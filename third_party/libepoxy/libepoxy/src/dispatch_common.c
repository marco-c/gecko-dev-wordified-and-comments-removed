#
include
<
assert
.
h
>
#
include
<
stdlib
.
h
>
#
ifdef
_WIN32
#
include
<
windows
.
h
>
#
else
#
include
<
dlfcn
.
h
>
#
include
<
err
.
h
>
#
include
<
pthread
.
h
>
#
endif
#
include
<
string
.
h
>
#
include
<
ctype
.
h
>
#
include
<
stdio
.
h
>
#
include
"
dispatch_common
.
h
"
#
if
defined
(
__APPLE__
)
#
define
GLX_LIB
"
/
opt
/
X11
/
lib
/
libGL
.
1
.
dylib
"
#
define
OPENGL_LIB
"
/
System
/
Library
/
Frameworks
/
OpenGL
.
framework
/
Versions
/
Current
/
OpenGL
"
#
define
GLES1_LIB
"
libGLESv1_CM
.
so
"
#
define
GLES2_LIB
"
libGLESv2
.
so
"
#
elif
defined
(
__ANDROID__
)
#
define
GLX_LIB
"
libGLESv2
.
so
"
#
define
EGL_LIB
"
libEGL
.
so
"
#
define
GLES1_LIB
"
libGLESv1_CM
.
so
"
#
define
GLES2_LIB
"
libGLESv2
.
so
"
#
elif
defined
(
_WIN32
)
#
define
EGL_LIB
"
libEGL
.
dll
"
#
define
GLES1_LIB
"
libGLES_CM
.
dll
"
#
define
GLES2_LIB
"
libGLESv2
.
dll
"
#
define
OPENGL_LIB
"
OPENGL32
"
#
else
#
define
GLVND_GLX_LIB
"
libGLX
.
so
.
1
"
#
define
GLX_LIB
"
libGL
.
so
.
1
"
#
define
EGL_LIB
"
libEGL
.
so
.
1
"
#
define
GLES1_LIB
"
libGLESv1_CM
.
so
.
1
"
#
define
GLES2_LIB
"
libGLESv2
.
so
.
2
"
#
define
OPENGL_LIB
"
libOpenGL
.
so
.
0
"
#
endif
#
ifdef
__GNUC__
#
define
CONSTRUCT
(
_func
)
static
void
_func
(
void
)
__attribute__
(
(
constructor
)
)
;
#
define
DESTRUCT
(
_func
)
static
void
_func
(
void
)
__attribute__
(
(
destructor
)
)
;
#
elif
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1500
)
#
define
CONSTRUCT
(
_func
)
\
static
void
_func
(
void
)
;
\
static
int
_func
#
#
_wrapper
(
void
)
{
_func
(
)
;
return
0
;
}
\
__pragma
(
section
(
"
.
CRT
XCU
"
read
)
)
\
__declspec
(
allocate
(
"
.
CRT
XCU
"
)
)
static
int
(
*
_array
#
#
_func
)
(
void
)
=
_func
#
#
_wrapper
;
#
define
DESTRUCT
(
_func
)
\
static
void
_func
(
void
)
;
\
static
int
_func
#
#
_constructor
(
void
)
{
atexit
(
_func
)
;
return
0
;
}
\
__pragma
(
section
(
"
.
CRT
XCU
"
read
)
)
\
__declspec
(
allocate
(
"
.
CRT
XCU
"
)
)
static
int
(
*
_array
#
#
_func
)
(
void
)
=
_func
#
#
_constructor
;
#
else
#
error
"
You
will
need
constructor
support
for
your
compiler
"
#
endif
struct
api
{
#
ifndef
_WIN32
pthread_mutex_t
mutex
;
#
endif
void
*
glx_handle
;
void
*
gl_handle
;
void
*
egl_handle
;
void
*
gles1_handle
;
void
*
gles2_handle
;
long
begin_count
;
}
;
static
struct
api
api
=
{
#
ifndef
_WIN32
.
mutex
=
PTHREAD_MUTEX_INITIALIZER
#
else
0
#
endif
}
;
static
bool
library_initialized
;
static
bool
epoxy_current_context_is_glx
(
void
)
;
#
if
PLATFORM_HAS_EGL
static
EGLenum
epoxy_egl_get_current_gl_context_api
(
void
)
;
#
endif
CONSTRUCT
(
library_init
)
static
void
library_init
(
void
)
{
library_initialized
=
true
;
}
static
bool
get_dlopen_handle
(
void
*
*
handle
const
char
*
lib_name
bool
exit_on_fail
bool
load
)
{
if
(
*
handle
)
return
true
;
if
(
!
library_initialized
)
{
fputs
(
"
Attempting
to
dlopen
(
)
while
in
the
dynamic
linker
.
\
n
"
stderr
)
;
abort
(
)
;
}
#
ifdef
_WIN32
*
handle
=
LoadLibraryA
(
lib_name
)
;
#
else
pthread_mutex_lock
(
&
api
.
mutex
)
;
if
(
!
*
handle
)
{
int
flags
=
RTLD_LAZY
|
RTLD_LOCAL
;
if
(
!
load
)
flags
|
=
RTLD_NOLOAD
;
*
handle
=
dlopen
(
lib_name
flags
)
;
if
(
!
*
handle
)
{
if
(
exit_on_fail
)
{
fprintf
(
stderr
"
Couldn
'
t
open
%
s
:
%
s
\
n
"
lib_name
dlerror
(
)
)
;
abort
(
)
;
}
else
{
(
void
)
dlerror
(
)
;
}
}
}
pthread_mutex_unlock
(
&
api
.
mutex
)
;
#
endif
return
*
handle
!
=
NULL
;
}
static
void
*
do_dlsym
(
void
*
*
handle
const
char
*
name
bool
exit_on_fail
)
{
void
*
result
;
const
char
*
error
=
"
"
;
#
ifdef
_WIN32
result
=
GetProcAddress
(
*
handle
name
)
;
#
else
result
=
dlsym
(
*
handle
name
)
;
if
(
!
result
)
error
=
dlerror
(
)
;
#
endif
if
(
!
result
&
&
exit_on_fail
)
{
fprintf
(
stderr
"
%
s
(
)
not
found
:
%
s
\
n
"
name
error
)
;
abort
(
)
;
}
return
result
;
}
bool
epoxy_is_desktop_gl
(
void
)
{
const
char
*
es_prefix
=
"
OpenGL
ES
"
;
const
char
*
version
;
#
if
PLATFORM_HAS_EGL
if
(
!
epoxy_current_context_is_glx
(
)
)
{
switch
(
epoxy_egl_get_current_gl_context_api
(
)
)
{
case
EGL_OPENGL_API
:
return
true
;
case
EGL_OPENGL_ES_API
:
return
false
;
case
EGL_NONE
:
default
:
break
;
}
}
#
endif
if
(
api
.
begin_count
)
return
true
;
version
=
(
const
char
*
)
glGetString
(
GL_VERSION
)
;
if
(
!
version
)
return
true
;
return
strncmp
(
es_prefix
version
strlen
(
es_prefix
)
)
;
}
static
int
epoxy_internal_gl_version
(
GLenum
version_string
int
error_version
int
factor
)
{
const
char
*
version
=
(
const
char
*
)
glGetString
(
version_string
)
;
GLint
major
minor
;
int
scanf_count
;
if
(
!
version
)
return
error_version
;
while
(
!
isdigit
(
*
version
)
&
&
*
version
!
=
'
\
0
'
)
version
+
+
;
scanf_count
=
sscanf
(
version
"
%
i
.
%
i
"
&
major
&
minor
)
;
if
(
scanf_count
!
=
2
)
{
fprintf
(
stderr
"
Unable
to
interpret
GL_VERSION
string
:
%
s
\
n
"
version
)
;
abort
(
)
;
}
return
factor
*
major
+
minor
;
}
int
epoxy_gl_version
(
void
)
{
return
epoxy_internal_gl_version
(
GL_VERSION
0
10
)
;
}
int
epoxy_conservative_gl_version
(
void
)
{
if
(
api
.
begin_count
)
return
100
;
return
epoxy_internal_gl_version
(
GL_VERSION
100
10
)
;
}
int
epoxy_glsl_version
(
void
)
{
if
(
epoxy_gl_version
(
)
>
=
20
|
|
epoxy_has_gl_extension
(
"
GL_ARB_shading_language_100
"
)
)
return
epoxy_internal_gl_version
(
GL_SHADING_LANGUAGE_VERSION
0
100
)
;
return
0
;
}
bool
epoxy_extension_in_string
(
const
char
*
extension_list
const
char
*
ext
)
{
const
char
*
ptr
=
extension_list
;
int
len
;
if
(
!
ext
)
return
false
;
len
=
strlen
(
ext
)
;
if
(
extension_list
=
=
NULL
|
|
*
extension_list
=
=
'
\
0
'
)
return
false
;
while
(
true
)
{
ptr
=
strstr
(
ptr
ext
)
;
if
(
!
ptr
)
return
false
;
if
(
ptr
[
len
]
=
=
'
'
|
|
ptr
[
len
]
=
=
0
)
return
true
;
ptr
+
=
len
;
}
}
static
bool
epoxy_internal_has_gl_extension
(
const
char
*
ext
bool
invalid_op_mode
)
{
if
(
epoxy_gl_version
(
)
<
30
)
{
const
char
*
exts
=
(
const
char
*
)
glGetString
(
GL_EXTENSIONS
)
;
if
(
!
exts
)
return
invalid_op_mode
;
return
epoxy_extension_in_string
(
exts
ext
)
;
}
else
{
int
num_extensions
;
int
i
;
glGetIntegerv
(
GL_NUM_EXTENSIONS
&
num_extensions
)
;
if
(
num_extensions
=
=
0
)
return
invalid_op_mode
;
for
(
i
=
0
;
i
<
num_extensions
;
i
+
+
)
{
const
char
*
gl_ext
=
(
const
char
*
)
glGetStringi
(
GL_EXTENSIONS
i
)
;
if
(
!
gl_ext
)
return
false
;
if
(
strcmp
(
ext
gl_ext
)
=
=
0
)
return
true
;
}
return
false
;
}
}
bool
epoxy_load_glx
(
bool
exit_if_fails
bool
load
)
{
#
if
PLATFORM_HAS_GLX
#
ifdef
GLVND_GLX_LIB
if
(
!
api
.
glx_handle
)
get_dlopen_handle
(
&
api
.
glx_handle
GLVND_GLX_LIB
false
load
)
;
#
endif
if
(
!
api
.
glx_handle
)
get_dlopen_handle
(
&
api
.
glx_handle
GLX_LIB
exit_if_fails
load
)
;
#
endif
return
api
.
glx_handle
!
=
NULL
;
}
void
*
epoxy_conservative_glx_dlsym
(
const
char
*
name
bool
exit_if_fails
)
{
#
if
PLATFORM_HAS_GLX
if
(
epoxy_load_glx
(
exit_if_fails
exit_if_fails
)
)
return
do_dlsym
(
&
api
.
glx_handle
name
exit_if_fails
)
;
#
endif
return
NULL
;
}
static
bool
epoxy_current_context_is_glx
(
void
)
{
#
if
!
PLATFORM_HAS_GLX
return
false
;
#
else
void
*
sym
;
sym
=
epoxy_conservative_glx_dlsym
(
"
glXGetCurrentContext
"
false
)
;
if
(
sym
)
{
if
(
glXGetCurrentContext
(
)
)
return
true
;
}
else
{
(
void
)
dlerror
(
)
;
}
#
if
PLATFORM_HAS_EGL
sym
=
epoxy_conservative_egl_dlsym
(
"
eglGetCurrentContext
"
false
)
;
if
(
sym
)
{
if
(
epoxy_egl_get_current_gl_context_api
(
)
!
=
EGL_NONE
)
return
false
;
}
else
{
(
void
)
dlerror
(
)
;
}
#
endif
return
false
;
#
endif
}
bool
epoxy_has_gl_extension
(
const
char
*
ext
)
{
return
epoxy_internal_has_gl_extension
(
ext
false
)
;
}
bool
epoxy_conservative_has_gl_extension
(
const
char
*
ext
)
{
if
(
api
.
begin_count
)
return
true
;
return
epoxy_internal_has_gl_extension
(
ext
true
)
;
}
bool
epoxy_load_egl
(
bool
exit_if_fails
bool
load
)
{
#
if
PLATFORM_HAS_EGL
return
get_dlopen_handle
(
&
api
.
egl_handle
EGL_LIB
exit_if_fails
load
)
;
#
else
return
false
;
#
endif
}
void
*
epoxy_conservative_egl_dlsym
(
const
char
*
name
bool
exit_if_fails
)
{
#
if
PLATFORM_HAS_EGL
if
(
epoxy_load_egl
(
exit_if_fails
exit_if_fails
)
)
return
do_dlsym
(
&
api
.
egl_handle
name
exit_if_fails
)
;
#
endif
return
NULL
;
}
void
*
epoxy_egl_dlsym
(
const
char
*
name
)
{
return
epoxy_conservative_egl_dlsym
(
name
true
)
;
}
void
*
epoxy_glx_dlsym
(
const
char
*
name
)
{
return
epoxy_conservative_glx_dlsym
(
name
true
)
;
}
static
void
epoxy_load_gl
(
void
)
{
if
(
api
.
gl_handle
)
return
;
#
if
defined
(
_WIN32
)
|
|
defined
(
__APPLE__
)
get_dlopen_handle
(
&
api
.
gl_handle
OPENGL_LIB
true
true
)
;
#
else
get_dlopen_handle
(
&
api
.
glx_handle
GLX_LIB
false
true
)
;
api
.
gl_handle
=
api
.
glx_handle
;
#
if
defined
(
OPENGL_LIB
)
if
(
!
api
.
gl_handle
)
get_dlopen_handle
(
&
api
.
gl_handle
OPENGL_LIB
false
true
)
;
#
endif
if
(
!
api
.
gl_handle
)
{
#
if
defined
(
OPENGL_LIB
)
fprintf
(
stderr
"
Couldn
'
t
open
%
s
or
%
s
\
n
"
GLX_LIB
OPENGL_LIB
)
;
#
else
fprintf
(
stderr
"
Couldn
'
t
open
%
s
\
n
"
GLX_LIB
)
;
#
endif
abort
(
)
;
}
#
endif
}
void
*
epoxy_gl_dlsym
(
const
char
*
name
)
{
epoxy_load_gl
(
)
;
return
do_dlsym
(
&
api
.
gl_handle
name
true
)
;
}
void
*
epoxy_gles1_dlsym
(
const
char
*
name
)
{
if
(
epoxy_current_context_is_glx
(
)
)
{
return
epoxy_get_proc_address
(
name
)
;
}
else
{
get_dlopen_handle
(
&
api
.
gles1_handle
GLES1_LIB
true
true
)
;
return
do_dlsym
(
&
api
.
gles1_handle
name
true
)
;
}
}
void
*
epoxy_gles2_dlsym
(
const
char
*
name
)
{
if
(
epoxy_current_context_is_glx
(
)
)
{
return
epoxy_get_proc_address
(
name
)
;
}
else
{
get_dlopen_handle
(
&
api
.
gles2_handle
GLES2_LIB
true
true
)
;
return
do_dlsym
(
&
api
.
gles2_handle
name
true
)
;
}
}
void
*
epoxy_gles3_dlsym
(
const
char
*
name
)
{
if
(
epoxy_current_context_is_glx
(
)
)
{
return
epoxy_get_proc_address
(
name
)
;
}
else
{
if
(
get_dlopen_handle
(
&
api
.
gles2_handle
GLES2_LIB
false
true
)
)
{
void
*
func
=
do_dlsym
(
&
api
.
gles2_handle
name
false
)
;
if
(
func
)
return
func
;
}
return
epoxy_get_proc_address
(
name
)
;
}
}
void
*
epoxy_get_core_proc_address
(
const
char
*
name
int
core_version
)
{
#
ifdef
_WIN32
int
core_symbol_support
=
11
;
#
elif
defined
(
__ANDROID__
)
int
core_symbol_support
=
0
;
#
else
int
core_symbol_support
=
12
;
#
endif
if
(
core_version
<
=
core_symbol_support
)
{
return
epoxy_gl_dlsym
(
name
)
;
}
else
{
return
epoxy_get_proc_address
(
name
)
;
}
}
#
if
PLATFORM_HAS_EGL
static
EGLenum
epoxy_egl_get_current_gl_context_api
(
void
)
{
EGLint
curapi
;
if
(
!
api
.
egl_handle
)
return
EGL_NONE
;
if
(
eglQueryContext
(
eglGetCurrentDisplay
(
)
eglGetCurrentContext
(
)
EGL_CONTEXT_CLIENT_TYPE
&
curapi
)
=
=
EGL_FALSE
)
{
(
void
)
eglGetError
(
)
;
return
EGL_NONE
;
}
return
(
EGLenum
)
curapi
;
}
#
endif
void
*
epoxy_get_bootstrap_proc_address
(
const
char
*
name
)
{
#
if
PLATFORM_HAS_GLX
if
(
api
.
glx_handle
&
&
glXGetCurrentContext
(
)
)
return
epoxy_gl_dlsym
(
name
)
;
#
endif
#
if
PLATFORM_HAS_EGL
get_dlopen_handle
(
&
api
.
egl_handle
EGL_LIB
false
true
)
;
if
(
api
.
egl_handle
)
{
int
version
=
0
;
switch
(
epoxy_egl_get_current_gl_context_api
(
)
)
{
case
EGL_OPENGL_API
:
return
epoxy_gl_dlsym
(
name
)
;
case
EGL_OPENGL_ES_API
:
if
(
eglQueryContext
(
eglGetCurrentDisplay
(
)
eglGetCurrentContext
(
)
EGL_CONTEXT_CLIENT_VERSION
&
version
)
)
{
if
(
version
>
=
2
)
return
epoxy_gles2_dlsym
(
name
)
;
else
return
epoxy_gles1_dlsym
(
name
)
;
}
}
}
#
endif
return
epoxy_gl_dlsym
(
name
)
;
}
void
*
epoxy_get_proc_address
(
const
char
*
name
)
{
#
if
PLATFORM_HAS_EGL
GLenum
egl_api
=
EGL_NONE
;
if
(
!
epoxy_current_context_is_glx
(
)
)
egl_api
=
epoxy_egl_get_current_gl_context_api
(
)
;
switch
(
egl_api
)
{
case
EGL_OPENGL_API
:
case
EGL_OPENGL_ES_API
:
return
eglGetProcAddress
(
name
)
;
case
EGL_NONE
:
break
;
}
#
endif
#
if
defined
(
_WIN32
)
return
wglGetProcAddress
(
name
)
;
#
elif
defined
(
__APPLE__
)
return
epoxy_gl_dlsym
(
name
)
;
#
elif
PLATFORM_HAS_GLX
if
(
epoxy_current_context_is_glx
(
)
)
return
glXGetProcAddressARB
(
(
const
GLubyte
*
)
name
)
;
assert
(
0
&
&
"
Couldn
'
t
find
current
GLX
or
EGL
context
.
\
n
"
)
;
#
endif
return
NULL
;
}
WRAPPER_VISIBILITY
(
void
)
WRAPPER
(
epoxy_glBegin
)
(
GLenum
primtype
)
{
#
ifdef
_WIN32
InterlockedIncrement
(
&
api
.
begin_count
)
;
#
else
pthread_mutex_lock
(
&
api
.
mutex
)
;
api
.
begin_count
+
+
;
pthread_mutex_unlock
(
&
api
.
mutex
)
;
#
endif
epoxy_glBegin_unwrapped
(
primtype
)
;
}
WRAPPER_VISIBILITY
(
void
)
WRAPPER
(
epoxy_glEnd
)
(
void
)
{
epoxy_glEnd_unwrapped
(
)
;
#
ifdef
_WIN32
InterlockedDecrement
(
&
api
.
begin_count
)
;
#
else
pthread_mutex_lock
(
&
api
.
mutex
)
;
api
.
begin_count
-
-
;
pthread_mutex_unlock
(
&
api
.
mutex
)
;
#
endif
}
PFNGLBEGINPROC
epoxy_glBegin
=
epoxy_glBegin_wrapped
;
PFNGLENDPROC
epoxy_glEnd
=
epoxy_glEnd_wrapped
;
epoxy_resolver_failure_handler_t
epoxy_resolver_failure_handler
;
epoxy_resolver_failure_handler_t
epoxy_set_resolver_failure_handler
(
epoxy_resolver_failure_handler_t
handler
)
{
#
ifdef
_WIN32
return
InterlockedExchangePointer
(
(
void
*
*
)
&
epoxy_resolver_failure_handler
handler
)
;
#
else
epoxy_resolver_failure_handler_t
old
;
pthread_mutex_lock
(
&
api
.
mutex
)
;
old
=
epoxy_resolver_failure_handler
;
epoxy_resolver_failure_handler
=
handler
;
pthread_mutex_unlock
(
&
api
.
mutex
)
;
return
old
;
#
endif
}
