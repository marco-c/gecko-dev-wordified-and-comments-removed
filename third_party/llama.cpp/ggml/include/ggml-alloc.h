#
pragma
once
#
include
"
ggml
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
typedef
struct
ggml_backend_buffer_type
*
ggml_backend_buffer_type_t
;
typedef
struct
ggml_backend_buffer
*
ggml_backend_buffer_t
;
typedef
struct
ggml_backend
*
ggml_backend_t
;
struct
ggml_tallocr
{
ggml_backend_buffer_t
buffer
;
void
*
base
;
size_t
alignment
;
size_t
offset
;
}
;
GGML_API
struct
ggml_tallocr
ggml_tallocr_new
(
ggml_backend_buffer_t
buffer
)
;
GGML_API
enum
ggml_status
ggml_tallocr_alloc
(
struct
ggml_tallocr
*
talloc
struct
ggml_tensor
*
tensor
)
;
typedef
struct
ggml_gallocr
*
ggml_gallocr_t
;
GGML_API
ggml_gallocr_t
ggml_gallocr_new
(
ggml_backend_buffer_type_t
buft
)
;
GGML_API
ggml_gallocr_t
ggml_gallocr_new_n
(
ggml_backend_buffer_type_t
*
bufts
int
n_bufs
)
;
GGML_API
void
ggml_gallocr_free
(
ggml_gallocr_t
galloc
)
;
GGML_API
bool
ggml_gallocr_reserve
(
ggml_gallocr_t
galloc
struct
ggml_cgraph
*
graph
)
;
GGML_API
bool
ggml_gallocr_reserve_n
(
ggml_gallocr_t
galloc
struct
ggml_cgraph
*
graph
const
int
*
node_buffer_ids
const
int
*
leaf_buffer_ids
)
;
GGML_API
bool
ggml_gallocr_alloc_graph
(
ggml_gallocr_t
galloc
struct
ggml_cgraph
*
graph
)
;
GGML_API
size_t
ggml_gallocr_get_buffer_size
(
ggml_gallocr_t
galloc
int
buffer_id
)
;
GGML_API
struct
ggml_backend_buffer
*
ggml_backend_alloc_ctx_tensors_from_buft
(
struct
ggml_context
*
ctx
ggml_backend_buffer_type_t
buft
)
;
GGML_API
struct
ggml_backend_buffer
*
ggml_backend_alloc_ctx_tensors
(
struct
ggml_context
*
ctx
ggml_backend_t
backend
)
;
#
ifdef
__cplusplus
}
#
endif
