#
pragma
once
#
include
"
ggml
.
h
"
#
include
"
ggml
-
backend
.
h
"
#
include
<
stdint
.
h
>
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
struct
ggml_opt_dataset
;
struct
ggml_opt_context
;
struct
ggml_opt_result
;
typedef
struct
ggml_opt_dataset
*
ggml_opt_dataset_t
;
typedef
struct
ggml_opt_context
*
ggml_opt_context_t
;
typedef
struct
ggml_opt_result
*
ggml_opt_result_t
;
enum
ggml_opt_loss_type
{
GGML_OPT_LOSS_TYPE_MEAN
GGML_OPT_LOSS_TYPE_SUM
GGML_OPT_LOSS_TYPE_CROSS_ENTROPY
GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR
}
;
GGML_API
ggml_opt_dataset_t
ggml_opt_dataset_init
(
enum
ggml_type
type_data
enum
ggml_type
type_label
int64_t
ne_datapoint
int64_t
ne_label
int64_t
ndata
int64_t
ndata_shard
)
;
GGML_API
void
ggml_opt_dataset_free
(
ggml_opt_dataset_t
dataset
)
;
GGML_API
int64_t
ggml_opt_dataset_ndata
(
ggml_opt_dataset_t
dataset
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_dataset_data
(
ggml_opt_dataset_t
dataset
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_dataset_labels
(
ggml_opt_dataset_t
dataset
)
;
GGML_API
void
ggml_opt_dataset_shuffle
(
ggml_opt_context_t
opt_ctx
ggml_opt_dataset_t
dataset
int64_t
idata
)
;
GGML_API
void
ggml_opt_dataset_get_batch
(
ggml_opt_dataset_t
dataset
struct
ggml_tensor
*
data_batch
struct
ggml_tensor
*
labels_batch
int64_t
ibatch
)
;
GGML_API
void
ggml_opt_dataset_get_batch_host
(
ggml_opt_dataset_t
dataset
void
*
data_batch
size_t
nb_data_batch
void
*
labels_batch
int64_t
ibatch
)
;
enum
ggml_opt_build_type
{
GGML_OPT_BUILD_TYPE_FORWARD
=
10
GGML_OPT_BUILD_TYPE_GRAD
=
20
GGML_OPT_BUILD_TYPE_OPT
=
30
}
;
enum
ggml_opt_optimizer_type
{
GGML_OPT_OPTIMIZER_TYPE_ADAMW
GGML_OPT_OPTIMIZER_TYPE_SGD
GGML_OPT_OPTIMIZER_TYPE_COUNT
}
;
struct
ggml_opt_optimizer_params
{
struct
{
float
alpha
;
float
beta1
;
float
beta2
;
float
eps
;
float
wd
;
}
adamw
;
struct
{
float
alpha
;
float
wd
;
}
sgd
;
}
;
typedef
struct
ggml_opt_optimizer_params
(
*
ggml_opt_get_optimizer_params
)
(
void
*
userdata
)
;
GGML_API
struct
ggml_opt_optimizer_params
ggml_opt_get_default_optimizer_params
(
void
*
userdata
)
;
GGML_API
struct
ggml_opt_optimizer_params
ggml_opt_get_constant_optimizer_params
(
void
*
userdata
)
;
struct
ggml_opt_params
{
ggml_backend_sched_t
backend_sched
;
struct
ggml_context
*
ctx_compute
;
struct
ggml_tensor
*
inputs
;
struct
ggml_tensor
*
outputs
;
enum
ggml_opt_loss_type
loss_type
;
enum
ggml_opt_build_type
build_type
;
int32_t
opt_period
;
ggml_opt_get_optimizer_params
get_opt_pars
;
void
*
get_opt_pars_ud
;
enum
ggml_opt_optimizer_type
optimizer
;
}
;
GGML_API
struct
ggml_opt_params
ggml_opt_default_params
(
ggml_backend_sched_t
backend_sched
enum
ggml_opt_loss_type
loss_type
)
;
GGML_API
ggml_opt_context_t
ggml_opt_init
(
struct
ggml_opt_params
params
)
;
GGML_API
void
ggml_opt_free
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
void
ggml_opt_reset
(
ggml_opt_context_t
opt_ctx
bool
optimizer
)
;
GGML_API
bool
ggml_opt_static_graphs
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_inputs
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_outputs
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_labels
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_loss
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_pred
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_ncorrect
(
ggml_opt_context_t
opt_ctx
)
;
GGML_API
struct
ggml_tensor
*
ggml_opt_grad_acc
(
ggml_opt_context_t
opt_ctx
struct
ggml_tensor
*
node
)
;
GGML_API
enum
ggml_opt_optimizer_type
ggml_opt_context_optimizer_type
(
ggml_opt_context_t
)
;
GGML_API
const
char
*
ggml_opt_optimizer_name
(
enum
ggml_opt_optimizer_type
)
;
GGML_API
ggml_opt_result_t
ggml_opt_result_init
(
void
)
;
GGML_API
void
ggml_opt_result_free
(
ggml_opt_result_t
result
)
;
GGML_API
void
ggml_opt_result_reset
(
ggml_opt_result_t
result
)
;
GGML_API
void
ggml_opt_result_ndata
(
ggml_opt_result_t
result
int64_t
*
ndata
)
;
GGML_API
void
ggml_opt_result_loss
(
ggml_opt_result_t
result
double
*
loss
double
*
unc
)
;
GGML_API
void
ggml_opt_result_pred
(
ggml_opt_result_t
result
int32_t
*
pred
)
;
GGML_API
void
ggml_opt_result_accuracy
(
ggml_opt_result_t
result
double
*
accuracy
double
*
unc
)
;
GGML_API
void
ggml_opt_prepare_alloc
(
ggml_opt_context_t
opt_ctx
struct
ggml_context
*
ctx_compute
struct
ggml_cgraph
*
gf
struct
ggml_tensor
*
inputs
struct
ggml_tensor
*
outputs
)
;
GGML_API
void
ggml_opt_alloc
(
ggml_opt_context_t
opt_ctx
bool
backward
)
;
GGML_API
void
ggml_opt_eval
(
ggml_opt_context_t
opt_ctx
ggml_opt_result_t
result
)
;
typedef
void
(
*
ggml_opt_epoch_callback
)
(
bool
train
ggml_opt_context_t
opt_ctx
ggml_opt_dataset_t
dataset
ggml_opt_result_t
result
int64_t
ibatch
int64_t
ibatch_max
int64_t
t_start_us
)
;
GGML_API
void
ggml_opt_epoch
(
ggml_opt_context_t
opt_ctx
ggml_opt_dataset_t
dataset
ggml_opt_result_t
result_train
ggml_opt_result_t
result_eval
int64_t
idata_split
ggml_opt_epoch_callback
callback_train
ggml_opt_epoch_callback
callback_eval
)
;
GGML_API
void
ggml_opt_epoch_callback_progress_bar
(
bool
train
ggml_opt_context_t
opt_ctx
ggml_opt_dataset_t
dataset
ggml_opt_result_t
result
int64_t
ibatch
int64_t
ibatch_max
int64_t
t_start_us
)
;
GGML_API
void
ggml_opt_fit
(
ggml_backend_sched_t
backend_sched
struct
ggml_context
*
ctx_compute
struct
ggml_tensor
*
inputs
struct
ggml_tensor
*
outputs
ggml_opt_dataset_t
dataset
enum
ggml_opt_loss_type
loss_type
enum
ggml_opt_optimizer_type
optimizer
ggml_opt_get_optimizer_params
get_opt_pars
int64_t
nepoch
int64_t
nbatch_logical
float
val_split
bool
silent
)
;
#
ifdef
__cplusplus
}
#
endif
