#
include
"
hedley
.
h
"
#
include
"
simde
-
common
.
h
"
#
include
"
simde
-
detect
-
clang
.
h
"
#
if
!
defined
(
SIMDE_FLOAT16_H
)
#
define
SIMDE_FLOAT16_H
HEDLEY_DIAGNOSTIC_PUSH
SIMDE_DISABLE_UNWANTED_DIAGNOSTICS
SIMDE_BEGIN_DECLS_
#
define
SIMDE_FLOAT16_API_PORTABLE
1
#
define
SIMDE_FLOAT16_API_FLOAT16
2
#
define
SIMDE_FLOAT16_API_FP16_NO_ABI
3
#
define
SIMDE_FLOAT16_API_FP16
4
#
if
!
defined
(
SIMDE_FLOAT16_API
)
#
if
0
&
&
!
defined
(
__cplusplus
)
#
define
SIMDE_FLOAT16_API
SIMDE_FLOAT16_API_FLOAT16
#
elif
defined
(
__ARM_FP16_FORMAT_IEEE
)
&
&
defined
(
SIMDE_ARM_NEON_FP16
)
#
define
SIMDE_FLOAT16_API
SIMDE_FLOAT16_API_FP16
#
elif
defined
(
__FLT16_MIN__
)
&
&
(
defined
(
__clang__
)
&
&
(
!
defined
(
SIMDE_ARCH_AARCH64
)
|
|
SIMDE_DETECT_CLANG_VERSION_CHECK
(
7
0
0
)
)
)
#
define
SIMDE_FLOAT16_API
SIMDE_FLOAT16_API_FP16_NO_ABI
#
else
#
define
SIMDE_FLOAT16_API
SIMDE_FLOAT16_API_PORTABLE
#
endif
#
endif
#
if
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_FLOAT16
typedef
_Float16
simde_float16
;
#
define
SIMDE_FLOAT16_C
(
value
)
value
#
#
f16
#
elif
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_FP16_NO_ABI
typedef
struct
{
__fp16
value
;
}
simde_float16
;
#
if
defined
(
SIMDE_STATEMENT_EXPR_
)
#
define
SIMDE_FLOAT16_C
(
value
)
(
__extension__
(
{
(
(
simde_float16
)
{
HEDLEY_DIAGNOSTIC_PUSH
SIMDE_DIAGNOSTIC_DISABLE_C99_EXTENSIONS_
HEDLEY_STATIC_CAST
(
__fp16
(
value
)
)
}
)
;
HEDLEY_DIAGNOSTIC_POP
}
)
)
#
else
#
define
SIMDE_FLOAT16_C
(
value
)
(
(
simde_float16
)
{
HEDLEY_STATIC_CAST
(
__fp16
(
value
)
)
}
)
#
endif
#
elif
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_FP16
typedef
__fp16
simde_float16
;
#
define
SIMDE_FLOAT16_C
(
value
)
HEDLEY_STATIC_CAST
(
__fp16
(
value
)
)
#
elif
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_PORTABLE
typedef
struct
{
uint16_t
value
;
}
simde_float16
;
#
else
#
error
No
16
-
bit
floating
point
API
.
#
endif
#
if
\
defined
(
SIMDE_VECTOR_OPS
)
&
&
\
(
SIMDE_FLOAT16_API
!
=
SIMDE_FLOAT16_API_PORTABLE
)
&
&
\
(
SIMDE_FLOAT16_API
!
=
SIMDE_FLOAT16_API_FP16_NO_ABI
)
#
define
SIMDE_FLOAT16_VECTOR
#
endif
SIMDE_DEFINE_CONVERSION_FUNCTION_
(
simde_float16_as_uint16
uint16_t
simde_float16
)
SIMDE_DEFINE_CONVERSION_FUNCTION_
(
simde_uint16_as_float16
simde_float16
uint16_t
)
#
define
SIMDE_NANHF
simde_uint16_as_float16
(
0x7E00
)
#
define
SIMDE_INFINITYHF
simde_uint16_as_float16
(
0x7C00
)
static
HEDLEY_ALWAYS_INLINE
HEDLEY_CONST
simde_float16
simde_float16_from_float32
(
simde_float32
value
)
{
simde_float16
res
;
#
if
\
(
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_FLOAT16
)
|
|
\
(
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_FP16
)
res
=
HEDLEY_STATIC_CAST
(
simde_float16
value
)
;
#
elif
(
SIMDE_FLOAT16_API
=
=
SIMDE_FLOAT16_API_FP16_NO_ABI
)
res
.
value
=
HEDLEY_STATIC_CAST
(
__fp16
value
)
;
#
else
uint32_t
f32u
=
simde_float32_as_uint32
(
value
)
;
static
const
uint32_t
f32u_infty
=
UINT32_C
(
255
)
<
<
23
;
static
const
uint32_t
f16u_max
=
(
UINT32_C
(
127
)
+
UINT32_C
(
16
)
)
<
<
23
;
static
const
uint32_t
denorm_magic
=
(
(
UINT32_C
(
127
)
-
UINT32_C
(
15
)
)
+
(
UINT32_C
(
23
)
-
UINT32_C
(
10
)
)
+
UINT32_C
(
1
)
)
<
<
23
;
uint16_t
f16u
;
uint32_t
sign
=
f32u
&
(
UINT32_C
(
1
)
<
<
31
)
;
f32u
^
=
sign
;
if
(
f32u
>
f16u_max
)
{
f16u
=
(
f32u
>
f32u_infty
)
?
UINT32_C
(
0x7e00
)
:
UINT32_C
(
0x7c00
)
;
}
else
{
if
(
f32u
<
(
UINT32_C
(
113
)
<
<
23
)
)
{
f32u
=
simde_float32_as_uint32
(
simde_uint32_as_float32
(
f32u
)
+
simde_uint32_as_float32
(
denorm_magic
)
)
;
f16u
=
HEDLEY_STATIC_CAST
(
uint16_t
f32u
-
denorm_magic
)
;
}
else
{
uint32_t
mant_odd
=
(
f32u
>
>
13
)
&
1
;
f32u
+
=
(
HEDLEY_STATIC_CAST
(
uint32_t
15
-
127
)
<
<
23
)
+
UINT32_C
(
0xfff
)
;
f32u
+
=
mant_odd
;
f16u
=
HEDLEY_STATIC_CAST
(
uint16_t
f32u
>
>
13
)
;
}
}
f16u
|
=
sign
>
>
16
;
res
=
simde_uint16_as_float16
(
f16u
)
;
#
endif
return
res
;
}
static
HEDLEY_ALWAYS_INLINE
HEDLEY_CONST
simde_float32
simde_float16_to_float32
(
simde_float16
value
)
{
simde_float32
res
;
#
if
defined
(
SIMDE_FLOAT16_FLOAT16
)
|
|
defined
(
SIMDE_FLOAT16_FP16
)
res
=
HEDLEY_STATIC_CAST
(
simde_float32
value
)
;
#
else
uint16_t
half
=
simde_float16_as_uint16
(
value
)
;
const
simde_float32
denorm_magic
=
simde_uint32_as_float32
(
(
UINT32_C
(
113
)
<
<
23
)
)
;
const
uint32_t
shifted_exp
=
UINT32_C
(
0x7c00
)
<
<
13
;
uint32_t
f32u
;
f32u
=
(
half
&
UINT32_C
(
0x7fff
)
)
<
<
13
;
uint32_t
exp
=
shifted_exp
&
f32u
;
f32u
+
=
(
UINT32_C
(
127
)
-
UINT32_C
(
15
)
)
<
<
23
;
if
(
exp
=
=
shifted_exp
)
f32u
+
=
(
UINT32_C
(
128
)
-
UINT32_C
(
16
)
)
<
<
23
;
else
if
(
exp
=
=
0
)
{
f32u
+
=
(
1
)
<
<
23
;
f32u
=
simde_float32_as_uint32
(
simde_uint32_as_float32
(
f32u
)
-
denorm_magic
)
;
}
f32u
|
=
(
half
&
UINT32_C
(
0x8000
)
)
<
<
16
;
res
=
simde_uint32_as_float32
(
f32u
)
;
#
endif
return
res
;
}
#
ifdef
SIMDE_FLOAT16_C
#
define
SIMDE_FLOAT16_VALUE
(
value
)
SIMDE_FLOAT16_C
(
value
)
#
else
#
define
SIMDE_FLOAT16_VALUE
(
value
)
simde_float16_from_float32
(
SIMDE_FLOAT32_C
(
value
)
)
#
endif
SIMDE_END_DECLS_
HEDLEY_DIAGNOSTIC_POP
#
endif
