#
if
defined
(
PSUTIL_NETBSD
)
#
define
_KMEMUSER
#
endif
#
include
<
Python
.
h
>
#
include
<
assert
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
signal
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
paths
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
param
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
if
!
defined
(
__NetBSD__
)
#
include
<
sys
/
user
.
h
>
#
endif
#
include
<
sys
/
proc
.
h
>
#
include
<
sys
/
file
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
net
/
route
.
h
>
#
include
<
sys
/
socketvar
.
h
>
#
include
<
sys
/
un
.
h
>
#
include
<
sys
/
unpcb
.
h
>
#
include
<
netinet
/
in
.
h
>
#
include
<
netinet
/
in_systm
.
h
>
#
include
<
netinet
/
ip
.
h
>
#
include
<
netinet
/
in_pcb
.
h
>
#
include
<
netinet
/
tcp
.
h
>
#
include
<
netinet
/
tcp_timer
.
h
>
#
include
<
netinet
/
ip_var
.
h
>
#
include
<
netinet
/
tcp_var
.
h
>
#
include
<
netinet
/
tcp_fsm
.
h
>
#
include
<
arpa
/
inet
.
h
>
#
include
<
sys
/
mount
.
h
>
#
include
<
net
/
if
.
h
>
#
include
<
net
/
if_dl
.
h
>
#
include
<
net
/
route
.
h
>
#
include
<
netinet
/
in
.
h
>
#
include
<
sys
/
un
.
h
>
#
include
"
_psutil_common
.
h
"
#
include
"
_psutil_posix
.
h
"
#
ifdef
PSUTIL_FREEBSD
#
include
"
arch
/
freebsd
/
specific
.
h
"
#
include
"
arch
/
freebsd
/
sys_socks
.
h
"
#
include
"
arch
/
freebsd
/
proc_socks
.
h
"
#
include
<
net
/
if_media
.
h
>
#
include
<
devstat
.
h
>
#
include
<
libutil
.
h
>
#
if
__FreeBSD_version
<
900000
#
include
<
utmp
.
h
>
#
else
#
include
<
utmpx
.
h
>
#
endif
#
elif
PSUTIL_OPENBSD
#
include
"
arch
/
openbsd
/
specific
.
h
"
#
include
<
utmp
.
h
>
#
include
<
sys
/
vnode
.
h
>
#
define
_KERNEL
#
include
<
sys
/
file
.
h
>
#
undef
_KERNEL
#
include
<
sys
/
sched
.
h
>
#
elif
PSUTIL_NETBSD
#
include
"
arch
/
netbsd
/
specific
.
h
"
#
include
"
arch
/
netbsd
/
socks
.
h
"
#
include
<
utmpx
.
h
>
#
include
<
sys
/
vnode
.
h
>
#
include
<
sys
/
sched
.
h
>
#
ifndef
DTYPE_VNODE
#
define
DTYPE_VNODE
1
#
endif
#
endif
#
define
PSUTIL_TV2DOUBLE
(
t
)
(
(
t
)
.
tv_sec
+
(
t
)
.
tv_usec
/
1000000
.
0
)
#
ifdef
PSUTIL_FREEBSD
#
define
PSUTIL_BT2MSEC
(
bt
)
(
bt
.
sec
*
1000
+
(
(
(
uint64_t
)
1000000000
*
\
(
uint32_t
)
(
bt
.
frac
>
>
32
)
)
>
>
32
)
/
1000000
)
#
endif
#
if
defined
(
PSUTIL_OPENBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
#
define
PSUTIL_KPT2DOUBLE
(
t
)
(
t
#
#
_sec
+
t
#
#
_usec
/
1000000
.
0
)
#
endif
static
PyObject
*
psutil_pids
(
PyObject
*
self
PyObject
*
args
)
{
kinfo_proc
*
proclist
=
NULL
;
kinfo_proc
*
orig_address
=
NULL
;
size_t
num_processes
;
size_t
idx
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_pid
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
if
(
psutil_get_proc_list
(
&
proclist
&
num_processes
)
!
=
0
)
{
if
(
errno
!
=
0
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
}
else
{
PyErr_SetString
(
PyExc_RuntimeError
"
failed
to
retrieve
process
list
"
)
;
}
goto
error
;
}
if
(
num_processes
>
0
)
{
orig_address
=
proclist
;
for
(
idx
=
0
;
idx
<
num_processes
;
idx
+
+
)
{
#
ifdef
PSUTIL_FREEBSD
py_pid
=
Py_BuildValue
(
"
i
"
proclist
-
>
ki_pid
)
;
#
elif
defined
(
PSUTIL_OPENBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
py_pid
=
Py_BuildValue
(
"
i
"
proclist
-
>
p_pid
)
;
#
endif
if
(
!
py_pid
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_pid
)
)
goto
error
;
Py_DECREF
(
py_pid
)
;
proclist
+
+
;
}
free
(
orig_address
)
;
}
return
py_retlist
;
error
:
Py_XDECREF
(
py_pid
)
;
Py_DECREF
(
py_retlist
)
;
if
(
orig_address
!
=
NULL
)
free
(
orig_address
)
;
return
NULL
;
}
static
PyObject
*
psutil_boot_time
(
PyObject
*
self
PyObject
*
args
)
{
static
int
request
[
2
]
=
{
CTL_KERN
KERN_BOOTTIME
}
;
struct
timeval
boottime
;
size_t
len
=
sizeof
(
boottime
)
;
if
(
sysctl
(
request
2
&
boottime
&
len
NULL
0
)
=
=
-
1
)
return
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
Py_BuildValue
(
"
d
"
(
double
)
boottime
.
tv_sec
)
;
}
static
PyObject
*
psutil_proc_oneshot_info
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
long
rss
;
long
vms
;
long
memtext
;
long
memdata
;
long
memstack
;
int
oncpu
;
kinfo_proc
kp
;
long
pagesize
=
sysconf
(
_SC_PAGESIZE
)
;
char
str
[
1000
]
;
PyObject
*
py_name
;
PyObject
*
py_retlist
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
psutil_kinfo_proc
(
pid
&
kp
)
=
=
-
1
)
return
NULL
;
#
ifdef
PSUTIL_FREEBSD
sprintf
(
str
"
%
s
"
kp
.
ki_comm
)
;
#
elif
defined
(
PSUTIL_OPENBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
sprintf
(
str
"
%
s
"
kp
.
p_comm
)
;
#
endif
py_name
=
PyUnicode_DecodeFSDefault
(
str
)
;
if
(
!
py_name
)
{
PyErr_Clear
(
)
;
py_name
=
Py_None
;
}
#
ifdef
PSUTIL_FREEBSD
rss
=
(
long
)
kp
.
ki_rssize
*
pagesize
;
vms
=
(
long
)
kp
.
ki_size
;
memtext
=
(
long
)
kp
.
ki_tsize
*
pagesize
;
memdata
=
(
long
)
kp
.
ki_dsize
*
pagesize
;
memstack
=
(
long
)
kp
.
ki_ssize
*
pagesize
;
#
else
rss
=
(
long
)
kp
.
p_vm_rssize
*
pagesize
;
#
ifdef
PSUTIL_OPENBSD
vms
=
(
long
)
(
kp
.
p_vm_dsize
+
kp
.
p_vm_ssize
+
kp
.
p_vm_tsize
)
*
pagesize
;
#
elif
PSUTIL_NETBSD
vms
=
(
long
)
kp
.
p_vm_msize
*
pagesize
;
#
endif
memtext
=
(
long
)
kp
.
p_vm_tsize
*
pagesize
;
memdata
=
(
long
)
kp
.
p_vm_dsize
*
pagesize
;
memstack
=
(
long
)
kp
.
p_vm_ssize
*
pagesize
;
#
endif
#
ifdef
PSUTIL_FREEBSD
if
(
kp
.
ki_stat
=
=
SRUN
&
&
kp
.
ki_oncpu
!
=
NOCPU
)
oncpu
=
kp
.
ki_oncpu
;
else
oncpu
=
kp
.
ki_lastcpu
;
#
else
oncpu
=
-
1
;
#
endif
py_retlist
=
Py_BuildValue
(
"
(
lillllllidllllddddlllllbO
)
"
#
ifdef
PSUTIL_FREEBSD
(
long
)
kp
.
ki_ppid
(
int
)
kp
.
ki_stat
(
long
)
kp
.
ki_ruid
(
long
)
kp
.
ki_uid
(
long
)
kp
.
ki_svuid
(
long
)
kp
.
ki_rgid
(
long
)
kp
.
ki_groups
[
0
]
(
long
)
kp
.
ki_svuid
kp
.
ki_tdev
PSUTIL_TV2DOUBLE
(
kp
.
ki_start
)
kp
.
ki_rusage
.
ru_nvcsw
kp
.
ki_rusage
.
ru_nivcsw
kp
.
ki_rusage
.
ru_inblock
kp
.
ki_rusage
.
ru_oublock
PSUTIL_TV2DOUBLE
(
kp
.
ki_rusage
.
ru_utime
)
PSUTIL_TV2DOUBLE
(
kp
.
ki_rusage
.
ru_stime
)
PSUTIL_TV2DOUBLE
(
kp
.
ki_rusage_ch
.
ru_utime
)
PSUTIL_TV2DOUBLE
(
kp
.
ki_rusage_ch
.
ru_stime
)
rss
vms
memtext
memdata
memstack
oncpu
#
elif
defined
(
PSUTIL_OPENBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
(
long
)
kp
.
p_ppid
(
int
)
kp
.
p_stat
(
long
)
kp
.
p_ruid
(
long
)
kp
.
p_uid
(
long
)
kp
.
p_svuid
(
long
)
kp
.
p_rgid
(
long
)
kp
.
p_groups
[
0
]
(
long
)
kp
.
p_svuid
kp
.
p_tdev
PSUTIL_KPT2DOUBLE
(
kp
.
p_ustart
)
kp
.
p_uru_nvcsw
kp
.
p_uru_nivcsw
kp
.
p_uru_inblock
kp
.
p_uru_oublock
PSUTIL_KPT2DOUBLE
(
kp
.
p_uutime
)
PSUTIL_KPT2DOUBLE
(
kp
.
p_ustime
)
kp
.
p_uctime_sec
+
kp
.
p_uctime_usec
/
1000000
.
0
kp
.
p_uctime_sec
+
kp
.
p_uctime_usec
/
1000000
.
0
rss
vms
memtext
memdata
memstack
oncpu
#
endif
py_name
)
;
Py_DECREF
(
py_name
)
;
return
py_retlist
;
}
static
PyObject
*
psutil_proc_name
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
kinfo_proc
kp
;
char
str
[
1000
]
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
psutil_kinfo_proc
(
pid
&
kp
)
=
=
-
1
)
return
NULL
;
#
ifdef
PSUTIL_FREEBSD
sprintf
(
str
"
%
s
"
kp
.
ki_comm
)
;
#
elif
defined
(
PSUTIL_OPENBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
sprintf
(
str
"
%
s
"
kp
.
p_comm
)
;
#
endif
return
PyUnicode_DecodeFSDefault
(
str
)
;
}
static
PyObject
*
psutil_proc_cmdline
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
PyObject
*
py_retlist
=
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
py_retlist
=
psutil_get_cmdline
(
pid
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
return
Py_BuildValue
(
"
N
"
py_retlist
)
;
}
static
PyObject
*
psutil_cpu_count_logical
(
PyObject
*
self
PyObject
*
args
)
{
int
mib
[
2
]
;
int
ncpu
;
size_t
len
;
mib
[
0
]
=
CTL_HW
;
mib
[
1
]
=
HW_NCPU
;
len
=
sizeof
(
ncpu
)
;
if
(
sysctl
(
mib
2
&
ncpu
&
len
NULL
0
)
=
=
-
1
)
Py_RETURN_NONE
;
else
return
Py_BuildValue
(
"
i
"
ncpu
)
;
}
static
PyObject
*
psutil_cpu_times
(
PyObject
*
self
PyObject
*
args
)
{
#
ifdef
PSUTIL_NETBSD
u_int64_t
cpu_time
[
CPUSTATES
]
;
#
else
long
cpu_time
[
CPUSTATES
]
;
#
endif
size_t
size
=
sizeof
(
cpu_time
)
;
int
ret
;
#
if
defined
(
PSUTIL_FREEBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
ret
=
sysctlbyname
(
"
kern
.
cp_time
"
&
cpu_time
&
size
NULL
0
)
;
#
elif
PSUTIL_OPENBSD
int
mib
[
]
=
{
CTL_KERN
KERN_CPTIME
}
;
ret
=
sysctl
(
mib
2
&
cpu_time
&
size
NULL
0
)
;
#
endif
if
(
ret
=
=
-
1
)
return
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
Py_BuildValue
(
"
(
ddddd
)
"
(
double
)
cpu_time
[
CP_USER
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
CP_NICE
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
CP_SYS
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
CP_IDLE
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
CP_INTR
]
/
CLOCKS_PER_SEC
)
;
}
#
if
(
defined
(
__FreeBSD_version
)
&
&
__FreeBSD_version
>
=
800000
)
|
|
PSUTIL_OPENBSD
|
|
defined
(
PSUTIL_NETBSD
)
static
PyObject
*
psutil_proc_open_files
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
i
;
int
cnt
;
int
regular
;
int
fd
;
char
*
path
;
struct
kinfo_file
*
freep
=
NULL
;
struct
kinfo_file
*
kif
;
kinfo_proc
kipp
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_path
=
NULL
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
goto
error
;
if
(
psutil_kinfo_proc
(
pid
&
kipp
)
=
=
-
1
)
goto
error
;
errno
=
0
;
freep
=
kinfo_getfile
(
pid
&
cnt
)
;
if
(
freep
=
=
NULL
)
{
psutil_raise_for_pid
(
pid
"
kinfo_getfile
(
)
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
cnt
;
i
+
+
)
{
kif
=
&
freep
[
i
]
;
#
ifdef
PSUTIL_FREEBSD
regular
=
(
kif
-
>
kf_type
=
=
KF_TYPE_VNODE
)
&
&
\
(
kif
-
>
kf_vnode_type
=
=
KF_VTYPE_VREG
)
;
fd
=
kif
-
>
kf_fd
;
path
=
kif
-
>
kf_path
;
#
elif
PSUTIL_OPENBSD
regular
=
(
kif
-
>
f_type
=
=
DTYPE_VNODE
)
&
&
(
kif
-
>
v_type
=
=
VREG
)
;
fd
=
kif
-
>
fd_fd
;
path
=
"
"
;
#
elif
PSUTIL_NETBSD
regular
=
(
kif
-
>
ki_ftype
=
=
DTYPE_VNODE
)
&
&
(
kif
-
>
ki_vtype
=
=
VREG
)
;
fd
=
kif
-
>
ki_fd
;
path
=
"
"
;
#
endif
if
(
regular
=
=
1
)
{
py_path
=
PyUnicode_DecodeFSDefault
(
path
)
;
if
(
!
py_path
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
(
Oi
)
"
py_path
fd
)
;
if
(
py_tuple
=
=
NULL
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_path
)
;
Py_DECREF
(
py_tuple
)
;
}
}
free
(
freep
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
if
(
freep
!
=
NULL
)
free
(
freep
)
;
return
NULL
;
}
#
endif
static
PyObject
*
psutil_disk_partitions
(
PyObject
*
self
PyObject
*
args
)
{
int
num
;
int
i
;
long
len
;
uint64_t
flags
;
char
opts
[
200
]
;
#
ifdef
PSUTIL_NETBSD
struct
statvfs
*
fs
=
NULL
;
#
else
struct
statfs
*
fs
=
NULL
;
#
endif
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_dev
=
NULL
;
PyObject
*
py_mountp
=
NULL
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
Py_BEGIN_ALLOW_THREADS
#
ifdef
PSUTIL_NETBSD
num
=
getvfsstat
(
NULL
0
MNT_NOWAIT
)
;
#
else
num
=
getfsstat
(
NULL
0
MNT_NOWAIT
)
;
#
endif
Py_END_ALLOW_THREADS
if
(
num
=
=
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
len
=
sizeof
(
*
fs
)
*
num
;
fs
=
malloc
(
len
)
;
if
(
fs
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
Py_BEGIN_ALLOW_THREADS
#
ifdef
PSUTIL_NETBSD
num
=
getvfsstat
(
fs
len
MNT_NOWAIT
)
;
#
else
num
=
getfsstat
(
fs
len
MNT_NOWAIT
)
;
#
endif
Py_END_ALLOW_THREADS
if
(
num
=
=
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
num
;
i
+
+
)
{
py_tuple
=
NULL
;
opts
[
0
]
=
0
;
#
ifdef
PSUTIL_NETBSD
flags
=
fs
[
i
]
.
f_flag
;
#
else
flags
=
fs
[
i
]
.
f_flags
;
#
endif
if
(
flags
&
MNT_RDONLY
)
strlcat
(
opts
"
ro
"
sizeof
(
opts
)
)
;
else
strlcat
(
opts
"
rw
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_SYNCHRONOUS
)
strlcat
(
opts
"
sync
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOEXEC
)
strlcat
(
opts
"
noexec
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOSUID
)
strlcat
(
opts
"
nosuid
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_ASYNC
)
strlcat
(
opts
"
async
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOATIME
)
strlcat
(
opts
"
noatime
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_SOFTDEP
)
strlcat
(
opts
"
softdep
"
sizeof
(
opts
)
)
;
#
ifdef
PSUTIL_FREEBSD
if
(
flags
&
MNT_UNION
)
strlcat
(
opts
"
union
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_SUIDDIR
)
strlcat
(
opts
"
suiddir
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_SOFTDEP
)
strlcat
(
opts
"
softdep
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOSYMFOLLOW
)
strlcat
(
opts
"
nosymfollow
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_GJOURNAL
)
strlcat
(
opts
"
gjournal
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_MULTILABEL
)
strlcat
(
opts
"
multilabel
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_ACLS
)
strlcat
(
opts
"
acls
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOCLUSTERR
)
strlcat
(
opts
"
noclusterr
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOCLUSTERW
)
strlcat
(
opts
"
noclusterw
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NFS4ACLS
)
strlcat
(
opts
"
nfs4acls
"
sizeof
(
opts
)
)
;
#
elif
PSUTIL_NETBSD
if
(
flags
&
MNT_NODEV
)
strlcat
(
opts
"
nodev
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_UNION
)
strlcat
(
opts
"
union
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NOCOREDUMP
)
strlcat
(
opts
"
nocoredump
"
sizeof
(
opts
)
)
;
#
ifdef
MNT_RELATIME
if
(
flags
&
MNT_RELATIME
)
strlcat
(
opts
"
relatime
"
sizeof
(
opts
)
)
;
#
endif
if
(
flags
&
MNT_IGNORE
)
strlcat
(
opts
"
ignore
"
sizeof
(
opts
)
)
;
#
ifdef
MNT_DISCARD
if
(
flags
&
MNT_DISCARD
)
strlcat
(
opts
"
discard
"
sizeof
(
opts
)
)
;
#
endif
#
ifdef
MNT_EXTATTR
if
(
flags
&
MNT_EXTATTR
)
strlcat
(
opts
"
extattr
"
sizeof
(
opts
)
)
;
#
endif
if
(
flags
&
MNT_LOG
)
strlcat
(
opts
"
log
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_SYMPERM
)
strlcat
(
opts
"
symperm
"
sizeof
(
opts
)
)
;
if
(
flags
&
MNT_NODEVMTIME
)
strlcat
(
opts
"
nodevmtime
"
sizeof
(
opts
)
)
;
#
endif
py_dev
=
PyUnicode_DecodeFSDefault
(
fs
[
i
]
.
f_mntfromname
)
;
if
(
!
py_dev
)
goto
error
;
py_mountp
=
PyUnicode_DecodeFSDefault
(
fs
[
i
]
.
f_mntonname
)
;
if
(
!
py_mountp
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
(
OOss
)
"
py_dev
py_mountp
fs
[
i
]
.
f_fstypename
opts
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_dev
)
;
Py_DECREF
(
py_mountp
)
;
Py_DECREF
(
py_tuple
)
;
}
free
(
fs
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_dev
)
;
Py_XDECREF
(
py_mountp
)
;
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
if
(
fs
!
=
NULL
)
free
(
fs
)
;
return
NULL
;
}
static
PyObject
*
psutil_net_io_counters
(
PyObject
*
self
PyObject
*
args
)
{
char
*
buf
=
NULL
*
lim
*
next
;
struct
if_msghdr
*
ifm
;
int
mib
[
6
]
;
size_t
len
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
PyObject
*
py_ifc_info
=
NULL
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
mib
[
0
]
=
CTL_NET
;
mib
[
1
]
=
PF_ROUTE
;
mib
[
2
]
=
0
;
mib
[
3
]
=
0
;
mib
[
4
]
=
NET_RT_IFLIST
;
mib
[
5
]
=
0
;
if
(
sysctl
(
mib
6
NULL
&
len
NULL
0
)
<
0
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
buf
=
malloc
(
len
)
;
if
(
buf
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
sysctl
(
mib
6
buf
&
len
NULL
0
)
<
0
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
lim
=
buf
+
len
;
for
(
next
=
buf
;
next
<
lim
;
)
{
py_ifc_info
=
NULL
;
ifm
=
(
struct
if_msghdr
*
)
next
;
next
+
=
ifm
-
>
ifm_msglen
;
if
(
ifm
-
>
ifm_type
=
=
RTM_IFINFO
)
{
struct
if_msghdr
*
if2m
=
(
struct
if_msghdr
*
)
ifm
;
struct
sockaddr_dl
*
sdl
=
(
struct
sockaddr_dl
*
)
(
if2m
+
1
)
;
char
ifc_name
[
32
]
;
strncpy
(
ifc_name
sdl
-
>
sdl_data
sdl
-
>
sdl_nlen
)
;
ifc_name
[
sdl
-
>
sdl_nlen
]
=
0
;
if
(
strncmp
(
ifc_name
"
usbus
"
5
)
=
=
0
)
continue
;
py_ifc_info
=
Py_BuildValue
(
"
(
kkkkkkki
)
"
if2m
-
>
ifm_data
.
ifi_obytes
if2m
-
>
ifm_data
.
ifi_ibytes
if2m
-
>
ifm_data
.
ifi_opackets
if2m
-
>
ifm_data
.
ifi_ipackets
if2m
-
>
ifm_data
.
ifi_ierrors
if2m
-
>
ifm_data
.
ifi_oerrors
if2m
-
>
ifm_data
.
ifi_iqdrops
#
ifdef
_IFI_OQDROPS
if2m
-
>
ifm_data
.
ifi_oqdrops
#
else
0
#
endif
)
;
if
(
!
py_ifc_info
)
goto
error
;
if
(
PyDict_SetItemString
(
py_retdict
ifc_name
py_ifc_info
)
)
goto
error
;
Py_DECREF
(
py_ifc_info
)
;
}
else
{
continue
;
}
}
free
(
buf
)
;
return
py_retdict
;
error
:
Py_XDECREF
(
py_ifc_info
)
;
Py_DECREF
(
py_retdict
)
;
if
(
buf
!
=
NULL
)
free
(
buf
)
;
return
NULL
;
}
static
PyObject
*
psutil_users
(
PyObject
*
self
PyObject
*
args
)
{
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_username
=
NULL
;
PyObject
*
py_tty
=
NULL
;
PyObject
*
py_hostname
=
NULL
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
#
if
(
defined
(
__FreeBSD_version
)
&
&
(
__FreeBSD_version
<
900000
)
)
|
|
PSUTIL_OPENBSD
struct
utmp
ut
;
FILE
*
fp
;
fp
=
fopen
(
_PATH_UTMP
"
r
"
)
;
if
(
fp
=
=
NULL
)
{
PyErr_SetFromErrnoWithFilename
(
PyExc_OSError
_PATH_UTMP
)
;
goto
error
;
}
while
(
fread
(
&
ut
sizeof
(
ut
)
1
fp
)
=
=
1
)
{
if
(
*
ut
.
ut_name
=
=
'
\
0
'
)
continue
;
py_username
=
PyUnicode_DecodeFSDefault
(
ut
.
ut_name
)
;
if
(
!
py_username
)
goto
error
;
py_tty
=
PyUnicode_DecodeFSDefault
(
ut
.
ut_line
)
;
if
(
!
py_tty
)
goto
error
;
py_hostname
=
PyUnicode_DecodeFSDefault
(
ut
.
ut_host
)
;
if
(
!
py_hostname
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
(
OOOfi
)
"
py_username
py_tty
py_hostname
(
float
)
ut
.
ut_time
#
ifdef
PSUTIL_OPENBSD
-
1
#
else
ut
.
ut_pid
#
endif
)
;
if
(
!
py_tuple
)
{
fclose
(
fp
)
;
goto
error
;
}
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
{
fclose
(
fp
)
;
goto
error
;
}
Py_DECREF
(
py_username
)
;
Py_DECREF
(
py_tty
)
;
Py_DECREF
(
py_hostname
)
;
Py_DECREF
(
py_tuple
)
;
}
fclose
(
fp
)
;
#
else
struct
utmpx
*
utx
;
setutxent
(
)
;
while
(
(
utx
=
getutxent
(
)
)
!
=
NULL
)
{
if
(
utx
-
>
ut_type
!
=
USER_PROCESS
)
continue
;
py_username
=
PyUnicode_DecodeFSDefault
(
utx
-
>
ut_user
)
;
if
(
!
py_username
)
goto
error
;
py_tty
=
PyUnicode_DecodeFSDefault
(
utx
-
>
ut_line
)
;
if
(
!
py_tty
)
goto
error
;
py_hostname
=
PyUnicode_DecodeFSDefault
(
utx
-
>
ut_host
)
;
if
(
!
py_hostname
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
(
OOOfi
)
"
py_username
py_tty
py_hostname
(
float
)
utx
-
>
ut_tv
.
tv_sec
#
ifdef
PSUTIL_OPENBSD
-
1
#
else
utx
-
>
ut_pid
#
endif
)
;
if
(
!
py_tuple
)
{
endutxent
(
)
;
goto
error
;
}
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
{
endutxent
(
)
;
goto
error
;
}
Py_DECREF
(
py_username
)
;
Py_DECREF
(
py_tty
)
;
Py_DECREF
(
py_hostname
)
;
Py_DECREF
(
py_tuple
)
;
}
endutxent
(
)
;
#
endif
return
py_retlist
;
error
:
Py_XDECREF
(
py_username
)
;
Py_XDECREF
(
py_tty
)
;
Py_XDECREF
(
py_hostname
)
;
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
return
NULL
;
}
static
PyMethodDef
PsutilMethods
[
]
=
{
{
"
proc_oneshot_info
"
psutil_proc_oneshot_info
METH_VARARGS
"
Return
multiple
info
about
a
process
"
}
{
"
proc_name
"
psutil_proc_name
METH_VARARGS
"
Return
process
name
"
}
{
"
proc_cmdline
"
psutil_proc_cmdline
METH_VARARGS
"
Return
process
cmdline
as
a
list
of
cmdline
arguments
"
}
{
"
proc_threads
"
psutil_proc_threads
METH_VARARGS
"
Return
process
threads
"
}
#
if
defined
(
PSUTIL_FREEBSD
)
|
|
defined
(
PSUTIL_OPENBSD
)
{
"
proc_connections
"
psutil_proc_connections
METH_VARARGS
"
Return
connections
opened
by
process
"
}
{
"
proc_cwd
"
psutil_proc_cwd
METH_VARARGS
"
Return
process
current
working
directory
.
"
}
#
endif
#
if
defined
(
__FreeBSD_version
)
&
&
__FreeBSD_version
>
=
800000
|
|
PSUTIL_OPENBSD
|
|
defined
(
PSUTIL_NETBSD
)
{
"
proc_num_fds
"
psutil_proc_num_fds
METH_VARARGS
"
Return
the
number
of
file
descriptors
opened
by
this
process
"
}
{
"
proc_open_files
"
psutil_proc_open_files
METH_VARARGS
"
Return
files
opened
by
process
as
a
list
of
(
path
fd
)
tuples
"
}
#
endif
#
if
defined
(
PSUTIL_FREEBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
{
"
proc_num_threads
"
psutil_proc_num_threads
METH_VARARGS
"
Return
number
of
threads
used
by
process
"
}
#
endif
#
if
defined
(
PSUTIL_FREEBSD
)
{
"
proc_exe
"
psutil_proc_exe
METH_VARARGS
"
Return
process
pathname
executable
"
}
{
"
proc_memory_maps
"
psutil_proc_memory_maps
METH_VARARGS
"
Return
a
list
of
tuples
for
every
process
'
s
memory
map
"
}
{
"
proc_cpu_affinity_get
"
psutil_proc_cpu_affinity_get
METH_VARARGS
"
Return
process
CPU
affinity
.
"
}
{
"
proc_cpu_affinity_set
"
psutil_proc_cpu_affinity_set
METH_VARARGS
"
Set
process
CPU
affinity
.
"
}
{
"
cpu_count_phys
"
psutil_cpu_count_phys
METH_VARARGS
"
Return
an
XML
string
to
determine
the
number
physical
CPUs
.
"
}
#
endif
{
"
pids
"
psutil_pids
METH_VARARGS
"
Returns
a
list
of
PIDs
currently
running
on
the
system
"
}
{
"
cpu_count_logical
"
psutil_cpu_count_logical
METH_VARARGS
"
Return
number
of
logical
CPUs
on
the
system
"
}
{
"
virtual_mem
"
psutil_virtual_mem
METH_VARARGS
"
Return
system
virtual
memory
usage
statistics
"
}
{
"
swap_mem
"
psutil_swap_mem
METH_VARARGS
"
Return
swap
mem
stats
"
}
{
"
cpu_times
"
psutil_cpu_times
METH_VARARGS
"
Return
system
cpu
times
as
a
tuple
(
user
system
nice
idle
irc
)
"
}
{
"
per_cpu_times
"
psutil_per_cpu_times
METH_VARARGS
"
Return
system
per
-
cpu
times
as
a
list
of
tuples
"
}
{
"
boot_time
"
psutil_boot_time
METH_VARARGS
"
Return
the
system
boot
time
expressed
in
seconds
since
the
epoch
.
"
}
{
"
disk_partitions
"
psutil_disk_partitions
METH_VARARGS
"
Return
a
list
of
tuples
including
device
mount
point
and
"
"
fs
type
for
all
partitions
mounted
on
the
system
.
"
}
{
"
net_io_counters
"
psutil_net_io_counters
METH_VARARGS
"
Return
dict
of
tuples
of
networks
I
/
O
information
.
"
}
{
"
disk_io_counters
"
psutil_disk_io_counters
METH_VARARGS
"
Return
a
Python
dict
of
tuples
for
disk
I
/
O
information
"
}
{
"
users
"
psutil_users
METH_VARARGS
"
Return
currently
connected
users
as
a
list
of
tuples
"
}
{
"
cpu_stats
"
psutil_cpu_stats
METH_VARARGS
"
Return
CPU
statistics
"
}
#
if
defined
(
PSUTIL_FREEBSD
)
|
|
defined
(
PSUTIL_NETBSD
)
{
"
net_connections
"
psutil_net_connections
METH_VARARGS
"
Return
system
-
wide
open
connections
.
"
}
#
endif
#
if
defined
(
PSUTIL_FREEBSD
)
{
"
sensors_battery
"
psutil_sensors_battery
METH_VARARGS
"
Return
battery
information
.
"
}
{
"
sensors_cpu_temperature
"
psutil_sensors_cpu_temperature
METH_VARARGS
"
Return
temperature
information
for
a
given
CPU
core
number
.
"
}
{
"
cpu_frequency
"
psutil_cpu_freq
METH_VARARGS
"
Return
frequency
of
a
given
CPU
"
}
#
endif
{
"
set_testing
"
psutil_set_testing
METH_NOARGS
"
Set
psutil
in
testing
mode
"
}
{
NULL
NULL
0
NULL
}
}
;
struct
module_state
{
PyObject
*
error
;
}
;
#
if
PY_MAJOR_VERSION
>
=
3
#
define
GETSTATE
(
m
)
(
(
struct
module_state
*
)
PyModule_GetState
(
m
)
)
#
else
#
define
GETSTATE
(
m
)
(
&
_state
)
#
endif
#
if
PY_MAJOR_VERSION
>
=
3
static
int
psutil_bsd_traverse
(
PyObject
*
m
visitproc
visit
void
*
arg
)
{
Py_VISIT
(
GETSTATE
(
m
)
-
>
error
)
;
return
0
;
}
static
int
psutil_bsd_clear
(
PyObject
*
m
)
{
Py_CLEAR
(
GETSTATE
(
m
)
-
>
error
)
;
return
0
;
}
static
struct
PyModuleDef
moduledef
=
{
PyModuleDef_HEAD_INIT
"
psutil_bsd
"
NULL
sizeof
(
struct
module_state
)
PsutilMethods
NULL
psutil_bsd_traverse
psutil_bsd_clear
NULL
}
;
#
define
INITERROR
return
NULL
PyMODINIT_FUNC
PyInit__psutil_bsd
(
void
)
#
else
#
define
INITERROR
return
void
init_psutil_bsd
(
void
)
#
endif
{
#
if
PY_MAJOR_VERSION
>
=
3
PyObject
*
module
=
PyModule_Create
(
&
moduledef
)
;
#
else
PyObject
*
module
=
Py_InitModule
(
"
_psutil_bsd
"
PsutilMethods
)
;
#
endif
PyModule_AddIntConstant
(
module
"
version
"
PSUTIL_VERSION
)
;
#
ifdef
PSUTIL_FREEBSD
PyModule_AddIntConstant
(
module
"
SIDL
"
SIDL
)
;
PyModule_AddIntConstant
(
module
"
SRUN
"
SRUN
)
;
PyModule_AddIntConstant
(
module
"
SSLEEP
"
SSLEEP
)
;
PyModule_AddIntConstant
(
module
"
SSTOP
"
SSTOP
)
;
PyModule_AddIntConstant
(
module
"
SZOMB
"
SZOMB
)
;
PyModule_AddIntConstant
(
module
"
SWAIT
"
SWAIT
)
;
PyModule_AddIntConstant
(
module
"
SLOCK
"
SLOCK
)
;
#
elif
PSUTIL_OPENBSD
PyModule_AddIntConstant
(
module
"
SIDL
"
SIDL
)
;
PyModule_AddIntConstant
(
module
"
SRUN
"
SRUN
)
;
PyModule_AddIntConstant
(
module
"
SSLEEP
"
SSLEEP
)
;
PyModule_AddIntConstant
(
module
"
SSTOP
"
SSTOP
)
;
PyModule_AddIntConstant
(
module
"
SZOMB
"
SZOMB
)
;
PyModule_AddIntConstant
(
module
"
SDEAD
"
SDEAD
)
;
PyModule_AddIntConstant
(
module
"
SONPROC
"
SONPROC
)
;
#
elif
defined
(
PSUTIL_NETBSD
)
PyModule_AddIntConstant
(
module
"
SIDL
"
LSIDL
)
;
PyModule_AddIntConstant
(
module
"
SRUN
"
LSRUN
)
;
PyModule_AddIntConstant
(
module
"
SSLEEP
"
LSSLEEP
)
;
PyModule_AddIntConstant
(
module
"
SSTOP
"
LSSTOP
)
;
PyModule_AddIntConstant
(
module
"
SZOMB
"
LSZOMB
)
;
PyModule_AddIntConstant
(
module
"
SDEAD
"
LSDEAD
)
;
PyModule_AddIntConstant
(
module
"
SONPROC
"
LSONPROC
)
;
PyModule_AddIntConstant
(
module
"
SSUSPENDED
"
LSSUSPENDED
)
;
#
endif
PyModule_AddIntConstant
(
module
"
TCPS_CLOSED
"
TCPS_CLOSED
)
;
PyModule_AddIntConstant
(
module
"
TCPS_CLOSING
"
TCPS_CLOSING
)
;
PyModule_AddIntConstant
(
module
"
TCPS_CLOSE_WAIT
"
TCPS_CLOSE_WAIT
)
;
PyModule_AddIntConstant
(
module
"
TCPS_LISTEN
"
TCPS_LISTEN
)
;
PyModule_AddIntConstant
(
module
"
TCPS_ESTABLISHED
"
TCPS_ESTABLISHED
)
;
PyModule_AddIntConstant
(
module
"
TCPS_SYN_SENT
"
TCPS_SYN_SENT
)
;
PyModule_AddIntConstant
(
module
"
TCPS_SYN_RECEIVED
"
TCPS_SYN_RECEIVED
)
;
PyModule_AddIntConstant
(
module
"
TCPS_FIN_WAIT_1
"
TCPS_FIN_WAIT_1
)
;
PyModule_AddIntConstant
(
module
"
TCPS_FIN_WAIT_2
"
TCPS_FIN_WAIT_2
)
;
PyModule_AddIntConstant
(
module
"
TCPS_LAST_ACK
"
TCPS_LAST_ACK
)
;
PyModule_AddIntConstant
(
module
"
TCPS_TIME_WAIT
"
TCPS_TIME_WAIT
)
;
PyModule_AddIntConstant
(
module
"
PSUTIL_CONN_NONE
"
128
)
;
psutil_setup
(
)
;
if
(
module
=
=
NULL
)
INITERROR
;
#
if
PY_MAJOR_VERSION
>
=
3
return
module
;
#
endif
}
