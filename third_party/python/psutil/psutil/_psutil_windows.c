#
define
WIN32_LEAN_AND_MEAN
#
include
<
Python
.
h
>
#
include
<
windows
.
h
>
#
include
<
Psapi
.
h
>
#
include
<
time
.
h
>
#
include
<
lm
.
h
>
#
include
<
WinIoCtl
.
h
>
#
include
<
tchar
.
h
>
#
include
<
tlhelp32
.
h
>
#
include
<
winsock2
.
h
>
#
if
(
_WIN32_WINNT
>
=
0x0600
)
#
include
<
ws2tcpip
.
h
>
#
endif
#
include
<
iphlpapi
.
h
>
#
include
<
wtsapi32
.
h
>
#
include
<
Winsvc
.
h
>
#
include
<
PowrProf
.
h
>
#
include
<
signal
.
h
>
#
pragma
comment
(
lib
"
IPHLPAPI
.
lib
"
)
#
include
"
_psutil_common
.
h
"
#
include
"
arch
/
windows
/
security
.
h
"
#
include
"
arch
/
windows
/
process_info
.
h
"
#
include
"
arch
/
windows
/
process_handles
.
h
"
#
include
"
arch
/
windows
/
ntextapi
.
h
"
#
include
"
arch
/
windows
/
inet_ntop
.
h
"
#
include
"
arch
/
windows
/
services
.
h
"
#
ifdef
__MINGW32__
#
include
"
arch
/
windows
/
glpi
.
h
"
#
endif
#
define
MALLOC
(
x
)
HeapAlloc
(
GetProcessHeap
(
)
0
(
x
)
)
#
define
FREE
(
x
)
HeapFree
(
GetProcessHeap
(
)
0
(
x
)
)
#
define
LO_T
(
(
float
)
1e
-
7
)
#
define
HI_T
(
LO_T
*
4294967296
.
0
)
#
define
BYTESWAP_USHORT
(
x
)
(
(
(
(
USHORT
)
(
x
)
<
<
8
)
|
(
(
USHORT
)
(
x
)
>
>
8
)
)
&
0xffff
)
#
ifndef
AF_INET6
#
define
AF_INET6
23
#
endif
#
define
_psutil_conn_decref_objs
(
)
\
Py_DECREF
(
_AF_INET
)
;
\
Py_DECREF
(
_AF_INET6
)
;
\
Py_DECREF
(
_SOCK_STREAM
)
;
\
Py_DECREF
(
_SOCK_DGRAM
)
;
typedef
BOOL
(
WINAPI
*
LPFN_GLPI
)
(
PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
PDWORD
)
;
typedef
struct
_DISK_PERFORMANCE_WIN_2008
{
LARGE_INTEGER
BytesRead
;
LARGE_INTEGER
BytesWritten
;
LARGE_INTEGER
ReadTime
;
LARGE_INTEGER
WriteTime
;
LARGE_INTEGER
IdleTime
;
DWORD
ReadCount
;
DWORD
WriteCount
;
DWORD
QueueDepth
;
DWORD
SplitCount
;
LARGE_INTEGER
QueryTime
;
DWORD
StorageDeviceNumber
;
WCHAR
StorageManagerName
[
8
]
;
}
DISK_PERFORMANCE_WIN_2008
;
#
ifndef
_IPRTRMIB_H
#
if
(
_WIN32_WINNT
<
0x0600
)
typedef
struct
_MIB_TCP6ROW_OWNER_PID
{
UCHAR
ucLocalAddr
[
16
]
;
DWORD
dwLocalScopeId
;
DWORD
dwLocalPort
;
UCHAR
ucRemoteAddr
[
16
]
;
DWORD
dwRemoteScopeId
;
DWORD
dwRemotePort
;
DWORD
dwState
;
DWORD
dwOwningPid
;
}
MIB_TCP6ROW_OWNER_PID
*
PMIB_TCP6ROW_OWNER_PID
;
typedef
struct
_MIB_TCP6TABLE_OWNER_PID
{
DWORD
dwNumEntries
;
MIB_TCP6ROW_OWNER_PID
table
[
ANY_SIZE
]
;
}
MIB_TCP6TABLE_OWNER_PID
*
PMIB_TCP6TABLE_OWNER_PID
;
#
endif
#
endif
#
ifndef
__IPHLPAPI_H__
typedef
struct
in6_addr
{
union
{
UCHAR
Byte
[
16
]
;
USHORT
Word
[
8
]
;
}
u
;
}
IN6_ADDR
*
PIN6_ADDR
FAR
*
LPIN6_ADDR
;
typedef
enum
_UDP_TABLE_CLASS
{
UDP_TABLE_BASIC
UDP_TABLE_OWNER_PID
UDP_TABLE_OWNER_MODULE
}
UDP_TABLE_CLASS
*
PUDP_TABLE_CLASS
;
typedef
struct
_MIB_UDPROW_OWNER_PID
{
DWORD
dwLocalAddr
;
DWORD
dwLocalPort
;
DWORD
dwOwningPid
;
}
MIB_UDPROW_OWNER_PID
*
PMIB_UDPROW_OWNER_PID
;
typedef
struct
_MIB_UDPTABLE_OWNER_PID
{
DWORD
dwNumEntries
;
MIB_UDPROW_OWNER_PID
table
[
ANY_SIZE
]
;
}
MIB_UDPTABLE_OWNER_PID
*
PMIB_UDPTABLE_OWNER_PID
;
#
endif
#
if
(
_WIN32_WINNT
<
0x0600
)
typedef
struct
_MIB_UDP6ROW_OWNER_PID
{
UCHAR
ucLocalAddr
[
16
]
;
DWORD
dwLocalScopeId
;
DWORD
dwLocalPort
;
DWORD
dwOwningPid
;
}
MIB_UDP6ROW_OWNER_PID
*
PMIB_UDP6ROW_OWNER_PID
;
typedef
struct
_MIB_UDP6TABLE_OWNER_PID
{
DWORD
dwNumEntries
;
MIB_UDP6ROW_OWNER_PID
table
[
ANY_SIZE
]
;
}
MIB_UDP6TABLE_OWNER_PID
*
PMIB_UDP6TABLE_OWNER_PID
;
#
endif
typedef
struct
_PROCESSOR_POWER_INFORMATION
{
ULONG
Number
;
ULONG
MaxMhz
;
ULONG
CurrentMhz
;
ULONG
MhzLimit
;
ULONG
MaxIdleState
;
ULONG
CurrentIdleState
;
}
PROCESSOR_POWER_INFORMATION
*
PPROCESSOR_POWER_INFORMATION
;
PIP_ADAPTER_ADDRESSES
psutil_get_nic_addresses
(
)
{
int
outBufLen
=
15000
;
DWORD
dwRetVal
=
0
;
ULONG
attempts
=
0
;
PIP_ADAPTER_ADDRESSES
pAddresses
=
NULL
;
do
{
pAddresses
=
(
IP_ADAPTER_ADDRESSES
*
)
malloc
(
outBufLen
)
;
if
(
pAddresses
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
dwRetVal
=
GetAdaptersAddresses
(
AF_UNSPEC
0
NULL
pAddresses
&
outBufLen
)
;
if
(
dwRetVal
=
=
ERROR_BUFFER_OVERFLOW
)
{
free
(
pAddresses
)
;
pAddresses
=
NULL
;
}
else
{
break
;
}
attempts
+
+
;
}
while
(
(
dwRetVal
=
=
ERROR_BUFFER_OVERFLOW
)
&
&
(
attempts
<
3
)
)
;
if
(
dwRetVal
!
=
NO_ERROR
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
GetAdaptersAddresses
(
)
syscall
failed
.
"
)
;
return
NULL
;
}
return
pAddresses
;
}
static
ULONGLONG
(
*
psutil_GetTickCount64
)
(
void
)
=
NULL
;
static
PyObject
*
psutil_boot_time
(
PyObject
*
self
PyObject
*
args
)
{
#
if
(
_WIN32_WINNT
>
=
0x0600
)
ULONGLONG
uptime
;
#
else
double
uptime
;
#
endif
time_t
pt
;
FILETIME
fileTime
;
long
long
ll
;
HINSTANCE
hKernel32
;
psutil_GetTickCount64
=
NULL
;
GetSystemTimeAsFileTime
(
&
fileTime
)
;
#
if
(
_WIN32_WINNT
>
=
0x0600
)
ll
=
(
(
(
ULONGLONG
)
#
else
ll
=
(
(
(
LONGLONG
)
#
endif
(
fileTime
.
dwHighDateTime
)
)
<
<
32
)
+
fileTime
.
dwLowDateTime
;
pt
=
(
time_t
)
(
(
ll
-
116444736000000000ull
)
/
10000000ull
)
;
hKernel32
=
GetModuleHandleW
(
L
"
KERNEL32
"
)
;
psutil_GetTickCount64
=
(
void
*
)
GetProcAddress
(
hKernel32
"
GetTickCount64
"
)
;
if
(
psutil_GetTickCount64
!
=
NULL
)
{
uptime
=
psutil_GetTickCount64
(
)
/
(
ULONGLONG
)
1000
.
00f
;
return
Py_BuildValue
(
"
K
"
pt
-
uptime
)
;
}
else
{
uptime
=
GetTickCount
(
)
/
(
LONGLONG
)
1000
.
00f
;
return
Py_BuildValue
(
"
L
"
pt
-
uptime
)
;
}
}
static
PyObject
*
psutil_pid_exists
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
status
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
status
=
psutil_pid_is_running
(
pid
)
;
if
(
-
1
=
=
status
)
return
NULL
;
return
PyBool_FromLong
(
status
)
;
}
static
PyObject
*
psutil_pids
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
*
proclist
=
NULL
;
DWORD
numberOfReturnedPIDs
;
DWORD
i
;
PyObject
*
py_pid
=
NULL
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
proclist
=
psutil_get_pids
(
&
numberOfReturnedPIDs
)
;
if
(
proclist
=
=
NULL
)
goto
error
;
for
(
i
=
0
;
i
<
numberOfReturnedPIDs
;
i
+
+
)
{
py_pid
=
Py_BuildValue
(
"
I
"
proclist
[
i
]
)
;
if
(
!
py_pid
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_pid
)
)
goto
error
;
Py_DECREF
(
py_pid
)
;
}
free
(
proclist
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_pid
)
;
Py_DECREF
(
py_retlist
)
;
if
(
proclist
!
=
NULL
)
free
(
proclist
)
;
return
NULL
;
}
static
PyObject
*
psutil_proc_kill
(
PyObject
*
self
PyObject
*
args
)
{
HANDLE
hProcess
;
DWORD
err
;
long
pid
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
pid
=
=
0
)
return
AccessDenied
(
"
"
)
;
hProcess
=
OpenProcess
(
PROCESS_TERMINATE
FALSE
pid
)
;
if
(
hProcess
=
=
NULL
)
{
if
(
GetLastError
(
)
=
=
ERROR_INVALID_PARAMETER
)
{
psutil_debug
(
"
OpenProcess
-
>
ERROR_INVALID_PARAMETER
turned
"
"
into
NoSuchProcess
"
)
;
NoSuchProcess
(
"
"
)
;
}
else
{
PyErr_SetFromWindowsErr
(
0
)
;
}
return
NULL
;
}
if
(
!
TerminateProcess
(
hProcess
SIGTERM
)
)
{
err
=
GetLastError
(
)
;
if
(
err
!
=
ERROR_ACCESS_DENIED
)
{
CloseHandle
(
hProcess
)
;
PyErr_SetFromWindowsErr
(
err
)
;
return
NULL
;
}
}
CloseHandle
(
hProcess
)
;
Py_RETURN_NONE
;
}
static
PyObject
*
psutil_proc_wait
(
PyObject
*
self
PyObject
*
args
)
{
HANDLE
hProcess
;
DWORD
ExitCode
;
DWORD
retVal
;
long
pid
;
long
timeout
;
if
(
!
PyArg_ParseTuple
(
args
"
ll
"
&
pid
&
timeout
)
)
return
NULL
;
if
(
pid
=
=
0
)
return
AccessDenied
(
"
"
)
;
hProcess
=
OpenProcess
(
SYNCHRONIZE
|
PROCESS_QUERY_INFORMATION
FALSE
pid
)
;
if
(
hProcess
=
=
NULL
)
{
if
(
GetLastError
(
)
=
=
ERROR_INVALID_PARAMETER
)
{
Py_RETURN_NONE
;
}
else
return
PyErr_SetFromWindowsErr
(
0
)
;
}
Py_BEGIN_ALLOW_THREADS
retVal
=
WaitForSingleObject
(
hProcess
timeout
)
;
Py_END_ALLOW_THREADS
if
(
retVal
=
=
WAIT_FAILED
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
if
(
retVal
=
=
WAIT_TIMEOUT
)
{
CloseHandle
(
hProcess
)
;
return
Py_BuildValue
(
"
l
"
WAIT_TIMEOUT
)
;
}
if
(
GetExitCodeProcess
(
hProcess
&
ExitCode
)
=
=
0
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
GetLastError
(
)
)
;
}
CloseHandle
(
hProcess
)
;
#
if
PY_MAJOR_VERSION
>
=
3
return
PyLong_FromLong
(
(
long
)
ExitCode
)
;
#
else
return
PyInt_FromLong
(
(
long
)
ExitCode
)
;
#
endif
}
static
PyObject
*
psutil_proc_cpu_times
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
HANDLE
hProcess
;
FILETIME
ftCreate
ftExit
ftKernel
ftUser
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
if
(
!
GetProcessTimes
(
hProcess
&
ftCreate
&
ftExit
&
ftKernel
&
ftUser
)
)
{
CloseHandle
(
hProcess
)
;
if
(
GetLastError
(
)
=
=
ERROR_ACCESS_DENIED
)
{
return
NoSuchProcess
(
"
"
)
;
}
else
{
return
PyErr_SetFromWindowsErr
(
0
)
;
}
}
CloseHandle
(
hProcess
)
;
return
Py_BuildValue
(
"
(
dd
)
"
(
double
)
(
ftUser
.
dwHighDateTime
*
429
.
4967296
+
\
ftUser
.
dwLowDateTime
*
1e
-
7
)
(
double
)
(
ftKernel
.
dwHighDateTime
*
429
.
4967296
+
\
ftKernel
.
dwLowDateTime
*
1e
-
7
)
)
;
}
static
PyObject
*
psutil_proc_create_time
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
long
long
unix_time
;
HANDLE
hProcess
;
FILETIME
ftCreate
ftExit
ftKernel
ftUser
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
0
=
=
pid
|
|
4
=
=
pid
)
return
psutil_boot_time
(
NULL
NULL
)
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
if
(
!
GetProcessTimes
(
hProcess
&
ftCreate
&
ftExit
&
ftKernel
&
ftUser
)
)
{
CloseHandle
(
hProcess
)
;
if
(
GetLastError
(
)
=
=
ERROR_ACCESS_DENIED
)
{
return
NoSuchProcess
(
"
"
)
;
}
else
{
return
PyErr_SetFromWindowsErr
(
0
)
;
}
}
CloseHandle
(
hProcess
)
;
unix_time
=
(
(
LONGLONG
)
ftCreate
.
dwHighDateTime
)
<
<
32
;
unix_time
+
=
ftCreate
.
dwLowDateTime
-
116444736000000000LL
;
unix_time
/
=
10000000
;
return
Py_BuildValue
(
"
d
"
(
double
)
unix_time
)
;
}
static
PyObject
*
psutil_cpu_count_logical
(
PyObject
*
self
PyObject
*
args
)
{
SYSTEM_INFO
system_info
;
system_info
.
dwNumberOfProcessors
=
0
;
GetSystemInfo
(
&
system_info
)
;
if
(
system_info
.
dwNumberOfProcessors
=
=
0
)
Py_RETURN_NONE
;
else
return
Py_BuildValue
(
"
I
"
system_info
.
dwNumberOfProcessors
)
;
}
static
PyObject
*
psutil_cpu_count_phys
(
PyObject
*
self
PyObject
*
args
)
{
LPFN_GLPI
glpi
;
DWORD
rc
;
PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
buffer
=
NULL
;
PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
ptr
=
NULL
;
DWORD
length
=
0
;
DWORD
offset
=
0
;
int
ncpus
=
0
;
glpi
=
(
LPFN_GLPI
)
GetProcAddress
(
GetModuleHandle
(
TEXT
(
"
kernel32
"
)
)
"
GetLogicalProcessorInformation
"
)
;
if
(
glpi
=
=
NULL
)
goto
return_none
;
while
(
1
)
{
rc
=
glpi
(
buffer
&
length
)
;
if
(
rc
=
=
FALSE
)
{
if
(
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
if
(
buffer
)
free
(
buffer
)
;
buffer
=
(
PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
)
malloc
(
length
)
;
if
(
NULL
=
=
buffer
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
}
else
{
goto
return_none
;
}
}
else
{
break
;
}
}
ptr
=
buffer
;
while
(
offset
+
sizeof
(
SYSTEM_LOGICAL_PROCESSOR_INFORMATION
)
<
=
length
)
{
if
(
ptr
-
>
Relationship
=
=
RelationProcessorCore
)
ncpus
+
=
1
;
offset
+
=
sizeof
(
SYSTEM_LOGICAL_PROCESSOR_INFORMATION
)
;
ptr
+
+
;
}
free
(
buffer
)
;
if
(
ncpus
=
=
0
)
goto
return_none
;
else
return
Py_BuildValue
(
"
i
"
ncpus
)
;
return_none
:
if
(
buffer
!
=
NULL
)
free
(
buffer
)
;
Py_RETURN_NONE
;
}
static
PyObject
*
psutil_proc_cmdline
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
pid_return
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
(
pid
=
=
0
)
|
|
(
pid
=
=
4
)
)
return
Py_BuildValue
(
"
[
]
"
)
;
pid_return
=
psutil_pid_is_running
(
pid
)
;
if
(
pid_return
=
=
0
)
return
NoSuchProcess
(
"
"
)
;
if
(
pid_return
=
=
-
1
)
return
NULL
;
return
psutil_get_cmdline
(
pid
)
;
}
static
PyObject
*
psutil_proc_environ
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
pid_return
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
(
pid
=
=
0
)
|
|
(
pid
=
=
4
)
)
return
Py_BuildValue
(
"
s
"
"
"
)
;
pid_return
=
psutil_pid_is_running
(
pid
)
;
if
(
pid_return
=
=
0
)
return
NoSuchProcess
(
"
"
)
;
if
(
pid_return
=
=
-
1
)
return
NULL
;
return
psutil_get_environ
(
pid
)
;
}
static
PyObject
*
psutil_proc_exe
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
HANDLE
hProcess
;
wchar_t
exe
[
MAX_PATH
]
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid_waccess
(
pid
PROCESS_QUERY_INFORMATION
)
;
if
(
NULL
=
=
hProcess
)
return
NULL
;
if
(
GetProcessImageFileNameW
(
hProcess
exe
MAX_PATH
)
=
=
0
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
CloseHandle
(
hProcess
)
;
return
PyUnicode_FromWideChar
(
exe
wcslen
(
exe
)
)
;
}
static
PyObject
*
psutil_proc_name
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
ok
;
PROCESSENTRY32W
pentry
;
HANDLE
hSnapShot
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hSnapShot
=
CreateToolhelp32Snapshot
(
TH32CS_SNAPPROCESS
pid
)
;
if
(
hSnapShot
=
=
INVALID_HANDLE_VALUE
)
return
PyErr_SetFromWindowsErr
(
0
)
;
pentry
.
dwSize
=
sizeof
(
PROCESSENTRY32W
)
;
ok
=
Process32FirstW
(
hSnapShot
&
pentry
)
;
if
(
!
ok
)
{
CloseHandle
(
hSnapShot
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
while
(
ok
)
{
if
(
pentry
.
th32ProcessID
=
=
pid
)
{
CloseHandle
(
hSnapShot
)
;
return
PyUnicode_FromWideChar
(
pentry
.
szExeFile
wcslen
(
pentry
.
szExeFile
)
)
;
}
ok
=
Process32NextW
(
hSnapShot
&
pentry
)
;
}
CloseHandle
(
hSnapShot
)
;
NoSuchProcess
(
"
"
)
;
return
NULL
;
}
static
PyObject
*
psutil_proc_memory_info
(
PyObject
*
self
PyObject
*
args
)
{
HANDLE
hProcess
;
DWORD
pid
;
#
if
(
_WIN32_WINNT
>
=
0x0501
)
PROCESS_MEMORY_COUNTERS_EX
cnt
;
#
else
PROCESS_MEMORY_COUNTERS
cnt
;
#
endif
SIZE_T
private
=
0
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
NULL
=
=
hProcess
)
return
NULL
;
if
(
!
GetProcessMemoryInfo
(
hProcess
(
PPROCESS_MEMORY_COUNTERS
)
&
cnt
sizeof
(
cnt
)
)
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
#
if
(
_WIN32_WINNT
>
=
0x0501
)
private
=
cnt
.
PrivateUsage
;
#
endif
CloseHandle
(
hProcess
)
;
#
if
defined
(
_WIN64
)
return
Py_BuildValue
(
"
(
kKKKKKKKKK
)
"
cnt
.
PageFaultCount
(
unsigned
long
long
)
cnt
.
PeakWorkingSetSize
(
unsigned
long
long
)
cnt
.
WorkingSetSize
(
unsigned
long
long
)
cnt
.
QuotaPeakPagedPoolUsage
(
unsigned
long
long
)
cnt
.
QuotaPagedPoolUsage
(
unsigned
long
long
)
cnt
.
QuotaPeakNonPagedPoolUsage
(
unsigned
long
long
)
cnt
.
QuotaNonPagedPoolUsage
(
unsigned
long
long
)
cnt
.
PagefileUsage
(
unsigned
long
long
)
cnt
.
PeakPagefileUsage
(
unsigned
long
long
)
private
)
;
#
else
return
Py_BuildValue
(
"
(
kIIIIIIIII
)
"
cnt
.
PageFaultCount
(
unsigned
int
)
cnt
.
PeakWorkingSetSize
(
unsigned
int
)
cnt
.
WorkingSetSize
(
unsigned
int
)
cnt
.
QuotaPeakPagedPoolUsage
(
unsigned
int
)
cnt
.
QuotaPagedPoolUsage
(
unsigned
int
)
cnt
.
QuotaPeakNonPagedPoolUsage
(
unsigned
int
)
cnt
.
QuotaNonPagedPoolUsage
(
unsigned
int
)
cnt
.
PagefileUsage
(
unsigned
int
)
cnt
.
PeakPagefileUsage
(
unsigned
int
)
private
)
;
#
endif
}
static
PyObject
*
psutil_proc_memory_uss
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
HANDLE
proc
;
PSAPI_WORKING_SET_INFORMATION
tmp
;
DWORD
tmp_size
=
sizeof
(
tmp
)
;
size_t
entries
;
size_t
private_pages
;
size_t
i
;
DWORD
info_array_size
;
PSAPI_WORKING_SET_INFORMATION
*
info_array
;
SYSTEM_INFO
system_info
;
PyObject
*
py_result
=
NULL
;
unsigned
long
long
total
=
0
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
proc
=
psutil_handle_from_pid
(
pid
)
;
if
(
proc
=
=
NULL
)
return
NULL
;
memset
(
&
tmp
0
tmp_size
)
;
if
(
!
QueryWorkingSet
(
proc
&
tmp
tmp_size
)
)
{
if
(
tmp
.
NumberOfEntries
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
done
;
}
}
entries
=
tmp
.
NumberOfEntries
*
2
;
if
(
!
entries
)
{
goto
done
;
}
info_array_size
=
tmp_size
+
(
entries
*
sizeof
(
PSAPI_WORKING_SET_BLOCK
)
)
;
info_array
=
(
PSAPI_WORKING_SET_INFORMATION
*
)
malloc
(
info_array_size
)
;
if
(
!
info_array
)
{
PyErr_NoMemory
(
)
;
goto
done
;
}
if
(
!
QueryWorkingSet
(
proc
info_array
info_array_size
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
done
;
}
entries
=
(
size_t
)
info_array
-
>
NumberOfEntries
;
private_pages
=
0
;
for
(
i
=
0
;
i
<
entries
;
i
+
+
)
{
if
(
!
info_array
-
>
WorkingSetInfo
[
i
]
.
Shared
|
|
info_array
-
>
WorkingSetInfo
[
i
]
.
ShareCount
<
=
1
)
{
private_pages
+
+
;
}
}
GetSystemInfo
(
&
system_info
)
;
total
=
private_pages
*
system_info
.
dwPageSize
;
py_result
=
Py_BuildValue
(
"
K
"
total
)
;
done
:
if
(
proc
)
{
CloseHandle
(
proc
)
;
}
if
(
info_array
)
{
free
(
info_array
)
;
}
return
py_result
;
}
static
PyObject
*
psutil_virtual_mem
(
PyObject
*
self
PyObject
*
args
)
{
MEMORYSTATUSEX
memInfo
;
memInfo
.
dwLength
=
sizeof
(
MEMORYSTATUSEX
)
;
if
(
!
GlobalMemoryStatusEx
(
&
memInfo
)
)
return
PyErr_SetFromWindowsErr
(
0
)
;
return
Py_BuildValue
(
"
(
LLLLLL
)
"
memInfo
.
ullTotalPhys
memInfo
.
ullAvailPhys
memInfo
.
ullTotalPageFile
memInfo
.
ullAvailPageFile
memInfo
.
ullTotalVirtual
memInfo
.
ullAvailVirtual
)
;
}
static
PyObject
*
psutil_cpu_times
(
PyObject
*
self
PyObject
*
args
)
{
float
idle
kernel
user
system
;
FILETIME
idle_time
kernel_time
user_time
;
if
(
!
GetSystemTimes
(
&
idle_time
&
kernel_time
&
user_time
)
)
return
PyErr_SetFromWindowsErr
(
0
)
;
idle
=
(
float
)
(
(
HI_T
*
idle_time
.
dwHighDateTime
)
+
\
(
LO_T
*
idle_time
.
dwLowDateTime
)
)
;
user
=
(
float
)
(
(
HI_T
*
user_time
.
dwHighDateTime
)
+
\
(
LO_T
*
user_time
.
dwLowDateTime
)
)
;
kernel
=
(
float
)
(
(
HI_T
*
kernel_time
.
dwHighDateTime
)
+
\
(
LO_T
*
kernel_time
.
dwLowDateTime
)
)
;
system
=
(
kernel
-
idle
)
;
return
Py_BuildValue
(
"
(
fff
)
"
user
system
idle
)
;
}
static
PyObject
*
psutil_per_cpu_times
(
PyObject
*
self
PyObject
*
args
)
{
typedef
DWORD
(
_stdcall
*
NTQSI_PROC
)
(
int
PVOID
ULONG
PULONG
)
;
NTQSI_PROC
NtQuerySystemInformation
;
HINSTANCE
hNtDll
;
float
idle
kernel
systemt
user
interrupt
dpc
;
NTSTATUS
status
;
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
*
sppi
=
NULL
;
SYSTEM_INFO
si
;
UINT
i
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
hNtDll
=
LoadLibrary
(
TEXT
(
"
ntdll
.
dll
"
)
)
;
if
(
hNtDll
=
=
NULL
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
NtQuerySystemInformation
=
(
NTQSI_PROC
)
GetProcAddress
(
hNtDll
"
NtQuerySystemInformation
"
)
;
if
(
NtQuerySystemInformation
=
=
NULL
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
GetSystemInfo
(
&
si
)
;
sppi
=
(
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
*
)
\
malloc
(
si
.
dwNumberOfProcessors
*
\
sizeof
(
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
)
)
;
if
(
sppi
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
status
=
NtQuerySystemInformation
(
SystemProcessorPerformanceInformation
sppi
si
.
dwNumberOfProcessors
*
sizeof
(
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
)
NULL
)
;
if
(
status
!
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
idle
=
user
=
kernel
=
interrupt
=
dpc
=
0
;
for
(
i
=
0
;
i
<
si
.
dwNumberOfProcessors
;
i
+
+
)
{
py_tuple
=
NULL
;
user
=
(
float
)
(
(
HI_T
*
sppi
[
i
]
.
UserTime
.
HighPart
)
+
(
LO_T
*
sppi
[
i
]
.
UserTime
.
LowPart
)
)
;
idle
=
(
float
)
(
(
HI_T
*
sppi
[
i
]
.
IdleTime
.
HighPart
)
+
(
LO_T
*
sppi
[
i
]
.
IdleTime
.
LowPart
)
)
;
kernel
=
(
float
)
(
(
HI_T
*
sppi
[
i
]
.
KernelTime
.
HighPart
)
+
(
LO_T
*
sppi
[
i
]
.
KernelTime
.
LowPart
)
)
;
interrupt
=
(
float
)
(
(
HI_T
*
sppi
[
i
]
.
InterruptTime
.
HighPart
)
+
(
LO_T
*
sppi
[
i
]
.
InterruptTime
.
LowPart
)
)
;
dpc
=
(
float
)
(
(
HI_T
*
sppi
[
i
]
.
DpcTime
.
HighPart
)
+
(
LO_T
*
sppi
[
i
]
.
DpcTime
.
LowPart
)
)
;
systemt
=
kernel
-
idle
;
py_tuple
=
Py_BuildValue
(
"
(
ddddd
)
"
user
systemt
idle
interrupt
dpc
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
}
free
(
sppi
)
;
FreeLibrary
(
hNtDll
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
if
(
sppi
)
free
(
sppi
)
;
if
(
hNtDll
)
FreeLibrary
(
hNtDll
)
;
return
NULL
;
}
static
PyObject
*
psutil_proc_cwd
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
pid_return
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
pid_return
=
psutil_pid_is_running
(
pid
)
;
if
(
pid_return
=
=
0
)
return
NoSuchProcess
(
"
"
)
;
if
(
pid_return
=
=
-
1
)
return
NULL
;
return
psutil_get_cwd
(
pid
)
;
}
int
psutil_proc_suspend_or_resume
(
DWORD
pid
int
suspend
)
{
HANDLE
hThreadSnap
=
NULL
;
HANDLE
hThread
;
THREADENTRY32
te32
=
{
0
}
;
if
(
pid
=
=
0
)
{
AccessDenied
(
"
"
)
;
return
FALSE
;
}
hThreadSnap
=
CreateToolhelp32Snapshot
(
TH32CS_SNAPTHREAD
0
)
;
if
(
hThreadSnap
=
=
INVALID_HANDLE_VALUE
)
{
PyErr_SetFromWindowsErr
(
0
)
;
return
FALSE
;
}
te32
.
dwSize
=
sizeof
(
THREADENTRY32
)
;
if
(
!
Thread32First
(
hThreadSnap
&
te32
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
CloseHandle
(
hThreadSnap
)
;
return
FALSE
;
}
do
{
if
(
te32
.
th32OwnerProcessID
=
=
pid
)
{
hThread
=
OpenThread
(
THREAD_SUSPEND_RESUME
FALSE
te32
.
th32ThreadID
)
;
if
(
hThread
=
=
NULL
)
{
PyErr_SetFromWindowsErr
(
0
)
;
CloseHandle
(
hThread
)
;
CloseHandle
(
hThreadSnap
)
;
return
FALSE
;
}
if
(
suspend
=
=
1
)
{
if
(
SuspendThread
(
hThread
)
=
=
(
DWORD
)
-
1
)
{
PyErr_SetFromWindowsErr
(
0
)
;
CloseHandle
(
hThread
)
;
CloseHandle
(
hThreadSnap
)
;
return
FALSE
;
}
}
else
{
if
(
ResumeThread
(
hThread
)
=
=
(
DWORD
)
-
1
)
{
PyErr_SetFromWindowsErr
(
0
)
;
CloseHandle
(
hThread
)
;
CloseHandle
(
hThreadSnap
)
;
return
FALSE
;
}
}
CloseHandle
(
hThread
)
;
}
}
while
(
Thread32Next
(
hThreadSnap
&
te32
)
)
;
CloseHandle
(
hThreadSnap
)
;
return
TRUE
;
}
static
PyObject
*
psutil_proc_suspend
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
suspend
=
1
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
!
psutil_proc_suspend_or_resume
(
pid
suspend
)
)
return
NULL
;
Py_RETURN_NONE
;
}
static
PyObject
*
psutil_proc_resume
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
suspend
=
0
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
!
psutil_proc_suspend_or_resume
(
pid
suspend
)
)
return
NULL
;
Py_RETURN_NONE
;
}
static
PyObject
*
psutil_proc_threads
(
PyObject
*
self
PyObject
*
args
)
{
HANDLE
hThread
;
THREADENTRY32
te32
=
{
0
}
;
long
pid
;
int
pid_return
;
int
rc
;
FILETIME
ftDummy
ftKernel
ftUser
;
HANDLE
hThreadSnap
=
NULL
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
goto
error
;
if
(
pid
=
=
0
)
{
AccessDenied
(
"
"
)
;
goto
error
;
}
pid_return
=
psutil_pid_is_running
(
pid
)
;
if
(
pid_return
=
=
0
)
{
NoSuchProcess
(
"
"
)
;
goto
error
;
}
if
(
pid_return
=
=
-
1
)
goto
error
;
hThreadSnap
=
CreateToolhelp32Snapshot
(
TH32CS_SNAPTHREAD
0
)
;
if
(
hThreadSnap
=
=
INVALID_HANDLE_VALUE
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
te32
.
dwSize
=
sizeof
(
THREADENTRY32
)
;
if
(
!
Thread32First
(
hThreadSnap
&
te32
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
do
{
if
(
te32
.
th32OwnerProcessID
=
=
pid
)
{
py_tuple
=
NULL
;
hThread
=
NULL
;
hThread
=
OpenThread
(
THREAD_QUERY_INFORMATION
FALSE
te32
.
th32ThreadID
)
;
if
(
hThread
=
=
NULL
)
{
continue
;
}
rc
=
GetThreadTimes
(
hThread
&
ftDummy
&
ftDummy
&
ftKernel
&
ftUser
)
;
if
(
rc
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
py_tuple
=
Py_BuildValue
(
"
kdd
"
te32
.
th32ThreadID
(
double
)
(
ftUser
.
dwHighDateTime
*
429
.
4967296
+
\
ftUser
.
dwLowDateTime
*
1e
-
7
)
(
double
)
(
ftKernel
.
dwHighDateTime
*
429
.
4967296
+
\
ftKernel
.
dwLowDateTime
*
1e
-
7
)
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
CloseHandle
(
hThread
)
;
}
}
while
(
Thread32Next
(
hThreadSnap
&
te32
)
)
;
CloseHandle
(
hThreadSnap
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
if
(
hThread
!
=
NULL
)
CloseHandle
(
hThread
)
;
if
(
hThreadSnap
!
=
NULL
)
CloseHandle
(
hThreadSnap
)
;
return
NULL
;
}
static
PyObject
*
psutil_proc_open_files
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
HANDLE
processHandle
;
DWORD
access
=
PROCESS_DUP_HANDLE
|
PROCESS_QUERY_INFORMATION
;
PyObject
*
py_retlist
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
processHandle
=
psutil_handle_from_pid_waccess
(
pid
access
)
;
if
(
processHandle
=
=
NULL
)
return
NULL
;
py_retlist
=
psutil_get_open_files
(
pid
processHandle
)
;
CloseHandle
(
processHandle
)
;
if
(
py_retlist
=
=
NULL
)
return
PyErr_SetFromWindowsErr
(
0
)
;
return
py_retlist
;
}
static
PyObject
*
psutil_win32_QueryDosDevice
(
PyObject
*
self
PyObject
*
args
)
{
LPCTSTR
lpDevicePath
;
TCHAR
d
=
TEXT
(
'
A
'
)
;
TCHAR
szBuff
[
5
]
;
if
(
!
PyArg_ParseTuple
(
args
"
s
"
&
lpDevicePath
)
)
return
NULL
;
while
(
d
<
=
TEXT
(
'
Z
'
)
)
{
TCHAR
szDeviceName
[
3
]
=
{
d
TEXT
(
'
:
'
)
TEXT
(
'
\
0
'
)
}
;
TCHAR
szTarget
[
512
]
=
{
0
}
;
if
(
QueryDosDevice
(
szDeviceName
szTarget
511
)
!
=
0
)
{
if
(
_tcscmp
(
lpDevicePath
szTarget
)
=
=
0
)
{
_stprintf_s
(
szBuff
_countof
(
szBuff
)
TEXT
(
"
%
c
:
"
)
d
)
;
return
Py_BuildValue
(
"
s
"
szBuff
)
;
}
}
d
+
+
;
}
return
Py_BuildValue
(
"
s
"
"
"
)
;
}
static
PyObject
*
psutil_proc_username
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
HANDLE
processHandle
=
NULL
;
HANDLE
tokenHandle
=
NULL
;
PTOKEN_USER
user
=
NULL
;
ULONG
bufferSize
;
WCHAR
*
name
=
NULL
;
WCHAR
*
domainName
=
NULL
;
ULONG
nameSize
;
ULONG
domainNameSize
;
SID_NAME_USE
nameUse
;
PyObject
*
py_username
;
PyObject
*
py_domain
;
PyObject
*
py_tuple
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
processHandle
=
psutil_handle_from_pid_waccess
(
pid
PROCESS_QUERY_INFORMATION
)
;
if
(
processHandle
=
=
NULL
)
return
NULL
;
if
(
!
OpenProcessToken
(
processHandle
TOKEN_QUERY
&
tokenHandle
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
CloseHandle
(
processHandle
)
;
processHandle
=
NULL
;
bufferSize
=
0x100
;
while
(
1
)
{
user
=
malloc
(
bufferSize
)
;
if
(
user
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
!
GetTokenInformation
(
tokenHandle
TokenUser
user
bufferSize
&
bufferSize
)
)
{
if
(
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
free
(
user
)
;
continue
;
}
else
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
}
break
;
}
CloseHandle
(
tokenHandle
)
;
tokenHandle
=
NULL
;
nameSize
=
0x100
;
domainNameSize
=
0x100
;
while
(
1
)
{
name
=
malloc
(
nameSize
*
sizeof
(
WCHAR
)
)
;
if
(
name
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
domainName
=
malloc
(
domainNameSize
*
sizeof
(
WCHAR
)
)
;
if
(
domainName
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
!
LookupAccountSidW
(
NULL
user
-
>
User
.
Sid
name
&
nameSize
domainName
&
domainNameSize
&
nameUse
)
)
{
if
(
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
free
(
name
)
;
free
(
domainName
)
;
continue
;
}
else
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
}
break
;
}
py_domain
=
PyUnicode_FromWideChar
(
domainName
wcslen
(
domainName
)
)
;
if
(
!
py_domain
)
goto
error
;
py_username
=
PyUnicode_FromWideChar
(
name
wcslen
(
name
)
)
;
if
(
!
py_username
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
OO
"
py_domain
py_username
)
;
if
(
!
py_tuple
)
goto
error
;
Py_DECREF
(
py_domain
)
;
Py_DECREF
(
py_username
)
;
free
(
name
)
;
free
(
domainName
)
;
free
(
user
)
;
return
py_tuple
;
error
:
if
(
processHandle
!
=
NULL
)
CloseHandle
(
processHandle
)
;
if
(
tokenHandle
!
=
NULL
)
CloseHandle
(
tokenHandle
)
;
if
(
name
!
=
NULL
)
free
(
name
)
;
if
(
domainName
!
=
NULL
)
free
(
domainName
)
;
if
(
user
!
=
NULL
)
free
(
user
)
;
Py_XDECREF
(
py_domain
)
;
Py_XDECREF
(
py_username
)
;
Py_XDECREF
(
py_tuple
)
;
return
NULL
;
}
typedef
DWORD
(
WINAPI
*
_GetExtendedTcpTable
)
(
PVOID
PDWORD
BOOL
ULONG
TCP_TABLE_CLASS
ULONG
)
;
static
DWORD
__GetExtendedTcpTable
(
_GetExtendedTcpTable
call
ULONG
address_family
PVOID
*
data
DWORD
*
size
)
{
DWORD
error
=
ERROR_INSUFFICIENT_BUFFER
;
*
size
=
0
;
*
data
=
NULL
;
Py_BEGIN_ALLOW_THREADS
;
error
=
call
(
NULL
size
FALSE
address_family
TCP_TABLE_OWNER_PID_ALL
0
)
;
while
(
error
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
*
data
=
malloc
(
*
size
)
;
if
(
*
data
=
=
NULL
)
{
error
=
ERROR_NOT_ENOUGH_MEMORY
;
continue
;
}
error
=
call
(
*
data
size
FALSE
address_family
TCP_TABLE_OWNER_PID_ALL
0
)
;
if
(
error
!
=
NO_ERROR
)
{
free
(
*
data
)
;
*
data
=
NULL
;
}
}
Py_END_ALLOW_THREADS
;
return
error
;
}
typedef
DWORD
(
WINAPI
*
_GetExtendedUdpTable
)
(
PVOID
PDWORD
BOOL
ULONG
UDP_TABLE_CLASS
ULONG
)
;
static
DWORD
__GetExtendedUdpTable
(
_GetExtendedUdpTable
call
ULONG
address_family
PVOID
*
data
DWORD
*
size
)
{
DWORD
error
=
ERROR_INSUFFICIENT_BUFFER
;
*
size
=
0
;
*
data
=
NULL
;
Py_BEGIN_ALLOW_THREADS
;
error
=
call
(
NULL
size
FALSE
address_family
UDP_TABLE_OWNER_PID
0
)
;
while
(
error
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
*
data
=
malloc
(
*
size
)
;
if
(
*
data
=
=
NULL
)
{
error
=
ERROR_NOT_ENOUGH_MEMORY
;
continue
;
}
error
=
call
(
*
data
size
FALSE
address_family
UDP_TABLE_OWNER_PID
0
)
;
if
(
error
!
=
NO_ERROR
)
{
free
(
*
data
)
;
*
data
=
NULL
;
}
}
Py_END_ALLOW_THREADS
;
return
error
;
}
static
PyObject
*
psutil_net_connections
(
PyObject
*
self
PyObject
*
args
)
{
static
long
null_address
[
4
]
=
{
0
0
0
0
}
;
unsigned
long
pid
;
int
pid_return
;
typedef
PSTR
(
NTAPI
*
_RtlIpv4AddressToStringA
)
(
struct
in_addr
*
PSTR
)
;
_RtlIpv4AddressToStringA
rtlIpv4AddressToStringA
;
typedef
PSTR
(
NTAPI
*
_RtlIpv6AddressToStringA
)
(
struct
in6_addr
*
PSTR
)
;
_RtlIpv6AddressToStringA
rtlIpv6AddressToStringA
;
_GetExtendedTcpTable
getExtendedTcpTable
;
_GetExtendedUdpTable
getExtendedUdpTable
;
PVOID
table
=
NULL
;
DWORD
tableSize
;
DWORD
error
;
PMIB_TCPTABLE_OWNER_PID
tcp4Table
;
PMIB_UDPTABLE_OWNER_PID
udp4Table
;
PMIB_TCP6TABLE_OWNER_PID
tcp6Table
;
PMIB_UDP6TABLE_OWNER_PID
udp6Table
;
ULONG
i
;
CHAR
addressBufferLocal
[
65
]
;
CHAR
addressBufferRemote
[
65
]
;
PyObject
*
py_retlist
;
PyObject
*
py_conn_tuple
=
NULL
;
PyObject
*
py_af_filter
=
NULL
;
PyObject
*
py_type_filter
=
NULL
;
PyObject
*
py_addr_tuple_local
=
NULL
;
PyObject
*
py_addr_tuple_remote
=
NULL
;
PyObject
*
_AF_INET
=
PyLong_FromLong
(
(
long
)
AF_INET
)
;
PyObject
*
_AF_INET6
=
PyLong_FromLong
(
(
long
)
AF_INET6
)
;
PyObject
*
_SOCK_STREAM
=
PyLong_FromLong
(
(
long
)
SOCK_STREAM
)
;
PyObject
*
_SOCK_DGRAM
=
PyLong_FromLong
(
(
long
)
SOCK_DGRAM
)
;
if
(
!
PyArg_ParseTuple
(
args
"
lOO
"
&
pid
&
py_af_filter
&
py_type_filter
)
)
{
_psutil_conn_decref_objs
(
)
;
return
NULL
;
}
if
(
!
PySequence_Check
(
py_af_filter
)
|
|
!
PySequence_Check
(
py_type_filter
)
)
{
_psutil_conn_decref_objs
(
)
;
PyErr_SetString
(
PyExc_TypeError
"
arg
2
or
3
is
not
a
sequence
"
)
;
return
NULL
;
}
if
(
pid
!
=
-
1
)
{
pid_return
=
psutil_pid_is_running
(
pid
)
;
if
(
pid_return
=
=
0
)
{
_psutil_conn_decref_objs
(
)
;
return
NoSuchProcess
(
"
"
)
;
}
else
if
(
pid_return
=
=
-
1
)
{
_psutil_conn_decref_objs
(
)
;
return
NULL
;
}
}
{
HMODULE
ntdll
;
HMODULE
iphlpapi
;
ntdll
=
LoadLibrary
(
TEXT
(
"
ntdll
.
dll
"
)
)
;
rtlIpv4AddressToStringA
=
(
_RtlIpv4AddressToStringA
)
GetProcAddress
(
ntdll
"
RtlIpv4AddressToStringA
"
)
;
rtlIpv6AddressToStringA
=
(
_RtlIpv6AddressToStringA
)
GetProcAddress
(
ntdll
"
RtlIpv6AddressToStringA
"
)
;
iphlpapi
=
LoadLibrary
(
TEXT
(
"
iphlpapi
.
dll
"
)
)
;
getExtendedTcpTable
=
(
_GetExtendedTcpTable
)
GetProcAddress
(
iphlpapi
"
GetExtendedTcpTable
"
)
;
getExtendedUdpTable
=
(
_GetExtendedUdpTable
)
GetProcAddress
(
iphlpapi
"
GetExtendedUdpTable
"
)
;
FreeLibrary
(
ntdll
)
;
FreeLibrary
(
iphlpapi
)
;
}
if
(
(
getExtendedTcpTable
=
=
NULL
)
|
|
(
getExtendedUdpTable
=
=
NULL
)
)
{
PyErr_SetString
(
PyExc_NotImplementedError
"
feature
not
supported
on
this
Windows
version
"
)
;
_psutil_conn_decref_objs
(
)
;
return
NULL
;
}
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
{
_psutil_conn_decref_objs
(
)
;
return
NULL
;
}
if
(
(
PySequence_Contains
(
py_af_filter
_AF_INET
)
=
=
1
)
&
&
(
PySequence_Contains
(
py_type_filter
_SOCK_STREAM
)
=
=
1
)
)
{
table
=
NULL
;
py_conn_tuple
=
NULL
;
py_addr_tuple_local
=
NULL
;
py_addr_tuple_remote
=
NULL
;
tableSize
=
0
;
error
=
__GetExtendedTcpTable
(
getExtendedTcpTable
AF_INET
&
table
&
tableSize
)
;
if
(
error
=
=
ERROR_NOT_ENOUGH_MEMORY
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
error
=
=
NO_ERROR
)
{
tcp4Table
=
table
;
for
(
i
=
0
;
i
<
tcp4Table
-
>
dwNumEntries
;
i
+
+
)
{
if
(
pid
!
=
-
1
)
{
if
(
tcp4Table
-
>
table
[
i
]
.
dwOwningPid
!
=
pid
)
{
continue
;
}
}
if
(
tcp4Table
-
>
table
[
i
]
.
dwLocalAddr
!
=
0
|
|
tcp4Table
-
>
table
[
i
]
.
dwLocalPort
!
=
0
)
{
struct
in_addr
addr
;
addr
.
S_un
.
S_addr
=
tcp4Table
-
>
table
[
i
]
.
dwLocalAddr
;
rtlIpv4AddressToStringA
(
&
addr
addressBufferLocal
)
;
py_addr_tuple_local
=
Py_BuildValue
(
"
(
si
)
"
addressBufferLocal
BYTESWAP_USHORT
(
tcp4Table
-
>
table
[
i
]
.
dwLocalPort
)
)
;
}
else
{
py_addr_tuple_local
=
PyTuple_New
(
0
)
;
}
if
(
py_addr_tuple_local
=
=
NULL
)
goto
error
;
if
(
(
tcp4Table
-
>
table
[
i
]
.
dwRemoteAddr
!
=
0
|
|
tcp4Table
-
>
table
[
i
]
.
dwRemotePort
!
=
0
)
&
&
(
tcp4Table
-
>
table
[
i
]
.
dwState
!
=
MIB_TCP_STATE_LISTEN
)
)
{
struct
in_addr
addr
;
addr
.
S_un
.
S_addr
=
tcp4Table
-
>
table
[
i
]
.
dwRemoteAddr
;
rtlIpv4AddressToStringA
(
&
addr
addressBufferRemote
)
;
py_addr_tuple_remote
=
Py_BuildValue
(
"
(
si
)
"
addressBufferRemote
BYTESWAP_USHORT
(
tcp4Table
-
>
table
[
i
]
.
dwRemotePort
)
)
;
}
else
{
py_addr_tuple_remote
=
PyTuple_New
(
0
)
;
}
if
(
py_addr_tuple_remote
=
=
NULL
)
goto
error
;
py_conn_tuple
=
Py_BuildValue
(
"
(
iiiNNiI
)
"
-
1
AF_INET
SOCK_STREAM
py_addr_tuple_local
py_addr_tuple_remote
tcp4Table
-
>
table
[
i
]
.
dwState
tcp4Table
-
>
table
[
i
]
.
dwOwningPid
)
;
if
(
!
py_conn_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_conn_tuple
)
)
goto
error
;
Py_DECREF
(
py_conn_tuple
)
;
}
}
else
{
PyErr_SetFromWindowsErr
(
error
)
;
goto
error
;
}
free
(
table
)
;
table
=
NULL
;
tableSize
=
0
;
}
if
(
(
PySequence_Contains
(
py_af_filter
_AF_INET6
)
=
=
1
)
&
&
(
PySequence_Contains
(
py_type_filter
_SOCK_STREAM
)
=
=
1
)
)
{
table
=
NULL
;
py_conn_tuple
=
NULL
;
py_addr_tuple_local
=
NULL
;
py_addr_tuple_remote
=
NULL
;
tableSize
=
0
;
error
=
__GetExtendedTcpTable
(
getExtendedTcpTable
AF_INET6
&
table
&
tableSize
)
;
if
(
error
=
=
ERROR_NOT_ENOUGH_MEMORY
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
error
=
=
NO_ERROR
)
{
tcp6Table
=
table
;
for
(
i
=
0
;
i
<
tcp6Table
-
>
dwNumEntries
;
i
+
+
)
{
if
(
pid
!
=
-
1
)
{
if
(
tcp6Table
-
>
table
[
i
]
.
dwOwningPid
!
=
pid
)
{
continue
;
}
}
if
(
memcmp
(
tcp6Table
-
>
table
[
i
]
.
ucLocalAddr
null_address
16
)
!
=
0
|
|
tcp6Table
-
>
table
[
i
]
.
dwLocalPort
!
=
0
)
{
struct
in6_addr
addr
;
memcpy
(
&
addr
tcp6Table
-
>
table
[
i
]
.
ucLocalAddr
16
)
;
rtlIpv6AddressToStringA
(
&
addr
addressBufferLocal
)
;
py_addr_tuple_local
=
Py_BuildValue
(
"
(
si
)
"
addressBufferLocal
BYTESWAP_USHORT
(
tcp6Table
-
>
table
[
i
]
.
dwLocalPort
)
)
;
}
else
{
py_addr_tuple_local
=
PyTuple_New
(
0
)
;
}
if
(
py_addr_tuple_local
=
=
NULL
)
goto
error
;
if
(
(
memcmp
(
tcp6Table
-
>
table
[
i
]
.
ucRemoteAddr
null_address
16
)
!
=
0
|
|
tcp6Table
-
>
table
[
i
]
.
dwRemotePort
!
=
0
)
&
&
(
tcp6Table
-
>
table
[
i
]
.
dwState
!
=
MIB_TCP_STATE_LISTEN
)
)
{
struct
in6_addr
addr
;
memcpy
(
&
addr
tcp6Table
-
>
table
[
i
]
.
ucRemoteAddr
16
)
;
rtlIpv6AddressToStringA
(
&
addr
addressBufferRemote
)
;
py_addr_tuple_remote
=
Py_BuildValue
(
"
(
si
)
"
addressBufferRemote
BYTESWAP_USHORT
(
tcp6Table
-
>
table
[
i
]
.
dwRemotePort
)
)
;
}
else
{
py_addr_tuple_remote
=
PyTuple_New
(
0
)
;
}
if
(
py_addr_tuple_remote
=
=
NULL
)
goto
error
;
py_conn_tuple
=
Py_BuildValue
(
"
(
iiiNNiI
)
"
-
1
AF_INET6
SOCK_STREAM
py_addr_tuple_local
py_addr_tuple_remote
tcp6Table
-
>
table
[
i
]
.
dwState
tcp6Table
-
>
table
[
i
]
.
dwOwningPid
)
;
if
(
!
py_conn_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_conn_tuple
)
)
goto
error
;
Py_DECREF
(
py_conn_tuple
)
;
}
}
else
{
PyErr_SetFromWindowsErr
(
error
)
;
goto
error
;
}
free
(
table
)
;
table
=
NULL
;
tableSize
=
0
;
}
if
(
(
PySequence_Contains
(
py_af_filter
_AF_INET
)
=
=
1
)
&
&
(
PySequence_Contains
(
py_type_filter
_SOCK_DGRAM
)
=
=
1
)
)
{
table
=
NULL
;
py_conn_tuple
=
NULL
;
py_addr_tuple_local
=
NULL
;
py_addr_tuple_remote
=
NULL
;
tableSize
=
0
;
error
=
__GetExtendedUdpTable
(
getExtendedUdpTable
AF_INET
&
table
&
tableSize
)
;
if
(
error
=
=
ERROR_NOT_ENOUGH_MEMORY
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
error
=
=
NO_ERROR
)
{
udp4Table
=
table
;
for
(
i
=
0
;
i
<
udp4Table
-
>
dwNumEntries
;
i
+
+
)
{
if
(
pid
!
=
-
1
)
{
if
(
udp4Table
-
>
table
[
i
]
.
dwOwningPid
!
=
pid
)
{
continue
;
}
}
if
(
udp4Table
-
>
table
[
i
]
.
dwLocalAddr
!
=
0
|
|
udp4Table
-
>
table
[
i
]
.
dwLocalPort
!
=
0
)
{
struct
in_addr
addr
;
addr
.
S_un
.
S_addr
=
udp4Table
-
>
table
[
i
]
.
dwLocalAddr
;
rtlIpv4AddressToStringA
(
&
addr
addressBufferLocal
)
;
py_addr_tuple_local
=
Py_BuildValue
(
"
(
si
)
"
addressBufferLocal
BYTESWAP_USHORT
(
udp4Table
-
>
table
[
i
]
.
dwLocalPort
)
)
;
}
else
{
py_addr_tuple_local
=
PyTuple_New
(
0
)
;
}
if
(
py_addr_tuple_local
=
=
NULL
)
goto
error
;
py_conn_tuple
=
Py_BuildValue
(
"
(
iiiNNiI
)
"
-
1
AF_INET
SOCK_DGRAM
py_addr_tuple_local
PyTuple_New
(
0
)
PSUTIL_CONN_NONE
udp4Table
-
>
table
[
i
]
.
dwOwningPid
)
;
if
(
!
py_conn_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_conn_tuple
)
)
goto
error
;
Py_DECREF
(
py_conn_tuple
)
;
}
}
else
{
PyErr_SetFromWindowsErr
(
error
)
;
goto
error
;
}
free
(
table
)
;
table
=
NULL
;
tableSize
=
0
;
}
if
(
(
PySequence_Contains
(
py_af_filter
_AF_INET6
)
=
=
1
)
&
&
(
PySequence_Contains
(
py_type_filter
_SOCK_DGRAM
)
=
=
1
)
)
{
table
=
NULL
;
py_conn_tuple
=
NULL
;
py_addr_tuple_local
=
NULL
;
py_addr_tuple_remote
=
NULL
;
tableSize
=
0
;
error
=
__GetExtendedUdpTable
(
getExtendedUdpTable
AF_INET6
&
table
&
tableSize
)
;
if
(
error
=
=
ERROR_NOT_ENOUGH_MEMORY
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
error
=
=
NO_ERROR
)
{
udp6Table
=
table
;
for
(
i
=
0
;
i
<
udp6Table
-
>
dwNumEntries
;
i
+
+
)
{
if
(
pid
!
=
-
1
)
{
if
(
udp6Table
-
>
table
[
i
]
.
dwOwningPid
!
=
pid
)
{
continue
;
}
}
if
(
memcmp
(
udp6Table
-
>
table
[
i
]
.
ucLocalAddr
null_address
16
)
!
=
0
|
|
udp6Table
-
>
table
[
i
]
.
dwLocalPort
!
=
0
)
{
struct
in6_addr
addr
;
memcpy
(
&
addr
udp6Table
-
>
table
[
i
]
.
ucLocalAddr
16
)
;
rtlIpv6AddressToStringA
(
&
addr
addressBufferLocal
)
;
py_addr_tuple_local
=
Py_BuildValue
(
"
(
si
)
"
addressBufferLocal
BYTESWAP_USHORT
(
udp6Table
-
>
table
[
i
]
.
dwLocalPort
)
)
;
}
else
{
py_addr_tuple_local
=
PyTuple_New
(
0
)
;
}
if
(
py_addr_tuple_local
=
=
NULL
)
goto
error
;
py_conn_tuple
=
Py_BuildValue
(
"
(
iiiNNiI
)
"
-
1
AF_INET6
SOCK_DGRAM
py_addr_tuple_local
PyTuple_New
(
0
)
PSUTIL_CONN_NONE
udp6Table
-
>
table
[
i
]
.
dwOwningPid
)
;
if
(
!
py_conn_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_conn_tuple
)
)
goto
error
;
Py_DECREF
(
py_conn_tuple
)
;
}
}
else
{
PyErr_SetFromWindowsErr
(
error
)
;
goto
error
;
}
free
(
table
)
;
table
=
NULL
;
tableSize
=
0
;
}
_psutil_conn_decref_objs
(
)
;
return
py_retlist
;
error
:
_psutil_conn_decref_objs
(
)
;
Py_XDECREF
(
py_conn_tuple
)
;
Py_XDECREF
(
py_addr_tuple_local
)
;
Py_XDECREF
(
py_addr_tuple_remote
)
;
Py_DECREF
(
py_retlist
)
;
if
(
table
!
=
NULL
)
free
(
table
)
;
return
NULL
;
}
static
PyObject
*
psutil_proc_priority_get
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
DWORD
priority
;
HANDLE
hProcess
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
priority
=
GetPriorityClass
(
hProcess
)
;
CloseHandle
(
hProcess
)
;
if
(
priority
=
=
0
)
return
PyErr_SetFromWindowsErr
(
0
)
;
return
Py_BuildValue
(
"
i
"
priority
)
;
}
static
PyObject
*
psutil_proc_priority_set
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
priority
;
int
retval
;
HANDLE
hProcess
;
DWORD
access
=
PROCESS_QUERY_INFORMATION
|
PROCESS_SET_INFORMATION
;
if
(
!
PyArg_ParseTuple
(
args
"
li
"
&
pid
&
priority
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid_waccess
(
pid
access
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
retval
=
SetPriorityClass
(
hProcess
priority
)
;
CloseHandle
(
hProcess
)
;
if
(
retval
=
=
0
)
return
PyErr_SetFromWindowsErr
(
0
)
;
Py_RETURN_NONE
;
}
#
if
(
_WIN32_WINNT
>
=
0x0600
)
static
PyObject
*
psutil_proc_io_priority_get
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
HANDLE
hProcess
;
PULONG
IoPriority
;
_NtQueryInformationProcess
NtQueryInformationProcess
=
(
_NtQueryInformationProcess
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
.
dll
"
)
"
NtQueryInformationProcess
"
)
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
NtQueryInformationProcess
(
hProcess
ProcessIoPriority
&
IoPriority
sizeof
(
ULONG
)
NULL
)
;
CloseHandle
(
hProcess
)
;
return
Py_BuildValue
(
"
i
"
IoPriority
)
;
}
static
PyObject
*
psutil_proc_io_priority_set
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
prio
;
HANDLE
hProcess
;
_NtSetInformationProcess
NtSetInformationProcess
=
(
_NtSetInformationProcess
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
.
dll
"
)
"
NtSetInformationProcess
"
)
;
if
(
NtSetInformationProcess
=
=
NULL
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
couldn
'
t
get
NtSetInformationProcess
syscall
"
)
;
return
NULL
;
}
if
(
!
PyArg_ParseTuple
(
args
"
li
"
&
pid
&
prio
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid_waccess
(
pid
PROCESS_ALL_ACCESS
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
NtSetInformationProcess
(
hProcess
ProcessIoPriority
(
PVOID
)
&
prio
sizeof
(
(
PVOID
)
prio
)
)
;
CloseHandle
(
hProcess
)
;
Py_RETURN_NONE
;
}
#
endif
static
PyObject
*
psutil_proc_io_counters
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
HANDLE
hProcess
;
IO_COUNTERS
IoCounters
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
NULL
=
=
hProcess
)
return
NULL
;
if
(
!
GetProcessIoCounters
(
hProcess
&
IoCounters
)
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
CloseHandle
(
hProcess
)
;
return
Py_BuildValue
(
"
(
KKKKKK
)
"
IoCounters
.
ReadOperationCount
IoCounters
.
WriteOperationCount
IoCounters
.
ReadTransferCount
IoCounters
.
WriteTransferCount
IoCounters
.
OtherOperationCount
IoCounters
.
OtherTransferCount
)
;
}
static
PyObject
*
psutil_proc_cpu_affinity_get
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
HANDLE
hProcess
;
DWORD_PTR
proc_mask
;
DWORD_PTR
system_mask
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
hProcess
=
=
NULL
)
{
return
NULL
;
}
if
(
GetProcessAffinityMask
(
hProcess
&
proc_mask
&
system_mask
)
=
=
0
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
CloseHandle
(
hProcess
)
;
#
ifdef
_WIN64
return
Py_BuildValue
(
"
K
"
(
unsigned
long
long
)
proc_mask
)
;
#
else
return
Py_BuildValue
(
"
k
"
(
unsigned
long
)
proc_mask
)
;
#
endif
}
static
PyObject
*
psutil_proc_cpu_affinity_set
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
HANDLE
hProcess
;
DWORD
dwDesiredAccess
=
\
PROCESS_QUERY_INFORMATION
|
PROCESS_SET_INFORMATION
;
DWORD_PTR
mask
;
#
ifdef
_WIN64
if
(
!
PyArg_ParseTuple
(
args
"
lK
"
&
pid
&
mask
)
)
#
else
if
(
!
PyArg_ParseTuple
(
args
"
lk
"
&
pid
&
mask
)
)
#
endif
{
return
NULL
;
}
hProcess
=
psutil_handle_from_pid_waccess
(
pid
dwDesiredAccess
)
;
if
(
hProcess
=
=
NULL
)
return
NULL
;
if
(
SetProcessAffinityMask
(
hProcess
mask
)
=
=
0
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
CloseHandle
(
hProcess
)
;
Py_RETURN_NONE
;
}
static
PyObject
*
psutil_proc_is_suspended
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
ULONG
i
;
PSYSTEM_PROCESS_INFORMATION
process
;
PVOID
buffer
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
!
psutil_get_proc_info
(
pid
&
process
&
buffer
)
)
{
return
NULL
;
}
for
(
i
=
0
;
i
<
process
-
>
NumberOfThreads
;
i
+
+
)
{
if
(
process
-
>
Threads
[
i
]
.
ThreadState
!
=
Waiting
|
|
process
-
>
Threads
[
i
]
.
WaitReason
!
=
Suspended
)
{
free
(
buffer
)
;
Py_RETURN_FALSE
;
}
}
free
(
buffer
)
;
Py_RETURN_TRUE
;
}
static
PyObject
*
psutil_disk_usage
(
PyObject
*
self
PyObject
*
args
)
{
BOOL
retval
;
ULARGE_INTEGER
_
total
free
;
char
*
path
;
if
(
PyArg_ParseTuple
(
args
"
u
"
&
path
)
)
{
Py_BEGIN_ALLOW_THREADS
retval
=
GetDiskFreeSpaceExW
(
(
LPCWSTR
)
path
&
_
&
total
&
free
)
;
Py_END_ALLOW_THREADS
goto
return_
;
}
#
if
PY_MAJOR_VERSION
<
=
2
PyErr_Clear
(
)
;
if
(
PyArg_ParseTuple
(
args
"
s
"
&
path
)
)
{
Py_BEGIN_ALLOW_THREADS
retval
=
GetDiskFreeSpaceEx
(
path
&
_
&
total
&
free
)
;
Py_END_ALLOW_THREADS
goto
return_
;
}
#
endif
return
NULL
;
return_
:
if
(
retval
=
=
0
)
return
PyErr_SetFromWindowsErr
(
0
)
;
else
return
Py_BuildValue
(
"
(
LL
)
"
total
.
QuadPart
free
.
QuadPart
)
;
}
static
PyObject
*
psutil_net_io_counters
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
dwRetVal
=
0
;
#
if
(
_WIN32_WINNT
>
=
0x0600
)
MIB_IF_ROW2
*
pIfRow
=
NULL
;
#
else
MIB_IFROW
*
pIfRow
=
NULL
;
#
endif
PIP_ADAPTER_ADDRESSES
pAddresses
=
NULL
;
PIP_ADAPTER_ADDRESSES
pCurrAddresses
=
NULL
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
PyObject
*
py_nic_info
=
NULL
;
PyObject
*
py_nic_name
=
NULL
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
pAddresses
=
psutil_get_nic_addresses
(
)
;
if
(
pAddresses
=
=
NULL
)
goto
error
;
pCurrAddresses
=
pAddresses
;
while
(
pCurrAddresses
)
{
py_nic_name
=
NULL
;
py_nic_info
=
NULL
;
#
if
(
_WIN32_WINNT
>
=
0x0600
)
pIfRow
=
(
MIB_IF_ROW2
*
)
malloc
(
sizeof
(
MIB_IF_ROW2
)
)
;
#
else
pIfRow
=
(
MIB_IFROW
*
)
malloc
(
sizeof
(
MIB_IFROW
)
)
;
#
endif
if
(
pIfRow
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
#
if
(
_WIN32_WINNT
>
=
0x0600
)
SecureZeroMemory
(
(
PVOID
)
pIfRow
sizeof
(
MIB_IF_ROW2
)
)
;
pIfRow
-
>
InterfaceIndex
=
pCurrAddresses
-
>
IfIndex
;
dwRetVal
=
GetIfEntry2
(
pIfRow
)
;
#
else
pIfRow
-
>
dwIndex
=
pCurrAddresses
-
>
IfIndex
;
dwRetVal
=
GetIfEntry
(
pIfRow
)
;
#
endif
if
(
dwRetVal
!
=
NO_ERROR
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
GetIfEntry
(
)
or
GetIfEntry2
(
)
syscalls
failed
.
"
)
;
goto
error
;
}
#
if
(
_WIN32_WINNT
>
=
0x0600
)
py_nic_info
=
Py_BuildValue
(
"
(
KKKKKKKK
)
"
pIfRow
-
>
OutOctets
pIfRow
-
>
InOctets
(
pIfRow
-
>
OutUcastPkts
+
pIfRow
-
>
OutNUcastPkts
)
(
pIfRow
-
>
InUcastPkts
+
pIfRow
-
>
InNUcastPkts
)
pIfRow
-
>
InErrors
pIfRow
-
>
OutErrors
pIfRow
-
>
InDiscards
pIfRow
-
>
OutDiscards
)
;
#
else
py_nic_info
=
Py_BuildValue
(
"
(
kkkkkkkk
)
"
pIfRow
-
>
dwOutOctets
pIfRow
-
>
dwInOctets
(
pIfRow
-
>
dwOutUcastPkts
+
pIfRow
-
>
dwOutNUcastPkts
)
(
pIfRow
-
>
dwInUcastPkts
+
pIfRow
-
>
dwInNUcastPkts
)
pIfRow
-
>
dwInErrors
pIfRow
-
>
dwOutErrors
pIfRow
-
>
dwInDiscards
pIfRow
-
>
dwOutDiscards
)
;
#
endif
if
(
!
py_nic_info
)
goto
error
;
py_nic_name
=
PyUnicode_FromWideChar
(
pCurrAddresses
-
>
FriendlyName
wcslen
(
pCurrAddresses
-
>
FriendlyName
)
)
;
if
(
py_nic_name
=
=
NULL
)
goto
error
;
if
(
PyDict_SetItem
(
py_retdict
py_nic_name
py_nic_info
)
)
goto
error
;
Py_XDECREF
(
py_nic_name
)
;
Py_XDECREF
(
py_nic_info
)
;
free
(
pIfRow
)
;
pCurrAddresses
=
pCurrAddresses
-
>
Next
;
}
free
(
pAddresses
)
;
return
py_retdict
;
error
:
Py_XDECREF
(
py_nic_name
)
;
Py_XDECREF
(
py_nic_info
)
;
Py_DECREF
(
py_retdict
)
;
if
(
pAddresses
!
=
NULL
)
free
(
pAddresses
)
;
if
(
pIfRow
!
=
NULL
)
free
(
pIfRow
)
;
return
NULL
;
}
static
PyObject
*
psutil_disk_io_counters
(
PyObject
*
self
PyObject
*
args
)
{
DISK_PERFORMANCE_WIN_2008
diskPerformance
;
DWORD
dwSize
;
HANDLE
hDevice
=
NULL
;
char
szDevice
[
MAX_PATH
]
;
char
szDeviceDisplay
[
MAX_PATH
]
;
int
devNum
;
int
i
;
size_t
ioctrlSize
;
BOOL
WINAPI
ret
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
for
(
devNum
=
0
;
devNum
<
=
32
;
+
+
devNum
)
{
py_tuple
=
NULL
;
sprintf_s
(
szDevice
MAX_PATH
"
\
\
\
\
.
\
\
PhysicalDrive
%
d
"
devNum
)
;
hDevice
=
CreateFile
(
szDevice
0
FILE_SHARE_READ
|
FILE_SHARE_WRITE
NULL
OPEN_EXISTING
0
NULL
)
;
if
(
hDevice
=
=
INVALID_HANDLE_VALUE
)
continue
;
i
=
0
;
ioctrlSize
=
sizeof
(
diskPerformance
)
;
while
(
1
)
{
i
+
=
1
;
ret
=
DeviceIoControl
(
hDevice
IOCTL_DISK_PERFORMANCE
NULL
0
&
diskPerformance
ioctrlSize
&
dwSize
NULL
)
;
if
(
ret
!
=
0
)
break
;
if
(
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
if
(
i
<
=
1024
)
{
ioctrlSize
*
=
2
;
continue
;
}
}
else
if
(
GetLastError
(
)
=
=
ERROR_INVALID_FUNCTION
)
{
psutil_debug
(
"
DeviceIoControl
-
>
ERROR_INVALID_FUNCTION
;
"
"
ignore
PhysicalDrive
%
i
"
devNum
)
;
goto
next
;
}
else
if
(
GetLastError
(
)
=
=
ERROR_NOT_SUPPORTED
)
{
psutil_debug
(
"
DeviceIoControl
-
>
ERROR_NOT_SUPPORTED
;
"
"
ignore
PhysicalDrive
%
i
"
devNum
)
;
goto
next
;
}
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
sprintf_s
(
szDeviceDisplay
MAX_PATH
"
PhysicalDrive
%
i
"
devNum
)
;
py_tuple
=
Py_BuildValue
(
"
(
IILLKK
)
"
diskPerformance
.
ReadCount
diskPerformance
.
WriteCount
diskPerformance
.
BytesRead
diskPerformance
.
BytesWritten
(
unsigned
long
long
)
(
diskPerformance
.
ReadTime
.
QuadPart
)
/
10000000
(
unsigned
long
long
)
(
diskPerformance
.
WriteTime
.
QuadPart
)
/
10000000
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyDict_SetItemString
(
py_retdict
szDeviceDisplay
py_tuple
)
)
goto
error
;
Py_XDECREF
(
py_tuple
)
;
next
:
CloseHandle
(
hDevice
)
;
}
return
py_retdict
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retdict
)
;
if
(
hDevice
!
=
NULL
)
CloseHandle
(
hDevice
)
;
return
NULL
;
}
static
char
*
psutil_get_drive_type
(
int
type
)
{
switch
(
type
)
{
case
DRIVE_FIXED
:
return
"
fixed
"
;
case
DRIVE_CDROM
:
return
"
cdrom
"
;
case
DRIVE_REMOVABLE
:
return
"
removable
"
;
case
DRIVE_UNKNOWN
:
return
"
unknown
"
;
case
DRIVE_NO_ROOT_DIR
:
return
"
unmounted
"
;
case
DRIVE_REMOTE
:
return
"
remote
"
;
case
DRIVE_RAMDISK
:
return
"
ramdisk
"
;
default
:
return
"
?
"
;
}
}
#
ifndef
_ARRAYSIZE
#
define
_ARRAYSIZE
(
a
)
(
sizeof
(
a
)
/
sizeof
(
a
[
0
]
)
)
#
endif
static
PyObject
*
psutil_disk_partitions
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
num_bytes
;
char
drive_strings
[
255
]
;
char
*
drive_letter
=
drive_strings
;
char
mp_buf
[
MAX_PATH
]
;
char
mp_path
[
MAX_PATH
]
;
int
all
;
int
type
;
int
ret
;
unsigned
int
old_mode
=
0
;
char
opts
[
20
]
;
HANDLE
mp_h
;
BOOL
mp_flag
=
TRUE
;
LPTSTR
fs_type
[
MAX_PATH
+
1
]
=
{
0
}
;
DWORD
pflags
=
0
;
PyObject
*
py_all
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retlist
=
=
NULL
)
{
return
NULL
;
}
old_mode
=
SetErrorMode
(
SEM_FAILCRITICALERRORS
)
;
if
(
!
PyArg_ParseTuple
(
args
"
O
"
&
py_all
)
)
goto
error
;
all
=
PyObject_IsTrue
(
py_all
)
;
Py_BEGIN_ALLOW_THREADS
num_bytes
=
GetLogicalDriveStrings
(
254
drive_letter
)
;
Py_END_ALLOW_THREADS
if
(
num_bytes
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
while
(
*
drive_letter
!
=
0
)
{
py_tuple
=
NULL
;
opts
[
0
]
=
0
;
fs_type
[
0
]
=
0
;
Py_BEGIN_ALLOW_THREADS
type
=
GetDriveType
(
drive_letter
)
;
Py_END_ALLOW_THREADS
if
(
all
=
=
0
)
{
if
(
(
type
=
=
DRIVE_UNKNOWN
)
|
|
(
type
=
=
DRIVE_NO_ROOT_DIR
)
|
|
(
type
=
=
DRIVE_REMOTE
)
|
|
(
type
=
=
DRIVE_RAMDISK
)
)
{
goto
next
;
}
if
(
(
type
=
=
DRIVE_REMOVABLE
)
&
&
(
strcmp
(
drive_letter
"
A
:
\
\
"
)
=
=
0
)
)
{
goto
next
;
}
}
ret
=
GetVolumeInformation
(
(
LPCTSTR
)
drive_letter
NULL
_ARRAYSIZE
(
drive_letter
)
NULL
NULL
&
pflags
(
LPTSTR
)
fs_type
_ARRAYSIZE
(
fs_type
)
)
;
if
(
ret
=
=
0
)
{
strcat_s
(
opts
_countof
(
opts
)
"
"
)
;
SetLastError
(
0
)
;
}
else
{
if
(
pflags
&
FILE_READ_ONLY_VOLUME
)
strcat_s
(
opts
_countof
(
opts
)
"
ro
"
)
;
else
strcat_s
(
opts
_countof
(
opts
)
"
rw
"
)
;
if
(
pflags
&
FILE_VOLUME_IS_COMPRESSED
)
strcat_s
(
opts
_countof
(
opts
)
"
compressed
"
)
;
if
(
pflags
&
FILE_SUPPORTS_REPARSE_POINTS
)
{
mp_h
=
FindFirstVolumeMountPoint
(
drive_letter
mp_buf
MAX_PATH
)
;
if
(
mp_h
!
=
INVALID_HANDLE_VALUE
)
{
while
(
mp_flag
)
{
strcpy_s
(
mp_path
_countof
(
mp_path
)
drive_letter
)
;
strcat_s
(
mp_path
_countof
(
mp_path
)
mp_buf
)
;
py_tuple
=
Py_BuildValue
(
"
(
ssss
)
"
drive_letter
mp_path
fs_type
opts
)
;
if
(
!
py_tuple
|
|
PyList_Append
(
py_retlist
py_tuple
)
=
=
-
1
)
{
FindVolumeMountPointClose
(
mp_h
)
;
goto
error
;
}
Py_DECREF
(
py_tuple
)
;
mp_flag
=
FindNextVolumeMountPoint
(
mp_h
mp_buf
MAX_PATH
)
;
}
FindVolumeMountPointClose
(
mp_h
)
;
}
}
}
if
(
strlen
(
opts
)
>
0
)
strcat_s
(
opts
_countof
(
opts
)
"
"
)
;
strcat_s
(
opts
_countof
(
opts
)
psutil_get_drive_type
(
type
)
)
;
py_tuple
=
Py_BuildValue
(
"
(
ssss
)
"
drive_letter
drive_letter
fs_type
opts
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
goto
next
;
next
:
drive_letter
=
strchr
(
drive_letter
0
)
+
1
;
}
SetErrorMode
(
old_mode
)
;
return
py_retlist
;
error
:
SetErrorMode
(
old_mode
)
;
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
return
NULL
;
}
static
PyObject
*
psutil_users
(
PyObject
*
self
PyObject
*
args
)
{
HANDLE
hServer
=
WTS_CURRENT_SERVER_HANDLE
;
WCHAR
*
buffer_user
=
NULL
;
LPTSTR
buffer_addr
=
NULL
;
PWTS_SESSION_INFO
sessions
=
NULL
;
DWORD
count
;
DWORD
i
;
DWORD
sessionId
;
DWORD
bytes
;
PWTS_CLIENT_ADDRESS
address
;
char
address_str
[
50
]
;
long
long
unix_time
;
PWINSTATIONQUERYINFORMATIONW
WinStationQueryInformationW
;
WINSTATION_INFO
station_info
;
HINSTANCE
hInstWinSta
=
NULL
;
ULONG
returnLen
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_address
=
NULL
;
PyObject
*
py_username
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
hInstWinSta
=
LoadLibraryA
(
"
winsta
.
dll
"
)
;
WinStationQueryInformationW
=
(
PWINSTATIONQUERYINFORMATIONW
)
\
GetProcAddress
(
hInstWinSta
"
WinStationQueryInformationW
"
)
;
if
(
WTSEnumerateSessions
(
hServer
0
1
&
sessions
&
count
)
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
py_address
=
NULL
;
py_tuple
=
NULL
;
sessionId
=
sessions
[
i
]
.
SessionId
;
if
(
buffer_user
!
=
NULL
)
WTSFreeMemory
(
buffer_user
)
;
if
(
buffer_addr
!
=
NULL
)
WTSFreeMemory
(
buffer_addr
)
;
buffer_user
=
NULL
;
buffer_addr
=
NULL
;
bytes
=
0
;
if
(
WTSQuerySessionInformationW
(
hServer
sessionId
WTSUserName
&
buffer_user
&
bytes
)
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
bytes
<
=
2
)
continue
;
bytes
=
0
;
if
(
WTSQuerySessionInformation
(
hServer
sessionId
WTSClientAddress
&
buffer_addr
&
bytes
)
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
address
=
(
PWTS_CLIENT_ADDRESS
)
buffer_addr
;
if
(
address
-
>
AddressFamily
=
=
0
)
{
sprintf_s
(
address_str
_countof
(
address_str
)
"
%
u
.
%
u
.
%
u
.
%
u
"
address
-
>
Address
[
0
]
address
-
>
Address
[
1
]
address
-
>
Address
[
2
]
address
-
>
Address
[
3
]
)
;
py_address
=
Py_BuildValue
(
"
s
"
address_str
)
;
if
(
!
py_address
)
goto
error
;
}
else
{
py_address
=
Py_None
;
}
if
(
!
WinStationQueryInformationW
(
hServer
sessionId
WinStationInformation
&
station_info
sizeof
(
station_info
)
&
returnLen
)
)
{
goto
error
;
}
unix_time
=
(
(
LONGLONG
)
station_info
.
ConnectTime
.
dwHighDateTime
)
<
<
32
;
unix_time
+
=
\
station_info
.
ConnectTime
.
dwLowDateTime
-
116444736000000000LL
;
unix_time
/
=
10000000
;
py_username
=
PyUnicode_FromWideChar
(
buffer_user
wcslen
(
buffer_user
)
)
;
if
(
py_username
=
=
NULL
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
OOd
"
py_username
py_address
(
double
)
unix_time
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_XDECREF
(
py_username
)
;
Py_XDECREF
(
py_address
)
;
Py_XDECREF
(
py_tuple
)
;
}
WTSFreeMemory
(
sessions
)
;
WTSFreeMemory
(
buffer_user
)
;
WTSFreeMemory
(
buffer_addr
)
;
FreeLibrary
(
hInstWinSta
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_username
)
;
Py_XDECREF
(
py_tuple
)
;
Py_XDECREF
(
py_address
)
;
Py_DECREF
(
py_retlist
)
;
if
(
hInstWinSta
!
=
NULL
)
FreeLibrary
(
hInstWinSta
)
;
if
(
sessions
!
=
NULL
)
WTSFreeMemory
(
sessions
)
;
if
(
buffer_user
!
=
NULL
)
WTSFreeMemory
(
buffer_user
)
;
if
(
buffer_addr
!
=
NULL
)
WTSFreeMemory
(
buffer_addr
)
;
return
NULL
;
}
static
PyObject
*
psutil_proc_num_handles
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
HANDLE
hProcess
;
DWORD
handleCount
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
NULL
=
=
hProcess
)
return
NULL
;
if
(
!
GetProcessHandleCount
(
hProcess
&
handleCount
)
)
{
CloseHandle
(
hProcess
)
;
return
PyErr_SetFromWindowsErr
(
0
)
;
}
CloseHandle
(
hProcess
)
;
return
Py_BuildValue
(
"
k
"
handleCount
)
;
}
static
PyObject
*
psutil_proc_info
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
pid
;
PSYSTEM_PROCESS_INFORMATION
process
;
PVOID
buffer
;
ULONG
i
;
ULONG
ctx_switches
=
0
;
double
user_time
;
double
kernel_time
;
long
long
create_time
;
SIZE_T
mem_private
;
PyObject
*
py_retlist
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
!
psutil_get_proc_info
(
pid
&
process
&
buffer
)
)
return
NULL
;
for
(
i
=
0
;
i
<
process
-
>
NumberOfThreads
;
i
+
+
)
ctx_switches
+
=
process
-
>
Threads
[
i
]
.
ContextSwitches
;
user_time
=
(
double
)
process
-
>
UserTime
.
HighPart
*
429
.
4967296
+
\
(
double
)
process
-
>
UserTime
.
LowPart
*
1e
-
7
;
kernel_time
=
(
double
)
process
-
>
KernelTime
.
HighPart
*
429
.
4967296
+
\
(
double
)
process
-
>
KernelTime
.
LowPart
*
1e
-
7
;
if
(
0
=
=
pid
|
|
4
=
=
pid
)
{
create_time
=
0
;
}
else
{
create_time
=
(
(
LONGLONG
)
process
-
>
CreateTime
.
HighPart
)
<
<
32
;
create_time
+
=
process
-
>
CreateTime
.
LowPart
-
116444736000000000LL
;
create_time
/
=
10000000
;
}
#
if
(
_WIN32_WINNT
>
=
0x0501
)
mem_private
=
process
-
>
PrivatePageCount
;
#
else
mem_private
=
0
;
#
endif
py_retlist
=
Py_BuildValue
(
#
if
defined
(
_WIN64
)
"
kkdddiKKKKKK
"
"
kKKKKKKKKK
"
#
else
"
kkdddiKKKKKK
"
"
kIIIIIIIII
"
#
endif
process
-
>
HandleCount
ctx_switches
user_time
kernel_time
(
double
)
create_time
(
int
)
process
-
>
NumberOfThreads
process
-
>
ReadOperationCount
.
QuadPart
process
-
>
WriteOperationCount
.
QuadPart
process
-
>
ReadTransferCount
.
QuadPart
process
-
>
WriteTransferCount
.
QuadPart
process
-
>
OtherOperationCount
.
QuadPart
process
-
>
OtherTransferCount
.
QuadPart
process
-
>
PageFaultCount
process
-
>
PeakWorkingSetSize
process
-
>
WorkingSetSize
process
-
>
QuotaPeakPagedPoolUsage
process
-
>
QuotaPagedPoolUsage
process
-
>
QuotaPeakNonPagedPoolUsage
process
-
>
QuotaNonPagedPoolUsage
process
-
>
PagefileUsage
process
-
>
PeakPagefileUsage
mem_private
)
;
free
(
buffer
)
;
return
py_retlist
;
}
static
char
*
get_region_protection_string
(
ULONG
protection
)
{
switch
(
protection
&
0xff
)
{
case
PAGE_NOACCESS
:
return
"
"
;
case
PAGE_READONLY
:
return
"
r
"
;
case
PAGE_READWRITE
:
return
"
rw
"
;
case
PAGE_WRITECOPY
:
return
"
wc
"
;
case
PAGE_EXECUTE
:
return
"
x
"
;
case
PAGE_EXECUTE_READ
:
return
"
xr
"
;
case
PAGE_EXECUTE_READWRITE
:
return
"
xrw
"
;
case
PAGE_EXECUTE_WRITECOPY
:
return
"
xwc
"
;
default
:
return
"
?
"
;
}
}
static
PyObject
*
psutil_proc_memory_maps
(
PyObject
*
self
PyObject
*
args
)
{
#
ifdef
_WIN64
MEMORY_BASIC_INFORMATION64
basicInfo
;
#
else
MEMORY_BASIC_INFORMATION
basicInfo
;
#
endif
DWORD
pid
;
HANDLE
hProcess
=
NULL
;
PVOID
baseAddress
;
PVOID
previousAllocationBase
;
WCHAR
mappedFileName
[
MAX_PATH
]
;
SYSTEM_INFO
system_info
;
LPVOID
maxAddr
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_str
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
goto
error
;
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
NULL
=
=
hProcess
)
goto
error
;
GetSystemInfo
(
&
system_info
)
;
maxAddr
=
system_info
.
lpMaximumApplicationAddress
;
baseAddress
=
NULL
;
previousAllocationBase
=
NULL
;
while
(
VirtualQueryEx
(
hProcess
baseAddress
&
basicInfo
sizeof
(
MEMORY_BASIC_INFORMATION
)
)
)
{
py_tuple
=
NULL
;
if
(
baseAddress
>
maxAddr
)
break
;
if
(
GetMappedFileNameW
(
hProcess
baseAddress
mappedFileName
sizeof
(
mappedFileName
)
)
)
{
py_str
=
PyUnicode_FromWideChar
(
mappedFileName
wcslen
(
mappedFileName
)
)
;
if
(
py_str
=
=
NULL
)
goto
error
;
#
ifdef
_WIN64
py_tuple
=
Py_BuildValue
(
"
(
KsOI
)
"
(
unsigned
long
long
)
baseAddress
#
else
py_tuple
=
Py_BuildValue
(
"
(
ksOI
)
"
(
unsigned
long
)
baseAddress
#
endif
get_region_protection_string
(
basicInfo
.
Protect
)
py_str
basicInfo
.
RegionSize
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
Py_DECREF
(
py_str
)
;
}
previousAllocationBase
=
basicInfo
.
AllocationBase
;
baseAddress
=
(
PCHAR
)
baseAddress
+
basicInfo
.
RegionSize
;
}
CloseHandle
(
hProcess
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_XDECREF
(
py_str
)
;
Py_DECREF
(
py_retlist
)
;
if
(
hProcess
!
=
NULL
)
CloseHandle
(
hProcess
)
;
return
NULL
;
}
static
PyObject
*
psutil_ppid_map
(
PyObject
*
self
PyObject
*
args
)
{
PyObject
*
py_pid
=
NULL
;
PyObject
*
py_ppid
=
NULL
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
HANDLE
handle
=
NULL
;
PROCESSENTRY32
pe
=
{
0
}
;
pe
.
dwSize
=
sizeof
(
PROCESSENTRY32
)
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
handle
=
CreateToolhelp32Snapshot
(
TH32CS_SNAPPROCESS
0
)
;
if
(
handle
=
=
INVALID_HANDLE_VALUE
)
{
PyErr_SetFromWindowsErr
(
0
)
;
Py_DECREF
(
py_retdict
)
;
return
NULL
;
}
if
(
Process32First
(
handle
&
pe
)
)
{
do
{
py_pid
=
Py_BuildValue
(
"
I
"
pe
.
th32ProcessID
)
;
if
(
py_pid
=
=
NULL
)
goto
error
;
py_ppid
=
Py_BuildValue
(
"
I
"
pe
.
th32ParentProcessID
)
;
if
(
py_ppid
=
=
NULL
)
goto
error
;
if
(
PyDict_SetItem
(
py_retdict
py_pid
py_ppid
)
)
goto
error
;
Py_DECREF
(
py_pid
)
;
Py_DECREF
(
py_ppid
)
;
}
while
(
Process32Next
(
handle
&
pe
)
)
;
}
CloseHandle
(
handle
)
;
return
py_retdict
;
error
:
Py_XDECREF
(
py_pid
)
;
Py_XDECREF
(
py_ppid
)
;
Py_DECREF
(
py_retdict
)
;
CloseHandle
(
handle
)
;
return
NULL
;
}
static
PyObject
*
psutil_net_if_addrs
(
PyObject
*
self
PyObject
*
args
)
{
unsigned
int
i
=
0
;
ULONG
family
;
PCTSTR
intRet
;
PCTSTR
netmaskIntRet
;
char
*
ptr
;
char
buff_addr
[
1024
]
;
char
buff_macaddr
[
1024
]
;
char
buff_netmask
[
1024
]
;
DWORD
dwRetVal
=
0
;
#
if
(
_WIN32_WINNT
>
=
0x0600
)
ULONG
converted_netmask
;
UINT
netmask_bits
;
struct
in_addr
in_netmask
;
#
endif
PIP_ADAPTER_ADDRESSES
pAddresses
=
NULL
;
PIP_ADAPTER_ADDRESSES
pCurrAddresses
=
NULL
;
PIP_ADAPTER_UNICAST_ADDRESS
pUnicast
=
NULL
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_address
=
NULL
;
PyObject
*
py_mac_address
=
NULL
;
PyObject
*
py_nic_name
=
NULL
;
PyObject
*
py_netmask
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
pAddresses
=
psutil_get_nic_addresses
(
)
;
if
(
pAddresses
=
=
NULL
)
goto
error
;
pCurrAddresses
=
pAddresses
;
while
(
pCurrAddresses
)
{
pUnicast
=
pCurrAddresses
-
>
FirstUnicastAddress
;
netmaskIntRet
=
NULL
;
py_nic_name
=
NULL
;
py_nic_name
=
PyUnicode_FromWideChar
(
pCurrAddresses
-
>
FriendlyName
wcslen
(
pCurrAddresses
-
>
FriendlyName
)
)
;
if
(
py_nic_name
=
=
NULL
)
goto
error
;
if
(
pCurrAddresses
-
>
PhysicalAddressLength
!
=
0
)
{
ptr
=
buff_macaddr
;
*
ptr
=
'
\
0
'
;
for
(
i
=
0
;
i
<
(
int
)
pCurrAddresses
-
>
PhysicalAddressLength
;
i
+
+
)
{
if
(
i
=
=
(
pCurrAddresses
-
>
PhysicalAddressLength
-
1
)
)
{
sprintf_s
(
ptr
_countof
(
buff_macaddr
)
"
%
.
2X
\
n
"
(
int
)
pCurrAddresses
-
>
PhysicalAddress
[
i
]
)
;
}
else
{
sprintf_s
(
ptr
_countof
(
buff_macaddr
)
"
%
.
2X
-
"
(
int
)
pCurrAddresses
-
>
PhysicalAddress
[
i
]
)
;
}
ptr
+
=
3
;
}
*
-
-
ptr
=
'
\
0
'
;
py_mac_address
=
Py_BuildValue
(
"
s
"
buff_macaddr
)
;
if
(
py_mac_address
=
=
NULL
)
goto
error
;
Py_INCREF
(
Py_None
)
;
Py_INCREF
(
Py_None
)
;
Py_INCREF
(
Py_None
)
;
py_tuple
=
Py_BuildValue
(
"
(
OiOOOO
)
"
py_nic_name
-
1
py_mac_address
Py_None
Py_None
Py_None
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
Py_DECREF
(
py_mac_address
)
;
}
if
(
pUnicast
!
=
NULL
)
{
for
(
i
=
0
;
pUnicast
!
=
NULL
;
i
+
+
)
{
family
=
pUnicast
-
>
Address
.
lpSockaddr
-
>
sa_family
;
if
(
family
=
=
AF_INET
)
{
struct
sockaddr_in
*
sa_in
=
(
struct
sockaddr_in
*
)
pUnicast
-
>
Address
.
lpSockaddr
;
intRet
=
inet_ntop
(
AF_INET
&
(
sa_in
-
>
sin_addr
)
buff_addr
sizeof
(
buff_addr
)
)
;
if
(
!
intRet
)
goto
error
;
#
if
(
_WIN32_WINNT
>
=
0x0600
)
netmask_bits
=
pUnicast
-
>
OnLinkPrefixLength
;
dwRetVal
=
ConvertLengthToIpv4Mask
(
netmask_bits
&
converted_netmask
)
;
if
(
dwRetVal
=
=
NO_ERROR
)
{
in_netmask
.
s_addr
=
converted_netmask
;
netmaskIntRet
=
inet_ntop
(
AF_INET
&
in_netmask
buff_netmask
sizeof
(
buff_netmask
)
)
;
if
(
!
netmaskIntRet
)
goto
error
;
}
#
endif
}
else
if
(
family
=
=
AF_INET6
)
{
struct
sockaddr_in6
*
sa_in6
=
(
struct
sockaddr_in6
*
)
pUnicast
-
>
Address
.
lpSockaddr
;
intRet
=
inet_ntop
(
AF_INET6
&
(
sa_in6
-
>
sin6_addr
)
buff_addr
sizeof
(
buff_addr
)
)
;
if
(
!
intRet
)
goto
error
;
}
else
{
pUnicast
=
pUnicast
-
>
Next
;
continue
;
}
#
if
PY_MAJOR_VERSION
>
=
3
py_address
=
PyUnicode_FromString
(
buff_addr
)
;
#
else
py_address
=
PyString_FromString
(
buff_addr
)
;
#
endif
if
(
py_address
=
=
NULL
)
goto
error
;
if
(
netmaskIntRet
!
=
NULL
)
{
#
if
PY_MAJOR_VERSION
>
=
3
py_netmask
=
PyUnicode_FromString
(
buff_netmask
)
;
#
else
py_netmask
=
PyString_FromString
(
buff_netmask
)
;
#
endif
}
else
{
Py_INCREF
(
Py_None
)
;
py_netmask
=
Py_None
;
}
Py_INCREF
(
Py_None
)
;
Py_INCREF
(
Py_None
)
;
py_tuple
=
Py_BuildValue
(
"
(
OiOOOO
)
"
py_nic_name
family
py_address
py_netmask
Py_None
Py_None
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
Py_DECREF
(
py_address
)
;
Py_DECREF
(
py_netmask
)
;
pUnicast
=
pUnicast
-
>
Next
;
}
}
Py_DECREF
(
py_nic_name
)
;
pCurrAddresses
=
pCurrAddresses
-
>
Next
;
}
free
(
pAddresses
)
;
return
py_retlist
;
error
:
if
(
pAddresses
)
free
(
pAddresses
)
;
Py_DECREF
(
py_retlist
)
;
Py_XDECREF
(
py_tuple
)
;
Py_XDECREF
(
py_address
)
;
Py_XDECREF
(
py_nic_name
)
;
Py_XDECREF
(
py_netmask
)
;
return
NULL
;
}
static
PyObject
*
psutil_net_if_stats
(
PyObject
*
self
PyObject
*
args
)
{
int
i
;
DWORD
dwSize
=
0
;
DWORD
dwRetVal
=
0
;
MIB_IFTABLE
*
pIfTable
;
MIB_IFROW
*
pIfRow
;
PIP_ADAPTER_ADDRESSES
pAddresses
=
NULL
;
PIP_ADAPTER_ADDRESSES
pCurrAddresses
=
NULL
;
char
descr
[
MAX_PATH
]
;
int
ifname_found
;
PyObject
*
py_nic_name
=
NULL
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
PyObject
*
py_ifc_info
=
NULL
;
PyObject
*
py_is_up
=
NULL
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
pAddresses
=
psutil_get_nic_addresses
(
)
;
if
(
pAddresses
=
=
NULL
)
goto
error
;
pIfTable
=
(
MIB_IFTABLE
*
)
malloc
(
sizeof
(
MIB_IFTABLE
)
)
;
if
(
pIfTable
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
dwSize
=
sizeof
(
MIB_IFTABLE
)
;
if
(
GetIfTable
(
pIfTable
&
dwSize
FALSE
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
free
(
pIfTable
)
;
pIfTable
=
(
MIB_IFTABLE
*
)
malloc
(
dwSize
)
;
if
(
pIfTable
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
}
if
(
(
dwRetVal
=
GetIfTable
(
pIfTable
&
dwSize
FALSE
)
)
!
=
NO_ERROR
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
GetIfTable
(
)
syscall
failed
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
(
int
)
pIfTable
-
>
dwNumEntries
;
i
+
+
)
{
pIfRow
=
(
MIB_IFROW
*
)
&
pIfTable
-
>
table
[
i
]
;
ifname_found
=
0
;
pCurrAddresses
=
pAddresses
;
while
(
pCurrAddresses
)
{
sprintf_s
(
descr
MAX_PATH
"
%
wS
"
pCurrAddresses
-
>
Description
)
;
if
(
lstrcmp
(
descr
pIfRow
-
>
bDescr
)
=
=
0
)
{
py_nic_name
=
PyUnicode_FromWideChar
(
pCurrAddresses
-
>
FriendlyName
wcslen
(
pCurrAddresses
-
>
FriendlyName
)
)
;
if
(
py_nic_name
=
=
NULL
)
goto
error
;
ifname_found
=
1
;
break
;
}
pCurrAddresses
=
pCurrAddresses
-
>
Next
;
}
if
(
ifname_found
=
=
0
)
{
continue
;
}
if
(
(
pIfRow
-
>
dwOperStatus
=
=
MIB_IF_OPER_STATUS_CONNECTED
|
|
pIfRow
-
>
dwOperStatus
=
=
MIB_IF_OPER_STATUS_OPERATIONAL
)
&
&
pIfRow
-
>
dwAdminStatus
=
=
1
)
{
py_is_up
=
Py_True
;
}
else
{
py_is_up
=
Py_False
;
}
Py_INCREF
(
py_is_up
)
;
py_ifc_info
=
Py_BuildValue
(
"
(
Oikk
)
"
py_is_up
2
pIfRow
-
>
dwSpeed
/
1000000
pIfRow
-
>
dwMtu
)
;
if
(
!
py_ifc_info
)
goto
error
;
if
(
PyDict_SetItem
(
py_retdict
py_nic_name
py_ifc_info
)
)
goto
error
;
Py_DECREF
(
py_nic_name
)
;
Py_DECREF
(
py_ifc_info
)
;
}
free
(
pIfTable
)
;
free
(
pAddresses
)
;
return
py_retdict
;
error
:
Py_XDECREF
(
py_is_up
)
;
Py_XDECREF
(
py_ifc_info
)
;
Py_XDECREF
(
py_nic_name
)
;
Py_DECREF
(
py_retdict
)
;
if
(
pIfTable
!
=
NULL
)
free
(
pIfTable
)
;
if
(
pAddresses
!
=
NULL
)
free
(
pAddresses
)
;
return
NULL
;
}
static
PyObject
*
psutil_cpu_stats
(
PyObject
*
self
PyObject
*
args
)
{
typedef
DWORD
(
_stdcall
*
NTQSI_PROC
)
(
int
PVOID
ULONG
PULONG
)
;
NTQSI_PROC
NtQuerySystemInformation
;
HINSTANCE
hNtDll
;
NTSTATUS
status
;
_SYSTEM_PERFORMANCE_INFORMATION
*
spi
=
NULL
;
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
*
sppi
=
NULL
;
_SYSTEM_INTERRUPT_INFORMATION
*
InterruptInformation
=
NULL
;
SYSTEM_INFO
si
;
UINT
i
;
ULONG64
dpcs
=
0
;
ULONG
interrupts
=
0
;
hNtDll
=
LoadLibrary
(
TEXT
(
"
ntdll
.
dll
"
)
)
;
if
(
hNtDll
=
=
NULL
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
NtQuerySystemInformation
=
(
NTQSI_PROC
)
GetProcAddress
(
hNtDll
"
NtQuerySystemInformation
"
)
;
if
(
NtQuerySystemInformation
=
=
NULL
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
GetSystemInfo
(
&
si
)
;
spi
=
(
_SYSTEM_PERFORMANCE_INFORMATION
*
)
\
malloc
(
si
.
dwNumberOfProcessors
*
\
sizeof
(
_SYSTEM_PERFORMANCE_INFORMATION
)
)
;
if
(
spi
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
status
=
NtQuerySystemInformation
(
SystemPerformanceInformation
spi
si
.
dwNumberOfProcessors
*
sizeof
(
_SYSTEM_PERFORMANCE_INFORMATION
)
NULL
)
;
if
(
status
!
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
InterruptInformation
=
\
malloc
(
sizeof
(
_SYSTEM_INTERRUPT_INFORMATION
)
*
si
.
dwNumberOfProcessors
)
;
if
(
InterruptInformation
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
status
=
NtQuerySystemInformation
(
SystemInterruptInformation
InterruptInformation
si
.
dwNumberOfProcessors
*
sizeof
(
SYSTEM_INTERRUPT_INFORMATION
)
NULL
)
;
if
(
status
!
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
si
.
dwNumberOfProcessors
;
i
+
+
)
{
dpcs
+
=
InterruptInformation
[
i
]
.
DpcCount
;
}
sppi
=
(
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
*
)
\
malloc
(
si
.
dwNumberOfProcessors
*
\
sizeof
(
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
)
)
;
if
(
sppi
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
status
=
NtQuerySystemInformation
(
SystemProcessorPerformanceInformation
sppi
si
.
dwNumberOfProcessors
*
sizeof
(
_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
)
NULL
)
;
if
(
status
!
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
si
.
dwNumberOfProcessors
;
i
+
+
)
{
interrupts
+
=
sppi
[
i
]
.
InterruptCount
;
}
free
(
spi
)
;
free
(
InterruptInformation
)
;
free
(
sppi
)
;
FreeLibrary
(
hNtDll
)
;
return
Py_BuildValue
(
"
kkkk
"
spi
-
>
ContextSwitches
interrupts
(
unsigned
long
)
dpcs
spi
-
>
SystemCalls
)
;
error
:
if
(
spi
)
free
(
spi
)
;
if
(
InterruptInformation
)
free
(
InterruptInformation
)
;
if
(
sppi
)
free
(
sppi
)
;
if
(
hNtDll
)
FreeLibrary
(
hNtDll
)
;
return
NULL
;
}
static
PyObject
*
psutil_cpu_freq
(
PyObject
*
self
PyObject
*
args
)
{
PROCESSOR_POWER_INFORMATION
*
ppi
;
NTSTATUS
ret
;
size_t
size
;
LPBYTE
pBuffer
=
NULL
;
ULONG
current
;
ULONG
max
;
unsigned
int
num_cpus
;
SYSTEM_INFO
system_info
;
system_info
.
dwNumberOfProcessors
=
0
;
GetSystemInfo
(
&
system_info
)
;
if
(
system_info
.
dwNumberOfProcessors
=
=
0
)
num_cpus
=
1
;
else
num_cpus
=
system_info
.
dwNumberOfProcessors
;
size
=
num_cpus
*
sizeof
(
PROCESSOR_POWER_INFORMATION
)
;
pBuffer
=
(
BYTE
*
)
LocalAlloc
(
LPTR
size
)
;
if
(
!
pBuffer
)
return
PyErr_SetFromWindowsErr
(
0
)
;
ret
=
CallNtPowerInformation
(
ProcessorInformation
NULL
0
pBuffer
size
)
;
if
(
ret
!
=
0
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
CallNtPowerInformation
syscall
failed
"
)
;
goto
error
;
}
ppi
=
(
PROCESSOR_POWER_INFORMATION
*
)
pBuffer
;
max
=
ppi
-
>
MaxMhz
;
current
=
ppi
-
>
CurrentMhz
;
LocalFree
(
pBuffer
)
;
return
Py_BuildValue
(
"
kk
"
current
max
)
;
error
:
if
(
pBuffer
!
=
NULL
)
LocalFree
(
pBuffer
)
;
return
NULL
;
}
static
PyObject
*
psutil_sensors_battery
(
PyObject
*
self
PyObject
*
args
)
{
SYSTEM_POWER_STATUS
sps
;
if
(
GetSystemPowerStatus
(
&
sps
)
=
=
0
)
return
PyErr_SetFromWindowsErr
(
0
)
;
return
Py_BuildValue
(
"
iiiI
"
sps
.
ACLineStatus
sps
.
BatteryFlag
sps
.
BatteryLifePercent
sps
.
BatteryLifeTime
)
;
}
static
PyMethodDef
PsutilMethods
[
]
=
{
{
"
proc_cmdline
"
psutil_proc_cmdline
METH_VARARGS
"
Return
process
cmdline
as
a
list
of
cmdline
arguments
"
}
{
"
proc_environ
"
psutil_proc_environ
METH_VARARGS
"
Return
process
environment
data
"
}
{
"
proc_exe
"
psutil_proc_exe
METH_VARARGS
"
Return
path
of
the
process
executable
"
}
{
"
proc_name
"
psutil_proc_name
METH_VARARGS
"
Return
process
name
"
}
{
"
proc_kill
"
psutil_proc_kill
METH_VARARGS
"
Kill
the
process
identified
by
the
given
PID
"
}
{
"
proc_cpu_times
"
psutil_proc_cpu_times
METH_VARARGS
"
Return
tuple
of
user
/
kern
time
for
the
given
PID
"
}
{
"
proc_create_time
"
psutil_proc_create_time
METH_VARARGS
"
Return
a
float
indicating
the
process
create
time
expressed
in
"
"
seconds
since
the
epoch
"
}
{
"
proc_memory_info
"
psutil_proc_memory_info
METH_VARARGS
"
Return
a
tuple
of
process
memory
information
"
}
{
"
proc_memory_uss
"
psutil_proc_memory_uss
METH_VARARGS
"
Return
the
USS
of
the
process
"
}
{
"
proc_cwd
"
psutil_proc_cwd
METH_VARARGS
"
Return
process
current
working
directory
"
}
{
"
proc_suspend
"
psutil_proc_suspend
METH_VARARGS
"
Suspend
a
process
"
}
{
"
proc_resume
"
psutil_proc_resume
METH_VARARGS
"
Resume
a
process
"
}
{
"
proc_open_files
"
psutil_proc_open_files
METH_VARARGS
"
Return
files
opened
by
process
"
}
{
"
proc_username
"
psutil_proc_username
METH_VARARGS
"
Return
the
username
of
a
process
"
}
{
"
proc_threads
"
psutil_proc_threads
METH_VARARGS
"
Return
process
threads
information
as
a
list
of
tuple
"
}
{
"
proc_wait
"
psutil_proc_wait
METH_VARARGS
"
Wait
for
process
to
terminate
and
return
its
exit
code
.
"
}
{
"
proc_priority_get
"
psutil_proc_priority_get
METH_VARARGS
"
Return
process
priority
.
"
}
{
"
proc_priority_set
"
psutil_proc_priority_set
METH_VARARGS
"
Set
process
priority
.
"
}
#
if
(
_WIN32_WINNT
>
=
0x0600
)
{
"
proc_io_priority_get
"
psutil_proc_io_priority_get
METH_VARARGS
"
Return
process
IO
priority
.
"
}
{
"
proc_io_priority_set
"
psutil_proc_io_priority_set
METH_VARARGS
"
Set
process
IO
priority
.
"
}
#
endif
{
"
proc_cpu_affinity_get
"
psutil_proc_cpu_affinity_get
METH_VARARGS
"
Return
process
CPU
affinity
as
a
bitmask
.
"
}
{
"
proc_cpu_affinity_set
"
psutil_proc_cpu_affinity_set
METH_VARARGS
"
Set
process
CPU
affinity
.
"
}
{
"
proc_io_counters
"
psutil_proc_io_counters
METH_VARARGS
"
Get
process
I
/
O
counters
.
"
}
{
"
proc_is_suspended
"
psutil_proc_is_suspended
METH_VARARGS
"
Return
True
if
one
of
the
process
threads
is
in
a
suspended
state
"
}
{
"
proc_num_handles
"
psutil_proc_num_handles
METH_VARARGS
"
Return
the
number
of
handles
opened
by
process
.
"
}
{
"
proc_memory_maps
"
psutil_proc_memory_maps
METH_VARARGS
"
Return
a
list
of
process
'
s
memory
mappings
"
}
{
"
proc_info
"
psutil_proc_info
METH_VARARGS
"
Various
process
information
"
}
{
"
pids
"
psutil_pids
METH_VARARGS
"
Returns
a
list
of
PIDs
currently
running
on
the
system
"
}
{
"
ppid_map
"
psutil_ppid_map
METH_VARARGS
"
Return
a
{
pid
:
ppid
.
.
.
}
dict
for
all
running
processes
"
}
{
"
pid_exists
"
psutil_pid_exists
METH_VARARGS
"
Determine
if
the
process
exists
in
the
current
process
list
.
"
}
{
"
cpu_count_logical
"
psutil_cpu_count_logical
METH_VARARGS
"
Returns
the
number
of
logical
CPUs
on
the
system
"
}
{
"
cpu_count_phys
"
psutil_cpu_count_phys
METH_VARARGS
"
Returns
the
number
of
physical
CPUs
on
the
system
"
}
{
"
boot_time
"
psutil_boot_time
METH_VARARGS
"
Return
the
system
boot
time
expressed
in
seconds
since
the
epoch
.
"
}
{
"
virtual_mem
"
psutil_virtual_mem
METH_VARARGS
"
Return
the
total
amount
of
physical
memory
in
bytes
"
}
{
"
cpu_times
"
psutil_cpu_times
METH_VARARGS
"
Return
system
cpu
times
as
a
list
"
}
{
"
per_cpu_times
"
psutil_per_cpu_times
METH_VARARGS
"
Return
system
per
-
cpu
times
as
a
list
of
tuples
"
}
{
"
disk_usage
"
psutil_disk_usage
METH_VARARGS
"
Return
path
'
s
disk
total
and
free
as
a
Python
tuple
.
"
}
{
"
net_io_counters
"
psutil_net_io_counters
METH_VARARGS
"
Return
dict
of
tuples
of
networks
I
/
O
information
.
"
}
{
"
disk_io_counters
"
psutil_disk_io_counters
METH_VARARGS
"
Return
dict
of
tuples
of
disks
I
/
O
information
.
"
}
{
"
users
"
psutil_users
METH_VARARGS
"
Return
a
list
of
currently
connected
users
.
"
}
{
"
disk_partitions
"
psutil_disk_partitions
METH_VARARGS
"
Return
disk
partitions
.
"
}
{
"
net_connections
"
psutil_net_connections
METH_VARARGS
"
Return
system
-
wide
connections
"
}
{
"
net_if_addrs
"
psutil_net_if_addrs
METH_VARARGS
"
Return
NICs
addresses
.
"
}
{
"
net_if_stats
"
psutil_net_if_stats
METH_VARARGS
"
Return
NICs
stats
.
"
}
{
"
cpu_stats
"
psutil_cpu_stats
METH_VARARGS
"
Return
NICs
stats
.
"
}
{
"
cpu_freq
"
psutil_cpu_freq
METH_VARARGS
"
Return
CPU
frequency
.
"
}
{
"
sensors_battery
"
psutil_sensors_battery
METH_VARARGS
"
Return
battery
metrics
usage
.
"
}
{
"
winservice_enumerate
"
psutil_winservice_enumerate
METH_VARARGS
"
List
all
services
"
}
{
"
winservice_query_config
"
psutil_winservice_query_config
METH_VARARGS
"
Return
service
config
"
}
{
"
winservice_query_status
"
psutil_winservice_query_status
METH_VARARGS
"
Return
service
config
"
}
{
"
winservice_query_descr
"
psutil_winservice_query_descr
METH_VARARGS
"
Return
the
description
of
a
service
"
}
{
"
winservice_start
"
psutil_winservice_start
METH_VARARGS
"
Start
a
service
"
}
{
"
winservice_stop
"
psutil_winservice_stop
METH_VARARGS
"
Stop
a
service
"
}
{
"
win32_QueryDosDevice
"
psutil_win32_QueryDosDevice
METH_VARARGS
"
QueryDosDevice
binding
"
}
{
"
set_testing
"
psutil_set_testing
METH_NOARGS
"
Set
psutil
in
testing
mode
"
}
{
NULL
NULL
0
NULL
}
}
;
struct
module_state
{
PyObject
*
error
;
}
;
#
if
PY_MAJOR_VERSION
>
=
3
#
define
GETSTATE
(
m
)
(
(
struct
module_state
*
)
PyModule_GetState
(
m
)
)
#
else
#
define
GETSTATE
(
m
)
(
&
_state
)
static
struct
module_state
_state
;
#
endif
#
if
PY_MAJOR_VERSION
>
=
3
static
int
psutil_windows_traverse
(
PyObject
*
m
visitproc
visit
void
*
arg
)
{
Py_VISIT
(
GETSTATE
(
m
)
-
>
error
)
;
return
0
;
}
static
int
psutil_windows_clear
(
PyObject
*
m
)
{
Py_CLEAR
(
GETSTATE
(
m
)
-
>
error
)
;
return
0
;
}
static
struct
PyModuleDef
moduledef
=
{
PyModuleDef_HEAD_INIT
"
psutil_windows
"
NULL
sizeof
(
struct
module_state
)
PsutilMethods
NULL
psutil_windows_traverse
psutil_windows_clear
NULL
}
;
#
define
INITERROR
return
NULL
PyMODINIT_FUNC
PyInit__psutil_windows
(
void
)
#
else
#
define
INITERROR
return
void
init_psutil_windows
(
void
)
#
endif
{
struct
module_state
*
st
=
NULL
;
#
if
PY_MAJOR_VERSION
>
=
3
PyObject
*
module
=
PyModule_Create
(
&
moduledef
)
;
#
else
PyObject
*
module
=
Py_InitModule
(
"
_psutil_windows
"
PsutilMethods
)
;
#
endif
if
(
module
=
=
NULL
)
{
INITERROR
;
}
st
=
GETSTATE
(
module
)
;
st
-
>
error
=
PyErr_NewException
(
"
_psutil_windows
.
Error
"
NULL
NULL
)
;
if
(
st
-
>
error
=
=
NULL
)
{
Py_DECREF
(
module
)
;
INITERROR
;
}
PyModule_AddIntConstant
(
module
"
version
"
PSUTIL_VERSION
)
;
PyModule_AddIntConstant
(
module
"
ABOVE_NORMAL_PRIORITY_CLASS
"
ABOVE_NORMAL_PRIORITY_CLASS
)
;
PyModule_AddIntConstant
(
module
"
BELOW_NORMAL_PRIORITY_CLASS
"
BELOW_NORMAL_PRIORITY_CLASS
)
;
PyModule_AddIntConstant
(
module
"
HIGH_PRIORITY_CLASS
"
HIGH_PRIORITY_CLASS
)
;
PyModule_AddIntConstant
(
module
"
IDLE_PRIORITY_CLASS
"
IDLE_PRIORITY_CLASS
)
;
PyModule_AddIntConstant
(
module
"
NORMAL_PRIORITY_CLASS
"
NORMAL_PRIORITY_CLASS
)
;
PyModule_AddIntConstant
(
module
"
REALTIME_PRIORITY_CLASS
"
REALTIME_PRIORITY_CLASS
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_CLOSED
"
MIB_TCP_STATE_CLOSED
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_CLOSING
"
MIB_TCP_STATE_CLOSING
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_CLOSE_WAIT
"
MIB_TCP_STATE_CLOSE_WAIT
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_LISTEN
"
MIB_TCP_STATE_LISTEN
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_ESTAB
"
MIB_TCP_STATE_ESTAB
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_SYN_SENT
"
MIB_TCP_STATE_SYN_SENT
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_SYN_RCVD
"
MIB_TCP_STATE_SYN_RCVD
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_FIN_WAIT1
"
MIB_TCP_STATE_FIN_WAIT1
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_FIN_WAIT2
"
MIB_TCP_STATE_FIN_WAIT2
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_LAST_ACK
"
MIB_TCP_STATE_LAST_ACK
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_TIME_WAIT
"
MIB_TCP_STATE_TIME_WAIT
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_TIME_WAIT
"
MIB_TCP_STATE_TIME_WAIT
)
;
PyModule_AddIntConstant
(
module
"
MIB_TCP_STATE_DELETE_TCB
"
MIB_TCP_STATE_DELETE_TCB
)
;
PyModule_AddIntConstant
(
module
"
PSUTIL_CONN_NONE
"
PSUTIL_CONN_NONE
)
;
PyModule_AddIntConstant
(
module
"
INFINITE
"
INFINITE
)
;
PyModule_AddIntConstant
(
module
"
ERROR_ACCESS_DENIED
"
ERROR_ACCESS_DENIED
)
;
PyModule_AddIntConstant
(
module
"
ERROR_INVALID_NAME
"
ERROR_INVALID_NAME
)
;
PyModule_AddIntConstant
(
module
"
ERROR_SERVICE_DOES_NOT_EXIST
"
ERROR_SERVICE_DOES_NOT_EXIST
)
;
psutil_set_se_debug
(
)
;
psutil_setup
(
)
;
#
if
PY_MAJOR_VERSION
>
=
3
return
module
;
#
endif
}
