#
include
<
Python
.
h
>
#
include
<
windows
.
h
>
#
include
<
Psapi
.
h
>
#
include
<
tlhelp32
.
h
>
#
include
"
security
.
h
"
#
include
"
process_info
.
h
"
#
include
"
ntextapi
.
h
"
#
include
"
.
.
/
.
.
/
_psutil_common
.
h
"
#
ifndef
NT_SUCCESS
#
define
NT_SUCCESS
(
Status
)
(
(
NTSTATUS
)
(
Status
)
>
=
0
)
#
endif
typedef
struct
{
BYTE
Reserved1
[
16
]
;
PVOID
Reserved2
[
5
]
;
UNICODE_STRING
CurrentDirectoryPath
;
PVOID
CurrentDirectoryHandle
;
UNICODE_STRING
DllPath
;
UNICODE_STRING
ImagePathName
;
UNICODE_STRING
CommandLine
;
LPCWSTR
env
;
}
RTL_USER_PROCESS_PARAMETERS_
*
PRTL_USER_PROCESS_PARAMETERS_
;
#
ifdef
_WIN64
typedef
struct
{
BYTE
Reserved1
[
2
]
;
BYTE
BeingDebugged
;
BYTE
Reserved2
[
21
]
;
PVOID
LoaderData
;
PRTL_USER_PROCESS_PARAMETERS_
ProcessParameters
;
}
PEB_
;
#
else
typedef
struct
{
BYTE
Reserved1
[
2
]
;
BYTE
BeingDebugged
;
BYTE
Reserved2
[
1
]
;
PVOID
Reserved3
[
2
]
;
PVOID
Ldr
;
PRTL_USER_PROCESS_PARAMETERS_
ProcessParameters
;
}
PEB_
;
#
endif
#
ifdef
_WIN64
typedef
struct
{
USHORT
Length
;
USHORT
MaxLength
;
DWORD
Buffer
;
}
UNICODE_STRING32
;
typedef
struct
{
BYTE
Reserved1
[
16
]
;
DWORD
Reserved2
[
5
]
;
UNICODE_STRING32
CurrentDirectoryPath
;
DWORD
CurrentDirectoryHandle
;
UNICODE_STRING32
DllPath
;
UNICODE_STRING32
ImagePathName
;
UNICODE_STRING32
CommandLine
;
DWORD
env
;
}
RTL_USER_PROCESS_PARAMETERS32
;
typedef
struct
{
BYTE
Reserved1
[
2
]
;
BYTE
BeingDebugged
;
BYTE
Reserved2
[
1
]
;
DWORD
Reserved3
[
2
]
;
DWORD
Ldr
;
DWORD
ProcessParameters
;
}
PEB32
;
#
else
typedef
NTSTATUS
(
NTAPI
*
_NtWow64ReadVirtualMemory64
)
(
IN
HANDLE
ProcessHandle
IN
PVOID64
BaseAddress
OUT
PVOID
Buffer
IN
ULONG64
Size
OUT
PULONG64
NumberOfBytesRead
)
;
typedef
enum
{
MemoryInformationBasic
}
MEMORY_INFORMATION_CLASS
;
typedef
NTSTATUS
(
NTAPI
*
_NtWow64QueryVirtualMemory64
)
(
IN
HANDLE
ProcessHandle
IN
PVOID64
BaseAddress
IN
MEMORY_INFORMATION_CLASS
MemoryInformationClass
OUT
PMEMORY_BASIC_INFORMATION64
MemoryInformation
IN
ULONG64
Size
OUT
PULONG64
ReturnLength
OPTIONAL
)
;
typedef
struct
{
PVOID
Reserved1
[
2
]
;
PVOID64
PebBaseAddress
;
PVOID
Reserved2
[
4
]
;
PVOID
UniqueProcessId
[
2
]
;
PVOID
Reserved3
[
2
]
;
}
PROCESS_BASIC_INFORMATION64
;
typedef
struct
{
USHORT
Length
;
USHORT
MaxLength
;
PVOID64
Buffer
;
}
UNICODE_STRING64
;
typedef
struct
{
BYTE
Reserved1
[
16
]
;
PVOID64
Reserved2
[
5
]
;
UNICODE_STRING64
CurrentDirectoryPath
;
PVOID64
CurrentDirectoryHandle
;
UNICODE_STRING64
DllPath
;
UNICODE_STRING64
ImagePathName
;
UNICODE_STRING64
CommandLine
;
PVOID64
env
;
}
RTL_USER_PROCESS_PARAMETERS64
;
typedef
struct
{
BYTE
Reserved1
[
2
]
;
BYTE
BeingDebugged
;
BYTE
Reserved2
[
21
]
;
PVOID64
LoaderData
;
PVOID64
ProcessParameters
;
}
PEB64
;
#
endif
#
define
PSUTIL_FIRST_PROCESS
(
Processes
)
(
\
(
PSYSTEM_PROCESS_INFORMATION
)
(
Processes
)
)
#
define
PSUTIL_NEXT_PROCESS
(
Process
)
(
\
(
(
PSYSTEM_PROCESS_INFORMATION
)
(
Process
)
)
-
>
NextEntryOffset
?
\
(
PSYSTEM_PROCESS_INFORMATION
)
(
(
PCHAR
)
(
Process
)
+
\
(
(
PSYSTEM_PROCESS_INFORMATION
)
(
Process
)
)
-
>
NextEntryOffset
)
:
NULL
)
const
int
STATUS_INFO_LENGTH_MISMATCH
=
0xC0000004
;
const
int
STATUS_BUFFER_TOO_SMALL
=
0xC0000023L
;
int
psutil_pid_in_pids
(
DWORD
pid
)
{
DWORD
*
proclist
=
NULL
;
DWORD
numberOfReturnedPIDs
;
DWORD
i
;
proclist
=
psutil_get_pids
(
&
numberOfReturnedPIDs
)
;
if
(
proclist
=
=
NULL
)
return
-
1
;
for
(
i
=
0
;
i
<
numberOfReturnedPIDs
;
i
+
+
)
{
if
(
proclist
[
i
]
=
=
pid
)
{
free
(
proclist
)
;
return
1
;
}
}
free
(
proclist
)
;
return
0
;
}
int
psutil_is_phandle_running
(
HANDLE
hProcess
DWORD
pid
)
{
DWORD
processExitCode
=
0
;
if
(
hProcess
=
=
NULL
)
{
if
(
GetLastError
(
)
=
=
ERROR_INVALID_PARAMETER
)
{
if
(
!
psutil_assert_pid_not_exists
(
pid
"
iphr
:
OpenProcess
(
)
-
>
ERROR_INVALID_PARAMETER
"
)
)
{
return
-
2
;
}
return
0
;
}
return
-
1
;
}
if
(
GetExitCodeProcess
(
hProcess
&
processExitCode
)
)
{
if
(
processExitCode
=
=
STILL_ACTIVE
)
{
if
(
!
psutil_assert_pid_exists
(
pid
"
iphr
:
GetExitCodeProcess
(
)
-
>
STILL_ACTIVE
"
)
)
{
return
-
2
;
}
return
1
;
}
else
{
if
(
psutil_pid_in_pids
(
pid
)
=
=
1
)
{
return
1
;
}
else
{
CloseHandle
(
hProcess
)
;
return
0
;
}
}
}
CloseHandle
(
hProcess
)
;
if
(
!
psutil_assert_pid_not_exists
(
pid
"
iphr
:
exit
fun
"
)
)
{
return
-
2
;
}
return
-
1
;
}
HANDLE
psutil_check_phandle
(
HANDLE
hProcess
DWORD
pid
)
{
int
ret
=
psutil_is_phandle_running
(
hProcess
pid
)
;
if
(
ret
=
=
1
)
return
hProcess
;
else
if
(
ret
=
=
0
)
return
NoSuchProcess
(
"
"
)
;
else
if
(
ret
=
=
-
1
)
return
PyErr_SetFromWindowsErr
(
0
)
;
else
return
NULL
;
}
HANDLE
psutil_handle_from_pid_waccess
(
DWORD
pid
DWORD
dwDesiredAccess
)
{
HANDLE
hProcess
;
if
(
pid
=
=
0
)
{
return
AccessDenied
(
"
"
)
;
}
hProcess
=
OpenProcess
(
dwDesiredAccess
FALSE
pid
)
;
return
psutil_check_phandle
(
hProcess
pid
)
;
}
HANDLE
psutil_handle_from_pid
(
DWORD
pid
)
{
DWORD
dwDesiredAccess
=
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
;
return
psutil_handle_from_pid_waccess
(
pid
dwDesiredAccess
)
;
}
DWORD
*
psutil_get_pids
(
DWORD
*
numberOfReturnedPIDs
)
{
DWORD
*
procArray
=
NULL
;
DWORD
procArrayByteSz
;
int
procArraySz
=
0
;
DWORD
enumReturnSz
=
0
;
do
{
procArraySz
+
=
1024
;
free
(
procArray
)
;
procArrayByteSz
=
procArraySz
*
sizeof
(
DWORD
)
;
procArray
=
malloc
(
procArrayByteSz
)
;
if
(
procArray
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
if
(
!
EnumProcesses
(
procArray
procArrayByteSz
&
enumReturnSz
)
)
{
free
(
procArray
)
;
PyErr_SetFromWindowsErr
(
0
)
;
return
NULL
;
}
}
while
(
enumReturnSz
=
=
procArraySz
*
sizeof
(
DWORD
)
)
;
*
numberOfReturnedPIDs
=
enumReturnSz
/
sizeof
(
DWORD
)
;
return
procArray
;
}
int
psutil_assert_pid_exists
(
DWORD
pid
char
*
err
)
{
if
(
PSUTIL_TESTING
)
{
if
(
psutil_pid_in_pids
(
pid
)
=
=
0
)
{
PyErr_SetString
(
PyExc_AssertionError
err
)
;
return
0
;
}
}
return
1
;
}
int
psutil_assert_pid_not_exists
(
DWORD
pid
char
*
err
)
{
if
(
PSUTIL_TESTING
)
{
if
(
psutil_pid_in_pids
(
pid
)
=
=
1
)
{
PyErr_SetString
(
PyExc_AssertionError
err
)
;
return
0
;
}
}
return
1
;
}
int
psutil_pid_is_running
(
DWORD
pid
)
{
HANDLE
hProcess
;
DWORD
exitCode
;
DWORD
err
;
if
(
pid
=
=
0
)
return
1
;
if
(
pid
<
0
)
return
0
;
hProcess
=
OpenProcess
(
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
FALSE
pid
)
;
if
(
NULL
=
=
hProcess
)
{
err
=
GetLastError
(
)
;
if
(
err
=
=
ERROR_INVALID_PARAMETER
)
{
if
(
!
psutil_assert_pid_not_exists
(
pid
"
pir
:
OpenProcess
(
)
-
>
INVALID_PARAMETER
"
)
)
{
return
-
1
;
}
return
0
;
}
else
if
(
err
=
=
ERROR_ACCESS_DENIED
)
{
if
(
!
psutil_assert_pid_exists
(
pid
"
pir
:
OpenProcess
(
)
ACCESS_DENIED
"
)
)
{
return
-
1
;
}
return
1
;
}
else
{
PyErr_SetFromWindowsErr
(
err
)
;
return
-
1
;
}
}
if
(
GetExitCodeProcess
(
hProcess
&
exitCode
)
)
{
CloseHandle
(
hProcess
)
;
if
(
exitCode
=
=
STILL_ACTIVE
)
{
if
(
!
psutil_assert_pid_exists
(
pid
"
pir
:
GetExitCodeProcess
(
)
-
>
STILL_ACTIVE
"
)
)
{
return
-
1
;
}
return
1
;
}
else
{
return
psutil_pid_in_pids
(
pid
)
;
}
}
else
{
err
=
GetLastError
(
)
;
CloseHandle
(
hProcess
)
;
if
(
err
=
=
ERROR_ACCESS_DENIED
)
{
if
(
!
psutil_assert_pid_exists
(
pid
"
pir
:
GetExitCodeProcess
(
)
-
>
ERROR_ACCESS_DENIED
"
)
)
{
return
-
1
;
}
return
1
;
}
else
{
PyErr_SetFromWindowsErr
(
0
)
;
return
-
1
;
}
}
}
static
int
psutil_get_process_region_size
(
HANDLE
hProcess
LPCVOID
src
SIZE_T
*
psize
)
{
MEMORY_BASIC_INFORMATION
info
;
if
(
!
VirtualQueryEx
(
hProcess
src
&
info
sizeof
(
info
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
return
-
1
;
}
*
psize
=
info
.
RegionSize
-
(
(
char
*
)
src
-
(
char
*
)
info
.
BaseAddress
)
;
return
0
;
}
#
ifndef
_WIN64
static
int
psutil_get_process_region_size64
(
HANDLE
hProcess
const
PVOID64
src64
PULONG64
psize
)
{
static
_NtWow64QueryVirtualMemory64
NtWow64QueryVirtualMemory64
=
NULL
;
MEMORY_BASIC_INFORMATION64
info64
;
if
(
NtWow64QueryVirtualMemory64
=
=
NULL
)
{
NtWow64QueryVirtualMemory64
=
(
_NtWow64QueryVirtualMemory64
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
.
dll
"
)
"
NtWow64QueryVirtualMemory64
"
)
;
if
(
NtWow64QueryVirtualMemory64
=
=
NULL
)
{
PyErr_SetString
(
PyExc_NotImplementedError
"
NtWow64QueryVirtualMemory64
missing
"
)
;
return
-
1
;
}
}
if
(
!
NT_SUCCESS
(
NtWow64QueryVirtualMemory64
(
hProcess
src64
0
&
info64
sizeof
(
info64
)
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
return
-
1
;
}
*
psize
=
info64
.
RegionSize
-
(
(
char
*
)
src64
-
(
char
*
)
info64
.
BaseAddress
)
;
return
0
;
}
#
endif
enum
psutil_process_data_kind
{
KIND_CMDLINE
KIND_CWD
KIND_ENVIRON
}
;
static
int
psutil_get_process_data
(
long
pid
enum
psutil_process_data_kind
kind
WCHAR
*
*
pdata
SIZE_T
*
psize
)
{
static
_NtQueryInformationProcess
NtQueryInformationProcess
=
NULL
;
#
ifndef
_WIN64
static
_NtQueryInformationProcess
NtWow64QueryInformationProcess64
=
NULL
;
static
_NtWow64ReadVirtualMemory64
NtWow64ReadVirtualMemory64
=
NULL
;
#
endif
HANDLE
hProcess
=
NULL
;
LPCVOID
src
;
SIZE_T
size
;
WCHAR
*
buffer
=
NULL
;
#
ifdef
_WIN64
LPVOID
ppeb32
=
NULL
;
#
else
PVOID64
src64
;
BOOL
weAreWow64
;
BOOL
theyAreWow64
;
#
endif
hProcess
=
psutil_handle_from_pid
(
pid
)
;
if
(
hProcess
=
=
NULL
)
return
-
1
;
if
(
NtQueryInformationProcess
=
=
NULL
)
{
NtQueryInformationProcess
=
(
_NtQueryInformationProcess
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
.
dll
"
)
"
NtQueryInformationProcess
"
)
;
}
#
ifdef
_WIN64
if
(
!
NT_SUCCESS
(
NtQueryInformationProcess
(
hProcess
ProcessWow64Information
&
ppeb32
sizeof
(
LPVOID
)
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
ppeb32
!
=
NULL
)
{
PEB32
peb32
;
RTL_USER_PROCESS_PARAMETERS32
procParameters32
;
if
(
!
ReadProcessMemory
(
hProcess
ppeb32
&
peb32
sizeof
(
peb32
)
NULL
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
!
ReadProcessMemory
(
hProcess
UlongToPtr
(
peb32
.
ProcessParameters
)
&
procParameters32
sizeof
(
procParameters32
)
NULL
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
switch
(
kind
)
{
case
KIND_CMDLINE
:
src
=
UlongToPtr
(
procParameters32
.
CommandLine
.
Buffer
)
size
=
procParameters32
.
CommandLine
.
Length
;
break
;
case
KIND_CWD
:
src
=
UlongToPtr
(
procParameters32
.
CurrentDirectoryPath
.
Buffer
)
;
size
=
procParameters32
.
CurrentDirectoryPath
.
Length
;
break
;
case
KIND_ENVIRON
:
src
=
UlongToPtr
(
procParameters32
.
env
)
;
break
;
}
}
else
#
else
if
(
!
IsWow64Process
(
GetCurrentProcess
(
)
&
weAreWow64
)
|
|
!
IsWow64Process
(
hProcess
&
theyAreWow64
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
weAreWow64
&
&
!
theyAreWow64
)
{
PROCESS_BASIC_INFORMATION64
pbi64
;
PEB64
peb64
;
RTL_USER_PROCESS_PARAMETERS64
procParameters64
;
if
(
NtWow64QueryInformationProcess64
=
=
NULL
)
{
NtWow64QueryInformationProcess64
=
(
_NtQueryInformationProcess
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
.
dll
"
)
"
NtWow64QueryInformationProcess64
"
)
;
if
(
NtWow64QueryInformationProcess64
=
=
NULL
)
{
PyErr_SetString
(
PyExc_NotImplementedError
"
NtWow64QueryInformationProcess64
missing
"
)
;
goto
error
;
}
}
if
(
!
NT_SUCCESS
(
NtWow64QueryInformationProcess64
(
hProcess
ProcessBasicInformation
&
pbi64
sizeof
(
pbi64
)
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
NtWow64ReadVirtualMemory64
=
=
NULL
)
{
NtWow64ReadVirtualMemory64
=
(
_NtWow64ReadVirtualMemory64
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
.
dll
"
)
"
NtWow64ReadVirtualMemory64
"
)
;
if
(
NtWow64ReadVirtualMemory64
=
=
NULL
)
{
PyErr_SetString
(
PyExc_NotImplementedError
"
NtWow64ReadVirtualMemory64
missing
"
)
;
goto
error
;
}
}
if
(
!
NT_SUCCESS
(
NtWow64ReadVirtualMemory64
(
hProcess
pbi64
.
PebBaseAddress
&
peb64
sizeof
(
peb64
)
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
!
NT_SUCCESS
(
NtWow64ReadVirtualMemory64
(
hProcess
peb64
.
ProcessParameters
&
procParameters64
sizeof
(
procParameters64
)
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
switch
(
kind
)
{
case
KIND_CMDLINE
:
src64
=
procParameters64
.
CommandLine
.
Buffer
;
size
=
procParameters64
.
CommandLine
.
Length
;
break
;
case
KIND_CWD
:
src64
=
procParameters64
.
CurrentDirectoryPath
.
Buffer
size
=
procParameters64
.
CurrentDirectoryPath
.
Length
;
break
;
case
KIND_ENVIRON
:
src64
=
procParameters64
.
env
;
break
;
}
}
else
#
endif
{
PROCESS_BASIC_INFORMATION
pbi
;
PEB_
peb
;
RTL_USER_PROCESS_PARAMETERS_
procParameters
;
if
(
!
NT_SUCCESS
(
NtQueryInformationProcess
(
hProcess
ProcessBasicInformation
&
pbi
sizeof
(
pbi
)
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
!
ReadProcessMemory
(
hProcess
pbi
.
PebBaseAddress
&
peb
sizeof
(
peb
)
NULL
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
if
(
!
ReadProcessMemory
(
hProcess
peb
.
ProcessParameters
&
procParameters
sizeof
(
procParameters
)
NULL
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
switch
(
kind
)
{
case
KIND_CMDLINE
:
src
=
procParameters
.
CommandLine
.
Buffer
;
size
=
procParameters
.
CommandLine
.
Length
;
break
;
case
KIND_CWD
:
src
=
procParameters
.
CurrentDirectoryPath
.
Buffer
;
size
=
procParameters
.
CurrentDirectoryPath
.
Length
;
break
;
case
KIND_ENVIRON
:
src
=
procParameters
.
env
;
break
;
}
}
if
(
kind
=
=
KIND_ENVIRON
)
{
#
ifndef
_WIN64
if
(
weAreWow64
&
&
!
theyAreWow64
)
{
ULONG64
size64
;
if
(
psutil_get_process_region_size64
(
hProcess
src64
&
size64
)
!
=
0
)
goto
error
;
size
=
(
SIZE_T
)
size64
;
}
else
#
endif
if
(
psutil_get_process_region_size
(
hProcess
src
&
size
)
!
=
0
)
goto
error
;
}
buffer
=
calloc
(
size
+
2
1
)
;
if
(
buffer
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
#
ifndef
_WIN64
if
(
weAreWow64
&
&
!
theyAreWow64
)
{
if
(
!
NT_SUCCESS
(
NtWow64ReadVirtualMemory64
(
hProcess
src64
buffer
size
NULL
)
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
}
else
#
endif
if
(
!
ReadProcessMemory
(
hProcess
src
buffer
size
NULL
)
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
CloseHandle
(
hProcess
)
;
*
pdata
=
buffer
;
*
psize
=
size
;
return
0
;
error
:
if
(
hProcess
!
=
NULL
)
CloseHandle
(
hProcess
)
;
if
(
buffer
!
=
NULL
)
free
(
buffer
)
;
return
-
1
;
}
PyObject
*
psutil_get_cmdline
(
long
pid
)
{
PyObject
*
ret
=
NULL
;
WCHAR
*
data
=
NULL
;
SIZE_T
size
;
PyObject
*
py_retlist
=
NULL
;
PyObject
*
py_unicode
=
NULL
;
LPWSTR
*
szArglist
=
NULL
;
int
nArgs
i
;
if
(
psutil_get_process_data
(
pid
KIND_CMDLINE
&
data
&
size
)
!
=
0
)
goto
out
;
szArglist
=
CommandLineToArgvW
(
data
&
nArgs
)
;
if
(
szArglist
=
=
NULL
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
out
;
}
py_retlist
=
PyList_New
(
nArgs
)
;
if
(
py_retlist
=
=
NULL
)
goto
out
;
for
(
i
=
0
;
i
<
nArgs
;
i
+
+
)
{
py_unicode
=
PyUnicode_FromWideChar
(
szArglist
[
i
]
wcslen
(
szArglist
[
i
]
)
)
;
if
(
py_unicode
=
=
NULL
)
goto
out
;
PyList_SET_ITEM
(
py_retlist
i
py_unicode
)
;
py_unicode
=
NULL
;
}
ret
=
py_retlist
;
py_retlist
=
NULL
;
out
:
LocalFree
(
szArglist
)
;
free
(
data
)
;
Py_XDECREF
(
py_unicode
)
;
Py_XDECREF
(
py_retlist
)
;
return
ret
;
}
PyObject
*
psutil_get_cwd
(
long
pid
)
{
PyObject
*
ret
=
NULL
;
WCHAR
*
data
=
NULL
;
SIZE_T
size
;
if
(
psutil_get_process_data
(
pid
KIND_CWD
&
data
&
size
)
!
=
0
)
goto
out
;
ret
=
PyUnicode_FromWideChar
(
data
wcslen
(
data
)
)
;
out
:
free
(
data
)
;
return
ret
;
}
PyObject
*
psutil_get_environ
(
long
pid
)
{
PyObject
*
ret
=
NULL
;
WCHAR
*
data
=
NULL
;
SIZE_T
size
;
if
(
psutil_get_process_data
(
pid
KIND_ENVIRON
&
data
&
size
)
!
=
0
)
goto
out
;
ret
=
PyUnicode_FromWideChar
(
data
size
/
2
)
;
out
:
free
(
data
)
;
return
ret
;
}
int
psutil_get_proc_info
(
DWORD
pid
PSYSTEM_PROCESS_INFORMATION
*
retProcess
PVOID
*
retBuffer
)
{
static
ULONG
initialBufferSize
=
0x4000
;
NTSTATUS
status
;
PVOID
buffer
;
ULONG
bufferSize
;
PSYSTEM_PROCESS_INFORMATION
process
;
typedef
DWORD
(
_stdcall
*
NTQSI_PROC
)
(
int
PVOID
ULONG
PULONG
)
;
NTQSI_PROC
NtQuerySystemInformation
;
HINSTANCE
hNtDll
;
hNtDll
=
LoadLibrary
(
TEXT
(
"
ntdll
.
dll
"
)
)
;
NtQuerySystemInformation
=
(
NTQSI_PROC
)
GetProcAddress
(
hNtDll
"
NtQuerySystemInformation
"
)
;
bufferSize
=
initialBufferSize
;
buffer
=
malloc
(
bufferSize
)
;
if
(
buffer
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
while
(
TRUE
)
{
status
=
NtQuerySystemInformation
(
SystemProcessInformation
buffer
bufferSize
&
bufferSize
)
;
if
(
status
=
=
STATUS_BUFFER_TOO_SMALL
|
|
status
=
=
STATUS_INFO_LENGTH_MISMATCH
)
{
free
(
buffer
)
;
buffer
=
malloc
(
bufferSize
)
;
if
(
buffer
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
}
else
{
break
;
}
}
if
(
status
!
=
0
)
{
PyErr_Format
(
PyExc_RuntimeError
"
NtQuerySystemInformation
(
)
syscall
failed
"
)
;
goto
error
;
}
if
(
bufferSize
<
=
0x20000
)
initialBufferSize
=
bufferSize
;
process
=
PSUTIL_FIRST_PROCESS
(
buffer
)
;
do
{
if
(
process
-
>
UniqueProcessId
=
=
(
HANDLE
)
pid
)
{
*
retProcess
=
process
;
*
retBuffer
=
buffer
;
return
1
;
}
}
while
(
(
process
=
PSUTIL_NEXT_PROCESS
(
process
)
)
)
;
NoSuchProcess
(
"
"
)
;
goto
error
;
error
:
FreeLibrary
(
hNtDll
)
;
if
(
buffer
!
=
NULL
)
free
(
buffer
)
;
return
0
;
}
