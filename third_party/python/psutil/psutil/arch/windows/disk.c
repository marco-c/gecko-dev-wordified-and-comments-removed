#
include
<
Python
.
h
>
#
include
<
windows
.
h
>
#
include
<
tchar
.
h
>
#
include
"
.
.
/
.
.
/
_psutil_common
.
h
"
#
ifndef
_ARRAYSIZE
#
define
_ARRAYSIZE
(
a
)
(
sizeof
(
a
)
/
sizeof
(
a
[
0
]
)
)
#
endif
static
char
*
psutil_get_drive_type
(
int
type
)
{
switch
(
type
)
{
case
DRIVE_FIXED
:
return
"
fixed
"
;
case
DRIVE_CDROM
:
return
"
cdrom
"
;
case
DRIVE_REMOVABLE
:
return
"
removable
"
;
case
DRIVE_UNKNOWN
:
return
"
unknown
"
;
case
DRIVE_NO_ROOT_DIR
:
return
"
unmounted
"
;
case
DRIVE_REMOTE
:
return
"
remote
"
;
case
DRIVE_RAMDISK
:
return
"
ramdisk
"
;
default
:
return
"
?
"
;
}
}
PyObject
*
psutil_disk_usage
(
PyObject
*
self
PyObject
*
args
)
{
BOOL
retval
;
ULARGE_INTEGER
_
total
free
;
char
*
path
;
if
(
PyArg_ParseTuple
(
args
"
u
"
&
path
)
)
{
Py_BEGIN_ALLOW_THREADS
retval
=
GetDiskFreeSpaceExW
(
(
LPCWSTR
)
path
&
_
&
total
&
free
)
;
Py_END_ALLOW_THREADS
goto
return_
;
}
#
if
PY_MAJOR_VERSION
<
=
2
PyErr_Clear
(
)
;
if
(
PyArg_ParseTuple
(
args
"
s
"
&
path
)
)
{
Py_BEGIN_ALLOW_THREADS
retval
=
GetDiskFreeSpaceEx
(
path
&
_
&
total
&
free
)
;
Py_END_ALLOW_THREADS
goto
return_
;
}
#
endif
return
NULL
;
return_
:
if
(
retval
=
=
0
)
return
PyErr_SetFromWindowsErrWithFilename
(
0
path
)
;
else
return
Py_BuildValue
(
"
(
LL
)
"
total
.
QuadPart
free
.
QuadPart
)
;
}
PyObject
*
psutil_disk_io_counters
(
PyObject
*
self
PyObject
*
args
)
{
DISK_PERFORMANCE
diskPerformance
;
DWORD
dwSize
;
HANDLE
hDevice
=
NULL
;
char
szDevice
[
MAX_PATH
]
;
char
szDeviceDisplay
[
MAX_PATH
]
;
int
devNum
;
int
i
;
DWORD
ioctrlSize
;
BOOL
ret
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
for
(
devNum
=
0
;
devNum
<
=
32
;
+
+
devNum
)
{
py_tuple
=
NULL
;
sprintf_s
(
szDevice
MAX_PATH
"
\
\
\
\
.
\
\
PhysicalDrive
%
d
"
devNum
)
;
hDevice
=
CreateFile
(
szDevice
0
FILE_SHARE_READ
|
FILE_SHARE_WRITE
NULL
OPEN_EXISTING
0
NULL
)
;
if
(
hDevice
=
=
INVALID_HANDLE_VALUE
)
continue
;
i
=
0
;
ioctrlSize
=
sizeof
(
diskPerformance
)
;
while
(
1
)
{
i
+
=
1
;
ret
=
DeviceIoControl
(
hDevice
IOCTL_DISK_PERFORMANCE
NULL
0
&
diskPerformance
ioctrlSize
&
dwSize
NULL
)
;
if
(
ret
!
=
0
)
break
;
if
(
GetLastError
(
)
=
=
ERROR_INSUFFICIENT_BUFFER
)
{
if
(
i
<
=
1024
)
{
ioctrlSize
*
=
2
;
continue
;
}
}
else
if
(
GetLastError
(
)
=
=
ERROR_INVALID_FUNCTION
)
{
psutil_debug
(
"
DeviceIoControl
-
>
ERROR_INVALID_FUNCTION
;
"
"
ignore
PhysicalDrive
%
i
"
devNum
)
;
goto
next
;
}
else
if
(
GetLastError
(
)
=
=
ERROR_NOT_SUPPORTED
)
{
psutil_debug
(
"
DeviceIoControl
-
>
ERROR_NOT_SUPPORTED
;
"
"
ignore
PhysicalDrive
%
i
"
devNum
)
;
goto
next
;
}
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
sprintf_s
(
szDeviceDisplay
MAX_PATH
"
PhysicalDrive
%
i
"
devNum
)
;
py_tuple
=
Py_BuildValue
(
"
(
IILLKK
)
"
diskPerformance
.
ReadCount
diskPerformance
.
WriteCount
diskPerformance
.
BytesRead
diskPerformance
.
BytesWritten
(
unsigned
long
long
)
(
diskPerformance
.
ReadTime
.
QuadPart
)
/
10000000
(
unsigned
long
long
)
(
diskPerformance
.
WriteTime
.
QuadPart
)
/
10000000
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyDict_SetItemString
(
py_retdict
szDeviceDisplay
py_tuple
)
)
goto
error
;
Py_CLEAR
(
py_tuple
)
;
next
:
CloseHandle
(
hDevice
)
;
}
return
py_retdict
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retdict
)
;
if
(
hDevice
!
=
NULL
)
CloseHandle
(
hDevice
)
;
return
NULL
;
}
PyObject
*
psutil_disk_partitions
(
PyObject
*
self
PyObject
*
args
)
{
DWORD
num_bytes
;
char
drive_strings
[
255
]
;
char
*
drive_letter
=
drive_strings
;
char
mp_buf
[
MAX_PATH
]
;
char
mp_path
[
MAX_PATH
]
;
int
all
;
int
type
;
int
ret
;
unsigned
int
old_mode
=
0
;
char
opts
[
20
]
;
HANDLE
mp_h
;
BOOL
mp_flag
=
TRUE
;
LPTSTR
fs_type
[
MAX_PATH
+
1
]
=
{
0
}
;
DWORD
pflags
=
0
;
PyObject
*
py_all
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retlist
=
=
NULL
)
{
return
NULL
;
}
old_mode
=
SetErrorMode
(
SEM_FAILCRITICALERRORS
)
;
if
(
!
PyArg_ParseTuple
(
args
"
O
"
&
py_all
)
)
goto
error
;
all
=
PyObject_IsTrue
(
py_all
)
;
Py_BEGIN_ALLOW_THREADS
num_bytes
=
GetLogicalDriveStrings
(
254
drive_letter
)
;
Py_END_ALLOW_THREADS
if
(
num_bytes
=
=
0
)
{
PyErr_SetFromWindowsErr
(
0
)
;
goto
error
;
}
while
(
*
drive_letter
!
=
0
)
{
py_tuple
=
NULL
;
opts
[
0
]
=
0
;
fs_type
[
0
]
=
0
;
Py_BEGIN_ALLOW_THREADS
type
=
GetDriveType
(
drive_letter
)
;
Py_END_ALLOW_THREADS
if
(
all
=
=
0
)
{
if
(
(
type
=
=
DRIVE_UNKNOWN
)
|
|
(
type
=
=
DRIVE_NO_ROOT_DIR
)
|
|
(
type
=
=
DRIVE_REMOTE
)
|
|
(
type
=
=
DRIVE_RAMDISK
)
)
{
goto
next
;
}
if
(
(
type
=
=
DRIVE_REMOVABLE
)
&
&
(
strcmp
(
drive_letter
"
A
:
\
\
"
)
=
=
0
)
)
{
goto
next
;
}
}
ret
=
GetVolumeInformation
(
(
LPCTSTR
)
drive_letter
NULL
_ARRAYSIZE
(
drive_letter
)
NULL
NULL
&
pflags
(
LPTSTR
)
fs_type
_ARRAYSIZE
(
fs_type
)
)
;
if
(
ret
=
=
0
)
{
strcat_s
(
opts
_countof
(
opts
)
"
"
)
;
SetLastError
(
0
)
;
}
else
{
if
(
pflags
&
FILE_READ_ONLY_VOLUME
)
strcat_s
(
opts
_countof
(
opts
)
"
ro
"
)
;
else
strcat_s
(
opts
_countof
(
opts
)
"
rw
"
)
;
if
(
pflags
&
FILE_VOLUME_IS_COMPRESSED
)
strcat_s
(
opts
_countof
(
opts
)
"
compressed
"
)
;
if
(
pflags
&
FILE_SUPPORTS_REPARSE_POINTS
)
{
mp_h
=
FindFirstVolumeMountPoint
(
drive_letter
mp_buf
MAX_PATH
)
;
if
(
mp_h
!
=
INVALID_HANDLE_VALUE
)
{
while
(
mp_flag
)
{
strcpy_s
(
mp_path
_countof
(
mp_path
)
drive_letter
)
;
strcat_s
(
mp_path
_countof
(
mp_path
)
mp_buf
)
;
py_tuple
=
Py_BuildValue
(
"
(
ssss
)
"
drive_letter
mp_path
fs_type
opts
)
;
if
(
!
py_tuple
|
|
PyList_Append
(
py_retlist
py_tuple
)
=
=
-
1
)
{
FindVolumeMountPointClose
(
mp_h
)
;
goto
error
;
}
Py_CLEAR
(
py_tuple
)
;
mp_flag
=
FindNextVolumeMountPoint
(
mp_h
mp_buf
MAX_PATH
)
;
}
FindVolumeMountPointClose
(
mp_h
)
;
}
}
}
if
(
strlen
(
opts
)
>
0
)
strcat_s
(
opts
_countof
(
opts
)
"
"
)
;
strcat_s
(
opts
_countof
(
opts
)
psutil_get_drive_type
(
type
)
)
;
py_tuple
=
Py_BuildValue
(
"
(
ssss
)
"
drive_letter
drive_letter
fs_type
opts
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_CLEAR
(
py_tuple
)
;
goto
next
;
next
:
drive_letter
=
strchr
(
drive_letter
0
)
+
1
;
}
SetErrorMode
(
old_mode
)
;
return
py_retlist
;
error
:
SetErrorMode
(
old_mode
)
;
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
return
NULL
;
}
PyObject
*
psutil_win32_QueryDosDevice
(
PyObject
*
self
PyObject
*
args
)
{
LPCTSTR
lpDevicePath
;
TCHAR
d
=
TEXT
(
'
A
'
)
;
TCHAR
szBuff
[
5
]
;
if
(
!
PyArg_ParseTuple
(
args
"
s
"
&
lpDevicePath
)
)
return
NULL
;
while
(
d
<
=
TEXT
(
'
Z
'
)
)
{
TCHAR
szDeviceName
[
3
]
=
{
d
TEXT
(
'
:
'
)
TEXT
(
'
\
0
'
)
}
;
TCHAR
szTarget
[
512
]
=
{
0
}
;
if
(
QueryDosDevice
(
szDeviceName
szTarget
511
)
!
=
0
)
{
if
(
_tcscmp
(
lpDevicePath
szTarget
)
=
=
0
)
{
_stprintf_s
(
szBuff
_countof
(
szBuff
)
TEXT
(
"
%
c
:
"
)
d
)
;
return
Py_BuildValue
(
"
s
"
szBuff
)
;
}
}
d
+
+
;
}
return
Py_BuildValue
(
"
s
"
"
"
)
;
}
