#
include
<
Python
.
h
>
#
include
<
sys
/
core
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
common
.
h
"
int
psutil_kread
(
int
Kd
KA_T
addr
char
*
buf
size_t
len
)
{
int
br
;
if
(
lseek64
(
Kd
(
off64_t
)
addr
L_SET
)
=
=
(
off64_t
)
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
1
;
}
br
=
read
(
Kd
buf
len
)
;
if
(
br
=
=
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
1
;
}
if
(
br
!
=
len
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
size
mismatch
when
reading
kernel
memory
fd
"
)
;
return
1
;
}
return
0
;
}
struct
procentry64
*
psutil_read_process_table
(
int
*
num
)
{
size_t
msz
;
pid32_t
pid
=
0
;
struct
procentry64
*
processes
=
(
struct
procentry64
*
)
NULL
;
struct
procentry64
*
p
;
int
Np
=
0
;
int
np
=
0
;
int
i
;
msz
=
(
size_t
)
(
PROCSIZE
*
PROCINFO_INCR
)
;
processes
=
(
struct
procentry64
*
)
malloc
(
msz
)
;
if
(
!
processes
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
Np
=
PROCINFO_INCR
;
p
=
processes
;
while
(
(
i
=
getprocs64
(
p
PROCSIZE
(
struct
fdsinfo64
*
)
NULL
0
&
pid
PROCINFO_INCR
)
)
=
=
PROCINFO_INCR
)
{
np
+
=
PROCINFO_INCR
;
if
(
np
>
=
Np
)
{
msz
=
(
size_t
)
(
PROCSIZE
*
(
Np
+
PROCINFO_INCR
)
)
;
processes
=
(
struct
procentry64
*
)
realloc
(
(
char
*
)
processes
msz
)
;
if
(
!
processes
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
Np
+
=
PROCINFO_INCR
;
}
p
=
(
struct
procentry64
*
)
(
(
char
*
)
processes
+
(
np
*
PROCSIZE
)
)
;
}
if
(
i
>
0
)
np
+
=
i
;
*
num
=
np
;
return
processes
;
}
