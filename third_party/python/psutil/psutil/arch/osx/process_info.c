#
include
<
Python
.
h
>
#
include
<
assert
.
h
>
#
include
<
errno
.
h
>
#
include
<
limits
.
h
>
#
include
<
stdbool
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
signal
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
libproc
.
h
>
#
include
"
.
.
/
.
.
/
_psutil_common
.
h
"
#
include
"
.
.
/
.
.
/
_psutil_posix
.
h
"
#
include
"
process_info
.
h
"
int
psutil_get_proc_list
(
kinfo_proc
*
*
procList
size_t
*
procCount
)
{
int
mib3
[
3
]
=
{
CTL_KERN
KERN_PROC
KERN_PROC_ALL
}
;
size_t
size
size2
;
void
*
ptr
;
int
err
;
int
lim
=
8
;
assert
(
procList
!
=
NULL
)
;
assert
(
*
procList
=
=
NULL
)
;
assert
(
procCount
!
=
NULL
)
;
*
procCount
=
0
;
while
(
lim
-
-
>
0
)
{
size
=
0
;
if
(
sysctl
(
(
int
*
)
mib3
3
NULL
&
size
NULL
0
)
=
=
-
1
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_ALL
)
"
)
;
return
1
;
}
size2
=
size
+
(
size
>
>
3
)
;
if
(
size2
>
size
)
{
ptr
=
malloc
(
size2
)
;
if
(
ptr
=
=
NULL
)
ptr
=
malloc
(
size
)
;
else
size
=
size2
;
}
else
{
ptr
=
malloc
(
size
)
;
}
if
(
ptr
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
return
1
;
}
if
(
sysctl
(
(
int
*
)
mib3
3
ptr
&
size
NULL
0
)
=
=
-
1
)
{
err
=
errno
;
free
(
ptr
)
;
if
(
err
!
=
ENOMEM
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_ALL
)
"
)
;
return
1
;
}
}
else
{
*
procList
=
(
kinfo_proc
*
)
ptr
;
*
procCount
=
size
/
sizeof
(
kinfo_proc
)
;
if
(
procCount
<
=
0
)
{
PyErr_Format
(
PyExc_RuntimeError
"
no
PIDs
found
"
)
;
return
1
;
}
return
0
;
}
}
PyErr_Format
(
PyExc_RuntimeError
"
couldn
'
t
collect
PIDs
list
"
)
;
return
1
;
}
int
psutil_get_argmax
(
)
{
int
argmax
;
int
mib
[
]
=
{
CTL_KERN
KERN_ARGMAX
}
;
size_t
size
=
sizeof
(
argmax
)
;
if
(
sysctl
(
mib
2
&
argmax
&
size
NULL
0
)
=
=
0
)
return
argmax
;
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_ARGMAX
)
"
)
;
return
0
;
}
int
psutil_is_zombie
(
pid_t
pid
)
{
struct
kinfo_proc
kp
;
if
(
psutil_get_kinfo_proc
(
pid
&
kp
)
=
=
-
1
)
return
0
;
return
(
kp
.
kp_proc
.
p_stat
=
=
SZOMB
)
?
1
:
0
;
}
PyObject
*
psutil_get_cmdline
(
pid_t
pid
)
{
int
mib
[
3
]
;
int
nargs
;
size_t
len
;
char
*
procargs
=
NULL
;
char
*
arg_ptr
;
char
*
arg_end
;
char
*
curr_arg
;
size_t
argmax
;
PyObject
*
py_arg
=
NULL
;
PyObject
*
py_retlist
=
NULL
;
if
(
pid
=
=
0
)
return
Py_BuildValue
(
"
[
]
"
)
;
argmax
=
psutil_get_argmax
(
)
;
if
(
!
argmax
)
goto
error
;
procargs
=
(
char
*
)
malloc
(
argmax
)
;
if
(
NULL
=
=
procargs
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROCARGS2
;
mib
[
2
]
=
pid
;
if
(
sysctl
(
mib
3
procargs
&
argmax
NULL
0
)
<
0
)
{
if
(
(
errno
=
=
EINVAL
)
&
&
(
psutil_pid_exists
(
pid
)
)
)
NoSuchProcess
(
"
sysctl
"
)
;
else
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
arg_end
=
&
procargs
[
argmax
]
;
memcpy
(
&
nargs
procargs
sizeof
(
nargs
)
)
;
arg_ptr
=
procargs
+
sizeof
(
nargs
)
;
len
=
strlen
(
arg_ptr
)
;
arg_ptr
+
=
len
+
1
;
if
(
arg_ptr
=
=
arg_end
)
{
free
(
procargs
)
;
return
Py_BuildValue
(
"
[
]
"
)
;
}
for
(
;
arg_ptr
<
arg_end
;
arg_ptr
+
+
)
{
if
(
*
arg_ptr
!
=
'
\
0
'
)
break
;
}
curr_arg
=
arg_ptr
;
py_retlist
=
Py_BuildValue
(
"
[
]
"
)
;
if
(
!
py_retlist
)
goto
error
;
while
(
arg_ptr
<
arg_end
&
&
nargs
>
0
)
{
if
(
*
arg_ptr
+
+
=
=
'
\
0
'
)
{
py_arg
=
PyUnicode_DecodeFSDefault
(
curr_arg
)
;
if
(
!
py_arg
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_arg
)
)
goto
error
;
Py_DECREF
(
py_arg
)
;
curr_arg
=
arg_ptr
;
nargs
-
-
;
}
}
free
(
procargs
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_arg
)
;
Py_XDECREF
(
py_retlist
)
;
if
(
procargs
!
=
NULL
)
free
(
procargs
)
;
return
NULL
;
}
PyObject
*
psutil_get_environ
(
pid_t
pid
)
{
int
mib
[
3
]
;
int
nargs
;
char
*
procargs
=
NULL
;
char
*
procenv
=
NULL
;
char
*
arg_ptr
;
char
*
arg_end
;
char
*
env_start
;
size_t
argmax
;
PyObject
*
py_ret
=
NULL
;
if
(
pid
=
=
0
)
goto
empty
;
argmax
=
psutil_get_argmax
(
)
;
if
(
!
argmax
)
goto
error
;
procargs
=
(
char
*
)
malloc
(
argmax
)
;
if
(
NULL
=
=
procargs
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROCARGS2
;
mib
[
2
]
=
pid
;
if
(
sysctl
(
mib
3
procargs
&
argmax
NULL
0
)
<
0
)
{
if
(
(
errno
=
=
EINVAL
)
&
&
(
psutil_pid_exists
(
pid
)
)
)
NoSuchProcess
(
"
sysctl
"
)
;
else
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
arg_end
=
&
procargs
[
argmax
]
;
memcpy
(
&
nargs
procargs
sizeof
(
nargs
)
)
;
arg_ptr
=
procargs
+
sizeof
(
nargs
)
;
arg_ptr
=
memchr
(
arg_ptr
'
\
0
'
arg_end
-
arg_ptr
)
;
if
(
arg_ptr
=
=
NULL
|
|
arg_ptr
=
=
arg_end
)
goto
empty
;
for
(
;
arg_ptr
<
arg_end
;
arg_ptr
+
+
)
{
if
(
*
arg_ptr
!
=
'
\
0
'
)
break
;
}
while
(
arg_ptr
<
arg_end
&
&
nargs
>
0
)
{
if
(
*
arg_ptr
+
+
=
=
'
\
0
'
)
nargs
-
-
;
}
env_start
=
arg_ptr
;
procenv
=
calloc
(
1
arg_end
-
arg_ptr
)
;
if
(
procenv
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
while
(
*
arg_ptr
!
=
'
\
0
'
&
&
arg_ptr
<
arg_end
)
{
char
*
s
=
memchr
(
arg_ptr
+
1
'
\
0
'
arg_end
-
arg_ptr
)
;
if
(
s
=
=
NULL
)
break
;
memcpy
(
procenv
+
(
arg_ptr
-
env_start
)
arg_ptr
s
-
arg_ptr
)
;
arg_ptr
=
s
+
1
;
}
py_ret
=
PyUnicode_DecodeFSDefaultAndSize
(
procenv
arg_ptr
-
env_start
+
1
)
;
if
(
!
py_ret
)
{
procargs
=
NULL
;
goto
error
;
}
free
(
procargs
)
;
free
(
procenv
)
;
return
py_ret
;
empty
:
if
(
procargs
!
=
NULL
)
free
(
procargs
)
;
return
Py_BuildValue
(
"
s
"
"
"
)
;
error
:
Py_XDECREF
(
py_ret
)
;
if
(
procargs
!
=
NULL
)
free
(
procargs
)
;
if
(
procenv
!
=
NULL
)
free
(
procargs
)
;
return
NULL
;
}
int
psutil_get_kinfo_proc
(
pid_t
pid
struct
kinfo_proc
*
kp
)
{
int
mib
[
4
]
;
size_t
len
;
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROC
;
mib
[
2
]
=
KERN_PROC_PID
;
mib
[
3
]
=
pid
;
len
=
sizeof
(
struct
kinfo_proc
)
;
if
(
sysctl
(
mib
4
kp
&
len
NULL
0
)
=
=
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
-
1
;
}
if
(
len
=
=
0
)
{
NoSuchProcess
(
"
sysctl
(
len
=
=
0
)
"
)
;
return
-
1
;
}
return
0
;
}
int
psutil_proc_pidinfo
(
pid_t
pid
int
flavor
uint64_t
arg
void
*
pti
int
size
)
{
errno
=
0
;
int
ret
=
proc_pidinfo
(
pid
flavor
arg
pti
size
)
;
if
(
(
ret
<
=
0
)
|
|
(
(
unsigned
long
)
ret
<
sizeof
(
pti
)
)
)
{
psutil_raise_for_pid
(
pid
"
proc_pidinfo
(
)
"
)
;
return
0
;
}
return
ret
;
}
