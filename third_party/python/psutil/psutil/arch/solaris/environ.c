#
define
_STRUCTURED_PROC
1
#
include
<
Python
.
h
>
#
if
!
defined
(
_LP64
)
&
&
_FILE_OFFSET_BITS
=
=
64
#
undef
_FILE_OFFSET_BITS
#
undef
_LARGEFILE64_SOURCE
#
endif
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
procfs
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
include
"
environ
.
h
"
#
define
STRING_SEARCH_BUF_SIZE
512
static
int
open_address_space
(
pid_t
pid
const
char
*
procfs_path
)
{
int
fd
;
char
proc_path
[
PATH_MAX
]
;
snprintf
(
proc_path
PATH_MAX
"
%
s
/
%
i
/
as
"
procfs_path
pid
)
;
fd
=
open
(
proc_path
O_RDONLY
)
;
if
(
fd
<
0
)
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
fd
;
}
static
int
read_offt
(
int
fd
off_t
offset
char
*
buf
size_t
buf_size
)
{
size_t
to_read
=
buf_size
;
size_t
stored
=
0
;
int
r
;
while
(
to_read
)
{
r
=
pread
(
fd
buf
+
stored
to_read
offset
+
stored
)
;
if
(
r
<
0
)
goto
error
;
else
if
(
r
=
=
0
)
break
;
to_read
-
=
r
;
stored
+
=
r
;
}
return
stored
;
error
:
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
-
1
;
}
static
char
*
read_cstring_offt
(
int
fd
off_t
offset
)
{
int
r
;
int
i
=
0
;
off_t
end
=
offset
;
size_t
len
;
char
buf
[
STRING_SEARCH_BUF_SIZE
]
;
char
*
result
=
NULL
;
if
(
lseek
(
fd
offset
SEEK_SET
)
=
=
(
off_t
)
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
for
(
;
;
)
{
r
=
read
(
fd
buf
sizeof
(
buf
)
)
;
if
(
r
=
=
-
1
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
else
if
(
r
=
=
0
)
{
break
;
}
else
{
for
(
i
=
0
;
i
<
r
;
i
+
+
)
if
(
!
buf
[
i
]
)
goto
found
;
}
end
+
=
r
;
}
found
:
len
=
end
+
i
-
offset
;
result
=
malloc
(
len
+
1
)
;
if
(
!
result
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
len
)
{
if
(
read_offt
(
fd
offset
result
len
)
<
0
)
{
goto
error
;
}
}
result
[
len
]
=
'
\
0
'
;
return
result
;
error
:
if
(
result
)
free
(
result
)
;
return
NULL
;
}
static
char
*
*
read_cstrings_block
(
int
fd
off_t
offset
size_t
ptr_size
size_t
count
)
{
char
*
*
result
=
NULL
;
char
*
pblock
=
NULL
;
size_t
pblock_size
;
int
i
;
assert
(
ptr_size
=
=
4
|
|
ptr_size
=
=
8
)
;
if
(
!
count
)
goto
error
;
pblock_size
=
ptr_size
*
count
;
pblock
=
malloc
(
pblock_size
)
;
if
(
!
pblock
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
if
(
read_offt
(
fd
offset
pblock
pblock_size
)
!
=
pblock_size
)
goto
error
;
result
=
(
char
*
*
)
calloc
(
count
sizeof
(
char
*
)
)
;
if
(
!
result
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
result
[
i
]
=
read_cstring_offt
(
fd
(
ptr_size
=
=
4
?
(
(
uint32_t
*
)
pblock
)
[
i
]
:
(
(
uint64_t
*
)
pblock
)
[
i
]
)
)
;
if
(
!
result
[
i
]
)
goto
error
;
}
free
(
pblock
)
;
return
result
;
error
:
if
(
result
)
psutil_free_cstrings_array
(
result
i
)
;
if
(
pblock
)
free
(
pblock
)
;
return
NULL
;
}
static
inline
int
is_ptr_dereference_possible
(
psinfo_t
info
)
{
#
if
!
defined
(
_LP64
)
return
info
.
pr_dmodel
=
=
PR_MODEL_ILP32
;
#
else
return
1
;
#
endif
}
static
inline
int
ptr_size_by_psinfo
(
psinfo_t
info
)
{
return
info
.
pr_dmodel
=
=
PR_MODEL_ILP32
?
4
:
8
;
}
static
int
search_pointers_vector_size_offt
(
int
fd
off_t
offt
size_t
ptr_size
)
{
int
count
=
0
;
int
r
;
char
buf
[
8
]
;
static
const
char
zeros
[
8
]
=
{
0
0
0
0
0
0
0
0
}
;
assert
(
ptr_size
=
=
4
|
|
ptr_size
=
=
8
)
;
if
(
lseek
(
fd
offt
SEEK_SET
)
=
=
(
off_t
)
-
1
)
goto
error
;
for
(
;
;
count
+
+
)
{
r
=
read
(
fd
buf
ptr_size
)
;
if
(
r
<
0
)
goto
error
;
if
(
r
=
=
0
)
break
;
if
(
r
!
=
ptr_size
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
pointer
block
is
truncated
"
)
;
return
-
1
;
}
if
(
!
memcmp
(
buf
zeros
ptr_size
)
)
break
;
}
return
count
;
error
:
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
-
1
;
}
char
*
*
psutil_read_raw_args
(
psinfo_t
info
const
char
*
procfs_path
size_t
*
count
)
{
int
as
;
char
*
*
result
;
if
(
!
is_ptr_dereference_possible
(
info
)
)
{
PyErr_SetString
(
PyExc_NotImplementedError
"
can
'
t
get
env
of
a
64
bit
process
from
a
32
bit
process
"
)
;
return
NULL
;
}
if
(
!
(
info
.
pr_argv
&
&
info
.
pr_argc
)
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
process
doesn
'
t
have
arguments
block
"
)
;
return
NULL
;
}
as
=
open_address_space
(
info
.
pr_pid
procfs_path
)
;
if
(
as
<
0
)
return
NULL
;
result
=
read_cstrings_block
(
as
info
.
pr_argv
ptr_size_by_psinfo
(
info
)
info
.
pr_argc
)
;
if
(
result
&
&
count
)
*
count
=
info
.
pr_argc
;
close
(
as
)
;
return
result
;
}
char
*
*
psutil_read_raw_env
(
psinfo_t
info
const
char
*
procfs_path
ssize_t
*
count
)
{
int
as
;
int
env_count
;
int
ptr_size
;
char
*
*
result
=
NULL
;
if
(
!
is_ptr_dereference_possible
(
info
)
)
{
PyErr_SetString
(
PyExc_NotImplementedError
"
can
'
t
get
env
of
a
64
bit
process
from
a
32
bit
process
"
)
;
return
NULL
;
}
as
=
open_address_space
(
info
.
pr_pid
procfs_path
)
;
if
(
as
<
0
)
return
NULL
;
ptr_size
=
ptr_size_by_psinfo
(
info
)
;
env_count
=
search_pointers_vector_size_offt
(
as
info
.
pr_envp
ptr_size
)
;
if
(
env_count
>
=
0
&
&
count
)
*
count
=
env_count
;
if
(
env_count
>
0
)
result
=
read_cstrings_block
(
as
info
.
pr_envp
ptr_size
env_count
)
;
close
(
as
)
;
return
result
;
}
void
psutil_free_cstrings_array
(
char
*
*
array
size_t
count
)
{
int
i
;
if
(
!
array
)
return
;
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
array
[
i
]
)
{
free
(
array
[
i
]
)
;
}
}
free
(
array
)
;
}
