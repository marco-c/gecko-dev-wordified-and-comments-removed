#
include
<
Python
.
h
>
#
include
<
assert
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
sys
/
param
.
h
>
#
include
<
sys
/
user
.
h
>
#
include
<
sys
/
proc
.
h
>
#
include
<
signal
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
vmmeter
.
h
>
#
include
<
devstat
.
h
>
#
include
<
libutil
.
h
>
#
include
<
sys
/
cpuset
.
h
>
#
include
"
.
.
/
.
.
/
_psutil_common
.
h
"
#
include
"
.
.
/
.
.
/
_psutil_posix
.
h
"
#
define
PSUTIL_TV2DOUBLE
(
t
)
(
(
t
)
.
tv_sec
+
(
t
)
.
tv_usec
/
1000000
.
0
)
#
define
PSUTIL_BT2MSEC
(
bt
)
(
bt
.
sec
*
1000
+
(
(
(
uint64_t
)
1000000000
*
(
uint32_t
)
\
(
bt
.
frac
>
>
32
)
)
>
>
32
)
/
1000000
)
#
define
DECIKELVIN_2_CELCIUS
(
t
)
(
t
-
2731
)
/
10
#
ifndef
_PATH_DEVNULL
#
define
_PATH_DEVNULL
"
/
dev
/
null
"
#
endif
int
psutil_kinfo_proc
(
const
pid_t
pid
struct
kinfo_proc
*
proc
)
{
int
mib
[
4
]
;
size_t
size
;
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROC
;
mib
[
2
]
=
KERN_PROC_PID
;
mib
[
3
]
=
pid
;
size
=
sizeof
(
struct
kinfo_proc
)
;
if
(
sysctl
(
(
int
*
)
mib
4
proc
&
size
NULL
0
)
=
=
-
1
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_PID
)
"
)
;
return
-
1
;
}
if
(
size
=
=
0
)
{
NoSuchProcess
(
"
"
)
;
return
-
1
;
}
return
0
;
}
static
void
psutil_remove_spaces
(
char
*
str
)
{
char
*
p1
=
str
;
char
*
p2
=
str
;
do
while
(
*
p2
=
=
'
'
)
p2
+
+
;
while
(
(
*
p1
+
+
=
*
p2
+
+
)
)
;
}
int
psutil_get_proc_list
(
struct
kinfo_proc
*
*
procList
size_t
*
procCount
)
{
int
err
;
struct
kinfo_proc
*
result
;
int
done
;
int
name
[
]
=
{
CTL_KERN
KERN_PROC
KERN_PROC_PROC
0
}
;
size_t
length
;
assert
(
procList
!
=
NULL
)
;
assert
(
*
procList
=
=
NULL
)
;
assert
(
procCount
!
=
NULL
)
;
*
procCount
=
0
;
result
=
NULL
;
done
=
0
;
do
{
assert
(
result
=
=
NULL
)
;
length
=
0
;
err
=
sysctl
(
(
int
*
)
name
(
sizeof
(
name
)
/
sizeof
(
*
name
)
)
-
1
NULL
&
length
NULL
0
)
;
if
(
err
=
=
-
1
)
err
=
errno
;
if
(
err
=
=
0
)
{
result
=
malloc
(
length
)
;
if
(
result
=
=
NULL
)
err
=
ENOMEM
;
}
if
(
err
=
=
0
)
{
err
=
sysctl
(
(
int
*
)
name
(
sizeof
(
name
)
/
sizeof
(
*
name
)
)
-
1
result
&
length
NULL
0
)
;
if
(
err
=
=
-
1
)
err
=
errno
;
if
(
err
=
=
0
)
{
done
=
1
;
}
else
if
(
err
=
=
ENOMEM
)
{
assert
(
result
!
=
NULL
)
;
free
(
result
)
;
result
=
NULL
;
err
=
0
;
}
}
}
while
(
err
=
=
0
&
&
!
done
)
;
if
(
err
!
=
0
&
&
result
!
=
NULL
)
{
free
(
result
)
;
result
=
NULL
;
}
*
procList
=
result
;
*
procCount
=
length
/
sizeof
(
struct
kinfo_proc
)
;
assert
(
(
err
=
=
0
)
=
=
(
*
procList
!
=
NULL
)
)
;
return
err
;
}
static
char
*
psutil_get_cmd_args
(
long
pid
size_t
*
argsize
)
{
int
mib
[
4
]
;
int
argmax
;
size_t
size
=
sizeof
(
argmax
)
;
char
*
procargs
=
NULL
;
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_ARGMAX
;
size
=
sizeof
(
argmax
)
;
if
(
sysctl
(
mib
2
&
argmax
&
size
NULL
0
)
=
=
-
1
)
return
NULL
;
procargs
=
(
char
*
)
malloc
(
argmax
)
;
if
(
procargs
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROC
;
mib
[
2
]
=
KERN_PROC_ARGS
;
mib
[
3
]
=
pid
;
size
=
argmax
;
if
(
sysctl
(
mib
4
procargs
&
size
NULL
0
)
=
=
-
1
)
{
free
(
procargs
)
;
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_ARGS
)
"
)
;
return
NULL
;
}
*
argsize
=
size
;
return
procargs
;
}
PyObject
*
psutil_get_cmdline
(
long
pid
)
{
char
*
argstr
=
NULL
;
size_t
pos
=
0
;
size_t
argsize
=
0
;
PyObject
*
py_retlist
=
Py_BuildValue
(
"
[
]
"
)
;
PyObject
*
py_arg
=
NULL
;
if
(
pid
<
0
)
return
py_retlist
;
argstr
=
psutil_get_cmd_args
(
pid
&
argsize
)
;
if
(
argstr
=
=
NULL
)
goto
error
;
if
(
argsize
>
0
)
{
while
(
pos
<
argsize
)
{
py_arg
=
PyUnicode_DecodeFSDefault
(
&
argstr
[
pos
]
)
;
if
(
!
py_arg
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_arg
)
)
goto
error
;
Py_DECREF
(
py_arg
)
;
pos
=
pos
+
strlen
(
&
argstr
[
pos
]
)
+
1
;
}
}
free
(
argstr
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_arg
)
;
Py_DECREF
(
py_retlist
)
;
if
(
argstr
!
=
NULL
)
free
(
argstr
)
;
return
NULL
;
}
PyObject
*
psutil_proc_exe
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
char
pathname
[
PATH_MAX
]
;
int
error
;
int
mib
[
4
]
;
int
ret
;
size_t
size
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROC
;
mib
[
2
]
=
KERN_PROC_PATHNAME
;
mib
[
3
]
=
pid
;
size
=
sizeof
(
pathname
)
;
error
=
sysctl
(
mib
4
pathname
&
size
NULL
0
)
;
if
(
error
=
=
-
1
)
{
if
(
errno
=
=
ENOENT
)
{
return
PyUnicode_DecodeFSDefault
(
"
"
)
;
}
else
{
return
\
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_PATHNAME
)
"
)
;
}
}
if
(
size
=
=
0
|
|
strlen
(
pathname
)
=
=
0
)
{
ret
=
psutil_pid_exists
(
pid
)
;
if
(
ret
=
=
-
1
)
return
NULL
;
else
if
(
ret
=
=
0
)
return
NoSuchProcess
(
"
"
)
;
else
strcpy
(
pathname
"
"
)
;
}
return
PyUnicode_DecodeFSDefault
(
pathname
)
;
}
PyObject
*
psutil_proc_num_threads
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
struct
kinfo_proc
kp
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
psutil_kinfo_proc
(
pid
&
kp
)
=
=
-
1
)
return
NULL
;
return
Py_BuildValue
(
"
l
"
(
long
)
kp
.
ki_numthreads
)
;
}
PyObject
*
psutil_proc_threads
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
mib
[
4
]
;
struct
kinfo_proc
*
kip
=
NULL
;
struct
kinfo_proc
*
kipp
=
NULL
;
int
error
;
unsigned
int
i
;
size_t
size
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_tuple
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
goto
error
;
mib
[
0
]
=
CTL_KERN
;
mib
[
1
]
=
KERN_PROC
;
mib
[
2
]
=
KERN_PROC_PID
|
KERN_PROC_INC_THREAD
;
mib
[
3
]
=
pid
;
size
=
0
;
error
=
sysctl
(
mib
4
NULL
&
size
NULL
0
)
;
if
(
error
=
=
-
1
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_INC_THREAD
)
"
)
;
goto
error
;
}
if
(
size
=
=
0
)
{
NoSuchProcess
(
"
"
)
;
goto
error
;
}
kip
=
malloc
(
size
)
;
if
(
kip
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
error
=
sysctl
(
mib
4
kip
&
size
NULL
0
)
;
if
(
error
=
=
-
1
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
KERN_PROC_INC_THREAD
)
"
)
;
goto
error
;
}
if
(
size
=
=
0
)
{
NoSuchProcess
(
"
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
size
/
sizeof
(
*
kipp
)
;
i
+
+
)
{
kipp
=
&
kip
[
i
]
;
py_tuple
=
Py_BuildValue
(
"
Idd
"
kipp
-
>
ki_tid
PSUTIL_TV2DOUBLE
(
kipp
-
>
ki_rusage
.
ru_utime
)
PSUTIL_TV2DOUBLE
(
kipp
-
>
ki_rusage
.
ru_stime
)
)
;
if
(
py_tuple
=
=
NULL
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_tuple
)
;
}
free
(
kip
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_DECREF
(
py_retlist
)
;
if
(
kip
!
=
NULL
)
free
(
kip
)
;
return
NULL
;
}
PyObject
*
psutil_cpu_count_phys
(
PyObject
*
self
PyObject
*
args
)
{
void
*
topology
=
NULL
;
size_t
size
=
0
;
PyObject
*
py_str
;
if
(
sysctlbyname
(
"
kern
.
sched
.
topology_spec
"
NULL
&
size
NULL
0
)
)
goto
error
;
topology
=
malloc
(
size
)
;
if
(
!
topology
)
{
PyErr_NoMemory
(
)
;
return
NULL
;
}
if
(
sysctlbyname
(
"
kern
.
sched
.
topology_spec
"
topology
&
size
NULL
0
)
)
goto
error
;
py_str
=
Py_BuildValue
(
"
s
"
topology
)
;
free
(
topology
)
;
return
py_str
;
error
:
if
(
topology
!
=
NULL
)
free
(
topology
)
;
Py_RETURN_NONE
;
}
PyObject
*
psutil_virtual_mem
(
PyObject
*
self
PyObject
*
args
)
{
unsigned
long
total
;
unsigned
int
active
inactive
wired
cached
free
;
size_t
size
=
sizeof
(
total
)
;
struct
vmtotal
vm
;
int
mib
[
]
=
{
CTL_VM
VM_METER
}
;
long
pagesize
=
getpagesize
(
)
;
#
if
__FreeBSD_version
>
702101
long
buffers
;
#
else
int
buffers
;
#
endif
size_t
buffers_size
=
sizeof
(
buffers
)
;
if
(
sysctlbyname
(
"
hw
.
physmem
"
&
total
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
hw
.
physmem
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_active_count
"
&
active
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_active_count
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_inactive_count
"
&
inactive
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_inactive_count
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_wire_count
"
&
wired
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_wire_count
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_cache_count
"
&
cached
&
size
NULL
0
)
)
{
cached
=
0
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_free_count
"
&
free
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_free_count
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vfs
.
bufspace
"
&
buffers
&
buffers_size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vfs
.
bufspace
'
)
"
)
;
}
size
=
sizeof
(
vm
)
;
if
(
sysctl
(
mib
2
&
vm
&
size
NULL
0
)
!
=
0
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
CTL_VM
|
VM_METER
)
"
)
;
}
return
Py_BuildValue
(
"
KKKKKKKK
"
(
unsigned
long
long
)
total
(
unsigned
long
long
)
free
*
pagesize
(
unsigned
long
long
)
active
*
pagesize
(
unsigned
long
long
)
inactive
*
pagesize
(
unsigned
long
long
)
wired
*
pagesize
(
unsigned
long
long
)
cached
*
pagesize
(
unsigned
long
long
)
buffers
(
unsigned
long
long
)
(
vm
.
t_vmshr
+
vm
.
t_rmshr
)
*
pagesize
)
;
}
PyObject
*
psutil_swap_mem
(
PyObject
*
self
PyObject
*
args
)
{
kvm_t
*
kd
;
struct
kvm_swap
kvmsw
[
1
]
;
unsigned
int
swapin
swapout
nodein
nodeout
;
size_t
size
=
sizeof
(
unsigned
int
)
;
int
pagesize
;
kd
=
kvm_open
(
NULL
_PATH_DEVNULL
NULL
O_RDONLY
"
kvm_open
failed
"
)
;
if
(
kd
=
=
NULL
)
{
PyErr_SetString
(
PyExc_RuntimeError
"
kvm_open
(
)
syscall
failed
"
)
;
return
NULL
;
}
if
(
kvm_getswapinfo
(
kd
kvmsw
1
0
)
<
0
)
{
kvm_close
(
kd
)
;
PyErr_SetString
(
PyExc_RuntimeError
"
kvm_getswapinfo
(
)
syscall
failed
"
)
;
return
NULL
;
}
kvm_close
(
kd
)
;
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_swapin
"
&
swapin
&
size
NULL
0
)
=
=
-
1
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_swapin
)
'
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_swapout
"
&
swapout
&
size
NULL
0
)
=
=
-
1
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_swapout
)
'
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_vnodein
"
&
nodein
&
size
NULL
0
)
=
=
-
1
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_vnodein
)
'
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
vm
.
v_vnodeout
"
&
nodeout
&
size
NULL
0
)
=
=
-
1
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
vm
.
v_vnodeout
)
'
"
)
;
}
pagesize
=
getpagesize
(
)
;
if
(
pagesize
<
=
0
)
{
PyErr_SetString
(
PyExc_ValueError
"
invalid
getpagesize
(
)
"
)
;
return
NULL
;
}
return
Py_BuildValue
(
"
(
KKKII
)
"
(
unsigned
long
long
)
kvmsw
[
0
]
.
ksw_total
*
pagesize
(
unsigned
long
long
)
kvmsw
[
0
]
.
ksw_used
*
pagesize
(
unsigned
long
long
)
kvmsw
[
0
]
.
ksw_total
*
pagesize
-
kvmsw
[
0
]
.
ksw_used
*
pagesize
swapin
+
swapout
nodein
+
nodeout
)
;
}
#
if
defined
(
__FreeBSD_version
)
&
&
__FreeBSD_version
>
=
800000
PyObject
*
psutil_proc_cwd
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
struct
kinfo_file
*
freep
=
NULL
;
struct
kinfo_file
*
kif
;
struct
kinfo_proc
kipp
;
PyObject
*
py_path
=
NULL
;
int
i
cnt
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
goto
error
;
if
(
psutil_kinfo_proc
(
pid
&
kipp
)
=
=
-
1
)
goto
error
;
errno
=
0
;
freep
=
kinfo_getfile
(
pid
&
cnt
)
;
if
(
freep
=
=
NULL
)
{
psutil_raise_for_pid
(
pid
"
kinfo_getfile
(
)
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
cnt
;
i
+
+
)
{
kif
=
&
freep
[
i
]
;
if
(
kif
-
>
kf_fd
=
=
KF_FD_TYPE_CWD
)
{
py_path
=
PyUnicode_DecodeFSDefault
(
kif
-
>
kf_path
)
;
if
(
!
py_path
)
goto
error
;
break
;
}
}
if
(
py_path
=
=
NULL
)
py_path
=
PyUnicode_DecodeFSDefault
(
"
"
)
;
free
(
freep
)
;
return
py_path
;
error
:
Py_XDECREF
(
py_path
)
;
if
(
freep
!
=
NULL
)
free
(
freep
)
;
return
NULL
;
}
#
endif
#
if
defined
(
__FreeBSD_version
)
&
&
__FreeBSD_version
>
=
800000
PyObject
*
psutil_proc_num_fds
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
cnt
;
struct
kinfo_file
*
freep
;
struct
kinfo_proc
kipp
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
return
NULL
;
if
(
psutil_kinfo_proc
(
pid
&
kipp
)
=
=
-
1
)
return
NULL
;
errno
=
0
;
freep
=
kinfo_getfile
(
pid
&
cnt
)
;
if
(
freep
=
=
NULL
)
{
psutil_raise_for_pid
(
pid
"
kinfo_getfile
(
)
"
)
;
return
NULL
;
}
free
(
freep
)
;
return
Py_BuildValue
(
"
i
"
cnt
)
;
}
#
endif
PyObject
*
psutil_per_cpu_times
(
PyObject
*
self
PyObject
*
args
)
{
static
int
maxcpus
;
int
mib
[
2
]
;
int
ncpu
;
size_t
len
;
size_t
size
;
int
i
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
PyObject
*
py_cputime
=
NULL
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
size
=
sizeof
(
maxcpus
)
;
if
(
sysctlbyname
(
"
kern
.
smp
.
maxcpus
"
&
maxcpus
&
size
NULL
0
)
<
0
)
{
Py_DECREF
(
py_retlist
)
;
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
kern
.
smp
.
maxcpus
'
)
"
)
;
}
long
cpu_time
[
maxcpus
]
[
CPUSTATES
]
;
mib
[
0
]
=
CTL_HW
;
mib
[
1
]
=
HW_NCPU
;
len
=
sizeof
(
ncpu
)
;
if
(
sysctl
(
mib
2
&
ncpu
&
len
NULL
0
)
=
=
-
1
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctl
(
HW_NCPU
)
"
)
;
goto
error
;
}
size
=
sizeof
(
cpu_time
)
;
if
(
sysctlbyname
(
"
kern
.
cp_times
"
&
cpu_time
&
size
NULL
0
)
=
=
-
1
)
{
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
kern
.
smp
.
maxcpus
'
)
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
ncpu
;
i
+
+
)
{
py_cputime
=
Py_BuildValue
(
"
(
ddddd
)
"
(
double
)
cpu_time
[
i
]
[
CP_USER
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
i
]
[
CP_NICE
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
i
]
[
CP_SYS
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
i
]
[
CP_IDLE
]
/
CLOCKS_PER_SEC
(
double
)
cpu_time
[
i
]
[
CP_INTR
]
/
CLOCKS_PER_SEC
)
;
if
(
!
py_cputime
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_cputime
)
)
goto
error
;
Py_DECREF
(
py_cputime
)
;
}
return
py_retlist
;
error
:
Py_XDECREF
(
py_cputime
)
;
Py_DECREF
(
py_retlist
)
;
return
NULL
;
}
PyObject
*
psutil_disk_io_counters
(
PyObject
*
self
PyObject
*
args
)
{
int
i
;
struct
statinfo
stats
;
PyObject
*
py_retdict
=
PyDict_New
(
)
;
PyObject
*
py_disk_info
=
NULL
;
if
(
py_retdict
=
=
NULL
)
return
NULL
;
if
(
devstat_checkversion
(
NULL
)
<
0
)
{
PyErr_Format
(
PyExc_RuntimeError
"
devstat_checkversion
(
)
syscall
failed
"
)
;
goto
error
;
}
stats
.
dinfo
=
(
struct
devinfo
*
)
malloc
(
sizeof
(
struct
devinfo
)
)
;
if
(
stats
.
dinfo
=
=
NULL
)
{
PyErr_NoMemory
(
)
;
goto
error
;
}
bzero
(
stats
.
dinfo
sizeof
(
struct
devinfo
)
)
;
if
(
devstat_getdevs
(
NULL
&
stats
)
=
=
-
1
)
{
PyErr_Format
(
PyExc_RuntimeError
"
devstat_getdevs
(
)
syscall
failed
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
stats
.
dinfo
-
>
numdevs
;
i
+
+
)
{
py_disk_info
=
NULL
;
struct
devstat
current
;
char
disk_name
[
128
]
;
current
=
stats
.
dinfo
-
>
devices
[
i
]
;
snprintf
(
disk_name
sizeof
(
disk_name
)
"
%
s
%
d
"
current
.
device_name
current
.
unit_number
)
;
py_disk_info
=
Py_BuildValue
(
"
(
KKKKLLL
)
"
current
.
operations
[
DEVSTAT_READ
]
current
.
operations
[
DEVSTAT_WRITE
]
current
.
bytes
[
DEVSTAT_READ
]
current
.
bytes
[
DEVSTAT_WRITE
]
(
long
long
)
PSUTIL_BT2MSEC
(
current
.
duration
[
DEVSTAT_READ
]
)
(
long
long
)
PSUTIL_BT2MSEC
(
current
.
duration
[
DEVSTAT_WRITE
]
)
(
long
long
)
PSUTIL_BT2MSEC
(
current
.
busy_time
)
)
;
if
(
!
py_disk_info
)
goto
error
;
if
(
PyDict_SetItemString
(
py_retdict
disk_name
py_disk_info
)
)
goto
error
;
Py_DECREF
(
py_disk_info
)
;
}
if
(
stats
.
dinfo
-
>
mem_ptr
)
free
(
stats
.
dinfo
-
>
mem_ptr
)
;
free
(
stats
.
dinfo
)
;
return
py_retdict
;
error
:
Py_XDECREF
(
py_disk_info
)
;
Py_DECREF
(
py_retdict
)
;
if
(
stats
.
dinfo
!
=
NULL
)
free
(
stats
.
dinfo
)
;
return
NULL
;
}
PyObject
*
psutil_proc_memory_maps
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
ptrwidth
;
int
i
cnt
;
char
addr
[
1000
]
;
char
perms
[
4
]
;
char
*
path
;
struct
kinfo_proc
kp
;
struct
kinfo_vmentry
*
freep
=
NULL
;
struct
kinfo_vmentry
*
kve
;
ptrwidth
=
2
*
sizeof
(
void
*
)
;
PyObject
*
py_tuple
=
NULL
;
PyObject
*
py_path
=
NULL
;
PyObject
*
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
l
"
&
pid
)
)
goto
error
;
if
(
psutil_kinfo_proc
(
pid
&
kp
)
=
=
-
1
)
goto
error
;
errno
=
0
;
freep
=
kinfo_getvmmap
(
pid
&
cnt
)
;
if
(
freep
=
=
NULL
)
{
psutil_raise_for_pid
(
pid
"
kinfo_getvmmap
(
)
"
)
;
goto
error
;
}
for
(
i
=
0
;
i
<
cnt
;
i
+
+
)
{
py_tuple
=
NULL
;
kve
=
&
freep
[
i
]
;
addr
[
0
]
=
'
\
0
'
;
perms
[
0
]
=
'
\
0
'
;
sprintf
(
addr
"
%
#
*
jx
-
%
#
*
jx
"
ptrwidth
(
uintmax_t
)
kve
-
>
kve_start
ptrwidth
(
uintmax_t
)
kve
-
>
kve_end
)
;
psutil_remove_spaces
(
addr
)
;
strlcat
(
perms
kve
-
>
kve_protection
&
KVME_PROT_READ
?
"
r
"
:
"
-
"
sizeof
(
perms
)
)
;
strlcat
(
perms
kve
-
>
kve_protection
&
KVME_PROT_WRITE
?
"
w
"
:
"
-
"
sizeof
(
perms
)
)
;
strlcat
(
perms
kve
-
>
kve_protection
&
KVME_PROT_EXEC
?
"
x
"
:
"
-
"
sizeof
(
perms
)
)
;
if
(
strlen
(
kve
-
>
kve_path
)
=
=
0
)
{
switch
(
kve
-
>
kve_type
)
{
case
KVME_TYPE_NONE
:
path
=
"
[
none
]
"
;
break
;
case
KVME_TYPE_DEFAULT
:
path
=
"
[
default
]
"
;
break
;
case
KVME_TYPE_VNODE
:
path
=
"
[
vnode
]
"
;
break
;
case
KVME_TYPE_SWAP
:
path
=
"
[
swap
]
"
;
break
;
case
KVME_TYPE_DEVICE
:
path
=
"
[
device
]
"
;
break
;
case
KVME_TYPE_PHYS
:
path
=
"
[
phys
]
"
;
break
;
case
KVME_TYPE_DEAD
:
path
=
"
[
dead
]
"
;
break
;
case
KVME_TYPE_SG
:
path
=
"
[
sg
]
"
;
break
;
case
KVME_TYPE_UNKNOWN
:
path
=
"
[
unknown
]
"
;
break
;
default
:
path
=
"
[
?
]
"
;
break
;
}
}
else
{
path
=
kve
-
>
kve_path
;
}
py_path
=
PyUnicode_DecodeFSDefault
(
path
)
;
if
(
!
py_path
)
goto
error
;
py_tuple
=
Py_BuildValue
(
"
ssOiiii
"
addr
perms
py_path
kve
-
>
kve_resident
kve
-
>
kve_private_resident
kve
-
>
kve_ref_count
kve
-
>
kve_shadow_count
)
;
if
(
!
py_tuple
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_tuple
)
)
goto
error
;
Py_DECREF
(
py_path
)
;
Py_DECREF
(
py_tuple
)
;
}
free
(
freep
)
;
return
py_retlist
;
error
:
Py_XDECREF
(
py_tuple
)
;
Py_XDECREF
(
py_path
)
;
Py_DECREF
(
py_retlist
)
;
if
(
freep
!
=
NULL
)
free
(
freep
)
;
return
NULL
;
}
PyObject
*
psutil_proc_cpu_affinity_get
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
ret
;
int
i
;
cpuset_t
mask
;
PyObject
*
py_retlist
;
PyObject
*
py_cpu_num
;
if
(
!
PyArg_ParseTuple
(
args
"
i
"
&
pid
)
)
return
NULL
;
ret
=
cpuset_getaffinity
(
CPU_LEVEL_WHICH
CPU_WHICH_PID
pid
sizeof
(
mask
)
&
mask
)
;
if
(
ret
!
=
0
)
return
PyErr_SetFromErrno
(
PyExc_OSError
)
;
py_retlist
=
PyList_New
(
0
)
;
if
(
py_retlist
=
=
NULL
)
return
NULL
;
for
(
i
=
0
;
i
<
CPU_SETSIZE
;
i
+
+
)
{
if
(
CPU_ISSET
(
i
&
mask
)
)
{
py_cpu_num
=
Py_BuildValue
(
"
i
"
i
)
;
if
(
py_cpu_num
=
=
NULL
)
goto
error
;
if
(
PyList_Append
(
py_retlist
py_cpu_num
)
)
goto
error
;
}
}
return
py_retlist
;
error
:
Py_XDECREF
(
py_cpu_num
)
;
Py_DECREF
(
py_retlist
)
;
return
NULL
;
}
PyObject
*
psutil_proc_cpu_affinity_set
(
PyObject
*
self
PyObject
*
args
)
{
long
pid
;
int
i
;
int
seq_len
;
int
ret
;
cpuset_t
cpu_set
;
PyObject
*
py_cpu_set
;
PyObject
*
py_cpu_seq
=
NULL
;
if
(
!
PyArg_ParseTuple
(
args
"
lO
"
&
pid
&
py_cpu_set
)
)
return
NULL
;
py_cpu_seq
=
PySequence_Fast
(
py_cpu_set
"
expected
a
sequence
or
integer
"
)
;
if
(
!
py_cpu_seq
)
return
NULL
;
seq_len
=
PySequence_Fast_GET_SIZE
(
py_cpu_seq
)
;
CPU_ZERO
(
&
cpu_set
)
;
for
(
i
=
0
;
i
<
seq_len
;
i
+
+
)
{
PyObject
*
item
=
PySequence_Fast_GET_ITEM
(
py_cpu_seq
i
)
;
#
if
PY_MAJOR_VERSION
>
=
3
long
value
=
PyLong_AsLong
(
item
)
;
#
else
long
value
=
PyInt_AsLong
(
item
)
;
#
endif
if
(
value
=
=
-
1
|
|
PyErr_Occurred
(
)
)
goto
error
;
CPU_SET
(
value
&
cpu_set
)
;
}
ret
=
cpuset_setaffinity
(
CPU_LEVEL_WHICH
CPU_WHICH_PID
pid
sizeof
(
cpu_set
)
&
cpu_set
)
;
if
(
ret
!
=
0
)
{
PyErr_SetFromErrno
(
PyExc_OSError
)
;
goto
error
;
}
Py_DECREF
(
py_cpu_seq
)
;
Py_RETURN_NONE
;
error
:
if
(
py_cpu_seq
!
=
NULL
)
Py_DECREF
(
py_cpu_seq
)
;
return
NULL
;
}
PyObject
*
psutil_cpu_stats
(
PyObject
*
self
PyObject
*
args
)
{
unsigned
int
v_soft
;
unsigned
int
v_intr
;
unsigned
int
v_syscall
;
unsigned
int
v_trap
;
unsigned
int
v_swtch
;
size_t
size
=
sizeof
(
v_soft
)
;
if
(
sysctlbyname
(
"
vm
.
stats
.
sys
.
v_soft
"
&
v_soft
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
sys
.
v_soft
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
sys
.
v_intr
"
&
v_intr
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
sys
.
v_intr
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
sys
.
v_syscall
"
&
v_syscall
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
sys
.
v_syscall
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
sys
.
v_trap
"
&
v_trap
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
sys
.
v_trap
'
)
"
)
;
}
if
(
sysctlbyname
(
"
vm
.
stats
.
sys
.
v_swtch
"
&
v_swtch
&
size
NULL
0
)
)
{
return
PyErr_SetFromOSErrnoWithSyscall
(
"
sysctlbyname
(
'
vm
.
stats
.
sys
.
v_swtch
'
)
"
)
;
}
return
Py_BuildValue
(
"
IIIII
"
v_swtch
v_intr
v_soft
v_syscall
v_trap
)
;
}
PyObject
*
psutil_sensors_battery
(
PyObject
*
self
PyObject
*
args
)
{
int
percent
;
int
minsleft
;
int
power_plugged
;
size_t
size
=
sizeof
(
percent
)
;
if
(
sysctlbyname
(
"
hw
.
acpi
.
battery
.
life
"
&
percent
&
size
NULL
0
)
)
goto
error
;
if
(
sysctlbyname
(
"
hw
.
acpi
.
battery
.
time
"
&
minsleft
&
size
NULL
0
)
)
goto
error
;
if
(
sysctlbyname
(
"
hw
.
acpi
.
acline
"
&
power_plugged
&
size
NULL
0
)
)
goto
error
;
return
Py_BuildValue
(
"
iii
"
percent
minsleft
power_plugged
)
;
error
:
if
(
errno
=
=
ENOENT
)
PyErr_SetString
(
PyExc_NotImplementedError
"
no
battery
"
)
;
else
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
NULL
;
}
PyObject
*
psutil_sensors_cpu_temperature
(
PyObject
*
self
PyObject
*
args
)
{
int
current
;
int
tjmax
;
int
core
;
char
sensor
[
26
]
;
size_t
size
=
sizeof
(
current
)
;
if
(
!
PyArg_ParseTuple
(
args
"
i
"
&
core
)
)
return
NULL
;
sprintf
(
sensor
"
dev
.
cpu
.
%
d
.
temperature
"
core
)
;
if
(
sysctlbyname
(
sensor
&
current
&
size
NULL
0
)
)
goto
error
;
current
=
DECIKELVIN_2_CELCIUS
(
current
)
;
sprintf
(
sensor
"
dev
.
cpu
.
%
d
.
coretemp
.
tjmax
"
core
)
;
if
(
sysctlbyname
(
sensor
&
tjmax
&
size
NULL
0
)
)
tjmax
=
0
;
tjmax
=
DECIKELVIN_2_CELCIUS
(
tjmax
)
;
return
Py_BuildValue
(
"
ii
"
current
tjmax
)
;
error
:
if
(
errno
=
=
ENOENT
)
PyErr_SetString
(
PyExc_NotImplementedError
"
no
temperature
sensors
"
)
;
else
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
NULL
;
}
PyObject
*
psutil_cpu_freq
(
PyObject
*
self
PyObject
*
args
)
{
int
current
;
int
core
;
char
sensor
[
26
]
;
char
available_freq_levels
[
1000
]
;
size_t
size
=
sizeof
(
current
)
;
if
(
!
PyArg_ParseTuple
(
args
"
i
"
&
core
)
)
return
NULL
;
sprintf
(
sensor
"
dev
.
cpu
.
%
d
.
freq
"
core
)
;
if
(
sysctlbyname
(
sensor
&
current
&
size
NULL
0
)
)
goto
error
;
size
=
sizeof
(
available_freq_levels
)
;
sprintf
(
sensor
"
dev
.
cpu
.
%
d
.
freq_levels
"
core
)
;
sysctlbyname
(
sensor
&
available_freq_levels
&
size
NULL
0
)
;
return
Py_BuildValue
(
"
is
"
current
available_freq_levels
)
;
error
:
if
(
errno
=
=
ENOENT
)
PyErr_SetString
(
PyExc_NotImplementedError
"
unable
to
read
frequency
"
)
;
else
PyErr_SetFromErrno
(
PyExc_OSError
)
;
return
NULL
;
}
