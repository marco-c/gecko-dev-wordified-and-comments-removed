from
__future__
import
annotations
from
collections
.
abc
import
Iterator
from
re
import
compile
from
.
.
model
import
Expression
VariableRef
printf
=
compile
(
    
r
"
%
(
?
:
(
[
1
-
9
]
)
\
|
\
(
(
[
\
w
.
]
+
)
\
)
)
?
[
-
#
+
0
]
?
[
0
-
9
.
]
*
(
?
:
(
[
Tt
]
[
A
-
Za
-
z
]
+
)
|
(
?
:
(
?
:
hh
?
|
ll
?
|
[
Lzjq
]
)
?
(
[
%
A
-
Za
-
z
]
)
)
)
"
)
def
parse_printf_pattern
(
src
:
str
|
None
)
-
>
Iterator
[
str
|
Expression
]
:
    
if
not
src
:
        
return
    
pos
=
0
    
for
m
in
printf
.
finditer
(
src
)
:
        
start
=
m
.
start
(
)
        
if
start
>
pos
:
            
yield
src
[
pos
:
start
]
        
source
=
m
[
0
]
        
[
argnum
argname
datetime
type
]
=
m
.
groups
(
)
        
pos
=
m
.
end
(
)
        
if
type
=
=
"
%
"
:
            
yield
Expression
(
"
%
"
attributes
=
{
"
source
"
:
source
}
)
            
continue
        
func
:
str
|
None
        
if
datetime
:
            
func
=
"
datetime
"
        
elif
type
in
{
"
c
"
"
C
"
"
s
"
"
S
"
}
:
            
func
=
"
string
"
        
elif
type
in
{
"
d
"
"
D
"
"
o
"
"
O
"
"
p
"
"
u
"
"
U
"
"
x
"
"
X
"
}
:
            
func
=
"
integer
"
        
elif
type
in
{
"
a
"
"
A
"
"
e
"
"
E
"
"
f
"
"
F
"
"
g
"
"
G
"
}
:
            
func
=
"
number
"
        
else
:
            
func
=
"
printf
"
        
yield
Expression
(
            
VariableRef
(
argname
or
(
"
arg
"
+
(
argnum
or
"
"
)
)
)
            
func
            
attributes
=
{
"
source
"
:
source
}
        
)
    
if
pos
<
len
(
src
)
:
        
yield
src
[
pos
:
]
