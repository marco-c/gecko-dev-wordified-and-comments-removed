from
__future__
import
annotations
from
collections
import
defaultdict
import
re
from
mdurl
.
_url
import
URL
PROTOCOL_PATTERN
=
re
.
compile
(
r
"
^
(
[
a
-
z0
-
9
.
+
-
]
+
:
)
"
flags
=
re
.
IGNORECASE
)
PORT_PATTERN
=
re
.
compile
(
r
"
:
[
0
-
9
]
*
"
)
SIMPLE_PATH_PATTERN
=
re
.
compile
(
r
"
^
(
/
/
?
(
?
!
/
)
[
^
?
\
s
]
*
)
(
\
?
[
^
\
s
]
*
)
?
"
)
DELIMS
=
(
"
<
"
"
>
"
'
"
'
"
"
"
"
"
\
r
"
"
\
n
"
"
\
t
"
)
UNWISE
=
(
"
{
"
"
}
"
"
|
"
"
\
\
"
"
^
"
"
"
)
+
DELIMS
AUTO_ESCAPE
=
(
"
'
"
)
+
UNWISE
NON_HOST_CHARS
=
(
"
%
"
"
/
"
"
?
"
"
;
"
"
#
"
)
+
AUTO_ESCAPE
HOST_ENDING_CHARS
=
(
"
/
"
"
?
"
"
#
"
)
HOSTNAME_MAX_LEN
=
255
HOSTNAME_PART_PATTERN
=
re
.
compile
(
r
"
^
[
+
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
"
)
HOSTNAME_PART_START
=
re
.
compile
(
r
"
^
(
[
+
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
)
(
.
*
)
"
)
HOSTLESS_PROTOCOL
=
defaultdict
(
    
bool
    
{
        
"
javascript
"
:
True
        
"
javascript
:
"
:
True
    
}
)
SLASHED_PROTOCOL
=
defaultdict
(
    
bool
    
{
        
"
http
"
:
True
        
"
https
"
:
True
        
"
ftp
"
:
True
        
"
gopher
"
:
True
        
"
file
"
:
True
        
"
http
:
"
:
True
        
"
https
:
"
:
True
        
"
ftp
:
"
:
True
        
"
gopher
:
"
:
True
        
"
file
:
"
:
True
    
}
)
class
MutableURL
:
    
def
__init__
(
self
)
-
>
None
:
        
self
.
protocol
:
str
|
None
=
None
        
self
.
slashes
:
bool
=
False
        
self
.
auth
:
str
|
None
=
None
        
self
.
port
:
str
|
None
=
None
        
self
.
hostname
:
str
|
None
=
None
        
self
.
hash
:
str
|
None
=
None
        
self
.
search
:
str
|
None
=
None
        
self
.
pathname
:
str
|
None
=
None
    
def
parse
(
self
url
:
str
slashes_denote_host
:
bool
)
-
>
"
MutableURL
"
:
        
lower_proto
=
"
"
        
slashes
=
False
        
rest
=
url
        
rest
=
rest
.
strip
(
)
        
if
not
slashes_denote_host
and
len
(
url
.
split
(
"
#
"
)
)
=
=
1
:
            
simple_path
=
SIMPLE_PATH_PATTERN
.
match
(
rest
)
            
if
simple_path
:
                
self
.
pathname
=
simple_path
.
group
(
1
)
                
if
simple_path
.
group
(
2
)
:
                    
self
.
search
=
simple_path
.
group
(
2
)
                
return
self
        
proto
=
"
"
        
proto_match
=
PROTOCOL_PATTERN
.
match
(
rest
)
        
if
proto_match
:
            
proto
=
proto_match
.
group
(
)
            
lower_proto
=
proto
.
lower
(
)
            
self
.
protocol
=
proto
            
rest
=
rest
[
len
(
proto
)
:
]
        
if
slashes_denote_host
or
proto
or
re
.
search
(
r
"
^
/
/
[
^
/
]
+
[
^
/
]
+
"
rest
)
:
            
slashes
=
rest
.
startswith
(
"
/
/
"
)
            
if
slashes
and
not
(
proto
and
HOSTLESS_PROTOCOL
[
proto
]
)
:
                
rest
=
rest
[
2
:
]
                
self
.
slashes
=
True
        
if
not
HOSTLESS_PROTOCOL
[
proto
]
and
(
            
slashes
or
(
proto
and
not
SLASHED_PROTOCOL
[
proto
]
)
        
)
:
            
host_end
=
-
1
            
for
i
in
range
(
len
(
HOST_ENDING_CHARS
)
)
:
                
hec
=
rest
.
find
(
HOST_ENDING_CHARS
[
i
]
)
                
if
hec
!
=
-
1
and
(
host_end
=
=
-
1
or
hec
<
host_end
)
:
                    
host_end
=
hec
            
if
host_end
=
=
-
1
:
                
at_sign
=
rest
.
rfind
(
"
"
)
            
else
:
                
at_sign
=
rest
.
rfind
(
"
"
0
host_end
+
1
)
            
if
at_sign
!
=
-
1
:
                
auth
=
rest
[
:
at_sign
]
                
rest
=
rest
[
at_sign
+
1
:
]
                
self
.
auth
=
auth
            
host_end
=
-
1
            
for
i
in
range
(
len
(
NON_HOST_CHARS
)
)
:
                
hec
=
rest
.
find
(
NON_HOST_CHARS
[
i
]
)
                
if
hec
!
=
-
1
and
(
host_end
=
=
-
1
or
hec
<
host_end
)
:
                    
host_end
=
hec
            
if
host_end
=
=
-
1
:
                
host_end
=
len
(
rest
)
            
if
host_end
>
0
and
rest
[
host_end
-
1
]
=
=
"
:
"
:
                
host_end
-
=
1
            
host
=
rest
[
:
host_end
]
            
rest
=
rest
[
host_end
:
]
            
self
.
parse_host
(
host
)
            
self
.
hostname
=
self
.
hostname
or
"
"
            
ipv6_hostname
=
self
.
hostname
.
startswith
(
"
[
"
)
and
self
.
hostname
.
endswith
(
                
"
]
"
            
)
            
if
not
ipv6_hostname
:
                
hostparts
=
self
.
hostname
.
split
(
"
.
"
)
                
l
=
len
(
hostparts
)
                
i
=
0
                
while
i
<
l
:
                    
part
=
hostparts
[
i
]
                    
if
not
part
:
                        
i
+
=
1
                        
continue
                    
if
not
HOSTNAME_PART_PATTERN
.
search
(
part
)
:
                        
newpart
=
"
"
                        
k
=
len
(
part
)
                        
j
=
0
                        
while
j
<
k
:
                            
if
ord
(
part
[
j
]
)
>
127
:
                                
newpart
+
=
"
x
"
                            
else
:
                                
newpart
+
=
part
[
j
]
                            
j
+
=
1
                        
if
not
HOSTNAME_PART_PATTERN
.
search
(
newpart
)
:
                            
valid_parts
=
hostparts
[
:
i
]
                            
not_host
=
hostparts
[
i
+
1
:
]
                            
bit
=
HOSTNAME_PART_START
.
search
(
part
)
                            
if
bit
:
                                
valid_parts
.
append
(
bit
.
group
(
1
)
)
                                
not_host
.
insert
(
0
bit
.
group
(
2
)
)
                            
if
not_host
:
                                
rest
=
"
.
"
.
join
(
not_host
)
+
rest
                            
self
.
hostname
=
"
.
"
.
join
(
valid_parts
)
                            
break
                    
i
+
=
1
            
if
len
(
self
.
hostname
)
>
HOSTNAME_MAX_LEN
:
                
self
.
hostname
=
"
"
            
if
ipv6_hostname
:
                
self
.
hostname
=
self
.
hostname
[
1
:
-
1
]
        
hash
=
rest
.
find
(
"
#
"
)
        
if
hash
!
=
-
1
:
            
self
.
hash
=
rest
[
hash
:
]
            
rest
=
rest
[
:
hash
]
        
qm
=
rest
.
find
(
"
?
"
)
        
if
qm
!
=
-
1
:
            
self
.
search
=
rest
[
qm
:
]
            
rest
=
rest
[
:
qm
]
        
if
rest
:
            
self
.
pathname
=
rest
        
if
SLASHED_PROTOCOL
[
lower_proto
]
and
self
.
hostname
and
not
self
.
pathname
:
            
self
.
pathname
=
"
"
        
return
self
    
def
parse_host
(
self
host
:
str
)
-
>
None
:
        
port_match
=
PORT_PATTERN
.
search
(
host
)
        
if
port_match
:
            
port
=
port_match
.
group
(
)
            
if
port
!
=
"
:
"
:
                
self
.
port
=
port
[
1
:
]
            
host
=
host
[
:
-
len
(
port
)
]
        
if
host
:
            
self
.
hostname
=
host
def
url_parse
(
url
:
URL
|
str
*
slashes_denote_host
:
bool
=
False
)
-
>
URL
:
    
if
isinstance
(
url
URL
)
:
        
return
url
    
u
=
MutableURL
(
)
    
u
.
parse
(
url
slashes_denote_host
)
    
return
URL
(
        
u
.
protocol
u
.
slashes
u
.
auth
u
.
port
u
.
hostname
u
.
hash
u
.
search
u
.
pathname
    
)
