"
"
"
Support
for
running
jobs
that
are
invoked
via
the
run
-
task
script
.
"
"
"
import
os
import
attr
from
voluptuous
import
Any
Optional
Required
from
taskgraph
.
transforms
.
job
import
run_job_using
from
taskgraph
.
transforms
.
job
.
common
import
support_vcs_checkout
from
taskgraph
.
transforms
.
task
import
taskref_or_string
from
taskgraph
.
util
import
path
taskcluster
from
taskgraph
.
util
.
schema
import
Schema
EXEC_COMMANDS
=
{
    
"
bash
"
:
[
"
bash
"
"
-
cx
"
]
    
"
powershell
"
:
[
"
powershell
.
exe
"
"
-
ExecutionPolicy
"
"
Bypass
"
]
}
run_task_schema
=
Schema
(
    
{
        
Required
(
"
using
"
)
:
"
run
-
task
"
        
Required
(
"
cache
-
dotcache
"
)
:
bool
        
Optional
(
"
use
-
caches
"
)
:
bool
        
Required
(
"
checkout
"
)
:
Any
(
bool
{
str
:
dict
}
)
        
Optional
(
            
"
cwd
"
            
description
=
"
Path
to
run
command
in
.
If
a
checkout
is
present
the
path
"
            
"
to
the
checkout
will
be
interpolated
with
the
key
checkout
"
        
)
:
str
        
Required
(
"
sparse
-
profile
"
)
:
Any
(
str
None
)
        
Required
(
"
command
"
)
:
Any
(
[
taskref_or_string
]
taskref_or_string
)
        
Optional
(
"
command
-
context
"
)
:
dict
        
Optional
(
"
exec
-
with
"
)
:
Any
(
*
list
(
EXEC_COMMANDS
)
)
        
Required
(
"
workdir
"
)
:
str
        
Optional
(
"
run
-
as
-
root
"
)
:
bool
    
}
)
def
common_setup
(
config
job
taskdesc
command
)
:
    
run
=
job
[
"
run
"
]
    
if
run
[
"
checkout
"
]
:
        
repo_configs
=
config
.
repo_configs
        
if
len
(
repo_configs
)
>
1
and
run
[
"
checkout
"
]
is
True
:
            
raise
Exception
(
"
Must
explicitly
specify
checkouts
with
multiple
repos
.
"
)
        
elif
run
[
"
checkout
"
]
is
not
True
:
            
repo_configs
=
{
                
repo
:
attr
.
evolve
(
repo_configs
[
repo
]
*
*
config
)
                
for
(
repo
config
)
in
run
[
"
checkout
"
]
.
items
(
)
            
}
        
support_vcs_checkout
(
            
config
            
job
            
taskdesc
            
repo_configs
=
repo_configs
            
sparse
=
bool
(
run
[
"
sparse
-
profile
"
]
)
        
)
        
vcs_path
=
taskdesc
[
"
worker
"
]
[
"
env
"
]
[
"
VCS_PATH
"
]
        
for
repo_config
in
repo_configs
.
values
(
)
:
            
checkout_path
=
path
.
join
(
vcs_path
repo_config
.
path
)
            
command
.
append
(
f
"
-
-
{
repo_config
.
prefix
}
-
checkout
=
{
checkout_path
}
"
)
        
if
run
[
"
sparse
-
profile
"
]
:
            
command
.
append
(
                
"
-
-
{
}
-
sparse
-
profile
=
build
/
sparse
-
profiles
/
{
}
"
.
format
(
                    
repo_config
.
prefix
                    
run
[
"
sparse
-
profile
"
]
                
)
            
)
        
if
"
cwd
"
in
run
:
            
run
[
"
cwd
"
]
=
path
.
normpath
(
run
[
"
cwd
"
]
.
format
(
checkout
=
vcs_path
)
)
    
elif
"
cwd
"
in
run
and
"
{
checkout
}
"
in
run
[
"
cwd
"
]
:
        
raise
Exception
(
            
"
Found
{
{
checkout
}
}
interpolation
in
cwd
for
task
{
name
}
"
            
"
but
the
task
doesn
'
t
have
a
checkout
:
{
cwd
}
"
.
format
(
                
cwd
=
run
[
"
cwd
"
]
name
=
job
.
get
(
"
name
"
job
.
get
(
"
label
"
)
)
            
)
        
)
    
if
"
cwd
"
in
run
:
        
command
.
extend
(
(
"
-
-
task
-
cwd
"
run
[
"
cwd
"
]
)
)
    
taskdesc
[
"
worker
"
]
.
setdefault
(
"
env
"
{
}
)
[
"
MOZ_SCM_LEVEL
"
]
=
config
.
params
[
"
level
"
]
worker_defaults
=
{
    
"
cache
-
dotcache
"
:
False
    
"
checkout
"
:
True
    
"
sparse
-
profile
"
:
None
    
"
run
-
as
-
root
"
:
False
}
def
script_url
(
config
script
)
:
    
if
"
MOZ_AUTOMATION
"
in
os
.
environ
and
"
TASK_ID
"
not
in
os
.
environ
:
        
raise
Exception
(
"
TASK_ID
must
be
defined
to
use
run
-
task
on
generic
-
worker
"
)
    
task_id
=
os
.
environ
.
get
(
"
TASK_ID
"
"
<
TASK_ID
>
"
)
    
tc_url
=
taskcluster
.
get_root_url
(
False
)
    
return
f
"
{
tc_url
}
/
api
/
queue
/
v1
/
task
/
{
task_id
}
/
artifacts
/
public
/
{
script
}
"
run_job_using
(
    
"
docker
-
worker
"
"
run
-
task
"
schema
=
run_task_schema
defaults
=
worker_defaults
)
def
docker_worker_run_task
(
config
job
taskdesc
)
:
    
run
=
job
[
"
run
"
]
    
worker
=
taskdesc
[
"
worker
"
]
=
job
[
"
worker
"
]
    
command
=
[
"
/
usr
/
local
/
bin
/
run
-
task
"
]
    
common_setup
(
config
job
taskdesc
command
)
    
if
run
.
get
(
"
cache
-
dotcache
"
)
:
        
worker
[
"
caches
"
]
.
append
(
            
{
                
"
type
"
:
"
persistent
"
                
"
name
"
:
"
{
project
}
-
dotcache
"
.
format
(
*
*
config
.
params
)
                
"
mount
-
point
"
:
"
{
workdir
}
/
.
cache
"
.
format
(
*
*
run
)
                
"
skip
-
untrusted
"
:
True
            
}
        
)
    
run_command
=
run
[
"
command
"
]
    
command_context
=
run
.
get
(
"
command
-
context
"
)
    
if
command_context
:
        
run_command
=
run_command
.
format
(
*
*
command_context
)
    
if
isinstance
(
run_command
str
)
or
isinstance
(
run_command
dict
)
:
        
exec_cmd
=
EXEC_COMMANDS
[
run
.
pop
(
"
exec
-
with
"
"
bash
"
)
]
        
run_command
=
exec_cmd
+
[
run_command
]
    
if
run
[
"
run
-
as
-
root
"
]
:
        
command
.
extend
(
(
"
-
-
user
"
"
root
"
"
-
-
group
"
"
root
"
)
)
    
command
.
append
(
"
-
-
"
)
    
command
.
extend
(
run_command
)
    
worker
[
"
command
"
]
=
command
run_job_using
(
    
"
generic
-
worker
"
"
run
-
task
"
schema
=
run_task_schema
defaults
=
worker_defaults
)
def
generic_worker_run_task
(
config
job
taskdesc
)
:
    
run
=
job
[
"
run
"
]
    
worker
=
taskdesc
[
"
worker
"
]
=
job
[
"
worker
"
]
    
is_win
=
worker
[
"
os
"
]
=
=
"
windows
"
    
is_mac
=
worker
[
"
os
"
]
=
=
"
macosx
"
    
is_bitbar
=
worker
[
"
os
"
]
=
=
"
linux
-
bitbar
"
    
if
is_win
:
        
command
=
[
"
C
:
/
mozilla
-
build
/
python3
/
python3
.
exe
"
"
run
-
task
"
]
    
elif
is_mac
:
        
command
=
[
"
/
tools
/
python36
/
bin
/
python3
"
"
run
-
task
"
]
    
else
:
        
command
=
[
"
.
/
run
-
task
"
]
    
common_setup
(
config
job
taskdesc
command
)
    
worker
.
setdefault
(
"
mounts
"
[
]
)
    
if
run
.
get
(
"
cache
-
dotcache
"
)
:
        
worker
[
"
mounts
"
]
.
append
(
            
{
                
"
cache
-
name
"
:
"
{
project
}
-
dotcache
"
.
format
(
*
*
config
.
params
)
                
"
directory
"
:
"
{
workdir
}
/
.
cache
"
.
format
(
*
*
run
)
            
}
        
)
    
worker
[
"
mounts
"
]
.
append
(
        
{
            
"
content
"
:
{
                
"
url
"
:
script_url
(
config
"
run
-
task
"
)
            
}
            
"
file
"
:
"
.
/
run
-
task
"
        
}
    
)
    
if
worker
.
get
(
"
env
"
{
}
)
.
get
(
"
MOZ_FETCHES
"
)
:
        
worker
[
"
mounts
"
]
.
append
(
            
{
                
"
content
"
:
{
                    
"
url
"
:
script_url
(
config
"
fetch
-
content
"
)
                
}
                
"
file
"
:
"
.
/
fetch
-
content
"
            
}
        
)
    
run_command
=
run
[
"
command
"
]
    
if
isinstance
(
run_command
str
)
:
        
if
is_win
:
            
run_command
=
f
'
"
{
run_command
}
"
'
        
exec_cmd
=
EXEC_COMMANDS
[
run
.
pop
(
"
exec
-
with
"
"
bash
"
)
]
        
run_command
=
exec_cmd
+
[
run_command
]
    
command_context
=
run
.
get
(
"
command
-
context
"
)
    
if
command_context
:
        
for
i
in
range
(
len
(
run_command
)
)
:
            
run_command
[
i
]
=
run_command
[
i
]
.
format
(
*
*
command_context
)
    
if
run
[
"
run
-
as
-
root
"
]
:
        
command
.
extend
(
(
"
-
-
user
"
"
root
"
"
-
-
group
"
"
root
"
)
)
    
command
.
append
(
"
-
-
"
)
    
if
is_bitbar
:
        
command
.
append
(
"
/
builds
/
taskcluster
/
script
.
py
"
)
    
command
.
extend
(
run_command
)
    
if
is_win
:
        
worker
[
"
command
"
]
=
[
"
"
.
join
(
command
)
]
    
else
:
        
worker
[
"
command
"
]
=
[
            
[
"
chmod
"
"
+
x
"
"
run
-
task
"
]
            
command
        
]
