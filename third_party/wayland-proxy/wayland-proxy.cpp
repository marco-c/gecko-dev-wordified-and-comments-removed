#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
sys
/
ioctl
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
sys
/
un
.
h
>
#
include
<
spawn
.
h
>
#
include
<
poll
.
h
>
#
include
<
vector
>
#
include
<
cerrno
>
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
include
<
memory
>
#
include
<
cassert
>
#
include
<
pthread
.
h
>
#
include
<
sched
.
h
>
#
include
"
wayland
-
proxy
.
h
"
#
define
MAX_LIBWAY_FDS
28
#
define
MAX_DATA_SIZE
4096
#
define
POLL_TIMEOUT
30000
bool
sPrintInfo
=
false
;
void
Print
(
const
char
*
aFormat
.
.
.
)
{
if
(
!
sPrintInfo
)
{
return
;
}
va_list
args
;
va_start
(
args
aFormat
)
;
vfprintf
(
stderr
aFormat
args
)
;
va_end
(
args
)
;
}
void
Warning
(
const
char
*
aOperation
bool
aPrintErrno
=
true
)
{
fprintf
(
stderr
"
Warning
:
%
s
:
%
s
\
n
"
aOperation
aPrintErrno
?
strerror
(
errno
)
:
"
"
)
;
}
void
Error
(
const
char
*
aOperation
bool
aPrintErrno
=
true
)
{
fprintf
(
stderr
"
Error
:
%
s
:
%
s
\
n
"
aOperation
aPrintErrno
?
strerror
(
errno
)
:
"
"
)
;
}
class
WaylandMessage
{
public
:
bool
Write
(
int
aSocket
)
;
bool
Loaded
(
)
const
{
return
mLoaded
&
&
(
mFds
.
size
(
)
|
|
mData
.
size
(
)
)
;
}
bool
Failed
(
)
const
{
return
mFailed
;
}
explicit
WaylandMessage
(
int
aSocket
)
{
Read
(
aSocket
)
;
}
~
WaylandMessage
(
)
;
private
:
bool
Read
(
int
aSocket
)
;
private
:
bool
mLoaded
=
false
;
bool
mFailed
=
false
;
std
:
:
vector
<
int
>
mFds
;
std
:
:
vector
<
unsigned
char
>
mData
;
}
;
class
ProxiedConnection
{
public
:
bool
Init
(
int
aChildSocket
char
*
aWaylandDisplay
)
;
bool
IsConnected
(
)
{
return
mCompositorConnected
;
}
struct
pollfd
*
AddToPollFd
(
struct
pollfd
*
aPfds
)
;
struct
pollfd
*
LoadPollFd
(
struct
pollfd
*
aPfds
)
;
bool
Process
(
)
;
~
ProxiedConnection
(
)
;
private
:
bool
ConnectToCompositor
(
)
;
bool
TransferOrQueue
(
int
aSourceSocket
int
aSourcePollFlags
int
aDestSocket
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
*
aMessageQueue
)
;
bool
FlushQueue
(
int
aDestSocket
int
aDestPollFlags
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
&
aMessageQueue
)
;
char
*
mWaylandDisplay
=
nullptr
;
bool
mCompositorConnected
=
false
;
bool
mFailed
=
false
;
int
mCompositorSocket
=
-
1
;
int
mCompositorFlags
=
0
;
int
mApplicationSocket
=
-
1
;
int
mApplicationFlags
=
0
;
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
mToCompositorQueue
;
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
mToApplicationQueue
;
}
;
WaylandMessage
:
:
~
WaylandMessage
(
)
{
for
(
auto
const
fd
:
mFds
)
{
close
(
fd
)
;
}
}
bool
WaylandMessage
:
:
Read
(
int
aSocket
)
{
assert
(
!
mLoaded
&
&
!
mFailed
)
;
mData
.
resize
(
MAX_DATA_SIZE
)
;
struct
msghdr
msg
=
{
0
}
;
struct
iovec
iov
=
{
mData
.
data
(
)
mData
.
size
(
)
}
;
msg
.
msg_iov
=
&
iov
;
msg
.
msg_iovlen
=
1
;
char
cmsgdata
[
(
CMSG_LEN
(
MAX_LIBWAY_FDS
*
sizeof
(
int32_t
)
)
)
]
=
{
0
}
;
msg
.
msg_control
=
&
cmsgdata
;
msg
.
msg_controllen
=
sizeof
(
cmsgdata
)
;
ssize_t
ret
=
recvmsg
(
aSocket
&
msg
MSG_CMSG_CLOEXEC
|
MSG_DONTWAIT
)
;
if
(
msg
.
msg_flags
&
(
MSG_CTRUNC
|
MSG_TRUNC
)
)
{
Error
(
"
WaylandMessage
:
:
Read
(
)
data
truncated
small
buffer
?
"
)
;
mFailed
=
true
;
return
false
;
}
if
(
ret
<
1
)
{
switch
(
errno
)
{
case
EAGAIN
:
case
EINTR
:
Print
(
"
WaylandMessage
:
:
Write
(
)
failed
%
s
\
n
"
strerror
(
errno
)
)
;
return
false
;
default
:
Error
(
"
WaylandMessage
:
:
Write
(
)
failed
"
)
;
mFailed
=
true
;
return
false
;
}
}
mData
.
resize
(
ret
)
;
struct
cmsghdr
*
header
=
CMSG_FIRSTHDR
(
&
msg
)
;
while
(
header
)
{
struct
cmsghdr
*
next
=
CMSG_NXTHDR
(
&
msg
header
)
;
if
(
header
-
>
cmsg_level
!
=
SOL_SOCKET
|
|
header
-
>
cmsg_type
!
=
SCM_RIGHTS
)
{
header
=
next
;
continue
;
}
int
*
data
=
(
int
*
)
CMSG_DATA
(
header
)
;
int
filenum
=
(
int
)
(
(
header
-
>
cmsg_len
-
CMSG_LEN
(
0
)
)
/
sizeof
(
int
)
)
;
for
(
int
i
=
0
;
i
<
filenum
;
i
+
+
)
{
#
ifdef
DEBUG
int
flags
=
fcntl
(
data
[
i
]
F_GETFL
0
)
;
if
(
flags
=
=
-
1
&
&
errno
=
=
EBADF
)
{
Error
(
"
WaylandMessage
:
:
Read
(
)
invalid
fd
"
)
;
}
#
endif
mFds
.
push_back
(
data
[
i
]
)
;
}
header
=
next
;
}
mLoaded
=
true
;
return
true
;
}
bool
WaylandMessage
:
:
Write
(
int
aSocket
)
{
if
(
!
mLoaded
|
|
mFailed
)
{
return
false
;
}
struct
msghdr
msg
=
{
0
}
;
struct
iovec
iov
=
{
mData
.
data
(
)
mData
.
size
(
)
}
;
msg
.
msg_iov
=
&
iov
;
msg
.
msg_iovlen
=
1
;
union
{
char
buf
[
CMSG_SPACE
(
sizeof
(
int
)
*
MAX_LIBWAY_FDS
)
]
;
struct
cmsghdr
align
;
}
cmsgu
;
memset
(
cmsgu
.
buf
0
sizeof
(
cmsgu
.
buf
)
)
;
int
filenum
=
mFds
.
size
(
)
;
if
(
filenum
)
{
if
(
filenum
>
=
MAX_LIBWAY_FDS
)
{
Error
(
"
WaylandMessage
:
:
Write
(
)
too
many
files
to
send
\
n
"
false
)
;
return
false
;
}
#
ifdef
DEBUG
for
(
int
i
=
0
;
i
<
filenum
;
i
+
+
)
{
int
flags
=
fcntl
(
mFds
[
i
]
F_GETFL
0
)
;
if
(
flags
=
=
-
1
&
&
errno
=
=
EBADF
)
{
Error
(
"
WaylandMessage
:
:
Write
(
)
invalid
fd
\
n
"
)
;
}
}
#
endif
msg
.
msg_control
=
cmsgu
.
buf
;
msg
.
msg_controllen
=
CMSG_SPACE
(
filenum
*
sizeof
(
int
)
)
;
struct
cmsghdr
*
cmsg
=
CMSG_FIRSTHDR
(
&
msg
)
;
cmsg
-
>
cmsg_level
=
SOL_SOCKET
;
cmsg
-
>
cmsg_type
=
SCM_RIGHTS
;
cmsg
-
>
cmsg_len
=
CMSG_LEN
(
filenum
*
sizeof
(
int
)
)
;
memcpy
(
CMSG_DATA
(
cmsg
)
mFds
.
data
(
)
filenum
*
sizeof
(
int
)
)
;
}
ssize_t
ret
=
sendmsg
(
aSocket
&
msg
MSG_CMSG_CLOEXEC
|
MSG_DONTWAIT
)
;
if
(
ret
<
1
)
{
switch
(
errno
)
{
case
EAGAIN
:
case
EINTR
:
Print
(
"
WaylandMessage
:
:
Write
(
)
failed
%
s
\
n
"
strerror
(
errno
)
)
;
return
false
;
default
:
Warning
(
"
WaylandMessage
:
:
Write
(
)
failed
"
)
;
mFailed
=
true
;
return
false
;
}
}
if
(
ret
!
=
(
ssize_t
)
mData
.
size
(
)
)
{
Print
(
"
WaylandMessage
:
:
Write
(
)
failed
to
write
all
data
!
(
%
d
vs
.
%
d
)
\
n
"
ret
mData
.
size
(
)
)
;
}
return
true
;
}
ProxiedConnection
:
:
~
ProxiedConnection
(
)
{
if
(
mCompositorSocket
!
=
-
1
)
{
close
(
mCompositorSocket
)
;
}
if
(
mApplicationSocket
!
=
-
1
)
{
close
(
mApplicationSocket
)
;
}
}
bool
ProxiedConnection
:
:
Init
(
int
aApplicationSocket
char
*
aWaylandDisplay
)
{
mWaylandDisplay
=
aWaylandDisplay
;
mApplicationSocket
=
aApplicationSocket
;
mCompositorSocket
=
socket
(
AF_UNIX
SOCK_STREAM
|
SOCK_NONBLOCK
|
SOCK_CLOEXEC
0
)
;
if
(
mCompositorSocket
=
=
-
1
)
{
Error
(
"
WaylandProxy
:
ProxiedConnection
:
:
Init
(
)
socket
(
)
"
)
;
}
bool
ret
=
mApplicationSocket
>
=
0
&
&
mCompositorSocket
>
=
0
;
Print
(
"
WaylandProxy
:
ProxiedConnection
:
:
Init
(
)
%
s
\
n
"
ret
?
"
OK
"
:
"
FAILED
"
)
;
return
ret
;
}
struct
pollfd
*
ProxiedConnection
:
:
AddToPollFd
(
struct
pollfd
*
aPfds
)
{
aPfds
-
>
fd
=
mApplicationSocket
;
aPfds
-
>
events
=
POLLIN
;
if
(
mCompositorConnected
&
&
!
mToApplicationQueue
.
empty
(
)
)
{
aPfds
-
>
events
|
=
POLLOUT
;
}
aPfds
+
+
;
aPfds
-
>
fd
=
mCompositorSocket
;
aPfds
-
>
events
=
0
;
if
(
!
mCompositorConnected
|
|
!
mToCompositorQueue
.
empty
(
)
)
{
aPfds
-
>
events
|
=
POLLOUT
;
}
if
(
mCompositorConnected
)
{
aPfds
-
>
events
|
=
POLLIN
;
}
aPfds
+
+
;
return
aPfds
;
}
struct
pollfd
*
ProxiedConnection
:
:
LoadPollFd
(
struct
pollfd
*
aPfds
)
{
if
(
aPfds
-
>
fd
!
=
mApplicationSocket
)
{
return
aPfds
;
}
mApplicationFlags
=
aPfds
-
>
revents
;
aPfds
+
+
;
mCompositorFlags
=
aPfds
-
>
revents
;
aPfds
+
+
;
return
aPfds
;
}
bool
ProxiedConnection
:
:
ConnectToCompositor
(
)
{
if
(
!
(
mCompositorFlags
&
POLLOUT
)
)
{
return
true
;
}
struct
sockaddr_un
addr
=
{
}
;
addr
.
sun_family
=
AF_UNIX
;
strcpy
(
addr
.
sun_path
mWaylandDisplay
)
;
mCompositorConnected
=
connect
(
mCompositorSocket
(
const
struct
sockaddr
*
)
&
addr
sizeof
(
struct
sockaddr_un
)
)
!
=
-
1
;
if
(
!
mCompositorConnected
)
{
switch
(
errno
)
{
case
EAGAIN
:
case
EALREADY
:
case
ECONNREFUSED
:
case
EINPROGRESS
:
case
EINTR
:
case
EISCONN
:
case
ETIMEDOUT
:
Warning
(
"
ConnectToCompositor
(
)
try
again
"
)
;
return
true
;
default
:
Error
(
"
ConnectToCompositor
(
)
connect
(
)
"
)
;
return
false
;
}
}
return
true
;
}
bool
ProxiedConnection
:
:
TransferOrQueue
(
int
aSourceSocket
int
aSourcePollFlags
int
aDestSocket
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
*
aMessageQueue
)
{
if
(
!
(
aSourcePollFlags
&
POLLIN
)
)
{
return
true
;
}
while
(
1
)
{
int
availableData
=
0
;
if
(
ioctl
(
aSourceSocket
FIONREAD
&
availableData
)
<
0
)
{
Warning
(
"
ProxiedConnection
:
:
TransferOrQueue
(
)
broken
source
socket
%
s
\
n
"
)
;
return
false
;
}
if
(
availableData
=
=
0
)
{
return
true
;
}
auto
message
=
std
:
:
make_unique
<
WaylandMessage
>
(
aSourceSocket
)
;
if
(
message
-
>
Failed
(
)
)
{
return
false
;
}
if
(
!
message
-
>
Loaded
(
)
)
{
return
true
;
}
if
(
!
message
-
>
Write
(
aDestSocket
)
)
{
if
(
message
-
>
Failed
(
)
)
{
return
false
;
}
aMessageQueue
-
>
push_back
(
std
:
:
move
(
message
)
)
;
}
}
}
bool
ProxiedConnection
:
:
FlushQueue
(
int
aDestSocket
int
aDestPollFlags
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
&
aMessageQueue
)
{
if
(
!
(
aDestPollFlags
&
POLLOUT
)
|
|
aMessageQueue
.
empty
(
)
)
{
return
true
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
WaylandMessage
>
>
:
:
iterator
message
;
for
(
message
=
aMessageQueue
.
begin
(
)
;
message
!
=
aMessageQueue
.
end
(
)
;
)
{
if
(
!
(
*
message
)
-
>
Write
(
aDestSocket
)
)
{
if
(
(
*
message
)
-
>
Failed
(
)
)
{
return
false
;
}
break
;
}
message
+
+
;
}
if
(
message
!
=
aMessageQueue
.
begin
(
)
)
{
aMessageQueue
.
erase
(
aMessageQueue
.
begin
(
)
message
)
;
}
return
true
;
}
bool
ProxiedConnection
:
:
Process
(
)
{
if
(
mFailed
)
{
return
false
;
}
if
(
mApplicationFlags
&
(
POLLHUP
|
POLLERR
)
)
{
return
false
;
}
if
(
mCompositorConnected
)
{
if
(
mCompositorFlags
&
(
POLLHUP
|
POLLERR
)
)
{
return
false
;
}
}
else
{
if
(
!
ConnectToCompositor
(
)
)
{
Print
(
"
Failed
to
connect
to
compositor
\
n
"
)
;
return
false
;
}
if
(
!
mCompositorConnected
)
{
return
true
;
}
}
mFailed
=
!
TransferOrQueue
(
mCompositorSocket
mCompositorFlags
mApplicationSocket
&
mToApplicationQueue
)
|
|
!
TransferOrQueue
(
mApplicationSocket
mApplicationFlags
mCompositorSocket
&
mToCompositorQueue
)
|
|
!
FlushQueue
(
mCompositorSocket
mCompositorFlags
mToCompositorQueue
)
|
|
!
FlushQueue
(
mApplicationSocket
mApplicationFlags
mToApplicationQueue
)
;
return
!
mFailed
;
}
bool
WaylandProxy
:
:
SetupWaylandDisplays
(
)
{
char
*
waylandDisplay
=
getenv
(
"
WAYLAND_DISPLAY
"
)
;
if
(
!
waylandDisplay
)
{
Error
(
"
Init
(
)
Missing
Wayland
display
WAYLAND_DISPLAY
is
empty
.
"
false
)
;
return
false
;
}
char
*
XDGRuntimeDir
=
getenv
(
"
XDG_RUNTIME_DIR
"
)
;
if
(
!
XDGRuntimeDir
)
{
Error
(
"
Init
(
)
Missing
XDG_RUNTIME_DIR
"
false
)
;
return
false
;
}
if
(
waylandDisplay
[
0
]
=
=
'
/
'
)
{
if
(
strlen
(
mWaylandDisplay
)
>
=
sMaxDisplayNameLen
)
{
Error
(
"
Init
(
)
WAYLAND_DISPLAY
is
too
large
.
"
false
)
;
return
false
;
}
strcpy
(
mWaylandDisplay
waylandDisplay
)
;
}
else
{
int
ret
=
snprintf
(
mWaylandDisplay
sMaxDisplayNameLen
"
%
s
/
%
s
"
XDGRuntimeDir
waylandDisplay
)
;
if
(
ret
<
0
|
|
ret
>
=
sMaxDisplayNameLen
)
{
Error
(
"
Init
(
)
WAYLAND_DISPLAY
/
XDG_RUNTIME_DIR
is
too
large
.
"
false
)
;
return
false
;
}
}
int
ret
=
snprintf
(
mWaylandProxy
sMaxDisplayNameLen
"
%
s
/
wayland
-
proxy
-
%
d
"
XDGRuntimeDir
getpid
(
)
)
;
if
(
ret
<
0
|
|
ret
>
=
sMaxDisplayNameLen
)
{
Error
(
"
Init
(
)
WAYLAND_DISPLAY
/
XDG_RUNTIME_DIR
is
too
large
.
"
false
)
;
return
false
;
}
Info
(
"
SetupWaylandDisplays
(
)
Wayland
'
%
s
'
proxy
'
%
s
'
\
n
"
mWaylandDisplay
mWaylandProxy
)
;
return
true
;
}
bool
WaylandProxy
:
:
StartProxyServer
(
)
{
mProxyServerSocket
=
socket
(
AF_UNIX
SOCK_STREAM
|
SOCK_NONBLOCK
|
SOCK_CLOEXEC
0
)
;
if
(
mProxyServerSocket
=
=
-
1
)
{
Error
(
"
StartProxyServer
(
)
:
failed
to
create
socket
"
)
;
return
false
;
}
struct
sockaddr_un
serverName
=
{
0
}
;
serverName
.
sun_family
=
AF_UNIX
;
strcpy
(
serverName
.
sun_path
mWaylandProxy
)
;
if
(
bind
(
mProxyServerSocket
(
struct
sockaddr
*
)
&
serverName
sizeof
(
serverName
)
)
=
=
-
1
)
{
Error
(
"
StartProxyServer
(
)
:
bind
(
)
error
"
)
;
return
false
;
}
if
(
listen
(
mProxyServerSocket
128
)
=
=
-
1
)
{
Error
(
"
StartProxyServer
(
)
:
listen
(
)
error
"
)
;
return
false
;
}
return
true
;
}
bool
WaylandProxy
:
:
Init
(
)
{
Info
(
"
Init
(
)
\
n
"
)
;
if
(
!
SetupWaylandDisplays
(
)
)
{
return
false
;
}
if
(
!
StartProxyServer
(
)
)
{
return
false
;
}
Info
(
"
Init
(
)
finished
\
n
"
)
;
return
true
;
}
void
WaylandProxy
:
:
SetWaylandProxyDisplay
(
)
{
Info
(
"
SetWaylandProxyDisplay
(
)
WAYLAND_DISPLAY
%
s
\
n
"
mWaylandDisplay
)
;
setenv
(
"
WAYLAND_DISPLAY
"
mWaylandProxy
true
)
;
}
void
WaylandProxy
:
:
SetWaylandDisplay
(
)
{
Info
(
"
SetWaylandDisplay
(
)
WAYLAND_DISPLAY
%
s
\
n
"
mWaylandDisplay
)
;
setenv
(
"
WAYLAND_DISPLAY
"
mWaylandDisplay
true
)
;
unlink
(
mWaylandProxy
)
;
}
bool
WaylandProxy
:
:
IsChildAppTerminated
(
)
{
if
(
!
mApplicationPID
)
{
return
false
;
}
int
status
=
0
;
int
ret
=
waitpid
(
mApplicationPID
&
status
WNOHANG
|
WUNTRACED
|
WCONTINUED
)
;
if
(
ret
=
=
0
)
{
return
false
;
}
if
(
ret
=
=
mApplicationPID
)
{
return
true
;
}
bool
terminate
=
(
errno
=
=
ECHILD
)
;
Error
(
"
IsChildAppTerminated
:
waitpid
(
)
error
"
)
;
return
terminate
;
}
bool
WaylandProxy
:
:
PollConnections
(
)
{
int
nfds_max
=
mConnections
.
size
(
)
*
2
+
1
;
struct
pollfd
pollfds
[
nfds_max
]
;
struct
pollfd
*
addedPollfd
=
pollfds
;
for
(
auto
const
&
connection
:
mConnections
)
{
addedPollfd
=
connection
-
>
AddToPollFd
(
addedPollfd
)
;
}
int
nfds
=
(
addedPollfd
-
pollfds
)
;
bool
addNewConnection
=
mConnections
.
empty
(
)
|
|
mConnections
.
back
(
)
-
>
IsConnected
(
)
;
if
(
addNewConnection
)
{
addedPollfd
-
>
fd
=
mProxyServerSocket
;
addedPollfd
-
>
events
=
POLLIN
;
nfds
+
+
;
}
assert
(
addedPollfd
<
pollfds
+
nfds_max
)
;
while
(
1
)
{
int
ret
=
poll
(
pollfds
nfds
POLL_TIMEOUT
)
;
if
(
ret
=
=
0
)
{
continue
;
}
else
if
(
ret
>
0
)
{
break
;
}
else
if
(
ret
=
=
-
1
)
{
switch
(
errno
)
{
case
EINTR
:
case
EAGAIN
:
if
(
IsChildAppTerminated
(
)
)
{
return
false
;
}
continue
;
default
:
Error
(
"
Run
:
poll
(
)
error
"
)
;
return
false
;
}
}
}
struct
pollfd
*
loadedPollfd
=
pollfds
;
for
(
auto
const
&
connection
:
mConnections
)
{
loadedPollfd
=
connection
-
>
LoadPollFd
(
loadedPollfd
)
;
}
assert
(
loadedPollfd
=
=
addedPollfd
)
;
assert
(
loadedPollfd
<
pollfds
+
nfds_max
)
;
if
(
addNewConnection
&
&
(
loadedPollfd
-
>
revents
&
POLLIN
)
)
{
Info
(
"
new
child
connection
\
n
"
)
;
int
applicationSocket
=
accept4
(
loadedPollfd
-
>
fd
nullptr
nullptr
SOCK_NONBLOCK
|
SOCK_CLOEXEC
)
;
if
(
applicationSocket
=
=
-
1
)
{
switch
(
errno
)
{
case
EAGAIN
:
case
EINTR
:
break
;
default
:
Error
(
"
Faild
to
accept
connection
from
application
"
)
;
return
false
;
}
}
else
{
auto
connection
=
std
:
:
make_unique
<
ProxiedConnection
>
(
)
;
if
(
connection
-
>
Init
(
applicationSocket
mWaylandDisplay
)
)
{
mConnections
.
push_back
(
std
:
:
move
(
connection
)
)
;
}
}
}
return
true
;
}
bool
WaylandProxy
:
:
ProcessConnections
(
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
ProxiedConnection
>
>
:
:
iterator
connection
;
for
(
connection
=
mConnections
.
begin
(
)
;
connection
!
=
mConnections
.
end
(
)
;
)
{
if
(
!
(
*
connection
)
-
>
Process
(
)
)
{
Info
(
"
remove
connection
\
n
"
)
;
connection
=
mConnections
.
erase
(
connection
)
;
if
(
mConnections
.
empty
(
)
)
{
Info
(
"
removed
last
connection
quit
\
n
"
)
;
return
false
;
}
}
else
{
connection
+
+
;
}
}
return
true
;
}
void
WaylandProxy
:
:
Run
(
)
{
while
(
!
IsChildAppTerminated
(
)
&
&
PollConnections
(
)
&
&
ProcessConnections
(
)
)
;
}
WaylandProxy
:
:
~
WaylandProxy
(
)
{
Info
(
"
terminated
\
n
"
)
;
if
(
mThreadRunning
)
{
Info
(
"
thread
is
still
running
terminating
.
\
n
"
)
;
mThreadRunning
=
false
;
pthread_cancel
(
mThread
)
;
pthread_join
(
mThread
nullptr
)
;
}
if
(
mProxyServerSocket
!
=
-
1
)
{
close
(
mProxyServerSocket
)
;
}
SetWaylandDisplay
(
)
;
}
void
*
WaylandProxy
:
:
RunProxyThread
(
WaylandProxy
*
aProxy
)
{
#
ifdef
__linux__
pthread_setname_np
(
pthread_self
(
)
"
WaylandProxy
"
)
;
#
endif
aProxy
-
>
Run
(
)
;
Print
(
"
[
%
d
]
WaylandProxy
[
%
p
]
:
thread
exited
.
\
n
"
getpid
(
)
aProxy
)
;
return
nullptr
;
}
std
:
:
unique_ptr
<
WaylandProxy
>
WaylandProxy
:
:
Create
(
)
{
auto
proxy
=
std
:
:
make_unique
<
WaylandProxy
>
(
)
;
Print
(
"
[
%
d
]
WaylandProxy
[
%
p
]
:
Created
(
)
.
\
n
"
getpid
(
)
proxy
.
get
(
)
)
;
if
(
!
proxy
-
>
Init
(
)
)
{
Print
(
"
[
%
d
]
WaylandProxy
[
%
p
]
:
Init
failed
exiting
.
\
n
"
getpid
(
)
proxy
.
get
(
)
)
;
return
nullptr
;
}
return
proxy
;
}
bool
WaylandProxy
:
:
RunChildApplication
(
char
*
argv
[
]
)
{
if
(
!
argv
[
0
]
)
{
Error
(
"
WaylandProxy
:
:
RunChildApplication
:
missing
application
to
run
"
false
)
;
return
false
;
}
mApplicationPID
=
fork
(
)
;
if
(
mApplicationPID
=
=
-
1
)
{
Error
(
"
WaylandProxy
:
:
RunChildApplication
:
fork
(
)
error
"
)
;
return
false
;
}
if
(
mApplicationPID
=
=
0
)
{
SetWaylandProxyDisplay
(
)
;
if
(
execv
(
argv
[
0
]
argv
)
=
=
-
1
)
{
ErrorPlain
(
"
WaylandProxy
:
:
RunChildApplication
:
failed
to
run
%
s
error
%
s
\
n
"
argv
[
0
]
strerror
(
errno
)
)
;
exit
(
1
)
;
}
}
Run
(
)
;
return
true
;
}
bool
WaylandProxy
:
:
RunThread
(
)
{
pthread_attr_t
attr
;
if
(
pthread_attr_init
(
&
attr
)
!
=
0
)
{
ErrorPlain
(
"
pthread_attr_init
(
)
failed
\
n
"
)
;
return
false
;
}
sched_param
param
;
if
(
pthread_attr_getschedparam
(
&
attr
&
param
)
=
=
0
)
{
param
.
sched_priority
=
sched_get_priority_min
(
SCHED_RR
)
;
pthread_attr_setschedparam
(
&
attr
&
param
)
;
}
SetWaylandProxyDisplay
(
)
;
mThreadRunning
=
pthread_create
(
&
mThread
nullptr
(
void
*
(
*
)
(
void
*
)
)
RunProxyThread
this
)
=
=
0
;
if
(
!
mThreadRunning
)
{
ErrorPlain
(
"
pthread_create
(
)
failed
\
n
"
)
;
SetWaylandDisplay
(
)
;
}
pthread_attr_destroy
(
&
attr
)
;
return
mThreadRunning
;
}
void
WaylandProxy
:
:
SetVerbose
(
bool
aVerbose
)
{
sPrintInfo
=
aVerbose
;
}
void
WaylandProxy
:
:
Info
(
const
char
*
aFormat
.
.
.
)
{
if
(
!
sPrintInfo
)
{
return
;
}
fprintf
(
stderr
"
[
%
d
]
WaylandProxy
[
%
p
]
:
"
getpid
(
)
this
)
;
va_list
args
;
va_start
(
args
aFormat
)
;
vfprintf
(
stderr
aFormat
args
)
;
va_end
(
args
)
;
}
void
WaylandProxy
:
:
Warning
(
const
char
*
aOperation
bool
aPrintErrno
)
{
fprintf
(
stderr
"
[
%
d
]
Wayland
Proxy
[
%
p
]
Warning
:
%
s
:
%
s
\
n
"
getpid
(
)
this
aOperation
aPrintErrno
?
strerror
(
errno
)
:
"
"
)
;
}
void
WaylandProxy
:
:
Error
(
const
char
*
aOperation
bool
aPrintErrno
)
{
fprintf
(
stderr
"
[
%
d
]
Wayland
Proxy
[
%
p
]
Error
:
%
s
:
%
s
\
n
"
getpid
(
)
this
aOperation
aPrintErrno
?
strerror
(
errno
)
:
"
"
)
;
}
void
WaylandProxy
:
:
ErrorPlain
(
const
char
*
aFormat
.
.
.
)
{
fprintf
(
stderr
"
[
%
d
]
Wayland
Proxy
[
%
p
]
Error
:
"
getpid
(
)
this
)
;
va_list
args
;
va_start
(
args
aFormat
)
;
vfprintf
(
stderr
aFormat
args
)
;
va_end
(
args
)
;
}
