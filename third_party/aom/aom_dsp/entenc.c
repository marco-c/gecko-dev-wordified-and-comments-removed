#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
math
.
h
>
#
include
<
assert
.
h
>
#
include
"
aom_dsp
/
entenc
.
h
"
#
include
"
aom_dsp
/
prob
.
h
"
#
if
OD_MEASURE_EC_OVERHEAD
#
if
!
defined
(
M_LOG2E
)
#
define
M_LOG2E
(
1
.
4426950408889634073599246810019
)
#
endif
#
define
OD_LOG2
(
x
)
(
M_LOG2E
*
log
(
x
)
)
#
endif
static
void
od_ec_enc_normalize
(
od_ec_enc
*
enc
od_ec_window
low
unsigned
rng
)
{
int
d
;
int
c
;
int
s
;
c
=
enc
-
>
cnt
;
assert
(
rng
<
=
65535U
)
;
d
=
16
-
OD_ILOG_NZ
(
rng
)
;
s
=
c
+
d
;
if
(
s
>
=
0
)
{
uint16_t
*
buf
;
uint32_t
storage
;
uint32_t
offs
;
unsigned
m
;
buf
=
enc
-
>
precarry_buf
;
storage
=
enc
-
>
precarry_storage
;
offs
=
enc
-
>
offs
;
if
(
offs
+
2
>
storage
)
{
storage
=
2
*
storage
+
2
;
buf
=
(
uint16_t
*
)
realloc
(
buf
sizeof
(
*
buf
)
*
storage
)
;
if
(
buf
=
=
NULL
)
{
enc
-
>
error
=
-
1
;
enc
-
>
offs
=
0
;
return
;
}
enc
-
>
precarry_buf
=
buf
;
enc
-
>
precarry_storage
=
storage
;
}
c
+
=
16
;
m
=
(
1
<
<
c
)
-
1
;
if
(
s
>
=
8
)
{
assert
(
offs
<
storage
)
;
buf
[
offs
+
+
]
=
(
uint16_t
)
(
low
>
>
c
)
;
low
&
=
m
;
c
-
=
8
;
m
>
>
=
8
;
}
assert
(
offs
<
storage
)
;
buf
[
offs
+
+
]
=
(
uint16_t
)
(
low
>
>
c
)
;
s
=
c
+
d
-
24
;
low
&
=
m
;
enc
-
>
offs
=
offs
;
}
enc
-
>
low
=
low
<
<
d
;
enc
-
>
rng
=
rng
<
<
d
;
enc
-
>
cnt
=
s
;
}
void
od_ec_enc_init
(
od_ec_enc
*
enc
uint32_t
size
)
{
od_ec_enc_reset
(
enc
)
;
enc
-
>
buf
=
(
unsigned
char
*
)
malloc
(
sizeof
(
*
enc
-
>
buf
)
*
size
)
;
enc
-
>
storage
=
size
;
if
(
size
>
0
&
&
enc
-
>
buf
=
=
NULL
)
{
enc
-
>
storage
=
0
;
enc
-
>
error
=
-
1
;
}
enc
-
>
precarry_buf
=
(
uint16_t
*
)
malloc
(
sizeof
(
*
enc
-
>
precarry_buf
)
*
size
)
;
enc
-
>
precarry_storage
=
size
;
if
(
size
>
0
&
&
enc
-
>
precarry_buf
=
=
NULL
)
{
enc
-
>
precarry_storage
=
0
;
enc
-
>
error
=
-
1
;
}
}
void
od_ec_enc_reset
(
od_ec_enc
*
enc
)
{
enc
-
>
offs
=
0
;
enc
-
>
low
=
0
;
enc
-
>
rng
=
0x8000
;
enc
-
>
cnt
=
-
9
;
enc
-
>
error
=
0
;
#
if
OD_MEASURE_EC_OVERHEAD
enc
-
>
entropy
=
0
;
enc
-
>
nb_symbols
=
0
;
#
endif
}
void
od_ec_enc_clear
(
od_ec_enc
*
enc
)
{
free
(
enc
-
>
precarry_buf
)
;
free
(
enc
-
>
buf
)
;
}
static
void
od_ec_encode_q15
(
od_ec_enc
*
enc
unsigned
fl
unsigned
fh
int
s
int
nsyms
)
{
od_ec_window
l
;
unsigned
r
;
unsigned
u
;
unsigned
v
;
l
=
enc
-
>
low
;
r
=
enc
-
>
rng
;
assert
(
32768U
<
=
r
)
;
assert
(
fh
<
=
fl
)
;
assert
(
fl
<
=
32768U
)
;
assert
(
7
-
EC_PROB_SHIFT
-
CDF_SHIFT
>
=
0
)
;
const
int
N
=
nsyms
-
1
;
if
(
fl
<
CDF_PROB_TOP
)
{
u
=
(
(
r
>
>
8
)
*
(
uint32_t
)
(
fl
>
>
EC_PROB_SHIFT
)
>
>
(
7
-
EC_PROB_SHIFT
-
CDF_SHIFT
)
)
+
EC_MIN_PROB
*
(
N
-
(
s
-
1
)
)
;
v
=
(
(
r
>
>
8
)
*
(
uint32_t
)
(
fh
>
>
EC_PROB_SHIFT
)
>
>
(
7
-
EC_PROB_SHIFT
-
CDF_SHIFT
)
)
+
EC_MIN_PROB
*
(
N
-
(
s
+
0
)
)
;
l
+
=
r
-
u
;
r
=
u
-
v
;
}
else
{
r
-
=
(
(
r
>
>
8
)
*
(
uint32_t
)
(
fh
>
>
EC_PROB_SHIFT
)
>
>
(
7
-
EC_PROB_SHIFT
-
CDF_SHIFT
)
)
+
EC_MIN_PROB
*
(
N
-
(
s
+
0
)
)
;
}
od_ec_enc_normalize
(
enc
l
r
)
;
#
if
OD_MEASURE_EC_OVERHEAD
enc
-
>
entropy
-
=
OD_LOG2
(
(
double
)
(
OD_ICDF
(
fh
)
-
OD_ICDF
(
fl
)
)
/
CDF_PROB_TOP
.
)
;
enc
-
>
nb_symbols
+
+
;
#
endif
}
void
od_ec_encode_bool_q15
(
od_ec_enc
*
enc
int
val
unsigned
f
)
{
od_ec_window
l
;
unsigned
r
;
unsigned
v
;
assert
(
0
<
f
)
;
assert
(
f
<
32768U
)
;
l
=
enc
-
>
low
;
r
=
enc
-
>
rng
;
assert
(
32768U
<
=
r
)
;
v
=
(
(
r
>
>
8
)
*
(
uint32_t
)
(
f
>
>
EC_PROB_SHIFT
)
>
>
(
7
-
EC_PROB_SHIFT
)
)
;
v
+
=
EC_MIN_PROB
;
if
(
val
)
l
+
=
r
-
v
;
r
=
val
?
v
:
r
-
v
;
od_ec_enc_normalize
(
enc
l
r
)
;
#
if
OD_MEASURE_EC_OVERHEAD
enc
-
>
entropy
-
=
OD_LOG2
(
(
double
)
(
val
?
f
:
(
32768
-
f
)
)
/
32768
.
)
;
enc
-
>
nb_symbols
+
+
;
#
endif
}
void
od_ec_encode_cdf_q15
(
od_ec_enc
*
enc
int
s
const
uint16_t
*
icdf
int
nsyms
)
{
(
void
)
nsyms
;
assert
(
s
>
=
0
)
;
assert
(
s
<
nsyms
)
;
assert
(
icdf
[
nsyms
-
1
]
=
=
OD_ICDF
(
CDF_PROB_TOP
)
)
;
od_ec_encode_q15
(
enc
s
>
0
?
icdf
[
s
-
1
]
:
OD_ICDF
(
0
)
icdf
[
s
]
s
nsyms
)
;
}
void
od_ec_enc_patch_initial_bits
(
od_ec_enc
*
enc
unsigned
val
int
nbits
)
{
int
shift
;
unsigned
mask
;
assert
(
nbits
>
=
0
)
;
assert
(
nbits
<
=
8
)
;
assert
(
val
<
1U
<
<
nbits
)
;
shift
=
8
-
nbits
;
mask
=
(
(
1U
<
<
nbits
)
-
1
)
<
<
shift
;
if
(
enc
-
>
offs
>
0
)
{
enc
-
>
precarry_buf
[
0
]
=
(
uint16_t
)
(
(
enc
-
>
precarry_buf
[
0
]
&
~
mask
)
|
val
<
<
shift
)
;
}
else
if
(
9
+
enc
-
>
cnt
+
(
enc
-
>
rng
=
=
0x8000
)
>
nbits
)
{
enc
-
>
low
=
(
enc
-
>
low
&
~
(
(
od_ec_window
)
mask
<
<
(
16
+
enc
-
>
cnt
)
)
)
|
(
od_ec_window
)
val
<
<
(
16
+
enc
-
>
cnt
+
shift
)
;
}
else
{
enc
-
>
error
=
-
1
;
}
}
#
if
OD_MEASURE_EC_OVERHEAD
#
include
<
stdio
.
h
>
#
endif
unsigned
char
*
od_ec_enc_done
(
od_ec_enc
*
enc
uint32_t
*
nbytes
)
{
unsigned
char
*
out
;
uint32_t
storage
;
uint16_t
*
buf
;
uint32_t
offs
;
od_ec_window
m
;
od_ec_window
e
;
od_ec_window
l
;
int
c
;
int
s
;
if
(
enc
-
>
error
)
return
NULL
;
#
if
OD_MEASURE_EC_OVERHEAD
{
uint32_t
tell
;
tell
=
od_ec_enc_tell
(
enc
)
-
1
;
fprintf
(
stderr
"
overhead
:
%
f
%
%
\
n
"
100
*
(
tell
-
enc
-
>
entropy
)
/
enc
-
>
entropy
)
;
fprintf
(
stderr
"
efficiency
:
%
f
bits
/
symbol
\
n
"
(
double
)
tell
/
enc
-
>
nb_symbols
)
;
}
#
endif
l
=
enc
-
>
low
;
c
=
enc
-
>
cnt
;
s
=
10
;
m
=
0x3FFF
;
e
=
(
(
l
+
m
)
&
~
m
)
|
(
m
+
1
)
;
s
+
=
c
;
offs
=
enc
-
>
offs
;
buf
=
enc
-
>
precarry_buf
;
if
(
s
>
0
)
{
unsigned
n
;
storage
=
enc
-
>
precarry_storage
;
if
(
offs
+
(
(
s
+
7
)
>
>
3
)
>
storage
)
{
storage
=
storage
*
2
+
(
(
s
+
7
)
>
>
3
)
;
buf
=
(
uint16_t
*
)
realloc
(
buf
sizeof
(
*
buf
)
*
storage
)
;
if
(
buf
=
=
NULL
)
{
enc
-
>
error
=
-
1
;
return
NULL
;
}
enc
-
>
precarry_buf
=
buf
;
enc
-
>
precarry_storage
=
storage
;
}
n
=
(
1
<
<
(
c
+
16
)
)
-
1
;
do
{
assert
(
offs
<
storage
)
;
buf
[
offs
+
+
]
=
(
uint16_t
)
(
e
>
>
(
c
+
16
)
)
;
e
&
=
n
;
s
-
=
8
;
c
-
=
8
;
n
>
>
=
8
;
}
while
(
s
>
0
)
;
}
out
=
enc
-
>
buf
;
storage
=
enc
-
>
storage
;
c
=
OD_MAXI
(
(
s
+
7
)
>
>
3
0
)
;
if
(
offs
+
c
>
storage
)
{
storage
=
offs
+
c
;
out
=
(
unsigned
char
*
)
realloc
(
out
sizeof
(
*
out
)
*
storage
)
;
if
(
out
=
=
NULL
)
{
enc
-
>
error
=
-
1
;
return
NULL
;
}
enc
-
>
buf
=
out
;
enc
-
>
storage
=
storage
;
}
*
nbytes
=
offs
;
assert
(
offs
<
=
storage
)
;
out
=
out
+
storage
-
offs
;
c
=
0
;
while
(
offs
>
0
)
{
offs
-
-
;
c
=
buf
[
offs
]
+
c
;
out
[
offs
]
=
(
unsigned
char
)
c
;
c
>
>
=
8
;
}
return
out
;
}
int
od_ec_enc_tell
(
const
od_ec_enc
*
enc
)
{
return
(
enc
-
>
cnt
+
10
)
+
enc
-
>
offs
*
8
;
}
uint32_t
od_ec_enc_tell_frac
(
const
od_ec_enc
*
enc
)
{
return
od_ec_tell_frac
(
od_ec_enc_tell
(
enc
)
enc
-
>
rng
)
;
}
void
od_ec_enc_checkpoint
(
od_ec_enc
*
dst
const
od_ec_enc
*
src
)
{
OD_COPY
(
dst
src
1
)
;
}
void
od_ec_enc_rollback
(
od_ec_enc
*
dst
const
od_ec_enc
*
src
)
{
unsigned
char
*
buf
;
uint32_t
storage
;
uint16_t
*
precarry_buf
;
uint32_t
precarry_storage
;
assert
(
dst
-
>
storage
>
=
src
-
>
storage
)
;
assert
(
dst
-
>
precarry_storage
>
=
src
-
>
precarry_storage
)
;
buf
=
dst
-
>
buf
;
storage
=
dst
-
>
storage
;
precarry_buf
=
dst
-
>
precarry_buf
;
precarry_storage
=
dst
-
>
precarry_storage
;
OD_COPY
(
dst
src
1
)
;
dst
-
>
buf
=
buf
;
dst
-
>
storage
=
storage
;
dst
-
>
precarry_buf
=
precarry_buf
;
dst
-
>
precarry_storage
=
precarry_storage
;
}
