#
ifndef
AOM_AOM_DSP_MATHUTILS_H_
#
define
AOM_AOM_DSP_MATHUTILS_H_
#
include
<
assert
.
h
>
#
include
<
math
.
h
>
#
include
<
string
.
h
>
#
include
"
aom_dsp
/
aom_dsp_common
.
h
"
#
include
"
aom_mem
/
aom_mem
.
h
"
static
const
double
TINY_NEAR_ZERO
=
1
.
0E
-
16
;
static
INLINE
int
linsolve
(
int
n
double
*
A
int
stride
double
*
b
double
*
x
)
{
int
i
j
k
;
double
c
;
for
(
k
=
0
;
k
<
n
-
1
;
k
+
+
)
{
for
(
i
=
n
-
1
;
i
>
k
;
i
-
-
)
{
if
(
fabs
(
A
[
(
i
-
1
)
*
stride
+
k
]
)
<
fabs
(
A
[
i
*
stride
+
k
]
)
)
{
for
(
j
=
0
;
j
<
n
;
j
+
+
)
{
c
=
A
[
i
*
stride
+
j
]
;
A
[
i
*
stride
+
j
]
=
A
[
(
i
-
1
)
*
stride
+
j
]
;
A
[
(
i
-
1
)
*
stride
+
j
]
=
c
;
}
c
=
b
[
i
]
;
b
[
i
]
=
b
[
i
-
1
]
;
b
[
i
-
1
]
=
c
;
}
}
for
(
i
=
k
;
i
<
n
-
1
;
i
+
+
)
{
if
(
fabs
(
A
[
k
*
stride
+
k
]
)
<
TINY_NEAR_ZERO
)
return
0
;
c
=
A
[
(
i
+
1
)
*
stride
+
k
]
/
A
[
k
*
stride
+
k
]
;
for
(
j
=
0
;
j
<
n
;
j
+
+
)
A
[
(
i
+
1
)
*
stride
+
j
]
-
=
c
*
A
[
k
*
stride
+
j
]
;
b
[
i
+
1
]
-
=
c
*
b
[
k
]
;
}
}
for
(
i
=
n
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
fabs
(
A
[
i
*
stride
+
i
]
)
<
TINY_NEAR_ZERO
)
return
0
;
c
=
0
;
for
(
j
=
i
+
1
;
j
<
=
n
-
1
;
j
+
+
)
c
+
=
A
[
i
*
stride
+
j
]
*
x
[
j
]
;
x
[
i
]
=
(
b
[
i
]
-
c
)
/
A
[
i
*
stride
+
i
]
;
}
return
1
;
}
static
INLINE
void
least_squares_init
(
double
*
mat
double
*
y
int
n
)
{
memset
(
mat
0
n
*
n
*
sizeof
(
double
)
)
;
memset
(
y
0
n
*
sizeof
(
double
)
)
;
}
static
AOM_FORCE_INLINE
int
iroundpf
(
float
x
)
{
assert
(
x
>
=
0
.
0
)
;
return
(
int
)
(
x
+
0
.
5f
)
;
}
static
INLINE
void
least_squares_accumulate
(
double
*
mat
double
*
y
const
double
*
a
double
b
int
n
)
{
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
for
(
int
j
=
0
;
j
<
n
;
j
+
+
)
{
mat
[
i
*
n
+
j
]
+
=
a
[
i
]
*
a
[
j
]
;
}
}
for
(
int
i
=
0
;
i
<
n
;
i
+
+
)
{
y
[
i
]
+
=
a
[
i
]
*
b
;
}
}
static
INLINE
int
least_squares_solve
(
double
*
mat
double
*
y
double
*
x
int
n
)
{
return
linsolve
(
n
mat
n
y
x
)
;
}
static
INLINE
void
multiply_mat
(
const
double
*
m1
const
double
*
m2
double
*
res
const
int
m1_rows
const
int
inner_dim
const
int
m2_cols
)
{
double
sum
;
int
row
col
inner
;
for
(
row
=
0
;
row
<
m1_rows
;
+
+
row
)
{
for
(
col
=
0
;
col
<
m2_cols
;
+
+
col
)
{
sum
=
0
;
for
(
inner
=
0
;
inner
<
inner_dim
;
+
+
inner
)
sum
+
=
m1
[
row
*
inner_dim
+
inner
]
*
m2
[
inner
*
m2_cols
+
col
]
;
*
(
res
+
+
)
=
sum
;
}
}
}
static
AOM_INLINE
float
approx_exp
(
float
y
)
{
#
define
A
(
(
1
<
<
23
)
/
0
.
69314718056f
)
/
/
(
1
<
<
23
)
/
ln
(
2
)
#
define
B
\
127
/
/
Offset
for
the
exponent
according
to
IEEE
floating
point
standard
.
#
define
C
60801
/
/
Magic
number
controls
the
accuracy
of
approximation
union
{
float
as_float
;
int32_t
as_int32
;
}
container
;
container
.
as_int32
=
(
(
int32_t
)
(
y
*
A
)
)
+
(
(
B
<
<
23
)
-
C
)
;
return
container
.
as_float
;
#
undef
A
#
undef
B
#
undef
C
}
#
endif
