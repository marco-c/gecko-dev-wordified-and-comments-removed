#
include
"
aom_dsp
/
pyramid
.
h
"
#
include
"
aom_mem
/
aom_mem
.
h
"
#
include
"
aom_ports
/
bitops
.
h
"
#
include
"
aom_util
/
aom_pthread
.
h
"
#
include
"
av1
/
common
/
resize
.
h
"
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
size_t
aom_get_pyramid_alloc_size
(
int
width
int
height
bool
image_is_16bit
)
{
const
int
msb
=
get_msb
(
AOMMIN
(
width
height
)
)
;
const
int
n_levels
=
AOMMAX
(
msb
-
MIN_PYRAMID_SIZE_LOG2
1
)
;
size_t
alloc_size
=
0
;
alloc_size
+
=
sizeof
(
ImagePyramid
)
;
alloc_size
+
=
n_levels
*
sizeof
(
PyramidLayer
)
;
size_t
buffer_size
=
0
;
size_t
first_px_offset
=
(
PYRAMID_PADDING
+
PYRAMID_ALIGNMENT
-
1
)
&
~
(
PYRAMID_ALIGNMENT
-
1
)
;
size_t
extra_bytes
=
first_px_offset
-
PYRAMID_PADDING
;
buffer_size
+
=
extra_bytes
;
int
first_allocated_level
=
image_is_16bit
?
0
:
1
;
for
(
int
level
=
first_allocated_level
;
level
<
n_levels
;
level
+
+
)
{
int
level_width
=
width
>
>
level
;
int
level_height
=
height
>
>
level
;
int
padded_width
=
level_width
+
2
*
PYRAMID_PADDING
;
int
padded_height
=
level_height
+
2
*
PYRAMID_PADDING
;
int
level_stride
=
(
padded_width
+
PYRAMID_ALIGNMENT
-
1
)
&
~
(
PYRAMID_ALIGNMENT
-
1
)
;
buffer_size
+
=
level_stride
*
padded_height
;
}
alloc_size
+
=
buffer_size
;
return
alloc_size
;
}
ImagePyramid
*
aom_alloc_pyramid
(
int
width
int
height
bool
image_is_16bit
)
{
const
int
msb
=
get_msb
(
AOMMIN
(
width
height
)
)
;
const
int
n_levels
=
AOMMAX
(
msb
-
MIN_PYRAMID_SIZE_LOG2
1
)
;
ImagePyramid
*
pyr
=
aom_calloc
(
1
sizeof
(
*
pyr
)
)
;
if
(
!
pyr
)
{
return
NULL
;
}
pyr
-
>
layers
=
aom_calloc
(
n_levels
sizeof
(
*
pyr
-
>
layers
)
)
;
if
(
!
pyr
-
>
layers
)
{
aom_free
(
pyr
)
;
return
NULL
;
}
pyr
-
>
max_levels
=
n_levels
;
pyr
-
>
filled_levels
=
0
;
size_t
buffer_size
=
0
;
size_t
*
layer_offsets
=
aom_calloc
(
n_levels
sizeof
(
*
layer_offsets
)
)
;
if
(
!
layer_offsets
)
{
aom_free
(
pyr
-
>
layers
)
;
aom_free
(
pyr
)
;
return
NULL
;
}
size_t
first_px_offset
=
(
PYRAMID_PADDING
+
PYRAMID_ALIGNMENT
-
1
)
&
~
(
PYRAMID_ALIGNMENT
-
1
)
;
size_t
extra_bytes
=
first_px_offset
-
PYRAMID_PADDING
;
buffer_size
+
=
extra_bytes
;
int
first_allocated_level
=
image_is_16bit
?
0
:
1
;
for
(
int
level
=
first_allocated_level
;
level
<
n_levels
;
level
+
+
)
{
PyramidLayer
*
layer
=
&
pyr
-
>
layers
[
level
]
;
int
level_width
=
width
>
>
level
;
int
level_height
=
height
>
>
level
;
int
padded_width
=
level_width
+
2
*
PYRAMID_PADDING
;
int
padded_height
=
level_height
+
2
*
PYRAMID_PADDING
;
int
level_stride
=
(
padded_width
+
PYRAMID_ALIGNMENT
-
1
)
&
~
(
PYRAMID_ALIGNMENT
-
1
)
;
size_t
level_alloc_start
=
buffer_size
;
size_t
level_start
=
level_alloc_start
+
PYRAMID_PADDING
*
level_stride
+
PYRAMID_PADDING
;
buffer_size
+
=
level_stride
*
padded_height
;
layer_offsets
[
level
]
=
level_start
;
layer
-
>
width
=
level_width
;
layer
-
>
height
=
level_height
;
layer
-
>
stride
=
level_stride
;
}
pyr
-
>
buffer_alloc
=
aom_memalign
(
PYRAMID_ALIGNMENT
buffer_size
*
sizeof
(
*
pyr
-
>
buffer_alloc
)
)
;
if
(
!
pyr
-
>
buffer_alloc
)
{
aom_free
(
pyr
-
>
layers
)
;
aom_free
(
pyr
)
;
aom_free
(
layer_offsets
)
;
return
NULL
;
}
for
(
int
level
=
first_allocated_level
;
level
<
n_levels
;
level
+
+
)
{
PyramidLayer
*
layer
=
&
pyr
-
>
layers
[
level
]
;
layer
-
>
buffer
=
pyr
-
>
buffer_alloc
+
layer_offsets
[
level
]
;
}
#
if
CONFIG_MULTITHREAD
pthread_mutex_init
(
&
pyr
-
>
mutex
NULL
)
;
#
endif
aom_free
(
layer_offsets
)
;
return
pyr
;
}
static
INLINE
void
fill_border
(
uint8_t
*
img_buf
const
int
width
const
int
height
const
int
stride
)
{
for
(
int
row
=
0
;
row
<
height
;
row
+
+
)
{
uint8_t
*
row_start
=
&
img_buf
[
row
*
stride
]
;
uint8_t
left_pixel
=
row_start
[
0
]
;
memset
(
row_start
-
PYRAMID_PADDING
left_pixel
PYRAMID_PADDING
)
;
uint8_t
right_pixel
=
row_start
[
width
-
1
]
;
memset
(
row_start
+
width
right_pixel
PYRAMID_PADDING
)
;
}
for
(
int
row
=
-
PYRAMID_PADDING
;
row
<
0
;
row
+
+
)
{
uint8_t
*
row_start
=
&
img_buf
[
row
*
stride
]
;
memcpy
(
row_start
-
PYRAMID_PADDING
img_buf
-
PYRAMID_PADDING
width
+
2
*
PYRAMID_PADDING
)
;
}
uint8_t
*
last_row_start
=
&
img_buf
[
(
height
-
1
)
*
stride
]
;
for
(
int
row
=
height
;
row
<
height
+
PYRAMID_PADDING
;
row
+
+
)
{
uint8_t
*
row_start
=
&
img_buf
[
row
*
stride
]
;
memcpy
(
row_start
-
PYRAMID_PADDING
last_row_start
-
PYRAMID_PADDING
width
+
2
*
PYRAMID_PADDING
)
;
}
}
static
INLINE
int
fill_pyramid
(
const
YV12_BUFFER_CONFIG
*
frame
int
bit_depth
int
n_levels
ImagePyramid
*
frame_pyr
)
{
int
already_filled_levels
=
frame_pyr
-
>
filled_levels
;
assert
(
n_levels
<
=
frame_pyr
-
>
max_levels
)
;
if
(
already_filled_levels
>
=
n_levels
)
{
return
n_levels
;
}
const
int
frame_width
=
frame
-
>
y_crop_width
;
const
int
frame_height
=
frame
-
>
y_crop_height
;
const
int
frame_stride
=
frame
-
>
y_stride
;
assert
(
(
frame_width
>
>
n_levels
)
>
=
0
)
;
assert
(
(
frame_height
>
>
n_levels
)
>
=
0
)
;
if
(
already_filled_levels
=
=
0
)
{
PyramidLayer
*
first_layer
=
&
frame_pyr
-
>
layers
[
0
]
;
if
(
frame
-
>
flags
&
YV12_FLAG_HIGHBITDEPTH
)
{
assert
(
first_layer
-
>
width
=
=
frame_width
)
;
assert
(
first_layer
-
>
height
=
=
frame_height
)
;
uint16_t
*
frame_buffer
=
CONVERT_TO_SHORTPTR
(
frame
-
>
y_buffer
)
;
uint8_t
*
pyr_buffer
=
first_layer
-
>
buffer
;
int
pyr_stride
=
first_layer
-
>
stride
;
for
(
int
y
=
0
;
y
<
frame_height
;
y
+
+
)
{
uint16_t
*
frame_row
=
frame_buffer
+
y
*
frame_stride
;
uint8_t
*
pyr_row
=
pyr_buffer
+
y
*
pyr_stride
;
for
(
int
x
=
0
;
x
<
frame_width
;
x
+
+
)
{
pyr_row
[
x
]
=
frame_row
[
x
]
>
>
(
bit_depth
-
8
)
;
}
}
fill_border
(
pyr_buffer
frame_width
frame_height
pyr_stride
)
;
}
else
{
first_layer
-
>
buffer
=
frame
-
>
y_buffer
;
first_layer
-
>
width
=
frame_width
;
first_layer
-
>
height
=
frame_height
;
first_layer
-
>
stride
=
frame_stride
;
}
already_filled_levels
=
1
;
}
for
(
int
level
=
already_filled_levels
;
level
<
n_levels
;
+
+
level
)
{
PyramidLayer
*
prev_layer
=
&
frame_pyr
-
>
layers
[
level
-
1
]
;
uint8_t
*
prev_buffer
=
prev_layer
-
>
buffer
;
int
prev_stride
=
prev_layer
-
>
stride
;
PyramidLayer
*
this_layer
=
&
frame_pyr
-
>
layers
[
level
]
;
uint8_t
*
this_buffer
=
this_layer
-
>
buffer
;
int
this_width
=
this_layer
-
>
width
;
int
this_height
=
this_layer
-
>
height
;
int
this_stride
=
this_layer
-
>
stride
;
if
(
!
av1_resize_plane
(
prev_buffer
this_height
<
<
1
this_width
<
<
1
prev_stride
this_buffer
this_height
this_width
this_stride
)
)
{
frame_pyr
-
>
filled_levels
=
n_levels
;
return
-
1
;
}
fill_border
(
this_buffer
this_width
this_height
this_stride
)
;
}
frame_pyr
-
>
filled_levels
=
n_levels
;
return
n_levels
;
}
int
aom_compute_pyramid
(
const
YV12_BUFFER_CONFIG
*
frame
int
bit_depth
int
n_levels
ImagePyramid
*
pyr
)
{
assert
(
pyr
)
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_lock
(
&
pyr
-
>
mutex
)
;
#
endif
n_levels
=
AOMMIN
(
n_levels
pyr
-
>
max_levels
)
;
int
result
=
n_levels
;
if
(
pyr
-
>
filled_levels
<
n_levels
)
{
result
=
fill_pyramid
(
frame
bit_depth
n_levels
pyr
)
;
}
assert
(
IMPLIES
(
result
>
=
0
pyr
-
>
filled_levels
>
=
n_levels
)
)
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_unlock
(
&
pyr
-
>
mutex
)
;
#
endif
return
result
;
}
#
ifndef
NDEBUG
bool
aom_is_pyramid_valid
(
ImagePyramid
*
pyr
int
n_levels
)
{
assert
(
pyr
)
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_lock
(
&
pyr
-
>
mutex
)
;
#
endif
bool
result
=
(
pyr
-
>
filled_levels
>
=
n_levels
)
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_unlock
(
&
pyr
-
>
mutex
)
;
#
endif
return
result
;
}
#
endif
void
aom_invalidate_pyramid
(
ImagePyramid
*
pyr
)
{
if
(
pyr
)
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_lock
(
&
pyr
-
>
mutex
)
;
#
endif
pyr
-
>
filled_levels
=
0
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_unlock
(
&
pyr
-
>
mutex
)
;
#
endif
}
}
void
aom_free_pyramid
(
ImagePyramid
*
pyr
)
{
if
(
pyr
)
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_destroy
(
&
pyr
-
>
mutex
)
;
#
endif
aom_free
(
pyr
-
>
buffer_alloc
)
;
aom_free
(
pyr
-
>
layers
)
;
aom_free
(
pyr
)
;
}
}
