#
include
"
config
/
aom_config
.
h
"
#
include
"
arm_cpudetect
.
h
"
#
include
"
aom_ports
/
arm
.
h
"
#
if
defined
(
__APPLE__
)
#
include
<
sys
/
sysctl
.
h
>
#
endif
#
if
!
CONFIG_RUNTIME_CPU_DETECT
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
return
flags
;
}
#
elif
defined
(
__APPLE__
)
static
inline
bool
have_feature
(
const
char
*
feature
)
{
int64_t
feature_present
=
0
;
size_t
size
=
sizeof
(
feature_present
)
;
if
(
sysctlbyname
(
feature
&
feature_present
&
size
NULL
0
)
!
=
0
)
{
return
false
;
}
return
feature_present
;
}
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
#
if
HAVE_ARM_CRC32
if
(
have_feature
(
"
hw
.
optional
.
armv8_crc32
"
)
)
flags
|
=
HAS_ARM_CRC32
;
#
endif
#
if
HAVE_NEON_DOTPROD
if
(
have_feature
(
"
hw
.
optional
.
arm
.
FEAT_DotProd
"
)
)
flags
|
=
HAS_NEON_DOTPROD
;
#
endif
#
if
HAVE_NEON_I8MM
if
(
have_feature
(
"
hw
.
optional
.
arm
.
FEAT_I8MM
"
)
)
flags
|
=
HAS_NEON_I8MM
;
#
endif
return
flags
;
}
#
elif
defined
(
_WIN32
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
#
if
HAVE_ARM_CRC32
if
(
IsProcessorFeaturePresent
(
PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE
)
)
{
flags
|
=
HAS_ARM_CRC32
;
}
#
endif
#
if
HAVE_NEON_DOTPROD
#
if
defined
(
PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE
)
if
(
IsProcessorFeaturePresent
(
PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE
)
)
{
flags
|
=
HAS_NEON_DOTPROD
;
}
#
endif
#
endif
#
if
HAVE_NEON_I8MM
#
if
defined
(
PF_ARM_SVE_I8MM_INSTRUCTIONS_AVAILABLE
)
if
(
IsProcessorFeaturePresent
(
PF_ARM_SVE_I8MM_INSTRUCTIONS_AVAILABLE
)
)
{
flags
|
=
HAS_NEON_I8MM
;
}
#
endif
#
endif
#
if
HAVE_SVE
#
if
defined
(
PF_ARM_SVE_INSTRUCTIONS_AVAILABLE
)
if
(
IsProcessorFeaturePresent
(
PF_ARM_SVE_INSTRUCTIONS_AVAILABLE
)
)
{
flags
|
=
HAS_SVE
;
}
#
endif
#
endif
#
if
HAVE_SVE2
#
if
defined
(
PF_ARM_SVE2_INSTRUCTIONS_AVAILABLE
)
if
(
IsProcessorFeaturePresent
(
PF_ARM_SVE2_INSTRUCTIONS_AVAILABLE
)
)
{
flags
|
=
HAS_SVE2
;
}
#
endif
#
endif
return
flags
;
}
#
elif
defined
(
AOM_USE_ANDROID_CPU_FEATURES
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
return
flags
;
}
#
elif
defined
(
__linux__
)
#
include
<
sys
/
auxv
.
h
>
#
define
AOM_AARCH64_HWCAP_CRC32
(
1
<
<
7
)
#
define
AOM_AARCH64_HWCAP_ASIMDDP
(
1
<
<
20
)
#
define
AOM_AARCH64_HWCAP_SVE
(
1
<
<
22
)
#
define
AOM_AARCH64_HWCAP2_SVE2
(
1
<
<
1
)
#
define
AOM_AARCH64_HWCAP2_I8MM
(
1
<
<
13
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_ARM_CRC32
|
|
HAVE_NEON_DOTPROD
|
|
HAVE_SVE
unsigned
long
hwcap
=
getauxval
(
AT_HWCAP
)
;
#
endif
#
if
HAVE_NEON_I8MM
|
|
HAVE_SVE2
unsigned
long
hwcap2
=
getauxval
(
AT_HWCAP2
)
;
#
endif
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
#
if
HAVE_ARM_CRC32
if
(
hwcap
&
AOM_AARCH64_HWCAP_CRC32
)
flags
|
=
HAS_ARM_CRC32
;
#
endif
#
if
HAVE_NEON_DOTPROD
if
(
hwcap
&
AOM_AARCH64_HWCAP_ASIMDDP
)
flags
|
=
HAS_NEON_DOTPROD
;
#
endif
#
if
HAVE_NEON_I8MM
if
(
hwcap2
&
AOM_AARCH64_HWCAP2_I8MM
)
flags
|
=
HAS_NEON_I8MM
;
#
endif
#
if
HAVE_SVE
if
(
hwcap
&
AOM_AARCH64_HWCAP_SVE
)
flags
|
=
HAS_SVE
;
#
endif
#
if
HAVE_SVE2
if
(
hwcap2
&
AOM_AARCH64_HWCAP2_SVE2
)
flags
|
=
HAS_SVE2
;
#
endif
return
flags
;
}
#
elif
defined
(
__Fuchsia__
)
#
include
<
zircon
/
features
.
h
>
#
include
<
zircon
/
syscalls
.
h
>
#
ifndef
ZX_ARM64_FEATURE_ISA_I8MM
#
define
ZX_ARM64_FEATURE_ISA_I8MM
(
(
uint32_t
)
(
1u
<
<
19
)
)
#
endif
#
ifndef
ZX_ARM64_FEATURE_ISA_SVE
#
define
ZX_ARM64_FEATURE_ISA_SVE
(
(
uint32_t
)
(
1u
<
<
20
)
)
#
endif
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
uint32_t
features
;
zx_status_t
status
=
zx_system_get_features
(
ZX_FEATURE_KIND_CPU
&
features
)
;
if
(
status
!
=
ZX_OK
)
return
flags
;
#
if
HAVE_ARM_CRC32
if
(
features
&
ZX_ARM64_FEATURE_ISA_CRC32
)
flags
|
=
HAS_ARM_CRC32
;
#
endif
#
if
HAVE_NEON_DOTPROD
if
(
features
&
ZX_ARM64_FEATURE_ISA_DP
)
flags
|
=
HAS_NEON_DOTPROD
;
#
endif
#
if
HAVE_NEON_I8MM
if
(
features
&
ZX_ARM64_FEATURE_ISA_I8MM
)
flags
|
=
HAS_NEON_I8MM
;
#
endif
#
if
HAVE_SVE
if
(
features
&
ZX_ARM64_FEATURE_ISA_SVE
)
flags
|
=
HAS_SVE
;
#
endif
return
flags
;
}
#
else
#
error
\
"
Runtime
CPU
detection
selected
but
no
CPU
detection
method
"
\
"
available
for
your
platform
.
Rerun
cmake
with
-
DCONFIG_RUNTIME_CPU_DETECT
=
0
.
"
#
endif
int
aom_arm_cpu_caps
(
void
)
{
int
flags
=
0
;
if
(
!
arm_cpu_env_flags
(
&
flags
)
)
{
flags
=
arm_get_cpu_caps
(
)
&
arm_cpu_env_mask
(
)
;
}
if
(
!
(
flags
&
HAS_NEON_DOTPROD
)
)
flags
&
=
~
HAS_NEON_I8MM
;
if
(
!
(
flags
&
HAS_NEON_DOTPROD
)
)
flags
&
=
~
HAS_SVE
;
if
(
!
(
flags
&
HAS_NEON_I8MM
)
)
flags
&
=
~
HAS_SVE
;
if
(
!
(
flags
&
HAS_SVE
)
)
flags
&
=
~
HAS_SVE2
;
return
flags
;
}
