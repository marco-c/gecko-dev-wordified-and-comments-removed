#
ifndef
_GNU_SOURCE
#
define
_GNU_SOURCE
#
endif
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
"
config
/
aom_config
.
h
"
#
include
"
aom_mem
/
aom_mem
.
h
"
#
include
"
aom_ports
/
sanitizer
.
h
"
#
include
"
aom_util
/
aom_pthread
.
h
"
#
include
"
aom_util
/
aom_thread
.
h
"
#
if
CONFIG_MULTITHREAD
struct
AVxWorkerImpl
{
pthread_mutex_t
mutex_
;
pthread_cond_t
condition_
;
pthread_t
thread_
;
}
;
static
void
execute
(
AVxWorker
*
const
worker
)
;
static
THREADFN
thread_loop
(
void
*
ptr
)
{
AVxWorker
*
const
worker
=
(
AVxWorker
*
)
ptr
;
#
ifdef
__APPLE__
if
(
worker
-
>
thread_name
!
=
NULL
)
{
char
thread_name
[
64
]
;
strncpy
(
thread_name
worker
-
>
thread_name
sizeof
(
thread_name
)
-
1
)
;
thread_name
[
sizeof
(
thread_name
)
-
1
]
=
'
\
0
'
;
pthread_setname_np
(
thread_name
)
;
}
#
elif
(
defined
(
__GLIBC__
)
&
&
!
defined
(
__GNU__
)
)
|
|
defined
(
__BIONIC__
)
if
(
worker
-
>
thread_name
!
=
NULL
)
{
char
thread_name
[
16
]
;
strncpy
(
thread_name
worker
-
>
thread_name
sizeof
(
thread_name
)
-
1
)
;
thread_name
[
sizeof
(
thread_name
)
-
1
]
=
'
\
0
'
;
pthread_setname_np
(
pthread_self
(
)
thread_name
)
;
}
#
endif
pthread_mutex_lock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
for
(
;
;
)
{
while
(
worker
-
>
status_
=
=
AVX_WORKER_STATUS_OK
)
{
pthread_cond_wait
(
&
worker
-
>
impl_
-
>
condition_
&
worker
-
>
impl_
-
>
mutex_
)
;
}
if
(
worker
-
>
status_
=
=
AVX_WORKER_STATUS_WORKING
)
{
pthread_mutex_unlock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
execute
(
worker
)
;
pthread_mutex_lock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
assert
(
worker
-
>
status_
=
=
AVX_WORKER_STATUS_WORKING
)
;
worker
-
>
status_
=
AVX_WORKER_STATUS_OK
;
pthread_cond_signal
(
&
worker
-
>
impl_
-
>
condition_
)
;
}
else
{
assert
(
worker
-
>
status_
=
=
AVX_WORKER_STATUS_NOT_OK
)
;
break
;
}
}
pthread_mutex_unlock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
return
THREAD_EXIT_SUCCESS
;
}
static
void
change_state
(
AVxWorker
*
const
worker
AVxWorkerStatus
new_status
)
{
if
(
worker
-
>
impl_
=
=
NULL
)
return
;
pthread_mutex_lock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
if
(
worker
-
>
status_
>
=
AVX_WORKER_STATUS_OK
)
{
while
(
worker
-
>
status_
!
=
AVX_WORKER_STATUS_OK
)
{
pthread_cond_wait
(
&
worker
-
>
impl_
-
>
condition_
&
worker
-
>
impl_
-
>
mutex_
)
;
}
if
(
new_status
!
=
AVX_WORKER_STATUS_OK
)
{
worker
-
>
status_
=
new_status
;
pthread_cond_signal
(
&
worker
-
>
impl_
-
>
condition_
)
;
}
}
pthread_mutex_unlock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
}
#
endif
static
void
init
(
AVxWorker
*
const
worker
)
{
memset
(
worker
0
sizeof
(
*
worker
)
)
;
worker
-
>
status_
=
AVX_WORKER_STATUS_NOT_OK
;
}
static
int
sync
(
AVxWorker
*
const
worker
)
{
#
if
CONFIG_MULTITHREAD
change_state
(
worker
AVX_WORKER_STATUS_OK
)
;
#
endif
assert
(
worker
-
>
status_
<
=
AVX_WORKER_STATUS_OK
)
;
return
!
worker
-
>
had_error
;
}
static
int
reset
(
AVxWorker
*
const
worker
)
{
int
ok
=
1
;
worker
-
>
had_error
=
0
;
if
(
worker
-
>
status_
<
AVX_WORKER_STATUS_OK
)
{
#
if
CONFIG_MULTITHREAD
worker
-
>
impl_
=
(
AVxWorkerImpl
*
)
aom_calloc
(
1
sizeof
(
*
worker
-
>
impl_
)
)
;
if
(
worker
-
>
impl_
=
=
NULL
)
{
return
0
;
}
if
(
pthread_mutex_init
(
&
worker
-
>
impl_
-
>
mutex_
NULL
)
)
{
goto
Error
;
}
if
(
pthread_cond_init
(
&
worker
-
>
impl_
-
>
condition_
NULL
)
)
{
pthread_mutex_destroy
(
&
worker
-
>
impl_
-
>
mutex_
)
;
goto
Error
;
}
pthread_attr_t
attr
;
if
(
pthread_attr_init
(
&
attr
)
)
goto
Error2
;
#
if
defined
(
AOM_ADDRESS_SANITIZER
)
&
&
defined
(
__APPLE__
)
&
&
AOM_ARCH_ARM
&
&
\
!
defined
(
NDEBUG
)
const
size_t
kMinStackSize
=
1024
*
1024
;
#
else
const
size_t
kMinStackSize
=
256
*
1024
;
#
endif
size_t
stacksize
;
if
(
!
pthread_attr_getstacksize
(
&
attr
&
stacksize
)
)
{
if
(
stacksize
<
kMinStackSize
&
&
pthread_attr_setstacksize
(
&
attr
kMinStackSize
)
)
{
pthread_attr_destroy
(
&
attr
)
;
goto
Error2
;
}
}
pthread_mutex_lock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
ok
=
!
pthread_create
(
&
worker
-
>
impl_
-
>
thread_
&
attr
thread_loop
worker
)
;
if
(
ok
)
worker
-
>
status_
=
AVX_WORKER_STATUS_OK
;
pthread_mutex_unlock
(
&
worker
-
>
impl_
-
>
mutex_
)
;
pthread_attr_destroy
(
&
attr
)
;
if
(
!
ok
)
{
Error2
:
pthread_mutex_destroy
(
&
worker
-
>
impl_
-
>
mutex_
)
;
pthread_cond_destroy
(
&
worker
-
>
impl_
-
>
condition_
)
;
Error
:
aom_free
(
worker
-
>
impl_
)
;
worker
-
>
impl_
=
NULL
;
return
0
;
}
#
else
worker
-
>
status_
=
AVX_WORKER_STATUS_OK
;
#
endif
}
else
if
(
worker
-
>
status_
>
AVX_WORKER_STATUS_OK
)
{
ok
=
sync
(
worker
)
;
}
assert
(
!
ok
|
|
(
worker
-
>
status_
=
=
AVX_WORKER_STATUS_OK
)
)
;
return
ok
;
}
static
void
execute
(
AVxWorker
*
const
worker
)
{
if
(
worker
-
>
hook
!
=
NULL
)
{
worker
-
>
had_error
|
=
!
worker
-
>
hook
(
worker
-
>
data1
worker
-
>
data2
)
;
}
}
static
void
launch
(
AVxWorker
*
const
worker
)
{
#
if
CONFIG_MULTITHREAD
change_state
(
worker
AVX_WORKER_STATUS_WORKING
)
;
#
else
execute
(
worker
)
;
#
endif
}
static
void
end
(
AVxWorker
*
const
worker
)
{
#
if
CONFIG_MULTITHREAD
if
(
worker
-
>
impl_
!
=
NULL
)
{
change_state
(
worker
AVX_WORKER_STATUS_NOT_OK
)
;
pthread_join
(
worker
-
>
impl_
-
>
thread_
NULL
)
;
pthread_mutex_destroy
(
&
worker
-
>
impl_
-
>
mutex_
)
;
pthread_cond_destroy
(
&
worker
-
>
impl_
-
>
condition_
)
;
aom_free
(
worker
-
>
impl_
)
;
worker
-
>
impl_
=
NULL
;
}
#
else
worker
-
>
status_
=
AVX_WORKER_STATUS_NOT_OK
;
assert
(
worker
-
>
impl_
=
=
NULL
)
;
#
endif
assert
(
worker
-
>
status_
=
=
AVX_WORKER_STATUS_NOT_OK
)
;
}
static
AVxWorkerInterface
g_worker_interface
=
{
init
reset
sync
launch
execute
end
}
;
int
aom_set_worker_interface
(
const
AVxWorkerInterface
*
const
winterface
)
{
if
(
winterface
=
=
NULL
|
|
winterface
-
>
init
=
=
NULL
|
|
winterface
-
>
reset
=
=
NULL
|
|
winterface
-
>
sync
=
=
NULL
|
|
winterface
-
>
launch
=
=
NULL
|
|
winterface
-
>
execute
=
=
NULL
|
|
winterface
-
>
end
=
=
NULL
)
{
return
0
;
}
g_worker_interface
=
*
winterface
;
return
1
;
}
const
AVxWorkerInterface
*
aom_get_worker_interface
(
void
)
{
return
&
g_worker_interface
;
}
