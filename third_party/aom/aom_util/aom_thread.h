#
ifndef
AOM_AOM_UTIL_AOM_THREAD_H_
#
define
AOM_AOM_UTIL_AOM_THREAD_H_
#
include
"
config
/
aom_config
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
MAX_NUM_THREADS
64
#
if
CONFIG_MULTITHREAD
#
if
defined
(
_WIN32
)
&
&
!
HAVE_PTHREAD_H
#
undef
NOMINMAX
#
define
NOMINMAX
#
undef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
include
<
errno
.
h
>
#
include
<
process
.
h
>
#
include
<
windows
.
h
>
typedef
HANDLE
pthread_t
;
typedef
int
pthread_attr_t
;
typedef
CRITICAL_SECTION
pthread_mutex_t
;
#
if
_WIN32_WINNT
<
0x0600
#
error
_WIN32_WINNT
must
target
Windows
Vista
/
Server
2008
or
newer
.
#
endif
typedef
CONDITION_VARIABLE
pthread_cond_t
;
#
ifndef
WINAPI_FAMILY_PARTITION
#
define
WINAPI_PARTITION_DESKTOP
1
#
define
WINAPI_FAMILY_PARTITION
(
x
)
x
#
endif
#
if
!
WINAPI_FAMILY_PARTITION
(
WINAPI_PARTITION_DESKTOP
)
#
define
USE_CREATE_THREAD
#
endif
#
define
THREADFN
unsigned
int
__stdcall
#
define
THREAD_RETURN
(
val
)
(
unsigned
int
)
(
(
DWORD_PTR
)
val
)
static
INLINE
int
pthread_attr_init
(
pthread_attr_t
*
attr
)
{
(
void
)
attr
;
return
0
;
}
static
INLINE
int
pthread_attr_destroy
(
pthread_attr_t
*
attr
)
{
(
void
)
attr
;
return
0
;
}
static
INLINE
int
pthread_create
(
pthread_t
*
const
thread
const
pthread_attr_t
*
attr
unsigned
int
(
__stdcall
*
start
)
(
void
*
)
void
*
arg
)
{
(
void
)
attr
;
#
ifdef
USE_CREATE_THREAD
*
thread
=
CreateThread
(
NULL
0
start
arg
0
NULL
)
;
#
else
*
thread
=
(
pthread_t
)
_beginthreadex
(
NULL
0
start
arg
0
NULL
)
;
#
endif
if
(
*
thread
=
=
NULL
)
return
1
;
SetThreadPriority
(
*
thread
THREAD_PRIORITY_ABOVE_NORMAL
)
;
return
0
;
}
static
INLINE
int
pthread_join
(
pthread_t
thread
void
*
*
value_ptr
)
{
(
void
)
value_ptr
;
return
(
WaitForSingleObjectEx
(
thread
INFINITE
FALSE
)
!
=
WAIT_OBJECT_0
|
|
CloseHandle
(
thread
)
=
=
0
)
;
}
static
INLINE
int
pthread_mutex_init
(
pthread_mutex_t
*
const
mutex
void
*
mutexattr
)
{
(
void
)
mutexattr
;
InitializeCriticalSectionEx
(
mutex
0
0
)
;
return
0
;
}
static
INLINE
int
pthread_mutex_trylock
(
pthread_mutex_t
*
const
mutex
)
{
return
TryEnterCriticalSection
(
mutex
)
?
0
:
EBUSY
;
}
static
INLINE
int
pthread_mutex_lock
(
pthread_mutex_t
*
const
mutex
)
{
EnterCriticalSection
(
mutex
)
;
return
0
;
}
static
INLINE
int
pthread_mutex_unlock
(
pthread_mutex_t
*
const
mutex
)
{
LeaveCriticalSection
(
mutex
)
;
return
0
;
}
static
INLINE
int
pthread_mutex_destroy
(
pthread_mutex_t
*
const
mutex
)
{
DeleteCriticalSection
(
mutex
)
;
return
0
;
}
static
INLINE
int
pthread_cond_destroy
(
pthread_cond_t
*
const
condition
)
{
(
void
)
condition
;
return
0
;
}
static
INLINE
int
pthread_cond_init
(
pthread_cond_t
*
const
condition
void
*
cond_attr
)
{
(
void
)
cond_attr
;
InitializeConditionVariable
(
condition
)
;
return
0
;
}
static
INLINE
int
pthread_cond_signal
(
pthread_cond_t
*
const
condition
)
{
WakeConditionVariable
(
condition
)
;
return
0
;
}
static
INLINE
int
pthread_cond_broadcast
(
pthread_cond_t
*
const
condition
)
{
WakeAllConditionVariable
(
condition
)
;
return
0
;
}
static
INLINE
int
pthread_cond_wait
(
pthread_cond_t
*
const
condition
pthread_mutex_t
*
const
mutex
)
{
int
ok
;
ok
=
SleepConditionVariableCS
(
condition
mutex
INFINITE
)
;
return
!
ok
;
}
#
else
#
include
<
pthread
.
h
>
#
define
THREADFN
void
*
#
define
THREAD_RETURN
(
val
)
val
#
endif
#
endif
typedef
enum
{
NOT_OK
=
0
OK
WORK
}
AVxWorkerStatus
;
typedef
int
(
*
AVxWorkerHook
)
(
void
*
void
*
)
;
typedef
struct
AVxWorkerImpl
AVxWorkerImpl
;
typedef
struct
{
AVxWorkerImpl
*
impl_
;
AVxWorkerStatus
status_
;
const
char
*
thread_name
;
AVxWorkerHook
hook
;
void
*
data1
;
void
*
data2
;
int
had_error
;
}
AVxWorker
;
typedef
struct
{
void
(
*
init
)
(
AVxWorker
*
const
worker
)
;
int
(
*
reset
)
(
AVxWorker
*
const
worker
)
;
int
(
*
sync
)
(
AVxWorker
*
const
worker
)
;
void
(
*
launch
)
(
AVxWorker
*
const
worker
)
;
void
(
*
execute
)
(
AVxWorker
*
const
worker
)
;
void
(
*
end
)
(
AVxWorker
*
const
worker
)
;
}
AVxWorkerInterface
;
int
aom_set_worker_interface
(
const
AVxWorkerInterface
*
const
winterface
)
;
const
AVxWorkerInterface
*
aom_get_worker_interface
(
void
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
