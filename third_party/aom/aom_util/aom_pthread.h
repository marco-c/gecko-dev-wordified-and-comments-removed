#
ifndef
AOM_AOM_UTIL_AOM_PTHREAD_H_
#
define
AOM_AOM_UTIL_AOM_PTHREAD_H_
#
include
"
config
/
aom_config
.
h
"
#
if
CONFIG_MULTITHREAD
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
if
defined
(
_WIN32
)
&
&
!
HAVE_PTHREAD_H
#
undef
NOMINMAX
#
define
NOMINMAX
#
undef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
include
<
errno
.
h
>
#
include
<
process
.
h
>
#
include
<
stddef
.
h
>
#
include
<
windows
.
h
>
typedef
HANDLE
pthread_t
;
typedef
int
pthread_attr_t
;
typedef
CRITICAL_SECTION
pthread_mutex_t
;
#
include
<
errno
.
h
>
#
if
_WIN32_WINNT
<
0x0600
#
error
_WIN32_WINNT
must
target
Windows
Vista
/
Server
2008
or
newer
.
#
endif
typedef
CONDITION_VARIABLE
pthread_cond_t
;
#
ifndef
WINAPI_FAMILY_PARTITION
#
define
WINAPI_PARTITION_DESKTOP
1
#
define
WINAPI_FAMILY_PARTITION
(
x
)
x
#
endif
#
if
!
WINAPI_FAMILY_PARTITION
(
WINAPI_PARTITION_DESKTOP
)
#
define
USE_CREATE_THREAD
#
endif
#
if
defined
(
__GNUC__
)
&
&
\
(
__GNUC__
>
4
|
|
(
__GNUC__
=
=
4
&
&
__GNUC_MINOR__
>
=
2
)
)
#
define
THREADFN
__attribute__
(
(
force_align_arg_pointer
)
)
unsigned
int
__stdcall
#
else
#
define
THREADFN
unsigned
int
__stdcall
#
endif
#
define
THREAD_EXIT_SUCCESS
0
static
INLINE
int
pthread_attr_init
(
pthread_attr_t
*
attr
)
{
(
void
)
attr
;
return
0
;
}
static
INLINE
int
pthread_attr_destroy
(
pthread_attr_t
*
attr
)
{
(
void
)
attr
;
return
0
;
}
static
INLINE
int
pthread_create
(
pthread_t
*
const
thread
const
pthread_attr_t
*
attr
unsigned
int
(
__stdcall
*
start
)
(
void
*
)
void
*
arg
)
{
(
void
)
attr
;
#
ifdef
USE_CREATE_THREAD
*
thread
=
CreateThread
(
NULL
0
start
arg
0
NULL
)
;
#
else
*
thread
=
(
pthread_t
)
_beginthreadex
(
NULL
0
start
arg
0
NULL
)
;
#
endif
if
(
*
thread
=
=
NULL
)
return
1
;
SetThreadPriority
(
*
thread
THREAD_PRIORITY_ABOVE_NORMAL
)
;
return
0
;
}
static
INLINE
int
pthread_join
(
pthread_t
thread
void
*
*
value_ptr
)
{
(
void
)
value_ptr
;
return
(
WaitForSingleObjectEx
(
thread
INFINITE
FALSE
)
!
=
WAIT_OBJECT_0
|
|
CloseHandle
(
thread
)
=
=
0
)
;
}
static
INLINE
int
pthread_mutex_init
(
pthread_mutex_t
*
const
mutex
void
*
mutexattr
)
{
(
void
)
mutexattr
;
InitializeCriticalSectionEx
(
mutex
0
0
)
;
return
0
;
}
static
INLINE
int
pthread_mutex_trylock
(
pthread_mutex_t
*
const
mutex
)
{
return
TryEnterCriticalSection
(
mutex
)
?
0
:
EBUSY
;
}
static
INLINE
int
pthread_mutex_lock
(
pthread_mutex_t
*
const
mutex
)
{
EnterCriticalSection
(
mutex
)
;
return
0
;
}
static
INLINE
int
pthread_mutex_unlock
(
pthread_mutex_t
*
const
mutex
)
{
LeaveCriticalSection
(
mutex
)
;
return
0
;
}
static
INLINE
int
pthread_mutex_destroy
(
pthread_mutex_t
*
const
mutex
)
{
DeleteCriticalSection
(
mutex
)
;
return
0
;
}
static
INLINE
int
pthread_cond_destroy
(
pthread_cond_t
*
const
condition
)
{
(
void
)
condition
;
return
0
;
}
static
INLINE
int
pthread_cond_init
(
pthread_cond_t
*
const
condition
void
*
cond_attr
)
{
(
void
)
cond_attr
;
InitializeConditionVariable
(
condition
)
;
return
0
;
}
static
INLINE
int
pthread_cond_signal
(
pthread_cond_t
*
const
condition
)
{
WakeConditionVariable
(
condition
)
;
return
0
;
}
static
INLINE
int
pthread_cond_broadcast
(
pthread_cond_t
*
const
condition
)
{
WakeAllConditionVariable
(
condition
)
;
return
0
;
}
static
INLINE
int
pthread_cond_wait
(
pthread_cond_t
*
const
condition
pthread_mutex_t
*
const
mutex
)
{
int
ok
;
ok
=
SleepConditionVariableCS
(
condition
mutex
INFINITE
)
;
return
!
ok
;
}
#
else
#
include
<
pthread
.
h
>
#
define
THREADFN
void
*
#
define
THREAD_EXIT_SUCCESS
NULL
#
endif
#
ifdef
__cplusplus
}
#
endif
#
endif
#
endif
