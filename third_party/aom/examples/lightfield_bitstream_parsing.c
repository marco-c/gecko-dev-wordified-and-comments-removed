#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
aom
/
aom_decoder
.
h
"
#
include
"
aom
/
aom_encoder
.
h
"
#
include
"
aom
/
aom_integer
.
h
"
#
include
"
aom
/
aomdx
.
h
"
#
include
"
aom_dsp
/
bitwriter_buffer
.
h
"
#
include
"
common
/
tools_common
.
h
"
#
include
"
common
/
video_reader
.
h
"
#
include
"
common
/
video_writer
.
h
"
#
define
MAX_TILES
512
static
const
char
*
exec_name
;
void
usage_exit
(
void
)
{
fprintf
(
stderr
"
Usage
:
%
s
<
infile
>
<
outfile
>
<
num_references
>
\
n
"
exec_name
)
;
exit
(
EXIT_FAILURE
)
;
}
#
define
ALIGN_POWER_OF_TWO
(
value
n
)
\
(
(
(
value
)
+
(
(
1
<
<
(
n
)
)
-
1
)
)
&
~
(
(
1
<
<
(
n
)
)
-
1
)
)
const
uint8_t
output_frame_width_in_tiles_minus_1
=
512
/
64
-
1
;
const
uint8_t
output_frame_height_in_tiles_minus_1
=
512
/
64
-
1
;
typedef
struct
{
int
image_idx
;
int
reference_idx
;
int
tile_col
;
int
tile_row
;
}
TILE_LIST_INFO
;
const
int
num_tile_lists
=
2
;
const
uint16_t
tile_count_minus_1
=
9
-
1
;
const
TILE_LIST_INFO
tile_list
[
2
]
[
9
]
=
{
{
{
16
0
4
5
}
{
83
3
13
2
}
{
57
2
2
6
}
{
31
1
11
5
}
{
2
0
7
4
}
{
77
3
9
9
}
{
49
1
0
1
}
{
6
0
3
10
}
{
63
2
5
8
}
}
{
{
65
2
11
1
}
{
42
1
3
7
}
{
88
3
8
4
}
{
76
3
1
15
}
{
1
0
2
2
}
{
19
0
5
6
}
{
60
2
4
0
}
{
25
1
11
15
}
{
50
2
5
4
}
}
}
;
static
int
get_image_bps
(
aom_img_fmt_t
fmt
)
{
switch
(
fmt
)
{
case
AOM_IMG_FMT_I420
:
return
12
;
case
AOM_IMG_FMT_I422
:
return
16
;
case
AOM_IMG_FMT_I444
:
return
24
;
case
AOM_IMG_FMT_I42016
:
return
24
;
case
AOM_IMG_FMT_I42216
:
return
32
;
case
AOM_IMG_FMT_I44416
:
return
48
;
default
:
die
(
"
Invalid
image
format
"
)
;
}
}
int
main
(
int
argc
char
*
*
argv
)
{
aom_codec_ctx_t
codec
;
AvxVideoReader
*
reader
=
NULL
;
AvxVideoWriter
*
writer
=
NULL
;
const
AvxInterface
*
decoder
=
NULL
;
const
AvxVideoInfo
*
info
=
NULL
;
int
num_references
;
int
n
i
;
aom_codec_pts_t
pts
;
exec_name
=
argv
[
0
]
;
if
(
argc
!
=
4
)
die
(
"
Invalid
number
of
arguments
.
"
)
;
reader
=
aom_video_reader_open
(
argv
[
1
]
)
;
if
(
!
reader
)
die
(
"
Failed
to
open
%
s
for
reading
.
"
argv
[
1
]
)
;
num_references
=
(
int
)
strtol
(
argv
[
3
]
NULL
0
)
;
info
=
aom_video_reader_get_info
(
reader
)
;
writer
=
aom_video_writer_open
(
argv
[
2
]
kContainerIVF
info
)
;
if
(
!
writer
)
die
(
"
Failed
to
open
%
s
for
writing
"
argv
[
2
]
)
;
decoder
=
get_aom_decoder_by_fourcc
(
info
-
>
codec_fourcc
)
;
if
(
!
decoder
)
die
(
"
Unknown
input
codec
.
"
)
;
printf
(
"
Using
%
s
\
n
"
aom_codec_iface_name
(
decoder
-
>
codec_interface
(
)
)
)
;
if
(
aom_codec_dec_init
(
&
codec
decoder
-
>
codec_interface
(
)
NULL
0
)
)
die_codec
(
&
codec
"
Failed
to
initialize
decoder
.
"
)
;
aom_codec_control_
(
&
codec
AV1_SET_TILE_MODE
0
)
;
for
(
i
=
0
;
i
<
num_references
;
+
+
i
)
{
aom_video_reader_read_frame
(
reader
)
;
size_t
frame_size
=
0
;
const
unsigned
char
*
frame
=
aom_video_reader_get_frame
(
reader
&
frame_size
)
;
pts
=
(
aom_codec_pts_t
)
aom_video_reader_get_frame_pts
(
reader
)
;
if
(
!
aom_video_writer_write_frame
(
writer
frame
frame_size
pts
)
)
die_codec
(
&
codec
"
Failed
to
copy
compressed
anchor
frame
.
"
)
;
if
(
aom_codec_decode
(
&
codec
frame
frame_size
NULL
)
)
die_codec
(
&
codec
"
Failed
to
decode
frame
.
"
)
;
}
aom_codec_control_
(
&
codec
AV1_SET_TILE_MODE
1
)
;
aom_codec_control_
(
&
codec
AV1D_EXT_TILE_DEBUG
1
)
;
FILE
*
infile
=
aom_video_reader_get_file
(
reader
)
;
const
FileOffset
camera_frame_pos
=
ftello
(
infile
)
;
aom_video_reader_read_frame
(
reader
)
;
{
size_t
frame_size
=
0
;
const
unsigned
char
*
frame
=
aom_video_reader_get_frame
(
reader
&
frame_size
)
;
pts
=
(
aom_codec_pts_t
)
aom_video_reader_get_frame_pts
(
reader
)
;
aom_tile_data
frame_header_info
=
{
0
NULL
0
}
;
aom_codec_control_
(
&
codec
AV1_SET_DECODE_TILE_ROW
0
)
;
aom_codec_control_
(
&
codec
AV1_SET_DECODE_TILE_COL
0
)
;
aom_codec_err_t
aom_status
=
aom_codec_decode
(
&
codec
frame
frame_size
NULL
)
;
if
(
aom_status
)
die_codec
(
&
codec
"
Failed
to
decode
tile
.
"
)
;
aom_codec_control_
(
&
codec
AV1D_GET_FRAME_HEADER_INFO
&
frame_header_info
)
;
size_t
obu_size_offset
=
(
uint8_t
*
)
frame_header_info
.
coded_tile_data
-
frame
;
size_t
length_field_size
=
frame_header_info
.
coded_tile_data_size
;
uint32_t
frame_header_size
=
(
uint32_t
)
frame_header_info
.
extra_size
-
1
;
size_t
bytes_to_copy
=
obu_size_offset
+
length_field_size
+
frame_header_size
;
unsigned
char
*
frame_hdr_buf
=
(
unsigned
char
*
)
malloc
(
bytes_to_copy
)
;
if
(
frame_hdr_buf
=
=
NULL
)
die_codec
(
&
codec
"
Failed
to
allocate
frame
header
buffer
.
"
)
;
memcpy
(
frame_hdr_buf
frame
bytes_to_copy
)
;
size_t
bytes_written
=
0
;
if
(
aom_uleb_encode_fixed_size
(
frame_header_size
length_field_size
length_field_size
frame_hdr_buf
+
obu_size_offset
&
bytes_written
)
)
die_codec
(
&
codec
"
Failed
to
encode
the
tile
list
obu
size
.
"
)
;
if
(
!
aom_video_writer_write_frame
(
writer
frame_hdr_buf
bytes_to_copy
pts
)
)
die_codec
(
&
codec
"
Failed
to
copy
compressed
camera
frame
header
.
"
)
;
}
aom_img_fmt_t
ref_fmt
=
0
;
if
(
aom_codec_control
(
&
codec
AV1D_GET_IMG_FORMAT
&
ref_fmt
)
)
die_codec
(
&
codec
"
Failed
to
get
the
image
format
"
)
;
const
int
bps
=
get_image_bps
(
ref_fmt
)
;
unsigned
int
tile_size
=
0
;
if
(
aom_codec_control
(
&
codec
AV1D_GET_TILE_SIZE
&
tile_size
)
)
die_codec
(
&
codec
"
Failed
to
get
the
tile
size
"
)
;
const
unsigned
int
tile_width
=
tile_size
>
>
16
;
const
unsigned
int
tile_height
=
tile_size
&
65535
;
const
size_t
data_sz
=
MAX_TILES
*
ALIGN_POWER_OF_TWO
(
tile_width
5
)
*
ALIGN_POWER_OF_TWO
(
tile_height
5
)
*
bps
/
8
;
unsigned
char
*
tl_buf
=
(
unsigned
char
*
)
malloc
(
data_sz
)
;
if
(
tl_buf
=
=
NULL
)
die_codec
(
&
codec
"
Failed
to
allocate
tile
list
buffer
.
"
)
;
aom_codec_pts_t
tl_pts
=
pts
;
for
(
n
=
0
;
n
<
num_tile_lists
;
n
+
+
)
{
unsigned
char
*
tl
=
tl_buf
;
struct
aom_write_bit_buffer
wb
=
{
tl
0
}
;
unsigned
char
*
saved_obu_size_loc
=
NULL
;
uint32_t
tile_list_obu_header_size
=
0
;
uint32_t
tile_list_obu_size
=
0
;
aom_wb_write_literal
(
&
wb
0
1
)
;
aom_wb_write_literal
(
&
wb
8
4
)
;
aom_wb_write_literal
(
&
wb
0
1
)
;
aom_wb_write_literal
(
&
wb
1
1
)
;
aom_wb_write_literal
(
&
wb
0
1
)
;
tl
+
+
;
tile_list_obu_header_size
+
+
;
saved_obu_size_loc
=
tl
;
aom_wb_write_unsigned_literal
(
&
wb
0
32
)
;
tl
+
=
4
;
tile_list_obu_header_size
+
=
4
;
aom_wb_write_literal
(
&
wb
output_frame_width_in_tiles_minus_1
8
)
;
aom_wb_write_literal
(
&
wb
output_frame_height_in_tiles_minus_1
8
)
;
aom_wb_write_literal
(
&
wb
tile_count_minus_1
16
)
;
tl
+
=
4
;
tile_list_obu_size
+
=
4
;
for
(
i
=
0
;
i
<
=
tile_count_minus_1
;
i
+
+
)
{
aom_tile_data
tile_data
=
{
0
NULL
0
}
;
int
image_idx
=
tile_list
[
n
]
[
i
]
.
image_idx
;
int
ref_idx
=
tile_list
[
n
]
[
i
]
.
reference_idx
;
int
tc
=
tile_list
[
n
]
[
i
]
.
tile_col
;
int
tr
=
tile_list
[
n
]
[
i
]
.
tile_row
;
int
frame_cnt
=
-
1
;
wb
.
bit_buffer
=
tl
;
wb
.
bit_offset
=
0
;
fseeko
(
infile
camera_frame_pos
SEEK_SET
)
;
while
(
frame_cnt
!
=
image_idx
)
{
aom_video_reader_read_frame
(
reader
)
;
frame_cnt
+
+
;
}
size_t
frame_size
=
0
;
const
unsigned
char
*
frame
=
aom_video_reader_get_frame
(
reader
&
frame_size
)
;
aom_codec_control_
(
&
codec
AV1_SET_DECODE_TILE_ROW
tr
)
;
aom_codec_control_
(
&
codec
AV1_SET_DECODE_TILE_COL
tc
)
;
aom_codec_err_t
aom_status
=
aom_codec_decode
(
&
codec
frame
frame_size
NULL
)
;
if
(
aom_status
)
die_codec
(
&
codec
"
Failed
to
decode
tile
.
"
)
;
aom_codec_control_
(
&
codec
AV1D_GET_TILE_DATA
&
tile_data
)
;
uint32_t
tile_info_bytes
=
5
;
aom_wb_write_literal
(
&
wb
ref_idx
8
)
;
aom_wb_write_literal
(
&
wb
tr
8
)
;
aom_wb_write_literal
(
&
wb
tc
8
)
;
aom_wb_write_literal
(
&
wb
(
int
)
tile_data
.
coded_tile_data_size
-
1
16
)
;
tl
+
=
tile_info_bytes
;
memcpy
(
tl
(
uint8_t
*
)
tile_data
.
coded_tile_data
tile_data
.
coded_tile_data_size
)
;
tl
+
=
tile_data
.
coded_tile_data_size
;
tile_list_obu_size
+
=
tile_info_bytes
+
(
uint32_t
)
tile_data
.
coded_tile_data_size
;
}
size_t
bytes_written
=
0
;
if
(
aom_uleb_encode_fixed_size
(
tile_list_obu_size
4
4
saved_obu_size_loc
&
bytes_written
)
)
die_codec
(
&
codec
"
Failed
to
encode
the
tile
list
obu
size
.
"
)
;
if
(
!
aom_video_writer_write_frame
(
writer
tl_buf
tile_list_obu_header_size
+
tile_list_obu_size
tl_pts
)
)
die_codec
(
&
codec
"
Failed
to
copy
compressed
tile
list
.
"
)
;
tl_pts
+
+
;
}
free
(
tl_buf
)
;
if
(
aom_codec_destroy
(
&
codec
)
)
die_codec
(
&
codec
"
Failed
to
destroy
codec
"
)
;
aom_video_writer_close
(
writer
)
;
aom_video_reader_close
(
reader
)
;
return
EXIT_SUCCESS
;
}
