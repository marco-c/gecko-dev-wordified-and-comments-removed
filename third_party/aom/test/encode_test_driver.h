#
ifndef
AOM_TEST_ENCODE_TEST_DRIVER_H_
#
define
AOM_TEST_ENCODE_TEST_DRIVER_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
config
/
aom_config
.
h
"
#
if
CONFIG_AV1_ENCODER
#
include
"
aom
/
aomcx
.
h
"
#
endif
#
include
"
aom
/
aom_encoder
.
h
"
namespace
libaom_test
{
class
CodecFactory
;
class
VideoSource
;
enum
TestMode
{
kRealTime
kOnePassGood
kTwoPassGood
kAllIntra
}
;
#
define
ALL_TEST_MODES
\
:
:
testing
:
:
Values
(
:
:
libaom_test
:
:
kRealTime
:
:
libaom_test
:
:
kOnePassGood
\
:
:
libaom_test
:
:
kTwoPassGood
)
#
define
ONE_PASS_TEST_MODES
\
:
:
testing
:
:
Values
(
:
:
libaom_test
:
:
kRealTime
:
:
libaom_test
:
:
kOnePassGood
)
#
define
TWO_PASS_TEST_MODES
:
:
testing
:
:
Values
(
:
:
libaom_test
:
:
kTwoPassGood
)
#
define
NONREALTIME_TEST_MODES
\
:
:
testing
:
:
Values
(
:
:
libaom_test
:
:
kOnePassGood
:
:
libaom_test
:
:
kTwoPassGood
)
class
CxDataIterator
{
public
:
explicit
CxDataIterator
(
aom_codec_ctx_t
*
encoder
)
:
encoder_
(
encoder
)
iter_
(
nullptr
)
{
}
const
aom_codec_cx_pkt_t
*
Next
(
)
{
return
aom_codec_get_cx_data
(
encoder_
&
iter_
)
;
}
private
:
aom_codec_ctx_t
*
encoder_
;
aom_codec_iter_t
iter_
;
}
;
class
TwopassStatsStore
{
public
:
void
Append
(
const
aom_codec_cx_pkt_t
&
pkt
)
{
buffer_
.
append
(
reinterpret_cast
<
char
*
>
(
pkt
.
data
.
twopass_stats
.
buf
)
pkt
.
data
.
twopass_stats
.
sz
)
;
}
aom_fixed_buf_t
buf
(
)
{
const
aom_fixed_buf_t
buf
=
{
&
buffer_
[
0
]
buffer_
.
size
(
)
}
;
return
buf
;
}
void
Reset
(
)
{
buffer_
.
clear
(
)
;
}
protected
:
std
:
:
string
buffer_
;
}
;
class
Encoder
{
public
:
Encoder
(
aom_codec_enc_cfg_t
cfg
const
aom_codec_flags_t
init_flags
TwopassStatsStore
*
stats
)
:
cfg_
(
cfg
)
init_flags_
(
init_flags
)
stats_
(
stats
)
{
memset
(
&
encoder_
0
sizeof
(
encoder_
)
)
;
}
virtual
~
Encoder
(
)
{
aom_codec_destroy
(
&
encoder_
)
;
}
CxDataIterator
GetCxData
(
)
{
return
CxDataIterator
(
&
encoder_
)
;
}
void
InitEncoder
(
VideoSource
*
video
)
;
const
aom_image_t
*
GetPreviewFrame
(
)
{
return
aom_codec_get_preview_frame
(
&
encoder_
)
;
}
void
EncodeFrame
(
VideoSource
*
video
aom_enc_frame_flags_t
frame_flags
)
;
void
EncodeFrame
(
VideoSource
*
video
)
{
EncodeFrame
(
video
0
)
;
}
void
Control
(
int
ctrl_id
int
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
int
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
struct
aom_scaling_mode
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
struct
aom_svc_layer_id
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
struct
aom_svc_ref_frame_config
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
struct
aom_svc_ref_frame_comp_pred
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
struct
aom_svc_params
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Control
(
int
ctrl_id
struct
aom_ext_part_funcs
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
#
if
CONFIG_AV1_ENCODER
void
Control
(
int
ctrl_id
aom_active_map_t
*
arg
)
{
const
aom_codec_err_t
res
=
aom_codec_control
(
&
encoder_
ctrl_id
arg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
#
endif
void
SetOption
(
const
char
*
name
const
char
*
value
)
{
const
aom_codec_err_t
res
=
aom_codec_set_option
(
&
encoder_
name
value
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
}
void
Config
(
const
aom_codec_enc_cfg_t
*
cfg
)
{
const
aom_codec_err_t
res
=
aom_codec_enc_config_set
(
&
encoder_
cfg
)
;
ASSERT_EQ
(
AOM_CODEC_OK
res
)
<
<
EncoderError
(
)
;
cfg_
=
*
cfg
;
}
protected
:
virtual
aom_codec_iface_t
*
CodecInterface
(
)
const
=
0
;
const
char
*
EncoderError
(
)
{
const
char
*
detail
=
aom_codec_error_detail
(
&
encoder_
)
;
return
detail
?
detail
:
aom_codec_error
(
&
encoder_
)
;
}
void
EncodeFrameInternal
(
const
VideoSource
&
video
aom_enc_frame_flags_t
frame_flags
)
;
void
Flush
(
)
;
aom_codec_ctx_t
encoder_
;
aom_codec_enc_cfg_t
cfg_
;
aom_codec_flags_t
init_flags_
;
TwopassStatsStore
*
stats_
;
}
;
class
EncoderTest
{
protected
:
explicit
EncoderTest
(
const
CodecFactory
*
codec
)
:
codec_
(
codec
)
abort_
(
false
)
init_flags_
(
0
)
frame_flags_
(
0
)
mode_
(
kRealTime
)
{
cfg_
.
g_threads
=
1
;
}
virtual
~
EncoderTest
(
)
=
default
;
void
InitializeConfig
(
TestMode
mode
)
;
void
set_init_flags
(
aom_codec_flags_t
flag
)
{
init_flags_
=
flag
;
}
virtual
void
RunLoop
(
VideoSource
*
video
)
;
virtual
void
BeginPassHook
(
unsigned
int
)
{
}
virtual
void
EndPassHook
(
)
{
}
virtual
void
PreEncodeFrameHook
(
VideoSource
*
Encoder
*
)
{
}
virtual
void
PostEncodeFrameHook
(
Encoder
*
)
{
}
virtual
void
FramePktHook
(
const
aom_codec_cx_pkt_t
*
)
{
}
virtual
void
PSNRPktHook
(
const
aom_codec_cx_pkt_t
*
)
{
}
virtual
void
StatsPktHook
(
const
aom_codec_cx_pkt_t
*
)
{
}
virtual
void
CalculateFrameLevelSSIM
(
const
aom_image_t
*
const
aom_image_t
*
aom_bit_depth_t
unsigned
int
)
{
}
virtual
bool
Continue
(
)
const
{
return
!
(
:
:
testing
:
:
Test
:
:
HasFatalFailure
(
)
|
|
abort_
)
;
}
virtual
bool
DoDecode
(
)
const
{
return
true
;
}
virtual
bool
DoDecodeInvisible
(
)
const
{
return
true
;
}
virtual
void
MismatchHook
(
const
aom_image_t
*
img1
const
aom_image_t
*
img2
)
;
virtual
void
DecompressedFrameHook
(
const
aom_image_t
&
aom_codec_pts_t
)
{
}
virtual
bool
HandleDecodeResult
(
const
aom_codec_err_t
res_dec
Decoder
*
decoder
)
{
EXPECT_EQ
(
AOM_CODEC_OK
res_dec
)
<
<
decoder
-
>
DecodeError
(
)
;
return
AOM_CODEC_OK
=
=
res_dec
;
}
virtual
int
GetNumSpatialLayers
(
)
{
return
1
;
}
virtual
const
aom_codec_cx_pkt_t
*
MutateEncoderOutputHook
(
const
aom_codec_cx_pkt_t
*
pkt
)
{
return
pkt
;
}
const
CodecFactory
*
codec_
;
bool
abort_
;
aom_codec_enc_cfg_t
cfg_
;
unsigned
int
passes_
;
TwopassStatsStore
stats_
;
aom_codec_flags_t
init_flags_
;
aom_enc_frame_flags_t
frame_flags_
;
TestMode
mode_
;
}
;
}
#
endif
