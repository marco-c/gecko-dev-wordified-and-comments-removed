#
ifndef
AOM_AV1_ENCODER_ENCODE_STRATEGY_H_
#
define
AOM_AV1_ENCODER_ENCODE_STRATEGY_H_
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
include
<
stdint
.
h
>
#
include
"
aom
/
aom_encoder
.
h
"
#
include
"
av1
/
encoder
/
encoder
.
h
"
#
include
"
av1
/
encoder
/
firstpass
.
h
"
int
av1_encode_strategy
(
AV1_COMP
*
const
cpi
size_t
*
const
size
uint8_t
*
const
dest
unsigned
int
*
frame_flags
int64_t
*
const
time_stamp
int64_t
*
const
time_end
const
aom_rational64_t
*
const
timestamp_ratio
int
*
const
pop_lookahead
int
flush
)
;
void
av1_configure_buffer_updates
(
AV1_COMP
*
const
cpi
RefreshFrameInfo
*
const
refresh_frame
const
FRAME_UPDATE_TYPE
type
const
REFBUF_STATE
refbuf_state
int
force_refresh_all
)
;
int
av1_get_refresh_frame_flags
(
const
AV1_COMP
*
const
cpi
const
EncodeFrameParams
*
const
frame_params
FRAME_UPDATE_TYPE
frame_update_type
int
gf_index
int
cur_disp_order
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
)
;
int
av1_get_refresh_ref_frame_map
(
int
refresh_frame_flags
)
;
void
av1_get_ref_frames
(
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
int
cur_frame_disp
const
AV1_COMP
*
cpi
int
gf_index
int
is_parallel_encode
int
remapped_ref_idx
[
REF_FRAMES
]
)
;
int
is_forced_keyframe_pending
(
struct
lookahead_ctx
*
lookahead
const
int
up_to_index
const
COMPRESSOR_STAGE
compressor_stage
)
;
static
AOM_INLINE
int
is_frame_droppable
(
const
RTC_REF
*
const
rtc_ref
const
ExtRefreshFrameFlagsInfo
*
const
ext_refresh_frame_flags
)
{
if
(
rtc_ref
-
>
set_ref_frame_config
)
return
rtc_ref
-
>
non_reference_frame
;
else
if
(
ext_refresh_frame_flags
-
>
update_pending
)
return
!
(
ext_refresh_frame_flags
-
>
alt_ref_frame
|
|
ext_refresh_frame_flags
-
>
alt2_ref_frame
|
|
ext_refresh_frame_flags
-
>
bwd_ref_frame
|
|
ext_refresh_frame_flags
-
>
golden_frame
|
|
ext_refresh_frame_flags
-
>
last_frame
)
;
else
return
0
;
}
static
AOM_INLINE
int
get_current_frame_ref_type
(
const
AV1_COMP
*
const
cpi
)
{
switch
(
cpi
-
>
ppi
-
>
gf_group
.
layer_depth
[
cpi
-
>
gf_frame_index
]
)
{
case
0
:
return
0
;
case
1
:
return
1
;
case
MAX_ARF_LAYERS
:
case
MAX_ARF_LAYERS
+
1
:
return
4
;
default
:
return
7
;
}
}
int
av1_calc_refresh_idx_for_intnl_arf
(
AV1_COMP
*
cpi
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
int
gf_index
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
