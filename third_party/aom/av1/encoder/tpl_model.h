#
ifndef
AOM_AV1_ENCODER_TPL_MODEL_H_
#
define
AOM_AV1_ENCODER_TPL_MODEL_H_
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
struct
AV1_PRIMARY
;
struct
AV1_COMP
;
struct
AV1_SEQ_CODING_TOOLS
;
struct
EncodeFrameParams
;
struct
EncodeFrameInput
;
struct
GF_GROUP
;
struct
ThreadData
;
struct
TPL_INFO
;
#
include
"
config
/
aom_config
.
h
"
#
include
"
aom_scale
/
yv12config
.
h
"
#
include
"
aom_util
/
aom_pthread
.
h
"
#
include
"
av1
/
common
/
mv
.
h
"
#
include
"
av1
/
common
/
scale
.
h
"
#
include
"
av1
/
encoder
/
block
.
h
"
#
include
"
av1
/
encoder
/
lookahead
.
h
"
#
include
"
av1
/
encoder
/
ratectrl
.
h
"
static
INLINE
BLOCK_SIZE
convert_length_to_bsize
(
int
length
)
{
switch
(
length
)
{
case
64
:
return
BLOCK_64X64
;
case
32
:
return
BLOCK_32X32
;
case
16
:
return
BLOCK_16X16
;
case
8
:
return
BLOCK_8X8
;
case
4
:
return
BLOCK_4X4
;
default
:
assert
(
0
&
&
"
Invalid
block
size
for
tpl
model
"
)
;
return
BLOCK_16X16
;
}
}
typedef
struct
AV1TplRowMultiThreadSync
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
*
mutex_
;
pthread_cond_t
*
cond_
;
#
endif
int
*
num_finished_cols
;
int
sync_range
;
int
rows
;
int
num_threads_working
;
}
AV1TplRowMultiThreadSync
;
typedef
struct
AV1TplRowMultiThreadInfo
{
bool
tpl_mt_exit
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
*
mutex_
;
#
endif
void
(
*
sync_read_ptr
)
(
AV1TplRowMultiThreadSync
*
tpl_mt_sync
int
r
int
c
)
;
void
(
*
sync_write_ptr
)
(
AV1TplRowMultiThreadSync
*
tpl_mt_sync
int
r
int
c
int
cols
)
;
}
AV1TplRowMultiThreadInfo
;
#
define
MAX_TPL_FRAME_IDX
(
2
*
MAX_LAG_BUFFERS
)
#
define
MAX_LENGTH_TPL_FRAME_STATS
(
MAX_TPL_FRAME_IDX
+
REF_FRAMES
+
1
)
#
define
TPL_DEP_COST_SCALE_LOG2
4
#
define
TPL_EPSILON
0
.
0000001
typedef
struct
TplTxfmStats
{
int
ready
;
double
abs_coeff_sum
[
256
]
;
double
abs_coeff_mean
[
256
]
;
int
txfm_block_count
;
int
coeff_num
;
}
TplTxfmStats
;
typedef
struct
{
uint8_t
*
predictor8
;
int16_t
*
src_diff
;
tran_low_t
*
coeff
;
tran_low_t
*
qcoeff
;
tran_low_t
*
dqcoeff
;
}
TplBuffers
;
typedef
struct
TplDepStats
{
int64_t
srcrf_sse
;
int64_t
srcrf_dist
;
int64_t
recrf_sse
;
int64_t
recrf_dist
;
int64_t
intra_sse
;
int64_t
intra_dist
;
int64_t
cmp_recrf_dist
[
2
]
;
int64_t
mc_dep_rate
;
int64_t
mc_dep_dist
;
int64_t
pred_error
[
INTER_REFS_PER_FRAME
]
;
int32_t
intra_cost
;
int32_t
inter_cost
;
int32_t
srcrf_rate
;
int32_t
recrf_rate
;
int32_t
intra_rate
;
int32_t
cmp_recrf_rate
[
2
]
;
int_mv
mv
[
INTER_REFS_PER_FRAME
]
;
int8_t
ref_frame_index
[
2
]
;
}
TplDepStats
;
typedef
struct
TplDepFrame
{
uint8_t
is_valid
;
TplDepStats
*
tpl_stats_ptr
;
const
YV12_BUFFER_CONFIG
*
gf_picture
;
YV12_BUFFER_CONFIG
*
rec_picture
;
int
ref_map_index
[
REF_FRAMES
]
;
int
stride
;
int
width
;
int
height
;
int
mi_rows
;
int
mi_cols
;
int
base_rdmult
;
uint32_t
frame_display_index
;
int
use_pred_sad
;
}
TplDepFrame
;
typedef
struct
TplParams
{
int
ready
;
uint8_t
tpl_stats_block_mis_log2
;
uint8_t
tpl_bsize_1d
;
TplDepFrame
tpl_stats_buffer
[
MAX_LENGTH_TPL_FRAME_STATS
]
;
TplDepStats
*
tpl_stats_pool
[
MAX_LAG_BUFFERS
]
;
TplTxfmStats
*
txfm_stats_list
;
YV12_BUFFER_CONFIG
tpl_rec_pool
[
MAX_LAG_BUFFERS
]
;
TplDepFrame
*
tpl_frame
;
struct
scale_factors
sf
;
int
frame_idx
;
const
YV12_BUFFER_CONFIG
*
src_ref_frame
[
INTER_REFS_PER_FRAME
]
;
const
YV12_BUFFER_CONFIG
*
ref_frame
[
INTER_REFS_PER_FRAME
]
;
AV1TplRowMultiThreadSync
tpl_mt_sync
;
int
border_in_pixels
;
double
r0_adjust_factor
;
}
TplParams
;
#
if
CONFIG_BITRATE_ACCURACY
|
|
CONFIG_RATECTRL_LOG
#
define
VBR_RC_INFO_MAX_FRAMES
500
#
endif
#
if
CONFIG_BITRATE_ACCURACY
typedef
struct
{
int
ready
;
double
total_bit_budget
;
int
show_frame_count
;
int
gop_showframe_count
;
double
gop_bit_budget
;
double
scale_factors
[
FRAME_UPDATE_TYPES
]
;
double
mv_scale_factors
[
FRAME_UPDATE_TYPES
]
;
int
base_q_index
;
int
q_index_list_ready
;
int
q_index_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
double
qstep_ratio_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
#
if
CONFIG_THREE_PASS
TplTxfmStats
txfm_stats_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
FRAME_UPDATE_TYPE
update_type_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
int
gop_start_idx_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
int
gop_length_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
int
cur_gop_idx
;
int
total_frame_count
;
int
gop_count
;
#
endif
}
VBR_RATECTRL_INFO
;
static
INLINE
void
vbr_rc_reset_gop_data
(
VBR_RATECTRL_INFO
*
vbr_rc_info
)
{
vbr_rc_info
-
>
q_index_list_ready
=
0
;
av1_zero
(
vbr_rc_info
-
>
q_index_list
)
;
}
void
av1_vbr_rc_init
(
VBR_RATECTRL_INFO
*
vbr_rc_info
double
total_bit_budget
int
show_frame_count
)
;
int
av1_vbr_rc_frame_coding_idx
(
const
VBR_RATECTRL_INFO
*
vbr_rc_info
int
gf_frame_index
)
;
void
av1_vbr_rc_append_tpl_info
(
VBR_RATECTRL_INFO
*
vbr_rc_info
const
struct
TPL_INFO
*
tpl_info
)
;
void
av1_vbr_rc_set_gop_bit_budget
(
VBR_RATECTRL_INFO
*
vbr_rc_info
int
gop_showframe_count
)
;
void
av1_vbr_rc_compute_q_indices
(
int
base_q_index
int
frame_count
const
double
*
qstep_ratio_list
aom_bit_depth_t
bit_depth
int
*
q_index_list
)
;
void
av1_vbr_rc_update_q_index_list
(
VBR_RATECTRL_INFO
*
vbr_rc_info
const
TplParams
*
tpl_data
const
struct
GF_GROUP
*
gf_group
aom_bit_depth_t
bit_depth
)
;
double
av1_vbr_rc_info_estimate_gop_bitrate
(
int
base_q_index
aom_bit_depth_t
bit_depth
const
double
*
update_type_scale_factors
int
frame_count
const
FRAME_UPDATE_TYPE
*
update_type_list
const
double
*
qstep_ratio_list
const
TplTxfmStats
*
stats_list
int
*
q_index_list
double
*
estimated_bitrate_byframe
)
;
int
av1_vbr_rc_info_estimate_base_q
(
double
bit_budget
aom_bit_depth_t
bit_depth
const
double
*
update_type_scale_factors
int
frame_count
const
FRAME_UPDATE_TYPE
*
update_type_list
const
double
*
qstep_ratio_list
const
TplTxfmStats
*
stats_list
int
*
q_index_list
double
*
estimated_bitrate_byframe
)
;
#
endif
#
if
CONFIG_RD_COMMAND
typedef
enum
{
RD_OPTION_NONE
RD_OPTION_SET_Q
RD_OPTION_SET_Q_RDMULT
}
RD_OPTION
;
typedef
struct
RD_COMMAND
{
RD_OPTION
option_ls
[
MAX_LENGTH_TPL_FRAME_STATS
]
;
int
q_index_ls
[
MAX_LENGTH_TPL_FRAME_STATS
]
;
int
rdmult_ls
[
MAX_LENGTH_TPL_FRAME_STATS
]
;
int
frame_count
;
int
frame_index
;
}
RD_COMMAND
;
void
av1_read_rd_command
(
const
char
*
filepath
RD_COMMAND
*
rd_command
)
;
#
endif
void
av1_setup_tpl_buffers
(
struct
AV1_PRIMARY
*
const
ppi
CommonModeInfoParams
*
const
mi_params
int
width
int
height
int
byte_alignment
int
lag_in_frames
)
;
static
AOM_INLINE
void
tpl_dealloc_temp_buffers
(
TplBuffers
*
tpl_tmp_buffers
)
{
aom_free
(
tpl_tmp_buffers
-
>
predictor8
)
;
tpl_tmp_buffers
-
>
predictor8
=
NULL
;
aom_free
(
tpl_tmp_buffers
-
>
src_diff
)
;
tpl_tmp_buffers
-
>
src_diff
=
NULL
;
aom_free
(
tpl_tmp_buffers
-
>
coeff
)
;
tpl_tmp_buffers
-
>
coeff
=
NULL
;
aom_free
(
tpl_tmp_buffers
-
>
qcoeff
)
;
tpl_tmp_buffers
-
>
qcoeff
=
NULL
;
aom_free
(
tpl_tmp_buffers
-
>
dqcoeff
)
;
tpl_tmp_buffers
-
>
dqcoeff
=
NULL
;
}
static
AOM_INLINE
bool
tpl_alloc_temp_buffers
(
TplBuffers
*
tpl_tmp_buffers
uint8_t
tpl_bsize_1d
)
{
const
int
tpl_block_pels
=
tpl_bsize_1d
*
tpl_bsize_1d
;
tpl_tmp_buffers
-
>
predictor8
=
(
uint8_t
*
)
aom_memalign
(
32
tpl_block_pels
*
2
*
sizeof
(
*
tpl_tmp_buffers
-
>
predictor8
)
)
;
tpl_tmp_buffers
-
>
src_diff
=
(
int16_t
*
)
aom_memalign
(
32
tpl_block_pels
*
sizeof
(
*
tpl_tmp_buffers
-
>
src_diff
)
)
;
tpl_tmp_buffers
-
>
coeff
=
(
tran_low_t
*
)
aom_memalign
(
32
tpl_block_pels
*
sizeof
(
*
tpl_tmp_buffers
-
>
coeff
)
)
;
tpl_tmp_buffers
-
>
qcoeff
=
(
tran_low_t
*
)
aom_memalign
(
32
tpl_block_pels
*
sizeof
(
*
tpl_tmp_buffers
-
>
qcoeff
)
)
;
tpl_tmp_buffers
-
>
dqcoeff
=
(
tran_low_t
*
)
aom_memalign
(
32
tpl_block_pels
*
sizeof
(
*
tpl_tmp_buffers
-
>
dqcoeff
)
)
;
if
(
!
(
tpl_tmp_buffers
-
>
predictor8
&
&
tpl_tmp_buffers
-
>
src_diff
&
&
tpl_tmp_buffers
-
>
coeff
&
&
tpl_tmp_buffers
-
>
qcoeff
&
&
tpl_tmp_buffers
-
>
dqcoeff
)
)
{
tpl_dealloc_temp_buffers
(
tpl_tmp_buffers
)
;
return
false
;
}
return
true
;
}
int
av1_tpl_setup_stats
(
struct
AV1_COMP
*
cpi
int
gop_eval
const
struct
EncodeFrameParams
*
const
frame_params
)
;
void
av1_tpl_preload_rc_estimate
(
struct
AV1_COMP
*
cpi
const
struct
EncodeFrameParams
*
const
frame_params
)
;
int
av1_tpl_ptr_pos
(
int
mi_row
int
mi_col
int
stride
uint8_t
right_shift
)
;
void
av1_init_tpl_stats
(
TplParams
*
const
tpl_data
)
;
int
av1_tpl_stats_ready
(
const
TplParams
*
tpl_data
int
gf_frame_index
)
;
void
av1_tpl_rdmult_setup
(
struct
AV1_COMP
*
cpi
)
;
void
av1_tpl_rdmult_setup_sb
(
struct
AV1_COMP
*
cpi
MACROBLOCK
*
const
x
BLOCK_SIZE
sb_size
int
mi_row
int
mi_col
)
;
void
av1_mc_flow_dispenser_row
(
struct
AV1_COMP
*
cpi
TplTxfmStats
*
tpl_txfm_stats
TplBuffers
*
tpl_tmp_buffers
MACROBLOCK
*
x
int
mi_row
BLOCK_SIZE
bsize
TX_SIZE
tx_size
)
;
double
av1_exponential_entropy
(
double
q_step
double
b
)
;
double
av1_laplace_entropy
(
double
q_step
double
b
double
zero_bin_ratio
)
;
double
av1_laplace_estimate_frame_rate
(
int
q_index
int
block_count
const
double
*
abs_coeff_mean
int
coeff_num
)
;
void
av1_init_tpl_txfm_stats
(
TplTxfmStats
*
tpl_txfm_stats
)
;
#
if
CONFIG_BITRATE_ACCURACY
void
av1_accumulate_tpl_txfm_stats
(
const
TplTxfmStats
*
sub_stats
TplTxfmStats
*
accumulated_stats
)
;
void
av1_record_tpl_txfm_block
(
TplTxfmStats
*
tpl_txfm_stats
const
tran_low_t
*
coeff
)
;
void
av1_tpl_txfm_stats_update_abs_coeff_mean
(
TplTxfmStats
*
txfm_stats
)
;
#
endif
double
av1_estimate_coeff_entropy
(
double
q_step
double
b
double
zero_bin_ratio
int
qcoeff
)
;
double
av1_estimate_txfm_block_entropy
(
int
q_index
const
double
*
abs_coeff_mean
int
*
qcoeff_arr
int
coeff_num
)
;
int64_t
av1_delta_rate_cost
(
int64_t
delta_rate
int64_t
recrf_dist
int64_t
srcrf_dist
int
pix_num
)
;
int
av1_get_overlap_area
(
int
row_a
int
col_a
int
row_b
int
col_b
int
width
int
height
)
;
int
av1_tpl_get_q_index
(
const
TplParams
*
tpl_data
int
gf_frame_index
int
leaf_qindex
aom_bit_depth_t
bit_depth
)
;
double
av1_tpl_get_frame_importance
(
const
TplParams
*
tpl_data
int
gf_frame_index
)
;
double
av1_tpl_get_qstep_ratio
(
const
TplParams
*
tpl_data
int
gf_frame_index
)
;
int
av1_get_q_index_from_qstep_ratio
(
int
leaf_qindex
double
qstep_ratio
aom_bit_depth_t
bit_depth
)
;
int_mv
av1_compute_mv_difference
(
const
TplDepFrame
*
tpl_frame
int
row
int
col
int
step
int
tpl_stride
int
right_shift
)
;
double
av1_tpl_compute_frame_mv_entropy
(
const
TplDepFrame
*
tpl_frame
uint8_t
right_shift
)
;
#
if
CONFIG_RATECTRL_LOG
typedef
struct
{
int
coding_frame_count
;
int
base_q_index
;
int
q_index_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
double
qstep_ratio_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
FRAME_UPDATE_TYPE
update_type_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
TplTxfmStats
txfm_stats_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
double
est_coeff_rate_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
double
act_rate_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
double
act_coeff_rate_list
[
VBR_RC_INFO_MAX_FRAMES
]
;
}
RATECTRL_LOG
;
static
INLINE
void
rc_log_init
(
RATECTRL_LOG
*
rc_log
)
{
av1_zero
(
*
rc_log
)
;
}
static
INLINE
void
rc_log_frame_stats
(
RATECTRL_LOG
*
rc_log
int
coding_index
const
TplTxfmStats
*
txfm_stats
)
{
rc_log
-
>
txfm_stats_list
[
coding_index
]
=
*
txfm_stats
;
}
static
INLINE
void
rc_log_frame_encode_param
(
RATECTRL_LOG
*
rc_log
int
coding_index
double
qstep_ratio
int
q_index
FRAME_UPDATE_TYPE
update_type
)
{
rc_log
-
>
qstep_ratio_list
[
coding_index
]
=
qstep_ratio
;
rc_log
-
>
q_index_list
[
coding_index
]
=
q_index
;
rc_log
-
>
update_type_list
[
coding_index
]
=
update_type
;
const
TplTxfmStats
*
txfm_stats
=
&
rc_log
-
>
txfm_stats_list
[
coding_index
]
;
rc_log
-
>
est_coeff_rate_list
[
coding_index
]
=
0
;
if
(
txfm_stats
-
>
ready
)
{
rc_log
-
>
est_coeff_rate_list
[
coding_index
]
=
av1_laplace_estimate_frame_rate
(
q_index
txfm_stats
-
>
txfm_block_count
txfm_stats
-
>
abs_coeff_mean
txfm_stats
-
>
coeff_num
)
;
}
}
static
INLINE
void
rc_log_frame_entropy
(
RATECTRL_LOG
*
rc_log
int
coding_index
double
act_rate
double
act_coeff_rate
)
{
rc_log
-
>
act_rate_list
[
coding_index
]
=
act_rate
;
rc_log
-
>
act_coeff_rate_list
[
coding_index
]
=
act_coeff_rate
;
}
static
INLINE
void
rc_log_record_chunk_info
(
RATECTRL_LOG
*
rc_log
int
base_q_index
int
coding_frame_count
)
{
rc_log
-
>
base_q_index
=
base_q_index
;
rc_log
-
>
coding_frame_count
=
coding_frame_count
;
}
static
INLINE
void
rc_log_show
(
const
RATECTRL_LOG
*
rc_log
)
{
printf
(
"
=
chunk
1
\
n
"
)
;
printf
(
"
coding_frame_count
%
d
base_q_index
%
d
\
n
"
rc_log
-
>
coding_frame_count
rc_log
-
>
base_q_index
)
;
printf
(
"
=
frame
%
d
\
n
"
rc_log
-
>
coding_frame_count
)
;
for
(
int
coding_idx
=
0
;
coding_idx
<
rc_log
-
>
coding_frame_count
;
coding_idx
+
+
)
{
printf
(
"
coding_idx
%
d
update_type
%
d
q
%
d
qstep_ratio
%
f
est_coeff_rate
%
f
"
"
act_coeff_rate
%
f
act_rate
%
f
\
n
"
coding_idx
rc_log
-
>
update_type_list
[
coding_idx
]
rc_log
-
>
q_index_list
[
coding_idx
]
rc_log
-
>
qstep_ratio_list
[
coding_idx
]
rc_log
-
>
est_coeff_rate_list
[
coding_idx
]
rc_log
-
>
act_coeff_rate_list
[
coding_idx
]
rc_log
-
>
act_rate_list
[
coding_idx
]
)
;
}
}
#
endif
#
ifdef
__cplusplus
}
#
endif
#
endif
