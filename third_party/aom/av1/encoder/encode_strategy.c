#
include
<
stdint
.
h
>
#
include
"
av1
/
common
/
blockd
.
h
"
#
include
"
config
/
aom_config
.
h
"
#
include
"
config
/
aom_scale_rtcd
.
h
"
#
include
"
aom
/
aom_codec
.
h
"
#
include
"
aom
/
aom_encoder
.
h
"
#
if
CONFIG_MISMATCH_DEBUG
#
include
"
aom_util
/
debug_util
.
h
"
#
endif
#
include
"
av1
/
common
/
av1_common_int
.
h
"
#
include
"
av1
/
common
/
reconinter
.
h
"
#
include
"
av1
/
encoder
/
encoder
.
h
"
#
include
"
av1
/
encoder
/
encode_strategy
.
h
"
#
include
"
av1
/
encoder
/
encodeframe
.
h
"
#
include
"
av1
/
encoder
/
encoder_alloc
.
h
"
#
include
"
av1
/
encoder
/
firstpass
.
h
"
#
include
"
av1
/
encoder
/
gop_structure
.
h
"
#
include
"
av1
/
encoder
/
pass2_strategy
.
h
"
#
include
"
av1
/
encoder
/
temporal_filter
.
h
"
#
if
CONFIG_THREE_PASS
#
include
"
av1
/
encoder
/
thirdpass
.
h
"
#
endif
#
include
"
av1
/
encoder
/
tpl_model
.
h
"
#
if
CONFIG_TUNE_VMAF
#
include
"
av1
/
encoder
/
tune_vmaf
.
h
"
#
endif
#
define
TEMPORAL_FILTER_KEY_FRAME
(
CONFIG_REALTIME_ONLY
?
0
:
1
)
static
INLINE
void
set_refresh_frame_flags
(
RefreshFrameInfo
*
const
refresh_frame
bool
refresh_gf
bool
refresh_bwdref
bool
refresh_arf
)
{
refresh_frame
-
>
golden_frame
=
refresh_gf
;
refresh_frame
-
>
bwd_ref_frame
=
refresh_bwdref
;
refresh_frame
-
>
alt_ref_frame
=
refresh_arf
;
}
void
av1_configure_buffer_updates
(
AV1_COMP
*
const
cpi
RefreshFrameInfo
*
const
refresh_frame
const
FRAME_UPDATE_TYPE
type
const
REFBUF_STATE
refbuf_state
int
force_refresh_all
)
{
const
ExtRefreshFrameFlagsInfo
*
const
ext_refresh_frame_flags
=
&
cpi
-
>
ext_flags
.
refresh_frame
;
cpi
-
>
rc
.
is_src_frame_alt_ref
=
0
;
switch
(
type
)
{
case
KF_UPDATE
:
set_refresh_frame_flags
(
refresh_frame
true
true
true
)
;
break
;
case
LF_UPDATE
:
set_refresh_frame_flags
(
refresh_frame
false
false
false
)
;
break
;
case
GF_UPDATE
:
set_refresh_frame_flags
(
refresh_frame
true
false
false
)
;
break
;
case
OVERLAY_UPDATE
:
if
(
refbuf_state
=
=
REFBUF_RESET
)
set_refresh_frame_flags
(
refresh_frame
true
true
true
)
;
else
set_refresh_frame_flags
(
refresh_frame
true
false
false
)
;
cpi
-
>
rc
.
is_src_frame_alt_ref
=
1
;
break
;
case
ARF_UPDATE
:
if
(
refbuf_state
=
=
REFBUF_RESET
)
set_refresh_frame_flags
(
refresh_frame
true
true
true
)
;
else
set_refresh_frame_flags
(
refresh_frame
false
false
true
)
;
break
;
case
INTNL_OVERLAY_UPDATE
:
set_refresh_frame_flags
(
refresh_frame
false
false
false
)
;
cpi
-
>
rc
.
is_src_frame_alt_ref
=
1
;
break
;
case
INTNL_ARF_UPDATE
:
set_refresh_frame_flags
(
refresh_frame
false
true
false
)
;
break
;
default
:
assert
(
0
)
;
break
;
}
if
(
ext_refresh_frame_flags
-
>
update_pending
&
&
(
!
is_stat_generation_stage
(
cpi
)
)
)
{
set_refresh_frame_flags
(
refresh_frame
ext_refresh_frame_flags
-
>
golden_frame
ext_refresh_frame_flags
-
>
bwd_ref_frame
ext_refresh_frame_flags
-
>
alt_ref_frame
)
;
GF_GROUP
*
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
if
(
ext_refresh_frame_flags
-
>
golden_frame
)
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
GF_UPDATE
;
if
(
ext_refresh_frame_flags
-
>
alt_ref_frame
)
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
ARF_UPDATE
;
if
(
ext_refresh_frame_flags
-
>
bwd_ref_frame
)
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
INTNL_ARF_UPDATE
;
}
if
(
force_refresh_all
)
set_refresh_frame_flags
(
refresh_frame
true
true
true
)
;
}
static
void
set_additional_frame_flags
(
const
AV1_COMMON
*
const
cm
unsigned
int
*
const
frame_flags
)
{
if
(
frame_is_intra_only
(
cm
)
)
{
*
frame_flags
|
=
FRAMEFLAGS_INTRAONLY
;
}
if
(
frame_is_sframe
(
cm
)
)
{
*
frame_flags
|
=
FRAMEFLAGS_SWITCH
;
}
if
(
cm
-
>
features
.
error_resilient_mode
)
{
*
frame_flags
|
=
FRAMEFLAGS_ERROR_RESILIENT
;
}
}
static
void
set_ext_overrides
(
AV1_COMMON
*
const
cm
EncodeFrameParams
*
const
frame_params
ExternalFlags
*
const
ext_flags
)
{
if
(
ext_flags
-
>
use_s_frame
)
{
frame_params
-
>
frame_type
=
S_FRAME
;
}
if
(
ext_flags
-
>
refresh_frame_context_pending
)
{
cm
-
>
features
.
refresh_frame_context
=
ext_flags
-
>
refresh_frame_context
;
ext_flags
-
>
refresh_frame_context_pending
=
0
;
}
cm
-
>
features
.
allow_ref_frame_mvs
=
ext_flags
-
>
use_ref_frame_mvs
;
frame_params
-
>
error_resilient_mode
=
ext_flags
-
>
use_error_resilient
;
frame_params
-
>
error_resilient_mode
&
=
frame_params
-
>
frame_type
!
=
KEY_FRAME
;
frame_params
-
>
error_resilient_mode
|
=
frame_params
-
>
frame_type
=
=
S_FRAME
;
}
static
int
choose_primary_ref_frame
(
AV1_COMP
*
const
cpi
const
EncodeFrameParams
*
const
frame_params
)
{
const
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
const
int
intra_only
=
frame_params
-
>
frame_type
=
=
KEY_FRAME
|
|
frame_params
-
>
frame_type
=
=
INTRA_ONLY_FRAME
;
if
(
intra_only
|
|
frame_params
-
>
error_resilient_mode
|
|
cpi
-
>
ext_flags
.
use_primary_ref_none
)
{
return
PRIMARY_REF_NONE
;
}
#
if
!
CONFIG_REALTIME_ONLY
if
(
cpi
-
>
use_ducky_encode
)
{
int
wanted_fb
=
cpi
-
>
ppi
-
>
gf_group
.
primary_ref_idx
[
cpi
-
>
gf_frame_index
]
;
for
(
int
ref_frame
=
LAST_FRAME
;
ref_frame
<
=
ALTREF_FRAME
;
ref_frame
+
+
)
{
if
(
get_ref_frame_map_idx
(
cm
ref_frame
)
=
=
wanted_fb
)
return
ref_frame
-
LAST_FRAME
;
}
return
PRIMARY_REF_NONE
;
}
#
endif
if
(
cm
-
>
tiles
.
large_scale
)
return
(
LAST_FRAME
-
LAST_FRAME
)
;
if
(
cpi
-
>
ppi
-
>
use_svc
|
|
cpi
-
>
ppi
-
>
rtc_ref
.
set_ref_frame_config
)
return
av1_svc_primary_ref_frame
(
cpi
)
;
const
int
current_ref_type
=
get_current_frame_ref_type
(
cpi
)
;
int
wanted_fb
=
cpi
-
>
ppi
-
>
fb_of_context_type
[
current_ref_type
]
;
#
if
CONFIG_FPMT_TEST
if
(
cpi
-
>
ppi
-
>
fpmt_unit_test_cfg
=
=
PARALLEL_SIMULATION_ENCODE
)
{
GF_GROUP
*
const
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
if
(
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
INTNL_ARF_UPDATE
)
{
int
frame_level
=
gf_group
-
>
frame_parallel_level
[
cpi
-
>
gf_frame_index
]
;
if
(
frame_level
=
=
1
)
{
cpi
-
>
wanted_fb
=
wanted_fb
;
}
if
(
frame_level
=
=
2
&
&
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
-
1
]
=
=
INTNL_ARF_UPDATE
)
{
assert
(
gf_group
-
>
frame_parallel_level
[
cpi
-
>
gf_frame_index
-
1
]
=
=
1
)
;
wanted_fb
=
cpi
-
>
wanted_fb
;
}
}
}
#
endif
int
primary_ref_frame
=
PRIMARY_REF_NONE
;
for
(
int
ref_frame
=
LAST_FRAME
;
ref_frame
<
=
ALTREF_FRAME
;
ref_frame
+
+
)
{
if
(
get_ref_frame_map_idx
(
cm
ref_frame
)
=
=
wanted_fb
)
{
primary_ref_frame
=
ref_frame
-
LAST_FRAME
;
}
}
return
primary_ref_frame
;
}
static
void
adjust_frame_rate
(
AV1_COMP
*
cpi
int64_t
ts_start
int64_t
ts_end
)
{
TimeStamps
*
time_stamps
=
&
cpi
-
>
time_stamps
;
int64_t
this_duration
;
int
step
=
0
;
if
(
cpi
-
>
ppi
-
>
use_svc
&
&
cpi
-
>
ppi
-
>
rtc_ref
.
set_ref_frame_config
&
&
cpi
-
>
svc
.
number_spatial_layers
>
1
)
{
this_duration
=
ts_end
-
ts_start
;
if
(
this_duration
>
0
)
{
cpi
-
>
new_framerate
=
10000000
.
0
/
this_duration
;
av1_new_framerate
(
cpi
cpi
-
>
new_framerate
)
;
time_stamps
-
>
prev_ts_start
=
ts_start
;
time_stamps
-
>
prev_ts_end
=
ts_end
;
return
;
}
}
if
(
ts_start
=
=
time_stamps
-
>
first_ts_start
)
{
this_duration
=
ts_end
-
ts_start
;
step
=
1
;
}
else
{
int64_t
last_duration
=
time_stamps
-
>
prev_ts_end
-
time_stamps
-
>
prev_ts_start
;
this_duration
=
ts_end
-
time_stamps
-
>
prev_ts_end
;
if
(
last_duration
)
step
=
(
int
)
(
(
this_duration
-
last_duration
)
*
10
/
last_duration
)
;
}
if
(
this_duration
)
{
if
(
step
)
{
cpi
-
>
new_framerate
=
10000000
.
0
/
this_duration
;
av1_new_framerate
(
cpi
cpi
-
>
new_framerate
)
;
}
else
{
const
double
interval
=
AOMMIN
(
(
double
)
(
ts_end
-
time_stamps
-
>
first_ts_start
)
10000000
.
0
)
;
double
avg_duration
=
10000000
.
0
/
cpi
-
>
framerate
;
avg_duration
*
=
(
interval
-
avg_duration
+
this_duration
)
;
avg_duration
/
=
interval
;
cpi
-
>
new_framerate
=
(
10000000
.
0
/
avg_duration
)
;
double
framerate
=
(
cpi
-
>
ppi
-
>
gf_group
.
frame_parallel_level
[
cpi
-
>
gf_frame_index
]
>
0
)
?
cpi
-
>
framerate
:
cpi
-
>
new_framerate
;
av1_new_framerate
(
cpi
framerate
)
;
}
}
time_stamps
-
>
prev_ts_start
=
ts_start
;
time_stamps
-
>
prev_ts_end
=
ts_end
;
}
int
is_forced_keyframe_pending
(
struct
lookahead_ctx
*
lookahead
const
int
up_to_index
const
COMPRESSOR_STAGE
compressor_stage
)
{
for
(
int
i
=
0
;
i
<
=
up_to_index
;
i
+
+
)
{
const
struct
lookahead_entry
*
e
=
av1_lookahead_peek
(
lookahead
i
compressor_stage
)
;
if
(
e
=
=
NULL
)
{
return
-
1
;
}
else
if
(
e
-
>
flags
=
=
AOM_EFLAG_FORCE_KF
)
{
return
i
;
}
else
{
continue
;
}
}
return
-
1
;
}
static
struct
lookahead_entry
*
choose_frame_source
(
AV1_COMP
*
const
cpi
int
*
const
flush
int
*
pop_lookahead
struct
lookahead_entry
*
*
last_source
int
*
const
show_frame
)
{
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
const
GF_GROUP
*
const
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
struct
lookahead_entry
*
source
=
NULL
;
int
src_index
=
gf_group
-
>
arf_src_offset
[
cpi
-
>
gf_frame_index
]
;
if
(
src_index
&
&
(
is_forced_keyframe_pending
(
cpi
-
>
ppi
-
>
lookahead
src_index
cpi
-
>
compressor_stage
)
!
=
-
1
)
&
&
cpi
-
>
oxcf
.
rc_cfg
.
mode
!
=
AOM_Q
&
&
!
is_stat_generation_stage
(
cpi
)
)
{
src_index
=
0
;
*
flush
=
1
;
}
*
pop_lookahead
=
(
src_index
=
=
0
)
;
if
(
*
pop_lookahead
&
&
cpi
-
>
oxcf
.
kf_cfg
.
enable_keyframe_filtering
>
1
&
&
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
ARF_UPDATE
&
&
!
is_stat_generation_stage
(
cpi
)
&
&
cpi
-
>
ppi
-
>
lookahead
)
{
if
(
cpi
-
>
ppi
-
>
lookahead
-
>
read_ctxs
[
cpi
-
>
compressor_stage
]
.
sz
&
&
(
*
flush
|
|
cpi
-
>
ppi
-
>
lookahead
-
>
read_ctxs
[
cpi
-
>
compressor_stage
]
.
sz
=
=
cpi
-
>
ppi
-
>
lookahead
-
>
read_ctxs
[
cpi
-
>
compressor_stage
]
.
pop_sz
)
)
{
*
pop_lookahead
=
0
;
}
}
if
(
is_stat_generation_stage
(
cpi
)
)
{
*
pop_lookahead
=
1
;
src_index
=
0
;
}
*
show_frame
=
*
pop_lookahead
;
#
if
CONFIG_FPMT_TEST
if
(
cpi
-
>
ppi
-
>
fpmt_unit_test_cfg
=
=
PARALLEL_ENCODE
)
{
#
else
{
#
endif
if
(
gf_group
-
>
src_offset
[
cpi
-
>
gf_frame_index
]
!
=
0
&
&
!
is_stat_generation_stage
(
cpi
)
)
src_index
=
gf_group
-
>
src_offset
[
cpi
-
>
gf_frame_index
]
;
}
if
(
*
show_frame
)
{
if
(
cm
-
>
current_frame
.
frame_number
>
0
)
{
*
last_source
=
av1_lookahead_peek
(
cpi
-
>
ppi
-
>
lookahead
src_index
-
1
cpi
-
>
compressor_stage
)
;
}
source
=
av1_lookahead_peek
(
cpi
-
>
ppi
-
>
lookahead
src_index
cpi
-
>
compressor_stage
)
;
}
else
{
source
=
av1_lookahead_peek
(
cpi
-
>
ppi
-
>
lookahead
src_index
cpi
-
>
compressor_stage
)
;
if
(
source
!
=
NULL
)
{
cm
-
>
showable_frame
=
1
;
}
}
return
source
;
}
static
int
allow_show_existing
(
const
AV1_COMP
*
const
cpi
unsigned
int
frame_flags
)
{
if
(
cpi
-
>
common
.
current_frame
.
frame_number
=
=
0
)
return
0
;
const
struct
lookahead_entry
*
lookahead_src
=
av1_lookahead_peek
(
cpi
-
>
ppi
-
>
lookahead
0
cpi
-
>
compressor_stage
)
;
if
(
lookahead_src
=
=
NULL
)
return
1
;
const
int
is_error_resilient
=
cpi
-
>
oxcf
.
tool_cfg
.
error_resilient_mode
|
|
(
lookahead_src
-
>
flags
&
AOM_EFLAG_ERROR_RESILIENT
)
;
const
int
is_s_frame
=
cpi
-
>
oxcf
.
kf_cfg
.
enable_sframe
|
|
(
lookahead_src
-
>
flags
&
AOM_EFLAG_SET_S_FRAME
)
;
const
int
is_key_frame
=
(
cpi
-
>
rc
.
frames_to_key
=
=
0
)
|
|
(
frame_flags
&
FRAMEFLAGS_KEY
)
;
return
!
(
is_error_resilient
|
|
is_s_frame
)
|
|
is_key_frame
;
}
static
void
update_frame_flags
(
const
AV1_COMMON
*
const
cm
const
RefreshFrameInfo
*
const
refresh_frame
unsigned
int
*
frame_flags
)
{
if
(
encode_show_existing_frame
(
cm
)
)
{
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_GOLDEN
;
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_BWDREF
;
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_ALTREF
;
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_KEY
;
return
;
}
if
(
refresh_frame
-
>
golden_frame
)
{
*
frame_flags
|
=
FRAMEFLAGS_GOLDEN
;
}
else
{
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_GOLDEN
;
}
if
(
refresh_frame
-
>
alt_ref_frame
)
{
*
frame_flags
|
=
FRAMEFLAGS_ALTREF
;
}
else
{
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_ALTREF
;
}
if
(
refresh_frame
-
>
bwd_ref_frame
)
{
*
frame_flags
|
=
FRAMEFLAGS_BWDREF
;
}
else
{
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_BWDREF
;
}
if
(
cm
-
>
current_frame
.
frame_type
=
=
KEY_FRAME
)
{
*
frame_flags
|
=
FRAMEFLAGS_KEY
;
}
else
{
*
frame_flags
&
=
~
(
uint32_t
)
FRAMEFLAGS_KEY
;
}
}
#
define
DUMP_REF_FRAME_IMAGES
0
#
if
DUMP_REF_FRAME_IMAGES
=
=
1
static
int
dump_one_image
(
AV1_COMMON
*
cm
const
YV12_BUFFER_CONFIG
*
const
ref_buf
char
*
file_name
)
{
int
h
;
FILE
*
f_ref
=
NULL
;
if
(
ref_buf
=
=
NULL
)
{
printf
(
"
Frame
data
buffer
is
NULL
.
\
n
"
)
;
return
AOM_CODEC_MEM_ERROR
;
}
if
(
(
f_ref
=
fopen
(
file_name
"
wb
"
)
)
=
=
NULL
)
{
printf
(
"
Unable
to
open
file
%
s
to
write
.
\
n
"
file_name
)
;
return
AOM_CODEC_MEM_ERROR
;
}
for
(
h
=
0
;
h
<
cm
-
>
height
;
+
+
h
)
{
fwrite
(
&
ref_buf
-
>
y_buffer
[
h
*
ref_buf
-
>
y_stride
]
1
cm
-
>
width
f_ref
)
;
}
for
(
h
=
0
;
h
<
(
cm
-
>
height
>
>
1
)
;
+
+
h
)
{
fwrite
(
&
ref_buf
-
>
u_buffer
[
h
*
ref_buf
-
>
uv_stride
]
1
(
cm
-
>
width
>
>
1
)
f_ref
)
;
}
for
(
h
=
0
;
h
<
(
cm
-
>
height
>
>
1
)
;
+
+
h
)
{
fwrite
(
&
ref_buf
-
>
v_buffer
[
h
*
ref_buf
-
>
uv_stride
]
1
(
cm
-
>
width
>
>
1
)
f_ref
)
;
}
fclose
(
f_ref
)
;
return
AOM_CODEC_OK
;
}
static
void
dump_ref_frame_images
(
AV1_COMP
*
cpi
)
{
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
MV_REFERENCE_FRAME
ref_frame
;
for
(
ref_frame
=
LAST_FRAME
;
ref_frame
<
=
ALTREF_FRAME
;
+
+
ref_frame
)
{
char
file_name
[
256
]
=
"
"
;
snprintf
(
file_name
sizeof
(
file_name
)
"
/
tmp
/
enc_F
%
d_ref_
%
d
.
yuv
"
cm
-
>
current_frame
.
frame_number
ref_frame
)
;
dump_one_image
(
cm
get_ref_frame_yv12_buf
(
cpi
ref_frame
)
file_name
)
;
}
}
#
endif
int
av1_get_refresh_ref_frame_map
(
int
refresh_frame_flags
)
{
int
ref_map_index
;
for
(
ref_map_index
=
0
;
ref_map_index
<
REF_FRAMES
;
+
+
ref_map_index
)
if
(
(
refresh_frame_flags
>
>
ref_map_index
)
&
1
)
break
;
if
(
ref_map_index
=
=
REF_FRAMES
)
ref_map_index
=
INVALID_IDX
;
return
ref_map_index
;
}
static
int
get_free_ref_map_index
(
RefFrameMapPair
ref_map_pairs
[
REF_FRAMES
]
)
{
for
(
int
idx
=
0
;
idx
<
REF_FRAMES
;
+
+
idx
)
if
(
ref_map_pairs
[
idx
]
.
disp_order
=
=
-
1
)
return
idx
;
return
INVALID_IDX
;
}
static
int
get_refresh_idx
(
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
int
update_arf
GF_GROUP
*
gf_group
int
gf_index
int
enable_refresh_skip
int
cur_frame_disp
)
{
int
arf_count
=
0
;
int
oldest_arf_order
=
INT32_MAX
;
int
oldest_arf_idx
=
-
1
;
int
oldest_frame_order
=
INT32_MAX
;
int
oldest_idx
=
-
1
;
for
(
int
map_idx
=
0
;
map_idx
<
REF_FRAMES
;
map_idx
+
+
)
{
RefFrameMapPair
ref_pair
=
ref_frame_map_pairs
[
map_idx
]
;
if
(
ref_pair
.
disp_order
=
=
-
1
)
continue
;
const
int
frame_order
=
ref_pair
.
disp_order
;
const
int
reference_frame_level
=
ref_pair
.
pyr_level
;
if
(
frame_order
>
cur_frame_disp
-
3
)
continue
;
if
(
enable_refresh_skip
)
{
int
skip_frame
=
0
;
for
(
int
i
=
0
;
i
<
REF_FRAMES
;
i
+
+
)
{
int
frame_to_skip
=
gf_group
-
>
skip_frame_refresh
[
gf_index
]
[
i
]
;
if
(
frame_to_skip
=
=
INVALID_IDX
)
break
;
if
(
frame_order
=
=
frame_to_skip
)
{
skip_frame
=
1
;
break
;
}
}
if
(
skip_frame
)
continue
;
}
if
(
reference_frame_level
=
=
1
)
{
if
(
frame_order
<
oldest_arf_order
)
{
oldest_arf_order
=
frame_order
;
oldest_arf_idx
=
map_idx
;
}
arf_count
+
+
;
continue
;
}
if
(
frame_order
<
oldest_frame_order
)
{
oldest_frame_order
=
frame_order
;
oldest_idx
=
map_idx
;
}
}
if
(
update_arf
&
&
arf_count
>
2
)
return
oldest_arf_idx
;
if
(
oldest_idx
>
=
0
)
return
oldest_idx
;
if
(
oldest_arf_idx
>
=
0
)
return
oldest_arf_idx
;
if
(
oldest_idx
=
=
-
1
)
{
assert
(
arf_count
>
2
&
&
enable_refresh_skip
)
;
return
oldest_arf_idx
;
}
assert
(
0
&
&
"
No
valid
refresh
index
found
"
)
;
return
-
1
;
}
int
av1_calc_refresh_idx_for_intnl_arf
(
AV1_COMP
*
cpi
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
int
gf_index
)
{
GF_GROUP
*
const
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
int
free_fb_index
=
get_free_ref_map_index
(
ref_frame_map_pairs
)
;
if
(
free_fb_index
!
=
INVALID_IDX
)
{
return
free_fb_index
;
}
else
{
int
enable_refresh_skip
=
!
is_one_pass_rt_params
(
cpi
)
;
int
refresh_idx
=
get_refresh_idx
(
ref_frame_map_pairs
0
gf_group
gf_index
enable_refresh_skip
gf_group
-
>
display_idx
[
gf_index
]
)
;
return
refresh_idx
;
}
}
int
av1_get_refresh_frame_flags
(
const
AV1_COMP
*
const
cpi
const
EncodeFrameParams
*
const
frame_params
FRAME_UPDATE_TYPE
frame_update_type
int
gf_index
int
cur_disp_order
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
)
{
const
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
const
ExtRefreshFrameFlagsInfo
*
const
ext_refresh_frame_flags
=
&
cpi
-
>
ext_flags
.
refresh_frame
;
GF_GROUP
*
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
if
(
gf_group
-
>
refbuf_state
[
gf_index
]
=
=
REFBUF_RESET
)
return
SELECT_ALL_BUF_SLOTS
;
if
(
frame_params
-
>
frame_type
=
=
S_FRAME
)
return
SELECT_ALL_BUF_SLOTS
;
if
(
frame_params
-
>
show_existing_frame
)
return
0
;
const
RTC_REF
*
const
rtc_ref
=
&
cpi
-
>
ppi
-
>
rtc_ref
;
if
(
is_frame_droppable
(
rtc_ref
ext_refresh_frame_flags
)
)
return
0
;
#
if
!
CONFIG_REALTIME_ONLY
if
(
cpi
-
>
use_ducky_encode
&
&
cpi
-
>
ducky_encode_info
.
frame_info
.
gop_mode
=
=
DUCKY_ENCODE_GOP_MODE_RCL
)
{
int
new_fb_map_idx
=
cpi
-
>
ppi
-
>
gf_group
.
update_ref_idx
[
gf_index
]
;
if
(
new_fb_map_idx
=
=
INVALID_IDX
)
return
0
;
return
1
<
<
new_fb_map_idx
;
}
#
endif
int
refresh_mask
=
0
;
if
(
ext_refresh_frame_flags
-
>
update_pending
)
{
if
(
rtc_ref
-
>
set_ref_frame_config
|
|
use_rtc_reference_structure_one_layer
(
cpi
)
)
{
for
(
unsigned
int
i
=
0
;
i
<
INTER_REFS_PER_FRAME
;
i
+
+
)
{
int
ref_frame_map_idx
=
rtc_ref
-
>
ref_idx
[
i
]
;
refresh_mask
|
=
rtc_ref
-
>
refresh
[
ref_frame_map_idx
]
<
<
ref_frame_map_idx
;
}
return
refresh_mask
;
}
int
ref_frame_map_idx
=
get_ref_frame_map_idx
(
cm
LAST_FRAME
)
;
if
(
ref_frame_map_idx
!
=
INVALID_IDX
)
refresh_mask
|
=
ext_refresh_frame_flags
-
>
last_frame
<
<
ref_frame_map_idx
;
ref_frame_map_idx
=
get_ref_frame_map_idx
(
cm
EXTREF_FRAME
)
;
if
(
ref_frame_map_idx
!
=
INVALID_IDX
)
refresh_mask
|
=
ext_refresh_frame_flags
-
>
bwd_ref_frame
<
<
ref_frame_map_idx
;
ref_frame_map_idx
=
get_ref_frame_map_idx
(
cm
ALTREF2_FRAME
)
;
if
(
ref_frame_map_idx
!
=
INVALID_IDX
)
refresh_mask
|
=
ext_refresh_frame_flags
-
>
alt2_ref_frame
<
<
ref_frame_map_idx
;
if
(
frame_update_type
=
=
OVERLAY_UPDATE
)
{
ref_frame_map_idx
=
get_ref_frame_map_idx
(
cm
ALTREF_FRAME
)
;
if
(
ref_frame_map_idx
!
=
INVALID_IDX
)
refresh_mask
|
=
ext_refresh_frame_flags
-
>
golden_frame
<
<
ref_frame_map_idx
;
}
else
{
ref_frame_map_idx
=
get_ref_frame_map_idx
(
cm
GOLDEN_FRAME
)
;
if
(
ref_frame_map_idx
!
=
INVALID_IDX
)
refresh_mask
|
=
ext_refresh_frame_flags
-
>
golden_frame
<
<
ref_frame_map_idx
;
ref_frame_map_idx
=
get_ref_frame_map_idx
(
cm
ALTREF_FRAME
)
;
if
(
ref_frame_map_idx
!
=
INVALID_IDX
)
refresh_mask
|
=
ext_refresh_frame_flags
-
>
alt_ref_frame
<
<
ref_frame_map_idx
;
}
return
refresh_mask
;
}
int
free_fb_index
=
get_free_ref_map_index
(
ref_frame_map_pairs
)
;
if
(
frame_update_type
=
=
OVERLAY_UPDATE
|
|
frame_update_type
=
=
INTNL_OVERLAY_UPDATE
)
return
refresh_mask
;
if
(
free_fb_index
!
=
INVALID_IDX
)
{
refresh_mask
=
1
<
<
free_fb_index
;
return
refresh_mask
;
}
const
int
enable_refresh_skip
=
!
is_one_pass_rt_params
(
cpi
)
;
const
int
update_arf
=
frame_update_type
=
=
ARF_UPDATE
;
const
int
refresh_idx
=
get_refresh_idx
(
ref_frame_map_pairs
update_arf
&
cpi
-
>
ppi
-
>
gf_group
gf_index
enable_refresh_skip
cur_disp_order
)
;
return
1
<
<
refresh_idx
;
}
#
if
!
CONFIG_REALTIME_ONLY
static
int
denoise_and_encode
(
AV1_COMP
*
const
cpi
uint8_t
*
const
dest
EncodeFrameInput
*
const
frame_input
const
EncodeFrameParams
*
const
frame_params
EncodeFrameResults
*
const
frame_results
)
{
#
if
CONFIG_COLLECT_COMPONENT_TIMING
if
(
cpi
-
>
oxcf
.
pass
=
=
2
)
start_timing
(
cpi
denoise_and_encode_time
)
;
#
endif
const
AV1EncoderConfig
*
const
oxcf
=
&
cpi
-
>
oxcf
;
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
GF_GROUP
*
const
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
FRAME_UPDATE_TYPE
update_type
=
get_frame_update_type
(
&
cpi
-
>
ppi
-
>
gf_group
cpi
-
>
gf_frame_index
)
;
const
int
is_second_arf
=
av1_gop_is_second_arf
(
gf_group
cpi
-
>
gf_frame_index
)
;
int
apply_filtering
=
av1_is_temporal_filter_on
(
oxcf
)
&
&
!
is_stat_generation_stage
(
cpi
)
;
if
(
update_type
!
=
KF_UPDATE
&
&
update_type
!
=
ARF_UPDATE
&
&
!
is_second_arf
)
{
apply_filtering
=
0
;
}
if
(
apply_filtering
)
{
if
(
frame_params
-
>
frame_type
=
=
KEY_FRAME
)
{
int
allow_kf_filtering
=
oxcf
-
>
kf_cfg
.
enable_keyframe_filtering
&
&
!
frame_params
-
>
show_existing_frame
&
&
!
is_lossless_requested
(
&
oxcf
-
>
rc_cfg
)
;
if
(
allow_kf_filtering
)
{
double
y_noise_level
=
0
.
0
;
av1_estimate_noise_level
(
frame_input
-
>
source
&
y_noise_level
AOM_PLANE_Y
AOM_PLANE_Y
cm
-
>
seq_params
-
>
bit_depth
NOISE_ESTIMATION_EDGE_THRESHOLD
)
;
apply_filtering
=
y_noise_level
>
0
;
}
else
{
apply_filtering
=
0
;
}
if
(
apply_filtering
)
{
av1_setup_past_independence
(
cm
)
;
}
}
else
if
(
is_second_arf
)
{
apply_filtering
=
cpi
-
>
sf
.
hl_sf
.
second_alt_ref_filtering
;
}
}
#
if
CONFIG_COLLECT_COMPONENT_TIMING
if
(
cpi
-
>
oxcf
.
pass
=
=
2
)
start_timing
(
cpi
apply_filtering_time
)
;
#
endif
YV12_BUFFER_CONFIG
*
source_buffer
=
frame_input
-
>
source
;
if
(
apply_filtering
)
{
int
show_existing_alt_ref
=
0
;
FRAME_DIFF
frame_diff
;
int
top_index
=
0
;
int
bottom_index
=
0
;
const
int
q_index
=
av1_rc_pick_q_and_bounds
(
cpi
cpi
-
>
oxcf
.
frm_dim_cfg
.
width
cpi
-
>
oxcf
.
frm_dim_cfg
.
height
cpi
-
>
gf_frame_index
&
bottom_index
&
top_index
)
;
cm
-
>
current_frame
.
frame_type
=
frame_params
-
>
frame_type
;
if
(
update_type
=
=
KF_UPDATE
|
|
update_type
=
=
ARF_UPDATE
)
{
YV12_BUFFER_CONFIG
*
tf_buf
=
av1_tf_info_get_filtered_buf
(
&
cpi
-
>
ppi
-
>
tf_info
cpi
-
>
gf_frame_index
&
frame_diff
)
;
if
(
tf_buf
!
=
NULL
)
{
frame_input
-
>
source
=
tf_buf
;
show_existing_alt_ref
=
av1_check_show_filtered_frame
(
tf_buf
&
frame_diff
q_index
cm
-
>
seq_params
-
>
bit_depth
)
;
if
(
show_existing_alt_ref
)
{
cpi
-
>
common
.
showable_frame
|
=
1
;
}
else
{
cpi
-
>
common
.
showable_frame
=
0
;
}
}
if
(
gf_group
-
>
frame_type
[
cpi
-
>
gf_frame_index
]
!
=
KEY_FRAME
)
{
cpi
-
>
ppi
-
>
show_existing_alt_ref
=
show_existing_alt_ref
;
}
}
if
(
is_second_arf
)
{
int
ret
=
aom_realloc_frame_buffer
(
&
cpi
-
>
ppi
-
>
tf_info
.
tf_buf_second_arf
oxcf
-
>
frm_dim_cfg
.
width
oxcf
-
>
frm_dim_cfg
.
height
cm
-
>
seq_params
-
>
subsampling_x
cm
-
>
seq_params
-
>
subsampling_y
cm
-
>
seq_params
-
>
use_highbitdepth
cpi
-
>
oxcf
.
border_in_pixels
cm
-
>
features
.
byte_alignment
NULL
NULL
NULL
cpi
-
>
alloc_pyramid
0
)
;
if
(
ret
)
aom_internal_error
(
cm
-
>
error
AOM_CODEC_MEM_ERROR
"
Failed
to
allocate
tf_buf_second_arf
"
)
;
YV12_BUFFER_CONFIG
*
tf_buf_second_arf
=
&
cpi
-
>
ppi
-
>
tf_info
.
tf_buf_second_arf
;
const
int
arf_src_index
=
gf_group
-
>
arf_src_offset
[
cpi
-
>
gf_frame_index
]
;
av1_temporal_filter
(
cpi
arf_src_index
cpi
-
>
gf_frame_index
&
frame_diff
tf_buf_second_arf
)
;
show_existing_alt_ref
=
av1_check_show_filtered_frame
(
tf_buf_second_arf
&
frame_diff
q_index
cm
-
>
seq_params
-
>
bit_depth
)
;
if
(
show_existing_alt_ref
)
{
aom_extend_frame_borders
(
tf_buf_second_arf
av1_num_planes
(
cm
)
)
;
frame_input
-
>
source
=
tf_buf_second_arf
;
}
cpi
-
>
common
.
showable_frame
|
=
1
;
}
if
(
source_buffer
-
>
metadata
&
&
aom_copy_metadata_to_frame_buffer
(
frame_input
-
>
source
source_buffer
-
>
metadata
)
)
{
aom_internal_error
(
cm
-
>
error
AOM_CODEC_MEM_ERROR
"
Failed
to
copy
source
metadata
to
the
temporal
filtered
frame
"
)
;
}
}
#
if
CONFIG_COLLECT_COMPONENT_TIMING
if
(
cpi
-
>
oxcf
.
pass
=
=
2
)
end_timing
(
cpi
apply_filtering_time
)
;
#
endif
int
set_mv_params
=
frame_params
-
>
frame_type
=
=
KEY_FRAME
|
|
update_type
=
=
ARF_UPDATE
|
|
update_type
=
=
GF_UPDATE
;
cm
-
>
show_frame
=
frame_params
-
>
show_frame
;
cm
-
>
current_frame
.
frame_type
=
frame_params
-
>
frame_type
;
av1_set_frame_size
(
cpi
cm
-
>
width
cm
-
>
height
)
;
if
(
set_mv_params
)
av1_set_mv_search_params
(
cpi
)
;
#
if
CONFIG_RD_COMMAND
if
(
frame_params
-
>
frame_type
=
=
KEY_FRAME
)
{
char
filepath
[
]
=
"
rd_command
.
txt
"
;
av1_read_rd_command
(
filepath
&
cpi
-
>
rd_command
)
;
}
#
endif
if
(
cpi
-
>
gf_frame_index
=
=
0
&
&
!
is_stat_generation_stage
(
cpi
)
)
{
int
allow_tpl
=
oxcf
-
>
gf_cfg
.
lag_in_frames
>
1
&
&
oxcf
-
>
algo_cfg
.
enable_tpl_model
;
if
(
gf_group
-
>
size
>
MAX_LENGTH_TPL_FRAME_STATS
)
{
allow_tpl
=
0
;
}
if
(
frame_params
-
>
frame_type
!
=
KEY_FRAME
)
{
allow_tpl
=
allow_tpl
&
&
(
update_type
=
=
ARF_UPDATE
|
|
update_type
=
=
GF_UPDATE
|
|
(
cpi
-
>
use_ducky_encode
&
&
cpi
-
>
ducky_encode_info
.
frame_info
.
gop_mode
=
=
DUCKY_ENCODE_GOP_MODE_RCL
)
)
;
}
if
(
allow_tpl
)
{
if
(
!
cpi
-
>
skip_tpl_setup_stats
)
{
av1_tpl_preload_rc_estimate
(
cpi
frame_params
)
;
av1_tpl_setup_stats
(
cpi
0
frame_params
)
;
#
if
CONFIG_BITRATE_ACCURACY
&
&
!
CONFIG_THREE_PASS
assert
(
cpi
-
>
gf_frame_index
=
=
0
)
;
av1_vbr_rc_update_q_index_list
(
&
cpi
-
>
vbr_rc_info
&
cpi
-
>
ppi
-
>
tpl_data
gf_group
cm
-
>
seq_params
-
>
bit_depth
)
;
#
endif
}
}
else
{
av1_init_tpl_stats
(
&
cpi
-
>
ppi
-
>
tpl_data
)
;
}
#
if
CONFIG_BITRATE_ACCURACY
&
&
CONFIG_THREE_PASS
if
(
cpi
-
>
oxcf
.
pass
=
=
AOM_RC_SECOND_PASS
&
&
cpi
-
>
second_pass_log_stream
!
=
NULL
)
{
TPL_INFO
*
tpl_info
;
AOM_CHECK_MEM_ERROR
(
cm
-
>
error
tpl_info
aom_malloc
(
sizeof
(
*
tpl_info
)
)
)
;
av1_pack_tpl_info
(
tpl_info
gf_group
&
cpi
-
>
ppi
-
>
tpl_data
)
;
av1_write_tpl_info
(
tpl_info
cpi
-
>
second_pass_log_stream
cpi
-
>
common
.
error
)
;
aom_free
(
tpl_info
)
;
}
#
endif
}
if
(
av1_encode
(
cpi
dest
frame_input
frame_params
frame_results
)
!
=
AOM_CODEC_OK
)
{
return
AOM_CODEC_ERROR
;
}
if
(
apply_filtering
&
&
is_psnr_calc_enabled
(
cpi
)
)
{
cpi
-
>
source
=
av1_realloc_and_scale_if_required
(
cm
source_buffer
&
cpi
-
>
scaled_source
cm
-
>
features
.
interp_filter
0
false
true
cpi
-
>
oxcf
.
border_in_pixels
cpi
-
>
alloc_pyramid
)
;
cpi
-
>
unscaled_source
=
source_buffer
;
}
#
if
CONFIG_COLLECT_COMPONENT_TIMING
if
(
cpi
-
>
oxcf
.
pass
=
=
2
)
end_timing
(
cpi
denoise_and_encode_time
)
;
#
endif
return
AOM_CODEC_OK
;
}
#
endif
typedef
struct
{
int
map_idx
;
int
disp_order
;
int
pyr_level
;
int
used
;
}
RefBufMapData
;
static
int
compare_map_idx_pair_asc
(
const
void
*
a
const
void
*
b
)
{
if
(
(
(
RefBufMapData
*
)
a
)
-
>
disp_order
=
=
(
(
RefBufMapData
*
)
b
)
-
>
disp_order
)
{
return
0
;
}
else
if
(
(
(
const
RefBufMapData
*
)
a
)
-
>
disp_order
>
(
(
const
RefBufMapData
*
)
b
)
-
>
disp_order
)
{
return
1
;
}
else
{
return
-
1
;
}
}
static
int
is_in_ref_map
(
RefBufMapData
*
map
int
disp_order
int
n_frames
)
{
for
(
int
i
=
0
;
i
<
n_frames
;
i
+
+
)
{
if
(
disp_order
=
=
map
[
i
]
.
disp_order
)
return
1
;
}
return
0
;
}
static
void
add_ref_to_slot
(
RefBufMapData
*
ref
int
*
const
remapped_ref_idx
int
frame
)
{
remapped_ref_idx
[
frame
-
LAST_FRAME
]
=
ref
-
>
map_idx
;
ref
-
>
used
=
1
;
}
#
define
LOW_LEVEL_FRAMES_TR
5
static
void
set_unmapped_ref
(
RefBufMapData
*
buffer_map
int
n_bufs
int
n_min_level_refs
int
min_level
int
cur_frame_disp
)
{
int
max_dist
=
0
;
int
unmapped_idx
=
-
1
;
if
(
n_bufs
<
=
ALTREF_FRAME
)
return
;
for
(
int
i
=
0
;
i
<
n_bufs
;
i
+
+
)
{
if
(
buffer_map
[
i
]
.
used
)
continue
;
if
(
buffer_map
[
i
]
.
pyr_level
!
=
min_level
|
|
n_min_level_refs
>
=
LOW_LEVEL_FRAMES_TR
)
{
int
dist
=
abs
(
cur_frame_disp
-
buffer_map
[
i
]
.
disp_order
)
;
if
(
dist
>
max_dist
)
{
max_dist
=
dist
;
unmapped_idx
=
i
;
}
}
}
assert
(
unmapped_idx
>
=
0
&
&
"
Unmapped
reference
not
found
"
)
;
buffer_map
[
unmapped_idx
]
.
used
=
1
;
}
void
av1_get_ref_frames
(
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
int
cur_frame_disp
const
AV1_COMP
*
cpi
int
gf_index
int
is_parallel_encode
int
remapped_ref_idx
[
REF_FRAMES
]
)
{
int
buf_map_idx
=
0
;
for
(
int
i
=
0
;
i
<
REF_FRAMES
;
+
+
i
)
remapped_ref_idx
[
i
]
=
INVALID_IDX
;
#
if
!
CONFIG_REALTIME_ONLY
if
(
cpi
-
>
use_ducky_encode
&
&
cpi
-
>
ducky_encode_info
.
frame_info
.
gop_mode
=
=
DUCKY_ENCODE_GOP_MODE_RCL
)
{
for
(
int
rf
=
LAST_FRAME
;
rf
<
REF_FRAMES
;
+
+
rf
)
{
if
(
cpi
-
>
ppi
-
>
gf_group
.
ref_frame_list
[
gf_index
]
[
rf
]
!
=
INVALID_IDX
)
{
remapped_ref_idx
[
rf
-
LAST_FRAME
]
=
cpi
-
>
ppi
-
>
gf_group
.
ref_frame_list
[
gf_index
]
[
rf
]
;
}
}
int
valid_rf_idx
=
0
;
static
const
int
ref_frame_type_order
[
REF_FRAMES
-
LAST_FRAME
]
=
{
GOLDEN_FRAME
ALTREF_FRAME
LAST_FRAME
BWDREF_FRAME
ALTREF2_FRAME
LAST2_FRAME
LAST3_FRAME
}
;
for
(
int
i
=
0
;
i
<
REF_FRAMES
-
LAST_FRAME
;
i
+
+
)
{
int
rf
=
ref_frame_type_order
[
i
]
;
if
(
remapped_ref_idx
[
rf
-
LAST_FRAME
]
!
=
INVALID_IDX
)
{
valid_rf_idx
=
remapped_ref_idx
[
rf
-
LAST_FRAME
]
;
break
;
}
}
for
(
int
i
=
0
;
i
<
REF_FRAMES
;
+
+
i
)
{
if
(
remapped_ref_idx
[
i
]
=
=
INVALID_IDX
)
{
remapped_ref_idx
[
i
]
=
valid_rf_idx
;
}
}
return
;
}
#
endif
RefBufMapData
buffer_map
[
REF_FRAMES
]
;
int
n_bufs
=
0
;
memset
(
buffer_map
0
REF_FRAMES
*
sizeof
(
buffer_map
[
0
]
)
)
;
int
min_level
=
MAX_ARF_LAYERS
;
int
max_level
=
0
;
GF_GROUP
*
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
int
skip_ref_unmapping
=
0
;
int
is_one_pass_rt
=
is_one_pass_rt_params
(
cpi
)
;
for
(
int
map_idx
=
0
;
map_idx
<
REF_FRAMES
;
map_idx
+
+
)
{
RefFrameMapPair
ref_pair
=
ref_frame_map_pairs
[
map_idx
]
;
if
(
ref_pair
.
disp_order
=
=
-
1
)
continue
;
const
int
frame_order
=
ref_pair
.
disp_order
;
if
(
is_in_ref_map
(
buffer_map
frame_order
n_bufs
)
)
continue
;
const
int
reference_frame_level
=
ref_pair
.
pyr_level
;
if
(
reference_frame_level
<
min_level
)
min_level
=
reference_frame_level
;
if
(
reference_frame_level
>
max_level
)
max_level
=
reference_frame_level
;
buffer_map
[
n_bufs
]
.
map_idx
=
map_idx
;
buffer_map
[
n_bufs
]
.
disp_order
=
frame_order
;
buffer_map
[
n_bufs
]
.
pyr_level
=
reference_frame_level
;
buffer_map
[
n_bufs
]
.
used
=
0
;
n_bufs
+
+
;
}
qsort
(
buffer_map
n_bufs
sizeof
(
buffer_map
[
0
]
)
compare_map_idx_pair_asc
)
;
int
n_min_level_refs
=
0
;
int
closest_past_ref
=
-
1
;
int
golden_idx
=
-
1
;
int
altref_idx
=
-
1
;
for
(
int
i
=
n_bufs
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
buffer_map
[
i
]
.
pyr_level
=
=
min_level
)
{
n_min_level_refs
+
+
;
if
(
buffer_map
[
i
]
.
disp_order
<
cur_frame_disp
&
&
golden_idx
=
=
-
1
&
&
remapped_ref_idx
[
GOLDEN_FRAME
-
LAST_FRAME
]
=
=
INVALID_IDX
)
{
golden_idx
=
i
;
}
else
if
(
buffer_map
[
i
]
.
disp_order
>
cur_frame_disp
&
&
altref_idx
=
=
-
1
&
&
remapped_ref_idx
[
ALTREF_FRAME
-
LAST_FRAME
]
=
=
INVALID_IDX
)
{
altref_idx
=
i
;
}
}
else
if
(
buffer_map
[
i
]
.
disp_order
=
=
cur_frame_disp
)
{
add_ref_to_slot
(
&
buffer_map
[
i
]
remapped_ref_idx
BWDREF_FRAME
)
;
}
if
(
!
is_one_pass_rt
&
&
gf_group
-
>
frame_parallel_level
[
gf_index
]
=
=
2
&
&
gf_group
-
>
frame_parallel_level
[
gf_index
-
1
]
=
=
1
&
&
gf_group
-
>
update_type
[
gf_index
-
1
]
=
=
INTNL_ARF_UPDATE
)
{
assert
(
gf_group
-
>
update_type
[
gf_index
]
=
=
INTNL_ARF_UPDATE
)
;
#
if
CONFIG_FPMT_TEST
is_parallel_encode
=
(
cpi
-
>
ppi
-
>
fpmt_unit_test_cfg
=
=
PARALLEL_ENCODE
)
?
is_parallel_encode
:
0
;
#
endif
assert
(
IMPLIES
(
is_parallel_encode
cpi
-
>
ref_idx_to_skip
!
=
INVALID_IDX
)
)
;
assert
(
IMPLIES
(
!
is_parallel_encode
gf_group
-
>
skip_frame_as_ref
[
gf_index
]
!
=
INVALID_IDX
)
)
;
buffer_map
[
i
]
.
used
=
is_parallel_encode
?
(
buffer_map
[
i
]
.
map_idx
=
=
cpi
-
>
ref_idx_to_skip
)
:
(
buffer_map
[
i
]
.
disp_order
=
=
gf_group
-
>
skip_frame_as_ref
[
gf_index
]
)
;
if
(
buffer_map
[
i
]
.
used
)
skip_ref_unmapping
=
1
;
}
if
(
buffer_map
[
i
]
.
disp_order
<
cur_frame_disp
&
&
closest_past_ref
<
0
)
closest_past_ref
=
i
;
}
if
(
n_min_level_refs
<
=
n_bufs
)
{
if
(
golden_idx
>
-
1
)
add_ref_to_slot
(
&
buffer_map
[
golden_idx
]
remapped_ref_idx
GOLDEN_FRAME
)
;
if
(
altref_idx
>
-
1
)
add_ref_to_slot
(
&
buffer_map
[
altref_idx
]
remapped_ref_idx
ALTREF_FRAME
)
;
}
if
(
!
skip_ref_unmapping
)
set_unmapped_ref
(
buffer_map
n_bufs
n_min_level_refs
min_level
cur_frame_disp
)
;
for
(
int
frame
=
LAST_FRAME
;
frame
<
GOLDEN_FRAME
;
frame
+
+
)
{
if
(
remapped_ref_idx
[
frame
-
LAST_FRAME
]
!
=
INVALID_IDX
)
continue
;
int
next_buf_max
=
0
;
int
next_disp_order
=
INT_MIN
;
for
(
buf_map_idx
=
n_bufs
-
1
;
buf_map_idx
>
=
0
;
buf_map_idx
-
-
)
{
if
(
!
buffer_map
[
buf_map_idx
]
.
used
&
&
buffer_map
[
buf_map_idx
]
.
disp_order
<
cur_frame_disp
&
&
buffer_map
[
buf_map_idx
]
.
disp_order
>
next_disp_order
)
{
next_disp_order
=
buffer_map
[
buf_map_idx
]
.
disp_order
;
next_buf_max
=
buf_map_idx
;
}
}
buf_map_idx
=
next_buf_max
;
if
(
buf_map_idx
<
0
)
break
;
if
(
buffer_map
[
buf_map_idx
]
.
used
)
break
;
add_ref_to_slot
(
&
buffer_map
[
buf_map_idx
]
remapped_ref_idx
frame
)
;
}
for
(
int
frame
=
BWDREF_FRAME
;
frame
<
REF_FRAMES
;
frame
+
+
)
{
if
(
remapped_ref_idx
[
frame
-
LAST_FRAME
]
!
=
INVALID_IDX
)
continue
;
int
next_buf_max
=
0
;
int
next_disp_order
=
INT_MAX
;
for
(
buf_map_idx
=
n_bufs
-
1
;
buf_map_idx
>
=
0
;
buf_map_idx
-
-
)
{
if
(
!
buffer_map
[
buf_map_idx
]
.
used
&
&
buffer_map
[
buf_map_idx
]
.
disp_order
>
cur_frame_disp
&
&
buffer_map
[
buf_map_idx
]
.
disp_order
<
next_disp_order
)
{
next_disp_order
=
buffer_map
[
buf_map_idx
]
.
disp_order
;
next_buf_max
=
buf_map_idx
;
}
}
buf_map_idx
=
next_buf_max
;
if
(
buf_map_idx
<
0
)
break
;
if
(
buffer_map
[
buf_map_idx
]
.
used
)
break
;
add_ref_to_slot
(
&
buffer_map
[
buf_map_idx
]
remapped_ref_idx
frame
)
;
}
buf_map_idx
=
closest_past_ref
;
for
(
int
frame
=
LAST_FRAME
;
frame
<
REF_FRAMES
;
frame
+
+
)
{
if
(
remapped_ref_idx
[
frame
-
LAST_FRAME
]
!
=
INVALID_IDX
)
continue
;
for
(
;
buf_map_idx
>
=
0
;
buf_map_idx
-
-
)
{
if
(
!
buffer_map
[
buf_map_idx
]
.
used
)
break
;
}
if
(
buf_map_idx
<
0
)
break
;
if
(
buffer_map
[
buf_map_idx
]
.
used
)
break
;
add_ref_to_slot
(
&
buffer_map
[
buf_map_idx
]
remapped_ref_idx
frame
)
;
}
buf_map_idx
=
n_bufs
-
1
;
for
(
int
frame
=
ALTREF_FRAME
;
frame
>
=
LAST_FRAME
;
frame
-
-
)
{
if
(
remapped_ref_idx
[
frame
-
LAST_FRAME
]
!
=
INVALID_IDX
)
continue
;
for
(
;
buf_map_idx
>
closest_past_ref
;
buf_map_idx
-
-
)
{
if
(
!
buffer_map
[
buf_map_idx
]
.
used
)
break
;
}
if
(
buf_map_idx
<
0
)
break
;
if
(
buffer_map
[
buf_map_idx
]
.
used
)
break
;
add_ref_to_slot
(
&
buffer_map
[
buf_map_idx
]
remapped_ref_idx
frame
)
;
}
for
(
int
i
=
0
;
i
<
REF_FRAMES
;
+
+
i
)
if
(
remapped_ref_idx
[
i
]
=
=
INVALID_IDX
)
remapped_ref_idx
[
i
]
=
0
;
}
int
av1_encode_strategy
(
AV1_COMP
*
const
cpi
size_t
*
const
size
uint8_t
*
const
dest
unsigned
int
*
frame_flags
int64_t
*
const
time_stamp
int64_t
*
const
time_end
const
aom_rational64_t
*
const
timestamp_ratio
int
*
const
pop_lookahead
int
flush
)
{
AV1EncoderConfig
*
const
oxcf
=
&
cpi
-
>
oxcf
;
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
GF_GROUP
*
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
ExternalFlags
*
const
ext_flags
=
&
cpi
-
>
ext_flags
;
GFConfig
*
const
gf_cfg
=
&
oxcf
-
>
gf_cfg
;
EncodeFrameInput
frame_input
;
EncodeFrameParams
frame_params
;
EncodeFrameResults
frame_results
;
memset
(
&
frame_input
0
sizeof
(
frame_input
)
)
;
memset
(
&
frame_params
0
sizeof
(
frame_params
)
)
;
memset
(
&
frame_results
0
sizeof
(
frame_results
)
)
;
#
if
CONFIG_BITRATE_ACCURACY
&
&
CONFIG_THREE_PASS
VBR_RATECTRL_INFO
*
vbr_rc_info
=
&
cpi
-
>
vbr_rc_info
;
if
(
oxcf
-
>
pass
=
=
AOM_RC_THIRD_PASS
&
&
vbr_rc_info
-
>
ready
=
=
0
)
{
THIRD_PASS_FRAME_INFO
frame_info
[
MAX_THIRD_PASS_BUF
]
;
av1_open_second_pass_log
(
cpi
1
)
;
FILE
*
second_pass_log_stream
=
cpi
-
>
second_pass_log_stream
;
fseek
(
second_pass_log_stream
0
SEEK_END
)
;
size_t
file_size
=
ftell
(
second_pass_log_stream
)
;
rewind
(
second_pass_log_stream
)
;
size_t
read_size
=
0
;
while
(
read_size
<
file_size
)
{
THIRD_PASS_GOP_INFO
gop_info
;
struct
aom_internal_error_info
*
error
=
cpi
-
>
common
.
error
;
av1_read_second_pass_gop_info
(
second_pass_log_stream
&
gop_info
error
)
;
TPL_INFO
*
tpl_info
;
AOM_CHECK_MEM_ERROR
(
cm
-
>
error
tpl_info
aom_malloc
(
sizeof
(
*
tpl_info
)
)
)
;
av1_read_tpl_info
(
tpl_info
second_pass_log_stream
error
)
;
av1_read_second_pass_per_frame_info
(
second_pass_log_stream
frame_info
gop_info
.
num_frames
error
)
;
av1_vbr_rc_append_tpl_info
(
vbr_rc_info
tpl_info
)
;
read_size
=
ftell
(
second_pass_log_stream
)
;
aom_free
(
tpl_info
)
;
}
av1_close_second_pass_log
(
cpi
)
;
if
(
cpi
-
>
oxcf
.
rc_cfg
.
mode
=
=
AOM_Q
)
{
vbr_rc_info
-
>
base_q_index
=
cpi
-
>
oxcf
.
rc_cfg
.
cq_level
;
av1_vbr_rc_compute_q_indices
(
vbr_rc_info
-
>
base_q_index
vbr_rc_info
-
>
total_frame_count
vbr_rc_info
-
>
qstep_ratio_list
cm
-
>
seq_params
-
>
bit_depth
vbr_rc_info
-
>
q_index_list
)
;
}
else
{
vbr_rc_info
-
>
base_q_index
=
av1_vbr_rc_info_estimate_base_q
(
vbr_rc_info
-
>
total_bit_budget
cm
-
>
seq_params
-
>
bit_depth
vbr_rc_info
-
>
scale_factors
vbr_rc_info
-
>
total_frame_count
vbr_rc_info
-
>
update_type_list
vbr_rc_info
-
>
qstep_ratio_list
vbr_rc_info
-
>
txfm_stats_list
vbr_rc_info
-
>
q_index_list
NULL
)
;
}
vbr_rc_info
-
>
ready
=
1
;
#
if
CONFIG_RATECTRL_LOG
rc_log_record_chunk_info
(
&
cpi
-
>
rc_log
vbr_rc_info
-
>
base_q_index
vbr_rc_info
-
>
total_frame_count
)
;
#
endif
}
#
endif
if
(
flush
=
=
0
)
{
int
srcbuf_size
=
av1_lookahead_depth
(
cpi
-
>
ppi
-
>
lookahead
cpi
-
>
compressor_stage
)
;
int
pop_size
=
av1_lookahead_pop_sz
(
cpi
-
>
ppi
-
>
lookahead
cpi
-
>
compressor_stage
)
;
if
(
srcbuf_size
<
pop_size
)
return
-
1
;
}
if
(
!
av1_lookahead_peek
(
cpi
-
>
ppi
-
>
lookahead
0
cpi
-
>
compressor_stage
)
)
{
#
if
!
CONFIG_REALTIME_ONLY
if
(
flush
&
&
oxcf
-
>
pass
=
=
AOM_RC_FIRST_PASS
&
&
!
cpi
-
>
ppi
-
>
twopass
.
first_pass_done
)
{
av1_end_first_pass
(
cpi
)
;
cpi
-
>
ppi
-
>
twopass
.
first_pass_done
=
1
;
}
#
endif
return
-
1
;
}
if
(
has_no_stats_stage
(
cpi
)
)
{
gf_cfg
-
>
gf_max_pyr_height
=
AOMMIN
(
gf_cfg
-
>
gf_max_pyr_height
USE_ALTREF_FOR_ONE_PASS
)
;
gf_cfg
-
>
gf_min_pyr_height
=
AOMMIN
(
gf_cfg
-
>
gf_min_pyr_height
gf_cfg
-
>
gf_max_pyr_height
)
;
}
alloc_mb_mode_info_buffers
(
cpi
)
;
cpi
-
>
skip_tpl_setup_stats
=
0
;
#
if
!
CONFIG_REALTIME_ONLY
if
(
oxcf
-
>
pass
!
=
AOM_RC_FIRST_PASS
)
{
TplParams
*
const
tpl_data
=
&
cpi
-
>
ppi
-
>
tpl_data
;
if
(
tpl_data
-
>
tpl_stats_pool
[
0
]
=
=
NULL
)
{
av1_setup_tpl_buffers
(
cpi
-
>
ppi
&
cm
-
>
mi_params
oxcf
-
>
frm_dim_cfg
.
width
oxcf
-
>
frm_dim_cfg
.
height
0
oxcf
-
>
gf_cfg
.
lag_in_frames
)
;
}
}
cpi
-
>
twopass_frame
.
this_frame
=
NULL
;
const
int
use_one_pass_rt_params
=
is_one_pass_rt_params
(
cpi
)
;
if
(
!
use_one_pass_rt_params
&
&
!
is_stat_generation_stage
(
cpi
)
)
{
#
if
CONFIG_COLLECT_COMPONENT_TIMING
start_timing
(
cpi
av1_get_second_pass_params_time
)
;
#
endif
if
(
cpi
-
>
ppi
-
>
gf_group
.
frame_parallel_level
[
cpi
-
>
gf_frame_index
]
>
0
)
{
for
(
int
i
=
0
;
i
<
RATE_FACTOR_LEVELS
;
i
+
+
)
{
cpi
-
>
rc
.
frame_level_rate_correction_factors
[
i
]
=
#
if
CONFIG_FPMT_TEST
(
cpi
-
>
ppi
-
>
fpmt_unit_test_cfg
=
=
PARALLEL_SIMULATION_ENCODE
)
?
cpi
-
>
ppi
-
>
p_rc
.
temp_rate_correction_factors
[
i
]
:
#
endif
cpi
-
>
ppi
-
>
p_rc
.
rate_correction_factors
[
i
]
;
}
}
cpi
-
>
mv_stats
=
cpi
-
>
ppi
-
>
mv_stats
;
av1_get_second_pass_params
(
cpi
&
frame_params
*
frame_flags
)
;
#
if
CONFIG_COLLECT_COMPONENT_TIMING
end_timing
(
cpi
av1_get_second_pass_params_time
)
;
#
endif
}
#
endif
if
(
!
is_stat_generation_stage
(
cpi
)
)
{
if
(
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
OVERLAY_UPDATE
&
&
gf_group
-
>
refbuf_state
[
cpi
-
>
gf_frame_index
]
=
=
REFBUF_RESET
)
{
frame_params
.
show_existing_frame
=
1
;
}
else
{
frame_params
.
show_existing_frame
=
(
cpi
-
>
ppi
-
>
show_existing_alt_ref
&
&
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
OVERLAY_UPDATE
)
|
|
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
INTNL_OVERLAY_UPDATE
;
}
frame_params
.
show_existing_frame
&
=
allow_show_existing
(
cpi
*
frame_flags
)
;
if
(
oxcf
-
>
rc_cfg
.
drop_frames_water_mark
&
&
(
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
OVERLAY_UPDATE
|
|
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
INTNL_OVERLAY_UPDATE
)
)
{
int
cur_disp_idx
=
gf_group
-
>
display_idx
[
cpi
-
>
gf_frame_index
]
;
for
(
int
idx
=
0
;
idx
<
cpi
-
>
gf_frame_index
;
idx
+
+
)
{
if
(
cur_disp_idx
=
=
gf_group
-
>
display_idx
[
idx
]
)
{
assert
(
IMPLIES
(
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
OVERLAY_UPDATE
gf_group
-
>
update_type
[
idx
]
=
=
ARF_UPDATE
)
)
;
assert
(
IMPLIES
(
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
INTNL_OVERLAY_UPDATE
gf_group
-
>
update_type
[
idx
]
=
=
INTNL_ARF_UPDATE
)
)
;
if
(
gf_group
-
>
is_frame_dropped
[
idx
]
)
{
frame_params
.
show_existing_frame
=
0
;
assert
(
!
cpi
-
>
is_dropped_frame
)
;
cpi
-
>
is_dropped_frame
=
true
;
}
break
;
}
}
}
if
(
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
=
=
OVERLAY_UPDATE
)
{
cpi
-
>
ppi
-
>
show_existing_alt_ref
=
0
;
}
}
else
{
frame_params
.
show_existing_frame
=
0
;
}
struct
lookahead_entry
*
source
=
NULL
;
struct
lookahead_entry
*
last_source
=
NULL
;
if
(
frame_params
.
show_existing_frame
)
{
source
=
av1_lookahead_peek
(
cpi
-
>
ppi
-
>
lookahead
0
cpi
-
>
compressor_stage
)
;
*
pop_lookahead
=
1
;
frame_params
.
show_frame
=
1
;
}
else
{
source
=
choose_frame_source
(
cpi
&
flush
pop_lookahead
&
last_source
&
frame_params
.
show_frame
)
;
}
if
(
source
=
=
NULL
)
{
#
if
!
CONFIG_REALTIME_ONLY
if
(
flush
&
&
oxcf
-
>
pass
=
=
AOM_RC_FIRST_PASS
&
&
!
cpi
-
>
ppi
-
>
twopass
.
first_pass_done
)
{
av1_end_first_pass
(
cpi
)
;
cpi
-
>
ppi
-
>
twopass
.
first_pass_done
=
1
;
}
#
endif
return
-
1
;
}
gf_group
-
>
src_offset
[
cpi
-
>
gf_frame_index
]
=
0
;
frame_input
.
source
=
&
source
-
>
img
;
if
(
(
cpi
-
>
ppi
-
>
use_svc
|
|
cpi
-
>
rc
.
prev_frame_is_dropped
)
&
&
last_source
!
=
NULL
)
av1_svc_set_last_source
(
cpi
&
frame_input
&
last_source
-
>
img
)
;
else
frame_input
.
last_source
=
last_source
!
=
NULL
?
&
last_source
-
>
img
:
NULL
;
frame_input
.
ts_duration
=
source
-
>
ts_end
-
source
-
>
ts_start
;
cpi
-
>
unfiltered_source
=
frame_input
.
source
;
*
time_stamp
=
source
-
>
ts_start
;
*
time_end
=
source
-
>
ts_end
;
if
(
source
-
>
ts_start
<
cpi
-
>
time_stamps
.
first_ts_start
)
{
cpi
-
>
time_stamps
.
first_ts_start
=
source
-
>
ts_start
;
cpi
-
>
time_stamps
.
prev_ts_end
=
source
-
>
ts_start
;
}
av1_apply_encoding_flags
(
cpi
source
-
>
flags
)
;
*
frame_flags
=
(
source
-
>
flags
&
AOM_EFLAG_FORCE_KF
)
?
FRAMEFLAGS_KEY
:
0
;
#
if
CONFIG_FPMT_TEST
if
(
cpi
-
>
ppi
-
>
fpmt_unit_test_cfg
=
=
PARALLEL_SIMULATION_ENCODE
)
{
if
(
cpi
-
>
ppi
-
>
gf_group
.
frame_parallel_level
[
cpi
-
>
gf_frame_index
]
>
0
)
{
cpi
-
>
framerate
=
cpi
-
>
temp_framerate
;
}
}
#
endif
if
(
frame_params
.
show_frame
)
adjust_frame_rate
(
cpi
source
-
>
ts_start
source
-
>
ts_end
)
;
if
(
!
frame_params
.
show_existing_frame
)
{
if
(
cpi
-
>
film_grain_table
)
{
cm
-
>
cur_frame
-
>
film_grain_params_present
=
aom_film_grain_table_lookup
(
cpi
-
>
film_grain_table
*
time_stamp
*
time_end
0
&
cm
-
>
film_grain_params
)
;
}
else
{
cm
-
>
cur_frame
-
>
film_grain_params_present
=
cm
-
>
seq_params
-
>
film_grain_params_present
;
}
const
int64_t
pts64
=
ticks_to_timebase_units
(
timestamp_ratio
*
time_stamp
)
;
if
(
pts64
<
0
|
|
pts64
>
UINT32_MAX
)
return
AOM_CODEC_ERROR
;
cm
-
>
frame_presentation_time
=
(
uint32_t
)
pts64
;
}
#
if
CONFIG_COLLECT_COMPONENT_TIMING
start_timing
(
cpi
av1_get_one_pass_rt_params_time
)
;
#
endif
#
if
CONFIG_REALTIME_ONLY
av1_get_one_pass_rt_params
(
cpi
&
frame_params
.
frame_type
&
frame_input
*
frame_flags
)
;
if
(
use_rtc_reference_structure_one_layer
(
cpi
)
)
av1_set_rtc_reference_structure_one_layer
(
cpi
cpi
-
>
gf_frame_index
=
=
0
)
;
#
else
if
(
use_one_pass_rt_params
)
{
av1_get_one_pass_rt_params
(
cpi
&
frame_params
.
frame_type
&
frame_input
*
frame_flags
)
;
if
(
use_rtc_reference_structure_one_layer
(
cpi
)
)
av1_set_rtc_reference_structure_one_layer
(
cpi
cpi
-
>
gf_frame_index
=
=
0
)
;
}
#
endif
#
if
CONFIG_COLLECT_COMPONENT_TIMING
end_timing
(
cpi
av1_get_one_pass_rt_params_time
)
;
#
endif
FRAME_UPDATE_TYPE
frame_update_type
=
get_frame_update_type
(
gf_group
cpi
-
>
gf_frame_index
)
;
if
(
frame_params
.
show_existing_frame
&
&
frame_params
.
frame_type
!
=
KEY_FRAME
)
{
frame_params
.
frame_type
=
INTER_FRAME
;
}
frame_params
.
speed
=
oxcf
-
>
speed
;
#
if
!
CONFIG_REALTIME_ONLY
if
(
!
use_one_pass_rt_params
&
&
(
is_stat_generation_stage
(
cpi
)
|
|
has_no_stats_stage
(
cpi
)
)
)
{
const
int
kf_requested
=
(
cm
-
>
current_frame
.
frame_number
=
=
0
|
|
oxcf
-
>
kf_cfg
.
key_freq_max
=
=
0
|
|
(
*
frame_flags
&
FRAMEFLAGS_KEY
)
)
;
if
(
kf_requested
&
&
frame_update_type
!
=
OVERLAY_UPDATE
&
&
frame_update_type
!
=
INTNL_OVERLAY_UPDATE
)
{
frame_params
.
frame_type
=
KEY_FRAME
;
}
else
if
(
is_stat_generation_stage
(
cpi
)
)
{
frame_params
.
frame_type
=
INTER_FRAME
;
}
}
#
endif
if
(
has_no_stats_stage
(
cpi
)
&
&
oxcf
-
>
q_cfg
.
aq_mode
=
=
CYCLIC_REFRESH_AQ
)
{
av1_cyclic_refresh_update_parameters
(
cpi
)
;
}
else
if
(
is_stat_generation_stage
(
cpi
)
)
{
cpi
-
>
td
.
mb
.
e_mbd
.
lossless
[
0
]
=
is_lossless_requested
(
&
oxcf
-
>
rc_cfg
)
;
}
else
if
(
is_stat_consumption_stage
(
cpi
)
)
{
#
if
CONFIG_MISMATCH_DEBUG
mismatch_move_frame_idx_w
(
)
;
#
endif
#
if
TXCOEFF_COST_TIMER
cm
-
>
txcoeff_cost_timer
=
0
;
cm
-
>
txcoeff_cost_count
=
0
;
#
endif
}
if
(
!
is_stat_generation_stage
(
cpi
)
)
set_ext_overrides
(
cm
&
frame_params
ext_flags
)
;
const
int
force_refresh_all
=
(
(
frame_params
.
frame_type
=
=
KEY_FRAME
&
&
frame_params
.
show_frame
)
|
|
frame_params
.
frame_type
=
=
S_FRAME
)
&
&
!
frame_params
.
show_existing_frame
;
av1_configure_buffer_updates
(
cpi
&
frame_params
.
refresh_frame
frame_update_type
gf_group
-
>
refbuf_state
[
cpi
-
>
gf_frame_index
]
force_refresh_all
)
;
if
(
!
is_stat_generation_stage
(
cpi
)
)
{
const
YV12_BUFFER_CONFIG
*
ref_frame_buf
[
INTER_REFS_PER_FRAME
]
;
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
;
init_ref_map_pair
(
cpi
ref_frame_map_pairs
)
;
const
int
order_offset
=
gf_group
-
>
arf_src_offset
[
cpi
-
>
gf_frame_index
]
;
const
int
cur_frame_disp
=
cpi
-
>
common
.
current_frame
.
frame_number
+
order_offset
;
int
get_ref_frames
=
0
;
#
if
CONFIG_FPMT_TEST
get_ref_frames
=
(
cpi
-
>
ppi
-
>
fpmt_unit_test_cfg
=
=
PARALLEL_SIMULATION_ENCODE
)
?
1
:
0
;
#
endif
if
(
get_ref_frames
|
|
gf_group
-
>
frame_parallel_level
[
cpi
-
>
gf_frame_index
]
=
=
0
)
{
if
(
!
ext_flags
-
>
refresh_frame
.
update_pending
)
{
av1_get_ref_frames
(
ref_frame_map_pairs
cur_frame_disp
cpi
cpi
-
>
gf_frame_index
1
cm
-
>
remapped_ref_idx
)
;
}
else
if
(
cpi
-
>
ppi
-
>
rtc_ref
.
set_ref_frame_config
|
|
use_rtc_reference_structure_one_layer
(
cpi
)
)
{
for
(
unsigned
int
i
=
0
;
i
<
INTER_REFS_PER_FRAME
;
i
+
+
)
cm
-
>
remapped_ref_idx
[
i
]
=
cpi
-
>
ppi
-
>
rtc_ref
.
ref_idx
[
i
]
;
}
}
bool
has_ref_frames
=
false
;
for
(
int
i
=
0
;
i
<
INTER_REFS_PER_FRAME
;
+
+
i
)
{
const
RefCntBuffer
*
ref_frame
=
get_ref_frame_buf
(
cm
ref_frame_priority_order
[
i
]
)
;
ref_frame_buf
[
i
]
=
ref_frame
!
=
NULL
?
&
ref_frame
-
>
buf
:
NULL
;
if
(
ref_frame
!
=
NULL
)
has_ref_frames
=
true
;
}
if
(
!
has_ref_frames
&
&
(
frame_params
.
frame_type
=
=
INTER_FRAME
|
|
frame_params
.
frame_type
=
=
S_FRAME
)
)
{
return
AOM_CODEC_ERROR
;
}
frame_params
.
ref_frame_flags
=
get_ref_frame_flags
(
&
cpi
-
>
sf
is_one_pass_rt_params
(
cpi
)
ref_frame_buf
ext_flags
-
>
ref_frame_flags
)
;
if
(
cpi
-
>
ppi
-
>
gf_group
.
is_frame_non_ref
[
cpi
-
>
gf_frame_index
]
)
{
frame_params
.
primary_ref_frame
=
PRIMARY_REF_NONE
;
}
else
{
frame_params
.
primary_ref_frame
=
choose_primary_ref_frame
(
cpi
&
frame_params
)
;
}
frame_params
.
order_offset
=
gf_group
-
>
arf_src_offset
[
cpi
-
>
gf_frame_index
]
;
if
(
!
cpi
-
>
refresh_idx_available
)
{
frame_params
.
refresh_frame_flags
=
av1_get_refresh_frame_flags
(
cpi
&
frame_params
frame_update_type
cpi
-
>
gf_frame_index
cur_frame_disp
ref_frame_map_pairs
)
;
}
else
{
assert
(
cpi
-
>
ref_refresh_index
!
=
INVALID_IDX
)
;
frame_params
.
refresh_frame_flags
=
(
1
<
<
cpi
-
>
ref_refresh_index
)
;
}
if
(
gf_group
-
>
is_frame_non_ref
[
cpi
-
>
gf_frame_index
]
)
frame_params
.
refresh_frame_flags
=
0
;
frame_params
.
existing_fb_idx_to_show
=
INVALID_IDX
;
if
(
frame_params
.
show_existing_frame
)
{
for
(
int
frame
=
0
;
frame
<
REF_FRAMES
;
frame
+
+
)
{
const
RefCntBuffer
*
const
buf
=
cm
-
>
ref_frame_map
[
frame
]
;
if
(
buf
=
=
NULL
)
continue
;
const
int
frame_order
=
(
int
)
buf
-
>
display_order_hint
;
if
(
frame_order
=
=
cur_frame_disp
)
frame_params
.
existing_fb_idx_to_show
=
frame
;
}
}
}
memcpy
(
frame_params
.
remapped_ref_idx
cm
-
>
remapped_ref_idx
REF_FRAMES
*
sizeof
(
*
cm
-
>
remapped_ref_idx
)
)
;
cpi
-
>
td
.
mb
.
rdmult_delta_qindex
=
cpi
-
>
td
.
mb
.
delta_qindex
=
0
;
if
(
!
frame_params
.
show_existing_frame
)
{
cm
-
>
quant_params
.
using_qmatrix
=
oxcf
-
>
q_cfg
.
using_qm
;
}
const
int
is_intra_frame
=
frame_params
.
frame_type
=
=
KEY_FRAME
|
|
frame_params
.
frame_type
=
=
INTRA_ONLY_FRAME
;
FeatureFlags
*
const
features
=
&
cm
-
>
features
;
if
(
!
is_stat_generation_stage
(
cpi
)
&
&
(
oxcf
-
>
pass
=
=
AOM_RC_ONE_PASS
|
|
oxcf
-
>
pass
>
=
AOM_RC_SECOND_PASS
)
&
&
is_intra_frame
)
{
av1_set_screen_content_options
(
cpi
features
)
;
}
#
if
CONFIG_REALTIME_ONLY
if
(
av1_encode
(
cpi
dest
&
frame_input
&
frame_params
&
frame_results
)
!
=
AOM_CODEC_OK
)
{
return
AOM_CODEC_ERROR
;
}
#
else
if
(
has_no_stats_stage
(
cpi
)
&
&
oxcf
-
>
mode
=
=
REALTIME
&
&
gf_cfg
-
>
lag_in_frames
=
=
0
)
{
if
(
av1_encode
(
cpi
dest
&
frame_input
&
frame_params
&
frame_results
)
!
=
AOM_CODEC_OK
)
{
return
AOM_CODEC_ERROR
;
}
}
else
if
(
denoise_and_encode
(
cpi
dest
&
frame_input
&
frame_params
&
frame_results
)
!
=
AOM_CODEC_OK
)
{
return
AOM_CODEC_ERROR
;
}
#
endif
if
(
is_psnr_calc_enabled
(
cpi
)
&
&
cpi
-
>
sf
.
rt_sf
.
use_rtc_tf
)
{
assert
(
cpi
-
>
orig_source
.
buffer_alloc_sz
>
0
)
;
cpi
-
>
source
=
&
cpi
-
>
orig_source
;
}
if
(
!
is_stat_generation_stage
(
cpi
)
)
{
update_frame_flags
(
&
cpi
-
>
common
&
cpi
-
>
refresh_frame
frame_flags
)
;
set_additional_frame_flags
(
cm
frame_flags
)
;
}
#
if
!
CONFIG_REALTIME_ONLY
#
if
TXCOEFF_COST_TIMER
if
(
!
is_stat_generation_stage
(
cpi
)
)
{
cm
-
>
cum_txcoeff_cost_timer
+
=
cm
-
>
txcoeff_cost_timer
;
fprintf
(
stderr
"
\
ntxb
coeff
cost
block
number
:
%
ld
frame
time
:
%
ld
cum
time
%
ld
"
"
in
us
\
n
"
cm
-
>
txcoeff_cost_count
cm
-
>
txcoeff_cost_timer
cm
-
>
cum_txcoeff_cost_timer
)
;
}
#
endif
#
endif
#
if
CONFIG_TUNE_VMAF
if
(
!
is_stat_generation_stage
(
cpi
)
&
&
(
oxcf
-
>
tune_cfg
.
tuning
>
=
AOM_TUNE_VMAF_WITH_PREPROCESSING
&
&
oxcf
-
>
tune_cfg
.
tuning
<
=
AOM_TUNE_VMAF_NEG_MAX_GAIN
)
)
{
av1_update_vmaf_curve
(
cpi
)
;
}
#
endif
*
size
=
frame_results
.
size
;
if
(
*
size
>
0
)
{
cpi
-
>
droppable
=
is_frame_droppable
(
&
cpi
-
>
ppi
-
>
rtc_ref
&
ext_flags
-
>
refresh_frame
)
;
}
if
(
*
size
>
0
&
&
(
cpi
-
>
ppi
-
>
use_svc
|
|
cpi
-
>
oxcf
.
rc_cfg
.
drop_frames_water_mark
>
0
)
&
&
cpi
-
>
svc
.
spatial_layer_id
=
=
cpi
-
>
svc
.
number_spatial_layers
-
1
&
&
cpi
-
>
svc
.
temporal_layer_id
=
=
0
&
&
cpi
-
>
unscaled_source
-
>
y_width
=
=
cpi
-
>
svc
.
source_last_TL0
.
y_width
&
&
cpi
-
>
unscaled_source
-
>
y_height
=
=
cpi
-
>
svc
.
source_last_TL0
.
y_height
)
{
aom_yv12_copy_y
(
cpi
-
>
unscaled_source
&
cpi
-
>
svc
.
source_last_TL0
1
)
;
aom_yv12_copy_u
(
cpi
-
>
unscaled_source
&
cpi
-
>
svc
.
source_last_TL0
1
)
;
aom_yv12_copy_v
(
cpi
-
>
unscaled_source
&
cpi
-
>
svc
.
source_last_TL0
1
)
;
}
return
AOM_CODEC_OK
;
}
