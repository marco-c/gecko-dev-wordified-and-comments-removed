#
ifndef
AOM_AV1_ENCODER_TEMPORAL_FILTER_H_
#
define
AOM_AV1_ENCODER_TEMPORAL_FILTER_H_
#
include
<
stdbool
.
h
>
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
struct
AV1_COMP
;
struct
AV1EncoderConfig
;
struct
ThreadData
;
#
define
BH
32
#
define
BW
32
#
define
TF_BLOCK_SIZE
BLOCK_32X32
#
define
TF_WINDOW_LENGTH
5
static
const
double
SQRT_PI_BY_2
=
1
.
25331413732
;
#
define
TF_WEIGHT_SCALE
1000
#
define
TF_WINDOW_BLOCK_BALANCE_WEIGHT
5
#
define
TF_Q_DECAY_THRESHOLD
20
#
define
TF_SEARCH_ERROR_NORM_WEIGHT
20
#
define
TF_STRENGTH_THRESHOLD
4
#
define
TF_SEARCH_DISTANCE_THRESHOLD
0
.
1
#
define
TF_QINDEX_CUTOFF
128
#
define
NOISE_ESTIMATION_EDGE_THRESHOLD
50
typedef
struct
{
int64_t
sum
;
int64_t
sse
;
}
FRAME_DIFF
;
typedef
struct
{
YV12_BUFFER_CONFIG
*
frames
[
MAX_LAG_BUFFERS
]
;
int
num_frames
;
YV12_BUFFER_CONFIG
*
output_frame
;
int
filter_frame_idx
;
int
compute_frame_diff
;
struct
scale_factors
sf
;
double
noise_levels
[
MAX_MB_PLANE
]
;
int
num_pels
;
int
mb_rows
;
int
mb_cols
;
int
is_highbitdepth
;
int
q_factor
;
}
TemporalFilterCtx
;
#
define
TF_INFO_BUF_COUNT
2
typedef
struct
TEMPORAL_FILTER_INFO
{
int
is_temporal_filter_on
;
YV12_BUFFER_CONFIG
tf_buf
[
TF_INFO_BUF_COUNT
]
;
YV12_BUFFER_CONFIG
tf_buf_second_arf
;
FRAME_DIFF
frame_diff
[
TF_INFO_BUF_COUNT
]
;
int
tf_buf_gf_index
[
TF_INFO_BUF_COUNT
]
;
int
tf_buf_display_index_offset
[
TF_INFO_BUF_COUNT
]
;
int
tf_buf_valid
[
TF_INFO_BUF_COUNT
]
;
}
TEMPORAL_FILTER_INFO
;
int
av1_is_temporal_filter_on
(
const
struct
AV1EncoderConfig
*
oxcf
)
;
bool
av1_tf_info_alloc
(
TEMPORAL_FILTER_INFO
*
tf_info
const
struct
AV1_COMP
*
cpi
)
;
void
av1_tf_info_free
(
TEMPORAL_FILTER_INFO
*
tf_info
)
;
void
av1_tf_info_reset
(
TEMPORAL_FILTER_INFO
*
tf_info
)
;
void
av1_tf_info_filtering
(
TEMPORAL_FILTER_INFO
*
tf_info
struct
AV1_COMP
*
cpi
const
GF_GROUP
*
gf_group
)
;
YV12_BUFFER_CONFIG
*
av1_tf_info_get_filtered_buf
(
TEMPORAL_FILTER_INFO
*
tf_info
int
gf_index
FRAME_DIFF
*
frame_diff
)
;
typedef
struct
{
FRAME_DIFF
diff
;
MB_MODE_INFO
*
tmp_mbmi
;
uint32_t
*
accum
;
uint16_t
*
count
;
uint8_t
*
pred
;
}
TemporalFilterData
;
typedef
struct
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
*
mutex_
;
#
endif
int
next_tf_row
;
bool
tf_mt_exit
;
}
AV1TemporalFilterSync
;
void
av1_estimate_noise_level
(
const
YV12_BUFFER_CONFIG
*
frame
double
*
noise_level
int
plane_from
int
plane_to
int
bit_depth
int
edge_thresh
)
;
void
av1_tf_do_filtering_row
(
struct
AV1_COMP
*
cpi
struct
ThreadData
*
td
int
mb_row
)
;
void
av1_temporal_filter
(
struct
AV1_COMP
*
cpi
const
int
filter_frame_lookahead_idx
int
gf_frame_index
FRAME_DIFF
*
frame_diff
YV12_BUFFER_CONFIG
*
output_frame
)
;
int
av1_check_show_filtered_frame
(
const
YV12_BUFFER_CONFIG
*
frame
const
FRAME_DIFF
*
frame_diff
int
q_index
aom_bit_depth_t
bit_depth
)
;
int
av1_get_q
(
const
struct
AV1_COMP
*
cpi
)
;
static
AOM_INLINE
bool
tf_alloc_and_reset_data
(
TemporalFilterData
*
tf_data
int
num_pels
int
is_high_bitdepth
)
{
tf_data
-
>
tmp_mbmi
=
(
MB_MODE_INFO
*
)
aom_calloc
(
1
sizeof
(
*
tf_data
-
>
tmp_mbmi
)
)
;
tf_data
-
>
accum
=
(
uint32_t
*
)
aom_memalign
(
16
num_pels
*
sizeof
(
*
tf_data
-
>
accum
)
)
;
tf_data
-
>
count
=
(
uint16_t
*
)
aom_memalign
(
16
num_pels
*
sizeof
(
*
tf_data
-
>
count
)
)
;
if
(
is_high_bitdepth
)
tf_data
-
>
pred
=
CONVERT_TO_BYTEPTR
(
aom_memalign
(
32
num_pels
*
2
*
sizeof
(
*
tf_data
-
>
pred
)
)
)
;
else
tf_data
-
>
pred
=
(
uint8_t
*
)
aom_memalign
(
32
num_pels
*
sizeof
(
*
tf_data
-
>
pred
)
)
;
if
(
!
(
tf_data
-
>
tmp_mbmi
&
&
tf_data
-
>
accum
&
&
tf_data
-
>
count
&
&
tf_data
-
>
pred
)
)
return
false
;
memset
(
&
tf_data
-
>
diff
0
sizeof
(
tf_data
-
>
diff
)
)
;
return
true
;
}
static
AOM_INLINE
void
tf_setup_macroblockd
(
MACROBLOCKD
*
mbd
TemporalFilterData
*
tf_data
const
struct
scale_factors
*
scale
)
{
mbd
-
>
block_ref_scale_factors
[
0
]
=
scale
;
mbd
-
>
block_ref_scale_factors
[
1
]
=
scale
;
mbd
-
>
mi
=
&
tf_data
-
>
tmp_mbmi
;
mbd
-
>
mi
[
0
]
-
>
motion_mode
=
SIMPLE_TRANSLATION
;
}
static
AOM_INLINE
void
tf_dealloc_data
(
TemporalFilterData
*
tf_data
int
is_high_bitdepth
)
{
if
(
is_high_bitdepth
)
tf_data
-
>
pred
=
(
uint8_t
*
)
CONVERT_TO_SHORTPTR
(
tf_data
-
>
pred
)
;
aom_free
(
tf_data
-
>
tmp_mbmi
)
;
tf_data
-
>
tmp_mbmi
=
NULL
;
aom_free
(
tf_data
-
>
accum
)
;
tf_data
-
>
accum
=
NULL
;
aom_free
(
tf_data
-
>
count
)
;
tf_data
-
>
count
=
NULL
;
aom_free
(
tf_data
-
>
pred
)
;
tf_data
-
>
pred
=
NULL
;
}
static
INLINE
void
tf_save_state
(
MACROBLOCKD
*
mbd
MB_MODE_INFO
*
*
*
input_mbmi
uint8_t
*
*
input_buffer
int
num_planes
)
{
for
(
int
i
=
0
;
i
<
num_planes
;
i
+
+
)
{
input_buffer
[
i
]
=
mbd
-
>
plane
[
i
]
.
pre
[
0
]
.
buf
;
}
*
input_mbmi
=
mbd
-
>
mi
;
}
static
INLINE
void
tf_restore_state
(
MACROBLOCKD
*
mbd
MB_MODE_INFO
*
*
input_mbmi
uint8_t
*
*
input_buffer
int
num_planes
)
{
for
(
int
i
=
0
;
i
<
num_planes
;
i
+
+
)
{
mbd
-
>
plane
[
i
]
.
pre
[
0
]
.
buf
=
input_buffer
[
i
]
;
}
mbd
-
>
mi
=
input_mbmi
;
}
#
ifdef
__cplusplus
}
#
endif
#
endif
