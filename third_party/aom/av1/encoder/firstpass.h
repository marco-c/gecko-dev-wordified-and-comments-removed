#
ifndef
AOM_AV1_ENCODER_FIRSTPASS_H_
#
define
AOM_AV1_ENCODER_FIRSTPASS_H_
#
include
<
stdbool
.
h
>
#
include
"
av1
/
common
/
av1_common_int
.
h
"
#
include
"
av1
/
common
/
enums
.
h
"
#
include
"
av1
/
encoder
/
lookahead
.
h
"
#
include
"
av1
/
encoder
/
ratectrl
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
DOUBLE_DIVIDE_CHECK
(
x
)
(
(
x
)
<
0
?
(
x
)
-
0
.
000001
:
(
x
)
+
0
.
000001
)
#
define
MIN_ZERO_MOTION
0
.
95
#
define
MAX_SR_CODED_ERROR
40
#
define
MAX_RAW_ERR_VAR
2000
#
define
MIN_MV_IN_OUT
0
.
4
#
define
VLOW_MOTION_THRESHOLD
950
struct
ThreadData
;
typedef
struct
FIRSTPASS_STATS
{
double
frame
;
double
weight
;
double
intra_error
;
double
frame_avg_wavelet_energy
;
double
coded_error
;
double
sr_coded_error
;
double
pcnt_inter
;
double
pcnt_motion
;
double
pcnt_second_ref
;
double
pcnt_neutral
;
double
intra_skip_pct
;
double
inactive_zone_rows
;
double
inactive_zone_cols
;
double
MVr
;
double
mvr_abs
;
double
MVc
;
double
mvc_abs
;
double
MVrv
;
double
MVcv
;
double
mv_in_out_count
;
double
new_mv_count
;
double
duration
;
double
count
;
double
raw_error_stdev
;
int64_t
is_flash
;
double
noise_var
;
double
cor_coeff
;
double
log_intra_error
;
double
log_coded_error
;
}
FIRSTPASS_STATS
;
#
define
FIRSTPASS_INFO_STATS_PAST_MIN
1
#
define
FIRSTPASS_INFO_STATIC_BUF_SIZE
\
(
MAX_LAP_BUFFERS
+
FIRSTPASS_INFO_STATS_PAST_MIN
)
typedef
struct
{
FIRSTPASS_STATS
static_stats_buf
[
FIRSTPASS_INFO_STATIC_BUF_SIZE
]
;
FIRSTPASS_STATS
*
stats_buf
;
int
stats_buf_size
;
int
start_index
;
int
stats_count
;
int
cur_index
;
int
future_stats_count
;
int
past_stats_count
;
FIRSTPASS_STATS
total_stats
;
}
FIRSTPASS_INFO
;
aom_codec_err_t
av1_firstpass_info_init
(
FIRSTPASS_INFO
*
firstpass_info
FIRSTPASS_STATS
*
ext_stats_buf
int
ext_stats_buf_size
)
;
aom_codec_err_t
av1_firstpass_info_move_cur_index
(
FIRSTPASS_INFO
*
firstpass_info
)
;
aom_codec_err_t
av1_firstpass_info_pop
(
FIRSTPASS_INFO
*
firstpass_info
)
;
aom_codec_err_t
av1_firstpass_info_move_cur_index_and_pop
(
FIRSTPASS_INFO
*
firstpass_info
)
;
aom_codec_err_t
av1_firstpass_info_push
(
FIRSTPASS_INFO
*
firstpass_info
const
FIRSTPASS_STATS
*
input_stats
)
;
const
FIRSTPASS_STATS
*
av1_firstpass_info_peek
(
const
FIRSTPASS_INFO
*
firstpass_info
int
offset_from_cur
)
;
int
av1_firstpass_info_future_count
(
const
FIRSTPASS_INFO
*
firstpass_info
int
offset_from_cur
)
;
int
av1_firstpass_info_past_count
(
const
FIRSTPASS_INFO
*
firstpass_info
int
offset_from_cur
)
;
#
define
FC_ANIMATION_THRESH
0
.
15
enum
{
FC_NORMAL
=
0
FC_GRAPHICS_ANIMATION
=
1
FRAME_CONTENT_TYPES
=
2
}
UENUM1BYTE
(
FRAME_CONTENT_TYPE
)
;
typedef
struct
GF_GROUP
{
FRAME_UPDATE_TYPE
update_type
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
unsigned
char
arf_src_offset
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
unsigned
char
cur_frame_idx
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
layer_depth
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
arf_boost
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
max_layer_depth
;
int
max_layer_depth_allowed
;
int
q_val
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
rdmult_val
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
bit_allocation
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
FRAME_TYPE
frame_type
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
REFBUF_STATE
refbuf_state
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
arf_index
;
int
size
;
int
src_offset
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
display_idx
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int8_t
ref_frame_list
[
MAX_STATIC_GF_GROUP_LENGTH
]
[
REF_FRAMES
]
;
int
update_ref_idx
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
primary_ref_idx
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
frame_parallel_level
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
bool
is_frame_non_ref
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
bool
is_frame_dropped
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
int
skip_frame_refresh
[
MAX_STATIC_GF_GROUP_LENGTH
]
[
REF_FRAMES
]
;
int
skip_frame_as_ref
[
MAX_STATIC_GF_GROUP_LENGTH
]
;
}
GF_GROUP
;
typedef
struct
{
int
arf_gf_boost_lst
;
}
GF_STATE
;
typedef
struct
{
FIRSTPASS_STATS
*
stats_in_start
;
FIRSTPASS_STATS
*
stats_in_end
;
FIRSTPASS_STATS
*
stats_in_buf_end
;
FIRSTPASS_STATS
*
total_stats
;
FIRSTPASS_STATS
*
total_left_stats
;
}
STATS_BUFFER_CTX
;
typedef
struct
{
unsigned
int
section_intra_rating
;
FIRSTPASS_STATS
*
frame_stats_arr
[
MAX_LAP_BUFFERS
+
1
]
;
int
frame_stats_next_idx
;
STATS_BUFFER_CTX
*
stats_buf_ctx
;
FIRSTPASS_INFO
firstpass_info
;
int
first_pass_done
;
int64_t
bits_left
;
double
modified_error_min
;
double
modified_error_max
;
double
modified_error_left
;
int64_t
kf_group_bits
;
double
kf_group_error_left
;
double
bpm_factor
;
int
rolling_arf_group_target_bits
;
int
rolling_arf_group_actual_bits
;
int
sr_update_lag
;
int
kf_zeromotion_pct
;
int
last_kfgroup_zeromotion_pct
;
int
extend_minq
;
int
extend_maxq
;
}
TWO_PASS
;
typedef
struct
{
const
FIRSTPASS_STATS
*
stats_in
;
const
FIRSTPASS_STATS
*
this_frame
;
double
mb_av_energy
;
FRAME_CONTENT_TYPE
fr_content_type
;
double
frame_avg_haar_energy
;
}
TWO_PASS_FRAME
;
typedef
struct
{
int64_t
intra_error
;
int64_t
frame_avg_wavelet_energy
;
int64_t
coded_error
;
int64_t
sr_coded_error
;
int
mv_count
;
int
inter_count
;
int
second_ref_count
;
double
neutral_count
;
int
intra_skip_count
;
int
image_data_start_row
;
int
new_mv_count
;
int
sum_in_vectors
;
int
sum_mvr
;
int
sum_mvc
;
int
sum_mvr_abs
;
int
sum_mvc_abs
;
int64_t
sum_mvrs
;
int64_t
sum_mvcs
;
double
intra_factor
;
double
brightness_factor
;
}
FRAME_STATS
;
typedef
struct
{
FRAME_STATS
*
mb_stats
;
int
*
raw_motion_err_list
;
}
FirstPassData
;
struct
AV1_COMP
;
struct
EncodeFrameParams
;
struct
AV1EncoderConfig
;
struct
TileDataEnc
;
static
INLINE
int
is_fp_wavelet_energy_invalid
(
const
FIRSTPASS_STATS
*
fp_stats
)
{
assert
(
fp_stats
!
=
NULL
)
;
return
(
fp_stats
-
>
frame_avg_wavelet_energy
<
0
)
;
}
static
INLINE
BLOCK_SIZE
get_fp_block_size
(
int
is_screen_content_type
)
{
return
(
is_screen_content_type
?
BLOCK_8X8
:
BLOCK_16X16
)
;
}
int
av1_get_unit_rows_in_tile
(
const
TileInfo
*
tile
const
BLOCK_SIZE
fp_block_size
)
;
int
av1_get_unit_cols_in_tile
(
const
TileInfo
*
tile
const
BLOCK_SIZE
fp_block_size
)
;
void
av1_first_pass_row
(
struct
AV1_COMP
*
cpi
struct
ThreadData
*
td
struct
TileDataEnc
*
tile_data
const
int
mb_row
const
BLOCK_SIZE
fp_block_size
)
;
void
av1_end_first_pass
(
struct
AV1_COMP
*
cpi
)
;
void
av1_free_firstpass_data
(
FirstPassData
*
firstpass_data
)
;
void
av1_twopass_zero_stats
(
FIRSTPASS_STATS
*
section
)
;
void
av1_accumulate_stats
(
FIRSTPASS_STATS
*
section
const
FIRSTPASS_STATS
*
frame
)
;
void
av1_first_pass
(
struct
AV1_COMP
*
cpi
const
int64_t
ts_duration
)
;
void
av1_noop_first_pass_frame
(
struct
AV1_COMP
*
cpi
const
int64_t
ts_duration
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
