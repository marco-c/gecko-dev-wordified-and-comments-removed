#
ifndef
AOM_AV1_ENCODER_TOKENIZE_H_
#
define
AOM_AV1_ENCODER_TOKENIZE_H_
#
include
"
av1
/
common
/
entropy
.
h
"
#
include
"
av1
/
encoder
/
block
.
h
"
#
include
"
aom_dsp
/
bitwriter
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
typedef
struct
{
uint8_t
token
:
3
;
uint8_t
reserved
:
1
;
int8_t
color_ctx
:
4
;
}
TokenExtra
;
typedef
struct
{
TokenExtra
*
start
;
unsigned
int
count
;
}
TokenList
;
typedef
struct
{
unsigned
int
tokens_allocated
;
TokenExtra
*
tile_tok
[
MAX_TILE_ROWS
]
[
MAX_TILE_COLS
]
;
TokenList
*
tplist
[
MAX_TILE_ROWS
]
[
MAX_TILE_COLS
]
;
}
TokenInfo
;
struct
AV1_COMP
;
struct
ThreadData
;
struct
FRAME_COUNTS
;
enum
{
OUTPUT_ENABLED
=
0
DRY_RUN_NORMAL
DRY_RUN_COSTCOEFFS
}
UENUM1BYTE
(
RUN_TYPE
)
;
struct
tokenize_b_args
{
const
struct
AV1_COMP
*
cpi
;
struct
ThreadData
*
td
;
int
this_rate
;
uint8_t
allow_update_cdf
;
RUN_TYPE
dry_run
;
}
;
void
av1_tokenize_sb_vartx
(
const
struct
AV1_COMP
*
cpi
struct
ThreadData
*
td
RUN_TYPE
dry_run
BLOCK_SIZE
bsize
int
*
rate
uint8_t
allow_update_cdf
)
;
int
av1_cost_color_map
(
const
MACROBLOCK
*
const
x
int
plane
BLOCK_SIZE
bsize
TX_SIZE
tx_size
COLOR_MAP_TYPE
type
)
;
void
av1_tokenize_color_map
(
const
MACROBLOCK
*
const
x
int
plane
TokenExtra
*
*
t
BLOCK_SIZE
bsize
TX_SIZE
tx_size
COLOR_MAP_TYPE
type
int
allow_update_cdf
struct
FRAME_COUNTS
*
counts
)
;
static
INLINE
int
av1_get_tx_eob
(
const
struct
segmentation
*
seg
int
segment_id
TX_SIZE
tx_size
)
{
const
int
eob_max
=
av1_get_max_eob
(
tx_size
)
;
return
segfeature_active
(
seg
segment_id
SEG_LVL_SKIP
)
?
0
:
eob_max
;
}
static
INLINE
unsigned
int
get_token_alloc
(
int
mb_rows
int
mb_cols
int
sb_size_log2
const
int
num_planes
)
{
const
int
shift
=
sb_size_log2
-
4
;
const
int
sb_size
=
1
<
<
sb_size_log2
;
const
int
sb_size_square
=
sb_size
*
sb_size
;
const
int
sb_rows
=
CEIL_POWER_OF_TWO
(
mb_rows
shift
)
;
const
int
sb_cols
=
CEIL_POWER_OF_TWO
(
mb_cols
shift
)
;
const
int
sb_palette_toks
=
AOMMIN
(
2
num_planes
)
*
sb_size_square
;
return
sb_rows
*
sb_cols
*
sb_palette_toks
;
}
static
AOM_INLINE
void
alloc_token_info
(
AV1_COMMON
*
cm
TokenInfo
*
token_info
unsigned
int
tokens_required
)
{
int
sb_rows
=
CEIL_POWER_OF_TWO
(
cm
-
>
mi_params
.
mi_rows
cm
-
>
seq_params
-
>
mib_size_log2
)
;
token_info
-
>
tokens_allocated
=
tokens_required
;
CHECK_MEM_ERROR
(
cm
token_info
-
>
tile_tok
[
0
]
[
0
]
(
TokenExtra
*
)
aom_calloc
(
tokens_required
sizeof
(
*
token_info
-
>
tile_tok
[
0
]
[
0
]
)
)
)
;
CHECK_MEM_ERROR
(
cm
token_info
-
>
tplist
[
0
]
[
0
]
(
TokenList
*
)
aom_calloc
(
sb_rows
*
MAX_TILE_ROWS
*
MAX_TILE_COLS
sizeof
(
*
token_info
-
>
tplist
[
0
]
[
0
]
)
)
)
;
}
static
AOM_INLINE
bool
is_token_info_allocated
(
const
TokenInfo
*
token_info
)
{
return
(
(
token_info
-
>
tile_tok
[
0
]
[
0
]
!
=
NULL
)
&
&
(
token_info
-
>
tplist
[
0
]
[
0
]
!
=
NULL
)
)
;
}
static
AOM_INLINE
void
free_token_info
(
TokenInfo
*
token_info
)
{
aom_free
(
token_info
-
>
tile_tok
[
0
]
[
0
]
)
;
token_info
-
>
tile_tok
[
0
]
[
0
]
=
NULL
;
aom_free
(
token_info
-
>
tplist
[
0
]
[
0
]
)
;
token_info
-
>
tplist
[
0
]
[
0
]
=
NULL
;
token_info
-
>
tokens_allocated
=
0
;
}
#
ifdef
__cplusplus
}
#
endif
#
endif
