#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
<
stdio
.
h
>
#
include
"
aom_dsp
/
bitwriter
.
h
"
#
include
"
av1
/
common
/
generic_code
.
h
"
#
include
"
av1
/
common
/
odintrin
.
h
"
#
include
"
pvq_encoder
.
h
"
void
aom_encode_cdf_adapt_q15
(
aom_writer
*
w
int
val
uint16_t
*
cdf
int
n
int
*
count
int
rate
)
{
int
i
;
if
(
*
count
=
=
0
)
{
int
ft
;
ft
=
cdf
[
n
-
1
]
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
cdf
[
i
]
=
AOM_ICDF
(
cdf
[
i
]
*
32768
/
ft
)
;
}
}
aom_write_cdf
(
w
val
cdf
n
)
;
aom_cdf_adapt_q15
(
val
cdf
n
count
rate
)
;
}
void
generic_encode
(
aom_writer
*
w
generic_encoder
*
model
int
x
int
*
ex_q16
int
integration
)
{
int
lg_q1
;
int
shift
;
int
id
;
uint16_t
*
cdf
;
int
xs
;
lg_q1
=
log_ex
(
*
ex_q16
)
;
OD_LOG
(
(
OD_LOG_ENTROPY_CODER
OD_LOG_DEBUG
"
%
d
%
d
"
*
ex_q16
lg_q1
)
)
;
shift
=
OD_MAXI
(
0
(
lg_q1
-
5
)
>
>
1
)
;
id
=
OD_MINI
(
GENERIC_TABLES
-
1
lg_q1
)
;
cdf
=
model
-
>
cdf
[
id
]
;
xs
=
(
x
+
(
1
<
<
shift
>
>
1
)
)
>
>
shift
;
aom_write_symbol_pvq
(
w
OD_MINI
(
15
xs
)
cdf
16
)
;
if
(
xs
>
=
15
)
{
int
e
;
unsigned
decay
;
OD_ASSERT
(
*
ex_q16
<
INT_MAX
>
>
1
)
;
e
=
(
(
2
*
*
ex_q16
>
>
8
)
+
(
1
<
<
shift
>
>
1
)
)
>
>
shift
;
decay
=
OD_MAXI
(
2
OD_MINI
(
254
256
*
e
/
(
e
+
256
)
)
)
;
aom_laplace_encode_special
(
w
xs
-
15
decay
)
;
}
if
(
shift
!
=
0
)
{
int
special
;
special
=
xs
=
=
0
;
if
(
shift
-
special
>
0
)
{
aom_write_literal
(
w
x
-
(
xs
<
<
shift
)
+
(
!
special
<
<
(
shift
-
1
)
)
shift
-
special
)
;
}
}
generic_model_update
(
ex_q16
x
integration
)
;
OD_LOG
(
(
OD_LOG_ENTROPY_CODER
OD_LOG_DEBUG
"
enc
:
%
d
%
d
%
d
%
d
%
d
%
x
"
*
ex_q16
x
shift
id
xs
enc
-
>
rng
)
)
;
}
double
generic_encode_cost
(
generic_encoder
*
model
int
x
int
*
ex_q16
)
{
int
lg_q1
;
int
shift
;
int
id
;
uint16_t
*
cdf
;
int
xs
;
int
extra
;
lg_q1
=
log_ex
(
*
ex_q16
)
;
shift
=
OD_MAXI
(
0
(
lg_q1
-
5
)
>
>
1
)
;
id
=
OD_MINI
(
GENERIC_TABLES
-
1
lg_q1
)
;
cdf
=
model
-
>
cdf
[
id
]
;
xs
=
(
x
+
(
1
<
<
shift
>
>
1
)
)
>
>
shift
;
extra
=
0
;
if
(
shift
)
extra
=
shift
-
(
xs
=
=
0
)
;
xs
=
OD_MINI
(
15
xs
)
;
if
(
xs
=
=
15
)
extra
+
=
2
;
return
extra
-
OD_LOG2
(
(
double
)
(
cdf
[
xs
]
-
(
xs
=
=
0
?
0
:
cdf
[
xs
-
1
]
)
)
/
cdf
[
15
]
)
;
}
double
od_encode_cdf_cost
(
int
val
uint16_t
*
cdf
int
n
)
{
int
total_prob
;
int
prev_prob
;
double
val_prob
;
OD_ASSERT
(
n
>
0
)
;
total_prob
=
cdf
[
n
-
1
]
;
if
(
val
=
=
0
)
{
prev_prob
=
0
;
}
else
{
prev_prob
=
cdf
[
val
-
1
]
;
}
val_prob
=
(
cdf
[
val
]
-
prev_prob
)
/
(
double
)
total_prob
;
return
-
OD_LOG2
(
val_prob
)
;
}
