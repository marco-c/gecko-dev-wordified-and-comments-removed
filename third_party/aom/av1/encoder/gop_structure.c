#
include
<
stdint
.
h
>
#
include
"
av1
/
common
/
blockd
.
h
"
#
include
"
config
/
aom_config
.
h
"
#
include
"
config
/
aom_scale_rtcd
.
h
"
#
include
"
aom
/
aom_codec
.
h
"
#
include
"
aom
/
aom_encoder
.
h
"
#
include
"
av1
/
common
/
av1_common_int
.
h
"
#
include
"
av1
/
encoder
/
encoder
.
h
"
#
include
"
av1
/
encoder
/
firstpass
.
h
"
#
include
"
av1
/
encoder
/
gop_structure
.
h
"
#
include
"
av1
/
encoder
/
pass2_strategy
.
h
"
static
void
set_frame_parallel_level
(
int
*
frame_parallel_level
int
*
parallel_frame_count
int
max_parallel_frames
)
{
assert
(
*
parallel_frame_count
>
0
)
;
*
frame_parallel_level
=
1
+
(
*
parallel_frame_count
>
1
)
;
(
*
parallel_frame_count
)
+
+
;
if
(
*
parallel_frame_count
>
max_parallel_frames
)
*
parallel_frame_count
=
1
;
}
static
void
set_src_offset
(
GF_GROUP
*
const
gf_group
int
*
first_frame_index
int
cur_frame_idx
int
frame_ind
)
{
if
(
gf_group
-
>
frame_parallel_level
[
frame_ind
]
>
0
)
{
if
(
gf_group
-
>
frame_parallel_level
[
frame_ind
]
=
=
1
)
{
*
first_frame_index
=
cur_frame_idx
;
}
gf_group
-
>
src_offset
[
frame_ind
]
=
(
cur_frame_idx
+
gf_group
-
>
arf_src_offset
[
frame_ind
]
)
-
*
first_frame_index
;
}
}
static
AOM_INLINE
void
set_params_for_leaf_frames
(
const
TWO_PASS
*
twopass
const
TWO_PASS_FRAME
*
twopass_frame
const
PRIMARY_RATE_CONTROL
*
p_rc
FRAME_INFO
*
frame_info
GF_GROUP
*
const
gf_group
int
*
cur_frame_idx
int
*
frame_ind
int
*
parallel_frame_count
int
max_parallel_frames
int
do_frame_parallel_encode
int
*
first_frame_index
int
*
cur_disp_index
int
layer_depth
int
start
int
end
)
{
gf_group
-
>
update_type
[
*
frame_ind
]
=
LF_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
0
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
MAX_ARF_LAYERS
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
AOMMAX
(
gf_group
-
>
max_layer_depth
layer_depth
)
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
(
*
cur_disp_index
)
;
gf_group
-
>
arf_boost
[
*
frame_ind
]
=
av1_calc_arf_boost
(
twopass
twopass_frame
p_rc
frame_info
start
end
-
start
0
NULL
NULL
0
)
;
+
+
(
*
cur_disp_index
)
;
if
(
do_frame_parallel_encode
)
{
set_frame_parallel_level
(
&
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
parallel_frame_count
max_parallel_frames
)
;
gf_group
-
>
is_frame_non_ref
[
*
frame_ind
]
=
true
;
}
set_src_offset
(
gf_group
first_frame_index
*
cur_frame_idx
*
frame_ind
)
;
+
+
(
*
frame_ind
)
;
+
+
(
*
cur_frame_idx
)
;
}
static
AOM_INLINE
void
set_params_for_intnl_overlay_frames
(
GF_GROUP
*
const
gf_group
int
*
cur_frame_idx
int
*
frame_ind
int
*
first_frame_index
int
*
cur_disp_index
int
layer_depth
)
{
gf_group
-
>
update_type
[
*
frame_ind
]
=
INTNL_OVERLAY_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
0
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
layer_depth
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
(
*
cur_disp_index
)
;
+
+
(
*
cur_disp_index
)
;
set_src_offset
(
gf_group
first_frame_index
*
cur_frame_idx
*
frame_ind
)
;
+
+
(
*
frame_ind
)
;
+
+
(
*
cur_frame_idx
)
;
}
static
AOM_INLINE
void
set_params_for_internal_arfs
(
const
TWO_PASS
*
twopass
const
TWO_PASS_FRAME
*
twopass_frame
const
PRIMARY_RATE_CONTROL
*
p_rc
FRAME_INFO
*
frame_info
GF_GROUP
*
const
gf_group
int
*
cur_frame_idx
int
*
frame_ind
int
*
parallel_frame_count
int
max_parallel_frames
int
do_frame_parallel_encode
int
*
first_frame_index
int
depth_thr
int
*
cur_disp_idx
int
layer_depth
int
arf_src_offset
int
offset
int
f_frames
int
b_frames
)
{
gf_group
-
>
update_type
[
*
frame_ind
]
=
INTNL_ARF_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
arf_src_offset
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
layer_depth
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
(
*
cur_disp_idx
)
+
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
;
gf_group
-
>
arf_boost
[
*
frame_ind
]
=
av1_calc_arf_boost
(
twopass
twopass_frame
p_rc
frame_info
offset
f_frames
b_frames
NULL
NULL
0
)
;
if
(
do_frame_parallel_encode
)
{
if
(
depth_thr
!
=
INT_MAX
)
{
assert
(
depth_thr
=
=
3
|
|
depth_thr
=
=
4
)
;
assert
(
IMPLIES
(
depth_thr
=
=
3
layer_depth
=
=
4
)
)
;
assert
(
IMPLIES
(
depth_thr
=
=
4
layer_depth
=
=
5
)
)
;
if
(
gf_group
-
>
layer_depth
[
(
*
frame_ind
)
-
1
]
!
=
layer_depth
)
{
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
=
1
;
}
else
{
assert
(
gf_group
-
>
frame_parallel_level
[
(
*
frame_ind
)
-
1
]
=
=
1
)
;
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
=
2
;
gf_group
-
>
skip_frame_refresh
[
*
frame_ind
]
[
0
]
=
gf_group
-
>
display_idx
[
(
*
frame_ind
)
-
1
]
;
gf_group
-
>
skip_frame_refresh
[
*
frame_ind
]
[
1
]
=
gf_group
-
>
display_idx
[
(
*
frame_ind
)
-
2
]
;
gf_group
-
>
skip_frame_as_ref
[
*
frame_ind
]
=
gf_group
-
>
display_idx
[
(
*
frame_ind
)
-
1
]
;
}
}
if
(
*
parallel_frame_count
>
1
&
&
*
parallel_frame_count
<
=
max_parallel_frames
)
{
if
(
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
<
TF_LOOKAHEAD_IDX_THR
)
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
=
2
;
*
parallel_frame_count
=
1
;
}
}
set_src_offset
(
gf_group
first_frame_index
*
cur_frame_idx
*
frame_ind
)
;
+
+
(
*
frame_ind
)
;
}
static
void
set_multi_layer_params_for_fp
(
const
TWO_PASS
*
twopass
const
TWO_PASS_FRAME
*
twopass_frame
GF_GROUP
*
const
gf_group
const
PRIMARY_RATE_CONTROL
*
p_rc
RATE_CONTROL
*
rc
FRAME_INFO
*
frame_info
int
start
int
end
int
*
cur_frame_idx
int
*
frame_ind
int
*
parallel_frame_count
int
max_parallel_frames
int
do_frame_parallel_encode
int
*
first_frame_index
int
depth_thr
int
*
cur_disp_idx
int
layer_depth
)
{
const
int
num_frames_to_process
=
end
-
start
;
if
(
layer_depth
>
gf_group
-
>
max_layer_depth_allowed
|
|
num_frames_to_process
<
3
)
{
while
(
start
<
end
)
{
set_params_for_leaf_frames
(
twopass
twopass_frame
p_rc
frame_info
gf_group
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
cur_disp_idx
layer_depth
start
end
)
;
+
+
start
;
}
}
else
{
const
int
m
=
(
start
+
end
-
1
)
/
2
;
int
arf_src_offset
=
m
-
start
;
set_params_for_internal_arfs
(
twopass
twopass_frame
p_rc
frame_info
gf_group
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
INT_MAX
cur_disp_idx
layer_depth
arf_src_offset
m
end
-
m
m
-
start
)
;
if
(
layer_depth
>
=
depth_thr
)
{
int
m1
=
(
m
+
start
-
1
)
/
2
;
int
m2
=
(
m
+
1
+
end
)
/
2
;
int
arf_src_offsets
[
2
]
=
{
m1
-
start
m2
-
start
}
;
int
offset
[
2
]
=
{
m1
m2
}
;
int
f_frames
[
2
]
=
{
m
-
m1
end
-
m2
}
;
int
b_frames
[
2
]
=
{
m1
-
start
m2
-
(
m
+
1
)
}
;
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
{
set_params_for_internal_arfs
(
twopass
twopass_frame
p_rc
frame_info
gf_group
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
depth_thr
cur_disp_idx
layer_depth
+
1
arf_src_offsets
[
i
]
offset
[
i
]
f_frames
[
i
]
b_frames
[
i
]
)
;
}
int
start_idx
[
4
]
=
{
start
m1
+
1
m
+
1
end
-
1
}
;
int
end_idx
[
4
]
=
{
m1
m
m2
end
}
;
int
layer_depth_for_intnl_overlay
[
4
]
=
{
layer_depth
+
1
layer_depth
layer_depth
+
1
INVALID_IDX
}
;
for
(
int
i
=
0
;
i
<
4
;
i
+
+
)
{
set_multi_layer_params_for_fp
(
twopass
twopass_frame
gf_group
p_rc
rc
frame_info
start_idx
[
i
]
end_idx
[
i
]
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
depth_thr
cur_disp_idx
layer_depth
+
2
)
;
if
(
layer_depth_for_intnl_overlay
[
i
]
!
=
INVALID_IDX
)
set_params_for_intnl_overlay_frames
(
gf_group
cur_frame_idx
frame_ind
first_frame_index
cur_disp_idx
layer_depth_for_intnl_overlay
[
i
]
)
;
}
return
;
}
set_multi_layer_params_for_fp
(
twopass
twopass_frame
gf_group
p_rc
rc
frame_info
start
m
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
depth_thr
cur_disp_idx
layer_depth
+
1
)
;
set_params_for_intnl_overlay_frames
(
gf_group
cur_frame_idx
frame_ind
first_frame_index
cur_disp_idx
layer_depth
)
;
set_multi_layer_params_for_fp
(
twopass
twopass_frame
gf_group
p_rc
rc
frame_info
m
+
1
end
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
depth_thr
cur_disp_idx
layer_depth
+
1
)
;
}
}
typedef
struct
{
int
start
;
int
end
;
int
display_index
;
}
FRAME_REORDER_INFO
;
static
AOM_INLINE
void
fill_arf_frame_stats
(
FRAME_REORDER_INFO
*
arf_frame_stats
int
arf_frame_index
int
display_idx
int
start
int
end
)
{
arf_frame_stats
[
arf_frame_index
]
.
start
=
start
;
arf_frame_stats
[
arf_frame_index
]
.
end
=
end
;
arf_frame_stats
[
arf_frame_index
]
.
display_index
=
display_idx
;
}
static
AOM_INLINE
void
set_params_for_internal_arfs_in_gf14
(
GF_GROUP
*
const
gf_group
FRAME_REORDER_INFO
*
arf_frame_stats
int
*
cur_frame_idx
int
*
cur_disp_idx
int
*
frame_ind
int
*
count_arf_frames
int
*
doh_gf_index_map
int
start
int
end
int
layer_depth
int
layer_with_parallel_encodes
)
{
int
index
=
(
start
+
end
-
1
)
/
2
;
gf_group
-
>
update_type
[
*
frame_ind
]
=
INTNL_ARF_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
index
-
1
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
layer_depth
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
(
*
cur_disp_idx
)
+
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
;
doh_gf_index_map
[
index
]
=
*
frame_ind
;
if
(
layer_with_parallel_encodes
)
{
assert
(
layer_depth
=
=
4
)
;
if
(
gf_group
-
>
layer_depth
[
(
*
frame_ind
)
-
1
]
!
=
layer_depth
)
{
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
=
1
;
}
else
{
assert
(
gf_group
-
>
frame_parallel_level
[
(
*
frame_ind
)
-
1
]
=
=
1
)
;
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
=
2
;
gf_group
-
>
skip_frame_as_ref
[
*
frame_ind
]
=
gf_group
-
>
display_idx
[
(
*
frame_ind
)
-
1
]
;
}
}
+
+
(
*
frame_ind
)
;
fill_arf_frame_stats
(
arf_frame_stats
*
count_arf_frames
index
start
end
)
;
+
+
(
*
count_arf_frames
)
;
}
static
AOM_INLINE
void
set_params_for_cur_layer_frames
(
GF_GROUP
*
const
gf_group
FRAME_REORDER_INFO
*
arf_frame_stats
int
*
cur_frame_idx
int
*
cur_disp_idx
int
*
frame_ind
int
*
count_arf_frames
int
*
doh_gf_index_map
int
num_dir
int
node_start
int
node_end
int
layer_depth
)
{
assert
(
num_dir
<
3
)
;
int
start
end
;
for
(
int
i
=
node_start
;
i
<
node_end
;
i
+
+
)
{
for
(
int
dir
=
0
;
dir
<
num_dir
;
dir
+
+
)
{
if
(
dir
=
=
0
)
{
start
=
arf_frame_stats
[
i
]
.
start
;
end
=
arf_frame_stats
[
i
]
.
display_index
;
}
else
{
start
=
arf_frame_stats
[
i
]
.
display_index
+
1
;
end
=
arf_frame_stats
[
i
]
.
end
;
}
const
int
num_frames_to_process
=
end
-
start
;
if
(
num_frames_to_process
>
=
3
)
{
int
layer_with_parallel_encodes
=
layer_depth
=
=
4
;
set_params_for_internal_arfs_in_gf14
(
gf_group
arf_frame_stats
cur_frame_idx
cur_disp_idx
frame_ind
count_arf_frames
doh_gf_index_map
start
end
layer_depth
layer_with_parallel_encodes
)
;
}
}
}
}
static
AOM_INLINE
void
set_multi_layer_params_for_gf14
(
const
TWO_PASS
*
twopass
const
TWO_PASS_FRAME
*
twopass_frame
const
PRIMARY_RATE_CONTROL
*
p_rc
FRAME_INFO
*
frame_info
GF_GROUP
*
const
gf_group
FRAME_REORDER_INFO
*
arf_frame_stats
int
*
cur_frame_idx
int
*
frame_ind
int
*
count_arf_frames
int
*
doh_gf_index_map
int
*
parallel_frame_count
int
*
first_frame_index
int
*
cur_disp_index
int
gf_interval
int
layer_depth
int
max_parallel_frames
)
{
assert
(
layer_depth
=
=
2
)
;
assert
(
gf_group
-
>
max_layer_depth_allowed
>
=
4
)
;
int
layer
node_start
node_end
=
0
;
const
int
max_layer_depth
=
4
;
for
(
layer
=
layer_depth
;
layer
<
=
max_layer_depth
;
layer
+
+
)
{
node_start
=
node_end
;
node_end
=
(
*
count_arf_frames
)
;
int
num_dir
=
layer
=
=
2
?
1
:
2
;
set_params_for_cur_layer_frames
(
gf_group
arf_frame_stats
cur_frame_idx
cur_disp_index
frame_ind
count_arf_frames
doh_gf_index_map
num_dir
node_start
node_end
layer
)
;
}
for
(
int
i
=
1
;
i
<
gf_interval
;
i
+
+
)
{
if
(
doh_gf_index_map
[
i
]
=
=
INVALID_IDX
)
{
set_params_for_leaf_frames
(
twopass
twopass_frame
p_rc
frame_info
gf_group
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
1
first_frame_index
cur_disp_index
layer
0
0
)
;
}
else
{
int
intnl_arf_index
=
doh_gf_index_map
[
i
]
;
int
ld
=
gf_group
-
>
layer_depth
[
intnl_arf_index
]
;
set_params_for_intnl_overlay_frames
(
gf_group
cur_frame_idx
frame_ind
first_frame_index
cur_disp_index
ld
)
;
}
}
}
static
void
set_multi_layer_params
(
const
TWO_PASS
*
twopass
const
TWO_PASS_FRAME
*
twopass_frame
GF_GROUP
*
const
gf_group
const
PRIMARY_RATE_CONTROL
*
p_rc
RATE_CONTROL
*
rc
FRAME_INFO
*
frame_info
int
start
int
end
int
*
cur_frame_idx
int
*
frame_ind
int
*
parallel_frame_count
int
max_parallel_frames
int
do_frame_parallel_encode
int
*
first_frame_index
int
*
cur_disp_idx
int
layer_depth
)
{
const
int
num_frames_to_process
=
end
-
start
;
if
(
layer_depth
>
gf_group
-
>
max_layer_depth_allowed
|
|
num_frames_to_process
<
3
)
{
while
(
start
<
end
)
{
gf_group
-
>
update_type
[
*
frame_ind
]
=
LF_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
0
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
*
cur_disp_idx
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
MAX_ARF_LAYERS
;
gf_group
-
>
arf_boost
[
*
frame_ind
]
=
av1_calc_arf_boost
(
twopass
twopass_frame
p_rc
frame_info
start
end
-
start
0
NULL
NULL
0
)
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
AOMMAX
(
gf_group
-
>
max_layer_depth
layer_depth
)
;
if
(
do_frame_parallel_encode
)
{
set_frame_parallel_level
(
&
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
parallel_frame_count
max_parallel_frames
)
;
gf_group
-
>
is_frame_non_ref
[
*
frame_ind
]
=
true
;
}
set_src_offset
(
gf_group
first_frame_index
*
cur_frame_idx
*
frame_ind
)
;
+
+
(
*
frame_ind
)
;
+
+
(
*
cur_frame_idx
)
;
+
+
(
*
cur_disp_idx
)
;
+
+
start
;
}
}
else
{
const
int
m
=
(
start
+
end
-
1
)
/
2
;
gf_group
-
>
update_type
[
*
frame_ind
]
=
INTNL_ARF_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
m
-
start
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
*
cur_disp_idx
+
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
layer_depth
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
if
(
do_frame_parallel_encode
)
{
if
(
*
parallel_frame_count
>
1
&
&
*
parallel_frame_count
<
=
max_parallel_frames
)
{
if
(
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
<
TF_LOOKAHEAD_IDX_THR
)
gf_group
-
>
frame_parallel_level
[
*
frame_ind
]
=
2
;
*
parallel_frame_count
=
1
;
}
}
set_src_offset
(
gf_group
first_frame_index
*
cur_frame_idx
*
frame_ind
)
;
gf_group
-
>
arf_boost
[
*
frame_ind
]
=
av1_calc_arf_boost
(
twopass
twopass_frame
p_rc
frame_info
m
end
-
m
m
-
start
NULL
NULL
0
)
;
+
+
(
*
frame_ind
)
;
set_multi_layer_params
(
twopass
twopass_frame
gf_group
p_rc
rc
frame_info
start
m
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
cur_disp_idx
layer_depth
+
1
)
;
gf_group
-
>
update_type
[
*
frame_ind
]
=
INTNL_OVERLAY_UPDATE
;
gf_group
-
>
arf_src_offset
[
*
frame_ind
]
=
0
;
gf_group
-
>
cur_frame_idx
[
*
frame_ind
]
=
*
cur_frame_idx
;
gf_group
-
>
display_idx
[
*
frame_ind
]
=
*
cur_disp_idx
;
gf_group
-
>
arf_boost
[
*
frame_ind
]
=
0
;
gf_group
-
>
layer_depth
[
*
frame_ind
]
=
layer_depth
;
gf_group
-
>
frame_type
[
*
frame_ind
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
*
frame_ind
]
=
REFBUF_UPDATE
;
set_src_offset
(
gf_group
first_frame_index
*
cur_frame_idx
*
frame_ind
)
;
+
+
(
*
frame_ind
)
;
+
+
(
*
cur_frame_idx
)
;
+
+
(
*
cur_disp_idx
)
;
set_multi_layer_params
(
twopass
twopass_frame
gf_group
p_rc
rc
frame_info
m
+
1
end
cur_frame_idx
frame_ind
parallel_frame_count
max_parallel_frames
do_frame_parallel_encode
first_frame_index
cur_disp_idx
layer_depth
+
1
)
;
}
}
static
int
construct_multi_layer_gf_structure
(
AV1_COMP
*
cpi
TWO_PASS
*
twopass
GF_GROUP
*
const
gf_group
RATE_CONTROL
*
rc
FRAME_INFO
*
const
frame_info
int
baseline_gf_interval
FRAME_UPDATE_TYPE
first_frame_update_type
)
{
PRIMARY_RATE_CONTROL
*
const
p_rc
=
&
cpi
-
>
ppi
-
>
p_rc
;
const
int
gf_interval
=
baseline_gf_interval
-
1
;
int
frame_index
=
0
;
int
cur_frame_index
=
0
;
int
cur_disp_index
=
(
first_frame_update_type
=
=
KF_UPDATE
)
?
0
:
cpi
-
>
common
.
current_frame
.
frame_number
;
memset
(
gf_group
-
>
frame_parallel_level
0
sizeof
(
gf_group
-
>
frame_parallel_level
)
)
;
memset
(
gf_group
-
>
is_frame_non_ref
0
sizeof
(
gf_group
-
>
is_frame_non_ref
)
)
;
memset
(
gf_group
-
>
src_offset
0
sizeof
(
gf_group
-
>
src_offset
)
)
;
memset
(
gf_group
-
>
is_frame_dropped
0
sizeof
(
gf_group
-
>
is_frame_dropped
)
)
;
memset
(
gf_group
-
>
skip_frame_refresh
INVALID_IDX
sizeof
(
gf_group
-
>
skip_frame_refresh
)
)
;
memset
(
gf_group
-
>
skip_frame_as_ref
INVALID_IDX
sizeof
(
gf_group
-
>
skip_frame_as_ref
)
)
;
int
kf_decomp
=
cpi
-
>
oxcf
.
kf_cfg
.
enable_keyframe_filtering
>
1
;
if
(
baseline_gf_interval
=
=
MAX_STATIC_GF_GROUP_LENGTH
)
{
kf_decomp
=
0
;
}
if
(
first_frame_update_type
=
=
KF_UPDATE
)
{
gf_group
-
>
update_type
[
frame_index
]
=
kf_decomp
?
ARF_UPDATE
:
KF_UPDATE
;
gf_group
-
>
arf_src_offset
[
frame_index
]
=
0
;
gf_group
-
>
cur_frame_idx
[
frame_index
]
=
cur_frame_index
;
gf_group
-
>
layer_depth
[
frame_index
]
=
0
;
gf_group
-
>
frame_type
[
frame_index
]
=
KEY_FRAME
;
gf_group
-
>
refbuf_state
[
frame_index
]
=
REFBUF_RESET
;
gf_group
-
>
max_layer_depth
=
0
;
gf_group
-
>
display_idx
[
frame_index
]
=
cur_disp_index
;
if
(
!
kf_decomp
)
cur_disp_index
+
+
;
+
+
frame_index
;
if
(
kf_decomp
)
{
gf_group
-
>
update_type
[
frame_index
]
=
OVERLAY_UPDATE
;
gf_group
-
>
arf_src_offset
[
frame_index
]
=
0
;
gf_group
-
>
cur_frame_idx
[
frame_index
]
=
cur_frame_index
;
gf_group
-
>
layer_depth
[
frame_index
]
=
0
;
gf_group
-
>
frame_type
[
frame_index
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
frame_index
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
0
;
gf_group
-
>
display_idx
[
frame_index
]
=
cur_disp_index
;
cur_disp_index
+
+
;
+
+
frame_index
;
}
cur_frame_index
+
+
;
}
if
(
first_frame_update_type
=
=
GF_UPDATE
)
{
gf_group
-
>
update_type
[
frame_index
]
=
GF_UPDATE
;
gf_group
-
>
arf_src_offset
[
frame_index
]
=
0
;
gf_group
-
>
cur_frame_idx
[
frame_index
]
=
cur_frame_index
;
gf_group
-
>
layer_depth
[
frame_index
]
=
0
;
gf_group
-
>
frame_type
[
frame_index
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
frame_index
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
0
;
gf_group
-
>
display_idx
[
frame_index
]
=
cur_disp_index
;
cur_disp_index
+
+
;
+
+
frame_index
;
+
+
cur_frame_index
;
}
const
int
use_altref
=
gf_group
-
>
max_layer_depth_allowed
>
0
;
int
is_fwd_kf
=
rc
-
>
frames_to_fwd_kf
=
=
gf_interval
;
if
(
use_altref
)
{
gf_group
-
>
update_type
[
frame_index
]
=
ARF_UPDATE
;
gf_group
-
>
arf_src_offset
[
frame_index
]
=
gf_interval
-
cur_frame_index
;
gf_group
-
>
cur_frame_idx
[
frame_index
]
=
cur_frame_index
;
gf_group
-
>
layer_depth
[
frame_index
]
=
1
;
gf_group
-
>
arf_boost
[
frame_index
]
=
cpi
-
>
ppi
-
>
p_rc
.
gfu_boost
;
gf_group
-
>
frame_type
[
frame_index
]
=
is_fwd_kf
?
KEY_FRAME
:
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
frame_index
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
1
;
gf_group
-
>
arf_index
=
frame_index
;
gf_group
-
>
display_idx
[
frame_index
]
=
cur_disp_index
+
gf_group
-
>
arf_src_offset
[
frame_index
]
;
+
+
frame_index
;
}
else
{
gf_group
-
>
arf_index
=
-
1
;
}
int
is_multi_layer_configured
=
0
;
int
parallel_frame_count
=
1
;
int
do_frame_parallel_encode
=
(
cpi
-
>
ppi
-
>
num_fp_contexts
>
1
&
&
use_altref
&
&
gf_group
-
>
max_layer_depth_allowed
>
=
4
)
;
int
first_frame_index
=
cur_frame_index
;
if
(
do_frame_parallel_encode
)
{
int
actual_gf_length
=
(
(
first_frame_update_type
=
=
KF_UPDATE
)
|
|
(
first_frame_update_type
=
=
GF_UPDATE
)
)
?
gf_interval
:
gf_interval
+
1
;
int
disable_gf14_reorder
=
1
;
if
(
actual_gf_length
=
=
14
&
&
!
disable_gf14_reorder
)
{
int
doh_gf_index_map
[
FIXED_GF_INTERVAL
]
;
memset
(
&
doh_gf_index_map
[
0
]
INVALID_IDX
(
sizeof
(
doh_gf_index_map
[
0
]
)
*
FIXED_GF_INTERVAL
)
)
;
FRAME_REORDER_INFO
arf_frame_stats
[
REF_FRAMES
-
1
]
;
fill_arf_frame_stats
(
arf_frame_stats
0
actual_gf_length
1
actual_gf_length
)
;
int
count_arf_frames
=
1
;
set_multi_layer_params_for_gf14
(
twopass
&
cpi
-
>
twopass_frame
p_rc
frame_info
gf_group
arf_frame_stats
&
cur_frame_index
&
frame_index
&
count_arf_frames
doh_gf_index_map
&
parallel_frame_count
&
first_frame_index
&
cur_disp_index
actual_gf_length
use_altref
+
1
cpi
-
>
ppi
-
>
num_fp_contexts
)
;
for
(
int
i
=
0
;
i
<
actual_gf_length
;
i
+
+
)
{
int
count
=
0
;
if
(
gf_group
-
>
update_type
[
i
]
=
=
INTNL_ARF_UPDATE
)
{
for
(
int
j
=
0
;
j
<
i
;
j
+
+
)
{
if
(
(
gf_group
-
>
display_idx
[
j
]
<
gf_group
-
>
display_idx
[
i
]
)
&
&
gf_group
-
>
update_type
[
j
]
=
=
INTNL_ARF_UPDATE
)
{
gf_group
-
>
skip_frame_refresh
[
i
]
[
count
+
+
]
=
gf_group
-
>
display_idx
[
j
]
;
}
}
}
}
}
else
{
int
depth_thr
=
(
actual_gf_length
=
=
16
)
?
3
:
(
actual_gf_length
=
=
32
)
?
4
:
INT_MAX
;
set_multi_layer_params_for_fp
(
twopass
&
cpi
-
>
twopass_frame
gf_group
p_rc
rc
frame_info
cur_frame_index
gf_interval
&
cur_frame_index
&
frame_index
&
parallel_frame_count
cpi
-
>
ppi
-
>
num_fp_contexts
do_frame_parallel_encode
&
first_frame_index
depth_thr
&
cur_disp_index
use_altref
+
1
)
;
}
is_multi_layer_configured
=
1
;
}
if
(
!
is_multi_layer_configured
)
set_multi_layer_params
(
twopass
&
cpi
-
>
twopass_frame
gf_group
p_rc
rc
frame_info
cur_frame_index
gf_interval
&
cur_frame_index
&
frame_index
&
parallel_frame_count
cpi
-
>
ppi
-
>
num_fp_contexts
do_frame_parallel_encode
&
first_frame_index
&
cur_disp_index
use_altref
+
1
)
;
if
(
use_altref
)
{
gf_group
-
>
update_type
[
frame_index
]
=
OVERLAY_UPDATE
;
gf_group
-
>
arf_src_offset
[
frame_index
]
=
0
;
gf_group
-
>
cur_frame_idx
[
frame_index
]
=
cur_frame_index
;
gf_group
-
>
layer_depth
[
frame_index
]
=
MAX_ARF_LAYERS
;
gf_group
-
>
arf_boost
[
frame_index
]
=
NORMAL_BOOST
;
gf_group
-
>
frame_type
[
frame_index
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
frame_index
]
=
is_fwd_kf
?
REFBUF_RESET
:
REFBUF_UPDATE
;
gf_group
-
>
display_idx
[
frame_index
]
=
cur_disp_index
;
+
+
frame_index
;
}
else
{
for
(
;
cur_frame_index
<
=
gf_interval
;
+
+
cur_frame_index
)
{
gf_group
-
>
update_type
[
frame_index
]
=
LF_UPDATE
;
gf_group
-
>
arf_src_offset
[
frame_index
]
=
0
;
gf_group
-
>
cur_frame_idx
[
frame_index
]
=
cur_frame_index
;
gf_group
-
>
layer_depth
[
frame_index
]
=
MAX_ARF_LAYERS
;
gf_group
-
>
arf_boost
[
frame_index
]
=
NORMAL_BOOST
;
gf_group
-
>
frame_type
[
frame_index
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
frame_index
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
AOMMAX
(
gf_group
-
>
max_layer_depth
2
)
;
set_src_offset
(
gf_group
&
first_frame_index
cur_frame_index
frame_index
)
;
gf_group
-
>
display_idx
[
frame_index
]
=
cur_disp_index
;
cur_disp_index
+
+
;
+
+
frame_index
;
}
}
if
(
do_frame_parallel_encode
)
{
int
level1_frame_idx
=
INT_MAX
;
int
level2_frame_count
=
0
;
for
(
int
frame_idx
=
0
;
frame_idx
<
frame_index
;
frame_idx
+
+
)
{
if
(
gf_group
-
>
frame_parallel_level
[
frame_idx
]
=
=
1
)
{
if
(
level1_frame_idx
!
=
INT_MAX
&
&
!
level2_frame_count
)
gf_group
-
>
frame_parallel_level
[
level1_frame_idx
]
=
0
;
level1_frame_idx
=
frame_idx
;
level2_frame_count
=
0
;
}
if
(
gf_group
-
>
frame_parallel_level
[
frame_idx
]
=
=
2
)
level2_frame_count
+
+
;
}
if
(
gf_group
-
>
frame_parallel_level
[
frame_index
-
2
]
=
=
1
)
{
assert
(
gf_group
-
>
update_type
[
frame_index
-
2
]
=
=
LF_UPDATE
)
;
gf_group
-
>
frame_parallel_level
[
frame_index
-
2
]
=
0
;
}
}
for
(
int
gf_idx
=
frame_index
;
gf_idx
<
MAX_STATIC_GF_GROUP_LENGTH
;
+
+
gf_idx
)
{
gf_group
-
>
update_type
[
gf_idx
]
=
LF_UPDATE
;
gf_group
-
>
arf_src_offset
[
gf_idx
]
=
0
;
gf_group
-
>
cur_frame_idx
[
gf_idx
]
=
gf_idx
;
gf_group
-
>
layer_depth
[
gf_idx
]
=
MAX_ARF_LAYERS
;
gf_group
-
>
arf_boost
[
gf_idx
]
=
NORMAL_BOOST
;
gf_group
-
>
frame_type
[
gf_idx
]
=
INTER_FRAME
;
gf_group
-
>
refbuf_state
[
gf_idx
]
=
REFBUF_UPDATE
;
gf_group
-
>
max_layer_depth
=
AOMMAX
(
gf_group
-
>
max_layer_depth
2
)
;
}
return
frame_index
;
}
static
void
set_ld_layer_depth
(
GF_GROUP
*
gf_group
int
gop_length
)
{
int
log_gop_length
=
0
;
while
(
(
1
<
<
log_gop_length
)
<
gop_length
)
{
+
+
log_gop_length
;
}
for
(
int
gf_index
=
0
;
gf_index
<
gf_group
-
>
size
;
+
+
gf_index
)
{
int
count
=
0
;
for
(
;
count
<
MAX_ARF_LAYERS
;
+
+
count
)
{
if
(
(
gf_index
>
>
count
)
&
0x01
)
break
;
}
gf_group
-
>
layer_depth
[
gf_index
]
=
AOMMAX
(
log_gop_length
-
count
0
)
;
}
gf_group
-
>
max_layer_depth
=
AOMMIN
(
log_gop_length
MAX_ARF_LAYERS
)
;
}
void
av1_gop_setup_structure
(
AV1_COMP
*
cpi
)
{
RATE_CONTROL
*
const
rc
=
&
cpi
-
>
rc
;
PRIMARY_RATE_CONTROL
*
const
p_rc
=
&
cpi
-
>
ppi
-
>
p_rc
;
GF_GROUP
*
const
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
TWO_PASS
*
const
twopass
=
&
cpi
-
>
ppi
-
>
twopass
;
FRAME_INFO
*
const
frame_info
=
&
cpi
-
>
frame_info
;
const
int
key_frame
=
rc
-
>
frames_since_key
=
=
0
;
FRAME_UPDATE_TYPE
first_frame_update_type
=
ARF_UPDATE
;
if
(
key_frame
)
{
first_frame_update_type
=
KF_UPDATE
;
if
(
cpi
-
>
oxcf
.
kf_max_pyr_height
!
=
-
1
)
{
gf_group
-
>
max_layer_depth_allowed
=
AOMMIN
(
cpi
-
>
oxcf
.
kf_max_pyr_height
gf_group
-
>
max_layer_depth_allowed
)
;
}
}
else
if
(
!
cpi
-
>
ppi
-
>
gf_state
.
arf_gf_boost_lst
)
{
first_frame_update_type
=
GF_UPDATE
;
}
gf_group
-
>
size
=
construct_multi_layer_gf_structure
(
cpi
twopass
gf_group
rc
frame_info
p_rc
-
>
baseline_gf_interval
first_frame_update_type
)
;
if
(
gf_group
-
>
max_layer_depth_allowed
=
=
0
)
set_ld_layer_depth
(
gf_group
p_rc
-
>
baseline_gf_interval
)
;
}
int
av1_gop_check_forward_keyframe
(
const
GF_GROUP
*
gf_group
int
gf_frame_index
)
{
return
gf_group
-
>
frame_type
[
gf_frame_index
]
=
=
KEY_FRAME
&
&
gf_group
-
>
refbuf_state
[
gf_frame_index
]
=
=
REFBUF_UPDATE
;
}
int
av1_gop_is_second_arf
(
const
GF_GROUP
*
gf_group
int
gf_frame_index
)
{
const
int
arf_src_offset
=
gf_group
-
>
arf_src_offset
[
gf_frame_index
]
;
if
(
gf_group
-
>
update_type
[
gf_frame_index
]
=
=
INTNL_ARF_UPDATE
&
&
arf_src_offset
>
=
TF_LOOKAHEAD_IDX_THR
)
{
return
1
;
}
return
0
;
}
