#
ifndef
AV1_ENCODER_BLOCK_H_
#
define
AV1_ENCODER_BLOCK_H_
#
include
"
av1
/
common
/
entropymv
.
h
"
#
include
"
av1
/
common
/
entropy
.
h
"
#
if
CONFIG_PVQ
#
include
"
av1
/
encoder
/
encint
.
h
"
#
endif
#
include
"
av1
/
common
/
mvref_common
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
if
CONFIG_PVQ
#
define
MAX_PVQ_BLOCKS_IN_SB
(
MAX_SB_SQUARE
>
>
2
*
OD_LOG_BSIZE0
)
#
endif
typedef
struct
{
unsigned
int
sse
;
int
sum
;
unsigned
int
var
;
}
DIFF
;
typedef
struct
macroblock_plane
{
DECLARE_ALIGNED
(
16
int16_t
src_diff
[
MAX_SB_SQUARE
]
)
;
#
if
CONFIG_PVQ
DECLARE_ALIGNED
(
16
int16_t
src_int16
[
MAX_SB_SQUARE
]
)
;
#
endif
tran_low_t
*
qcoeff
;
tran_low_t
*
coeff
;
uint16_t
*
eobs
;
#
if
CONFIG_LV_MAP
uint8_t
*
txb_entropy_ctx
;
#
endif
struct
buf_2d
src
;
const
int16_t
*
quant_fp
;
const
int16_t
*
round_fp
;
const
int16_t
*
quant
;
const
int16_t
*
quant_shift
;
const
int16_t
*
zbin
;
const
int16_t
*
round
;
#
if
CONFIG_NEW_QUANT
const
cuml_bins_type_nuq
*
cuml_bins_nuq
[
QUANT_PROFILES
]
;
#
endif
}
MACROBLOCK_PLANE
;
typedef
unsigned
int
av1_coeff_cost
[
PLANE_TYPES
]
[
REF_TYPES
]
[
COEF_BANDS
]
[
2
]
[
COEFF_CONTEXTS
]
[
ENTROPY_TOKENS
]
;
typedef
struct
{
int_mv
ref_mvs
[
MODE_CTX_REF_FRAMES
]
[
MAX_MV_REF_CANDIDATES
]
;
int16_t
mode_context
[
MODE_CTX_REF_FRAMES
]
;
#
if
CONFIG_LV_MAP
tran_low_t
tcoeff
[
MAX_MB_PLANE
]
[
MAX_SB_SQUARE
]
;
uint16_t
eobs
[
MAX_MB_PLANE
]
[
MAX_SB_SQUARE
/
(
TX_SIZE_W_MIN
*
TX_SIZE_H_MIN
)
]
;
uint8_t
txb_skip_ctx
[
MAX_MB_PLANE
]
[
MAX_SB_SQUARE
/
(
TX_SIZE_W_MIN
*
TX_SIZE_H_MIN
)
]
;
int
dc_sign_ctx
[
MAX_MB_PLANE
]
[
MAX_SB_SQUARE
/
(
TX_SIZE_W_MIN
*
TX_SIZE_H_MIN
)
]
;
#
endif
uint8_t
ref_mv_count
[
MODE_CTX_REF_FRAMES
]
;
CANDIDATE_MV
ref_mv_stack
[
MODE_CTX_REF_FRAMES
]
[
MAX_REF_MV_STACK_SIZE
]
;
#
if
CONFIG_EXT_INTER
int16_t
compound_mode_context
[
MODE_CTX_REF_FRAMES
]
;
#
endif
}
MB_MODE_INFO_EXT
;
typedef
struct
{
int
col_min
;
int
col_max
;
int
row_min
;
int
row_max
;
}
MvLimits
;
#
if
CONFIG_PALETTE
typedef
struct
{
uint8_t
best_palette_color_map
[
MAX_SB_SQUARE
]
;
float
kmeans_data_buf
[
2
*
MAX_SB_SQUARE
]
;
}
PALETTE_BUFFER
;
#
endif
typedef
struct
macroblock
MACROBLOCK
;
struct
macroblock
{
struct
macroblock_plane
plane
[
MAX_MB_PLANE
]
;
MACROBLOCKD
e_mbd
;
MB_MODE_INFO_EXT
*
mbmi_ext
;
int
skip_block
;
int
qindex
;
int
errorperbit
;
int
sadperbit16
;
int
sadperbit4
;
int
rdmult
;
int
mb_energy
;
int
*
m_search_count_ptr
;
int
*
ex_search_count_ptr
;
#
if
CONFIG_VAR_TX
unsigned
int
txb_split_count
;
#
endif
BLOCK_SIZE
min_partition_size
;
BLOCK_SIZE
max_partition_size
;
int
mv_best_ref_index
[
TOTAL_REFS_PER_FRAME
]
;
unsigned
int
max_mv_context
[
TOTAL_REFS_PER_FRAME
]
;
unsigned
int
source_variance
;
unsigned
int
pred_sse
[
TOTAL_REFS_PER_FRAME
]
;
int
pred_mv_sad
[
TOTAL_REFS_PER_FRAME
]
;
int
*
nmvjointcost
;
int
nmv_vec_cost
[
NMV_CONTEXTS
]
[
MV_JOINTS
]
;
int
*
nmvcost
[
NMV_CONTEXTS
]
[
2
]
;
int
*
nmvcost_hp
[
NMV_CONTEXTS
]
[
2
]
;
int
*
*
mv_cost_stack
[
NMV_CONTEXTS
]
;
int
*
*
mvcost
;
#
if
CONFIG_MOTION_VAR
int32_t
*
wsrc_buf
;
int32_t
*
mask_buf
;
uint8_t
*
above_pred_buf
;
uint8_t
*
left_pred_buf
;
#
endif
#
if
CONFIG_PALETTE
PALETTE_BUFFER
*
palette_buffer
;
#
endif
MvLimits
mv_limits
;
#
if
CONFIG_VAR_TX
uint8_t
blk_skip
[
MAX_MB_PLANE
]
[
MAX_MIB_SIZE
*
MAX_MIB_SIZE
*
8
]
;
uint8_t
blk_skip_drl
[
MAX_MB_PLANE
]
[
MAX_MIB_SIZE
*
MAX_MIB_SIZE
*
8
]
;
#
endif
int
skip
;
#
if
CONFIG_CB4X4
int
skip_chroma_rd
;
#
endif
av1_coeff_cost
token_costs
[
TX_SIZES
]
;
int
optimize
;
MV
pred_mv
[
TOTAL_REFS_PER_FRAME
]
;
int_mv
best_mv
;
int_mv
second_best_mv
;
int
use_default_intra_tx_type
;
int
use_default_inter_tx_type
;
#
if
CONFIG_PVQ
int
rate
;
int
pvq_skip
[
MAX_MB_PLANE
]
;
PVQ_QUEUE
*
pvq_q
;
PVQ_INFO
pvq
[
MAX_PVQ_BLOCKS_IN_SB
]
[
MAX_MB_PLANE
]
;
daala_enc_ctx
daala_enc
;
int
pvq_speed
;
int
pvq_coded
;
#
endif
#
if
CONFIG_DIST_8X8
#
if
CONFIG_CB4X4
#
if
CONFIG_HIGHBITDEPTH
DECLARE_ALIGNED
(
16
uint16_t
decoded_8x8
[
8
*
8
]
)
;
#
else
DECLARE_ALIGNED
(
16
uint8_t
decoded_8x8
[
8
*
8
]
)
;
#
endif
#
endif
#
endif
#
if
CONFIG_CFL
int
cfl_store_y
;
#
endif
}
;
#
ifdef
__cplusplus
}
#
endif
#
endif
