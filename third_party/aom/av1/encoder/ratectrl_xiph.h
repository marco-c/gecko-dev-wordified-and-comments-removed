#
if
!
defined
(
_ratectrl_xiph_H
)
#
define
_ratectrl_xiph_H
(
1
)
#
include
"
av1
/
encoder
/
ratectrl
.
h
"
#
include
"
aom
/
internal
/
aom_codec_internal
.
h
"
#
define
OD_I_FRAME
(
0
)
#
define
OD_P_FRAME
(
1
)
#
define
OD_GOLDEN_P_FRAME
(
2
)
#
define
OD_ALTREF_P_FRAME
(
3
)
#
define
OD_FRAME_NSUBTYPES
(
OD_ALTREF_P_FRAME
+
1
)
#
define
OD_PERIODIC_BOOST_DIV
(
10
)
#
define
OD_MQP_I
(
0
.
98
)
#
define
OD_MQP_P
(
1
.
06
)
#
define
OD_MQP_GP
(
0
.
99
)
#
define
OD_MQP_AP
(
0
.
92
)
#
define
OD_DQP_I
(
-
2
)
#
define
OD_DQP_P
(
0
)
#
define
OD_DQP_GP
(
-
2
)
#
define
OD_DQP_AP
(
-
2
)
#
define
OD_LOG_QUANTIZER_BASE_Q12
(
0x0064EB
)
#
define
OD_LOG_QUANTIZER_EXP_Q12
(
0x000289
)
#
define
OD_LOG_QUANTIZER_OFFSET_Q45
(
0x0000C7851EB851ECLL
)
#
define
OD_RC_2PASS_MAGIC
(
0x53015641
)
/
*
[
A
V
1
S
]
in
little
endian
*
/
#
define
OD_RC_2PASS_SUMMARY_SZ
(
4
+
1
+
(
4
+
4
+
8
)
*
OD_FRAME_NSUBTYPES
)
#
define
OD_RC_2PASS_PACKET_SZ
(
1
+
4
)
#
define
OD_RC_2PASS_MIN
(
OD_RC_2PASS_PACKET_SZ
+
OD_RC_2PASS_SUMMARY_SZ
)
#
define
OD_RC_2PASS_VERSION
(
1
)
typedef
struct
od_iir_bessel2
{
int32_t
c
[
2
]
;
int64_t
g
;
int32_t
x
[
2
]
;
int32_t
y
[
2
]
;
}
od_iir_bessel2
;
typedef
struct
od_frame_metrics
{
int64_t
log_scale
;
unsigned
frame_type
:
1
;
}
od_frame_metrics
;
typedef
struct
od_rc_state
{
int
frame_width
;
int
frame_height
;
int
bit_depth
;
double
framerate
;
int
keyframe_rate
;
int
goldenframe_rate
;
int
altref_rate
;
int64_t
target_bitrate
;
int
quality
;
int
periodic_boosts
;
int
maxq
;
int
minq
;
int
firstpass_quant
;
od_frame_metrics
cur_metrics
;
int64_t
scale_sum
[
OD_FRAME_NSUBTYPES
]
;
int
nframes
[
OD_FRAME_NSUBTYPES
]
;
uint8_t
*
twopass_buffer
;
int
twopass_buffer_bytes
;
uint8_t
firstpass_buffer
[
OD_RC_2PASS_SUMMARY_SZ
]
;
uint8_t
*
twopass_allframes_buf
;
size_t
twopass_allframes_buf_size
;
int
target_quantizer
;
int
base_quantizer
;
int64_t
cur_frame
;
int
end_of_input
;
int
closed_gop
;
int
reservoir_frame_delay
;
unsigned
char
drop_frames
;
unsigned
char
cap_overflow
;
unsigned
char
cap_underflow
;
int
twopass_state
;
int64_t
log_npixels
;
int64_t
bits_per_frame
;
int64_t
reservoir_fullness
;
int64_t
reservoir_target
;
int64_t
reservoir_max
;
int64_t
log_scale
[
OD_FRAME_NSUBTYPES
]
;
unsigned
exp
[
OD_FRAME_NSUBTYPES
]
;
int64_t
log_drop_scale
[
OD_FRAME_NSUBTYPES
]
;
uint32_t
prev_drop_count
[
OD_FRAME_NSUBTYPES
]
;
od_iir_bessel2
scalefilter
[
OD_FRAME_NSUBTYPES
]
;
od_iir_bessel2
vfrfilter
[
OD_FRAME_NSUBTYPES
]
;
int
frame_count
[
OD_FRAME_NSUBTYPES
]
;
int
inter_p_delay
;
int
inter_delay_target
;
int64_t
rate_bias
;
}
od_rc_state
;
int
od_enc_rc_init
(
od_rc_state
*
rc
int64_t
bitrate
int
delay_ms
)
;
int
od_enc_rc_select_quantizers_and_lambdas
(
od_rc_state
*
rc
int
is_golden_frame
int
is_altref_frame
int
frame_type
int
*
bottom_idx
int
*
top_idx
)
;
int
od_enc_rc_update_state
(
od_rc_state
*
rc
int64_t
bits
int
is_golden_frame
int
is_altref_frame
int
frame_type
int
droppable
)
;
int
od_frame_type
(
od_rc_state
*
rc
int64_t
coding_frame_count
int
*
is_golden
int
*
is_altref
int64_t
*
ip_count
)
;
int
od_enc_rc_resize
(
od_rc_state
*
rc
)
;
int
od_enc_rc_2pass_out
(
od_rc_state
*
rc
struct
aom_codec_pkt_list
*
pkt_list
int
summary
)
;
int
od_enc_rc_2pass_in
(
od_rc_state
*
rc
)
;
#
endif
