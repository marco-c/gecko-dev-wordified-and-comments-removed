#
ifndef
AOM_AV1_ENCODER_ENCODER_H_
#
define
AOM_AV1_ENCODER_ENCODER_H_
#
include
<
stdbool
.
h
>
#
include
<
stdio
.
h
>
#
include
"
config
/
aom_config
.
h
"
#
include
"
aom
/
aomcx
.
h
"
#
include
"
aom_util
/
aom_pthread
.
h
"
#
include
"
av1
/
common
/
alloccommon
.
h
"
#
include
"
av1
/
common
/
av1_common_int
.
h
"
#
include
"
av1
/
common
/
blockd
.
h
"
#
include
"
av1
/
common
/
entropymode
.
h
"
#
include
"
av1
/
common
/
enums
.
h
"
#
include
"
av1
/
common
/
reconintra
.
h
"
#
include
"
av1
/
common
/
resize
.
h
"
#
include
"
av1
/
common
/
thread_common
.
h
"
#
include
"
av1
/
common
/
timing
.
h
"
#
include
"
av1
/
encoder
/
aq_cyclicrefresh
.
h
"
#
include
"
av1
/
encoder
/
av1_quantize
.
h
"
#
include
"
av1
/
encoder
/
block
.
h
"
#
include
"
av1
/
encoder
/
context_tree
.
h
"
#
include
"
av1
/
encoder
/
enc_enums
.
h
"
#
include
"
av1
/
encoder
/
encodemb
.
h
"
#
include
"
av1
/
encoder
/
external_partition
.
h
"
#
include
"
av1
/
encoder
/
firstpass
.
h
"
#
include
"
av1
/
encoder
/
global_motion
.
h
"
#
include
"
av1
/
encoder
/
level
.
h
"
#
include
"
av1
/
encoder
/
lookahead
.
h
"
#
include
"
av1
/
encoder
/
mcomp
.
h
"
#
include
"
av1
/
encoder
/
pickcdef
.
h
"
#
include
"
av1
/
encoder
/
ratectrl
.
h
"
#
include
"
av1
/
encoder
/
rd
.
h
"
#
include
"
av1
/
encoder
/
speed_features
.
h
"
#
include
"
av1
/
encoder
/
svc_layercontext
.
h
"
#
include
"
av1
/
encoder
/
temporal_filter
.
h
"
#
if
CONFIG_THREE_PASS
#
include
"
av1
/
encoder
/
thirdpass
.
h
"
#
endif
#
include
"
av1
/
encoder
/
tokenize
.
h
"
#
include
"
av1
/
encoder
/
tpl_model
.
h
"
#
include
"
av1
/
encoder
/
av1_noise_estimate
.
h
"
#
include
"
av1
/
encoder
/
bitstream
.
h
"
#
if
CONFIG_INTERNAL_STATS
#
include
"
aom_dsp
/
ssim
.
h
"
#
endif
#
include
"
aom_dsp
/
variance
.
h
"
#
if
CONFIG_DENOISE
#
include
"
aom_dsp
/
noise_model
.
h
"
#
endif
#
if
CONFIG_TUNE_VMAF
#
include
"
av1
/
encoder
/
tune_vmaf
.
h
"
#
endif
#
if
CONFIG_AV1_TEMPORAL_DENOISING
#
include
"
av1
/
encoder
/
av1_temporal_denoiser
.
h
"
#
endif
#
if
CONFIG_TUNE_BUTTERAUGLI
#
include
"
av1
/
encoder
/
tune_butteraugli
.
h
"
#
endif
#
include
"
aom
/
internal
/
aom_codec_internal
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
SCENE_CUT_KEY_TEST_INTERVAL
16
#
define
TF_LOOKAHEAD_IDX_THR
7
#
define
HDR_QP_LEVELS
10
#
define
CHROMA_CB_QP_SCALE
1
.
04
#
define
CHROMA_CR_QP_SCALE
1
.
04
#
define
CHROMA_QP_SCALE
-
0
.
46
#
define
CHROMA_QP_OFFSET
9
.
26
#
define
QP_SCALE_FACTOR
2
.
0
#
define
DISABLE_HDR_LUMA_DELTAQ
1
typedef
struct
aom_rational64
{
int64_t
num
;
int
den
;
}
aom_rational64_t
;
enum
{
GOOD
REALTIME
ALLINTRA
}
UENUM1BYTE
(
MODE
)
;
enum
{
FRAMEFLAGS_KEY
=
1
<
<
0
FRAMEFLAGS_GOLDEN
=
1
<
<
1
FRAMEFLAGS_BWDREF
=
1
<
<
2
FRAMEFLAGS_ALTREF
=
1
<
<
3
FRAMEFLAGS_INTRAONLY
=
1
<
<
4
FRAMEFLAGS_SWITCH
=
1
<
<
5
FRAMEFLAGS_ERROR_RESILIENT
=
1
<
<
6
}
UENUM1BYTE
(
FRAMETYPE_FLAGS
)
;
#
if
CONFIG_FPMT_TEST
enum
{
PARALLEL_ENCODE
=
0
PARALLEL_SIMULATION_ENCODE
NUM_FPMT_TEST_ENCODES
}
UENUM1BYTE
(
FPMT_TEST_ENC_CFG
)
;
#
endif
#
define
MIN_PYR_LEVEL
1
static
inline
int
get_true_pyr_level
(
int
frame_level
int
frame_order
int
max_layer_depth
)
{
if
(
frame_order
=
=
0
)
{
return
MIN_PYR_LEVEL
;
}
else
if
(
frame_level
=
=
MAX_ARF_LAYERS
)
{
return
max_layer_depth
;
}
else
if
(
frame_level
=
=
(
MAX_ARF_LAYERS
+
1
)
)
{
return
MIN_PYR_LEVEL
;
}
return
AOMMAX
(
MIN_PYR_LEVEL
frame_level
)
;
}
enum
{
NO_AQ
=
0
VARIANCE_AQ
=
1
COMPLEXITY_AQ
=
2
CYCLIC_REFRESH_AQ
=
3
AQ_MODE_COUNT
}
UENUM1BYTE
(
AQ_MODE
)
;
enum
{
NO_DELTA_Q
=
0
DELTA_Q_OBJECTIVE
=
1
DELTA_Q_PERCEPTUAL
=
2
DELTA_Q_PERCEPTUAL_AI
=
3
DELTA_Q_USER_RATING_BASED
=
4
DELTA_Q_HDR
=
5
DELTA_Q_VARIANCE_BOOST
=
6
DELTA_Q_MODE_COUNT
}
UENUM1BYTE
(
DELTAQ_MODE
)
;
enum
{
RESIZE_NONE
=
0
RESIZE_FIXED
=
1
RESIZE_RANDOM
=
2
RESIZE_DYNAMIC
=
3
RESIZE_MODES
}
UENUM1BYTE
(
RESIZE_MODE
)
;
enum
{
SS_CFG_SRC
=
0
SS_CFG_LOOKAHEAD
=
1
SS_CFG_FPF
=
2
SS_CFG_TOTAL
=
3
}
UENUM1BYTE
(
SS_CFG_OFFSET
)
;
enum
{
DISABLE_SCENECUT
ENABLE_SCENECUT_MODE_1
ENABLE_SCENECUT_MODE_2
}
UENUM1BYTE
(
SCENECUT_MODE
)
;
#
define
MAX_VBR_CORPUS_COMPLEXITY
10000
typedef
enum
{
MOD_FP
MOD_TF
MOD_TPL
MOD_GME
MOD_ENC
MOD_LPF
MOD_CDEF_SEARCH
MOD_CDEF
MOD_LR
MOD_PACK_BS
MOD_FRAME_ENC
MOD_AI
NUM_MT_MODULES
}
MULTI_THREADED_MODULES
;
typedef
enum
{
COST_UPD_SB
COST_UPD_SBROW
COST_UPD_TILE
COST_UPD_OFF
NUM_COST_UPDATE_TYPES
}
COST_UPDATE_TYPE
;
typedef
enum
{
LOOPFILTER_NONE
=
0
LOOPFILTER_ALL
=
1
LOOPFILTER_REFERENCE
=
2
LOOPFILTER_SELECTIVELY
=
3
}
LOOPFILTER_CONTROL
;
typedef
enum
{
SKIP_APPLY_RESTORATION
=
1
<
<
0
SKIP_APPLY_SUPERRES
=
1
<
<
1
SKIP_APPLY_CDEF
=
1
<
<
2
SKIP_APPLY_LOOPFILTER
=
1
<
<
3
}
SKIP_APPLY_POSTPROC_FILTER
;
typedef
struct
{
RESIZE_MODE
resize_mode
;
uint8_t
resize_scale_denominator
;
uint8_t
resize_kf_scale_denominator
;
}
ResizeCfg
;
typedef
struct
{
bool
enable_rect_partitions
;
bool
enable_ab_partitions
;
bool
enable_1to4_partitions
;
BLOCK_SIZE
min_partition_size
;
BLOCK_SIZE
max_partition_size
;
}
PartitionCfg
;
typedef
struct
{
bool
enable_intra_edge_filter
;
bool
enable_filter_intra
;
bool
enable_smooth_intra
;
bool
enable_paeth_intra
;
bool
enable_cfl_intra
;
bool
enable_directional_intra
;
bool
enable_diagonal_intra
;
bool
enable_angle_delta
;
bool
auto_intra_tools_off
;
}
IntraModeCfg
;
typedef
struct
{
bool
enable_tx64
;
bool
enable_flip_idtx
;
bool
enable_rect_tx
;
bool
reduced_tx_type_set
;
bool
use_intra_dct_only
;
bool
use_inter_dct_only
;
bool
use_intra_default_tx_only
;
bool
enable_tx_size_search
;
}
TxfmSizeTypeCfg
;
typedef
struct
{
bool
enable_dist_wtd_comp
;
bool
enable_masked_comp
;
bool
enable_smooth_interintra
;
bool
enable_diff_wtd_comp
;
bool
enable_interinter_wedge
;
bool
enable_interintra_wedge
;
}
CompoundTypeCfg
;
typedef
struct
{
int
superres_qthresh
;
int
superres_kf_qthresh
;
uint8_t
superres_scale_denominator
;
uint8_t
superres_kf_scale_denominator
;
aom_superres_mode
superres_mode
;
bool
enable_superres
;
}
SuperResCfg
;
typedef
struct
{
int
key_freq_min
;
int
key_freq_max
;
int
enable_keyframe_filtering
;
int
sframe_dist
;
int
sframe_mode
;
bool
auto_key
;
int
fwd_kf_dist
;
bool
fwd_kf_enabled
;
bool
enable_sframe
;
bool
enable_intrabc
;
}
KeyFrameCfg
;
typedef
struct
{
int64_t
starting_buffer_level_ms
;
int64_t
optimal_buffer_level_ms
;
int64_t
maximum_buffer_size_ms
;
int64_t
target_bandwidth
;
unsigned
int
vbr_corpus_complexity_lap
;
unsigned
int
max_intra_bitrate_pct
;
unsigned
int
max_inter_bitrate_pct
;
unsigned
int
gf_cbr_boost_pct
;
unsigned
int
min_cr
;
int
drop_frames_water_mark
;
int
under_shoot_pct
;
int
over_shoot_pct
;
int
worst_allowed_q
;
int
best_allowed_q
;
int
cq_level
;
enum
aom_rc_mode
mode
;
int
vbrbias
;
int
vbrmin_section
;
int
vbrmax_section
;
int
max_consec_drop_ms
;
}
RateControlCfg
;
typedef
struct
{
int
lag_in_frames
;
int
min_gf_interval
;
int
max_gf_interval
;
int
gf_min_pyr_height
;
int
gf_max_pyr_height
;
bool
enable_auto_arf
;
bool
enable_auto_brf
;
}
GFConfig
;
typedef
struct
{
unsigned
int
num_tile_groups
;
unsigned
int
mtu
;
int
tile_columns
;
int
tile_rows
;
int
tile_width_count
;
int
tile_height_count
;
int
tile_widths
[
MAX_TILE_COLS
]
;
int
tile_heights
[
MAX_TILE_ROWS
]
;
bool
enable_large_scale_tile
;
bool
enable_single_tile_decoding
;
bool
enable_ext_tile_debug
;
}
TileConfig
;
typedef
struct
{
int
width
;
int
height
;
int
forced_max_frame_width
;
int
forced_max_frame_height
;
int
render_width
;
int
render_height
;
}
FrameDimensionCfg
;
typedef
struct
{
bool
enable_warped_motion
;
bool
allow_warped_motion
;
bool
enable_obmc
;
}
MotionModeCfg
;
typedef
struct
{
aom_timing_info_t
timing_info
;
uint32_t
num_units_in_decoding_tick
;
bool
decoder_model_info_present_flag
;
bool
display_model_info_present_flag
;
bool
timing_info_present
;
}
DecoderModelCfg
;
typedef
struct
{
COST_UPDATE_TYPE
coeff
;
COST_UPDATE_TYPE
mode
;
COST_UPDATE_TYPE
mv
;
COST_UPDATE_TYPE
dv
;
}
CostUpdateFreq
;
typedef
struct
{
unsigned
int
max_reference_frames
;
bool
enable_reduced_reference_set
;
bool
enable_onesided_comp
;
}
RefFrameCfg
;
typedef
struct
{
aom_color_primaries_t
color_primaries
;
aom_transfer_characteristics_t
transfer_characteristics
;
aom_matrix_coefficients_t
matrix_coefficients
;
aom_chroma_sample_position_t
chroma_sample_position
;
aom_color_range_t
color_range
;
}
ColorCfg
;
typedef
struct
{
unsigned
int
motion_vector_unit_test
;
unsigned
int
sb_multipass_unit_test
;
}
UnitTestCfg
;
typedef
struct
{
const
char
*
vmaf_model_path
;
const
char
*
film_grain_table_filename
;
aom_tune_metric
tuning
;
aom_tune_content
content
;
int
film_grain_test_vector
;
aom_dist_metric
dist_metric
;
}
TuneCfg
;
typedef
struct
{
double
init_framerate
;
unsigned
int
input_bit_depth
;
unsigned
int
limit
;
unsigned
int
chroma_subsampling_x
;
unsigned
int
chroma_subsampling_y
;
}
InputCfg
;
typedef
struct
{
int
use_fixed_qp_offsets
;
int
qm_minlevel
;
int
qm_maxlevel
;
int
quant_b_adapt
;
AQ_MODE
aq_mode
;
DELTAQ_MODE
deltaq_mode
;
unsigned
int
deltaq_strength
;
bool
enable_chroma_deltaq
;
bool
enable_hdr_deltaq
;
bool
using_qm
;
}
QuantizationCfg
;
typedef
struct
{
int
sharpness
;
bool
enable_adaptive_sharpness
;
int
disable_trellis_quant
;
int
arnr_max_frames
;
int
arnr_strength
;
uint8_t
cdf_update_mode
;
bool
enable_tpl_model
;
bool
enable_overlay
;
LOOPFILTER_CONTROL
loopfilter_control
;
bool
skip_postproc_filtering
;
aom_screen_detection_mode
screen_detection_mode
;
}
AlgoCfg
;
typedef
struct
{
aom_bit_depth_t
bit_depth
;
aom_superblock_size_t
superblock_size
;
bool
enable_deltalf_mode
;
CDEF_CONTROL
cdef_control
;
bool
enable_restoration
;
bool
force_video_mode
;
bool
error_resilient_mode
;
bool
frame_parallel_decoding_mode
;
bool
enable_monochrome
;
bool
full_still_picture_hdr
;
bool
enable_dual_filter
;
bool
enable_order_hint
;
bool
ref_frame_mvs_present
;
bool
enable_ref_frame_mvs
;
bool
enable_interintra_comp
;
bool
enable_global_motion
;
bool
enable_palette
;
}
ToolCfg
;
typedef
struct
AV1EncoderConfig
{
InputCfg
input_cfg
;
FrameDimensionCfg
frm_dim_cfg
;
AlgoCfg
algo_cfg
;
KeyFrameCfg
kf_cfg
;
RateControlCfg
rc_cfg
;
QuantizationCfg
q_cfg
;
ResizeCfg
resize_cfg
;
SuperResCfg
superres_cfg
;
aom_fixed_buf_t
twopass_stats_in
;
ToolCfg
tool_cfg
;
GFConfig
gf_cfg
;
TileConfig
tile_cfg
;
TuneCfg
tune_cfg
;
ColorCfg
color_cfg
;
DecoderModelCfg
dec_model_cfg
;
RefFrameCfg
ref_frm_cfg
;
UnitTestCfg
unit_test_cfg
;
MotionModeCfg
motion_mode_cfg
;
IntraModeCfg
intra_mode_cfg
;
TxfmSizeTypeCfg
txfm_cfg
;
CompoundTypeCfg
comp_type_cfg
;
PartitionCfg
part_cfg
;
CostUpdateFreq
cost_upd_freq
;
#
if
CONFIG_DENOISE
float
noise_level
;
int
noise_block_size
;
int
enable_dnl_denoising
;
#
endif
#
if
CONFIG_AV1_TEMPORAL_DENOISING
int
noise_sensitivity
;
#
endif
unsigned
int
tier_mask
;
int
border_in_pixels
;
int
max_threads
;
int
speed
;
unsigned
int
enable_low_complexity_decode
;
AV1_LEVEL
target_seq_level_idx
[
MAX_NUM_OPERATING_POINTS
]
;
BITSTREAM_PROFILE
profile
;
enum
aom_enc_pass
pass
;
int
passes
;
const
char
*
two_pass_output
;
const
char
*
second_pass_log
;
MODE
mode
;
bool
row_mt
;
bool
fp_mt
;
bool
use_highbitdepth
;
bool
save_as_annexb
;
const
char
*
partition_info_path
;
unsigned
int
enable_rate_guide_deltaq
;
const
char
*
rate_distribution_info
;
int
strict_level_conformance
;
int
kf_max_pyr_height
;
int
sb_qp_sweep
;
}
AV1EncoderConfig
;
static
inline
int
is_lossless_requested
(
const
RateControlCfg
*
const
rc_cfg
)
{
return
rc_cfg
-
>
best_allowed_q
=
=
0
&
&
rc_cfg
-
>
worst_allowed_q
=
=
0
;
}
typedef
struct
{
int
obmc_probs
[
FRAME_UPDATE_TYPES
]
[
BLOCK_SIZES_ALL
]
;
int
warped_probs
[
FRAME_UPDATE_TYPES
]
;
int
tx_type_probs
[
FRAME_UPDATE_TYPES
]
[
TX_SIZES_ALL
]
[
TX_TYPES
]
;
int
switchable_interp_probs
[
FRAME_UPDATE_TYPES
]
[
SWITCHABLE_FILTER_CONTEXTS
]
[
SWITCHABLE_FILTERS
]
;
}
FrameProbInfo
;
typedef
struct
FRAME_COUNTS
{
#
if
CONFIG_ENTROPY_STATS
unsigned
int
kf_y_mode
[
KF_MODE_CONTEXTS
]
[
KF_MODE_CONTEXTS
]
[
INTRA_MODES
]
;
unsigned
int
angle_delta
[
DIRECTIONAL_MODES
]
[
2
*
MAX_ANGLE_DELTA
+
1
]
;
unsigned
int
y_mode
[
BLOCK_SIZE_GROUPS
]
[
INTRA_MODES
]
;
unsigned
int
uv_mode
[
CFL_ALLOWED_TYPES
]
[
INTRA_MODES
]
[
UV_INTRA_MODES
]
;
unsigned
int
cfl_sign
[
CFL_JOINT_SIGNS
]
;
unsigned
int
cfl_alpha
[
CFL_ALPHA_CONTEXTS
]
[
CFL_ALPHABET_SIZE
]
;
unsigned
int
palette_y_mode
[
PALATTE_BSIZE_CTXS
]
[
PALETTE_Y_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
palette_uv_mode
[
PALETTE_UV_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
palette_y_size
[
PALATTE_BSIZE_CTXS
]
[
PALETTE_SIZES
]
;
unsigned
int
palette_uv_size
[
PALATTE_BSIZE_CTXS
]
[
PALETTE_SIZES
]
;
unsigned
int
palette_y_color_index
[
PALETTE_SIZES
]
[
PALETTE_COLOR_INDEX_CONTEXTS
]
[
PALETTE_COLORS
]
;
unsigned
int
palette_uv_color_index
[
PALETTE_SIZES
]
[
PALETTE_COLOR_INDEX_CONTEXTS
]
[
PALETTE_COLORS
]
;
unsigned
int
partition
[
PARTITION_CONTEXTS
]
[
EXT_PARTITION_TYPES
]
;
unsigned
int
txb_skip
[
TOKEN_CDF_Q_CTXS
]
[
TX_SIZES
]
[
TXB_SKIP_CONTEXTS
]
[
2
]
;
unsigned
int
eob_extra
[
TOKEN_CDF_Q_CTXS
]
[
TX_SIZES
]
[
PLANE_TYPES
]
[
EOB_COEF_CONTEXTS
]
[
2
]
;
unsigned
int
dc_sign
[
PLANE_TYPES
]
[
DC_SIGN_CONTEXTS
]
[
2
]
;
unsigned
int
coeff_lps
[
TX_SIZES
]
[
PLANE_TYPES
]
[
BR_CDF_SIZE
-
1
]
[
LEVEL_CONTEXTS
]
[
2
]
;
unsigned
int
eob_flag
[
TX_SIZES
]
[
PLANE_TYPES
]
[
EOB_COEF_CONTEXTS
]
[
2
]
;
unsigned
int
eob_multi16
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
5
]
;
unsigned
int
eob_multi32
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
6
]
;
unsigned
int
eob_multi64
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
7
]
;
unsigned
int
eob_multi128
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
8
]
;
unsigned
int
eob_multi256
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
9
]
;
unsigned
int
eob_multi512
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
10
]
;
unsigned
int
eob_multi1024
[
TOKEN_CDF_Q_CTXS
]
[
PLANE_TYPES
]
[
2
]
[
11
]
;
unsigned
int
coeff_lps_multi
[
TOKEN_CDF_Q_CTXS
]
[
TX_SIZES
]
[
PLANE_TYPES
]
[
LEVEL_CONTEXTS
]
[
BR_CDF_SIZE
]
;
unsigned
int
coeff_base_multi
[
TOKEN_CDF_Q_CTXS
]
[
TX_SIZES
]
[
PLANE_TYPES
]
[
SIG_COEF_CONTEXTS
]
[
NUM_BASE_LEVELS
+
2
]
;
unsigned
int
coeff_base_eob_multi
[
TOKEN_CDF_Q_CTXS
]
[
TX_SIZES
]
[
PLANE_TYPES
]
[
SIG_COEF_CONTEXTS_EOB
]
[
NUM_BASE_LEVELS
+
1
]
;
unsigned
int
newmv_mode
[
NEWMV_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
zeromv_mode
[
GLOBALMV_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
refmv_mode
[
REFMV_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
drl_mode
[
DRL_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
inter_compound_mode
[
INTER_MODE_CONTEXTS
]
[
INTER_COMPOUND_MODES
]
;
unsigned
int
wedge_idx
[
BLOCK_SIZES_ALL
]
[
16
]
;
unsigned
int
interintra
[
BLOCK_SIZE_GROUPS
]
[
2
]
;
unsigned
int
interintra_mode
[
BLOCK_SIZE_GROUPS
]
[
INTERINTRA_MODES
]
;
unsigned
int
wedge_interintra
[
BLOCK_SIZES_ALL
]
[
2
]
;
unsigned
int
compound_type
[
BLOCK_SIZES_ALL
]
[
MASKED_COMPOUND_TYPES
]
;
unsigned
int
motion_mode
[
BLOCK_SIZES_ALL
]
[
MOTION_MODES
]
;
unsigned
int
obmc
[
BLOCK_SIZES_ALL
]
[
2
]
;
unsigned
int
intra_inter
[
INTRA_INTER_CONTEXTS
]
[
2
]
;
unsigned
int
comp_inter
[
COMP_INTER_CONTEXTS
]
[
2
]
;
unsigned
int
comp_ref_type
[
COMP_REF_TYPE_CONTEXTS
]
[
2
]
;
unsigned
int
uni_comp_ref
[
UNI_COMP_REF_CONTEXTS
]
[
UNIDIR_COMP_REFS
-
1
]
[
2
]
;
unsigned
int
single_ref
[
REF_CONTEXTS
]
[
SINGLE_REFS
-
1
]
[
2
]
;
unsigned
int
comp_ref
[
REF_CONTEXTS
]
[
FWD_REFS
-
1
]
[
2
]
;
unsigned
int
comp_bwdref
[
REF_CONTEXTS
]
[
BWD_REFS
-
1
]
[
2
]
;
unsigned
int
intrabc
[
2
]
;
unsigned
int
txfm_partition
[
TXFM_PARTITION_CONTEXTS
]
[
2
]
;
unsigned
int
intra_tx_size
[
MAX_TX_CATS
]
[
TX_SIZE_CONTEXTS
]
[
MAX_TX_DEPTH
+
1
]
;
unsigned
int
skip_mode
[
SKIP_MODE_CONTEXTS
]
[
2
]
;
unsigned
int
skip_txfm
[
SKIP_CONTEXTS
]
[
2
]
;
unsigned
int
compound_index
[
COMP_INDEX_CONTEXTS
]
[
2
]
;
unsigned
int
comp_group_idx
[
COMP_GROUP_IDX_CONTEXTS
]
[
2
]
;
unsigned
int
delta_q
[
DELTA_Q_PROBS
]
[
2
]
;
unsigned
int
delta_lf_multi
[
FRAME_LF_COUNT
]
[
DELTA_LF_PROBS
]
[
2
]
;
unsigned
int
delta_lf
[
DELTA_LF_PROBS
]
[
2
]
;
unsigned
int
inter_ext_tx
[
EXT_TX_SETS_INTER
]
[
EXT_TX_SIZES
]
[
TX_TYPES
]
;
unsigned
int
intra_ext_tx
[
EXT_TX_SETS_INTRA
]
[
EXT_TX_SIZES
]
[
INTRA_MODES
]
[
TX_TYPES
]
;
unsigned
int
filter_intra_mode
[
FILTER_INTRA_MODES
]
;
unsigned
int
filter_intra
[
BLOCK_SIZES_ALL
]
[
2
]
;
unsigned
int
switchable_restore
[
RESTORE_SWITCHABLE_TYPES
]
;
unsigned
int
wiener_restore
[
2
]
;
unsigned
int
sgrproj_restore
[
2
]
;
#
endif
unsigned
int
switchable_interp
[
SWITCHABLE_FILTER_CONTEXTS
]
[
SWITCHABLE_FILTERS
]
;
}
FRAME_COUNTS
;
#
define
INTER_MODE_RD_DATA_OVERALL_SIZE
6400
typedef
struct
{
int
ready
;
double
a
;
double
b
;
double
dist_mean
;
double
ld_mean
;
double
sse_mean
;
double
sse_sse_mean
;
double
sse_ld_mean
;
int
num
;
double
dist_sum
;
double
ld_sum
;
double
sse_sum
;
double
sse_sse_sum
;
double
sse_ld_sum
;
}
InterModeRdModel
;
typedef
struct
{
int
idx
;
int64_t
rd
;
}
RdIdxPair
;
#
define
MAX_INTER_MODES
1024
typedef
struct
inter_modes_info
{
int
num
;
MB_MODE_INFO
mbmi_arr
[
MAX_INTER_MODES
]
;
int
mode_rate_arr
[
MAX_INTER_MODES
]
;
int64_t
sse_arr
[
MAX_INTER_MODES
]
;
int64_t
est_rd_arr
[
MAX_INTER_MODES
]
;
RdIdxPair
rd_idx_pair_arr
[
MAX_INTER_MODES
]
;
RD_STATS
rd_cost_arr
[
MAX_INTER_MODES
]
;
RD_STATS
rd_cost_y_arr
[
MAX_INTER_MODES
]
;
RD_STATS
rd_cost_uv_arr
[
MAX_INTER_MODES
]
;
}
InterModesInfo
;
typedef
struct
{
uint32_t
sum_square_error
;
int32_t
sum_error
;
int
log2_count
;
int
variance
;
}
VPartVar
;
typedef
struct
{
VPartVar
none
;
VPartVar
horz
[
2
]
;
VPartVar
vert
[
2
]
;
}
VPVariance
;
typedef
struct
{
VPVariance
part_variances
;
VPartVar
split
[
4
]
;
}
VP4x4
;
typedef
struct
{
VPVariance
part_variances
;
VP4x4
split
[
4
]
;
}
VP8x8
;
typedef
struct
{
VPVariance
part_variances
;
VP8x8
split
[
4
]
;
}
VP16x16
;
typedef
struct
{
VPVariance
part_variances
;
VP16x16
split
[
4
]
;
}
VP32x32
;
typedef
struct
{
VPVariance
part_variances
;
VP32x32
split
[
4
]
;
}
VP64x64
;
typedef
struct
{
VPVariance
part_variances
;
VP64x64
*
split
;
}
VP128x128
;
typedef
struct
{
int64_t
thresholds
[
5
]
;
int64_t
threshold_minmax
;
}
VarBasedPartitionInfo
;
typedef
struct
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
*
mutex_
;
pthread_cond_t
*
cond_
;
#
endif
int
*
num_finished_cols
;
int
sync_range
;
int
intrabc_extra_top_right_sb_delay
;
int
rows
;
int
next_mi_row
;
int
num_threads_working
;
}
AV1EncRowMultiThreadSync
;
typedef
struct
TileDataEnc
{
TileInfo
tile_info
;
DECLARE_ALIGNED
(
16
FRAME_CONTEXT
tctx
)
;
FRAME_CONTEXT
*
row_ctx
;
uint64_t
abs_sum_level
;
uint8_t
allow_update_cdf
;
InterModeRdModel
inter_mode_rd_models
[
BLOCK_SIZES_ALL
]
;
AV1EncRowMultiThreadSync
row_mt_sync
;
MV
firstpass_top_mv
;
}
TileDataEnc
;
typedef
struct
RD_COUNTS
{
int
compound_ref_used_flag
;
int
skip_mode_used_flag
;
int
tx_type_used
[
TX_SIZES_ALL
]
[
TX_TYPES
]
;
int
obmc_used
[
BLOCK_SIZES_ALL
]
[
2
]
;
int
warped_used
[
2
]
;
int
newmv_or_intra_blocks
;
uint64_t
seg_tmp_pred_cost
[
2
]
;
}
RD_COUNTS
;
typedef
struct
ThreadData
{
MACROBLOCK
mb
;
MvCosts
*
mv_costs_alloc
;
IntraBCMVCosts
*
dv_costs_alloc
;
RD_COUNTS
rd_counts
;
FRAME_COUNTS
*
counts
;
PC_TREE_SHARED_BUFFERS
shared_coeff_buf
;
SIMPLE_MOTION_DATA_TREE
*
sms_tree
;
SIMPLE_MOTION_DATA_TREE
*
sms_root
;
uint32_t
*
hash_value_buffer
[
2
]
;
OBMCBuffer
obmc_buffer
;
PALETTE_BUFFER
*
palette_buffer
;
CompoundTypeRdBuffers
comp_rd_buffer
;
CONV_BUF_TYPE
*
tmp_conv_dst
;
uint64_t
abs_sum_level
;
uint8_t
*
tmp_pred_bufs
[
2
]
;
uint8_t
*
wiener_tmp_pred_buf
;
int
intrabc_used
;
int
deltaq_used
;
int
coefficient_size
;
int
max_mv_magnitude
;
int
interp_filter_selected
[
SWITCHABLE
]
;
FRAME_CONTEXT
*
tctx
;
VP64x64
*
vt64x64
;
int32_t
num_64x64_blocks
;
PICK_MODE_CONTEXT
*
firstpass_ctx
;
TemporalFilterData
tf_data
;
TplBuffers
tpl_tmp_buffers
;
TplTxfmStats
tpl_txfm_stats
;
GlobalMotionData
gm_data
;
PixelLevelGradientInfo
*
pixel_gradient_info
;
Block4x4VarInfo
*
src_var_info_of_4x4_sub_blocks
;
PC_TREE
*
pc_root
;
}
ThreadData
;
struct
EncWorkerData
;
typedef
struct
{
int
allocated_tile_rows
;
int
allocated_tile_cols
;
int
allocated_rows
;
int
allocated_cols
;
int
thread_id_to_tile_id
[
MAX_NUM_THREADS
]
;
int
*
num_tile_cols_done
;
int
allocated_sb_rows
;
bool
row_mt_exit
;
bool
firstpass_mt_exit
;
bool
mb_wiener_mt_exit
;
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
*
mutex_
;
pthread_cond_t
*
cond_
;
#
endif
void
(
*
sync_read_ptr
)
(
AV1EncRowMultiThreadSync
*
const
int
int
)
;
void
(
*
sync_write_ptr
)
(
AV1EncRowMultiThreadSync
*
const
int
int
int
)
;
}
AV1EncRowMultiThreadInfo
;
typedef
struct
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
*
mutex_
;
pthread_cond_t
*
cond_
;
#
endif
void
(
*
intra_sync_read_ptr
)
(
AV1EncRowMultiThreadSync
*
const
int
int
)
;
void
(
*
intra_sync_write_ptr
)
(
AV1EncRowMultiThreadSync
*
const
int
int
int
)
;
}
AV1EncAllIntraMultiThreadInfo
;
#
define
NUM_RECODES_PER_FRAME
10
#
define
MAX_PARALLEL_FRAMES
4
typedef
struct
RestoreStateBuffers
{
uint16_t
*
cdef_srcbuf
;
uint16_t
*
cdef_colbuf
[
MAX_MB_PLANE
]
;
int32_t
*
rst_tmpbuf
;
RestorationLineBuffers
*
rlbs
;
}
RestoreStateBuffers
;
typedef
struct
{
WienerInfo
wiener
;
SgrprojInfo
sgrproj
;
RestorationType
best_rtype
[
RESTORE_TYPES
-
1
]
;
}
RestUnitSearchInfo
;
typedef
struct
{
RestUnitSearchInfo
*
rusi
[
MAX_MB_PLANE
]
;
int16_t
*
dgd_avg
;
}
AV1LrPickStruct
;
typedef
struct
PrimaryMultiThreadInfo
{
int
num_workers
;
int
num_mod_workers
[
NUM_MT_MODULES
]
;
AVxWorker
*
workers
;
struct
EncWorkerData
*
tile_thr_data
;
AV1CdefWorkerData
*
cdef_worker
;
AVxWorker
*
p_workers
[
MAX_PARALLEL_FRAMES
]
;
int
p_num_workers
;
int
prev_num_enc_workers
;
}
PrimaryMultiThreadInfo
;
typedef
struct
MultiThreadInfo
{
int
num_workers
;
int
num_mod_workers
[
NUM_MT_MODULES
]
;
AVxWorker
*
workers
;
struct
EncWorkerData
*
tile_thr_data
;
bool
row_mt_enabled
;
bool
pack_bs_mt_enabled
;
AV1EncRowMultiThreadInfo
enc_row_mt
;
AV1EncAllIntraMultiThreadInfo
intra_mt
;
AV1TplRowMultiThreadInfo
tpl_row_mt
;
AV1LfSync
lf_row_sync
;
AV1LrSync
lr_row_sync
;
AV1EncPackBSSync
pack_bs_sync
;
AV1GlobalMotionSync
gm_sync
;
AV1TemporalFilterSync
tf_sync
;
AV1CdefSync
cdef_sync
;
AV1CdefWorkerData
*
cdef_worker
;
RestoreStateBuffers
restore_state_buf
;
int
pipeline_lpf_mt_with_enc
;
}
MultiThreadInfo
;
typedef
struct
ActiveMap
{
int
enabled
;
int
update
;
unsigned
char
*
map
;
}
ActiveMap
;
typedef
struct
{
double
cs_rate_array
[
32
]
;
int
rate_index
;
int
rate_size
;
}
ForceIntegerMVInfo
;
#
if
CONFIG_INTERNAL_STATS
enum
{
STAT_Y
STAT_U
STAT_V
STAT_ALL
NUM_STAT_TYPES
}
UENUM1BYTE
(
StatType
)
;
typedef
struct
IMAGE_STAT
{
double
stat
[
NUM_STAT_TYPES
]
;
double
worst
;
}
ImageStat
;
#
endif
typedef
struct
{
int
ref_count
;
YV12_BUFFER_CONFIG
buf
;
}
EncRefCntBuffer
;
typedef
struct
{
MB_MODE_INFO_EXT_FRAME
*
frame_base
;
int
alloc_size
;
int
stride
;
}
MBMIExtFrameBufferInfo
;
#
if
CONFIG_COLLECT_PARTITION_STATS
typedef
struct
FramePartitionTimingStats
{
int
partition_decisions
[
6
]
[
EXT_PARTITION_TYPES
]
;
int
partition_attempts
[
6
]
[
EXT_PARTITION_TYPES
]
;
int64_t
partition_times
[
6
]
[
EXT_PARTITION_TYPES
]
;
int
partition_redo
;
}
FramePartitionTimingStats
;
#
endif
#
if
CONFIG_COLLECT_COMPONENT_TIMING
#
include
"
aom_ports
/
aom_timer
.
h
"
enum
{
av1_encode_strategy_time
av1_get_one_pass_rt_params_time
av1_get_second_pass_params_time
denoise_and_encode_time
apply_filtering_time
av1_tpl_setup_stats_time
encode_frame_to_data_rate_time
encode_with_or_without_recode_time
loop_filter_time
cdef_time
loop_restoration_time
av1_pack_bitstream_final_time
av1_encode_frame_time
av1_compute_global_motion_time
av1_setup_motion_field_time
encode_sb_row_time
rd_pick_partition_time
rd_use_partition_time
choose_var_based_partitioning_time
av1_prune_partitions_time
none_partition_search_time
split_partition_search_time
rectangular_partition_search_time
ab_partitions_search_time
rd_pick_4partition_time
encode_sb_time
rd_pick_sb_modes_time
av1_rd_pick_intra_mode_sb_time
av1_rd_pick_inter_mode_sb_time
set_params_rd_pick_inter_mode_time
skip_inter_mode_time
handle_inter_mode_time
evaluate_motion_mode_for_winner_candidates_time
do_tx_search_time
handle_intra_mode_time
refine_winner_mode_tx_time
av1_search_palette_mode_time
handle_newmv_time
compound_type_rd_time
interpolation_filter_search_time
motion_mode_rd_time
nonrd_use_partition_time
pick_sb_modes_nonrd_time
hybrid_intra_mode_search_time
nonrd_pick_inter_mode_sb_time
encode_b_nonrd_time
kTimingComponents
}
UENUM1BYTE
(
TIMING_COMPONENT
)
;
static
inline
char
const
*
get_component_name
(
int
index
)
{
switch
(
index
)
{
case
av1_encode_strategy_time
:
return
"
av1_encode_strategy_time
"
;
case
av1_get_one_pass_rt_params_time
:
return
"
av1_get_one_pass_rt_params_time
"
;
case
av1_get_second_pass_params_time
:
return
"
av1_get_second_pass_params_time
"
;
case
denoise_and_encode_time
:
return
"
denoise_and_encode_time
"
;
case
apply_filtering_time
:
return
"
apply_filtering_time
"
;
case
av1_tpl_setup_stats_time
:
return
"
av1_tpl_setup_stats_time
"
;
case
encode_frame_to_data_rate_time
:
return
"
encode_frame_to_data_rate_time
"
;
case
encode_with_or_without_recode_time
:
return
"
encode_with_or_without_recode_time
"
;
case
loop_filter_time
:
return
"
loop_filter_time
"
;
case
cdef_time
:
return
"
cdef_time
"
;
case
loop_restoration_time
:
return
"
loop_restoration_time
"
;
case
av1_pack_bitstream_final_time
:
return
"
av1_pack_bitstream_final_time
"
;
case
av1_encode_frame_time
:
return
"
av1_encode_frame_time
"
;
case
av1_compute_global_motion_time
:
return
"
av1_compute_global_motion_time
"
;
case
av1_setup_motion_field_time
:
return
"
av1_setup_motion_field_time
"
;
case
encode_sb_row_time
:
return
"
encode_sb_row_time
"
;
case
rd_pick_partition_time
:
return
"
rd_pick_partition_time
"
;
case
rd_use_partition_time
:
return
"
rd_use_partition_time
"
;
case
choose_var_based_partitioning_time
:
return
"
choose_var_based_partitioning_time
"
;
case
av1_prune_partitions_time
:
return
"
av1_prune_partitions_time
"
;
case
none_partition_search_time
:
return
"
none_partition_search_time
"
;
case
split_partition_search_time
:
return
"
split_partition_search_time
"
;
case
rectangular_partition_search_time
:
return
"
rectangular_partition_search_time
"
;
case
ab_partitions_search_time
:
return
"
ab_partitions_search_time
"
;
case
rd_pick_4partition_time
:
return
"
rd_pick_4partition_time
"
;
case
encode_sb_time
:
return
"
encode_sb_time
"
;
case
rd_pick_sb_modes_time
:
return
"
rd_pick_sb_modes_time
"
;
case
av1_rd_pick_intra_mode_sb_time
:
return
"
av1_rd_pick_intra_mode_sb_time
"
;
case
av1_rd_pick_inter_mode_sb_time
:
return
"
av1_rd_pick_inter_mode_sb_time
"
;
case
set_params_rd_pick_inter_mode_time
:
return
"
set_params_rd_pick_inter_mode_time
"
;
case
skip_inter_mode_time
:
return
"
skip_inter_mode_time
"
;
case
handle_inter_mode_time
:
return
"
handle_inter_mode_time
"
;
case
evaluate_motion_mode_for_winner_candidates_time
:
return
"
evaluate_motion_mode_for_winner_candidates_time
"
;
case
do_tx_search_time
:
return
"
do_tx_search_time
"
;
case
handle_intra_mode_time
:
return
"
handle_intra_mode_time
"
;
case
refine_winner_mode_tx_time
:
return
"
refine_winner_mode_tx_time
"
;
case
av1_search_palette_mode_time
:
return
"
av1_search_palette_mode_time
"
;
case
handle_newmv_time
:
return
"
handle_newmv_time
"
;
case
compound_type_rd_time
:
return
"
compound_type_rd_time
"
;
case
interpolation_filter_search_time
:
return
"
interpolation_filter_search_time
"
;
case
motion_mode_rd_time
:
return
"
motion_mode_rd_time
"
;
case
nonrd_use_partition_time
:
return
"
nonrd_use_partition_time
"
;
case
pick_sb_modes_nonrd_time
:
return
"
pick_sb_modes_nonrd_time
"
;
case
hybrid_intra_mode_search_time
:
return
"
hybrid_intra_mode_search_time
"
;
case
nonrd_pick_inter_mode_sb_time
:
return
"
nonrd_pick_inter_mode_sb_time
"
;
case
encode_b_nonrd_time
:
return
"
encode_b_nonrd_time
"
;
default
:
assert
(
0
)
;
}
return
"
error
"
;
}
#
endif
#
define
MAX_INTERNAL_ARFS
(
REF_FRAMES
-
BWDREF_FRAME
-
1
)
typedef
struct
{
bool
search_done
;
YV12_BUFFER_CONFIG
*
ref_buf
[
REF_FRAMES
]
;
int
num_ref_frames
[
MAX_DIRECTIONS
]
;
FrameDistPair
reference_frames
[
MAX_DIRECTIONS
]
[
REF_FRAMES
-
1
]
;
int
segment_map_w
;
int
segment_map_h
;
}
GlobalMotionInfo
;
typedef
struct
{
int
default_interp_skip_flags
;
uint16_t
interp_filter_search_mask
;
}
InterpSearchFlags
;
typedef
struct
{
int
max_mv_magnitude
;
int
mv_step_param
;
fractional_mv_step_fp
*
find_fractional_mv_step
;
search_site_config
search_site_cfg
[
SS_CFG_TOTAL
]
[
NUM_DISTINCT_SEARCH_METHODS
]
;
}
MotionVectorSearchParams
;
typedef
struct
{
bool
golden_frame
;
bool
bwd_ref_frame
;
bool
alt_ref_frame
;
}
RefreshFrameInfo
;
typedef
struct
{
int
width
;
int
height
;
}
ResizePendingParams
;
typedef
struct
{
int
ref_relative_dist
[
INTER_REFS_PER_FRAME
]
;
int8_t
nearest_past_ref
;
int8_t
nearest_future_ref
;
}
RefFrameDistanceInfo
;
typedef
struct
{
unsigned
int
coeff_opt_thresholds
[
MODE_EVAL_TYPES
]
[
2
]
;
TX_SIZE_SEARCH_METHOD
tx_size_search_methods
[
MODE_EVAL_TYPES
]
;
unsigned
int
use_transform_domain_distortion
[
MODE_EVAL_TYPES
]
;
unsigned
int
tx_domain_dist_threshold
[
MODE_EVAL_TYPES
]
;
unsigned
int
skip_txfm_level
[
MODE_EVAL_TYPES
]
;
unsigned
int
predict_dc_level
[
MODE_EVAL_TYPES
]
;
}
WinnerModeParams
;
typedef
struct
{
bool
last_frame
;
bool
golden_frame
;
bool
bwd_ref_frame
;
bool
alt2_ref_frame
;
bool
alt_ref_frame
;
bool
update_pending
;
}
ExtRefreshFrameFlagsInfo
;
typedef
struct
{
int
ref_frame_flags
;
ExtRefreshFrameFlagsInfo
refresh_frame
;
bool
refresh_frame_context
;
bool
refresh_frame_context_pending
;
bool
use_ref_frame_mvs
;
bool
use_error_resilient
;
bool
use_s_frame
;
bool
use_primary_ref_none
;
}
ExternalFlags
;
typedef
struct
{
int
high_prec
;
int
q
;
int
order
;
int
inter_count
;
int
intra_count
;
int
default_mvs
;
int
mv_joint_count
[
4
]
;
int
last_bit_zero
;
int
last_bit_nonzero
;
int
total_mv_rate
;
int
hp_total_mv_rate
;
int
lp_total_mv_rate
;
int
horz_text
;
int
vert_text
;
int
diag_text
;
int
valid
;
}
MV_STATS
;
typedef
struct
WeberStats
{
int64_t
mb_wiener_variance
;
int64_t
src_variance
;
int64_t
rec_variance
;
int16_t
src_pix_max
;
int16_t
rec_pix_max
;
int64_t
distortion
;
int64_t
satd
;
double
max_scale
;
}
WeberStats
;
typedef
struct
{
struct
loopfilter
lf
;
CdefInfo
cdef_info
;
YV12_BUFFER_CONFIG
copy_buffer
;
RATE_CONTROL
rc
;
MV_STATS
mv_stats
;
}
CODING_CONTEXT
;
typedef
struct
{
int
frame_width
;
int
frame_height
;
int
mi_rows
;
int
mi_cols
;
int
mb_rows
;
int
mb_cols
;
int
num_mbs
;
aom_bit_depth_t
bit_depth
;
int
subsampling_x
;
int
subsampling_y
;
}
FRAME_INFO
;
typedef
struct
{
int
show_frame_count
;
}
FRAME_INDEX_SET
;
typedef
struct
{
uint8_t
*
map
;
bool
has_lossless_segment
;
}
EncSegmentationInfo
;
typedef
struct
{
int64_t
prev_ts_start
;
int64_t
prev_ts_end
;
int64_t
first_ts_start
;
}
TimeStamps
;
typedef
struct
{
tran_low_t
*
tcoeff
;
uint16_t
*
eobs
;
uint8_t
*
entropy_ctx
;
}
CoeffBufferPool
;
#
if
!
CONFIG_REALTIME_ONLY
enum
{
DUCKY_ENCODE_FRAME_MODE_NONE
DUCKY_ENCODE_FRAME_MODE_QINDEX
DUCKY_ENCODE_FRAME_MODE_QINDEX_RDMULT
}
UENUM1BYTE
(
DUCKY_ENCODE_FRAME_MODE
)
;
enum
{
DUCKY_ENCODE_GOP_MODE_NONE
DUCKY_ENCODE_GOP_MODE_RCL
}
UENUM1BYTE
(
DUCKY_ENCODE_GOP_MODE
)
;
typedef
struct
DuckyEncodeFrameInfo
{
DUCKY_ENCODE_FRAME_MODE
qp_mode
;
DUCKY_ENCODE_GOP_MODE
gop_mode
;
int
q_index
;
int
rdmult
;
int
*
superblock_encode_qindex
;
int
*
superblock_encode_rdmult
;
int
delta_q_enabled
;
}
DuckyEncodeFrameInfo
;
typedef
struct
DuckyEncodeFrameResult
{
int
global_order_idx
;
int
q_index
;
int
rdmult
;
int
rate
;
int64_t
dist
;
double
psnr
;
}
DuckyEncodeFrameResult
;
typedef
struct
DuckyEncodeInfo
{
DuckyEncodeFrameInfo
frame_info
;
DuckyEncodeFrameResult
frame_result
;
}
DuckyEncodeInfo
;
#
endif
typedef
struct
RTC_REF
{
int
reference
[
INTER_REFS_PER_FRAME
]
;
int
ref_idx
[
INTER_REFS_PER_FRAME
]
;
int
refresh
[
REF_FRAMES
]
;
int
set_ref_frame_config
;
int
non_reference_frame
;
int
ref_frame_comp
[
3
]
;
int
gld_idx_1layer
;
unsigned
int
buffer_time_index
[
REF_FRAMES
]
;
unsigned
char
buffer_spatial_layer
[
REF_FRAMES
]
;
bool
reference_was_previous_frame
;
bool
bias_recovery_frame
;
}
RTC_REF
;
typedef
struct
AV1_COMP_DATA
{
unsigned
char
*
cx_data
;
size_t
cx_data_sz
;
size_t
frame_size
;
unsigned
int
lib_flags
;
int64_t
ts_frame_start
;
int64_t
ts_frame_end
;
int
flush
;
const
aom_rational64_t
*
timestamp_ratio
;
int
pop_lookahead
;
}
AV1_COMP_DATA
;
typedef
struct
AV1_PRIMARY
{
struct
AV1_COMP
*
parallel_cpi
[
MAX_PARALLEL_FRAMES
]
;
struct
AV1_COMP_DATA
parallel_frames_data
[
MAX_PARALLEL_FRAMES
-
1
]
;
#
if
CONFIG_FPMT_TEST
FPMT_TEST_ENC_CFG
fpmt_unit_test_cfg
;
FrameProbInfo
temp_frame_probs
;
FrameProbInfo
temp_frame_probs_simulation
;
int
temp_valid_gm_model_found
[
FRAME_UPDATE_TYPES
]
;
#
endif
RefCntBuffer
*
ref_frame_map_copy
[
REF_FRAMES
]
;
int64_t
ts_start_last_show_frame
;
int64_t
ts_end_last_show_frame
;
int
num_fp_contexts
;
int
filter_level
[
2
]
;
int
filter_level_u
;
int
filter_level_v
;
struct
AV1_COMP
*
cpi
;
struct
AV1_COMP
*
cpi_lap
;
struct
lookahead_ctx
*
lookahead
;
int
seq_params_locked
;
struct
aom_codec_pkt_list
*
output_pkt_list
;
int
internal_altref_allowed
;
int
show_existing_alt_ref
;
GF_GROUP
gf_group
;
GF_STATE
gf_state
;
int
lap_enabled
;
AV1LevelParams
level_params
;
int
b_calculate_psnr
;
int
frames_left
;
TWO_PASS
twopass
;
PRIMARY_RATE_CONTROL
p_rc
;
TEMPORAL_FILTER_INFO
tf_info
;
SequenceHeader
seq_params
;
int
use_svc
;
bool
buffer_removal_time_present
;
unsigned
int
number_temporal_layers
;
unsigned
int
number_spatial_layers
;
struct
aom_internal_error_info
error
;
aom_variance_fn_ptr_t
fn_ptr
[
BLOCK_SIZES_ALL
]
;
double
*
tpl_sb_rdmult_scaling_factors
;
TplParams
tpl_data
;
MV_STATS
mv_stats
;
#
if
CONFIG_INTERNAL_STATS
uint64_t
total_time_receive_data
;
uint64_t
total_time_compress_data
;
unsigned
int
total_mode_chosen_counts
[
MAX_MODES
]
;
int
count
[
2
]
;
uint64_t
total_sq_error
[
2
]
;
uint64_t
total_samples
[
2
]
;
ImageStat
psnr
[
2
]
;
double
total_blockiness
;
double
worst_blockiness
;
uint64_t
total_bytes
;
double
summed_quality
;
double
summed_weights
;
double
summed_quality_hbd
;
double
summed_weights_hbd
;
unsigned
int
total_recode_hits
;
double
worst_ssim
;
double
worst_ssim_hbd
;
ImageStat
fastssim
;
ImageStat
psnrhvs
;
int
b_calculate_blockiness
;
int
b_calculate_consistency
;
double
total_inconsistency
;
double
worst_consistency
;
Ssimv
*
ssim_vars
;
Metrics
metrics
;
#
endif
#
if
CONFIG_ENTROPY_STATS
FRAME_COUNTS
aggregate_fc
;
#
endif
int
fb_of_context_type
[
REF_FRAMES
]
;
PrimaryMultiThreadInfo
p_mt_info
;
FrameProbInfo
frame_probs
;
int
valid_gm_model_found
[
FRAME_UPDATE_TYPES
]
;
RTC_REF
rtc_ref
;
AV1EncRowMultiThreadSync
intra_row_mt_sync
;
}
AV1_PRIMARY
;
typedef
struct
AV1_COMP
{
AV1_PRIMARY
*
ppi
;
EncQuantDequantParams
enc_quant_dequant_params
;
ThreadData
td
;
FRAME_COUNTS
counts
;
MBMIExtFrameBufferInfo
mbmi_ext_info
;
CB_COEFF_BUFFER
*
coeff_buffer_base
;
CoeffBufferPool
coeff_buffer_pool
;
AV1_COMMON
common
;
AV1EncoderConfig
oxcf
;
TRELLIS_OPT_TYPE
optimize_seg_arr
[
MAX_SEGMENTS
]
;
YV12_BUFFER_CONFIG
*
source
;
YV12_BUFFER_CONFIG
*
last_source
;
YV12_BUFFER_CONFIG
*
unscaled_source
;
YV12_BUFFER_CONFIG
scaled_source
;
YV12_BUFFER_CONFIG
*
unscaled_last_source
;
YV12_BUFFER_CONFIG
scaled_last_source
;
YV12_BUFFER_CONFIG
*
unfiltered_source
;
YV12_BUFFER_CONFIG
orig_source
;
int
skip_tpl_setup_stats
;
double
*
tpl_rdmult_scaling_factors
;
TemporalFilterCtx
tf_ctx
;
CdefSearchCtx
*
cdef_search_ctx
;
ForceIntegerMVInfo
force_intpel_info
;
RefCntBuffer
*
scaled_ref_buf
[
INTER_REFS_PER_FRAME
]
;
RefCntBuffer
*
last_show_frame_buf
;
RefreshFrameInfo
refresh_frame
;
int
rt_reduce_num_ref_buffers
;
ExternalFlags
ext_flags
;
YV12_BUFFER_CONFIG
last_frame_uf
;
YV12_BUFFER_CONFIG
trial_frame_rst
;
int64_t
ambient_err
;
RD_OPT
rd
;
CODING_CONTEXT
coding_context
;
GlobalMotionInfo
gm_info
;
WinnerModeParams
winner_mode_params
;
TimeStamps
time_stamps
;
RATE_CONTROL
rc
;
double
framerate
;
int
ref_frame_flags
;
int
speed
;
SPEED_FEATURES
sf
;
MotionVectorSearchParams
mv_search_params
;
int
all_one_sided_refs
;
EncSegmentationInfo
enc_seg
;
CYCLIC_REFRESH
*
cyclic_refresh
;
ActiveMap
active_map
;
unsigned
char
gf_frame_index
;
#
if
CONFIG_INTERNAL_STATS
uint64_t
time_compress_data
;
unsigned
int
mode_chosen_counts
[
MAX_MODES
]
;
int
bytes
;
unsigned
int
frame_recode_hits
;
#
endif
#
if
CONFIG_SPEED_STATS
unsigned
int
tx_search_count
;
#
endif
int
droppable
;
FRAME_INFO
frame_info
;
FRAME_INDEX_SET
frame_index_set
;
int
data_alloc_width
;
int
data_alloc_height
;
int
initial_mbs
;
bool
frame_size_related_setup_done
;
int
last_coded_width
;
int
last_coded_height
;
ResizePendingParams
resize_pending_params
;
TileDataEnc
*
tile_data
;
int
allocated_tiles
;
TokenInfo
token_info
;
int
vaq_refresh
;
VarBasedPartitionInfo
vbp_info
;
int
num_frame_recode
;
FrameProbInfo
frame_new_probs
[
NUM_RECODES_PER_FRAME
]
;
int
do_update_frame_probs_txtype
[
NUM_RECODES_PER_FRAME
]
;
int
do_update_frame_probs_obmc
[
NUM_RECODES_PER_FRAME
]
;
int
do_update_frame_probs_warp
[
NUM_RECODES_PER_FRAME
]
;
int
do_update_frame_probs_interpfilter
[
NUM_RECODES_PER_FRAME
]
;
#
if
CONFIG_FPMT_TEST
double
temp_framerate
;
#
endif
double
new_framerate
;
int
do_update_vbr_bits_off_target_fast
;
MultiThreadInfo
mt_info
;
int
existing_fb_idx_to_show
;
int
intrabc_used
;
int
prune_ref_frame_mask
;
AV1LrStruct
lr_ctxt
;
AV1LrPickStruct
pick_lr_ctxt
;
aom_film_grain_table_t
*
film_grain_table
;
#
if
CONFIG_DENOISE
struct
aom_denoise_and_model_t
*
denoise_and_model
;
#
endif
InterpSearchFlags
interp_search_flags
;
int
use_screen_content_tools
;
int
is_screen_content_type
;
#
if
CONFIG_COLLECT_PARTITION_STATS
FramePartitionTimingStats
partition_stats
;
#
endif
#
if
CONFIG_COLLECT_COMPONENT_TIMING
uint64_t
component_time
[
kTimingComponents
]
;
struct
aom_usec_timer
component_timer
[
kTimingComponents
]
;
uint64_t
frame_component_time
[
kTimingComponents
]
;
#
endif
int
frame_header_count
;
int
deltaq_used
;
RefFrameDistanceInfo
ref_frame_dist_info
;
double
*
ssim_rdmult_scaling_factors
;
#
if
CONFIG_TUNE_VMAF
TuneVMAFInfo
vmaf_info
;
#
endif
#
if
CONFIG_TUNE_BUTTERAUGLI
TuneButteraugliInfo
butteraugli_info
;
#
endif
SVC
svc
;
COMPRESSOR_STAGE
compressor_stage
;
FRAME_TYPE
last_frame_type
;
int
num_tg
;
aom_superres_mode
superres_mode
;
FirstPassData
firstpass_data
;
NOISE_ESTIMATE
noise_estimate
;
#
if
CONFIG_AV1_TEMPORAL_DENOISING
AV1_DENOISER
denoiser
;
#
endif
uint8_t
*
consec_zero_mv
;
int
consec_zero_mv_alloc_size
;
BLOCK_SIZE
fp_block_size
;
int
sb_counter
;
size_t
available_bs_size
;
ExtPartController
ext_part_controller
;
MV_STATS
mv_stats
;
int
ref_refresh_index
;
bool
refresh_idx_available
;
int
ref_idx_to_skip
;
#
if
CONFIG_FPMT_TEST
int
wanted_fb
;
#
endif
bool
do_frame_data_update
;
#
if
CONFIG_RD_COMMAND
RD_COMMAND
rd_command
;
#
endif
WeberStats
*
mb_weber_stats
;
int
*
prep_rate_estimates
;
double
*
ext_rate_distribution
;
double
ext_rate_scale
;
BLOCK_SIZE
weber_bsize
;
int64_t
norm_wiener_variance
;
int
*
mb_delta_q
;
bool
is_dropped_frame
;
#
if
CONFIG_BITRATE_ACCURACY
VBR_RATECTRL_INFO
vbr_rc_info
;
#
endif
#
if
CONFIG_RATECTRL_LOG
RATECTRL_LOG
rc_log
;
#
endif
TWO_PASS_FRAME
twopass_frame
;
#
if
CONFIG_THREE_PASS
THIRD_PASS_DEC_CTX
*
third_pass_ctx
;
#
endif
FILE
*
second_pass_log_stream
;
uint64_t
*
src_sad_blk_64x64
;
uint64_t
rec_sse
;
int
use_ducky_encode
;
#
if
!
CONFIG_REALTIME_ONLY
DuckyEncodeInfo
ducky_encode_info
;
#
endif
int
frames_since_last_update
;
unsigned
int
zeromv_skip_thresh_exit_part
[
BLOCK_SIZES_ALL
]
;
bool
alloc_pyramid
;
#
if
CONFIG_SALIENCY_MAP
uint8_t
*
saliency_map
;
double
*
sm_scaling_factor
;
#
endif
int
palette_pixel_num
;
int
scaled_last_source_available
;
aom_roi_map_t
roi
;
}
AV1_COMP
;
typedef
struct
EncodeFrameInput
{
YV12_BUFFER_CONFIG
*
source
;
YV12_BUFFER_CONFIG
*
last_source
;
int64_t
ts_duration
;
}
EncodeFrameInput
;
typedef
struct
EncodeFrameParams
{
int
error_resilient_mode
;
FRAME_TYPE
frame_type
;
int
primary_ref_frame
;
int
order_offset
;
int
show_frame
;
int
refresh_frame_flags
;
int
show_existing_frame
;
int
existing_fb_idx_to_show
;
int
ref_frame_flags
;
int
remapped_ref_idx
[
REF_FRAMES
]
;
RefreshFrameInfo
refresh_frame
;
int
speed
;
}
EncodeFrameParams
;
void
av1_initialize_enc
(
unsigned
int
usage
enum
aom_rc_mode
end_usage
)
;
struct
AV1_COMP
*
av1_create_compressor
(
AV1_PRIMARY
*
ppi
const
AV1EncoderConfig
*
oxcf
BufferPool
*
const
pool
COMPRESSOR_STAGE
stage
int
lap_lag_in_frames
)
;
struct
AV1_PRIMARY
*
av1_create_primary_compressor
(
struct
aom_codec_pkt_list
*
pkt_list_head
int
num_lap_buffers
const
AV1EncoderConfig
*
oxcf
)
;
void
av1_remove_compressor
(
AV1_COMP
*
cpi
)
;
void
av1_remove_primary_compressor
(
AV1_PRIMARY
*
ppi
)
;
#
if
CONFIG_ENTROPY_STATS
void
print_entropy_stats
(
AV1_PRIMARY
*
const
ppi
)
;
#
endif
#
if
CONFIG_INTERNAL_STATS
void
print_internal_stats
(
AV1_PRIMARY
*
ppi
)
;
#
endif
void
av1_change_config_seq
(
AV1_PRIMARY
*
ppi
const
AV1EncoderConfig
*
oxcf
bool
*
sb_size_changed
)
;
void
av1_change_config
(
AV1_COMP
*
cpi
const
AV1EncoderConfig
*
oxcf
bool
sb_size_changed
)
;
aom_codec_err_t
av1_check_initial_width
(
AV1_COMP
*
cpi
int
use_highbitdepth
int
subsampling_x
int
subsampling_y
)
;
void
av1_post_encode_updates
(
AV1_COMP
*
const
cpi
const
AV1_COMP_DATA
*
const
cpi_data
)
;
void
av1_release_scaled_references_fpmt
(
AV1_COMP
*
cpi
)
;
void
av1_decrement_ref_counts_fpmt
(
BufferPool
*
buffer_pool
int
ref_buffers_used_map
)
;
void
av1_init_sc_decisions
(
AV1_PRIMARY
*
const
ppi
)
;
AV1_COMP
*
av1_get_parallel_frame_enc_data
(
AV1_PRIMARY
*
const
ppi
AV1_COMP_DATA
*
const
first_cpi_data
)
;
int
av1_init_parallel_frame_context
(
const
AV1_COMP_DATA
*
const
first_cpi_data
AV1_PRIMARY
*
const
ppi
int
*
ref_buffers_used_map
)
;
int
av1_receive_raw_frame
(
AV1_COMP
*
cpi
aom_enc_frame_flags_t
frame_flags
const
YV12_BUFFER_CONFIG
*
sd
int64_t
time_stamp
int64_t
end_time_stamp
)
;
int
av1_get_compressed_data
(
AV1_COMP
*
cpi
AV1_COMP_DATA
*
const
cpi_data
)
;
int
av1_encode
(
AV1_COMP
*
const
cpi
uint8_t
*
const
dest
size_t
dest_size
const
EncodeFrameInput
*
const
frame_input
const
EncodeFrameParams
*
const
frame_params
size_t
*
const
frame_size
)
;
int
av1_get_preview_raw_frame
(
AV1_COMP
*
cpi
YV12_BUFFER_CONFIG
*
dest
)
;
int
av1_get_last_show_frame
(
AV1_COMP
*
cpi
YV12_BUFFER_CONFIG
*
frame
)
;
aom_codec_err_t
av1_copy_new_frame_enc
(
AV1_COMMON
*
cm
YV12_BUFFER_CONFIG
*
new_frame
YV12_BUFFER_CONFIG
*
sd
)
;
int
av1_use_as_reference
(
int
*
ext_ref_frame_flags
int
ref_frame_flags
)
;
int
av1_copy_reference_enc
(
AV1_COMP
*
cpi
int
idx
YV12_BUFFER_CONFIG
*
sd
)
;
int
av1_set_reference_enc
(
AV1_COMP
*
cpi
int
idx
YV12_BUFFER_CONFIG
*
sd
)
;
void
av1_set_frame_size
(
AV1_COMP
*
cpi
int
width
int
height
)
;
void
av1_set_mv_search_params
(
AV1_COMP
*
cpi
)
;
int
av1_set_roi_map
(
AV1_COMP
*
cpi
unsigned
char
*
map
unsigned
int
rows
unsigned
int
cols
int
delta_q
[
8
]
int
delta_lf
[
8
]
int
skip
[
8
]
int
ref_frame
[
8
]
)
;
int
av1_set_active_map
(
AV1_COMP
*
cpi
unsigned
char
*
map
int
rows
int
cols
)
;
int
av1_get_active_map
(
AV1_COMP
*
cpi
unsigned
char
*
map
int
rows
int
cols
)
;
int
av1_set_internal_size
(
AV1EncoderConfig
*
const
oxcf
ResizePendingParams
*
resize_pending_params
AOM_SCALING_MODE
horiz_mode
AOM_SCALING_MODE
vert_mode
)
;
int
av1_get_quantizer
(
struct
AV1_COMP
*
cpi
)
;
int
av1_convert_sect5obus_to_annexb
(
uint8_t
*
buffer
size_t
buffer_size
size_t
*
input_size
)
;
void
av1_alloc_mb_wiener_var_pred_buf
(
AV1_COMMON
*
cm
ThreadData
*
td
)
;
void
av1_dealloc_mb_wiener_var_pred_buf
(
ThreadData
*
td
)
;
uint8_t
av1_find_dominant_value
(
const
uint8_t
*
src
int
stride
int
rows
int
cols
)
;
void
av1_dilate_block
(
const
uint8_t
*
src
int
src_stride
uint8_t
*
dilated
int
dilated_stride
int
rows
int
cols
)
;
void
av1_set_screen_content_options
(
struct
AV1_COMP
*
cpi
FeatureFlags
*
features
)
;
void
av1_update_frame_size
(
AV1_COMP
*
cpi
)
;
void
av1_set_svc_seq_params
(
AV1_PRIMARY
*
const
ppi
)
;
typedef
struct
{
int
pyr_level
;
int
disp_order
;
}
RefFrameMapPair
;
static
inline
void
init_ref_map_pair
(
AV1_COMP
*
cpi
RefFrameMapPair
ref_frame_map_pairs
[
REF_FRAMES
]
)
{
if
(
cpi
-
>
ppi
-
>
gf_group
.
update_type
[
cpi
-
>
gf_frame_index
]
=
=
KF_UPDATE
)
{
memset
(
ref_frame_map_pairs
-
1
sizeof
(
*
ref_frame_map_pairs
)
*
REF_FRAMES
)
;
return
;
}
memset
(
ref_frame_map_pairs
0
sizeof
(
*
ref_frame_map_pairs
)
*
REF_FRAMES
)
;
for
(
int
map_idx
=
0
;
map_idx
<
REF_FRAMES
;
map_idx
+
+
)
{
const
RefCntBuffer
*
const
buf
=
cpi
-
>
common
.
ref_frame_map
[
map_idx
]
;
if
(
ref_frame_map_pairs
[
map_idx
]
.
disp_order
=
=
-
1
)
continue
;
if
(
buf
=
=
NULL
)
{
ref_frame_map_pairs
[
map_idx
]
.
disp_order
=
-
1
;
ref_frame_map_pairs
[
map_idx
]
.
pyr_level
=
-
1
;
continue
;
}
else
if
(
buf
-
>
ref_count
>
1
)
{
for
(
int
idx2
=
map_idx
+
1
;
idx2
<
REF_FRAMES
;
+
+
idx2
)
{
const
RefCntBuffer
*
const
buf2
=
cpi
-
>
common
.
ref_frame_map
[
idx2
]
;
if
(
buf2
=
=
buf
)
{
ref_frame_map_pairs
[
idx2
]
.
disp_order
=
-
1
;
ref_frame_map_pairs
[
idx2
]
.
pyr_level
=
-
1
;
}
}
}
ref_frame_map_pairs
[
map_idx
]
.
disp_order
=
(
int
)
buf
-
>
display_order_hint
;
ref_frame_map_pairs
[
map_idx
]
.
pyr_level
=
buf
-
>
pyramid_level
;
}
}
#
if
CONFIG_FPMT_TEST
static
inline
void
calc_frame_data_update_flag
(
GF_GROUP
*
const
gf_group
int
gf_frame_index
bool
*
const
do_frame_data_update
)
{
*
do_frame_data_update
=
true
;
if
(
gf_group
-
>
frame_parallel_level
[
gf_frame_index
]
=
=
1
)
{
*
do_frame_data_update
=
false
;
}
else
if
(
gf_group
-
>
frame_parallel_level
[
gf_frame_index
]
=
=
2
)
{
for
(
int
i
=
gf_frame_index
+
1
;
i
<
gf_group
-
>
size
;
i
+
+
)
{
if
(
(
gf_group
-
>
frame_parallel_level
[
i
]
=
=
0
&
&
(
gf_group
-
>
update_type
[
i
]
=
=
ARF_UPDATE
|
|
gf_group
-
>
update_type
[
i
]
=
=
INTNL_ARF_UPDATE
)
)
|
|
gf_group
-
>
frame_parallel_level
[
i
]
=
=
1
)
{
break
;
}
else
if
(
gf_group
-
>
frame_parallel_level
[
i
]
=
=
2
)
{
*
do_frame_data_update
=
false
;
break
;
}
}
}
}
#
endif
#
define
TICKS_PER_SEC
10000000LL
static
inline
int64_t
timebase_units_to_ticks
(
const
aom_rational64_t
*
timestamp_ratio
int64_t
n
)
{
return
n
*
timestamp_ratio
-
>
num
/
timestamp_ratio
-
>
den
;
}
static
inline
int64_t
ticks_to_timebase_units
(
const
aom_rational64_t
*
timestamp_ratio
int64_t
n
)
{
int64_t
round
=
timestamp_ratio
-
>
num
/
2
;
if
(
round
>
0
)
-
-
round
;
return
(
n
*
timestamp_ratio
-
>
den
+
round
)
/
timestamp_ratio
-
>
num
;
}
static
inline
int
frame_is_kf_gf_arf
(
const
AV1_COMP
*
cpi
)
{
const
GF_GROUP
*
const
gf_group
=
&
cpi
-
>
ppi
-
>
gf_group
;
const
FRAME_UPDATE_TYPE
update_type
=
gf_group
-
>
update_type
[
cpi
-
>
gf_frame_index
]
;
return
frame_is_intra_only
(
&
cpi
-
>
common
)
|
|
update_type
=
=
ARF_UPDATE
|
|
update_type
=
=
GF_UPDATE
;
}
static
inline
int
av1_use_hash_me
(
const
AV1_COMP
*
const
cpi
)
{
return
(
cpi
-
>
common
.
features
.
allow_screen_content_tools
&
&
cpi
-
>
common
.
features
.
allow_intrabc
&
&
frame_is_intra_only
(
&
cpi
-
>
common
)
)
;
}
static
inline
const
YV12_BUFFER_CONFIG
*
get_ref_frame_yv12_buf
(
const
AV1_COMMON
*
const
cm
MV_REFERENCE_FRAME
ref_frame
)
{
const
RefCntBuffer
*
const
buf
=
get_ref_frame_buf
(
cm
ref_frame
)
;
return
buf
!
=
NULL
?
&
buf
-
>
buf
:
NULL
;
}
static
inline
void
alloc_frame_mvs
(
AV1_COMMON
*
const
cm
RefCntBuffer
*
buf
)
{
assert
(
buf
!
=
NULL
)
;
ensure_mv_buffer
(
buf
cm
)
;
buf
-
>
width
=
cm
-
>
width
;
buf
-
>
height
=
cm
-
>
height
;
}
static
inline
unsigned
int
allocated_tokens
(
const
TileInfo
*
tile
int
sb_size_log2
int
num_planes
)
{
int
tile_mb_rows
=
ROUND_POWER_OF_TWO
(
tile
-
>
mi_row_end
-
tile
-
>
mi_row_start
2
)
;
int
tile_mb_cols
=
ROUND_POWER_OF_TWO
(
tile
-
>
mi_col_end
-
tile
-
>
mi_col_start
2
)
;
return
get_token_alloc
(
tile_mb_rows
tile_mb_cols
sb_size_log2
num_planes
)
;
}
static
inline
void
get_start_tok
(
AV1_COMP
*
cpi
int
tile_row
int
tile_col
int
mi_row
TokenExtra
*
*
tok
int
sb_size_log2
int
num_planes
)
{
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
const
int
tile_cols
=
cm
-
>
tiles
.
cols
;
TileDataEnc
*
this_tile
=
&
cpi
-
>
tile_data
[
tile_row
*
tile_cols
+
tile_col
]
;
const
TileInfo
*
const
tile_info
=
&
this_tile
-
>
tile_info
;
const
int
tile_mb_cols
=
(
tile_info
-
>
mi_col_end
-
tile_info
-
>
mi_col_start
+
2
)
>
>
2
;
const
int
tile_mb_row
=
(
mi_row
-
tile_info
-
>
mi_row_start
+
2
)
>
>
2
;
*
tok
=
cpi
-
>
token_info
.
tile_tok
[
tile_row
]
[
tile_col
]
+
get_token_alloc
(
tile_mb_row
tile_mb_cols
sb_size_log2
num_planes
)
;
}
void
av1_apply_encoding_flags
(
AV1_COMP
*
cpi
aom_enc_frame_flags_t
flags
)
;
#
define
ALT_MIN_LAG
3
static
inline
int
is_altref_enabled
(
int
lag_in_frames
bool
enable_auto_arf
)
{
return
lag_in_frames
>
=
ALT_MIN_LAG
&
&
enable_auto_arf
;
}
static
inline
int
can_disable_altref
(
const
GFConfig
*
gf_cfg
)
{
return
is_altref_enabled
(
gf_cfg
-
>
lag_in_frames
gf_cfg
-
>
enable_auto_arf
)
&
&
(
gf_cfg
-
>
gf_min_pyr_height
=
=
0
)
;
}
static
inline
int
get_num_blocks
(
const
int
frame_length
const
int
mb_length
)
{
return
(
frame_length
+
mb_length
-
1
)
/
mb_length
;
}
static
inline
int
is_stat_generation_stage
(
const
AV1_COMP
*
const
cpi
)
{
assert
(
IMPLIES
(
cpi
-
>
compressor_stage
=
=
LAP_STAGE
cpi
-
>
oxcf
.
pass
=
=
AOM_RC_ONE_PASS
&
&
cpi
-
>
ppi
-
>
lap_enabled
)
)
;
return
(
cpi
-
>
oxcf
.
pass
=
=
AOM_RC_FIRST_PASS
|
|
(
cpi
-
>
compressor_stage
=
=
LAP_STAGE
)
)
;
}
static
inline
int
is_stat_consumption_stage_twopass
(
const
AV1_COMP
*
const
cpi
)
{
return
(
cpi
-
>
oxcf
.
pass
>
=
AOM_RC_SECOND_PASS
)
;
}
static
inline
int
is_stat_consumption_stage
(
const
AV1_COMP
*
const
cpi
)
{
return
(
is_stat_consumption_stage_twopass
(
cpi
)
|
|
(
cpi
-
>
oxcf
.
pass
=
=
AOM_RC_ONE_PASS
&
&
(
cpi
-
>
compressor_stage
=
=
ENCODE_STAGE
)
&
&
cpi
-
>
ppi
-
>
lap_enabled
)
)
;
}
static
inline
bool
av1_need_dv_costs
(
const
AV1_COMP
*
const
cpi
)
{
return
!
cpi
-
>
sf
.
rt_sf
.
use_nonrd_pick_mode
&
&
av1_allow_intrabc
(
&
cpi
-
>
common
)
&
&
!
is_stat_generation_stage
(
cpi
)
;
}
static
inline
int
has_no_stats_stage
(
const
AV1_COMP
*
const
cpi
)
{
assert
(
IMPLIES
(
!
cpi
-
>
ppi
-
>
lap_enabled
cpi
-
>
compressor_stage
=
=
ENCODE_STAGE
)
)
;
return
(
cpi
-
>
oxcf
.
pass
=
=
AOM_RC_ONE_PASS
&
&
!
cpi
-
>
ppi
-
>
lap_enabled
)
;
}
static
inline
int
is_one_pass_rt_params
(
const
AV1_COMP
*
cpi
)
{
return
has_no_stats_stage
(
cpi
)
&
&
cpi
-
>
oxcf
.
gf_cfg
.
lag_in_frames
=
=
0
&
&
(
cpi
-
>
oxcf
.
mode
=
=
REALTIME
|
|
cpi
-
>
svc
.
number_spatial_layers
>
1
)
;
}
static
inline
int
use_rtc_reference_structure_one_layer
(
const
AV1_COMP
*
cpi
)
{
return
is_one_pass_rt_params
(
cpi
)
&
&
cpi
-
>
ppi
-
>
number_spatial_layers
=
=
1
&
&
cpi
-
>
ppi
-
>
number_temporal_layers
=
=
1
&
&
!
cpi
-
>
ppi
-
>
rtc_ref
.
set_ref_frame_config
;
}
static
inline
int
allow_postencode_drop_rtc
(
const
AV1_COMP
*
cpi
)
{
const
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
return
is_one_pass_rt_params
(
cpi
)
&
&
cpi
-
>
oxcf
.
rc_cfg
.
mode
=
=
AOM_CBR
&
&
cpi
-
>
oxcf
.
rc_cfg
.
drop_frames_water_mark
>
0
&
&
!
cpi
-
>
rc
.
rtc_external_ratectrl
&
&
!
frame_is_intra_only
(
cm
)
&
&
cpi
-
>
svc
.
spatial_layer_id
=
=
0
;
}
static
inline
int
get_stats_buf_size
(
int
num_lap_buffer
int
num_lag_buffer
)
{
return
(
num_lap_buffer
>
0
?
num_lap_buffer
+
1
:
num_lag_buffer
)
;
}
static
inline
void
set_ref_ptrs
(
const
AV1_COMMON
*
cm
MACROBLOCKD
*
xd
MV_REFERENCE_FRAME
ref0
MV_REFERENCE_FRAME
ref1
)
{
xd
-
>
block_ref_scale_factors
[
0
]
=
get_ref_scale_factors_const
(
cm
ref0
>
=
LAST_FRAME
?
ref0
:
1
)
;
xd
-
>
block_ref_scale_factors
[
1
]
=
get_ref_scale_factors_const
(
cm
ref1
>
=
LAST_FRAME
?
ref1
:
1
)
;
}
static
inline
int
get_chessboard_index
(
int
frame_index
)
{
return
frame_index
&
0x1
;
}
static
inline
const
int
*
cond_cost_list_const
(
const
struct
AV1_COMP
*
cpi
const
int
*
cost_list
)
{
const
int
use_cost_list
=
cpi
-
>
sf
.
mv_sf
.
subpel_search_method
!
=
SUBPEL_TREE
&
&
cpi
-
>
sf
.
mv_sf
.
use_fullpel_costlist
;
return
use_cost_list
?
cost_list
:
NULL
;
}
static
inline
int
*
cond_cost_list
(
const
struct
AV1_COMP
*
cpi
int
*
cost_list
)
{
const
int
use_cost_list
=
cpi
-
>
sf
.
mv_sf
.
subpel_search_method
!
=
SUBPEL_TREE
&
&
cpi
-
>
sf
.
mv_sf
.
use_fullpel_costlist
;
return
use_cost_list
?
cost_list
:
NULL
;
}
double
av1_get_compression_ratio
(
const
AV1_COMMON
*
const
cm
size_t
encoded_frame_size
)
;
void
av1_new_framerate
(
AV1_COMP
*
cpi
double
framerate
)
;
void
av1_setup_frame_size
(
AV1_COMP
*
cpi
)
;
#
define
LAYER_IDS_TO_IDX
(
sl
tl
num_tl
)
(
(
sl
)
*
(
num_tl
)
+
(
tl
)
)
static
inline
int
av1_resize_scaled
(
const
AV1_COMMON
*
cm
)
{
return
cm
-
>
superres_upscaled_width
!
=
cm
-
>
render_width
|
|
cm
-
>
superres_upscaled_height
!
=
cm
-
>
render_height
;
}
static
inline
int
av1_frame_scaled
(
const
AV1_COMMON
*
cm
)
{
return
av1_superres_scaled
(
cm
)
|
|
av1_resize_scaled
(
cm
)
;
}
static
inline
int
encode_show_existing_frame
(
const
AV1_COMMON
*
cm
)
{
return
cm
-
>
show_existing_frame
&
&
(
!
cm
-
>
features
.
error_resilient_mode
|
|
cm
-
>
current_frame
.
frame_type
=
=
KEY_FRAME
)
;
}
static
inline
int
get_mi_ext_idx
(
const
int
mi_row
const
int
mi_col
const
BLOCK_SIZE
mi_alloc_bsize
const
int
mbmi_ext_stride
)
{
const
int
mi_ext_size_1d
=
mi_size_wide
[
mi_alloc_bsize
]
;
const
int
mi_ext_row
=
mi_row
/
mi_ext_size_1d
;
const
int
mi_ext_col
=
mi_col
/
mi_ext_size_1d
;
return
mi_ext_row
*
mbmi_ext_stride
+
mi_ext_col
;
}
static
inline
void
set_mode_info_offsets
(
const
CommonModeInfoParams
*
const
mi_params
const
MBMIExtFrameBufferInfo
*
const
mbmi_ext_info
MACROBLOCK
*
const
x
MACROBLOCKD
*
const
xd
int
mi_row
int
mi_col
)
{
set_mi_offsets
(
mi_params
xd
mi_row
mi_col
)
;
const
int
ext_idx
=
get_mi_ext_idx
(
mi_row
mi_col
mi_params
-
>
mi_alloc_bsize
mbmi_ext_info
-
>
stride
)
;
x
-
>
mbmi_ext_frame
=
mbmi_ext_info
-
>
frame_base
+
ext_idx
;
}
static
inline
BLOCK_SIZE
find_partition_size
(
BLOCK_SIZE
bsize
int
rows_left
int
cols_left
int
*
bh
int
*
bw
)
{
int
int_size
=
(
int
)
bsize
;
if
(
rows_left
<
=
0
|
|
cols_left
<
=
0
)
{
return
AOMMIN
(
bsize
BLOCK_8X8
)
;
}
else
{
for
(
;
int_size
>
0
;
int_size
-
=
3
)
{
*
bh
=
mi_size_high
[
int_size
]
;
*
bw
=
mi_size_wide
[
int_size
]
;
if
(
(
*
bh
<
=
rows_left
)
&
&
(
*
bw
<
=
cols_left
)
)
{
break
;
}
}
}
return
(
BLOCK_SIZE
)
int_size
;
}
static
const
uint8_t
av1_ref_frame_flag_list
[
REF_FRAMES
]
=
{
0
AOM_LAST_FLAG
AOM_LAST2_FLAG
AOM_LAST3_FLAG
AOM_GOLD_FLAG
AOM_BWD_FLAG
AOM_ALT2_FLAG
AOM_ALT_FLAG
}
;
static
const
MV_REFERENCE_FRAME
disable_order
[
]
=
{
LAST3_FRAME
LAST2_FRAME
ALTREF2_FRAME
BWDREF_FRAME
}
;
static
const
MV_REFERENCE_FRAME
ref_frame_priority_order
[
INTER_REFS_PER_FRAME
]
=
{
LAST_FRAME
ALTREF_FRAME
BWDREF_FRAME
GOLDEN_FRAME
ALTREF2_FRAME
LAST2_FRAME
LAST3_FRAME
}
;
static
inline
int
get_ref_frame_flags
(
const
SPEED_FEATURES
*
const
sf
const
int
use_one_pass_rt_params
const
YV12_BUFFER_CONFIG
*
*
ref_frames
const
int
ext_ref_frame_flags
)
{
int
flags
=
ext_ref_frame_flags
;
for
(
int
i
=
1
;
i
<
INTER_REFS_PER_FRAME
;
+
+
i
)
{
const
YV12_BUFFER_CONFIG
*
const
this_ref
=
ref_frames
[
i
]
;
int
index
=
(
use_one_pass_rt_params
&
&
ref_frame_priority_order
[
i
]
=
=
GOLDEN_FRAME
)
?
(
1
+
sf
-
>
rt_sf
.
use_nonrd_altref_frame
)
:
i
;
for
(
int
j
=
0
;
j
<
index
;
+
+
j
)
{
if
(
this_ref
=
=
ref_frames
[
j
]
&
&
(
flags
&
(
1
<
<
(
ref_frame_priority_order
[
j
]
-
1
)
)
)
)
{
flags
&
=
~
(
1
<
<
(
ref_frame_priority_order
[
i
]
-
1
)
)
;
break
;
}
}
}
return
flags
;
}
aom_fixed_buf_t
*
av1_get_global_headers
(
AV1_PRIMARY
*
ppi
)
;
#
define
MAX_GFUBOOST_FACTOR
10
.
0
#
define
MIN_GFUBOOST_FACTOR
4
.
0
static
inline
int
is_frame_tpl_eligible
(
const
GF_GROUP
*
const
gf_group
uint8_t
index
)
{
const
FRAME_UPDATE_TYPE
update_type
=
gf_group
-
>
update_type
[
index
]
;
return
update_type
=
=
ARF_UPDATE
|
|
update_type
=
=
GF_UPDATE
|
|
update_type
=
=
KF_UPDATE
;
}
static
inline
int
is_frame_eligible_for_ref_pruning
(
const
GF_GROUP
*
gf_group
int
selective_ref_frame
int
prune_ref_frames
int
gf_index
)
{
return
(
selective_ref_frame
>
0
)
&
&
(
prune_ref_frames
>
0
)
&
&
!
is_frame_tpl_eligible
(
gf_group
gf_index
)
;
}
static
inline
FRAME_UPDATE_TYPE
get_frame_update_type
(
const
GF_GROUP
*
gf_group
int
gf_frame_index
)
{
return
gf_group
-
>
update_type
[
gf_frame_index
]
;
}
static
inline
int
av1_pixels_to_mi
(
int
pixels
)
{
return
ALIGN_POWER_OF_TWO
(
pixels
3
)
>
>
MI_SIZE_LOG2
;
}
static
inline
int
is_psnr_calc_enabled
(
const
AV1_COMP
*
cpi
)
{
const
AV1_COMMON
*
const
cm
=
&
cpi
-
>
common
;
return
cpi
-
>
ppi
-
>
b_calculate_psnr
&
&
!
is_stat_generation_stage
(
cpi
)
&
&
cm
-
>
show_frame
&
&
!
cpi
-
>
is_dropped_frame
;
}
static
inline
int
is_frame_resize_pending
(
const
AV1_COMP
*
const
cpi
)
{
const
ResizePendingParams
*
const
resize_pending_params
=
&
cpi
-
>
resize_pending_params
;
return
(
resize_pending_params
-
>
width
&
&
resize_pending_params
-
>
height
&
&
(
cpi
-
>
common
.
width
!
=
resize_pending_params
-
>
width
|
|
cpi
-
>
common
.
height
!
=
resize_pending_params
-
>
height
)
)
;
}
static
inline
int
is_loopfilter_used
(
const
AV1_COMMON
*
const
cm
)
{
return
!
cm
-
>
features
.
coded_lossless
&
&
!
cm
-
>
tiles
.
large_scale
;
}
static
inline
int
is_cdef_used
(
const
AV1_COMMON
*
const
cm
)
{
return
cm
-
>
seq_params
-
>
enable_cdef
&
&
!
cm
-
>
features
.
coded_lossless
&
&
!
cm
-
>
tiles
.
large_scale
;
}
static
inline
int
is_restoration_used
(
const
AV1_COMMON
*
const
cm
)
{
return
cm
-
>
seq_params
-
>
enable_restoration
&
&
!
cm
-
>
features
.
all_lossless
&
&
!
cm
-
>
tiles
.
large_scale
;
}
static
inline
unsigned
int
derive_skip_apply_postproc_filters
(
const
AV1_COMP
*
cpi
int
use_loopfilter
int
use_cdef
int
use_superres
int
use_restoration
)
{
if
(
cpi
-
>
ppi
-
>
rtc_ref
.
non_reference_frame
)
return
(
SKIP_APPLY_LOOPFILTER
|
SKIP_APPLY_CDEF
)
;
if
(
!
cpi
-
>
oxcf
.
algo_cfg
.
skip_postproc_filtering
|
|
cpi
-
>
ppi
-
>
b_calculate_psnr
)
return
0
;
assert
(
cpi
-
>
oxcf
.
mode
=
=
ALLINTRA
)
;
if
(
use_restoration
)
return
SKIP_APPLY_RESTORATION
;
if
(
use_superres
)
return
SKIP_APPLY_SUPERRES
;
if
(
use_cdef
)
{
return
(
cpi
-
>
sf
.
lpf_sf
.
cdef_pick_method
=
=
CDEF_PICK_FROM_Q
&
&
use_loopfilter
)
?
(
SKIP_APPLY_LOOPFILTER
|
SKIP_APPLY_CDEF
)
:
SKIP_APPLY_CDEF
;
}
if
(
use_loopfilter
)
return
SKIP_APPLY_LOOPFILTER
;
return
0
;
}
static
inline
void
set_postproc_filter_default_params
(
AV1_COMMON
*
cm
)
{
struct
loopfilter
*
const
lf
=
&
cm
-
>
lf
;
CdefInfo
*
const
cdef_info
=
&
cm
-
>
cdef_info
;
RestorationInfo
*
const
rst_info
=
cm
-
>
rst_info
;
lf
-
>
filter_level
[
0
]
=
0
;
lf
-
>
filter_level
[
1
]
=
0
;
lf
-
>
backup_filter_level
[
0
]
=
0
;
lf
-
>
backup_filter_level
[
1
]
=
0
;
cdef_info
-
>
cdef_bits
=
0
;
cdef_info
-
>
cdef_strengths
[
0
]
=
0
;
cdef_info
-
>
nb_cdef_strengths
=
1
;
cdef_info
-
>
cdef_uv_strengths
[
0
]
=
0
;
rst_info
[
0
]
.
frame_restoration_type
=
RESTORE_NONE
;
rst_info
[
1
]
.
frame_restoration_type
=
RESTORE_NONE
;
rst_info
[
2
]
.
frame_restoration_type
=
RESTORE_NONE
;
}
static
inline
int
is_inter_tx_size_search_level_one
(
const
TX_SPEED_FEATURES
*
tx_sf
)
{
return
(
tx_sf
-
>
inter_tx_size_search_init_depth_rect
>
=
1
&
&
tx_sf
-
>
inter_tx_size_search_init_depth_sqr
>
=
1
)
;
}
static
inline
int
get_lpf_opt_level
(
const
SPEED_FEATURES
*
sf
)
{
int
lpf_opt_level
=
0
;
if
(
is_inter_tx_size_search_level_one
(
&
sf
-
>
tx_sf
)
)
lpf_opt_level
=
(
sf
-
>
lpf_sf
.
lpf_pick
=
=
LPF_PICK_FROM_Q
)
?
2
:
1
;
return
lpf_opt_level
;
}
static
inline
bool
is_switchable_motion_mode_allowed
(
bool
allow_warped_motion
bool
enable_obmc
)
{
return
(
allow_warped_motion
|
|
enable_obmc
)
;
}
#
if
CONFIG_AV1_TEMPORAL_DENOISING
static
inline
int
denoise_svc
(
const
struct
AV1_COMP
*
const
cpi
)
{
return
(
!
cpi
-
>
ppi
-
>
use_svc
|
|
(
cpi
-
>
ppi
-
>
use_svc
&
&
cpi
-
>
svc
.
spatial_layer_id
>
=
cpi
-
>
svc
.
first_layer_denoise
)
)
;
}
#
endif
#
if
CONFIG_COLLECT_PARTITION_STATS
=
=
2
static
inline
void
av1_print_fr_partition_timing_stats
(
const
FramePartitionTimingStats
*
part_stats
const
char
*
filename
)
{
FILE
*
f
=
fopen
(
filename
"
w
"
)
;
if
(
!
f
)
{
return
;
}
fprintf
(
f
"
bsize
redo
"
)
;
for
(
int
part
=
0
;
part
<
EXT_PARTITION_TYPES
;
part
+
+
)
{
fprintf
(
f
"
decision_
%
d
"
part
)
;
}
for
(
int
part
=
0
;
part
<
EXT_PARTITION_TYPES
;
part
+
+
)
{
fprintf
(
f
"
attempt_
%
d
"
part
)
;
}
for
(
int
part
=
0
;
part
<
EXT_PARTITION_TYPES
;
part
+
+
)
{
fprintf
(
f
"
time_
%
d
"
part
)
;
}
fprintf
(
f
"
\
n
"
)
;
static
const
int
bsizes
[
6
]
=
{
128
64
32
16
8
4
}
;
for
(
int
bsize_idx
=
0
;
bsize_idx
<
6
;
bsize_idx
+
+
)
{
fprintf
(
f
"
%
d
%
d
"
bsizes
[
bsize_idx
]
part_stats
-
>
partition_redo
)
;
for
(
int
part
=
0
;
part
<
EXT_PARTITION_TYPES
;
part
+
+
)
{
fprintf
(
f
"
%
d
"
part_stats
-
>
partition_decisions
[
bsize_idx
]
[
part
]
)
;
}
for
(
int
part
=
0
;
part
<
EXT_PARTITION_TYPES
;
part
+
+
)
{
fprintf
(
f
"
%
d
"
part_stats
-
>
partition_attempts
[
bsize_idx
]
[
part
]
)
;
}
for
(
int
part
=
0
;
part
<
EXT_PARTITION_TYPES
;
part
+
+
)
{
fprintf
(
f
"
%
ld
"
part_stats
-
>
partition_times
[
bsize_idx
]
[
part
]
)
;
}
fprintf
(
f
"
\
n
"
)
;
}
fclose
(
f
)
;
}
#
endif
#
if
CONFIG_COLLECT_PARTITION_STATS
static
inline
int
av1_get_bsize_idx_for_part_stats
(
BLOCK_SIZE
bsize
)
{
assert
(
bsize
=
=
BLOCK_128X128
|
|
bsize
=
=
BLOCK_64X64
|
|
bsize
=
=
BLOCK_32X32
|
|
bsize
=
=
BLOCK_16X16
|
|
bsize
=
=
BLOCK_8X8
|
|
bsize
=
=
BLOCK_4X4
)
;
switch
(
bsize
)
{
case
BLOCK_128X128
:
return
0
;
case
BLOCK_64X64
:
return
1
;
case
BLOCK_32X32
:
return
2
;
case
BLOCK_16X16
:
return
3
;
case
BLOCK_8X8
:
return
4
;
case
BLOCK_4X4
:
return
5
;
default
:
assert
(
0
&
&
"
Invalid
bsize
for
partition_stats
.
"
)
;
return
-
1
;
}
}
#
endif
#
if
CONFIG_COLLECT_COMPONENT_TIMING
static
inline
void
start_timing
(
AV1_COMP
*
cpi
int
component
)
{
aom_usec_timer_start
(
&
cpi
-
>
component_timer
[
component
]
)
;
}
static
inline
void
end_timing
(
AV1_COMP
*
cpi
int
component
)
{
aom_usec_timer_mark
(
&
cpi
-
>
component_timer
[
component
]
)
;
cpi
-
>
frame_component_time
[
component
]
+
=
aom_usec_timer_elapsed
(
&
cpi
-
>
component_timer
[
component
]
)
;
}
static
inline
char
const
*
get_frame_type_enum
(
int
type
)
{
switch
(
type
)
{
case
0
:
return
"
KEY_FRAME
"
;
case
1
:
return
"
INTER_FRAME
"
;
case
2
:
return
"
INTRA_ONLY_FRAME
"
;
case
3
:
return
"
S_FRAME
"
;
default
:
assert
(
0
)
;
}
return
"
error
"
;
}
#
endif
#
ifdef
__cplusplus
}
#
endif
#
endif
