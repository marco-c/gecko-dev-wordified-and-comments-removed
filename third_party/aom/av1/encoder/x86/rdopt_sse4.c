#
include
<
assert
.
h
>
#
include
<
smmintrin
.
h
>
#
include
"
aom_dsp
/
x86
/
synonyms
.
h
"
#
include
"
config
/
av1_rtcd
.
h
"
#
include
"
av1
/
encoder
/
rdopt
.
h
"
INLINE
static
void
horver_correlation_4x4
(
const
int16_t
*
diff
int
stride
__m128i
*
xy_sum_32
__m128i
*
xz_sum_32
__m128i
*
x_sum_32
__m128i
*
x2_sum_32
)
{
const
__m128i
pixelsa
=
xx_loadu_2x64
(
&
diff
[
0
*
stride
]
&
diff
[
2
*
stride
]
)
;
const
__m128i
pixelsb
=
xx_loadu_2x64
(
&
diff
[
1
*
stride
]
&
diff
[
3
*
stride
]
)
;
const
__m128i
slli_a
=
_mm_slli_epi64
(
pixelsa
16
)
;
const
__m128i
slli_b
=
_mm_slli_epi64
(
pixelsb
16
)
;
const
__m128i
xy_madd_a
=
_mm_madd_epi16
(
pixelsa
slli_a
)
;
const
__m128i
xy_madd_b
=
_mm_madd_epi16
(
pixelsb
slli_b
)
;
const
__m128i
xy32
=
_mm_hadd_epi32
(
xy_madd_b
xy_madd_a
)
;
*
xy_sum_32
=
_mm_add_epi32
(
*
xy_sum_32
xy32
)
;
const
__m128i
xz_madd_a
=
_mm_madd_epi16
(
slli_a
slli_b
)
;
const
__m128i
swap_b
=
_mm_srli_si128
(
slli_b
8
)
;
const
__m128i
xz_madd_b
=
_mm_madd_epi16
(
slli_a
swap_b
)
;
const
__m128i
xz32
=
_mm_hadd_epi32
(
xz_madd_b
xz_madd_a
)
;
*
xz_sum_32
=
_mm_add_epi32
(
*
xz_sum_32
xz32
)
;
const
__m128i
sum_slli_a
=
_mm_hadd_epi16
(
slli_a
slli_a
)
;
const
__m128i
sum_slli_a32
=
_mm_cvtepi16_epi32
(
sum_slli_a
)
;
const
__m128i
swap_b32
=
_mm_cvtepi16_epi32
(
swap_b
)
;
*
x_sum_32
=
_mm_add_epi32
(
*
x_sum_32
sum_slli_a32
)
;
*
x_sum_32
=
_mm_add_epi32
(
*
x_sum_32
swap_b32
)
;
const
__m128i
slli_a_2
=
_mm_madd_epi16
(
slli_a
slli_a
)
;
const
__m128i
swap_b_2
=
_mm_madd_epi16
(
swap_b
swap_b
)
;
const
__m128i
sum2
=
_mm_hadd_epi32
(
slli_a_2
swap_b_2
)
;
*
x2_sum_32
=
_mm_add_epi32
(
*
x2_sum_32
sum2
)
;
}
void
av1_get_horver_correlation_full_sse4_1
(
const
int16_t
*
diff
int
stride
int
width
int
height
float
*
hcorr
float
*
vcorr
)
{
int64_t
xy_sum
=
0
xz_sum
=
0
;
int64_t
x_sum
=
0
x2_sum
=
0
;
int32_t
xy_tmp
[
4
]
=
{
0
}
xz_tmp
[
4
]
=
{
0
}
;
int32_t
x_tmp
[
4
]
=
{
0
}
x2_tmp
[
4
]
=
{
0
}
;
__m128i
xy_sum_32
=
_mm_setzero_si128
(
)
;
__m128i
xz_sum_32
=
_mm_setzero_si128
(
)
;
__m128i
x_sum_32
=
_mm_setzero_si128
(
)
;
__m128i
x2_sum_32
=
_mm_setzero_si128
(
)
;
for
(
int
i
=
0
;
i
<
=
height
-
4
;
i
+
=
3
)
{
for
(
int
j
=
0
;
j
<
=
width
-
4
;
j
+
=
3
)
{
horver_correlation_4x4
(
&
diff
[
i
*
stride
+
j
]
stride
&
xy_sum_32
&
xz_sum_32
&
x_sum_32
&
x2_sum_32
)
;
}
xx_storeu_128
(
xy_tmp
xy_sum_32
)
;
xx_storeu_128
(
xz_tmp
xz_sum_32
)
;
xx_storeu_128
(
x_tmp
x_sum_32
)
;
xx_storeu_128
(
x2_tmp
x2_sum_32
)
;
xy_sum
+
=
(
int64_t
)
xy_tmp
[
3
]
+
xy_tmp
[
2
]
+
xy_tmp
[
1
]
;
xz_sum
+
=
(
int64_t
)
xz_tmp
[
3
]
+
xz_tmp
[
2
]
+
xz_tmp
[
0
]
;
x_sum
+
=
(
int64_t
)
x_tmp
[
3
]
+
x_tmp
[
2
]
+
x_tmp
[
1
]
+
x_tmp
[
0
]
;
x2_sum
+
=
(
int64_t
)
x2_tmp
[
2
]
+
x2_tmp
[
1
]
+
x2_tmp
[
0
]
;
xy_sum_32
=
_mm_setzero_si128
(
)
;
xz_sum_32
=
_mm_setzero_si128
(
)
;
x_sum_32
=
_mm_setzero_si128
(
)
;
x2_sum_32
=
_mm_setzero_si128
(
)
;
}
int64_t
x_finalrow
=
0
x_finalcol
=
0
x2_finalrow
=
0
x2_finalcol
=
0
;
if
(
height
%
3
=
=
1
)
{
const
int16_t
x0
=
diff
[
(
height
-
1
)
*
stride
]
;
x_sum
+
=
x0
;
x_finalrow
+
=
x0
;
x2_sum
+
=
x0
*
x0
;
x2_finalrow
+
=
x0
*
x0
;
for
(
int
j
=
0
;
j
<
width
-
1
;
+
+
j
)
{
const
int16_t
x
=
diff
[
(
height
-
1
)
*
stride
+
j
]
;
const
int16_t
y
=
diff
[
(
height
-
1
)
*
stride
+
j
+
1
]
;
xy_sum
+
=
x
*
y
;
x_sum
+
=
y
;
x2_sum
+
=
y
*
y
;
x_finalrow
+
=
y
;
x2_finalrow
+
=
y
*
y
;
}
}
else
{
const
int16_t
x0
=
diff
[
(
height
-
2
)
*
stride
]
;
const
int16_t
z0
=
diff
[
(
height
-
1
)
*
stride
]
;
x_sum
+
=
x0
+
z0
;
x2_sum
+
=
x0
*
x0
+
z0
*
z0
;
x_finalrow
+
=
z0
;
x2_finalrow
+
=
z0
*
z0
;
for
(
int
j
=
0
;
j
<
width
-
1
;
+
+
j
)
{
const
int16_t
x
=
diff
[
(
height
-
2
)
*
stride
+
j
]
;
const
int16_t
y
=
diff
[
(
height
-
2
)
*
stride
+
j
+
1
]
;
const
int16_t
z
=
diff
[
(
height
-
1
)
*
stride
+
j
]
;
const
int16_t
w
=
diff
[
(
height
-
1
)
*
stride
+
j
+
1
]
;
xy_sum
+
=
x
*
y
;
xz_sum
+
=
x
*
z
;
xy_sum
+
=
z
*
w
;
x_sum
+
=
y
+
w
;
x2_sum
+
=
y
*
y
+
w
*
w
;
x_finalrow
+
=
w
;
x2_finalrow
+
=
w
*
w
;
}
}
if
(
width
%
3
=
=
1
)
{
const
int16_t
x0
=
diff
[
width
-
1
]
;
x_sum
+
=
x0
;
x_finalcol
+
=
x0
;
x2_sum
+
=
x0
*
x0
;
x2_finalcol
+
=
x0
*
x0
;
for
(
int
i
=
0
;
i
<
height
-
1
;
+
+
i
)
{
const
int16_t
x
=
diff
[
i
*
stride
+
width
-
1
]
;
const
int16_t
z
=
diff
[
(
i
+
1
)
*
stride
+
width
-
1
]
;
xz_sum
+
=
x
*
z
;
x_finalcol
+
=
z
;
x2_finalcol
+
=
z
*
z
;
if
(
i
<
height
-
(
height
%
3
=
=
1
?
2
:
3
)
)
{
x_sum
+
=
z
;
x2_sum
+
=
z
*
z
;
}
}
}
else
{
const
int16_t
x0
=
diff
[
width
-
2
]
;
const
int16_t
y0
=
diff
[
width
-
1
]
;
x_sum
+
=
x0
+
y0
;
x2_sum
+
=
x0
*
x0
+
y0
*
y0
;
x_finalcol
+
=
y0
;
x2_finalcol
+
=
y0
*
y0
;
for
(
int
i
=
0
;
i
<
height
-
1
;
+
+
i
)
{
const
int16_t
x
=
diff
[
i
*
stride
+
width
-
2
]
;
const
int16_t
y
=
diff
[
i
*
stride
+
width
-
1
]
;
const
int16_t
z
=
diff
[
(
i
+
1
)
*
stride
+
width
-
2
]
;
const
int16_t
w
=
diff
[
(
i
+
1
)
*
stride
+
width
-
1
]
;
if
(
i
<
height
-
2
|
|
height
%
3
=
=
1
)
{
xy_sum
+
=
x
*
y
;
xz_sum
+
=
x
*
z
;
}
x_finalcol
+
=
w
;
x2_finalcol
+
=
w
*
w
;
if
(
i
<
height
-
(
height
%
3
=
=
1
?
2
:
3
)
)
{
x_sum
+
=
z
+
w
;
x2_sum
+
=
z
*
z
+
w
*
w
;
}
xz_sum
+
=
y
*
w
;
}
}
int64_t
x_firstrow
=
0
x_firstcol
=
0
;
int64_t
x2_firstrow
=
0
x2_firstcol
=
0
;
for
(
int
j
=
0
;
j
<
width
;
+
+
j
)
{
x_firstrow
+
=
diff
[
j
]
;
x2_firstrow
+
=
diff
[
j
]
*
diff
[
j
]
;
}
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
x_firstcol
+
=
diff
[
i
*
stride
]
;
x2_firstcol
+
=
diff
[
i
*
stride
]
*
diff
[
i
*
stride
]
;
}
int64_t
xhor_sum
=
x_sum
-
x_finalcol
;
int64_t
xver_sum
=
x_sum
-
x_finalrow
;
int64_t
y_sum
=
x_sum
-
x_firstcol
;
int64_t
z_sum
=
x_sum
-
x_firstrow
;
int64_t
x2hor_sum
=
x2_sum
-
x2_finalcol
;
int64_t
x2ver_sum
=
x2_sum
-
x2_finalrow
;
int64_t
y2_sum
=
x2_sum
-
x2_firstcol
;
int64_t
z2_sum
=
x2_sum
-
x2_firstrow
;
const
float
num_hor
=
(
float
)
(
height
*
(
width
-
1
)
)
;
const
float
num_ver
=
(
float
)
(
(
height
-
1
)
*
width
)
;
const
float
xhor_var_n
=
x2hor_sum
-
(
xhor_sum
*
xhor_sum
)
/
num_hor
;
const
float
xver_var_n
=
x2ver_sum
-
(
xver_sum
*
xver_sum
)
/
num_ver
;
const
float
y_var_n
=
y2_sum
-
(
y_sum
*
y_sum
)
/
num_hor
;
const
float
z_var_n
=
z2_sum
-
(
z_sum
*
z_sum
)
/
num_ver
;
const
float
xy_var_n
=
xy_sum
-
(
xhor_sum
*
y_sum
)
/
num_hor
;
const
float
xz_var_n
=
xz_sum
-
(
xver_sum
*
z_sum
)
/
num_ver
;
if
(
xhor_var_n
>
0
&
&
y_var_n
>
0
)
{
*
hcorr
=
xy_var_n
/
sqrtf
(
xhor_var_n
*
y_var_n
)
;
*
hcorr
=
*
hcorr
<
0
?
0
:
*
hcorr
;
}
else
{
*
hcorr
=
1
.
0
;
}
if
(
xver_var_n
>
0
&
&
z_var_n
>
0
)
{
*
vcorr
=
xz_var_n
/
sqrtf
(
xver_var_n
*
z_var_n
)
;
*
vcorr
=
*
vcorr
<
0
?
0
:
*
vcorr
;
}
else
{
*
vcorr
=
1
.
0
;
}
}
