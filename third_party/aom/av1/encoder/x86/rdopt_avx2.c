#
include
<
assert
.
h
>
#
include
<
immintrin
.
h
>
#
include
"
aom_dsp
/
x86
/
mem_sse2
.
h
"
#
include
"
aom_dsp
/
x86
/
synonyms_avx2
.
h
"
#
include
"
config
/
av1_rtcd
.
h
"
#
include
"
av1
/
encoder
/
rdopt
.
h
"
INLINE
static
void
horver_correlation_4x4
(
const
int16_t
*
diff
int
stride
__m256i
*
xy_sum_32
__m256i
*
xz_sum_32
__m256i
*
x_sum_32
__m256i
*
x2_sum_32
)
{
const
__m256i
pixels
=
_mm256_set_epi64x
(
loadu_int64
(
&
diff
[
0
*
stride
]
)
loadu_int64
(
&
diff
[
1
*
stride
]
)
loadu_int64
(
&
diff
[
2
*
stride
]
)
loadu_int64
(
&
diff
[
3
*
stride
]
)
)
;
const
__m256i
slli
=
_mm256_slli_epi64
(
pixels
16
)
;
const
__m256i
madd_xy
=
_mm256_madd_epi16
(
pixels
slli
)
;
*
xy_sum_32
=
_mm256_add_epi32
(
*
xy_sum_32
madd_xy
)
;
const
__m256i
perm
=
_mm256_permute4x64_epi64
(
slli
0x90
)
;
const
__m256i
madd_xz
=
_mm256_madd_epi16
(
slli
perm
)
;
*
xz_sum_32
=
_mm256_add_epi32
(
*
xz_sum_32
madd_xz
)
;
const
__m256i
madd1_slli
=
_mm256_madd_epi16
(
slli
_mm256_set1_epi16
(
1
)
)
;
*
x_sum_32
=
_mm256_add_epi32
(
*
x_sum_32
madd1_slli
)
;
const
__m256i
madd_slli
=
_mm256_madd_epi16
(
slli
slli
)
;
*
x2_sum_32
=
_mm256_add_epi32
(
*
x2_sum_32
madd_slli
)
;
}
void
av1_get_horver_correlation_full_avx2
(
const
int16_t
*
diff
int
stride
int
width
int
height
float
*
hcorr
float
*
vcorr
)
{
int64_t
xy_sum
=
0
xz_sum
=
0
;
int64_t
x_sum
=
0
x2_sum
=
0
;
int32_t
xy_xz_tmp
[
8
]
=
{
0
}
x_x2_tmp
[
8
]
=
{
0
}
;
__m256i
xy_sum_32
=
_mm256_setzero_si256
(
)
;
__m256i
xz_sum_32
=
_mm256_setzero_si256
(
)
;
__m256i
x_sum_32
=
_mm256_setzero_si256
(
)
;
__m256i
x2_sum_32
=
_mm256_setzero_si256
(
)
;
for
(
int
i
=
0
;
i
<
=
height
-
4
;
i
+
=
3
)
{
for
(
int
j
=
0
;
j
<
=
width
-
4
;
j
+
=
3
)
{
horver_correlation_4x4
(
&
diff
[
i
*
stride
+
j
]
stride
&
xy_sum_32
&
xz_sum_32
&
x_sum_32
&
x2_sum_32
)
;
}
const
__m256i
hadd_xy_xz
=
_mm256_hadd_epi32
(
xy_sum_32
xz_sum_32
)
;
yy_storeu_256
(
xy_xz_tmp
hadd_xy_xz
)
;
xy_sum
+
=
(
int64_t
)
xy_xz_tmp
[
5
]
+
xy_xz_tmp
[
4
]
+
xy_xz_tmp
[
1
]
;
xz_sum
+
=
(
int64_t
)
xy_xz_tmp
[
7
]
+
xy_xz_tmp
[
6
]
+
xy_xz_tmp
[
3
]
;
const
__m256i
hadd_x_x2
=
_mm256_hadd_epi32
(
x_sum_32
x2_sum_32
)
;
yy_storeu_256
(
x_x2_tmp
hadd_x_x2
)
;
x_sum
+
=
(
int64_t
)
x_x2_tmp
[
5
]
+
x_x2_tmp
[
4
]
+
x_x2_tmp
[
1
]
;
x2_sum
+
=
(
int64_t
)
x_x2_tmp
[
7
]
+
x_x2_tmp
[
6
]
+
x_x2_tmp
[
3
]
;
xy_sum_32
=
_mm256_setzero_si256
(
)
;
xz_sum_32
=
_mm256_setzero_si256
(
)
;
x_sum_32
=
_mm256_setzero_si256
(
)
;
x2_sum_32
=
_mm256_setzero_si256
(
)
;
}
int64_t
x_finalrow
=
0
x_finalcol
=
0
x2_finalrow
=
0
x2_finalcol
=
0
;
if
(
height
%
3
=
=
1
)
{
const
int16_t
x0
=
diff
[
(
height
-
1
)
*
stride
]
;
x_sum
+
=
x0
;
x_finalrow
+
=
x0
;
x2_sum
+
=
x0
*
x0
;
x2_finalrow
+
=
x0
*
x0
;
for
(
int
j
=
0
;
j
<
width
-
1
;
+
+
j
)
{
const
int16_t
x
=
diff
[
(
height
-
1
)
*
stride
+
j
]
;
const
int16_t
y
=
diff
[
(
height
-
1
)
*
stride
+
j
+
1
]
;
xy_sum
+
=
x
*
y
;
x_sum
+
=
y
;
x2_sum
+
=
y
*
y
;
x_finalrow
+
=
y
;
x2_finalrow
+
=
y
*
y
;
}
}
else
{
const
int16_t
x0
=
diff
[
(
height
-
2
)
*
stride
]
;
const
int16_t
z0
=
diff
[
(
height
-
1
)
*
stride
]
;
x_sum
+
=
x0
+
z0
;
x2_sum
+
=
x0
*
x0
+
z0
*
z0
;
x_finalrow
+
=
z0
;
x2_finalrow
+
=
z0
*
z0
;
for
(
int
j
=
0
;
j
<
width
-
1
;
+
+
j
)
{
const
int16_t
x
=
diff
[
(
height
-
2
)
*
stride
+
j
]
;
const
int16_t
y
=
diff
[
(
height
-
2
)
*
stride
+
j
+
1
]
;
const
int16_t
z
=
diff
[
(
height
-
1
)
*
stride
+
j
]
;
const
int16_t
w
=
diff
[
(
height
-
1
)
*
stride
+
j
+
1
]
;
xy_sum
+
=
x
*
y
;
xz_sum
+
=
x
*
z
;
xy_sum
+
=
z
*
w
;
x_sum
+
=
y
+
w
;
x2_sum
+
=
y
*
y
+
w
*
w
;
x_finalrow
+
=
w
;
x2_finalrow
+
=
w
*
w
;
}
}
if
(
width
%
3
=
=
1
)
{
const
int16_t
x0
=
diff
[
width
-
1
]
;
x_sum
+
=
x0
;
x_finalcol
+
=
x0
;
x2_sum
+
=
x0
*
x0
;
x2_finalcol
+
=
x0
*
x0
;
for
(
int
i
=
0
;
i
<
height
-
1
;
+
+
i
)
{
const
int16_t
x
=
diff
[
i
*
stride
+
width
-
1
]
;
const
int16_t
z
=
diff
[
(
i
+
1
)
*
stride
+
width
-
1
]
;
xz_sum
+
=
x
*
z
;
x_finalcol
+
=
z
;
x2_finalcol
+
=
z
*
z
;
if
(
i
<
height
-
(
height
%
3
=
=
1
?
2
:
3
)
)
{
x_sum
+
=
z
;
x2_sum
+
=
z
*
z
;
}
}
}
else
{
const
int16_t
x0
=
diff
[
width
-
2
]
;
const
int16_t
y0
=
diff
[
width
-
1
]
;
x_sum
+
=
x0
+
y0
;
x2_sum
+
=
x0
*
x0
+
y0
*
y0
;
x_finalcol
+
=
y0
;
x2_finalcol
+
=
y0
*
y0
;
for
(
int
i
=
0
;
i
<
height
-
1
;
+
+
i
)
{
const
int16_t
x
=
diff
[
i
*
stride
+
width
-
2
]
;
const
int16_t
y
=
diff
[
i
*
stride
+
width
-
1
]
;
const
int16_t
z
=
diff
[
(
i
+
1
)
*
stride
+
width
-
2
]
;
const
int16_t
w
=
diff
[
(
i
+
1
)
*
stride
+
width
-
1
]
;
if
(
i
<
height
-
2
|
|
height
%
3
=
=
1
)
{
xy_sum
+
=
x
*
y
;
xz_sum
+
=
x
*
z
;
}
x_finalcol
+
=
w
;
x2_finalcol
+
=
w
*
w
;
if
(
i
<
height
-
(
height
%
3
=
=
1
?
2
:
3
)
)
{
x_sum
+
=
z
+
w
;
x2_sum
+
=
z
*
z
+
w
*
w
;
}
xz_sum
+
=
y
*
w
;
}
}
int64_t
x_firstrow
=
0
x_firstcol
=
0
;
int64_t
x2_firstrow
=
0
x2_firstcol
=
0
;
for
(
int
j
=
0
;
j
<
width
;
+
+
j
)
{
x_firstrow
+
=
diff
[
j
]
;
x2_firstrow
+
=
diff
[
j
]
*
diff
[
j
]
;
}
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
x_firstcol
+
=
diff
[
i
*
stride
]
;
x2_firstcol
+
=
diff
[
i
*
stride
]
*
diff
[
i
*
stride
]
;
}
int64_t
xhor_sum
=
x_sum
-
x_finalcol
;
int64_t
xver_sum
=
x_sum
-
x_finalrow
;
int64_t
y_sum
=
x_sum
-
x_firstcol
;
int64_t
z_sum
=
x_sum
-
x_firstrow
;
int64_t
x2hor_sum
=
x2_sum
-
x2_finalcol
;
int64_t
x2ver_sum
=
x2_sum
-
x2_finalrow
;
int64_t
y2_sum
=
x2_sum
-
x2_firstcol
;
int64_t
z2_sum
=
x2_sum
-
x2_firstrow
;
const
float
num_hor
=
(
float
)
(
height
*
(
width
-
1
)
)
;
const
float
num_ver
=
(
float
)
(
(
height
-
1
)
*
width
)
;
const
float
xhor_var_n
=
x2hor_sum
-
(
xhor_sum
*
xhor_sum
)
/
num_hor
;
const
float
xver_var_n
=
x2ver_sum
-
(
xver_sum
*
xver_sum
)
/
num_ver
;
const
float
y_var_n
=
y2_sum
-
(
y_sum
*
y_sum
)
/
num_hor
;
const
float
z_var_n
=
z2_sum
-
(
z_sum
*
z_sum
)
/
num_ver
;
const
float
xy_var_n
=
xy_sum
-
(
xhor_sum
*
y_sum
)
/
num_hor
;
const
float
xz_var_n
=
xz_sum
-
(
xver_sum
*
z_sum
)
/
num_ver
;
if
(
xhor_var_n
>
0
&
&
y_var_n
>
0
)
{
*
hcorr
=
xy_var_n
/
sqrtf
(
xhor_var_n
*
y_var_n
)
;
*
hcorr
=
*
hcorr
<
0
?
0
:
*
hcorr
;
}
else
{
*
hcorr
=
1
.
0
;
}
if
(
xver_var_n
>
0
&
&
z_var_n
>
0
)
{
*
vcorr
=
xz_var_n
/
sqrtf
(
xver_var_n
*
z_var_n
)
;
*
vcorr
=
*
vcorr
<
0
?
0
:
*
vcorr
;
}
else
{
*
vcorr
=
1
.
0
;
}
}
