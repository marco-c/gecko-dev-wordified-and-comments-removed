#
ifndef
AV1_COMMON_LOOPFILTER_H_
#
define
AV1_COMMON_LOOPFILTER_H_
#
include
"
config
/
aom_config
.
h
"
#
include
"
aom_ports
/
mem
.
h
"
#
include
"
av1
/
common
/
blockd
.
h
"
#
include
"
av1
/
common
/
seg_common
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
MAX_LOOP_FILTER
63
#
define
MAX_SHARPNESS
7
#
define
SIMD_WIDTH
16
enum
lf_path
{
LF_PATH_420
LF_PATH_444
LF_PATH_SLOW
}
;
#
if
LOOP_FILTER_BITMASK
typedef
struct
{
uint64_t
bits
[
4
]
;
}
FilterMask
;
typedef
struct
{
FilterMask
left_y
[
TX_SIZES
]
;
FilterMask
above_y
[
TX_SIZES
]
;
FilterMask
left_u
[
TX_SIZES
]
;
FilterMask
above_u
[
TX_SIZES
]
;
FilterMask
left_v
[
TX_SIZES
]
;
FilterMask
above_v
[
TX_SIZES
]
;
uint8_t
lfl_y_hor
[
MI_SIZE_64X64
]
[
MI_SIZE_64X64
]
;
uint8_t
lfl_y_ver
[
MI_SIZE_64X64
]
[
MI_SIZE_64X64
]
;
uint8_t
lfl_u_hor
[
MI_SIZE_64X64
]
[
MI_SIZE_64X64
]
;
uint8_t
lfl_u_ver
[
MI_SIZE_64X64
]
[
MI_SIZE_64X64
]
;
uint8_t
lfl_v_hor
[
MI_SIZE_64X64
]
[
MI_SIZE_64X64
]
;
uint8_t
lfl_v_ver
[
MI_SIZE_64X64
]
[
MI_SIZE_64X64
]
;
}
LoopFilterMask
;
typedef
struct
{
TX_SIZE
tx_size_y_above
[
MI_SIZE_64X64
]
;
TX_SIZE
tx_size_y_left
[
MI_SIZE_64X64
]
;
TX_SIZE
tx_size_uv_above
[
MI_SIZE_64X64
]
;
TX_SIZE
tx_size_uv_left
[
MI_SIZE_64X64
]
;
uint8_t
y_level_above
[
MI_SIZE_64X64
]
;
uint8_t
y_level_left
[
MI_SIZE_64X64
]
;
uint8_t
u_level_above
[
MI_SIZE_64X64
]
;
uint8_t
u_level_left
[
MI_SIZE_64X64
]
;
uint8_t
v_level_above
[
MI_SIZE_64X64
]
;
uint8_t
v_level_left
[
MI_SIZE_64X64
]
;
uint8_t
skip
[
MI_SIZE_64X64
]
;
}
LpfSuperblockInfo
;
#
endif
struct
loopfilter
{
int
filter_level
[
2
]
;
int
filter_level_u
;
int
filter_level_v
;
int
sharpness_level
;
uint8_t
mode_ref_delta_enabled
;
uint8_t
mode_ref_delta_update
;
int8_t
ref_deltas
[
REF_FRAMES
]
;
int8_t
mode_deltas
[
MAX_MODE_LF_DELTAS
]
;
int
combine_vert_horz_lf
;
#
if
LOOP_FILTER_BITMASK
LoopFilterMask
*
lfm
;
size_t
lfm_num
;
int
lfm_stride
;
LpfSuperblockInfo
neighbor_sb_lpf_info
;
#
endif
}
;
typedef
struct
{
DECLARE_ALIGNED
(
SIMD_WIDTH
uint8_t
mblim
[
SIMD_WIDTH
]
)
;
DECLARE_ALIGNED
(
SIMD_WIDTH
uint8_t
lim
[
SIMD_WIDTH
]
)
;
DECLARE_ALIGNED
(
SIMD_WIDTH
uint8_t
hev_thr
[
SIMD_WIDTH
]
)
;
}
loop_filter_thresh
;
typedef
struct
{
loop_filter_thresh
lfthr
[
MAX_LOOP_FILTER
+
1
]
;
uint8_t
lvl
[
MAX_MB_PLANE
]
[
MAX_SEGMENTS
]
[
2
]
[
REF_FRAMES
]
[
MAX_MODE_LF_DELTAS
]
;
}
loop_filter_info_n
;
struct
AV1Common
;
struct
macroblockd
;
struct
AV1LfSyncData
;
void
av1_loop_filter_init
(
struct
AV1Common
*
cm
)
;
void
av1_loop_filter_frame_init
(
struct
AV1Common
*
cm
int
plane_start
int
plane_end
)
;
void
av1_loop_filter_frame
(
YV12_BUFFER_CONFIG
*
frame
struct
AV1Common
*
cm
struct
macroblockd
*
mbd
int
plane_start
int
plane_end
int
partial_frame
)
;
void
av1_filter_block_plane_vert
(
const
struct
AV1Common
*
const
cm
const
MACROBLOCKD
*
const
xd
const
int
plane
const
MACROBLOCKD_PLANE
*
const
plane_ptr
const
uint32_t
mi_row
const
uint32_t
mi_col
)
;
void
av1_filter_block_plane_horz
(
const
struct
AV1Common
*
const
cm
const
MACROBLOCKD
*
const
xd
const
int
plane
const
MACROBLOCKD_PLANE
*
const
plane_ptr
const
uint32_t
mi_row
const
uint32_t
mi_col
)
;
typedef
struct
LoopFilterWorkerData
{
YV12_BUFFER_CONFIG
*
frame_buffer
;
struct
AV1Common
*
cm
;
struct
macroblockd_plane
planes
[
MAX_MB_PLANE
]
;
MACROBLOCKD
*
xd
;
}
LFWorkerData
;
#
if
LOOP_FILTER_BITMASK
void
av1_setup_bitmask
(
struct
AV1Common
*
const
cm
int
mi_row
int
mi_col
int
plane
int
subsampling_x
int
subsampling_y
int
row_end
int
col_end
)
;
void
av1_filter_block_plane_ver
(
struct
AV1Common
*
const
cm
struct
macroblockd_plane
*
const
plane_ptr
int
pl
int
mi_row
int
mi_col
)
;
void
av1_filter_block_plane_hor
(
struct
AV1Common
*
const
cm
struct
macroblockd_plane
*
const
plane
int
pl
int
mi_row
int
mi_col
)
;
#
endif
#
ifdef
__cplusplus
}
#
endif
#
endif
