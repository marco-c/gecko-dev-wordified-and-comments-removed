#
ifndef
AOM_AV1_COMMON_QUANT_COMMON_H_
#
define
AOM_AV1_COMMON_QUANT_COMMON_H_
#
include
<
stdbool
.
h
>
#
include
"
aom
/
aom_codec
.
h
"
#
include
"
av1
/
common
/
seg_common
.
h
"
#
include
"
av1
/
common
/
enums
.
h
"
#
include
"
av1
/
common
/
entropy
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
MINQ
0
#
define
MAXQ
255
#
define
QINDEX_RANGE
(
MAXQ
-
MINQ
+
1
)
#
define
QINDEX_BITS
8
#
define
QM_LEVEL_BITS
4
#
define
NUM_QM_LEVELS
(
1
<
<
QM_LEVEL_BITS
)
#
define
DEFAULT_QM_Y
10
#
define
DEFAULT_QM_U
11
#
define
DEFAULT_QM_V
12
#
define
DEFAULT_QM_FIRST
5
#
define
DEFAULT_QM_LAST
9
#
define
DEFAULT_QM_FIRST_ALLINTRA
4
#
define
DEFAULT_QM_LAST_ALLINTRA
10
#
define
QM_FIRST_IQ
2
#
define
QM_LAST_IQ
10
#
define
LOSSLESS_Q_STEP
4
/
/
this
should
equal
to
dc
/
ac_qlookup_QTX
[
0
]
struct
AV1Common
;
struct
CommonQuantParams
;
struct
macroblockd
;
int16_t
av1_dc_quant_QTX
(
int
qindex
int
delta
aom_bit_depth_t
bit_depth
)
;
int16_t
av1_ac_quant_QTX
(
int
qindex
int
delta
aom_bit_depth_t
bit_depth
)
;
int
av1_get_qindex
(
const
struct
segmentation
*
seg
int
segment_id
int
base_qindex
)
;
bool
av1_use_qmatrix
(
const
struct
CommonQuantParams
*
quant_params
const
struct
macroblockd
*
xd
int
segment_id
)
;
static
inline
int
aom_get_qmlevel
(
int
qindex
int
first
int
last
)
{
return
first
+
(
qindex
*
(
last
+
1
-
first
)
)
/
QINDEX_RANGE
;
}
static
inline
int
aom_get_qmlevel_allintra
(
int
qindex
int
first
int
last
)
{
int
qm_level
=
0
;
if
(
qindex
<
=
40
)
{
qm_level
=
10
;
}
else
if
(
qindex
<
=
100
)
{
qm_level
=
9
;
}
else
if
(
qindex
<
=
160
)
{
qm_level
=
8
;
}
else
if
(
qindex
<
=
200
)
{
qm_level
=
7
;
}
else
if
(
qindex
<
=
220
)
{
qm_level
=
6
;
}
else
if
(
qindex
<
=
240
)
{
qm_level
=
5
;
}
else
{
qm_level
=
4
;
}
return
clamp
(
qm_level
first
last
)
;
}
static
inline
int
aom_get_qmlevel_luma_iq
(
int
qindex
int
first
int
last
)
{
int
qm_level
=
0
;
if
(
qindex
<
=
40
)
{
qm_level
=
10
;
}
else
if
(
qindex
<
=
60
)
{
qm_level
=
9
;
}
else
if
(
qindex
<
=
100
)
{
qm_level
=
8
;
}
else
if
(
qindex
<
=
120
)
{
qm_level
=
7
;
}
else
if
(
qindex
<
=
140
)
{
qm_level
=
6
;
}
else
if
(
qindex
<
=
160
)
{
qm_level
=
5
;
}
else
if
(
qindex
<
=
200
)
{
qm_level
=
4
;
}
else
if
(
qindex
<
=
220
)
{
qm_level
=
3
;
}
else
{
qm_level
=
2
;
}
return
clamp
(
qm_level
first
last
)
;
}
static
inline
int
aom_get_qmlevel_444_chroma_iq
(
int
qindex
int
first
int
last
)
{
int
chroma_qm_level
=
0
;
if
(
qindex
<
=
12
)
{
chroma_qm_level
=
10
;
}
else
if
(
qindex
<
=
24
)
{
chroma_qm_level
=
9
;
}
else
if
(
qindex
<
=
32
)
{
chroma_qm_level
=
8
;
}
else
if
(
qindex
<
=
36
)
{
chroma_qm_level
=
7
;
}
else
if
(
qindex
<
=
44
)
{
chroma_qm_level
=
6
;
}
else
if
(
qindex
<
=
48
)
{
chroma_qm_level
=
5
;
}
else
if
(
qindex
<
=
56
)
{
chroma_qm_level
=
4
;
}
else
if
(
qindex
<
=
88
)
{
chroma_qm_level
=
3
;
}
else
{
chroma_qm_level
=
2
;
}
return
clamp
(
chroma_qm_level
first
last
)
;
}
void
av1_qm_init
(
struct
CommonQuantParams
*
quant_params
int
num_planes
)
;
const
qm_val_t
*
av1_get_iqmatrix
(
const
struct
CommonQuantParams
*
quant_params
const
struct
macroblockd
*
xd
int
plane
TX_SIZE
tx_size
TX_TYPE
tx_type
)
;
const
qm_val_t
*
av1_get_qmatrix
(
const
struct
CommonQuantParams
*
quant_params
const
struct
macroblockd
*
xd
int
plane
TX_SIZE
tx_size
TX_TYPE
tx_type
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
