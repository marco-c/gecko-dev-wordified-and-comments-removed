#
ifndef
AV1_COMMON_ENUMS_H_
#
define
AV1_COMMON_ENUMS_H_
#
include
"
.
/
aom_config
.
h
"
#
include
"
aom
/
aom_codec
.
h
"
#
include
"
aom
/
aom_integer
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
undef
MAX_SB_SIZE
#
if
CONFIG_EXT_PARTITION
#
define
MAX_SB_SIZE_LOG2
7
#
else
#
define
MAX_SB_SIZE_LOG2
6
#
endif
#
define
MAX_SB_SIZE
(
1
<
<
MAX_SB_SIZE_LOG2
)
#
define
MAX_SB_SQUARE
(
MAX_SB_SIZE
*
MAX_SB_SIZE
)
#
define
MIN_SB_SIZE_LOG2
6
#
if
CONFIG_CB4X4
#
define
MI_SIZE_LOG2
2
#
else
#
define
MI_SIZE_LOG2
3
#
endif
#
define
MI_SIZE
(
1
<
<
MI_SIZE_LOG2
)
#
define
MAX_MIB_SIZE_LOG2
(
MAX_SB_SIZE_LOG2
-
MI_SIZE_LOG2
)
#
define
MAX_MIB_SIZE
(
1
<
<
MAX_MIB_SIZE_LOG2
)
#
define
MIN_MIB_SIZE_LOG2
(
MIN_SB_SIZE_LOG2
-
MI_SIZE_LOG2
)
#
define
MAX_MIB_MASK
(
MAX_MIB_SIZE
-
1
)
#
if
CONFIG_EXT_TILE
#
define
TILE_NORMAL
0
#
define
TILE_VR
1
#
define
MAX_TILE_ROWS
1024
#
define
MAX_TILE_COLS
1024
#
else
#
define
MAX_TILE_ROWS
4
#
define
MAX_TILE_COLS
64
#
endif
#
if
CONFIG_VAR_TX
#
define
MAX_VARTX_DEPTH
2
#
endif
typedef
enum
BITSTREAM_PROFILE
{
PROFILE_0
PROFILE_1
PROFILE_2
PROFILE_3
MAX_PROFILES
}
BITSTREAM_PROFILE
;
typedef
enum
ATTRIBUTE_PACKED
{
#
if
CONFIG_CB4X4
BLOCK_2X2
BLOCK_2X4
BLOCK_4X2
#
endif
BLOCK_4X4
BLOCK_4X8
BLOCK_8X4
BLOCK_8X8
BLOCK_8X16
BLOCK_16X8
BLOCK_16X16
BLOCK_16X32
BLOCK_32X16
BLOCK_32X32
BLOCK_32X64
BLOCK_64X32
BLOCK_64X64
#
if
CONFIG_EXT_PARTITION
BLOCK_64X128
BLOCK_128X64
BLOCK_128X128
#
endif
BLOCK_4X16
BLOCK_16X4
BLOCK_8X32
BLOCK_32X8
BLOCK_SIZES_ALL
BLOCK_SIZES
=
BLOCK_4X16
BLOCK_INVALID
=
255
BLOCK_LARGEST
=
(
BLOCK_SIZES
-
1
)
}
BLOCK_SIZE
;
typedef
enum
{
PARTITION_NONE
PARTITION_HORZ
PARTITION_VERT
PARTITION_SPLIT
#
if
CONFIG_EXT_PARTITION_TYPES
PARTITION_HORZ_A
PARTITION_HORZ_B
PARTITION_VERT_A
PARTITION_VERT_B
EXT_PARTITION_TYPES
#
endif
PARTITION_TYPES
=
PARTITION_SPLIT
+
1
PARTITION_INVALID
=
255
}
PARTITION_TYPE
;
typedef
char
PARTITION_CONTEXT
;
#
define
PARTITION_PLOFFSET
4
/
/
number
of
probability
models
per
block
size
#
define
PARTITION_BLOCK_SIZES
(
4
+
CONFIG_EXT_PARTITION
)
#
define
PARTITION_CONTEXTS_PRIMARY
(
PARTITION_BLOCK_SIZES
*
PARTITION_PLOFFSET
)
#
if
CONFIG_UNPOISON_PARTITION_CTX
#
define
PARTITION_CONTEXTS
\
(
PARTITION_CONTEXTS_PRIMARY
+
2
*
PARTITION_BLOCK_SIZES
)
#
else
#
define
PARTITION_CONTEXTS
PARTITION_CONTEXTS_PRIMARY
#
endif
typedef
enum
ATTRIBUTE_PACKED
{
#
if
CONFIG_CHROMA_2X2
TX_2X2
#
endif
TX_4X4
TX_8X8
TX_16X16
TX_32X32
#
if
CONFIG_TX64X64
TX_64X64
#
endif
TX_4X8
TX_8X4
TX_8X16
TX_16X8
TX_16X32
TX_32X16
TX_4X16
TX_16X4
TX_8X32
TX_32X8
TX_SIZES_ALL
TX_SIZES
=
TX_4X8
TX_INVALID
=
255
}
TX_SIZE
;
#
define
TX_SIZE_LUMA_MIN
(
TX_4X4
)
#
define
TX_SIZE_CTX_MIN
(
TX_SIZE_LUMA_MIN
+
1
)
#
define
MAX_TX_DEPTH
(
TX_SIZES
-
TX_SIZE_CTX_MIN
)
#
define
MAX_TX_SIZE_LOG2
(
5
+
CONFIG_TX64X64
)
#
define
MAX_TX_SIZE
(
1
<
<
MAX_TX_SIZE_LOG2
)
#
define
MIN_TX_SIZE_LOG2
2
#
define
MIN_TX_SIZE
(
1
<
<
MIN_TX_SIZE_LOG2
)
#
define
MAX_TX_SQUARE
(
MAX_TX_SIZE
*
MAX_TX_SIZE
)
#
define
MAX_TX_BLOCKS_IN_MAX_SB_LOG2
(
(
MAX_SB_SIZE_LOG2
-
MAX_TX_SIZE_LOG2
)
*
2
)
#
define
MAX_TX_BLOCKS_IN_MAX_SB
(
1
<
<
MAX_TX_BLOCKS_IN_MAX_SB_LOG2
)
#
define
MAX_NUM_TXB
(
1
<
<
(
MAX_SB_SIZE_LOG2
-
MIN_TX_SIZE_LOG2
)
)
typedef
enum
{
ONLY_4X4
=
0
ALLOW_8X8
=
1
ALLOW_16X16
=
2
ALLOW_32X32
=
3
#
if
CONFIG_TX64X64
ALLOW_64X64
=
4
#
endif
TX_MODE_SELECT
TX_MODES
}
TX_MODE
;
typedef
enum
{
DCT_1D
=
0
ADST_1D
=
1
FLIPADST_1D
=
2
IDTX_1D
=
3
TX_TYPES_1D
=
4
}
TX_TYPE_1D
;
typedef
enum
{
DCT_DCT
=
0
ADST_DCT
=
1
DCT_ADST
=
2
ADST_ADST
=
3
#
if
CONFIG_EXT_TX
FLIPADST_DCT
=
4
DCT_FLIPADST
=
5
FLIPADST_FLIPADST
=
6
ADST_FLIPADST
=
7
FLIPADST_ADST
=
8
IDTX
=
9
V_DCT
=
10
H_DCT
=
11
V_ADST
=
12
H_ADST
=
13
V_FLIPADST
=
14
H_FLIPADST
=
15
#
endif
TX_TYPES
}
TX_TYPE
;
typedef
enum
{
TILE_LEFT_BOUNDARY
=
1
TILE_RIGHT_BOUNDARY
=
2
TILE_ABOVE_BOUNDARY
=
4
TILE_BOTTOM_BOUNDARY
=
8
FRAME_LEFT_BOUNDARY
=
16
FRAME_RIGHT_BOUNDARY
=
32
FRAME_ABOVE_BOUNDARY
=
64
FRAME_BOTTOM_BOUNDARY
=
128
}
BOUNDARY_TYPE
;
#
if
CONFIG_EXT_TX
#
if
CONFIG_CHROMA_2X2
#
define
EXT_TX_SIZES
5
/
/
number
of
sizes
that
use
extended
transforms
#
else
#
define
EXT_TX_SIZES
4
/
/
number
of
sizes
that
use
extended
transforms
#
endif
#
define
EXT_TX_SETS_INTER
4
/
/
Sets
of
transform
selections
for
INTER
#
define
EXT_TX_SETS_INTRA
3
/
/
Sets
of
transform
selections
for
INTRA
#
else
#
if
CONFIG_CHROMA_2X2
#
define
EXT_TX_SIZES
4
/
/
number
of
sizes
that
use
extended
transforms
#
else
#
define
EXT_TX_SIZES
3
/
/
number
of
sizes
that
use
extended
transforms
#
endif
#
endif
typedef
enum
{
AOM_LAST_FLAG
=
1
<
<
0
#
if
CONFIG_EXT_REFS
AOM_LAST2_FLAG
=
1
<
<
1
AOM_LAST3_FLAG
=
1
<
<
2
AOM_GOLD_FLAG
=
1
<
<
3
AOM_BWD_FLAG
=
1
<
<
4
AOM_ALT_FLAG
=
1
<
<
5
AOM_REFFRAME_ALL
=
(
1
<
<
6
)
-
1
#
else
AOM_GOLD_FLAG
=
1
<
<
1
AOM_ALT_FLAG
=
1
<
<
2
AOM_REFFRAME_ALL
=
(
1
<
<
3
)
-
1
#
endif
}
AOM_REFFRAME
;
typedef
enum
{
PLANE_TYPE_Y
=
0
PLANE_TYPE_UV
=
1
PLANE_TYPES
}
PLANE_TYPE
;
#
if
CONFIG_CFL
#
define
CB_ALPHABET_SIZE
4
#
define
CR_ALPHABET_SIZE
4
#
define
CFL_ALPHABET_SIZE
(
CB_ALPHABET_SIZE
*
CR_ALPHABET_SIZE
)
#
define
CFL_MAGS_SIZE
7
typedef
enum
{
CFL_PRED_U
=
0
CFL_PRED_V
=
1
CFL_PRED_PLANES
}
CFL_PRED_TYPE
;
typedef
enum
{
CFL_SIGN_NEG
=
0
CFL_SIGN_POS
=
1
CFL_SIGNS
}
CFL_SIGN_TYPE
;
#
endif
#
if
CONFIG_PALETTE
typedef
enum
{
TWO_COLORS
THREE_COLORS
FOUR_COLORS
FIVE_COLORS
SIX_COLORS
SEVEN_COLORS
EIGHT_COLORS
PALETTE_SIZES
}
PALETTE_SIZE
;
typedef
enum
{
PALETTE_COLOR_ONE
PALETTE_COLOR_TWO
PALETTE_COLOR_THREE
PALETTE_COLOR_FOUR
PALETTE_COLOR_FIVE
PALETTE_COLOR_SIX
PALETTE_COLOR_SEVEN
PALETTE_COLOR_EIGHT
PALETTE_COLORS
}
PALETTE_COLOR
;
#
endif
typedef
enum
ATTRIBUTE_PACKED
{
DC_PRED
V_PRED
H_PRED
D45_PRED
D135_PRED
D117_PRED
D153_PRED
D207_PRED
D63_PRED
#
if
CONFIG_ALT_INTRA
SMOOTH_PRED
#
if
CONFIG_SMOOTH_HV
SMOOTH_V_PRED
SMOOTH_H_PRED
#
endif
#
endif
TM_PRED
NEARESTMV
NEARMV
ZEROMV
NEWMV
#
if
CONFIG_EXT_INTER
#
if
CONFIG_COMPOUND_SINGLEREF
SR_NEAREST_NEARMV
SR_NEAREST_NEWMV
SR_NEAR_NEWMV
SR_ZERO_NEWMV
SR_NEW_NEWMV
#
endif
NEAREST_NEARESTMV
NEAR_NEARMV
NEAREST_NEWMV
NEW_NEARESTMV
NEAR_NEWMV
NEW_NEARMV
ZERO_ZEROMV
NEW_NEWMV
#
endif
MB_MODE_COUNT
INTRA_MODES
=
TM_PRED
+
1
INTRA_INVALID
=
MB_MODE_COUNT
}
PREDICTION_MODE
;
typedef
enum
{
SIMPLE_TRANSLATION
=
0
#
if
CONFIG_MOTION_VAR
OBMC_CAUSAL
#
endif
#
if
CONFIG_WARPED_MOTION
WARPED_CAUSAL
#
endif
MOTION_MODES
}
MOTION_MODE
;
#
if
CONFIG_EXT_INTER
#
if
CONFIG_INTERINTRA
typedef
enum
{
II_DC_PRED
=
0
II_V_PRED
II_H_PRED
#
if
CONFIG_ALT_INTRA
II_SMOOTH_PRED
#
else
II_TM_PRED
#
endif
INTERINTRA_MODES
}
INTERINTRA_MODE
;
#
endif
typedef
enum
{
COMPOUND_AVERAGE
=
0
#
if
CONFIG_WEDGE
COMPOUND_WEDGE
#
endif
#
if
CONFIG_COMPOUND_SEGMENT
COMPOUND_SEG
#
endif
COMPOUND_TYPES
}
COMPOUND_TYPE
;
#
endif
#
if
CONFIG_FILTER_INTRA
typedef
enum
{
FILTER_DC_PRED
FILTER_V_PRED
FILTER_H_PRED
FILTER_D45_PRED
FILTER_D135_PRED
FILTER_D117_PRED
FILTER_D153_PRED
FILTER_D207_PRED
FILTER_D63_PRED
FILTER_TM_PRED
FILTER_INTRA_MODES
}
FILTER_INTRA_MODE
;
#
endif
#
if
CONFIG_EXT_INTRA
#
define
DIRECTIONAL_MODES
8
#
endif
#
define
INTER_MODES
(
1
+
NEWMV
-
NEARESTMV
)
#
if
CONFIG_EXT_INTER
#
if
CONFIG_COMPOUND_SINGLEREF
#
define
INTER_SINGLEREF_COMP_MODES
(
1
+
SR_NEW_NEWMV
-
SR_NEAREST_NEARMV
)
#
endif
#
define
INTER_COMPOUND_MODES
(
1
+
NEW_NEWMV
-
NEAREST_NEARESTMV
)
#
endif
#
define
SKIP_CONTEXTS
3
#
define
NMV_CONTEXTS
3
#
define
NEWMV_MODE_CONTEXTS
7
#
define
ZEROMV_MODE_CONTEXTS
2
#
define
REFMV_MODE_CONTEXTS
9
#
define
DRL_MODE_CONTEXTS
5
#
define
ZEROMV_OFFSET
3
#
define
REFMV_OFFSET
4
#
define
NEWMV_CTX_MASK
(
(
1
<
<
ZEROMV_OFFSET
)
-
1
)
#
define
ZEROMV_CTX_MASK
(
(
1
<
<
(
REFMV_OFFSET
-
ZEROMV_OFFSET
)
)
-
1
)
#
define
REFMV_CTX_MASK
(
(
1
<
<
(
8
-
REFMV_OFFSET
)
)
-
1
)
#
define
ALL_ZERO_FLAG_OFFSET
8
#
define
SKIP_NEARESTMV_OFFSET
9
#
define
SKIP_NEARMV_OFFSET
10
#
define
SKIP_NEARESTMV_SUB8X8_OFFSET
11
#
define
INTER_MODE_CONTEXTS
7
#
if
CONFIG_DELTA_Q
#
define
DELTA_Q_SMALL
3
#
define
DELTA_Q_PROBS
(
DELTA_Q_SMALL
)
#
define
DEFAULT_DELTA_Q_RES
4
#
if
CONFIG_EXT_DELTA_Q
#
define
DELTA_LF_SMALL
3
#
define
DELTA_LF_PROBS
(
DELTA_LF_SMALL
)
#
define
DEFAULT_DELTA_LF_RES
2
#
endif
#
endif
#
define
MAX_MV_REF_CANDIDATES
2
#
define
MAX_REF_MV_STACK_SIZE
16
#
if
CONFIG_EXT_PARTITION
#
define
REF_CAT_LEVEL
640
#
else
#
define
REF_CAT_LEVEL
255
#
endif
#
define
INTRA_INTER_CONTEXTS
4
#
define
COMP_INTER_CONTEXTS
5
#
define
REF_CONTEXTS
5
#
if
CONFIG_EXT_INTER
&
&
CONFIG_COMPOUND_SINGLEREF
#
define
COMP_INTER_MODE_CONTEXTS
4
#
endif
#
if
CONFIG_VAR_TX
#
define
TXFM_PARTITION_CONTEXTS
(
(
TX_SIZES
-
TX_8X8
)
*
6
-
2
)
typedef
uint8_t
TXFM_CONTEXT
;
#
endif
#
define
NONE_FRAME
-
1
#
define
INTRA_FRAME
0
#
define
LAST_FRAME
1
#
if
CONFIG_EXT_REFS
#
define
LAST2_FRAME
2
#
define
LAST3_FRAME
3
#
define
GOLDEN_FRAME
4
#
define
BWDREF_FRAME
5
#
define
ALTREF_FRAME
6
#
define
LAST_REF_FRAMES
(
LAST3_FRAME
-
LAST_FRAME
+
1
)
#
else
#
define
GOLDEN_FRAME
2
#
define
ALTREF_FRAME
3
#
endif
#
define
INTER_REFS_PER_FRAME
(
ALTREF_FRAME
-
LAST_FRAME
+
1
)
#
define
TOTAL_REFS_PER_FRAME
(
ALTREF_FRAME
-
INTRA_FRAME
+
1
)
#
define
FWD_REFS
(
GOLDEN_FRAME
-
LAST_FRAME
+
1
)
#
define
FWD_RF_OFFSET
(
ref
)
(
ref
-
LAST_FRAME
)
#
if
CONFIG_EXT_REFS
#
define
BWD_REFS
(
ALTREF_FRAME
-
BWDREF_FRAME
+
1
)
#
define
BWD_RF_OFFSET
(
ref
)
(
ref
-
BWDREF_FRAME
)
#
else
#
define
BWD_REFS
1
#
define
BWD_RF_OFFSET
(
ref
)
(
ref
-
ALTREF_FRAME
)
#
endif
#
define
SINGLE_REFS
(
FWD_REFS
+
BWD_REFS
)
#
define
COMP_REFS
(
FWD_REFS
*
BWD_REFS
)
#
define
MODE_CTX_REF_FRAMES
(
TOTAL_REFS_PER_FRAME
+
COMP_REFS
)
#
if
CONFIG_SUPERTX
#
define
PARTITION_SUPERTX_CONTEXTS
2
#
define
MAX_SUPERTX_BLOCK_SIZE
BLOCK_32X32
#
endif
#
if
CONFIG_LOOP_RESTORATION
typedef
enum
{
RESTORE_NONE
=
0
RESTORE_WIENER
=
1
RESTORE_SGRPROJ
=
2
RESTORE_SWITCHABLE
RESTORE_SWITCHABLE_TYPES
=
RESTORE_SWITCHABLE
RESTORE_TYPES
}
RestorationType
;
#
endif
#
if
CONFIG_FRAME_SUPERRES
#
define
SUPERRES_SCALE_DENOMINATOR
16
#
define
SUPERRES_SCALE_BITS
3
#
define
SUPERRES_SCALE_NUMERATOR_MIN
8
#
endif
#
ifdef
__cplusplus
}
#
endif
#
endif
