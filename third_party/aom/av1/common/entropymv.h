#
ifndef
AV1_COMMON_ENTROPYMV_H_
#
define
AV1_COMMON_ENTROPYMV_H_
#
include
"
config
/
aom_config
.
h
"
#
include
"
aom_dsp
/
prob
.
h
"
#
include
"
av1
/
common
/
mv
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
struct
AV1Common
;
void
av1_init_mv_probs
(
struct
AV1Common
*
cm
)
;
#
define
MV_UPDATE_PROB
252
#
define
MV_JOINTS
4
typedef
enum
{
MV_JOINT_ZERO
=
0
MV_JOINT_HNZVZ
=
1
MV_JOINT_HZVNZ
=
2
MV_JOINT_HNZVNZ
=
3
}
MV_JOINT_TYPE
;
static
INLINE
int
mv_joint_vertical
(
MV_JOINT_TYPE
type
)
{
return
type
=
=
MV_JOINT_HZVNZ
|
|
type
=
=
MV_JOINT_HNZVNZ
;
}
static
INLINE
int
mv_joint_horizontal
(
MV_JOINT_TYPE
type
)
{
return
type
=
=
MV_JOINT_HNZVZ
|
|
type
=
=
MV_JOINT_HNZVNZ
;
}
#
define
MV_CLASSES
11
typedef
enum
{
MV_CLASS_0
=
0
MV_CLASS_1
=
1
MV_CLASS_2
=
2
MV_CLASS_3
=
3
MV_CLASS_4
=
4
MV_CLASS_5
=
5
MV_CLASS_6
=
6
MV_CLASS_7
=
7
MV_CLASS_8
=
8
MV_CLASS_9
=
9
MV_CLASS_10
=
10
}
MV_CLASS_TYPE
;
#
define
CLASS0_BITS
1
/
*
bits
at
integer
precision
for
class
0
*
/
#
define
CLASS0_SIZE
(
1
<
<
CLASS0_BITS
)
#
define
MV_OFFSET_BITS
(
MV_CLASSES
+
CLASS0_BITS
-
2
)
#
define
MV_BITS_CONTEXTS
6
#
define
MV_FP_SIZE
4
#
define
MV_MAX_BITS
(
MV_CLASSES
+
CLASS0_BITS
+
2
)
#
define
MV_MAX
(
(
1
<
<
MV_MAX_BITS
)
-
1
)
#
define
MV_VALS
(
(
MV_MAX
<
<
1
)
+
1
)
#
define
MV_IN_USE_BITS
14
#
define
MV_UPP
(
1
<
<
MV_IN_USE_BITS
)
#
define
MV_LOW
(
-
(
1
<
<
MV_IN_USE_BITS
)
)
typedef
struct
{
aom_cdf_prob
classes_cdf
[
CDF_SIZE
(
MV_CLASSES
)
]
;
aom_cdf_prob
class0_fp_cdf
[
CLASS0_SIZE
]
[
CDF_SIZE
(
MV_FP_SIZE
)
]
;
aom_cdf_prob
fp_cdf
[
CDF_SIZE
(
MV_FP_SIZE
)
]
;
aom_cdf_prob
sign_cdf
[
CDF_SIZE
(
2
)
]
;
aom_cdf_prob
class0_hp_cdf
[
CDF_SIZE
(
2
)
]
;
aom_cdf_prob
hp_cdf
[
CDF_SIZE
(
2
)
]
;
aom_cdf_prob
class0_cdf
[
CDF_SIZE
(
CLASS0_SIZE
)
]
;
aom_cdf_prob
bits_cdf
[
MV_OFFSET_BITS
]
[
CDF_SIZE
(
2
)
]
;
}
nmv_component
;
typedef
struct
{
aom_cdf_prob
joints_cdf
[
CDF_SIZE
(
MV_JOINTS
)
]
;
nmv_component
comps
[
2
]
;
}
nmv_context
;
static
INLINE
MV_JOINT_TYPE
av1_get_mv_joint
(
const
MV
*
mv
)
{
if
(
mv
-
>
row
=
=
0
)
{
return
mv
-
>
col
=
=
0
?
MV_JOINT_ZERO
:
MV_JOINT_HNZVZ
;
}
else
{
return
mv
-
>
col
=
=
0
?
MV_JOINT_HZVNZ
:
MV_JOINT_HNZVNZ
;
}
}
MV_CLASS_TYPE
av1_get_mv_class
(
int
z
int
*
offset
)
;
typedef
enum
{
MV_SUBPEL_NONE
=
-
1
MV_SUBPEL_LOW_PRECISION
=
0
MV_SUBPEL_HIGH_PRECISION
}
MvSubpelPrecision
;
#
ifdef
__cplusplus
}
#
endif
#
endif
