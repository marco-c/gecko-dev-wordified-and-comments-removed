#
ifndef
AOM_AV1_COMMON_AV1_COMMON_INT_H_
#
define
AOM_AV1_COMMON_AV1_COMMON_INT_H_
#
include
"
config
/
aom_config
.
h
"
#
include
"
config
/
av1_rtcd
.
h
"
#
include
"
aom
/
internal
/
aom_codec_internal
.
h
"
#
include
"
aom_dsp
/
flow_estimation
/
corner_detect
.
h
"
#
include
"
aom_util
/
aom_pthread
.
h
"
#
include
"
av1
/
common
/
alloccommon
.
h
"
#
include
"
av1
/
common
/
av1_loopfilter
.
h
"
#
include
"
av1
/
common
/
entropy
.
h
"
#
include
"
av1
/
common
/
entropymode
.
h
"
#
include
"
av1
/
common
/
entropymv
.
h
"
#
include
"
av1
/
common
/
enums
.
h
"
#
include
"
av1
/
common
/
frame_buffers
.
h
"
#
include
"
av1
/
common
/
mv
.
h
"
#
include
"
av1
/
common
/
quant_common
.
h
"
#
include
"
av1
/
common
/
restoration
.
h
"
#
include
"
av1
/
common
/
tile_common
.
h
"
#
include
"
av1
/
common
/
timing
.
h
"
#
include
"
aom_dsp
/
grain_params
.
h
"
#
include
"
aom_dsp
/
grain_table
.
h
"
#
include
"
aom_dsp
/
odintrin
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
if
defined
(
__clang__
)
&
&
defined
(
__has_warning
)
#
if
__has_feature
(
cxx_attributes
)
&
&
__has_warning
(
"
-
Wimplicit
-
fallthrough
"
)
#
define
AOM_FALLTHROUGH_INTENDED
[
[
clang
:
:
fallthrough
]
]
/
/
NOLINT
#
endif
#
elif
defined
(
__GNUC__
)
&
&
__GNUC__
>
=
7
#
define
AOM_FALLTHROUGH_INTENDED
__attribute__
(
(
fallthrough
)
)
/
/
NOLINT
#
endif
#
ifndef
AOM_FALLTHROUGH_INTENDED
#
define
AOM_FALLTHROUGH_INTENDED
\
do
{
\
}
while
(
0
)
#
endif
#
define
CDEF_MAX_STRENGTHS
16
#
define
FRAME_ID_LENGTH
15
#
define
DELTA_FRAME_ID_LENGTH
14
#
define
FRAME_CONTEXTS
(
FRAME_BUFFERS
+
1
)
#
define
FRAME_CONTEXT_DEFAULTS
(
FRAME_CONTEXTS
-
1
)
#
define
PRIMARY_REF_BITS
3
#
define
PRIMARY_REF_NONE
7
#
define
NUM_PING_PONG_BUFFERS
2
#
define
MAX_NUM_TEMPORAL_LAYERS
8
#
define
MAX_NUM_SPATIAL_LAYERS
4
#
define
MAX_NUM_OPERATING_POINTS
\
(
MAX_NUM_TEMPORAL_LAYERS
*
MAX_NUM_SPATIAL_LAYERS
)
#
define
TXCOEFF_TIMER
0
#
define
TXCOEFF_COST_TIMER
0
enum
{
SINGLE_REFERENCE
=
0
COMPOUND_REFERENCE
=
1
REFERENCE_MODE_SELECT
=
2
REFERENCE_MODES
=
3
}
UENUM1BYTE
(
REFERENCE_MODE
)
;
enum
{
REFRESH_FRAME_CONTEXT_DISABLED
REFRESH_FRAME_CONTEXT_BACKWARD
}
UENUM1BYTE
(
REFRESH_FRAME_CONTEXT_MODE
)
;
#
define
MFMV_STACK_SIZE
3
typedef
struct
{
int_mv
mfmv0
;
uint8_t
ref_frame_offset
;
}
TPL_MV_REF
;
typedef
struct
{
int_mv
mv
;
MV_REFERENCE_FRAME
ref_frame
;
}
MV_REF
;
typedef
struct
RefCntBuffer
{
int
ref_count
;
unsigned
int
order_hint
;
unsigned
int
ref_order_hints
[
INTER_REFS_PER_FRAME
]
;
unsigned
int
display_order_hint
;
unsigned
int
ref_display_order_hint
[
INTER_REFS_PER_FRAME
]
;
unsigned
int
pyramid_level
;
MV_REF
*
mvs
;
uint8_t
*
seg_map
;
struct
segmentation
seg
;
int
mi_rows
;
int
mi_cols
;
int
width
;
int
height
;
WarpedMotionParams
global_motion
[
REF_FRAMES
]
;
int
showable_frame
;
uint8_t
film_grain_params_present
;
aom_film_grain_t
film_grain_params
;
aom_codec_frame_buffer_t
raw_frame_buffer
;
YV12_BUFFER_CONFIG
buf
;
int
temporal_id
;
int
spatial_id
;
FRAME_TYPE
frame_type
;
int
interp_filter_selected
[
SWITCHABLE
]
;
int8_t
ref_deltas
[
REF_FRAMES
]
;
int8_t
mode_deltas
[
MAX_MODE_LF_DELTAS
]
;
FRAME_CONTEXT
frame_context
;
}
RefCntBuffer
;
typedef
struct
BufferPool
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_t
pool_mutex
;
#
endif
void
*
cb_priv
;
aom_get_frame_buffer_cb_fn_t
get_fb_cb
;
aom_release_frame_buffer_cb_fn_t
release_fb_cb
;
RefCntBuffer
*
frame_bufs
;
uint8_t
num_frame_bufs
;
InternalFrameBufferList
int_frame_buffers
;
}
BufferPool
;
typedef
struct
{
uint16_t
*
colbuf
[
MAX_MB_PLANE
]
;
uint16_t
*
linebuf
[
MAX_MB_PLANE
]
;
uint16_t
*
srcbuf
;
size_t
allocated_colbuf_size
[
MAX_MB_PLANE
]
;
size_t
allocated_linebuf_size
[
MAX_MB_PLANE
]
;
size_t
allocated_srcbuf_size
;
int
cdef_damping
;
int
nb_cdef_strengths
;
int
cdef_strengths
[
CDEF_MAX_STRENGTHS
]
;
int
cdef_uv_strengths
[
CDEF_MAX_STRENGTHS
]
;
int
cdef_bits
;
int
allocated_mi_rows
;
int
allocated_num_workers
;
}
CdefInfo
;
typedef
struct
{
int
delta_q_present_flag
;
int
delta_q_res
;
int
delta_lf_present_flag
;
int
delta_lf_res
;
int
delta_lf_multi
;
}
DeltaQInfo
;
typedef
struct
{
int
enable_order_hint
;
int
order_hint_bits_minus_1
;
int
enable_dist_wtd_comp
;
int
enable_ref_frame_mvs
;
}
OrderHintInfo
;
typedef
struct
SequenceHeader
{
int
num_bits_width
;
int
num_bits_height
;
int
max_frame_width
;
int
max_frame_height
;
uint8_t
frame_id_numbers_present_flag
;
int
frame_id_length
;
int
delta_frame_id_length
;
BLOCK_SIZE
sb_size
;
int
mib_size
;
int
mib_size_log2
;
OrderHintInfo
order_hint_info
;
uint8_t
force_screen_content_tools
;
uint8_t
still_picture
;
uint8_t
reduced_still_picture_hdr
;
uint8_t
force_integer_mv
;
uint8_t
enable_filter_intra
;
uint8_t
enable_intra_edge_filter
;
uint8_t
enable_interintra_compound
;
uint8_t
enable_masked_compound
;
uint8_t
enable_dual_filter
;
uint8_t
enable_warped_motion
;
uint8_t
enable_superres
;
uint8_t
enable_cdef
;
uint8_t
enable_restoration
;
BITSTREAM_PROFILE
profile
;
aom_bit_depth_t
bit_depth
;
uint8_t
use_highbitdepth
;
uint8_t
monochrome
;
aom_color_primaries_t
color_primaries
;
aom_transfer_characteristics_t
transfer_characteristics
;
aom_matrix_coefficients_t
matrix_coefficients
;
int
color_range
;
int
subsampling_x
;
int
subsampling_y
;
aom_chroma_sample_position_t
chroma_sample_position
;
uint8_t
separate_uv_delta_q
;
uint8_t
film_grain_params_present
;
int
operating_points_cnt_minus_1
;
int
operating_point_idc
[
MAX_NUM_OPERATING_POINTS
]
;
int
timing_info_present
;
aom_timing_info_t
timing_info
;
uint8_t
decoder_model_info_present_flag
;
aom_dec_model_info_t
decoder_model_info
;
uint8_t
display_model_info_present_flag
;
AV1_LEVEL
seq_level_idx
[
MAX_NUM_OPERATING_POINTS
]
;
uint8_t
tier
[
MAX_NUM_OPERATING_POINTS
]
;
aom_dec_model_op_parameters_t
op_params
[
MAX_NUM_OPERATING_POINTS
+
1
]
;
}
SequenceHeader
;
typedef
struct
{
int
skip_mode_allowed
;
int
skip_mode_flag
;
int
ref_frame_idx_0
;
int
ref_frame_idx_1
;
}
SkipModeInfo
;
typedef
struct
{
FRAME_TYPE
frame_type
;
REFERENCE_MODE
reference_mode
;
unsigned
int
order_hint
;
unsigned
int
display_order_hint
;
unsigned
int
pyramid_level
;
unsigned
int
frame_number
;
SkipModeInfo
skip_mode_info
;
int
refresh_frame_flags
;
int
frame_refs_short_signaling
;
}
CurrentFrame
;
typedef
struct
{
bool
disable_cdf_update
;
bool
allow_high_precision_mv
;
bool
cur_frame_force_integer_mv
;
bool
allow_screen_content_tools
;
bool
allow_intrabc
;
bool
allow_warped_motion
;
bool
allow_ref_frame_mvs
;
bool
coded_lossless
;
bool
all_lossless
;
bool
reduced_tx_set_used
;
bool
error_resilient_mode
;
bool
switchable_motion_mode
;
TX_MODE
tx_mode
;
InterpFilter
interp_filter
;
int
primary_ref_frame
;
int
byte_alignment
;
REFRESH_FRAME_CONTEXT_MODE
refresh_frame_context
;
}
FeatureFlags
;
typedef
struct
CommonTileParams
{
int
cols
;
int
rows
;
int
max_width_sb
;
int
max_height_sb
;
int
min_inner_width
;
int
uniform_spacing
;
int
log2_cols
;
int
log2_rows
;
int
width
;
int
height
;
int
min_log2_cols
;
int
min_log2_rows
;
int
max_log2_cols
;
int
max_log2_rows
;
int
min_log2
;
int
col_start_sb
[
MAX_TILE_COLS
+
1
]
;
int
row_start_sb
[
MAX_TILE_ROWS
+
1
]
;
unsigned
int
large_scale
;
unsigned
int
single_tile_decoding
;
}
CommonTileParams
;
typedef
struct
CommonModeInfoParams
CommonModeInfoParams
;
struct
CommonModeInfoParams
{
int
mb_rows
;
int
mb_cols
;
int
MBs
;
int
mi_rows
;
int
mi_cols
;
MB_MODE_INFO
*
mi_alloc
;
int
mi_alloc_size
;
int
mi_alloc_stride
;
BLOCK_SIZE
mi_alloc_bsize
;
MB_MODE_INFO
*
*
mi_grid_base
;
int
mi_grid_size
;
int
mi_stride
;
TX_TYPE
*
tx_type_map
;
void
(
*
free_mi
)
(
struct
CommonModeInfoParams
*
mi_params
)
;
void
(
*
setup_mi
)
(
struct
CommonModeInfoParams
*
mi_params
)
;
void
(
*
set_mb_mi
)
(
struct
CommonModeInfoParams
*
mi_params
int
width
int
height
BLOCK_SIZE
min_partition_size
)
;
}
;
typedef
struct
CommonQuantParams
CommonQuantParams
;
struct
CommonQuantParams
{
int
base_qindex
;
int
y_dc_delta_q
;
int
u_dc_delta_q
;
int
v_dc_delta_q
;
int
u_ac_delta_q
;
int
v_ac_delta_q
;
int16_t
y_dequant_QTX
[
MAX_SEGMENTS
]
[
2
]
;
int16_t
u_dequant_QTX
[
MAX_SEGMENTS
]
[
2
]
;
int16_t
v_dequant_QTX
[
MAX_SEGMENTS
]
[
2
]
;
const
qm_val_t
*
giqmatrix
[
NUM_QM_LEVELS
]
[
3
]
[
TX_SIZES_ALL
]
;
const
qm_val_t
*
gqmatrix
[
NUM_QM_LEVELS
]
[
3
]
[
TX_SIZES_ALL
]
;
const
qm_val_t
*
y_iqmatrix
[
MAX_SEGMENTS
]
[
TX_SIZES_ALL
]
;
const
qm_val_t
*
u_iqmatrix
[
MAX_SEGMENTS
]
[
TX_SIZES_ALL
]
;
const
qm_val_t
*
v_iqmatrix
[
MAX_SEGMENTS
]
[
TX_SIZES_ALL
]
;
bool
using_qmatrix
;
int
qmatrix_level_y
;
int
qmatrix_level_u
;
int
qmatrix_level_v
;
}
;
typedef
struct
CommonContexts
CommonContexts
;
struct
CommonContexts
{
PARTITION_CONTEXT
*
*
partition
;
ENTROPY_CONTEXT
*
*
entropy
[
MAX_MB_PLANE
]
;
TXFM_CONTEXT
*
*
txfm
;
int
num_planes
;
int
num_tile_rows
;
int
num_mi_cols
;
}
;
typedef
struct
AV1Common
{
CurrentFrame
current_frame
;
struct
aom_internal_error_info
*
error
;
int
width
;
int
height
;
int
render_width
;
int
render_height
;
int
superres_upscaled_width
;
int
superres_upscaled_height
;
uint8_t
superres_scale_denominator
;
uint32_t
buffer_removal_times
[
MAX_NUM_OPERATING_POINTS
+
1
]
;
uint32_t
frame_presentation_time
;
RefCntBuffer
*
prev_frame
;
RefCntBuffer
*
cur_frame
;
int
remapped_ref_idx
[
REF_FRAMES
]
;
struct
scale_factors
sf_identity
;
struct
scale_factors
ref_scale_factors
[
REF_FRAMES
]
;
RefCntBuffer
*
ref_frame_map
[
REF_FRAMES
]
;
int
show_frame
;
int
showable_frame
;
int
show_existing_frame
;
FeatureFlags
features
;
CommonModeInfoParams
mi_params
;
#
if
CONFIG_ENTROPY_STATS
int
coef_cdf_category
;
#
endif
CommonQuantParams
quant_params
;
struct
segmentation
seg
;
uint8_t
*
last_frame_seg_map
;
loop_filter_info_n
lf_info
;
struct
loopfilter
lf
;
RestorationInfo
rst_info
[
MAX_MB_PLANE
]
;
int32_t
*
rst_tmpbuf
;
RestorationLineBuffers
*
rlbs
;
YV12_BUFFER_CONFIG
rst_frame
;
CdefInfo
cdef_info
;
aom_film_grain_t
film_grain_params
;
DeltaQInfo
delta_q_info
;
WarpedMotionParams
global_motion
[
REF_FRAMES
]
;
SequenceHeader
*
seq_params
;
FRAME_CONTEXT
*
fc
;
FRAME_CONTEXT
*
default_frame_context
;
CommonTileParams
tiles
;
BufferPool
*
buffer_pool
;
CommonContexts
above_contexts
;
int
current_frame_id
;
int
ref_frame_id
[
REF_FRAMES
]
;
TPL_MV_REF
*
tpl_mvs
;
int
tpl_mvs_mem_size
;
int
ref_frame_sign_bias
[
REF_FRAMES
]
;
int8_t
ref_frame_side
[
REF_FRAMES
]
;
int
temporal_layer_id
;
int
spatial_layer_id
;
#
if
TXCOEFF_TIMER
int64_t
cum_txcoeff_timer
;
int64_t
txcoeff_timer
;
int
txb_count
;
#
endif
#
if
TXCOEFF_COST_TIMER
int64_t
cum_txcoeff_cost_timer
;
int64_t
txcoeff_cost_timer
;
int64_t
txcoeff_cost_count
;
#
endif
}
AV1_COMMON
;
static
void
lock_buffer_pool
(
BufferPool
*
const
pool
)
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_lock
(
&
pool
-
>
pool_mutex
)
;
#
else
(
void
)
pool
;
#
endif
}
static
void
unlock_buffer_pool
(
BufferPool
*
const
pool
)
{
#
if
CONFIG_MULTITHREAD
pthread_mutex_unlock
(
&
pool
-
>
pool_mutex
)
;
#
else
(
void
)
pool
;
#
endif
}
static
INLINE
YV12_BUFFER_CONFIG
*
get_ref_frame
(
AV1_COMMON
*
cm
int
index
)
{
if
(
index
<
0
|
|
index
>
=
REF_FRAMES
)
return
NULL
;
if
(
cm
-
>
ref_frame_map
[
index
]
=
=
NULL
)
return
NULL
;
return
&
cm
-
>
ref_frame_map
[
index
]
-
>
buf
;
}
static
INLINE
int
get_free_fb
(
AV1_COMMON
*
cm
)
{
RefCntBuffer
*
const
frame_bufs
=
cm
-
>
buffer_pool
-
>
frame_bufs
;
int
i
;
lock_buffer_pool
(
cm
-
>
buffer_pool
)
;
const
int
num_frame_bufs
=
cm
-
>
buffer_pool
-
>
num_frame_bufs
;
for
(
i
=
0
;
i
<
num_frame_bufs
;
+
+
i
)
if
(
frame_bufs
[
i
]
.
ref_count
=
=
0
)
break
;
if
(
i
!
=
num_frame_bufs
)
{
if
(
frame_bufs
[
i
]
.
buf
.
use_external_reference_buffers
)
{
YV12_BUFFER_CONFIG
*
ybf
=
&
frame_bufs
[
i
]
.
buf
;
ybf
-
>
y_buffer
=
ybf
-
>
store_buf_adr
[
0
]
;
ybf
-
>
u_buffer
=
ybf
-
>
store_buf_adr
[
1
]
;
ybf
-
>
v_buffer
=
ybf
-
>
store_buf_adr
[
2
]
;
ybf
-
>
use_external_reference_buffers
=
0
;
}
frame_bufs
[
i
]
.
ref_count
=
1
;
}
else
{
assert
(
0
&
&
"
Ran
out
of
free
frame
buffers
.
Likely
a
reference
leak
.
"
)
;
i
=
INVALID_IDX
;
}
unlock_buffer_pool
(
cm
-
>
buffer_pool
)
;
return
i
;
}
static
INLINE
RefCntBuffer
*
assign_cur_frame_new_fb
(
AV1_COMMON
*
const
cm
)
{
if
(
cm
-
>
cur_frame
!
=
NULL
)
{
-
-
cm
-
>
cur_frame
-
>
ref_count
;
cm
-
>
cur_frame
=
NULL
;
}
const
int
new_fb_idx
=
get_free_fb
(
cm
)
;
if
(
new_fb_idx
=
=
INVALID_IDX
)
return
NULL
;
cm
-
>
cur_frame
=
&
cm
-
>
buffer_pool
-
>
frame_bufs
[
new_fb_idx
]
;
#
if
CONFIG_AV1_ENCODER
&
&
!
CONFIG_REALTIME_ONLY
aom_invalidate_pyramid
(
cm
-
>
cur_frame
-
>
buf
.
y_pyramid
)
;
av1_invalidate_corner_list
(
cm
-
>
cur_frame
-
>
buf
.
corners
)
;
#
endif
av1_zero
(
cm
-
>
cur_frame
-
>
interp_filter_selected
)
;
return
cm
-
>
cur_frame
;
}
static
INLINE
void
assign_frame_buffer_p
(
RefCntBuffer
*
*
lhs_ptr
RefCntBuffer
*
rhs_ptr
)
{
RefCntBuffer
*
const
old_ptr
=
*
lhs_ptr
;
if
(
old_ptr
!
=
NULL
)
{
assert
(
old_ptr
-
>
ref_count
>
0
)
;
-
-
old_ptr
-
>
ref_count
;
}
*
lhs_ptr
=
rhs_ptr
;
+
+
rhs_ptr
-
>
ref_count
;
}
static
INLINE
int
frame_is_intra_only
(
const
AV1_COMMON
*
const
cm
)
{
return
cm
-
>
current_frame
.
frame_type
=
=
KEY_FRAME
|
|
cm
-
>
current_frame
.
frame_type
=
=
INTRA_ONLY_FRAME
;
}
static
INLINE
int
frame_is_sframe
(
const
AV1_COMMON
*
cm
)
{
return
cm
-
>
current_frame
.
frame_type
=
=
S_FRAME
;
}
static
INLINE
int
get_ref_frame_map_idx
(
const
AV1_COMMON
*
const
cm
const
MV_REFERENCE_FRAME
ref_frame
)
{
return
(
ref_frame
>
=
LAST_FRAME
&
&
ref_frame
<
=
EXTREF_FRAME
)
?
cm
-
>
remapped_ref_idx
[
ref_frame
-
LAST_FRAME
]
:
INVALID_IDX
;
}
static
INLINE
RefCntBuffer
*
get_ref_frame_buf
(
const
AV1_COMMON
*
const
cm
const
MV_REFERENCE_FRAME
ref_frame
)
{
const
int
map_idx
=
get_ref_frame_map_idx
(
cm
ref_frame
)
;
return
(
map_idx
!
=
INVALID_IDX
)
?
cm
-
>
ref_frame_map
[
map_idx
]
:
NULL
;
}
static
INLINE
const
struct
scale_factors
*
get_ref_scale_factors_const
(
const
AV1_COMMON
*
const
cm
const
MV_REFERENCE_FRAME
ref_frame
)
{
const
int
map_idx
=
get_ref_frame_map_idx
(
cm
ref_frame
)
;
return
(
map_idx
!
=
INVALID_IDX
)
?
&
cm
-
>
ref_scale_factors
[
map_idx
]
:
NULL
;
}
static
INLINE
struct
scale_factors
*
get_ref_scale_factors
(
AV1_COMMON
*
const
cm
const
MV_REFERENCE_FRAME
ref_frame
)
{
const
int
map_idx
=
get_ref_frame_map_idx
(
cm
ref_frame
)
;
return
(
map_idx
!
=
INVALID_IDX
)
?
&
cm
-
>
ref_scale_factors
[
map_idx
]
:
NULL
;
}
static
INLINE
RefCntBuffer
*
get_primary_ref_frame_buf
(
const
AV1_COMMON
*
const
cm
)
{
const
int
primary_ref_frame
=
cm
-
>
features
.
primary_ref_frame
;
if
(
primary_ref_frame
=
=
PRIMARY_REF_NONE
)
return
NULL
;
const
int
map_idx
=
get_ref_frame_map_idx
(
cm
primary_ref_frame
+
1
)
;
return
(
map_idx
!
=
INVALID_IDX
)
?
cm
-
>
ref_frame_map
[
map_idx
]
:
NULL
;
}
static
INLINE
int
frame_might_allow_ref_frame_mvs
(
const
AV1_COMMON
*
cm
)
{
return
!
cm
-
>
features
.
error_resilient_mode
&
&
cm
-
>
seq_params
-
>
order_hint_info
.
enable_ref_frame_mvs
&
&
cm
-
>
seq_params
-
>
order_hint_info
.
enable_order_hint
&
&
!
frame_is_intra_only
(
cm
)
;
}
static
INLINE
int
frame_might_allow_warped_motion
(
const
AV1_COMMON
*
cm
)
{
return
!
cm
-
>
features
.
error_resilient_mode
&
&
!
frame_is_intra_only
(
cm
)
&
&
cm
-
>
seq_params
-
>
enable_warped_motion
;
}
static
INLINE
void
ensure_mv_buffer
(
RefCntBuffer
*
buf
AV1_COMMON
*
cm
)
{
const
int
buf_rows
=
buf
-
>
mi_rows
;
const
int
buf_cols
=
buf
-
>
mi_cols
;
const
CommonModeInfoParams
*
const
mi_params
=
&
cm
-
>
mi_params
;
if
(
buf
-
>
mvs
=
=
NULL
|
|
buf_rows
!
=
mi_params
-
>
mi_rows
|
|
buf_cols
!
=
mi_params
-
>
mi_cols
)
{
aom_free
(
buf
-
>
mvs
)
;
buf
-
>
mi_rows
=
mi_params
-
>
mi_rows
;
buf
-
>
mi_cols
=
mi_params
-
>
mi_cols
;
CHECK_MEM_ERROR
(
cm
buf
-
>
mvs
(
MV_REF
*
)
aom_calloc
(
(
(
mi_params
-
>
mi_rows
+
1
)
>
>
1
)
*
(
(
mi_params
-
>
mi_cols
+
1
)
>
>
1
)
sizeof
(
*
buf
-
>
mvs
)
)
)
;
aom_free
(
buf
-
>
seg_map
)
;
CHECK_MEM_ERROR
(
cm
buf
-
>
seg_map
(
uint8_t
*
)
aom_calloc
(
mi_params
-
>
mi_rows
*
mi_params
-
>
mi_cols
sizeof
(
*
buf
-
>
seg_map
)
)
)
;
}
const
int
mem_size
=
(
(
mi_params
-
>
mi_rows
+
MAX_MIB_SIZE
)
>
>
1
)
*
(
mi_params
-
>
mi_stride
>
>
1
)
;
if
(
cm
-
>
tpl_mvs
=
=
NULL
|
|
cm
-
>
tpl_mvs_mem_size
<
mem_size
)
{
aom_free
(
cm
-
>
tpl_mvs
)
;
CHECK_MEM_ERROR
(
cm
cm
-
>
tpl_mvs
(
TPL_MV_REF
*
)
aom_calloc
(
mem_size
sizeof
(
*
cm
-
>
tpl_mvs
)
)
)
;
cm
-
>
tpl_mvs_mem_size
=
mem_size
;
}
}
void
cfl_init
(
CFL_CTX
*
cfl
const
SequenceHeader
*
seq_params
)
;
static
INLINE
int
av1_num_planes
(
const
AV1_COMMON
*
cm
)
{
return
cm
-
>
seq_params
-
>
monochrome
?
1
:
MAX_MB_PLANE
;
}
static
INLINE
void
av1_init_above_context
(
CommonContexts
*
above_contexts
int
num_planes
int
tile_row
MACROBLOCKD
*
xd
)
{
for
(
int
i
=
0
;
i
<
num_planes
;
+
+
i
)
{
xd
-
>
above_entropy_context
[
i
]
=
above_contexts
-
>
entropy
[
i
]
[
tile_row
]
;
}
xd
-
>
above_partition_context
=
above_contexts
-
>
partition
[
tile_row
]
;
xd
-
>
above_txfm_context
=
above_contexts
-
>
txfm
[
tile_row
]
;
}
static
INLINE
void
av1_init_macroblockd
(
AV1_COMMON
*
cm
MACROBLOCKD
*
xd
)
{
const
int
num_planes
=
av1_num_planes
(
cm
)
;
const
CommonQuantParams
*
const
quant_params
=
&
cm
-
>
quant_params
;
for
(
int
i
=
0
;
i
<
num_planes
;
+
+
i
)
{
if
(
xd
-
>
plane
[
i
]
.
plane_type
=
=
PLANE_TYPE_Y
)
{
memcpy
(
xd
-
>
plane
[
i
]
.
seg_dequant_QTX
quant_params
-
>
y_dequant_QTX
sizeof
(
quant_params
-
>
y_dequant_QTX
)
)
;
memcpy
(
xd
-
>
plane
[
i
]
.
seg_iqmatrix
quant_params
-
>
y_iqmatrix
sizeof
(
quant_params
-
>
y_iqmatrix
)
)
;
}
else
{
if
(
i
=
=
AOM_PLANE_U
)
{
memcpy
(
xd
-
>
plane
[
i
]
.
seg_dequant_QTX
quant_params
-
>
u_dequant_QTX
sizeof
(
quant_params
-
>
u_dequant_QTX
)
)
;
memcpy
(
xd
-
>
plane
[
i
]
.
seg_iqmatrix
quant_params
-
>
u_iqmatrix
sizeof
(
quant_params
-
>
u_iqmatrix
)
)
;
}
else
{
memcpy
(
xd
-
>
plane
[
i
]
.
seg_dequant_QTX
quant_params
-
>
v_dequant_QTX
sizeof
(
quant_params
-
>
v_dequant_QTX
)
)
;
memcpy
(
xd
-
>
plane
[
i
]
.
seg_iqmatrix
quant_params
-
>
v_iqmatrix
sizeof
(
quant_params
-
>
v_iqmatrix
)
)
;
}
}
}
xd
-
>
mi_stride
=
cm
-
>
mi_params
.
mi_stride
;
xd
-
>
error_info
=
cm
-
>
error
;
cfl_init
(
&
xd
-
>
cfl
cm
-
>
seq_params
)
;
}
static
INLINE
void
set_entropy_context
(
MACROBLOCKD
*
xd
int
mi_row
int
mi_col
const
int
num_planes
)
{
int
i
;
int
row_offset
=
mi_row
;
int
col_offset
=
mi_col
;
for
(
i
=
0
;
i
<
num_planes
;
+
+
i
)
{
struct
macroblockd_plane
*
const
pd
=
&
xd
-
>
plane
[
i
]
;
const
BLOCK_SIZE
bsize
=
xd
-
>
mi
[
0
]
-
>
bsize
;
if
(
pd
-
>
subsampling_y
&
&
(
mi_row
&
0x01
)
&
&
(
mi_size_high
[
bsize
]
=
=
1
)
)
row_offset
=
mi_row
-
1
;
if
(
pd
-
>
subsampling_x
&
&
(
mi_col
&
0x01
)
&
&
(
mi_size_wide
[
bsize
]
=
=
1
)
)
col_offset
=
mi_col
-
1
;
int
above_idx
=
col_offset
;
int
left_idx
=
row_offset
&
MAX_MIB_MASK
;
pd
-
>
above_entropy_context
=
&
xd
-
>
above_entropy_context
[
i
]
[
above_idx
>
>
pd
-
>
subsampling_x
]
;
pd
-
>
left_entropy_context
=
&
xd
-
>
left_entropy_context
[
i
]
[
left_idx
>
>
pd
-
>
subsampling_y
]
;
}
}
static
INLINE
int
calc_mi_size
(
int
len
)
{
return
ALIGN_POWER_OF_TWO
(
len
MAX_MIB_SIZE_LOG2
)
;
}
static
INLINE
void
set_plane_n4
(
MACROBLOCKD
*
const
xd
int
bw
int
bh
const
int
num_planes
)
{
int
i
;
for
(
i
=
0
;
i
<
num_planes
;
i
+
+
)
{
xd
-
>
plane
[
i
]
.
width
=
(
bw
*
MI_SIZE
)
>
>
xd
-
>
plane
[
i
]
.
subsampling_x
;
xd
-
>
plane
[
i
]
.
height
=
(
bh
*
MI_SIZE
)
>
>
xd
-
>
plane
[
i
]
.
subsampling_y
;
xd
-
>
plane
[
i
]
.
width
=
AOMMAX
(
xd
-
>
plane
[
i
]
.
width
4
)
;
xd
-
>
plane
[
i
]
.
height
=
AOMMAX
(
xd
-
>
plane
[
i
]
.
height
4
)
;
}
}
static
INLINE
void
set_mi_row_col
(
MACROBLOCKD
*
xd
const
TileInfo
*
const
tile
int
mi_row
int
bh
int
mi_col
int
bw
int
mi_rows
int
mi_cols
)
{
xd
-
>
mb_to_top_edge
=
-
GET_MV_SUBPEL
(
mi_row
*
MI_SIZE
)
;
xd
-
>
mb_to_bottom_edge
=
GET_MV_SUBPEL
(
(
mi_rows
-
bh
-
mi_row
)
*
MI_SIZE
)
;
xd
-
>
mb_to_left_edge
=
-
GET_MV_SUBPEL
(
(
mi_col
*
MI_SIZE
)
)
;
xd
-
>
mb_to_right_edge
=
GET_MV_SUBPEL
(
(
mi_cols
-
bw
-
mi_col
)
*
MI_SIZE
)
;
xd
-
>
mi_row
=
mi_row
;
xd
-
>
mi_col
=
mi_col
;
xd
-
>
up_available
=
(
mi_row
>
tile
-
>
mi_row_start
)
;
const
int
ss_x
=
xd
-
>
plane
[
1
]
.
subsampling_x
;
const
int
ss_y
=
xd
-
>
plane
[
1
]
.
subsampling_y
;
xd
-
>
left_available
=
(
mi_col
>
tile
-
>
mi_col_start
)
;
xd
-
>
chroma_up_available
=
xd
-
>
up_available
;
xd
-
>
chroma_left_available
=
xd
-
>
left_available
;
if
(
ss_x
&
&
bw
<
mi_size_wide
[
BLOCK_8X8
]
)
xd
-
>
chroma_left_available
=
(
mi_col
-
1
)
>
tile
-
>
mi_col_start
;
if
(
ss_y
&
&
bh
<
mi_size_high
[
BLOCK_8X8
]
)
xd
-
>
chroma_up_available
=
(
mi_row
-
1
)
>
tile
-
>
mi_row_start
;
if
(
xd
-
>
up_available
)
{
xd
-
>
above_mbmi
=
xd
-
>
mi
[
-
xd
-
>
mi_stride
]
;
}
else
{
xd
-
>
above_mbmi
=
NULL
;
}
if
(
xd
-
>
left_available
)
{
xd
-
>
left_mbmi
=
xd
-
>
mi
[
-
1
]
;
}
else
{
xd
-
>
left_mbmi
=
NULL
;
}
const
int
chroma_ref
=
(
(
mi_row
&
0x01
)
|
|
!
(
bh
&
0x01
)
|
|
!
ss_y
)
&
&
(
(
mi_col
&
0x01
)
|
|
!
(
bw
&
0x01
)
|
|
!
ss_x
)
;
xd
-
>
is_chroma_ref
=
chroma_ref
;
if
(
chroma_ref
)
{
MB_MODE_INFO
*
*
base_mi
=
&
xd
-
>
mi
[
-
(
mi_row
&
ss_y
)
*
xd
-
>
mi_stride
-
(
mi_col
&
ss_x
)
]
;
MB_MODE_INFO
*
chroma_above_mi
=
xd
-
>
chroma_up_available
?
base_mi
[
-
xd
-
>
mi_stride
+
ss_x
]
:
NULL
;
xd
-
>
chroma_above_mbmi
=
chroma_above_mi
;
MB_MODE_INFO
*
chroma_left_mi
=
xd
-
>
chroma_left_available
?
base_mi
[
ss_y
*
xd
-
>
mi_stride
-
1
]
:
NULL
;
xd
-
>
chroma_left_mbmi
=
chroma_left_mi
;
}
xd
-
>
height
=
bh
;
xd
-
>
width
=
bw
;
xd
-
>
is_last_vertical_rect
=
0
;
if
(
xd
-
>
width
<
xd
-
>
height
)
{
if
(
!
(
(
mi_col
+
xd
-
>
width
)
&
(
xd
-
>
height
-
1
)
)
)
{
xd
-
>
is_last_vertical_rect
=
1
;
}
}
xd
-
>
is_first_horizontal_rect
=
0
;
if
(
xd
-
>
width
>
xd
-
>
height
)
if
(
!
(
mi_row
&
(
xd
-
>
width
-
1
)
)
)
xd
-
>
is_first_horizontal_rect
=
1
;
}
static
INLINE
aom_cdf_prob
*
get_y_mode_cdf
(
FRAME_CONTEXT
*
tile_ctx
const
MB_MODE_INFO
*
above_mi
const
MB_MODE_INFO
*
left_mi
)
{
const
PREDICTION_MODE
above
=
av1_above_block_mode
(
above_mi
)
;
const
PREDICTION_MODE
left
=
av1_left_block_mode
(
left_mi
)
;
const
int
above_ctx
=
intra_mode_context
[
above
]
;
const
int
left_ctx
=
intra_mode_context
[
left
]
;
return
tile_ctx
-
>
kf_y_cdf
[
above_ctx
]
[
left_ctx
]
;
}
static
INLINE
void
update_partition_context
(
MACROBLOCKD
*
xd
int
mi_row
int
mi_col
BLOCK_SIZE
subsize
BLOCK_SIZE
bsize
)
{
PARTITION_CONTEXT
*
const
above_ctx
=
xd
-
>
above_partition_context
+
mi_col
;
PARTITION_CONTEXT
*
const
left_ctx
=
xd
-
>
left_partition_context
+
(
mi_row
&
MAX_MIB_MASK
)
;
const
int
bw
=
mi_size_wide
[
bsize
]
;
const
int
bh
=
mi_size_high
[
bsize
]
;
memset
(
above_ctx
partition_context_lookup
[
subsize
]
.
above
bw
)
;
memset
(
left_ctx
partition_context_lookup
[
subsize
]
.
left
bh
)
;
}
static
INLINE
int
is_chroma_reference
(
int
mi_row
int
mi_col
BLOCK_SIZE
bsize
int
subsampling_x
int
subsampling_y
)
{
assert
(
bsize
<
BLOCK_SIZES_ALL
)
;
const
int
bw
=
mi_size_wide
[
bsize
]
;
const
int
bh
=
mi_size_high
[
bsize
]
;
int
ref_pos
=
(
(
mi_row
&
0x01
)
|
|
!
(
bh
&
0x01
)
|
|
!
subsampling_y
)
&
&
(
(
mi_col
&
0x01
)
|
|
!
(
bw
&
0x01
)
|
|
!
subsampling_x
)
;
return
ref_pos
;
}
static
INLINE
aom_cdf_prob
cdf_element_prob
(
const
aom_cdf_prob
*
cdf
size_t
element
)
{
assert
(
cdf
!
=
NULL
)
;
return
(
element
>
0
?
cdf
[
element
-
1
]
:
CDF_PROB_TOP
)
-
cdf
[
element
]
;
}
static
INLINE
void
partition_gather_horz_alike
(
aom_cdf_prob
*
out
const
aom_cdf_prob
*
const
in
BLOCK_SIZE
bsize
)
{
(
void
)
bsize
;
out
[
0
]
=
CDF_PROB_TOP
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_HORZ
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_SPLIT
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_HORZ_A
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_HORZ_B
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_VERT_A
)
;
if
(
bsize
!
=
BLOCK_128X128
)
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_HORZ_4
)
;
out
[
0
]
=
AOM_ICDF
(
out
[
0
]
)
;
out
[
1
]
=
AOM_ICDF
(
CDF_PROB_TOP
)
;
}
static
INLINE
void
partition_gather_vert_alike
(
aom_cdf_prob
*
out
const
aom_cdf_prob
*
const
in
BLOCK_SIZE
bsize
)
{
(
void
)
bsize
;
out
[
0
]
=
CDF_PROB_TOP
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_VERT
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_SPLIT
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_HORZ_A
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_VERT_A
)
;
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_VERT_B
)
;
if
(
bsize
!
=
BLOCK_128X128
)
out
[
0
]
-
=
cdf_element_prob
(
in
PARTITION_VERT_4
)
;
out
[
0
]
=
AOM_ICDF
(
out
[
0
]
)
;
out
[
1
]
=
AOM_ICDF
(
CDF_PROB_TOP
)
;
}
static
INLINE
void
update_ext_partition_context
(
MACROBLOCKD
*
xd
int
mi_row
int
mi_col
BLOCK_SIZE
subsize
BLOCK_SIZE
bsize
PARTITION_TYPE
partition
)
{
if
(
bsize
>
=
BLOCK_8X8
)
{
const
int
hbs
=
mi_size_wide
[
bsize
]
/
2
;
BLOCK_SIZE
bsize2
=
get_partition_subsize
(
bsize
PARTITION_SPLIT
)
;
switch
(
partition
)
{
case
PARTITION_SPLIT
:
if
(
bsize
!
=
BLOCK_8X8
)
break
;
AOM_FALLTHROUGH_INTENDED
;
case
PARTITION_NONE
:
case
PARTITION_HORZ
:
case
PARTITION_VERT
:
case
PARTITION_HORZ_4
:
case
PARTITION_VERT_4
:
update_partition_context
(
xd
mi_row
mi_col
subsize
bsize
)
;
break
;
case
PARTITION_HORZ_A
:
update_partition_context
(
xd
mi_row
mi_col
bsize2
subsize
)
;
update_partition_context
(
xd
mi_row
+
hbs
mi_col
subsize
subsize
)
;
break
;
case
PARTITION_HORZ_B
:
update_partition_context
(
xd
mi_row
mi_col
subsize
subsize
)
;
update_partition_context
(
xd
mi_row
+
hbs
mi_col
bsize2
subsize
)
;
break
;
case
PARTITION_VERT_A
:
update_partition_context
(
xd
mi_row
mi_col
bsize2
subsize
)
;
update_partition_context
(
xd
mi_row
mi_col
+
hbs
subsize
subsize
)
;
break
;
case
PARTITION_VERT_B
:
update_partition_context
(
xd
mi_row
mi_col
subsize
subsize
)
;
update_partition_context
(
xd
mi_row
mi_col
+
hbs
bsize2
subsize
)
;
break
;
default
:
assert
(
0
&
&
"
Invalid
partition
type
"
)
;
}
}
}
static
INLINE
int
partition_plane_context
(
const
MACROBLOCKD
*
xd
int
mi_row
int
mi_col
BLOCK_SIZE
bsize
)
{
const
PARTITION_CONTEXT
*
above_ctx
=
xd
-
>
above_partition_context
+
mi_col
;
const
PARTITION_CONTEXT
*
left_ctx
=
xd
-
>
left_partition_context
+
(
mi_row
&
MAX_MIB_MASK
)
;
const
int
bsl
=
mi_size_wide_log2
[
bsize
]
-
mi_size_wide_log2
[
BLOCK_8X8
]
;
int
above
=
(
*
above_ctx
>
>
bsl
)
&
1
left
=
(
*
left_ctx
>
>
bsl
)
&
1
;
assert
(
mi_size_wide_log2
[
bsize
]
=
=
mi_size_high_log2
[
bsize
]
)
;
assert
(
bsl
>
=
0
)
;
return
(
left
*
2
+
above
)
+
bsl
*
PARTITION_PLOFFSET
;
}
static
INLINE
int
partition_cdf_length
(
BLOCK_SIZE
bsize
)
{
if
(
bsize
<
=
BLOCK_8X8
)
return
PARTITION_TYPES
;
else
if
(
bsize
=
=
BLOCK_128X128
)
return
EXT_PARTITION_TYPES
-
2
;
else
return
EXT_PARTITION_TYPES
;
}
static
INLINE
int
max_block_wide
(
const
MACROBLOCKD
*
xd
BLOCK_SIZE
bsize
int
plane
)
{
assert
(
bsize
<
BLOCK_SIZES_ALL
)
;
int
max_blocks_wide
=
block_size_wide
[
bsize
]
;
if
(
xd
-
>
mb_to_right_edge
<
0
)
{
const
struct
macroblockd_plane
*
const
pd
=
&
xd
-
>
plane
[
plane
]
;
max_blocks_wide
+
=
xd
-
>
mb_to_right_edge
>
>
(
3
+
pd
-
>
subsampling_x
)
;
}
return
max_blocks_wide
>
>
MI_SIZE_LOG2
;
}
static
INLINE
int
max_block_high
(
const
MACROBLOCKD
*
xd
BLOCK_SIZE
bsize
int
plane
)
{
int
max_blocks_high
=
block_size_high
[
bsize
]
;
if
(
xd
-
>
mb_to_bottom_edge
<
0
)
{
const
struct
macroblockd_plane
*
const
pd
=
&
xd
-
>
plane
[
plane
]
;
max_blocks_high
+
=
xd
-
>
mb_to_bottom_edge
>
>
(
3
+
pd
-
>
subsampling_y
)
;
}
return
max_blocks_high
>
>
MI_SIZE_LOG2
;
}
static
INLINE
void
av1_zero_above_context
(
AV1_COMMON
*
const
cm
const
MACROBLOCKD
*
xd
int
mi_col_start
int
mi_col_end
const
int
tile_row
)
{
const
SequenceHeader
*
const
seq_params
=
cm
-
>
seq_params
;
const
int
num_planes
=
av1_num_planes
(
cm
)
;
const
int
width
=
mi_col_end
-
mi_col_start
;
const
int
aligned_width
=
ALIGN_POWER_OF_TWO
(
width
seq_params
-
>
mib_size_log2
)
;
const
int
offset_y
=
mi_col_start
;
const
int
width_y
=
aligned_width
;
const
int
offset_uv
=
offset_y
>
>
seq_params
-
>
subsampling_x
;
const
int
width_uv
=
width_y
>
>
seq_params
-
>
subsampling_x
;
CommonContexts
*
const
above_contexts
=
&
cm
-
>
above_contexts
;
av1_zero_array
(
above_contexts
-
>
entropy
[
0
]
[
tile_row
]
+
offset_y
width_y
)
;
if
(
num_planes
>
1
)
{
if
(
above_contexts
-
>
entropy
[
1
]
[
tile_row
]
&
&
above_contexts
-
>
entropy
[
2
]
[
tile_row
]
)
{
av1_zero_array
(
above_contexts
-
>
entropy
[
1
]
[
tile_row
]
+
offset_uv
width_uv
)
;
av1_zero_array
(
above_contexts
-
>
entropy
[
2
]
[
tile_row
]
+
offset_uv
width_uv
)
;
}
else
{
aom_internal_error
(
xd
-
>
error_info
AOM_CODEC_CORRUPT_FRAME
"
Invalid
value
of
planes
"
)
;
}
}
av1_zero_array
(
above_contexts
-
>
partition
[
tile_row
]
+
mi_col_start
aligned_width
)
;
memset
(
above_contexts
-
>
txfm
[
tile_row
]
+
mi_col_start
tx_size_wide
[
TX_SIZES_LARGEST
]
aligned_width
*
sizeof
(
TXFM_CONTEXT
)
)
;
}
static
INLINE
void
av1_zero_left_context
(
MACROBLOCKD
*
const
xd
)
{
av1_zero
(
xd
-
>
left_entropy_context
)
;
av1_zero
(
xd
-
>
left_partition_context
)
;
memset
(
xd
-
>
left_txfm_context_buffer
tx_size_high
[
TX_SIZES_LARGEST
]
sizeof
(
xd
-
>
left_txfm_context_buffer
)
)
;
}
static
INLINE
void
set_txfm_ctx
(
TXFM_CONTEXT
*
txfm_ctx
uint8_t
txs
int
len
)
{
int
i
;
for
(
i
=
0
;
i
<
len
;
+
+
i
)
txfm_ctx
[
i
]
=
txs
;
}
static
INLINE
void
set_txfm_ctxs
(
TX_SIZE
tx_size
int
n4_w
int
n4_h
int
skip
const
MACROBLOCKD
*
xd
)
{
uint8_t
bw
=
tx_size_wide
[
tx_size
]
;
uint8_t
bh
=
tx_size_high
[
tx_size
]
;
if
(
skip
)
{
bw
=
n4_w
*
MI_SIZE
;
bh
=
n4_h
*
MI_SIZE
;
}
set_txfm_ctx
(
xd
-
>
above_txfm_context
bw
n4_w
)
;
set_txfm_ctx
(
xd
-
>
left_txfm_context
bh
n4_h
)
;
}
static
INLINE
int
get_mi_grid_idx
(
const
CommonModeInfoParams
*
const
mi_params
int
mi_row
int
mi_col
)
{
return
mi_row
*
mi_params
-
>
mi_stride
+
mi_col
;
}
static
INLINE
int
get_alloc_mi_idx
(
const
CommonModeInfoParams
*
const
mi_params
int
mi_row
int
mi_col
)
{
const
int
mi_alloc_size_1d
=
mi_size_wide
[
mi_params
-
>
mi_alloc_bsize
]
;
const
int
mi_alloc_row
=
mi_row
/
mi_alloc_size_1d
;
const
int
mi_alloc_col
=
mi_col
/
mi_alloc_size_1d
;
return
mi_alloc_row
*
mi_params
-
>
mi_alloc_stride
+
mi_alloc_col
;
}
static
INLINE
void
set_mi_offsets
(
const
CommonModeInfoParams
*
const
mi_params
MACROBLOCKD
*
const
xd
int
mi_row
int
mi_col
)
{
const
int
mi_grid_idx
=
get_mi_grid_idx
(
mi_params
mi_row
mi_col
)
;
const
int
mi_alloc_idx
=
get_alloc_mi_idx
(
mi_params
mi_row
mi_col
)
;
mi_params
-
>
mi_grid_base
[
mi_grid_idx
]
=
&
mi_params
-
>
mi_alloc
[
mi_alloc_idx
]
;
xd
-
>
mi
=
mi_params
-
>
mi_grid_base
+
mi_grid_idx
;
xd
-
>
tx_type_map
=
mi_params
-
>
tx_type_map
+
mi_grid_idx
;
xd
-
>
tx_type_map_stride
=
mi_params
-
>
mi_stride
;
}
static
INLINE
void
txfm_partition_update
(
TXFM_CONTEXT
*
above_ctx
TXFM_CONTEXT
*
left_ctx
TX_SIZE
tx_size
TX_SIZE
txb_size
)
{
BLOCK_SIZE
bsize
=
txsize_to_bsize
[
txb_size
]
;
int
bh
=
mi_size_high
[
bsize
]
;
int
bw
=
mi_size_wide
[
bsize
]
;
uint8_t
txw
=
tx_size_wide
[
tx_size
]
;
uint8_t
txh
=
tx_size_high
[
tx_size
]
;
int
i
;
for
(
i
=
0
;
i
<
bh
;
+
+
i
)
left_ctx
[
i
]
=
txh
;
for
(
i
=
0
;
i
<
bw
;
+
+
i
)
above_ctx
[
i
]
=
txw
;
}
static
INLINE
TX_SIZE
get_sqr_tx_size
(
int
tx_dim
)
{
switch
(
tx_dim
)
{
case
128
:
case
64
:
return
TX_64X64
;
break
;
case
32
:
return
TX_32X32
;
break
;
case
16
:
return
TX_16X16
;
break
;
case
8
:
return
TX_8X8
;
break
;
default
:
return
TX_4X4
;
}
}
static
INLINE
TX_SIZE
get_tx_size
(
int
width
int
height
)
{
if
(
width
=
=
height
)
{
return
get_sqr_tx_size
(
width
)
;
}
if
(
width
<
height
)
{
if
(
width
+
width
=
=
height
)
{
switch
(
width
)
{
case
4
:
return
TX_4X8
;
break
;
case
8
:
return
TX_8X16
;
break
;
case
16
:
return
TX_16X32
;
break
;
case
32
:
return
TX_32X64
;
break
;
}
}
else
{
switch
(
width
)
{
case
4
:
return
TX_4X16
;
break
;
case
8
:
return
TX_8X32
;
break
;
case
16
:
return
TX_16X64
;
break
;
}
}
}
else
{
if
(
height
+
height
=
=
width
)
{
switch
(
height
)
{
case
4
:
return
TX_8X4
;
break
;
case
8
:
return
TX_16X8
;
break
;
case
16
:
return
TX_32X16
;
break
;
case
32
:
return
TX_64X32
;
break
;
}
}
else
{
switch
(
height
)
{
case
4
:
return
TX_16X4
;
break
;
case
8
:
return
TX_32X8
;
break
;
case
16
:
return
TX_64X16
;
break
;
}
}
}
assert
(
0
)
;
return
TX_4X4
;
}
static
INLINE
int
txfm_partition_context
(
const
TXFM_CONTEXT
*
const
above_ctx
const
TXFM_CONTEXT
*
const
left_ctx
BLOCK_SIZE
bsize
TX_SIZE
tx_size
)
{
const
uint8_t
txw
=
tx_size_wide
[
tx_size
]
;
const
uint8_t
txh
=
tx_size_high
[
tx_size
]
;
const
int
above
=
*
above_ctx
<
txw
;
const
int
left
=
*
left_ctx
<
txh
;
int
category
=
TXFM_PARTITION_CONTEXTS
;
if
(
tx_size
<
=
TX_4X4
)
return
0
;
TX_SIZE
max_tx_size
=
get_sqr_tx_size
(
AOMMAX
(
block_size_wide
[
bsize
]
block_size_high
[
bsize
]
)
)
;
if
(
max_tx_size
>
=
TX_8X8
)
{
category
=
(
txsize_sqr_up_map
[
tx_size
]
!
=
max_tx_size
&
&
max_tx_size
>
TX_8X8
)
+
(
TX_SIZES
-
1
-
max_tx_size
)
*
2
;
}
assert
(
category
!
=
TXFM_PARTITION_CONTEXTS
)
;
return
category
*
3
+
above
+
left
;
}
static
INLINE
PARTITION_TYPE
get_partition
(
const
AV1_COMMON
*
const
cm
int
mi_row
int
mi_col
BLOCK_SIZE
bsize
)
{
const
CommonModeInfoParams
*
const
mi_params
=
&
cm
-
>
mi_params
;
if
(
mi_row
>
=
mi_params
-
>
mi_rows
|
|
mi_col
>
=
mi_params
-
>
mi_cols
)
return
PARTITION_INVALID
;
const
int
offset
=
mi_row
*
mi_params
-
>
mi_stride
+
mi_col
;
MB_MODE_INFO
*
*
mi
=
mi_params
-
>
mi_grid_base
+
offset
;
const
BLOCK_SIZE
subsize
=
mi
[
0
]
-
>
bsize
;
assert
(
bsize
<
BLOCK_SIZES_ALL
)
;
if
(
subsize
=
=
bsize
)
return
PARTITION_NONE
;
const
int
bhigh
=
mi_size_high
[
bsize
]
;
const
int
bwide
=
mi_size_wide
[
bsize
]
;
const
int
sshigh
=
mi_size_high
[
subsize
]
;
const
int
sswide
=
mi_size_wide
[
subsize
]
;
if
(
bsize
>
BLOCK_8X8
&
&
mi_row
+
bwide
/
2
<
mi_params
-
>
mi_rows
&
&
mi_col
+
bhigh
/
2
<
mi_params
-
>
mi_cols
)
{
const
MB_MODE_INFO
*
const
mbmi_right
=
mi
[
bwide
/
2
]
;
const
MB_MODE_INFO
*
const
mbmi_below
=
mi
[
bhigh
/
2
*
mi_params
-
>
mi_stride
]
;
if
(
sswide
=
=
bwide
)
{
if
(
sshigh
*
4
=
=
bhigh
)
return
PARTITION_HORZ_4
;
assert
(
sshigh
*
2
=
=
bhigh
)
;
if
(
mbmi_below
-
>
bsize
=
=
subsize
)
return
PARTITION_HORZ
;
else
return
PARTITION_HORZ_B
;
}
else
if
(
sshigh
=
=
bhigh
)
{
if
(
sswide
*
4
=
=
bwide
)
return
PARTITION_VERT_4
;
assert
(
sswide
*
2
=
=
bhigh
)
;
if
(
mbmi_right
-
>
bsize
=
=
subsize
)
return
PARTITION_VERT
;
else
return
PARTITION_VERT_B
;
}
else
{
if
(
sswide
*
2
!
=
bwide
|
|
sshigh
*
2
!
=
bhigh
)
return
PARTITION_SPLIT
;
if
(
mi_size_wide
[
mbmi_below
-
>
bsize
]
=
=
bwide
)
return
PARTITION_HORZ_A
;
if
(
mi_size_high
[
mbmi_right
-
>
bsize
]
=
=
bhigh
)
return
PARTITION_VERT_A
;
return
PARTITION_SPLIT
;
}
}
const
int
vert_split
=
sswide
<
bwide
;
const
int
horz_split
=
sshigh
<
bhigh
;
const
int
split_idx
=
(
vert_split
<
<
1
)
|
horz_split
;
assert
(
split_idx
!
=
0
)
;
static
const
PARTITION_TYPE
base_partitions
[
4
]
=
{
PARTITION_INVALID
PARTITION_HORZ
PARTITION_VERT
PARTITION_SPLIT
}
;
return
base_partitions
[
split_idx
]
;
}
static
INLINE
void
set_sb_size
(
SequenceHeader
*
const
seq_params
BLOCK_SIZE
sb_size
)
{
seq_params
-
>
sb_size
=
sb_size
;
seq_params
-
>
mib_size
=
mi_size_wide
[
seq_params
-
>
sb_size
]
;
seq_params
-
>
mib_size_log2
=
mi_size_wide_log2
[
seq_params
-
>
sb_size
]
;
}
static
INLINE
int
is_coded_lossless
(
const
AV1_COMMON
*
cm
const
MACROBLOCKD
*
xd
)
{
int
coded_lossless
=
1
;
if
(
cm
-
>
seg
.
enabled
)
{
for
(
int
i
=
0
;
i
<
MAX_SEGMENTS
;
+
+
i
)
{
if
(
!
xd
-
>
lossless
[
i
]
)
{
coded_lossless
=
0
;
break
;
}
}
}
else
{
coded_lossless
=
xd
-
>
lossless
[
0
]
;
}
return
coded_lossless
;
}
static
INLINE
int
is_valid_seq_level_idx
(
AV1_LEVEL
seq_level_idx
)
{
return
seq_level_idx
=
=
SEQ_LEVEL_MAX
|
|
(
seq_level_idx
<
SEQ_LEVELS
&
&
seq_level_idx
!
=
SEQ_LEVEL_2_2
&
&
seq_level_idx
!
=
SEQ_LEVEL_2_3
&
&
seq_level_idx
!
=
SEQ_LEVEL_3_2
&
&
seq_level_idx
!
=
SEQ_LEVEL_3_3
&
&
seq_level_idx
!
=
SEQ_LEVEL_4_2
&
&
seq_level_idx
!
=
SEQ_LEVEL_4_3
#
if
!
CONFIG_CWG_C013
&
&
seq_level_idx
!
=
SEQ_LEVEL_7_0
&
&
seq_level_idx
!
=
SEQ_LEVEL_7_1
&
&
seq_level_idx
!
=
SEQ_LEVEL_7_2
&
&
seq_level_idx
!
=
SEQ_LEVEL_7_3
&
&
seq_level_idx
!
=
SEQ_LEVEL_8_0
&
&
seq_level_idx
!
=
SEQ_LEVEL_8_1
&
&
seq_level_idx
!
=
SEQ_LEVEL_8_2
&
&
seq_level_idx
!
=
SEQ_LEVEL_8_3
#
endif
)
;
}
#
ifdef
__cplusplus
}
#
endif
#
endif
