#
ifndef
AV1_COMMON_CFL_H_
#
define
AV1_COMMON_CFL_H_
#
include
<
assert
.
h
>
#
include
"
av1
/
common
/
enums
.
h
"
typedef
struct
AV1Common
AV1_COMMON
;
typedef
struct
macroblockd
MACROBLOCKD
;
typedef
struct
{
uint8_t
y_pix
[
MAX_SB_SQUARE
]
;
int
y_height
y_width
;
int
subsampling_x
subsampling_y
;
double
dc_pred
[
CFL_PRED_PLANES
]
;
int
costs
[
CFL_ALPHABET_SIZE
]
;
int
num_tx_blk
[
CFL_PRED_PLANES
]
;
}
CFL_CTX
;
static
const
double
cfl_alpha_mags
[
CFL_MAGS_SIZE
]
=
{
0
.
0
.
125
-
0
.
125
0
.
25
-
0
.
25
0
.
5
-
0
.
5
}
;
static
const
int
cfl_alpha_codes
[
CFL_ALPHABET_SIZE
]
[
CFL_PRED_PLANES
]
=
{
{
0
0
}
{
1
1
}
{
3
0
}
{
3
1
}
{
1
0
}
{
3
3
}
{
0
1
}
{
5
5
}
{
5
3
}
{
1
3
}
{
5
3
}
{
3
5
}
{
0
3
}
{
5
1
}
{
1
5
}
{
0
5
}
}
;
void
cfl_init
(
CFL_CTX
*
cfl
AV1_COMMON
*
cm
int
subsampling_x
int
subsampling_y
)
;
void
cfl_dc_pred
(
MACROBLOCKD
*
xd
BLOCK_SIZE
plane_bsize
TX_SIZE
tx_size
)
;
static
INLINE
double
cfl_idx_to_alpha
(
int
alpha_idx
CFL_SIGN_TYPE
alpha_sign
CFL_PRED_TYPE
pred_type
)
{
const
int
mag_idx
=
cfl_alpha_codes
[
alpha_idx
]
[
pred_type
]
;
const
double
abs_alpha
=
cfl_alpha_mags
[
mag_idx
]
;
if
(
alpha_sign
=
=
CFL_SIGN_POS
)
{
return
abs_alpha
;
}
else
{
assert
(
abs_alpha
!
=
0
.
0
)
;
assert
(
cfl_alpha_mags
[
mag_idx
+
1
]
=
=
-
abs_alpha
)
;
return
-
abs_alpha
;
}
}
void
cfl_predict_block
(
const
CFL_CTX
*
cfl
uint8_t
*
dst
int
dst_stride
int
row
int
col
TX_SIZE
tx_size
double
dc_pred
double
alpha
)
;
void
cfl_store
(
CFL_CTX
*
cfl
const
uint8_t
*
input
int
input_stride
int
row
int
col
TX_SIZE
tx_size
)
;
double
cfl_load
(
const
CFL_CTX
*
cfl
uint8_t
*
output
int
output_stride
int
row
int
col
int
width
int
height
)
;
#
endif
