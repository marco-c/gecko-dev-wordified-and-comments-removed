#
include
<
assert
.
h
>
#
include
"
av1
/
common
/
av1_loopfilter
.
h
"
#
include
"
av1
/
common
/
blockd
.
h
"
#
include
"
av1
/
common
/
seg_common
.
h
"
#
include
"
av1
/
common
/
quant_common
.
h
"
static
const
int
seg_feature_data_signed
[
SEG_LVL_MAX
]
=
{
1
1
1
1
1
0
0
}
;
static
const
int
seg_feature_data_max
[
SEG_LVL_MAX
]
=
{
MAXQ
MAX_LOOP_FILTER
MAX_LOOP_FILTER
MAX_LOOP_FILTER
MAX_LOOP_FILTER
7
0
}
;
void
av1_clearall_segfeatures
(
struct
segmentation
*
seg
)
{
av1_zero
(
seg
-
>
feature_data
)
;
av1_zero
(
seg
-
>
feature_mask
)
;
}
void
calculate_segdata
(
struct
segmentation
*
seg
)
{
seg
-
>
segid_preskip
=
0
;
seg
-
>
last_active_segid
=
0
;
for
(
int
i
=
0
;
i
<
MAX_SEGMENTS
;
i
+
+
)
{
for
(
int
j
=
0
;
j
<
SEG_LVL_MAX
;
j
+
+
)
{
if
(
seg
-
>
feature_mask
[
i
]
&
(
1
<
<
j
)
)
{
seg
-
>
segid_preskip
|
=
(
j
>
=
SEG_LVL_REF_FRAME
)
;
seg
-
>
last_active_segid
=
i
;
}
}
}
}
void
av1_enable_segfeature
(
struct
segmentation
*
seg
int
segment_id
SEG_LVL_FEATURES
feature_id
)
{
seg
-
>
feature_mask
[
segment_id
]
|
=
1
<
<
feature_id
;
}
int
av1_seg_feature_data_max
(
SEG_LVL_FEATURES
feature_id
)
{
return
seg_feature_data_max
[
feature_id
]
;
}
int
av1_is_segfeature_signed
(
SEG_LVL_FEATURES
feature_id
)
{
return
seg_feature_data_signed
[
feature_id
]
;
}
void
av1_set_segdata
(
struct
segmentation
*
seg
int
segment_id
SEG_LVL_FEATURES
feature_id
int
seg_data
)
{
if
(
seg_data
<
0
)
{
assert
(
seg_feature_data_signed
[
feature_id
]
)
;
assert
(
-
seg_data
<
=
seg_feature_data_max
[
feature_id
]
)
;
}
else
{
assert
(
seg_data
<
=
seg_feature_data_max
[
feature_id
]
)
;
}
seg
-
>
feature_data
[
segment_id
]
[
feature_id
]
=
seg_data
;
}
