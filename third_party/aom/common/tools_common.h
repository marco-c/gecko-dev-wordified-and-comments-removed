#
ifndef
AOM_COMMON_TOOLS_COMMON_H_
#
define
AOM_COMMON_TOOLS_COMMON_H_
#
include
<
stdbool
.
h
>
#
include
<
stdio
.
h
>
#
include
"
config
/
aom_config
.
h
"
#
include
"
aom
/
aom_codec
.
h
"
#
include
"
aom
/
aom_image
.
h
"
#
include
"
aom
/
aom_integer
.
h
"
#
include
"
aom_ports
/
mem
.
h
"
#
if
CONFIG_AV1_ENCODER
#
include
"
common
/
y4minput
.
h
"
#
endif
#
if
defined
(
_MSC_VER
)
#
define
fseeko
_fseeki64
#
define
ftello
_ftelli64
typedef
int64_t
FileOffset
;
#
elif
defined
(
_WIN32
)
#
include
<
sys
/
types
.
h
>
#
define
fseeko
fseeko64
#
define
ftello
ftello64
typedef
off64_t
FileOffset
;
#
elif
CONFIG_OS_SUPPORT
&
&
\
!
(
defined
(
__ANDROID__
)
&
&
__ANDROID_API__
<
24
&
&
!
defined
(
__LP64__
)
&
&
\
defined
(
_FILE_OFFSET_BITS
)
&
&
_FILE_OFFSET_BITS
=
=
64
)
#
include
<
sys
/
types
.
h
>
typedef
off_t
FileOffset
;
#
else
#
define
fseeko
fseek
#
define
ftello
ftell
typedef
long
FileOffset
;
#
endif
#
if
CONFIG_OS_SUPPORT
#
if
defined
(
_MSC_VER
)
#
include
<
io
.
h
>
#
define
isatty
_isatty
#
define
fileno
_fileno
#
else
#
include
<
unistd
.
h
>
#
endif
#
endif
#
define
LITERALU64
(
hi
lo
)
(
(
(
(
uint64_t
)
hi
)
<
<
32
)
|
lo
)
#
ifndef
PATH_MAX
#
define
PATH_MAX
512
#
endif
#
define
IVF_FRAME_HDR_SZ
(
4
+
8
)
/
*
4
byte
size
+
8
byte
timestamp
*
/
#
define
IVF_FILE_HDR_SZ
32
#
define
RAW_FRAME_HDR_SZ
sizeof
(
uint32_t
)
#
define
OBU_DETECTION_SZ
34
/
/
See
common
/
obudec
.
c
#
define
DETECT_BUF_SZ
34
/
/
Max
of
the
above
header
sizes
#
define
AV1_FOURCC
0x31305641
enum
VideoFileType
{
FILE_TYPE_OBU
FILE_TYPE_RAW
FILE_TYPE_IVF
FILE_TYPE_Y4M
FILE_TYPE_WEBM
}
;
#
define
LST_FOURCC
0x4354534c
struct
FileTypeDetectionBuffer
{
char
buf
[
DETECT_BUF_SZ
]
;
size_t
buf_read
;
size_t
position
;
}
;
struct
AvxRational
{
int
numerator
;
int
denominator
;
}
;
struct
AvxInputContext
{
const
char
*
filename
;
FILE
*
file
;
int64_t
length
;
struct
FileTypeDetectionBuffer
detect
;
enum
VideoFileType
file_type
;
uint32_t
width
;
uint32_t
height
;
struct
AvxRational
pixel_aspect_ratio
;
aom_img_fmt_t
fmt
;
aom_bit_depth_t
bit_depth
;
int
only_i420
;
uint32_t
fourcc
;
struct
AvxRational
framerate
;
#
if
CONFIG_AV1_ENCODER
y4m_input
y4m
;
#
endif
aom_color_range_t
color_range
;
}
;
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
if
defined
(
__GNUC__
)
#
define
AOM_NO_RETURN
__attribute__
(
(
noreturn
)
)
#
elif
defined
(
_MSC_VER
)
#
define
AOM_NO_RETURN
__declspec
(
noreturn
)
#
else
#
define
AOM_NO_RETURN
#
endif
#
define
AOM_TOOLS_FORMAT_PRINTF
(
string_index
first_to_check
)
#
if
defined
(
__has_attribute
)
#
if
__has_attribute
(
format
)
#
undef
AOM_TOOLS_FORMAT_PRINTF
#
define
AOM_TOOLS_FORMAT_PRINTF
(
string_index
first_to_check
)
\
__attribute__
(
(
__format__
(
__printf__
string_index
first_to_check
)
)
)
#
endif
#
endif
FILE
*
set_binary_mode
(
FILE
*
stream
)
;
AOM_NO_RETURN
void
die
(
const
char
*
fmt
.
.
.
)
AOM_TOOLS_FORMAT_PRINTF
(
1
2
)
;
AOM_NO_RETURN
void
fatal
(
const
char
*
fmt
.
.
.
)
AOM_TOOLS_FORMAT_PRINTF
(
1
2
)
;
void
aom_tools_warn
(
const
char
*
fmt
.
.
.
)
AOM_TOOLS_FORMAT_PRINTF
(
1
2
)
;
AOM_NO_RETURN
void
die_codec
(
aom_codec_ctx_t
*
ctx
const
char
*
s
)
;
AOM_NO_RETURN
void
usage_exit
(
void
)
;
#
undef
AOM_NO_RETURN
int
get_aom_encoder_count
(
void
)
;
aom_codec_iface_t
*
get_aom_encoder_by_index
(
int
i
)
;
aom_codec_iface_t
*
get_aom_encoder_by_short_name
(
const
char
*
name
)
;
const
char
*
get_short_name_by_aom_encoder
(
aom_codec_iface_t
*
encoder
)
;
uint32_t
get_fourcc_by_aom_encoder
(
aom_codec_iface_t
*
iface
)
;
int
get_aom_decoder_count
(
void
)
;
aom_codec_iface_t
*
get_aom_decoder_by_index
(
int
i
)
;
aom_codec_iface_t
*
get_aom_decoder_by_short_name
(
const
char
*
name
)
;
aom_codec_iface_t
*
get_aom_decoder_by_fourcc
(
uint32_t
fourcc
)
;
const
char
*
get_short_name_by_aom_decoder
(
aom_codec_iface_t
*
decoder
)
;
uint32_t
get_fourcc_by_aom_decoder
(
aom_codec_iface_t
*
iface
)
;
const
char
*
image_format_to_string
(
aom_img_fmt_t
fmt
)
;
int
read_yuv_frame
(
struct
AvxInputContext
*
input_ctx
aom_image_t
*
yuv_frame
)
;
void
aom_img_write
(
const
aom_image_t
*
img
FILE
*
file
)
;
bool
aom_img_read
(
aom_image_t
*
img
FILE
*
file
)
;
double
sse_to_psnr
(
double
samples
double
peak
double
mse
)
;
void
aom_img_upshift
(
aom_image_t
*
dst
const
aom_image_t
*
src
int
input_shift
)
;
void
aom_img_downshift
(
aom_image_t
*
dst
const
aom_image_t
*
src
int
down_shift
)
;
bool
aom_shift_img
(
unsigned
int
output_bit_depth
aom_image_t
*
*
img_ptr
aom_image_t
*
*
img_shifted_ptr
)
;
void
aom_img_truncate_16_to_8
(
aom_image_t
*
dst
const
aom_image_t
*
src
)
;
void
aom_img_write_nv12
(
const
aom_image_t
*
img
FILE
*
file
)
;
size_t
read_from_input
(
struct
AvxInputContext
*
input_ctx
size_t
n
unsigned
char
*
buf
)
;
size_t
input_to_detect_buf
(
struct
AvxInputContext
*
input_ctx
size_t
n
)
;
size_t
buffer_input
(
struct
AvxInputContext
*
input_ctx
size_t
n
unsigned
char
*
buf
bool
buffered
)
;
void
rewind_detect
(
struct
AvxInputContext
*
input_ctx
)
;
bool
input_eof
(
struct
AvxInputContext
*
input_ctx
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
