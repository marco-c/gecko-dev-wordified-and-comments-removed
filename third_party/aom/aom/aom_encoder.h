#
ifndef
AOM_AOM_ENCODER_H_
#
define
AOM_AOM_ENCODER_H_
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
include
"
.
/
aom_codec
.
h
"
#
define
AOM_ENCODER_ABI_VERSION
\
(
5
+
AOM_CODEC_ABI_VERSION
)
/
*
*
<
\
hideinitializer
*
/
#
define
AOM_CODEC_CAP_PSNR
0x10000
/
*
*
<
Can
issue
PSNR
packets
*
/
#
define
AOM_CODEC_CAP_OUTPUT_PARTITION
0x20000
#
define
AOM_CODEC_CAP_HIGHBITDEPTH
0x40000
#
define
AOM_CODEC_USE_PSNR
0x10000
/
*
*
<
Calculate
PSNR
on
each
frame
*
/
#
define
AOM_CODEC_USE_OUTPUT_PARTITION
0x20000
#
define
AOM_CODEC_USE_HIGHBITDEPTH
0x40000
/
*
*
<
Use
high
bitdepth
*
/
typedef
struct
aom_fixed_buf
{
void
*
buf
;
size_t
sz
;
}
aom_fixed_buf_t
;
typedef
int64_t
aom_codec_pts_t
;
typedef
uint32_t
aom_codec_frame_flags_t
;
#
define
AOM_FRAME_IS_KEY
0x1
/
*
*
<
frame
is
the
start
of
a
GOP
*
/
#
define
AOM_FRAME_IS_DROPPABLE
0x2
#
define
AOM_FRAME_IS_INVISIBLE
0x4
#
define
AOM_FRAME_IS_FRAGMENT
0x8
typedef
uint32_t
aom_codec_er_flags_t
;
#
define
AOM_ERROR_RESILIENT_DEFAULT
0x1
#
define
AOM_ERROR_RESILIENT_PARTITIONS
0x2
enum
aom_codec_cx_pkt_kind
{
AOM_CODEC_CX_FRAME_PKT
AOM_CODEC_STATS_PKT
AOM_CODEC_FPMB_STATS_PKT
AOM_CODEC_PSNR_PKT
AOM_CODEC_CUSTOM_PKT
=
256
}
;
typedef
struct
aom_codec_cx_pkt
{
enum
aom_codec_cx_pkt_kind
kind
;
union
{
struct
{
void
*
buf
;
size_t
sz
;
aom_codec_pts_t
pts
;
unsigned
long
duration
;
aom_codec_frame_flags_t
flags
;
int
partition_id
;
}
frame
;
aom_fixed_buf_t
twopass_stats
;
aom_fixed_buf_t
firstpass_mb_stats
;
struct
aom_psnr_pkt
{
unsigned
int
samples
[
4
]
;
uint64_t
sse
[
4
]
;
double
psnr
[
4
]
;
}
psnr
;
aom_fixed_buf_t
raw
;
char
pad
[
128
-
sizeof
(
enum
aom_codec_cx_pkt_kind
)
]
;
}
data
;
}
aom_codec_cx_pkt_t
;
typedef
struct
aom_rational
{
int
num
;
int
den
;
}
aom_rational_t
;
enum
aom_enc_pass
{
AOM_RC_ONE_PASS
AOM_RC_FIRST_PASS
AOM_RC_LAST_PASS
}
;
enum
aom_rc_mode
{
AOM_VBR
AOM_CBR
AOM_CQ
AOM_Q
}
;
enum
aom_kf_mode
{
AOM_KF_FIXED
AOM_KF_AUTO
AOM_KF_DISABLED
=
0
}
;
typedef
long
aom_enc_frame_flags_t
;
#
define
AOM_EFLAG_FORCE_KF
(
1
<
<
0
)
/
*
*
<
Force
this
frame
to
be
a
keyframe
*
/
typedef
struct
aom_codec_enc_cfg
{
unsigned
int
g_usage
;
unsigned
int
g_threads
;
unsigned
int
g_profile
;
unsigned
int
g_w
;
unsigned
int
g_h
;
aom_bit_depth_t
g_bit_depth
;
unsigned
int
g_input_bit_depth
;
struct
aom_rational
g_timebase
;
aom_codec_er_flags_t
g_error_resilient
;
enum
aom_enc_pass
g_pass
;
unsigned
int
g_lag_in_frames
;
unsigned
int
rc_dropframe_thresh
;
unsigned
int
rc_resize_mode
;
unsigned
int
rc_resize_denominator
;
unsigned
int
rc_resize_kf_denominator
;
unsigned
int
rc_superres_mode
;
unsigned
int
rc_superres_denominator
;
unsigned
int
rc_superres_kf_denominator
;
unsigned
int
rc_superres_qthresh
;
unsigned
int
rc_superres_kf_qthresh
;
enum
aom_rc_mode
rc_end_usage
;
aom_fixed_buf_t
rc_twopass_stats_in
;
aom_fixed_buf_t
rc_firstpass_mb_stats_in
;
unsigned
int
rc_target_bitrate
;
unsigned
int
rc_min_quantizer
;
unsigned
int
rc_max_quantizer
;
unsigned
int
rc_undershoot_pct
;
unsigned
int
rc_overshoot_pct
;
unsigned
int
rc_buf_sz
;
unsigned
int
rc_buf_initial_sz
;
unsigned
int
rc_buf_optimal_sz
;
unsigned
int
rc_2pass_vbr_bias_pct
;
unsigned
int
rc_2pass_vbr_minsection_pct
;
unsigned
int
rc_2pass_vbr_maxsection_pct
;
enum
aom_kf_mode
kf_mode
;
unsigned
int
kf_min_dist
;
unsigned
int
kf_max_dist
;
unsigned
int
large_scale_tile
;
int
tile_width_count
;
int
tile_height_count
;
#
define
MAX_TILE_WIDTHS
64
/
/
maximum
tile
width
array
length
int
tile_widths
[
MAX_TILE_WIDTHS
]
;
#
define
MAX_TILE_HEIGHTS
64
/
/
maximum
tile
height
array
length
int
tile_heights
[
MAX_TILE_HEIGHTS
]
;
}
aom_codec_enc_cfg_t
;
aom_codec_err_t
aom_codec_enc_init_ver
(
aom_codec_ctx_t
*
ctx
aom_codec_iface_t
*
iface
const
aom_codec_enc_cfg_t
*
cfg
aom_codec_flags_t
flags
int
ver
)
;
#
define
aom_codec_enc_init
(
ctx
iface
cfg
flags
)
\
aom_codec_enc_init_ver
(
ctx
iface
cfg
flags
AOM_ENCODER_ABI_VERSION
)
aom_codec_err_t
aom_codec_enc_init_multi_ver
(
aom_codec_ctx_t
*
ctx
aom_codec_iface_t
*
iface
aom_codec_enc_cfg_t
*
cfg
int
num_enc
aom_codec_flags_t
flags
aom_rational_t
*
dsf
int
ver
)
;
#
define
aom_codec_enc_init_multi
(
ctx
iface
cfg
num_enc
flags
dsf
)
\
aom_codec_enc_init_multi_ver
(
ctx
iface
cfg
num_enc
flags
dsf
\
AOM_ENCODER_ABI_VERSION
)
aom_codec_err_t
aom_codec_enc_config_default
(
aom_codec_iface_t
*
iface
aom_codec_enc_cfg_t
*
cfg
unsigned
int
reserved
)
;
aom_codec_err_t
aom_codec_enc_config_set
(
aom_codec_ctx_t
*
ctx
const
aom_codec_enc_cfg_t
*
cfg
)
;
aom_fixed_buf_t
*
aom_codec_get_global_headers
(
aom_codec_ctx_t
*
ctx
)
;
#
define
AOM_DL_GOOD_QUALITY
(
1000000
)
aom_codec_err_t
aom_codec_encode
(
aom_codec_ctx_t
*
ctx
const
aom_image_t
*
img
aom_codec_pts_t
pts
unsigned
long
duration
aom_enc_frame_flags_t
flags
unsigned
long
deadline
)
;
aom_codec_err_t
aom_codec_set_cx_data_buf
(
aom_codec_ctx_t
*
ctx
const
aom_fixed_buf_t
*
buf
unsigned
int
pad_before
unsigned
int
pad_after
)
;
const
aom_codec_cx_pkt_t
*
aom_codec_get_cx_data
(
aom_codec_ctx_t
*
ctx
aom_codec_iter_t
*
iter
)
;
const
aom_image_t
*
aom_codec_get_preview_frame
(
aom_codec_ctx_t
*
ctx
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
