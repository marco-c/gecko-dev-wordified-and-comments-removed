#
if
defined
(
HIGHWAY_HWY_CONTRIB_ALGO_COPY_INL_H_
)
=
=
\
defined
(
HWY_TARGET_TOGGLE
)
#
ifdef
HIGHWAY_HWY_CONTRIB_ALGO_COPY_INL_H_
#
undef
HIGHWAY_HWY_CONTRIB_ALGO_COPY_INL_H_
#
else
#
define
HIGHWAY_HWY_CONTRIB_ALGO_COPY_INL_H_
#
endif
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
third_party
/
highway
/
hwy
/
highway
.
h
"
HWY_BEFORE_NAMESPACE
(
)
;
namespace
hwy
{
namespace
HWY_NAMESPACE
{
template
<
class
D
typename
T
=
TFromD
<
D
>
>
void
Fill
(
D
d
T
value
size_t
count
T
*
HWY_RESTRICT
to
)
{
const
size_t
N
=
Lanes
(
d
)
;
const
Vec
<
D
>
v
=
Set
(
d
value
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
StoreU
(
v
d
to
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
SafeFillN
(
remaining
value
d
to
+
idx
)
;
}
template
<
class
D
typename
T
=
TFromD
<
D
>
>
void
Copy
(
D
d
const
T
*
HWY_RESTRICT
from
size_t
count
T
*
HWY_RESTRICT
to
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
from
+
idx
)
;
StoreU
(
v
d
to
+
idx
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
;
const
size_t
remaining
=
count
-
idx
;
HWY_DASSERT
(
0
!
=
remaining
&
&
remaining
<
N
)
;
SafeCopyN
(
remaining
d
from
+
idx
to
+
idx
)
;
}
template
<
class
D
class
Func
typename
T
=
TFromD
<
D
>
>
T
*
CopyIf
(
D
d
const
T
*
HWY_RESTRICT
from
size_t
count
T
*
HWY_RESTRICT
to
const
Func
&
func
)
{
const
size_t
N
=
Lanes
(
d
)
;
size_t
idx
=
0
;
if
(
count
>
=
N
)
{
for
(
;
idx
<
=
count
-
N
;
idx
+
=
N
)
{
const
Vec
<
D
>
v
=
LoadU
(
d
from
+
idx
)
;
to
+
=
CompressBlendedStore
(
v
func
(
d
v
)
d
to
)
;
}
}
if
(
HWY_UNLIKELY
(
idx
=
=
count
)
)
return
to
;
#
if
HWY_MEM_OPS_MIGHT_FAULT
const
CappedTag
<
T
1
>
d1
;
for
(
;
idx
<
count
;
+
+
idx
)
{
using
V1
=
Vec
<
decltype
(
d1
)
>
;
const
uintptr_t
addr
=
reinterpret_cast
<
uintptr_t
>
(
from
)
;
const
T
*
HWY_RESTRICT
from_idx
=
reinterpret_cast
<
const
T
*
HWY_RESTRICT
>
(
addr
+
(
idx
*
sizeof
(
T
)
)
)
;
const
V1
v
=
LoadU
(
d1
from_idx
)
;
if
(
CountTrue
(
d1
func
(
d1
v
)
)
=
=
0
)
continue
;
StoreU
(
v
d1
to
)
;
to
+
=
1
;
}
#
else
const
size_t
last
=
count
-
N
;
const
size_t
invalid
=
idx
-
last
;
HWY_DASSERT
(
0
!
=
invalid
&
&
invalid
<
N
)
;
const
Mask
<
D
>
mask
=
Not
(
FirstN
(
d
invalid
)
)
;
const
Vec
<
D
>
v
=
MaskedLoad
(
mask
d
from
+
last
)
;
to
+
=
CompressBlendedStore
(
v
And
(
mask
func
(
d
v
)
)
d
to
)
;
#
endif
return
to
;
}
}
}
HWY_AFTER_NAMESPACE
(
)
;
#
endif
