#
pragma
once
#
include
<
tuple
>
namespace
intgemm
{
template
<
unsigned
.
.
.
Indices
>
struct
sequence
{
using
type
=
sequence
;
}
;
template
<
unsigned
I
typename
Sequence
>
struct
sequence_pushback
;
template
<
unsigned
I
unsigned
.
.
.
Indices
>
struct
sequence_pushback
<
I
sequence
<
Indices
.
.
.
>
>
:
sequence
<
Indices
.
.
.
I
>
{
}
;
template
<
typename
Sequence
>
struct
sequence_popfront
;
template
<
unsigned
FirstIndex
unsigned
.
.
.
RestIndices
>
struct
sequence_popfront
<
sequence
<
FirstIndex
RestIndices
.
.
.
>
>
:
sequence
<
RestIndices
.
.
.
>
{
}
;
namespace
{
template
<
unsigned
N
>
struct
make_sequence_impl
:
sequence_pushback
<
N
-
1
typename
make_sequence_impl
<
N
-
1
>
:
:
type
>
{
}
;
template
<
>
struct
make_sequence_impl
<
0
>
:
sequence
<
>
{
}
;
}
template
<
unsigned
N
>
using
make_sequence
=
typename
make_sequence_impl
<
N
>
:
:
type
;
template
<
typename
Tuple
unsigned
.
.
.
Indices
>
using
subtuple_t
=
typename
std
:
:
tuple
<
typename
std
:
:
tuple_element
<
Indices
Tuple
>
:
:
type
.
.
.
>
;
template
<
typename
Tuple
unsigned
.
.
.
Indices
>
constexpr
subtuple_t
<
Tuple
Indices
.
.
.
>
make_subtuple
(
const
Tuple
&
tuple
sequence
<
Indices
.
.
.
>
)
{
return
std
:
:
make_tuple
(
std
:
:
get
<
Indices
>
(
tuple
)
.
.
.
)
;
}
static
constexpr
unsigned
long
long
factorial
(
unsigned
n
)
{
return
n
<
=
1
?
1
:
n
*
factorial
(
n
-
1
)
;
}
static
constexpr
double
expi_nonnegative
(
unsigned
n
)
{
return
n
=
=
0
?
1
.
0
:
(
n
=
=
1
?
2
.
718281828459045
:
expi_nonnegative
(
n
/
2
)
*
expi_nonnegative
(
(
n
+
1
)
/
2
)
)
;
}
static
constexpr
double
expi
(
int
n
)
{
return
(
n
>
=
0
?
expi_nonnegative
(
n
)
:
1
.
0
/
expi_nonnegative
(
-
n
)
)
;
}
static
constexpr
float
expif
(
int
n
)
{
return
static_cast
<
float
>
(
expi
(
n
)
)
;
}
static
constexpr
Index
round_up
(
Index
value
Index
factor
)
{
return
(
value
+
factor
-
1
)
/
factor
*
factor
;
}
}
