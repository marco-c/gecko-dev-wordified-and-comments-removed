#
include
"
intgemm
/
intgemm
.
h
"
#
include
"
intgemm
/
aligned
.
h
"
#
include
"
intgemm
/
callbacks
.
h
"
#
include
<
cassert
>
#
include
<
cmath
>
#
include
<
random
>
int
main
(
)
{
using
intgemm
:
:
Index
;
const
Index
A_rows
=
1
;
const
Index
width
=
64
;
const
Index
B_cols
=
8
;
using
intgemm
:
:
AlignedVector
;
AlignedVector
<
float
>
A
(
A_rows
*
width
)
;
AlignedVector
<
float
>
B
(
width
*
B_cols
)
;
std
:
:
mt19937
gen
;
std
:
:
uniform_real_distribution
<
float
>
dist
(
-
2
.
f
2
.
f
)
;
gen
.
seed
(
1
)
;
for
(
auto
&
it
:
A
)
{
it
=
dist
(
gen
)
;
}
for
(
auto
&
it
:
B
)
{
it
=
dist
(
gen
)
;
}
float
top_left_reference
=
0
.
0f
;
for
(
Index
w
=
0
;
w
<
width
;
+
+
w
)
{
top_left_reference
+
=
A
[
w
]
*
B
[
w
*
B_cols
]
;
}
{
float
quant_mult
=
1024
.
0f
;
AlignedVector
<
int16_t
>
A_prepared
(
A
.
size
(
)
)
;
AlignedVector
<
int16_t
>
B_prepared
(
B
.
size
(
)
)
;
intgemm
:
:
Int16
:
:
PrepareA
(
A
.
begin
(
)
A_prepared
.
begin
(
)
quant_mult
A_rows
width
)
;
intgemm
:
:
Int16
:
:
PrepareB
(
B
.
begin
(
)
B_prepared
.
begin
(
)
quant_mult
width
B_cols
)
;
AlignedVector
<
float
>
C
(
A_rows
*
B_cols
)
;
intgemm
:
:
Int16
:
:
Multiply
(
A_prepared
.
begin
(
)
B_prepared
.
begin
(
)
A_rows
width
B_cols
intgemm
:
:
callbacks
:
:
UnquantizeAndWrite
(
1
.
0f
/
(
quant_mult
*
quant_mult
)
C
.
begin
(
)
)
)
;
assert
(
std
:
:
fabs
(
C
[
0
]
-
top_left_reference
)
<
0
.
05f
)
;
}
{
float
quant_mult
=
127
.
0f
/
2
.
0f
;
AlignedVector
<
int8_t
>
A_prepared
(
A
.
size
(
)
)
;
AlignedVector
<
int8_t
>
B_prepared
(
B
.
size
(
)
)
;
intgemm
:
:
Int8
:
:
PrepareA
(
A
.
begin
(
)
A_prepared
.
begin
(
)
quant_mult
A_rows
width
)
;
intgemm
:
:
Int8
:
:
PrepareB
(
B
.
begin
(
)
B_prepared
.
begin
(
)
quant_mult
width
B_cols
)
;
AlignedVector
<
float
>
C
(
A_rows
*
B_cols
)
;
intgemm
:
:
Int8
:
:
Multiply
(
A_prepared
.
begin
(
)
B_prepared
.
begin
(
)
A_rows
width
B_cols
intgemm
:
:
callbacks
:
:
UnquantizeAndWrite
(
1
.
0f
/
(
quant_mult
*
quant_mult
)
C
.
begin
(
)
)
)
;
assert
(
std
:
:
fabs
(
C
[
0
]
-
top_left_reference
)
<
0
.
05f
)
;
}
return
0
;
}
