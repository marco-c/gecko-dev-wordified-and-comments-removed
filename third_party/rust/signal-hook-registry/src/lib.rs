#
!
[
doc
(
test
(
attr
(
deny
(
warnings
)
)
)
)
]
#
!
[
warn
(
missing_docs
)
]
#
!
[
allow
(
unknown_lints
renamed_and_remove_lints
bare_trait_objects
)
]
extern
crate
libc
;
mod
half_lock
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
collections
:
:
{
BTreeMap
HashMap
}
;
use
std
:
:
io
:
:
Error
;
use
std
:
:
mem
;
#
[
cfg
(
not
(
windows
)
)
]
use
std
:
:
ptr
;
#
[
allow
(
deprecated
)
]
use
std
:
:
sync
:
:
ONCE_INIT
;
use
std
:
:
sync
:
:
{
Arc
Once
}
;
#
[
cfg
(
not
(
windows
)
)
]
use
libc
:
:
{
c_int
c_void
sigaction
siginfo_t
}
;
#
[
cfg
(
windows
)
]
use
libc
:
:
{
c_int
sighandler_t
}
;
#
[
cfg
(
not
(
windows
)
)
]
use
libc
:
:
{
SIGFPE
SIGILL
SIGKILL
SIGSEGV
SIGSTOP
}
;
#
[
cfg
(
windows
)
]
use
libc
:
:
{
SIGFPE
SIGILL
SIGSEGV
}
;
use
half_lock
:
:
HalfLock
;
#
[
cfg
(
windows
)
]
const
SIG_DFL
:
sighandler_t
=
0
;
#
[
cfg
(
windows
)
]
const
SIG_IGN
:
sighandler_t
=
1
;
#
[
cfg
(
windows
)
]
const
SIG_GET
:
sighandler_t
=
2
;
#
[
cfg
(
windows
)
]
const
SIG_ERR
:
sighandler_t
=
!
0
;
#
[
cfg
(
windows
)
]
#
[
allow
(
non_camel_case_types
)
]
struct
siginfo_t
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
struct
ActionId
(
u128
)
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
SigId
{
signal
:
c_int
action
:
ActionId
}
#
[
allow
(
unknown_lints
bare_trait_objects
)
]
type
Action
=
Fn
(
&
siginfo_t
)
+
Send
+
Sync
;
#
[
derive
(
Clone
)
]
struct
Slot
{
prev
:
Prev
actions
:
BTreeMap
<
ActionId
Arc
<
Action
>
>
}
impl
Slot
{
#
[
cfg
(
windows
)
]
fn
new
(
signal
:
libc
:
:
c_int
)
-
>
Result
<
Self
Error
>
{
let
old
=
unsafe
{
libc
:
:
signal
(
signal
handler
as
sighandler_t
)
}
;
if
old
=
=
SIG_ERR
{
return
Err
(
Error
:
:
last_os_error
(
)
)
;
}
Ok
(
Slot
{
prev
:
Prev
{
signal
info
:
old
}
actions
:
BTreeMap
:
:
new
(
)
}
)
}
#
[
cfg
(
not
(
windows
)
)
]
fn
new
(
signal
:
libc
:
:
c_int
)
-
>
Result
<
Self
Error
>
{
let
mut
new
:
libc
:
:
sigaction
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
#
[
cfg
(
not
(
target_os
=
"
aix
"
)
)
]
{
new
.
sa_sigaction
=
handler
as
usize
;
}
#
[
cfg
(
target_os
=
"
aix
"
)
]
{
new
.
sa_union
.
__su_sigaction
=
handler
;
}
let
flags
=
libc
:
:
SA_RESTART
;
#
[
allow
(
unused_assignments
)
]
let
mut
siginfo
=
flags
;
siginfo
=
libc
:
:
SA_SIGINFO
as
_
;
let
flags
=
flags
|
siginfo
;
new
.
sa_flags
=
flags
as
_
;
let
mut
old
:
libc
:
:
sigaction
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
if
unsafe
{
libc
:
:
sigaction
(
signal
&
new
&
mut
old
)
}
!
=
0
{
return
Err
(
Error
:
:
last_os_error
(
)
)
;
}
Ok
(
Slot
{
prev
:
Prev
{
signal
info
:
old
}
actions
:
BTreeMap
:
:
new
(
)
}
)
}
}
#
[
derive
(
Clone
)
]
struct
SignalData
{
signals
:
HashMap
<
c_int
Slot
>
next_id
:
u128
}
#
[
derive
(
Clone
)
]
struct
Prev
{
signal
:
c_int
#
[
cfg
(
windows
)
]
info
:
sighandler_t
#
[
cfg
(
not
(
windows
)
)
]
info
:
sigaction
}
impl
Prev
{
#
[
cfg
(
windows
)
]
fn
detect
(
signal
:
c_int
)
-
>
Result
<
Self
Error
>
{
let
old
=
unsafe
{
libc
:
:
signal
(
signal
SIG_GET
)
}
;
if
old
=
=
SIG_ERR
{
return
Err
(
Error
:
:
last_os_error
(
)
)
;
}
Ok
(
Prev
{
signal
info
:
old
}
)
}
#
[
cfg
(
not
(
windows
)
)
]
fn
detect
(
signal
:
c_int
)
-
>
Result
<
Self
Error
>
{
let
mut
old
:
libc
:
:
sigaction
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
if
unsafe
{
libc
:
:
sigaction
(
signal
ptr
:
:
null
(
)
&
mut
old
)
}
!
=
0
{
return
Err
(
Error
:
:
last_os_error
(
)
)
;
}
Ok
(
Prev
{
signal
info
:
old
}
)
}
#
[
cfg
(
windows
)
]
fn
execute
(
&
self
sig
:
c_int
)
{
let
fptr
=
self
.
info
;
if
fptr
!
=
0
&
&
fptr
!
=
SIG_DFL
&
&
fptr
!
=
SIG_IGN
{
unsafe
{
let
action
=
mem
:
:
transmute
:
:
<
usize
extern
"
C
"
fn
(
c_int
)
>
(
fptr
)
;
action
(
sig
)
;
}
}
}
#
[
cfg
(
not
(
windows
)
)
]
unsafe
fn
execute
(
&
self
sig
:
c_int
info
:
*
mut
siginfo_t
data
:
*
mut
c_void
)
{
#
[
cfg
(
not
(
target_os
=
"
aix
"
)
)
]
let
fptr
=
self
.
info
.
sa_sigaction
;
#
[
cfg
(
target_os
=
"
aix
"
)
]
let
fptr
=
self
.
info
.
sa_union
.
__su_sigaction
as
usize
;
if
fptr
!
=
0
&
&
fptr
!
=
libc
:
:
SIG_DFL
&
&
fptr
!
=
libc
:
:
SIG_IGN
{
#
[
allow
(
unused_assignments
)
]
let
mut
siginfo
=
self
.
info
.
sa_flags
;
siginfo
=
libc
:
:
SA_SIGINFO
as
_
;
if
self
.
info
.
sa_flags
&
siginfo
=
=
0
{
let
action
=
mem
:
:
transmute
:
:
<
usize
extern
"
C
"
fn
(
c_int
)
>
(
fptr
)
;
action
(
sig
)
;
}
else
{
type
SigAction
=
extern
"
C
"
fn
(
c_int
*
mut
siginfo_t
*
mut
c_void
)
;
let
action
=
mem
:
:
transmute
:
:
<
usize
SigAction
>
(
fptr
)
;
action
(
sig
info
data
)
;
}
}
}
}
struct
GlobalData
{
data
:
HalfLock
<
SignalData
>
race_fallback
:
HalfLock
<
Option
<
Prev
>
>
}
static
mut
GLOBAL_DATA
:
Option
<
GlobalData
>
=
None
;
#
[
allow
(
deprecated
)
]
static
GLOBAL_INIT
:
Once
=
ONCE_INIT
;
impl
GlobalData
{
fn
get
(
)
-
>
&
'
static
Self
{
unsafe
{
GLOBAL_DATA
.
as_ref
(
)
.
unwrap
(
)
}
}
fn
ensure
(
)
-
>
&
'
static
Self
{
GLOBAL_INIT
.
call_once
(
|
|
unsafe
{
GLOBAL_DATA
=
Some
(
GlobalData
{
data
:
HalfLock
:
:
new
(
SignalData
{
signals
:
HashMap
:
:
new
(
)
next_id
:
1
}
)
race_fallback
:
HalfLock
:
:
new
(
None
)
}
)
;
}
)
;
Self
:
:
get
(
)
}
}
#
[
cfg
(
windows
)
]
extern
"
C
"
fn
handler
(
sig
:
c_int
)
{
if
sig
!
=
SIGFPE
{
let
old
=
unsafe
{
libc
:
:
signal
(
sig
handler
as
sighandler_t
)
}
;
if
old
=
=
SIG_ERR
{
unsafe
{
libc
:
:
abort
(
)
;
}
}
}
let
globals
=
GlobalData
:
:
get
(
)
;
let
fallback
=
globals
.
race_fallback
.
read
(
)
;
let
sigdata
=
globals
.
data
.
read
(
)
;
if
let
Some
(
ref
slot
)
=
sigdata
.
signals
.
get
(
&
sig
)
{
slot
.
prev
.
execute
(
sig
)
;
for
action
in
slot
.
actions
.
values
(
)
{
action
(
&
siginfo_t
)
;
}
}
else
if
let
Some
(
prev
)
=
fallback
.
as_ref
(
)
{
if
sig
=
=
prev
.
signal
{
prev
.
execute
(
sig
)
;
}
}
}
#
[
cfg
(
not
(
windows
)
)
]
extern
"
C
"
fn
handler
(
sig
:
c_int
info
:
*
mut
siginfo_t
data
:
*
mut
c_void
)
{
let
globals
=
GlobalData
:
:
get
(
)
;
let
fallback
=
globals
.
race_fallback
.
read
(
)
;
let
sigdata
=
globals
.
data
.
read
(
)
;
if
let
Some
(
slot
)
=
sigdata
.
signals
.
get
(
&
sig
)
{
unsafe
{
slot
.
prev
.
execute
(
sig
info
data
)
}
;
let
info
=
unsafe
{
info
.
as_ref
(
)
}
;
let
info
=
info
.
unwrap_or_else
(
|
|
{
unsafe
{
const
MSG
:
&
[
u8
]
=
b
"
Platform
broken
got
NULL
as
siginfo
to
signal
handler
.
Aborting
"
;
libc
:
:
write
(
2
MSG
.
as_ptr
(
)
as
*
const
_
MSG
.
len
(
)
)
;
libc
:
:
abort
(
)
;
}
}
)
;
for
action
in
slot
.
actions
.
values
(
)
{
action
(
info
)
;
}
}
else
if
let
Some
(
prev
)
=
fallback
.
as_ref
(
)
{
if
prev
.
signal
=
=
sig
{
unsafe
{
prev
.
execute
(
sig
info
data
)
}
;
}
}
}
pub
const
FORBIDDEN
:
&
[
c_int
]
=
FORBIDDEN_IMPL
;
#
[
cfg
(
windows
)
]
const
FORBIDDEN_IMPL
:
&
[
c_int
]
=
&
[
SIGILL
SIGFPE
SIGSEGV
]
;
#
[
cfg
(
not
(
windows
)
)
]
const
FORBIDDEN_IMPL
:
&
[
c_int
]
=
&
[
SIGKILL
SIGSTOP
SIGILL
SIGFPE
SIGSEGV
]
;
pub
unsafe
fn
register
<
F
>
(
signal
:
c_int
action
:
F
)
-
>
Result
<
SigId
Error
>
where
F
:
Fn
(
)
+
Sync
+
Send
+
'
static
{
register_sigaction_impl
(
signal
move
|
_
:
&
_
|
action
(
)
)
}
#
[
cfg
(
not
(
windows
)
)
]
pub
unsafe
fn
register_sigaction
<
F
>
(
signal
:
c_int
action
:
F
)
-
>
Result
<
SigId
Error
>
where
F
:
Fn
(
&
siginfo_t
)
+
Sync
+
Send
+
'
static
{
register_sigaction_impl
(
signal
action
)
}
unsafe
fn
register_sigaction_impl
<
F
>
(
signal
:
c_int
action
:
F
)
-
>
Result
<
SigId
Error
>
where
F
:
Fn
(
&
siginfo_t
)
+
Sync
+
Send
+
'
static
{
assert
!
(
!
FORBIDDEN
.
contains
(
&
signal
)
"
Attempted
to
register
forbidden
signal
{
}
"
signal
)
;
register_unchecked_impl
(
signal
action
)
}
pub
unsafe
fn
register_signal_unchecked
<
F
>
(
signal
:
c_int
action
:
F
)
-
>
Result
<
SigId
Error
>
where
F
:
Fn
(
)
+
Sync
+
Send
+
'
static
{
register_unchecked_impl
(
signal
move
|
_
:
&
_
|
action
(
)
)
}
#
[
cfg
(
not
(
windows
)
)
]
pub
unsafe
fn
register_unchecked
<
F
>
(
signal
:
c_int
action
:
F
)
-
>
Result
<
SigId
Error
>
where
F
:
Fn
(
&
siginfo_t
)
+
Sync
+
Send
+
'
static
{
register_unchecked_impl
(
signal
action
)
}
unsafe
fn
register_unchecked_impl
<
F
>
(
signal
:
c_int
action
:
F
)
-
>
Result
<
SigId
Error
>
where
F
:
Fn
(
&
siginfo_t
)
+
Sync
+
Send
+
'
static
{
let
globals
=
GlobalData
:
:
ensure
(
)
;
let
action
=
Arc
:
:
from
(
action
)
;
let
mut
lock
=
globals
.
data
.
write
(
)
;
let
mut
sigdata
=
SignalData
:
:
clone
(
&
lock
)
;
let
id
=
ActionId
(
sigdata
.
next_id
)
;
sigdata
.
next_id
+
=
1
;
match
sigdata
.
signals
.
entry
(
signal
)
{
Entry
:
:
Occupied
(
mut
occupied
)
=
>
{
assert
!
(
occupied
.
get_mut
(
)
.
actions
.
insert
(
id
action
)
.
is_none
(
)
)
;
}
Entry
:
:
Vacant
(
place
)
=
>
{
globals
.
race_fallback
.
write
(
)
.
store
(
Some
(
Prev
:
:
detect
(
signal
)
?
)
)
;
let
mut
slot
=
Slot
:
:
new
(
signal
)
?
;
slot
.
actions
.
insert
(
id
action
)
;
place
.
insert
(
slot
)
;
}
}
lock
.
store
(
sigdata
)
;
Ok
(
SigId
{
signal
action
:
id
}
)
}
pub
fn
unregister
(
id
:
SigId
)
-
>
bool
{
let
globals
=
GlobalData
:
:
ensure
(
)
;
let
mut
replace
=
false
;
let
mut
lock
=
globals
.
data
.
write
(
)
;
let
mut
sigdata
=
SignalData
:
:
clone
(
&
lock
)
;
if
let
Some
(
slot
)
=
sigdata
.
signals
.
get_mut
(
&
id
.
signal
)
{
replace
=
slot
.
actions
.
remove
(
&
id
.
action
)
.
is_some
(
)
;
}
if
replace
{
lock
.
store
(
sigdata
)
;
}
replace
}
#
[
deprecated
(
since
=
"
1
.
3
.
0
"
note
=
"
Don
'
t
use
.
Can
influence
unrelated
parts
of
program
/
unknown
actions
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
unregister_signal
(
signal
:
c_int
)
-
>
bool
{
let
globals
=
GlobalData
:
:
ensure
(
)
;
let
mut
replace
=
false
;
let
mut
lock
=
globals
.
data
.
write
(
)
;
let
mut
sigdata
=
SignalData
:
:
clone
(
&
lock
)
;
if
let
Some
(
slot
)
=
sigdata
.
signals
.
get_mut
(
&
signal
)
{
if
!
slot
.
actions
.
is_empty
(
)
{
slot
.
actions
.
clear
(
)
;
replace
=
true
;
}
}
if
replace
{
lock
.
store
(
sigdata
)
;
}
replace
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
Duration
;
#
[
cfg
(
not
(
windows
)
)
]
use
libc
:
:
{
pid_t
SIGUSR1
SIGUSR2
}
;
#
[
cfg
(
windows
)
]
use
libc
:
:
SIGTERM
as
SIGUSR1
;
#
[
cfg
(
windows
)
]
use
libc
:
:
SIGTERM
as
SIGUSR2
;
use
super
:
:
*
;
#
[
test
]
#
[
should_panic
]
fn
panic_forbidden
(
)
{
let
_
=
unsafe
{
register
(
SIGILL
|
|
(
)
)
}
;
}
#
[
test
]
#
[
allow
(
clippy
:
:
redundant_closure
)
]
fn
forbidden_raw
(
)
{
unsafe
{
register_signal_unchecked
(
SIGFPE
|
|
std
:
:
process
:
:
abort
(
)
)
.
unwrap
(
)
}
;
}
#
[
test
]
fn
signal_without_pid
(
)
{
let
status
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
action
=
{
let
status
=
Arc
:
:
clone
(
&
status
)
;
move
|
|
{
status
.
store
(
1
Ordering
:
:
Relaxed
)
;
}
}
;
unsafe
{
register
(
SIGUSR2
action
)
.
unwrap
(
)
;
libc
:
:
raise
(
SIGUSR2
)
;
}
for
_
in
0
.
.
10
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
100
)
)
;
let
current
=
status
.
load
(
Ordering
:
:
Relaxed
)
;
match
current
{
0
=
>
continue
_
if
current
=
=
1
=
>
return
_
=
>
panic
!
(
"
Wrong
result
value
{
}
"
current
)
}
}
panic
!
(
"
Timed
out
waiting
for
the
signal
"
)
;
}
#
[
test
]
#
[
cfg
(
not
(
windows
)
)
]
fn
signal_with_pid
(
)
{
let
status
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
action
=
{
let
status
=
Arc
:
:
clone
(
&
status
)
;
move
|
siginfo
:
&
siginfo_t
|
{
#
[
repr
(
C
)
]
struct
SigInfo
{
_fields
:
[
c_int
;
3
]
#
[
cfg
(
all
(
target_pointer_width
=
"
64
"
target_os
=
"
linux
"
)
)
]
_pad
:
c_int
pid
:
pid_t
}
let
s
:
&
SigInfo
=
unsafe
{
(
siginfo
as
*
const
_
as
usize
as
*
const
SigInfo
)
.
as_ref
(
)
.
unwrap
(
)
}
;
status
.
store
(
s
.
pid
as
usize
Ordering
:
:
Relaxed
)
;
}
}
;
let
pid
;
unsafe
{
pid
=
libc
:
:
getpid
(
)
;
register_sigaction
(
SIGUSR2
action
)
.
unwrap
(
)
;
libc
:
:
raise
(
SIGUSR2
)
;
}
for
_
in
0
.
.
10
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
100
)
)
;
let
current
=
status
.
load
(
Ordering
:
:
Relaxed
)
;
match
current
{
0
=
>
continue
_
if
current
=
=
pid
as
usize
=
>
return
_
=
>
panic
!
(
"
Wrong
status
value
{
}
"
current
)
}
}
panic
!
(
"
Timed
out
waiting
for
the
signal
"
)
;
}
#
[
test
]
fn
register_unregister
(
)
{
let
signal
=
unsafe
{
register
(
SIGUSR1
|
|
(
)
)
.
unwrap
(
)
}
;
assert
!
(
unregister
(
signal
)
)
;
assert
!
(
!
unregister
(
signal
)
)
;
}
}
