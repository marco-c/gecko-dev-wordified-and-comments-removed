#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
quote
/
0
.
6
.
3
"
)
]
#
[
cfg
(
feature
=
"
proc
-
macro
"
)
]
extern
crate
proc_macro
;
extern
crate
proc_macro2
;
mod
ext
;
pub
use
ext
:
:
TokenStreamExt
;
mod
to_tokens
;
pub
use
to_tokens
:
:
ToTokens
;
#
[
doc
(
hidden
)
]
pub
mod
__rt
{
pub
use
proc_macro2
:
:
*
;
pub
fn
parse
(
tokens
:
&
mut
TokenStream
span
:
Span
s
:
&
str
)
{
let
s
:
TokenStream
=
s
.
parse
(
)
.
expect
(
"
invalid
token
stream
"
)
;
tokens
.
extend
(
s
.
into_iter
(
)
.
map
(
|
mut
t
|
{
t
.
set_span
(
span
)
;
t
}
)
)
;
}
}
#
[
macro_export
]
macro_rules
!
quote
{
(
(
tt
:
tt
)
*
)
=
>
(
quote_spanned
!
(
crate
:
:
__rt
:
:
Span
:
:
call_site
(
)
=
>
(
tt
)
*
)
)
;
}
#
[
macro_export
]
macro_rules
!
quote_spanned
{
(
span
:
expr
=
>
(
tt
:
tt
)
*
)
=
>
{
{
let
mut
_s
=
crate
:
:
__rt
:
:
TokenStream
:
:
new
(
)
;
let
_span
=
span
;
quote_each_token
!
(
_s
_span
(
tt
)
*
)
;
_s
}
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
pounded_var_names
{
(
finish
:
ident
(
(
found
:
ident
)
*
)
#
(
(
inner
:
tt
)
*
)
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
inner
)
*
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
#
[
(
inner
:
tt
)
*
]
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
inner
)
*
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
#
{
(
inner
:
tt
)
*
}
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
inner
)
*
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
#
first
:
ident
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
first
)
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
(
(
inner
:
tt
)
*
)
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
inner
)
*
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
[
(
inner
:
tt
)
*
]
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
inner
)
*
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
{
(
inner
:
tt
)
*
}
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
inner
)
*
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
ignore
:
tt
(
rest
:
tt
)
*
)
=
>
{
pounded_var_names
!
(
finish
(
(
found
)
*
)
(
rest
)
*
)
}
;
(
finish
:
ident
(
(
found
:
ident
)
*
)
)
=
>
{
finish
!
(
(
)
(
found
)
*
)
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
nested_tuples_pat
{
(
(
)
)
=
>
{
&
(
)
}
;
(
(
)
first
:
ident
(
rest
:
ident
)
*
)
=
>
{
nested_tuples_pat
!
(
(
first
)
(
rest
)
*
)
}
;
(
(
pat
:
pat
)
first
:
ident
(
rest
:
ident
)
*
)
=
>
{
nested_tuples_pat
!
(
(
(
pat
first
)
)
(
rest
)
*
)
}
;
(
(
done
:
pat
)
)
=
>
{
done
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
multi_zip_expr
{
(
(
)
)
=
>
{
&
[
]
}
;
(
(
)
single
:
ident
)
=
>
{
single
}
;
(
(
)
first
:
ident
(
rest
:
ident
)
*
)
=
>
{
multi_zip_expr
!
(
(
first
.
into_iter
(
)
)
(
rest
)
*
)
}
;
(
(
zips
:
expr
)
first
:
ident
(
rest
:
ident
)
*
)
=
>
{
multi_zip_expr
!
(
(
zips
.
zip
(
first
)
)
(
rest
)
*
)
}
;
(
(
done
:
expr
)
)
=
>
{
done
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_each_token
{
(
tokens
:
ident
span
:
ident
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
#
!
(
rest
:
tt
)
*
)
=
>
{
quote_each_token
!
(
tokens
span
#
)
;
quote_each_token
!
(
tokens
span
!
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
#
(
(
inner
:
tt
)
*
)
*
(
rest
:
tt
)
*
)
=
>
{
for
pounded_var_names
!
(
nested_tuples_pat
(
)
(
inner
)
*
)
in
pounded_var_names
!
(
multi_zip_expr
(
)
(
inner
)
*
)
{
quote_each_token
!
(
tokens
span
(
inner
)
*
)
;
}
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
#
(
(
inner
:
tt
)
*
)
sep
:
tt
*
(
rest
:
tt
)
*
)
=
>
{
for
(
_i
pounded_var_names
!
(
nested_tuples_pat
(
)
(
inner
)
*
)
)
in
pounded_var_names
!
(
multi_zip_expr
(
)
(
inner
)
*
)
.
into_iter
(
)
.
enumerate
(
)
{
if
_i
>
0
{
quote_each_token
!
(
tokens
span
sep
)
;
}
quote_each_token
!
(
tokens
span
(
inner
)
*
)
;
}
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
#
[
(
inner
:
tt
)
*
]
(
rest
:
tt
)
*
)
=
>
{
quote_each_token
!
(
tokens
span
#
)
;
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Bracket
quote_spanned
!
(
span
=
>
(
inner
)
*
)
.
into
(
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
#
first
:
ident
(
rest
:
tt
)
*
)
=
>
{
crate
:
:
ToTokens
:
:
to_tokens
(
&
first
&
mut
tokens
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
(
(
first
:
tt
)
*
)
(
rest
:
tt
)
*
)
=
>
{
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Parenthesis
quote_spanned
!
(
span
=
>
(
first
)
*
)
.
into
(
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
[
(
first
:
tt
)
*
]
(
rest
:
tt
)
*
)
=
>
{
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Bracket
quote_spanned
!
(
span
=
>
(
first
)
*
)
.
into
(
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
{
(
first
:
tt
)
*
}
(
rest
:
tt
)
*
)
=
>
{
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Brace
quote_spanned
!
(
span
=
>
(
first
)
*
)
.
into
(
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
(
tokens
:
ident
span
:
ident
first
:
tt
(
rest
:
tt
)
*
)
=
>
{
/
/
TODO
:
this
seems
slow
.
.
.
special
case
some
:
tt
arguments
?
crate
:
:
__rt
:
:
parse
(
&
mut
tokens
span
stringify
!
(
first
)
)
;
quote_each_token
!
(
tokens
span
(
rest
)
*
)
;
}
;
}
