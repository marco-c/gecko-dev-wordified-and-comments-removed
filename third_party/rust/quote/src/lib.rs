#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
quote
/
1
.
0
.
2
"
)
]
#
[
cfg
(
all
(
not
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
)
feature
=
"
proc
-
macro
"
)
)
]
extern
crate
proc_macro
;
mod
ext
;
mod
format
;
mod
ident_fragment
;
mod
to_tokens
;
#
[
doc
(
hidden
)
]
#
[
path
=
"
runtime
.
rs
"
]
pub
mod
__rt
;
pub
use
crate
:
:
ext
:
:
TokenStreamExt
;
pub
use
crate
:
:
ident_fragment
:
:
IdentFragment
;
pub
use
crate
:
:
to_tokens
:
:
ToTokens
;
#
[
doc
(
hidden
)
]
pub
mod
spanned
;
#
[
macro_export
]
macro_rules
!
quote
{
(
(
tt
:
tt
)
*
)
=
>
{
crate
:
:
quote_spanned
!
(
crate
:
:
__rt
:
:
Span
:
:
call_site
(
)
=
>
(
tt
)
*
)
}
;
}
#
[
macro_export
]
macro_rules
!
quote_spanned
{
(
span
:
expr
=
>
(
tt
:
tt
)
*
)
=
>
{
{
let
mut
_s
=
crate
:
:
__rt
:
:
TokenStream
:
:
new
(
)
;
let
_span
:
crate
:
:
__rt
:
:
Span
=
span
;
crate
:
:
quote_each_token
!
(
_s
_span
(
tt
)
*
)
;
_s
}
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
pounded_var_names
{
(
call
:
ident
!
extra
:
tt
(
tts
:
tt
)
*
)
=
>
{
crate
:
:
pounded_var_names_with_context
!
(
call
!
extra
(
(
tts
)
*
)
(
(
tts
)
*
)
)
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
pounded_var_names_with_context
{
(
call
:
ident
!
extra
:
tt
(
(
b1
:
tt
)
*
)
(
(
curr
:
tt
)
*
)
)
=
>
{
(
crate
:
:
pounded_var_with_context
!
(
call
!
extra
b1
curr
)
;
)
*
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
pounded_var_with_context
{
(
call
:
ident
!
extra
:
tt
b1
:
tt
(
(
inner
:
tt
)
*
)
)
=
>
{
crate
:
:
pounded_var_names
!
(
call
!
extra
(
inner
)
*
)
;
}
;
(
call
:
ident
!
extra
:
tt
b1
:
tt
[
(
inner
:
tt
)
*
]
)
=
>
{
crate
:
:
pounded_var_names
!
(
call
!
extra
(
inner
)
*
)
;
}
;
(
call
:
ident
!
extra
:
tt
b1
:
tt
{
(
inner
:
tt
)
*
}
)
=
>
{
crate
:
:
pounded_var_names
!
(
call
!
extra
(
inner
)
*
)
;
}
;
(
call
:
ident
!
(
(
extra
:
tt
)
*
)
#
var
:
ident
)
=
>
{
crate
:
:
call
!
(
(
extra
)
*
var
)
;
}
;
(
call
:
ident
!
extra
:
tt
b1
:
tt
curr
:
tt
)
=
>
{
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_bind_into_iter
{
(
has_iter
:
ident
var
:
ident
)
=
>
{
/
/
mut
may
be
unused
if
var
occurs
multiple
times
in
the
list
.
#
[
allow
(
unused_mut
)
]
let
(
mut
var
i
)
=
var
.
quote_into_iter
(
)
;
let
has_iter
=
has_iter
|
i
;
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_bind_next_or_break
{
(
var
:
ident
)
=
>
{
let
var
=
match
var
.
next
(
)
{
Some
(
_x
)
=
>
crate
:
:
__rt
:
:
RepInterp
(
_x
)
None
=
>
break
}
;
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_each_token
{
(
tokens
:
ident
span
:
ident
(
tts
:
tt
)
*
)
=
>
{
crate
:
:
quote_tokens_with_context
!
(
tokens
span
(
(
tts
)
*
)
(
(
tts
)
*
)
(
(
tts
)
*
)
(
(
(
tts
)
)
*
)
(
(
tts
)
*
)
(
(
tts
)
*
)
(
(
tts
)
*
)
)
;
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_tokens_with_context
{
(
tokens
:
ident
span
:
ident
(
(
b3
:
tt
)
*
)
(
(
b2
:
tt
)
*
)
(
(
b1
:
tt
)
*
)
(
(
curr
:
tt
)
*
)
(
(
a1
:
tt
)
*
)
(
(
a2
:
tt
)
*
)
(
(
a3
:
tt
)
*
)
)
=
>
{
(
crate
:
:
quote_token_with_context
!
(
tokens
span
b3
b2
b1
curr
a1
a2
a3
)
;
)
*
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_token_with_context
{
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
b1
:
tt
a1
:
tt
a2
:
tt
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
b1
:
tt
(
#
)
(
(
inner
:
tt
)
*
)
*
a3
:
tt
)
=
>
{
{
use
crate
:
:
__rt
:
:
ext
:
:
*
;
let
has_iter
=
crate
:
:
__rt
:
:
ThereIsNoIteratorInRepetition
;
crate
:
:
pounded_var_names
!
(
quote_bind_into_iter
!
(
has_iter
)
(
)
(
inner
)
*
)
;
let
_
:
crate
:
:
__rt
:
:
HasIterator
=
has_iter
;
/
/
This
is
while
true
instead
of
loop
because
if
there
are
no
/
/
iterators
used
inside
of
this
repetition
then
the
body
would
not
/
/
contain
any
break
so
the
compiler
would
emit
unreachable
code
/
/
warnings
on
anything
below
the
loop
.
We
use
has_iter
to
detect
and
/
/
fail
to
compile
when
there
are
no
iterators
so
here
we
just
work
/
/
around
the
unneeded
extra
warning
.
while
true
{
crate
:
:
pounded_var_names
!
(
quote_bind_next_or_break
!
(
)
(
)
(
inner
)
*
)
;
crate
:
:
quote_each_token
!
(
tokens
span
(
inner
)
*
)
;
}
}
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
#
(
(
(
inner
:
tt
)
*
)
)
*
a2
:
tt
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
#
(
(
inner
:
tt
)
*
)
(
*
)
a1
:
tt
a2
:
tt
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
b1
:
tt
(
#
)
(
(
inner
:
tt
)
*
)
sep
:
tt
*
)
=
>
{
{
use
crate
:
:
__rt
:
:
ext
:
:
*
;
let
mut
_i
=
0usize
;
let
has_iter
=
crate
:
:
__rt
:
:
ThereIsNoIteratorInRepetition
;
crate
:
:
pounded_var_names
!
(
quote_bind_into_iter
!
(
has_iter
)
(
)
(
inner
)
*
)
;
let
_
:
crate
:
:
__rt
:
:
HasIterator
=
has_iter
;
while
true
{
crate
:
:
pounded_var_names
!
(
quote_bind_next_or_break
!
(
)
(
)
(
inner
)
*
)
;
if
_i
>
0
{
crate
:
:
quote_token
!
(
tokens
span
sep
)
;
}
_i
+
=
1
;
crate
:
:
quote_each_token
!
(
tokens
span
(
inner
)
*
)
;
}
}
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
#
(
(
(
inner
:
tt
)
*
)
)
sep
:
tt
*
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
#
(
(
inner
:
tt
)
*
)
(
sep
:
tt
)
*
a2
:
tt
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
#
(
(
inner
:
tt
)
*
)
*
(
*
)
a1
:
tt
a2
:
tt
a3
:
tt
)
=
>
{
/
/
https
:
/
/
github
.
com
/
dtolnay
/
quote
/
issues
/
130
crate
:
:
quote_token
!
(
tokens
span
*
)
;
}
;
(
tokens
:
ident
span
:
ident
#
(
(
inner
:
tt
)
*
)
sep
:
tt
(
*
)
a1
:
tt
a2
:
tt
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
b1
:
tt
(
#
)
var
:
ident
a2
:
tt
a3
:
tt
)
=
>
{
crate
:
:
ToTokens
:
:
to_tokens
(
&
var
&
mut
tokens
)
;
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
#
(
var
:
ident
)
a1
:
tt
a2
:
tt
a3
:
tt
)
=
>
{
}
;
(
tokens
:
ident
span
:
ident
b3
:
tt
b2
:
tt
b1
:
tt
(
curr
:
tt
)
a1
:
tt
a2
:
tt
a3
:
tt
)
=
>
{
crate
:
:
quote_token
!
(
tokens
span
curr
)
;
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
quote_token
{
(
tokens
:
ident
span
:
ident
(
(
inner
:
tt
)
*
)
)
=
>
{
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Parenthesis
crate
:
:
quote_spanned
!
(
span
=
>
(
inner
)
*
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
}
;
(
tokens
:
ident
span
:
ident
[
(
inner
:
tt
)
*
]
)
=
>
{
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Bracket
crate
:
:
quote_spanned
!
(
span
=
>
(
inner
)
*
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
}
;
(
tokens
:
ident
span
:
ident
{
(
inner
:
tt
)
*
}
)
=
>
{
tokens
.
extend
(
{
let
mut
g
=
crate
:
:
__rt
:
:
Group
:
:
new
(
crate
:
:
__rt
:
:
Delimiter
:
:
Brace
crate
:
:
quote_spanned
!
(
span
=
>
(
inner
)
*
)
)
;
g
.
set_span
(
span
)
;
Some
(
crate
:
:
__rt
:
:
TokenTree
:
:
from
(
g
)
)
}
)
;
}
;
(
tokens
:
ident
span
:
ident
+
)
=
>
{
crate
:
:
__rt
:
:
push_add
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
+
=
)
=
>
{
crate
:
:
__rt
:
:
push_add_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
&
)
=
>
{
crate
:
:
__rt
:
:
push_and
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
&
&
)
=
>
{
crate
:
:
__rt
:
:
push_and_and
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
&
=
)
=
>
{
crate
:
:
__rt
:
:
push_and_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
)
=
>
{
crate
:
:
__rt
:
:
push_at
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
!
)
=
>
{
crate
:
:
__rt
:
:
push_bang
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
^
)
=
>
{
crate
:
:
__rt
:
:
push_caret
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
^
=
)
=
>
{
crate
:
:
__rt
:
:
push_caret_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
:
)
=
>
{
crate
:
:
__rt
:
:
push_colon
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
:
:
)
=
>
{
crate
:
:
__rt
:
:
push_colon2
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
)
=
>
{
crate
:
:
__rt
:
:
push_comma
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
/
)
=
>
{
crate
:
:
__rt
:
:
push_div
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
/
=
)
=
>
{
crate
:
:
__rt
:
:
push_div_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
.
)
=
>
{
crate
:
:
__rt
:
:
push_dot
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
.
.
)
=
>
{
crate
:
:
__rt
:
:
push_dot2
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
.
.
.
)
=
>
{
crate
:
:
__rt
:
:
push_dot3
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
.
.
=
)
=
>
{
crate
:
:
__rt
:
:
push_dot_dot_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
=
)
=
>
{
crate
:
:
__rt
:
:
push_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
=
=
)
=
>
{
crate
:
:
__rt
:
:
push_eq_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
>
=
)
=
>
{
crate
:
:
__rt
:
:
push_ge
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
>
)
=
>
{
crate
:
:
__rt
:
:
push_gt
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
<
=
)
=
>
{
crate
:
:
__rt
:
:
push_le
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
<
)
=
>
{
crate
:
:
__rt
:
:
push_lt
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
*
=
)
=
>
{
crate
:
:
__rt
:
:
push_mul_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
!
=
)
=
>
{
crate
:
:
__rt
:
:
push_ne
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
|
)
=
>
{
crate
:
:
__rt
:
:
push_or
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
|
=
)
=
>
{
crate
:
:
__rt
:
:
push_or_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
|
|
)
=
>
{
crate
:
:
__rt
:
:
push_or_or
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
#
)
=
>
{
crate
:
:
__rt
:
:
push_pound
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
?
)
=
>
{
crate
:
:
__rt
:
:
push_question
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
-
>
)
=
>
{
crate
:
:
__rt
:
:
push_rarrow
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
<
-
)
=
>
{
crate
:
:
__rt
:
:
push_larrow
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
%
)
=
>
{
crate
:
:
__rt
:
:
push_rem
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
%
=
)
=
>
{
crate
:
:
__rt
:
:
push_rem_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
=
>
)
=
>
{
crate
:
:
__rt
:
:
push_fat_arrow
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
;
)
=
>
{
crate
:
:
__rt
:
:
push_semi
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
<
<
)
=
>
{
crate
:
:
__rt
:
:
push_shl
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
<
<
=
)
=
>
{
crate
:
:
__rt
:
:
push_shl_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
>
>
)
=
>
{
crate
:
:
__rt
:
:
push_shr
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
>
>
=
)
=
>
{
crate
:
:
__rt
:
:
push_shr_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
*
)
=
>
{
crate
:
:
__rt
:
:
push_star
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
-
)
=
>
{
crate
:
:
__rt
:
:
push_sub
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
-
=
)
=
>
{
crate
:
:
__rt
:
:
push_sub_eq
(
&
mut
tokens
span
)
;
}
;
(
tokens
:
ident
span
:
ident
other
:
tt
)
=
>
{
crate
:
:
__rt
:
:
parse
(
&
mut
tokens
span
stringify
!
(
other
)
)
;
}
;
}
