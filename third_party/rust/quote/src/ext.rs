use
super
:
:
ToTokens
;
use
proc_macro2
:
:
{
TokenStream
TokenTree
}
;
pub
trait
TokenStreamExt
:
private
:
:
Sealed
{
fn
append
<
U
>
(
&
mut
self
token
:
U
)
where
U
:
Into
<
TokenTree
>
;
fn
append_all
<
T
I
>
(
&
mut
self
iter
:
I
)
where
T
:
ToTokens
I
:
IntoIterator
<
Item
=
T
>
;
fn
append_separated
<
T
I
U
>
(
&
mut
self
iter
:
I
op
:
U
)
where
T
:
ToTokens
I
:
IntoIterator
<
Item
=
T
>
U
:
ToTokens
;
fn
append_terminated
<
T
I
U
>
(
&
mut
self
iter
:
I
term
:
U
)
where
T
:
ToTokens
I
:
IntoIterator
<
Item
=
T
>
U
:
ToTokens
;
}
impl
TokenStreamExt
for
TokenStream
{
fn
append
<
U
>
(
&
mut
self
token
:
U
)
where
U
:
Into
<
TokenTree
>
{
self
.
extend
(
Some
(
token
.
into
(
)
)
)
;
}
fn
append_all
<
T
I
>
(
&
mut
self
iter
:
I
)
where
T
:
ToTokens
I
:
IntoIterator
<
Item
=
T
>
{
for
token
in
iter
{
token
.
to_tokens
(
self
)
;
}
}
fn
append_separated
<
T
I
U
>
(
&
mut
self
iter
:
I
op
:
U
)
where
T
:
ToTokens
I
:
IntoIterator
<
Item
=
T
>
U
:
ToTokens
{
for
(
i
token
)
in
iter
.
into_iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
op
.
to_tokens
(
self
)
;
}
token
.
to_tokens
(
self
)
;
}
}
fn
append_terminated
<
T
I
U
>
(
&
mut
self
iter
:
I
term
:
U
)
where
T
:
ToTokens
I
:
IntoIterator
<
Item
=
T
>
U
:
ToTokens
{
for
token
in
iter
{
token
.
to_tokens
(
self
)
;
term
.
to_tokens
(
self
)
;
}
}
}
mod
private
{
use
proc_macro2
:
:
TokenStream
;
pub
trait
Sealed
{
}
impl
Sealed
for
TokenStream
{
}
}
