use
core
:
:
fmt
;
use
proc_macro2
:
:
{
Ident
Span
}
;
use
std
:
:
borrow
:
:
Cow
;
pub
trait
IdentFragment
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
;
fn
span
(
&
self
)
-
>
Option
<
Span
>
{
None
}
}
impl
<
T
:
IdentFragment
+
?
Sized
>
IdentFragment
for
&
T
{
fn
span
(
&
self
)
-
>
Option
<
Span
>
{
<
T
as
IdentFragment
>
:
:
span
(
*
self
)
}
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
IdentFragment
:
:
fmt
(
*
self
f
)
}
}
impl
<
T
:
IdentFragment
+
?
Sized
>
IdentFragment
for
&
mut
T
{
fn
span
(
&
self
)
-
>
Option
<
Span
>
{
<
T
as
IdentFragment
>
:
:
span
(
*
self
)
}
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
IdentFragment
:
:
fmt
(
*
self
f
)
}
}
impl
IdentFragment
for
Ident
{
fn
span
(
&
self
)
-
>
Option
<
Span
>
{
Some
(
self
.
span
(
)
)
}
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
id
=
self
.
to_string
(
)
;
if
id
.
starts_with
(
"
r
#
"
)
{
fmt
:
:
Display
:
:
fmt
(
&
id
[
2
.
.
]
f
)
}
else
{
fmt
:
:
Display
:
:
fmt
(
&
id
[
.
.
]
f
)
}
}
}
impl
<
T
>
IdentFragment
for
Cow
<
'
_
T
>
where
T
:
IdentFragment
+
ToOwned
+
?
Sized
{
fn
span
(
&
self
)
-
>
Option
<
Span
>
{
T
:
:
span
(
self
)
}
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
T
:
:
fmt
(
self
f
)
}
}
macro_rules
!
ident_fragment_display
{
(
(
T
:
ty
)
*
)
=
>
{
(
impl
IdentFragment
for
T
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
)
*
}
;
}
ident_fragment_display
!
(
bool
str
String
char
)
;
ident_fragment_display
!
(
u8
u16
u32
u64
u128
usize
)
;
