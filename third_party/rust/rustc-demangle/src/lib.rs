#
!
[
no_std
]
#
!
[
deny
(
missing_docs
)
]
#
[
cfg
(
test
)
]
#
[
macro_use
]
extern
crate
std
;
use
core
:
:
fmt
;
pub
struct
Demangle
<
'
a
>
{
original
:
&
'
a
str
inner
:
&
'
a
str
valid
:
bool
elements
:
usize
}
pub
fn
demangle
(
mut
s
:
&
str
)
-
>
Demangle
{
let
llvm
=
"
.
llvm
.
"
;
if
let
Some
(
i
)
=
s
.
find
(
llvm
)
{
let
candidate
=
&
s
[
i
+
llvm
.
len
(
)
.
.
]
;
let
all_hex
=
candidate
.
chars
(
)
.
all
(
|
c
|
{
match
c
{
'
A
'
.
.
.
'
F
'
|
'
0
'
.
.
.
'
9
'
|
'
'
=
>
true
_
=
>
false
}
}
)
;
if
all_hex
{
s
=
&
s
[
.
.
i
]
;
}
}
let
mut
valid
=
true
;
let
mut
inner
=
s
;
if
s
.
len
(
)
>
4
&
&
s
.
starts_with
(
"
_ZN
"
)
&
&
s
.
ends_with
(
'
E
'
)
{
inner
=
&
s
[
3
.
.
s
.
len
(
)
-
1
]
;
}
else
if
s
.
len
(
)
>
3
&
&
s
.
starts_with
(
"
ZN
"
)
&
&
s
.
ends_with
(
'
E
'
)
{
inner
=
&
s
[
2
.
.
s
.
len
(
)
-
1
]
;
}
else
if
s
.
len
(
)
>
5
&
&
s
.
starts_with
(
"
__ZN
"
)
&
&
s
.
ends_with
(
'
E
'
)
{
inner
=
&
s
[
4
.
.
s
.
len
(
)
-
1
]
;
}
else
{
valid
=
false
;
}
if
inner
.
bytes
(
)
.
any
(
|
c
|
c
&
0x80
!
=
0
)
{
valid
=
false
;
}
let
mut
elements
=
0
;
if
valid
{
let
mut
chars
=
inner
.
chars
(
)
.
peekable
(
)
;
while
valid
{
let
mut
i
=
0usize
;
while
let
Some
(
&
c
)
=
chars
.
peek
(
)
{
if
!
c
.
is_digit
(
10
)
{
break
}
chars
.
next
(
)
;
let
next
=
i
.
checked_mul
(
10
)
.
and_then
(
|
i
|
i
.
checked_add
(
c
as
usize
-
'
0
'
as
usize
)
)
;
i
=
match
next
{
Some
(
i
)
=
>
i
None
=
>
{
valid
=
false
;
break
}
}
;
}
if
i
=
=
0
{
valid
=
chars
.
next
(
)
.
is_none
(
)
;
break
;
}
else
if
chars
.
by_ref
(
)
.
take
(
i
)
.
count
(
)
!
=
i
{
valid
=
false
;
}
else
{
elements
+
=
1
;
}
}
}
Demangle
{
inner
:
inner
valid
:
valid
elements
:
elements
original
:
s
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TryDemangleError
{
_priv
:
(
)
}
pub
fn
try_demangle
(
s
:
&
str
)
-
>
Result
<
Demangle
TryDemangleError
>
{
let
sym
=
demangle
(
s
)
;
if
sym
.
valid
{
Ok
(
sym
)
}
else
{
Err
(
TryDemangleError
{
_priv
:
(
)
}
)
}
}
impl
<
'
a
>
Demangle
<
'
a
>
{
pub
fn
as_str
(
&
self
)
-
>
&
'
a
str
{
self
.
original
}
}
fn
is_rust_hash
(
s
:
&
str
)
-
>
bool
{
s
.
starts_with
(
'
h
'
)
&
&
s
[
1
.
.
]
.
chars
(
)
.
all
(
|
c
|
c
.
is_digit
(
16
)
)
}
impl
<
'
a
>
fmt
:
:
Display
for
Demangle
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
!
self
.
valid
{
return
f
.
write_str
(
self
.
inner
)
;
}
let
mut
inner
=
self
.
inner
;
for
element
in
0
.
.
self
.
elements
{
let
mut
rest
=
inner
;
while
rest
.
chars
(
)
.
next
(
)
.
unwrap
(
)
.
is_digit
(
10
)
{
rest
=
&
rest
[
1
.
.
]
;
}
let
i
:
usize
=
inner
[
.
.
(
inner
.
len
(
)
-
rest
.
len
(
)
)
]
.
parse
(
)
.
unwrap
(
)
;
inner
=
&
rest
[
i
.
.
]
;
rest
=
&
rest
[
.
.
i
]
;
if
f
.
alternate
(
)
&
&
element
+
1
=
=
self
.
elements
&
&
is_rust_hash
(
&
rest
)
{
break
;
}
if
element
!
=
0
{
try
!
(
f
.
write_str
(
"
:
:
"
)
)
;
}
if
rest
.
starts_with
(
"
_
"
)
{
rest
=
&
rest
[
1
.
.
]
;
}
while
!
rest
.
is_empty
(
)
{
if
rest
.
starts_with
(
'
.
'
)
{
if
let
Some
(
'
.
'
)
=
rest
[
1
.
.
]
.
chars
(
)
.
next
(
)
{
try
!
(
f
.
write_str
(
"
:
:
"
)
)
;
rest
=
&
rest
[
2
.
.
]
;
}
else
{
try
!
(
f
.
write_str
(
"
.
"
)
)
;
rest
=
&
rest
[
1
.
.
]
;
}
}
else
if
rest
.
starts_with
(
'
'
)
{
macro_rules
!
demangle
{
(
(
pat
:
expr
=
>
demangled
:
expr
)
*
)
=
>
(
{
(
if
rest
.
starts_with
(
pat
)
{
try
!
(
f
.
write_str
(
demangled
)
)
;
rest
=
&
rest
[
pat
.
len
(
)
.
.
]
;
}
else
)
*
{
try
!
(
f
.
write_str
(
rest
)
)
;
break
;
}
}
)
}
demangle
!
{
"
SP
"
=
>
"
"
"
BP
"
=
>
"
*
"
"
RF
"
=
>
"
&
"
"
LT
"
=
>
"
<
"
"
GT
"
=
>
"
>
"
"
LP
"
=
>
"
(
"
"
RP
"
=
>
"
)
"
"
C
"
=
>
"
"
/
/
in
theory
we
can
demangle
any
Unicode
code
point
but
/
/
for
simplicity
we
just
catch
the
common
ones
.
"
u7e
"
=
>
"
~
"
"
u20
"
=
>
"
"
"
u27
"
=
>
"
'
"
"
u5b
"
=
>
"
[
"
"
u5d
"
=
>
"
]
"
"
u7b
"
=
>
"
{
"
"
u7d
"
=
>
"
}
"
"
u3b
"
=
>
"
;
"
"
u2b
"
=
>
"
+
"
"
u22
"
=
>
"
\
"
"
}
}
else
{
let
idx
=
match
rest
.
char_indices
(
)
.
find
(
|
&
(
_
c
)
|
c
=
=
'
'
|
|
c
=
=
'
.
'
)
{
None
=
>
rest
.
len
(
)
Some
(
(
i
_
)
)
=
>
i
}
;
try
!
(
f
.
write_str
(
&
rest
[
.
.
idx
]
)
)
;
rest
=
&
rest
[
idx
.
.
]
;
}
}
}
Ok
(
(
)
)
}
}
impl
<
'
a
>
fmt
:
:
Debug
for
Demangle
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
prelude
:
:
v1
:
:
*
;
macro_rules
!
t
{
(
a
:
expr
b
:
expr
)
=
>
(
{
assert_eq
!
(
super
:
:
demangle
(
a
)
.
to_string
(
)
b
)
;
}
)
}
macro_rules
!
t_nohash
{
(
a
:
expr
b
:
expr
)
=
>
(
{
assert_eq
!
(
format
!
(
"
{
:
#
}
"
super
:
:
demangle
(
a
)
)
b
)
;
}
)
}
#
[
test
]
fn
demangle
(
)
{
t
!
(
"
test
"
"
test
"
)
;
t
!
(
"
_ZN4testE
"
"
test
"
)
;
t
!
(
"
_ZN4test
"
"
_ZN4test
"
)
;
t
!
(
"
_ZN4test1a2bcE
"
"
test
:
:
a
:
:
bc
"
)
;
}
#
[
test
]
fn
demangle_dollars
(
)
{
t
!
(
"
_ZN4
RP
E
"
"
)
"
)
;
t
!
(
"
_ZN8
RF
testE
"
"
&
test
"
)
;
t
!
(
"
_ZN8
BP
test4foobE
"
"
*
test
:
:
foob
"
)
;
t
!
(
"
_ZN9
u20
test4foobE
"
"
test
:
:
foob
"
)
;
t
!
(
"
_ZN35Bar
LT
u5b
u32
u3b
u20
4
u5d
GT
E
"
"
Bar
<
[
u32
;
4
]
>
"
)
;
}
#
[
test
]
fn
demangle_many_dollars
(
)
{
t
!
(
"
_ZN13test
u20
test4foobE
"
"
test
test
:
:
foob
"
)
;
t
!
(
"
_ZN12test
BP
test4foobE
"
"
test
*
test
:
:
foob
"
)
;
}
#
[
test
]
fn
demangle_osx
(
)
{
t
!
(
"
__ZN5alloc9allocator6Layout9for_value17h02a996811f781011E
"
"
alloc
:
:
allocator
:
:
Layout
:
:
for_value
:
:
h02a996811f781011
"
)
;
t
!
(
"
__ZN38_
LT
core
.
.
option
.
.
Option
LT
T
GT
GT
6unwrap18_MSG_FILE_LINE_COL17haf7cb8d5824ee659E
"
"
<
core
:
:
option
:
:
Option
<
T
>
>
:
:
unwrap
:
:
_MSG_FILE_LINE_COL
:
:
haf7cb8d5824ee659
"
)
;
t
!
(
"
__ZN4core5slice89_
LT
impl
u20
core
.
.
iter
.
.
traits
.
.
IntoIterator
u20
for
u20
RF
u27
a
u20
u5b
T
u5d
GT
9into_iter17h450e234d27262170E
"
"
core
:
:
slice
:
:
<
impl
core
:
:
iter
:
:
traits
:
:
IntoIterator
for
&
'
a
[
T
]
>
:
:
into_iter
:
:
h450e234d27262170
"
)
;
}
#
[
test
]
fn
demangle_windows
(
)
{
t
!
(
"
ZN4testE
"
"
test
"
)
;
t
!
(
"
ZN13test
u20
test4foobE
"
"
test
test
:
:
foob
"
)
;
t
!
(
"
ZN12test
RF
test4foobE
"
"
test
&
test
:
:
foob
"
)
;
}
#
[
test
]
fn
demangle_elements_beginning_with_underscore
(
)
{
t
!
(
"
_ZN13_
LT
test
GT
E
"
"
<
test
>
"
)
;
t
!
(
"
_ZN28_
u7b
u7b
closure
u7d
u7d
E
"
"
{
{
closure
}
}
"
)
;
t
!
(
"
_ZN15__STATIC_FMTSTRE
"
"
__STATIC_FMTSTR
"
)
;
}
#
[
test
]
fn
demangle_trait_impls
(
)
{
t
!
(
"
_ZN71_
LT
Test
u20
u2b
u20
u27
static
u20
as
u20
foo
.
.
Bar
LT
Test
GT
GT
3barE
"
"
<
Test
+
'
static
as
foo
:
:
Bar
<
Test
>
>
:
:
bar
"
)
;
}
#
[
test
]
fn
demangle_without_hash
(
)
{
let
s
=
"
_ZN3foo17h05af221e174051e9E
"
;
t
!
(
s
"
foo
:
:
h05af221e174051e9
"
)
;
t_nohash
!
(
s
"
foo
"
)
;
}
#
[
test
]
fn
demangle_without_hash_edgecases
(
)
{
t_nohash
!
(
"
_ZN3fooE
"
"
foo
"
)
;
t_nohash
!
(
"
_ZN3foo3barE
"
"
foo
:
:
bar
"
)
;
t_nohash
!
(
"
_ZN3foo20h05af221e174051e9abcE
"
"
foo
"
)
;
t_nohash
!
(
"
_ZN3foo5h05afE
"
"
foo
"
)
;
t_nohash
!
(
"
_ZN17h05af221e174051e93fooE
"
"
h05af221e174051e9
:
:
foo
"
)
;
t_nohash
!
(
"
_ZN3foo16ffaf221e174051e9E
"
"
foo
:
:
ffaf221e174051e9
"
)
;
t_nohash
!
(
"
_ZN3foo17hg5af221e174051e9E
"
"
foo
:
:
hg5af221e174051e9
"
)
;
}
#
[
test
]
fn
demangle_thinlto
(
)
{
t
!
(
"
_ZN3fooE
.
llvm
.
9D1C9369
"
"
foo
"
)
;
t
!
(
"
_ZN3fooE
.
llvm
.
9D1C9369
16
"
"
foo
"
)
;
t_nohash
!
(
"
_ZN9backtrace3foo17hbb467fcdaea5d79bE
.
llvm
.
A5310EB9
"
"
backtrace
:
:
foo
"
)
;
}
#
[
test
]
fn
dont_panic
(
)
{
super
:
:
demangle
(
"
_ZN2222222222222222222222EE
"
)
.
to_string
(
)
;
super
:
:
demangle
(
"
_ZN5
*
70527e27
.
ll34csa
E
"
)
.
to_string
(
)
;
super
:
:
demangle
(
"
_ZN5
*
70527a54
.
ll34_
b
.
1E
"
)
.
to_string
(
)
;
super
:
:
demangle
(
"
\
_ZN5
~
sa
b4e
\
n
\
2734cOsbE
\
n
\
5usage20h
)
3
\
0
\
0
\
0
\
0
\
0
\
0
\
07e2734cOsbE
\
"
)
.
to_string
(
)
;
}
}
