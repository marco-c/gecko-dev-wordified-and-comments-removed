use
super
:
:
atanf
;
use
super
:
:
fabsf
;
const
PI
:
f32
=
3
.
1415927410e
+
00
;
const
PI_LO
:
f32
=
-
8
.
7422776573e
-
08
;
#
[
cfg_attr
(
all
(
test
assert_no_panic
)
no_panic
:
:
no_panic
)
]
pub
fn
atan2f
(
y
:
f32
x
:
f32
)
-
>
f32
{
if
x
.
is_nan
(
)
|
|
y
.
is_nan
(
)
{
return
x
+
y
;
}
let
mut
ix
=
x
.
to_bits
(
)
;
let
mut
iy
=
y
.
to_bits
(
)
;
if
ix
=
=
0x3f800000
{
return
atanf
(
y
)
;
}
let
m
=
(
(
iy
>
>
31
)
&
1
)
|
(
(
ix
>
>
30
)
&
2
)
;
ix
&
=
0x7fffffff
;
iy
&
=
0x7fffffff
;
if
iy
=
=
0
{
return
match
m
{
0
|
1
=
>
y
2
=
>
PI
3
|
_
=
>
-
PI
}
;
}
if
ix
=
=
0
{
return
if
m
&
1
!
=
0
{
-
PI
/
2
.
}
else
{
PI
/
2
.
}
;
}
if
ix
=
=
0x7f800000
{
return
if
iy
=
=
0x7f800000
{
match
m
{
0
=
>
PI
/
4
.
1
=
>
-
PI
/
4
.
2
=
>
3
.
*
PI
/
4
.
3
|
_
=
>
-
3
.
*
PI
/
4
.
}
}
else
{
match
m
{
0
=
>
0
.
1
=
>
-
0
.
2
=
>
PI
3
|
_
=
>
-
PI
}
}
;
}
if
(
ix
+
(
26
<
<
23
)
<
iy
)
|
|
(
iy
=
=
0x7f800000
)
{
return
if
m
&
1
!
=
0
{
-
PI
/
2
.
}
else
{
PI
/
2
.
}
;
}
let
z
=
if
(
m
&
2
!
=
0
)
&
&
(
iy
+
(
26
<
<
23
)
<
ix
)
{
0
.
}
else
{
atanf
(
fabsf
(
y
/
x
)
)
}
;
match
m
{
0
=
>
z
1
=
>
-
z
2
=
>
PI
-
(
z
-
PI_LO
)
_
=
>
(
z
-
PI_LO
)
-
PI
}
}
