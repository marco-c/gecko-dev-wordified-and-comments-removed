use
core
:
:
f64
;
const
O_THRESHOLD
:
f64
=
7
.
09782712893383973096e
+
02
;
const
LN2_HI
:
f64
=
6
.
93147180369123816490e
-
01
;
const
LN2_LO
:
f64
=
1
.
90821492927058770002e
-
10
;
const
INVLN2
:
f64
=
1
.
44269504088896338700e
+
00
;
const
Q1
:
f64
=
-
3
.
33333333333331316428e
-
02
;
const
Q2
:
f64
=
1
.
58730158725481460165e
-
03
;
const
Q3
:
f64
=
-
7
.
93650757867487942473e
-
05
;
const
Q4
:
f64
=
4
.
00821782732936239552e
-
06
;
const
Q5
:
f64
=
-
2
.
01099218183624371326e
-
07
;
#
[
cfg_attr
(
all
(
test
assert_no_panic
)
no_panic
:
:
no_panic
)
]
pub
fn
expm1
(
mut
x
:
f64
)
-
>
f64
{
let
hi
:
f64
;
let
lo
:
f64
;
let
k
:
i32
;
let
c
:
f64
;
let
mut
t
:
f64
;
let
mut
y
:
f64
;
let
mut
ui
=
x
.
to_bits
(
)
;
let
hx
=
(
(
ui
>
>
32
)
&
0x7fffffff
)
as
u32
;
let
sign
=
(
ui
>
>
63
)
as
i32
;
if
hx
>
=
0x4043687A
{
if
x
.
is_nan
(
)
{
return
x
;
}
if
sign
!
=
0
{
return
-
1
.
0
;
}
if
x
>
O_THRESHOLD
{
x
*
=
f64
:
:
from_bits
(
0x7fe0000000000000
)
;
return
x
;
}
}
if
hx
>
0x3fd62e42
{
if
hx
<
0x3FF0A2B2
{
if
sign
=
=
0
{
hi
=
x
-
LN2_HI
;
lo
=
LN2_LO
;
k
=
1
;
}
else
{
hi
=
x
+
LN2_HI
;
lo
=
-
LN2_LO
;
k
=
-
1
;
}
}
else
{
k
=
(
INVLN2
*
x
+
if
sign
!
=
0
{
-
0
.
5
}
else
{
0
.
5
}
)
as
i32
;
t
=
k
as
f64
;
hi
=
x
-
t
*
LN2_HI
;
lo
=
t
*
LN2_LO
;
}
x
=
hi
-
lo
;
c
=
(
hi
-
x
)
-
lo
;
}
else
if
hx
<
0x3c900000
{
if
hx
<
0x00100000
{
force_eval
!
(
x
)
;
}
return
x
;
}
else
{
c
=
0
.
0
;
k
=
0
;
}
let
hfx
=
0
.
5
*
x
;
let
hxs
=
x
*
hfx
;
let
r1
=
1
.
0
+
hxs
*
(
Q1
+
hxs
*
(
Q2
+
hxs
*
(
Q3
+
hxs
*
(
Q4
+
hxs
*
Q5
)
)
)
)
;
t
=
3
.
0
-
r1
*
hfx
;
let
mut
e
=
hxs
*
(
(
r1
-
t
)
/
(
6
.
0
-
x
*
t
)
)
;
if
k
=
=
0
{
return
x
-
(
x
*
e
-
hxs
)
;
}
e
=
x
*
(
e
-
c
)
-
c
;
e
-
=
hxs
;
if
k
=
=
-
1
{
return
0
.
5
*
(
x
-
e
)
-
0
.
5
;
}
if
k
=
=
1
{
if
x
<
-
0
.
25
{
return
-
2
.
0
*
(
e
-
(
x
+
0
.
5
)
)
;
}
return
1
.
0
+
2
.
0
*
(
x
-
e
)
;
}
ui
=
(
(
0x3ff
+
k
)
as
u64
)
<
<
52
;
let
twopk
=
f64
:
:
from_bits
(
ui
)
;
if
k
<
0
|
|
k
>
56
{
y
=
x
-
e
+
1
.
0
;
if
k
=
=
1024
{
y
=
y
*
2
.
0
*
f64
:
:
from_bits
(
0x7fe0000000000000
)
;
}
else
{
y
=
y
*
twopk
;
}
return
y
-
1
.
0
;
}
ui
=
(
(
0x3ff
-
k
)
as
u64
)
<
<
52
;
let
uf
=
f64
:
:
from_bits
(
ui
)
;
if
k
<
20
{
y
=
(
x
-
e
+
(
1
.
0
-
uf
)
)
*
twopk
;
}
else
{
y
=
(
x
-
(
e
+
uf
)
+
1
.
0
)
*
twopk
;
}
y
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
test
]
fn
sanity_check
(
)
{
assert_eq
!
(
super
:
:
expm1
(
1
.
1
)
2
.
0041660239464334
)
;
}
}
