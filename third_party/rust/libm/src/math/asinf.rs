use
super
:
:
fabsf
:
:
fabsf
;
use
super
:
:
sqrt
:
:
sqrt
;
const
PIO2
:
f64
=
1
.
570796326794896558e
+
00
;
const
P_S0
:
f32
=
1
.
6666586697e
-
01
;
const
P_S1
:
f32
=
-
4
.
2743422091e
-
02
;
const
P_S2
:
f32
=
-
8
.
6563630030e
-
03
;
const
Q_S1
:
f32
=
-
7
.
0662963390e
-
01
;
fn
r
(
z
:
f32
)
-
>
f32
{
let
p
=
z
*
(
P_S0
+
z
*
(
P_S1
+
z
*
P_S2
)
)
;
let
q
=
1
.
+
z
*
Q_S1
;
p
/
q
}
#
[
cfg_attr
(
all
(
test
assert_no_panic
)
no_panic
:
:
no_panic
)
]
pub
fn
asinf
(
mut
x
:
f32
)
-
>
f32
{
let
x1p_120
=
f64
:
:
from_bits
(
0x3870000000000000
)
;
let
hx
=
x
.
to_bits
(
)
;
let
ix
=
hx
&
0x7fffffff
;
if
ix
>
=
0x3f800000
{
if
ix
=
=
0x3f800000
{
return
(
(
x
as
f64
)
*
PIO2
+
x1p_120
)
as
f32
;
}
return
0
.
/
(
x
-
x
)
;
}
if
ix
<
0x3f000000
{
if
(
ix
<
0x39800000
)
&
&
(
ix
>
=
0x00800000
)
{
return
x
;
}
return
x
+
x
*
r
(
x
*
x
)
;
}
let
z
=
(
1
.
-
fabsf
(
x
)
)
*
0
.
5
;
let
s
=
sqrt
(
z
as
f64
)
;
x
=
(
PIO2
-
2
.
*
(
s
+
s
*
(
r
(
z
)
as
f64
)
)
)
as
f32
;
if
(
hx
>
>
31
)
!
=
0
{
-
x
}
else
{
x
}
}
