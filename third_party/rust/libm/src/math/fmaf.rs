use
core
:
:
f32
;
use
core
:
:
ptr
:
:
read_volatile
;
use
super
:
:
fenv
:
:
{
feclearexcept
fegetround
feraiseexcept
fetestexcept
FE_INEXACT
FE_TONEAREST
FE_UNDERFLOW
}
;
#
[
cfg_attr
(
all
(
test
assert_no_panic
)
no_panic
:
:
no_panic
)
]
pub
fn
fmaf
(
x
:
f32
y
:
f32
mut
z
:
f32
)
-
>
f32
{
let
xy
:
f64
;
let
mut
result
:
f64
;
let
mut
ui
:
u64
;
let
e
:
i32
;
xy
=
x
as
f64
*
y
as
f64
;
result
=
xy
+
z
as
f64
;
ui
=
result
.
to_bits
(
)
;
e
=
(
ui
>
>
52
)
as
i32
&
0x7ff
;
if
(
ui
&
0x1fffffff
)
!
=
0x10000000
|
|
e
=
=
0x7ff
|
|
(
result
-
xy
=
=
z
as
f64
&
&
result
-
z
as
f64
=
=
xy
)
|
|
fegetround
(
)
!
=
FE_TONEAREST
{
if
e
<
0x3ff
-
126
&
&
e
>
=
0x3ff
-
149
&
&
fetestexcept
(
FE_INEXACT
)
!
=
0
{
feclearexcept
(
FE_INEXACT
)
;
let
vz
:
f32
=
unsafe
{
read_volatile
(
&
z
)
}
;
result
=
xy
+
vz
as
f64
;
if
fetestexcept
(
FE_INEXACT
)
!
=
0
{
feraiseexcept
(
FE_UNDERFLOW
)
;
}
else
{
feraiseexcept
(
FE_INEXACT
)
;
}
}
z
=
result
as
f32
;
return
z
;
}
let
neg
=
ui
>
>
63
!
=
0
;
let
err
=
if
neg
=
=
(
z
as
f64
>
xy
)
{
xy
-
result
+
z
as
f64
}
else
{
z
as
f64
-
result
+
xy
}
;
if
neg
=
=
(
err
<
0
.
0
)
{
ui
+
=
1
;
}
else
{
ui
-
=
1
;
}
f64
:
:
from_bits
(
ui
)
as
f32
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
test
]
fn
issue_263
(
)
{
let
a
=
f32
:
:
from_bits
(
1266679807
)
;
let
b
=
f32
:
:
from_bits
(
1300234242
)
;
let
c
=
f32
:
:
from_bits
(
1115553792
)
;
let
expected
=
f32
:
:
from_bits
(
1501560833
)
;
assert_eq
!
(
super
:
:
fmaf
(
a
b
c
)
expected
)
;
}
}
