#
!
[
allow
(
clippy
:
:
unwrap_used
)
]
use
std
:
:
env
;
const
BINDINGS
:
&
str
=
"
bindings
.
rs
"
;
#
[
cfg
(
feature
=
"
gecko
"
)
]
fn
clang_args
(
)
-
>
Vec
<
String
>
{
use
mozbuild
:
:
TOPOBJDIR
;
let
flags_path
=
TOPOBJDIR
.
join
(
"
netwerk
/
socket
/
neqo
/
extra
-
bindgen
-
flags
"
)
;
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
{
}
"
flags_path
.
to_str
(
)
.
unwrap
(
)
)
;
let
mut
flags
:
Vec
<
String
>
=
std
:
:
fs
:
:
read_to_string
(
flags_path
)
.
expect
(
"
Failed
to
read
extra
-
bindgen
-
flags
file
"
)
.
split_whitespace
(
)
.
map
(
std
:
:
borrow
:
:
ToOwned
:
:
to_owned
)
.
collect
(
)
;
flags
.
push
(
String
:
:
from
(
"
-
include
"
)
)
;
flags
.
push
(
TOPOBJDIR
.
join
(
"
dist
"
)
.
join
(
"
include
"
)
.
join
(
"
mozilla
-
config
.
h
"
)
.
to_str
(
)
.
unwrap
(
)
.
to_string
(
)
)
;
flags
}
#
[
cfg
(
not
(
feature
=
"
gecko
"
)
)
]
const
fn
clang_args
(
)
-
>
Vec
<
String
>
{
Vec
:
:
new
(
)
}
fn
bindgen
(
)
{
let
target_os
=
env
:
:
var
(
"
CARGO_CFG_TARGET_OS
"
)
.
expect
(
"
CARGO_CFG_TARGET_OS
was
not
set
"
)
;
if
matches
!
(
target_os
.
as_str
(
)
"
ios
"
|
"
tvos
"
|
"
visionos
"
)
{
return
;
}
if
target_os
=
=
"
windows
"
{
return
;
}
let
bindings
=
if
matches
!
(
target_os
.
as_str
(
)
"
linux
"
|
"
android
"
)
{
bindgen
:
:
Builder
:
:
default
(
)
.
header_contents
(
"
rtnetlink
.
h
"
"
#
include
<
linux
/
rtnetlink
.
h
>
"
)
.
allowlist_type
(
"
rtattr
|
rtmsg
|
ifinfomsg
|
nlmsghdr
"
)
}
else
{
bindgen
:
:
Builder
:
:
default
(
)
.
header_contents
(
"
route
.
h
"
"
#
include
<
sys
/
types
.
h
>
\
n
#
include
<
sys
/
socket
.
h
>
\
n
#
include
<
net
/
route
.
h
>
\
n
#
include
<
net
/
if
.
h
>
"
)
.
allowlist_type
(
"
rt_msghdr
|
rt_metrics
|
if_data
"
)
.
allowlist_item
(
"
RTAX_MAX
|
RTM_GET
|
RTM_VERSION
|
RTA_DST
|
RTA_IFP
"
)
}
;
let
bindings
=
bindings
.
clang_args
(
clang_args
(
)
)
.
parse_callbacks
(
Box
:
:
new
(
bindgen
:
:
CargoCallbacks
:
:
new
(
)
)
)
.
generate_cstr
(
true
)
.
explicit_padding
(
true
)
.
derive_default
(
true
)
.
generate
(
)
.
expect
(
"
Unable
to
generate
bindings
"
)
;
let
out_path
=
std
:
:
path
:
:
PathBuf
:
:
from
(
env
:
:
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
)
.
join
(
BINDINGS
)
;
bindings
.
write_to_file
(
out_path
.
clone
(
)
)
.
expect
(
"
Couldn
'
t
write
bindings
!
"
)
;
println
!
(
"
cargo
:
rustc
-
env
=
BINDINGS
=
{
}
"
out_path
.
display
(
)
)
;
}
fn
main
(
)
{
cfg_aliases
:
:
cfg_aliases
!
{
bsd
:
{
any
(
target_os
=
"
freebsd
"
target_os
=
"
openbsd
"
target_os
=
"
netbsd
"
target_os
=
"
solaris
"
)
}
}
bindgen
(
)
;
}
