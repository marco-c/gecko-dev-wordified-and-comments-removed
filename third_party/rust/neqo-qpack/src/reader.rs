use
std
:
:
{
mem
str
}
;
use
neqo_common
:
:
{
qdebug
qerror
}
;
use
neqo_transport
:
:
{
Connection
StreamId
}
;
use
crate
:
:
{
huffman
prefix
:
:
Prefix
Error
Res
}
;
pub
trait
ReadByte
{
fn
read_byte
(
&
mut
self
)
-
>
Res
<
u8
>
;
}
pub
trait
Reader
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Res
<
usize
>
;
}
pub
(
crate
)
struct
ReceiverConnWrapper
<
'
a
>
{
conn
:
&
'
a
mut
Connection
stream_id
:
StreamId
}
impl
ReadByte
for
ReceiverConnWrapper
<
'
_
>
{
fn
read_byte
(
&
mut
self
)
-
>
Res
<
u8
>
{
let
mut
b
=
[
0
]
;
match
self
.
conn
.
stream_recv
(
self
.
stream_id
&
mut
b
)
?
{
(
_
true
)
=
>
Err
(
Error
:
:
ClosedCriticalStream
)
(
0
false
)
=
>
Err
(
Error
:
:
NeedMoreData
)
_
=
>
Ok
(
b
[
0
]
)
}
}
}
impl
Reader
for
ReceiverConnWrapper
<
'
_
>
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Res
<
usize
>
{
match
self
.
conn
.
stream_recv
(
self
.
stream_id
buf
)
?
{
(
_
true
)
=
>
Err
(
Error
:
:
ClosedCriticalStream
)
(
amount
false
)
=
>
Ok
(
amount
)
}
}
}
impl
<
'
a
>
ReceiverConnWrapper
<
'
a
>
{
pub
fn
new
(
conn
:
&
'
a
mut
Connection
stream_id
:
StreamId
)
-
>
Self
{
Self
{
conn
stream_id
}
}
}
pub
(
crate
)
struct
ReceiverBufferWrapper
<
'
a
>
{
buf
:
&
'
a
[
u8
]
offset
:
usize
}
impl
ReadByte
for
ReceiverBufferWrapper
<
'
_
>
{
fn
read_byte
(
&
mut
self
)
-
>
Res
<
u8
>
{
if
self
.
offset
=
=
self
.
buf
.
len
(
)
{
Err
(
Error
:
:
Decompression
)
}
else
{
let
b
=
self
.
buf
[
self
.
offset
]
;
self
.
offset
+
=
1
;
Ok
(
b
)
}
}
}
impl
<
'
a
>
ReceiverBufferWrapper
<
'
a
>
{
pub
const
fn
new
(
buf
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
{
buf
offset
:
0
}
}
pub
const
fn
peek
(
&
self
)
-
>
Res
<
u8
>
{
if
self
.
offset
=
=
self
.
buf
.
len
(
)
{
Err
(
Error
:
:
Decompression
)
}
else
{
Ok
(
self
.
buf
[
self
.
offset
]
)
}
}
pub
const
fn
done
(
&
self
)
-
>
bool
{
self
.
offset
=
=
self
.
buf
.
len
(
)
}
pub
fn
read_prefixed_int
(
&
mut
self
prefix_len
:
u8
)
-
>
Res
<
u64
>
{
debug_assert
!
(
prefix_len
<
8
)
;
let
first_byte
=
self
.
read_byte
(
)
?
;
let
mut
reader
=
IntReader
:
:
new
(
first_byte
prefix_len
)
;
reader
.
read
(
self
)
}
pub
fn
read_literal_from_buffer
(
&
mut
self
prefix_len
:
u8
)
-
>
Res
<
Vec
<
u8
>
>
{
debug_assert
!
(
prefix_len
<
7
)
;
let
first_byte
=
self
.
read_byte
(
)
?
;
let
use_huffman
=
(
first_byte
&
(
0x80
>
>
prefix_len
)
)
!
=
0
;
let
mut
int_reader
=
IntReader
:
:
new
(
first_byte
prefix_len
+
1
)
;
let
length
:
usize
=
int_reader
.
read
(
self
)
?
.
try_into
(
)
.
or
(
Err
(
Error
:
:
Decompression
)
)
?
;
if
use_huffman
{
huffman
:
:
decode
(
self
.
slice
(
length
)
?
)
}
else
{
Ok
(
self
.
slice
(
length
)
?
.
to_vec
(
)
)
}
}
fn
slice
(
&
mut
self
len
:
usize
)
-
>
Res
<
&
[
u8
]
>
{
if
self
.
offset
+
len
>
self
.
buf
.
len
(
)
{
Err
(
Error
:
:
Decompression
)
}
else
{
let
start
=
self
.
offset
;
self
.
offset
+
=
len
;
Ok
(
&
self
.
buf
[
start
.
.
self
.
offset
]
)
}
}
}
#
[
derive
(
Debug
)
]
#
[
expect
(
clippy
:
:
module_name_repetitions
reason
=
"
This
is
OK
.
"
)
]
pub
struct
IntReader
{
value
:
u64
cnt
:
u8
done
:
bool
}
impl
IntReader
{
#
[
must_use
]
pub
fn
new
(
first_byte
:
u8
prefix_len
:
u8
)
-
>
Self
{
debug_assert
!
(
prefix_len
<
8
"
prefix
cannot
larger
than
7
"
)
;
let
mask
=
if
prefix_len
=
=
0
{
0xff
}
else
{
(
1
<
<
(
8
-
prefix_len
)
)
-
1
}
;
let
value
=
u64
:
:
from
(
first_byte
&
mask
)
;
Self
{
value
cnt
:
0
done
:
value
<
u64
:
:
from
(
mask
)
}
}
#
[
must_use
]
pub
fn
make
(
first_byte
:
u8
prefixes
:
&
[
Prefix
]
)
-
>
Self
{
for
prefix
in
prefixes
{
if
prefix
.
cmp_prefix
(
first_byte
)
{
return
Self
:
:
new
(
first_byte
prefix
.
len
(
)
)
;
}
}
unreachable
!
(
)
;
}
pub
fn
read
<
R
:
ReadByte
>
(
&
mut
self
s
:
&
mut
R
)
-
>
Res
<
u64
>
{
let
mut
b
:
u8
;
while
!
self
.
done
{
b
=
s
.
read_byte
(
)
?
;
if
(
self
.
cnt
=
=
63
)
&
&
(
b
>
1
|
|
(
b
=
=
1
&
&
(
(
self
.
value
>
>
63
)
=
=
1
)
)
)
{
qerror
!
(
"
Error
decoding
prefixed
encoded
int
-
IntegerOverflow
"
)
;
return
Err
(
Error
:
:
IntegerOverflow
)
;
}
self
.
value
+
=
u64
:
:
from
(
b
&
0x7f
)
<
<
self
.
cnt
;
if
(
b
&
0x80
)
=
=
0
{
self
.
done
=
true
;
}
self
.
cnt
+
=
7
;
if
self
.
cnt
>
=
64
{
self
.
done
=
true
;
}
}
Ok
(
self
.
value
)
}
}
#
[
derive
(
Debug
Default
)
]
enum
LiteralReaderState
{
#
[
default
]
ReadHuffman
ReadLength
{
reader
:
IntReader
}
ReadLiteral
{
offset
:
usize
}
Done
}
#
[
derive
(
Debug
Default
)
]
#
[
expect
(
clippy
:
:
module_name_repetitions
reason
=
"
This
is
OK
.
"
)
]
pub
struct
LiteralReader
{
state
:
LiteralReaderState
literal
:
Vec
<
u8
>
use_huffman
:
bool
}
impl
LiteralReader
{
const
MAX_LEN
:
usize
=
384
*
1024
;
#
[
must_use
]
pub
fn
new_with_first_byte
(
first_byte
:
u8
prefix_len
:
u8
)
-
>
Self
{
assert
!
(
prefix_len
<
8
)
;
Self
{
state
:
LiteralReaderState
:
:
ReadLength
{
reader
:
IntReader
:
:
new
(
first_byte
prefix_len
+
1
)
}
literal
:
Vec
:
:
new
(
)
use_huffman
:
(
first_byte
&
(
0x80
>
>
prefix_len
)
)
!
=
0
}
}
pub
fn
read
<
T
:
ReadByte
+
Reader
>
(
&
mut
self
s
:
&
mut
T
)
-
>
Res
<
Vec
<
u8
>
>
{
loop
{
qdebug
!
(
"
state
=
{
:
?
}
"
self
.
state
)
;
match
&
mut
self
.
state
{
LiteralReaderState
:
:
ReadHuffman
=
>
{
let
b
=
s
.
read_byte
(
)
?
;
self
.
use_huffman
=
(
b
&
0x80
)
!
=
0
;
self
.
state
=
LiteralReaderState
:
:
ReadLength
{
reader
:
IntReader
:
:
new
(
b
1
)
}
;
}
LiteralReaderState
:
:
ReadLength
{
reader
}
=
>
{
let
v
=
usize
:
:
try_from
(
reader
.
read
(
s
)
?
)
.
ok
(
)
.
filter
(
|
&
l
|
l
<
=
Self
:
:
MAX_LEN
)
.
ok_or
(
Error
:
:
Decoding
)
?
;
self
.
literal
.
resize
(
v
0x0
)
;
self
.
state
=
LiteralReaderState
:
:
ReadLiteral
{
offset
:
0
}
;
}
LiteralReaderState
:
:
ReadLiteral
{
offset
}
=
>
{
let
amount
=
s
.
read
(
&
mut
self
.
literal
[
*
offset
.
.
]
)
?
;
*
offset
+
=
amount
;
if
*
offset
=
=
self
.
literal
.
len
(
)
{
self
.
state
=
LiteralReaderState
:
:
Done
;
if
self
.
use_huffman
{
break
Ok
(
huffman
:
:
decode
(
&
self
.
literal
)
?
)
;
}
break
Ok
(
mem
:
:
take
(
&
mut
self
.
literal
)
)
;
}
break
Err
(
Error
:
:
NeedMoreData
)
;
}
LiteralReaderState
:
:
Done
=
>
{
panic
!
(
"
Should
not
call
read
(
)
in
this
state
"
)
;
}
}
}
}
}
pub
fn
parse_utf8
(
v
:
&
[
u8
]
)
-
>
Res
<
&
str
>
{
str
:
:
from_utf8
(
v
)
.
map_err
(
|
_
|
Error
:
:
BadUtf8
)
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
pub
(
crate
)
mod
test_receiver
{
use
std
:
:
collections
:
:
VecDeque
;
use
super
:
:
{
Error
ReadByte
Reader
Res
}
;
#
[
derive
(
Default
)
]
pub
struct
TestReceiver
{
buf
:
VecDeque
<
u8
>
}
impl
ReadByte
for
TestReceiver
{
fn
read_byte
(
&
mut
self
)
-
>
Res
<
u8
>
{
self
.
buf
.
pop_back
(
)
.
ok_or
(
Error
:
:
NeedMoreData
)
}
}
impl
Reader
for
TestReceiver
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Res
<
usize
>
{
let
len
=
if
buf
.
len
(
)
>
self
.
buf
.
len
(
)
{
self
.
buf
.
len
(
)
}
else
{
buf
.
len
(
)
}
;
for
item
in
buf
.
iter_mut
(
)
.
take
(
len
)
{
*
item
=
self
.
buf
.
pop_back
(
)
.
ok_or
(
Error
:
:
NeedMoreData
)
?
;
}
Ok
(
len
)
}
}
impl
TestReceiver
{
pub
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
{
for
b
in
buf
{
self
.
buf
.
push_front
(
*
b
)
;
}
}
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
tests
{
use
neqo_common
:
:
Encoder
;
use
test_receiver
:
:
TestReceiver
;
use
super
:
:
{
huffman
test_receiver
Error
IntReader
LiteralReader
ReadByte
as
_
ReceiverBufferWrapper
Res
}
;
use
crate
:
:
{
prefix
:
:
Prefix
qpack_send_buf
:
:
Encoder
as
_
}
;
const
TEST_CASES_NUMBERS
:
[
(
&
[
u8
]
u8
u64
)
;
7
]
=
[
(
&
[
0xEA
]
3
10
)
(
&
[
0x0A
]
3
10
)
(
&
[
0x8A
]
3
10
)
(
&
[
0xFF
0x9A
0x0A
]
3
1337
)
(
&
[
0x1F
0x9A
0x0A
]
3
1337
)
(
&
[
0x9F
0x9A
0x0A
]
3
1337
)
(
&
[
0x2A
]
0
42
)
]
;
#
[
test
]
fn
read_prefixed_int
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_NUMBERS
{
let
mut
reader
=
IntReader
:
:
new
(
buf
[
0
]
*
prefix_len
)
;
let
mut
test_receiver
:
TestReceiver
=
TestReceiver
:
:
default
(
)
;
test_receiver
.
write
(
&
buf
[
1
.
.
]
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
Ok
(
*
value
)
)
;
}
}
#
[
test
]
fn
read_prefixed_int_with_more_data_in_buffer
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_NUMBERS
{
let
mut
reader
=
IntReader
:
:
new
(
buf
[
0
]
*
prefix_len
)
;
let
mut
test_receiver
:
TestReceiver
=
TestReceiver
:
:
default
(
)
;
test_receiver
.
write
(
&
buf
[
1
.
.
]
)
;
test_receiver
.
write
(
&
[
0x0
0x0
0x0
]
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
Ok
(
*
value
)
)
;
}
}
#
[
test
]
fn
read_prefixed_int_slow_writer
(
)
{
let
(
buf
prefix_len
value
)
=
&
TEST_CASES_NUMBERS
[
4
]
;
assert
!
(
buf
.
len
(
)
>
1
)
;
let
mut
reader
=
IntReader
:
:
new
(
buf
[
0
]
*
prefix_len
)
;
let
mut
test_receiver
:
TestReceiver
=
TestReceiver
:
:
default
(
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
Err
(
Error
:
:
NeedMoreData
)
)
;
test_receiver
.
write
(
&
buf
[
1
.
.
2
]
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
Err
(
Error
:
:
NeedMoreData
)
)
;
test_receiver
.
write
(
&
buf
[
2
.
.
]
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
Ok
(
*
value
)
)
;
}
type
TestSetup
=
(
&
'
static
[
u8
]
u8
Res
<
u64
>
)
;
const
TEST_CASES_BIG_NUMBERS
:
[
TestSetup
;
3
]
=
[
(
&
[
0xFF
0x80
0xFE
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x01
]
0
Ok
(
0xFFFF_FFFF_FFFF_FFFF
)
)
(
&
[
0xFF
0x81
0xFE
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x01
]
0
Err
(
Error
:
:
IntegerOverflow
)
)
(
&
[
0xFF
0x80
0xFE
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x02
]
0
Err
(
Error
:
:
IntegerOverflow
)
)
]
;
#
[
test
]
fn
read_prefixed_int_big_number
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_BIG_NUMBERS
{
let
mut
reader
=
IntReader
:
:
new
(
buf
[
0
]
*
prefix_len
)
;
let
mut
test_receiver
:
TestReceiver
=
TestReceiver
:
:
default
(
)
;
test_receiver
.
write
(
&
buf
[
1
.
.
]
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
*
value
)
;
}
}
const
TEST_CASES_LITERAL
:
[
(
&
[
u8
]
u8
&
[
u8
]
)
;
9
]
=
[
(
&
[
0x0a
0x63
0x75
0x73
0x74
0x6f
0x6d
0x2d
0x6b
0x65
0x79
]
1
b
"
custom
-
key
"
)
(
&
[
0x0a
0x63
0x75
0x73
0x74
0x6f
0x6d
0x2d
0x6b
0x65
0x79
]
3
b
"
custom
-
key
"
)
(
&
[
0xea
0x63
0x75
0x73
0x74
0x6f
0x6d
0x2d
0x6b
0x65
0x79
]
3
b
"
custom
-
key
"
)
(
&
[
0x0d
0x63
0x75
0x73
0x74
0x6f
0x6d
0x2d
0x68
0x65
0x61
0x64
0x65
0x72
]
1
b
"
custom
-
header
"
)
(
&
[
0x15
0xae
0xc3
0x77
0x1a
0x4b
]
3
b
"
private
"
)
(
&
[
0x56
0xd0
0x7a
0xbe
0x94
0x10
0x54
0xd4
0x44
0xa8
0x20
0x05
0x95
0x04
0x0b
0x81
0x66
0xe0
0x82
0xa6
0x2d
0x1b
0xff
]
1
b
"
Mon
21
Oct
2013
20
:
13
:
21
GMT
"
)
(
&
[
0xff
0x0f
0xd0
0x7a
0xbe
0x94
0x10
0x54
0xd4
0x44
0xa8
0x20
0x05
0x95
0x04
0x0b
0x81
0x66
0xe0
0x82
0xa6
0x2d
0x1b
0xff
]
4
b
"
Mon
21
Oct
2013
20
:
13
:
21
GMT
"
)
(
&
[
0x51
0x9d
0x29
0xad
0x17
0x18
0x63
0xc7
0x8f
0x0b
0x97
0xc8
0xe9
0xae
0x82
0xae
0x43
0xd3
]
1
b
"
https
:
/
/
www
.
example
.
com
"
)
(
&
[
0x91
0x9d
0x29
0xad
0x17
0x18
0x63
0xc7
0x8f
0x0b
0x97
0xc8
0xe9
0xae
0x82
0xae
0x43
0xd3
]
0
b
"
https
:
/
/
www
.
example
.
com
"
)
]
;
#
[
test
]
fn
read_literal
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_LITERAL
{
let
mut
reader
=
LiteralReader
:
:
new_with_first_byte
(
buf
[
0
]
*
prefix_len
)
;
let
mut
test_receiver
:
TestReceiver
=
TestReceiver
:
:
default
(
)
;
test_receiver
.
write
(
&
buf
[
1
.
.
]
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
.
unwrap
(
)
.
as_slice
(
)
*
value
)
;
}
}
#
[
test
]
fn
read_prefixed_int_receiver_buffer_wrapper
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_NUMBERS
{
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
buf
)
;
let
mut
reader
=
IntReader
:
:
new
(
buffer
.
read_byte
(
)
.
unwrap
(
)
*
prefix_len
)
;
assert_eq
!
(
reader
.
read
(
&
mut
buffer
)
Ok
(
*
value
)
)
;
}
}
#
[
test
]
fn
read_prefixed_int_big_receiver_buffer_wrapper
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_BIG_NUMBERS
{
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
buf
)
;
let
mut
reader
=
IntReader
:
:
new
(
buffer
.
read_byte
(
)
.
unwrap
(
)
*
prefix_len
)
;
assert_eq
!
(
reader
.
read
(
&
mut
buffer
)
*
value
)
;
}
}
#
[
test
]
fn
read_literal_receiver_buffer_wrapper
(
)
{
for
(
buf
prefix_len
value
)
in
&
TEST_CASES_LITERAL
{
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
buf
)
;
assert_eq
!
(
buffer
.
read_literal_from_buffer
(
*
prefix_len
)
.
unwrap
(
)
*
value
)
;
}
}
#
[
test
]
fn
read_failure_receiver_buffer_wrapper_number
(
)
{
let
(
buf
prefix_len
_
)
=
&
TEST_CASES_NUMBERS
[
4
]
;
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
&
buf
[
.
.
1
]
)
;
let
mut
reader
=
IntReader
:
:
new
(
buffer
.
read_byte
(
)
.
unwrap
(
)
*
prefix_len
)
;
assert_eq
!
(
reader
.
read
(
&
mut
buffer
)
Err
(
Error
:
:
Decompression
)
)
;
}
#
[
test
]
fn
read_failure_receiver_buffer_wrapper_literal
(
)
{
let
(
buf
prefix_len
_
)
=
&
TEST_CASES_LITERAL
[
0
]
;
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
&
buf
[
.
.
6
]
)
;
assert_eq
!
(
buffer
.
read_literal_from_buffer
(
*
prefix_len
)
Err
(
Error
:
:
Decompression
)
)
;
}
#
[
test
]
fn
read_non_utf8_huffman_literal
(
)
{
let
non_utf8_data
=
&
[
0xE4u8
]
;
let
encoded
=
huffman
:
:
encode
(
non_utf8_data
)
;
let
mut
buf
=
Vec
:
:
new
(
)
;
#
[
expect
(
clippy
:
:
cast_possible_truncation
reason
=
"
Test
data
is
small
"
)
]
let
len
=
encoded
.
len
(
)
as
u8
;
buf
.
push
(
0x10
|
len
)
;
buf
.
extend_from_slice
(
&
encoded
)
;
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
&
buf
)
;
let
result
=
buffer
.
read_literal_from_buffer
(
3
)
.
unwrap
(
)
;
assert_eq
!
(
result
non_utf8_data
)
;
}
#
[
test
]
fn
read_non_utf8_plain_literal
(
)
{
let
non_utf8_data
=
&
[
0xFFu8
0xFEu8
]
;
let
mut
buf
=
Vec
:
:
new
(
)
;
#
[
expect
(
clippy
:
:
cast_possible_truncation
reason
=
"
Test
data
is
small
"
)
]
let
len
=
non_utf8_data
.
len
(
)
as
u8
;
buf
.
push
(
len
)
;
buf
.
extend_from_slice
(
non_utf8_data
)
;
let
mut
buffer
=
ReceiverBufferWrapper
:
:
new
(
&
buf
)
;
let
result
=
buffer
.
read_literal_from_buffer
(
3
)
.
unwrap
(
)
;
assert_eq
!
(
result
non_utf8_data
)
;
}
fn
literal_reader_for_test
(
literal_len
:
usize
)
-
>
(
LiteralReader
TestReceiver
)
{
const
PREFIX_LEN
:
u8
=
3
;
let
mut
data
=
Encoder
:
:
default
(
)
;
data
.
encode_literal
(
false
Prefix
:
:
new
(
0x00
PREFIX_LEN
)
&
vec
!
[
b
'
a
'
;
literal_len
]
)
;
let
reader
=
LiteralReader
:
:
new_with_first_byte
(
data
.
as_ref
(
)
[
0
]
PREFIX_LEN
)
;
let
mut
test_receiver
=
TestReceiver
:
:
default
(
)
;
test_receiver
.
write
(
&
data
.
as_ref
(
)
[
1
.
.
]
)
;
(
reader
test_receiver
)
}
#
[
test
]
fn
literal_exceeding_max_len_rejected
(
)
{
let
(
mut
reader
mut
test_receiver
)
=
literal_reader_for_test
(
LiteralReader
:
:
MAX_LEN
+
1
)
;
assert_eq
!
(
reader
.
read
(
&
mut
test_receiver
)
Err
(
Error
:
:
Decoding
)
)
;
}
#
[
test
]
fn
literal_at_max_len_accepted
(
)
{
let
(
mut
reader
mut
test_receiver
)
=
literal_reader_for_test
(
LiteralReader
:
:
MAX_LEN
)
;
let
result
=
reader
.
read
(
&
mut
test_receiver
)
.
unwrap
(
)
;
assert_eq
!
(
result
.
len
(
)
LiteralReader
:
:
MAX_LEN
)
;
}
}
