typedef
unsigned
char
uint8_t
;
typedef
unsigned
short
uint16_t
;
typedef
unsigned
int
uint32_t
;
typedef
unsigned
long
long
uint64_t
;
#
define
ETH_MQ_RX_RSS_FLAG
0x1
#
define
ETH_MQ_RX_DCB_FLAG
0x2
#
define
ETH_MQ_RX_VMDQ_FLAG
0x4
#
define
ETH_VMDQ_MAX_VLAN_FILTERS
64
/
*
*
<
Maximum
nb
.
of
VMDQ
vlan
filters
.
*
/
#
define
ETH_DCB_NUM_USER_PRIORITIES
8
/
*
*
<
Maximum
nb
.
of
DCB
priorities
.
*
/
#
define
ETH_VMDQ_DCB_NUM_QUEUES
128
/
*
*
<
Maximum
nb
.
of
VMDQ
DCB
queues
.
*
/
#
define
ETH_DCB_NUM_QUEUES
128
/
*
*
<
Maximum
nb
.
of
DCB
queues
.
*
/
enum
rte_eth_rx_mq_mode
{
ETH_MQ_RX_NONE
=
0
ETH_MQ_RX_RSS
=
ETH_MQ_RX_RSS_FLAG
ETH_MQ_RX_DCB
=
ETH_MQ_RX_DCB_FLAG
ETH_MQ_RX_DCB_RSS
=
ETH_MQ_RX_RSS_FLAG
|
ETH_MQ_RX_DCB_FLAG
ETH_MQ_RX_VMDQ_ONLY
=
ETH_MQ_RX_VMDQ_FLAG
ETH_MQ_RX_VMDQ_RSS
=
ETH_MQ_RX_RSS_FLAG
|
ETH_MQ_RX_VMDQ_FLAG
ETH_MQ_RX_VMDQ_DCB
=
ETH_MQ_RX_VMDQ_FLAG
|
ETH_MQ_RX_DCB_FLAG
ETH_MQ_RX_VMDQ_DCB_RSS
=
ETH_MQ_RX_RSS_FLAG
|
ETH_MQ_RX_DCB_FLAG
|
ETH_MQ_RX_VMDQ_FLAG
}
;
struct
rte_eth_rxmode
{
enum
rte_eth_rx_mq_mode
mq_mode
;
uint32_t
max_rx_pkt_len
;
uint16_t
split_hdr_size
;
__extension__
uint16_t
header_split
:
1
hw_ip_checksum
:
1
hw_vlan_filter
:
1
hw_vlan_strip
:
1
hw_vlan_extend
:
1
jumbo_frame
:
1
hw_strip_crc
:
1
enable_scatter
:
1
enable_lro
:
1
;
}
;
enum
rte_eth_tx_mq_mode
{
ETH_MQ_TX_NONE
=
0
ETH_MQ_TX_DCB
ETH_MQ_TX_VMDQ_DCB
ETH_MQ_TX_VMDQ_ONLY
}
;
struct
rte_eth_txmode
{
enum
rte_eth_tx_mq_mode
mq_mode
;
uint16_t
pvid
;
__extension__
uint8_t
hw_vlan_reject_tagged
:
1
hw_vlan_reject_untagged
:
1
hw_vlan_insert_pvid
:
1
;
}
;
struct
rte_eth_rss_conf
{
uint8_t
*
rss_key
;
uint8_t
rss_key_len
;
uint64_t
rss_hf
;
}
;
enum
rte_eth_nb_tcs
{
ETH_4_TCS
=
4
ETH_8_TCS
=
8
}
;
enum
rte_eth_nb_pools
{
ETH_8_POOLS
=
8
ETH_16_POOLS
=
16
ETH_32_POOLS
=
32
ETH_64_POOLS
=
64
}
;
struct
rte_eth_vmdq_dcb_conf
{
enum
rte_eth_nb_pools
nb_queue_pools
;
uint8_t
enable_default_pool
;
uint8_t
default_pool
;
uint8_t
nb_pool_maps
;
struct
{
uint16_t
vlan_id
;
uint64_t
pools
;
}
pool_map
[
ETH_VMDQ_MAX_VLAN_FILTERS
]
;
uint8_t
dcb_tc
[
ETH_DCB_NUM_USER_PRIORITIES
]
;
}
;
struct
rte_eth_dcb_rx_conf
{
enum
rte_eth_nb_tcs
nb_tcs
;
uint8_t
dcb_tc
[
ETH_DCB_NUM_USER_PRIORITIES
]
;
}
;
struct
rte_eth_vmdq_dcb_tx_conf
{
enum
rte_eth_nb_pools
nb_queue_pools
;
uint8_t
dcb_tc
[
ETH_DCB_NUM_USER_PRIORITIES
]
;
}
;
struct
rte_eth_dcb_tx_conf
{
enum
rte_eth_nb_tcs
nb_tcs
;
uint8_t
dcb_tc
[
ETH_DCB_NUM_USER_PRIORITIES
]
;
}
;
struct
rte_eth_vmdq_tx_conf
{
enum
rte_eth_nb_pools
nb_queue_pools
;
}
;
struct
rte_eth_vmdq_rx_conf
{
enum
rte_eth_nb_pools
nb_queue_pools
;
uint8_t
enable_default_pool
;
uint8_t
default_pool
;
uint8_t
enable_loop_back
;
uint8_t
nb_pool_maps
;
uint32_t
rx_mode
;
struct
{
uint16_t
vlan_id
;
uint64_t
pools
;
}
pool_map
[
ETH_VMDQ_MAX_VLAN_FILTERS
]
;
}
;
enum
rte_fdir_mode
{
RTE_FDIR_MODE_NONE
=
0
RTE_FDIR_MODE_SIGNATURE
RTE_FDIR_MODE_PERFECT
RTE_FDIR_MODE_PERFECT_MAC_VLAN
RTE_FDIR_MODE_PERFECT_TUNNEL
}
;
enum
rte_fdir_pballoc_type
{
RTE_FDIR_PBALLOC_64K
=
0
RTE_FDIR_PBALLOC_128K
RTE_FDIR_PBALLOC_256K
}
;
enum
rte_fdir_status_mode
{
RTE_FDIR_NO_REPORT_STATUS
=
0
RTE_FDIR_REPORT_STATUS
RTE_FDIR_REPORT_STATUS_ALWAYS
}
;
struct
rte_eth_ipv4_flow
{
uint32_t
src_ip
;
uint32_t
dst_ip
;
uint8_t
tos
;
uint8_t
ttl
;
uint8_t
proto
;
}
;
struct
rte_eth_ipv6_flow
{
uint32_t
src_ip
[
4
]
;
uint32_t
dst_ip
[
4
]
;
uint8_t
tc
;
uint8_t
proto
;
uint8_t
hop_limits
;
}
;
struct
rte_eth_fdir_masks
{
uint16_t
vlan_tci_mask
;
struct
rte_eth_ipv4_flow
ipv4_mask
;
struct
rte_eth_ipv6_flow
ipv6_mask
;
uint16_t
src_port_mask
;
uint16_t
dst_port_mask
;
uint8_t
mac_addr_byte_mask
;
uint32_t
tunnel_id_mask
;
uint8_t
tunnel_type_mask
;
}
;
enum
rte_eth_payload_type
{
RTE_ETH_PAYLOAD_UNKNOWN
=
0
RTE_ETH_RAW_PAYLOAD
RTE_ETH_L2_PAYLOAD
RTE_ETH_L3_PAYLOAD
RTE_ETH_L4_PAYLOAD
RTE_ETH_PAYLOAD_MAX
=
8
}
;
#
define
RTE_ETH_FDIR_MAX_FLEXLEN
16
/
*
*
<
Max
length
of
flexbytes
.
*
/
#
define
RTE_ETH_INSET_SIZE_MAX
128
/
*
*
<
Max
length
of
input
set
.
*
/
struct
rte_eth_flex_payload_cfg
{
enum
rte_eth_payload_type
type
;
uint16_t
src_offset
[
RTE_ETH_FDIR_MAX_FLEXLEN
]
;
}
;
struct
rte_eth_fdir_flex_mask
{
uint16_t
flow_type
;
uint8_t
mask
[
RTE_ETH_FDIR_MAX_FLEXLEN
]
;
}
;
#
define
RTE_ETH_FLOW_UNKNOWN
0
#
define
RTE_ETH_FLOW_RAW
1
#
define
RTE_ETH_FLOW_IPV4
2
#
define
RTE_ETH_FLOW_FRAG_IPV4
3
#
define
RTE_ETH_FLOW_NONFRAG_IPV4_TCP
4
#
define
RTE_ETH_FLOW_NONFRAG_IPV4_UDP
5
#
define
RTE_ETH_FLOW_NONFRAG_IPV4_SCTP
6
#
define
RTE_ETH_FLOW_NONFRAG_IPV4_OTHER
7
#
define
RTE_ETH_FLOW_IPV6
8
#
define
RTE_ETH_FLOW_FRAG_IPV6
9
#
define
RTE_ETH_FLOW_NONFRAG_IPV6_TCP
10
#
define
RTE_ETH_FLOW_NONFRAG_IPV6_UDP
11
#
define
RTE_ETH_FLOW_NONFRAG_IPV6_SCTP
12
#
define
RTE_ETH_FLOW_NONFRAG_IPV6_OTHER
13
#
define
RTE_ETH_FLOW_L2_PAYLOAD
14
#
define
RTE_ETH_FLOW_IPV6_EX
15
#
define
RTE_ETH_FLOW_IPV6_TCP_EX
16
#
define
RTE_ETH_FLOW_IPV6_UDP_EX
17
#
define
RTE_ETH_FLOW_PORT
18
#
define
RTE_ETH_FLOW_VXLAN
19
/
*
*
<
VXLAN
protocol
based
flow
*
/
#
define
RTE_ETH_FLOW_GENEVE
20
/
*
*
<
GENEVE
protocol
based
flow
*
/
#
define
RTE_ETH_FLOW_NVGRE
21
/
*
*
<
NVGRE
protocol
based
flow
*
/
#
define
RTE_ETH_FLOW_MAX
22
struct
rte_eth_fdir_flex_conf
{
uint16_t
nb_payloads
;
uint16_t
nb_flexmasks
;
struct
rte_eth_flex_payload_cfg
flex_set
[
RTE_ETH_PAYLOAD_MAX
]
;
struct
rte_eth_fdir_flex_mask
flex_mask
[
RTE_ETH_FLOW_MAX
]
;
}
;
struct
rte_fdir_conf
{
enum
rte_fdir_mode
mode
;
enum
rte_fdir_pballoc_type
pballoc
;
enum
rte_fdir_status_mode
status
;
uint8_t
drop_queue
;
struct
rte_eth_fdir_masks
mask
;
struct
rte_eth_fdir_flex_conf
flex_conf
;
}
;
struct
rte_intr_conf
{
uint16_t
lsc
;
uint16_t
rxq
;
}
;
struct
rte_eth_conf
{
uint32_t
link_speeds
;
struct
rte_eth_rxmode
rxmode
;
struct
rte_eth_txmode
txmode
;
uint32_t
lpbk_mode
;
struct
{
struct
rte_eth_rss_conf
rss_conf
;
struct
rte_eth_vmdq_dcb_conf
vmdq_dcb_conf
;
struct
rte_eth_dcb_rx_conf
dcb_rx_conf
;
struct
rte_eth_vmdq_rx_conf
vmdq_rx_conf
;
}
rx_adv_conf
;
union
{
struct
rte_eth_vmdq_dcb_tx_conf
vmdq_dcb_tx_conf
;
struct
rte_eth_dcb_tx_conf
dcb_tx_conf
;
struct
rte_eth_vmdq_tx_conf
vmdq_tx_conf
;
}
tx_adv_conf
;
uint32_t
dcb_capability_en
;
struct
rte_fdir_conf
fdir_conf
;
struct
rte_intr_conf
intr_conf
;
}
;
