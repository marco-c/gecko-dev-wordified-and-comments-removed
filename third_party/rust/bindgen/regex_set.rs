use
regex
:
:
RegexSet
as
RxSet
;
use
std
:
:
cell
:
:
Cell
;
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
RegexSet
{
items
:
Vec
<
String
>
matched
:
Vec
<
Cell
<
bool
>
>
set
:
Option
<
RxSet
>
record_matches
:
bool
}
impl
RegexSet
{
pub
fn
new
(
)
-
>
RegexSet
{
RegexSet
{
.
.
Default
:
:
default
(
)
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
items
.
is_empty
(
)
}
pub
fn
insert
<
S
>
(
&
mut
self
string
:
S
)
where
S
:
AsRef
<
str
>
{
let
string
=
string
.
as_ref
(
)
.
to_owned
(
)
;
if
string
=
=
"
*
"
{
warn
!
(
"
using
wildcard
patterns
(
*
)
is
no
longer
considered
valid
.
Use
.
*
instead
"
)
;
}
self
.
items
.
push
(
string
)
;
self
.
matched
.
push
(
Cell
:
:
new
(
false
)
)
;
self
.
set
=
None
;
}
pub
fn
get_items
(
&
self
)
-
>
&
[
String
]
{
&
self
.
items
[
.
.
]
}
pub
fn
unmatched_items
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
String
>
{
self
.
items
.
iter
(
)
.
enumerate
(
)
.
filter_map
(
move
|
(
i
item
)
|
{
if
!
self
.
record_matches
|
|
self
.
matched
[
i
]
.
get
(
)
{
return
None
;
}
Some
(
item
)
}
)
}
pub
fn
build
(
&
mut
self
record_matches
:
bool
)
{
let
items
=
self
.
items
.
iter
(
)
.
map
(
|
item
|
format
!
(
"
^
(
{
}
)
"
item
)
)
;
self
.
record_matches
=
record_matches
;
self
.
set
=
match
RxSet
:
:
new
(
items
)
{
Ok
(
x
)
=
>
Some
(
x
)
Err
(
e
)
=
>
{
warn
!
(
"
Invalid
regex
in
{
:
?
}
:
{
:
?
}
"
self
.
items
e
)
;
None
}
}
}
pub
fn
matches
<
S
>
(
&
self
string
:
S
)
-
>
bool
where
S
:
AsRef
<
str
>
{
let
s
=
string
.
as_ref
(
)
;
let
set
=
match
self
.
set
{
Some
(
ref
set
)
=
>
set
None
=
>
return
false
}
;
if
!
self
.
record_matches
{
return
set
.
is_match
(
s
)
;
}
let
matches
=
set
.
matches
(
s
)
;
if
!
matches
.
matched_any
(
)
{
return
false
;
}
for
i
in
matches
.
iter
(
)
{
self
.
matched
[
i
]
.
set
(
true
)
;
}
true
}
}
