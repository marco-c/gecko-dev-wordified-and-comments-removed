use
clang
;
use
ir
:
:
context
:
:
{
BindgenContext
ItemId
}
;
use
ir
:
:
ty
:
:
TypeKind
;
#
[
derive
(
Debug
)
]
pub
enum
ParseError
{
Recurse
Continue
}
#
[
derive
(
Debug
)
]
pub
enum
ParseResult
<
T
>
{
AlreadyResolved
(
ItemId
)
New
(
T
Option
<
clang
:
:
Cursor
>
)
}
pub
trait
ClangSubItemParser
:
Sized
{
fn
parse
(
cursor
:
clang
:
:
Cursor
context
:
&
mut
BindgenContext
)
-
>
Result
<
ParseResult
<
Self
>
ParseError
>
;
}
pub
trait
ClangItemParser
:
Sized
{
fn
parse
(
cursor
:
clang
:
:
Cursor
parent
:
Option
<
ItemId
>
context
:
&
mut
BindgenContext
)
-
>
Result
<
ItemId
ParseError
>
;
fn
from_ty
(
ty
:
&
clang
:
:
Type
location
:
clang
:
:
Cursor
parent
:
Option
<
ItemId
>
ctx
:
&
mut
BindgenContext
)
-
>
Result
<
ItemId
ParseError
>
;
fn
from_ty_with_id
(
id
:
ItemId
ty
:
&
clang
:
:
Type
location
:
clang
:
:
Cursor
parent
:
Option
<
ItemId
>
ctx
:
&
mut
BindgenContext
)
-
>
Result
<
ItemId
ParseError
>
;
fn
from_ty_or_ref
(
ty
:
clang
:
:
Type
location
:
clang
:
:
Cursor
parent_id
:
Option
<
ItemId
>
context
:
&
mut
BindgenContext
)
-
>
ItemId
;
fn
from_ty_or_ref_with_id
(
potential_id
:
ItemId
ty
:
clang
:
:
Type
location
:
clang
:
:
Cursor
parent_id
:
Option
<
ItemId
>
context
:
&
mut
BindgenContext
)
-
>
ItemId
;
fn
named_type
(
with_id
:
Option
<
ItemId
>
location
:
clang
:
:
Cursor
ctx
:
&
mut
BindgenContext
)
-
>
Option
<
ItemId
>
;
fn
builtin_type
(
kind
:
TypeKind
is_const
:
bool
context
:
&
mut
BindgenContext
)
-
>
ItemId
;
}
