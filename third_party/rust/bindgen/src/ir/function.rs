use
super
:
:
comp
:
:
MethodKind
;
use
super
:
:
context
:
:
{
BindgenContext
TypeId
}
;
use
super
:
:
dot
:
:
DotAttributes
;
use
super
:
:
item
:
:
Item
;
use
super
:
:
traversal
:
:
{
EdgeKind
Trace
Tracer
}
;
use
super
:
:
ty
:
:
TypeKind
;
use
clang
;
use
clang_sys
:
:
{
self
CXCallingConv
}
;
use
parse
:
:
{
ClangItemParser
ClangSubItemParser
ParseError
ParseResult
}
;
use
proc_macro2
;
use
quote
;
use
quote
:
:
TokenStreamExt
;
use
std
:
:
io
;
const
RUST_DERIVE_FUNPTR_LIMIT
:
usize
=
12
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
FunctionKind
{
Function
Method
(
MethodKind
)
}
impl
FunctionKind
{
fn
from_cursor
(
cursor
:
&
clang
:
:
Cursor
)
-
>
Option
<
FunctionKind
>
{
Some
(
match
cursor
.
kind
(
)
{
clang_sys
:
:
CXCursor_FunctionDecl
=
>
FunctionKind
:
:
Function
clang_sys
:
:
CXCursor_Constructor
=
>
{
FunctionKind
:
:
Method
(
MethodKind
:
:
Constructor
)
}
clang_sys
:
:
CXCursor_Destructor
=
>
{
FunctionKind
:
:
Method
(
if
cursor
.
method_is_virtual
(
)
{
MethodKind
:
:
VirtualDestructor
{
pure_virtual
:
cursor
.
method_is_pure_virtual
(
)
}
}
else
{
MethodKind
:
:
Destructor
}
)
}
clang_sys
:
:
CXCursor_CXXMethod
=
>
{
if
cursor
.
method_is_virtual
(
)
{
FunctionKind
:
:
Method
(
MethodKind
:
:
Virtual
{
pure_virtual
:
cursor
.
method_is_pure_virtual
(
)
}
)
}
else
if
cursor
.
method_is_static
(
)
{
FunctionKind
:
:
Method
(
MethodKind
:
:
Static
)
}
else
{
FunctionKind
:
:
Method
(
MethodKind
:
:
Normal
)
}
}
_
=
>
return
None
}
)
}
}
#
[
derive
(
Debug
Clone
Copy
)
]
pub
enum
Linkage
{
External
Internal
}
#
[
derive
(
Debug
)
]
pub
struct
Function
{
name
:
String
mangled_name
:
Option
<
String
>
signature
:
TypeId
comment
:
Option
<
String
>
kind
:
FunctionKind
linkage
:
Linkage
}
impl
Function
{
pub
fn
new
(
name
:
String
mangled_name
:
Option
<
String
>
signature
:
TypeId
comment
:
Option
<
String
>
kind
:
FunctionKind
linkage
:
Linkage
)
-
>
Self
{
Function
{
name
mangled_name
signature
comment
kind
linkage
}
}
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
mangled_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
mangled_name
.
as_ref
(
)
.
map
(
|
n
|
&
*
*
n
)
}
pub
fn
signature
(
&
self
)
-
>
TypeId
{
self
.
signature
}
pub
fn
kind
(
&
self
)
-
>
FunctionKind
{
self
.
kind
}
pub
fn
linkage
(
&
self
)
-
>
Linkage
{
self
.
linkage
}
}
impl
DotAttributes
for
Function
{
fn
dot_attributes
<
W
>
(
&
self
_ctx
:
&
BindgenContext
out
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
if
let
Some
(
ref
mangled
)
=
self
.
mangled_name
{
let
mangled
:
String
=
mangled
.
chars
(
)
.
flat_map
(
|
c
|
c
.
escape_default
(
)
)
.
collect
(
)
;
writeln
!
(
out
"
<
tr
>
<
td
>
mangled
name
<
/
td
>
<
td
>
{
}
<
/
td
>
<
/
tr
>
"
mangled
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
Abi
{
C
Stdcall
Fastcall
ThisCall
Aapcs
Win64
Unknown
(
CXCallingConv
)
}
impl
Abi
{
fn
is_unknown
(
&
self
)
-
>
bool
{
match
*
self
{
Abi
:
:
Unknown
(
.
.
)
=
>
true
_
=
>
false
}
}
}
impl
quote
:
:
ToTokens
for
Abi
{
fn
to_tokens
(
&
self
tokens
:
&
mut
proc_macro2
:
:
TokenStream
)
{
tokens
.
append_all
(
match
*
self
{
Abi
:
:
C
=
>
quote
!
{
"
C
"
}
Abi
:
:
Stdcall
=
>
quote
!
{
"
stdcall
"
}
Abi
:
:
Fastcall
=
>
quote
!
{
"
fastcall
"
}
Abi
:
:
ThisCall
=
>
quote
!
{
"
thiscall
"
}
Abi
:
:
Aapcs
=
>
quote
!
{
"
aapcs
"
}
Abi
:
:
Win64
=
>
quote
!
{
"
win64
"
}
Abi
:
:
Unknown
(
cc
)
=
>
panic
!
(
"
Cannot
turn
unknown
calling
convention
to
tokens
:
{
:
?
}
"
cc
)
}
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
FunctionSig
{
return_type
:
TypeId
argument_types
:
Vec
<
(
Option
<
String
>
TypeId
)
>
is_variadic
:
bool
must_use
:
bool
abi
:
Abi
}
fn
get_abi
(
cc
:
CXCallingConv
)
-
>
Abi
{
use
clang_sys
:
:
*
;
match
cc
{
CXCallingConv_Default
=
>
Abi
:
:
C
CXCallingConv_C
=
>
Abi
:
:
C
CXCallingConv_X86StdCall
=
>
Abi
:
:
Stdcall
CXCallingConv_X86FastCall
=
>
Abi
:
:
Fastcall
CXCallingConv_X86ThisCall
=
>
Abi
:
:
ThisCall
CXCallingConv_AAPCS
=
>
Abi
:
:
Aapcs
CXCallingConv_X86_64Win64
=
>
Abi
:
:
Win64
other
=
>
Abi
:
:
Unknown
(
other
)
}
}
pub
fn
cursor_mangling
(
ctx
:
&
BindgenContext
cursor
:
&
clang
:
:
Cursor
)
-
>
Option
<
String
>
{
if
!
ctx
.
options
(
)
.
enable_mangling
{
return
None
;
}
if
cursor
.
is_in_non_fully_specialized_template
(
)
{
return
None
;
}
let
is_destructor
=
cursor
.
kind
(
)
=
=
clang_sys
:
:
CXCursor_Destructor
;
if
let
Ok
(
mut
manglings
)
=
cursor
.
cxx_manglings
(
)
{
while
let
Some
(
m
)
=
manglings
.
pop
(
)
{
if
is_destructor
&
&
!
m
.
ends_with
(
"
D1Ev
"
)
{
continue
;
}
return
Some
(
m
)
;
}
}
let
mut
mangling
=
cursor
.
mangling
(
)
;
if
mangling
.
is_empty
(
)
{
return
None
;
}
if
is_destructor
{
if
mangling
.
ends_with
(
"
D0Ev
"
)
{
let
new_len
=
mangling
.
len
(
)
-
4
;
mangling
.
truncate
(
new_len
)
;
mangling
.
push_str
(
"
D1Ev
"
)
;
}
}
Some
(
mangling
)
}
fn
args_from_ty_and_cursor
(
ty
:
&
clang
:
:
Type
cursor
:
&
clang
:
:
Cursor
ctx
:
&
mut
BindgenContext
)
-
>
Vec
<
(
Option
<
String
>
TypeId
)
>
{
let
cursor_args
=
cursor
.
args
(
)
.
unwrap
(
)
.
into_iter
(
)
;
let
type_args
=
ty
.
args
(
)
.
unwrap_or_default
(
)
.
into_iter
(
)
;
cursor_args
.
map
(
Some
)
.
chain
(
std
:
:
iter
:
:
repeat
(
None
)
)
.
zip
(
type_args
.
map
(
Some
)
.
chain
(
std
:
:
iter
:
:
repeat
(
None
)
)
)
.
take_while
(
|
(
cur
ty
)
|
cur
.
is_some
(
)
|
|
ty
.
is_some
(
)
)
.
map
(
|
(
arg_cur
arg_ty
)
|
{
let
name
=
arg_cur
.
map
(
|
a
|
a
.
spelling
(
)
)
.
and_then
(
|
name
|
{
if
name
.
is_empty
(
)
{
None
}
else
{
Some
(
name
)
}
}
)
;
let
cursor
=
arg_cur
.
unwrap_or
(
*
cursor
)
;
let
ty
=
arg_ty
.
unwrap_or
(
cursor
.
cur_type
(
)
)
;
(
name
Item
:
:
from_ty_or_ref
(
ty
cursor
None
ctx
)
)
}
)
.
collect
(
)
}
impl
FunctionSig
{
pub
fn
new
(
return_type
:
TypeId
argument_types
:
Vec
<
(
Option
<
String
>
TypeId
)
>
is_variadic
:
bool
must_use
:
bool
abi
:
Abi
)
-
>
Self
{
FunctionSig
{
return_type
argument_types
is_variadic
must_use
abi
:
abi
}
}
pub
fn
from_ty
(
ty
:
&
clang
:
:
Type
cursor
:
&
clang
:
:
Cursor
ctx
:
&
mut
BindgenContext
)
-
>
Result
<
Self
ParseError
>
{
use
clang_sys
:
:
*
;
debug
!
(
"
FunctionSig
:
:
from_ty
{
:
?
}
{
:
?
}
"
ty
cursor
)
;
let
kind
=
cursor
.
kind
(
)
;
if
kind
=
=
CXCursor_FunctionTemplate
{
return
Err
(
ParseError
:
:
Continue
)
;
}
let
spelling
=
cursor
.
spelling
(
)
;
if
spelling
.
starts_with
(
"
operator
"
)
{
return
Err
(
ParseError
:
:
Continue
)
;
}
if
(
kind
=
=
CXCursor_Constructor
|
|
kind
=
=
CXCursor_Destructor
)
&
&
spelling
.
contains
(
'
<
'
)
{
return
Err
(
ParseError
:
:
Continue
)
;
}
let
cursor
=
if
cursor
.
is_valid
(
)
{
*
cursor
}
else
{
ty
.
declaration
(
)
}
;
let
mut
args
=
match
kind
{
CXCursor_FunctionDecl
|
CXCursor_Constructor
|
CXCursor_CXXMethod
|
CXCursor_ObjCInstanceMethodDecl
|
CXCursor_ObjCClassMethodDecl
=
>
{
args_from_ty_and_cursor
(
&
ty
&
cursor
ctx
)
}
_
=
>
{
let
mut
args
=
vec
!
[
]
;
cursor
.
visit
(
|
c
|
{
if
c
.
kind
(
)
=
=
CXCursor_ParmDecl
{
let
ty
=
Item
:
:
from_ty_or_ref
(
c
.
cur_type
(
)
c
None
ctx
)
;
let
name
=
c
.
spelling
(
)
;
let
name
=
if
name
.
is_empty
(
)
{
None
}
else
{
Some
(
name
)
}
;
args
.
push
(
(
name
ty
)
)
;
}
CXChildVisit_Continue
}
)
;
args
}
}
;
let
must_use
=
ctx
.
options
(
)
.
enable_function_attribute_detection
&
&
cursor
.
has_warn_unused_result_attr
(
)
;
let
is_method
=
kind
=
=
CXCursor_CXXMethod
;
let
is_constructor
=
kind
=
=
CXCursor_Constructor
;
let
is_destructor
=
kind
=
=
CXCursor_Destructor
;
if
(
is_constructor
|
|
is_destructor
|
|
is_method
)
&
&
cursor
.
lexical_parent
(
)
!
=
cursor
.
semantic_parent
(
)
{
return
Err
(
ParseError
:
:
Continue
)
;
}
if
is_method
|
|
is_constructor
|
|
is_destructor
{
let
is_const
=
is_method
&
&
cursor
.
method_is_const
(
)
;
let
is_virtual
=
is_method
&
&
cursor
.
method_is_virtual
(
)
;
let
is_static
=
is_method
&
&
cursor
.
method_is_static
(
)
;
if
!
is_static
&
&
!
is_virtual
{
let
parent
=
cursor
.
semantic_parent
(
)
;
let
class
=
Item
:
:
parse
(
parent
None
ctx
)
.
expect
(
"
Expected
to
parse
the
class
"
)
;
let
class
=
class
.
as_type_id_unchecked
(
)
;
let
class
=
if
is_const
{
let
const_class_id
=
ctx
.
next_item_id
(
)
;
ctx
.
build_const_wrapper
(
const_class_id
class
None
&
parent
.
cur_type
(
)
)
}
else
{
class
}
;
let
ptr
=
Item
:
:
builtin_type
(
TypeKind
:
:
Pointer
(
class
)
false
ctx
)
;
args
.
insert
(
0
(
Some
(
"
this
"
.
into
(
)
)
ptr
)
)
;
}
else
if
is_virtual
{
let
void
=
Item
:
:
builtin_type
(
TypeKind
:
:
Void
false
ctx
)
;
let
ptr
=
Item
:
:
builtin_type
(
TypeKind
:
:
Pointer
(
void
)
false
ctx
)
;
args
.
insert
(
0
(
Some
(
"
this
"
.
into
(
)
)
ptr
)
)
;
}
}
let
ty_ret_type
=
if
kind
=
=
CXCursor_ObjCInstanceMethodDecl
|
|
kind
=
=
CXCursor_ObjCClassMethodDecl
{
ty
.
ret_type
(
)
.
or_else
(
|
|
cursor
.
ret_type
(
)
)
.
ok_or
(
ParseError
:
:
Continue
)
?
}
else
{
ty
.
ret_type
(
)
.
ok_or
(
ParseError
:
:
Continue
)
?
}
;
let
ret
=
Item
:
:
from_ty_or_ref
(
ty_ret_type
cursor
None
ctx
)
;
let
mut
call_conv
=
ty
.
call_conv
(
)
;
if
let
Some
(
ty
)
=
cursor
.
cur_type
(
)
.
canonical_type
(
)
.
pointee_type
(
)
{
let
cursor_call_conv
=
ty
.
call_conv
(
)
;
if
cursor_call_conv
!
=
CXCallingConv_Invalid
{
call_conv
=
cursor_call_conv
;
}
}
let
abi
=
get_abi
(
call_conv
)
;
if
abi
.
is_unknown
(
)
{
warn
!
(
"
Unknown
calling
convention
:
{
:
?
}
"
call_conv
)
;
}
Ok
(
Self
:
:
new
(
ret
.
into
(
)
args
ty
.
is_variadic
(
)
must_use
abi
)
)
}
pub
fn
return_type
(
&
self
)
-
>
TypeId
{
self
.
return_type
}
pub
fn
argument_types
(
&
self
)
-
>
&
[
(
Option
<
String
>
TypeId
)
]
{
&
self
.
argument_types
}
pub
fn
abi
(
&
self
)
-
>
Abi
{
self
.
abi
}
pub
fn
is_variadic
(
&
self
)
-
>
bool
{
self
.
is_variadic
&
&
!
self
.
argument_types
.
is_empty
(
)
}
pub
fn
must_use
(
&
self
)
-
>
bool
{
self
.
must_use
}
pub
fn
function_pointers_can_derive
(
&
self
)
-
>
bool
{
if
self
.
argument_types
.
len
(
)
>
RUST_DERIVE_FUNPTR_LIMIT
{
return
false
;
}
match
self
.
abi
{
Abi
:
:
C
|
Abi
:
:
Unknown
(
.
.
)
=
>
true
_
=
>
false
}
}
}
impl
ClangSubItemParser
for
Function
{
fn
parse
(
cursor
:
clang
:
:
Cursor
context
:
&
mut
BindgenContext
)
-
>
Result
<
ParseResult
<
Self
>
ParseError
>
{
use
clang_sys
:
:
*
;
let
kind
=
match
FunctionKind
:
:
from_cursor
(
&
cursor
)
{
None
=
>
return
Err
(
ParseError
:
:
Continue
)
Some
(
k
)
=
>
k
}
;
debug
!
(
"
Function
:
:
parse
(
{
:
?
}
{
:
?
}
)
"
cursor
cursor
.
cur_type
(
)
)
;
let
visibility
=
cursor
.
visibility
(
)
;
if
visibility
!
=
CXVisibility_Default
{
return
Err
(
ParseError
:
:
Continue
)
;
}
if
cursor
.
access_specifier
(
)
=
=
CX_CXXPrivate
{
return
Err
(
ParseError
:
:
Continue
)
;
}
if
!
context
.
options
(
)
.
generate_inline_functions
&
&
cursor
.
is_inlined_function
(
)
{
return
Err
(
ParseError
:
:
Continue
)
;
}
let
linkage
=
cursor
.
linkage
(
)
;
let
linkage
=
match
linkage
{
CXLinkage_External
|
CXLinkage_UniqueExternal
=
>
Linkage
:
:
External
CXLinkage_Internal
=
>
Linkage
:
:
Internal
_
=
>
return
Err
(
ParseError
:
:
Continue
)
}
;
let
sig
=
Item
:
:
from_ty
(
&
cursor
.
cur_type
(
)
cursor
None
context
)
?
;
let
mut
name
=
cursor
.
spelling
(
)
;
assert
!
(
!
name
.
is_empty
(
)
"
Empty
function
name
?
"
)
;
if
cursor
.
kind
(
)
=
=
CXCursor_Destructor
{
if
name
.
starts_with
(
'
~
'
)
{
name
.
remove
(
0
)
;
}
name
.
push_str
(
"
_destructor
"
)
;
}
let
mangled_name
=
cursor_mangling
(
context
&
cursor
)
;
let
comment
=
cursor
.
raw_comment
(
)
;
let
function
=
Self
:
:
new
(
name
mangled_name
sig
comment
kind
linkage
)
;
Ok
(
ParseResult
:
:
New
(
function
Some
(
cursor
)
)
)
}
}
impl
Trace
for
FunctionSig
{
type
Extra
=
(
)
;
fn
trace
<
T
>
(
&
self
_
:
&
BindgenContext
tracer
:
&
mut
T
_
:
&
(
)
)
where
T
:
Tracer
{
tracer
.
visit_kind
(
self
.
return_type
(
)
.
into
(
)
EdgeKind
:
:
FunctionReturn
)
;
for
&
(
_
ty
)
in
self
.
argument_types
(
)
{
tracer
.
visit_kind
(
ty
.
into
(
)
EdgeKind
:
:
FunctionParameter
)
;
}
}
}
