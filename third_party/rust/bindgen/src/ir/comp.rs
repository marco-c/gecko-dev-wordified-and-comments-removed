use
super
:
:
annotations
:
:
Annotations
;
use
super
:
:
context
:
:
{
BindgenContext
ItemId
}
;
use
super
:
:
derive
:
:
{
CanDeriveCopy
CanDeriveDebug
CanDeriveDefault
}
;
use
super
:
:
item
:
:
Item
;
use
super
:
:
layout
:
:
Layout
;
use
super
:
:
traversal
:
:
{
EdgeKind
Trace
Tracer
}
;
use
super
:
:
ty
:
:
{
TemplateDeclaration
Type
}
;
use
clang
;
use
parse
:
:
{
ClangItemParser
ParseError
}
;
use
std
:
:
cell
:
:
Cell
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompKind
{
Struct
Union
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
MethodKind
{
Constructor
Static
Normal
Virtual
}
#
[
derive
(
Debug
)
]
pub
struct
Method
{
kind
:
MethodKind
signature
:
ItemId
is_const
:
bool
}
impl
Method
{
pub
fn
new
(
kind
:
MethodKind
signature
:
ItemId
is_const
:
bool
)
-
>
Self
{
Method
{
kind
:
kind
signature
:
signature
is_const
:
is_const
}
}
pub
fn
kind
(
&
self
)
-
>
MethodKind
{
self
.
kind
}
pub
fn
is_constructor
(
&
self
)
-
>
bool
{
self
.
kind
=
=
MethodKind
:
:
Constructor
}
pub
fn
is_virtual
(
&
self
)
-
>
bool
{
self
.
kind
=
=
MethodKind
:
:
Virtual
}
pub
fn
is_static
(
&
self
)
-
>
bool
{
self
.
kind
=
=
MethodKind
:
:
Static
}
pub
fn
signature
(
&
self
)
-
>
ItemId
{
self
.
signature
}
pub
fn
is_const
(
&
self
)
-
>
bool
{
self
.
is_const
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Field
{
name
:
Option
<
String
>
ty
:
ItemId
comment
:
Option
<
String
>
annotations
:
Annotations
bitfield
:
Option
<
u32
>
mutable
:
bool
offset
:
Option
<
usize
>
}
impl
Field
{
pub
fn
new
(
name
:
Option
<
String
>
ty
:
ItemId
comment
:
Option
<
String
>
annotations
:
Option
<
Annotations
>
bitfield
:
Option
<
u32
>
mutable
:
bool
offset
:
Option
<
usize
>
)
-
>
Field
{
Field
{
name
:
name
ty
:
ty
comment
:
comment
annotations
:
annotations
.
unwrap_or_default
(
)
bitfield
:
bitfield
mutable
:
mutable
offset
:
offset
}
}
pub
fn
name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
name
.
as_ref
(
)
.
map
(
|
n
|
&
*
*
n
)
}
pub
fn
ty
(
&
self
)
-
>
ItemId
{
self
.
ty
}
pub
fn
comment
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
comment
.
as_ref
(
)
.
map
(
|
c
|
&
*
*
c
)
}
pub
fn
bitfield
(
&
self
)
-
>
Option
<
u32
>
{
self
.
bitfield
}
pub
fn
is_mutable
(
&
self
)
-
>
bool
{
self
.
mutable
}
pub
fn
annotations
(
&
self
)
-
>
&
Annotations
{
&
self
.
annotations
}
pub
fn
offset
(
&
self
)
-
>
Option
<
usize
>
{
self
.
offset
}
}
impl
CanDeriveDebug
for
Field
{
type
Extra
=
(
)
;
fn
can_derive_debug
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
ty
.
can_derive_debug
(
ctx
(
)
)
}
}
impl
CanDeriveDefault
for
Field
{
type
Extra
=
(
)
;
fn
can_derive_default
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
ty
.
can_derive_default
(
ctx
(
)
)
}
}
impl
<
'
a
>
CanDeriveCopy
<
'
a
>
for
Field
{
type
Extra
=
(
)
;
fn
can_derive_copy
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
ty
.
can_derive_copy
(
ctx
(
)
)
}
fn
can_derive_copy_in_array
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
ty
.
can_derive_copy_in_array
(
ctx
(
)
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
BaseKind
{
Normal
Virtual
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Base
{
pub
ty
:
ItemId
pub
kind
:
BaseKind
}
impl
Base
{
pub
fn
is_virtual
(
&
self
)
-
>
bool
{
self
.
kind
=
=
BaseKind
:
:
Virtual
}
}
#
[
derive
(
Debug
)
]
pub
struct
CompInfo
{
kind
:
CompKind
fields
:
Vec
<
Field
>
template_args
:
Vec
<
ItemId
>
methods
:
Vec
<
Method
>
constructors
:
Vec
<
ItemId
>
base_members
:
Vec
<
Base
>
ref_template
:
Option
<
ItemId
>
inner_types
:
Vec
<
ItemId
>
inner_vars
:
Vec
<
ItemId
>
has_vtable
:
bool
has_destructor
:
bool
has_nonempty_base
:
bool
has_non_type_template_params
:
bool
packed
:
bool
found_unknown_attr
:
bool
detect_derive_debug_cycle
:
Cell
<
bool
>
detect_derive_default_cycle
:
Cell
<
bool
>
detect_has_destructor_cycle
:
Cell
<
bool
>
is_forward_declaration
:
bool
}
impl
CompInfo
{
pub
fn
new
(
kind
:
CompKind
)
-
>
Self
{
CompInfo
{
kind
:
kind
fields
:
vec
!
[
]
template_args
:
vec
!
[
]
methods
:
vec
!
[
]
constructors
:
vec
!
[
]
base_members
:
vec
!
[
]
ref_template
:
None
inner_types
:
vec
!
[
]
inner_vars
:
vec
!
[
]
has_vtable
:
false
has_destructor
:
false
has_nonempty_base
:
false
has_non_type_template_params
:
false
packed
:
false
found_unknown_attr
:
false
detect_derive_debug_cycle
:
Cell
:
:
new
(
false
)
detect_derive_default_cycle
:
Cell
:
:
new
(
false
)
detect_has_destructor_cycle
:
Cell
:
:
new
(
false
)
is_forward_declaration
:
false
}
}
pub
fn
is_unsized
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
!
self
.
has_vtable
(
ctx
)
&
&
self
.
fields
.
is_empty
(
)
&
&
self
.
base_members
.
iter
(
)
.
all
(
|
base
|
{
ctx
.
resolve_type
(
base
.
ty
)
.
canonical_type
(
ctx
)
.
is_unsized
(
ctx
)
}
)
&
&
self
.
ref_template
.
map_or
(
true
|
template
|
ctx
.
resolve_type
(
template
)
.
is_unsized
(
ctx
)
)
}
pub
fn
has_destructor
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
if
self
.
detect_has_destructor_cycle
.
get
(
)
{
warn
!
(
"
Cycle
detected
looking
for
destructors
"
)
;
return
false
;
}
self
.
detect_has_destructor_cycle
.
set
(
true
)
;
let
has_destructor
=
self
.
has_destructor
|
|
match
self
.
kind
{
CompKind
:
:
Union
=
>
false
CompKind
:
:
Struct
=
>
{
self
.
ref_template
.
as_ref
(
)
.
map_or
(
false
|
t
|
{
ctx
.
resolve_type
(
*
t
)
.
has_destructor
(
ctx
)
}
)
|
|
self
.
template_args
.
iter
(
)
.
any
(
|
t
|
{
ctx
.
resolve_type
(
*
t
)
.
has_destructor
(
ctx
)
}
)
|
|
self
.
base_members
.
iter
(
)
.
any
(
|
base
|
{
ctx
.
resolve_type
(
base
.
ty
)
.
has_destructor
(
ctx
)
}
)
|
|
self
.
fields
.
iter
(
)
.
any
(
|
field
|
{
ctx
.
resolve_type
(
field
.
ty
)
.
has_destructor
(
ctx
)
}
)
}
}
;
self
.
detect_has_destructor_cycle
.
set
(
false
)
;
has_destructor
}
pub
fn
is_template_specialization
(
&
self
)
-
>
bool
{
self
.
ref_template
.
is_some
(
)
}
pub
fn
specialized_template
(
&
self
)
-
>
Option
<
ItemId
>
{
self
.
ref_template
}
pub
fn
layout
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Layout
>
{
use
std
:
:
cmp
;
if
self
.
kind
=
=
CompKind
:
:
Struct
{
return
None
}
let
mut
max_size
=
0
;
let
mut
max_align
=
0
;
for
field
in
&
self
.
fields
{
let
field_layout
=
ctx
.
resolve_type
(
field
.
ty
)
.
layout
(
ctx
)
;
if
let
Some
(
layout
)
=
field_layout
{
max_size
=
cmp
:
:
max
(
max_size
layout
.
size
)
;
max_align
=
cmp
:
:
max
(
max_align
layout
.
align
)
;
}
}
Some
(
Layout
:
:
new
(
max_size
max_align
)
)
}
pub
fn
fields
(
&
self
)
-
>
&
[
Field
]
{
&
self
.
fields
}
pub
fn
template_args
(
&
self
)
-
>
&
[
ItemId
]
{
&
self
.
template_args
}
pub
fn
has_non_type_template_params
(
&
self
)
-
>
bool
{
self
.
has_non_type_template_params
}
pub
fn
has_vtable
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
self
.
has_vtable
|
|
self
.
base_members
(
)
.
iter
(
)
.
any
(
|
base
|
{
ctx
.
resolve_type
(
base
.
ty
)
.
has_vtable
(
ctx
)
}
)
|
|
self
.
ref_template
.
map_or
(
false
|
template
|
{
ctx
.
resolve_type
(
template
)
.
has_vtable
(
ctx
)
}
)
}
pub
fn
methods
(
&
self
)
-
>
&
[
Method
]
{
&
self
.
methods
}
pub
fn
constructors
(
&
self
)
-
>
&
[
ItemId
]
{
&
self
.
constructors
}
pub
fn
kind
(
&
self
)
-
>
CompKind
{
self
.
kind
}
pub
fn
base_members
(
&
self
)
-
>
&
[
Base
]
{
&
self
.
base_members
}
pub
fn
from_ty
(
potential_id
:
ItemId
ty
:
&
clang
:
:
Type
location
:
Option
<
clang
:
:
Cursor
>
ctx
:
&
mut
BindgenContext
)
-
>
Result
<
Self
ParseError
>
{
use
clang_sys
:
:
*
;
let
mut
cursor
=
ty
.
declaration
(
)
;
let
mut
kind
=
Self
:
:
kind_from_cursor
(
&
cursor
)
;
if
kind
.
is_err
(
)
{
if
let
Some
(
location
)
=
location
{
kind
=
Self
:
:
kind_from_cursor
(
&
location
)
;
cursor
=
location
;
}
}
let
kind
=
try
!
(
kind
)
;
debug
!
(
"
CompInfo
:
:
from_ty
(
{
:
?
}
{
:
?
}
)
"
kind
cursor
)
;
let
mut
ci
=
CompInfo
:
:
new
(
kind
)
;
ci
.
is_forward_declaration
=
location
.
map_or
(
true
|
cur
|
match
cur
.
kind
(
)
{
CXCursor_StructDecl
|
CXCursor_UnionDecl
|
CXCursor_ClassDecl
=
>
!
cur
.
is_definition
(
)
_
=
>
false
}
)
;
ci
.
template_args
=
match
ty
.
template_args
(
)
{
None
=
>
vec
!
[
]
Some
(
arg_types
)
=
>
{
let
num_arg_types
=
arg_types
.
len
(
)
;
let
mut
specialization
=
true
;
let
args
=
arg_types
.
filter
(
|
t
|
t
.
kind
(
)
!
=
CXType_Invalid
)
.
filter_map
(
|
t
|
if
t
.
spelling
(
)
.
starts_with
(
"
type
-
parameter
"
)
{
specialization
=
false
;
None
}
else
{
Some
(
Item
:
:
from_ty_or_ref
(
t
None
None
ctx
)
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
if
specialization
&
&
args
.
len
(
)
!
=
num_arg_types
{
ci
.
has_non_type_template_params
=
true
;
warn
!
(
"
warning
:
Template
parameter
is
not
a
type
"
)
;
}
if
specialization
{
args
}
else
{
vec
!
[
]
}
}
}
;
ci
.
ref_template
=
cursor
.
specialized
(
)
.
and_then
(
|
c
|
Item
:
:
parse
(
c
None
ctx
)
.
ok
(
)
)
;
let
mut
maybe_anonymous_struct_field
=
None
;
cursor
.
visit
(
|
cur
|
{
if
cur
.
kind
(
)
!
=
CXCursor_FieldDecl
{
if
let
Some
(
(
ty
_
offset
)
)
=
maybe_anonymous_struct_field
.
take
(
)
{
let
field
=
Field
:
:
new
(
None
ty
None
None
None
false
offset
)
;
ci
.
fields
.
push
(
field
)
;
}
}
match
cur
.
kind
(
)
{
CXCursor_FieldDecl
=
>
{
if
let
Some
(
(
ty
clang_ty
offset
)
)
=
maybe_anonymous_struct_field
.
take
(
)
{
let
mut
used
=
false
;
cur
.
visit
(
|
child
|
{
if
child
.
cur_type
(
)
=
=
clang_ty
{
used
=
true
;
}
CXChildVisit_Continue
}
)
;
if
!
used
{
let
field
=
Field
:
:
new
(
None
ty
None
None
None
false
offset
)
;
ci
.
fields
.
push
(
field
)
;
}
}
let
bit_width
=
cur
.
bit_width
(
)
;
let
field_type
=
Item
:
:
from_ty_or_ref
(
cur
.
cur_type
(
)
Some
(
cur
)
Some
(
potential_id
)
ctx
)
;
let
comment
=
cur
.
raw_comment
(
)
;
let
annotations
=
Annotations
:
:
new
(
&
cur
)
;
let
name
=
cur
.
spelling
(
)
;
let
is_mutable
=
cursor
.
is_mutable_field
(
)
;
let
offset
=
cur
.
offset_of_field
(
)
.
ok
(
)
;
assert
!
(
!
name
.
is_empty
(
)
|
|
bit_width
.
is_some
(
)
"
Empty
field
name
?
"
)
;
let
name
=
if
name
.
is_empty
(
)
{
None
}
else
{
Some
(
name
)
}
;
let
field
=
Field
:
:
new
(
name
field_type
comment
annotations
bit_width
is_mutable
offset
)
;
ci
.
fields
.
push
(
field
)
;
cur
.
visit
(
|
cur
|
{
if
cur
.
kind
(
)
=
=
CXCursor_UnexposedAttr
{
ci
.
found_unknown_attr
=
true
;
}
CXChildVisit_Continue
}
)
;
}
CXCursor_UnexposedAttr
=
>
{
ci
.
found_unknown_attr
=
true
;
}
CXCursor_EnumDecl
|
CXCursor_TypeAliasDecl
|
CXCursor_TypedefDecl
|
CXCursor_StructDecl
|
CXCursor_UnionDecl
|
CXCursor_ClassTemplate
|
CXCursor_ClassDecl
=
>
{
if
cur
.
semantic_parent
(
)
!
=
cursor
{
return
CXChildVisit_Continue
;
}
let
inner
=
Item
:
:
parse
(
cur
Some
(
potential_id
)
ctx
)
.
expect
(
"
Inner
ClassDecl
"
)
;
ci
.
inner_types
.
push
(
inner
)
;
if
cur
.
spelling
(
)
.
is_empty
(
)
&
&
cur
.
kind
(
)
!
=
CXCursor_EnumDecl
{
let
ty
=
cur
.
cur_type
(
)
;
let
offset
=
cur
.
offset_of_field
(
)
.
ok
(
)
;
maybe_anonymous_struct_field
=
Some
(
(
inner
ty
offset
)
)
;
}
}
CXCursor_PackedAttr
=
>
{
ci
.
packed
=
true
;
}
CXCursor_TemplateTypeParameter
=
>
{
if
cur
.
spelling
(
)
.
is_empty
(
)
{
return
CXChildVisit_Continue
;
}
let
param
=
Item
:
:
named_type
(
cur
.
spelling
(
)
potential_id
ctx
)
;
ci
.
template_args
.
push
(
param
)
;
}
CXCursor_CXXBaseSpecifier
=
>
{
let
is_virtual_base
=
cur
.
is_virtual_base
(
)
;
ci
.
has_vtable
|
=
is_virtual_base
;
let
kind
=
if
is_virtual_base
{
BaseKind
:
:
Virtual
}
else
{
BaseKind
:
:
Normal
}
;
let
type_id
=
Item
:
:
from_ty_or_ref
(
cur
.
cur_type
(
)
Some
(
cur
)
None
ctx
)
;
ci
.
base_members
.
push
(
Base
{
ty
:
type_id
kind
:
kind
}
)
;
}
CXCursor_Constructor
|
CXCursor_Destructor
|
CXCursor_CXXMethod
=
>
{
let
is_virtual
=
cur
.
method_is_virtual
(
)
;
let
is_static
=
cur
.
method_is_static
(
)
;
debug_assert
!
(
!
(
is_static
&
&
is_virtual
)
"
How
?
"
)
;
ci
.
has_destructor
|
=
cur
.
kind
(
)
=
=
CXCursor_Destructor
;
ci
.
has_vtable
|
=
is_virtual
;
if
!
ci
.
template_args
.
is_empty
(
)
{
return
CXChildVisit_Continue
;
}
let
signature
=
match
Item
:
:
parse
(
cur
Some
(
potential_id
)
ctx
)
{
Ok
(
item
)
if
ctx
.
resolve_item
(
item
)
.
kind
(
)
.
is_function
(
)
=
>
item
_
=
>
return
CXChildVisit_Continue
}
;
match
cur
.
kind
(
)
{
CXCursor_Constructor
=
>
{
ci
.
constructors
.
push
(
signature
)
;
}
CXCursor_Destructor
=
>
{
}
CXCursor_CXXMethod
=
>
{
let
is_const
=
cur
.
method_is_const
(
)
;
let
method_kind
=
if
is_static
{
MethodKind
:
:
Static
}
else
if
is_virtual
{
MethodKind
:
:
Virtual
}
else
{
MethodKind
:
:
Normal
}
;
let
method
=
Method
:
:
new
(
method_kind
signature
is_const
)
;
ci
.
methods
.
push
(
method
)
;
}
_
=
>
unreachable
!
(
"
How
can
we
see
this
here
?
"
)
}
}
CXCursor_NonTypeTemplateParameter
=
>
{
ci
.
has_non_type_template_params
=
true
;
}
CXCursor_VarDecl
=
>
{
let
linkage
=
cur
.
linkage
(
)
;
if
linkage
!
=
CXLinkage_External
&
&
linkage
!
=
CXLinkage_UniqueExternal
{
return
CXChildVisit_Continue
;
}
let
visibility
=
cur
.
visibility
(
)
;
if
visibility
!
=
CXVisibility_Default
{
return
CXChildVisit_Continue
;
}
if
let
Ok
(
item
)
=
Item
:
:
parse
(
cur
Some
(
potential_id
)
ctx
)
{
ci
.
inner_vars
.
push
(
item
)
;
}
}
CXCursor_CXXAccessSpecifier
|
CXCursor_CXXFinalAttr
|
CXCursor_FunctionTemplate
|
CXCursor_ConversionFunction
=
>
{
}
_
=
>
{
warn
!
(
"
unhandled
comp
member
{
}
(
kind
{
:
?
}
)
in
{
}
(
{
}
)
"
cur
.
spelling
(
)
cur
.
kind
(
)
cursor
.
spelling
(
)
cur
.
location
(
)
)
;
}
}
CXChildVisit_Continue
}
)
;
if
let
Some
(
(
ty
_
offset
)
)
=
maybe_anonymous_struct_field
{
let
field
=
Field
:
:
new
(
None
ty
None
None
None
false
offset
)
;
ci
.
fields
.
push
(
field
)
;
}
Ok
(
ci
)
}
fn
kind_from_cursor
(
cursor
:
&
clang
:
:
Cursor
)
-
>
Result
<
CompKind
ParseError
>
{
use
clang_sys
:
:
*
;
Ok
(
match
cursor
.
kind
(
)
{
CXCursor_UnionDecl
=
>
CompKind
:
:
Union
CXCursor_ClassDecl
|
CXCursor_StructDecl
=
>
CompKind
:
:
Struct
CXCursor_CXXBaseSpecifier
|
CXCursor_ClassTemplatePartialSpecialization
|
CXCursor_ClassTemplate
=
>
{
match
cursor
.
template_kind
(
)
{
CXCursor_UnionDecl
=
>
CompKind
:
:
Union
_
=
>
CompKind
:
:
Struct
}
}
_
=
>
{
warn
!
(
"
Unknown
kind
for
comp
type
:
{
:
?
}
"
cursor
)
;
return
Err
(
ParseError
:
:
Continue
)
;
}
}
)
}
pub
fn
signature_contains_named_type
(
&
self
ctx
:
&
BindgenContext
ty
:
&
Type
)
-
>
bool
{
if
self
.
has_non_type_template_params
(
)
{
return
false
;
}
self
.
template_args
.
iter
(
)
.
any
(
|
arg
|
{
ctx
.
resolve_type
(
*
arg
)
.
signature_contains_named_type
(
ctx
ty
)
}
)
}
pub
fn
inner_types
(
&
self
)
-
>
&
[
ItemId
]
{
&
self
.
inner_types
}
pub
fn
inner_vars
(
&
self
)
-
>
&
[
ItemId
]
{
&
self
.
inner_vars
}
pub
fn
found_unknown_attr
(
&
self
)
-
>
bool
{
self
.
found_unknown_attr
}
pub
fn
packed
(
&
self
)
-
>
bool
{
self
.
packed
}
pub
fn
needs_explicit_vtable
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
self
.
has_vtable
(
ctx
)
&
&
!
self
.
base_members
.
iter
(
)
.
any
(
|
base
|
{
ctx
.
resolve_type
(
base
.
ty
)
.
canonical_type
(
ctx
)
.
as_comp
(
)
.
map_or
(
false
|
ci
|
ci
.
has_vtable
(
ctx
)
)
}
)
}
pub
fn
is_forward_declaration
(
&
self
)
-
>
bool
{
self
.
is_forward_declaration
}
}
impl
TemplateDeclaration
for
CompInfo
{
fn
template_params
(
&
self
_ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
{
if
self
.
template_args
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
template_args
.
clone
(
)
)
}
}
}
impl
CanDeriveDebug
for
CompInfo
{
type
Extra
=
Option
<
Layout
>
;
fn
can_derive_debug
(
&
self
ctx
:
&
BindgenContext
layout
:
Option
<
Layout
>
)
-
>
bool
{
if
self
.
has_non_type_template_params
(
)
{
return
layout
.
map_or
(
false
|
l
|
l
.
opaque
(
)
.
can_derive_debug
(
ctx
(
)
)
)
;
}
if
self
.
detect_derive_debug_cycle
.
get
(
)
{
warn
!
(
"
Derive
debug
cycle
detected
!
"
)
;
return
true
;
}
if
self
.
kind
=
=
CompKind
:
:
Union
{
if
ctx
.
options
(
)
.
unstable_rust
{
return
false
;
}
return
layout
.
unwrap_or_else
(
Layout
:
:
zero
)
.
opaque
(
)
.
can_derive_debug
(
ctx
(
)
)
;
}
self
.
detect_derive_debug_cycle
.
set
(
true
)
;
let
can_derive_debug
=
{
self
.
base_members
.
iter
(
)
.
all
(
|
base
|
base
.
ty
.
can_derive_debug
(
ctx
(
)
)
)
&
&
self
.
template_args
.
iter
(
)
.
all
(
|
id
|
id
.
can_derive_debug
(
ctx
(
)
)
)
&
&
self
.
fields
.
iter
(
)
.
all
(
|
f
|
f
.
can_derive_debug
(
ctx
(
)
)
)
&
&
self
.
ref_template
.
map_or
(
true
|
id
|
id
.
can_derive_debug
(
ctx
(
)
)
)
}
;
self
.
detect_derive_debug_cycle
.
set
(
false
)
;
can_derive_debug
}
}
impl
CanDeriveDefault
for
CompInfo
{
type
Extra
=
Option
<
Layout
>
;
fn
can_derive_default
(
&
self
ctx
:
&
BindgenContext
layout
:
Option
<
Layout
>
)
-
>
bool
{
if
self
.
detect_derive_default_cycle
.
get
(
)
{
warn
!
(
"
Derive
default
cycle
detected
!
"
)
;
return
true
;
}
if
self
.
kind
=
=
CompKind
:
:
Union
{
if
ctx
.
options
(
)
.
unstable_rust
{
return
false
;
}
return
layout
.
unwrap_or_else
(
Layout
:
:
zero
)
.
opaque
(
)
.
can_derive_debug
(
ctx
(
)
)
;
}
self
.
detect_derive_default_cycle
.
set
(
true
)
;
let
can_derive_default
=
!
self
.
has_vtable
(
ctx
)
&
&
!
self
.
needs_explicit_vtable
(
ctx
)
&
&
self
.
base_members
.
iter
(
)
.
all
(
|
base
|
base
.
ty
.
can_derive_default
(
ctx
(
)
)
)
&
&
self
.
template_args
.
iter
(
)
.
all
(
|
id
|
id
.
can_derive_default
(
ctx
(
)
)
)
&
&
self
.
fields
.
iter
(
)
.
all
(
|
f
|
f
.
can_derive_default
(
ctx
(
)
)
)
&
&
self
.
ref_template
.
map_or
(
true
|
id
|
id
.
can_derive_default
(
ctx
(
)
)
)
;
self
.
detect_derive_default_cycle
.
set
(
false
)
;
can_derive_default
}
}
impl
<
'
a
>
CanDeriveCopy
<
'
a
>
for
CompInfo
{
type
Extra
=
(
&
'
a
Item
Option
<
Layout
>
)
;
fn
can_derive_copy
(
&
self
ctx
:
&
BindgenContext
(
item
layout
)
:
(
&
Item
Option
<
Layout
>
)
)
-
>
bool
{
if
self
.
has_non_type_template_params
(
)
{
return
layout
.
map_or
(
false
|
l
|
l
.
opaque
(
)
.
can_derive_copy
(
ctx
(
)
)
)
;
}
if
self
.
has_destructor
(
ctx
)
{
return
false
;
}
if
self
.
kind
=
=
CompKind
:
:
Union
{
if
!
ctx
.
options
(
)
.
unstable_rust
{
return
true
;
}
if
!
self
.
template_args
.
is_empty
(
)
|
|
self
.
ref_template
.
is_some
(
)
|
|
!
item
.
applicable_template_args
(
ctx
)
.
is_empty
(
)
{
return
false
;
}
}
self
.
ref_template
.
as_ref
(
)
.
map_or
(
true
|
t
|
t
.
can_derive_copy
(
ctx
(
)
)
)
&
&
self
.
base_members
.
iter
(
)
.
all
(
|
base
|
base
.
ty
.
can_derive_copy
(
ctx
(
)
)
)
&
&
self
.
fields
.
iter
(
)
.
all
(
|
field
|
field
.
can_derive_copy
(
ctx
(
)
)
)
}
fn
can_derive_copy_in_array
(
&
self
ctx
:
&
BindgenContext
extra
:
(
&
Item
Option
<
Layout
>
)
)
-
>
bool
{
self
.
can_derive_copy
(
ctx
extra
)
}
}
impl
Trace
for
CompInfo
{
type
Extra
=
Item
;
fn
trace
<
T
>
(
&
self
context
:
&
BindgenContext
tracer
:
&
mut
T
item
:
&
Item
)
where
T
:
Tracer
{
if
let
Some
(
template
)
=
self
.
specialized_template
(
)
{
tracer
.
visit
(
template
)
;
let
args
=
item
.
applicable_template_args
(
context
)
;
for
a
in
args
{
tracer
.
visit
(
a
)
;
}
}
else
{
let
params
=
item
.
applicable_template_args
(
context
)
;
for
p
in
params
{
tracer
.
visit_kind
(
p
EdgeKind
:
:
TemplateParameterDefinition
)
;
}
}
for
base
in
self
.
base_members
(
)
{
tracer
.
visit
(
base
.
ty
)
;
}
for
field
in
self
.
fields
(
)
{
tracer
.
visit
(
field
.
ty
(
)
)
;
}
for
&
ty
in
self
.
inner_types
(
)
{
tracer
.
visit
(
ty
)
;
}
for
&
var
in
self
.
inner_vars
(
)
{
tracer
.
visit
(
var
)
;
}
for
method
in
self
.
methods
(
)
{
tracer
.
visit
(
method
.
signature
)
;
}
for
&
ctor
in
self
.
constructors
(
)
{
tracer
.
visit
(
ctor
)
;
}
}
}
