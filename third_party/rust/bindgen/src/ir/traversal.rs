use
super
:
:
context
:
:
{
BindgenContext
ItemId
}
;
use
super
:
:
item
:
:
ItemSet
;
use
std
:
:
collections
:
:
{
BTreeMap
VecDeque
}
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
Edge
{
to
:
ItemId
kind
:
EdgeKind
}
impl
Edge
{
pub
fn
new
(
to
:
ItemId
kind
:
EdgeKind
)
-
>
Edge
{
Edge
{
to
:
to
kind
:
kind
}
}
pub
fn
to
(
&
self
)
-
>
ItemId
{
self
.
to
}
pub
fn
kind
(
&
self
)
-
>
EdgeKind
{
self
.
kind
}
}
impl
Into
<
ItemId
>
for
Edge
{
fn
into
(
self
)
-
>
ItemId
{
self
.
to
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
EdgeKind
{
Generic
TemplateParameterDefinition
}
pub
trait
TraversalPredicate
{
fn
should_follow
(
&
self
edge
:
Edge
)
-
>
bool
;
}
impl
TraversalPredicate
for
fn
(
Edge
)
-
>
bool
{
fn
should_follow
(
&
self
edge
:
Edge
)
-
>
bool
{
(
*
self
)
(
edge
)
}
}
pub
fn
all_edges
(
_
:
Edge
)
-
>
bool
{
true
}
pub
fn
no_edges
(
_
:
Edge
)
-
>
bool
{
false
}
pub
trait
TraversalStorage
<
'
ctx
'
gen
>
{
fn
new
(
ctx
:
&
'
ctx
BindgenContext
<
'
gen
>
)
-
>
Self
;
fn
add
(
&
mut
self
from
:
Option
<
ItemId
>
item
:
ItemId
)
-
>
bool
;
}
impl
<
'
ctx
'
gen
>
TraversalStorage
<
'
ctx
'
gen
>
for
ItemSet
{
fn
new
(
_
:
&
'
ctx
BindgenContext
<
'
gen
>
)
-
>
Self
{
ItemSet
:
:
new
(
)
}
fn
add
(
&
mut
self
_
:
Option
<
ItemId
>
item
:
ItemId
)
-
>
bool
{
self
.
insert
(
item
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Paths
<
'
ctx
'
gen
>
(
BTreeMap
<
ItemId
ItemId
>
&
'
ctx
BindgenContext
<
'
gen
>
)
where
'
gen
:
'
ctx
;
impl
<
'
ctx
'
gen
>
TraversalStorage
<
'
ctx
'
gen
>
for
Paths
<
'
ctx
'
gen
>
where
'
gen
:
'
ctx
{
fn
new
(
ctx
:
&
'
ctx
BindgenContext
<
'
gen
>
)
-
>
Self
{
Paths
(
BTreeMap
:
:
new
(
)
ctx
)
}
fn
add
(
&
mut
self
from
:
Option
<
ItemId
>
item
:
ItemId
)
-
>
bool
{
let
newly_discovered
=
self
.
0
.
insert
(
item
from
.
unwrap_or
(
item
)
)
.
is_none
(
)
;
if
self
.
1
.
resolve_item_fallible
(
item
)
.
is_none
(
)
{
let
mut
path
=
vec
!
[
]
;
let
mut
current
=
item
;
loop
{
let
predecessor
=
*
self
.
0
.
get
(
&
current
)
.
expect
(
"
We
know
we
found
this
item
id
so
it
must
have
a
\
predecessor
"
)
;
if
predecessor
=
=
current
{
break
;
}
path
.
push
(
predecessor
)
;
current
=
predecessor
;
}
path
.
reverse
(
)
;
panic
!
(
"
Found
reference
to
dangling
id
=
{
:
?
}
\
nvia
path
=
{
:
?
}
"
item
path
)
;
}
newly_discovered
}
}
pub
trait
TraversalQueue
:
Default
{
fn
push
(
&
mut
self
item
:
ItemId
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
ItemId
>
;
}
impl
TraversalQueue
for
Vec
<
ItemId
>
{
fn
push
(
&
mut
self
item
:
ItemId
)
{
self
.
push
(
item
)
;
}
fn
next
(
&
mut
self
)
-
>
Option
<
ItemId
>
{
self
.
pop
(
)
}
}
impl
TraversalQueue
for
VecDeque
<
ItemId
>
{
fn
push
(
&
mut
self
item
:
ItemId
)
{
self
.
push_back
(
item
)
;
}
fn
next
(
&
mut
self
)
-
>
Option
<
ItemId
>
{
self
.
pop_front
(
)
}
}
pub
trait
Tracer
{
fn
visit_kind
(
&
mut
self
item
:
ItemId
kind
:
EdgeKind
)
;
fn
visit
(
&
mut
self
item
:
ItemId
)
{
self
.
visit_kind
(
item
EdgeKind
:
:
Generic
)
;
}
}
impl
<
F
>
Tracer
for
F
where
F
:
FnMut
(
ItemId
EdgeKind
)
{
fn
visit_kind
(
&
mut
self
item
:
ItemId
kind
:
EdgeKind
)
{
(
*
self
)
(
item
kind
)
}
}
pub
trait
Trace
{
type
Extra
;
fn
trace
<
T
>
(
&
self
context
:
&
BindgenContext
tracer
:
&
mut
T
extra
:
&
Self
:
:
Extra
)
where
T
:
Tracer
;
}
pub
struct
ItemTraversal
<
'
ctx
'
gen
Storage
Queue
Predicate
>
where
'
gen
:
'
ctx
Storage
:
TraversalStorage
<
'
ctx
'
gen
>
Queue
:
TraversalQueue
Predicate
:
TraversalPredicate
{
ctx
:
&
'
ctx
BindgenContext
<
'
gen
>
seen
:
Storage
queue
:
Queue
predicate
:
Predicate
currently_traversing
:
Option
<
ItemId
>
}
impl
<
'
ctx
'
gen
Storage
Queue
Predicate
>
ItemTraversal
<
'
ctx
'
gen
Storage
Queue
Predicate
>
where
'
gen
:
'
ctx
Storage
:
TraversalStorage
<
'
ctx
'
gen
>
Queue
:
TraversalQueue
Predicate
:
TraversalPredicate
{
pub
fn
new
<
R
>
(
ctx
:
&
'
ctx
BindgenContext
<
'
gen
>
roots
:
R
predicate
:
Predicate
)
-
>
ItemTraversal
<
'
ctx
'
gen
Storage
Queue
Predicate
>
where
R
:
IntoIterator
<
Item
=
ItemId
>
{
let
mut
seen
=
Storage
:
:
new
(
ctx
)
;
let
mut
queue
=
Queue
:
:
default
(
)
;
for
id
in
roots
{
seen
.
add
(
None
id
)
;
queue
.
push
(
id
)
;
}
ItemTraversal
{
ctx
:
ctx
seen
:
seen
queue
:
queue
predicate
:
predicate
currently_traversing
:
None
}
}
}
impl
<
'
ctx
'
gen
Storage
Queue
Predicate
>
Tracer
for
ItemTraversal
<
'
ctx
'
gen
Storage
Queue
Predicate
>
where
'
gen
:
'
ctx
Storage
:
TraversalStorage
<
'
ctx
'
gen
>
Queue
:
TraversalQueue
Predicate
:
TraversalPredicate
{
fn
visit_kind
(
&
mut
self
item
:
ItemId
kind
:
EdgeKind
)
{
let
edge
=
Edge
:
:
new
(
item
kind
)
;
if
!
self
.
predicate
.
should_follow
(
edge
)
{
return
;
}
let
is_newly_discovered
=
self
.
seen
.
add
(
self
.
currently_traversing
item
)
;
if
is_newly_discovered
{
self
.
queue
.
push
(
item
)
}
}
}
impl
<
'
ctx
'
gen
Storage
Queue
Predicate
>
Iterator
for
ItemTraversal
<
'
ctx
'
gen
Storage
Queue
Predicate
>
where
'
gen
:
'
ctx
Storage
:
TraversalStorage
<
'
ctx
'
gen
>
Queue
:
TraversalQueue
Predicate
:
TraversalPredicate
{
type
Item
=
ItemId
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
id
=
match
self
.
queue
.
next
(
)
{
None
=
>
return
None
Some
(
id
)
=
>
id
}
;
let
newly_discovered
=
self
.
seen
.
add
(
None
id
)
;
debug_assert
!
(
!
newly_discovered
"
should
have
already
seen
anything
we
get
out
of
our
queue
"
)
;
debug_assert
!
(
self
.
ctx
.
resolve_item_fallible
(
id
)
.
is_some
(
)
"
should
only
get
IDs
of
actual
items
in
our
context
during
traversal
"
)
;
self
.
currently_traversing
=
Some
(
id
)
;
id
.
trace
(
self
.
ctx
self
&
(
)
)
;
self
.
currently_traversing
=
None
;
Some
(
id
)
}
}
pub
type
AssertNoDanglingItemsTraversal
<
'
ctx
'
gen
>
=
ItemTraversal
<
'
ctx
'
gen
Paths
<
'
ctx
'
gen
>
VecDeque
<
ItemId
>
fn
(
Edge
)
-
>
bool
>
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
#
[
allow
(
dead_code
)
]
fn
traversal_predicate_is_object_safe
(
)
{
fn
takes_by_trait_object
(
_
:
&
TraversalPredicate
)
{
}
}
}
