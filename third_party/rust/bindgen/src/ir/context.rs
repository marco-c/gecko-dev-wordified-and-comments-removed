use
super
:
:
derive
:
:
{
CanDeriveCopy
CanDeriveDebug
}
;
use
super
:
:
int
:
:
IntKind
;
use
super
:
:
item
:
:
{
Item
ItemCanonicalPath
}
;
use
super
:
:
item_kind
:
:
ItemKind
;
use
super
:
:
module
:
:
{
Module
ModuleKind
}
;
use
super
:
:
ty
:
:
{
FloatKind
Type
TypeKind
}
;
use
super
:
:
type_collector
:
:
{
ItemSet
TypeCollector
}
;
use
BindgenOptions
;
use
cexpr
;
use
chooser
:
:
TypeChooser
;
use
clang
:
:
{
self
Cursor
}
;
use
parse
:
:
ClangItemParser
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
collections
:
:
{
HashMap
VecDeque
hash_map
}
;
use
std
:
:
collections
:
:
btree_map
:
:
{
self
BTreeMap
}
;
use
std
:
:
fmt
;
use
syntax
:
:
ast
:
:
Ident
;
use
syntax
:
:
codemap
:
:
{
DUMMY_SP
Span
}
;
use
syntax
:
:
ext
:
:
base
:
:
ExtCtxt
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
ItemId
(
usize
)
;
impl
ItemId
{
pub
fn
as_usize
(
&
self
)
-
>
usize
{
self
.
0
}
}
impl
CanDeriveDebug
for
ItemId
{
type
Extra
=
(
)
;
fn
can_derive_debug
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
ctx
.
resolve_item
(
*
self
)
.
can_derive_debug
(
ctx
(
)
)
}
}
impl
<
'
a
>
CanDeriveCopy
<
'
a
>
for
ItemId
{
type
Extra
=
(
)
;
fn
can_derive_copy
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
ctx
.
resolve_item
(
*
self
)
.
can_derive_copy
(
ctx
(
)
)
}
fn
can_derive_copy_in_array
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
ctx
.
resolve_item
(
*
self
)
.
can_derive_copy_in_array
(
ctx
(
)
)
}
}
#
[
derive
(
Eq
PartialEq
Hash
Debug
)
]
enum
TypeKey
{
USR
(
String
)
Declaration
(
Cursor
)
}
struct
GenContext
<
'
ctx
>
(
ExtCtxt
<
'
ctx
>
)
;
impl
<
'
ctx
>
fmt
:
:
Debug
for
GenContext
<
'
ctx
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
GenContext
{
{
.
.
.
}
}
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
BindgenContext
<
'
ctx
>
{
items
:
BTreeMap
<
ItemId
Item
>
next_item_id
:
ItemId
types
:
HashMap
<
TypeKey
ItemId
>
modules
:
HashMap
<
Cursor
ItemId
>
root_module
:
ItemId
current_module
:
ItemId
pub
currently_parsed_types
:
Vec
<
(
Cursor
ItemId
)
>
parsed_macros
:
HashMap
<
Vec
<
u8
>
cexpr
:
:
expr
:
:
EvalResult
>
replacements
:
HashMap
<
Vec
<
String
>
ItemId
>
collected_typerefs
:
bool
gen_ctx
:
Option
<
&
'
ctx
GenContext
<
'
ctx
>
>
span
:
Span
index
:
clang
:
:
Index
translation_unit
:
clang
:
:
TranslationUnit
options
:
BindgenOptions
generated_bindegen_complex
:
Cell
<
bool
>
}
impl
<
'
ctx
>
BindgenContext
<
'
ctx
>
{
pub
fn
new
(
options
:
BindgenOptions
)
-
>
Self
{
use
clang_sys
;
let
index
=
clang
:
:
Index
:
:
new
(
false
true
)
;
let
parse_options
=
clang_sys
:
:
CXTranslationUnit_DetailedPreprocessingRecord
;
let
translation_unit
=
clang
:
:
TranslationUnit
:
:
parse
(
&
index
"
"
&
options
.
clang_args
&
[
]
parse_options
)
.
expect
(
"
TranslationUnit
:
:
parse
"
)
;
let
root_module
=
Self
:
:
build_root_module
(
ItemId
(
0
)
)
;
let
mut
me
=
BindgenContext
{
items
:
Default
:
:
default
(
)
types
:
Default
:
:
default
(
)
modules
:
Default
:
:
default
(
)
next_item_id
:
ItemId
(
1
)
root_module
:
root_module
.
id
(
)
current_module
:
root_module
.
id
(
)
currently_parsed_types
:
vec
!
[
]
parsed_macros
:
Default
:
:
default
(
)
replacements
:
Default
:
:
default
(
)
collected_typerefs
:
false
gen_ctx
:
None
span
:
DUMMY_SP
index
:
index
translation_unit
:
translation_unit
options
:
options
generated_bindegen_complex
:
Cell
:
:
new
(
false
)
}
;
me
.
add_item
(
root_module
None
None
)
;
me
}
pub
fn
type_chooser
(
&
self
)
-
>
Option
<
&
TypeChooser
>
{
self
.
options
(
)
.
type_chooser
.
as_ref
(
)
.
map
(
|
t
|
&
*
*
t
)
}
pub
fn
add_item
(
&
mut
self
item
:
Item
declaration
:
Option
<
Cursor
>
location
:
Option
<
Cursor
>
)
{
debug
!
(
"
BindgenContext
:
:
add_item
(
{
:
?
}
declaration
:
{
:
?
}
loc
:
{
:
?
}
"
item
declaration
location
)
;
debug_assert
!
(
declaration
.
is_some
(
)
|
|
!
item
.
kind
(
)
.
is_type
(
)
|
|
item
.
kind
(
)
.
expect_type
(
)
.
is_builtin_or_named
(
)
"
Adding
a
type
without
declaration
?
"
)
;
let
id
=
item
.
id
(
)
;
let
is_type
=
item
.
kind
(
)
.
is_type
(
)
;
let
is_unnamed
=
is_type
&
&
item
.
expect_type
(
)
.
name
(
)
.
is_none
(
)
;
if
item
.
id
(
)
!
=
item
.
parent_id
(
)
{
if
let
Some
(
mut
parent
)
=
self
.
items
.
get_mut
(
&
item
.
parent_id
(
)
)
{
if
let
Some
(
mut
module
)
=
parent
.
as_module_mut
(
)
{
module
.
children_mut
(
)
.
push
(
item
.
id
(
)
)
;
}
}
}
let
old_item
=
self
.
items
.
insert
(
id
item
)
;
assert
!
(
old_item
.
is_none
(
)
"
Inserted
type
twice
?
"
)
;
if
is_type
&
&
declaration
.
is_some
(
)
{
let
mut
declaration
=
declaration
.
unwrap
(
)
;
if
!
declaration
.
is_valid
(
)
{
if
let
Some
(
location
)
=
location
{
if
location
.
is_template_like
(
)
{
declaration
=
location
;
}
}
}
declaration
=
declaration
.
canonical
(
)
;
if
!
declaration
.
is_valid
(
)
{
debug
!
(
"
Invalid
declaration
{
:
?
}
found
for
type
{
:
?
}
"
declaration
self
.
items
.
get
(
&
id
)
.
unwrap
(
)
.
kind
(
)
.
expect_type
(
)
)
;
return
;
}
let
key
=
if
is_unnamed
{
TypeKey
:
:
Declaration
(
declaration
)
}
else
if
let
Some
(
usr
)
=
declaration
.
usr
(
)
{
TypeKey
:
:
USR
(
usr
)
}
else
{
warn
!
(
"
Valid
declaration
with
no
USR
:
{
:
?
}
{
:
?
}
"
declaration
location
)
;
TypeKey
:
:
Declaration
(
declaration
)
}
;
let
old
=
self
.
types
.
insert
(
key
id
)
;
debug_assert_eq
!
(
old
None
)
;
}
}
pub
fn
ext_cx
(
&
self
)
-
>
&
ExtCtxt
<
'
ctx
>
{
&
self
.
gen_ctx
.
expect
(
"
Not
in
gen
phase
"
)
.
0
}
pub
fn
span
(
&
self
)
-
>
Span
{
self
.
span
}
pub
fn
rust_mangle
<
'
a
>
(
&
self
name
:
&
'
a
str
)
-
>
Cow
<
'
a
str
>
{
use
syntax
:
:
parse
:
:
token
;
let
ident
=
self
.
rust_ident_raw
(
name
)
;
let
token
=
token
:
:
Ident
(
ident
)
;
if
token
.
is_any_keyword
(
)
|
|
name
.
contains
(
"
"
)
|
|
name
.
contains
(
"
?
"
)
|
|
name
.
contains
(
"
"
)
|
|
"
bool
"
=
=
name
{
let
mut
s
=
name
.
to_owned
(
)
;
s
=
s
.
replace
(
"
"
"
_
"
)
;
s
=
s
.
replace
(
"
?
"
"
_
"
)
;
s
=
s
.
replace
(
"
"
"
_
"
)
;
s
.
push_str
(
"
_
"
)
;
return
Cow
:
:
Owned
(
s
)
;
}
Cow
:
:
Borrowed
(
name
)
}
pub
fn
rust_ident
(
&
self
name
:
&
str
)
-
>
Ident
{
self
.
rust_ident_raw
(
&
self
.
rust_mangle
(
name
)
)
}
pub
fn
rust_ident_raw
(
&
self
name
:
&
str
)
-
>
Ident
{
self
.
ext_cx
(
)
.
ident_of
(
name
)
}
pub
fn
items
<
'
a
>
(
&
'
a
self
)
-
>
btree_map
:
:
Iter
<
'
a
ItemId
Item
>
{
self
.
items
.
iter
(
)
}
pub
fn
collected_typerefs
(
&
self
)
-
>
bool
{
self
.
collected_typerefs
}
fn
collect_typerefs
(
&
mut
self
)
-
>
Vec
<
(
ItemId
clang
:
:
Type
Option
<
clang
:
:
Cursor
>
Option
<
ItemId
>
)
>
{
debug_assert
!
(
!
self
.
collected_typerefs
)
;
self
.
collected_typerefs
=
true
;
let
mut
typerefs
=
vec
!
[
]
;
for
(
id
ref
mut
item
)
in
&
mut
self
.
items
{
let
kind
=
item
.
kind
(
)
;
let
ty
=
match
kind
.
as_type
(
)
{
Some
(
ty
)
=
>
ty
None
=
>
continue
}
;
match
*
ty
.
kind
(
)
{
TypeKind
:
:
UnresolvedTypeRef
(
ref
ty
loc
parent_id
)
=
>
{
typerefs
.
push
(
(
*
id
ty
.
clone
(
)
loc
parent_id
)
)
;
}
_
=
>
{
}
}
;
}
typerefs
}
fn
resolve_typerefs
(
&
mut
self
)
{
let
typerefs
=
self
.
collect_typerefs
(
)
;
for
(
id
ty
loc
parent_id
)
in
typerefs
{
let
_resolved
=
{
let
resolved
=
Item
:
:
from_ty
(
&
ty
loc
parent_id
self
)
.
expect
(
"
What
happened
?
"
)
;
let
mut
item
=
self
.
items
.
get_mut
(
&
id
)
.
unwrap
(
)
;
*
item
.
kind_mut
(
)
.
as_type_mut
(
)
.
unwrap
(
)
.
kind_mut
(
)
=
TypeKind
:
:
ResolvedTypeRef
(
resolved
)
;
resolved
}
;
}
}
fn
process_replacements
(
&
mut
self
)
{
if
self
.
replacements
.
is_empty
(
)
{
debug
!
(
"
No
replacements
to
process
"
)
;
return
;
}
let
mut
replacements
=
vec
!
[
]
;
for
(
id
item
)
in
self
.
items
.
iter
(
)
{
if
item
.
annotations
(
)
.
use_instead_of
(
)
.
is_some
(
)
{
continue
;
}
let
ty
=
match
item
.
kind
(
)
.
as_type
(
)
{
Some
(
ty
)
=
>
ty
None
=
>
continue
}
;
match
*
ty
.
kind
(
)
{
TypeKind
:
:
Comp
(
ref
ci
)
if
!
ci
.
is_template_specialization
(
)
=
>
{
}
TypeKind
:
:
TemplateAlias
(
.
.
)
|
TypeKind
:
:
Alias
(
.
.
)
=
>
{
}
_
=
>
continue
}
let
path
=
item
.
canonical_path
(
self
)
;
let
replacement
=
self
.
replacements
.
get
(
&
path
[
1
.
.
]
)
;
if
let
Some
(
replacement
)
=
replacement
{
if
replacement
!
=
id
{
if
self
.
items
.
get
(
replacement
)
.
is_some
(
)
{
replacements
.
push
(
(
*
id
*
replacement
)
)
;
}
}
}
}
for
(
id
replacement
)
in
replacements
{
debug
!
(
"
Replacing
{
:
?
}
with
{
:
?
}
"
id
replacement
)
;
let
new_parent
=
{
let
mut
item
=
self
.
items
.
get_mut
(
&
id
)
.
unwrap
(
)
;
*
item
.
kind_mut
(
)
.
as_type_mut
(
)
.
unwrap
(
)
.
kind_mut
(
)
=
TypeKind
:
:
ResolvedTypeRef
(
replacement
)
;
item
.
parent_id
(
)
}
;
let
old_parent
=
self
.
resolve_item
(
replacement
)
.
parent_id
(
)
;
if
new_parent
=
=
old_parent
{
continue
;
}
if
let
Some
(
mut
module
)
=
self
.
items
.
get_mut
(
&
old_parent
)
.
unwrap
(
)
.
as_module_mut
(
)
{
let
position
=
module
.
children
(
)
.
iter
(
)
.
position
(
|
id
|
*
id
=
=
replacement
)
.
unwrap
(
)
;
module
.
children_mut
(
)
.
remove
(
position
)
;
}
if
let
Some
(
mut
module
)
=
self
.
items
.
get_mut
(
&
new_parent
)
.
unwrap
(
)
.
as_module_mut
(
)
{
module
.
children_mut
(
)
.
push
(
replacement
)
;
}
self
.
items
.
get_mut
(
&
replacement
)
.
unwrap
(
)
.
set_parent_for_replacement
(
new_parent
)
;
self
.
items
.
get_mut
(
&
id
)
.
unwrap
(
)
.
set_parent_for_replacement
(
old_parent
)
;
}
}
pub
fn
gen
<
F
Out
>
(
&
mut
self
cb
:
F
)
-
>
Out
where
F
:
FnOnce
(
&
Self
)
-
>
Out
{
use
aster
:
:
symbol
:
:
ToSymbol
;
use
syntax
:
:
ext
:
:
expand
:
:
ExpansionConfig
;
use
syntax
:
:
codemap
:
:
{
ExpnInfo
MacroBang
NameAndSpan
}
;
use
syntax
:
:
ext
:
:
base
;
use
syntax
:
:
parse
;
use
std
:
:
mem
;
let
cfg
=
ExpansionConfig
:
:
default
(
"
xxx
"
.
to_owned
(
)
)
;
let
sess
=
parse
:
:
ParseSess
:
:
new
(
)
;
let
mut
loader
=
base
:
:
DummyResolver
;
let
mut
ctx
=
GenContext
(
base
:
:
ExtCtxt
:
:
new
(
&
sess
cfg
&
mut
loader
)
)
;
ctx
.
0
.
bt_push
(
ExpnInfo
{
call_site
:
self
.
span
callee
:
NameAndSpan
{
format
:
MacroBang
(
"
"
.
to_symbol
(
)
)
allow_internal_unstable
:
false
span
:
None
}
}
)
;
self
.
gen_ctx
=
Some
(
unsafe
{
mem
:
:
transmute
(
&
ctx
)
}
)
;
self
.
assert_no_dangling_references
(
)
;
if
!
self
.
collected_typerefs
(
)
{
self
.
resolve_typerefs
(
)
;
self
.
process_replacements
(
)
;
}
let
ret
=
cb
(
self
)
;
self
.
gen_ctx
=
None
;
ret
}
fn
assert_no_dangling_references
(
&
self
)
{
if
cfg
!
(
feature
=
"
assert_no_dangling_items
"
)
{
for
_
in
self
.
assert_no_dangling_item_traversal
(
)
{
}
}
}
fn
assert_no_dangling_item_traversal
<
'
me
>
(
&
'
me
self
)
-
>
AssertNoDanglingItemIter
<
'
me
'
ctx
>
{
assert
!
(
self
.
in_codegen_phase
(
)
)
;
assert
!
(
self
.
current_module
=
=
self
.
root_module
)
;
let
mut
roots
=
self
.
items
(
)
.
map
(
|
(
&
id
_
)
|
id
)
;
let
mut
seen
=
BTreeMap
:
:
<
ItemId
ItemId
>
:
:
new
(
)
;
let
next_child
=
roots
.
next
(
)
.
map
(
|
id
|
id
)
.
unwrap
(
)
;
seen
.
insert
(
next_child
next_child
)
;
let
to_iterate
=
seen
.
iter
(
)
.
map
(
|
(
&
id
_
)
|
id
)
.
rev
(
)
.
collect
(
)
;
AssertNoDanglingItemIter
{
ctx
:
self
seen
:
seen
to_iterate
:
to_iterate
}
}
fn
add_builtin_item
(
&
mut
self
item
:
Item
)
{
debug
!
(
"
add_builtin_item
:
item
=
{
:
?
}
"
item
)
;
debug_assert
!
(
item
.
kind
(
)
.
is_type
(
)
)
;
let
id
=
item
.
id
(
)
;
let
old_item
=
self
.
items
.
insert
(
id
item
)
;
assert
!
(
old_item
.
is_none
(
)
"
Inserted
type
twice
?
"
)
;
}
fn
build_root_module
(
id
:
ItemId
)
-
>
Item
{
let
module
=
Module
:
:
new
(
Some
(
"
root
"
.
into
(
)
)
ModuleKind
:
:
Normal
)
;
Item
:
:
new
(
id
None
None
id
ItemKind
:
:
Module
(
module
)
)
}
pub
fn
root_module
(
&
self
)
-
>
ItemId
{
self
.
root_module
}
pub
fn
resolve_type
(
&
self
type_id
:
ItemId
)
-
>
&
Type
{
self
.
items
.
get
(
&
type_id
)
.
unwrap
(
)
.
kind
(
)
.
expect_type
(
)
}
pub
fn
safe_resolve_type
(
&
self
type_id
:
ItemId
)
-
>
Option
<
&
Type
>
{
self
.
items
.
get
(
&
type_id
)
.
map
(
|
t
|
t
.
kind
(
)
.
expect_type
(
)
)
}
pub
fn
resolve_item_fallible
(
&
self
item_id
:
ItemId
)
-
>
Option
<
&
Item
>
{
self
.
items
.
get
(
&
item_id
)
}
pub
fn
resolve_item
(
&
self
item_id
:
ItemId
)
-
>
&
Item
{
match
self
.
items
.
get
(
&
item_id
)
{
Some
(
item
)
=
>
item
None
=
>
panic
!
(
"
Not
an
item
:
{
:
?
}
"
item_id
)
}
}
pub
fn
current_module
(
&
self
)
-
>
ItemId
{
self
.
current_module
}
fn
build_template_wrapper
(
&
mut
self
with_id
:
ItemId
wrapping
:
ItemId
parent_id
:
ItemId
ty
:
&
clang
:
:
Type
location
:
clang
:
:
Cursor
declaration
:
clang
:
:
Cursor
)
-
>
ItemId
{
use
clang_sys
:
:
*
;
let
mut
args
=
vec
!
[
]
;
location
.
visit
(
|
c
|
{
if
c
.
kind
(
)
=
=
CXCursor_TypeRef
{
let
new_ty
=
Item
:
:
from_ty_or_ref
(
c
.
cur_type
(
)
Some
(
c
)
Some
(
wrapping
)
self
)
;
args
.
push
(
new_ty
)
;
}
CXChildVisit_Continue
}
)
;
let
item
=
{
let
wrapping_type
=
self
.
resolve_type
(
wrapping
)
;
if
let
TypeKind
:
:
Comp
(
ref
ci
)
=
*
wrapping_type
.
kind
(
)
{
let
old_args
=
ci
.
template_args
(
)
;
if
old_args
.
len
(
)
!
=
args
.
len
(
)
{
error
!
(
"
Found
partial
template
specialization
\
expect
dragons
!
"
)
;
return
wrapping
;
}
}
else
{
assert_eq
!
(
declaration
.
kind
(
)
:
:
clang_sys
:
:
CXCursor_TypeAliasTemplateDecl
"
Expected
wrappable
type
"
)
;
}
let
type_kind
=
TypeKind
:
:
TemplateRef
(
wrapping
args
)
;
let
name
=
ty
.
spelling
(
)
;
let
name
=
if
name
.
is_empty
(
)
{
None
}
else
{
Some
(
name
)
}
;
let
ty
=
Type
:
:
new
(
name
ty
.
fallible_layout
(
)
.
ok
(
)
type_kind
ty
.
is_const
(
)
)
;
Item
:
:
new
(
with_id
None
None
parent_id
ItemKind
:
:
Type
(
ty
)
)
}
;
debug
!
(
"
build_template_wrapper
:
inserting
item
:
{
:
?
}
"
item
)
;
debug_assert
!
(
with_id
=
=
item
.
id
(
)
)
;
self
.
items
.
insert
(
with_id
item
)
;
with_id
}
pub
fn
builtin_or_resolved_ty
(
&
mut
self
with_id
:
ItemId
parent_id
:
Option
<
ItemId
>
ty
:
&
clang
:
:
Type
location
:
Option
<
clang
:
:
Cursor
>
)
-
>
Option
<
ItemId
>
{
use
clang_sys
:
:
{
CXCursor_TypeAliasTemplateDecl
CXCursor_TypeRef
}
;
debug
!
(
"
builtin_or_resolved_ty
:
{
:
?
}
{
:
?
}
{
:
?
}
"
ty
location
parent_id
)
;
let
mut
declaration
=
ty
.
declaration
(
)
;
if
!
declaration
.
is_valid
(
)
{
if
let
Some
(
location
)
=
location
{
if
location
.
is_template_like
(
)
{
declaration
=
location
;
}
}
}
let
canonical_declaration
=
declaration
.
canonical
(
)
;
if
canonical_declaration
.
is_valid
(
)
{
let
id
=
self
.
types
.
get
(
&
TypeKey
:
:
Declaration
(
canonical_declaration
)
)
.
map
(
|
id
|
*
id
)
.
or_else
(
|
|
{
canonical_declaration
.
usr
(
)
.
and_then
(
|
usr
|
self
.
types
.
get
(
&
TypeKey
:
:
USR
(
usr
)
)
)
.
map
(
|
id
|
*
id
)
}
)
;
if
let
Some
(
id
)
=
id
{
debug
!
(
"
Already
resolved
ty
{
:
?
}
{
:
?
}
{
:
?
}
{
:
?
}
"
id
declaration
ty
location
)
;
if
declaration
.
is_template_like
(
)
&
&
*
ty
!
=
canonical_declaration
.
cur_type
(
)
&
&
location
.
is_some
(
)
&
&
parent_id
.
is_some
(
)
{
if
declaration
.
kind
(
)
=
=
CXCursor_TypeAliasTemplateDecl
&
&
!
location
.
unwrap
(
)
.
contains_cursor
(
CXCursor_TypeRef
)
&
&
ty
.
canonical_type
(
)
.
is_valid_and_exposed
(
)
{
return
None
;
}
return
Some
(
self
.
build_template_wrapper
(
with_id
id
parent_id
.
unwrap
(
)
ty
location
.
unwrap
(
)
declaration
)
)
;
}
return
Some
(
self
.
build_ty_wrapper
(
with_id
id
parent_id
ty
)
)
;
}
}
debug
!
(
"
Not
resolved
maybe
builtin
?
"
)
;
self
.
build_builtin_ty
(
ty
declaration
)
}
fn
build_ty_wrapper
(
&
mut
self
with_id
:
ItemId
wrapped_id
:
ItemId
parent_id
:
Option
<
ItemId
>
ty
:
&
clang
:
:
Type
)
-
>
ItemId
{
let
spelling
=
ty
.
spelling
(
)
;
let
is_const
=
ty
.
is_const
(
)
;
let
layout
=
ty
.
fallible_layout
(
)
.
ok
(
)
;
let
type_kind
=
TypeKind
:
:
ResolvedTypeRef
(
wrapped_id
)
;
let
ty
=
Type
:
:
new
(
Some
(
spelling
)
layout
type_kind
is_const
)
;
let
item
=
Item
:
:
new
(
with_id
None
None
parent_id
.
unwrap_or
(
self
.
current_module
)
ItemKind
:
:
Type
(
ty
)
)
;
self
.
add_builtin_item
(
item
)
;
with_id
}
pub
fn
next_item_id
(
&
mut
self
)
-
>
ItemId
{
let
ret
=
self
.
next_item_id
;
self
.
next_item_id
=
ItemId
(
self
.
next_item_id
.
0
+
1
)
;
ret
}
fn
build_builtin_ty
(
&
mut
self
ty
:
&
clang
:
:
Type
_declaration
:
Cursor
)
-
>
Option
<
ItemId
>
{
use
clang_sys
:
:
*
;
let
type_kind
=
match
ty
.
kind
(
)
{
CXType_NullPtr
=
>
TypeKind
:
:
NullPtr
CXType_Void
=
>
TypeKind
:
:
Void
CXType_Bool
=
>
TypeKind
:
:
Int
(
IntKind
:
:
Bool
)
CXType_Int
=
>
TypeKind
:
:
Int
(
IntKind
:
:
Int
)
CXType_UInt
=
>
TypeKind
:
:
Int
(
IntKind
:
:
UInt
)
CXType_SChar
|
CXType_Char_S
=
>
TypeKind
:
:
Int
(
IntKind
:
:
Char
)
CXType_UChar
|
CXType_Char_U
=
>
TypeKind
:
:
Int
(
IntKind
:
:
UChar
)
CXType_Short
=
>
TypeKind
:
:
Int
(
IntKind
:
:
Short
)
CXType_UShort
=
>
TypeKind
:
:
Int
(
IntKind
:
:
UShort
)
CXType_WChar
|
CXType_Char16
=
>
TypeKind
:
:
Int
(
IntKind
:
:
U16
)
CXType_Char32
=
>
TypeKind
:
:
Int
(
IntKind
:
:
U32
)
CXType_Long
=
>
TypeKind
:
:
Int
(
IntKind
:
:
Long
)
CXType_ULong
=
>
TypeKind
:
:
Int
(
IntKind
:
:
ULong
)
CXType_LongLong
=
>
TypeKind
:
:
Int
(
IntKind
:
:
LongLong
)
CXType_ULongLong
=
>
TypeKind
:
:
Int
(
IntKind
:
:
ULongLong
)
CXType_Int128
=
>
TypeKind
:
:
Int
(
IntKind
:
:
I128
)
CXType_UInt128
=
>
TypeKind
:
:
Int
(
IntKind
:
:
U128
)
CXType_Float
=
>
TypeKind
:
:
Float
(
FloatKind
:
:
Float
)
CXType_Double
=
>
TypeKind
:
:
Float
(
FloatKind
:
:
Double
)
CXType_LongDouble
=
>
TypeKind
:
:
Float
(
FloatKind
:
:
LongDouble
)
CXType_Float128
=
>
TypeKind
:
:
Float
(
FloatKind
:
:
Float128
)
CXType_Complex
=
>
{
let
float_type
=
ty
.
elem_type
(
)
.
expect
(
"
Not
able
to
resolve
complex
type
?
"
)
;
let
float_kind
=
match
float_type
.
kind
(
)
{
CXType_Float
=
>
FloatKind
:
:
Float
CXType_Double
=
>
FloatKind
:
:
Double
CXType_LongDouble
=
>
FloatKind
:
:
LongDouble
_
=
>
panic
!
(
"
Non
floating
-
type
complex
?
"
)
}
;
TypeKind
:
:
Complex
(
float_kind
)
}
_
=
>
return
None
}
;
let
spelling
=
ty
.
spelling
(
)
;
let
is_const
=
ty
.
is_const
(
)
;
let
layout
=
ty
.
fallible_layout
(
)
.
ok
(
)
;
let
ty
=
Type
:
:
new
(
Some
(
spelling
)
layout
type_kind
is_const
)
;
let
id
=
self
.
next_item_id
(
)
;
let
item
=
Item
:
:
new
(
id
None
None
self
.
root_module
ItemKind
:
:
Type
(
ty
)
)
;
self
.
add_builtin_item
(
item
)
;
Some
(
id
)
}
pub
fn
translation_unit
(
&
self
)
-
>
&
clang
:
:
TranslationUnit
{
&
self
.
translation_unit
}
pub
fn
parsed_macro
(
&
self
macro_name
:
&
[
u8
]
)
-
>
bool
{
self
.
parsed_macros
.
contains_key
(
macro_name
)
}
pub
fn
parsed_macros
(
&
self
)
-
>
&
HashMap
<
Vec
<
u8
>
cexpr
:
:
expr
:
:
EvalResult
>
{
debug_assert
!
(
!
self
.
in_codegen_phase
(
)
)
;
&
self
.
parsed_macros
}
pub
fn
note_parsed_macro
(
&
mut
self
id
:
Vec
<
u8
>
value
:
cexpr
:
:
expr
:
:
EvalResult
)
{
self
.
parsed_macros
.
insert
(
id
value
)
;
}
pub
fn
in_codegen_phase
(
&
self
)
-
>
bool
{
self
.
gen_ctx
.
is_some
(
)
}
pub
fn
replace
(
&
mut
self
name
:
&
[
String
]
potential_ty
:
ItemId
)
{
match
self
.
replacements
.
entry
(
name
.
into
(
)
)
{
hash_map
:
:
Entry
:
:
Vacant
(
entry
)
=
>
{
debug
!
(
"
Defining
replacement
for
{
:
?
}
as
{
:
?
}
"
name
potential_ty
)
;
entry
.
insert
(
potential_ty
)
;
}
hash_map
:
:
Entry
:
:
Occupied
(
occupied
)
=
>
{
warn
!
(
"
Replacement
for
{
:
?
}
already
defined
as
{
:
?
}
;
\
ignoring
duplicate
replacement
definition
as
{
:
?
}
"
name
occupied
.
get
(
)
potential_ty
)
;
}
}
}
pub
fn
hidden_by_name
(
&
self
path
:
&
[
String
]
id
:
ItemId
)
-
>
bool
{
debug_assert
!
(
self
.
in_codegen_phase
(
)
"
You
'
re
not
supposed
to
call
this
yet
"
)
;
self
.
options
.
hidden_types
.
matches
(
&
path
[
1
.
.
]
.
join
(
"
:
:
"
)
)
|
|
self
.
is_replaced_type
(
path
id
)
}
pub
fn
is_replaced_type
(
&
self
path
:
&
[
String
]
id
:
ItemId
)
-
>
bool
{
match
self
.
replacements
.
get
(
path
)
{
Some
(
replaced_by
)
if
*
replaced_by
!
=
id
=
>
true
_
=
>
false
}
}
pub
fn
opaque_by_name
(
&
self
path
:
&
[
String
]
)
-
>
bool
{
debug_assert
!
(
self
.
in_codegen_phase
(
)
"
You
'
re
not
supposed
to
call
this
yet
"
)
;
self
.
options
.
opaque_types
.
matches
(
&
path
[
1
.
.
]
.
join
(
"
:
:
"
)
)
}
pub
fn
options
(
&
self
)
-
>
&
BindgenOptions
{
&
self
.
options
}
fn
tokenize_namespace
(
&
self
cursor
:
&
clang
:
:
Cursor
)
-
>
(
Option
<
String
>
ModuleKind
)
{
assert_eq
!
(
cursor
.
kind
(
)
:
:
clang_sys
:
:
CXCursor_Namespace
"
Be
a
nice
person
"
)
;
let
tokens
=
match
self
.
translation_unit
.
tokens
(
&
cursor
)
{
Some
(
tokens
)
=
>
tokens
None
=
>
return
(
None
ModuleKind
:
:
Normal
)
}
;
let
mut
iter
=
tokens
.
iter
(
)
;
let
mut
kind
=
ModuleKind
:
:
Normal
;
let
mut
found_namespace_keyword
=
false
;
let
mut
module_name
=
None
;
while
let
Some
(
token
)
=
iter
.
next
(
)
{
match
&
*
token
.
spelling
{
"
inline
"
=
>
{
assert
!
(
!
found_namespace_keyword
)
;
assert
!
(
kind
!
=
ModuleKind
:
:
Inline
)
;
kind
=
ModuleKind
:
:
Inline
;
}
"
namespace
"
=
>
{
found_namespace_keyword
=
true
;
}
"
{
"
=
>
{
assert
!
(
found_namespace_keyword
)
;
break
;
}
name
if
found_namespace_keyword
=
>
{
module_name
=
Some
(
name
.
to_owned
(
)
)
;
break
;
}
_
=
>
{
panic
!
(
"
Unknown
token
while
processing
namespace
:
{
:
?
}
"
token
)
;
}
}
}
(
module_name
kind
)
}
pub
fn
module
(
&
mut
self
cursor
:
clang
:
:
Cursor
)
-
>
ItemId
{
use
clang_sys
:
:
*
;
assert_eq
!
(
cursor
.
kind
(
)
CXCursor_Namespace
"
Be
a
nice
person
"
)
;
let
cursor
=
cursor
.
canonical
(
)
;
if
let
Some
(
id
)
=
self
.
modules
.
get
(
&
cursor
)
{
return
*
id
;
}
let
(
module_name
kind
)
=
self
.
tokenize_namespace
(
&
cursor
)
;
let
module_id
=
self
.
next_item_id
(
)
;
let
module
=
Module
:
:
new
(
module_name
kind
)
;
let
module
=
Item
:
:
new
(
module_id
None
None
self
.
current_module
ItemKind
:
:
Module
(
module
)
)
;
self
.
modules
.
insert
(
cursor
module
.
id
(
)
)
;
self
.
add_item
(
module
None
None
)
;
module_id
}
pub
fn
with_module
<
F
>
(
&
mut
self
module_id
:
ItemId
cb
:
F
)
where
F
:
FnOnce
(
&
mut
Self
)
{
debug_assert
!
(
self
.
resolve_item
(
module_id
)
.
kind
(
)
.
is_module
(
)
"
Wat
"
)
;
let
previous_id
=
self
.
current_module
;
self
.
current_module
=
module_id
;
cb
(
self
)
;
self
.
current_module
=
previous_id
;
}
pub
fn
whitelisted_items
<
'
me
>
(
&
'
me
self
)
-
>
WhitelistedItemsIter
<
'
me
'
ctx
>
{
assert
!
(
self
.
in_codegen_phase
(
)
)
;
assert
!
(
self
.
current_module
=
=
self
.
root_module
)
;
let
roots
=
self
.
items
(
)
.
filter
(
|
&
(
_
item
)
|
{
if
self
.
options
(
)
.
whitelisted_types
.
is_empty
(
)
&
&
self
.
options
(
)
.
whitelisted_functions
.
is_empty
(
)
&
&
self
.
options
(
)
.
whitelisted_vars
.
is_empty
(
)
{
return
true
;
}
if
item
.
annotations
(
)
.
use_instead_of
(
)
.
is_some
(
)
{
return
true
;
}
let
name
=
item
.
canonical_path
(
self
)
[
1
.
.
]
.
join
(
"
:
:
"
)
;
debug
!
(
"
whitelisted_items
:
testing
{
:
?
}
"
name
)
;
match
*
item
.
kind
(
)
{
ItemKind
:
:
Module
(
.
.
)
=
>
true
ItemKind
:
:
Function
(
_
)
=
>
{
self
.
options
(
)
.
whitelisted_functions
.
matches
(
&
name
)
}
ItemKind
:
:
Var
(
_
)
=
>
{
self
.
options
(
)
.
whitelisted_vars
.
matches
(
&
name
)
}
ItemKind
:
:
Type
(
ref
ty
)
=
>
{
if
self
.
options
(
)
.
whitelisted_types
.
matches
(
&
name
)
{
return
true
;
}
let
parent
=
self
.
resolve_item
(
item
.
parent_id
(
)
)
;
if
parent
.
is_module
(
)
{
let
mut
prefix_path
=
parent
.
canonical_path
(
self
)
;
if
let
TypeKind
:
:
Enum
(
ref
enum_
)
=
*
ty
.
kind
(
)
{
if
ty
.
name
(
)
.
is_none
(
)
&
&
enum_
.
variants
(
)
.
iter
(
)
.
any
(
|
variant
|
{
prefix_path
.
push
(
variant
.
name
(
)
.
into
(
)
)
;
let
name
=
prefix_path
[
1
.
.
]
.
join
(
"
:
:
"
)
;
prefix_path
.
pop
(
)
.
unwrap
(
)
;
self
.
options
(
)
.
whitelisted_vars
.
matches
(
&
name
)
}
)
{
return
true
;
}
}
}
false
}
}
}
)
.
map
(
|
(
&
id
_
)
|
id
)
;
let
seen
:
ItemSet
=
roots
.
collect
(
)
;
let
to_iterate
=
seen
.
iter
(
)
.
cloned
(
)
.
rev
(
)
.
collect
(
)
;
WhitelistedItemsIter
{
ctx
:
self
seen
:
seen
to_iterate
:
to_iterate
}
}
pub
fn
trait_prefix
(
&
self
)
-
>
Ident
{
if
self
.
options
(
)
.
use_core
{
self
.
rust_ident_raw
(
"
core
"
)
}
else
{
self
.
rust_ident_raw
(
"
std
"
)
}
}
pub
fn
generated_bindegen_complex
(
&
self
)
{
self
.
generated_bindegen_complex
.
set
(
true
)
}
pub
fn
need_bindegen_complex_type
(
&
self
)
-
>
bool
{
self
.
generated_bindegen_complex
.
get
(
)
}
}
pub
struct
WhitelistedItemsIter
<
'
ctx
'
gen
>
where
'
gen
:
'
ctx
{
ctx
:
&
'
ctx
BindgenContext
<
'
gen
>
seen
:
ItemSet
to_iterate
:
Vec
<
ItemId
>
}
impl
<
'
ctx
'
gen
>
Iterator
for
WhitelistedItemsIter
<
'
ctx
'
gen
>
where
'
gen
:
'
ctx
{
type
Item
=
ItemId
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
id
=
match
self
.
to_iterate
.
pop
(
)
{
None
=
>
return
None
Some
(
id
)
=
>
id
}
;
debug_assert
!
(
self
.
seen
.
contains
(
&
id
)
)
;
debug_assert
!
(
self
.
ctx
.
items
.
contains_key
(
&
id
)
)
;
if
self
.
ctx
.
options
(
)
.
whitelist_recursively
{
let
mut
sub_types
=
ItemSet
:
:
new
(
)
;
id
.
collect_types
(
self
.
ctx
&
mut
sub_types
&
(
)
)
;
for
id
in
sub_types
{
if
self
.
seen
.
insert
(
id
)
{
self
.
to_iterate
.
push
(
id
)
;
}
}
}
Some
(
id
)
}
}
pub
struct
AssertNoDanglingItemIter
<
'
ctx
'
gen
>
where
'
gen
:
'
ctx
{
ctx
:
&
'
ctx
BindgenContext
<
'
gen
>
seen
:
BTreeMap
<
ItemId
ItemId
>
to_iterate
:
VecDeque
<
ItemId
>
}
impl
<
'
ctx
'
gen
>
Iterator
for
AssertNoDanglingItemIter
<
'
ctx
'
gen
>
where
'
gen
:
'
ctx
{
type
Item
=
ItemId
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
id
=
match
self
.
to_iterate
.
pop_front
(
)
{
None
=
>
{
match
self
.
ctx
.
items
(
)
.
filter
(
|
&
(
id
_
)
|
!
self
.
seen
.
contains_key
(
id
)
)
.
next
(
)
.
map
(
|
(
id
_
)
|
*
id
)
{
None
=
>
return
None
Some
(
id
)
=
>
{
self
.
seen
.
insert
(
id
id
)
;
id
}
}
}
Some
(
id
)
=
>
id
}
;
let
mut
sub_types
=
ItemSet
:
:
new
(
)
;
id
.
collect_types
(
self
.
ctx
&
mut
sub_types
&
(
)
)
;
if
self
.
ctx
.
resolve_item_fallible
(
id
)
.
is_none
(
)
{
let
mut
path
=
vec
!
[
]
;
let
mut
current
=
id
;
loop
{
let
predecessor
=
*
self
.
seen
.
get
(
&
current
)
.
expect
(
"
We
know
we
found
this
item
id
so
it
must
have
a
\
predecessor
"
)
;
if
predecessor
=
=
current
{
break
;
}
path
.
push
(
predecessor
)
;
current
=
predecessor
;
}
path
.
reverse
(
)
;
panic
!
(
"
Found
reference
to
dangling
id
=
{
:
?
}
\
nvia
path
=
{
:
?
}
"
id
path
)
;
}
for
sub_id
in
sub_types
{
if
self
.
seen
.
insert
(
sub_id
id
)
.
is_none
(
)
{
self
.
to_iterate
.
push_back
(
sub_id
)
;
}
}
Some
(
id
)
}
}
