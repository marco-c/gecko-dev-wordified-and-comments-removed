use
super
:
:
context
:
:
{
BindgenContext
ItemId
}
;
use
super
:
:
item
:
:
{
IsOpaque
Item
ItemAncestors
ItemCanonicalPath
}
;
use
super
:
:
traversal
:
:
{
EdgeKind
Trace
Tracer
}
;
use
clang
;
use
parse
:
:
ClangItemParser
;
pub
trait
TemplateParameters
{
fn
self_template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
;
fn
num_self_template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
usize
>
{
self
.
self_template_params
(
ctx
)
.
map
(
|
params
|
params
.
len
(
)
)
}
fn
all_template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
where
Self
:
ItemAncestors
{
let
each_self_params
:
Vec
<
Vec
<
_
>
>
=
self
.
ancestors
(
ctx
)
.
filter_map
(
|
id
|
id
.
self_template_params
(
ctx
)
)
.
collect
(
)
;
if
each_self_params
.
is_empty
(
)
{
None
}
else
{
Some
(
each_self_params
.
into_iter
(
)
.
rev
(
)
.
flat_map
(
|
params
|
params
)
.
collect
(
)
)
}
}
fn
used_template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
where
Self
:
AsRef
<
ItemId
>
{
assert
!
(
ctx
.
in_codegen_phase
(
)
"
template
parameter
usage
is
not
computed
until
codegen
"
)
;
let
id
=
*
self
.
as_ref
(
)
;
ctx
.
resolve_item
(
id
)
.
all_template_params
(
ctx
)
.
map
(
|
all_params
|
{
all_params
.
into_iter
(
)
.
filter
(
|
p
|
ctx
.
uses_template_parameter
(
id
*
p
)
)
.
collect
(
)
}
)
}
}
pub
trait
AsTemplateParam
{
type
Extra
;
fn
as_template_param
(
&
self
ctx
:
&
BindgenContext
extra
:
&
Self
:
:
Extra
)
-
>
Option
<
ItemId
>
;
fn
is_template_param
(
&
self
ctx
:
&
BindgenContext
extra
:
&
Self
:
:
Extra
)
-
>
bool
{
self
.
as_template_param
(
ctx
extra
)
.
is_some
(
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
TemplateInstantiation
{
definition
:
ItemId
args
:
Vec
<
ItemId
>
}
impl
TemplateInstantiation
{
pub
fn
new
<
I
>
(
template_definition
:
ItemId
template_args
:
I
)
-
>
TemplateInstantiation
where
I
:
IntoIterator
<
Item
=
ItemId
>
{
TemplateInstantiation
{
definition
:
template_definition
args
:
template_args
.
into_iter
(
)
.
collect
(
)
}
}
pub
fn
template_definition
(
&
self
)
-
>
ItemId
{
self
.
definition
}
pub
fn
template_arguments
(
&
self
)
-
>
&
[
ItemId
]
{
&
self
.
args
[
.
.
]
}
pub
fn
from_ty
(
ty
:
&
clang
:
:
Type
ctx
:
&
mut
BindgenContext
)
-
>
Option
<
TemplateInstantiation
>
{
use
clang_sys
:
:
*
;
let
template_args
=
ty
.
template_args
(
)
.
map_or
(
vec
!
[
]
|
args
|
{
match
ty
.
canonical_type
(
)
.
template_args
(
)
{
Some
(
canonical_args
)
=
>
{
let
arg_count
=
args
.
len
(
)
;
args
.
chain
(
canonical_args
.
skip
(
arg_count
)
)
.
filter
(
|
t
|
t
.
kind
(
)
!
=
CXType_Invalid
)
.
map
(
|
t
|
{
Item
:
:
from_ty_or_ref
(
t
t
.
declaration
(
)
None
ctx
)
}
)
.
collect
(
)
}
None
=
>
{
args
.
filter
(
|
t
|
t
.
kind
(
)
!
=
CXType_Invalid
)
.
map
(
|
t
|
{
Item
:
:
from_ty_or_ref
(
t
t
.
declaration
(
)
None
ctx
)
}
)
.
collect
(
)
}
}
}
)
;
let
declaration
=
ty
.
declaration
(
)
;
let
definition
=
if
declaration
.
kind
(
)
=
=
CXCursor_TypeAliasTemplateDecl
{
Some
(
declaration
)
}
else
{
declaration
.
specialized
(
)
.
or_else
(
|
|
{
let
mut
template_ref
=
None
;
ty
.
declaration
(
)
.
visit
(
|
child
|
{
if
child
.
kind
(
)
=
=
CXCursor_TemplateRef
{
template_ref
=
Some
(
child
)
;
return
CXVisit_Break
;
}
CXChildVisit_Recurse
}
)
;
template_ref
.
and_then
(
|
cur
|
cur
.
referenced
(
)
)
}
)
}
;
let
definition
=
match
definition
{
Some
(
def
)
=
>
def
None
=
>
{
if
!
ty
.
declaration
(
)
.
is_builtin
(
)
{
warn
!
(
"
Could
not
find
template
definition
for
template
\
instantiation
"
)
;
}
return
None
;
}
}
;
let
template_definition
=
Item
:
:
from_ty_or_ref
(
definition
.
cur_type
(
)
definition
None
ctx
)
;
Some
(
TemplateInstantiation
:
:
new
(
template_definition
template_args
)
)
}
}
impl
IsOpaque
for
TemplateInstantiation
{
type
Extra
=
Item
;
fn
is_opaque
(
&
self
ctx
:
&
BindgenContext
item
:
&
Item
)
-
>
bool
{
if
self
.
template_definition
(
)
.
is_opaque
(
ctx
&
(
)
)
{
return
true
;
}
let
mut
path
=
item
.
canonical_path
(
ctx
)
;
let
args
:
Vec
<
_
>
=
self
.
template_arguments
(
)
.
iter
(
)
.
map
(
|
arg
|
{
let
arg_path
=
arg
.
canonical_path
(
ctx
)
;
arg_path
[
1
.
.
]
.
join
(
"
:
:
"
)
}
)
.
collect
(
)
;
{
let
last
=
path
.
last_mut
(
)
.
unwrap
(
)
;
last
.
push
(
'
<
'
)
;
last
.
push_str
(
&
args
.
join
(
"
"
)
)
;
last
.
push
(
'
>
'
)
;
}
ctx
.
opaque_by_name
(
&
path
)
}
}
impl
Trace
for
TemplateInstantiation
{
type
Extra
=
(
)
;
fn
trace
<
T
>
(
&
self
_ctx
:
&
BindgenContext
tracer
:
&
mut
T
_
:
&
(
)
)
where
T
:
Tracer
{
tracer
.
visit_kind
(
self
.
definition
EdgeKind
:
:
TemplateDeclaration
)
;
for
&
item
in
self
.
template_arguments
(
)
{
tracer
.
visit_kind
(
item
EdgeKind
:
:
TemplateArgument
)
;
}
}
}
