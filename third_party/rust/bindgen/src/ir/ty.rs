use
super
:
:
comp
:
:
CompInfo
;
use
super
:
:
context
:
:
{
BindgenContext
ItemId
}
;
use
super
:
:
derive
:
:
{
CanDeriveCopy
CanDeriveDebug
CanDeriveDefault
}
;
use
super
:
:
enum_ty
:
:
Enum
;
use
super
:
:
function
:
:
FunctionSig
;
use
super
:
:
int
:
:
IntKind
;
use
super
:
:
item
:
:
Item
;
use
super
:
:
layout
:
:
Layout
;
use
super
:
:
objc
:
:
ObjCInterface
;
use
super
:
:
traversal
:
:
{
Trace
Tracer
}
;
use
clang
:
:
{
self
Cursor
}
;
use
parse
:
:
{
ClangItemParser
ParseError
ParseResult
}
;
use
std
:
:
mem
;
pub
trait
TemplateDeclaration
{
fn
template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
;
fn
num_template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
usize
>
{
self
.
template_params
(
ctx
)
.
map
(
|
params
|
params
.
len
(
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Type
{
name
:
Option
<
String
>
layout
:
Option
<
Layout
>
kind
:
TypeKind
is_const
:
bool
}
pub
const
RUST_DERIVE_IN_ARRAY_LIMIT
:
usize
=
32
;
impl
Type
{
pub
fn
as_comp
(
&
self
)
-
>
Option
<
&
CompInfo
>
{
match
self
.
kind
{
TypeKind
:
:
Comp
(
ref
ci
)
=
>
Some
(
ci
)
_
=
>
None
}
}
pub
fn
new
(
name
:
Option
<
String
>
layout
:
Option
<
Layout
>
kind
:
TypeKind
is_const
:
bool
)
-
>
Self
{
Type
{
name
:
name
layout
:
layout
kind
:
kind
is_const
:
is_const
}
}
pub
fn
kind
(
&
self
)
-
>
&
TypeKind
{
&
self
.
kind
}
pub
fn
kind_mut
(
&
mut
self
)
-
>
&
mut
TypeKind
{
&
mut
self
.
kind
}
pub
fn
name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
name
.
as_ref
(
)
.
map
(
|
name
|
&
*
*
name
)
}
pub
fn
is_comp
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Comp
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_named
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Named
=
>
true
_
=
>
false
}
}
pub
fn
is_template_alias
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
TemplateAlias
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_function
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Function
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_enum
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Enum
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_builtin_or_named
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Void
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
Function
(
.
.
)
|
TypeKind
:
:
Array
(
.
.
)
|
TypeKind
:
:
Reference
(
.
.
)
|
TypeKind
:
:
Pointer
(
.
.
)
|
TypeKind
:
:
BlockPointer
|
TypeKind
:
:
Int
(
.
.
)
|
TypeKind
:
:
Float
(
.
.
)
|
TypeKind
:
:
Named
=
>
true
_
=
>
false
}
}
pub
fn
named
(
name
:
String
)
-
>
Self
{
assert
!
(
!
name
.
is_empty
(
)
)
;
Self
:
:
new
(
Some
(
name
)
None
TypeKind
:
:
Named
false
)
}
pub
fn
is_float
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Float
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_bool
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Int
(
IntKind
:
:
Bool
)
=
>
true
_
=
>
false
}
}
pub
fn
is_integer
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Int
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_const
(
&
self
)
-
>
bool
{
self
.
is_const
}
pub
fn
is_type_ref
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
ResolvedTypeRef
(
_
)
|
TypeKind
:
:
UnresolvedTypeRef
(
_
_
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_incomplete_array
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
ItemId
>
{
match
self
.
kind
{
TypeKind
:
:
Array
(
item
len
)
=
>
{
if
len
=
=
0
{
Some
(
item
)
}
else
{
None
}
}
TypeKind
:
:
ResolvedTypeRef
(
inner
)
=
>
{
ctx
.
resolve_type
(
inner
)
.
is_incomplete_array
(
ctx
)
}
_
=
>
None
}
}
pub
fn
layout
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Layout
>
{
use
std
:
:
mem
;
self
.
layout
.
or_else
(
|
|
{
match
self
.
kind
{
TypeKind
:
:
Comp
(
ref
ci
)
=
>
ci
.
layout
(
ctx
)
TypeKind
:
:
Pointer
(
.
.
)
|
TypeKind
:
:
BlockPointer
=
>
{
Some
(
Layout
:
:
new
(
mem
:
:
size_of
:
:
<
*
mut
(
)
>
(
)
mem
:
:
align_of
:
:
<
*
mut
(
)
>
(
)
)
)
}
TypeKind
:
:
ResolvedTypeRef
(
inner
)
=
>
{
ctx
.
resolve_type
(
inner
)
.
layout
(
ctx
)
}
_
=
>
None
}
}
)
}
pub
fn
has_vtable
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
TemplateInstantiation
(
t
_
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
|
TypeKind
:
:
ResolvedTypeRef
(
t
)
=
>
ctx
.
resolve_type
(
t
)
.
has_vtable
(
ctx
)
TypeKind
:
:
Comp
(
ref
info
)
=
>
info
.
has_vtable
(
ctx
)
_
=
>
false
}
}
pub
fn
has_destructor
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
TemplateInstantiation
(
t
_
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
|
TypeKind
:
:
ResolvedTypeRef
(
t
)
=
>
{
ctx
.
resolve_type
(
t
)
.
has_destructor
(
ctx
)
}
TypeKind
:
:
Comp
(
ref
info
)
=
>
info
.
has_destructor
(
ctx
)
_
=
>
false
}
}
pub
fn
signature_contains_named_type
(
&
self
ctx
:
&
BindgenContext
ty
:
&
Type
)
-
>
bool
{
let
name
=
match
*
ty
.
kind
(
)
{
TypeKind
:
:
Named
=
>
ty
.
name
(
)
ref
other
_
=
>
unreachable
!
(
"
Not
a
named
type
:
{
:
?
}
"
other
)
}
;
match
self
.
kind
{
TypeKind
:
:
Named
=
>
self
.
name
(
)
=
=
name
TypeKind
:
:
ResolvedTypeRef
(
t
)
|
TypeKind
:
:
Array
(
t
_
)
|
TypeKind
:
:
Pointer
(
t
)
|
TypeKind
:
:
Alias
(
t
)
=
>
{
ctx
.
resolve_type
(
t
)
.
signature_contains_named_type
(
ctx
ty
)
}
TypeKind
:
:
Function
(
ref
sig
)
=
>
{
sig
.
argument_types
(
)
.
iter
(
)
.
any
(
|
&
(
_
arg
)
|
{
ctx
.
resolve_type
(
arg
)
.
signature_contains_named_type
(
ctx
ty
)
}
)
|
|
ctx
.
resolve_type
(
sig
.
return_type
(
)
)
.
signature_contains_named_type
(
ctx
ty
)
}
TypeKind
:
:
TemplateAlias
(
_
ref
template_args
)
|
TypeKind
:
:
TemplateInstantiation
(
_
ref
template_args
)
=
>
{
template_args
.
iter
(
)
.
any
(
|
arg
|
{
ctx
.
resolve_type
(
*
arg
)
.
signature_contains_named_type
(
ctx
ty
)
}
)
}
TypeKind
:
:
Comp
(
ref
ci
)
=
>
ci
.
signature_contains_named_type
(
ctx
ty
)
_
=
>
false
}
}
pub
fn
is_invalid_named_type
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Named
=
>
{
let
name
=
self
.
name
(
)
.
expect
(
"
Unnamed
named
type
?
"
)
;
!
Self
:
:
is_valid_identifier
(
&
name
)
}
_
=
>
false
}
}
pub
fn
is_valid_identifier
(
name
:
&
str
)
-
>
bool
{
let
mut
chars
=
name
.
chars
(
)
;
let
first_valid
=
chars
.
next
(
)
.
map
(
|
c
|
c
.
is_alphabetic
(
)
|
|
c
=
=
'
_
'
)
.
unwrap_or
(
false
)
;
first_valid
&
&
chars
.
all
(
|
c
|
c
.
is_alphanumeric
(
)
|
|
c
=
=
'
_
'
)
}
pub
fn
canonical_type
<
'
tr
>
(
&
'
tr
self
ctx
:
&
'
tr
BindgenContext
)
-
>
&
'
tr
Type
{
self
.
safe_canonical_type
(
ctx
)
.
expect
(
"
Should
have
been
resolved
after
parsing
!
"
)
}
pub
fn
safe_canonical_type
<
'
tr
>
(
&
'
tr
self
ctx
:
&
'
tr
BindgenContext
)
-
>
Option
<
&
'
tr
Type
>
{
match
self
.
kind
{
TypeKind
:
:
Named
|
TypeKind
:
:
Array
(
.
.
)
|
TypeKind
:
:
Comp
(
.
.
)
|
TypeKind
:
:
Int
(
.
.
)
|
TypeKind
:
:
Float
(
.
.
)
|
TypeKind
:
:
Complex
(
.
.
)
|
TypeKind
:
:
Function
(
.
.
)
|
TypeKind
:
:
Enum
(
.
.
)
|
TypeKind
:
:
Reference
(
.
.
)
|
TypeKind
:
:
Void
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
BlockPointer
|
TypeKind
:
:
Pointer
(
.
.
)
|
TypeKind
:
:
ObjCInterface
(
.
.
)
=
>
Some
(
self
)
TypeKind
:
:
ResolvedTypeRef
(
inner
)
|
TypeKind
:
:
Alias
(
inner
)
|
TypeKind
:
:
TemplateAlias
(
inner
_
)
|
TypeKind
:
:
TemplateInstantiation
(
inner
_
)
=
>
{
ctx
.
resolve_type
(
inner
)
.
safe_canonical_type
(
ctx
)
}
TypeKind
:
:
UnresolvedTypeRef
(
.
.
)
=
>
None
}
}
pub
fn
should_be_traced_unconditionally
(
&
self
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Function
(
.
.
)
|
TypeKind
:
:
Pointer
(
.
.
)
|
TypeKind
:
:
Array
(
.
.
)
|
TypeKind
:
:
Reference
(
.
.
)
|
TypeKind
:
:
TemplateInstantiation
(
.
.
)
|
TypeKind
:
:
ResolvedTypeRef
(
.
.
)
=
>
true
_
=
>
false
}
}
}
#
[
test
]
fn
is_invalid_named_type_valid
(
)
{
let
ty
=
Type
:
:
new
(
Some
(
"
foo
"
.
into
(
)
)
None
TypeKind
:
:
Named
false
)
;
assert
!
(
!
ty
.
is_invalid_named_type
(
)
)
}
#
[
test
]
fn
is_invalid_named_type_valid_underscore_and_numbers
(
)
{
let
ty
=
Type
:
:
new
(
Some
(
"
_foo123456789_
"
.
into
(
)
)
None
TypeKind
:
:
Named
false
)
;
assert
!
(
!
ty
.
is_invalid_named_type
(
)
)
}
#
[
test
]
fn
is_invalid_named_type_valid_unnamed_kind
(
)
{
let
ty
=
Type
:
:
new
(
Some
(
"
foo
"
.
into
(
)
)
None
TypeKind
:
:
Void
false
)
;
assert
!
(
!
ty
.
is_invalid_named_type
(
)
)
}
#
[
test
]
fn
is_invalid_named_type_invalid_start
(
)
{
let
ty
=
Type
:
:
new
(
Some
(
"
1foo
"
.
into
(
)
)
None
TypeKind
:
:
Named
false
)
;
assert
!
(
ty
.
is_invalid_named_type
(
)
)
}
#
[
test
]
fn
is_invalid_named_type_invalid_remaing
(
)
{
let
ty
=
Type
:
:
new
(
Some
(
"
foo
-
"
.
into
(
)
)
None
TypeKind
:
:
Named
false
)
;
assert
!
(
ty
.
is_invalid_named_type
(
)
)
}
#
[
test
]
#
[
should_panic
]
fn
is_invalid_named_type_unnamed
(
)
{
let
ty
=
Type
:
:
new
(
None
None
TypeKind
:
:
Named
false
)
;
assert
!
(
ty
.
is_invalid_named_type
(
)
)
}
#
[
test
]
fn
is_invalid_named_type_empty_name
(
)
{
let
ty
=
Type
:
:
new
(
Some
(
"
"
.
into
(
)
)
None
TypeKind
:
:
Named
false
)
;
assert
!
(
ty
.
is_invalid_named_type
(
)
)
}
impl
TemplateDeclaration
for
Type
{
fn
template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
{
self
.
kind
.
template_params
(
ctx
)
}
}
impl
TemplateDeclaration
for
TypeKind
{
fn
template_params
(
&
self
ctx
:
&
BindgenContext
)
-
>
Option
<
Vec
<
ItemId
>
>
{
match
*
self
{
TypeKind
:
:
ResolvedTypeRef
(
id
)
=
>
{
ctx
.
resolve_type
(
id
)
.
template_params
(
ctx
)
}
TypeKind
:
:
Comp
(
ref
comp
)
=
>
comp
.
template_params
(
ctx
)
TypeKind
:
:
TemplateAlias
(
_
ref
args
)
=
>
Some
(
args
.
clone
(
)
)
TypeKind
:
:
TemplateInstantiation
(
.
.
)
|
TypeKind
:
:
Void
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
Int
(
_
)
|
TypeKind
:
:
Float
(
_
)
|
TypeKind
:
:
Complex
(
_
)
|
TypeKind
:
:
Array
(
.
.
)
|
TypeKind
:
:
Function
(
_
)
|
TypeKind
:
:
Enum
(
_
)
|
TypeKind
:
:
Pointer
(
_
)
|
TypeKind
:
:
BlockPointer
|
TypeKind
:
:
Reference
(
_
)
|
TypeKind
:
:
UnresolvedTypeRef
(
.
.
)
|
TypeKind
:
:
Named
|
TypeKind
:
:
Alias
(
_
)
|
TypeKind
:
:
ObjCInterface
(
_
)
=
>
None
}
}
}
impl
CanDeriveDebug
for
Type
{
type
Extra
=
(
)
;
fn
can_derive_debug
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Array
(
t
len
)
=
>
{
len
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
&
&
t
.
can_derive_debug
(
ctx
(
)
)
}
TypeKind
:
:
ResolvedTypeRef
(
t
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
=
>
t
.
can_derive_debug
(
ctx
(
)
)
TypeKind
:
:
Comp
(
ref
info
)
=
>
{
info
.
can_derive_debug
(
ctx
self
.
layout
(
ctx
)
)
}
_
=
>
true
}
}
}
impl
CanDeriveDefault
for
Type
{
type
Extra
=
(
)
;
fn
can_derive_default
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Array
(
t
len
)
=
>
{
len
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
&
&
t
.
can_derive_default
(
ctx
(
)
)
}
TypeKind
:
:
ResolvedTypeRef
(
t
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
=
>
t
.
can_derive_default
(
ctx
(
)
)
TypeKind
:
:
Comp
(
ref
info
)
=
>
{
info
.
can_derive_default
(
ctx
self
.
layout
(
ctx
)
)
}
TypeKind
:
:
Void
|
TypeKind
:
:
Named
|
TypeKind
:
:
TemplateInstantiation
(
.
.
)
|
TypeKind
:
:
Reference
(
.
.
)
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
Pointer
(
.
.
)
|
TypeKind
:
:
BlockPointer
|
TypeKind
:
:
ObjCInterface
(
.
.
)
|
TypeKind
:
:
Enum
(
.
.
)
=
>
false
TypeKind
:
:
Function
(
.
.
)
|
TypeKind
:
:
Int
(
.
.
)
|
TypeKind
:
:
Float
(
.
.
)
|
TypeKind
:
:
Complex
(
.
.
)
=
>
true
TypeKind
:
:
UnresolvedTypeRef
(
.
.
)
=
>
unreachable
!
(
)
}
}
}
impl
<
'
a
>
CanDeriveCopy
<
'
a
>
for
Type
{
type
Extra
=
&
'
a
Item
;
fn
can_derive_copy
(
&
self
ctx
:
&
BindgenContext
item
:
&
Item
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
Array
(
t
len
)
=
>
{
len
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
&
&
t
.
can_derive_copy_in_array
(
ctx
(
)
)
}
TypeKind
:
:
ResolvedTypeRef
(
t
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
TemplateInstantiation
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
=
>
t
.
can_derive_copy
(
ctx
(
)
)
TypeKind
:
:
Comp
(
ref
info
)
=
>
{
info
.
can_derive_copy
(
ctx
(
item
self
.
layout
(
ctx
)
)
)
}
_
=
>
true
}
}
fn
can_derive_copy_in_array
(
&
self
ctx
:
&
BindgenContext
item
:
&
Item
)
-
>
bool
{
match
self
.
kind
{
TypeKind
:
:
ResolvedTypeRef
(
t
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
|
TypeKind
:
:
Array
(
t
_
)
=
>
t
.
can_derive_copy_in_array
(
ctx
(
)
)
TypeKind
:
:
Named
=
>
false
_
=
>
self
.
can_derive_copy
(
ctx
item
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
FloatKind
{
Float
Double
LongDouble
Float128
}
impl
FloatKind
{
pub
fn
known_size
(
&
self
)
-
>
usize
{
match
*
self
{
FloatKind
:
:
Float
=
>
mem
:
:
size_of
:
:
<
f32
>
(
)
FloatKind
:
:
Double
|
FloatKind
:
:
LongDouble
=
>
mem
:
:
size_of
:
:
<
f64
>
(
)
FloatKind
:
:
Float128
=
>
mem
:
:
size_of
:
:
<
f64
>
(
)
*
2
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
TypeKind
{
Void
NullPtr
Comp
(
CompInfo
)
Int
(
IntKind
)
Float
(
FloatKind
)
Complex
(
FloatKind
)
Alias
(
ItemId
)
TemplateAlias
(
ItemId
Vec
<
ItemId
>
)
Array
(
ItemId
usize
)
Function
(
FunctionSig
)
Enum
(
Enum
)
Pointer
(
ItemId
)
BlockPointer
Reference
(
ItemId
)
TemplateInstantiation
(
ItemId
Vec
<
ItemId
>
)
UnresolvedTypeRef
(
clang
:
:
Type
Option
<
clang
:
:
Cursor
>
Option
<
ItemId
>
)
ResolvedTypeRef
(
ItemId
)
Named
ObjCInterface
(
ObjCInterface
)
}
impl
Type
{
pub
fn
is_unsized
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
{
debug_assert
!
(
ctx
.
in_codegen_phase
(
)
"
Not
yet
"
)
;
match
self
.
kind
{
TypeKind
:
:
Void
=
>
true
TypeKind
:
:
Comp
(
ref
ci
)
=
>
ci
.
is_unsized
(
ctx
)
TypeKind
:
:
Array
(
inner
size
)
=
>
{
size
=
=
0
|
|
ctx
.
resolve_type
(
inner
)
.
is_unsized
(
ctx
)
}
TypeKind
:
:
ResolvedTypeRef
(
inner
)
|
TypeKind
:
:
Alias
(
inner
)
|
TypeKind
:
:
TemplateAlias
(
inner
_
)
|
TypeKind
:
:
TemplateInstantiation
(
inner
_
)
=
>
{
ctx
.
resolve_type
(
inner
)
.
is_unsized
(
ctx
)
}
TypeKind
:
:
Named
|
TypeKind
:
:
Int
(
.
.
)
|
TypeKind
:
:
Float
(
.
.
)
|
TypeKind
:
:
Complex
(
.
.
)
|
TypeKind
:
:
Function
(
.
.
)
|
TypeKind
:
:
Enum
(
.
.
)
|
TypeKind
:
:
Reference
(
.
.
)
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
BlockPointer
|
TypeKind
:
:
Pointer
(
.
.
)
=
>
false
TypeKind
:
:
ObjCInterface
(
.
.
)
=
>
true
TypeKind
:
:
UnresolvedTypeRef
(
.
.
)
=
>
{
unreachable
!
(
"
Should
have
been
resolved
after
parsing
!
"
)
;
}
}
}
pub
fn
from_clang_ty
(
potential_id
:
ItemId
ty
:
&
clang
:
:
Type
location
:
Option
<
Cursor
>
parent_id
:
Option
<
ItemId
>
ctx
:
&
mut
BindgenContext
)
-
>
Result
<
ParseResult
<
Self
>
ParseError
>
{
use
clang_sys
:
:
*
;
{
let
already_resolved
=
ctx
.
builtin_or_resolved_ty
(
potential_id
parent_id
ty
location
)
;
if
let
Some
(
ty
)
=
already_resolved
{
debug
!
(
"
{
:
?
}
already
resolved
:
{
:
?
}
"
ty
location
)
;
return
Ok
(
ParseResult
:
:
AlreadyResolved
(
ty
)
)
;
}
}
let
layout
=
ty
.
fallible_layout
(
)
.
ok
(
)
;
let
cursor
=
ty
.
declaration
(
)
;
let
mut
name
=
cursor
.
spelling
(
)
;
debug
!
(
"
from_clang_ty
:
{
:
?
}
ty
:
{
:
?
}
loc
:
{
:
?
}
"
potential_id
ty
location
)
;
debug
!
(
"
currently_parsed_types
:
{
:
?
}
"
ctx
.
currently_parsed_types
(
)
)
;
let
canonical_ty
=
ty
.
canonical_type
(
)
;
let
mut
ty_kind
=
ty
.
kind
(
)
;
if
let
Some
(
loc
)
=
location
{
if
loc
.
kind
(
)
=
=
CXCursor_ObjCProtocolDecl
{
ty_kind
=
CXType_ObjCInterface
;
}
}
let
kind
=
match
ty_kind
{
CXType_Unexposed
if
*
ty
!
=
canonical_ty
&
&
canonical_ty
.
kind
(
)
!
=
CXType_Invalid
&
&
!
canonical_ty
.
spelling
(
)
.
contains
(
"
type
-
parameter
"
)
=
>
{
debug
!
(
"
Looking
for
canonical
type
:
{
:
?
}
"
canonical_ty
)
;
return
Self
:
:
from_clang_ty
(
potential_id
&
canonical_ty
location
parent_id
ctx
)
;
}
CXType_Unexposed
|
CXType_Invalid
=
>
{
if
ty
.
ret_type
(
)
.
is_some
(
)
{
let
signature
=
try
!
(
FunctionSig
:
:
from_ty
(
ty
&
location
.
unwrap_or
(
cursor
)
ctx
)
)
;
TypeKind
:
:
Function
(
signature
)
}
else
if
ty
.
is_fully_specialized_template
(
)
{
debug
!
(
"
Template
specialization
:
{
:
?
}
{
:
?
}
{
:
?
}
"
ty
location
canonical_ty
)
;
let
complex
=
CompInfo
:
:
from_ty
(
potential_id
ty
location
ctx
)
.
expect
(
"
C
'
mon
"
)
;
TypeKind
:
:
Comp
(
complex
)
}
else
if
let
Some
(
location
)
=
location
{
match
location
.
kind
(
)
{
CXCursor_ClassTemplatePartialSpecialization
|
CXCursor_CXXBaseSpecifier
|
CXCursor_ClassTemplate
=
>
{
if
location
.
kind
(
)
=
=
CXCursor_CXXBaseSpecifier
{
if
location
.
spelling
(
)
.
chars
(
)
.
all
(
|
c
|
c
.
is_alphanumeric
(
)
|
|
c
=
=
'
_
'
)
{
return
Err
(
ParseError
:
:
Recurse
)
;
}
}
else
{
name
=
location
.
spelling
(
)
;
}
let
complex
=
CompInfo
:
:
from_ty
(
potential_id
ty
Some
(
location
)
ctx
)
.
expect
(
"
C
'
mon
"
)
;
TypeKind
:
:
Comp
(
complex
)
}
CXCursor_TypeAliasTemplateDecl
=
>
{
debug
!
(
"
TypeAliasTemplateDecl
"
)
;
let
mut
inner
=
Err
(
ParseError
:
:
Continue
)
;
let
mut
args
=
vec
!
[
]
;
location
.
visit
(
|
cur
|
{
match
cur
.
kind
(
)
{
CXCursor_TypeAliasDecl
=
>
{
let
current
=
cur
.
cur_type
(
)
;
debug_assert
!
(
current
.
kind
(
)
=
=
CXType_Typedef
)
;
name
=
current
.
spelling
(
)
;
let
inner_ty
=
cur
.
typedef_type
(
)
.
expect
(
"
Not
valid
Type
?
"
)
;
inner
=
Item
:
:
from_ty
(
&
inner_ty
Some
(
cur
)
Some
(
potential_id
)
ctx
)
;
}
CXCursor_TemplateTypeParameter
=
>
{
if
cur
.
spelling
(
)
.
is_empty
(
)
{
return
CXChildVisit_Continue
;
}
let
param
=
Item
:
:
named_type
(
cur
.
spelling
(
)
potential_id
ctx
)
;
args
.
push
(
param
)
;
}
_
=
>
{
}
}
CXChildVisit_Continue
}
)
;
let
inner_type
=
match
inner
{
Ok
(
inner
)
=
>
inner
Err
(
.
.
)
=
>
{
error
!
(
"
Failed
to
parse
template
alias
\
{
:
?
}
"
location
)
;
return
Err
(
ParseError
:
:
Continue
)
;
}
}
;
TypeKind
:
:
TemplateAlias
(
inner_type
args
)
}
CXCursor_TemplateRef
=
>
{
let
referenced
=
location
.
referenced
(
)
.
unwrap
(
)
;
let
referenced_ty
=
referenced
.
cur_type
(
)
;
debug
!
(
"
TemplateRef
:
location
=
{
:
?
}
;
referenced
=
\
{
:
?
}
;
referenced_ty
=
{
:
?
}
"
location
referenced
referenced_ty
)
;
return
Self
:
:
from_clang_ty
(
potential_id
&
referenced_ty
Some
(
referenced
)
parent_id
ctx
)
;
}
CXCursor_TypeRef
=
>
{
let
referenced
=
location
.
referenced
(
)
.
unwrap
(
)
;
let
referenced_ty
=
referenced
.
cur_type
(
)
;
let
declaration
=
referenced_ty
.
declaration
(
)
;
debug
!
(
"
TypeRef
:
location
=
{
:
?
}
;
referenced
=
\
{
:
?
}
;
referenced_ty
=
{
:
?
}
"
location
referenced
referenced_ty
)
;
let
item
=
Item
:
:
from_ty_or_ref_with_id
(
potential_id
referenced_ty
Some
(
declaration
)
parent_id
ctx
)
;
return
Ok
(
ParseResult
:
:
AlreadyResolved
(
item
)
)
;
}
CXCursor_NamespaceRef
=
>
{
return
Err
(
ParseError
:
:
Continue
)
;
}
_
=
>
{
if
ty
.
kind
(
)
=
=
CXType_Unexposed
{
warn
!
(
"
Unexposed
type
{
:
?
}
recursing
inside
\
loc
:
{
:
?
}
"
ty
location
)
;
return
Err
(
ParseError
:
:
Recurse
)
;
}
if
!
ty
.
spelling
(
)
.
is_empty
(
)
{
warn
!
(
"
invalid
type
{
:
?
}
"
ty
)
;
}
else
{
warn
!
(
"
invalid
type
{
:
?
}
"
ty
)
;
}
return
Err
(
ParseError
:
:
Continue
)
;
}
}
}
else
{
if
ty
.
kind
(
)
=
=
CXType_Unexposed
{
warn
!
(
"
Unexposed
type
{
:
?
}
recursing
inside
"
ty
)
;
return
Err
(
ParseError
:
:
Recurse
)
;
}
if
!
ty
.
spelling
(
)
.
is_empty
(
)
{
warn
!
(
"
invalid
type
{
:
?
}
"
ty
)
;
}
else
{
warn
!
(
"
invalid
type
{
:
?
}
"
ty
)
;
}
return
Err
(
ParseError
:
:
Continue
)
;
}
}
CXType_Auto
=
>
{
if
canonical_ty
=
=
*
ty
{
debug
!
(
"
Couldn
'
t
find
deduced
type
:
{
:
?
}
"
ty
)
;
return
Err
(
ParseError
:
:
Continue
)
;
}
return
Self
:
:
from_clang_ty
(
potential_id
&
canonical_ty
location
parent_id
ctx
)
;
}
CXType_ObjCObjectPointer
|
CXType_MemberPointer
|
CXType_Pointer
=
>
{
let
inner
=
Item
:
:
from_ty_or_ref
(
ty
.
pointee_type
(
)
.
unwrap
(
)
location
None
ctx
)
;
TypeKind
:
:
Pointer
(
inner
)
}
CXType_BlockPointer
=
>
TypeKind
:
:
BlockPointer
CXType_RValueReference
|
CXType_LValueReference
=
>
{
let
inner
=
Item
:
:
from_ty_or_ref
(
ty
.
pointee_type
(
)
.
unwrap
(
)
location
None
ctx
)
;
TypeKind
:
:
Reference
(
inner
)
}
CXType_VariableArray
|
CXType_DependentSizedArray
=
>
{
let
inner
=
Item
:
:
from_ty
(
ty
.
elem_type
(
)
.
as_ref
(
)
.
unwrap
(
)
location
None
ctx
)
.
expect
(
"
Not
able
to
resolve
array
element
?
"
)
;
TypeKind
:
:
Pointer
(
inner
)
}
CXType_IncompleteArray
=
>
{
let
inner
=
Item
:
:
from_ty
(
ty
.
elem_type
(
)
.
as_ref
(
)
.
unwrap
(
)
location
None
ctx
)
.
expect
(
"
Not
able
to
resolve
array
element
?
"
)
;
TypeKind
:
:
Array
(
inner
0
)
}
CXType_FunctionNoProto
|
CXType_FunctionProto
=
>
{
let
signature
=
try
!
(
FunctionSig
:
:
from_ty
(
ty
&
location
.
unwrap_or
(
cursor
)
ctx
)
)
;
TypeKind
:
:
Function
(
signature
)
}
CXType_Typedef
=
>
{
let
inner
=
cursor
.
typedef_type
(
)
.
expect
(
"
Not
valid
Type
?
"
)
;
let
inner
=
Item
:
:
from_ty_or_ref
(
inner
location
None
ctx
)
;
TypeKind
:
:
Alias
(
inner
)
}
CXType_Enum
=
>
{
let
enum_
=
Enum
:
:
from_ty
(
ty
ctx
)
.
expect
(
"
Not
an
enum
?
"
)
;
if
name
.
is_empty
(
)
{
let
pretty_name
=
ty
.
spelling
(
)
;
if
Self
:
:
is_valid_identifier
(
&
pretty_name
)
{
name
=
pretty_name
;
}
}
TypeKind
:
:
Enum
(
enum_
)
}
CXType_Record
=
>
{
let
complex
=
CompInfo
:
:
from_ty
(
potential_id
ty
location
ctx
)
.
expect
(
"
Not
a
complex
type
?
"
)
;
if
name
.
is_empty
(
)
{
let
pretty_name
=
ty
.
spelling
(
)
;
if
Self
:
:
is_valid_identifier
(
&
pretty_name
)
{
name
=
pretty_name
;
}
}
TypeKind
:
:
Comp
(
complex
)
}
CXType_Vector
|
CXType_ConstantArray
=
>
{
let
inner
=
Item
:
:
from_ty
(
ty
.
elem_type
(
)
.
as_ref
(
)
.
unwrap
(
)
location
None
ctx
)
.
expect
(
"
Not
able
to
resolve
array
element
?
"
)
;
TypeKind
:
:
Array
(
inner
ty
.
num_elements
(
)
.
unwrap
(
)
)
}
CXType_Elaborated
=
>
{
return
Self
:
:
from_clang_ty
(
potential_id
&
ty
.
named
(
)
location
parent_id
ctx
)
;
}
CXType_ObjCInterface
=
>
{
let
interface
=
ObjCInterface
:
:
from_ty
(
&
location
.
unwrap
(
)
ctx
)
.
expect
(
"
Not
a
valid
objc
interface
?
"
)
;
TypeKind
:
:
ObjCInterface
(
interface
)
}
_
=
>
{
error
!
(
"
unsupported
type
:
kind
=
{
:
?
}
;
ty
=
{
:
?
}
;
at
{
:
?
}
"
ty
.
kind
(
)
ty
location
)
;
return
Err
(
ParseError
:
:
Continue
)
;
}
}
;
let
name
=
if
name
.
is_empty
(
)
{
None
}
else
{
Some
(
name
)
}
;
let
is_const
=
ty
.
is_const
(
)
;
let
ty
=
Type
:
:
new
(
name
layout
kind
is_const
)
;
Ok
(
ParseResult
:
:
New
(
ty
Some
(
cursor
.
canonical
(
)
)
)
)
}
}
impl
Trace
for
Type
{
type
Extra
=
Item
;
fn
trace
<
T
>
(
&
self
context
:
&
BindgenContext
tracer
:
&
mut
T
item
:
&
Item
)
where
T
:
Tracer
{
match
*
self
.
kind
(
)
{
TypeKind
:
:
Pointer
(
inner
)
|
TypeKind
:
:
Reference
(
inner
)
|
TypeKind
:
:
Array
(
inner
_
)
|
TypeKind
:
:
Alias
(
inner
)
|
TypeKind
:
:
ResolvedTypeRef
(
inner
)
=
>
{
tracer
.
visit
(
inner
)
;
}
TypeKind
:
:
TemplateAlias
(
inner
ref
template_args
)
|
TypeKind
:
:
TemplateInstantiation
(
inner
ref
template_args
)
=
>
{
tracer
.
visit
(
inner
)
;
for
&
item
in
template_args
{
tracer
.
visit
(
item
)
;
}
}
TypeKind
:
:
Comp
(
ref
ci
)
=
>
ci
.
trace
(
context
tracer
item
)
TypeKind
:
:
Function
(
ref
sig
)
=
>
sig
.
trace
(
context
tracer
&
(
)
)
TypeKind
:
:
Enum
(
ref
en
)
=
>
{
if
let
Some
(
repr
)
=
en
.
repr
(
)
{
tracer
.
visit
(
repr
)
;
}
}
TypeKind
:
:
UnresolvedTypeRef
(
_
_
Some
(
id
)
)
=
>
{
tracer
.
visit
(
id
)
;
}
TypeKind
:
:
ObjCInterface
(
_
)
=
>
{
}
TypeKind
:
:
UnresolvedTypeRef
(
_
_
None
)
|
TypeKind
:
:
Named
|
TypeKind
:
:
Void
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
Int
(
_
)
|
TypeKind
:
:
Float
(
_
)
|
TypeKind
:
:
Complex
(
_
)
|
TypeKind
:
:
BlockPointer
=
>
{
}
}
}
}
