use
super
:
:
{
ConstrainResult
MonotoneFramework
generate_dependencies
}
;
use
ir
:
:
comp
:
:
CompKind
;
use
ir
:
:
comp
:
:
Field
;
use
ir
:
:
comp
:
:
FieldMethods
;
use
ir
:
:
context
:
:
{
BindgenContext
ItemId
}
;
use
ir
:
:
derive
:
:
CanTriviallyDeriveCopy
;
use
ir
:
:
item
:
:
IsOpaque
;
use
ir
:
:
template
:
:
TemplateParameters
;
use
ir
:
:
traversal
:
:
EdgeKind
;
use
ir
:
:
ty
:
:
RUST_DERIVE_IN_ARRAY_LIMIT
;
use
ir
:
:
ty
:
:
TypeKind
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
HashSet
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
CannotDeriveCopy
<
'
ctx
>
{
ctx
:
&
'
ctx
BindgenContext
cannot_derive_copy
:
HashSet
<
ItemId
>
dependencies
:
HashMap
<
ItemId
Vec
<
ItemId
>
>
}
impl
<
'
ctx
>
CannotDeriveCopy
<
'
ctx
>
{
fn
consider_edge
(
kind
:
EdgeKind
)
-
>
bool
{
match
kind
{
EdgeKind
:
:
BaseMember
|
EdgeKind
:
:
Field
|
EdgeKind
:
:
TypeReference
|
EdgeKind
:
:
VarType
|
EdgeKind
:
:
TemplateArgument
|
EdgeKind
:
:
TemplateDeclaration
|
EdgeKind
:
:
TemplateParameterDefinition
=
>
true
EdgeKind
:
:
Constructor
|
EdgeKind
:
:
Destructor
|
EdgeKind
:
:
FunctionReturn
|
EdgeKind
:
:
FunctionParameter
|
EdgeKind
:
:
InnerType
|
EdgeKind
:
:
InnerVar
|
EdgeKind
:
:
Method
=
>
false
EdgeKind
:
:
Generic
=
>
false
}
}
fn
insert
<
Id
:
Into
<
ItemId
>
>
(
&
mut
self
id
:
Id
)
-
>
ConstrainResult
{
let
id
=
id
.
into
(
)
;
trace
!
(
"
inserting
{
:
?
}
into
the
cannot_derive_copy
set
"
id
)
;
let
was_not_already_in_set
=
self
.
cannot_derive_copy
.
insert
(
id
)
;
assert
!
(
was_not_already_in_set
"
We
shouldn
'
t
try
and
insert
{
:
?
}
twice
because
if
it
was
\
already
in
the
set
constrain
should
have
exited
early
.
"
id
)
;
ConstrainResult
:
:
Changed
}
fn
is_not_copy
<
Id
:
Into
<
ItemId
>
>
(
&
self
id
:
Id
)
-
>
bool
{
let
id
=
id
.
into
(
)
;
self
.
cannot_derive_copy
.
contains
(
&
id
)
|
|
!
self
.
ctx
.
whitelisted_items
(
)
.
contains
(
&
id
)
}
}
impl
<
'
ctx
>
MonotoneFramework
for
CannotDeriveCopy
<
'
ctx
>
{
type
Node
=
ItemId
;
type
Extra
=
&
'
ctx
BindgenContext
;
type
Output
=
HashSet
<
ItemId
>
;
fn
new
(
ctx
:
&
'
ctx
BindgenContext
)
-
>
CannotDeriveCopy
<
'
ctx
>
{
let
cannot_derive_copy
=
HashSet
:
:
new
(
)
;
let
dependencies
=
generate_dependencies
(
ctx
Self
:
:
consider_edge
)
;
CannotDeriveCopy
{
ctx
cannot_derive_copy
dependencies
}
}
fn
initial_worklist
(
&
self
)
-
>
Vec
<
ItemId
>
{
self
.
ctx
.
whitelisted_items
(
)
.
iter
(
)
.
cloned
(
)
.
collect
(
)
}
fn
constrain
(
&
mut
self
id
:
ItemId
)
-
>
ConstrainResult
{
trace
!
(
"
constrain
:
{
:
?
}
"
id
)
;
if
self
.
cannot_derive_copy
.
contains
(
&
id
)
{
trace
!
(
"
already
know
it
cannot
derive
Copy
"
)
;
return
ConstrainResult
:
:
Same
;
}
if
!
self
.
ctx
.
whitelisted_items
(
)
.
contains
(
&
id
)
{
trace
!
(
"
blacklisted
items
are
assumed
not
to
be
Copy
"
)
;
return
ConstrainResult
:
:
Same
;
}
let
item
=
self
.
ctx
.
resolve_item
(
id
)
;
let
ty
=
match
item
.
as_type
(
)
{
Some
(
ty
)
=
>
ty
None
=
>
{
trace
!
(
"
not
a
type
;
ignoring
"
)
;
return
ConstrainResult
:
:
Same
;
}
}
;
if
self
.
ctx
.
no_copy_by_name
(
&
item
)
{
return
self
.
insert
(
id
)
;
}
if
item
.
is_opaque
(
self
.
ctx
&
(
)
)
{
let
layout_can_derive
=
ty
.
layout
(
self
.
ctx
)
.
map_or
(
true
|
l
|
{
l
.
opaque
(
)
.
can_trivially_derive_copy
(
self
.
ctx
)
}
)
;
return
if
layout_can_derive
{
trace
!
(
"
we
can
trivially
derive
Copy
for
the
layout
"
)
;
ConstrainResult
:
:
Same
}
else
{
trace
!
(
"
we
cannot
derive
Copy
for
the
layout
"
)
;
self
.
insert
(
id
)
}
;
}
match
*
ty
.
kind
(
)
{
TypeKind
:
:
Void
|
TypeKind
:
:
NullPtr
|
TypeKind
:
:
Int
(
.
.
)
|
TypeKind
:
:
Float
(
.
.
)
|
TypeKind
:
:
Vector
(
.
.
)
|
TypeKind
:
:
Complex
(
.
.
)
|
TypeKind
:
:
Function
(
.
.
)
|
TypeKind
:
:
Enum
(
.
.
)
|
TypeKind
:
:
Reference
(
.
.
)
|
TypeKind
:
:
TypeParam
|
TypeKind
:
:
Pointer
(
.
.
)
|
TypeKind
:
:
UnresolvedTypeRef
(
.
.
)
|
TypeKind
:
:
ObjCInterface
(
.
.
)
|
TypeKind
:
:
ObjCId
|
TypeKind
:
:
ObjCSel
=
>
{
trace
!
(
"
simple
type
that
can
always
derive
Copy
"
)
;
ConstrainResult
:
:
Same
}
TypeKind
:
:
Array
(
t
len
)
=
>
{
let
cant_derive_copy
=
self
.
is_not_copy
(
t
)
;
if
cant_derive_copy
{
trace
!
(
"
arrays
of
T
for
which
we
cannot
derive
Copy
\
also
cannot
derive
Copy
"
)
;
return
self
.
insert
(
id
)
;
}
if
len
>
0
{
trace
!
(
"
array
can
derive
Copy
with
positive
length
"
)
;
ConstrainResult
:
:
Same
}
else
{
trace
!
(
"
array
cannot
derive
Copy
with
0
length
"
)
;
self
.
insert
(
id
)
}
}
TypeKind
:
:
ResolvedTypeRef
(
t
)
|
TypeKind
:
:
TemplateAlias
(
t
_
)
|
TypeKind
:
:
Alias
(
t
)
|
TypeKind
:
:
BlockPointer
(
t
)
=
>
{
let
cant_derive_copy
=
self
.
is_not_copy
(
t
)
;
if
cant_derive_copy
{
trace
!
(
"
arrays
of
T
for
which
we
cannot
derive
Copy
\
also
cannot
derive
Copy
"
)
;
return
self
.
insert
(
id
)
;
}
trace
!
(
"
aliases
and
type
refs
to
T
which
can
derive
\
Copy
can
also
derive
Copy
"
)
;
ConstrainResult
:
:
Same
}
TypeKind
:
:
Comp
(
ref
info
)
=
>
{
assert
!
(
!
info
.
has_non_type_template_params
(
)
"
The
early
ty
.
is_opaque
check
should
have
handled
this
case
"
)
;
if
self
.
ctx
.
lookup_has_destructor
(
id
.
expect_type_id
(
self
.
ctx
)
)
{
trace
!
(
"
comp
has
destructor
which
cannot
derive
copy
"
)
;
return
self
.
insert
(
id
)
;
}
if
info
.
kind
(
)
=
=
CompKind
:
:
Union
{
if
!
self
.
ctx
.
options
(
)
.
rust_features
(
)
.
untagged_union
{
trace
!
(
"
comp
can
always
derive
debug
if
it
'
s
a
Union
and
no
template
parameters
"
)
;
return
ConstrainResult
:
:
Same
;
}
if
!
info
.
self_template_params
(
self
.
ctx
)
.
is_empty
(
)
|
|
!
item
.
all_template_params
(
self
.
ctx
)
.
is_empty
(
)
{
trace
!
(
"
comp
cannot
derive
copy
because
issue
36640
"
)
;
return
self
.
insert
(
id
)
;
}
}
let
bases_cannot_derive
=
info
.
base_members
(
)
.
iter
(
)
.
any
(
|
base
|
{
self
.
is_not_copy
(
base
.
ty
)
}
)
;
if
bases_cannot_derive
{
trace
!
(
"
base
members
cannot
derive
Copy
so
we
can
'
t
\
either
"
)
;
return
self
.
insert
(
id
)
;
}
let
fields_cannot_derive
=
info
.
fields
(
)
.
iter
(
)
.
any
(
|
f
|
match
*
f
{
Field
:
:
DataMember
(
ref
data
)
=
>
{
self
.
is_not_copy
(
data
.
ty
(
)
)
}
Field
:
:
Bitfields
(
ref
bfu
)
=
>
{
if
bfu
.
layout
(
)
.
align
>
RUST_DERIVE_IN_ARRAY_LIMIT
{
trace
!
(
"
we
cannot
derive
Copy
for
a
bitfield
larger
then
\
the
limit
"
)
;
return
true
;
}
bfu
.
bitfields
(
)
.
iter
(
)
.
any
(
|
b
|
{
self
.
is_not_copy
(
b
.
ty
(
)
)
}
)
}
}
)
;
if
fields_cannot_derive
{
trace
!
(
"
fields
cannot
derive
Copy
so
we
can
'
t
either
"
)
;
return
self
.
insert
(
id
)
;
}
trace
!
(
"
comp
can
derive
Copy
"
)
;
ConstrainResult
:
:
Same
}
TypeKind
:
:
TemplateInstantiation
(
ref
template
)
=
>
{
let
args_cannot_derive
=
template
.
template_arguments
(
)
.
iter
(
)
.
any
(
|
arg
|
{
self
.
is_not_copy
(
*
arg
)
}
)
;
if
args_cannot_derive
{
trace
!
(
"
template
args
cannot
derive
Copy
so
\
insantiation
can
'
t
either
"
)
;
return
self
.
insert
(
id
)
;
}
assert
!
(
!
template
.
template_definition
(
)
.
is_opaque
(
self
.
ctx
&
(
)
)
"
The
early
ty
.
is_opaque
check
should
have
handled
this
case
"
)
;
let
def_cannot_derive
=
self
.
is_not_copy
(
template
.
template_definition
(
)
)
;
if
def_cannot_derive
{
trace
!
(
"
template
definition
cannot
derive
Copy
so
\
insantiation
can
'
t
either
"
)
;
return
self
.
insert
(
id
)
;
}
trace
!
(
"
template
instantiation
can
derive
Copy
"
)
;
ConstrainResult
:
:
Same
}
TypeKind
:
:
Opaque
=
>
{
unreachable
!
(
"
The
early
ty
.
is_opaque
check
should
have
handled
this
case
"
)
}
}
}
fn
each_depending_on
<
F
>
(
&
self
id
:
ItemId
mut
f
:
F
)
where
F
:
FnMut
(
ItemId
)
{
if
let
Some
(
edges
)
=
self
.
dependencies
.
get
(
&
id
)
{
for
item
in
edges
{
trace
!
(
"
enqueue
{
:
?
}
into
worklist
"
item
)
;
f
(
*
item
)
;
}
}
}
}
impl
<
'
ctx
>
From
<
CannotDeriveCopy
<
'
ctx
>
>
for
HashSet
<
ItemId
>
{
fn
from
(
analysis
:
CannotDeriveCopy
<
'
ctx
>
)
-
>
Self
{
analysis
.
cannot_derive_copy
}
}
