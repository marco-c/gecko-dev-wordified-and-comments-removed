use
super
:
:
context
:
:
BindgenContext
;
use
std
:
:
cmp
;
use
std
:
:
ops
;
pub
trait
CanDeriveDebug
{
fn
can_derive_debug
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDeriveCopy
{
fn
can_derive_copy
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDeriveDefault
{
fn
can_derive_default
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDeriveHash
{
fn
can_derive_hash
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDerivePartialEq
{
fn
can_derive_partialeq
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDerivePartialOrd
{
fn
can_derive_partialord
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDeriveEq
{
fn
can_derive_eq
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
pub
trait
CanDeriveOrd
{
fn
can_derive_ord
(
&
self
ctx
:
&
BindgenContext
)
-
>
bool
;
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Ord
)
]
pub
enum
CanDerive
{
No
Manually
Yes
}
impl
Default
for
CanDerive
{
fn
default
(
)
-
>
CanDerive
{
CanDerive
:
:
Yes
}
}
impl
cmp
:
:
PartialOrd
for
CanDerive
{
fn
partial_cmp
(
&
self
rhs
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
use
self
:
:
CanDerive
:
:
*
;
let
ordering
=
match
(
*
self
*
rhs
)
{
(
x
y
)
if
x
=
=
y
=
>
cmp
:
:
Ordering
:
:
Equal
(
No
_
)
=
>
cmp
:
:
Ordering
:
:
Greater
(
_
No
)
=
>
cmp
:
:
Ordering
:
:
Less
(
Manually
_
)
=
>
cmp
:
:
Ordering
:
:
Greater
(
_
Manually
)
=
>
cmp
:
:
Ordering
:
:
Less
_
=
>
unreachable
!
(
)
}
;
Some
(
ordering
)
}
}
impl
CanDerive
{
pub
fn
join
(
self
rhs
:
Self
)
-
>
Self
{
cmp
:
:
max
(
self
rhs
)
}
}
impl
ops
:
:
BitOr
for
CanDerive
{
type
Output
=
Self
;
fn
bitor
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
join
(
rhs
)
}
}
impl
ops
:
:
BitOrAssign
for
CanDerive
{
fn
bitor_assign
(
&
mut
self
rhs
:
Self
)
{
*
self
=
self
.
join
(
rhs
)
}
}
