use
super
:
:
context
:
:
BindgenContext
;
use
super
:
:
derive
:
:
{
CanDeriveCopy
CanDeriveDebug
}
;
use
super
:
:
ty
:
:
RUST_DERIVE_IN_ARRAY_LIMIT
;
use
std
:
:
cmp
;
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
Layout
{
pub
size
:
usize
pub
align
:
usize
pub
packed
:
bool
}
impl
Layout
{
pub
fn
new
(
size
:
usize
align
:
usize
)
-
>
Self
{
Layout
{
size
:
size
align
:
align
packed
:
false
}
}
pub
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
size
=
=
0
&
&
self
.
align
=
=
0
}
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
0
0
)
}
pub
fn
opaque
(
&
self
)
-
>
Opaque
{
Opaque
(
*
self
)
}
}
pub
struct
Opaque
(
pub
Layout
)
;
impl
Opaque
{
pub
fn
known_rust_type_for_array
(
&
self
)
-
>
Option
<
&
'
static
str
>
{
Some
(
match
self
.
0
.
align
{
8
=
>
"
u64
"
4
=
>
"
u32
"
2
=
>
"
u16
"
1
=
>
"
u8
"
_
=
>
return
None
}
)
}
pub
fn
array_size
(
&
self
)
-
>
Option
<
usize
>
{
if
self
.
known_rust_type_for_array
(
)
.
is_some
(
)
{
Some
(
self
.
0
.
size
/
cmp
:
:
max
(
self
.
0
.
align
1
)
)
}
else
{
None
}
}
}
impl
CanDeriveDebug
for
Opaque
{
type
Extra
=
(
)
;
fn
can_derive_debug
(
&
self
_
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
)
}
}
impl
<
'
a
>
CanDeriveCopy
<
'
a
>
for
Opaque
{
type
Extra
=
(
)
;
fn
can_derive_copy
(
&
self
_
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
)
}
fn
can_derive_copy_in_array
(
&
self
ctx
:
&
BindgenContext
_
:
(
)
)
-
>
bool
{
self
.
can_derive_copy
(
ctx
(
)
)
}
}
