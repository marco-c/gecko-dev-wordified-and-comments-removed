use
super
:
:
derive
:
:
{
CanTriviallyDeriveCopy
CanTriviallyDeriveDebug
CanTriviallyDeriveDefault
CanTriviallyDeriveHash
CanTriviallyDerivePartialEq
}
;
use
super
:
:
ty
:
:
{
RUST_DERIVE_IN_ARRAY_LIMIT
Type
TypeKind
}
;
use
clang
;
use
std
:
:
{
cmp
mem
}
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
)
]
pub
struct
Layout
{
pub
size
:
usize
pub
align
:
usize
pub
packed
:
bool
}
#
[
test
]
fn
test_layout_for_size
(
)
{
let
ptr_size
=
mem
:
:
size_of
:
:
<
*
mut
(
)
>
(
)
;
assert_eq
!
(
Layout
:
:
for_size
(
ptr_size
)
Layout
:
:
new
(
ptr_size
ptr_size
)
)
;
assert_eq
!
(
Layout
:
:
for_size
(
3
*
ptr_size
)
Layout
:
:
new
(
3
*
ptr_size
ptr_size
)
)
;
}
impl
Layout
{
pub
fn
new
(
size
:
usize
align
:
usize
)
-
>
Self
{
Layout
{
size
:
size
align
:
align
packed
:
false
}
}
pub
fn
for_size
(
size
:
usize
)
-
>
Self
{
let
mut
next_align
=
2
;
while
size
%
next_align
=
=
0
&
&
next_align
<
=
mem
:
:
size_of
:
:
<
*
mut
(
)
>
(
)
{
next_align
*
=
2
;
}
Layout
{
size
:
size
align
:
next_align
/
2
packed
:
false
}
}
pub
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
size
=
=
0
&
&
self
.
align
=
=
0
}
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
0
0
)
}
pub
fn
opaque
(
&
self
)
-
>
Opaque
{
Opaque
(
*
self
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
Opaque
(
pub
Layout
)
;
impl
Opaque
{
pub
fn
from_clang_ty
(
ty
:
&
clang
:
:
Type
)
-
>
Type
{
let
layout
=
Layout
:
:
new
(
ty
.
size
(
)
ty
.
align
(
)
)
;
let
ty_kind
=
TypeKind
:
:
Opaque
;
Type
:
:
new
(
None
Some
(
layout
)
ty_kind
false
)
}
pub
fn
known_rust_type_for_array
(
&
self
)
-
>
Option
<
&
'
static
str
>
{
Some
(
match
self
.
0
.
align
{
8
=
>
"
u64
"
4
=
>
"
u32
"
2
=
>
"
u16
"
1
=
>
"
u8
"
_
=
>
return
None
}
)
}
pub
fn
array_size
(
&
self
)
-
>
Option
<
usize
>
{
if
self
.
known_rust_type_for_array
(
)
.
is_some
(
)
{
Some
(
self
.
0
.
size
/
cmp
:
:
max
(
self
.
0
.
align
1
)
)
}
else
{
None
}
}
}
impl
CanTriviallyDeriveDebug
for
Opaque
{
fn
can_trivially_derive_debug
(
&
self
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
{
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
}
)
}
}
impl
CanTriviallyDeriveDefault
for
Opaque
{
fn
can_trivially_derive_default
(
&
self
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
{
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
}
)
}
}
impl
CanTriviallyDeriveCopy
for
Opaque
{
fn
can_trivially_derive_copy
(
&
self
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
{
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
}
)
}
}
impl
CanTriviallyDeriveHash
for
Opaque
{
fn
can_trivially_derive_hash
(
&
self
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
{
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
}
)
}
}
impl
CanTriviallyDerivePartialEq
for
Opaque
{
fn
can_trivially_derive_partialeq
(
&
self
)
-
>
bool
{
self
.
array_size
(
)
.
map_or
(
false
|
size
|
{
size
<
=
RUST_DERIVE_IN_ARRAY_LIMIT
}
)
}
}
