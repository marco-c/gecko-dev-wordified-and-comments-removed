use
ir
:
:
context
:
:
BindgenContext
;
use
ir
:
:
item
:
:
{
Item
ItemAncestors
ItemCanonicalName
}
;
use
std
:
:
io
;
fn
namespaced_name
(
ctx
:
&
BindgenContext
item
:
&
Item
)
-
>
String
{
let
mut
names
:
Vec
<
_
>
=
item
.
ancestors
(
ctx
)
.
map
(
|
id
|
ctx
.
resolve_item
(
id
)
.
canonical_name
(
ctx
)
)
.
filter
(
|
name
|
!
name
.
starts_with
(
"
_bindgen_
"
)
)
.
collect
(
)
;
names
.
reverse
(
)
;
names
.
join
(
"
:
:
"
)
}
pub
fn
generate_dummy_uses
<
W
>
(
ctx
:
&
mut
BindgenContext
mut
dest
:
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
ctx
.
gen
(
|
ctx
|
{
let
input_header
=
ctx
.
options
(
)
.
input_header
.
as_ref
(
)
.
expect
(
"
Should
not
generate
dummy
uses
without
an
input
header
"
)
;
try
!
(
writeln
!
(
dest
"
/
*
automatically
generated
by
rust
-
bindgen
*
/
"
)
)
;
try
!
(
writeln
!
(
dest
"
"
)
)
;
try
!
(
writeln
!
(
dest
"
#
include
\
"
{
}
\
"
"
input_header
)
)
;
try
!
(
writeln
!
(
dest
"
"
)
)
;
let
type_items
=
ctx
.
whitelisted_items
(
)
.
map
(
|
id
|
ctx
.
resolve_item
(
id
)
)
.
filter
(
|
item
|
{
if
let
Some
(
ty
)
=
item
.
kind
(
)
.
as_type
(
)
{
ty
.
name
(
)
.
is_some
(
)
&
&
!
ty
.
is_builtin_or_named
(
)
&
&
item
.
applicable_template_args
(
ctx
)
.
is_empty
(
)
}
else
{
false
}
}
)
.
map
(
|
item
|
namespaced_name
(
ctx
item
)
)
.
enumerate
(
)
;
for
(
idx
name
)
in
type_items
{
try
!
(
writeln
!
(
dest
"
void
dummy
{
}
(
{
}
*
)
{
{
}
}
"
idx
name
)
)
;
}
Ok
(
(
)
)
}
)
}
