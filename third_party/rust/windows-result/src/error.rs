use
super
:
:
*
;
use
core
:
:
num
:
:
NonZeroI32
;
#
[
allow
(
unused_imports
)
]
use
core
:
:
mem
:
:
size_of
;
#
[
derive
(
Clone
)
]
pub
struct
Error
{
code
:
NonZeroI32
info
:
ErrorInfo
}
const
S_EMPTY_ERROR
:
NonZeroI32
=
const_nonzero_i32
(
u32
:
:
from_be_bytes
(
*
b
"
S_OK
"
)
as
i32
)
;
const
fn
const_nonzero_i32
(
i
:
i32
)
-
>
NonZeroI32
{
if
let
Some
(
nz
)
=
NonZeroI32
:
:
new
(
i
)
{
nz
}
else
{
panic
!
(
)
;
}
}
fn
nonzero_hresult
(
hr
:
HRESULT
)
-
>
NonZeroI32
{
if
let
Some
(
nz
)
=
NonZeroI32
:
:
new
(
hr
.
0
)
{
nz
}
else
{
S_EMPTY_ERROR
}
}
impl
Error
{
pub
const
fn
empty
(
)
-
>
Self
{
Self
{
code
:
S_EMPTY_ERROR
info
:
ErrorInfo
:
:
empty
(
)
}
}
pub
fn
new
<
T
:
AsRef
<
str
>
>
(
code
:
HRESULT
message
:
T
)
-
>
Self
{
#
[
cfg
(
windows
)
]
{
let
message
:
&
str
=
message
.
as_ref
(
)
;
if
message
.
is_empty
(
)
{
Self
:
:
from_hresult
(
code
)
}
else
{
ErrorInfo
:
:
originate_error
(
code
message
)
;
code
.
into
(
)
}
}
#
[
cfg
(
not
(
windows
)
)
]
{
let
_
=
message
;
Self
:
:
from_hresult
(
code
)
}
}
pub
fn
from_hresult
(
code
:
HRESULT
)
-
>
Self
{
Self
{
code
:
nonzero_hresult
(
code
)
info
:
ErrorInfo
:
:
empty
(
)
}
}
pub
fn
from_win32
(
)
-
>
Self
{
#
[
cfg
(
windows
)
]
{
let
error
=
unsafe
{
GetLastError
(
)
}
;
Self
:
:
from_hresult
(
HRESULT
:
:
from_win32
(
error
)
)
}
#
[
cfg
(
not
(
windows
)
)
]
{
unimplemented
!
(
)
}
}
pub
const
fn
code
(
&
self
)
-
>
HRESULT
{
if
self
.
code
.
get
(
)
=
=
S_EMPTY_ERROR
.
get
(
)
{
HRESULT
(
0
)
}
else
{
HRESULT
(
self
.
code
.
get
(
)
)
}
}
pub
fn
message
(
&
self
)
-
>
String
{
if
let
Some
(
message
)
=
self
.
info
.
message
(
)
{
return
message
;
}
self
.
code
(
)
.
message
(
)
}
#
[
cfg
(
windows
)
]
pub
fn
as_ptr
(
&
self
)
-
>
*
mut
core
:
:
ffi
:
:
c_void
{
self
.
info
.
as_ptr
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
Error
{
}
impl
From
<
Error
>
for
HRESULT
{
fn
from
(
error
:
Error
)
-
>
Self
{
let
code
=
error
.
code
(
)
;
error
.
info
.
into_thread
(
)
;
code
}
}
impl
From
<
HRESULT
>
for
Error
{
fn
from
(
code
:
HRESULT
)
-
>
Self
{
Self
{
code
:
nonzero_hresult
(
code
)
info
:
ErrorInfo
:
:
from_thread
(
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
From
<
Error
>
for
std
:
:
io
:
:
Error
{
fn
from
(
from
:
Error
)
-
>
Self
{
Self
:
:
from_raw_os_error
(
from
.
code
(
)
.
0
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
From
<
std
:
:
io
:
:
Error
>
for
Error
{
fn
from
(
from
:
std
:
:
io
:
:
Error
)
-
>
Self
{
match
from
.
raw_os_error
(
)
{
Some
(
status
)
=
>
HRESULT
:
:
from_win32
(
status
as
u32
)
.
into
(
)
None
=
>
HRESULT
(
E_UNEXPECTED
)
.
into
(
)
}
}
}
impl
From
<
alloc
:
:
string
:
:
FromUtf16Error
>
for
Error
{
fn
from
(
_
:
alloc
:
:
string
:
:
FromUtf16Error
)
-
>
Self
{
Self
:
:
from_hresult
(
HRESULT
:
:
from_win32
(
ERROR_NO_UNICODE_TRANSLATION
)
)
}
}
impl
From
<
alloc
:
:
string
:
:
FromUtf8Error
>
for
Error
{
fn
from
(
_
:
alloc
:
:
string
:
:
FromUtf8Error
)
-
>
Self
{
Self
:
:
from_hresult
(
HRESULT
:
:
from_win32
(
ERROR_NO_UNICODE_TRANSLATION
)
)
}
}
impl
From
<
core
:
:
num
:
:
TryFromIntError
>
for
Error
{
fn
from
(
_
:
core
:
:
num
:
:
TryFromIntError
)
-
>
Self
{
Self
:
:
from_hresult
(
HRESULT
:
:
from_win32
(
ERROR_INVALID_DATA
)
)
}
}
impl
core
:
:
fmt
:
:
Debug
for
Error
{
fn
fmt
(
&
self
fmt
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
let
mut
debug
=
fmt
.
debug_struct
(
"
Error
"
)
;
debug
.
field
(
"
code
"
&
self
.
code
(
)
)
.
field
(
"
message
"
&
self
.
message
(
)
)
.
finish
(
)
}
}
impl
core
:
:
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
fmt
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
let
message
=
self
.
message
(
)
;
if
message
.
is_empty
(
)
{
core
:
:
write
!
(
fmt
"
{
}
"
self
.
code
(
)
)
}
else
{
core
:
:
write
!
(
fmt
"
{
}
(
{
}
)
"
self
.
message
(
)
self
.
code
(
)
)
}
}
}
impl
core
:
:
hash
:
:
Hash
for
Error
{
fn
hash
<
H
:
core
:
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
code
.
hash
(
state
)
;
}
}
impl
PartialEq
for
Error
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
code
=
=
other
.
code
}
}
impl
Eq
for
Error
{
}
impl
PartialOrd
for
Error
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
core
:
:
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
Error
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
core
:
:
cmp
:
:
Ordering
{
self
.
code
.
cmp
(
&
other
.
code
)
}
}
use
error_info
:
:
*
;
#
[
cfg
(
all
(
windows
not
(
windows_slim_errors
)
)
)
]
mod
error_info
{
use
super
:
:
*
;
use
crate
:
:
com
:
:
ComPtr
;
#
[
derive
(
Clone
Default
)
]
pub
(
crate
)
struct
ErrorInfo
{
pub
(
super
)
ptr
:
Option
<
ComPtr
>
}
impl
ErrorInfo
{
pub
(
crate
)
const
fn
empty
(
)
-
>
Self
{
Self
{
ptr
:
None
}
}
pub
(
crate
)
fn
from_thread
(
)
-
>
Self
{
unsafe
{
let
mut
ptr
=
core
:
:
mem
:
:
MaybeUninit
:
:
zeroed
(
)
;
crate
:
:
bindings
:
:
GetErrorInfo
(
0
ptr
.
as_mut_ptr
(
)
as
*
mut
_
)
;
Self
{
ptr
:
ptr
.
assume_init
(
)
}
}
}
pub
(
crate
)
fn
into_thread
(
self
)
{
if
let
Some
(
ptr
)
=
self
.
ptr
{
unsafe
{
crate
:
:
bindings
:
:
SetErrorInfo
(
0
ptr
.
as_raw
(
)
)
;
}
}
}
pub
(
crate
)
fn
originate_error
(
code
:
HRESULT
message
:
&
str
)
{
let
message
:
Vec
<
_
>
=
message
.
encode_utf16
(
)
.
collect
(
)
;
unsafe
{
RoOriginateErrorW
(
code
.
0
message
.
len
(
)
as
u32
message
.
as_ptr
(
)
)
;
}
}
pub
(
crate
)
fn
message
(
&
self
)
-
>
Option
<
String
>
{
use
crate
:
:
bstr
:
:
BasicString
;
let
ptr
=
self
.
ptr
.
as_ref
(
)
?
;
let
mut
message
=
BasicString
:
:
default
(
)
;
if
let
Some
(
info
)
=
ptr
.
cast
(
&
IID_IRestrictedErrorInfo
)
{
let
mut
fallback
=
BasicString
:
:
default
(
)
;
let
mut
code
=
0
;
unsafe
{
com_call
!
(
IRestrictedErrorInfo_Vtbl
info
.
GetErrorDetails
(
&
mut
fallback
as
*
mut
_
as
_
&
mut
code
&
mut
message
as
*
mut
_
as
_
&
mut
BasicString
:
:
default
(
)
as
*
mut
_
as
_
)
)
;
}
if
message
.
is_empty
(
)
{
message
=
fallback
}
;
}
if
message
.
is_empty
(
)
{
unsafe
{
com_call
!
(
IErrorInfo_Vtbl
ptr
.
GetDescription
(
&
mut
message
as
*
mut
_
as
_
)
)
;
}
}
Some
(
String
:
:
from_utf16_lossy
(
wide_trim_end
(
message
.
as_wide
(
)
)
)
)
}
pub
(
crate
)
fn
as_ptr
(
&
self
)
-
>
*
mut
core
:
:
ffi
:
:
c_void
{
if
let
Some
(
info
)
=
self
.
ptr
.
as_ref
(
)
{
info
.
as_raw
(
)
}
else
{
core
:
:
ptr
:
:
null_mut
(
)
}
}
}
unsafe
impl
Send
for
ErrorInfo
{
}
unsafe
impl
Sync
for
ErrorInfo
{
}
}
#
[
cfg
(
not
(
all
(
windows
not
(
windows_slim_errors
)
)
)
)
]
mod
error_info
{
use
super
:
:
*
;
#
[
derive
(
Clone
Default
)
]
pub
(
crate
)
struct
EmptyErrorInfo
;
pub
(
crate
)
use
EmptyErrorInfo
as
ErrorInfo
;
impl
EmptyErrorInfo
{
pub
(
crate
)
const
fn
empty
(
)
-
>
Self
{
Self
}
pub
(
crate
)
fn
from_thread
(
)
-
>
Self
{
Self
}
pub
(
crate
)
fn
into_thread
(
self
)
{
}
#
[
cfg
(
windows
)
]
pub
(
crate
)
fn
originate_error
(
_code
:
HRESULT
_message
:
&
str
)
{
}
pub
(
crate
)
fn
message
(
&
self
)
-
>
Option
<
String
>
{
None
}
#
[
cfg
(
windows
)
]
pub
(
crate
)
fn
as_ptr
(
&
self
)
-
>
*
mut
core
:
:
ffi
:
:
c_void
{
core
:
:
ptr
:
:
null_mut
(
)
}
}
}
