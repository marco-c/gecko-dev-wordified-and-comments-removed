#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
allow
(
non_snake_case
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
doc
=
include_str
!
(
"
.
.
/
README
.
md
"
)
]
use
core
:
:
mem
:
:
MaybeUninit
;
use
core
:
:
ffi
:
:
{
c_char
c_int
c_long
c_uchar
c_uint
c_ulong
c_void
}
;
use
zlib_rs
:
:
{
deflate
:
:
{
DeflateConfig
DeflateStream
Method
Strategy
}
inflate
:
:
{
InflateConfig
InflateStream
}
DeflateFlush
InflateFlush
ReturnCode
}
;
pub
use
zlib_rs
:
:
c_api
:
:
*
;
#
[
cfg
(
feature
=
"
custom
-
prefix
"
)
]
macro_rules
!
prefix
{
(
name
:
expr
)
=
>
{
concat
!
(
env
!
(
"
LIBZ_RS_SYS_PREFIX
"
)
stringify
!
(
name
)
)
}
;
}
#
[
cfg
(
all
(
not
(
feature
=
"
custom
-
prefix
"
)
not
(
any
(
test
feature
=
"
testing
-
prefix
"
)
)
)
)
]
macro_rules
!
prefix
{
(
name
:
expr
)
=
>
{
stringify
!
(
name
)
}
;
}
#
[
cfg
(
all
(
not
(
feature
=
"
custom
-
prefix
"
)
any
(
test
feature
=
"
testing
-
prefix
"
)
)
)
]
macro_rules
!
prefix
{
(
name
:
expr
)
=
>
{
concat
!
(
"
LIBZ_RS_SYS_TEST_
"
stringify
!
(
name
)
)
}
;
}
#
[
cfg
(
all
(
feature
=
"
rust
-
allocator
"
feature
=
"
c
-
allocator
"
)
)
]
const
_
:
(
)
=
compile_error
!
(
"
Only
one
of
rust
-
allocator
and
c
-
allocator
can
be
enabled
at
a
time
"
)
;
pub
type
z_off_t
=
c_long
;
#
[
export_name
=
prefix
!
(
crc32
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
crc32
(
crc
:
c_ulong
buf
:
*
const
Bytef
len
:
uInt
)
-
>
c_ulong
{
match
unsafe
{
slice_from_raw_parts
(
buf
len
as
usize
)
}
{
Some
(
buf
)
=
>
zlib_rs
:
:
crc32
(
crc
as
u32
buf
)
as
c_ulong
None
=
>
0
}
}
#
[
export_name
=
prefix
!
(
crc32_combine
)
]
pub
extern
"
C
-
unwind
"
fn
crc32_combine
(
crc1
:
c_ulong
crc2
:
c_ulong
len2
:
z_off_t
)
-
>
c_ulong
{
zlib_rs
:
:
crc32_combine
(
crc1
as
u32
crc2
as
u32
len2
as
u64
)
as
c_ulong
}
#
[
export_name
=
prefix
!
(
adler32
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
adler32
(
adler
:
c_ulong
buf
:
*
const
Bytef
len
:
uInt
)
-
>
c_ulong
{
match
unsafe
{
slice_from_raw_parts
(
buf
len
as
usize
)
}
{
Some
(
buf
)
=
>
zlib_rs
:
:
adler32
(
adler
as
u32
buf
)
as
c_ulong
None
=
>
1
}
}
#
[
export_name
=
prefix
!
(
adler32_combine
)
]
pub
extern
"
C
-
unwind
"
fn
adler32_combine
(
adler1
:
c_ulong
adler2
:
c_ulong
len2
:
z_off_t
)
-
>
c_ulong
{
match
u64
:
:
try_from
(
len2
)
{
Ok
(
len2
)
=
>
zlib_rs
:
:
adler32_combine
(
adler1
as
u32
adler2
as
u32
len2
)
as
c_ulong
Err
(
_
)
=
>
{
0xFFFF_FFFF
}
}
}
#
[
export_name
=
prefix
!
(
uncompress
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
uncompress
(
dest
:
*
mut
u8
destLen
:
*
mut
c_ulong
source
:
*
const
u8
sourceLen
:
c_ulong
)
-
>
c_int
{
let
Some
(
destLen
)
=
(
unsafe
{
destLen
.
as_mut
(
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Some
(
output
)
=
(
unsafe
{
slice_from_raw_parts_uninit_mut
(
dest
*
destLen
as
usize
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Some
(
input
)
=
(
unsafe
{
slice_from_raw_parts
(
source
sourceLen
as
usize
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
config
=
InflateConfig
:
:
default
(
)
;
let
(
output
err
)
=
zlib_rs
:
:
inflate
:
:
uncompress
(
output
input
config
)
;
*
destLen
=
output
.
len
(
)
as
c_ulong
;
err
as
c_int
}
#
[
export_name
=
prefix
!
(
inflate
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflate
(
strm
:
*
mut
z_stream
flush
:
i32
)
-
>
i32
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
let
flush
=
InflateFlush
:
:
try_from
(
flush
)
.
unwrap_or_default
(
)
;
zlib_rs
:
:
inflate
:
:
inflate
(
stream
flush
)
as
_
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
inflateEnd
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateEnd
(
strm
:
*
mut
z_stream
)
-
>
i32
{
match
InflateStream
:
:
from_stream_mut
(
strm
)
{
Some
(
stream
)
=
>
{
zlib_rs
:
:
inflate
:
:
end
(
stream
)
;
ReturnCode
:
:
Ok
as
_
}
None
=
>
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
inflateBackInit_
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateBackInit_
(
_strm
:
z_streamp
_windowBits
:
c_int
_window
:
*
mut
c_uchar
_version
:
*
const
c_char
_stream_size
:
c_int
)
-
>
c_int
{
todo
!
(
"
inflateBack
is
not
implemented
yet
"
)
}
#
[
export_name
=
prefix
!
(
inflateBack
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateBack
(
_strm
:
z_streamp
_in
:
in_func
_in_desc
:
*
mut
c_void
_out
:
out_func
_out_desc
:
*
mut
c_void
)
-
>
c_int
{
todo
!
(
"
inflateBack
is
not
implemented
yet
"
)
}
#
[
export_name
=
prefix
!
(
inflateBackEnd
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateBackEnd
(
_strm
:
z_streamp
)
-
>
c_int
{
todo
!
(
"
inflateBack
is
not
implemented
yet
"
)
}
#
[
export_name
=
prefix
!
(
inflateCopy
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateCopy
(
dest
:
*
mut
z_stream
source
:
*
const
z_stream
)
-
>
i32
{
let
Some
(
dest
)
=
(
unsafe
{
dest
.
cast
:
:
<
MaybeUninit
<
InflateStream
>
>
(
)
.
as_mut
(
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Some
(
source
)
=
(
unsafe
{
InflateStream
:
:
from_stream_ref
(
source
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
zlib_rs
:
:
inflate
:
:
copy
(
dest
source
)
as
_
}
#
[
export_name
=
prefix
!
(
inflateMark
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateMark
(
strm
:
*
const
z_stream
)
-
>
c_long
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_ref
(
strm
)
{
zlib_rs
:
:
inflate
:
:
mark
(
stream
)
}
else
{
-
65536
}
}
#
[
export_name
=
prefix
!
(
inflateSync
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateSync
(
strm
:
*
mut
z_stream
)
-
>
i32
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
zlib_rs
:
:
inflate
:
:
sync
(
stream
)
as
_
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
doc
(
hidden
)
]
#
[
export_name
=
prefix
!
(
inflateSyncPoint
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateSyncPoint
(
strm
:
*
mut
z_stream
)
-
>
i32
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
zlib_rs
:
:
inflate
:
:
sync_point
(
stream
)
as
i32
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
inflateInit_
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateInit_
(
strm
:
z_streamp
version
:
*
const
c_char
stream_size
:
c_int
)
-
>
c_int
{
let
config
=
InflateConfig
:
:
default
(
)
;
unsafe
{
inflateInit2_
(
strm
config
.
window_bits
version
stream_size
)
}
}
#
[
export_name
=
prefix
!
(
inflateInit2_
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateInit2_
(
strm
:
z_streamp
windowBits
:
c_int
version
:
*
const
c_char
stream_size
:
c_int
)
-
>
c_int
{
if
!
is_version_compatible
(
version
stream_size
)
{
ReturnCode
:
:
VersionError
as
_
}
else
{
inflateInit2
(
strm
windowBits
)
}
}
unsafe
extern
"
C
-
unwind
"
fn
inflateInit2
(
strm
:
z_streamp
windowBits
:
c_int
)
-
>
c_int
{
let
Some
(
strm
)
=
(
unsafe
{
strm
.
as_mut
(
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
config
=
InflateConfig
{
window_bits
:
windowBits
}
;
zlib_rs
:
:
inflate
:
:
init
(
strm
config
)
as
_
}
#
[
export_name
=
prefix
!
(
inflatePrime
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflatePrime
(
strm
:
*
mut
z_stream
bits
:
i32
value
:
i32
)
-
>
i32
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
zlib_rs
:
:
inflate
:
:
prime
(
stream
bits
value
)
as
_
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
inflateReset
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateReset
(
strm
:
*
mut
z_stream
)
-
>
i32
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
zlib_rs
:
:
inflate
:
:
reset
(
stream
)
as
_
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
inflateReset2
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateReset2
(
strm
:
*
mut
z_stream
windowBits
:
c_int
)
-
>
i32
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
let
config
=
InflateConfig
{
window_bits
:
windowBits
}
;
zlib_rs
:
:
inflate
:
:
reset_with_config
(
stream
config
)
as
_
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
inflateSetDictionary
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateSetDictionary
(
strm
:
*
mut
z_stream
dictionary
:
*
const
u8
dictLength
:
c_uint
)
-
>
c_int
{
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
dict
=
match
dictLength
{
0
=
>
&
[
]
_
=
>
unsafe
{
slice_from_raw_parts
(
dictionary
dictLength
as
usize
)
}
.
unwrap_or
(
&
[
]
)
}
;
zlib_rs
:
:
inflate
:
:
set_dictionary
(
stream
dict
)
as
_
}
#
[
export_name
=
prefix
!
(
inflateGetHeader
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateGetHeader
(
strm
:
z_streamp
head
:
gz_headerp
)
-
>
c_int
{
let
Some
(
stream
)
=
(
unsafe
{
InflateStream
:
:
from_stream_mut
(
strm
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
header
=
unsafe
{
head
.
as_mut
(
)
}
;
zlib_rs
:
:
inflate
:
:
get_header
(
stream
header
)
as
i32
}
#
[
doc
(
hidden
)
]
#
[
export_name
=
prefix
!
(
inflateUndermine
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateUndermine
(
strm
:
*
mut
z_stream
subvert
:
i32
)
-
>
c_int
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
zlib_rs
:
:
inflate
:
:
undermine
(
stream
subvert
)
as
i32
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
doc
(
hidden
)
]
#
[
export_name
=
prefix
!
(
inflateResetKeep
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateResetKeep
(
strm
:
*
mut
z_stream
)
-
>
c_int
{
if
let
Some
(
stream
)
=
InflateStream
:
:
from_stream_mut
(
strm
)
{
zlib_rs
:
:
inflate
:
:
reset_keep
(
stream
)
as
_
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
doc
(
hidden
)
]
#
[
export_name
=
prefix
!
(
inflateCodesUsed
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
inflateCodesUsed
(
_strm
:
*
mut
z_stream
)
-
>
c_ulong
{
todo
!
(
)
}
#
[
export_name
=
prefix
!
(
deflate
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflate
(
strm
:
*
mut
z_stream
flush
:
i32
)
-
>
c_int
{
if
let
Some
(
stream
)
=
DeflateStream
:
:
from_stream_mut
(
strm
)
{
match
DeflateFlush
:
:
try_from
(
flush
)
{
Ok
(
flush
)
=
>
zlib_rs
:
:
deflate
:
:
deflate
(
stream
flush
)
as
_
Err
(
(
)
)
=
>
ReturnCode
:
:
StreamError
as
_
}
}
else
{
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
deflateSetHeader
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateSetHeader
(
strm
:
*
mut
z_stream
head
:
gz_headerp
)
-
>
c_int
{
let
Some
(
stream
)
=
(
unsafe
{
DeflateStream
:
:
from_stream_mut
(
strm
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
header
=
unsafe
{
head
.
as_mut
(
)
}
;
zlib_rs
:
:
deflate
:
:
set_header
(
stream
header
)
as
_
}
#
[
export_name
=
prefix
!
(
deflateBound
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateBound
(
strm
:
*
mut
z_stream
sourceLen
:
c_ulong
)
-
>
c_ulong
{
zlib_rs
:
:
deflate
:
:
bound
(
DeflateStream
:
:
from_stream_mut
(
strm
)
sourceLen
as
usize
)
as
c_ulong
}
#
[
export_name
=
prefix
!
(
compress
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
compress
(
dest
:
*
mut
Bytef
destLen
:
*
mut
c_ulong
source
:
*
const
Bytef
sourceLen
:
c_ulong
)
-
>
c_int
{
compress2
(
dest
destLen
source
sourceLen
DeflateConfig
:
:
default
(
)
.
level
)
}
#
[
export_name
=
prefix
!
(
compress2
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
compress2
(
dest
:
*
mut
Bytef
destLen
:
*
mut
c_ulong
source
:
*
const
Bytef
sourceLen
:
c_ulong
level
:
c_int
)
-
>
c_int
{
let
Some
(
destLen
)
=
(
unsafe
{
destLen
.
as_mut
(
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Some
(
output
)
=
(
unsafe
{
slice_from_raw_parts_uninit_mut
(
dest
*
destLen
as
usize
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Some
(
input
)
=
(
unsafe
{
slice_from_raw_parts
(
source
sourceLen
as
usize
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
config
=
DeflateConfig
:
:
new
(
level
)
;
let
(
output
err
)
=
zlib_rs
:
:
deflate
:
:
compress
(
output
input
config
)
;
*
destLen
=
output
.
len
(
)
as
c_ulong
;
err
as
c_int
}
#
[
export_name
=
prefix
!
(
compressBound
)
]
pub
extern
"
C
-
unwind
"
fn
compressBound
(
sourceLen
:
c_ulong
)
-
>
c_ulong
{
zlib_rs
:
:
deflate
:
:
compress_bound
(
sourceLen
as
usize
)
as
c_ulong
}
#
[
export_name
=
prefix
!
(
deflateEnd
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateEnd
(
strm
:
*
mut
z_stream
)
-
>
i32
{
match
DeflateStream
:
:
from_stream_mut
(
strm
)
{
Some
(
stream
)
=
>
match
zlib_rs
:
:
deflate
:
:
end
(
stream
)
{
Ok
(
_
)
=
>
ReturnCode
:
:
Ok
as
_
Err
(
_
)
=
>
ReturnCode
:
:
DataError
as
_
}
None
=
>
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
deflateReset
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateReset
(
strm
:
*
mut
z_stream
)
-
>
i32
{
match
DeflateStream
:
:
from_stream_mut
(
strm
)
{
Some
(
stream
)
=
>
zlib_rs
:
:
deflate
:
:
reset
(
stream
)
as
_
None
=
>
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
deflateParams
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateParams
(
strm
:
z_streamp
level
:
c_int
strategy
:
c_int
)
-
>
c_int
{
let
Ok
(
strategy
)
=
Strategy
:
:
try_from
(
strategy
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
match
DeflateStream
:
:
from_stream_mut
(
strm
)
{
Some
(
stream
)
=
>
zlib_rs
:
:
deflate
:
:
params
(
stream
level
strategy
)
as
_
None
=
>
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
deflateSetDictionary
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateSetDictionary
(
strm
:
z_streamp
dictionary
:
*
const
Bytef
dictLength
:
uInt
)
-
>
c_int
{
let
Some
(
dictionary
)
=
(
unsafe
{
slice_from_raw_parts
(
dictionary
dictLength
as
usize
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
match
DeflateStream
:
:
from_stream_mut
(
strm
)
{
Some
(
stream
)
=
>
zlib_rs
:
:
deflate
:
:
set_dictionary
(
stream
dictionary
)
as
_
None
=
>
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
deflatePrime
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflatePrime
(
strm
:
z_streamp
bits
:
c_int
value
:
c_int
)
-
>
c_int
{
match
DeflateStream
:
:
from_stream_mut
(
strm
)
{
Some
(
stream
)
=
>
zlib_rs
:
:
deflate
:
:
prime
(
stream
bits
value
)
as
_
None
=
>
ReturnCode
:
:
StreamError
as
_
}
}
#
[
export_name
=
prefix
!
(
deflatePending
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflatePending
(
strm
:
z_streamp
pending
:
*
mut
c_uint
bits
:
*
mut
c_int
)
-
>
c_int
{
let
Some
(
stream
)
=
(
unsafe
{
DeflateStream
:
:
from_stream_mut
(
strm
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
(
current_pending
current_bits
)
=
stream
.
pending
(
)
;
if
let
Some
(
pending
)
=
unsafe
{
pending
.
as_mut
(
)
}
{
*
pending
=
current_pending
as
c_uint
;
}
if
let
Some
(
bits
)
=
unsafe
{
bits
.
as_mut
(
)
}
{
*
bits
=
current_bits
as
c_int
;
}
ReturnCode
:
:
Ok
as
_
}
#
[
export_name
=
prefix
!
(
deflateCopy
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateCopy
(
dest
:
z_streamp
source
:
z_streamp
)
-
>
c_int
{
let
Some
(
dest
)
=
(
unsafe
{
dest
.
cast
:
:
<
MaybeUninit
<
DeflateStream
>
>
(
)
.
as_mut
(
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Some
(
source
)
=
(
unsafe
{
DeflateStream
:
:
from_stream_mut
(
source
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
zlib_rs
:
:
deflate
:
:
copy
(
dest
source
)
as
_
}
#
[
export_name
=
prefix
!
(
deflateInit_
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateInit_
(
strm
:
z_streamp
level
:
c_int
version
:
*
const
c_char
stream_size
:
c_int
)
-
>
c_int
{
let
config
=
DeflateConfig
:
:
new
(
level
)
;
unsafe
{
deflateInit2_
(
strm
level
config
.
method
as
c_int
config
.
window_bits
config
.
mem_level
config
.
strategy
as
c_int
version
stream_size
)
}
}
#
[
export_name
=
prefix
!
(
deflateInit2_
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateInit2_
(
strm
:
z_streamp
level
:
c_int
method
:
c_int
windowBits
:
c_int
memLevel
:
c_int
strategy
:
c_int
version
:
*
const
c_char
stream_size
:
c_int
)
-
>
c_int
{
if
!
is_version_compatible
(
version
stream_size
)
{
return
ReturnCode
:
:
VersionError
as
_
;
}
let
Some
(
strm
)
=
(
unsafe
{
strm
.
as_mut
(
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Ok
(
method
)
=
Method
:
:
try_from
(
method
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
Ok
(
strategy
)
=
Strategy
:
:
try_from
(
strategy
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
let
config
=
DeflateConfig
{
level
method
window_bits
:
windowBits
mem_level
:
memLevel
strategy
}
;
zlib_rs
:
:
deflate
:
:
init
(
strm
config
)
as
_
}
#
[
export_name
=
prefix
!
(
deflateTune
)
]
pub
unsafe
extern
"
C
-
unwind
"
fn
deflateTune
(
strm
:
z_streamp
good_length
:
c_int
max_lazy
:
c_int
nice_length
:
c_int
max_chain
:
c_int
)
-
>
c_int
{
let
Some
(
stream
)
=
(
unsafe
{
DeflateStream
:
:
from_stream_mut
(
strm
)
}
)
else
{
return
ReturnCode
:
:
StreamError
as
_
;
}
;
zlib_rs
:
:
deflate
:
:
tune
(
stream
good_length
as
usize
max_lazy
as
usize
nice_length
as
usize
max_chain
as
usize
)
as
_
}
#
[
export_name
=
prefix
!
(
zError
)
]
pub
const
extern
"
C
"
fn
zError
(
err
:
c_int
)
-
>
*
const
c_char
{
match
ReturnCode
:
:
try_from_c_int
(
err
)
{
Some
(
return_code
)
=
>
return_code
.
error_message
(
)
None
=
>
[
0
as
c_char
]
.
as_ptr
(
)
}
}
macro_rules
!
libz_rs_sys_version
{
(
)
=
>
{
concat
!
(
"
1
.
3
.
0
-
zlib
-
rs
-
"
env
!
(
"
CARGO_PKG_VERSION
"
)
"
\
0
"
)
}
;
}
const
LIBZ_RS_SYS_VERSION
:
&
str
=
concat
!
(
libz_rs_sys_version
!
(
)
"
\
0
"
)
;
unsafe
fn
is_version_compatible
(
version
:
*
const
c_char
stream_size
:
i32
)
-
>
bool
{
let
Some
(
expected_major_version
)
=
(
unsafe
{
version
.
as_ref
(
)
}
)
else
{
return
false
;
}
;
if
*
expected_major_version
as
u8
!
=
LIBZ_RS_SYS_VERSION
.
as_bytes
(
)
[
0
]
{
return
false
;
}
core
:
:
mem
:
:
size_of
:
:
<
z_stream
>
(
)
as
i32
=
=
stream_size
}
#
[
doc
=
libz_rs_sys_version
!
(
)
]
#
[
export_name
=
prefix
!
(
zlibVersion
)
]
pub
const
extern
"
C
"
fn
zlibVersion
(
)
-
>
*
const
c_char
{
LIBZ_RS_SYS_VERSION
.
as_ptr
(
)
.
cast
:
:
<
c_char
>
(
)
}
unsafe
fn
slice_from_raw_parts
<
'
a
T
>
(
ptr
:
*
const
T
len
:
usize
)
-
>
Option
<
&
'
a
[
T
]
>
{
if
ptr
.
is_null
(
)
{
None
}
else
{
Some
(
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
ptr
len
)
}
)
}
}
unsafe
fn
slice_from_raw_parts_uninit_mut
<
'
a
T
>
(
ptr
:
*
mut
T
len
:
usize
)
-
>
Option
<
&
'
a
mut
[
MaybeUninit
<
T
>
]
>
{
if
ptr
.
is_null
(
)
{
None
}
else
{
Some
(
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
ptr
.
cast
:
:
<
MaybeUninit
<
T
>
>
(
)
len
)
}
)
}
}
