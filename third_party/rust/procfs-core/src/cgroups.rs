use
crate
:
:
ProcResult
;
#
[
cfg
(
feature
=
"
serde1
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
io
:
:
BufRead
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
CGroupController
{
pub
name
:
String
pub
hierarchy
:
u32
pub
num_cgroups
:
u32
pub
enabled
:
bool
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
CGroupControllers
(
pub
Vec
<
CGroupController
>
)
;
impl
crate
:
:
FromBufRead
for
CGroupControllers
{
fn
from_buf_read
<
R
:
BufRead
>
(
reader
:
R
)
-
>
ProcResult
<
Self
>
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
line
in
reader
.
lines
(
)
{
let
line
=
line
?
;
if
line
.
starts_with
(
'
#
'
)
{
continue
;
}
let
mut
s
=
line
.
split_whitespace
(
)
;
let
name
=
expect
!
(
s
.
next
(
)
"
name
"
)
.
to_owned
(
)
;
let
hierarchy
=
from_str
!
(
u32
expect
!
(
s
.
next
(
)
"
hierarchy
"
)
)
;
let
num_cgroups
=
from_str
!
(
u32
expect
!
(
s
.
next
(
)
"
num_cgroups
"
)
)
;
let
enabled
=
expect
!
(
s
.
next
(
)
"
enabled
"
)
=
=
"
1
"
;
vec
.
push
(
CGroupController
{
name
hierarchy
num_cgroups
enabled
}
)
;
}
Ok
(
CGroupControllers
(
vec
)
)
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
ProcessCGroup
{
pub
hierarchy
:
u32
pub
controllers
:
Vec
<
String
>
pub
pathname
:
String
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
ProcessCGroups
(
pub
Vec
<
ProcessCGroup
>
)
;
impl
crate
:
:
FromBufRead
for
ProcessCGroups
{
fn
from_buf_read
<
R
:
BufRead
>
(
reader
:
R
)
-
>
ProcResult
<
Self
>
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
line
in
reader
.
lines
(
)
{
let
line
=
line
?
;
if
line
.
starts_with
(
'
#
'
)
{
continue
;
}
let
mut
s
=
line
.
splitn
(
3
'
:
'
)
;
let
hierarchy
=
from_str
!
(
u32
expect
!
(
s
.
next
(
)
"
hierarchy
"
)
)
;
let
controllers
=
expect
!
(
s
.
next
(
)
"
controllers
"
)
.
split
(
'
'
)
.
filter
(
|
s
|
!
s
.
is_empty
(
)
)
.
map
(
|
s
|
s
.
to_owned
(
)
)
.
collect
(
)
;
let
pathname
=
expect
!
(
s
.
next
(
)
"
path
"
)
.
to_owned
(
)
;
vec
.
push
(
ProcessCGroup
{
hierarchy
controllers
pathname
}
)
;
}
Ok
(
ProcessCGroups
(
vec
)
)
}
}
impl
IntoIterator
for
ProcessCGroups
{
type
IntoIter
=
std
:
:
vec
:
:
IntoIter
<
ProcessCGroup
>
;
type
Item
=
ProcessCGroup
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
0
.
into_iter
(
)
}
}
impl
<
'
a
>
IntoIterator
for
&
'
a
ProcessCGroups
{
type
IntoIter
=
std
:
:
slice
:
:
Iter
<
'
a
ProcessCGroup
>
;
type
Item
=
&
'
a
ProcessCGroup
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
0
.
iter
(
)
}
}
