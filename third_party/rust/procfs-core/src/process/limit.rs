use
crate
:
:
{
ProcError
ProcResult
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
io
:
:
BufRead
;
use
std
:
:
str
:
:
FromStr
;
#
[
cfg
(
feature
=
"
serde1
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Limits
{
pub
max_cpu_time
:
Limit
pub
max_file_size
:
Limit
pub
max_data_size
:
Limit
pub
max_stack_size
:
Limit
pub
max_core_file_size
:
Limit
pub
max_resident_set
:
Limit
pub
max_processes
:
Limit
pub
max_open_files
:
Limit
pub
max_locked_memory
:
Limit
pub
max_address_space
:
Limit
pub
max_file_locks
:
Limit
pub
max_pending_signals
:
Limit
pub
max_msgqueue_size
:
Limit
pub
max_nice_priority
:
Limit
pub
max_realtime_priority
:
Limit
pub
max_realtime_timeout
:
Limit
}
impl
crate
:
:
FromBufRead
for
Limits
{
fn
from_buf_read
<
R
:
BufRead
>
(
r
:
R
)
-
>
ProcResult
<
Self
>
{
let
mut
lines
=
r
.
lines
(
)
;
let
mut
map
=
HashMap
:
:
new
(
)
;
while
let
Some
(
Ok
(
line
)
)
=
lines
.
next
(
)
{
let
line
=
line
.
trim
(
)
;
if
line
.
starts_with
(
"
Limit
"
)
{
continue
;
}
let
s
:
Vec
<
_
>
=
line
.
split_whitespace
(
)
.
collect
(
)
;
let
l
=
s
.
len
(
)
;
let
(
hard_limit
soft_limit
name
)
=
if
line
.
starts_with
(
"
Max
nice
priority
"
)
|
|
line
.
starts_with
(
"
Max
realtime
priority
"
)
{
let
hard_limit
=
expect
!
(
s
.
get
(
l
-
1
)
)
.
to_owned
(
)
;
let
soft_limit
=
expect
!
(
s
.
get
(
l
-
2
)
)
.
to_owned
(
)
;
let
name
=
s
[
0
.
.
l
-
2
]
.
join
(
"
"
)
;
(
hard_limit
soft_limit
name
)
}
else
{
let
hard_limit
=
expect
!
(
s
.
get
(
l
-
2
)
)
.
to_owned
(
)
;
let
soft_limit
=
expect
!
(
s
.
get
(
l
-
3
)
)
.
to_owned
(
)
;
let
name
=
s
[
0
.
.
l
-
3
]
.
join
(
"
"
)
;
(
hard_limit
soft_limit
name
)
}
;
let
_units
=
expect
!
(
s
.
get
(
l
-
1
)
)
;
map
.
insert
(
name
.
to_owned
(
)
(
soft_limit
.
to_owned
(
)
hard_limit
.
to_owned
(
)
)
)
;
}
let
limits
=
Limits
{
max_cpu_time
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
cpu
time
"
)
)
)
?
max_file_size
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
file
size
"
)
)
)
?
max_data_size
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
data
size
"
)
)
)
?
max_stack_size
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
stack
size
"
)
)
)
?
max_core_file_size
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
core
file
size
"
)
)
)
?
max_resident_set
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
resident
set
"
)
)
)
?
max_processes
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
processes
"
)
)
)
?
max_open_files
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
open
files
"
)
)
)
?
max_locked_memory
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
locked
memory
"
)
)
)
?
max_address_space
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
address
space
"
)
)
)
?
max_file_locks
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
file
locks
"
)
)
)
?
max_pending_signals
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
pending
signals
"
)
)
)
?
max_msgqueue_size
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
msgqueue
size
"
)
)
)
?
max_nice_priority
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
nice
priority
"
)
)
)
?
max_realtime_priority
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
realtime
priority
"
)
)
)
?
max_realtime_timeout
:
Limit
:
:
from_pair
(
expect
!
(
map
.
remove
(
"
Max
realtime
timeout
"
)
)
)
?
}
;
if
cfg
!
(
test
)
{
assert
!
(
map
.
is_empty
(
)
"
Map
isn
'
t
empty
:
{
:
?
}
"
map
)
;
}
Ok
(
limits
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Limit
{
pub
soft_limit
:
LimitValue
pub
hard_limit
:
LimitValue
}
impl
Limit
{
fn
from_pair
(
l
:
(
String
String
)
)
-
>
ProcResult
<
Limit
>
{
let
(
soft
hard
)
=
l
;
Ok
(
Limit
{
soft_limit
:
LimitValue
:
:
from_str
(
&
soft
)
?
hard_limit
:
LimitValue
:
:
from_str
(
&
hard
)
?
}
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
LimitValue
{
Unlimited
Value
(
u64
)
}
impl
FromStr
for
LimitValue
{
type
Err
=
ProcError
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
if
s
=
=
"
unlimited
"
{
Ok
(
LimitValue
:
:
Unlimited
)
}
else
{
Ok
(
LimitValue
:
:
Value
(
from_str
!
(
u64
s
)
)
)
}
}
}
