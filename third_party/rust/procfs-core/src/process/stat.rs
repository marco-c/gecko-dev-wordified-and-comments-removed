use
super
:
:
ProcState
;
use
super
:
:
StatFlags
;
use
crate
:
:
{
from_iter
from_iter_optional
ProcResult
}
;
#
[
cfg
(
feature
=
"
serde1
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
str
:
:
FromStr
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
struct
Stat
{
pub
pid
:
i32
pub
comm
:
String
pub
state
:
char
pub
ppid
:
i32
pub
pgrp
:
i32
pub
session
:
i32
pub
tty_nr
:
i32
pub
tpgid
:
i32
pub
flags
:
u32
pub
minflt
:
u64
pub
cminflt
:
u64
pub
majflt
:
u64
pub
cmajflt
:
u64
pub
utime
:
u64
pub
stime
:
u64
pub
cutime
:
i64
pub
cstime
:
i64
pub
priority
:
i64
pub
nice
:
i64
pub
num_threads
:
i64
pub
itrealvalue
:
i64
#
[
cfg_attr
(
feature
=
"
chrono
"
doc
=
"
See
also
the
[
Stat
:
:
starttime
(
)
]
method
to
get
the
starttime
as
a
DateTime
object
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
chrono
"
)
doc
=
"
If
you
compile
with
the
optional
chrono
feature
you
can
use
the
starttime
(
)
method
to
get
the
starttime
as
a
DateTime
object
"
)
]
pub
starttime
:
u64
pub
vsize
:
u64
pub
rss
:
u64
pub
rsslim
:
u64
pub
startcode
:
u64
pub
endcode
:
u64
pub
startstack
:
u64
pub
kstkesp
:
u64
pub
kstkeip
:
u64
pub
signal
:
u64
pub
blocked
:
u64
pub
sigignore
:
u64
pub
sigcatch
:
u64
pub
wchan
:
u64
pub
nswap
:
u64
pub
cnswap
:
u64
pub
exit_signal
:
Option
<
i32
>
pub
processor
:
Option
<
i32
>
pub
rt_priority
:
Option
<
u32
>
pub
policy
:
Option
<
u32
>
pub
delayacct_blkio_ticks
:
Option
<
u64
>
pub
guest_time
:
Option
<
u64
>
pub
cguest_time
:
Option
<
i64
>
pub
start_data
:
Option
<
u64
>
pub
end_data
:
Option
<
u64
>
pub
start_brk
:
Option
<
u64
>
pub
arg_start
:
Option
<
u64
>
pub
arg_end
:
Option
<
u64
>
pub
env_start
:
Option
<
u64
>
pub
env_end
:
Option
<
u64
>
pub
exit_code
:
Option
<
i32
>
}
impl
crate
:
:
FromRead
for
Stat
{
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
from_read
<
R
:
Read
>
(
mut
r
:
R
)
-
>
ProcResult
<
Self
>
{
let
mut
buf
=
Vec
:
:
with_capacity
(
512
)
;
r
.
read_to_end
(
&
mut
buf
)
?
;
let
line
=
String
:
:
from_utf8_lossy
(
&
buf
)
;
let
buf
=
line
.
trim
(
)
;
let
start_paren
=
expect
!
(
buf
.
find
(
'
(
'
)
)
;
let
end_paren
=
expect
!
(
buf
.
rfind
(
'
)
'
)
)
;
let
pid_s
=
&
buf
[
.
.
start_paren
-
1
]
;
let
comm
=
buf
[
start_paren
+
1
.
.
end_paren
]
.
to_string
(
)
;
let
rest
=
&
buf
[
end_paren
+
2
.
.
]
;
let
pid
=
expect
!
(
FromStr
:
:
from_str
(
pid_s
)
)
;
let
mut
rest
=
rest
.
split
(
'
'
)
;
let
state
=
expect
!
(
expect
!
(
rest
.
next
(
)
)
.
chars
(
)
.
next
(
)
)
;
let
ppid
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
pgrp
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
session
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
tty_nr
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
tpgid
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
flags
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
minflt
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
cminflt
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
majflt
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
cmajflt
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
utime
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
stime
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
cutime
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
cstime
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
priority
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
nice
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
num_threads
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
itrealvalue
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
starttime
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
vsize
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
rss
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
rsslim
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
startcode
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
endcode
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
startstack
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
kstkesp
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
kstkeip
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
signal
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
blocked
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
sigignore
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
sigcatch
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
wchan
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
nswap
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
cnswap
=
expect
!
(
from_iter
(
&
mut
rest
)
)
;
let
exit_signal
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
processor
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
rt_priority
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
policy
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
delayacct_blkio_ticks
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
guest_time
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
cguest_time
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
start_data
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
end_data
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
start_brk
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
arg_start
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
arg_end
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
env_start
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
env_end
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
let
exit_code
=
expect
!
(
from_iter_optional
(
&
mut
rest
)
)
;
Ok
(
Stat
{
pid
comm
state
ppid
pgrp
session
tty_nr
tpgid
flags
minflt
cminflt
majflt
cmajflt
utime
stime
cutime
cstime
priority
nice
num_threads
itrealvalue
starttime
vsize
rss
rsslim
startcode
endcode
startstack
kstkesp
kstkeip
signal
blocked
sigignore
sigcatch
wchan
nswap
cnswap
exit_signal
processor
rt_priority
policy
delayacct_blkio_ticks
guest_time
cguest_time
start_data
end_data
start_brk
arg_start
arg_end
env_start
env_end
exit_code
}
)
}
}
impl
Stat
{
pub
fn
state
(
&
self
)
-
>
ProcResult
<
ProcState
>
{
ProcState
:
:
from_char
(
self
.
state
)
.
ok_or_else
(
|
|
build_internal_error
!
(
format
!
(
"
{
:
?
}
is
not
a
recognized
process
state
"
self
.
state
)
)
)
}
pub
fn
tty_nr
(
&
self
)
-
>
(
i32
i32
)
{
let
major
=
(
self
.
tty_nr
&
0xfff00
)
>
>
8
;
let
minor
=
(
self
.
tty_nr
&
0x000ff
)
|
(
(
self
.
tty_nr
>
>
12
)
&
0xfff00
)
;
(
major
minor
)
}
pub
fn
flags
(
&
self
)
-
>
ProcResult
<
StatFlags
>
{
StatFlags
:
:
from_bits
(
self
.
flags
)
.
ok_or_else
(
|
|
build_internal_error
!
(
format
!
(
"
Can
'
t
construct
flags
bitfield
from
{
:
?
}
"
self
.
flags
)
)
)
}
#
[
cfg
(
feature
=
"
chrono
"
)
]
pub
fn
starttime
(
&
self
)
-
>
impl
crate
:
:
WithSystemInfo
<
Output
=
ProcResult
<
chrono
:
:
DateTime
<
chrono
:
:
Local
>
>
>
{
move
|
si
:
&
crate
:
:
SystemInfo
|
{
let
seconds_since_boot
=
self
.
starttime
as
f32
/
si
.
ticks_per_second
(
)
as
f32
;
Ok
(
si
.
boot_time
(
)
?
+
chrono
:
:
Duration
:
:
milliseconds
(
(
seconds_since_boot
*
1000
.
0
)
as
i64
)
)
}
}
pub
fn
rss_bytes
(
&
self
)
-
>
impl
crate
:
:
WithSystemInfo
<
Output
=
u64
>
{
move
|
si
:
&
crate
:
:
SystemInfo
|
self
.
rss
*
si
.
page_size
(
)
}
}
