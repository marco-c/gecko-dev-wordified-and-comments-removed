use
super
:
:
{
expect
from_str
ProcResult
}
;
#
[
cfg
(
feature
=
"
serde1
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
{
collections
:
:
HashMap
io
}
;
fn
convert_to_kibibytes
(
num
:
u64
unit
:
&
str
)
-
>
ProcResult
<
u64
>
{
match
unit
{
"
B
"
=
>
Ok
(
num
)
"
KiB
"
|
"
kiB
"
|
"
kB
"
|
"
KB
"
=
>
Ok
(
num
*
1024
)
"
MiB
"
|
"
miB
"
|
"
MB
"
|
"
mB
"
=
>
Ok
(
num
*
1024
*
1024
)
"
GiB
"
|
"
giB
"
|
"
GB
"
|
"
gB
"
=
>
Ok
(
num
*
1024
*
1024
*
1024
)
unknown
=
>
Err
(
build_internal_error
!
(
format
!
(
"
Unknown
unit
type
{
}
"
unknown
)
)
)
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
Serialize
Deserialize
)
)
]
#
[
allow
(
non_snake_case
)
]
#
[
non_exhaustive
]
pub
struct
Meminfo
{
pub
mem_total
:
u64
pub
mem_free
:
u64
pub
mem_available
:
Option
<
u64
>
pub
buffers
:
u64
pub
cached
:
u64
pub
swap_cached
:
u64
pub
active
:
u64
pub
inactive
:
u64
pub
active_anon
:
Option
<
u64
>
pub
inactive_anon
:
Option
<
u64
>
pub
active_file
:
Option
<
u64
>
pub
inactive_file
:
Option
<
u64
>
pub
unevictable
:
Option
<
u64
>
pub
mlocked
:
Option
<
u64
>
pub
high_total
:
Option
<
u64
>
pub
high_free
:
Option
<
u64
>
pub
low_total
:
Option
<
u64
>
pub
low_free
:
Option
<
u64
>
pub
mmap_copy
:
Option
<
u64
>
pub
swap_total
:
u64
pub
swap_free
:
u64
pub
dirty
:
u64
pub
writeback
:
u64
pub
anon_pages
:
Option
<
u64
>
pub
mapped
:
u64
pub
shmem
:
Option
<
u64
>
pub
slab
:
u64
pub
s_reclaimable
:
Option
<
u64
>
pub
s_unreclaim
:
Option
<
u64
>
pub
kernel_stack
:
Option
<
u64
>
pub
page_tables
:
Option
<
u64
>
pub
secondary_page_tables
:
Option
<
u64
>
pub
quicklists
:
Option
<
u64
>
pub
nfs_unstable
:
Option
<
u64
>
pub
bounce
:
Option
<
u64
>
pub
writeback_tmp
:
Option
<
u64
>
pub
commit_limit
:
Option
<
u64
>
pub
committed_as
:
u64
pub
vmalloc_total
:
u64
pub
vmalloc_used
:
u64
pub
vmalloc_chunk
:
u64
pub
hardware_corrupted
:
Option
<
u64
>
pub
anon_hugepages
:
Option
<
u64
>
pub
shmem_hugepages
:
Option
<
u64
>
pub
shmem_pmd_mapped
:
Option
<
u64
>
pub
cma_total
:
Option
<
u64
>
pub
cma_free
:
Option
<
u64
>
pub
hugepages_total
:
Option
<
u64
>
pub
hugepages_free
:
Option
<
u64
>
pub
hugepages_rsvd
:
Option
<
u64
>
pub
hugepages_surp
:
Option
<
u64
>
pub
hugepagesize
:
Option
<
u64
>
pub
direct_map_4k
:
Option
<
u64
>
pub
direct_map_4M
:
Option
<
u64
>
pub
direct_map_2M
:
Option
<
u64
>
pub
direct_map_1G
:
Option
<
u64
>
pub
hugetlb
:
Option
<
u64
>
pub
per_cpu
:
Option
<
u64
>
pub
k_reclaimable
:
Option
<
u64
>
pub
file_pmd_mapped
:
Option
<
u64
>
pub
file_huge_pages
:
Option
<
u64
>
pub
z_swap
:
Option
<
u64
>
pub
z_swapped
:
Option
<
u64
>
}
impl
super
:
:
FromBufRead
for
Meminfo
{
fn
from_buf_read
<
R
:
io
:
:
BufRead
>
(
r
:
R
)
-
>
ProcResult
<
Self
>
{
let
mut
map
=
HashMap
:
:
new
(
)
;
for
line
in
r
.
lines
(
)
{
let
line
=
expect
!
(
line
)
;
if
line
.
is_empty
(
)
{
continue
;
}
let
mut
s
=
line
.
split_whitespace
(
)
;
let
field
=
expect
!
(
s
.
next
(
)
"
no
field
"
)
;
let
value
=
expect
!
(
s
.
next
(
)
"
no
value
"
)
;
let
unit
=
s
.
next
(
)
;
let
value
=
from_str
!
(
u64
value
)
;
let
value
=
if
let
Some
(
unit
)
=
unit
{
convert_to_kibibytes
(
value
unit
)
?
}
else
{
value
}
;
map
.
insert
(
field
[
.
.
field
.
len
(
)
-
1
]
.
to_string
(
)
value
)
;
}
let
meminfo
=
Meminfo
{
mem_total
:
expect
!
(
map
.
remove
(
"
MemTotal
"
)
)
mem_free
:
expect
!
(
map
.
remove
(
"
MemFree
"
)
)
mem_available
:
map
.
remove
(
"
MemAvailable
"
)
buffers
:
expect
!
(
map
.
remove
(
"
Buffers
"
)
)
cached
:
expect
!
(
map
.
remove
(
"
Cached
"
)
)
swap_cached
:
expect
!
(
map
.
remove
(
"
SwapCached
"
)
)
active
:
expect
!
(
map
.
remove
(
"
Active
"
)
)
inactive
:
expect
!
(
map
.
remove
(
"
Inactive
"
)
)
active_anon
:
map
.
remove
(
"
Active
(
anon
)
"
)
inactive_anon
:
map
.
remove
(
"
Inactive
(
anon
)
"
)
active_file
:
map
.
remove
(
"
Active
(
file
)
"
)
inactive_file
:
map
.
remove
(
"
Inactive
(
file
)
"
)
unevictable
:
map
.
remove
(
"
Unevictable
"
)
mlocked
:
map
.
remove
(
"
Mlocked
"
)
high_total
:
map
.
remove
(
"
HighTotal
"
)
high_free
:
map
.
remove
(
"
HighFree
"
)
low_total
:
map
.
remove
(
"
LowTotal
"
)
low_free
:
map
.
remove
(
"
LowFree
"
)
mmap_copy
:
map
.
remove
(
"
MmapCopy
"
)
swap_total
:
expect
!
(
map
.
remove
(
"
SwapTotal
"
)
)
swap_free
:
expect
!
(
map
.
remove
(
"
SwapFree
"
)
)
dirty
:
expect
!
(
map
.
remove
(
"
Dirty
"
)
)
writeback
:
expect
!
(
map
.
remove
(
"
Writeback
"
)
)
anon_pages
:
map
.
remove
(
"
AnonPages
"
)
mapped
:
expect
!
(
map
.
remove
(
"
Mapped
"
)
)
shmem
:
map
.
remove
(
"
Shmem
"
)
slab
:
expect
!
(
map
.
remove
(
"
Slab
"
)
)
s_reclaimable
:
map
.
remove
(
"
SReclaimable
"
)
s_unreclaim
:
map
.
remove
(
"
SUnreclaim
"
)
kernel_stack
:
map
.
remove
(
"
KernelStack
"
)
page_tables
:
map
.
remove
(
"
PageTables
"
)
secondary_page_tables
:
map
.
remove
(
"
SecPageTables
"
)
quicklists
:
map
.
remove
(
"
Quicklists
"
)
nfs_unstable
:
map
.
remove
(
"
NFS_Unstable
"
)
bounce
:
map
.
remove
(
"
Bounce
"
)
writeback_tmp
:
map
.
remove
(
"
WritebackTmp
"
)
commit_limit
:
map
.
remove
(
"
CommitLimit
"
)
committed_as
:
expect
!
(
map
.
remove
(
"
Committed_AS
"
)
)
vmalloc_total
:
expect
!
(
map
.
remove
(
"
VmallocTotal
"
)
)
vmalloc_used
:
expect
!
(
map
.
remove
(
"
VmallocUsed
"
)
)
vmalloc_chunk
:
expect
!
(
map
.
remove
(
"
VmallocChunk
"
)
)
hardware_corrupted
:
map
.
remove
(
"
HardwareCorrupted
"
)
anon_hugepages
:
map
.
remove
(
"
AnonHugePages
"
)
shmem_hugepages
:
map
.
remove
(
"
ShmemHugePages
"
)
shmem_pmd_mapped
:
map
.
remove
(
"
ShmemPmdMapped
"
)
cma_total
:
map
.
remove
(
"
CmaTotal
"
)
cma_free
:
map
.
remove
(
"
CmaFree
"
)
hugepages_total
:
map
.
remove
(
"
HugePages_Total
"
)
hugepages_free
:
map
.
remove
(
"
HugePages_Free
"
)
hugepages_rsvd
:
map
.
remove
(
"
HugePages_Rsvd
"
)
hugepages_surp
:
map
.
remove
(
"
HugePages_Surp
"
)
hugepagesize
:
map
.
remove
(
"
Hugepagesize
"
)
direct_map_4k
:
map
.
remove
(
"
DirectMap4k
"
)
direct_map_4M
:
map
.
remove
(
"
DirectMap4M
"
)
direct_map_2M
:
map
.
remove
(
"
DirectMap2M
"
)
direct_map_1G
:
map
.
remove
(
"
DirectMap1G
"
)
k_reclaimable
:
map
.
remove
(
"
KReclaimable
"
)
per_cpu
:
map
.
remove
(
"
Percpu
"
)
hugetlb
:
map
.
remove
(
"
Hugetlb
"
)
file_pmd_mapped
:
map
.
remove
(
"
FilePmdMapped
"
)
file_huge_pages
:
map
.
remove
(
"
FileHugePages
"
)
z_swap
:
map
.
remove
(
"
Zswap
"
)
z_swapped
:
map
.
remove
(
"
Zswapped
"
)
}
;
if
cfg
!
(
test
)
{
assert
!
(
map
.
is_empty
(
)
"
meminfo
map
is
not
empty
:
{
:
#
?
}
"
map
)
;
}
Ok
(
meminfo
)
}
}
