use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
io
;
use
std
:
:
net
:
:
{
SocketAddr
ToSocketAddrs
TcpListener
TcpStream
}
;
use
std
:
:
fmt
;
use
IntoInner
;
use
socket
:
:
Socket
;
use
sys
:
:
c
;
pub
struct
TcpBuilder
{
socket
:
RefCell
<
Option
<
Socket
>
>
}
impl
TcpBuilder
{
pub
fn
new_v4
(
)
-
>
io
:
:
Result
<
TcpBuilder
>
{
Socket
:
:
new
(
c
:
:
AF_INET
c
:
:
SOCK_STREAM
)
.
map
(
:
:
FromInner
:
:
from_inner
)
}
pub
fn
new_v6
(
)
-
>
io
:
:
Result
<
TcpBuilder
>
{
Socket
:
:
new
(
c
:
:
AF_INET6
c
:
:
SOCK_STREAM
)
.
map
(
:
:
FromInner
:
:
from_inner
)
}
pub
fn
bind
<
T
>
(
&
self
addr
:
T
)
-
>
io
:
:
Result
<
&
TcpBuilder
>
where
T
:
ToSocketAddrs
{
self
.
with_socket
(
|
sock
|
{
let
addr
=
try
!
(
:
:
one_addr
(
addr
)
)
;
sock
.
bind
(
&
addr
)
}
)
.
map
(
|
(
)
|
self
)
}
pub
fn
listen
(
&
self
backlog
:
i32
)
-
>
io
:
:
Result
<
TcpListener
>
{
self
.
with_socket
(
|
sock
|
{
sock
.
listen
(
backlog
)
}
)
.
and_then
(
|
(
)
|
{
self
.
to_tcp_listener
(
)
}
)
}
pub
fn
connect
<
T
>
(
&
self
addr
:
T
)
-
>
io
:
:
Result
<
TcpStream
>
where
T
:
ToSocketAddrs
{
self
.
with_socket
(
|
sock
|
{
let
err
=
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
no
socket
addresses
resolved
"
)
;
try
!
(
addr
.
to_socket_addrs
(
)
)
.
fold
(
Err
(
err
)
|
prev
addr
|
{
prev
.
or_else
(
|
_
|
sock
.
connect
(
&
addr
)
)
}
)
}
)
.
and_then
(
|
(
)
|
{
self
.
to_tcp_stream
(
)
}
)
}
pub
fn
to_tcp_stream
(
&
self
)
-
>
io
:
:
Result
<
TcpStream
>
{
self
.
socket
.
borrow_mut
(
)
.
take
(
)
.
map
(
|
s
|
s
.
into_inner
(
)
.
into_tcp_stream
(
)
)
.
ok_or
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
socket
has
already
been
consumed
"
)
)
}
pub
fn
to_tcp_listener
(
&
self
)
-
>
io
:
:
Result
<
TcpListener
>
{
self
.
socket
.
borrow_mut
(
)
.
take
(
)
.
map
(
|
s
|
s
.
into_inner
(
)
.
into_tcp_listener
(
)
)
.
ok_or
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
socket
has
already
been
consumed
"
)
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
match
*
self
.
socket
.
borrow
(
)
{
Some
(
ref
s
)
=
>
s
.
getsockname
(
)
None
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
builder
has
already
finished
its
socket
"
)
)
}
}
fn
with_socket
<
F
>
(
&
self
f
:
F
)
-
>
io
:
:
Result
<
(
)
>
where
F
:
FnOnce
(
&
Socket
)
-
>
io
:
:
Result
<
(
)
>
{
match
*
self
.
socket
.
borrow
(
)
{
Some
(
ref
s
)
=
>
f
(
s
)
None
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
builder
has
already
finished
its
socket
"
)
)
}
}
}
impl
fmt
:
:
Debug
for
TcpBuilder
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
TcpBuilder
{
{
socket
:
{
:
?
}
}
}
"
self
.
socket
.
borrow
(
)
.
as_ref
(
)
.
unwrap
(
)
)
}
}
impl
:
:
AsInner
for
TcpBuilder
{
type
Inner
=
RefCell
<
Option
<
Socket
>
>
;
fn
as_inner
(
&
self
)
-
>
&
RefCell
<
Option
<
Socket
>
>
{
&
self
.
socket
}
}
impl
:
:
FromInner
for
TcpBuilder
{
type
Inner
=
Socket
;
fn
from_inner
(
sock
:
Socket
)
-
>
TcpBuilder
{
TcpBuilder
{
socket
:
RefCell
:
:
new
(
Some
(
sock
)
)
}
}
}
