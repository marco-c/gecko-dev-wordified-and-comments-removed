#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
net2
-
rs
"
)
]
#
!
[
deny
(
missing_docs
warnings
)
]
#
[
cfg
(
unix
)
]
extern
crate
libc
;
#
[
cfg
(
windows
)
]
extern
crate
kernel32
;
#
[
cfg
(
windows
)
]
extern
crate
winapi
;
#
[
cfg
(
windows
)
]
extern
crate
ws2_32
;
#
[
macro_use
]
extern
crate
cfg_if
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
Neg
;
use
std
:
:
net
:
:
{
ToSocketAddrs
SocketAddr
}
;
use
utils
:
:
{
One
NetInt
}
;
mod
tcp
;
mod
udp
;
mod
socket
;
mod
ext
;
mod
utils
;
#
[
cfg
(
unix
)
]
#
[
path
=
"
sys
/
unix
/
mod
.
rs
"
]
mod
sys
;
#
[
cfg
(
windows
)
]
#
[
path
=
"
sys
/
windows
/
mod
.
rs
"
]
mod
sys
;
#
[
cfg
(
all
(
unix
not
(
any
(
target_os
=
"
solaris
"
)
)
)
)
]
pub
mod
unix
;
pub
use
tcp
:
:
TcpBuilder
;
pub
use
udp
:
:
UdpBuilder
;
pub
use
ext
:
:
{
TcpStreamExt
TcpListenerExt
UdpSocketExt
}
;
fn
one_addr
<
T
:
ToSocketAddrs
>
(
tsa
:
T
)
-
>
io
:
:
Result
<
SocketAddr
>
{
let
mut
addrs
=
try
!
(
tsa
.
to_socket_addrs
(
)
)
;
let
addr
=
match
addrs
.
next
(
)
{
Some
(
addr
)
=
>
addr
None
=
>
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
no
socket
addresses
could
be
resolved
"
)
)
}
;
if
addrs
.
next
(
)
.
is_none
(
)
{
Ok
(
addr
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
more
than
one
address
resolved
"
)
)
}
}
fn
cvt
<
T
:
One
+
PartialEq
+
Neg
<
Output
=
T
>
>
(
t
:
T
)
-
>
io
:
:
Result
<
T
>
{
let
one
:
T
=
T
:
:
one
(
)
;
if
t
=
=
-
one
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
t
)
}
}
#
[
cfg
(
windows
)
]
fn
cvt_win
<
T
:
PartialEq
+
utils
:
:
Zero
>
(
t
:
T
)
-
>
io
:
:
Result
<
T
>
{
if
t
=
=
T
:
:
zero
(
)
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
t
)
}
}
fn
hton
<
I
:
NetInt
>
(
i
:
I
)
-
>
I
{
i
.
to_be
(
)
}
fn
ntoh
<
I
:
NetInt
>
(
i
:
I
)
-
>
I
{
I
:
:
from_be
(
i
)
}
trait
AsInner
{
type
Inner
;
fn
as_inner
(
&
self
)
-
>
&
Self
:
:
Inner
;
}
trait
FromInner
{
type
Inner
;
fn
from_inner
(
inner
:
Self
:
:
Inner
)
-
>
Self
;
}
trait
IntoInner
{
type
Inner
;
fn
into_inner
(
self
)
-
>
Self
:
:
Inner
;
}
