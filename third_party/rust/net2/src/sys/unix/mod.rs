use
std
:
:
io
;
use
std
:
:
mem
;
use
std
:
:
net
:
:
{
TcpListener
TcpStream
UdpSocket
}
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
FromRawFd
;
use
libc
:
:
{
self
c_int
}
;
#
[
cfg
(
not
(
any
(
target_os
=
"
solaris
"
target_os
=
"
emscripten
"
)
)
)
]
use
libc
:
:
{
ioctl
FIOCLEX
}
;
mod
impls
;
pub
mod
c
{
pub
use
libc
:
:
*
;
pub
fn
sockaddr_in_u32
(
sa
:
&
sockaddr_in
)
-
>
u32
{
:
:
ntoh
(
(
*
sa
)
.
sin_addr
.
s_addr
)
}
}
pub
struct
Socket
{
fd
:
c_int
}
impl
Socket
{
#
[
cfg
(
not
(
any
(
target_os
=
"
solaris
"
target_os
=
"
emscripten
"
)
)
)
]
pub
fn
new
(
family
:
c_int
ty
:
c_int
)
-
>
io
:
:
Result
<
Socket
>
{
unsafe
{
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
match
:
:
cvt
(
libc
:
:
socket
(
family
ty
|
libc
:
:
SOCK_CLOEXEC
0
)
)
{
Ok
(
fd
)
=
>
return
Ok
(
Socket
{
fd
:
fd
}
)
Err
(
ref
e
)
if
e
.
raw_os_error
(
)
=
=
Some
(
libc
:
:
EINVAL
)
=
>
{
}
Err
(
e
)
=
>
return
Err
(
e
)
}
let
fd
=
try
!
(
:
:
cvt
(
libc
:
:
socket
(
family
ty
0
)
)
)
;
ioctl
(
fd
FIOCLEX
)
;
Ok
(
Socket
{
fd
:
fd
}
)
}
}
#
[
cfg
(
any
(
target_os
=
"
solaris
"
target_os
=
"
emscripten
"
)
)
]
pub
fn
new
(
family
:
c_int
ty
:
c_int
)
-
>
io
:
:
Result
<
Socket
>
{
unsafe
{
let
fd
=
try
!
(
:
:
cvt
(
libc
:
:
socket
(
family
ty
0
)
)
)
;
libc
:
:
fcntl
(
fd
libc
:
:
FD_CLOEXEC
)
;
Ok
(
Socket
{
fd
:
fd
}
)
}
}
pub
fn
raw
(
&
self
)
-
>
c_int
{
self
.
fd
}
fn
into_fd
(
self
)
-
>
c_int
{
let
fd
=
self
.
fd
;
mem
:
:
forget
(
self
)
;
fd
}
pub
fn
into_tcp_listener
(
self
)
-
>
TcpListener
{
unsafe
{
TcpListener
:
:
from_raw_fd
(
self
.
into_fd
(
)
)
}
}
pub
fn
into_tcp_stream
(
self
)
-
>
TcpStream
{
unsafe
{
TcpStream
:
:
from_raw_fd
(
self
.
into_fd
(
)
)
}
}
pub
fn
into_udp_socket
(
self
)
-
>
UdpSocket
{
unsafe
{
UdpSocket
:
:
from_raw_fd
(
self
.
into_fd
(
)
)
}
}
}
impl
:
:
FromInner
for
Socket
{
type
Inner
=
c_int
;
fn
from_inner
(
fd
:
c_int
)
-
>
Socket
{
Socket
{
fd
:
fd
}
}
}
impl
Drop
for
Socket
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
_
=
libc
:
:
close
(
self
.
fd
)
;
}
}
}
