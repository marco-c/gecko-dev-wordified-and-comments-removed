#
!
[
allow
(
unknown_lints
)
]
#
!
[
deny
(
renamed_and_removed_lints
)
]
#
!
[
deny
(
clippy
:
:
all
clippy
:
:
missing_safety_doc
clippy
:
:
undocumented_unsafe_blocks
)
]
#
!
[
deny
(
rustdoc
:
:
bare_urls
rustdoc
:
:
broken_intra_doc_links
rustdoc
:
:
invalid_codeblock_attributes
rustdoc
:
:
invalid_html_tags
rustdoc
:
:
invalid_rust_codeblocks
rustdoc
:
:
missing_crate_level_docs
rustdoc
:
:
private_intra_doc_links
)
]
#
!
[
recursion_limit
=
"
128
"
]
mod
ext
;
mod
repr
;
use
{
proc_macro2
:
:
Span
quote
:
:
quote
syn
:
:
{
parse_quote
Data
DataEnum
DataStruct
DataUnion
DeriveInput
Error
Expr
ExprLit
GenericParam
Ident
Lit
}
}
;
use
{
crate
:
:
ext
:
:
*
crate
:
:
repr
:
:
*
}
;
macro_rules
!
try_or_print
{
(
e
:
expr
)
=
>
{
match
e
{
Ok
(
x
)
=
>
x
Err
(
errors
)
=
>
return
print_all_errors
(
errors
)
.
into
(
)
}
}
;
}
#
[
proc_macro_derive
(
KnownLayout
)
]
pub
fn
derive_known_layout
(
ts
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
ast
=
syn
:
:
parse_macro_input
!
(
ts
as
DeriveInput
)
;
let
is_repr_c_struct
=
match
&
ast
.
data
{
Data
:
:
Struct
(
.
.
)
=
>
{
let
reprs
=
try_or_print
!
(
repr
:
:
reprs
:
:
<
Repr
>
(
&
ast
.
attrs
)
)
;
if
reprs
.
iter
(
)
.
any
(
|
(
_meta
repr
)
|
repr
=
=
&
Repr
:
:
C
)
{
Some
(
reprs
)
}
else
{
None
}
}
Data
:
:
Enum
(
.
.
)
|
Data
:
:
Union
(
.
.
)
=
>
None
}
;
let
fields
=
ast
.
data
.
field_types
(
)
;
let
(
require_self_sized
extras
)
=
if
let
(
Some
(
reprs
)
Some
(
(
trailing_field
leading_fields
)
)
)
=
(
is_repr_c_struct
fields
.
split_last
(
)
)
{
let
repr_align
=
reprs
.
iter
(
)
.
find_map
(
|
(
_meta
repr
)
|
{
if
let
Repr
:
:
Align
(
repr_align
)
=
repr
{
Some
(
repr_align
)
}
else
{
None
}
}
)
.
map
(
|
repr_align
|
quote
!
(
NonZeroUsize
:
:
new
(
#
repr_align
as
usize
)
)
)
.
unwrap_or
(
quote
!
(
None
)
)
;
let
repr_packed
=
reprs
.
iter
(
)
.
find_map
(
|
(
_meta
repr
)
|
match
repr
{
Repr
:
:
Packed
=
>
Some
(
1
)
Repr
:
:
PackedN
(
repr_packed
)
=
>
Some
(
*
repr_packed
)
_
=
>
None
}
)
.
map
(
|
repr_packed
|
quote
!
(
NonZeroUsize
:
:
new
(
#
repr_packed
as
usize
)
)
)
.
unwrap_or
(
quote
!
(
None
)
)
;
(
false
quote
!
(
/
/
SAFETY
:
LAYOUT
accurately
describes
the
layout
of
Self
.
/
/
The
layout
of
Self
is
reflected
using
a
sequence
of
/
/
invocations
of
DstLayout
:
:
{
new_zst
extend
pad_to_align
}
.
/
/
The
documentation
of
these
items
vows
that
invocations
in
/
/
this
manner
will
acurately
describe
a
type
so
long
as
:
/
/
/
/
-
that
type
is
repr
(
C
)
/
/
-
its
fields
are
enumerated
in
the
order
they
appear
/
/
-
the
presence
of
repr_align
and
repr_packed
are
correctly
accounted
for
.
/
/
/
/
We
respect
all
three
of
these
preconditions
here
.
This
/
/
expansion
is
only
used
if
is_repr_c_struct
we
enumerate
/
/
the
fields
in
order
and
we
extract
the
values
of
align
(
N
)
/
/
and
packed
(
N
)
.
const
LAYOUT
:
:
:
zerocopy
:
:
DstLayout
=
{
use
:
:
zerocopy
:
:
macro_util
:
:
core_reexport
:
:
num
:
:
NonZeroUsize
;
use
:
:
zerocopy
:
:
{
DstLayout
KnownLayout
}
;
let
repr_align
=
#
repr_align
;
let
repr_packed
=
#
repr_packed
;
DstLayout
:
:
new_zst
(
repr_align
)
#
(
.
extend
(
DstLayout
:
:
for_type
:
:
<
#
leading_fields
>
(
)
repr_packed
)
)
*
.
extend
(
<
#
trailing_field
as
KnownLayout
>
:
:
LAYOUT
repr_packed
)
.
pad_to_align
(
)
}
;
/
/
SAFETY
:
/
/
-
The
recursive
call
to
raw_from_ptr_len
preserves
both
address
and
provenance
.
/
/
-
The
as
cast
preserves
both
address
and
provenance
.
/
/
-
NonNull
:
:
new_unchecked
preserves
both
address
and
provenance
.
#
[
inline
(
always
)
]
fn
raw_from_ptr_len
(
bytes
:
:
:
zerocopy
:
:
macro_util
:
:
core_reexport
:
:
ptr
:
:
NonNull
<
u8
>
elems
:
usize
)
-
>
:
:
zerocopy
:
:
macro_util
:
:
core_reexport
:
:
ptr
:
:
NonNull
<
Self
>
{
use
:
:
zerocopy
:
:
{
KnownLayout
}
;
let
trailing
=
<
#
trailing_field
as
KnownLayout
>
:
:
raw_from_ptr_len
(
bytes
elems
)
;
let
slf
=
trailing
.
as_ptr
(
)
as
*
mut
Self
;
/
/
SAFETY
:
Constructed
from
trailing
which
is
non
-
null
.
unsafe
{
:
:
zerocopy
:
:
macro_util
:
:
core_reexport
:
:
ptr
:
:
NonNull
:
:
new_unchecked
(
slf
)
}
}
)
)
}
else
{
(
true
quote
!
(
/
/
SAFETY
:
LAYOUT
is
guaranteed
to
accurately
describe
the
/
/
layout
of
Self
because
that
is
the
documented
safety
/
/
contract
of
DstLayout
:
:
for_type
.
const
LAYOUT
:
:
:
zerocopy
:
:
DstLayout
=
:
:
zerocopy
:
:
DstLayout
:
:
for_type
:
:
<
Self
>
(
)
;
/
/
SAFETY
:
.
cast
preserves
address
and
provenance
.
/
/
/
/
TODO
(
#
429
)
:
Add
documentation
to
.
cast
that
promises
that
/
/
it
preserves
provenance
.
#
[
inline
(
always
)
]
fn
raw_from_ptr_len
(
bytes
:
:
:
zerocopy
:
:
macro_util
:
:
core_reexport
:
:
ptr
:
:
NonNull
<
u8
>
_elems
:
usize
)
-
>
:
:
zerocopy
:
:
macro_util
:
:
core_reexport
:
:
ptr
:
:
NonNull
<
Self
>
{
bytes
.
cast
:
:
<
Self
>
(
)
}
)
)
}
;
match
&
ast
.
data
{
Data
:
:
Struct
(
strct
)
=
>
{
let
require_trait_bound_on_field_types
=
if
require_self_sized
{
RequireBoundedFields
:
:
No
}
else
{
RequireBoundedFields
:
:
Trailing
}
;
impl_block
(
&
ast
strct
Trait
:
:
KnownLayout
require_trait_bound_on_field_types
require_self_sized
None
Some
(
extras
)
)
}
Data
:
:
Enum
(
enm
)
=
>
{
impl_block
(
&
ast
enm
Trait
:
:
KnownLayout
RequireBoundedFields
:
:
No
true
None
Some
(
extras
)
)
}
Data
:
:
Union
(
unn
)
=
>
{
impl_block
(
&
ast
unn
Trait
:
:
KnownLayout
RequireBoundedFields
:
:
No
true
None
Some
(
extras
)
)
}
}
.
into
(
)
}
#
[
proc_macro_derive
(
FromZeroes
)
]
pub
fn
derive_from_zeroes
(
ts
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
ast
=
syn
:
:
parse_macro_input
!
(
ts
as
DeriveInput
)
;
match
&
ast
.
data
{
Data
:
:
Struct
(
strct
)
=
>
derive_from_zeroes_struct
(
&
ast
strct
)
Data
:
:
Enum
(
enm
)
=
>
derive_from_zeroes_enum
(
&
ast
enm
)
Data
:
:
Union
(
unn
)
=
>
derive_from_zeroes_union
(
&
ast
unn
)
}
.
into
(
)
}
#
[
proc_macro_derive
(
FromBytes
)
]
pub
fn
derive_from_bytes
(
ts
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
ast
=
syn
:
:
parse_macro_input
!
(
ts
as
DeriveInput
)
;
match
&
ast
.
data
{
Data
:
:
Struct
(
strct
)
=
>
derive_from_bytes_struct
(
&
ast
strct
)
Data
:
:
Enum
(
enm
)
=
>
derive_from_bytes_enum
(
&
ast
enm
)
Data
:
:
Union
(
unn
)
=
>
derive_from_bytes_union
(
&
ast
unn
)
}
.
into
(
)
}
#
[
proc_macro_derive
(
AsBytes
)
]
pub
fn
derive_as_bytes
(
ts
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
ast
=
syn
:
:
parse_macro_input
!
(
ts
as
DeriveInput
)
;
match
&
ast
.
data
{
Data
:
:
Struct
(
strct
)
=
>
derive_as_bytes_struct
(
&
ast
strct
)
Data
:
:
Enum
(
enm
)
=
>
derive_as_bytes_enum
(
&
ast
enm
)
Data
:
:
Union
(
unn
)
=
>
derive_as_bytes_union
(
&
ast
unn
)
}
.
into
(
)
}
#
[
proc_macro_derive
(
Unaligned
)
]
pub
fn
derive_unaligned
(
ts
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
ast
=
syn
:
:
parse_macro_input
!
(
ts
as
DeriveInput
)
;
match
&
ast
.
data
{
Data
:
:
Struct
(
strct
)
=
>
derive_unaligned_struct
(
&
ast
strct
)
Data
:
:
Enum
(
enm
)
=
>
derive_unaligned_enum
(
&
ast
enm
)
Data
:
:
Union
(
unn
)
=
>
derive_unaligned_union
(
&
ast
unn
)
}
.
into
(
)
}
const
STRUCT_UNION_ALLOWED_REPR_COMBINATIONS
:
&
[
&
[
StructRepr
]
]
=
&
[
&
[
StructRepr
:
:
C
]
&
[
StructRepr
:
:
Transparent
]
&
[
StructRepr
:
:
Packed
]
&
[
StructRepr
:
:
C
StructRepr
:
:
Packed
]
]
;
fn
derive_from_zeroes_struct
(
ast
:
&
DeriveInput
strct
:
&
DataStruct
)
-
>
proc_macro2
:
:
TokenStream
{
impl_block
(
ast
strct
Trait
:
:
FromZeroes
RequireBoundedFields
:
:
Yes
false
None
None
)
}
fn
derive_from_zeroes_enum
(
ast
:
&
DeriveInput
enm
:
&
DataEnum
)
-
>
proc_macro2
:
:
TokenStream
{
if
!
enm
.
is_c_like
(
)
{
return
Error
:
:
new_spanned
(
ast
"
only
C
-
like
enums
can
implement
FromZeroes
"
)
.
to_compile_error
(
)
;
}
let
has_explicit_zero_discriminant
=
enm
.
variants
.
iter
(
)
.
filter_map
(
|
v
|
v
.
discriminant
.
as_ref
(
)
)
.
any
(
|
(
_
e
)
|
{
if
let
Expr
:
:
Lit
(
ExprLit
{
lit
:
Lit
:
:
Int
(
i
)
.
.
}
)
=
e
{
i
.
base10_parse
:
:
<
usize
>
(
)
.
ok
(
)
=
=
Some
(
0
)
}
else
{
false
}
}
)
;
let
has_implicit_zero_discriminant
=
enm
.
variants
.
iter
(
)
.
next
(
)
.
map
(
|
v
|
v
.
discriminant
.
is_none
(
)
)
=
=
Some
(
true
)
;
if
!
has_explicit_zero_discriminant
&
&
!
has_implicit_zero_discriminant
{
return
Error
:
:
new_spanned
(
ast
"
FromZeroes
only
supported
on
enums
with
a
variant
that
has
a
discriminant
of
0
"
)
.
to_compile_error
(
)
;
}
impl_block
(
ast
enm
Trait
:
:
FromZeroes
RequireBoundedFields
:
:
Yes
false
None
None
)
}
fn
derive_from_zeroes_union
(
ast
:
&
DeriveInput
unn
:
&
DataUnion
)
-
>
proc_macro2
:
:
TokenStream
{
impl_block
(
ast
unn
Trait
:
:
FromZeroes
RequireBoundedFields
:
:
Yes
false
None
None
)
}
fn
derive_from_bytes_struct
(
ast
:
&
DeriveInput
strct
:
&
DataStruct
)
-
>
proc_macro2
:
:
TokenStream
{
impl_block
(
ast
strct
Trait
:
:
FromBytes
RequireBoundedFields
:
:
Yes
false
None
None
)
}
fn
derive_from_bytes_enum
(
ast
:
&
DeriveInput
enm
:
&
DataEnum
)
-
>
proc_macro2
:
:
TokenStream
{
if
!
enm
.
is_c_like
(
)
{
return
Error
:
:
new_spanned
(
ast
"
only
C
-
like
enums
can
implement
FromBytes
"
)
.
to_compile_error
(
)
;
}
let
reprs
=
try_or_print
!
(
ENUM_FROM_BYTES_CFG
.
validate_reprs
(
ast
)
)
;
let
variants_required
=
match
reprs
.
as_slice
(
)
{
[
EnumRepr
:
:
U8
]
|
[
EnumRepr
:
:
I8
]
=
>
1usize
<
<
8
[
EnumRepr
:
:
U16
]
|
[
EnumRepr
:
:
I16
]
=
>
1usize
<
<
16
_
=
>
unreachable
!
(
)
}
;
if
enm
.
variants
.
len
(
)
!
=
variants_required
{
return
Error
:
:
new_spanned
(
ast
format
!
(
"
FromBytes
only
supported
on
{
}
enum
with
{
}
variants
"
reprs
[
0
]
variants_required
)
)
.
to_compile_error
(
)
;
}
impl_block
(
ast
enm
Trait
:
:
FromBytes
RequireBoundedFields
:
:
Yes
false
None
None
)
}
#
[
rustfmt
:
:
skip
]
const
ENUM_FROM_BYTES_CFG
:
Config
<
EnumRepr
>
=
{
use
EnumRepr
:
:
*
;
Config
{
allowed_combinations_message
:
r
#
"
FromBytes
requires
repr
of
"
u8
"
"
u16
"
"
i8
"
or
"
i16
"
"
#
derive_unaligned
:
false
allowed_combinations
:
&
[
&
[
U8
]
&
[
U16
]
&
[
I8
]
&
[
I16
]
]
disallowed_but_legal_combinations
:
&
[
&
[
C
]
&
[
U32
]
&
[
I32
]
&
[
U64
]
&
[
I64
]
&
[
Usize
]
&
[
Isize
]
]
}
}
;
fn
derive_from_bytes_union
(
ast
:
&
DeriveInput
unn
:
&
DataUnion
)
-
>
proc_macro2
:
:
TokenStream
{
impl_block
(
ast
unn
Trait
:
:
FromBytes
RequireBoundedFields
:
:
Yes
false
None
None
)
}
fn
derive_as_bytes_struct
(
ast
:
&
DeriveInput
strct
:
&
DataStruct
)
-
>
proc_macro2
:
:
TokenStream
{
let
reprs
=
try_or_print
!
(
STRUCT_UNION_AS_BYTES_CFG
.
validate_reprs
(
ast
)
)
;
let
is_transparent
=
reprs
.
contains
(
&
StructRepr
:
:
Transparent
)
;
let
is_packed
=
reprs
.
contains
(
&
StructRepr
:
:
Packed
)
;
if
!
ast
.
generics
.
params
.
is_empty
(
)
&
&
!
is_transparent
&
&
!
is_packed
{
return
Error
:
:
new
(
Span
:
:
call_site
(
)
"
unsupported
on
generic
structs
that
are
not
repr
(
transparent
)
or
repr
(
packed
)
"
)
.
to_compile_error
(
)
;
}
let
padding_check
=
if
is_transparent
|
|
is_packed
{
None
}
else
{
Some
(
PaddingCheck
:
:
Struct
)
}
;
impl_block
(
ast
strct
Trait
:
:
AsBytes
RequireBoundedFields
:
:
Yes
false
padding_check
None
)
}
const
STRUCT_UNION_AS_BYTES_CFG
:
Config
<
StructRepr
>
=
Config
{
allowed_combinations_message
:
r
#
"
AsBytes
requires
either
a
)
repr
"
C
"
or
"
transparent
"
with
all
fields
implementing
AsBytes
or
b
)
repr
"
packed
"
"
#
derive_unaligned
:
false
allowed_combinations
:
STRUCT_UNION_ALLOWED_REPR_COMBINATIONS
disallowed_but_legal_combinations
:
&
[
]
}
;
fn
derive_as_bytes_enum
(
ast
:
&
DeriveInput
enm
:
&
DataEnum
)
-
>
proc_macro2
:
:
TokenStream
{
if
!
enm
.
is_c_like
(
)
{
return
Error
:
:
new_spanned
(
ast
"
only
C
-
like
enums
can
implement
AsBytes
"
)
.
to_compile_error
(
)
;
}
let
_
:
Vec
<
repr
:
:
EnumRepr
>
=
try_or_print
!
(
ENUM_AS_BYTES_CFG
.
validate_reprs
(
ast
)
)
;
impl_block
(
ast
enm
Trait
:
:
AsBytes
RequireBoundedFields
:
:
No
false
None
None
)
}
#
[
rustfmt
:
:
skip
]
const
ENUM_AS_BYTES_CFG
:
Config
<
EnumRepr
>
=
{
use
EnumRepr
:
:
*
;
Config
{
allowed_combinations_message
:
r
#
"
AsBytes
requires
repr
of
"
C
"
"
u8
"
"
u16
"
"
u32
"
"
u64
"
"
usize
"
"
i8
"
"
i16
"
"
i32
"
"
i64
"
or
"
isize
"
"
#
derive_unaligned
:
false
allowed_combinations
:
&
[
&
[
C
]
&
[
U8
]
&
[
U16
]
&
[
I8
]
&
[
I16
]
&
[
U32
]
&
[
I32
]
&
[
U64
]
&
[
I64
]
&
[
Usize
]
&
[
Isize
]
]
disallowed_but_legal_combinations
:
&
[
]
}
}
;
fn
derive_as_bytes_union
(
ast
:
&
DeriveInput
unn
:
&
DataUnion
)
-
>
proc_macro2
:
:
TokenStream
{
if
!
ast
.
generics
.
params
.
is_empty
(
)
{
return
Error
:
:
new
(
Span
:
:
call_site
(
)
"
unsupported
on
types
with
type
parameters
"
)
.
to_compile_error
(
)
;
}
try_or_print
!
(
STRUCT_UNION_AS_BYTES_CFG
.
validate_reprs
(
ast
)
)
;
impl_block
(
ast
unn
Trait
:
:
AsBytes
RequireBoundedFields
:
:
Yes
false
Some
(
PaddingCheck
:
:
Union
)
None
)
}
fn
derive_unaligned_struct
(
ast
:
&
DeriveInput
strct
:
&
DataStruct
)
-
>
proc_macro2
:
:
TokenStream
{
let
reprs
=
try_or_print
!
(
STRUCT_UNION_UNALIGNED_CFG
.
validate_reprs
(
ast
)
)
;
let
require_trait_bounds_on_field_types
=
(
!
reprs
.
contains
(
&
StructRepr
:
:
Packed
)
)
.
into
(
)
;
impl_block
(
ast
strct
Trait
:
:
Unaligned
require_trait_bounds_on_field_types
false
None
None
)
}
const
STRUCT_UNION_UNALIGNED_CFG
:
Config
<
StructRepr
>
=
Config
{
allowed_combinations_message
:
r
#
"
Unaligned
requires
either
a
)
repr
"
C
"
or
"
transparent
"
with
all
fields
implementing
Unaligned
or
b
)
repr
"
packed
"
"
#
derive_unaligned
:
true
allowed_combinations
:
STRUCT_UNION_ALLOWED_REPR_COMBINATIONS
disallowed_but_legal_combinations
:
&
[
]
}
;
fn
derive_unaligned_enum
(
ast
:
&
DeriveInput
enm
:
&
DataEnum
)
-
>
proc_macro2
:
:
TokenStream
{
if
!
enm
.
is_c_like
(
)
{
return
Error
:
:
new_spanned
(
ast
"
only
C
-
like
enums
can
implement
Unaligned
"
)
.
to_compile_error
(
)
;
}
let
_
:
Vec
<
repr
:
:
EnumRepr
>
=
try_or_print
!
(
ENUM_UNALIGNED_CFG
.
validate_reprs
(
ast
)
)
;
impl_block
(
ast
enm
Trait
:
:
Unaligned
RequireBoundedFields
:
:
Yes
false
None
None
)
}
#
[
rustfmt
:
:
skip
]
const
ENUM_UNALIGNED_CFG
:
Config
<
EnumRepr
>
=
{
use
EnumRepr
:
:
*
;
Config
{
allowed_combinations_message
:
r
#
"
Unaligned
requires
repr
of
"
u8
"
or
"
i8
"
and
no
alignment
(
i
.
e
.
repr
(
align
(
N
>
1
)
)
)
"
#
derive_unaligned
:
true
allowed_combinations
:
&
[
&
[
U8
]
&
[
I8
]
]
disallowed_but_legal_combinations
:
&
[
&
[
C
]
&
[
U16
]
&
[
U32
]
&
[
U64
]
&
[
Usize
]
&
[
I16
]
&
[
I32
]
&
[
I64
]
&
[
Isize
]
]
}
}
;
fn
derive_unaligned_union
(
ast
:
&
DeriveInput
unn
:
&
DataUnion
)
-
>
proc_macro2
:
:
TokenStream
{
let
reprs
=
try_or_print
!
(
STRUCT_UNION_UNALIGNED_CFG
.
validate_reprs
(
ast
)
)
;
let
require_trait_bound_on_field_types
=
(
!
reprs
.
contains
(
&
StructRepr
:
:
Packed
)
)
.
into
(
)
;
impl_block
(
ast
unn
Trait
:
:
Unaligned
require_trait_bound_on_field_types
false
None
None
)
}
enum
PaddingCheck
{
Struct
Union
}
impl
PaddingCheck
{
fn
validator_macro_ident
(
&
self
)
-
>
Ident
{
let
s
=
match
self
{
PaddingCheck
:
:
Struct
=
>
"
struct_has_padding
"
PaddingCheck
:
:
Union
=
>
"
union_has_padding
"
}
;
Ident
:
:
new
(
s
Span
:
:
call_site
(
)
)
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
enum
Trait
{
KnownLayout
FromZeroes
FromBytes
AsBytes
Unaligned
}
impl
Trait
{
fn
ident
(
&
self
)
-
>
Ident
{
Ident
:
:
new
(
format
!
(
"
{
:
?
}
"
self
)
.
as_str
(
)
Span
:
:
call_site
(
)
)
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
enum
RequireBoundedFields
{
No
Yes
Trailing
}
impl
From
<
bool
>
for
RequireBoundedFields
{
fn
from
(
do_require
:
bool
)
-
>
Self
{
match
do_require
{
true
=
>
Self
:
:
Yes
false
=
>
Self
:
:
No
}
}
}
fn
impl_block
<
D
:
DataExt
>
(
input
:
&
DeriveInput
data
:
&
D
trt
:
Trait
require_trait_bound_on_field_types
:
RequireBoundedFields
require_self_sized
:
bool
padding_check
:
Option
<
PaddingCheck
>
extras
:
Option
<
proc_macro2
:
:
TokenStream
>
)
-
>
proc_macro2
:
:
TokenStream
{
let
type_ident
=
&
input
.
ident
;
let
trait_ident
=
trt
.
ident
(
)
;
let
field_types
=
data
.
field_types
(
)
;
let
bound_tt
=
|
ty
|
parse_quote
!
(
#
ty
:
:
:
zerocopy
:
:
#
trait_ident
)
;
let
field_type_bounds
:
Vec
<
_
>
=
match
(
require_trait_bound_on_field_types
&
field_types
[
.
.
]
)
{
(
RequireBoundedFields
:
:
Yes
_
)
=
>
field_types
.
iter
(
)
.
map
(
bound_tt
)
.
collect
(
)
(
RequireBoundedFields
:
:
No
_
)
|
(
RequireBoundedFields
:
:
Trailing
[
]
)
=
>
vec
!
[
]
(
RequireBoundedFields
:
:
Trailing
[
.
.
last
]
)
=
>
vec
!
[
bound_tt
(
last
)
]
}
;
#
[
allow
(
unstable_name_collisions
)
]
let
padding_check_bound
=
padding_check
.
and_then
(
|
check
|
(
!
field_types
.
is_empty
(
)
)
.
then_some
(
check
)
)
.
map
(
|
check
|
{
let
fields
=
field_types
.
iter
(
)
;
let
validator_macro
=
check
.
validator_macro_ident
(
)
;
parse_quote
!
(
:
:
zerocopy
:
:
macro_util
:
:
HasPadding
<
#
type_ident
{
:
:
zerocopy
:
:
#
validator_macro
!
(
#
type_ident
#
(
#
fields
)
*
)
}
>
:
:
:
zerocopy
:
:
macro_util
:
:
ShouldBe
<
false
>
)
}
)
;
let
self_sized_bound
=
if
require_self_sized
{
Some
(
parse_quote
!
(
Self
:
Sized
)
)
}
else
{
None
}
;
let
bounds
=
input
.
generics
.
where_clause
.
as_ref
(
)
.
map
(
|
where_clause
|
where_clause
.
predicates
.
iter
(
)
)
.
into_iter
(
)
.
flatten
(
)
.
chain
(
field_type_bounds
.
iter
(
)
)
.
chain
(
padding_check_bound
.
iter
(
)
)
.
chain
(
self_sized_bound
.
iter
(
)
)
;
let
params
=
input
.
generics
.
params
.
clone
(
)
.
into_iter
(
)
.
map
(
|
mut
param
|
{
match
&
mut
param
{
GenericParam
:
:
Type
(
ty
)
=
>
ty
.
default
=
None
GenericParam
:
:
Const
(
cnst
)
=
>
cnst
.
default
=
None
GenericParam
:
:
Lifetime
(
_
)
=
>
{
}
}
quote
!
(
#
param
)
}
)
;
let
param_idents
=
input
.
generics
.
params
.
iter
(
)
.
map
(
|
param
|
match
param
{
GenericParam
:
:
Type
(
ty
)
=
>
{
let
ident
=
&
ty
.
ident
;
quote
!
(
#
ident
)
}
GenericParam
:
:
Lifetime
(
l
)
=
>
{
let
ident
=
&
l
.
lifetime
;
quote
!
(
#
ident
)
}
GenericParam
:
:
Const
(
cnst
)
=
>
{
let
ident
=
&
cnst
.
ident
;
quote
!
(
{
#
ident
}
)
}
}
)
;
quote
!
{
/
/
TODO
(
#
553
)
:
Add
a
test
that
generates
a
warning
when
/
/
#
[
allow
(
deprecated
)
]
isn
'
t
present
.
#
[
allow
(
deprecated
)
]
unsafe
impl
<
#
(
#
params
)
*
>
:
:
zerocopy
:
:
#
trait_ident
for
#
type_ident
<
#
(
#
param_idents
)
*
>
where
#
(
#
bounds
)
*
{
fn
only_derive_is_allowed_to_implement_this_trait
(
)
{
}
#
extras
}
}
}
fn
print_all_errors
(
errors
:
Vec
<
Error
>
)
-
>
proc_macro2
:
:
TokenStream
{
errors
.
iter
(
)
.
map
(
Error
:
:
to_compile_error
)
.
collect
(
)
}
trait
BoolExt
{
fn
then_some
<
T
>
(
self
t
:
T
)
-
>
Option
<
T
>
;
}
impl
BoolExt
for
bool
{
fn
then_some
<
T
>
(
self
t
:
T
)
-
>
Option
<
T
>
{
if
self
{
Some
(
t
)
}
else
{
None
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_config_repr_orderings
(
)
{
fn
is_sorted_and_deduped
<
T
:
Clone
+
Ord
>
(
ts
:
&
[
T
]
)
-
>
bool
{
let
mut
sorted
=
ts
.
to_vec
(
)
;
sorted
.
sort
(
)
;
sorted
.
dedup
(
)
;
ts
=
=
sorted
.
as_slice
(
)
}
fn
elements_are_sorted_and_deduped
<
T
:
Clone
+
Ord
>
(
lists
:
&
[
&
[
T
]
]
)
-
>
bool
{
lists
.
iter
(
)
.
all
(
|
list
|
is_sorted_and_deduped
(
list
)
)
}
fn
config_is_sorted
<
T
:
KindRepr
+
Clone
>
(
config
:
&
Config
<
T
>
)
-
>
bool
{
elements_are_sorted_and_deduped
(
config
.
allowed_combinations
)
&
&
elements_are_sorted_and_deduped
(
config
.
disallowed_but_legal_combinations
)
}
assert
!
(
config_is_sorted
(
&
STRUCT_UNION_UNALIGNED_CFG
)
)
;
assert
!
(
config_is_sorted
(
&
ENUM_FROM_BYTES_CFG
)
)
;
assert
!
(
config_is_sorted
(
&
ENUM_UNALIGNED_CFG
)
)
;
}
#
[
test
]
fn
test_config_repr_no_overlap
(
)
{
fn
overlap
<
T
:
Eq
>
(
a
:
&
[
T
]
b
:
&
[
T
]
)
-
>
bool
{
a
.
iter
(
)
.
any
(
|
elem
|
b
.
contains
(
elem
)
)
}
fn
config_overlaps
<
T
:
KindRepr
+
Eq
>
(
config
:
&
Config
<
T
>
)
-
>
bool
{
overlap
(
config
.
allowed_combinations
config
.
disallowed_but_legal_combinations
)
}
assert
!
(
!
config_overlaps
(
&
STRUCT_UNION_UNALIGNED_CFG
)
)
;
assert
!
(
!
config_overlaps
(
&
ENUM_FROM_BYTES_CFG
)
)
;
assert
!
(
!
config_overlaps
(
&
ENUM_UNALIGNED_CFG
)
)
;
}
}
