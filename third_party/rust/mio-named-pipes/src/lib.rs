#
!
[
cfg
(
windows
)
]
#
!
[
deny
(
missing_docs
)
]
#
[
macro_use
]
extern
crate
log
;
extern
crate
mio
;
extern
crate
miow
;
extern
crate
winapi
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
fmt
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
;
use
std
:
:
mem
;
use
std
:
:
os
:
:
windows
:
:
io
:
:
*
;
use
std
:
:
slice
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicBool
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
use
mio
:
:
windows
;
use
mio
:
:
{
Registration
Poll
Token
PollOpt
Ready
Evented
SetReadiness
}
;
use
miow
:
:
iocp
:
:
CompletionStatus
;
use
miow
:
:
pipe
;
use
winapi
:
:
shared
:
:
winerror
:
:
*
;
use
winapi
:
:
um
:
:
ioapiset
:
:
*
;
use
winapi
:
:
um
:
:
minwinbase
:
:
*
;
mod
from_raw_arc
;
use
from_raw_arc
:
:
FromRawArc
;
macro_rules
!
offset_of
{
(
t
:
ty
(
field
:
ident
)
.
+
)
=
>
(
&
(
*
(
0
as
*
const
t
)
)
.
(
field
)
.
+
as
*
const
_
as
usize
)
}
macro_rules
!
overlapped2arc
{
(
e
:
expr
t
:
ty
(
field
:
ident
)
.
+
)
=
>
(
{
let
offset
=
offset_of
!
(
t
(
field
)
.
+
)
;
debug_assert
!
(
offset
<
mem
:
:
size_of
:
:
<
t
>
(
)
)
;
FromRawArc
:
:
from_raw
(
(
e
as
usize
-
offset
)
as
*
mut
t
)
}
)
}
fn
would_block
(
)
-
>
io
:
:
Error
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
WouldBlock
"
would
block
"
)
}
pub
struct
NamedPipe
{
registered
:
AtomicBool
ready_registration
:
Registration
poll_registration
:
windows
:
:
Binding
inner
:
FromRawArc
<
Inner
>
}
struct
Inner
{
handle
:
pipe
:
:
NamedPipe
readiness
:
SetReadiness
connect
:
windows
:
:
Overlapped
connecting
:
AtomicBool
read
:
windows
:
:
Overlapped
write
:
windows
:
:
Overlapped
io
:
Mutex
<
Io
>
}
struct
Io
{
read
:
State
write
:
State
connect_error
:
Option
<
io
:
:
Error
>
}
enum
State
{
None
Pending
(
Vec
<
u8
>
usize
)
Ok
(
Vec
<
u8
>
usize
)
Err
(
io
:
:
Error
)
}
fn
_assert_kinds
(
)
{
fn
_assert_send
<
T
:
Send
>
(
)
{
}
fn
_assert_sync
<
T
:
Sync
>
(
)
{
}
_assert_send
:
:
<
NamedPipe
>
(
)
;
_assert_sync
:
:
<
NamedPipe
>
(
)
;
}
impl
NamedPipe
{
pub
fn
new
<
A
:
AsRef
<
OsStr
>
>
(
addr
:
A
)
-
>
io
:
:
Result
<
NamedPipe
>
{
NamedPipe
:
:
_new
(
addr
.
as_ref
(
)
)
}
fn
_new
(
addr
:
&
OsStr
)
-
>
io
:
:
Result
<
NamedPipe
>
{
let
pipe
=
try
!
(
pipe
:
:
NamedPipe
:
:
new
(
addr
)
)
;
unsafe
{
Ok
(
NamedPipe
:
:
from_raw_handle
(
pipe
.
into_raw_handle
(
)
)
)
}
}
pub
fn
connect
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
!
self
.
registered
(
)
{
return
Err
(
would_block
(
)
)
}
if
self
.
inner
.
connecting
.
swap
(
true
SeqCst
)
{
return
Err
(
would_block
(
)
)
}
let
res
=
unsafe
{
let
overlapped
=
self
.
inner
.
connect
.
as_mut_ptr
(
)
as
*
mut
_
;
self
.
inner
.
handle
.
connect_overlapped
(
overlapped
)
}
;
match
res
{
Ok
(
true
)
=
>
{
trace
!
(
"
connect
done
immediately
"
)
;
self
.
inner
.
connecting
.
store
(
false
SeqCst
)
;
Inner
:
:
post_register
(
&
self
.
inner
)
;
Ok
(
(
)
)
}
Ok
(
false
)
=
>
{
trace
!
(
"
connect
in
progress
"
)
;
mem
:
:
forget
(
self
.
inner
.
clone
(
)
)
;
Err
(
would_block
(
)
)
}
Err
(
e
)
=
>
{
trace
!
(
"
connect
error
:
{
}
"
e
)
;
self
.
inner
.
connecting
.
store
(
false
SeqCst
)
;
Err
(
e
)
}
}
}
pub
fn
take_error
(
&
self
)
-
>
io
:
:
Result
<
Option
<
io
:
:
Error
>
>
{
Ok
(
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
.
connect_error
.
take
(
)
)
}
pub
fn
disconnect
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
try
!
(
self
.
inner
.
handle
.
disconnect
(
)
)
;
self
.
inner
.
readiness
.
set_readiness
(
Ready
:
:
empty
(
)
)
.
expect
(
"
event
loop
seems
gone
"
)
;
Ok
(
(
)
)
}
fn
registered
(
&
self
)
-
>
bool
{
self
.
registered
.
load
(
SeqCst
)
}
}
impl
Read
for
NamedPipe
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
<
&
NamedPipe
as
Read
>
:
:
read
(
&
mut
&
*
self
buf
)
}
}
impl
Write
for
NamedPipe
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
<
&
NamedPipe
as
Write
>
:
:
write
(
&
mut
&
*
self
buf
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
<
&
NamedPipe
as
Write
>
:
:
flush
(
&
mut
&
*
self
)
}
}
impl
<
'
a
>
Read
for
&
'
a
NamedPipe
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
!
self
.
registered
(
)
{
return
Err
(
would_block
(
)
)
}
let
mut
state
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
state
.
read
State
:
:
None
)
{
State
:
:
None
=
>
Err
(
would_block
(
)
)
State
:
:
Pending
(
buf
amt
)
=
>
{
state
.
read
=
State
:
:
Pending
(
buf
amt
)
;
Err
(
would_block
(
)
)
}
State
:
:
Ok
(
data
cur
)
=
>
{
let
n
=
{
let
mut
remaining
=
&
data
[
cur
.
.
]
;
try
!
(
remaining
.
read
(
buf
)
)
}
;
let
next
=
cur
+
n
;
if
next
!
=
data
.
len
(
)
{
state
.
read
=
State
:
:
Ok
(
data
next
)
;
}
else
{
Inner
:
:
schedule_read
(
&
self
.
inner
&
mut
state
)
;
}
Ok
(
n
)
}
State
:
:
Err
(
e
)
=
>
{
Inner
:
:
schedule_read
(
&
self
.
inner
&
mut
state
)
;
if
e
.
raw_os_error
(
)
=
=
Some
(
ERROR_BROKEN_PIPE
as
i32
)
{
Ok
(
0
)
}
else
{
Err
(
e
)
}
}
}
}
}
impl
<
'
a
>
Write
for
&
'
a
NamedPipe
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
!
self
.
registered
(
)
{
return
Err
(
would_block
(
)
)
}
let
mut
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
match
io
.
write
{
State
:
:
None
=
>
{
}
_
=
>
return
Err
(
would_block
(
)
)
}
Inner
:
:
schedule_write
(
&
self
.
inner
buf
.
to_vec
(
)
0
&
mut
io
)
;
Ok
(
buf
.
len
(
)
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
Evented
for
NamedPipe
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
try
!
(
self
.
poll_registration
.
register_handle
(
&
self
.
inner
.
handle
token
poll
)
)
;
}
try
!
(
poll
.
register
(
&
self
.
ready_registration
token
interest
opts
)
)
;
self
.
registered
.
store
(
true
SeqCst
)
;
Inner
:
:
post_register
(
&
self
.
inner
)
;
Ok
(
(
)
)
}
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
try
!
(
self
.
poll_registration
.
reregister_handle
(
&
self
.
inner
.
handle
token
poll
)
)
;
}
try
!
(
poll
.
reregister
(
&
self
.
ready_registration
token
interest
opts
)
)
;
Inner
:
:
post_register
(
&
self
.
inner
)
;
Ok
(
(
)
)
}
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
try
!
(
self
.
poll_registration
.
deregister_handle
(
&
self
.
inner
.
handle
poll
)
)
;
}
poll
.
deregister
(
&
self
.
ready_registration
)
}
}
impl
AsRawHandle
for
NamedPipe
{
fn
as_raw_handle
(
&
self
)
-
>
RawHandle
{
self
.
inner
.
handle
.
as_raw_handle
(
)
}
}
impl
FromRawHandle
for
NamedPipe
{
unsafe
fn
from_raw_handle
(
handle
:
RawHandle
)
-
>
NamedPipe
{
let
(
r
s
)
=
Registration
:
:
new2
(
)
;
NamedPipe
{
registered
:
AtomicBool
:
:
new
(
false
)
ready_registration
:
r
poll_registration
:
windows
:
:
Binding
:
:
new
(
)
inner
:
FromRawArc
:
:
new
(
Inner
{
handle
:
pipe
:
:
NamedPipe
:
:
from_raw_handle
(
handle
)
readiness
:
s
connecting
:
AtomicBool
:
:
new
(
false
)
connect
:
windows
:
:
Overlapped
:
:
new
(
mem
:
:
transmute
(
connect_done
as
fn
(
_
)
)
)
read
:
windows
:
:
Overlapped
:
:
new
(
mem
:
:
transmute
(
read_done
as
fn
(
_
)
)
)
write
:
windows
:
:
Overlapped
:
:
new
(
mem
:
:
transmute
(
write_done
as
fn
(
_
)
)
)
io
:
Mutex
:
:
new
(
Io
{
read
:
State
:
:
None
write
:
State
:
:
None
connect_error
:
None
}
)
}
)
}
}
}
impl
fmt
:
:
Debug
for
NamedPipe
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
inner
.
handle
.
fmt
(
f
)
}
}
impl
Drop
for
NamedPipe
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
self
.
inner
.
connecting
.
load
(
SeqCst
)
{
drop
(
cancel
(
&
self
.
inner
.
handle
&
self
.
inner
.
connect
)
)
;
}
let
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
match
io
.
read
{
State
:
:
Pending
(
.
.
)
=
>
{
drop
(
cancel
(
&
self
.
inner
.
handle
&
self
.
inner
.
read
)
)
;
}
_
=
>
{
}
}
}
}
}
impl
Inner
{
fn
schedule_read
(
me
:
&
FromRawArc
<
Inner
>
io
:
&
mut
Io
)
-
>
bool
{
match
io
.
read
{
State
:
:
None
=
>
{
}
_
=
>
return
true
}
let
ready
=
me
.
readiness
.
readiness
(
)
;
me
.
readiness
.
set_readiness
(
ready
&
!
Ready
:
:
readable
(
)
)
.
expect
(
"
event
loop
seems
gone
"
)
;
let
mut
buf
=
Vec
:
:
with_capacity
(
8
*
1024
)
;
let
e
=
unsafe
{
let
overlapped
=
me
.
read
.
as_mut_ptr
(
)
as
*
mut
_
;
let
slice
=
slice
:
:
from_raw_parts_mut
(
buf
.
as_mut_ptr
(
)
buf
.
capacity
(
)
)
;
me
.
handle
.
read_overlapped
(
slice
overlapped
)
}
;
match
e
{
Ok
(
e
)
=
>
{
trace
!
(
"
schedule
read
success
:
{
:
?
}
"
e
)
;
io
.
read
=
State
:
:
Pending
(
buf
0
)
;
mem
:
:
forget
(
me
.
clone
(
)
)
;
true
}
Err
(
ref
e
)
if
e
.
raw_os_error
(
)
=
=
Some
(
ERROR_PIPE_LISTENING
as
i32
)
=
>
{
false
}
Err
(
e
)
=
>
{
trace
!
(
"
schedule
read
error
:
{
}
"
e
)
;
io
.
read
=
State
:
:
Err
(
e
)
;
me
.
readiness
.
set_readiness
(
ready
|
Ready
:
:
readable
(
)
)
.
expect
(
"
event
loop
still
seems
gone
"
)
;
true
}
}
}
fn
schedule_write
(
me
:
&
FromRawArc
<
Inner
>
buf
:
Vec
<
u8
>
pos
:
usize
io
:
&
mut
Io
)
{
let
ready
=
me
.
readiness
.
readiness
(
)
;
me
.
readiness
.
set_readiness
(
ready
&
!
Ready
:
:
writable
(
)
)
.
expect
(
"
event
loop
seems
gone
"
)
;
let
e
=
unsafe
{
let
overlapped
=
me
.
write
.
as_mut_ptr
(
)
as
*
mut
_
;
me
.
handle
.
write_overlapped
(
&
buf
[
pos
.
.
]
overlapped
)
}
;
match
e
{
Ok
(
e
)
=
>
{
trace
!
(
"
schedule
write
success
:
{
:
?
}
"
e
)
;
io
.
write
=
State
:
:
Pending
(
buf
pos
)
;
mem
:
:
forget
(
me
.
clone
(
)
)
}
Err
(
e
)
=
>
{
trace
!
(
"
schedule
write
error
:
{
}
"
e
)
;
io
.
write
=
State
:
:
Err
(
e
)
;
me
.
add_readiness
(
Ready
:
:
writable
(
)
)
;
}
}
}
fn
add_readiness
(
&
self
ready
:
Ready
)
{
self
.
readiness
.
set_readiness
(
ready
|
self
.
readiness
.
readiness
(
)
)
.
expect
(
"
event
loop
still
seems
gone
"
)
;
}
fn
post_register
(
me
:
&
FromRawArc
<
Inner
>
)
{
let
mut
io
=
me
.
io
.
lock
(
)
.
unwrap
(
)
;
if
Inner
:
:
schedule_read
(
&
me
&
mut
io
)
{
if
let
State
:
:
None
=
io
.
write
{
me
.
add_readiness
(
Ready
:
:
writable
(
)
)
;
}
}
}
}
unsafe
fn
cancel
(
handle
:
&
AsRawHandle
overlapped
:
&
windows
:
:
Overlapped
)
-
>
io
:
:
Result
<
(
)
>
{
let
ret
=
CancelIoEx
(
handle
.
as_raw_handle
(
)
overlapped
.
as_mut_ptr
(
)
as
*
mut
_
)
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
connect_done
(
status
:
&
OVERLAPPED_ENTRY
)
{
let
status
=
CompletionStatus
:
:
from_entry
(
status
)
;
trace
!
(
"
connect
done
"
)
;
let
me
=
unsafe
{
overlapped2arc
!
(
status
.
overlapped
(
)
Inner
connect
)
}
;
let
prev
=
me
.
connecting
.
swap
(
false
SeqCst
)
;
assert
!
(
prev
"
wasn
'
t
previously
connecting
"
)
;
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
0
)
;
unsafe
{
match
me
.
handle
.
result
(
status
.
overlapped
(
)
)
{
Ok
(
n
)
=
>
debug_assert_eq
!
(
n
0
)
Err
(
e
)
=
>
me
.
io
.
lock
(
)
.
unwrap
(
)
.
connect_error
=
Some
(
e
)
}
}
Inner
:
:
post_register
(
&
me
)
;
}
fn
read_done
(
status
:
&
OVERLAPPED_ENTRY
)
{
let
status
=
CompletionStatus
:
:
from_entry
(
status
)
;
trace
!
(
"
read
finished
bytes
=
{
}
"
status
.
bytes_transferred
(
)
)
;
let
me
=
unsafe
{
overlapped2arc
!
(
status
.
overlapped
(
)
Inner
read
)
}
;
let
mut
io
=
me
.
io
.
lock
(
)
.
unwrap
(
)
;
let
mut
buf
=
match
mem
:
:
replace
(
&
mut
io
.
read
State
:
:
None
)
{
State
:
:
Pending
(
buf
_
)
=
>
buf
_
=
>
unreachable
!
(
)
}
;
unsafe
{
match
me
.
handle
.
result
(
status
.
overlapped
(
)
)
{
Ok
(
n
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
as
usize
n
)
;
buf
.
set_len
(
status
.
bytes_transferred
(
)
as
usize
)
;
io
.
read
=
State
:
:
Ok
(
buf
0
)
;
}
Err
(
e
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
0
)
;
io
.
read
=
State
:
:
Err
(
e
)
;
}
}
}
me
.
add_readiness
(
Ready
:
:
readable
(
)
)
;
}
fn
write_done
(
status
:
&
OVERLAPPED_ENTRY
)
{
let
status
=
CompletionStatus
:
:
from_entry
(
status
)
;
trace
!
(
"
write
finished
bytes
=
{
}
"
status
.
bytes_transferred
(
)
)
;
let
me
=
unsafe
{
overlapped2arc
!
(
status
.
overlapped
(
)
Inner
write
)
}
;
let
mut
io
=
me
.
io
.
lock
(
)
.
unwrap
(
)
;
let
(
buf
pos
)
=
match
mem
:
:
replace
(
&
mut
io
.
write
State
:
:
None
)
{
State
:
:
Pending
(
buf
pos
)
=
>
(
buf
pos
)
_
=
>
unreachable
!
(
)
}
;
unsafe
{
match
me
.
handle
.
result
(
status
.
overlapped
(
)
)
{
Ok
(
n
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
as
usize
n
)
;
let
new_pos
=
pos
+
(
status
.
bytes_transferred
(
)
as
usize
)
;
if
new_pos
=
=
buf
.
len
(
)
{
me
.
add_readiness
(
Ready
:
:
writable
(
)
)
;
}
else
{
Inner
:
:
schedule_write
(
&
me
buf
new_pos
&
mut
io
)
;
}
}
Err
(
e
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
0
)
;
io
.
write
=
State
:
:
Err
(
e
)
;
me
.
add_readiness
(
Ready
:
:
writable
(
)
)
;
}
}
}
}
