use
crate
:
:
helpers
:
:
i64_to_i32
;
use
crate
:
:
rata_die
:
:
RataDie
;
use
core
:
:
cmp
:
:
Ordering
;
#
[
inline
]
fn
months_preceding_molad
(
h_year
:
i32
)
-
>
i64
{
(
235
*
(
i64
:
:
from
(
h_year
)
-
1
)
+
1
)
.
div_euclid
(
19
)
}
macro_rules
!
al
{
(
d
:
literal
-
h
:
literal
-
p
:
literal
)
=
>
{
{
const
CONSTANT
:
i32
=
(
(
d
-
1
)
*
24
+
h
)
*
1080
+
p
;
CONSTANT
}
}
;
(
0
-
indexed
d
:
literal
-
h
:
literal
-
p
:
literal
)
=
>
{
{
const
CONSTANT
:
i32
=
(
d
*
24
+
h
)
*
1080
+
p
;
CONSTANT
}
}
;
}
const
MOLAD_BEHERAD_OFFSET
:
i32
=
al
!
(
2
-
5
-
204
)
;
const
HEBREW_LUNATION_TIME
:
i32
=
al
!
(
0
-
indexed
29
-
12
-
793
)
;
const
HEBREW_APPROX_YEAR_LENGTH
:
f64
=
35975351
.
0
/
98496
.
0
;
const
ALAKIM_IN_WEEK
:
i64
=
1080
*
24
*
7
;
const
HEBREW_CALENDAR_EPOCH
:
RataDie
=
crate
:
:
julian
:
:
fixed_from_julian_book_version
(
-
3761
10
7
)
;
pub
const
HEBREW_MIN_YEAR
:
i32
=
i32
:
:
MIN
;
pub
const
HEBREW_MIN_RD
:
RataDie
=
RataDie
:
:
new
(
-
784362951979
)
;
pub
const
HEBREW_MAX_YEAR
:
i32
=
i32
:
:
MAX
;
pub
const
HEBREW_MAX_RD
:
RataDie
=
RataDie
:
:
new
(
784360204356
)
;
#
[
inline
]
fn
molad_details
(
h_year
:
i32
)
-
>
(
i64
i32
)
{
let
months_preceding
=
months_preceding_molad
(
h_year
)
;
let
molad
=
MOLAD_BEHERAD_OFFSET
as
i64
+
months_preceding
*
HEBREW_LUNATION_TIME
as
i64
;
let
weeks_since_beharad
=
molad
.
div_euclid
(
ALAKIM_IN_WEEK
)
;
let
in_week
=
molad
.
rem_euclid
(
ALAKIM_IN_WEEK
)
;
let
in_week
=
i32
:
:
try_from
(
in_week
)
;
debug_assert
!
(
in_week
.
is_ok
(
)
"
ALAKIM_IN_WEEK
should
fit
in
an
i32
"
)
;
(
weeks_since_beharad
in_week
.
unwrap_or
(
0
)
)
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Debug
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
YearInfo
{
pub
keviyah
:
Keviyah
pub
weeks_since_beharad
:
i64
}
impl
YearInfo
{
#
[
inline
]
pub
fn
compute_for
(
h_year
:
i32
)
-
>
Self
{
let
(
mut
weeks_since_beharad
alakim
)
=
molad_details
(
h_year
)
;
let
cycle_type
=
MetonicCycleType
:
:
for_h_year
(
h_year
)
;
let
keviyah
=
keviyah_for
(
cycle_type
alakim
)
;
if
alakim
>
al
!
(
7
-
18
-
0
)
{
weeks_since_beharad
+
=
1
;
}
Self
{
keviyah
weeks_since_beharad
}
}
#
[
inline
]
pub
fn
year_containing_rd
(
date
:
RataDie
)
-
>
(
Self
i32
)
{
#
[
allow
(
unused_imports
)
]
use
core_maths
:
:
*
;
let
date
=
date
.
clamp
(
HEBREW_MIN_RD
HEBREW_MAX_RD
)
;
let
days_since_epoch
=
(
date
-
HEBREW_CALENDAR_EPOCH
)
as
f64
;
let
maybe_approx
=
i64_to_i32
(
1
+
days_since_epoch
.
div_euclid
(
HEBREW_APPROX_YEAR_LENGTH
)
as
i64
)
;
let
approx
=
maybe_approx
.
unwrap_or_else
(
|
e
|
e
.
saturate
(
)
)
;
let
yi
=
Self
:
:
compute_for
(
approx
)
;
let
cmp
=
yi
.
compare
(
date
)
;
let
(
yi
h_year
)
=
match
cmp
{
Ordering
:
:
Greater
=
>
{
let
prev
=
approx
.
saturating_sub
(
1
)
;
(
Self
:
:
compute_for
(
prev
)
prev
)
}
Ordering
:
:
Equal
=
>
(
yi
approx
)
Ordering
:
:
Less
=
>
{
let
next
=
approx
.
saturating_add
(
1
)
;
(
Self
:
:
compute_for
(
next
)
next
)
}
}
;
debug_assert
!
(
yi
.
compare
(
date
)
.
is_eq
(
)
"
Date
{
date
:
?
}
calculated
approximately
to
Hebrew
Year
{
approx
}
(
comparison
:
{
cmp
:
?
}
)
\
should
be
contained
in
adjacent
year
{
h_year
}
but
that
year
is
still
{
:
?
}
it
"
yi
.
compare
(
date
)
)
;
(
yi
h_year
)
}
fn
compare
(
self
rd
:
RataDie
)
-
>
Ordering
{
let
ny
=
self
.
new_year
(
)
;
let
len
=
self
.
keviyah
.
year_length
(
)
;
if
rd
<
ny
{
Ordering
:
:
Greater
}
else
if
rd
>
=
ny
+
len
.
into
(
)
{
Ordering
:
:
Less
}
else
{
Ordering
:
:
Equal
}
}
#
[
inline
]
pub
fn
new_year
(
self
)
-
>
RataDie
{
const
BEHARAD_START_OF_YEAR
:
StartOfYear
=
StartOfYear
:
:
Monday
;
let
days_since_beharad
=
(
self
.
weeks_since_beharad
*
7
)
+
self
.
keviyah
.
start_of_year
(
)
as
i64
-
BEHARAD_START_OF_YEAR
as
i64
;
HEBREW_CALENDAR_EPOCH
+
days_since_beharad
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Debug
)
]
#
[
allow
(
clippy
:
:
exhaustive_enums
)
]
pub
enum
Keviyah
{
=
0
=
1
=
2
=
3
=
4
=
5
=
6
=
7
=
8
=
9
=
10
=
11
=
12
=
13
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Debug
)
]
#
[
allow
(
clippy
:
:
exhaustive_enums
)
]
pub
enum
YearType
{
Deficient
=
-
1
Regular
=
0
Complete
=
1
}
impl
YearType
{
fn
length_correction
(
self
)
-
>
i8
{
self
as
i8
}
fn
eshvan_length
(
self
)
-
>
u8
{
if
self
=
=
Self
:
:
Complete
{
ESHVAN_DEFAULT_LEN
+
1
}
else
{
ESHVAN_DEFAULT_LEN
}
}
fn
kislev_length
(
self
)
-
>
u8
{
if
self
=
=
Self
:
:
Deficient
{
KISLEV_DEFAULT_LEN
-
1
}
else
{
KISLEV_DEFAULT_LEN
}
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Debug
)
]
#
[
allow
(
clippy
:
:
exhaustive_enums
)
]
pub
enum
StartOfYear
{
Monday
=
2
Tuesday
=
3
Thursday
=
5
Saturday
=
7
}
macro_rules
!
u16_cvt
(
(
first
:
ident
(
+
rest
:
ident
)
*
)
=
>
{
{
/
/
make
sure
it
is
constant
/
/
we
use
as
here
because
it
works
in
consts
and
in
this
context
/
/
overflow
will
panic
anyway
const
COMPUTED
:
u16
=
first
as
u16
(
+
rest
as
u16
)
*
;
COMPUTED
}
}
;
)
;
const
TISHREI_LEN
:
u8
=
30
;
const
ESHVAN_DEFAULT_LEN
:
u8
=
29
;
const
KISLEV_DEFAULT_LEN
:
u8
=
30
;
const
TEVET_LEN
:
u8
=
29
;
const
SHEVAT_LEN
:
u8
=
30
;
const
ADARI_LEN
:
u8
=
30
;
const
ADAR_LEN
:
u8
=
29
;
const
NISAN_LEN
:
u8
=
30
;
const
IYYAR_LEN
:
u8
=
29
;
const
SIVAN_LEN
:
u8
=
30
;
const
TAMMUZ_LEN
:
u8
=
29
;
const
AV_LEN
:
u8
=
30
;
const
ELUL_LEN
:
u8
=
29
;
pub
const
TISHREI
:
u8
=
1
;
pub
const
ESHVAN
:
u8
=
2
;
pub
const
KISLEV
:
u8
=
3
;
pub
const
TEVET
:
u8
=
4
;
pub
const
SHEVAT
:
u8
=
5
;
pub
const
ADAR
:
u8
=
6
;
pub
const
NISAN
:
u8
=
7
;
pub
const
IYYAR
:
u8
=
8
;
pub
const
SIVAN
:
u8
=
9
;
pub
const
TAMMUZ
:
u8
=
10
;
pub
const
AV
:
u8
=
11
;
pub
const
ELUL
:
u8
=
12
;
impl
Keviyah
{
#
[
inline
]
pub
fn
year_type
(
self
)
-
>
YearType
{
match
self
{
Self
:
:
=
>
YearType
:
:
Deficient
Self
:
:
=
>
YearType
:
:
Complete
Self
:
:
=
>
YearType
:
:
Regular
Self
:
:
=
>
YearType
:
:
Regular
Self
:
:
=
>
YearType
:
:
Complete
Self
:
:
=
>
YearType
:
:
Deficient
Self
:
:
=
>
YearType
:
:
Complete
Self
:
:
=
>
YearType
:
:
Deficient
Self
:
:
=
>
YearType
:
:
Complete
Self
:
:
=
>
YearType
:
:
Regular
Self
:
:
=
>
YearType
:
:
Deficient
Self
:
:
=
>
YearType
:
:
Complete
Self
:
:
=
>
YearType
:
:
Deficient
Self
:
:
=
>
YearType
:
:
Complete
}
}
#
[
inline
]
pub
fn
start_of_year
(
self
)
-
>
StartOfYear
{
match
self
{
Self
:
:
=
>
StartOfYear
:
:
Monday
Self
:
:
=
>
StartOfYear
:
:
Monday
Self
:
:
=
>
StartOfYear
:
:
Tuesday
Self
:
:
=
>
StartOfYear
:
:
Thursday
Self
:
:
=
>
StartOfYear
:
:
Thursday
Self
:
:
=
>
StartOfYear
:
:
Saturday
Self
:
:
=
>
StartOfYear
:
:
Saturday
Self
:
:
=
>
StartOfYear
:
:
Monday
Self
:
:
=
>
StartOfYear
:
:
Monday
Self
:
:
=
>
StartOfYear
:
:
Tuesday
Self
:
:
=
>
StartOfYear
:
:
Thursday
Self
:
:
=
>
StartOfYear
:
:
Thursday
Self
:
:
=
>
StartOfYear
:
:
Saturday
Self
:
:
=
>
StartOfYear
:
:
Saturday
}
}
#
[
inline
]
fn
normalized_ordinal_month
(
self
ordinal_month
:
u8
)
-
>
Option
<
u8
>
{
if
self
.
is_leap
(
)
{
match
ordinal_month
.
cmp
(
&
6
)
{
Ordering
:
:
Equal
=
>
None
Ordering
:
:
Less
=
>
Some
(
ordinal_month
)
Ordering
:
:
Greater
=
>
Some
(
ordinal_month
-
1
)
}
}
else
{
Some
(
ordinal_month
)
}
}
#
[
inline
]
pub
fn
month_len
(
self
ordinal_month
:
u8
)
-
>
u8
{
let
Some
(
normalized_ordinal_month
)
=
self
.
normalized_ordinal_month
(
ordinal_month
)
else
{
return
ADARI_LEN
;
}
;
debug_assert
!
(
normalized_ordinal_month
<
=
12
&
&
normalized_ordinal_month
>
0
)
;
match
normalized_ordinal_month
{
TISHREI
=
>
TISHREI_LEN
ESHVAN
=
>
self
.
year_type
(
)
.
eshvan_length
(
)
KISLEV
=
>
self
.
year_type
(
)
.
kislev_length
(
)
TEVET
=
>
TEVET_LEN
SHEVAT
=
>
SHEVAT_LEN
ADAR
=
>
ADAR_LEN
NISAN
=
>
NISAN_LEN
IYYAR
=
>
IYYAR_LEN
SIVAN
=
>
SIVAN_LEN
TAMMUZ
=
>
TAMMUZ_LEN
AV
=
>
AV_LEN
ELUL
=
>
ELUL_LEN
_
=
>
{
debug_assert
!
(
false
"
Got
unknown
month
index
{
ordinal_month
}
"
)
;
30
}
}
}
#
[
inline
]
pub
fn
days_preceding
(
self
ordinal_month
:
u8
)
-
>
u16
{
const
BEFORE_ADAR_DEFAULT_LEN
:
u16
=
u16_cvt
!
(
TISHREI_LEN
+
ESHVAN_DEFAULT_LEN
+
KISLEV_DEFAULT_LEN
+
TEVET_LEN
+
SHEVAT_LEN
)
;
let
Some
(
normalized_ordinal_month
)
=
self
.
normalized_ordinal_month
(
ordinal_month
)
else
{
let
corrected
=
BEFORE_ADAR_DEFAULT_LEN
as
i16
+
i16
:
:
from
(
self
.
year_type
(
)
.
length_correction
(
)
)
;
return
corrected
as
u16
;
}
;
debug_assert
!
(
normalized_ordinal_month
<
=
ELUL
&
&
normalized_ordinal_month
>
0
)
;
let
year_type
=
self
.
year_type
(
)
;
let
mut
days
=
match
normalized_ordinal_month
{
TISHREI
=
>
0
ESHVAN
=
>
u16_cvt
!
(
TISHREI_LEN
)
KISLEV
=
>
u16_cvt
!
(
TISHREI_LEN
)
+
u16
:
:
from
(
year_type
.
eshvan_length
(
)
)
TEVET
=
>
u16_cvt
!
(
TISHREI_LEN
+
ESHVAN_DEFAULT_LEN
+
KISLEV_DEFAULT_LEN
)
SHEVAT
=
>
u16_cvt
!
(
TISHREI_LEN
+
ESHVAN_DEFAULT_LEN
+
KISLEV_DEFAULT_LEN
+
TEVET_LEN
)
ADAR
=
>
BEFORE_ADAR_DEFAULT_LEN
NISAN
=
>
u16_cvt
!
(
BEFORE_ADAR_DEFAULT_LEN
+
ADAR_LEN
)
IYYAR
=
>
u16_cvt
!
(
BEFORE_ADAR_DEFAULT_LEN
+
ADAR_LEN
+
NISAN_LEN
)
SIVAN
=
>
u16_cvt
!
(
BEFORE_ADAR_DEFAULT_LEN
+
ADAR_LEN
+
NISAN_LEN
+
IYYAR_LEN
)
TAMMUZ
=
>
{
u16_cvt
!
(
BEFORE_ADAR_DEFAULT_LEN
+
ADAR_LEN
+
NISAN_LEN
+
IYYAR_LEN
+
SIVAN_LEN
)
}
#
[
rustfmt
:
:
skip
]
AV
=
>
u16_cvt
!
(
BEFORE_ADAR_DEFAULT_LEN
+
ADAR_LEN
+
NISAN_LEN
+
IYYAR_LEN
+
SIVAN_LEN
+
TAMMUZ_LEN
)
#
[
rustfmt
:
:
skip
]
_
=
>
u16_cvt
!
(
BEFORE_ADAR_DEFAULT_LEN
+
ADAR_LEN
+
NISAN_LEN
+
IYYAR_LEN
+
SIVAN_LEN
+
TAMMUZ_LEN
+
AV_LEN
)
}
;
if
normalized_ordinal_month
>
KISLEV
{
debug_assert
!
(
days
>
1
&
&
year_type
.
length_correction
(
)
.
abs
(
)
<
=
1
)
;
days
=
(
days
as
i16
+
year_type
.
length_correction
(
)
as
i16
)
as
u16
;
}
if
normalized_ordinal_month
>
=
ADAR
&
&
self
.
is_leap
(
)
{
days
+
=
u16
:
:
from
(
ADARI_LEN
)
;
}
days
}
pub
fn
month_day_for
(
self
mut
day
:
u16
)
-
>
(
u8
u8
)
{
for
month
in
1
.
.
14
{
let
month_len
=
self
.
month_len
(
month
)
;
if
let
Ok
(
day
)
=
u8
:
:
try_from
(
day
)
{
if
day
<
=
month_len
{
return
(
month
day
)
;
}
}
day
-
=
u16
:
:
from
(
month_len
)
;
}
debug_assert
!
(
false
"
Attempted
to
get
Hebrew
date
for
{
day
:
?
}
in
keviyah
{
self
:
?
}
didn
'
t
have
enough
days
in
the
year
"
)
;
self
.
last_month_day_in_year
(
)
}
#
[
inline
]
pub
fn
last_month_day_in_year
(
self
)
-
>
(
u8
u8
)
{
if
self
.
is_leap
(
)
{
(
13
ELUL_LEN
)
}
else
{
(
12
ELUL_LEN
)
}
}
#
[
inline
]
pub
fn
is_leap
(
self
)
-
>
bool
{
debug_assert_eq
!
(
Self
:
:
as
u8
7
"
Representation
of
keviyot
changed
!
"
)
;
self
>
=
Self
:
:
}
#
[
inline
]
pub
fn
year_info
(
self
h_year
:
i32
)
-
>
YearInfo
{
let
(
mut
weeks_since_beharad
alakim
)
=
molad_details
(
h_year
)
;
if
alakim
>
al
!
(
7
-
18
-
0
)
{
weeks_since_beharad
+
=
1
;
}
YearInfo
{
keviyah
:
self
weeks_since_beharad
}
}
#
[
inline
]
pub
fn
year_length
(
self
)
-
>
u16
{
let
base_year_length
=
if
self
.
is_leap
(
)
{
384
}
else
{
354
}
;
(
base_year_length
+
i16
:
:
from
(
self
.
year_type
(
)
.
length_correction
(
)
)
)
as
u16
}
#
[
inline
]
pub
fn
from_integer
(
integer
:
u8
)
-
>
Self
{
debug_assert
!
(
integer
<
14
"
Keviyah
:
:
from_integer
(
)
takes
in
a
number
between
0
and
13
inclusive
"
)
;
match
integer
{
0
=
>
Self
:
:
1
=
>
Self
:
:
2
=
>
Self
:
:
3
=
>
Self
:
:
4
=
>
Self
:
:
5
=
>
Self
:
:
6
=
>
Self
:
:
7
=
>
Self
:
:
8
=
>
Self
:
:
9
=
>
Self
:
:
10
=
>
Self
:
:
11
=
>
Self
:
:
12
=
>
Self
:
:
_
=
>
Self
:
:
}
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Debug
)
]
enum
MetonicCycleType
{
LMinusOne
LPlusOne
LPlusMinusOne
Leap
}
impl
MetonicCycleType
{
fn
for_h_year
(
h_year
:
i32
)
-
>
Self
{
let
remainder
=
h_year
.
rem_euclid
(
19
)
;
match
remainder
{
2
|
5
|
10
|
13
|
16
=
>
Self
:
:
LMinusOne
1
|
4
|
9
|
12
|
15
=
>
Self
:
:
LPlusOne
7
|
18
=
>
Self
:
:
LPlusMinusOne
_
=
>
{
debug_assert
!
(
matches
!
(
remainder
3
|
6
|
8
|
11
|
14
|
17
|
0
|
19
)
)
;
Self
:
:
Leap
}
}
}
}
const
FOUR_GATES_LMINUSONE
:
[
i32
;
7
]
=
[
al
!
(
7
-
18
-
0
)
al
!
(
1
-
9
-
204
)
al
!
(
2
-
18
-
0
)
al
!
(
3
-
9
-
204
)
al
!
(
5
-
9
-
204
)
al
!
(
5
-
18
-
0
)
al
!
(
6
-
9
-
204
)
]
;
const
FOUR_GATES_LPLUSONE
:
[
i32
;
7
]
=
[
al
!
(
7
-
18
-
0
)
al
!
(
1
-
9
-
204
)
al
!
(
2
-
15
-
589
)
al
!
(
3
-
9
-
204
)
al
!
(
5
-
9
-
204
)
al
!
(
5
-
18
-
0
)
al
!
(
6
-
0
-
408
)
]
;
const
FOUR_GATES_LPLUSMINUSONE
:
[
i32
;
7
]
=
[
al
!
(
7
-
18
-
0
)
al
!
(
1
-
9
-
204
)
al
!
(
2
-
15
-
589
)
al
!
(
3
-
9
-
204
)
al
!
(
5
-
9
-
204
)
al
!
(
5
-
18
-
0
)
al
!
(
6
-
9
-
204
)
]
;
const
FOUR_GATES_LEAP
:
[
i32
;
7
]
=
[
al
!
(
7
-
18
-
0
)
al
!
(
1
-
20
-
491
)
al
!
(
2
-
18
-
0
)
al
!
(
3
-
18
-
0
)
al
!
(
4
-
11
-
695
)
al
!
(
5
-
18
-
0
)
al
!
(
6
-
20
-
491
)
]
;
#
[
inline
]
fn
keviyah_for
(
year_type
:
MetonicCycleType
alakim
:
i32
)
-
>
Keviyah
{
let
gate
=
match
year_type
{
MetonicCycleType
:
:
LMinusOne
=
>
FOUR_GATES_LMINUSONE
MetonicCycleType
:
:
LPlusOne
=
>
FOUR_GATES_LPLUSONE
MetonicCycleType
:
:
LPlusMinusOne
=
>
FOUR_GATES_LPLUSMINUSONE
MetonicCycleType
:
:
Leap
=
>
FOUR_GATES_LEAP
}
;
let
keviyot
=
if
alakim
>
=
gate
[
0
]
|
|
alakim
<
gate
[
1
]
{
(
Keviyah
:
:
Keviyah
:
:
)
}
else
if
alakim
<
gate
[
2
]
{
(
Keviyah
:
:
Keviyah
:
:
)
}
else
if
alakim
<
gate
[
3
]
{
(
Keviyah
:
:
Keviyah
:
:
)
}
else
if
alakim
<
gate
[
4
]
{
(
Keviyah
:
:
Keviyah
:
:
)
}
else
if
alakim
<
gate
[
5
]
{
(
Keviyah
:
:
Keviyah
:
:
)
}
else
if
alakim
<
gate
[
6
]
{
(
Keviyah
:
:
Keviyah
:
:
)
}
else
{
(
Keviyah
:
:
Keviyah
:
:
)
}
;
debug_assert
!
(
keviyot
.
0
as
u8
+
7
=
=
keviyot
.
1
as
u8
"
The
table
above
should
produce
matching
-
indexed
keviyot
for
the
leap
/
non
-
leap
year
"
)
;
#
[
cfg
(
debug_assertions
)
]
#
[
allow
(
clippy
:
:
indexing_slicing
)
]
if
keviyot
.
0
as
u8
=
=
0
{
debug_assert
!
(
alakim
>
=
gate
[
keviyot
.
0
as
usize
]
|
|
alakim
<
gate
[
(
keviyot
.
0
as
usize
+
1
)
%
7
]
"
The
table
above
should
produce
the
right
indexed
keviyah
instead
found
{
keviyot
:
?
}
for
time
{
alakim
}
(
year
type
{
year_type
:
?
}
)
"
)
;
}
else
{
debug_assert
!
(
alakim
>
=
gate
[
keviyot
.
0
as
usize
]
&
&
alakim
<
gate
[
(
keviyot
.
0
as
usize
+
1
)
%
7
]
"
The
table
above
should
produce
the
right
indexed
keviyah
instead
found
{
keviyot
:
?
}
for
time
{
alakim
}
(
year
type
{
year_type
:
?
}
)
"
)
;
}
if
year_type
=
=
MetonicCycleType
:
:
Leap
{
keviyot
.
1
}
else
{
keviyot
.
0
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
hebrew
:
:
{
self
BookHebrew
}
;
#
[
test
]
fn
test_consts
(
)
{
assert_eq
!
(
MOLAD_BEHERAD_OFFSET
31524
)
;
assert_eq
!
(
ALAKIM_IN_WEEK
181440
)
;
assert_eq
!
(
HEBREW_LUNATION_TIME
765433
)
;
assert_eq
!
(
HEBREW_CALENDAR_EPOCH
hebrew
:
:
FIXED_HEBREW_EPOCH
)
;
}
#
[
test
]
fn
test_roundtrip_days
(
)
{
for
h_year
in
(
1
.
.
10
)
.
chain
(
5775
.
.
5795
)
.
chain
(
10000
.
.
10010
)
{
let
year_info
=
YearInfo
:
:
compute_for
(
h_year
)
;
let
ny
=
year_info
.
new_year
(
)
;
for
day
in
1
.
.
=
year_info
.
keviyah
.
year_length
(
)
{
let
offset_date
=
ny
+
i64
:
:
from
(
day
)
-
1
;
let
(
offset_yearinfo
offset_h_year
)
=
YearInfo
:
:
year_containing_rd
(
offset_date
)
;
assert_eq
!
(
offset_h_year
h_year
"
Backcomputed
h_year
should
be
same
for
day
{
day
}
in
Hebrew
Year
{
h_year
}
"
)
;
assert_eq
!
(
offset_yearinfo
year_info
"
Backcomputed
YearInfo
should
be
same
for
day
{
day
}
in
Hebrew
Year
{
h_year
}
"
)
;
let
(
month
day2
)
=
year_info
.
keviyah
.
month_day_for
(
day
)
;
let
days_preceding
=
year_info
.
keviyah
.
days_preceding
(
month
)
;
assert_eq
!
(
days_preceding
+
u16
:
:
from
(
day2
)
day
"
{
h_year
}
-
{
month
}
-
{
day2
}
should
round
trip
for
day
-
of
-
year
{
day
}
"
)
}
}
}
#
[
test
]
fn
test_book_parity
(
)
{
let
mut
last_year
=
None
;
for
h_year
in
(
1
.
.
100
)
.
chain
(
5600
.
.
5900
)
.
chain
(
10000
.
.
10100
)
{
let
book_date
=
BookHebrew
:
:
from_civil_date
(
h_year
1
1
)
;
let
book_ny
=
BookHebrew
:
:
fixed_from_book_hebrew
(
book_date
)
;
let
kv_yearinfo
=
YearInfo
:
:
compute_for
(
h_year
)
;
let
kv_ny
=
kv_yearinfo
.
new_year
(
)
;
assert_eq
!
(
book_ny
kv_ny
"
Book
and
Keviyah
-
based
years
should
match
for
Hebrew
Year
{
h_year
}
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
let
book_is_leap
=
BookHebrew
:
:
is_hebrew_leap_year
(
h_year
)
;
assert_eq
!
(
book_is_leap
kv_yearinfo
.
keviyah
.
is_leap
(
)
"
Book
and
Keviyah
-
based
years
should
match
for
Hebrew
Year
{
h_year
}
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
let
book_year_len
=
BookHebrew
:
:
days_in_book_hebrew_year
(
h_year
)
;
let
book_year_type
=
match
book_year_len
{
355
|
385
=
>
YearType
:
:
Complete
354
|
384
=
>
YearType
:
:
Regular
353
|
383
=
>
YearType
:
:
Deficient
_
=
>
unreachable
!
(
"
Found
unexpected
book
year
len
{
book_year_len
}
"
)
}
;
assert_eq
!
(
book_year_type
kv_yearinfo
.
keviyah
.
year_type
(
)
"
Book
and
Keviyah
-
based
years
should
match
for
Hebrew
Year
{
h_year
}
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
let
kv_recomputed_yearinfo
=
kv_yearinfo
.
keviyah
.
year_info
(
h_year
)
;
assert_eq
!
(
kv_recomputed_yearinfo
kv_yearinfo
"
Recomputed
YearInfo
should
match
for
Hebrew
Year
{
h_year
}
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
let
year_len
=
kv_yearinfo
.
keviyah
.
year_length
(
)
;
let
month_range
=
if
kv_yearinfo
.
keviyah
.
is_leap
(
)
{
1
.
.
14
}
else
{
1
.
.
13
}
;
let
mut
days_preceding
=
0
;
for
month
in
month_range
{
let
kv_month_len
=
kv_yearinfo
.
keviyah
.
month_len
(
month
)
;
let
book_date
=
BookHebrew
:
:
from_civil_date
(
h_year
month
1
)
;
let
book_month_len
=
BookHebrew
:
:
last_day_of_book_hebrew_month
(
book_date
.
year
book_date
.
month
)
;
assert_eq
!
(
kv_month_len
book_month_len
"
Month
lengths
should
be
same
for
ordinal
hebrew
month
{
month
}
in
year
{
h_year
}
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
assert_eq
!
(
days_preceding
kv_yearinfo
.
keviyah
.
days_preceding
(
month
)
"
Days
preceding
should
be
the
sum
of
preceding
days
for
ordinal
hebrew
month
{
month
}
in
year
{
h_year
}
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
days_preceding
+
=
u16
:
:
from
(
kv_month_len
)
;
}
for
offset
in
[
0
1
100
year_len
-
100
year_len
-
2
year_len
-
1
]
{
let
offset_date
=
kv_ny
+
offset
.
into
(
)
;
let
(
offset_yearinfo
offset_h_year
)
=
YearInfo
:
:
year_containing_rd
(
offset_date
)
;
assert_eq
!
(
offset_h_year
h_year
"
Backcomputed
h_year
should
be
same
for
date
{
offset_date
:
?
}
in
Hebrew
Year
{
h_year
}
(
offset
from
ny
{
offset
}
)
"
)
;
assert_eq
!
(
offset_yearinfo
kv_yearinfo
"
Backcomputed
YearInfo
should
be
same
for
date
{
offset_date
:
?
}
in
Hebrew
Year
{
h_year
}
(
offset
from
ny
{
offset
}
)
"
)
;
}
if
let
Some
(
(
last_h_year
predicted_ny
)
)
=
last_year
{
if
last_h_year
+
1
=
=
h_year
{
assert_eq
!
(
predicted_ny
kv_ny
"
{
last_h_year
}
'
s
YearInfo
predicts
New
Year
{
predicted_ny
:
?
}
which
does
not
match
current
new
year
.
Got
YearInfo
{
kv_yearinfo
:
?
}
"
)
;
}
}
last_year
=
Some
(
(
h_year
kv_ny
+
year_len
.
into
(
)
)
)
}
}
#
[
test
]
fn
test_minmax
(
)
{
let
min
=
YearInfo
:
:
compute_for
(
HEBREW_MIN_YEAR
)
;
let
min_ny
=
min
.
new_year
(
)
;
assert_eq
!
(
min_ny
HEBREW_MIN_RD
)
;
let
(
recomputed_yi
recomputed_y
)
=
YearInfo
:
:
year_containing_rd
(
min_ny
)
;
assert_eq
!
(
recomputed_y
HEBREW_MIN_YEAR
)
;
assert_eq
!
(
recomputed_yi
min
)
;
let
max
=
YearInfo
:
:
compute_for
(
HEBREW_MAX_YEAR
)
;
let
max_ny
=
max
.
new_year
(
)
;
let
max_last
=
max_ny
+
i64
:
:
from
(
max
.
keviyah
.
year_length
(
)
)
-
1
;
assert_eq
!
(
max_last
HEBREW_MAX_RD
)
;
let
(
recomputed_yi
recomputed_y
)
=
YearInfo
:
:
year_containing_rd
(
max_last
)
;
assert_eq
!
(
recomputed_y
HEBREW_MAX_YEAR
)
;
assert_eq
!
(
recomputed_yi
max
)
;
}
#
[
test
]
fn
test_leap_agreement
(
)
{
for
year0
in
-
1000
.
.
1000
{
let
year1
=
year0
+
1
;
let
info0
=
YearInfo
:
:
compute_for
(
year0
)
;
let
info1
=
YearInfo
:
:
compute_for
(
year1
)
;
let
num_months
=
(
info1
.
new_year
(
)
-
info0
.
new_year
(
)
)
/
29
;
if
info0
.
keviyah
.
is_leap
(
)
{
assert_eq
!
(
num_months
13
"
{
year0
}
"
)
;
}
else
{
assert_eq
!
(
num_months
12
"
{
year0
}
"
)
;
}
}
}
}
