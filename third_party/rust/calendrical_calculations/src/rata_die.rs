use
core
:
:
fmt
;
use
core
:
:
ops
:
:
{
Add
AddAssign
Sub
SubAssign
}
;
#
[
allow
(
unused_imports
)
]
use
core_maths
:
:
*
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
RataDie
(
i64
)
;
impl
RataDie
{
pub
const
fn
new
(
fixed_date
:
i64
)
-
>
Self
{
let
result
=
Self
(
fixed_date
)
;
#
[
cfg
(
debug_assertions
)
]
result
.
check
(
)
;
result
}
#
[
cfg
(
debug_assertions
)
]
const
fn
check
(
self
)
{
if
self
.
0
>
i64
:
:
MAX
/
256
{
debug_assert
!
(
false
"
RataDie
is
not
designed
to
store
values
near
to
the
overflow
boundary
"
)
;
}
if
self
.
0
<
i64
:
:
MIN
/
256
{
debug_assert
!
(
false
"
RataDie
is
not
designed
to
store
values
near
to
the
overflow
boundary
"
)
;
}
}
#
[
doc
(
hidden
)
]
pub
const
fn
big_negative
(
)
-
>
Self
{
Self
:
:
new
(
i64
:
:
MIN
/
256
/
256
)
}
pub
const
fn
to_i64_date
(
self
)
-
>
i64
{
self
.
0
}
pub
(
crate
)
const
fn
to_f64_date
(
self
)
-
>
f64
{
self
.
0
as
f64
}
pub
const
fn
until
(
self
rhs
:
Self
)
-
>
i64
{
self
.
0
-
rhs
.
0
}
pub
const
fn
add
(
self
rhs
:
i64
)
-
>
Self
{
let
result
=
Self
(
self
.
0
+
rhs
)
;
#
[
cfg
(
debug_assertions
)
]
result
.
check
(
)
;
result
}
pub
(
crate
)
const
fn
as_moment
(
self
)
-
>
Moment
{
Moment
:
:
new
(
self
.
0
as
f64
)
}
}
impl
fmt
:
:
Debug
for
RataDie
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
rd
=
self
.
0
;
if
let
Ok
(
(
y
m
d
)
)
=
crate
:
:
iso
:
:
iso_from_fixed
(
*
self
)
{
write
!
(
f
"
{
rd
}
R
.
D
.
(
{
y
}
-
{
m
:
02
}
-
{
d
:
02
}
)
"
)
}
else
{
write
!
(
f
"
{
rd
}
R
.
D
.
(
out
of
bounds
)
"
)
}
}
}
impl
Add
<
i64
>
for
RataDie
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
i64
)
-
>
Self
:
:
Output
{
self
.
add
(
rhs
)
}
}
impl
AddAssign
<
i64
>
for
RataDie
{
fn
add_assign
(
&
mut
self
rhs
:
i64
)
{
self
.
0
+
=
rhs
;
}
}
impl
Sub
<
i64
>
for
RataDie
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
i64
)
-
>
Self
:
:
Output
{
let
result
=
Self
(
self
.
0
-
rhs
)
;
#
[
cfg
(
debug_assertions
)
]
result
.
check
(
)
;
result
}
}
impl
SubAssign
<
i64
>
for
RataDie
{
fn
sub_assign
(
&
mut
self
rhs
:
i64
)
{
self
.
0
-
=
rhs
;
}
}
impl
Sub
for
RataDie
{
type
Output
=
i64
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
until
(
rhs
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
PartialOrd
)
]
pub
(
crate
)
struct
Moment
(
f64
)
;
impl
Add
<
f64
>
for
Moment
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
f64
)
-
>
Self
:
:
Output
{
Self
(
self
.
0
+
rhs
)
}
}
impl
AddAssign
<
f64
>
for
Moment
{
fn
add_assign
(
&
mut
self
rhs
:
f64
)
{
self
.
0
+
=
rhs
;
}
}
impl
Sub
<
f64
>
for
Moment
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
f64
)
-
>
Self
:
:
Output
{
Self
(
self
.
0
-
rhs
)
}
}
impl
SubAssign
<
f64
>
for
Moment
{
fn
sub_assign
(
&
mut
self
rhs
:
f64
)
{
self
.
0
-
=
rhs
;
}
}
impl
Sub
for
Moment
{
type
Output
=
f64
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
0
-
rhs
.
0
}
}
impl
Moment
{
pub
const
fn
new
(
value
:
f64
)
-
>
Moment
{
Moment
(
value
)
}
pub
const
fn
inner
(
self
)
-
>
f64
{
self
.
0
}
pub
fn
as_rata_die
(
self
)
-
>
RataDie
{
RataDie
:
:
new
(
self
.
0
.
floor
(
)
as
i64
)
}
}
#
[
test
]
fn
test_moment_to_rata_die_conversion
(
)
{
for
i
in
-
1000
.
.
=
1000
{
let
moment
=
Moment
:
:
new
(
i
as
f64
)
;
let
rata_die
=
moment
.
as_rata_die
(
)
;
assert_eq
!
(
rata_die
.
to_i64_date
(
)
i
)
;
}
}
