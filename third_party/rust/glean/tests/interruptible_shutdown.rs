mod
common
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
time
:
:
Instant
;
use
crossbeam_channel
:
:
{
bounded
Sender
}
;
use
flate2
:
:
read
:
:
GzDecoder
;
use
serde_json
:
:
Value
as
JsonValue
;
use
glean
:
:
net
;
use
glean
:
:
{
ConfigurationBuilder
PingRateLimit
}
;
mod
metrics
{
#
!
[
allow
(
non_upper_case_globals
)
]
use
glean
:
:
{
private
:
:
BooleanMetric
CommonMetricData
Lifetime
}
;
use
once_cell
:
:
sync
:
:
Lazy
;
pub
static
sample_boolean
:
Lazy
<
BooleanMetric
>
=
Lazy
:
:
new
(
|
|
{
BooleanMetric
:
:
new
(
CommonMetricData
{
name
:
"
sample_boolean
"
.
into
(
)
category
:
"
test
.
metrics
"
.
into
(
)
send_in_pings
:
vec
!
[
"
validation
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
)
}
)
;
}
mod
pings
{
use
super
:
:
*
;
use
glean
:
:
private
:
:
PingType
;
use
once_cell
:
:
sync
:
:
Lazy
;
#
[
allow
(
non_upper_case_globals
)
]
pub
static
validation
:
Lazy
<
PingType
>
=
Lazy
:
:
new
(
|
|
{
common
:
:
PingBuilder
:
:
new
(
"
validation
"
)
.
with_send_if_empty
(
true
)
.
build
(
)
}
)
;
}
#
[
derive
(
Debug
)
]
struct
ReportingUploader
{
calls
:
AtomicUsize
sender
:
Sender
<
JsonValue
>
}
impl
net
:
:
PingUploader
for
ReportingUploader
{
fn
upload
(
&
self
upload_request
:
net
:
:
CapablePingUploadRequest
)
-
>
net
:
:
UploadResult
{
let
upload_request
=
upload_request
.
capable
(
|
_
|
true
)
.
unwrap
(
)
;
let
calls
=
self
.
calls
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
let
body
=
upload_request
.
body
;
let
decode
=
|
body
:
Vec
<
u8
>
|
{
let
mut
gzip_decoder
=
GzDecoder
:
:
new
(
&
body
[
.
.
]
)
;
let
mut
s
=
String
:
:
with_capacity
(
body
.
len
(
)
)
;
gzip_decoder
.
read_to_string
(
&
mut
s
)
.
ok
(
)
.
map
(
|
_
|
&
s
[
.
.
]
)
.
or_else
(
|
|
std
:
:
str
:
:
from_utf8
(
&
body
)
.
ok
(
)
)
.
and_then
(
|
payload
|
serde_json
:
:
from_str
(
payload
)
.
ok
(
)
)
.
unwrap
(
)
}
;
match
calls
{
0
=
>
{
self
.
sender
.
send
(
decode
(
body
)
)
.
unwrap
(
)
;
net
:
:
UploadResult
:
:
http_status
(
200
)
}
1
=
>
panic
!
(
"
We
should
shutdown
before
getting
to
the
second
ping
"
)
_
=
>
panic
!
(
"
Wat
.
"
)
}
}
}
#
[
test
]
fn
interruptible_shutdown
(
)
{
common
:
:
enable_test_logging
(
)
;
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
tmpname
=
dir
.
path
(
)
.
to_path_buf
(
)
;
let
(
tx
rx
)
=
bounded
(
1
)
;
let
mut
cfg
=
ConfigurationBuilder
:
:
new
(
true
tmpname
.
clone
(
)
"
glean
-
interruptible
-
shutdown
"
)
.
with_server_endpoint
(
"
invalid
-
test
-
host
"
)
.
with_use_core_mps
(
false
)
.
with_uploader
(
ReportingUploader
{
calls
:
AtomicUsize
:
:
new
(
0
)
sender
:
tx
}
)
.
build
(
)
;
cfg
.
rate_limit
=
Some
(
PingRateLimit
{
seconds_per_interval
:
600
pings_per_interval
:
1
}
)
;
common
:
:
initialize
(
cfg
)
;
let
_
=
metrics
:
:
sample_boolean
.
test_get_value
(
None
)
;
pings
:
:
validation
.
submit
(
None
)
;
let
_body
=
rx
.
recv
(
)
.
unwrap
(
)
;
pings
:
:
validation
.
submit
(
None
)
;
let
pre_shutdown
=
Instant
:
:
now
(
)
;
glean
:
:
shutdown
(
)
;
let
shutdown_elapsed
=
pre_shutdown
.
elapsed
(
)
;
assert
!
(
shutdown_elapsed
.
as_secs
(
)
<
2
"
We
shouldn
'
t
have
been
slow
on
shutdown
.
"
)
;
}
