use
once_cell
:
:
sync
:
:
{
Lazy
OnceCell
}
;
use
std
:
:
sync
:
:
RwLock
;
use
super
:
:
{
DispatchError
DispatchGuard
Dispatcher
}
;
const
GLOBAL_DISPATCHER_LIMIT
:
usize
=
100
;
static
GLOBAL_DISPATCHER
:
Lazy
<
RwLock
<
Option
<
Dispatcher
>
>
>
=
Lazy
:
:
new
(
|
|
RwLock
:
:
new
(
Some
(
Dispatcher
:
:
new
(
GLOBAL_DISPATCHER_LIMIT
)
)
)
)
;
fn
guard
(
)
-
>
&
'
static
DispatchGuard
{
static
GLOBAL_GUARD
:
OnceCell
<
DispatchGuard
>
=
OnceCell
:
:
new
(
)
;
GLOBAL_GUARD
.
get_or_init
(
|
|
{
let
lock
=
GLOBAL_DISPATCHER
.
read
(
)
.
unwrap
(
)
;
lock
.
as_ref
(
)
.
unwrap
(
)
.
guard
(
)
}
)
}
pub
fn
launch
(
task
:
impl
FnOnce
(
)
+
Send
+
'
static
)
{
match
guard
(
)
.
launch
(
task
)
{
Ok
(
_
)
=
>
{
}
Err
(
DispatchError
:
:
QueueFull
)
=
>
{
log
:
:
info
!
(
"
Exceeded
maximum
queue
size
discarding
task
"
)
;
}
Err
(
_
)
=
>
{
log
:
:
info
!
(
"
Failed
to
launch
a
task
on
the
queue
.
Discarding
task
.
"
)
;
}
}
}
pub
fn
block_on_queue
(
)
{
let
guard
=
{
GLOBAL_DISPATCHER
.
write
(
)
.
unwrap
(
)
.
as_ref
(
)
.
map
(
|
dispatcher
|
dispatcher
.
guard
(
)
)
.
unwrap
(
)
}
;
guard
.
block_on_queue
(
)
;
}
pub
fn
flush_init
(
)
-
>
Result
<
(
)
DispatchError
>
{
let
mut
guard
=
{
GLOBAL_DISPATCHER
.
write
(
)
.
unwrap
(
)
.
as_ref
(
)
.
map
(
|
dispatcher
|
dispatcher
.
guard
(
)
)
.
unwrap
(
)
}
;
guard
.
flush_init
(
)
}
pub
fn
try_shutdown
(
)
-
>
Result
<
(
)
DispatchError
>
{
guard
(
)
.
shutdown
(
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
super
:
:
*
;
#
[
test
]
#
[
ignore
]
fn
global_fills_up_in_order_and_works
(
)
{
let
_
=
env_logger
:
:
builder
(
)
.
is_test
(
true
)
.
try_init
(
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
for
i
in
1
.
.
=
GLOBAL_DISPATCHER_LIMIT
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
;
}
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
150
)
;
}
)
;
}
flush_init
(
)
.
unwrap
(
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
200
)
;
}
)
;
}
block_on_queue
(
)
;
let
mut
expected
=
(
1
.
.
=
GLOBAL_DISPATCHER_LIMIT
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
expected
.
push
(
200
)
;
assert_eq
!
(
&
*
result
.
lock
(
)
.
unwrap
(
)
&
expected
)
;
}
}
