use
once_cell
:
:
sync
:
:
Lazy
;
use
std
:
:
sync
:
:
RwLock
;
use
super
:
:
{
DispatchError
DispatchGuard
Dispatcher
}
;
pub
const
GLOBAL_DISPATCHER_LIMIT
:
usize
=
100
;
static
GLOBAL_DISPATCHER
:
Lazy
<
RwLock
<
Option
<
Dispatcher
>
>
>
=
Lazy
:
:
new
(
|
|
RwLock
:
:
new
(
Some
(
Dispatcher
:
:
new
(
GLOBAL_DISPATCHER_LIMIT
)
)
)
)
;
fn
guard
(
)
-
>
DispatchGuard
{
GLOBAL_DISPATCHER
.
read
(
)
.
unwrap
(
)
.
as_ref
(
)
.
map
(
|
dispatcher
|
dispatcher
.
guard
(
)
)
.
unwrap
(
)
}
pub
fn
launch
(
task
:
impl
FnOnce
(
)
+
Send
+
'
static
)
{
match
guard
(
)
.
launch
(
task
)
{
Ok
(
_
)
=
>
{
}
Err
(
DispatchError
:
:
QueueFull
)
=
>
{
log
:
:
info
!
(
"
Exceeded
maximum
queue
size
discarding
task
"
)
;
}
Err
(
_
)
=
>
{
log
:
:
info
!
(
"
Failed
to
launch
a
task
on
the
queue
.
Discarding
task
.
"
)
;
}
}
}
pub
fn
block_on_queue
(
)
-
>
Result
<
(
)
DispatchError
>
{
guard
(
)
.
block_on_queue
(
)
}
pub
fn
flush_init
(
)
-
>
Result
<
usize
DispatchError
>
{
guard
(
)
.
flush_init
(
)
}
fn
join_dispatcher_thread
(
)
-
>
Result
<
(
)
DispatchError
>
{
let
mut
lock
=
GLOBAL_DISPATCHER
.
write
(
)
.
unwrap
(
)
;
let
dispatcher
=
lock
.
as_mut
(
)
.
expect
(
"
Global
dispatcher
has
gone
missing
"
)
;
if
let
Some
(
worker
)
=
dispatcher
.
worker
.
take
(
)
{
return
worker
.
join
(
)
.
map_err
(
|
_
|
DispatchError
:
:
WorkerPanic
)
;
}
Ok
(
(
)
)
}
pub
fn
kill
(
)
-
>
Result
<
(
)
DispatchError
>
{
guard
(
)
.
kill
(
)
?
;
join_dispatcher_thread
(
)
}
pub
fn
shutdown
(
)
-
>
Result
<
(
)
DispatchError
>
{
guard
(
)
.
shutdown
(
)
?
;
join_dispatcher_thread
(
)
}
pub
(
crate
)
fn
reset_dispatcher
(
)
{
let
_
=
shutdown
(
)
;
let
mut
lock
=
GLOBAL_DISPATCHER
.
write
(
)
.
unwrap
(
)
;
let
new_dispatcher
=
Some
(
Dispatcher
:
:
new
(
GLOBAL_DISPATCHER_LIMIT
)
)
;
*
lock
=
new_dispatcher
;
}
#
[
cfg
(
test
)
]
mod
test
{
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
super
:
:
*
;
#
[
test
]
#
[
ignore
]
fn
global_fills_up_in_order_and_works
(
)
{
let
_
=
env_logger
:
:
builder
(
)
.
is_test
(
true
)
.
try_init
(
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
for
i
in
1
.
.
=
GLOBAL_DISPATCHER_LIMIT
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
;
}
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
150
)
;
}
)
;
}
flush_init
(
)
.
unwrap
(
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
200
)
;
}
)
;
}
block_on_queue
(
)
.
unwrap
(
)
;
let
mut
expected
=
(
1
.
.
=
GLOBAL_DISPATCHER_LIMIT
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
expected
.
push
(
200
)
;
assert_eq
!
(
&
*
result
.
lock
(
)
.
unwrap
(
)
&
expected
)
;
}
#
[
test
]
#
[
ignore
]
fn
global_nested_calls
(
)
{
let
_
=
env_logger
:
:
builder
(
)
.
is_test
(
true
)
.
try_init
(
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
1
)
;
}
)
;
}
flush_init
(
)
.
unwrap
(
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
21
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
3
)
;
}
)
;
}
result
.
lock
(
)
.
unwrap
(
)
.
push
(
22
)
;
}
)
;
}
block_on_queue
(
)
.
unwrap
(
)
;
let
expected
=
vec
!
[
1
21
22
3
]
;
assert_eq
!
(
&
*
result
.
lock
(
)
.
unwrap
(
)
&
expected
)
;
}
}
