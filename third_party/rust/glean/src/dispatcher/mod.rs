#
!
[
allow
(
dead_code
)
]
use
std
:
:
{
mem
sync
:
:
{
atomic
:
:
{
AtomicBool
Ordering
}
Arc
}
thread
:
:
{
self
JoinHandle
}
}
;
use
crossbeam_channel
:
:
{
bounded
unbounded
SendError
Sender
TrySendError
}
;
use
thiserror
:
:
Error
;
pub
use
global
:
:
*
;
mod
global
;
enum
Blocked
{
Shutdown
Continue
}
enum
Command
{
Task
(
Box
<
dyn
FnOnce
(
)
+
Send
>
)
Swap
(
Sender
<
(
)
>
)
Shutdown
}
#
[
derive
(
Error
Debug
PartialEq
)
]
pub
enum
DispatchError
{
#
[
error
(
"
The
worker
panicked
while
running
a
task
"
)
]
WorkerPanic
#
[
error
(
"
Maximum
queue
size
reached
"
)
]
QueueFull
#
[
error
(
"
Pre
-
init
buffer
was
already
flushed
"
)
]
AlreadyFlushed
#
[
error
(
"
Failed
to
send
command
to
worker
thread
"
)
]
SendError
#
[
error
(
"
Failed
to
receive
from
channel
"
)
]
RecvError
(
#
[
from
]
crossbeam_channel
:
:
RecvError
)
}
impl
From
<
TrySendError
<
Command
>
>
for
DispatchError
{
fn
from
(
err
:
TrySendError
<
Command
>
)
-
>
Self
{
match
err
{
TrySendError
:
:
Full
(
_
)
=
>
DispatchError
:
:
QueueFull
_
=
>
DispatchError
:
:
SendError
}
}
}
impl
<
T
>
From
<
SendError
<
T
>
>
for
DispatchError
{
fn
from
(
_
:
SendError
<
T
>
)
-
>
Self
{
DispatchError
:
:
SendError
}
}
#
[
derive
(
Clone
)
]
struct
DispatchGuard
{
queue_preinit
:
Arc
<
AtomicBool
>
block_sender
:
Sender
<
Blocked
>
preinit_sender
:
Sender
<
Command
>
sender
:
Sender
<
Command
>
}
impl
DispatchGuard
{
pub
fn
launch
(
&
self
task
:
impl
FnOnce
(
)
+
Send
+
'
static
)
-
>
Result
<
(
)
DispatchError
>
{
let
task
=
Command
:
:
Task
(
Box
:
:
new
(
task
)
)
;
self
.
send
(
task
)
}
pub
fn
shutdown
(
&
mut
self
)
-
>
Result
<
(
)
DispatchError
>
{
self
.
flush_init
(
)
.
ok
(
)
;
self
.
send
(
Command
:
:
Shutdown
)
}
fn
send
(
&
self
task
:
Command
)
-
>
Result
<
(
)
DispatchError
>
{
if
self
.
queue_preinit
.
load
(
Ordering
:
:
SeqCst
)
{
match
self
.
preinit_sender
.
try_send
(
task
)
{
Ok
(
(
)
)
=
>
Ok
(
(
)
)
Err
(
TrySendError
:
:
Full
(
_
)
)
=
>
Err
(
DispatchError
:
:
QueueFull
)
Err
(
TrySendError
:
:
Disconnected
(
_
)
)
=
>
Err
(
DispatchError
:
:
SendError
)
}
}
else
{
self
.
sender
.
send
(
task
)
?
;
Ok
(
(
)
)
}
}
fn
block_on_queue
(
&
self
)
{
let
(
tx
rx
)
=
crossbeam_channel
:
:
bounded
(
0
)
;
self
.
launch
(
move
|
|
{
tx
.
send
(
(
)
)
.
expect
(
"
(
worker
)
Can
'
t
send
message
on
single
-
use
channel
"
)
}
)
.
expect
(
"
Failed
to
launch
the
blocking
task
"
)
;
rx
.
recv
(
)
.
expect
(
"
Failed
to
receive
message
on
single
-
use
channel
"
)
;
}
fn
kill
(
&
mut
self
)
-
>
Result
<
(
)
DispatchError
>
{
let
old_val
=
self
.
queue_preinit
.
swap
(
false
Ordering
:
:
SeqCst
)
;
if
!
old_val
{
return
Err
(
DispatchError
:
:
AlreadyFlushed
)
;
}
self
.
block_sender
.
send
(
Blocked
:
:
Shutdown
)
?
;
Ok
(
(
)
)
}
fn
flush_init
(
&
mut
self
)
-
>
Result
<
(
)
DispatchError
>
{
let
old_val
=
self
.
queue_preinit
.
swap
(
false
Ordering
:
:
SeqCst
)
;
if
!
old_val
{
return
Err
(
DispatchError
:
:
AlreadyFlushed
)
;
}
self
.
block_sender
.
send
(
Blocked
:
:
Continue
)
?
;
let
(
swap_sender
swap_receiver
)
=
bounded
(
0
)
;
self
.
preinit_sender
.
send
(
Command
:
:
Swap
(
swap_sender
)
)
.
map_err
(
|
_
|
DispatchError
:
:
SendError
)
?
;
swap_receiver
.
recv
(
)
?
;
Ok
(
(
)
)
}
}
pub
struct
Dispatcher
{
guard
:
DispatchGuard
worker
:
Option
<
JoinHandle
<
(
)
>
>
}
impl
Dispatcher
{
pub
fn
new
(
max_queue_size
:
usize
)
-
>
Self
{
let
(
block_sender
block_receiver
)
=
bounded
(
1
)
;
let
(
preinit_sender
preinit_receiver
)
=
bounded
(
max_queue_size
)
;
let
(
sender
mut
unbounded_receiver
)
=
unbounded
(
)
;
let
queue_preinit
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
true
)
)
;
let
worker
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
glean
.
dispatcher
"
.
into
(
)
)
.
spawn
(
move
|
|
{
match
block_receiver
.
recv
(
)
{
Err
(
_
)
=
>
{
log
:
:
error
!
(
"
The
task
producer
was
disconnected
.
Worker
thread
will
exit
.
"
)
;
return
;
}
Ok
(
Blocked
:
:
Shutdown
)
=
>
{
return
;
}
Ok
(
Blocked
:
:
Continue
)
=
>
{
}
}
let
mut
receiver
=
preinit_receiver
;
loop
{
use
Command
:
:
*
;
match
receiver
.
recv
(
)
{
Ok
(
Shutdown
)
=
>
{
break
;
}
Ok
(
Task
(
f
)
)
=
>
{
(
f
)
(
)
;
}
Ok
(
Swap
(
swap_done
)
)
=
>
{
mem
:
:
swap
(
&
mut
receiver
&
mut
unbounded_receiver
)
;
swap_done
.
send
(
(
)
)
.
expect
(
"
The
caller
of
flush_init
has
gone
missing
"
)
;
}
Err
(
_
)
=
>
{
log
:
:
error
!
(
"
The
task
producer
was
disconnected
.
Worker
thread
will
exit
.
"
)
;
return
;
}
}
}
}
)
.
expect
(
"
Failed
to
spawn
Glean
'
s
dispatcher
thread
"
)
;
let
guard
=
DispatchGuard
{
queue_preinit
block_sender
preinit_sender
sender
}
;
Dispatcher
{
guard
worker
:
Some
(
worker
)
}
}
fn
guard
(
&
self
)
-
>
DispatchGuard
{
self
.
guard
.
clone
(
)
}
fn
block_on_queue
(
&
self
)
{
self
.
guard
(
)
.
block_on_queue
(
)
}
fn
join
(
mut
self
)
-
>
Result
<
(
)
DispatchError
>
{
if
let
Some
(
worker
)
=
self
.
worker
.
take
(
)
{
worker
.
join
(
)
.
map_err
(
|
_
|
DispatchError
:
:
WorkerPanic
)
?
;
}
Ok
(
(
)
)
}
pub
fn
flush_init
(
&
mut
self
)
-
>
Result
<
(
)
DispatchError
>
{
self
.
guard
(
)
.
flush_init
(
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicU8
Ordering
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
{
thread
time
:
:
Duration
}
;
fn
enable_test_logging
(
)
{
let
_
=
env_logger
:
:
builder
(
)
.
is_test
(
true
)
.
try_init
(
)
;
}
#
[
test
]
fn
tasks_run_off_the_main_thread
(
)
{
enable_test_logging
(
)
;
let
main_thread_id
=
thread
:
:
current
(
)
.
id
(
)
;
let
thread_canary
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
false
)
)
;
let
mut
dispatcher
=
Dispatcher
:
:
new
(
100
)
;
dispatcher
.
flush_init
(
)
.
expect
(
"
Failed
to
get
out
of
preinit
queue
mode
"
)
;
let
canary_clone
=
thread_canary
.
clone
(
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
assert
!
(
thread
:
:
current
(
)
.
id
(
)
!
=
main_thread_id
)
;
assert_eq
!
(
false
canary_clone
.
load
(
Ordering
:
:
SeqCst
)
)
;
canary_clone
.
store
(
true
Ordering
:
:
SeqCst
)
;
}
)
.
expect
(
"
Failed
to
dispatch
the
test
task
"
)
;
dispatcher
.
block_on_queue
(
)
;
assert_eq
!
(
true
thread_canary
.
load
(
Ordering
:
:
SeqCst
)
)
;
assert_eq
!
(
main_thread_id
thread
:
:
current
(
)
.
id
(
)
)
;
}
#
[
test
]
fn
launch_correctly_adds_tasks_to_preinit_queue
(
)
{
enable_test_logging
(
)
;
let
main_thread_id
=
thread
:
:
current
(
)
.
id
(
)
;
let
thread_canary
=
Arc
:
:
new
(
AtomicU8
:
:
new
(
0
)
)
;
let
mut
dispatcher
=
Dispatcher
:
:
new
(
100
)
;
for
_
in
0
.
.
3
{
let
canary_clone
=
thread_canary
.
clone
(
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
assert
!
(
thread
:
:
current
(
)
.
id
(
)
!
=
main_thread_id
)
;
canary_clone
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
)
.
expect
(
"
Failed
to
dispatch
the
test
task
"
)
;
}
assert_eq
!
(
0
thread_canary
.
load
(
Ordering
:
:
SeqCst
)
)
;
dispatcher
.
flush_init
(
)
.
expect
(
"
Failed
to
get
out
of
preinit
queue
mode
"
)
;
assert_eq
!
(
3
thread_canary
.
load
(
Ordering
:
:
SeqCst
)
)
;
}
#
[
test
]
fn
preinit_tasks_are_processed_after_flush
(
)
{
enable_test_logging
(
)
;
let
mut
dispatcher
=
Dispatcher
:
:
new
(
10
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
for
i
in
1
.
.
=
5
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
.
unwrap
(
)
;
}
result
.
lock
(
)
.
unwrap
(
)
.
push
(
0
)
;
dispatcher
.
flush_init
(
)
.
unwrap
(
)
;
for
i
in
6
.
.
=
10
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
.
unwrap
(
)
;
}
dispatcher
.
block_on_queue
(
)
;
assert_eq
!
(
&
*
result
.
lock
(
)
.
unwrap
(
)
&
[
0
1
2
3
4
5
6
7
8
9
10
]
)
;
}
#
[
test
]
fn
tasks_after_shutdown_are_not_processed
(
)
{
enable_test_logging
(
)
;
let
mut
dispatcher
=
Dispatcher
:
:
new
(
10
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
dispatcher
.
flush_init
(
)
.
unwrap
(
)
;
dispatcher
.
guard
(
)
.
shutdown
(
)
.
unwrap
(
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
let
_
=
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
0
)
;
}
)
;
}
dispatcher
.
join
(
)
.
unwrap
(
)
;
assert
!
(
result
.
lock
(
)
.
unwrap
(
)
.
is_empty
(
)
)
;
}
#
[
test
]
fn
preinit_buffer_fills_up
(
)
{
enable_test_logging
(
)
;
let
mut
dispatcher
=
Dispatcher
:
:
new
(
5
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
for
i
in
1
.
.
=
5
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
.
unwrap
(
)
;
}
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
let
err
=
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
10
)
;
}
)
;
assert_eq
!
(
Err
(
DispatchError
:
:
QueueFull
)
err
)
;
}
dispatcher
.
flush_init
(
)
.
unwrap
(
)
;
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
20
)
;
}
)
.
unwrap
(
)
;
}
dispatcher
.
block_on_queue
(
)
;
assert_eq
!
(
&
*
result
.
lock
(
)
.
unwrap
(
)
&
[
1
2
3
4
5
20
]
)
;
}
#
[
test
]
fn
normal_queue_is_unbounded
(
)
{
enable_test_logging
(
)
;
let
mut
dispatcher
=
Dispatcher
:
:
new
(
5
)
;
let
result
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
for
i
in
1
.
.
=
5
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
.
unwrap
(
)
;
}
dispatcher
.
flush_init
(
)
.
unwrap
(
)
;
for
i
in
6
.
.
=
20
{
let
result
=
Arc
:
:
clone
(
&
result
)
;
dispatcher
.
guard
(
)
.
launch
(
move
|
|
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
50
)
)
;
result
.
lock
(
)
.
unwrap
(
)
.
push
(
i
)
;
}
)
.
unwrap
(
)
;
}
dispatcher
.
guard
(
)
.
shutdown
(
)
.
unwrap
(
)
;
dispatcher
.
join
(
)
.
unwrap
(
)
;
let
expected
=
(
1
.
.
=
20
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
&
*
result
.
lock
(
)
.
unwrap
(
)
&
expected
)
;
}
}
