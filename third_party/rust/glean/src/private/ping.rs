use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
type
BoxedCallback
=
Box
<
dyn
FnOnce
(
Option
<
&
str
>
)
+
Send
+
'
static
>
;
#
[
derive
(
Clone
)
]
pub
struct
PingType
{
pub
(
crate
)
inner
:
glean_core
:
:
metrics
:
:
PingType
test_callback
:
Arc
<
Mutex
<
Option
<
BoxedCallback
>
>
>
}
impl
PingType
{
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
pub
fn
new
<
A
:
Into
<
String
>
>
(
name
:
A
include_client_id
:
bool
send_if_empty
:
bool
precise_timestamps
:
bool
include_info_sections
:
bool
enabled
:
bool
schedules_pings
:
Vec
<
String
>
reason_codes
:
Vec
<
String
>
follows_collection_enabled
:
bool
uploader_capabilities
:
Vec
<
String
>
)
-
>
Self
{
let
inner
=
glean_core
:
:
metrics
:
:
PingType
:
:
new
(
name
.
into
(
)
include_client_id
send_if_empty
precise_timestamps
include_info_sections
enabled
schedules_pings
reason_codes
follows_collection_enabled
uploader_capabilities
)
;
Self
{
inner
test_callback
:
Arc
:
:
new
(
Default
:
:
default
(
)
)
}
}
pub
fn
set_enabled
(
&
self
enabled
:
bool
)
{
self
.
inner
.
set_enabled
(
enabled
)
}
pub
fn
submit
(
&
self
reason
:
Option
<
&
str
>
)
{
let
mut
cb
=
self
.
test_callback
.
lock
(
)
.
unwrap
(
)
;
let
cb
=
cb
.
take
(
)
;
if
let
Some
(
cb
)
=
cb
{
cb
(
reason
)
}
self
.
inner
.
submit
(
reason
.
map
(
|
s
|
s
.
to_string
(
)
)
)
}
pub
fn
name
(
&
self
)
-
>
&
str
{
self
.
inner
.
name
(
)
}
pub
fn
include_client_id
(
&
self
)
-
>
bool
{
self
.
inner
.
include_client_id
(
)
}
pub
fn
send_if_empty
(
&
self
)
-
>
bool
{
self
.
inner
.
send_if_empty
(
)
}
pub
fn
precise_timestamps
(
&
self
)
-
>
bool
{
self
.
inner
.
precise_timestamps
(
)
}
pub
fn
include_info_sections
(
&
self
)
-
>
bool
{
self
.
inner
.
include_info_sections
(
)
}
pub
fn
naively_enabled
(
&
self
)
-
>
bool
{
self
.
inner
.
naively_enabled
(
)
}
pub
fn
follows_collection_enabled
(
&
self
)
-
>
bool
{
self
.
inner
.
follows_collection_enabled
(
)
}
pub
fn
schedules_pings
(
&
self
)
-
>
&
[
String
]
{
self
.
inner
.
schedules_pings
(
)
}
pub
fn
reason_codes
(
&
self
)
-
>
&
[
String
]
{
self
.
inner
.
reason_codes
(
)
}
pub
fn
test_before_next_submit
(
&
self
cb
:
impl
FnOnce
(
Option
<
&
str
>
)
+
Send
+
'
static
)
{
let
mut
test_callback
=
self
.
test_callback
.
lock
(
)
.
unwrap
(
)
;
let
cb
=
Box
:
:
new
(
cb
)
;
*
test_callback
=
Some
(
cb
)
;
}
}
