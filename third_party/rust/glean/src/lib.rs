#
!
[
deny
(
missing_docs
)
]
use
once_cell
:
:
sync
:
:
OnceCell
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
Mutex
;
pub
use
configuration
:
:
Configuration
;
pub
use
core_metrics
:
:
ClientInfoMetrics
;
pub
use
glean_core
:
:
{
global_glean
setup_glean
CommonMetricData
Error
Glean
Lifetime
Result
}
;
mod
configuration
;
mod
core_metrics
;
pub
mod
dispatcher
;
mod
glean_metrics
;
pub
mod
private
;
mod
system
;
const
LANGUAGE_BINDING_NAME
:
&
str
=
"
Rust
"
;
#
[
derive
(
Debug
)
]
struct
RustBindingsState
{
channel
:
Option
<
String
>
client_info
:
ClientInfoMetrics
}
static
INITIALIZE_CALLED
:
AtomicBool
=
AtomicBool
:
:
new
(
false
)
;
static
STATE
:
OnceCell
<
Mutex
<
RustBindingsState
>
>
=
OnceCell
:
:
new
(
)
;
fn
global_state
(
)
-
>
&
'
static
Mutex
<
RustBindingsState
>
{
STATE
.
get
(
)
.
unwrap
(
)
}
fn
setup_state
(
state
:
RustBindingsState
)
{
if
STATE
.
get
(
)
.
is_none
(
)
{
STATE
.
set
(
Mutex
:
:
new
(
state
)
)
.
unwrap
(
)
;
}
else
{
let
mut
lock
=
STATE
.
get
(
)
.
unwrap
(
)
.
lock
(
)
.
unwrap
(
)
;
*
lock
=
state
;
}
}
fn
with_glean
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
Fn
(
&
Glean
)
-
>
R
{
let
glean
=
global_glean
(
)
.
expect
(
"
Global
Glean
object
not
initialized
"
)
;
let
lock
=
glean
.
lock
(
)
.
unwrap
(
)
;
f
(
&
lock
)
}
fn
with_glean_mut
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
Fn
(
&
mut
Glean
)
-
>
R
{
let
glean
=
global_glean
(
)
.
expect
(
"
Global
Glean
object
not
initialized
"
)
;
let
mut
lock
=
glean
.
lock
(
)
.
unwrap
(
)
;
f
(
&
mut
lock
)
}
pub
fn
initialize
(
cfg
:
Configuration
client_info
:
ClientInfoMetrics
)
{
if
was_initialize_called
(
)
{
log
:
:
error
!
(
"
Glean
should
not
be
initialized
multiple
times
"
)
;
return
;
}
std
:
:
thread
:
:
spawn
(
move
|
|
{
let
core_cfg
=
glean_core
:
:
Configuration
{
upload_enabled
:
cfg
.
upload_enabled
data_path
:
cfg
.
data_path
.
clone
(
)
application_id
:
cfg
.
application_id
.
clone
(
)
language_binding_name
:
LANGUAGE_BINDING_NAME
.
into
(
)
max_events
:
cfg
.
max_events
delay_ping_lifetime_io
:
cfg
.
delay_ping_lifetime_io
}
;
let
glean
=
match
Glean
:
:
new
(
core_cfg
)
{
Ok
(
glean
)
=
>
glean
Err
(
_
)
=
>
return
}
;
if
glean_core
:
:
setup_glean
(
glean
)
.
is_err
(
)
{
return
;
}
log
:
:
info
!
(
"
Glean
initialized
"
)
;
setup_state
(
RustBindingsState
{
channel
:
cfg
.
channel
client_info
}
)
;
let
upload_enabled
=
cfg
.
upload_enabled
;
with_glean_mut
(
|
glean
|
{
let
state
=
global_state
(
)
.
lock
(
)
.
unwrap
(
)
;
let
dirty_flag
=
glean
.
is_dirty_flag_set
(
)
;
glean
.
set_dirty_flag
(
false
)
;
glean
.
register_ping_type
(
&
glean_metrics
:
:
pings
:
:
baseline
.
ping_type
)
;
glean
.
register_ping_type
(
&
glean_metrics
:
:
pings
:
:
metrics
.
ping_type
)
;
glean
.
register_ping_type
(
&
glean_metrics
:
:
pings
:
:
events
.
ping_type
)
;
let
is_first_run
=
glean
.
is_first_run
(
)
;
if
is_first_run
{
initialize_core_metrics
(
&
glean
&
state
.
client_info
state
.
channel
.
clone
(
)
)
;
}
let
pings_submitted
=
glean
.
on_ready_to_submit_pings
(
)
;
if
pings_submitted
|
|
!
upload_enabled
{
}
if
!
is_first_run
&
&
dirty_flag
{
}
if
!
is_first_run
{
glean
.
clear_application_lifetime_metrics
(
)
;
initialize_core_metrics
(
&
glean
&
state
.
client_info
state
.
channel
.
clone
(
)
)
;
}
}
)
;
if
let
Err
(
err
)
=
dispatcher
:
:
flush_init
(
)
{
log
:
:
error
!
(
"
Unable
to
flush
the
preinit
queue
:
{
}
"
err
)
;
}
}
)
;
INITIALIZE_CALLED
.
store
(
true
Ordering
:
:
SeqCst
)
;
}
fn
was_initialize_called
(
)
-
>
bool
{
INITIALIZE_CALLED
.
load
(
Ordering
:
:
SeqCst
)
}
fn
initialize_core_metrics
(
glean
:
&
Glean
client_info
:
&
ClientInfoMetrics
channel
:
Option
<
String
>
)
{
let
core_metrics
=
core_metrics
:
:
InternalMetrics
:
:
new
(
)
;
core_metrics
.
app_build
.
set
(
glean
&
client_info
.
app_build
[
.
.
]
)
;
core_metrics
.
app_display_version
.
set
(
glean
&
client_info
.
app_display_version
[
.
.
]
)
;
if
let
Some
(
app_channel
)
=
channel
{
core_metrics
.
app_channel
.
set
(
glean
app_channel
)
;
}
core_metrics
.
os_version
.
set
(
glean
"
unknown
"
.
to_string
(
)
)
;
core_metrics
.
architecture
.
set
(
glean
system
:
:
ARCH
.
to_string
(
)
)
;
core_metrics
.
device_manufacturer
.
set
(
glean
"
unknown
"
.
to_string
(
)
)
;
core_metrics
.
device_model
.
set
(
glean
"
unknown
"
.
to_string
(
)
)
;
}
pub
fn
set_upload_enabled
(
enabled
:
bool
)
{
if
!
was_initialize_called
(
)
{
let
msg
=
"
Changing
upload
enabled
before
Glean
is
initialized
is
not
supported
.
\
n
\
Pass
the
correct
state
into
Glean
.
initialize
(
)
.
\
n
\
See
documentation
at
https
:
/
/
mozilla
.
github
.
io
/
glean
/
book
/
user
/
general
-
api
.
html
#
initializing
-
the
-
glean
-
sdk
"
;
log
:
:
error
!
(
"
{
}
"
msg
)
;
return
;
}
dispatcher
:
:
launch
(
move
|
|
{
with_glean_mut
(
|
glean
|
{
let
state
=
global_state
(
)
.
lock
(
)
.
unwrap
(
)
;
let
old_enabled
=
glean
.
is_upload_enabled
(
)
;
glean
.
set_upload_enabled
(
enabled
)
;
if
!
old_enabled
&
&
enabled
{
initialize_core_metrics
(
&
glean
&
state
.
client_info
state
.
channel
.
clone
(
)
)
;
}
}
)
;
}
)
;
}
pub
fn
register_ping_type
(
ping
:
&
private
:
:
PingType
)
{
let
ping
=
ping
.
clone
(
)
;
dispatcher
:
:
launch
(
move
|
|
{
with_glean_mut
(
|
glean
|
{
glean
.
register_ping_type
(
&
ping
.
ping_type
)
;
}
)
}
)
}
pub
fn
submit_ping
(
ping
:
&
private
:
:
PingType
reason
:
Option
<
&
str
>
)
{
submit_ping_by_name
(
&
ping
.
name
reason
)
}
pub
fn
submit_ping_by_name
(
ping
:
&
str
reason
:
Option
<
&
str
>
)
{
let
ping
=
ping
.
to_string
(
)
;
let
reason
=
reason
.
map
(
|
s
|
s
.
to_string
(
)
)
;
dispatcher
:
:
launch
(
move
|
|
{
with_glean
(
|
glean
|
glean
.
submit_ping_by_name
(
&
ping
reason
.
as_deref
(
)
)
.
ok
(
)
)
;
}
)
}
#
[
cfg
(
test
)
]
mod
test
;
