use
timer
:
:
Inner
;
use
{
Deadline
Delay
Error
Interval
Timeout
}
;
use
tokio_executor
:
:
Enter
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
{
Arc
Weak
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Handle
{
inner
:
Option
<
HandlePriv
>
}
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
HandlePriv
{
inner
:
Weak
<
Inner
>
}
#
[
derive
(
Debug
)
]
pub
struct
DefaultGuard
{
_p
:
(
)
}
thread_local
!
{
/
/
/
Tracks
the
timer
for
the
current
execution
context
.
static
CURRENT_TIMER
:
RefCell
<
Option
<
HandlePriv
>
>
=
RefCell
:
:
new
(
None
)
}
pub
fn
with_default
<
F
R
>
(
handle
:
&
Handle
enter
:
&
mut
Enter
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Enter
)
-
>
R
{
let
_guard
=
set_default
(
handle
)
;
f
(
enter
)
}
pub
fn
set_default
(
handle
:
&
Handle
)
-
>
DefaultGuard
{
CURRENT_TIMER
.
with
(
|
current
|
{
let
mut
current
=
current
.
borrow_mut
(
)
;
assert
!
(
current
.
is_none
(
)
"
default
Tokio
timer
already
set
\
for
execution
context
"
)
;
let
handle
=
handle
.
as_priv
(
)
.
unwrap_or_else
(
|
|
panic
!
(
"
handle
does
not
reference
a
timer
"
)
)
;
*
current
=
Some
(
handle
.
clone
(
)
)
;
}
)
;
DefaultGuard
{
_p
:
(
)
}
}
impl
Handle
{
pub
(
crate
)
fn
new
(
inner
:
Weak
<
Inner
>
)
-
>
Handle
{
let
inner
=
HandlePriv
{
inner
}
;
Handle
{
inner
:
Some
(
inner
)
}
}
pub
fn
current
(
)
-
>
Handle
{
let
private
=
HandlePriv
:
:
try_current
(
)
.
unwrap_or_else
(
|
_
|
HandlePriv
{
inner
:
Weak
:
:
new
(
)
}
)
;
Handle
{
inner
:
Some
(
private
)
}
}
pub
fn
delay
(
&
self
deadline
:
Instant
)
-
>
Delay
{
match
self
.
inner
{
Some
(
ref
handle_priv
)
=
>
Delay
:
:
new_with_handle
(
deadline
handle_priv
.
clone
(
)
)
None
=
>
Delay
:
:
new
(
deadline
)
}
}
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
2
.
11
"
note
=
"
use
timeout
instead
"
)
]
pub
fn
deadline
<
T
>
(
&
self
future
:
T
deadline
:
Instant
)
-
>
Deadline
<
T
>
{
Deadline
:
:
new_with_delay
(
future
self
.
delay
(
deadline
)
)
}
pub
fn
timeout
<
T
>
(
&
self
value
:
T
deadline
:
Instant
)
-
>
Timeout
<
T
>
{
Timeout
:
:
new_with_delay
(
value
self
.
delay
(
deadline
)
)
}
pub
fn
interval
(
&
self
at
:
Instant
duration
:
Duration
)
-
>
Interval
{
Interval
:
:
new_with_delay
(
self
.
delay
(
at
)
duration
)
}
fn
as_priv
(
&
self
)
-
>
Option
<
&
HandlePriv
>
{
self
.
inner
.
as_ref
(
)
}
}
impl
Default
for
Handle
{
fn
default
(
)
-
>
Handle
{
Handle
{
inner
:
None
}
}
}
impl
HandlePriv
{
pub
(
crate
)
fn
try_current
(
)
-
>
Result
<
HandlePriv
Error
>
{
CURRENT_TIMER
.
with
(
|
current
|
match
*
current
.
borrow
(
)
{
Some
(
ref
handle
)
=
>
Ok
(
handle
.
clone
(
)
)
None
=
>
Err
(
Error
:
:
shutdown
(
)
)
}
)
}
pub
(
crate
)
fn
inner
(
&
self
)
-
>
Option
<
Arc
<
Inner
>
>
{
self
.
inner
.
upgrade
(
)
}
pub
(
crate
)
fn
into_inner
(
self
)
-
>
Weak
<
Inner
>
{
self
.
inner
}
}
impl
fmt
:
:
Debug
for
HandlePriv
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
HandlePriv
"
)
}
}
impl
Drop
for
DefaultGuard
{
fn
drop
(
&
mut
self
)
{
let
_
=
CURRENT_TIMER
.
try_with
(
|
current
|
{
let
mut
current
=
current
.
borrow_mut
(
)
;
*
current
=
None
;
}
)
;
}
}
