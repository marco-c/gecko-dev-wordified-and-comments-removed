use
{
Error
Delay
Deadline
Interval
}
;
use
timer
:
:
{
Registration
Inner
}
;
use
tokio_executor
:
:
Enter
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
sync
:
:
{
Arc
Weak
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Handle
{
inner
:
Weak
<
Inner
>
}
thread_local
!
(
static
CURRENT_TIMER
:
RefCell
<
Option
<
Handle
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
with_default
<
F
R
>
(
handle
:
&
Handle
enter
:
&
mut
Enter
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Enter
)
-
>
R
{
struct
Reset
;
impl
Drop
for
Reset
{
fn
drop
(
&
mut
self
)
{
CURRENT_TIMER
.
with
(
|
current
|
{
let
mut
current
=
current
.
borrow_mut
(
)
;
*
current
=
None
;
}
)
;
}
}
let
_r
=
Reset
;
CURRENT_TIMER
.
with
(
|
current
|
{
{
let
mut
current
=
current
.
borrow_mut
(
)
;
assert
!
(
current
.
is_none
(
)
"
default
Tokio
timer
already
set
\
for
execution
context
"
)
;
*
current
=
Some
(
handle
.
clone
(
)
)
;
}
f
(
enter
)
}
)
}
impl
Handle
{
pub
(
crate
)
fn
new
(
inner
:
Weak
<
Inner
>
)
-
>
Handle
{
Handle
{
inner
}
}
pub
fn
current
(
)
-
>
Handle
{
Handle
:
:
try_current
(
)
.
unwrap_or
(
Handle
{
inner
:
Weak
:
:
new
(
)
}
)
}
pub
fn
delay
(
&
self
deadline
:
Instant
)
-
>
Delay
{
let
registration
=
Registration
:
:
new_with_handle
(
deadline
self
.
clone
(
)
)
;
Delay
:
:
new_with_registration
(
deadline
registration
)
}
pub
fn
deadline
<
T
>
(
&
self
future
:
T
deadline
:
Instant
)
-
>
Deadline
<
T
>
{
Deadline
:
:
new_with_delay
(
future
self
.
delay
(
deadline
)
)
}
pub
fn
interval
(
&
self
at
:
Instant
duration
:
Duration
)
-
>
Interval
{
Interval
:
:
new_with_delay
(
self
.
delay
(
at
)
duration
)
}
pub
(
crate
)
fn
try_current
(
)
-
>
Result
<
Handle
Error
>
{
CURRENT_TIMER
.
with
(
|
current
|
{
match
*
current
.
borrow
(
)
{
Some
(
ref
handle
)
=
>
Ok
(
handle
.
clone
(
)
)
None
=
>
Err
(
Error
:
:
shutdown
(
)
)
}
}
)
}
pub
(
crate
)
fn
inner
(
&
self
)
-
>
Option
<
Arc
<
Inner
>
>
{
self
.
inner
.
upgrade
(
)
}
pub
(
crate
)
fn
into_inner
(
self
)
-
>
Weak
<
Inner
>
{
self
.
inner
}
}
