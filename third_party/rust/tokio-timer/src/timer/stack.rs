use
super
:
:
Entry
;
use
wheel
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Stack
{
head
:
Option
<
Arc
<
Entry
>
>
}
impl
Default
for
Stack
{
fn
default
(
)
-
>
Stack
{
Stack
{
head
:
None
}
}
}
impl
wheel
:
:
Stack
for
Stack
{
type
Owned
=
Arc
<
Entry
>
;
type
Borrowed
=
Entry
;
type
Store
=
(
)
;
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
head
.
is_none
(
)
}
fn
push
(
&
mut
self
entry
:
Self
:
:
Owned
_
:
&
mut
Self
:
:
Store
)
{
let
ptr
:
*
const
Entry
=
&
*
entry
as
*
const
_
;
let
old
=
self
.
head
.
take
(
)
;
unsafe
{
debug_assert
!
(
(
*
entry
.
next_stack
.
get
(
)
)
.
is_none
(
)
)
;
debug_assert
!
(
(
*
entry
.
prev_stack
.
get
(
)
)
.
is_null
(
)
)
;
if
let
Some
(
ref
entry
)
=
old
.
as_ref
(
)
{
debug_assert
!
(
{
/
/
The
head
is
not
already
set
to
the
entry
ptr
!
=
&
*
*
*
entry
as
*
const
_
}
)
;
*
entry
.
prev_stack
.
get
(
)
=
ptr
;
}
*
entry
.
next_stack
.
get
(
)
=
old
;
}
self
.
head
=
Some
(
entry
)
;
}
fn
pop
(
&
mut
self
_
:
&
mut
(
)
)
-
>
Option
<
Arc
<
Entry
>
>
{
let
entry
=
self
.
head
.
take
(
)
;
unsafe
{
if
let
Some
(
entry
)
=
entry
.
as_ref
(
)
{
self
.
head
=
(
*
entry
.
next_stack
.
get
(
)
)
.
take
(
)
;
if
let
Some
(
entry
)
=
self
.
head
.
as_ref
(
)
{
*
entry
.
prev_stack
.
get
(
)
=
ptr
:
:
null
(
)
;
}
*
entry
.
prev_stack
.
get
(
)
=
ptr
:
:
null
(
)
;
}
}
entry
}
fn
remove
(
&
mut
self
entry
:
&
Entry
_
:
&
mut
(
)
)
{
unsafe
{
debug_assert
!
(
{
/
/
This
walks
the
full
linked
list
even
if
an
entry
is
found
.
let
mut
next
=
self
.
head
.
as_ref
(
)
;
let
mut
contains
=
false
;
while
let
Some
(
n
)
=
next
{
if
entry
as
*
const
_
=
=
&
*
*
n
as
*
const
_
{
debug_assert
!
(
!
contains
)
;
contains
=
true
;
}
next
=
(
*
n
.
next_stack
.
get
(
)
)
.
as_ref
(
)
;
}
contains
}
)
;
let
next
=
(
*
entry
.
next_stack
.
get
(
)
)
.
take
(
)
;
if
let
Some
(
next
)
=
next
.
as_ref
(
)
{
(
*
next
.
prev_stack
.
get
(
)
)
=
*
entry
.
prev_stack
.
get
(
)
;
}
if
let
Some
(
prev
)
=
(
*
entry
.
prev_stack
.
get
(
)
)
.
as_ref
(
)
{
*
prev
.
next_stack
.
get
(
)
=
next
;
}
else
{
self
.
head
=
next
;
}
*
entry
.
prev_stack
.
get
(
)
=
ptr
:
:
null
(
)
;
}
}
fn
when
(
item
:
&
Entry
_
:
&
(
)
)
-
>
u64
{
item
.
when_internal
(
)
.
expect
(
"
invalid
internal
state
"
)
}
}
