use
timer
:
:
{
HandlePriv
Registration
}
;
use
Error
;
use
futures
:
:
{
Future
Poll
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
derive
(
Debug
)
]
pub
struct
Delay
{
registration
:
Registration
}
impl
Delay
{
pub
fn
new
(
deadline
:
Instant
)
-
>
Delay
{
let
registration
=
Registration
:
:
new
(
deadline
Duration
:
:
from_millis
(
0
)
)
;
Delay
{
registration
}
}
pub
(
crate
)
fn
new_timeout
(
deadline
:
Instant
duration
:
Duration
)
-
>
Delay
{
let
registration
=
Registration
:
:
new
(
deadline
duration
)
;
Delay
{
registration
}
}
pub
(
crate
)
fn
new_with_handle
(
deadline
:
Instant
handle
:
HandlePriv
)
-
>
Delay
{
let
mut
registration
=
Registration
:
:
new
(
deadline
Duration
:
:
from_millis
(
0
)
)
;
registration
.
register_with
(
handle
)
;
Delay
{
registration
}
}
pub
fn
deadline
(
&
self
)
-
>
Instant
{
self
.
registration
.
deadline
(
)
}
pub
fn
is_elapsed
(
&
self
)
-
>
bool
{
self
.
registration
.
is_elapsed
(
)
}
pub
fn
reset
(
&
mut
self
deadline
:
Instant
)
{
self
.
registration
.
reset
(
deadline
)
;
}
pub
(
crate
)
fn
reset_timeout
(
&
mut
self
)
{
self
.
registration
.
reset_timeout
(
)
;
}
fn
register
(
&
mut
self
)
{
self
.
registration
.
register
(
)
;
}
}
impl
Future
for
Delay
{
type
Item
=
(
)
;
type
Error
=
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
self
.
register
(
)
;
self
.
registration
.
poll_elapsed
(
)
}
}
