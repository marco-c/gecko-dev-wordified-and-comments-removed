use
Error
;
use
timer
:
:
Registration
;
use
futures
:
:
{
Future
Poll
}
;
use
std
:
:
time
:
:
Instant
;
#
[
derive
(
Debug
)
]
pub
struct
Delay
{
deadline
:
Instant
registration
:
Option
<
Registration
>
}
impl
Delay
{
pub
fn
new
(
deadline
:
Instant
)
-
>
Delay
{
Delay
{
deadline
registration
:
None
}
}
pub
(
crate
)
fn
new_with_registration
(
deadline
:
Instant
registration
:
Registration
)
-
>
Delay
{
Delay
{
deadline
registration
:
Some
(
registration
)
}
}
pub
fn
deadline
(
&
self
)
-
>
Instant
{
self
.
deadline
}
pub
fn
is_elapsed
(
&
self
)
-
>
bool
{
self
.
registration
.
as_ref
(
)
.
map
(
|
r
|
r
.
is_elapsed
(
)
)
.
unwrap_or
(
false
)
}
pub
fn
reset
(
&
mut
self
deadline
:
Instant
)
{
self
.
deadline
=
deadline
;
if
let
Some
(
registration
)
=
self
.
registration
.
as_ref
(
)
{
registration
.
reset
(
deadline
)
;
}
}
fn
register
(
&
mut
self
)
{
if
self
.
registration
.
is_some
(
)
{
return
;
}
self
.
registration
=
Some
(
Registration
:
:
new
(
self
.
deadline
)
)
;
}
}
impl
Future
for
Delay
{
type
Item
=
(
)
;
type
Error
=
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
self
.
register
(
)
;
self
.
registration
.
as_ref
(
)
.
unwrap
(
)
.
poll_elapsed
(
)
}
}
