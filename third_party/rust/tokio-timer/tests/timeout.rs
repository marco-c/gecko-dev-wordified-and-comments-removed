extern
crate
futures
;
extern
crate
tokio_executor
;
extern
crate
tokio_timer
;
#
[
macro_use
]
mod
support
;
use
support
:
:
*
;
use
tokio_timer
:
:
*
;
use
futures
:
:
sync
:
:
{
mpsc
oneshot
}
;
use
futures
:
:
{
future
Future
Stream
}
;
#
[
test
]
fn
simultaneous_deadline_future_completion
(
)
{
mocked
(
|
_
time
|
{
let
fut
=
future
:
:
ok
:
:
<
_
(
)
>
(
(
)
)
;
let
mut
fut
=
Timeout
:
:
new_at
(
fut
time
.
now
(
)
)
;
assert_ready
!
(
fut
)
;
}
)
;
}
#
[
test
]
fn
completed_future_past_deadline
(
)
{
mocked
(
|
_
time
|
{
let
fut
=
future
:
:
ok
:
:
<
_
(
)
>
(
(
)
)
;
let
mut
fut
=
Timeout
:
:
new_at
(
fut
time
.
now
(
)
-
ms
(
1000
)
)
;
assert_ready
!
(
fut
)
;
}
)
;
}
#
[
test
]
fn
future_and_deadline_in_future
(
)
{
mocked
(
|
timer
time
|
{
let
(
tx
rx
)
=
oneshot
:
:
channel
(
)
;
let
mut
fut
=
Timeout
:
:
new_at
(
rx
time
.
now
(
)
+
ms
(
100
)
)
;
assert_not_ready
!
(
fut
)
;
advance
(
timer
ms
(
90
)
)
;
assert_not_ready
!
(
fut
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
assert_ready
!
(
fut
)
;
}
)
;
}
#
[
test
]
fn
future_and_timeout_in_future
(
)
{
mocked
(
|
timer
_time
|
{
let
(
tx
rx
)
=
oneshot
:
:
channel
(
)
;
let
mut
fut
=
Timeout
:
:
new
(
rx
ms
(
100
)
)
;
assert_not_ready
!
(
fut
)
;
advance
(
timer
ms
(
90
)
)
;
assert_not_ready
!
(
fut
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
assert_ready
!
(
fut
)
;
}
)
;
}
#
[
test
]
fn
deadline_now_elapses
(
)
{
mocked
(
|
_
time
|
{
let
fut
=
future
:
:
empty
:
:
<
(
)
(
)
>
(
)
;
let
mut
fut
=
Timeout
:
:
new_at
(
fut
time
.
now
(
)
)
;
assert_elapsed
!
(
fut
)
;
}
)
;
}
#
[
test
]
fn
deadline_future_elapses
(
)
{
mocked
(
|
timer
time
|
{
let
fut
=
future
:
:
empty
:
:
<
(
)
(
)
>
(
)
;
let
mut
fut
=
Timeout
:
:
new_at
(
fut
time
.
now
(
)
+
ms
(
300
)
)
;
assert_not_ready
!
(
fut
)
;
advance
(
timer
ms
(
300
)
)
;
assert_elapsed
!
(
fut
)
;
}
)
;
}
#
[
test
]
fn
future_errors_first
(
)
{
mocked
(
|
_
time
|
{
let
fut
=
future
:
:
err
:
:
<
(
)
(
)
>
(
(
)
)
;
let
mut
fut
=
Timeout
:
:
new_at
(
fut
time
.
now
(
)
+
ms
(
100
)
)
;
assert
!
(
fut
.
poll
(
)
.
unwrap_err
(
)
.
is_inner
(
)
)
;
}
)
;
}
#
[
test
]
fn
stream_and_timeout_in_future
(
)
{
mocked
(
|
timer
_time
|
{
let
(
tx
rx
)
=
mpsc
:
:
unbounded
(
)
;
let
mut
stream
=
Timeout
:
:
new
(
rx
ms
(
100
)
)
;
assert_not_ready
!
(
stream
)
;
advance
(
timer
ms
(
90
)
)
;
assert_not_ready
!
(
stream
)
;
tx
.
unbounded_send
(
(
)
)
.
unwrap
(
)
;
let
item
=
assert_ready
!
(
stream
)
;
assert
!
(
item
.
is_some
(
)
)
;
}
)
;
}
#
[
test
]
fn
idle_stream_timesout_periodically
(
)
{
mocked
(
|
timer
_time
|
{
let
(
_tx
rx
)
=
mpsc
:
:
unbounded
:
:
<
(
)
>
(
)
;
let
mut
stream
=
Timeout
:
:
new
(
rx
ms
(
100
)
)
;
assert_not_ready
!
(
stream
)
;
advance
(
timer
ms
(
100
)
)
;
assert_elapsed
!
(
stream
)
;
assert_not_ready
!
(
stream
)
;
advance
(
timer
ms
(
100
)
)
;
assert_elapsed
!
(
stream
)
;
}
)
;
}
