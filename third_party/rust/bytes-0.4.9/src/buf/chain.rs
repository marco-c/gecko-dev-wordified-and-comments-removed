use
{
Buf
BufMut
}
;
use
iovec
:
:
IoVec
;
#
[
derive
(
Debug
)
]
pub
struct
Chain
<
T
U
>
{
a
:
T
b
:
U
}
impl
<
T
U
>
Chain
<
T
U
>
{
pub
fn
new
(
a
:
T
b
:
U
)
-
>
Chain
<
T
U
>
{
Chain
{
a
:
a
b
:
b
}
}
pub
fn
first_ref
(
&
self
)
-
>
&
T
{
&
self
.
a
}
pub
fn
first_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
a
}
pub
fn
last_ref
(
&
self
)
-
>
&
U
{
&
self
.
b
}
pub
fn
last_mut
(
&
mut
self
)
-
>
&
mut
U
{
&
mut
self
.
b
}
pub
fn
into_inner
(
self
)
-
>
(
T
U
)
{
(
self
.
a
self
.
b
)
}
}
impl
<
T
U
>
Buf
for
Chain
<
T
U
>
where
T
:
Buf
U
:
Buf
{
fn
remaining
(
&
self
)
-
>
usize
{
self
.
a
.
remaining
(
)
+
self
.
b
.
remaining
(
)
}
fn
bytes
(
&
self
)
-
>
&
[
u8
]
{
if
self
.
a
.
has_remaining
(
)
{
self
.
a
.
bytes
(
)
}
else
{
self
.
b
.
bytes
(
)
}
}
fn
advance
(
&
mut
self
mut
cnt
:
usize
)
{
let
a_rem
=
self
.
a
.
remaining
(
)
;
if
a_rem
!
=
0
{
if
a_rem
>
=
cnt
{
self
.
a
.
advance
(
cnt
)
;
return
;
}
self
.
a
.
advance
(
a_rem
)
;
cnt
-
=
a_rem
;
}
self
.
b
.
advance
(
cnt
)
;
}
fn
bytes_vec
<
'
a
>
(
&
'
a
self
dst
:
&
mut
[
&
'
a
IoVec
]
)
-
>
usize
{
let
mut
n
=
self
.
a
.
bytes_vec
(
dst
)
;
n
+
=
self
.
b
.
bytes_vec
(
&
mut
dst
[
n
.
.
]
)
;
n
}
}
impl
<
T
U
>
BufMut
for
Chain
<
T
U
>
where
T
:
BufMut
U
:
BufMut
{
fn
remaining_mut
(
&
self
)
-
>
usize
{
self
.
a
.
remaining_mut
(
)
+
self
.
b
.
remaining_mut
(
)
}
unsafe
fn
bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
if
self
.
a
.
has_remaining_mut
(
)
{
self
.
a
.
bytes_mut
(
)
}
else
{
self
.
b
.
bytes_mut
(
)
}
}
unsafe
fn
advance_mut
(
&
mut
self
mut
cnt
:
usize
)
{
let
a_rem
=
self
.
a
.
remaining_mut
(
)
;
if
a_rem
!
=
0
{
if
a_rem
>
=
cnt
{
self
.
a
.
advance_mut
(
cnt
)
;
return
;
}
self
.
a
.
advance_mut
(
a_rem
)
;
cnt
-
=
a_rem
;
}
self
.
b
.
advance_mut
(
cnt
)
;
}
unsafe
fn
bytes_vec_mut
<
'
a
>
(
&
'
a
mut
self
dst
:
&
mut
[
&
'
a
mut
IoVec
]
)
-
>
usize
{
let
mut
n
=
self
.
a
.
bytes_vec_mut
(
dst
)
;
n
+
=
self
.
b
.
bytes_vec_mut
(
&
mut
dst
[
n
.
.
]
)
;
n
}
}
