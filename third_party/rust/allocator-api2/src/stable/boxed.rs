use
core
:
:
any
:
:
Any
;
use
core
:
:
borrow
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
convert
:
:
{
From
TryFrom
}
;
use
core
:
:
fmt
;
use
core
:
:
future
:
:
Future
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
use
core
:
:
iter
:
:
FromIterator
;
use
core
:
:
iter
:
:
{
FusedIterator
Iterator
}
;
use
core
:
:
marker
:
:
Unpin
;
use
core
:
:
mem
;
use
core
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
core
:
:
pin
:
:
Pin
;
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
use
core
:
:
task
:
:
{
Context
Poll
}
;
use
super
:
:
alloc
:
:
{
AllocError
Allocator
Global
Layout
}
;
use
super
:
:
raw_vec
:
:
RawVec
;
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
use
super
:
:
vec
:
:
Vec
;
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
use
alloc_crate
:
:
alloc
:
:
handle_alloc_error
;
pub
struct
Box
<
T
:
?
Sized
A
:
Allocator
=
Global
>
(
NonNull
<
T
>
A
)
;
unsafe
impl
<
T
:
?
Sized
A
:
Allocator
>
Send
for
Box
<
T
A
>
where
T
:
Send
A
:
Send
{
}
unsafe
impl
<
T
:
?
Sized
A
:
Allocator
>
Sync
for
Box
<
T
A
>
where
T
:
Sync
A
:
Sync
{
}
impl
<
T
>
Box
<
T
>
{
#
[
cfg
(
all
(
not
(
no_global_oom_handling
)
)
)
]
#
[
inline
(
always
)
]
#
[
must_use
]
pub
fn
new
(
x
:
T
)
-
>
Self
{
Self
:
:
new_in
(
x
Global
)
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_uninit
(
)
-
>
Box
<
mem
:
:
MaybeUninit
<
T
>
>
{
Self
:
:
new_uninit_in
(
Global
)
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_zeroed
(
)
-
>
Box
<
mem
:
:
MaybeUninit
<
T
>
>
{
Self
:
:
new_zeroed_in
(
Global
)
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
pin
(
x
:
T
)
-
>
Pin
<
Box
<
T
>
>
{
Box
:
:
new
(
x
)
.
into
(
)
}
#
[
inline
(
always
)
]
pub
fn
try_new
(
x
:
T
)
-
>
Result
<
Self
AllocError
>
{
Self
:
:
try_new_in
(
x
Global
)
}
#
[
inline
(
always
)
]
pub
fn
try_new_uninit
(
)
-
>
Result
<
Box
<
mem
:
:
MaybeUninit
<
T
>
>
AllocError
>
{
Box
:
:
try_new_uninit_in
(
Global
)
}
#
[
inline
(
always
)
]
pub
fn
try_new_zeroed
(
)
-
>
Result
<
Box
<
mem
:
:
MaybeUninit
<
T
>
>
AllocError
>
{
Box
:
:
try_new_zeroed_in
(
Global
)
}
}
impl
<
T
A
:
Allocator
>
Box
<
T
A
>
{
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_in
(
x
:
T
alloc
:
A
)
-
>
Self
where
A
:
Allocator
{
let
mut
boxed
=
Self
:
:
new_uninit_in
(
alloc
)
;
unsafe
{
boxed
.
as_mut_ptr
(
)
.
write
(
x
)
;
boxed
.
assume_init
(
)
}
}
#
[
inline
(
always
)
]
pub
fn
try_new_in
(
x
:
T
alloc
:
A
)
-
>
Result
<
Self
AllocError
>
where
A
:
Allocator
{
let
mut
boxed
=
Self
:
:
try_new_uninit_in
(
alloc
)
?
;
unsafe
{
boxed
.
as_mut_ptr
(
)
.
write
(
x
)
;
Ok
(
boxed
.
assume_init
(
)
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_uninit_in
(
alloc
:
A
)
-
>
Box
<
mem
:
:
MaybeUninit
<
T
>
A
>
where
A
:
Allocator
{
let
layout
=
Layout
:
:
new
:
:
<
mem
:
:
MaybeUninit
<
T
>
>
(
)
;
match
Box
:
:
try_new_uninit_in
(
alloc
)
{
Ok
(
m
)
=
>
m
Err
(
_
)
=
>
handle_alloc_error
(
layout
)
}
}
#
[
inline
(
always
)
]
pub
fn
try_new_uninit_in
(
alloc
:
A
)
-
>
Result
<
Box
<
mem
:
:
MaybeUninit
<
T
>
A
>
AllocError
>
where
A
:
Allocator
{
let
layout
=
Layout
:
:
new
:
:
<
mem
:
:
MaybeUninit
<
T
>
>
(
)
;
let
ptr
=
alloc
.
allocate
(
layout
)
?
.
cast
(
)
;
unsafe
{
Ok
(
Box
:
:
from_raw_in
(
ptr
.
as_ptr
(
)
alloc
)
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_zeroed_in
(
alloc
:
A
)
-
>
Box
<
mem
:
:
MaybeUninit
<
T
>
A
>
where
A
:
Allocator
{
let
layout
=
Layout
:
:
new
:
:
<
mem
:
:
MaybeUninit
<
T
>
>
(
)
;
match
Box
:
:
try_new_zeroed_in
(
alloc
)
{
Ok
(
m
)
=
>
m
Err
(
_
)
=
>
handle_alloc_error
(
layout
)
}
}
#
[
inline
(
always
)
]
pub
fn
try_new_zeroed_in
(
alloc
:
A
)
-
>
Result
<
Box
<
mem
:
:
MaybeUninit
<
T
>
A
>
AllocError
>
where
A
:
Allocator
{
let
layout
=
Layout
:
:
new
:
:
<
mem
:
:
MaybeUninit
<
T
>
>
(
)
;
let
ptr
=
alloc
.
allocate_zeroed
(
layout
)
?
.
cast
(
)
;
unsafe
{
Ok
(
Box
:
:
from_raw_in
(
ptr
.
as_ptr
(
)
alloc
)
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
pin_in
(
x
:
T
alloc
:
A
)
-
>
Pin
<
Self
>
where
A
:
'
static
+
Allocator
{
Self
:
:
into_pin
(
Self
:
:
new_in
(
x
alloc
)
)
}
#
[
inline
(
always
)
]
pub
fn
into_boxed_slice
(
boxed
:
Self
)
-
>
Box
<
[
T
]
A
>
{
let
(
raw
alloc
)
=
Box
:
:
into_raw_with_allocator
(
boxed
)
;
unsafe
{
Box
:
:
from_raw_in
(
raw
as
*
mut
[
T
;
1
]
alloc
)
}
}
#
[
inline
(
always
)
]
pub
fn
into_inner
(
boxed
:
Self
)
-
>
T
{
let
ptr
=
boxed
.
0
;
let
unboxed
=
unsafe
{
ptr
.
as_ptr
(
)
.
read
(
)
}
;
unsafe
{
boxed
.
1
.
deallocate
(
ptr
.
cast
(
)
Layout
:
:
new
:
:
<
T
>
(
)
)
}
;
unboxed
}
}
impl
<
T
>
Box
<
[
T
]
>
{
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_uninit_slice
(
len
:
usize
)
-
>
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
>
{
unsafe
{
RawVec
:
:
with_capacity
(
len
)
.
into_box
(
len
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_zeroed_slice
(
len
:
usize
)
-
>
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
>
{
unsafe
{
RawVec
:
:
with_capacity_zeroed
(
len
)
.
into_box
(
len
)
}
}
#
[
inline
(
always
)
]
pub
fn
try_new_uninit_slice
(
len
:
usize
)
-
>
Result
<
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
>
AllocError
>
{
unsafe
{
let
layout
=
match
Layout
:
:
array
:
:
<
mem
:
:
MaybeUninit
<
T
>
>
(
len
)
{
Ok
(
l
)
=
>
l
Err
(
_
)
=
>
return
Err
(
AllocError
)
}
;
let
ptr
=
Global
.
allocate
(
layout
)
?
;
Ok
(
RawVec
:
:
from_raw_parts_in
(
ptr
.
as_ptr
(
)
as
*
mut
_
len
Global
)
.
into_box
(
len
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
try_new_zeroed_slice
(
len
:
usize
)
-
>
Result
<
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
>
AllocError
>
{
unsafe
{
let
layout
=
match
Layout
:
:
array
:
:
<
mem
:
:
MaybeUninit
<
T
>
>
(
len
)
{
Ok
(
l
)
=
>
l
Err
(
_
)
=
>
return
Err
(
AllocError
)
}
;
let
ptr
=
Global
.
allocate_zeroed
(
layout
)
?
;
Ok
(
RawVec
:
:
from_raw_parts_in
(
ptr
.
as_ptr
(
)
as
*
mut
_
len
Global
)
.
into_box
(
len
)
)
}
}
}
impl
<
T
A
:
Allocator
>
Box
<
[
T
]
A
>
{
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_uninit_slice_in
(
len
:
usize
alloc
:
A
)
-
>
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
A
>
{
unsafe
{
RawVec
:
:
with_capacity_in
(
len
alloc
)
.
into_box
(
len
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
new_zeroed_slice_in
(
len
:
usize
alloc
:
A
)
-
>
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
A
>
{
unsafe
{
RawVec
:
:
with_capacity_zeroed_in
(
len
alloc
)
.
into_box
(
len
)
}
}
pub
fn
into_vec
(
self
)
-
>
Vec
<
T
A
>
where
A
:
Allocator
{
unsafe
{
let
len
=
self
.
len
(
)
;
let
(
b
alloc
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
Vec
:
:
from_raw_parts_in
(
b
as
*
mut
T
len
len
alloc
)
}
}
}
impl
<
T
A
:
Allocator
>
Box
<
mem
:
:
MaybeUninit
<
T
>
A
>
{
#
[
inline
(
always
)
]
pub
unsafe
fn
assume_init
(
self
)
-
>
Box
<
T
A
>
{
let
(
raw
alloc
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
unsafe
{
Box
:
:
from_raw_in
(
raw
as
*
mut
T
alloc
)
}
}
#
[
inline
(
always
)
]
pub
fn
write
(
mut
boxed
:
Self
value
:
T
)
-
>
Box
<
T
A
>
{
unsafe
{
(
*
boxed
)
.
write
(
value
)
;
boxed
.
assume_init
(
)
}
}
}
impl
<
T
A
:
Allocator
>
Box
<
[
mem
:
:
MaybeUninit
<
T
>
]
A
>
{
#
[
inline
(
always
)
]
pub
unsafe
fn
assume_init
(
self
)
-
>
Box
<
[
T
]
A
>
{
let
(
raw
alloc
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
unsafe
{
Box
:
:
from_raw_in
(
raw
as
*
mut
[
T
]
alloc
)
}
}
}
impl
<
T
:
?
Sized
>
Box
<
T
>
{
#
[
must_use
=
"
call
drop
(
from_raw
(
ptr
)
)
if
you
intend
to
drop
the
Box
"
]
#
[
inline
(
always
)
]
pub
unsafe
fn
from_raw
(
raw
:
*
mut
T
)
-
>
Self
{
unsafe
{
Self
:
:
from_raw_in
(
raw
Global
)
}
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
Box
<
T
A
>
{
#
[
inline
(
always
)
]
pub
const
unsafe
fn
from_raw_in
(
raw
:
*
mut
T
alloc
:
A
)
-
>
Self
{
Box
(
unsafe
{
NonNull
:
:
new_unchecked
(
raw
)
}
alloc
)
}
#
[
inline
(
always
)
]
pub
fn
into_raw
(
b
:
Self
)
-
>
*
mut
T
{
Self
:
:
into_raw_with_allocator
(
b
)
.
0
}
#
[
inline
(
always
)
]
pub
fn
into_raw_with_allocator
(
b
:
Self
)
-
>
(
*
mut
T
A
)
{
let
(
leaked
alloc
)
=
Box
:
:
into_non_null
(
b
)
;
(
leaked
.
as_ptr
(
)
alloc
)
}
#
[
inline
(
always
)
]
pub
fn
into_non_null
(
b
:
Self
)
-
>
(
NonNull
<
T
>
A
)
{
let
alloc
=
unsafe
{
ptr
:
:
read
(
&
b
.
1
)
}
;
(
NonNull
:
:
from
(
Box
:
:
leak
(
b
)
)
alloc
)
}
#
[
inline
(
always
)
]
pub
const
fn
allocator
(
b
:
&
Self
)
-
>
&
A
{
&
b
.
1
}
#
[
inline
(
always
)
]
fn
leak
<
'
a
>
(
b
:
Self
)
-
>
&
'
a
mut
T
where
A
:
'
a
{
unsafe
{
&
mut
*
mem
:
:
ManuallyDrop
:
:
new
(
b
)
.
0
.
as_ptr
(
)
}
}
#
[
inline
(
always
)
]
pub
fn
into_pin
(
boxed
:
Self
)
-
>
Pin
<
Self
>
where
A
:
'
static
{
unsafe
{
Pin
:
:
new_unchecked
(
boxed
)
}
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
Drop
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
drop
(
&
mut
self
)
{
let
layout
=
Layout
:
:
for_value
:
:
<
T
>
(
&
*
*
self
)
;
unsafe
{
ptr
:
:
drop_in_place
(
self
.
0
.
as_mut
(
)
)
;
self
.
1
.
deallocate
(
self
.
0
.
cast
(
)
layout
)
;
}
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
T
:
Default
>
Default
for
Box
<
T
>
{
#
[
inline
(
always
)
]
fn
default
(
)
-
>
Self
{
Box
:
:
new
(
T
:
:
default
(
)
)
}
}
impl
<
T
A
:
Allocator
+
Default
>
Default
for
Box
<
[
T
]
A
>
{
#
[
inline
(
always
)
]
fn
default
(
)
-
>
Self
{
let
ptr
:
NonNull
<
[
T
]
>
=
NonNull
:
:
<
[
T
;
0
]
>
:
:
dangling
(
)
;
Box
(
ptr
A
:
:
default
(
)
)
}
}
impl
<
A
:
Allocator
+
Default
>
Default
for
Box
<
str
A
>
{
#
[
inline
(
always
)
]
fn
default
(
)
-
>
Self
{
let
ptr
:
NonNull
<
str
>
=
unsafe
{
let
bytes
:
NonNull
<
[
u8
]
>
=
NonNull
:
:
<
[
u8
;
0
]
>
:
:
dangling
(
)
;
NonNull
:
:
new_unchecked
(
bytes
.
as_ptr
(
)
as
*
mut
str
)
}
;
Box
(
ptr
A
:
:
default
(
)
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
T
:
Clone
A
:
Allocator
+
Clone
>
Clone
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
clone
(
&
self
)
-
>
Self
{
let
mut
boxed
=
Self
:
:
new_uninit_in
(
self
.
1
.
clone
(
)
)
;
unsafe
{
boxed
.
write
(
(
*
*
self
)
.
clone
(
)
)
;
boxed
.
assume_init
(
)
}
}
#
[
inline
(
always
)
]
fn
clone_from
(
&
mut
self
source
:
&
Self
)
{
(
*
*
self
)
.
clone_from
(
&
(
*
*
source
)
)
;
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
Clone
for
Box
<
str
>
{
#
[
inline
(
always
)
]
fn
clone
(
&
self
)
-
>
Self
{
let
buf
:
Box
<
[
u8
]
>
=
self
.
as_bytes
(
)
.
into
(
)
;
unsafe
{
Box
:
:
from_raw
(
Box
:
:
into_raw
(
buf
)
as
*
mut
str
)
}
}
}
impl
<
T
:
?
Sized
+
PartialEq
A
:
Allocator
>
PartialEq
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
PartialEq
:
:
eq
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
(
always
)
]
fn
ne
(
&
self
other
:
&
Self
)
-
>
bool
{
PartialEq
:
:
ne
(
&
*
*
self
&
*
*
other
)
}
}
impl
<
T
:
?
Sized
+
PartialOrd
A
:
Allocator
>
PartialOrd
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
PartialOrd
:
:
partial_cmp
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
(
always
)
]
fn
lt
(
&
self
other
:
&
Self
)
-
>
bool
{
PartialOrd
:
:
lt
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
(
always
)
]
fn
le
(
&
self
other
:
&
Self
)
-
>
bool
{
PartialOrd
:
:
le
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
(
always
)
]
fn
ge
(
&
self
other
:
&
Self
)
-
>
bool
{
PartialOrd
:
:
ge
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
(
always
)
]
fn
gt
(
&
self
other
:
&
Self
)
-
>
bool
{
PartialOrd
:
:
gt
(
&
*
*
self
&
*
*
other
)
}
}
impl
<
T
:
?
Sized
+
Ord
A
:
Allocator
>
Ord
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
Ord
:
:
cmp
(
&
*
*
self
&
*
*
other
)
}
}
impl
<
T
:
?
Sized
+
Eq
A
:
Allocator
>
Eq
for
Box
<
T
A
>
{
}
impl
<
T
:
?
Sized
+
Hash
A
:
Allocator
>
Hash
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
(
*
*
self
)
.
hash
(
state
)
;
}
}
impl
<
T
:
?
Sized
+
Hasher
A
:
Allocator
>
Hasher
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
finish
(
&
self
)
-
>
u64
{
(
*
*
self
)
.
finish
(
)
}
#
[
inline
(
always
)
]
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
{
(
*
*
self
)
.
write
(
bytes
)
}
#
[
inline
(
always
)
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
(
*
*
self
)
.
write_u8
(
i
)
}
#
[
inline
(
always
)
]
fn
write_u16
(
&
mut
self
i
:
u16
)
{
(
*
*
self
)
.
write_u16
(
i
)
}
#
[
inline
(
always
)
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
(
*
*
self
)
.
write_u32
(
i
)
}
#
[
inline
(
always
)
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
(
*
*
self
)
.
write_u64
(
i
)
}
#
[
inline
(
always
)
]
fn
write_u128
(
&
mut
self
i
:
u128
)
{
(
*
*
self
)
.
write_u128
(
i
)
}
#
[
inline
(
always
)
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
(
*
*
self
)
.
write_usize
(
i
)
}
#
[
inline
(
always
)
]
fn
write_i8
(
&
mut
self
i
:
i8
)
{
(
*
*
self
)
.
write_i8
(
i
)
}
#
[
inline
(
always
)
]
fn
write_i16
(
&
mut
self
i
:
i16
)
{
(
*
*
self
)
.
write_i16
(
i
)
}
#
[
inline
(
always
)
]
fn
write_i32
(
&
mut
self
i
:
i32
)
{
(
*
*
self
)
.
write_i32
(
i
)
}
#
[
inline
(
always
)
]
fn
write_i64
(
&
mut
self
i
:
i64
)
{
(
*
*
self
)
.
write_i64
(
i
)
}
#
[
inline
(
always
)
]
fn
write_i128
(
&
mut
self
i
:
i128
)
{
(
*
*
self
)
.
write_i128
(
i
)
}
#
[
inline
(
always
)
]
fn
write_isize
(
&
mut
self
i
:
isize
)
{
(
*
*
self
)
.
write_isize
(
i
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
T
>
From
<
T
>
for
Box
<
T
>
{
#
[
inline
(
always
)
]
fn
from
(
t
:
T
)
-
>
Self
{
Box
:
:
new
(
t
)
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
From
<
Box
<
T
A
>
>
for
Pin
<
Box
<
T
A
>
>
where
A
:
'
static
{
#
[
inline
(
always
)
]
fn
from
(
boxed
:
Box
<
T
A
>
)
-
>
Self
{
Box
:
:
into_pin
(
boxed
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
T
:
Copy
A
:
Allocator
+
Default
>
From
<
&
[
T
]
>
for
Box
<
[
T
]
A
>
{
#
[
inline
(
always
)
]
fn
from
(
slice
:
&
[
T
]
)
-
>
Box
<
[
T
]
A
>
{
let
len
=
slice
.
len
(
)
;
let
buf
=
RawVec
:
:
with_capacity_in
(
len
A
:
:
default
(
)
)
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
slice
.
as_ptr
(
)
buf
.
ptr
(
)
len
)
;
buf
.
into_box
(
slice
.
len
(
)
)
.
assume_init
(
)
}
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
A
:
Allocator
+
Default
>
From
<
&
str
>
for
Box
<
str
A
>
{
#
[
inline
(
always
)
]
fn
from
(
s
:
&
str
)
-
>
Box
<
str
A
>
{
let
(
raw
alloc
)
=
Box
:
:
into_raw_with_allocator
(
Box
:
:
<
[
u8
]
A
>
:
:
from
(
s
.
as_bytes
(
)
)
)
;
unsafe
{
Box
:
:
from_raw_in
(
raw
as
*
mut
str
alloc
)
}
}
}
impl
<
A
:
Allocator
>
From
<
Box
<
str
A
>
>
for
Box
<
[
u8
]
A
>
{
#
[
inline
(
always
)
]
fn
from
(
s
:
Box
<
str
A
>
)
-
>
Self
{
let
(
raw
alloc
)
=
Box
:
:
into_raw_with_allocator
(
s
)
;
unsafe
{
Box
:
:
from_raw_in
(
raw
as
*
mut
[
u8
]
alloc
)
}
}
}
impl
<
T
A
:
Allocator
const
N
:
usize
>
Box
<
[
T
;
N
]
A
>
{
#
[
inline
(
always
)
]
pub
fn
slice
(
b
:
Self
)
-
>
Box
<
[
T
]
A
>
{
let
(
ptr
alloc
)
=
Box
:
:
into_raw_with_allocator
(
b
)
;
unsafe
{
Box
:
:
from_raw_in
(
ptr
alloc
)
}
}
pub
fn
into_vec
(
self
)
-
>
Vec
<
T
A
>
where
A
:
Allocator
{
unsafe
{
let
(
b
alloc
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
Vec
:
:
from_raw_parts_in
(
b
as
*
mut
T
N
N
alloc
)
}
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
T
const
N
:
usize
>
From
<
[
T
;
N
]
>
for
Box
<
[
T
]
>
{
#
[
inline
(
always
)
]
fn
from
(
array
:
[
T
;
N
]
)
-
>
Box
<
[
T
]
>
{
Box
:
:
slice
(
Box
:
:
new
(
array
)
)
}
}
impl
<
T
A
:
Allocator
const
N
:
usize
>
TryFrom
<
Box
<
[
T
]
A
>
>
for
Box
<
[
T
;
N
]
A
>
{
type
Error
=
Box
<
[
T
]
A
>
;
#
[
inline
(
always
)
]
fn
try_from
(
boxed_slice
:
Box
<
[
T
]
A
>
)
-
>
Result
<
Self
Self
:
:
Error
>
{
if
boxed_slice
.
len
(
)
=
=
N
{
let
(
ptr
alloc
)
=
Box
:
:
into_raw_with_allocator
(
boxed_slice
)
;
Ok
(
unsafe
{
Box
:
:
from_raw_in
(
ptr
as
*
mut
[
T
;
N
]
alloc
)
}
)
}
else
{
Err
(
boxed_slice
)
}
}
}
impl
<
A
:
Allocator
>
Box
<
dyn
Any
A
>
{
#
[
inline
(
always
)
]
pub
fn
downcast
<
T
:
Any
>
(
self
)
-
>
Result
<
Box
<
T
A
>
Self
>
{
if
self
.
is
:
:
<
T
>
(
)
{
unsafe
{
Ok
(
self
.
downcast_unchecked
:
:
<
T
>
(
)
)
}
}
else
{
Err
(
self
)
}
}
#
[
inline
(
always
)
]
pub
unsafe
fn
downcast_unchecked
<
T
:
Any
>
(
self
)
-
>
Box
<
T
A
>
{
debug_assert
!
(
self
.
is
:
:
<
T
>
(
)
)
;
unsafe
{
let
(
raw
alloc
)
:
(
*
mut
dyn
Any
_
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
Box
:
:
from_raw_in
(
raw
as
*
mut
T
alloc
)
}
}
}
impl
<
A
:
Allocator
>
Box
<
dyn
Any
+
Send
A
>
{
#
[
inline
(
always
)
]
pub
fn
downcast
<
T
:
Any
>
(
self
)
-
>
Result
<
Box
<
T
A
>
Self
>
{
if
self
.
is
:
:
<
T
>
(
)
{
unsafe
{
Ok
(
self
.
downcast_unchecked
:
:
<
T
>
(
)
)
}
}
else
{
Err
(
self
)
}
}
#
[
inline
(
always
)
]
pub
unsafe
fn
downcast_unchecked
<
T
:
Any
>
(
self
)
-
>
Box
<
T
A
>
{
debug_assert
!
(
self
.
is
:
:
<
T
>
(
)
)
;
unsafe
{
let
(
raw
alloc
)
:
(
*
mut
(
dyn
Any
+
Send
)
_
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
Box
:
:
from_raw_in
(
raw
as
*
mut
T
alloc
)
}
}
}
impl
<
A
:
Allocator
>
Box
<
dyn
Any
+
Send
+
Sync
A
>
{
#
[
inline
(
always
)
]
pub
fn
downcast
<
T
:
Any
>
(
self
)
-
>
Result
<
Box
<
T
A
>
Self
>
{
if
self
.
is
:
:
<
T
>
(
)
{
unsafe
{
Ok
(
self
.
downcast_unchecked
:
:
<
T
>
(
)
)
}
}
else
{
Err
(
self
)
}
}
#
[
inline
(
always
)
]
pub
unsafe
fn
downcast_unchecked
<
T
:
Any
>
(
self
)
-
>
Box
<
T
A
>
{
debug_assert
!
(
self
.
is
:
:
<
T
>
(
)
)
;
unsafe
{
let
(
raw
alloc
)
:
(
*
mut
(
dyn
Any
+
Send
+
Sync
)
_
)
=
Box
:
:
into_raw_with_allocator
(
self
)
;
Box
:
:
from_raw_in
(
raw
as
*
mut
T
alloc
)
}
}
}
impl
<
T
:
fmt
:
:
Display
+
?
Sized
A
:
Allocator
>
fmt
:
:
Display
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
:
fmt
:
:
Debug
+
?
Sized
A
:
Allocator
>
fmt
:
:
Debug
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
fmt
:
:
Pointer
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
ptr
:
*
const
T
=
&
*
*
self
;
fmt
:
:
Pointer
:
:
fmt
(
&
ptr
f
)
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
Deref
for
Box
<
T
A
>
{
type
Target
=
T
;
#
[
inline
(
always
)
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
self
.
0
.
as_ref
(
)
}
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
DerefMut
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
self
.
0
.
as_mut
(
)
}
}
}
impl
<
I
:
Iterator
+
?
Sized
A
:
Allocator
>
Iterator
for
Box
<
I
A
>
{
type
Item
=
I
:
:
Item
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
next
(
)
}
#
[
inline
(
always
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
*
*
self
)
.
size_hint
(
)
}
#
[
inline
(
always
)
]
fn
nth
(
&
mut
self
n
:
usize
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
nth
(
n
)
}
#
[
inline
(
always
)
]
fn
last
(
self
)
-
>
Option
<
I
:
:
Item
>
{
BoxIter
:
:
last
(
self
)
}
}
trait
BoxIter
{
type
Item
;
fn
last
(
self
)
-
>
Option
<
Self
:
:
Item
>
;
}
impl
<
I
:
Iterator
+
?
Sized
A
:
Allocator
>
BoxIter
for
Box
<
I
A
>
{
type
Item
=
I
:
:
Item
;
#
[
inline
(
always
)
]
fn
last
(
self
)
-
>
Option
<
I
:
:
Item
>
{
#
[
inline
(
always
)
]
fn
some
<
T
>
(
_
:
Option
<
T
>
x
:
T
)
-
>
Option
<
T
>
{
Some
(
x
)
}
self
.
fold
(
None
some
)
}
}
impl
<
I
:
DoubleEndedIterator
+
?
Sized
A
:
Allocator
>
DoubleEndedIterator
for
Box
<
I
A
>
{
#
[
inline
(
always
)
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
next_back
(
)
}
#
[
inline
(
always
)
]
fn
nth_back
(
&
mut
self
n
:
usize
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
nth_back
(
n
)
}
}
impl
<
I
:
ExactSizeIterator
+
?
Sized
A
:
Allocator
>
ExactSizeIterator
for
Box
<
I
A
>
{
#
[
inline
(
always
)
]
fn
len
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
len
(
)
}
}
impl
<
I
:
FusedIterator
+
?
Sized
A
:
Allocator
>
FusedIterator
for
Box
<
I
A
>
{
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
I
>
FromIterator
<
I
>
for
Box
<
[
I
]
>
{
#
[
inline
(
always
)
]
fn
from_iter
<
T
:
IntoIterator
<
Item
=
I
>
>
(
iter
:
T
)
-
>
Self
{
iter
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
T
:
Clone
A
:
Allocator
+
Clone
>
Clone
for
Box
<
[
T
]
A
>
{
#
[
inline
(
always
)
]
fn
clone
(
&
self
)
-
>
Self
{
let
alloc
=
Box
:
:
allocator
(
self
)
.
clone
(
)
;
let
mut
vec
=
Vec
:
:
with_capacity_in
(
self
.
len
(
)
alloc
)
;
vec
.
extend_from_slice
(
self
)
;
vec
.
into_boxed_slice
(
)
}
#
[
inline
(
always
)
]
fn
clone_from
(
&
mut
self
other
:
&
Self
)
{
if
self
.
len
(
)
=
=
other
.
len
(
)
{
self
.
clone_from_slice
(
other
)
;
}
else
{
*
self
=
other
.
clone
(
)
;
}
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
borrow
:
:
Borrow
<
T
>
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
borrow
(
&
self
)
-
>
&
T
{
self
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
borrow
:
:
BorrowMut
<
T
>
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
borrow_mut
(
&
mut
self
)
-
>
&
mut
T
{
self
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
AsRef
<
T
>
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
as_ref
(
&
self
)
-
>
&
T
{
self
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
AsMut
<
T
>
for
Box
<
T
A
>
{
#
[
inline
(
always
)
]
fn
as_mut
(
&
mut
self
)
-
>
&
mut
T
{
self
}
}
impl
<
T
:
?
Sized
A
:
Allocator
>
Unpin
for
Box
<
T
A
>
where
A
:
'
static
{
}
impl
<
F
:
?
Sized
+
Future
+
Unpin
A
:
Allocator
>
Future
for
Box
<
F
A
>
where
A
:
'
static
{
type
Output
=
F
:
:
Output
;
#
[
inline
(
always
)
]
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
F
:
:
poll
(
Pin
:
:
new
(
&
mut
*
self
)
cx
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
mod
error
{
use
std
:
:
error
:
:
Error
;
use
super
:
:
Box
;
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
'
a
E
:
Error
+
'
a
>
From
<
E
>
for
Box
<
dyn
Error
+
'
a
>
{
#
[
inline
(
always
)
]
fn
from
(
err
:
E
)
-
>
Box
<
dyn
Error
+
'
a
>
{
unsafe
{
Box
:
:
from_raw
(
Box
:
:
leak
(
Box
:
:
new
(
err
)
)
)
}
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
<
'
a
E
:
Error
+
Send
+
Sync
+
'
a
>
From
<
E
>
for
Box
<
dyn
Error
+
Send
+
Sync
+
'
a
>
{
#
[
inline
(
always
)
]
fn
from
(
err
:
E
)
-
>
Box
<
dyn
Error
+
Send
+
Sync
+
'
a
>
{
unsafe
{
Box
:
:
from_raw
(
Box
:
:
leak
(
Box
:
:
new
(
err
)
)
)
}
}
}
impl
<
T
:
Error
>
Error
for
Box
<
T
>
{
#
[
inline
(
always
)
]
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
Error
+
'
static
)
>
{
Error
:
:
source
(
&
*
*
self
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
R
:
std
:
:
io
:
:
Read
+
?
Sized
A
:
Allocator
>
std
:
:
io
:
:
Read
for
Box
<
R
A
>
{
#
[
inline
]
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
(
*
*
self
)
.
read
(
buf
)
}
#
[
inline
]
fn
read_to_end
(
&
mut
self
buf
:
&
mut
std
:
:
vec
:
:
Vec
<
u8
>
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
(
*
*
self
)
.
read_to_end
(
buf
)
}
#
[
inline
]
fn
read_to_string
(
&
mut
self
buf
:
&
mut
String
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
(
*
*
self
)
.
read_to_string
(
buf
)
}
#
[
inline
]
fn
read_exact
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
(
*
*
self
)
.
read_exact
(
buf
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
W
:
std
:
:
io
:
:
Write
+
?
Sized
A
:
Allocator
>
std
:
:
io
:
:
Write
for
Box
<
W
A
>
{
#
[
inline
]
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
(
*
*
self
)
.
write
(
buf
)
}
#
[
inline
]
fn
flush
(
&
mut
self
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
(
*
*
self
)
.
flush
(
)
}
#
[
inline
]
fn
write_all
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
(
*
*
self
)
.
write_all
(
buf
)
}
#
[
inline
]
fn
write_fmt
(
&
mut
self
fmt
:
fmt
:
:
Arguments
<
'
_
>
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
(
*
*
self
)
.
write_fmt
(
fmt
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
S
:
std
:
:
io
:
:
Seek
+
?
Sized
A
:
Allocator
>
std
:
:
io
:
:
Seek
for
Box
<
S
A
>
{
#
[
inline
]
fn
seek
(
&
mut
self
pos
:
std
:
:
io
:
:
SeekFrom
)
-
>
std
:
:
io
:
:
Result
<
u64
>
{
(
*
*
self
)
.
seek
(
pos
)
}
#
[
inline
]
fn
stream_position
(
&
mut
self
)
-
>
std
:
:
io
:
:
Result
<
u64
>
{
(
*
*
self
)
.
stream_position
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
B
:
std
:
:
io
:
:
BufRead
+
?
Sized
A
:
Allocator
>
std
:
:
io
:
:
BufRead
for
Box
<
B
A
>
{
#
[
inline
]
fn
fill_buf
(
&
mut
self
)
-
>
std
:
:
io
:
:
Result
<
&
[
u8
]
>
{
(
*
*
self
)
.
fill_buf
(
)
}
#
[
inline
]
fn
consume
(
&
mut
self
amt
:
usize
)
{
(
*
*
self
)
.
consume
(
amt
)
}
#
[
inline
]
fn
read_until
(
&
mut
self
byte
:
u8
buf
:
&
mut
std
:
:
vec
:
:
Vec
<
u8
>
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
(
*
*
self
)
.
read_until
(
byte
buf
)
}
#
[
inline
]
fn
read_line
(
&
mut
self
buf
:
&
mut
std
:
:
string
:
:
String
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
(
*
*
self
)
.
read_line
(
buf
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
A
:
Allocator
>
Extend
<
Box
<
str
A
>
>
for
alloc_crate
:
:
string
:
:
String
{
fn
extend
<
I
:
IntoIterator
<
Item
=
Box
<
str
A
>
>
>
(
&
mut
self
iter
:
I
)
{
iter
.
into_iter
(
)
.
for_each
(
move
|
s
|
self
.
push_str
(
&
s
)
)
;
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
Clone
for
Box
<
core
:
:
ffi
:
:
CStr
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
(
*
*
self
)
.
into
(
)
}
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
impl
From
<
&
core
:
:
ffi
:
:
CStr
>
for
Box
<
core
:
:
ffi
:
:
CStr
>
{
fn
from
(
s
:
&
core
:
:
ffi
:
:
CStr
)
-
>
Box
<
core
:
:
ffi
:
:
CStr
>
{
let
boxed
:
Box
<
[
u8
]
>
=
Box
:
:
from
(
s
.
to_bytes_with_nul
(
)
)
;
unsafe
{
Box
:
:
from_raw
(
Box
:
:
into_raw
(
boxed
)
as
*
mut
core
:
:
ffi
:
:
CStr
)
}
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
T
A
>
serde
:
:
Serialize
for
Box
<
T
A
>
where
T
:
serde
:
:
Serialize
A
:
Allocator
{
#
[
inline
(
always
)
]
fn
serialize
<
S
:
serde
:
:
ser
:
:
Serializer
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
{
(
*
*
self
)
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
T
A
>
serde
:
:
Deserialize
<
'
de
>
for
Box
<
T
A
>
where
T
:
serde
:
:
Deserialize
<
'
de
>
A
:
Allocator
+
Default
{
#
[
inline
(
always
)
]
fn
deserialize
<
D
:
serde
:
:
de
:
:
Deserializer
<
'
de
>
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
{
let
value
=
T
:
:
deserialize
(
deserializer
)
?
;
Ok
(
Box
:
:
new_in
(
value
A
:
:
default
(
)
)
)
}
}
