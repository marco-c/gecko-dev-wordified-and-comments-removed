use
core
:
:
ptr
:
:
{
self
}
;
use
core
:
:
slice
:
:
{
self
}
;
use
crate
:
:
stable
:
:
alloc
:
:
{
Allocator
Global
}
;
use
super
:
:
{
Drain
Vec
}
;
#
[
derive
(
Debug
)
]
pub
struct
Splice
<
'
a
I
:
Iterator
+
'
a
A
:
Allocator
+
'
a
=
Global
>
{
pub
(
super
)
drain
:
Drain
<
'
a
I
:
:
Item
A
>
pub
(
super
)
replace_with
:
I
}
impl
<
I
:
Iterator
A
:
Allocator
>
Iterator
for
Splice
<
'
_
I
A
>
{
type
Item
=
I
:
:
Item
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
drain
.
next
(
)
}
#
[
inline
(
always
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
drain
.
size_hint
(
)
}
}
impl
<
I
:
Iterator
A
:
Allocator
>
DoubleEndedIterator
for
Splice
<
'
_
I
A
>
{
#
[
inline
(
always
)
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
drain
.
next_back
(
)
}
}
impl
<
I
:
Iterator
A
:
Allocator
>
ExactSizeIterator
for
Splice
<
'
_
I
A
>
{
}
impl
<
I
:
Iterator
A
:
Allocator
>
Drop
for
Splice
<
'
_
I
A
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
drain
.
by_ref
(
)
.
for_each
(
drop
)
;
unsafe
{
if
self
.
drain
.
tail_len
=
=
0
{
self
.
drain
.
vec
.
as_mut
(
)
.
extend
(
self
.
replace_with
.
by_ref
(
)
)
;
return
;
}
if
!
self
.
drain
.
fill
(
&
mut
self
.
replace_with
)
{
return
;
}
let
(
lower_bound
_upper_bound
)
=
self
.
replace_with
.
size_hint
(
)
;
if
lower_bound
>
0
{
self
.
drain
.
move_tail
(
lower_bound
)
;
if
!
self
.
drain
.
fill
(
&
mut
self
.
replace_with
)
{
return
;
}
}
let
mut
collected
=
self
.
replace_with
.
by_ref
(
)
.
collect
:
:
<
Vec
<
I
:
:
Item
>
>
(
)
.
into_iter
(
)
;
if
collected
.
len
(
)
>
0
{
self
.
drain
.
move_tail
(
collected
.
len
(
)
)
;
let
filled
=
self
.
drain
.
fill
(
&
mut
collected
)
;
debug_assert
!
(
filled
)
;
debug_assert_eq
!
(
collected
.
len
(
)
0
)
;
}
}
}
}
impl
<
T
A
:
Allocator
>
Drain
<
'
_
T
A
>
{
#
[
inline
(
always
)
]
unsafe
fn
fill
<
I
:
Iterator
<
Item
=
T
>
>
(
&
mut
self
replace_with
:
&
mut
I
)
-
>
bool
{
let
vec
=
unsafe
{
self
.
vec
.
as_mut
(
)
}
;
let
range_start
=
vec
.
len
;
let
range_end
=
self
.
tail_start
;
let
range_slice
=
unsafe
{
slice
:
:
from_raw_parts_mut
(
vec
.
as_mut_ptr
(
)
.
add
(
range_start
)
range_end
-
range_start
)
}
;
for
place
in
range_slice
{
if
let
Some
(
new_item
)
=
replace_with
.
next
(
)
{
unsafe
{
ptr
:
:
write
(
place
new_item
)
}
;
vec
.
len
+
=
1
;
}
else
{
return
false
;
}
}
true
}
#
[
inline
(
always
)
]
unsafe
fn
move_tail
(
&
mut
self
additional
:
usize
)
{
let
vec
=
unsafe
{
self
.
vec
.
as_mut
(
)
}
;
let
len
=
self
.
tail_start
+
self
.
tail_len
;
vec
.
buf
.
reserve
(
len
additional
)
;
let
new_tail_start
=
self
.
tail_start
+
additional
;
unsafe
{
let
src
=
vec
.
as_ptr
(
)
.
add
(
self
.
tail_start
)
;
let
dst
=
vec
.
as_mut_ptr
(
)
.
add
(
new_tail_start
)
;
ptr
:
:
copy
(
src
dst
self
.
tail_len
)
;
}
self
.
tail_start
=
new_tail_start
;
}
}
