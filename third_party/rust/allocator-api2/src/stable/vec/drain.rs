use
core
:
:
fmt
;
use
core
:
:
iter
:
:
FusedIterator
;
use
core
:
:
mem
:
:
{
self
size_of
ManuallyDrop
}
;
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
use
core
:
:
slice
:
:
{
self
}
;
use
crate
:
:
stable
:
:
alloc
:
:
{
Allocator
Global
}
;
use
super
:
:
Vec
;
pub
struct
Drain
<
'
a
T
:
'
a
A
:
Allocator
+
'
a
=
Global
>
{
pub
(
super
)
tail_start
:
usize
pub
(
super
)
tail_len
:
usize
pub
(
super
)
iter
:
slice
:
:
Iter
<
'
a
T
>
pub
(
super
)
vec
:
NonNull
<
Vec
<
T
A
>
>
}
impl
<
T
:
fmt
:
:
Debug
A
:
Allocator
>
fmt
:
:
Debug
for
Drain
<
'
_
T
A
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
Drain
"
)
.
field
(
&
self
.
iter
.
as_slice
(
)
)
.
finish
(
)
}
}
impl
<
'
a
T
A
:
Allocator
>
Drain
<
'
a
T
A
>
{
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
T
]
{
self
.
iter
.
as_slice
(
)
}
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
allocator
(
&
self
)
-
>
&
A
{
unsafe
{
self
.
vec
.
as_ref
(
)
.
allocator
(
)
}
}
#
[
inline
(
always
)
]
pub
fn
keep_rest
(
self
)
{
let
mut
this
=
ManuallyDrop
:
:
new
(
self
)
;
unsafe
{
let
source_vec
=
this
.
vec
.
as_mut
(
)
;
let
start
=
source_vec
.
len
(
)
;
let
tail
=
this
.
tail_start
;
let
unyielded_len
=
this
.
iter
.
len
(
)
;
let
unyielded_ptr
=
this
.
iter
.
as_slice
(
)
.
as_ptr
(
)
;
let
needs_move
=
mem
:
:
size_of
:
:
<
T
>
(
)
!
=
0
;
if
needs_move
{
let
start_ptr
=
source_vec
.
as_mut_ptr
(
)
.
add
(
start
)
;
if
unyielded_ptr
!
=
start_ptr
{
let
src
=
unyielded_ptr
;
let
dst
=
start_ptr
;
ptr
:
:
copy
(
src
dst
unyielded_len
)
;
}
if
tail
!
=
(
start
+
unyielded_len
)
{
let
src
=
source_vec
.
as_ptr
(
)
.
add
(
tail
)
;
let
dst
=
start_ptr
.
add
(
unyielded_len
)
;
ptr
:
:
copy
(
src
dst
this
.
tail_len
)
;
}
}
source_vec
.
set_len
(
start
+
unyielded_len
+
this
.
tail_len
)
;
}
}
}
impl
<
'
a
T
A
:
Allocator
>
AsRef
<
[
T
]
>
for
Drain
<
'
a
T
A
>
{
#
[
inline
(
always
)
]
fn
as_ref
(
&
self
)
-
>
&
[
T
]
{
self
.
as_slice
(
)
}
}
unsafe
impl
<
T
:
Sync
A
:
Sync
+
Allocator
>
Sync
for
Drain
<
'
_
T
A
>
{
}
unsafe
impl
<
T
:
Send
A
:
Send
+
Allocator
>
Send
for
Drain
<
'
_
T
A
>
{
}
impl
<
T
A
:
Allocator
>
Iterator
for
Drain
<
'
_
T
A
>
{
type
Item
=
T
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
iter
.
next
(
)
.
map
(
|
elt
|
unsafe
{
ptr
:
:
read
(
elt
as
*
const
_
)
}
)
}
#
[
inline
(
always
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
T
A
:
Allocator
>
DoubleEndedIterator
for
Drain
<
'
_
T
A
>
{
#
[
inline
(
always
)
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
iter
.
next_back
(
)
.
map
(
|
elt
|
unsafe
{
ptr
:
:
read
(
elt
as
*
const
_
)
}
)
}
}
impl
<
T
A
:
Allocator
>
Drop
for
Drain
<
'
_
T
A
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
struct
DropGuard
<
'
r
'
a
T
A
:
Allocator
>
(
&
'
r
mut
Drain
<
'
a
T
A
>
)
;
impl
<
'
r
'
a
T
A
:
Allocator
>
Drop
for
DropGuard
<
'
r
'
a
T
A
>
{
fn
drop
(
&
mut
self
)
{
if
self
.
0
.
tail_len
>
0
{
unsafe
{
let
source_vec
=
self
.
0
.
vec
.
as_mut
(
)
;
let
start
=
source_vec
.
len
(
)
;
let
tail
=
self
.
0
.
tail_start
;
if
tail
!
=
start
{
let
src
=
source_vec
.
as_ptr
(
)
.
add
(
tail
)
;
let
dst
=
source_vec
.
as_mut_ptr
(
)
.
add
(
start
)
;
ptr
:
:
copy
(
src
dst
self
.
0
.
tail_len
)
;
}
source_vec
.
set_len
(
start
+
self
.
0
.
tail_len
)
;
}
}
}
}
let
iter
=
mem
:
:
replace
(
&
mut
self
.
iter
[
]
.
iter
(
)
)
;
let
drop_len
=
iter
.
len
(
)
;
let
mut
vec
=
self
.
vec
;
if
size_of
:
:
<
T
>
(
)
=
=
0
{
unsafe
{
let
vec
=
vec
.
as_mut
(
)
;
let
old_len
=
vec
.
len
(
)
;
vec
.
set_len
(
old_len
+
drop_len
+
self
.
tail_len
)
;
vec
.
truncate
(
old_len
+
self
.
tail_len
)
;
}
return
;
}
let
_guard
=
DropGuard
(
self
)
;
if
drop_len
=
=
0
{
return
;
}
let
drop_ptr
=
iter
.
as_slice
(
)
.
as_ptr
(
)
;
unsafe
{
let
vec_ptr
=
vec
.
as_mut
(
)
.
as_mut_ptr
(
)
;
let
drop_offset
=
drop_ptr
.
offset_from
(
vec_ptr
)
as
usize
;
let
to_drop
=
ptr
:
:
slice_from_raw_parts_mut
(
vec_ptr
.
add
(
drop_offset
)
drop_len
)
;
ptr
:
:
drop_in_place
(
to_drop
)
;
}
}
}
impl
<
T
A
:
Allocator
>
ExactSizeIterator
for
Drain
<
'
_
T
A
>
{
}
impl
<
T
A
:
Allocator
>
FusedIterator
for
Drain
<
'
_
T
A
>
{
}
