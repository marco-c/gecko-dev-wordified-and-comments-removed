use
core
:
:
{
fmt
ptr
:
:
{
self
NonNull
}
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
global
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
system
;
pub
use
core
:
:
alloc
:
:
{
GlobalAlloc
Layout
LayoutError
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
self
:
:
global
:
:
Global
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
system
:
:
System
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
alloc_crate
:
:
alloc
:
:
{
alloc
alloc_zeroed
dealloc
realloc
}
;
#
[
cfg
(
all
(
feature
=
"
alloc
"
not
(
no_global_oom_handling
)
)
)
]
pub
use
alloc_crate
:
:
alloc
:
:
handle_alloc_error
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
struct
AllocError
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
AllocError
{
}
impl
fmt
:
:
Display
for
AllocError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
memory
allocation
failed
"
)
}
}
pub
unsafe
trait
Allocator
{
fn
allocate
(
&
self
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
;
#
[
inline
(
always
)
]
fn
allocate_zeroed
(
&
self
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
let
ptr
=
self
.
allocate
(
layout
)
?
;
unsafe
{
ptr
.
cast
:
:
<
u8
>
(
)
.
as_ptr
(
)
.
write_bytes
(
0
ptr
.
len
(
)
)
}
Ok
(
ptr
)
}
unsafe
fn
deallocate
(
&
self
ptr
:
NonNull
<
u8
>
layout
:
Layout
)
;
#
[
inline
(
always
)
]
unsafe
fn
grow
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
debug_assert
!
(
new_layout
.
size
(
)
>
=
old_layout
.
size
(
)
"
new_layout
.
size
(
)
must
be
greater
than
or
equal
to
old_layout
.
size
(
)
"
)
;
let
new_ptr
=
self
.
allocate
(
new_layout
)
?
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
ptr
.
as_ptr
(
)
new_ptr
.
as_ptr
(
)
.
cast
(
)
old_layout
.
size
(
)
)
;
self
.
deallocate
(
ptr
old_layout
)
;
}
Ok
(
new_ptr
)
}
#
[
inline
(
always
)
]
unsafe
fn
grow_zeroed
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
debug_assert
!
(
new_layout
.
size
(
)
>
=
old_layout
.
size
(
)
"
new_layout
.
size
(
)
must
be
greater
than
or
equal
to
old_layout
.
size
(
)
"
)
;
let
new_ptr
=
self
.
allocate_zeroed
(
new_layout
)
?
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
ptr
.
as_ptr
(
)
new_ptr
.
as_ptr
(
)
.
cast
(
)
old_layout
.
size
(
)
)
;
self
.
deallocate
(
ptr
old_layout
)
;
}
Ok
(
new_ptr
)
}
#
[
inline
(
always
)
]
unsafe
fn
shrink
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
debug_assert
!
(
new_layout
.
size
(
)
<
=
old_layout
.
size
(
)
"
new_layout
.
size
(
)
must
be
smaller
than
or
equal
to
old_layout
.
size
(
)
"
)
;
let
new_ptr
=
self
.
allocate
(
new_layout
)
?
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
ptr
.
as_ptr
(
)
new_ptr
.
as_ptr
(
)
.
cast
(
)
new_layout
.
size
(
)
)
;
self
.
deallocate
(
ptr
old_layout
)
;
}
Ok
(
new_ptr
)
}
#
[
inline
(
always
)
]
fn
by_ref
(
&
self
)
-
>
&
Self
where
Self
:
Sized
{
self
}
}
unsafe
impl
<
A
>
Allocator
for
&
A
where
A
:
Allocator
+
?
Sized
{
#
[
inline
(
always
)
]
fn
allocate
(
&
self
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
(
*
*
self
)
.
allocate
(
layout
)
}
#
[
inline
(
always
)
]
fn
allocate_zeroed
(
&
self
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
(
*
*
self
)
.
allocate_zeroed
(
layout
)
}
#
[
inline
(
always
)
]
unsafe
fn
deallocate
(
&
self
ptr
:
NonNull
<
u8
>
layout
:
Layout
)
{
unsafe
{
(
*
*
self
)
.
deallocate
(
ptr
layout
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
grow
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
unsafe
{
(
*
*
self
)
.
grow
(
ptr
old_layout
new_layout
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
grow_zeroed
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
unsafe
{
(
*
*
self
)
.
grow_zeroed
(
ptr
old_layout
new_layout
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
shrink
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
unsafe
{
(
*
*
self
)
.
shrink
(
ptr
old_layout
new_layout
)
}
}
}
