use
crate
:
:
{
alloc
:
:
{
Allocator
Global
}
vec
:
:
Vec
}
;
pub
trait
SliceExt
<
T
>
{
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
inline
(
always
)
]
fn
to_vec
(
&
self
)
-
>
Vec
<
T
Global
>
where
T
:
Clone
{
self
.
to_vec_in
(
Global
)
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
fn
to_vec_in
<
A
:
Allocator
>
(
&
self
alloc
:
A
)
-
>
Vec
<
T
A
>
where
T
:
Clone
;
fn
repeat
(
&
self
n
:
usize
)
-
>
Vec
<
T
Global
>
where
T
:
Copy
;
}
impl
<
T
>
SliceExt
<
T
>
for
[
T
]
{
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
inline
]
fn
to_vec_in
<
A
:
Allocator
>
(
&
self
alloc
:
A
)
-
>
Vec
<
T
A
>
where
T
:
Clone
{
struct
DropGuard
<
'
a
T
A
:
Allocator
>
{
vec
:
&
'
a
mut
Vec
<
T
A
>
num_init
:
usize
}
impl
<
'
a
T
A
:
Allocator
>
Drop
for
DropGuard
<
'
a
T
A
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
vec
.
set_len
(
self
.
num_init
)
;
}
}
}
let
mut
vec
=
Vec
:
:
with_capacity_in
(
self
.
len
(
)
alloc
)
;
let
mut
guard
=
DropGuard
{
vec
:
&
mut
vec
num_init
:
0
}
;
let
slots
=
guard
.
vec
.
spare_capacity_mut
(
)
;
for
(
i
b
)
in
self
.
iter
(
)
.
enumerate
(
)
.
take
(
slots
.
len
(
)
)
{
guard
.
num_init
=
i
;
slots
[
i
]
.
write
(
b
.
clone
(
)
)
;
}
core
:
:
mem
:
:
forget
(
guard
)
;
unsafe
{
vec
.
set_len
(
self
.
len
(
)
)
;
}
vec
}
#
[
cfg
(
not
(
no_global_oom_handling
)
)
]
#
[
inline
]
fn
repeat
(
&
self
n
:
usize
)
-
>
Vec
<
T
Global
>
where
T
:
Copy
{
if
n
=
=
0
{
return
Vec
:
:
new
(
)
;
}
let
capacity
=
self
.
len
(
)
.
checked_mul
(
n
)
.
expect
(
"
capacity
overflow
"
)
;
let
mut
buf
=
Vec
:
:
with_capacity
(
capacity
)
;
buf
.
extend
(
self
)
;
{
let
mut
m
=
n
>
>
1
;
while
m
>
0
{
unsafe
{
core
:
:
ptr
:
:
copy_nonoverlapping
(
buf
.
as_ptr
(
)
(
buf
.
as_mut_ptr
(
)
as
*
mut
T
)
.
add
(
buf
.
len
(
)
)
buf
.
len
(
)
)
;
let
buf_len
=
buf
.
len
(
)
;
buf
.
set_len
(
buf_len
*
2
)
;
}
m
>
>
=
1
;
}
}
let
rem_len
=
capacity
-
buf
.
len
(
)
;
if
rem_len
>
0
{
unsafe
{
core
:
:
ptr
:
:
copy_nonoverlapping
(
buf
.
as_ptr
(
)
(
buf
.
as_mut_ptr
(
)
as
*
mut
T
)
.
add
(
buf
.
len
(
)
)
rem_len
)
;
buf
.
set_len
(
capacity
)
;
}
}
buf
}
}
