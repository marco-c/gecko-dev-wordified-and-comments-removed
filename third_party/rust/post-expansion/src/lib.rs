extern
crate
syn
;
use
syn
:
:
*
;
#
[
macro_use
]
extern
crate
quote
;
#
[
macro_export
]
macro_rules
!
register_post_expansion
{
(
id
:
ident
)
=
>
{
#
[
proc_macro_derive
(
id
)
]
pub
fn
post_expansion
(
input
:
:
:
proc_macro
:
:
TokenStream
)
-
>
:
:
proc_macro
:
:
TokenStream
{
let
source
=
input
.
to_string
(
)
;
let
clean
=
:
:
post_expansion
:
:
run
(
source
)
;
clean
.
parse
(
)
.
unwrap
(
)
}
}
;
}
pub
fn
run
(
input
:
String
)
-
>
String
{
let
ast
=
parse_macro_input
(
&
input
)
.
unwrap
(
)
;
let
clean
=
post_expansion
(
ast
)
;
quote
!
(
#
clean
)
.
to_string
(
)
}
fn
post_expansion
(
mut
ast
:
MacroInput
)
-
>
MacroInput
{
let
mut
strip
=
Vec
:
:
new
(
)
;
ast
.
attrs
=
ast
.
attrs
.
into_iter
(
)
.
filter_map
(
|
attr
|
{
if
attr
.
is_sugared_doc
|
|
attr
.
style
!
=
AttrStyle
:
:
Outer
{
return
Some
(
attr
)
;
}
let
(
name
nested
)
=
match
attr
.
value
{
MetaItem
:
:
List
(
name
nested
)
=
>
(
name
nested
)
_
=
>
{
return
Some
(
attr
)
;
}
}
;
match
name
.
as_ref
(
)
{
"
post_expansion
"
=
>
{
for
nested
in
nested
{
if
let
MetaItem
:
:
NameValue
(
name
Lit
:
:
Str
(
attr
_
)
)
=
nested
{
if
name
=
=
"
strip
"
&
&
!
strip
.
contains
(
&
attr
)
{
strip
.
push
(
attr
)
;
}
}
}
None
}
"
derive
"
=
>
{
let
rest
:
Vec
<
_
>
=
nested
.
into_iter
(
)
.
filter
(
|
nested
|
{
match
*
nested
{
MetaItem
:
:
Word
(
ref
word
)
=
>
{
!
word
.
as_ref
(
)
.
starts_with
(
"
PostExpansion_
"
)
}
_
=
>
true
}
}
)
.
collect
(
)
;
if
rest
.
is_empty
(
)
{
None
}
else
{
Some
(
Attribute
{
style
:
AttrStyle
:
:
Outer
value
:
MetaItem
:
:
List
(
name
rest
)
is_sugared_doc
:
false
}
)
}
}
_
=
>
{
Some
(
Attribute
{
style
:
AttrStyle
:
:
Outer
value
:
MetaItem
:
:
List
(
name
nested
)
is_sugared_doc
:
false
}
)
}
}
}
)
.
collect
(
)
;
strip_attrs_now
(
ast
&
strip
.
iter
(
)
.
map
(
AsRef
:
:
as_ref
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
}
pub
fn
strip_attrs_now
(
ast
:
MacroInput
strip
:
&
[
&
str
]
)
-
>
MacroInput
{
if
strip
.
is_empty
(
)
{
return
ast
;
}
return
MacroInput
{
attrs
:
strip_attrs
(
ast
.
attrs
strip
)
body
:
match
ast
.
body
{
Body
:
:
Enum
(
variants
)
=
>
{
Body
:
:
Enum
(
variants
.
into_iter
(
)
.
map
(
|
variant
|
{
Variant
{
attrs
:
strip_attrs
(
variant
.
attrs
strip
)
data
:
strip_variant_data
(
variant
.
data
strip
)
.
.
variant
}
}
)
.
collect
(
)
)
}
Body
:
:
Struct
(
variant_data
)
=
>
Body
:
:
Struct
(
strip_variant_data
(
variant_data
strip
)
)
}
.
.
ast
}
;
fn
strip_variant_data
(
data
:
VariantData
strip
:
&
[
&
str
]
)
-
>
VariantData
{
match
data
{
VariantData
:
:
Struct
(
fields
)
=
>
{
VariantData
:
:
Struct
(
fields
.
into_iter
(
)
.
map
(
|
field
|
strip_field
(
field
strip
)
)
.
collect
(
)
)
}
VariantData
:
:
Tuple
(
fields
)
=
>
{
VariantData
:
:
Tuple
(
fields
.
into_iter
(
)
.
map
(
|
field
|
strip_field
(
field
strip
)
)
.
collect
(
)
)
}
VariantData
:
:
Unit
=
>
VariantData
:
:
Unit
}
}
fn
strip_field
(
field
:
Field
strip
:
&
[
&
str
]
)
-
>
Field
{
Field
{
attrs
:
strip_attrs
(
field
.
attrs
strip
)
.
.
field
}
}
fn
strip_attrs
(
attrs
:
Vec
<
Attribute
>
strip
:
&
[
&
str
]
)
-
>
Vec
<
Attribute
>
{
attrs
.
into_iter
(
)
.
filter
(
|
attr
|
{
match
attr
.
value
{
MetaItem
:
:
List
(
ref
ident
_
)
=
>
!
strip
.
into_iter
(
)
.
any
(
|
n
|
ident
=
=
n
)
_
=
>
true
}
}
)
.
collect
(
)
}
}
pub
fn
strip_attrs_later
(
mut
ast
:
MacroInput
strip
:
&
[
&
str
]
identifier
:
&
str
)
-
>
MacroInput
{
if
strip
.
is_empty
(
)
{
return
ast
;
}
let
run_now
=
can_run_post_expansion_now
(
&
ast
)
;
ast
.
attrs
.
push
(
Attribute
{
style
:
AttrStyle
:
:
Outer
value
:
MetaItem
:
:
List
(
"
derive
"
.
into
(
)
vec
!
[
MetaItem
:
:
Word
(
format
!
(
"
PostExpansion_
{
}
"
identifier
)
.
into
(
)
)
]
)
is_sugared_doc
:
false
}
)
;
ast
.
attrs
.
push
(
Attribute
{
style
:
AttrStyle
:
:
Outer
value
:
MetaItem
:
:
List
(
"
post_expansion
"
.
into
(
)
strip
.
into_iter
(
)
.
map
(
|
&
n
|
{
MetaItem
:
:
NameValue
(
"
strip
"
.
into
(
)
Lit
:
:
Str
(
n
.
into
(
)
StrStyle
:
:
Cooked
)
)
}
)
.
collect
(
)
)
is_sugared_doc
:
false
}
)
;
if
run_now
{
post_expansion
(
ast
)
}
else
{
ast
}
}
fn
can_run_post_expansion_now
(
ast
:
&
MacroInput
)
-
>
bool
{
for
attr
in
&
ast
.
attrs
{
if
attr
.
is_sugared_doc
|
|
attr
.
style
!
=
AttrStyle
:
:
Outer
{
continue
;
}
let
list
=
match
attr
.
value
{
MetaItem
:
:
List
(
ref
name
ref
list
)
if
name
=
=
"
derive
"
=
>
list
_
=
>
{
continue
;
}
}
;
for
elem
in
list
{
let
word
=
match
*
elem
{
MetaItem
:
:
Word
(
ref
word
)
=
>
word
_
=
>
{
return
false
;
}
}
;
match
word
.
as_ref
(
)
{
"
Clone
"
|
"
Hash
"
|
"
RustcEncodable
"
|
"
RustcDecodable
"
|
"
PartialEq
"
|
"
Eq
"
|
"
PartialOrd
"
|
"
Ord
"
|
"
Debug
"
|
"
Default
"
|
"
Send
"
|
"
Sync
"
|
"
Copy
"
|
"
Encodable
"
|
"
Decodable
"
=
>
{
continue
;
}
custom
if
custom
.
starts_with
(
"
PostExpansion_
"
)
=
>
{
continue
;
}
_
=
>
{
return
false
;
}
}
}
}
true
}
