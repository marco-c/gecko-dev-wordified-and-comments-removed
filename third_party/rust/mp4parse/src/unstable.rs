use
num_traits
:
:
{
CheckedAdd
CheckedSub
PrimInt
Zero
}
;
use
std
:
:
ops
:
:
{
Add
Neg
Sub
}
;
use
super
:
:
*
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Default
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
CheckedInteger
<
T
>
(
pub
T
)
;
impl
<
T
>
From
<
T
>
for
CheckedInteger
<
T
>
{
fn
from
(
i
:
T
)
-
>
Self
{
Self
(
i
)
}
}
impl
From
<
CheckedInteger
<
i64
>
>
for
i64
{
fn
from
(
checked
:
CheckedInteger
<
i64
>
)
-
>
i64
{
checked
.
0
}
}
impl
<
T
U
:
Into
<
T
>
>
Add
<
U
>
for
CheckedInteger
<
T
>
where
T
:
CheckedAdd
{
type
Output
=
Option
<
Self
>
;
fn
add
(
self
other
:
U
)
-
>
Self
:
:
Output
{
self
.
0
.
checked_add
(
&
other
.
into
(
)
)
.
map
(
Into
:
:
into
)
}
}
impl
<
T
U
:
Into
<
T
>
>
Sub
<
U
>
for
CheckedInteger
<
T
>
where
T
:
CheckedSub
{
type
Output
=
Option
<
Self
>
;
fn
sub
(
self
other
:
U
)
-
>
Self
:
:
Output
{
self
.
0
.
checked_sub
(
&
other
.
into
(
)
)
.
map
(
Into
:
:
into
)
}
}
impl
Sub
for
CheckedInteger
<
u64
>
{
type
Output
=
Option
<
CheckedInteger
<
i64
>
>
;
fn
sub
(
self
other
:
Self
)
-
>
Self
:
:
Output
{
if
self
>
=
other
{
self
.
0
.
checked_sub
(
other
.
0
)
.
and_then
(
|
u
|
i64
:
:
try_from
(
u
)
.
ok
(
)
)
.
map
(
CheckedInteger
)
}
else
{
other
.
0
.
checked_sub
(
self
.
0
)
.
and_then
(
|
u
|
i64
:
:
try_from
(
u
)
.
ok
(
)
)
.
map
(
i64
:
:
neg
)
.
map
(
CheckedInteger
)
}
}
}
#
[
test
]
fn
u64_subtraction_returning_i64
(
)
{
assert_eq
!
(
CheckedInteger
(
2u64
)
-
CheckedInteger
(
1u64
)
Some
(
CheckedInteger
(
1i64
)
)
)
;
assert_eq
!
(
CheckedInteger
(
1u64
)
-
CheckedInteger
(
1u64
)
Some
(
CheckedInteger
(
0i64
)
)
)
;
assert_eq
!
(
CheckedInteger
(
u64
:
:
MAX
)
-
CheckedInteger
(
1u64
)
None
)
;
assert_eq
!
(
CheckedInteger
(
1u64
)
-
CheckedInteger
(
2u64
)
Some
(
CheckedInteger
(
-
1i64
)
)
)
;
assert_eq
!
(
CheckedInteger
(
1u64
)
-
CheckedInteger
(
u64
:
:
MAX
)
None
)
;
}
impl
<
T
:
std
:
:
cmp
:
:
PartialEq
>
PartialEq
<
T
>
for
CheckedInteger
<
T
>
{
fn
eq
(
&
self
other
:
&
T
)
-
>
bool
{
self
.
0
=
=
*
other
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Default
Debug
PartialEq
Eq
)
]
pub
struct
Indice
{
pub
start_offset
:
CheckedInteger
<
u64
>
pub
end_offset
:
CheckedInteger
<
u64
>
pub
start_composition
:
CheckedInteger
<
i64
>
pub
end_composition
:
CheckedInteger
<
i64
>
pub
start_decode
:
CheckedInteger
<
i64
>
pub
sync
:
bool
}
#
[
allow
(
clippy
:
:
reversed_empty_ranges
)
]
pub
fn
create_sample_table
(
track
:
&
Track
track_offset_time
:
CheckedInteger
<
i64
>
)
-
>
Option
<
TryVec
<
Indice
>
>
{
let
(
stsc
stco
stsz
stts
)
=
match
(
&
track
.
stsc
&
track
.
stco
&
track
.
stsz
&
track
.
stts
)
{
(
Some
(
a
)
Some
(
b
)
Some
(
c
)
Some
(
d
)
)
=
>
(
a
b
c
d
)
_
=
>
return
None
}
;
let
has_sync_table
=
track
.
stss
.
is_some
(
)
;
let
mut
sample_size_iter
=
stsz
.
sample_sizes
.
iter
(
)
;
let
total_sample_count
=
sample_to_chunk_iter
(
&
stsc
.
samples
&
stco
.
offsets
)
.
map
(
|
(
_
sample_counts
)
|
sample_counts
.
to_usize
(
)
)
.
try_fold
(
0usize
usize
:
:
checked_add
)
?
;
let
mut
sample_table
=
TryVec
:
:
with_capacity
(
total_sample_count
)
.
ok
(
)
?
;
for
i
in
sample_to_chunk_iter
(
&
stsc
.
samples
&
stco
.
offsets
)
{
let
chunk_id
=
i
.
0
as
usize
;
let
sample_counts
=
i
.
1
;
let
mut
cur_position
=
match
stco
.
offsets
.
get
(
chunk_id
)
{
Some
(
&
i
)
=
>
i
.
into
(
)
_
=
>
return
None
}
;
for
_
in
0
.
.
sample_counts
{
let
start_offset
=
cur_position
;
let
end_offset
=
match
(
stsz
.
sample_size
sample_size_iter
.
next
(
)
)
{
(
_
Some
(
t
)
)
=
>
(
start_offset
+
*
t
)
?
(
t
_
)
if
t
>
0
=
>
(
start_offset
+
t
)
?
_
=
>
0
.
into
(
)
}
;
if
end_offset
=
=
0
{
return
None
;
}
cur_position
=
end_offset
;
sample_table
.
push
(
Indice
{
start_offset
end_offset
sync
:
!
has_sync_table
.
.
Default
:
:
default
(
)
}
)
.
ok
(
)
?
;
}
}
if
let
Some
(
ref
v
)
=
track
.
stss
{
for
iter
in
&
v
.
samples
{
match
iter
.
checked_sub
(
&
1
)
.
and_then
(
|
idx
|
sample_table
.
get_mut
(
idx
as
usize
)
)
{
Some
(
elem
)
=
>
elem
.
sync
=
true
_
=
>
return
None
}
}
}
let
ctts_iter
=
track
.
ctts
.
as_ref
(
)
.
map
(
|
v
|
v
.
samples
.
as_slice
(
)
.
iter
(
)
)
;
let
mut
ctts_offset_iter
=
TimeOffsetIterator
{
cur_sample_range
:
(
0
.
.
0
)
cur_offset
:
0
ctts_iter
track_id
:
track
.
id
}
;
let
mut
stts_iter
=
TimeToSampleIterator
{
cur_sample_count
:
(
0
.
.
0
)
cur_sample_delta
:
0
stts_iter
:
stts
.
samples
.
as_slice
(
)
.
iter
(
)
track_id
:
track
.
id
}
;
let
mut
sum_delta
=
TrackScaledTime
:
:
<
i64
>
(
0
track
.
id
)
;
for
sample
in
sample_table
.
as_mut_slice
(
)
{
let
decode_time
=
sum_delta
;
sum_delta
=
(
sum_delta
+
stts_iter
.
next_delta
(
)
)
?
;
let
ctts_offset
=
ctts_offset_iter
.
next_offset_time
(
)
;
let
start_composition
=
decode_time
+
ctts_offset
;
let
end_composition
=
sum_delta
+
ctts_offset
;
let
start_decode
=
decode_time
;
sample
.
start_composition
=
CheckedInteger
(
track_offset_time
.
0
+
start_composition
?
.
0
)
;
sample
.
end_composition
=
CheckedInteger
(
track_offset_time
.
0
+
end_composition
?
.
0
)
;
sample
.
start_decode
=
CheckedInteger
(
start_decode
.
0
)
;
}
if
!
sample_table
.
is_empty
(
)
{
let
mut
sort_table
=
TryVec
:
:
with_capacity
(
sample_table
.
len
(
)
)
.
ok
(
)
?
;
for
i
in
0
.
.
sample_table
.
len
(
)
{
sort_table
.
push
(
i
)
.
ok
(
)
?
;
}
sort_table
.
sort_by_key
(
|
i
|
match
sample_table
.
get
(
*
i
)
{
Some
(
v
)
=
>
v
.
start_composition
_
=
>
0
.
into
(
)
}
)
;
for
indices
in
sort_table
.
windows
(
2
)
{
if
let
[
current_index
peek_index
]
=
*
indices
{
let
next_start_composition_time
=
sample_table
[
peek_index
]
.
start_composition
;
let
sample
=
&
mut
sample_table
[
current_index
]
;
sample
.
end_composition
=
next_start_composition_time
;
}
}
}
Some
(
sample_table
)
}
struct
TimeOffsetIterator
<
'
a
>
{
cur_sample_range
:
std
:
:
ops
:
:
Range
<
u32
>
cur_offset
:
i64
ctts_iter
:
Option
<
std
:
:
slice
:
:
Iter
<
'
a
TimeOffset
>
>
track_id
:
usize
}
impl
<
'
a
>
Iterator
for
TimeOffsetIterator
<
'
a
>
{
type
Item
=
i64
;
#
[
allow
(
clippy
:
:
reversed_empty_ranges
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
i64
>
{
let
has_sample
=
self
.
cur_sample_range
.
next
(
)
.
or_else
(
|
|
{
let
iter
=
match
self
.
ctts_iter
{
Some
(
ref
mut
v
)
=
>
v
_
=
>
return
None
}
;
let
offset_version
;
self
.
cur_sample_range
=
match
iter
.
next
(
)
{
Some
(
v
)
=
>
{
offset_version
=
v
.
time_offset
;
0
.
.
v
.
sample_count
}
_
=
>
{
offset_version
=
TimeOffsetVersion
:
:
Version0
(
0
)
;
0
.
.
0
}
}
;
self
.
cur_offset
=
match
offset_version
{
TimeOffsetVersion
:
:
Version0
(
i
)
=
>
i64
:
:
from
(
i
)
TimeOffsetVersion
:
:
Version1
(
i
)
=
>
i64
:
:
from
(
i
)
}
;
self
.
cur_sample_range
.
next
(
)
}
)
;
has_sample
.
and
(
Some
(
self
.
cur_offset
)
)
}
}
impl
<
'
a
>
TimeOffsetIterator
<
'
a
>
{
fn
next_offset_time
(
&
mut
self
)
-
>
TrackScaledTime
<
i64
>
{
match
self
.
next
(
)
{
Some
(
v
)
=
>
TrackScaledTime
:
:
<
i64
>
(
v
self
.
track_id
)
_
=
>
TrackScaledTime
:
:
<
i64
>
(
0
self
.
track_id
)
}
}
}
struct
TimeToSampleIterator
<
'
a
>
{
cur_sample_count
:
std
:
:
ops
:
:
Range
<
u32
>
cur_sample_delta
:
u32
stts_iter
:
std
:
:
slice
:
:
Iter
<
'
a
Sample
>
track_id
:
usize
}
impl
<
'
a
>
Iterator
for
TimeToSampleIterator
<
'
a
>
{
type
Item
=
u32
;
#
[
allow
(
clippy
:
:
reversed_empty_ranges
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
u32
>
{
let
has_sample
=
self
.
cur_sample_count
.
next
(
)
.
or_else
(
|
|
{
self
.
cur_sample_count
=
match
self
.
stts_iter
.
next
(
)
{
Some
(
v
)
=
>
{
self
.
cur_sample_delta
=
v
.
sample_delta
;
0
.
.
v
.
sample_count
}
_
=
>
0
.
.
0
}
;
self
.
cur_sample_count
.
next
(
)
}
)
;
has_sample
.
and
(
Some
(
self
.
cur_sample_delta
)
)
}
}
impl
<
'
a
>
TimeToSampleIterator
<
'
a
>
{
fn
next_delta
(
&
mut
self
)
-
>
TrackScaledTime
<
i64
>
{
match
self
.
next
(
)
{
Some
(
v
)
=
>
TrackScaledTime
:
:
<
i64
>
(
i64
:
:
from
(
v
)
self
.
track_id
)
_
=
>
TrackScaledTime
:
:
<
i64
>
(
0
self
.
track_id
)
}
}
}
fn
sample_to_chunk_iter
<
'
a
>
(
stsc_samples
:
&
'
a
TryVec
<
SampleToChunk
>
stco_offsets
:
&
'
a
TryVec
<
u64
>
)
-
>
SampleToChunkIterator
<
'
a
>
{
SampleToChunkIterator
{
chunks
:
(
0
.
.
0
)
sample_count
:
0
stsc_peek_iter
:
stsc_samples
.
as_slice
(
)
.
iter
(
)
.
peekable
(
)
remain_chunk_count
:
stco_offsets
.
len
(
)
.
try_into
(
)
.
expect
(
"
stco
.
entry_count
is
u32
"
)
}
}
struct
SampleToChunkIterator
<
'
a
>
{
chunks
:
std
:
:
ops
:
:
Range
<
u32
>
sample_count
:
u32
stsc_peek_iter
:
std
:
:
iter
:
:
Peekable
<
std
:
:
slice
:
:
Iter
<
'
a
SampleToChunk
>
>
remain_chunk_count
:
u32
}
impl
<
'
a
>
Iterator
for
SampleToChunkIterator
<
'
a
>
{
type
Item
=
(
u32
u32
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
(
u32
u32
)
>
{
let
has_chunk
=
self
.
chunks
.
next
(
)
.
or_else
(
|
|
{
self
.
chunks
=
self
.
locate
(
)
;
self
.
remain_chunk_count
.
checked_sub
(
self
.
chunks
.
len
(
)
.
try_into
(
)
.
expect
(
"
len
(
)
of
a
Range
<
u32
>
must
fit
in
u32
"
)
)
.
and_then
(
|
res
|
{
self
.
remain_chunk_count
=
res
;
self
.
chunks
.
next
(
)
}
)
}
)
;
has_chunk
.
map
(
|
id
|
(
id
self
.
sample_count
)
)
}
}
impl
<
'
a
>
SampleToChunkIterator
<
'
a
>
{
#
[
allow
(
clippy
:
:
reversed_empty_ranges
)
]
fn
locate
(
&
mut
self
)
-
>
std
:
:
ops
:
:
Range
<
u32
>
{
loop
{
return
match
(
self
.
stsc_peek_iter
.
next
(
)
self
.
stsc_peek_iter
.
peek
(
)
)
{
(
Some
(
next
)
Some
(
peek
)
)
if
next
.
first_chunk
=
=
peek
.
first_chunk
=
>
{
continue
;
}
(
Some
(
next
)
Some
(
peek
)
)
if
next
.
first_chunk
>
0
&
&
peek
.
first_chunk
>
0
=
>
{
self
.
sample_count
=
next
.
samples_per_chunk
;
(
next
.
first_chunk
-
1
)
.
.
(
peek
.
first_chunk
-
1
)
}
(
Some
(
next
)
None
)
if
next
.
first_chunk
>
0
=
>
{
self
.
sample_count
=
next
.
samples_per_chunk
;
match
next
.
first_chunk
.
checked_add
(
self
.
remain_chunk_count
)
{
Some
(
r
)
=
>
(
next
.
first_chunk
-
1
)
.
.
r
-
1
_
=
>
0
.
.
0
}
}
_
=
>
0
.
.
0
}
;
}
}
}
pub
fn
rational_scale
<
T
S
>
(
numerator
:
T
denominator
:
T
scale2
:
S
)
-
>
Option
<
T
>
where
T
:
PrimInt
+
Zero
S
:
PrimInt
{
if
denominator
.
is_zero
(
)
{
return
None
;
}
let
integer
=
numerator
/
denominator
;
let
remainder
=
numerator
%
denominator
;
num_traits
:
:
cast
(
scale2
)
.
and_then
(
|
s
|
match
integer
.
checked_mul
(
&
s
)
{
Some
(
integer
)
=
>
remainder
.
checked_mul
(
&
s
)
.
and_then
(
|
remainder
|
(
remainder
/
denominator
)
.
checked_add
(
&
integer
)
)
None
=
>
None
}
)
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
Microseconds
<
T
>
(
pub
T
)
;
pub
fn
media_time_to_us
(
time
:
MediaScaledTime
scale
:
MediaTimeScale
)
-
>
Option
<
Microseconds
<
u64
>
>
{
let
microseconds_per_second
=
1_000_000
;
rational_scale
(
time
.
0
scale
.
0
microseconds_per_second
)
.
map
(
Microseconds
)
}
pub
fn
track_time_to_us
<
T
>
(
time
:
TrackScaledTime
<
T
>
scale
:
TrackTimeScale
<
T
>
)
-
>
Option
<
Microseconds
<
T
>
>
where
T
:
PrimInt
+
Zero
{
assert_eq
!
(
time
.
1
scale
.
1
)
;
let
microseconds_per_second
=
1_000_000
;
rational_scale
(
time
.
0
scale
.
0
microseconds_per_second
)
.
map
(
Microseconds
)
}
#
[
test
]
fn
rational_scale_overflow
(
)
{
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
17
3
1000
)
Some
(
5666
)
)
;
let
large
=
0x4000_0000_0000_0000
;
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
large
2
2
)
Some
(
large
)
)
;
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
large
4
4
)
Some
(
large
)
)
;
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
large
2
8
)
None
)
;
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
large
8
4
)
Some
(
large
/
2
)
)
;
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
large
+
1
4
4
)
Some
(
large
+
1
)
)
;
assert_eq
!
(
rational_scale
:
:
<
u64
u64
>
(
large
40
1000
)
None
)
;
}
#
[
test
]
fn
media_time_overflow
(
)
{
let
scale
=
MediaTimeScale
(
90000
)
;
let
duration
=
MediaScaledTime
(
9_007_199_254_710_000
)
;
assert_eq
!
(
media_time_to_us
(
duration
scale
)
Some
(
Microseconds
(
100_079_991_719_000_000u64
)
)
)
;
}
#
[
test
]
fn
track_time_overflow
(
)
{
let
scale
=
TrackTimeScale
(
44100u64
0
)
;
let
duration
=
TrackScaledTime
(
4_413_527_634_807_900u64
0
)
;
assert_eq
!
(
track_time_to_us
(
duration
scale
)
Some
(
Microseconds
(
100_079_991_719_000_000u64
)
)
)
;
}
