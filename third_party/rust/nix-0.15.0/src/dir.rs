use
{
Error
NixPath
Result
}
;
use
errno
:
:
Errno
;
use
fcntl
:
:
{
self
OFlag
}
;
use
libc
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
IntoRawFd
RawFd
}
;
use
std
:
:
{
ffi
ptr
}
;
use
sys
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
libc
:
:
{
dirent64
as
dirent
readdir64_r
as
readdir_r
}
;
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
use
libc
:
:
{
dirent
readdir_r
}
;
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Dir
(
ptr
:
:
NonNull
<
libc
:
:
DIR
>
)
;
impl
Dir
{
pub
fn
open
<
P
:
?
Sized
+
NixPath
>
(
path
:
&
P
oflag
:
OFlag
mode
:
sys
:
:
stat
:
:
Mode
)
-
>
Result
<
Self
>
{
let
fd
=
fcntl
:
:
open
(
path
oflag
mode
)
?
;
Dir
:
:
from_fd
(
fd
)
}
pub
fn
openat
<
P
:
?
Sized
+
NixPath
>
(
dirfd
:
RawFd
path
:
&
P
oflag
:
OFlag
mode
:
sys
:
:
stat
:
:
Mode
)
-
>
Result
<
Self
>
{
let
fd
=
fcntl
:
:
openat
(
dirfd
path
oflag
mode
)
?
;
Dir
:
:
from_fd
(
fd
)
}
#
[
inline
]
pub
fn
from
<
F
:
IntoRawFd
>
(
fd
:
F
)
-
>
Result
<
Self
>
{
Dir
:
:
from_fd
(
fd
.
into_raw_fd
(
)
)
}
pub
fn
from_fd
(
fd
:
RawFd
)
-
>
Result
<
Self
>
{
let
d
=
unsafe
{
libc
:
:
fdopendir
(
fd
)
}
;
if
d
.
is_null
(
)
{
let
e
=
Error
:
:
last
(
)
;
unsafe
{
libc
:
:
close
(
fd
)
}
;
return
Err
(
e
)
;
}
;
Ok
(
Dir
(
ptr
:
:
NonNull
:
:
new
(
d
)
.
unwrap
(
)
)
)
}
pub
fn
iter
(
&
mut
self
)
-
>
Iter
{
Iter
(
self
)
}
}
unsafe
impl
Send
for
Dir
{
}
impl
AsRawFd
for
Dir
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
unsafe
{
libc
:
:
dirfd
(
self
.
0
.
as_ptr
(
)
)
}
}
}
impl
Drop
for
Dir
{
fn
drop
(
&
mut
self
)
{
unsafe
{
libc
:
:
closedir
(
self
.
0
.
as_ptr
(
)
)
}
;
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Iter
<
'
d
>
(
&
'
d
mut
Dir
)
;
impl
<
'
d
>
Iterator
for
Iter
<
'
d
>
{
type
Item
=
Result
<
Entry
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
unsafe
{
let
mut
ent
:
Entry
=
Entry
(
:
:
std
:
:
mem
:
:
uninitialized
(
)
)
;
let
mut
result
=
ptr
:
:
null_mut
(
)
;
if
let
Err
(
e
)
=
Errno
:
:
result
(
readdir_r
(
(
self
.
0
)
.
0
.
as_ptr
(
)
&
mut
ent
.
0
&
mut
result
)
)
{
return
Some
(
Err
(
e
)
)
;
}
if
result
=
=
ptr
:
:
null_mut
(
)
{
return
None
;
}
assert_eq
!
(
result
&
mut
ent
.
0
as
*
mut
dirent
)
;
return
Some
(
Ok
(
ent
)
)
;
}
}
}
impl
<
'
d
>
Drop
for
Iter
<
'
d
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
libc
:
:
rewinddir
(
(
self
.
0
)
.
0
.
as_ptr
(
)
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Entry
(
dirent
)
;
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Type
{
Fifo
CharacterDevice
Directory
BlockDevice
File
Symlink
Socket
}
impl
Entry
{
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
haiku
"
target_os
=
"
ios
"
target_os
=
"
l4re
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
solaris
"
)
)
]
pub
fn
ino
(
&
self
)
-
>
u64
{
self
.
0
.
d_ino
as
u64
}
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
haiku
"
target_os
=
"
ios
"
target_os
=
"
l4re
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
solaris
"
)
)
)
]
pub
fn
ino
(
&
self
)
-
>
u64
{
self
.
0
.
d_fileno
as
u64
}
pub
fn
file_name
(
&
self
)
-
>
&
ffi
:
:
CStr
{
unsafe
{
:
:
std
:
:
ffi
:
:
CStr
:
:
from_ptr
(
self
.
0
.
d_name
.
as_ptr
(
)
)
}
}
pub
fn
file_type
(
&
self
)
-
>
Option
<
Type
>
{
match
self
.
0
.
d_type
{
libc
:
:
DT_FIFO
=
>
Some
(
Type
:
:
Fifo
)
libc
:
:
DT_CHR
=
>
Some
(
Type
:
:
CharacterDevice
)
libc
:
:
DT_DIR
=
>
Some
(
Type
:
:
Directory
)
libc
:
:
DT_BLK
=
>
Some
(
Type
:
:
BlockDevice
)
libc
:
:
DT_REG
=
>
Some
(
Type
:
:
File
)
libc
:
:
DT_LNK
=
>
Some
(
Type
:
:
Symlink
)
libc
:
:
DT_SOCK
=
>
Some
(
Type
:
:
Socket
)
_
=
>
None
}
}
}
