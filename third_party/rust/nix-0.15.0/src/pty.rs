use
libc
;
pub
use
libc
:
:
pid_t
as
SessionId
;
pub
use
libc
:
:
winsize
as
Winsize
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
mem
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
sys
:
:
termios
:
:
Termios
;
use
unistd
:
:
ForkResult
;
use
{
Result
Error
fcntl
}
;
use
errno
:
:
Errno
;
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
struct
OpenptyResult
{
pub
master
:
RawFd
pub
slave
:
RawFd
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ForkptyResult
{
pub
master
:
RawFd
pub
fork_result
:
ForkResult
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
PtyMaster
(
RawFd
)
;
impl
AsRawFd
for
PtyMaster
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
0
}
}
impl
IntoRawFd
for
PtyMaster
{
fn
into_raw_fd
(
self
)
-
>
RawFd
{
let
fd
=
self
.
0
;
mem
:
:
forget
(
self
)
;
fd
}
}
impl
Drop
for
PtyMaster
{
fn
drop
(
&
mut
self
)
{
let
e
=
:
:
unistd
:
:
close
(
self
.
0
)
;
if
e
=
=
Err
(
Error
:
:
Sys
(
Errno
:
:
EBADF
)
)
{
panic
!
(
"
Closing
an
invalid
file
descriptor
!
"
)
;
}
;
}
}
#
[
inline
]
pub
fn
grantpt
(
fd
:
&
PtyMaster
)
-
>
Result
<
(
)
>
{
if
unsafe
{
libc
:
:
grantpt
(
fd
.
as_raw_fd
(
)
)
}
<
0
{
return
Err
(
Error
:
:
last
(
)
)
;
}
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
posix_openpt
(
flags
:
fcntl
:
:
OFlag
)
-
>
Result
<
PtyMaster
>
{
let
fd
=
unsafe
{
libc
:
:
posix_openpt
(
flags
.
bits
(
)
)
}
;
if
fd
<
0
{
return
Err
(
Error
:
:
last
(
)
)
;
}
Ok
(
PtyMaster
(
fd
)
)
}
#
[
inline
]
pub
unsafe
fn
ptsname
(
fd
:
&
PtyMaster
)
-
>
Result
<
String
>
{
let
name_ptr
=
libc
:
:
ptsname
(
fd
.
as_raw_fd
(
)
)
;
if
name_ptr
.
is_null
(
)
{
return
Err
(
Error
:
:
last
(
)
)
;
}
let
name
=
CStr
:
:
from_ptr
(
name_ptr
)
;
Ok
(
name
.
to_string_lossy
(
)
.
into_owned
(
)
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
#
[
inline
]
pub
fn
ptsname_r
(
fd
:
&
PtyMaster
)
-
>
Result
<
String
>
{
let
mut
name_buf
=
vec
!
[
0u8
;
64
]
;
let
name_buf_ptr
=
name_buf
.
as_mut_ptr
(
)
as
*
mut
libc
:
:
c_char
;
if
unsafe
{
libc
:
:
ptsname_r
(
fd
.
as_raw_fd
(
)
name_buf_ptr
name_buf
.
capacity
(
)
)
}
!
=
0
{
return
Err
(
Error
:
:
last
(
)
)
;
}
let
null_index
=
name_buf
.
iter
(
)
.
position
(
|
c
|
*
c
=
=
b
'
\
0
'
)
.
unwrap
(
)
;
name_buf
.
truncate
(
null_index
)
;
let
name
=
String
:
:
from_utf8
(
name_buf
)
?
;
Ok
(
name
)
}
#
[
inline
]
pub
fn
unlockpt
(
fd
:
&
PtyMaster
)
-
>
Result
<
(
)
>
{
if
unsafe
{
libc
:
:
unlockpt
(
fd
.
as_raw_fd
(
)
)
}
<
0
{
return
Err
(
Error
:
:
last
(
)
)
;
}
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
openpty
<
'
a
'
b
T
:
Into
<
Option
<
&
'
a
Winsize
>
>
U
:
Into
<
Option
<
&
'
b
Termios
>
>
>
(
winsize
:
T
termios
:
U
)
-
>
Result
<
OpenptyResult
>
{
use
std
:
:
ptr
;
let
mut
slave
:
libc
:
:
c_int
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
let
mut
master
:
libc
:
:
c_int
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
let
ret
=
{
match
(
termios
.
into
(
)
winsize
.
into
(
)
)
{
(
Some
(
termios
)
Some
(
winsize
)
)
=
>
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
unsafe
{
libc
:
:
openpty
(
&
mut
master
&
mut
slave
ptr
:
:
null_mut
(
)
&
*
inner_termios
as
*
const
libc
:
:
termios
as
*
mut
_
winsize
as
*
const
Winsize
as
*
mut
_
)
}
}
(
None
Some
(
winsize
)
)
=
>
{
unsafe
{
libc
:
:
openpty
(
&
mut
master
&
mut
slave
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
winsize
as
*
const
Winsize
as
*
mut
_
)
}
}
(
Some
(
termios
)
None
)
=
>
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
unsafe
{
libc
:
:
openpty
(
&
mut
master
&
mut
slave
ptr
:
:
null_mut
(
)
&
*
inner_termios
as
*
const
libc
:
:
termios
as
*
mut
_
ptr
:
:
null_mut
(
)
)
}
}
(
None
None
)
=
>
{
unsafe
{
libc
:
:
openpty
(
&
mut
master
&
mut
slave
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
)
}
}
}
}
;
Errno
:
:
result
(
ret
)
?
;
Ok
(
OpenptyResult
{
master
:
master
slave
:
slave
}
)
}
pub
fn
forkpty
<
'
a
'
b
T
:
Into
<
Option
<
&
'
a
Winsize
>
>
U
:
Into
<
Option
<
&
'
b
Termios
>
>
>
(
winsize
:
T
termios
:
U
)
-
>
Result
<
ForkptyResult
>
{
use
std
:
:
ptr
;
use
unistd
:
:
Pid
;
use
unistd
:
:
ForkResult
:
:
*
;
let
mut
master
:
libc
:
:
c_int
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
let
term
=
match
termios
.
into
(
)
{
Some
(
termios
)
=
>
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
&
*
inner_termios
as
*
const
libc
:
:
termios
as
*
mut
_
}
None
=
>
ptr
:
:
null_mut
(
)
}
;
let
win
=
winsize
.
into
(
)
.
map
(
|
ws
|
ws
as
*
const
Winsize
as
*
mut
_
)
.
unwrap_or
(
ptr
:
:
null_mut
(
)
)
;
let
res
=
unsafe
{
libc
:
:
forkpty
(
&
mut
master
ptr
:
:
null_mut
(
)
term
win
)
}
;
let
fork_result
=
Errno
:
:
result
(
res
)
.
map
(
|
res
|
match
res
{
0
=
>
Child
res
=
>
Parent
{
child
:
Pid
:
:
from_raw
(
res
)
}
}
)
?
;
Ok
(
ForkptyResult
{
master
:
master
fork_result
:
fork_result
}
)
}
