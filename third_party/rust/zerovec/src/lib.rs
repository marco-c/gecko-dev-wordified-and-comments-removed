#
!
[
cfg_attr
(
not
(
any
(
test
doc
)
)
no_std
)
]
#
!
[
cfg_attr
(
not
(
test
)
deny
(
clippy
:
:
indexing_slicing
clippy
:
:
unwrap_used
clippy
:
:
expect_used
clippy
:
:
panic
clippy
:
:
exhaustive_structs
clippy
:
:
exhaustive_enums
clippy
:
:
trivially_copy_pass_by_ref
missing_debug_implementations
)
)
]
#
!
[
allow
(
clippy
:
:
needless_lifetimes
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
mod
cow
;
#
[
cfg
(
feature
=
"
hashmap
"
)
]
pub
mod
hashmap
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
map
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
map2d
;
#
[
cfg
(
test
)
]
pub
mod
samples
;
mod
varzerovec
;
mod
zerovec
;
pub
mod
ule
;
#
[
cfg
(
feature
=
"
yoke
"
)
]
mod
yoke_impls
;
mod
zerofrom_impls
;
pub
use
crate
:
:
cow
:
:
VarZeroCow
;
#
[
cfg
(
feature
=
"
hashmap
"
)
]
pub
use
crate
:
:
hashmap
:
:
ZeroHashMap
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
crate
:
:
map
:
:
map
:
:
ZeroMap
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
crate
:
:
map2d
:
:
map
:
:
ZeroMap2d
;
pub
use
crate
:
:
varzerovec
:
:
{
slice
:
:
VarZeroSlice
vec
:
:
VarZeroVec
}
;
pub
use
crate
:
:
zerovec
:
:
{
ZeroSlice
ZeroVec
}
;
#
[
doc
(
hidden
)
]
pub
mod
__zerovec_internal_reexport
{
pub
use
zerofrom
:
:
ZeroFrom
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
alloc
:
:
borrow
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
alloc
:
:
boxed
;
#
[
cfg
(
feature
=
"
serde
"
)
]
pub
use
serde
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
mod
maps
{
#
[
doc
(
no_inline
)
]
pub
use
crate
:
:
map
:
:
ZeroMap
;
pub
use
crate
:
:
map
:
:
ZeroMapBorrowed
;
#
[
doc
(
no_inline
)
]
pub
use
crate
:
:
map2d
:
:
ZeroMap2d
;
pub
use
crate
:
:
map2d
:
:
ZeroMap2dBorrowed
;
pub
use
crate
:
:
map
:
:
{
MutableZeroVecLike
ZeroMapKV
ZeroVecLike
}
;
pub
use
crate
:
:
map2d
:
:
ZeroMap2dCursor
;
}
pub
mod
vecs
{
#
[
doc
(
no_inline
)
]
pub
use
crate
:
:
zerovec
:
:
{
ZeroSlice
ZeroVec
}
;
pub
use
crate
:
:
zerovec
:
:
ZeroSliceIter
;
#
[
doc
(
no_inline
)
]
pub
use
crate
:
:
varzerovec
:
:
{
VarZeroSlice
VarZeroVec
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
crate
:
:
varzerovec
:
:
VarZeroVecOwned
;
pub
use
crate
:
:
varzerovec
:
:
{
Index16
Index32
Index8
VarZeroSliceIter
VarZeroVecFormat
}
;
pub
type
VarZeroVec16
<
'
a
T
>
=
VarZeroVec
<
'
a
T
Index16
>
;
pub
type
VarZeroVec32
<
'
a
T
>
=
VarZeroVec
<
'
a
T
Index32
>
;
pub
type
VarZeroSlice16
<
T
>
=
VarZeroSlice
<
T
Index16
>
;
pub
type
VarZeroSlice32
<
T
>
=
VarZeroSlice
<
T
Index32
>
;
}
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
zerovec_derive
:
:
make_ule
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
zerovec_derive
:
:
make_varule
;
#
[
cfg
(
test
)
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
mod
tests
{
use
super
:
:
*
;
use
core
:
:
mem
:
:
size_of
;
macro_rules
!
check_size_of
{
(
sizes
:
pat
type
:
path
)
=
>
{
assert
!
(
matches
!
(
size_of
:
:
<
type
>
(
)
sizes
)
concat
!
(
stringify
!
(
type
)
"
is
of
size
{
}
"
)
size_of
:
:
<
type
>
(
)
)
;
}
;
}
#
[
test
]
fn
check_sizes
(
)
{
check_size_of
!
(
24
ZeroVec
<
u8
>
)
;
check_size_of
!
(
24
ZeroVec
<
u32
>
)
;
check_size_of
!
(
32
|
24
VarZeroVec
<
[
u8
]
>
)
;
check_size_of
!
(
32
|
24
VarZeroVec
<
str
>
)
;
check_size_of
!
(
48
ZeroMap
<
u32
u32
>
)
;
check_size_of
!
(
56
|
48
ZeroMap
<
u32
str
>
)
;
check_size_of
!
(
56
|
48
ZeroMap
<
str
u32
>
)
;
check_size_of
!
(
64
|
48
ZeroMap
<
str
str
>
)
;
check_size_of
!
(
120
|
96
ZeroMap2d
<
str
str
str
>
)
;
check_size_of
!
(
24
Option
<
ZeroVec
<
u8
>
>
)
;
check_size_of
!
(
32
|
24
Option
<
VarZeroVec
<
str
>
>
)
;
check_size_of
!
(
64
|
56
|
48
Option
<
ZeroMap
<
str
str
>
>
)
;
check_size_of
!
(
120
|
104
|
96
Option
<
ZeroMap2d
<
str
str
str
>
>
)
;
}
}
