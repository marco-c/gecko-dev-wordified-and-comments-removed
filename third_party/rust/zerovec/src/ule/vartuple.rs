use
core
:
:
mem
:
:
{
size_of
transmute_copy
}
;
use
zerofrom
:
:
ZeroFrom
;
use
super
:
:
{
AsULE
EncodeAsVarULE
UleError
VarULE
ULE
}
;
#
[
derive
(
Debug
PartialEq
Eq
PartialOrd
Ord
Clone
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
VarTuple
<
A
B
>
{
pub
sized
:
A
pub
variable
:
B
}
#
[
derive
(
Debug
PartialEq
Eq
PartialOrd
Ord
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
#
[
repr
(
C
)
]
pub
struct
VarTupleULE
<
A
:
AsULE
V
:
VarULE
+
?
Sized
>
{
pub
sized
:
A
:
:
ULE
pub
variable
:
V
}
unsafe
impl
<
A
V
>
VarULE
for
VarTupleULE
<
A
V
>
where
A
:
AsULE
+
'
static
V
:
VarULE
+
?
Sized
{
fn
validate_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
UleError
>
{
let
(
sized_chunk
variable_chunk
)
=
bytes
.
split_at_checked
(
size_of
:
:
<
A
:
:
ULE
>
(
)
)
.
ok_or
(
UleError
:
:
length
:
:
<
Self
>
(
bytes
.
len
(
)
)
)
?
;
A
:
:
ULE
:
:
validate_bytes
(
sized_chunk
)
?
;
V
:
:
validate_bytes
(
variable_chunk
)
?
;
Ok
(
(
)
)
}
unsafe
fn
from_bytes_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
Self
{
let
(
_sized_chunk
variable_chunk
)
=
bytes
.
split_at_unchecked
(
size_of
:
:
<
A
:
:
ULE
>
(
)
)
;
let
variable_ref
=
V
:
:
from_bytes_unchecked
(
variable_chunk
)
;
let
variable_ptr
:
*
const
V
=
variable_ref
;
assert_eq
!
(
size_of
:
:
<
*
const
V
>
(
)
size_of
:
:
<
(
*
const
u8
usize
)
>
(
)
)
;
let
(
_v_ptr
metadata
)
=
transmute_copy
:
:
<
*
const
V
(
*
const
u8
usize
)
>
(
&
variable_ptr
)
;
assert_eq
!
(
size_of
:
:
<
*
const
Self
>
(
)
size_of
:
:
<
(
*
const
u8
usize
)
>
(
)
)
;
let
composed_ptr
=
transmute_copy
:
:
<
(
*
const
u8
usize
)
*
const
Self
>
(
&
(
bytes
.
as_ptr
(
)
metadata
)
)
;
&
*
(
composed_ptr
)
}
}
unsafe
impl
<
A
B
V
>
EncodeAsVarULE
<
VarTupleULE
<
A
V
>
>
for
VarTuple
<
A
B
>
where
A
:
AsULE
+
'
static
B
:
EncodeAsVarULE
<
V
>
V
:
VarULE
+
?
Sized
{
fn
encode_var_ule_as_slices
<
R
>
(
&
self
_
:
impl
FnOnce
(
&
[
&
[
u8
]
]
)
-
>
R
)
-
>
R
{
unreachable
!
(
)
}
#
[
inline
]
fn
encode_var_ule_len
(
&
self
)
-
>
usize
{
size_of
:
:
<
A
:
:
ULE
>
(
)
+
self
.
variable
.
encode_var_ule_len
(
)
}
#
[
inline
]
fn
encode_var_ule_write
(
&
self
dst
:
&
mut
[
u8
]
)
{
let
(
sized_chunk
variable_chunk
)
=
dst
.
split_at_mut
(
size_of
:
:
<
A
:
:
ULE
>
(
)
)
;
sized_chunk
.
clone_from_slice
(
[
self
.
sized
.
to_unaligned
(
)
]
.
as_bytes
(
)
)
;
self
.
variable
.
encode_var_ule_write
(
variable_chunk
)
;
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
A
V
>
alloc
:
:
borrow
:
:
ToOwned
for
VarTupleULE
<
A
V
>
where
A
:
AsULE
+
'
static
V
:
VarULE
+
?
Sized
{
type
Owned
=
alloc
:
:
boxed
:
:
Box
<
Self
>
;
fn
to_owned
(
&
self
)
-
>
Self
:
:
Owned
{
crate
:
:
ule
:
:
encode_varule_to_box
(
self
)
}
}
impl
<
'
a
A
B
V
>
ZeroFrom
<
'
a
VarTupleULE
<
A
V
>
>
for
VarTuple
<
A
B
>
where
A
:
AsULE
+
'
static
V
:
VarULE
+
?
Sized
B
:
ZeroFrom
<
'
a
V
>
{
fn
zero_from
(
other
:
&
'
a
VarTupleULE
<
A
V
>
)
-
>
Self
{
VarTuple
{
sized
:
AsULE
:
:
from_unaligned
(
other
.
sized
)
variable
:
B
:
:
zero_from
(
&
other
.
variable
)
}
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
A
V
>
serde
:
:
Serialize
for
VarTupleULE
<
A
V
>
where
A
:
AsULE
+
'
static
V
:
VarULE
+
?
Sized
A
:
serde
:
:
Serialize
V
:
serde
:
:
Serialize
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
if
serializer
.
is_human_readable
(
)
{
let
this
=
VarTuple
{
sized
:
A
:
:
from_unaligned
(
self
.
sized
)
variable
:
&
self
.
variable
}
;
this
.
serialize
(
serializer
)
}
else
{
serializer
.
serialize_bytes
(
self
.
as_bytes
(
)
)
}
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
a
'
de
:
'
a
A
V
>
serde
:
:
Deserialize
<
'
de
>
for
&
'
a
VarTupleULE
<
A
V
>
where
A
:
AsULE
+
'
static
V
:
VarULE
+
?
Sized
A
:
serde
:
:
Deserialize
<
'
de
>
{
fn
deserialize
<
Des
>
(
deserializer
:
Des
)
-
>
Result
<
Self
Des
:
:
Error
>
where
Des
:
serde
:
:
Deserializer
<
'
de
>
{
if
!
deserializer
.
is_human_readable
(
)
{
let
bytes
=
<
&
[
u8
]
>
:
:
deserialize
(
deserializer
)
?
;
VarTupleULE
:
:
<
A
V
>
:
:
parse_bytes
(
bytes
)
.
map_err
(
serde
:
:
de
:
:
Error
:
:
custom
)
}
else
{
Err
(
serde
:
:
de
:
:
Error
:
:
custom
(
"
&
VarTupleULE
can
only
deserialize
in
zero
-
copy
ways
"
)
)
}
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
A
V
>
serde
:
:
Deserialize
<
'
de
>
for
alloc
:
:
boxed
:
:
Box
<
VarTupleULE
<
A
V
>
>
where
A
:
AsULE
+
'
static
V
:
VarULE
+
?
Sized
A
:
serde
:
:
Deserialize
<
'
de
>
alloc
:
:
boxed
:
:
Box
<
V
>
:
serde
:
:
Deserialize
<
'
de
>
{
fn
deserialize
<
Des
>
(
deserializer
:
Des
)
-
>
Result
<
Self
Des
:
:
Error
>
where
Des
:
serde
:
:
Deserializer
<
'
de
>
{
if
deserializer
.
is_human_readable
(
)
{
let
this
=
VarTuple
:
:
<
A
alloc
:
:
boxed
:
:
Box
<
V
>
>
:
:
deserialize
(
deserializer
)
?
;
Ok
(
crate
:
:
ule
:
:
encode_varule_to_box
(
&
this
)
)
}
else
{
let
deserialized
=
<
&
VarTupleULE
<
A
V
>
>
:
:
deserialize
(
deserializer
)
?
;
Ok
(
deserialized
.
to_boxed
(
)
)
}
}
}
#
[
test
]
fn
test_simple
(
)
{
let
var_tuple
=
VarTuple
{
sized
:
1500u16
variable
:
"
hello
"
}
;
let
var_tuple_ule
=
super
:
:
encode_varule_to_box
(
&
var_tuple
)
;
assert_eq
!
(
var_tuple_ule
.
sized
.
as_unsigned_int
(
)
1500
)
;
assert_eq
!
(
&
var_tuple_ule
.
variable
"
hello
"
)
;
#
[
cfg
(
feature
=
"
serde
"
)
]
crate
:
:
ule
:
:
test_utils
:
:
assert_serde_roundtrips
:
:
<
VarTupleULE
<
u16
str
>
>
(
&
var_tuple_ule
)
;
}
#
[
test
]
fn
test_nested
(
)
{
use
crate
:
:
{
ZeroSlice
ZeroVec
}
;
let
var_tuple
=
VarTuple
{
sized
:
2000u16
variable
:
VarTuple
{
sized
:
'
'
variable
:
ZeroVec
:
:
alloc_from_slice
(
b
"
ICU
"
)
}
}
;
let
var_tuple_ule
=
super
:
:
encode_varule_to_box
(
&
var_tuple
)
;
assert_eq
!
(
var_tuple_ule
.
sized
.
as_unsigned_int
(
)
2000u16
)
;
assert_eq
!
(
var_tuple_ule
.
variable
.
sized
.
to_char
(
)
'
'
)
;
assert_eq
!
(
&
var_tuple_ule
.
variable
.
variable
ZeroSlice
:
:
from_ule_slice
(
b
"
ICU
"
)
)
;
#
[
cfg
(
feature
=
"
serde
"
)
]
crate
:
:
ule
:
:
test_utils
:
:
assert_serde_roundtrips
:
:
<
VarTupleULE
<
u16
VarTupleULE
<
char
ZeroSlice
<
_
>
>
>
>
(
&
var_tuple_ule
)
;
}
