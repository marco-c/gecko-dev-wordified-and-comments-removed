use
crate
:
:
ule
:
:
*
;
use
core
:
:
str
;
unsafe
impl
<
T
:
ULE
const
N
:
usize
>
ULE
for
[
T
;
N
]
{
#
[
inline
]
fn
validate_byte_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
ZeroVecError
>
{
T
:
:
validate_byte_slice
(
bytes
)
}
}
impl
<
T
:
AsULE
const
N
:
usize
>
AsULE
for
[
T
;
N
]
{
type
ULE
=
[
T
:
:
ULE
;
N
]
;
#
[
inline
]
fn
to_unaligned
(
self
)
-
>
Self
:
:
ULE
{
self
.
map
(
T
:
:
to_unaligned
)
}
#
[
inline
]
fn
from_unaligned
(
unaligned
:
Self
:
:
ULE
)
-
>
Self
{
unaligned
.
map
(
T
:
:
from_unaligned
)
}
}
unsafe
impl
<
T
:
EqULE
const
N
:
usize
>
EqULE
for
[
T
;
N
]
{
}
unsafe
impl
VarULE
for
str
{
#
[
inline
]
fn
validate_byte_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
ZeroVecError
>
{
str
:
:
from_utf8
(
bytes
)
.
map_err
(
|
_
|
ZeroVecError
:
:
parse
:
:
<
Self
>
(
)
)
?
;
Ok
(
(
)
)
}
#
[
inline
]
fn
parse_byte_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
&
Self
ZeroVecError
>
{
str
:
:
from_utf8
(
bytes
)
.
map_err
(
|
_
|
ZeroVecError
:
:
parse
:
:
<
Self
>
(
)
)
}
#
[
inline
]
unsafe
fn
from_byte_slice_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
Self
{
str
:
:
from_utf8_unchecked
(
bytes
)
}
}
unsafe
impl
<
T
>
VarULE
for
[
T
]
where
T
:
ULE
{
#
[
inline
]
fn
validate_byte_slice
(
slice
:
&
[
u8
]
)
-
>
Result
<
(
)
ZeroVecError
>
{
T
:
:
validate_byte_slice
(
slice
)
}
#
[
inline
]
unsafe
fn
from_byte_slice_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
Self
{
T
:
:
from_byte_slice_unchecked
(
bytes
)
}
}
