#
!
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
mod
chars
;
#
[
cfg
(
doc
)
]
pub
mod
custom
;
mod
encode
;
mod
macros
;
mod
multi
;
mod
niche
;
mod
option
;
mod
plain
;
mod
slices
;
mod
unvalidated
;
pub
mod
tuple
;
pub
use
super
:
:
ZeroVecError
;
pub
use
chars
:
:
CharULE
;
pub
use
encode
:
:
{
encode_varule_to_box
EncodeAsVarULE
}
;
pub
use
multi
:
:
MultiFieldsULE
;
pub
use
niche
:
:
{
NicheBytes
NichedOption
NichedOptionULE
}
;
pub
use
option
:
:
{
OptionULE
OptionVarULE
}
;
pub
use
plain
:
:
RawBytesULE
;
pub
use
unvalidated
:
:
{
UnvalidatedChar
UnvalidatedStr
}
;
use
alloc
:
:
alloc
:
:
Layout
;
use
alloc
:
:
borrow
:
:
ToOwned
;
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
{
mem
slice
}
;
pub
unsafe
trait
ULE
where
Self
:
Sized
Self
:
Copy
+
'
static
{
fn
validate_byte_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
ZeroVecError
>
;
fn
parse_byte_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
&
[
Self
]
ZeroVecError
>
{
Self
:
:
validate_byte_slice
(
bytes
)
?
;
debug_assert_eq
!
(
bytes
.
len
(
)
%
mem
:
:
size_of
:
:
<
Self
>
(
)
0
)
;
Ok
(
unsafe
{
Self
:
:
from_byte_slice_unchecked
(
bytes
)
}
)
}
#
[
inline
]
unsafe
fn
from_byte_slice_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
[
Self
]
{
let
data
=
bytes
.
as_ptr
(
)
;
let
len
=
bytes
.
len
(
)
/
mem
:
:
size_of
:
:
<
Self
>
(
)
;
debug_assert_eq
!
(
bytes
.
len
(
)
%
mem
:
:
size_of
:
:
<
Self
>
(
)
0
)
;
core
:
:
slice
:
:
from_raw_parts
(
data
as
*
const
Self
len
)
}
#
[
inline
]
#
[
allow
(
clippy
:
:
wrong_self_convention
)
]
fn
as_byte_slice
(
slice
:
&
[
Self
]
)
-
>
&
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts
(
slice
as
*
const
[
Self
]
as
*
const
u8
mem
:
:
size_of_val
(
slice
)
)
}
}
}
pub
trait
AsULE
:
Copy
{
type
ULE
:
ULE
;
fn
to_unaligned
(
self
)
-
>
Self
:
:
ULE
;
fn
from_unaligned
(
unaligned
:
Self
:
:
ULE
)
-
>
Self
;
}
pub
unsafe
trait
EqULE
:
AsULE
{
}
pub
trait
SliceAsULE
where
Self
:
AsULE
+
Sized
{
fn
slice_to_unaligned
(
slice
:
&
[
Self
]
)
-
>
Option
<
&
[
Self
:
:
ULE
]
>
;
}
#
[
cfg
(
target_endian
=
"
little
"
)
]
impl
<
T
>
SliceAsULE
for
T
where
T
:
EqULE
{
#
[
inline
]
fn
slice_to_unaligned
(
slice
:
&
[
Self
]
)
-
>
Option
<
&
[
Self
:
:
ULE
]
>
{
let
ule_slice
=
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
slice
.
as_ptr
(
)
as
*
const
Self
:
:
ULE
slice
.
len
(
)
)
}
;
Some
(
ule_slice
)
}
}
#
[
cfg
(
not
(
target_endian
=
"
little
"
)
)
]
impl
<
T
>
SliceAsULE
for
T
where
T
:
EqULE
{
#
[
inline
]
fn
slice_to_unaligned
(
_
:
&
[
Self
]
)
-
>
Option
<
&
[
Self
:
:
ULE
]
>
{
None
}
}
pub
unsafe
trait
VarULE
:
'
static
{
fn
validate_byte_slice
(
_bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
ZeroVecError
>
;
fn
parse_byte_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
&
Self
ZeroVecError
>
{
Self
:
:
validate_byte_slice
(
bytes
)
?
;
let
result
=
unsafe
{
Self
:
:
from_byte_slice_unchecked
(
bytes
)
}
;
debug_assert_eq
!
(
mem
:
:
size_of_val
(
result
)
mem
:
:
size_of_val
(
bytes
)
)
;
Ok
(
result
)
}
unsafe
fn
from_byte_slice_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
Self
;
#
[
inline
]
fn
as_byte_slice
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
as
*
const
Self
as
*
const
u8
mem
:
:
size_of_val
(
self
)
)
}
}
#
[
inline
]
fn
to_boxed
(
&
self
)
-
>
Box
<
Self
>
{
let
bytesvec
=
self
.
as_byte_slice
(
)
.
to_owned
(
)
.
into_boxed_slice
(
)
;
let
bytesvec
=
mem
:
:
ManuallyDrop
:
:
new
(
bytesvec
)
;
unsafe
{
let
ptr
:
*
mut
Self
=
Self
:
:
from_byte_slice_unchecked
(
&
bytesvec
)
as
*
const
Self
as
*
mut
Self
;
assert_eq
!
(
Layout
:
:
for_value
(
&
*
ptr
)
Layout
:
:
for_value
(
&
*
*
bytesvec
)
)
;
Box
:
:
from_raw
(
ptr
)
}
}
}
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
zerovec_derive
:
:
ULE
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
zerovec_derive
:
:
VarULE
;
