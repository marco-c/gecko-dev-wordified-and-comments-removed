#
!
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
mod
chars
;
#
[
cfg
(
doc
)
]
pub
mod
custom
;
mod
encode
;
mod
macros
;
mod
multi
;
mod
niche
;
mod
option
;
mod
plain
;
mod
slices
;
#
[
cfg
(
test
)
]
pub
mod
test_utils
;
pub
mod
tuple
;
pub
mod
tuplevar
;
pub
mod
vartuple
;
pub
use
chars
:
:
CharULE
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
encode
:
:
encode_varule_to_box
;
pub
use
encode
:
:
EncodeAsVarULE
;
pub
use
multi
:
:
MultiFieldsULE
;
pub
use
niche
:
:
{
NicheBytes
NichedOption
NichedOptionULE
}
;
pub
use
option
:
:
{
OptionULE
OptionVarULE
}
;
pub
use
plain
:
:
RawBytesULE
;
use
core
:
:
{
any
fmt
mem
slice
}
;
pub
unsafe
trait
ULE
where
Self
:
Sized
Self
:
Copy
+
'
static
{
fn
validate_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
UleError
>
;
fn
parse_bytes_to_slice
(
bytes
:
&
[
u8
]
)
-
>
Result
<
&
[
Self
]
UleError
>
{
Self
:
:
validate_bytes
(
bytes
)
?
;
debug_assert_eq
!
(
bytes
.
len
(
)
%
mem
:
:
size_of
:
:
<
Self
>
(
)
0
)
;
Ok
(
unsafe
{
Self
:
:
slice_from_bytes_unchecked
(
bytes
)
}
)
}
#
[
inline
]
unsafe
fn
slice_from_bytes_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
[
Self
]
{
let
data
=
bytes
.
as_ptr
(
)
;
let
len
=
bytes
.
len
(
)
/
mem
:
:
size_of
:
:
<
Self
>
(
)
;
debug_assert_eq
!
(
bytes
.
len
(
)
%
mem
:
:
size_of
:
:
<
Self
>
(
)
0
)
;
core
:
:
slice
:
:
from_raw_parts
(
data
as
*
const
Self
len
)
}
#
[
inline
]
#
[
allow
(
clippy
:
:
wrong_self_convention
)
]
fn
slice_as_bytes
(
slice
:
&
[
Self
]
)
-
>
&
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts
(
slice
as
*
const
[
Self
]
as
*
const
u8
mem
:
:
size_of_val
(
slice
)
)
}
}
}
pub
trait
AsULE
:
Copy
{
type
ULE
:
ULE
;
fn
to_unaligned
(
self
)
-
>
Self
:
:
ULE
;
fn
from_unaligned
(
unaligned
:
Self
:
:
ULE
)
-
>
Self
;
}
pub
unsafe
trait
EqULE
:
AsULE
{
}
pub
trait
SliceAsULE
where
Self
:
AsULE
+
Sized
{
fn
slice_to_unaligned
(
slice
:
&
[
Self
]
)
-
>
Option
<
&
[
Self
:
:
ULE
]
>
;
}
#
[
cfg
(
target_endian
=
"
little
"
)
]
impl
<
T
>
SliceAsULE
for
T
where
T
:
EqULE
{
#
[
inline
]
fn
slice_to_unaligned
(
slice
:
&
[
Self
]
)
-
>
Option
<
&
[
Self
:
:
ULE
]
>
{
let
ule_slice
=
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
slice
.
as_ptr
(
)
as
*
const
Self
:
:
ULE
slice
.
len
(
)
)
}
;
Some
(
ule_slice
)
}
}
#
[
cfg
(
not
(
target_endian
=
"
little
"
)
)
]
impl
<
T
>
SliceAsULE
for
T
where
T
:
EqULE
{
#
[
inline
]
fn
slice_to_unaligned
(
_
:
&
[
Self
]
)
-
>
Option
<
&
[
Self
:
:
ULE
]
>
{
None
}
}
pub
unsafe
trait
VarULE
:
'
static
{
fn
validate_bytes
(
_bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
UleError
>
;
fn
parse_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
&
Self
UleError
>
{
Self
:
:
validate_bytes
(
bytes
)
?
;
let
result
=
unsafe
{
Self
:
:
from_bytes_unchecked
(
bytes
)
}
;
debug_assert_eq
!
(
mem
:
:
size_of_val
(
result
)
mem
:
:
size_of_val
(
bytes
)
)
;
Ok
(
result
)
}
unsafe
fn
from_bytes_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
Self
;
#
[
inline
]
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
as
*
const
Self
as
*
const
u8
mem
:
:
size_of_val
(
self
)
)
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
to_boxed
(
&
self
)
-
>
alloc
:
:
boxed
:
:
Box
<
Self
>
{
use
alloc
:
:
borrow
:
:
ToOwned
;
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
alloc
:
:
Layout
;
let
bytesvec
=
self
.
as_bytes
(
)
.
to_owned
(
)
.
into_boxed_slice
(
)
;
let
bytesvec
=
mem
:
:
ManuallyDrop
:
:
new
(
bytesvec
)
;
unsafe
{
let
ptr
:
*
mut
Self
=
Self
:
:
from_bytes_unchecked
(
&
bytesvec
)
as
*
const
Self
as
*
mut
Self
;
assert_eq
!
(
Layout
:
:
for_value
(
&
*
ptr
)
Layout
:
:
for_value
(
&
*
*
bytesvec
)
)
;
Box
:
:
from_raw
(
ptr
)
}
}
}
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
zerovec_derive
:
:
ULE
;
#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
zerovec_derive
:
:
VarULE
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
enum
UleError
{
InvalidLength
{
ty
:
&
'
static
str
len
:
usize
}
ParseError
{
ty
:
&
'
static
str
}
}
impl
fmt
:
:
Display
for
UleError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
match
*
self
{
UleError
:
:
InvalidLength
{
ty
len
}
=
>
{
write
!
(
f
"
Invalid
length
{
len
}
for
slice
of
type
{
ty
}
"
)
}
UleError
:
:
ParseError
{
ty
}
=
>
{
write
!
(
f
"
Could
not
parse
bytes
to
slice
of
type
{
ty
}
"
)
}
}
}
}
impl
UleError
{
pub
fn
parse
<
T
:
?
Sized
+
'
static
>
(
)
-
>
UleError
{
UleError
:
:
ParseError
{
ty
:
any
:
:
type_name
:
:
<
T
>
(
)
}
}
pub
fn
length
<
T
:
?
Sized
+
'
static
>
(
len
:
usize
)
-
>
UleError
{
UleError
:
:
InvalidLength
{
ty
:
any
:
:
type_name
:
:
<
T
>
(
)
len
}
}
}
impl
core
:
:
error
:
:
Error
for
UleError
{
}
