use
super
:
:
VarZeroVecFormatError
;
use
crate
:
:
ule
:
:
*
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
convert
:
:
TryFrom
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
use
core
:
:
ops
:
:
Range
;
pub
trait
VarZeroVecFormat
:
'
static
+
Sized
{
#
[
doc
(
hidden
)
]
type
Index
:
IntegerULE
;
#
[
doc
(
hidden
)
]
type
Len
:
IntegerULE
;
}
#
[
doc
(
hidden
)
]
pub
unsafe
trait
IntegerULE
:
ULE
{
#
[
doc
(
hidden
)
]
const
TOO_LARGE_ERROR
:
&
'
static
str
;
#
[
doc
(
hidden
)
]
const
SIZE
:
usize
;
#
[
doc
(
hidden
)
]
const
MAX_VALUE
:
u32
;
#
[
doc
(
hidden
)
]
fn
iule_to_usize
(
self
)
-
>
usize
;
#
[
doc
(
hidden
)
]
fn
iule_from_usize
(
x
:
usize
)
-
>
Option
<
Self
>
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
iule_from_bytes_unchecked_mut
(
bytes
:
&
mut
[
u8
]
)
-
>
&
mut
[
Self
]
;
}
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
Index8
;
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
Index16
;
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
Index32
;
impl
VarZeroVecFormat
for
Index8
{
type
Index
=
u8
;
type
Len
=
u8
;
}
impl
VarZeroVecFormat
for
Index16
{
type
Index
=
RawBytesULE
<
2
>
;
type
Len
=
RawBytesULE
<
2
>
;
}
impl
VarZeroVecFormat
for
Index32
{
type
Index
=
RawBytesULE
<
4
>
;
type
Len
=
RawBytesULE
<
4
>
;
}
unsafe
impl
IntegerULE
for
u8
{
const
TOO_LARGE_ERROR
:
&
'
static
str
=
"
Attempted
to
build
VarZeroVec
out
of
elements
that
\
cumulatively
are
larger
than
a
u8
in
size
"
;
const
SIZE
:
usize
=
mem
:
:
size_of
:
:
<
Self
>
(
)
;
const
MAX_VALUE
:
u32
=
u8
:
:
MAX
as
u32
;
#
[
inline
]
fn
iule_to_usize
(
self
)
-
>
usize
{
self
as
usize
}
#
[
inline
]
fn
iule_from_usize
(
u
:
usize
)
-
>
Option
<
Self
>
{
u8
:
:
try_from
(
u
)
.
ok
(
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
iule_from_bytes_unchecked_mut
(
bytes
:
&
mut
[
u8
]
)
-
>
&
mut
[
Self
]
{
bytes
}
}
unsafe
impl
IntegerULE
for
RawBytesULE
<
2
>
{
const
TOO_LARGE_ERROR
:
&
'
static
str
=
"
Attempted
to
build
VarZeroVec
out
of
elements
that
\
cumulatively
are
larger
than
a
u16
in
size
"
;
const
SIZE
:
usize
=
mem
:
:
size_of
:
:
<
Self
>
(
)
;
const
MAX_VALUE
:
u32
=
u16
:
:
MAX
as
u32
;
#
[
inline
]
fn
iule_to_usize
(
self
)
-
>
usize
{
self
.
as_unsigned_int
(
)
as
usize
}
#
[
inline
]
fn
iule_from_usize
(
u
:
usize
)
-
>
Option
<
Self
>
{
u16
:
:
try_from
(
u
)
.
ok
(
)
.
map
(
u16
:
:
to_unaligned
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
iule_from_bytes_unchecked_mut
(
bytes
:
&
mut
[
u8
]
)
-
>
&
mut
[
Self
]
{
Self
:
:
from_bytes_unchecked_mut
(
bytes
)
}
}
unsafe
impl
IntegerULE
for
RawBytesULE
<
4
>
{
const
TOO_LARGE_ERROR
:
&
'
static
str
=
"
Attempted
to
build
VarZeroVec
out
of
elements
that
\
cumulatively
are
larger
than
a
u32
in
size
"
;
const
SIZE
:
usize
=
mem
:
:
size_of
:
:
<
Self
>
(
)
;
const
MAX_VALUE
:
u32
=
u32
:
:
MAX
;
#
[
inline
]
fn
iule_to_usize
(
self
)
-
>
usize
{
self
.
as_unsigned_int
(
)
as
usize
}
#
[
inline
]
fn
iule_from_usize
(
u
:
usize
)
-
>
Option
<
Self
>
{
u32
:
:
try_from
(
u
)
.
ok
(
)
.
map
(
u32
:
:
to_unaligned
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
iule_from_bytes_unchecked_mut
(
bytes
:
&
mut
[
u8
]
)
-
>
&
mut
[
Self
]
{
Self
:
:
from_bytes_unchecked_mut
(
bytes
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
VarZeroVecComponents
<
'
a
T
:
?
Sized
F
>
{
len
:
u32
indices
:
&
'
a
[
u8
]
things
:
&
'
a
[
u8
]
marker
:
PhantomData
<
(
&
'
a
T
F
)
>
}
impl
<
'
a
T
:
?
Sized
F
>
Copy
for
VarZeroVecComponents
<
'
a
T
F
>
{
}
impl
<
'
a
T
:
?
Sized
F
>
Clone
for
VarZeroVecComponents
<
'
a
T
F
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
'
a
T
:
VarULE
+
?
Sized
F
>
Default
for
VarZeroVecComponents
<
'
a
T
F
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
'
a
T
:
VarULE
+
?
Sized
F
>
VarZeroVecComponents
<
'
a
T
F
>
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
len
:
0
indices
:
&
[
]
things
:
&
[
]
marker
:
PhantomData
}
}
}
impl
<
'
a
T
:
VarULE
+
?
Sized
F
:
VarZeroVecFormat
>
VarZeroVecComponents
<
'
a
T
F
>
{
#
[
inline
]
pub
fn
parse_bytes
(
slice
:
&
'
a
[
u8
]
)
-
>
Result
<
Self
VarZeroVecFormatError
>
{
if
slice
.
is_empty
(
)
{
return
Ok
(
VarZeroVecComponents
{
len
:
0
indices
:
&
[
]
things
:
&
[
]
marker
:
PhantomData
}
)
;
}
let
len_bytes
=
slice
.
get
(
0
.
.
F
:
:
Len
:
:
SIZE
)
.
ok_or
(
VarZeroVecFormatError
:
:
Metadata
)
?
;
let
len_ule
=
F
:
:
Len
:
:
parse_bytes_to_slice
(
len_bytes
)
.
map_err
(
|
_
|
VarZeroVecFormatError
:
:
Metadata
)
?
;
let
len
=
len_ule
.
first
(
)
.
ok_or
(
VarZeroVecFormatError
:
:
Metadata
)
?
.
iule_to_usize
(
)
;
let
rest
=
slice
.
get
(
F
:
:
Len
:
:
SIZE
.
.
)
.
ok_or
(
VarZeroVecFormatError
:
:
Metadata
)
?
;
let
len_u32
=
u32
:
:
try_from
(
len
)
.
map_err
(
|
_
|
VarZeroVecFormatError
:
:
Metadata
)
;
Self
:
:
parse_bytes_with_length
(
len_u32
?
rest
)
}
#
[
inline
]
pub
fn
parse_bytes_with_length
(
len
:
u32
slice
:
&
'
a
[
u8
]
)
-
>
Result
<
Self
VarZeroVecFormatError
>
{
let
len_minus_one
=
len
.
checked_sub
(
1
)
;
let
Some
(
len_minus_one
)
=
len_minus_one
else
{
return
Ok
(
VarZeroVecComponents
{
len
:
0
indices
:
&
[
]
things
:
&
[
]
marker
:
PhantomData
}
)
;
}
;
let
indices_bytes
=
slice
.
get
(
.
.
F
:
:
Index
:
:
SIZE
*
(
len_minus_one
as
usize
)
)
.
ok_or
(
VarZeroVecFormatError
:
:
Metadata
)
?
;
let
things
=
slice
.
get
(
F
:
:
Index
:
:
SIZE
*
(
len_minus_one
as
usize
)
.
.
)
.
ok_or
(
VarZeroVecFormatError
:
:
Metadata
)
?
;
let
borrowed
=
VarZeroVecComponents
{
len
indices
:
indices_bytes
things
marker
:
PhantomData
}
;
borrowed
.
check_indices_and_things
(
)
?
;
Ok
(
borrowed
)
}
pub
unsafe
fn
from_bytes_unchecked
(
slice
:
&
'
a
[
u8
]
)
-
>
Self
{
if
slice
.
is_empty
(
)
{
return
VarZeroVecComponents
{
len
:
0
indices
:
&
[
]
things
:
&
[
]
marker
:
PhantomData
}
;
}
let
(
len_bytes
data_bytes
)
=
unsafe
{
slice
.
split_at_unchecked
(
F
:
:
Len
:
:
SIZE
)
}
;
let
len_ule
=
F
:
:
Len
:
:
slice_from_bytes_unchecked
(
len_bytes
)
;
let
len
=
len_ule
.
get_unchecked
(
0
)
.
iule_to_usize
(
)
;
let
len_u32
=
len
as
u32
;
Self
:
:
from_bytes_unchecked_with_length
(
len_u32
data_bytes
)
}
pub
unsafe
fn
from_bytes_unchecked_with_length
(
len
:
u32
slice
:
&
'
a
[
u8
]
)
-
>
Self
{
let
len_minus_one
=
len
.
checked_sub
(
1
)
;
let
Some
(
len_minus_one
)
=
len_minus_one
else
{
return
VarZeroVecComponents
{
len
:
0
indices
:
&
[
]
things
:
&
[
]
marker
:
PhantomData
}
;
}
;
let
indices_bytes
=
slice
.
get_unchecked
(
.
.
F
:
:
Index
:
:
SIZE
*
(
len_minus_one
as
usize
)
)
;
let
things
=
slice
.
get_unchecked
(
F
:
:
Index
:
:
SIZE
*
(
len_minus_one
as
usize
)
.
.
)
;
VarZeroVecComponents
{
len
indices
:
indices_bytes
things
marker
:
PhantomData
}
}
#
[
inline
]
pub
fn
len
(
self
)
-
>
usize
{
self
.
len
as
usize
}
#
[
inline
]
pub
fn
is_empty
(
self
)
-
>
bool
{
self
.
len
=
=
0
}
#
[
inline
]
pub
fn
get
(
self
idx
:
usize
)
-
>
Option
<
&
'
a
T
>
{
if
idx
>
=
self
.
len
(
)
{
return
None
;
}
Some
(
unsafe
{
self
.
get_unchecked
(
idx
)
}
)
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
get_unchecked
(
self
idx
:
usize
)
-
>
&
'
a
T
{
let
range
=
self
.
get_things_range
(
idx
)
;
let
things_slice
=
self
.
things
.
get_unchecked
(
range
)
;
T
:
:
from_bytes_unchecked
(
things_slice
)
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
get_things_range
(
self
idx
:
usize
)
-
>
Range
<
usize
>
{
let
start
=
if
let
Some
(
idx_minus_one
)
=
idx
.
checked_sub
(
1
)
{
self
.
indices_slice
(
)
.
get_unchecked
(
idx_minus_one
)
.
iule_to_usize
(
)
}
else
{
0
}
;
let
end
=
if
idx
+
1
=
=
self
.
len
(
)
{
self
.
things
.
len
(
)
}
else
{
self
.
indices_slice
(
)
.
get_unchecked
(
idx
)
.
iule_to_usize
(
)
}
;
debug_assert
!
(
start
<
=
end
)
;
start
.
.
end
}
pub
(
crate
)
unsafe
fn
get_indices_size
(
self
)
-
>
usize
{
self
.
indices
.
len
(
)
}
#
[
inline
]
#
[
expect
(
clippy
:
:
len_zero
)
]
fn
check_indices_and_things
(
self
)
-
>
Result
<
(
)
VarZeroVecFormatError
>
{
if
self
.
len
(
)
=
=
0
{
if
self
.
things
.
len
(
)
>
0
{
return
Err
(
VarZeroVecFormatError
:
:
Metadata
)
;
}
else
{
return
Ok
(
(
)
)
;
}
}
let
indices_slice
=
self
.
indices_slice
(
)
;
assert_eq
!
(
self
.
len
(
)
indices_slice
.
len
(
)
+
1
)
;
let
mut
start
=
0
;
for
i
in
0
.
.
self
.
len
(
)
{
let
end
=
if
let
Some
(
end
)
=
indices_slice
.
get
(
i
)
{
end
.
iule_to_usize
(
)
}
else
{
self
.
things
.
len
(
)
}
;
if
start
>
end
{
return
Err
(
VarZeroVecFormatError
:
:
Metadata
)
;
}
if
end
>
self
.
things
.
len
(
)
{
return
Err
(
VarZeroVecFormatError
:
:
Metadata
)
;
}
let
bytes
=
unsafe
{
self
.
things
.
get_unchecked
(
start
.
.
end
)
}
;
T
:
:
parse_bytes
(
bytes
)
.
map_err
(
VarZeroVecFormatError
:
:
Values
)
?
;
start
=
end
;
}
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
iter
(
self
)
-
>
VarZeroSliceIter
<
'
a
T
F
>
{
VarZeroSliceIter
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
to_vec
(
self
)
-
>
alloc
:
:
vec
:
:
Vec
<
alloc
:
:
boxed
:
:
Box
<
T
>
>
{
self
.
iter
(
)
.
map
(
T
:
:
to_boxed
)
.
collect
(
)
}
#
[
inline
]
fn
indices_slice
(
&
self
)
-
>
&
'
a
[
F
:
:
Index
]
{
unsafe
{
F
:
:
Index
:
:
slice_from_bytes_unchecked
(
self
.
indices
)
}
}
#
[
allow
(
unused
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
(
crate
)
fn
dump
(
&
self
)
-
>
alloc
:
:
string
:
:
String
{
let
indices
=
self
.
indices_slice
(
)
.
iter
(
)
.
copied
(
)
.
map
(
IntegerULE
:
:
iule_to_usize
)
.
collect
:
:
<
alloc
:
:
vec
:
:
Vec
<
_
>
>
(
)
;
alloc
:
:
format
!
(
"
VarZeroVecComponents
{
{
indices
:
{
indices
:
?
}
}
}
"
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
VarZeroSliceIter
<
'
a
T
:
?
Sized
F
=
Index16
>
{
components
:
VarZeroVecComponents
<
'
a
T
F
>
index
:
usize
start_index
:
usize
}
impl
<
'
a
T
:
VarULE
+
?
Sized
F
:
VarZeroVecFormat
>
VarZeroSliceIter
<
'
a
T
F
>
{
fn
new
(
c
:
VarZeroVecComponents
<
'
a
T
F
>
)
-
>
Self
{
Self
{
components
:
c
index
:
0
start_index
:
0
}
}
}
impl
<
'
a
T
:
VarULE
+
?
Sized
F
:
VarZeroVecFormat
>
Iterator
for
VarZeroSliceIter
<
'
a
T
F
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
index
>
=
self
.
components
.
len
(
)
{
return
None
;
}
let
end
=
if
self
.
index
+
1
=
=
self
.
components
.
len
(
)
{
self
.
components
.
things
.
len
(
)
}
else
{
unsafe
{
self
.
components
.
indices_slice
(
)
.
get_unchecked
(
self
.
index
)
.
iule_to_usize
(
)
}
}
;
let
item
=
unsafe
{
T
:
:
from_bytes_unchecked
(
self
.
components
.
things
.
get_unchecked
(
self
.
start_index
.
.
end
)
)
}
;
self
.
index
+
=
1
;
self
.
start_index
=
end
;
Some
(
item
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
remainder
=
self
.
components
.
len
(
)
-
self
.
index
;
(
remainder
Some
(
remainder
)
)
}
}
impl
<
'
a
T
:
VarULE
+
?
Sized
F
:
VarZeroVecFormat
>
ExactSizeIterator
for
VarZeroSliceIter
<
'
a
T
F
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
components
.
len
(
)
-
self
.
index
}
}
impl
<
'
a
T
F
>
VarZeroVecComponents
<
'
a
T
F
>
where
T
:
VarULE
T
:
?
Sized
T
:
Ord
F
:
VarZeroVecFormat
{
pub
fn
binary_search
(
&
self
needle
:
&
T
)
-
>
Result
<
usize
usize
>
{
self
.
binary_search_by
(
|
probe
|
probe
.
cmp
(
needle
)
)
}
pub
fn
binary_search_in_range
(
&
self
needle
:
&
T
range
:
Range
<
usize
>
)
-
>
Option
<
Result
<
usize
usize
>
>
{
self
.
binary_search_in_range_by
(
|
probe
|
probe
.
cmp
(
needle
)
range
)
}
}
impl
<
'
a
T
F
>
VarZeroVecComponents
<
'
a
T
F
>
where
T
:
VarULE
T
:
?
Sized
F
:
VarZeroVecFormat
{
pub
fn
binary_search_by
(
&
self
predicate
:
impl
FnMut
(
&
T
)
-
>
Ordering
)
-
>
Result
<
usize
usize
>
{
unsafe
{
self
.
binary_search_in_range_unchecked
(
predicate
0
.
.
self
.
len
(
)
)
}
}
pub
fn
binary_search_in_range_by
(
&
self
predicate
:
impl
FnMut
(
&
T
)
-
>
Ordering
range
:
Range
<
usize
>
)
-
>
Option
<
Result
<
usize
usize
>
>
{
if
range
.
end
>
self
.
len
(
)
{
return
None
;
}
if
range
.
end
<
range
.
start
{
return
None
;
}
let
range_absolute
=
unsafe
{
self
.
binary_search_in_range_unchecked
(
predicate
range
.
clone
(
)
)
}
;
Some
(
range_absolute
.
map
(
|
o
|
o
-
range
.
start
)
.
map_err
(
|
e
|
e
-
range
.
start
)
)
}
unsafe
fn
binary_search_in_range_unchecked
(
&
self
mut
predicate
:
impl
FnMut
(
&
T
)
-
>
Ordering
range
:
Range
<
usize
>
)
-
>
Result
<
usize
usize
>
{
let
mut
start
=
range
.
start
;
let
mut
end
=
range
.
end
;
let
mut
size
;
while
start
<
end
{
size
=
end
-
start
;
let
mid
=
start
+
size
/
2
;
let
cmp
=
predicate
(
self
.
get_unchecked
(
mid
)
)
;
match
cmp
{
Ordering
:
:
Less
=
>
{
start
=
mid
+
1
;
}
Ordering
:
:
Greater
=
>
{
end
=
mid
;
}
Ordering
:
:
Equal
=
>
return
Ok
(
mid
)
}
}
Err
(
start
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
get_serializable_bytes_non_empty
<
T
A
F
>
(
elements
:
&
[
A
]
)
-
>
Option
<
alloc
:
:
vec
:
:
Vec
<
u8
>
>
where
T
:
VarULE
+
?
Sized
A
:
EncodeAsVarULE
<
T
>
F
:
VarZeroVecFormat
{
debug_assert
!
(
!
elements
.
is_empty
(
)
)
;
let
len
=
compute_serializable_len
:
:
<
T
A
F
>
(
elements
)
?
;
debug_assert
!
(
len
>
=
F
:
:
Len
:
:
SIZE
as
u32
"
Must
have
at
least
F
:
:
Len
:
:
SIZE
bytes
to
hold
the
length
of
the
vector
"
)
;
let
mut
output
=
alloc
:
:
vec
!
[
0u8
;
len
as
usize
]
;
write_serializable_bytes
:
:
<
T
A
F
>
(
elements
&
mut
output
)
;
Some
(
output
)
}
pub
fn
write_serializable_bytes_without_length
<
T
A
F
>
(
elements
:
&
[
A
]
output
:
&
mut
[
u8
]
)
where
T
:
VarULE
+
?
Sized
A
:
EncodeAsVarULE
<
T
>
F
:
VarZeroVecFormat
{
assert
!
(
elements
.
len
(
)
<
=
F
:
:
Len
:
:
MAX_VALUE
as
usize
)
;
if
elements
.
is_empty
(
)
{
return
;
}
let
mut
idx_offset
:
usize
=
0
;
let
first_dat_offset
:
usize
=
idx_offset
+
(
elements
.
len
(
)
-
1
)
*
F
:
:
Index
:
:
SIZE
;
let
mut
dat_offset
:
usize
=
first_dat_offset
;
for
(
i
element
)
in
elements
.
iter
(
)
.
enumerate
(
)
{
let
element_len
=
element
.
encode_var_ule_len
(
)
;
if
i
!
=
0
{
let
idx_limit
=
idx_offset
+
F
:
:
Index
:
:
SIZE
;
#
[
expect
(
clippy
:
:
indexing_slicing
)
]
let
idx_slice
=
&
mut
output
[
idx_offset
.
.
idx_limit
]
;
let
idx
=
dat_offset
-
first_dat_offset
;
assert
!
(
idx
<
=
F
:
:
Index
:
:
MAX_VALUE
as
usize
)
;
#
[
expect
(
clippy
:
:
expect_used
)
]
let
bytes_to_write
=
F
:
:
Index
:
:
iule_from_usize
(
idx
)
.
expect
(
F
:
:
Index
:
:
TOO_LARGE_ERROR
)
;
idx_slice
.
copy_from_slice
(
ULE
:
:
slice_as_bytes
(
&
[
bytes_to_write
]
)
)
;
idx_offset
=
idx_limit
;
}
let
dat_limit
=
dat_offset
+
element_len
;
#
[
expect
(
clippy
:
:
indexing_slicing
)
]
let
dat_slice
=
&
mut
output
[
dat_offset
.
.
dat_limit
]
;
element
.
encode_var_ule_write
(
dat_slice
)
;
debug_assert_eq
!
(
T
:
:
validate_bytes
(
dat_slice
)
Ok
(
(
)
)
)
;
dat_offset
=
dat_limit
;
}
debug_assert_eq
!
(
idx_offset
F
:
:
Index
:
:
SIZE
*
(
elements
.
len
(
)
-
1
)
)
;
assert_eq
!
(
dat_offset
output
.
len
(
)
)
;
}
pub
fn
write_serializable_bytes
<
T
A
F
>
(
elements
:
&
[
A
]
output
:
&
mut
[
u8
]
)
where
T
:
VarULE
+
?
Sized
A
:
EncodeAsVarULE
<
T
>
F
:
VarZeroVecFormat
{
if
elements
.
is_empty
(
)
{
return
;
}
assert
!
(
elements
.
len
(
)
<
=
F
:
:
Len
:
:
MAX_VALUE
as
usize
)
;
#
[
expect
(
clippy
:
:
expect_used
)
]
let
num_elements_ule
=
F
:
:
Len
:
:
iule_from_usize
(
elements
.
len
(
)
)
.
expect
(
F
:
:
Len
:
:
TOO_LARGE_ERROR
)
;
#
[
expect
(
clippy
:
:
indexing_slicing
)
]
output
[
0
.
.
F
:
:
Len
:
:
SIZE
]
.
copy_from_slice
(
ULE
:
:
slice_as_bytes
(
&
[
num_elements_ule
]
)
)
;
#
[
expect
(
clippy
:
:
indexing_slicing
)
]
write_serializable_bytes_without_length
:
:
<
T
A
F
>
(
elements
&
mut
output
[
F
:
:
Len
:
:
SIZE
.
.
]
)
;
}
pub
fn
compute_serializable_len_without_length
<
T
A
F
>
(
elements
:
&
[
A
]
)
-
>
Option
<
u32
>
where
T
:
VarULE
+
?
Sized
A
:
EncodeAsVarULE
<
T
>
F
:
VarZeroVecFormat
{
let
elements_len
=
elements
.
len
(
)
;
let
Some
(
elements_len_minus_one
)
=
elements_len
.
checked_sub
(
1
)
else
{
return
Some
(
0
)
;
}
;
let
idx_len
:
u32
=
u32
:
:
try_from
(
elements_len_minus_one
)
.
ok
(
)
?
.
checked_mul
(
F
:
:
Index
:
:
SIZE
as
u32
)
?
;
let
data_len
:
u32
=
elements
.
iter
(
)
.
map
(
|
v
|
u32
:
:
try_from
(
v
.
encode_var_ule_len
(
)
)
.
ok
(
)
)
.
try_fold
(
0u32
|
s
v
|
s
.
checked_add
(
v
?
)
)
?
;
let
ret
=
idx_len
.
checked_add
(
data_len
)
;
if
let
Some
(
r
)
=
ret
{
if
r
>
=
F
:
:
Index
:
:
MAX_VALUE
{
return
None
;
}
}
ret
}
pub
fn
compute_serializable_len
<
T
A
F
>
(
elements
:
&
[
A
]
)
-
>
Option
<
u32
>
where
T
:
VarULE
+
?
Sized
A
:
EncodeAsVarULE
<
T
>
F
:
VarZeroVecFormat
{
compute_serializable_len_without_length
:
:
<
T
A
F
>
(
elements
)
.
map
(
|
x
|
x
+
F
:
:
Len
:
:
SIZE
as
u32
)
}
