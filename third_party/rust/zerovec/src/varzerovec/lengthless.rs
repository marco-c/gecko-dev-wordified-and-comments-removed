use
super
:
:
components
:
:
VarZeroVecComponents
;
use
super
:
:
*
;
use
crate
:
:
ule
:
:
*
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
#
[
repr
(
transparent
)
]
#
[
derive
(
PartialEq
Eq
)
]
pub
(
crate
)
struct
VarZeroLengthlessSlice
<
T
:
?
Sized
F
>
{
marker
:
PhantomData
<
(
F
T
)
>
entire_slice
:
[
u8
]
}
impl
<
T
:
VarULE
+
?
Sized
F
:
VarZeroVecFormat
>
VarZeroLengthlessSlice
<
T
F
>
{
#
[
inline
]
pub
(
crate
)
unsafe
fn
as_components
<
'
a
>
(
&
'
a
self
len
:
u32
)
-
>
VarZeroVecComponents
<
'
a
T
F
>
{
unsafe
{
VarZeroVecComponents
:
:
from_bytes_unchecked_with_length
(
len
&
self
.
entire_slice
)
}
}
pub
fn
parse_bytes
<
'
a
>
(
len
:
u32
slice
:
&
'
a
[
u8
]
)
-
>
Result
<
&
'
a
Self
UleError
>
{
let
_
=
VarZeroVecComponents
:
:
<
T
F
>
:
:
parse_bytes_with_length
(
len
slice
)
.
map_err
(
|
_
|
UleError
:
:
parse
:
:
<
Self
>
(
)
)
?
;
unsafe
{
Ok
(
Self
:
:
from_bytes_unchecked
(
slice
)
)
}
}
pub
(
crate
)
const
unsafe
fn
from_bytes_unchecked
(
bytes
:
&
[
u8
]
)
-
>
&
Self
{
mem
:
:
transmute
(
bytes
)
}
pub
(
crate
)
unsafe
fn
from_bytes_unchecked_mut
(
bytes
:
&
mut
[
u8
]
)
-
>
&
mut
Self
{
mem
:
:
transmute
(
bytes
)
}
pub
(
crate
)
unsafe
fn
get_unchecked
(
&
self
len
:
u32
idx
:
usize
)
-
>
&
T
{
self
.
as_components
(
len
)
.
get_unchecked
(
idx
)
}
#
[
inline
]
pub
(
crate
)
const
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
entire_slice
}
pub
(
crate
)
unsafe
fn
get_bytes_at_mut
(
&
mut
self
len
:
u32
idx
:
usize
)
-
>
&
mut
[
u8
]
{
let
components
=
self
.
as_components
(
len
)
;
let
range
=
components
.
get_things_range
(
idx
)
;
let
offset
=
components
.
get_indices_size
(
)
;
#
[
expect
(
clippy
:
:
indexing_slicing
)
]
&
mut
self
.
entire_slice
[
offset
.
.
]
[
range
]
}
}
