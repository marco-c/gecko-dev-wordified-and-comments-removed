use
crate
:
:
ZeroSlice
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
;
use
crate
:
:
map
:
:
ZeroMapKV
;
use
crate
:
:
map
:
:
ZeroVecLike
;
use
crate
:
:
map2d
:
:
ZeroMap2dCursor
;
pub
struct
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
(
crate
)
keys0
:
&
'
a
K0
:
:
Slice
pub
(
crate
)
joiner
:
&
'
a
ZeroSlice
<
u32
>
pub
(
crate
)
keys1
:
&
'
a
K1
:
:
Slice
pub
(
crate
)
values
:
&
'
a
V
:
:
Slice
}
impl
<
'
a
K0
K1
V
>
Copy
for
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
}
impl
<
'
a
K0
K1
V
>
Clone
for
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
fn
clone
(
&
self
)
-
>
Self
{
ZeroMap2dBorrowed
{
keys0
:
self
.
keys0
joiner
:
self
.
joiner
keys1
:
self
.
keys1
values
:
self
.
values
}
}
}
impl
<
'
a
K0
K1
V
>
Default
for
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
:
Slice
:
'
static
K1
:
:
Slice
:
'
static
V
:
:
Slice
:
'
static
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
:
Slice
:
'
static
K1
:
:
Slice
:
'
static
V
:
:
Slice
:
'
static
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
fn
new
(
)
-
>
Self
{
Self
{
keys0
:
K0
:
:
Container
:
:
zvl_new_borrowed
(
)
joiner
:
Default
:
:
default
(
)
keys1
:
K1
:
:
Container
:
:
zvl_new_borrowed
(
)
values
:
V
:
:
Container
:
:
zvl_new_borrowed
(
)
}
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
#
[
doc
(
hidden
)
]
pub
const
unsafe
fn
from_parts_unchecked
(
keys0
:
&
'
a
K0
:
:
Slice
joiner
:
&
'
a
ZeroSlice
<
u32
>
keys1
:
&
'
a
K1
:
:
Slice
values
:
&
'
a
V
:
:
Slice
)
-
>
Self
{
Self
{
keys0
joiner
keys1
values
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
values
.
zvl_len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
values
.
zvl_len
(
)
=
=
0
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
Ord
K1
:
ZeroMapKV
<
'
a
>
+
Ord
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
fn
get_2d
(
&
self
key0
:
&
K0
key1
:
&
K1
)
-
>
Option
<
&
'
a
V
:
:
GetType
>
{
self
.
get0
(
key0
)
?
.
get1
(
key1
)
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
Ord
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
#
[
inline
]
pub
fn
get0
<
'
l
>
(
&
'
l
self
key0
:
&
K0
)
-
>
Option
<
ZeroMap2dCursor
<
'
a
'
a
K0
K1
V
>
>
{
let
key0_index
=
self
.
keys0
.
zvl_binary_search
(
key0
)
.
ok
(
)
?
;
Some
(
ZeroMap2dCursor
:
:
from_borrowed
(
self
key0_index
)
)
}
pub
fn
get0_by
<
'
l
>
(
&
'
l
self
predicate
:
impl
FnMut
(
&
K0
)
-
>
Ordering
)
-
>
Option
<
ZeroMap2dCursor
<
'
a
'
a
K0
K1
V
>
>
{
let
key0_index
=
self
.
keys0
.
zvl_binary_search_by
(
predicate
)
.
ok
(
)
?
;
Some
(
ZeroMap2dCursor
:
:
from_borrowed
(
self
key0_index
)
)
}
pub
fn
contains_key0
(
&
self
key0
:
&
K0
)
-
>
bool
{
self
.
keys0
.
zvl_binary_search
(
key0
)
.
is_ok
(
)
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
fn
iter0
<
'
l
>
(
&
'
l
self
)
-
>
impl
Iterator
<
Item
=
ZeroMap2dCursor
<
'
a
'
a
K0
K1
V
>
>
+
'
_
{
(
0
.
.
self
.
keys0
.
zvl_len
(
)
)
.
map
(
move
|
idx
|
ZeroMap2dCursor
:
:
from_borrowed
(
self
idx
)
)
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
Ord
K1
:
ZeroMapKV
<
'
a
>
+
Ord
V
:
ZeroMapKV
<
'
a
>
V
:
Copy
K0
:
?
Sized
K1
:
?
Sized
{
pub
fn
get_copied_2d
(
&
self
key0
:
&
K0
key1
:
&
K1
)
-
>
Option
<
V
>
{
self
.
get0
(
key0
)
?
.
get1_copied
(
key1
)
}
}
impl
<
'
a
'
b
K0
K1
V
>
PartialEq
<
ZeroMap2dBorrowed
<
'
b
K0
K1
V
>
>
for
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
for
<
'
c
>
ZeroMapKV
<
'
c
>
+
?
Sized
K1
:
for
<
'
c
>
ZeroMapKV
<
'
c
>
+
?
Sized
V
:
for
<
'
c
>
ZeroMapKV
<
'
c
>
+
?
Sized
<
K0
as
ZeroMapKV
<
'
a
>
>
:
:
Slice
:
PartialEq
<
<
K0
as
ZeroMapKV
<
'
b
>
>
:
:
Slice
>
<
K1
as
ZeroMapKV
<
'
a
>
>
:
:
Slice
:
PartialEq
<
<
K1
as
ZeroMapKV
<
'
b
>
>
:
:
Slice
>
<
V
as
ZeroMapKV
<
'
a
>
>
:
:
Slice
:
PartialEq
<
<
V
as
ZeroMapKV
<
'
b
>
>
:
:
Slice
>
{
fn
eq
(
&
self
other
:
&
ZeroMap2dBorrowed
<
'
b
K0
K1
V
>
)
-
>
bool
{
self
.
keys0
.
eq
(
other
.
keys0
)
&
&
self
.
joiner
.
eq
(
other
.
joiner
)
&
&
self
.
keys1
.
eq
(
other
.
keys1
)
&
&
self
.
values
.
eq
(
other
.
values
)
}
}
impl
<
'
a
K0
K1
V
>
fmt
:
:
Debug
for
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
?
Sized
K1
:
ZeroMapKV
<
'
a
>
+
?
Sized
V
:
ZeroMapKV
<
'
a
>
+
?
Sized
K0
:
:
Slice
:
fmt
:
:
Debug
K1
:
:
Slice
:
fmt
:
:
Debug
V
:
:
Slice
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
f
.
debug_struct
(
"
ZeroMap2dBorrowed
"
)
.
field
(
"
keys0
"
&
self
.
keys0
)
.
field
(
"
joiner
"
&
self
.
joiner
)
.
field
(
"
keys1
"
&
self
.
keys1
)
.
field
(
"
values
"
&
self
.
values
)
.
finish
(
)
}
}
