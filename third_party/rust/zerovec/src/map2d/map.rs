use
crate
:
:
ule
:
:
AsULE
;
use
crate
:
:
ZeroVec
;
use
alloc
:
:
borrow
:
:
Borrow
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
convert
:
:
TryFrom
;
use
core
:
:
fmt
;
use
core
:
:
iter
:
:
FromIterator
;
use
core
:
:
ops
:
:
Range
;
use
super
:
:
*
;
use
crate
:
:
map
:
:
ZeroMapKV
;
use
crate
:
:
map
:
:
{
MutableZeroVecLike
ZeroVecLike
}
;
pub
struct
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
(
crate
)
keys0
:
K0
:
:
Container
pub
(
crate
)
joiner
:
ZeroVec
<
'
a
u32
>
pub
(
crate
)
keys1
:
K1
:
:
Container
pub
(
crate
)
values
:
V
:
:
Container
}
impl
<
'
a
K0
K1
V
>
Default
for
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
fn
new
(
)
-
>
Self
{
Self
{
keys0
:
K0
:
:
Container
:
:
zvl_with_capacity
(
0
)
joiner
:
ZeroVec
:
:
new
(
)
keys1
:
K1
:
:
Container
:
:
zvl_with_capacity
(
0
)
values
:
V
:
:
Container
:
:
zvl_with_capacity
(
0
)
}
}
#
[
doc
(
hidden
)
]
pub
const
unsafe
fn
from_parts_unchecked
(
keys0
:
K0
:
:
Container
joiner
:
ZeroVec
<
'
a
u32
>
keys1
:
K1
:
:
Container
values
:
V
:
:
Container
)
-
>
Self
{
Self
{
keys0
joiner
keys1
values
}
}
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
keys0
:
K0
:
:
Container
:
:
zvl_with_capacity
(
capacity
)
joiner
:
ZeroVec
:
:
with_capacity
(
capacity
)
keys1
:
K1
:
:
Container
:
:
zvl_with_capacity
(
capacity
)
values
:
V
:
:
Container
:
:
zvl_with_capacity
(
capacity
)
}
}
pub
fn
as_borrowed
(
&
'
a
self
)
-
>
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
{
ZeroMap2dBorrowed
{
keys0
:
self
.
keys0
.
zvl_as_borrowed
(
)
joiner
:
&
self
.
joiner
keys1
:
self
.
keys1
.
zvl_as_borrowed
(
)
values
:
self
.
values
.
zvl_as_borrowed
(
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
values
.
zvl_len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
values
.
zvl_len
(
)
=
=
0
}
pub
fn
clear
(
&
mut
self
)
{
self
.
keys0
.
zvl_clear
(
)
;
self
.
joiner
.
clear
(
)
;
self
.
keys1
.
zvl_clear
(
)
;
self
.
values
.
zvl_clear
(
)
;
}
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
keys0
.
zvl_reserve
(
additional
)
;
self
.
joiner
.
zvl_reserve
(
additional
)
;
self
.
keys1
.
zvl_reserve
(
additional
)
;
self
.
values
.
zvl_reserve
(
additional
)
;
}
pub
fn
iter0
<
'
l
>
(
&
'
l
self
)
-
>
impl
Iterator
<
Item
=
ZeroMap2dCursor
<
'
l
'
a
K0
K1
V
>
>
+
'
l
{
(
0
.
.
self
.
keys0
.
zvl_len
(
)
)
.
map
(
move
|
idx
|
ZeroMap2dCursor
:
:
from_cow
(
self
idx
)
)
}
fn
get_range_for_key0_index
(
&
self
key0_index
:
usize
)
-
>
Range
<
usize
>
{
ZeroMap2dCursor
:
:
from_cow
(
self
key0_index
)
.
get_range
(
)
}
fn
remove_key0_index
(
&
mut
self
key0_index
:
usize
)
{
self
.
keys0
.
zvl_remove
(
key0_index
)
;
self
.
joiner
.
with_mut
(
|
v
|
v
.
remove
(
key0_index
)
)
;
}
fn
joiner_expand
(
&
mut
self
key0_index
:
usize
)
{
#
[
expect
(
clippy
:
:
expect_used
)
]
self
.
joiner
.
to_mut_slice
(
)
.
iter_mut
(
)
.
skip
(
key0_index
)
.
for_each
(
|
ref
mut
v
|
{
*
*
v
=
v
.
as_unsigned_int
(
)
.
checked_add
(
1
)
.
expect
(
"
Attempted
to
add
more
than
2
^
32
elements
to
a
ZeroMap2d
"
)
.
to_unaligned
(
)
}
)
}
fn
joiner_shrink
(
&
mut
self
key0_index
:
usize
)
{
self
.
joiner
.
to_mut_slice
(
)
.
iter_mut
(
)
.
skip
(
key0_index
)
.
for_each
(
|
ref
mut
v
|
*
*
v
=
(
v
.
as_unsigned_int
(
)
-
1
)
.
to_unaligned
(
)
)
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
Ord
K1
:
ZeroMapKV
<
'
a
>
+
Ord
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
pub
fn
get_2d
(
&
self
key0
:
&
K0
key1
:
&
K1
)
-
>
Option
<
&
V
:
:
GetType
>
{
self
.
get0
(
key0
)
?
.
get1
(
key1
)
}
pub
fn
insert
(
&
mut
self
key0
:
&
K0
key1
:
&
K1
value
:
&
V
)
-
>
Option
<
V
:
:
OwnedType
>
{
let
(
key0_index
range
)
=
self
.
get_or_insert_range_for_key0
(
key0
)
;
debug_assert
!
(
range
.
start
<
=
range
.
end
)
;
debug_assert
!
(
range
.
end
<
=
self
.
keys1
.
zvl_len
(
)
)
;
let
range_start
=
range
.
start
;
#
[
expect
(
clippy
:
:
unwrap_used
)
]
let
index
=
range_start
+
match
self
.
keys1
.
zvl_binary_search_in_range
(
key1
range
)
.
unwrap
(
)
{
Ok
(
index
)
=
>
return
Some
(
self
.
values
.
zvl_replace
(
range_start
+
index
value
)
)
Err
(
index
)
=
>
index
}
;
self
.
keys1
.
zvl_insert
(
index
key1
)
;
self
.
values
.
zvl_insert
(
index
value
)
;
self
.
joiner_expand
(
key0_index
)
;
#
[
cfg
(
debug_assertions
)
]
self
.
check_invariants
(
)
;
None
}
pub
fn
remove
(
&
mut
self
key0
:
&
K0
key1
:
&
K1
)
-
>
Option
<
V
:
:
OwnedType
>
{
let
key0_index
=
self
.
keys0
.
zvl_binary_search
(
key0
)
.
ok
(
)
?
;
let
range
=
self
.
get_range_for_key0_index
(
key0_index
)
;
debug_assert
!
(
range
.
start
<
range
.
end
)
;
debug_assert
!
(
range
.
end
<
=
self
.
keys1
.
zvl_len
(
)
)
;
let
is_singleton_range
=
range
.
start
+
1
=
=
range
.
end
;
#
[
expect
(
clippy
:
:
unwrap_used
)
]
let
index
=
range
.
start
+
self
.
keys1
.
zvl_binary_search_in_range
(
key1
range
)
.
unwrap
(
)
.
ok
(
)
?
;
self
.
keys1
.
zvl_remove
(
index
)
;
let
removed
=
self
.
values
.
zvl_remove
(
index
)
;
self
.
joiner_shrink
(
key0_index
)
;
if
is_singleton_range
{
self
.
remove_key0_index
(
key0_index
)
;
}
#
[
cfg
(
debug_assertions
)
]
self
.
check_invariants
(
)
;
Some
(
removed
)
}
#
[
must_use
]
pub
fn
try_append
<
'
b
>
(
&
mut
self
key0
:
&
'
b
K0
key1
:
&
'
b
K1
value
:
&
'
b
V
)
-
>
Option
<
(
&
'
b
K0
&
'
b
K1
&
'
b
V
)
>
{
if
self
.
is_empty
(
)
{
self
.
keys0
.
zvl_push
(
key0
)
;
self
.
joiner
.
with_mut
(
|
v
|
v
.
push
(
1u32
.
to_unaligned
(
)
)
)
;
self
.
keys1
.
zvl_push
(
key1
)
;
self
.
values
.
zvl_push
(
value
)
;
return
None
;
}
#
[
expect
(
clippy
:
:
unwrap_used
)
]
let
last_key0
=
self
.
keys0
.
zvl_get
(
self
.
keys0
.
zvl_len
(
)
-
1
)
.
unwrap
(
)
;
let
key0_cmp
=
K0
:
:
Container
:
:
t_cmp_get
(
key0
last_key0
)
;
#
[
expect
(
clippy
:
:
unwrap_used
)
]
let
last_key1
=
self
.
keys1
.
zvl_get
(
self
.
keys1
.
zvl_len
(
)
-
1
)
.
unwrap
(
)
;
let
key1_cmp
=
K1
:
:
Container
:
:
t_cmp_get
(
key1
last_key1
)
;
match
key0_cmp
{
Ordering
:
:
Less
=
>
{
return
Some
(
(
key0
key1
value
)
)
;
}
Ordering
:
:
Equal
=
>
{
match
key1_cmp
{
Ordering
:
:
Less
|
Ordering
:
:
Equal
=
>
{
return
Some
(
(
key0
key1
value
)
)
;
}
_
=
>
{
}
}
}
_
=
>
{
}
}
#
[
expect
(
clippy
:
:
expect_used
)
]
let
joiner_value
=
u32
:
:
try_from
(
self
.
keys1
.
zvl_len
(
)
+
1
)
.
expect
(
"
Attempted
to
add
more
than
2
^
32
elements
to
a
ZeroMap2d
"
)
;
#
[
expect
(
clippy
:
:
unwrap_used
)
]
if
key0_cmp
=
=
Ordering
:
:
Greater
{
self
.
keys0
.
zvl_push
(
key0
)
;
self
.
joiner
.
with_mut
(
|
v
|
v
.
push
(
joiner_value
.
to_unaligned
(
)
)
)
;
}
else
{
*
self
.
joiner
.
to_mut_slice
(
)
.
last_mut
(
)
.
unwrap
(
)
=
joiner_value
.
to_unaligned
(
)
;
}
self
.
keys1
.
zvl_push
(
key1
)
;
self
.
values
.
zvl_push
(
value
)
;
#
[
cfg
(
debug_assertions
)
]
self
.
check_invariants
(
)
;
None
}
#
[
cfg
(
debug_assertions
)
]
#
[
expect
(
clippy
:
:
unwrap_used
)
]
pub
(
crate
)
fn
check_invariants
(
&
self
)
{
debug_assert_eq
!
(
self
.
keys0
.
zvl_len
(
)
self
.
joiner
.
len
(
)
)
;
debug_assert_eq
!
(
self
.
keys1
.
zvl_len
(
)
self
.
values
.
zvl_len
(
)
)
;
debug_assert
!
(
self
.
keys0
.
zvl_is_ascending
(
)
)
;
debug_assert
!
(
self
.
joiner
.
zvl_is_ascending
(
)
)
;
if
let
Some
(
last_joiner
)
=
self
.
joiner
.
last
(
)
{
debug_assert_eq
!
(
last_joiner
as
usize
self
.
keys1
.
zvl_len
(
)
)
;
}
for
i
in
0
.
.
self
.
joiner
.
len
(
)
{
let
j0
=
if
i
=
=
0
{
0
}
else
{
self
.
joiner
.
get
(
i
-
1
)
.
unwrap
(
)
as
usize
}
;
let
j1
=
self
.
joiner
.
get
(
i
)
.
unwrap
(
)
as
usize
;
debug_assert_ne
!
(
j0
j1
)
;
for
j
in
(
j0
+
1
)
.
.
j1
{
let
m0
=
self
.
keys1
.
zvl_get
(
j
-
1
)
.
unwrap
(
)
;
let
m1
=
self
.
keys1
.
zvl_get
(
j
)
.
unwrap
(
)
;
debug_assert_eq
!
(
Ordering
:
:
Less
K1
:
:
Container
:
:
get_cmp_get
(
m0
m1
)
)
;
}
}
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
Ord
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
#
[
inline
]
pub
fn
get0
<
'
l
>
(
&
'
l
self
key0
:
&
K0
)
-
>
Option
<
ZeroMap2dCursor
<
'
l
'
a
K0
K1
V
>
>
{
let
key0_index
=
self
.
keys0
.
zvl_binary_search
(
key0
)
.
ok
(
)
?
;
Some
(
ZeroMap2dCursor
:
:
from_cow
(
self
key0_index
)
)
}
pub
fn
get0_by
<
'
l
>
(
&
'
l
self
predicate
:
impl
FnMut
(
&
K0
)
-
>
Ordering
)
-
>
Option
<
ZeroMap2dCursor
<
'
l
'
a
K0
K1
V
>
>
{
let
key0_index
=
self
.
keys0
.
zvl_binary_search_by
(
predicate
)
.
ok
(
)
?
;
Some
(
ZeroMap2dCursor
:
:
from_cow
(
self
key0_index
)
)
}
pub
fn
contains_key0
(
&
self
key0
:
&
K0
)
-
>
bool
{
self
.
keys0
.
zvl_binary_search
(
key0
)
.
is_ok
(
)
}
fn
get_or_insert_range_for_key0
(
&
mut
self
key0
:
&
K0
)
-
>
(
usize
Range
<
usize
>
)
{
match
self
.
keys0
.
zvl_binary_search
(
key0
)
{
Ok
(
key0_index
)
=
>
(
key0_index
self
.
get_range_for_key0_index
(
key0_index
)
)
Err
(
key0_index
)
=
>
{
let
joiner_value
=
if
key0_index
=
=
0
{
0
}
else
{
debug_assert
!
(
key0_index
<
=
self
.
joiner
.
len
(
)
)
;
#
[
expect
(
clippy
:
:
unwrap_used
)
]
self
.
joiner
.
get
(
key0_index
-
1
)
.
unwrap
(
)
}
;
self
.
keys0
.
zvl_insert
(
key0_index
key0
)
;
self
.
joiner
.
with_mut
(
|
v
|
v
.
insert
(
key0_index
joiner_value
.
to_unaligned
(
)
)
)
;
(
key0_index
(
joiner_value
as
usize
)
.
.
(
joiner_value
as
usize
)
)
}
}
}
}
impl
<
'
a
K0
K1
V
>
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
Ord
K1
:
ZeroMapKV
<
'
a
>
+
Ord
V
:
ZeroMapKV
<
'
a
>
V
:
Copy
K0
:
?
Sized
K1
:
?
Sized
{
#
[
inline
]
pub
fn
get_copied_2d
(
&
self
key0
:
&
K0
key1
:
&
K1
)
-
>
Option
<
V
>
{
self
.
get0
(
key0
)
?
.
get1_copied
(
key1
)
}
}
impl
<
'
a
K0
K1
V
>
From
<
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
>
for
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
K1
:
ZeroMapKV
<
'
a
>
V
:
ZeroMapKV
<
'
a
>
K0
:
?
Sized
K1
:
?
Sized
V
:
?
Sized
{
fn
from
(
other
:
ZeroMap2dBorrowed
<
'
a
K0
K1
V
>
)
-
>
Self
{
Self
{
keys0
:
K0
:
:
Container
:
:
zvl_from_borrowed
(
other
.
keys0
)
joiner
:
other
.
joiner
.
as_zerovec
(
)
keys1
:
K1
:
:
Container
:
:
zvl_from_borrowed
(
other
.
keys1
)
values
:
V
:
:
Container
:
:
zvl_from_borrowed
(
other
.
values
)
}
}
}
impl
<
'
a
'
b
K0
K1
V
>
PartialEq
<
ZeroMap2d
<
'
b
K0
K1
V
>
>
for
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
for
<
'
c
>
ZeroMapKV
<
'
c
>
+
?
Sized
K1
:
for
<
'
c
>
ZeroMapKV
<
'
c
>
+
?
Sized
V
:
for
<
'
c
>
ZeroMapKV
<
'
c
>
+
?
Sized
<
K0
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
PartialEq
<
<
K0
as
ZeroMapKV
<
'
b
>
>
:
:
Container
>
<
K1
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
PartialEq
<
<
K1
as
ZeroMapKV
<
'
b
>
>
:
:
Container
>
<
V
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
PartialEq
<
<
V
as
ZeroMapKV
<
'
b
>
>
:
:
Container
>
{
fn
eq
(
&
self
other
:
&
ZeroMap2d
<
'
b
K0
K1
V
>
)
-
>
bool
{
self
.
keys0
.
eq
(
&
other
.
keys0
)
&
&
self
.
joiner
.
eq
(
&
other
.
joiner
)
&
&
self
.
keys1
.
eq
(
&
other
.
keys1
)
&
&
self
.
values
.
eq
(
&
other
.
values
)
}
}
impl
<
'
a
K0
K1
V
>
fmt
:
:
Debug
for
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
?
Sized
K1
:
ZeroMapKV
<
'
a
>
+
?
Sized
V
:
ZeroMapKV
<
'
a
>
+
?
Sized
<
K0
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
fmt
:
:
Debug
<
K1
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
fmt
:
:
Debug
<
V
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
f
.
debug_struct
(
"
ZeroMap2d
"
)
.
field
(
"
keys0
"
&
self
.
keys0
)
.
field
(
"
joiner
"
&
self
.
joiner
)
.
field
(
"
keys1
"
&
self
.
keys1
)
.
field
(
"
values
"
&
self
.
values
)
.
finish
(
)
}
}
impl
<
'
a
K0
K1
V
>
Clone
for
ZeroMap2d
<
'
a
K0
K1
V
>
where
K0
:
ZeroMapKV
<
'
a
>
+
?
Sized
K1
:
ZeroMapKV
<
'
a
>
+
?
Sized
V
:
ZeroMapKV
<
'
a
>
+
?
Sized
<
K0
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
Clone
<
K1
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
Clone
<
V
as
ZeroMapKV
<
'
a
>
>
:
:
Container
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
Self
{
keys0
:
self
.
keys0
.
clone
(
)
joiner
:
self
.
joiner
.
clone
(
)
keys1
:
self
.
keys1
.
clone
(
)
values
:
self
.
values
.
clone
(
)
}
}
}
impl
<
'
a
A
B
C
K0
K1
V
>
FromIterator
<
(
A
B
C
)
>
for
ZeroMap2d
<
'
a
K0
K1
V
>
where
A
:
Borrow
<
K0
>
B
:
Borrow
<
K1
>
C
:
Borrow
<
V
>
K0
:
ZeroMapKV
<
'
a
>
+
?
Sized
+
Ord
K1
:
ZeroMapKV
<
'
a
>
+
?
Sized
+
Ord
V
:
ZeroMapKV
<
'
a
>
+
?
Sized
{
fn
from_iter
<
T
>
(
iter
:
T
)
-
>
Self
where
T
:
IntoIterator
<
Item
=
(
A
B
C
)
>
{
let
iter
=
iter
.
into_iter
(
)
;
let
mut
map
=
match
iter
.
size_hint
(
)
{
(
_
Some
(
upper
)
)
=
>
Self
:
:
with_capacity
(
upper
)
(
lower
None
)
=
>
Self
:
:
with_capacity
(
lower
)
}
;
for
(
key0
key1
value
)
in
iter
{
if
let
Some
(
(
key0
key1
value
)
)
=
map
.
try_append
(
key0
.
borrow
(
)
key1
.
borrow
(
)
value
.
borrow
(
)
)
{
map
.
insert
(
key0
key1
value
)
;
}
}
#
[
cfg
(
debug_assertions
)
]
map
.
check_invariants
(
)
;
map
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
alloc
:
:
collections
:
:
BTreeMap
;
#
[
test
]
fn
stress_test
(
)
{
let
mut
zm2d
=
ZeroMap2d
:
:
<
u16
str
str
>
:
:
new
(
)
;
assert_eq
!
(
format
!
(
"
{
zm2d
:
?
}
"
)
"
ZeroMap2d
{
keys0
:
ZeroVec
(
[
]
)
joiner
:
ZeroVec
(
[
]
)
keys1
:
[
]
values
:
[
]
}
"
)
;
assert_eq
!
(
zm2d
.
get0
(
&
0
)
None
)
;
let
result
=
zm2d
.
try_append
(
&
3
"
ccc
"
"
CCC
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
assert_eq
!
(
format
!
(
"
{
zm2d
:
?
}
"
)
"
ZeroMap2d
{
keys0
:
ZeroVec
(
[
3
]
)
joiner
:
ZeroVec
(
[
1
]
)
keys1
:
[
\
"
ccc
\
"
]
values
:
[
\
"
CCC
\
"
]
}
"
)
;
assert_eq
!
(
zm2d
.
get0
(
&
0
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
ccc
"
)
Some
(
"
CCC
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
99
)
None
)
;
let
result
=
zm2d
.
try_append
(
&
3
"
eee
"
"
EEE
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
assert_eq
!
(
format
!
(
"
{
zm2d
:
?
}
"
)
"
ZeroMap2d
{
keys0
:
ZeroVec
(
[
3
]
)
joiner
:
ZeroVec
(
[
2
]
)
keys1
:
[
\
"
ccc
\
"
\
"
eee
\
"
]
values
:
[
\
"
CCC
\
"
\
"
EEE
\
"
]
}
"
)
;
assert_eq
!
(
zm2d
.
get0
(
&
0
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
ccc
"
)
Some
(
"
CCC
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
eee
"
)
Some
(
"
EEE
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
five
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
99
)
None
)
;
let
result
=
zm2d
.
try_append
(
&
3
"
ddd
"
"
DD0
"
)
;
assert
!
(
result
.
is_some
(
)
)
;
let
result
=
zm2d
.
try_append
(
&
5
"
ddd
"
"
DD1
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
let
result
=
zm2d
.
try_append
(
&
7
"
ddd
"
"
DD2
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
let
result
=
zm2d
.
try_append
(
&
7
"
eee
"
"
EEE
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
let
result
=
zm2d
.
try_append
(
&
7
"
www
"
"
WWW
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
let
result
=
zm2d
.
try_append
(
&
9
"
yyy
"
"
YYY
"
)
;
assert
!
(
result
.
is_none
(
)
)
;
assert_eq
!
(
format
!
(
"
{
zm2d
:
?
}
"
)
"
ZeroMap2d
{
keys0
:
ZeroVec
(
[
3
5
7
9
]
)
joiner
:
ZeroVec
(
[
2
3
6
7
]
)
keys1
:
[
\
"
ccc
\
"
\
"
eee
\
"
\
"
ddd
\
"
\
"
ddd
\
"
\
"
eee
\
"
\
"
www
\
"
\
"
yyy
\
"
]
values
:
[
\
"
CCC
\
"
\
"
EEE
\
"
\
"
DD1
\
"
\
"
DD2
\
"
\
"
EEE
\
"
\
"
WWW
\
"
\
"
YYY
\
"
]
}
"
)
;
assert_eq
!
(
zm2d
.
get0
(
&
0
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
ccc
"
)
Some
(
"
CCC
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
eee
"
)
Some
(
"
EEE
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
4
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
5
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
5
"
ddd
"
)
Some
(
"
DD1
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
5
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
6
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
7
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
7
"
ddd
"
)
Some
(
"
DD2
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
7
"
eee
"
)
Some
(
"
EEE
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
7
"
www
"
)
Some
(
"
WWW
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
7
)
.
unwrap
(
)
.
get1
(
"
yyy
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
7
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
8
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
9
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
9
)
.
unwrap
(
)
.
get1
(
"
www
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
9
"
yyy
"
)
Some
(
"
YYY
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
9
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
10
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
99
)
None
)
;
zm2d
.
insert
(
&
3
"
mmm
"
"
MM0
"
)
;
zm2d
.
insert
(
&
6
"
ddd
"
"
DD3
"
)
;
zm2d
.
insert
(
&
6
"
mmm
"
"
MM1
"
)
;
zm2d
.
insert
(
&
6
"
nnn
"
"
NNN
"
)
;
assert_eq
!
(
format
!
(
"
{
zm2d
:
?
}
"
)
"
ZeroMap2d
{
keys0
:
ZeroVec
(
[
3
5
6
7
9
]
)
joiner
:
ZeroVec
(
[
3
4
7
10
11
]
)
keys1
:
[
\
"
ccc
\
"
\
"
eee
\
"
\
"
mmm
\
"
\
"
ddd
\
"
\
"
ddd
\
"
\
"
mmm
\
"
\
"
nnn
\
"
\
"
ddd
\
"
\
"
eee
\
"
\
"
www
\
"
\
"
yyy
\
"
]
values
:
[
\
"
CCC
\
"
\
"
EEE
\
"
\
"
MM0
\
"
\
"
DD1
\
"
\
"
DD3
\
"
\
"
MM1
\
"
\
"
NNN
\
"
\
"
DD2
\
"
\
"
EEE
\
"
\
"
WWW
\
"
\
"
YYY
\
"
]
}
"
)
;
assert_eq
!
(
zm2d
.
get0
(
&
0
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
ccc
"
)
Some
(
"
CCC
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
eee
"
)
Some
(
"
EEE
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
3
"
mmm
"
)
Some
(
"
MM0
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
3
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
4
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
5
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
5
"
ddd
"
)
Some
(
"
DD1
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
5
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
6
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
6
"
ddd
"
)
Some
(
"
DD3
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
6
"
mmm
"
)
Some
(
"
MM1
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
6
"
nnn
"
)
Some
(
"
NNN
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
6
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
7
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
7
"
ddd
"
)
Some
(
"
DD2
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
7
"
eee
"
)
Some
(
"
EEE
"
)
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
7
"
www
"
)
Some
(
"
WWW
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
7
)
.
unwrap
(
)
.
get1
(
"
yyy
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
7
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
8
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
9
)
.
unwrap
(
)
.
get1
(
"
aaa
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
9
)
.
unwrap
(
)
.
get1
(
"
www
"
)
None
)
;
assert_eq
!
(
zm2d
.
get_2d
(
&
9
"
yyy
"
)
Some
(
"
YYY
"
)
)
;
assert_eq
!
(
zm2d
.
get0
(
&
9
)
.
unwrap
(
)
.
get1
(
"
zzz
"
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
10
)
None
)
;
assert_eq
!
(
zm2d
.
get0
(
&
99
)
None
)
;
let
result
=
zm2d
.
remove
(
&
3
"
ccc
"
)
;
assert_eq
!
(
result
.
as_deref
(
)
Some
(
"
CCC
"
)
)
;
let
result
=
zm2d
.
remove
(
&
3
"
mmm
"
)
;
assert_eq
!
(
result
.
as_deref
(
)
Some
(
"
MM0
"
)
)
;
let
result
=
zm2d
.
remove
(
&
5
"
ddd
"
)
;
assert_eq
!
(
result
.
as_deref
(
)
Some
(
"
DD1
"
)
)
;
let
result
=
zm2d
.
remove
(
&
9
"
yyy
"
)
;
assert_eq
!
(
result
.
as_deref
(
)
Some
(
"
YYY
"
)
)
;
assert_eq
!
(
format
!
(
"
{
zm2d
:
?
}
"
)
"
ZeroMap2d
{
keys0
:
ZeroVec
(
[
3
6
7
]
)
joiner
:
ZeroVec
(
[
1
4
7
]
)
keys1
:
[
\
"
eee
\
"
\
"
ddd
\
"
\
"
mmm
\
"
\
"
nnn
\
"
\
"
ddd
\
"
\
"
eee
\
"
\
"
www
\
"
]
values
:
[
\
"
EEE
\
"
\
"
DD3
\
"
\
"
MM1
\
"
\
"
NNN
\
"
\
"
DD2
\
"
\
"
EEE
\
"
\
"
WWW
\
"
]
}
"
)
;
}
#
[
test
]
fn
zeromap2d_metazone
(
)
{
let
source_data
=
[
(
*
b
"
aedxb
"
0
Some
(
*
b
"
gulf
"
)
)
(
*
b
"
afkbl
"
0
Some
(
*
b
"
afgh
"
)
)
(
*
b
"
ushnl
"
0
None
)
(
*
b
"
ushnl
"
7272660
Some
(
*
b
"
haal
"
)
)
(
*
b
"
ushnl
"
0
None
)
(
*
b
"
ushnl
"
7272660
Some
(
*
b
"
haal
"
)
)
]
;
let
btreemap
:
BTreeMap
<
(
[
u8
;
5
]
i32
)
Option
<
[
u8
;
4
]
>
>
=
source_data
.
iter
(
)
.
copied
(
)
.
map
(
|
(
a
b
c
)
|
(
(
a
b
)
c
)
)
.
collect
(
)
;
let
zeromap2d
:
ZeroMap2d
<
[
u8
;
5
]
i32
Option
<
[
u8
;
4
]
>
>
=
source_data
.
iter
(
)
.
copied
(
)
.
collect
(
)
;
let
mut
btreemap_iter
=
btreemap
.
iter
(
)
;
for
cursor
in
zeromap2d
.
iter0
(
)
{
for
(
key1
value
)
in
cursor
.
iter1
(
)
{
let
expected
=
btreemap_iter
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
(
expected
.
0
.
0
expected
.
0
.
1
expected
.
1
)
(
*
cursor
.
key0
(
)
key1
.
as_unsigned_int
(
)
as
i32
&
value
.
get
(
)
)
)
;
}
}
assert
!
(
btreemap_iter
.
next
(
)
.
is_none
(
)
)
;
}
}
