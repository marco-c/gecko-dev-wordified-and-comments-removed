use
criterion
:
:
{
black_box
criterion_group
criterion_main
Criterion
}
;
use
rand
:
:
SeedableRng
;
use
rand_distr
:
:
{
Distribution
LogNormal
}
;
use
rand_pcg
:
:
Lcg64Xsh32
;
#
[
path
=
"
.
.
/
src
/
samples
.
rs
"
]
mod
samples
;
use
samples
:
:
*
;
use
zerovec
:
:
ZeroVec
;
#
[
allow
(
dead_code
)
]
fn
random_numbers
(
count
:
usize
)
-
>
Vec
<
u32
>
{
let
mut
rng
=
Lcg64Xsh32
:
:
seed_from_u64
(
2021
)
;
let
dist
=
LogNormal
:
:
new
(
10
.
0
1
.
0
)
.
unwrap
(
)
;
(
&
dist
)
.
sample_iter
(
&
mut
rng
)
.
take
(
count
)
.
map
(
|
f
|
f
as
u32
)
.
collect
(
)
}
fn
overview_bench
(
c
:
&
mut
Criterion
)
{
c
.
bench_function
(
"
zerovec_serde
/
overview
"
|
b
|
{
let
buffer
=
bincode
:
:
serialize
(
&
ZeroVec
:
:
<
u32
>
:
:
parse_bytes
(
black_box
(
TEST_BUFFER_LE
)
)
.
unwrap
(
)
)
.
unwrap
(
)
;
b
.
iter
(
|
|
{
bincode
:
:
deserialize
:
:
<
ZeroVec
<
u32
>
>
(
&
buffer
)
.
unwrap
(
)
.
iter
(
)
.
sum
:
:
<
u32
>
(
)
}
)
;
}
)
;
{
u32_benches
(
c
)
;
char_benches
(
c
)
;
stress_benches
(
c
)
;
}
}
fn
u32_benches
(
c
:
&
mut
Criterion
)
{
c
.
bench_function
(
"
zerovec_serde
/
serialize
/
u32
/
slice
"
|
b
|
{
b
.
iter
(
|
|
bincode
:
:
serialize
(
&
Vec
:
:
from
(
black_box
(
TEST_SLICE
)
)
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
deserialize_sum
/
u32
/
slice
"
|
b
|
{
let
buffer
=
bincode
:
:
serialize
(
&
Vec
:
:
from
(
black_box
(
TEST_SLICE
)
)
)
.
unwrap
(
)
;
b
.
iter
(
|
|
{
bincode
:
:
deserialize
:
:
<
Vec
<
u32
>
>
(
&
buffer
)
.
unwrap
(
)
.
iter
(
)
.
sum
:
:
<
u32
>
(
)
}
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
serialize
/
u32
/
zerovec
"
|
b
|
{
b
.
iter
(
|
|
bincode
:
:
serialize
(
&
ZeroVec
:
:
from_slice_or_alloc
(
black_box
(
TEST_SLICE
)
)
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
deserialize_sum
/
u32
/
zerovec
"
|
b
|
{
let
buffer
=
bincode
:
:
serialize
(
&
ZeroVec
:
:
<
u32
>
:
:
parse_bytes
(
black_box
(
TEST_BUFFER_LE
)
)
.
unwrap
(
)
)
.
unwrap
(
)
;
b
.
iter
(
|
|
{
bincode
:
:
deserialize
:
:
<
ZeroVec
<
u32
>
>
(
&
buffer
)
.
unwrap
(
)
.
iter
(
)
.
sum
:
:
<
u32
>
(
)
}
)
;
}
)
;
}
fn
char_benches
(
c
:
&
mut
Criterion
)
{
const
ORIGINAL_CHARS
:
&
[
char
]
=
&
[
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
]
;
let
char_zero_vec
=
&
ZeroVec
:
:
alloc_from_slice
(
ORIGINAL_CHARS
)
;
c
.
bench_function
(
"
zerovec_serde
/
serialize
/
char
/
slice
"
|
b
|
{
b
.
iter
(
|
|
bincode
:
:
serialize
(
black_box
(
&
Vec
:
:
from
(
ORIGINAL_CHARS
)
)
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
deserialize
/
char
/
slice
"
|
b
|
{
let
buffer
=
bincode
:
:
serialize
(
black_box
(
&
Vec
:
:
from
(
ORIGINAL_CHARS
)
)
)
.
unwrap
(
)
;
b
.
iter
(
|
|
bincode
:
:
deserialize
:
:
<
Vec
<
char
>
>
(
&
buffer
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
serialize
/
char
/
zerovec
"
|
b
|
{
b
.
iter
(
|
|
bincode
:
:
serialize
(
black_box
(
char_zero_vec
)
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
deserialize
/
char
/
zerovec
"
|
b
|
{
let
buffer
=
bincode
:
:
serialize
(
black_box
(
char_zero_vec
)
)
.
unwrap
(
)
;
b
.
iter
(
|
|
bincode
:
:
deserialize
:
:
<
ZeroVec
<
char
>
>
(
&
buffer
)
)
;
}
)
;
}
fn
stress_benches
(
c
:
&
mut
Criterion
)
{
let
number_vec
=
random_numbers
(
100
)
;
let
bincode_vec
=
bincode
:
:
serialize
(
&
number_vec
)
.
unwrap
(
)
;
let
zerovec_aligned
=
ZeroVec
:
:
from_slice_or_alloc
(
number_vec
.
as_slice
(
)
)
;
let
bincode_zerovec
=
bincode
:
:
serialize
(
&
zerovec_aligned
)
.
unwrap
(
)
;
c
.
bench_function
(
"
zerovec_serde
/
deserialize
/
stress
/
vec
"
|
b
|
{
b
.
iter
(
|
|
bincode
:
:
deserialize
:
:
<
Vec
<
u32
>
>
(
&
bincode_vec
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
deserialize
/
stress
/
zerovec
"
|
b
|
{
b
.
iter
(
|
|
bincode
:
:
deserialize
:
:
<
ZeroVec
<
u32
>
>
(
&
bincode_zerovec
)
)
;
}
)
;
c
.
bench_function
(
"
zerovec_serde
/
sum
/
stress
/
vec
"
|
b
|
{
b
.
iter
(
|
|
black_box
(
&
number_vec
)
.
iter
(
)
.
sum
:
:
<
u32
>
(
)
)
;
}
)
;
let
zerovec
=
ZeroVec
:
:
<
u32
>
:
:
parse_bytes
(
zerovec_aligned
.
as_bytes
(
)
)
.
unwrap
(
)
;
c
.
bench_function
(
"
zerovec_serde
/
sum
/
stress
/
zerovec
"
|
b
|
{
b
.
iter
(
|
|
black_box
(
&
zerovec
)
.
iter
(
)
.
sum
:
:
<
u32
>
(
)
)
;
}
)
;
}
criterion_group
!
(
benches
overview_bench
)
;
criterion_main
!
(
benches
)
;
