use
core
:
:
num
:
:
Wrapping
;
use
core
:
:
ops
:
:
{
Add
Mul
}
;
pub
trait
Zero
:
Sized
+
Add
<
Self
Output
=
Self
>
{
fn
zero
(
)
-
>
Self
;
fn
set_zero
(
&
mut
self
)
{
*
self
=
Zero
:
:
zero
(
)
;
}
fn
is_zero
(
&
self
)
-
>
bool
;
}
pub
trait
ConstZero
:
Zero
{
const
ZERO
:
Self
;
}
macro_rules
!
zero_impl
{
(
t
:
ty
v
:
expr
)
=
>
{
impl
Zero
for
t
{
#
[
inline
]
fn
zero
(
)
-
>
t
{
v
}
#
[
inline
]
fn
is_zero
(
&
self
)
-
>
bool
{
*
self
=
=
v
}
}
impl
ConstZero
for
t
{
const
ZERO
:
Self
=
v
;
}
}
;
}
zero_impl
!
(
usize
0
)
;
zero_impl
!
(
u8
0
)
;
zero_impl
!
(
u16
0
)
;
zero_impl
!
(
u32
0
)
;
zero_impl
!
(
u64
0
)
;
zero_impl
!
(
u128
0
)
;
zero_impl
!
(
isize
0
)
;
zero_impl
!
(
i8
0
)
;
zero_impl
!
(
i16
0
)
;
zero_impl
!
(
i32
0
)
;
zero_impl
!
(
i64
0
)
;
zero_impl
!
(
i128
0
)
;
zero_impl
!
(
f32
0
.
0
)
;
zero_impl
!
(
f64
0
.
0
)
;
impl
<
T
:
Zero
>
Zero
for
Wrapping
<
T
>
where
Wrapping
<
T
>
:
Add
<
Output
=
Wrapping
<
T
>
>
{
fn
is_zero
(
&
self
)
-
>
bool
{
self
.
0
.
is_zero
(
)
}
fn
set_zero
(
&
mut
self
)
{
self
.
0
.
set_zero
(
)
;
}
fn
zero
(
)
-
>
Self
{
Wrapping
(
T
:
:
zero
(
)
)
}
}
impl
<
T
:
ConstZero
>
ConstZero
for
Wrapping
<
T
>
where
Wrapping
<
T
>
:
Add
<
Output
=
Wrapping
<
T
>
>
{
const
ZERO
:
Self
=
Wrapping
(
T
:
:
ZERO
)
;
}
pub
trait
One
:
Sized
+
Mul
<
Self
Output
=
Self
>
{
fn
one
(
)
-
>
Self
;
fn
set_one
(
&
mut
self
)
{
*
self
=
One
:
:
one
(
)
;
}
#
[
inline
]
fn
is_one
(
&
self
)
-
>
bool
where
Self
:
PartialEq
{
*
self
=
=
Self
:
:
one
(
)
}
}
pub
trait
ConstOne
:
One
{
const
ONE
:
Self
;
}
macro_rules
!
one_impl
{
(
t
:
ty
v
:
expr
)
=
>
{
impl
One
for
t
{
#
[
inline
]
fn
one
(
)
-
>
t
{
v
}
#
[
inline
]
fn
is_one
(
&
self
)
-
>
bool
{
*
self
=
=
v
}
}
impl
ConstOne
for
t
{
const
ONE
:
Self
=
v
;
}
}
;
}
one_impl
!
(
usize
1
)
;
one_impl
!
(
u8
1
)
;
one_impl
!
(
u16
1
)
;
one_impl
!
(
u32
1
)
;
one_impl
!
(
u64
1
)
;
one_impl
!
(
u128
1
)
;
one_impl
!
(
isize
1
)
;
one_impl
!
(
i8
1
)
;
one_impl
!
(
i16
1
)
;
one_impl
!
(
i32
1
)
;
one_impl
!
(
i64
1
)
;
one_impl
!
(
i128
1
)
;
one_impl
!
(
f32
1
.
0
)
;
one_impl
!
(
f64
1
.
0
)
;
impl
<
T
:
One
>
One
for
Wrapping
<
T
>
where
Wrapping
<
T
>
:
Mul
<
Output
=
Wrapping
<
T
>
>
{
fn
set_one
(
&
mut
self
)
{
self
.
0
.
set_one
(
)
;
}
fn
one
(
)
-
>
Self
{
Wrapping
(
T
:
:
one
(
)
)
}
}
impl
<
T
:
ConstOne
>
ConstOne
for
Wrapping
<
T
>
where
Wrapping
<
T
>
:
Mul
<
Output
=
Wrapping
<
T
>
>
{
const
ONE
:
Self
=
Wrapping
(
T
:
:
ONE
)
;
}
#
[
inline
(
always
)
]
pub
fn
zero
<
T
:
Zero
>
(
)
-
>
T
{
Zero
:
:
zero
(
)
}
#
[
inline
(
always
)
]
pub
fn
one
<
T
:
One
>
(
)
-
>
T
{
One
:
:
one
(
)
}
#
[
test
]
fn
wrapping_identities
(
)
{
macro_rules
!
test_wrapping_identities
{
(
(
t
:
ty
)
+
)
=
>
{
(
assert_eq
!
(
zero
:
:
<
t
>
(
)
zero
:
:
<
Wrapping
<
t
>
>
(
)
.
0
)
;
assert_eq
!
(
one
:
:
<
t
>
(
)
one
:
:
<
Wrapping
<
t
>
>
(
)
.
0
)
;
assert_eq
!
(
(
0
as
t
)
.
is_zero
(
)
Wrapping
(
0
as
t
)
.
is_zero
(
)
)
;
assert_eq
!
(
(
1
as
t
)
.
is_zero
(
)
Wrapping
(
1
as
t
)
.
is_zero
(
)
)
;
)
+
}
;
}
test_wrapping_identities
!
(
isize
i8
i16
i32
i64
usize
u8
u16
u32
u64
)
;
}
#
[
test
]
fn
wrapping_is_zero
(
)
{
fn
require_zero
<
T
:
Zero
>
(
_
:
&
T
)
{
}
require_zero
(
&
Wrapping
(
42
)
)
;
}
#
[
test
]
fn
wrapping_is_one
(
)
{
fn
require_one
<
T
:
One
>
(
_
:
&
T
)
{
}
require_one
(
&
Wrapping
(
42
)
)
;
}
