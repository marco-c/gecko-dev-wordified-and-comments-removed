pub
trait
MulAdd
<
A
=
Self
B
=
Self
>
{
type
Output
;
fn
mul_add
(
self
a
:
A
b
:
B
)
-
>
Self
:
:
Output
;
}
pub
trait
MulAddAssign
<
A
=
Self
B
=
Self
>
{
fn
mul_add_assign
(
&
mut
self
a
:
A
b
:
B
)
;
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
libm
"
)
)
]
impl
MulAdd
<
f32
f32
>
for
f32
{
type
Output
=
Self
;
#
[
inline
]
fn
mul_add
(
self
a
:
Self
b
:
Self
)
-
>
Self
:
:
Output
{
<
Self
as
:
:
Float
>
:
:
mul_add
(
self
a
b
)
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
libm
"
)
)
]
impl
MulAdd
<
f64
f64
>
for
f64
{
type
Output
=
Self
;
#
[
inline
]
fn
mul_add
(
self
a
:
Self
b
:
Self
)
-
>
Self
:
:
Output
{
<
Self
as
:
:
Float
>
:
:
mul_add
(
self
a
b
)
}
}
macro_rules
!
mul_add_impl
{
(
trait_name
:
ident
for
(
t
:
ty
)
*
)
=
>
{
(
impl
trait_name
for
t
{
type
Output
=
Self
;
#
[
inline
]
fn
mul_add
(
self
a
:
Self
b
:
Self
)
-
>
Self
:
:
Output
{
(
self
*
a
)
+
b
}
}
)
*
}
}
mul_add_impl
!
(
MulAdd
for
isize
usize
i8
u8
i16
u16
i32
u32
i64
u64
)
;
#
[
cfg
(
has_i128
)
]
mul_add_impl
!
(
MulAdd
for
i128
u128
)
;
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
libm
"
)
)
]
impl
MulAddAssign
<
f32
f32
>
for
f32
{
#
[
inline
]
fn
mul_add_assign
(
&
mut
self
a
:
Self
b
:
Self
)
{
*
self
=
<
Self
as
:
:
Float
>
:
:
mul_add
(
*
self
a
b
)
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
libm
"
)
)
]
impl
MulAddAssign
<
f64
f64
>
for
f64
{
#
[
inline
]
fn
mul_add_assign
(
&
mut
self
a
:
Self
b
:
Self
)
{
*
self
=
<
Self
as
:
:
Float
>
:
:
mul_add
(
*
self
a
b
)
}
}
macro_rules
!
mul_add_assign_impl
{
(
trait_name
:
ident
for
(
t
:
ty
)
*
)
=
>
{
(
impl
trait_name
for
t
{
#
[
inline
]
fn
mul_add_assign
(
&
mut
self
a
:
Self
b
:
Self
)
{
*
self
=
(
*
self
*
a
)
+
b
}
}
)
*
}
}
mul_add_assign_impl
!
(
MulAddAssign
for
isize
usize
i8
u8
i16
u16
i32
u32
i64
u64
)
;
#
[
cfg
(
has_i128
)
]
mul_add_assign_impl
!
(
MulAddAssign
for
i128
u128
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
mul_add_integer
(
)
{
macro_rules
!
test_mul_add
{
(
(
t
:
ident
)
+
)
=
>
{
(
{
let
m
:
t
=
2
;
let
x
:
t
=
3
;
let
b
:
t
=
4
;
assert_eq
!
(
MulAdd
:
:
mul_add
(
m
x
b
)
(
m
*
x
+
b
)
)
;
}
)
+
}
;
}
test_mul_add
!
(
usize
u8
u16
u32
u64
isize
i8
i16
i32
i64
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
mul_add_float
(
)
{
macro_rules
!
test_mul_add
{
(
(
t
:
ident
)
+
)
=
>
{
(
{
use
core
:
:
t
;
let
m
:
t
=
12
.
0
;
let
x
:
t
=
3
.
4
;
let
b
:
t
=
5
.
6
;
let
abs_difference
=
(
MulAdd
:
:
mul_add
(
m
x
b
)
-
(
m
*
x
+
b
)
)
.
abs
(
)
;
assert
!
(
abs_difference
<
=
46
.
4
*
t
:
:
EPSILON
)
;
}
)
+
}
;
}
test_mul_add
!
(
f32
f64
)
;
}
}
