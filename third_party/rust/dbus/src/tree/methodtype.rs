use
std
:
:
fmt
;
use
{
ErrorName
Message
stdintf
}
;
use
arg
:
:
{
Iter
IterAppend
TypeMismatchError
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
super
:
:
{
Method
Interface
Property
ObjectPath
Tree
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
ffi
:
:
CString
;
use
super
:
:
super
:
:
Error
as
dbusError
;
#
[
derive
(
Clone
Debug
PartialOrd
Ord
PartialEq
Eq
)
]
pub
struct
MethodErr
(
ErrorName
<
'
static
>
String
)
;
impl
MethodErr
{
pub
fn
invalid_arg
<
T
:
fmt
:
:
Debug
>
(
a
:
&
T
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
InvalidArgs
"
format
!
(
"
Invalid
argument
{
:
?
}
"
a
)
)
.
into
(
)
}
pub
fn
no_arg
(
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
InvalidArgs
"
"
Not
enough
arguments
"
)
.
into
(
)
}
pub
fn
failed
<
T
:
fmt
:
:
Display
>
(
a
:
&
T
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
Failed
"
a
.
to_string
(
)
)
.
into
(
)
}
pub
fn
no_interface
<
T
:
fmt
:
:
Display
>
(
a
:
&
T
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
UnknownInterface
"
format
!
(
"
Unknown
interface
{
}
"
a
)
)
.
into
(
)
}
pub
fn
no_method
<
T
:
fmt
:
:
Display
>
(
a
:
&
T
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
UnknownMethod
"
format
!
(
"
Unknown
method
{
}
"
a
)
)
.
into
(
)
}
pub
fn
no_property
<
T
:
fmt
:
:
Display
>
(
a
:
&
T
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
UnknownProperty
"
format
!
(
"
Unknown
property
{
}
"
a
)
)
.
into
(
)
}
pub
fn
ro_property
<
T
:
fmt
:
:
Display
>
(
a
:
&
T
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
PropertyReadOnly
"
format
!
(
"
Property
{
}
is
read
only
"
a
)
)
.
into
(
)
}
pub
fn
errorname
(
&
self
)
-
>
&
ErrorName
<
'
static
>
{
&
self
.
0
}
pub
fn
description
(
&
self
)
-
>
&
str
{
&
self
.
1
}
pub
fn
to_message
(
&
self
msg
:
&
Message
)
-
>
Message
{
msg
.
error
(
&
self
.
0
&
CString
:
:
new
(
&
*
self
.
1
)
.
unwrap
(
)
)
}
}
impl
From
<
TypeMismatchError
>
for
MethodErr
{
fn
from
(
t
:
TypeMismatchError
)
-
>
MethodErr
{
(
"
org
.
freedesktop
.
DBus
.
Error
.
Failed
"
format
!
(
"
{
}
"
t
)
)
.
into
(
)
}
}
impl
<
T
:
Into
<
ErrorName
<
'
static
>
>
M
:
Into
<
String
>
>
From
<
(
T
M
)
>
for
MethodErr
{
fn
from
(
(
t
m
)
:
(
T
M
)
)
-
>
MethodErr
{
MethodErr
(
t
.
into
(
)
m
.
into
(
)
)
}
}
impl
From
<
dbusError
>
for
MethodErr
{
fn
from
(
t
:
dbusError
)
-
>
MethodErr
{
let
n
=
t
.
name
(
)
.
unwrap_or
(
"
org
.
freedesktop
.
DBus
.
Error
.
Failed
"
)
;
let
m
=
t
.
message
(
)
.
unwrap_or
(
"
Unknown
error
"
)
;
MethodErr
(
String
:
:
from
(
n
)
.
into
(
)
m
.
into
(
)
)
}
}
pub
type
MethodResult
=
Result
<
Vec
<
Message
>
MethodErr
>
;
pub
trait
DataType
:
Sized
+
Default
{
type
Tree
:
fmt
:
:
Debug
;
type
ObjectPath
:
fmt
:
:
Debug
;
type
Property
:
fmt
:
:
Debug
;
type
Interface
:
fmt
:
:
Debug
;
type
Method
:
fmt
:
:
Debug
;
type
Signal
:
fmt
:
:
Debug
;
}
impl
DataType
for
(
)
{
type
Tree
=
(
)
;
type
ObjectPath
=
(
)
;
type
Interface
=
(
)
;
type
Property
=
(
)
;
type
Method
=
(
)
;
type
Signal
=
(
)
;
}
pub
trait
MethodType
<
D
:
DataType
>
:
Sized
+
Default
{
type
Method
:
?
Sized
;
type
GetProp
:
?
Sized
;
type
SetProp
:
?
Sized
;
fn
call_getprop
(
&
Self
:
:
GetProp
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
;
fn
call_setprop
(
&
Self
:
:
SetProp
&
mut
Iter
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
;
fn
call_method
(
&
Self
:
:
Method
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
;
fn
make_getprop
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
GetProp
>
where
H
:
Fn
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
+
Send
+
Sync
+
'
static
;
fn
make_method
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
Method
>
where
H
:
Fn
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
+
Send
+
Sync
+
'
static
;
}
#
[
derive
(
Default
Debug
Copy
Clone
)
]
pub
struct
MTFn
<
D
=
(
)
>
(
PhantomData
<
*
const
D
>
)
;
impl
<
D
:
DataType
>
MethodType
<
D
>
for
MTFn
<
D
>
{
type
GetProp
=
Fn
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
;
type
SetProp
=
Fn
(
&
mut
Iter
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
;
type
Method
=
Fn
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
;
fn
call_getprop
(
p
:
&
Self
:
:
GetProp
i
:
&
mut
IterAppend
pinfo
:
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
{
p
(
i
pinfo
)
}
fn
call_setprop
(
p
:
&
Self
:
:
SetProp
i
:
&
mut
Iter
pinfo
:
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
{
p
(
i
pinfo
)
}
fn
call_method
(
p
:
&
Self
:
:
Method
minfo
:
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
{
p
(
minfo
)
}
fn
make_getprop
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
GetProp
>
where
H
:
Fn
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
h
)
}
fn
make_method
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
Method
>
where
H
:
Fn
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
h
)
}
}
#
[
derive
(
Default
Debug
Copy
Clone
)
]
pub
struct
MTFnMut
<
D
=
(
)
>
(
PhantomData
<
*
const
D
>
)
;
impl
<
D
:
DataType
>
MethodType
<
D
>
for
MTFnMut
<
D
>
{
type
GetProp
=
RefCell
<
FnMut
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
>
;
type
SetProp
=
RefCell
<
FnMut
(
&
mut
Iter
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
>
;
type
Method
=
RefCell
<
FnMut
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
>
;
fn
call_getprop
(
p
:
&
Self
:
:
GetProp
i
:
&
mut
IterAppend
pinfo
:
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
{
(
&
mut
*
p
.
borrow_mut
(
)
)
(
i
pinfo
)
}
fn
call_setprop
(
p
:
&
Self
:
:
SetProp
i
:
&
mut
Iter
pinfo
:
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
{
(
&
mut
*
p
.
borrow_mut
(
)
)
(
i
pinfo
)
}
fn
call_method
(
p
:
&
Self
:
:
Method
minfo
:
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
{
(
&
mut
*
p
.
borrow_mut
(
)
)
(
minfo
)
}
fn
make_getprop
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
GetProp
>
where
H
:
Fn
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
RefCell
:
:
new
(
h
)
)
}
fn
make_method
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
Method
>
where
H
:
Fn
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
RefCell
:
:
new
(
h
)
)
}
}
#
[
derive
(
Default
Debug
Copy
Clone
)
]
pub
struct
MTSync
<
D
=
(
)
>
(
PhantomData
<
*
const
D
>
)
;
impl
<
D
:
DataType
>
MethodType
<
D
>
for
MTSync
<
D
>
{
type
GetProp
=
Fn
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
+
Send
+
Sync
+
'
static
;
type
SetProp
=
Fn
(
&
mut
Iter
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
+
Send
+
Sync
+
'
static
;
type
Method
=
Fn
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
+
Send
+
Sync
+
'
static
;
fn
call_getprop
(
p
:
&
Self
:
:
GetProp
i
:
&
mut
IterAppend
pinfo
:
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
{
p
(
i
pinfo
)
}
fn
call_setprop
(
p
:
&
Self
:
:
SetProp
i
:
&
mut
Iter
pinfo
:
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
{
p
(
i
pinfo
)
}
fn
call_method
(
p
:
&
Self
:
:
Method
minfo
:
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
{
p
(
minfo
)
}
fn
make_getprop
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
GetProp
>
where
H
:
Fn
(
&
mut
IterAppend
&
PropInfo
<
Self
D
>
)
-
>
Result
<
(
)
MethodErr
>
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
h
)
}
fn
make_method
<
H
>
(
h
:
H
)
-
>
Box
<
Self
:
:
Method
>
where
H
:
Fn
(
&
MethodInfo
<
Self
D
>
)
-
>
MethodResult
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
h
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
MethodInfo
<
'
a
M
:
'
a
+
MethodType
<
D
>
D
:
'
a
+
DataType
>
{
pub
msg
:
&
'
a
Message
pub
method
:
&
'
a
Method
<
M
D
>
pub
iface
:
&
'
a
Interface
<
M
D
>
pub
path
:
&
'
a
ObjectPath
<
M
D
>
pub
tree
:
&
'
a
Tree
<
M
D
>
}
impl
<
'
a
M
:
'
a
+
MethodType
<
D
>
D
:
'
a
+
DataType
>
MethodInfo
<
'
a
M
D
>
{
pub
fn
to_prop_info
(
&
self
iface
:
&
'
a
Interface
<
M
D
>
prop
:
&
'
a
Property
<
M
D
>
)
-
>
PropInfo
<
'
a
M
D
>
{
PropInfo
{
msg
:
self
.
msg
method
:
self
.
method
iface
:
iface
prop
:
prop
path
:
self
.
path
tree
:
self
.
tree
}
}
}
impl
<
'
a
M
:
'
a
+
MethodType
<
D
>
D
:
'
a
+
DataType
>
stdintf
:
:
OrgFreedesktopDBusIntrospectable
for
MethodInfo
<
'
a
M
D
>
{
type
Err
=
MethodErr
;
fn
introspect
(
&
self
)
-
>
Result
<
String
Self
:
:
Err
>
{
Ok
(
self
.
path
.
introspect
(
self
.
tree
)
)
}
}
pub
fn
org_freedesktop_dbus_introspectable_server
<
M
D
>
(
factory
:
&
super
:
:
Factory
<
M
D
>
data
:
D
:
:
Interface
)
-
>
super
:
:
Interface
<
M
D
>
where
D
:
super
:
:
DataType
D
:
:
Method
:
Default
M
:
MethodType
<
D
>
{
let
i
=
factory
.
interface
(
"
org
.
freedesktop
.
DBus
.
Introspectable
"
data
)
;
let
h
=
move
|
minfo
:
&
super
:
:
MethodInfo
<
M
D
>
|
{
let
d
:
&
stdintf
:
:
OrgFreedesktopDBusIntrospectable
<
Err
=
super
:
:
MethodErr
>
=
minfo
;
let
arg0
=
try
!
(
d
.
introspect
(
)
)
;
let
rm
=
minfo
.
msg
.
method_return
(
)
;
let
rm
=
rm
.
append1
(
arg0
)
;
Ok
(
vec
!
(
rm
)
)
}
;
let
m
=
factory
.
method_sync
(
"
Introspect
"
Default
:
:
default
(
)
h
)
;
let
m
=
m
.
out_arg
(
(
"
xml_data
"
"
s
"
)
)
;
let
i
=
i
.
add_m
(
m
)
;
i
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
PropInfo
<
'
a
M
:
'
a
+
MethodType
<
D
>
D
:
'
a
+
DataType
>
{
pub
msg
:
&
'
a
Message
pub
method
:
&
'
a
Method
<
M
D
>
pub
prop
:
&
'
a
Property
<
M
D
>
pub
iface
:
&
'
a
Interface
<
M
D
>
pub
path
:
&
'
a
ObjectPath
<
M
D
>
pub
tree
:
&
'
a
Tree
<
M
D
>
}
impl
<
'
a
M
:
'
a
+
MethodType
<
D
>
D
:
'
a
+
DataType
>
PropInfo
<
'
a
M
D
>
{
pub
fn
to_method_info
(
&
self
)
-
>
MethodInfo
<
'
a
M
D
>
{
MethodInfo
{
msg
:
self
.
msg
method
:
self
.
method
iface
:
self
.
iface
path
:
self
.
path
tree
:
self
.
tree
}
}
}
