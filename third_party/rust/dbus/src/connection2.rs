use
crate
:
:
{
BusType
Error
Message
to_c_str
Watch
}
;
use
std
:
:
{
ptr
str
}
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
os
:
:
raw
:
:
{
c_void
}
;
#
[
derive
(
Debug
)
]
pub
struct
ConnHandle
(
*
mut
ffi
:
:
DBusConnection
)
;
unsafe
impl
Send
for
ConnHandle
{
}
unsafe
impl
Sync
for
ConnHandle
{
}
impl
Drop
for
ConnHandle
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ffi
:
:
dbus_connection_close
(
self
.
0
)
;
ffi
:
:
dbus_connection_unref
(
self
.
0
)
;
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
TxRx
{
handle
:
ConnHandle
}
impl
TxRx
{
#
[
inline
(
always
)
]
pub
(
crate
)
fn
conn
(
&
self
)
-
>
*
mut
ffi
:
:
DBusConnection
{
self
.
handle
.
0
}
fn
conn_from_ptr
(
ptr
:
*
mut
ffi
:
:
DBusConnection
)
-
>
Result
<
TxRx
Error
>
{
let
handle
=
ConnHandle
(
ptr
)
;
unsafe
{
ffi
:
:
dbus_connection_set_exit_on_disconnect
(
ptr
0
)
}
;
let
c
=
TxRx
{
handle
}
;
Ok
(
c
)
}
pub
fn
get_private
(
bus
:
BusType
)
-
>
Result
<
TxRx
Error
>
{
let
mut
e
=
Error
:
:
empty
(
)
;
let
conn
=
unsafe
{
ffi
:
:
dbus_bus_get_private
(
bus
e
.
get_mut
(
)
)
}
;
if
conn
=
=
ptr
:
:
null_mut
(
)
{
return
Err
(
e
)
}
Self
:
:
conn_from_ptr
(
conn
)
}
pub
fn
open_private
(
address
:
&
str
)
-
>
Result
<
TxRx
Error
>
{
let
mut
e
=
Error
:
:
empty
(
)
;
let
conn
=
unsafe
{
ffi
:
:
dbus_connection_open_private
(
to_c_str
(
address
)
.
as_ptr
(
)
e
.
get_mut
(
)
)
}
;
if
conn
=
=
ptr
:
:
null_mut
(
)
{
return
Err
(
e
)
}
Self
:
:
conn_from_ptr
(
conn
)
}
pub
fn
register
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
let
mut
e
=
Error
:
:
empty
(
)
;
if
unsafe
{
ffi
:
:
dbus_bus_register
(
self
.
conn
(
)
e
.
get_mut
(
)
)
=
=
0
}
{
Err
(
e
)
}
else
{
Ok
(
(
)
)
}
}
pub
fn
is_connected
(
&
self
)
-
>
bool
{
unsafe
{
ffi
:
:
dbus_connection_get_is_connected
(
self
.
conn
(
)
)
!
=
0
}
}
pub
fn
unique_name
(
&
self
)
-
>
Option
<
&
str
>
{
let
c
=
unsafe
{
ffi
:
:
dbus_bus_get_unique_name
(
self
.
conn
(
)
)
}
;
if
c
=
=
ptr
:
:
null_mut
(
)
{
return
None
;
}
let
s
=
unsafe
{
CStr
:
:
from_ptr
(
c
)
}
;
str
:
:
from_utf8
(
s
.
to_bytes
(
)
)
.
ok
(
)
}
pub
fn
send
(
&
self
msg
:
Message
)
-
>
Result
<
u32
(
)
>
{
let
mut
serial
=
0u32
;
let
r
=
unsafe
{
ffi
:
:
dbus_connection_send
(
self
.
conn
(
)
msg
.
ptr
(
)
&
mut
serial
)
}
;
if
r
=
=
0
{
return
Err
(
(
)
)
;
}
Ok
(
serial
)
}
pub
fn
flush
(
&
self
)
{
unsafe
{
ffi
:
:
dbus_connection_flush
(
self
.
conn
(
)
)
}
}
pub
fn
read_write
(
&
self
timeout_ms
:
Option
<
i32
>
)
-
>
Result
<
(
)
(
)
>
{
let
t
=
timeout_ms
.
unwrap_or
(
-
1
)
;
if
unsafe
{
ffi
:
:
dbus_connection_read_write
(
self
.
conn
(
)
t
)
=
=
0
}
{
Err
(
(
)
)
}
else
{
Ok
(
(
)
)
}
}
pub
fn
pop_message
(
&
self
)
-
>
Option
<
Message
>
{
let
mptr
=
unsafe
{
ffi
:
:
dbus_connection_pop_message
(
self
.
conn
(
)
)
}
;
if
mptr
=
=
ptr
:
:
null_mut
(
)
{
None
}
else
{
Some
(
Message
:
:
from_ptr
(
mptr
false
)
)
}
}
pub
fn
watch_fds
(
&
mut
self
)
-
>
Result
<
Vec
<
Watch
>
(
)
>
{
extern
"
C
"
fn
add_watch_cb
(
watch
:
*
mut
ffi
:
:
DBusWatch
data
:
*
mut
c_void
)
-
>
u32
{
unsafe
{
let
wlist
:
&
mut
Vec
<
Watch
>
=
&
mut
*
(
data
as
*
mut
_
)
;
wlist
.
push
(
Watch
:
:
from_raw
(
watch
)
)
;
}
1
}
let
mut
r
=
vec
!
(
)
;
if
unsafe
{
ffi
:
:
dbus_connection_set_watch_functions
(
self
.
conn
(
)
Some
(
add_watch_cb
)
None
None
&
mut
r
as
*
mut
_
as
*
mut
_
None
)
}
=
=
0
{
return
Err
(
(
)
)
}
assert
!
(
unsafe
{
ffi
:
:
dbus_connection_set_watch_functions
(
self
.
conn
(
)
None
None
None
ptr
:
:
null_mut
(
)
None
)
}
!
=
0
)
;
Ok
(
r
)
}
}
#
[
test
]
fn
test_txrx_send_sync
(
)
{
fn
is_send
<
T
:
Send
>
(
_
:
&
T
)
{
}
fn
is_sync
<
T
:
Sync
>
(
_
:
&
T
)
{
}
let
c
=
TxRx
:
:
get_private
(
BusType
:
:
Session
)
.
unwrap
(
)
;
is_send
(
&
c
)
;
is_sync
(
&
c
)
;
}
#
[
test
]
fn
txrx_simple_test
(
)
{
let
mut
c
=
TxRx
:
:
get_private
(
BusType
:
:
Session
)
.
unwrap
(
)
;
assert
!
(
c
.
is_connected
(
)
)
;
let
fds
=
c
.
watch_fds
(
)
.
unwrap
(
)
;
println
!
(
"
{
:
?
}
"
fds
)
;
assert
!
(
fds
.
len
(
)
>
0
)
;
let
m
=
Message
:
:
new_method_call
(
"
org
.
freedesktop
.
DBus
"
"
/
"
"
org
.
freedesktop
.
DBus
"
"
ListNames
"
)
.
unwrap
(
)
;
let
reply
=
c
.
send
(
m
)
.
unwrap
(
)
;
let
my_name
=
c
.
unique_name
(
)
.
unwrap
(
)
;
loop
{
while
let
Some
(
mut
msg
)
=
c
.
pop_message
(
)
{
println
!
(
"
{
:
?
}
"
msg
)
;
if
msg
.
get_reply_serial
(
)
=
=
Some
(
reply
)
{
let
r
=
msg
.
as_result
(
)
.
unwrap
(
)
;
let
z
:
:
:
arg
:
:
Array
<
&
str
_
>
=
r
.
get1
(
)
.
unwrap
(
)
;
for
n
in
z
{
println
!
(
"
{
}
"
n
)
;
if
n
=
=
my_name
{
return
;
}
}
assert
!
(
false
)
;
}
else
if
let
Some
(
r
)
=
crate
:
:
MessageDispatcher
:
:
<
(
)
>
:
:
default_dispatch
(
&
msg
)
{
c
.
send
(
r
)
.
unwrap
(
)
;
}
}
c
.
read_write
(
Some
(
100
)
)
.
unwrap
(
)
;
}
}
