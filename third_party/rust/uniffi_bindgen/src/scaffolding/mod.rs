use
anyhow
:
:
Result
;
use
askama
:
:
Template
;
use
std
:
:
borrow
:
:
Borrow
;
use
super
:
:
interface
:
:
*
;
use
heck
:
:
ToSnakeCase
;
#
[
derive
(
Template
)
]
#
[
template
(
syntax
=
"
rs
"
escape
=
"
none
"
path
=
"
scaffolding_template
.
rs
"
)
]
pub
struct
RustScaffolding
<
'
a
>
{
ci
:
&
'
a
ComponentInterface
uniffi_version
:
&
'
static
str
}
impl
<
'
a
>
RustScaffolding
<
'
a
>
{
pub
fn
new
(
ci
:
&
'
a
ComponentInterface
)
-
>
Self
{
Self
{
ci
uniffi_version
:
crate
:
:
BINDGEN_VERSION
}
}
}
mod
filters
{
use
super
:
:
*
;
pub
fn
type_rs
(
type_
:
&
Type
)
-
>
Result
<
String
askama
:
:
Error
>
{
Ok
(
match
type_
{
Type
:
:
Int8
=
>
"
i8
"
.
into
(
)
Type
:
:
UInt8
=
>
"
u8
"
.
into
(
)
Type
:
:
Int16
=
>
"
i16
"
.
into
(
)
Type
:
:
UInt16
=
>
"
u16
"
.
into
(
)
Type
:
:
Int32
=
>
"
i32
"
.
into
(
)
Type
:
:
UInt32
=
>
"
u32
"
.
into
(
)
Type
:
:
Int64
=
>
"
i64
"
.
into
(
)
Type
:
:
UInt64
=
>
"
u64
"
.
into
(
)
Type
:
:
Float32
=
>
"
f32
"
.
into
(
)
Type
:
:
Float64
=
>
"
f64
"
.
into
(
)
Type
:
:
Boolean
=
>
"
bool
"
.
into
(
)
Type
:
:
String
=
>
"
String
"
.
into
(
)
Type
:
:
Timestamp
=
>
"
std
:
:
time
:
:
SystemTime
"
.
into
(
)
Type
:
:
Duration
=
>
"
std
:
:
time
:
:
Duration
"
.
into
(
)
Type
:
:
Enum
(
name
)
|
Type
:
:
Record
(
name
)
|
Type
:
:
Error
(
name
)
=
>
format
!
(
"
r
#
{
name
}
"
)
Type
:
:
Object
(
name
)
=
>
format
!
(
"
std
:
:
sync
:
:
Arc
<
r
#
{
name
}
>
"
)
Type
:
:
CallbackInterface
(
name
)
=
>
format
!
(
"
Box
<
dyn
r
#
{
name
}
>
"
)
Type
:
:
Optional
(
t
)
=
>
format
!
(
"
std
:
:
option
:
:
Option
<
{
}
>
"
type_rs
(
t
)
?
)
Type
:
:
Sequence
(
t
)
=
>
format
!
(
"
std
:
:
vec
:
:
Vec
<
{
}
>
"
type_rs
(
t
)
?
)
Type
:
:
Map
(
k
v
)
=
>
format
!
(
"
std
:
:
collections
:
:
HashMap
<
{
}
{
}
>
"
type_rs
(
k
)
?
type_rs
(
v
)
?
)
Type
:
:
Custom
{
name
.
.
}
=
>
format
!
(
"
r
#
{
name
}
"
)
Type
:
:
External
{
.
.
}
=
>
panic
!
(
"
External
types
coming
to
a
uniffi
near
you
soon
!
"
)
Type
:
:
Unresolved
{
.
.
}
=
>
{
unreachable
!
(
"
UDL
scaffolding
code
never
contains
unresolved
types
"
)
}
}
)
}
pub
fn
type_ffi
(
type_
:
&
FfiType
)
-
>
Result
<
String
askama
:
:
Error
>
{
Ok
(
match
type_
{
FfiType
:
:
Int8
=
>
"
i8
"
.
into
(
)
FfiType
:
:
UInt8
=
>
"
u8
"
.
into
(
)
FfiType
:
:
Int16
=
>
"
i16
"
.
into
(
)
FfiType
:
:
UInt16
=
>
"
u16
"
.
into
(
)
FfiType
:
:
Int32
=
>
"
i32
"
.
into
(
)
FfiType
:
:
UInt32
=
>
"
u32
"
.
into
(
)
FfiType
:
:
Int64
=
>
"
i64
"
.
into
(
)
FfiType
:
:
UInt64
=
>
"
u64
"
.
into
(
)
FfiType
:
:
Float32
=
>
"
f32
"
.
into
(
)
FfiType
:
:
Float64
=
>
"
f64
"
.
into
(
)
FfiType
:
:
RustArcPtr
(
_
)
=
>
"
*
const
std
:
:
os
:
:
raw
:
:
c_void
"
.
into
(
)
FfiType
:
:
RustBuffer
(
_
)
=
>
"
uniffi
:
:
RustBuffer
"
.
into
(
)
FfiType
:
:
ForeignBytes
=
>
"
uniffi
:
:
ForeignBytes
"
.
into
(
)
FfiType
:
:
ForeignCallback
=
>
"
uniffi
:
:
ForeignCallback
"
.
into
(
)
}
)
}
pub
fn
ffi_converter_name
(
type_
:
&
Type
)
-
>
askama
:
:
Result
<
String
>
{
Ok
(
match
type_
{
Type
:
:
Timestamp
=
>
"
std
:
:
time
:
:
SystemTime
"
.
into
(
)
Type
:
:
Duration
=
>
"
std
:
:
time
:
:
Duration
"
.
into
(
)
Type
:
:
Object
(
name
)
=
>
format
!
(
"
std
:
:
sync
:
:
Arc
<
r
#
{
name
}
>
"
)
Type
:
:
Enum
(
_
)
|
Type
:
:
Record
(
_
)
|
Type
:
:
Error
(
_
)
|
Type
:
:
CallbackInterface
(
_
)
=
>
{
format
!
(
"
FfiConverter
{
}
"
type_
.
canonical_name
(
)
)
}
Type
:
:
Optional
(
inner
)
=
>
{
format
!
(
"
std
:
:
option
:
:
Option
<
{
}
>
"
ffi_converter_name
(
inner
)
?
)
}
Type
:
:
Sequence
(
inner
)
=
>
format
!
(
"
std
:
:
vec
:
:
Vec
<
{
}
>
"
ffi_converter_name
(
inner
)
?
)
Type
:
:
Map
(
k
v
)
=
>
format
!
(
"
std
:
:
collections
:
:
HashMap
<
{
}
{
}
>
"
ffi_converter_name
(
k
)
?
ffi_converter_name
(
v
)
?
)
Type
:
:
Custom
{
name
.
.
}
|
Type
:
:
External
{
name
.
.
}
=
>
{
format
!
(
"
FfiConverterType
{
name
}
"
)
}
Type
:
:
Int8
=
>
"
i8
"
.
into
(
)
Type
:
:
UInt8
=
>
"
u8
"
.
into
(
)
Type
:
:
Int16
=
>
"
i16
"
.
into
(
)
Type
:
:
UInt16
=
>
"
u16
"
.
into
(
)
Type
:
:
Int32
=
>
"
i32
"
.
into
(
)
Type
:
:
UInt32
=
>
"
u32
"
.
into
(
)
Type
:
:
Int64
=
>
"
i64
"
.
into
(
)
Type
:
:
UInt64
=
>
"
u64
"
.
into
(
)
Type
:
:
Float32
=
>
"
f32
"
.
into
(
)
Type
:
:
Float64
=
>
"
f64
"
.
into
(
)
Type
:
:
String
=
>
"
String
"
.
into
(
)
Type
:
:
Boolean
=
>
"
bool
"
.
into
(
)
Type
:
:
Unresolved
{
.
.
}
=
>
{
unreachable
!
(
"
UDL
scaffolding
code
never
contains
unresolved
types
"
)
}
}
)
}
pub
fn
ffi_converter
(
type_
:
&
Type
)
-
>
Result
<
String
askama
:
:
Error
>
{
Ok
(
format
!
(
"
<
{
}
as
uniffi
:
:
FfiConverter
>
"
ffi_converter_name
(
type_
)
?
)
)
}
pub
fn
crate_name_rs
(
nm
:
&
str
)
-
>
Result
<
String
askama
:
:
Error
>
{
Ok
(
nm
.
to_string
(
)
.
to_snake_case
(
)
)
}
}
