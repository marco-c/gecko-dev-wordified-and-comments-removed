{
#
#
}
{
%
let
trait_name
=
cbi
.
name
(
)
-
%
}
{
%
let
trait_impl
=
cbi
.
type_
(
)
.
borrow
(
)
|
ffi_converter_name
-
%
}
{
%
let
foreign_callback_internals
=
format
!
(
"
foreign_callback_
{
}
_internals
"
trait_name
)
|
upper
-
%
}
#
[
doc
(
hidden
)
]
static
{
{
foreign_callback_internals
}
}
:
uniffi
:
:
ForeignCallbackInternals
=
uniffi
:
:
ForeignCallbackInternals
:
:
new
(
)
;
#
[
doc
(
hidden
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
{
{
cbi
.
ffi_init_callback
(
)
.
name
(
)
}
}
(
callback
:
uniffi
:
:
ForeignCallback
)
{
{
{
foreign_callback_internals
}
}
.
set_callback
(
callback
)
;
}
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
struct
{
{
trait_impl
}
}
{
handle
:
u64
}
impl
Drop
for
{
{
trait_impl
}
}
{
fn
drop
(
&
mut
self
)
{
let
callback
=
{
{
foreign_callback_internals
}
}
.
get_callback
(
)
.
unwrap
(
)
;
let
mut
rbuf
=
uniffi
:
:
RustBuffer
:
:
new
(
)
;
unsafe
{
callback
(
self
.
handle
uniffi
:
:
IDX_CALLBACK_FREE
Default
:
:
default
(
)
&
mut
rbuf
)
}
;
}
}
uniffi
:
:
deps
:
:
static_assertions
:
:
assert_impl_all
!
(
{
{
trait_impl
}
}
:
Send
)
;
impl
{
{
trait_name
}
}
for
{
{
trait_impl
}
}
{
{
%
-
for
meth
in
cbi
.
methods
(
)
%
}
{
#
-
Method
declaration
#
}
fn
{
{
meth
.
name
(
)
-
}
}
(
{
%
call
rs
:
:
arg_list_decl_with_prefix
(
"
&
self
"
meth
)
%
}
)
{
%
-
match
meth
.
return_type
(
)
%
}
{
%
-
when
Some
with
(
return_type
)
%
}
-
>
{
{
return_type
.
borrow
(
)
|
type_rs
}
}
{
%
else
-
%
}
{
%
-
endmatch
-
%
}
{
{
#
-
Method
body
#
}
uniffi
:
:
deps
:
:
log
:
:
debug
!
(
"
{
{
cbi
.
name
(
)
}
}
.
{
{
meth
.
name
(
)
}
}
"
)
;
{
#
-
Packing
args
into
a
RustBuffer
#
}
{
%
if
meth
.
arguments
(
)
.
len
(
)
=
=
0
-
%
}
let
args_buf
=
Vec
:
:
new
(
)
;
{
%
else
-
%
}
let
mut
args_buf
=
Vec
:
:
new
(
)
;
{
%
endif
-
%
}
{
%
-
for
arg
in
meth
.
arguments
(
)
%
}
{
{
arg
.
type_
(
)
.
borrow
(
)
|
ffi_converter
}
}
:
:
write
(
{
{
arg
.
name
(
)
}
}
&
mut
args_buf
)
;
{
%
-
endfor
-
%
}
let
args_rbuf
=
uniffi
:
:
RustBuffer
:
:
from_vec
(
args_buf
)
;
{
#
-
Calling
into
foreign
code
.
#
}
let
callback
=
{
{
foreign_callback_internals
}
}
.
get_callback
(
)
.
unwrap
(
)
;
let
ret_rbuf
=
unsafe
{
let
mut
ret_rbuf
=
uniffi
:
:
RustBuffer
:
:
new
(
)
;
let
ret
=
callback
(
self
.
handle
{
{
loop
.
index
}
}
args_rbuf
&
mut
ret_rbuf
)
;
match
ret
{
0
=
>
uniffi
:
:
RustBuffer
:
:
new
(
)
_
if
ret
<
0
=
>
panic
!
(
"
Callback
failed
"
)
_
=
>
ret_rbuf
}
}
;
{
#
-
Unpacking
the
RustBuffer
to
return
to
Rust
#
}
{
%
match
meth
.
return_type
(
)
-
%
}
{
%
when
Some
with
(
return_type
)
-
%
}
let
vec
=
ret_rbuf
.
destroy_into_vec
(
)
;
let
mut
ret_buf
=
vec
.
as_slice
(
)
;
{
{
return_type
|
ffi_converter
}
}
:
:
try_read
(
&
mut
ret_buf
)
.
unwrap
(
)
{
%
-
else
-
%
}
uniffi
:
:
RustBuffer
:
:
destroy
(
ret_rbuf
)
;
{
%
-
endmatch
%
}
}
{
%
-
endfor
%
}
}
unsafe
impl
uniffi
:
:
FfiConverter
for
{
{
trait_impl
}
}
{
type
RustType
=
Box
<
dyn
{
{
trait_name
}
}
>
;
type
FfiType
=
u64
;
fn
lower
(
_obj
:
Self
:
:
RustType
)
-
>
Self
:
:
FfiType
{
panic
!
(
"
Lowering
CallbackInterface
not
supported
"
)
}
fn
write
(
_obj
:
Self
:
:
RustType
_buf
:
&
mut
std
:
:
vec
:
:
Vec
<
u8
>
)
{
panic
!
(
"
Writing
CallbackInterface
not
supported
"
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
uniffi
:
:
deps
:
:
anyhow
:
:
Result
<
Self
:
:
RustType
>
{
Ok
(
Box
:
:
new
(
Self
{
handle
:
v
}
)
)
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
uniffi
:
:
deps
:
:
anyhow
:
:
Result
<
Self
:
:
RustType
>
{
use
uniffi
:
:
deps
:
:
bytes
:
:
Buf
;
uniffi
:
:
check_remaining
(
buf
8
)
?
;
<
Self
as
uniffi
:
:
FfiConverter
>
:
:
try_lift
(
buf
.
get_u64
(
)
)
}
}
