use
uniffi_meta
:
:
{
ExternalKind
Type
}
;
#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
FfiType
{
UInt8
Int8
UInt16
Int16
UInt32
Int32
UInt64
Int64
Float32
Float64
RustArcPtr
(
String
)
RustBuffer
(
Option
<
String
>
)
ForeignBytes
ForeignCallback
ForeignExecutorHandle
ForeignExecutorCallback
RustFutureHandle
RustFutureContinuationCallback
RustFutureContinuationData
}
impl
From
<
&
Type
>
for
FfiType
{
fn
from
(
t
:
&
Type
)
-
>
FfiType
{
match
t
{
Type
:
:
UInt8
=
>
FfiType
:
:
UInt8
Type
:
:
Int8
=
>
FfiType
:
:
Int8
Type
:
:
UInt16
=
>
FfiType
:
:
UInt16
Type
:
:
Int16
=
>
FfiType
:
:
Int16
Type
:
:
UInt32
=
>
FfiType
:
:
UInt32
Type
:
:
Int32
=
>
FfiType
:
:
Int32
Type
:
:
UInt64
=
>
FfiType
:
:
UInt64
Type
:
:
Int64
=
>
FfiType
:
:
Int64
Type
:
:
Float32
=
>
FfiType
:
:
Float32
Type
:
:
Float64
=
>
FfiType
:
:
Float64
Type
:
:
Boolean
=
>
FfiType
:
:
Int8
Type
:
:
String
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Bytes
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Object
{
name
.
.
}
=
>
FfiType
:
:
RustArcPtr
(
name
.
to_owned
(
)
)
Type
:
:
CallbackInterface
{
.
.
}
=
>
FfiType
:
:
UInt64
Type
:
:
ForeignExecutor
=
>
FfiType
:
:
ForeignExecutorHandle
Type
:
:
Enum
{
.
.
}
|
Type
:
:
Record
{
.
.
}
|
Type
:
:
Optional
{
.
.
}
|
Type
:
:
Sequence
{
.
.
}
|
Type
:
:
Map
{
.
.
}
|
Type
:
:
Timestamp
|
Type
:
:
Duration
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
External
{
name
kind
:
ExternalKind
:
:
Interface
.
.
}
=
>
FfiType
:
:
RustArcPtr
(
name
.
clone
(
)
)
Type
:
:
External
{
name
kind
:
ExternalKind
:
:
DataClass
.
.
}
=
>
FfiType
:
:
RustBuffer
(
Some
(
name
.
clone
(
)
)
)
Type
:
:
Custom
{
builtin
.
.
}
=
>
FfiType
:
:
from
(
builtin
.
as_ref
(
)
)
}
}
}
impl
From
<
Type
>
for
FfiType
{
fn
from
(
ty
:
Type
)
-
>
Self
{
(
&
ty
)
.
into
(
)
}
}
impl
From
<
&
&
Type
>
for
FfiType
{
fn
from
(
ty
:
&
&
Type
)
-
>
Self
{
(
*
ty
)
.
into
(
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FfiFunction
{
pub
(
super
)
name
:
String
pub
(
super
)
is_async
:
bool
pub
(
super
)
arguments
:
Vec
<
FfiArgument
>
pub
(
super
)
return_type
:
Option
<
FfiType
>
pub
(
super
)
has_rust_call_status_arg
:
bool
pub
(
super
)
is_object_free_function
:
bool
}
impl
FfiFunction
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
is_async
(
&
self
)
-
>
bool
{
self
.
is_async
}
pub
fn
arguments
(
&
self
)
-
>
Vec
<
&
FfiArgument
>
{
self
.
arguments
.
iter
(
)
.
collect
(
)
}
pub
fn
return_type
(
&
self
)
-
>
Option
<
&
FfiType
>
{
self
.
return_type
.
as_ref
(
)
}
pub
fn
has_rust_call_status_arg
(
&
self
)
-
>
bool
{
self
.
has_rust_call_status_arg
}
pub
fn
is_object_free_function
(
&
self
)
-
>
bool
{
self
.
is_object_free_function
}
pub
fn
init
(
&
mut
self
return_type
:
Option
<
FfiType
>
args
:
impl
IntoIterator
<
Item
=
FfiArgument
>
)
{
self
.
arguments
=
args
.
into_iter
(
)
.
collect
(
)
;
if
self
.
is_async
(
)
{
self
.
return_type
=
Some
(
FfiType
:
:
RustFutureHandle
)
;
self
.
has_rust_call_status_arg
=
false
;
}
else
{
self
.
return_type
=
return_type
;
}
}
}
impl
Default
for
FfiFunction
{
fn
default
(
)
-
>
Self
{
Self
{
name
:
"
"
.
into
(
)
is_async
:
false
arguments
:
Vec
:
:
new
(
)
return_type
:
None
has_rust_call_status_arg
:
true
is_object_free_function
:
false
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FfiArgument
{
pub
(
super
)
name
:
String
pub
(
super
)
type_
:
FfiType
}
impl
FfiArgument
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
type_
(
&
self
)
-
>
FfiType
{
self
.
type_
.
clone
(
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
}
