#
[
derive
(
Debug
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
FfiType
{
UInt8
Int8
UInt16
Int16
UInt32
Int32
UInt64
Int64
Float32
Float64
RustArcPtr
(
String
)
RustBuffer
(
Option
<
String
>
)
ForeignBytes
ForeignCallback
ForeignExecutorHandle
ForeignExecutorCallback
FutureCallback
{
return_type
:
Box
<
FfiType
>
}
FutureCallbackData
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FfiFunction
{
pub
(
super
)
name
:
String
pub
(
super
)
is_async
:
bool
pub
(
super
)
arguments
:
Vec
<
FfiArgument
>
pub
(
super
)
return_type
:
Option
<
FfiType
>
pub
(
super
)
has_rust_call_status_arg
:
bool
pub
(
super
)
is_object_free_function
:
bool
}
impl
FfiFunction
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
is_async
(
&
self
)
-
>
bool
{
self
.
is_async
}
pub
fn
arguments
(
&
self
)
-
>
Vec
<
&
FfiArgument
>
{
self
.
arguments
.
iter
(
)
.
collect
(
)
}
pub
fn
return_type
(
&
self
)
-
>
Option
<
&
FfiType
>
{
self
.
return_type
.
as_ref
(
)
}
pub
fn
has_rust_call_status_arg
(
&
self
)
-
>
bool
{
self
.
has_rust_call_status_arg
}
pub
fn
is_object_free_function
(
&
self
)
-
>
bool
{
self
.
is_object_free_function
}
pub
fn
init
(
&
mut
self
return_type
:
Option
<
FfiType
>
args
:
impl
IntoIterator
<
Item
=
FfiArgument
>
)
{
self
.
arguments
=
args
.
into_iter
(
)
.
collect
(
)
;
if
self
.
is_async
(
)
{
self
.
arguments
.
extend
(
[
FfiArgument
{
name
:
"
uniffi_executor
"
.
into
(
)
type_
:
FfiType
:
:
ForeignExecutorHandle
}
FfiArgument
{
name
:
"
uniffi_callback
"
.
into
(
)
type_
:
FfiType
:
:
FutureCallback
{
return_type
:
Box
:
:
new
(
return_type
.
unwrap_or
(
FfiType
:
:
UInt8
)
)
}
}
FfiArgument
{
name
:
"
uniffi_callback_data
"
.
into
(
)
type_
:
FfiType
:
:
FutureCallbackData
}
]
)
;
self
.
return_type
=
None
;
}
else
{
self
.
return_type
=
return_type
;
}
}
}
impl
Default
for
FfiFunction
{
fn
default
(
)
-
>
Self
{
Self
{
name
:
"
"
.
into
(
)
is_async
:
false
arguments
:
Vec
:
:
new
(
)
return_type
:
None
has_rust_call_status_arg
:
true
is_object_free_function
:
false
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FfiArgument
{
pub
(
super
)
name
:
String
pub
(
super
)
type_
:
FfiType
}
impl
FfiArgument
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
type_
(
&
self
)
-
>
FfiType
{
self
.
type_
.
clone
(
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
}
