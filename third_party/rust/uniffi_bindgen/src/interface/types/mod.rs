use
std
:
:
{
collections
:
:
hash_map
:
:
Entry
collections
:
:
BTreeSet
collections
:
:
HashMap
iter
}
;
use
anyhow
:
:
{
bail
Result
}
;
use
heck
:
:
ToUpperCamelCase
;
use
super
:
:
ffi
:
:
FFIType
;
mod
finder
;
pub
(
super
)
use
finder
:
:
TypeFinder
;
mod
resolver
;
pub
(
super
)
use
resolver
:
:
{
resolve_builtin_type
TypeResolver
}
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
Ord
PartialOrd
)
]
pub
enum
Type
{
UInt8
Int8
UInt16
Int16
UInt32
Int32
UInt64
Int64
Float32
Float64
Boolean
String
Timestamp
Duration
Object
(
String
)
Record
(
String
)
Enum
(
String
)
Error
(
String
)
CallbackInterface
(
String
)
Optional
(
Box
<
Type
>
)
Sequence
(
Box
<
Type
>
)
Map
(
Box
<
Type
>
Box
<
Type
>
)
External
{
name
:
String
crate_name
:
String
}
Custom
{
name
:
String
builtin
:
Box
<
Type
>
}
}
impl
Type
{
pub
fn
canonical_name
(
&
self
)
-
>
String
{
match
self
{
Type
:
:
Int8
=
>
"
i8
"
.
into
(
)
Type
:
:
UInt8
=
>
"
u8
"
.
into
(
)
Type
:
:
Int16
=
>
"
i16
"
.
into
(
)
Type
:
:
UInt16
=
>
"
u16
"
.
into
(
)
Type
:
:
Int32
=
>
"
i32
"
.
into
(
)
Type
:
:
UInt32
=
>
"
u32
"
.
into
(
)
Type
:
:
Int64
=
>
"
i64
"
.
into
(
)
Type
:
:
UInt64
=
>
"
u64
"
.
into
(
)
Type
:
:
Float32
=
>
"
f32
"
.
into
(
)
Type
:
:
Float64
=
>
"
f64
"
.
into
(
)
Type
:
:
String
=
>
"
string
"
.
into
(
)
Type
:
:
Boolean
=
>
"
bool
"
.
into
(
)
Type
:
:
Object
(
nm
)
=
>
format
!
(
"
Type
{
}
"
nm
)
Type
:
:
Error
(
nm
)
=
>
format
!
(
"
Type
{
}
"
nm
)
Type
:
:
Enum
(
nm
)
=
>
format
!
(
"
Type
{
}
"
nm
)
Type
:
:
Record
(
nm
)
=
>
format
!
(
"
Type
{
}
"
nm
)
Type
:
:
CallbackInterface
(
nm
)
=
>
format
!
(
"
CallbackInterface
{
}
"
nm
)
Type
:
:
Timestamp
=
>
"
Timestamp
"
.
into
(
)
Type
:
:
Duration
=
>
"
Duration
"
.
into
(
)
Type
:
:
Optional
(
t
)
=
>
format
!
(
"
Optional
{
}
"
t
.
canonical_name
(
)
)
Type
:
:
Sequence
(
t
)
=
>
format
!
(
"
Sequence
{
}
"
t
.
canonical_name
(
)
)
Type
:
:
Map
(
k
v
)
=
>
format
!
(
"
Map
{
}
{
}
"
k
.
canonical_name
(
)
.
to_upper_camel_case
(
)
v
.
canonical_name
(
)
.
to_upper_camel_case
(
)
)
Type
:
:
External
{
name
.
.
}
|
Type
:
:
Custom
{
name
.
.
}
=
>
format
!
(
"
Type
{
}
"
name
)
}
}
pub
fn
ffi_type
(
&
self
)
-
>
FFIType
{
self
.
into
(
)
}
pub
fn
iter_types
(
&
self
)
-
>
TypeIterator
<
'
_
>
{
let
nested_types
=
match
self
{
Type
:
:
Optional
(
t
)
|
Type
:
:
Sequence
(
t
)
=
>
t
.
iter_types
(
)
Type
:
:
Map
(
k
v
)
=
>
Box
:
:
new
(
k
.
iter_types
(
)
.
chain
(
v
.
iter_types
(
)
)
)
_
=
>
Box
:
:
new
(
iter
:
:
empty
(
)
)
}
;
Box
:
:
new
(
std
:
:
iter
:
:
once
(
self
)
.
chain
(
nested_types
)
)
}
}
impl
From
<
&
Type
>
for
FFIType
{
fn
from
(
t
:
&
Type
)
-
>
FFIType
{
match
t
{
Type
:
:
UInt8
=
>
FFIType
:
:
UInt8
Type
:
:
Int8
=
>
FFIType
:
:
Int8
Type
:
:
UInt16
=
>
FFIType
:
:
UInt16
Type
:
:
Int16
=
>
FFIType
:
:
Int16
Type
:
:
UInt32
=
>
FFIType
:
:
UInt32
Type
:
:
Int32
=
>
FFIType
:
:
Int32
Type
:
:
UInt64
=
>
FFIType
:
:
UInt64
Type
:
:
Int64
=
>
FFIType
:
:
Int64
Type
:
:
Float32
=
>
FFIType
:
:
Float32
Type
:
:
Float64
=
>
FFIType
:
:
Float64
Type
:
:
Boolean
=
>
FFIType
:
:
Int8
Type
:
:
String
=
>
FFIType
:
:
RustBuffer
Type
:
:
Object
(
name
)
=
>
FFIType
:
:
RustArcPtr
(
name
.
to_owned
(
)
)
Type
:
:
CallbackInterface
(
_
)
=
>
FFIType
:
:
UInt64
Type
:
:
Enum
(
_
)
|
Type
:
:
Error
(
_
)
|
Type
:
:
Record
(
_
)
|
Type
:
:
Optional
(
_
)
|
Type
:
:
Sequence
(
_
)
|
Type
:
:
Map
(
_
_
)
|
Type
:
:
Timestamp
|
Type
:
:
Duration
|
Type
:
:
External
{
.
.
}
=
>
FFIType
:
:
RustBuffer
Type
:
:
Custom
{
builtin
.
.
}
=
>
FFIType
:
:
from
(
builtin
.
as_ref
(
)
)
}
}
}
impl
From
<
&
&
Type
>
for
FFIType
{
fn
from
(
ty
:
&
&
Type
)
-
>
Self
{
(
*
ty
)
.
into
(
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
TypeUniverse
{
type_definitions
:
HashMap
<
String
Type
>
all_known_types
:
BTreeSet
<
Type
>
}
impl
TypeUniverse
{
pub
(
super
)
fn
add_type_definitions_from
<
T
:
TypeFinder
>
(
&
mut
self
defn
:
T
)
-
>
Result
<
(
)
>
{
defn
.
add_type_definitions_to
(
self
)
}
pub
fn
add_type_definition
(
&
mut
self
name
:
&
str
type_
:
Type
)
-
>
Result
<
(
)
>
{
if
resolve_builtin_type
(
name
)
.
is_some
(
)
{
bail
!
(
"
please
don
'
t
shadow
builtin
types
(
{
}
{
}
)
"
name
type_
.
canonical_name
(
)
)
;
}
let
type_
=
self
.
add_known_type
(
type_
)
?
;
match
self
.
type_definitions
.
entry
(
name
.
to_string
(
)
)
{
Entry
:
:
Occupied
(
_
)
=
>
bail
!
(
"
Conflicting
type
definition
for
\
"
{
}
\
"
"
name
)
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
type_
)
;
Ok
(
(
)
)
}
}
}
pub
(
super
)
fn
get_type_definition
(
&
self
name
:
&
str
)
-
>
Option
<
Type
>
{
self
.
type_definitions
.
get
(
name
)
.
cloned
(
)
}
pub
(
crate
)
fn
resolve_type_expression
<
T
:
TypeResolver
>
(
&
mut
self
expr
:
T
)
-
>
Result
<
Type
>
{
expr
.
resolve_type_expression
(
self
)
}
pub
fn
add_known_type
(
&
mut
self
type_
:
Type
)
-
>
Result
<
Type
>
{
if
!
self
.
all_known_types
.
contains
(
&
type_
)
{
self
.
all_known_types
.
insert
(
type_
.
clone
(
)
)
;
}
Ok
(
type_
)
}
pub
fn
iter_known_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Type
>
{
self
.
all_known_types
.
iter
(
)
}
}
pub
type
TypeIterator
<
'
a
>
=
Box
<
dyn
Iterator
<
Item
=
&
'
a
Type
>
+
'
a
>
;
#
[
cfg
(
test
)
]
mod
test_type
{
use
super
:
:
*
;
#
[
test
]
fn
test_canonical_names
(
)
{
assert_eq
!
(
Type
:
:
UInt8
.
canonical_name
(
)
"
u8
"
)
;
assert_eq
!
(
Type
:
:
String
.
canonical_name
(
)
"
string
"
)
;
assert_eq
!
(
Type
:
:
Optional
(
Box
:
:
new
(
Type
:
:
Sequence
(
Box
:
:
new
(
Type
:
:
Object
(
"
Example
"
.
into
(
)
)
)
)
)
)
.
canonical_name
(
)
"
OptionalSequenceTypeExample
"
)
;
}
}
#
[
cfg
(
test
)
]
mod
test_type_universe
{
}
