use
std
:
:
{
collections
:
:
hash_map
:
:
Entry
collections
:
:
BTreeSet
collections
:
:
HashMap
iter
}
;
use
anyhow
:
:
{
bail
Result
}
;
use
uniffi_meta
:
:
Checksum
;
use
super
:
:
ffi
:
:
FfiType
;
mod
finder
;
pub
(
super
)
use
finder
:
:
TypeFinder
;
mod
resolver
;
pub
(
super
)
use
resolver
:
:
{
resolve_builtin_type
TypeResolver
}
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Checksum
Ord
PartialOrd
)
]
pub
enum
ObjectImpl
{
Struct
Trait
}
impl
ObjectImpl
{
pub
fn
rust_name_for
(
&
self
name
:
&
str
)
-
>
String
{
if
self
=
=
&
ObjectImpl
:
:
Trait
{
format
!
(
"
dyn
r
#
{
name
}
"
)
}
else
{
format
!
(
"
r
#
{
name
}
"
)
}
}
pub
fn
from_is_trait
(
is_trait
:
bool
)
-
>
Self
{
if
is_trait
{
ObjectImpl
:
:
Trait
}
else
{
ObjectImpl
:
:
Struct
}
}
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Checksum
Ord
PartialOrd
)
]
pub
enum
Type
{
UInt8
Int8
UInt16
Int16
UInt32
Int32
UInt64
Int64
Float32
Float64
Boolean
String
Bytes
Timestamp
Duration
Object
{
name
:
String
imp
:
ObjectImpl
}
ForeignExecutor
Record
(
String
)
Enum
(
String
)
CallbackInterface
(
String
)
Optional
(
Box
<
Type
>
)
Sequence
(
Box
<
Type
>
)
Map
(
Box
<
Type
>
Box
<
Type
>
)
External
{
name
:
String
crate_name
:
String
kind
:
ExternalKind
}
Custom
{
name
:
String
builtin
:
Box
<
Type
>
}
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Checksum
Ord
PartialOrd
)
]
pub
enum
ExternalKind
{
Interface
DataClass
}
impl
Type
{
pub
fn
ffi_type
(
&
self
)
-
>
FfiType
{
self
.
into
(
)
}
pub
fn
iter_types
(
&
self
)
-
>
TypeIterator
<
'
_
>
{
let
nested_types
=
match
self
{
Type
:
:
Optional
(
t
)
|
Type
:
:
Sequence
(
t
)
=
>
t
.
iter_types
(
)
Type
:
:
Map
(
k
v
)
=
>
Box
:
:
new
(
k
.
iter_types
(
)
.
chain
(
v
.
iter_types
(
)
)
)
_
=
>
Box
:
:
new
(
iter
:
:
empty
(
)
)
}
;
Box
:
:
new
(
std
:
:
iter
:
:
once
(
self
)
.
chain
(
nested_types
)
)
}
}
impl
From
<
&
Type
>
for
FfiType
{
fn
from
(
t
:
&
Type
)
-
>
FfiType
{
match
t
{
Type
:
:
UInt8
=
>
FfiType
:
:
UInt8
Type
:
:
Int8
=
>
FfiType
:
:
Int8
Type
:
:
UInt16
=
>
FfiType
:
:
UInt16
Type
:
:
Int16
=
>
FfiType
:
:
Int16
Type
:
:
UInt32
=
>
FfiType
:
:
UInt32
Type
:
:
Int32
=
>
FfiType
:
:
Int32
Type
:
:
UInt64
=
>
FfiType
:
:
UInt64
Type
:
:
Int64
=
>
FfiType
:
:
Int64
Type
:
:
Float32
=
>
FfiType
:
:
Float32
Type
:
:
Float64
=
>
FfiType
:
:
Float64
Type
:
:
Boolean
=
>
FfiType
:
:
Int8
Type
:
:
String
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Bytes
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Object
{
name
.
.
}
=
>
FfiType
:
:
RustArcPtr
(
name
.
to_owned
(
)
)
Type
:
:
CallbackInterface
(
_
)
=
>
FfiType
:
:
UInt64
Type
:
:
ForeignExecutor
=
>
FfiType
:
:
ForeignExecutorHandle
Type
:
:
Enum
(
_
)
|
Type
:
:
Record
(
_
)
|
Type
:
:
Optional
(
_
)
|
Type
:
:
Sequence
(
_
)
|
Type
:
:
Map
(
_
_
)
|
Type
:
:
Timestamp
|
Type
:
:
Duration
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
External
{
name
kind
:
ExternalKind
:
:
Interface
.
.
}
=
>
FfiType
:
:
RustArcPtr
(
name
.
clone
(
)
)
Type
:
:
External
{
name
kind
:
ExternalKind
:
:
DataClass
.
.
}
=
>
FfiType
:
:
RustBuffer
(
Some
(
name
.
clone
(
)
)
)
Type
:
:
Custom
{
builtin
.
.
}
=
>
FfiType
:
:
from
(
builtin
.
as_ref
(
)
)
}
}
}
impl
From
<
&
&
Type
>
for
FfiType
{
fn
from
(
ty
:
&
&
Type
)
-
>
Self
{
(
*
ty
)
.
into
(
)
}
}
pub
trait
AsType
:
core
:
:
fmt
:
:
Debug
{
fn
as_type
(
&
self
)
-
>
Type
;
}
impl
AsType
for
Type
{
fn
as_type
(
&
self
)
-
>
Type
{
self
.
clone
(
)
}
}
impl
<
T
C
>
AsType
for
T
where
T
:
std
:
:
ops
:
:
Deref
<
Target
=
C
>
+
std
:
:
fmt
:
:
Debug
C
:
AsType
{
fn
as_type
(
&
self
)
-
>
Type
{
self
.
deref
(
)
.
as_type
(
)
}
}
impl
From
<
uniffi_meta
:
:
Type
>
for
Type
{
fn
from
(
ty
:
uniffi_meta
:
:
Type
)
-
>
Self
{
use
uniffi_meta
:
:
Type
as
Ty
;
match
ty
{
Ty
:
:
U8
=
>
Type
:
:
UInt8
Ty
:
:
U16
=
>
Type
:
:
UInt16
Ty
:
:
U32
=
>
Type
:
:
UInt32
Ty
:
:
U64
=
>
Type
:
:
UInt64
Ty
:
:
I8
=
>
Type
:
:
Int8
Ty
:
:
I16
=
>
Type
:
:
Int16
Ty
:
:
I32
=
>
Type
:
:
Int32
Ty
:
:
I64
=
>
Type
:
:
Int64
Ty
:
:
F32
=
>
Type
:
:
Float32
Ty
:
:
F64
=
>
Type
:
:
Float64
Ty
:
:
Bool
=
>
Type
:
:
Boolean
Ty
:
:
String
=
>
Type
:
:
String
Ty
:
:
SystemTime
=
>
Type
:
:
Timestamp
Ty
:
:
Duration
=
>
Type
:
:
Duration
Ty
:
:
ForeignExecutor
=
>
Type
:
:
ForeignExecutor
Ty
:
:
Record
{
name
}
=
>
Type
:
:
Record
(
name
)
Ty
:
:
Enum
{
name
.
.
}
=
>
Type
:
:
Enum
(
name
)
Ty
:
:
ArcObject
{
object_name
is_trait
}
=
>
Type
:
:
Object
{
name
:
object_name
imp
:
ObjectImpl
:
:
from_is_trait
(
is_trait
)
}
Ty
:
:
CallbackInterface
{
name
}
=
>
Type
:
:
CallbackInterface
(
name
)
Ty
:
:
Custom
{
name
builtin
}
=
>
Type
:
:
Custom
{
name
builtin
:
builtin
.
into
(
)
}
Ty
:
:
Option
{
inner_type
}
=
>
Type
:
:
Optional
(
inner_type
.
into
(
)
)
Ty
:
:
Vec
{
inner_type
}
=
>
Type
:
:
Sequence
(
inner_type
.
into
(
)
)
Ty
:
:
HashMap
{
key_type
value_type
}
=
>
Type
:
:
Map
(
key_type
.
into
(
)
value_type
.
into
(
)
)
}
}
}
impl
From
<
uniffi_meta
:
:
Type
>
for
Box
<
Type
>
{
fn
from
(
ty
:
uniffi_meta
:
:
Type
)
-
>
Self
{
Box
:
:
new
(
ty
.
into
(
)
)
}
}
impl
From
<
Box
<
uniffi_meta
:
:
Type
>
>
for
Box
<
Type
>
{
fn
from
(
ty
:
Box
<
uniffi_meta
:
:
Type
>
)
-
>
Self
{
Box
:
:
new
(
(
*
ty
)
.
into
(
)
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
TypeUniverse
{
type_definitions
:
HashMap
<
String
Type
>
all_known_types
:
BTreeSet
<
Type
>
}
impl
TypeUniverse
{
pub
(
super
)
fn
add_type_definitions_from
<
T
:
TypeFinder
>
(
&
mut
self
defn
:
T
)
-
>
Result
<
(
)
>
{
defn
.
add_type_definitions_to
(
self
)
}
pub
fn
add_type_definition
(
&
mut
self
name
:
&
str
type_
:
Type
)
-
>
Result
<
(
)
>
{
if
resolve_builtin_type
(
name
)
.
is_some
(
)
{
bail
!
(
"
please
don
'
t
shadow
builtin
types
(
{
name
}
{
:
?
}
)
"
type_
)
;
}
self
.
add_known_type
(
&
type_
)
;
match
self
.
type_definitions
.
entry
(
name
.
to_string
(
)
)
{
Entry
:
:
Occupied
(
o
)
=
>
{
let
existing_def
=
o
.
get
(
)
;
if
type_
=
=
*
existing_def
&
&
matches
!
(
type_
Type
:
:
Record
(
_
)
|
Type
:
:
Enum
(
_
)
)
{
Ok
(
(
)
)
}
else
{
bail
!
(
"
Conflicting
type
definition
for
{
name
}
!
\
existing
definition
:
{
existing_def
:
?
}
\
new
definition
:
{
type_
:
?
}
"
)
;
}
}
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
type_
)
;
Ok
(
(
)
)
}
}
}
pub
(
super
)
fn
get_type_definition
(
&
self
name
:
&
str
)
-
>
Option
<
Type
>
{
self
.
type_definitions
.
get
(
name
)
.
cloned
(
)
}
pub
(
crate
)
fn
resolve_type_expression
<
T
:
TypeResolver
>
(
&
mut
self
expr
:
T
)
-
>
Result
<
Type
>
{
expr
.
resolve_type_expression
(
self
)
}
pub
fn
add_known_type
(
&
mut
self
type_
:
&
Type
)
{
if
!
self
.
all_known_types
.
contains
(
type_
)
{
self
.
all_known_types
.
insert
(
type_
.
to_owned
(
)
)
;
match
type_
{
Type
:
:
Optional
(
t
)
=
>
self
.
add_known_type
(
t
)
Type
:
:
Sequence
(
t
)
=
>
self
.
add_known_type
(
t
)
Type
:
:
Map
(
k
v
)
=
>
{
self
.
add_known_type
(
k
)
;
self
.
add_known_type
(
v
)
;
}
_
=
>
{
}
}
}
}
pub
fn
contains
(
&
self
type_
:
&
Type
)
-
>
bool
{
self
.
all_known_types
.
contains
(
type_
)
}
pub
fn
iter_known_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Type
>
{
self
.
all_known_types
.
iter
(
)
}
}
pub
type
TypeIterator
<
'
a
>
=
Box
<
dyn
Iterator
<
Item
=
&
'
a
Type
>
+
'
a
>
;
#
[
cfg
(
test
)
]
mod
test_type_universe
{
}
