use
anyhow
:
:
{
bail
Result
}
;
use
uniffi_meta
:
:
Checksum
;
use
super
:
:
ffi
:
:
{
FfiArgument
FfiFunction
FfiType
}
;
use
super
:
:
object
:
:
Method
;
use
super
:
:
types
:
:
{
ObjectImpl
Type
TypeIterator
}
;
use
super
:
:
{
APIConverter
AsType
ComponentInterface
}
;
#
[
derive
(
Debug
Clone
Checksum
)
]
pub
struct
CallbackInterface
{
pub
(
super
)
name
:
String
pub
(
super
)
methods
:
Vec
<
Method
>
#
[
checksum_ignore
]
pub
(
super
)
ffi_init_callback
:
FfiFunction
}
impl
CallbackInterface
{
pub
fn
new
(
name
:
String
)
-
>
CallbackInterface
{
CallbackInterface
{
name
methods
:
Default
:
:
default
(
)
ffi_init_callback
:
Default
:
:
default
(
)
}
}
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
methods
(
&
self
)
-
>
Vec
<
&
Method
>
{
self
.
methods
.
iter
(
)
.
collect
(
)
}
pub
fn
ffi_init_callback
(
&
self
)
-
>
&
FfiFunction
{
&
self
.
ffi_init_callback
}
pub
(
super
)
fn
derive_ffi_funcs
(
&
mut
self
ci_namespace
:
&
str
)
{
self
.
ffi_init_callback
.
name
=
uniffi_meta
:
:
init_callback_fn_symbol_name
(
ci_namespace
&
self
.
name
)
;
self
.
ffi_init_callback
.
arguments
=
vec
!
[
FfiArgument
{
name
:
"
callback_stub
"
.
to_string
(
)
type_
:
FfiType
:
:
ForeignCallback
}
]
;
self
.
ffi_init_callback
.
return_type
=
None
;
}
pub
fn
iter_types
(
&
self
)
-
>
TypeIterator
<
'
_
>
{
Box
:
:
new
(
self
.
methods
.
iter
(
)
.
flat_map
(
Method
:
:
iter_types
)
)
}
}
impl
AsType
for
CallbackInterface
{
fn
as_type
(
&
self
)
-
>
Type
{
Type
:
:
CallbackInterface
(
self
.
name
.
clone
(
)
)
}
}
impl
APIConverter
<
CallbackInterface
>
for
weedle
:
:
CallbackInterfaceDefinition
<
'
_
>
{
fn
convert
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
CallbackInterface
>
{
if
self
.
attributes
.
is_some
(
)
{
bail
!
(
"
callback
interface
attributes
are
not
supported
yet
"
)
;
}
if
self
.
inheritance
.
is_some
(
)
{
bail
!
(
"
callback
interface
inheritance
is
not
supported
"
)
;
}
let
mut
object
=
CallbackInterface
:
:
new
(
self
.
identifier
.
0
.
to_string
(
)
)
;
for
member
in
&
self
.
members
.
body
{
match
member
{
weedle
:
:
interface
:
:
InterfaceMember
:
:
Operation
(
t
)
=
>
{
let
mut
method
:
Method
=
t
.
convert
(
ci
)
?
;
method
.
object_name
=
object
.
name
.
clone
(
)
;
method
.
object_impl
=
ObjectImpl
:
:
Struct
;
object
.
methods
.
push
(
method
)
;
}
_
=
>
bail
!
(
"
no
support
for
callback
interface
member
type
{
:
?
}
yet
"
member
)
}
}
Ok
(
object
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_empty_interface
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
/
/
Weird
but
allowed
.
callback
interface
Testing
{
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
callback_interface_definitions
(
)
.
len
(
)
1
)
;
assert_eq
!
(
ci
.
get_callback_interface_definition
(
"
Testing
"
)
.
unwrap
(
)
.
methods
(
)
.
len
(
)
0
)
;
}
#
[
test
]
fn
test_multiple_interfaces
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
callback
interface
One
{
void
one
(
)
;
}
;
callback
interface
Two
{
u32
two
(
)
;
u64
too
(
)
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
callback_interface_definitions
(
)
.
len
(
)
2
)
;
let
callbacks_one
=
ci
.
get_callback_interface_definition
(
"
One
"
)
.
unwrap
(
)
;
assert_eq
!
(
callbacks_one
.
methods
(
)
.
len
(
)
1
)
;
assert_eq
!
(
callbacks_one
.
methods
(
)
[
0
]
.
name
(
)
"
one
"
)
;
let
callbacks_two
=
ci
.
get_callback_interface_definition
(
"
Two
"
)
.
unwrap
(
)
;
assert_eq
!
(
callbacks_two
.
methods
(
)
.
len
(
)
2
)
;
assert_eq
!
(
callbacks_two
.
methods
(
)
[
0
]
.
name
(
)
"
two
"
)
;
assert_eq
!
(
callbacks_two
.
methods
(
)
[
1
]
.
name
(
)
"
too
"
)
;
}
}
