use
anyhow
:
:
Result
;
use
std
:
:
{
collections
:
:
hash_map
:
:
Entry
collections
:
:
BTreeSet
collections
:
:
HashMap
}
;
pub
use
uniffi_meta
:
:
{
AsType
ExternalKind
NamespaceMetadata
ObjectImpl
Type
TypeIterator
}
;
#
[
derive
(
Clone
Debug
Default
)
]
pub
(
crate
)
struct
TypeUniverse
{
pub
namespace
:
NamespaceMetadata
pub
namespace_docstring
:
Option
<
String
>
pub
(
super
)
type_definitions
:
HashMap
<
String
Type
>
pub
(
super
)
all_known_types
:
BTreeSet
<
Type
>
}
impl
TypeUniverse
{
pub
fn
new
(
namespace
:
NamespaceMetadata
)
-
>
Self
{
Self
{
namespace
.
.
Default
:
:
default
(
)
}
}
fn
add_type_definition
(
&
mut
self
name
:
&
str
type_
:
&
Type
)
-
>
Result
<
(
)
>
{
match
self
.
type_definitions
.
entry
(
name
.
to_string
(
)
)
{
Entry
:
:
Occupied
(
o
)
=
>
{
assert_eq
!
(
type_
o
.
get
(
)
)
;
Ok
(
(
)
)
}
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
type_
.
clone
(
)
)
;
Ok
(
(
)
)
}
}
}
pub
(
super
)
fn
get_type_definition
(
&
self
name
:
&
str
)
-
>
Option
<
Type
>
{
self
.
type_definitions
.
get
(
name
)
.
cloned
(
)
}
pub
fn
add_known_type
(
&
mut
self
type_
:
&
Type
)
-
>
Result
<
(
)
>
{
if
!
self
.
all_known_types
.
contains
(
type_
)
{
self
.
all_known_types
.
insert
(
type_
.
to_owned
(
)
)
;
}
match
type_
{
Type
:
:
UInt8
=
>
self
.
add_type_definition
(
"
u8
"
type_
)
?
Type
:
:
Int8
=
>
self
.
add_type_definition
(
"
i8
"
type_
)
?
Type
:
:
UInt16
=
>
self
.
add_type_definition
(
"
u16
"
type_
)
?
Type
:
:
Int16
=
>
self
.
add_type_definition
(
"
i16
"
type_
)
?
Type
:
:
UInt32
=
>
self
.
add_type_definition
(
"
i32
"
type_
)
?
Type
:
:
Int32
=
>
self
.
add_type_definition
(
"
u32
"
type_
)
?
Type
:
:
UInt64
=
>
self
.
add_type_definition
(
"
u64
"
type_
)
?
Type
:
:
Int64
=
>
self
.
add_type_definition
(
"
i64
"
type_
)
?
Type
:
:
Float32
=
>
self
.
add_type_definition
(
"
f32
"
type_
)
?
Type
:
:
Float64
=
>
self
.
add_type_definition
(
"
f64
"
type_
)
?
Type
:
:
Boolean
=
>
self
.
add_type_definition
(
"
bool
"
type_
)
?
Type
:
:
String
=
>
self
.
add_type_definition
(
"
string
"
type_
)
?
Type
:
:
Bytes
=
>
self
.
add_type_definition
(
"
bytes
"
type_
)
?
Type
:
:
Timestamp
=
>
self
.
add_type_definition
(
"
timestamp
"
type_
)
?
Type
:
:
Duration
=
>
self
.
add_type_definition
(
"
duration
"
type_
)
?
Type
:
:
Object
{
name
.
.
}
|
Type
:
:
Record
{
name
.
.
}
|
Type
:
:
Enum
{
name
.
.
}
|
Type
:
:
CallbackInterface
{
name
.
.
}
|
Type
:
:
External
{
name
.
.
}
=
>
self
.
add_type_definition
(
name
type_
)
?
Type
:
:
Custom
{
name
builtin
.
.
}
=
>
{
self
.
add_type_definition
(
name
type_
)
?
;
self
.
add_known_type
(
builtin
)
?
;
}
Type
:
:
Optional
{
inner_type
.
.
}
|
Type
:
:
Sequence
{
inner_type
.
.
}
=
>
{
self
.
add_known_type
(
inner_type
)
?
;
}
Type
:
:
Map
{
key_type
value_type
}
=
>
{
self
.
add_known_type
(
key_type
)
?
;
self
.
add_known_type
(
value_type
)
?
;
}
}
Ok
(
(
)
)
}
pub
fn
add_known_types
(
&
mut
self
types
:
TypeIterator
<
'
_
>
)
-
>
Result
<
(
)
>
{
for
t
in
types
{
self
.
add_known_type
(
t
)
?
}
Ok
(
(
)
)
}
#
[
cfg
(
test
)
]
pub
fn
contains
(
&
self
type_
:
&
Type
)
-
>
bool
{
self
.
all_known_types
.
contains
(
type_
)
}
pub
fn
iter_known_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Type
>
{
self
.
all_known_types
.
iter
(
)
}
}
#
[
cfg
(
test
)
]
mod
test_type_universe
{
}
