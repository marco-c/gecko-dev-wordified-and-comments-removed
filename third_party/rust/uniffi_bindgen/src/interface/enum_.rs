use
anyhow
:
:
Result
;
use
uniffi_meta
:
:
Checksum
;
use
super
:
:
record
:
:
Field
;
use
super
:
:
{
AsType
Type
TypeIterator
}
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
Checksum
)
]
pub
struct
Enum
{
pub
(
super
)
name
:
String
pub
(
super
)
module_path
:
String
pub
(
super
)
variants
:
Vec
<
Variant
>
pub
(
super
)
flat
:
bool
}
impl
Enum
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
variants
(
&
self
)
-
>
&
[
Variant
]
{
&
self
.
variants
}
pub
fn
is_flat
(
&
self
)
-
>
bool
{
self
.
flat
}
pub
fn
iter_types
(
&
self
)
-
>
TypeIterator
<
'
_
>
{
Box
:
:
new
(
self
.
variants
.
iter
(
)
.
flat_map
(
Variant
:
:
iter_types
)
)
}
pub
fn
try_from_meta
(
meta
:
uniffi_meta
:
:
EnumMetadata
flat
:
bool
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
name
:
meta
.
name
module_path
:
meta
.
module_path
variants
:
meta
.
variants
.
into_iter
(
)
.
map
(
TryInto
:
:
try_into
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
flat
}
)
}
}
impl
AsType
for
Enum
{
fn
as_type
(
&
self
)
-
>
Type
{
Type
:
:
Enum
{
name
:
self
.
name
.
clone
(
)
module_path
:
self
.
module_path
.
clone
(
)
}
}
}
#
[
derive
(
Debug
Clone
Default
PartialEq
Eq
Checksum
)
]
pub
struct
Variant
{
pub
(
super
)
name
:
String
pub
(
super
)
fields
:
Vec
<
Field
>
}
impl
Variant
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
name
}
pub
fn
fields
(
&
self
)
-
>
&
[
Field
]
{
&
self
.
fields
}
pub
fn
has_fields
(
&
self
)
-
>
bool
{
!
self
.
fields
.
is_empty
(
)
}
pub
fn
iter_types
(
&
self
)
-
>
TypeIterator
<
'
_
>
{
Box
:
:
new
(
self
.
fields
.
iter
(
)
.
flat_map
(
Field
:
:
iter_types
)
)
}
}
impl
TryFrom
<
uniffi_meta
:
:
VariantMetadata
>
for
Variant
{
type
Error
=
anyhow
:
:
Error
;
fn
try_from
(
meta
:
uniffi_meta
:
:
VariantMetadata
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
name
:
meta
.
name
fields
:
meta
.
fields
.
into_iter
(
)
.
map
(
TryInto
:
:
try_into
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
}
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
super
:
:
{
ComponentInterface
FfiType
}
;
use
super
:
:
*
;
#
[
test
]
fn
test_duplicate_variants
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
/
/
Weird
but
currently
allowed
!
/
/
We
should
probably
disallow
this
.
.
.
enum
Testing
{
"
one
"
"
two
"
"
one
"
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
"
crate_name
"
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
enum_definitions
(
)
.
count
(
)
1
)
;
assert_eq
!
(
ci
.
get_enum_definition
(
"
Testing
"
)
.
unwrap
(
)
.
variants
(
)
.
len
(
)
3
)
;
}
#
[
test
]
fn
test_associated_data
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
void
takes_an_enum
(
TestEnum
e
)
;
void
takes_an_enum_with_data
(
TestEnumWithData
ed
)
;
TestEnum
returns_an_enum
(
)
;
TestEnumWithData
returns_an_enum_with_data
(
)
;
}
;
enum
TestEnum
{
"
one
"
"
two
"
}
;
[
Enum
]
interface
TestEnumWithData
{
Zero
(
)
;
One
(
u32
first
)
;
Two
(
u32
first
string
second
)
;
}
;
[
Enum
]
interface
TestEnumWithoutData
{
One
(
)
;
Two
(
)
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
"
crate_name
"
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
enum_definitions
(
)
.
count
(
)
3
)
;
assert_eq
!
(
ci
.
function_definitions
(
)
.
len
(
)
4
)
;
let
e
=
ci
.
get_enum_definition
(
"
TestEnum
"
)
.
unwrap
(
)
;
assert
!
(
e
.
is_flat
(
)
)
;
assert_eq
!
(
e
.
variants
(
)
.
len
(
)
2
)
;
assert_eq
!
(
e
.
variants
(
)
.
iter
(
)
.
map
(
|
v
|
v
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
one
"
"
two
"
]
)
;
assert_eq
!
(
e
.
variants
(
)
[
0
]
.
fields
(
)
.
len
(
)
0
)
;
assert_eq
!
(
e
.
variants
(
)
[
1
]
.
fields
(
)
.
len
(
)
0
)
;
let
ed
=
ci
.
get_enum_definition
(
"
TestEnumWithData
"
)
.
unwrap
(
)
;
assert
!
(
!
ed
.
is_flat
(
)
)
;
assert_eq
!
(
ed
.
variants
(
)
.
len
(
)
3
)
;
assert_eq
!
(
ed
.
variants
(
)
.
iter
(
)
.
map
(
|
v
|
v
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
Zero
"
"
One
"
"
Two
"
]
)
;
assert_eq
!
(
ed
.
variants
(
)
[
0
]
.
fields
(
)
.
len
(
)
0
)
;
assert_eq
!
(
ed
.
variants
(
)
[
1
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
first
"
]
)
;
assert_eq
!
(
ed
.
variants
(
)
[
1
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
as_type
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
Type
:
:
UInt32
]
)
;
assert_eq
!
(
ed
.
variants
(
)
[
2
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
first
"
"
second
"
]
)
;
assert_eq
!
(
ed
.
variants
(
)
[
2
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
as_type
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
Type
:
:
UInt32
Type
:
:
String
]
)
;
let
ewd
=
ci
.
get_enum_definition
(
"
TestEnumWithoutData
"
)
.
unwrap
(
)
;
assert_eq
!
(
ewd
.
variants
(
)
.
len
(
)
2
)
;
assert_eq
!
(
ewd
.
variants
(
)
.
iter
(
)
.
map
(
|
v
|
v
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
One
"
"
Two
"
]
)
;
assert_eq
!
(
ewd
.
variants
(
)
[
0
]
.
fields
(
)
.
len
(
)
0
)
;
assert_eq
!
(
ewd
.
variants
(
)
[
1
]
.
fields
(
)
.
len
(
)
0
)
;
let
farg
=
ci
.
get_function_definition
(
"
takes_an_enum
"
)
.
unwrap
(
)
;
assert_eq
!
(
farg
.
arguments
(
)
[
0
]
.
as_type
(
)
Type
:
:
Enum
{
name
:
"
TestEnum
"
.
into
(
)
module_path
:
"
crate_name
"
.
into
(
)
}
)
;
assert_eq
!
(
farg
.
ffi_func
(
)
.
arguments
(
)
[
0
]
.
type_
(
)
FfiType
:
:
RustBuffer
(
None
)
)
;
let
fret
=
ci
.
get_function_definition
(
"
returns_an_enum
"
)
.
unwrap
(
)
;
assert
!
(
matches
!
(
fret
.
return_type
(
)
Some
(
Type
:
:
Enum
{
name
.
.
}
)
if
name
=
=
"
TestEnum
"
&
&
!
ci
.
is_name_used_as_error
(
name
)
)
)
;
assert
!
(
matches
!
(
fret
.
ffi_func
(
)
.
return_type
(
)
Some
(
FfiType
:
:
RustBuffer
(
None
)
)
)
)
;
let
farg
=
ci
.
get_function_definition
(
"
takes_an_enum_with_data
"
)
.
unwrap
(
)
;
assert_eq
!
(
farg
.
arguments
(
)
[
0
]
.
as_type
(
)
Type
:
:
Enum
{
name
:
"
TestEnumWithData
"
.
into
(
)
module_path
:
"
crate_name
"
.
into
(
)
}
)
;
assert_eq
!
(
farg
.
ffi_func
(
)
.
arguments
(
)
[
0
]
.
type_
(
)
FfiType
:
:
RustBuffer
(
None
)
)
;
let
fret
=
ci
.
get_function_definition
(
"
returns_an_enum_with_data
"
)
.
unwrap
(
)
;
assert
!
(
matches
!
(
fret
.
return_type
(
)
Some
(
Type
:
:
Enum
{
name
.
.
}
)
if
name
=
=
"
TestEnumWithData
"
&
&
!
ci
.
is_name_used_as_error
(
name
)
)
)
;
assert
!
(
matches
!
(
fret
.
ffi_func
(
)
.
return_type
(
)
Some
(
FfiType
:
:
RustBuffer
(
None
)
)
)
)
;
}
#
[
test
]
fn
test_variants
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
[
Error
]
enum
Testing
{
"
one
"
"
two
"
"
three
"
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
"
crate_name
"
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
enum_definitions
(
)
.
count
(
)
1
)
;
let
error
=
ci
.
get_enum_definition
(
"
Testing
"
)
.
unwrap
(
)
;
assert_eq
!
(
error
.
variants
(
)
.
iter
(
)
.
map
(
|
v
|
v
.
name
(
)
)
.
collect
:
:
<
Vec
<
&
str
>
>
(
)
vec
!
(
"
one
"
"
two
"
"
three
"
)
)
;
assert
!
(
error
.
is_flat
(
)
)
;
assert
!
(
ci
.
is_name_used_as_error
(
&
error
.
name
)
)
;
}
#
[
test
]
fn
test_duplicate_error_variants
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
/
/
Weird
but
currently
allowed
!
/
/
We
should
probably
disallow
this
.
.
.
[
Error
]
enum
Testing
{
"
one
"
"
two
"
"
one
"
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
"
crate_name
"
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
enum_definitions
(
)
.
count
(
)
1
)
;
assert_eq
!
(
ci
.
get_enum_definition
(
"
Testing
"
)
.
unwrap
(
)
.
variants
(
)
.
len
(
)
3
)
;
}
#
[
test
]
fn
test_variant_data
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
[
Error
]
interface
Testing
{
One
(
string
reason
)
;
Two
(
u8
code
)
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
"
crate_name
"
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
enum_definitions
(
)
.
count
(
)
1
)
;
let
error
:
&
Enum
=
ci
.
get_enum_definition
(
"
Testing
"
)
.
unwrap
(
)
;
assert_eq
!
(
error
.
variants
(
)
.
iter
(
)
.
map
(
|
v
|
v
.
name
(
)
)
.
collect
:
:
<
Vec
<
&
str
>
>
(
)
vec
!
(
"
One
"
"
Two
"
)
)
;
assert
!
(
!
error
.
is_flat
(
)
)
;
assert
!
(
ci
.
is_name_used_as_error
(
&
error
.
name
)
)
;
}
#
[
test
]
fn
test_enum_variant_named_error
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
[
Enum
]
interface
Testing
{
Normal
(
string
first
)
;
Error
(
string
first
)
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
"
crate_name
"
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
enum_definitions
(
)
.
count
(
)
1
)
;
let
testing
:
&
Enum
=
ci
.
get_enum_definition
(
"
Testing
"
)
.
unwrap
(
)
;
assert_eq
!
(
testing
.
variants
(
)
[
0
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
first
"
]
)
;
assert_eq
!
(
testing
.
variants
(
)
[
0
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
as_type
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
Type
:
:
String
]
)
;
assert_eq
!
(
testing
.
variants
(
)
[
1
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
first
"
]
)
;
assert_eq
!
(
testing
.
variants
(
)
[
1
]
.
fields
(
)
.
iter
(
)
.
map
(
|
f
|
f
.
as_type
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
Type
:
:
String
]
)
;
assert_eq
!
(
testing
.
variants
(
)
.
iter
(
)
.
map
(
|
v
|
v
.
name
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
"
Normal
"
"
Error
"
]
)
;
}
}
