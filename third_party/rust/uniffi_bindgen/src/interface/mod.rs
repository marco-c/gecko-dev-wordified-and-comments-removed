use
std
:
:
{
collections
:
:
{
hash_map
:
:
DefaultHasher
HashSet
}
convert
:
:
TryFrom
hash
:
:
{
Hash
Hasher
}
iter
str
:
:
FromStr
}
;
use
anyhow
:
:
{
bail
Result
}
;
pub
mod
types
;
pub
use
types
:
:
Type
;
use
types
:
:
{
TypeIterator
TypeUniverse
}
;
mod
attributes
;
mod
callbacks
;
pub
use
callbacks
:
:
CallbackInterface
;
mod
enum_
;
pub
use
enum_
:
:
Enum
;
mod
error
;
pub
use
error
:
:
Error
;
mod
function
;
pub
use
function
:
:
{
Argument
Function
}
;
mod
literal
;
pub
use
literal
:
:
{
Literal
Radix
}
;
mod
namespace
;
pub
use
namespace
:
:
Namespace
;
mod
object
;
pub
use
object
:
:
{
Constructor
Method
Object
}
;
mod
record
;
pub
use
record
:
:
{
Field
Record
}
;
pub
mod
ffi
;
pub
use
ffi
:
:
{
FFIArgument
FFIFunction
FFIType
}
;
#
[
derive
(
Debug
Default
)
]
pub
struct
ComponentInterface
{
uniffi_version
:
String
types
:
TypeUniverse
namespace
:
String
enums
:
Vec
<
Enum
>
records
:
Vec
<
Record
>
functions
:
Vec
<
Function
>
objects
:
Vec
<
Object
>
callback_interfaces
:
Vec
<
CallbackInterface
>
errors
:
Vec
<
Error
>
}
impl
ComponentInterface
{
pub
fn
from_webidl
(
idl
:
&
str
)
-
>
Result
<
Self
>
{
let
mut
ci
=
Self
{
uniffi_version
:
env
!
(
"
CARGO_PKG_VERSION
"
)
.
to_string
(
)
.
.
Default
:
:
default
(
)
}
;
use
weedle
:
:
Parse
;
let
(
remaining
defns
)
=
weedle
:
:
Definitions
:
:
parse
(
idl
.
trim
(
)
)
.
unwrap
(
)
;
if
!
remaining
.
is_empty
(
)
{
println
!
(
"
Error
parsing
the
IDL
.
Text
remaining
to
be
parsed
is
:
"
)
;
println
!
(
"
{
}
"
remaining
)
;
bail
!
(
"
parse
error
"
)
;
}
let
_
=
ci
.
types
.
add_known_type
(
Type
:
:
String
)
;
ci
.
types
.
add_type_definitions_from
(
defns
.
as_slice
(
)
)
?
;
APIBuilder
:
:
process
(
&
defns
&
mut
ci
)
?
;
ci
.
check_consistency
(
)
?
;
ci
.
derive_ffi_funcs
(
)
?
;
Ok
(
ci
)
}
pub
fn
namespace
(
&
self
)
-
>
&
str
{
self
.
namespace
.
as_str
(
)
}
pub
fn
enum_definitions
(
&
self
)
-
>
&
[
Enum
]
{
&
self
.
enums
}
pub
fn
get_enum_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Enum
>
{
self
.
enums
.
iter
(
)
.
find
(
|
e
|
e
.
name
=
=
name
)
}
pub
fn
record_definitions
(
&
self
)
-
>
&
[
Record
]
{
&
self
.
records
}
pub
fn
get_record_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Record
>
{
self
.
records
.
iter
(
)
.
find
(
|
r
|
r
.
name
=
=
name
)
}
pub
fn
function_definitions
(
&
self
)
-
>
&
[
Function
]
{
&
self
.
functions
}
pub
fn
get_function_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Function
>
{
self
.
functions
.
iter
(
)
.
find
(
|
f
|
f
.
name
=
=
name
)
}
pub
fn
object_definitions
(
&
self
)
-
>
&
[
Object
]
{
&
self
.
objects
}
pub
fn
get_object_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Object
>
{
self
.
objects
.
iter
(
)
.
find
(
|
o
|
o
.
name
=
=
name
)
}
pub
fn
callback_interface_definitions
(
&
self
)
-
>
&
[
CallbackInterface
]
{
&
self
.
callback_interfaces
}
pub
fn
get_callback_interface_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
CallbackInterface
>
{
self
.
callback_interfaces
.
iter
(
)
.
find
(
|
o
|
o
.
name
=
=
name
)
}
pub
fn
error_definitions
(
&
self
)
-
>
&
[
Error
]
{
&
self
.
errors
}
pub
fn
get_error_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Error
>
{
self
.
errors
.
iter
(
)
.
find
(
|
e
|
e
.
name
=
=
name
)
}
pub
fn
iter_external_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
(
&
String
&
String
)
>
{
self
.
types
.
iter_known_types
(
)
.
filter_map
(
|
t
|
match
t
{
Type
:
:
External
{
name
crate_name
}
=
>
Some
(
(
name
crate_name
)
)
_
=
>
None
}
)
}
pub
fn
iter_custom_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
(
&
String
&
Type
)
>
{
self
.
types
.
iter_known_types
(
)
.
filter_map
(
|
t
|
match
t
{
Type
:
:
Custom
{
name
builtin
}
=
>
Some
(
(
name
&
*
*
builtin
)
)
_
=
>
None
}
)
}
pub
fn
iter_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Type
>
{
self
.
types
.
iter_known_types
(
)
}
pub
fn
get_type
(
&
self
name
:
&
str
)
-
>
Option
<
Type
>
{
self
.
types
.
get_type_definition
(
name
)
}
fn
iter_types_in_item
<
'
a
>
(
&
'
a
self
item
:
&
'
a
Type
)
-
>
impl
Iterator
<
Item
=
&
'
a
Type
>
+
'
a
{
RecursiveTypeIterator
:
:
new
(
self
item
)
}
pub
fn
item_contains_object_references
(
&
self
item
:
&
Type
)
-
>
bool
{
self
.
iter_types_in_item
(
item
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Object
(
_
)
)
)
}
pub
fn
item_contains_unsigned_types
(
&
self
item
:
&
Type
)
-
>
bool
{
self
.
iter_types_in_item
(
item
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
UInt8
|
Type
:
:
UInt16
|
Type
:
:
UInt32
|
Type
:
:
UInt64
)
)
}
pub
fn
contains_optional_types
(
&
self
)
-
>
bool
{
self
.
types
.
iter_known_types
(
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Optional
(
_
)
)
)
}
pub
fn
contains_sequence_types
(
&
self
)
-
>
bool
{
self
.
types
.
iter_known_types
(
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Sequence
(
_
)
)
)
}
pub
fn
contains_map_types
(
&
self
)
-
>
bool
{
self
.
types
.
iter_known_types
(
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Map
(
_
_
)
)
)
}
pub
fn
checksum
(
&
self
)
-
>
u64
{
let
mut
hasher
=
DefaultHasher
:
:
new
(
)
;
self
.
hash
(
&
mut
hasher
)
;
hasher
.
finish
(
)
}
pub
fn
ffi_namespace
(
&
self
)
-
>
String
{
format
!
(
"
{
}
_
{
:
x
}
"
self
.
namespace
(
self
.
checksum
(
)
&
0x000000000000FFFF
)
as
u16
)
}
pub
fn
ffi_rustbuffer_alloc
(
&
self
)
-
>
FFIFunction
{
FFIFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_alloc
"
self
.
ffi_namespace
(
)
)
arguments
:
vec
!
[
FFIArgument
{
name
:
"
size
"
.
to_string
(
)
type_
:
FFIType
:
:
Int32
}
]
return_type
:
Some
(
FFIType
:
:
RustBuffer
)
}
}
pub
fn
ffi_rustbuffer_from_bytes
(
&
self
)
-
>
FFIFunction
{
FFIFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_from_bytes
"
self
.
ffi_namespace
(
)
)
arguments
:
vec
!
[
FFIArgument
{
name
:
"
bytes
"
.
to_string
(
)
type_
:
FFIType
:
:
ForeignBytes
}
]
return_type
:
Some
(
FFIType
:
:
RustBuffer
)
}
}
pub
fn
ffi_rustbuffer_free
(
&
self
)
-
>
FFIFunction
{
FFIFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_free
"
self
.
ffi_namespace
(
)
)
arguments
:
vec
!
[
FFIArgument
{
name
:
"
buf
"
.
to_string
(
)
type_
:
FFIType
:
:
RustBuffer
}
]
return_type
:
None
}
}
pub
fn
ffi_rustbuffer_reserve
(
&
self
)
-
>
FFIFunction
{
FFIFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_reserve
"
self
.
ffi_namespace
(
)
)
arguments
:
vec
!
[
FFIArgument
{
name
:
"
buf
"
.
to_string
(
)
type_
:
FFIType
:
:
RustBuffer
}
FFIArgument
{
name
:
"
additional
"
.
to_string
(
)
type_
:
FFIType
:
:
Int32
}
]
return_type
:
Some
(
FFIType
:
:
RustBuffer
)
}
}
pub
fn
iter_ffi_function_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
FFIFunction
>
+
'
_
{
self
.
iter_user_ffi_function_definitions
(
)
.
cloned
(
)
.
chain
(
self
.
iter_rust_buffer_ffi_function_definitions
(
)
)
}
pub
fn
iter_user_ffi_function_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
FFIFunction
>
+
'
_
{
iter
:
:
empty
(
)
.
chain
(
self
.
objects
.
iter
(
)
.
flat_map
(
|
obj
|
obj
.
iter_ffi_function_definitions
(
)
)
)
.
chain
(
self
.
callback_interfaces
.
iter
(
)
.
map
(
|
cb
|
cb
.
ffi_init_callback
(
)
)
)
.
chain
(
self
.
functions
.
iter
(
)
.
map
(
|
f
|
&
f
.
ffi_func
)
)
}
pub
fn
iter_rust_buffer_ffi_function_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
FFIFunction
>
{
[
self
.
ffi_rustbuffer_alloc
(
)
self
.
ffi_rustbuffer_from_bytes
(
)
self
.
ffi_rustbuffer_free
(
)
self
.
ffi_rustbuffer_reserve
(
)
]
.
into_iter
(
)
}
fn
resolve_type_expression
<
T
:
types
:
:
TypeResolver
>
(
&
mut
self
expr
:
T
)
-
>
Result
<
Type
>
{
self
.
types
.
resolve_type_expression
(
expr
)
}
fn
resolve_return_type_expression
(
&
mut
self
expr
:
&
weedle
:
:
types
:
:
ReturnType
<
'
_
>
)
-
>
Result
<
Option
<
Type
>
>
{
Ok
(
match
expr
{
weedle
:
:
types
:
:
ReturnType
:
:
Undefined
(
_
)
=
>
None
weedle
:
:
types
:
:
ReturnType
:
:
Type
(
t
)
=
>
{
use
weedle
:
:
types
:
:
{
NonAnyType
:
:
Identifier
SingleType
:
:
NonAny
Type
:
:
Single
}
;
match
t
{
Single
(
NonAny
(
Identifier
(
id
)
)
)
if
id
.
type_
.
0
=
=
"
void
"
=
>
None
_
=
>
Some
(
self
.
resolve_type_expression
(
t
)
?
)
}
}
}
)
}
fn
add_namespace_definition
(
&
mut
self
defn
:
Namespace
)
-
>
Result
<
(
)
>
{
if
!
self
.
namespace
.
is_empty
(
)
{
bail
!
(
"
duplicate
namespace
definition
"
)
;
}
self
.
namespace
=
defn
.
name
;
Ok
(
(
)
)
}
fn
add_enum_definition
(
&
mut
self
defn
:
Enum
)
{
self
.
enums
.
push
(
defn
)
;
}
fn
add_record_definition
(
&
mut
self
defn
:
Record
)
{
self
.
records
.
push
(
defn
)
;
}
fn
add_function_definition
(
&
mut
self
defn
:
Function
)
-
>
Result
<
(
)
>
{
if
self
.
functions
.
iter
(
)
.
any
(
|
f
|
f
.
name
=
=
defn
.
name
)
{
bail
!
(
"
duplicate
function
definition
:
\
"
{
}
\
"
"
defn
.
name
)
;
}
if
!
matches
!
(
self
.
types
.
get_type_definition
(
defn
.
name
(
)
)
None
)
{
bail
!
(
"
Conflicting
type
definition
for
\
"
{
}
\
"
"
defn
.
name
(
)
)
;
}
self
.
functions
.
push
(
defn
)
;
Ok
(
(
)
)
}
fn
add_object_definition
(
&
mut
self
defn
:
Object
)
{
self
.
objects
.
push
(
defn
)
;
}
fn
add_callback_interface_definition
(
&
mut
self
defn
:
CallbackInterface
)
{
self
.
callback_interfaces
.
push
(
defn
)
;
}
fn
add_error_definition
(
&
mut
self
defn
:
Error
)
{
self
.
errors
.
push
(
defn
)
;
}
fn
check_consistency
(
&
self
)
-
>
Result
<
(
)
>
{
if
self
.
namespace
.
is_empty
(
)
{
bail
!
(
"
missing
namespace
definition
"
)
;
}
for
e
in
&
self
.
enums
{
for
variant
in
&
e
.
variants
{
if
self
.
types
.
get_type_definition
(
variant
.
name
(
)
)
.
is_some
(
)
{
bail
!
(
"
Enum
variant
names
must
not
shadow
type
names
:
\
"
{
}
\
"
"
variant
.
name
(
)
)
}
}
}
Ok
(
(
)
)
}
fn
derive_ffi_funcs
(
&
mut
self
)
-
>
Result
<
(
)
>
{
let
ci_prefix
=
self
.
ffi_namespace
(
)
;
for
func
in
self
.
functions
.
iter_mut
(
)
{
func
.
derive_ffi_func
(
&
ci_prefix
)
?
;
}
for
obj
in
self
.
objects
.
iter_mut
(
)
{
obj
.
derive_ffi_funcs
(
&
ci_prefix
)
?
;
}
for
callback
in
self
.
callback_interfaces
.
iter_mut
(
)
{
callback
.
derive_ffi_funcs
(
&
ci_prefix
)
;
}
Ok
(
(
)
)
}
}
impl
FromStr
for
ComponentInterface
{
type
Err
=
anyhow
:
:
Error
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
>
{
ComponentInterface
:
:
from_webidl
(
s
)
}
}
impl
Hash
for
ComponentInterface
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
uniffi_version
.
hash
(
state
)
;
self
.
namespace
.
hash
(
state
)
;
self
.
enums
.
hash
(
state
)
;
self
.
records
.
hash
(
state
)
;
self
.
functions
.
hash
(
state
)
;
self
.
objects
.
hash
(
state
)
;
self
.
callback_interfaces
.
hash
(
state
)
;
self
.
errors
.
hash
(
state
)
;
}
}
struct
RecursiveTypeIterator
<
'
a
>
{
ci
:
&
'
a
ComponentInterface
current
:
TypeIterator
<
'
a
>
seen
:
HashSet
<
&
'
a
str
>
pending
:
Vec
<
&
'
a
Type
>
}
impl
<
'
a
>
RecursiveTypeIterator
<
'
a
>
{
fn
new
(
ci
:
&
'
a
ComponentInterface
item
:
&
'
a
Type
)
-
>
RecursiveTypeIterator
<
'
a
>
{
RecursiveTypeIterator
{
ci
current
:
item
.
iter_types
(
)
seen
:
Default
:
:
default
(
)
pending
:
Default
:
:
default
(
)
}
}
fn
add_pending_type
(
&
mut
self
type_
:
&
'
a
Type
)
{
match
type_
{
Type
:
:
Record
(
nm
)
|
Type
:
:
Enum
(
nm
)
|
Type
:
:
Error
(
nm
)
|
Type
:
:
Object
(
nm
)
|
Type
:
:
CallbackInterface
(
nm
)
=
>
{
if
!
self
.
seen
.
contains
(
nm
.
as_str
(
)
)
{
self
.
pending
.
push
(
type_
)
;
self
.
seen
.
insert
(
nm
.
as_str
(
)
)
;
}
}
_
=
>
(
)
}
}
fn
advance_to_next_type
(
&
mut
self
)
-
>
Option
<
&
'
a
Type
>
{
if
let
Some
(
next_type
)
=
self
.
pending
.
pop
(
)
{
let
next_iter
=
match
next_type
{
Type
:
:
Record
(
nm
)
=
>
self
.
ci
.
get_record_definition
(
nm
)
.
map
(
Record
:
:
iter_types
)
Type
:
:
Enum
(
nm
)
=
>
self
.
ci
.
get_enum_definition
(
nm
)
.
map
(
Enum
:
:
iter_types
)
Type
:
:
Error
(
nm
)
=
>
self
.
ci
.
get_error_definition
(
nm
)
.
map
(
Error
:
:
iter_types
)
Type
:
:
Object
(
nm
)
=
>
self
.
ci
.
get_object_definition
(
nm
)
.
map
(
Object
:
:
iter_types
)
Type
:
:
CallbackInterface
(
nm
)
=
>
self
.
ci
.
get_callback_interface_definition
(
nm
)
.
map
(
CallbackInterface
:
:
iter_types
)
_
=
>
None
}
;
if
let
Some
(
next_iter
)
=
next_iter
{
self
.
current
=
next_iter
;
}
self
.
next
(
)
}
else
{
None
}
}
}
impl
<
'
a
>
Iterator
for
RecursiveTypeIterator
<
'
a
>
{
type
Item
=
&
'
a
Type
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
type_
)
=
self
.
current
.
next
(
)
{
self
.
add_pending_type
(
type_
)
;
Some
(
type_
)
}
else
{
self
.
advance_to_next_type
(
)
}
}
}
trait
APIBuilder
{
fn
process
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
(
)
>
;
}
impl
<
T
:
APIBuilder
>
APIBuilder
for
Vec
<
T
>
{
fn
process
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
(
)
>
{
for
item
in
self
{
item
.
process
(
ci
)
?
;
}
Ok
(
(
)
)
}
}
impl
APIBuilder
for
weedle
:
:
Definition
<
'
_
>
{
fn
process
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
(
)
>
{
match
self
{
weedle
:
:
Definition
:
:
Namespace
(
d
)
=
>
d
.
process
(
ci
)
?
weedle
:
:
Definition
:
:
Enum
(
d
)
=
>
{
let
attrs
=
attributes
:
:
EnumAttributes
:
:
try_from
(
d
.
attributes
.
as_ref
(
)
)
?
;
if
attrs
.
contains_error_attr
(
)
{
let
err
=
d
.
convert
(
ci
)
?
;
ci
.
add_error_definition
(
err
)
;
}
else
{
let
e
=
d
.
convert
(
ci
)
?
;
ci
.
add_enum_definition
(
e
)
;
}
}
weedle
:
:
Definition
:
:
Dictionary
(
d
)
=
>
{
let
rec
=
d
.
convert
(
ci
)
?
;
ci
.
add_record_definition
(
rec
)
;
}
weedle
:
:
Definition
:
:
Interface
(
d
)
=
>
{
let
attrs
=
attributes
:
:
InterfaceAttributes
:
:
try_from
(
d
.
attributes
.
as_ref
(
)
)
?
;
if
attrs
.
contains_enum_attr
(
)
{
let
e
=
d
.
convert
(
ci
)
?
;
ci
.
add_enum_definition
(
e
)
;
}
else
if
attrs
.
contains_error_attr
(
)
{
let
e
=
d
.
convert
(
ci
)
?
;
ci
.
add_error_definition
(
e
)
;
}
else
{
let
obj
=
d
.
convert
(
ci
)
?
;
ci
.
add_object_definition
(
obj
)
;
}
}
weedle
:
:
Definition
:
:
CallbackInterface
(
d
)
=
>
{
let
obj
=
d
.
convert
(
ci
)
?
;
ci
.
add_callback_interface_definition
(
obj
)
;
}
weedle
:
:
Definition
:
:
Typedef
(
_
)
=
>
{
}
_
=
>
bail
!
(
"
don
'
t
know
how
to
deal
with
{
:
?
}
"
self
)
}
Ok
(
(
)
)
}
}
trait
APIConverter
<
T
>
{
fn
convert
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
T
>
;
}
impl
<
U
T
:
APIConverter
<
U
>
>
APIConverter
<
Vec
<
U
>
>
for
Vec
<
T
>
{
fn
convert
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
Vec
<
U
>
>
{
self
.
iter
(
)
.
map
(
|
v
|
v
.
convert
(
ci
)
)
.
collect
:
:
<
Result
<
_
>
>
(
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
const
UDL1
:
&
str
=
r
#
"
namespace
foobar
{
}
;
enum
Test
{
"
test_me
"
}
;
"
#
;
const
UDL2
:
&
str
=
r
#
"
namespace
hello
{
u64
world
(
)
;
}
;
dictionary
Test
{
boolean
me
;
}
;
"
#
;
#
[
test
]
fn
test_checksum_always_matches_for_same_webidl
(
)
{
for
udl
in
&
[
UDL1
UDL2
]
{
let
ci1
=
ComponentInterface
:
:
from_webidl
(
udl
)
.
unwrap
(
)
;
let
ci2
=
ComponentInterface
:
:
from_webidl
(
udl
)
.
unwrap
(
)
;
assert_eq
!
(
ci1
.
checksum
(
)
ci2
.
checksum
(
)
)
;
}
}
#
[
test
]
fn
test_checksum_differs_for_different_webidl
(
)
{
let
ci1
=
ComponentInterface
:
:
from_webidl
(
UDL1
)
.
unwrap
(
)
;
let
ci2
=
ComponentInterface
:
:
from_webidl
(
UDL2
)
.
unwrap
(
)
;
assert_ne
!
(
ci1
.
checksum
(
)
ci2
.
checksum
(
)
)
;
}
#
[
test
]
fn
test_checksum_differs_for_different_uniffi_version
(
)
{
for
udl
in
&
[
UDL1
UDL2
]
{
let
ci1
=
ComponentInterface
:
:
from_webidl
(
udl
)
.
unwrap
(
)
;
let
mut
ci2
=
ComponentInterface
:
:
from_webidl
(
udl
)
.
unwrap
(
)
;
ci2
.
uniffi_version
=
String
:
:
from
(
"
fake
-
version
"
)
;
assert_ne
!
(
ci1
.
checksum
(
)
ci2
.
checksum
(
)
)
;
}
}
#
[
test
]
fn
test_duplicate_type_names_are_an_error
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
Testing
{
constructor
(
)
;
}
;
dictionary
Testing
{
u32
field
;
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Conflicting
type
definition
for
\
"
Testing
\
"
"
)
;
const
UDL2
:
&
str
=
r
#
"
namespace
test
{
}
;
enum
Testing
{
"
one
"
"
two
"
}
;
[
Error
]
enum
Testing
{
"
three
"
"
four
"
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL2
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Conflicting
type
definition
for
\
"
Testing
\
"
"
)
;
const
UDL3
:
&
str
=
r
#
"
namespace
test
{
u32
Testing
(
)
;
}
;
enum
Testing
{
"
one
"
"
two
"
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL3
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Conflicting
type
definition
for
\
"
Testing
\
"
"
)
;
}
#
[
test
]
fn
test_enum_variant_names_dont_shadow_types
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
Testing
{
constructor
(
)
;
}
;
[
Enum
]
interface
HardToCodegenFor
{
Testing
(
)
;
OtherVariant
(
u32
field
)
;
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Enum
variant
names
must
not
shadow
type
names
:
\
"
Testing
\
"
"
)
;
}
#
[
test
]
fn
test_contains_optional_types
(
)
{
let
mut
ci
=
ComponentInterface
{
.
.
Default
:
:
default
(
)
}
;
assert
!
(
!
ci
.
contains_optional_types
(
)
)
;
assert
!
(
ci
.
types
.
add_type_definition
(
"
TestOptional
{
}
"
Type
:
:
Optional
(
Box
:
:
new
(
Type
:
:
String
)
)
)
.
is_ok
(
)
)
;
assert
!
(
ci
.
contains_optional_types
(
)
)
;
}
#
[
test
]
fn
test_contains_sequence_types
(
)
{
let
mut
ci
=
ComponentInterface
{
.
.
Default
:
:
default
(
)
}
;
assert
!
(
!
ci
.
contains_sequence_types
(
)
)
;
assert
!
(
ci
.
types
.
add_type_definition
(
"
TestSequence
{
}
"
Type
:
:
Sequence
(
Box
:
:
new
(
Type
:
:
UInt64
)
)
)
.
is_ok
(
)
)
;
assert
!
(
ci
.
contains_sequence_types
(
)
)
;
}
#
[
test
]
fn
test_contains_map_types
(
)
{
let
mut
ci
=
ComponentInterface
{
.
.
Default
:
:
default
(
)
}
;
assert
!
(
!
ci
.
contains_map_types
(
)
)
;
assert
!
(
ci
.
types
.
add_type_definition
(
"
Map
{
}
"
Type
:
:
Map
(
Box
:
:
new
(
Type
:
:
String
)
Box
:
:
new
(
Type
:
:
Boolean
)
)
)
.
is_ok
(
)
)
;
assert
!
(
ci
.
contains_map_types
(
)
)
;
}
#
[
test
]
fn
test_no_infinite_recursion_when_walking_types
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
Testing
{
void
tester
(
Testing
foo
)
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap
(
)
;
assert
!
(
!
ci
.
item_contains_unsigned_types
(
&
Type
:
:
Object
(
"
Testing
"
.
into
(
)
)
)
)
;
}
#
[
test
]
fn
test_correct_recursion_when_walking_types
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
TestObj
{
void
tester
(
TestRecord
foo
)
;
}
;
dictionary
TestRecord
{
NestedRecord
bar
;
}
;
dictionary
NestedRecord
{
u64
baz
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap
(
)
;
assert
!
(
ci
.
item_contains_unsigned_types
(
&
Type
:
:
Object
(
"
TestObj
"
.
into
(
)
)
)
)
;
}
}
