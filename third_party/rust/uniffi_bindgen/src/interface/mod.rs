use
std
:
:
{
collections
:
:
{
btree_map
:
:
Entry
BTreeMap
BTreeSet
HashSet
}
convert
:
:
TryFrom
iter
}
;
use
anyhow
:
:
{
anyhow
bail
ensure
Result
}
;
pub
mod
types
;
pub
use
types
:
:
{
AsType
ExternalKind
ObjectImpl
Type
}
;
use
types
:
:
{
TypeIterator
TypeUniverse
}
;
mod
attributes
;
mod
callbacks
;
pub
use
callbacks
:
:
CallbackInterface
;
mod
enum_
;
pub
use
enum_
:
:
{
Enum
Variant
}
;
mod
function
;
pub
use
function
:
:
{
Argument
Callable
Function
ResultType
}
;
mod
literal
;
pub
use
literal
:
:
{
Literal
Radix
}
;
mod
namespace
;
pub
use
namespace
:
:
Namespace
;
mod
object
;
pub
use
object
:
:
{
Constructor
Method
Object
UniffiTrait
}
;
mod
record
;
pub
use
record
:
:
{
Field
Record
}
;
pub
mod
ffi
;
pub
use
ffi
:
:
{
FfiArgument
FfiFunction
FfiType
}
;
use
uniffi_meta
:
:
{
ConstructorMetadata
ObjectMetadata
TraitMethodMetadata
}
;
const
UNIFFI_CONTRACT_VERSION
:
u32
=
22
;
#
[
derive
(
Debug
Default
)
]
pub
struct
ComponentInterface
{
pub
(
super
)
types
:
TypeUniverse
namespace
:
String
enums
:
BTreeMap
<
String
Enum
>
records
:
BTreeMap
<
String
Record
>
functions
:
Vec
<
Function
>
objects
:
Vec
<
Object
>
callback_interfaces
:
Vec
<
CallbackInterface
>
errors
:
HashSet
<
String
>
callback_interface_throws_types
:
BTreeSet
<
Type
>
}
impl
ComponentInterface
{
pub
fn
from_webidl
(
idl
:
&
str
)
-
>
Result
<
Self
>
{
let
mut
ci
=
Self
:
:
default
(
)
;
use
weedle
:
:
Parse
;
let
(
remaining
defns
)
=
weedle
:
:
Definitions
:
:
parse
(
idl
.
trim
(
)
)
.
unwrap
(
)
;
if
!
remaining
.
is_empty
(
)
{
println
!
(
"
Error
parsing
the
IDL
.
Text
remaining
to
be
parsed
is
:
"
)
;
println
!
(
"
{
remaining
}
"
)
;
bail
!
(
"
parse
error
"
)
;
}
ci
.
types
.
add_known_type
(
&
Type
:
:
String
)
;
ci
.
types
.
add_type_definitions_from
(
defns
.
as_slice
(
)
)
?
;
APIBuilder
:
:
process
(
&
defns
&
mut
ci
)
?
;
ci
.
check_consistency
(
)
?
;
ci
.
derive_ffi_funcs
(
)
?
;
Ok
(
ci
)
}
pub
fn
namespace
(
&
self
)
-
>
&
str
{
self
.
namespace
.
as_str
(
)
}
pub
fn
uniffi_contract_version
(
&
self
)
-
>
u32
{
let
force_version
=
std
:
:
env
:
:
var
(
"
UNIFFI_FORCE_CONTRACT_VERSION
"
)
;
match
force_version
{
Ok
(
v
)
if
!
v
.
is_empty
(
)
=
>
v
.
parse
(
)
.
unwrap
(
)
_
=
>
UNIFFI_CONTRACT_VERSION
}
}
pub
fn
enum_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Enum
>
{
self
.
enums
.
values
(
)
}
pub
fn
get_enum_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Enum
>
{
self
.
enums
.
get
(
name
)
}
pub
fn
record_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Record
>
{
self
.
records
.
values
(
)
}
pub
fn
get_record_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Record
>
{
self
.
records
.
get
(
name
)
}
pub
fn
function_definitions
(
&
self
)
-
>
&
[
Function
]
{
&
self
.
functions
}
pub
fn
get_function_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Function
>
{
self
.
functions
.
iter
(
)
.
find
(
|
f
|
f
.
name
=
=
name
)
}
pub
fn
object_definitions
(
&
self
)
-
>
&
[
Object
]
{
&
self
.
objects
}
pub
fn
get_object_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
Object
>
{
self
.
objects
.
iter
(
)
.
find
(
|
o
|
o
.
name
=
=
name
)
}
pub
fn
callback_interface_definitions
(
&
self
)
-
>
&
[
CallbackInterface
]
{
&
self
.
callback_interfaces
}
pub
fn
get_callback_interface_definition
(
&
self
name
:
&
str
)
-
>
Option
<
&
CallbackInterface
>
{
self
.
callback_interfaces
.
iter
(
)
.
find
(
|
o
|
o
.
name
=
=
name
)
}
pub
fn
iter_callables
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
dyn
Callable
>
{
#
[
allow
(
trivial_casts
)
]
self
.
function_definitions
(
)
.
iter
(
)
.
map
(
|
f
|
f
as
&
dyn
Callable
)
.
chain
(
self
.
objects
.
iter
(
)
.
flat_map
(
|
o
|
{
o
.
constructors
(
)
.
into_iter
(
)
.
map
(
|
c
|
c
as
&
dyn
Callable
)
.
chain
(
o
.
methods
(
)
.
into_iter
(
)
.
map
(
|
m
|
m
as
&
dyn
Callable
)
)
}
)
)
}
pub
fn
should_generate_error_read
(
&
self
e
:
&
Enum
)
-
>
bool
{
let
fielded
=
!
e
.
is_flat
(
)
;
let
used_in_callback_interface
=
self
.
callback_interface_definitions
(
)
.
iter
(
)
.
flat_map
(
|
cb
|
cb
.
methods
(
)
)
.
any
(
|
m
|
m
.
throws_type
(
)
=
=
Some
(
&
e
.
as_type
(
)
)
)
;
self
.
is_name_used_as_error
(
&
e
.
name
)
&
&
(
fielded
|
|
used_in_callback_interface
)
}
pub
fn
iter_external_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
(
&
String
&
String
ExternalKind
)
>
{
self
.
types
.
iter_known_types
(
)
.
filter_map
(
|
t
|
match
t
{
Type
:
:
External
{
name
crate_name
kind
}
=
>
Some
(
(
name
crate_name
*
kind
)
)
_
=
>
None
}
)
}
pub
fn
iter_custom_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
(
&
String
&
Type
)
>
{
self
.
types
.
iter_known_types
(
)
.
filter_map
(
|
t
|
match
t
{
Type
:
:
Custom
{
name
builtin
}
=
>
Some
(
(
name
&
*
*
builtin
)
)
_
=
>
None
}
)
}
pub
fn
iter_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Type
>
{
self
.
types
.
iter_known_types
(
)
}
pub
fn
get_type
(
&
self
name
:
&
str
)
-
>
Option
<
Type
>
{
self
.
types
.
get_type_definition
(
name
)
}
pub
fn
is_callback_interface_throws_type
(
&
self
type_
:
Type
)
-
>
bool
{
self
.
callback_interface_throws_types
.
contains
(
&
type_
)
}
fn
iter_types_in_item
<
'
a
>
(
&
'
a
self
item
:
&
'
a
Type
)
-
>
impl
Iterator
<
Item
=
&
'
a
Type
>
+
'
a
{
RecursiveTypeIterator
:
:
new
(
self
item
)
}
pub
fn
item_contains_object_references
(
&
self
item
:
&
Type
)
-
>
bool
{
self
.
iter_types_in_item
(
item
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Object
{
.
.
}
)
)
}
pub
fn
item_contains_unsigned_types
(
&
self
item
:
&
Type
)
-
>
bool
{
self
.
iter_types_in_item
(
item
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
UInt8
|
Type
:
:
UInt16
|
Type
:
:
UInt32
|
Type
:
:
UInt64
)
)
}
pub
fn
contains_optional_types
(
&
self
)
-
>
bool
{
self
.
types
.
iter_known_types
(
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Optional
(
_
)
)
)
}
pub
fn
contains_sequence_types
(
&
self
)
-
>
bool
{
self
.
types
.
iter_known_types
(
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Sequence
(
_
)
)
)
}
pub
fn
contains_map_types
(
&
self
)
-
>
bool
{
self
.
types
.
iter_known_types
(
)
.
any
(
|
t
|
matches
!
(
t
Type
:
:
Map
(
_
_
)
)
)
}
pub
fn
ffi_namespace
(
&
self
)
-
>
&
str
{
&
self
.
namespace
}
pub
fn
ffi_uniffi_contract_version
(
&
self
)
-
>
FfiFunction
{
FfiFunction
{
name
:
format
!
(
"
ffi_
{
}
_uniffi_contract_version
"
self
.
ffi_namespace
(
)
)
is_async
:
false
arguments
:
vec
!
[
]
return_type
:
Some
(
FfiType
:
:
UInt32
)
has_rust_call_status_arg
:
false
is_object_free_function
:
false
}
}
pub
fn
ffi_rustbuffer_alloc
(
&
self
)
-
>
FfiFunction
{
FfiFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_alloc
"
self
.
ffi_namespace
(
)
)
is_async
:
false
arguments
:
vec
!
[
FfiArgument
{
name
:
"
size
"
.
to_string
(
)
type_
:
FfiType
:
:
Int32
}
]
return_type
:
Some
(
FfiType
:
:
RustBuffer
(
None
)
)
has_rust_call_status_arg
:
true
is_object_free_function
:
false
}
}
pub
fn
ffi_rustbuffer_from_bytes
(
&
self
)
-
>
FfiFunction
{
FfiFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_from_bytes
"
self
.
ffi_namespace
(
)
)
is_async
:
false
arguments
:
vec
!
[
FfiArgument
{
name
:
"
bytes
"
.
to_string
(
)
type_
:
FfiType
:
:
ForeignBytes
}
]
return_type
:
Some
(
FfiType
:
:
RustBuffer
(
None
)
)
has_rust_call_status_arg
:
true
is_object_free_function
:
false
}
}
pub
fn
ffi_rustbuffer_free
(
&
self
)
-
>
FfiFunction
{
FfiFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_free
"
self
.
ffi_namespace
(
)
)
is_async
:
false
arguments
:
vec
!
[
FfiArgument
{
name
:
"
buf
"
.
to_string
(
)
type_
:
FfiType
:
:
RustBuffer
(
None
)
}
]
return_type
:
None
has_rust_call_status_arg
:
true
is_object_free_function
:
false
}
}
pub
fn
ffi_rustbuffer_reserve
(
&
self
)
-
>
FfiFunction
{
FfiFunction
{
name
:
format
!
(
"
ffi_
{
}
_rustbuffer_reserve
"
self
.
ffi_namespace
(
)
)
is_async
:
false
arguments
:
vec
!
[
FfiArgument
{
name
:
"
buf
"
.
to_string
(
)
type_
:
FfiType
:
:
RustBuffer
(
None
)
}
FfiArgument
{
name
:
"
additional
"
.
to_string
(
)
type_
:
FfiType
:
:
Int32
}
]
return_type
:
Some
(
FfiType
:
:
RustBuffer
(
None
)
)
has_rust_call_status_arg
:
true
is_object_free_function
:
false
}
}
pub
fn
has_async_fns
(
&
self
)
-
>
bool
{
self
.
iter_ffi_function_definitions
(
)
.
any
(
|
f
|
f
.
is_async
(
)
)
}
pub
fn
iter_future_callback_params
(
&
self
)
-
>
impl
Iterator
<
Item
=
FfiType
>
{
let
unique_results
=
self
.
iter_callables
(
)
.
map
(
|
c
|
c
.
result_type
(
)
.
future_callback_param
(
)
)
.
collect
:
:
<
BTreeSet
<
_
>
>
(
)
;
unique_results
.
into_iter
(
)
}
pub
fn
iter_async_result_types
(
&
self
)
-
>
impl
Iterator
<
Item
=
ResultType
>
{
let
unique_results
=
self
.
iter_callables
(
)
.
map
(
|
c
|
c
.
result_type
(
)
)
.
collect
:
:
<
BTreeSet
<
_
>
>
(
)
;
unique_results
.
into_iter
(
)
}
pub
fn
iter_ffi_function_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
FfiFunction
>
+
'
_
{
self
.
iter_user_ffi_function_definitions
(
)
.
cloned
(
)
.
chain
(
self
.
iter_rust_buffer_ffi_function_definitions
(
)
)
.
chain
(
self
.
iter_checksum_ffi_functions
(
)
)
.
chain
(
self
.
ffi_foreign_executor_callback_set
(
)
)
.
chain
(
[
self
.
ffi_uniffi_contract_version
(
)
]
)
}
pub
fn
iter_user_ffi_function_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
FfiFunction
>
+
'
_
{
iter
:
:
empty
(
)
.
chain
(
self
.
objects
.
iter
(
)
.
flat_map
(
|
obj
|
obj
.
iter_ffi_function_definitions
(
)
)
)
.
chain
(
self
.
callback_interfaces
.
iter
(
)
.
map
(
|
cb
|
cb
.
ffi_init_callback
(
)
)
)
.
chain
(
self
.
functions
.
iter
(
)
.
map
(
|
f
|
&
f
.
ffi_func
)
)
}
pub
fn
iter_rust_buffer_ffi_function_definitions
(
&
self
)
-
>
impl
Iterator
<
Item
=
FfiFunction
>
{
[
self
.
ffi_rustbuffer_alloc
(
)
self
.
ffi_rustbuffer_from_bytes
(
)
self
.
ffi_rustbuffer_free
(
)
self
.
ffi_rustbuffer_reserve
(
)
]
.
into_iter
(
)
}
pub
fn
ffi_foreign_executor_callback_set
(
&
self
)
-
>
Option
<
FfiFunction
>
{
if
self
.
types
.
contains
(
&
Type
:
:
ForeignExecutor
)
{
Some
(
FfiFunction
{
name
:
"
uniffi_foreign_executor_callback_set
"
.
into
(
)
arguments
:
vec
!
[
FfiArgument
{
name
:
"
callback
"
.
into
(
)
type_
:
FfiType
:
:
ForeignExecutorCallback
}
]
return_type
:
None
is_async
:
false
has_rust_call_status_arg
:
false
is_object_free_function
:
false
}
)
}
else
{
None
}
}
pub
fn
iter_checksums
(
&
self
)
-
>
impl
Iterator
<
Item
=
(
String
u16
)
>
+
'
_
{
let
func_checksums
=
self
.
functions
.
iter
(
)
.
map
(
|
f
|
(
f
.
checksum_fn_name
(
)
f
.
checksum
(
)
)
)
;
let
method_checksums
=
self
.
objects
.
iter
(
)
.
flat_map
(
|
o
|
{
o
.
methods
(
)
.
into_iter
(
)
.
map
(
|
m
|
(
m
.
checksum_fn_name
(
)
m
.
checksum
(
)
)
)
}
)
;
let
constructor_checksums
=
self
.
objects
.
iter
(
)
.
flat_map
(
|
o
|
{
o
.
constructors
(
)
.
into_iter
(
)
.
map
(
|
c
|
(
c
.
checksum_fn_name
(
)
c
.
checksum
(
)
)
)
}
)
;
let
callback_method_checksums
=
self
.
callback_interfaces
.
iter
(
)
.
flat_map
(
|
cbi
|
{
cbi
.
methods
(
)
.
into_iter
(
)
.
filter_map
(
|
m
|
{
if
m
.
checksum_fn_name
(
)
.
is_empty
(
)
{
None
}
else
{
Some
(
(
m
.
checksum_fn_name
(
)
m
.
checksum
(
)
)
)
}
}
)
}
)
;
func_checksums
.
chain
(
method_checksums
)
.
chain
(
constructor_checksums
)
.
chain
(
callback_method_checksums
)
.
map
(
|
(
fn_name
checksum
)
|
(
fn_name
.
to_string
(
)
checksum
)
)
}
pub
fn
iter_checksum_ffi_functions
(
&
self
)
-
>
impl
Iterator
<
Item
=
FfiFunction
>
+
'
_
{
self
.
iter_checksums
(
)
.
map
(
|
(
name
_
)
|
FfiFunction
{
name
is_async
:
false
arguments
:
vec
!
[
]
return_type
:
Some
(
FfiType
:
:
UInt16
)
has_rust_call_status_arg
:
false
is_object_free_function
:
false
}
)
}
fn
resolve_type_expression
<
T
:
types
:
:
TypeResolver
>
(
&
mut
self
expr
:
T
)
-
>
Result
<
Type
>
{
self
.
types
.
resolve_type_expression
(
expr
)
}
fn
resolve_return_type_expression
(
&
mut
self
expr
:
&
weedle
:
:
types
:
:
ReturnType
<
'
_
>
)
-
>
Result
<
Option
<
Type
>
>
{
Ok
(
match
expr
{
weedle
:
:
types
:
:
ReturnType
:
:
Undefined
(
_
)
=
>
None
weedle
:
:
types
:
:
ReturnType
:
:
Type
(
t
)
=
>
{
use
weedle
:
:
types
:
:
{
NonAnyType
:
:
Identifier
SingleType
:
:
NonAny
Type
:
:
Single
}
;
match
t
{
Single
(
NonAny
(
Identifier
(
id
)
)
)
if
id
.
type_
.
0
=
=
"
void
"
=
>
None
_
=
>
Some
(
self
.
resolve_type_expression
(
t
)
?
)
}
}
}
)
}
fn
add_namespace_definition
(
&
mut
self
defn
:
Namespace
)
-
>
Result
<
(
)
>
{
if
!
self
.
namespace
.
is_empty
(
)
{
bail
!
(
"
duplicate
namespace
definition
"
)
;
}
self
.
namespace
=
defn
.
name
;
Ok
(
(
)
)
}
pub
(
super
)
fn
add_enum_definition
(
&
mut
self
defn
:
Enum
)
-
>
Result
<
(
)
>
{
match
self
.
enums
.
entry
(
defn
.
name
(
)
.
to_owned
(
)
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
for
variant
in
defn
.
variants
(
)
{
for
field
in
variant
.
fields
(
)
{
self
.
types
.
add_known_type
(
&
field
.
as_type
(
)
)
;
}
}
v
.
insert
(
defn
)
;
}
Entry
:
:
Occupied
(
o
)
=
>
{
let
existing_def
=
o
.
get
(
)
;
if
defn
!
=
*
existing_def
{
bail
!
(
"
Mismatching
definition
for
enum
{
}
!
\
n
\
existing
definition
:
{
existing_def
:
#
?
}
\
n
\
new
definition
:
{
defn
:
#
?
}
"
defn
.
name
(
)
)
;
}
}
}
Ok
(
(
)
)
}
pub
(
super
)
fn
add_record_definition
(
&
mut
self
defn
:
Record
)
-
>
Result
<
(
)
>
{
match
self
.
records
.
entry
(
defn
.
name
(
)
.
to_owned
(
)
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
for
field
in
defn
.
fields
(
)
{
self
.
types
.
add_known_type
(
&
field
.
as_type
(
)
)
;
}
v
.
insert
(
defn
)
;
}
Entry
:
:
Occupied
(
o
)
=
>
{
let
existing_def
=
o
.
get
(
)
;
if
defn
!
=
*
existing_def
{
bail
!
(
"
Mismatching
definition
for
record
{
}
!
\
n
\
existing
definition
:
{
existing_def
:
#
?
}
\
n
\
new
definition
:
{
defn
:
#
?
}
"
defn
.
name
(
)
)
;
}
}
}
Ok
(
(
)
)
}
pub
(
super
)
fn
add_function_definition
(
&
mut
self
defn
:
Function
)
-
>
Result
<
(
)
>
{
for
arg
in
&
defn
.
arguments
{
self
.
types
.
add_known_type
(
&
arg
.
type_
)
;
}
if
let
Some
(
ty
)
=
&
defn
.
return_type
{
self
.
types
.
add_known_type
(
ty
)
;
}
if
self
.
functions
.
iter
(
)
.
any
(
|
f
|
f
.
name
=
=
defn
.
name
)
{
bail
!
(
"
duplicate
function
definition
:
\
"
{
}
\
"
"
defn
.
name
)
;
}
if
!
matches
!
(
self
.
types
.
get_type_definition
(
defn
.
name
(
)
)
None
)
{
bail
!
(
"
Conflicting
type
definition
for
\
"
{
}
\
"
"
defn
.
name
(
)
)
;
}
if
defn
.
is_async
(
)
{
self
.
types
.
add_known_type
(
&
Type
:
:
ForeignExecutor
)
;
}
self
.
functions
.
push
(
defn
)
;
Ok
(
(
)
)
}
pub
(
super
)
fn
add_constructor_meta
(
&
mut
self
meta
:
ConstructorMetadata
)
-
>
Result
<
(
)
>
{
let
object
=
get_object
(
&
mut
self
.
objects
&
meta
.
self_name
)
.
ok_or_else
(
|
|
anyhow
!
(
"
add_constructor_meta
:
object
{
}
not
found
"
&
meta
.
self_name
)
)
?
;
let
defn
:
Constructor
=
meta
.
into
(
)
;
for
arg
in
&
defn
.
arguments
{
self
.
types
.
add_known_type
(
&
arg
.
type_
)
;
}
object
.
constructors
.
push
(
defn
)
;
Ok
(
(
)
)
}
pub
(
super
)
fn
add_method_meta
(
&
mut
self
meta
:
impl
Into
<
Method
>
)
-
>
Result
<
(
)
>
{
let
defn
:
Method
=
meta
.
into
(
)
;
let
object
=
get_object
(
&
mut
self
.
objects
&
defn
.
object_name
)
.
ok_or_else
(
|
|
anyhow
!
(
"
add_method_meta
:
object
{
}
not
found
"
&
defn
.
object_name
)
)
?
;
for
arg
in
&
defn
.
arguments
{
self
.
types
.
add_known_type
(
&
arg
.
type_
)
;
}
if
let
Some
(
ty
)
=
&
defn
.
return_type
{
self
.
types
.
add_known_type
(
ty
)
;
}
if
defn
.
is_async
(
)
{
self
.
types
.
add_known_type
(
&
Type
:
:
ForeignExecutor
)
;
}
object
.
methods
.
push
(
defn
)
;
Ok
(
(
)
)
}
pub
(
super
)
fn
add_object_meta
(
&
mut
self
meta
:
ObjectMetadata
)
{
let
free_name
=
meta
.
free_ffi_symbol_name
(
)
;
let
mut
obj
=
Object
:
:
new
(
meta
.
name
ObjectImpl
:
:
from_is_trait
(
meta
.
is_trait
)
)
;
obj
.
ffi_func_free
.
name
=
free_name
;
self
.
types
.
add_known_type
(
&
obj
.
as_type
(
)
)
;
self
.
add_object_definition
(
obj
)
;
}
fn
add_object_definition
(
&
mut
self
defn
:
Object
)
{
self
.
objects
.
push
(
defn
)
;
}
pub
(
super
)
fn
note_name_used_as_error
(
&
mut
self
name
:
&
str
)
{
self
.
errors
.
insert
(
name
.
to_string
(
)
)
;
}
pub
fn
is_name_used_as_error
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
errors
.
contains
(
name
)
}
pub
(
super
)
fn
add_callback_interface_definition
(
&
mut
self
defn
:
CallbackInterface
)
{
for
method
in
defn
.
methods
(
)
{
if
let
Some
(
error
)
=
method
.
throws_type
(
)
{
self
.
callback_interface_throws_types
.
insert
(
error
.
clone
(
)
)
;
}
}
self
.
callback_interfaces
.
push
(
defn
)
;
}
pub
(
super
)
fn
add_trait_method_meta
(
&
mut
self
meta
:
TraitMethodMetadata
)
-
>
Result
<
(
)
>
{
if
let
Some
(
cbi
)
=
get_callback_interface
(
&
mut
self
.
callback_interfaces
&
meta
.
trait_name
)
{
if
cbi
.
methods
.
len
(
)
!
=
meta
.
index
as
usize
{
bail
!
(
"
UniFFI
internal
error
:
callback
interface
method
index
mismatch
for
{
}
:
:
{
}
(
expected
{
}
saw
{
}
)
"
meta
.
trait_name
meta
.
name
cbi
.
methods
.
len
(
)
meta
.
index
)
;
}
cbi
.
methods
.
push
(
meta
.
into
(
)
)
;
}
else
{
self
.
add_method_meta
(
meta
)
?
;
}
Ok
(
(
)
)
}
pub
fn
check_consistency
(
&
self
)
-
>
Result
<
(
)
>
{
if
self
.
namespace
.
is_empty
(
)
{
bail
!
(
"
missing
namespace
definition
"
)
;
}
for
e
in
self
.
enums
.
values
(
)
{
if
!
self
.
is_name_used_as_error
(
&
e
.
name
)
{
for
variant
in
&
e
.
variants
{
if
self
.
types
.
get_type_definition
(
variant
.
name
(
)
)
.
is_some
(
)
{
bail
!
(
"
Enum
variant
names
must
not
shadow
type
names
:
\
"
{
}
\
"
"
variant
.
name
(
)
)
}
}
}
}
for
ty
in
self
.
iter_types
(
)
{
match
ty
{
Type
:
:
Object
{
name
.
.
}
=
>
{
ensure
!
(
self
.
objects
.
iter
(
)
.
any
(
|
o
|
o
.
name
=
=
*
name
)
"
Object
{
name
}
has
no
definition
"
)
;
}
Type
:
:
Record
(
name
)
=
>
{
ensure
!
(
self
.
records
.
contains_key
(
name
)
"
Record
{
name
}
has
no
definition
"
)
;
}
Type
:
:
Enum
(
name
)
=
>
{
ensure
!
(
self
.
enums
.
contains_key
(
name
)
"
Enum
{
name
}
has
no
definition
"
)
;
}
_
=
>
{
}
}
}
Ok
(
(
)
)
}
pub
fn
derive_ffi_funcs
(
&
mut
self
)
-
>
Result
<
(
)
>
{
let
ci_namespace
=
self
.
ffi_namespace
(
)
.
to_owned
(
)
;
for
func
in
self
.
functions
.
iter_mut
(
)
{
func
.
derive_ffi_func
(
&
ci_namespace
)
?
;
}
for
obj
in
self
.
objects
.
iter_mut
(
)
{
obj
.
derive_ffi_funcs
(
&
ci_namespace
)
?
;
}
for
callback
in
self
.
callback_interfaces
.
iter_mut
(
)
{
callback
.
derive_ffi_funcs
(
&
ci_namespace
)
;
}
Ok
(
(
)
)
}
}
fn
get_object
<
'
a
>
(
objects
:
&
'
a
mut
[
Object
]
name
:
&
str
)
-
>
Option
<
&
'
a
mut
Object
>
{
objects
.
iter_mut
(
)
.
find
(
|
o
|
o
.
name
=
=
name
)
}
fn
get_callback_interface
<
'
a
>
(
callback_interfaces
:
&
'
a
mut
[
CallbackInterface
]
name
:
&
str
)
-
>
Option
<
&
'
a
mut
CallbackInterface
>
{
callback_interfaces
.
iter_mut
(
)
.
find
(
|
o
|
o
.
name
=
=
name
)
}
struct
RecursiveTypeIterator
<
'
a
>
{
ci
:
&
'
a
ComponentInterface
current
:
TypeIterator
<
'
a
>
seen
:
HashSet
<
&
'
a
str
>
pending
:
Vec
<
&
'
a
Type
>
}
impl
<
'
a
>
RecursiveTypeIterator
<
'
a
>
{
fn
new
(
ci
:
&
'
a
ComponentInterface
item
:
&
'
a
Type
)
-
>
RecursiveTypeIterator
<
'
a
>
{
RecursiveTypeIterator
{
ci
current
:
item
.
iter_types
(
)
seen
:
Default
:
:
default
(
)
pending
:
Default
:
:
default
(
)
}
}
fn
add_pending_type
(
&
mut
self
type_
:
&
'
a
Type
)
{
match
type_
{
Type
:
:
Record
(
nm
)
|
Type
:
:
Enum
(
nm
)
|
Type
:
:
Object
{
name
:
nm
.
.
}
|
Type
:
:
CallbackInterface
(
nm
)
=
>
{
if
!
self
.
seen
.
contains
(
nm
.
as_str
(
)
)
{
self
.
pending
.
push
(
type_
)
;
self
.
seen
.
insert
(
nm
.
as_str
(
)
)
;
}
}
_
=
>
(
)
}
}
fn
advance_to_next_type
(
&
mut
self
)
-
>
Option
<
&
'
a
Type
>
{
if
let
Some
(
next_type
)
=
self
.
pending
.
pop
(
)
{
let
next_iter
=
match
next_type
{
Type
:
:
Record
(
nm
)
=
>
self
.
ci
.
get_record_definition
(
nm
)
.
map
(
Record
:
:
iter_types
)
Type
:
:
Enum
(
name
)
=
>
self
.
ci
.
get_enum_definition
(
name
)
.
map
(
Enum
:
:
iter_types
)
Type
:
:
Object
{
name
:
nm
.
.
}
=
>
{
self
.
ci
.
get_object_definition
(
nm
)
.
map
(
Object
:
:
iter_types
)
}
Type
:
:
CallbackInterface
(
nm
)
=
>
self
.
ci
.
get_callback_interface_definition
(
nm
)
.
map
(
CallbackInterface
:
:
iter_types
)
_
=
>
None
}
;
if
let
Some
(
next_iter
)
=
next_iter
{
self
.
current
=
next_iter
;
}
self
.
next
(
)
}
else
{
None
}
}
}
impl
<
'
a
>
Iterator
for
RecursiveTypeIterator
<
'
a
>
{
type
Item
=
&
'
a
Type
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
type_
)
=
self
.
current
.
next
(
)
{
self
.
add_pending_type
(
type_
)
;
Some
(
type_
)
}
else
{
self
.
advance_to_next_type
(
)
}
}
}
trait
APIBuilder
{
fn
process
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
(
)
>
;
}
impl
<
T
:
APIBuilder
>
APIBuilder
for
Vec
<
T
>
{
fn
process
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
(
)
>
{
for
item
in
self
{
item
.
process
(
ci
)
?
;
}
Ok
(
(
)
)
}
}
impl
APIBuilder
for
weedle
:
:
Definition
<
'
_
>
{
fn
process
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
(
)
>
{
match
self
{
weedle
:
:
Definition
:
:
Namespace
(
d
)
=
>
d
.
process
(
ci
)
?
weedle
:
:
Definition
:
:
Enum
(
d
)
=
>
{
let
attrs
=
attributes
:
:
EnumAttributes
:
:
try_from
(
d
.
attributes
.
as_ref
(
)
)
?
;
if
attrs
.
contains_error_attr
(
)
{
let
e
=
d
.
convert
(
ci
)
?
;
ci
.
note_name_used_as_error
(
&
e
.
name
)
;
ci
.
add_enum_definition
(
e
)
?
;
}
else
{
let
e
=
d
.
convert
(
ci
)
?
;
ci
.
add_enum_definition
(
e
)
?
;
}
}
weedle
:
:
Definition
:
:
Dictionary
(
d
)
=
>
{
let
rec
=
d
.
convert
(
ci
)
?
;
ci
.
add_record_definition
(
rec
)
?
;
}
weedle
:
:
Definition
:
:
Interface
(
d
)
=
>
{
let
attrs
=
attributes
:
:
InterfaceAttributes
:
:
try_from
(
d
.
attributes
.
as_ref
(
)
)
?
;
if
attrs
.
contains_enum_attr
(
)
{
let
e
=
d
.
convert
(
ci
)
?
;
ci
.
add_enum_definition
(
e
)
?
;
}
else
if
attrs
.
contains_error_attr
(
)
{
let
e
:
Enum
=
d
.
convert
(
ci
)
?
;
ci
.
note_name_used_as_error
(
&
e
.
name
)
;
ci
.
add_enum_definition
(
e
)
?
;
}
else
{
let
obj
=
d
.
convert
(
ci
)
?
;
ci
.
add_object_definition
(
obj
)
;
}
}
weedle
:
:
Definition
:
:
CallbackInterface
(
d
)
=
>
{
let
obj
=
d
.
convert
(
ci
)
?
;
ci
.
add_callback_interface_definition
(
obj
)
;
}
weedle
:
:
Definition
:
:
Typedef
(
_
)
=
>
{
}
_
=
>
bail
!
(
"
don
'
t
know
how
to
deal
with
{
:
?
}
"
self
)
}
Ok
(
(
)
)
}
}
trait
APIConverter
<
T
>
{
fn
convert
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
T
>
;
}
impl
<
U
T
:
APIConverter
<
U
>
>
APIConverter
<
Vec
<
U
>
>
for
Vec
<
T
>
{
fn
convert
(
&
self
ci
:
&
mut
ComponentInterface
)
-
>
Result
<
Vec
<
U
>
>
{
self
.
iter
(
)
.
map
(
|
v
|
v
.
convert
(
ci
)
)
.
collect
:
:
<
Result
<
_
>
>
(
)
}
}
fn
throws_name
(
throws
:
&
Option
<
Type
>
)
-
>
Option
<
&
str
>
{
match
throws
{
None
=
>
None
Some
(
Type
:
:
Enum
(
name
)
)
=
>
Some
(
name
)
_
=
>
panic
!
(
"
unknown
throw
type
:
{
throws
:
?
}
"
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_duplicate_type_names_are_an_error
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
Testing
{
constructor
(
)
;
}
;
dictionary
Testing
{
u32
field
;
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Conflicting
type
definition
for
Testing
!
\
existing
definition
:
Object
{
name
:
\
"
Testing
\
"
imp
:
Struct
}
\
new
definition
:
Record
(
\
"
Testing
\
"
)
"
)
;
const
UDL2
:
&
str
=
r
#
"
namespace
test
{
}
;
enum
Testing
{
"
one
"
"
two
"
}
;
[
Error
]
enum
Testing
{
"
three
"
"
four
"
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL2
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Mismatching
definition
for
enum
Testing
!
\
nexisting
definition
:
Enum
{
name
:
\
"
Testing
\
"
variants
:
[
Variant
{
name
:
\
"
one
\
"
fields
:
[
]
}
Variant
{
name
:
\
"
two
\
"
fields
:
[
]
}
]
flat
:
true
}
new
definition
:
Enum
{
name
:
\
"
Testing
\
"
variants
:
[
Variant
{
name
:
\
"
three
\
"
fields
:
[
]
}
Variant
{
name
:
\
"
four
\
"
fields
:
[
]
}
]
flat
:
true
}
"
)
;
const
UDL3
:
&
str
=
r
#
"
namespace
test
{
u32
Testing
(
)
;
}
;
enum
Testing
{
"
one
"
"
two
"
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL3
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Conflicting
type
definition
for
\
"
Testing
\
"
"
)
;
}
#
[
test
]
fn
test_enum_variant_names_dont_shadow_types
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
Testing
{
constructor
(
)
;
}
;
[
Enum
]
interface
HardToCodegenFor
{
Testing
(
)
;
OtherVariant
(
u32
field
)
;
}
;
"
#
;
let
err
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
to_string
(
)
"
Enum
variant
names
must
not
shadow
type
names
:
\
"
Testing
\
"
"
)
;
}
#
[
test
]
fn
test_contains_optional_types
(
)
{
let
mut
ci
=
ComponentInterface
{
.
.
Default
:
:
default
(
)
}
;
assert
!
(
!
ci
.
contains_optional_types
(
)
)
;
assert
!
(
ci
.
types
.
add_type_definition
(
"
TestOptional
{
}
"
Type
:
:
Optional
(
Box
:
:
new
(
Type
:
:
String
)
)
)
.
is_ok
(
)
)
;
assert
!
(
ci
.
contains_optional_types
(
)
)
;
}
#
[
test
]
fn
test_contains_sequence_types
(
)
{
let
mut
ci
=
ComponentInterface
{
.
.
Default
:
:
default
(
)
}
;
assert
!
(
!
ci
.
contains_sequence_types
(
)
)
;
assert
!
(
ci
.
types
.
add_type_definition
(
"
TestSequence
{
}
"
Type
:
:
Sequence
(
Box
:
:
new
(
Type
:
:
UInt64
)
)
)
.
is_ok
(
)
)
;
assert
!
(
ci
.
contains_sequence_types
(
)
)
;
}
#
[
test
]
fn
test_contains_map_types
(
)
{
let
mut
ci
=
ComponentInterface
{
.
.
Default
:
:
default
(
)
}
;
assert
!
(
!
ci
.
contains_map_types
(
)
)
;
assert
!
(
ci
.
types
.
add_type_definition
(
"
Map
{
}
"
Type
:
:
Map
(
Box
:
:
new
(
Type
:
:
String
)
Box
:
:
new
(
Type
:
:
Boolean
)
)
)
.
is_ok
(
)
)
;
assert
!
(
ci
.
contains_map_types
(
)
)
;
}
#
[
test
]
fn
test_no_infinite_recursion_when_walking_types
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
Testing
{
void
tester
(
Testing
foo
)
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap
(
)
;
assert
!
(
!
ci
.
item_contains_unsigned_types
(
&
Type
:
:
Object
{
name
:
"
Testing
"
.
into
(
)
imp
:
ObjectImpl
:
:
Struct
}
)
)
;
}
#
[
test
]
fn
test_correct_recursion_when_walking_types
(
)
{
const
UDL
:
&
str
=
r
#
"
namespace
test
{
}
;
interface
TestObj
{
void
tester
(
TestRecord
foo
)
;
}
;
dictionary
TestRecord
{
NestedRecord
bar
;
}
;
dictionary
NestedRecord
{
u64
baz
;
}
;
"
#
;
let
ci
=
ComponentInterface
:
:
from_webidl
(
UDL
)
.
unwrap
(
)
;
assert
!
(
ci
.
item_contains_unsigned_types
(
&
Type
:
:
Object
{
name
:
"
TestObj
"
.
into
(
)
imp
:
ObjectImpl
:
:
Struct
}
)
)
;
}
}
