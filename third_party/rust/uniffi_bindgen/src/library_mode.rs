use
crate
:
:
{
macro_metadata
overridden_config_value
BindgenCrateConfigSupplier
BindingGenerator
Component
ComponentInterface
GenerationSettings
Result
}
;
use
anyhow
:
:
{
bail
Context
}
;
use
camino
:
:
Utf8Path
;
use
std
:
:
{
collections
:
:
BTreeMap
fs
}
;
use
toml
:
:
value
:
:
Table
as
TomlTable
;
use
uniffi_meta
:
:
{
create_metadata_groups
group_metadata
Metadata
MetadataGroup
NamespaceMetadata
}
;
pub
fn
generate_bindings
<
T
:
BindingGenerator
>
(
library_path
:
&
Utf8Path
crate_name
:
Option
<
String
>
binding_generator
:
&
T
config_supplier
:
&
dyn
BindgenCrateConfigSupplier
config_file_override
:
Option
<
&
Utf8Path
>
out_dir
:
&
Utf8Path
try_format_code
:
bool
)
-
>
Result
<
Vec
<
Component
<
T
:
:
Config
>
>
>
{
let
mut
components
=
find_components
(
library_path
config_supplier
)
.
with_context
(
|
|
format
!
(
"
finding
components
in
'
{
library_path
}
'
"
)
)
?
.
into_iter
(
)
.
map
(
|
Component
{
ci
config
}
|
{
let
toml_value
=
overridden_config_value
(
config
config_file_override
)
?
;
let
config
=
binding_generator
.
new_config
(
&
toml_value
)
.
context
(
"
loading
toml
"
)
?
;
Ok
(
Component
{
ci
config
}
)
}
)
.
collect
:
:
<
Result
<
Vec
<
_
>
>
>
(
)
?
;
let
settings
=
GenerationSettings
{
out_dir
:
out_dir
.
to_owned
(
)
try_format_code
cdylib
:
calc_cdylib_name
(
library_path
)
.
map
(
ToOwned
:
:
to_owned
)
}
;
binding_generator
.
update_component_configs
(
&
settings
&
mut
components
)
?
;
fs
:
:
create_dir_all
(
out_dir
)
?
;
if
let
Some
(
crate_name
)
=
&
crate_name
{
let
old_elements
=
components
.
drain
(
.
.
)
;
let
mut
matches
:
Vec
<
_
>
=
old_elements
.
filter
(
|
s
|
s
.
ci
.
crate_name
(
)
=
=
crate_name
)
.
collect
(
)
;
match
matches
.
len
(
)
{
0
=
>
bail
!
(
"
Crate
{
crate_name
}
not
found
in
{
library_path
}
"
)
1
=
>
components
.
push
(
matches
.
pop
(
)
.
unwrap
(
)
)
n
=
>
bail
!
(
"
{
n
}
crates
named
{
crate_name
}
found
in
{
library_path
}
"
)
}
}
binding_generator
.
write_bindings
(
&
settings
&
components
)
?
;
Ok
(
components
)
}
pub
fn
calc_cdylib_name
(
library_path
:
&
Utf8Path
)
-
>
Option
<
&
str
>
{
let
cdylib_extensions
=
[
"
.
so
"
"
.
dll
"
"
.
dylib
"
]
;
let
filename
=
library_path
.
file_name
(
)
?
;
let
filename
=
filename
.
strip_prefix
(
"
lib
"
)
.
unwrap_or
(
filename
)
;
for
ext
in
cdylib_extensions
{
if
let
Some
(
f
)
=
filename
.
strip_suffix
(
ext
)
{
return
Some
(
f
)
;
}
}
None
}
pub
fn
find_components
(
library_path
:
&
Utf8Path
config_supplier
:
&
dyn
BindgenCrateConfigSupplier
)
-
>
Result
<
Vec
<
Component
<
TomlTable
>
>
>
{
let
items
=
macro_metadata
:
:
extract_from_library
(
library_path
)
?
;
let
mut
metadata_groups
=
create_metadata_groups
(
&
items
)
;
group_metadata
(
&
mut
metadata_groups
items
)
?
;
for
group
in
metadata_groups
.
values_mut
(
)
{
let
crate_name
=
group
.
namespace
.
crate_name
.
clone
(
)
;
if
let
Some
(
udl_group
)
=
load_udl_metadata
(
group
&
crate_name
config_supplier
)
?
{
let
mut
udl_items
=
udl_group
.
items
.
into_iter
(
)
.
filter
(
|
item
|
!
matches
!
(
item
Metadata
:
:
UniffiTrait
{
.
.
}
)
)
.
collect
(
)
;
group
.
items
.
append
(
&
mut
udl_items
)
;
if
group
.
namespace_docstring
.
is_none
(
)
{
group
.
namespace_docstring
=
udl_group
.
namespace_docstring
;
}
}
;
}
let
crate_to_namespace_map
:
BTreeMap
<
String
NamespaceMetadata
>
=
metadata_groups
.
iter
(
)
.
map
(
|
(
k
v
)
|
(
k
.
clone
(
)
v
.
namespace
.
clone
(
)
)
)
.
collect
(
)
;
metadata_groups
.
into_values
(
)
.
map
(
|
group
|
{
let
crate_name
=
&
group
.
namespace
.
crate_name
;
let
mut
ci
=
ComponentInterface
:
:
new
(
crate_name
)
;
ci
.
add_metadata
(
group
)
?
;
let
config
=
config_supplier
.
get_toml
(
ci
.
crate_name
(
)
)
?
.
unwrap_or_default
(
)
;
ci
.
set_crate_to_namespace_map
(
crate_to_namespace_map
.
clone
(
)
)
;
Ok
(
Component
{
ci
config
}
)
}
)
.
collect
(
)
}
fn
load_udl_metadata
(
group
:
&
MetadataGroup
crate_name
:
&
str
config_supplier
:
&
dyn
BindgenCrateConfigSupplier
)
-
>
Result
<
Option
<
MetadataGroup
>
>
{
let
udl_items
=
group
.
items
.
iter
(
)
.
filter_map
(
|
i
|
match
i
{
Metadata
:
:
UdlFile
(
meta
)
=
>
Some
(
meta
)
_
=
>
None
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
match
udl_items
.
len
(
)
{
0
=
>
Ok
(
None
)
1
=
>
{
if
udl_items
[
0
]
.
module_path
!
=
crate_name
{
bail
!
(
"
UDL
is
for
crate
'
{
}
'
but
this
crate
name
is
'
{
}
'
"
udl_items
[
0
]
.
module_path
crate_name
)
;
}
let
udl
=
config_supplier
.
get_udl
(
crate_name
&
udl_items
[
0
]
.
file_stub
)
?
;
let
udl_group
=
uniffi_udl
:
:
parse_udl
(
&
udl
crate_name
)
?
;
Ok
(
Some
(
udl_group
)
)
}
n
=
>
bail
!
(
"
{
n
}
UDL
files
found
for
{
crate_name
}
"
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
calc_cdylib_name_is_correct
(
)
{
assert_eq
!
(
"
uniffi
"
calc_cdylib_name
(
"
/
path
/
to
/
libuniffi
.
so
"
.
into
(
)
)
.
unwrap
(
)
)
;
assert_eq
!
(
"
uniffi
"
calc_cdylib_name
(
"
/
path
/
to
/
libuniffi
.
dylib
"
.
into
(
)
)
.
unwrap
(
)
)
;
assert_eq
!
(
"
uniffi
"
calc_cdylib_name
(
"
/
path
/
to
/
uniffi
.
dll
"
.
into
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
#
[
ignore
]
fn
calc_cdylib_name_is_correct_on_windows
(
)
{
assert_eq
!
(
"
libuniffi
"
calc_cdylib_name
(
"
/
path
/
to
/
libuniffi
.
dll
"
.
into
(
)
)
.
unwrap
(
)
)
;
}
}
