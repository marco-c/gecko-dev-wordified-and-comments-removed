use
super
:
:
*
;
pub
fn
pass
(
module
:
&
mut
Module
)
-
>
Result
<
(
)
>
{
let
module_name
=
module
.
name
.
clone
(
)
;
module
.
visit_mut
(
|
node
:
&
mut
TypeNode
|
{
node
.
ffi_type
=
generate_ffi_type
(
&
node
.
ty
&
module_name
)
;
}
)
;
Ok
(
(
)
)
}
fn
generate_ffi_type
(
ty
:
&
Type
current_module_name
:
&
str
)
-
>
FfiType
{
match
ty
{
Type
:
:
UInt8
=
>
FfiType
:
:
UInt8
Type
:
:
Int8
=
>
FfiType
:
:
Int8
Type
:
:
UInt16
=
>
FfiType
:
:
UInt16
Type
:
:
Int16
=
>
FfiType
:
:
Int16
Type
:
:
UInt32
=
>
FfiType
:
:
UInt32
Type
:
:
Int32
=
>
FfiType
:
:
Int32
Type
:
:
UInt64
=
>
FfiType
:
:
UInt64
Type
:
:
Int64
=
>
FfiType
:
:
Int64
Type
:
:
Float32
=
>
FfiType
:
:
Float32
Type
:
:
Float64
=
>
FfiType
:
:
Float64
Type
:
:
Boolean
=
>
FfiType
:
:
Int8
Type
:
:
String
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Bytes
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Interface
{
module_name
name
.
.
}
=
>
FfiType
:
:
RustArcPtr
{
module_name
:
module_name
.
clone
(
)
object_name
:
name
.
clone
(
)
}
Type
:
:
CallbackInterface
{
module_name
name
}
=
>
{
FfiType
:
:
Handle
(
HandleKind
:
:
CallbackInterface
{
module_name
:
module_name
.
clone
(
)
interface_name
:
name
.
clone
(
)
}
)
}
Type
:
:
Enum
{
module_name
.
.
}
|
Type
:
:
Record
{
module_name
.
.
}
=
>
{
FfiType
:
:
RustBuffer
(
(
module_name
!
=
current_module_name
)
.
then_some
(
module_name
.
clone
(
)
)
)
}
Type
:
:
Optional
{
.
.
}
|
Type
:
:
Sequence
{
.
.
}
|
Type
:
:
Map
{
.
.
}
|
Type
:
:
Timestamp
|
Type
:
:
Duration
=
>
FfiType
:
:
RustBuffer
(
None
)
Type
:
:
Custom
{
builtin
.
.
}
=
>
generate_ffi_type
(
builtin
current_module_name
)
}
}
