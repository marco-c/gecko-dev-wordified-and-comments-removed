use
indexmap
:
:
IndexMap
;
use
uniffi_pipeline
:
:
Node
;
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Root
{
pub
cdylib
:
Option
<
String
>
pub
modules
:
IndexMap
<
String
Module
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Module
{
pub
name
:
String
pub
crate_name
:
String
pub
config_toml
:
Option
<
String
>
pub
docstring
:
Option
<
String
>
pub
functions
:
Vec
<
Function
>
pub
type_definitions
:
Vec
<
TypeDefinition
>
pub
ffi_definitions
:
Vec
<
FfiDefinition
>
pub
checksums
:
Vec
<
Checksum
>
pub
ffi_rustbuffer_alloc
:
RustFfiFunctionName
pub
ffi_rustbuffer_from_bytes
:
RustFfiFunctionName
pub
ffi_rustbuffer_free
:
RustFfiFunctionName
pub
ffi_rustbuffer_reserve
:
RustFfiFunctionName
pub
ffi_uniffi_contract_version
:
RustFfiFunctionName
pub
correct_contract_version
:
String
pub
string_type_node
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Function
{
pub
name
:
String
pub
callable
:
Callable
pub
is_async
:
bool
pub
inputs
:
Vec
<
Argument
>
pub
return_type
:
Option
<
Type
>
pub
throws
:
Option
<
Type
>
pub
checksum
:
Option
<
u16
>
pub
docstring
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
TypeDefinition
{
Interface
(
Interface
)
CallbackInterface
(
CallbackInterface
)
Record
(
Record
)
Enum
(
Enum
)
Custom
(
CustomType
)
Simple
(
TypeNode
)
Optional
(
OptionalType
)
Sequence
(
SequenceType
)
Map
(
MapType
)
External
(
ExternalType
)
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Constructor
{
pub
name
:
String
pub
callable
:
Callable
pub
is_async
:
bool
pub
inputs
:
Vec
<
Argument
>
pub
throws
:
Option
<
Type
>
pub
checksum
:
Option
<
u16
>
pub
docstring
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Method
{
pub
name
:
String
pub
callable
:
Callable
pub
is_async
:
bool
pub
inputs
:
Vec
<
Argument
>
pub
return_type
:
Option
<
Type
>
pub
throws
:
Option
<
Type
>
pub
checksum
:
Option
<
u16
>
pub
docstring
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Callable
{
pub
name
:
String
pub
is_async
:
bool
pub
async_data
:
Option
<
AsyncData
>
pub
kind
:
CallableKind
pub
arguments
:
Vec
<
Argument
>
pub
return_type
:
ReturnType
pub
throws_type
:
ThrowsType
pub
checksum
:
Option
<
u16
>
pub
ffi_func
:
RustFfiFunctionName
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
CallableKind
{
Function
Method
{
interface_name
:
String
}
Constructor
{
interface_name
:
String
primary
:
bool
}
VTableMethod
{
trait_name
:
String
}
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
ReturnType
{
pub
ty
:
Option
<
TypeNode
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
ThrowsType
{
pub
ty
:
Option
<
TypeNode
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
AsyncData
{
pub
ffi_rust_future_poll
:
RustFfiFunctionName
pub
ffi_rust_future_cancel
:
RustFfiFunctionName
pub
ffi_rust_future_free
:
RustFfiFunctionName
pub
ffi_rust_future_complete
:
RustFfiFunctionName
pub
ffi_foreign_future_complete
:
FfiFunctionTypeName
pub
ffi_foreign_future_result
:
FfiStructName
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Argument
{
pub
name
:
String
pub
ty
:
TypeNode
pub
optional
:
bool
pub
default
:
Option
<
LiteralNode
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
LiteralNode
{
#
[
node
(
wraps
)
]
pub
lit
:
Literal
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
Literal
{
Boolean
(
bool
)
String
(
String
)
UInt
(
u64
Radix
TypeNode
)
Int
(
i64
Radix
TypeNode
)
Float
(
String
TypeNode
)
Enum
(
String
TypeNode
)
EmptySequence
EmptyMap
None
Some
{
inner
:
Box
<
Literal
>
}
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
Radix
{
Decimal
=
10
Octal
=
8
Hexadecimal
=
16
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Record
{
pub
name
:
String
pub
fields
:
Vec
<
Field
>
pub
docstring
:
Option
<
String
>
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Field
{
pub
name
:
String
pub
ty
:
TypeNode
pub
default
:
Option
<
LiteralNode
>
pub
docstring
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
EnumShape
{
Enum
Error
{
flat
:
bool
}
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Enum
{
pub
name
:
String
pub
is_flat
:
bool
pub
shape
:
EnumShape
pub
variants
:
Vec
<
Variant
>
pub
discr_type
:
Option
<
TypeNode
>
pub
docstring
:
Option
<
String
>
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Variant
{
pub
name
:
String
pub
discr
:
Option
<
LiteralNode
>
pub
fields
:
Vec
<
Field
>
pub
docstring
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Interface
{
pub
name
:
String
pub
docstring
:
Option
<
String
>
pub
constructors
:
Vec
<
Constructor
>
pub
methods
:
Vec
<
Method
>
pub
uniffi_traits
:
Vec
<
UniffiTrait
>
pub
trait_impls
:
Vec
<
ObjectTraitImpl
>
pub
imp
:
ObjectImpl
pub
self_type
:
TypeNode
pub
vtable
:
Option
<
VTable
>
pub
ffi_func_clone
:
RustFfiFunctionName
pub
ffi_func_free
:
RustFfiFunctionName
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
CallbackInterface
{
pub
name
:
String
pub
docstring
:
Option
<
String
>
pub
vtable
:
VTable
pub
methods
:
Vec
<
Method
>
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
VTable
{
pub
struct_type
:
FfiType
pub
interface_name
:
String
pub
init_fn
:
RustFfiFunctionName
pub
methods
:
Vec
<
VTableMethod
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
VTableMethod
{
pub
callable
:
Callable
pub
ffi_type
:
FfiType
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
UniffiTrait
{
Debug
{
fmt
:
Method
}
Display
{
fmt
:
Method
}
Eq
{
eq
:
Method
ne
:
Method
}
Hash
{
hash
:
Method
}
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
ObjectTraitImpl
{
pub
ty
:
TypeNode
pub
trait_name
:
String
pub
tr_module_name
:
Option
<
String
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
CustomType
{
pub
name
:
String
pub
builtin
:
TypeNode
pub
docstring
:
Option
<
String
>
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
OptionalType
{
pub
inner
:
TypeNode
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
SequenceType
{
pub
inner
:
TypeNode
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
MapType
{
pub
key
:
TypeNode
pub
value
:
TypeNode
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
ExternalType
{
pub
module_name
:
String
pub
name
:
String
pub
self_type
:
TypeNode
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
TypeNode
{
#
[
node
(
wraps
)
]
pub
ty
:
Type
pub
canonical_name
:
String
pub
is_used_as_error
:
bool
pub
ffi_type
:
FfiType
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
Node
)
]
pub
enum
Type
{
UInt8
Int8
UInt16
Int16
UInt32
Int32
UInt64
Int64
Float32
Float64
Boolean
String
Bytes
Timestamp
Duration
Optional
{
inner_type
:
Box
<
Type
>
}
Sequence
{
inner_type
:
Box
<
Type
>
}
Map
{
key_type
:
Box
<
Type
>
value_type
:
Box
<
Type
>
}
Interface
{
module_name
:
String
name
:
String
imp
:
ObjectImpl
}
Record
{
module_name
:
String
name
:
String
}
Enum
{
module_name
:
String
name
:
String
}
CallbackInterface
{
module_name
:
String
name
:
String
}
Custom
{
module_name
:
String
name
:
String
builtin
:
Box
<
Type
>
}
}
#
[
derive
(
Debug
Clone
Node
PartialEq
Eq
Hash
)
]
pub
enum
ObjectImpl
{
Struct
Trait
CallbackTrait
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
FfiDefinition
{
RustFunction
(
FfiFunction
)
FunctionType
(
FfiFunctionType
)
Struct
(
FfiStruct
)
}
#
[
derive
(
Debug
Clone
Node
PartialEq
Eq
Hash
)
]
pub
struct
RustFfiFunctionName
(
pub
String
)
;
#
[
derive
(
Debug
Clone
Node
PartialEq
Eq
Hash
)
]
pub
struct
FfiStructName
(
pub
String
)
;
#
[
derive
(
Debug
Clone
Node
PartialEq
Eq
Hash
)
]
pub
struct
FfiFunctionTypeName
(
pub
String
)
;
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
FfiFunction
{
pub
name
:
RustFfiFunctionName
pub
is_async
:
bool
pub
async_data
:
Option
<
AsyncData
>
pub
arguments
:
Vec
<
FfiArgument
>
pub
return_type
:
FfiReturnType
pub
has_rust_call_status_arg
:
bool
pub
kind
:
FfiFunctionKind
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
enum
FfiFunctionKind
{
Scaffolding
ObjectClone
ObjectFree
RustFuturePoll
RustFutureComplete
RustFutureCancel
RustFutureFree
RustBufferFromBytes
RustBufferFree
RustBufferAlloc
RustBufferReserve
RustVtableInit
UniffiContractVersion
Checksum
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
FfiFunctionType
{
pub
name
:
FfiFunctionTypeName
pub
arguments
:
Vec
<
FfiArgument
>
pub
return_type
:
FfiReturnType
pub
has_rust_call_status_arg
:
bool
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
FfiReturnType
{
pub
ty
:
Option
<
FfiType
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
FfiStruct
{
pub
name
:
FfiStructName
pub
fields
:
Vec
<
FfiField
>
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
FfiField
{
pub
name
:
String
pub
ty
:
FfiType
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
FfiArgument
{
pub
name
:
String
pub
ty
:
FfiType
}
#
[
derive
(
Debug
Clone
Node
PartialEq
Eq
Hash
)
]
pub
enum
FfiType
{
UInt8
Int8
UInt16
Int16
UInt32
Int32
UInt64
Int64
Float32
Float64
RustArcPtr
{
module_name
:
String
object_name
:
String
}
RustBuffer
(
Option
<
String
>
)
ForeignBytes
Function
(
FfiFunctionTypeName
)
Struct
(
FfiStructName
)
Handle
(
HandleKind
)
RustCallStatus
Reference
(
Box
<
FfiType
>
)
MutReference
(
Box
<
FfiType
>
)
VoidPointer
}
#
[
derive
(
Debug
Clone
Node
PartialEq
Eq
Hash
)
]
pub
enum
HandleKind
{
RustFuture
ForeignFuture
ForeignFutureCallbackData
CallbackInterface
{
module_name
:
String
interface_name
:
String
}
}
#
[
derive
(
Debug
Clone
Node
)
]
pub
struct
Checksum
{
pub
fn_name
:
RustFfiFunctionName
pub
checksum
:
u16
}
impl
FfiDefinition
{
pub
fn
name
(
&
self
)
-
>
&
str
{
match
self
{
Self
:
:
RustFunction
(
func
)
=
>
&
func
.
name
.
0
Self
:
:
FunctionType
(
func_type
)
=
>
&
func_type
.
name
.
0
Self
:
:
Struct
(
st
)
=
>
&
st
.
name
.
0
}
}
}
impl
From
<
FfiFunction
>
for
FfiDefinition
{
fn
from
(
func
:
FfiFunction
)
-
>
Self
{
Self
:
:
RustFunction
(
func
)
}
}
impl
From
<
FfiFunctionType
>
for
FfiDefinition
{
fn
from
(
func_type
:
FfiFunctionType
)
-
>
Self
{
Self
:
:
FunctionType
(
func_type
)
}
}
impl
From
<
FfiStruct
>
for
FfiDefinition
{
fn
from
(
st
:
FfiStruct
)
-
>
Self
{
Self
:
:
Struct
(
st
)
}
}
impl
FfiArgument
{
pub
fn
new
(
name
:
impl
Into
<
String
>
ty
:
FfiType
)
-
>
Self
{
Self
{
name
:
name
.
into
(
)
ty
}
}
}
impl
FfiField
{
pub
fn
new
(
name
:
impl
Into
<
String
>
ty
:
FfiType
)
-
>
Self
{
Self
{
name
:
name
.
into
(
)
ty
}
}
}
impl
Callable
{
pub
fn
is_async
(
&
self
)
-
>
bool
{
self
.
async_data
.
is_some
(
)
}
pub
fn
ffi_return_type
(
&
self
)
-
>
Option
<
&
FfiType
>
{
self
.
return_type
.
ty
.
as_ref
(
)
.
map
(
|
ty
|
&
ty
.
ffi_type
)
}
}
impl
Type
{
pub
fn
name
(
&
self
)
-
>
Option
<
&
str
>
{
match
&
self
{
Type
:
:
Record
{
name
.
.
}
|
Type
:
:
Enum
{
name
.
.
}
|
Type
:
:
Interface
{
name
.
.
}
|
Type
:
:
CallbackInterface
{
name
.
.
}
|
Type
:
:
Custom
{
name
.
.
}
=
>
Some
(
name
.
as_str
(
)
)
_
=
>
None
}
}
}
impl
ObjectImpl
{
pub
fn
has_callback_interface
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
CallbackTrait
)
}
}
