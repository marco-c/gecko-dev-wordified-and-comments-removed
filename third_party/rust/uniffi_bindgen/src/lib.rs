#
!
[
warn
(
rust_2018_idioms
unused_qualifications
)
]
#
!
[
allow
(
unknown_lints
)
]
const
BINDGEN_VERSION
:
&
str
=
env
!
(
"
CARGO_PKG_VERSION
"
)
;
use
anyhow
:
:
{
anyhow
bail
Context
Result
}
;
use
camino
:
:
{
Utf8Path
Utf8PathBuf
}
;
use
fs_err
:
:
{
self
as
fs
File
}
;
use
serde
:
:
{
de
:
:
DeserializeOwned
Deserialize
Serialize
}
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
:
:
ErrorKind
;
use
std
:
:
{
collections
:
:
HashMap
env
process
:
:
Command
str
:
:
FromStr
}
;
pub
mod
backend
;
pub
mod
bindings
;
pub
mod
interface
;
pub
mod
library_mode
;
pub
mod
macro_metadata
;
pub
mod
scaffolding
;
use
bindings
:
:
TargetLanguage
;
pub
use
interface
:
:
ComponentInterface
;
use
scaffolding
:
:
RustScaffolding
;
pub
trait
BindingsConfig
:
DeserializeOwned
{
const
TOML_KEY
:
&
'
static
str
;
fn
update_from_ci
(
&
mut
self
ci
:
&
ComponentInterface
)
;
fn
update_from_cdylib_name
(
&
mut
self
cdylib_name
:
&
str
)
;
fn
update_from_dependency_configs
(
&
mut
self
config_map
:
HashMap
<
&
str
&
Self
>
)
;
}
fn
load_bindings_config
<
BC
:
BindingsConfig
>
(
ci
:
&
ComponentInterface
crate_root
:
&
Utf8Path
config_file_override
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
BC
>
{
let
toml_config
=
load_bindings_config_toml
(
crate_root
config_file_override
)
?
.
and_then
(
|
mut
v
|
v
.
as_table_mut
(
)
.
and_then
(
|
t
|
t
.
remove
(
BC
:
:
TOML_KEY
)
)
)
.
unwrap_or_else
(
|
|
toml
:
:
Value
:
:
from
(
toml
:
:
value
:
:
Table
:
:
default
(
)
)
)
;
let
mut
config
:
BC
=
toml_config
.
try_into
(
)
?
;
config
.
update_from_ci
(
ci
)
;
Ok
(
config
)
}
#
[
derive
(
Clone
Debug
Deserialize
Hash
PartialEq
PartialOrd
Ord
Eq
)
]
pub
struct
EmptyBindingsConfig
;
impl
BindingsConfig
for
EmptyBindingsConfig
{
const
TOML_KEY
:
&
'
static
str
=
"
"
;
fn
update_from_ci
(
&
mut
self
_ci
:
&
ComponentInterface
)
{
}
fn
update_from_cdylib_name
(
&
mut
self
_cdylib_name
:
&
str
)
{
}
fn
update_from_dependency_configs
(
&
mut
self
_config_map
:
HashMap
<
&
str
&
Self
>
)
{
}
}
fn
load_bindings_config_toml
(
crate_root
:
&
Utf8Path
config_file_override
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
Option
<
toml
:
:
Value
>
>
{
let
config_path
=
match
config_file_override
{
Some
(
cfg
)
=
>
cfg
.
to_owned
(
)
None
=
>
crate_root
.
join
(
"
uniffi
.
toml
"
)
}
;
if
!
config_path
.
exists
(
)
{
return
Ok
(
None
)
;
}
let
contents
=
fs
:
:
read_to_string
(
&
config_path
)
.
with_context
(
|
|
format
!
(
"
Failed
to
read
config
file
from
{
config_path
}
"
)
)
?
;
let
mut
full_config
=
toml
:
:
Value
:
:
from_str
(
&
contents
)
.
with_context
(
|
|
format
!
(
"
Failed
to
parse
config
file
{
config_path
}
"
)
)
?
;
Ok
(
full_config
.
as_table_mut
(
)
.
and_then
(
|
t
|
t
.
remove
(
"
bindings
"
)
)
)
}
pub
trait
BindingGenerator
:
Sized
{
type
Config
:
BindingsConfig
;
fn
write_bindings
(
&
self
ci
:
ComponentInterface
config
:
Self
:
:
Config
out_dir
:
&
Utf8Path
)
-
>
Result
<
(
)
>
;
}
pub
fn
generate_external_bindings
(
binding_generator
:
impl
BindingGenerator
udl_file
:
impl
AsRef
<
Utf8Path
>
config_file_override
:
Option
<
impl
AsRef
<
Utf8Path
>
>
out_dir_override
:
Option
<
impl
AsRef
<
Utf8Path
>
>
)
-
>
Result
<
(
)
>
{
let
out_dir_override
=
out_dir_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
config_file_override
=
config_file_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
crate_root
=
guess_crate_root
(
udl_file
.
as_ref
(
)
)
?
;
let
out_dir
=
get_out_dir
(
udl_file
.
as_ref
(
)
out_dir_override
)
?
;
let
component
=
parse_udl
(
udl_file
.
as_ref
(
)
)
.
context
(
"
Error
parsing
UDL
"
)
?
;
let
bindings_config
=
load_bindings_config
(
&
component
crate_root
config_file_override
)
?
;
binding_generator
.
write_bindings
(
component
bindings_config
&
out_dir
)
}
pub
fn
generate_component_scaffolding
(
udl_file
:
&
Utf8Path
out_dir_override
:
Option
<
&
Utf8Path
>
format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
component
=
parse_udl
(
udl_file
)
?
;
let
file_stem
=
udl_file
.
file_stem
(
)
.
context
(
"
not
a
file
"
)
?
;
let
filename
=
format
!
(
"
{
file_stem
}
.
uniffi
.
rs
"
)
;
let
out_path
=
get_out_dir
(
udl_file
out_dir_override
)
?
.
join
(
filename
)
;
let
mut
f
=
File
:
:
create
(
&
out_path
)
?
;
write
!
(
f
"
{
}
"
RustScaffolding
:
:
new
(
&
component
)
)
.
context
(
"
Failed
to
write
output
file
"
)
?
;
if
format_code
{
format_code_with_rustfmt
(
&
out_path
)
?
;
}
Ok
(
(
)
)
}
pub
fn
generate_bindings
(
udl_file
:
&
Utf8Path
config_file_override
:
Option
<
&
Utf8Path
>
target_languages
:
Vec
<
TargetLanguage
>
out_dir_override
:
Option
<
&
Utf8Path
>
library_file
:
Option
<
&
Utf8Path
>
try_format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
mut
component
=
parse_udl
(
udl_file
)
?
;
if
let
Some
(
library_file
)
=
library_file
{
macro_metadata
:
:
add_to_ci_from_library
(
&
mut
component
library_file
)
?
;
}
let
crate_root
=
&
guess_crate_root
(
udl_file
)
.
context
(
"
Failed
to
guess
crate
root
"
)
?
;
let
mut
config
=
Config
:
:
load_initial
(
crate_root
config_file_override
)
?
;
config
.
update_from_ci
(
&
component
)
;
let
out_dir
=
get_out_dir
(
udl_file
out_dir_override
)
?
;
for
language
in
target_languages
{
bindings
:
:
write_bindings
(
&
config
.
bindings
&
component
&
out_dir
language
try_format_code
)
?
;
}
Ok
(
(
)
)
}
pub
fn
dump_json
(
library_path
:
&
Utf8Path
)
-
>
Result
<
String
>
{
let
metadata
=
macro_metadata
:
:
extract_from_library
(
library_path
)
?
;
Ok
(
serde_json
:
:
to_string_pretty
(
&
metadata
)
?
)
}
pub
fn
print_json
(
library_path
:
&
Utf8Path
)
-
>
Result
<
(
)
>
{
println
!
(
"
{
}
"
dump_json
(
library_path
)
?
)
;
Ok
(
(
)
)
}
pub
fn
guess_crate_root
(
udl_file
:
&
Utf8Path
)
-
>
Result
<
&
Utf8Path
>
{
let
path_guess
=
udl_file
.
parent
(
)
.
context
(
"
UDL
file
has
no
parent
folder
!
"
)
?
.
parent
(
)
.
context
(
"
UDL
file
has
no
grand
-
parent
folder
!
"
)
?
;
if
!
path_guess
.
join
(
"
Cargo
.
toml
"
)
.
is_file
(
)
{
bail
!
(
"
UDL
file
does
not
appear
to
be
inside
a
crate
"
)
}
Ok
(
path_guess
)
}
fn
get_out_dir
(
udl_file
:
&
Utf8Path
out_dir_override
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
Utf8PathBuf
>
{
Ok
(
match
out_dir_override
{
Some
(
s
)
=
>
{
fs
:
:
create_dir_all
(
s
)
?
;
s
.
canonicalize_utf8
(
)
.
context
(
"
Unable
to
find
out
-
dir
"
)
?
}
None
=
>
udl_file
.
parent
(
)
.
context
(
"
File
has
no
parent
directory
"
)
?
.
to_owned
(
)
}
)
}
fn
parse_udl
(
udl_file
:
&
Utf8Path
)
-
>
Result
<
ComponentInterface
>
{
let
udl
=
fs
:
:
read_to_string
(
udl_file
)
.
with_context
(
|
|
format
!
(
"
Failed
to
read
UDL
from
{
udl_file
}
"
)
)
?
;
ComponentInterface
:
:
from_webidl
(
&
udl
)
.
context
(
"
Failed
to
parse
UDL
"
)
}
fn
format_code_with_rustfmt
(
path
:
&
Utf8Path
)
-
>
Result
<
(
)
>
{
let
status
=
Command
:
:
new
(
"
rustfmt
"
)
.
arg
(
path
)
.
status
(
)
.
map_err
(
|
e
|
{
let
ctx
=
match
e
.
kind
(
)
{
ErrorKind
:
:
NotFound
=
>
"
formatting
was
requested
but
rustfmt
was
not
found
"
_
=
>
"
unknown
error
when
calling
rustfmt
"
}
;
anyhow
!
(
e
)
.
context
(
ctx
)
}
)
?
;
if
!
status
.
success
(
)
{
bail
!
(
"
rustmt
failed
when
formatting
scaffolding
.
Note
:
-
-
no
-
format
can
be
used
to
skip
formatting
"
)
;
}
Ok
(
(
)
)
}
#
[
derive
(
Debug
Clone
Default
Serialize
Deserialize
)
]
pub
struct
Config
{
#
[
serde
(
default
)
]
bindings
:
bindings
:
:
Config
}
impl
Config
{
fn
load_initial
(
crate_root
:
&
Utf8Path
config_file_override
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
Self
>
{
let
path
=
match
config_file_override
{
Some
(
cfg
)
=
>
Some
(
cfg
.
to_owned
(
)
)
None
=
>
crate_root
.
join
(
"
uniffi
.
toml
"
)
.
canonicalize_utf8
(
)
.
ok
(
)
}
;
let
toml_config
=
match
path
{
Some
(
path
)
=
>
{
let
contents
=
fs
:
:
read_to_string
(
path
)
.
context
(
"
Failed
to
read
config
file
"
)
?
;
toml
:
:
de
:
:
from_str
(
&
contents
)
?
}
None
=
>
toml
:
:
Value
:
:
from
(
toml
:
:
value
:
:
Table
:
:
default
(
)
)
}
;
Ok
(
toml_config
.
try_into
(
)
?
)
}
fn
update_from_ci
(
&
mut
self
ci
:
&
ComponentInterface
)
{
self
.
bindings
.
kotlin
.
update_from_ci
(
ci
)
;
self
.
bindings
.
swift
.
update_from_ci
(
ci
)
;
self
.
bindings
.
python
.
update_from_ci
(
ci
)
;
self
.
bindings
.
ruby
.
update_from_ci
(
ci
)
;
}
fn
update_from_cdylib_name
(
&
mut
self
cdylib_name
:
&
str
)
{
self
.
bindings
.
kotlin
.
update_from_cdylib_name
(
cdylib_name
)
;
self
.
bindings
.
swift
.
update_from_cdylib_name
(
cdylib_name
)
;
self
.
bindings
.
python
.
update_from_cdylib_name
(
cdylib_name
)
;
self
.
bindings
.
ruby
.
update_from_cdylib_name
(
cdylib_name
)
;
}
fn
update_from_dependency_configs
(
&
mut
self
config_map
:
HashMap
<
&
str
&
Self
>
)
{
self
.
bindings
.
kotlin
.
update_from_dependency_configs
(
config_map
.
iter
(
)
.
map
(
|
(
key
config
)
|
(
*
key
&
config
.
bindings
.
kotlin
)
)
.
collect
(
)
)
;
self
.
bindings
.
swift
.
update_from_dependency_configs
(
config_map
.
iter
(
)
.
map
(
|
(
key
config
)
|
(
*
key
&
config
.
bindings
.
swift
)
)
.
collect
(
)
)
;
self
.
bindings
.
python
.
update_from_dependency_configs
(
config_map
.
iter
(
)
.
map
(
|
(
key
config
)
|
(
*
key
&
config
.
bindings
.
python
)
)
.
collect
(
)
)
;
self
.
bindings
.
ruby
.
update_from_dependency_configs
(
config_map
.
iter
(
)
.
map
(
|
(
key
config
)
|
(
*
key
&
config
.
bindings
.
ruby
)
)
.
collect
(
)
)
;
}
}
#
[
allow
(
dead_code
)
]
mod
__unused
{
const
_
:
&
[
u8
]
=
include_bytes
!
(
"
.
.
/
askama
.
toml
"
)
;
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_guessing_of_crate_root_directory_from_udl_file
(
)
{
let
this_crate_root
=
Utf8PathBuf
:
:
from
(
std
:
:
env
:
:
var
(
"
CARGO_MANIFEST_DIR
"
)
.
unwrap
(
)
)
;
let
example_crate_root
=
this_crate_root
.
parent
(
)
.
expect
(
"
should
have
a
parent
directory
"
)
.
join
(
"
examples
/
arithmetic
"
)
;
assert_eq
!
(
guess_crate_root
(
&
example_crate_root
.
join
(
"
src
/
arthmetic
.
udl
"
)
)
.
unwrap
(
)
example_crate_root
)
;
let
not_a_crate_root
=
&
this_crate_root
.
join
(
"
src
/
templates
"
)
;
assert
!
(
guess_crate_root
(
&
not_a_crate_root
.
join
(
"
src
/
example
.
udl
"
)
)
.
is_err
(
)
)
;
}
}
