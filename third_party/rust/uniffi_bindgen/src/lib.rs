#
!
[
warn
(
rust_2018_idioms
unused_qualifications
)
]
#
!
[
allow
(
unknown_lints
)
]
use
anyhow
:
:
{
anyhow
bail
Context
Result
}
;
use
camino
:
:
{
Utf8Path
Utf8PathBuf
}
;
use
fs_err
:
:
{
self
as
fs
File
}
;
use
serde
:
:
Deserialize
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
:
:
ErrorKind
;
use
std
:
:
process
:
:
Command
;
pub
mod
backend
;
pub
mod
bindings
;
pub
mod
interface
;
pub
mod
library_mode
;
pub
mod
macro_metadata
;
pub
mod
scaffolding
;
#
[
cfg
(
feature
=
"
cargo
-
metadata
"
)
]
pub
mod
cargo_metadata
;
use
crate
:
:
interface
:
:
{
Argument
Constructor
Enum
FfiArgument
FfiField
Field
Function
Method
Object
Record
Variant
}
;
pub
use
interface
:
:
ComponentInterface
;
pub
use
library_mode
:
:
find_components
;
use
scaffolding
:
:
RustScaffolding
;
use
uniffi_meta
:
:
Type
;
#
[
derive
(
Debug
Default
)
]
pub
struct
GenerationSettings
{
pub
out_dir
:
Utf8PathBuf
pub
try_format_code
:
bool
pub
cdylib
:
Option
<
String
>
}
pub
trait
BindingGenerator
:
Sized
{
type
Config
;
fn
new_config
(
&
self
root_toml
:
&
toml
:
:
Value
)
-
>
Result
<
Self
:
:
Config
>
;
fn
update_component_configs
(
&
self
settings
:
&
GenerationSettings
components
:
&
mut
Vec
<
Component
<
Self
:
:
Config
>
>
)
-
>
Result
<
(
)
>
;
fn
write_bindings
(
&
self
settings
:
&
GenerationSettings
components
:
&
[
Component
<
Self
:
:
Config
>
]
)
-
>
Result
<
(
)
>
;
}
pub
trait
VisitMut
{
fn
visit_record
(
&
self
record
:
&
mut
Record
)
;
fn
visit_object
(
&
self
object
:
&
mut
Object
)
;
fn
visit_field
(
&
self
field
:
&
mut
Field
)
;
fn
visit_ffi_field
(
&
self
ffi_field
:
&
mut
FfiField
)
;
fn
visit_ffi_argument
(
&
self
ffi_argument
:
&
mut
FfiArgument
)
;
fn
visit_enum
(
&
self
is_error
:
bool
enum_
:
&
mut
Enum
)
;
fn
visit_enum_key
(
&
self
key
:
&
mut
String
)
-
>
String
;
fn
visit_variant
(
&
self
is_error
:
bool
variant
:
&
mut
Variant
)
;
fn
visit_type
(
&
self
type_
:
&
mut
Type
)
;
fn
visit_method
(
&
self
method
:
&
mut
Method
)
;
fn
visit_argument
(
&
self
argument
:
&
mut
Argument
)
;
fn
visit_constructor
(
&
self
constructor
:
&
mut
Constructor
)
;
fn
visit_function
(
&
self
function
:
&
mut
Function
)
;
}
#
[
derive
(
Debug
)
]
pub
struct
Component
<
Config
>
{
pub
ci
:
ComponentInterface
pub
config
:
Config
}
pub
trait
BindgenCrateConfigSupplier
{
fn
get_toml
(
&
self
_crate_name
:
&
str
)
-
>
Result
<
Option
<
toml
:
:
value
:
:
Table
>
>
{
Ok
(
None
)
}
fn
get_udl
(
&
self
crate_name
:
&
str
udl_name
:
&
str
)
-
>
Result
<
String
>
{
bail
!
(
"
Crate
{
crate_name
}
has
no
UDL
{
udl_name
}
"
)
}
}
pub
struct
EmptyCrateConfigSupplier
;
impl
BindgenCrateConfigSupplier
for
EmptyCrateConfigSupplier
{
}
pub
fn
is_cdylib
(
library_file
:
impl
AsRef
<
Utf8Path
>
)
-
>
bool
{
crate
:
:
library_mode
:
:
calc_cdylib_name
(
library_file
.
as_ref
(
)
)
.
is_some
(
)
}
pub
fn
generate_external_bindings
<
T
:
BindingGenerator
>
(
binding_generator
:
&
T
udl_file
:
impl
AsRef
<
Utf8Path
>
config_file_override
:
Option
<
impl
AsRef
<
Utf8Path
>
>
out_dir_override
:
Option
<
impl
AsRef
<
Utf8Path
>
>
library_file
:
Option
<
impl
AsRef
<
Utf8Path
>
>
crate_name
:
Option
<
&
str
>
try_format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
crate_name
=
crate_name
.
map
(
|
c
|
Ok
(
c
.
to_string
(
)
)
)
.
unwrap_or_else
(
|
|
crate_name_from_cargo_toml
(
udl_file
.
as_ref
(
)
)
)
?
;
let
mut
ci
=
parse_udl
(
udl_file
.
as_ref
(
)
&
crate_name
)
?
;
if
let
Some
(
ref
library_file
)
=
library_file
{
macro_metadata
:
:
add_to_ci_from_library
(
&
mut
ci
library_file
.
as_ref
(
)
)
?
;
}
let
crate_root
=
&
guess_crate_root
(
udl_file
.
as_ref
(
)
)
.
context
(
"
Failed
to
guess
crate
root
"
)
?
;
let
config_file_override
=
config_file_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
config
=
{
let
crate_config
=
load_toml_file
(
Some
(
&
crate_root
.
join
(
"
uniffi
.
toml
"
)
)
)
.
context
(
"
failed
to
load
{
crate_root
}
/
uniffi
.
toml
"
)
?
;
let
toml_value
=
overridden_config_value
(
crate_config
.
unwrap_or_default
(
)
config_file_override
)
?
;
binding_generator
.
new_config
(
&
toml_value
)
?
}
;
let
settings
=
GenerationSettings
{
cdylib
:
match
library_file
{
Some
(
ref
library_file
)
=
>
{
crate
:
:
library_mode
:
:
calc_cdylib_name
(
library_file
.
as_ref
(
)
)
.
map
(
ToOwned
:
:
to_owned
)
}
None
=
>
None
}
out_dir
:
get_out_dir
(
udl_file
.
as_ref
(
)
out_dir_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
)
?
try_format_code
}
;
let
mut
components
=
vec
!
[
Component
{
ci
config
}
]
;
binding_generator
.
update_component_configs
(
&
settings
&
mut
components
)
?
;
binding_generator
.
write_bindings
(
&
settings
&
components
)
}
pub
fn
generate_component_scaffolding
(
udl_file
:
&
Utf8Path
out_dir_override
:
Option
<
&
Utf8Path
>
format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
component
=
parse_udl
(
udl_file
&
crate_name_from_cargo_toml
(
udl_file
)
?
)
?
;
generate_component_scaffolding_inner
(
component
udl_file
out_dir_override
format_code
)
}
pub
fn
generate_component_scaffolding_for_crate
(
udl_file
:
&
Utf8Path
crate_name
:
&
str
out_dir_override
:
Option
<
&
Utf8Path
>
format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
component
=
parse_udl
(
udl_file
crate_name
)
?
;
generate_component_scaffolding_inner
(
component
udl_file
out_dir_override
format_code
)
}
fn
generate_component_scaffolding_inner
(
component
:
ComponentInterface
udl_file
:
&
Utf8Path
out_dir_override
:
Option
<
&
Utf8Path
>
format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
file_stem
=
udl_file
.
file_stem
(
)
.
context
(
"
not
a
file
"
)
?
;
let
filename
=
format
!
(
"
{
file_stem
}
.
uniffi
.
rs
"
)
;
let
out_path
=
get_out_dir
(
udl_file
out_dir_override
)
?
.
join
(
filename
)
;
let
mut
f
=
File
:
:
create
(
&
out_path
)
?
;
write
!
(
f
"
{
}
"
RustScaffolding
:
:
new
(
&
component
file_stem
)
)
.
context
(
"
Failed
to
write
output
file
"
)
?
;
if
format_code
{
format_code_with_rustfmt
(
&
out_path
)
?
;
}
Ok
(
(
)
)
}
pub
fn
generate_bindings
<
T
:
BindingGenerator
>
(
udl_file
:
&
Utf8Path
config_file_override
:
Option
<
&
Utf8Path
>
binding_generator
:
T
out_dir_override
:
Option
<
&
Utf8Path
>
library_file
:
Option
<
&
Utf8Path
>
crate_name
:
Option
<
&
str
>
try_format_code
:
bool
)
-
>
Result
<
(
)
>
{
generate_external_bindings
(
&
binding_generator
udl_file
config_file_override
out_dir_override
library_file
crate_name
try_format_code
)
}
pub
fn
print_repr
(
library_path
:
&
Utf8Path
)
-
>
Result
<
(
)
>
{
let
metadata
=
macro_metadata
:
:
extract_from_library
(
library_path
)
?
;
println
!
(
"
{
metadata
:
#
?
}
"
)
;
Ok
(
(
)
)
}
fn
crate_name_from_cargo_toml
(
udl_file
:
&
Utf8Path
)
-
>
Result
<
String
>
{
#
[
derive
(
Deserialize
)
]
struct
CargoToml
{
package
:
Package
#
[
serde
(
default
)
]
lib
:
Lib
}
#
[
derive
(
Deserialize
)
]
struct
Package
{
name
:
String
}
#
[
derive
(
Default
Deserialize
)
]
struct
Lib
{
name
:
Option
<
String
>
}
let
file
=
guess_crate_root
(
udl_file
)
?
.
join
(
"
Cargo
.
toml
"
)
;
let
cargo_toml_bytes
=
fs
:
:
read
(
file
)
.
context
(
"
Can
'
t
find
Cargo
.
toml
to
determine
the
crate
name
"
)
?
;
let
cargo_toml
=
toml
:
:
from_slice
:
:
<
CargoToml
>
(
&
cargo_toml_bytes
)
?
;
let
lib_crate_name
=
cargo_toml
.
lib
.
name
.
unwrap_or_else
(
|
|
cargo_toml
.
package
.
name
.
replace
(
'
-
'
"
_
"
)
)
;
Ok
(
lib_crate_name
)
}
pub
fn
guess_crate_root
(
udl_file
:
&
Utf8Path
)
-
>
Result
<
&
Utf8Path
>
{
let
path_guess
=
udl_file
.
parent
(
)
.
context
(
"
UDL
file
has
no
parent
folder
!
"
)
?
.
parent
(
)
.
context
(
"
UDL
file
has
no
grand
-
parent
folder
!
"
)
?
;
if
!
path_guess
.
join
(
"
Cargo
.
toml
"
)
.
is_file
(
)
{
bail
!
(
"
UDL
file
does
not
appear
to
be
inside
a
crate
"
)
}
Ok
(
path_guess
)
}
fn
get_out_dir
(
udl_file
:
&
Utf8Path
out_dir_override
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
Utf8PathBuf
>
{
Ok
(
match
out_dir_override
{
Some
(
s
)
=
>
{
fs
:
:
create_dir_all
(
s
)
?
;
s
.
canonicalize_utf8
(
)
.
context
(
"
Unable
to
find
out
-
dir
"
)
?
}
None
=
>
udl_file
.
parent
(
)
.
context
(
"
File
has
no
parent
directory
"
)
?
.
to_owned
(
)
}
)
}
fn
parse_udl
(
udl_file
:
&
Utf8Path
crate_name
:
&
str
)
-
>
Result
<
ComponentInterface
>
{
let
udl
=
fs
:
:
read_to_string
(
udl_file
)
.
with_context
(
|
|
format
!
(
"
Failed
to
read
UDL
from
{
udl_file
}
"
)
)
?
;
let
group
=
uniffi_udl
:
:
parse_udl
(
&
udl
crate_name
)
?
;
ComponentInterface
:
:
from_metadata
(
group
)
}
fn
format_code_with_rustfmt
(
path
:
&
Utf8Path
)
-
>
Result
<
(
)
>
{
let
status
=
Command
:
:
new
(
"
rustfmt
"
)
.
arg
(
path
)
.
status
(
)
.
map_err
(
|
e
|
{
let
ctx
=
match
e
.
kind
(
)
{
ErrorKind
:
:
NotFound
=
>
"
formatting
was
requested
but
rustfmt
was
not
found
"
_
=
>
"
unknown
error
when
calling
rustfmt
"
}
;
anyhow
!
(
e
)
.
context
(
ctx
)
}
)
?
;
if
!
status
.
success
(
)
{
bail
!
(
"
rustmt
failed
when
formatting
scaffolding
.
Note
:
-
-
no
-
format
can
be
used
to
skip
formatting
"
)
;
}
Ok
(
(
)
)
}
fn
load_toml_file
(
source
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
Option
<
toml
:
:
value
:
:
Table
>
>
{
if
let
Some
(
source
)
=
source
{
if
source
.
exists
(
)
{
let
contents
=
fs
:
:
read_to_string
(
source
)
.
with_context
(
|
|
format
!
(
"
read
file
:
{
:
?
}
"
source
)
)
?
;
return
Ok
(
Some
(
toml
:
:
de
:
:
from_str
(
&
contents
)
.
with_context
(
|
|
format
!
(
"
parse
toml
:
{
:
?
}
"
source
)
)
?
)
)
;
}
}
Ok
(
None
)
}
fn
overridden_config_value
(
mut
config
:
toml
:
:
value
:
:
Table
config_file_override
:
Option
<
&
Utf8Path
>
)
-
>
Result
<
toml
:
:
Value
>
{
let
override_config
=
load_toml_file
(
config_file_override
)
.
context
(
"
override
config
"
)
?
;
if
let
Some
(
override_config
)
=
override_config
{
merge_toml
(
&
mut
config
override_config
)
;
}
Ok
(
toml
:
:
Value
:
:
from
(
config
)
)
}
fn
merge_toml
(
a
:
&
mut
toml
:
:
value
:
:
Table
b
:
toml
:
:
value
:
:
Table
)
{
for
(
key
value
)
in
b
.
into_iter
(
)
{
match
a
.
get_mut
(
&
key
)
{
Some
(
existing_value
)
=
>
match
(
existing_value
value
)
{
(
toml
:
:
Value
:
:
Table
(
ref
mut
t0
)
toml
:
:
Value
:
:
Table
(
t1
)
)
=
>
{
merge_toml
(
t0
t1
)
;
}
(
v
value
)
=
>
*
v
=
value
}
None
=
>
{
a
.
insert
(
key
value
)
;
}
}
}
}
#
[
allow
(
dead_code
)
]
mod
__unused
{
const
_
:
&
[
u8
]
=
include_bytes
!
(
"
.
.
/
askama
.
toml
"
)
;
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_guessing_of_crate_root_directory_from_udl_file
(
)
{
let
this_crate_root
=
Utf8PathBuf
:
:
from
(
std
:
:
env
:
:
var
(
"
CARGO_MANIFEST_DIR
"
)
.
unwrap
(
)
)
;
let
example_crate_root
=
this_crate_root
.
parent
(
)
.
expect
(
"
should
have
a
parent
directory
"
)
.
join
(
"
examples
/
arithmetic
"
)
;
assert_eq
!
(
guess_crate_root
(
&
example_crate_root
.
join
(
"
src
/
arthmetic
.
udl
"
)
)
.
unwrap
(
)
example_crate_root
)
;
let
not_a_crate_root
=
&
this_crate_root
.
join
(
"
src
/
templates
"
)
;
assert
!
(
guess_crate_root
(
&
not_a_crate_root
.
join
(
"
src
/
example
.
udl
"
)
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_merge_toml
(
)
{
let
default
=
r
#
"
foo
=
"
foo
"
bar
=
"
bar
"
[
table1
]
foo
=
"
foo
"
bar
=
"
bar
"
"
#
;
let
mut
default
=
toml
:
:
de
:
:
from_str
(
default
)
.
unwrap
(
)
;
let
override_toml
=
r
#
"
#
update
key
bar
=
"
BAR
"
#
insert
new
key
baz
=
"
BAZ
"
[
table1
]
#
update
key
bar
=
"
BAR
"
#
insert
new
key
baz
=
"
BAZ
"
#
new
table
[
table1
.
table2
]
bar
=
"
BAR
"
baz
=
"
BAZ
"
"
#
;
let
override_toml
=
toml
:
:
de
:
:
from_str
(
override_toml
)
.
unwrap
(
)
;
let
expected
=
r
#
"
foo
=
"
foo
"
bar
=
"
BAR
"
baz
=
"
BAZ
"
[
table1
]
foo
=
"
foo
"
bar
=
"
BAR
"
baz
=
"
BAZ
"
[
table1
.
table2
]
bar
=
"
BAR
"
baz
=
"
BAZ
"
"
#
;
let
expected
:
toml
:
:
value
:
:
Table
=
toml
:
:
de
:
:
from_str
(
expected
)
.
unwrap
(
)
;
merge_toml
(
&
mut
default
override_toml
)
;
assert_eq
!
(
&
expected
&
default
)
;
}
}
