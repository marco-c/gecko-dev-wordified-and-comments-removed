#
!
[
warn
(
rust_2018_idioms
)
]
#
!
[
allow
(
unknown_lints
)
]
const
BINDGEN_VERSION
:
&
str
=
env
!
(
"
CARGO_PKG_VERSION
"
)
;
use
anyhow
:
:
{
anyhow
bail
Context
Result
}
;
use
clap
:
:
{
Parser
Subcommand
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
{
collections
:
:
HashMap
env
ffi
:
:
OsString
fs
:
:
File
path
:
:
{
Path
PathBuf
}
process
:
:
Command
str
:
:
FromStr
}
;
pub
mod
backend
;
pub
mod
bindings
;
pub
mod
interface
;
pub
mod
scaffolding
;
use
bindings
:
:
TargetLanguage
;
pub
use
interface
:
:
ComponentInterface
;
use
scaffolding
:
:
RustScaffolding
;
pub
trait
BindingGeneratorConfig
:
for
<
'
de
>
Deserialize
<
'
de
>
{
fn
get_entry_from_bindings_table
(
bindings
:
&
toml
:
:
Value
)
-
>
Option
<
toml
:
:
Value
>
;
fn
get_config_defaults
(
ci
:
&
ComponentInterface
)
-
>
Vec
<
(
String
toml
:
:
Value
)
>
;
}
fn
load_bindings_config
<
BC
:
BindingGeneratorConfig
>
(
ci
:
&
ComponentInterface
udl_file
:
&
Path
config_file_override
:
Option
<
&
Path
>
)
-
>
Result
<
BC
>
{
let
mut
config_map
:
toml
:
:
value
:
:
Table
=
match
load_bindings_config_toml
:
:
<
BC
>
(
udl_file
config_file_override
)
?
{
Some
(
value
)
=
>
value
.
try_into
(
)
.
context
(
"
Bindings
config
must
be
a
TOML
table
"
)
?
None
=
>
toml
:
:
map
:
:
Map
:
:
new
(
)
}
;
for
(
key
value
)
in
BC
:
:
get_config_defaults
(
ci
)
.
into_iter
(
)
{
config_map
.
entry
(
key
)
.
or_insert
(
value
)
;
}
toml
:
:
Value
:
:
from
(
config_map
)
.
try_into
(
)
.
context
(
"
Generating
bindings
config
from
toml
:
:
Value
"
)
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
PartialOrd
Ord
Eq
)
]
pub
struct
EmptyBindingGeneratorConfig
;
impl
BindingGeneratorConfig
for
EmptyBindingGeneratorConfig
{
fn
get_entry_from_bindings_table
(
_bindings
:
&
toml
:
:
Value
)
-
>
Option
<
toml
:
:
Value
>
{
None
}
fn
get_config_defaults
(
_ci
:
&
ComponentInterface
)
-
>
Vec
<
(
String
toml
:
:
Value
)
>
{
Vec
:
:
new
(
)
}
}
impl
<
'
de
>
Deserialize
<
'
de
>
for
EmptyBindingGeneratorConfig
{
fn
deserialize
<
D
>
(
_deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
Ok
(
EmptyBindingGeneratorConfig
)
}
}
fn
load_bindings_config_toml
<
BC
:
BindingGeneratorConfig
>
(
udl_file
:
&
Path
config_file_override
:
Option
<
&
Path
>
)
-
>
Result
<
Option
<
toml
:
:
Value
>
>
{
let
config_path
=
match
config_file_override
{
Some
(
cfg
)
=
>
cfg
.
to_owned
(
)
None
=
>
guess_crate_root
(
udl_file
)
?
.
join
(
"
uniffi
.
toml
"
)
}
;
if
!
config_path
.
exists
(
)
{
return
Ok
(
None
)
;
}
let
contents
=
slurp_file
(
&
config_path
)
.
with_context
(
|
|
format
!
(
"
Failed
to
read
config
file
from
{
:
?
}
"
config_path
)
)
?
;
let
full_config
=
toml
:
:
Value
:
:
from_str
(
&
contents
)
.
with_context
(
|
|
format
!
(
"
Failed
to
parse
config
file
{
:
?
}
"
config_path
)
)
?
;
Ok
(
full_config
.
get
(
"
bindings
"
)
.
and_then
(
BC
:
:
get_entry_from_bindings_table
)
)
}
pub
trait
BindingGenerator
:
Sized
{
type
Config
:
BindingGeneratorConfig
;
fn
write_bindings
(
&
self
ci
:
ComponentInterface
config
:
Self
:
:
Config
out_dir
:
&
Path
)
-
>
anyhow
:
:
Result
<
(
)
>
;
}
pub
fn
generate_external_bindings
(
binding_generator
:
impl
BindingGenerator
udl_file
:
impl
AsRef
<
Path
>
config_file_override
:
Option
<
impl
AsRef
<
Path
>
>
out_dir_override
:
Option
<
impl
AsRef
<
Path
>
>
)
-
>
Result
<
(
)
>
{
let
out_dir_override
=
out_dir_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
config_file_override
=
config_file_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
out_dir
=
get_out_dir
(
udl_file
.
as_ref
(
)
out_dir_override
)
?
;
let
component
=
parse_udl
(
udl_file
.
as_ref
(
)
)
.
context
(
"
Error
parsing
UDL
"
)
?
;
let
bindings_config
=
load_bindings_config
(
&
component
udl_file
.
as_ref
(
)
config_file_override
)
?
;
binding_generator
.
write_bindings
(
component
bindings_config
out_dir
.
as_path
(
)
)
}
pub
fn
generate_component_scaffolding
<
P
:
AsRef
<
Path
>
>
(
udl_file
:
P
config_file_override
:
Option
<
P
>
out_dir_override
:
Option
<
P
>
format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
config_file_override
=
config_file_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
out_dir_override
=
out_dir_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
udl_file
=
udl_file
.
as_ref
(
)
;
let
component
=
parse_udl
(
udl_file
)
?
;
let
_config
=
get_config
(
&
component
guess_crate_root
(
udl_file
)
?
config_file_override
)
;
let
mut
filename
=
Path
:
:
new
(
&
udl_file
)
.
file_stem
(
)
.
ok_or_else
(
|
|
anyhow
!
(
"
not
a
file
"
)
)
?
.
to_os_string
(
)
;
filename
.
push
(
"
.
uniffi
.
rs
"
)
;
let
mut
out_dir
=
get_out_dir
(
udl_file
out_dir_override
)
?
;
out_dir
.
push
(
filename
)
;
let
mut
f
=
File
:
:
create
(
&
out_dir
)
.
map_err
(
|
e
|
anyhow
!
(
"
Failed
to
create
output
file
:
{
:
?
}
"
e
)
)
?
;
write
!
(
f
"
{
}
"
RustScaffolding
:
:
new
(
&
component
)
)
.
map_err
(
|
e
|
anyhow
!
(
"
Failed
to
write
output
file
:
{
:
?
}
"
e
)
)
?
;
if
format_code
{
Command
:
:
new
(
"
rustfmt
"
)
.
arg
(
&
out_dir
)
.
status
(
)
?
;
}
Ok
(
(
)
)
}
pub
fn
generate_bindings
<
P
:
AsRef
<
Path
>
>
(
udl_file
:
P
config_file_override
:
Option
<
P
>
target_languages
:
Vec
<
&
str
>
out_dir_override
:
Option
<
P
>
try_format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
out_dir_override
=
out_dir_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
config_file_override
=
config_file_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
udl_file
=
udl_file
.
as_ref
(
)
;
let
component
=
parse_udl
(
udl_file
)
?
;
let
config
=
get_config
(
&
component
guess_crate_root
(
udl_file
)
?
config_file_override
)
?
;
let
out_dir
=
get_out_dir
(
udl_file
out_dir_override
)
?
;
for
language
in
target_languages
{
bindings
:
:
write_bindings
(
&
config
.
bindings
&
component
&
out_dir
language
.
try_into
(
)
?
try_format_code
)
?
;
}
Ok
(
(
)
)
}
pub
fn
run_tests
<
P
:
AsRef
<
Path
>
>
(
cdylib_dir
:
P
udl_files
:
&
[
&
str
]
test_scripts
:
Vec
<
&
str
>
config_file_override
:
Option
<
P
>
)
-
>
Result
<
(
)
>
{
assert
!
(
udl_files
.
len
(
)
=
=
1
|
|
config_file_override
.
is_none
(
)
)
;
let
cdylib_dir
=
cdylib_dir
.
as_ref
(
)
;
let
config_file_override
=
config_file_override
.
as_ref
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
)
;
let
mut
language_tests
:
HashMap
<
TargetLanguage
Vec
<
String
>
>
=
HashMap
:
:
new
(
)
;
for
test_script
in
test_scripts
{
let
lang
:
TargetLanguage
=
PathBuf
:
:
from
(
test_script
)
.
extension
(
)
.
ok_or_else
(
|
|
anyhow
!
(
"
File
has
no
extension
!
"
)
)
?
.
try_into
(
)
?
;
language_tests
.
entry
(
lang
)
.
or_default
(
)
.
push
(
test_script
.
to_owned
(
)
)
;
}
for
(
lang
test_scripts
)
in
language_tests
{
for
udl_file
in
udl_files
{
let
crate_root
=
guess_crate_root
(
Path
:
:
new
(
udl_file
)
)
?
;
let
component
=
parse_udl
(
Path
:
:
new
(
udl_file
)
)
?
;
let
config
=
get_config
(
&
component
crate_root
config_file_override
)
?
;
bindings
:
:
write_bindings
(
&
config
.
bindings
&
component
&
cdylib_dir
lang
true
)
?
;
bindings
:
:
compile_bindings
(
&
config
.
bindings
&
component
&
cdylib_dir
lang
)
?
;
}
for
test_script
in
test_scripts
{
bindings
:
:
run_script
(
cdylib_dir
&
test_script
lang
)
?
;
}
}
Ok
(
(
)
)
}
fn
guess_crate_root
(
udl_file
:
&
Path
)
-
>
Result
<
&
Path
>
{
let
path_guess
=
udl_file
.
parent
(
)
.
ok_or_else
(
|
|
anyhow
!
(
"
UDL
file
has
no
parent
folder
!
"
)
)
?
.
parent
(
)
.
ok_or_else
(
|
|
anyhow
!
(
"
UDL
file
has
no
grand
-
parent
folder
!
"
)
)
?
;
if
!
path_guess
.
join
(
"
Cargo
.
toml
"
)
.
is_file
(
)
{
bail
!
(
"
UDL
file
does
not
appear
to
be
inside
a
crate
"
)
}
Ok
(
path_guess
)
}
fn
get_config
(
component
:
&
ComponentInterface
crate_root
:
&
Path
config_file_override
:
Option
<
&
Path
>
)
-
>
Result
<
Config
>
{
let
default_config
:
Config
=
component
.
into
(
)
;
let
config_file
:
Option
<
PathBuf
>
=
match
config_file_override
{
Some
(
cfg
)
=
>
Some
(
PathBuf
:
:
from
(
cfg
)
)
None
=
>
crate_root
.
join
(
"
uniffi
.
toml
"
)
.
canonicalize
(
)
.
ok
(
)
}
;
match
config_file
{
Some
(
path
)
=
>
{
let
contents
=
slurp_file
(
&
path
)
.
with_context
(
|
|
format
!
(
"
Failed
to
read
config
file
from
{
:
?
}
"
&
path
)
)
?
;
let
loaded_config
:
Config
=
toml
:
:
de
:
:
from_str
(
&
contents
)
.
with_context
(
|
|
format
!
(
"
Failed
to
generate
config
from
file
{
:
?
}
"
&
path
)
)
?
;
Ok
(
loaded_config
.
merge_with
(
&
default_config
)
)
}
None
=
>
Ok
(
default_config
)
}
}
fn
get_out_dir
(
udl_file
:
&
Path
out_dir_override
:
Option
<
&
Path
>
)
-
>
Result
<
PathBuf
>
{
Ok
(
match
out_dir_override
{
Some
(
s
)
=
>
{
std
:
:
fs
:
:
create_dir_all
(
&
s
)
?
;
s
.
canonicalize
(
)
.
map_err
(
|
e
|
anyhow
!
(
"
Unable
to
find
out
-
dir
:
{
:
?
}
"
e
)
)
?
}
None
=
>
udl_file
.
parent
(
)
.
ok_or_else
(
|
|
anyhow
!
(
"
File
has
no
parent
directory
"
)
)
?
.
to_owned
(
)
}
)
}
fn
parse_udl
(
udl_file
:
&
Path
)
-
>
Result
<
ComponentInterface
>
{
let
udl
=
slurp_file
(
udl_file
)
.
map_err
(
|
_
|
anyhow
!
(
"
Failed
to
read
UDL
from
{
:
?
}
"
&
udl_file
)
)
?
;
udl
.
parse
:
:
<
interface
:
:
ComponentInterface
>
(
)
.
map_err
(
|
e
|
anyhow
!
(
"
Failed
to
parse
UDL
:
{
}
"
e
)
)
}
fn
slurp_file
(
file_name
:
&
Path
)
-
>
Result
<
String
>
{
let
mut
contents
=
String
:
:
new
(
)
;
let
mut
f
=
File
:
:
open
(
file_name
)
?
;
f
.
read_to_string
(
&
mut
contents
)
?
;
Ok
(
contents
)
}
#
[
derive
(
Debug
Clone
Default
Serialize
Deserialize
)
]
struct
Config
{
#
[
serde
(
default
)
]
bindings
:
bindings
:
:
Config
}
impl
From
<
&
ComponentInterface
>
for
Config
{
fn
from
(
ci
:
&
ComponentInterface
)
-
>
Self
{
Config
{
bindings
:
ci
.
into
(
)
}
}
}
pub
trait
MergeWith
{
fn
merge_with
(
&
self
other
:
&
Self
)
-
>
Self
;
}
impl
MergeWith
for
Config
{
fn
merge_with
(
&
self
other
:
&
Self
)
-
>
Self
{
Config
{
bindings
:
self
.
bindings
.
merge_with
(
&
other
.
bindings
)
}
}
}
impl
<
T
:
Clone
>
MergeWith
for
Option
<
T
>
{
fn
merge_with
(
&
self
other
:
&
Self
)
-
>
Self
{
match
(
self
other
)
{
(
Some
(
_
)
_
)
=
>
self
.
clone
(
)
(
None
Some
(
_
)
)
=
>
other
.
clone
(
)
(
None
None
)
=
>
None
}
}
}
impl
<
V
:
Clone
>
MergeWith
for
HashMap
<
String
V
>
{
fn
merge_with
(
&
self
other
:
&
Self
)
-
>
Self
{
let
mut
merged
=
HashMap
:
:
new
(
)
;
for
(
key
value
)
in
other
.
iter
(
)
.
chain
(
self
)
{
merged
.
insert
(
key
.
clone
(
)
value
.
clone
(
)
)
;
}
merged
}
}
#
[
derive
(
Parser
)
]
#
[
clap
(
name
=
"
uniffi
-
bindgen
"
)
]
#
[
clap
(
version
=
clap
:
:
crate_version
!
(
)
)
]
#
[
clap
(
about
=
"
Scaffolding
and
bindings
generator
for
Rust
"
)
]
#
[
clap
(
propagate_version
=
true
)
]
struct
Cli
{
#
[
clap
(
subcommand
)
]
command
:
Commands
}
#
[
derive
(
Subcommand
)
]
enum
Commands
{
#
[
clap
(
name
=
"
generate
"
about
=
"
Generate
foreign
language
bindings
"
)
]
Generate
{
#
[
clap
(
long
short
possible_values
=
&
[
"
kotlin
"
"
python
"
"
swift
"
"
ruby
"
]
)
]
#
[
clap
(
help
=
"
Foreign
language
(
s
)
for
which
to
build
bindings
.
"
)
]
language
:
Vec
<
String
>
#
[
clap
(
long
short
help
=
"
Directory
in
which
to
write
generated
files
.
Default
is
same
folder
as
.
udl
file
.
"
)
]
out_dir
:
Option
<
OsString
>
#
[
clap
(
long
short
help
=
"
Do
not
try
to
format
the
generated
bindings
.
"
)
]
no_format
:
bool
#
[
clap
(
long
short
help
=
"
Path
to
the
optional
uniffi
config
file
.
If
not
provided
uniffi
-
bindgen
will
try
to
guess
it
from
the
UDL
'
s
file
location
.
"
)
]
config
:
Option
<
OsString
>
#
[
clap
(
help
=
"
Path
to
the
UDL
file
.
"
)
]
udl_file
:
OsString
}
#
[
clap
(
name
=
"
scaffolding
"
about
=
"
Generate
Rust
scaffolding
code
"
)
]
Scaffolding
{
#
[
clap
(
long
short
help
=
"
Directory
in
which
to
write
generated
files
.
Default
is
same
folder
as
.
udl
file
.
"
)
]
out_dir
:
Option
<
OsString
>
#
[
clap
(
long
short
help
=
"
Path
to
the
optional
uniffi
config
file
.
If
not
provided
uniffi
-
bindgen
will
try
to
guess
it
from
the
UDL
'
s
file
location
.
"
)
]
config
:
Option
<
OsString
>
#
[
clap
(
long
short
help
=
"
Do
not
try
to
format
the
generated
bindings
.
"
)
]
no_format
:
bool
#
[
clap
(
help
=
"
Path
to
the
UDL
file
.
"
)
]
udl_file
:
OsString
}
#
[
clap
(
name
=
"
test
"
about
=
"
Run
test
scripts
against
foreign
language
bindings
.
"
)
]
Test
{
#
[
clap
(
help
=
"
Path
to
the
directory
containing
the
cdylib
the
scripts
will
be
testing
against
.
"
)
]
cdylib_dir
:
OsString
#
[
clap
(
help
=
"
Path
to
the
UDL
file
.
"
)
]
udl_file
:
OsString
#
[
clap
(
help
=
"
Foreign
language
(
s
)
test
scripts
to
run
.
"
)
]
test_scripts
:
Vec
<
String
>
#
[
clap
(
long
short
help
=
"
Path
to
the
optional
uniffi
config
file
.
If
not
provided
uniffi
-
bindgen
will
try
to
guess
it
from
the
UDL
'
s
file
location
.
"
)
]
config
:
Option
<
OsString
>
}
}
pub
fn
run_main
(
)
-
>
Result
<
(
)
>
{
let
cli
=
Cli
:
:
parse
(
)
;
match
&
cli
.
command
{
Commands
:
:
Generate
{
language
out_dir
no_format
config
udl_file
}
=
>
crate
:
:
generate_bindings
(
udl_file
config
.
as_ref
(
)
language
.
iter
(
)
.
map
(
String
:
:
as_str
)
.
collect
(
)
out_dir
.
as_ref
(
)
!
no_format
)
Commands
:
:
Scaffolding
{
out_dir
config
no_format
udl_file
}
=
>
crate
:
:
generate_component_scaffolding
(
udl_file
config
.
as_ref
(
)
out_dir
.
as_ref
(
)
!
no_format
)
Commands
:
:
Test
{
cdylib_dir
udl_file
test_scripts
config
}
=
>
crate
:
:
run_tests
(
cdylib_dir
&
[
&
udl_file
.
to_string_lossy
(
)
]
test_scripts
.
iter
(
)
.
map
(
String
:
:
as_str
)
.
collect
(
)
config
.
as_ref
(
)
)
}
?
;
Ok
(
(
)
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_guessing_of_crate_root_directory_from_udl_file
(
)
{
let
this_crate_root
=
PathBuf
:
:
from
(
std
:
:
env
:
:
var
(
"
CARGO_MANIFEST_DIR
"
)
.
unwrap
(
)
)
;
let
example_crate_root
=
this_crate_root
.
parent
(
)
.
expect
(
"
should
have
a
parent
directory
"
)
.
join
(
"
.
/
examples
/
arithmetic
"
)
;
assert_eq
!
(
guess_crate_root
(
&
example_crate_root
.
join
(
"
.
/
src
/
arthmetic
.
udl
"
)
)
.
unwrap
(
)
example_crate_root
)
;
let
not_a_crate_root
=
&
this_crate_root
.
join
(
"
.
/
src
/
templates
"
)
;
assert
!
(
guess_crate_root
(
&
not_a_crate_root
.
join
(
"
.
/
src
/
example
.
udl
"
)
)
.
is_err
(
)
)
;
}
}
