use
anyhow
:
:
{
bail
Context
Result
}
;
use
std
:
:
{
env
ffi
:
:
OsString
fs
:
:
File
io
:
:
Write
path
:
:
{
Path
PathBuf
}
process
:
:
Command
}
;
pub
mod
gen_kotlin
;
pub
use
gen_kotlin
:
:
{
generate_bindings
Config
}
;
use
super
:
:
super
:
:
interface
:
:
ComponentInterface
;
pub
fn
write_bindings
(
config
:
&
Config
ci
:
&
ComponentInterface
out_dir
:
&
Path
try_format_code
:
bool
)
-
>
Result
<
(
)
>
{
let
mut
kt_file
=
full_bindings_path
(
config
out_dir
)
?
;
std
:
:
fs
:
:
create_dir_all
(
&
kt_file
)
?
;
kt_file
.
push
(
format
!
(
"
{
}
.
kt
"
ci
.
namespace
(
)
)
)
;
let
mut
f
=
File
:
:
create
(
&
kt_file
)
.
context
(
"
Failed
to
create
.
kt
file
for
bindings
"
)
?
;
write
!
(
f
"
{
}
"
generate_bindings
(
config
ci
)
?
)
?
;
if
try_format_code
{
if
let
Err
(
e
)
=
Command
:
:
new
(
"
ktlint
"
)
.
arg
(
"
-
F
"
)
.
arg
(
kt_file
.
to_str
(
)
.
unwrap
(
)
)
.
output
(
)
{
println
!
(
"
Warning
:
Unable
to
auto
-
format
{
}
using
ktlint
:
{
:
?
}
"
kt_file
.
file_name
(
)
.
unwrap
(
)
.
to_str
(
)
.
unwrap
(
)
e
)
}
}
Ok
(
(
)
)
}
fn
full_bindings_path
(
config
:
&
Config
out_dir
:
&
Path
)
-
>
Result
<
PathBuf
>
{
let
package_path
:
PathBuf
=
config
.
package_name
(
)
.
split
(
'
.
'
)
.
collect
(
)
;
Ok
(
PathBuf
:
:
from
(
out_dir
)
.
join
(
package_path
)
)
}
pub
fn
compile_bindings
(
config
:
&
Config
ci
:
&
ComponentInterface
out_dir
:
&
Path
)
-
>
Result
<
(
)
>
{
let
mut
kt_file
=
full_bindings_path
(
config
out_dir
)
?
;
kt_file
.
push
(
format
!
(
"
{
}
.
kt
"
ci
.
namespace
(
)
)
)
;
let
mut
jar_file
=
PathBuf
:
:
from
(
out_dir
)
;
jar_file
.
push
(
format
!
(
"
{
}
.
jar
"
ci
.
namespace
(
)
)
)
;
let
status
=
Command
:
:
new
(
"
kotlinc
"
)
.
arg
(
"
-
Werror
"
)
.
arg
(
"
-
classpath
"
)
.
arg
(
classpath_for_testing
(
out_dir
)
?
)
.
arg
(
&
kt_file
)
.
arg
(
"
-
d
"
)
.
arg
(
jar_file
)
.
spawn
(
)
.
context
(
"
Failed
to
spawn
kotlinc
to
compile
the
bindings
"
)
?
.
wait
(
)
.
context
(
"
Failed
to
wait
for
kotlinc
when
compiling
the
bindings
"
)
?
;
if
!
status
.
success
(
)
{
bail
!
(
"
running
kotlinc
failed
"
)
}
Ok
(
(
)
)
}
pub
fn
run_script
(
out_dir
:
&
Path
script_file
:
&
Path
)
-
>
Result
<
(
)
>
{
let
mut
cmd
=
Command
:
:
new
(
"
kotlinc
"
)
;
cmd
.
arg
(
"
-
classpath
"
)
.
arg
(
classpath_for_testing
(
out_dir
)
?
)
;
cmd
.
arg
(
"
-
J
-
ea
"
)
;
cmd
.
arg
(
"
-
Werror
"
)
;
cmd
.
arg
(
"
-
script
"
)
.
arg
(
script_file
)
;
let
status
=
cmd
.
spawn
(
)
.
context
(
"
Failed
to
spawn
kotlinc
to
run
Kotlin
script
"
)
?
.
wait
(
)
.
context
(
"
Failed
to
wait
for
kotlinc
when
running
Kotlin
script
"
)
?
;
if
!
status
.
success
(
)
{
bail
!
(
"
running
kotlinc
failed
"
)
}
Ok
(
(
)
)
}
pub
fn
classpath_for_testing
(
out_dir
:
&
Path
)
-
>
Result
<
OsString
>
{
let
mut
classpath
=
env
:
:
var_os
(
"
CLASSPATH
"
)
.
unwrap_or_else
(
|
|
OsString
:
:
from
(
"
"
)
)
;
classpath
.
push
(
"
:
"
)
;
classpath
.
push
(
out_dir
)
;
for
entry
in
PathBuf
:
:
from
(
out_dir
)
.
read_dir
(
)
.
context
(
"
Failed
to
list
target
directory
when
running
Kotlin
script
"
)
?
{
let
entry
=
entry
.
context
(
"
Directory
listing
failed
while
running
Kotlin
script
"
)
?
;
if
let
Some
(
ext
)
=
entry
.
path
(
)
.
extension
(
)
{
if
ext
=
=
"
jar
"
{
classpath
.
push
(
"
:
"
)
;
classpath
.
push
(
entry
.
path
(
)
)
;
}
}
}
Ok
(
classpath
)
}
