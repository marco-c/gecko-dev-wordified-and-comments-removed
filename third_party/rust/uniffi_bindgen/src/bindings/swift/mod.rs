use
crate
:
:
{
BindingGenerator
Component
GenerationSettings
}
;
use
anyhow
:
:
{
Context
Result
}
;
use
camino
:
:
Utf8PathBuf
;
use
fs_err
as
fs
;
use
std
:
:
process
:
:
Command
;
mod
gen_swift
;
use
gen_swift
:
:
{
generate_bindings
generate_header
generate_modulemap
generate_swift
Config
}
;
#
[
cfg
(
feature
=
"
bindgen
-
tests
"
)
]
pub
mod
test
;
struct
Bindings
{
library
:
String
header
:
String
modulemap
:
Option
<
String
>
}
pub
struct
SwiftBindingGenerator
;
impl
BindingGenerator
for
SwiftBindingGenerator
{
type
Config
=
Config
;
fn
new_config
(
&
self
root_toml
:
&
toml
:
:
Value
)
-
>
Result
<
Self
:
:
Config
>
{
Ok
(
match
root_toml
.
get
(
"
bindings
"
)
.
and_then
(
|
b
|
b
.
get
(
"
swift
"
)
)
{
Some
(
v
)
=
>
v
.
clone
(
)
.
try_into
(
)
?
None
=
>
Default
:
:
default
(
)
}
)
}
fn
update_component_configs
(
&
self
_settings
:
&
GenerationSettings
components
:
&
mut
Vec
<
Component
<
Self
:
:
Config
>
>
)
-
>
Result
<
(
)
>
{
for
c
in
&
mut
*
components
{
c
.
config
.
module_name
.
get_or_insert_with
(
|
|
c
.
ci
.
namespace
(
)
.
into
(
)
)
;
}
Ok
(
(
)
)
}
fn
write_bindings
(
&
self
settings
:
&
GenerationSettings
components
:
&
[
Component
<
Self
:
:
Config
>
]
)
-
>
Result
<
(
)
>
{
for
Component
{
ci
config
.
.
}
in
components
{
let
Bindings
{
header
library
modulemap
}
=
generate_bindings
(
config
ci
)
?
;
let
source_file
=
settings
.
out_dir
.
join
(
format
!
(
"
{
}
.
swift
"
config
.
module_name
(
)
)
)
;
fs
:
:
write
(
&
source_file
library
)
?
;
let
header_file
=
settings
.
out_dir
.
join
(
config
.
header_filename
(
)
)
;
fs
:
:
write
(
header_file
header
)
?
;
if
let
Some
(
modulemap
)
=
modulemap
{
let
modulemap_file
=
settings
.
out_dir
.
join
(
config
.
modulemap_filename
(
)
)
;
fs
:
:
write
(
modulemap_file
modulemap
)
?
;
}
if
settings
.
try_format_code
{
if
let
Err
(
e
)
=
Command
:
:
new
(
"
swiftformat
"
)
.
arg
(
source_file
.
as_str
(
)
)
.
output
(
)
{
println
!
(
"
Warning
:
Unable
to
auto
-
format
{
}
using
swiftformat
:
{
e
:
?
}
"
source_file
.
file_name
(
)
.
unwrap
(
)
)
;
}
}
}
Ok
(
(
)
)
}
}
pub
fn
generate_swift_bindings
(
options
:
SwiftBindingsOptions
)
-
>
Result
<
(
)
>
{
#
[
cfg
(
feature
=
"
cargo
-
metadata
"
)
]
let
config_supplier
=
{
use
crate
:
:
cargo_metadata
:
:
CrateConfigSupplier
;
let
mut
cmd
=
cargo_metadata
:
:
MetadataCommand
:
:
new
(
)
;
if
options
.
metadata_no_deps
{
cmd
.
no_deps
(
)
;
}
let
metadata
=
cmd
.
exec
(
)
.
context
(
"
error
running
cargo
metadata
"
)
?
;
CrateConfigSupplier
:
:
from
(
metadata
)
}
;
#
[
cfg
(
not
(
feature
=
"
cargo
-
metadata
"
)
)
]
let
config_supplier
=
crate
:
:
EmptyCrateConfigSupplier
;
fs
:
:
create_dir_all
(
&
options
.
out_dir
)
?
;
let
mut
components
=
crate
:
:
library_mode
:
:
find_components
(
&
options
.
library_path
&
config_supplier
)
?
.
into_iter
(
)
.
map
(
|
Component
{
ci
config
}
|
{
let
config
=
SwiftBindingGenerator
.
new_config
(
&
config
.
into
(
)
)
?
;
Ok
(
Component
{
ci
config
}
)
}
)
.
collect
:
:
<
Result
<
Vec
<
_
>
>
>
(
)
?
;
SwiftBindingGenerator
.
update_component_configs
(
&
GenerationSettings
:
:
default
(
)
&
mut
components
)
?
;
for
Component
{
ci
config
}
in
&
components
{
if
options
.
generate_swift_sources
{
let
source_file
=
options
.
out_dir
.
join
(
format
!
(
"
{
}
.
swift
"
config
.
module_name
(
)
)
)
;
fs
:
:
write
(
&
source_file
generate_swift
(
config
ci
)
?
)
?
;
}
if
options
.
generate_headers
{
let
header_file
=
options
.
out_dir
.
join
(
config
.
header_filename
(
)
)
;
fs
:
:
write
(
header_file
generate_header
(
config
ci
)
?
)
?
;
}
}
let
library_name
=
{
let
stem
=
options
.
library_path
.
file_stem
(
)
.
with_context
(
|
|
format
!
(
"
Invalid
library
path
{
}
"
options
.
library_path
)
)
?
;
match
stem
.
strip_prefix
(
"
lib
"
)
{
Some
(
name
)
=
>
name
None
=
>
stem
}
}
;
let
module_name
=
options
.
module_name
.
unwrap_or_else
(
|
|
library_name
.
to_string
(
)
)
;
let
modulemap_filename
=
options
.
modulemap_filename
.
unwrap_or_else
(
|
|
format
!
(
"
{
library_name
}
.
modulemap
"
)
)
;
if
options
.
generate_modulemap
{
let
mut
header_filenames
:
Vec
<
_
>
=
components
.
iter
(
)
.
map
(
|
Component
{
config
.
.
}
|
config
.
header_filename
(
)
)
.
collect
(
)
;
header_filenames
.
sort
(
)
;
let
modulemap_source
=
generate_modulemap
(
module_name
header_filenames
options
.
xcframework
)
?
;
let
modulemap_path
=
options
.
out_dir
.
join
(
modulemap_filename
)
;
fs
:
:
write
(
modulemap_path
modulemap_source
)
?
;
}
Ok
(
(
)
)
}
#
[
derive
(
Debug
)
]
pub
struct
SwiftBindingsOptions
{
pub
generate_swift_sources
:
bool
pub
generate_headers
:
bool
pub
generate_modulemap
:
bool
pub
library_path
:
Utf8PathBuf
pub
out_dir
:
Utf8PathBuf
pub
xcframework
:
bool
pub
module_name
:
Option
<
String
>
pub
modulemap_filename
:
Option
<
String
>
pub
metadata_no_deps
:
bool
}
