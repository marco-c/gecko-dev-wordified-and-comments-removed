#
pragma
once
#
include
<
stdbool
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
ifdef
UNIFFI_SHARED_H
#
ifndef
UNIFFI_SHARED_HEADER_V4
#
error
Combining
helper
code
from
multiple
versions
of
uniffi
is
not
supported
#
endif
#
else
#
define
UNIFFI_SHARED_H
#
define
UNIFFI_SHARED_HEADER_V4
typedef
struct
RustBuffer
{
uint64_t
capacity
;
uint64_t
len
;
uint8_t
*
_Nullable
data
;
}
RustBuffer
;
typedef
struct
ForeignBytes
{
int32_t
len
;
const
uint8_t
*
_Nullable
data
;
}
ForeignBytes
;
typedef
struct
RustCallStatus
{
int8_t
code
;
RustBuffer
errorBuf
;
}
RustCallStatus
;
#
endif
{
%
-
for
def
in
ci
.
ffi_definitions
(
)
%
}
#
ifndef
{
{
def
.
name
(
)
|
if_guard_name
}
}
#
define
{
{
def
.
name
(
)
|
if_guard_name
}
}
{
%
-
match
def
%
}
{
%
when
FfiDefinition
:
:
CallbackFunction
(
callback
)
%
}
typedef
{
%
-
match
callback
.
return_type
(
)
%
}
{
%
when
Some
(
return_type
)
%
}
{
{
return_type
|
header_ffi_type_name
}
}
{
%
when
None
%
}
void
{
%
endmatch
-
%
}
(
*
{
{
callback
.
name
(
)
|
ffi_callback_name
}
}
)
(
{
%
-
for
arg
in
callback
.
arguments
(
)
-
%
}
{
{
arg
.
type_
(
)
.
borrow
(
)
|
header_ffi_type_name
}
}
{
%
-
if
!
loop
.
last
|
|
callback
.
has_rust_call_status_arg
(
)
%
}
{
%
endif
%
}
{
%
-
endfor
-
%
}
{
%
-
if
callback
.
has_rust_call_status_arg
(
)
%
}
RustCallStatus
*
_Nonnull
uniffiCallStatus
{
%
-
endif
%
}
)
;
{
%
when
FfiDefinition
:
:
Struct
(
struct
)
%
}
typedef
struct
{
{
struct
.
name
(
)
|
ffi_struct_name
}
}
{
{
%
-
for
field
in
struct
.
fields
(
)
%
}
{
{
field
.
type_
(
)
.
borrow
(
)
|
header_ffi_type_name
}
}
{
{
field
.
name
(
)
|
var_name
}
}
;
{
%
-
endfor
%
}
}
{
{
struct
.
name
(
)
|
ffi_struct_name
}
}
;
{
%
when
FfiDefinition
:
:
Function
(
func
)
%
}
{
%
match
func
.
return_type
(
)
-
%
}
{
%
-
when
Some
(
type_
)
%
}
{
{
type_
|
header_ffi_type_name
}
}
{
%
when
None
%
}
void
{
%
endmatch
%
}
{
{
func
.
name
(
)
}
}
(
{
%
-
if
func
.
arguments
(
)
.
len
(
)
>
0
%
}
{
%
-
for
arg
in
func
.
arguments
(
)
%
}
{
{
-
arg
.
type_
(
)
.
borrow
(
)
|
header_ffi_type_name
}
}
{
{
arg
.
name
(
)
-
}
}
{
%
if
!
loop
.
last
|
|
func
.
has_rust_call_status_arg
(
)
%
}
{
%
endif
%
}
{
%
-
endfor
%
}
{
%
-
if
func
.
has_rust_call_status_arg
(
)
%
}
RustCallStatus
*
_Nonnull
out_status
{
%
endif
%
}
{
%
-
else
%
}
{
%
-
if
func
.
has_rust_call_status_arg
(
)
%
}
RustCallStatus
*
_Nonnull
out_status
{
%
-
else
%
}
void
{
%
endif
%
}
{
%
endif
%
}
)
;
{
%
-
endmatch
%
}
#
endif
{
%
-
endfor
%
}
{
%
import
"
macros
.
swift
"
as
swift
%
}
