#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
core
;
#
[
macro_use
]
extern
crate
rental_impl
;
extern
crate
stable_deref_trait
;
#
[
doc
(
hidden
)
]
pub
use
rental_impl
:
:
*
;
pub
trait
IntoSuffix
{
type
Suffix
;
fn
into_suffix
(
self
)
-
>
<
Self
as
IntoSuffix
>
:
:
Suffix
;
}
pub
struct
RentalError
<
E
H
>
(
pub
E
pub
H
)
;
pub
type
RentalResult
<
T
E
H
>
=
Result
<
T
RentalError
<
E
H
>
>
;
macro_rules
!
define_rental_traits
{
(
max_arity
:
expr
)
=
>
{
#
[
allow
(
unused
)
]
#
[
derive
(
__rental_traits
)
]
enum
ProceduralMasqueradeDummyType
{
Input
=
(
0
stringify
!
(
max_arity
)
)
.
0
}
}
;
}
#
[
doc
(
hidden
)
]
pub
mod
__rental_prelude
{
pub
use
core
:
:
marker
:
:
PhantomData
;
pub
use
core
:
:
clone
:
:
Clone
;
pub
use
core
:
:
ops
:
:
{
FnOnce
Deref
DerefMut
Drop
}
;
pub
use
core
:
:
convert
:
:
{
AsRef
AsMut
Into
}
;
pub
use
core
:
:
borrow
:
:
{
Borrow
BorrowMut
}
;
pub
use
core
:
:
mem
:
:
transmute
;
pub
use
core
:
:
result
:
:
Result
;
pub
use
core
:
:
option
:
:
Option
;
pub
use
core
:
:
fmt
;
pub
use
stable_deref_trait
:
:
{
StableDeref
CloneStableDeref
}
;
pub
use
super
:
:
{
IntoSuffix
RentalError
RentalResult
}
;
define_rental_traits
!
(
32
)
;
#
[
inline
(
always
)
]
pub
fn
static_assert_stable_deref
<
T
:
StableDeref
>
(
)
{
}
#
[
inline
(
always
)
]
pub
fn
static_assert_mut_stable_deref
<
T
:
DerefMut
+
StableDeref
>
(
)
{
}
}
#
[
macro_export
]
macro_rules
!
rental
{
{
(
#
[
attr
:
meta
]
)
*
mod
rental_mod
:
ident
{
(
body
:
tt
)
*
}
}
=
>
{
(
#
[
attr
]
)
*
mod
rental_mod
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
__rental_prelude
;
#
[
allow
(
unused
)
]
#
[
derive
(
__rental_structs_and_impls
)
]
enum
ProceduralMasqueradeDummyType
{
Input
=
(
0
stringify
!
(
(
body
)
*
)
)
.
0
}
}
}
;
{
(
#
[
attr
:
meta
]
)
*
pub
mod
rental_mod
:
ident
{
(
body
:
tt
)
*
}
}
=
>
{
(
#
[
attr
]
)
*
pub
mod
rental_mod
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
__rental_prelude
;
#
[
allow
(
unused
)
]
#
[
derive
(
__rental_structs_and_impls
)
]
enum
ProceduralMasqueradeDummyType
{
Input
=
(
0
stringify
!
(
(
body
)
*
)
)
.
0
}
}
}
;
{
(
#
[
attr
:
meta
]
)
*
pub
(
(
vis
:
tt
)
*
)
mod
rental_mod
:
ident
{
(
body
:
tt
)
*
}
}
=
>
{
(
#
[
attr
]
)
*
pub
(
(
vis
)
*
)
mod
rental_mod
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
__rental_prelude
;
#
[
allow
(
unused
)
]
#
[
derive
(
__rental_structs_and_impls
)
]
enum
ProceduralMasqueradeDummyType
{
Input
=
(
0
stringify
!
(
(
body
)
*
)
)
.
0
}
}
}
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
rental
!
{
/
/
/
Example
types
that
demonstrate
the
API
generated
by
the
rental
macro
.
pub
mod
examples
{
use
std
:
:
sync
;
/
/
/
The
simplest
shared
rental
.
The
head
is
a
boxed
integer
and
the
suffix
is
a
ref
to
that
integer
.
This
struct
demonstrates
the
basic
API
that
all
shared
rental
structs
have
.
See
[
SimpleMut
]
(
struct
.
SimpleMut
.
html
)
for
the
mutable
analog
.
#
[
rental
]
pub
struct
SimpleRef
{
head
:
Box
<
i32
>
iref
:
&
'
head
i32
}
/
/
/
The
simplest
mutable
rental
.
Mutable
rentals
have
a
slightly
different
API
;
compare
this
struct
to
[
SimpleRef
]
(
struct
.
SimpleRef
.
html
)
for
the
clearest
picture
of
how
they
differ
.
#
[
rental_mut
]
pub
struct
SimpleMut
{
head
:
Box
<
i32
>
iref
:
&
'
head
mut
i32
}
/
/
/
Identical
to
[
SimpleRef
]
(
struct
.
SimpleRef
.
html
)
but
with
the
debug
flag
enabled
.
This
will
provide
a
Debug
impl
for
the
struct
as
long
as
all
of
the
fields
are
Debug
.
#
[
rental
(
debug
)
]
pub
struct
SimpleRefDebug
{
head
:
Box
<
i32
>
iref
:
&
'
head
i32
}
/
/
/
Similar
to
[
SimpleRef
]
(
struct
.
SimpleRef
.
html
)
but
with
the
clone
flag
enabled
.
This
will
provide
a
Clone
impl
for
the
struct
as
long
as
the
prefix
fields
are
CloneStableDeref
and
the
suffix
is
Clone
.
Notice
that
the
head
is
an
Arc
since
a
clone
of
an
Arc
will
deref
to
the
same
object
as
the
original
.
#
[
rental
(
clone
)
]
pub
struct
SimpleRefClone
{
head
:
sync
:
:
Arc
<
i32
>
iref
:
&
'
head
i32
}
/
/
/
Identical
to
[
SimpleRef
]
(
struct
.
SimpleRef
.
html
)
but
with
the
deref_suffix
flag
enabled
.
This
will
provide
a
Deref
impl
for
the
struct
which
will
in
turn
deref
the
suffix
.
Notice
that
this
flag
also
removes
the
self
param
from
all
methods
replacing
it
with
an
explicit
param
.
This
prevents
any
rental
methods
from
blocking
deref
.
#
[
rental
(
deref_suffix
)
]
pub
struct
SimpleRefDeref
{
head
:
Box
<
i32
>
iref
:
&
'
head
i32
}
/
/
/
Identical
to
[
SimpleMut
]
(
struct
.
SimpleMut
.
html
)
but
with
the
deref_mut_suffix
flag
enabled
.
This
will
provide
a
DerefMut
impl
for
the
struct
which
will
in
turn
deref
the
suffix
.
Notice
that
this
flag
also
removes
the
self
param
from
all
methods
replacing
it
with
an
explicit
param
.
This
prevents
any
rental
methods
from
blocking
deref
.
#
[
rental_mut
(
deref_mut_suffix
)
]
pub
struct
SimpleMutDeref
{
head
:
Box
<
i32
>
iref
:
&
'
head
mut
i32
}
/
/
/
Identical
to
[
SimpleRef
]
(
struct
.
SimpleRef
.
html
)
but
with
the
covariant
flag
enabled
.
For
rental
structs
where
the
field
types
have
covariant
lifetimes
this
will
allow
you
to
directly
borrow
the
fields
as
they
can
be
safely
reborrowed
to
a
shorter
lifetime
.
See
the
[
all
]
(
struct
.
SimpleRefCovariant
.
html
#
method
.
all
)
and
[
suffix
]
(
struct
.
SimpleRefCovariant
.
html
#
method
.
suffix
)
methods
.
#
[
rental
(
covariant
)
]
pub
struct
SimpleRefCovariant
{
head
:
Box
<
i32
>
iref
:
&
'
head
i32
}
/
/
/
Identical
to
[
SimpleRef
]
(
struct
.
SimpleRef
.
html
)
but
with
the
map_suffix
flag
enabled
.
This
will
allow
the
type
of
the
suffix
to
be
changed
by
mapping
it
to
another
instantiation
of
the
same
struct
with
the
different
type
param
.
See
the
[
map
]
(
struct
.
SimpleRefMap
.
html
#
method
.
map
)
[
try_map
]
(
struct
.
SimpleRefMap
.
html
#
method
.
try_map
)
and
[
try_map_or_drop
]
(
struct
.
SimpleRefMap
.
html
#
method
.
try_map_or_drop
)
methods
.
#
[
rental
(
map_suffix
=
"
T
"
)
]
pub
struct
SimpleRefMap
<
T
:
'
static
>
{
head
:
Box
<
i32
>
iref
:
&
'
head
T
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
rental
!
{
/
/
/
Premade
types
for
the
most
common
use
cases
.
pub
mod
common
{
use
std
:
:
ops
:
:
DerefMut
;
use
stable_deref_trait
:
:
StableDeref
;
use
std
:
:
cell
;
use
std
:
:
sync
;
/
/
/
Stores
an
owner
and
a
shared
reference
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentRef
;
/
/
/
#
fn
main
(
)
{
/
/
/
let
r
=
RentRef
:
:
new
(
Box
:
:
new
(
5
)
|
i
|
&
*
i
)
;
/
/
/
assert_eq
!
(
*
r
RentRef
:
:
rent
(
&
r
|
iref
|
*
*
iref
)
)
;
/
/
/
#
}
/
/
/
#
[
rental
(
debug
clone
deref_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentRef
<
H
:
'
static
+
StableDeref
T
:
'
static
>
{
head
:
H
suffix
:
&
'
head
T
}
/
/
/
Stores
an
owner
and
a
mutable
reference
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentMut
;
/
/
/
#
fn
main
(
)
{
/
/
/
let
mut
r
=
RentMut
:
:
new
(
Box
:
:
new
(
5
)
|
i
|
&
mut
*
i
)
;
/
/
/
*
r
=
12
;
/
/
/
assert_eq
!
(
12
RentMut
:
:
rent
(
&
mut
r
|
iref
|
*
*
iref
)
)
;
/
/
/
#
}
/
/
/
#
[
rental_mut
(
debug
deref_mut_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentMut
<
H
:
'
static
+
StableDeref
+
DerefMut
T
:
'
static
>
{
head
:
H
suffix
:
&
'
head
mut
T
}
/
/
/
Stores
a
RefCell
and
a
Ref
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentRefCell
;
/
/
/
#
fn
main
(
)
{
/
/
/
use
std
:
:
cell
;
/
/
/
/
/
/
let
r
=
RentRefCell
:
:
new
(
Box
:
:
new
(
cell
:
:
RefCell
:
:
new
(
5
)
)
|
c
|
c
.
borrow
(
)
)
;
/
/
/
assert_eq
!
(
*
r
RentRefCell
:
:
rent
(
&
r
|
c
|
*
*
c
)
)
;
/
/
/
#
}
/
/
/
#
[
rental
(
debug
clone
deref_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentRefCell
<
H
:
'
static
+
StableDeref
T
:
'
static
>
{
head
:
H
suffix
:
cell
:
:
Ref
<
'
head
T
>
}
/
/
/
Stores
a
RefCell
and
a
RefMut
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentRefCellMut
;
/
/
/
#
fn
main
(
)
{
/
/
/
use
std
:
:
cell
;
/
/
/
/
/
/
let
mut
r
=
RentRefCellMut
:
:
new
(
Box
:
:
new
(
cell
:
:
RefCell
:
:
new
(
5
)
)
|
c
|
c
.
borrow_mut
(
)
)
;
/
/
/
*
r
=
12
;
/
/
/
assert_eq
!
(
12
RentRefCellMut
:
:
rent
(
&
r
|
c
|
*
*
c
)
)
;
/
/
/
#
}
/
/
/
#
[
rental_mut
(
debug
deref_mut_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentRefCellMut
<
H
:
'
static
+
StableDeref
+
DerefMut
T
:
'
static
>
{
head
:
H
suffix
:
cell
:
:
RefMut
<
'
head
T
>
}
/
/
/
Stores
a
Mutex
and
a
MutexGuard
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentMutex
;
/
/
/
#
fn
main
(
)
{
/
/
/
use
std
:
:
sync
;
/
/
/
/
/
/
let
mut
r
=
RentMutex
:
:
new
(
Box
:
:
new
(
sync
:
:
Mutex
:
:
new
(
5
)
)
|
c
|
c
.
lock
(
)
.
unwrap
(
)
)
;
/
/
/
*
r
=
12
;
/
/
/
assert_eq
!
(
12
RentMutex
:
:
rent
(
&
r
|
c
|
*
*
c
)
)
;
/
/
/
#
}
/
/
/
#
[
rental
(
debug
clone
deref_mut_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentMutex
<
H
:
'
static
+
StableDeref
+
DerefMut
T
:
'
static
>
{
head
:
H
suffix
:
sync
:
:
MutexGuard
<
'
head
T
>
}
/
/
/
Stores
an
RwLock
and
an
RwLockReadGuard
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentRwLock
;
/
/
/
#
fn
main
(
)
{
/
/
/
use
std
:
:
sync
;
/
/
/
/
/
/
let
r
=
RentRwLock
:
:
new
(
Box
:
:
new
(
sync
:
:
RwLock
:
:
new
(
5
)
)
|
c
|
c
.
read
(
)
.
unwrap
(
)
)
;
/
/
/
assert_eq
!
(
*
r
RentRwLock
:
:
rent
(
&
r
|
c
|
*
*
c
)
)
;
/
/
/
#
}
/
/
/
#
[
rental
(
debug
clone
deref_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentRwLock
<
H
:
'
static
+
StableDeref
T
:
'
static
>
{
head
:
H
suffix
:
sync
:
:
RwLockReadGuard
<
'
head
T
>
}
/
/
/
Stores
an
RwLock
and
an
RwLockWriteGuard
in
the
same
struct
.
/
/
/
/
/
/
rust
/
/
/
#
extern
crate
rental
;
/
/
/
#
use
rental
:
:
common
:
:
RentRwLockMut
;
/
/
/
#
fn
main
(
)
{
/
/
/
use
std
:
:
sync
;
/
/
/
/
/
/
let
mut
r
=
RentRwLockMut
:
:
new
(
Box
:
:
new
(
sync
:
:
RwLock
:
:
new
(
5
)
)
|
c
|
c
.
write
(
)
.
unwrap
(
)
)
;
/
/
/
*
r
=
12
;
/
/
/
assert_eq
!
(
12
RentRwLockMut
:
:
rent
(
&
r
|
c
|
*
*
c
)
)
;
/
/
/
#
}
/
/
/
#
[
rental
(
debug
clone
deref_mut_suffix
covariant
map_suffix
=
"
T
"
)
]
pub
struct
RentRwLockMut
<
H
:
'
static
+
StableDeref
T
:
'
static
>
{
head
:
H
suffix
:
sync
:
:
RwLockWriteGuard
<
'
head
T
>
}
}
}
