#
[
cfg
(
feature
=
"
chrono
"
)
]
extern
crate
chrono
;
#
[
cfg
(
feature
=
"
serialization
-
serde
"
)
]
extern
crate
serde
;
extern
crate
winapi
;
use
enums
:
:
*
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
mem
:
:
transmute
;
use
std
:
:
os
:
:
windows
:
:
ffi
:
:
OsStrExt
;
use
std
:
:
ptr
;
use
std
:
:
slice
;
#
[
cfg
(
feature
=
"
transactions
"
)
]
use
transaction
:
:
Transaction
;
use
types
:
:
{
FromRegValue
ToRegValue
}
;
pub
use
winapi
:
:
shared
:
:
minwindef
:
:
HKEY
;
use
winapi
:
:
shared
:
:
minwindef
:
:
{
BYTE
DWORD
FILETIME
LPBYTE
}
;
use
winapi
:
:
shared
:
:
winerror
;
use
winapi
:
:
um
:
:
minwinbase
:
:
SYSTEMTIME
;
use
winapi
:
:
um
:
:
timezoneapi
:
:
FileTimeToSystemTime
;
use
winapi
:
:
um
:
:
winnt
:
:
{
self
WCHAR
}
;
use
winapi
:
:
um
:
:
winreg
as
winapi_reg
;
macro_rules
!
werr
{
(
e
:
expr
)
=
>
{
Err
(
io
:
:
Error
:
:
from_raw_os_error
(
e
as
i32
)
)
}
;
}
#
[
cfg
(
feature
=
"
serialization
-
serde
"
)
]
mod
decoder
;
#
[
cfg
(
feature
=
"
serialization
-
serde
"
)
]
mod
encoder
;
pub
mod
enums
;
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
mod
transaction
;
pub
mod
types
;
#
[
derive
(
Debug
Default
)
]
pub
struct
RegKeyMetadata
{
pub
sub_keys
:
DWORD
pub
max_sub_key_len
:
DWORD
pub
max_class_len
:
DWORD
pub
values
:
DWORD
pub
max_value_name_len
:
DWORD
pub
max_value_len
:
DWORD
pub
last_write_time
:
FILETIME
}
impl
RegKeyMetadata
{
pub
fn
get_last_write_time_system
(
&
self
)
-
>
SYSTEMTIME
{
let
mut
st
:
SYSTEMTIME
=
unsafe
{
:
:
std
:
:
mem
:
:
zeroed
(
)
}
;
unsafe
{
FileTimeToSystemTime
(
&
self
.
last_write_time
&
mut
st
)
;
}
st
}
#
[
cfg
(
feature
=
"
chrono
"
)
]
pub
fn
get_last_write_time_chrono
(
&
self
)
-
>
chrono
:
:
NaiveDateTime
{
let
st
=
self
.
get_last_write_time_system
(
)
;
chrono
:
:
NaiveDate
:
:
from_ymd
(
st
.
wYear
.
into
(
)
st
.
wMonth
.
into
(
)
st
.
wDay
.
into
(
)
)
.
and_hms
(
st
.
wHour
.
into
(
)
st
.
wMinute
.
into
(
)
st
.
wSecond
.
into
(
)
)
}
}
#
[
derive
(
PartialEq
)
]
pub
struct
RegValue
{
pub
bytes
:
Vec
<
u8
>
pub
vtype
:
RegType
}
macro_rules
!
format_reg_value
{
(
e
:
expr
=
>
t
:
ident
)
=
>
{
match
t
:
:
from_reg_value
(
e
)
{
Ok
(
val
)
=
>
format
!
(
"
{
:
?
}
"
val
)
Err
(
_
)
=
>
return
Err
(
fmt
:
:
Error
)
}
}
;
}
impl
fmt
:
:
Display
for
RegValue
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
f_val
=
match
self
.
vtype
{
REG_SZ
|
REG_EXPAND_SZ
|
REG_MULTI_SZ
=
>
format_reg_value
!
(
self
=
>
String
)
REG_DWORD
=
>
format_reg_value
!
(
self
=
>
u32
)
REG_QWORD
=
>
format_reg_value
!
(
self
=
>
u64
)
_
=
>
format
!
(
"
{
:
?
}
"
self
.
bytes
)
}
;
write
!
(
f
"
{
}
"
f_val
)
}
}
impl
fmt
:
:
Debug
for
RegValue
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
RegValue
(
{
:
?
}
:
{
}
)
"
self
.
vtype
self
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
RegKey
{
hkey
:
HKEY
}
unsafe
impl
Send
for
RegKey
{
}
impl
RegKey
{
pub
const
fn
predef
(
hkey
:
HKEY
)
-
>
RegKey
{
RegKey
{
hkey
}
}
pub
fn
load_app_key
<
N
:
AsRef
<
OsStr
>
>
(
filename
:
N
lock
:
bool
)
-
>
io
:
:
Result
<
RegKey
>
{
let
options
=
if
lock
{
winapi_reg
:
:
REG_PROCESS_APPKEY
}
else
{
0
}
;
RegKey
:
:
load_app_key_with_flags
(
filename
enums
:
:
KEY_ALL_ACCESS
options
)
}
pub
fn
load_app_key_with_flags
<
N
:
AsRef
<
OsStr
>
>
(
filename
:
N
perms
:
winapi_reg
:
:
REGSAM
options
:
DWORD
)
-
>
io
:
:
Result
<
RegKey
>
{
let
c_filename
=
to_utf16
(
filename
)
;
let
mut
new_hkey
:
HKEY
=
ptr
:
:
null_mut
(
)
;
match
unsafe
{
winapi_reg
:
:
RegLoadAppKeyW
(
c_filename
.
as_ptr
(
)
&
mut
new_hkey
perms
options
0
)
as
DWORD
}
{
0
=
>
Ok
(
RegKey
{
hkey
:
new_hkey
}
)
err
=
>
werr
!
(
err
)
}
}
pub
const
fn
raw_handle
(
&
self
)
-
>
HKEY
{
self
.
hkey
}
pub
fn
open_subkey
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
)
-
>
io
:
:
Result
<
RegKey
>
{
self
.
open_subkey_with_flags
(
path
enums
:
:
KEY_READ
)
}
pub
fn
open_subkey_with_flags
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
perms
:
winapi_reg
:
:
REGSAM
)
-
>
io
:
:
Result
<
RegKey
>
{
let
c_path
=
to_utf16
(
path
)
;
let
mut
new_hkey
:
HKEY
=
ptr
:
:
null_mut
(
)
;
match
unsafe
{
winapi_reg
:
:
RegOpenKeyExW
(
self
.
hkey
c_path
.
as_ptr
(
)
0
perms
&
mut
new_hkey
)
as
DWORD
}
{
0
=
>
Ok
(
RegKey
{
hkey
:
new_hkey
}
)
err
=
>
werr
!
(
err
)
}
}
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
fn
open_subkey_transacted
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
t
:
&
Transaction
)
-
>
io
:
:
Result
<
RegKey
>
{
self
.
open_subkey_transacted_with_flags
(
path
t
winnt
:
:
KEY_READ
)
}
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
fn
open_subkey_transacted_with_flags
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
t
:
&
Transaction
perms
:
winapi_reg
:
:
REGSAM
)
-
>
io
:
:
Result
<
RegKey
>
{
let
c_path
=
to_utf16
(
path
)
;
let
mut
new_hkey
:
HKEY
=
ptr
:
:
null_mut
(
)
;
match
unsafe
{
winapi_reg
:
:
RegOpenKeyTransactedW
(
self
.
hkey
c_path
.
as_ptr
(
)
0
perms
&
mut
new_hkey
t
.
handle
ptr
:
:
null_mut
(
)
)
as
DWORD
}
{
0
=
>
Ok
(
RegKey
{
hkey
:
new_hkey
}
)
err
=
>
werr
!
(
err
)
}
}
pub
fn
create_subkey
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
)
-
>
io
:
:
Result
<
(
RegKey
RegDisposition
)
>
{
self
.
create_subkey_with_flags
(
path
enums
:
:
KEY_ALL_ACCESS
)
}
pub
fn
create_subkey_with_flags
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
perms
:
winapi_reg
:
:
REGSAM
)
-
>
io
:
:
Result
<
(
RegKey
RegDisposition
)
>
{
let
c_path
=
to_utf16
(
path
)
;
let
mut
new_hkey
:
HKEY
=
ptr
:
:
null_mut
(
)
;
let
mut
disp_buf
:
DWORD
=
0
;
match
unsafe
{
winapi_reg
:
:
RegCreateKeyExW
(
self
.
hkey
c_path
.
as_ptr
(
)
0
ptr
:
:
null_mut
(
)
winnt
:
:
REG_OPTION_NON_VOLATILE
perms
ptr
:
:
null_mut
(
)
&
mut
new_hkey
&
mut
disp_buf
)
}
{
0
=
>
{
let
disp
:
RegDisposition
=
unsafe
{
transmute
(
disp_buf
as
u8
)
}
;
Ok
(
(
RegKey
{
hkey
:
new_hkey
}
disp
)
)
}
err
=
>
werr
!
(
err
)
}
}
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
fn
create_subkey_transacted
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
t
:
&
Transaction
)
-
>
io
:
:
Result
<
(
RegKey
RegDisposition
)
>
{
self
.
create_subkey_transacted_with_flags
(
path
t
winnt
:
:
KEY_ALL_ACCESS
)
}
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
fn
create_subkey_transacted_with_flags
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
t
:
&
Transaction
perms
:
winapi_reg
:
:
REGSAM
)
-
>
io
:
:
Result
<
(
RegKey
RegDisposition
)
>
{
let
c_path
=
to_utf16
(
path
)
;
let
mut
new_hkey
:
HKEY
=
ptr
:
:
null_mut
(
)
;
let
mut
disp_buf
:
DWORD
=
0
;
match
unsafe
{
winapi_reg
:
:
RegCreateKeyTransactedW
(
self
.
hkey
c_path
.
as_ptr
(
)
0
ptr
:
:
null_mut
(
)
winnt
:
:
REG_OPTION_NON_VOLATILE
perms
ptr
:
:
null_mut
(
)
&
mut
new_hkey
&
mut
disp_buf
t
.
handle
ptr
:
:
null_mut
(
)
)
as
DWORD
}
{
0
=
>
{
let
disp
:
RegDisposition
=
unsafe
{
transmute
(
disp_buf
as
u8
)
}
;
Ok
(
(
RegKey
{
hkey
:
new_hkey
}
disp
)
)
}
err
=
>
werr
!
(
err
)
}
}
pub
fn
copy_tree
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
dest
:
&
RegKey
)
-
>
io
:
:
Result
<
(
)
>
{
let
c_path
=
to_utf16
(
path
)
;
match
unsafe
{
winapi_reg
:
:
RegCopyTreeW
(
self
.
hkey
c_path
.
as_ptr
(
)
dest
.
hkey
)
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
pub
fn
query_info
(
&
self
)
-
>
io
:
:
Result
<
RegKeyMetadata
>
{
let
mut
info
:
RegKeyMetadata
=
Default
:
:
default
(
)
;
match
unsafe
{
winapi_reg
:
:
RegQueryInfoKeyW
(
self
.
hkey
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
&
mut
info
.
sub_keys
&
mut
info
.
max_sub_key_len
&
mut
info
.
max_class_len
&
mut
info
.
values
&
mut
info
.
max_value_name_len
&
mut
info
.
max_value_len
ptr
:
:
null_mut
(
)
&
mut
info
.
last_write_time
)
as
DWORD
}
{
0
=
>
Ok
(
info
)
err
=
>
werr
!
(
err
)
}
}
pub
const
fn
enum_keys
(
&
self
)
-
>
EnumKeys
{
EnumKeys
{
key
:
self
index
:
0
}
}
pub
const
fn
enum_values
(
&
self
)
-
>
EnumValues
{
EnumValues
{
key
:
self
index
:
0
}
}
pub
fn
delete_subkey
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
delete_subkey_with_flags
(
path
0
)
}
pub
fn
delete_subkey_with_flags
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
perms
:
winapi_reg
:
:
REGSAM
)
-
>
io
:
:
Result
<
(
)
>
{
let
c_path
=
to_utf16
(
path
)
;
match
unsafe
{
winapi_reg
:
:
RegDeleteKeyExW
(
self
.
hkey
c_path
.
as_ptr
(
)
perms
0
)
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
fn
delete_subkey_transacted
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
t
:
&
Transaction
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
delete_subkey_transacted_with_flags
(
path
t
0
)
}
#
[
cfg
(
feature
=
"
transactions
"
)
]
pub
fn
delete_subkey_transacted_with_flags
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
t
:
&
Transaction
perms
:
winapi_reg
:
:
REGSAM
)
-
>
io
:
:
Result
<
(
)
>
{
let
c_path
=
to_utf16
(
path
)
;
match
unsafe
{
winapi_reg
:
:
RegDeleteKeyTransactedW
(
self
.
hkey
c_path
.
as_ptr
(
)
perms
0
t
.
handle
ptr
:
:
null_mut
(
)
)
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
pub
fn
delete_subkey_all
<
P
:
AsRef
<
OsStr
>
>
(
&
self
path
:
P
)
-
>
io
:
:
Result
<
(
)
>
{
let
c_path
;
let
path_ptr
=
if
path
.
as_ref
(
)
.
is_empty
(
)
{
ptr
:
:
null
(
)
}
else
{
c_path
=
to_utf16
(
path
)
;
c_path
.
as_ptr
(
)
}
;
match
unsafe
{
winapi_reg
:
:
RegDeleteTreeW
(
self
.
hkey
path_ptr
)
as
DWORD
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
pub
fn
get_value
<
T
:
FromRegValue
N
:
AsRef
<
OsStr
>
>
(
&
self
name
:
N
)
-
>
io
:
:
Result
<
T
>
{
match
self
.
get_raw_value
(
name
)
{
Ok
(
ref
val
)
=
>
FromRegValue
:
:
from_reg_value
(
val
)
Err
(
err
)
=
>
Err
(
err
)
}
}
pub
fn
get_raw_value
<
N
:
AsRef
<
OsStr
>
>
(
&
self
name
:
N
)
-
>
io
:
:
Result
<
RegValue
>
{
let
c_name
=
to_utf16
(
name
)
;
let
mut
buf_len
:
DWORD
=
2048
;
let
mut
buf_type
:
DWORD
=
0
;
let
mut
buf
:
Vec
<
u8
>
=
Vec
:
:
with_capacity
(
buf_len
as
usize
)
;
loop
{
match
unsafe
{
winapi_reg
:
:
RegQueryValueExW
(
self
.
hkey
c_name
.
as_ptr
(
)
as
*
const
u16
ptr
:
:
null_mut
(
)
&
mut
buf_type
buf
.
as_mut_ptr
(
)
as
LPBYTE
&
mut
buf_len
)
as
DWORD
}
{
0
=
>
{
unsafe
{
buf
.
set_len
(
buf_len
as
usize
)
;
}
if
buf_type
>
winnt
:
:
REG_QWORD
{
return
werr
!
(
winerror
:
:
ERROR_BAD_FILE_TYPE
)
;
}
let
t
:
RegType
=
unsafe
{
transmute
(
buf_type
as
u8
)
}
;
return
Ok
(
RegValue
{
bytes
:
buf
vtype
:
t
}
)
;
}
winerror
:
:
ERROR_MORE_DATA
=
>
{
buf
.
reserve
(
buf_len
as
usize
)
;
}
err
=
>
return
werr
!
(
err
)
}
}
}
pub
fn
set_value
<
T
:
ToRegValue
N
:
AsRef
<
OsStr
>
>
(
&
self
name
:
N
value
:
&
T
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
set_raw_value
(
name
&
value
.
to_reg_value
(
)
)
}
pub
fn
set_raw_value
<
N
:
AsRef
<
OsStr
>
>
(
&
self
name
:
N
value
:
&
RegValue
)
-
>
io
:
:
Result
<
(
)
>
{
let
c_name
=
to_utf16
(
name
)
;
let
t
=
value
.
vtype
.
clone
(
)
as
DWORD
;
match
unsafe
{
winapi_reg
:
:
RegSetValueExW
(
self
.
hkey
c_name
.
as_ptr
(
)
0
t
value
.
bytes
.
as_ptr
(
)
as
*
const
BYTE
value
.
bytes
.
len
(
)
as
u32
)
as
DWORD
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
pub
fn
delete_value
<
N
:
AsRef
<
OsStr
>
>
(
&
self
name
:
N
)
-
>
io
:
:
Result
<
(
)
>
{
let
c_name
=
to_utf16
(
name
)
;
match
unsafe
{
winapi_reg
:
:
RegDeleteValueW
(
self
.
hkey
c_name
.
as_ptr
(
)
)
as
DWORD
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
#
[
cfg
(
feature
=
"
serialization
-
serde
"
)
]
pub
fn
encode
<
T
:
serde
:
:
Serialize
>
(
&
self
value
:
&
T
)
-
>
encoder
:
:
EncodeResult
<
(
)
>
{
let
mut
encoder
=
encoder
:
:
Encoder
:
:
from_key
(
self
)
?
;
value
.
serialize
(
&
mut
encoder
)
?
;
encoder
.
commit
(
)
}
#
[
cfg
(
feature
=
"
serialization
-
serde
"
)
]
pub
fn
decode
<
'
de
T
:
serde
:
:
Deserialize
<
'
de
>
>
(
&
self
)
-
>
decoder
:
:
DecodeResult
<
T
>
{
let
mut
decoder
=
decoder
:
:
Decoder
:
:
from_key
(
self
)
?
;
T
:
:
deserialize
(
&
mut
decoder
)
}
fn
close_
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
self
.
hkey
>
=
enums
:
:
HKEY_CLASSES_ROOT
{
return
Ok
(
(
)
)
;
}
;
match
unsafe
{
winapi_reg
:
:
RegCloseKey
(
self
.
hkey
)
as
DWORD
}
{
0
=
>
Ok
(
(
)
)
err
=
>
werr
!
(
err
)
}
}
fn
enum_key
(
&
self
index
:
DWORD
)
-
>
Option
<
io
:
:
Result
<
String
>
>
{
let
mut
name_len
=
2048
;
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
let
mut
name
=
[
0
as
WCHAR
;
2048
]
;
match
unsafe
{
winapi_reg
:
:
RegEnumKeyExW
(
self
.
hkey
index
name
.
as_mut_ptr
(
)
&
mut
name_len
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
ptr
:
:
null_mut
(
)
)
as
DWORD
}
{
0
=
>
match
String
:
:
from_utf16
(
&
name
[
.
.
name_len
as
usize
]
)
{
Ok
(
s
)
=
>
Some
(
Ok
(
s
)
)
Err
(
_
)
=
>
Some
(
werr
!
(
winerror
:
:
ERROR_INVALID_BLOCK
)
)
}
winerror
:
:
ERROR_NO_MORE_ITEMS
=
>
None
err
=
>
Some
(
werr
!
(
err
)
)
}
}
fn
enum_value
(
&
self
index
:
DWORD
)
-
>
Option
<
io
:
:
Result
<
(
String
RegValue
)
>
>
{
let
mut
name_len
=
2048
;
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
let
mut
name
=
[
0
as
WCHAR
;
2048
]
;
let
mut
buf_len
:
DWORD
=
2048
;
let
mut
buf_type
:
DWORD
=
0
;
let
mut
buf
:
Vec
<
u8
>
=
Vec
:
:
with_capacity
(
buf_len
as
usize
)
;
loop
{
match
unsafe
{
winapi_reg
:
:
RegEnumValueW
(
self
.
hkey
index
name
.
as_mut_ptr
(
)
&
mut
name_len
ptr
:
:
null_mut
(
)
&
mut
buf_type
buf
.
as_mut_ptr
(
)
as
LPBYTE
&
mut
buf_len
)
as
DWORD
}
{
0
=
>
{
let
name
=
match
String
:
:
from_utf16
(
&
name
[
.
.
name_len
as
usize
]
)
{
Ok
(
s
)
=
>
s
Err
(
_
)
=
>
return
Some
(
werr
!
(
winerror
:
:
ERROR_INVALID_DATA
)
)
}
;
unsafe
{
buf
.
set_len
(
buf_len
as
usize
)
;
}
if
buf_type
>
winnt
:
:
REG_QWORD
{
return
Some
(
werr
!
(
winerror
:
:
ERROR_BAD_FILE_TYPE
)
)
;
}
let
t
:
RegType
=
unsafe
{
transmute
(
buf_type
as
u8
)
}
;
let
value
=
RegValue
{
bytes
:
buf
vtype
:
t
}
;
return
Some
(
Ok
(
(
name
value
)
)
)
;
}
winerror
:
:
ERROR_MORE_DATA
=
>
{
name_len
+
=
1
;
buf
.
reserve
(
buf_len
as
usize
)
;
}
winerror
:
:
ERROR_NO_MORE_ITEMS
=
>
return
None
err
=
>
return
Some
(
werr
!
(
err
)
)
}
}
}
}
impl
Drop
for
RegKey
{
fn
drop
(
&
mut
self
)
{
self
.
close_
(
)
.
unwrap_or
(
(
)
)
;
}
}
pub
struct
EnumKeys
<
'
key
>
{
key
:
&
'
key
RegKey
index
:
DWORD
}
impl
<
'
key
>
Iterator
for
EnumKeys
<
'
key
>
{
type
Item
=
io
:
:
Result
<
String
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
io
:
:
Result
<
String
>
>
{
match
self
.
key
.
enum_key
(
self
.
index
)
{
v
Some
(
_
)
=
>
{
self
.
index
+
=
1
;
v
}
e
None
=
>
e
}
}
fn
nth
(
&
mut
self
n
:
usize
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
index
+
=
n
as
DWORD
;
self
.
next
(
)
}
}
pub
struct
EnumValues
<
'
key
>
{
key
:
&
'
key
RegKey
index
:
DWORD
}
impl
<
'
key
>
Iterator
for
EnumValues
<
'
key
>
{
type
Item
=
io
:
:
Result
<
(
String
RegValue
)
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
io
:
:
Result
<
(
String
RegValue
)
>
>
{
match
self
.
key
.
enum_value
(
self
.
index
)
{
v
Some
(
_
)
=
>
{
self
.
index
+
=
1
;
v
}
e
None
=
>
e
}
}
fn
nth
(
&
mut
self
n
:
usize
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
index
+
=
n
as
DWORD
;
self
.
next
(
)
}
}
fn
to_utf16
<
P
:
AsRef
<
OsStr
>
>
(
s
:
P
)
-
>
Vec
<
u16
>
{
s
.
as_ref
(
)
.
encode_wide
(
)
.
chain
(
Some
(
0
)
.
into_iter
(
)
)
.
collect
(
)
}
fn
v16_to_v8
(
v
:
&
[
u16
]
)
-
>
Vec
<
u8
>
{
unsafe
{
slice
:
:
from_raw_parts
(
v
.
as_ptr
(
)
as
*
const
u8
v
.
len
(
)
*
2
)
.
to_vec
(
)
}
}
