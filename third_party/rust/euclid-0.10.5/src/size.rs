use
super
:
:
UnknownUnit
;
use
length
:
:
Length
;
use
scale_factor
:
:
ScaleFactor
;
use
num
:
:
*
;
use
num_traits
:
:
NumCast
;
use
std
:
:
fmt
;
use
std
:
:
ops
:
:
{
Add
Div
Mul
Sub
}
;
use
std
:
:
marker
:
:
PhantomData
;
define_matrix
!
{
#
[
derive
(
RustcDecodable
RustcEncodable
)
]
pub
struct
TypedSize2D
<
T
U
>
{
pub
width
:
T
pub
height
:
T
}
}
pub
type
Size2D
<
T
>
=
TypedSize2D
<
T
UnknownUnit
>
;
impl
<
T
:
fmt
:
:
Debug
U
>
fmt
:
:
Debug
for
TypedSize2D
<
T
U
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
{
:
?
}
"
self
.
width
self
.
height
)
}
}
impl
<
T
:
fmt
:
:
Display
U
>
fmt
:
:
Display
for
TypedSize2D
<
T
U
>
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
(
{
}
x
{
}
)
"
self
.
width
self
.
height
)
}
}
impl
<
T
U
>
TypedSize2D
<
T
U
>
{
pub
fn
new
(
width
:
T
height
:
T
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
{
width
:
width
height
:
height
_unit
:
PhantomData
}
}
}
impl
<
T
:
Clone
U
>
TypedSize2D
<
T
U
>
{
pub
fn
from_lengths
(
width
:
Length
<
T
U
>
height
:
Length
<
T
U
>
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
width
.
get
(
)
height
.
get
(
)
)
}
}
impl
<
T
:
Round
U
>
TypedSize2D
<
T
U
>
{
pub
fn
round
(
&
self
)
-
>
Self
{
TypedSize2D
:
:
new
(
self
.
width
.
round
(
)
self
.
height
.
round
(
)
)
}
}
impl
<
T
:
Ceil
U
>
TypedSize2D
<
T
U
>
{
pub
fn
ceil
(
&
self
)
-
>
Self
{
TypedSize2D
:
:
new
(
self
.
width
.
ceil
(
)
self
.
height
.
ceil
(
)
)
}
}
impl
<
T
:
Floor
U
>
TypedSize2D
<
T
U
>
{
pub
fn
floor
(
&
self
)
-
>
Self
{
TypedSize2D
:
:
new
(
self
.
width
.
floor
(
)
self
.
height
.
floor
(
)
)
}
}
impl
<
T
:
Copy
+
Add
<
T
Output
=
T
>
U
>
Add
for
TypedSize2D
<
T
U
>
{
type
Output
=
TypedSize2D
<
T
U
>
;
fn
add
(
self
other
:
TypedSize2D
<
T
U
>
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
self
.
width
+
other
.
width
self
.
height
+
other
.
height
)
}
}
impl
<
T
:
Copy
+
Sub
<
T
Output
=
T
>
U
>
Sub
for
TypedSize2D
<
T
U
>
{
type
Output
=
TypedSize2D
<
T
U
>
;
fn
sub
(
self
other
:
TypedSize2D
<
T
U
>
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
self
.
width
-
other
.
width
self
.
height
-
other
.
height
)
}
}
impl
<
T
:
Copy
+
Clone
+
Mul
<
T
Output
=
U
>
U
>
TypedSize2D
<
T
U
>
{
pub
fn
area
(
&
self
)
-
>
U
{
self
.
width
*
self
.
height
}
}
impl
<
T
:
Zero
U
>
TypedSize2D
<
T
U
>
{
pub
fn
zero
(
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
Zero
:
:
zero
(
)
Zero
:
:
zero
(
)
)
}
}
impl
<
T
:
Zero
U
>
Zero
for
TypedSize2D
<
T
U
>
{
fn
zero
(
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
Zero
:
:
zero
(
)
Zero
:
:
zero
(
)
)
}
}
impl
<
T
:
Copy
+
Mul
<
T
Output
=
T
>
U
>
Mul
<
T
>
for
TypedSize2D
<
T
U
>
{
type
Output
=
TypedSize2D
<
T
U
>
;
#
[
inline
]
fn
mul
(
self
scale
:
T
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
self
.
width
*
scale
self
.
height
*
scale
)
}
}
impl
<
T
:
Copy
+
Div
<
T
Output
=
T
>
U
>
Div
<
T
>
for
TypedSize2D
<
T
U
>
{
type
Output
=
TypedSize2D
<
T
U
>
;
#
[
inline
]
fn
div
(
self
scale
:
T
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
self
.
width
/
scale
self
.
height
/
scale
)
}
}
impl
<
T
:
Copy
+
Mul
<
T
Output
=
T
>
U1
U2
>
Mul
<
ScaleFactor
<
T
U1
U2
>
>
for
TypedSize2D
<
T
U1
>
{
type
Output
=
TypedSize2D
<
T
U2
>
;
#
[
inline
]
fn
mul
(
self
scale
:
ScaleFactor
<
T
U1
U2
>
)
-
>
TypedSize2D
<
T
U2
>
{
TypedSize2D
:
:
new
(
self
.
width
*
scale
.
get
(
)
self
.
height
*
scale
.
get
(
)
)
}
}
impl
<
T
:
Copy
+
Div
<
T
Output
=
T
>
U1
U2
>
Div
<
ScaleFactor
<
T
U1
U2
>
>
for
TypedSize2D
<
T
U2
>
{
type
Output
=
TypedSize2D
<
T
U1
>
;
#
[
inline
]
fn
div
(
self
scale
:
ScaleFactor
<
T
U1
U2
>
)
-
>
TypedSize2D
<
T
U1
>
{
TypedSize2D
:
:
new
(
self
.
width
/
scale
.
get
(
)
self
.
height
/
scale
.
get
(
)
)
}
}
impl
<
T
:
Copy
U
>
TypedSize2D
<
T
U
>
{
#
[
inline
]
pub
fn
width_typed
(
&
self
)
-
>
Length
<
T
U
>
{
Length
:
:
new
(
self
.
width
)
}
#
[
inline
]
pub
fn
height_typed
(
&
self
)
-
>
Length
<
T
U
>
{
Length
:
:
new
(
self
.
height
)
}
#
[
inline
]
pub
fn
to_array
(
&
self
)
-
>
[
T
;
2
]
{
[
self
.
width
self
.
height
]
}
pub
fn
to_untyped
(
&
self
)
-
>
Size2D
<
T
>
{
TypedSize2D
:
:
new
(
self
.
width
self
.
height
)
}
pub
fn
from_untyped
(
p
:
&
Size2D
<
T
>
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
p
.
width
p
.
height
)
}
}
impl
<
T
:
NumCast
+
Copy
Unit
>
TypedSize2D
<
T
Unit
>
{
pub
fn
cast
<
NewT
:
NumCast
+
Copy
>
(
&
self
)
-
>
Option
<
TypedSize2D
<
NewT
Unit
>
>
{
match
(
NumCast
:
:
from
(
self
.
width
)
NumCast
:
:
from
(
self
.
height
)
)
{
(
Some
(
w
)
Some
(
h
)
)
=
>
Some
(
TypedSize2D
:
:
new
(
w
h
)
)
_
=
>
None
}
}
pub
fn
to_f32
(
&
self
)
-
>
TypedSize2D
<
f32
Unit
>
{
self
.
cast
(
)
.
unwrap
(
)
}
pub
fn
to_uint
(
&
self
)
-
>
TypedSize2D
<
usize
Unit
>
{
self
.
cast
(
)
.
unwrap
(
)
}
pub
fn
to_i32
(
&
self
)
-
>
TypedSize2D
<
i32
Unit
>
{
self
.
cast
(
)
.
unwrap
(
)
}
pub
fn
to_i64
(
&
self
)
-
>
TypedSize2D
<
i64
Unit
>
{
self
.
cast
(
)
.
unwrap
(
)
}
}
pub
fn
size2
<
T
U
>
(
w
:
T
h
:
T
)
-
>
TypedSize2D
<
T
U
>
{
TypedSize2D
:
:
new
(
w
h
)
}
#
[
cfg
(
test
)
]
mod
size2d
{
use
super
:
:
Size2D
;
#
[
test
]
pub
fn
test_add
(
)
{
let
p1
=
Size2D
:
:
new
(
1
.
0
2
.
0
)
;
let
p2
=
Size2D
:
:
new
(
3
.
0
4
.
0
)
;
assert_eq
!
(
p1
+
p2
Size2D
:
:
new
(
4
.
0
6
.
0
)
)
;
let
p1
=
Size2D
:
:
new
(
1
.
0
2
.
0
)
;
let
p2
=
Size2D
:
:
new
(
0
.
0
0
.
0
)
;
assert_eq
!
(
p1
+
p2
Size2D
:
:
new
(
1
.
0
2
.
0
)
)
;
let
p1
=
Size2D
:
:
new
(
1
.
0
2
.
0
)
;
let
p2
=
Size2D
:
:
new
(
-
3
.
0
-
4
.
0
)
;
assert_eq
!
(
p1
+
p2
Size2D
:
:
new
(
-
2
.
0
-
2
.
0
)
)
;
let
p1
=
Size2D
:
:
new
(
0
.
0
0
.
0
)
;
let
p2
=
Size2D
:
:
new
(
0
.
0
0
.
0
)
;
assert_eq
!
(
p1
+
p2
Size2D
:
:
new
(
0
.
0
0
.
0
)
)
;
}
#
[
test
]
pub
fn
test_sub
(
)
{
let
p1
=
Size2D
:
:
new
(
1
.
0
2
.
0
)
;
let
p2
=
Size2D
:
:
new
(
3
.
0
4
.
0
)
;
assert_eq
!
(
p1
-
p2
Size2D
:
:
new
(
-
2
.
0
-
2
.
0
)
)
;
let
p1
=
Size2D
:
:
new
(
1
.
0
2
.
0
)
;
let
p2
=
Size2D
:
:
new
(
0
.
0
0
.
0
)
;
assert_eq
!
(
p1
-
p2
Size2D
:
:
new
(
1
.
0
2
.
0
)
)
;
let
p1
=
Size2D
:
:
new
(
1
.
0
2
.
0
)
;
let
p2
=
Size2D
:
:
new
(
-
3
.
0
-
4
.
0
)
;
assert_eq
!
(
p1
-
p2
Size2D
:
:
new
(
4
.
0
6
.
0
)
)
;
let
p1
=
Size2D
:
:
new
(
0
.
0
0
.
0
)
;
let
p2
=
Size2D
:
:
new
(
0
.
0
0
.
0
)
;
assert_eq
!
(
p1
-
p2
Size2D
:
:
new
(
0
.
0
0
.
0
)
)
;
}
}
