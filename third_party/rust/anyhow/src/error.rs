use
crate
:
:
backtrace
:
:
Backtrace
;
use
crate
:
:
chain
:
:
Chain
;
#
[
cfg
(
any
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
use
crate
:
:
ptr
:
:
Mut
;
use
crate
:
:
ptr
:
:
{
Own
Ref
}
;
use
crate
:
:
{
Error
StdError
}
;
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
any
:
:
TypeId
;
use
core
:
:
fmt
:
:
{
self
Debug
Display
}
;
use
core
:
:
mem
:
:
ManuallyDrop
;
#
[
cfg
(
not
(
anyhow_no_ptr_addr_of
)
)
]
use
core
:
:
ptr
;
use
core
:
:
ptr
:
:
NonNull
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
core
:
:
ops
:
:
{
Deref
DerefMut
}
;
impl
Error
{
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
#
[
cold
]
#
[
must_use
]
pub
fn
new
<
E
>
(
error
:
E
)
-
>
Self
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
backtrace
=
backtrace_if_absent
!
(
error
)
;
Error
:
:
from_std
(
error
backtrace
)
}
#
[
cold
]
#
[
must_use
]
pub
fn
msg
<
M
>
(
message
:
M
)
-
>
Self
where
M
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
Error
:
:
from_adhoc
(
message
backtrace
!
(
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cold
]
pub
(
crate
)
fn
from_std
<
E
>
(
error
:
E
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
E
>
object_ref
:
object_ref
:
:
<
E
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_mut
:
object_mut
:
:
<
E
>
object_boxed
:
object_boxed
:
:
<
E
>
object_downcast
:
object_downcast
:
:
<
E
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
object_downcast_mut
:
:
<
E
>
object_drop_rest
:
object_drop_front
:
:
<
E
>
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
no_backtrace
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cold
]
pub
(
crate
)
fn
from_adhoc
<
M
>
(
message
:
M
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
M
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
use
crate
:
:
wrapper
:
:
MessageError
;
let
error
:
MessageError
<
M
>
=
MessageError
(
message
)
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
MessageError
<
M
>
>
object_ref
:
object_ref
:
:
<
MessageError
<
M
>
>
#
[
cfg
(
all
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
object_mut
:
object_mut
:
:
<
MessageError
<
M
>
>
object_boxed
:
object_boxed
:
:
<
MessageError
<
M
>
>
object_downcast
:
object_downcast
:
:
<
M
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
object_downcast_mut
:
:
<
M
>
object_drop_rest
:
object_drop_front
:
:
<
M
>
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
no_backtrace
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cold
]
pub
(
crate
)
fn
from_display
<
M
>
(
message
:
M
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
M
:
Display
+
Send
+
Sync
+
'
static
{
use
crate
:
:
wrapper
:
:
DisplayError
;
let
error
:
DisplayError
<
M
>
=
DisplayError
(
message
)
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
DisplayError
<
M
>
>
object_ref
:
object_ref
:
:
<
DisplayError
<
M
>
>
#
[
cfg
(
all
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
object_mut
:
object_mut
:
:
<
DisplayError
<
M
>
>
object_boxed
:
object_boxed
:
:
<
DisplayError
<
M
>
>
object_downcast
:
object_downcast
:
:
<
M
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
object_downcast_mut
:
:
<
M
>
object_drop_rest
:
object_drop_front
:
:
<
M
>
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
no_backtrace
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cold
]
pub
(
crate
)
fn
from_context
<
C
E
>
(
context
:
C
error
:
E
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
C
:
Display
+
Send
+
Sync
+
'
static
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
error
:
ContextError
<
C
E
>
=
ContextError
{
context
error
}
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
ContextError
<
C
E
>
>
object_ref
:
object_ref
:
:
<
ContextError
<
C
E
>
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_mut
:
object_mut
:
:
<
ContextError
<
C
E
>
>
object_boxed
:
object_boxed
:
:
<
ContextError
<
C
E
>
>
object_downcast
:
context_downcast
:
:
<
C
E
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
context_downcast_mut
:
:
<
C
E
>
object_drop_rest
:
context_drop_rest
:
:
<
C
E
>
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
no_backtrace
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cold
]
pub
(
crate
)
fn
from_boxed
(
error
:
Box
<
dyn
StdError
+
Send
+
Sync
>
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
{
use
crate
:
:
wrapper
:
:
BoxedError
;
let
error
=
BoxedError
(
error
)
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
BoxedError
>
object_ref
:
object_ref
:
:
<
BoxedError
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_mut
:
object_mut
:
:
<
BoxedError
>
object_boxed
:
object_boxed
:
:
<
BoxedError
>
object_downcast
:
object_downcast
:
:
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
object_downcast_mut
:
:
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
object_drop_rest
:
object_drop_front
:
:
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
no_backtrace
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cold
]
unsafe
fn
construct
<
E
>
(
error
:
E
vtable
:
&
'
static
ErrorVTable
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
inner
:
Box
<
ErrorImpl
<
E
>
>
=
Box
:
:
new
(
ErrorImpl
{
vtable
backtrace
_object
:
error
}
)
;
let
inner
=
Own
:
:
new
(
inner
)
.
cast
:
:
<
ErrorImpl
>
(
)
;
Error
{
inner
}
}
#
[
cold
]
#
[
must_use
]
pub
fn
context
<
C
>
(
self
context
:
C
)
-
>
Self
where
C
:
Display
+
Send
+
Sync
+
'
static
{
let
error
:
ContextError
<
C
Error
>
=
ContextError
{
context
error
:
self
}
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
ContextError
<
C
Error
>
>
object_ref
:
object_ref
:
:
<
ContextError
<
C
Error
>
>
#
[
cfg
(
all
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
object_mut
:
object_mut
:
:
<
ContextError
<
C
Error
>
>
object_boxed
:
object_boxed
:
:
<
ContextError
<
C
Error
>
>
object_downcast
:
context_chain_downcast
:
:
<
C
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
context_chain_downcast_mut
:
:
<
C
>
object_drop_rest
:
context_chain_drop_rest
:
:
<
C
>
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
context_backtrace
:
:
<
C
>
}
;
let
backtrace
=
None
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cfg
(
any
(
backtrace
feature
=
"
backtrace
"
)
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
any
(
nightly
feature
=
"
backtrace
"
)
)
)
)
]
pub
fn
backtrace
(
&
self
)
-
>
&
impl_backtrace
!
(
)
{
unsafe
{
ErrorImpl
:
:
backtrace
(
self
.
inner
.
by_ref
(
)
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
#
[
cold
]
pub
fn
chain
(
&
self
)
-
>
Chain
{
unsafe
{
ErrorImpl
:
:
chain
(
self
.
inner
.
by_ref
(
)
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
pub
fn
root_cause
(
&
self
)
-
>
&
(
dyn
StdError
+
'
static
)
{
self
.
chain
(
)
.
last
(
)
.
unwrap
(
)
}
pub
fn
is
<
E
>
(
&
self
)
-
>
bool
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
self
.
downcast_ref
:
:
<
E
>
(
)
.
is_some
(
)
}
pub
fn
downcast
<
E
>
(
mut
self
)
-
>
Result
<
E
Self
>
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
let
target
=
TypeId
:
:
of
:
:
<
E
>
(
)
;
let
inner
=
self
.
inner
.
by_mut
(
)
;
unsafe
{
#
[
cfg
(
not
(
anyhow_no_ptr_addr_of
)
)
]
let
addr
=
match
(
vtable
(
inner
.
ptr
)
.
object_downcast
)
(
inner
.
by_ref
(
)
target
)
{
Some
(
addr
)
=
>
addr
.
by_mut
(
)
.
extend
(
)
None
=
>
return
Err
(
self
)
}
;
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
let
addr
=
match
(
vtable
(
inner
.
ptr
)
.
object_downcast_mut
)
(
inner
target
)
{
Some
(
addr
)
=
>
addr
.
extend
(
)
None
=
>
return
Err
(
self
)
}
;
let
outer
=
ManuallyDrop
:
:
new
(
self
)
;
let
error
=
addr
.
cast
:
:
<
E
>
(
)
.
read
(
)
;
(
vtable
(
outer
.
inner
.
ptr
)
.
object_drop_rest
)
(
outer
.
inner
target
)
;
Ok
(
error
)
}
}
pub
fn
downcast_ref
<
E
>
(
&
self
)
-
>
Option
<
&
E
>
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
let
target
=
TypeId
:
:
of
:
:
<
E
>
(
)
;
unsafe
{
let
addr
=
(
vtable
(
self
.
inner
.
ptr
)
.
object_downcast
)
(
self
.
inner
.
by_ref
(
)
target
)
?
;
Some
(
addr
.
cast
:
:
<
E
>
(
)
.
deref
(
)
)
}
}
pub
fn
downcast_mut
<
E
>
(
&
mut
self
)
-
>
Option
<
&
mut
E
>
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
let
target
=
TypeId
:
:
of
:
:
<
E
>
(
)
;
unsafe
{
#
[
cfg
(
not
(
anyhow_no_ptr_addr_of
)
)
]
let
addr
=
(
vtable
(
self
.
inner
.
ptr
)
.
object_downcast
)
(
self
.
inner
.
by_ref
(
)
target
)
?
.
by_mut
(
)
;
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
let
addr
=
(
vtable
(
self
.
inner
.
ptr
)
.
object_downcast_mut
)
(
self
.
inner
.
by_mut
(
)
target
)
?
;
Some
(
addr
.
cast
:
:
<
E
>
(
)
.
deref_mut
(
)
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
<
E
>
From
<
E
>
for
Error
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
#
[
cold
]
fn
from
(
error
:
E
)
-
>
Self
{
let
backtrace
=
backtrace_if_absent
!
(
error
)
;
Error
:
:
from_std
(
error
backtrace
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
Deref
for
Error
{
type
Target
=
dyn
StdError
+
Send
+
Sync
+
'
static
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
unsafe
{
ErrorImpl
:
:
error
(
self
.
inner
.
by_ref
(
)
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
DerefMut
for
Error
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
unsafe
{
ErrorImpl
:
:
error_mut
(
self
.
inner
.
by_mut
(
)
)
}
}
}
impl
Display
for
Error
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
unsafe
{
ErrorImpl
:
:
display
(
self
.
inner
.
by_ref
(
)
formatter
)
}
}
}
impl
Debug
for
Error
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
unsafe
{
ErrorImpl
:
:
debug
(
self
.
inner
.
by_ref
(
)
formatter
)
}
}
}
impl
Drop
for
Error
{
fn
drop
(
&
mut
self
)
{
unsafe
{
(
vtable
(
self
.
inner
.
ptr
)
.
object_drop
)
(
self
.
inner
)
;
}
}
}
struct
ErrorVTable
{
object_drop
:
unsafe
fn
(
Own
<
ErrorImpl
>
)
object_ref
:
unsafe
fn
(
Ref
<
ErrorImpl
>
)
-
>
Ref
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
#
[
cfg
(
all
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
object_mut
:
unsafe
fn
(
Mut
<
ErrorImpl
>
)
-
>
&
mut
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
object_boxed
:
unsafe
fn
(
Own
<
ErrorImpl
>
)
-
>
Box
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
object_downcast
:
unsafe
fn
(
Ref
<
ErrorImpl
>
TypeId
)
-
>
Option
<
Ref
<
(
)
>
>
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
object_downcast_mut
:
unsafe
fn
(
Mut
<
ErrorImpl
>
TypeId
)
-
>
Option
<
Mut
<
(
)
>
>
object_drop_rest
:
unsafe
fn
(
Own
<
ErrorImpl
>
TypeId
)
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
object_backtrace
:
unsafe
fn
(
Ref
<
ErrorImpl
>
)
-
>
Option
<
&
Backtrace
>
}
unsafe
fn
object_drop
<
E
>
(
e
:
Own
<
ErrorImpl
>
)
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
E
>
>
(
)
.
boxed
(
)
;
drop
(
unerased
)
;
}
unsafe
fn
object_drop_front
<
E
>
(
e
:
Own
<
ErrorImpl
>
target
:
TypeId
)
{
let
_
=
target
;
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ManuallyDrop
<
E
>
>
>
(
)
.
boxed
(
)
;
drop
(
unerased
)
;
}
unsafe
fn
object_ref
<
E
>
(
e
:
Ref
<
ErrorImpl
>
)
-
>
Ref
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
E
>
>
(
)
;
#
[
cfg
(
not
(
anyhow_no_ptr_addr_of
)
)
]
return
Ref
:
:
from_raw
(
NonNull
:
:
new_unchecked
(
ptr
:
:
addr_of
!
(
(
*
unerased
.
as_ptr
(
)
)
.
_object
)
as
*
mut
E
)
)
;
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
return
Ref
:
:
new
(
&
unerased
.
deref
(
)
.
_object
)
;
}
#
[
cfg
(
all
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
unsafe
fn
object_mut
<
E
>
(
e
:
Mut
<
ErrorImpl
>
)
-
>
&
mut
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
&
mut
e
.
cast
:
:
<
ErrorImpl
<
E
>
>
(
)
.
deref_mut
(
)
.
_object
}
unsafe
fn
object_boxed
<
E
>
(
e
:
Own
<
ErrorImpl
>
)
-
>
Box
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
e
.
cast
:
:
<
ErrorImpl
<
E
>
>
(
)
.
boxed
(
)
}
unsafe
fn
object_downcast
<
E
>
(
e
:
Ref
<
ErrorImpl
>
target
:
TypeId
)
-
>
Option
<
Ref
<
(
)
>
>
where
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
E
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
E
>
>
(
)
;
#
[
cfg
(
not
(
anyhow_no_ptr_addr_of
)
)
]
return
Some
(
Ref
:
:
from_raw
(
NonNull
:
:
new_unchecked
(
ptr
:
:
addr_of
!
(
(
*
unerased
.
as_ptr
(
)
)
.
_object
)
as
*
mut
E
)
)
.
cast
:
:
<
(
)
>
(
)
)
;
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
return
Some
(
Ref
:
:
new
(
&
unerased
.
deref
(
)
.
_object
)
.
cast
:
:
<
(
)
>
(
)
)
;
}
else
{
None
}
}
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
unsafe
fn
object_downcast_mut
<
E
>
(
e
:
Mut
<
ErrorImpl
>
target
:
TypeId
)
-
>
Option
<
Mut
<
(
)
>
>
where
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
E
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
E
>
>
(
)
.
deref_mut
(
)
;
Some
(
Mut
:
:
new
(
&
mut
unerased
.
_object
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
{
None
}
}
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
fn
no_backtrace
(
e
:
Ref
<
ErrorImpl
>
)
-
>
Option
<
&
Backtrace
>
{
let
_
=
e
;
None
}
#
[
cfg
(
feature
=
"
std
"
)
]
unsafe
fn
context_downcast
<
C
E
>
(
e
:
Ref
<
ErrorImpl
>
target
:
TypeId
)
-
>
Option
<
Ref
<
(
)
>
>
where
C
:
'
static
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
E
>
>
>
(
)
.
deref
(
)
;
Some
(
Ref
:
:
new
(
&
unerased
.
_object
.
context
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
if
TypeId
:
:
of
:
:
<
E
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
E
>
>
>
(
)
.
deref
(
)
;
Some
(
Ref
:
:
new
(
&
unerased
.
_object
.
error
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
{
None
}
}
#
[
cfg
(
all
(
feature
=
"
std
"
anyhow_no_ptr_addr_of
)
)
]
unsafe
fn
context_downcast_mut
<
C
E
>
(
e
:
Mut
<
ErrorImpl
>
target
:
TypeId
)
-
>
Option
<
Mut
<
(
)
>
>
where
C
:
'
static
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
E
>
>
>
(
)
.
deref_mut
(
)
;
Some
(
Mut
:
:
new
(
&
mut
unerased
.
_object
.
context
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
if
TypeId
:
:
of
:
:
<
E
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
E
>
>
>
(
)
.
deref_mut
(
)
;
Some
(
Mut
:
:
new
(
&
mut
unerased
.
_object
.
error
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
{
None
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
unsafe
fn
context_drop_rest
<
C
E
>
(
e
:
Own
<
ErrorImpl
>
target
:
TypeId
)
where
C
:
'
static
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
ManuallyDrop
<
C
>
E
>
>
>
(
)
.
boxed
(
)
;
drop
(
unerased
)
;
}
else
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
ManuallyDrop
<
E
>
>
>
>
(
)
.
boxed
(
)
;
drop
(
unerased
)
;
}
}
unsafe
fn
context_chain_downcast
<
C
>
(
e
:
Ref
<
ErrorImpl
>
target
:
TypeId
)
-
>
Option
<
Ref
<
(
)
>
>
where
C
:
'
static
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
Error
>
>
>
(
)
.
deref
(
)
;
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
Some
(
Ref
:
:
new
(
&
unerased
.
_object
.
context
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
{
let
source
=
&
unerased
.
_object
.
error
;
(
vtable
(
source
.
inner
.
ptr
)
.
object_downcast
)
(
source
.
inner
.
by_ref
(
)
target
)
}
}
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
unsafe
fn
context_chain_downcast_mut
<
C
>
(
e
:
Mut
<
ErrorImpl
>
target
:
TypeId
)
-
>
Option
<
Mut
<
(
)
>
>
where
C
:
'
static
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
Error
>
>
>
(
)
.
deref_mut
(
)
;
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
Some
(
Mut
:
:
new
(
&
mut
unerased
.
_object
.
context
)
.
cast
:
:
<
(
)
>
(
)
)
}
else
{
let
source
=
&
mut
unerased
.
_object
.
error
;
(
vtable
(
source
.
inner
.
ptr
)
.
object_downcast_mut
)
(
source
.
inner
.
by_mut
(
)
target
)
}
}
unsafe
fn
context_chain_drop_rest
<
C
>
(
e
:
Own
<
ErrorImpl
>
target
:
TypeId
)
where
C
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
ManuallyDrop
<
C
>
Error
>
>
>
(
)
.
boxed
(
)
;
drop
(
unerased
)
;
}
else
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
ManuallyDrop
<
Error
>
>
>
>
(
)
.
boxed
(
)
;
let
inner
=
unerased
.
_object
.
error
.
inner
;
drop
(
unerased
)
;
let
vtable
=
vtable
(
inner
.
ptr
)
;
(
vtable
.
object_drop_rest
)
(
inner
target
)
;
}
}
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
#
[
allow
(
clippy
:
:
unnecessary_wraps
)
]
unsafe
fn
context_backtrace
<
C
>
(
e
:
Ref
<
ErrorImpl
>
)
-
>
Option
<
&
Backtrace
>
where
C
:
'
static
{
let
unerased
=
e
.
cast
:
:
<
ErrorImpl
<
ContextError
<
C
Error
>
>
>
(
)
.
deref
(
)
;
let
backtrace
=
ErrorImpl
:
:
backtrace
(
unerased
.
_object
.
error
.
inner
.
by_ref
(
)
)
;
Some
(
backtrace
)
}
#
[
repr
(
C
)
]
pub
(
crate
)
struct
ErrorImpl
<
E
=
(
)
>
{
vtable
:
&
'
static
ErrorVTable
backtrace
:
Option
<
Backtrace
>
_object
:
E
}
unsafe
fn
vtable
(
p
:
NonNull
<
ErrorImpl
>
)
-
>
&
'
static
ErrorVTable
{
*
(
p
.
as_ptr
(
)
as
*
const
&
'
static
ErrorVTable
)
}
#
[
repr
(
C
)
]
pub
(
crate
)
struct
ContextError
<
C
E
>
{
pub
context
:
C
pub
error
:
E
}
impl
<
E
>
ErrorImpl
<
E
>
{
fn
erase
(
&
self
)
-
>
Ref
<
ErrorImpl
>
{
Ref
:
:
new
(
self
)
.
cast
:
:
<
ErrorImpl
>
(
)
}
}
impl
ErrorImpl
{
pub
(
crate
)
unsafe
fn
error
(
this
:
Ref
<
Self
>
)
-
>
&
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
{
(
vtable
(
this
.
ptr
)
.
object_ref
)
(
this
)
.
deref
(
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
(
crate
)
unsafe
fn
error_mut
(
this
:
Mut
<
Self
>
)
-
>
&
mut
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
{
#
[
cfg
(
not
(
anyhow_no_ptr_addr_of
)
)
]
return
(
vtable
(
this
.
ptr
)
.
object_ref
)
(
this
.
by_ref
(
)
)
.
by_mut
(
)
.
deref_mut
(
)
;
#
[
cfg
(
anyhow_no_ptr_addr_of
)
]
return
(
vtable
(
this
.
ptr
)
.
object_mut
)
(
this
)
;
}
#
[
cfg
(
any
(
backtrace
feature
=
"
backtrace
"
)
)
]
pub
(
crate
)
unsafe
fn
backtrace
(
this
:
Ref
<
Self
>
)
-
>
&
Backtrace
{
this
.
deref
(
)
.
backtrace
.
as_ref
(
)
.
or_else
(
|
|
{
#
[
cfg
(
backtrace
)
]
return
Self
:
:
error
(
this
)
.
backtrace
(
)
;
#
[
cfg
(
all
(
not
(
backtrace
)
feature
=
"
backtrace
"
)
)
]
return
(
vtable
(
this
.
ptr
)
.
object_backtrace
)
(
this
)
;
}
)
.
expect
(
"
backtrace
capture
failed
"
)
}
#
[
cold
]
pub
(
crate
)
unsafe
fn
chain
(
this
:
Ref
<
Self
>
)
-
>
Chain
{
Chain
:
:
new
(
Self
:
:
error
(
this
)
)
}
}
impl
<
E
>
StdError
for
ErrorImpl
<
E
>
where
E
:
StdError
{
#
[
cfg
(
backtrace
)
]
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
{
Some
(
unsafe
{
ErrorImpl
:
:
backtrace
(
self
.
erase
(
)
)
}
)
}
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
StdError
+
'
static
)
>
{
unsafe
{
ErrorImpl
:
:
error
(
self
.
erase
(
)
)
.
source
(
)
}
}
}
impl
<
E
>
Debug
for
ErrorImpl
<
E
>
where
E
:
Debug
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
unsafe
{
ErrorImpl
:
:
debug
(
self
.
erase
(
)
formatter
)
}
}
}
impl
<
E
>
Display
for
ErrorImpl
<
E
>
where
E
:
Display
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
unsafe
{
Display
:
:
fmt
(
ErrorImpl
:
:
error
(
self
.
erase
(
)
)
formatter
)
}
}
}
impl
From
<
Error
>
for
Box
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
{
#
[
cold
]
fn
from
(
error
:
Error
)
-
>
Self
{
let
outer
=
ManuallyDrop
:
:
new
(
error
)
;
unsafe
{
(
vtable
(
outer
.
inner
.
ptr
)
.
object_boxed
)
(
outer
.
inner
)
}
}
}
impl
From
<
Error
>
for
Box
<
dyn
StdError
+
Send
+
'
static
>
{
fn
from
(
error
:
Error
)
-
>
Self
{
Box
:
:
<
dyn
StdError
+
Send
+
Sync
>
:
:
from
(
error
)
}
}
impl
From
<
Error
>
for
Box
<
dyn
StdError
+
'
static
>
{
fn
from
(
error
:
Error
)
-
>
Self
{
Box
:
:
<
dyn
StdError
+
Send
+
Sync
>
:
:
from
(
error
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
AsRef
<
dyn
StdError
+
Send
+
Sync
>
for
Error
{
fn
as_ref
(
&
self
)
-
>
&
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
{
&
*
*
self
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
AsRef
<
dyn
StdError
>
for
Error
{
fn
as_ref
(
&
self
)
-
>
&
(
dyn
StdError
+
'
static
)
{
&
*
*
self
}
}
