use
crate
:
:
alloc
:
:
Box
;
use
crate
:
:
backtrace
:
:
Backtrace
;
use
crate
:
:
chain
:
:
Chain
;
use
crate
:
:
{
Error
StdError
}
;
use
core
:
:
any
:
:
TypeId
;
use
core
:
:
fmt
:
:
{
self
Debug
Display
}
;
use
core
:
:
mem
:
:
{
self
ManuallyDrop
}
;
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
core
:
:
ops
:
:
{
Deref
DerefMut
}
;
impl
Error
{
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
pub
fn
new
<
E
>
(
error
:
E
)
-
>
Self
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
backtrace
=
backtrace_if_absent
!
(
error
)
;
Error
:
:
from_std
(
error
backtrace
)
}
pub
fn
msg
<
M
>
(
message
:
M
)
-
>
Self
where
M
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
Error
:
:
from_adhoc
(
message
backtrace
!
(
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
(
crate
)
fn
from_std
<
E
>
(
error
:
E
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
E
>
object_ref
:
object_ref
:
:
<
E
>
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
object_mut
:
:
<
E
>
object_boxed
:
object_boxed
:
:
<
E
>
object_downcast
:
object_downcast
:
:
<
E
>
object_drop_rest
:
object_drop_front
:
:
<
E
>
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
pub
(
crate
)
fn
from_adhoc
<
M
>
(
message
:
M
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
M
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
use
crate
:
:
wrapper
:
:
MessageError
;
let
error
:
MessageError
<
M
>
=
MessageError
(
message
)
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
MessageError
<
M
>
>
object_ref
:
object_ref
:
:
<
MessageError
<
M
>
>
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
object_mut
:
:
<
MessageError
<
M
>
>
object_boxed
:
object_boxed
:
:
<
MessageError
<
M
>
>
object_downcast
:
object_downcast
:
:
<
M
>
object_drop_rest
:
object_drop_front
:
:
<
M
>
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
pub
(
crate
)
fn
from_display
<
M
>
(
message
:
M
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
M
:
Display
+
Send
+
Sync
+
'
static
{
use
crate
:
:
wrapper
:
:
DisplayError
;
let
error
:
DisplayError
<
M
>
=
DisplayError
(
message
)
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
DisplayError
<
M
>
>
object_ref
:
object_ref
:
:
<
DisplayError
<
M
>
>
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
object_mut
:
:
<
DisplayError
<
M
>
>
object_boxed
:
object_boxed
:
:
<
DisplayError
<
M
>
>
object_downcast
:
object_downcast
:
:
<
M
>
object_drop_rest
:
object_drop_front
:
:
<
M
>
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
(
crate
)
fn
from_context
<
C
E
>
(
context
:
C
error
:
E
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
C
:
Display
+
Send
+
Sync
+
'
static
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
error
:
ContextError
<
C
E
>
=
ContextError
{
context
error
}
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
ContextError
<
C
E
>
>
object_ref
:
object_ref
:
:
<
ContextError
<
C
E
>
>
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
object_mut
:
:
<
ContextError
<
C
E
>
>
object_boxed
:
object_boxed
:
:
<
ContextError
<
C
E
>
>
object_downcast
:
context_downcast
:
:
<
C
E
>
object_drop_rest
:
context_drop_rest
:
:
<
C
E
>
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
(
crate
)
fn
from_boxed
(
error
:
Box
<
dyn
StdError
+
Send
+
Sync
>
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
{
use
crate
:
:
wrapper
:
:
BoxedError
;
let
error
=
BoxedError
(
error
)
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
BoxedError
>
object_ref
:
object_ref
:
:
<
BoxedError
>
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
object_mut
:
:
<
BoxedError
>
object_boxed
:
object_boxed
:
:
<
BoxedError
>
object_downcast
:
object_downcast
:
:
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
object_drop_rest
:
object_drop_front
:
:
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
}
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
unsafe
fn
construct
<
E
>
(
error
:
E
vtable
:
&
'
static
ErrorVTable
backtrace
:
Option
<
Backtrace
>
)
-
>
Self
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
let
inner
=
Box
:
:
new
(
ErrorImpl
{
vtable
backtrace
_object
:
error
}
)
;
let
erased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
E
>
>
Box
<
ErrorImpl
<
(
)
>
>
>
(
inner
)
;
let
inner
=
ManuallyDrop
:
:
new
(
erased
)
;
Error
{
inner
}
}
pub
fn
context
<
C
>
(
self
context
:
C
)
-
>
Self
where
C
:
Display
+
Send
+
Sync
+
'
static
{
let
error
:
ContextError
<
C
Error
>
=
ContextError
{
context
error
:
self
}
;
let
vtable
=
&
ErrorVTable
{
object_drop
:
object_drop
:
:
<
ContextError
<
C
Error
>
>
object_ref
:
object_ref
:
:
<
ContextError
<
C
Error
>
>
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
object_mut
:
:
<
ContextError
<
C
Error
>
>
object_boxed
:
object_boxed
:
:
<
ContextError
<
C
Error
>
>
object_downcast
:
context_chain_downcast
:
:
<
C
>
object_drop_rest
:
context_chain_drop_rest
:
:
<
C
>
}
;
let
backtrace
=
None
;
unsafe
{
Error
:
:
construct
(
error
vtable
backtrace
)
}
}
#
[
cfg
(
backtrace
)
]
pub
fn
backtrace
(
&
self
)
-
>
&
Backtrace
{
self
.
inner
.
backtrace
(
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
chain
(
&
self
)
-
>
Chain
{
self
.
inner
.
chain
(
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
root_cause
(
&
self
)
-
>
&
(
dyn
StdError
+
'
static
)
{
let
mut
chain
=
self
.
chain
(
)
;
let
mut
root_cause
=
chain
.
next
(
)
.
unwrap
(
)
;
for
cause
in
chain
{
root_cause
=
cause
;
}
root_cause
}
pub
fn
is
<
E
>
(
&
self
)
-
>
bool
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
self
.
downcast_ref
:
:
<
E
>
(
)
.
is_some
(
)
}
pub
fn
downcast
<
E
>
(
self
)
-
>
Result
<
E
Self
>
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
let
target
=
TypeId
:
:
of
:
:
<
E
>
(
)
;
unsafe
{
let
addr
=
match
(
self
.
inner
.
vtable
.
object_downcast
)
(
&
self
.
inner
target
)
{
Some
(
addr
)
=
>
addr
None
=
>
return
Err
(
self
)
}
;
let
outer
=
ManuallyDrop
:
:
new
(
self
)
;
let
error
=
ptr
:
:
read
(
addr
.
cast
:
:
<
E
>
(
)
.
as_ptr
(
)
)
;
let
inner
=
ptr
:
:
read
(
&
outer
.
inner
)
;
let
erased
=
ManuallyDrop
:
:
into_inner
(
inner
)
;
(
erased
.
vtable
.
object_drop_rest
)
(
erased
target
)
;
Ok
(
error
)
}
}
pub
fn
downcast_ref
<
E
>
(
&
self
)
-
>
Option
<
&
E
>
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
let
target
=
TypeId
:
:
of
:
:
<
E
>
(
)
;
unsafe
{
let
addr
=
(
self
.
inner
.
vtable
.
object_downcast
)
(
&
self
.
inner
target
)
?
;
Some
(
&
*
addr
.
cast
:
:
<
E
>
(
)
.
as_ptr
(
)
)
}
}
pub
fn
downcast_mut
<
E
>
(
&
mut
self
)
-
>
Option
<
&
mut
E
>
where
E
:
Display
+
Debug
+
Send
+
Sync
+
'
static
{
let
target
=
TypeId
:
:
of
:
:
<
E
>
(
)
;
unsafe
{
let
addr
=
(
self
.
inner
.
vtable
.
object_downcast
)
(
&
self
.
inner
target
)
?
;
Some
(
&
mut
*
addr
.
cast
:
:
<
E
>
(
)
.
as_ptr
(
)
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
E
>
From
<
E
>
for
Error
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
fn
from
(
error
:
E
)
-
>
Self
{
let
backtrace
=
backtrace_if_absent
!
(
error
)
;
Error
:
:
from_std
(
error
backtrace
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Deref
for
Error
{
type
Target
=
dyn
StdError
+
Send
+
Sync
+
'
static
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
self
.
inner
.
error
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
DerefMut
for
Error
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
self
.
inner
.
error_mut
(
)
}
}
impl
Display
for
Error
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
inner
.
display
(
formatter
)
}
}
impl
Debug
for
Error
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
inner
.
debug
(
formatter
)
}
}
impl
Drop
for
Error
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
inner
=
ptr
:
:
read
(
&
self
.
inner
)
;
let
erased
=
ManuallyDrop
:
:
into_inner
(
inner
)
;
(
erased
.
vtable
.
object_drop
)
(
erased
)
;
}
}
}
struct
ErrorVTable
{
object_drop
:
unsafe
fn
(
Box
<
ErrorImpl
<
(
)
>
>
)
object_ref
:
unsafe
fn
(
&
ErrorImpl
<
(
)
>
)
-
>
&
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
#
[
cfg
(
feature
=
"
std
"
)
]
object_mut
:
unsafe
fn
(
&
mut
ErrorImpl
<
(
)
>
)
-
>
&
mut
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
object_boxed
:
unsafe
fn
(
Box
<
ErrorImpl
<
(
)
>
>
)
-
>
Box
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
object_downcast
:
unsafe
fn
(
&
ErrorImpl
<
(
)
>
TypeId
)
-
>
Option
<
NonNull
<
(
)
>
>
object_drop_rest
:
unsafe
fn
(
Box
<
ErrorImpl
<
(
)
>
>
TypeId
)
}
unsafe
fn
object_drop
<
E
>
(
e
:
Box
<
ErrorImpl
<
(
)
>
>
)
{
let
unerased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
E
>
>
>
(
e
)
;
drop
(
unerased
)
;
}
unsafe
fn
object_drop_front
<
E
>
(
e
:
Box
<
ErrorImpl
<
(
)
>
>
target
:
TypeId
)
{
let
_
=
target
;
let
unerased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
ManuallyDrop
<
E
>
>
>
>
(
e
)
;
drop
(
unerased
)
;
}
unsafe
fn
object_ref
<
E
>
(
e
:
&
ErrorImpl
<
(
)
>
)
-
>
&
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
&
(
*
(
e
as
*
const
ErrorImpl
<
(
)
>
as
*
const
ErrorImpl
<
E
>
)
)
.
_object
}
#
[
cfg
(
feature
=
"
std
"
)
]
unsafe
fn
object_mut
<
E
>
(
e
:
&
mut
ErrorImpl
<
(
)
>
)
-
>
&
mut
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
&
mut
(
*
(
e
as
*
mut
ErrorImpl
<
(
)
>
as
*
mut
ErrorImpl
<
E
>
)
)
.
_object
}
unsafe
fn
object_boxed
<
E
>
(
e
:
Box
<
ErrorImpl
<
(
)
>
>
)
-
>
Box
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
where
E
:
StdError
+
Send
+
Sync
+
'
static
{
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
E
>
>
>
(
e
)
}
unsafe
fn
object_downcast
<
E
>
(
e
:
&
ErrorImpl
<
(
)
>
target
:
TypeId
)
-
>
Option
<
NonNull
<
(
)
>
>
where
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
E
>
(
)
=
=
target
{
let
unerased
=
e
as
*
const
ErrorImpl
<
(
)
>
as
*
const
ErrorImpl
<
E
>
;
let
addr
=
&
(
*
unerased
)
.
_object
as
*
const
E
as
*
mut
(
)
;
Some
(
NonNull
:
:
new_unchecked
(
addr
)
)
}
else
{
None
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
unsafe
fn
context_downcast
<
C
E
>
(
e
:
&
ErrorImpl
<
(
)
>
target
:
TypeId
)
-
>
Option
<
NonNull
<
(
)
>
>
where
C
:
'
static
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
e
as
*
const
ErrorImpl
<
(
)
>
as
*
const
ErrorImpl
<
ContextError
<
C
E
>
>
;
let
addr
=
&
(
*
unerased
)
.
_object
.
context
as
*
const
C
as
*
mut
(
)
;
Some
(
NonNull
:
:
new_unchecked
(
addr
)
)
}
else
if
TypeId
:
:
of
:
:
<
E
>
(
)
=
=
target
{
let
unerased
=
e
as
*
const
ErrorImpl
<
(
)
>
as
*
const
ErrorImpl
<
ContextError
<
C
E
>
>
;
let
addr
=
&
(
*
unerased
)
.
_object
.
error
as
*
const
E
as
*
mut
(
)
;
Some
(
NonNull
:
:
new_unchecked
(
addr
)
)
}
else
{
None
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
unsafe
fn
context_drop_rest
<
C
E
>
(
e
:
Box
<
ErrorImpl
<
(
)
>
>
target
:
TypeId
)
where
C
:
'
static
E
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
ContextError
<
ManuallyDrop
<
C
>
E
>
>
>
>
(
e
)
;
drop
(
unerased
)
;
}
else
{
let
unerased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
ContextError
<
C
ManuallyDrop
<
E
>
>
>
>
>
(
e
)
;
drop
(
unerased
)
;
}
}
unsafe
fn
context_chain_downcast
<
C
>
(
e
:
&
ErrorImpl
<
(
)
>
target
:
TypeId
)
-
>
Option
<
NonNull
<
(
)
>
>
where
C
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
e
as
*
const
ErrorImpl
<
(
)
>
as
*
const
ErrorImpl
<
ContextError
<
C
Error
>
>
;
let
addr
=
&
(
*
unerased
)
.
_object
.
context
as
*
const
C
as
*
mut
(
)
;
Some
(
NonNull
:
:
new_unchecked
(
addr
)
)
}
else
{
let
unerased
=
e
as
*
const
ErrorImpl
<
(
)
>
as
*
const
ErrorImpl
<
ContextError
<
C
Error
>
>
;
let
source
=
&
(
*
unerased
)
.
_object
.
error
;
(
source
.
inner
.
vtable
.
object_downcast
)
(
&
source
.
inner
target
)
}
}
unsafe
fn
context_chain_drop_rest
<
C
>
(
e
:
Box
<
ErrorImpl
<
(
)
>
>
target
:
TypeId
)
where
C
:
'
static
{
if
TypeId
:
:
of
:
:
<
C
>
(
)
=
=
target
{
let
unerased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
ContextError
<
ManuallyDrop
<
C
>
Error
>
>
>
>
(
e
)
;
drop
(
unerased
)
;
}
else
{
let
unerased
=
mem
:
:
transmute
:
:
<
Box
<
ErrorImpl
<
(
)
>
>
Box
<
ErrorImpl
<
ContextError
<
C
ManuallyDrop
<
Error
>
>
>
>
>
(
e
)
;
let
inner
=
ptr
:
:
read
(
&
unerased
.
_object
.
error
.
inner
)
;
drop
(
unerased
)
;
let
erased
=
ManuallyDrop
:
:
into_inner
(
inner
)
;
(
erased
.
vtable
.
object_drop_rest
)
(
erased
target
)
;
}
}
#
[
repr
(
C
)
]
pub
(
crate
)
struct
ErrorImpl
<
E
>
{
vtable
:
&
'
static
ErrorVTable
backtrace
:
Option
<
Backtrace
>
_object
:
E
}
#
[
repr
(
C
)
]
pub
(
crate
)
struct
ContextError
<
C
E
>
{
pub
context
:
C
pub
error
:
E
}
impl
<
E
>
ErrorImpl
<
E
>
{
fn
erase
(
&
self
)
-
>
&
ErrorImpl
<
(
)
>
{
unsafe
{
&
*
(
self
as
*
const
ErrorImpl
<
E
>
as
*
const
ErrorImpl
<
(
)
>
)
}
}
}
impl
ErrorImpl
<
(
)
>
{
pub
(
crate
)
fn
error
(
&
self
)
-
>
&
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
{
unsafe
{
&
*
(
self
.
vtable
.
object_ref
)
(
self
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
(
crate
)
fn
error_mut
(
&
mut
self
)
-
>
&
mut
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
{
unsafe
{
&
mut
*
(
self
.
vtable
.
object_mut
)
(
self
)
}
}
#
[
cfg
(
backtrace
)
]
pub
(
crate
)
fn
backtrace
(
&
self
)
-
>
&
Backtrace
{
self
.
backtrace
.
as_ref
(
)
.
or_else
(
|
|
self
.
error
(
)
.
backtrace
(
)
)
.
expect
(
"
backtrace
capture
failed
"
)
}
pub
(
crate
)
fn
chain
(
&
self
)
-
>
Chain
{
Chain
:
:
new
(
self
.
error
(
)
)
}
}
impl
<
E
>
StdError
for
ErrorImpl
<
E
>
where
E
:
StdError
{
#
[
cfg
(
backtrace
)
]
fn
backtrace
(
&
self
)
-
>
Option
<
&
Backtrace
>
{
Some
(
self
.
erase
(
)
.
backtrace
(
)
)
}
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
StdError
+
'
static
)
>
{
self
.
erase
(
)
.
error
(
)
.
source
(
)
}
}
impl
<
E
>
Debug
for
ErrorImpl
<
E
>
where
E
:
Debug
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
erase
(
)
.
debug
(
formatter
)
}
}
impl
<
E
>
Display
for
ErrorImpl
<
E
>
where
E
:
Display
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
erase
(
)
.
error
(
)
formatter
)
}
}
impl
From
<
Error
>
for
Box
<
dyn
StdError
+
Send
+
Sync
+
'
static
>
{
fn
from
(
error
:
Error
)
-
>
Self
{
let
outer
=
ManuallyDrop
:
:
new
(
error
)
;
unsafe
{
let
inner
=
ptr
:
:
read
(
&
outer
.
inner
)
;
let
erased
=
ManuallyDrop
:
:
into_inner
(
inner
)
;
(
erased
.
vtable
.
object_boxed
)
(
erased
)
}
}
}
impl
From
<
Error
>
for
Box
<
dyn
StdError
+
'
static
>
{
fn
from
(
error
:
Error
)
-
>
Self
{
Box
:
:
<
dyn
StdError
+
Send
+
Sync
>
:
:
from
(
error
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
AsRef
<
dyn
StdError
+
Send
+
Sync
>
for
Error
{
fn
as_ref
(
&
self
)
-
>
&
(
dyn
StdError
+
Send
+
Sync
+
'
static
)
{
&
*
*
self
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
AsRef
<
dyn
StdError
>
for
Error
{
fn
as_ref
(
&
self
)
-
>
&
(
dyn
StdError
+
'
static
)
{
&
*
*
self
}
}
