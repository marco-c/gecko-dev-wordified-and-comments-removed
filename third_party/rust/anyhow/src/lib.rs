#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
anyhow
/
1
.
0
.
62
"
)
]
#
!
[
cfg_attr
(
backtrace
feature
(
backtrace
)
)
]
#
!
[
cfg_attr
(
doc_cfg
feature
(
doc_cfg
)
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
deny
(
dead_code
unused_imports
unused_mut
)
]
#
!
[
allow
(
clippy
:
:
doc_markdown
clippy
:
:
enum_glob_use
clippy
:
:
explicit_auto_deref
clippy
:
:
missing_errors_doc
clippy
:
:
missing_panics_doc
clippy
:
:
module_name_repetitions
clippy
:
:
must_use_candidate
clippy
:
:
needless_doctest_main
clippy
:
:
new_ret_no_self
clippy
:
:
redundant_else
clippy
:
:
return_self_not_must_use
clippy
:
:
unused_self
clippy
:
:
used_underscore_binding
clippy
:
:
wildcard_imports
clippy
:
:
wrong_self_convention
)
]
extern
crate
alloc
;
#
[
macro_use
]
mod
backtrace
;
mod
chain
;
mod
context
;
mod
ensure
;
mod
error
;
mod
fmt
;
mod
kind
;
mod
macros
;
mod
ptr
;
mod
wrapper
;
use
crate
:
:
error
:
:
ErrorImpl
;
use
crate
:
:
ptr
:
:
Own
;
use
core
:
:
fmt
:
:
Display
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
core
:
:
fmt
:
:
Debug
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
error
:
:
Error
as
StdError
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
trait
StdError
:
Debug
+
Display
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
StdError
+
'
static
)
>
{
None
}
}
pub
use
anyhow
as
format_err
;
#
[
repr
(
transparent
)
]
pub
struct
Error
{
inner
:
Own
<
ErrorImpl
>
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
#
[
derive
(
Clone
)
]
pub
struct
Chain
<
'
a
>
{
state
:
crate
:
:
chain
:
:
ChainState
<
'
a
>
}
pub
type
Result
<
T
E
=
Error
>
=
core
:
:
result
:
:
Result
<
T
E
>
;
pub
trait
Context
<
T
E
>
:
context
:
:
private
:
:
Sealed
{
fn
context
<
C
>
(
self
context
:
C
)
-
>
Result
<
T
Error
>
where
C
:
Display
+
Send
+
Sync
+
'
static
;
fn
with_context
<
C
F
>
(
self
f
:
F
)
-
>
Result
<
T
Error
>
where
C
:
Display
+
Send
+
Sync
+
'
static
F
:
FnOnce
(
)
-
>
C
;
}
#
[
allow
(
non_snake_case
)
]
pub
fn
Ok
<
T
>
(
t
:
T
)
-
>
Result
<
T
>
{
Result
:
:
Ok
(
t
)
}
#
[
doc
(
hidden
)
]
pub
mod
__private
{
use
crate
:
:
Error
;
use
alloc
:
:
fmt
;
use
core
:
:
fmt
:
:
Arguments
;
pub
use
crate
:
:
ensure
:
:
{
BothDebug
NotBothDebug
}
;
pub
use
alloc
:
:
format
;
pub
use
core
:
:
result
:
:
Result
:
:
Err
;
pub
use
core
:
:
{
concat
format_args
stringify
}
;
#
[
doc
(
hidden
)
]
pub
mod
kind
{
pub
use
crate
:
:
kind
:
:
{
AdhocKind
TraitKind
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
crate
:
:
kind
:
:
BoxedKind
;
}
#
[
doc
(
hidden
)
]
#
[
inline
]
#
[
cold
]
pub
fn
format_err
(
args
:
Arguments
)
-
>
Error
{
#
[
cfg
(
anyhow_no_fmt_arguments_as_str
)
]
let
fmt_arguments_as_str
=
None
:
:
<
&
str
>
;
#
[
cfg
(
not
(
anyhow_no_fmt_arguments_as_str
)
)
]
let
fmt_arguments_as_str
=
args
.
as_str
(
)
;
if
let
Some
(
message
)
=
fmt_arguments_as_str
{
Error
:
:
msg
(
message
)
}
else
{
Error
:
:
msg
(
fmt
:
:
format
(
args
)
)
}
}
#
[
doc
(
hidden
)
]
#
[
inline
]
#
[
cold
]
#
[
must_use
]
pub
fn
must_use
(
error
:
Error
)
-
>
Error
{
error
}
}
