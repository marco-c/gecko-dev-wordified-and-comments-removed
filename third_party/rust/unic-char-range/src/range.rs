use
core
:
:
{
char
cmp
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
collections
:
:
Bound
;
use
self
:
:
cmp
:
:
Ordering
;
use
crate
:
:
CharIter
;
#
[
derive
(
Copy
Clone
Debug
Eq
)
]
pub
struct
CharRange
{
pub
low
:
char
pub
high
:
char
}
impl
CharRange
{
pub
fn
closed
(
start
:
char
stop
:
char
)
-
>
CharRange
{
CharRange
{
low
:
start
high
:
stop
}
}
pub
fn
open_right
(
start
:
char
stop
:
char
)
-
>
CharRange
{
let
mut
iter
=
CharRange
:
:
closed
(
start
stop
)
.
iter
(
)
;
let
_
=
iter
.
next_back
(
)
;
iter
.
into
(
)
}
pub
fn
open_left
(
start
:
char
stop
:
char
)
-
>
CharRange
{
let
mut
iter
=
CharRange
:
:
closed
(
start
stop
)
.
iter
(
)
;
let
_
=
iter
.
next
(
)
;
iter
.
into
(
)
}
pub
fn
open
(
start
:
char
stop
:
char
)
-
>
CharRange
{
let
mut
iter
=
CharRange
:
:
closed
(
start
stop
)
.
iter
(
)
;
let
_
=
iter
.
next
(
)
;
let
_
=
iter
.
next_back
(
)
;
iter
.
into
(
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
bound
(
start
:
Bound
<
char
>
stop
:
Bound
<
char
>
)
-
>
CharRange
{
let
start
=
if
start
=
=
Bound
:
:
Unbounded
{
Bound
:
:
Included
(
'
\
u
{
0
}
'
)
}
else
{
start
}
;
let
stop
=
if
stop
=
=
Bound
:
:
Unbounded
{
Bound
:
:
Included
(
char
:
:
MAX
)
}
else
{
stop
}
;
match
(
start
stop
)
{
(
Bound
:
:
Included
(
start
)
Bound
:
:
Included
(
stop
)
)
=
>
CharRange
:
:
closed
(
start
stop
)
(
Bound
:
:
Excluded
(
start
)
Bound
:
:
Excluded
(
stop
)
)
=
>
CharRange
:
:
open
(
start
stop
)
(
Bound
:
:
Included
(
start
)
Bound
:
:
Excluded
(
stop
)
)
=
>
CharRange
:
:
open_right
(
start
stop
)
(
Bound
:
:
Excluded
(
start
)
Bound
:
:
Included
(
stop
)
)
=
>
CharRange
:
:
open_left
(
start
stop
)
(
Bound
:
:
Unbounded
_
)
|
(
_
Bound
:
:
Unbounded
)
=
>
unreachable
!
(
)
}
}
pub
fn
all
(
)
-
>
CharRange
{
CharRange
:
:
closed
(
'
\
u
{
0
}
'
char
:
:
MAX
)
}
pub
fn
assigned_normal_planes
(
)
-
>
CharRange
{
CharRange
:
:
closed
(
'
\
u
{
0
}
'
'
\
u
{
2_FFFF
}
'
)
}
}
/
/
/
Collection
-
like
fns
impl
CharRange
{
/
/
/
Does
this
range
include
a
character
?
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
#
use
unic_char_range
:
:
CharRange
;
/
/
/
assert
!
(
CharRange
:
:
closed
(
'
a
'
'
g
'
)
.
contains
(
'
d
'
)
)
;
/
/
/
assert
!
(
!
CharRange
:
:
closed
(
'
a
'
'
g
'
)
.
contains
(
'
z
'
)
)
;
/
/
/
/
/
/
assert
!
(
!
CharRange
:
:
open
(
'
a
'
'
a
'
)
.
contains
(
'
a
'
)
)
;
/
/
/
assert
!
(
!
CharRange
:
:
closed
(
'
z
'
'
a
'
)
.
contains
(
'
g
'
)
)
;
/
/
/
pub
fn
contains
(
&
self
ch
:
char
)
-
>
bool
{
self
.
low
<
=
ch
&
&
ch
<
=
self
.
high
}
/
/
/
Determine
the
ordering
of
this
range
and
a
character
.
/
/
/
/
/
/
#
Panics
/
/
/
/
/
/
Panics
if
the
range
is
empty
.
This
fn
may
be
adjusted
in
the
future
to
not
panic
/
/
/
in
optimized
builds
.
Even
if
so
an
empty
range
will
never
compare
as
Ordering
:
:
Equal
.
pub
fn
cmp_char
(
&
self
ch
:
char
)
-
>
Ordering
{
/
/
possible
optimization
:
only
assert
this
in
debug
builds
assert
!
(
!
self
.
is_empty
(
)
"
Cannot
compare
empty
range
'
s
ordering
"
)
;
if
self
.
high
<
ch
{
Ordering
:
:
Less
}
else
if
self
.
low
>
ch
{
Ordering
:
:
Greater
}
else
{
Ordering
:
:
Equal
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
(
)
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
low
>
self
.
high
}
pub
fn
iter
(
&
self
)
-
>
CharIter
{
(
*
self
)
.
into
(
)
}
}
impl
IntoIterator
for
CharRange
{
type
IntoIter
=
CharIter
;
type
Item
=
char
;
fn
into_iter
(
self
)
-
>
CharIter
{
self
.
iter
(
)
}
}
impl
PartialEq
<
CharRange
>
for
CharRange
{
fn
eq
(
&
self
other
:
&
CharRange
)
-
>
bool
{
(
self
.
is_empty
(
)
&
&
other
.
is_empty
(
)
)
|
|
(
self
.
low
=
=
other
.
low
&
&
self
.
high
=
=
other
.
high
)
}
}
