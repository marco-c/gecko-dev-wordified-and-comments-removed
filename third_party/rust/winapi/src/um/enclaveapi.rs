use
shared
:
:
basetsd
:
:
{
PSIZE_T
SIZE_T
}
;
use
shared
:
:
minwindef
:
:
{
BOOL
DWORD
LPCVOID
LPDWORD
LPVOID
}
;
use
shared
:
:
ntdef
:
:
{
HANDLE
}
;
use
um
:
:
minwinbase
:
:
LPENCLAVE_ROUTINE
;
use
um
:
:
winnt
:
:
{
LPCSTR
LPCWSTR
}
;
extern
"
system
"
{
pub
fn
IsEnclaveTypeSupported
(
flEnclaveType
:
DWORD
)
-
>
BOOL
;
pub
fn
CreateEnclave
(
hProcess
:
HANDLE
lpAddress
:
LPVOID
dwSize
:
SIZE_T
dwInitialCommitment
:
SIZE_T
flEnclaveType
:
DWORD
lpEnclaveInformation
:
LPCVOID
dwInfoLength
:
DWORD
lpEnclaveError
:
LPDWORD
)
-
>
LPVOID
;
pub
fn
LoadEnclaveData
(
hProcess
:
HANDLE
lpAddress
:
LPVOID
lpBuffer
:
LPCVOID
nSize
:
SIZE_T
flProtect
:
DWORD
lpPageInformation
:
LPCVOID
dwInfoLength
:
DWORD
lpNumberOfBytesWritten
:
PSIZE_T
lpEnclaveError
:
LPDWORD
)
-
>
BOOL
;
pub
fn
InitializeEnclave
(
hProcess
:
HANDLE
lpAddress
:
LPVOID
lpEnclaveInformation
:
LPCVOID
dwInfoLength
:
DWORD
lpEnclaveError
:
LPDWORD
)
-
>
BOOL
;
pub
fn
LoadEnclaveImageA
(
lpEnclaveAddress
:
LPVOID
lpImageName
:
LPCSTR
)
-
>
BOOL
;
pub
fn
LoadEnclaveImageW
(
lpEnclaveAddress
:
LPVOID
lpImageName
:
LPCWSTR
)
-
>
BOOL
;
pub
fn
CallEnclave
(
lpRoutine
:
LPENCLAVE_ROUTINE
lpParameter
:
LPVOID
fWaitForThread
:
BOOL
lpReturnValue
:
*
mut
LPVOID
)
-
>
BOOL
;
pub
fn
TerminateEnclave
(
lpAddress
:
LPVOID
fWait
:
BOOL
)
-
>
BOOL
;
pub
fn
DeleteEnclave
(
lpAddress
:
LPVOID
)
-
>
BOOL
;
}
