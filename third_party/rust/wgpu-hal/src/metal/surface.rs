#
!
[
allow
(
clippy
:
:
let_unit_value
)
]
use
std
:
:
ffi
:
:
c_uint
;
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
sync
:
:
Once
;
use
std
:
:
thread
;
use
core_graphics_types
:
:
{
base
:
:
CGFloat
geometry
:
:
{
CGRect
CGSize
}
}
;
use
metal
:
:
foreign_types
:
:
ForeignType
;
use
objc
:
:
{
class
declare
:
:
ClassDecl
msg_send
rc
:
:
{
autoreleasepool
StrongPtr
}
runtime
:
:
{
Class
Object
Sel
BOOL
NO
YES
}
sel
sel_impl
}
;
use
parking_lot
:
:
{
Mutex
RwLock
}
;
#
[
link
(
name
=
"
QuartzCore
"
kind
=
"
framework
"
)
]
extern
"
C
"
{
#
[
allow
(
non_upper_case_globals
)
]
static
kCAGravityResize
:
*
mut
Object
;
}
extern
"
C
"
fn
layer_should_inherit_contents_scale_from_window
(
_
:
&
Class
_
:
Sel
_layer
:
*
mut
Object
_new_scale
:
CGFloat
_from_window
:
*
mut
Object
)
-
>
BOOL
{
YES
}
static
CAML_DELEGATE_REGISTER
:
Once
=
Once
:
:
new
(
)
;
#
[
derive
(
Debug
)
]
pub
struct
HalManagedMetalLayerDelegate
(
&
'
static
Class
)
;
impl
HalManagedMetalLayerDelegate
{
pub
fn
new
(
)
-
>
Self
{
let
class_name
=
format
!
(
"
HalManagedMetalLayerDelegate
{
:
p
}
"
&
CAML_DELEGATE_REGISTER
)
;
CAML_DELEGATE_REGISTER
.
call_once
(
|
|
{
type
Fun
=
extern
"
C
"
fn
(
&
Class
Sel
*
mut
Object
CGFloat
*
mut
Object
)
-
>
BOOL
;
let
mut
decl
=
ClassDecl
:
:
new
(
&
class_name
class
!
(
NSObject
)
)
.
unwrap
(
)
;
unsafe
{
decl
.
add_class_method
:
:
<
Fun
>
(
sel
!
(
layer
:
shouldInheritContentsScale
:
fromWindow
:
)
layer_should_inherit_contents_scale_from_window
)
;
}
decl
.
register
(
)
;
}
)
;
Self
(
Class
:
:
get
(
&
class_name
)
.
unwrap
(
)
)
}
}
impl
super
:
:
Surface
{
fn
new
(
layer
:
metal
:
:
MetalLayer
)
-
>
Self
{
Self
{
render_layer
:
Mutex
:
:
new
(
layer
)
swapchain_format
:
RwLock
:
:
new
(
None
)
extent
:
RwLock
:
:
new
(
wgt
:
:
Extent3d
:
:
default
(
)
)
main_thread_id
:
thread
:
:
current
(
)
.
id
(
)
present_with_transaction
:
false
}
}
#
[
allow
(
clippy
:
:
transmute_ptr_to_ref
)
]
pub
unsafe
fn
from_view
(
view
:
NonNull
<
Object
>
)
-
>
Self
{
let
layer
=
unsafe
{
Self
:
:
get_metal_layer
(
view
)
}
;
let
layer
=
ManuallyDrop
:
:
new
(
layer
)
;
let
layer
=
unsafe
{
metal
:
:
MetalLayer
:
:
from_ptr
(
layer
.
cast
(
)
)
}
;
Self
:
:
new
(
layer
)
}
pub
unsafe
fn
from_layer
(
layer
:
&
metal
:
:
MetalLayerRef
)
-
>
Self
{
let
class
=
class
!
(
CAMetalLayer
)
;
let
proper_kind
:
BOOL
=
msg_send
!
[
layer
isKindOfClass
:
class
]
;
assert_eq
!
(
proper_kind
YES
)
;
Self
:
:
new
(
layer
.
to_owned
(
)
)
}
pub
(
crate
)
unsafe
fn
get_metal_layer
(
view
:
NonNull
<
Object
>
)
-
>
StrongPtr
{
let
is_main_thread
:
BOOL
=
msg_send
!
[
class
!
(
NSThread
)
isMainThread
]
;
if
is_main_thread
=
=
NO
{
panic
!
(
"
get_metal_layer
cannot
be
called
in
non
-
ui
thread
.
"
)
;
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
let
(
)
=
msg_send
!
[
view
.
as_ptr
(
)
setWantsLayer
:
YES
]
;
let
root_layer
:
*
mut
Object
=
msg_send
!
[
view
.
as_ptr
(
)
layer
]
;
assert
!
(
!
root_layer
.
is_null
(
)
"
failed
making
the
view
layer
-
backed
"
)
;
let
is_metal_layer
:
BOOL
=
msg_send
!
[
root_layer
isKindOfClass
:
class
!
(
CAMetalLayer
)
]
;
if
is_metal_layer
=
=
YES
{
unsafe
{
StrongPtr
:
:
retain
(
root_layer
)
}
}
else
{
let
new_layer
:
*
mut
Object
=
msg_send
!
[
class
!
(
CAMetalLayer
)
new
]
;
let
(
)
=
msg_send
!
[
root_layer
addSublayer
:
new_layer
]
;
let
width_sizable
=
1
<
<
1
;
let
height_sizable
=
1
<
<
4
;
let
mask
:
c_uint
=
width_sizable
|
height_sizable
;
let
(
)
=
msg_send
!
[
new_layer
setAutoresizingMask
:
mask
]
;
let
frame
:
CGRect
=
msg_send
!
[
root_layer
bounds
]
;
let
(
)
=
msg_send
!
[
new_layer
setFrame
:
frame
]
;
let
_
:
(
)
=
msg_send
!
[
new_layer
setContentsGravity
:
unsafe
{
kCAGravityResize
}
]
;
let
scale_factor
:
CGFloat
=
msg_send
!
[
root_layer
contentsScale
]
;
let
(
)
=
msg_send
!
[
new_layer
setContentsScale
:
scale_factor
]
;
let
delegate
=
HalManagedMetalLayerDelegate
:
:
new
(
)
;
let
(
)
=
msg_send
!
[
new_layer
setDelegate
:
delegate
.
0
]
;
unsafe
{
StrongPtr
:
:
new
(
new_layer
)
}
}
}
pub
(
super
)
fn
dimensions
(
&
self
)
-
>
wgt
:
:
Extent3d
{
let
(
size
scale
)
:
(
CGSize
CGFloat
)
=
unsafe
{
let
render_layer_borrow
=
self
.
render_layer
.
lock
(
)
;
let
render_layer
=
render_layer_borrow
.
as_ref
(
)
;
let
bounds
:
CGRect
=
msg_send
!
[
render_layer
bounds
]
;
let
contents_scale
:
CGFloat
=
msg_send
!
[
render_layer
contentsScale
]
;
(
bounds
.
size
contents_scale
)
}
;
wgt
:
:
Extent3d
{
width
:
(
size
.
width
*
scale
)
as
u32
height
:
(
size
.
height
*
scale
)
as
u32
depth_or_array_layers
:
1
}
}
}
impl
crate
:
:
Surface
for
super
:
:
Surface
{
type
A
=
super
:
:
Api
;
unsafe
fn
configure
(
&
self
device
:
&
super
:
:
Device
config
:
&
crate
:
:
SurfaceConfiguration
)
-
>
Result
<
(
)
crate
:
:
SurfaceError
>
{
log
:
:
debug
!
(
"
build
swapchain
{
:
?
}
"
config
)
;
let
caps
=
&
device
.
shared
.
private_caps
;
*
self
.
swapchain_format
.
write
(
)
=
Some
(
config
.
format
)
;
*
self
.
extent
.
write
(
)
=
config
.
extent
;
let
render_layer
=
self
.
render_layer
.
lock
(
)
;
let
framebuffer_only
=
config
.
usage
=
=
crate
:
:
TextureUses
:
:
COLOR_TARGET
;
let
display_sync
=
match
config
.
present_mode
{
wgt
:
:
PresentMode
:
:
Fifo
=
>
true
wgt
:
:
PresentMode
:
:
Immediate
=
>
false
m
=
>
unreachable
!
(
"
Unsupported
present
mode
:
{
m
:
?
}
"
)
}
;
let
drawable_size
=
CGSize
:
:
new
(
config
.
extent
.
width
as
f64
config
.
extent
.
height
as
f64
)
;
match
config
.
composite_alpha_mode
{
wgt
:
:
CompositeAlphaMode
:
:
Opaque
=
>
render_layer
.
set_opaque
(
true
)
wgt
:
:
CompositeAlphaMode
:
:
PostMultiplied
=
>
render_layer
.
set_opaque
(
false
)
_
=
>
(
)
}
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
{
let
superlayer
:
*
mut
Object
=
msg_send
!
[
render_layer
.
as_ptr
(
)
superlayer
]
;
if
!
superlayer
.
is_null
(
)
{
let
scale_factor
:
CGFloat
=
msg_send
!
[
superlayer
contentsScale
]
;
let
(
)
=
msg_send
!
[
render_layer
.
as_ptr
(
)
setContentsScale
:
scale_factor
]
;
}
}
let
device_raw
=
device
.
shared
.
device
.
lock
(
)
;
render_layer
.
set_device
(
&
device_raw
)
;
render_layer
.
set_pixel_format
(
caps
.
map_format
(
config
.
format
)
)
;
render_layer
.
set_framebuffer_only
(
framebuffer_only
)
;
render_layer
.
set_presents_with_transaction
(
self
.
present_with_transaction
)
;
let
wants_edr
=
config
.
format
=
=
wgt
:
:
TextureFormat
:
:
Rgba16Float
;
if
wants_edr
!
=
render_layer
.
wants_extended_dynamic_range_content
(
)
{
render_layer
.
set_wants_extended_dynamic_range_content
(
wants_edr
)
;
}
render_layer
.
set_maximum_drawable_count
(
config
.
maximum_frame_latency
as
u64
+
1
)
;
render_layer
.
set_drawable_size
(
drawable_size
)
;
if
caps
.
can_set_next_drawable_timeout
{
let
(
)
=
msg_send
!
[
*
render_layer
setAllowsNextDrawableTimeout
:
false
]
;
}
if
caps
.
can_set_display_sync
{
let
(
)
=
msg_send
!
[
*
render_layer
setDisplaySyncEnabled
:
display_sync
]
;
}
Ok
(
(
)
)
}
unsafe
fn
unconfigure
(
&
self
_device
:
&
super
:
:
Device
)
{
*
self
.
swapchain_format
.
write
(
)
=
None
;
}
unsafe
fn
acquire_texture
(
&
self
_timeout_ms
:
Option
<
std
:
:
time
:
:
Duration
>
_fence
:
&
super
:
:
Fence
)
-
>
Result
<
Option
<
crate
:
:
AcquiredSurfaceTexture
<
super
:
:
Api
>
>
crate
:
:
SurfaceError
>
{
let
render_layer
=
self
.
render_layer
.
lock
(
)
;
let
(
drawable
texture
)
=
match
autoreleasepool
(
|
|
{
render_layer
.
next_drawable
(
)
.
map
(
|
drawable
|
(
drawable
.
to_owned
(
)
drawable
.
texture
(
)
.
to_owned
(
)
)
)
}
)
{
Some
(
pair
)
=
>
pair
None
=
>
return
Ok
(
None
)
}
;
let
swapchain_format
=
self
.
swapchain_format
.
read
(
)
.
unwrap
(
)
;
let
extent
=
self
.
extent
.
read
(
)
;
let
suf_texture
=
super
:
:
SurfaceTexture
{
texture
:
super
:
:
Texture
{
raw
:
texture
format
:
swapchain_format
raw_type
:
metal
:
:
MTLTextureType
:
:
D2
array_layers
:
1
mip_levels
:
1
copy_size
:
crate
:
:
CopyExtent
{
width
:
extent
.
width
height
:
extent
.
height
depth
:
1
}
}
drawable
present_with_transaction
:
self
.
present_with_transaction
}
;
Ok
(
Some
(
crate
:
:
AcquiredSurfaceTexture
{
texture
:
suf_texture
suboptimal
:
false
}
)
)
}
unsafe
fn
discard_texture
(
&
self
_texture
:
super
:
:
SurfaceTexture
)
{
}
}
