use
alloc
:
:
vec
:
:
Vec
;
use
ash
:
:
vk
;
use
core
:
:
mem
:
:
MaybeUninit
;
#
[
derive
(
Debug
Default
)
]
pub
struct
SemaphoreList
{
semaphores
:
Vec
<
vk
:
:
Semaphore
>
values
:
Vec
<
u64
>
}
impl
SemaphoreList
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
semaphores
.
is_empty
(
)
}
pub
fn
add_to_submit
<
'
i
'
s
:
'
i
>
(
&
'
s
self
submit_info
:
vk
:
:
SubmitInfo
<
'
i
>
timeline_info
:
&
'
i
mut
MaybeUninit
<
vk
:
:
TimelineSemaphoreSubmitInfo
<
'
i
>
>
)
-
>
vk
:
:
SubmitInfo
<
'
i
>
{
self
.
check
(
)
;
let
mut
submit_info
=
submit_info
.
signal_semaphores
(
&
self
.
semaphores
)
;
if
!
self
.
values
.
is_empty
(
)
{
let
timeline_info
=
timeline_info
.
write
(
vk
:
:
TimelineSemaphoreSubmitInfo
:
:
default
(
)
.
signal_semaphore_values
(
&
self
.
values
)
)
;
submit_info
=
submit_info
.
push_next
(
timeline_info
)
;
}
submit_info
}
pub
fn
push_binary
(
&
mut
self
semaphore
:
vk
:
:
Semaphore
)
{
self
.
semaphores
.
push
(
semaphore
)
;
if
!
self
.
values
.
is_empty
(
)
{
self
.
values
.
push
(
!
0
)
;
}
self
.
check
(
)
;
}
pub
fn
push_timeline
(
&
mut
self
semaphore
:
vk
:
:
Semaphore
value
:
u64
)
{
self
.
pad_values
(
)
;
self
.
semaphores
.
push
(
semaphore
)
;
self
.
values
.
push
(
value
)
;
self
.
check
(
)
;
}
pub
fn
append
(
&
mut
self
other
:
&
mut
Self
)
{
if
!
other
.
values
.
is_empty
(
)
{
self
.
pad_values
(
)
;
}
self
.
semaphores
.
append
(
&
mut
other
.
semaphores
)
;
self
.
values
.
append
(
&
mut
other
.
values
)
;
if
!
self
.
values
.
is_empty
(
)
{
self
.
pad_values
(
)
;
}
self
.
check
(
)
;
}
fn
pad_values
(
&
mut
self
)
{
self
.
values
.
resize
(
self
.
semaphores
.
len
(
)
!
0
)
;
}
#
[
track_caller
]
fn
check
(
&
self
)
{
debug_assert
!
(
self
.
values
.
is_empty
(
)
|
|
self
.
values
.
len
(
)
=
=
self
.
semaphores
.
len
(
)
)
;
}
}
