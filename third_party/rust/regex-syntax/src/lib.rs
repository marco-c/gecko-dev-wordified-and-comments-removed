#
!
[
no_std
]
#
!
[
forbid
(
unsafe_code
)
]
#
!
[
deny
(
missing_docs
rustdoc
:
:
broken_intra_doc_links
)
]
#
!
[
warn
(
missing_debug_implementations
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_auto_cfg
)
)
]
#
[
cfg
(
any
(
test
feature
=
"
std
"
)
)
]
extern
crate
std
;
extern
crate
alloc
;
pub
use
crate
:
:
{
error
:
:
Error
parser
:
:
{
parse
Parser
ParserBuilder
}
unicode
:
:
UnicodeWordError
}
;
use
alloc
:
:
string
:
:
String
;
pub
mod
ast
;
mod
debug
;
mod
either
;
mod
error
;
pub
mod
hir
;
mod
parser
;
mod
rank
;
mod
unicode
;
mod
unicode_tables
;
pub
mod
utf8
;
pub
fn
escape
(
text
:
&
str
)
-
>
String
{
let
mut
quoted
=
String
:
:
new
(
)
;
escape_into
(
text
&
mut
quoted
)
;
quoted
}
pub
fn
escape_into
(
text
:
&
str
buf
:
&
mut
String
)
{
buf
.
reserve
(
text
.
len
(
)
)
;
for
c
in
text
.
chars
(
)
{
if
is_meta_character
(
c
)
{
buf
.
push
(
'
\
\
'
)
;
}
buf
.
push
(
c
)
;
}
}
pub
fn
is_meta_character
(
c
:
char
)
-
>
bool
{
match
c
{
'
\
\
'
|
'
.
'
|
'
+
'
|
'
*
'
|
'
?
'
|
'
(
'
|
'
)
'
|
'
|
'
|
'
[
'
|
'
]
'
|
'
{
'
|
'
}
'
|
'
^
'
|
'
'
|
'
#
'
|
'
&
'
|
'
-
'
|
'
~
'
=
>
true
_
=
>
false
}
}
pub
fn
is_escapeable_character
(
c
:
char
)
-
>
bool
{
if
is_meta_character
(
c
)
{
return
true
;
}
if
!
c
.
is_ascii
(
)
{
return
false
;
}
match
c
{
'
0
'
.
.
=
'
9
'
|
'
A
'
.
.
=
'
Z
'
|
'
a
'
.
.
=
'
z
'
=
>
false
'
<
'
|
'
>
'
=
>
false
_
=
>
true
}
}
pub
fn
is_word_character
(
c
:
char
)
-
>
bool
{
try_is_word_character
(
c
)
.
expect
(
"
unicode
-
perl
feature
must
be
enabled
"
)
}
pub
fn
try_is_word_character
(
c
:
char
)
-
>
core
:
:
result
:
:
Result
<
bool
UnicodeWordError
>
{
unicode
:
:
is_word_character
(
c
)
}
pub
fn
is_word_byte
(
c
:
u8
)
-
>
bool
{
match
c
{
b
'
_
'
|
b
'
0
'
.
.
=
b
'
9
'
|
b
'
a
'
.
.
=
b
'
z
'
|
b
'
A
'
.
.
=
b
'
Z
'
=
>
true
_
=
>
false
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
alloc
:
:
string
:
:
ToString
;
use
super
:
:
*
;
#
[
test
]
fn
escape_meta
(
)
{
assert_eq
!
(
escape
(
r
"
\
.
+
*
?
(
)
|
[
]
{
}
^
#
&
-
~
"
)
r
"
\
\
\
.
\
+
\
*
\
?
\
(
\
)
\
|
\
[
\
]
\
{
\
}
\
^
\
\
#
\
&
\
-
\
~
"
.
to_string
(
)
)
;
}
#
[
test
]
fn
word_byte
(
)
{
assert
!
(
is_word_byte
(
b
'
a
'
)
)
;
assert
!
(
!
is_word_byte
(
b
'
-
'
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
unicode
-
perl
"
)
]
fn
word_char
(
)
{
assert
!
(
is_word_character
(
'
a
'
)
"
ASCII
"
)
;
assert
!
(
is_word_character
(
'
'
)
"
Latin
-
1
"
)
;
assert
!
(
is_word_character
(
'
'
)
"
Greek
"
)
;
assert
!
(
is_word_character
(
'
\
u
{
11011
}
'
)
"
Brahmi
(
Unicode
6
.
0
)
"
)
;
assert
!
(
is_word_character
(
'
\
u
{
11611
}
'
)
"
Modi
(
Unicode
7
.
0
)
"
)
;
assert
!
(
is_word_character
(
'
\
u
{
11711
}
'
)
"
Ahom
(
Unicode
8
.
0
)
"
)
;
assert
!
(
is_word_character
(
'
\
u
{
17828
}
'
)
"
Tangut
(
Unicode
9
.
0
)
"
)
;
assert
!
(
is_word_character
(
'
\
u
{
1B1B1
}
'
)
"
Nushu
(
Unicode
10
.
0
)
"
)
;
assert
!
(
is_word_character
(
'
\
u
{
16E40
}
'
)
"
Medefaidrin
(
Unicode
11
.
0
)
"
)
;
assert
!
(
!
is_word_character
(
'
-
'
)
)
;
assert
!
(
!
is_word_character
(
'
'
)
)
;
}
#
[
test
]
#
[
should_panic
]
#
[
cfg
(
not
(
feature
=
"
unicode
-
perl
"
)
)
]
fn
word_char_disabled_panic
(
)
{
assert
!
(
is_word_character
(
'
a
'
)
)
;
}
#
[
test
]
#
[
cfg
(
not
(
feature
=
"
unicode
-
perl
"
)
)
]
fn
word_char_disabled_error
(
)
{
assert
!
(
try_is_word_character
(
'
a
'
)
.
is_err
(
)
)
;
}
}
