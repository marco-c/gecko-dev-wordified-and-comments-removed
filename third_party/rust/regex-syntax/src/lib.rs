#
!
[
deny
(
missing_docs
)
]
extern
crate
ucd_util
;
pub
use
error
:
:
{
Error
Result
}
;
pub
use
parser
:
:
{
Parser
ParserBuilder
}
;
pub
mod
ast
;
mod
either
;
mod
error
;
pub
mod
hir
;
mod
parser
;
mod
unicode
;
mod
unicode_tables
;
pub
fn
escape
(
text
:
&
str
)
-
>
String
{
let
mut
quoted
=
String
:
:
with_capacity
(
text
.
len
(
)
)
;
escape_into
(
text
&
mut
quoted
)
;
quoted
}
pub
fn
escape_into
(
text
:
&
str
buf
:
&
mut
String
)
{
for
c
in
text
.
chars
(
)
{
if
is_meta_character
(
c
)
{
buf
.
push
(
'
\
\
'
)
;
}
buf
.
push
(
c
)
;
}
}
pub
fn
is_meta_character
(
c
:
char
)
-
>
bool
{
match
c
{
'
\
\
'
|
'
.
'
|
'
+
'
|
'
*
'
|
'
?
'
|
'
(
'
|
'
)
'
|
'
|
'
|
'
[
'
|
'
]
'
|
'
{
'
|
'
}
'
|
'
^
'
|
'
'
|
'
#
'
|
'
&
'
|
'
-
'
|
'
~
'
=
>
true
_
=
>
false
}
}
pub
fn
is_word_character
(
c
:
char
)
-
>
bool
{
use
std
:
:
cmp
:
:
Ordering
;
use
unicode_tables
:
:
perl_word
:
:
PERL_WORD
;
if
c
<
=
0x7F
as
char
&
&
is_word_byte
(
c
as
u8
)
{
return
true
;
}
PERL_WORD
.
binary_search_by
(
|
&
(
start
end
)
|
{
if
start
<
=
c
&
&
c
<
=
end
{
Ordering
:
:
Equal
}
else
if
start
>
c
{
Ordering
:
:
Greater
}
else
{
Ordering
:
:
Less
}
}
)
.
is_ok
(
)
}
pub
fn
is_word_byte
(
c
:
u8
)
-
>
bool
{
match
c
{
b
'
_
'
|
b
'
0
'
.
.
.
b
'
9
'
|
b
'
a
'
.
.
.
b
'
z
'
|
b
'
A
'
.
.
.
b
'
Z
'
=
>
true
_
=
>
false
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
escape_meta
(
)
{
assert_eq
!
(
escape
(
r
"
\
.
+
*
?
(
)
|
[
]
{
}
^
#
&
-
~
"
)
r
"
\
\
\
.
\
+
\
*
\
?
\
(
\
)
\
|
\
[
\
]
\
{
\
}
\
^
\
\
#
\
&
\
-
\
~
"
.
to_string
(
)
)
;
}
#
[
test
]
fn
word
(
)
{
assert
!
(
is_word_byte
(
b
'
a
'
)
)
;
assert
!
(
!
is_word_byte
(
b
'
-
'
)
)
;
assert
!
(
is_word_character
(
'
a
'
)
)
;
assert
!
(
is_word_character
(
'
'
)
)
;
assert
!
(
!
is_word_character
(
'
-
'
)
)
;
assert
!
(
!
is_word_character
(
'
'
)
)
;
}
}
