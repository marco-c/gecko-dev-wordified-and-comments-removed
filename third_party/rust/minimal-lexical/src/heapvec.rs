#
!
[
cfg
(
feature
=
"
alloc
"
)
]
#
!
[
doc
(
hidden
)
]
use
crate
:
:
bigint
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
{
cmp
ops
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
vec
:
:
Vec
;
#
[
derive
(
Clone
)
]
pub
struct
HeapVec
{
data
:
Vec
<
bigint
:
:
Limb
>
}
#
[
allow
(
clippy
:
:
new_without_default
)
]
impl
HeapVec
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
data
:
Vec
:
:
with_capacity
(
bigint
:
:
BIGINT_LIMBS
)
}
}
#
[
inline
]
pub
fn
try_from
(
x
:
&
[
bigint
:
:
Limb
]
)
-
>
Option
<
Self
>
{
let
mut
vec
=
Self
:
:
new
(
)
;
vec
.
try_extend
(
x
)
?
;
Some
(
vec
)
}
#
[
inline
]
pub
unsafe
fn
set_len
(
&
mut
self
len
:
usize
)
{
debug_assert
!
(
len
<
=
bigint
:
:
BIGINT_LIMBS
)
;
unsafe
{
self
.
data
.
set_len
(
len
)
}
;
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
data
.
len
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
data
.
capacity
(
)
}
#
[
inline
]
pub
fn
try_push
(
&
mut
self
value
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
self
.
data
.
push
(
value
)
;
Some
(
(
)
)
}
#
[
inline
]
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
bigint
:
:
Limb
>
{
self
.
data
.
pop
(
)
}
#
[
inline
]
pub
fn
try_extend
(
&
mut
self
slc
:
&
[
bigint
:
:
Limb
]
)
-
>
Option
<
(
)
>
{
self
.
data
.
extend_from_slice
(
slc
)
;
Some
(
(
)
)
}
#
[
inline
]
pub
fn
try_resize
(
&
mut
self
len
:
usize
value
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
self
.
data
.
resize
(
len
value
)
;
Some
(
(
)
)
}
#
[
inline
(
always
)
]
pub
fn
hi64
(
&
self
)
-
>
(
u64
bool
)
{
bigint
:
:
hi64
(
&
self
.
data
)
}
#
[
inline
(
always
)
]
pub
fn
from_u64
(
x
:
u64
)
-
>
Self
{
bigint
:
:
from_u64
(
x
)
}
#
[
inline
]
pub
fn
normalize
(
&
mut
self
)
{
bigint
:
:
normalize
(
self
)
}
#
[
inline
]
pub
fn
is_normalized
(
&
self
)
-
>
bool
{
bigint
:
:
is_normalized
(
self
)
}
#
[
inline
]
pub
fn
add_small
(
&
mut
self
y
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
bigint
:
:
small_add
(
self
y
)
}
#
[
inline
]
pub
fn
mul_small
(
&
mut
self
y
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
bigint
:
:
small_mul
(
self
y
)
}
}
impl
PartialEq
for
HeapVec
{
#
[
inline
]
#
[
allow
(
clippy
:
:
op_ref
)
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
use
core
:
:
ops
:
:
Deref
;
self
.
len
(
)
=
=
other
.
len
(
)
&
&
self
.
deref
(
)
=
=
other
.
deref
(
)
}
}
impl
Eq
for
HeapVec
{
}
impl
cmp
:
:
PartialOrd
for
HeapVec
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
Some
(
bigint
:
:
compare
(
self
other
)
)
}
}
impl
cmp
:
:
Ord
for
HeapVec
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
bigint
:
:
compare
(
self
other
)
}
}
impl
ops
:
:
Deref
for
HeapVec
{
type
Target
=
[
bigint
:
:
Limb
]
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
[
bigint
:
:
Limb
]
{
&
self
.
data
}
}
impl
ops
:
:
DerefMut
for
HeapVec
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
bigint
:
:
Limb
]
{
&
mut
self
.
data
}
}
impl
ops
:
:
MulAssign
<
&
[
bigint
:
:
Limb
]
>
for
HeapVec
{
#
[
inline
]
fn
mul_assign
(
&
mut
self
rhs
:
&
[
bigint
:
:
Limb
]
)
{
bigint
:
:
large_mul
(
self
rhs
)
.
unwrap
(
)
;
}
}
