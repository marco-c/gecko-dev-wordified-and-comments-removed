#
!
[
doc
(
hidden
)
]
#
[
cfg
(
all
(
not
(
feature
=
"
std
"
)
feature
=
"
compact
"
)
)
]
use
crate
:
:
libm
:
:
{
powd
powf
}
;
#
[
cfg
(
not
(
feature
=
"
compact
"
)
)
]
use
crate
:
:
table
:
:
{
SMALL_F32_POW10
SMALL_F64_POW10
SMALL_INT_POW10
SMALL_INT_POW5
}
;
#
[
cfg
(
not
(
feature
=
"
compact
"
)
)
]
use
core
:
:
hint
;
use
core
:
:
ops
;
pub
trait
Float
:
Sized
+
Copy
+
PartialEq
+
PartialOrd
+
Send
+
Sync
+
ops
:
:
Add
<
Output
=
Self
>
+
ops
:
:
AddAssign
+
ops
:
:
Div
<
Output
=
Self
>
+
ops
:
:
DivAssign
+
ops
:
:
Mul
<
Output
=
Self
>
+
ops
:
:
MulAssign
+
ops
:
:
Rem
<
Output
=
Self
>
+
ops
:
:
RemAssign
+
ops
:
:
Sub
<
Output
=
Self
>
+
ops
:
:
SubAssign
+
ops
:
:
Neg
<
Output
=
Self
>
{
const
MAX_DIGITS
:
usize
;
const
SIGN_MASK
:
u64
;
const
EXPONENT_MASK
:
u64
;
const
HIDDEN_BIT_MASK
:
u64
;
const
MANTISSA_MASK
:
u64
;
const
MANTISSA_SIZE
:
i32
;
const
EXPONENT_BIAS
:
i32
;
const
DENORMAL_EXPONENT
:
i32
;
const
MAX_EXPONENT
:
i32
;
const
CARRY_MASK
:
u64
;
const
INVALID_FP
:
i32
=
-
0x8000
;
const
MAX_MANTISSA_FAST_PATH
:
u64
=
2_u64
<
<
Self
:
:
MANTISSA_SIZE
;
const
INFINITE_POWER
:
i32
=
Self
:
:
MAX_EXPONENT
+
Self
:
:
EXPONENT_BIAS
;
const
MIN_EXPONENT_ROUND_TO_EVEN
:
i32
;
const
MAX_EXPONENT_ROUND_TO_EVEN
:
i32
;
const
MINIMUM_EXPONENT
:
i32
;
const
SMALLEST_POWER_OF_TEN
:
i32
;
const
LARGEST_POWER_OF_TEN
:
i32
;
const
MIN_EXPONENT_FAST_PATH
:
i32
;
const
MAX_EXPONENT_FAST_PATH
:
i32
;
const
MAX_EXPONENT_DISGUISED_FAST_PATH
:
i32
;
fn
from_u64
(
u
:
u64
)
-
>
Self
;
fn
from_bits
(
u
:
u64
)
-
>
Self
;
fn
to_bits
(
self
)
-
>
u64
;
unsafe
fn
pow_fast_path
(
exponent
:
usize
)
-
>
Self
;
#
[
inline
(
always
)
]
unsafe
fn
int_pow_fast_path
(
exponent
:
usize
radix
:
u32
)
-
>
u64
{
#
[
cfg
(
not
(
feature
=
"
compact
"
)
)
]
return
match
radix
{
5
=
>
unsafe
{
*
SMALL_INT_POW5
.
get_unchecked
(
exponent
)
}
10
=
>
unsafe
{
*
SMALL_INT_POW10
.
get_unchecked
(
exponent
)
}
_
=
>
unsafe
{
hint
:
:
unreachable_unchecked
(
)
}
}
;
#
[
cfg
(
feature
=
"
compact
"
)
]
return
(
radix
as
u64
)
.
pow
(
exponent
as
u32
)
;
}
#
[
inline
]
fn
is_denormal
(
self
)
-
>
bool
{
self
.
to_bits
(
)
&
Self
:
:
EXPONENT_MASK
=
=
0
}
#
[
inline
]
fn
exponent
(
self
)
-
>
i32
{
if
self
.
is_denormal
(
)
{
return
Self
:
:
DENORMAL_EXPONENT
;
}
let
bits
=
self
.
to_bits
(
)
;
let
biased_e
:
i32
=
(
(
bits
&
Self
:
:
EXPONENT_MASK
)
>
>
Self
:
:
MANTISSA_SIZE
)
as
i32
;
biased_e
-
Self
:
:
EXPONENT_BIAS
}
#
[
inline
]
fn
mantissa
(
self
)
-
>
u64
{
let
bits
=
self
.
to_bits
(
)
;
let
s
=
bits
&
Self
:
:
MANTISSA_MASK
;
if
!
self
.
is_denormal
(
)
{
s
+
Self
:
:
HIDDEN_BIT_MASK
}
else
{
s
}
}
}
impl
Float
for
f32
{
const
MAX_DIGITS
:
usize
=
114
;
const
SIGN_MASK
:
u64
=
0x80000000
;
const
EXPONENT_MASK
:
u64
=
0x7F800000
;
const
HIDDEN_BIT_MASK
:
u64
=
0x00800000
;
const
MANTISSA_MASK
:
u64
=
0x007FFFFF
;
const
MANTISSA_SIZE
:
i32
=
23
;
const
EXPONENT_BIAS
:
i32
=
127
+
Self
:
:
MANTISSA_SIZE
;
const
DENORMAL_EXPONENT
:
i32
=
1
-
Self
:
:
EXPONENT_BIAS
;
const
MAX_EXPONENT
:
i32
=
0xFF
-
Self
:
:
EXPONENT_BIAS
;
const
CARRY_MASK
:
u64
=
0x1000000
;
const
MIN_EXPONENT_ROUND_TO_EVEN
:
i32
=
-
17
;
const
MAX_EXPONENT_ROUND_TO_EVEN
:
i32
=
10
;
const
MINIMUM_EXPONENT
:
i32
=
-
127
;
const
SMALLEST_POWER_OF_TEN
:
i32
=
-
65
;
const
LARGEST_POWER_OF_TEN
:
i32
=
38
;
const
MIN_EXPONENT_FAST_PATH
:
i32
=
-
10
;
const
MAX_EXPONENT_FAST_PATH
:
i32
=
10
;
const
MAX_EXPONENT_DISGUISED_FAST_PATH
:
i32
=
17
;
#
[
inline
(
always
)
]
unsafe
fn
pow_fast_path
(
exponent
:
usize
)
-
>
Self
{
#
[
cfg
(
not
(
feature
=
"
compact
"
)
)
]
return
unsafe
{
*
SMALL_F32_POW10
.
get_unchecked
(
exponent
)
}
;
#
[
cfg
(
feature
=
"
compact
"
)
]
return
powf
(
10
.
0f32
exponent
as
f32
)
;
}
#
[
inline
]
fn
from_u64
(
u
:
u64
)
-
>
f32
{
u
as
_
}
#
[
inline
]
fn
from_bits
(
u
:
u64
)
-
>
f32
{
debug_assert
!
(
u
<
=
0xffff_ffff
)
;
f32
:
:
from_bits
(
u
as
u32
)
}
#
[
inline
]
fn
to_bits
(
self
)
-
>
u64
{
f32
:
:
to_bits
(
self
)
as
u64
}
}
impl
Float
for
f64
{
const
MAX_DIGITS
:
usize
=
769
;
const
SIGN_MASK
:
u64
=
0x8000000000000000
;
const
EXPONENT_MASK
:
u64
=
0x7FF0000000000000
;
const
HIDDEN_BIT_MASK
:
u64
=
0x0010000000000000
;
const
MANTISSA_MASK
:
u64
=
0x000FFFFFFFFFFFFF
;
const
MANTISSA_SIZE
:
i32
=
52
;
const
EXPONENT_BIAS
:
i32
=
1023
+
Self
:
:
MANTISSA_SIZE
;
const
DENORMAL_EXPONENT
:
i32
=
1
-
Self
:
:
EXPONENT_BIAS
;
const
MAX_EXPONENT
:
i32
=
0x7FF
-
Self
:
:
EXPONENT_BIAS
;
const
CARRY_MASK
:
u64
=
0x20000000000000
;
const
MIN_EXPONENT_ROUND_TO_EVEN
:
i32
=
-
4
;
const
MAX_EXPONENT_ROUND_TO_EVEN
:
i32
=
23
;
const
MINIMUM_EXPONENT
:
i32
=
-
1023
;
const
SMALLEST_POWER_OF_TEN
:
i32
=
-
342
;
const
LARGEST_POWER_OF_TEN
:
i32
=
308
;
const
MIN_EXPONENT_FAST_PATH
:
i32
=
-
22
;
const
MAX_EXPONENT_FAST_PATH
:
i32
=
22
;
const
MAX_EXPONENT_DISGUISED_FAST_PATH
:
i32
=
37
;
#
[
inline
(
always
)
]
unsafe
fn
pow_fast_path
(
exponent
:
usize
)
-
>
Self
{
#
[
cfg
(
not
(
feature
=
"
compact
"
)
)
]
return
unsafe
{
*
SMALL_F64_POW10
.
get_unchecked
(
exponent
)
}
;
#
[
cfg
(
feature
=
"
compact
"
)
]
return
powd
(
10
.
0f64
exponent
as
f64
)
;
}
#
[
inline
]
fn
from_u64
(
u
:
u64
)
-
>
f64
{
u
as
_
}
#
[
inline
]
fn
from_bits
(
u
:
u64
)
-
>
f64
{
f64
:
:
from_bits
(
u
)
}
#
[
inline
]
fn
to_bits
(
self
)
-
>
u64
{
f64
:
:
to_bits
(
self
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
all
(
feature
=
"
std
"
feature
=
"
compact
"
)
)
]
pub
fn
powf
(
x
:
f32
y
:
f32
)
-
>
f32
{
x
.
powf
(
y
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
all
(
feature
=
"
std
"
feature
=
"
compact
"
)
)
]
pub
fn
powd
(
x
:
f64
y
:
f64
)
-
>
f64
{
x
.
powf
(
y
)
}
