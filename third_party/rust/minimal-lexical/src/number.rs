#
!
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
nightly
"
)
]
use
crate
:
:
fpu
:
:
set_precision
;
use
crate
:
:
num
:
:
Float
;
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
Eq
)
]
pub
struct
Number
{
pub
exponent
:
i32
pub
mantissa
:
u64
pub
many_digits
:
bool
}
impl
Number
{
#
[
inline
]
pub
fn
is_fast_path
<
F
:
Float
>
(
&
self
)
-
>
bool
{
F
:
:
MIN_EXPONENT_FAST_PATH
<
=
self
.
exponent
&
&
self
.
exponent
<
=
F
:
:
MAX_EXPONENT_DISGUISED_FAST_PATH
&
&
self
.
mantissa
<
=
F
:
:
MAX_MANTISSA_FAST_PATH
&
&
!
self
.
many_digits
}
pub
fn
try_fast_path
<
F
:
Float
>
(
&
self
)
-
>
Option
<
F
>
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
let
_cw
=
set_precision
:
:
<
F
>
(
)
;
if
self
.
is_fast_path
:
:
<
F
>
(
)
{
let
max_exponent
=
F
:
:
MAX_EXPONENT_FAST_PATH
;
Some
(
if
self
.
exponent
<
=
max_exponent
{
let
value
=
F
:
:
from_u64
(
self
.
mantissa
)
;
if
self
.
exponent
<
0
{
value
/
unsafe
{
F
:
:
pow_fast_path
(
(
-
self
.
exponent
)
as
_
)
}
}
else
{
value
*
unsafe
{
F
:
:
pow_fast_path
(
self
.
exponent
as
_
)
}
}
}
else
{
let
shift
=
self
.
exponent
-
max_exponent
;
let
int_power
=
unsafe
{
F
:
:
int_pow_fast_path
(
shift
as
usize
10
)
}
;
let
mantissa
=
self
.
mantissa
.
checked_mul
(
int_power
)
?
;
if
mantissa
>
F
:
:
MAX_MANTISSA_FAST_PATH
{
return
None
;
}
F
:
:
from_u64
(
mantissa
)
*
unsafe
{
F
:
:
pow_fast_path
(
max_exponent
as
_
)
}
}
)
}
else
{
None
}
}
}
