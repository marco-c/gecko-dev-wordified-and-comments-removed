#
!
[
cfg
(
all
(
not
(
feature
=
"
std
"
)
feature
=
"
compact
"
)
)
]
#
!
[
doc
(
hidden
)
]
macro_rules
!
i
{
(
array
:
ident
index
:
expr
)
=
>
{
/
/
SAFETY
:
safe
if
index
<
array
.
len
(
)
.
unsafe
{
*
array
.
get_unchecked
(
index
)
}
}
;
}
pub
fn
powf
(
x
:
f32
y
:
f32
)
-
>
f32
{
const
BP
:
[
f32
;
2
]
=
[
1
.
0
1
.
5
]
;
const
DP_H
:
[
f32
;
2
]
=
[
0
.
0
5
.
84960938e
-
01
]
;
const
DP_L
:
[
f32
;
2
]
=
[
0
.
0
1
.
56322085e
-
06
]
;
const
TWO24
:
f32
=
16777216
.
0
;
const
HUGE
:
f32
=
1
.
0e30
;
const
TINY
:
f32
=
1
.
0e
-
30
;
const
L1
:
f32
=
6
.
0000002384e
-
01
;
const
L2
:
f32
=
4
.
2857143283e
-
01
;
const
L3
:
f32
=
3
.
3333334327e
-
01
;
const
L4
:
f32
=
2
.
7272811532e
-
01
;
const
L5
:
f32
=
2
.
3066075146e
-
01
;
const
L6
:
f32
=
2
.
0697501302e
-
01
;
const
P1
:
f32
=
1
.
6666667163e
-
01
;
const
P2
:
f32
=
-
2
.
7777778450e
-
03
;
const
P3
:
f32
=
6
.
6137559770e
-
05
;
const
P4
:
f32
=
-
1
.
6533901999e
-
06
;
const
P5
:
f32
=
4
.
1381369442e
-
08
;
const
LG2
:
f32
=
6
.
9314718246e
-
01
;
const
LG2_H
:
f32
=
6
.
93145752e
-
01
;
const
LG2_L
:
f32
=
1
.
42860654e
-
06
;
const
OVT
:
f32
=
4
.
2995665694e
-
08
;
const
CP
:
f32
=
9
.
6179670095e
-
01
;
const
CP_H
:
f32
=
9
.
6191406250e
-
01
;
const
CP_L
:
f32
=
-
1
.
1736857402e
-
04
;
const
IVLN2
:
f32
=
1
.
4426950216e
+
00
;
const
IVLN2_H
:
f32
=
1
.
4426879883e
+
00
;
const
IVLN2_L
:
f32
=
7
.
0526075433e
-
06
;
let
mut
z
:
f32
;
let
mut
ax
:
f32
;
let
z_h
:
f32
;
let
z_l
:
f32
;
let
mut
p_h
:
f32
;
let
mut
p_l
:
f32
;
let
y1
:
f32
;
let
mut
t1
:
f32
;
let
t2
:
f32
;
let
mut
r
:
f32
;
let
s
:
f32
;
let
mut
sn
:
f32
;
let
mut
t
:
f32
;
let
mut
u
:
f32
;
let
mut
v
:
f32
;
let
mut
w
:
f32
;
let
i
:
i32
;
let
mut
j
:
i32
;
let
mut
k
:
i32
;
let
mut
yisint
:
i32
;
let
mut
n
:
i32
;
let
hx
:
i32
;
let
hy
:
i32
;
let
mut
ix
:
i32
;
let
iy
:
i32
;
let
mut
is
:
i32
;
hx
=
x
.
to_bits
(
)
as
i32
;
hy
=
y
.
to_bits
(
)
as
i32
;
ix
=
hx
&
0x7fffffff
;
iy
=
hy
&
0x7fffffff
;
if
iy
=
=
0
{
return
1
.
0
;
}
if
hx
=
=
0x3f800000
{
return
1
.
0
;
}
if
ix
>
0x7f800000
|
|
iy
>
0x7f800000
{
return
x
+
y
;
}
yisint
=
0
;
if
hx
<
0
{
if
iy
>
=
0x4b800000
{
yisint
=
2
;
}
else
if
iy
>
=
0x3f800000
{
k
=
(
iy
>
>
23
)
-
0x7f
;
j
=
iy
>
>
(
23
-
k
)
;
if
(
j
<
<
(
23
-
k
)
)
=
=
iy
{
yisint
=
2
-
(
j
&
1
)
;
}
}
}
if
iy
=
=
0x7f800000
{
if
ix
=
=
0x3f800000
{
return
1
.
0
;
}
else
if
ix
>
0x3f800000
{
return
if
hy
>
=
0
{
y
}
else
{
0
.
0
}
;
}
else
{
return
if
hy
>
=
0
{
0
.
0
}
else
{
-
y
}
;
}
}
if
iy
=
=
0x3f800000
{
return
if
hy
>
=
0
{
x
}
else
{
1
.
0
/
x
}
;
}
if
hy
=
=
0x40000000
{
return
x
*
x
;
}
if
hy
=
=
0x3f000000
&
&
hx
>
=
0
{
return
sqrtf
(
x
)
;
}
ax
=
fabsf
(
x
)
;
if
ix
=
=
0x7f800000
|
|
ix
=
=
0
|
|
ix
=
=
0x3f800000
{
z
=
ax
;
if
hy
<
0
{
z
=
1
.
0
/
z
;
}
if
hx
<
0
{
if
(
(
ix
-
0x3f800000
)
|
yisint
)
=
=
0
{
z
=
(
z
-
z
)
/
(
z
-
z
)
;
}
else
if
yisint
=
=
1
{
z
=
-
z
;
}
}
return
z
;
}
sn
=
1
.
0
;
if
hx
<
0
{
if
yisint
=
=
0
{
return
(
x
-
x
)
/
(
x
-
x
)
;
}
if
yisint
=
=
1
{
sn
=
-
1
.
0
;
}
}
if
iy
>
0x4d000000
{
if
ix
<
0x3f7ffff8
{
return
if
hy
<
0
{
sn
*
HUGE
*
HUGE
}
else
{
sn
*
TINY
*
TINY
}
;
}
if
ix
>
0x3f800007
{
return
if
hy
>
0
{
sn
*
HUGE
*
HUGE
}
else
{
sn
*
TINY
*
TINY
}
;
}
t
=
ax
-
1
.
;
w
=
(
t
*
t
)
*
(
0
.
5
-
t
*
(
0
.
333333333333
-
t
*
0
.
25
)
)
;
u
=
IVLN2_H
*
t
;
v
=
t
*
IVLN2_L
-
w
*
IVLN2
;
t1
=
u
+
v
;
is
=
t1
.
to_bits
(
)
as
i32
;
t1
=
f32
:
:
from_bits
(
is
as
u32
&
0xfffff000
)
;
t2
=
v
-
(
t1
-
u
)
;
}
else
{
let
mut
s2
:
f32
;
let
mut
s_h
:
f32
;
let
s_l
:
f32
;
let
mut
t_h
:
f32
;
let
mut
t_l
:
f32
;
n
=
0
;
if
ix
<
0x00800000
{
ax
*
=
TWO24
;
n
-
=
24
;
ix
=
ax
.
to_bits
(
)
as
i32
;
}
n
+
=
(
(
ix
)
>
>
23
)
-
0x7f
;
j
=
ix
&
0x007fffff
;
ix
=
j
|
0x3f800000
;
if
j
<
=
0x1cc471
{
k
=
0
;
}
else
if
j
<
0x5db3d7
{
k
=
1
;
}
else
{
k
=
0
;
n
+
=
1
;
ix
-
=
0x00800000
;
}
ax
=
f32
:
:
from_bits
(
ix
as
u32
)
;
u
=
ax
-
i
!
(
BP
k
as
usize
)
;
v
=
1
.
0
/
(
ax
+
i
!
(
BP
k
as
usize
)
)
;
s
=
u
*
v
;
s_h
=
s
;
is
=
s_h
.
to_bits
(
)
as
i32
;
s_h
=
f32
:
:
from_bits
(
is
as
u32
&
0xfffff000
)
;
is
=
(
(
(
ix
as
u32
>
>
1
)
&
0xfffff000
)
|
0x20000000
)
as
i32
;
t_h
=
f32
:
:
from_bits
(
is
as
u32
+
0x00400000
+
(
(
k
as
u32
)
<
<
21
)
)
;
t_l
=
ax
-
(
t_h
-
i
!
(
BP
k
as
usize
)
)
;
s_l
=
v
*
(
(
u
-
s_h
*
t_h
)
-
s_h
*
t_l
)
;
s2
=
s
*
s
;
r
=
s2
*
s2
*
(
L1
+
s2
*
(
L2
+
s2
*
(
L3
+
s2
*
(
L4
+
s2
*
(
L5
+
s2
*
L6
)
)
)
)
)
;
r
+
=
s_l
*
(
s_h
+
s
)
;
s2
=
s_h
*
s_h
;
t_h
=
3
.
0
+
s2
+
r
;
is
=
t_h
.
to_bits
(
)
as
i32
;
t_h
=
f32
:
:
from_bits
(
is
as
u32
&
0xfffff000
)
;
t_l
=
r
-
(
(
t_h
-
3
.
0
)
-
s2
)
;
u
=
s_h
*
t_h
;
v
=
s_l
*
t_h
+
t_l
*
s
;
p_h
=
u
+
v
;
is
=
p_h
.
to_bits
(
)
as
i32
;
p_h
=
f32
:
:
from_bits
(
is
as
u32
&
0xfffff000
)
;
p_l
=
v
-
(
p_h
-
u
)
;
z_h
=
CP_H
*
p_h
;
z_l
=
CP_L
*
p_h
+
p_l
*
CP
+
i
!
(
DP_L
k
as
usize
)
;
t
=
n
as
f32
;
t1
=
(
(
z_h
+
z_l
)
+
i
!
(
DP_H
k
as
usize
)
)
+
t
;
is
=
t1
.
to_bits
(
)
as
i32
;
t1
=
f32
:
:
from_bits
(
is
as
u32
&
0xfffff000
)
;
t2
=
z_l
-
(
(
(
t1
-
t
)
-
i
!
(
DP_H
k
as
usize
)
)
-
z_h
)
;
}
;
is
=
y
.
to_bits
(
)
as
i32
;
y1
=
f32
:
:
from_bits
(
is
as
u32
&
0xfffff000
)
;
p_l
=
(
y
-
y1
)
*
t1
+
y
*
t2
;
p_h
=
y1
*
t1
;
z
=
p_l
+
p_h
;
j
=
z
.
to_bits
(
)
as
i32
;
if
j
>
0x43000000
{
return
sn
*
HUGE
*
HUGE
;
}
else
if
j
=
=
0x43000000
{
if
p_l
+
OVT
>
z
-
p_h
{
return
sn
*
HUGE
*
HUGE
;
}
}
else
if
(
j
&
0x7fffffff
)
>
0x43160000
{
return
sn
*
TINY
*
TINY
;
}
else
if
j
as
u32
=
=
0xc3160000
&
&
p_l
<
=
z
-
p_h
{
return
sn
*
TINY
*
TINY
;
}
i
=
j
&
0x7fffffff
;
k
=
(
i
>
>
23
)
-
0x7f
;
n
=
0
;
if
i
>
0x3f000000
{
n
=
j
+
(
0x00800000
>
>
(
k
+
1
)
)
;
k
=
(
(
n
&
0x7fffffff
)
>
>
23
)
-
0x7f
;
t
=
f32
:
:
from_bits
(
n
as
u32
&
!
(
0x007fffff
>
>
k
)
)
;
n
=
(
(
n
&
0x007fffff
)
|
0x00800000
)
>
>
(
23
-
k
)
;
if
j
<
0
{
n
=
-
n
;
}
p_h
-
=
t
;
}
t
=
p_l
+
p_h
;
is
=
t
.
to_bits
(
)
as
i32
;
t
=
f32
:
:
from_bits
(
is
as
u32
&
0xffff8000
)
;
u
=
t
*
LG2_H
;
v
=
(
p_l
-
(
t
-
p_h
)
)
*
LG2
+
t
*
LG2_L
;
z
=
u
+
v
;
w
=
v
-
(
z
-
u
)
;
t
=
z
*
z
;
t1
=
z
-
t
*
(
P1
+
t
*
(
P2
+
t
*
(
P3
+
t
*
(
P4
+
t
*
P5
)
)
)
)
;
r
=
(
z
*
t1
)
/
(
t1
-
2
.
0
)
-
(
w
+
z
*
w
)
;
z
=
1
.
0
-
(
r
-
z
)
;
j
=
z
.
to_bits
(
)
as
i32
;
j
+
=
n
<
<
23
;
if
(
j
>
>
23
)
<
=
0
{
z
=
scalbnf
(
z
n
)
;
}
else
{
z
=
f32
:
:
from_bits
(
j
as
u32
)
;
}
sn
*
z
}
pub
fn
sqrtf
(
x
:
f32
)
-
>
f32
{
#
[
cfg
(
target_feature
=
"
sse
"
)
]
{
#
[
cfg
(
target_arch
=
"
x86
"
)
]
use
core
:
:
arch
:
:
x86
:
:
*
;
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
use
core
:
:
arch
:
:
x86_64
:
:
*
;
unsafe
{
let
m
=
_mm_set_ss
(
x
)
;
let
m_sqrt
=
_mm_sqrt_ss
(
m
)
;
_mm_cvtss_f32
(
m_sqrt
)
}
}
#
[
cfg
(
not
(
target_feature
=
"
sse
"
)
)
]
{
const
TINY
:
f32
=
1
.
0e
-
30
;
let
mut
z
:
f32
;
let
sign
:
i32
=
0x80000000u32
as
i32
;
let
mut
ix
:
i32
;
let
mut
s
:
i32
;
let
mut
q
:
i32
;
let
mut
m
:
i32
;
let
mut
t
:
i32
;
let
mut
i
:
i32
;
let
mut
r
:
u32
;
ix
=
x
.
to_bits
(
)
as
i32
;
if
(
ix
as
u32
&
0x7f800000
)
=
=
0x7f800000
{
return
x
*
x
+
x
;
}
if
ix
<
=
0
{
if
(
ix
&
!
sign
)
=
=
0
{
return
x
;
}
if
ix
<
0
{
return
(
x
-
x
)
/
(
x
-
x
)
;
}
}
m
=
ix
>
>
23
;
if
m
=
=
0
{
i
=
0
;
while
ix
&
0x00800000
=
=
0
{
ix
<
<
=
1
;
i
=
i
+
1
;
}
m
-
=
i
-
1
;
}
m
-
=
127
;
ix
=
(
ix
&
0x007fffff
)
|
0x00800000
;
if
m
&
1
=
=
1
{
ix
+
=
ix
;
}
m
>
>
=
1
;
ix
+
=
ix
;
q
=
0
;
s
=
0
;
r
=
0x01000000
;
while
r
!
=
0
{
t
=
s
+
r
as
i32
;
if
t
<
=
ix
{
s
=
t
+
r
as
i32
;
ix
-
=
t
;
q
+
=
r
as
i32
;
}
ix
+
=
ix
;
r
>
>
=
1
;
}
if
ix
!
=
0
{
z
=
1
.
0
-
TINY
;
if
z
>
=
1
.
0
{
z
=
1
.
0
+
TINY
;
if
z
>
1
.
0
{
q
+
=
2
;
}
else
{
q
+
=
q
&
1
;
}
}
}
ix
=
(
q
>
>
1
)
+
0x3f000000
;
ix
+
=
m
<
<
23
;
f32
:
:
from_bits
(
ix
as
u32
)
}
}
pub
fn
fabsf
(
x
:
f32
)
-
>
f32
{
f32
:
:
from_bits
(
x
.
to_bits
(
)
&
0x7fffffff
)
}
pub
fn
scalbnf
(
mut
x
:
f32
mut
n
:
i32
)
-
>
f32
{
let
x1p127
=
f32
:
:
from_bits
(
0x7f000000
)
;
let
x1p_126
=
f32
:
:
from_bits
(
0x800000
)
;
let
x1p24
=
f32
:
:
from_bits
(
0x4b800000
)
;
if
n
>
127
{
x
*
=
x1p127
;
n
-
=
127
;
if
n
>
127
{
x
*
=
x1p127
;
n
-
=
127
;
if
n
>
127
{
n
=
127
;
}
}
}
else
if
n
<
-
126
{
x
*
=
x1p_126
*
x1p24
;
n
+
=
126
-
24
;
if
n
<
-
126
{
x
*
=
x1p_126
*
x1p24
;
n
+
=
126
-
24
;
if
n
<
-
126
{
n
=
-
126
;
}
}
}
x
*
f32
:
:
from_bits
(
(
(
0x7f
+
n
)
as
u32
)
<
<
23
)
}
pub
fn
powd
(
x
:
f64
y
:
f64
)
-
>
f64
{
const
BP
:
[
f64
;
2
]
=
[
1
.
0
1
.
5
]
;
const
DP_H
:
[
f64
;
2
]
=
[
0
.
0
5
.
84962487220764160156e
-
01
]
;
const
DP_L
:
[
f64
;
2
]
=
[
0
.
0
1
.
35003920212974897128e
-
08
]
;
const
TWO53
:
f64
=
9007199254740992
.
0
;
const
HUGE
:
f64
=
1
.
0e300
;
const
TINY
:
f64
=
1
.
0e
-
300
;
const
L1
:
f64
=
5
.
99999999999994648725e
-
01
;
const
L2
:
f64
=
4
.
28571428578550184252e
-
01
;
const
L3
:
f64
=
3
.
33333329818377432918e
-
01
;
const
L4
:
f64
=
2
.
72728123808534006489e
-
01
;
const
L5
:
f64
=
2
.
30660745775561754067e
-
01
;
const
L6
:
f64
=
2
.
06975017800338417784e
-
01
;
const
P1
:
f64
=
1
.
66666666666666019037e
-
01
;
const
P2
:
f64
=
-
2
.
77777777770155933842e
-
03
;
const
P3
:
f64
=
6
.
61375632143793436117e
-
05
;
const
P4
:
f64
=
-
1
.
65339022054652515390e
-
06
;
const
P5
:
f64
=
4
.
13813679705723846039e
-
08
;
const
LG2
:
f64
=
6
.
93147180559945286227e
-
01
;
const
LG2_H
:
f64
=
6
.
93147182464599609375e
-
01
;
const
LG2_L
:
f64
=
-
1
.
90465429995776804525e
-
09
;
const
OVT
:
f64
=
8
.
0085662595372944372e
-
017
;
const
CP
:
f64
=
9
.
61796693925975554329e
-
01
;
const
CP_H
:
f64
=
9
.
61796700954437255859e
-
01
;
const
CP_L
:
f64
=
-
7
.
02846165095275826516e
-
09
;
const
IVLN2
:
f64
=
1
.
44269504088896338700e
+
00
;
const
IVLN2_H
:
f64
=
1
.
44269502162933349609e
+
00
;
const
IVLN2_L
:
f64
=
1
.
92596299112661746887e
-
08
;
let
t1
:
f64
;
let
t2
:
f64
;
let
(
hx
lx
)
:
(
i32
u32
)
=
(
(
x
.
to_bits
(
)
>
>
32
)
as
i32
x
.
to_bits
(
)
as
u32
)
;
let
(
hy
ly
)
:
(
i32
u32
)
=
(
(
y
.
to_bits
(
)
>
>
32
)
as
i32
y
.
to_bits
(
)
as
u32
)
;
let
mut
ix
:
i32
=
(
hx
&
0x7fffffff
)
as
i32
;
let
iy
:
i32
=
(
hy
&
0x7fffffff
)
as
i32
;
if
(
(
iy
as
u32
)
|
ly
)
=
=
0
{
return
1
.
0
;
}
if
hx
=
=
0x3ff00000
&
&
lx
=
=
0
{
return
1
.
0
;
}
if
ix
>
0x7ff00000
|
|
(
ix
=
=
0x7ff00000
&
&
lx
!
=
0
)
|
|
iy
>
0x7ff00000
|
|
(
iy
=
=
0x7ff00000
&
&
ly
!
=
0
)
{
return
x
+
y
;
}
let
mut
yisint
:
i32
=
0
;
let
mut
k
:
i32
;
let
mut
j
:
i32
;
if
hx
<
0
{
if
iy
>
=
0x43400000
{
yisint
=
2
;
}
else
if
iy
>
=
0x3ff00000
{
k
=
(
iy
>
>
20
)
-
0x3ff
;
if
k
>
20
{
j
=
(
ly
>
>
(
52
-
k
)
)
as
i32
;
if
(
j
<
<
(
52
-
k
)
)
=
=
(
ly
as
i32
)
{
yisint
=
2
-
(
j
&
1
)
;
}
}
else
if
ly
=
=
0
{
j
=
iy
>
>
(
20
-
k
)
;
if
(
j
<
<
(
20
-
k
)
)
=
=
iy
{
yisint
=
2
-
(
j
&
1
)
;
}
}
}
}
if
ly
=
=
0
{
if
iy
=
=
0x7ff00000
{
return
if
(
(
ix
-
0x3ff00000
)
|
(
lx
as
i32
)
)
=
=
0
{
1
.
0
}
else
if
ix
>
=
0x3ff00000
{
if
hy
>
=
0
{
y
}
else
{
0
.
0
}
}
else
{
if
hy
>
=
0
{
0
.
0
}
else
{
-
y
}
}
;
}
if
iy
=
=
0x3ff00000
{
return
if
hy
>
=
0
{
x
}
else
{
1
.
0
/
x
}
;
}
if
hy
=
=
0x40000000
{
return
x
*
x
;
}
if
hy
=
=
0x3fe00000
{
if
hx
>
=
0
{
return
sqrtd
(
x
)
;
}
}
}
let
mut
ax
:
f64
=
fabsd
(
x
)
;
if
lx
=
=
0
{
if
ix
=
=
0x7ff00000
|
|
ix
=
=
0
|
|
ix
=
=
0x3ff00000
{
let
mut
z
:
f64
=
ax
;
if
hy
<
0
{
z
=
1
.
0
/
z
;
}
if
hx
<
0
{
if
(
(
ix
-
0x3ff00000
)
|
yisint
)
=
=
0
{
z
=
(
z
-
z
)
/
(
z
-
z
)
;
}
else
if
yisint
=
=
1
{
z
=
-
z
;
}
}
return
z
;
}
}
let
mut
s
:
f64
=
1
.
0
;
if
hx
<
0
{
if
yisint
=
=
0
{
return
(
x
-
x
)
/
(
x
-
x
)
;
}
if
yisint
=
=
1
{
s
=
-
1
.
0
;
}
}
if
iy
>
0x41e00000
{
if
iy
>
0x43f00000
{
if
ix
<
=
0x3fefffff
{
return
if
hy
<
0
{
HUGE
*
HUGE
}
else
{
TINY
*
TINY
}
;
}
if
ix
>
=
0x3ff00000
{
return
if
hy
>
0
{
HUGE
*
HUGE
}
else
{
TINY
*
TINY
}
;
}
}
if
ix
<
0x3fefffff
{
return
if
hy
<
0
{
s
*
HUGE
*
HUGE
}
else
{
s
*
TINY
*
TINY
}
;
}
if
ix
>
0x3ff00000
{
return
if
hy
>
0
{
s
*
HUGE
*
HUGE
}
else
{
s
*
TINY
*
TINY
}
;
}
let
t
:
f64
=
ax
-
1
.
0
;
let
w
:
f64
=
(
t
*
t
)
*
(
0
.
5
-
t
*
(
0
.
3333333333333333333333
-
t
*
0
.
25
)
)
;
let
u
:
f64
=
IVLN2_H
*
t
;
let
v
:
f64
=
t
*
IVLN2_L
-
w
*
IVLN2
;
t1
=
with_set_low_word
(
u
+
v
0
)
;
t2
=
v
-
(
t1
-
u
)
;
}
else
{
let
mut
n
:
i32
=
0
;
if
ix
<
0x00100000
{
ax
*
=
TWO53
;
n
-
=
53
;
ix
=
get_high_word
(
ax
)
as
i32
;
}
n
+
=
(
ix
>
>
20
)
-
0x3ff
;
j
=
ix
&
0x000fffff
;
let
k
:
i32
;
ix
=
j
|
0x3ff00000
;
if
j
<
=
0x3988E
{
k
=
0
;
}
else
if
j
<
0xBB67A
{
k
=
1
;
}
else
{
k
=
0
;
n
+
=
1
;
ix
-
=
0x00100000
;
}
ax
=
with_set_high_word
(
ax
ix
as
u32
)
;
let
u
:
f64
=
ax
-
i
!
(
BP
k
as
usize
)
;
let
v
:
f64
=
1
.
0
/
(
ax
+
i
!
(
BP
k
as
usize
)
)
;
let
ss
:
f64
=
u
*
v
;
let
s_h
=
with_set_low_word
(
ss
0
)
;
let
t_h
:
f64
=
with_set_high_word
(
0
.
0
(
(
ix
as
u32
>
>
1
)
|
0x20000000
)
+
0x00080000
+
(
(
k
as
u32
)
<
<
18
)
)
;
let
t_l
:
f64
=
ax
-
(
t_h
-
i
!
(
BP
k
as
usize
)
)
;
let
s_l
:
f64
=
v
*
(
(
u
-
s_h
*
t_h
)
-
s_h
*
t_l
)
;
let
s2
:
f64
=
ss
*
ss
;
let
mut
r
:
f64
=
s2
*
s2
*
(
L1
+
s2
*
(
L2
+
s2
*
(
L3
+
s2
*
(
L4
+
s2
*
(
L5
+
s2
*
L6
)
)
)
)
)
;
r
+
=
s_l
*
(
s_h
+
ss
)
;
let
s2
:
f64
=
s_h
*
s_h
;
let
t_h
:
f64
=
with_set_low_word
(
3
.
0
+
s2
+
r
0
)
;
let
t_l
:
f64
=
r
-
(
(
t_h
-
3
.
0
)
-
s2
)
;
let
u
:
f64
=
s_h
*
t_h
;
let
v
:
f64
=
s_l
*
t_h
+
t_l
*
ss
;
let
p_h
:
f64
=
with_set_low_word
(
u
+
v
0
)
;
let
p_l
=
v
-
(
p_h
-
u
)
;
let
z_h
:
f64
=
CP_H
*
p_h
;
let
z_l
:
f64
=
CP_L
*
p_h
+
p_l
*
CP
+
i
!
(
DP_L
k
as
usize
)
;
let
t
:
f64
=
n
as
f64
;
t1
=
with_set_low_word
(
(
(
z_h
+
z_l
)
+
i
!
(
DP_H
k
as
usize
)
)
+
t
0
)
;
t2
=
z_l
-
(
(
(
t1
-
t
)
-
i
!
(
DP_H
k
as
usize
)
)
-
z_h
)
;
}
let
y1
:
f64
=
with_set_low_word
(
y
0
)
;
let
p_l
:
f64
=
(
y
-
y1
)
*
t1
+
y
*
t2
;
let
mut
p_h
:
f64
=
y1
*
t1
;
let
z
:
f64
=
p_l
+
p_h
;
let
mut
j
:
i32
=
(
z
.
to_bits
(
)
>
>
32
)
as
i32
;
let
i
:
i32
=
z
.
to_bits
(
)
as
i32
;
if
j
>
=
0x40900000
{
if
(
j
-
0x40900000
)
|
i
!
=
0
{
return
s
*
HUGE
*
HUGE
;
}
if
p_l
+
OVT
>
z
-
p_h
{
return
s
*
HUGE
*
HUGE
;
}
}
else
if
(
j
&
0x7fffffff
)
>
=
0x4090cc00
{
if
(
(
(
j
as
u32
)
-
0xc090cc00
)
|
(
i
as
u32
)
)
!
=
0
{
return
s
*
TINY
*
TINY
;
}
if
p_l
<
=
z
-
p_h
{
return
s
*
TINY
*
TINY
;
}
}
let
i
:
i32
=
j
&
(
0x7fffffff
as
i32
)
;
k
=
(
i
>
>
20
)
-
0x3ff
;
let
mut
n
:
i32
=
0
;
if
i
>
0x3fe00000
{
n
=
j
+
(
0x00100000
>
>
(
k
+
1
)
)
;
k
=
(
(
n
&
0x7fffffff
)
>
>
20
)
-
0x3ff
;
let
t
:
f64
=
with_set_high_word
(
0
.
0
(
n
&
!
(
0x000fffff
>
>
k
)
)
as
u32
)
;
n
=
(
(
n
&
0x000fffff
)
|
0x00100000
)
>
>
(
20
-
k
)
;
if
j
<
0
{
n
=
-
n
;
}
p_h
-
=
t
;
}
let
t
:
f64
=
with_set_low_word
(
p_l
+
p_h
0
)
;
let
u
:
f64
=
t
*
LG2_H
;
let
v
:
f64
=
(
p_l
-
(
t
-
p_h
)
)
*
LG2
+
t
*
LG2_L
;
let
mut
z
:
f64
=
u
+
v
;
let
w
:
f64
=
v
-
(
z
-
u
)
;
let
t
:
f64
=
z
*
z
;
let
t1
:
f64
=
z
-
t
*
(
P1
+
t
*
(
P2
+
t
*
(
P3
+
t
*
(
P4
+
t
*
P5
)
)
)
)
;
let
r
:
f64
=
(
z
*
t1
)
/
(
t1
-
2
.
0
)
-
(
w
+
z
*
w
)
;
z
=
1
.
0
-
(
r
-
z
)
;
j
=
get_high_word
(
z
)
as
i32
;
j
+
=
n
<
<
20
;
if
(
j
>
>
20
)
<
=
0
{
z
=
scalbnd
(
z
n
)
;
}
else
{
z
=
with_set_high_word
(
z
j
as
u32
)
;
}
s
*
z
}
pub
fn
fabsd
(
x
:
f64
)
-
>
f64
{
f64
:
:
from_bits
(
x
.
to_bits
(
)
&
(
u64
:
:
MAX
/
2
)
)
}
pub
fn
scalbnd
(
x
:
f64
mut
n
:
i32
)
-
>
f64
{
let
x1p1023
=
f64
:
:
from_bits
(
0x7fe0000000000000
)
;
let
x1p53
=
f64
:
:
from_bits
(
0x4340000000000000
)
;
let
x1p_1022
=
f64
:
:
from_bits
(
0x0010000000000000
)
;
let
mut
y
=
x
;
if
n
>
1023
{
y
*
=
x1p1023
;
n
-
=
1023
;
if
n
>
1023
{
y
*
=
x1p1023
;
n
-
=
1023
;
if
n
>
1023
{
n
=
1023
;
}
}
}
else
if
n
<
-
1022
{
y
*
=
x1p_1022
*
x1p53
;
n
+
=
1022
-
53
;
if
n
<
-
1022
{
y
*
=
x1p_1022
*
x1p53
;
n
+
=
1022
-
53
;
if
n
<
-
1022
{
n
=
-
1022
;
}
}
}
y
*
f64
:
:
from_bits
(
(
(
0x3ff
+
n
)
as
u64
)
<
<
52
)
}
pub
fn
sqrtd
(
x
:
f64
)
-
>
f64
{
#
[
cfg
(
target_feature
=
"
sse2
"
)
]
{
#
[
cfg
(
target_arch
=
"
x86
"
)
]
use
core
:
:
arch
:
:
x86
:
:
*
;
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
use
core
:
:
arch
:
:
x86_64
:
:
*
;
unsafe
{
let
m
=
_mm_set_sd
(
x
)
;
let
m_sqrt
=
_mm_sqrt_pd
(
m
)
;
_mm_cvtsd_f64
(
m_sqrt
)
}
}
#
[
cfg
(
not
(
target_feature
=
"
sse2
"
)
)
]
{
use
core
:
:
num
:
:
Wrapping
;
const
TINY
:
f64
=
1
.
0e
-
300
;
let
mut
z
:
f64
;
let
sign
:
Wrapping
<
u32
>
=
Wrapping
(
0x80000000
)
;
let
mut
ix0
:
i32
;
let
mut
s0
:
i32
;
let
mut
q
:
i32
;
let
mut
m
:
i32
;
let
mut
t
:
i32
;
let
mut
i
:
i32
;
let
mut
r
:
Wrapping
<
u32
>
;
let
mut
t1
:
Wrapping
<
u32
>
;
let
mut
s1
:
Wrapping
<
u32
>
;
let
mut
ix1
:
Wrapping
<
u32
>
;
let
mut
q1
:
Wrapping
<
u32
>
;
ix0
=
(
x
.
to_bits
(
)
>
>
32
)
as
i32
;
ix1
=
Wrapping
(
x
.
to_bits
(
)
as
u32
)
;
if
(
ix0
&
0x7ff00000
)
=
=
0x7ff00000
{
return
x
*
x
+
x
;
}
if
ix0
<
=
0
{
if
(
(
ix0
&
!
(
sign
.
0
as
i32
)
)
|
ix1
.
0
as
i32
)
=
=
0
{
return
x
;
}
if
ix0
<
0
{
return
(
x
-
x
)
/
(
x
-
x
)
;
}
}
m
=
ix0
>
>
20
;
if
m
=
=
0
{
while
ix0
=
=
0
{
m
-
=
21
;
ix0
|
=
(
ix1
>
>
11
)
.
0
as
i32
;
ix1
<
<
=
21
;
}
i
=
0
;
while
(
ix0
&
0x00100000
)
=
=
0
{
i
+
=
1
;
ix0
<
<
=
1
;
}
m
-
=
i
-
1
;
ix0
|
=
(
ix1
>
>
(
32
-
i
)
as
usize
)
.
0
as
i32
;
ix1
=
ix1
<
<
i
as
usize
;
}
m
-
=
1023
;
ix0
=
(
ix0
&
0x000fffff
)
|
0x00100000
;
if
(
m
&
1
)
=
=
1
{
ix0
+
=
ix0
+
(
(
ix1
&
sign
)
>
>
31
)
.
0
as
i32
;
ix1
+
=
ix1
;
}
m
>
>
=
1
;
ix0
+
=
ix0
+
(
(
ix1
&
sign
)
>
>
31
)
.
0
as
i32
;
ix1
+
=
ix1
;
q
=
0
;
q1
=
Wrapping
(
0
)
;
s0
=
0
;
s1
=
Wrapping
(
0
)
;
r
=
Wrapping
(
0x00200000
)
;
while
r
!
=
Wrapping
(
0
)
{
t
=
s0
+
r
.
0
as
i32
;
if
t
<
=
ix0
{
s0
=
t
+
r
.
0
as
i32
;
ix0
-
=
t
;
q
+
=
r
.
0
as
i32
;
}
ix0
+
=
ix0
+
(
(
ix1
&
sign
)
>
>
31
)
.
0
as
i32
;
ix1
+
=
ix1
;
r
>
>
=
1
;
}
r
=
sign
;
while
r
!
=
Wrapping
(
0
)
{
t1
=
s1
+
r
;
t
=
s0
;
if
t
<
ix0
|
|
(
t
=
=
ix0
&
&
t1
<
=
ix1
)
{
s1
=
t1
+
r
;
if
(
t1
&
sign
)
=
=
sign
&
&
(
s1
&
sign
)
=
=
Wrapping
(
0
)
{
s0
+
=
1
;
}
ix0
-
=
t
;
if
ix1
<
t1
{
ix0
-
=
1
;
}
ix1
-
=
t1
;
q1
+
=
r
;
}
ix0
+
=
ix0
+
(
(
ix1
&
sign
)
>
>
31
)
.
0
as
i32
;
ix1
+
=
ix1
;
r
>
>
=
1
;
}
if
(
ix0
as
u32
|
ix1
.
0
)
!
=
0
{
z
=
1
.
0
-
TINY
;
if
z
>
=
1
.
0
{
z
=
1
.
0
+
TINY
;
if
q1
.
0
=
=
0xffffffff
{
q1
=
Wrapping
(
0
)
;
q
+
=
1
;
}
else
if
z
>
1
.
0
{
if
q1
.
0
=
=
0xfffffffe
{
q
+
=
1
;
}
q1
+
=
Wrapping
(
2
)
;
}
else
{
q1
+
=
q1
&
Wrapping
(
1
)
;
}
}
}
ix0
=
(
q
>
>
1
)
+
0x3fe00000
;
ix1
=
q1
>
>
1
;
if
(
q
&
1
)
=
=
1
{
ix1
|
=
sign
;
}
ix0
+
=
m
<
<
20
;
f64
:
:
from_bits
(
(
ix0
as
u64
)
<
<
32
|
ix1
.
0
as
u64
)
}
}
#
[
inline
]
fn
get_high_word
(
x
:
f64
)
-
>
u32
{
(
x
.
to_bits
(
)
>
>
32
)
as
u32
}
#
[
inline
]
fn
with_set_high_word
(
f
:
f64
hi
:
u32
)
-
>
f64
{
let
mut
tmp
=
f
.
to_bits
(
)
;
tmp
&
=
0x00000000_ffffffff
;
tmp
|
=
(
hi
as
u64
)
<
<
32
;
f64
:
:
from_bits
(
tmp
)
}
#
[
inline
]
fn
with_set_low_word
(
f
:
f64
lo
:
u32
)
-
>
f64
{
let
mut
tmp
=
f
.
to_bits
(
)
;
tmp
&
=
0xffffffff_00000000
;
tmp
|
=
lo
as
u64
;
f64
:
:
from_bits
(
tmp
)
}
