#
!
[
cfg
(
not
(
feature
=
"
alloc
"
)
)
]
#
!
[
doc
(
hidden
)
]
use
crate
:
:
bigint
;
use
core
:
:
{
cmp
mem
ops
ptr
slice
}
;
#
[
derive
(
Clone
)
]
pub
struct
StackVec
{
data
:
[
mem
:
:
MaybeUninit
<
bigint
:
:
Limb
>
;
bigint
:
:
BIGINT_LIMBS
]
length
:
u16
}
#
[
allow
(
clippy
:
:
new_without_default
)
]
impl
StackVec
{
#
[
inline
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
length
:
0
data
:
[
mem
:
:
MaybeUninit
:
:
uninit
(
)
;
bigint
:
:
BIGINT_LIMBS
]
}
}
#
[
inline
]
pub
fn
try_from
(
x
:
&
[
bigint
:
:
Limb
]
)
-
>
Option
<
Self
>
{
let
mut
vec
=
Self
:
:
new
(
)
;
vec
.
try_extend
(
x
)
?
;
Some
(
vec
)
}
#
[
inline
]
pub
unsafe
fn
set_len
(
&
mut
self
len
:
usize
)
{
debug_assert
!
(
len
<
=
0xffff
)
;
debug_assert
!
(
len
<
=
bigint
:
:
BIGINT_LIMBS
)
;
self
.
length
=
len
as
u16
;
}
#
[
inline
]
pub
const
fn
len
(
&
self
)
-
>
usize
{
self
.
length
as
usize
}
#
[
inline
]
pub
const
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
#
[
inline
]
pub
const
fn
capacity
(
&
self
)
-
>
usize
{
bigint
:
:
BIGINT_LIMBS
as
usize
}
#
[
inline
]
pub
unsafe
fn
push_unchecked
(
&
mut
self
value
:
bigint
:
:
Limb
)
{
debug_assert
!
(
self
.
len
(
)
<
self
.
capacity
(
)
)
;
unsafe
{
ptr
:
:
write
(
self
.
as_mut_ptr
(
)
.
add
(
self
.
len
(
)
)
value
)
;
self
.
length
+
=
1
;
}
}
#
[
inline
]
pub
fn
try_push
(
&
mut
self
value
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
if
self
.
len
(
)
<
self
.
capacity
(
)
{
unsafe
{
self
.
push_unchecked
(
value
)
}
;
Some
(
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
unsafe
fn
pop_unchecked
(
&
mut
self
)
-
>
bigint
:
:
Limb
{
debug_assert
!
(
!
self
.
is_empty
(
)
)
;
self
.
length
-
=
1
;
unsafe
{
ptr
:
:
read
(
self
.
as_mut_ptr
(
)
.
add
(
self
.
len
(
)
)
)
}
}
#
[
inline
]
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
bigint
:
:
Limb
>
{
if
self
.
is_empty
(
)
{
None
}
else
{
unsafe
{
Some
(
self
.
pop_unchecked
(
)
)
}
}
}
#
[
inline
]
pub
unsafe
fn
extend_unchecked
(
&
mut
self
slc
:
&
[
bigint
:
:
Limb
]
)
{
let
index
=
self
.
len
(
)
;
let
new_len
=
index
+
slc
.
len
(
)
;
debug_assert
!
(
self
.
len
(
)
+
slc
.
len
(
)
<
=
self
.
capacity
(
)
)
;
let
src
=
slc
.
as_ptr
(
)
;
unsafe
{
let
dst
=
self
.
as_mut_ptr
(
)
.
add
(
index
)
;
ptr
:
:
copy_nonoverlapping
(
src
dst
slc
.
len
(
)
)
;
self
.
set_len
(
new_len
)
;
}
}
#
[
inline
]
pub
fn
try_extend
(
&
mut
self
slc
:
&
[
bigint
:
:
Limb
]
)
-
>
Option
<
(
)
>
{
if
self
.
len
(
)
+
slc
.
len
(
)
<
=
self
.
capacity
(
)
{
unsafe
{
self
.
extend_unchecked
(
slc
)
}
;
Some
(
(
)
)
}
else
{
None
}
}
unsafe
fn
truncate_unchecked
(
&
mut
self
len
:
usize
)
{
debug_assert
!
(
len
<
=
self
.
capacity
(
)
)
;
self
.
length
=
len
as
u16
;
}
#
[
inline
]
pub
unsafe
fn
resize_unchecked
(
&
mut
self
len
:
usize
value
:
bigint
:
:
Limb
)
{
debug_assert
!
(
len
<
=
self
.
capacity
(
)
)
;
let
old_len
=
self
.
len
(
)
;
if
len
>
old_len
{
let
count
=
len
-
old_len
;
for
index
in
0
.
.
count
{
unsafe
{
let
dst
=
self
.
as_mut_ptr
(
)
.
add
(
old_len
+
index
)
;
ptr
:
:
write
(
dst
value
)
;
}
}
self
.
length
=
len
as
u16
;
}
else
{
unsafe
{
self
.
truncate_unchecked
(
len
)
}
;
}
}
#
[
inline
]
pub
fn
try_resize
(
&
mut
self
len
:
usize
value
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
if
len
>
self
.
capacity
(
)
{
None
}
else
{
unsafe
{
self
.
resize_unchecked
(
len
value
)
}
;
Some
(
(
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
hi64
(
&
self
)
-
>
(
u64
bool
)
{
bigint
:
:
hi64
(
self
)
}
#
[
inline
(
always
)
]
pub
fn
from_u64
(
x
:
u64
)
-
>
Self
{
bigint
:
:
from_u64
(
x
)
}
#
[
inline
]
pub
fn
normalize
(
&
mut
self
)
{
bigint
:
:
normalize
(
self
)
}
#
[
inline
]
pub
fn
is_normalized
(
&
self
)
-
>
bool
{
bigint
:
:
is_normalized
(
self
)
}
#
[
inline
]
pub
fn
add_small
(
&
mut
self
y
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
bigint
:
:
small_add
(
self
y
)
}
#
[
inline
]
pub
fn
mul_small
(
&
mut
self
y
:
bigint
:
:
Limb
)
-
>
Option
<
(
)
>
{
bigint
:
:
small_mul
(
self
y
)
}
}
impl
PartialEq
for
StackVec
{
#
[
inline
]
#
[
allow
(
clippy
:
:
op_ref
)
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
use
core
:
:
ops
:
:
Deref
;
self
.
len
(
)
=
=
other
.
len
(
)
&
&
self
.
deref
(
)
=
=
other
.
deref
(
)
}
}
impl
Eq
for
StackVec
{
}
impl
cmp
:
:
PartialOrd
for
StackVec
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
Some
(
bigint
:
:
compare
(
self
other
)
)
}
}
impl
cmp
:
:
Ord
for
StackVec
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
bigint
:
:
compare
(
self
other
)
}
}
impl
ops
:
:
Deref
for
StackVec
{
type
Target
=
[
bigint
:
:
Limb
]
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
[
bigint
:
:
Limb
]
{
unsafe
{
let
ptr
=
self
.
data
.
as_ptr
(
)
as
*
const
bigint
:
:
Limb
;
slice
:
:
from_raw_parts
(
ptr
self
.
len
(
)
)
}
}
}
impl
ops
:
:
DerefMut
for
StackVec
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
bigint
:
:
Limb
]
{
unsafe
{
let
ptr
=
self
.
data
.
as_mut_ptr
(
)
as
*
mut
bigint
:
:
Limb
;
slice
:
:
from_raw_parts_mut
(
ptr
self
.
len
(
)
)
}
}
}
impl
ops
:
:
MulAssign
<
&
[
bigint
:
:
Limb
]
>
for
StackVec
{
#
[
inline
]
fn
mul_assign
(
&
mut
self
rhs
:
&
[
bigint
:
:
Limb
]
)
{
bigint
:
:
large_mul
(
self
rhs
)
.
unwrap
(
)
;
}
}
