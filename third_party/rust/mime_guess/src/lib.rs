#
!
[
cfg_attr
(
feature
=
"
bench
"
feature
(
test
)
)
]
extern
crate
mime
;
extern
crate
phf
;
extern
crate
unicase
;
pub
use
mime
:
:
Mime
;
use
unicase
:
:
UniCase
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
path
:
:
Path
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
mime_types_generated
.
rs
"
)
)
;
struct
TopLevelExts
{
start
:
usize
end
:
usize
subs
:
phf
:
:
Map
<
UniCase
<
&
'
static
str
>
(
usize
usize
)
>
}
macro_rules
!
try_opt
(
(
expr
:
expr
)
=
>
(
match
expr
{
Some
(
val
)
=
>
val
None
=
>
return
None
}
)
)
;
#
[
cfg
(
test
)
]
#
[
path
=
"
mime_types
.
rs
"
]
mod
mime_types_src
;
pub
fn
guess_mime_type
<
P
:
AsRef
<
Path
>
>
(
path
:
P
)
-
>
Mime
{
guess_mime_type_opt
(
path
)
.
unwrap_or_else
(
octet_stream
)
}
pub
fn
guess_mime_type_opt
<
P
:
AsRef
<
Path
>
>
(
path
:
P
)
-
>
Option
<
Mime
>
{
let
ext
=
path
.
as_ref
(
)
.
extension
(
)
.
and_then
(
OsStr
:
:
to_str
)
.
unwrap_or
(
"
"
)
;
get_mime_type_opt
(
ext
)
}
pub
fn
get_mime_type
(
search_ext
:
&
str
)
-
>
Mime
{
get_mime_type_opt
(
search_ext
)
.
unwrap_or_else
(
octet_stream
)
}
pub
fn
get_mime_type_opt
(
search_ext
:
&
str
)
-
>
Option
<
Mime
>
{
get_mime_type_str
(
search_ext
)
.
map
(
|
mime
|
mime
.
parse
:
:
<
Mime
>
(
)
.
unwrap
(
)
)
}
pub
fn
get_mime_type_str
(
search_ext
:
&
str
)
-
>
Option
<
&
'
static
str
>
{
if
search_ext
.
is_empty
(
)
{
return
None
;
}
map_lookup
(
&
MIME_TYPES
search_ext
)
.
cloned
(
)
}
pub
fn
get_mime_extensions
(
mime
:
&
Mime
)
-
>
Option
<
&
'
static
[
&
'
static
str
]
>
{
get_extensions
(
mime
.
type_
(
)
.
as_ref
(
)
mime
.
subtype
(
)
.
as_ref
(
)
)
}
pub
fn
get_mime_extensions_str
(
mut
mime_str
:
&
str
)
-
>
Option
<
&
'
static
[
&
'
static
str
]
>
{
mime_str
=
mime_str
.
trim
(
)
;
if
let
Some
(
sep_idx
)
=
mime_str
.
find
(
'
;
'
)
{
mime_str
=
&
mime_str
[
.
.
sep_idx
]
;
}
let
(
top
sub
)
=
{
let
split_idx
=
mime_str
.
find
(
'
/
'
)
.
unwrap
(
)
;
(
&
mime_str
[
.
.
split_idx
]
&
mime_str
[
split_idx
+
1
.
.
]
)
}
;
get_extensions
(
top
sub
)
}
pub
fn
get_extensions
(
toplevel
:
&
str
sublevel
:
&
str
)
-
>
Option
<
&
'
static
[
&
'
static
str
]
>
{
if
toplevel
=
=
"
*
"
{
return
Some
(
EXTS
)
;
}
let
top
=
try_opt
!
(
map_lookup
(
&
REV_MAPPINGS
toplevel
)
)
;
if
sublevel
=
=
"
*
"
{
return
Some
(
&
EXTS
[
top
.
start
.
.
top
.
end
]
)
;
}
let
sub
=
try_opt
!
(
map_lookup
(
&
top
.
subs
sublevel
)
)
;
Some
(
&
EXTS
[
sub
.
0
.
.
sub
.
1
]
)
}
pub
fn
octet_stream
(
)
-
>
Mime
{
"
application
/
octet
-
stream
"
.
parse
(
)
.
unwrap
(
)
}
fn
map_lookup
<
'
map
V
>
(
map
:
&
'
map
phf
:
:
Map
<
UniCase
<
&
'
static
str
>
V
>
key
:
&
str
)
-
>
Option
<
&
'
map
V
>
{
let
key
=
unsafe
{
:
:
std
:
:
mem
:
:
transmute
:
:
<
_
&
'
static
str
>
(
key
)
}
;
map
.
get
(
&
UniCase
(
key
)
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
mime
:
:
Mime
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
std
:
:
path
:
:
Path
;
use
super
:
:
{
get_mime_type
guess_mime_type
MIME_TYPES
}
;
use
super
:
:
{
get_mime_type_opt
guess_mime_type_opt
}
;
#
[
test
]
fn
test_mime_type_guessing
(
)
{
assert_eq
!
(
get_mime_type
(
"
gif
"
)
.
to_string
(
)
"
image
/
gif
"
.
to_string
(
)
)
;
assert_eq
!
(
get_mime_type
(
"
TXT
"
)
.
to_string
(
)
"
text
/
plain
"
.
to_string
(
)
)
;
assert_eq
!
(
get_mime_type
(
"
blahblah
"
)
.
to_string
(
)
"
application
/
octet
-
stream
"
.
to_string
(
)
)
;
assert_eq
!
(
guess_mime_type
(
Path
:
:
new
(
"
/
path
/
to
/
file
.
gif
"
)
)
.
to_string
(
)
"
image
/
gif
"
.
to_string
(
)
)
;
assert_eq
!
(
guess_mime_type
(
"
/
path
/
to
/
file
.
gif
"
)
.
to_string
(
)
"
image
/
gif
"
.
to_string
(
)
)
;
}
#
[
test
]
fn
test_mime_type_guessing_opt
(
)
{
assert_eq
!
(
get_mime_type_opt
(
"
gif
"
)
.
unwrap
(
)
.
to_string
(
)
"
image
/
gif
"
.
to_string
(
)
)
;
assert_eq
!
(
get_mime_type_opt
(
"
TXT
"
)
.
unwrap
(
)
.
to_string
(
)
"
text
/
plain
"
.
to_string
(
)
)
;
assert_eq
!
(
get_mime_type_opt
(
"
blahblah
"
)
None
)
;
assert_eq
!
(
guess_mime_type_opt
(
"
/
path
/
to
/
file
.
gif
"
)
.
unwrap
(
)
.
to_string
(
)
"
image
/
gif
"
.
to_string
(
)
)
;
assert_eq
!
(
guess_mime_type_opt
(
"
/
path
/
to
/
file
"
)
None
)
;
}
#
[
test
]
fn
test_are_mime_types_parseable
(
)
{
for
(
_
mime
)
in
&
MIME_TYPES
{
mime
.
parse
:
:
<
Mime
>
(
)
.
unwrap
(
)
;
}
}
#
[
test
]
fn
test_are_extensions_ascii
(
)
{
for
(
ext
_
)
in
&
MIME_TYPES
{
assert
!
(
ext
.
is_ascii
(
)
"
Extension
not
ASCII
:
{
:
?
}
"
ext
)
;
}
}
#
[
test
]
fn
test_are_extensions_sorted
(
)
{
use
mime_types_src
:
:
MIME_TYPES
;
for
(
&
(
ext
_
)
&
(
n_ext
_
)
)
in
MIME_TYPES
.
iter
(
)
.
zip
(
MIME_TYPES
.
iter
(
)
.
skip
(
1
)
)
{
assert
!
(
ext
<
=
n_ext
"
Extensions
in
src
/
mime_types
should
be
sorted
alphabetically
in
ascending
order
.
Failed
assert
:
{
:
?
}
<
=
{
:
?
}
"
ext
n_ext
)
;
}
}
}
#
[
cfg
(
feature
=
"
bench
"
)
]
mod
bench
{
extern
crate
test
;
use
self
:
:
test
:
:
Bencher
;
use
super
:
:
{
get_mime_type_str
MIME_TYPES
}
;
#
[
bench
]
fn
bench_mime_str
(
b
:
&
mut
Bencher
)
{
for
(
mime_ext
_
)
in
&
MIME_TYPES
{
b
.
iter
(
|
|
{
get_mime_type_str
(
mime_ext
)
.
expect
(
mime_ext
)
;
}
)
;
}
}
#
[
bench
]
fn
bench_mime_str_uppercase
(
b
:
&
mut
Bencher
)
{
let
uppercased
:
Vec
<
_
>
=
MIME_TYPES
.
into_iter
(
)
.
map
(
|
(
s
_
)
|
s
.
to_uppercase
(
)
)
.
collect
(
)
;
for
mime_ext
in
&
uppercased
{
b
.
iter
(
|
|
{
get_mime_type_str
(
mime_ext
)
.
expect
(
mime_ext
)
;
}
)
;
}
}
}
