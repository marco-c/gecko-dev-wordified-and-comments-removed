use
alloc
:
:
vec
:
:
Vec
;
use
super
:
:
*
;
#
[
deprecated
(
since
=
"
0
.
3
.
0
"
note
=
"
please
use
BidiInfo
:
:
visual_runs
(
)
instead
.
"
)
]
pub
fn
visual_runs
(
line
:
Range
<
usize
>
levels
:
&
[
Level
]
)
-
>
Vec
<
LevelRun
>
{
assert
!
(
line
.
start
<
=
levels
.
len
(
)
)
;
assert
!
(
line
.
end
<
=
levels
.
len
(
)
)
;
let
mut
runs
=
Vec
:
:
new
(
)
;
let
mut
start
=
line
.
start
;
let
mut
run_level
=
levels
[
start
]
;
let
mut
min_level
=
run_level
;
let
mut
max_level
=
run_level
;
for
(
i
&
new_level
)
in
levels
.
iter
(
)
.
enumerate
(
)
.
take
(
line
.
end
)
.
skip
(
start
+
1
)
{
if
new_level
!
=
run_level
{
runs
.
push
(
start
.
.
i
)
;
start
=
i
;
run_level
=
new_level
;
min_level
=
min
(
run_level
min_level
)
;
max_level
=
max
(
run_level
max_level
)
;
}
}
runs
.
push
(
start
.
.
line
.
end
)
;
let
run_count
=
runs
.
len
(
)
;
min_level
=
min_level
.
new_lowest_ge_rtl
(
)
.
expect
(
"
Level
error
"
)
;
while
max_level
>
=
min_level
{
let
mut
seq_start
=
0
;
while
seq_start
<
run_count
{
if
levels
[
runs
[
seq_start
]
.
start
]
<
max_level
{
seq_start
+
=
1
;
continue
;
}
let
mut
seq_end
=
seq_start
+
1
;
while
seq_end
<
run_count
{
if
levels
[
runs
[
seq_end
]
.
start
]
<
max_level
{
break
;
}
seq_end
+
=
1
;
}
runs
[
seq_start
.
.
seq_end
]
.
reverse
(
)
;
seq_start
=
seq_end
;
}
max_level
.
lower
(
1
)
.
expect
(
"
Lowering
embedding
level
below
zero
"
)
;
}
runs
}
