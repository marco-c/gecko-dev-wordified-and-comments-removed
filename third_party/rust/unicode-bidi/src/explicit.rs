use
alloc
:
:
vec
:
:
Vec
;
use
super
:
:
char_data
:
:
{
is_rtl
BidiClass
:
:
{
self
*
}
}
;
use
super
:
:
level
:
:
Level
;
#
[
cfg_attr
(
feature
=
"
flame_it
"
flamer
:
:
flame
)
]
pub
fn
compute
(
text
:
&
str
para_level
:
Level
original_classes
:
&
[
BidiClass
]
levels
:
&
mut
[
Level
]
processing_classes
:
&
mut
[
BidiClass
]
)
{
assert_eq
!
(
text
.
len
(
)
original_classes
.
len
(
)
)
;
let
mut
stack
=
DirectionalStatusStack
:
:
new
(
)
;
stack
.
push
(
para_level
OverrideStatus
:
:
Neutral
)
;
let
mut
overflow_isolate_count
=
0u32
;
let
mut
overflow_embedding_count
=
0u32
;
let
mut
valid_isolate_count
=
0u32
;
for
(
i
c
)
in
text
.
char_indices
(
)
{
match
original_classes
[
i
]
{
RLE
|
LRE
|
RLO
|
LRO
|
RLI
|
LRI
|
FSI
=
>
{
let
last_level
=
stack
.
last
(
)
.
level
;
levels
[
i
]
=
last_level
;
let
is_isolate
=
match
original_classes
[
i
]
{
RLI
|
LRI
|
FSI
=
>
true
_
=
>
false
}
;
if
is_isolate
{
match
stack
.
last
(
)
.
status
{
OverrideStatus
:
:
RTL
=
>
processing_classes
[
i
]
=
R
OverrideStatus
:
:
LTR
=
>
processing_classes
[
i
]
=
L
_
=
>
{
}
}
}
let
new_level
=
if
is_rtl
(
original_classes
[
i
]
)
{
last_level
.
new_explicit_next_rtl
(
)
}
else
{
last_level
.
new_explicit_next_ltr
(
)
}
;
if
new_level
.
is_ok
(
)
&
&
overflow_isolate_count
=
=
0
&
&
overflow_embedding_count
=
=
0
{
let
new_level
=
new_level
.
unwrap
(
)
;
stack
.
push
(
new_level
match
original_classes
[
i
]
{
RLO
=
>
OverrideStatus
:
:
RTL
LRO
=
>
OverrideStatus
:
:
LTR
RLI
|
LRI
|
FSI
=
>
OverrideStatus
:
:
Isolate
_
=
>
OverrideStatus
:
:
Neutral
}
)
;
if
is_isolate
{
valid_isolate_count
+
=
1
;
}
else
{
levels
[
i
]
=
new_level
;
}
}
else
if
is_isolate
{
overflow_isolate_count
+
=
1
;
}
else
if
overflow_isolate_count
=
=
0
{
overflow_embedding_count
+
=
1
;
}
if
!
is_isolate
{
processing_classes
[
i
]
=
BN
;
}
}
PDI
=
>
{
if
overflow_isolate_count
>
0
{
overflow_isolate_count
-
=
1
;
}
else
if
valid_isolate_count
>
0
{
overflow_embedding_count
=
0
;
loop
{
match
stack
.
vec
.
pop
(
)
{
None
|
Some
(
Status
{
status
:
OverrideStatus
:
:
Isolate
.
.
}
)
=
>
break
_
=
>
continue
}
}
valid_isolate_count
-
=
1
;
}
let
last
=
stack
.
last
(
)
;
levels
[
i
]
=
last
.
level
;
match
last
.
status
{
OverrideStatus
:
:
RTL
=
>
processing_classes
[
i
]
=
R
OverrideStatus
:
:
LTR
=
>
processing_classes
[
i
]
=
L
_
=
>
{
}
}
}
PDF
=
>
{
if
overflow_isolate_count
>
0
{
}
else
if
overflow_embedding_count
>
0
{
overflow_embedding_count
-
=
1
;
}
else
if
stack
.
last
(
)
.
status
!
=
OverrideStatus
:
:
Isolate
&
&
stack
.
vec
.
len
(
)
>
=
2
{
stack
.
vec
.
pop
(
)
;
}
levels
[
i
]
=
stack
.
last
(
)
.
level
;
processing_classes
[
i
]
=
BN
;
}
B
=
>
{
}
_
=
>
{
let
last
=
stack
.
last
(
)
;
levels
[
i
]
=
last
.
level
;
if
original_classes
[
i
]
!
=
BN
{
match
last
.
status
{
OverrideStatus
:
:
RTL
=
>
processing_classes
[
i
]
=
R
OverrideStatus
:
:
LTR
=
>
processing_classes
[
i
]
=
L
_
=
>
{
}
}
}
}
}
for
j
in
1
.
.
c
.
len_utf8
(
)
{
levels
[
i
+
j
]
=
levels
[
i
]
;
processing_classes
[
i
+
j
]
=
processing_classes
[
i
]
;
}
}
}
struct
Status
{
level
:
Level
status
:
OverrideStatus
}
#
[
derive
(
PartialEq
)
]
enum
OverrideStatus
{
Neutral
RTL
LTR
Isolate
}
struct
DirectionalStatusStack
{
vec
:
Vec
<
Status
>
}
impl
DirectionalStatusStack
{
fn
new
(
)
-
>
Self
{
DirectionalStatusStack
{
vec
:
Vec
:
:
with_capacity
(
Level
:
:
max_explicit_depth
(
)
as
usize
+
2
)
}
}
fn
push
(
&
mut
self
level
:
Level
status
:
OverrideStatus
)
{
self
.
vec
.
push
(
Status
{
level
status
}
)
;
}
fn
last
(
&
self
)
-
>
&
Status
{
self
.
vec
.
last
(
)
.
unwrap
(
)
}
}
