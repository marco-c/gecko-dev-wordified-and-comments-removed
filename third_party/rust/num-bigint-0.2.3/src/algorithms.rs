use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
cmp
;
use
std
:
:
cmp
:
:
Ordering
:
:
{
self
Equal
Greater
Less
}
;
use
std
:
:
iter
:
:
repeat
;
use
std
:
:
mem
;
use
traits
;
use
traits
:
:
{
One
Zero
}
;
use
biguint
:
:
BigUint
;
use
bigint
:
:
BigInt
;
use
bigint
:
:
Sign
;
use
bigint
:
:
Sign
:
:
{
Minus
NoSign
Plus
}
;
use
big_digit
:
:
{
self
BigDigit
DoubleBigDigit
SignedDoubleBigDigit
}
;
#
[
inline
]
fn
adc
(
a
:
BigDigit
b
:
BigDigit
acc
:
&
mut
DoubleBigDigit
)
-
>
BigDigit
{
*
acc
+
=
DoubleBigDigit
:
:
from
(
a
)
;
*
acc
+
=
DoubleBigDigit
:
:
from
(
b
)
;
let
lo
=
*
acc
as
BigDigit
;
*
acc
>
>
=
big_digit
:
:
BITS
;
lo
}
#
[
inline
]
fn
sbb
(
a
:
BigDigit
b
:
BigDigit
acc
:
&
mut
SignedDoubleBigDigit
)
-
>
BigDigit
{
*
acc
+
=
SignedDoubleBigDigit
:
:
from
(
a
)
;
*
acc
-
=
SignedDoubleBigDigit
:
:
from
(
b
)
;
let
lo
=
*
acc
as
BigDigit
;
*
acc
>
>
=
big_digit
:
:
BITS
;
lo
}
#
[
inline
]
pub
fn
mac_with_carry
(
a
:
BigDigit
b
:
BigDigit
c
:
BigDigit
acc
:
&
mut
DoubleBigDigit
)
-
>
BigDigit
{
*
acc
+
=
DoubleBigDigit
:
:
from
(
a
)
;
*
acc
+
=
DoubleBigDigit
:
:
from
(
b
)
*
DoubleBigDigit
:
:
from
(
c
)
;
let
lo
=
*
acc
as
BigDigit
;
*
acc
>
>
=
big_digit
:
:
BITS
;
lo
}
#
[
inline
]
pub
fn
mul_with_carry
(
a
:
BigDigit
b
:
BigDigit
acc
:
&
mut
DoubleBigDigit
)
-
>
BigDigit
{
*
acc
+
=
DoubleBigDigit
:
:
from
(
a
)
*
DoubleBigDigit
:
:
from
(
b
)
;
let
lo
=
*
acc
as
BigDigit
;
*
acc
>
>
=
big_digit
:
:
BITS
;
lo
}
#
[
inline
]
fn
div_wide
(
hi
:
BigDigit
lo
:
BigDigit
divisor
:
BigDigit
)
-
>
(
BigDigit
BigDigit
)
{
debug_assert
!
(
hi
<
divisor
)
;
let
lhs
=
big_digit
:
:
to_doublebigdigit
(
hi
lo
)
;
let
rhs
=
DoubleBigDigit
:
:
from
(
divisor
)
;
(
(
lhs
/
rhs
)
as
BigDigit
(
lhs
%
rhs
)
as
BigDigit
)
}
pub
fn
div_rem_digit
(
mut
a
:
BigUint
b
:
BigDigit
)
-
>
(
BigUint
BigDigit
)
{
let
mut
rem
=
0
;
for
d
in
a
.
data
.
iter_mut
(
)
.
rev
(
)
{
let
(
q
r
)
=
div_wide
(
rem
*
d
b
)
;
*
d
=
q
;
rem
=
r
;
}
(
a
.
normalized
(
)
rem
)
}
pub
fn
rem_digit
(
a
:
&
BigUint
b
:
BigDigit
)
-
>
BigDigit
{
let
mut
rem
:
DoubleBigDigit
=
0
;
for
&
digit
in
a
.
data
.
iter
(
)
.
rev
(
)
{
rem
=
(
rem
<
<
big_digit
:
:
BITS
)
+
DoubleBigDigit
:
:
from
(
digit
)
;
rem
%
=
DoubleBigDigit
:
:
from
(
b
)
;
}
rem
as
BigDigit
}
#
[
inline
]
pub
fn
__add2
(
a
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
)
-
>
BigDigit
{
debug_assert
!
(
a
.
len
(
)
>
=
b
.
len
(
)
)
;
let
mut
carry
=
0
;
let
(
a_lo
a_hi
)
=
a
.
split_at_mut
(
b
.
len
(
)
)
;
for
(
a
b
)
in
a_lo
.
iter_mut
(
)
.
zip
(
b
)
{
*
a
=
adc
(
*
a
*
b
&
mut
carry
)
;
}
if
carry
!
=
0
{
for
a
in
a_hi
{
*
a
=
adc
(
*
a
0
&
mut
carry
)
;
if
carry
=
=
0
{
break
;
}
}
}
carry
as
BigDigit
}
pub
fn
add2
(
a
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
)
{
let
carry
=
__add2
(
a
b
)
;
debug_assert
!
(
carry
=
=
0
)
;
}
pub
fn
sub2
(
a
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
)
{
let
mut
borrow
=
0
;
let
len
=
cmp
:
:
min
(
a
.
len
(
)
b
.
len
(
)
)
;
let
(
a_lo
a_hi
)
=
a
.
split_at_mut
(
len
)
;
let
(
b_lo
b_hi
)
=
b
.
split_at
(
len
)
;
for
(
a
b
)
in
a_lo
.
iter_mut
(
)
.
zip
(
b_lo
)
{
*
a
=
sbb
(
*
a
*
b
&
mut
borrow
)
;
}
if
borrow
!
=
0
{
for
a
in
a_hi
{
*
a
=
sbb
(
*
a
0
&
mut
borrow
)
;
if
borrow
=
=
0
{
break
;
}
}
}
assert
!
(
borrow
=
=
0
&
&
b_hi
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
0
)
"
Cannot
subtract
b
from
a
because
b
is
larger
than
a
.
"
)
;
}
#
[
inline
]
pub
fn
__sub2rev
(
a
:
&
[
BigDigit
]
b
:
&
mut
[
BigDigit
]
)
-
>
BigDigit
{
debug_assert
!
(
b
.
len
(
)
=
=
a
.
len
(
)
)
;
let
mut
borrow
=
0
;
for
(
ai
bi
)
in
a
.
iter
(
)
.
zip
(
b
)
{
*
bi
=
sbb
(
*
ai
*
bi
&
mut
borrow
)
;
}
borrow
as
BigDigit
}
pub
fn
sub2rev
(
a
:
&
[
BigDigit
]
b
:
&
mut
[
BigDigit
]
)
{
debug_assert
!
(
b
.
len
(
)
>
=
a
.
len
(
)
)
;
let
len
=
cmp
:
:
min
(
a
.
len
(
)
b
.
len
(
)
)
;
let
(
a_lo
a_hi
)
=
a
.
split_at
(
len
)
;
let
(
b_lo
b_hi
)
=
b
.
split_at_mut
(
len
)
;
let
borrow
=
__sub2rev
(
a_lo
b_lo
)
;
assert
!
(
a_hi
.
is_empty
(
)
)
;
assert
!
(
borrow
=
=
0
&
&
b_hi
.
iter
(
)
.
all
(
|
x
|
*
x
=
=
0
)
"
Cannot
subtract
b
from
a
because
b
is
larger
than
a
.
"
)
;
}
pub
fn
sub_sign
(
a
:
&
[
BigDigit
]
b
:
&
[
BigDigit
]
)
-
>
(
Sign
BigUint
)
{
let
a
=
&
a
[
.
.
a
.
iter
(
)
.
rposition
(
|
&
x
|
x
!
=
0
)
.
map_or
(
0
|
i
|
i
+
1
)
]
;
let
b
=
&
b
[
.
.
b
.
iter
(
)
.
rposition
(
|
&
x
|
x
!
=
0
)
.
map_or
(
0
|
i
|
i
+
1
)
]
;
match
cmp_slice
(
a
b
)
{
Greater
=
>
{
let
mut
a
=
a
.
to_vec
(
)
;
sub2
(
&
mut
a
b
)
;
(
Plus
BigUint
:
:
new
(
a
)
)
}
Less
=
>
{
let
mut
b
=
b
.
to_vec
(
)
;
sub2
(
&
mut
b
a
)
;
(
Minus
BigUint
:
:
new
(
b
)
)
}
_
=
>
(
NoSign
Zero
:
:
zero
(
)
)
}
}
pub
fn
mac_digit
(
acc
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
c
:
BigDigit
)
{
if
c
=
=
0
{
return
;
}
let
mut
carry
=
0
;
let
(
a_lo
a_hi
)
=
acc
.
split_at_mut
(
b
.
len
(
)
)
;
for
(
a
&
b
)
in
a_lo
.
iter_mut
(
)
.
zip
(
b
)
{
*
a
=
mac_with_carry
(
*
a
b
c
&
mut
carry
)
;
}
let
mut
a
=
a_hi
.
iter_mut
(
)
;
while
carry
!
=
0
{
let
a
=
a
.
next
(
)
.
expect
(
"
carry
overflow
during
multiplication
!
"
)
;
*
a
=
adc
(
*
a
0
&
mut
carry
)
;
}
}
fn
mac3
(
acc
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
c
:
&
[
BigDigit
]
)
{
let
(
x
y
)
=
if
b
.
len
(
)
<
c
.
len
(
)
{
(
b
c
)
}
else
{
(
c
b
)
}
;
if
x
.
len
(
)
<
=
32
{
for
(
i
xi
)
in
x
.
iter
(
)
.
enumerate
(
)
{
mac_digit
(
&
mut
acc
[
i
.
.
]
y
*
xi
)
;
}
}
else
if
x
.
len
(
)
<
=
256
{
let
b
=
x
.
len
(
)
/
2
;
let
(
x0
x1
)
=
x
.
split_at
(
b
)
;
let
(
y0
y1
)
=
y
.
split_at
(
b
)
;
let
len
=
x1
.
len
(
)
+
y1
.
len
(
)
+
1
;
let
mut
p
=
BigUint
{
data
:
vec
!
[
0
;
len
]
}
;
mac3
(
&
mut
p
.
data
[
.
.
]
x1
y1
)
;
p
.
normalize
(
)
;
add2
(
&
mut
acc
[
b
.
.
]
&
p
.
data
[
.
.
]
)
;
add2
(
&
mut
acc
[
b
*
2
.
.
]
&
p
.
data
[
.
.
]
)
;
p
.
data
.
truncate
(
0
)
;
p
.
data
.
extend
(
repeat
(
0
)
.
take
(
len
)
)
;
mac3
(
&
mut
p
.
data
[
.
.
]
x0
y0
)
;
p
.
normalize
(
)
;
add2
(
&
mut
acc
[
.
.
]
&
p
.
data
[
.
.
]
)
;
add2
(
&
mut
acc
[
b
.
.
]
&
p
.
data
[
.
.
]
)
;
let
(
j0_sign
j0
)
=
sub_sign
(
x1
x0
)
;
let
(
j1_sign
j1
)
=
sub_sign
(
y1
y0
)
;
match
j0_sign
*
j1_sign
{
Plus
=
>
{
p
.
data
.
truncate
(
0
)
;
p
.
data
.
extend
(
repeat
(
0
)
.
take
(
len
)
)
;
mac3
(
&
mut
p
.
data
[
.
.
]
&
j0
.
data
[
.
.
]
&
j1
.
data
[
.
.
]
)
;
p
.
normalize
(
)
;
sub2
(
&
mut
acc
[
b
.
.
]
&
p
.
data
[
.
.
]
)
;
}
Minus
=
>
{
mac3
(
&
mut
acc
[
b
.
.
]
&
j0
.
data
[
.
.
]
&
j1
.
data
[
.
.
]
)
;
}
NoSign
=
>
(
)
}
}
else
{
let
i
=
y
.
len
(
)
/
3
+
1
;
let
x0_len
=
cmp
:
:
min
(
x
.
len
(
)
i
)
;
let
x1_len
=
cmp
:
:
min
(
x
.
len
(
)
-
x0_len
i
)
;
let
y0_len
=
i
;
let
y1_len
=
cmp
:
:
min
(
y
.
len
(
)
-
y0_len
i
)
;
let
x0
=
BigInt
:
:
from_slice
(
Plus
&
x
[
.
.
x0_len
]
)
;
let
x1
=
BigInt
:
:
from_slice
(
Plus
&
x
[
x0_len
.
.
x0_len
+
x1_len
]
)
;
let
x2
=
BigInt
:
:
from_slice
(
Plus
&
x
[
x0_len
+
x1_len
.
.
]
)
;
let
y0
=
BigInt
:
:
from_slice
(
Plus
&
y
[
.
.
y0_len
]
)
;
let
y1
=
BigInt
:
:
from_slice
(
Plus
&
y
[
y0_len
.
.
y0_len
+
y1_len
]
)
;
let
y2
=
BigInt
:
:
from_slice
(
Plus
&
y
[
y0_len
+
y1_len
.
.
]
)
;
let
p
=
&
x0
+
&
x2
;
let
q
=
&
y0
+
&
y2
;
let
p2
=
&
p
-
&
x1
;
let
q2
=
&
q
-
&
y1
;
let
r0
=
&
x0
*
&
y0
;
let
r4
=
&
x2
*
&
y2
;
let
r1
=
(
p
+
x1
)
*
(
q
+
y1
)
;
let
r2
=
&
p2
*
&
q2
;
let
r3
=
(
(
p2
+
x2
)
*
2
-
x0
)
*
(
(
q2
+
y2
)
*
2
-
y0
)
;
let
mut
comp3
:
BigInt
=
(
r3
-
&
r1
)
/
3
;
let
mut
comp1
:
BigInt
=
(
r1
-
&
r2
)
/
2
;
let
mut
comp2
:
BigInt
=
r2
-
&
r0
;
comp3
=
(
&
comp2
-
comp3
)
/
2
+
&
r4
*
2
;
comp2
=
comp2
+
&
comp1
-
&
r4
;
comp1
=
comp1
-
&
comp3
;
let
result
=
r0
+
(
comp1
<
<
32
*
i
)
+
(
comp2
<
<
2
*
32
*
i
)
+
(
comp3
<
<
3
*
32
*
i
)
+
(
r4
<
<
4
*
32
*
i
)
;
let
result_pos
=
result
.
to_biguint
(
)
.
unwrap
(
)
;
add2
(
&
mut
acc
[
.
.
]
&
result_pos
.
data
)
;
}
}
pub
fn
mul3
(
x
:
&
[
BigDigit
]
y
:
&
[
BigDigit
]
)
-
>
BigUint
{
let
len
=
x
.
len
(
)
+
y
.
len
(
)
+
1
;
let
mut
prod
=
BigUint
{
data
:
vec
!
[
0
;
len
]
}
;
mac3
(
&
mut
prod
.
data
[
.
.
]
x
y
)
;
prod
.
normalized
(
)
}
pub
fn
scalar_mul
(
a
:
&
mut
[
BigDigit
]
b
:
BigDigit
)
-
>
BigDigit
{
let
mut
carry
=
0
;
for
a
in
a
.
iter_mut
(
)
{
*
a
=
mul_with_carry
(
*
a
b
&
mut
carry
)
;
}
carry
as
BigDigit
}
pub
fn
div_rem
(
mut
u
:
BigUint
mut
d
:
BigUint
)
-
>
(
BigUint
BigUint
)
{
if
d
.
is_zero
(
)
{
panic
!
(
)
}
if
u
.
is_zero
(
)
{
return
(
Zero
:
:
zero
(
)
Zero
:
:
zero
(
)
)
;
}
if
d
.
data
.
len
(
)
=
=
1
{
if
d
.
data
=
=
[
1
]
{
return
(
u
Zero
:
:
zero
(
)
)
;
}
let
(
div
rem
)
=
div_rem_digit
(
u
d
.
data
[
0
]
)
;
d
.
data
.
clear
(
)
;
d
+
=
rem
;
return
(
div
d
)
;
}
match
u
.
cmp
(
&
d
)
{
Less
=
>
return
(
Zero
:
:
zero
(
)
u
)
Equal
=
>
{
u
.
set_one
(
)
;
return
(
u
Zero
:
:
zero
(
)
)
;
}
Greater
=
>
{
}
}
let
shift
=
d
.
data
.
last
(
)
.
unwrap
(
)
.
leading_zeros
(
)
as
usize
;
let
(
q
r
)
=
if
shift
=
=
0
{
div_rem_core
(
u
&
d
)
}
else
{
div_rem_core
(
u
<
<
shift
&
(
d
<
<
shift
)
)
}
;
(
q
r
>
>
shift
)
}
pub
fn
div_rem_ref
(
u
:
&
BigUint
d
:
&
BigUint
)
-
>
(
BigUint
BigUint
)
{
if
d
.
is_zero
(
)
{
panic
!
(
)
}
if
u
.
is_zero
(
)
{
return
(
Zero
:
:
zero
(
)
Zero
:
:
zero
(
)
)
;
}
if
d
.
data
.
len
(
)
=
=
1
{
if
d
.
data
=
=
[
1
]
{
return
(
u
.
clone
(
)
Zero
:
:
zero
(
)
)
;
}
let
(
div
rem
)
=
div_rem_digit
(
u
.
clone
(
)
d
.
data
[
0
]
)
;
return
(
div
rem
.
into
(
)
)
;
}
match
u
.
cmp
(
d
)
{
Less
=
>
return
(
Zero
:
:
zero
(
)
u
.
clone
(
)
)
Equal
=
>
return
(
One
:
:
one
(
)
Zero
:
:
zero
(
)
)
Greater
=
>
{
}
}
let
shift
=
d
.
data
.
last
(
)
.
unwrap
(
)
.
leading_zeros
(
)
as
usize
;
let
(
q
r
)
=
if
shift
=
=
0
{
div_rem_core
(
u
.
clone
(
)
d
)
}
else
{
div_rem_core
(
u
<
<
shift
&
(
d
<
<
shift
)
)
}
;
(
q
r
>
>
shift
)
}
fn
div_rem_core
(
mut
a
:
BigUint
b
:
&
BigUint
)
-
>
(
BigUint
BigUint
)
{
let
bn
=
*
b
.
data
.
last
(
)
.
unwrap
(
)
;
let
q_len
=
a
.
data
.
len
(
)
-
b
.
data
.
len
(
)
+
1
;
let
mut
q
=
BigUint
{
data
:
vec
!
[
0
;
q_len
]
}
;
let
mut
tmp
=
BigUint
{
data
:
Vec
:
:
with_capacity
(
2
)
}
;
for
j
in
(
0
.
.
q_len
)
.
rev
(
)
{
let
offset
=
j
+
b
.
data
.
len
(
)
-
1
;
if
offset
>
=
a
.
data
.
len
(
)
{
continue
;
}
let
mut
a0
=
tmp
;
a0
.
data
.
truncate
(
0
)
;
a0
.
data
.
extend
(
a
.
data
[
offset
.
.
]
.
iter
(
)
.
cloned
(
)
)
;
let
(
mut
q0
_
)
=
div_rem_digit
(
a0
bn
)
;
let
mut
prod
=
b
*
&
q0
;
while
cmp_slice
(
&
prod
.
data
[
.
.
]
&
a
.
data
[
j
.
.
]
)
=
=
Greater
{
let
one
:
BigUint
=
One
:
:
one
(
)
;
q0
=
q0
-
one
;
prod
=
prod
-
b
;
}
add2
(
&
mut
q
.
data
[
j
.
.
]
&
q0
.
data
[
.
.
]
)
;
sub2
(
&
mut
a
.
data
[
j
.
.
]
&
prod
.
data
[
.
.
]
)
;
a
.
normalize
(
)
;
tmp
=
q0
;
}
debug_assert
!
(
&
a
<
b
)
;
(
q
.
normalized
(
)
a
)
}
pub
fn
fls
<
T
:
traits
:
:
PrimInt
>
(
v
:
T
)
-
>
usize
{
mem
:
:
size_of
:
:
<
T
>
(
)
*
8
-
v
.
leading_zeros
(
)
as
usize
}
pub
fn
ilog2
<
T
:
traits
:
:
PrimInt
>
(
v
:
T
)
-
>
usize
{
fls
(
v
)
-
1
}
#
[
inline
]
pub
fn
biguint_shl
(
n
:
Cow
<
BigUint
>
bits
:
usize
)
-
>
BigUint
{
let
n_unit
=
bits
/
big_digit
:
:
BITS
;
let
mut
data
=
match
n_unit
{
0
=
>
n
.
into_owned
(
)
.
data
_
=
>
{
let
len
=
n_unit
+
n
.
data
.
len
(
)
+
1
;
let
mut
data
=
Vec
:
:
with_capacity
(
len
)
;
data
.
extend
(
repeat
(
0
)
.
take
(
n_unit
)
)
;
data
.
extend
(
n
.
data
.
iter
(
)
.
cloned
(
)
)
;
data
}
}
;
let
n_bits
=
bits
%
big_digit
:
:
BITS
;
if
n_bits
>
0
{
let
mut
carry
=
0
;
for
elem
in
data
[
n_unit
.
.
]
.
iter_mut
(
)
{
let
new_carry
=
*
elem
>
>
(
big_digit
:
:
BITS
-
n_bits
)
;
*
elem
=
(
*
elem
<
<
n_bits
)
|
carry
;
carry
=
new_carry
;
}
if
carry
!
=
0
{
data
.
push
(
carry
)
;
}
}
BigUint
:
:
new
(
data
)
}
#
[
inline
]
pub
fn
biguint_shr
(
n
:
Cow
<
BigUint
>
bits
:
usize
)
-
>
BigUint
{
let
n_unit
=
bits
/
big_digit
:
:
BITS
;
if
n_unit
>
=
n
.
data
.
len
(
)
{
return
Zero
:
:
zero
(
)
;
}
let
mut
data
=
match
n
{
Cow
:
:
Borrowed
(
n
)
=
>
n
.
data
[
n_unit
.
.
]
.
to_vec
(
)
Cow
:
:
Owned
(
mut
n
)
=
>
{
n
.
data
.
drain
(
.
.
n_unit
)
;
n
.
data
}
}
;
let
n_bits
=
bits
%
big_digit
:
:
BITS
;
if
n_bits
>
0
{
let
mut
borrow
=
0
;
for
elem
in
data
.
iter_mut
(
)
.
rev
(
)
{
let
new_borrow
=
*
elem
<
<
(
big_digit
:
:
BITS
-
n_bits
)
;
*
elem
=
(
*
elem
>
>
n_bits
)
|
borrow
;
borrow
=
new_borrow
;
}
}
BigUint
:
:
new
(
data
)
}
pub
fn
cmp_slice
(
a
:
&
[
BigDigit
]
b
:
&
[
BigDigit
]
)
-
>
Ordering
{
debug_assert
!
(
a
.
last
(
)
!
=
Some
(
&
0
)
)
;
debug_assert
!
(
b
.
last
(
)
!
=
Some
(
&
0
)
)
;
let
(
a_len
b_len
)
=
(
a
.
len
(
)
b
.
len
(
)
)
;
if
a_len
<
b_len
{
return
Less
;
}
if
a_len
>
b_len
{
return
Greater
;
}
for
(
&
ai
&
bi
)
in
a
.
iter
(
)
.
rev
(
)
.
zip
(
b
.
iter
(
)
.
rev
(
)
)
{
if
ai
<
bi
{
return
Less
;
}
if
ai
>
bi
{
return
Greater
;
}
}
return
Equal
;
}
#
[
cfg
(
test
)
]
mod
algorithm_tests
{
use
big_digit
:
:
BigDigit
;
use
traits
:
:
Num
;
use
Sign
:
:
Plus
;
use
{
BigInt
BigUint
}
;
#
[
test
]
fn
test_sub_sign
(
)
{
use
super
:
:
sub_sign
;
fn
sub_sign_i
(
a
:
&
[
BigDigit
]
b
:
&
[
BigDigit
]
)
-
>
BigInt
{
let
(
sign
val
)
=
sub_sign
(
a
b
)
;
BigInt
:
:
from_biguint
(
sign
val
)
}
let
a
=
BigUint
:
:
from_str_radix
(
"
265252859812191058636308480000000
"
10
)
.
unwrap
(
)
;
let
b
=
BigUint
:
:
from_str_radix
(
"
26525285981219105863630848000000
"
10
)
.
unwrap
(
)
;
let
a_i
=
BigInt
:
:
from_biguint
(
Plus
a
.
clone
(
)
)
;
let
b_i
=
BigInt
:
:
from_biguint
(
Plus
b
.
clone
(
)
)
;
assert_eq
!
(
sub_sign_i
(
&
a
.
data
[
.
.
]
&
b
.
data
[
.
.
]
)
&
a_i
-
&
b_i
)
;
assert_eq
!
(
sub_sign_i
(
&
b
.
data
[
.
.
]
&
a
.
data
[
.
.
]
)
&
b_i
-
&
a_i
)
;
}
}
