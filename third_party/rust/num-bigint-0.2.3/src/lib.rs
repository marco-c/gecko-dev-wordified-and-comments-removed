#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
num
-
bigint
/
0
.
2
"
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
[
cfg
(
feature
=
"
rand
"
)
]
extern
crate
rand
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
extern
crate
num_integer
as
integer
;
extern
crate
num_traits
as
traits
;
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
extern
crate
quickcheck
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
#
[
macro_use
]
mod
macros
;
mod
bigint
;
mod
biguint
;
#
[
cfg
(
feature
=
"
rand
"
)
]
mod
bigrand
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
type
UsizePromotion
=
u32
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
type
UsizePromotion
=
u64
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
type
IsizePromotion
=
i32
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
type
IsizePromotion
=
i64
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
ParseBigIntError
{
kind
:
BigIntErrorKind
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
enum
BigIntErrorKind
{
Empty
InvalidDigit
}
impl
ParseBigIntError
{
fn
__description
(
&
self
)
-
>
&
str
{
use
BigIntErrorKind
:
:
*
;
match
self
.
kind
{
Empty
=
>
"
cannot
parse
integer
from
empty
string
"
InvalidDigit
=
>
"
invalid
digit
found
in
string
"
}
}
fn
empty
(
)
-
>
Self
{
ParseBigIntError
{
kind
:
BigIntErrorKind
:
:
Empty
}
}
fn
invalid
(
)
-
>
Self
{
ParseBigIntError
{
kind
:
BigIntErrorKind
:
:
InvalidDigit
}
}
}
impl
fmt
:
:
Display
for
ParseBigIntError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
__description
(
)
.
fmt
(
f
)
}
}
impl
Error
for
ParseBigIntError
{
fn
description
(
&
self
)
-
>
&
str
{
self
.
__description
(
)
}
}
pub
use
biguint
:
:
BigUint
;
pub
use
biguint
:
:
ToBigUint
;
pub
use
bigint
:
:
BigInt
;
pub
use
bigint
:
:
Sign
;
pub
use
bigint
:
:
ToBigInt
;
#
[
cfg
(
feature
=
"
rand
"
)
]
pub
use
bigrand
:
:
{
RandBigInt
RandomBits
UniformBigInt
UniformBigUint
}
;
mod
big_digit
{
pub
type
BigDigit
=
u32
;
pub
type
DoubleBigDigit
=
u64
;
pub
type
SignedDoubleBigDigit
=
i64
;
pub
const
BITS
:
usize
=
32
;
const
LO_MASK
:
DoubleBigDigit
=
(
-
1i32
as
DoubleBigDigit
)
>
>
BITS
;
#
[
inline
]
fn
get_hi
(
n
:
DoubleBigDigit
)
-
>
BigDigit
{
(
n
>
>
BITS
)
as
BigDigit
}
#
[
inline
]
fn
get_lo
(
n
:
DoubleBigDigit
)
-
>
BigDigit
{
(
n
&
LO_MASK
)
as
BigDigit
}
#
[
inline
]
pub
fn
from_doublebigdigit
(
n
:
DoubleBigDigit
)
-
>
(
BigDigit
BigDigit
)
{
(
get_hi
(
n
)
get_lo
(
n
)
)
}
#
[
inline
]
pub
fn
to_doublebigdigit
(
hi
:
BigDigit
lo
:
BigDigit
)
-
>
DoubleBigDigit
{
DoubleBigDigit
:
:
from
(
lo
)
|
(
DoubleBigDigit
:
:
from
(
hi
)
<
<
BITS
)
}
}
