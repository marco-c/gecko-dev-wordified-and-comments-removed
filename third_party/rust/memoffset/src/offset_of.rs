#
[
macro_export
]
macro_rules
!
offset_of
{
(
father
:
ty
(
field
:
tt
)
+
)
=
>
(
{
#
[
allow
(
unused_unsafe
)
]
let
root
:
father
=
unsafe
{
crate
:
:
mem
:
:
uninitialized
(
)
}
;
let
base
=
&
root
as
*
const
_
as
usize
;
/
/
Future
error
:
borrow
of
packed
field
requires
unsafe
function
or
block
(
error
E0133
)
#
[
allow
(
unused_unsafe
)
]
let
member
=
unsafe
{
&
root
.
(
field
)
*
as
*
const
_
as
usize
}
;
crate
:
:
mem
:
:
forget
(
root
)
;
member
-
base
}
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
repr
(
C
packed
)
]
struct
Foo
{
a
:
u32
b
:
[
u8
;
4
]
c
:
i64
}
#
[
test
]
fn
offset_simple
(
)
{
assert_eq
!
(
offset_of
!
(
Foo
a
)
0
)
;
assert_eq
!
(
offset_of
!
(
Foo
b
)
4
)
;
assert_eq
!
(
offset_of
!
(
Foo
c
)
8
)
;
}
#
[
test
]
fn
offset_index
(
)
{
assert_eq
!
(
offset_of
!
(
Foo
b
[
2
]
)
6
)
;
}
#
[
test
]
#
[
should_panic
]
fn
offset_index_out_of_bounds
(
)
{
offset_of
!
(
Foo
b
[
4
]
)
;
}
#
[
test
]
fn
tuple_struct
(
)
{
#
[
repr
(
C
packed
)
]
struct
Tup
(
i32
i32
)
;
assert_eq
!
(
offset_of
!
(
Tup
0
)
0
)
;
}
}
