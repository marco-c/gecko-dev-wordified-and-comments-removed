#
[
cfg
(
memoffset_maybe_uninit
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__let_base_ptr
{
(
name
:
ident
type
:
tt
)
=
>
{
/
/
No
UB
here
and
the
pointer
does
not
dangle
either
.
/
/
But
we
have
to
make
sure
that
uninit
lives
long
enough
/
/
so
it
has
to
be
in
the
same
scope
as
name
.
That
'
s
why
/
/
let_base_ptr
declares
a
variable
(
several
actually
)
/
/
instad
of
returning
one
.
let
uninit
=
crate
:
:
mem
:
:
MaybeUninit
:
:
<
type
>
:
:
uninit
(
)
;
let
name
=
uninit
.
as_ptr
(
)
;
}
;
}
#
[
cfg
(
not
(
memoffset_maybe_uninit
)
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__let_base_ptr
{
(
name
:
ident
type
:
tt
)
=
>
{
/
/
No
UB
right
here
but
we
will
later
offset
into
a
field
/
/
of
this
pointer
and
that
is
UB
when
the
pointer
is
dangling
.
let
non_null
=
crate
:
:
ptr
:
:
NonNull
:
:
<
type
>
:
:
dangling
(
)
;
let
name
=
non_null
.
as_ptr
(
)
as
*
const
type
;
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__field_check
{
(
type
:
tt
field
:
tt
)
=
>
{
/
/
Make
sure
the
field
actually
exists
.
This
line
ensures
that
a
/
/
compile
-
time
error
is
generated
if
field
is
accessed
through
a
/
/
Deref
impl
.
let
type
{
field
:
_
.
.
}
;
}
;
}
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
offset_of
{
(
parent
:
tt
field
:
tt
)
=
>
{
{
_memoffset__field_check
!
(
parent
field
)
;
/
/
Get
a
base
pointer
.
_memoffset__let_base_ptr
!
(
base_ptr
parent
)
;
/
/
Get
the
field
address
.
This
is
UB
because
we
are
creating
a
reference
to
/
/
the
uninitialized
field
.
#
[
allow
(
unused_unsafe
)
]
/
/
for
when
the
macro
is
used
in
an
unsafe
block
let
field_ptr
=
unsafe
{
&
(
*
base_ptr
)
.
field
as
*
const
_
}
;
let
offset
=
(
field_ptr
as
usize
)
-
(
base_ptr
as
usize
)
;
offset
}
}
;
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
test
]
fn
offset_simple
(
)
{
#
[
repr
(
C
)
]
struct
Foo
{
a
:
u32
b
:
[
u8
;
2
]
c
:
i64
}
assert_eq
!
(
offset_of
!
(
Foo
a
)
0
)
;
assert_eq
!
(
offset_of
!
(
Foo
b
)
4
)
;
assert_eq
!
(
offset_of
!
(
Foo
c
)
8
)
;
}
#
[
test
]
#
[
cfg
(
not
(
miri
)
)
]
fn
offset_simple_packed
(
)
{
#
[
repr
(
C
packed
)
]
struct
Foo
{
a
:
u32
b
:
[
u8
;
2
]
c
:
i64
}
assert_eq
!
(
offset_of
!
(
Foo
a
)
0
)
;
assert_eq
!
(
offset_of
!
(
Foo
b
)
4
)
;
assert_eq
!
(
offset_of
!
(
Foo
c
)
6
)
;
}
#
[
test
]
fn
tuple_struct
(
)
{
#
[
repr
(
C
)
]
struct
Tup
(
i32
i32
)
;
assert_eq
!
(
offset_of
!
(
Tup
0
)
0
)
;
assert_eq
!
(
offset_of
!
(
Tup
1
)
4
)
;
}
}
