#
[
cfg
(
feature
=
"
unstable_raw
"
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__raw_const
{
(
path
:
expr
)
=
>
{
{
crate
:
:
ptr
:
:
raw_const
!
(
path
)
}
}
;
}
#
[
cfg
(
not
(
feature
=
"
unstable_raw
"
)
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__raw_const
{
(
path
:
expr
)
=
>
{
{
/
/
This
is
UB
because
we
create
an
intermediate
reference
to
uninitialized
memory
.
/
/
Nothing
we
can
do
about
that
without
raw_const
!
though
.
&
path
as
*
const
_
}
}
;
}
#
[
cfg
(
allow_clippy
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__field_check
{
(
type
:
path
field
:
tt
)
=
>
{
/
/
Make
sure
the
field
actually
exists
.
This
line
ensures
that
a
/
/
compile
-
time
error
is
generated
if
field
is
accessed
through
a
/
/
Deref
impl
.
#
[
allow
(
clippy
:
:
unneeded_field_pattern
)
]
let
type
{
field
:
_
.
.
}
;
}
;
}
#
[
cfg
(
not
(
allow_clippy
)
)
]
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
_memoffset__field_check
{
(
type
:
path
field
:
tt
)
=
>
{
/
/
Make
sure
the
field
actually
exists
.
This
line
ensures
that
a
/
/
compile
-
time
error
is
generated
if
field
is
accessed
through
a
/
/
Deref
impl
.
let
type
{
field
:
_
.
.
}
;
}
;
}
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
raw_field
{
(
base
:
expr
parent
:
path
field
:
tt
)
=
>
{
{
_memoffset__field_check
!
(
parent
field
)
;
/
/
Get
the
field
address
.
/
/
Crucially
we
know
that
this
will
not
trigger
a
deref
coercion
because
/
/
of
the
field
check
we
did
above
.
#
[
allow
(
unused_unsafe
)
]
/
/
for
when
the
macro
is
used
in
an
unsafe
block
unsafe
{
_memoffset__raw_const
!
(
(
*
(
base
as
*
const
parent
)
)
.
field
)
}
}
}
;
}
