use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
ptr
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
str
;
use
std
:
:
str
:
:
FromStr
;
use
std
:
:
str
:
:
Utf8Error
;
use
std
:
:
slice
;
use
crate
:
:
array
:
:
Array
;
use
crate
:
:
array
:
:
Index
;
use
crate
:
:
CapacityError
;
use
crate
:
:
char
:
:
encode_utf8
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
{
Serialize
Deserialize
Serializer
Deserializer
}
;
use
super
:
:
MaybeUninit
as
MaybeUninitCopy
;
#
[
derive
(
Copy
)
]
pub
struct
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
xs
:
MaybeUninitCopy
<
A
>
len
:
A
:
:
Index
}
impl
<
A
>
Default
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
default
(
)
-
>
ArrayString
<
A
>
{
ArrayString
:
:
new
(
)
}
}
impl
<
A
>
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
#
[
cfg
(
not
(
feature
=
"
unstable
-
const
-
fn
"
)
)
]
pub
fn
new
(
)
-
>
ArrayString
<
A
>
{
unsafe
{
ArrayString
{
xs
:
MaybeUninitCopy
:
:
uninitialized
(
)
len
:
Index
:
:
ZERO
}
}
}
#
[
cfg
(
feature
=
"
unstable
-
const
-
fn
"
)
]
pub
const
fn
new
(
)
-
>
ArrayString
<
A
>
{
unsafe
{
ArrayString
{
xs
:
MaybeUninitCopy
:
:
uninitialized
(
)
len
:
Index
:
:
ZERO
}
}
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
.
to_usize
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
pub
fn
from
(
s
:
&
str
)
-
>
Result
<
Self
CapacityError
<
&
str
>
>
{
let
mut
arraystr
=
Self
:
:
new
(
)
;
arraystr
.
try_push_str
(
s
)
?
;
Ok
(
arraystr
)
}
pub
fn
from_byte_string
(
b
:
&
A
)
-
>
Result
<
Self
Utf8Error
>
{
let
len
=
str
:
:
from_utf8
(
b
.
as_slice
(
)
)
?
.
len
(
)
;
debug_assert_eq
!
(
len
A
:
:
CAPACITY
)
;
Ok
(
ArrayString
{
xs
:
MaybeUninitCopy
:
:
from
(
*
b
)
len
:
Index
:
:
from
(
A
:
:
CAPACITY
)
}
)
}
#
[
inline
(
always
)
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
A
:
:
CAPACITY
}
pub
fn
is_full
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
self
.
capacity
(
)
}
pub
fn
push
(
&
mut
self
c
:
char
)
{
self
.
try_push
(
c
)
.
unwrap
(
)
;
}
pub
fn
try_push
(
&
mut
self
c
:
char
)
-
>
Result
<
(
)
CapacityError
<
char
>
>
{
let
len
=
self
.
len
(
)
;
unsafe
{
let
ptr
=
self
.
xs
.
ptr_mut
(
)
.
add
(
len
)
;
let
remaining_cap
=
self
.
capacity
(
)
-
len
;
match
encode_utf8
(
c
ptr
remaining_cap
)
{
Ok
(
n
)
=
>
{
self
.
set_len
(
len
+
n
)
;
Ok
(
(
)
)
}
Err
(
_
)
=
>
Err
(
CapacityError
:
:
new
(
c
)
)
}
}
}
pub
fn
push_str
(
&
mut
self
s
:
&
str
)
{
self
.
try_push_str
(
s
)
.
unwrap
(
)
}
pub
fn
try_push_str
<
'
a
>
(
&
mut
self
s
:
&
'
a
str
)
-
>
Result
<
(
)
CapacityError
<
&
'
a
str
>
>
{
if
s
.
len
(
)
>
self
.
capacity
(
)
-
self
.
len
(
)
{
return
Err
(
CapacityError
:
:
new
(
s
)
)
;
}
unsafe
{
let
dst
=
self
.
xs
.
ptr_mut
(
)
.
add
(
self
.
len
(
)
)
;
let
src
=
s
.
as_ptr
(
)
;
ptr
:
:
copy_nonoverlapping
(
src
dst
s
.
len
(
)
)
;
let
newl
=
self
.
len
(
)
+
s
.
len
(
)
;
self
.
set_len
(
newl
)
;
}
Ok
(
(
)
)
}
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
char
>
{
let
ch
=
match
self
.
chars
(
)
.
rev
(
)
.
next
(
)
{
Some
(
ch
)
=
>
ch
None
=
>
return
None
}
;
let
new_len
=
self
.
len
(
)
-
ch
.
len_utf8
(
)
;
unsafe
{
self
.
set_len
(
new_len
)
;
}
Some
(
ch
)
}
pub
fn
truncate
(
&
mut
self
new_len
:
usize
)
{
if
new_len
<
=
self
.
len
(
)
{
assert
!
(
self
.
is_char_boundary
(
new_len
)
)
;
unsafe
{
self
.
set_len
(
new_len
)
;
}
}
}
pub
fn
remove
(
&
mut
self
idx
:
usize
)
-
>
char
{
let
ch
=
match
self
[
idx
.
.
]
.
chars
(
)
.
next
(
)
{
Some
(
ch
)
=
>
ch
None
=
>
panic
!
(
"
cannot
remove
a
char
from
the
end
of
a
string
"
)
}
;
let
next
=
idx
+
ch
.
len_utf8
(
)
;
let
len
=
self
.
len
(
)
;
unsafe
{
ptr
:
:
copy
(
self
.
xs
.
ptr
(
)
.
add
(
next
)
self
.
xs
.
ptr_mut
(
)
.
add
(
idx
)
len
-
next
)
;
self
.
set_len
(
len
-
(
next
-
idx
)
)
;
}
ch
}
pub
fn
clear
(
&
mut
self
)
{
unsafe
{
self
.
set_len
(
0
)
;
}
}
pub
unsafe
fn
set_len
(
&
mut
self
length
:
usize
)
{
debug_assert
!
(
length
<
=
self
.
capacity
(
)
)
;
self
.
len
=
Index
:
:
from
(
length
)
;
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
self
}
}
impl
<
A
>
Deref
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
type
Target
=
str
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
str
{
unsafe
{
let
sl
=
slice
:
:
from_raw_parts
(
self
.
xs
.
ptr
(
)
self
.
len
.
to_usize
(
)
)
;
str
:
:
from_utf8_unchecked
(
sl
)
}
}
}
impl
<
A
>
DerefMut
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
str
{
unsafe
{
let
sl
=
slice
:
:
from_raw_parts_mut
(
self
.
xs
.
ptr_mut
(
)
self
.
len
.
to_usize
(
)
)
;
str
:
:
from_utf8_unchecked_mut
(
sl
)
}
}
}
impl
<
A
>
PartialEq
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
eq
(
&
self
rhs
:
&
Self
)
-
>
bool
{
*
*
self
=
=
*
*
rhs
}
}
impl
<
A
>
PartialEq
<
str
>
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
eq
(
&
self
rhs
:
&
str
)
-
>
bool
{
&
*
*
self
=
=
rhs
}
}
impl
<
A
>
PartialEq
<
ArrayString
<
A
>
>
for
str
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
eq
(
&
self
rhs
:
&
ArrayString
<
A
>
)
-
>
bool
{
self
=
=
&
*
*
rhs
}
}
impl
<
A
>
Eq
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
}
impl
<
A
>
Hash
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
hash
<
H
:
Hasher
>
(
&
self
h
:
&
mut
H
)
{
(
*
*
self
)
.
hash
(
h
)
}
}
impl
<
A
>
Borrow
<
str
>
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
borrow
(
&
self
)
-
>
&
str
{
self
}
}
impl
<
A
>
AsRef
<
str
>
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
as_ref
(
&
self
)
-
>
&
str
{
self
}
}
impl
<
A
>
fmt
:
:
Debug
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
(
*
*
self
)
.
fmt
(
f
)
}
}
impl
<
A
>
fmt
:
:
Display
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
(
*
*
self
)
.
fmt
(
f
)
}
}
impl
<
A
>
fmt
:
:
Write
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
write_char
(
&
mut
self
c
:
char
)
-
>
fmt
:
:
Result
{
self
.
try_push
(
c
)
.
map_err
(
|
_
|
fmt
:
:
Error
)
}
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
self
.
try_push_str
(
s
)
.
map_err
(
|
_
|
fmt
:
:
Error
)
}
}
impl
<
A
>
Clone
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
clone
(
&
self
)
-
>
ArrayString
<
A
>
{
*
self
}
fn
clone_from
(
&
mut
self
rhs
:
&
Self
)
{
self
.
clear
(
)
;
self
.
try_push_str
(
rhs
)
.
ok
(
)
;
}
}
impl
<
A
>
PartialOrd
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
partial_cmp
(
&
self
rhs
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
(
*
*
self
)
.
partial_cmp
(
&
*
*
rhs
)
}
fn
lt
(
&
self
rhs
:
&
Self
)
-
>
bool
{
*
*
self
<
*
*
rhs
}
fn
le
(
&
self
rhs
:
&
Self
)
-
>
bool
{
*
*
self
<
=
*
*
rhs
}
fn
gt
(
&
self
rhs
:
&
Self
)
-
>
bool
{
*
*
self
>
*
*
rhs
}
fn
ge
(
&
self
rhs
:
&
Self
)
-
>
bool
{
*
*
self
>
=
*
*
rhs
}
}
impl
<
A
>
PartialOrd
<
str
>
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
partial_cmp
(
&
self
rhs
:
&
str
)
-
>
Option
<
cmp
:
:
Ordering
>
{
(
*
*
self
)
.
partial_cmp
(
rhs
)
}
fn
lt
(
&
self
rhs
:
&
str
)
-
>
bool
{
&
*
*
self
<
rhs
}
fn
le
(
&
self
rhs
:
&
str
)
-
>
bool
{
&
*
*
self
<
=
rhs
}
fn
gt
(
&
self
rhs
:
&
str
)
-
>
bool
{
&
*
*
self
>
rhs
}
fn
ge
(
&
self
rhs
:
&
str
)
-
>
bool
{
&
*
*
self
>
=
rhs
}
}
impl
<
A
>
PartialOrd
<
ArrayString
<
A
>
>
for
str
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
partial_cmp
(
&
self
rhs
:
&
ArrayString
<
A
>
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
partial_cmp
(
&
*
*
rhs
)
}
fn
lt
(
&
self
rhs
:
&
ArrayString
<
A
>
)
-
>
bool
{
self
<
&
*
*
rhs
}
fn
le
(
&
self
rhs
:
&
ArrayString
<
A
>
)
-
>
bool
{
self
<
=
&
*
*
rhs
}
fn
gt
(
&
self
rhs
:
&
ArrayString
<
A
>
)
-
>
bool
{
self
>
&
*
*
rhs
}
fn
ge
(
&
self
rhs
:
&
ArrayString
<
A
>
)
-
>
bool
{
self
>
=
&
*
*
rhs
}
}
impl
<
A
>
Ord
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
cmp
(
&
self
rhs
:
&
Self
)
-
>
cmp
:
:
Ordering
{
(
*
*
self
)
.
cmp
(
&
*
*
rhs
)
}
}
impl
<
A
>
FromStr
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
type
Err
=
CapacityError
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Self
:
:
from
(
s
)
.
map_err
(
CapacityError
:
:
simplify
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
A
>
Serialize
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_str
(
&
*
self
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
A
>
Deserialize
<
'
de
>
for
ArrayString
<
A
>
where
A
:
Array
<
Item
=
u8
>
+
Copy
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
self
Visitor
}
;
use
std
:
:
marker
:
:
PhantomData
;
struct
ArrayStringVisitor
<
A
:
Array
<
Item
=
u8
>
>
(
PhantomData
<
A
>
)
;
impl
<
'
de
A
:
Copy
+
Array
<
Item
=
u8
>
>
Visitor
<
'
de
>
for
ArrayStringVisitor
<
A
>
{
type
Value
=
ArrayString
<
A
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
a
string
no
more
than
{
}
bytes
long
"
A
:
:
CAPACITY
)
}
fn
visit_str
<
E
>
(
self
v
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
ArrayString
:
:
from
(
v
)
.
map_err
(
|
_
|
E
:
:
invalid_length
(
v
.
len
(
)
&
self
)
)
}
fn
visit_bytes
<
E
>
(
self
v
:
&
[
u8
]
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
de
:
:
Error
{
let
s
=
str
:
:
from_utf8
(
v
)
.
map_err
(
|
_
|
E
:
:
invalid_value
(
de
:
:
Unexpected
:
:
Bytes
(
v
)
&
self
)
)
?
;
ArrayString
:
:
from
(
s
)
.
map_err
(
|
_
|
E
:
:
invalid_length
(
s
.
len
(
)
&
self
)
)
}
}
deserializer
.
deserialize_str
(
ArrayStringVisitor
:
:
<
A
>
(
PhantomData
)
)
}
}
