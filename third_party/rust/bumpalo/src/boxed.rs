use
{
crate
:
:
Bump
{
core
:
:
{
any
:
:
Any
borrow
cmp
:
:
Ordering
convert
:
:
TryFrom
future
:
:
Future
hash
:
:
{
Hash
Hasher
}
iter
:
:
FusedIterator
mem
:
:
ManuallyDrop
ops
:
:
{
Deref
DerefMut
}
pin
:
:
Pin
task
:
:
{
Context
Poll
}
}
core_alloc
:
:
fmt
}
}
;
#
[
repr
(
transparent
)
]
pub
struct
Box
<
'
a
T
:
?
Sized
>
(
&
'
a
mut
T
)
;
impl
<
'
a
T
>
Box
<
'
a
T
>
{
#
[
inline
(
always
)
]
pub
fn
new_in
(
x
:
T
a
:
&
'
a
Bump
)
-
>
Box
<
'
a
T
>
{
Box
(
a
.
alloc
(
x
)
)
}
#
[
inline
(
always
)
]
pub
fn
pin_in
(
x
:
T
a
:
&
'
a
Bump
)
-
>
Pin
<
Box
<
'
a
T
>
>
{
Box
(
a
.
alloc
(
x
)
)
.
into
(
)
}
pub
fn
into_inner
(
b
:
Box
<
'
a
T
>
)
-
>
T
{
unsafe
{
core
:
:
ptr
:
:
read
(
Box
:
:
into_raw
(
b
)
)
}
}
}
impl
<
'
a
T
:
?
Sized
>
Box
<
'
a
T
>
{
#
[
inline
]
pub
unsafe
fn
from_raw
(
raw
:
*
mut
T
)
-
>
Self
{
Box
(
&
mut
*
raw
)
}
#
[
inline
]
pub
fn
into_raw
(
b
:
Box
<
'
a
T
>
)
-
>
*
mut
T
{
let
mut
b
=
ManuallyDrop
:
:
new
(
b
)
;
b
.
deref_mut
(
)
.
0
as
*
mut
T
}
#
[
inline
]
pub
fn
leak
(
b
:
Box
<
'
a
T
>
)
-
>
&
'
a
mut
T
{
unsafe
{
&
mut
*
Box
:
:
into_raw
(
b
)
}
}
}
impl
<
'
a
T
:
?
Sized
>
Drop
for
Box
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
core
:
:
ptr
:
:
drop_in_place
(
self
.
0
)
;
}
}
}
impl
<
'
a
T
>
Default
for
Box
<
'
a
[
T
]
>
{
fn
default
(
)
-
>
Box
<
'
a
[
T
]
>
{
Box
(
&
mut
[
]
)
}
}
impl
<
'
a
>
Default
for
Box
<
'
a
str
>
{
fn
default
(
)
-
>
Box
<
'
a
str
>
{
unsafe
{
Box
:
:
from_raw
(
Box
:
:
into_raw
(
Box
:
:
<
[
u8
]
>
:
:
default
(
)
)
as
*
mut
str
)
}
}
}
impl
<
'
a
'
b
T
:
?
Sized
+
PartialEq
>
PartialEq
<
Box
<
'
b
T
>
>
for
Box
<
'
a
T
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
bool
{
PartialEq
:
:
eq
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
]
fn
ne
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
bool
{
PartialEq
:
:
ne
(
&
*
*
self
&
*
*
other
)
}
}
impl
<
'
a
'
b
T
:
?
Sized
+
PartialOrd
>
PartialOrd
<
Box
<
'
b
T
>
>
for
Box
<
'
a
T
>
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
Option
<
Ordering
>
{
PartialOrd
:
:
partial_cmp
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
]
fn
lt
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
bool
{
PartialOrd
:
:
lt
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
]
fn
le
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
bool
{
PartialOrd
:
:
le
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
]
fn
ge
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
bool
{
PartialOrd
:
:
ge
(
&
*
*
self
&
*
*
other
)
}
#
[
inline
]
fn
gt
(
&
self
other
:
&
Box
<
'
b
T
>
)
-
>
bool
{
PartialOrd
:
:
gt
(
&
*
*
self
&
*
*
other
)
}
}
impl
<
'
a
T
:
?
Sized
+
Ord
>
Ord
for
Box
<
'
a
T
>
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Box
<
'
a
T
>
)
-
>
Ordering
{
Ord
:
:
cmp
(
&
*
*
self
&
*
*
other
)
}
}
impl
<
'
a
T
:
?
Sized
+
Eq
>
Eq
for
Box
<
'
a
T
>
{
}
impl
<
'
a
T
:
?
Sized
+
Hash
>
Hash
for
Box
<
'
a
T
>
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
(
*
*
self
)
.
hash
(
state
)
;
}
}
impl
<
'
a
T
:
?
Sized
+
Hasher
>
Hasher
for
Box
<
'
a
T
>
{
fn
finish
(
&
self
)
-
>
u64
{
(
*
*
self
)
.
finish
(
)
}
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
{
(
*
*
self
)
.
write
(
bytes
)
}
fn
write_u8
(
&
mut
self
i
:
u8
)
{
(
*
*
self
)
.
write_u8
(
i
)
}
fn
write_u16
(
&
mut
self
i
:
u16
)
{
(
*
*
self
)
.
write_u16
(
i
)
}
fn
write_u32
(
&
mut
self
i
:
u32
)
{
(
*
*
self
)
.
write_u32
(
i
)
}
fn
write_u64
(
&
mut
self
i
:
u64
)
{
(
*
*
self
)
.
write_u64
(
i
)
}
fn
write_u128
(
&
mut
self
i
:
u128
)
{
(
*
*
self
)
.
write_u128
(
i
)
}
fn
write_usize
(
&
mut
self
i
:
usize
)
{
(
*
*
self
)
.
write_usize
(
i
)
}
fn
write_i8
(
&
mut
self
i
:
i8
)
{
(
*
*
self
)
.
write_i8
(
i
)
}
fn
write_i16
(
&
mut
self
i
:
i16
)
{
(
*
*
self
)
.
write_i16
(
i
)
}
fn
write_i32
(
&
mut
self
i
:
i32
)
{
(
*
*
self
)
.
write_i32
(
i
)
}
fn
write_i64
(
&
mut
self
i
:
i64
)
{
(
*
*
self
)
.
write_i64
(
i
)
}
fn
write_i128
(
&
mut
self
i
:
i128
)
{
(
*
*
self
)
.
write_i128
(
i
)
}
fn
write_isize
(
&
mut
self
i
:
isize
)
{
(
*
*
self
)
.
write_isize
(
i
)
}
}
impl
<
'
a
T
:
?
Sized
>
From
<
Box
<
'
a
T
>
>
for
Pin
<
Box
<
'
a
T
>
>
{
fn
from
(
boxed
:
Box
<
'
a
T
>
)
-
>
Self
{
unsafe
{
Pin
:
:
new_unchecked
(
boxed
)
}
}
}
impl
<
'
a
>
Box
<
'
a
dyn
Any
>
{
#
[
inline
]
pub
fn
downcast
<
T
:
Any
>
(
self
)
-
>
Result
<
Box
<
'
a
T
>
Box
<
'
a
dyn
Any
>
>
{
if
self
.
is
:
:
<
T
>
(
)
{
unsafe
{
let
raw
:
*
mut
dyn
Any
=
Box
:
:
into_raw
(
self
)
;
Ok
(
Box
:
:
from_raw
(
raw
as
*
mut
T
)
)
}
}
else
{
Err
(
self
)
}
}
}
impl
<
'
a
>
Box
<
'
a
dyn
Any
+
Send
>
{
#
[
inline
]
pub
fn
downcast
<
T
:
Any
>
(
self
)
-
>
Result
<
Box
<
'
a
T
>
Box
<
'
a
dyn
Any
+
Send
>
>
{
if
self
.
is
:
:
<
T
>
(
)
{
unsafe
{
let
raw
:
*
mut
(
dyn
Any
+
Send
)
=
Box
:
:
into_raw
(
self
)
;
Ok
(
Box
:
:
from_raw
(
raw
as
*
mut
T
)
)
}
}
else
{
Err
(
self
)
}
}
}
impl
<
'
a
T
:
fmt
:
:
Display
+
?
Sized
>
fmt
:
:
Display
for
Box
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
'
a
T
:
fmt
:
:
Debug
+
?
Sized
>
fmt
:
:
Debug
for
Box
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
'
a
T
:
?
Sized
>
fmt
:
:
Pointer
for
Box
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
ptr
:
*
const
T
=
&
*
*
self
;
fmt
:
:
Pointer
:
:
fmt
(
&
ptr
f
)
}
}
impl
<
'
a
T
:
?
Sized
>
Deref
for
Box
<
'
a
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
&
*
self
.
0
}
}
impl
<
'
a
T
:
?
Sized
>
DerefMut
for
Box
<
'
a
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
self
.
0
}
}
impl
<
'
a
I
:
Iterator
+
?
Sized
>
Iterator
for
Box
<
'
a
I
>
{
type
Item
=
I
:
:
Item
;
fn
next
(
&
mut
self
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
next
(
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
*
*
self
)
.
size_hint
(
)
}
fn
nth
(
&
mut
self
n
:
usize
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
nth
(
n
)
}
fn
last
(
self
)
-
>
Option
<
I
:
:
Item
>
{
#
[
inline
]
fn
some
<
T
>
(
_
:
Option
<
T
>
x
:
T
)
-
>
Option
<
T
>
{
Some
(
x
)
}
self
.
fold
(
None
some
)
}
}
impl
<
'
a
I
:
DoubleEndedIterator
+
?
Sized
>
DoubleEndedIterator
for
Box
<
'
a
I
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
next_back
(
)
}
fn
nth_back
(
&
mut
self
n
:
usize
)
-
>
Option
<
I
:
:
Item
>
{
(
*
*
self
)
.
nth_back
(
n
)
}
}
impl
<
'
a
I
:
ExactSizeIterator
+
?
Sized
>
ExactSizeIterator
for
Box
<
'
a
I
>
{
fn
len
(
&
self
)
-
>
usize
{
(
*
*
self
)
.
len
(
)
}
}
impl
<
'
a
I
:
FusedIterator
+
?
Sized
>
FusedIterator
for
Box
<
'
a
I
>
{
}
#
[
cfg
(
feature
=
"
collections
"
)
]
impl
<
'
a
A
>
Box
<
'
a
[
A
]
>
{
pub
fn
from_iter_in
<
T
:
IntoIterator
<
Item
=
A
>
>
(
iter
:
T
a
:
&
'
a
Bump
)
-
>
Self
{
use
crate
:
:
collections
:
:
Vec
;
let
mut
vec
=
Vec
:
:
new_in
(
a
)
;
vec
.
extend
(
iter
)
;
vec
.
into_boxed_slice
(
)
}
}
impl
<
'
a
T
:
?
Sized
>
borrow
:
:
Borrow
<
T
>
for
Box
<
'
a
T
>
{
fn
borrow
(
&
self
)
-
>
&
T
{
&
*
*
self
}
}
impl
<
'
a
T
:
?
Sized
>
borrow
:
:
BorrowMut
<
T
>
for
Box
<
'
a
T
>
{
fn
borrow_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
*
*
self
}
}
impl
<
'
a
T
:
?
Sized
>
AsRef
<
T
>
for
Box
<
'
a
T
>
{
fn
as_ref
(
&
self
)
-
>
&
T
{
&
*
*
self
}
}
impl
<
'
a
T
:
?
Sized
>
AsMut
<
T
>
for
Box
<
'
a
T
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
*
*
self
}
}
impl
<
'
a
T
:
?
Sized
>
Unpin
for
Box
<
'
a
T
>
{
}
impl
<
'
a
F
:
?
Sized
+
Future
+
Unpin
>
Future
for
Box
<
'
a
F
>
{
type
Output
=
F
:
:
Output
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
F
:
:
poll
(
Pin
:
:
new
(
&
mut
*
self
)
cx
)
}
}
impl
<
'
a
T
const
N
:
usize
>
From
<
Box
<
'
a
[
T
;
N
]
>
>
for
Box
<
'
a
[
T
]
>
{
fn
from
(
arr
:
Box
<
'
a
[
T
;
N
]
>
)
-
>
Box
<
'
a
[
T
]
>
{
let
mut
arr
=
ManuallyDrop
:
:
new
(
arr
)
;
let
ptr
=
core
:
:
ptr
:
:
slice_from_raw_parts_mut
(
arr
.
as_mut_ptr
(
)
N
)
;
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
}
}
impl
<
'
a
T
const
N
:
usize
>
TryFrom
<
Box
<
'
a
[
T
]
>
>
for
Box
<
'
a
[
T
;
N
]
>
{
type
Error
=
Box
<
'
a
[
T
]
>
;
fn
try_from
(
slice
:
Box
<
'
a
[
T
]
>
)
-
>
Result
<
Box
<
'
a
[
T
;
N
]
>
Box
<
'
a
[
T
]
>
>
{
if
slice
.
len
(
)
=
=
N
{
let
mut
slice
=
ManuallyDrop
:
:
new
(
slice
)
;
let
ptr
=
slice
.
as_mut_ptr
(
)
as
*
mut
[
T
;
N
]
;
Ok
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
}
else
{
Err
(
slice
)
}
}
}
