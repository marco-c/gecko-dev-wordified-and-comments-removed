#
!
[
deny
(
missing_debug_implementations
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
feature
(
alloc
)
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
core
;
#
[
cfg
(
feature
=
"
collections
"
)
]
pub
mod
collections
;
mod
alloc
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
imports
{
pub
use
std
:
:
alloc
:
:
{
alloc
dealloc
Layout
}
;
pub
use
std
:
:
cell
:
:
{
Cell
UnsafeCell
}
;
pub
use
std
:
:
cmp
;
pub
use
std
:
:
fmt
;
pub
use
std
:
:
mem
;
pub
use
std
:
:
ptr
:
:
{
self
NonNull
}
;
pub
use
std
:
:
slice
;
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
mod
imports
{
extern
crate
alloc
;
pub
use
self
:
:
alloc
:
:
alloc
:
:
{
alloc
dealloc
Layout
}
;
pub
use
core
:
:
cell
:
:
{
Cell
UnsafeCell
}
;
pub
use
core
:
:
cmp
;
pub
use
core
:
:
fmt
;
pub
use
core
:
:
mem
;
pub
use
core
:
:
ptr
:
:
{
self
NonNull
}
;
pub
use
core
:
:
slice
;
}
use
crate
:
:
imports
:
:
*
;
#
[
derive
(
Debug
)
]
pub
struct
Bump
{
current_chunk_footer
:
Cell
<
NonNull
<
ChunkFooter
>
>
all_chunk_footers
:
Cell
<
NonNull
<
ChunkFooter
>
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
struct
ChunkFooter
{
data
:
NonNull
<
u8
>
layout
:
Layout
next
:
Cell
<
Option
<
NonNull
<
ChunkFooter
>
>
>
ptr
:
Cell
<
NonNull
<
u8
>
>
}
impl
Default
for
Bump
{
fn
default
(
)
-
>
Bump
{
Bump
:
:
new
(
)
}
}
impl
Drop
for
Bump
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
mut
footer
=
Some
(
self
.
all_chunk_footers
.
get
(
)
)
;
while
let
Some
(
f
)
=
footer
{
footer
=
f
.
as_ref
(
)
.
next
.
get
(
)
;
dealloc
(
f
.
as_ref
(
)
.
data
.
as_ptr
(
)
f
.
as_ref
(
)
.
layout
)
;
}
}
}
}
unsafe
impl
Send
for
Bump
{
}
#
[
inline
]
pub
(
crate
)
fn
round_up_to
(
n
:
usize
divisor
:
usize
)
-
>
usize
{
debug_assert
!
(
divisor
.
is_power_of_two
(
)
)
;
(
n
+
divisor
-
1
)
&
!
(
divisor
-
1
)
}
const
MALLOC_OVERHEAD
:
usize
=
16
;
const
DEFAULT_CHUNK_SIZE_WITH_FOOTER
:
usize
=
(
1
<
<
9
)
-
MALLOC_OVERHEAD
;
const
DEFAULT_CHUNK_ALIGN
:
usize
=
mem
:
:
align_of
:
:
<
ChunkFooter
>
(
)
;
#
[
inline
]
unsafe
fn
layout_from_size_align
(
size
:
usize
align
:
usize
)
-
>
Layout
{
if
cfg
!
(
debug_assertions
)
{
Layout
:
:
from_size_align
(
size
align
)
.
unwrap
(
)
}
else
{
Layout
:
:
from_size_align_unchecked
(
size
align
)
}
}
impl
Bump
{
fn
default_chunk_layout
(
)
-
>
Layout
{
unsafe
{
layout_from_size_align
(
DEFAULT_CHUNK_SIZE_WITH_FOOTER
DEFAULT_CHUNK_ALIGN
)
}
}
pub
fn
new
(
)
-
>
Bump
{
let
chunk_footer
=
Self
:
:
new_chunk
(
None
)
;
Bump
{
current_chunk_footer
:
Cell
:
:
new
(
chunk_footer
)
all_chunk_footers
:
Cell
:
:
new
(
chunk_footer
)
}
}
fn
new_chunk
(
layouts
:
Option
<
(
usize
Layout
)
>
)
-
>
NonNull
<
ChunkFooter
>
{
unsafe
{
let
layout
:
Layout
=
layouts
.
map_or_else
(
Bump
:
:
default_chunk_layout
|
(
old_size
requested
)
|
{
let
old_doubled
=
old_size
.
checked_mul
(
2
)
.
unwrap
(
)
;
let
footer_align
=
mem
:
:
align_of
:
:
<
ChunkFooter
>
(
)
;
debug_assert_eq
!
(
old_doubled
round_up_to
(
old_doubled
footer_align
)
"
The
old
size
was
already
a
multiple
of
our
chunk
footer
alignment
so
no
\
need
to
round
it
up
again
.
"
)
;
let
size_to_allocate
=
cmp
:
:
max
(
old_doubled
requested
.
size
(
)
)
;
let
size
=
cmp
:
:
max
(
size_to_allocate
requested
.
size
(
)
+
mem
:
:
size_of
:
:
<
ChunkFooter
>
(
)
)
;
let
size
=
round_up_to
(
size
footer_align
)
;
let
align
=
cmp
:
:
max
(
footer_align
requested
.
align
(
)
)
;
layout_from_size_align
(
size
align
)
}
)
;
let
size
=
layout
.
size
(
)
;
debug_assert
!
(
layout
.
align
(
)
%
mem
:
:
align_of
:
:
<
ChunkFooter
>
(
)
=
=
0
)
;
let
data
=
alloc
(
layout
)
;
let
data
=
NonNull
:
:
new
(
data
)
.
unwrap_or_else
(
|
|
oom
(
)
)
;
let
next
=
Cell
:
:
new
(
None
)
;
let
ptr
=
Cell
:
:
new
(
data
)
;
let
footer_ptr
=
data
.
as_ptr
(
)
as
usize
+
size
-
mem
:
:
size_of
:
:
<
ChunkFooter
>
(
)
;
let
footer_ptr
=
footer_ptr
as
*
mut
ChunkFooter
;
ptr
:
:
write
(
footer_ptr
ChunkFooter
{
data
layout
next
ptr
}
)
;
NonNull
:
:
new_unchecked
(
footer_ptr
)
}
}
pub
fn
reset
(
&
mut
self
)
{
unsafe
{
let
mut
footer
=
Some
(
self
.
all_chunk_footers
.
get
(
)
)
;
while
let
Some
(
f
)
=
footer
{
footer
=
f
.
as_ref
(
)
.
next
.
get
(
)
;
if
f
=
=
self
.
current_chunk_footer
.
get
(
)
{
f
.
as_ref
(
)
.
ptr
.
set
(
NonNull
:
:
new_unchecked
(
f
.
as_ref
(
)
.
data
.
as_ptr
(
)
as
*
mut
u8
)
)
;
f
.
as_ref
(
)
.
next
.
set
(
None
)
;
self
.
all_chunk_footers
.
set
(
f
)
;
}
else
{
dealloc
(
f
.
as_ref
(
)
.
data
.
as_ptr
(
)
f
.
as_ref
(
)
.
layout
.
clone
(
)
)
;
}
}
debug_assert_eq
!
(
self
.
all_chunk_footers
.
get
(
)
self
.
current_chunk_footer
.
get
(
)
"
The
current
chunk
should
be
the
list
head
of
all
of
our
chunks
"
)
;
debug_assert
!
(
self
.
current_chunk_footer
.
get
(
)
.
as_ref
(
)
.
next
.
get
(
)
.
is_none
(
)
"
We
should
only
have
a
single
chunk
"
)
;
debug_assert_eq
!
(
self
.
current_chunk_footer
.
get
(
)
.
as_ref
(
)
.
ptr
.
get
(
)
self
.
current_chunk_footer
.
get
(
)
.
as_ref
(
)
.
data
"
Our
chunk
'
s
bump
finger
should
be
reset
to
the
start
of
its
allocation
"
)
;
}
}
#
[
inline
(
always
)
]
pub
fn
alloc
<
T
>
(
&
self
val
:
T
)
-
>
&
mut
T
{
self
.
alloc_with
(
|
|
val
)
}
#
[
inline
(
always
)
]
pub
fn
alloc_with
<
F
T
>
(
&
self
f
:
F
)
-
>
&
mut
T
where
F
:
FnOnce
(
)
-
>
T
{
#
[
inline
(
always
)
]
unsafe
fn
inner_writer
<
T
F
>
(
ptr
:
*
mut
T
f
:
F
)
where
F
:
FnOnce
(
)
-
>
T
{
ptr
:
:
write
(
ptr
f
(
)
)
}
let
layout
=
Layout
:
:
new
:
:
<
T
>
(
)
;
unsafe
{
let
p
=
self
.
alloc_layout
(
layout
)
;
let
p
=
p
.
as_ptr
(
)
as
*
mut
T
;
inner_writer
(
p
f
)
;
&
mut
*
p
}
}
#
[
inline
(
always
)
]
pub
fn
alloc_slice_copy
<
T
>
(
&
self
src
:
&
[
T
]
)
-
>
&
mut
[
T
]
where
T
:
Copy
{
let
layout
=
Layout
:
:
for_value
(
src
)
;
let
dst
=
self
.
alloc_layout
(
layout
)
.
cast
:
:
<
T
>
(
)
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
src
.
as_ptr
(
)
dst
.
as_ptr
(
)
src
.
len
(
)
)
;
slice
:
:
from_raw_parts_mut
(
dst
.
as_ptr
(
)
src
.
len
(
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
alloc_slice_clone
<
T
>
(
&
self
src
:
&
[
T
]
)
-
>
&
mut
[
T
]
where
T
:
Clone
{
let
layout
=
Layout
:
:
for_value
(
src
)
;
let
dst
=
self
.
alloc_layout
(
layout
)
.
cast
:
:
<
T
>
(
)
;
unsafe
{
for
(
i
val
)
in
src
.
iter
(
)
.
cloned
(
)
.
enumerate
(
)
{
ptr
:
:
write
(
dst
.
as_ptr
(
)
.
offset
(
i
as
isize
)
val
)
;
}
slice
:
:
from_raw_parts_mut
(
dst
.
as_ptr
(
)
src
.
len
(
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
alloc_layout
(
&
self
layout
:
Layout
)
-
>
NonNull
<
u8
>
{
if
let
Some
(
p
)
=
self
.
try_alloc_layout_fast
(
layout
)
{
p
}
else
{
self
.
alloc_layout_slow
(
layout
)
}
}
#
[
inline
(
always
)
]
fn
try_alloc_layout_fast
(
&
self
layout
:
Layout
)
-
>
Option
<
NonNull
<
u8
>
>
{
unsafe
{
let
footer
=
self
.
current_chunk_footer
.
get
(
)
;
let
footer
=
footer
.
as_ref
(
)
;
let
ptr
=
footer
.
ptr
.
get
(
)
.
as_ptr
(
)
as
usize
;
let
ptr
=
round_up_to
(
ptr
layout
.
align
(
)
)
;
let
end
=
footer
as
*
const
_
as
usize
;
debug_assert
!
(
ptr
<
=
end
)
;
let
new_ptr
=
ptr
.
checked_add
(
layout
.
size
(
)
)
?
;
if
new_ptr
<
=
end
{
let
p
=
ptr
as
*
mut
u8
;
debug_assert
!
(
new_ptr
<
=
footer
as
*
const
_
as
usize
)
;
footer
.
ptr
.
set
(
NonNull
:
:
new_unchecked
(
new_ptr
as
*
mut
u8
)
)
;
Some
(
NonNull
:
:
new_unchecked
(
p
)
)
}
else
{
None
}
}
}
#
[
inline
(
never
)
]
fn
alloc_layout_slow
(
&
self
layout
:
Layout
)
-
>
NonNull
<
u8
>
{
unsafe
{
let
size
=
layout
.
size
(
)
;
let
current_layout
=
self
.
current_chunk_footer
.
get
(
)
.
as_ref
(
)
.
layout
.
clone
(
)
;
let
footer
=
Bump
:
:
new_chunk
(
Some
(
(
current_layout
.
size
(
)
layout
)
)
)
;
self
.
current_chunk_footer
.
get
(
)
.
as_ref
(
)
.
next
.
set
(
Some
(
footer
)
)
;
self
.
current_chunk_footer
.
set
(
footer
)
;
let
footer
=
footer
.
as_ref
(
)
;
let
ptr
=
footer
.
ptr
.
get
(
)
.
as_ptr
(
)
as
usize
+
size
;
debug_assert
!
(
ptr
<
=
footer
as
*
const
_
as
usize
"
{
}
<
=
{
}
"
ptr
footer
as
*
const
_
as
usize
)
;
footer
.
ptr
.
set
(
NonNull
:
:
new_unchecked
(
ptr
as
*
mut
u8
)
)
;
footer
.
data
.
cast
:
:
<
u8
>
(
)
}
}
pub
unsafe
fn
each_allocated_chunk
<
F
>
(
&
mut
self
mut
f
:
F
)
where
F
:
for
<
'
a
>
FnMut
(
&
'
a
[
u8
]
)
{
let
mut
footer
=
Some
(
self
.
all_chunk_footers
.
get
(
)
)
;
while
let
Some
(
foot
)
=
footer
{
let
foot
=
foot
.
as_ref
(
)
;
let
start
=
foot
.
data
.
as_ptr
(
)
as
usize
;
let
end_of_allocated_region
=
foot
.
ptr
.
get
(
)
.
as_ptr
(
)
as
usize
;
debug_assert
!
(
end_of_allocated_region
<
=
foot
as
*
const
_
as
usize
)
;
debug_assert
!
(
end_of_allocated_region
>
=
start
"
end_of_allocated_region
(
0x
{
:
x
}
)
>
=
start
(
0x
{
:
x
}
)
"
end_of_allocated_region
start
)
;
let
len
=
end_of_allocated_region
-
start
;
let
slice
=
slice
:
:
from_raw_parts
(
start
as
*
const
u8
len
)
;
f
(
slice
)
;
footer
=
foot
.
next
.
get
(
)
;
}
}
}
#
[
inline
(
never
)
]
#
[
cold
]
fn
oom
(
)
-
>
!
{
panic
!
(
"
out
of
memory
"
)
}
unsafe
impl
<
'
a
>
alloc
:
:
Alloc
for
&
'
a
Bump
{
#
[
inline
(
always
)
]
unsafe
fn
alloc
(
&
mut
self
layout
:
Layout
)
-
>
Result
<
NonNull
<
u8
>
alloc
:
:
AllocErr
>
{
Ok
(
self
.
alloc_layout
(
layout
)
)
}
#
[
inline
(
always
)
]
unsafe
fn
dealloc
(
&
mut
self
_ptr
:
NonNull
<
u8
>
_layout
:
Layout
)
{
}
#
[
inline
]
unsafe
fn
realloc
(
&
mut
self
ptr
:
NonNull
<
u8
>
layout
:
Layout
new_size
:
usize
)
-
>
Result
<
NonNull
<
u8
>
alloc
:
:
AllocErr
>
{
let
old_size
=
layout
.
size
(
)
;
if
new_size
<
old_size
{
return
Ok
(
ptr
)
;
}
let
footer
=
self
.
current_chunk_footer
.
get
(
)
;
let
footer
=
footer
.
as_ref
(
)
;
let
footer_ptr
=
footer
.
ptr
.
get
(
)
.
as_ptr
(
)
as
usize
;
if
footer_ptr
.
checked_sub
(
old_size
)
=
=
Some
(
ptr
.
as_ptr
(
)
as
usize
)
{
let
delta
=
layout_from_size_align
(
new_size
-
old_size
1
)
;
if
let
Some
(
_
)
=
self
.
try_alloc_layout_fast
(
delta
)
{
return
Ok
(
ptr
)
;
}
}
let
new_layout
=
layout_from_size_align
(
new_size
layout
.
align
(
)
)
;
let
result
=
self
.
alloc
(
new_layout
)
;
if
let
Ok
(
new_ptr
)
=
result
{
ptr
:
:
copy_nonoverlapping
(
ptr
.
as_ptr
(
)
new_ptr
.
as_ptr
(
)
cmp
:
:
min
(
old_size
new_size
)
)
;
self
.
dealloc
(
ptr
layout
)
;
}
result
}
}
#
[
test
]
fn
chunk_footer_is_five_words
(
)
{
assert_eq
!
(
mem
:
:
size_of
:
:
<
ChunkFooter
>
(
)
mem
:
:
size_of
:
:
<
usize
>
(
)
*
5
)
;
}
