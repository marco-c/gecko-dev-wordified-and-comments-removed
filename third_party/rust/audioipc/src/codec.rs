use
bincode
:
:
{
self
Options
}
;
use
bytes
:
:
{
BufMut
ByteOrder
BytesMut
LittleEndian
}
;
use
serde
:
:
de
:
:
DeserializeOwned
;
use
serde
:
:
ser
:
:
Serialize
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
io
;
use
std
:
:
marker
:
:
PhantomData
;
pub
trait
Codec
{
type
In
;
type
Out
;
fn
decode
(
&
mut
self
buf
:
&
mut
BytesMut
)
-
>
io
:
:
Result
<
Option
<
Self
:
:
Out
>
>
;
fn
decode_eof
(
&
mut
self
buf
:
&
mut
BytesMut
)
-
>
io
:
:
Result
<
Self
:
:
Out
>
{
match
self
.
decode
(
buf
)
?
{
Some
(
frame
)
=
>
Ok
(
frame
)
None
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
bytes
remaining
on
stream
"
)
)
}
}
fn
encode
(
&
mut
self
msg
:
Self
:
:
In
buf
:
&
mut
BytesMut
)
-
>
io
:
:
Result
<
(
)
>
;
}
pub
struct
LengthDelimitedCodec
<
In
Out
>
{
state
:
State
__in
:
PhantomData
<
In
>
__out
:
PhantomData
<
Out
>
}
enum
State
{
Length
Data
(
usize
)
}
const
MAX_MESSAGE_LEN
:
u64
=
1024
*
1024
;
const
MESSAGE_LENGTH_SIZE
:
usize
=
std
:
:
mem
:
:
size_of
:
:
<
u32
>
(
)
;
impl
<
In
Out
>
Default
for
LengthDelimitedCodec
<
In
Out
>
{
fn
default
(
)
-
>
Self
{
LengthDelimitedCodec
{
state
:
State
:
:
Length
__in
:
PhantomData
__out
:
PhantomData
}
}
}
impl
<
In
Out
>
LengthDelimitedCodec
<
In
Out
>
{
fn
decode_length
(
&
mut
self
buf
:
&
mut
BytesMut
)
-
>
Option
<
usize
>
{
if
buf
.
len
(
)
<
MESSAGE_LENGTH_SIZE
{
return
None
;
}
let
n
=
LittleEndian
:
:
read_u32
(
buf
.
as_ref
(
)
)
;
let
_
=
buf
.
split_to
(
MESSAGE_LENGTH_SIZE
)
;
Some
(
n
as
usize
)
}
fn
decode_data
(
&
mut
self
buf
:
&
mut
BytesMut
n
:
usize
)
-
>
io
:
:
Result
<
Option
<
Out
>
>
where
Out
:
DeserializeOwned
+
Debug
{
if
buf
.
len
(
)
<
n
{
return
Ok
(
None
)
;
}
let
buf
=
buf
.
split_to
(
n
)
.
freeze
(
)
;
trace
!
(
"
Attempting
to
decode
"
)
;
let
msg
=
bincode
:
:
options
(
)
.
deserialize
:
:
<
Out
>
(
buf
.
as_ref
(
)
)
.
map_err
(
|
e
|
match
*
e
{
bincode
:
:
ErrorKind
:
:
Io
(
e
)
=
>
e
_
=
>
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
*
e
)
}
)
?
;
trace
!
(
"
.
.
.
Decoded
{
:
?
}
"
msg
)
;
Ok
(
Some
(
msg
)
)
}
}
impl
<
In
Out
>
Codec
for
LengthDelimitedCodec
<
In
Out
>
where
In
:
Serialize
+
Debug
Out
:
DeserializeOwned
+
Debug
{
type
In
=
In
;
type
Out
=
Out
;
fn
decode
(
&
mut
self
buf
:
&
mut
BytesMut
)
-
>
io
:
:
Result
<
Option
<
Self
:
:
Out
>
>
{
let
n
=
match
self
.
state
{
State
:
:
Length
=
>
{
match
self
.
decode_length
(
buf
)
{
Some
(
n
)
=
>
{
self
.
state
=
State
:
:
Data
(
n
)
;
buf
.
reserve
(
n
)
;
n
}
None
=
>
return
Ok
(
None
)
}
}
State
:
:
Data
(
n
)
=
>
n
}
;
match
self
.
decode_data
(
buf
n
)
?
{
Some
(
data
)
=
>
{
self
.
state
=
State
:
:
Length
;
buf
.
reserve
(
MESSAGE_LENGTH_SIZE
)
;
Ok
(
Some
(
data
)
)
}
None
=
>
Ok
(
None
)
}
}
fn
encode
(
&
mut
self
item
:
Self
:
:
In
buf
:
&
mut
BytesMut
)
-
>
io
:
:
Result
<
(
)
>
{
trace
!
(
"
Attempting
to
encode
"
)
;
let
encoded_len
=
bincode
:
:
options
(
)
.
serialized_size
(
&
item
)
.
unwrap
(
)
;
if
encoded_len
>
MAX_MESSAGE_LEN
{
trace
!
(
"
oversized
message
{
}
"
encoded_len
)
;
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
encoded
message
too
big
"
)
)
;
}
buf
.
reserve
(
(
encoded_len
as
usize
)
+
MESSAGE_LENGTH_SIZE
)
;
buf
.
put_u32_le
(
encoded_len
as
u32
)
;
if
let
Err
(
e
)
=
bincode
:
:
options
(
)
.
with_limit
(
encoded_len
)
.
serialize_into
:
:
<
_
Self
:
:
In
>
(
&
mut
buf
.
writer
(
)
&
item
)
{
match
*
e
{
bincode
:
:
ErrorKind
:
:
Io
(
e
)
=
>
return
Err
(
e
)
_
=
>
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
*
e
)
)
}
}
Ok
(
(
)
)
}
}
