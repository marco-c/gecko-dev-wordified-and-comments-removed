#
!
[
deny
(
missing_docs
missing_debug_implementations
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
tokio
-
fs
/
0
.
1
.
7
"
)
]
#
[
macro_use
]
extern
crate
futures
;
extern
crate
tokio_io
;
extern
crate
tokio_threadpool
;
mod
create_dir
;
mod
create_dir_all
;
pub
mod
file
;
mod
hard_link
;
mod
metadata
;
pub
mod
os
;
mod
read
;
mod
read_dir
;
mod
read_link
;
mod
remove_dir
;
mod
remove_file
;
mod
rename
;
mod
set_permissions
;
mod
stderr
;
mod
stdin
;
mod
stdout
;
mod
symlink_metadata
;
mod
write
;
pub
use
create_dir
:
:
{
create_dir
CreateDirFuture
}
;
pub
use
create_dir_all
:
:
{
create_dir_all
CreateDirAllFuture
}
;
pub
use
file
:
:
File
;
pub
use
file
:
:
OpenOptions
;
pub
use
hard_link
:
:
{
hard_link
HardLinkFuture
}
;
pub
use
metadata
:
:
{
metadata
MetadataFuture
}
;
pub
use
read
:
:
{
read
ReadFile
}
;
pub
use
read_dir
:
:
{
read_dir
DirEntry
ReadDir
ReadDirFuture
}
;
pub
use
read_link
:
:
{
read_link
ReadLinkFuture
}
;
pub
use
remove_dir
:
:
{
remove_dir
RemoveDirFuture
}
;
pub
use
remove_file
:
:
{
remove_file
RemoveFileFuture
}
;
pub
use
rename
:
:
{
rename
RenameFuture
}
;
pub
use
set_permissions
:
:
{
set_permissions
SetPermissionsFuture
}
;
pub
use
stderr
:
:
{
stderr
Stderr
}
;
pub
use
stdin
:
:
{
stdin
Stdin
}
;
pub
use
stdout
:
:
{
stdout
Stdout
}
;
pub
use
symlink_metadata
:
:
{
symlink_metadata
SymlinkMetadataFuture
}
;
pub
use
write
:
:
{
write
WriteFile
}
;
use
futures
:
:
Async
:
:
*
;
use
futures
:
:
Poll
;
use
std
:
:
io
;
use
std
:
:
io
:
:
ErrorKind
:
:
{
Other
WouldBlock
}
;
fn
blocking_io
<
F
T
>
(
f
:
F
)
-
>
Poll
<
T
io
:
:
Error
>
where
F
:
FnOnce
(
)
-
>
io
:
:
Result
<
T
>
{
match
tokio_threadpool
:
:
blocking
(
f
)
{
Ok
(
Ready
(
Ok
(
v
)
)
)
=
>
Ok
(
v
.
into
(
)
)
Ok
(
Ready
(
Err
(
err
)
)
)
=
>
Err
(
err
)
Ok
(
NotReady
)
=
>
Ok
(
NotReady
)
Err
(
_
)
=
>
Err
(
blocking_err
(
)
)
}
}
fn
would_block
<
F
T
>
(
f
:
F
)
-
>
io
:
:
Result
<
T
>
where
F
:
FnOnce
(
)
-
>
io
:
:
Result
<
T
>
{
match
tokio_threadpool
:
:
blocking
(
f
)
{
Ok
(
Ready
(
Ok
(
v
)
)
)
=
>
Ok
(
v
)
Ok
(
Ready
(
Err
(
err
)
)
)
=
>
{
debug_assert_ne
!
(
err
.
kind
(
)
WouldBlock
)
;
Err
(
err
)
}
Ok
(
NotReady
)
=
>
Err
(
WouldBlock
.
into
(
)
)
Err
(
_
)
=
>
Err
(
blocking_err
(
)
)
}
}
fn
blocking_err
(
)
-
>
io
:
:
Error
{
io
:
:
Error
:
:
new
(
Other
"
blocking
annotated
I
/
O
must
be
called
\
from
the
context
of
the
Tokio
runtime
.
"
)
}
