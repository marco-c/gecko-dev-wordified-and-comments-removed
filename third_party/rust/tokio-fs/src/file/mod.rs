mod
clone
;
mod
create
;
mod
metadata
;
mod
open
;
mod
open_options
;
mod
seek
;
pub
use
self
:
:
clone
:
:
CloneFuture
;
pub
use
self
:
:
create
:
:
CreateFuture
;
pub
use
self
:
:
metadata
:
:
MetadataFuture
;
pub
use
self
:
:
open
:
:
OpenFuture
;
pub
use
self
:
:
open_options
:
:
OpenOptions
;
pub
use
self
:
:
seek
:
:
SeekFuture
;
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
futures
:
:
Poll
;
use
std
:
:
fs
:
:
{
File
as
StdFile
Metadata
Permissions
}
;
use
std
:
:
io
:
:
{
self
Read
Seek
Write
}
;
use
std
:
:
path
:
:
Path
;
#
[
derive
(
Debug
)
]
pub
struct
File
{
std
:
Option
<
StdFile
>
}
impl
File
{
pub
fn
open
<
P
>
(
path
:
P
)
-
>
OpenFuture
<
P
>
where
P
:
AsRef
<
Path
>
+
Send
+
'
static
{
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
open
(
path
)
}
pub
fn
create
<
P
>
(
path
:
P
)
-
>
CreateFuture
<
P
>
where
P
:
AsRef
<
Path
>
+
Send
+
'
static
{
CreateFuture
:
:
new
(
path
)
}
pub
fn
from_std
(
std
:
StdFile
)
-
>
File
{
File
{
std
:
Some
(
std
)
}
}
pub
fn
poll_seek
(
&
mut
self
pos
:
io
:
:
SeekFrom
)
-
>
Poll
<
u64
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
self
.
std
(
)
.
seek
(
pos
)
)
}
pub
fn
seek
(
self
pos
:
io
:
:
SeekFrom
)
-
>
SeekFuture
{
SeekFuture
:
:
new
(
self
pos
)
}
pub
fn
poll_sync_all
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
self
.
std
(
)
.
sync_all
(
)
)
}
pub
fn
poll_sync_data
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
self
.
std
(
)
.
sync_data
(
)
)
}
pub
fn
poll_set_len
(
&
mut
self
size
:
u64
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
self
.
std
(
)
.
set_len
(
size
)
)
}
pub
fn
metadata
(
self
)
-
>
MetadataFuture
{
MetadataFuture
:
:
new
(
self
)
}
pub
fn
poll_metadata
(
&
mut
self
)
-
>
Poll
<
Metadata
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
self
.
std
(
)
.
metadata
(
)
)
}
pub
fn
poll_try_clone
(
&
mut
self
)
-
>
Poll
<
File
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
{
let
std
=
self
.
std
(
)
.
try_clone
(
)
?
;
Ok
(
File
:
:
from_std
(
std
)
)
}
)
}
pub
fn
try_clone
(
self
)
-
>
CloneFuture
{
CloneFuture
:
:
new
(
self
)
}
pub
fn
poll_set_permissions
(
&
mut
self
perm
:
Permissions
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
self
.
std
(
)
.
set_permissions
(
perm
)
)
}
pub
fn
into_std
(
mut
self
)
-
>
StdFile
{
self
.
std
.
take
(
)
.
expect
(
"
File
instance
already
shutdown
"
)
}
fn
std
(
&
mut
self
)
-
>
&
mut
StdFile
{
self
.
std
.
as_mut
(
)
.
expect
(
"
File
instance
already
shutdown
"
)
}
}
impl
Read
for
File
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
:
:
would_block
(
|
|
self
.
std
(
)
.
read
(
buf
)
)
}
}
impl
AsyncRead
for
File
{
unsafe
fn
prepare_uninitialized_buffer
(
&
self
_
:
&
mut
[
u8
]
)
-
>
bool
{
false
}
}
impl
Write
for
File
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
:
:
would_block
(
|
|
self
.
std
(
)
.
write
(
buf
)
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
:
:
would_block
(
|
|
self
.
std
(
)
.
flush
(
)
)
}
}
impl
AsyncWrite
for
File
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
:
:
blocking_io
(
|
|
{
self
.
std
=
None
;
Ok
(
(
)
)
}
)
}
}
impl
Drop
for
File
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
_std
)
=
self
.
std
.
take
(
)
{
}
}
}
