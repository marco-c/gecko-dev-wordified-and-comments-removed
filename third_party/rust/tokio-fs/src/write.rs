use
futures
:
:
{
Async
Future
Poll
}
;
use
std
:
:
{
fmt
io
mem
path
:
:
Path
}
;
use
tokio_io
;
use
{
file
File
}
;
pub
fn
write
<
P
C
:
AsRef
<
[
u8
]
>
>
(
path
:
P
contents
:
C
)
-
>
WriteFile
<
P
C
>
where
P
:
AsRef
<
Path
>
+
Send
+
'
static
{
WriteFile
{
state
:
State
:
:
Create
(
File
:
:
create
(
path
)
Some
(
contents
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
WriteFile
<
P
:
AsRef
<
Path
>
+
Send
+
'
static
C
:
AsRef
<
[
u8
]
>
>
{
state
:
State
<
P
C
>
}
#
[
derive
(
Debug
)
]
enum
State
<
P
:
AsRef
<
Path
>
+
Send
+
'
static
C
:
AsRef
<
[
u8
]
>
>
{
Create
(
file
:
:
CreateFuture
<
P
>
Option
<
C
>
)
Write
(
tokio_io
:
:
io
:
:
WriteAll
<
File
C
>
)
}
impl
<
P
:
AsRef
<
Path
>
+
Send
+
'
static
C
:
AsRef
<
[
u8
]
>
+
fmt
:
:
Debug
>
Future
for
WriteFile
<
P
C
>
{
type
Item
=
C
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
let
new_state
=
match
&
mut
self
.
state
{
State
:
:
Create
(
ref
mut
create_file
contents
)
=
>
{
let
file
=
try_ready
!
(
create_file
.
poll
(
)
)
;
let
write
=
tokio_io
:
:
io
:
:
write_all
(
file
contents
.
take
(
)
.
unwrap
(
)
)
;
State
:
:
Write
(
write
)
}
State
:
:
Write
(
ref
mut
write
)
=
>
{
let
(
_
contents
)
=
try_ready
!
(
write
.
poll
(
)
)
;
return
Ok
(
Async
:
:
Ready
(
contents
)
)
;
}
}
;
mem
:
:
replace
(
&
mut
self
.
state
new_state
)
;
self
.
poll
(
)
}
}
