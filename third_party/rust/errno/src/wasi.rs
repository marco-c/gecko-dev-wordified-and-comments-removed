use
core
:
:
str
;
use
libc
:
:
{
self
c_int
size_t
strerror_r
strlen
}
;
use
crate
:
:
Errno
;
fn
from_utf8_lossy
(
input
:
&
[
u8
]
)
-
>
&
str
{
match
str
:
:
from_utf8
(
input
)
{
Ok
(
valid
)
=
>
valid
Err
(
error
)
=
>
unsafe
{
str
:
:
from_utf8_unchecked
(
&
input
[
.
.
error
.
valid_up_to
(
)
]
)
}
}
}
pub
fn
with_description
<
F
T
>
(
err
:
Errno
callback
:
F
)
-
>
T
where
F
:
FnOnce
(
Result
<
&
str
Errno
>
)
-
>
T
{
let
mut
buf
=
[
0u8
;
1024
]
;
let
c_str
=
unsafe
{
let
rc
=
strerror_r
(
err
.
0
buf
.
as_mut_ptr
(
)
as
*
mut
_
buf
.
len
(
)
as
size_t
)
;
if
rc
!
=
0
{
let
fm_err
=
Errno
(
rc
)
;
if
fm_err
!
=
Errno
(
libc
:
:
ERANGE
)
{
return
callback
(
Err
(
fm_err
)
)
;
}
}
let
c_str_len
=
strlen
(
buf
.
as_ptr
(
)
as
*
const
_
)
;
&
buf
[
.
.
c_str_len
]
}
;
callback
(
Ok
(
from_utf8_lossy
(
c_str
)
)
)
}
pub
const
STRERROR_NAME
:
&
str
=
"
strerror_r
"
;
pub
fn
errno
(
)
-
>
Errno
{
unsafe
{
Errno
(
*
__errno_location
(
)
)
}
}
pub
fn
set_errno
(
Errno
(
new_errno
)
:
Errno
)
{
unsafe
{
*
__errno_location
(
)
=
new_errno
;
}
}
extern
"
C
"
{
fn
__errno_location
(
)
-
>
*
mut
c_int
;
}
