#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
memmap2
/
0
.
3
.
1
"
)
]
#
[
cfg
(
windows
)
]
mod
windows
;
#
[
cfg
(
windows
)
]
use
crate
:
:
windows
:
:
file_len
;
#
[
cfg
(
windows
)
]
use
crate
:
:
windows
:
:
MmapInner
;
#
[
cfg
(
unix
)
]
mod
unix
;
#
[
cfg
(
unix
)
]
use
crate
:
:
unix
:
:
file_len
;
#
[
cfg
(
unix
)
]
use
crate
:
:
unix
:
:
MmapInner
;
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
mod
stub
;
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
use
crate
:
:
stub
:
:
file_len
;
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
use
crate
:
:
stub
:
:
MmapInner
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
Error
ErrorKind
Result
}
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
AsRawFd
;
use
std
:
:
slice
;
use
std
:
:
usize
;
#
[
cfg
(
windows
)
]
pub
struct
MmapRawDescriptor
<
'
a
>
(
&
'
a
File
)
;
#
[
cfg
(
unix
)
]
pub
struct
MmapRawDescriptor
(
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
)
;
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
pub
struct
MmapRawDescriptor
<
'
a
>
(
&
'
a
File
)
;
pub
trait
MmapAsRawDesc
{
fn
as_raw_desc
(
&
self
)
-
>
MmapRawDescriptor
;
}
#
[
cfg
(
windows
)
]
impl
MmapAsRawDesc
for
&
File
{
fn
as_raw_desc
(
&
self
)
-
>
MmapRawDescriptor
{
MmapRawDescriptor
(
self
)
}
}
#
[
cfg
(
unix
)
]
impl
MmapAsRawDesc
for
&
File
{
fn
as_raw_desc
(
&
self
)
-
>
MmapRawDescriptor
{
MmapRawDescriptor
(
self
.
as_raw_fd
(
)
)
}
}
#
[
cfg
(
unix
)
]
impl
MmapAsRawDesc
for
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
{
fn
as_raw_desc
(
&
self
)
-
>
MmapRawDescriptor
{
MmapRawDescriptor
(
*
self
)
}
}
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
impl
MmapAsRawDesc
for
&
File
{
fn
as_raw_desc
(
&
self
)
-
>
MmapRawDescriptor
{
MmapRawDescriptor
(
self
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
MmapOptions
{
offset
:
u64
len
:
Option
<
usize
>
stack
:
bool
populate
:
bool
}
impl
MmapOptions
{
pub
fn
new
(
)
-
>
MmapOptions
{
MmapOptions
:
:
default
(
)
}
pub
fn
offset
(
&
mut
self
offset
:
u64
)
-
>
&
mut
Self
{
self
.
offset
=
offset
;
self
}
pub
fn
len
(
&
mut
self
len
:
usize
)
-
>
&
mut
Self
{
self
.
len
=
Some
(
len
)
;
self
}
fn
get_len
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
&
T
)
-
>
Result
<
usize
>
{
self
.
len
.
map
(
Ok
)
.
unwrap_or_else
(
|
|
{
let
desc
=
file
.
as_raw_desc
(
)
;
let
file_len
=
file_len
(
desc
.
0
)
?
;
if
file_len
<
self
.
offset
{
return
Err
(
Error
:
:
new
(
ErrorKind
:
:
InvalidData
"
memory
map
offset
is
larger
than
length
"
)
)
;
}
let
len
=
file_len
-
self
.
offset
;
#
[
cfg
(
not
(
target_pointer_width
=
"
64
"
)
)
]
{
if
len
>
(
usize
:
:
MAX
as
u64
)
{
return
Err
(
Error
:
:
new
(
ErrorKind
:
:
InvalidData
"
memory
map
length
overflows
usize
"
)
)
;
}
}
Ok
(
len
as
usize
)
}
)
}
pub
fn
stack
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
stack
=
true
;
self
}
pub
fn
populate
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
populate
=
true
;
self
}
pub
unsafe
fn
map
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
T
)
-
>
Result
<
Mmap
>
{
let
desc
=
file
.
as_raw_desc
(
)
;
MmapInner
:
:
map
(
self
.
get_len
(
&
file
)
?
desc
.
0
self
.
offset
self
.
populate
)
.
map
(
|
inner
|
Mmap
{
inner
}
)
}
pub
unsafe
fn
map_exec
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
T
)
-
>
Result
<
Mmap
>
{
let
desc
=
file
.
as_raw_desc
(
)
;
MmapInner
:
:
map_exec
(
self
.
get_len
(
&
file
)
?
desc
.
0
self
.
offset
self
.
populate
)
.
map
(
|
inner
|
Mmap
{
inner
:
inner
}
)
}
pub
unsafe
fn
map_mut
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
T
)
-
>
Result
<
MmapMut
>
{
let
desc
=
file
.
as_raw_desc
(
)
;
MmapInner
:
:
map_mut
(
self
.
get_len
(
&
file
)
?
desc
.
0
self
.
offset
self
.
populate
)
.
map
(
|
inner
|
MmapMut
{
inner
:
inner
}
)
}
pub
unsafe
fn
map_copy
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
T
)
-
>
Result
<
MmapMut
>
{
let
desc
=
file
.
as_raw_desc
(
)
;
MmapInner
:
:
map_copy
(
self
.
get_len
(
&
file
)
?
desc
.
0
self
.
offset
self
.
populate
)
.
map
(
|
inner
|
MmapMut
{
inner
:
inner
}
)
}
pub
unsafe
fn
map_copy_read_only
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
T
)
-
>
Result
<
Mmap
>
{
let
desc
=
file
.
as_raw_desc
(
)
;
MmapInner
:
:
map_copy_read_only
(
self
.
get_len
(
&
file
)
?
desc
.
0
self
.
offset
self
.
populate
)
.
map
(
|
inner
|
Mmap
{
inner
:
inner
}
)
}
pub
fn
map_anon
(
&
self
)
-
>
Result
<
MmapMut
>
{
MmapInner
:
:
map_anon
(
self
.
len
.
unwrap_or
(
0
)
self
.
stack
)
.
map
(
|
inner
|
MmapMut
{
inner
}
)
}
pub
fn
map_raw
<
T
:
MmapAsRawDesc
>
(
&
self
file
:
T
)
-
>
Result
<
MmapRaw
>
{
let
desc
=
file
.
as_raw_desc
(
)
;
MmapInner
:
:
map_mut
(
self
.
get_len
(
&
file
)
?
desc
.
0
self
.
offset
self
.
populate
)
.
map
(
|
inner
|
MmapRaw
{
inner
:
inner
}
)
}
}
pub
struct
Mmap
{
inner
:
MmapInner
}
impl
Mmap
{
pub
unsafe
fn
map
<
T
:
MmapAsRawDesc
>
(
file
:
T
)
-
>
Result
<
Mmap
>
{
MmapOptions
:
:
new
(
)
.
map
(
file
)
}
pub
fn
make_mut
(
mut
self
)
-
>
Result
<
MmapMut
>
{
self
.
inner
.
make_mut
(
)
?
;
Ok
(
MmapMut
{
inner
:
self
.
inner
}
)
}
}
impl
Deref
for
Mmap
{
type
Target
=
[
u8
]
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
inner
.
ptr
(
)
self
.
inner
.
len
(
)
)
}
}
}
impl
AsRef
<
[
u8
]
>
for
Mmap
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
self
.
deref
(
)
}
}
impl
fmt
:
:
Debug
for
Mmap
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Mmap
"
)
.
field
(
"
ptr
"
&
self
.
as_ptr
(
)
)
.
field
(
"
len
"
&
self
.
len
(
)
)
.
finish
(
)
}
}
pub
struct
MmapRaw
{
inner
:
MmapInner
}
impl
MmapRaw
{
pub
fn
map_raw
<
T
:
MmapAsRawDesc
>
(
file
:
T
)
-
>
Result
<
MmapRaw
>
{
MmapOptions
:
:
new
(
)
.
map_raw
(
file
)
}
#
[
inline
]
pub
fn
as_ptr
(
&
self
)
-
>
*
const
u8
{
self
.
inner
.
ptr
(
)
}
#
[
inline
]
pub
fn
as_mut_ptr
(
&
self
)
-
>
*
mut
u8
{
self
.
inner
.
ptr
(
)
as
_
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
}
impl
fmt
:
:
Debug
for
MmapRaw
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
MmapRaw
"
)
.
field
(
"
ptr
"
&
self
.
as_ptr
(
)
)
.
field
(
"
len
"
&
self
.
len
(
)
)
.
finish
(
)
}
}
pub
struct
MmapMut
{
inner
:
MmapInner
}
impl
MmapMut
{
pub
unsafe
fn
map_mut
<
T
:
MmapAsRawDesc
>
(
file
:
T
)
-
>
Result
<
MmapMut
>
{
MmapOptions
:
:
new
(
)
.
map_mut
(
file
)
}
pub
fn
map_anon
(
length
:
usize
)
-
>
Result
<
MmapMut
>
{
MmapOptions
:
:
new
(
)
.
len
(
length
)
.
map_anon
(
)
}
pub
fn
flush
(
&
self
)
-
>
Result
<
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
inner
.
flush
(
0
len
)
}
pub
fn
flush_async
(
&
self
)
-
>
Result
<
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
inner
.
flush_async
(
0
len
)
}
pub
fn
flush_range
(
&
self
offset
:
usize
len
:
usize
)
-
>
Result
<
(
)
>
{
self
.
inner
.
flush
(
offset
len
)
}
pub
fn
flush_async_range
(
&
self
offset
:
usize
len
:
usize
)
-
>
Result
<
(
)
>
{
self
.
inner
.
flush_async
(
offset
len
)
}
pub
fn
make_read_only
(
mut
self
)
-
>
Result
<
Mmap
>
{
self
.
inner
.
make_read_only
(
)
?
;
Ok
(
Mmap
{
inner
:
self
.
inner
}
)
}
pub
fn
make_exec
(
mut
self
)
-
>
Result
<
Mmap
>
{
self
.
inner
.
make_exec
(
)
?
;
Ok
(
Mmap
{
inner
:
self
.
inner
}
)
}
}
impl
Deref
for
MmapMut
{
type
Target
=
[
u8
]
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
inner
.
ptr
(
)
self
.
inner
.
len
(
)
)
}
}
}
impl
DerefMut
for
MmapMut
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
inner
.
mut_ptr
(
)
self
.
inner
.
len
(
)
)
}
}
}
impl
AsRef
<
[
u8
]
>
for
MmapMut
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
self
.
deref
(
)
}
}
impl
AsMut
<
[
u8
]
>
for
MmapMut
{
#
[
inline
]
fn
as_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
self
.
deref_mut
(
)
}
}
impl
fmt
:
:
Debug
for
MmapMut
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
MmapMut
"
)
.
field
(
"
ptr
"
&
self
.
as_ptr
(
)
)
.
field
(
"
len
"
&
self
.
len
(
)
)
.
finish
(
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
extern
crate
tempdir
;
use
std
:
:
fs
:
:
OpenOptions
;
use
std
:
:
io
:
:
{
Read
Write
}
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
AsRawFd
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
fs
:
:
OpenOptionsExt
;
#
[
cfg
(
windows
)
]
const
GENERIC_ALL
:
u32
=
0x10000000
;
use
super
:
:
{
Mmap
MmapMut
MmapOptions
}
;
#
[
test
]
fn
map_file
(
)
{
let
expected_len
=
128
;
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
file
.
set_len
(
expected_len
as
u64
)
.
unwrap
(
)
;
let
mut
mmap
=
unsafe
{
MmapMut
:
:
map_mut
(
&
file
)
.
unwrap
(
)
}
;
let
len
=
mmap
.
len
(
)
;
assert_eq
!
(
expected_len
len
)
;
let
zeros
=
vec
!
[
0
;
len
]
;
let
incr
:
Vec
<
u8
>
=
(
0
.
.
len
as
u8
)
.
collect
(
)
;
assert_eq
!
(
&
zeros
[
.
.
]
&
mmap
[
.
.
]
)
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
&
incr
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
&
incr
[
.
.
]
&
mmap
[
.
.
]
)
;
}
#
[
test
]
#
[
cfg
(
unix
)
]
fn
map_fd
(
)
{
let
expected_len
=
128
;
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
file
.
set_len
(
expected_len
as
u64
)
.
unwrap
(
)
;
let
mut
mmap
=
unsafe
{
MmapMut
:
:
map_mut
(
file
.
as_raw_fd
(
)
)
.
unwrap
(
)
}
;
let
len
=
mmap
.
len
(
)
;
assert_eq
!
(
expected_len
len
)
;
let
zeros
=
vec
!
[
0
;
len
]
;
let
incr
:
Vec
<
u8
>
=
(
0
.
.
len
as
u8
)
.
collect
(
)
;
assert_eq
!
(
&
zeros
[
.
.
]
&
mmap
[
.
.
]
)
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
&
incr
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
&
incr
[
.
.
]
&
mmap
[
.
.
]
)
;
}
#
[
test
]
fn
map_empty_file
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
let
mmap
=
unsafe
{
Mmap
:
:
map
(
&
file
)
}
;
assert
!
(
mmap
.
is_err
(
)
)
;
}
#
[
test
]
fn
map_anon
(
)
{
let
expected_len
=
128
;
let
mut
mmap
=
MmapMut
:
:
map_anon
(
expected_len
)
.
unwrap
(
)
;
let
len
=
mmap
.
len
(
)
;
assert_eq
!
(
expected_len
len
)
;
let
zeros
=
vec
!
[
0
;
len
]
;
let
incr
:
Vec
<
u8
>
=
(
0
.
.
len
as
u8
)
.
collect
(
)
;
assert_eq
!
(
&
zeros
[
.
.
]
&
mmap
[
.
.
]
)
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
&
incr
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
&
incr
[
.
.
]
&
mmap
[
.
.
]
)
;
}
#
[
test
]
fn
map_anon_zero_len
(
)
{
assert
!
(
MmapOptions
:
:
new
(
)
.
map_anon
(
)
.
is_err
(
)
)
}
#
[
test
]
fn
file_write
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
mut
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
file
.
set_len
(
128
)
.
unwrap
(
)
;
let
write
=
b
"
abc123
"
;
let
mut
read
=
[
0u8
;
6
]
;
let
mut
mmap
=
unsafe
{
MmapMut
:
:
map_mut
(
&
file
)
.
unwrap
(
)
}
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
write
)
.
unwrap
(
)
;
mmap
.
flush
(
)
.
unwrap
(
)
;
file
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
write
&
read
)
;
}
#
[
test
]
fn
flush_range
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
file
.
set_len
(
128
)
.
unwrap
(
)
;
let
write
=
b
"
abc123
"
;
let
mut
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
offset
(
2
)
.
len
(
write
.
len
(
)
)
.
map_mut
(
&
file
)
.
unwrap
(
)
}
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
write
)
.
unwrap
(
)
;
mmap
.
flush_async_range
(
0
write
.
len
(
)
)
.
unwrap
(
)
;
mmap
.
flush_range
(
0
write
.
len
(
)
)
.
unwrap
(
)
;
}
#
[
test
]
fn
map_copy
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
mut
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
file
.
set_len
(
128
)
.
unwrap
(
)
;
let
nulls
=
b
"
\
0
\
0
\
0
\
0
\
0
\
0
"
;
let
write
=
b
"
abc123
"
;
let
mut
read
=
[
0u8
;
6
]
;
let
mut
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map_copy
(
&
file
)
.
unwrap
(
)
}
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
write
)
.
unwrap
(
)
;
mmap
.
flush
(
)
.
unwrap
(
)
;
(
&
mmap
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
write
&
read
)
;
file
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
nulls
&
read
)
;
let
mmap2
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map
(
&
file
)
.
unwrap
(
)
}
;
(
&
mmap2
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
nulls
&
read
)
;
}
#
[
test
]
fn
map_copy_read_only
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
file
.
set_len
(
128
)
.
unwrap
(
)
;
let
nulls
=
b
"
\
0
\
0
\
0
\
0
\
0
\
0
"
;
let
mut
read
=
[
0u8
;
6
]
;
let
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map_copy_read_only
(
&
file
)
.
unwrap
(
)
}
;
(
&
mmap
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
nulls
&
read
)
;
let
mmap2
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map
(
&
file
)
.
unwrap
(
)
}
;
(
&
mmap2
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
nulls
&
read
)
;
}
#
[
cfg
(
all
(
target_os
=
"
linux
"
target_pointer_width
=
"
32
"
)
)
]
#
[
test
]
fn
map_offset
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
let
offset
=
u32
:
:
max_value
(
)
as
u64
+
2
;
let
len
=
5432
;
file
.
set_len
(
offset
+
len
as
u64
)
.
unwrap
(
)
;
let
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
offset
(
offset
)
.
map_mut
(
&
file
)
}
;
assert
!
(
mmap
.
is_err
(
)
)
;
}
#
[
cfg
(
not
(
all
(
target_os
=
"
linux
"
target_pointer_width
=
"
32
"
)
)
)
]
#
[
test
]
fn
map_offset
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
unwrap
(
)
;
let
offset
=
u32
:
:
max_value
(
)
as
u64
+
2
;
let
len
=
5432
;
file
.
set_len
(
offset
+
len
as
u64
)
.
unwrap
(
)
;
let
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
offset
(
offset
)
.
map_mut
(
&
file
)
.
unwrap
(
)
}
;
assert_eq
!
(
len
mmap
.
len
(
)
)
;
let
mut
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
offset
(
offset
)
.
len
(
len
)
.
map_mut
(
&
file
)
.
unwrap
(
)
}
;
assert_eq
!
(
len
mmap
.
len
(
)
)
;
let
zeros
=
vec
!
[
0
;
len
]
;
let
incr
:
Vec
<
_
>
=
(
0
.
.
len
)
.
map
(
|
i
|
i
as
u8
)
.
collect
(
)
;
assert_eq
!
(
&
zeros
[
.
.
]
&
mmap
[
.
.
]
)
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
&
incr
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
&
incr
[
.
.
]
&
mmap
[
.
.
]
)
;
}
#
[
test
]
fn
index
(
)
{
let
mut
mmap
=
MmapMut
:
:
map_anon
(
128
)
.
unwrap
(
)
;
mmap
[
0
]
=
42
;
assert_eq
!
(
42
mmap
[
0
]
)
;
}
#
[
test
]
fn
sync_send
(
)
{
let
mmap
=
MmapMut
:
:
map_anon
(
129
)
.
unwrap
(
)
;
fn
is_sync_send
<
T
>
(
_val
:
T
)
where
T
:
Sync
+
Send
{
}
is_sync_send
(
mmap
)
;
}
#
[
cfg
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
fn
jit_x86
(
mut
mmap
:
MmapMut
)
{
use
std
:
:
mem
;
mmap
[
0
]
=
0xB8
;
mmap
[
1
]
=
0xAB
;
mmap
[
2
]
=
0x00
;
mmap
[
3
]
=
0x00
;
mmap
[
4
]
=
0x00
;
mmap
[
5
]
=
0xC3
;
let
mmap
=
mmap
.
make_exec
(
)
.
expect
(
"
make_exec
"
)
;
let
jitfn
:
extern
"
C
"
fn
(
)
-
>
u8
=
unsafe
{
mem
:
:
transmute
(
mmap
.
as_ptr
(
)
)
}
;
assert_eq
!
(
jitfn
(
)
0xab
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
fn
jit_x86_anon
(
)
{
jit_x86
(
MmapMut
:
:
map_anon
(
4096
)
.
unwrap
(
)
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
fn
jit_x86_file
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
mut
options
=
OpenOptions
:
:
new
(
)
;
#
[
cfg
(
windows
)
]
options
.
access_mode
(
GENERIC_ALL
)
;
let
file
=
options
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
tempdir
.
path
(
)
.
join
(
"
jit_x86
"
)
)
.
expect
(
"
open
"
)
;
file
.
set_len
(
4096
)
.
expect
(
"
set_len
"
)
;
jit_x86
(
unsafe
{
MmapMut
:
:
map_mut
(
&
file
)
.
expect
(
"
map_mut
"
)
}
)
;
}
#
[
test
]
fn
mprotect_file
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
mut
options
=
OpenOptions
:
:
new
(
)
;
#
[
cfg
(
windows
)
]
options
.
access_mode
(
GENERIC_ALL
)
;
let
mut
file
=
options
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
expect
(
"
open
"
)
;
file
.
set_len
(
256_u64
)
.
expect
(
"
set_len
"
)
;
let
mmap
=
unsafe
{
MmapMut
:
:
map_mut
(
&
file
)
.
expect
(
"
map_mut
"
)
}
;
let
mmap
=
mmap
.
make_read_only
(
)
.
expect
(
"
make_read_only
"
)
;
let
mut
mmap
=
mmap
.
make_mut
(
)
.
expect
(
"
make_mut
"
)
;
let
write
=
b
"
abc123
"
;
let
mut
read
=
[
0u8
;
6
]
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
write
)
.
unwrap
(
)
;
mmap
.
flush
(
)
.
unwrap
(
)
;
(
&
mmap
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
write
&
read
)
;
file
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
write
&
read
)
;
let
mmap2
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map
(
&
file
)
.
unwrap
(
)
}
;
(
&
mmap2
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
write
&
read
)
;
let
mmap
=
mmap
.
make_exec
(
)
.
expect
(
"
make_exec
"
)
;
drop
(
mmap
)
;
}
#
[
test
]
fn
mprotect_copy
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmap
"
)
;
let
mut
options
=
OpenOptions
:
:
new
(
)
;
#
[
cfg
(
windows
)
]
options
.
access_mode
(
GENERIC_ALL
)
;
let
mut
file
=
options
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
expect
(
"
open
"
)
;
file
.
set_len
(
256_u64
)
.
expect
(
"
set_len
"
)
;
let
mmap
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map_copy
(
&
file
)
.
expect
(
"
map_mut
"
)
}
;
let
mmap
=
mmap
.
make_read_only
(
)
.
expect
(
"
make_read_only
"
)
;
let
mut
mmap
=
mmap
.
make_mut
(
)
.
expect
(
"
make_mut
"
)
;
let
nulls
=
b
"
\
0
\
0
\
0
\
0
\
0
\
0
"
;
let
write
=
b
"
abc123
"
;
let
mut
read
=
[
0u8
;
6
]
;
(
&
mut
mmap
[
.
.
]
)
.
write_all
(
write
)
.
unwrap
(
)
;
mmap
.
flush
(
)
.
unwrap
(
)
;
(
&
mmap
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
write
&
read
)
;
file
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
nulls
&
read
)
;
let
mmap2
=
unsafe
{
MmapOptions
:
:
new
(
)
.
map
(
&
file
)
.
unwrap
(
)
}
;
(
&
mmap2
[
.
.
]
)
.
read_exact
(
&
mut
read
)
.
unwrap
(
)
;
assert_eq
!
(
nulls
&
read
)
;
let
mmap
=
mmap
.
make_exec
(
)
.
expect
(
"
make_exec
"
)
;
drop
(
mmap
)
;
}
#
[
test
]
fn
mprotect_anon
(
)
{
let
mmap
=
MmapMut
:
:
map_anon
(
256
)
.
expect
(
"
map_mut
"
)
;
let
mmap
=
mmap
.
make_read_only
(
)
.
expect
(
"
make_read_only
"
)
;
let
mmap
=
mmap
.
make_mut
(
)
.
expect
(
"
make_mut
"
)
;
let
mmap
=
mmap
.
make_exec
(
)
.
expect
(
"
make_exec
"
)
;
drop
(
mmap
)
;
}
#
[
test
]
fn
raw
(
)
{
let
tempdir
=
tempdir
:
:
TempDir
:
:
new
(
"
mmap
"
)
.
unwrap
(
)
;
let
path
=
tempdir
.
path
(
)
.
join
(
"
mmapraw
"
)
;
let
mut
options
=
OpenOptions
:
:
new
(
)
;
let
mut
file
=
options
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
open
(
&
path
)
.
expect
(
"
open
"
)
;
file
.
write_all
(
b
"
abc123
"
)
.
unwrap
(
)
;
let
mmap
=
MmapOptions
:
:
new
(
)
.
map_raw
(
&
file
)
.
unwrap
(
)
;
assert_eq
!
(
mmap
.
len
(
)
6
)
;
assert
!
(
!
mmap
.
as_ptr
(
)
.
is_null
(
)
)
;
assert_eq
!
(
unsafe
{
std
:
:
ptr
:
:
read
(
mmap
.
as_ptr
(
)
)
}
b
'
a
'
)
;
}
}
