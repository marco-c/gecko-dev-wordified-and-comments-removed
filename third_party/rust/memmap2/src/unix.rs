extern
crate
libc
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
RawFd
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
{
io
ptr
}
;
use
crate
:
:
advice
:
:
Advice
;
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
mips
"
)
)
target_os
=
"
freebsd
"
target_os
=
"
android
"
)
)
]
const
MAP_STACK
:
libc
:
:
c_int
=
libc
:
:
MAP_STACK
;
#
[
cfg
(
not
(
any
(
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
mips
"
)
)
target_os
=
"
freebsd
"
target_os
=
"
android
"
)
)
)
]
const
MAP_STACK
:
libc
:
:
c_int
=
0
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
const
MAP_POPULATE
:
libc
:
:
c_int
=
libc
:
:
MAP_POPULATE
;
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
]
const
MAP_POPULATE
:
libc
:
:
c_int
=
0
;
pub
struct
MmapInner
{
ptr
:
*
mut
libc
:
:
c_void
len
:
usize
}
impl
MmapInner
{
fn
new
(
len
:
usize
prot
:
libc
:
:
c_int
flags
:
libc
:
:
c_int
file
:
RawFd
offset
:
u64
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
alignment
=
offset
%
page_size
(
)
as
u64
;
let
aligned_offset
=
offset
-
alignment
;
let
aligned_len
=
len
+
alignment
as
usize
;
let
aligned_len
=
aligned_len
.
max
(
1
)
;
unsafe
{
let
ptr
=
libc
:
:
mmap
(
ptr
:
:
null_mut
(
)
aligned_len
as
libc
:
:
size_t
prot
flags
file
aligned_offset
as
libc
:
:
off_t
)
;
if
ptr
=
=
libc
:
:
MAP_FAILED
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
MmapInner
{
ptr
:
ptr
.
offset
(
alignment
as
isize
)
len
}
)
}
}
}
pub
fn
map
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
libc
:
:
MAP_SHARED
|
populate
file
offset
)
}
pub
fn
map_exec
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_EXEC
libc
:
:
MAP_SHARED
|
populate
file
offset
)
}
pub
fn
map_mut
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
libc
:
:
MAP_SHARED
|
populate
file
offset
)
}
pub
fn
map_copy
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
libc
:
:
MAP_PRIVATE
|
populate
file
offset
)
}
pub
fn
map_copy_read_only
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
libc
:
:
MAP_PRIVATE
|
populate
file
offset
)
}
pub
fn
map_anon
(
len
:
usize
stack
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
stack
=
if
stack
{
MAP_STACK
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
libc
:
:
MAP_PRIVATE
|
libc
:
:
MAP_ANON
|
stack
-
1
0
)
}
pub
fn
flush
(
&
self
offset
:
usize
len
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
let
alignment
=
(
self
.
ptr
as
usize
+
offset
)
%
page_size
(
)
;
let
offset
=
offset
as
isize
-
alignment
as
isize
;
let
len
=
len
+
alignment
;
let
result
=
unsafe
{
libc
:
:
msync
(
self
.
ptr
.
offset
(
offset
)
len
as
libc
:
:
size_t
libc
:
:
MS_SYNC
)
}
;
if
result
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
pub
fn
flush_async
(
&
self
offset
:
usize
len
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
let
alignment
=
(
self
.
ptr
as
usize
+
offset
)
%
page_size
(
)
;
let
offset
=
offset
as
isize
-
alignment
as
isize
;
let
len
=
len
+
alignment
;
let
result
=
unsafe
{
libc
:
:
msync
(
self
.
ptr
.
offset
(
offset
)
len
as
libc
:
:
size_t
libc
:
:
MS_ASYNC
)
}
;
if
result
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
fn
mprotect
(
&
mut
self
prot
:
libc
:
:
c_int
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
let
alignment
=
self
.
ptr
as
usize
%
page_size
(
)
;
let
ptr
=
self
.
ptr
.
offset
(
-
(
alignment
as
isize
)
)
;
let
len
=
self
.
len
+
alignment
;
let
len
=
len
.
max
(
1
)
;
if
libc
:
:
mprotect
(
ptr
len
prot
)
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
}
pub
fn
make_read_only
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
mprotect
(
libc
:
:
PROT_READ
)
}
pub
fn
make_exec
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
mprotect
(
libc
:
:
PROT_READ
|
libc
:
:
PROT_EXEC
)
}
pub
fn
make_mut
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
mprotect
(
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
)
}
#
[
inline
]
pub
fn
ptr
(
&
self
)
-
>
*
const
u8
{
self
.
ptr
as
*
const
u8
}
#
[
inline
]
pub
fn
mut_ptr
(
&
mut
self
)
-
>
*
mut
u8
{
self
.
ptr
as
*
mut
u8
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
pub
fn
advise
(
&
self
advice
:
Advice
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
if
libc
:
:
madvise
(
self
.
ptr
self
.
len
advice
as
i32
)
!
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
pub
fn
lock
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
if
libc
:
:
mlock
(
self
.
ptr
self
.
len
)
!
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
pub
fn
unlock
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
if
libc
:
:
munlock
(
self
.
ptr
self
.
len
)
!
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
}
impl
Drop
for
MmapInner
{
fn
drop
(
&
mut
self
)
{
let
alignment
=
self
.
ptr
as
usize
%
page_size
(
)
;
let
len
=
self
.
len
+
alignment
;
let
len
=
len
.
max
(
1
)
;
unsafe
{
let
ptr
=
self
.
ptr
.
offset
(
-
(
alignment
as
isize
)
)
;
libc
:
:
munmap
(
ptr
len
as
libc
:
:
size_t
)
;
}
}
}
unsafe
impl
Sync
for
MmapInner
{
}
unsafe
impl
Send
for
MmapInner
{
}
fn
page_size
(
)
-
>
usize
{
static
PAGE_SIZE
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
match
PAGE_SIZE
.
load
(
Ordering
:
:
Relaxed
)
{
0
=
>
{
let
page_size
=
unsafe
{
libc
:
:
sysconf
(
libc
:
:
_SC_PAGESIZE
)
as
usize
}
;
PAGE_SIZE
.
store
(
page_size
Ordering
:
:
Relaxed
)
;
page_size
}
page_size
=
>
page_size
}
}
pub
fn
file_len
(
file
:
RawFd
)
-
>
io
:
:
Result
<
u64
>
{
unsafe
{
let
file
=
ManuallyDrop
:
:
new
(
File
:
:
from_raw_fd
(
file
)
)
;
Ok
(
file
.
metadata
(
)
?
.
len
(
)
)
}
}
