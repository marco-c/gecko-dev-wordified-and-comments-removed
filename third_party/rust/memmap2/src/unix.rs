extern
crate
libc
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
FromRawFd
RawFd
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
{
io
ptr
}
;
use
crate
:
:
advice
:
:
Advice
;
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
mips
"
)
)
target_os
=
"
freebsd
"
target_os
=
"
android
"
)
)
]
const
MAP_STACK
:
libc
:
:
c_int
=
libc
:
:
MAP_STACK
;
#
[
cfg
(
not
(
any
(
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
mips
"
)
)
target_os
=
"
freebsd
"
target_os
=
"
android
"
)
)
)
]
const
MAP_STACK
:
libc
:
:
c_int
=
0
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
const
MAP_POPULATE
:
libc
:
:
c_int
=
libc
:
:
MAP_POPULATE
;
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
]
const
MAP_POPULATE
:
libc
:
:
c_int
=
0
;
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_env
=
"
musl
"
)
)
)
)
]
use
libc
:
:
{
mmap64
as
mmap
off64_t
as
off_t
}
;
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_env
=
"
musl
"
)
)
)
)
)
]
use
libc
:
:
{
mmap
off_t
}
;
pub
struct
MmapInner
{
ptr
:
*
mut
libc
:
:
c_void
len
:
usize
}
impl
MmapInner
{
fn
new
(
len
:
usize
prot
:
libc
:
:
c_int
flags
:
libc
:
:
c_int
file
:
RawFd
offset
:
u64
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
alignment
=
offset
%
page_size
(
)
as
u64
;
let
aligned_offset
=
offset
-
alignment
;
let
(
map_len
map_offset
)
=
Self
:
:
adjust_mmap_params
(
len
alignment
as
usize
)
?
;
unsafe
{
let
ptr
=
mmap
(
ptr
:
:
null_mut
(
)
map_len
as
libc
:
:
size_t
prot
flags
file
aligned_offset
as
off_t
)
;
if
ptr
=
=
libc
:
:
MAP_FAILED
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
Self
:
:
from_raw_parts
(
ptr
len
map_offset
)
)
}
}
}
fn
adjust_mmap_params
(
len
:
usize
alignment
:
usize
)
-
>
io
:
:
Result
<
(
usize
usize
)
>
{
use
std
:
:
isize
;
if
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
<
8
&
&
len
>
isize
:
:
MAX
as
usize
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
"
memory
map
length
overflows
isize
"
)
)
;
}
let
map_len
=
len
+
alignment
;
let
map_offset
=
alignment
;
let
map_len
=
map_len
.
max
(
1
)
;
Ok
(
(
map_len
map_offset
)
)
}
fn
as_mmap_params
(
&
self
)
-
>
(
*
mut
libc
:
:
c_void
usize
usize
)
{
let
offset
=
self
.
ptr
as
usize
%
page_size
(
)
;
let
len
=
self
.
len
+
offset
;
if
len
=
=
0
{
(
self
.
ptr
1
0
)
}
else
{
(
unsafe
{
self
.
ptr
.
offset
(
-
(
offset
as
isize
)
)
}
len
offset
)
}
}
unsafe
fn
from_raw_parts
(
ptr
:
*
mut
libc
:
:
c_void
len
:
usize
offset
:
usize
)
-
>
Self
{
debug_assert_eq
!
(
ptr
as
usize
%
page_size
(
)
0
"
ptr
not
page
-
aligned
"
)
;
debug_assert
!
(
offset
<
page_size
(
)
"
offset
larger
than
page
size
"
)
;
Self
{
ptr
:
ptr
.
add
(
offset
)
len
}
}
pub
fn
map
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
libc
:
:
MAP_SHARED
|
populate
file
offset
)
}
pub
fn
map_exec
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_EXEC
libc
:
:
MAP_SHARED
|
populate
file
offset
)
}
pub
fn
map_mut
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
libc
:
:
MAP_SHARED
|
populate
file
offset
)
}
pub
fn
map_copy
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
libc
:
:
MAP_PRIVATE
|
populate
file
offset
)
}
pub
fn
map_copy_read_only
(
len
:
usize
file
:
RawFd
offset
:
u64
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
libc
:
:
MAP_PRIVATE
|
populate
file
offset
)
}
pub
fn
map_anon
(
len
:
usize
stack
:
bool
populate
:
bool
)
-
>
io
:
:
Result
<
MmapInner
>
{
let
stack
=
if
stack
{
MAP_STACK
}
else
{
0
}
;
let
populate
=
if
populate
{
MAP_POPULATE
}
else
{
0
}
;
MmapInner
:
:
new
(
len
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
libc
:
:
MAP_PRIVATE
|
libc
:
:
MAP_ANON
|
stack
|
populate
-
1
0
)
}
pub
fn
flush
(
&
self
offset
:
usize
len
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
let
alignment
=
(
self
.
ptr
as
usize
+
offset
)
%
page_size
(
)
;
let
offset
=
offset
as
isize
-
alignment
as
isize
;
let
len
=
len
+
alignment
;
let
result
=
unsafe
{
libc
:
:
msync
(
self
.
ptr
.
offset
(
offset
)
len
as
libc
:
:
size_t
libc
:
:
MS_SYNC
)
}
;
if
result
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
pub
fn
flush_async
(
&
self
offset
:
usize
len
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
let
alignment
=
(
self
.
ptr
as
usize
+
offset
)
%
page_size
(
)
;
let
offset
=
offset
as
isize
-
alignment
as
isize
;
let
len
=
len
+
alignment
;
let
result
=
unsafe
{
libc
:
:
msync
(
self
.
ptr
.
offset
(
offset
)
len
as
libc
:
:
size_t
libc
:
:
MS_ASYNC
)
}
;
if
result
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
fn
mprotect
(
&
mut
self
prot
:
libc
:
:
c_int
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
let
alignment
=
self
.
ptr
as
usize
%
page_size
(
)
;
let
ptr
=
self
.
ptr
.
offset
(
-
(
alignment
as
isize
)
)
;
let
len
=
self
.
len
+
alignment
;
let
len
=
len
.
max
(
1
)
;
if
libc
:
:
mprotect
(
ptr
len
prot
)
=
=
0
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
}
pub
fn
make_read_only
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
mprotect
(
libc
:
:
PROT_READ
)
}
pub
fn
make_exec
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
mprotect
(
libc
:
:
PROT_READ
|
libc
:
:
PROT_EXEC
)
}
pub
fn
make_mut
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
mprotect
(
libc
:
:
PROT_READ
|
libc
:
:
PROT_WRITE
)
}
#
[
inline
]
pub
fn
ptr
(
&
self
)
-
>
*
const
u8
{
self
.
ptr
as
*
const
u8
}
#
[
inline
]
pub
fn
mut_ptr
(
&
mut
self
)
-
>
*
mut
u8
{
self
.
ptr
as
*
mut
u8
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
pub
fn
advise
(
&
self
advice
:
Advice
offset
:
usize
len
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
let
alignment
=
(
self
.
ptr
as
usize
+
offset
)
%
page_size
(
)
;
let
offset
=
offset
as
isize
-
alignment
as
isize
;
let
len
=
len
+
alignment
;
unsafe
{
if
libc
:
:
madvise
(
self
.
ptr
.
offset
(
offset
)
len
advice
.
0
)
!
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
#
[
cfg
(
target_os
=
"
linux
"
)
]
pub
fn
remap
(
&
mut
self
new_len
:
usize
options
:
crate
:
:
RemapOptions
)
-
>
io
:
:
Result
<
(
)
>
{
let
(
old_ptr
old_len
offset
)
=
self
.
as_mmap_params
(
)
;
let
(
map_len
offset
)
=
Self
:
:
adjust_mmap_params
(
new_len
offset
)
?
;
unsafe
{
let
new_ptr
=
libc
:
:
mremap
(
old_ptr
old_len
map_len
options
.
into_flags
(
)
)
;
if
new_ptr
=
=
libc
:
:
MAP_FAILED
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
ptr
:
:
write
(
self
Self
:
:
from_raw_parts
(
new_ptr
new_len
offset
)
)
;
Ok
(
(
)
)
}
}
}
pub
fn
lock
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
if
libc
:
:
mlock
(
self
.
ptr
self
.
len
)
!
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
pub
fn
unlock
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
if
libc
:
:
munlock
(
self
.
ptr
self
.
len
)
!
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
}
impl
Drop
for
MmapInner
{
fn
drop
(
&
mut
self
)
{
let
(
ptr
len
_
)
=
self
.
as_mmap_params
(
)
;
unsafe
{
libc
:
:
munmap
(
ptr
len
as
libc
:
:
size_t
)
}
;
}
}
unsafe
impl
Sync
for
MmapInner
{
}
unsafe
impl
Send
for
MmapInner
{
}
fn
page_size
(
)
-
>
usize
{
static
PAGE_SIZE
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
match
PAGE_SIZE
.
load
(
Ordering
:
:
Relaxed
)
{
0
=
>
{
let
page_size
=
unsafe
{
libc
:
:
sysconf
(
libc
:
:
_SC_PAGESIZE
)
as
usize
}
;
PAGE_SIZE
.
store
(
page_size
Ordering
:
:
Relaxed
)
;
page_size
}
page_size
=
>
page_size
}
}
pub
fn
file_len
(
file
:
RawFd
)
-
>
io
:
:
Result
<
u64
>
{
unsafe
{
let
file
=
ManuallyDrop
:
:
new
(
File
:
:
from_raw_fd
(
file
)
)
;
Ok
(
file
.
metadata
(
)
?
.
len
(
)
)
}
}
