use
regex
:
:
RegexSet
as
RxSet
;
#
[
derive
(
Debug
)
]
pub
struct
RegexSet
{
items
:
Vec
<
String
>
set
:
Option
<
RxSet
>
}
impl
RegexSet
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
items
.
is_empty
(
)
}
pub
fn
extend
<
I
S
>
(
&
mut
self
iter
:
I
)
where
I
:
IntoIterator
<
Item
=
S
>
S
:
AsRef
<
str
>
{
for
s
in
iter
.
into_iter
(
)
{
self
.
insert
(
s
)
}
}
pub
fn
insert
<
S
>
(
&
mut
self
string
:
S
)
where
S
:
AsRef
<
str
>
{
self
.
items
.
push
(
format
!
(
"
^
{
}
"
string
.
as_ref
(
)
)
)
;
self
.
set
=
None
;
}
pub
fn
get_items
(
&
self
)
-
>
&
[
String
]
{
&
self
.
items
[
.
.
]
}
pub
fn
get_set
(
&
self
)
-
>
Option
<
&
RxSet
>
{
self
.
set
.
as_ref
(
)
}
pub
fn
build
(
&
mut
self
)
{
self
.
set
=
match
RxSet
:
:
new
(
&
self
.
items
)
{
Ok
(
x
)
=
>
Some
(
x
)
Err
(
e
)
=
>
{
error
!
(
"
Invalid
regex
in
{
:
?
}
:
{
:
?
}
"
self
.
items
e
)
;
None
}
}
}
pub
fn
matches
<
S
>
(
&
self
string
:
S
)
-
>
bool
where
S
:
AsRef
<
str
>
{
let
s
=
string
.
as_ref
(
)
;
self
.
set
.
as_ref
(
)
.
map
(
|
set
|
set
.
is_match
(
s
)
)
.
unwrap_or
(
false
)
}
}
impl
Default
for
RegexSet
{
fn
default
(
)
-
>
Self
{
RegexSet
{
items
:
vec
!
[
]
set
:
None
}
}
}
