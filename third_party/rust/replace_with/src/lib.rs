#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
cfg_attr
(
all
(
not
(
feature
=
"
std
"
)
feature
=
"
nightly
"
)
feature
(
core_intrinsics
)
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
replace_with
/
0
.
1
.
7
"
)
]
#
!
[
warn
(
missing_copy_implementations
missing_debug_implementations
missing_docs
trivial_casts
trivial_numeric_casts
unused_import_braces
unused_qualifications
unused_results
)
]
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
core
as
std
;
use
std
:
:
{
mem
ptr
}
;
struct
OnDrop
<
F
:
FnOnce
(
)
>
(
mem
:
:
ManuallyDrop
<
F
>
)
;
impl
<
F
:
FnOnce
(
)
>
Drop
for
OnDrop
<
F
>
{
#
[
inline
(
always
)
]
fn
drop
(
&
mut
self
)
{
(
unsafe
{
ptr
:
:
read
(
&
*
self
.
0
)
}
)
(
)
;
}
}
#
[
doc
(
hidden
)
]
#
[
inline
(
always
)
]
pub
fn
on_unwind
<
F
:
FnOnce
(
)
-
>
T
T
P
:
FnOnce
(
)
>
(
f
:
F
p
:
P
)
-
>
T
{
let
x
=
OnDrop
(
mem
:
:
ManuallyDrop
:
:
new
(
p
)
)
;
let
t
=
f
(
)
;
let
mut
x
=
mem
:
:
ManuallyDrop
:
:
new
(
x
)
;
unsafe
{
mem
:
:
ManuallyDrop
:
:
drop
(
&
mut
x
.
0
)
}
;
t
}
#
[
doc
(
hidden
)
]
#
[
inline
(
always
)
]
pub
fn
on_return_or_unwind
<
F
:
FnOnce
(
)
-
>
T
T
P
:
FnOnce
(
)
>
(
f
:
F
p
:
P
)
-
>
T
{
let
_x
=
OnDrop
(
mem
:
:
ManuallyDrop
:
:
new
(
p
)
)
;
f
(
)
}
#
[
inline
]
pub
fn
replace_with
<
T
D
:
FnOnce
(
)
-
>
T
F
:
FnOnce
(
T
)
-
>
T
>
(
dest
:
&
mut
T
default
:
D
f
:
F
)
{
unsafe
{
let
old
=
ptr
:
:
read
(
dest
)
;
let
new
=
on_unwind
(
move
|
|
f
(
old
)
|
|
ptr
:
:
write
(
dest
default
(
)
)
)
;
ptr
:
:
write
(
dest
new
)
;
}
}
#
[
inline
]
pub
fn
replace_with_or_default
<
T
:
Default
F
:
FnOnce
(
T
)
-
>
T
>
(
dest
:
&
mut
T
f
:
F
)
{
replace_with
(
dest
T
:
:
default
f
)
;
}
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
replace_with_or_abort
<
T
F
:
FnOnce
(
T
)
-
>
T
>
(
dest
:
&
mut
T
f
:
F
)
{
replace_with
(
dest
|
|
std
:
:
process
:
:
abort
(
)
f
)
;
}
#
[
inline
]
#
[
cfg
(
all
(
not
(
feature
=
"
std
"
)
feature
=
"
nightly
"
)
)
]
pub
fn
replace_with_or_abort
<
T
F
:
FnOnce
(
T
)
-
>
T
>
(
dest
:
&
mut
T
f
:
F
)
{
replace_with
(
dest
|
|
unsafe
{
std
:
:
intrinsics
:
:
abort
(
)
}
f
)
;
}
#
[
inline
]
#
[
cfg
(
feature
=
"
panic_abort
"
)
]
pub
unsafe
fn
replace_with_or_abort_unchecked
<
T
F
:
FnOnce
(
T
)
-
>
T
>
(
dest
:
&
mut
T
f
:
F
)
{
ptr
:
:
write
(
dest
f
(
ptr
:
:
read
(
dest
)
)
)
;
}
#
[
inline
]
pub
fn
replace_with_and_return
<
T
U
D
:
FnOnce
(
)
-
>
T
F
:
FnOnce
(
T
)
-
>
(
U
T
)
>
(
dest
:
&
mut
T
default
:
D
f
:
F
)
-
>
U
{
unsafe
{
let
old
=
ptr
:
:
read
(
dest
)
;
let
(
res
new
)
=
on_unwind
(
move
|
|
f
(
old
)
|
|
ptr
:
:
write
(
dest
default
(
)
)
)
;
ptr
:
:
write
(
dest
new
)
;
res
}
}
#
[
inline
]
pub
fn
replace_with_or_default_and_return
<
T
:
Default
U
F
:
FnOnce
(
T
)
-
>
(
U
T
)
>
(
dest
:
&
mut
T
f
:
F
)
-
>
U
{
replace_with_and_return
(
dest
T
:
:
default
f
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
replace_with_or_abort_and_return
<
T
U
F
:
FnOnce
(
T
)
-
>
(
U
T
)
>
(
dest
:
&
mut
T
f
:
F
)
-
>
U
{
replace_with_and_return
(
dest
|
|
std
:
:
process
:
:
abort
(
)
f
)
}
#
[
inline
]
#
[
cfg
(
all
(
not
(
feature
=
"
std
"
)
feature
=
"
nightly
"
)
)
]
pub
fn
replace_with_or_abort_and_return
<
T
U
F
:
FnOnce
(
T
)
-
>
(
U
T
)
>
(
dest
:
&
mut
T
f
:
F
)
-
>
U
{
replace_with_and_return
(
dest
|
|
unsafe
{
std
:
:
intrinsics
:
:
abort
(
)
}
f
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg
(
feature
=
"
panic_abort
"
)
]
pub
unsafe
fn
replace_with_or_abort_and_return_unchecked
<
T
U
F
:
FnOnce
(
T
)
-
>
(
U
T
)
>
(
dest
:
&
mut
T
f
:
F
)
-
>
U
{
let
(
res
new
)
=
f
(
ptr
:
:
read
(
dest
)
)
;
ptr
:
:
write
(
dest
new
)
;
res
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
it_works_recover
(
)
{
#
[
derive
(
PartialEq
Eq
Debug
)
]
enum
Foo
{
A
B
}
;
impl
Drop
for
Foo
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
drop
(
&
mut
self
)
{
match
*
self
{
Foo
:
:
A
=
>
println
!
(
"
Foo
:
:
A
dropped
"
)
Foo
:
:
B
=
>
println
!
(
"
Foo
:
:
B
dropped
"
)
}
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
fn
drop
(
&
mut
self
)
{
match
*
self
{
Foo
:
:
A
|
Foo
:
:
B
=
>
(
)
}
}
}
let
mut
quax
=
Foo
:
:
A
;
replace_with
(
&
mut
quax
|
|
Foo
:
:
A
|
f
|
{
drop
(
f
)
;
Foo
:
:
B
}
)
;
assert_eq
!
(
&
quax
&
Foo
:
:
B
)
;
let
n
=
replace_with_and_return
(
&
mut
quax
|
|
Foo
:
:
B
|
f
|
{
drop
(
f
)
;
(
3
Foo
:
:
A
)
}
)
;
assert_eq
!
(
n
3
)
;
assert_eq
!
(
&
quax
&
Foo
:
:
A
)
;
}
#
[
cfg
(
all
(
feature
=
"
std
"
not
(
miri
)
)
)
]
#
[
test
]
fn
it_works_recover_panic
(
)
{
use
std
:
:
panic
;
#
[
derive
(
PartialEq
Eq
Debug
)
]
enum
Foo
{
A
B
C
}
;
impl
Drop
for
Foo
{
fn
drop
(
&
mut
self
)
{
match
*
self
{
Foo
:
:
A
=
>
println
!
(
"
Foo
:
:
A
dropped
"
)
Foo
:
:
B
=
>
println
!
(
"
Foo
:
:
B
dropped
"
)
Foo
:
:
C
=
>
println
!
(
"
Foo
:
:
C
dropped
"
)
}
}
}
let
mut
quax
=
Foo
:
:
A
;
let
res
=
panic
:
:
catch_unwind
(
panic
:
:
AssertUnwindSafe
(
|
|
{
replace_with
(
&
mut
quax
|
|
Foo
:
:
C
|
f
|
{
drop
(
f
)
;
panic
!
(
"
panic
"
)
;
#
[
allow
(
unreachable_code
)
]
Foo
:
:
B
}
)
;
}
)
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
&
quax
&
Foo
:
:
C
)
;
}
}
