#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
deny
(
unsafe_op_in_unsafe_fn
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
cfg_attr
(
docs_build
feature
(
doc_auto_cfg
)
)
]
use
core
:
:
alloc
:
:
Layout
;
use
core
:
:
alloc
:
:
LayoutError
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
:
:
MaybeUninit
;
use
core
:
:
ptr
:
:
NonNull
;
pub
unsafe
trait
Slab
{
fn
base_ptr
(
&
self
)
-
>
*
const
u8
;
fn
base_ptr_mut
(
&
mut
self
)
-
>
*
mut
u8
;
fn
size
(
&
self
)
-
>
usize
;
fn
as_maybe_uninit_bytes
(
&
self
)
-
>
&
[
MaybeUninit
<
u8
>
]
{
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
self
.
base_ptr
(
)
.
cast
(
)
self
.
size
(
)
)
}
}
fn
as_maybe_uninit_bytes_mut
(
&
mut
self
)
-
>
&
mut
[
MaybeUninit
<
u8
>
]
{
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
self
.
base_ptr_mut
(
)
.
cast
(
)
self
.
size
(
)
)
}
}
unsafe
fn
assume_initialized_as_bytes
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
self
.
base_ptr
(
)
.
cast
(
)
self
.
size
(
)
)
}
}
unsafe
fn
assume_initialized_as_bytes_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
self
.
base_ptr_mut
(
)
.
cast
(
)
self
.
size
(
)
)
}
}
unsafe
fn
assume_range_initialized_as_bytes
<
R
>
(
&
self
range
:
R
)
-
>
&
[
u8
]
where
R
:
core
:
:
slice
:
:
SliceIndex
<
[
MaybeUninit
<
u8
>
]
Output
=
[
MaybeUninit
<
u8
>
]
>
{
let
maybe_uninit_slice
=
&
self
.
as_maybe_uninit_bytes
(
)
[
range
]
;
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
maybe_uninit_slice
.
as_ptr
(
)
.
cast
(
)
maybe_uninit_slice
.
len
(
)
)
}
}
unsafe
fn
assume_range_initialized_as_bytes_mut
<
R
>
(
&
mut
self
range
:
R
)
-
>
&
mut
[
u8
]
where
R
:
core
:
:
slice
:
:
SliceIndex
<
[
MaybeUninit
<
u8
>
]
Output
=
[
MaybeUninit
<
u8
>
]
>
{
let
maybe_uninit_slice
=
&
mut
self
.
as_maybe_uninit_bytes_mut
(
)
[
range
]
;
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
maybe_uninit_slice
.
as_mut_ptr
(
)
.
cast
(
)
maybe_uninit_slice
.
len
(
)
)
}
}
}
unsafe
impl
Slab
for
[
MaybeUninit
<
u8
>
]
{
fn
base_ptr
(
&
self
)
-
>
*
const
u8
{
self
.
as_ptr
(
)
.
cast
(
)
}
fn
base_ptr_mut
(
&
mut
self
)
-
>
*
mut
u8
{
self
.
as_mut_ptr
(
)
.
cast
(
)
}
fn
size
(
&
self
)
-
>
usize
{
core
:
:
mem
:
:
size_of_val
(
self
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
unsafe
fn
maybe_uninit_slice_from_vec
<
T
>
(
vec
:
&
mut
Vec
<
T
>
length
:
usize
)
-
>
&
mut
[
MaybeUninit
<
T
>
]
{
unsafe
{
#
[
allow
(
clippy
:
:
uninit_vec
)
]
vec
.
set_len
(
length
)
;
}
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
vec
.
as_mut_ptr
(
)
.
cast
:
:
<
MaybeUninit
<
T
>
>
(
)
length
)
}
}
pub
fn
copy_into_maybe_uninit_slice
<
'
a
T
>
(
src
:
&
[
T
]
dst
:
&
'
a
mut
[
MaybeUninit
<
T
>
]
)
-
>
&
'
a
mut
[
T
]
where
T
:
Copy
{
let
uninit_src
:
&
[
MaybeUninit
<
T
>
]
=
unsafe
{
&
*
(
src
as
*
const
[
T
]
as
*
const
[
MaybeUninit
<
T
>
]
)
}
;
dst
.
copy_from_slice
(
uninit_src
)
;
unsafe
{
&
mut
*
(
dst
as
*
mut
[
MaybeUninit
<
T
>
]
as
*
mut
[
T
]
)
}
}
pub
fn
clone_into_maybe_uninit_slice
<
'
a
T
>
(
src
:
&
[
T
]
dst
:
&
'
a
mut
[
MaybeUninit
<
T
>
]
)
-
>
&
'
a
mut
[
T
]
where
T
:
Clone
{
struct
Guard
<
'
a
T
>
{
slice
:
&
'
a
mut
[
MaybeUninit
<
T
>
]
initialized
:
usize
}
impl
<
'
a
T
>
Drop
for
Guard
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
let
initialized_part
=
&
mut
self
.
slice
[
.
.
self
.
initialized
]
;
unsafe
{
core
:
:
ptr
:
:
drop_in_place
(
&
mut
*
(
initialized_part
as
*
mut
[
MaybeUninit
<
T
>
]
as
*
mut
[
T
]
)
)
;
}
}
}
assert_eq
!
(
dst
.
len
(
)
src
.
len
(
)
"
destination
and
source
slices
have
different
lengths
"
)
;
let
len
=
dst
.
len
(
)
;
let
src
=
&
src
[
.
.
len
]
;
let
mut
guard
=
Guard
{
slice
:
dst
initialized
:
0
}
;
#
[
allow
(
clippy
:
:
needless_range_loop
)
]
for
i
in
0
.
.
len
{
guard
.
slice
[
i
]
.
write
(
src
[
i
]
.
clone
(
)
)
;
guard
.
initialized
+
=
1
;
}
#
[
allow
(
clippy
:
:
mem_forget
)
]
core
:
:
mem
:
:
forget
(
guard
)
;
unsafe
{
&
mut
*
(
dst
as
*
mut
[
MaybeUninit
<
T
>
]
as
*
mut
[
T
]
)
}
}
pub
struct
RawAllocation
{
pub
base_ptr
:
NonNull
<
u8
>
pub
size
:
usize
}
impl
RawAllocation
{
pub
fn
from_raw_parts
(
base_ptr
:
NonNull
<
u8
>
size
:
usize
)
-
>
Self
{
Self
{
base_ptr
size
}
}
#
[
allow
(
clippy
:
:
needless_lifetimes
)
]
pub
unsafe
fn
borrow_as_slab
<
'
a
>
(
&
'
a
mut
self
)
-
>
BorrowedRawAllocation
<
'
a
>
{
BorrowedRawAllocation
{
base_ptr
:
self
.
base_ptr
size
:
self
.
size
phantom
:
PhantomData
}
}
}
pub
struct
BorrowedRawAllocation
<
'
a
>
{
base_ptr
:
NonNull
<
u8
>
size
:
usize
phantom
:
PhantomData
<
&
'
a
(
)
>
}
unsafe
impl
<
'
a
>
Slab
for
BorrowedRawAllocation
<
'
a
>
{
fn
base_ptr
(
&
self
)
-
>
*
const
u8
{
self
.
base_ptr
.
as_ptr
(
)
as
*
const
u8
}
fn
base_ptr_mut
(
&
mut
self
)
-
>
*
mut
u8
{
self
.
base_ptr
.
as_ptr
(
)
}
fn
size
(
&
self
)
-
>
usize
{
self
.
size
}
}
fn
align_offset_up_to
(
ptr
:
usize
offset
:
usize
align
:
usize
)
-
>
Option
<
usize
>
{
let
offsetted_ptr
=
ptr
.
checked_add
(
offset
)
?
;
let
aligned_ptr
=
offsetted_ptr
.
checked_add
(
align
-
1
)
?
&
!
(
align
-
1
)
;
Some
(
aligned_ptr
-
ptr
)
}
fn
compute_offsets
<
S
:
Slab
>
(
dst
:
&
S
start_offset
:
usize
t_layout
:
Layout
min_alignment
:
usize
)
-
>
Result
<
CopyRecord
CopyError
>
{
let
copy_layout
=
t_layout
.
align_to
(
min_alignment
.
next_power_of_two
(
)
)
?
;
let
copy_start_offset
=
align_offset_up_to
(
dst
.
base_ptr
(
)
as
usize
start_offset
copy_layout
.
align
(
)
)
.
ok_or
(
CopyError
:
:
InvalidLayout
)
?
;
let
copy_end_offset
=
copy_start_offset
.
checked_add
(
copy_layout
.
size
(
)
)
.
ok_or
(
CopyError
:
:
InvalidLayout
)
?
;
let
copy_end_offset_padded
=
copy_start_offset
.
checked_add
(
copy_layout
.
pad_to_align
(
)
.
size
(
)
)
.
ok_or
(
CopyError
:
:
InvalidLayout
)
?
;
if
copy_start_offset
>
dst
.
size
(
)
{
return
Err
(
CopyError
:
:
OffsetOutOfBounds
)
;
}
if
copy_end_offset_padded
>
dst
.
size
(
)
{
return
Err
(
CopyError
:
:
OutOfMemory
)
;
}
Ok
(
CopyRecord
{
copy_start_offset
copy_end_offset
copy_end_offset_padded
}
)
}
#
[
derive
(
Debug
)
]
pub
enum
CopyError
{
OutOfMemory
OffsetOutOfBounds
InvalidLayout
}
impl
core
:
:
fmt
:
:
Display
for
CopyError
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
match
self
{
Self
:
:
OutOfMemory
=
>
"
Copy
would
exceed
the
end
of
the
allocation
"
Self
:
:
OffsetOutOfBounds
=
>
"
Requested
copy
to
a
location
starting
outside
the
allocation
"
Self
:
:
InvalidLayout
=
>
"
Invalid
layout
probably
caused
by
incredibly
large
size
offset
or
alignment
parameters
"
}
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
CopyError
{
}
impl
From
<
LayoutError
>
for
CopyError
{
fn
from
(
_err
:
LayoutError
)
-
>
Self
{
Self
:
:
InvalidLayout
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
CopyRecord
{
pub
copy_start_offset
:
usize
pub
copy_end_offset
:
usize
pub
copy_end_offset_padded
:
usize
}
#
[
inline
]
pub
fn
copy_to_offset
<
T
:
Copy
S
:
Slab
>
(
src
:
&
T
dst
:
&
mut
S
start_offset
:
usize
)
-
>
Result
<
CopyRecord
CopyError
>
{
copy_to_offset_with_align
(
src
dst
start_offset
1
)
}
pub
fn
copy_to_offset_with_align
<
T
:
Copy
S
:
Slab
>
(
src
:
&
T
dst
:
&
mut
S
start_offset
:
usize
min_alignment
:
usize
)
-
>
Result
<
CopyRecord
CopyError
>
{
let
t_layout
=
Layout
:
:
new
:
:
<
T
>
(
)
;
let
record
=
compute_offsets
(
&
*
dst
start_offset
t_layout
min_alignment
)
?
;
let
dst_ptr
=
unsafe
{
dst
.
base_ptr_mut
(
)
.
add
(
record
.
copy_start_offset
)
}
.
cast
:
:
<
T
>
(
)
;
unsafe
{
core
:
:
ptr
:
:
copy_nonoverlapping
(
src
as
*
const
T
dst_ptr
1
)
;
}
Ok
(
record
)
}
#
[
inline
]
pub
fn
copy_from_slice_to_offset
<
T
:
Copy
S
:
Slab
>
(
src
:
&
[
T
]
dst
:
&
mut
S
start_offset
:
usize
)
-
>
Result
<
CopyRecord
CopyError
>
{
copy_from_slice_to_offset_with_align
(
src
dst
start_offset
1
)
}
pub
fn
copy_from_slice_to_offset_with_align
<
T
:
Copy
S
:
Slab
>
(
src
:
&
[
T
]
dst
:
&
mut
S
start_offset
:
usize
min_alignment
:
usize
)
-
>
Result
<
CopyRecord
CopyError
>
{
let
t_layout
=
Layout
:
:
for_value
(
src
)
;
let
record
=
compute_offsets
(
&
*
dst
start_offset
t_layout
min_alignment
)
?
;
let
dst_ptr
=
unsafe
{
dst
.
base_ptr_mut
(
)
.
add
(
record
.
copy_start_offset
)
}
.
cast
:
:
<
T
>
(
)
;
unsafe
{
core
:
:
ptr
:
:
copy_nonoverlapping
(
src
.
as_ptr
(
)
dst_ptr
src
.
len
(
)
)
;
}
Ok
(
record
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
copy_from_iter_to_offset_with_align
<
T
:
Copy
Iter
:
Iterator
<
Item
=
T
>
S
:
Slab
>
(
src
:
Iter
dst
:
&
mut
S
start_offset
:
usize
min_alignment
:
usize
)
-
>
Result
<
Vec
<
CopyRecord
>
CopyError
>
{
let
mut
offset
=
start_offset
;
src
.
map
(
|
item
|
{
let
copy_record
=
copy_to_offset_with_align
(
&
item
dst
offset
min_alignment
)
?
;
offset
=
copy_record
.
copy_end_offset
;
Ok
(
copy_record
)
}
)
.
collect
:
:
<
Result
<
Vec
<
_
>
_
>
>
(
)
}
pub
fn
copy_from_iter_to_offset_with_align_packed
<
T
:
Copy
Iter
:
Iterator
<
Item
=
T
>
S
:
Slab
>
(
mut
src
:
Iter
dst
:
&
mut
S
start_offset
:
usize
min_alignment
:
usize
)
-
>
Result
<
Option
<
CopyRecord
>
CopyError
>
{
let
first_record
=
if
let
Some
(
first_item
)
=
src
.
next
(
)
{
copy_to_offset_with_align
(
&
first_item
dst
start_offset
min_alignment
)
?
}
else
{
return
Ok
(
None
)
;
}
;
let
mut
prev_record
=
first_record
;
for
item
in
src
{
let
copy_record
=
copy_to_offset_with_align
(
&
item
dst
prev_record
.
copy_end_offset
1
)
?
;
prev_record
=
copy_record
;
}
Ok
(
Some
(
CopyRecord
{
copy_start_offset
:
first_record
.
copy_start_offset
copy_end_offset
:
prev_record
.
copy_end_offset
copy_end_offset_padded
:
prev_record
.
copy_end_offset_padded
}
)
)
}
