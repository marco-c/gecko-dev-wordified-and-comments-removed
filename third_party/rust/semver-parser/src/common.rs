use
version
:
:
Identifier
;
use
recognize
:
:
{
Recognize
Alt
OneOrMore
Inclusive
OneByte
}
;
use
std
:
:
str
:
:
from_utf8
;
fn
parse_meta
(
s
:
&
str
)
-
>
Vec
<
Identifier
>
{
s
.
split
(
"
.
"
)
.
map
(
|
part
|
{
if
is_alpha_numeric
(
part
)
{
Identifier
:
:
AlphaNumeric
(
part
.
to_string
(
)
)
}
else
{
Identifier
:
:
Numeric
(
part
.
parse
(
)
.
unwrap
(
)
)
}
}
)
.
collect
(
)
}
pub
fn
parse_optional_meta
(
s
:
&
[
u8
]
prefix_char
:
u8
)
-
>
Result
<
(
Vec
<
Identifier
>
usize
)
String
>
{
if
let
Some
(
len
)
=
prefix_char
.
p
(
s
)
{
let
start
=
len
;
if
let
Some
(
len
)
=
letters_numbers_dash_dot
(
&
s
[
start
.
.
]
)
{
let
end
=
start
+
len
;
Ok
(
(
parse_meta
(
from_utf8
(
&
s
[
start
.
.
end
]
)
.
unwrap
(
)
)
end
)
)
}
else
{
Err
(
"
Error
parsing
prerelease
"
.
to_string
(
)
)
}
}
else
{
Ok
(
(
Vec
:
:
new
(
)
0
)
)
}
}
pub
fn
is_alpha_numeric
(
s
:
&
str
)
-
>
bool
{
if
let
Some
(
(
_val
len
)
)
=
numeric_identifier
(
s
.
as_bytes
(
)
)
{
len
!
=
s
.
len
(
)
}
else
{
true
}
}
pub
fn
numeric_identifier
(
s
:
&
[
u8
]
)
-
>
Option
<
(
u64
usize
)
>
{
if
let
Some
(
len
)
=
Alt
(
b
'
0
'
OneOrMore
(
Inclusive
(
b
'
0
'
.
.
b
'
9
'
)
)
)
.
p
(
s
)
{
from_utf8
(
&
s
[
0
.
.
len
]
)
.
unwrap
(
)
.
parse
(
)
.
ok
(
)
.
map
(
|
val
|
(
val
len
)
)
}
else
{
None
}
}
pub
fn
letters_numbers_dash_dot
(
s
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
OneOrMore
(
OneByte
(
|
c
|
c
=
=
b
'
-
'
|
|
c
=
=
b
'
.
'
|
|
(
b
'
0
'
<
=
c
&
&
c
<
=
b
'
9
'
)
|
|
(
b
'
a
'
<
=
c
&
&
c
<
=
b
'
z
'
)
|
|
(
b
'
A
'
<
=
c
&
&
c
<
=
b
'
Z
'
)
)
)
.
p
(
s
)
}
