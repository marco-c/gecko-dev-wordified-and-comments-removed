#
[
macro_export
]
macro_rules
!
define_proc_macros
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
fn
proc_macro_name
:
ident
(
input
:
ident
:
&
str
)
-
>
String
body
:
block
)
+
)
=
>
{
(
(
#
[
attr
]
)
*
#
[
proc_macro_derive
(
proc_macro_name
)
]
pub
fn
proc_macro_name
(
derive_input
:
:
:
proc_macro
:
:
TokenStream
)
-
>
:
:
proc_macro
:
:
TokenStream
{
let
input
=
derive_input
.
to_string
(
)
;
let
input
=
crate
:
:
_extract_input
(
&
input
)
;
body
.
parse
(
)
.
unwrap
(
)
}
)
+
}
}
#
[
doc
(
hidden
)
]
pub
fn
_extract_input
(
derive_input
:
&
str
)
-
>
&
str
{
let
mut
input
=
derive_input
;
for
expected
in
&
[
"
#
[
allow
(
unused
)
]
"
"
enum
"
"
ProceduralMasqueradeDummyType
"
"
{
"
"
Input
"
"
=
"
"
(
0
"
"
stringify
!
"
"
(
"
]
{
input
=
input
.
trim_left
(
)
;
assert
!
(
input
.
starts_with
(
expected
)
"
expected
prefix
{
:
?
}
not
found
in
{
:
?
}
"
expected
derive_input
)
;
input
=
&
input
[
expected
.
len
(
)
.
.
]
;
}
for
expected
in
[
"
)
"
"
)
.
0
"
"
}
"
]
.
iter
(
)
.
rev
(
)
{
input
=
input
.
trim_right
(
)
;
assert
!
(
input
.
ends_with
(
expected
)
"
expected
suffix
{
:
?
}
not
found
in
{
:
?
}
"
expected
derive_input
)
;
let
end
=
input
.
len
(
)
-
expected
.
len
(
)
;
input
=
&
input
[
.
.
end
]
;
}
input
}
#
[
macro_export
]
macro_rules
!
define_invoke_proc_macro
{
(
macro_name
:
ident
)
=
>
{
/
/
/
Implementation
detail
of
other
macros
in
this
crate
.
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
macro_name
{
(
proc_macro_name
:
ident
!
paren
:
tt
)
=
>
{
#
[
derive
(
proc_macro_name
)
]
#
[
allow
(
unused
)
]
enum
ProceduralMasqueradeDummyType
{
/
/
The
magic
happens
here
.
/
/
/
/
We
use
an
enum
with
an
explicit
discriminant
/
/
because
that
is
the
only
case
where
a
type
definition
/
/
can
contain
a
(
const
)
expression
.
/
/
/
/
(
0
"
foo
"
)
.
0
evalutes
to
0
with
the
"
foo
"
part
ignored
.
/
/
/
/
By
the
time
the
#
[
proc_macro_derive
]
function
/
/
implementing
#
[
derive
(
proc_macro_name
)
]
is
called
/
/
paren
has
already
been
replaced
with
the
input
of
this
inner
macro
/
/
but
stringify
!
has
not
been
expanded
yet
.
/
/
/
/
This
how
arbitrary
tokens
can
be
inserted
/
/
in
the
input
to
the
#
[
proc_macro_derive
]
function
.
/
/
/
/
Later
stringify
!
(
.
.
.
)
is
expanded
into
a
string
literal
/
/
which
is
then
ignored
.
/
/
Using
stringify
!
enables
passing
arbitrary
tokens
/
/
rather
than
only
what
can
be
parsed
as
a
const
expression
.
Input
=
(
0
stringify
!
paren
)
.
0
}
}
}
}
}
