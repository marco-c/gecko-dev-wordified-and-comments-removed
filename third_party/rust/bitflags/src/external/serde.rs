use
crate
:
:
{
parser
:
:
{
self
ParseHex
WriteHex
}
Flags
}
;
use
core
:
:
{
fmt
str
}
;
use
serde
:
:
{
de
:
:
{
Error
Visitor
}
Deserialize
Deserializer
Serialize
Serializer
}
;
pub
fn
serialize
<
B
:
Flags
S
:
Serializer
>
(
flags
:
&
B
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
B
:
:
Bits
:
WriteHex
+
Serialize
{
if
serializer
.
is_human_readable
(
)
{
serializer
.
collect_str
(
&
parser
:
:
AsDisplay
(
flags
)
)
}
else
{
flags
.
bits
(
)
.
serialize
(
serializer
)
}
}
pub
fn
deserialize
<
'
de
B
:
Flags
D
:
Deserializer
<
'
de
>
>
(
deserializer
:
D
)
-
>
Result
<
B
D
:
:
Error
>
where
B
:
:
Bits
:
ParseHex
+
Deserialize
<
'
de
>
{
if
deserializer
.
is_human_readable
(
)
{
struct
FlagsVisitor
<
B
>
(
core
:
:
marker
:
:
PhantomData
<
B
>
)
;
impl
<
'
de
B
:
Flags
>
Visitor
<
'
de
>
for
FlagsVisitor
<
B
>
where
B
:
:
Bits
:
ParseHex
{
type
Value
=
B
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
string
value
of
|
separated
flags
"
)
}
fn
visit_str
<
E
:
Error
>
(
self
flags
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
{
parser
:
:
from_str
(
flags
)
.
map_err
(
|
e
|
E
:
:
custom
(
e
)
)
}
}
deserializer
.
deserialize_str
(
FlagsVisitor
(
Default
:
:
default
(
)
)
)
}
else
{
let
bits
=
B
:
:
Bits
:
:
deserialize
(
deserializer
)
?
;
Ok
(
B
:
:
from_bits_retain
(
bits
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
serde_test
:
:
{
assert_tokens
Configure
Token
:
:
*
}
;
bitflags
!
{
#
[
derive
(
serde_derive
:
:
Serialize
serde_derive
:
:
Deserialize
Debug
PartialEq
Eq
)
]
#
[
serde
(
transparent
)
]
struct
SerdeFlags
:
u32
{
const
A
=
1
;
const
B
=
2
;
const
C
=
4
;
const
D
=
8
;
}
}
#
[
test
]
fn
test_serde_bitflags_default
(
)
{
assert_tokens
(
&
SerdeFlags
:
:
empty
(
)
.
readable
(
)
&
[
Str
(
"
"
)
]
)
;
assert_tokens
(
&
SerdeFlags
:
:
empty
(
)
.
compact
(
)
&
[
U32
(
0
)
]
)
;
assert_tokens
(
&
(
SerdeFlags
:
:
A
|
SerdeFlags
:
:
B
)
.
readable
(
)
&
[
Str
(
"
A
|
B
"
)
]
)
;
assert_tokens
(
&
(
SerdeFlags
:
:
A
|
SerdeFlags
:
:
B
)
.
compact
(
)
&
[
U32
(
1
|
2
)
]
)
;
}
}
