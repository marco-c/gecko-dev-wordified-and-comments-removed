use
crate
:
:
{
Flag
Flags
}
;
pub
struct
Iter
<
B
:
'
static
>
{
inner
:
IterNames
<
B
>
done
:
bool
}
impl
<
B
:
Flags
>
Iter
<
B
>
{
pub
(
crate
)
fn
new
(
flags
:
&
B
)
-
>
Self
{
Iter
{
inner
:
IterNames
:
:
new
(
flags
)
done
:
false
}
}
}
impl
<
B
:
'
static
>
Iter
<
B
>
{
#
[
doc
(
hidden
)
]
pub
const
fn
__private_const_new
(
flags
:
&
'
static
[
Flag
<
B
>
]
source
:
B
remaining
:
B
)
-
>
Self
{
Iter
{
inner
:
IterNames
:
:
__private_const_new
(
flags
source
remaining
)
done
:
false
}
}
}
impl
<
B
:
Flags
>
Iterator
for
Iter
<
B
>
{
type
Item
=
B
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
match
self
.
inner
.
next
(
)
{
Some
(
(
_
flag
)
)
=
>
Some
(
flag
)
None
if
!
self
.
done
=
>
{
self
.
done
=
true
;
if
!
self
.
inner
.
remaining
(
)
.
is_empty
(
)
{
Some
(
B
:
:
from_bits_retain
(
self
.
inner
.
remaining
.
bits
(
)
)
)
}
else
{
None
}
}
None
=
>
None
}
}
}
pub
struct
IterNames
<
B
:
'
static
>
{
flags
:
&
'
static
[
Flag
<
B
>
]
idx
:
usize
source
:
B
remaining
:
B
}
impl
<
B
:
Flags
>
IterNames
<
B
>
{
pub
(
crate
)
fn
new
(
flags
:
&
B
)
-
>
Self
{
IterNames
{
flags
:
B
:
:
FLAGS
idx
:
0
remaining
:
B
:
:
from_bits_retain
(
flags
.
bits
(
)
)
source
:
B
:
:
from_bits_retain
(
flags
.
bits
(
)
)
}
}
}
impl
<
B
:
'
static
>
IterNames
<
B
>
{
#
[
doc
(
hidden
)
]
pub
const
fn
__private_const_new
(
flags
:
&
'
static
[
Flag
<
B
>
]
source
:
B
remaining
:
B
)
-
>
Self
{
IterNames
{
flags
idx
:
0
remaining
source
}
}
pub
fn
remaining
(
&
self
)
-
>
&
B
{
&
self
.
remaining
}
}
impl
<
B
:
Flags
>
Iterator
for
IterNames
<
B
>
{
type
Item
=
(
&
'
static
str
B
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
while
let
Some
(
flag
)
=
self
.
flags
.
get
(
self
.
idx
)
{
if
self
.
remaining
.
is_empty
(
)
{
return
None
;
}
self
.
idx
+
=
1
;
if
flag
.
name
(
)
.
is_empty
(
)
{
continue
;
}
let
bits
=
flag
.
value
(
)
.
bits
(
)
;
if
self
.
source
.
contains
(
B
:
:
from_bits_retain
(
bits
)
)
&
&
self
.
remaining
.
intersects
(
B
:
:
from_bits_retain
(
bits
)
)
{
self
.
remaining
.
remove
(
B
:
:
from_bits_retain
(
bits
)
)
;
return
Some
(
(
flag
.
name
(
)
B
:
:
from_bits_retain
(
bits
)
)
)
;
}
}
None
}
}
