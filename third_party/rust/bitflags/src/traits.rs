use
core
:
:
{
fmt
ops
:
:
{
BitAnd
BitOr
BitXor
Not
}
}
;
use
crate
:
:
{
iter
parser
:
:
{
ParseError
ParseHex
WriteHex
}
}
;
#
[
derive
(
Debug
)
]
pub
struct
Flag
<
B
>
{
name
:
&
'
static
str
value
:
B
}
impl
<
B
>
Flag
<
B
>
{
pub
const
fn
new
(
name
:
&
'
static
str
value
:
B
)
-
>
Self
{
Flag
{
name
value
}
}
pub
const
fn
name
(
&
self
)
-
>
&
'
static
str
{
self
.
name
}
pub
const
fn
value
(
&
self
)
-
>
&
B
{
&
self
.
value
}
pub
const
fn
is_named
(
&
self
)
-
>
bool
{
!
self
.
name
.
is_empty
(
)
}
pub
const
fn
is_unnamed
(
&
self
)
-
>
bool
{
self
.
name
.
is_empty
(
)
}
}
pub
trait
Flags
:
Sized
+
'
static
{
const
FLAGS
:
&
'
static
[
Flag
<
Self
>
]
;
type
Bits
:
Bits
;
fn
empty
(
)
-
>
Self
{
Self
:
:
from_bits_retain
(
Self
:
:
Bits
:
:
EMPTY
)
}
fn
all
(
)
-
>
Self
{
let
mut
truncated
=
Self
:
:
Bits
:
:
EMPTY
;
for
flag
in
Self
:
:
FLAGS
.
iter
(
)
{
truncated
=
truncated
|
flag
.
value
(
)
.
bits
(
)
;
}
Self
:
:
from_bits_retain
(
truncated
)
}
fn
bits
(
&
self
)
-
>
Self
:
:
Bits
;
fn
from_bits
(
bits
:
Self
:
:
Bits
)
-
>
Option
<
Self
>
{
let
truncated
=
Self
:
:
from_bits_truncate
(
bits
)
;
if
truncated
.
bits
(
)
=
=
bits
{
Some
(
truncated
)
}
else
{
None
}
}
fn
from_bits_truncate
(
bits
:
Self
:
:
Bits
)
-
>
Self
{
Self
:
:
from_bits_retain
(
bits
&
Self
:
:
all
(
)
.
bits
(
)
)
}
fn
from_bits_retain
(
bits
:
Self
:
:
Bits
)
-
>
Self
;
fn
from_name
(
name
:
&
str
)
-
>
Option
<
Self
>
{
if
name
.
is_empty
(
)
{
return
None
;
}
for
flag
in
Self
:
:
FLAGS
{
if
flag
.
name
(
)
=
=
name
{
return
Some
(
Self
:
:
from_bits_retain
(
flag
.
value
(
)
.
bits
(
)
)
)
;
}
}
None
}
fn
iter
(
&
self
)
-
>
iter
:
:
Iter
<
Self
>
{
iter
:
:
Iter
:
:
new
(
self
)
}
fn
iter_names
(
&
self
)
-
>
iter
:
:
IterNames
<
Self
>
{
iter
:
:
IterNames
:
:
new
(
self
)
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
bits
(
)
=
=
Self
:
:
Bits
:
:
EMPTY
}
fn
is_all
(
&
self
)
-
>
bool
{
Self
:
:
all
(
)
.
bits
(
)
|
self
.
bits
(
)
=
=
self
.
bits
(
)
}
fn
intersects
(
&
self
other
:
Self
)
-
>
bool
where
Self
:
Sized
{
self
.
bits
(
)
&
other
.
bits
(
)
!
=
Self
:
:
Bits
:
:
EMPTY
}
fn
contains
(
&
self
other
:
Self
)
-
>
bool
where
Self
:
Sized
{
self
.
bits
(
)
&
other
.
bits
(
)
=
=
other
.
bits
(
)
}
fn
insert
(
&
mut
self
other
:
Self
)
where
Self
:
Sized
{
*
self
=
Self
:
:
from_bits_retain
(
self
.
bits
(
)
)
.
union
(
other
)
;
}
fn
remove
(
&
mut
self
other
:
Self
)
where
Self
:
Sized
{
*
self
=
Self
:
:
from_bits_retain
(
self
.
bits
(
)
)
.
difference
(
other
)
;
}
fn
toggle
(
&
mut
self
other
:
Self
)
where
Self
:
Sized
{
*
self
=
Self
:
:
from_bits_retain
(
self
.
bits
(
)
)
.
symmetric_difference
(
other
)
;
}
fn
set
(
&
mut
self
other
:
Self
value
:
bool
)
where
Self
:
Sized
{
if
value
{
self
.
insert
(
other
)
;
}
else
{
self
.
remove
(
other
)
;
}
}
#
[
must_use
]
fn
intersection
(
self
other
:
Self
)
-
>
Self
{
Self
:
:
from_bits_retain
(
self
.
bits
(
)
&
other
.
bits
(
)
)
}
#
[
must_use
]
fn
union
(
self
other
:
Self
)
-
>
Self
{
Self
:
:
from_bits_retain
(
self
.
bits
(
)
|
other
.
bits
(
)
)
}
#
[
must_use
]
fn
difference
(
self
other
:
Self
)
-
>
Self
{
Self
:
:
from_bits_retain
(
self
.
bits
(
)
&
!
other
.
bits
(
)
)
}
#
[
must_use
]
fn
symmetric_difference
(
self
other
:
Self
)
-
>
Self
{
Self
:
:
from_bits_retain
(
self
.
bits
(
)
^
other
.
bits
(
)
)
}
#
[
must_use
]
fn
complement
(
self
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
!
self
.
bits
(
)
)
}
}
pub
trait
Bits
:
Clone
+
Copy
+
PartialEq
+
BitAnd
<
Output
=
Self
>
+
BitOr
<
Output
=
Self
>
+
BitXor
<
Output
=
Self
>
+
Not
<
Output
=
Self
>
+
Sized
+
'
static
{
const
EMPTY
:
Self
;
const
ALL
:
Self
;
}
pub
trait
Primitive
{
}
macro_rules
!
impl_bits
{
(
(
u
:
ty
i
:
ty
)
*
)
=
>
{
(
impl
Bits
for
u
{
const
EMPTY
:
u
=
0
;
const
ALL
:
u
=
<
u
>
:
:
MAX
;
}
impl
Bits
for
i
{
const
EMPTY
:
i
=
0
;
const
ALL
:
i
=
<
u
>
:
:
MAX
as
i
;
}
impl
ParseHex
for
u
{
fn
parse_hex
(
input
:
&
str
)
-
>
Result
<
Self
ParseError
>
{
<
u
>
:
:
from_str_radix
(
input
16
)
.
map_err
(
|
_
|
ParseError
:
:
invalid_hex_flag
(
input
)
)
}
}
impl
ParseHex
for
i
{
fn
parse_hex
(
input
:
&
str
)
-
>
Result
<
Self
ParseError
>
{
<
i
>
:
:
from_str_radix
(
input
16
)
.
map_err
(
|
_
|
ParseError
:
:
invalid_hex_flag
(
input
)
)
}
}
impl
WriteHex
for
u
{
fn
write_hex
<
W
:
fmt
:
:
Write
>
(
&
self
mut
writer
:
W
)
-
>
fmt
:
:
Result
{
write
!
(
writer
"
{
:
x
}
"
self
)
}
}
impl
WriteHex
for
i
{
fn
write_hex
<
W
:
fmt
:
:
Write
>
(
&
self
mut
writer
:
W
)
-
>
fmt
:
:
Result
{
write
!
(
writer
"
{
:
x
}
"
self
)
}
}
impl
Primitive
for
i
{
}
impl
Primitive
for
u
{
}
)
*
}
}
impl_bits
!
{
u8
i8
u16
i16
u32
i32
u64
i64
u128
i128
usize
isize
}
pub
trait
PublicFlags
{
type
Primitive
:
Primitive
;
type
Internal
;
}
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
use
the
Flags
trait
instead
"
)
]
pub
trait
BitFlags
:
ImplementedByBitFlagsMacro
+
Flags
{
type
Iter
:
Iterator
<
Item
=
Self
>
;
type
IterNames
:
Iterator
<
Item
=
(
&
'
static
str
Self
)
>
;
}
#
[
allow
(
deprecated
)
]
impl
<
B
:
Flags
>
BitFlags
for
B
{
type
Iter
=
iter
:
:
Iter
<
Self
>
;
type
IterNames
=
iter
:
:
IterNames
<
Self
>
;
}
impl
<
B
:
Flags
>
ImplementedByBitFlagsMacro
for
B
{
}
#
[
doc
(
hidden
)
]
pub
trait
ImplementedByBitFlagsMacro
{
}
pub
(
crate
)
mod
__private
{
pub
use
super
:
:
{
ImplementedByBitFlagsMacro
PublicFlags
}
;
}
