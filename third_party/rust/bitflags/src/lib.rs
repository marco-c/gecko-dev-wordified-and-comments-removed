#
!
[
cfg_attr
(
not
(
any
(
feature
=
"
std
"
test
)
)
no_std
)
]
#
!
[
cfg_attr
(
not
(
test
)
forbid
(
unsafe_code
)
)
]
#
!
[
cfg_attr
(
test
allow
(
mixed_script_confusables
)
)
]
#
[
doc
(
inline
)
]
pub
use
traits
:
:
{
Bits
Flag
Flags
}
;
pub
mod
iter
;
pub
mod
parser
;
mod
traits
;
#
[
doc
(
hidden
)
]
pub
mod
__private
{
#
[
allow
(
unused_imports
)
]
pub
use
crate
:
:
{
external
:
:
__private
:
:
*
traits
:
:
__private
:
:
*
}
;
pub
use
core
;
}
#
[
allow
(
unused_imports
)
]
pub
use
external
:
:
*
;
#
[
allow
(
deprecated
)
]
pub
use
traits
:
:
BitFlags
;
#
[
macro_export
]
macro_rules
!
bitflags
{
(
(
#
[
outer
:
meta
]
)
*
vis
:
vis
struct
BitFlags
:
ident
:
T
:
ty
{
(
(
#
[
inner
:
ident
(
args
:
tt
)
*
]
)
*
const
Flag
:
tt
=
value
:
expr
;
)
*
}
(
t
:
tt
)
*
)
=
>
{
/
/
Declared
in
the
scope
of
the
bitflags
!
call
/
/
This
type
appears
in
the
end
-
user
'
s
API
crate
:
:
__declare_public_bitflags
!
{
(
#
[
outer
]
)
*
vis
struct
BitFlags
}
/
/
Workaround
for
:
https
:
/
/
github
.
com
/
bitflags
/
bitflags
/
issues
/
320
crate
:
:
__impl_public_bitflags_consts
!
{
BitFlags
:
T
{
(
(
#
[
inner
(
args
)
*
]
)
*
const
Flag
=
value
;
)
*
}
}
#
[
allow
(
dead_code
deprecated
unused_doc_comments
unused_attributes
unused_mut
unused_imports
non_upper_case_globals
clippy
:
:
assign_op_pattern
clippy
:
:
indexing_slicing
clippy
:
:
same_name_method
clippy
:
:
iter_without_into_iter
)
]
const
_
:
(
)
=
{
/
/
Declared
in
a
"
hidden
"
scope
that
can
'
t
be
reached
directly
/
/
These
types
don
'
t
appear
in
the
end
-
user
'
s
API
crate
:
:
__declare_internal_bitflags
!
{
vis
struct
InternalBitFlags
:
T
}
crate
:
:
__impl_internal_bitflags
!
{
InternalBitFlags
:
T
BitFlags
{
(
(
#
[
inner
(
args
)
*
]
)
*
const
Flag
=
value
;
)
*
}
}
/
/
This
is
where
new
library
trait
implementations
can
be
added
crate
:
:
__impl_external_bitflags
!
{
InternalBitFlags
:
T
BitFlags
{
(
(
#
[
inner
(
args
)
*
]
)
*
const
Flag
;
)
*
}
}
crate
:
:
__impl_public_bitflags_forward
!
{
BitFlags
:
T
InternalBitFlags
}
crate
:
:
__impl_public_bitflags_ops
!
{
BitFlags
}
crate
:
:
__impl_public_bitflags_iter
!
{
BitFlags
:
T
BitFlags
}
}
;
crate
:
:
bitflags
!
{
(
t
)
*
}
}
;
(
(
#
[
outer
:
meta
]
)
*
impl
BitFlags
:
ident
:
T
:
ty
{
(
(
#
[
inner
:
ident
(
args
:
tt
)
*
]
)
*
const
Flag
:
tt
=
value
:
expr
;
)
*
}
(
t
:
tt
)
*
)
=
>
{
crate
:
:
__impl_public_bitflags_consts
!
{
BitFlags
:
T
{
(
(
#
[
inner
(
args
)
*
]
)
*
const
Flag
=
value
;
)
*
}
}
#
[
allow
(
dead_code
deprecated
unused_doc_comments
unused_attributes
unused_mut
unused_imports
non_upper_case_globals
clippy
:
:
assign_op_pattern
clippy
:
:
iter_without_into_iter
)
]
const
_
:
(
)
=
{
crate
:
:
__impl_public_bitflags
!
{
(
#
[
outer
]
)
*
BitFlags
:
T
BitFlags
{
(
(
#
[
inner
(
args
)
*
]
)
*
const
Flag
=
value
;
)
*
}
}
crate
:
:
__impl_public_bitflags_ops
!
{
BitFlags
}
crate
:
:
__impl_public_bitflags_iter
!
{
BitFlags
:
T
BitFlags
}
}
;
crate
:
:
bitflags
!
{
(
t
)
*
}
}
;
(
)
=
>
{
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__impl_bitflags
{
(
(
#
[
outer
:
meta
]
)
*
PublicBitFlags
:
ident
:
T
:
ty
{
fn
empty
(
)
empty
:
block
fn
all
(
)
all
:
block
fn
bits
(
bits0
:
ident
)
bits
:
block
fn
from_bits
(
from_bits0
:
ident
)
from_bits
:
block
fn
from_bits_truncate
(
from_bits_truncate0
:
ident
)
from_bits_truncate
:
block
fn
from_bits_retain
(
from_bits_retain0
:
ident
)
from_bits_retain
:
block
fn
from_name
(
from_name0
:
ident
)
from_name
:
block
fn
is_empty
(
is_empty0
:
ident
)
is_empty
:
block
fn
is_all
(
is_all0
:
ident
)
is_all
:
block
fn
intersects
(
intersects0
:
ident
intersects1
:
ident
)
intersects
:
block
fn
contains
(
contains0
:
ident
contains1
:
ident
)
contains
:
block
fn
insert
(
insert0
:
ident
insert1
:
ident
)
insert
:
block
fn
remove
(
remove0
:
ident
remove1
:
ident
)
remove
:
block
fn
toggle
(
toggle0
:
ident
toggle1
:
ident
)
toggle
:
block
fn
set
(
set0
:
ident
set1
:
ident
set2
:
ident
)
set
:
block
fn
intersection
(
intersection0
:
ident
intersection1
:
ident
)
intersection
:
block
fn
union
(
union0
:
ident
union1
:
ident
)
union
:
block
fn
difference
(
difference0
:
ident
difference1
:
ident
)
difference
:
block
fn
symmetric_difference
(
symmetric_difference0
:
ident
symmetric_difference1
:
ident
)
symmetric_difference
:
block
fn
complement
(
complement0
:
ident
)
complement
:
block
}
)
=
>
{
#
[
allow
(
dead_code
deprecated
unused_attributes
)
]
(
#
[
outer
]
)
*
impl
PublicBitFlags
{
/
/
/
Get
a
flags
value
with
all
bits
unset
.
#
[
inline
]
pub
const
fn
empty
(
)
-
>
Self
{
empty
}
/
/
/
Get
a
flags
value
with
all
known
bits
set
.
#
[
inline
]
pub
const
fn
all
(
)
-
>
Self
{
all
}
/
/
/
Get
the
underlying
bits
value
.
/
/
/
/
/
/
The
returned
value
is
exactly
the
bits
set
in
this
flags
value
.
#
[
inline
]
pub
const
fn
bits
(
&
self
)
-
>
T
{
let
bits0
=
self
;
bits
}
/
/
/
Convert
from
a
bits
value
.
/
/
/
/
/
/
This
method
will
return
None
if
any
unknown
bits
are
set
.
#
[
inline
]
pub
const
fn
from_bits
(
bits
:
T
)
-
>
crate
:
:
__private
:
:
core
:
:
option
:
:
Option
<
Self
>
{
let
from_bits0
=
bits
;
from_bits
}
/
/
/
Convert
from
a
bits
value
unsetting
any
unknown
bits
.
#
[
inline
]
pub
const
fn
from_bits_truncate
(
bits
:
T
)
-
>
Self
{
let
from_bits_truncate0
=
bits
;
from_bits_truncate
}
/
/
/
Convert
from
a
bits
value
exactly
.
#
[
inline
]
pub
const
fn
from_bits_retain
(
bits
:
T
)
-
>
Self
{
let
from_bits_retain0
=
bits
;
from_bits_retain
}
/
/
/
Get
a
flags
value
with
the
bits
of
a
flag
with
the
given
name
set
.
/
/
/
/
/
/
This
method
will
return
None
if
name
is
empty
or
doesn
'
t
/
/
/
correspond
to
any
named
flag
.
#
[
inline
]
pub
fn
from_name
(
name
:
&
str
)
-
>
crate
:
:
__private
:
:
core
:
:
option
:
:
Option
<
Self
>
{
let
from_name0
=
name
;
from_name
}
/
/
/
Whether
all
bits
in
this
flags
value
are
unset
.
#
[
inline
]
pub
const
fn
is_empty
(
&
self
)
-
>
bool
{
let
is_empty0
=
self
;
is_empty
}
/
/
/
Whether
all
known
bits
in
this
flags
value
are
set
.
#
[
inline
]
pub
const
fn
is_all
(
&
self
)
-
>
bool
{
let
is_all0
=
self
;
is_all
}
/
/
/
Whether
any
set
bits
in
a
source
flags
value
are
also
set
in
a
target
flags
value
.
#
[
inline
]
pub
const
fn
intersects
(
&
self
other
:
Self
)
-
>
bool
{
let
intersects0
=
self
;
let
intersects1
=
other
;
intersects
}
/
/
/
Whether
all
set
bits
in
a
source
flags
value
are
also
set
in
a
target
flags
value
.
#
[
inline
]
pub
const
fn
contains
(
&
self
other
:
Self
)
-
>
bool
{
let
contains0
=
self
;
let
contains1
=
other
;
contains
}
/
/
/
The
bitwise
or
(
|
)
of
the
bits
in
two
flags
values
.
#
[
inline
]
pub
fn
insert
(
&
mut
self
other
:
Self
)
{
let
insert0
=
self
;
let
insert1
=
other
;
insert
}
/
/
/
The
intersection
of
a
source
flags
value
with
the
complement
of
a
target
flags
value
(
&
!
)
.
/
/
/
/
/
/
This
method
is
not
equivalent
to
self
&
!
other
when
other
has
unknown
bits
set
.
/
/
/
remove
won
'
t
truncate
other
but
the
!
operator
will
.
#
[
inline
]
pub
fn
remove
(
&
mut
self
other
:
Self
)
{
let
remove0
=
self
;
let
remove1
=
other
;
remove
}
/
/
/
The
bitwise
exclusive
-
or
(
^
)
of
the
bits
in
two
flags
values
.
#
[
inline
]
pub
fn
toggle
(
&
mut
self
other
:
Self
)
{
let
toggle0
=
self
;
let
toggle1
=
other
;
toggle
}
/
/
/
Call
insert
when
value
is
true
or
remove
when
value
is
false
.
#
[
inline
]
pub
fn
set
(
&
mut
self
other
:
Self
value
:
bool
)
{
let
set0
=
self
;
let
set1
=
other
;
let
set2
=
value
;
set
}
/
/
/
The
bitwise
and
(
&
)
of
the
bits
in
two
flags
values
.
#
[
inline
]
#
[
must_use
]
pub
const
fn
intersection
(
self
other
:
Self
)
-
>
Self
{
let
intersection0
=
self
;
let
intersection1
=
other
;
intersection
}
/
/
/
The
bitwise
or
(
|
)
of
the
bits
in
two
flags
values
.
#
[
inline
]
#
[
must_use
]
pub
const
fn
union
(
self
other
:
Self
)
-
>
Self
{
let
union0
=
self
;
let
union1
=
other
;
union
}
/
/
/
The
intersection
of
a
source
flags
value
with
the
complement
of
a
target
flags
value
(
&
!
)
.
/
/
/
/
/
/
This
method
is
not
equivalent
to
self
&
!
other
when
other
has
unknown
bits
set
.
/
/
/
difference
won
'
t
truncate
other
but
the
!
operator
will
.
#
[
inline
]
#
[
must_use
]
pub
const
fn
difference
(
self
other
:
Self
)
-
>
Self
{
let
difference0
=
self
;
let
difference1
=
other
;
difference
}
/
/
/
The
bitwise
exclusive
-
or
(
^
)
of
the
bits
in
two
flags
values
.
#
[
inline
]
#
[
must_use
]
pub
const
fn
symmetric_difference
(
self
other
:
Self
)
-
>
Self
{
let
symmetric_difference0
=
self
;
let
symmetric_difference1
=
other
;
symmetric_difference
}
/
/
/
The
bitwise
negation
(
!
)
of
the
bits
in
a
flags
value
truncating
the
result
.
#
[
inline
]
#
[
must_use
]
pub
const
fn
complement
(
self
)
-
>
Self
{
let
complement0
=
self
;
complement
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
bitflags_match
{
(
operation
:
expr
{
(
t
:
tt
)
*
}
)
=
>
{
/
/
Expand
to
a
closure
so
we
can
use
return
/
/
This
makes
it
possible
to
apply
attributes
to
the
"
match
arms
"
(
|
|
{
crate
:
:
__bitflags_match
!
(
operation
{
(
t
)
*
}
)
}
)
(
)
}
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__bitflags_match
{
(
operation
:
expr
{
pattern
:
expr
=
>
{
(
body
:
tt
)
*
}
(
t
:
tt
)
+
}
)
=
>
{
crate
:
:
__bitflags_match
!
(
operation
{
pattern
=
>
{
(
body
)
*
}
(
t
)
+
}
)
}
;
(
operation
:
expr
{
pattern
:
expr
=
>
{
(
body
:
tt
)
*
}
(
t
:
tt
)
+
}
)
=
>
{
{
if
operation
=
=
pattern
{
return
{
(
body
)
*
}
;
}
crate
:
:
__bitflags_match
!
(
operation
{
(
t
)
+
}
)
}
}
;
(
operation
:
expr
{
pattern
:
expr
=
>
body
:
expr
(
t
:
tt
)
+
}
)
=
>
{
{
if
operation
=
=
pattern
{
return
body
;
}
crate
:
:
__bitflags_match
!
(
operation
{
(
t
)
+
}
)
}
}
;
(
operation
:
expr
{
_
=
>
default
:
expr
(
)
?
}
)
=
>
{
default
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__bitflags_expr_safe_attrs
{
(
(
#
[
inner
:
ident
(
args
:
tt
)
*
]
)
*
{
e
:
expr
}
)
=
>
{
crate
:
:
__bitflags_expr_safe_attrs
!
{
expr
:
{
e
}
attrs
:
{
/
/
All
attributes
start
here
unprocessed
:
[
(
#
[
inner
(
args
)
*
]
)
*
]
/
/
Attributes
that
are
safe
on
expressions
go
here
processed
:
[
]
}
}
}
;
(
expr
:
{
e
:
expr
}
attrs
:
{
unprocessed
:
[
#
[
cfg
(
args
:
tt
)
*
]
(
attrs_rest
:
tt
)
*
]
processed
:
[
(
expr
:
tt
)
*
]
}
)
=
>
{
crate
:
:
__bitflags_expr_safe_attrs
!
{
expr
:
{
e
}
attrs
:
{
unprocessed
:
[
(
attrs_rest
)
*
]
processed
:
[
(
expr
)
*
/
/
cfg
added
here
#
[
cfg
(
args
)
*
]
]
}
}
}
;
(
expr
:
{
e
:
expr
}
attrs
:
{
unprocessed
:
[
#
[
other
:
ident
(
args
:
tt
)
*
]
(
attrs_rest
:
tt
)
*
]
processed
:
[
(
expr
:
tt
)
*
]
}
)
=
>
{
crate
:
:
__bitflags_expr_safe_attrs
!
{
expr
:
{
e
}
attrs
:
{
unprocessed
:
[
(
attrs_rest
)
*
]
processed
:
[
/
/
other
not
added
here
(
expr
)
*
]
}
}
}
;
(
expr
:
{
e
:
expr
}
attrs
:
{
unprocessed
:
[
]
processed
:
[
(
#
[
expr
:
ident
(
exprargs
:
tt
)
*
]
)
*
]
}
)
=
>
{
(
#
[
expr
(
exprargs
)
*
]
)
*
{
e
}
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__bitflags_flag
{
(
{
name
:
_
named
:
{
(
named
:
tt
)
*
}
unnamed
:
{
(
unnamed
:
tt
)
*
}
}
)
=
>
{
(
unnamed
)
*
}
;
(
{
name
:
Flag
:
ident
named
:
{
(
named
:
tt
)
*
}
unnamed
:
{
(
unnamed
:
tt
)
*
}
}
)
=
>
{
(
named
)
*
}
;
}
#
[
macro_use
]
mod
public
;
#
[
macro_use
]
mod
internal
;
#
[
macro_use
]
mod
external
;
#
[
cfg
(
feature
=
"
example_generated
"
)
]
pub
mod
example_generated
;
#
[
cfg
(
test
)
]
mod
tests
;
