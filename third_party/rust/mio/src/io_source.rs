use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
AsRawFd
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
io
:
:
AsRawSocket
;
#
[
cfg
(
debug_assertions
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
{
fmt
io
}
;
use
crate
:
:
sys
:
:
IoSourceState
;
use
crate
:
:
{
event
Interest
Registry
Token
}
;
pub
struct
IoSource
<
T
>
{
state
:
IoSourceState
inner
:
T
#
[
cfg
(
debug_assertions
)
]
selector_id
:
SelectorId
}
impl
<
T
>
IoSource
<
T
>
{
pub
fn
new
(
io
:
T
)
-
>
IoSource
<
T
>
{
IoSource
{
state
:
IoSourceState
:
:
new
(
)
inner
:
io
#
[
cfg
(
debug_assertions
)
]
selector_id
:
SelectorId
:
:
new
(
)
}
}
pub
fn
do_io
<
F
R
>
(
&
self
f
:
F
)
-
>
io
:
:
Result
<
R
>
where
F
:
FnOnce
(
&
T
)
-
>
io
:
:
Result
<
R
>
{
self
.
state
.
do_io
(
f
&
self
.
inner
)
}
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
inner
}
}
impl
<
T
>
Deref
for
IoSource
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
inner
}
}
impl
<
T
>
DerefMut
for
IoSource
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
inner
}
}
#
[
cfg
(
unix
)
]
impl
<
T
>
event
:
:
Source
for
IoSource
<
T
>
where
T
:
AsRawFd
{
fn
register
(
&
mut
self
registry
:
&
Registry
token
:
Token
interests
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
debug_assertions
)
]
self
.
selector_id
.
associate
(
registry
)
?
;
registry
.
selector
(
)
.
register
(
self
.
inner
.
as_raw_fd
(
)
token
interests
)
}
fn
reregister
(
&
mut
self
registry
:
&
Registry
token
:
Token
interests
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
debug_assertions
)
]
self
.
selector_id
.
check_association
(
registry
)
?
;
registry
.
selector
(
)
.
reregister
(
self
.
inner
.
as_raw_fd
(
)
token
interests
)
}
fn
deregister
(
&
mut
self
registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
debug_assertions
)
]
self
.
selector_id
.
remove_association
(
registry
)
?
;
registry
.
selector
(
)
.
deregister
(
self
.
inner
.
as_raw_fd
(
)
)
}
}
#
[
cfg
(
windows
)
]
impl
<
T
>
event
:
:
Source
for
IoSource
<
T
>
where
T
:
AsRawSocket
{
fn
register
(
&
mut
self
registry
:
&
Registry
token
:
Token
interests
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
debug_assertions
)
]
self
.
selector_id
.
associate
(
registry
)
?
;
self
.
state
.
register
(
registry
token
interests
self
.
inner
.
as_raw_socket
(
)
)
}
fn
reregister
(
&
mut
self
registry
:
&
Registry
token
:
Token
interests
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
debug_assertions
)
]
self
.
selector_id
.
check_association
(
registry
)
?
;
self
.
state
.
reregister
(
registry
token
interests
)
}
fn
deregister
(
&
mut
self
_registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
debug_assertions
)
]
self
.
selector_id
.
remove_association
(
_registry
)
?
;
self
.
state
.
deregister
(
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
IoSource
<
T
>
where
T
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
inner
.
fmt
(
f
)
}
}
#
[
cfg
(
debug_assertions
)
]
#
[
derive
(
Debug
)
]
struct
SelectorId
{
id
:
AtomicUsize
}
#
[
cfg
(
debug_assertions
)
]
impl
SelectorId
{
const
UNASSOCIATED
:
usize
=
0
;
const
fn
new
(
)
-
>
SelectorId
{
SelectorId
{
id
:
AtomicUsize
:
:
new
(
Self
:
:
UNASSOCIATED
)
}
}
fn
associate
(
&
self
registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
let
registry_id
=
registry
.
selector
(
)
.
id
(
)
;
let
previous_id
=
self
.
id
.
swap
(
registry_id
Ordering
:
:
AcqRel
)
;
if
previous_id
=
=
Self
:
:
UNASSOCIATED
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
AlreadyExists
"
I
/
O
source
already
registered
with
a
Registry
"
)
)
}
}
fn
check_association
(
&
self
registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
let
registry_id
=
registry
.
selector
(
)
.
id
(
)
;
let
id
=
self
.
id
.
load
(
Ordering
:
:
Acquire
)
;
if
id
=
=
registry_id
{
Ok
(
(
)
)
}
else
if
id
=
=
Self
:
:
UNASSOCIATED
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
NotFound
"
I
/
O
source
not
registered
with
Registry
"
)
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
AlreadyExists
"
I
/
O
source
already
registered
with
a
different
Registry
"
)
)
}
}
fn
remove_association
(
&
self
registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
let
registry_id
=
registry
.
selector
(
)
.
id
(
)
;
let
previous_id
=
self
.
id
.
swap
(
Self
:
:
UNASSOCIATED
Ordering
:
:
AcqRel
)
;
if
previous_id
=
=
registry_id
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
NotFound
"
I
/
O
source
not
registered
with
Registry
"
)
)
}
}
}
#
[
cfg
(
debug_assertions
)
]
impl
Clone
for
SelectorId
{
fn
clone
(
&
self
)
-
>
SelectorId
{
SelectorId
{
id
:
AtomicUsize
:
:
new
(
self
.
id
.
load
(
Ordering
:
:
Acquire
)
)
}
}
}
