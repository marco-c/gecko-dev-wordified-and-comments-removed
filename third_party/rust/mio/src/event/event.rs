use
crate
:
:
{
sys
Token
}
;
use
std
:
:
fmt
;
#
[
derive
(
Clone
)
]
#
[
repr
(
transparent
)
]
pub
struct
Event
{
inner
:
sys
:
:
Event
}
impl
Event
{
pub
fn
token
(
&
self
)
-
>
Token
{
sys
:
:
event
:
:
token
(
&
self
.
inner
)
}
pub
fn
is_readable
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_readable
(
&
self
.
inner
)
}
pub
fn
is_writable
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_writable
(
&
self
.
inner
)
}
pub
fn
is_error
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_error
(
&
self
.
inner
)
}
pub
fn
is_read_closed
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_read_closed
(
&
self
.
inner
)
}
pub
fn
is_write_closed
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_write_closed
(
&
self
.
inner
)
}
#
[
inline
]
pub
fn
is_priority
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_priority
(
&
self
.
inner
)
}
pub
fn
is_aio
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_aio
(
&
self
.
inner
)
}
pub
fn
is_lio
(
&
self
)
-
>
bool
{
sys
:
:
event
:
:
is_lio
(
&
self
.
inner
)
}
pub
(
crate
)
fn
from_sys_event_ref
(
sys_event
:
&
sys
:
:
Event
)
-
>
&
Event
{
unsafe
{
&
*
(
sys_event
as
*
const
sys
:
:
Event
as
*
const
Event
)
}
}
}
impl
fmt
:
:
Debug
for
Event
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
alternate
=
f
.
alternate
(
)
;
let
mut
d
=
f
.
debug_struct
(
"
Event
"
)
;
d
.
field
(
"
token
"
&
self
.
token
(
)
)
.
field
(
"
readable
"
&
self
.
is_readable
(
)
)
.
field
(
"
writable
"
&
self
.
is_writable
(
)
)
.
field
(
"
error
"
&
self
.
is_error
(
)
)
.
field
(
"
read_closed
"
&
self
.
is_read_closed
(
)
)
.
field
(
"
write_closed
"
&
self
.
is_write_closed
(
)
)
.
field
(
"
priority
"
&
self
.
is_priority
(
)
)
.
field
(
"
aio
"
&
self
.
is_aio
(
)
)
.
field
(
"
lio
"
&
self
.
is_lio
(
)
)
;
if
alternate
{
struct
EventDetails
<
'
a
>
(
&
'
a
sys
:
:
Event
)
;
impl
<
'
a
>
fmt
:
:
Debug
for
EventDetails
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
sys
:
:
event
:
:
debug_details
(
f
self
.
0
)
}
}
d
.
field
(
"
details
"
&
EventDetails
(
&
self
.
inner
)
)
.
finish
(
)
}
else
{
d
.
finish
(
)
}
}
}
