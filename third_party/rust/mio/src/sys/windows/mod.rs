use
std
:
:
io
;
use
std
:
:
os
:
:
windows
:
:
prelude
:
:
*
;
mod
kernel32
{
pub
use
:
:
winapi
:
:
um
:
:
ioapiset
:
:
CancelIoEx
;
pub
use
:
:
winapi
:
:
um
:
:
winbase
:
:
SetFileCompletionNotificationModes
;
}
mod
winapi
{
pub
use
:
:
winapi
:
:
shared
:
:
minwindef
:
:
{
TRUE
UCHAR
}
;
pub
use
:
:
winapi
:
:
um
:
:
winnt
:
:
HANDLE
;
}
mod
awakener
;
#
[
macro_use
]
mod
selector
;
mod
tcp
;
mod
udp
;
mod
from_raw_arc
;
mod
buffer_pool
;
pub
use
self
:
:
awakener
:
:
Awakener
;
pub
use
self
:
:
selector
:
:
{
Events
Selector
Overlapped
Binding
}
;
pub
use
self
:
:
tcp
:
:
{
TcpStream
TcpListener
}
;
pub
use
self
:
:
udp
:
:
UdpSocket
;
#
[
derive
(
Copy
Clone
)
]
enum
Family
{
V4
V6
}
unsafe
fn
cancel
(
socket
:
&
AsRawSocket
overlapped
:
&
Overlapped
)
-
>
io
:
:
Result
<
(
)
>
{
let
handle
=
socket
.
as_raw_socket
(
)
as
winapi
:
:
HANDLE
;
let
ret
=
kernel32
:
:
CancelIoEx
(
handle
overlapped
.
as_mut_ptr
(
)
)
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
unsafe
fn
no_notify_on_instant_completion
(
handle
:
winapi
:
:
HANDLE
)
-
>
io
:
:
Result
<
(
)
>
{
const
FILE_SKIP_COMPLETION_PORT_ON_SUCCESS
:
winapi
:
:
UCHAR
=
1
;
const
FILE_SKIP_SET_EVENT_ON_HANDLE
:
winapi
:
:
UCHAR
=
2
;
let
flags
=
FILE_SKIP_COMPLETION_PORT_ON_SUCCESS
|
FILE_SKIP_SET_EVENT_ON_HANDLE
;
let
r
=
kernel32
:
:
SetFileCompletionNotificationModes
(
handle
flags
)
;
if
r
=
=
winapi
:
:
TRUE
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
}
