use
super
:
:
{
Handle
Overlapped
}
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
mem
;
use
std
:
:
os
:
:
windows
:
:
io
:
:
*
;
use
std
:
:
time
:
:
Duration
;
use
windows_sys
:
:
Win32
:
:
Foundation
:
:
{
HANDLE
INVALID_HANDLE_VALUE
}
;
use
windows_sys
:
:
Win32
:
:
System
:
:
IO
:
:
{
CreateIoCompletionPort
GetQueuedCompletionStatusEx
PostQueuedCompletionStatus
OVERLAPPED
OVERLAPPED_ENTRY
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
CompletionPort
{
handle
:
Handle
}
#
[
derive
(
Clone
Copy
)
]
#
[
repr
(
transparent
)
]
pub
struct
CompletionStatus
(
OVERLAPPED_ENTRY
)
;
impl
fmt
:
:
Debug
for
CompletionStatus
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
CompletionStatus
(
OVERLAPPED_ENTRY
)
"
)
}
}
unsafe
impl
Send
for
CompletionStatus
{
}
unsafe
impl
Sync
for
CompletionStatus
{
}
impl
CompletionPort
{
pub
fn
new
(
threads
:
u32
)
-
>
io
:
:
Result
<
CompletionPort
>
{
let
ret
=
unsafe
{
CreateIoCompletionPort
(
INVALID_HANDLE_VALUE
0
0
threads
)
}
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
CompletionPort
{
handle
:
Handle
:
:
new
(
ret
)
}
)
}
}
#
[
cfg
(
any
(
feature
=
"
net
"
feature
=
"
os
-
ext
"
)
)
]
pub
fn
add_handle
<
T
:
AsRawHandle
+
?
Sized
>
(
&
self
token
:
usize
t
:
&
T
)
-
>
io
:
:
Result
<
(
)
>
{
let
ret
=
unsafe
{
CreateIoCompletionPort
(
t
.
as_raw_handle
(
)
as
HANDLE
self
.
handle
.
raw
(
)
token
0
)
}
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
pub
fn
get_many
<
'
a
>
(
&
self
list
:
&
'
a
mut
[
CompletionStatus
]
timeout
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
&
'
a
mut
[
CompletionStatus
]
>
{
debug_assert_eq
!
(
mem
:
:
size_of
:
:
<
CompletionStatus
>
(
)
mem
:
:
size_of
:
:
<
OVERLAPPED_ENTRY
>
(
)
)
;
let
mut
removed
=
0
;
let
timeout
=
duration_millis
(
timeout
)
;
let
len
=
cmp
:
:
min
(
list
.
len
(
)
<
u32
>
:
:
max_value
(
)
as
usize
)
as
u32
;
let
ret
=
unsafe
{
GetQueuedCompletionStatusEx
(
self
.
handle
.
raw
(
)
list
.
as_ptr
(
)
as
*
mut
_
len
&
mut
removed
timeout
0
)
}
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
&
mut
list
[
.
.
removed
as
usize
]
)
}
}
pub
fn
post
(
&
self
status
:
CompletionStatus
)
-
>
io
:
:
Result
<
(
)
>
{
let
ret
=
unsafe
{
PostQueuedCompletionStatus
(
self
.
handle
.
raw
(
)
status
.
0
.
dwNumberOfBytesTransferred
status
.
0
.
lpCompletionKey
status
.
0
.
lpOverlapped
)
}
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
impl
AsRawHandle
for
CompletionPort
{
fn
as_raw_handle
(
&
self
)
-
>
RawHandle
{
self
.
handle
.
raw
(
)
as
RawHandle
}
}
impl
FromRawHandle
for
CompletionPort
{
unsafe
fn
from_raw_handle
(
handle
:
RawHandle
)
-
>
CompletionPort
{
CompletionPort
{
handle
:
Handle
:
:
new
(
handle
as
HANDLE
)
}
}
}
impl
IntoRawHandle
for
CompletionPort
{
fn
into_raw_handle
(
self
)
-
>
RawHandle
{
self
.
handle
.
into_raw
(
)
}
}
impl
CompletionStatus
{
pub
(
crate
)
fn
new
(
bytes
:
u32
token
:
usize
overlapped
:
*
mut
Overlapped
)
-
>
Self
{
CompletionStatus
(
OVERLAPPED_ENTRY
{
dwNumberOfBytesTransferred
:
bytes
lpCompletionKey
:
token
lpOverlapped
:
overlapped
as
*
mut
_
Internal
:
0
}
)
}
#
[
cfg
(
feature
=
"
os
-
ext
"
)
]
pub
fn
from_entry
(
entry
:
&
OVERLAPPED_ENTRY
)
-
>
&
Self
{
unsafe
{
&
*
(
entry
as
*
const
_
as
*
const
_
)
}
}
pub
fn
zero
(
)
-
>
Self
{
Self
:
:
new
(
0
0
std
:
:
ptr
:
:
null_mut
(
)
)
}
pub
fn
bytes_transferred
(
&
self
)
-
>
u32
{
self
.
0
.
dwNumberOfBytesTransferred
}
pub
fn
token
(
&
self
)
-
>
usize
{
self
.
0
.
lpCompletionKey
as
usize
}
pub
fn
overlapped
(
&
self
)
-
>
*
mut
OVERLAPPED
{
self
.
0
.
lpOverlapped
}
pub
fn
entry
(
&
self
)
-
>
&
OVERLAPPED_ENTRY
{
&
self
.
0
}
}
#
[
inline
]
fn
duration_millis
(
dur
:
Option
<
Duration
>
)
-
>
u32
{
if
let
Some
(
dur
)
=
dur
{
let
dur_ms
=
dur
.
checked_add
(
Duration
:
:
from_nanos
(
999_999
)
)
.
unwrap_or
(
dur
)
.
as_millis
(
)
;
cmp
:
:
min
(
dur_ms
u32
:
:
MAX
as
u128
)
as
u32
}
else
{
u32
:
:
MAX
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
CompletionPort
CompletionStatus
}
;
#
[
test
]
fn
is_send_sync
(
)
{
fn
is_send_sync
<
T
:
Send
+
Sync
>
(
)
{
}
is_send_sync
:
:
<
CompletionPort
>
(
)
;
}
#
[
test
]
fn
get_many
(
)
{
let
c
=
CompletionPort
:
:
new
(
1
)
.
unwrap
(
)
;
c
.
post
(
CompletionStatus
:
:
new
(
1
2
3
as
*
mut
_
)
)
.
unwrap
(
)
;
c
.
post
(
CompletionStatus
:
:
new
(
4
5
6
as
*
mut
_
)
)
.
unwrap
(
)
;
let
mut
s
=
vec
!
[
CompletionStatus
:
:
zero
(
)
;
4
]
;
{
let
s
=
c
.
get_many
(
&
mut
s
None
)
.
unwrap
(
)
;
assert_eq
!
(
s
.
len
(
)
2
)
;
assert_eq
!
(
s
[
0
]
.
bytes_transferred
(
)
1
)
;
assert_eq
!
(
s
[
0
]
.
token
(
)
2
)
;
assert_eq
!
(
s
[
0
]
.
overlapped
(
)
3
as
*
mut
_
)
;
assert_eq
!
(
s
[
1
]
.
bytes_transferred
(
)
4
)
;
assert_eq
!
(
s
[
1
]
.
token
(
)
5
)
;
assert_eq
!
(
s
[
1
]
.
overlapped
(
)
6
as
*
mut
_
)
;
}
assert_eq
!
(
s
[
2
]
.
bytes_transferred
(
)
0
)
;
assert_eq
!
(
s
[
2
]
.
token
(
)
0
)
;
assert_eq
!
(
s
[
2
]
.
overlapped
(
)
0
as
*
mut
_
)
;
}
}
