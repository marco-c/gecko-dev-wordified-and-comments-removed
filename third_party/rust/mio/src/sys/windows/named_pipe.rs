use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
FromRawHandle
RawHandle
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Relaxed
SeqCst
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
AtomicUsize
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
{
fmt
mem
slice
}
;
use
windows_sys
:
:
Win32
:
:
Foundation
:
:
{
ERROR_BROKEN_PIPE
ERROR_IO_INCOMPLETE
ERROR_IO_PENDING
ERROR_NO_DATA
ERROR_PIPE_CONNECTED
ERROR_PIPE_LISTENING
HANDLE
INVALID_HANDLE_VALUE
}
;
use
windows_sys
:
:
Win32
:
:
Storage
:
:
FileSystem
:
:
{
ReadFile
WriteFile
FILE_FLAG_FIRST_PIPE_INSTANCE
FILE_FLAG_OVERLAPPED
PIPE_ACCESS_DUPLEX
}
;
use
windows_sys
:
:
Win32
:
:
System
:
:
Pipes
:
:
{
ConnectNamedPipe
CreateNamedPipeW
DisconnectNamedPipe
PIPE_TYPE_BYTE
PIPE_UNLIMITED_INSTANCES
}
;
use
windows_sys
:
:
Win32
:
:
System
:
:
IO
:
:
{
CancelIoEx
GetOverlappedResult
OVERLAPPED
OVERLAPPED_ENTRY
}
;
use
crate
:
:
event
:
:
Source
;
use
crate
:
:
sys
:
:
windows
:
:
iocp
:
:
{
CompletionPort
CompletionStatus
}
;
use
crate
:
:
sys
:
:
windows
:
:
{
Event
Handle
Overlapped
}
;
use
crate
:
:
Registry
;
use
crate
:
:
{
Interest
Token
}
;
pub
struct
NamedPipe
{
inner
:
Arc
<
Inner
>
}
#
[
repr
(
C
)
]
struct
Inner
{
connect
:
Overlapped
read
:
Overlapped
write
:
Overlapped
handle
:
Handle
connecting
:
AtomicBool
io
:
Mutex
<
Io
>
pool
:
Mutex
<
BufferPool
>
}
impl
Inner
{
unsafe
fn
ptr_from_conn_overlapped
(
ptr
:
*
mut
OVERLAPPED
)
-
>
*
const
Inner
{
ptr
.
cast
(
)
}
unsafe
fn
ptr_from_read_overlapped
(
ptr
:
*
mut
OVERLAPPED
)
-
>
*
const
Inner
{
(
ptr
as
*
mut
Overlapped
)
.
wrapping_sub
(
1
)
as
*
const
Inner
}
unsafe
fn
ptr_from_write_overlapped
(
ptr
:
*
mut
OVERLAPPED
)
-
>
*
const
Inner
{
(
ptr
as
*
mut
Overlapped
)
.
wrapping_sub
(
2
)
as
*
const
Inner
}
pub
unsafe
fn
connect_overlapped
(
&
self
overlapped
:
*
mut
OVERLAPPED
)
-
>
io
:
:
Result
<
bool
>
{
if
ConnectNamedPipe
(
self
.
handle
.
raw
(
)
overlapped
)
!
=
0
{
return
Ok
(
true
)
;
}
let
err
=
io
:
:
Error
:
:
last_os_error
(
)
;
match
err
.
raw_os_error
(
)
.
map
(
|
e
|
e
as
u32
)
{
Some
(
ERROR_PIPE_CONNECTED
)
=
>
Ok
(
true
)
Some
(
ERROR_NO_DATA
)
=
>
Ok
(
true
)
Some
(
ERROR_IO_PENDING
)
=
>
Ok
(
false
)
_
=
>
Err
(
err
)
}
}
pub
fn
disconnect
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
unsafe
{
DisconnectNamedPipe
(
self
.
handle
.
raw
(
)
)
}
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
pub
unsafe
fn
read_overlapped
(
&
self
buf
:
&
mut
[
u8
]
overlapped
:
*
mut
OVERLAPPED
)
-
>
io
:
:
Result
<
Option
<
usize
>
>
{
let
len
=
std
:
:
cmp
:
:
min
(
buf
.
len
(
)
u32
:
:
MAX
as
usize
)
as
u32
;
let
res
=
ReadFile
(
self
.
handle
.
raw
(
)
buf
.
as_mut_ptr
(
)
as
*
mut
_
len
std
:
:
ptr
:
:
null_mut
(
)
overlapped
)
;
if
res
=
=
0
{
let
err
=
io
:
:
Error
:
:
last_os_error
(
)
;
if
err
.
raw_os_error
(
)
!
=
Some
(
ERROR_IO_PENDING
as
i32
)
{
return
Err
(
err
)
;
}
}
let
mut
bytes
=
0
;
let
res
=
GetOverlappedResult
(
self
.
handle
.
raw
(
)
overlapped
&
mut
bytes
0
)
;
if
res
=
=
0
{
let
err
=
io
:
:
Error
:
:
last_os_error
(
)
;
if
err
.
raw_os_error
(
)
=
=
Some
(
ERROR_IO_INCOMPLETE
as
i32
)
{
Ok
(
None
)
}
else
{
Err
(
err
)
}
}
else
{
Ok
(
Some
(
bytes
as
usize
)
)
}
}
pub
unsafe
fn
write_overlapped
(
&
self
buf
:
&
[
u8
]
overlapped
:
*
mut
OVERLAPPED
)
-
>
io
:
:
Result
<
Option
<
usize
>
>
{
let
len
=
std
:
:
cmp
:
:
min
(
buf
.
len
(
)
u32
:
:
MAX
as
usize
)
as
u32
;
let
res
=
WriteFile
(
self
.
handle
.
raw
(
)
buf
.
as_ptr
(
)
as
*
const
_
len
std
:
:
ptr
:
:
null_mut
(
)
overlapped
)
;
if
res
=
=
0
{
let
err
=
io
:
:
Error
:
:
last_os_error
(
)
;
if
err
.
raw_os_error
(
)
!
=
Some
(
ERROR_IO_PENDING
as
i32
)
{
return
Err
(
err
)
;
}
}
let
mut
bytes
=
0
;
let
res
=
GetOverlappedResult
(
self
.
handle
.
raw
(
)
overlapped
&
mut
bytes
0
)
;
if
res
=
=
0
{
let
err
=
io
:
:
Error
:
:
last_os_error
(
)
;
if
err
.
raw_os_error
(
)
=
=
Some
(
ERROR_IO_INCOMPLETE
as
i32
)
{
Ok
(
None
)
}
else
{
Err
(
err
)
}
}
else
{
Ok
(
Some
(
bytes
as
usize
)
)
}
}
#
[
inline
]
unsafe
fn
result
(
&
self
overlapped
:
*
mut
OVERLAPPED
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
transferred
=
0
;
let
r
=
GetOverlappedResult
(
self
.
handle
.
raw
(
)
overlapped
&
mut
transferred
0
)
;
if
r
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
transferred
as
usize
)
}
}
}
#
[
test
]
fn
ptr_from
(
)
{
use
std
:
:
mem
:
:
ManuallyDrop
;
use
std
:
:
ptr
;
let
pipe
=
unsafe
{
ManuallyDrop
:
:
new
(
NamedPipe
:
:
from_raw_handle
(
ptr
:
:
null_mut
(
)
)
)
}
;
let
inner
:
&
Inner
=
&
pipe
.
inner
;
assert_eq
!
(
inner
as
*
const
Inner
unsafe
{
Inner
:
:
ptr_from_conn_overlapped
(
&
inner
.
connect
as
*
const
_
as
*
mut
OVERLAPPED
)
}
"
ptr_from_conn_overlapped
incorrect
"
)
;
assert_eq
!
(
inner
as
*
const
Inner
unsafe
{
Inner
:
:
ptr_from_read_overlapped
(
&
inner
.
read
as
*
const
_
as
*
mut
OVERLAPPED
)
}
"
ptr_from_read_overlapped
incorrect
"
)
;
assert_eq
!
(
inner
as
*
const
Inner
unsafe
{
Inner
:
:
ptr_from_write_overlapped
(
&
inner
.
write
as
*
const
_
as
*
mut
OVERLAPPED
)
}
"
ptr_from_write_overlapped
incorrect
"
)
;
}
struct
Io
{
cp
:
Option
<
Arc
<
CompletionPort
>
>
token
:
Option
<
Token
>
read
:
State
write
:
State
connect_error
:
Option
<
io
:
:
Error
>
}
#
[
derive
(
Debug
)
]
enum
State
{
None
Pending
(
Vec
<
u8
>
usize
)
Ok
(
Vec
<
u8
>
usize
)
Err
(
io
:
:
Error
)
}
static
NEXT_TOKEN
:
AtomicUsize
=
AtomicUsize
:
:
new
(
1
)
;
fn
would_block
(
)
-
>
io
:
:
Error
{
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
}
impl
NamedPipe
{
pub
fn
new
<
A
:
AsRef
<
OsStr
>
>
(
addr
:
A
)
-
>
io
:
:
Result
<
NamedPipe
>
{
use
std
:
:
os
:
:
windows
:
:
ffi
:
:
OsStrExt
;
let
name
:
Vec
<
_
>
=
addr
.
as_ref
(
)
.
encode_wide
(
)
.
chain
(
Some
(
0
)
)
.
collect
(
)
;
let
h
=
unsafe
{
CreateNamedPipeW
(
name
.
as_ptr
(
)
PIPE_ACCESS_DUPLEX
|
FILE_FLAG_FIRST_PIPE_INSTANCE
|
FILE_FLAG_OVERLAPPED
PIPE_TYPE_BYTE
PIPE_UNLIMITED_INSTANCES
65536
65536
0
std
:
:
ptr
:
:
null_mut
(
)
)
}
;
if
h
=
=
INVALID_HANDLE_VALUE
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
unsafe
{
Self
:
:
from_raw_handle
(
h
as
RawHandle
)
}
)
}
}
pub
fn
connect
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
self
.
inner
.
connecting
.
swap
(
true
SeqCst
)
{
return
Err
(
would_block
(
)
)
;
}
let
res
=
unsafe
{
let
overlapped
=
self
.
inner
.
connect
.
as_ptr
(
)
as
*
mut
_
;
self
.
inner
.
connect_overlapped
(
overlapped
)
}
;
match
res
{
Ok
(
true
)
=
>
{
self
.
inner
.
connecting
.
store
(
false
SeqCst
)
;
Inner
:
:
post_register
(
&
self
.
inner
None
)
;
Ok
(
(
)
)
}
Ok
(
false
)
=
>
{
mem
:
:
forget
(
self
.
inner
.
clone
(
)
)
;
Err
(
would_block
(
)
)
}
Err
(
e
)
=
>
{
self
.
inner
.
connecting
.
store
(
false
SeqCst
)
;
Err
(
e
)
}
}
}
pub
fn
take_error
(
&
self
)
-
>
io
:
:
Result
<
Option
<
io
:
:
Error
>
>
{
Ok
(
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
.
connect_error
.
take
(
)
)
}
pub
fn
disconnect
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
disconnect
(
)
}
}
impl
FromRawHandle
for
NamedPipe
{
unsafe
fn
from_raw_handle
(
handle
:
RawHandle
)
-
>
NamedPipe
{
NamedPipe
{
inner
:
Arc
:
:
new
(
Inner
{
handle
:
Handle
:
:
new
(
handle
as
HANDLE
)
connect
:
Overlapped
:
:
new
(
connect_done
)
connecting
:
AtomicBool
:
:
new
(
false
)
read
:
Overlapped
:
:
new
(
read_done
)
write
:
Overlapped
:
:
new
(
write_done
)
io
:
Mutex
:
:
new
(
Io
{
cp
:
None
token
:
None
read
:
State
:
:
None
write
:
State
:
:
None
connect_error
:
None
}
)
pool
:
Mutex
:
:
new
(
BufferPool
:
:
with_capacity
(
2
)
)
}
)
}
}
}
impl
Read
for
NamedPipe
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
<
&
NamedPipe
as
Read
>
:
:
read
(
&
mut
&
*
self
buf
)
}
}
impl
Write
for
NamedPipe
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
<
&
NamedPipe
as
Write
>
:
:
write
(
&
mut
&
*
self
buf
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
<
&
NamedPipe
as
Write
>
:
:
flush
(
&
mut
&
*
self
)
}
}
impl
<
'
a
>
Read
for
&
'
a
NamedPipe
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
state
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
if
state
.
token
.
is_none
(
)
{
return
Err
(
would_block
(
)
)
;
}
match
mem
:
:
replace
(
&
mut
state
.
read
State
:
:
None
)
{
State
:
:
None
=
>
Err
(
would_block
(
)
)
State
:
:
Pending
(
buf
amt
)
=
>
{
state
.
read
=
State
:
:
Pending
(
buf
amt
)
;
Err
(
would_block
(
)
)
}
State
:
:
Ok
(
data
cur
)
=
>
{
let
n
=
{
let
mut
remaining
=
&
data
[
cur
.
.
]
;
remaining
.
read
(
buf
)
?
}
;
let
next
=
cur
+
n
;
if
next
!
=
data
.
len
(
)
{
state
.
read
=
State
:
:
Ok
(
data
next
)
;
}
else
{
self
.
inner
.
put_buffer
(
data
)
;
Inner
:
:
schedule_read
(
&
self
.
inner
&
mut
state
None
)
;
}
Ok
(
n
)
}
State
:
:
Err
(
e
)
=
>
{
Inner
:
:
schedule_read
(
&
self
.
inner
&
mut
state
None
)
;
if
e
.
raw_os_error
(
)
=
=
Some
(
ERROR_BROKEN_PIPE
as
i32
)
{
Ok
(
0
)
}
else
{
Err
(
e
)
}
}
}
}
}
impl
<
'
a
>
Write
for
&
'
a
NamedPipe
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
if
io
.
token
.
is_none
(
)
{
return
Err
(
would_block
(
)
)
;
}
match
io
.
write
{
State
:
:
None
=
>
{
}
State
:
:
Err
(
_
)
=
>
match
mem
:
:
replace
(
&
mut
io
.
write
State
:
:
None
)
{
State
:
:
Err
(
e
)
=
>
return
Err
(
e
)
_
=
>
unreachable
!
(
)
}
_
=
>
{
return
Err
(
would_block
(
)
)
;
}
}
let
mut
owned_buf
=
self
.
inner
.
get_buffer
(
)
;
owned_buf
.
extend
(
buf
)
;
match
Inner
:
:
maybe_schedule_write
(
&
self
.
inner
owned_buf
0
&
mut
io
)
?
{
Some
(
n
)
=
>
Ok
(
n
)
None
=
>
Ok
(
buf
.
len
(
)
)
}
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
Source
for
NamedPipe
{
fn
register
(
&
mut
self
registry
:
&
Registry
token
:
Token
_
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
io
.
check_association
(
registry
false
)
?
;
if
io
.
token
.
is_some
(
)
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
AlreadyExists
"
I
/
O
source
already
registered
with
a
Registry
"
)
)
;
}
if
io
.
cp
.
is_none
(
)
{
let
selector
=
registry
.
selector
(
)
;
io
.
cp
=
Some
(
selector
.
clone_port
(
)
)
;
let
inner_token
=
NEXT_TOKEN
.
fetch_add
(
2
Relaxed
)
+
2
;
selector
.
inner
.
cp
.
add_handle
(
inner_token
self
)
?
;
}
io
.
token
=
Some
(
token
)
;
drop
(
io
)
;
Inner
:
:
post_register
(
&
self
.
inner
None
)
;
Ok
(
(
)
)
}
fn
reregister
(
&
mut
self
registry
:
&
Registry
token
:
Token
_
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
io
.
check_association
(
registry
true
)
?
;
io
.
token
=
Some
(
token
)
;
drop
(
io
)
;
Inner
:
:
post_register
(
&
self
.
inner
None
)
;
Ok
(
(
)
)
}
fn
deregister
(
&
mut
self
registry
:
&
Registry
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
io
.
check_association
(
registry
true
)
?
;
if
io
.
token
.
is_none
(
)
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
NotFound
"
I
/
O
source
not
registered
with
Registry
"
)
)
;
}
io
.
token
=
None
;
Ok
(
(
)
)
}
}
impl
AsRawHandle
for
NamedPipe
{
fn
as_raw_handle
(
&
self
)
-
>
RawHandle
{
self
.
inner
.
handle
.
raw
(
)
as
RawHandle
}
}
impl
fmt
:
:
Debug
for
NamedPipe
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
inner
.
handle
.
fmt
(
f
)
}
}
impl
Drop
for
NamedPipe
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
self
.
inner
.
connecting
.
load
(
SeqCst
)
{
drop
(
cancel
(
&
self
.
inner
.
handle
&
self
.
inner
.
connect
)
)
;
}
let
io
=
self
.
inner
.
io
.
lock
(
)
.
unwrap
(
)
;
if
let
State
:
:
Pending
(
.
.
)
=
io
.
read
{
drop
(
cancel
(
&
self
.
inner
.
handle
&
self
.
inner
.
read
)
)
;
}
}
}
}
impl
Inner
{
fn
schedule_read
(
me
:
&
Arc
<
Inner
>
io
:
&
mut
Io
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
-
>
bool
{
match
io
.
read
{
State
:
:
None
=
>
{
}
_
=
>
return
true
}
let
mut
buf
=
me
.
get_buffer
(
)
;
let
e
=
unsafe
{
let
overlapped
=
me
.
read
.
as_ptr
(
)
as
*
mut
_
;
let
slice
=
slice
:
:
from_raw_parts_mut
(
buf
.
as_mut_ptr
(
)
buf
.
capacity
(
)
)
;
me
.
read_overlapped
(
slice
overlapped
)
}
;
match
e
{
Ok
(
_
)
=
>
{
io
.
read
=
State
:
:
Pending
(
buf
0
)
;
mem
:
:
forget
(
me
.
clone
(
)
)
;
true
}
Err
(
ref
e
)
if
e
.
raw_os_error
(
)
=
=
Some
(
ERROR_PIPE_LISTENING
as
i32
)
=
>
false
Err
(
e
)
=
>
{
io
.
read
=
State
:
:
Err
(
e
)
;
io
.
notify_readable
(
events
)
;
true
}
}
}
fn
maybe_schedule_write
(
me
:
&
Arc
<
Inner
>
buf
:
Vec
<
u8
>
pos
:
usize
io
:
&
mut
Io
)
-
>
io
:
:
Result
<
Option
<
usize
>
>
{
let
e
=
unsafe
{
let
overlapped
=
me
.
write
.
as_ptr
(
)
as
*
mut
_
;
me
.
write_overlapped
(
&
buf
[
pos
.
.
]
overlapped
)
}
;
match
e
{
Ok
(
Some
(
n
)
)
=
>
{
io
.
write
=
State
:
:
Ok
(
buf
pos
)
;
mem
:
:
forget
(
me
.
clone
(
)
)
;
Ok
(
Some
(
n
)
)
}
Ok
(
None
)
=
>
{
io
.
write
=
State
:
:
Pending
(
buf
pos
)
;
mem
:
:
forget
(
me
.
clone
(
)
)
;
Ok
(
None
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
fn
schedule_write
(
me
:
&
Arc
<
Inner
>
buf
:
Vec
<
u8
>
pos
:
usize
io
:
&
mut
Io
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
match
Inner
:
:
maybe_schedule_write
(
me
buf
pos
io
)
{
Ok
(
Some
(
_
)
)
=
>
{
let
state
=
mem
:
:
replace
(
&
mut
io
.
write
State
:
:
None
)
;
io
.
write
=
match
state
{
State
:
:
Ok
(
buf
pos
)
=
>
State
:
:
Pending
(
buf
pos
)
_
=
>
unreachable
!
(
)
}
;
mem
:
:
forget
(
me
.
clone
(
)
)
;
}
Ok
(
None
)
=
>
(
)
Err
(
e
)
=
>
{
io
.
write
=
State
:
:
Err
(
e
)
;
io
.
notify_writable
(
events
)
;
}
}
}
fn
post_register
(
me
:
&
Arc
<
Inner
>
mut
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
let
mut
io
=
me
.
io
.
lock
(
)
.
unwrap
(
)
;
#
[
allow
(
clippy
:
:
needless_option_as_deref
)
]
if
Inner
:
:
schedule_read
(
me
&
mut
io
events
.
as_deref_mut
(
)
)
{
if
let
State
:
:
None
=
io
.
write
{
io
.
notify_writable
(
events
)
;
}
}
}
fn
get_buffer
(
&
self
)
-
>
Vec
<
u8
>
{
self
.
pool
.
lock
(
)
.
unwrap
(
)
.
get
(
4
*
1024
)
}
fn
put_buffer
(
&
self
buf
:
Vec
<
u8
>
)
{
self
.
pool
.
lock
(
)
.
unwrap
(
)
.
put
(
buf
)
}
}
unsafe
fn
cancel
(
handle
:
&
Handle
overlapped
:
&
Overlapped
)
-
>
io
:
:
Result
<
(
)
>
{
let
ret
=
CancelIoEx
(
handle
.
raw
(
)
overlapped
.
as_ptr
(
)
)
;
if
ret
=
=
0
{
Err
(
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
connect_done
(
status
:
&
OVERLAPPED_ENTRY
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
let
status
=
CompletionStatus
:
:
from_entry
(
status
)
;
let
me
=
unsafe
{
Arc
:
:
from_raw
(
Inner
:
:
ptr_from_conn_overlapped
(
status
.
overlapped
(
)
)
)
}
;
let
prev
=
me
.
connecting
.
swap
(
false
SeqCst
)
;
assert
!
(
prev
"
NamedPipe
was
not
previously
connecting
"
)
;
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
0
)
;
unsafe
{
match
me
.
result
(
status
.
overlapped
(
)
)
{
Ok
(
n
)
=
>
debug_assert_eq
!
(
n
0
)
Err
(
e
)
=
>
me
.
io
.
lock
(
)
.
unwrap
(
)
.
connect_error
=
Some
(
e
)
}
}
Inner
:
:
post_register
(
&
me
events
)
;
}
fn
read_done
(
status
:
&
OVERLAPPED_ENTRY
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
let
status
=
CompletionStatus
:
:
from_entry
(
status
)
;
let
me
=
unsafe
{
Arc
:
:
from_raw
(
Inner
:
:
ptr_from_read_overlapped
(
status
.
overlapped
(
)
)
)
}
;
let
mut
io
=
me
.
io
.
lock
(
)
.
unwrap
(
)
;
let
mut
buf
=
match
mem
:
:
replace
(
&
mut
io
.
read
State
:
:
None
)
{
State
:
:
Pending
(
buf
_
)
=
>
buf
_
=
>
unreachable
!
(
)
}
;
unsafe
{
match
me
.
result
(
status
.
overlapped
(
)
)
{
Ok
(
n
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
as
usize
n
)
;
buf
.
set_len
(
status
.
bytes_transferred
(
)
as
usize
)
;
io
.
read
=
State
:
:
Ok
(
buf
0
)
;
}
Err
(
e
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
0
)
;
io
.
read
=
State
:
:
Err
(
e
)
;
}
}
}
io
.
notify_readable
(
events
)
;
}
fn
write_done
(
status
:
&
OVERLAPPED_ENTRY
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
let
status
=
CompletionStatus
:
:
from_entry
(
status
)
;
let
me
=
unsafe
{
Arc
:
:
from_raw
(
Inner
:
:
ptr_from_write_overlapped
(
status
.
overlapped
(
)
)
)
}
;
let
mut
io
=
me
.
io
.
lock
(
)
.
unwrap
(
)
;
let
(
buf
pos
)
=
match
mem
:
:
replace
(
&
mut
io
.
write
State
:
:
None
)
{
State
:
:
Ok
(
.
.
)
=
>
{
io
.
notify_writable
(
events
)
;
return
;
}
State
:
:
Pending
(
buf
pos
)
=
>
(
buf
pos
)
_
=
>
unreachable
!
(
)
}
;
unsafe
{
match
me
.
result
(
status
.
overlapped
(
)
)
{
Ok
(
n
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
as
usize
n
)
;
let
new_pos
=
pos
+
(
status
.
bytes_transferred
(
)
as
usize
)
;
if
new_pos
=
=
buf
.
len
(
)
{
me
.
put_buffer
(
buf
)
;
io
.
notify_writable
(
events
)
;
}
else
{
Inner
:
:
schedule_write
(
&
me
buf
new_pos
&
mut
io
events
)
;
}
}
Err
(
e
)
=
>
{
debug_assert_eq
!
(
status
.
bytes_transferred
(
)
0
)
;
io
.
write
=
State
:
:
Err
(
e
)
;
io
.
notify_writable
(
events
)
;
}
}
}
}
impl
Io
{
fn
check_association
(
&
self
registry
:
&
Registry
required
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
match
self
.
cp
{
Some
(
ref
cp
)
if
!
registry
.
selector
(
)
.
same_port
(
cp
)
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
AlreadyExists
"
I
/
O
source
already
registered
with
a
different
Registry
"
)
)
None
if
required
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
NotFound
"
I
/
O
source
not
registered
with
Registry
"
)
)
_
=
>
Ok
(
(
)
)
}
}
fn
notify_readable
(
&
self
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
if
let
Some
(
token
)
=
self
.
token
{
let
mut
ev
=
Event
:
:
new
(
token
)
;
ev
.
set_readable
(
)
;
if
let
Some
(
events
)
=
events
{
events
.
push
(
ev
)
;
}
else
{
let
_
=
self
.
cp
.
as_ref
(
)
.
unwrap
(
)
.
post
(
ev
.
to_completion_status
(
)
)
;
}
}
}
fn
notify_writable
(
&
self
events
:
Option
<
&
mut
Vec
<
Event
>
>
)
{
if
let
Some
(
token
)
=
self
.
token
{
let
mut
ev
=
Event
:
:
new
(
token
)
;
ev
.
set_writable
(
)
;
if
let
Some
(
events
)
=
events
{
events
.
push
(
ev
)
;
}
else
{
let
_
=
self
.
cp
.
as_ref
(
)
.
unwrap
(
)
.
post
(
ev
.
to_completion_status
(
)
)
;
}
}
}
}
struct
BufferPool
{
pool
:
Vec
<
Vec
<
u8
>
>
}
impl
BufferPool
{
fn
with_capacity
(
cap
:
usize
)
-
>
BufferPool
{
BufferPool
{
pool
:
Vec
:
:
with_capacity
(
cap
)
}
}
fn
get
(
&
mut
self
default_cap
:
usize
)
-
>
Vec
<
u8
>
{
self
.
pool
.
pop
(
)
.
unwrap_or_else
(
|
|
Vec
:
:
with_capacity
(
default_cap
)
)
}
fn
put
(
&
mut
self
mut
buf
:
Vec
<
u8
>
)
{
if
self
.
pool
.
len
(
)
<
self
.
pool
.
capacity
(
)
{
unsafe
{
buf
.
set_len
(
0
)
;
}
self
.
pool
.
push
(
buf
)
;
}
}
}
