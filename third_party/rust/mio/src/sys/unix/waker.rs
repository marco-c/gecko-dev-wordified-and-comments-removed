#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
mod
eventfd
{
use
crate
:
:
sys
:
:
Selector
;
use
crate
:
:
{
Interest
Token
}
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
FromRawFd
;
#
[
derive
(
Debug
)
]
pub
struct
Waker
{
fd
:
File
}
impl
Waker
{
pub
fn
new
(
selector
:
&
Selector
token
:
Token
)
-
>
io
:
:
Result
<
Waker
>
{
syscall
!
(
eventfd
(
0
libc
:
:
EFD_CLOEXEC
|
libc
:
:
EFD_NONBLOCK
)
)
.
and_then
(
|
fd
|
{
let
file
=
unsafe
{
File
:
:
from_raw_fd
(
fd
)
}
;
selector
.
register
(
fd
token
Interest
:
:
READABLE
)
.
map
(
|
(
)
|
Waker
{
fd
:
file
}
)
}
)
}
pub
fn
wake
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
buf
:
[
u8
;
8
]
=
1u64
.
to_ne_bytes
(
)
;
match
(
&
self
.
fd
)
.
write
(
&
buf
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
ref
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
reset
(
)
?
;
self
.
wake
(
)
}
Err
(
err
)
=
>
Err
(
err
)
}
}
fn
reset
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
buf
:
[
u8
;
8
]
=
0u64
.
to_ne_bytes
(
)
;
match
(
&
self
.
fd
)
.
read
(
&
mut
buf
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
ref
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
Ok
(
(
)
)
Err
(
err
)
=
>
Err
(
err
)
}
}
}
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
pub
use
self
:
:
eventfd
:
:
Waker
;
#
[
cfg
(
any
(
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
]
mod
kqueue
{
use
crate
:
:
sys
:
:
Selector
;
use
crate
:
:
Token
;
use
std
:
:
io
;
#
[
derive
(
Debug
)
]
pub
struct
Waker
{
selector
:
Selector
token
:
Token
}
impl
Waker
{
pub
fn
new
(
selector
:
&
Selector
token
:
Token
)
-
>
io
:
:
Result
<
Waker
>
{
selector
.
try_clone
(
)
.
and_then
(
|
selector
|
{
selector
.
setup_waker
(
token
)
.
map
(
|
(
)
|
Waker
{
selector
token
}
)
}
)
}
pub
fn
wake
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
selector
.
wake
(
self
.
token
)
}
}
}
#
[
cfg
(
any
(
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
]
pub
use
self
:
:
kqueue
:
:
Waker
;
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
mod
pipe
{
use
crate
:
:
sys
:
:
unix
:
:
Selector
;
use
crate
:
:
{
Interest
Token
}
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
FromRawFd
;
#
[
derive
(
Debug
)
]
pub
struct
Waker
{
sender
:
File
receiver
:
File
}
impl
Waker
{
pub
fn
new
(
selector
:
&
Selector
token
:
Token
)
-
>
io
:
:
Result
<
Waker
>
{
let
mut
fds
=
[
-
1
;
2
]
;
syscall
!
(
pipe2
(
fds
.
as_mut_ptr
(
)
libc
:
:
O_NONBLOCK
|
libc
:
:
O_CLOEXEC
)
)
?
;
let
sender
=
unsafe
{
File
:
:
from_raw_fd
(
fds
[
1
]
)
}
;
let
receiver
=
unsafe
{
File
:
:
from_raw_fd
(
fds
[
0
]
)
}
;
selector
.
register
(
fds
[
0
]
token
Interest
:
:
READABLE
)
.
map
(
|
(
)
|
Waker
{
sender
receiver
}
)
}
pub
fn
wake
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
target_os
=
"
illumos
"
)
]
self
.
empty
(
)
;
match
(
&
self
.
sender
)
.
write
(
&
[
1
]
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
ref
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
empty
(
)
;
self
.
wake
(
)
}
Err
(
ref
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
self
.
wake
(
)
Err
(
err
)
=
>
Err
(
err
)
}
}
fn
empty
(
&
self
)
{
let
mut
buf
=
[
0
;
4096
]
;
loop
{
match
(
&
self
.
receiver
)
.
read
(
&
mut
buf
)
{
Ok
(
n
)
if
n
>
0
=
>
continue
_
=
>
return
}
}
}
}
}
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
pub
use
self
:
:
pipe
:
:
Waker
;
