use
event_imp
:
:
{
Ready
ready_from_usize
}
;
use
std
:
:
ops
;
#
[
derive
(
Debug
Copy
PartialEq
Eq
Clone
PartialOrd
Ord
)
]
pub
struct
UnixReady
(
Ready
)
;
const
ERROR
:
usize
=
0b00100
;
const
HUP
:
usize
=
0b01000
;
const
AIO
:
usize
=
0b10000
;
impl
UnixReady
{
#
[
inline
]
pub
fn
aio
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
AIO
)
)
}
#
[
inline
]
pub
fn
error
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
ERROR
)
)
}
#
[
inline
]
pub
fn
hup
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
HUP
)
)
}
#
[
inline
]
pub
fn
is_aio
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
AIO
)
)
}
#
[
inline
]
pub
fn
is_error
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
ERROR
)
)
}
#
[
inline
]
pub
fn
is_hup
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
HUP
)
)
}
}
impl
From
<
Ready
>
for
UnixReady
{
fn
from
(
src
:
Ready
)
-
>
UnixReady
{
UnixReady
(
src
)
}
}
impl
From
<
UnixReady
>
for
Ready
{
fn
from
(
src
:
UnixReady
)
-
>
Ready
{
src
.
0
}
}
impl
ops
:
:
Deref
for
UnixReady
{
type
Target
=
Ready
;
fn
deref
(
&
self
)
-
>
&
Ready
{
&
self
.
0
}
}
impl
ops
:
:
DerefMut
for
UnixReady
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Ready
{
&
mut
self
.
0
}
}
impl
ops
:
:
BitOr
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
bitor
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
|
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
BitXor
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
bitxor
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
^
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
BitAnd
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
bitand
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
&
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
Sub
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
sub
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
&
!
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
Not
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
not
(
self
)
-
>
UnixReady
{
(
!
self
.
0
)
.
into
(
)
}
}
