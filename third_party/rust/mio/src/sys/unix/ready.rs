use
event_imp
:
:
{
Ready
ready_as_usize
ready_from_usize
}
;
use
std
:
:
ops
;
use
std
:
:
fmt
;
#
[
derive
(
Copy
PartialEq
Eq
Clone
PartialOrd
Ord
)
]
pub
struct
UnixReady
(
Ready
)
;
const
ERROR
:
usize
=
0b00_0100
;
const
HUP
:
usize
=
0b00_1000
;
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
]
const
AIO
:
usize
=
0b01_0000
;
#
[
cfg
(
not
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
)
]
const
AIO
:
usize
=
0b00_0000
;
#
[
cfg
(
any
(
target_os
=
"
freebsd
"
)
)
]
const
LIO
:
usize
=
0b10_0000
;
#
[
cfg
(
not
(
any
(
target_os
=
"
freebsd
"
)
)
)
]
const
LIO
:
usize
=
0b00_0000
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
solaris
"
)
)
]
const
PRI
:
usize
=
0b100_0000
;
#
[
cfg
(
not
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
solaris
"
)
)
)
]
const
PRI
:
usize
=
0
;
pub
const
READY_ALL
:
usize
=
ERROR
|
HUP
|
AIO
|
LIO
|
PRI
;
#
[
test
]
fn
test_ready_all
(
)
{
let
readable
=
Ready
:
:
readable
(
)
.
as_usize
(
)
;
let
writable
=
Ready
:
:
writable
(
)
.
as_usize
(
)
;
assert_eq
!
(
READY_ALL
|
readable
|
writable
ERROR
+
HUP
+
AIO
+
LIO
+
PRI
+
readable
+
writable
)
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
solaris
"
)
)
]
assert
!
(
!
Ready
:
:
from
(
UnixReady
:
:
priority
(
)
)
.
is_writable
(
)
)
;
}
impl
UnixReady
{
#
[
inline
]
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
]
pub
fn
aio
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
AIO
)
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
)
]
#
[
deprecated
(
since
=
"
0
.
6
.
12
"
note
=
"
this
function
is
now
platform
specific
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
aio
(
)
-
>
UnixReady
{
UnixReady
(
Ready
:
:
empty
(
)
)
}
#
[
inline
]
pub
fn
error
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
ERROR
)
)
}
#
[
inline
]
pub
fn
hup
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
HUP
)
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_os
=
"
freebsd
"
)
)
]
pub
fn
lio
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
LIO
)
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
solaris
"
)
)
]
pub
fn
priority
(
)
-
>
UnixReady
{
UnixReady
(
ready_from_usize
(
PRI
)
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
]
pub
fn
is_aio
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
AIO
)
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
12
"
note
=
"
this
function
is
now
platform
specific
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
cfg
(
not
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
ios
"
target_os
=
"
macos
"
)
)
)
]
#
[
doc
(
hidden
)
]
pub
fn
is_aio
(
&
self
)
-
>
bool
{
false
}
#
[
inline
]
pub
fn
is_error
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
ERROR
)
)
}
#
[
inline
]
pub
fn
is_hup
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
HUP
)
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_os
=
"
freebsd
"
)
)
]
pub
fn
is_lio
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
LIO
)
)
}
#
[
inline
]
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
solaris
"
)
)
]
pub
fn
is_priority
(
&
self
)
-
>
bool
{
self
.
contains
(
ready_from_usize
(
PRI
)
)
}
}
impl
From
<
Ready
>
for
UnixReady
{
fn
from
(
src
:
Ready
)
-
>
UnixReady
{
UnixReady
(
src
)
}
}
impl
From
<
UnixReady
>
for
Ready
{
fn
from
(
src
:
UnixReady
)
-
>
Ready
{
src
.
0
}
}
impl
ops
:
:
Deref
for
UnixReady
{
type
Target
=
Ready
;
fn
deref
(
&
self
)
-
>
&
Ready
{
&
self
.
0
}
}
impl
ops
:
:
DerefMut
for
UnixReady
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Ready
{
&
mut
self
.
0
}
}
impl
ops
:
:
BitOr
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
bitor
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
|
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
BitXor
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
bitxor
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
^
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
BitAnd
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
bitand
(
self
other
:
UnixReady
)
-
>
UnixReady
{
(
self
.
0
&
other
.
0
)
.
into
(
)
}
}
impl
ops
:
:
Sub
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
sub
(
self
other
:
UnixReady
)
-
>
UnixReady
{
ready_from_usize
(
ready_as_usize
(
self
.
0
)
&
!
ready_as_usize
(
other
.
0
)
)
.
into
(
)
}
}
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
impl
ops
:
:
Not
for
UnixReady
{
type
Output
=
UnixReady
;
#
[
inline
]
fn
not
(
self
)
-
>
UnixReady
{
(
!
self
.
0
)
.
into
(
)
}
}
impl
fmt
:
:
Debug
for
UnixReady
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
one
=
false
;
let
flags
=
[
(
UnixReady
(
Ready
:
:
readable
(
)
)
"
Readable
"
)
(
UnixReady
(
Ready
:
:
writable
(
)
)
"
Writable
"
)
(
UnixReady
:
:
error
(
)
"
Error
"
)
(
UnixReady
:
:
hup
(
)
"
Hup
"
)
#
[
allow
(
deprecated
)
]
(
UnixReady
:
:
aio
(
)
"
Aio
"
)
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
solaris
"
)
)
]
(
UnixReady
:
:
priority
(
)
"
Priority
"
)
]
;
for
&
(
flag
msg
)
in
&
flags
{
if
self
.
contains
(
flag
)
{
if
one
{
write
!
(
fmt
"
|
"
)
?
}
write
!
(
fmt
"
{
}
"
msg
)
?
;
one
=
true
}
}
if
!
one
{
fmt
.
write_str
(
"
(
empty
)
"
)
?
;
}
Ok
(
(
)
)
}
}
