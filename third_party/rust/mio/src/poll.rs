use
crate
:
:
{
event
sys
Events
Interest
Token
}
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
RawFd
}
;
use
std
:
:
time
:
:
Duration
;
use
std
:
:
{
fmt
io
}
;
#
[
cfg_attr
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
)
doc
=
"
ignore
"
)
]
pub
struct
Poll
{
registry
:
Registry
}
pub
struct
Registry
{
selector
:
sys
:
:
Selector
}
impl
Poll
{
cfg_os_poll
!
{
/
/
/
Return
a
new
Poll
handle
.
/
/
/
/
/
/
This
function
will
make
a
syscall
to
the
operating
system
to
create
/
/
/
the
system
selector
.
If
this
syscall
fails
Poll
:
:
new
will
return
/
/
/
with
the
error
.
/
/
/
/
/
/
close
-
on
-
exec
flag
is
set
on
the
file
descriptors
used
by
the
selector
to
prevent
/
/
/
leaking
it
to
executed
processes
.
However
on
some
systems
such
as
/
/
/
old
Linux
systems
that
don
'
t
support
epoll_create1
syscall
it
is
done
/
/
/
non
-
atomically
so
a
separate
thread
executing
in
parallel
to
this
/
/
/
function
may
accidentally
leak
the
file
descriptor
if
it
executes
a
/
/
/
new
process
before
this
function
returns
.
/
/
/
/
/
/
See
[
struct
]
level
docs
for
more
details
.
/
/
/
/
/
/
[
struct
]
:
struct
.
Poll
.
html
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
/
/
/
#
use
std
:
:
error
:
:
Error
;
/
/
/
#
fn
main
(
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
/
/
/
use
mio
:
:
{
Poll
Events
}
;
/
/
/
use
std
:
:
time
:
:
Duration
;
/
/
/
/
/
/
let
mut
poll
=
match
Poll
:
:
new
(
)
{
/
/
/
Ok
(
poll
)
=
>
poll
/
/
/
Err
(
e
)
=
>
panic
!
(
"
failed
to
create
Poll
instance
;
err
=
{
:
?
}
"
e
)
/
/
/
}
;
/
/
/
/
/
/
/
/
Create
a
structure
to
receive
polled
events
/
/
/
let
mut
events
=
Events
:
:
with_capacity
(
1024
)
;
/
/
/
/
/
/
/
/
Wait
for
events
but
none
will
be
received
because
no
/
/
/
/
/
event
:
:
Source
s
have
been
registered
with
this
Poll
instance
.
/
/
/
poll
.
poll
(
&
mut
events
Some
(
Duration
:
:
from_millis
(
500
)
)
)
?
;
/
/
/
assert
!
(
events
.
is_empty
(
)
)
;
/
/
/
#
Ok
(
(
)
)
/
/
/
#
}
/
/
/
pub
fn
new
(
)
-
>
io
:
:
Result
<
Poll
>
{
sys
:
:
Selector
:
:
new
(
)
.
map
(
|
selector
|
Poll
{
registry
:
Registry
{
selector
}
}
)
}
}
pub
fn
registry
(
&
self
)
-
>
&
Registry
{
&
self
.
registry
}
#
[
cfg_attr
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
)
doc
=
"
ignore
"
)
]
pub
fn
poll
(
&
mut
self
events
:
&
mut
Events
timeout
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
registry
.
selector
.
select
(
events
.
sys
(
)
timeout
)
}
}
#
[
cfg
(
unix
)
]
impl
AsRawFd
for
Poll
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
registry
.
as_raw_fd
(
)
}
}
impl
fmt
:
:
Debug
for
Poll
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Poll
"
)
.
finish
(
)
}
}
impl
Registry
{
#
[
cfg_attr
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
)
doc
=
"
ignore
"
)
]
pub
fn
register
<
S
>
(
&
self
source
:
&
mut
S
token
:
Token
interests
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
where
S
:
event
:
:
Source
+
?
Sized
{
trace
!
(
"
registering
event
source
with
poller
:
token
=
{
:
?
}
interests
=
{
:
?
}
"
token
interests
)
;
source
.
register
(
self
token
interests
)
}
#
[
cfg_attr
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
)
doc
=
"
ignore
"
)
]
pub
fn
reregister
<
S
>
(
&
self
source
:
&
mut
S
token
:
Token
interests
:
Interest
)
-
>
io
:
:
Result
<
(
)
>
where
S
:
event
:
:
Source
+
?
Sized
{
trace
!
(
"
reregistering
event
source
with
poller
:
token
=
{
:
?
}
interests
=
{
:
?
}
"
token
interests
)
;
source
.
reregister
(
self
token
interests
)
}
#
[
cfg_attr
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
all
(
feature
=
"
os
-
poll
"
feature
=
"
net
"
)
)
doc
=
"
ignore
"
)
]
pub
fn
deregister
<
S
>
(
&
self
source
:
&
mut
S
)
-
>
io
:
:
Result
<
(
)
>
where
S
:
event
:
:
Source
+
?
Sized
{
trace
!
(
"
deregistering
event
source
from
poller
"
)
;
source
.
deregister
(
self
)
}
pub
fn
try_clone
(
&
self
)
-
>
io
:
:
Result
<
Registry
>
{
self
.
selector
.
try_clone
(
)
.
map
(
|
selector
|
Registry
{
selector
}
)
}
#
[
cfg
(
all
(
debug_assertions
not
(
target_os
=
"
wasi
"
)
)
)
]
pub
(
crate
)
fn
register_waker
(
&
self
)
{
assert
!
(
!
self
.
selector
.
register_waker
(
)
"
Only
a
single
Waker
can
be
active
per
Poll
instance
"
)
;
}
#
[
cfg
(
any
(
not
(
target_os
=
"
wasi
"
)
feature
=
"
net
"
)
)
]
pub
(
crate
)
fn
selector
(
&
self
)
-
>
&
sys
:
:
Selector
{
&
self
.
selector
}
}
impl
fmt
:
:
Debug
for
Registry
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Registry
"
)
.
finish
(
)
}
}
#
[
cfg
(
unix
)
]
impl
AsRawFd
for
Registry
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
selector
.
as_raw_fd
(
)
}
}
cfg_os_poll
!
{
#
[
cfg
(
unix
)
]
#
[
test
]
pub
fn
as_raw_fd
(
)
{
let
poll
=
Poll
:
:
new
(
)
.
unwrap
(
)
;
assert
!
(
poll
.
as_raw_fd
(
)
>
0
)
;
}
}
