use
{
Poll
Token
}
;
use
std
:
:
{
fmt
io
ops
}
;
pub
trait
Evented
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
;
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
;
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
;
}
impl
Evented
for
Box
<
Evented
>
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
register
(
poll
token
interest
opts
)
}
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
reregister
(
poll
token
interest
opts
)
}
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
deregister
(
poll
)
}
}
impl
<
T
:
Evented
>
Evented
for
Box
<
T
>
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
register
(
poll
token
interest
opts
)
}
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
reregister
(
poll
token
interest
opts
)
}
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
deregister
(
poll
)
}
}
impl
<
T
:
Evented
>
Evented
for
:
:
std
:
:
sync
:
:
Arc
<
T
>
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
register
(
poll
token
interest
opts
)
}
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
reregister
(
poll
token
interest
opts
)
}
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
as_ref
(
)
.
deregister
(
poll
)
}
}
#
[
derive
(
Copy
PartialEq
Eq
Clone
PartialOrd
Ord
)
]
pub
struct
PollOpt
(
usize
)
;
impl
PollOpt
{
#
[
inline
]
pub
fn
empty
(
)
-
>
PollOpt
{
PollOpt
(
0
)
}
#
[
inline
]
pub
fn
edge
(
)
-
>
PollOpt
{
PollOpt
(
0b0001
)
}
#
[
inline
]
pub
fn
level
(
)
-
>
PollOpt
{
PollOpt
(
0b0010
)
}
#
[
inline
]
pub
fn
oneshot
(
)
-
>
PollOpt
{
PollOpt
(
0b0100
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
urgent
(
)
-
>
PollOpt
{
PollOpt
(
0b1000
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
all
(
)
-
>
PollOpt
{
PollOpt
:
:
edge
(
)
|
PollOpt
:
:
level
(
)
|
PollOpt
:
:
oneshot
(
)
}
#
[
inline
]
pub
fn
is_edge
(
&
self
)
-
>
bool
{
self
.
contains
(
PollOpt
:
:
edge
(
)
)
}
#
[
inline
]
pub
fn
is_level
(
&
self
)
-
>
bool
{
self
.
contains
(
PollOpt
:
:
level
(
)
)
}
#
[
inline
]
pub
fn
is_oneshot
(
&
self
)
-
>
bool
{
self
.
contains
(
PollOpt
:
:
oneshot
(
)
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
allow
(
deprecated
)
]
#
[
inline
]
pub
fn
is_urgent
(
&
self
)
-
>
bool
{
self
.
contains
(
PollOpt
:
:
urgent
(
)
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
bits
(
&
self
)
-
>
usize
{
self
.
0
}
#
[
inline
]
pub
fn
contains
(
&
self
other
:
PollOpt
)
-
>
bool
{
(
*
self
&
other
)
=
=
other
}
#
[
inline
]
pub
fn
insert
(
&
mut
self
other
:
PollOpt
)
{
self
.
0
|
=
other
.
0
;
}
#
[
inline
]
pub
fn
remove
(
&
mut
self
other
:
PollOpt
)
{
self
.
0
&
=
!
other
.
0
;
}
}
impl
ops
:
:
BitOr
for
PollOpt
{
type
Output
=
PollOpt
;
#
[
inline
]
fn
bitor
(
self
other
:
PollOpt
)
-
>
PollOpt
{
PollOpt
(
self
.
0
|
other
.
0
)
}
}
impl
ops
:
:
BitXor
for
PollOpt
{
type
Output
=
PollOpt
;
#
[
inline
]
fn
bitxor
(
self
other
:
PollOpt
)
-
>
PollOpt
{
PollOpt
(
self
.
0
^
other
.
0
)
}
}
impl
ops
:
:
BitAnd
for
PollOpt
{
type
Output
=
PollOpt
;
#
[
inline
]
fn
bitand
(
self
other
:
PollOpt
)
-
>
PollOpt
{
PollOpt
(
self
.
0
&
other
.
0
)
}
}
impl
ops
:
:
Sub
for
PollOpt
{
type
Output
=
PollOpt
;
#
[
inline
]
fn
sub
(
self
other
:
PollOpt
)
-
>
PollOpt
{
PollOpt
(
self
.
0
&
!
other
.
0
)
}
}
#
[
deprecated
(
since
=
"
0
.
6
.
10
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
impl
ops
:
:
Not
for
PollOpt
{
type
Output
=
PollOpt
;
#
[
inline
]
fn
not
(
self
)
-
>
PollOpt
{
PollOpt
(
!
self
.
0
)
}
}
impl
fmt
:
:
Debug
for
PollOpt
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
one
=
false
;
let
flags
=
[
(
PollOpt
:
:
edge
(
)
"
Edge
-
Triggered
"
)
(
PollOpt
:
:
level
(
)
"
Level
-
Triggered
"
)
(
PollOpt
:
:
oneshot
(
)
"
OneShot
"
)
]
;
for
&
(
flag
msg
)
in
&
flags
{
if
self
.
contains
(
flag
)
{
if
one
{
write
!
(
fmt
"
|
"
)
?
}
write
!
(
fmt
"
{
}
"
msg
)
?
;
one
=
true
}
}
if
!
one
{
fmt
.
write_str
(
"
(
empty
)
"
)
?
;
}
Ok
(
(
)
)
}
}
#
[
test
]
fn
test_debug_pollopt
(
)
{
assert_eq
!
(
"
(
empty
)
"
format
!
(
"
{
:
?
}
"
PollOpt
:
:
empty
(
)
)
)
;
assert_eq
!
(
"
Edge
-
Triggered
"
format
!
(
"
{
:
?
}
"
PollOpt
:
:
edge
(
)
)
)
;
assert_eq
!
(
"
Level
-
Triggered
"
format
!
(
"
{
:
?
}
"
PollOpt
:
:
level
(
)
)
)
;
assert_eq
!
(
"
OneShot
"
format
!
(
"
{
:
?
}
"
PollOpt
:
:
oneshot
(
)
)
)
;
}
#
[
derive
(
Copy
PartialEq
Eq
Clone
PartialOrd
Ord
)
]
pub
struct
Ready
(
usize
)
;
const
READABLE
:
usize
=
0b00001
;
const
WRITABLE
:
usize
=
0b00010
;
const
ERROR
:
usize
=
0b00100
;
const
HUP
:
usize
=
0b01000
;
impl
Ready
{
pub
fn
empty
(
)
-
>
Ready
{
Ready
(
0
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
Ready
:
:
empty
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
none
(
)
-
>
Ready
{
Ready
:
:
empty
(
)
}
#
[
inline
]
pub
fn
readable
(
)
-
>
Ready
{
Ready
(
READABLE
)
}
#
[
inline
]
pub
fn
writable
(
)
-
>
Ready
{
Ready
(
WRITABLE
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
UnixReady
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
error
(
)
-
>
Ready
{
Ready
(
ERROR
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
UnixReady
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
hup
(
)
-
>
Ready
{
Ready
(
HUP
)
}
#
[
inline
]
pub
fn
all
(
)
-
>
Ready
{
Ready
(
READABLE
|
WRITABLE
|
:
:
sys
:
:
READY_ALL
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
*
self
=
=
Ready
:
:
empty
(
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
Ready
:
:
is_empty
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
is_none
(
&
self
)
-
>
bool
{
self
.
is_empty
(
)
}
#
[
inline
]
pub
fn
is_readable
(
&
self
)
-
>
bool
{
self
.
contains
(
Ready
:
:
readable
(
)
)
}
#
[
inline
]
pub
fn
is_writable
(
&
self
)
-
>
bool
{
self
.
contains
(
Ready
:
:
writable
(
)
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
UnixReady
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
is_error
(
&
self
)
-
>
bool
{
self
.
contains
(
Ready
(
ERROR
)
)
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
UnixReady
instead
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
is_hup
(
&
self
)
-
>
bool
{
self
.
contains
(
Ready
(
HUP
)
)
}
#
[
inline
]
pub
fn
insert
<
T
:
Into
<
Self
>
>
(
&
mut
self
other
:
T
)
{
let
other
=
other
.
into
(
)
;
self
.
0
|
=
other
.
0
;
}
#
[
inline
]
pub
fn
remove
<
T
:
Into
<
Self
>
>
(
&
mut
self
other
:
T
)
{
let
other
=
other
.
into
(
)
;
self
.
0
&
=
!
other
.
0
;
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
bits
(
&
self
)
-
>
usize
{
self
.
0
}
#
[
inline
]
pub
fn
contains
<
T
:
Into
<
Self
>
>
(
&
self
other
:
T
)
-
>
bool
{
let
other
=
other
.
into
(
)
;
(
*
self
&
other
)
=
=
other
}
pub
fn
from_usize
(
val
:
usize
)
-
>
Ready
{
Ready
(
val
)
}
pub
fn
as_usize
(
&
self
)
-
>
usize
{
self
.
0
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
BitOr
<
T
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
bitor
(
self
other
:
T
)
-
>
Ready
{
Ready
(
self
.
0
|
other
.
into
(
)
.
0
)
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
BitOrAssign
<
T
>
for
Ready
{
#
[
inline
]
fn
bitor_assign
(
&
mut
self
other
:
T
)
{
self
.
0
|
=
other
.
into
(
)
.
0
;
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
BitXor
<
T
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
bitxor
(
self
other
:
T
)
-
>
Ready
{
Ready
(
self
.
0
^
other
.
into
(
)
.
0
)
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
BitXorAssign
<
T
>
for
Ready
{
#
[
inline
]
fn
bitxor_assign
(
&
mut
self
other
:
T
)
{
self
.
0
^
=
other
.
into
(
)
.
0
;
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
BitAnd
<
T
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
bitand
(
self
other
:
T
)
-
>
Ready
{
Ready
(
self
.
0
&
other
.
into
(
)
.
0
)
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
BitAndAssign
<
T
>
for
Ready
{
#
[
inline
]
fn
bitand_assign
(
&
mut
self
other
:
T
)
{
self
.
0
&
=
other
.
into
(
)
.
0
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
Sub
<
T
>
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
sub
(
self
other
:
T
)
-
>
Ready
{
Ready
(
self
.
0
&
!
other
.
into
(
)
.
0
)
}
}
impl
<
T
:
Into
<
Ready
>
>
ops
:
:
SubAssign
<
T
>
for
Ready
{
#
[
inline
]
fn
sub_assign
(
&
mut
self
other
:
T
)
{
self
.
0
&
=
!
other
.
into
(
)
.
0
;
}
}
#
[
deprecated
(
since
=
"
0
.
6
.
10
"
note
=
"
removed
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
impl
ops
:
:
Not
for
Ready
{
type
Output
=
Ready
;
#
[
inline
]
fn
not
(
self
)
-
>
Ready
{
Ready
(
!
self
.
0
)
}
}
impl
fmt
:
:
Debug
for
Ready
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
one
=
false
;
let
flags
=
[
(
Ready
:
:
readable
(
)
"
Readable
"
)
(
Ready
:
:
writable
(
)
"
Writable
"
)
(
Ready
(
ERROR
)
"
Error
"
)
(
Ready
(
HUP
)
"
Hup
"
)
]
;
for
&
(
flag
msg
)
in
&
flags
{
if
self
.
contains
(
flag
)
{
if
one
{
write
!
(
fmt
"
|
"
)
?
}
write
!
(
fmt
"
{
}
"
msg
)
?
;
one
=
true
}
}
if
!
one
{
fmt
.
write_str
(
"
(
empty
)
"
)
?
;
}
Ok
(
(
)
)
}
}
#
[
test
]
fn
test_debug_ready
(
)
{
assert_eq
!
(
"
(
empty
)
"
format
!
(
"
{
:
?
}
"
Ready
:
:
empty
(
)
)
)
;
assert_eq
!
(
"
Readable
"
format
!
(
"
{
:
?
}
"
Ready
:
:
readable
(
)
)
)
;
assert_eq
!
(
"
Writable
"
format
!
(
"
{
:
?
}
"
Ready
:
:
writable
(
)
)
)
;
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Debug
)
]
pub
struct
Event
{
kind
:
Ready
token
:
Token
}
impl
Event
{
pub
fn
new
(
readiness
:
Ready
token
:
Token
)
-
>
Event
{
Event
{
kind
:
readiness
token
:
token
}
}
pub
fn
readiness
(
&
self
)
-
>
Ready
{
self
.
kind
}
#
[
deprecated
(
since
=
"
0
.
6
.
5
"
note
=
"
use
Event
:
:
readiness
(
)
"
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
kind
(
&
self
)
-
>
Ready
{
self
.
kind
}
pub
fn
token
(
&
self
)
-
>
Token
{
self
.
token
}
}
pub
fn
ready_as_usize
(
events
:
Ready
)
-
>
usize
{
events
.
0
}
pub
fn
opt_as_usize
(
opt
:
PollOpt
)
-
>
usize
{
opt
.
0
}
pub
fn
ready_from_usize
(
events
:
usize
)
-
>
Ready
{
Ready
(
events
)
}
pub
fn
opt_from_usize
(
opt
:
usize
)
-
>
PollOpt
{
PollOpt
(
opt
)
}
#
[
allow
(
dead_code
)
]
pub
fn
kind_mut
(
event
:
&
mut
Event
)
-
>
&
mut
Ready
{
&
mut
event
.
kind
}
