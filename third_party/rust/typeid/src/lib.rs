#
!
[
no_std
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
typeid
/
1
.
0
.
3
"
)
]
#
!
[
allow
(
clippy
:
:
doc_markdown
clippy
:
:
inline_always
)
]
extern
crate
self
as
typeid
;
use
core
:
:
any
:
:
TypeId
;
#
[
cfg
(
not
(
no_const_type_id
)
)
]
use
core
:
:
cmp
:
:
Ordering
;
#
[
cfg
(
not
(
no_const_type_id
)
)
]
use
core
:
:
fmt
:
:
{
self
Debug
}
;
#
[
cfg
(
not
(
no_const_type_id
)
)
]
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
#
[
cfg
(
not
(
no_const_type_id
)
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
ConstTypeId
{
type_id_fn
:
fn
(
)
-
>
TypeId
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
ConstTypeId
{
#
[
must_use
]
pub
const
fn
of
<
T
>
(
)
-
>
Self
where
T
:
?
Sized
{
ConstTypeId
{
type_id_fn
:
typeid
:
:
of
:
:
<
T
>
}
}
#
[
inline
]
fn
get
(
self
)
-
>
TypeId
{
(
self
.
type_id_fn
)
(
)
}
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
Debug
for
ConstTypeId
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
get
(
)
formatter
)
}
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
PartialEq
for
ConstTypeId
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
get
(
)
=
=
other
.
get
(
)
}
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
PartialEq
<
TypeId
>
for
ConstTypeId
{
fn
eq
(
&
self
other
:
&
TypeId
)
-
>
bool
{
self
.
get
(
)
=
=
*
other
}
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
Eq
for
ConstTypeId
{
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
PartialOrd
for
ConstTypeId
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
Ord
:
:
cmp
(
self
other
)
)
}
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
Ord
for
ConstTypeId
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
Ord
:
:
cmp
(
&
self
.
get
(
)
&
other
.
get
(
)
)
}
}
#
[
cfg
(
not
(
no_const_type_id
)
)
]
impl
Hash
for
ConstTypeId
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
get
(
)
.
hash
(
state
)
;
}
}
#
[
must_use
]
#
[
inline
(
always
)
]
pub
fn
of
<
T
>
(
)
-
>
TypeId
where
T
:
?
Sized
{
trait
NonStaticAny
{
fn
get_type_id
(
&
self
)
-
>
TypeId
where
Self
:
'
static
;
}
impl
<
T
:
?
Sized
>
NonStaticAny
for
PhantomData
<
T
>
{
#
[
inline
(
always
)
]
fn
get_type_id
(
&
self
)
-
>
TypeId
where
Self
:
'
static
{
TypeId
:
:
of
:
:
<
T
>
(
)
}
}
let
phantom_data
=
PhantomData
:
:
<
T
>
;
NonStaticAny
:
:
get_type_id
(
unsafe
{
mem
:
:
transmute
:
:
<
&
dyn
NonStaticAny
&
(
dyn
NonStaticAny
+
'
static
)
>
(
&
phantom_data
)
}
)
}
