use
hal
:
:
memory
as
m
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
)
]
pub
enum
MemoryUsage
{
Private
Dynamic
{
sparse_updates
:
bool
}
Staging
{
read_back
:
bool
}
}
impl
MemoryUsage
{
pub
fn
properties_required
(
self
)
-
>
m
:
:
Properties
{
match
self
{
MemoryUsage
:
:
Private
=
>
m
:
:
Properties
:
:
DEVICE_LOCAL
MemoryUsage
:
:
Dynamic
{
.
.
}
|
MemoryUsage
:
:
Staging
{
.
.
}
=
>
m
:
:
Properties
:
:
CPU_VISIBLE
}
}
#
[
allow
(
clippy
:
:
identity_op
)
]
pub
(
crate
)
fn
memory_fitness
(
self
properties
:
m
:
:
Properties
)
-
>
u32
{
match
self
{
MemoryUsage
:
:
Private
=
>
{
assert
!
(
properties
.
contains
(
m
:
:
Properties
:
:
DEVICE_LOCAL
)
)
;
0
|
(
!
properties
.
contains
(
m
:
:
Properties
:
:
CPU_VISIBLE
)
as
u32
)
<
<
3
|
(
!
properties
.
contains
(
m
:
:
Properties
:
:
LAZILY_ALLOCATED
)
as
u32
)
<
<
2
|
(
!
properties
.
contains
(
m
:
:
Properties
:
:
CPU_CACHED
)
as
u32
)
<
<
1
|
(
!
properties
.
contains
(
m
:
:
Properties
:
:
COHERENT
)
as
u32
)
<
<
0
}
MemoryUsage
:
:
Dynamic
{
sparse_updates
}
=
>
{
assert
!
(
properties
.
contains
(
m
:
:
Properties
:
:
CPU_VISIBLE
)
)
;
assert
!
(
!
properties
.
contains
(
m
:
:
Properties
:
:
LAZILY_ALLOCATED
)
)
;
0
|
(
properties
.
contains
(
m
:
:
Properties
:
:
DEVICE_LOCAL
)
as
u32
)
<
<
2
|
(
(
properties
.
contains
(
m
:
:
Properties
:
:
COHERENT
)
=
=
sparse_updates
)
as
u32
)
<
<
1
|
(
!
properties
.
contains
(
m
:
:
Properties
:
:
CPU_CACHED
)
as
u32
)
<
<
0
}
MemoryUsage
:
:
Staging
{
read_back
}
=
>
{
assert
!
(
properties
.
contains
(
m
:
:
Properties
:
:
CPU_VISIBLE
)
)
;
assert
!
(
!
properties
.
contains
(
m
:
:
Properties
:
:
LAZILY_ALLOCATED
)
)
;
0
|
(
(
properties
.
contains
(
m
:
:
Properties
:
:
CPU_CACHED
)
=
=
read_back
)
as
u32
)
<
<
1
|
(
!
properties
.
contains
(
m
:
:
Properties
:
:
DEVICE_LOCAL
)
as
u32
)
<
<
0
}
}
}
}
