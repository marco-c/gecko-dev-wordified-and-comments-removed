use
libc
:
:
SI_LOAD_SHIFT
;
use
std
:
:
time
:
:
Duration
;
use
std
:
:
{
cmp
mem
}
;
use
crate
:
:
errno
:
:
Errno
;
use
crate
:
:
Result
;
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
#
[
repr
(
transparent
)
]
pub
struct
SysInfo
(
libc
:
:
sysinfo
)
;
#
[
cfg
(
all
(
target_arch
=
"
x86_64
"
target_pointer_width
=
"
32
"
)
)
]
type
mem_blocks_t
=
u64
;
#
[
cfg
(
not
(
all
(
target_arch
=
"
x86_64
"
target_pointer_width
=
"
32
"
)
)
)
]
type
mem_blocks_t
=
libc
:
:
c_ulong
;
impl
SysInfo
{
pub
fn
load_average
(
&
self
)
-
>
(
f64
f64
f64
)
{
(
self
.
0
.
loads
[
0
]
as
f64
/
(
1
<
<
SI_LOAD_SHIFT
)
as
f64
self
.
0
.
loads
[
1
]
as
f64
/
(
1
<
<
SI_LOAD_SHIFT
)
as
f64
self
.
0
.
loads
[
2
]
as
f64
/
(
1
<
<
SI_LOAD_SHIFT
)
as
f64
)
}
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
pub
fn
uptime
(
&
self
)
-
>
Duration
{
Duration
:
:
from_secs
(
cmp
:
:
max
(
self
.
0
.
uptime
0
)
as
u64
)
}
pub
fn
process_count
(
&
self
)
-
>
u16
{
self
.
0
.
procs
}
pub
fn
swap_total
(
&
self
)
-
>
u64
{
self
.
scale_mem
(
self
.
0
.
totalswap
)
}
pub
fn
swap_free
(
&
self
)
-
>
u64
{
self
.
scale_mem
(
self
.
0
.
freeswap
)
}
pub
fn
ram_total
(
&
self
)
-
>
u64
{
self
.
scale_mem
(
self
.
0
.
totalram
)
}
pub
fn
ram_unused
(
&
self
)
-
>
u64
{
self
.
scale_mem
(
self
.
0
.
freeram
)
}
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
fn
scale_mem
(
&
self
units
:
mem_blocks_t
)
-
>
u64
{
units
as
u64
*
self
.
0
.
mem_unit
as
u64
}
}
pub
fn
sysinfo
(
)
-
>
Result
<
SysInfo
>
{
let
mut
info
=
mem
:
:
MaybeUninit
:
:
uninit
(
)
;
let
res
=
unsafe
{
libc
:
:
sysinfo
(
info
.
as_mut_ptr
(
)
)
}
;
Errno
:
:
result
(
res
)
.
map
(
|
_
|
unsafe
{
SysInfo
(
info
.
assume_init
(
)
)
}
)
}
