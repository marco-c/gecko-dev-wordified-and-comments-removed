use
libc
:
:
{
self
c_int
}
;
use
Result
;
use
errno
:
:
Errno
;
use
unistd
:
:
Pid
;
use
sys
:
:
signal
:
:
Signal
;
libc_bitflags
!
(
pub
struct
WaitPidFlag
:
c_int
{
WNOHANG
;
WUNTRACED
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
ios
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
netbsd
"
)
)
]
WEXITED
;
WCONTINUED
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
ios
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
netbsd
"
)
)
]
WSTOPPED
;
/
/
/
Don
'
t
reap
just
poll
status
.
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
ios
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
netbsd
"
)
)
]
WNOWAIT
;
/
/
/
Don
'
t
wait
on
children
of
other
threads
in
this
group
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
__WNOTHREAD
;
/
/
/
Wait
on
all
children
regardless
of
type
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
__WALL
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
__WCLONE
;
}
)
;
#
[
derive
(
Eq
PartialEq
Clone
Copy
Debug
)
]
pub
enum
WaitStatus
{
Exited
(
Pid
i32
)
Signaled
(
Pid
Signal
bool
)
Stopped
(
Pid
Signal
)
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
PtraceEvent
(
Pid
Signal
c_int
)
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
PtraceSyscall
(
Pid
)
Continued
(
Pid
)
StillAlive
}
impl
WaitStatus
{
pub
fn
pid
(
&
self
)
-
>
Option
<
Pid
>
{
use
self
:
:
WaitStatus
:
:
*
;
match
*
self
{
Exited
(
p
_
)
|
Signaled
(
p
_
_
)
|
Stopped
(
p
_
)
|
Continued
(
p
)
=
>
Some
(
p
)
StillAlive
=
>
None
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
PtraceEvent
(
p
_
_
)
|
PtraceSyscall
(
p
)
=
>
Some
(
p
)
}
}
}
fn
exited
(
status
:
i32
)
-
>
bool
{
unsafe
{
libc
:
:
WIFEXITED
(
status
)
}
}
fn
exit_status
(
status
:
i32
)
-
>
i32
{
unsafe
{
libc
:
:
WEXITSTATUS
(
status
)
}
}
fn
signaled
(
status
:
i32
)
-
>
bool
{
unsafe
{
libc
:
:
WIFSIGNALED
(
status
)
}
}
fn
term_signal
(
status
:
i32
)
-
>
Result
<
Signal
>
{
Signal
:
:
from_c_int
(
unsafe
{
libc
:
:
WTERMSIG
(
status
)
}
)
}
fn
dumped_core
(
status
:
i32
)
-
>
bool
{
unsafe
{
libc
:
:
WCOREDUMP
(
status
)
}
}
fn
stopped
(
status
:
i32
)
-
>
bool
{
unsafe
{
libc
:
:
WIFSTOPPED
(
status
)
}
}
fn
stop_signal
(
status
:
i32
)
-
>
Result
<
Signal
>
{
Signal
:
:
from_c_int
(
unsafe
{
libc
:
:
WSTOPSIG
(
status
)
}
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
syscall_stop
(
status
:
i32
)
-
>
bool
{
unsafe
{
libc
:
:
WSTOPSIG
(
status
)
=
=
libc
:
:
SIGTRAP
|
0x80
}
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
stop_additional
(
status
:
i32
)
-
>
c_int
{
(
status
>
>
16
)
as
c_int
}
fn
continued
(
status
:
i32
)
-
>
bool
{
unsafe
{
libc
:
:
WIFCONTINUED
(
status
)
}
}
impl
WaitStatus
{
pub
fn
from_raw
(
pid
:
Pid
status
:
i32
)
-
>
Result
<
WaitStatus
>
{
Ok
(
if
exited
(
status
)
{
WaitStatus
:
:
Exited
(
pid
exit_status
(
status
)
)
}
else
if
signaled
(
status
)
{
WaitStatus
:
:
Signaled
(
pid
term_signal
(
status
)
?
dumped_core
(
status
)
)
}
else
if
stopped
(
status
)
{
cfg_if
!
{
if
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
{
fn
decode_stopped
(
pid
:
Pid
status
:
i32
)
-
>
Result
<
WaitStatus
>
{
let
status_additional
=
stop_additional
(
status
)
;
Ok
(
if
syscall_stop
(
status
)
{
WaitStatus
:
:
PtraceSyscall
(
pid
)
}
else
if
status_additional
=
=
0
{
WaitStatus
:
:
Stopped
(
pid
stop_signal
(
status
)
?
)
}
else
{
WaitStatus
:
:
PtraceEvent
(
pid
stop_signal
(
status
)
?
stop_additional
(
status
)
)
}
)
}
}
else
{
fn
decode_stopped
(
pid
:
Pid
status
:
i32
)
-
>
Result
<
WaitStatus
>
{
Ok
(
WaitStatus
:
:
Stopped
(
pid
stop_signal
(
status
)
?
)
)
}
}
}
return
decode_stopped
(
pid
status
)
;
}
else
{
assert
!
(
continued
(
status
)
)
;
WaitStatus
:
:
Continued
(
pid
)
}
)
}
}
pub
fn
waitpid
<
P
:
Into
<
Option
<
Pid
>
>
>
(
pid
:
P
options
:
Option
<
WaitPidFlag
>
)
-
>
Result
<
WaitStatus
>
{
use
self
:
:
WaitStatus
:
:
*
;
let
mut
status
:
i32
=
0
;
let
option_bits
=
match
options
{
Some
(
bits
)
=
>
bits
.
bits
(
)
None
=
>
0
}
;
let
res
=
unsafe
{
libc
:
:
waitpid
(
pid
.
into
(
)
.
unwrap_or
(
Pid
:
:
from_raw
(
-
1
)
)
.
into
(
)
&
mut
status
as
*
mut
c_int
option_bits
)
}
;
match
Errno
:
:
result
(
res
)
?
{
0
=
>
Ok
(
StillAlive
)
res
=
>
WaitStatus
:
:
from_raw
(
Pid
:
:
from_raw
(
res
)
status
)
}
}
pub
fn
wait
(
)
-
>
Result
<
WaitStatus
>
{
waitpid
(
None
None
)
}
