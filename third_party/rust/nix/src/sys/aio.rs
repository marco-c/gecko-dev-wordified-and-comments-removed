#
[
cfg
(
target_os
=
"
freebsd
"
)
]
use
std
:
:
io
:
:
{
IoSlice
IoSliceMut
}
;
use
std
:
:
{
convert
:
:
TryFrom
fmt
:
:
{
self
Debug
}
marker
:
:
{
PhantomData
PhantomPinned
}
mem
os
:
:
unix
:
:
io
:
:
RawFd
pin
:
:
Pin
ptr
thread
}
;
use
libc
:
:
off_t
;
use
pin_utils
:
:
unsafe_pinned
;
use
crate
:
:
{
errno
:
:
Errno
sys
:
:
{
signal
:
:
*
time
:
:
TimeSpec
}
Result
}
;
libc_enum
!
{
/
/
/
Mode
for
AioCb
:
:
fsync
.
Controls
whether
only
data
or
both
data
and
/
/
/
metadata
are
synced
.
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
AioFsyncMode
{
/
/
/
do
it
like
fsync
O_SYNC
/
/
/
on
supported
operating
systems
only
do
it
like
fdatasync
#
[
cfg
(
any
(
apple_targets
target_os
=
"
linux
"
netbsdlike
)
)
]
O_DSYNC
}
impl
TryFrom
<
i32
>
}
libc_enum
!
{
/
/
/
Mode
for
[
lio_listio
]
(
fn
.
lio_listio
.
html
)
#
[
repr
(
i32
)
]
pub
enum
LioMode
{
/
/
/
Requests
that
[
lio_listio
]
(
fn
.
lio_listio
.
html
)
block
until
all
/
/
/
requested
operations
have
been
completed
LIO_WAIT
/
/
/
Requests
that
[
lio_listio
]
(
fn
.
lio_listio
.
html
)
return
immediately
LIO_NOWAIT
}
}
#
[
repr
(
i32
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
enum
AioCancelStat
{
AioCanceled
=
libc
:
:
AIO_CANCELED
AioNotCanceled
=
libc
:
:
AIO_NOTCANCELED
AioAllDone
=
libc
:
:
AIO_ALLDONE
}
#
[
repr
(
transparent
)
]
struct
LibcAiocb
(
libc
:
:
aiocb
)
;
unsafe
impl
Send
for
LibcAiocb
{
}
unsafe
impl
Sync
for
LibcAiocb
{
}
#
[
repr
(
C
)
]
struct
AioCb
{
aiocb
:
LibcAiocb
in_progress
:
bool
}
impl
AioCb
{
pin_utils
:
:
unsafe_unpinned
!
(
aiocb
:
LibcAiocb
)
;
fn
aio_return
(
mut
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
usize
>
{
self
.
in_progress
=
false
;
unsafe
{
let
p
:
*
mut
libc
:
:
aiocb
=
&
mut
self
.
aiocb
.
0
;
Errno
:
:
result
(
libc
:
:
aio_return
(
p
)
)
}
.
map
(
|
r
|
r
as
usize
)
}
fn
cancel
(
mut
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
AioCancelStat
>
{
let
r
=
unsafe
{
libc
:
:
aio_cancel
(
self
.
aiocb
.
0
.
aio_fildes
&
mut
self
.
aiocb
.
0
)
}
;
match
r
{
libc
:
:
AIO_CANCELED
=
>
Ok
(
AioCancelStat
:
:
AioCanceled
)
libc
:
:
AIO_NOTCANCELED
=
>
Ok
(
AioCancelStat
:
:
AioNotCanceled
)
libc
:
:
AIO_ALLDONE
=
>
Ok
(
AioCancelStat
:
:
AioAllDone
)
-
1
=
>
Err
(
Errno
:
:
last
(
)
)
_
=
>
panic
!
(
"
unknown
aio_cancel
return
value
"
)
}
}
fn
common_init
(
fd
:
RawFd
prio
:
i32
sigev_notify
:
SigevNotify
)
-
>
Self
{
let
mut
a
=
unsafe
{
mem
:
:
zeroed
:
:
<
libc
:
:
aiocb
>
(
)
}
;
a
.
aio_fildes
=
fd
;
a
.
aio_reqprio
=
prio
;
a
.
aio_sigevent
=
SigEvent
:
:
new
(
sigev_notify
)
.
sigevent
(
)
;
AioCb
{
aiocb
:
LibcAiocb
(
a
)
in_progress
:
false
}
}
fn
error
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
{
let
r
=
unsafe
{
libc
:
:
aio_error
(
&
self
.
aiocb
(
)
.
0
)
}
;
match
r
{
0
=
>
Ok
(
(
)
)
num
if
num
>
0
=
>
Err
(
Errno
:
:
from_raw
(
num
)
)
-
1
=
>
Err
(
Errno
:
:
last
(
)
)
num
=
>
panic
!
(
"
unknown
aio_error
return
value
{
num
:
?
}
"
)
}
}
fn
in_progress
(
&
self
)
-
>
bool
{
self
.
in_progress
}
fn
set_in_progress
(
mut
self
:
Pin
<
&
mut
Self
>
)
{
self
.
as_mut
(
)
.
in_progress
=
true
;
}
fn
set_sigev_notify
(
&
mut
self
sigev_notify
:
SigevNotify
)
{
assert
!
(
!
self
.
in_progress
"
Can
'
t
change
notification
settings
for
an
in
-
progress
operation
"
)
;
self
.
aiocb
.
0
.
aio_sigevent
=
SigEvent
:
:
new
(
sigev_notify
)
.
sigevent
(
)
;
}
}
impl
Debug
for
AioCb
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
AioCb
"
)
.
field
(
"
aiocb
"
&
self
.
aiocb
.
0
)
.
field
(
"
in_progress
"
&
self
.
in_progress
)
.
finish
(
)
}
}
impl
Drop
for
AioCb
{
fn
drop
(
&
mut
self
)
{
assert
!
(
thread
:
:
panicking
(
)
|
|
!
self
.
in_progress
"
Dropped
an
in
-
progress
AioCb
"
)
;
}
}
pub
trait
Aio
{
type
Output
;
fn
aio_return
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
Self
:
:
Output
>
;
fn
cancel
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
AioCancelStat
>
;
fn
error
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
;
fn
fd
(
&
self
)
-
>
RawFd
;
fn
in_progress
(
&
self
)
-
>
bool
;
fn
priority
(
&
self
)
-
>
i32
;
fn
set_sigev_notify
(
&
mut
self
sev
:
SigevNotify
)
;
fn
sigevent
(
&
self
)
-
>
SigEvent
;
fn
submit
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
;
}
macro_rules
!
aio_methods
{
(
)
=
>
{
fn
cancel
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
AioCancelStat
>
{
self
.
aiocb
(
)
.
cancel
(
)
}
fn
error
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
{
self
.
aiocb
(
)
.
error
(
)
}
fn
fd
(
&
self
)
-
>
RawFd
{
self
.
aiocb
.
aiocb
.
0
.
aio_fildes
}
fn
in_progress
(
&
self
)
-
>
bool
{
self
.
aiocb
.
in_progress
(
)
}
fn
priority
(
&
self
)
-
>
i32
{
self
.
aiocb
.
aiocb
.
0
.
aio_reqprio
}
fn
set_sigev_notify
(
&
mut
self
sev
:
SigevNotify
)
{
self
.
aiocb
.
set_sigev_notify
(
sev
)
}
fn
sigevent
(
&
self
)
-
>
SigEvent
{
SigEvent
:
:
from
(
&
self
.
aiocb
.
aiocb
.
0
.
aio_sigevent
)
}
}
;
(
func
:
ident
)
=
>
{
aio_methods
!
(
)
;
fn
aio_return
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
<
Self
as
Aio
>
:
:
Output
>
{
self
.
aiocb
(
)
.
aio_return
(
)
}
fn
submit
(
mut
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
{
let
p
:
*
mut
libc
:
:
aiocb
=
&
mut
self
.
as_mut
(
)
.
aiocb
(
)
.
aiocb
.
0
;
Errno
:
:
result
(
{
unsafe
{
libc
:
:
func
(
p
)
}
}
)
.
map
(
|
_
|
{
self
.
aiocb
(
)
.
set_in_progress
(
)
;
}
)
}
}
;
}
#
[
derive
(
Debug
)
]
#
[
repr
(
transparent
)
]
pub
struct
AioFsync
{
aiocb
:
AioCb
_pin
:
PhantomPinned
}
impl
AioFsync
{
unsafe_pinned
!
(
aiocb
:
AioCb
)
;
pub
fn
mode
(
&
self
)
-
>
AioFsyncMode
{
AioFsyncMode
:
:
try_from
(
self
.
aiocb
.
aiocb
.
0
.
aio_lio_opcode
)
.
unwrap
(
)
}
pub
fn
new
(
fd
:
RawFd
mode
:
AioFsyncMode
prio
:
i32
sigev_notify
:
SigevNotify
)
-
>
Self
{
let
mut
aiocb
=
AioCb
:
:
common_init
(
fd
prio
sigev_notify
)
;
aiocb
.
aiocb
.
0
.
aio_lio_opcode
=
mode
as
libc
:
:
c_int
;
AioFsync
{
aiocb
_pin
:
PhantomPinned
}
}
}
impl
Aio
for
AioFsync
{
type
Output
=
(
)
;
aio_methods
!
(
)
;
fn
aio_return
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
{
self
.
aiocb
(
)
.
aio_return
(
)
.
map
(
drop
)
}
fn
submit
(
mut
self
:
Pin
<
&
mut
Self
>
)
-
>
Result
<
(
)
>
{
let
aiocb
=
&
mut
self
.
as_mut
(
)
.
aiocb
(
)
.
aiocb
.
0
;
let
mode
=
mem
:
:
replace
(
&
mut
aiocb
.
aio_lio_opcode
0
)
;
let
p
:
*
mut
libc
:
:
aiocb
=
aiocb
;
Errno
:
:
result
(
unsafe
{
libc
:
:
aio_fsync
(
mode
p
)
}
)
.
map
(
|
_
|
{
self
.
aiocb
(
)
.
set_in_progress
(
)
;
}
)
}
}
impl
AsRef
<
libc
:
:
aiocb
>
for
AioFsync
{
fn
as_ref
(
&
self
)
-
>
&
libc
:
:
aiocb
{
&
self
.
aiocb
.
aiocb
.
0
}
}
#
[
derive
(
Debug
)
]
#
[
repr
(
transparent
)
]
pub
struct
AioRead
<
'
a
>
{
aiocb
:
AioCb
_data
:
PhantomData
<
&
'
a
[
u8
]
>
_pin
:
PhantomPinned
}
impl
<
'
a
>
AioRead
<
'
a
>
{
unsafe_pinned
!
(
aiocb
:
AioCb
)
;
pub
fn
nbytes
(
&
self
)
-
>
usize
{
self
.
aiocb
.
aiocb
.
0
.
aio_nbytes
}
pub
fn
new
(
fd
:
RawFd
offs
:
off_t
buf
:
&
'
a
mut
[
u8
]
prio
:
i32
sigev_notify
:
SigevNotify
)
-
>
Self
{
let
mut
aiocb
=
AioCb
:
:
common_init
(
fd
prio
sigev_notify
)
;
aiocb
.
aiocb
.
0
.
aio_nbytes
=
buf
.
len
(
)
;
aiocb
.
aiocb
.
0
.
aio_buf
=
buf
.
as_mut_ptr
(
)
.
cast
(
)
;
aiocb
.
aiocb
.
0
.
aio_lio_opcode
=
libc
:
:
LIO_READ
;
aiocb
.
aiocb
.
0
.
aio_offset
=
offs
;
AioRead
{
aiocb
_data
:
PhantomData
_pin
:
PhantomPinned
}
}
pub
fn
offset
(
&
self
)
-
>
off_t
{
self
.
aiocb
.
aiocb
.
0
.
aio_offset
}
}
impl
<
'
a
>
Aio
for
AioRead
<
'
a
>
{
type
Output
=
usize
;
aio_methods
!
(
aio_read
)
;
}
impl
<
'
a
>
AsMut
<
libc
:
:
aiocb
>
for
AioRead
<
'
a
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
libc
:
:
aiocb
{
&
mut
self
.
aiocb
.
aiocb
.
0
}
}
impl
<
'
a
>
AsRef
<
libc
:
:
aiocb
>
for
AioRead
<
'
a
>
{
fn
as_ref
(
&
self
)
-
>
&
libc
:
:
aiocb
{
&
self
.
aiocb
.
aiocb
.
0
}
}
#
[
cfg_attr
(
fbsd14
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
fbsd14
)
doc
=
"
no_run
"
)
]
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
#
[
derive
(
Debug
)
]
#
[
repr
(
transparent
)
]
pub
struct
AioReadv
<
'
a
>
{
aiocb
:
AioCb
_data
:
PhantomData
<
&
'
a
[
&
'
a
[
u8
]
]
>
_pin
:
PhantomPinned
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
AioReadv
<
'
a
>
{
unsafe_pinned
!
(
aiocb
:
AioCb
)
;
pub
fn
iovlen
(
&
self
)
-
>
usize
{
self
.
aiocb
.
aiocb
.
0
.
aio_nbytes
}
pub
fn
new
(
fd
:
RawFd
offs
:
off_t
bufs
:
&
mut
[
IoSliceMut
<
'
a
>
]
prio
:
i32
sigev_notify
:
SigevNotify
)
-
>
Self
{
let
mut
aiocb
=
AioCb
:
:
common_init
(
fd
prio
sigev_notify
)
;
aiocb
.
aiocb
.
0
.
aio_nbytes
=
bufs
.
len
(
)
;
aiocb
.
aiocb
.
0
.
aio_buf
=
bufs
.
as_mut_ptr
(
)
.
cast
(
)
;
aiocb
.
aiocb
.
0
.
aio_lio_opcode
=
libc
:
:
LIO_READV
;
aiocb
.
aiocb
.
0
.
aio_offset
=
offs
;
AioReadv
{
aiocb
_data
:
PhantomData
_pin
:
PhantomPinned
}
}
pub
fn
offset
(
&
self
)
-
>
off_t
{
self
.
aiocb
.
aiocb
.
0
.
aio_offset
}
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
Aio
for
AioReadv
<
'
a
>
{
type
Output
=
usize
;
aio_methods
!
(
aio_readv
)
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
AsMut
<
libc
:
:
aiocb
>
for
AioReadv
<
'
a
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
libc
:
:
aiocb
{
&
mut
self
.
aiocb
.
aiocb
.
0
}
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
AsRef
<
libc
:
:
aiocb
>
for
AioReadv
<
'
a
>
{
fn
as_ref
(
&
self
)
-
>
&
libc
:
:
aiocb
{
&
self
.
aiocb
.
aiocb
.
0
}
}
#
[
derive
(
Debug
)
]
#
[
repr
(
transparent
)
]
pub
struct
AioWrite
<
'
a
>
{
aiocb
:
AioCb
_data
:
PhantomData
<
&
'
a
[
u8
]
>
_pin
:
PhantomPinned
}
impl
<
'
a
>
AioWrite
<
'
a
>
{
unsafe_pinned
!
(
aiocb
:
AioCb
)
;
pub
fn
nbytes
(
&
self
)
-
>
usize
{
self
.
aiocb
.
aiocb
.
0
.
aio_nbytes
}
pub
fn
new
(
fd
:
RawFd
offs
:
off_t
buf
:
&
'
a
[
u8
]
prio
:
i32
sigev_notify
:
SigevNotify
)
-
>
Self
{
let
mut
aiocb
=
AioCb
:
:
common_init
(
fd
prio
sigev_notify
)
;
aiocb
.
aiocb
.
0
.
aio_nbytes
=
buf
.
len
(
)
;
aiocb
.
aiocb
.
0
.
aio_buf
=
buf
.
as_ptr
(
)
.
cast_mut
(
)
.
cast
(
)
;
aiocb
.
aiocb
.
0
.
aio_lio_opcode
=
libc
:
:
LIO_WRITE
;
aiocb
.
aiocb
.
0
.
aio_offset
=
offs
;
AioWrite
{
aiocb
_data
:
PhantomData
_pin
:
PhantomPinned
}
}
pub
fn
offset
(
&
self
)
-
>
off_t
{
self
.
aiocb
.
aiocb
.
0
.
aio_offset
}
}
impl
<
'
a
>
Aio
for
AioWrite
<
'
a
>
{
type
Output
=
usize
;
aio_methods
!
(
aio_write
)
;
}
impl
<
'
a
>
AsMut
<
libc
:
:
aiocb
>
for
AioWrite
<
'
a
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
libc
:
:
aiocb
{
&
mut
self
.
aiocb
.
aiocb
.
0
}
}
impl
<
'
a
>
AsRef
<
libc
:
:
aiocb
>
for
AioWrite
<
'
a
>
{
fn
as_ref
(
&
self
)
-
>
&
libc
:
:
aiocb
{
&
self
.
aiocb
.
aiocb
.
0
}
}
#
[
cfg_attr
(
fbsd14
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
fbsd14
)
doc
=
"
no_run
"
)
]
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
#
[
derive
(
Debug
)
]
#
[
repr
(
transparent
)
]
pub
struct
AioWritev
<
'
a
>
{
aiocb
:
AioCb
_data
:
PhantomData
<
&
'
a
[
&
'
a
[
u8
]
]
>
_pin
:
PhantomPinned
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
AioWritev
<
'
a
>
{
unsafe_pinned
!
(
aiocb
:
AioCb
)
;
pub
fn
iovlen
(
&
self
)
-
>
usize
{
self
.
aiocb
.
aiocb
.
0
.
aio_nbytes
}
pub
fn
new
(
fd
:
RawFd
offs
:
off_t
bufs
:
&
[
IoSlice
<
'
a
>
]
prio
:
i32
sigev_notify
:
SigevNotify
)
-
>
Self
{
let
mut
aiocb
=
AioCb
:
:
common_init
(
fd
prio
sigev_notify
)
;
aiocb
.
aiocb
.
0
.
aio_nbytes
=
bufs
.
len
(
)
;
aiocb
.
aiocb
.
0
.
aio_buf
=
bufs
.
as_ptr
(
)
.
cast_mut
(
)
.
cast
(
)
;
aiocb
.
aiocb
.
0
.
aio_lio_opcode
=
libc
:
:
LIO_WRITEV
;
aiocb
.
aiocb
.
0
.
aio_offset
=
offs
;
AioWritev
{
aiocb
_data
:
PhantomData
_pin
:
PhantomPinned
}
}
pub
fn
offset
(
&
self
)
-
>
off_t
{
self
.
aiocb
.
aiocb
.
0
.
aio_offset
}
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
Aio
for
AioWritev
<
'
a
>
{
type
Output
=
usize
;
aio_methods
!
(
aio_writev
)
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
AsMut
<
libc
:
:
aiocb
>
for
AioWritev
<
'
a
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
libc
:
:
aiocb
{
&
mut
self
.
aiocb
.
aiocb
.
0
}
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
impl
<
'
a
>
AsRef
<
libc
:
:
aiocb
>
for
AioWritev
<
'
a
>
{
fn
as_ref
(
&
self
)
-
>
&
libc
:
:
aiocb
{
&
self
.
aiocb
.
aiocb
.
0
}
}
pub
fn
aio_cancel_all
(
fd
:
RawFd
)
-
>
Result
<
AioCancelStat
>
{
match
unsafe
{
libc
:
:
aio_cancel
(
fd
ptr
:
:
null_mut
(
)
)
}
{
libc
:
:
AIO_CANCELED
=
>
Ok
(
AioCancelStat
:
:
AioCanceled
)
libc
:
:
AIO_NOTCANCELED
=
>
Ok
(
AioCancelStat
:
:
AioNotCanceled
)
libc
:
:
AIO_ALLDONE
=
>
Ok
(
AioCancelStat
:
:
AioAllDone
)
-
1
=
>
Err
(
Errno
:
:
last
(
)
)
_
=
>
panic
!
(
"
unknown
aio_cancel
return
value
"
)
}
}
pub
fn
aio_suspend
(
list
:
&
[
&
dyn
AsRef
<
libc
:
:
aiocb
>
]
timeout
:
Option
<
TimeSpec
>
)
-
>
Result
<
(
)
>
{
let
v
=
list
.
iter
(
)
.
map
(
|
x
|
x
.
as_ref
(
)
as
*
const
libc
:
:
aiocb
)
.
collect
:
:
<
Vec
<
*
const
libc
:
:
aiocb
>
>
(
)
;
let
p
=
v
.
as_ptr
(
)
;
let
timep
=
match
timeout
{
None
=
>
ptr
:
:
null
:
:
<
libc
:
:
timespec
>
(
)
Some
(
x
)
=
>
x
.
as_ref
(
)
as
*
const
libc
:
:
timespec
}
;
Errno
:
:
result
(
unsafe
{
libc
:
:
aio_suspend
(
p
list
.
len
(
)
as
i32
timep
)
}
)
.
map
(
drop
)
}
#
[
deprecated
(
since
=
"
0
.
27
.
0
"
note
=
"
https
:
/
/
github
.
com
/
nix
-
rust
/
nix
/
issues
/
2017
"
)
]
pub
fn
lio_listio
(
mode
:
LioMode
list
:
&
mut
[
Pin
<
&
mut
dyn
AsMut
<
libc
:
:
aiocb
>
>
]
sigev_notify
:
SigevNotify
)
-
>
Result
<
(
)
>
{
let
p
=
list
as
*
mut
[
Pin
<
&
mut
dyn
AsMut
<
libc
:
:
aiocb
>
>
]
as
*
mut
[
*
mut
libc
:
:
aiocb
]
as
*
mut
*
mut
libc
:
:
aiocb
;
let
sigev
=
SigEvent
:
:
new
(
sigev_notify
)
;
let
sigevp
=
&
mut
sigev
.
sigevent
(
)
as
*
mut
libc
:
:
sigevent
;
Errno
:
:
result
(
unsafe
{
libc
:
:
lio_listio
(
mode
as
i32
p
list
.
len
(
)
as
i32
sigevp
)
}
)
.
map
(
drop
)
}
