use
crate
:
:
sys
:
:
time
:
:
timer
:
:
TimerSpec
;
pub
use
crate
:
:
sys
:
:
time
:
:
timer
:
:
{
Expiration
TimerSetTimeFlags
}
;
use
crate
:
:
unistd
:
:
read
;
use
crate
:
:
{
errno
:
:
Errno
Result
}
;
use
libc
:
:
c_int
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
FromRawFd
RawFd
}
;
#
[
derive
(
Debug
)
]
pub
struct
TimerFd
{
fd
:
RawFd
}
impl
AsRawFd
for
TimerFd
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
fd
}
}
impl
FromRawFd
for
TimerFd
{
unsafe
fn
from_raw_fd
(
fd
:
RawFd
)
-
>
Self
{
TimerFd
{
fd
}
}
}
libc_enum
!
{
/
/
/
The
type
of
the
clock
used
to
mark
the
progress
of
the
timer
.
For
more
/
/
/
details
on
each
kind
of
clock
please
refer
to
[
timerfd_create
(
2
)
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man2
/
timerfd_create
.
2
.
html
)
.
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
ClockId
{
/
/
/
A
settable
system
-
wide
real
-
time
clock
.
CLOCK_REALTIME
/
/
/
A
non
-
settable
monotonically
increasing
clock
.
/
/
/
/
/
/
Does
not
change
after
system
startup
.
/
/
/
Does
not
measure
time
while
the
system
is
suspended
.
CLOCK_MONOTONIC
/
/
/
Like
CLOCK_MONOTONIC
except
that
CLOCK_BOOTTIME
includes
the
time
/
/
/
that
the
system
was
suspended
.
CLOCK_BOOTTIME
/
/
/
Like
CLOCK_REALTIME
but
will
wake
the
system
if
it
is
suspended
.
CLOCK_REALTIME_ALARM
/
/
/
Like
CLOCK_BOOTTIME
but
will
wake
the
system
if
it
is
suspended
.
CLOCK_BOOTTIME_ALARM
}
}
libc_bitflags
!
{
/
/
/
Additional
flags
to
change
the
behaviour
of
the
file
descriptor
at
the
/
/
/
time
of
creation
.
pub
struct
TimerFlags
:
c_int
{
/
/
/
Set
the
O_NONBLOCK
flag
on
the
open
file
description
referred
to
by
the
new
file
descriptor
.
TFD_NONBLOCK
;
/
/
/
Set
the
FD_CLOEXEC
flag
on
the
file
descriptor
.
TFD_CLOEXEC
;
}
}
impl
TimerFd
{
#
[
doc
(
alias
(
"
timerfd_create
"
)
)
]
pub
fn
new
(
clockid
:
ClockId
flags
:
TimerFlags
)
-
>
Result
<
Self
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_create
(
clockid
as
i32
flags
.
bits
(
)
)
}
)
.
map
(
|
fd
|
Self
{
fd
}
)
}
#
[
doc
(
alias
(
"
timerfd_settime
"
)
)
]
pub
fn
set
(
&
self
expiration
:
Expiration
flags
:
TimerSetTimeFlags
)
-
>
Result
<
(
)
>
{
let
timerspec
:
TimerSpec
=
expiration
.
into
(
)
;
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_settime
(
self
.
fd
flags
.
bits
(
)
timerspec
.
as_ref
(
)
std
:
:
ptr
:
:
null_mut
(
)
)
}
)
.
map
(
drop
)
}
#
[
doc
(
alias
(
"
timerfd_gettime
"
)
)
]
pub
fn
get
(
&
self
)
-
>
Result
<
Option
<
Expiration
>
>
{
let
mut
timerspec
=
TimerSpec
:
:
none
(
)
;
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_gettime
(
self
.
fd
timerspec
.
as_mut
(
)
)
}
)
.
map
(
|
_
|
{
if
timerspec
.
as_ref
(
)
.
it_interval
.
tv_sec
=
=
0
&
&
timerspec
.
as_ref
(
)
.
it_interval
.
tv_nsec
=
=
0
&
&
timerspec
.
as_ref
(
)
.
it_value
.
tv_sec
=
=
0
&
&
timerspec
.
as_ref
(
)
.
it_value
.
tv_nsec
=
=
0
{
None
}
else
{
Some
(
timerspec
.
into
(
)
)
}
}
)
}
#
[
doc
(
alias
(
"
timerfd_settime
"
)
)
]
pub
fn
unset
(
&
self
)
-
>
Result
<
(
)
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_settime
(
self
.
fd
TimerSetTimeFlags
:
:
empty
(
)
.
bits
(
)
TimerSpec
:
:
none
(
)
.
as_ref
(
)
std
:
:
ptr
:
:
null_mut
(
)
)
}
)
.
map
(
drop
)
}
pub
fn
wait
(
&
self
)
-
>
Result
<
(
)
>
{
while
let
Err
(
e
)
=
read
(
self
.
fd
&
mut
[
0u8
;
8
]
)
{
if
e
!
=
Errno
:
:
EINTR
{
return
Err
(
e
)
;
}
}
Ok
(
(
)
)
}
}
impl
Drop
for
TimerFd
{
fn
drop
(
&
mut
self
)
{
if
!
std
:
:
thread
:
:
panicking
(
)
{
let
result
=
Errno
:
:
result
(
unsafe
{
libc
:
:
close
(
self
.
fd
)
}
)
;
if
let
Err
(
Errno
:
:
EBADF
)
=
result
{
panic
!
(
"
close
of
TimerFd
encountered
EBADF
"
)
;
}
}
}
}
