use
crate
:
:
sys
:
:
time
:
:
timer
:
:
TimerSpec
;
pub
use
crate
:
:
sys
:
:
time
:
:
timer
:
:
{
Expiration
TimerSetTimeFlags
}
;
use
crate
:
:
unistd
:
:
read
;
use
crate
:
:
{
errno
:
:
Errno
Result
}
;
use
libc
:
:
c_int
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsFd
AsRawFd
BorrowedFd
FromRawFd
OwnedFd
RawFd
}
;
#
[
derive
(
Debug
)
]
pub
struct
TimerFd
{
fd
:
OwnedFd
}
impl
AsFd
for
TimerFd
{
fn
as_fd
(
&
self
)
-
>
BorrowedFd
<
'
_
>
{
self
.
fd
.
as_fd
(
)
}
}
impl
FromRawFd
for
TimerFd
{
unsafe
fn
from_raw_fd
(
fd
:
RawFd
)
-
>
Self
{
TimerFd
{
fd
:
unsafe
{
OwnedFd
:
:
from_raw_fd
(
fd
)
}
}
}
}
libc_enum
!
{
/
/
/
The
type
of
the
clock
used
to
mark
the
progress
of
the
timer
.
For
more
/
/
/
details
on
each
kind
of
clock
please
refer
to
[
timerfd_create
(
2
)
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man2
/
timerfd_create
.
2
.
html
)
.
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
ClockId
{
/
/
/
A
settable
system
-
wide
real
-
time
clock
.
CLOCK_REALTIME
/
/
/
A
non
-
settable
monotonically
increasing
clock
.
/
/
/
/
/
/
Does
not
change
after
system
startup
.
/
/
/
Does
not
measure
time
while
the
system
is
suspended
.
CLOCK_MONOTONIC
/
/
/
Like
CLOCK_MONOTONIC
except
that
CLOCK_BOOTTIME
includes
the
time
/
/
/
that
the
system
was
suspended
.
CLOCK_BOOTTIME
/
/
/
Like
CLOCK_REALTIME
but
will
wake
the
system
if
it
is
suspended
.
CLOCK_REALTIME_ALARM
/
/
/
Like
CLOCK_BOOTTIME
but
will
wake
the
system
if
it
is
suspended
.
CLOCK_BOOTTIME_ALARM
}
}
libc_bitflags
!
{
/
/
/
Additional
flags
to
change
the
behaviour
of
the
file
descriptor
at
the
/
/
/
time
of
creation
.
pub
struct
TimerFlags
:
c_int
{
/
/
/
Set
the
O_NONBLOCK
flag
on
the
open
file
description
referred
to
by
the
new
file
descriptor
.
TFD_NONBLOCK
;
/
/
/
Set
the
FD_CLOEXEC
flag
on
the
file
descriptor
.
TFD_CLOEXEC
;
}
}
impl
TimerFd
{
#
[
doc
(
alias
(
"
timerfd_create
"
)
)
]
pub
fn
new
(
clockid
:
ClockId
flags
:
TimerFlags
)
-
>
Result
<
Self
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_create
(
clockid
as
i32
flags
.
bits
(
)
)
}
)
.
map
(
|
fd
|
Self
{
fd
:
unsafe
{
OwnedFd
:
:
from_raw_fd
(
fd
)
}
}
)
}
#
[
doc
(
alias
(
"
timerfd_settime
"
)
)
]
pub
fn
set
(
&
self
expiration
:
Expiration
flags
:
TimerSetTimeFlags
)
-
>
Result
<
(
)
>
{
let
timerspec
:
TimerSpec
=
expiration
.
into
(
)
;
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_settime
(
self
.
fd
.
as_fd
(
)
.
as_raw_fd
(
)
flags
.
bits
(
)
timerspec
.
as_ref
(
)
std
:
:
ptr
:
:
null_mut
(
)
)
}
)
.
map
(
drop
)
}
#
[
doc
(
alias
(
"
timerfd_gettime
"
)
)
]
pub
fn
get
(
&
self
)
-
>
Result
<
Option
<
Expiration
>
>
{
let
mut
timerspec
=
TimerSpec
:
:
none
(
)
;
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_gettime
(
self
.
fd
.
as_fd
(
)
.
as_raw_fd
(
)
timerspec
.
as_mut
(
)
)
}
)
.
map
(
|
_
|
{
if
timerspec
.
as_ref
(
)
.
it_interval
.
tv_sec
=
=
0
&
&
timerspec
.
as_ref
(
)
.
it_interval
.
tv_nsec
=
=
0
&
&
timerspec
.
as_ref
(
)
.
it_value
.
tv_sec
=
=
0
&
&
timerspec
.
as_ref
(
)
.
it_value
.
tv_nsec
=
=
0
{
None
}
else
{
Some
(
timerspec
.
into
(
)
)
}
}
)
}
#
[
doc
(
alias
(
"
timerfd_settime
"
)
)
]
pub
fn
unset
(
&
self
)
-
>
Result
<
(
)
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
timerfd_settime
(
self
.
fd
.
as_fd
(
)
.
as_raw_fd
(
)
TimerSetTimeFlags
:
:
empty
(
)
.
bits
(
)
TimerSpec
:
:
none
(
)
.
as_ref
(
)
std
:
:
ptr
:
:
null_mut
(
)
)
}
)
.
map
(
drop
)
}
pub
fn
wait
(
&
self
)
-
>
Result
<
(
)
>
{
while
let
Err
(
e
)
=
read
(
self
.
fd
.
as_fd
(
)
.
as_raw_fd
(
)
&
mut
[
0u8
;
8
]
)
{
if
e
=
=
Errno
:
:
ECANCELED
{
break
;
}
if
e
!
=
Errno
:
:
EINTR
{
return
Err
(
e
)
;
}
}
Ok
(
(
)
)
}
}
