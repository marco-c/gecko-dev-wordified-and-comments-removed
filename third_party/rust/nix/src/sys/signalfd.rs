use
crate
:
:
unistd
;
use
crate
:
:
Result
;
use
crate
:
:
errno
:
:
Errno
;
pub
use
crate
:
:
sys
:
:
signal
:
:
{
self
SigSet
}
;
pub
use
libc
:
:
signalfd_siginfo
as
siginfo
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
RawFd
AsRawFd
}
;
use
std
:
:
mem
;
libc_bitflags
!
{
pub
struct
SfdFlags
:
libc
:
:
c_int
{
SFD_NONBLOCK
;
SFD_CLOEXEC
;
}
}
pub
const
SIGNALFD_NEW
:
RawFd
=
-
1
;
#
[
deprecated
(
since
=
"
0
.
23
.
0
"
note
=
"
use
mem
:
:
size_of
:
:
<
siginfo
>
(
)
instead
"
)
]
pub
const
SIGNALFD_SIGINFO_SIZE
:
usize
=
mem
:
:
size_of
:
:
<
siginfo
>
(
)
;
pub
fn
signalfd
(
fd
:
RawFd
mask
:
&
SigSet
flags
:
SfdFlags
)
-
>
Result
<
RawFd
>
{
unsafe
{
Errno
:
:
result
(
libc
:
:
signalfd
(
fd
as
libc
:
:
c_int
mask
.
as_ref
(
)
flags
.
bits
(
)
)
)
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
SignalFd
(
RawFd
)
;
impl
SignalFd
{
pub
fn
new
(
mask
:
&
SigSet
)
-
>
Result
<
SignalFd
>
{
Self
:
:
with_flags
(
mask
SfdFlags
:
:
empty
(
)
)
}
pub
fn
with_flags
(
mask
:
&
SigSet
flags
:
SfdFlags
)
-
>
Result
<
SignalFd
>
{
let
fd
=
signalfd
(
SIGNALFD_NEW
mask
flags
)
?
;
Ok
(
SignalFd
(
fd
)
)
}
pub
fn
set_mask
(
&
mut
self
mask
:
&
SigSet
)
-
>
Result
<
(
)
>
{
signalfd
(
self
.
0
mask
SfdFlags
:
:
empty
(
)
)
.
map
(
drop
)
}
pub
fn
read_signal
(
&
mut
self
)
-
>
Result
<
Option
<
siginfo
>
>
{
let
mut
buffer
=
mem
:
:
MaybeUninit
:
:
<
siginfo
>
:
:
uninit
(
)
;
let
size
=
mem
:
:
size_of_val
(
&
buffer
)
;
let
res
=
Errno
:
:
result
(
unsafe
{
libc
:
:
read
(
self
.
0
buffer
.
as_mut_ptr
(
)
as
*
mut
libc
:
:
c_void
size
)
}
)
.
map
(
|
r
|
r
as
usize
)
;
match
res
{
Ok
(
x
)
if
x
=
=
size
=
>
Ok
(
Some
(
unsafe
{
buffer
.
assume_init
(
)
}
)
)
Ok
(
_
)
=
>
unreachable
!
(
"
partial
read
on
signalfd
"
)
Err
(
Errno
:
:
EAGAIN
)
=
>
Ok
(
None
)
Err
(
error
)
=
>
Err
(
error
)
}
}
}
impl
Drop
for
SignalFd
{
fn
drop
(
&
mut
self
)
{
let
e
=
unistd
:
:
close
(
self
.
0
)
;
if
!
std
:
:
thread
:
:
panicking
(
)
&
&
e
=
=
Err
(
Errno
:
:
EBADF
)
{
panic
!
(
"
Closing
an
invalid
file
descriptor
!
"
)
;
}
;
}
}
impl
AsRawFd
for
SignalFd
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
0
}
}
impl
Iterator
for
SignalFd
{
type
Item
=
siginfo
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
match
self
.
read_signal
(
)
{
Ok
(
Some
(
sig
)
)
=
>
Some
(
sig
)
Ok
(
None
)
|
Err
(
_
)
=
>
None
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
create_signalfd
(
)
{
let
mask
=
SigSet
:
:
empty
(
)
;
SignalFd
:
:
new
(
&
mask
)
.
unwrap
(
)
;
}
#
[
test
]
fn
create_signalfd_with_opts
(
)
{
let
mask
=
SigSet
:
:
empty
(
)
;
SignalFd
:
:
with_flags
(
&
mask
SfdFlags
:
:
SFD_CLOEXEC
|
SfdFlags
:
:
SFD_NONBLOCK
)
.
unwrap
(
)
;
}
#
[
test
]
fn
read_empty_signalfd
(
)
{
let
mask
=
SigSet
:
:
empty
(
)
;
let
mut
fd
=
SignalFd
:
:
with_flags
(
&
mask
SfdFlags
:
:
SFD_NONBLOCK
)
.
unwrap
(
)
;
let
res
=
fd
.
read_signal
(
)
;
assert
!
(
res
.
unwrap
(
)
.
is_none
(
)
)
;
}
}
