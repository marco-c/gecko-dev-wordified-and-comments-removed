use
crate
:
:
errno
:
:
Errno
;
use
crate
:
:
sys
:
:
signal
:
:
Signal
;
use
crate
:
:
unistd
:
:
Pid
;
use
crate
:
:
Result
;
use
cfg_if
:
:
cfg_if
;
use
libc
:
:
{
self
c_int
}
;
use
std
:
:
ptr
;
pub
type
RequestType
=
c_int
;
cfg_if
!
{
if
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
macos
"
target_os
=
"
openbsd
"
)
)
]
{
#
[
doc
(
hidden
)
]
pub
type
AddressType
=
*
mut
:
:
libc
:
:
c_char
;
}
else
{
#
[
doc
(
hidden
)
]
pub
type
AddressType
=
*
mut
:
:
libc
:
:
c_void
;
}
}
libc_enum
!
{
#
[
repr
(
i32
)
]
/
/
/
Ptrace
Request
enum
defining
the
action
to
be
taken
.
#
[
non_exhaustive
]
pub
enum
Request
{
PT_TRACE_ME
PT_READ_I
PT_READ_D
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
PT_READ_U
PT_WRITE_I
PT_WRITE_D
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
PT_WRITE_U
PT_CONTINUE
PT_KILL
#
[
cfg
(
any
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
macos
"
)
all
(
target_os
=
"
openbsd
"
target_arch
=
"
x86_64
"
)
all
(
target_os
=
"
netbsd
"
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
powerpc
"
)
)
)
)
]
PT_STEP
PT_ATTACH
PT_DETACH
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
PT_SIGEXC
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
PT_THUPDATE
#
[
cfg
(
target_os
=
"
macos
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
PT_ATTACHEXC
}
}
unsafe
fn
ptrace_other
(
request
:
Request
pid
:
Pid
addr
:
AddressType
data
:
c_int
)
-
>
Result
<
c_int
>
{
Errno
:
:
result
(
libc
:
:
ptrace
(
request
as
RequestType
libc
:
:
pid_t
:
:
from
(
pid
)
addr
data
)
)
.
map
(
|
_
|
0
)
}
pub
fn
traceme
(
)
-
>
Result
<
(
)
>
{
unsafe
{
ptrace_other
(
Request
:
:
PT_TRACE_ME
Pid
:
:
from_raw
(
0
)
ptr
:
:
null_mut
(
)
0
)
.
map
(
drop
)
}
}
pub
fn
attach
(
pid
:
Pid
)
-
>
Result
<
(
)
>
{
unsafe
{
ptrace_other
(
Request
:
:
PT_ATTACH
pid
ptr
:
:
null_mut
(
)
0
)
.
map
(
drop
)
}
}
pub
fn
detach
<
T
:
Into
<
Option
<
Signal
>
>
>
(
pid
:
Pid
sig
:
T
)
-
>
Result
<
(
)
>
{
let
data
=
match
sig
.
into
(
)
{
Some
(
s
)
=
>
s
as
c_int
None
=
>
0
}
;
unsafe
{
ptrace_other
(
Request
:
:
PT_DETACH
pid
ptr
:
:
null_mut
(
)
data
)
.
map
(
drop
)
}
}
pub
fn
cont
<
T
:
Into
<
Option
<
Signal
>
>
>
(
pid
:
Pid
sig
:
T
)
-
>
Result
<
(
)
>
{
let
data
=
match
sig
.
into
(
)
{
Some
(
s
)
=
>
s
as
c_int
None
=
>
0
}
;
unsafe
{
ptrace_other
(
Request
:
:
PT_CONTINUE
pid
1
as
AddressType
data
)
.
map
(
drop
)
}
}
pub
fn
kill
(
pid
:
Pid
)
-
>
Result
<
(
)
>
{
unsafe
{
ptrace_other
(
Request
:
:
PT_KILL
pid
0
as
AddressType
0
)
.
map
(
drop
)
}
}
#
[
cfg
(
any
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
macos
"
)
all
(
target_os
=
"
openbsd
"
target_arch
=
"
x86_64
"
)
all
(
target_os
=
"
netbsd
"
any
(
target_arch
=
"
x86_64
"
target_arch
=
"
powerpc
"
)
)
)
)
]
pub
fn
step
<
T
:
Into
<
Option
<
Signal
>
>
>
(
pid
:
Pid
sig
:
T
)
-
>
Result
<
(
)
>
{
let
data
=
match
sig
.
into
(
)
{
Some
(
s
)
=
>
s
as
c_int
None
=
>
0
}
;
unsafe
{
ptrace_other
(
Request
:
:
PT_STEP
pid
ptr
:
:
null_mut
(
)
data
)
.
map
(
drop
)
}
}
#
[
allow
(
clippy
:
:
not_unsafe_ptr_arg_deref
)
]
pub
fn
read
(
pid
:
Pid
addr
:
AddressType
)
-
>
Result
<
c_int
>
{
unsafe
{
ptrace_other
(
Request
:
:
PT_READ_D
pid
addr
0
)
}
}
#
[
allow
(
clippy
:
:
not_unsafe_ptr_arg_deref
)
]
pub
fn
write
(
pid
:
Pid
addr
:
AddressType
data
:
c_int
)
-
>
Result
<
(
)
>
{
unsafe
{
ptrace_other
(
Request
:
:
PT_WRITE_D
pid
addr
data
)
.
map
(
drop
)
}
}
