use
cfg_if
:
:
cfg_if
;
use
libc
:
:
{
c_int
c_long
rusage
}
;
use
crate
:
:
errno
:
:
Errno
;
use
crate
:
:
sys
:
:
time
:
:
TimeVal
;
use
crate
:
:
Result
;
pub
use
libc
:
:
rlim_t
;
pub
use
libc
:
:
RLIM_INFINITY
;
use
std
:
:
mem
;
cfg_if
!
{
if
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
any
(
target_env
=
"
gnu
"
target_env
=
"
uclibc
"
)
)
target_os
=
"
hurd
"
)
)
]
{
use
libc
:
:
{
__rlimit_resource_t
rlimit
}
;
}
else
if
#
[
cfg
(
any
(
bsd
target_os
=
"
android
"
target_os
=
"
aix
"
all
(
target_os
=
"
linux
"
not
(
target_env
=
"
gnu
"
)
)
target_os
=
"
cygwin
"
)
)
]
{
use
libc
:
:
rlimit
;
}
}
libc_enum
!
{
/
/
/
Types
of
process
resources
.
/
/
/
/
/
/
The
Resource
enum
is
platform
dependent
.
Check
different
platform
/
/
/
manuals
for
more
details
.
Some
platform
links
have
been
provided
for
/
/
/
easier
reference
(
non
-
exhaustive
)
.
/
/
/
/
/
/
*
[
Linux
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man2
/
getrlimit
.
2
.
html
)
/
/
/
*
[
FreeBSD
]
(
https
:
/
/
www
.
freebsd
.
org
/
cgi
/
man
.
cgi
?
query
=
setrlimit
)
/
/
/
*
[
NetBSD
]
(
https
:
/
/
man
.
netbsd
.
org
/
setrlimit
.
2
)
/
/
linux
-
gnu
uses
u_int
as
resource
enum
which
is
implemented
in
libc
as
/
/
well
.
/
/
/
/
https
:
/
/
gcc
.
gnu
.
org
/
legacy
-
ml
/
gcc
/
2015
-
08
/
msg00441
.
html
/
/
https
:
/
/
github
.
com
/
rust
-
lang
/
libc
/
blob
/
master
/
src
/
unix
/
linux_like
/
linux
/
gnu
/
mod
.
rs
#
[
cfg_attr
(
any
(
all
(
target_os
=
"
linux
"
any
(
target_env
=
"
gnu
"
target_env
=
"
uclibc
"
)
)
target_os
=
"
hurd
"
)
repr
(
u32
)
)
]
#
[
cfg_attr
(
any
(
bsd
target_os
=
"
android
"
target_os
=
"
aix
"
all
(
target_os
=
"
linux
"
not
(
any
(
target_env
=
"
gnu
"
target_env
=
"
uclibc
"
)
)
)
target_os
=
"
cygwin
"
)
repr
(
i32
)
)
]
#
[
non_exhaustive
]
pub
enum
Resource
{
#
[
cfg
(
not
(
any
(
target_os
=
"
freebsd
"
netbsdlike
)
)
)
]
/
/
/
The
maximum
amount
(
in
bytes
)
of
virtual
memory
the
process
is
/
/
/
allowed
to
map
.
RLIMIT_AS
/
/
/
The
largest
size
(
in
bytes
)
core
(
5
)
file
that
may
be
created
.
RLIMIT_CORE
/
/
/
The
maximum
amount
of
cpu
time
(
in
seconds
)
to
be
used
by
each
/
/
/
process
.
RLIMIT_CPU
/
/
/
The
maximum
size
(
in
bytes
)
of
the
data
segment
for
a
process
RLIMIT_DATA
/
/
/
The
largest
size
(
in
bytes
)
file
that
may
be
created
.
RLIMIT_FSIZE
/
/
/
The
maximum
number
of
open
files
for
this
process
.
RLIMIT_NOFILE
/
/
/
The
maximum
size
(
in
bytes
)
of
the
stack
segment
for
a
process
.
RLIMIT_STACK
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
/
/
/
The
maximum
number
of
kqueues
this
user
id
is
allowed
to
create
.
RLIMIT_KQUEUES
#
[
cfg
(
linux_android
)
]
/
/
/
A
limit
on
the
combined
number
of
flock
locks
and
fcntl
leases
that
/
/
/
this
process
may
establish
.
RLIMIT_LOCKS
#
[
cfg
(
any
(
linux_android
target_os
=
"
freebsd
"
netbsdlike
)
)
]
/
/
/
The
maximum
size
(
in
bytes
)
which
a
process
may
lock
into
memory
/
/
/
using
the
mlock
(
2
)
system
call
.
RLIMIT_MEMLOCK
#
[
cfg
(
linux_android
)
]
/
/
/
A
limit
on
the
number
of
bytes
that
can
be
allocated
for
POSIX
/
/
/
message
queues
for
the
real
user
ID
of
the
calling
process
.
RLIMIT_MSGQUEUE
#
[
cfg
(
linux_android
)
]
/
/
/
A
ceiling
to
which
the
process
'
s
nice
value
can
be
raised
using
/
/
/
setpriority
or
nice
.
RLIMIT_NICE
#
[
cfg
(
any
(
linux_android
target_os
=
"
freebsd
"
netbsdlike
target_os
=
"
aix
"
)
)
]
/
/
/
The
maximum
number
of
simultaneous
processes
for
this
user
id
.
RLIMIT_NPROC
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
/
/
/
The
maximum
number
of
pseudo
-
terminals
this
user
id
is
allowed
to
/
/
/
create
.
RLIMIT_NPTS
#
[
cfg
(
any
(
linux_android
target_os
=
"
freebsd
"
netbsdlike
target_os
=
"
aix
"
)
)
]
/
/
/
When
there
is
memory
pressure
and
swap
is
available
prioritize
/
/
/
eviction
of
a
process
'
resident
pages
beyond
this
amount
(
in
bytes
)
.
RLIMIT_RSS
#
[
cfg
(
linux_android
)
]
/
/
/
A
ceiling
on
the
real
-
time
priority
that
may
be
set
for
this
process
/
/
/
using
sched_setscheduler
and
sched_set
param
.
RLIMIT_RTPRIO
#
[
cfg
(
any
(
target_os
=
"
linux
"
)
)
]
/
/
/
A
limit
(
in
microseconds
)
on
the
amount
of
CPU
time
that
a
process
/
/
/
scheduled
under
a
real
-
time
scheduling
policy
may
con
sume
without
/
/
/
making
a
blocking
system
call
.
RLIMIT_RTTIME
#
[
cfg
(
linux_android
)
]
/
/
/
A
limit
on
the
number
of
signals
that
may
be
queued
for
the
real
/
/
/
user
ID
of
the
calling
process
.
RLIMIT_SIGPENDING
#
[
cfg
(
freebsdlike
)
]
/
/
/
The
maximum
size
(
in
bytes
)
of
socket
buffer
usage
for
this
user
.
RLIMIT_SBSIZE
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
/
/
/
The
maximum
size
(
in
bytes
)
of
the
swap
space
that
may
be
reserved
/
/
/
or
used
by
all
of
this
user
id
'
s
processes
.
RLIMIT_SWAP
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
/
/
/
An
alias
for
RLIMIT_AS
.
RLIMIT_VMEM
}
}
pub
fn
getrlimit
(
resource
:
Resource
)
-
>
Result
<
(
rlim_t
rlim_t
)
>
{
let
mut
old_rlim
=
mem
:
:
MaybeUninit
:
:
<
rlimit
>
:
:
uninit
(
)
;
cfg_if
!
{
if
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
any
(
target_env
=
"
gnu
"
target_env
=
"
uclibc
"
)
)
target_os
=
"
hurd
"
)
)
]
{
let
res
=
unsafe
{
libc
:
:
getrlimit
(
resource
as
__rlimit_resource_t
old_rlim
.
as_mut_ptr
(
)
)
}
;
}
else
{
let
res
=
unsafe
{
libc
:
:
getrlimit
(
resource
as
c_int
old_rlim
.
as_mut_ptr
(
)
)
}
;
}
}
Errno
:
:
result
(
res
)
.
map
(
|
_
|
{
let
rlimit
{
rlim_cur
rlim_max
}
=
unsafe
{
old_rlim
.
assume_init
(
)
}
;
(
rlim_cur
rlim_max
)
}
)
}
pub
fn
setrlimit
(
resource
:
Resource
soft_limit
:
rlim_t
hard_limit
:
rlim_t
)
-
>
Result
<
(
)
>
{
let
new_rlim
=
rlimit
{
rlim_cur
:
soft_limit
rlim_max
:
hard_limit
}
;
cfg_if
!
{
if
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
any
(
target_env
=
"
gnu
"
target_env
=
"
uclibc
"
)
)
target_os
=
"
hurd
"
)
)
]
{
let
res
=
unsafe
{
libc
:
:
setrlimit
(
resource
as
__rlimit_resource_t
&
new_rlim
as
*
const
rlimit
)
}
;
}
else
{
let
res
=
unsafe
{
libc
:
:
setrlimit
(
resource
as
c_int
&
new_rlim
as
*
const
rlimit
)
}
;
}
}
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
libc_enum
!
{
/
/
/
Whose
resource
usage
should
be
returned
by
[
getrusage
]
.
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
UsageWho
{
/
/
/
Resource
usage
for
the
current
process
.
RUSAGE_SELF
/
/
/
Resource
usage
for
all
the
children
that
have
terminated
and
been
waited
for
.
RUSAGE_CHILDREN
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
freebsd
"
target_os
=
"
openbsd
"
)
)
]
/
/
/
Resource
usage
for
the
calling
thread
.
RUSAGE_THREAD
}
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Usage
(
rusage
)
;
impl
AsRef
<
rusage
>
for
Usage
{
fn
as_ref
(
&
self
)
-
>
&
rusage
{
&
self
.
0
}
}
impl
AsMut
<
rusage
>
for
Usage
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
rusage
{
&
mut
self
.
0
}
}
impl
Usage
{
pub
fn
user_time
(
&
self
)
-
>
TimeVal
{
TimeVal
:
:
from
(
self
.
0
.
ru_utime
)
}
pub
fn
system_time
(
&
self
)
-
>
TimeVal
{
TimeVal
:
:
from
(
self
.
0
.
ru_stime
)
}
#
[
cfg_attr
(
apple_targets
doc
=
"
in
bytes
.
"
)
]
#
[
cfg_attr
(
not
(
apple_targets
)
doc
=
"
in
kilobytes
.
"
)
]
pub
fn
max_rss
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_maxrss
}
pub
fn
shared_integral
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_ixrss
}
pub
fn
unshared_data_integral
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_idrss
}
pub
fn
unshared_stack_integral
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_isrss
}
pub
fn
minor_page_faults
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_minflt
}
pub
fn
major_page_faults
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_majflt
}
pub
fn
full_swaps
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_nswap
}
pub
fn
block_reads
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_inblock
}
pub
fn
block_writes
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_oublock
}
pub
fn
ipc_sends
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_msgsnd
}
pub
fn
ipc_receives
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_msgrcv
}
pub
fn
signals
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_nsignals
}
pub
fn
voluntary_context_switches
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_nvcsw
}
pub
fn
involuntary_context_switches
(
&
self
)
-
>
c_long
{
self
.
0
.
ru_nivcsw
}
}
pub
fn
getrusage
(
who
:
UsageWho
)
-
>
Result
<
Usage
>
{
unsafe
{
let
mut
rusage
=
mem
:
:
MaybeUninit
:
:
<
rusage
>
:
:
uninit
(
)
;
let
res
=
libc
:
:
getrusage
(
who
as
c_int
rusage
.
as_mut_ptr
(
)
)
;
Errno
:
:
result
(
res
)
.
map
(
|
_
|
Usage
(
rusage
.
assume_init
(
)
)
)
}
}
