#
!
[
cfg_attr
(
bsd
doc
=
"
rust
ignore
"
)
]
#
!
[
cfg_attr
(
not
(
bsd
)
doc
=
"
rust
"
)
]
#
!
[
cfg_attr
(
bsd
doc
=
"
rust
"
)
]
#
!
[
cfg_attr
(
not
(
bsd
)
doc
=
"
rust
ignore
"
)
]
#
!
[
cfg_attr
(
bsd
doc
=
"
rust
"
)
]
#
!
[
cfg_attr
(
not
(
bsd
)
doc
=
"
rust
ignore
"
)
]
#
!
[
cfg_attr
(
bsd
doc
=
"
rust
"
)
]
#
!
[
cfg_attr
(
not
(
bsd
)
doc
=
"
rust
ignore
"
)
]
use
crate
:
:
errno
:
:
Errno
;
use
crate
:
:
Result
;
use
cfg_if
:
:
cfg_if
;
use
libc
:
:
{
self
c_int
tcflag_t
}
;
use
std
:
:
cell
:
:
{
Ref
RefCell
}
;
use
std
:
:
convert
:
:
From
;
use
std
:
:
mem
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsFd
AsRawFd
}
;
#
[
cfg
(
feature
=
"
process
"
)
]
use
crate
:
:
unistd
:
:
Pid
;
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
struct
Termios
{
inner
:
RefCell
<
libc
:
:
termios
>
pub
input_flags
:
InputFlags
pub
output_flags
:
OutputFlags
pub
control_flags
:
ControlFlags
pub
local_flags
:
LocalFlags
pub
control_chars
:
[
libc
:
:
cc_t
;
NCCS
]
#
[
cfg
(
linux_android
)
]
pub
line_discipline
:
libc
:
:
cc_t
#
[
cfg
(
target_os
=
"
haiku
"
)
]
pub
line_discipline
:
libc
:
:
c_char
}
impl
Termios
{
pub
(
crate
)
fn
get_libc_termios
(
&
self
)
-
>
Ref
<
libc
:
:
termios
>
{
{
let
mut
termios
=
self
.
inner
.
borrow_mut
(
)
;
termios
.
c_iflag
=
self
.
input_flags
.
bits
(
)
;
termios
.
c_oflag
=
self
.
output_flags
.
bits
(
)
;
termios
.
c_cflag
=
self
.
control_flags
.
bits
(
)
;
termios
.
c_lflag
=
self
.
local_flags
.
bits
(
)
;
termios
.
c_cc
=
self
.
control_chars
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
)
)
]
{
termios
.
c_line
=
self
.
line_discipline
;
}
}
self
.
inner
.
borrow
(
)
}
pub
(
crate
)
unsafe
fn
get_libc_termios_mut
(
&
mut
self
)
-
>
*
mut
libc
:
:
termios
{
{
let
mut
termios
=
self
.
inner
.
borrow_mut
(
)
;
termios
.
c_iflag
=
self
.
input_flags
.
bits
(
)
;
termios
.
c_oflag
=
self
.
output_flags
.
bits
(
)
;
termios
.
c_cflag
=
self
.
control_flags
.
bits
(
)
;
termios
.
c_lflag
=
self
.
local_flags
.
bits
(
)
;
termios
.
c_cc
=
self
.
control_chars
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
)
)
]
{
termios
.
c_line
=
self
.
line_discipline
;
}
}
self
.
inner
.
as_ptr
(
)
}
pub
(
crate
)
fn
update_wrapper
(
&
mut
self
)
{
let
termios
=
*
self
.
inner
.
borrow_mut
(
)
;
self
.
input_flags
=
InputFlags
:
:
from_bits_truncate
(
termios
.
c_iflag
)
;
self
.
output_flags
=
OutputFlags
:
:
from_bits_truncate
(
termios
.
c_oflag
)
;
self
.
control_flags
=
ControlFlags
:
:
from_bits_retain
(
termios
.
c_cflag
)
;
self
.
local_flags
=
LocalFlags
:
:
from_bits_truncate
(
termios
.
c_lflag
)
;
self
.
control_chars
=
termios
.
c_cc
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
)
)
]
{
self
.
line_discipline
=
termios
.
c_line
;
}
}
}
impl
From
<
libc
:
:
termios
>
for
Termios
{
fn
from
(
termios
:
libc
:
:
termios
)
-
>
Self
{
Termios
{
inner
:
RefCell
:
:
new
(
termios
)
input_flags
:
InputFlags
:
:
from_bits_truncate
(
termios
.
c_iflag
)
output_flags
:
OutputFlags
:
:
from_bits_truncate
(
termios
.
c_oflag
)
control_flags
:
ControlFlags
:
:
from_bits_truncate
(
termios
.
c_cflag
)
local_flags
:
LocalFlags
:
:
from_bits_truncate
(
termios
.
c_lflag
)
control_chars
:
termios
.
c_cc
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
)
)
]
line_discipline
:
termios
.
c_line
}
}
}
impl
From
<
Termios
>
for
libc
:
:
termios
{
fn
from
(
termios
:
Termios
)
-
>
Self
{
termios
.
inner
.
into_inner
(
)
}
}
libc_enum
!
{
/
/
/
Baud
rates
supported
by
the
system
.
/
/
/
/
/
/
For
the
BSDs
arbitrary
baud
rates
can
be
specified
by
using
u32
s
directly
instead
of
this
/
/
/
enum
.
/
/
/
/
/
/
B0
is
special
and
will
disable
the
port
.
#
[
cfg_attr
(
target_os
=
"
haiku
"
repr
(
u8
)
)
]
#
[
cfg_attr
(
target_os
=
"
hurd
"
repr
(
i32
)
)
]
#
[
cfg_attr
(
all
(
apple_targets
target_pointer_width
=
"
64
"
)
repr
(
u64
)
)
]
#
[
cfg_attr
(
all
(
not
(
all
(
apple_targets
target_pointer_width
=
"
64
"
)
)
not
(
target_os
=
"
haiku
"
)
not
(
target_os
=
"
hurd
"
)
)
repr
(
u32
)
)
]
#
[
non_exhaustive
]
pub
enum
BaudRate
{
B0
B50
B75
B110
B134
B150
B200
B300
B600
B1200
B1800
B2400
B4800
#
[
cfg
(
bsd
)
]
B7200
B9600
#
[
cfg
(
bsd
)
]
B14400
B19200
#
[
cfg
(
bsd
)
]
B28800
B38400
#
[
cfg
(
not
(
target_os
=
"
aix
"
)
)
]
B57600
#
[
cfg
(
bsd
)
]
B76800
#
[
cfg
(
not
(
target_os
=
"
aix
"
)
)
]
B115200
#
[
cfg
(
solarish
)
]
B153600
#
[
cfg
(
not
(
target_os
=
"
aix
"
)
)
]
B230400
#
[
cfg
(
solarish
)
]
B307200
#
[
cfg
(
any
(
linux_android
solarish
target_os
=
"
freebsd
"
target_os
=
"
netbsd
"
)
)
]
B460800
#
[
cfg
(
linux_android
)
]
B500000
#
[
cfg
(
linux_android
)
]
B576000
#
[
cfg
(
any
(
linux_android
solarish
target_os
=
"
freebsd
"
target_os
=
"
netbsd
"
)
)
]
B921600
#
[
cfg
(
linux_android
)
]
B1000000
#
[
cfg
(
linux_android
)
]
B1152000
#
[
cfg
(
linux_android
)
]
B1500000
#
[
cfg
(
linux_android
)
]
B2000000
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
sparc64
"
)
)
)
)
]
B2500000
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
sparc64
"
)
)
)
)
]
B3000000
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
sparc64
"
)
)
)
)
]
B3500000
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
sparc64
"
)
)
)
)
]
B4000000
}
impl
TryFrom
<
libc
:
:
speed_t
>
}
#
[
cfg
(
bsd
)
]
impl
From
<
BaudRate
>
for
u32
{
fn
from
(
b
:
BaudRate
)
-
>
u32
{
b
as
u32
}
}
#
[
cfg
(
target_os
=
"
haiku
"
)
]
impl
From
<
BaudRate
>
for
u8
{
fn
from
(
b
:
BaudRate
)
-
>
u8
{
b
as
u8
}
}
libc_enum
!
{
/
/
/
Specify
when
a
port
configuration
change
should
occur
.
/
/
/
/
/
/
Used
as
an
argument
to
tcsetattr
(
)
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
SetArg
{
/
/
/
The
change
will
occur
immediately
TCSANOW
/
/
/
The
change
occurs
after
all
output
has
been
written
TCSADRAIN
/
/
/
Same
as
TCSADRAIN
but
will
also
flush
the
input
buffer
TCSAFLUSH
}
}
libc_enum
!
{
/
/
/
Specify
a
combination
of
the
input
and
output
buffers
to
flush
/
/
/
/
/
/
Used
as
an
argument
to
tcflush
(
)
.
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
FlushArg
{
/
/
/
Flush
data
that
was
received
but
not
read
TCIFLUSH
/
/
/
Flush
data
written
but
not
transmitted
TCOFLUSH
/
/
/
Flush
both
received
data
not
read
and
written
data
not
transmitted
TCIOFLUSH
}
}
libc_enum
!
{
/
/
/
Specify
how
transmission
flow
should
be
altered
/
/
/
/
/
/
Used
as
an
argument
to
tcflow
(
)
.
#
[
repr
(
i32
)
]
#
[
non_exhaustive
]
pub
enum
FlowArg
{
/
/
/
Suspend
transmission
TCOOFF
/
/
/
Resume
transmission
TCOON
/
/
/
Transmit
a
STOP
character
which
should
disable
a
connected
terminal
device
TCIOFF
/
/
/
Transmit
a
START
character
which
should
re
-
enable
a
connected
terminal
device
TCION
}
}
libc_enum
!
{
/
/
/
Indices
into
the
termios
.
c_cc
array
for
special
characters
.
#
[
repr
(
usize
)
]
#
[
non_exhaustive
]
pub
enum
SpecialCharacterIndices
{
#
[
cfg
(
not
(
any
(
target_os
=
"
aix
"
target_os
=
"
haiku
"
)
)
)
]
VDISCARD
#
[
cfg
(
any
(
bsd
solarish
target_os
=
"
aix
"
)
)
]
VDSUSP
VEOF
VEOL
VEOL2
VERASE
#
[
cfg
(
any
(
freebsdlike
solarish
)
)
]
VERASE2
VINTR
VKILL
#
[
cfg
(
not
(
target_os
=
"
haiku
"
)
)
]
VLNEXT
#
[
cfg
(
not
(
any
(
all
(
target_os
=
"
linux
"
target_arch
=
"
sparc64
"
)
solarish
target_os
=
"
aix
"
target_os
=
"
haiku
"
)
)
)
]
VMIN
VQUIT
#
[
cfg
(
not
(
target_os
=
"
haiku
"
)
)
]
VREPRINT
VSTART
#
[
cfg
(
any
(
bsd
solarish
)
)
]
VSTATUS
VSTOP
VSUSP
#
[
cfg
(
target_os
=
"
linux
"
)
]
VSWTC
#
[
cfg
(
any
(
solarish
target_os
=
"
haiku
"
)
)
]
VSWTCH
#
[
cfg
(
not
(
any
(
all
(
target_os
=
"
linux
"
target_arch
=
"
sparc64
"
)
solarish
target_os
=
"
aix
"
target_os
=
"
haiku
"
)
)
)
]
VTIME
#
[
cfg
(
not
(
any
(
target_os
=
"
aix
"
target_os
=
"
haiku
"
)
)
)
]
VWERASE
#
[
cfg
(
target_os
=
"
dragonfly
"
)
]
VCHECKPT
}
}
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
target_arch
=
"
sparc64
"
)
solarish
target_os
=
"
aix
"
target_os
=
"
haiku
"
)
)
]
impl
SpecialCharacterIndices
{
pub
const
VMIN
:
SpecialCharacterIndices
=
SpecialCharacterIndices
:
:
VEOF
;
pub
const
VTIME
:
SpecialCharacterIndices
=
SpecialCharacterIndices
:
:
VEOL
;
}
pub
use
libc
:
:
NCCS
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
aix
"
bsd
)
)
]
pub
use
libc
:
:
_POSIX_VDISABLE
;
libc_bitflags
!
{
/
/
/
Flags
for
configuring
the
input
mode
of
a
terminal
pub
struct
InputFlags
:
tcflag_t
{
IGNBRK
;
BRKINT
;
IGNPAR
;
PARMRK
;
INPCK
;
ISTRIP
;
INLCR
;
IGNCR
;
ICRNL
;
IXON
;
IXOFF
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
IXANY
;
#
[
cfg
(
not
(
any
(
target_os
=
"
redox
"
target_os
=
"
haiku
"
)
)
)
]
IMAXBEL
;
#
[
cfg
(
any
(
linux_android
apple_targets
)
)
]
IUTF8
;
}
}
libc_bitflags
!
{
/
/
/
Flags
for
configuring
the
output
mode
of
a
terminal
pub
struct
OutputFlags
:
tcflag_t
{
OPOST
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
)
)
]
OLCUC
;
ONLCR
;
OCRNL
as
tcflag_t
;
ONOCR
as
tcflag_t
;
ONLRET
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
OFDEL
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
NL0
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
NL1
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
CR0
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
CR1
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
CR2
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
CR3
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
apple_targets
)
)
]
TAB0
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
TAB1
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
TAB2
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
apple_targets
)
)
]
TAB3
as
tcflag_t
;
#
[
cfg
(
linux_android
)
]
XTABS
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
BS0
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
BS1
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
VT0
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
VT1
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
FF0
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
FF1
as
tcflag_t
;
#
[
cfg
(
bsd
)
]
OXTABS
;
#
[
cfg
(
bsd
)
]
ONOEOT
as
tcflag_t
;
/
/
Bitmasks
for
use
with
OutputFlags
to
select
specific
settings
/
/
These
should
be
moved
to
be
a
mask
once
https
:
/
/
github
.
com
/
rust
-
lang
-
nursery
/
bitflags
/
issues
/
110
/
/
is
resolved
.
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
NLDLY
as
tcflag_t
;
/
/
FIXME
:
Datatype
needs
to
be
corrected
in
libc
for
mac
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
CRDLY
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
apple_targets
)
)
]
TABDLY
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
BSDLY
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
VTDLY
as
tcflag_t
;
#
[
cfg
(
any
(
linux_android
target_os
=
"
haiku
"
apple_targets
)
)
]
FFDLY
as
tcflag_t
;
}
}
libc_bitflags
!
{
/
/
/
Flags
for
setting
the
control
mode
of
a
terminal
pub
struct
ControlFlags
:
tcflag_t
{
#
[
cfg
(
bsd
)
]
CIGNORE
;
CS5
;
CS6
;
CS7
;
CS8
;
CSTOPB
;
CREAD
;
PARENB
;
PARODD
;
HUPCL
;
CLOCAL
;
#
[
cfg
(
not
(
any
(
target_os
=
"
redox
"
target_os
=
"
aix
"
)
)
)
]
CRTSCTS
;
#
[
cfg
(
linux_android
)
]
CBAUD
;
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
target_arch
=
"
mips
"
)
)
)
)
]
CMSPAR
;
#
[
cfg
(
any
(
target_os
=
"
android
"
all
(
target_os
=
"
linux
"
not
(
any
(
target_arch
=
"
powerpc
"
target_arch
=
"
powerpc64
"
)
)
)
)
)
]
CIBAUD
;
#
[
cfg
(
linux_android
)
]
CBAUDEX
;
#
[
cfg
(
bsd
)
]
MDMBUF
;
#
[
cfg
(
netbsdlike
)
]
CHWFLOW
;
#
[
cfg
(
any
(
freebsdlike
netbsdlike
)
)
]
CCTS_OFLOW
;
#
[
cfg
(
any
(
freebsdlike
netbsdlike
)
)
]
CRTS_IFLOW
;
#
[
cfg
(
freebsdlike
)
]
CDTR_IFLOW
;
#
[
cfg
(
freebsdlike
)
]
CDSR_OFLOW
;
#
[
cfg
(
freebsdlike
)
]
CCAR_OFLOW
;
/
/
Bitmasks
for
use
with
ControlFlags
to
select
specific
settings
/
/
These
should
be
moved
to
be
a
mask
once
https
:
/
/
github
.
com
/
rust
-
lang
-
nursery
/
bitflags
/
issues
/
110
/
/
is
resolved
.
CSIZE
;
}
}
libc_bitflags
!
{
/
/
/
Flags
for
setting
any
local
modes
pub
struct
LocalFlags
:
tcflag_t
{
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
ECHOKE
;
ECHOE
;
ECHOK
;
ECHO
;
ECHONL
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
ECHOPRT
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
ECHOCTL
;
ISIG
;
ICANON
;
#
[
cfg
(
bsd
)
]
ALTWERASE
;
IEXTEN
;
#
[
cfg
(
not
(
any
(
target_os
=
"
redox
"
target_os
=
"
haiku
"
target_os
=
"
aix
"
)
)
)
]
EXTPROC
;
TOSTOP
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
FLUSHO
;
#
[
cfg
(
bsd
)
]
NOKERNINFO
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
PENDIN
;
NOFLSH
;
}
}
cfg_if
!
{
if
#
[
cfg
(
bsd
)
]
{
/
/
/
Get
input
baud
rate
(
see
/
/
/
[
cfgetispeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfgetispeed
.
html
)
)
.
/
/
/
/
/
/
cfgetispeed
(
)
extracts
the
input
baud
rate
from
the
given
Termios
structure
.
/
/
The
cast
is
not
unnecessary
on
all
platforms
.
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
pub
fn
cfgetispeed
(
termios
:
&
Termios
)
-
>
u32
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
unsafe
{
libc
:
:
cfgetispeed
(
&
*
inner_termios
)
as
u32
}
}
/
/
/
Get
output
baud
rate
(
see
/
/
/
[
cfgetospeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfgetospeed
.
html
)
)
.
/
/
/
/
/
/
cfgetospeed
(
)
extracts
the
output
baud
rate
from
the
given
Termios
structure
.
/
/
The
cast
is
not
unnecessary
on
all
platforms
.
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
pub
fn
cfgetospeed
(
termios
:
&
Termios
)
-
>
u32
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
unsafe
{
libc
:
:
cfgetospeed
(
&
*
inner_termios
)
as
u32
}
}
/
/
/
Set
input
baud
rate
(
see
/
/
/
[
cfsetispeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfsetispeed
.
html
)
)
.
/
/
/
/
/
/
cfsetispeed
(
)
sets
the
intput
baud
rate
in
the
given
Termios
structure
.
pub
fn
cfsetispeed
<
T
:
Into
<
u32
>
>
(
termios
:
&
mut
Termios
baud
:
T
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
let
res
=
unsafe
{
libc
:
:
cfsetispeed
(
inner_termios
baud
.
into
(
)
as
libc
:
:
speed_t
)
}
;
termios
.
update_wrapper
(
)
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
/
/
/
Set
output
baud
rate
(
see
/
/
/
[
cfsetospeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfsetospeed
.
html
)
)
.
/
/
/
/
/
/
cfsetospeed
(
)
sets
the
output
baud
rate
in
the
given
termios
structure
.
pub
fn
cfsetospeed
<
T
:
Into
<
u32
>
>
(
termios
:
&
mut
Termios
baud
:
T
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
let
res
=
unsafe
{
libc
:
:
cfsetospeed
(
inner_termios
baud
.
into
(
)
as
libc
:
:
speed_t
)
}
;
termios
.
update_wrapper
(
)
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
/
/
/
Set
both
the
input
and
output
baud
rates
(
see
/
/
/
[
termios
(
3
)
]
(
https
:
/
/
www
.
freebsd
.
org
/
cgi
/
man
.
cgi
?
query
=
cfsetspeed
)
)
.
/
/
/
/
/
/
cfsetspeed
(
)
sets
the
input
and
output
baud
rate
in
the
given
termios
structure
.
Note
that
/
/
/
this
is
part
of
the
4
.
4BSD
standard
and
not
part
of
POSIX
.
pub
fn
cfsetspeed
<
T
:
Into
<
u32
>
>
(
termios
:
&
mut
Termios
baud
:
T
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
let
res
=
unsafe
{
libc
:
:
cfsetspeed
(
inner_termios
baud
.
into
(
)
as
libc
:
:
speed_t
)
}
;
termios
.
update_wrapper
(
)
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
}
else
{
use
std
:
:
convert
:
:
TryInto
;
/
/
/
Get
input
baud
rate
(
see
/
/
/
[
cfgetispeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfgetispeed
.
html
)
)
.
/
/
/
/
/
/
cfgetispeed
(
)
extracts
the
input
baud
rate
from
the
given
Termios
structure
.
pub
fn
cfgetispeed
(
termios
:
&
Termios
)
-
>
BaudRate
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
unsafe
{
libc
:
:
cfgetispeed
(
&
*
inner_termios
)
}
.
try_into
(
)
.
unwrap
(
)
}
/
/
/
Get
output
baud
rate
(
see
/
/
/
[
cfgetospeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfgetospeed
.
html
)
)
.
/
/
/
/
/
/
cfgetospeed
(
)
extracts
the
output
baud
rate
from
the
given
Termios
structure
.
pub
fn
cfgetospeed
(
termios
:
&
Termios
)
-
>
BaudRate
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
unsafe
{
libc
:
:
cfgetospeed
(
&
*
inner_termios
)
}
.
try_into
(
)
.
unwrap
(
)
}
/
/
/
Set
input
baud
rate
(
see
/
/
/
[
cfsetispeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfsetispeed
.
html
)
)
.
/
/
/
/
/
/
cfsetispeed
(
)
sets
the
intput
baud
rate
in
the
given
Termios
structure
.
pub
fn
cfsetispeed
(
termios
:
&
mut
Termios
baud
:
BaudRate
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
let
res
=
unsafe
{
libc
:
:
cfsetispeed
(
inner_termios
baud
as
libc
:
:
speed_t
)
}
;
termios
.
update_wrapper
(
)
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
/
/
/
Set
output
baud
rate
(
see
/
/
/
[
cfsetospeed
(
3p
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
cfsetospeed
.
html
)
)
.
/
/
/
/
/
/
cfsetospeed
(
)
sets
the
output
baud
rate
in
the
given
Termios
structure
.
pub
fn
cfsetospeed
(
termios
:
&
mut
Termios
baud
:
BaudRate
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
let
res
=
unsafe
{
libc
:
:
cfsetospeed
(
inner_termios
baud
as
libc
:
:
speed_t
)
}
;
termios
.
update_wrapper
(
)
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
/
/
/
Set
both
the
input
and
output
baud
rates
(
see
/
/
/
[
termios
(
3
)
]
(
https
:
/
/
www
.
freebsd
.
org
/
cgi
/
man
.
cgi
?
query
=
cfsetspeed
)
)
.
/
/
/
/
/
/
cfsetspeed
(
)
sets
the
input
and
output
baud
rate
in
the
given
Termios
structure
.
Note
that
/
/
/
this
is
part
of
the
4
.
4BSD
standard
and
not
part
of
POSIX
.
#
[
cfg
(
not
(
target_os
=
"
haiku
"
)
)
]
pub
fn
cfsetspeed
(
termios
:
&
mut
Termios
baud
:
BaudRate
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
let
res
=
unsafe
{
libc
:
:
cfsetspeed
(
inner_termios
baud
as
libc
:
:
speed_t
)
}
;
termios
.
update_wrapper
(
)
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
}
}
pub
fn
cfmakeraw
(
termios
:
&
mut
Termios
)
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
unsafe
{
libc
:
:
cfmakeraw
(
inner_termios
)
;
}
termios
.
update_wrapper
(
)
;
}
#
[
cfg
(
target_os
=
"
freebsd
"
)
]
pub
fn
cfmakesane
(
termios
:
&
mut
Termios
)
{
let
inner_termios
=
unsafe
{
termios
.
get_libc_termios_mut
(
)
}
;
unsafe
{
libc
:
:
cfmakesane
(
inner_termios
)
;
}
termios
.
update_wrapper
(
)
;
}
pub
fn
tcgetattr
<
Fd
:
AsFd
>
(
fd
:
Fd
)
-
>
Result
<
Termios
>
{
let
mut
termios
=
mem
:
:
MaybeUninit
:
:
uninit
(
)
;
let
res
=
unsafe
{
libc
:
:
tcgetattr
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
termios
.
as_mut_ptr
(
)
)
}
;
Errno
:
:
result
(
res
)
?
;
unsafe
{
Ok
(
termios
.
assume_init
(
)
.
into
(
)
)
}
}
pub
fn
tcsetattr
<
Fd
:
AsFd
>
(
fd
:
Fd
actions
:
SetArg
termios
:
&
Termios
)
-
>
Result
<
(
)
>
{
let
inner_termios
=
termios
.
get_libc_termios
(
)
;
Errno
:
:
result
(
unsafe
{
libc
:
:
tcsetattr
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
actions
as
c_int
&
*
inner_termios
)
}
)
.
map
(
drop
)
}
pub
fn
tcdrain
<
Fd
:
AsFd
>
(
fd
:
Fd
)
-
>
Result
<
(
)
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
tcdrain
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
)
}
)
.
map
(
drop
)
}
pub
fn
tcflow
<
Fd
:
AsFd
>
(
fd
:
Fd
action
:
FlowArg
)
-
>
Result
<
(
)
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
tcflow
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
action
as
c_int
)
}
)
.
map
(
drop
)
}
pub
fn
tcflush
<
Fd
:
AsFd
>
(
fd
:
Fd
action
:
FlushArg
)
-
>
Result
<
(
)
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
tcflush
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
action
as
c_int
)
}
)
.
map
(
drop
)
}
pub
fn
tcsendbreak
<
Fd
:
AsFd
>
(
fd
:
Fd
duration
:
c_int
)
-
>
Result
<
(
)
>
{
Errno
:
:
result
(
unsafe
{
libc
:
:
tcsendbreak
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
duration
)
}
)
.
map
(
drop
)
}
feature
!
{
#
!
[
feature
=
"
process
"
]
/
/
/
Get
the
session
controlled
by
the
given
terminal
(
see
/
/
/
[
tcgetsid
(
3
)
]
(
https
:
/
/
pubs
.
opengroup
.
org
/
onlinepubs
/
9699919799
/
functions
/
tcgetsid
.
html
)
)
.
pub
fn
tcgetsid
<
Fd
:
AsFd
>
(
fd
:
Fd
)
-
>
Result
<
Pid
>
{
let
res
=
unsafe
{
libc
:
:
tcgetsid
(
fd
.
as_fd
(
)
.
as_raw_fd
(
)
)
}
;
Errno
:
:
result
(
res
)
.
map
(
Pid
:
:
from_raw
)
}
}
