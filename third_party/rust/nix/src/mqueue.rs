use
crate
:
:
errno
:
:
Errno
;
use
crate
:
:
Result
;
use
crate
:
:
sys
:
:
stat
:
:
Mode
;
use
libc
:
:
{
self
c_char
mqd_t
size_t
}
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
mem
;
libc_bitflags
!
{
/
/
/
Used
with
[
mq_open
]
.
pub
struct
MQ_OFlag
:
libc
:
:
c_int
{
/
/
/
Open
the
message
queue
for
receiving
messages
.
O_RDONLY
;
/
/
/
Open
the
queue
for
sending
messages
.
O_WRONLY
;
/
/
/
Open
the
queue
for
both
receiving
and
sending
messages
O_RDWR
;
/
/
/
Create
a
message
queue
.
O_CREAT
;
/
/
/
If
set
along
with
O_CREAT
mq_open
will
fail
if
the
message
/
/
/
queue
name
exists
.
O_EXCL
;
/
/
/
mq_send
and
mq_receive
should
fail
with
EAGAIN
rather
than
/
/
/
wait
for
resources
that
are
not
currently
available
.
O_NONBLOCK
;
/
/
/
Set
the
close
-
on
-
exec
flag
for
the
message
queue
descriptor
.
O_CLOEXEC
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
struct
MqAttr
{
mq_attr
:
libc
:
:
mq_attr
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
)
]
#
[
allow
(
missing_copy_implementations
)
]
pub
struct
MqdT
(
mqd_t
)
;
#
[
cfg
(
all
(
target_arch
=
"
x86_64
"
target_pointer_width
=
"
32
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
pub
type
mq_attr_member_t
=
i64
;
#
[
cfg
(
not
(
all
(
target_arch
=
"
x86_64
"
target_pointer_width
=
"
32
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
)
)
)
)
]
pub
type
mq_attr_member_t
=
libc
:
:
c_long
;
impl
MqAttr
{
pub
fn
new
(
mq_flags
:
mq_attr_member_t
mq_maxmsg
:
mq_attr_member_t
mq_msgsize
:
mq_attr_member_t
mq_curmsgs
:
mq_attr_member_t
)
-
>
MqAttr
{
let
mut
attr
=
mem
:
:
MaybeUninit
:
:
<
libc
:
:
mq_attr
>
:
:
uninit
(
)
;
unsafe
{
let
p
=
attr
.
as_mut_ptr
(
)
;
(
*
p
)
.
mq_flags
=
mq_flags
;
(
*
p
)
.
mq_maxmsg
=
mq_maxmsg
;
(
*
p
)
.
mq_msgsize
=
mq_msgsize
;
(
*
p
)
.
mq_curmsgs
=
mq_curmsgs
;
MqAttr
{
mq_attr
:
attr
.
assume_init
(
)
}
}
}
pub
const
fn
flags
(
&
self
)
-
>
mq_attr_member_t
{
self
.
mq_attr
.
mq_flags
}
pub
const
fn
maxmsg
(
&
self
)
-
>
mq_attr_member_t
{
self
.
mq_attr
.
mq_maxmsg
}
pub
const
fn
msgsize
(
&
self
)
-
>
mq_attr_member_t
{
self
.
mq_attr
.
mq_msgsize
}
pub
const
fn
curmsgs
(
&
self
)
-
>
mq_attr_member_t
{
self
.
mq_attr
.
mq_curmsgs
}
}
#
[
allow
(
clippy
:
:
cast_lossless
)
]
pub
fn
mq_open
(
name
:
&
CStr
oflag
:
MQ_OFlag
mode
:
Mode
attr
:
Option
<
&
MqAttr
>
)
-
>
Result
<
MqdT
>
{
let
res
=
match
attr
{
Some
(
mq_attr
)
=
>
unsafe
{
libc
:
:
mq_open
(
name
.
as_ptr
(
)
oflag
.
bits
(
)
mode
.
bits
(
)
as
libc
:
:
c_int
&
mq_attr
.
mq_attr
as
*
const
libc
:
:
mq_attr
)
}
None
=
>
unsafe
{
libc
:
:
mq_open
(
name
.
as_ptr
(
)
oflag
.
bits
(
)
)
}
}
;
Errno
:
:
result
(
res
)
.
map
(
MqdT
)
}
pub
fn
mq_unlink
(
name
:
&
CStr
)
-
>
Result
<
(
)
>
{
let
res
=
unsafe
{
libc
:
:
mq_unlink
(
name
.
as_ptr
(
)
)
}
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
pub
fn
mq_close
(
mqdes
:
MqdT
)
-
>
Result
<
(
)
>
{
let
res
=
unsafe
{
libc
:
:
mq_close
(
mqdes
.
0
)
}
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
pub
fn
mq_receive
(
mqdes
:
&
MqdT
message
:
&
mut
[
u8
]
msg_prio
:
&
mut
u32
)
-
>
Result
<
usize
>
{
let
len
=
message
.
len
(
)
as
size_t
;
let
res
=
unsafe
{
libc
:
:
mq_receive
(
mqdes
.
0
message
.
as_mut_ptr
(
)
as
*
mut
c_char
len
msg_prio
as
*
mut
u32
)
}
;
Errno
:
:
result
(
res
)
.
map
(
|
r
|
r
as
usize
)
}
pub
fn
mq_send
(
mqdes
:
&
MqdT
message
:
&
[
u8
]
msq_prio
:
u32
)
-
>
Result
<
(
)
>
{
let
res
=
unsafe
{
libc
:
:
mq_send
(
mqdes
.
0
message
.
as_ptr
(
)
as
*
const
c_char
message
.
len
(
)
msq_prio
)
}
;
Errno
:
:
result
(
res
)
.
map
(
drop
)
}
pub
fn
mq_getattr
(
mqd
:
&
MqdT
)
-
>
Result
<
MqAttr
>
{
let
mut
attr
=
mem
:
:
MaybeUninit
:
:
<
libc
:
:
mq_attr
>
:
:
uninit
(
)
;
let
res
=
unsafe
{
libc
:
:
mq_getattr
(
mqd
.
0
attr
.
as_mut_ptr
(
)
)
}
;
Errno
:
:
result
(
res
)
.
map
(
|
_
|
unsafe
{
MqAttr
{
mq_attr
:
attr
.
assume_init
(
)
}
}
)
}
pub
fn
mq_setattr
(
mqd
:
&
MqdT
newattr
:
&
MqAttr
)
-
>
Result
<
MqAttr
>
{
let
mut
attr
=
mem
:
:
MaybeUninit
:
:
<
libc
:
:
mq_attr
>
:
:
uninit
(
)
;
let
res
=
unsafe
{
libc
:
:
mq_setattr
(
mqd
.
0
&
newattr
.
mq_attr
as
*
const
libc
:
:
mq_attr
attr
.
as_mut_ptr
(
)
)
}
;
Errno
:
:
result
(
res
)
.
map
(
|
_
|
unsafe
{
MqAttr
{
mq_attr
:
attr
.
assume_init
(
)
}
}
)
}
#
[
allow
(
clippy
:
:
useless_conversion
)
]
pub
fn
mq_set_nonblock
(
mqd
:
&
MqdT
)
-
>
Result
<
MqAttr
>
{
let
oldattr
=
mq_getattr
(
mqd
)
?
;
let
newattr
=
MqAttr
:
:
new
(
mq_attr_member_t
:
:
from
(
MQ_OFlag
:
:
O_NONBLOCK
.
bits
(
)
)
oldattr
.
mq_attr
.
mq_maxmsg
oldattr
.
mq_attr
.
mq_msgsize
oldattr
.
mq_attr
.
mq_curmsgs
)
;
mq_setattr
(
mqd
&
newattr
)
}
pub
fn
mq_remove_nonblock
(
mqd
:
&
MqdT
)
-
>
Result
<
MqAttr
>
{
let
oldattr
=
mq_getattr
(
mqd
)
?
;
let
newattr
=
MqAttr
:
:
new
(
0
oldattr
.
mq_attr
.
mq_maxmsg
oldattr
.
mq_attr
.
mq_msgsize
oldattr
.
mq_attr
.
mq_curmsgs
)
;
mq_setattr
(
mqd
&
newattr
)
}
