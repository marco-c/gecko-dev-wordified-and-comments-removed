use
cfg_if
:
:
cfg_if
;
#
[
cfg
(
apple_targets
)
]
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
ffi
;
use
std
:
:
iter
:
:
Iterator
;
use
std
:
:
mem
;
use
std
:
:
option
:
:
Option
;
use
crate
:
:
net
:
:
if_
:
:
*
;
use
crate
:
:
sys
:
:
socket
:
:
{
SockaddrLike
SockaddrStorage
}
;
use
crate
:
:
{
Errno
Result
}
;
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
InterfaceAddress
{
pub
interface_name
:
String
pub
flags
:
InterfaceFlags
pub
address
:
Option
<
SockaddrStorage
>
pub
netmask
:
Option
<
SockaddrStorage
>
pub
broadcast
:
Option
<
SockaddrStorage
>
pub
destination
:
Option
<
SockaddrStorage
>
}
cfg_if
!
{
if
#
[
cfg
(
any
(
linux_android
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
)
)
]
{
fn
get_ifu_from_sockaddr
(
info
:
&
libc
:
:
ifaddrs
)
-
>
*
const
libc
:
:
sockaddr
{
info
.
ifa_ifu
}
}
else
{
fn
get_ifu_from_sockaddr
(
info
:
&
libc
:
:
ifaddrs
)
-
>
*
const
libc
:
:
sockaddr
{
info
.
ifa_dstaddr
}
}
}
#
[
cfg
(
apple_targets
)
]
unsafe
fn
workaround_xnu_bug
(
info
:
&
libc
:
:
ifaddrs
)
-
>
Option
<
SockaddrStorage
>
{
let
src_sock
=
info
.
ifa_netmask
;
if
src_sock
.
is_null
(
)
{
return
None
;
}
let
mut
dst_sock
=
mem
:
:
MaybeUninit
:
:
<
libc
:
:
sockaddr_storage
>
:
:
zeroed
(
)
;
let
dst_sock
=
unsafe
{
std
:
:
ptr
:
:
copy_nonoverlapping
(
src_sock
as
*
const
u8
dst_sock
.
as_mut_ptr
(
)
.
cast
(
)
(
*
src_sock
)
.
sa_len
.
into
(
)
)
;
(
*
dst_sock
.
as_mut_ptr
(
)
)
.
ss_len
=
u8
:
:
try_from
(
mem
:
:
size_of
:
:
<
libc
:
:
sockaddr_storage
>
(
)
)
.
unwrap
(
)
;
dst_sock
.
assume_init
(
)
}
;
let
dst_sock_ptr
=
&
dst_sock
as
*
const
libc
:
:
sockaddr_storage
as
*
const
libc
:
:
sockaddr
;
unsafe
{
SockaddrStorage
:
:
from_raw
(
dst_sock_ptr
None
)
}
}
impl
InterfaceAddress
{
fn
from_libc_ifaddrs
(
info
:
&
libc
:
:
ifaddrs
)
-
>
InterfaceAddress
{
let
ifname
=
unsafe
{
ffi
:
:
CStr
:
:
from_ptr
(
info
.
ifa_name
)
}
;
let
address
=
unsafe
{
SockaddrStorage
:
:
from_raw
(
info
.
ifa_addr
None
)
}
;
#
[
cfg
(
apple_targets
)
]
let
netmask
=
unsafe
{
workaround_xnu_bug
(
info
)
}
;
#
[
cfg
(
not
(
apple_targets
)
)
]
let
netmask
=
unsafe
{
SockaddrStorage
:
:
from_raw
(
info
.
ifa_netmask
None
)
}
;
let
mut
addr
=
InterfaceAddress
{
interface_name
:
ifname
.
to_string_lossy
(
)
.
to_string
(
)
flags
:
InterfaceFlags
:
:
from_bits_truncate
(
info
.
ifa_flags
as
IflagsType
)
address
netmask
broadcast
:
None
destination
:
None
}
;
let
ifu
=
get_ifu_from_sockaddr
(
info
)
;
if
addr
.
flags
.
contains
(
InterfaceFlags
:
:
IFF_POINTOPOINT
)
{
addr
.
destination
=
unsafe
{
SockaddrStorage
:
:
from_raw
(
ifu
None
)
}
;
}
else
if
addr
.
flags
.
contains
(
InterfaceFlags
:
:
IFF_BROADCAST
)
{
addr
.
broadcast
=
unsafe
{
SockaddrStorage
:
:
from_raw
(
ifu
None
)
}
;
}
addr
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
InterfaceAddressIterator
{
base
:
*
mut
libc
:
:
ifaddrs
next
:
*
mut
libc
:
:
ifaddrs
}
impl
Drop
for
InterfaceAddressIterator
{
fn
drop
(
&
mut
self
)
{
unsafe
{
libc
:
:
freeifaddrs
(
self
.
base
)
}
;
}
}
impl
Iterator
for
InterfaceAddressIterator
{
type
Item
=
InterfaceAddress
;
fn
next
(
&
mut
self
)
-
>
Option
<
<
Self
as
Iterator
>
:
:
Item
>
{
match
unsafe
{
self
.
next
.
as_ref
(
)
}
{
Some
(
ifaddr
)
=
>
{
self
.
next
=
ifaddr
.
ifa_next
;
Some
(
InterfaceAddress
:
:
from_libc_ifaddrs
(
ifaddr
)
)
}
None
=
>
None
}
}
}
pub
fn
getifaddrs
(
)
-
>
Result
<
InterfaceAddressIterator
>
{
let
mut
addrs
=
mem
:
:
MaybeUninit
:
:
<
*
mut
libc
:
:
ifaddrs
>
:
:
uninit
(
)
;
unsafe
{
Errno
:
:
result
(
libc
:
:
getifaddrs
(
addrs
.
as_mut_ptr
(
)
)
)
.
map
(
|
_
|
{
InterfaceAddressIterator
{
base
:
addrs
.
assume_init
(
)
next
:
addrs
.
assume_init
(
)
}
}
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_getifaddrs
(
)
{
let
_
=
getifaddrs
(
)
;
}
#
[
test
]
fn
test_getifaddrs_netmask_correct
(
)
{
let
addrs
=
getifaddrs
(
)
.
unwrap
(
)
;
for
iface
in
addrs
{
let
sock
=
if
let
Some
(
sock
)
=
iface
.
netmask
{
sock
}
else
{
continue
;
}
;
if
sock
.
family
(
)
=
=
Some
(
crate
:
:
sys
:
:
socket
:
:
AddressFamily
:
:
Inet
)
{
let
_
=
sock
.
as_sockaddr_in
(
)
.
unwrap
(
)
;
return
;
}
else
if
sock
.
family
(
)
=
=
Some
(
crate
:
:
sys
:
:
socket
:
:
AddressFamily
:
:
Inet6
)
{
let
_
=
sock
.
as_sockaddr_in6
(
)
.
unwrap
(
)
;
return
;
}
}
panic
!
(
"
No
address
?
"
)
;
}
}
