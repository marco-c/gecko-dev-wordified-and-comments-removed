use
crate
:
:
{
Error
NixPath
Result
}
;
use
crate
:
:
errno
:
:
Errno
;
use
crate
:
:
fcntl
:
:
{
self
OFlag
}
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
IntoRawFd
RawFd
}
;
use
std
:
:
ptr
;
use
std
:
:
ffi
;
use
crate
:
:
sys
;
use
cfg_if
:
:
cfg_if
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
use
libc
:
:
{
dirent64
as
dirent
readdir64_r
as
readdir_r
}
;
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
use
libc
:
:
{
dirent
readdir_r
}
;
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Dir
(
ptr
:
:
NonNull
<
libc
:
:
DIR
>
)
;
impl
Dir
{
pub
fn
open
<
P
:
?
Sized
+
NixPath
>
(
path
:
&
P
oflag
:
OFlag
mode
:
sys
:
:
stat
:
:
Mode
)
-
>
Result
<
Self
>
{
let
fd
=
fcntl
:
:
open
(
path
oflag
mode
)
?
;
Dir
:
:
from_fd
(
fd
)
}
pub
fn
openat
<
P
:
?
Sized
+
NixPath
>
(
dirfd
:
RawFd
path
:
&
P
oflag
:
OFlag
mode
:
sys
:
:
stat
:
:
Mode
)
-
>
Result
<
Self
>
{
let
fd
=
fcntl
:
:
openat
(
dirfd
path
oflag
mode
)
?
;
Dir
:
:
from_fd
(
fd
)
}
#
[
inline
]
pub
fn
from
<
F
:
IntoRawFd
>
(
fd
:
F
)
-
>
Result
<
Self
>
{
Dir
:
:
from_fd
(
fd
.
into_raw_fd
(
)
)
}
#
[
cfg_attr
(
has_doc_alias
doc
(
alias
(
"
fdopendir
"
)
)
)
]
pub
fn
from_fd
(
fd
:
RawFd
)
-
>
Result
<
Self
>
{
let
d
=
ptr
:
:
NonNull
:
:
new
(
unsafe
{
libc
:
:
fdopendir
(
fd
)
}
)
.
ok_or_else
(
|
|
{
let
e
=
Error
:
:
last
(
)
;
unsafe
{
libc
:
:
close
(
fd
)
}
;
e
}
)
?
;
Ok
(
Dir
(
d
)
)
}
pub
fn
iter
(
&
mut
self
)
-
>
Iter
{
Iter
(
self
)
}
}
unsafe
impl
Send
for
Dir
{
}
impl
AsRawFd
for
Dir
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
unsafe
{
libc
:
:
dirfd
(
self
.
0
.
as_ptr
(
)
)
}
}
}
impl
Drop
for
Dir
{
fn
drop
(
&
mut
self
)
{
let
e
=
Errno
:
:
result
(
unsafe
{
libc
:
:
closedir
(
self
.
0
.
as_ptr
(
)
)
}
)
;
if
!
std
:
:
thread
:
:
panicking
(
)
&
&
e
=
=
Err
(
Errno
:
:
EBADF
)
{
panic
!
(
"
Closing
an
invalid
file
descriptor
!
"
)
;
}
;
}
}
fn
next
(
dir
:
&
mut
Dir
)
-
>
Option
<
Result
<
Entry
>
>
{
unsafe
{
let
mut
ent
=
std
:
:
mem
:
:
MaybeUninit
:
:
<
dirent
>
:
:
uninit
(
)
;
let
mut
result
=
ptr
:
:
null_mut
(
)
;
if
let
Err
(
e
)
=
Errno
:
:
result
(
readdir_r
(
dir
.
0
.
as_ptr
(
)
ent
.
as_mut_ptr
(
)
&
mut
result
)
)
{
return
Some
(
Err
(
e
)
)
;
}
if
result
.
is_null
(
)
{
return
None
;
}
assert_eq
!
(
result
ent
.
as_mut_ptr
(
)
)
;
Some
(
Ok
(
Entry
(
ent
.
assume_init
(
)
)
)
)
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Iter
<
'
d
>
(
&
'
d
mut
Dir
)
;
impl
<
'
d
>
Iterator
for
Iter
<
'
d
>
{
type
Item
=
Result
<
Entry
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
next
(
self
.
0
)
}
}
impl
<
'
d
>
Drop
for
Iter
<
'
d
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
libc
:
:
rewinddir
(
(
self
.
0
)
.
0
.
as_ptr
(
)
)
}
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
OwningIter
(
Dir
)
;
impl
Iterator
for
OwningIter
{
type
Item
=
Result
<
Entry
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
next
(
&
mut
self
.
0
)
}
}
impl
AsRawFd
for
OwningIter
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
0
.
as_raw_fd
(
)
}
}
impl
IntoIterator
for
Dir
{
type
Item
=
Result
<
Entry
>
;
type
IntoIter
=
OwningIter
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
OwningIter
(
self
)
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
#
[
repr
(
transparent
)
]
pub
struct
Entry
(
dirent
)
;
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
enum
Type
{
Fifo
CharacterDevice
Directory
BlockDevice
File
Symlink
Socket
}
impl
Entry
{
#
[
allow
(
clippy
:
:
useless_conversion
)
]
#
[
allow
(
clippy
:
:
unnecessary_cast
)
]
pub
fn
ino
(
&
self
)
-
>
u64
{
cfg_if
!
{
if
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
emscripten
"
target_os
=
"
fuchsia
"
target_os
=
"
haiku
"
target_os
=
"
illumos
"
target_os
=
"
ios
"
target_os
=
"
l4re
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
solaris
"
)
)
]
{
self
.
0
.
d_ino
as
u64
}
else
{
u64
:
:
from
(
self
.
0
.
d_fileno
)
}
}
}
pub
fn
file_name
(
&
self
)
-
>
&
ffi
:
:
CStr
{
unsafe
{
:
:
std
:
:
ffi
:
:
CStr
:
:
from_ptr
(
self
.
0
.
d_name
.
as_ptr
(
)
)
}
}
pub
fn
file_type
(
&
self
)
-
>
Option
<
Type
>
{
#
[
cfg
(
not
(
any
(
target_os
=
"
illumos
"
target_os
=
"
solaris
"
target_os
=
"
haiku
"
)
)
)
]
match
self
.
0
.
d_type
{
libc
:
:
DT_FIFO
=
>
Some
(
Type
:
:
Fifo
)
libc
:
:
DT_CHR
=
>
Some
(
Type
:
:
CharacterDevice
)
libc
:
:
DT_DIR
=
>
Some
(
Type
:
:
Directory
)
libc
:
:
DT_BLK
=
>
Some
(
Type
:
:
BlockDevice
)
libc
:
:
DT_REG
=
>
Some
(
Type
:
:
File
)
libc
:
:
DT_LNK
=
>
Some
(
Type
:
:
Symlink
)
libc
:
:
DT_SOCK
=
>
Some
(
Type
:
:
Socket
)
_
=
>
None
}
#
[
cfg
(
any
(
target_os
=
"
illumos
"
target_os
=
"
solaris
"
target_os
=
"
haiku
"
)
)
]
None
}
}
