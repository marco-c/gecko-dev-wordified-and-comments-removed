use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsFd
AsRawFd
BorrowedFd
}
;
use
crate
:
:
errno
:
:
Errno
;
pub
use
crate
:
:
poll_timeout
:
:
{
PollTimeout
PollTimeoutTryFromError
}
;
use
crate
:
:
Result
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
PollFd
<
'
fd
>
{
pollfd
:
libc
:
:
pollfd
_fd
:
std
:
:
marker
:
:
PhantomData
<
BorrowedFd
<
'
fd
>
>
}
impl
<
'
fd
>
PollFd
<
'
fd
>
{
pub
fn
new
(
fd
:
BorrowedFd
<
'
fd
>
events
:
PollFlags
)
-
>
PollFd
<
'
fd
>
{
PollFd
{
pollfd
:
libc
:
:
pollfd
{
fd
:
fd
.
as_raw_fd
(
)
events
:
events
.
bits
(
)
revents
:
PollFlags
:
:
empty
(
)
.
bits
(
)
}
_fd
:
std
:
:
marker
:
:
PhantomData
}
}
pub
fn
revents
(
&
self
)
-
>
Option
<
PollFlags
>
{
PollFlags
:
:
from_bits
(
self
.
pollfd
.
revents
)
}
pub
fn
any
(
&
self
)
-
>
Option
<
bool
>
{
Some
(
self
.
revents
(
)
?
!
=
PollFlags
:
:
empty
(
)
)
}
pub
fn
all
(
&
self
)
-
>
Option
<
bool
>
{
Some
(
self
.
revents
(
)
?
&
self
.
events
(
)
=
=
self
.
events
(
)
)
}
pub
fn
events
(
&
self
)
-
>
PollFlags
{
PollFlags
:
:
from_bits
(
self
.
pollfd
.
events
)
.
unwrap
(
)
}
pub
fn
set_events
(
&
mut
self
events
:
PollFlags
)
{
self
.
pollfd
.
events
=
events
.
bits
(
)
;
}
}
impl
AsFd
for
PollFd
<
'
_
>
{
fn
as_fd
(
&
self
)
-
>
BorrowedFd
<
'
_
>
{
unsafe
{
BorrowedFd
:
:
borrow_raw
(
self
.
pollfd
.
fd
)
}
}
}
libc_bitflags
!
{
/
/
/
These
flags
define
the
different
events
that
can
be
monitored
by
poll
and
ppoll
pub
struct
PollFlags
:
libc
:
:
c_short
{
/
/
/
There
is
data
to
read
.
POLLIN
;
/
/
/
There
is
some
exceptional
condition
on
the
file
descriptor
.
/
/
/
/
/
/
Possibilities
include
:
/
/
/
/
/
/
*
There
is
out
-
of
-
band
data
on
a
TCP
socket
(
see
/
/
/
[
tcp
(
7
)
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man7
/
tcp
.
7
.
html
)
)
.
/
/
/
*
A
pseudoterminal
master
in
packet
mode
has
seen
a
state
/
/
/
change
on
the
slave
(
see
/
/
/
[
ioctl_tty
(
2
)
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man2
/
ioctl_tty
.
2
.
html
)
)
.
/
/
/
*
A
cgroup
.
events
file
has
been
modified
(
see
/
/
/
[
cgroups
(
7
)
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man7
/
cgroups
.
7
.
html
)
)
.
POLLPRI
;
/
/
/
Writing
is
now
possible
though
a
write
larger
that
the
/
/
/
available
space
in
a
socket
or
pipe
will
still
block
(
unless
/
/
/
O_NONBLOCK
is
set
)
.
POLLOUT
;
/
/
/
Equivalent
to
[
POLLIN
]
(
constant
.
POLLIN
.
html
)
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
POLLRDNORM
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
/
/
/
Equivalent
to
[
POLLOUT
]
(
constant
.
POLLOUT
.
html
)
POLLWRNORM
;
/
/
/
Priority
band
data
can
be
read
(
generally
unused
on
Linux
)
.
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
POLLRDBAND
;
/
/
/
Priority
data
may
be
written
.
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
POLLWRBAND
;
/
/
/
Error
condition
(
only
returned
in
/
/
/
[
PollFd
:
:
revents
]
(
struct
.
PollFd
.
html
#
method
.
revents
)
;
/
/
/
ignored
in
[
PollFd
:
:
new
]
(
struct
.
PollFd
.
html
#
method
.
new
)
)
.
/
/
/
This
bit
is
also
set
for
a
file
descriptor
referring
to
the
/
/
/
write
end
of
a
pipe
when
the
read
end
has
been
closed
.
POLLERR
;
/
/
/
Hang
up
(
only
returned
in
[
PollFd
:
:
revents
]
(
struct
.
PollFd
.
html
#
method
.
revents
)
;
/
/
/
ignored
in
[
PollFd
:
:
new
]
(
struct
.
PollFd
.
html
#
method
.
new
)
)
.
/
/
/
Note
that
when
reading
from
a
channel
such
as
a
pipe
or
a
stream
/
/
/
socket
this
event
merely
indicates
that
the
peer
closed
its
/
/
/
end
of
the
channel
.
Subsequent
reads
from
the
channel
will
/
/
/
return
0
(
end
of
file
)
only
after
all
outstanding
data
in
the
/
/
/
channel
has
been
consumed
.
POLLHUP
;
/
/
/
Invalid
request
:
fd
not
open
(
only
returned
in
/
/
/
[
PollFd
:
:
revents
]
(
struct
.
PollFd
.
html
#
method
.
revents
)
;
/
/
/
ignored
in
[
PollFd
:
:
new
]
(
struct
.
PollFd
.
html
#
method
.
new
)
)
.
POLLNVAL
;
}
}
pub
fn
poll
<
T
:
Into
<
PollTimeout
>
>
(
fds
:
&
mut
[
PollFd
]
timeout
:
T
)
-
>
Result
<
libc
:
:
c_int
>
{
let
res
=
unsafe
{
libc
:
:
poll
(
fds
.
as_mut_ptr
(
)
.
cast
(
)
fds
.
len
(
)
as
libc
:
:
nfds_t
i32
:
:
from
(
timeout
.
into
(
)
)
)
}
;
Errno
:
:
result
(
res
)
}
feature
!
{
#
!
[
feature
=
"
signal
"
]
/
/
/
ppoll
(
)
allows
an
application
to
safely
wait
until
either
a
file
/
/
/
descriptor
becomes
ready
or
until
a
signal
is
caught
.
/
/
/
(
[
poll
(
2
)
]
(
https
:
/
/
man7
.
org
/
linux
/
man
-
pages
/
man2
/
poll
.
2
.
html
)
)
/
/
/
/
/
/
ppoll
behaves
like
[
poll
]
but
let
you
specify
what
signals
may
interrupt
it
/
/
/
with
the
sigmask
argument
.
If
you
want
ppoll
to
block
indefinitely
/
/
/
specify
None
as
timeout
(
it
is
like
timeout
=
-
1
for
poll
)
.
/
/
/
If
sigmask
is
None
then
no
signal
mask
manipulation
is
performed
/
/
/
so
in
that
case
ppoll
differs
from
poll
only
in
the
precision
of
the
/
/
/
timeout
argument
.
/
/
/
#
[
cfg
(
any
(
linux_android
freebsdlike
)
)
]
pub
fn
ppoll
(
fds
:
&
mut
[
PollFd
]
timeout
:
Option
<
crate
:
:
sys
:
:
time
:
:
TimeSpec
>
sigmask
:
Option
<
crate
:
:
sys
:
:
signal
:
:
SigSet
>
)
-
>
Result
<
libc
:
:
c_int
>
{
let
timeout
=
timeout
.
as_ref
(
)
.
map_or
(
core
:
:
ptr
:
:
null
(
)
|
r
|
r
.
as_ref
(
)
)
;
let
sigmask
=
sigmask
.
as_ref
(
)
.
map_or
(
core
:
:
ptr
:
:
null
(
)
|
r
|
r
.
as_ref
(
)
)
;
let
res
=
unsafe
{
libc
:
:
ppoll
(
fds
.
as_mut_ptr
(
)
.
cast
(
)
fds
.
len
(
)
as
libc
:
:
nfds_t
timeout
sigmask
)
}
;
Errno
:
:
result
(
res
)
}
}
