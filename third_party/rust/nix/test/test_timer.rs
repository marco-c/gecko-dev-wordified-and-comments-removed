use
nix
:
:
sys
:
:
signal
:
:
{
sigaction
SaFlags
SigAction
SigEvent
SigHandler
SigSet
SigevNotify
Signal
}
;
use
nix
:
:
sys
:
:
timer
:
:
{
Expiration
Timer
TimerSetTimeFlags
}
;
use
nix
:
:
time
:
:
ClockId
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
const
SIG
:
Signal
=
Signal
:
:
SIGALRM
;
static
ALARM_CALLED
:
AtomicBool
=
AtomicBool
:
:
new
(
false
)
;
pub
extern
"
C
"
fn
handle_sigalarm
(
raw_signal
:
libc
:
:
c_int
)
{
let
signal
=
Signal
:
:
try_from
(
raw_signal
)
.
unwrap
(
)
;
if
signal
=
=
SIG
{
ALARM_CALLED
.
store
(
true
Ordering
:
:
Release
)
;
}
}
#
[
test
]
fn
alarm_fires
(
)
{
let
_m
=
crate
:
:
SIGNAL_MTX
.
lock
(
)
;
const
TIMER_PERIOD
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
handler
=
SigHandler
:
:
Handler
(
handle_sigalarm
)
;
let
signal_action
=
SigAction
:
:
new
(
handler
SaFlags
:
:
SA_RESTART
SigSet
:
:
empty
(
)
)
;
let
old_handler
=
unsafe
{
sigaction
(
SIG
&
signal_action
)
.
expect
(
"
unable
to
set
signal
handler
for
alarm
"
)
}
;
let
clockid
=
ClockId
:
:
CLOCK_MONOTONIC
;
let
sigevent
=
SigEvent
:
:
new
(
SigevNotify
:
:
SigevSignal
{
signal
:
SIG
si_value
:
0
}
)
;
let
mut
timer
=
Timer
:
:
new
(
clockid
sigevent
)
.
expect
(
"
failed
to
create
timer
"
)
;
let
expiration
=
Expiration
:
:
Interval
(
TIMER_PERIOD
.
into
(
)
)
;
let
flags
=
TimerSetTimeFlags
:
:
empty
(
)
;
timer
.
set
(
expiration
flags
)
.
expect
(
"
could
not
set
timer
"
)
;
match
timer
.
get
(
)
{
Ok
(
Some
(
exp
)
)
=
>
assert
!
(
matches
!
(
exp
Expiration
:
:
Interval
(
.
.
)
|
Expiration
:
:
IntervalDelayed
(
.
.
)
)
)
_
=
>
panic
!
(
"
timer
lost
its
expiration
"
)
}
let
starttime
=
Instant
:
:
now
(
)
;
loop
{
thread
:
:
sleep
(
2
*
TIMER_PERIOD
)
;
if
ALARM_CALLED
.
load
(
Ordering
:
:
Acquire
)
{
break
;
}
if
starttime
.
elapsed
(
)
>
Duration
:
:
from_secs
(
3
)
{
panic
!
(
"
Timeout
waiting
for
SIGALRM
"
)
;
}
}
drop
(
timer
)
;
thread
:
:
sleep
(
TIMER_PERIOD
)
;
unsafe
{
sigaction
(
SIG
&
old_handler
)
.
expect
(
"
unable
to
reset
signal
handler
"
)
;
}
}
