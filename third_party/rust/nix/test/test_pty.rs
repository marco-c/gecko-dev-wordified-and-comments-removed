use
std
:
:
io
:
:
Write
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
tempfile
:
:
tempfile
;
use
libc
:
:
{
_exit
STDOUT_FILENO
}
;
use
nix
:
:
fcntl
:
:
{
OFlag
open
}
;
use
nix
:
:
pty
:
:
*
;
use
nix
:
:
sys
:
:
stat
;
use
nix
:
:
sys
:
:
termios
:
:
*
;
use
nix
:
:
unistd
:
:
{
write
close
pause
}
;
#
[
test
]
fn
test_explicit_close
(
)
{
let
mut
f
=
{
let
m
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
unwrap
(
)
;
close
(
m
.
into_raw_fd
(
)
)
.
unwrap
(
)
;
tempfile
(
)
.
unwrap
(
)
}
;
f
.
write_all
(
b
"
whatever
"
)
.
unwrap
(
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptsname_equivalence
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
master_fd
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
unwrap
(
)
;
assert
!
(
master_fd
.
as_raw_fd
(
)
>
0
)
;
let
slave_name
=
unsafe
{
ptsname
(
&
master_fd
)
}
.
unwrap
(
)
;
let
slave_name_r
=
ptsname_r
(
&
master_fd
)
.
unwrap
(
)
;
assert_eq
!
(
slave_name
slave_name_r
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptsname_copy
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
master_fd
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
unwrap
(
)
;
assert
!
(
master_fd
.
as_raw_fd
(
)
>
0
)
;
let
slave_name1
=
unsafe
{
ptsname
(
&
master_fd
)
}
.
unwrap
(
)
;
let
slave_name2
=
unsafe
{
ptsname
(
&
master_fd
)
}
.
unwrap
(
)
;
assert
!
(
slave_name1
=
=
slave_name2
)
;
assert
!
(
slave_name1
.
as_ptr
(
)
!
=
slave_name2
.
as_ptr
(
)
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptsname_r_copy
(
)
{
let
master_fd
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
unwrap
(
)
;
assert
!
(
master_fd
.
as_raw_fd
(
)
>
0
)
;
let
slave_name1
=
ptsname_r
(
&
master_fd
)
.
unwrap
(
)
;
let
slave_name2
=
ptsname_r
(
&
master_fd
)
.
unwrap
(
)
;
assert
!
(
slave_name1
=
=
slave_name2
)
;
assert
!
(
slave_name1
.
as_ptr
(
)
!
=
slave_name2
.
as_ptr
(
)
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptsname_unique
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
master1_fd
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
unwrap
(
)
;
assert
!
(
master1_fd
.
as_raw_fd
(
)
>
0
)
;
let
master2_fd
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
unwrap
(
)
;
assert
!
(
master2_fd
.
as_raw_fd
(
)
>
0
)
;
let
slave_name1
=
unsafe
{
ptsname
(
&
master1_fd
)
}
.
unwrap
(
)
;
let
slave_name2
=
unsafe
{
ptsname
(
&
master2_fd
)
}
.
unwrap
(
)
;
assert
!
(
slave_name1
!
=
slave_name2
)
;
}
#
[
test
]
fn
test_open_ptty_pair
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
master_fd
=
posix_openpt
(
OFlag
:
:
O_RDWR
)
.
expect
(
"
posix_openpt
failed
"
)
;
assert
!
(
master_fd
.
as_raw_fd
(
)
>
0
)
;
grantpt
(
&
master_fd
)
.
expect
(
"
grantpt
failed
"
)
;
unlockpt
(
&
master_fd
)
.
expect
(
"
unlockpt
failed
"
)
;
let
slave_name
=
unsafe
{
ptsname
(
&
master_fd
)
}
.
expect
(
"
ptsname
failed
"
)
;
let
slave_fd
=
open
(
Path
:
:
new
(
&
slave_name
)
OFlag
:
:
O_RDWR
stat
:
:
Mode
:
:
empty
(
)
)
.
unwrap
(
)
;
assert
!
(
slave_fd
>
0
)
;
}
#
[
test
]
fn
test_openpty
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
pty
=
openpty
(
None
None
)
.
unwrap
(
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
string
=
"
foofoofoo
\
n
"
;
let
mut
buf
=
[
0u8
;
10
]
;
write
(
pty
.
master
string
.
as_bytes
(
)
)
.
unwrap
(
)
;
:
:
read_exact
(
pty
.
slave
&
mut
buf
)
;
assert_eq
!
(
&
buf
string
.
as_bytes
(
)
)
;
let
echoed_string
=
"
foofoofoo
\
r
\
n
"
;
let
mut
buf
=
[
0u8
;
11
]
;
:
:
read_exact
(
pty
.
master
&
mut
buf
)
;
assert_eq
!
(
&
buf
echoed_string
.
as_bytes
(
)
)
;
let
string2
=
"
barbarbarbar
\
n
"
;
let
echoed_string2
=
"
barbarbarbar
\
r
\
n
"
;
let
mut
buf
=
[
0u8
;
14
]
;
write
(
pty
.
slave
string2
.
as_bytes
(
)
)
.
unwrap
(
)
;
:
:
read_exact
(
pty
.
master
&
mut
buf
)
;
assert_eq
!
(
&
buf
echoed_string2
.
as_bytes
(
)
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_openpty_with_termios
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
mut
termios
=
{
let
pty
=
openpty
(
None
None
)
.
unwrap
(
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
termios
=
tcgetattr
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
termios
}
;
termios
.
output_flags
.
remove
(
OutputFlags
:
:
ONLCR
)
;
let
pty
=
openpty
(
None
&
termios
)
.
unwrap
(
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
string
=
"
foofoofoo
\
n
"
;
let
mut
buf
=
[
0u8
;
10
]
;
write
(
pty
.
master
string
.
as_bytes
(
)
)
.
unwrap
(
)
;
:
:
read_exact
(
pty
.
slave
&
mut
buf
)
;
assert_eq
!
(
&
buf
string
.
as_bytes
(
)
)
;
let
echoed_string
=
"
foofoofoo
\
n
"
;
:
:
read_exact
(
pty
.
master
&
mut
buf
)
;
assert_eq
!
(
&
buf
echoed_string
.
as_bytes
(
)
)
;
let
string2
=
"
barbarbarbar
\
n
"
;
let
echoed_string2
=
"
barbarbarbar
\
n
"
;
let
mut
buf
=
[
0u8
;
13
]
;
write
(
pty
.
slave
string2
.
as_bytes
(
)
)
.
unwrap
(
)
;
:
:
read_exact
(
pty
.
master
&
mut
buf
)
;
assert_eq
!
(
&
buf
echoed_string2
.
as_bytes
(
)
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_forkpty
(
)
{
use
nix
:
:
unistd
:
:
ForkResult
:
:
*
;
use
nix
:
:
sys
:
:
signal
:
:
*
;
use
nix
:
:
sys
:
:
wait
:
:
wait
;
let
_m0
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
_m1
=
:
:
FORK_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
string
=
"
naninani
\
n
"
;
let
echoed_string
=
"
naninani
\
r
\
n
"
;
let
pty
=
forkpty
(
None
None
)
.
unwrap
(
)
;
match
pty
.
fork_result
{
Child
=
>
{
write
(
STDOUT_FILENO
string
.
as_bytes
(
)
)
.
unwrap
(
)
;
pause
(
)
;
unsafe
{
_exit
(
0
)
;
}
}
Parent
{
child
}
=
>
{
let
mut
buf
=
[
0u8
;
10
]
;
assert
!
(
child
.
as_raw
(
)
>
0
)
;
:
:
read_exact
(
pty
.
master
&
mut
buf
)
;
kill
(
child
SIGTERM
)
.
unwrap
(
)
;
wait
(
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
echoed_string
.
as_bytes
(
)
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
}
}
}
