use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
tempfile
:
:
tempfile
;
use
nix
:
:
{
Error
fcntl
}
;
use
nix
:
:
errno
:
:
Errno
;
use
nix
:
:
pty
:
:
openpty
;
use
nix
:
:
sys
:
:
termios
:
:
{
self
LocalFlags
OutputFlags
Termios
tcgetattr
}
;
use
nix
:
:
unistd
:
:
{
read
write
close
}
;
fn
write_all
(
f
:
RawFd
buf
:
&
[
u8
]
)
{
let
mut
len
=
0
;
while
len
<
buf
.
len
(
)
{
len
+
=
write
(
f
&
buf
[
len
.
.
]
)
.
unwrap
(
)
;
}
}
#
[
test
]
fn
test_tcgetattr_pty
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
pty
=
openpty
(
None
None
)
.
expect
(
"
openpty
failed
"
)
;
assert
!
(
termios
:
:
tcgetattr
(
pty
.
master
)
.
is_ok
(
)
)
;
close
(
pty
.
master
)
.
expect
(
"
closing
the
master
failed
"
)
;
close
(
pty
.
slave
)
.
expect
(
"
closing
the
slave
failed
"
)
;
}
#
[
test
]
fn
test_tcgetattr_enotty
(
)
{
let
file
=
tempfile
(
)
.
unwrap
(
)
;
assert_eq
!
(
termios
:
:
tcgetattr
(
file
.
as_raw_fd
(
)
)
.
err
(
)
Some
(
Error
:
:
Sys
(
Errno
:
:
ENOTTY
)
)
)
;
}
#
[
test
]
fn
test_tcgetattr_ebadf
(
)
{
assert_eq
!
(
termios
:
:
tcgetattr
(
-
1
)
.
err
(
)
Some
(
Error
:
:
Sys
(
Errno
:
:
EBADF
)
)
)
;
}
#
[
test
]
fn
test_output_flags
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
mut
termios
=
{
let
pty
=
openpty
(
None
None
)
.
expect
(
"
openpty
failed
"
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
termios
=
tcgetattr
(
pty
.
master
)
.
expect
(
"
tcgetattr
failed
"
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
termios
}
;
assert
!
(
!
termios
.
output_flags
.
contains
(
OutputFlags
:
:
OPOST
|
OutputFlags
:
:
OCRNL
)
)
;
termios
.
output_flags
.
insert
(
OutputFlags
:
:
OPOST
|
OutputFlags
:
:
OCRNL
)
;
let
pty
=
openpty
(
None
&
termios
)
.
unwrap
(
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
string
=
"
foofoofoo
\
r
"
;
write_all
(
pty
.
master
string
.
as_bytes
(
)
)
;
let
mut
buf
=
[
0u8
;
10
]
;
:
:
read_exact
(
pty
.
slave
&
mut
buf
)
;
let
transformed_string
=
"
foofoofoo
\
n
"
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
transformed_string
.
as_bytes
(
)
)
;
}
#
[
test
]
fn
test_local_flags
(
)
{
let
_m
=
:
:
PTSNAME_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
mut
termios
=
{
let
pty
=
openpty
(
None
None
)
.
unwrap
(
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
termios
=
tcgetattr
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
termios
}
;
assert
!
(
termios
.
local_flags
.
contains
(
LocalFlags
:
:
ECHO
)
)
;
termios
.
local_flags
.
remove
(
LocalFlags
:
:
ECHO
)
;
let
pty
=
openpty
(
None
&
termios
)
.
unwrap
(
)
;
assert
!
(
pty
.
master
>
0
)
;
assert
!
(
pty
.
slave
>
0
)
;
let
flags
=
fcntl
:
:
fcntl
(
pty
.
master
fcntl
:
:
F_GETFL
)
.
unwrap
(
)
;
let
new_flags
=
fcntl
:
:
OFlag
:
:
from_bits_truncate
(
flags
)
|
fcntl
:
:
OFlag
:
:
O_NONBLOCK
;
fcntl
:
:
fcntl
(
pty
.
master
fcntl
:
:
F_SETFL
(
new_flags
)
)
.
unwrap
(
)
;
let
string
=
"
foofoofoo
\
r
"
;
write_all
(
pty
.
master
string
.
as_bytes
(
)
)
;
let
mut
buf
=
[
0u8
;
10
]
;
let
read
=
read
(
pty
.
master
&
mut
buf
)
.
unwrap_err
(
)
;
close
(
pty
.
master
)
.
unwrap
(
)
;
close
(
pty
.
slave
)
.
unwrap
(
)
;
assert_eq
!
(
read
Error
:
:
Sys
(
Errno
:
:
EAGAIN
)
)
;
}
#
[
test
]
fn
test_cfmakeraw
(
)
{
let
mut
termios
=
unsafe
{
Termios
:
:
default_uninit
(
)
}
;
termios
:
:
cfmakeraw
(
&
mut
termios
)
;
}
