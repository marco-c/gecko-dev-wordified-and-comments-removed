use
nix
:
:
Error
;
use
nix
:
:
errno
:
:
Errno
;
use
nix
:
:
unistd
:
:
getpid
;
use
nix
:
:
sys
:
:
ptrace
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
use
nix
:
:
sys
:
:
ptrace
:
:
Options
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
use
std
:
:
mem
;
#
[
test
]
fn
test_ptrace
(
)
{
let
err
=
ptrace
:
:
attach
(
getpid
(
)
)
.
unwrap_err
(
)
;
assert
!
(
err
=
=
Error
:
:
Sys
(
Errno
:
:
EPERM
)
|
|
err
=
=
Error
:
:
Sys
(
Errno
:
:
EINVAL
)
|
|
err
=
=
Error
:
:
Sys
(
Errno
:
:
ENOSYS
)
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptrace_setoptions
(
)
{
let
err
=
ptrace
:
:
setoptions
(
getpid
(
)
Options
:
:
PTRACE_O_TRACESYSGOOD
)
.
unwrap_err
(
)
;
assert
!
(
err
!
=
Error
:
:
UnsupportedOperation
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptrace_getevent
(
)
{
let
err
=
ptrace
:
:
getevent
(
getpid
(
)
)
.
unwrap_err
(
)
;
assert
!
(
err
!
=
Error
:
:
UnsupportedOperation
)
;
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptrace_getsiginfo
(
)
{
if
let
Err
(
Error
:
:
UnsupportedOperation
)
=
ptrace
:
:
getsiginfo
(
getpid
(
)
)
{
panic
!
(
"
ptrace_getsiginfo
returns
Error
:
:
UnsupportedOperation
!
"
)
;
}
}
#
[
test
]
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
test_ptrace_setsiginfo
(
)
{
let
siginfo
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
if
let
Err
(
Error
:
:
UnsupportedOperation
)
=
ptrace
:
:
setsiginfo
(
getpid
(
)
&
siginfo
)
{
panic
!
(
"
ptrace_setsiginfo
returns
Error
:
:
UnsupportedOperation
!
"
)
;
}
}
#
[
test
]
fn
test_ptrace_cont
(
)
{
use
nix
:
:
sys
:
:
ptrace
;
use
nix
:
:
sys
:
:
signal
:
:
{
raise
Signal
}
;
use
nix
:
:
sys
:
:
wait
:
:
{
waitpid
WaitPidFlag
WaitStatus
}
;
use
nix
:
:
unistd
:
:
fork
;
use
nix
:
:
unistd
:
:
ForkResult
:
:
*
;
let
_m
=
:
:
FORK_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
let
err
=
ptrace
:
:
attach
(
getpid
(
)
)
.
unwrap_err
(
)
;
if
err
=
=
Error
:
:
Sys
(
Errno
:
:
ENOSYS
)
{
return
;
}
match
fork
(
)
.
expect
(
"
Error
:
Fork
Failed
"
)
{
Child
=
>
{
ptrace
:
:
traceme
(
)
.
unwrap
(
)
;
loop
{
raise
(
Signal
:
:
SIGTRAP
)
.
unwrap
(
)
;
}
}
Parent
{
child
}
=
>
{
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
Stopped
(
child
Signal
:
:
SIGTRAP
)
)
)
;
ptrace
:
:
cont
(
child
None
)
.
unwrap
(
)
;
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
Stopped
(
child
Signal
:
:
SIGTRAP
)
)
)
;
ptrace
:
:
cont
(
child
Some
(
Signal
:
:
SIGKILL
)
)
.
unwrap
(
)
;
match
waitpid
(
child
None
)
{
Ok
(
WaitStatus
:
:
Signaled
(
pid
Signal
:
:
SIGKILL
_
)
)
if
pid
=
=
child
=
>
{
let
_
=
waitpid
(
child
Some
(
WaitPidFlag
:
:
WNOHANG
)
)
;
while
ptrace
:
:
cont
(
child
Some
(
Signal
:
:
SIGKILL
)
)
.
is_ok
(
)
{
let
_
=
waitpid
(
child
Some
(
WaitPidFlag
:
:
WNOHANG
)
)
;
}
}
_
=
>
panic
!
(
"
The
process
should
have
been
killed
"
)
}
}
}
}
