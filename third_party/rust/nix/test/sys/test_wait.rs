use
nix
:
:
Error
;
use
nix
:
:
unistd
:
:
*
;
use
nix
:
:
unistd
:
:
ForkResult
:
:
*
;
use
nix
:
:
sys
:
:
signal
:
:
*
;
use
nix
:
:
sys
:
:
wait
:
:
*
;
use
libc
:
:
_exit
;
#
[
test
]
fn
test_wait_signal
(
)
{
let
_
=
:
:
FORK_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
match
fork
(
)
.
expect
(
"
Error
:
Fork
Failed
"
)
{
Child
=
>
{
pause
(
)
;
unsafe
{
_exit
(
123
)
}
}
Parent
{
child
}
=
>
{
kill
(
child
Some
(
SIGKILL
)
)
.
expect
(
"
Error
:
Kill
Failed
"
)
;
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
Signaled
(
child
SIGKILL
false
)
)
)
;
}
}
}
#
[
test
]
fn
test_wait_exit
(
)
{
let
_m
=
:
:
FORK_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
match
fork
(
)
.
expect
(
"
Error
:
Fork
Failed
"
)
{
Child
=
>
unsafe
{
_exit
(
12
)
;
}
Parent
{
child
}
=
>
{
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
Exited
(
child
12
)
)
)
;
}
}
}
#
[
test
]
fn
test_waitstatus_from_raw
(
)
{
let
pid
=
Pid
:
:
from_raw
(
1
)
;
assert_eq
!
(
WaitStatus
:
:
from_raw
(
pid
0x0002
)
Ok
(
WaitStatus
:
:
Signaled
(
pid
Signal
:
:
SIGINT
false
)
)
)
;
assert_eq
!
(
WaitStatus
:
:
from_raw
(
pid
0x0200
)
Ok
(
WaitStatus
:
:
Exited
(
pid
2
)
)
)
;
assert_eq
!
(
WaitStatus
:
:
from_raw
(
pid
0x7f7f
)
Err
(
Error
:
:
invalid_argument
(
)
)
)
;
}
#
[
test
]
fn
test_waitstatus_pid
(
)
{
let
_m
=
:
:
FORK_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
match
fork
(
)
.
unwrap
(
)
{
Child
=
>
unsafe
{
_exit
(
0
)
}
Parent
{
child
}
=
>
{
let
status
=
waitpid
(
child
None
)
.
unwrap
(
)
;
assert_eq
!
(
status
.
pid
(
)
Some
(
child
)
)
;
}
}
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
#
[
cfg
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
]
mod
ptrace
{
use
nix
:
:
sys
:
:
ptrace
:
:
{
self
Options
Event
}
;
use
nix
:
:
sys
:
:
signal
:
:
*
;
use
nix
:
:
sys
:
:
wait
:
:
*
;
use
nix
:
:
unistd
:
:
*
;
use
nix
:
:
unistd
:
:
ForkResult
:
:
*
;
use
libc
:
:
_exit
;
fn
ptrace_child
(
)
-
>
!
{
ptrace
:
:
traceme
(
)
.
unwrap
(
)
;
raise
(
SIGTRAP
)
.
unwrap
(
)
;
unsafe
{
_exit
(
0
)
}
}
fn
ptrace_parent
(
child
:
Pid
)
{
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
Stopped
(
child
SIGTRAP
)
)
)
;
assert
!
(
ptrace
:
:
setoptions
(
child
Options
:
:
PTRACE_O_TRACESYSGOOD
|
Options
:
:
PTRACE_O_TRACEEXIT
)
.
is_ok
(
)
)
;
assert
!
(
ptrace
:
:
syscall
(
child
)
.
is_ok
(
)
)
;
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
PtraceSyscall
(
child
)
)
)
;
assert
!
(
ptrace
:
:
cont
(
child
None
)
.
is_ok
(
)
)
;
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
PtraceEvent
(
child
SIGTRAP
Event
:
:
PTRACE_EVENT_EXIT
as
i32
)
)
)
;
assert
!
(
ptrace
:
:
cont
(
child
None
)
.
is_ok
(
)
)
;
assert_eq
!
(
waitpid
(
child
None
)
Ok
(
WaitStatus
:
:
Exited
(
child
0
)
)
)
;
}
#
[
test
]
fn
test_wait_ptrace
(
)
{
let
_m
=
:
:
FORK_MTX
.
lock
(
)
.
expect
(
"
Mutex
got
poisoned
by
another
test
"
)
;
match
fork
(
)
.
expect
(
"
Error
:
Fork
Failed
"
)
{
Child
=
>
ptrace_child
(
)
Parent
{
child
}
=
>
ptrace_parent
(
child
)
}
}
}
