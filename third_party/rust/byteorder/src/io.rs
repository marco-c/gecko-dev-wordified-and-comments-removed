use
std
:
:
io
:
:
{
self
Result
}
;
use
std
:
:
slice
;
use
ByteOrder
;
pub
trait
ReadBytesExt
:
io
:
:
Read
{
#
[
inline
]
fn
read_u8
(
&
mut
self
)
-
>
Result
<
u8
>
{
let
mut
buf
=
[
0
;
1
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
buf
[
0
]
)
}
#
[
inline
]
fn
read_i8
(
&
mut
self
)
-
>
Result
<
i8
>
{
let
mut
buf
=
[
0
;
1
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
buf
[
0
]
as
i8
)
}
#
[
inline
]
fn
read_u16
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
u16
>
{
let
mut
buf
=
[
0
;
2
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_u16
(
&
buf
)
)
}
#
[
inline
]
fn
read_i16
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
i16
>
{
let
mut
buf
=
[
0
;
2
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_i16
(
&
buf
)
)
}
#
[
inline
]
fn
read_u24
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
u32
>
{
let
mut
buf
=
[
0
;
3
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_u24
(
&
buf
)
)
}
#
[
inline
]
fn
read_i24
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
i32
>
{
let
mut
buf
=
[
0
;
3
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_i24
(
&
buf
)
)
}
#
[
inline
]
fn
read_u32
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
u32
>
{
let
mut
buf
=
[
0
;
4
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_u32
(
&
buf
)
)
}
#
[
inline
]
fn
read_i32
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
i32
>
{
let
mut
buf
=
[
0
;
4
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_i32
(
&
buf
)
)
}
#
[
inline
]
fn
read_u48
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
u64
>
{
let
mut
buf
=
[
0
;
6
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_u48
(
&
buf
)
)
}
#
[
inline
]
fn
read_i48
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
i64
>
{
let
mut
buf
=
[
0
;
6
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_i48
(
&
buf
)
)
}
#
[
inline
]
fn
read_u64
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
u64
>
{
let
mut
buf
=
[
0
;
8
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_u64
(
&
buf
)
)
}
#
[
inline
]
fn
read_i64
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
i64
>
{
let
mut
buf
=
[
0
;
8
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_i64
(
&
buf
)
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
read_u128
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
u128
>
{
let
mut
buf
=
[
0
;
16
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_u128
(
&
buf
)
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
read_i128
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
i128
>
{
let
mut
buf
=
[
0
;
16
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_i128
(
&
buf
)
)
}
#
[
inline
]
fn
read_uint
<
T
:
ByteOrder
>
(
&
mut
self
nbytes
:
usize
)
-
>
Result
<
u64
>
{
let
mut
buf
=
[
0
;
8
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
[
.
.
nbytes
]
)
)
;
Ok
(
T
:
:
read_uint
(
&
buf
[
.
.
nbytes
]
nbytes
)
)
}
#
[
inline
]
fn
read_int
<
T
:
ByteOrder
>
(
&
mut
self
nbytes
:
usize
)
-
>
Result
<
i64
>
{
let
mut
buf
=
[
0
;
8
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
[
.
.
nbytes
]
)
)
;
Ok
(
T
:
:
read_int
(
&
buf
[
.
.
nbytes
]
nbytes
)
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
read_uint128
<
T
:
ByteOrder
>
(
&
mut
self
nbytes
:
usize
)
-
>
Result
<
u128
>
{
let
mut
buf
=
[
0
;
16
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
[
.
.
nbytes
]
)
)
;
Ok
(
T
:
:
read_uint128
(
&
buf
[
.
.
nbytes
]
nbytes
)
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
read_int128
<
T
:
ByteOrder
>
(
&
mut
self
nbytes
:
usize
)
-
>
Result
<
i128
>
{
let
mut
buf
=
[
0
;
16
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
[
.
.
nbytes
]
)
)
;
Ok
(
T
:
:
read_int128
(
&
buf
[
.
.
nbytes
]
nbytes
)
)
}
#
[
inline
]
fn
read_f32
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
f32
>
{
let
mut
buf
=
[
0
;
4
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_f32
(
&
buf
)
)
}
#
[
inline
]
fn
read_f64
<
T
:
ByteOrder
>
(
&
mut
self
)
-
>
Result
<
f64
>
{
let
mut
buf
=
[
0
;
8
]
;
try
!
(
self
.
read_exact
(
&
mut
buf
)
)
;
Ok
(
T
:
:
read_f64
(
&
buf
)
)
}
#
[
inline
]
fn
read_u16_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
u16
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_u16
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
read_u32_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
u32
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_u32
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
read_u64_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
u64
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_u64
(
dst
)
;
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
read_u128_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
u128
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_u128
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
read_i16_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
i16
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_i16
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
read_i32_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
i32
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_i32
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
read_i64_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
i64
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_i64
(
dst
)
;
Ok
(
(
)
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
read_i128_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
i128
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_i128
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
read_f32_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
f32
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_f32
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
#
[
deprecated
(
since
=
"
1
.
2
.
0
"
note
=
"
please
use
read_f32_into
instead
"
)
]
fn
read_f32_into_unchecked
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
f32
]
)
-
>
Result
<
(
)
>
{
self
.
read_f32_into
:
:
<
T
>
(
dst
)
}
#
[
inline
]
fn
read_f64_into
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
f64
]
)
-
>
Result
<
(
)
>
{
{
let
buf
=
unsafe
{
slice_to_u8_mut
(
dst
)
}
;
try
!
(
self
.
read_exact
(
buf
)
)
;
}
T
:
:
from_slice_f64
(
dst
)
;
Ok
(
(
)
)
}
#
[
inline
]
#
[
deprecated
(
since
=
"
1
.
2
.
0
"
note
=
"
please
use
read_f64_into
instead
"
)
]
fn
read_f64_into_unchecked
<
T
:
ByteOrder
>
(
&
mut
self
dst
:
&
mut
[
f64
]
)
-
>
Result
<
(
)
>
{
self
.
read_f64_into
:
:
<
T
>
(
dst
)
}
}
impl
<
R
:
io
:
:
Read
+
?
Sized
>
ReadBytesExt
for
R
{
}
pub
trait
WriteBytesExt
:
io
:
:
Write
{
#
[
inline
]
fn
write_u8
(
&
mut
self
n
:
u8
)
-
>
Result
<
(
)
>
{
self
.
write_all
(
&
[
n
]
)
}
#
[
inline
]
fn
write_i8
(
&
mut
self
n
:
i8
)
-
>
Result
<
(
)
>
{
self
.
write_all
(
&
[
n
as
u8
]
)
}
#
[
inline
]
fn
write_u16
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u16
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
2
]
;
T
:
:
write_u16
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_i16
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i16
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
2
]
;
T
:
:
write_i16
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_u24
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u32
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
3
]
;
T
:
:
write_u24
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_i24
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i32
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
3
]
;
T
:
:
write_i24
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_u32
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u32
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
4
]
;
T
:
:
write_u32
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_i32
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i32
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
4
]
;
T
:
:
write_i32
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_u48
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u64
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
6
]
;
T
:
:
write_u48
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_i48
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i64
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
6
]
;
T
:
:
write_i48
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_u64
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u64
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_u64
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_i64
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i64
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_i64
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
write_u128
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u128
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
16
]
;
T
:
:
write_u128
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
write_i128
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i128
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
16
]
;
T
:
:
write_i128
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_uint
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u64
nbytes
:
usize
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_uint
(
&
mut
buf
n
nbytes
)
;
self
.
write_all
(
&
buf
[
0
.
.
nbytes
]
)
}
#
[
inline
]
fn
write_int
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i64
nbytes
:
usize
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_int
(
&
mut
buf
n
nbytes
)
;
self
.
write_all
(
&
buf
[
0
.
.
nbytes
]
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
write_uint128
<
T
:
ByteOrder
>
(
&
mut
self
n
:
u128
nbytes
:
usize
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
16
]
;
T
:
:
write_uint128
(
&
mut
buf
n
nbytes
)
;
self
.
write_all
(
&
buf
[
0
.
.
nbytes
]
)
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
write_int128
<
T
:
ByteOrder
>
(
&
mut
self
n
:
i128
nbytes
:
usize
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
16
]
;
T
:
:
write_int128
(
&
mut
buf
n
nbytes
)
;
self
.
write_all
(
&
buf
[
0
.
.
nbytes
]
)
}
#
[
inline
]
fn
write_f32
<
T
:
ByteOrder
>
(
&
mut
self
n
:
f32
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
4
]
;
T
:
:
write_f32
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
#
[
inline
]
fn
write_f64
<
T
:
ByteOrder
>
(
&
mut
self
n
:
f64
)
-
>
Result
<
(
)
>
{
let
mut
buf
=
[
0
;
8
]
;
T
:
:
write_f64
(
&
mut
buf
n
)
;
self
.
write_all
(
&
buf
)
}
}
impl
<
W
:
io
:
:
Write
+
?
Sized
>
WriteBytesExt
for
W
{
}
unsafe
fn
slice_to_u8_mut
<
T
:
Copy
>
(
slice
:
&
mut
[
T
]
)
-
>
&
mut
[
u8
]
{
use
std
:
:
mem
:
:
size_of
;
let
len
=
size_of
:
:
<
T
>
(
)
*
slice
.
len
(
)
;
slice
:
:
from_raw_parts_mut
(
slice
.
as_mut_ptr
(
)
as
*
mut
u8
len
)
}
