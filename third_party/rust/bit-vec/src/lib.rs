#
!
[
cfg_attr
(
all
(
test
feature
=
"
nightly
"
)
feature
(
test
)
)
]
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
extern
crate
test
;
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
extern
crate
rand
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
std
:
:
hash
;
use
std
:
:
iter
:
:
{
Chain
Enumerate
Repeat
Skip
Take
repeat
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
slice
;
use
std
:
:
{
u8
usize
}
;
type
MutBlocks
<
'
a
B
>
=
slice
:
:
IterMut
<
'
a
B
>
;
type
MatchWords
<
'
a
B
>
=
Chain
<
Enumerate
<
Blocks
<
'
a
B
>
>
Skip
<
Take
<
Enumerate
<
Repeat
<
B
>
>
>
>
>
;
use
std
:
:
ops
:
:
*
;
pub
trait
BitBlock
:
Copy
+
Add
<
Self
Output
=
Self
>
+
Sub
<
Self
Output
=
Self
>
+
Shl
<
usize
Output
=
Self
>
+
Shr
<
usize
Output
=
Self
>
+
Not
<
Output
=
Self
>
+
BitAnd
<
Self
Output
=
Self
>
+
BitOr
<
Self
Output
=
Self
>
+
BitXor
<
Self
Output
=
Self
>
+
Rem
<
Self
Output
=
Self
>
+
Eq
+
Ord
+
hash
:
:
Hash
+
{
fn
bits
(
)
-
>
usize
;
#
[
inline
]
fn
bytes
(
)
-
>
usize
{
Self
:
:
bits
(
)
/
8
}
fn
from_byte
(
byte
:
u8
)
-
>
Self
;
fn
count_ones
(
self
)
-
>
usize
;
fn
zero
(
)
-
>
Self
;
fn
one
(
)
-
>
Self
;
}
macro_rules
!
bit_block_impl
{
(
(
(
t
:
ty
size
:
expr
)
)
*
)
=
>
(
(
impl
BitBlock
for
t
{
#
[
inline
]
fn
bits
(
)
-
>
usize
{
size
}
#
[
inline
]
fn
from_byte
(
byte
:
u8
)
-
>
Self
{
byte
as
t
}
#
[
inline
]
fn
count_ones
(
self
)
-
>
usize
{
self
.
count_ones
(
)
as
usize
}
#
[
inline
]
fn
one
(
)
-
>
Self
{
1
}
#
[
inline
]
fn
zero
(
)
-
>
Self
{
0
}
}
)
*
)
}
bit_block_impl
!
{
(
u8
8
)
(
u16
16
)
(
u32
32
)
(
u64
64
)
(
usize
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
*
8
)
}
fn
reverse_bits
(
byte
:
u8
)
-
>
u8
{
let
mut
result
=
0
;
for
i
in
0
.
.
u8
:
:
bits
(
)
{
result
=
result
|
(
(
byte
>
>
i
)
&
1
)
<
<
(
u8
:
:
bits
(
)
-
1
-
i
)
;
}
result
}
static
TRUE
:
bool
=
true
;
static
FALSE
:
bool
=
false
;
pub
struct
BitVec
<
B
=
u32
>
{
storage
:
Vec
<
B
>
nbits
:
usize
}
impl
<
B
:
BitBlock
>
Index
<
usize
>
for
BitVec
<
B
>
{
type
Output
=
bool
;
#
[
inline
]
fn
index
(
&
self
i
:
usize
)
-
>
&
bool
{
if
self
.
get
(
i
)
.
expect
(
"
index
out
of
bounds
"
)
{
&
TRUE
}
else
{
&
FALSE
}
}
}
fn
blocks_for_bits
<
B
:
BitBlock
>
(
bits
:
usize
)
-
>
usize
{
if
bits
%
B
:
:
bits
(
)
=
=
0
{
bits
/
B
:
:
bits
(
)
}
else
{
bits
/
B
:
:
bits
(
)
+
1
}
}
fn
mask_for_bits
<
B
:
BitBlock
>
(
bits
:
usize
)
-
>
B
{
(
!
B
:
:
zero
(
)
)
>
>
(
(
B
:
:
bits
(
)
-
bits
%
B
:
:
bits
(
)
)
%
B
:
:
bits
(
)
)
}
type
B
=
u32
;
impl
BitVec
<
u32
>
{
pub
fn
new
(
)
-
>
Self
{
Default
:
:
default
(
)
}
pub
fn
from_elem
(
nbits
:
usize
bit
:
bool
)
-
>
Self
{
let
nblocks
=
blocks_for_bits
:
:
<
B
>
(
nbits
)
;
let
mut
bit_vec
=
BitVec
{
storage
:
vec
!
[
if
bit
{
!
B
:
:
zero
(
)
}
else
{
B
:
:
zero
(
)
}
;
nblocks
]
nbits
:
nbits
}
;
bit_vec
.
fix_last_block
(
)
;
bit_vec
}
pub
fn
with_capacity
(
nbits
:
usize
)
-
>
Self
{
BitVec
{
storage
:
Vec
:
:
with_capacity
(
blocks_for_bits
:
:
<
B
>
(
nbits
)
)
nbits
:
0
}
}
pub
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
Self
{
let
len
=
bytes
.
len
(
)
.
checked_mul
(
u8
:
:
bits
(
)
)
.
expect
(
"
capacity
overflow
"
)
;
let
mut
bit_vec
=
BitVec
:
:
with_capacity
(
len
)
;
let
complete_words
=
bytes
.
len
(
)
/
B
:
:
bytes
(
)
;
let
extra_bytes
=
bytes
.
len
(
)
%
B
:
:
bytes
(
)
;
bit_vec
.
nbits
=
len
;
for
i
in
0
.
.
complete_words
{
let
mut
accumulator
=
B
:
:
zero
(
)
;
for
idx
in
0
.
.
B
:
:
bytes
(
)
{
accumulator
=
accumulator
|
(
B
:
:
from_byte
(
reverse_bits
(
bytes
[
i
*
B
:
:
bytes
(
)
+
idx
]
)
)
<
<
(
idx
*
8
)
)
}
bit_vec
.
storage
.
push
(
accumulator
)
;
}
if
extra_bytes
>
0
{
let
mut
last_word
=
B
:
:
zero
(
)
;
for
(
i
&
byte
)
in
bytes
[
complete_words
*
B
:
:
bytes
(
)
.
.
]
.
iter
(
)
.
enumerate
(
)
{
last_word
=
last_word
|
(
B
:
:
from_byte
(
reverse_bits
(
byte
)
)
<
<
(
i
*
8
)
)
;
}
bit_vec
.
storage
.
push
(
last_word
)
;
}
bit_vec
}
pub
fn
from_fn
<
F
>
(
len
:
usize
mut
f
:
F
)
-
>
Self
where
F
:
FnMut
(
usize
)
-
>
bool
{
let
mut
bit_vec
=
BitVec
:
:
from_elem
(
len
false
)
;
for
i
in
0
.
.
len
{
bit_vec
.
set
(
i
f
(
i
)
)
;
}
bit_vec
}
}
impl
<
B
:
BitBlock
>
BitVec
<
B
>
{
#
[
inline
]
fn
process
<
F
>
(
&
mut
self
other
:
&
BitVec
<
B
>
mut
op
:
F
)
-
>
bool
where
F
:
FnMut
(
B
B
)
-
>
B
{
assert_eq
!
(
self
.
len
(
)
other
.
len
(
)
)
;
assert_eq
!
(
self
.
storage
.
len
(
)
other
.
storage
.
len
(
)
)
;
let
mut
changed_bits
=
B
:
:
zero
(
)
;
for
(
a
b
)
in
self
.
blocks_mut
(
)
.
zip
(
other
.
blocks
(
)
)
{
let
w
=
op
(
*
a
b
)
;
changed_bits
=
changed_bits
|
(
*
a
^
w
)
;
*
a
=
w
;
}
changed_bits
!
=
B
:
:
zero
(
)
}
fn
blocks_mut
(
&
mut
self
)
-
>
MutBlocks
<
B
>
{
self
.
storage
.
iter_mut
(
)
}
pub
fn
blocks
(
&
self
)
-
>
Blocks
<
B
>
{
Blocks
{
iter
:
self
.
storage
.
iter
(
)
}
}
pub
fn
storage
(
&
self
)
-
>
&
[
B
]
{
&
self
.
storage
}
pub
unsafe
fn
storage_mut
(
&
mut
self
)
-
>
&
mut
Vec
<
B
>
{
&
mut
self
.
storage
}
fn
fix_last_block
(
&
mut
self
)
{
let
extra_bits
=
self
.
len
(
)
%
B
:
:
bits
(
)
;
if
extra_bits
>
0
{
let
mask
=
(
B
:
:
one
(
)
<
<
extra_bits
)
-
B
:
:
one
(
)
;
let
storage_len
=
self
.
storage
.
len
(
)
;
let
block
=
&
mut
self
.
storage
[
storage_len
-
1
]
;
*
block
=
*
block
&
mask
;
}
}
#
[
inline
]
pub
fn
get
(
&
self
i
:
usize
)
-
>
Option
<
bool
>
{
if
i
>
=
self
.
nbits
{
return
None
;
}
let
w
=
i
/
B
:
:
bits
(
)
;
let
b
=
i
%
B
:
:
bits
(
)
;
self
.
storage
.
get
(
w
)
.
map
(
|
&
block
|
(
block
&
(
B
:
:
one
(
)
<
<
b
)
)
!
=
B
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
set
(
&
mut
self
i
:
usize
x
:
bool
)
{
assert
!
(
i
<
self
.
nbits
"
index
out
of
bounds
:
{
:
?
}
>
=
{
:
?
}
"
i
self
.
nbits
)
;
let
w
=
i
/
B
:
:
bits
(
)
;
let
b
=
i
%
B
:
:
bits
(
)
;
let
flag
=
B
:
:
one
(
)
<
<
b
;
let
val
=
if
x
{
self
.
storage
[
w
]
|
flag
}
else
{
self
.
storage
[
w
]
&
!
flag
}
;
self
.
storage
[
w
]
=
val
;
}
#
[
inline
]
pub
fn
set_all
(
&
mut
self
)
{
for
w
in
&
mut
self
.
storage
{
*
w
=
!
B
:
:
zero
(
)
;
}
self
.
fix_last_block
(
)
;
}
#
[
inline
]
pub
fn
negate
(
&
mut
self
)
{
for
w
in
&
mut
self
.
storage
{
*
w
=
!
*
w
;
}
self
.
fix_last_block
(
)
;
}
#
[
inline
]
pub
fn
union
(
&
mut
self
other
:
&
Self
)
-
>
bool
{
self
.
process
(
other
|
w1
w2
|
(
w1
|
w2
)
)
}
#
[
inline
]
pub
fn
intersect
(
&
mut
self
other
:
&
Self
)
-
>
bool
{
self
.
process
(
other
|
w1
w2
|
(
w1
&
w2
)
)
}
#
[
inline
]
pub
fn
difference
(
&
mut
self
other
:
&
Self
)
-
>
bool
{
self
.
process
(
other
|
w1
w2
|
(
w1
&
!
w2
)
)
}
pub
fn
all
(
&
self
)
-
>
bool
{
let
mut
last_word
=
!
B
:
:
zero
(
)
;
self
.
blocks
(
)
.
all
(
|
elem
|
{
let
tmp
=
last_word
;
last_word
=
elem
;
tmp
=
=
!
B
:
:
zero
(
)
}
)
&
&
(
last_word
=
=
mask_for_bits
(
self
.
nbits
)
)
}
#
[
inline
]
pub
fn
iter
(
&
self
)
-
>
Iter
<
B
>
{
Iter
{
bit_vec
:
self
range
:
0
.
.
self
.
nbits
}
}
pub
fn
none
(
&
self
)
-
>
bool
{
self
.
blocks
(
)
.
all
(
|
w
|
w
=
=
B
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
any
(
&
self
)
-
>
bool
{
!
self
.
none
(
)
}
pub
fn
to_bytes
(
&
self
)
-
>
Vec
<
u8
>
{
fn
bit
<
B
:
BitBlock
>
(
bit_vec
:
&
BitVec
<
B
>
byte
:
usize
bit
:
usize
)
-
>
u8
{
let
offset
=
byte
*
8
+
bit
;
if
offset
>
=
bit_vec
.
nbits
{
0
}
else
{
(
bit_vec
[
offset
]
as
u8
)
<
<
(
7
-
bit
)
}
}
let
len
=
self
.
nbits
/
8
+
if
self
.
nbits
%
8
=
=
0
{
0
}
else
{
1
}
;
(
0
.
.
len
)
.
map
(
|
i
|
bit
(
self
i
0
)
|
bit
(
self
i
1
)
|
bit
(
self
i
2
)
|
bit
(
self
i
3
)
|
bit
(
self
i
4
)
|
bit
(
self
i
5
)
|
bit
(
self
i
6
)
|
bit
(
self
i
7
)
)
.
collect
(
)
}
pub
fn
eq_vec
(
&
self
v
:
&
[
bool
]
)
-
>
bool
{
assert_eq
!
(
self
.
nbits
v
.
len
(
)
)
;
self
.
iter
(
)
.
zip
(
v
.
iter
(
)
.
cloned
(
)
)
.
all
(
|
(
b1
b2
)
|
b1
=
=
b2
)
}
pub
fn
truncate
(
&
mut
self
len
:
usize
)
{
if
len
<
self
.
len
(
)
{
self
.
nbits
=
len
;
self
.
storage
.
truncate
(
blocks_for_bits
:
:
<
B
>
(
len
)
)
;
self
.
fix_last_block
(
)
;
}
}
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
let
desired_cap
=
self
.
len
(
)
.
checked_add
(
additional
)
.
expect
(
"
capacity
overflow
"
)
;
let
storage_len
=
self
.
storage
.
len
(
)
;
if
desired_cap
>
self
.
capacity
(
)
{
self
.
storage
.
reserve
(
blocks_for_bits
:
:
<
B
>
(
desired_cap
)
-
storage_len
)
;
}
}
pub
fn
reserve_exact
(
&
mut
self
additional
:
usize
)
{
let
desired_cap
=
self
.
len
(
)
.
checked_add
(
additional
)
.
expect
(
"
capacity
overflow
"
)
;
let
storage_len
=
self
.
storage
.
len
(
)
;
if
desired_cap
>
self
.
capacity
(
)
{
self
.
storage
.
reserve_exact
(
blocks_for_bits
:
:
<
B
>
(
desired_cap
)
-
storage_len
)
;
}
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
storage
.
capacity
(
)
.
checked_mul
(
B
:
:
bits
(
)
)
.
unwrap_or
(
usize
:
:
MAX
)
}
pub
fn
grow
(
&
mut
self
n
:
usize
value
:
bool
)
{
let
new_nbits
=
self
.
nbits
.
checked_add
(
n
)
.
expect
(
"
capacity
overflow
"
)
;
let
new_nblocks
=
blocks_for_bits
:
:
<
B
>
(
new_nbits
)
;
let
full_value
=
if
value
{
!
B
:
:
zero
(
)
}
else
{
B
:
:
zero
(
)
}
;
let
num_cur_blocks
=
blocks_for_bits
:
:
<
B
>
(
self
.
nbits
)
;
if
self
.
nbits
%
B
:
:
bits
(
)
>
0
{
let
mask
=
mask_for_bits
:
:
<
B
>
(
self
.
nbits
)
;
if
value
{
let
block
=
&
mut
self
.
storage
[
num_cur_blocks
-
1
]
;
*
block
=
*
block
|
!
mask
;
}
else
{
}
}
let
stop_idx
=
cmp
:
:
min
(
self
.
storage
.
len
(
)
new_nblocks
)
;
for
idx
in
num_cur_blocks
.
.
stop_idx
{
self
.
storage
[
idx
]
=
full_value
;
}
if
new_nblocks
>
self
.
storage
.
len
(
)
{
let
to_add
=
new_nblocks
-
self
.
storage
.
len
(
)
;
self
.
storage
.
extend
(
repeat
(
full_value
)
.
take
(
to_add
)
)
;
}
self
.
nbits
=
new_nbits
;
self
.
fix_last_block
(
)
;
}
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
bool
>
{
if
self
.
is_empty
(
)
{
None
}
else
{
let
i
=
self
.
nbits
-
1
;
let
ret
=
self
[
i
]
;
self
.
set
(
i
false
)
;
self
.
nbits
=
i
;
if
self
.
nbits
%
B
:
:
bits
(
)
=
=
0
{
self
.
storage
.
pop
(
)
;
}
Some
(
ret
)
}
}
pub
fn
push
(
&
mut
self
elem
:
bool
)
{
if
self
.
nbits
%
B
:
:
bits
(
)
=
=
0
{
self
.
storage
.
push
(
B
:
:
zero
(
)
)
;
}
let
insert_pos
=
self
.
nbits
;
self
.
nbits
=
self
.
nbits
.
checked_add
(
1
)
.
expect
(
"
Capacity
overflow
"
)
;
self
.
set
(
insert_pos
elem
)
;
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
nbits
}
pub
unsafe
fn
set_len
(
&
mut
self
len
:
usize
)
{
self
.
nbits
=
len
;
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
for
w
in
&
mut
self
.
storage
{
*
w
=
B
:
:
zero
(
)
;
}
}
}
impl
<
B
:
BitBlock
>
Default
for
BitVec
<
B
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
BitVec
{
storage
:
Vec
:
:
new
(
)
nbits
:
0
}
}
}
impl
<
B
:
BitBlock
>
FromIterator
<
bool
>
for
BitVec
<
B
>
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
bool
>
>
(
iter
:
I
)
-
>
Self
{
let
mut
ret
:
Self
=
Default
:
:
default
(
)
;
ret
.
extend
(
iter
)
;
ret
}
}
impl
<
B
:
BitBlock
>
Extend
<
bool
>
for
BitVec
<
B
>
{
#
[
inline
]
fn
extend
<
I
:
IntoIterator
<
Item
=
bool
>
>
(
&
mut
self
iterable
:
I
)
{
let
iterator
=
iterable
.
into_iter
(
)
;
let
(
min
_
)
=
iterator
.
size_hint
(
)
;
self
.
reserve
(
min
)
;
for
element
in
iterator
{
self
.
push
(
element
)
}
}
}
impl
<
B
:
BitBlock
>
Clone
for
BitVec
<
B
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
BitVec
{
storage
:
self
.
storage
.
clone
(
)
nbits
:
self
.
nbits
}
}
#
[
inline
]
fn
clone_from
(
&
mut
self
source
:
&
Self
)
{
self
.
nbits
=
source
.
nbits
;
self
.
storage
.
clone_from
(
&
source
.
storage
)
;
}
}
impl
<
B
:
BitBlock
>
PartialOrd
for
BitVec
<
B
>
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
<
B
:
BitBlock
>
Ord
for
BitVec
<
B
>
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
let
mut
a
=
self
.
iter
(
)
;
let
mut
b
=
other
.
iter
(
)
;
loop
{
match
(
a
.
next
(
)
b
.
next
(
)
)
{
(
Some
(
x
)
Some
(
y
)
)
=
>
match
x
.
cmp
(
&
y
)
{
Ordering
:
:
Equal
=
>
{
}
otherwise
=
>
return
otherwise
}
(
None
None
)
=
>
return
Ordering
:
:
Equal
(
None
_
)
=
>
return
Ordering
:
:
Less
(
_
None
)
=
>
return
Ordering
:
:
Greater
}
}
}
}
impl
<
B
:
BitBlock
>
fmt
:
:
Debug
for
BitVec
<
B
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
for
bit
in
self
{
try
!
(
write
!
(
fmt
"
{
}
"
if
bit
{
1
}
else
{
0
}
)
)
;
}
Ok
(
(
)
)
}
}
impl
<
B
:
BitBlock
>
hash
:
:
Hash
for
BitVec
<
B
>
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
nbits
.
hash
(
state
)
;
for
elem
in
self
.
blocks
(
)
{
elem
.
hash
(
state
)
;
}
}
}
impl
<
B
:
BitBlock
>
cmp
:
:
PartialEq
for
BitVec
<
B
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
if
self
.
nbits
!
=
other
.
nbits
{
return
false
;
}
self
.
blocks
(
)
.
zip
(
other
.
blocks
(
)
)
.
all
(
|
(
w1
w2
)
|
w1
=
=
w2
)
}
}
impl
<
B
:
BitBlock
>
cmp
:
:
Eq
for
BitVec
<
B
>
{
}
#
[
derive
(
Clone
)
]
pub
struct
Iter
<
'
a
B
:
'
a
=
u32
>
{
bit_vec
:
&
'
a
BitVec
<
B
>
range
:
Range
<
usize
>
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
Iter
<
'
a
B
>
{
type
Item
=
bool
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
bool
>
{
self
.
range
.
next
(
)
.
map
(
|
i
|
self
.
bit_vec
.
get
(
i
)
.
unwrap
(
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
range
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
DoubleEndedIterator
for
Iter
<
'
a
B
>
{
#
[
inline
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
bool
>
{
self
.
range
.
next_back
(
)
.
map
(
|
i
|
self
.
bit_vec
.
get
(
i
)
.
unwrap
(
)
)
}
}
impl
<
'
a
B
:
BitBlock
>
ExactSizeIterator
for
Iter
<
'
a
B
>
{
}
impl
<
'
a
B
:
BitBlock
>
IntoIterator
for
&
'
a
BitVec
<
B
>
{
type
Item
=
bool
;
type
IntoIter
=
Iter
<
'
a
B
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
B
>
{
self
.
iter
(
)
}
}
pub
struct
IntoIter
<
B
=
u32
>
{
bit_vec
:
BitVec
<
B
>
range
:
Range
<
usize
>
}
impl
<
B
:
BitBlock
>
Iterator
for
IntoIter
<
B
>
{
type
Item
=
bool
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
bool
>
{
self
.
range
.
next
(
)
.
map
(
|
i
|
self
.
bit_vec
.
get
(
i
)
.
unwrap
(
)
)
}
}
impl
<
B
:
BitBlock
>
DoubleEndedIterator
for
IntoIter
<
B
>
{
#
[
inline
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
bool
>
{
self
.
range
.
next_back
(
)
.
map
(
|
i
|
self
.
bit_vec
.
get
(
i
)
.
unwrap
(
)
)
}
}
impl
<
B
:
BitBlock
>
ExactSizeIterator
for
IntoIter
<
B
>
{
}
impl
<
B
:
BitBlock
>
IntoIterator
for
BitVec
<
B
>
{
type
Item
=
bool
;
type
IntoIter
=
IntoIter
<
B
>
;
fn
into_iter
(
self
)
-
>
IntoIter
<
B
>
{
let
nbits
=
self
.
nbits
;
IntoIter
{
bit_vec
:
self
range
:
0
.
.
nbits
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
Blocks
<
'
a
B
:
'
a
>
{
iter
:
slice
:
:
Iter
<
'
a
B
>
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
Blocks
<
'
a
B
>
{
type
Item
=
B
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
B
>
{
self
.
iter
.
next
(
)
.
cloned
(
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
DoubleEndedIterator
for
Blocks
<
'
a
B
>
{
#
[
inline
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
B
>
{
self
.
iter
.
next_back
(
)
.
cloned
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
ExactSizeIterator
for
Blocks
<
'
a
B
>
{
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
BitVec
Iter
}
;
const
U32_BITS
:
usize
=
32
;
#
[
test
]
fn
test_to_str
(
)
{
let
zerolen
=
BitVec
:
:
new
(
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
zerolen
)
"
"
)
;
let
eightbits
=
BitVec
:
:
from_elem
(
8
false
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
eightbits
)
"
00000000
"
)
}
#
[
test
]
fn
test_0_elements
(
)
{
let
act
=
BitVec
:
:
new
(
)
;
let
exp
=
Vec
:
:
new
(
)
;
assert
!
(
act
.
eq_vec
(
&
exp
)
)
;
assert
!
(
act
.
none
(
)
&
&
act
.
all
(
)
)
;
}
#
[
test
]
fn
test_1_element
(
)
{
let
mut
act
=
BitVec
:
:
from_elem
(
1
false
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
]
)
)
;
assert
!
(
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
1
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
act
.
all
(
)
)
;
}
#
[
test
]
fn
test_2_elements
(
)
{
let
mut
b
=
BitVec
:
:
from_elem
(
2
false
)
;
b
.
set
(
0
true
)
;
b
.
set
(
1
false
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
b
)
"
10
"
)
;
assert
!
(
!
b
.
none
(
)
&
&
!
b
.
all
(
)
)
;
}
#
[
test
]
fn
test_10_elements
(
)
{
let
mut
act
;
act
=
BitVec
:
:
from_elem
(
10
false
)
;
assert
!
(
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
]
)
)
)
;
assert
!
(
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
10
true
)
;
assert
!
(
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
true
true
]
)
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
10
false
)
;
act
.
set
(
0
true
)
;
act
.
set
(
1
true
)
;
act
.
set
(
2
true
)
;
act
.
set
(
3
true
)
;
act
.
set
(
4
true
)
;
assert
!
(
(
act
.
eq_vec
(
&
[
true
true
true
true
true
false
false
false
false
false
]
)
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
10
false
)
;
act
.
set
(
5
true
)
;
act
.
set
(
6
true
)
;
act
.
set
(
7
true
)
;
act
.
set
(
8
true
)
;
act
.
set
(
9
true
)
;
assert
!
(
(
act
.
eq_vec
(
&
[
false
false
false
false
false
true
true
true
true
true
]
)
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
10
false
)
;
act
.
set
(
0
true
)
;
act
.
set
(
3
true
)
;
act
.
set
(
6
true
)
;
act
.
set
(
9
true
)
;
assert
!
(
(
act
.
eq_vec
(
&
[
true
false
false
true
false
false
true
false
false
true
]
)
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
}
#
[
test
]
fn
test_31_elements
(
)
{
let
mut
act
;
act
=
BitVec
:
:
from_elem
(
31
false
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
31
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
31
false
)
;
act
.
set
(
0
true
)
;
act
.
set
(
1
true
)
;
act
.
set
(
2
true
)
;
act
.
set
(
3
true
)
;
act
.
set
(
4
true
)
;
act
.
set
(
5
true
)
;
act
.
set
(
6
true
)
;
act
.
set
(
7
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
31
false
)
;
act
.
set
(
16
true
)
;
act
.
set
(
17
true
)
;
act
.
set
(
18
true
)
;
act
.
set
(
19
true
)
;
act
.
set
(
20
true
)
;
act
.
set
(
21
true
)
;
act
.
set
(
22
true
)
;
act
.
set
(
23
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
true
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
31
false
)
;
act
.
set
(
24
true
)
;
act
.
set
(
25
true
)
;
act
.
set
(
26
true
)
;
act
.
set
(
27
true
)
;
act
.
set
(
28
true
)
;
act
.
set
(
29
true
)
;
act
.
set
(
30
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
31
false
)
;
act
.
set
(
3
true
)
;
act
.
set
(
17
true
)
;
act
.
set
(
30
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
true
false
false
false
false
false
false
false
false
false
false
false
false
false
true
false
false
false
false
false
false
false
false
false
false
false
false
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
}
#
[
test
]
fn
test_32_elements
(
)
{
let
mut
act
;
act
=
BitVec
:
:
from_elem
(
32
false
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
32
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
32
false
)
;
act
.
set
(
0
true
)
;
act
.
set
(
1
true
)
;
act
.
set
(
2
true
)
;
act
.
set
(
3
true
)
;
act
.
set
(
4
true
)
;
act
.
set
(
5
true
)
;
act
.
set
(
6
true
)
;
act
.
set
(
7
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
32
false
)
;
act
.
set
(
16
true
)
;
act
.
set
(
17
true
)
;
act
.
set
(
18
true
)
;
act
.
set
(
19
true
)
;
act
.
set
(
20
true
)
;
act
.
set
(
21
true
)
;
act
.
set
(
22
true
)
;
act
.
set
(
23
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
true
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
32
false
)
;
act
.
set
(
24
true
)
;
act
.
set
(
25
true
)
;
act
.
set
(
26
true
)
;
act
.
set
(
27
true
)
;
act
.
set
(
28
true
)
;
act
.
set
(
29
true
)
;
act
.
set
(
30
true
)
;
act
.
set
(
31
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
32
false
)
;
act
.
set
(
3
true
)
;
act
.
set
(
17
true
)
;
act
.
set
(
30
true
)
;
act
.
set
(
31
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
true
false
false
false
false
false
false
false
false
false
false
false
false
false
true
false
false
false
false
false
false
false
false
false
false
false
false
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
}
#
[
test
]
fn
test_33_elements
(
)
{
let
mut
act
;
act
=
BitVec
:
:
from_elem
(
33
false
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
33
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
33
false
)
;
act
.
set
(
0
true
)
;
act
.
set
(
1
true
)
;
act
.
set
(
2
true
)
;
act
.
set
(
3
true
)
;
act
.
set
(
4
true
)
;
act
.
set
(
5
true
)
;
act
.
set
(
6
true
)
;
act
.
set
(
7
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
true
true
true
true
true
true
true
true
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
33
false
)
;
act
.
set
(
16
true
)
;
act
.
set
(
17
true
)
;
act
.
set
(
18
true
)
;
act
.
set
(
19
true
)
;
act
.
set
(
20
true
)
;
act
.
set
(
21
true
)
;
act
.
set
(
22
true
)
;
act
.
set
(
23
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
true
false
false
false
false
false
false
false
false
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
33
false
)
;
act
.
set
(
24
true
)
;
act
.
set
(
25
true
)
;
act
.
set
(
26
true
)
;
act
.
set
(
27
true
)
;
act
.
set
(
28
true
)
;
act
.
set
(
29
true
)
;
act
.
set
(
30
true
)
;
act
.
set
(
31
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
true
false
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
act
=
BitVec
:
:
from_elem
(
33
false
)
;
act
.
set
(
3
true
)
;
act
.
set
(
17
true
)
;
act
.
set
(
30
true
)
;
act
.
set
(
31
true
)
;
act
.
set
(
32
true
)
;
assert
!
(
act
.
eq_vec
(
&
[
false
false
false
true
false
false
false
false
false
false
false
false
false
false
false
false
false
true
false
false
false
false
false
false
false
false
false
false
false
false
true
true
true
]
)
)
;
assert
!
(
!
act
.
none
(
)
&
&
!
act
.
all
(
)
)
;
}
#
[
test
]
fn
test_equal_differing_sizes
(
)
{
let
v0
=
BitVec
:
:
from_elem
(
10
false
)
;
let
v1
=
BitVec
:
:
from_elem
(
11
false
)
;
assert
!
(
v0
!
=
v1
)
;
}
#
[
test
]
fn
test_equal_greatly_differing_sizes
(
)
{
let
v0
=
BitVec
:
:
from_elem
(
10
false
)
;
let
v1
=
BitVec
:
:
from_elem
(
110
false
)
;
assert
!
(
v0
!
=
v1
)
;
}
#
[
test
]
fn
test_equal_sneaky_small
(
)
{
let
mut
a
=
BitVec
:
:
from_elem
(
1
false
)
;
a
.
set
(
0
true
)
;
let
mut
b
=
BitVec
:
:
from_elem
(
1
true
)
;
b
.
set
(
0
true
)
;
assert_eq
!
(
a
b
)
;
}
#
[
test
]
fn
test_equal_sneaky_big
(
)
{
let
mut
a
=
BitVec
:
:
from_elem
(
100
false
)
;
for
i
in
0
.
.
100
{
a
.
set
(
i
true
)
;
}
let
mut
b
=
BitVec
:
:
from_elem
(
100
true
)
;
for
i
in
0
.
.
100
{
b
.
set
(
i
true
)
;
}
assert_eq
!
(
a
b
)
;
}
#
[
test
]
fn
test_from_bytes
(
)
{
let
bit_vec
=
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b11111111
]
)
;
let
str
=
concat
!
(
"
10110110
"
"
00000000
"
"
11111111
"
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
bit_vec
)
str
)
;
}
#
[
test
]
fn
test_to_bytes
(
)
{
let
mut
bv
=
BitVec
:
:
from_elem
(
3
true
)
;
bv
.
set
(
1
false
)
;
assert_eq
!
(
bv
.
to_bytes
(
)
[
0b10100000
]
)
;
let
mut
bv
=
BitVec
:
:
from_elem
(
9
false
)
;
bv
.
set
(
2
true
)
;
bv
.
set
(
8
true
)
;
assert_eq
!
(
bv
.
to_bytes
(
)
[
0b00100000
0b10000000
]
)
;
}
#
[
test
]
fn
test_from_bools
(
)
{
let
bools
=
vec
!
[
true
false
true
true
]
;
let
bit_vec
:
BitVec
=
bools
.
iter
(
)
.
map
(
|
n
|
*
n
)
.
collect
(
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
bit_vec
)
"
1011
"
)
;
}
#
[
test
]
fn
test_to_bools
(
)
{
let
bools
=
vec
!
[
false
false
true
false
false
true
true
false
]
;
assert_eq
!
(
BitVec
:
:
from_bytes
(
&
[
0b00100110
]
)
.
iter
(
)
.
collect
:
:
<
Vec
<
bool
>
>
(
)
bools
)
;
}
#
[
test
]
fn
test_bit_vec_iterator
(
)
{
let
bools
=
vec
!
[
true
false
true
true
]
;
let
bit_vec
:
BitVec
=
bools
.
iter
(
)
.
map
(
|
n
|
*
n
)
.
collect
(
)
;
assert_eq
!
(
bit_vec
.
iter
(
)
.
collect
:
:
<
Vec
<
bool
>
>
(
)
bools
)
;
let
long
:
Vec
<
_
>
=
(
0
.
.
10000
)
.
map
(
|
i
|
i
%
2
=
=
0
)
.
collect
(
)
;
let
bit_vec
:
BitVec
=
long
.
iter
(
)
.
map
(
|
n
|
*
n
)
.
collect
(
)
;
assert_eq
!
(
bit_vec
.
iter
(
)
.
collect
:
:
<
Vec
<
bool
>
>
(
)
long
)
}
#
[
test
]
fn
test_small_difference
(
)
{
let
mut
b1
=
BitVec
:
:
from_elem
(
3
false
)
;
let
mut
b2
=
BitVec
:
:
from_elem
(
3
false
)
;
b1
.
set
(
0
true
)
;
b1
.
set
(
1
true
)
;
b2
.
set
(
1
true
)
;
b2
.
set
(
2
true
)
;
assert
!
(
b1
.
difference
(
&
b2
)
)
;
assert
!
(
b1
[
0
]
)
;
assert
!
(
!
b1
[
1
]
)
;
assert
!
(
!
b1
[
2
]
)
;
}
#
[
test
]
fn
test_big_difference
(
)
{
let
mut
b1
=
BitVec
:
:
from_elem
(
100
false
)
;
let
mut
b2
=
BitVec
:
:
from_elem
(
100
false
)
;
b1
.
set
(
0
true
)
;
b1
.
set
(
40
true
)
;
b2
.
set
(
40
true
)
;
b2
.
set
(
80
true
)
;
assert
!
(
b1
.
difference
(
&
b2
)
)
;
assert
!
(
b1
[
0
]
)
;
assert
!
(
!
b1
[
40
]
)
;
assert
!
(
!
b1
[
80
]
)
;
}
#
[
test
]
fn
test_small_clear
(
)
{
let
mut
b
=
BitVec
:
:
from_elem
(
14
true
)
;
assert
!
(
!
b
.
none
(
)
&
&
b
.
all
(
)
)
;
b
.
clear
(
)
;
assert
!
(
b
.
none
(
)
&
&
!
b
.
all
(
)
)
;
}
#
[
test
]
fn
test_big_clear
(
)
{
let
mut
b
=
BitVec
:
:
from_elem
(
140
true
)
;
assert
!
(
!
b
.
none
(
)
&
&
b
.
all
(
)
)
;
b
.
clear
(
)
;
assert
!
(
b
.
none
(
)
&
&
!
b
.
all
(
)
)
;
}
#
[
test
]
fn
test_bit_vec_lt
(
)
{
let
mut
a
=
BitVec
:
:
from_elem
(
5
false
)
;
let
mut
b
=
BitVec
:
:
from_elem
(
5
false
)
;
assert
!
(
!
(
a
<
b
)
&
&
!
(
b
<
a
)
)
;
b
.
set
(
2
true
)
;
assert
!
(
a
<
b
)
;
a
.
set
(
3
true
)
;
assert
!
(
a
<
b
)
;
a
.
set
(
2
true
)
;
assert
!
(
!
(
a
<
b
)
&
&
b
<
a
)
;
b
.
set
(
0
true
)
;
assert
!
(
a
<
b
)
;
}
#
[
test
]
fn
test_ord
(
)
{
let
mut
a
=
BitVec
:
:
from_elem
(
5
false
)
;
let
mut
b
=
BitVec
:
:
from_elem
(
5
false
)
;
assert
!
(
a
<
=
b
&
&
a
>
=
b
)
;
a
.
set
(
1
true
)
;
assert
!
(
a
>
b
&
&
a
>
=
b
)
;
assert
!
(
b
<
a
&
&
b
<
=
a
)
;
b
.
set
(
1
true
)
;
b
.
set
(
2
true
)
;
assert
!
(
b
>
a
&
&
b
>
=
a
)
;
assert
!
(
a
<
b
&
&
a
<
=
b
)
;
}
#
[
test
]
fn
test_small_bit_vec_tests
(
)
{
let
v
=
BitVec
:
:
from_bytes
(
&
[
0
]
)
;
assert
!
(
!
v
.
all
(
)
)
;
assert
!
(
!
v
.
any
(
)
)
;
assert
!
(
v
.
none
(
)
)
;
let
v
=
BitVec
:
:
from_bytes
(
&
[
0b00010100
]
)
;
assert
!
(
!
v
.
all
(
)
)
;
assert
!
(
v
.
any
(
)
)
;
assert
!
(
!
v
.
none
(
)
)
;
let
v
=
BitVec
:
:
from_bytes
(
&
[
0xFF
]
)
;
assert
!
(
v
.
all
(
)
)
;
assert
!
(
v
.
any
(
)
)
;
assert
!
(
!
v
.
none
(
)
)
;
}
#
[
test
]
fn
test_big_bit_vec_tests
(
)
{
let
v
=
BitVec
:
:
from_bytes
(
&
[
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
!
v
.
all
(
)
)
;
assert
!
(
!
v
.
any
(
)
)
;
assert
!
(
v
.
none
(
)
)
;
let
v
=
BitVec
:
:
from_bytes
(
&
[
0
0
0b00010100
0
0
0
0
0b00110100
0
0
0
]
)
;
assert
!
(
!
v
.
all
(
)
)
;
assert
!
(
v
.
any
(
)
)
;
assert
!
(
!
v
.
none
(
)
)
;
let
v
=
BitVec
:
:
from_bytes
(
&
[
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
]
)
;
assert
!
(
v
.
all
(
)
)
;
assert
!
(
v
.
any
(
)
)
;
assert
!
(
!
v
.
none
(
)
)
;
}
#
[
test
]
fn
test_bit_vec_push_pop
(
)
{
let
mut
s
=
BitVec
:
:
from_elem
(
5
*
U32_BITS
-
2
false
)
;
assert_eq
!
(
s
.
len
(
)
5
*
U32_BITS
-
2
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
-
3
]
false
)
;
s
.
push
(
true
)
;
s
.
push
(
true
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
-
2
]
true
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
-
1
]
true
)
;
s
.
push
(
false
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
]
false
)
;
s
.
push
(
false
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
+
1
]
false
)
;
assert_eq
!
(
s
.
len
(
)
5
*
U32_BITS
+
2
)
;
assert_eq
!
(
s
.
pop
(
)
Some
(
false
)
)
;
assert_eq
!
(
s
.
pop
(
)
Some
(
false
)
)
;
assert_eq
!
(
s
.
pop
(
)
Some
(
true
)
)
;
assert_eq
!
(
s
.
pop
(
)
Some
(
true
)
)
;
assert_eq
!
(
s
.
len
(
)
5
*
U32_BITS
-
2
)
;
}
#
[
test
]
fn
test_bit_vec_truncate
(
)
{
let
mut
s
=
BitVec
:
:
from_elem
(
5
*
U32_BITS
true
)
;
assert_eq
!
(
s
BitVec
:
:
from_elem
(
5
*
U32_BITS
true
)
)
;
assert_eq
!
(
s
.
len
(
)
5
*
U32_BITS
)
;
s
.
truncate
(
4
*
U32_BITS
)
;
assert_eq
!
(
s
BitVec
:
:
from_elem
(
4
*
U32_BITS
true
)
)
;
assert_eq
!
(
s
.
len
(
)
4
*
U32_BITS
)
;
s
.
truncate
(
5
*
U32_BITS
)
;
assert_eq
!
(
s
BitVec
:
:
from_elem
(
4
*
U32_BITS
true
)
)
;
assert_eq
!
(
s
.
len
(
)
4
*
U32_BITS
)
;
s
.
truncate
(
3
*
U32_BITS
-
10
)
;
assert_eq
!
(
s
BitVec
:
:
from_elem
(
3
*
U32_BITS
-
10
true
)
)
;
assert_eq
!
(
s
.
len
(
)
3
*
U32_BITS
-
10
)
;
s
.
truncate
(
0
)
;
assert_eq
!
(
s
BitVec
:
:
from_elem
(
0
true
)
)
;
assert_eq
!
(
s
.
len
(
)
0
)
;
}
#
[
test
]
fn
test_bit_vec_reserve
(
)
{
let
mut
s
=
BitVec
:
:
from_elem
(
5
*
U32_BITS
true
)
;
assert
!
(
s
.
capacity
(
)
>
=
5
*
U32_BITS
)
;
s
.
reserve
(
2
*
U32_BITS
)
;
assert
!
(
s
.
capacity
(
)
>
=
7
*
U32_BITS
)
;
s
.
reserve
(
7
*
U32_BITS
)
;
assert
!
(
s
.
capacity
(
)
>
=
12
*
U32_BITS
)
;
s
.
reserve_exact
(
7
*
U32_BITS
)
;
assert
!
(
s
.
capacity
(
)
>
=
12
*
U32_BITS
)
;
s
.
reserve
(
7
*
U32_BITS
+
1
)
;
assert
!
(
s
.
capacity
(
)
>
=
12
*
U32_BITS
+
1
)
;
assert_eq
!
(
s
.
len
(
)
5
*
U32_BITS
)
;
s
.
push
(
true
)
;
s
.
push
(
false
)
;
s
.
push
(
true
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
-
1
]
true
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
-
0
]
true
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
+
1
]
false
)
;
assert_eq
!
(
s
[
5
*
U32_BITS
+
2
]
true
)
;
}
#
[
test
]
fn
test_bit_vec_grow
(
)
{
let
mut
bit_vec
=
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b10101010
]
)
;
bit_vec
.
grow
(
32
true
)
;
assert_eq
!
(
bit_vec
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b10101010
0xFF
0xFF
0xFF
0xFF
]
)
)
;
bit_vec
.
grow
(
64
false
)
;
assert_eq
!
(
bit_vec
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b10101010
0xFF
0xFF
0xFF
0xFF
0
0
0
0
0
0
0
0
]
)
)
;
bit_vec
.
grow
(
16
true
)
;
assert_eq
!
(
bit_vec
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b10101010
0xFF
0xFF
0xFF
0xFF
0
0
0
0
0
0
0
0
0xFF
0xFF
]
)
)
;
}
#
[
test
]
fn
test_bit_vec_extend
(
)
{
let
mut
bit_vec
=
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b11111111
]
)
;
let
ext
=
BitVec
:
:
from_bytes
(
&
[
0b01001001
0b10010010
0b10111101
]
)
;
bit_vec
.
extend
(
ext
.
iter
(
)
)
;
assert_eq
!
(
bit_vec
BitVec
:
:
from_bytes
(
&
[
0b10110110
0b00000000
0b11111111
0b01001001
0b10010010
0b10111101
]
)
)
;
}
#
[
test
]
fn
test_into_iter
(
)
{
let
bools
=
vec
!
[
true
false
true
true
]
;
let
bit_vec
:
BitVec
=
bools
.
iter
(
)
.
map
(
|
n
|
*
n
)
.
collect
(
)
;
let
mut
iter
=
bit_vec
.
into_iter
(
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next
(
)
)
;
assert_eq
!
(
Some
(
false
)
iter
.
next
(
)
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next
(
)
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next
(
)
)
;
assert_eq
!
(
None
iter
.
next
(
)
)
;
assert_eq
!
(
None
iter
.
next
(
)
)
;
let
bit_vec
:
BitVec
=
bools
.
iter
(
)
.
map
(
|
n
|
*
n
)
.
collect
(
)
;
let
mut
iter
=
bit_vec
.
into_iter
(
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next_back
(
)
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next_back
(
)
)
;
assert_eq
!
(
Some
(
false
)
iter
.
next_back
(
)
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next_back
(
)
)
;
assert_eq
!
(
None
iter
.
next_back
(
)
)
;
assert_eq
!
(
None
iter
.
next_back
(
)
)
;
let
bit_vec
:
BitVec
=
bools
.
iter
(
)
.
map
(
|
n
|
*
n
)
.
collect
(
)
;
let
mut
iter
=
bit_vec
.
into_iter
(
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next_back
(
)
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next
(
)
)
;
assert_eq
!
(
Some
(
false
)
iter
.
next
(
)
)
;
assert_eq
!
(
Some
(
true
)
iter
.
next_back
(
)
)
;
assert_eq
!
(
None
iter
.
next
(
)
)
;
assert_eq
!
(
None
iter
.
next_back
(
)
)
;
}
#
[
test
]
fn
iter
(
)
{
let
b
=
BitVec
:
:
with_capacity
(
10
)
;
let
_a
:
Iter
=
b
.
iter
(
)
;
}
}
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
mod
bench
;
