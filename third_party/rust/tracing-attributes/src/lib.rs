#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
raw
.
githubusercontent
.
com
/
tokio
-
rs
/
tracing
/
master
/
assets
/
logo
-
type
.
png
"
issue_tracker_base_url
=
"
https
:
/
/
github
.
com
/
tokio
-
rs
/
tracing
/
issues
/
"
)
]
#
!
[
cfg_attr
(
docsrs
deny
(
rustdoc
:
:
broken_intra_doc_links
)
)
]
#
!
[
warn
(
missing_debug_implementations
missing_docs
rust_2018_idioms
unreachable_pub
bad_style
dead_code
improper_ctypes
non_shorthand_field_patterns
no_mangle_generic_items
overflowing_literals
path_statements
patterns_in_fns_without_body
private_in_public
unconditional_recursion
unused_allocation
unused_comparisons
unused_parens
while_true
)
]
#
!
[
allow
(
unused
)
]
extern
crate
proc_macro
;
use
proc_macro2
:
:
TokenStream
;
use
quote
:
:
{
quote
ToTokens
}
;
use
syn
:
:
parse
:
:
{
Parse
ParseStream
}
;
use
syn
:
:
{
Attribute
ItemFn
Signature
Visibility
}
;
mod
attr
;
mod
expand
;
#
[
proc_macro_attribute
]
pub
fn
instrument
(
args
:
proc_macro
:
:
TokenStream
item
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
args
=
syn
:
:
parse_macro_input
!
(
args
as
attr
:
:
InstrumentArgs
)
;
instrument_precise
(
args
.
clone
(
)
item
.
clone
(
)
)
.
unwrap_or_else
(
|
_err
|
instrument_speculative
(
args
item
)
)
}
fn
instrument_speculative
(
args
:
attr
:
:
InstrumentArgs
item
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
input
=
syn
:
:
parse_macro_input
!
(
item
as
MaybeItemFn
)
;
let
instrumented_function_name
=
input
.
sig
.
ident
.
to_string
(
)
;
expand
:
:
gen_function
(
input
.
as_ref
(
)
args
instrumented_function_name
.
as_str
(
)
None
)
.
into
(
)
}
fn
instrument_precise
(
args
:
attr
:
:
InstrumentArgs
item
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
proc_macro
:
:
TokenStream
syn
:
:
Error
>
{
let
input
=
syn
:
:
parse
:
:
<
ItemFn
>
(
item
)
?
;
let
instrumented_function_name
=
input
.
sig
.
ident
.
to_string
(
)
;
if
input
.
sig
.
constness
.
is_some
(
)
{
return
Ok
(
quote
!
{
compile_error
!
(
"
the
#
[
instrument
]
attribute
may
not
be
used
with
const
fn
s
"
)
}
.
into
(
)
)
;
}
if
let
Some
(
async_like
)
=
expand
:
:
AsyncInfo
:
:
from_fn
(
&
input
)
{
return
async_like
.
gen_async
(
args
instrumented_function_name
.
as_str
(
)
)
;
}
let
input
=
MaybeItemFn
:
:
from
(
input
)
;
Ok
(
expand
:
:
gen_function
(
input
.
as_ref
(
)
args
instrumented_function_name
.
as_str
(
)
None
)
.
into
(
)
)
}
#
[
derive
(
Debug
Clone
)
]
struct
MaybeItemFn
{
outer_attrs
:
Vec
<
Attribute
>
inner_attrs
:
Vec
<
Attribute
>
vis
:
Visibility
sig
:
Signature
block
:
TokenStream
}
impl
MaybeItemFn
{
fn
as_ref
(
&
self
)
-
>
MaybeItemFnRef
<
'
_
TokenStream
>
{
MaybeItemFnRef
{
outer_attrs
:
&
self
.
outer_attrs
inner_attrs
:
&
self
.
inner_attrs
vis
:
&
self
.
vis
sig
:
&
self
.
sig
block
:
&
self
.
block
}
}
}
impl
Parse
for
MaybeItemFn
{
fn
parse
(
input
:
ParseStream
<
'
_
>
)
-
>
syn
:
:
Result
<
Self
>
{
let
outer_attrs
=
input
.
call
(
Attribute
:
:
parse_outer
)
?
;
let
vis
:
Visibility
=
input
.
parse
(
)
?
;
let
sig
:
Signature
=
input
.
parse
(
)
?
;
let
inner_attrs
=
input
.
call
(
Attribute
:
:
parse_inner
)
?
;
let
block
:
TokenStream
=
input
.
parse
(
)
?
;
Ok
(
Self
{
outer_attrs
inner_attrs
vis
sig
block
}
)
}
}
impl
From
<
ItemFn
>
for
MaybeItemFn
{
fn
from
(
ItemFn
{
attrs
vis
sig
block
}
:
ItemFn
)
-
>
Self
{
let
(
outer_attrs
inner_attrs
)
=
attrs
.
into_iter
(
)
.
partition
(
|
attr
|
attr
.
style
=
=
syn
:
:
AttrStyle
:
:
Outer
)
;
Self
{
outer_attrs
inner_attrs
vis
sig
block
:
block
.
to_token_stream
(
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
struct
MaybeItemFnRef
<
'
a
B
:
ToTokens
>
{
outer_attrs
:
&
'
a
Vec
<
Attribute
>
inner_attrs
:
&
'
a
Vec
<
Attribute
>
vis
:
&
'
a
Visibility
sig
:
&
'
a
Signature
block
:
&
'
a
B
}
