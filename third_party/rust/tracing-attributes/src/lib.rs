#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
tracing
-
attributes
/
0
.
1
.
22
"
)
]
#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
raw
.
githubusercontent
.
com
/
tokio
-
rs
/
tracing
/
master
/
assets
/
logo
-
type
.
png
"
issue_tracker_base_url
=
"
https
:
/
/
github
.
com
/
tokio
-
rs
/
tracing
/
issues
/
"
)
]
#
!
[
cfg_attr
(
docsrs
deny
(
rustdoc
:
:
broken_intra_doc_links
)
)
]
#
!
[
warn
(
missing_debug_implementations
missing_docs
rust_2018_idioms
unreachable_pub
bad_style
const_err
dead_code
improper_ctypes
non_shorthand_field_patterns
no_mangle_generic_items
overflowing_literals
path_statements
patterns_in_fns_without_body
private_in_public
unconditional_recursion
unused_allocation
unused_comparisons
unused_parens
while_true
)
]
#
!
[
allow
(
unused
)
]
extern
crate
proc_macro
;
use
proc_macro2
:
:
TokenStream
;
use
quote
:
:
ToTokens
;
use
syn
:
:
parse
:
:
{
Parse
ParseStream
}
;
use
syn
:
:
{
Attribute
Block
ItemFn
Signature
Visibility
}
;
mod
attr
;
mod
expand
;
#
[
proc_macro_attribute
]
pub
fn
instrument
(
args
:
proc_macro
:
:
TokenStream
item
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
args
=
syn
:
:
parse_macro_input
!
(
args
as
attr
:
:
InstrumentArgs
)
;
instrument_precise
(
args
.
clone
(
)
item
.
clone
(
)
)
.
unwrap_or_else
(
|
_err
|
instrument_speculative
(
args
item
)
)
}
fn
instrument_speculative
(
args
:
attr
:
:
InstrumentArgs
item
:
proc_macro
:
:
TokenStream
)
-
>
proc_macro
:
:
TokenStream
{
let
input
=
syn
:
:
parse_macro_input
!
(
item
as
MaybeItemFn
)
;
let
instrumented_function_name
=
input
.
sig
.
ident
.
to_string
(
)
;
expand
:
:
gen_function
(
input
.
as_ref
(
)
args
instrumented_function_name
.
as_str
(
)
None
)
.
into
(
)
}
fn
instrument_precise
(
args
:
attr
:
:
InstrumentArgs
item
:
proc_macro
:
:
TokenStream
)
-
>
Result
<
proc_macro
:
:
TokenStream
syn
:
:
Error
>
{
let
input
=
syn
:
:
parse
:
:
<
ItemFn
>
(
item
)
?
;
let
instrumented_function_name
=
input
.
sig
.
ident
.
to_string
(
)
;
if
let
Some
(
async_like
)
=
expand
:
:
AsyncInfo
:
:
from_fn
(
&
input
)
{
return
Ok
(
async_like
.
gen_async
(
args
instrumented_function_name
.
as_str
(
)
)
)
;
}
Ok
(
expand
:
:
gen_function
(
(
&
input
)
.
into
(
)
args
instrumented_function_name
.
as_str
(
)
None
)
.
into
(
)
)
}
#
[
derive
(
Debug
Clone
)
]
struct
MaybeItemFn
{
attrs
:
Vec
<
Attribute
>
vis
:
Visibility
sig
:
Signature
block
:
TokenStream
}
impl
MaybeItemFn
{
fn
as_ref
(
&
self
)
-
>
MaybeItemFnRef
<
'
_
TokenStream
>
{
MaybeItemFnRef
{
attrs
:
&
self
.
attrs
vis
:
&
self
.
vis
sig
:
&
self
.
sig
block
:
&
self
.
block
}
}
}
impl
Parse
for
MaybeItemFn
{
fn
parse
(
input
:
ParseStream
<
'
_
>
)
-
>
syn
:
:
Result
<
Self
>
{
let
attrs
=
input
.
call
(
syn
:
:
Attribute
:
:
parse_outer
)
?
;
let
vis
:
Visibility
=
input
.
parse
(
)
?
;
let
sig
:
Signature
=
input
.
parse
(
)
?
;
let
block
:
TokenStream
=
input
.
parse
(
)
?
;
Ok
(
Self
{
attrs
vis
sig
block
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
struct
MaybeItemFnRef
<
'
a
B
:
ToTokens
>
{
attrs
:
&
'
a
Vec
<
Attribute
>
vis
:
&
'
a
Visibility
sig
:
&
'
a
Signature
block
:
&
'
a
B
}
impl
<
'
a
>
From
<
&
'
a
ItemFn
>
for
MaybeItemFnRef
<
'
a
Box
<
Block
>
>
{
fn
from
(
val
:
&
'
a
ItemFn
)
-
>
Self
{
MaybeItemFnRef
{
attrs
:
&
val
.
attrs
vis
:
&
val
.
vis
sig
:
&
val
.
sig
block
:
&
val
.
block
}
}
}
