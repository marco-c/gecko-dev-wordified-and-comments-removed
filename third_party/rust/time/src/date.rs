#
[
cfg
(
feature
=
"
formatting
"
)
]
use
alloc
:
:
string
:
:
String
;
use
core
:
:
num
:
:
{
NonZeroI32
NonZeroU8
}
;
use
core
:
:
ops
:
:
{
Add
Sub
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
use
core
:
:
{
cmp
fmt
}
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
use
deranged
:
:
RangedI32
;
use
num_conv
:
:
prelude
:
:
*
;
use
powerfmt
:
:
ext
:
:
FormatterExt
;
use
powerfmt
:
:
smart_display
:
:
{
self
FormatterOptions
Metadata
SmartDisplay
}
;
use
crate
:
:
convert
:
:
*
;
use
crate
:
:
ext
:
:
DigitCount
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
use
crate
:
:
internal_macros
:
:
{
const_try
const_try_opt
div_floor
ensure_ranged
expect_opt
impl_add_assign
impl_sub_assign
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
use
crate
:
:
util
:
:
{
days_in_year
is_leap_year
weeks_in_year
}
;
use
crate
:
:
{
error
Duration
Month
PrimitiveDateTime
Time
Weekday
}
;
type
Year
=
RangedI32
<
MIN_YEAR
MAX_YEAR
>
;
pub
(
crate
)
const
MIN_YEAR
:
i32
=
if
cfg
!
(
feature
=
"
large
-
dates
"
)
{
-
999_999
}
else
{
-
9999
}
;
pub
(
crate
)
const
MAX_YEAR
:
i32
=
if
cfg
!
(
feature
=
"
large
-
dates
"
)
{
999_999
}
else
{
9999
}
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Date
{
value
:
NonZeroI32
}
impl
Date
{
#
[
allow
(
clippy
:
:
undocumented_unsafe_blocks
)
]
pub
const
MIN
:
Self
=
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
MIN_YEAR
1
)
}
;
#
[
allow
(
clippy
:
:
undocumented_unsafe_blocks
)
]
pub
const
MAX
:
Self
=
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
MAX_YEAR
days_in_year
(
MAX_YEAR
)
)
}
;
const
unsafe
fn
from_parts
(
year
:
i32
is_leap_year
:
bool
ordinal
:
u16
)
-
>
Self
{
debug_assert
!
(
year
>
=
MIN_YEAR
)
;
debug_assert
!
(
year
<
=
MAX_YEAR
)
;
debug_assert
!
(
ordinal
!
=
0
)
;
debug_assert
!
(
ordinal
<
=
days_in_year
(
year
)
)
;
debug_assert
!
(
crate
:
:
util
:
:
is_leap_year
(
year
)
=
=
is_leap_year
)
;
Self
{
value
:
unsafe
{
NonZeroI32
:
:
new_unchecked
(
(
year
<
<
10
)
|
(
(
is_leap_year
as
i32
)
<
<
9
)
|
ordinal
as
i32
)
}
}
}
#
[
doc
(
hidden
)
]
pub
const
unsafe
fn
__from_ordinal_date_unchecked
(
year
:
i32
ordinal
:
u16
)
-
>
Self
{
unsafe
{
Self
:
:
from_parts
(
year
is_leap_year
(
year
)
ordinal
)
}
}
pub
const
fn
from_calendar_date
(
year
:
i32
month
:
Month
day
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
const
DAYS_CUMULATIVE_COMMON_LEAP
:
[
[
u16
;
12
]
;
2
]
=
[
[
0
31
59
90
120
151
181
212
243
273
304
334
]
[
0
31
60
91
121
152
182
213
244
274
305
335
]
]
;
ensure_ranged
!
(
Year
:
year
)
;
match
day
{
1
.
.
=
28
=
>
{
}
29
.
.
=
31
if
day
<
=
month
.
length
(
year
)
=
>
{
}
_
=
>
{
return
Err
(
error
:
:
ComponentRange
{
name
:
"
day
"
minimum
:
1
maximum
:
month
.
length
(
year
)
as
i64
value
:
day
as
i64
conditional_message
:
Some
(
"
for
the
given
month
and
year
"
)
}
)
;
}
}
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
DAYS_CUMULATIVE_COMMON_LEAP
[
is_leap_year
(
year
)
as
usize
]
[
month
as
usize
-
1
]
+
day
as
u16
)
}
)
}
pub
const
fn
from_ordinal_date
(
year
:
i32
ordinal
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_ranged
!
(
Year
:
year
)
;
match
ordinal
{
1
.
.
=
365
=
>
{
}
366
if
is_leap_year
(
year
)
=
>
{
}
_
=
>
{
return
Err
(
error
:
:
ComponentRange
{
name
:
"
ordinal
"
minimum
:
1
maximum
:
days_in_year
(
year
)
as
i64
value
:
ordinal
as
i64
conditional_message
:
Some
(
"
for
the
given
year
"
)
}
)
;
}
}
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
}
)
}
pub
const
fn
from_iso_week_date
(
year
:
i32
week
:
u8
weekday
:
Weekday
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_ranged
!
(
Year
:
year
)
;
match
week
{
1
.
.
=
52
=
>
{
}
53
if
week
<
=
weeks_in_year
(
year
)
=
>
{
}
_
=
>
{
return
Err
(
error
:
:
ComponentRange
{
name
:
"
week
"
minimum
:
1
maximum
:
weeks_in_year
(
year
)
as
i64
value
:
week
as
i64
conditional_message
:
Some
(
"
for
the
given
year
"
)
}
)
;
}
}
let
adj_year
=
year
-
1
;
let
raw
=
365
*
adj_year
+
div_floor
!
(
adj_year
4
)
-
div_floor
!
(
adj_year
100
)
+
div_floor
!
(
adj_year
400
)
;
let
jan_4
=
match
(
raw
%
7
)
as
i8
{
-
6
|
1
=
>
8
-
5
|
2
=
>
9
-
4
|
3
=
>
10
-
3
|
4
=
>
4
-
2
|
5
=
>
5
-
1
|
6
=
>
6
_
=
>
7
}
;
let
ordinal
=
week
as
i16
*
7
+
weekday
.
number_from_monday
(
)
as
i16
-
jan_4
;
Ok
(
if
ordinal
<
=
0
{
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
-
1
(
ordinal
as
u16
)
.
wrapping_add
(
days_in_year
(
year
-
1
)
)
)
}
}
else
if
ordinal
>
days_in_year
(
year
)
as
i16
{
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
+
1
ordinal
as
u16
-
days_in_year
(
year
)
)
}
}
else
{
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
as
u16
)
}
}
)
}
#
[
doc
(
alias
=
"
from_julian_date
"
)
]
pub
const
fn
from_julian_day
(
julian_day
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
type
JulianDay
=
RangedI32
<
{
Date
:
:
MIN
.
to_julian_day
(
)
}
{
Date
:
:
MAX
.
to_julian_day
(
)
}
>
;
ensure_ranged
!
(
JulianDay
:
julian_day
)
;
Ok
(
unsafe
{
Self
:
:
from_julian_day_unchecked
(
julian_day
)
}
)
}
pub
(
crate
)
const
unsafe
fn
from_julian_day_unchecked
(
julian_day
:
i32
)
-
>
Self
{
debug_assert
!
(
julian_day
>
=
Self
:
:
MIN
.
to_julian_day
(
)
)
;
debug_assert
!
(
julian_day
<
=
Self
:
:
MAX
.
to_julian_day
(
)
)
;
const
S
:
i32
=
2_500
;
const
K
:
i32
=
719_468
+
146_097
*
S
;
const
L
:
i32
=
400
*
S
;
let
julian_day
=
julian_day
-
2_440_588
;
let
n
=
(
julian_day
+
K
)
as
u32
;
let
n_1
=
4
*
n
+
3
;
let
c
=
n_1
/
146_097
;
let
n_c
=
n_1
%
146_097
/
4
;
let
n_2
=
4
*
n_c
+
3
;
let
p_2
=
2_939_745
*
n_2
as
u64
;
let
z
=
(
p_2
>
>
32
)
as
u32
;
let
n_y
=
p_2
as
u32
/
2_939_745
/
4
;
let
y
=
100
*
c
+
z
;
let
j
=
n_y
>
=
306
;
let
y_g
=
y
as
i32
-
L
+
j
as
i32
;
let
is_leap_year
=
is_leap_year
(
y_g
)
;
let
ordinal
=
if
j
{
n_y
-
305
}
else
{
n_y
+
60
+
is_leap_year
as
u32
}
;
unsafe
{
Self
:
:
from_parts
(
y_g
is_leap_year
ordinal
as
u16
)
}
}
const
fn
is_in_leap_year
(
self
)
-
>
bool
{
(
self
.
value
.
get
(
)
>
>
9
)
&
1
=
=
1
}
pub
const
fn
year
(
self
)
-
>
i32
{
self
.
value
.
get
(
)
>
>
10
}
pub
const
fn
month
(
self
)
-
>
Month
{
let
ordinal
=
self
.
ordinal
(
)
as
u32
;
let
jan_feb_len
=
59
+
self
.
is_in_leap_year
(
)
as
u32
;
let
(
month_adj
ordinal_adj
)
=
if
ordinal
<
=
jan_feb_len
{
(
0
0
)
}
else
{
(
2
jan_feb_len
)
}
;
let
ordinal
=
ordinal
-
ordinal_adj
;
let
month
=
(
(
ordinal
*
268
+
8031
)
>
>
13
)
+
month_adj
;
unsafe
{
match
Month
:
:
from_number
(
NonZeroU8
:
:
new_unchecked
(
month
as
u8
)
)
{
Ok
(
month
)
=
>
month
Err
(
_
)
=
>
core
:
:
hint
:
:
unreachable_unchecked
(
)
}
}
}
pub
const
fn
day
(
self
)
-
>
u8
{
let
ordinal
=
self
.
ordinal
(
)
as
u32
;
let
jan_feb_len
=
59
+
self
.
is_in_leap_year
(
)
as
u32
;
let
ordinal_adj
=
if
ordinal
<
=
jan_feb_len
{
0
}
else
{
jan_feb_len
}
;
let
ordinal
=
ordinal
-
ordinal_adj
;
let
month
=
(
ordinal
*
268
+
8031
)
>
>
13
;
let
days_in_preceding_months
=
(
month
*
3917
-
3866
)
>
>
7
;
(
ordinal
-
days_in_preceding_months
)
as
u8
}
pub
const
fn
ordinal
(
self
)
-
>
u16
{
(
self
.
value
.
get
(
)
&
0x1FF
)
as
u16
}
pub
(
crate
)
const
fn
iso_year_week
(
self
)
-
>
(
i32
u8
)
{
let
(
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
match
(
(
ordinal
+
10
-
self
.
weekday
(
)
.
number_from_monday
(
)
as
u16
)
/
7
)
as
u8
{
0
=
>
(
year
-
1
weeks_in_year
(
year
-
1
)
)
53
if
weeks_in_year
(
year
)
=
=
52
=
>
(
year
+
1
1
)
week
=
>
(
year
week
)
}
}
pub
const
fn
iso_week
(
self
)
-
>
u8
{
self
.
iso_year_week
(
)
.
1
}
pub
const
fn
sunday_based_week
(
self
)
-
>
u8
{
(
(
self
.
ordinal
(
)
as
i16
-
self
.
weekday
(
)
.
number_days_from_sunday
(
)
as
i16
+
6
)
/
7
)
as
u8
}
pub
const
fn
monday_based_week
(
self
)
-
>
u8
{
(
(
self
.
ordinal
(
)
as
i16
-
self
.
weekday
(
)
.
number_days_from_monday
(
)
as
i16
+
6
)
/
7
)
as
u8
}
pub
const
fn
to_calendar_date
(
self
)
-
>
(
i32
Month
u8
)
{
let
(
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
let
ordinal
=
ordinal
as
u32
;
let
jan_feb_len
=
59
+
self
.
is_in_leap_year
(
)
as
u32
;
let
(
month_adj
ordinal_adj
)
=
if
ordinal
<
=
jan_feb_len
{
(
0
0
)
}
else
{
(
2
jan_feb_len
)
}
;
let
ordinal
=
ordinal
-
ordinal_adj
;
let
month
=
(
ordinal
*
268
+
8031
)
>
>
13
;
let
days_in_preceding_months
=
(
month
*
3917
-
3866
)
>
>
7
;
let
day
=
ordinal
-
days_in_preceding_months
;
let
month
=
month
+
month_adj
;
(
year
unsafe
{
match
Month
:
:
from_number
(
NonZeroU8
:
:
new_unchecked
(
month
as
u8
)
)
{
Ok
(
month
)
=
>
month
Err
(
_
)
=
>
core
:
:
hint
:
:
unreachable_unchecked
(
)
}
}
day
as
u8
)
}
pub
const
fn
to_ordinal_date
(
self
)
-
>
(
i32
u16
)
{
(
self
.
year
(
)
self
.
ordinal
(
)
)
}
pub
const
fn
to_iso_week_date
(
self
)
-
>
(
i32
u8
Weekday
)
{
let
(
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
let
weekday
=
self
.
weekday
(
)
;
match
(
(
ordinal
+
10
-
weekday
.
number_from_monday
(
)
as
u16
)
/
7
)
as
u8
{
0
=
>
(
year
-
1
weeks_in_year
(
year
-
1
)
weekday
)
53
if
weeks_in_year
(
year
)
=
=
52
=
>
(
year
+
1
1
weekday
)
week
=
>
(
year
week
weekday
)
}
}
pub
const
fn
weekday
(
self
)
-
>
Weekday
{
match
self
.
to_julian_day
(
)
%
7
{
-
6
|
1
=
>
Weekday
:
:
Tuesday
-
5
|
2
=
>
Weekday
:
:
Wednesday
-
4
|
3
=
>
Weekday
:
:
Thursday
-
3
|
4
=
>
Weekday
:
:
Friday
-
2
|
5
=
>
Weekday
:
:
Saturday
-
1
|
6
=
>
Weekday
:
:
Sunday
val
=
>
{
debug_assert
!
(
val
=
=
0
)
;
Weekday
:
:
Monday
}
}
}
pub
const
fn
next_day
(
self
)
-
>
Option
<
Self
>
{
if
self
.
ordinal
(
)
=
=
366
|
|
(
self
.
ordinal
(
)
=
=
365
&
&
!
self
.
is_in_leap_year
(
)
)
{
if
self
.
value
.
get
(
)
=
=
Self
:
:
MAX
.
value
.
get
(
)
{
None
}
else
{
unsafe
{
Some
(
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
+
1
1
)
)
}
}
}
else
{
Some
(
Self
{
value
:
unsafe
{
NonZeroI32
:
:
new_unchecked
(
self
.
value
.
get
(
)
+
1
)
}
}
)
}
}
pub
const
fn
previous_day
(
self
)
-
>
Option
<
Self
>
{
if
self
.
ordinal
(
)
!
=
1
{
Some
(
Self
{
value
:
unsafe
{
NonZeroI32
:
:
new_unchecked
(
self
.
value
.
get
(
)
-
1
)
}
}
)
}
else
if
self
.
value
.
get
(
)
=
=
Self
:
:
MIN
.
value
.
get
(
)
{
None
}
else
{
Some
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
-
1
days_in_year
(
self
.
year
(
)
-
1
)
)
}
)
}
}
pub
const
fn
next_occurrence
(
self
weekday
:
Weekday
)
-
>
Self
{
expect_opt
!
(
self
.
checked_next_occurrence
(
weekday
)
"
overflow
calculating
the
next
occurrence
of
a
weekday
"
)
}
pub
const
fn
prev_occurrence
(
self
weekday
:
Weekday
)
-
>
Self
{
expect_opt
!
(
self
.
checked_prev_occurrence
(
weekday
)
"
overflow
calculating
the
previous
occurrence
of
a
weekday
"
)
}
pub
const
fn
nth_next_occurrence
(
self
weekday
:
Weekday
n
:
u8
)
-
>
Self
{
expect_opt
!
(
self
.
checked_nth_next_occurrence
(
weekday
n
)
"
overflow
calculating
the
next
occurrence
of
a
weekday
"
)
}
pub
const
fn
nth_prev_occurrence
(
self
weekday
:
Weekday
n
:
u8
)
-
>
Self
{
expect_opt
!
(
self
.
checked_nth_prev_occurrence
(
weekday
n
)
"
overflow
calculating
the
previous
occurrence
of
a
weekday
"
)
}
pub
const
fn
to_julian_day
(
self
)
-
>
i32
{
let
(
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
let
adj_year
=
year
+
999_999
;
let
century
=
adj_year
/
100
;
let
days_before_year
=
(
1461
*
adj_year
as
i64
/
4
)
as
i32
-
century
+
century
/
4
;
days_before_year
+
ordinal
as
i32
-
363_521_075
}
pub
const
fn
checked_add
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
let
whole_days
=
duration
.
whole_days
(
)
;
if
whole_days
<
i32
:
:
MIN
as
i64
|
|
whole_days
>
i32
:
:
MAX
as
i64
{
return
None
;
}
let
julian_day
=
const_try_opt
!
(
self
.
to_julian_day
(
)
.
checked_add
(
whole_days
as
i32
)
)
;
if
let
Ok
(
date
)
=
Self
:
:
from_julian_day
(
julian_day
)
{
Some
(
date
)
}
else
{
None
}
}
pub
const
fn
checked_add_std
(
self
duration
:
StdDuration
)
-
>
Option
<
Self
>
{
let
whole_days
=
duration
.
as_secs
(
)
/
Second
:
:
per
(
Day
)
as
u64
;
if
whole_days
>
i32
:
:
MAX
as
u64
{
return
None
;
}
let
julian_day
=
const_try_opt
!
(
self
.
to_julian_day
(
)
.
checked_add
(
whole_days
as
i32
)
)
;
if
let
Ok
(
date
)
=
Self
:
:
from_julian_day
(
julian_day
)
{
Some
(
date
)
}
else
{
None
}
}
pub
const
fn
checked_sub
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
let
whole_days
=
duration
.
whole_days
(
)
;
if
whole_days
<
i32
:
:
MIN
as
i64
|
|
whole_days
>
i32
:
:
MAX
as
i64
{
return
None
;
}
let
julian_day
=
const_try_opt
!
(
self
.
to_julian_day
(
)
.
checked_sub
(
whole_days
as
i32
)
)
;
if
let
Ok
(
date
)
=
Self
:
:
from_julian_day
(
julian_day
)
{
Some
(
date
)
}
else
{
None
}
}
pub
const
fn
checked_sub_std
(
self
duration
:
StdDuration
)
-
>
Option
<
Self
>
{
let
whole_days
=
duration
.
as_secs
(
)
/
Second
:
:
per
(
Day
)
as
u64
;
if
whole_days
>
i32
:
:
MAX
as
u64
{
return
None
;
}
let
julian_day
=
const_try_opt
!
(
self
.
to_julian_day
(
)
.
checked_sub
(
whole_days
as
i32
)
)
;
if
let
Ok
(
date
)
=
Self
:
:
from_julian_day
(
julian_day
)
{
Some
(
date
)
}
else
{
None
}
}
pub
(
crate
)
const
fn
checked_next_occurrence
(
self
weekday
:
Weekday
)
-
>
Option
<
Self
>
{
let
day_diff
=
match
weekday
as
i8
-
self
.
weekday
(
)
as
i8
{
1
|
-
6
=
>
1
2
|
-
5
=
>
2
3
|
-
4
=
>
3
4
|
-
3
=
>
4
5
|
-
2
=
>
5
6
|
-
1
=
>
6
val
=
>
{
debug_assert
!
(
val
=
=
0
)
;
7
}
}
;
self
.
checked_add
(
Duration
:
:
days
(
day_diff
)
)
}
pub
(
crate
)
const
fn
checked_prev_occurrence
(
self
weekday
:
Weekday
)
-
>
Option
<
Self
>
{
let
day_diff
=
match
weekday
as
i8
-
self
.
weekday
(
)
as
i8
{
1
|
-
6
=
>
6
2
|
-
5
=
>
5
3
|
-
4
=
>
4
4
|
-
3
=
>
3
5
|
-
2
=
>
2
6
|
-
1
=
>
1
val
=
>
{
debug_assert
!
(
val
=
=
0
)
;
7
}
}
;
self
.
checked_sub
(
Duration
:
:
days
(
day_diff
)
)
}
pub
(
crate
)
const
fn
checked_nth_next_occurrence
(
self
weekday
:
Weekday
n
:
u8
)
-
>
Option
<
Self
>
{
if
n
=
=
0
{
return
None
;
}
const_try_opt
!
(
self
.
checked_next_occurrence
(
weekday
)
)
.
checked_add
(
Duration
:
:
weeks
(
n
as
i64
-
1
)
)
}
pub
(
crate
)
const
fn
checked_nth_prev_occurrence
(
self
weekday
:
Weekday
n
:
u8
)
-
>
Option
<
Self
>
{
if
n
=
=
0
{
return
None
;
}
const_try_opt
!
(
self
.
checked_prev_occurrence
(
weekday
)
)
.
checked_sub
(
Duration
:
:
weeks
(
n
as
i64
-
1
)
)
}
pub
const
fn
saturating_add
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_add
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
Self
:
:
MIN
}
else
{
debug_assert
!
(
duration
.
is_positive
(
)
)
;
Self
:
:
MAX
}
}
pub
const
fn
saturating_sub
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_sub
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
Self
:
:
MAX
}
else
{
debug_assert
!
(
duration
.
is_positive
(
)
)
;
Self
:
:
MIN
}
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_year
(
self
year
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_ranged
!
(
Year
:
year
)
;
let
ordinal
=
self
.
ordinal
(
)
;
if
ordinal
<
=
59
{
return
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
}
)
;
}
match
(
self
.
is_in_leap_year
(
)
is_leap_year
(
year
)
)
{
(
false
false
)
|
(
true
true
)
=
>
{
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
}
)
}
(
true
false
)
if
ordinal
=
=
60
=
>
Err
(
error
:
:
ComponentRange
{
name
:
"
day
"
value
:
29
minimum
:
1
maximum
:
28
conditional_message
:
Some
(
"
for
the
given
month
and
year
"
)
}
)
(
false
true
)
=
>
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
+
1
)
}
)
(
true
false
)
=
>
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
-
1
)
}
)
}
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_month
(
self
month
:
Month
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
let
(
year
_
day
)
=
self
.
to_calendar_date
(
)
;
Self
:
:
from_calendar_date
(
year
month
day
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_day
(
self
day
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
match
day
{
1
.
.
=
28
=
>
{
}
29
.
.
=
31
if
day
<
=
self
.
month
(
)
.
length
(
self
.
year
(
)
)
=
>
{
}
_
=
>
{
return
Err
(
error
:
:
ComponentRange
{
name
:
"
day
"
minimum
:
1
maximum
:
self
.
month
(
)
.
length
(
self
.
year
(
)
)
as
i64
value
:
day
as
i64
conditional_message
:
Some
(
"
for
the
given
month
and
year
"
)
}
)
;
}
}
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
(
self
.
ordinal
(
)
as
i16
-
self
.
day
(
)
as
i16
+
day
as
i16
)
as
u16
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_ordinal
(
self
ordinal
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
match
ordinal
{
1
.
.
=
365
=
>
{
}
366
if
self
.
is_in_leap_year
(
)
=
>
{
}
_
=
>
{
return
Err
(
error
:
:
ComponentRange
{
name
:
"
ordinal
"
minimum
:
1
maximum
:
days_in_year
(
self
.
year
(
)
)
as
i64
value
:
ordinal
as
i64
conditional_message
:
Some
(
"
for
the
given
year
"
)
}
)
;
}
}
Ok
(
unsafe
{
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
ordinal
)
}
)
}
}
impl
Date
{
pub
const
fn
midnight
(
self
)
-
>
PrimitiveDateTime
{
PrimitiveDateTime
:
:
new
(
self
Time
:
:
MIDNIGHT
)
}
pub
const
fn
with_time
(
self
time
:
Time
)
-
>
PrimitiveDateTime
{
PrimitiveDateTime
:
:
new
(
self
time
)
}
pub
const
fn
with_hms
(
self
hour
:
u8
minute
:
u8
second
:
u8
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms
(
hour
minute
second
)
)
)
)
}
pub
const
fn
with_hms_milli
(
self
hour
:
u8
minute
:
u8
second
:
u8
millisecond
:
u16
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms_milli
(
hour
minute
second
millisecond
)
)
)
)
}
pub
const
fn
with_hms_micro
(
self
hour
:
u8
minute
:
u8
second
:
u8
microsecond
:
u32
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms_micro
(
hour
minute
second
microsecond
)
)
)
)
}
pub
const
fn
with_hms_nano
(
self
hour
:
u8
minute
:
u8
second
:
u8
nanosecond
:
u32
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms_nano
(
hour
minute
second
nanosecond
)
)
)
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
Date
{
pub
fn
format_into
(
self
output
:
&
mut
(
impl
io
:
:
Write
+
?
Sized
)
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
Some
(
self
)
None
None
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
Some
(
self
)
None
None
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
Date
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_date
(
input
.
as_bytes
(
)
)
}
}
mod
private
{
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
DateMetadata
{
pub
(
super
)
year_width
:
u8
pub
(
super
)
display_sign
:
bool
pub
(
super
)
year
:
i32
pub
(
super
)
month
:
u8
pub
(
super
)
day
:
u8
}
}
use
private
:
:
DateMetadata
;
impl
SmartDisplay
for
Date
{
type
Metadata
=
DateMetadata
;
fn
metadata
(
&
self
_
:
FormatterOptions
)
-
>
Metadata
<
Self
>
{
let
(
year
month
day
)
=
self
.
to_calendar_date
(
)
;
let
mut
year_width
=
cmp
:
:
max
(
year
.
unsigned_abs
(
)
.
num_digits
(
)
4
)
;
let
display_sign
=
if
!
(
0
.
.
10_000
)
.
contains
(
&
year
)
{
year_width
+
=
1
;
true
}
else
{
false
}
;
let
formatted_width
=
year_width
.
extend
:
:
<
usize
>
(
)
+
smart_display
:
:
padded_width_of
!
(
"
-
"
u8
:
:
from
(
month
)
=
>
width
(
2
)
"
-
"
day
=
>
width
(
2
)
)
;
Metadata
:
:
new
(
formatted_width
self
DateMetadata
{
year_width
display_sign
year
month
:
u8
:
:
from
(
month
)
day
}
)
}
fn
fmt_with_metadata
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
metadata
:
Metadata
<
Self
>
)
-
>
fmt
:
:
Result
{
let
DateMetadata
{
year_width
display_sign
year
month
day
}
=
*
metadata
;
let
year_width
=
year_width
.
extend
(
)
;
if
display_sign
{
f
.
pad_with_width
(
metadata
.
unpadded_width
(
)
format_args
!
(
"
{
year
:
+
0year_width
}
-
{
month
:
02
}
-
{
day
:
02
}
"
)
)
}
else
{
f
.
pad_with_width
(
metadata
.
unpadded_width
(
)
format_args
!
(
"
{
year
:
0year_width
}
-
{
month
:
02
}
-
{
day
:
02
}
"
)
)
}
}
}
impl
fmt
:
:
Display
for
Date
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
SmartDisplay
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Debug
for
Date
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
Add
<
Duration
>
for
Date
{
type
Output
=
Self
;
fn
add
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
checked_add
(
duration
)
.
expect
(
"
overflow
adding
duration
to
date
"
)
}
}
impl
Add
<
StdDuration
>
for
Date
{
type
Output
=
Self
;
fn
add
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
self
.
checked_add_std
(
duration
)
.
expect
(
"
overflow
adding
duration
to
date
"
)
}
}
impl_add_assign
!
(
Date
:
Duration
StdDuration
)
;
impl
Sub
<
Duration
>
for
Date
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
checked_sub
(
duration
)
.
expect
(
"
overflow
subtracting
duration
from
date
"
)
}
}
impl
Sub
<
StdDuration
>
for
Date
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
self
.
checked_sub_std
(
duration
)
.
expect
(
"
overflow
subtracting
duration
from
date
"
)
}
}
impl_sub_assign
!
(
Date
:
Duration
StdDuration
)
;
impl
Sub
for
Date
{
type
Output
=
Duration
;
fn
sub
(
self
other
:
Self
)
-
>
Self
:
:
Output
{
Duration
:
:
days
(
(
self
.
to_julian_day
(
)
-
other
.
to_julian_day
(
)
)
.
extend
(
)
)
}
}
