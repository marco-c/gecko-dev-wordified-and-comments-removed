use
core
:
:
fmt
;
use
core
:
:
ops
:
:
{
Add
Sub
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
use
crate
:
:
util
:
:
{
days_in_year
days_in_year_month
is_leap_year
weeks_in_year
}
;
use
crate
:
:
{
error
Duration
Month
PrimitiveDateTime
Time
Weekday
}
;
pub
(
crate
)
const
MIN_YEAR
:
i32
=
if
cfg
!
(
feature
=
"
large
-
dates
"
)
{
-
999_999
}
else
{
-
9999
}
;
pub
(
crate
)
const
MAX_YEAR
:
i32
=
if
cfg
!
(
feature
=
"
large
-
dates
"
)
{
999_999
}
else
{
9999
}
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Date
{
value
:
i32
}
impl
Date
{
pub
const
MIN
:
Self
=
Self
:
:
__from_ordinal_date_unchecked
(
MIN_YEAR
1
)
;
pub
const
MAX
:
Self
=
Self
:
:
__from_ordinal_date_unchecked
(
MAX_YEAR
days_in_year
(
MAX_YEAR
)
)
;
#
[
doc
(
hidden
)
]
pub
const
fn
__from_ordinal_date_unchecked
(
year
:
i32
ordinal
:
u16
)
-
>
Self
{
debug_assert
!
(
year
>
=
MIN_YEAR
)
;
debug_assert
!
(
year
<
=
MAX_YEAR
)
;
debug_assert
!
(
ordinal
!
=
0
)
;
debug_assert
!
(
ordinal
<
=
days_in_year
(
year
)
)
;
Self
{
value
:
(
year
<
<
9
)
|
ordinal
as
i32
}
}
pub
const
fn
from_calendar_date
(
year
:
i32
month
:
Month
day
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
const
DAYS_CUMULATIVE_COMMON_LEAP
:
[
[
u16
;
12
]
;
2
]
=
[
[
0
31
59
90
120
151
181
212
243
273
304
334
]
[
0
31
60
91
121
152
182
213
244
274
305
335
]
]
;
ensure_value_in_range
!
(
year
in
MIN_YEAR
=
>
MAX_YEAR
)
;
ensure_value_in_range
!
(
day
conditionally
in
1
=
>
days_in_year_month
(
year
month
)
)
;
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
year
DAYS_CUMULATIVE_COMMON_LEAP
[
is_leap_year
(
year
)
as
usize
]
[
month
as
usize
-
1
]
+
day
as
u16
)
)
}
pub
const
fn
from_ordinal_date
(
year
:
i32
ordinal
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_value_in_range
!
(
year
in
MIN_YEAR
=
>
MAX_YEAR
)
;
ensure_value_in_range
!
(
ordinal
conditionally
in
1
=
>
days_in_year
(
year
)
)
;
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
)
}
pub
const
fn
from_iso_week_date
(
year
:
i32
week
:
u8
weekday
:
Weekday
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_value_in_range
!
(
year
in
MIN_YEAR
=
>
MAX_YEAR
)
;
ensure_value_in_range
!
(
week
conditionally
in
1
=
>
weeks_in_year
(
year
)
)
;
let
adj_year
=
year
-
1
;
let
raw
=
365
*
adj_year
+
div_floor
!
(
adj_year
4
)
-
div_floor
!
(
adj_year
100
)
+
div_floor
!
(
adj_year
400
)
;
let
jan_4
=
match
(
raw
%
7
)
as
i8
{
-
6
|
1
=
>
8
-
5
|
2
=
>
9
-
4
|
3
=
>
10
-
3
|
4
=
>
4
-
2
|
5
=
>
5
-
1
|
6
=
>
6
_
=
>
7
}
;
let
ordinal
=
week
as
i16
*
7
+
weekday
.
number_from_monday
(
)
as
i16
-
jan_4
;
Ok
(
if
ordinal
<
=
0
{
Self
:
:
__from_ordinal_date_unchecked
(
year
-
1
(
ordinal
as
u16
)
.
wrapping_add
(
days_in_year
(
year
-
1
)
)
)
}
else
if
ordinal
>
days_in_year
(
year
)
as
i16
{
Self
:
:
__from_ordinal_date_unchecked
(
year
+
1
ordinal
as
u16
-
days_in_year
(
year
)
)
}
else
{
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
as
_
)
}
)
}
#
[
doc
(
alias
=
"
from_julian_date
"
)
]
pub
const
fn
from_julian_day
(
julian_day
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_value_in_range
!
(
julian_day
in
Self
:
:
MIN
.
to_julian_day
(
)
=
>
Self
:
:
MAX
.
to_julian_day
(
)
)
;
Ok
(
Self
:
:
from_julian_day_unchecked
(
julian_day
)
)
}
#
[
doc
(
alias
=
"
from_julian_date_unchecked
"
)
]
pub
(
crate
)
const
fn
from_julian_day_unchecked
(
julian_day
:
i32
)
-
>
Self
{
debug_assert
!
(
julian_day
>
=
Self
:
:
MIN
.
to_julian_day
(
)
)
;
debug_assert
!
(
julian_day
<
=
Self
:
:
MAX
.
to_julian_day
(
)
)
;
let
z
=
julian_day
-
1_721_119
;
let
(
mut
year
mut
ordinal
)
=
if
julian_day
<
-
19_752_948
|
|
julian_day
>
23_195_514
{
let
g
=
100
*
z
as
i64
-
25
;
let
a
=
(
g
/
3_652_425
)
as
i32
;
let
b
=
a
-
a
/
4
;
let
year
=
div_floor
!
(
100
*
b
as
i64
+
g
36525
)
as
i32
;
let
ordinal
=
(
b
+
z
-
div_floor
!
(
36525
*
year
as
i64
100
)
as
i32
)
as
_
;
(
year
ordinal
)
}
else
{
let
g
=
100
*
z
-
25
;
let
a
=
g
/
3_652_425
;
let
b
=
a
-
a
/
4
;
let
year
=
div_floor
!
(
100
*
b
+
g
36525
)
;
let
ordinal
=
(
b
+
z
-
div_floor
!
(
36525
*
year
100
)
)
as
_
;
(
year
ordinal
)
}
;
if
is_leap_year
(
year
)
{
ordinal
+
=
60
;
cascade
!
(
ordinal
in
1
.
.
367
=
>
year
)
;
}
else
{
ordinal
+
=
59
;
cascade
!
(
ordinal
in
1
.
.
366
=
>
year
)
;
}
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
}
pub
const
fn
year
(
self
)
-
>
i32
{
self
.
value
>
>
9
}
pub
const
fn
month
(
self
)
-
>
Month
{
self
.
month_day
(
)
.
0
}
pub
const
fn
day
(
self
)
-
>
u8
{
self
.
month_day
(
)
.
1
}
pub
(
crate
)
const
fn
month_day
(
self
)
-
>
(
Month
u8
)
{
const
CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP
:
[
[
u16
;
11
]
;
2
]
=
[
[
31
59
90
120
151
181
212
243
273
304
334
]
[
31
60
91
121
152
182
213
244
274
305
335
]
]
;
let
days
=
CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP
[
is_leap_year
(
self
.
year
(
)
)
as
usize
]
;
let
ordinal
=
self
.
ordinal
(
)
;
if
ordinal
>
days
[
10
]
{
(
Month
:
:
December
(
ordinal
-
days
[
10
]
)
as
_
)
}
else
if
ordinal
>
days
[
9
]
{
(
Month
:
:
November
(
ordinal
-
days
[
9
]
)
as
_
)
}
else
if
ordinal
>
days
[
8
]
{
(
Month
:
:
October
(
ordinal
-
days
[
8
]
)
as
_
)
}
else
if
ordinal
>
days
[
7
]
{
(
Month
:
:
September
(
ordinal
-
days
[
7
]
)
as
_
)
}
else
if
ordinal
>
days
[
6
]
{
(
Month
:
:
August
(
ordinal
-
days
[
6
]
)
as
_
)
}
else
if
ordinal
>
days
[
5
]
{
(
Month
:
:
July
(
ordinal
-
days
[
5
]
)
as
_
)
}
else
if
ordinal
>
days
[
4
]
{
(
Month
:
:
June
(
ordinal
-
days
[
4
]
)
as
_
)
}
else
if
ordinal
>
days
[
3
]
{
(
Month
:
:
May
(
ordinal
-
days
[
3
]
)
as
_
)
}
else
if
ordinal
>
days
[
2
]
{
(
Month
:
:
April
(
ordinal
-
days
[
2
]
)
as
_
)
}
else
if
ordinal
>
days
[
1
]
{
(
Month
:
:
March
(
ordinal
-
days
[
1
]
)
as
_
)
}
else
if
ordinal
>
days
[
0
]
{
(
Month
:
:
February
(
ordinal
-
days
[
0
]
)
as
_
)
}
else
{
(
Month
:
:
January
ordinal
as
_
)
}
}
pub
const
fn
ordinal
(
self
)
-
>
u16
{
(
self
.
value
&
0x1FF
)
as
_
}
pub
(
crate
)
const
fn
iso_year_week
(
self
)
-
>
(
i32
u8
)
{
let
(
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
match
(
(
ordinal
+
10
-
self
.
weekday
(
)
.
number_from_monday
(
)
as
u16
)
/
7
)
as
_
{
0
=
>
(
year
-
1
weeks_in_year
(
year
-
1
)
)
53
if
weeks_in_year
(
year
)
=
=
52
=
>
(
year
+
1
1
)
week
=
>
(
year
week
)
}
}
pub
const
fn
iso_week
(
self
)
-
>
u8
{
self
.
iso_year_week
(
)
.
1
}
pub
const
fn
sunday_based_week
(
self
)
-
>
u8
{
(
(
self
.
ordinal
(
)
as
i16
-
self
.
weekday
(
)
.
number_days_from_sunday
(
)
as
i16
+
6
)
/
7
)
as
_
}
pub
const
fn
monday_based_week
(
self
)
-
>
u8
{
(
(
self
.
ordinal
(
)
as
i16
-
self
.
weekday
(
)
.
number_days_from_monday
(
)
as
i16
+
6
)
/
7
)
as
_
}
pub
const
fn
to_calendar_date
(
self
)
-
>
(
i32
Month
u8
)
{
let
(
month
day
)
=
self
.
month_day
(
)
;
(
self
.
year
(
)
month
day
)
}
pub
const
fn
to_ordinal_date
(
self
)
-
>
(
i32
u16
)
{
(
self
.
year
(
)
self
.
ordinal
(
)
)
}
pub
const
fn
to_iso_week_date
(
self
)
-
>
(
i32
u8
Weekday
)
{
let
(
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
let
weekday
=
self
.
weekday
(
)
;
match
(
(
ordinal
+
10
-
self
.
weekday
(
)
.
number_from_monday
(
)
as
u16
)
/
7
)
as
_
{
0
=
>
(
year
-
1
weeks_in_year
(
year
-
1
)
weekday
)
53
if
weeks_in_year
(
year
)
=
=
52
=
>
(
year
+
1
1
weekday
)
week
=
>
(
year
week
weekday
)
}
}
pub
const
fn
weekday
(
self
)
-
>
Weekday
{
match
self
.
to_julian_day
(
)
%
7
{
-
6
|
1
=
>
Weekday
:
:
Tuesday
-
5
|
2
=
>
Weekday
:
:
Wednesday
-
4
|
3
=
>
Weekday
:
:
Thursday
-
3
|
4
=
>
Weekday
:
:
Friday
-
2
|
5
=
>
Weekday
:
:
Saturday
-
1
|
6
=
>
Weekday
:
:
Sunday
val
=
>
{
debug_assert
!
(
val
=
=
0
)
;
Weekday
:
:
Monday
}
}
}
pub
const
fn
next_day
(
self
)
-
>
Option
<
Self
>
{
if
self
.
ordinal
(
)
=
=
366
|
|
(
self
.
ordinal
(
)
=
=
365
&
&
!
is_leap_year
(
self
.
year
(
)
)
)
{
if
self
.
value
=
=
Self
:
:
MAX
.
value
{
None
}
else
{
Some
(
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
+
1
1
)
)
}
}
else
{
Some
(
Self
{
value
:
self
.
value
+
1
}
)
}
}
pub
const
fn
previous_day
(
self
)
-
>
Option
<
Self
>
{
if
self
.
ordinal
(
)
!
=
1
{
Some
(
Self
{
value
:
self
.
value
-
1
}
)
}
else
if
self
.
value
=
=
Self
:
:
MIN
.
value
{
None
}
else
{
Some
(
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
-
1
days_in_year
(
self
.
year
(
)
-
1
)
)
)
}
}
pub
const
fn
to_julian_day
(
self
)
-
>
i32
{
let
year
=
self
.
year
(
)
-
1
;
let
ordinal
=
self
.
ordinal
(
)
as
i32
;
ordinal
+
365
*
year
+
div_floor
!
(
year
4
)
-
div_floor
!
(
year
100
)
+
div_floor
!
(
year
400
)
+
1_721_425
}
pub
const
fn
checked_add
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
let
whole_days
=
duration
.
whole_days
(
)
;
if
whole_days
<
i32
:
:
MIN
as
i64
|
|
whole_days
>
i32
:
:
MAX
as
i64
{
return
None
;
}
let
julian_day
=
const_try_opt
!
(
self
.
to_julian_day
(
)
.
checked_add
(
whole_days
as
_
)
)
;
if
let
Ok
(
date
)
=
Self
:
:
from_julian_day
(
julian_day
)
{
Some
(
date
)
}
else
{
None
}
}
pub
const
fn
checked_sub
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
let
whole_days
=
duration
.
whole_days
(
)
;
if
whole_days
<
i32
:
:
MIN
as
i64
|
|
whole_days
>
i32
:
:
MAX
as
i64
{
return
None
;
}
let
julian_day
=
const_try_opt
!
(
self
.
to_julian_day
(
)
.
checked_sub
(
whole_days
as
_
)
)
;
if
let
Ok
(
date
)
=
Self
:
:
from_julian_day
(
julian_day
)
{
Some
(
date
)
}
else
{
None
}
}
pub
const
fn
saturating_add
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_add
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
Self
:
:
MIN
}
else
{
debug_assert
!
(
duration
.
is_positive
(
)
)
;
Self
:
:
MAX
}
}
pub
const
fn
saturating_sub
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_sub
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
Self
:
:
MAX
}
else
{
debug_assert
!
(
duration
.
is_positive
(
)
)
;
Self
:
:
MIN
}
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_year
(
self
year
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_value_in_range
!
(
year
in
MIN_YEAR
=
>
MAX_YEAR
)
;
let
ordinal
=
self
.
ordinal
(
)
;
if
ordinal
<
=
59
{
return
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
)
;
}
match
(
is_leap_year
(
self
.
year
(
)
)
is_leap_year
(
year
)
)
{
(
false
false
)
|
(
true
true
)
=
>
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
)
(
true
false
)
if
ordinal
=
=
60
=
>
Err
(
error
:
:
ComponentRange
{
name
:
"
day
"
value
:
29
minimum
:
1
maximum
:
28
conditional_range
:
true
}
)
(
false
true
)
=
>
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
+
1
)
)
(
true
false
)
=
>
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
year
ordinal
-
1
)
)
}
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_month
(
self
month
:
Month
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
let
(
year
_
day
)
=
self
.
to_calendar_date
(
)
;
Self
:
:
from_calendar_date
(
year
month
day
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Date
.
"
]
pub
const
fn
replace_day
(
self
day
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
if
day
=
=
0
|
|
day
>
=
29
{
ensure_value_in_range
!
(
day
conditionally
in
1
=
>
days_in_year_month
(
self
.
year
(
)
self
.
month
(
)
)
)
;
}
Ok
(
Self
:
:
__from_ordinal_date_unchecked
(
self
.
year
(
)
(
self
.
ordinal
(
)
as
i16
-
self
.
day
(
)
as
i16
+
day
as
i16
)
as
_
)
)
}
}
impl
Date
{
pub
const
fn
midnight
(
self
)
-
>
PrimitiveDateTime
{
PrimitiveDateTime
:
:
new
(
self
Time
:
:
MIDNIGHT
)
}
pub
const
fn
with_time
(
self
time
:
Time
)
-
>
PrimitiveDateTime
{
PrimitiveDateTime
:
:
new
(
self
time
)
}
pub
const
fn
with_hms
(
self
hour
:
u8
minute
:
u8
second
:
u8
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms
(
hour
minute
second
)
)
)
)
}
pub
const
fn
with_hms_milli
(
self
hour
:
u8
minute
:
u8
second
:
u8
millisecond
:
u16
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms_milli
(
hour
minute
second
millisecond
)
)
)
)
}
pub
const
fn
with_hms_micro
(
self
hour
:
u8
minute
:
u8
second
:
u8
microsecond
:
u32
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms_micro
(
hour
minute
second
microsecond
)
)
)
)
}
pub
const
fn
with_hms_nano
(
self
hour
:
u8
minute
:
u8
second
:
u8
nanosecond
:
u32
)
-
>
Result
<
PrimitiveDateTime
error
:
:
ComponentRange
>
{
Ok
(
PrimitiveDateTime
:
:
new
(
self
const_try
!
(
Time
:
:
from_hms_nano
(
hour
minute
second
nanosecond
)
)
)
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
Date
{
pub
fn
format_into
(
self
output
:
&
mut
impl
io
:
:
Write
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
Some
(
self
)
None
None
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
Some
(
self
)
None
None
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
Date
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_date
(
input
.
as_bytes
(
)
)
}
}
impl
fmt
:
:
Display
for
Date
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
cfg
!
(
feature
=
"
large
-
dates
"
)
&
&
self
.
year
(
)
.
abs
(
)
>
=
10_000
{
write
!
(
f
"
{
:
+
}
-
{
:
02
}
-
{
:
02
}
"
self
.
year
(
)
self
.
month
(
)
as
u8
self
.
day
(
)
)
}
else
{
write
!
(
f
"
{
:
0width
}
-
{
:
02
}
-
{
:
02
}
"
self
.
year
(
)
self
.
month
(
)
as
u8
self
.
day
(
)
width
=
4
+
(
self
.
year
(
)
<
0
)
as
usize
)
}
}
}
impl
fmt
:
:
Debug
for
Date
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
Add
<
Duration
>
for
Date
{
type
Output
=
Self
;
fn
add
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
checked_add
(
duration
)
.
expect
(
"
overflow
adding
duration
to
date
"
)
}
}
impl
Add
<
StdDuration
>
for
Date
{
type
Output
=
Self
;
fn
add
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
Self
:
:
from_julian_day
(
self
.
to_julian_day
(
)
+
(
duration
.
as_secs
(
)
/
86_400
)
as
i32
)
.
expect
(
"
overflow
adding
duration
to
date
"
)
}
}
impl_add_assign
!
(
Date
:
Duration
StdDuration
)
;
impl
Sub
<
Duration
>
for
Date
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
checked_sub
(
duration
)
.
expect
(
"
overflow
subtracting
duration
from
date
"
)
}
}
impl
Sub
<
StdDuration
>
for
Date
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
Self
:
:
from_julian_day
(
self
.
to_julian_day
(
)
-
(
duration
.
as_secs
(
)
/
86_400
)
as
i32
)
.
expect
(
"
overflow
subtracting
duration
from
date
"
)
}
}
impl_sub_assign
!
(
Date
:
Duration
StdDuration
)
;
impl
Sub
for
Date
{
type
Output
=
Duration
;
fn
sub
(
self
other
:
Self
)
-
>
Self
:
:
Output
{
Duration
:
:
days
(
(
self
.
to_julian_day
(
)
-
other
.
to_julian_day
(
)
)
as
_
)
}
}
