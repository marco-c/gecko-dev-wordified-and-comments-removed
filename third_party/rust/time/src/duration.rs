use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
;
use
core
:
:
iter
:
:
Sum
;
use
core
:
:
ops
:
:
{
Add
AddAssign
Div
Mul
Neg
Sub
SubAssign
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
use
crate
:
:
error
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
crate
:
:
Instant
;
#
[
repr
(
u32
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
(
crate
)
enum
Padding
{
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
Optimize
}
impl
Default
for
Padding
{
fn
default
(
)
-
>
Self
{
Self
:
:
Optimize
}
}
#
[
derive
(
Clone
Copy
Default
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Duration
{
seconds
:
i64
nanoseconds
:
i32
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
padding
:
Padding
}
impl
fmt
:
:
Debug
for
Duration
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Duration
"
)
.
field
(
"
seconds
"
&
self
.
seconds
)
.
field
(
"
nanoseconds
"
&
self
.
nanoseconds
)
.
finish
(
)
}
}
impl
Duration
{
pub
const
ZERO
:
Self
=
Self
:
:
seconds
(
0
)
;
pub
const
NANOSECOND
:
Self
=
Self
:
:
nanoseconds
(
1
)
;
pub
const
MICROSECOND
:
Self
=
Self
:
:
microseconds
(
1
)
;
pub
const
MILLISECOND
:
Self
=
Self
:
:
milliseconds
(
1
)
;
pub
const
SECOND
:
Self
=
Self
:
:
seconds
(
1
)
;
pub
const
MINUTE
:
Self
=
Self
:
:
minutes
(
1
)
;
pub
const
HOUR
:
Self
=
Self
:
:
hours
(
1
)
;
pub
const
DAY
:
Self
=
Self
:
:
days
(
1
)
;
pub
const
WEEK
:
Self
=
Self
:
:
weeks
(
1
)
;
pub
const
MIN
:
Self
=
Self
:
:
new_unchecked
(
i64
:
:
MIN
-
999_999_999
)
;
pub
const
MAX
:
Self
=
Self
:
:
new_unchecked
(
i64
:
:
MAX
999_999_999
)
;
pub
const
fn
is_zero
(
self
)
-
>
bool
{
self
.
seconds
=
=
0
&
&
self
.
nanoseconds
=
=
0
}
pub
const
fn
is_negative
(
self
)
-
>
bool
{
self
.
seconds
<
0
|
|
self
.
nanoseconds
<
0
}
pub
const
fn
is_positive
(
self
)
-
>
bool
{
self
.
seconds
>
0
|
|
self
.
nanoseconds
>
0
}
pub
const
fn
abs
(
self
)
-
>
Self
{
Self
:
:
new_unchecked
(
self
.
seconds
.
saturating_abs
(
)
self
.
nanoseconds
.
abs
(
)
)
}
pub
const
fn
unsigned_abs
(
self
)
-
>
StdDuration
{
StdDuration
:
:
new
(
self
.
seconds
.
unsigned_abs
(
)
self
.
nanoseconds
.
unsigned_abs
(
)
)
}
pub
(
crate
)
const
fn
new_unchecked
(
seconds
:
i64
nanoseconds
:
i32
)
-
>
Self
{
if
seconds
<
0
{
debug_assert
!
(
nanoseconds
<
=
0
)
;
debug_assert
!
(
nanoseconds
>
-
1_000_000_000
)
;
}
else
if
seconds
>
0
{
debug_assert
!
(
nanoseconds
>
=
0
)
;
debug_assert
!
(
nanoseconds
<
1_000_000_000
)
;
}
else
{
debug_assert
!
(
nanoseconds
.
unsigned_abs
(
)
<
1_000_000_000
)
;
}
Self
{
seconds
nanoseconds
padding
:
Padding
:
:
Optimize
}
}
pub
const
fn
new
(
mut
seconds
:
i64
mut
nanoseconds
:
i32
)
-
>
Self
{
seconds
=
expect_opt
!
(
seconds
.
checked_add
(
nanoseconds
as
i64
/
1_000_000_000
)
"
overflow
constructing
time
:
:
Duration
"
)
;
nanoseconds
%
=
1_000_000_000
;
if
seconds
>
0
&
&
nanoseconds
<
0
{
seconds
-
=
1
;
nanoseconds
+
=
1_000_000_000
;
}
else
if
seconds
<
0
&
&
nanoseconds
>
0
{
seconds
+
=
1
;
nanoseconds
-
=
1_000_000_000
;
}
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
pub
const
fn
weeks
(
weeks
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
weeks
.
checked_mul
(
604_800
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
days
(
days
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
days
.
checked_mul
(
86_400
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
hours
(
hours
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
hours
.
checked_mul
(
3_600
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
minutes
(
minutes
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
minutes
.
checked_mul
(
60
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
seconds
(
seconds
:
i64
)
-
>
Self
{
Self
:
:
new_unchecked
(
seconds
0
)
}
pub
fn
seconds_f64
(
seconds
:
f64
)
-
>
Self
{
if
seconds
>
i64
:
:
MAX
as
f64
|
|
seconds
<
i64
:
:
MIN
as
f64
{
crate
:
:
expect_failed
(
"
overflow
constructing
time
:
:
Duration
"
)
;
}
if
seconds
.
is_nan
(
)
{
crate
:
:
expect_failed
(
"
passed
NaN
to
time
:
:
Duration
:
:
seconds_f64
"
)
;
}
Self
:
:
new_unchecked
(
seconds
as
_
(
(
seconds
%
1
.
)
*
1_000_000_000
.
)
as
_
)
}
pub
fn
seconds_f32
(
seconds
:
f32
)
-
>
Self
{
if
seconds
>
i64
:
:
MAX
as
f32
|
|
seconds
<
i64
:
:
MIN
as
f32
{
crate
:
:
expect_failed
(
"
overflow
constructing
time
:
:
Duration
"
)
;
}
if
seconds
.
is_nan
(
)
{
crate
:
:
expect_failed
(
"
passed
NaN
to
time
:
:
Duration
:
:
seconds_f32
"
)
;
}
Self
:
:
new_unchecked
(
seconds
as
_
(
(
seconds
%
1
.
)
*
1_000_000_000
.
)
as
_
)
}
pub
const
fn
milliseconds
(
milliseconds
:
i64
)
-
>
Self
{
Self
:
:
new_unchecked
(
milliseconds
/
1_000
(
(
milliseconds
%
1_000
)
*
1_000_000
)
as
_
)
}
pub
const
fn
microseconds
(
microseconds
:
i64
)
-
>
Self
{
Self
:
:
new_unchecked
(
microseconds
/
1_000_000
(
(
microseconds
%
1_000_000
)
*
1_000
)
as
_
)
}
pub
const
fn
nanoseconds
(
nanoseconds
:
i64
)
-
>
Self
{
Self
:
:
new_unchecked
(
nanoseconds
/
1_000_000_000
(
nanoseconds
%
1_000_000_000
)
as
_
)
}
pub
(
crate
)
const
fn
nanoseconds_i128
(
nanoseconds
:
i128
)
-
>
Self
{
let
seconds
=
nanoseconds
/
1_000_000_000
;
let
nanoseconds
=
nanoseconds
%
1_000_000_000
;
if
seconds
>
i64
:
:
MAX
as
i128
|
|
seconds
<
i64
:
:
MIN
as
i128
{
crate
:
:
expect_failed
(
"
overflow
constructing
time
:
:
Duration
"
)
;
}
Self
:
:
new_unchecked
(
seconds
as
_
nanoseconds
as
_
)
}
pub
const
fn
whole_weeks
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
604_800
}
pub
const
fn
whole_days
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
86_400
}
pub
const
fn
whole_hours
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
3_600
}
pub
const
fn
whole_minutes
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
60
}
pub
const
fn
whole_seconds
(
self
)
-
>
i64
{
self
.
seconds
}
pub
fn
as_seconds_f64
(
self
)
-
>
f64
{
self
.
seconds
as
f64
+
self
.
nanoseconds
as
f64
/
1_000_000_000
.
}
pub
fn
as_seconds_f32
(
self
)
-
>
f32
{
self
.
seconds
as
f32
+
self
.
nanoseconds
as
f32
/
1_000_000_000
.
}
pub
const
fn
whole_milliseconds
(
self
)
-
>
i128
{
self
.
seconds
as
i128
*
1_000
+
self
.
nanoseconds
as
i128
/
1_000_000
}
pub
const
fn
subsec_milliseconds
(
self
)
-
>
i16
{
(
self
.
nanoseconds
/
1_000_000
)
as
_
}
pub
const
fn
whole_microseconds
(
self
)
-
>
i128
{
self
.
seconds
as
i128
*
1_000_000
+
self
.
nanoseconds
as
i128
/
1_000
}
pub
const
fn
subsec_microseconds
(
self
)
-
>
i32
{
self
.
nanoseconds
/
1_000
}
pub
const
fn
whole_nanoseconds
(
self
)
-
>
i128
{
self
.
seconds
as
i128
*
1_000_000_000
+
self
.
nanoseconds
as
i128
}
pub
const
fn
subsec_nanoseconds
(
self
)
-
>
i32
{
self
.
nanoseconds
}
pub
const
fn
checked_add
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
{
let
mut
seconds
=
const_try_opt
!
(
self
.
seconds
.
checked_add
(
rhs
.
seconds
)
)
;
let
mut
nanoseconds
=
self
.
nanoseconds
+
rhs
.
nanoseconds
;
if
nanoseconds
>
=
1_000_000_000
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
1_000_000_000
;
seconds
=
const_try_opt
!
(
seconds
.
checked_add
(
1
)
)
;
}
else
if
nanoseconds
<
=
-
1_000_000_000
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
1_000_000_000
;
seconds
=
const_try_opt
!
(
seconds
.
checked_sub
(
1
)
)
;
}
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
pub
const
fn
checked_sub
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
{
let
mut
seconds
=
const_try_opt
!
(
self
.
seconds
.
checked_sub
(
rhs
.
seconds
)
)
;
let
mut
nanoseconds
=
self
.
nanoseconds
-
rhs
.
nanoseconds
;
if
nanoseconds
>
=
1_000_000_000
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
1_000_000_000
;
seconds
=
const_try_opt
!
(
seconds
.
checked_add
(
1
)
)
;
}
else
if
nanoseconds
<
=
-
1_000_000_000
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
1_000_000_000
;
seconds
=
const_try_opt
!
(
seconds
.
checked_sub
(
1
)
)
;
}
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
pub
const
fn
checked_mul
(
self
rhs
:
i32
)
-
>
Option
<
Self
>
{
let
total_nanos
=
self
.
nanoseconds
as
i64
*
rhs
as
i64
;
let
extra_secs
=
total_nanos
/
1_000_000_000
;
let
nanoseconds
=
(
total_nanos
%
1_000_000_000
)
as
_
;
let
seconds
=
const_try_opt
!
(
const_try_opt
!
(
self
.
seconds
.
checked_mul
(
rhs
as
_
)
)
.
checked_add
(
extra_secs
)
)
;
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
pub
const
fn
checked_div
(
self
rhs
:
i32
)
-
>
Option
<
Self
>
{
let
seconds
=
const_try_opt
!
(
self
.
seconds
.
checked_div
(
rhs
as
i64
)
)
;
let
carry
=
self
.
seconds
-
seconds
*
(
rhs
as
i64
)
;
let
extra_nanos
=
const_try_opt
!
(
(
carry
*
1_000_000_000
)
.
checked_div
(
rhs
as
i64
)
)
;
let
nanoseconds
=
const_try_opt
!
(
self
.
nanoseconds
.
checked_div
(
rhs
)
)
+
(
extra_nanos
as
i32
)
;
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
pub
const
fn
saturating_add
(
self
rhs
:
Self
)
-
>
Self
{
let
(
mut
seconds
overflow
)
=
self
.
seconds
.
overflowing_add
(
rhs
.
seconds
)
;
if
overflow
{
if
self
.
seconds
>
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
let
mut
nanoseconds
=
self
.
nanoseconds
+
rhs
.
nanoseconds
;
if
nanoseconds
>
=
1_000_000_000
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
1_000_000_000
;
seconds
=
match
seconds
.
checked_add
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MAX
}
;
}
else
if
nanoseconds
<
=
-
1_000_000_000
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
1_000_000_000
;
seconds
=
match
seconds
.
checked_sub
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MIN
}
;
}
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
pub
const
fn
saturating_sub
(
self
rhs
:
Self
)
-
>
Self
{
let
(
mut
seconds
overflow
)
=
self
.
seconds
.
overflowing_sub
(
rhs
.
seconds
)
;
if
overflow
{
if
self
.
seconds
>
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
let
mut
nanoseconds
=
self
.
nanoseconds
-
rhs
.
nanoseconds
;
if
nanoseconds
>
=
1_000_000_000
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
1_000_000_000
;
seconds
=
match
seconds
.
checked_add
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MAX
}
;
}
else
if
nanoseconds
<
=
-
1_000_000_000
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
1_000_000_000
;
seconds
=
match
seconds
.
checked_sub
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MIN
}
;
}
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
pub
const
fn
saturating_mul
(
self
rhs
:
i32
)
-
>
Self
{
let
total_nanos
=
self
.
nanoseconds
as
i64
*
rhs
as
i64
;
let
extra_secs
=
total_nanos
/
1_000_000_000
;
let
nanoseconds
=
(
total_nanos
%
1_000_000_000
)
as
_
;
let
(
seconds
overflow1
)
=
self
.
seconds
.
overflowing_mul
(
rhs
as
_
)
;
if
overflow1
{
if
self
.
seconds
>
0
&
&
rhs
>
0
|
|
self
.
seconds
<
0
&
&
rhs
<
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
let
(
seconds
overflow2
)
=
seconds
.
overflowing_add
(
extra_secs
)
;
if
overflow2
{
if
self
.
seconds
>
0
&
&
rhs
>
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
time_fn
<
T
>
(
f
:
impl
FnOnce
(
)
-
>
T
)
-
>
(
Self
T
)
{
let
start
=
Instant
:
:
now
(
)
;
let
return_value
=
f
(
)
;
let
end
=
Instant
:
:
now
(
)
;
(
end
-
start
return_value
)
}
}
impl
fmt
:
:
Display
for
Duration
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
is_negative
(
)
{
f
.
write_str
(
"
-
"
)
?
;
}
if
let
Some
(
_precision
)
=
f
.
precision
(
)
{
if
self
.
is_zero
(
)
{
return
(
0
.
)
.
fmt
(
f
)
.
and_then
(
|
_
|
f
.
write_str
(
"
s
"
)
)
;
}
macro_rules
!
item
{
(
name
:
literal
value
:
expr
)
=
>
{
let
value
=
value
;
if
value
>
=
1
.
0
{
return
value
.
fmt
(
f
)
.
and_then
(
|
_
|
f
.
write_str
(
name
)
)
;
}
}
;
}
let
seconds
=
self
.
unsigned_abs
(
)
.
as_secs_f64
(
)
;
item
!
(
"
d
"
seconds
/
86_400
.
)
;
item
!
(
"
h
"
seconds
/
3_600
.
)
;
item
!
(
"
m
"
seconds
/
60
.
)
;
item
!
(
"
s
"
seconds
)
;
item
!
(
"
ms
"
seconds
*
1_000
.
)
;
item
!
(
"
s
"
seconds
*
1_000_000
.
)
;
item
!
(
"
ns
"
seconds
*
1_000_000_000
.
)
;
}
else
{
if
self
.
is_zero
(
)
{
return
f
.
write_str
(
"
0s
"
)
;
}
macro_rules
!
item
{
(
name
:
literal
value
:
expr
)
=
>
{
match
value
{
0
=
>
Ok
(
(
)
)
value
=
>
value
.
fmt
(
f
)
.
and_then
(
|
_
|
f
.
write_str
(
name
)
)
}
}
;
}
let
seconds
=
self
.
seconds
.
unsigned_abs
(
)
;
let
nanoseconds
=
self
.
nanoseconds
.
unsigned_abs
(
)
;
item
!
(
"
d
"
seconds
/
86_400
)
?
;
item
!
(
"
h
"
seconds
/
3_600
%
24
)
?
;
item
!
(
"
m
"
seconds
/
60
%
60
)
?
;
item
!
(
"
s
"
seconds
%
60
)
?
;
item
!
(
"
ms
"
nanoseconds
/
1_000_000
)
?
;
item
!
(
"
s
"
nanoseconds
/
1_000
%
1_000
)
?
;
item
!
(
"
ns
"
nanoseconds
%
1_000
)
?
;
}
Ok
(
(
)
)
}
}
impl
TryFrom
<
StdDuration
>
for
Duration
{
type
Error
=
error
:
:
ConversionRange
;
fn
try_from
(
original
:
StdDuration
)
-
>
Result
<
Self
error
:
:
ConversionRange
>
{
Ok
(
Self
:
:
new
(
original
.
as_secs
(
)
.
try_into
(
)
.
map_err
(
|
_
|
error
:
:
ConversionRange
)
?
original
.
subsec_nanos
(
)
as
_
)
)
}
}
impl
TryFrom
<
Duration
>
for
StdDuration
{
type
Error
=
error
:
:
ConversionRange
;
fn
try_from
(
duration
:
Duration
)
-
>
Result
<
Self
error
:
:
ConversionRange
>
{
Ok
(
Self
:
:
new
(
duration
.
seconds
.
try_into
(
)
.
map_err
(
|
_
|
error
:
:
ConversionRange
)
?
duration
.
nanoseconds
.
try_into
(
)
.
map_err
(
|
_
|
error
:
:
ConversionRange
)
?
)
)
}
}
impl
Add
for
Duration
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
checked_add
(
rhs
)
.
expect
(
"
overflow
when
adding
durations
"
)
}
}
impl
Add
<
StdDuration
>
for
Duration
{
type
Output
=
Self
;
fn
add
(
self
std_duration
:
StdDuration
)
-
>
Self
:
:
Output
{
self
+
Self
:
:
try_from
(
std_duration
)
.
expect
(
"
overflow
converting
std
:
:
time
:
:
Duration
to
time
:
:
Duration
"
)
}
}
impl
Add
<
Duration
>
for
StdDuration
{
type
Output
=
Duration
;
fn
add
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
+
self
}
}
impl_add_assign
!
(
Duration
:
Self
StdDuration
)
;
impl
AddAssign
<
Duration
>
for
StdDuration
{
fn
add_assign
(
&
mut
self
rhs
:
Duration
)
{
*
self
=
(
*
self
+
rhs
)
.
try_into
(
)
.
expect
(
"
Cannot
represent
a
resulting
duration
in
std
.
Try
let
x
=
x
+
rhs
;
which
will
\
change
the
type
.
"
)
;
}
}
impl
Neg
for
Duration
{
type
Output
=
Self
;
fn
neg
(
self
)
-
>
Self
:
:
Output
{
Self
:
:
new_unchecked
(
-
self
.
seconds
-
self
.
nanoseconds
)
}
}
impl
Sub
for
Duration
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
checked_sub
(
rhs
)
.
expect
(
"
overflow
when
subtracting
durations
"
)
}
}
impl
Sub
<
StdDuration
>
for
Duration
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
StdDuration
)
-
>
Self
:
:
Output
{
self
-
Self
:
:
try_from
(
rhs
)
.
expect
(
"
overflow
converting
std
:
:
time
:
:
Duration
to
time
:
:
Duration
"
)
}
}
impl
Sub
<
Duration
>
for
StdDuration
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
Duration
:
:
try_from
(
self
)
.
expect
(
"
overflow
converting
std
:
:
time
:
:
Duration
to
time
:
:
Duration
"
)
-
rhs
}
}
impl_sub_assign
!
(
Duration
:
Self
StdDuration
)
;
impl
SubAssign
<
Duration
>
for
StdDuration
{
fn
sub_assign
(
&
mut
self
rhs
:
Duration
)
{
*
self
=
(
*
self
-
rhs
)
.
try_into
(
)
.
expect
(
"
Cannot
represent
a
resulting
duration
in
std
.
Try
let
x
=
x
-
rhs
;
which
will
\
change
the
type
.
"
)
;
}
}
macro_rules
!
duration_mul_div_int
{
(
(
type
:
ty
)
+
)
=
>
{
(
impl
Mul
<
type
>
for
Duration
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
type
)
-
>
Self
:
:
Output
{
Self
:
:
nanoseconds_i128
(
self
.
whole_nanoseconds
(
)
.
checked_mul
(
rhs
as
_
)
.
expect
(
"
overflow
when
multiplying
duration
"
)
)
}
}
impl
Mul
<
Duration
>
for
type
{
type
Output
=
Duration
;
fn
mul
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
*
self
}
}
impl
Div
<
type
>
for
Duration
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
type
)
-
>
Self
:
:
Output
{
Self
:
:
nanoseconds_i128
(
self
.
whole_nanoseconds
(
)
/
rhs
as
i128
)
}
}
)
+
}
;
}
duration_mul_div_int
!
[
i8
i16
i32
u8
u16
u32
]
;
impl
Mul
<
f32
>
for
Duration
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
f32
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f32
(
self
.
as_seconds_f32
(
)
*
rhs
)
}
}
impl
Mul
<
Duration
>
for
f32
{
type
Output
=
Duration
;
fn
mul
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
*
self
}
}
impl
Mul
<
f64
>
for
Duration
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
f64
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f64
(
self
.
as_seconds_f64
(
)
*
rhs
)
}
}
impl
Mul
<
Duration
>
for
f64
{
type
Output
=
Duration
;
fn
mul
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
*
self
}
}
impl_mul_assign
!
(
Duration
:
i8
i16
i32
u8
u16
u32
f32
f64
)
;
impl
Div
<
f32
>
for
Duration
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
f32
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f32
(
self
.
as_seconds_f32
(
)
/
rhs
)
}
}
impl
Div
<
f64
>
for
Duration
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
f64
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f64
(
self
.
as_seconds_f64
(
)
/
rhs
)
}
}
impl_div_assign
!
(
Duration
:
i8
i16
i32
u8
u16
u32
f32
f64
)
;
impl
Div
for
Duration
{
type
Output
=
f64
;
fn
div
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
as_seconds_f64
(
)
/
rhs
.
as_seconds_f64
(
)
}
}
impl
Div
<
StdDuration
>
for
Duration
{
type
Output
=
f64
;
fn
div
(
self
rhs
:
StdDuration
)
-
>
Self
:
:
Output
{
self
.
as_seconds_f64
(
)
/
rhs
.
as_secs_f64
(
)
}
}
impl
Div
<
Duration
>
for
StdDuration
{
type
Output
=
f64
;
fn
div
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
self
.
as_secs_f64
(
)
/
rhs
.
as_seconds_f64
(
)
}
}
impl
PartialEq
<
StdDuration
>
for
Duration
{
fn
eq
(
&
self
rhs
:
&
StdDuration
)
-
>
bool
{
Ok
(
*
self
)
=
=
Self
:
:
try_from
(
*
rhs
)
}
}
impl
PartialEq
<
Duration
>
for
StdDuration
{
fn
eq
(
&
self
rhs
:
&
Duration
)
-
>
bool
{
rhs
=
=
self
}
}
impl
PartialOrd
<
StdDuration
>
for
Duration
{
fn
partial_cmp
(
&
self
rhs
:
&
StdDuration
)
-
>
Option
<
Ordering
>
{
if
rhs
.
as_secs
(
)
>
i64
:
:
MAX
as
_
{
return
Some
(
Ordering
:
:
Less
)
;
}
Some
(
self
.
seconds
.
cmp
(
&
(
rhs
.
as_secs
(
)
as
_
)
)
.
then_with
(
|
|
self
.
nanoseconds
.
cmp
(
&
(
rhs
.
subsec_nanos
(
)
as
_
)
)
)
)
}
}
impl
PartialOrd
<
Duration
>
for
StdDuration
{
fn
partial_cmp
(
&
self
rhs
:
&
Duration
)
-
>
Option
<
Ordering
>
{
rhs
.
partial_cmp
(
self
)
.
map
(
Ordering
:
:
reverse
)
}
}
impl
Sum
for
Duration
{
fn
sum
<
I
:
Iterator
<
Item
=
Self
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
reduce
(
|
a
b
|
a
+
b
)
.
unwrap_or_default
(
)
}
}
impl
<
'
a
>
Sum
<
&
'
a
Self
>
for
Duration
{
fn
sum
<
I
:
Iterator
<
Item
=
&
'
a
Self
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
copied
(
)
.
sum
(
)
}
}
