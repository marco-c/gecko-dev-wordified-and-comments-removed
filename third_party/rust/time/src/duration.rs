use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
fmt
;
use
core
:
:
iter
:
:
Sum
;
use
core
:
:
ops
:
:
{
Add
AddAssign
Div
Mul
Neg
Sub
SubAssign
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
use
deranged
:
:
RangedI32
;
use
num_conv
:
:
prelude
:
:
*
;
use
crate
:
:
convert
:
:
*
;
use
crate
:
:
error
;
use
crate
:
:
internal_macros
:
:
{
const_try_opt
expect_opt
impl_add_assign
impl_div_assign
impl_mul_assign
impl_sub_assign
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
allow
(
deprecated
)
]
use
crate
:
:
Instant
;
#
[
repr
(
u32
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
(
crate
)
enum
Padding
{
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
Optimize
}
type
Nanoseconds
=
RangedI32
<
{
-
(
Nanosecond
:
:
per
(
Second
)
as
i32
-
1
)
}
{
Nanosecond
:
:
per
(
Second
)
as
i32
-
1
}
>
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Duration
{
seconds
:
i64
nanoseconds
:
Nanoseconds
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
padding
:
Padding
}
impl
fmt
:
:
Debug
for
Duration
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Duration
"
)
.
field
(
"
seconds
"
&
self
.
seconds
)
.
field
(
"
nanoseconds
"
&
self
.
nanoseconds
)
.
finish
(
)
}
}
impl
Default
for
Duration
{
fn
default
(
)
-
>
Self
{
Self
{
seconds
:
0
nanoseconds
:
Nanoseconds
:
:
new_static
:
:
<
0
>
(
)
padding
:
Padding
:
:
Optimize
}
}
}
#
[
rustfmt
:
:
skip
]
macro_rules
!
try_from_secs
{
(
secs
=
secs
:
expr
mantissa_bits
=
mant_bits
:
literal
exponent_bits
=
exp_bits
:
literal
offset
=
offset
:
literal
bits_ty
=
bits_ty
:
ty
bits_ty_signed
=
bits_ty_signed
:
ty
double_ty
=
double_ty
:
ty
float_ty
=
float_ty
:
ty
is_nan
=
is_nan
:
expr
is_overflow
=
is_overflow
:
expr
)
=
>
{
{
'
value
:
{
const
MIN_EXP
:
i16
=
1
-
(
1i16
<
<
exp_bits
)
/
2
;
const
MANT_MASK
:
bits_ty
=
(
1
<
<
mant_bits
)
-
1
;
const
EXP_MASK
:
bits_ty
=
(
1
<
<
exp_bits
)
-
1
;
/
/
Change
from
std
:
No
error
check
for
negative
values
necessary
.
let
bits
=
secs
.
to_bits
(
)
;
let
mant
=
(
bits
&
MANT_MASK
)
|
(
MANT_MASK
+
1
)
;
let
exp
=
(
(
bits
>
>
mant_bits
)
&
EXP_MASK
)
as
i16
+
MIN_EXP
;
let
(
secs
nanos
)
=
if
exp
<
-
31
{
/
/
the
input
represents
less
than
1ns
and
can
not
be
rounded
to
it
(
0u64
0u32
)
}
else
if
exp
<
0
{
/
/
the
input
is
less
than
1
second
let
t
=
<
double_ty
>
:
:
from
(
mant
)
<
<
(
offset
+
exp
)
;
let
nanos_offset
=
mant_bits
+
offset
;
let
nanos_tmp
=
u128
:
:
from
(
Nanosecond
:
:
per
(
Second
)
)
*
u128
:
:
from
(
t
)
;
let
nanos
=
(
nanos_tmp
>
>
nanos_offset
)
as
u32
;
let
rem_mask
=
(
1
<
<
nanos_offset
)
-
1
;
let
rem_msb_mask
=
1
<
<
(
nanos_offset
-
1
)
;
let
rem
=
nanos_tmp
&
rem_mask
;
let
is_tie
=
rem
=
=
rem_msb_mask
;
let
is_even
=
(
nanos
&
1
)
=
=
0
;
let
rem_msb
=
nanos_tmp
&
rem_msb_mask
=
=
0
;
let
add_ns
=
!
(
rem_msb
|
|
(
is_even
&
&
is_tie
)
)
;
/
/
f32
does
not
have
enough
precision
to
trigger
the
second
branch
/
/
since
it
can
not
represent
numbers
between
0
.
999_999_940_395
and
1
.
0
.
let
nanos
=
nanos
+
add_ns
as
u32
;
if
(
mant_bits
=
=
23
)
|
|
(
nanos
!
=
Nanosecond
:
:
per
(
Second
)
)
{
(
0
nanos
)
}
else
{
(
1
0
)
}
}
else
if
exp
<
mant_bits
{
let
secs
=
u64
:
:
from
(
mant
>
>
(
mant_bits
-
exp
)
)
;
let
t
=
<
double_ty
>
:
:
from
(
(
mant
<
<
exp
)
&
MANT_MASK
)
;
let
nanos_offset
=
mant_bits
;
let
nanos_tmp
=
<
double_ty
>
:
:
from
(
Nanosecond
:
:
per
(
Second
)
)
*
t
;
let
nanos
=
(
nanos_tmp
>
>
nanos_offset
)
as
u32
;
let
rem_mask
=
(
1
<
<
nanos_offset
)
-
1
;
let
rem_msb_mask
=
1
<
<
(
nanos_offset
-
1
)
;
let
rem
=
nanos_tmp
&
rem_mask
;
let
is_tie
=
rem
=
=
rem_msb_mask
;
let
is_even
=
(
nanos
&
1
)
=
=
0
;
let
rem_msb
=
nanos_tmp
&
rem_msb_mask
=
=
0
;
let
add_ns
=
!
(
rem_msb
|
|
(
is_even
&
&
is_tie
)
)
;
/
/
f32
does
not
have
enough
precision
to
trigger
the
second
branch
.
/
/
For
example
it
can
not
represent
numbers
between
1
.
999_999_880
.
.
.
/
/
and
2
.
0
.
Bigger
values
result
in
even
smaller
precision
of
the
/
/
fractional
part
.
let
nanos
=
nanos
+
add_ns
as
u32
;
if
(
mant_bits
=
=
23
)
|
|
(
nanos
!
=
Nanosecond
:
:
per
(
Second
)
)
{
(
secs
nanos
)
}
else
{
(
secs
+
1
0
)
}
}
else
if
exp
<
63
{
/
/
Change
from
std
:
The
exponent
here
is
63
instead
of
64
/
/
because
i64
:
:
MAX
+
1
is
2
^
63
.
/
/
the
input
has
no
fractional
part
let
secs
=
u64
:
:
from
(
mant
)
<
<
(
exp
-
mant_bits
)
;
(
secs
0
)
}
else
if
bits
=
=
(
i64
:
:
MIN
as
float_ty
)
.
to_bits
(
)
{
/
/
Change
from
std
:
Signed
integers
are
asymmetrical
in
that
/
/
iN
:
:
MIN
is
-
iN
:
:
MAX
-
1
.
So
for
example
i8
covers
the
/
/
following
numbers
-
128
.
.
=
127
.
The
check
above
(
exp
<
63
)
/
/
doesn
'
t
cover
i64
:
:
MIN
as
that
is
-
2
^
63
so
we
have
this
/
/
additional
case
to
handle
the
asymmetry
of
iN
:
:
MIN
.
break
'
value
Self
:
:
new_ranged_unchecked
(
i64
:
:
MIN
Nanoseconds
:
:
new_static
:
:
<
0
>
(
)
)
;
}
else
if
secs
.
is_nan
(
)
{
/
/
Change
from
std
:
std
doesn
'
t
differentiate
between
the
error
/
/
cases
.
is_nan
}
else
{
is_overflow
}
;
/
/
Change
from
std
:
All
the
code
is
mostly
unmodified
in
that
it
/
/
simply
calculates
an
unsigned
integer
.
Here
we
extract
the
sign
/
/
bit
and
assign
it
to
the
number
.
We
basically
manually
do
two
'
s
/
/
complement
here
we
could
also
use
an
if
and
just
negate
the
/
/
numbers
based
on
the
sign
but
it
turns
out
to
be
quite
a
bit
/
/
slower
.
let
mask
=
(
bits
as
bits_ty_signed
)
>
>
(
mant_bits
+
exp_bits
)
;
#
[
allow
(
trivial_numeric_casts
)
]
let
secs_signed
=
(
(
secs
as
i64
)
^
(
mask
as
i64
)
)
-
(
mask
as
i64
)
;
#
[
allow
(
trivial_numeric_casts
)
]
let
nanos_signed
=
(
(
nanos
as
i32
)
^
(
mask
as
i32
)
)
-
(
mask
as
i32
)
;
/
/
Safety
:
nanos_signed
is
in
range
.
unsafe
{
Self
:
:
new_unchecked
(
secs_signed
nanos_signed
)
}
}
}
}
;
}
impl
Duration
{
pub
const
ZERO
:
Self
=
Self
:
:
seconds
(
0
)
;
pub
const
NANOSECOND
:
Self
=
Self
:
:
nanoseconds
(
1
)
;
pub
const
MICROSECOND
:
Self
=
Self
:
:
microseconds
(
1
)
;
pub
const
MILLISECOND
:
Self
=
Self
:
:
milliseconds
(
1
)
;
pub
const
SECOND
:
Self
=
Self
:
:
seconds
(
1
)
;
pub
const
MINUTE
:
Self
=
Self
:
:
minutes
(
1
)
;
pub
const
HOUR
:
Self
=
Self
:
:
hours
(
1
)
;
pub
const
DAY
:
Self
=
Self
:
:
days
(
1
)
;
pub
const
WEEK
:
Self
=
Self
:
:
weeks
(
1
)
;
pub
const
MIN
:
Self
=
Self
:
:
new_ranged
(
i64
:
:
MIN
Nanoseconds
:
:
MIN
)
;
pub
const
MAX
:
Self
=
Self
:
:
new_ranged
(
i64
:
:
MAX
Nanoseconds
:
:
MAX
)
;
pub
const
fn
is_zero
(
self
)
-
>
bool
{
self
.
seconds
=
=
0
&
&
self
.
nanoseconds
.
get
(
)
=
=
0
}
pub
const
fn
is_negative
(
self
)
-
>
bool
{
self
.
seconds
<
0
|
|
self
.
nanoseconds
.
get
(
)
<
0
}
pub
const
fn
is_positive
(
self
)
-
>
bool
{
self
.
seconds
>
0
|
|
self
.
nanoseconds
.
get
(
)
>
0
}
pub
const
fn
abs
(
self
)
-
>
Self
{
match
self
.
seconds
.
checked_abs
(
)
{
Some
(
seconds
)
=
>
Self
:
:
new_ranged_unchecked
(
seconds
self
.
nanoseconds
.
abs
(
)
)
None
=
>
Self
:
:
MAX
}
}
pub
const
fn
unsigned_abs
(
self
)
-
>
StdDuration
{
StdDuration
:
:
new
(
self
.
seconds
.
unsigned_abs
(
)
self
.
nanoseconds
.
get
(
)
.
unsigned_abs
(
)
)
}
pub
(
crate
)
const
unsafe
fn
new_unchecked
(
seconds
:
i64
nanoseconds
:
i32
)
-
>
Self
{
Self
:
:
new_ranged_unchecked
(
seconds
unsafe
{
Nanoseconds
:
:
new_unchecked
(
nanoseconds
)
}
)
}
pub
(
crate
)
const
fn
new_ranged_unchecked
(
seconds
:
i64
nanoseconds
:
Nanoseconds
)
-
>
Self
{
if
seconds
<
0
{
debug_assert
!
(
nanoseconds
.
get
(
)
<
=
0
)
;
}
else
if
seconds
>
0
{
debug_assert
!
(
nanoseconds
.
get
(
)
>
=
0
)
;
}
Self
{
seconds
nanoseconds
padding
:
Padding
:
:
Optimize
}
}
pub
const
fn
new
(
mut
seconds
:
i64
mut
nanoseconds
:
i32
)
-
>
Self
{
seconds
=
expect_opt
!
(
seconds
.
checked_add
(
nanoseconds
as
i64
/
Nanosecond
:
:
per
(
Second
)
as
i64
)
"
overflow
constructing
time
:
:
Duration
"
)
;
nanoseconds
%
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
if
seconds
>
0
&
&
nanoseconds
<
0
{
seconds
-
=
1
;
nanoseconds
+
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
}
else
if
seconds
<
0
&
&
nanoseconds
>
0
{
seconds
+
=
1
;
nanoseconds
-
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
}
unsafe
{
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
}
pub
(
crate
)
const
fn
new_ranged
(
mut
seconds
:
i64
mut
nanoseconds
:
Nanoseconds
)
-
>
Self
{
if
seconds
>
0
&
&
nanoseconds
.
get
(
)
<
0
{
seconds
-
=
1
;
nanoseconds
=
unsafe
{
Nanoseconds
:
:
new_unchecked
(
nanoseconds
.
get
(
)
+
Nanosecond
:
:
per
(
Second
)
as
i32
)
}
;
}
else
if
seconds
<
0
&
&
nanoseconds
.
get
(
)
>
0
{
seconds
+
=
1
;
nanoseconds
=
unsafe
{
Nanoseconds
:
:
new_unchecked
(
nanoseconds
.
get
(
)
-
Nanosecond
:
:
per
(
Second
)
as
i32
)
}
;
}
Self
:
:
new_ranged_unchecked
(
seconds
nanoseconds
)
}
pub
const
fn
weeks
(
weeks
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
weeks
.
checked_mul
(
Second
:
:
per
(
Week
)
as
_
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
days
(
days
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
days
.
checked_mul
(
Second
:
:
per
(
Day
)
as
_
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
hours
(
hours
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
hours
.
checked_mul
(
Second
:
:
per
(
Hour
)
as
_
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
minutes
(
minutes
:
i64
)
-
>
Self
{
Self
:
:
seconds
(
expect_opt
!
(
minutes
.
checked_mul
(
Second
:
:
per
(
Minute
)
as
_
)
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
const
fn
seconds
(
seconds
:
i64
)
-
>
Self
{
Self
:
:
new_ranged_unchecked
(
seconds
Nanoseconds
:
:
new_static
:
:
<
0
>
(
)
)
}
pub
fn
seconds_f64
(
seconds
:
f64
)
-
>
Self
{
try_from_secs
!
(
secs
=
seconds
mantissa_bits
=
52
exponent_bits
=
11
offset
=
44
bits_ty
=
u64
bits_ty_signed
=
i64
double_ty
=
u128
float_ty
=
f64
is_nan
=
crate
:
:
expect_failed
(
"
passed
NaN
to
time
:
:
Duration
:
:
seconds_f64
"
)
is_overflow
=
crate
:
:
expect_failed
(
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
fn
seconds_f32
(
seconds
:
f32
)
-
>
Self
{
try_from_secs
!
(
secs
=
seconds
mantissa_bits
=
23
exponent_bits
=
8
offset
=
41
bits_ty
=
u32
bits_ty_signed
=
i32
double_ty
=
u64
float_ty
=
f32
is_nan
=
crate
:
:
expect_failed
(
"
passed
NaN
to
time
:
:
Duration
:
:
seconds_f32
"
)
is_overflow
=
crate
:
:
expect_failed
(
"
overflow
constructing
time
:
:
Duration
"
)
)
}
pub
fn
saturating_seconds_f64
(
seconds
:
f64
)
-
>
Self
{
try_from_secs
!
(
secs
=
seconds
mantissa_bits
=
52
exponent_bits
=
11
offset
=
44
bits_ty
=
u64
bits_ty_signed
=
i64
double_ty
=
u128
float_ty
=
f64
is_nan
=
return
Self
:
:
ZERO
is_overflow
=
return
if
seconds
<
0
.
0
{
Self
:
:
MIN
}
else
{
Self
:
:
MAX
}
)
}
pub
fn
saturating_seconds_f32
(
seconds
:
f32
)
-
>
Self
{
try_from_secs
!
(
secs
=
seconds
mantissa_bits
=
23
exponent_bits
=
8
offset
=
41
bits_ty
=
u32
bits_ty_signed
=
i32
double_ty
=
u64
float_ty
=
f32
is_nan
=
return
Self
:
:
ZERO
is_overflow
=
return
if
seconds
<
0
.
0
{
Self
:
:
MIN
}
else
{
Self
:
:
MAX
}
)
}
pub
fn
checked_seconds_f64
(
seconds
:
f64
)
-
>
Option
<
Self
>
{
Some
(
try_from_secs
!
(
secs
=
seconds
mantissa_bits
=
52
exponent_bits
=
11
offset
=
44
bits_ty
=
u64
bits_ty_signed
=
i64
double_ty
=
u128
float_ty
=
f64
is_nan
=
return
None
is_overflow
=
return
None
)
)
}
pub
fn
checked_seconds_f32
(
seconds
:
f32
)
-
>
Option
<
Self
>
{
Some
(
try_from_secs
!
(
secs
=
seconds
mantissa_bits
=
23
exponent_bits
=
8
offset
=
41
bits_ty
=
u32
bits_ty_signed
=
i32
double_ty
=
u64
float_ty
=
f32
is_nan
=
return
None
is_overflow
=
return
None
)
)
}
pub
const
fn
milliseconds
(
milliseconds
:
i64
)
-
>
Self
{
unsafe
{
Self
:
:
new_unchecked
(
milliseconds
/
Millisecond
:
:
per
(
Second
)
as
i64
(
milliseconds
%
Millisecond
:
:
per
(
Second
)
as
i64
*
Nanosecond
:
:
per
(
Millisecond
)
as
i64
)
as
_
)
}
}
pub
const
fn
microseconds
(
microseconds
:
i64
)
-
>
Self
{
unsafe
{
Self
:
:
new_unchecked
(
microseconds
/
Microsecond
:
:
per
(
Second
)
as
i64
(
microseconds
%
Microsecond
:
:
per
(
Second
)
as
i64
*
Nanosecond
:
:
per
(
Microsecond
)
as
i64
)
as
_
)
}
}
pub
const
fn
nanoseconds
(
nanoseconds
:
i64
)
-
>
Self
{
unsafe
{
Self
:
:
new_unchecked
(
nanoseconds
/
Nanosecond
:
:
per
(
Second
)
as
i64
(
nanoseconds
%
Nanosecond
:
:
per
(
Second
)
as
i64
)
as
_
)
}
}
pub
(
crate
)
const
fn
nanoseconds_i128
(
nanoseconds
:
i128
)
-
>
Self
{
let
seconds
=
nanoseconds
/
Nanosecond
:
:
per
(
Second
)
as
i128
;
let
nanoseconds
=
nanoseconds
%
Nanosecond
:
:
per
(
Second
)
as
i128
;
if
seconds
>
i64
:
:
MAX
as
i128
|
|
seconds
<
i64
:
:
MIN
as
i128
{
crate
:
:
expect_failed
(
"
overflow
constructing
time
:
:
Duration
"
)
;
}
unsafe
{
Self
:
:
new_unchecked
(
seconds
as
_
nanoseconds
as
_
)
}
}
pub
const
fn
whole_weeks
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
Second
:
:
per
(
Week
)
as
i64
}
pub
const
fn
whole_days
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
Second
:
:
per
(
Day
)
as
i64
}
pub
const
fn
whole_hours
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
Second
:
:
per
(
Hour
)
as
i64
}
pub
const
fn
whole_minutes
(
self
)
-
>
i64
{
self
.
whole_seconds
(
)
/
Second
:
:
per
(
Minute
)
as
i64
}
pub
const
fn
whole_seconds
(
self
)
-
>
i64
{
self
.
seconds
}
pub
fn
as_seconds_f64
(
self
)
-
>
f64
{
self
.
seconds
as
f64
+
self
.
nanoseconds
.
get
(
)
as
f64
/
Nanosecond
:
:
per
(
Second
)
as
f64
}
pub
fn
as_seconds_f32
(
self
)
-
>
f32
{
self
.
seconds
as
f32
+
self
.
nanoseconds
.
get
(
)
as
f32
/
Nanosecond
:
:
per
(
Second
)
as
f32
}
pub
const
fn
whole_milliseconds
(
self
)
-
>
i128
{
self
.
seconds
as
i128
*
Millisecond
:
:
per
(
Second
)
as
i128
+
self
.
nanoseconds
.
get
(
)
as
i128
/
Nanosecond
:
:
per
(
Millisecond
)
as
i128
}
pub
const
fn
subsec_milliseconds
(
self
)
-
>
i16
{
(
self
.
nanoseconds
.
get
(
)
/
Nanosecond
:
:
per
(
Millisecond
)
as
i32
)
as
_
}
pub
const
fn
whole_microseconds
(
self
)
-
>
i128
{
self
.
seconds
as
i128
*
Microsecond
:
:
per
(
Second
)
as
i128
+
self
.
nanoseconds
.
get
(
)
as
i128
/
Nanosecond
:
:
per
(
Microsecond
)
as
i128
}
pub
const
fn
subsec_microseconds
(
self
)
-
>
i32
{
self
.
nanoseconds
.
get
(
)
/
Nanosecond
:
:
per
(
Microsecond
)
as
i32
}
pub
const
fn
whole_nanoseconds
(
self
)
-
>
i128
{
self
.
seconds
as
i128
*
Nanosecond
:
:
per
(
Second
)
as
i128
+
self
.
nanoseconds
.
get
(
)
as
i128
}
pub
const
fn
subsec_nanoseconds
(
self
)
-
>
i32
{
self
.
nanoseconds
.
get
(
)
}
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
pub
(
crate
)
const
fn
subsec_nanoseconds_ranged
(
self
)
-
>
Nanoseconds
{
self
.
nanoseconds
}
pub
const
fn
checked_add
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
{
let
mut
seconds
=
const_try_opt
!
(
self
.
seconds
.
checked_add
(
rhs
.
seconds
)
)
;
let
mut
nanoseconds
=
self
.
nanoseconds
.
get
(
)
+
rhs
.
nanoseconds
.
get
(
)
;
if
nanoseconds
>
=
Nanosecond
:
:
per
(
Second
)
as
_
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
const_try_opt
!
(
seconds
.
checked_add
(
1
)
)
;
}
else
if
nanoseconds
<
=
-
(
Nanosecond
:
:
per
(
Second
)
as
i32
)
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
const_try_opt
!
(
seconds
.
checked_sub
(
1
)
)
;
}
unsafe
{
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
}
pub
const
fn
checked_sub
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
{
let
mut
seconds
=
const_try_opt
!
(
self
.
seconds
.
checked_sub
(
rhs
.
seconds
)
)
;
let
mut
nanoseconds
=
self
.
nanoseconds
.
get
(
)
-
rhs
.
nanoseconds
.
get
(
)
;
if
nanoseconds
>
=
Nanosecond
:
:
per
(
Second
)
as
_
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
const_try_opt
!
(
seconds
.
checked_add
(
1
)
)
;
}
else
if
nanoseconds
<
=
-
(
Nanosecond
:
:
per
(
Second
)
as
i32
)
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
const_try_opt
!
(
seconds
.
checked_sub
(
1
)
)
;
}
unsafe
{
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
}
pub
const
fn
checked_mul
(
self
rhs
:
i32
)
-
>
Option
<
Self
>
{
let
total_nanos
=
self
.
nanoseconds
.
get
(
)
as
i64
*
rhs
as
i64
;
let
extra_secs
=
total_nanos
/
Nanosecond
:
:
per
(
Second
)
as
i64
;
let
nanoseconds
=
(
total_nanos
%
Nanosecond
:
:
per
(
Second
)
as
i64
)
as
_
;
let
seconds
=
const_try_opt
!
(
const_try_opt
!
(
self
.
seconds
.
checked_mul
(
rhs
as
_
)
)
.
checked_add
(
extra_secs
)
)
;
unsafe
{
Some
(
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
)
}
}
pub
const
fn
checked_div
(
self
rhs
:
i32
)
-
>
Option
<
Self
>
{
let
(
secs
extra_secs
)
=
(
const_try_opt
!
(
self
.
seconds
.
checked_div
(
rhs
as
i64
)
)
self
.
seconds
%
(
rhs
as
i64
)
)
;
let
(
mut
nanos
extra_nanos
)
=
(
self
.
nanoseconds
.
get
(
)
/
rhs
self
.
nanoseconds
.
get
(
)
%
rhs
)
;
nanos
+
=
(
(
extra_secs
*
(
Nanosecond
:
:
per
(
Second
)
as
i64
)
+
extra_nanos
as
i64
)
/
(
rhs
as
i64
)
)
as
i32
;
unsafe
{
Some
(
Self
:
:
new_unchecked
(
secs
nanos
)
)
}
}
pub
const
fn
checked_neg
(
self
)
-
>
Option
<
Self
>
{
if
self
.
seconds
=
=
i64
:
:
MIN
{
None
}
else
{
Some
(
Self
:
:
new_ranged_unchecked
(
-
self
.
seconds
self
.
nanoseconds
.
neg
(
)
)
)
}
}
pub
const
fn
saturating_add
(
self
rhs
:
Self
)
-
>
Self
{
let
(
mut
seconds
overflow
)
=
self
.
seconds
.
overflowing_add
(
rhs
.
seconds
)
;
if
overflow
{
if
self
.
seconds
>
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
let
mut
nanoseconds
=
self
.
nanoseconds
.
get
(
)
+
rhs
.
nanoseconds
.
get
(
)
;
if
nanoseconds
>
=
Nanosecond
:
:
per
(
Second
)
as
_
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
match
seconds
.
checked_add
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MAX
}
;
}
else
if
nanoseconds
<
=
-
(
Nanosecond
:
:
per
(
Second
)
as
i32
)
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
match
seconds
.
checked_sub
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MIN
}
;
}
unsafe
{
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
}
pub
const
fn
saturating_sub
(
self
rhs
:
Self
)
-
>
Self
{
let
(
mut
seconds
overflow
)
=
self
.
seconds
.
overflowing_sub
(
rhs
.
seconds
)
;
if
overflow
{
if
self
.
seconds
>
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
let
mut
nanoseconds
=
self
.
nanoseconds
.
get
(
)
-
rhs
.
nanoseconds
.
get
(
)
;
if
nanoseconds
>
=
Nanosecond
:
:
per
(
Second
)
as
_
|
|
seconds
<
0
&
&
nanoseconds
>
0
{
nanoseconds
-
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
match
seconds
.
checked_add
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MAX
}
;
}
else
if
nanoseconds
<
=
-
(
Nanosecond
:
:
per
(
Second
)
as
i32
)
|
|
seconds
>
0
&
&
nanoseconds
<
0
{
nanoseconds
+
=
Nanosecond
:
:
per
(
Second
)
as
i32
;
seconds
=
match
seconds
.
checked_sub
(
1
)
{
Some
(
seconds
)
=
>
seconds
None
=
>
return
Self
:
:
MIN
}
;
}
unsafe
{
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
}
pub
const
fn
saturating_mul
(
self
rhs
:
i32
)
-
>
Self
{
let
total_nanos
=
self
.
nanoseconds
.
get
(
)
as
i64
*
rhs
as
i64
;
let
extra_secs
=
total_nanos
/
Nanosecond
:
:
per
(
Second
)
as
i64
;
let
nanoseconds
=
(
total_nanos
%
Nanosecond
:
:
per
(
Second
)
as
i64
)
as
_
;
let
(
seconds
overflow1
)
=
self
.
seconds
.
overflowing_mul
(
rhs
as
_
)
;
if
overflow1
{
if
self
.
seconds
>
0
&
&
rhs
>
0
|
|
self
.
seconds
<
0
&
&
rhs
<
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
let
(
seconds
overflow2
)
=
seconds
.
overflowing_add
(
extra_secs
)
;
if
overflow2
{
if
self
.
seconds
>
0
&
&
rhs
>
0
{
return
Self
:
:
MAX
;
}
return
Self
:
:
MIN
;
}
unsafe
{
Self
:
:
new_unchecked
(
seconds
nanoseconds
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
deprecated
(
since
=
"
0
.
3
.
32
"
note
=
"
extremely
limited
use
case
not
intended
for
benchmarking
"
)
]
#
[
allow
(
deprecated
)
]
pub
fn
time_fn
<
T
>
(
f
:
impl
FnOnce
(
)
-
>
T
)
-
>
(
Self
T
)
{
let
start
=
Instant
:
:
now
(
)
;
let
return_value
=
f
(
)
;
let
end
=
Instant
:
:
now
(
)
;
(
end
-
start
return_value
)
}
}
impl
fmt
:
:
Display
for
Duration
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
is_negative
(
)
{
f
.
write_str
(
"
-
"
)
?
;
}
if
let
Some
(
_precision
)
=
f
.
precision
(
)
{
if
self
.
is_zero
(
)
{
return
(
0
.
)
.
fmt
(
f
)
.
and_then
(
|
_
|
f
.
write_str
(
"
s
"
)
)
;
}
macro_rules
!
item
{
(
name
:
literal
value
:
expr
)
=
>
{
let
value
=
value
;
if
value
>
=
1
.
0
{
return
value
.
fmt
(
f
)
.
and_then
(
|
_
|
f
.
write_str
(
name
)
)
;
}
}
;
}
let
seconds
=
self
.
unsigned_abs
(
)
.
as_secs_f64
(
)
;
item
!
(
"
d
"
seconds
/
Second
:
:
per
(
Day
)
as
f64
)
;
item
!
(
"
h
"
seconds
/
Second
:
:
per
(
Hour
)
as
f64
)
;
item
!
(
"
m
"
seconds
/
Second
:
:
per
(
Minute
)
as
f64
)
;
item
!
(
"
s
"
seconds
)
;
item
!
(
"
ms
"
seconds
*
Millisecond
:
:
per
(
Second
)
as
f64
)
;
item
!
(
"
s
"
seconds
*
Microsecond
:
:
per
(
Second
)
as
f64
)
;
item
!
(
"
ns
"
seconds
*
Nanosecond
:
:
per
(
Second
)
as
f64
)
;
}
else
{
if
self
.
is_zero
(
)
{
return
f
.
write_str
(
"
0s
"
)
;
}
macro_rules
!
item
{
(
name
:
literal
value
:
expr
)
=
>
{
match
value
{
0
=
>
Ok
(
(
)
)
value
=
>
value
.
fmt
(
f
)
.
and_then
(
|
_
|
f
.
write_str
(
name
)
)
}
}
;
}
let
seconds
=
self
.
seconds
.
unsigned_abs
(
)
;
let
nanoseconds
=
self
.
nanoseconds
.
get
(
)
.
unsigned_abs
(
)
;
item
!
(
"
d
"
seconds
/
Second
:
:
per
(
Day
)
.
extend
:
:
<
u64
>
(
)
)
?
;
item
!
(
"
h
"
seconds
/
Second
:
:
per
(
Hour
)
.
extend
:
:
<
u64
>
(
)
%
Hour
:
:
per
(
Day
)
.
extend
:
:
<
u64
>
(
)
)
?
;
item
!
(
"
m
"
seconds
/
Second
:
:
per
(
Minute
)
.
extend
:
:
<
u64
>
(
)
%
Minute
:
:
per
(
Hour
)
.
extend
:
:
<
u64
>
(
)
)
?
;
item
!
(
"
s
"
seconds
%
Second
:
:
per
(
Minute
)
.
extend
:
:
<
u64
>
(
)
)
?
;
item
!
(
"
ms
"
nanoseconds
/
Nanosecond
:
:
per
(
Millisecond
)
)
?
;
item
!
(
"
s
"
nanoseconds
/
Nanosecond
:
:
per
(
Microsecond
)
.
extend
:
:
<
u32
>
(
)
%
Microsecond
:
:
per
(
Millisecond
)
.
extend
:
:
<
u32
>
(
)
)
?
;
item
!
(
"
ns
"
nanoseconds
%
Nanosecond
:
:
per
(
Microsecond
)
.
extend
:
:
<
u32
>
(
)
)
?
;
}
Ok
(
(
)
)
}
}
impl
TryFrom
<
StdDuration
>
for
Duration
{
type
Error
=
error
:
:
ConversionRange
;
fn
try_from
(
original
:
StdDuration
)
-
>
Result
<
Self
error
:
:
ConversionRange
>
{
Ok
(
Self
:
:
new
(
original
.
as_secs
(
)
.
try_into
(
)
.
map_err
(
|
_
|
error
:
:
ConversionRange
)
?
original
.
subsec_nanos
(
)
.
cast_signed
(
)
)
)
}
}
impl
TryFrom
<
Duration
>
for
StdDuration
{
type
Error
=
error
:
:
ConversionRange
;
fn
try_from
(
duration
:
Duration
)
-
>
Result
<
Self
error
:
:
ConversionRange
>
{
Ok
(
Self
:
:
new
(
duration
.
seconds
.
try_into
(
)
.
map_err
(
|
_
|
error
:
:
ConversionRange
)
?
duration
.
nanoseconds
.
get
(
)
.
try_into
(
)
.
map_err
(
|
_
|
error
:
:
ConversionRange
)
?
)
)
}
}
impl
Add
for
Duration
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
checked_add
(
rhs
)
.
expect
(
"
overflow
when
adding
durations
"
)
}
}
impl
Add
<
StdDuration
>
for
Duration
{
type
Output
=
Self
;
fn
add
(
self
std_duration
:
StdDuration
)
-
>
Self
:
:
Output
{
self
+
Self
:
:
try_from
(
std_duration
)
.
expect
(
"
overflow
converting
std
:
:
time
:
:
Duration
to
time
:
:
Duration
"
)
}
}
impl
Add
<
Duration
>
for
StdDuration
{
type
Output
=
Duration
;
fn
add
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
+
self
}
}
impl_add_assign
!
(
Duration
:
Self
StdDuration
)
;
impl
AddAssign
<
Duration
>
for
StdDuration
{
fn
add_assign
(
&
mut
self
rhs
:
Duration
)
{
*
self
=
(
*
self
+
rhs
)
.
try_into
(
)
.
expect
(
"
Cannot
represent
a
resulting
duration
in
std
.
Try
let
x
=
x
+
rhs
;
which
will
\
change
the
type
.
"
)
;
}
}
impl
Neg
for
Duration
{
type
Output
=
Self
;
fn
neg
(
self
)
-
>
Self
:
:
Output
{
self
.
checked_neg
(
)
.
expect
(
"
overflow
when
negating
duration
"
)
}
}
impl
Sub
for
Duration
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
checked_sub
(
rhs
)
.
expect
(
"
overflow
when
subtracting
durations
"
)
}
}
impl
Sub
<
StdDuration
>
for
Duration
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
StdDuration
)
-
>
Self
:
:
Output
{
self
-
Self
:
:
try_from
(
rhs
)
.
expect
(
"
overflow
converting
std
:
:
time
:
:
Duration
to
time
:
:
Duration
"
)
}
}
impl
Sub
<
Duration
>
for
StdDuration
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
Duration
:
:
try_from
(
self
)
.
expect
(
"
overflow
converting
std
:
:
time
:
:
Duration
to
time
:
:
Duration
"
)
-
rhs
}
}
impl_sub_assign
!
(
Duration
:
Self
StdDuration
)
;
impl
SubAssign
<
Duration
>
for
StdDuration
{
fn
sub_assign
(
&
mut
self
rhs
:
Duration
)
{
*
self
=
(
*
self
-
rhs
)
.
try_into
(
)
.
expect
(
"
Cannot
represent
a
resulting
duration
in
std
.
Try
let
x
=
x
-
rhs
;
which
will
\
change
the
type
.
"
)
;
}
}
macro_rules
!
duration_mul_div_int
{
(
(
type
:
ty
)
+
)
=
>
{
(
impl
Mul
<
type
>
for
Duration
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
type
)
-
>
Self
:
:
Output
{
Self
:
:
nanoseconds_i128
(
self
.
whole_nanoseconds
(
)
.
checked_mul
(
rhs
.
cast_signed
(
)
.
extend
:
:
<
i128
>
(
)
)
.
expect
(
"
overflow
when
multiplying
duration
"
)
)
}
}
impl
Mul
<
Duration
>
for
type
{
type
Output
=
Duration
;
fn
mul
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
*
self
}
}
impl
Div
<
type
>
for
Duration
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
type
)
-
>
Self
:
:
Output
{
Self
:
:
nanoseconds_i128
(
self
.
whole_nanoseconds
(
)
/
rhs
.
cast_signed
(
)
.
extend
:
:
<
i128
>
(
)
)
}
}
)
+
}
;
}
duration_mul_div_int
!
[
i8
i16
i32
u8
u16
u32
]
;
impl
Mul
<
f32
>
for
Duration
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
f32
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f32
(
self
.
as_seconds_f32
(
)
*
rhs
)
}
}
impl
Mul
<
Duration
>
for
f32
{
type
Output
=
Duration
;
fn
mul
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
*
self
}
}
impl
Mul
<
f64
>
for
Duration
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
f64
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f64
(
self
.
as_seconds_f64
(
)
*
rhs
)
}
}
impl
Mul
<
Duration
>
for
f64
{
type
Output
=
Duration
;
fn
mul
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
rhs
*
self
}
}
impl_mul_assign
!
(
Duration
:
i8
i16
i32
u8
u16
u32
f32
f64
)
;
impl
Div
<
f32
>
for
Duration
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
f32
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f32
(
self
.
as_seconds_f32
(
)
/
rhs
)
}
}
impl
Div
<
f64
>
for
Duration
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
f64
)
-
>
Self
:
:
Output
{
Self
:
:
seconds_f64
(
self
.
as_seconds_f64
(
)
/
rhs
)
}
}
impl_div_assign
!
(
Duration
:
i8
i16
i32
u8
u16
u32
f32
f64
)
;
impl
Div
for
Duration
{
type
Output
=
f64
;
fn
div
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
as_seconds_f64
(
)
/
rhs
.
as_seconds_f64
(
)
}
}
impl
Div
<
StdDuration
>
for
Duration
{
type
Output
=
f64
;
fn
div
(
self
rhs
:
StdDuration
)
-
>
Self
:
:
Output
{
self
.
as_seconds_f64
(
)
/
rhs
.
as_secs_f64
(
)
}
}
impl
Div
<
Duration
>
for
StdDuration
{
type
Output
=
f64
;
fn
div
(
self
rhs
:
Duration
)
-
>
Self
:
:
Output
{
self
.
as_secs_f64
(
)
/
rhs
.
as_seconds_f64
(
)
}
}
impl
PartialEq
<
StdDuration
>
for
Duration
{
fn
eq
(
&
self
rhs
:
&
StdDuration
)
-
>
bool
{
Ok
(
*
self
)
=
=
Self
:
:
try_from
(
*
rhs
)
}
}
impl
PartialEq
<
Duration
>
for
StdDuration
{
fn
eq
(
&
self
rhs
:
&
Duration
)
-
>
bool
{
rhs
=
=
self
}
}
impl
PartialOrd
<
StdDuration
>
for
Duration
{
fn
partial_cmp
(
&
self
rhs
:
&
StdDuration
)
-
>
Option
<
Ordering
>
{
if
rhs
.
as_secs
(
)
>
i64
:
:
MAX
.
cast_unsigned
(
)
{
return
Some
(
Ordering
:
:
Less
)
;
}
Some
(
self
.
seconds
.
cmp
(
&
rhs
.
as_secs
(
)
.
cast_signed
(
)
)
.
then_with
(
|
|
{
self
.
nanoseconds
.
get
(
)
.
cmp
(
&
rhs
.
subsec_nanos
(
)
.
cast_signed
(
)
)
}
)
)
}
}
impl
PartialOrd
<
Duration
>
for
StdDuration
{
fn
partial_cmp
(
&
self
rhs
:
&
Duration
)
-
>
Option
<
Ordering
>
{
rhs
.
partial_cmp
(
self
)
.
map
(
Ordering
:
:
reverse
)
}
}
impl
Sum
for
Duration
{
fn
sum
<
I
:
Iterator
<
Item
=
Self
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
reduce
(
|
a
b
|
a
+
b
)
.
unwrap_or_default
(
)
}
}
impl
<
'
a
>
Sum
<
&
'
a
Self
>
for
Duration
{
fn
sum
<
I
:
Iterator
<
Item
=
&
'
a
Self
>
>
(
iter
:
I
)
-
>
Self
{
iter
.
copied
(
)
.
sum
(
)
}
}
