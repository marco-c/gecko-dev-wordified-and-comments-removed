pub
(
crate
)
mod
formattable
;
use
std
:
:
io
;
pub
use
self
:
:
formattable
:
:
Formattable
;
use
crate
:
:
format_description
:
:
{
modifier
Component
}
;
use
crate
:
:
{
error
Date
Time
UtcOffset
}
;
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
const
MONTH_NAMES
:
[
&
[
u8
]
;
12
]
=
[
b
"
January
"
b
"
February
"
b
"
March
"
b
"
April
"
b
"
May
"
b
"
June
"
b
"
July
"
b
"
August
"
b
"
September
"
b
"
October
"
b
"
November
"
b
"
December
"
]
;
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
const
WEEKDAY_NAMES
:
[
&
[
u8
]
;
7
]
=
[
b
"
Monday
"
b
"
Tuesday
"
b
"
Wednesday
"
b
"
Thursday
"
b
"
Friday
"
b
"
Saturday
"
b
"
Sunday
"
]
;
pub
(
crate
)
trait
DigitCount
{
fn
num_digits
(
self
)
-
>
u8
;
}
impl
DigitCount
for
u8
{
fn
num_digits
(
self
)
-
>
u8
{
if
self
<
10
{
1
}
else
if
self
<
100
{
2
}
else
{
3
}
}
}
impl
DigitCount
for
u16
{
fn
num_digits
(
self
)
-
>
u8
{
if
self
<
10
{
1
}
else
if
self
<
100
{
2
}
else
if
self
<
1_000
{
3
}
else
if
self
<
10_000
{
4
}
else
{
5
}
}
}
impl
DigitCount
for
u32
{
fn
num_digits
(
self
)
-
>
u8
{
const
TABLE
:
&
[
u64
]
=
&
[
0x0001_0000_0000
0x0001_0000_0000
0x0001_0000_0000
0x0001_FFFF_FFF6
0x0002_0000_0000
0x0002_0000_0000
0x0002_FFFF_FF9C
0x0003_0000_0000
0x0003_0000_0000
0x0003_FFFF_FC18
0x0004_0000_0000
0x0004_0000_0000
0x0004_0000_0000
0x0004_FFFF_D8F0
0x0005_0000_0000
0x0005_0000_0000
0x0005_FFFE_7960
0x0006_0000_0000
0x0006_0000_0000
0x0006_FFF0_BDC0
0x0007_0000_0000
0x0007_0000_0000
0x0007_0000_0000
0x0007_FF67_6980
0x0008_0000_0000
0x0008_0000_0000
0x0008_FA0A_1F00
0x0009_0000_0000
0x0009_0000_0000
0x0009_C465_3600
0x000A_0000_0000
0x000A_0000_0000
]
;
(
(
self
as
u64
+
TABLE
[
31_u32
.
saturating_sub
(
self
.
leading_zeros
(
)
)
as
usize
]
)
>
>
32
)
as
_
}
}
fn
write
(
output
:
&
mut
impl
io
:
:
Write
bytes
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
output
.
write_all
(
bytes
)
?
;
Ok
(
bytes
.
len
(
)
)
}
pub
(
crate
)
fn
format_number
<
W
:
io
:
:
Write
V
:
itoa
:
:
Integer
+
DigitCount
+
Copy
const
WIDTH
:
u8
>
(
output
:
&
mut
W
value
:
V
padding
:
modifier
:
:
Padding
)
-
>
Result
<
usize
io
:
:
Error
>
{
match
padding
{
modifier
:
:
Padding
:
:
Space
=
>
format_number_pad_space
:
:
<
_
_
WIDTH
>
(
output
value
)
modifier
:
:
Padding
:
:
Zero
=
>
format_number_pad_zero
:
:
<
_
_
WIDTH
>
(
output
value
)
modifier
:
:
Padding
:
:
None
=
>
write
(
output
itoa
:
:
Buffer
:
:
new
(
)
.
format
(
value
)
.
as_bytes
(
)
)
}
}
pub
(
crate
)
fn
format_number_pad_space
<
W
:
io
:
:
Write
V
:
itoa
:
:
Integer
+
DigitCount
+
Copy
const
WIDTH
:
u8
>
(
output
:
&
mut
W
value
:
V
)
-
>
Result
<
usize
io
:
:
Error
>
{
let
mut
bytes
=
0
;
for
_
in
0
.
.
(
WIDTH
.
saturating_sub
(
value
.
num_digits
(
)
)
)
{
bytes
+
=
write
(
output
&
[
b
'
'
]
)
?
;
}
bytes
+
=
write
(
output
itoa
:
:
Buffer
:
:
new
(
)
.
format
(
value
)
.
as_bytes
(
)
)
?
;
Ok
(
bytes
)
}
pub
(
crate
)
fn
format_number_pad_zero
<
W
:
io
:
:
Write
V
:
itoa
:
:
Integer
+
DigitCount
+
Copy
const
WIDTH
:
u8
>
(
output
:
&
mut
W
value
:
V
)
-
>
Result
<
usize
io
:
:
Error
>
{
let
mut
bytes
=
0
;
for
_
in
0
.
.
(
WIDTH
.
saturating_sub
(
value
.
num_digits
(
)
)
)
{
bytes
+
=
write
(
output
&
[
b
'
0
'
]
)
?
;
}
bytes
+
=
write
(
output
itoa
:
:
Buffer
:
:
new
(
)
.
format
(
value
)
.
as_bytes
(
)
)
?
;
Ok
(
bytes
)
}
pub
(
crate
)
fn
format_component
(
output
:
&
mut
impl
io
:
:
Write
component
:
Component
date
:
Option
<
Date
>
time
:
Option
<
Time
>
offset
:
Option
<
UtcOffset
>
)
-
>
Result
<
usize
error
:
:
Format
>
{
use
Component
:
:
*
;
Ok
(
match
(
component
date
time
offset
)
{
(
Day
(
modifier
)
Some
(
date
)
.
.
)
=
>
fmt_day
(
output
date
modifier
)
?
(
Month
(
modifier
)
Some
(
date
)
.
.
)
=
>
fmt_month
(
output
date
modifier
)
?
(
Ordinal
(
modifier
)
Some
(
date
)
.
.
)
=
>
fmt_ordinal
(
output
date
modifier
)
?
(
Weekday
(
modifier
)
Some
(
date
)
.
.
)
=
>
fmt_weekday
(
output
date
modifier
)
?
(
WeekNumber
(
modifier
)
Some
(
date
)
.
.
)
=
>
fmt_week_number
(
output
date
modifier
)
?
(
Year
(
modifier
)
Some
(
date
)
.
.
)
=
>
fmt_year
(
output
date
modifier
)
?
(
Hour
(
modifier
)
_
Some
(
time
)
_
)
=
>
fmt_hour
(
output
time
modifier
)
?
(
Minute
(
modifier
)
_
Some
(
time
)
_
)
=
>
fmt_minute
(
output
time
modifier
)
?
(
Period
(
modifier
)
_
Some
(
time
)
_
)
=
>
fmt_period
(
output
time
modifier
)
?
(
Second
(
modifier
)
_
Some
(
time
)
_
)
=
>
fmt_second
(
output
time
modifier
)
?
(
Subsecond
(
modifier
)
_
Some
(
time
)
_
)
=
>
fmt_subsecond
(
output
time
modifier
)
?
(
OffsetHour
(
modifier
)
.
.
Some
(
offset
)
)
=
>
fmt_offset_hour
(
output
offset
modifier
)
?
(
OffsetMinute
(
modifier
)
.
.
Some
(
offset
)
)
=
>
fmt_offset_minute
(
output
offset
modifier
)
?
(
OffsetSecond
(
modifier
)
.
.
Some
(
offset
)
)
=
>
fmt_offset_second
(
output
offset
modifier
)
?
_
=
>
return
Err
(
error
:
:
Format
:
:
InsufficientTypeInformation
)
}
)
}
fn
fmt_day
(
output
:
&
mut
impl
io
:
:
Write
date
:
Date
modifier
:
:
Day
{
padding
}
:
modifier
:
:
Day
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
2
>
(
output
date
.
day
(
)
padding
)
}
fn
fmt_month
(
output
:
&
mut
impl
io
:
:
Write
date
:
Date
modifier
:
:
Month
{
padding
repr
case_sensitive
:
_
}
:
modifier
:
:
Month
)
-
>
Result
<
usize
io
:
:
Error
>
{
match
repr
{
modifier
:
:
MonthRepr
:
:
Numerical
=
>
{
format_number
:
:
<
_
_
2
>
(
output
date
.
month
(
)
as
u8
padding
)
}
modifier
:
:
MonthRepr
:
:
Long
=
>
write
(
output
MONTH_NAMES
[
date
.
month
(
)
as
usize
-
1
]
)
modifier
:
:
MonthRepr
:
:
Short
=
>
write
(
output
&
MONTH_NAMES
[
date
.
month
(
)
as
usize
-
1
]
[
.
.
3
]
)
}
}
fn
fmt_ordinal
(
output
:
&
mut
impl
io
:
:
Write
date
:
Date
modifier
:
:
Ordinal
{
padding
}
:
modifier
:
:
Ordinal
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
3
>
(
output
date
.
ordinal
(
)
padding
)
}
fn
fmt_weekday
(
output
:
&
mut
impl
io
:
:
Write
date
:
Date
modifier
:
:
Weekday
{
repr
one_indexed
case_sensitive
:
_
}
:
modifier
:
:
Weekday
)
-
>
Result
<
usize
io
:
:
Error
>
{
match
repr
{
modifier
:
:
WeekdayRepr
:
:
Short
=
>
write
(
output
&
WEEKDAY_NAMES
[
date
.
weekday
(
)
.
number_days_from_monday
(
)
as
usize
]
[
.
.
3
]
)
modifier
:
:
WeekdayRepr
:
:
Long
=
>
write
(
output
WEEKDAY_NAMES
[
date
.
weekday
(
)
.
number_days_from_monday
(
)
as
usize
]
)
modifier
:
:
WeekdayRepr
:
:
Sunday
=
>
format_number
:
:
<
_
_
1
>
(
output
date
.
weekday
(
)
.
number_days_from_sunday
(
)
+
one_indexed
as
u8
modifier
:
:
Padding
:
:
None
)
modifier
:
:
WeekdayRepr
:
:
Monday
=
>
format_number
:
:
<
_
_
1
>
(
output
date
.
weekday
(
)
.
number_days_from_monday
(
)
+
one_indexed
as
u8
modifier
:
:
Padding
:
:
None
)
}
}
fn
fmt_week_number
(
output
:
&
mut
impl
io
:
:
Write
date
:
Date
modifier
:
:
WeekNumber
{
padding
repr
}
:
modifier
:
:
WeekNumber
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
2
>
(
output
match
repr
{
modifier
:
:
WeekNumberRepr
:
:
Iso
=
>
date
.
iso_week
(
)
modifier
:
:
WeekNumberRepr
:
:
Sunday
=
>
date
.
sunday_based_week
(
)
modifier
:
:
WeekNumberRepr
:
:
Monday
=
>
date
.
monday_based_week
(
)
}
padding
)
}
fn
fmt_year
(
output
:
&
mut
impl
io
:
:
Write
date
:
Date
modifier
:
:
Year
{
padding
repr
iso_week_based
sign_is_mandatory
}
:
modifier
:
:
Year
)
-
>
Result
<
usize
io
:
:
Error
>
{
let
full_year
=
if
iso_week_based
{
date
.
iso_year_week
(
)
.
0
}
else
{
date
.
year
(
)
}
;
let
value
=
match
repr
{
modifier
:
:
YearRepr
:
:
Full
=
>
full_year
modifier
:
:
YearRepr
:
:
LastTwo
=
>
(
full_year
%
100
)
.
abs
(
)
}
;
let
format_number
=
match
repr
{
#
[
cfg
(
feature
=
"
large
-
dates
"
)
]
modifier
:
:
YearRepr
:
:
Full
if
value
.
abs
(
)
>
=
100_000
=
>
format_number
:
:
<
_
_
6
>
#
[
cfg
(
feature
=
"
large
-
dates
"
)
]
modifier
:
:
YearRepr
:
:
Full
if
value
.
abs
(
)
>
=
10_000
=
>
format_number
:
:
<
_
_
5
>
modifier
:
:
YearRepr
:
:
Full
=
>
format_number
:
:
<
_
_
4
>
modifier
:
:
YearRepr
:
:
LastTwo
=
>
format_number
:
:
<
_
_
2
>
}
;
let
mut
bytes
=
0
;
if
repr
!
=
modifier
:
:
YearRepr
:
:
LastTwo
{
if
full_year
<
0
{
bytes
+
=
write
(
output
&
[
b
'
-
'
]
)
?
;
}
else
if
sign_is_mandatory
|
|
cfg
!
(
feature
=
"
large
-
dates
"
)
&
&
full_year
>
=
10_000
{
bytes
+
=
write
(
output
&
[
b
'
+
'
]
)
?
;
}
}
bytes
+
=
format_number
(
output
value
.
unsigned_abs
(
)
padding
)
?
;
Ok
(
bytes
)
}
fn
fmt_hour
(
output
:
&
mut
impl
io
:
:
Write
time
:
Time
modifier
:
:
Hour
{
padding
is_12_hour_clock
}
:
modifier
:
:
Hour
)
-
>
Result
<
usize
io
:
:
Error
>
{
let
value
=
match
(
time
.
hour
(
)
is_12_hour_clock
)
{
(
hour
false
)
=
>
hour
(
0
|
12
true
)
=
>
12
(
hour
true
)
if
hour
<
12
=
>
hour
(
hour
true
)
=
>
hour
-
12
}
;
format_number
:
:
<
_
_
2
>
(
output
value
padding
)
}
fn
fmt_minute
(
output
:
&
mut
impl
io
:
:
Write
time
:
Time
modifier
:
:
Minute
{
padding
}
:
modifier
:
:
Minute
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
2
>
(
output
time
.
minute
(
)
padding
)
}
fn
fmt_period
(
output
:
&
mut
impl
io
:
:
Write
time
:
Time
modifier
:
:
Period
{
is_uppercase
case_sensitive
:
_
}
:
modifier
:
:
Period
)
-
>
Result
<
usize
io
:
:
Error
>
{
match
(
time
.
hour
(
)
>
=
12
is_uppercase
)
{
(
false
false
)
=
>
write
(
output
b
"
am
"
)
(
false
true
)
=
>
write
(
output
b
"
AM
"
)
(
true
false
)
=
>
write
(
output
b
"
pm
"
)
(
true
true
)
=
>
write
(
output
b
"
PM
"
)
}
}
fn
fmt_second
(
output
:
&
mut
impl
io
:
:
Write
time
:
Time
modifier
:
:
Second
{
padding
}
:
modifier
:
:
Second
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
2
>
(
output
time
.
second
(
)
padding
)
}
fn
fmt_subsecond
<
W
:
io
:
:
Write
>
(
output
:
&
mut
W
time
:
Time
modifier
:
:
Subsecond
{
digits
}
:
modifier
:
:
Subsecond
)
-
>
Result
<
usize
io
:
:
Error
>
{
use
modifier
:
:
SubsecondDigits
:
:
*
;
let
nanos
=
time
.
nanosecond
(
)
;
if
digits
=
=
Nine
|
|
(
digits
=
=
OneOrMore
&
&
nanos
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
9
>
(
output
nanos
)
}
else
if
digits
=
=
Eight
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
10
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
8
>
(
output
nanos
/
10
)
}
else
if
digits
=
=
Seven
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
100
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
7
>
(
output
nanos
/
100
)
}
else
if
digits
=
=
Six
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
1_000
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
6
>
(
output
nanos
/
1_000
)
}
else
if
digits
=
=
Five
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
10_000
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
5
>
(
output
nanos
/
10_000
)
}
else
if
digits
=
=
Four
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
100_000
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
4
>
(
output
nanos
/
100_000
)
}
else
if
digits
=
=
Three
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
1_000_000
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
3
>
(
output
nanos
/
1_000_000
)
}
else
if
digits
=
=
Two
|
|
(
digits
=
=
OneOrMore
&
&
(
nanos
/
10_000_000
)
%
10
!
=
0
)
{
format_number_pad_zero
:
:
<
_
_
2
>
(
output
nanos
/
10_000_000
)
}
else
{
format_number_pad_zero
:
:
<
_
_
1
>
(
output
nanos
/
100_000_000
)
}
}
fn
fmt_offset_hour
(
output
:
&
mut
impl
io
:
:
Write
offset
:
UtcOffset
modifier
:
:
OffsetHour
{
padding
sign_is_mandatory
}
:
modifier
:
:
OffsetHour
)
-
>
Result
<
usize
io
:
:
Error
>
{
let
mut
bytes
=
0
;
if
offset
.
is_negative
(
)
{
bytes
+
=
write
(
output
&
[
b
'
-
'
]
)
?
;
}
else
if
sign_is_mandatory
{
bytes
+
=
write
(
output
&
[
b
'
+
'
]
)
?
;
}
bytes
+
=
format_number
:
:
<
_
_
2
>
(
output
offset
.
whole_hours
(
)
.
unsigned_abs
(
)
padding
)
?
;
Ok
(
bytes
)
}
fn
fmt_offset_minute
(
output
:
&
mut
impl
io
:
:
Write
offset
:
UtcOffset
modifier
:
:
OffsetMinute
{
padding
}
:
modifier
:
:
OffsetMinute
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
2
>
(
output
offset
.
minutes_past_hour
(
)
.
unsigned_abs
(
)
padding
)
}
fn
fmt_offset_second
(
output
:
&
mut
impl
io
:
:
Write
offset
:
UtcOffset
modifier
:
:
OffsetSecond
{
padding
}
:
modifier
:
:
OffsetSecond
)
-
>
Result
<
usize
io
:
:
Error
>
{
format_number
:
:
<
_
_
2
>
(
output
offset
.
seconds_past_minute
(
)
.
unsigned_abs
(
)
padding
)
}
