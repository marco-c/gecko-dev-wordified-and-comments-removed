#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
mem
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
{
error
:
:
InvalidFormatDescription
format_description
:
:
helper
}
;
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Day
{
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
MonthRepr
{
Numerical
Long
Short
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Month
{
pub
padding
:
Padding
pub
repr
:
MonthRepr
pub
case_sensitive
:
bool
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Ordinal
{
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
WeekdayRepr
{
Short
Long
Sunday
Monday
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Weekday
{
pub
repr
:
WeekdayRepr
pub
one_indexed
:
bool
pub
case_sensitive
:
bool
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
WeekNumberRepr
{
Iso
Sunday
Monday
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
WeekNumber
{
pub
padding
:
Padding
pub
repr
:
WeekNumberRepr
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
YearRepr
{
Full
LastTwo
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Year
{
pub
padding
:
Padding
pub
repr
:
YearRepr
pub
iso_week_based
:
bool
pub
sign_is_mandatory
:
bool
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Hour
{
pub
padding
:
Padding
pub
is_12_hour_clock
:
bool
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Minute
{
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Period
{
pub
is_uppercase
:
bool
pub
case_sensitive
:
bool
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Second
{
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
SubsecondDigits
{
One
Two
Three
Four
Five
Six
Seven
Eight
Nine
OneOrMore
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Subsecond
{
pub
digits
:
SubsecondDigits
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
OffsetHour
{
pub
sign_is_mandatory
:
bool
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
OffsetMinute
{
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
OffsetSecond
{
pub
padding
:
Padding
}
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
Padding
{
Space
Zero
None
}
macro_rules
!
if_pub
{
(
pub
(
#
[
attr
:
meta
]
)
*
;
(
x
:
tt
)
*
)
=
>
{
(
#
[
attr
]
)
*
/
/
/
/
/
/
This
function
exists
since
[
Default
:
:
default
(
)
]
cannot
be
used
in
a
const
context
.
/
/
/
It
may
be
removed
once
that
becomes
possible
.
As
the
[
Default
]
trait
is
in
the
/
/
/
prelude
removing
this
function
in
the
future
will
not
cause
any
resolution
failures
for
/
/
/
the
overwhelming
majority
of
users
;
only
users
who
use
#
!
[
no_implicit_prelude
]
will
be
/
/
/
affected
.
As
such
it
will
not
be
considered
a
breaking
change
.
(
x
)
*
}
;
(
(
_
:
tt
)
*
)
=
>
{
}
;
}
macro_rules
!
impl_const_default
{
(
(
(
#
[
doc
:
meta
]
)
*
(
pub
:
ident
)
?
type
:
ty
=
>
default
:
expr
;
)
*
)
=
>
{
(
impl
type
{
if_pub
!
{
(
pub
)
?
(
#
[
doc
]
)
*
;
pub
const
fn
default
(
)
-
>
Self
{
default
}
}
}
(
#
[
doc
]
)
*
impl
Default
for
type
{
fn
default
(
)
-
>
Self
{
default
}
}
)
*
}
;
}
impl_const_default
!
{
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
Day
=
>
Self
{
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
/
/
/
[
Numerical
]
(
Self
:
:
Numerical
)
representation
.
MonthRepr
=
>
Self
:
:
Numerical
;
/
/
/
Creates
an
instance
of
this
type
that
indicates
the
value
uses
the
/
/
/
[
Numerical
]
(
MonthRepr
:
:
Numerical
)
representation
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
/
/
/
and
is
case
-
sensitive
when
parsing
.
pub
Month
=
>
Self
{
padding
:
Padding
:
:
Zero
repr
:
MonthRepr
:
:
Numerical
case_sensitive
:
true
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
Ordinal
=
>
Self
{
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
[
Long
]
(
Self
:
:
Long
)
representation
.
WeekdayRepr
=
>
Self
:
:
Long
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
[
Long
]
(
WeekdayRepr
:
:
Long
)
/
/
/
representation
and
is
case
-
sensitive
when
parsing
.
If
the
representation
is
changed
to
a
/
/
/
numerical
one
the
instance
defaults
to
one
-
based
indexing
.
pub
Weekday
=
>
Self
{
repr
:
WeekdayRepr
:
:
Long
one_indexed
:
true
case_sensitive
:
true
}
;
/
/
/
Creates
a
modifier
that
indicates
that
the
value
uses
the
[
Iso
]
(
Self
:
:
Iso
)
representation
.
WeekNumberRepr
=
>
Self
:
:
Iso
;
/
/
/
Creates
a
modifier
that
indicates
that
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
/
/
/
and
uses
the
[
Iso
]
(
WeekNumberRepr
:
:
Iso
)
representation
.
pub
WeekNumber
=
>
Self
{
padding
:
Padding
:
:
Zero
repr
:
WeekNumberRepr
:
:
Iso
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
[
Full
]
(
Self
:
:
Full
)
representation
.
YearRepr
=
>
Self
:
:
Full
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
[
Full
]
(
YearRepr
:
:
Full
)
/
/
/
representation
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
uses
the
Gregorian
calendar
as
its
/
/
/
base
and
only
includes
the
year
'
s
sign
if
necessary
.
pub
Year
=
>
Self
{
padding
:
Padding
:
:
Zero
repr
:
YearRepr
:
:
Full
iso_week_based
:
false
sign_is_mandatory
:
false
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
and
/
/
/
has
the
24
-
hour
representation
.
pub
Hour
=
>
Self
{
padding
:
Padding
:
:
Zero
is_12_hour_clock
:
false
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
Minute
=
>
Self
{
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
upper
-
case
representation
and
is
/
/
/
case
-
sensitive
when
parsing
.
pub
Period
=
>
Self
{
is_uppercase
:
true
case_sensitive
:
true
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
Second
=
>
Self
{
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
stringified
value
contains
[
one
or
more
/
/
/
digits
]
(
Self
:
:
OneOrMore
)
.
SubsecondDigits
=
>
Self
:
:
OneOrMore
;
/
/
/
Creates
a
modifier
that
indicates
the
stringified
value
contains
[
one
or
more
/
/
/
digits
]
(
SubsecondDigits
:
:
OneOrMore
)
.
pub
Subsecond
=
>
Self
{
digits
:
SubsecondDigits
:
:
OneOrMore
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
uses
the
+
sign
for
all
positive
values
/
/
/
and
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
OffsetHour
=
>
Self
{
sign_is_mandatory
:
true
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
OffsetMinute
=
>
Self
{
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Padding
:
:
Zero
)
.
pub
OffsetSecond
=
>
Self
{
padding
:
Padding
:
:
Zero
}
;
/
/
/
Creates
a
modifier
that
indicates
the
value
is
[
padded
with
zeroes
]
(
Self
:
:
Zero
)
.
Padding
=
>
Self
:
:
Zero
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
Modifiers
{
pub
(
crate
)
padding
:
Option
<
Padding
>
pub
(
crate
)
hour_is_12_hour_clock
:
Option
<
bool
>
pub
(
crate
)
period_is_uppercase
:
Option
<
bool
>
pub
(
crate
)
month_repr
:
Option
<
MonthRepr
>
pub
(
crate
)
subsecond_digits
:
Option
<
SubsecondDigits
>
pub
(
crate
)
weekday_repr
:
Option
<
WeekdayRepr
>
pub
(
crate
)
weekday_is_one_indexed
:
Option
<
bool
>
pub
(
crate
)
week_number_repr
:
Option
<
WeekNumberRepr
>
pub
(
crate
)
year_repr
:
Option
<
YearRepr
>
pub
(
crate
)
year_is_iso_week_based
:
Option
<
bool
>
pub
(
crate
)
sign_is_mandatory
:
Option
<
bool
>
pub
(
crate
)
case_sensitive
:
Option
<
bool
>
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Modifiers
{
#
[
allow
(
clippy
:
:
too_many_lines
)
]
pub
(
crate
)
fn
parse
(
component_name
:
&
[
u8
]
mut
bytes
:
&
[
u8
]
index
:
&
mut
usize
)
-
>
Result
<
Self
InvalidFormatDescription
>
{
let
mut
modifiers
=
Self
:
:
default
(
)
;
while
!
bytes
.
is_empty
(
)
{
bytes
=
helper
:
:
consume_whitespace
(
bytes
index
)
;
let
modifier
;
if
let
Some
(
whitespace_loc
)
=
bytes
.
iter
(
)
.
position
(
u8
:
:
is_ascii_whitespace
)
{
*
index
+
=
whitespace_loc
;
modifier
=
&
bytes
[
.
.
whitespace_loc
]
;
bytes
=
&
bytes
[
whitespace_loc
.
.
]
;
}
else
{
modifier
=
mem
:
:
take
(
&
mut
bytes
)
;
}
if
modifier
.
is_empty
(
)
{
break
;
}
match
(
component_name
modifier
)
{
(
b
"
day
"
|
b
"
hour
"
|
b
"
minute
"
|
b
"
month
"
|
b
"
offset_hour
"
|
b
"
offset_minute
"
|
b
"
offset_second
"
|
b
"
ordinal
"
|
b
"
second
"
|
b
"
week_number
"
|
b
"
year
"
b
"
padding
:
space
"
)
=
>
modifiers
.
padding
=
Some
(
Padding
:
:
Space
)
(
b
"
day
"
|
b
"
hour
"
|
b
"
minute
"
|
b
"
month
"
|
b
"
offset_hour
"
|
b
"
offset_minute
"
|
b
"
offset_second
"
|
b
"
ordinal
"
|
b
"
second
"
|
b
"
week_number
"
|
b
"
year
"
b
"
padding
:
zero
"
)
=
>
modifiers
.
padding
=
Some
(
Padding
:
:
Zero
)
(
b
"
day
"
|
b
"
hour
"
|
b
"
minute
"
|
b
"
month
"
|
b
"
offset_hour
"
|
b
"
offset_minute
"
|
b
"
offset_second
"
|
b
"
ordinal
"
|
b
"
second
"
|
b
"
week_number
"
|
b
"
year
"
b
"
padding
:
none
"
)
=
>
modifiers
.
padding
=
Some
(
Padding
:
:
None
)
(
b
"
hour
"
b
"
repr
:
24
"
)
=
>
modifiers
.
hour_is_12_hour_clock
=
Some
(
false
)
(
b
"
hour
"
b
"
repr
:
12
"
)
=
>
modifiers
.
hour_is_12_hour_clock
=
Some
(
true
)
(
b
"
month
"
|
b
"
period
"
|
b
"
weekday
"
b
"
case_sensitive
:
true
"
)
=
>
{
modifiers
.
case_sensitive
=
Some
(
true
)
}
(
b
"
month
"
|
b
"
period
"
|
b
"
weekday
"
b
"
case_sensitive
:
false
"
)
=
>
{
modifiers
.
case_sensitive
=
Some
(
false
)
}
(
b
"
month
"
b
"
repr
:
numerical
"
)
=
>
modifiers
.
month_repr
=
Some
(
MonthRepr
:
:
Numerical
)
(
b
"
month
"
b
"
repr
:
long
"
)
=
>
modifiers
.
month_repr
=
Some
(
MonthRepr
:
:
Long
)
(
b
"
month
"
b
"
repr
:
short
"
)
=
>
modifiers
.
month_repr
=
Some
(
MonthRepr
:
:
Short
)
(
b
"
offset_hour
"
|
b
"
year
"
b
"
sign
:
automatic
"
)
=
>
{
modifiers
.
sign_is_mandatory
=
Some
(
false
)
;
}
(
b
"
offset_hour
"
|
b
"
year
"
b
"
sign
:
mandatory
"
)
=
>
{
modifiers
.
sign_is_mandatory
=
Some
(
true
)
;
}
(
b
"
period
"
b
"
case
:
upper
"
)
=
>
modifiers
.
period_is_uppercase
=
Some
(
true
)
(
b
"
period
"
b
"
case
:
lower
"
)
=
>
modifiers
.
period_is_uppercase
=
Some
(
false
)
(
b
"
subsecond
"
b
"
digits
:
1
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
One
)
;
}
(
b
"
subsecond
"
b
"
digits
:
2
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Two
)
;
}
(
b
"
subsecond
"
b
"
digits
:
3
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Three
)
;
}
(
b
"
subsecond
"
b
"
digits
:
4
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Four
)
;
}
(
b
"
subsecond
"
b
"
digits
:
5
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Five
)
;
}
(
b
"
subsecond
"
b
"
digits
:
6
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Six
)
;
}
(
b
"
subsecond
"
b
"
digits
:
7
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Seven
)
;
}
(
b
"
subsecond
"
b
"
digits
:
8
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Eight
)
;
}
(
b
"
subsecond
"
b
"
digits
:
9
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
Nine
)
;
}
(
b
"
subsecond
"
b
"
digits
:
1
+
"
)
=
>
{
modifiers
.
subsecond_digits
=
Some
(
SubsecondDigits
:
:
OneOrMore
)
;
}
(
b
"
weekday
"
b
"
repr
:
short
"
)
=
>
modifiers
.
weekday_repr
=
Some
(
WeekdayRepr
:
:
Short
)
(
b
"
weekday
"
b
"
repr
:
long
"
)
=
>
modifiers
.
weekday_repr
=
Some
(
WeekdayRepr
:
:
Long
)
(
b
"
weekday
"
b
"
repr
:
sunday
"
)
=
>
modifiers
.
weekday_repr
=
Some
(
WeekdayRepr
:
:
Sunday
)
(
b
"
weekday
"
b
"
repr
:
monday
"
)
=
>
modifiers
.
weekday_repr
=
Some
(
WeekdayRepr
:
:
Monday
)
(
b
"
weekday
"
b
"
one_indexed
:
true
"
)
=
>
modifiers
.
weekday_is_one_indexed
=
Some
(
true
)
(
b
"
weekday
"
b
"
one_indexed
:
false
"
)
=
>
{
modifiers
.
weekday_is_one_indexed
=
Some
(
false
)
;
}
(
b
"
week_number
"
b
"
repr
:
iso
"
)
=
>
{
modifiers
.
week_number_repr
=
Some
(
WeekNumberRepr
:
:
Iso
)
;
}
(
b
"
week_number
"
b
"
repr
:
sunday
"
)
=
>
{
modifiers
.
week_number_repr
=
Some
(
WeekNumberRepr
:
:
Sunday
)
;
}
(
b
"
week_number
"
b
"
repr
:
monday
"
)
=
>
{
modifiers
.
week_number_repr
=
Some
(
WeekNumberRepr
:
:
Monday
)
;
}
(
b
"
year
"
b
"
repr
:
full
"
)
=
>
modifiers
.
year_repr
=
Some
(
YearRepr
:
:
Full
)
(
b
"
year
"
b
"
repr
:
last_two
"
)
=
>
modifiers
.
year_repr
=
Some
(
YearRepr
:
:
LastTwo
)
(
b
"
year
"
b
"
base
:
calendar
"
)
=
>
modifiers
.
year_is_iso_week_based
=
Some
(
false
)
(
b
"
year
"
b
"
base
:
iso_week
"
)
=
>
modifiers
.
year_is_iso_week_based
=
Some
(
true
)
_
=
>
{
return
Err
(
InvalidFormatDescription
:
:
InvalidModifier
{
value
:
String
:
:
from_utf8_lossy
(
modifier
)
.
into_owned
(
)
index
:
*
index
}
)
;
}
}
}
Ok
(
modifiers
)
}
}
