mod
component
;
pub
mod
modifier
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
(
crate
)
mod
parse
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
use
core
:
:
convert
:
:
TryFrom
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
fmt
;
pub
use
self
:
:
component
:
:
Component
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
self
:
:
parse
:
:
parse
;
use
crate
:
:
error
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
helper
{
#
[
must_use
=
"
This
does
not
modify
the
original
slice
.
"
]
pub
(
crate
)
fn
consume_whitespace
<
'
a
>
(
bytes
:
&
'
a
[
u8
]
index
:
&
mut
usize
)
-
>
&
'
a
[
u8
]
{
let
first_non_whitespace
=
bytes
.
iter
(
)
.
position
(
|
c
|
!
c
.
is_ascii_whitespace
(
)
)
.
unwrap_or
(
bytes
.
len
(
)
)
;
*
index
+
=
first_non_whitespace
;
&
bytes
[
first_non_whitespace
.
.
]
}
}
pub
mod
well_known
{
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Rfc3339
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Rfc2822
;
}
#
[
non_exhaustive
]
#
[
cfg_attr
(
not
(
feature
=
"
alloc
"
)
derive
(
Debug
)
)
]
#
[
derive
(
Clone
PartialEq
Eq
)
]
pub
enum
FormatItem
<
'
a
>
{
Literal
(
&
'
a
[
u8
]
)
Component
(
Component
)
Compound
(
&
'
a
[
Self
]
)
Optional
(
&
'
a
Self
)
First
(
&
'
a
[
Self
]
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
fmt
:
:
Debug
for
FormatItem
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
FormatItem
:
:
Literal
(
literal
)
=
>
f
.
write_str
(
&
String
:
:
from_utf8_lossy
(
literal
)
)
FormatItem
:
:
Component
(
component
)
=
>
component
.
fmt
(
f
)
FormatItem
:
:
Compound
(
compound
)
=
>
compound
.
fmt
(
f
)
FormatItem
:
:
Optional
(
item
)
=
>
f
.
debug_tuple
(
"
Optional
"
)
.
field
(
item
)
.
finish
(
)
FormatItem
:
:
First
(
items
)
=
>
f
.
debug_tuple
(
"
First
"
)
.
field
(
items
)
.
finish
(
)
}
}
}
impl
From
<
Component
>
for
FormatItem
<
'
_
>
{
fn
from
(
component
:
Component
)
-
>
Self
{
Self
:
:
Component
(
component
)
}
}
impl
TryFrom
<
FormatItem
<
'
_
>
>
for
Component
{
type
Error
=
error
:
:
DifferentVariant
;
fn
try_from
(
value
:
FormatItem
<
'
_
>
)
-
>
Result
<
Self
Self
:
:
Error
>
{
match
value
{
FormatItem
:
:
Component
(
component
)
=
>
Ok
(
component
)
_
=
>
Err
(
error
:
:
DifferentVariant
)
}
}
}
impl
<
'
a
>
From
<
&
'
a
[
FormatItem
<
'
_
>
]
>
for
FormatItem
<
'
a
>
{
fn
from
(
items
:
&
'
a
[
FormatItem
<
'
_
>
]
)
-
>
FormatItem
<
'
a
>
{
FormatItem
:
:
Compound
(
items
)
}
}
impl
<
'
a
>
TryFrom
<
FormatItem
<
'
a
>
>
for
&
[
FormatItem
<
'
a
>
]
{
type
Error
=
error
:
:
DifferentVariant
;
fn
try_from
(
value
:
FormatItem
<
'
a
>
)
-
>
Result
<
Self
Self
:
:
Error
>
{
match
value
{
FormatItem
:
:
Compound
(
items
)
=
>
Ok
(
items
)
_
=
>
Err
(
error
:
:
DifferentVariant
)
}
}
}
impl
PartialEq
<
Component
>
for
FormatItem
<
'
_
>
{
fn
eq
(
&
self
rhs
:
&
Component
)
-
>
bool
{
matches
!
(
self
FormatItem
:
:
Component
(
component
)
if
component
=
=
rhs
)
}
}
impl
PartialEq
<
FormatItem
<
'
_
>
>
for
Component
{
fn
eq
(
&
self
rhs
:
&
FormatItem
<
'
_
>
)
-
>
bool
{
rhs
=
=
self
}
}
impl
PartialEq
<
&
[
FormatItem
<
'
_
>
]
>
for
FormatItem
<
'
_
>
{
fn
eq
(
&
self
rhs
:
&
&
[
FormatItem
<
'
_
>
]
)
-
>
bool
{
matches
!
(
self
FormatItem
:
:
Compound
(
compound
)
if
compound
=
=
rhs
)
}
}
impl
PartialEq
<
FormatItem
<
'
_
>
>
for
&
[
FormatItem
<
'
_
>
]
{
fn
eq
(
&
self
rhs
:
&
FormatItem
<
'
_
>
)
-
>
bool
{
rhs
=
=
self
}
}
