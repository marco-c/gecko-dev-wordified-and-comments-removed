#
[
cfg
(
feature
=
"
formatting
"
)
]
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
use
core
:
:
ops
:
:
{
Add
Sub
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
use
deranged
:
:
{
RangedU32
RangedU8
}
;
use
num_conv
:
:
prelude
:
:
*
;
use
powerfmt
:
:
ext
:
:
FormatterExt
;
use
powerfmt
:
:
smart_display
:
:
{
self
FormatterOptions
Metadata
SmartDisplay
}
;
use
crate
:
:
convert
:
:
*
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
use
crate
:
:
internal_macros
:
:
{
cascade
ensure_ranged
impl_add_assign
impl_sub_assign
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
use
crate
:
:
util
:
:
DateAdjustment
;
use
crate
:
:
{
error
Duration
}
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
(
crate
)
enum
Padding
{
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
Optimize
}
type
Hours
=
RangedU8
<
0
{
Hour
:
:
per
(
Day
)
-
1
}
>
;
type
Minutes
=
RangedU8
<
0
{
Minute
:
:
per
(
Hour
)
-
1
}
>
;
type
Seconds
=
RangedU8
<
0
{
Second
:
:
per
(
Minute
)
-
1
}
>
;
type
Nanoseconds
=
RangedU32
<
0
{
Nanosecond
:
:
per
(
Second
)
-
1
}
>
;
#
[
derive
(
Clone
Copy
Eq
)
]
#
[
repr
(
C
)
]
pub
struct
Time
{
#
[
cfg
(
target_endian
=
"
little
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
nanosecond
:
Nanoseconds
#
[
cfg
(
target_endian
=
"
little
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
second
:
Seconds
#
[
cfg
(
target_endian
=
"
little
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
minute
:
Minutes
#
[
cfg
(
target_endian
=
"
little
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
hour
:
Hours
#
[
cfg
(
target_endian
=
"
little
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
padding
:
Padding
#
[
cfg
(
target_endian
=
"
big
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
padding
:
Padding
#
[
cfg
(
target_endian
=
"
big
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
hour
:
Hours
#
[
cfg
(
target_endian
=
"
big
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
minute
:
Minutes
#
[
cfg
(
target_endian
=
"
big
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
second
:
Seconds
#
[
cfg
(
target_endian
=
"
big
"
)
]
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
nanosecond
:
Nanoseconds
}
impl
core
:
:
hash
:
:
Hash
for
Time
{
fn
hash
<
H
:
core
:
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
as_u64
(
)
.
hash
(
state
)
}
}
impl
PartialEq
for
Time
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
as_u64
(
)
.
eq
(
&
other
.
as_u64
(
)
)
}
}
impl
PartialOrd
for
Time
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
core
:
:
cmp
:
:
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
Time
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
core
:
:
cmp
:
:
Ordering
{
self
.
as_u64
(
)
.
cmp
(
&
other
.
as_u64
(
)
)
}
}
impl
Time
{
const
fn
as_u64
(
self
)
-
>
u64
{
let
nano_bytes
=
self
.
nanosecond
.
get
(
)
.
to_ne_bytes
(
)
;
#
[
cfg
(
target_endian
=
"
big
"
)
]
return
u64
:
:
from_be_bytes
(
[
self
.
padding
as
u8
self
.
hour
.
get
(
)
self
.
minute
.
get
(
)
self
.
second
.
get
(
)
nano_bytes
[
0
]
nano_bytes
[
1
]
nano_bytes
[
2
]
nano_bytes
[
3
]
]
)
;
#
[
cfg
(
target_endian
=
"
little
"
)
]
return
u64
:
:
from_le_bytes
(
[
nano_bytes
[
0
]
nano_bytes
[
1
]
nano_bytes
[
2
]
nano_bytes
[
3
]
self
.
second
.
get
(
)
self
.
minute
.
get
(
)
self
.
hour
.
get
(
)
self
.
padding
as
u8
]
)
;
}
pub
const
MIDNIGHT
:
Self
=
Self
:
:
MIN
;
pub
(
crate
)
const
MIN
:
Self
=
Self
:
:
from_hms_nanos_ranged
(
Hours
:
:
MIN
Minutes
:
:
MIN
Seconds
:
:
MIN
Nanoseconds
:
:
MIN
)
;
pub
(
crate
)
const
MAX
:
Self
=
Self
:
:
from_hms_nanos_ranged
(
Hours
:
:
MAX
Minutes
:
:
MAX
Seconds
:
:
MAX
Nanoseconds
:
:
MAX
)
;
#
[
doc
(
hidden
)
]
pub
const
unsafe
fn
__from_hms_nanos_unchecked
(
hour
:
u8
minute
:
u8
second
:
u8
nanosecond
:
u32
)
-
>
Self
{
unsafe
{
Self
:
:
from_hms_nanos_ranged
(
Hours
:
:
new_unchecked
(
hour
)
Minutes
:
:
new_unchecked
(
minute
)
Seconds
:
:
new_unchecked
(
second
)
Nanoseconds
:
:
new_unchecked
(
nanosecond
)
)
}
}
pub
const
fn
from_hms
(
hour
:
u8
minute
:
u8
second
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
:
:
from_hms_nanos_ranged
(
ensure_ranged
!
(
Hours
:
hour
)
ensure_ranged
!
(
Minutes
:
minute
)
ensure_ranged
!
(
Seconds
:
second
)
Nanoseconds
:
:
MIN
)
)
}
pub
(
crate
)
const
fn
from_hms_nanos_ranged
(
hour
:
Hours
minute
:
Minutes
second
:
Seconds
nanosecond
:
Nanoseconds
)
-
>
Self
{
Self
{
hour
minute
second
nanosecond
padding
:
Padding
:
:
Optimize
}
}
pub
const
fn
from_hms_milli
(
hour
:
u8
minute
:
u8
second
:
u8
millisecond
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
:
:
from_hms_nanos_ranged
(
ensure_ranged
!
(
Hours
:
hour
)
ensure_ranged
!
(
Minutes
:
minute
)
ensure_ranged
!
(
Seconds
:
second
)
ensure_ranged
!
(
Nanoseconds
:
millisecond
as
u32
*
Nanosecond
:
:
per
(
Millisecond
)
)
)
)
}
pub
const
fn
from_hms_micro
(
hour
:
u8
minute
:
u8
second
:
u8
microsecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
:
:
from_hms_nanos_ranged
(
ensure_ranged
!
(
Hours
:
hour
)
ensure_ranged
!
(
Minutes
:
minute
)
ensure_ranged
!
(
Seconds
:
second
)
ensure_ranged
!
(
Nanoseconds
:
microsecond
*
Nanosecond
:
:
per
(
Microsecond
)
as
u32
)
)
)
}
pub
const
fn
from_hms_nano
(
hour
:
u8
minute
:
u8
second
:
u8
nanosecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
:
:
from_hms_nanos_ranged
(
ensure_ranged
!
(
Hours
:
hour
)
ensure_ranged
!
(
Minutes
:
minute
)
ensure_ranged
!
(
Seconds
:
second
)
ensure_ranged
!
(
Nanoseconds
:
nanosecond
)
)
)
}
pub
const
fn
as_hms
(
self
)
-
>
(
u8
u8
u8
)
{
(
self
.
hour
.
get
(
)
self
.
minute
.
get
(
)
self
.
second
.
get
(
)
)
}
pub
const
fn
as_hms_milli
(
self
)
-
>
(
u8
u8
u8
u16
)
{
(
self
.
hour
.
get
(
)
self
.
minute
.
get
(
)
self
.
second
.
get
(
)
(
self
.
nanosecond
.
get
(
)
/
Nanosecond
:
:
per
(
Millisecond
)
)
as
u16
)
}
pub
const
fn
as_hms_micro
(
self
)
-
>
(
u8
u8
u8
u32
)
{
(
self
.
hour
.
get
(
)
self
.
minute
.
get
(
)
self
.
second
.
get
(
)
self
.
nanosecond
.
get
(
)
/
Nanosecond
:
:
per
(
Microsecond
)
as
u32
)
}
pub
const
fn
as_hms_nano
(
self
)
-
>
(
u8
u8
u8
u32
)
{
(
self
.
hour
.
get
(
)
self
.
minute
.
get
(
)
self
.
second
.
get
(
)
self
.
nanosecond
.
get
(
)
)
}
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
pub
(
crate
)
const
fn
as_hms_nano_ranged
(
self
)
-
>
(
Hours
Minutes
Seconds
Nanoseconds
)
{
(
self
.
hour
self
.
minute
self
.
second
self
.
nanosecond
)
}
pub
const
fn
hour
(
self
)
-
>
u8
{
self
.
hour
.
get
(
)
}
pub
const
fn
minute
(
self
)
-
>
u8
{
self
.
minute
.
get
(
)
}
pub
const
fn
second
(
self
)
-
>
u8
{
self
.
second
.
get
(
)
}
pub
const
fn
millisecond
(
self
)
-
>
u16
{
(
self
.
nanosecond
.
get
(
)
/
Nanosecond
:
:
per
(
Millisecond
)
)
as
_
}
pub
const
fn
microsecond
(
self
)
-
>
u32
{
self
.
nanosecond
.
get
(
)
/
Nanosecond
:
:
per
(
Microsecond
)
as
u32
}
pub
const
fn
nanosecond
(
self
)
-
>
u32
{
self
.
nanosecond
.
get
(
)
}
pub
(
crate
)
const
fn
adjusting_add
(
self
duration
:
Duration
)
-
>
(
DateAdjustment
Self
)
{
let
mut
nanoseconds
=
self
.
nanosecond
.
get
(
)
as
i32
+
duration
.
subsec_nanoseconds
(
)
;
let
mut
seconds
=
self
.
second
.
get
(
)
as
i8
+
(
duration
.
whole_seconds
(
)
%
Second
:
:
per
(
Minute
)
as
i64
)
as
i8
;
let
mut
minutes
=
self
.
minute
.
get
(
)
as
i8
+
(
duration
.
whole_minutes
(
)
%
Minute
:
:
per
(
Hour
)
as
i64
)
as
i8
;
let
mut
hours
=
self
.
hour
.
get
(
)
as
i8
+
(
duration
.
whole_hours
(
)
%
Hour
:
:
per
(
Day
)
as
i64
)
as
i8
;
let
mut
date_adjustment
=
DateAdjustment
:
:
None
;
cascade
!
(
nanoseconds
in
0
.
.
Nanosecond
:
:
per
(
Second
)
as
_
=
>
seconds
)
;
cascade
!
(
seconds
in
0
.
.
Second
:
:
per
(
Minute
)
as
_
=
>
minutes
)
;
cascade
!
(
minutes
in
0
.
.
Minute
:
:
per
(
Hour
)
as
_
=
>
hours
)
;
if
hours
>
=
Hour
:
:
per
(
Day
)
as
_
{
hours
-
=
Hour
:
:
per
(
Day
)
as
i8
;
date_adjustment
=
DateAdjustment
:
:
Next
;
}
else
if
hours
<
0
{
hours
+
=
Hour
:
:
per
(
Day
)
as
i8
;
date_adjustment
=
DateAdjustment
:
:
Previous
;
}
(
date_adjustment
unsafe
{
Self
:
:
__from_hms_nanos_unchecked
(
hours
as
_
minutes
as
_
seconds
as
_
nanoseconds
as
_
)
}
)
}
pub
(
crate
)
const
fn
adjusting_sub
(
self
duration
:
Duration
)
-
>
(
DateAdjustment
Self
)
{
let
mut
nanoseconds
=
self
.
nanosecond
.
get
(
)
as
i32
-
duration
.
subsec_nanoseconds
(
)
;
let
mut
seconds
=
self
.
second
.
get
(
)
as
i8
-
(
duration
.
whole_seconds
(
)
%
Second
:
:
per
(
Minute
)
as
i64
)
as
i8
;
let
mut
minutes
=
self
.
minute
.
get
(
)
as
i8
-
(
duration
.
whole_minutes
(
)
%
Minute
:
:
per
(
Hour
)
as
i64
)
as
i8
;
let
mut
hours
=
self
.
hour
.
get
(
)
as
i8
-
(
duration
.
whole_hours
(
)
%
Hour
:
:
per
(
Day
)
as
i64
)
as
i8
;
let
mut
date_adjustment
=
DateAdjustment
:
:
None
;
cascade
!
(
nanoseconds
in
0
.
.
Nanosecond
:
:
per
(
Second
)
as
_
=
>
seconds
)
;
cascade
!
(
seconds
in
0
.
.
Second
:
:
per
(
Minute
)
as
_
=
>
minutes
)
;
cascade
!
(
minutes
in
0
.
.
Minute
:
:
per
(
Hour
)
as
_
=
>
hours
)
;
if
hours
>
=
Hour
:
:
per
(
Day
)
as
_
{
hours
-
=
Hour
:
:
per
(
Day
)
as
i8
;
date_adjustment
=
DateAdjustment
:
:
Next
;
}
else
if
hours
<
0
{
hours
+
=
Hour
:
:
per
(
Day
)
as
i8
;
date_adjustment
=
DateAdjustment
:
:
Previous
;
}
(
date_adjustment
unsafe
{
Self
:
:
__from_hms_nanos_unchecked
(
hours
as
_
minutes
as
_
seconds
as
_
nanoseconds
as
_
)
}
)
}
pub
(
crate
)
const
fn
adjusting_add_std
(
self
duration
:
StdDuration
)
-
>
(
bool
Self
)
{
let
mut
nanosecond
=
self
.
nanosecond
.
get
(
)
+
duration
.
subsec_nanos
(
)
;
let
mut
second
=
self
.
second
.
get
(
)
+
(
duration
.
as_secs
(
)
%
Second
:
:
per
(
Minute
)
as
u64
)
as
u8
;
let
mut
minute
=
self
.
minute
.
get
(
)
+
(
(
duration
.
as_secs
(
)
/
Second
:
:
per
(
Minute
)
as
u64
)
%
Minute
:
:
per
(
Hour
)
as
u64
)
as
u8
;
let
mut
hour
=
self
.
hour
.
get
(
)
+
(
(
duration
.
as_secs
(
)
/
Second
:
:
per
(
Hour
)
as
u64
)
%
Hour
:
:
per
(
Day
)
as
u64
)
as
u8
;
let
mut
is_next_day
=
false
;
cascade
!
(
nanosecond
in
0
.
.
Nanosecond
:
:
per
(
Second
)
=
>
second
)
;
cascade
!
(
second
in
0
.
.
Second
:
:
per
(
Minute
)
=
>
minute
)
;
cascade
!
(
minute
in
0
.
.
Minute
:
:
per
(
Hour
)
=
>
hour
)
;
if
hour
>
=
Hour
:
:
per
(
Day
)
{
hour
-
=
Hour
:
:
per
(
Day
)
;
is_next_day
=
true
;
}
(
is_next_day
unsafe
{
Self
:
:
__from_hms_nanos_unchecked
(
hour
minute
second
nanosecond
)
}
)
}
pub
(
crate
)
const
fn
adjusting_sub_std
(
self
duration
:
StdDuration
)
-
>
(
bool
Self
)
{
let
mut
nanosecond
=
self
.
nanosecond
.
get
(
)
as
i32
-
duration
.
subsec_nanos
(
)
as
i32
;
let
mut
second
=
self
.
second
.
get
(
)
as
i8
-
(
duration
.
as_secs
(
)
%
Second
:
:
per
(
Minute
)
as
u64
)
as
i8
;
let
mut
minute
=
self
.
minute
.
get
(
)
as
i8
-
(
(
duration
.
as_secs
(
)
/
Second
:
:
per
(
Minute
)
as
u64
)
%
Minute
:
:
per
(
Hour
)
as
u64
)
as
i8
;
let
mut
hour
=
self
.
hour
.
get
(
)
as
i8
-
(
(
duration
.
as_secs
(
)
/
Second
:
:
per
(
Hour
)
as
u64
)
%
Hour
:
:
per
(
Day
)
as
u64
)
as
i8
;
let
mut
is_previous_day
=
false
;
cascade
!
(
nanosecond
in
0
.
.
Nanosecond
:
:
per
(
Second
)
as
_
=
>
second
)
;
cascade
!
(
second
in
0
.
.
Second
:
:
per
(
Minute
)
as
_
=
>
minute
)
;
cascade
!
(
minute
in
0
.
.
Minute
:
:
per
(
Hour
)
as
_
=
>
hour
)
;
if
hour
<
0
{
hour
+
=
Hour
:
:
per
(
Day
)
as
i8
;
is_previous_day
=
true
;
}
(
is_previous_day
unsafe
{
Self
:
:
__from_hms_nanos_unchecked
(
hour
as
_
minute
as
_
second
as
_
nanosecond
as
_
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Time
.
"
]
pub
const
fn
replace_hour
(
mut
self
hour
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
self
.
hour
=
ensure_ranged
!
(
Hours
:
hour
)
;
Ok
(
self
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Time
.
"
]
pub
const
fn
replace_minute
(
mut
self
minute
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
self
.
minute
=
ensure_ranged
!
(
Minutes
:
minute
)
;
Ok
(
self
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Time
.
"
]
pub
const
fn
replace_second
(
mut
self
second
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
self
.
second
=
ensure_ranged
!
(
Seconds
:
second
)
;
Ok
(
self
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Time
.
"
]
pub
const
fn
replace_millisecond
(
mut
self
millisecond
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
self
.
nanosecond
=
ensure_ranged
!
(
Nanoseconds
:
millisecond
as
u32
*
Nanosecond
:
:
per
(
Millisecond
)
)
;
Ok
(
self
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Time
.
"
]
pub
const
fn
replace_microsecond
(
mut
self
microsecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
self
.
nanosecond
=
ensure_ranged
!
(
Nanoseconds
:
microsecond
*
Nanosecond
:
:
per
(
Microsecond
)
as
u32
)
;
Ok
(
self
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
Time
.
"
]
pub
const
fn
replace_nanosecond
(
mut
self
nanosecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
self
.
nanosecond
=
ensure_ranged
!
(
Nanoseconds
:
nanosecond
)
;
Ok
(
self
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
Time
{
pub
fn
format_into
(
self
output
:
&
mut
impl
io
:
:
Write
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
None
Some
(
self
)
None
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
None
Some
(
self
)
None
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
Time
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_time
(
input
.
as_bytes
(
)
)
}
}
mod
private
{
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
TimeMetadata
{
pub
(
super
)
subsecond_width
:
u8
pub
(
super
)
subsecond_value
:
u32
}
}
use
private
:
:
TimeMetadata
;
impl
SmartDisplay
for
Time
{
type
Metadata
=
TimeMetadata
;
fn
metadata
(
&
self
_
:
FormatterOptions
)
-
>
Metadata
<
Self
>
{
let
(
subsecond_value
subsecond_width
)
=
match
self
.
nanosecond
(
)
{
nanos
if
nanos
%
10
!
=
0
=
>
(
nanos
9
)
nanos
if
(
nanos
/
10
)
%
10
!
=
0
=
>
(
nanos
/
10
8
)
nanos
if
(
nanos
/
100
)
%
10
!
=
0
=
>
(
nanos
/
100
7
)
nanos
if
(
nanos
/
1_000
)
%
10
!
=
0
=
>
(
nanos
/
1_000
6
)
nanos
if
(
nanos
/
10_000
)
%
10
!
=
0
=
>
(
nanos
/
10_000
5
)
nanos
if
(
nanos
/
100_000
)
%
10
!
=
0
=
>
(
nanos
/
100_000
4
)
nanos
if
(
nanos
/
1_000_000
)
%
10
!
=
0
=
>
(
nanos
/
1_000_000
3
)
nanos
if
(
nanos
/
10_000_000
)
%
10
!
=
0
=
>
(
nanos
/
10_000_000
2
)
nanos
=
>
(
nanos
/
100_000_000
1
)
}
;
let
formatted_width
=
smart_display
:
:
padded_width_of
!
(
self
.
hour
.
get
(
)
"
:
"
self
.
minute
.
get
(
)
=
>
width
(
2
)
fill
(
'
0
'
)
"
:
"
self
.
second
.
get
(
)
=
>
width
(
2
)
fill
(
'
0
'
)
"
.
"
)
+
subsecond_width
;
Metadata
:
:
new
(
formatted_width
self
TimeMetadata
{
subsecond_width
:
subsecond_width
.
truncate
(
)
subsecond_value
}
)
}
fn
fmt_with_metadata
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
metadata
:
Metadata
<
Self
>
)
-
>
fmt
:
:
Result
{
let
subsecond_width
=
metadata
.
subsecond_width
.
extend
(
)
;
let
subsecond_value
=
metadata
.
subsecond_value
;
f
.
pad_with_width
(
metadata
.
unpadded_width
(
)
format_args
!
(
"
{
}
:
{
:
02
}
:
{
:
02
}
.
{
subsecond_value
:
0subsecond_width
}
"
self
.
hour
self
.
minute
self
.
second
)
)
}
}
impl
fmt
:
:
Display
for
Time
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
SmartDisplay
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Debug
for
Time
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
Add
<
Duration
>
for
Time
{
type
Output
=
Self
;
fn
add
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
adjusting_add
(
duration
)
.
1
}
}
impl
Add
<
StdDuration
>
for
Time
{
type
Output
=
Self
;
fn
add
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
self
.
adjusting_add_std
(
duration
)
.
1
}
}
impl_add_assign
!
(
Time
:
Duration
StdDuration
)
;
impl
Sub
<
Duration
>
for
Time
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
adjusting_sub
(
duration
)
.
1
}
}
impl
Sub
<
StdDuration
>
for
Time
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
self
.
adjusting_sub_std
(
duration
)
.
1
}
}
impl_sub_assign
!
(
Time
:
Duration
StdDuration
)
;
impl
Sub
for
Time
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
let
hour_diff
=
self
.
hour
.
get
(
)
.
cast_signed
(
)
-
rhs
.
hour
.
get
(
)
.
cast_signed
(
)
;
let
minute_diff
=
self
.
minute
.
get
(
)
.
cast_signed
(
)
-
rhs
.
minute
.
get
(
)
.
cast_signed
(
)
;
let
second_diff
=
self
.
second
.
get
(
)
.
cast_signed
(
)
-
rhs
.
second
.
get
(
)
.
cast_signed
(
)
;
let
nanosecond_diff
=
self
.
nanosecond
.
get
(
)
.
cast_signed
(
)
-
rhs
.
nanosecond
.
get
(
)
.
cast_signed
(
)
;
let
seconds
=
hour_diff
.
extend
:
:
<
i64
>
(
)
*
Second
:
:
per
(
Hour
)
.
cast_signed
(
)
.
extend
:
:
<
i64
>
(
)
+
minute_diff
.
extend
:
:
<
i64
>
(
)
*
Second
:
:
per
(
Minute
)
.
cast_signed
(
)
.
extend
:
:
<
i64
>
(
)
+
second_diff
.
extend
:
:
<
i64
>
(
)
;
let
(
seconds
nanoseconds
)
=
if
seconds
>
0
&
&
nanosecond_diff
<
0
{
(
seconds
-
1
nanosecond_diff
+
Nanosecond
:
:
per
(
Second
)
.
cast_signed
(
)
)
}
else
if
seconds
<
0
&
&
nanosecond_diff
>
0
{
(
seconds
+
1
nanosecond_diff
-
Nanosecond
:
:
per
(
Second
)
.
cast_signed
(
)
)
}
else
{
(
seconds
nanosecond_diff
)
}
;
unsafe
{
Duration
:
:
new_unchecked
(
seconds
nanoseconds
)
}
}
}
