#
[
cfg
(
feature
=
"
formatting
"
)
]
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
use
core
:
:
ops
:
:
Neg
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
use
deranged
:
:
{
RangedI32
RangedI8
}
;
use
powerfmt
:
:
ext
:
:
FormatterExt
;
use
powerfmt
:
:
smart_display
:
:
{
self
FormatterOptions
Metadata
SmartDisplay
}
;
use
crate
:
:
convert
:
:
*
;
use
crate
:
:
error
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
use
crate
:
:
internal_macros
:
:
ensure_ranged
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
use
crate
:
:
sys
:
:
local_offset_at
;
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
use
crate
:
:
OffsetDateTime
;
type
Hours
=
RangedI8
<
-
25
25
>
;
type
Minutes
=
RangedI8
<
{
-
(
Minute
:
:
per
(
Hour
)
as
i8
-
1
)
}
{
Minute
:
:
per
(
Hour
)
as
i8
-
1
}
>
;
type
Seconds
=
RangedI8
<
{
-
(
Second
:
:
per
(
Minute
)
as
i8
-
1
)
}
{
Second
:
:
per
(
Minute
)
as
i8
-
1
}
>
;
type
WholeSeconds
=
RangedI32
<
{
Hours
:
:
MIN
.
get
(
)
as
i32
*
Second
:
:
per
(
Hour
)
as
i32
+
Minutes
:
:
MIN
.
get
(
)
as
i32
*
Second
:
:
per
(
Minute
)
as
i32
+
Seconds
:
:
MIN
.
get
(
)
as
i32
}
{
Hours
:
:
MAX
.
get
(
)
as
i32
*
Second
:
:
per
(
Hour
)
as
i32
+
Minutes
:
:
MAX
.
get
(
)
as
i32
*
Second
:
:
per
(
Minute
)
as
i32
+
Seconds
:
:
MAX
.
get
(
)
as
i32
}
>
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
UtcOffset
{
hours
:
Hours
minutes
:
Minutes
seconds
:
Seconds
}
impl
UtcOffset
{
pub
const
UTC
:
Self
=
Self
:
:
from_whole_seconds_ranged
(
WholeSeconds
:
:
new_static
:
:
<
0
>
(
)
)
;
#
[
doc
(
hidden
)
]
pub
const
unsafe
fn
__from_hms_unchecked
(
hours
:
i8
minutes
:
i8
seconds
:
i8
)
-
>
Self
{
unsafe
{
Self
:
:
from_hms_ranged_unchecked
(
Hours
:
:
new_unchecked
(
hours
)
Minutes
:
:
new_unchecked
(
minutes
)
Seconds
:
:
new_unchecked
(
seconds
)
)
}
}
pub
const
fn
from_hms
(
hours
:
i8
minutes
:
i8
seconds
:
i8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
:
:
from_hms_ranged
(
ensure_ranged
!
(
Hours
:
hours
)
ensure_ranged
!
(
Minutes
:
minutes
)
ensure_ranged
!
(
Seconds
:
seconds
)
)
)
}
pub
(
crate
)
const
fn
from_hms_ranged_unchecked
(
hours
:
Hours
minutes
:
Minutes
seconds
:
Seconds
)
-
>
Self
{
if
hours
.
get
(
)
<
0
{
debug_assert
!
(
minutes
.
get
(
)
<
=
0
)
;
debug_assert
!
(
seconds
.
get
(
)
<
=
0
)
;
}
else
if
hours
.
get
(
)
>
0
{
debug_assert
!
(
minutes
.
get
(
)
>
=
0
)
;
debug_assert
!
(
seconds
.
get
(
)
>
=
0
)
;
}
if
minutes
.
get
(
)
<
0
{
debug_assert
!
(
seconds
.
get
(
)
<
=
0
)
;
}
else
if
minutes
.
get
(
)
>
0
{
debug_assert
!
(
seconds
.
get
(
)
>
=
0
)
;
}
Self
{
hours
minutes
seconds
}
}
pub
(
crate
)
const
fn
from_hms_ranged
(
hours
:
Hours
mut
minutes
:
Minutes
mut
seconds
:
Seconds
)
-
>
Self
{
if
(
hours
.
get
(
)
>
0
&
&
minutes
.
get
(
)
<
0
)
|
|
(
hours
.
get
(
)
<
0
&
&
minutes
.
get
(
)
>
0
)
{
minutes
=
minutes
.
neg
(
)
;
}
if
(
hours
.
get
(
)
>
0
&
&
seconds
.
get
(
)
<
0
)
|
|
(
hours
.
get
(
)
<
0
&
&
seconds
.
get
(
)
>
0
)
|
|
(
minutes
.
get
(
)
>
0
&
&
seconds
.
get
(
)
<
0
)
|
|
(
minutes
.
get
(
)
<
0
&
&
seconds
.
get
(
)
>
0
)
{
seconds
=
seconds
.
neg
(
)
;
}
Self
{
hours
minutes
seconds
}
}
pub
const
fn
from_whole_seconds
(
seconds
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
:
:
from_whole_seconds_ranged
(
ensure_ranged
!
(
WholeSeconds
:
seconds
)
)
)
}
pub
(
crate
)
const
fn
from_whole_seconds_ranged
(
seconds
:
WholeSeconds
)
-
>
Self
{
unsafe
{
Self
:
:
__from_hms_unchecked
(
(
seconds
.
get
(
)
/
Second
:
:
per
(
Hour
)
as
i32
)
as
i8
(
(
seconds
.
get
(
)
%
Second
:
:
per
(
Hour
)
as
i32
)
/
Minute
:
:
per
(
Hour
)
as
i32
)
as
i8
(
seconds
.
get
(
)
%
Second
:
:
per
(
Minute
)
as
i32
)
as
i8
)
}
}
pub
const
fn
as_hms
(
self
)
-
>
(
i8
i8
i8
)
{
(
self
.
hours
.
get
(
)
self
.
minutes
.
get
(
)
self
.
seconds
.
get
(
)
)
}
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
pub
(
crate
)
const
fn
as_hms_ranged
(
self
)
-
>
(
Hours
Minutes
Seconds
)
{
(
self
.
hours
self
.
minutes
self
.
seconds
)
}
pub
const
fn
whole_hours
(
self
)
-
>
i8
{
self
.
hours
.
get
(
)
}
pub
const
fn
whole_minutes
(
self
)
-
>
i16
{
self
.
hours
.
get
(
)
as
i16
*
Minute
:
:
per
(
Hour
)
as
i16
+
self
.
minutes
.
get
(
)
as
i16
}
pub
const
fn
minutes_past_hour
(
self
)
-
>
i8
{
self
.
minutes
.
get
(
)
}
pub
const
fn
whole_seconds
(
self
)
-
>
i32
{
self
.
hours
.
get
(
)
as
i32
*
Second
:
:
per
(
Hour
)
as
i32
+
self
.
minutes
.
get
(
)
as
i32
*
Second
:
:
per
(
Minute
)
as
i32
+
self
.
seconds
.
get
(
)
as
i32
}
pub
const
fn
seconds_past_minute
(
self
)
-
>
i8
{
self
.
seconds
.
get
(
)
}
pub
const
fn
is_utc
(
self
)
-
>
bool
{
self
.
hours
.
get
(
)
=
=
0
&
&
self
.
minutes
.
get
(
)
=
=
0
&
&
self
.
seconds
.
get
(
)
=
=
0
}
pub
const
fn
is_positive
(
self
)
-
>
bool
{
self
.
hours
.
get
(
)
>
0
|
|
self
.
minutes
.
get
(
)
>
0
|
|
self
.
seconds
.
get
(
)
>
0
}
pub
const
fn
is_negative
(
self
)
-
>
bool
{
self
.
hours
.
get
(
)
<
0
|
|
self
.
minutes
.
get
(
)
<
0
|
|
self
.
seconds
.
get
(
)
<
0
}
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
pub
fn
local_offset_at
(
datetime
:
OffsetDateTime
)
-
>
Result
<
Self
error
:
:
IndeterminateOffset
>
{
local_offset_at
(
datetime
)
.
ok_or
(
error
:
:
IndeterminateOffset
)
}
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
pub
fn
current_local_offset
(
)
-
>
Result
<
Self
error
:
:
IndeterminateOffset
>
{
let
now
=
OffsetDateTime
:
:
now_utc
(
)
;
local_offset_at
(
now
)
.
ok_or
(
error
:
:
IndeterminateOffset
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
UtcOffset
{
pub
fn
format_into
(
self
output
:
&
mut
(
impl
io
:
:
Write
+
?
Sized
)
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
None
None
Some
(
self
)
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
None
None
Some
(
self
)
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
UtcOffset
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_offset
(
input
.
as_bytes
(
)
)
}
}
mod
private
{
#
[
non_exhaustive
]
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
UtcOffsetMetadata
;
}
use
private
:
:
UtcOffsetMetadata
;
impl
SmartDisplay
for
UtcOffset
{
type
Metadata
=
UtcOffsetMetadata
;
fn
metadata
(
&
self
_
:
FormatterOptions
)
-
>
Metadata
<
Self
>
{
let
sign
=
if
self
.
is_negative
(
)
{
'
-
'
}
else
{
'
+
'
}
;
let
width
=
smart_display
:
:
padded_width_of
!
(
sign
self
.
hours
.
abs
(
)
=
>
width
(
2
)
"
:
"
self
.
minutes
.
abs
(
)
=
>
width
(
2
)
"
:
"
self
.
seconds
.
abs
(
)
=
>
width
(
2
)
)
;
Metadata
:
:
new
(
width
self
UtcOffsetMetadata
)
}
fn
fmt_with_metadata
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
metadata
:
Metadata
<
Self
>
)
-
>
fmt
:
:
Result
{
f
.
pad_with_width
(
metadata
.
unpadded_width
(
)
format_args
!
(
"
{
}
{
:
02
}
:
{
:
02
}
:
{
:
02
}
"
if
self
.
is_negative
(
)
{
'
-
'
}
else
{
'
+
'
}
self
.
hours
.
abs
(
)
self
.
minutes
.
abs
(
)
self
.
seconds
.
abs
(
)
)
)
}
}
impl
fmt
:
:
Display
for
UtcOffset
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
SmartDisplay
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Debug
for
UtcOffset
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
Neg
for
UtcOffset
{
type
Output
=
Self
;
fn
neg
(
self
)
-
>
Self
:
:
Output
{
Self
:
:
from_hms_ranged
(
self
.
hours
.
neg
(
)
self
.
minutes
.
neg
(
)
self
.
seconds
.
neg
(
)
)
}
}
