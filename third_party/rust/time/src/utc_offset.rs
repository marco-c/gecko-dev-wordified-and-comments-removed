use
core
:
:
fmt
;
use
core
:
:
ops
:
:
Neg
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
use
crate
:
:
convert
:
:
*
;
use
crate
:
:
error
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
use
crate
:
:
sys
:
:
local_offset_at
;
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
use
crate
:
:
OffsetDateTime
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
UtcOffset
{
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
hours
:
i8
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
minutes
:
i8
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
seconds
:
i8
}
impl
UtcOffset
{
pub
const
UTC
:
Self
=
Self
:
:
__from_hms_unchecked
(
0
0
0
)
;
#
[
doc
(
hidden
)
]
pub
const
fn
__from_hms_unchecked
(
hours
:
i8
minutes
:
i8
seconds
:
i8
)
-
>
Self
{
if
hours
<
0
{
debug_assert
!
(
minutes
<
=
0
)
;
debug_assert
!
(
seconds
<
=
0
)
;
}
else
if
hours
>
0
{
debug_assert
!
(
minutes
>
=
0
)
;
debug_assert
!
(
seconds
>
=
0
)
;
}
if
minutes
<
0
{
debug_assert
!
(
seconds
<
=
0
)
;
}
else
if
minutes
>
0
{
debug_assert
!
(
seconds
>
=
0
)
;
}
debug_assert
!
(
hours
.
unsigned_abs
(
)
<
24
)
;
debug_assert
!
(
minutes
.
unsigned_abs
(
)
<
Minute
.
per
(
Hour
)
)
;
debug_assert
!
(
seconds
.
unsigned_abs
(
)
<
Second
.
per
(
Minute
)
)
;
Self
{
hours
minutes
seconds
}
}
pub
const
fn
from_hms
(
hours
:
i8
mut
minutes
:
i8
mut
seconds
:
i8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_value_in_range
!
(
hours
in
-
23
=
>
23
)
;
ensure_value_in_range
!
(
minutes
in
-
(
Minute
.
per
(
Hour
)
as
i8
-
1
)
=
>
Minute
.
per
(
Hour
)
as
i8
-
1
)
;
ensure_value_in_range
!
(
seconds
in
-
(
Second
.
per
(
Minute
)
as
i8
-
1
)
=
>
Second
.
per
(
Minute
)
as
i8
-
1
)
;
if
(
hours
>
0
&
&
minutes
<
0
)
|
|
(
hours
<
0
&
&
minutes
>
0
)
{
minutes
*
=
-
1
;
}
if
(
hours
>
0
&
&
seconds
<
0
)
|
|
(
hours
<
0
&
&
seconds
>
0
)
|
|
(
minutes
>
0
&
&
seconds
<
0
)
|
|
(
minutes
<
0
&
&
seconds
>
0
)
{
seconds
*
=
-
1
;
}
Ok
(
Self
:
:
__from_hms_unchecked
(
hours
minutes
seconds
)
)
}
pub
const
fn
from_whole_seconds
(
seconds
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
ensure_value_in_range
!
(
seconds
in
-
24
*
Second
.
per
(
Hour
)
as
i32
-
1
=
>
24
*
Second
.
per
(
Hour
)
as
i32
-
1
)
;
Ok
(
Self
:
:
__from_hms_unchecked
(
(
seconds
/
Second
.
per
(
Hour
)
as
i32
)
as
_
(
(
seconds
%
Second
.
per
(
Hour
)
as
i32
)
/
Minute
.
per
(
Hour
)
as
i32
)
as
_
(
seconds
%
Second
.
per
(
Minute
)
as
i32
)
as
_
)
)
}
pub
const
fn
as_hms
(
self
)
-
>
(
i8
i8
i8
)
{
(
self
.
hours
self
.
minutes
self
.
seconds
)
}
pub
const
fn
whole_hours
(
self
)
-
>
i8
{
self
.
hours
}
pub
const
fn
whole_minutes
(
self
)
-
>
i16
{
self
.
hours
as
i16
*
Minute
.
per
(
Hour
)
as
i16
+
self
.
minutes
as
i16
}
pub
const
fn
minutes_past_hour
(
self
)
-
>
i8
{
self
.
minutes
}
pub
const
fn
whole_seconds
(
self
)
-
>
i32
{
self
.
hours
as
i32
*
Second
.
per
(
Hour
)
as
i32
+
self
.
minutes
as
i32
*
Second
.
per
(
Minute
)
as
i32
+
self
.
seconds
as
i32
}
pub
const
fn
seconds_past_minute
(
self
)
-
>
i8
{
self
.
seconds
}
pub
const
fn
is_utc
(
self
)
-
>
bool
{
self
.
hours
=
=
0
&
&
self
.
minutes
=
=
0
&
&
self
.
seconds
=
=
0
}
pub
const
fn
is_positive
(
self
)
-
>
bool
{
self
.
hours
>
0
|
|
self
.
minutes
>
0
|
|
self
.
seconds
>
0
}
pub
const
fn
is_negative
(
self
)
-
>
bool
{
self
.
hours
<
0
|
|
self
.
minutes
<
0
|
|
self
.
seconds
<
0
}
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
pub
fn
local_offset_at
(
datetime
:
OffsetDateTime
)
-
>
Result
<
Self
error
:
:
IndeterminateOffset
>
{
local_offset_at
(
datetime
)
.
ok_or
(
error
:
:
IndeterminateOffset
)
}
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
pub
fn
current_local_offset
(
)
-
>
Result
<
Self
error
:
:
IndeterminateOffset
>
{
let
now
=
OffsetDateTime
:
:
now_utc
(
)
;
local_offset_at
(
now
)
.
ok_or
(
error
:
:
IndeterminateOffset
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
UtcOffset
{
pub
fn
format_into
(
self
output
:
&
mut
impl
io
:
:
Write
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
None
None
Some
(
self
)
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
None
None
Some
(
self
)
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
UtcOffset
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_offset
(
input
.
as_bytes
(
)
)
}
}
impl
fmt
:
:
Display
for
UtcOffset
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
:
02
}
:
{
:
02
}
:
{
:
02
}
"
if
self
.
is_negative
(
)
{
'
-
'
}
else
{
'
+
'
}
self
.
hours
.
abs
(
)
self
.
minutes
.
abs
(
)
self
.
seconds
.
abs
(
)
)
}
}
impl
fmt
:
:
Debug
for
UtcOffset
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
Neg
for
UtcOffset
{
type
Output
=
Self
;
fn
neg
(
self
)
-
>
Self
:
:
Output
{
Self
:
:
__from_hms_unchecked
(
-
self
.
hours
-
self
.
minutes
-
self
.
seconds
)
}
}
