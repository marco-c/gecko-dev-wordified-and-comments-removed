#
[
cfg
(
feature
=
"
formatting
"
)
]
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
;
use
core
:
:
ops
:
:
{
Add
AddAssign
Sub
SubAssign
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
use
powerfmt
:
:
ext
:
:
FormatterExt
as
_
;
use
powerfmt
:
:
smart_display
:
:
{
self
FormatterOptions
Metadata
SmartDisplay
}
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
use
crate
:
:
internal_macros
:
:
{
const_try
const_try_opt
}
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
use
crate
:
:
{
error
util
Date
Duration
Month
OffsetDateTime
Time
UtcDateTime
UtcOffset
Weekday
}
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
PrimitiveDateTime
{
date
:
Date
time
:
Time
}
impl
PrimitiveDateTime
{
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
/
/
Assuming
large
-
dates
feature
is
enabled
.
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
assert_eq
!
(
PrimitiveDateTime
:
:
MIN
datetime
!
(
-
999999
-
01
-
01
0
:
00
)
)
;
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
/
/
Assuming
large
-
dates
feature
is
disabled
.
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
assert_eq
!
(
PrimitiveDateTime
:
:
MIN
datetime
!
(
-
9999
-
01
-
01
0
:
00
)
)
;
"
)
]
pub
const
MIN
:
Self
=
Self
{
date
:
Date
:
:
MIN
time
:
Time
:
:
MIDNIGHT
}
;
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
/
/
Assuming
large
-
dates
feature
is
enabled
.
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
assert_eq
!
(
PrimitiveDateTime
:
:
MAX
datetime
!
(
+
999999
-
12
-
31
23
:
59
:
59
.
999_999_999
)
)
;
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
/
/
Assuming
large
-
dates
feature
is
disabled
.
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
assert_eq
!
(
PrimitiveDateTime
:
:
MAX
datetime
!
(
+
9999
-
12
-
31
23
:
59
:
59
.
999_999_999
)
)
;
"
)
]
pub
const
MAX
:
Self
=
Self
{
date
:
Date
:
:
MAX
time
:
Time
:
:
MAX
}
;
pub
const
fn
new
(
date
:
Date
time
:
Time
)
-
>
Self
{
Self
{
date
time
}
}
pub
const
fn
date
(
self
)
-
>
Date
{
self
.
date
}
pub
const
fn
time
(
self
)
-
>
Time
{
self
.
time
}
pub
const
fn
year
(
self
)
-
>
i32
{
self
.
date
(
)
.
year
(
)
}
pub
const
fn
month
(
self
)
-
>
Month
{
self
.
date
(
)
.
month
(
)
}
pub
const
fn
day
(
self
)
-
>
u8
{
self
.
date
(
)
.
day
(
)
}
pub
const
fn
ordinal
(
self
)
-
>
u16
{
self
.
date
(
)
.
ordinal
(
)
}
pub
const
fn
iso_week
(
self
)
-
>
u8
{
self
.
date
(
)
.
iso_week
(
)
}
pub
const
fn
sunday_based_week
(
self
)
-
>
u8
{
self
.
date
(
)
.
sunday_based_week
(
)
}
pub
const
fn
monday_based_week
(
self
)
-
>
u8
{
self
.
date
(
)
.
monday_based_week
(
)
}
pub
const
fn
to_calendar_date
(
self
)
-
>
(
i32
Month
u8
)
{
self
.
date
(
)
.
to_calendar_date
(
)
}
pub
const
fn
to_ordinal_date
(
self
)
-
>
(
i32
u16
)
{
self
.
date
(
)
.
to_ordinal_date
(
)
}
pub
const
fn
to_iso_week_date
(
self
)
-
>
(
i32
u8
Weekday
)
{
self
.
date
(
)
.
to_iso_week_date
(
)
}
pub
const
fn
weekday
(
self
)
-
>
Weekday
{
self
.
date
(
)
.
weekday
(
)
}
pub
const
fn
to_julian_day
(
self
)
-
>
i32
{
self
.
date
(
)
.
to_julian_day
(
)
}
pub
const
fn
as_hms
(
self
)
-
>
(
u8
u8
u8
)
{
self
.
time
(
)
.
as_hms
(
)
}
pub
const
fn
as_hms_milli
(
self
)
-
>
(
u8
u8
u8
u16
)
{
self
.
time
(
)
.
as_hms_milli
(
)
}
pub
const
fn
as_hms_micro
(
self
)
-
>
(
u8
u8
u8
u32
)
{
self
.
time
(
)
.
as_hms_micro
(
)
}
pub
const
fn
as_hms_nano
(
self
)
-
>
(
u8
u8
u8
u32
)
{
self
.
time
(
)
.
as_hms_nano
(
)
}
pub
const
fn
hour
(
self
)
-
>
u8
{
self
.
time
(
)
.
hour
(
)
}
pub
const
fn
minute
(
self
)
-
>
u8
{
self
.
time
(
)
.
minute
(
)
}
pub
const
fn
second
(
self
)
-
>
u8
{
self
.
time
(
)
.
second
(
)
}
pub
const
fn
millisecond
(
self
)
-
>
u16
{
self
.
time
(
)
.
millisecond
(
)
}
pub
const
fn
microsecond
(
self
)
-
>
u32
{
self
.
time
(
)
.
microsecond
(
)
}
pub
const
fn
nanosecond
(
self
)
-
>
u32
{
self
.
time
(
)
.
nanosecond
(
)
}
pub
const
fn
assume_offset
(
self
offset
:
UtcOffset
)
-
>
OffsetDateTime
{
OffsetDateTime
:
:
new_in_offset
(
self
.
date
self
.
time
offset
)
}
pub
const
fn
assume_utc
(
self
)
-
>
OffsetDateTime
{
self
.
assume_offset
(
UtcOffset
:
:
UTC
)
}
pub
const
fn
as_utc
(
self
)
-
>
UtcDateTime
{
UtcDateTime
:
:
from_primitive
(
self
)
}
pub
const
fn
checked_add
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
let
(
date_adjustment
time
)
=
self
.
time
.
adjusting_add
(
duration
)
;
let
date
=
const_try_opt
!
(
self
.
date
.
checked_add
(
duration
)
)
;
Some
(
Self
{
date
:
match
date_adjustment
{
util
:
:
DateAdjustment
:
:
Previous
=
>
const_try_opt
!
(
date
.
previous_day
(
)
)
util
:
:
DateAdjustment
:
:
Next
=
>
const_try_opt
!
(
date
.
next_day
(
)
)
util
:
:
DateAdjustment
:
:
None
=
>
date
}
time
}
)
}
pub
const
fn
checked_sub
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
let
(
date_adjustment
time
)
=
self
.
time
.
adjusting_sub
(
duration
)
;
let
date
=
const_try_opt
!
(
self
.
date
.
checked_sub
(
duration
)
)
;
Some
(
Self
{
date
:
match
date_adjustment
{
util
:
:
DateAdjustment
:
:
Previous
=
>
const_try_opt
!
(
date
.
previous_day
(
)
)
util
:
:
DateAdjustment
:
:
Next
=
>
const_try_opt
!
(
date
.
next_day
(
)
)
util
:
:
DateAdjustment
:
:
None
=
>
date
}
time
}
)
}
pub
const
fn
saturating_add
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_add
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
Self
:
:
MIN
}
else
{
Self
:
:
MAX
}
}
pub
const
fn
saturating_sub
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_sub
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
Self
:
:
MAX
}
else
{
Self
:
:
MIN
}
}
}
impl
PrimitiveDateTime
{
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_time
(
self
time
:
Time
)
-
>
Self
{
Self
{
date
:
self
.
date
time
}
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_date
(
self
date
:
Date
)
-
>
Self
{
Self
{
date
time
:
self
.
time
}
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_year
(
self
year
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
const_try
!
(
self
.
date
.
replace_year
(
year
)
)
time
:
self
.
time
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_month
(
self
month
:
Month
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
const_try
!
(
self
.
date
.
replace_month
(
month
)
)
time
:
self
.
time
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_day
(
self
day
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
const_try
!
(
self
.
date
.
replace_day
(
day
)
)
time
:
self
.
time
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_ordinal
(
self
ordinal
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
const_try
!
(
self
.
date
.
replace_ordinal
(
ordinal
)
)
time
:
self
.
time
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_hour
(
self
hour
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
self
.
date
time
:
const_try
!
(
self
.
time
.
replace_hour
(
hour
)
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_minute
(
self
minute
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
self
.
date
time
:
const_try
!
(
self
.
time
.
replace_minute
(
minute
)
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_second
(
self
second
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
self
.
date
time
:
const_try
!
(
self
.
time
.
replace_second
(
second
)
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_millisecond
(
self
millisecond
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
self
.
date
time
:
const_try
!
(
self
.
time
.
replace_millisecond
(
millisecond
)
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_microsecond
(
self
microsecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
self
.
date
time
:
const_try
!
(
self
.
time
.
replace_microsecond
(
microsecond
)
)
}
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
PrimitiveDateTime
.
"
]
pub
const
fn
replace_nanosecond
(
self
nanosecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
Self
{
date
:
self
.
date
time
:
const_try
!
(
self
.
time
.
replace_nanosecond
(
nanosecond
)
)
}
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
PrimitiveDateTime
{
pub
fn
format_into
(
self
output
:
&
mut
(
impl
io
:
:
Write
+
?
Sized
)
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
Some
(
self
.
date
)
Some
(
self
.
time
)
None
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
Some
(
self
.
date
)
Some
(
self
.
time
)
None
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
PrimitiveDateTime
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_primitive_date_time
(
input
.
as_bytes
(
)
)
}
}
impl
SmartDisplay
for
PrimitiveDateTime
{
type
Metadata
=
(
)
;
fn
metadata
(
&
self
_
:
FormatterOptions
)
-
>
Metadata
<
Self
>
{
let
width
=
smart_display
:
:
padded_width_of
!
(
self
.
date
"
"
self
.
time
)
;
Metadata
:
:
new
(
width
self
(
)
)
}
fn
fmt_with_metadata
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
metadata
:
Metadata
<
Self
>
)
-
>
fmt
:
:
Result
{
f
.
pad_with_width
(
metadata
.
unpadded_width
(
)
format_args
!
(
"
{
}
{
}
"
self
.
date
self
.
time
)
)
}
}
impl
fmt
:
:
Display
for
PrimitiveDateTime
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
SmartDisplay
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Debug
for
PrimitiveDateTime
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
Add
<
Duration
>
for
PrimitiveDateTime
{
type
Output
=
Self
;
fn
add
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
checked_add
(
duration
)
.
expect
(
"
resulting
value
is
out
of
range
"
)
}
}
impl
Add
<
StdDuration
>
for
PrimitiveDateTime
{
type
Output
=
Self
;
fn
add
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
let
(
is_next_day
time
)
=
self
.
time
.
adjusting_add_std
(
duration
)
;
Self
{
date
:
if
is_next_day
{
(
self
.
date
+
duration
)
.
next_day
(
)
.
expect
(
"
resulting
value
is
out
of
range
"
)
}
else
{
self
.
date
+
duration
}
time
}
}
}
impl
AddAssign
<
Duration
>
for
PrimitiveDateTime
{
fn
add_assign
(
&
mut
self
duration
:
Duration
)
{
*
self
=
*
self
+
duration
;
}
}
impl
AddAssign
<
StdDuration
>
for
PrimitiveDateTime
{
fn
add_assign
(
&
mut
self
duration
:
StdDuration
)
{
*
self
=
*
self
+
duration
;
}
}
impl
Sub
<
Duration
>
for
PrimitiveDateTime
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
self
.
checked_sub
(
duration
)
.
expect
(
"
resulting
value
is
out
of
range
"
)
}
}
impl
Sub
<
StdDuration
>
for
PrimitiveDateTime
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
StdDuration
)
-
>
Self
:
:
Output
{
let
(
is_previous_day
time
)
=
self
.
time
.
adjusting_sub_std
(
duration
)
;
Self
{
date
:
if
is_previous_day
{
(
self
.
date
-
duration
)
.
previous_day
(
)
.
expect
(
"
resulting
value
is
out
of
range
"
)
}
else
{
self
.
date
-
duration
}
time
}
}
}
impl
SubAssign
<
Duration
>
for
PrimitiveDateTime
{
fn
sub_assign
(
&
mut
self
duration
:
Duration
)
{
*
self
=
*
self
-
duration
;
}
}
impl
SubAssign
<
StdDuration
>
for
PrimitiveDateTime
{
fn
sub_assign
(
&
mut
self
duration
:
StdDuration
)
{
*
self
=
*
self
-
duration
;
}
}
impl
Sub
for
PrimitiveDateTime
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
(
self
.
date
-
rhs
.
date
)
+
(
self
.
time
-
rhs
.
time
)
}
}
