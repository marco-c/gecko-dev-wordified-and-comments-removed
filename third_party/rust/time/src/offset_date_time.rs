use
core
:
:
cmp
:
:
Ordering
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
core
:
:
convert
:
:
From
;
use
core
:
:
fmt
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
use
core
:
:
ops
:
:
{
Add
Sub
}
;
use
core
:
:
time
:
:
Duration
as
StdDuration
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
std
:
:
io
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
time
:
:
SystemTime
;
use
crate
:
:
date
:
:
{
MAX_YEAR
MIN_YEAR
}
;
#
[
cfg
(
feature
=
"
formatting
"
)
]
use
crate
:
:
formatting
:
:
Formattable
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
parsing
:
:
Parsable
;
#
[
cfg
(
feature
=
"
parsing
"
)
]
use
crate
:
:
util
;
use
crate
:
:
{
error
Date
Duration
Month
PrimitiveDateTime
Time
UtcOffset
Weekday
}
;
const
UNIX_EPOCH_JULIAN_DAY
:
i32
=
Date
:
:
__from_ordinal_date_unchecked
(
1970
1
)
.
to_julian_day
(
)
;
#
[
derive
(
Clone
Copy
Eq
)
]
pub
struct
OffsetDateTime
{
pub
(
crate
)
local_datetime
:
PrimitiveDateTime
pub
(
crate
)
offset
:
UtcOffset
}
impl
OffsetDateTime
{
pub
const
UNIX_EPOCH
:
Self
=
Date
:
:
__from_ordinal_date_unchecked
(
1970
1
)
.
midnight
(
)
.
assume_utc
(
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
now_utc
(
)
-
>
Self
{
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
wasi
"
)
)
feature
=
"
wasm
-
bindgen
"
)
)
]
{
js_sys
:
:
Date
:
:
new_0
(
)
.
into
(
)
}
#
[
cfg
(
not
(
all
(
target_arch
=
"
wasm32
"
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
wasi
"
)
)
feature
=
"
wasm
-
bindgen
"
)
)
)
]
SystemTime
:
:
now
(
)
.
into
(
)
}
#
[
cfg
(
feature
=
"
local
-
offset
"
)
]
pub
fn
now_local
(
)
-
>
Result
<
Self
error
:
:
IndeterminateOffset
>
{
let
t
=
Self
:
:
now_utc
(
)
;
Ok
(
t
.
to_offset
(
UtcOffset
:
:
local_offset_at
(
t
)
?
)
)
}
pub
const
fn
to_offset
(
self
offset
:
UtcOffset
)
-
>
Self
{
if
self
.
offset
.
whole_hours
(
)
=
=
offset
.
whole_hours
(
)
&
&
self
.
offset
.
minutes_past_hour
(
)
=
=
offset
.
minutes_past_hour
(
)
&
&
self
.
offset
.
seconds_past_minute
(
)
=
=
offset
.
seconds_past_minute
(
)
{
return
self
;
}
let
(
year
ordinal
time
)
=
self
.
to_offset_raw
(
offset
)
;
if
year
>
MAX_YEAR
|
|
year
<
MIN_YEAR
{
panic
!
(
"
local
datetime
out
of
valid
range
"
)
;
}
Date
:
:
__from_ordinal_date_unchecked
(
year
ordinal
)
.
with_time
(
time
)
.
assume_offset
(
offset
)
}
const
fn
to_offset_raw
(
self
offset
:
UtcOffset
)
-
>
(
i32
u16
Time
)
{
let
from
=
self
.
offset
;
let
to
=
offset
;
if
from
.
whole_hours
(
)
=
=
to
.
whole_hours
(
)
&
&
from
.
minutes_past_hour
(
)
=
=
to
.
minutes_past_hour
(
)
&
&
from
.
seconds_past_minute
(
)
=
=
to
.
seconds_past_minute
(
)
{
return
(
self
.
year
(
)
self
.
ordinal
(
)
self
.
time
(
)
)
;
}
let
mut
second
=
self
.
second
(
)
as
i16
-
from
.
seconds_past_minute
(
)
as
i16
+
to
.
seconds_past_minute
(
)
as
i16
;
let
mut
minute
=
self
.
minute
(
)
as
i16
-
from
.
minutes_past_hour
(
)
as
i16
+
to
.
minutes_past_hour
(
)
as
i16
;
let
mut
hour
=
self
.
hour
(
)
as
i8
-
from
.
whole_hours
(
)
+
to
.
whole_hours
(
)
;
let
(
mut
year
ordinal
)
=
self
.
to_ordinal_date
(
)
;
let
mut
ordinal
=
ordinal
as
i16
;
cascade
!
(
second
in
0
.
.
60
=
>
minute
)
;
cascade
!
(
second
in
0
.
.
60
=
>
minute
)
;
cascade
!
(
minute
in
0
.
.
60
=
>
hour
)
;
cascade
!
(
minute
in
0
.
.
60
=
>
hour
)
;
cascade
!
(
hour
in
0
.
.
24
=
>
ordinal
)
;
cascade
!
(
hour
in
0
.
.
24
=
>
ordinal
)
;
cascade
!
(
ordinal
=
>
year
)
;
debug_assert
!
(
ordinal
>
0
)
;
debug_assert
!
(
ordinal
<
=
crate
:
:
util
:
:
days_in_year
(
year
)
as
i16
)
;
(
year
ordinal
as
_
Time
:
:
__from_hms_nanos_unchecked
(
hour
as
_
minute
as
_
second
as
_
self
.
nanosecond
(
)
)
)
}
pub
const
fn
from_unix_timestamp
(
timestamp
:
i64
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
const
MIN_TIMESTAMP
:
i64
=
Date
:
:
MIN
.
midnight
(
)
.
assume_utc
(
)
.
unix_timestamp
(
)
;
#
[
allow
(
clippy
:
:
missing_docs_in_private_items
)
]
const
MAX_TIMESTAMP
:
i64
=
Date
:
:
MAX
.
with_time
(
Time
:
:
__from_hms_nanos_unchecked
(
23
59
59
999_999_999
)
)
.
assume_utc
(
)
.
unix_timestamp
(
)
;
ensure_value_in_range
!
(
timestamp
in
MIN_TIMESTAMP
=
>
MAX_TIMESTAMP
)
;
let
date
=
Date
:
:
from_julian_day_unchecked
(
UNIX_EPOCH_JULIAN_DAY
+
div_floor
!
(
timestamp
86_400
)
as
i32
)
;
let
seconds_within_day
=
timestamp
.
rem_euclid
(
86_400
)
;
let
time
=
Time
:
:
__from_hms_nanos_unchecked
(
(
seconds_within_day
/
3_600
)
as
_
(
(
seconds_within_day
%
3_600
)
/
60
)
as
_
(
seconds_within_day
%
60
)
as
_
0
)
;
Ok
(
PrimitiveDateTime
:
:
new
(
date
time
)
.
assume_utc
(
)
)
}
pub
const
fn
from_unix_timestamp_nanos
(
timestamp
:
i128
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
let
datetime
=
const_try
!
(
Self
:
:
from_unix_timestamp
(
div_floor
!
(
timestamp
1_000_000_000
)
as
i64
)
)
;
Ok
(
datetime
.
local_datetime
.
replace_time
(
Time
:
:
__from_hms_nanos_unchecked
(
datetime
.
local_datetime
.
hour
(
)
datetime
.
local_datetime
.
minute
(
)
datetime
.
local_datetime
.
second
(
)
timestamp
.
rem_euclid
(
1_000_000_000
)
as
u32
)
)
.
assume_utc
(
)
)
}
pub
const
fn
offset
(
self
)
-
>
UtcOffset
{
self
.
offset
}
pub
const
fn
unix_timestamp
(
self
)
-
>
i64
{
let
offset
=
self
.
offset
.
whole_seconds
(
)
as
i64
;
let
days
=
(
self
.
local_datetime
.
to_julian_day
(
)
as
i64
-
UNIX_EPOCH_JULIAN_DAY
as
i64
)
*
86_400
;
let
hours
=
self
.
local_datetime
.
hour
(
)
as
i64
*
3_600
;
let
minutes
=
self
.
local_datetime
.
minute
(
)
as
i64
*
60
;
let
seconds
=
self
.
local_datetime
.
second
(
)
as
i64
;
days
+
hours
+
minutes
+
seconds
-
offset
}
pub
const
fn
unix_timestamp_nanos
(
self
)
-
>
i128
{
self
.
unix_timestamp
(
)
as
i128
*
1_000_000_000
+
self
.
nanosecond
(
)
as
i128
}
pub
const
fn
date
(
self
)
-
>
Date
{
self
.
local_datetime
.
date
(
)
}
pub
const
fn
time
(
self
)
-
>
Time
{
self
.
local_datetime
.
time
(
)
}
pub
const
fn
year
(
self
)
-
>
i32
{
self
.
date
(
)
.
year
(
)
}
pub
const
fn
month
(
self
)
-
>
Month
{
self
.
date
(
)
.
month
(
)
}
pub
const
fn
day
(
self
)
-
>
u8
{
self
.
date
(
)
.
day
(
)
}
pub
const
fn
ordinal
(
self
)
-
>
u16
{
self
.
date
(
)
.
ordinal
(
)
}
pub
const
fn
iso_week
(
self
)
-
>
u8
{
self
.
date
(
)
.
iso_week
(
)
}
pub
const
fn
sunday_based_week
(
self
)
-
>
u8
{
self
.
date
(
)
.
sunday_based_week
(
)
}
pub
const
fn
monday_based_week
(
self
)
-
>
u8
{
self
.
date
(
)
.
monday_based_week
(
)
}
pub
const
fn
to_calendar_date
(
self
)
-
>
(
i32
Month
u8
)
{
self
.
date
(
)
.
to_calendar_date
(
)
}
pub
const
fn
to_ordinal_date
(
self
)
-
>
(
i32
u16
)
{
self
.
date
(
)
.
to_ordinal_date
(
)
}
pub
const
fn
to_iso_week_date
(
self
)
-
>
(
i32
u8
Weekday
)
{
self
.
date
(
)
.
to_iso_week_date
(
)
}
pub
const
fn
weekday
(
self
)
-
>
Weekday
{
self
.
date
(
)
.
weekday
(
)
}
pub
const
fn
to_julian_day
(
self
)
-
>
i32
{
self
.
date
(
)
.
to_julian_day
(
)
}
pub
const
fn
to_hms
(
self
)
-
>
(
u8
u8
u8
)
{
self
.
time
(
)
.
as_hms
(
)
}
pub
const
fn
to_hms_milli
(
self
)
-
>
(
u8
u8
u8
u16
)
{
self
.
time
(
)
.
as_hms_milli
(
)
}
pub
const
fn
to_hms_micro
(
self
)
-
>
(
u8
u8
u8
u32
)
{
self
.
time
(
)
.
as_hms_micro
(
)
}
pub
const
fn
to_hms_nano
(
self
)
-
>
(
u8
u8
u8
u32
)
{
self
.
time
(
)
.
as_hms_nano
(
)
}
pub
const
fn
hour
(
self
)
-
>
u8
{
self
.
time
(
)
.
hour
(
)
}
pub
const
fn
minute
(
self
)
-
>
u8
{
self
.
time
(
)
.
minute
(
)
}
pub
const
fn
second
(
self
)
-
>
u8
{
self
.
time
(
)
.
second
(
)
}
pub
const
fn
millisecond
(
self
)
-
>
u16
{
self
.
time
(
)
.
millisecond
(
)
}
pub
const
fn
microsecond
(
self
)
-
>
u32
{
self
.
time
(
)
.
microsecond
(
)
}
pub
const
fn
nanosecond
(
self
)
-
>
u32
{
self
.
time
(
)
.
nanosecond
(
)
}
pub
const
fn
checked_add
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
Some
(
const_try_opt
!
(
self
.
local_datetime
.
checked_add
(
duration
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
checked_sub
(
self
duration
:
Duration
)
-
>
Option
<
Self
>
{
Some
(
const_try_opt
!
(
self
.
local_datetime
.
checked_sub
(
duration
)
)
.
assume_offset
(
self
.
offset
)
)
}
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
-
999999
-
01
-
01
0
:
00
+
10
)
.
saturating_add
(
(
-
2
)
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
-
999999
-
01
-
01
0
:
00
+
10
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
-
9999
-
01
-
01
0
:
00
+
10
)
.
saturating_add
(
(
-
2
)
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
-
9999
-
01
-
01
0
:
00
+
10
)
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
+
999999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
.
saturating_add
(
2
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
+
999999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
+
9999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
.
saturating_add
(
2
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
+
9999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
"
)
]
pub
const
fn
saturating_add
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_add
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
PrimitiveDateTime
:
:
MIN
.
assume_offset
(
self
.
offset
)
}
else
{
debug_assert
!
(
duration
.
is_positive
(
)
)
;
PrimitiveDateTime
:
:
MAX
.
assume_offset
(
self
.
offset
)
}
}
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
-
999999
-
01
-
01
0
:
00
+
10
)
.
saturating_sub
(
2
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
-
999999
-
01
-
01
0
:
00
+
10
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
-
9999
-
01
-
01
0
:
00
+
10
)
.
saturating_sub
(
2
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
-
9999
-
01
-
01
0
:
00
+
10
)
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
+
999999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
.
saturating_sub
(
(
-
2
)
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
feature
=
"
large
-
dates
"
doc
=
"
datetime
!
(
+
999999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
+
9999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
.
saturating_sub
(
(
-
2
)
.
days
(
)
)
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
large
-
dates
"
)
doc
=
"
datetime
!
(
+
9999
-
12
-
31
23
:
59
:
59
.
999_999_999
+
10
)
"
)
]
pub
const
fn
saturating_sub
(
self
duration
:
Duration
)
-
>
Self
{
if
let
Some
(
datetime
)
=
self
.
checked_sub
(
duration
)
{
datetime
}
else
if
duration
.
is_negative
(
)
{
PrimitiveDateTime
:
:
MAX
.
assume_offset
(
self
.
offset
)
}
else
{
debug_assert
!
(
duration
.
is_positive
(
)
)
;
PrimitiveDateTime
:
:
MIN
.
assume_offset
(
self
.
offset
)
}
}
}
impl
OffsetDateTime
{
#
[
must_use
=
"
This
method
does
not
mutate
the
original
OffsetDateTime
.
"
]
pub
const
fn
replace_time
(
self
time
:
Time
)
-
>
Self
{
self
.
local_datetime
.
replace_time
(
time
)
.
assume_offset
(
self
.
offset
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
OffsetDateTime
.
"
]
pub
const
fn
replace_date
(
self
date
:
Date
)
-
>
Self
{
self
.
local_datetime
.
replace_date
(
date
)
.
assume_offset
(
self
.
offset
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
OffsetDateTime
.
"
]
pub
const
fn
replace_date_time
(
self
date_time
:
PrimitiveDateTime
)
-
>
Self
{
date_time
.
assume_offset
(
self
.
offset
)
}
#
[
must_use
=
"
This
method
does
not
mutate
the
original
OffsetDateTime
.
"
]
pub
const
fn
replace_offset
(
self
offset
:
UtcOffset
)
-
>
Self
{
self
.
local_datetime
.
assume_offset
(
offset
)
}
pub
const
fn
replace_year
(
self
year
:
i32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_year
(
year
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_month
(
self
month
:
Month
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_month
(
month
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_day
(
self
day
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_day
(
day
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_hour
(
self
hour
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_hour
(
hour
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_minute
(
self
minute
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_minute
(
minute
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_second
(
self
second
:
u8
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_second
(
second
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_millisecond
(
self
millisecond
:
u16
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_millisecond
(
millisecond
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_microsecond
(
self
microsecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_microsecond
(
microsecond
)
)
.
assume_offset
(
self
.
offset
)
)
}
pub
const
fn
replace_nanosecond
(
self
nanosecond
:
u32
)
-
>
Result
<
Self
error
:
:
ComponentRange
>
{
Ok
(
const_try
!
(
self
.
local_datetime
.
replace_nanosecond
(
nanosecond
)
)
.
assume_offset
(
self
.
offset
)
)
}
}
#
[
cfg
(
feature
=
"
formatting
"
)
]
impl
OffsetDateTime
{
pub
fn
format_into
(
self
output
:
&
mut
impl
io
:
:
Write
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
usize
error
:
:
Format
>
{
format
.
format_into
(
output
Some
(
self
.
date
(
)
)
Some
(
self
.
time
(
)
)
Some
(
self
.
offset
)
)
}
pub
fn
format
(
self
format
:
&
(
impl
Formattable
+
?
Sized
)
)
-
>
Result
<
String
error
:
:
Format
>
{
format
.
format
(
Some
(
self
.
date
(
)
)
Some
(
self
.
time
(
)
)
Some
(
self
.
offset
)
)
}
}
#
[
cfg
(
feature
=
"
parsing
"
)
]
impl
OffsetDateTime
{
pub
fn
parse
(
input
:
&
str
description
:
&
(
impl
Parsable
+
?
Sized
)
)
-
>
Result
<
Self
error
:
:
Parse
>
{
description
.
parse_offset_date_time
(
input
.
as_bytes
(
)
)
}
pub
(
crate
)
const
fn
is_valid_leap_second_stand_in
(
self
)
-
>
bool
{
if
self
.
nanosecond
(
)
!
=
999_999_999
{
return
false
;
}
let
(
year
ordinal
time
)
=
self
.
to_offset_raw
(
UtcOffset
:
:
UTC
)
;
let
date
=
match
Date
:
:
from_ordinal_date
(
year
ordinal
)
{
Ok
(
date
)
=
>
date
Err
(
_
)
=
>
return
false
}
;
time
.
hour
(
)
=
=
23
&
&
time
.
minute
(
)
=
=
59
&
&
time
.
second
(
)
=
=
59
&
&
date
.
day
(
)
=
=
util
:
:
days_in_year_month
(
year
date
.
month
(
)
)
}
}
impl
fmt
:
:
Display
for
OffsetDateTime
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
}
{
}
"
self
.
date
(
)
self
.
time
(
)
self
.
offset
)
}
}
impl
fmt
:
:
Debug
for
OffsetDateTime
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
PartialEq
for
OffsetDateTime
{
fn
eq
(
&
self
rhs
:
&
Self
)
-
>
bool
{
self
.
to_offset_raw
(
UtcOffset
:
:
UTC
)
=
=
rhs
.
to_offset_raw
(
UtcOffset
:
:
UTC
)
}
}
impl
PartialOrd
for
OffsetDateTime
{
fn
partial_cmp
(
&
self
rhs
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
rhs
)
)
}
}
impl
Ord
for
OffsetDateTime
{
fn
cmp
(
&
self
rhs
:
&
Self
)
-
>
Ordering
{
self
.
to_offset_raw
(
UtcOffset
:
:
UTC
)
.
cmp
(
&
rhs
.
to_offset_raw
(
UtcOffset
:
:
UTC
)
)
}
}
impl
Hash
for
OffsetDateTime
{
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
hasher
.
write
(
b
"
OffsetDateTime
"
)
;
self
.
to_offset_raw
(
UtcOffset
:
:
UTC
)
.
hash
(
hasher
)
;
}
}
impl
<
T
>
Add
<
T
>
for
OffsetDateTime
where
PrimitiveDateTime
:
Add
<
T
Output
=
PrimitiveDateTime
>
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
T
)
-
>
Self
:
:
Output
{
(
self
.
local_datetime
+
rhs
)
.
assume_offset
(
self
.
offset
)
}
}
impl_add_assign
!
(
OffsetDateTime
:
Duration
StdDuration
)
;
impl
<
T
>
Sub
<
T
>
for
OffsetDateTime
where
PrimitiveDateTime
:
Sub
<
T
Output
=
PrimitiveDateTime
>
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
T
)
-
>
Self
:
:
Output
{
(
self
.
local_datetime
-
rhs
)
.
assume_offset
(
self
.
offset
)
}
}
impl_sub_assign
!
(
OffsetDateTime
:
Duration
StdDuration
)
;
impl
Sub
for
OffsetDateTime
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
let
adjustment
=
Duration
:
:
seconds
(
(
self
.
offset
.
whole_seconds
(
)
-
rhs
.
offset
.
whole_seconds
(
)
)
as
i64
)
;
self
.
local_datetime
-
rhs
.
local_datetime
-
adjustment
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Add
<
Duration
>
for
SystemTime
{
type
Output
=
Self
;
fn
add
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
if
duration
.
is_zero
(
)
{
self
}
else
if
duration
.
is_positive
(
)
{
self
+
duration
.
unsigned_abs
(
)
}
else
{
debug_assert
!
(
duration
.
is_negative
(
)
)
;
self
-
duration
.
unsigned_abs
(
)
}
}
}
impl_add_assign
!
(
SystemTime
:
#
[
cfg
(
feature
=
"
std
"
)
]
Duration
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Sub
<
Duration
>
for
SystemTime
{
type
Output
=
Self
;
fn
sub
(
self
duration
:
Duration
)
-
>
Self
:
:
Output
{
(
OffsetDateTime
:
:
from
(
self
)
-
duration
)
.
into
(
)
}
}
impl_sub_assign
!
(
SystemTime
:
#
[
cfg
(
feature
=
"
std
"
)
]
Duration
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Sub
<
SystemTime
>
for
OffsetDateTime
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
SystemTime
)
-
>
Self
:
:
Output
{
self
-
Self
:
:
from
(
rhs
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Sub
<
OffsetDateTime
>
for
SystemTime
{
type
Output
=
Duration
;
fn
sub
(
self
rhs
:
OffsetDateTime
)
-
>
Self
:
:
Output
{
OffsetDateTime
:
:
from
(
self
)
-
rhs
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
PartialEq
<
SystemTime
>
for
OffsetDateTime
{
fn
eq
(
&
self
rhs
:
&
SystemTime
)
-
>
bool
{
self
=
=
&
Self
:
:
from
(
*
rhs
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
PartialEq
<
OffsetDateTime
>
for
SystemTime
{
fn
eq
(
&
self
rhs
:
&
OffsetDateTime
)
-
>
bool
{
&
OffsetDateTime
:
:
from
(
*
self
)
=
=
rhs
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
PartialOrd
<
SystemTime
>
for
OffsetDateTime
{
fn
partial_cmp
(
&
self
other
:
&
SystemTime
)
-
>
Option
<
Ordering
>
{
self
.
partial_cmp
(
&
Self
:
:
from
(
*
other
)
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
PartialOrd
<
OffsetDateTime
>
for
SystemTime
{
fn
partial_cmp
(
&
self
other
:
&
OffsetDateTime
)
-
>
Option
<
Ordering
>
{
OffsetDateTime
:
:
from
(
*
self
)
.
partial_cmp
(
other
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
From
<
SystemTime
>
for
OffsetDateTime
{
fn
from
(
system_time
:
SystemTime
)
-
>
Self
{
match
system_time
.
duration_since
(
SystemTime
:
:
UNIX_EPOCH
)
{
Ok
(
duration
)
=
>
Self
:
:
UNIX_EPOCH
+
duration
Err
(
err
)
=
>
Self
:
:
UNIX_EPOCH
-
err
.
duration
(
)
}
}
}
#
[
allow
(
clippy
:
:
fallible_impl_from
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
impl
From
<
OffsetDateTime
>
for
SystemTime
{
fn
from
(
datetime
:
OffsetDateTime
)
-
>
Self
{
let
duration
=
datetime
-
OffsetDateTime
:
:
UNIX_EPOCH
;
if
duration
.
is_zero
(
)
{
Self
:
:
UNIX_EPOCH
}
else
if
duration
.
is_positive
(
)
{
Self
:
:
UNIX_EPOCH
+
duration
.
unsigned_abs
(
)
}
else
{
debug_assert
!
(
duration
.
is_negative
(
)
)
;
Self
:
:
UNIX_EPOCH
-
duration
.
unsigned_abs
(
)
}
}
}
#
[
allow
(
clippy
:
:
fallible_impl_from
)
]
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
wasi
"
)
)
feature
=
"
wasm
-
bindgen
"
)
)
]
impl
From
<
js_sys
:
:
Date
>
for
OffsetDateTime
{
fn
from
(
js_date
:
js_sys
:
:
Date
)
-
>
Self
{
let
timestamp_nanos
=
(
js_date
.
get_time
(
)
*
1_000_000
.
0
)
as
i128
;
Self
:
:
from_unix_timestamp_nanos
(
timestamp_nanos
)
.
expect
(
"
invalid
timestamp
:
Timestamp
cannot
fit
in
range
"
)
}
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
any
(
target_os
=
"
emscripten
"
target_os
=
"
wasi
"
)
)
feature
=
"
wasm
-
bindgen
"
)
)
]
impl
From
<
OffsetDateTime
>
for
js_sys
:
:
Date
{
fn
from
(
datetime
:
OffsetDateTime
)
-
>
Self
{
let
timestamp
=
(
datetime
.
unix_timestamp_nanos
(
)
/
1_000_000
)
as
f64
;
js_sys
:
:
Date
:
:
new
(
&
timestamp
.
into
(
)
)
}
}
