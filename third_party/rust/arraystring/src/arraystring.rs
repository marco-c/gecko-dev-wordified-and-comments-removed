use
crate
:
:
utils
:
:
{
encode_char_utf8_unchecked
is_char_boundary
is_inside_boundary
never
}
;
use
crate
:
:
utils
:
:
{
shift_left_unchecked
shift_right_unchecked
truncate_str
IntoLossy
}
;
use
crate
:
:
{
error
:
:
Error
generic
:
:
ArraySlice
prelude
:
:
*
}
;
use
core
:
:
char
:
:
{
decode_utf16
REPLACEMENT_CHARACTER
}
;
use
core
:
:
str
:
:
{
from_utf8
from_utf8_unchecked
}
;
use
core
:
:
{
cmp
:
:
min
ops
:
:
*
ptr
:
:
copy_nonoverlapping
}
;
#
[
cfg
(
feature
=
"
logs
"
)
]
use
log
:
:
{
debug
trace
}
;
use
crate
:
:
generic
:
:
Capacity
;
#
[
derive
(
Clone
)
]
pub
struct
ArrayString
<
SIZE
:
Capacity
>
{
pub
(
crate
)
array
:
SIZE
:
:
Array
pub
(
crate
)
size
:
u8
}
impl
<
SIZE
:
Capacity
>
ArrayString
<
SIZE
>
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
trace
!
(
"
New
empty
ArrayString
"
)
;
Self
:
:
default
(
)
}
#
[
inline
]
pub
fn
try_from_str
<
S
>
(
s
:
S
)
-
>
Result
<
Self
OutOfBounds
>
where
S
:
AsRef
<
str
>
{
trace
!
(
"
Try
from
str
:
{
:
?
}
"
s
.
as_ref
(
)
)
;
is_inside_boundary
(
s
.
as_ref
(
)
.
len
(
)
Self
:
:
capacity
(
)
)
?
;
unsafe
{
Ok
(
Self
:
:
from_str_unchecked
(
s
.
as_ref
(
)
)
)
}
}
#
[
inline
]
pub
fn
from_str_truncate
<
S
>
(
string
:
S
)
-
>
Self
where
S
:
AsRef
<
str
>
{
trace
!
(
"
FromStr
truncate
"
)
;
unsafe
{
Self
:
:
from_str_unchecked
(
truncate_str
(
string
.
as_ref
(
)
Self
:
:
capacity
(
)
)
)
}
}
#
[
inline
]
pub
unsafe
fn
from_str_unchecked
<
S
>
(
string
:
S
)
-
>
Self
where
S
:
AsRef
<
str
>
{
trace
!
(
"
FromStr
unchecked
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
out
.
push_str_unchecked
(
string
)
;
out
}
#
[
inline
]
pub
fn
try_from_iterator
<
U
I
>
(
iter
:
I
)
-
>
Result
<
Self
OutOfBounds
>
where
U
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
U
>
{
trace
!
(
"
FromIterator
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
s
in
iter
{
out
.
try_push_str
(
s
)
?
;
}
Ok
(
out
)
}
#
[
inline
]
pub
fn
from_iterator
<
U
I
>
(
iter
:
I
)
-
>
Self
where
U
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
U
>
{
trace
!
(
"
FromIterator
truncate
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
s
in
iter
{
if
out
.
try_push_str
(
s
.
as_ref
(
)
)
.
is_err
(
)
{
out
.
push_str
(
s
)
;
break
;
}
}
out
}
#
[
inline
]
pub
unsafe
fn
from_iterator_unchecked
<
U
I
>
(
iter
:
I
)
-
>
Self
where
U
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
U
>
{
trace
!
(
"
FromIterator
unchecked
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
s
in
iter
{
out
.
push_str_unchecked
(
s
)
;
}
out
}
#
[
inline
]
pub
fn
try_from_chars
<
I
>
(
iter
:
I
)
-
>
Result
<
Self
OutOfBounds
>
where
I
:
IntoIterator
<
Item
=
char
>
{
trace
!
(
"
TryFrom
chars
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
c
in
iter
{
out
.
try_push
(
c
)
?
;
}
Ok
(
out
)
}
#
[
inline
]
pub
fn
from_chars
<
I
>
(
iter
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
char
>
{
trace
!
(
"
From
chars
truncate
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
c
in
iter
{
if
out
.
try_push
(
c
)
.
is_err
(
)
{
break
;
}
}
out
}
#
[
inline
]
pub
unsafe
fn
from_chars_unchecked
<
I
>
(
iter
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
char
>
{
trace
!
(
"
From
chars
unchecked
"
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
c
in
iter
{
out
.
push_unchecked
(
c
)
}
out
}
#
[
inline
]
pub
fn
try_from_utf8
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Error
>
where
B
:
AsRef
<
[
u8
]
>
{
debug
!
(
"
From
utf8
:
{
:
?
}
"
slice
.
as_ref
(
)
)
;
Ok
(
Self
:
:
try_from_str
(
from_utf8
(
slice
.
as_ref
(
)
)
?
)
?
)
}
#
[
inline
]
pub
fn
from_utf8
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Utf8
>
where
B
:
AsRef
<
[
u8
]
>
{
debug
!
(
"
From
utf8
:
{
:
?
}
"
slice
.
as_ref
(
)
)
;
Ok
(
Self
:
:
from_str_truncate
(
from_utf8
(
slice
.
as_ref
(
)
)
?
)
)
}
#
[
inline
]
pub
unsafe
fn
from_utf8_unchecked
<
B
>
(
slice
:
B
)
-
>
Self
where
B
:
AsRef
<
[
u8
]
>
{
trace
!
(
"
From
utf8
unchecked
"
)
;
debug_assert
!
(
from_utf8
(
slice
.
as_ref
(
)
)
.
is_ok
(
)
)
;
Self
:
:
from_str_unchecked
(
from_utf8_unchecked
(
slice
.
as_ref
(
)
)
)
}
#
[
inline
]
pub
fn
try_from_utf16
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Error
>
where
B
:
AsRef
<
[
u16
]
>
{
debug
!
(
"
From
utf16
:
{
:
?
}
"
slice
.
as_ref
(
)
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
c
in
decode_utf16
(
slice
.
as_ref
(
)
.
iter
(
)
.
cloned
(
)
)
{
out
.
try_push
(
c
?
)
?
;
}
Ok
(
out
)
}
#
[
inline
]
pub
fn
from_utf16
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Utf16
>
where
B
:
AsRef
<
[
u16
]
>
{
debug
!
(
"
From
utf16
:
{
:
?
}
"
slice
.
as_ref
(
)
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
c
in
decode_utf16
(
slice
.
as_ref
(
)
.
iter
(
)
.
cloned
(
)
)
{
if
out
.
try_push
(
c
?
)
.
is_err
(
)
{
break
;
}
}
Ok
(
out
)
}
#
[
inline
]
pub
fn
from_utf16_lossy
<
B
>
(
slice
:
B
)
-
>
Self
where
B
:
AsRef
<
[
u16
]
>
{
debug
!
(
"
From
utf16
lossy
:
{
:
?
}
"
slice
.
as_ref
(
)
)
;
let
mut
out
=
Self
:
:
default
(
)
;
for
c
in
decode_utf16
(
slice
.
as_ref
(
)
.
iter
(
)
.
cloned
(
)
)
{
if
out
.
try_push
(
c
.
unwrap_or
(
REPLACEMENT_CHARACTER
)
)
.
is_err
(
)
{
break
;
}
}
out
}
#
[
inline
]
pub
fn
as_str
(
&
self
)
-
>
&
str
{
trace
!
(
"
As
str
:
{
}
"
<
Self
as
AsRef
<
str
>
>
:
:
as_ref
(
self
)
)
;
self
.
as_ref
(
)
}
#
[
inline
]
pub
fn
as_mut_str
(
&
mut
self
)
-
>
&
mut
str
{
trace
!
(
"
As
mut
str
:
{
}
"
self
.
as_mut
(
)
)
;
self
.
as_mut
(
)
}
#
[
inline
]
pub
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
trace
!
(
"
As
str
:
{
}
"
self
.
as_str
(
)
)
;
self
.
as_ref
(
)
}
#
[
inline
]
pub
unsafe
fn
as_mut_bytes
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
trace
!
(
"
As
mut
str
:
{
}
"
self
.
as_str
(
)
)
;
let
len
=
self
.
len
(
)
;
self
.
array
.
as_mut_slice
(
)
.
get_unchecked_mut
(
.
.
len
.
into
(
)
)
}
#
[
inline
]
pub
fn
capacity
(
)
-
>
u8
{
SIZE
:
:
to_u8
(
)
}
#
[
inline
]
pub
fn
try_push_str
<
S
>
(
&
mut
self
string
:
S
)
-
>
Result
<
(
)
OutOfBounds
>
where
S
:
AsRef
<
str
>
{
trace
!
(
"
Push
str
"
)
;
let
new_end
=
string
.
as_ref
(
)
.
len
(
)
.
saturating_add
(
self
.
len
(
)
.
into
(
)
)
;
is_inside_boundary
(
new_end
Self
:
:
capacity
(
)
)
?
;
unsafe
{
self
.
push_str_unchecked
(
string
)
}
;
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
push_str
<
S
>
(
&
mut
self
string
:
S
)
where
S
:
AsRef
<
str
>
{
trace
!
(
"
Push
str
truncate
"
)
;
let
size
=
Self
:
:
capacity
(
)
.
saturating_sub
(
self
.
len
(
)
)
;
unsafe
{
self
.
push_str_unchecked
(
truncate_str
(
string
.
as_ref
(
)
size
)
)
}
}
#
[
inline
]
pub
unsafe
fn
push_str_unchecked
<
S
>
(
&
mut
self
string
:
S
)
where
S
:
AsRef
<
str
>
{
let
(
s
len
)
=
(
string
.
as_ref
(
)
string
.
as_ref
(
)
.
len
(
)
)
;
debug
!
(
"
Push
str
unchecked
:
{
}
(
{
}
+
{
}
)
"
s
self
.
len
(
)
len
)
;
debug_assert
!
(
len
.
saturating_add
(
self
.
len
(
)
.
into
(
)
)
<
=
Self
:
:
capacity
(
)
as
usize
)
;
let
dest
=
self
.
as_mut_bytes
(
)
.
as_mut_ptr
(
)
.
add
(
self
.
len
(
)
.
into
(
)
)
;
copy_nonoverlapping
(
s
.
as_ptr
(
)
dest
len
)
;
self
.
size
=
self
.
size
.
saturating_add
(
len
.
into_lossy
(
)
)
;
}
#
[
inline
]
pub
fn
try_push
(
&
mut
self
character
:
char
)
-
>
Result
<
(
)
OutOfBounds
>
{
trace
!
(
"
Push
:
{
}
"
character
)
;
let
new_end
=
character
.
len_utf8
(
)
.
saturating_add
(
self
.
len
(
)
.
into
(
)
)
;
is_inside_boundary
(
new_end
Self
:
:
capacity
(
)
)
?
;
unsafe
{
self
.
push_unchecked
(
character
)
}
;
Ok
(
(
)
)
}
#
[
inline
]
pub
unsafe
fn
push_unchecked
(
&
mut
self
ch
:
char
)
{
let
(
len
chlen
)
=
(
self
.
len
(
)
ch
.
len_utf8
(
)
.
into_lossy
(
)
)
;
debug
!
(
"
Push
unchecked
(
len
:
{
}
)
:
{
}
(
len
:
{
}
)
"
len
ch
chlen
)
;
encode_char_utf8_unchecked
(
self
ch
len
)
;
self
.
size
=
self
.
size
.
saturating_add
(
chlen
)
;
}
#
[
inline
]
pub
fn
truncate
(
&
mut
self
size
:
u8
)
-
>
Result
<
(
)
Utf8
>
{
debug
!
(
"
Truncate
:
{
}
"
size
)
;
let
len
=
min
(
self
.
len
(
)
size
)
;
is_char_boundary
(
self
len
)
.
map
(
|
(
)
|
self
.
size
=
len
)
}
#
[
inline
]
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
char
>
{
debug
!
(
"
Pop
"
)
;
self
.
as_str
(
)
.
chars
(
)
.
last
(
)
.
map
(
|
ch
|
{
self
.
size
=
self
.
size
.
saturating_sub
(
ch
.
len_utf8
(
)
.
into_lossy
(
)
)
;
ch
}
)
}
#
[
inline
]
pub
fn
trim
(
&
mut
self
)
{
trace
!
(
"
Trim
"
)
;
let
is_whitespace
=
|
s
:
&
[
u8
]
index
:
usize
|
{
debug_assert
!
(
index
<
s
.
len
(
)
)
;
unsafe
{
s
.
get_unchecked
(
index
)
=
=
&
b
'
'
}
}
;
let
(
mut
start
mut
end
mut
leave
)
=
(
0_u8
self
.
len
(
)
0_u8
)
;
while
start
<
end
&
&
leave
<
2
{
leave
=
0
;
if
is_whitespace
(
self
.
as_bytes
(
)
start
.
into
(
)
)
{
start
=
start
.
saturating_add
(
1
)
;
if
start
>
=
end
{
continue
;
}
;
}
else
{
leave
=
leave
.
saturating_add
(
1
)
;
}
if
start
<
end
&
&
is_whitespace
(
self
.
as_bytes
(
)
end
.
saturating_sub
(
1
)
.
into
(
)
)
{
end
=
end
.
saturating_sub
(
1
)
;
}
else
{
leave
=
leave
.
saturating_add
(
1
)
;
}
}
unsafe
{
shift_left_unchecked
(
self
start
0u8
)
}
;
self
.
size
=
end
.
saturating_sub
(
start
)
;
}
#
[
inline
]
pub
fn
remove
(
&
mut
self
idx
:
u8
)
-
>
Result
<
char
Error
>
{
debug
!
(
"
Remove
:
{
}
"
idx
)
;
is_inside_boundary
(
idx
self
.
len
(
)
.
saturating_sub
(
1
)
)
?
;
is_char_boundary
(
self
idx
)
?
;
debug_assert
!
(
idx
<
self
.
len
(
)
&
&
self
.
as_str
(
)
.
is_char_boundary
(
idx
.
into
(
)
)
)
;
let
ch
=
unsafe
{
self
.
as_str
(
)
.
get_unchecked
(
idx
.
into
(
)
.
.
)
.
chars
(
)
.
next
(
)
}
;
let
ch
=
ch
.
unwrap_or_else
(
|
|
unsafe
{
never
(
"
Missing
char
"
)
}
)
;
unsafe
{
shift_left_unchecked
(
self
idx
.
saturating_add
(
ch
.
len_utf8
(
)
.
into_lossy
(
)
)
idx
)
}
;
self
.
size
=
self
.
size
.
saturating_sub
(
ch
.
len_utf8
(
)
.
into_lossy
(
)
)
;
Ok
(
ch
)
}
#
[
inline
]
pub
fn
retain
<
F
:
FnMut
(
char
)
-
>
bool
>
(
&
mut
self
mut
f
:
F
)
{
trace
!
(
"
Retain
"
)
;
*
self
=
unsafe
{
Self
:
:
from_chars_unchecked
(
self
.
as_str
(
)
.
chars
(
)
.
filter
(
|
c
|
f
(
*
c
)
)
)
}
;
}
#
[
inline
]
pub
fn
try_insert
(
&
mut
self
idx
:
u8
ch
:
char
)
-
>
Result
<
(
)
Error
>
{
trace
!
(
"
Insert
{
}
to
{
}
"
ch
idx
)
;
is_inside_boundary
(
idx
self
.
len
(
)
)
?
;
let
new_end
=
ch
.
len_utf8
(
)
.
saturating_add
(
self
.
len
(
)
.
into
(
)
)
;
is_inside_boundary
(
new_end
Self
:
:
capacity
(
)
)
?
;
is_char_boundary
(
self
idx
)
?
;
unsafe
{
self
.
insert_unchecked
(
idx
ch
)
}
;
Ok
(
(
)
)
}
#
[
inline
]
pub
unsafe
fn
insert_unchecked
(
&
mut
self
idx
:
u8
ch
:
char
)
{
let
clen
=
ch
.
len_utf8
(
)
.
into_lossy
(
)
;
debug
!
(
"
Insert
uncheck
(
{
}
+
{
}
)
{
}
at
{
}
"
self
.
len
(
)
clen
ch
idx
)
;
shift_right_unchecked
(
self
idx
idx
.
saturating_add
(
clen
)
)
;
encode_char_utf8_unchecked
(
self
ch
idx
)
;
self
.
size
=
self
.
size
.
saturating_add
(
clen
)
;
}
#
[
inline
]
pub
fn
try_insert_str
<
S
>
(
&
mut
self
idx
:
u8
s
:
S
)
-
>
Result
<
(
)
Error
>
where
S
:
AsRef
<
str
>
{
trace
!
(
"
Try
insert
str
"
)
;
is_inside_boundary
(
idx
self
.
len
(
)
)
?
;
let
new_end
=
s
.
as_ref
(
)
.
len
(
)
.
saturating_add
(
self
.
len
(
)
.
into
(
)
)
;
is_inside_boundary
(
new_end
Self
:
:
capacity
(
)
)
?
;
is_char_boundary
(
self
idx
)
?
;
unsafe
{
self
.
insert_str_unchecked
(
idx
s
.
as_ref
(
)
)
}
;
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
insert_str
<
S
>
(
&
mut
self
idx
:
u8
string
:
S
)
-
>
Result
<
(
)
Error
>
where
S
:
AsRef
<
str
>
{
trace
!
(
"
Insert
str
"
)
;
is_inside_boundary
(
idx
self
.
len
(
)
)
?
;
is_char_boundary
(
self
idx
)
?
;
let
size
=
Self
:
:
capacity
(
)
.
saturating_sub
(
self
.
len
(
)
)
;
unsafe
{
self
.
insert_str_unchecked
(
idx
truncate_str
(
string
.
as_ref
(
)
size
)
)
}
;
Ok
(
(
)
)
}
#
[
inline
]
pub
unsafe
fn
insert_str_unchecked
<
S
>
(
&
mut
self
idx
:
u8
string
:
S
)
where
S
:
AsRef
<
str
>
{
let
(
s
slen
)
=
(
string
.
as_ref
(
)
string
.
as_ref
(
)
.
len
(
)
.
into_lossy
(
)
)
;
let
ptr
=
s
.
as_ptr
(
)
;
trace
!
(
"
InsertStr
uncheck
{
}
+
{
}
{
}
at
{
}
"
self
.
len
(
)
slen
s
idx
)
;
debug_assert
!
(
self
.
len
(
)
.
saturating_add
(
slen
)
<
=
Self
:
:
capacity
(
)
)
;
debug_assert
!
(
idx
<
=
self
.
len
(
)
)
;
debug_assert
!
(
self
.
as_str
(
)
.
is_char_boundary
(
idx
.
into
(
)
)
)
;
shift_right_unchecked
(
self
idx
idx
.
saturating_add
(
slen
)
)
;
let
dest
=
self
.
as_mut_bytes
(
)
.
as_mut_ptr
(
)
.
add
(
idx
.
into
(
)
)
;
copy_nonoverlapping
(
ptr
dest
slen
.
into
(
)
)
;
self
.
size
=
self
.
size
.
saturating_add
(
slen
)
;
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
u8
{
trace
!
(
"
Len
"
)
;
self
.
size
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
trace
!
(
"
Is
empty
"
)
;
self
.
len
(
)
=
=
0
}
#
[
inline
]
pub
fn
split_off
(
&
mut
self
at
:
u8
)
-
>
Result
<
Self
Error
>
{
debug
!
(
"
Split
off
"
)
;
is_inside_boundary
(
at
self
.
len
(
)
)
?
;
is_char_boundary
(
self
at
)
?
;
debug_assert
!
(
at
<
=
self
.
len
(
)
&
&
self
.
as_str
(
)
.
is_char_boundary
(
at
.
into
(
)
)
)
;
let
new
=
unsafe
{
Self
:
:
from_utf8_unchecked
(
self
.
as_str
(
)
.
get_unchecked
(
at
.
into
(
)
.
.
)
)
}
;
self
.
size
=
at
;
Ok
(
new
)
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
trace
!
(
"
Clear
"
)
;
self
.
size
=
0
;
}
#
[
inline
]
pub
fn
drain
<
R
>
(
&
mut
self
range
:
R
)
-
>
Result
<
Drain
<
SIZE
>
Error
>
where
R
:
RangeBounds
<
u8
>
{
let
start
=
match
range
.
start_bound
(
)
{
Bound
:
:
Included
(
t
)
=
>
*
t
Bound
:
:
Excluded
(
t
)
=
>
t
.
saturating_add
(
1
)
Bound
:
:
Unbounded
=
>
0
}
;
let
end
=
match
range
.
end_bound
(
)
{
Bound
:
:
Included
(
t
)
=
>
t
.
saturating_add
(
1
)
Bound
:
:
Excluded
(
t
)
=
>
*
t
Bound
:
:
Unbounded
=
>
self
.
len
(
)
}
;
debug
!
(
"
Drain
iterator
(
len
:
{
}
)
:
{
}
.
.
{
}
"
self
.
len
(
)
start
end
)
;
is_inside_boundary
(
start
end
)
?
;
is_inside_boundary
(
end
self
.
len
(
)
)
?
;
is_char_boundary
(
self
start
)
?
;
is_char_boundary
(
self
end
)
?
;
debug_assert
!
(
start
<
=
end
&
&
end
<
=
self
.
len
(
)
)
;
debug_assert
!
(
self
.
as_str
(
)
.
is_char_boundary
(
start
.
into
(
)
)
)
;
debug_assert
!
(
self
.
as_str
(
)
.
is_char_boundary
(
end
.
into
(
)
)
)
;
let
drain
=
unsafe
{
let
slice
=
self
.
as_str
(
)
.
get_unchecked
(
start
.
into
(
)
.
.
end
.
into
(
)
)
;
Self
:
:
from_str_unchecked
(
slice
)
}
;
unsafe
{
shift_left_unchecked
(
self
end
start
)
}
;
self
.
size
=
self
.
size
.
saturating_sub
(
end
.
saturating_sub
(
start
)
)
;
Ok
(
Drain
(
drain
0
)
)
}
#
[
inline
]
pub
fn
replace_range
<
S
R
>
(
&
mut
self
r
:
R
with
:
S
)
-
>
Result
<
(
)
Error
>
where
S
:
AsRef
<
str
>
R
:
RangeBounds
<
u8
>
{
let
replace_with
=
with
.
as_ref
(
)
;
let
start
=
match
r
.
start_bound
(
)
{
Bound
:
:
Included
(
t
)
=
>
*
t
Bound
:
:
Excluded
(
t
)
=
>
t
.
saturating_add
(
1
)
Bound
:
:
Unbounded
=
>
0
}
;
let
end
=
match
r
.
end_bound
(
)
{
Bound
:
:
Included
(
t
)
=
>
t
.
saturating_add
(
1
)
Bound
:
:
Excluded
(
t
)
=
>
*
t
Bound
:
:
Unbounded
=
>
self
.
len
(
)
}
;
let
len
=
replace_with
.
len
(
)
.
into_lossy
(
)
;
debug
!
(
"
Replace
range
(
len
:
{
}
)
(
{
}
.
.
{
}
)
with
(
len
:
{
}
)
{
}
"
self
.
len
(
)
start
end
len
replace_with
)
;
is_inside_boundary
(
start
end
)
?
;
is_inside_boundary
(
end
self
.
len
(
)
)
?
;
let
replaced
=
(
end
as
usize
)
.
saturating_sub
(
start
.
into
(
)
)
;
is_inside_boundary
(
replaced
.
saturating_add
(
len
.
into
(
)
)
Self
:
:
capacity
(
)
)
?
;
is_char_boundary
(
self
start
)
?
;
is_char_boundary
(
self
end
)
?
;
debug_assert
!
(
start
<
=
end
&
&
end
<
=
self
.
len
(
)
)
;
debug_assert
!
(
len
.
saturating_sub
(
end
)
.
saturating_add
(
start
)
<
=
Self
:
:
capacity
(
)
)
;
debug_assert
!
(
self
.
as_str
(
)
.
is_char_boundary
(
start
.
into
(
)
)
)
;
debug_assert
!
(
self
.
as_str
(
)
.
is_char_boundary
(
end
.
into
(
)
)
)
;
if
start
.
saturating_add
(
len
)
>
end
{
unsafe
{
shift_right_unchecked
(
self
end
start
.
saturating_add
(
len
)
)
}
;
}
else
{
unsafe
{
shift_left_unchecked
(
self
end
start
.
saturating_add
(
len
)
)
}
;
}
let
grow
=
len
.
saturating_sub
(
replaced
.
into_lossy
(
)
)
;
self
.
size
=
self
.
size
.
saturating_add
(
grow
)
;
let
ptr
=
replace_with
.
as_ptr
(
)
;
let
dest
=
unsafe
{
self
.
as_mut_bytes
(
)
.
as_mut_ptr
(
)
.
add
(
start
.
into
(
)
)
}
;
unsafe
{
copy_nonoverlapping
(
ptr
dest
len
.
into
(
)
)
}
;
Ok
(
(
)
)
}
}
