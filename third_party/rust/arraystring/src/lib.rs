#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
arraystring
/
0
.
3
.
0
/
arraystring
"
)
]
#
!
[
cfg_attr
(
docs_rs_workaround
feature
(
doc_cfg
)
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
warn
(
missing_docs
missing_debug_implementations
trivial_numeric_casts
unused_extern_crates
unused_import_braces
unused_qualifications
unused_results
bad_style
const_err
dead_code
improper_ctypes
legacy_directory_ownership
non_shorthand_field_patterns
no_mangle_generic_items
overflowing_literals
path_statements
patterns_in_fns_without_body
plugin_as_library
private_in_public
safe_extern_statics
unconditional_recursion
unions_with_drop_fields
unused_allocation
unused_comparisons
unused_parens
while_true
)
]
#
!
[
doc
(
test
(
attr
(
deny
(
warnings
)
)
)
)
]
pub
use
typenum
;
#
[
macro_use
]
#
[
cfg
(
not
(
feature
=
"
logs
"
)
)
]
#
[
allow
(
unused
)
]
mod
mock
{
macro_rules
!
trace
(
(
(
x
:
tt
)
*
)
=
>
(
)
)
;
macro_rules
!
debug
(
(
(
x
:
tt
)
*
)
=
>
(
)
)
;
macro_rules
!
info
(
(
(
x
:
tt
)
*
)
=
>
(
)
)
;
macro_rules
!
warn
(
(
(
x
:
tt
)
*
)
=
>
(
)
)
;
macro_rules
!
error
(
(
(
x
:
tt
)
*
)
=
>
(
)
)
;
}
#
[
cfg
(
all
(
feature
=
"
diesel
-
traits
"
test
)
)
]
#
[
macro_use
]
extern
crate
diesel
;
mod
arraystring
;
pub
mod
drain
;
pub
mod
error
;
mod
generic
;
mod
implementations
;
#
[
cfg
(
any
(
feature
=
"
serde
-
traits
"
feature
=
"
diesel
-
traits
"
)
)
]
mod
integration
;
#
[
doc
(
hidden
)
]
pub
mod
utils
;
pub
mod
prelude
{
pub
use
crate
:
:
arraystring
:
:
ArrayString
;
pub
use
crate
:
:
drain
:
:
Drain
;
pub
use
crate
:
:
error
:
:
{
OutOfBounds
Utf16
Utf8
}
;
pub
use
crate
:
:
{
generic
:
:
Capacity
CacheString
MaxString
SmallString
}
;
}
pub
use
crate
:
:
arraystring
:
:
ArrayString
;
pub
use
crate
:
:
error
:
:
Error
;
use
crate
:
:
prelude
:
:
*
;
use
core
:
:
fmt
:
:
{
self
Debug
Display
Formatter
Write
}
;
use
core
:
:
{
borrow
:
:
Borrow
borrow
:
:
BorrowMut
ops
:
:
*
}
;
use
core
:
:
{
cmp
:
:
Ordering
hash
:
:
Hash
hash
:
:
Hasher
str
:
:
FromStr
}
;
#
[
cfg
(
feature
=
"
logs
"
)
]
use
log
:
:
trace
;
use
typenum
:
:
{
Unsigned
U255
U63
}
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
use
typenum
:
:
U23
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
use
typenum
:
:
U11
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
pub
type
SmallString
=
ArrayString
<
U23
>
;
#
[
cfg
(
not
(
target_pointer_width
=
"
64
"
)
)
]
pub
type
SmallString
=
ArrayString
<
U11
>
;
pub
type
MaxString
=
ArrayString
<
U255
>
;
#
[
repr
(
align
(
64
)
)
]
#
[
derive
(
Copy
Clone
Default
)
]
pub
struct
CacheString
(
pub
ArrayString
<
U63
>
)
;
impl
CacheString
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
trace
!
(
"
New
empty
CacheString
"
)
;
Self
:
:
default
(
)
}
#
[
inline
]
pub
fn
try_from_str
<
S
>
(
s
:
S
)
-
>
Result
<
Self
OutOfBounds
>
where
S
:
AsRef
<
str
>
{
Ok
(
CacheString
(
ArrayString
:
:
try_from_str
(
s
)
?
)
)
}
#
[
inline
]
pub
fn
from_str_truncate
<
S
>
(
string
:
S
)
-
>
Self
where
S
:
AsRef
<
str
>
{
CacheString
(
ArrayString
:
:
from_str_truncate
(
string
)
)
}
#
[
inline
]
pub
unsafe
fn
from_str_unchecked
<
S
>
(
string
:
S
)
-
>
Self
where
S
:
AsRef
<
str
>
{
CacheString
(
ArrayString
:
:
from_str_unchecked
(
string
)
)
}
#
[
inline
]
pub
fn
try_from_iterator
<
U
I
>
(
iter
:
I
)
-
>
Result
<
Self
OutOfBounds
>
where
U
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
U
>
{
Ok
(
CacheString
(
ArrayString
:
:
try_from_iterator
(
iter
)
?
)
)
}
#
[
inline
]
pub
fn
from_iterator
<
U
I
>
(
iter
:
I
)
-
>
Self
where
U
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
U
>
{
CacheString
(
ArrayString
:
:
from_iterator
(
iter
)
)
}
#
[
inline
]
pub
unsafe
fn
from_iterator_unchecked
<
U
I
>
(
iter
:
I
)
-
>
Self
where
U
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
U
>
{
CacheString
(
ArrayString
:
:
from_iterator_unchecked
(
iter
)
)
}
#
[
inline
]
pub
fn
try_from_chars
<
I
>
(
iter
:
I
)
-
>
Result
<
Self
OutOfBounds
>
where
I
:
IntoIterator
<
Item
=
char
>
{
Ok
(
CacheString
(
ArrayString
:
:
try_from_chars
(
iter
)
?
)
)
}
#
[
inline
]
pub
fn
from_chars
<
I
>
(
iter
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
char
>
{
CacheString
(
ArrayString
:
:
from_chars
(
iter
)
)
}
#
[
inline
]
pub
unsafe
fn
from_chars_unchecked
<
I
>
(
iter
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
char
>
{
CacheString
(
ArrayString
:
:
from_chars_unchecked
(
iter
)
)
}
#
[
inline
]
pub
fn
try_from_utf8
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Error
>
where
B
:
AsRef
<
[
u8
]
>
{
Ok
(
CacheString
(
ArrayString
:
:
try_from_utf8
(
slice
)
?
)
)
}
#
[
inline
]
pub
fn
from_utf8
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Utf8
>
where
B
:
AsRef
<
[
u8
]
>
{
Ok
(
CacheString
(
ArrayString
:
:
from_utf8
(
slice
)
?
)
)
}
#
[
inline
]
pub
unsafe
fn
from_utf8_unchecked
<
B
>
(
slice
:
B
)
-
>
Self
where
B
:
AsRef
<
[
u8
]
>
{
CacheString
(
ArrayString
:
:
from_utf8_unchecked
(
slice
)
)
}
#
[
inline
]
pub
fn
try_from_utf16
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Error
>
where
B
:
AsRef
<
[
u16
]
>
{
Ok
(
CacheString
(
ArrayString
:
:
try_from_utf16
(
slice
)
?
)
)
}
#
[
inline
]
pub
fn
from_utf16
<
B
>
(
slice
:
B
)
-
>
Result
<
Self
Utf16
>
where
B
:
AsRef
<
[
u16
]
>
{
Ok
(
CacheString
(
ArrayString
:
:
from_utf16
(
slice
)
?
)
)
}
#
[
inline
]
pub
fn
from_utf16_lossy
<
B
>
(
slice
:
B
)
-
>
Self
where
B
:
AsRef
<
[
u16
]
>
{
CacheString
(
ArrayString
:
:
from_utf16_lossy
(
slice
)
)
}
#
[
inline
]
pub
fn
capacity
(
)
-
>
u8
{
<
U63
as
Unsigned
>
:
:
to_u8
(
)
}
#
[
inline
]
pub
fn
split_off
(
&
mut
self
at
:
u8
)
-
>
Result
<
Self
Error
>
{
Ok
(
CacheString
(
self
.
0
.
split_off
(
at
)
?
)
)
}
}
impl
Debug
for
CacheString
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
CacheString
"
)
.
field
(
&
self
.
0
)
.
finish
(
)
}
}
impl
Hash
for
CacheString
{
#
[
inline
]
fn
hash
<
H
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
self
.
0
.
hash
(
hasher
)
;
}
}
impl
PartialEq
for
CacheString
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
0
.
eq
(
&
other
.
0
)
}
}
impl
Eq
for
CacheString
{
}
impl
Ord
for
CacheString
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
self
.
0
.
cmp
(
&
other
.
0
)
}
}
impl
PartialOrd
for
CacheString
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Deref
for
CacheString
{
type
Target
=
ArrayString
<
U63
>
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
CacheString
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
ArrayString
<
U63
>
{
&
mut
self
.
0
}
}
impl
Display
for
CacheString
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
0
f
)
}
}
impl
AsRef
<
str
>
for
CacheString
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
str
{
self
.
0
.
as_ref
(
)
}
}
impl
AsMut
<
str
>
for
CacheString
{
#
[
inline
]
fn
as_mut
(
&
mut
self
)
-
>
&
mut
str
{
self
.
0
.
as_mut
(
)
}
}
impl
AsRef
<
[
u8
]
>
for
CacheString
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
self
.
0
.
as_ref
(
)
}
}
impl
FromStr
for
CacheString
{
type
Err
=
OutOfBounds
;
#
[
inline
]
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Ok
(
CacheString
(
ArrayString
:
:
try_from_str
(
s
)
?
)
)
}
}
impl
<
'
a
'
b
>
PartialEq
<
str
>
for
CacheString
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
self
.
0
.
eq
(
other
)
}
}
impl
Borrow
<
str
>
for
CacheString
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
str
{
self
.
0
.
borrow
(
)
}
}
impl
BorrowMut
<
str
>
for
CacheString
{
#
[
inline
]
fn
borrow_mut
(
&
mut
self
)
-
>
&
mut
str
{
self
.
0
.
borrow_mut
(
)
}
}
impl
<
'
a
>
Add
<
&
'
a
str
>
for
CacheString
{
type
Output
=
Self
;
#
[
inline
]
fn
add
(
self
other
:
&
str
)
-
>
Self
:
:
Output
{
CacheString
(
self
.
0
.
add
(
other
)
)
}
}
impl
Write
for
CacheString
{
#
[
inline
]
fn
write_str
(
&
mut
self
slice
:
&
str
)
-
>
fmt
:
:
Result
{
self
.
0
.
write_str
(
slice
)
}
}
impl
From
<
ArrayString
<
U63
>
>
for
CacheString
{
fn
from
(
array
:
ArrayString
<
U63
>
)
-
>
Self
{
CacheString
(
array
)
}
}
