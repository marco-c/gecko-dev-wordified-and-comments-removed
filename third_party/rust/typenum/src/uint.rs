use
core
:
:
ops
:
:
{
Add
BitAnd
BitOr
BitXor
Mul
Shl
Shr
Sub
}
;
use
core
:
:
marker
:
:
PhantomData
;
use
{
Cmp
Equal
Greater
Len
Less
NonZero
Ord
Pow
}
;
use
bit
:
:
{
B0
B1
Bit
}
;
use
private
:
:
{
BitDiff
PrivateAnd
PrivateCmp
PrivatePow
PrivateSub
PrivateXor
Trim
}
;
use
private
:
:
{
BitDiffOut
PrivateAndOut
PrivateCmpOut
PrivatePowOut
PrivateSubOut
PrivateXorOut
TrimOut
}
;
use
consts
:
:
{
U0
U1
}
;
use
{
Add1
Length
Or
Prod
Shleft
Shright
Square
Sub1
Sum
}
;
pub
use
marker_traits
:
:
{
PowerOfTwo
Unsigned
}
;
#
[
derive
(
Eq
PartialEq
Ord
PartialOrd
Clone
Copy
Hash
Debug
Default
)
]
pub
struct
UTerm
;
impl
UTerm
{
#
[
inline
]
pub
fn
new
(
)
-
>
UTerm
{
UTerm
}
}
impl
Unsigned
for
UTerm
{
const
U8
:
u8
=
0
;
const
U16
:
u16
=
0
;
const
U32
:
u32
=
0
;
const
U64
:
u64
=
0
;
#
[
cfg
(
feature
=
"
i128
"
)
]
const
U128
:
u128
=
0
;
const
USIZE
:
usize
=
0
;
const
I8
:
i8
=
0
;
const
I16
:
i16
=
0
;
const
I32
:
i32
=
0
;
const
I64
:
i64
=
0
;
#
[
cfg
(
feature
=
"
i128
"
)
]
const
I128
:
i128
=
0
;
const
ISIZE
:
isize
=
0
;
#
[
inline
]
fn
to_u8
(
)
-
>
u8
{
0
}
#
[
inline
]
fn
to_u16
(
)
-
>
u16
{
0
}
#
[
inline
]
fn
to_u32
(
)
-
>
u32
{
0
}
#
[
inline
]
fn
to_u64
(
)
-
>
u64
{
0
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
to_u128
(
)
-
>
u128
{
0
}
#
[
inline
]
fn
to_usize
(
)
-
>
usize
{
0
}
#
[
inline
]
fn
to_i8
(
)
-
>
i8
{
0
}
#
[
inline
]
fn
to_i16
(
)
-
>
i16
{
0
}
#
[
inline
]
fn
to_i32
(
)
-
>
i32
{
0
}
#
[
inline
]
fn
to_i64
(
)
-
>
i64
{
0
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
to_i128
(
)
-
>
i128
{
0
}
#
[
inline
]
fn
to_isize
(
)
-
>
isize
{
0
}
}
#
[
derive
(
Eq
PartialEq
Ord
PartialOrd
Clone
Copy
Hash
Debug
Default
)
]
pub
struct
UInt
<
U
B
>
{
_marker
:
PhantomData
<
(
U
B
)
>
}
impl
<
U
:
Unsigned
B
:
Bit
>
UInt
<
U
B
>
{
#
[
inline
]
pub
fn
new
(
)
-
>
UInt
<
U
B
>
{
UInt
{
_marker
:
PhantomData
}
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Unsigned
for
UInt
<
U
B
>
{
const
U8
:
u8
=
B
:
:
U8
|
U
:
:
U8
<
<
1
;
const
U16
:
u16
=
B
:
:
U8
as
u16
|
U
:
:
U16
<
<
1
;
const
U32
:
u32
=
B
:
:
U8
as
u32
|
U
:
:
U32
<
<
1
;
const
U64
:
u64
=
B
:
:
U8
as
u64
|
U
:
:
U64
<
<
1
;
#
[
cfg
(
feature
=
"
i128
"
)
]
const
U128
:
u128
=
B
:
:
U8
as
u128
|
U
:
:
U128
<
<
1
;
const
USIZE
:
usize
=
B
:
:
U8
as
usize
|
U
:
:
USIZE
<
<
1
;
const
I8
:
i8
=
B
:
:
U8
as
i8
|
U
:
:
I8
<
<
1
;
const
I16
:
i16
=
B
:
:
U8
as
i16
|
U
:
:
I16
<
<
1
;
const
I32
:
i32
=
B
:
:
U8
as
i32
|
U
:
:
I32
<
<
1
;
const
I64
:
i64
=
B
:
:
U8
as
i64
|
U
:
:
I64
<
<
1
;
#
[
cfg
(
feature
=
"
i128
"
)
]
const
I128
:
i128
=
B
:
:
U8
as
i128
|
U
:
:
I128
<
<
1
;
const
ISIZE
:
isize
=
B
:
:
U8
as
isize
|
U
:
:
ISIZE
<
<
1
;
#
[
inline
]
fn
to_u8
(
)
-
>
u8
{
B
:
:
to_u8
(
)
|
U
:
:
to_u8
(
)
<
<
1
}
#
[
inline
]
fn
to_u16
(
)
-
>
u16
{
u16
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_u16
(
)
<
<
1
}
#
[
inline
]
fn
to_u32
(
)
-
>
u32
{
u32
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_u32
(
)
<
<
1
}
#
[
inline
]
fn
to_u64
(
)
-
>
u64
{
u64
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_u64
(
)
<
<
1
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
to_u128
(
)
-
>
u128
{
u128
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_u128
(
)
<
<
1
}
#
[
inline
]
fn
to_usize
(
)
-
>
usize
{
usize
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_usize
(
)
<
<
1
}
#
[
inline
]
fn
to_i8
(
)
-
>
i8
{
B
:
:
to_u8
(
)
as
i8
|
U
:
:
to_i8
(
)
<
<
1
}
#
[
inline
]
fn
to_i16
(
)
-
>
i16
{
i16
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_i16
(
)
<
<
1
}
#
[
inline
]
fn
to_i32
(
)
-
>
i32
{
i32
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_i32
(
)
<
<
1
}
#
[
inline
]
fn
to_i64
(
)
-
>
i64
{
i64
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_i64
(
)
<
<
1
}
#
[
cfg
(
feature
=
"
i128
"
)
]
#
[
inline
]
fn
to_i128
(
)
-
>
i128
{
i128
:
:
from
(
B
:
:
to_u8
(
)
)
|
U
:
:
to_i128
(
)
<
<
1
}
#
[
inline
]
fn
to_isize
(
)
-
>
isize
{
B
:
:
to_u8
(
)
as
isize
|
U
:
:
to_isize
(
)
<
<
1
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
NonZero
for
UInt
<
U
B
>
{
}
impl
PowerOfTwo
for
UInt
<
UTerm
B1
>
{
}
impl
<
U
:
Unsigned
+
PowerOfTwo
>
PowerOfTwo
for
UInt
<
U
B0
>
{
}
impl
Len
for
UTerm
{
type
Output
=
U0
;
fn
len
(
&
self
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Len
for
UInt
<
U
B
>
where
U
:
Len
Length
<
U
>
:
Add
<
B1
>
Add1
<
Length
<
U
>
>
:
Unsigned
{
type
Output
=
Add1
<
Length
<
U
>
>
;
fn
len
(
&
self
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
Add
<
B0
>
for
UTerm
{
type
Output
=
UTerm
;
fn
add
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Add
<
B0
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
add
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
Add
<
B1
>
for
UTerm
{
type
Output
=
UInt
<
UTerm
B1
>
;
fn
add
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
>
Add
<
B1
>
for
UInt
<
U
B0
>
{
type
Output
=
UInt
<
U
B1
>
;
fn
add
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
>
Add
<
B1
>
for
UInt
<
U
B1
>
where
U
:
Add
<
B1
>
Add1
<
U
>
:
Unsigned
{
type
Output
=
UInt
<
Add1
<
U
>
B0
>
;
fn
add
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
>
Add
<
U
>
for
UTerm
{
type
Output
=
U
;
fn
add
(
self
_
:
U
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Add
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
add
(
self
_
:
UTerm
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Add
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
Add
<
Ur
>
{
type
Output
=
UInt
<
Sum
<
Ul
Ur
>
B0
>
;
fn
add
(
self
_
:
UInt
<
Ur
B0
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Add
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
Add
<
Ur
>
{
type
Output
=
UInt
<
Sum
<
Ul
Ur
>
B1
>
;
fn
add
(
self
_
:
UInt
<
Ur
B1
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Add
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
Add
<
Ur
>
{
type
Output
=
UInt
<
Sum
<
Ul
Ur
>
B1
>
;
fn
add
(
self
_
:
UInt
<
Ur
B0
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Add
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
Add
<
Ur
>
Sum
<
Ul
Ur
>
:
Add
<
B1
>
{
type
Output
=
UInt
<
Add1
<
Sum
<
Ul
Ur
>
>
B0
>
;
fn
add
(
self
_
:
UInt
<
Ur
B1
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
Sub
<
B0
>
for
UTerm
{
type
Output
=
UTerm
;
fn
sub
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Sub
<
B0
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
sub
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Sub
<
B1
>
for
UInt
<
UInt
<
U
B
>
B1
>
{
type
Output
=
UInt
<
UInt
<
U
B
>
B0
>
;
fn
sub
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
Sub
<
B1
>
for
UInt
<
UTerm
B1
>
{
type
Output
=
UTerm
;
fn
sub
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
>
Sub
<
B1
>
for
UInt
<
U
B0
>
where
U
:
Sub
<
B1
>
Sub1
<
U
>
:
Unsigned
{
type
Output
=
UInt
<
Sub1
<
U
>
B1
>
;
fn
sub
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
Sub
<
UTerm
>
for
UTerm
{
type
Output
=
UTerm
;
fn
sub
(
self
_
:
UTerm
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
>
Sub
<
Ur
>
for
UInt
<
Ul
Bl
>
where
UInt
<
Ul
Bl
>
:
PrivateSub
<
Ur
>
PrivateSubOut
<
UInt
<
Ul
Bl
>
Ur
>
:
Trim
{
type
Output
=
TrimOut
<
PrivateSubOut
<
UInt
<
Ul
Bl
>
Ur
>
>
;
fn
sub
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
>
PrivateSub
<
UTerm
>
for
U
{
type
Output
=
U
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateSub
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateSub
<
Ur
>
{
type
Output
=
UInt
<
PrivateSubOut
<
Ul
Ur
>
B0
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateSub
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateSub
<
Ur
>
PrivateSubOut
<
Ul
Ur
>
:
Sub
<
B1
>
{
type
Output
=
UInt
<
Sub1
<
PrivateSubOut
<
Ul
Ur
>
>
B1
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateSub
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateSub
<
Ur
>
{
type
Output
=
UInt
<
PrivateSubOut
<
Ul
Ur
>
B1
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateSub
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateSub
<
Ur
>
{
type
Output
=
UInt
<
PrivateSubOut
<
Ul
Ur
>
B0
>
;
}
impl
<
Ur
:
Unsigned
>
BitAnd
<
Ur
>
for
UTerm
{
type
Output
=
UTerm
;
fn
bitand
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
>
BitAnd
<
Ur
>
for
UInt
<
Ul
Bl
>
where
UInt
<
Ul
Bl
>
:
PrivateAnd
<
Ur
>
PrivateAndOut
<
UInt
<
Ul
Bl
>
Ur
>
:
Trim
{
type
Output
=
TrimOut
<
PrivateAndOut
<
UInt
<
Ul
Bl
>
Ur
>
>
;
fn
bitand
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
>
PrivateAnd
<
U
>
for
UTerm
{
type
Output
=
UTerm
;
}
impl
<
B
:
Bit
U
:
Unsigned
>
PrivateAnd
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
UTerm
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateAnd
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateAnd
<
Ur
>
{
type
Output
=
UInt
<
PrivateAndOut
<
Ul
Ur
>
B0
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateAnd
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateAnd
<
Ur
>
{
type
Output
=
UInt
<
PrivateAndOut
<
Ul
Ur
>
B0
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateAnd
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateAnd
<
Ur
>
{
type
Output
=
UInt
<
PrivateAndOut
<
Ul
Ur
>
B0
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateAnd
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateAnd
<
Ur
>
{
type
Output
=
UInt
<
PrivateAndOut
<
Ul
Ur
>
B1
>
;
}
impl
<
U
:
Unsigned
>
BitOr
<
U
>
for
UTerm
{
type
Output
=
U
;
fn
bitor
(
self
_
:
U
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
B
:
Bit
U
:
Unsigned
>
BitOr
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
Self
;
fn
bitor
(
self
_
:
UTerm
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
BitOr
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
BitOr
<
Ur
>
{
type
Output
=
UInt
<
<
Ul
as
BitOr
<
Ur
>
>
:
:
Output
B0
>
;
fn
bitor
(
self
_
:
UInt
<
Ur
B0
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
BitOr
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
BitOr
<
Ur
>
{
type
Output
=
UInt
<
Or
<
Ul
Ur
>
B1
>
;
fn
bitor
(
self
_
:
UInt
<
Ur
B1
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
BitOr
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
BitOr
<
Ur
>
{
type
Output
=
UInt
<
Or
<
Ul
Ur
>
B1
>
;
fn
bitor
(
self
_
:
UInt
<
Ur
B0
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
BitOr
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
BitOr
<
Ur
>
{
type
Output
=
UInt
<
Or
<
Ul
Ur
>
B1
>
;
fn
bitor
(
self
_
:
UInt
<
Ur
B1
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ur
:
Unsigned
>
BitXor
<
Ur
>
for
UTerm
{
type
Output
=
Ur
;
fn
bitxor
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
>
BitXor
<
Ur
>
for
UInt
<
Ul
Bl
>
where
UInt
<
Ul
Bl
>
:
PrivateXor
<
Ur
>
PrivateXorOut
<
UInt
<
Ul
Bl
>
Ur
>
:
Trim
{
type
Output
=
TrimOut
<
PrivateXorOut
<
UInt
<
Ul
Bl
>
Ur
>
>
;
fn
bitxor
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
>
PrivateXor
<
U
>
for
UTerm
{
type
Output
=
U
;
}
impl
<
B
:
Bit
U
:
Unsigned
>
PrivateXor
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
Self
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateXor
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateXor
<
Ur
>
{
type
Output
=
UInt
<
PrivateXorOut
<
Ul
Ur
>
B0
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateXor
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateXor
<
Ur
>
{
type
Output
=
UInt
<
PrivateXorOut
<
Ul
Ur
>
B1
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateXor
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateXor
<
Ur
>
{
type
Output
=
UInt
<
PrivateXorOut
<
Ul
Ur
>
B1
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
PrivateXor
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateXor
<
Ur
>
{
type
Output
=
UInt
<
PrivateXorOut
<
Ul
Ur
>
B0
>
;
}
impl
Shl
<
B0
>
for
UTerm
{
type
Output
=
UTerm
;
fn
shl
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
Shl
<
B1
>
for
UTerm
{
type
Output
=
UTerm
;
fn
shl
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Shl
<
B0
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
shl
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Shl
<
B1
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
UInt
<
U
B
>
B0
>
;
fn
shl
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Shl
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
shl
(
self
_
:
UTerm
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
>
Shl
<
U
>
for
UTerm
{
type
Output
=
UTerm
;
fn
shl
(
self
_
:
U
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
Ur
:
Unsigned
Br
:
Bit
>
Shl
<
UInt
<
Ur
Br
>
>
for
UInt
<
U
B
>
where
UInt
<
Ur
Br
>
:
Sub
<
B1
>
UInt
<
UInt
<
U
B
>
B0
>
:
Shl
<
Sub1
<
UInt
<
Ur
Br
>
>
>
{
type
Output
=
Shleft
<
UInt
<
UInt
<
U
B
>
B0
>
Sub1
<
UInt
<
Ur
Br
>
>
>
;
fn
shl
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
>
Shr
<
U
>
for
UTerm
{
type
Output
=
UTerm
;
fn
shr
(
self
_
:
U
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Shr
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
shr
(
self
_
:
UTerm
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
Shr
<
B0
>
for
UTerm
{
type
Output
=
UTerm
;
fn
shr
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
Shr
<
B1
>
for
UTerm
{
type
Output
=
UTerm
;
fn
shr
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Shr
<
B0
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
shr
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Shr
<
B1
>
for
UInt
<
U
B
>
{
type
Output
=
U
;
fn
shr
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
B
:
Bit
Ur
:
Unsigned
Br
:
Bit
>
Shr
<
UInt
<
Ur
Br
>
>
for
UInt
<
U
B
>
where
UInt
<
Ur
Br
>
:
Sub
<
B1
>
U
:
Shr
<
Sub1
<
UInt
<
Ur
Br
>
>
>
{
type
Output
=
Shright
<
U
Sub1
<
UInt
<
Ur
Br
>
>
>
;
fn
shr
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Mul
<
B0
>
for
UInt
<
U
B
>
{
type
Output
=
UTerm
;
fn
mul
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
Mul
<
B0
>
for
UTerm
{
type
Output
=
UTerm
;
fn
mul
(
self
_
:
B0
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
Mul
<
B1
>
for
UTerm
{
type
Output
=
UTerm
;
fn
mul
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Mul
<
B1
>
for
UInt
<
U
B
>
{
type
Output
=
UInt
<
U
B
>
;
fn
mul
(
self
_
:
B1
)
-
>
Self
:
:
Output
{
UInt
:
:
new
(
)
}
}
impl
<
U
:
Unsigned
B
:
Bit
>
Mul
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
UTerm
;
fn
mul
(
self
_
:
UTerm
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
U
:
Unsigned
>
Mul
<
U
>
for
UTerm
{
type
Output
=
UTerm
;
fn
mul
(
self
_
:
U
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
Ul
:
Unsigned
B
:
Bit
Ur
:
Unsigned
>
Mul
<
UInt
<
Ur
B
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
Mul
<
UInt
<
Ur
B
>
>
{
type
Output
=
UInt
<
Prod
<
Ul
UInt
<
Ur
B
>
>
B0
>
;
fn
mul
(
self
_
:
UInt
<
Ur
B
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Ul
:
Unsigned
B
:
Bit
Ur
:
Unsigned
>
Mul
<
UInt
<
Ur
B
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
Mul
<
UInt
<
Ur
B
>
>
UInt
<
Prod
<
Ul
UInt
<
Ur
B
>
>
B0
>
:
Add
<
UInt
<
Ur
B
>
>
{
type
Output
=
Sum
<
UInt
<
Prod
<
Ul
UInt
<
Ur
B
>
>
B0
>
UInt
<
Ur
B
>
>
;
fn
mul
(
self
_
:
UInt
<
Ur
B
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
Cmp
<
UTerm
>
for
UTerm
{
type
Output
=
Equal
;
}
impl
<
U
:
Unsigned
B
:
Bit
>
Cmp
<
UTerm
>
for
UInt
<
U
B
>
{
type
Output
=
Greater
;
}
impl
<
U
:
Unsigned
B
:
Bit
>
Cmp
<
UInt
<
U
B
>
>
for
UTerm
{
type
Output
=
Less
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Cmp
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateCmp
<
Ur
Equal
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
Equal
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Cmp
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateCmp
<
Ur
Equal
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
Equal
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Cmp
<
UInt
<
Ur
B1
>
>
for
UInt
<
Ul
B0
>
where
Ul
:
PrivateCmp
<
Ur
Less
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
Less
>
;
}
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
Cmp
<
UInt
<
Ur
B0
>
>
for
UInt
<
Ul
B1
>
where
Ul
:
PrivateCmp
<
Ur
Greater
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
Greater
>
;
}
impl
<
Ul
Ur
SoFar
>
PrivateCmp
<
UInt
<
Ur
B0
>
SoFar
>
for
UInt
<
Ul
B0
>
where
Ul
:
Unsigned
Ur
:
Unsigned
SoFar
:
Ord
Ul
:
PrivateCmp
<
Ur
SoFar
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
SoFar
>
;
}
impl
<
Ul
Ur
SoFar
>
PrivateCmp
<
UInt
<
Ur
B1
>
SoFar
>
for
UInt
<
Ul
B1
>
where
Ul
:
Unsigned
Ur
:
Unsigned
SoFar
:
Ord
Ul
:
PrivateCmp
<
Ur
SoFar
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
SoFar
>
;
}
impl
<
Ul
Ur
SoFar
>
PrivateCmp
<
UInt
<
Ur
B1
>
SoFar
>
for
UInt
<
Ul
B0
>
where
Ul
:
Unsigned
Ur
:
Unsigned
SoFar
:
Ord
Ul
:
PrivateCmp
<
Ur
Less
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
Less
>
;
}
impl
<
Ul
Ur
SoFar
>
PrivateCmp
<
UInt
<
Ur
B0
>
SoFar
>
for
UInt
<
Ul
B1
>
where
Ul
:
Unsigned
Ur
:
Unsigned
SoFar
:
Ord
Ul
:
PrivateCmp
<
Ur
Greater
>
{
type
Output
=
PrivateCmpOut
<
Ul
Ur
Greater
>
;
}
impl
<
U
:
Unsigned
B
:
Bit
SoFar
:
Ord
>
PrivateCmp
<
UInt
<
U
B
>
SoFar
>
for
UTerm
{
type
Output
=
Less
;
}
impl
<
U
:
Unsigned
B
:
Bit
SoFar
:
Ord
>
PrivateCmp
<
UTerm
SoFar
>
for
UInt
<
U
B
>
{
type
Output
=
Greater
;
}
impl
<
SoFar
:
Ord
>
PrivateCmp
<
UTerm
SoFar
>
for
UTerm
{
type
Output
=
SoFar
;
}
impl
<
Ul
Bl
Ur
Br
>
BitDiff
<
UInt
<
Ur
Br
>
>
for
UInt
<
Ul
Bl
>
where
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
Br
:
Bit
Ul
:
BitDiff
<
Ur
>
{
type
Output
=
BitDiffOut
<
Ul
Ur
>
;
}
impl
<
Ul
>
BitDiff
<
UTerm
>
for
Ul
where
Ul
:
Unsigned
+
Len
{
type
Output
=
Length
<
Ul
>
;
}
use
private
:
:
ShiftDiff
;
impl
<
Ul
:
Unsigned
Ur
:
Unsigned
>
ShiftDiff
<
Ur
>
for
Ul
where
Ur
:
BitDiff
<
Ul
>
Ul
:
Shl
<
BitDiffOut
<
Ur
Ul
>
>
{
type
Output
=
Shleft
<
Ul
BitDiffOut
<
Ur
Ul
>
>
;
}
impl
<
X
:
Unsigned
N
:
Unsigned
>
Pow
<
N
>
for
X
where
X
:
PrivatePow
<
U1
N
>
{
type
Output
=
PrivatePowOut
<
X
U1
N
>
;
fn
powi
(
self
_
:
N
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
impl
<
Y
:
Unsigned
X
:
Unsigned
>
PrivatePow
<
Y
U0
>
for
X
{
type
Output
=
Y
;
}
impl
<
Y
:
Unsigned
X
:
Unsigned
>
PrivatePow
<
Y
U1
>
for
X
where
X
:
Mul
<
Y
>
{
type
Output
=
Prod
<
X
Y
>
;
}
impl
<
Y
:
Unsigned
U
:
Unsigned
B
:
Bit
X
:
Unsigned
>
PrivatePow
<
Y
UInt
<
UInt
<
U
B
>
B0
>
>
for
X
where
X
:
Mul
Square
<
X
>
:
PrivatePow
<
Y
UInt
<
U
B
>
>
{
type
Output
=
PrivatePowOut
<
Square
<
X
>
Y
UInt
<
U
B
>
>
;
}
impl
<
Y
:
Unsigned
U
:
Unsigned
B
:
Bit
X
:
Unsigned
>
PrivatePow
<
Y
UInt
<
UInt
<
U
B
>
B1
>
>
for
X
where
X
:
Mul
+
Mul
<
Y
>
Square
<
X
>
:
PrivatePow
<
Prod
<
X
Y
>
UInt
<
U
B
>
>
{
type
Output
=
PrivatePowOut
<
Square
<
X
>
Prod
<
X
Y
>
UInt
<
U
B
>
>
;
}
#
[
allow
(
missing_docs
)
]
pub
trait
GetBit
<
I
>
{
#
[
allow
(
missing_docs
)
]
type
Output
;
}
#
[
allow
(
missing_docs
)
]
pub
type
GetBitOut
<
N
I
>
=
<
N
as
GetBit
<
I
>
>
:
:
Output
;
impl
<
Un
Bn
>
GetBit
<
U0
>
for
UInt
<
Un
Bn
>
{
type
Output
=
Bn
;
}
impl
<
Un
Bn
Ui
Bi
>
GetBit
<
UInt
<
Ui
Bi
>
>
for
UInt
<
Un
Bn
>
where
UInt
<
Ui
Bi
>
:
Sub
<
B1
>
Un
:
GetBit
<
Sub1
<
UInt
<
Ui
Bi
>
>
>
{
type
Output
=
GetBitOut
<
Un
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
}
impl
<
I
>
GetBit
<
I
>
for
UTerm
{
type
Output
=
B0
;
}
#
[
test
]
fn
test_get_bit
(
)
{
use
consts
:
:
*
;
use
Same
;
type
T1
=
<
GetBitOut
<
U2
U0
>
as
Same
<
B0
>
>
:
:
Output
;
type
T2
=
<
GetBitOut
<
U2
U1
>
as
Same
<
B1
>
>
:
:
Output
;
type
T3
=
<
GetBitOut
<
U2
U2
>
as
Same
<
B0
>
>
:
:
Output
;
<
T1
as
Bit
>
:
:
to_bool
(
)
;
<
T2
as
Bit
>
:
:
to_bool
(
)
;
<
T3
as
Bit
>
:
:
to_bool
(
)
;
}
pub
trait
SetBit
<
I
B
>
{
#
[
allow
(
missing_docs
)
]
type
Output
;
}
pub
type
SetBitOut
<
N
I
B
>
=
<
N
as
SetBit
<
I
B
>
>
:
:
Output
;
use
private
:
:
{
PrivateSetBit
PrivateSetBitOut
}
;
impl
<
N
I
B
>
SetBit
<
I
B
>
for
N
where
N
:
PrivateSetBit
<
I
B
>
PrivateSetBitOut
<
N
I
B
>
:
Trim
{
type
Output
=
TrimOut
<
PrivateSetBitOut
<
N
I
B
>
>
;
}
impl
<
Un
Bn
B
>
PrivateSetBit
<
U0
B
>
for
UInt
<
Un
Bn
>
{
type
Output
=
UInt
<
Un
B
>
;
}
impl
<
Un
Bn
Ui
Bi
B
>
PrivateSetBit
<
UInt
<
Ui
Bi
>
B
>
for
UInt
<
Un
Bn
>
where
UInt
<
Ui
Bi
>
:
Sub
<
B1
>
Un
:
PrivateSetBit
<
Sub1
<
UInt
<
Ui
Bi
>
>
B
>
{
type
Output
=
UInt
<
PrivateSetBitOut
<
Un
Sub1
<
UInt
<
Ui
Bi
>
>
B
>
Bn
>
;
}
impl
<
I
>
PrivateSetBit
<
I
B0
>
for
UTerm
{
type
Output
=
UTerm
;
}
impl
<
I
>
PrivateSetBit
<
I
B1
>
for
UTerm
where
U1
:
Shl
<
I
>
{
type
Output
=
Shleft
<
U1
I
>
;
}
#
[
test
]
fn
test_set_bit
(
)
{
use
consts
:
:
*
;
use
Same
;
type
T1
=
<
SetBitOut
<
U2
U0
B0
>
as
Same
<
U2
>
>
:
:
Output
;
type
T2
=
<
SetBitOut
<
U2
U0
B1
>
as
Same
<
U3
>
>
:
:
Output
;
type
T3
=
<
SetBitOut
<
U2
U1
B0
>
as
Same
<
U0
>
>
:
:
Output
;
type
T4
=
<
SetBitOut
<
U2
U1
B1
>
as
Same
<
U2
>
>
:
:
Output
;
type
T5
=
<
SetBitOut
<
U2
U2
B0
>
as
Same
<
U2
>
>
:
:
Output
;
type
T6
=
<
SetBitOut
<
U2
U2
B1
>
as
Same
<
U6
>
>
:
:
Output
;
type
T7
=
<
SetBitOut
<
U2
U3
B0
>
as
Same
<
U2
>
>
:
:
Output
;
type
T8
=
<
SetBitOut
<
U2
U3
B1
>
as
Same
<
U10
>
>
:
:
Output
;
type
T9
=
<
SetBitOut
<
U2
U4
B0
>
as
Same
<
U2
>
>
:
:
Output
;
type
T10
=
<
SetBitOut
<
U2
U4
B1
>
as
Same
<
U18
>
>
:
:
Output
;
type
T11
=
<
SetBitOut
<
U3
U0
B0
>
as
Same
<
U2
>
>
:
:
Output
;
<
T1
as
Unsigned
>
:
:
to_u32
(
)
;
<
T2
as
Unsigned
>
:
:
to_u32
(
)
;
<
T3
as
Unsigned
>
:
:
to_u32
(
)
;
<
T4
as
Unsigned
>
:
:
to_u32
(
)
;
<
T5
as
Unsigned
>
:
:
to_u32
(
)
;
<
T6
as
Unsigned
>
:
:
to_u32
(
)
;
<
T7
as
Unsigned
>
:
:
to_u32
(
)
;
<
T8
as
Unsigned
>
:
:
to_u32
(
)
;
<
T9
as
Unsigned
>
:
:
to_u32
(
)
;
<
T10
as
Unsigned
>
:
:
to_u32
(
)
;
<
T11
as
Unsigned
>
:
:
to_u32
(
)
;
}
#
[
cfg
(
tests
)
]
mod
tests
{
macro_rules
!
test_div
{
(
a
:
ident
/
b
:
ident
=
c
:
ident
)
=
>
(
{
type
R
=
Quot
<
a
b
>
;
assert_eq
!
(
<
R
as
Unsigned
>
:
:
to_usize
(
)
c
:
:
to_usize
(
)
)
;
}
)
;
}
#
[
test
]
fn
test_div
(
)
{
use
consts
:
:
*
;
use
{
Quot
Same
}
;
test_div
!
(
U0
/
U1
=
U0
)
;
test_div
!
(
U1
/
U1
=
U1
)
;
test_div
!
(
U2
/
U1
=
U2
)
;
test_div
!
(
U3
/
U1
=
U3
)
;
test_div
!
(
U4
/
U1
=
U4
)
;
test_div
!
(
U0
/
U2
=
U0
)
;
test_div
!
(
U1
/
U2
=
U0
)
;
test_div
!
(
U2
/
U2
=
U1
)
;
test_div
!
(
U3
/
U2
=
U1
)
;
test_div
!
(
U4
/
U2
=
U2
)
;
test_div
!
(
U6
/
U2
=
U3
)
;
test_div
!
(
U7
/
U2
=
U3
)
;
type
T
=
<
SetBitOut
<
U0
U1
B1
>
as
Same
<
U2
>
>
:
:
Output
;
<
T
as
Unsigned
>
:
:
to_u32
(
)
;
}
}
use
core
:
:
ops
:
:
Div
;
impl
<
Ur
:
Unsigned
Br
:
Bit
>
Div
<
UInt
<
Ur
Br
>
>
for
UTerm
{
type
Output
=
UTerm
;
fn
div
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
Br
:
Bit
>
Div
<
UInt
<
Ur
Br
>
>
for
UInt
<
Ul
Bl
>
where
UInt
<
Ul
Bl
>
:
Len
Length
<
UInt
<
Ul
Bl
>
>
:
Sub
<
B1
>
(
)
:
PrivateDiv
<
UInt
<
Ul
Bl
>
UInt
<
Ur
Br
>
U0
U0
Sub1
<
Length
<
UInt
<
Ul
Bl
>
>
>
>
{
type
Output
=
PrivateDivQuot
<
UInt
<
Ul
Bl
>
UInt
<
Ur
Br
>
U0
U0
Sub1
<
Length
<
UInt
<
Ul
Bl
>
>
>
>
;
fn
div
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
use
core
:
:
ops
:
:
Rem
;
impl
<
Ur
:
Unsigned
Br
:
Bit
>
Rem
<
UInt
<
Ur
Br
>
>
for
UTerm
{
type
Output
=
UTerm
;
fn
rem
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
Br
:
Bit
>
Rem
<
UInt
<
Ur
Br
>
>
for
UInt
<
Ul
Bl
>
where
UInt
<
Ul
Bl
>
:
Len
Length
<
UInt
<
Ul
Bl
>
>
:
Sub
<
B1
>
(
)
:
PrivateDiv
<
UInt
<
Ul
Bl
>
UInt
<
Ur
Br
>
U0
U0
Sub1
<
Length
<
UInt
<
Ul
Bl
>
>
>
>
{
type
Output
=
PrivateDivRem
<
UInt
<
Ul
Bl
>
UInt
<
Ur
Br
>
U0
U0
Sub1
<
Length
<
UInt
<
Ul
Bl
>
>
>
>
;
fn
rem
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
use
private
:
:
{
PrivateDiv
PrivateDivQuot
PrivateDivRem
}
;
use
Compare
;
impl
<
N
D
Q
I
>
PrivateDiv
<
N
D
Q
U0
I
>
for
(
)
where
N
:
GetBit
<
I
>
UInt
<
UTerm
GetBitOut
<
N
I
>
>
:
Trim
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
:
Cmp
<
D
>
(
)
:
PrivateDivIf
<
N
D
Q
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
I
Compare
<
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
D
>
>
{
type
Quotient
=
PrivateDivIfQuot
<
N
D
Q
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
I
Compare
<
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
D
>
>
;
type
Remainder
=
PrivateDivIfRem
<
N
D
Q
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
I
Compare
<
TrimOut
<
UInt
<
UTerm
GetBitOut
<
N
I
>
>
>
D
>
>
;
}
impl
<
N
D
Q
Ur
Br
I
>
PrivateDiv
<
N
D
Q
UInt
<
Ur
Br
>
I
>
for
(
)
where
N
:
GetBit
<
I
>
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
:
Cmp
<
D
>
(
)
:
PrivateDivIf
<
N
D
Q
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
I
Compare
<
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
D
>
>
{
type
Quotient
=
PrivateDivIfQuot
<
N
D
Q
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
I
Compare
<
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
D
>
>
;
type
Remainder
=
PrivateDivIfRem
<
N
D
Q
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
I
Compare
<
UInt
<
UInt
<
Ur
Br
>
GetBitOut
<
N
I
>
>
D
>
>
;
}
use
private
:
:
{
PrivateDivIf
PrivateDivIfQuot
PrivateDivIfRem
}
;
impl
<
N
D
Q
R
Ui
Bi
>
PrivateDivIf
<
N
D
Q
R
UInt
<
Ui
Bi
>
Less
>
for
(
)
where
UInt
<
Ui
Bi
>
:
Sub
<
B1
>
(
)
:
PrivateDiv
<
N
D
Q
R
Sub1
<
UInt
<
Ui
Bi
>
>
>
{
type
Quotient
=
PrivateDivQuot
<
N
D
Q
R
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
type
Remainder
=
PrivateDivRem
<
N
D
Q
R
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
}
impl
<
N
D
Q
R
Ui
Bi
>
PrivateDivIf
<
N
D
Q
R
UInt
<
Ui
Bi
>
Equal
>
for
(
)
where
UInt
<
Ui
Bi
>
:
Sub
<
B1
>
Q
:
SetBit
<
UInt
<
Ui
Bi
>
B1
>
(
)
:
PrivateDiv
<
N
D
SetBitOut
<
Q
UInt
<
Ui
Bi
>
B1
>
U0
Sub1
<
UInt
<
Ui
Bi
>
>
>
{
type
Quotient
=
PrivateDivQuot
<
N
D
SetBitOut
<
Q
UInt
<
Ui
Bi
>
B1
>
U0
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
type
Remainder
=
PrivateDivRem
<
N
D
SetBitOut
<
Q
UInt
<
Ui
Bi
>
B1
>
U0
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
}
use
Diff
;
impl
<
N
D
Q
R
Ui
Bi
>
PrivateDivIf
<
N
D
Q
R
UInt
<
Ui
Bi
>
Greater
>
for
(
)
where
UInt
<
Ui
Bi
>
:
Sub
<
B1
>
R
:
Sub
<
D
>
Q
:
SetBit
<
UInt
<
Ui
Bi
>
B1
>
(
)
:
PrivateDiv
<
N
D
SetBitOut
<
Q
UInt
<
Ui
Bi
>
B1
>
Diff
<
R
D
>
Sub1
<
UInt
<
Ui
Bi
>
>
>
{
type
Quotient
=
PrivateDivQuot
<
N
D
SetBitOut
<
Q
UInt
<
Ui
Bi
>
B1
>
Diff
<
R
D
>
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
type
Remainder
=
PrivateDivRem
<
N
D
SetBitOut
<
Q
UInt
<
Ui
Bi
>
B1
>
Diff
<
R
D
>
Sub1
<
UInt
<
Ui
Bi
>
>
>
;
}
impl
<
N
D
Q
R
>
PrivateDivIf
<
N
D
Q
R
U0
Less
>
for
(
)
{
type
Quotient
=
Q
;
type
Remainder
=
R
;
}
impl
<
N
D
Q
R
>
PrivateDivIf
<
N
D
Q
R
U0
Equal
>
for
(
)
where
Q
:
SetBit
<
U0
B1
>
{
type
Quotient
=
SetBitOut
<
Q
U0
B1
>
;
type
Remainder
=
U0
;
}
impl
<
N
D
Q
R
>
PrivateDivIf
<
N
D
Q
R
U0
Greater
>
for
(
)
where
R
:
Sub
<
D
>
Q
:
SetBit
<
U0
B1
>
{
type
Quotient
=
SetBitOut
<
Q
U0
B1
>
;
type
Remainder
=
Diff
<
R
D
>
;
}
use
{
PartialDiv
Quot
}
;
impl
<
Ur
:
Unsigned
Br
:
Bit
>
PartialDiv
<
UInt
<
Ur
Br
>
>
for
UTerm
{
type
Output
=
UTerm
;
fn
partial_div
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
UTerm
}
}
impl
<
Ul
:
Unsigned
Bl
:
Bit
Ur
:
Unsigned
Br
:
Bit
>
PartialDiv
<
UInt
<
Ur
Br
>
>
for
UInt
<
Ul
Bl
>
where
UInt
<
Ul
Bl
>
:
Div
<
UInt
<
Ur
Br
>
>
+
Rem
<
UInt
<
Ur
Br
>
Output
=
U0
>
{
type
Output
=
Quot
<
UInt
<
Ul
Bl
>
UInt
<
Ur
Br
>
>
;
fn
partial_div
(
self
_
:
UInt
<
Ur
Br
>
)
-
>
Self
:
:
Output
{
unsafe
{
:
:
core
:
:
mem
:
:
uninitialized
(
)
}
}
}
use
private
:
:
{
PrivateMin
PrivateMinOut
}
;
impl
<
U
B
Ur
>
PrivateMin
<
Ur
Equal
>
for
UInt
<
U
B
>
where
Ur
:
Unsigned
U
:
Unsigned
B
:
Bit
{
type
Output
=
UInt
<
U
B
>
;
fn
private_min
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
self
}
}
impl
<
U
B
Ur
>
PrivateMin
<
Ur
Less
>
for
UInt
<
U
B
>
where
Ur
:
Unsigned
U
:
Unsigned
B
:
Bit
{
type
Output
=
UInt
<
U
B
>
;
fn
private_min
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
self
}
}
impl
<
U
B
Ur
>
PrivateMin
<
Ur
Greater
>
for
UInt
<
U
B
>
where
Ur
:
Unsigned
U
:
Unsigned
B
:
Bit
{
type
Output
=
Ur
;
fn
private_min
(
self
rhs
:
Ur
)
-
>
Self
:
:
Output
{
rhs
}
}
use
Min
;
impl
<
U
>
Min
<
U
>
for
UTerm
where
U
:
Unsigned
{
type
Output
=
UTerm
;
fn
min
(
self
_
:
U
)
-
>
Self
:
:
Output
{
self
}
}
impl
<
U
B
Ur
>
Min
<
Ur
>
for
UInt
<
U
B
>
where
U
:
Unsigned
B
:
Bit
Ur
:
Unsigned
UInt
<
U
B
>
:
Cmp
<
Ur
>
+
PrivateMin
<
Ur
Compare
<
UInt
<
U
B
>
Ur
>
>
{
type
Output
=
PrivateMinOut
<
UInt
<
U
B
>
Ur
Compare
<
UInt
<
U
B
>
Ur
>
>
;
fn
min
(
self
rhs
:
Ur
)
-
>
Self
:
:
Output
{
self
.
private_min
(
rhs
)
}
}
use
private
:
:
{
PrivateMax
PrivateMaxOut
}
;
impl
<
U
B
Ur
>
PrivateMax
<
Ur
Equal
>
for
UInt
<
U
B
>
where
Ur
:
Unsigned
U
:
Unsigned
B
:
Bit
{
type
Output
=
UInt
<
U
B
>
;
fn
private_max
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
self
}
}
impl
<
U
B
Ur
>
PrivateMax
<
Ur
Less
>
for
UInt
<
U
B
>
where
Ur
:
Unsigned
U
:
Unsigned
B
:
Bit
{
type
Output
=
Ur
;
fn
private_max
(
self
rhs
:
Ur
)
-
>
Self
:
:
Output
{
rhs
}
}
impl
<
U
B
Ur
>
PrivateMax
<
Ur
Greater
>
for
UInt
<
U
B
>
where
Ur
:
Unsigned
U
:
Unsigned
B
:
Bit
{
type
Output
=
UInt
<
U
B
>
;
fn
private_max
(
self
_
:
Ur
)
-
>
Self
:
:
Output
{
self
}
}
use
Max
;
impl
<
U
>
Max
<
U
>
for
UTerm
where
U
:
Unsigned
{
type
Output
=
U
;
fn
max
(
self
rhs
:
U
)
-
>
Self
:
:
Output
{
rhs
}
}
impl
<
U
B
Ur
>
Max
<
Ur
>
for
UInt
<
U
B
>
where
U
:
Unsigned
B
:
Bit
Ur
:
Unsigned
UInt
<
U
B
>
:
Cmp
<
Ur
>
+
PrivateMax
<
Ur
Compare
<
UInt
<
U
B
>
Ur
>
>
{
type
Output
=
PrivateMaxOut
<
UInt
<
U
B
>
Ur
Compare
<
UInt
<
U
B
>
Ur
>
>
;
fn
max
(
self
rhs
:
Ur
)
-
>
Self
:
:
Output
{
self
.
private_max
(
rhs
)
}
}
