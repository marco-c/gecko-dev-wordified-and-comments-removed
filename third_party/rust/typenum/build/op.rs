#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
enum
OpType
{
Operator
Function
}
use
self
:
:
OpType
:
:
*
;
struct
Op
{
token
:
&
'
static
str
operator
:
&
'
static
str
example
:
(
&
'
static
str
&
'
static
str
)
precedence
:
u8
n_args
:
u8
op_type
:
OpType
}
pub
fn
write_op_macro
(
)
-
>
:
:
std
:
:
io
:
:
Result
<
(
)
>
{
let
out_dir
=
:
:
std
:
:
env
:
:
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
;
let
dest
=
:
:
std
:
:
path
:
:
Path
:
:
new
(
&
out_dir
)
.
join
(
"
op
.
rs
"
)
;
println
!
(
"
cargo
:
rustc
-
env
=
TYPENUM_BUILD_OP
=
{
}
"
dest
.
display
(
)
)
;
let
mut
f
=
:
:
std
:
:
fs
:
:
File
:
:
create
(
&
dest
)
.
unwrap
(
)
;
let
ops
=
&
[
Op
{
token
:
"
*
"
operator
:
"
Prod
"
example
:
(
"
P2
*
P3
"
"
P6
"
)
precedence
:
16
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
/
"
operator
:
"
Quot
"
example
:
(
"
P6
/
P2
"
"
P3
"
)
precedence
:
16
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
%
"
operator
:
"
Mod
"
example
:
(
"
P5
%
P3
"
"
P2
"
)
precedence
:
16
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
+
"
operator
:
"
Sum
"
example
:
(
"
P2
+
P3
"
"
P5
"
)
precedence
:
15
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
-
"
operator
:
"
Diff
"
example
:
(
"
P2
-
P3
"
"
N1
"
)
precedence
:
15
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
<
<
"
operator
:
"
Shleft
"
example
:
(
"
U1
<
<
U5
"
"
U32
"
)
precedence
:
14
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
>
>
"
operator
:
"
Shright
"
example
:
(
"
U32
>
>
U5
"
"
U1
"
)
precedence
:
14
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
&
"
operator
:
"
And
"
example
:
(
"
U5
&
U3
"
"
U1
"
)
precedence
:
13
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
^
"
operator
:
"
Xor
"
example
:
(
"
U5
^
U3
"
"
U6
"
)
precedence
:
12
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
|
"
operator
:
"
Or
"
example
:
(
"
U5
|
U3
"
"
U7
"
)
precedence
:
11
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
=
=
"
operator
:
"
Eq
"
example
:
(
"
P5
=
=
P3
+
P2
"
"
True
"
)
precedence
:
10
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
!
=
"
operator
:
"
NotEq
"
example
:
(
"
P5
!
=
P3
+
P2
"
"
False
"
)
precedence
:
10
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
<
=
"
operator
:
"
LeEq
"
example
:
(
"
P6
<
=
P3
+
P2
"
"
False
"
)
precedence
:
10
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
>
=
"
operator
:
"
GrEq
"
example
:
(
"
P6
>
=
P3
+
P2
"
"
True
"
)
precedence
:
10
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
<
"
operator
:
"
Le
"
example
:
(
"
P4
<
P3
+
P2
"
"
True
"
)
precedence
:
10
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
>
"
operator
:
"
Gr
"
example
:
(
"
P5
<
P3
+
P2
"
"
False
"
)
precedence
:
10
n_args
:
2
op_type
:
Operator
}
Op
{
token
:
"
cmp
"
operator
:
"
Compare
"
example
:
(
"
cmp
(
P2
P3
)
"
"
Less
"
)
precedence
:
!
0
n_args
:
2
op_type
:
Function
}
Op
{
token
:
"
sqr
"
operator
:
"
Square
"
example
:
(
"
sqr
(
P2
)
"
"
P4
"
)
precedence
:
!
0
n_args
:
1
op_type
:
Function
}
Op
{
token
:
"
sqrt
"
operator
:
"
Sqrt
"
example
:
(
"
sqrt
(
U9
)
"
"
U3
"
)
precedence
:
!
0
n_args
:
1
op_type
:
Function
}
Op
{
token
:
"
abs
"
operator
:
"
AbsVal
"
example
:
(
"
abs
(
N2
)
"
"
P2
"
)
precedence
:
!
0
n_args
:
1
op_type
:
Function
}
Op
{
token
:
"
cube
"
operator
:
"
Cube
"
example
:
(
"
cube
(
P2
)
"
"
P8
"
)
precedence
:
!
0
n_args
:
1
op_type
:
Function
}
Op
{
token
:
"
pow
"
operator
:
"
Exp
"
example
:
(
"
pow
(
P2
P3
)
"
"
P8
"
)
precedence
:
!
0
n_args
:
2
op_type
:
Function
}
Op
{
token
:
"
min
"
operator
:
"
Minimum
"
example
:
(
"
min
(
P2
P3
)
"
"
P2
"
)
precedence
:
!
0
n_args
:
2
op_type
:
Function
}
Op
{
token
:
"
max
"
operator
:
"
Maximum
"
example
:
(
"
max
(
P2
P3
)
"
"
P3
"
)
precedence
:
!
0
n_args
:
2
op_type
:
Function
}
Op
{
token
:
"
log2
"
operator
:
"
Log2
"
example
:
(
"
log2
(
U9
)
"
"
U3
"
)
precedence
:
!
0
n_args
:
1
op_type
:
Function
}
Op
{
token
:
"
gcd
"
operator
:
"
Gcf
"
example
:
(
"
gcd
(
U9
U21
)
"
"
U3
"
)
precedence
:
!
0
n_args
:
2
op_type
:
Function
}
]
;
use
std
:
:
io
:
:
Write
;
write
!
(
f
"
/
*
*
Convenient
type
operations
.
Any
types
representing
values
must
be
able
to
be
expressed
as
ident
s
.
That
means
they
need
to
be
in
scope
.
For
example
P5
is
okay
but
typenum
:
:
P5
is
not
.
You
may
combine
operators
arbitrarily
although
doing
so
excessively
may
require
raising
the
recursion
limit
.
#
Example
rust
#
!
[
recursion_limit
=
\
"
128
\
"
]
#
[
macro_use
]
extern
crate
typenum
;
use
typenum
:
:
consts
:
:
*
;
fn
main
(
)
{
{
assert_type
!
(
op
!
(
min
(
(
P1
-
P2
)
*
(
N3
+
N7
)
P5
*
(
P3
+
P4
)
)
=
=
P10
)
)
;
}
}
Operators
are
evaluated
based
on
the
operator
precedence
outlined
[
here
]
(
https
:
/
/
doc
.
rust
-
lang
.
org
/
reference
.
html
#
operator
-
precedence
)
.
The
full
list
of
supported
operators
and
functions
is
as
follows
:
{
}
They
all
expand
to
type
aliases
defined
in
the
operator_aliases
module
.
Here
is
an
expanded
list
including
examples
:
"
ops
.
iter
(
)
.
map
(
|
op
|
format
!
(
"
{
}
"
op
.
token
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
"
)
)
?
;
for
op
in
ops
.
iter
(
)
{
write
!
(
f
"
-
-
-
\
nOperator
{
token
}
.
Expands
to
{
operator
}
.
rust
#
#
[
macro_use
]
extern
crate
typenum
;
#
use
typenum
:
:
*
;
#
fn
main
(
)
{
{
assert_type_eq
!
(
op
!
(
{
ex0
}
)
{
ex1
}
)
;
#
}
}
\
n
"
token
=
op
.
token
operator
=
op
.
operator
ex0
=
op
.
example
.
0
ex1
=
op
.
example
.
1
)
?
;
}
write
!
(
f
"
*
/
#
[
macro_export
]
macro_rules
!
op
{
{
(
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
(
tail
)
*
)
)
;
}
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__op_internal__
{
{
"
)
?
;
for
fun
in
ops
.
iter
(
)
.
filter
(
|
f
|
f
.
op_type
=
=
Function
)
{
write
!
(
f
"
(
stack
[
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
{
f_token
}
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
{
f_op
}
(
stack
)
*
]
queue
[
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
f_token
=
fun
.
token
f_op
=
fun
.
operator
)
?
;
}
write
!
(
f
"
(
stack
[
LParen
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
LParen
(
stack
)
*
]
queue
[
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
stack
[
stack_top
:
ident
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
stack_top
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
)
?
;
for
o1
in
ops
.
iter
(
)
.
filter
(
|
op
|
op
.
op_type
=
=
Operator
)
{
for
o2
in
ops
.
iter
(
)
.
filter
(
|
op
|
op
.
op_type
=
=
Operator
)
.
filter
(
|
o2
|
o1
.
precedence
<
=
o2
.
precedence
)
{
write
!
(
f
"
(
stack
[
{
o2_op
}
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
{
o1_token
}
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
{
o2_op
}
(
queue
)
*
]
tail
:
{
o1_token
}
(
tail
)
*
)
)
;
"
o2_op
=
o2
.
operator
o1_token
=
o1
.
token
)
?
;
}
write
!
(
f
"
(
stack
[
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
{
o1_token
}
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
{
o1_op
}
(
stack
)
*
]
queue
[
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
o1_op
=
o1
.
operator
o1_token
=
o1
.
token
)
?
;
}
write
!
(
f
"
(
stack
[
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
(
(
stuff
:
tt
)
*
)
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
LParen
(
stack
)
*
]
queue
[
(
queue
)
*
]
tail
:
(
stuff
)
*
RParen
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
stack
[
LParen
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
RParen
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
rp3
stack
[
(
stack
)
*
]
queue
[
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
stack
[
stack_top
:
ident
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
RParen
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
stack_top
(
queue
)
*
]
tail
:
RParen
(
tail
)
*
)
)
;
"
)
?
;
for
fun
in
ops
.
iter
(
)
.
filter
(
|
f
|
f
.
op_type
=
=
Function
)
{
write
!
(
f
"
(
rp3
stack
[
{
fun_op
}
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
{
fun_op
}
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
fun_op
=
fun
.
operator
)
?
;
}
write
!
(
f
"
(
rp3
stack
[
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
stack
[
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
num
:
ident
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
num
(
queue
)
*
]
tail
:
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
stack
[
]
queue
[
(
queue
:
ident
)
*
]
tail
:
)
=
>
(
__op_internal__
!
(
reverse
[
]
input
:
(
queue
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
stack
[
stack_top
:
ident
(
stack
:
ident
)
*
]
queue
[
(
queue
:
ident
)
*
]
tail
:
)
=
>
(
__op_internal__
!
(
stack
[
(
stack
)
*
]
queue
[
stack_top
(
queue
)
*
]
tail
:
)
)
;
"
)
?
;
write
!
(
f
"
(
reverse
[
(
revved
:
ident
)
*
]
input
:
head
:
ident
(
tail
:
ident
)
*
)
=
>
(
__op_internal__
!
(
reverse
[
head
(
revved
)
*
]
input
:
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
(
reverse
[
(
revved
:
ident
)
*
]
input
:
)
=
>
(
__op_internal__
!
(
eval
stack
[
]
input
[
(
revved
)
*
]
)
)
;
"
)
?
;
for
op
in
ops
.
iter
(
)
.
filter
(
|
op
|
op
.
n_args
=
=
2
)
{
write
!
(
f
"
(
eval
stack
[
a
:
ty
b
:
ty
(
stack
:
ty
)
*
]
input
[
{
op
}
(
tail
:
ident
)
*
]
)
=
>
(
__op_internal__
!
(
eval
stack
[
crate
:
:
{
op
}
<
b
a
>
(
stack
)
*
]
input
[
(
tail
)
*
]
)
)
;
"
op
=
op
.
operator
)
?
;
}
for
op
in
ops
.
iter
(
)
.
filter
(
|
op
|
op
.
n_args
=
=
1
)
{
write
!
(
f
"
(
eval
stack
[
a
:
ty
(
stack
:
ty
)
*
]
input
[
{
op
}
(
tail
:
ident
)
*
]
)
=
>
(
__op_internal__
!
(
eval
stack
[
crate
:
:
{
op
}
<
a
>
(
stack
)
*
]
input
[
(
tail
)
*
]
)
)
;
"
op
=
op
.
operator
)
?
;
}
write
!
(
f
"
(
eval
stack
[
(
stack
:
ty
)
*
]
input
[
head
:
ident
(
tail
:
ident
)
*
]
)
=
>
(
__op_internal__
!
(
eval
stack
[
head
(
stack
)
*
]
input
[
(
tail
)
*
]
)
)
;
"
)
?
;
write
!
(
f
"
(
eval
stack
[
stack
:
ty
]
input
[
]
)
=
>
(
stack
)
;
"
)
?
;
write
!
(
f
"
(
(
tail
:
tt
)
*
)
=
>
(
__op_internal__
!
(
stack
[
]
queue
[
]
tail
:
(
tail
)
*
)
)
;
"
)
?
;
write
!
(
f
"
}
}
"
)
?
;
Ok
(
(
)
)
}
