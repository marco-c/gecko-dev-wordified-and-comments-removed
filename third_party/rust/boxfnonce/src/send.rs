use
traits
:
:
FnBox
;
pub
struct
SendBoxFnOnce
<
Arguments
Result
=
(
)
>
(
Box
<
FnBox
<
Arguments
Result
>
+
Send
>
)
;
impl
<
Args
Result
>
SendBoxFnOnce
<
Args
Result
>
{
#
[
inline
]
pub
fn
call_tuple
(
self
args
:
Args
)
-
>
Result
{
self
.
0
.
call
(
args
)
}
#
[
inline
]
pub
fn
new
<
F
>
(
func
:
F
)
-
>
Self
where
Self
:
From
<
F
>
{
Self
:
:
from
(
func
)
}
}
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
a5
:
A5
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
a5
:
A5
a6
:
A6
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
a5
:
A5
a6
:
A6
a7
:
A7
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
a5
:
A5
a6
:
A6
a7
:
A7
a8
:
A8
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
a5
:
A5
a6
:
A6
a7
:
A7
a8
:
A8
a9
:
A9
)
;
build_n_args
!
(
SendBoxFnOnce
[
+
Send
]
:
a1
:
A1
a2
:
A2
a3
:
A3
a4
:
A4
a5
:
A5
a6
:
A6
a7
:
A7
a8
:
A8
a9
:
A9
a10
:
A10
)
;
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
SendBoxFnOnce
;
use
std
:
:
thread
;
use
std
:
:
sync
:
:
Arc
;
struct
SendString
(
String
Arc
<
(
)
>
)
;
impl
SendString
{
fn
into
(
self
)
-
>
String
{
self
.
0
}
}
fn
closure_string
(
)
-
>
SendString
{
SendString
(
String
:
:
from
(
"
abc
"
)
Arc
:
:
new
(
(
)
)
)
}
fn
try_send
<
Result
F
>
(
name
:
&
str
func
:
F
)
-
>
thread
:
:
Result
<
Result
>
where
Result
:
'
static
+
Send
F
:
'
static
+
Send
+
FnOnce
(
)
-
>
Result
{
thread
:
:
Builder
:
:
new
(
)
.
name
(
name
.
to_string
(
)
)
.
spawn
(
func
)
.
unwrap
(
)
.
join
(
)
}
fn
send
<
Result
F
>
(
func
:
F
)
-
>
Result
where
Result
:
'
static
+
Send
F
:
'
static
+
Send
+
FnOnce
(
)
-
>
Result
{
try_send
(
"
test
thread
"
func
)
.
unwrap
(
)
}
#
[
test
]
fn
test_arg0
(
)
{
let
f
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
|
-
>
String
{
s
.
into
(
)
}
}
)
;
let
result
=
send
(
|
|
{
f
.
call
(
)
}
)
;
assert_eq
!
(
result
"
abc
"
)
;
}
#
[
test
]
fn
test_arg1
(
)
{
let
f
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
_
|
-
>
String
{
s
.
into
(
)
}
}
)
;
let
result
=
send
(
|
|
{
f
.
call
(
0
)
}
)
;
assert_eq
!
(
result
"
abc
"
)
;
}
#
[
test
]
fn
test_arg1_fixed_argument_type
(
)
{
let
f
:
SendBoxFnOnce
<
(
i32
)
String
>
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
_
|
-
>
String
{
s
.
into
(
)
}
}
)
;
let
result
=
send
(
|
|
{
f
.
call
(
0
)
}
)
;
assert_eq
!
(
result
"
abc
"
)
;
}
#
[
test
]
fn
test_arg2
(
)
{
let
f
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
_
_
|
-
>
String
{
s
.
into
(
)
}
}
)
;
let
result
=
send
(
|
|
{
f
.
call
(
0
0
)
}
)
;
assert_eq
!
(
result
"
abc
"
)
;
}
#
[
test
]
fn
test_arg3
(
)
{
let
f
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
_
_
_
|
-
>
String
{
s
.
into
(
)
}
}
)
;
let
result
=
send
(
|
|
{
f
.
call
(
0
0
0
)
}
)
;
assert_eq
!
(
result
"
abc
"
)
;
}
#
[
test
]
fn
test_arg4_void
(
)
{
let
f
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
_
_
_
_
|
{
drop
(
s
)
;
}
}
)
;
send
(
|
|
{
f
.
call
(
0
0
0
0
)
;
}
)
;
}
#
[
test
]
fn
test_arg4_diverging
(
)
{
use
std
:
:
panic
;
let
f
=
SendBoxFnOnce
:
:
from
(
{
let
s
=
closure_string
(
)
;
|
_
_
_
_
|
-
>
!
{
drop
(
s
)
;
panic
:
:
resume_unwind
(
Box
:
:
new
(
"
inner
diverging
"
)
)
;
}
}
)
;
let
result
=
try_send
(
"
diverging
test
thread
"
|
|
{
f
.
call
(
0
0
0
0
)
;
}
)
.
map_err
(
|
e
|
e
.
downcast
:
:
<
&
str
>
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
result
Err
(
Box
:
:
new
(
"
inner
diverging
"
)
)
)
;
}
}
