extern
crate
flate2
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
:
:
{
self
BufReader
}
;
use
std
:
:
path
:
:
Path
;
use
flate2
:
:
read
:
:
GzDecoder
;
use
flate2
:
:
read
:
:
MultiGzDecoder
;
#
[
test
]
fn
test_extract_success
(
)
{
let
content
=
extract_file
(
Path
:
:
new
(
"
tests
/
good
-
file
.
gz
"
)
)
.
unwrap
(
)
;
let
mut
expected
=
Vec
:
:
new
(
)
;
File
:
:
open
(
"
tests
/
good
-
file
.
txt
"
)
.
unwrap
(
)
.
read_to_end
(
&
mut
expected
)
.
unwrap
(
)
;
assert
!
(
content
=
=
expected
)
;
}
#
[
test
]
fn
test_extract_success_partial_multi
(
)
{
let
content
=
extract_file
(
Path
:
:
new
(
"
tests
/
multi
.
gz
"
)
)
.
unwrap
(
)
;
let
mut
expected
=
String
:
:
new
(
)
;
BufReader
:
:
new
(
File
:
:
open
(
"
tests
/
multi
.
txt
"
)
.
unwrap
(
)
)
.
read_line
(
&
mut
expected
)
.
unwrap
(
)
;
assert_eq
!
(
content
expected
.
as_bytes
(
)
)
;
}
#
[
test
]
fn
test_extract_failure
(
)
{
let
result
=
extract_file
(
Path
:
:
new
(
"
tests
/
corrupt
-
file
.
gz
"
)
)
;
assert_eq
!
(
result
.
err
(
)
.
unwrap
(
)
.
kind
(
)
io
:
:
ErrorKind
:
:
InvalidInput
)
;
}
#
[
test
]
fn
test_extract_success_multi
(
)
{
let
content
=
extract_file_multi
(
Path
:
:
new
(
"
tests
/
multi
.
gz
"
)
)
.
unwrap
(
)
;
let
mut
expected
=
Vec
:
:
new
(
)
;
File
:
:
open
(
"
tests
/
multi
.
txt
"
)
.
unwrap
(
)
.
read_to_end
(
&
mut
expected
)
.
unwrap
(
)
;
assert_eq
!
(
content
expected
)
;
}
fn
extract_file
(
path_compressed
:
&
Path
)
-
>
io
:
:
Result
<
Vec
<
u8
>
>
{
let
mut
v
=
Vec
:
:
new
(
)
;
let
f
=
try
!
(
File
:
:
open
(
path_compressed
)
)
;
try
!
(
try
!
(
GzDecoder
:
:
new
(
f
)
)
.
read_to_end
(
&
mut
v
)
)
;
Ok
(
v
)
}
fn
extract_file_multi
(
path_compressed
:
&
Path
)
-
>
io
:
:
Result
<
Vec
<
u8
>
>
{
let
mut
v
=
Vec
:
:
new
(
)
;
let
f
=
try
!
(
File
:
:
open
(
path_compressed
)
)
;
try
!
(
try
!
(
MultiGzDecoder
:
:
new
(
f
)
)
.
read_to_end
(
&
mut
v
)
)
;
Ok
(
v
)
}
