use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
marker
;
use
std
:
:
slice
;
use
libc
:
:
{
c_int
c_uint
}
;
use
Compression
;
use
ffi
;
pub
struct
Compress
{
inner
:
Stream
<
DirCompress
>
}
pub
struct
Decompress
{
inner
:
Stream
<
DirDecompress
>
}
struct
Stream
<
D
:
Direction
>
{
stream_wrapper
:
ffi
:
:
StreamWrapper
total_in
:
u64
total_out
:
u64
_marker
:
marker
:
:
PhantomData
<
D
>
}
unsafe
impl
<
D
:
Direction
>
Send
for
Stream
<
D
>
{
}
unsafe
impl
<
D
:
Direction
>
Sync
for
Stream
<
D
>
{
}
trait
Direction
{
unsafe
fn
destroy
(
stream
:
*
mut
ffi
:
:
mz_stream
)
-
>
c_int
;
}
enum
DirCompress
{
}
enum
DirDecompress
{
}
pub
enum
Flush
{
None
=
ffi
:
:
MZ_NO_FLUSH
as
isize
Sync
=
ffi
:
:
MZ_SYNC_FLUSH
as
isize
Partial
=
ffi
:
:
MZ_PARTIAL_FLUSH
as
isize
Block
=
ffi
:
:
MZ_BLOCK
as
isize
Full
=
ffi
:
:
MZ_FULL_FLUSH
as
isize
Finish
=
ffi
:
:
MZ_FINISH
as
isize
}
#
[
derive
(
Debug
)
]
pub
struct
DataError
(
(
)
)
;
pub
enum
Status
{
Ok
BufError
StreamEnd
}
impl
Compress
{
pub
fn
new
(
level
:
Compression
zlib_header
:
bool
)
-
>
Compress
{
unsafe
{
let
mut
state
=
ffi
:
:
StreamWrapper
:
:
default
(
)
;
let
ret
=
ffi
:
:
mz_deflateInit2
(
&
mut
*
state
level
as
c_int
ffi
:
:
MZ_DEFLATED
if
zlib_header
{
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
}
else
{
-
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
}
9
ffi
:
:
MZ_DEFAULT_STRATEGY
)
;
debug_assert_eq
!
(
ret
0
)
;
Compress
{
inner
:
Stream
{
stream_wrapper
:
state
total_in
:
0
total_out
:
0
_marker
:
marker
:
:
PhantomData
}
}
}
}
pub
fn
total_in
(
&
self
)
-
>
u64
{
self
.
inner
.
total_in
}
pub
fn
total_out
(
&
self
)
-
>
u64
{
self
.
inner
.
total_out
}
pub
fn
reset
(
&
mut
self
)
{
let
rc
=
unsafe
{
ffi
:
:
mz_deflateReset
(
&
mut
*
self
.
inner
.
stream_wrapper
)
}
;
assert_eq
!
(
rc
ffi
:
:
MZ_OK
)
;
self
.
inner
.
total_in
=
0
;
self
.
inner
.
total_out
=
0
;
}
pub
fn
compress
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
flush
:
Flush
)
-
>
Status
{
let
raw
=
&
mut
*
self
.
inner
.
stream_wrapper
;
raw
.
next_in
=
input
.
as_ptr
(
)
as
*
mut
_
;
raw
.
avail_in
=
input
.
len
(
)
as
c_uint
;
raw
.
next_out
=
output
.
as_mut_ptr
(
)
;
raw
.
avail_out
=
output
.
len
(
)
as
c_uint
;
let
rc
=
unsafe
{
ffi
:
:
mz_deflate
(
raw
flush
as
c_int
)
}
;
self
.
inner
.
total_in
+
=
(
raw
.
next_in
as
usize
-
input
.
as_ptr
(
)
as
usize
)
as
u64
;
self
.
inner
.
total_out
+
=
(
raw
.
next_out
as
usize
-
output
.
as_ptr
(
)
as
usize
)
as
u64
;
match
rc
{
ffi
:
:
MZ_OK
=
>
Status
:
:
Ok
ffi
:
:
MZ_BUF_ERROR
=
>
Status
:
:
BufError
ffi
:
:
MZ_STREAM_END
=
>
Status
:
:
StreamEnd
c
=
>
panic
!
(
"
unknown
return
code
:
{
}
"
c
)
}
}
pub
fn
compress_vec
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
Vec
<
u8
>
flush
:
Flush
)
-
>
Status
{
let
cap
=
output
.
capacity
(
)
;
let
len
=
output
.
len
(
)
;
unsafe
{
let
before
=
self
.
total_out
(
)
;
let
ret
=
{
let
ptr
=
output
.
as_mut_ptr
(
)
.
offset
(
len
as
isize
)
;
let
out
=
slice
:
:
from_raw_parts_mut
(
ptr
cap
-
len
)
;
self
.
compress
(
input
out
flush
)
}
;
output
.
set_len
(
(
self
.
total_out
(
)
-
before
)
as
usize
+
len
)
;
return
ret
}
}
}
impl
Decompress
{
pub
fn
new
(
zlib_header
:
bool
)
-
>
Decompress
{
unsafe
{
let
mut
state
=
ffi
:
:
StreamWrapper
:
:
default
(
)
;
let
ret
=
ffi
:
:
mz_inflateInit2
(
&
mut
*
state
if
zlib_header
{
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
}
else
{
-
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
}
)
;
debug_assert_eq
!
(
ret
0
)
;
Decompress
{
inner
:
Stream
{
stream_wrapper
:
state
total_in
:
0
total_out
:
0
_marker
:
marker
:
:
PhantomData
}
}
}
}
pub
fn
total_in
(
&
self
)
-
>
u64
{
self
.
inner
.
total_in
}
pub
fn
total_out
(
&
self
)
-
>
u64
{
self
.
inner
.
total_out
}
pub
fn
decompress
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
flush
:
Flush
)
-
>
Result
<
Status
DataError
>
{
let
raw
=
&
mut
*
self
.
inner
.
stream_wrapper
;
raw
.
next_in
=
input
.
as_ptr
(
)
as
*
mut
u8
;
raw
.
avail_in
=
input
.
len
(
)
as
c_uint
;
raw
.
next_out
=
output
.
as_mut_ptr
(
)
;
raw
.
avail_out
=
output
.
len
(
)
as
c_uint
;
let
rc
=
unsafe
{
ffi
:
:
mz_inflate
(
raw
flush
as
c_int
)
}
;
self
.
inner
.
total_in
+
=
(
raw
.
next_in
as
usize
-
input
.
as_ptr
(
)
as
usize
)
as
u64
;
self
.
inner
.
total_out
+
=
(
raw
.
next_out
as
usize
-
output
.
as_ptr
(
)
as
usize
)
as
u64
;
match
rc
{
ffi
:
:
MZ_DATA_ERROR
|
ffi
:
:
MZ_STREAM_ERROR
=
>
Err
(
DataError
(
(
)
)
)
ffi
:
:
MZ_OK
=
>
Ok
(
Status
:
:
Ok
)
ffi
:
:
MZ_BUF_ERROR
=
>
Ok
(
Status
:
:
BufError
)
ffi
:
:
MZ_STREAM_END
=
>
Ok
(
Status
:
:
StreamEnd
)
c
=
>
panic
!
(
"
unknown
return
code
:
{
}
"
c
)
}
}
pub
fn
decompress_vec
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
Vec
<
u8
>
flush
:
Flush
)
-
>
Result
<
Status
DataError
>
{
let
cap
=
output
.
capacity
(
)
;
let
len
=
output
.
len
(
)
;
unsafe
{
let
before
=
self
.
total_out
(
)
;
let
ret
=
{
let
ptr
=
output
.
as_mut_ptr
(
)
.
offset
(
len
as
isize
)
;
let
out
=
slice
:
:
from_raw_parts_mut
(
ptr
cap
-
len
)
;
self
.
decompress
(
input
out
flush
)
}
;
output
.
set_len
(
(
self
.
total_out
(
)
-
before
)
as
usize
+
len
)
;
return
ret
}
}
pub
fn
reset
(
&
mut
self
zlib_header
:
bool
)
{
self
.
_reset
(
zlib_header
)
;
}
#
[
cfg
(
feature
=
"
zlib
"
)
]
fn
_reset
(
&
mut
self
zlib_header
:
bool
)
{
let
bits
=
if
zlib_header
{
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
}
else
{
-
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
}
;
unsafe
{
ffi
:
:
inflateReset2
(
&
mut
*
self
.
inner
.
stream_wrapper
bits
)
;
}
self
.
inner
.
total_out
=
0
;
self
.
inner
.
total_in
=
0
;
}
#
[
cfg
(
not
(
feature
=
"
zlib
"
)
)
]
fn
_reset
(
&
mut
self
zlib_header
:
bool
)
{
*
self
=
Decompress
:
:
new
(
zlib_header
)
;
}
}
impl
Error
for
DataError
{
fn
description
(
&
self
)
-
>
&
str
{
"
deflate
data
error
"
}
}
impl
From
<
DataError
>
for
io
:
:
Error
{
fn
from
(
data
:
DataError
)
-
>
io
:
:
Error
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
data
)
}
}
impl
fmt
:
:
Display
for
DataError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
description
(
)
.
fmt
(
f
)
}
}
impl
Direction
for
DirCompress
{
unsafe
fn
destroy
(
stream
:
*
mut
ffi
:
:
mz_stream
)
-
>
c_int
{
ffi
:
:
mz_deflateEnd
(
stream
)
}
}
impl
Direction
for
DirDecompress
{
unsafe
fn
destroy
(
stream
:
*
mut
ffi
:
:
mz_stream
)
-
>
c_int
{
ffi
:
:
mz_inflateEnd
(
stream
)
}
}
impl
<
D
:
Direction
>
Drop
for
Stream
<
D
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
_
=
D
:
:
destroy
(
&
mut
*
self
.
stream_wrapper
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
io
:
:
Write
;
use
write
;
use
{
Compression
Decompress
Flush
}
;
#
[
test
]
fn
issue51
(
)
{
let
data
=
vec
!
[
0x1f
0x8b
0x08
0x00
0x00
0x00
0x00
0x00
0x00
0x03
0xb3
0xc9
0x28
0xc9
0xcd
0xb1
0xe3
0xe5
0xb2
0xc9
0x48
0x4d
0x4c
0xb1
0xb3
0x29
0xc9
0x2c
0xc9
0x49
0xb5
0x33
0x31
0x30
0x51
0xf0
0xcb
0x2f
0x51
0x70
0xcb
0x2f
0xcd
0x4b
0xb1
0xd1
0x87
0x08
0xda
0xe8
0x83
0x95
0x00
0x95
0x26
0xe5
0xa7
0x54
0x2a
0x24
0xa5
0x27
0xe7
0xe7
0xe4
0x17
0xd9
0x2a
0x95
0x67
0x64
0x96
0xa4
0x2a
0x81
0x8c
0x48
0x4e
0xcd
0x2b
0x49
0x2d
0xb2
0xb3
0xc9
0x30
0x44
0x37
0x01
0x28
0x62
0xa3
0x0f
0x95
0x06
0xd9
0x05
0x54
0x04
0xe5
0xe5
0xa5
0x67
0xe6
0x55
0xe8
0x1b
0xea
0x99
0xe9
0x19
0x21
0xab
0xd0
0x07
0xd9
0x01
0x32
0x53
0x1f
0xea
0x3e
0x00
0x94
0x85
0xeb
0xe4
0xa8
0x00
0x00
0x00
]
;
let
mut
decoded
=
Vec
:
:
with_capacity
(
data
.
len
(
)
*
2
)
;
let
mut
d
=
Decompress
:
:
new
(
false
)
;
assert
!
(
d
.
decompress_vec
(
&
data
[
10
.
.
]
&
mut
decoded
Flush
:
:
Finish
)
.
is_ok
(
)
)
;
drop
(
d
.
decompress_vec
(
&
[
0
]
&
mut
decoded
Flush
:
:
None
)
)
;
}
#
[
test
]
fn
reset
(
)
{
let
string
=
"
hello
world
"
.
as_bytes
(
)
;
let
mut
zlib
=
Vec
:
:
new
(
)
;
let
mut
deflate
=
Vec
:
:
new
(
)
;
let
comp
=
Compression
:
:
Default
;
write
:
:
ZlibEncoder
:
:
new
(
&
mut
zlib
comp
)
.
write_all
(
string
)
.
unwrap
(
)
;
write
:
:
DeflateEncoder
:
:
new
(
&
mut
deflate
comp
)
.
write_all
(
string
)
.
unwrap
(
)
;
let
mut
dst
=
[
0
;
1024
]
;
let
mut
decoder
=
Decompress
:
:
new
(
true
)
;
decoder
.
decompress
(
&
zlib
&
mut
dst
Flush
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
decoder
.
total_out
(
)
string
.
len
(
)
as
u64
)
;
assert
!
(
dst
.
starts_with
(
string
)
)
;
decoder
.
reset
(
false
)
;
decoder
.
decompress
(
&
deflate
&
mut
dst
Flush
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
decoder
.
total_out
(
)
string
.
len
(
)
as
u64
)
;
assert
!
(
dst
.
starts_with
(
string
)
)
;
}
}
