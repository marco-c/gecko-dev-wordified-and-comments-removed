use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
crate
:
:
ffi
:
:
{
self
Backend
Deflate
DeflateBackend
ErrorMessage
Inflate
InflateBackend
}
;
use
crate
:
:
Compression
;
#
[
derive
(
Debug
)
]
pub
struct
Compress
{
inner
:
Deflate
}
#
[
derive
(
Debug
)
]
pub
struct
Decompress
{
inner
:
Inflate
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
#
[
non_exhaustive
]
pub
enum
FlushCompress
{
None
=
ffi
:
:
MZ_NO_FLUSH
as
isize
Sync
=
ffi
:
:
MZ_SYNC_FLUSH
as
isize
Partial
=
ffi
:
:
MZ_PARTIAL_FLUSH
as
isize
Full
=
ffi
:
:
MZ_FULL_FLUSH
as
isize
Finish
=
ffi
:
:
MZ_FINISH
as
isize
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
#
[
non_exhaustive
]
pub
enum
FlushDecompress
{
None
=
ffi
:
:
MZ_NO_FLUSH
as
isize
Sync
=
ffi
:
:
MZ_SYNC_FLUSH
as
isize
Finish
=
ffi
:
:
MZ_FINISH
as
isize
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
DecompressErrorInner
{
General
{
msg
:
ErrorMessage
}
NeedsDictionary
(
u32
)
}
#
[
derive
(
Debug
)
]
pub
struct
DecompressError
(
pub
(
crate
)
DecompressErrorInner
)
;
impl
DecompressError
{
pub
fn
needs_dictionary
(
&
self
)
-
>
Option
<
u32
>
{
match
self
.
0
{
DecompressErrorInner
:
:
NeedsDictionary
(
adler
)
=
>
Some
(
adler
)
_
=
>
None
}
}
}
#
[
inline
]
pub
(
crate
)
fn
decompress_failed
<
T
>
(
msg
:
ErrorMessage
)
-
>
Result
<
T
DecompressError
>
{
Err
(
DecompressError
(
DecompressErrorInner
:
:
General
{
msg
}
)
)
}
#
[
inline
]
pub
(
crate
)
fn
decompress_need_dict
<
T
>
(
adler
:
u32
)
-
>
Result
<
T
DecompressError
>
{
Err
(
DecompressError
(
DecompressErrorInner
:
:
NeedsDictionary
(
adler
)
)
)
}
#
[
derive
(
Debug
)
]
pub
struct
CompressError
{
pub
(
crate
)
msg
:
ErrorMessage
}
#
[
inline
]
pub
(
crate
)
fn
compress_failed
<
T
>
(
msg
:
ErrorMessage
)
-
>
Result
<
T
CompressError
>
{
Err
(
CompressError
{
msg
}
)
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
Status
{
Ok
BufError
StreamEnd
}
impl
Compress
{
pub
fn
new
(
level
:
Compression
zlib_header
:
bool
)
-
>
Compress
{
Compress
{
inner
:
Deflate
:
:
make
(
level
zlib_header
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
as
u8
)
}
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
new_with_window_bits
(
level
:
Compression
zlib_header
:
bool
window_bits
:
u8
)
-
>
Compress
{
assert
!
(
window_bits
>
8
&
&
window_bits
<
16
"
window_bits
must
be
within
9
.
.
=
15
"
)
;
Compress
{
inner
:
Deflate
:
:
make
(
level
zlib_header
window_bits
)
}
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
new_gzip
(
level
:
Compression
window_bits
:
u8
)
-
>
Compress
{
assert
!
(
window_bits
>
8
&
&
window_bits
<
16
"
window_bits
must
be
within
9
.
.
=
15
"
)
;
Compress
{
inner
:
Deflate
:
:
make
(
level
true
window_bits
+
16
)
}
}
pub
fn
total_in
(
&
self
)
-
>
u64
{
self
.
inner
.
total_in
(
)
}
pub
fn
total_out
(
&
self
)
-
>
u64
{
self
.
inner
.
total_out
(
)
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
set_dictionary
(
&
mut
self
dictionary
:
&
[
u8
]
)
-
>
Result
<
u32
CompressError
>
{
let
stream
=
self
.
inner
.
inner
.
stream_wrapper
.
inner
;
let
rc
=
unsafe
{
(
*
stream
)
.
msg
=
std
:
:
ptr
:
:
null_mut
(
)
;
assert
!
(
dictionary
.
len
(
)
<
ffi
:
:
uInt
:
:
MAX
as
usize
)
;
ffi
:
:
deflateSetDictionary
(
stream
dictionary
.
as_ptr
(
)
dictionary
.
len
(
)
as
ffi
:
:
uInt
)
}
;
match
rc
{
ffi
:
:
MZ_STREAM_ERROR
=
>
compress_failed
(
self
.
inner
.
inner
.
msg
(
)
)
ffi
:
:
MZ_OK
=
>
Ok
(
unsafe
{
(
*
stream
)
.
adler
}
as
u32
)
c
=
>
panic
!
(
"
unknown
return
code
:
{
}
"
c
)
}
}
pub
fn
reset
(
&
mut
self
)
{
self
.
inner
.
reset
(
)
;
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
set_level
(
&
mut
self
level
:
Compression
)
-
>
Result
<
(
)
CompressError
>
{
use
std
:
:
os
:
:
raw
:
:
c_int
;
let
stream
=
self
.
inner
.
inner
.
stream_wrapper
.
inner
;
unsafe
{
(
*
stream
)
.
msg
=
std
:
:
ptr
:
:
null_mut
(
)
;
}
let
rc
=
unsafe
{
ffi
:
:
deflateParams
(
stream
level
.
0
as
c_int
ffi
:
:
MZ_DEFAULT_STRATEGY
)
}
;
match
rc
{
ffi
:
:
MZ_OK
=
>
Ok
(
(
)
)
ffi
:
:
MZ_BUF_ERROR
=
>
compress_failed
(
self
.
inner
.
inner
.
msg
(
)
)
c
=
>
panic
!
(
"
unknown
return
code
:
{
}
"
c
)
}
}
pub
fn
compress
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
flush
:
FlushCompress
)
-
>
Result
<
Status
CompressError
>
{
self
.
inner
.
compress
(
input
output
flush
)
}
pub
fn
compress_vec
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
Vec
<
u8
>
flush
:
FlushCompress
)
-
>
Result
<
Status
CompressError
>
{
write_to_spare_capacity_of_vec
(
output
|
out
|
{
let
before
=
self
.
total_out
(
)
;
let
ret
=
self
.
compress
(
input
out
flush
)
;
let
bytes_written
=
self
.
total_out
(
)
-
before
;
(
bytes_written
as
usize
ret
)
}
)
}
}
impl
Decompress
{
pub
fn
new
(
zlib_header
:
bool
)
-
>
Decompress
{
Decompress
{
inner
:
Inflate
:
:
make
(
zlib_header
ffi
:
:
MZ_DEFAULT_WINDOW_BITS
as
u8
)
}
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
new_with_window_bits
(
zlib_header
:
bool
window_bits
:
u8
)
-
>
Decompress
{
assert
!
(
window_bits
>
8
&
&
window_bits
<
16
"
window_bits
must
be
within
9
.
.
=
15
"
)
;
Decompress
{
inner
:
Inflate
:
:
make
(
zlib_header
window_bits
)
}
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
new_gzip
(
window_bits
:
u8
)
-
>
Decompress
{
assert
!
(
window_bits
>
8
&
&
window_bits
<
16
"
window_bits
must
be
within
9
.
.
=
15
"
)
;
Decompress
{
inner
:
Inflate
:
:
make
(
true
window_bits
+
16
)
}
}
pub
fn
total_in
(
&
self
)
-
>
u64
{
self
.
inner
.
total_in
(
)
}
pub
fn
total_out
(
&
self
)
-
>
u64
{
self
.
inner
.
total_out
(
)
}
pub
fn
decompress
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
flush
:
FlushDecompress
)
-
>
Result
<
Status
DecompressError
>
{
self
.
inner
.
decompress
(
input
output
flush
)
}
pub
fn
decompress_vec
(
&
mut
self
input
:
&
[
u8
]
output
:
&
mut
Vec
<
u8
>
flush
:
FlushDecompress
)
-
>
Result
<
Status
DecompressError
>
{
write_to_spare_capacity_of_vec
(
output
|
out
|
{
let
before
=
self
.
total_out
(
)
;
let
ret
=
self
.
decompress
(
input
out
flush
)
;
let
bytes_written
=
self
.
total_out
(
)
-
before
;
(
bytes_written
as
usize
ret
)
}
)
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
pub
fn
set_dictionary
(
&
mut
self
dictionary
:
&
[
u8
]
)
-
>
Result
<
u32
DecompressError
>
{
let
stream
=
self
.
inner
.
inner
.
stream_wrapper
.
inner
;
let
rc
=
unsafe
{
(
*
stream
)
.
msg
=
std
:
:
ptr
:
:
null_mut
(
)
;
assert
!
(
dictionary
.
len
(
)
<
ffi
:
:
uInt
:
:
MAX
as
usize
)
;
ffi
:
:
inflateSetDictionary
(
stream
dictionary
.
as_ptr
(
)
dictionary
.
len
(
)
as
ffi
:
:
uInt
)
}
;
match
rc
{
ffi
:
:
MZ_STREAM_ERROR
=
>
decompress_failed
(
self
.
inner
.
inner
.
msg
(
)
)
ffi
:
:
MZ_DATA_ERROR
=
>
decompress_need_dict
(
unsafe
{
(
*
stream
)
.
adler
}
as
u32
)
ffi
:
:
MZ_OK
=
>
Ok
(
unsafe
{
(
*
stream
)
.
adler
}
as
u32
)
c
=
>
panic
!
(
"
unknown
return
code
:
{
}
"
c
)
}
}
pub
fn
reset
(
&
mut
self
zlib_header
:
bool
)
{
self
.
inner
.
reset
(
zlib_header
)
;
}
}
impl
Error
for
DecompressError
{
}
impl
DecompressError
{
pub
fn
message
(
&
self
)
-
>
Option
<
&
str
>
{
match
&
self
.
0
{
DecompressErrorInner
:
:
General
{
msg
}
=
>
msg
.
get
(
)
_
=
>
None
}
}
}
impl
From
<
DecompressError
>
for
io
:
:
Error
{
fn
from
(
data
:
DecompressError
)
-
>
io
:
:
Error
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
data
)
}
}
impl
fmt
:
:
Display
for
DecompressError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
msg
=
match
&
self
.
0
{
DecompressErrorInner
:
:
General
{
msg
}
=
>
msg
.
get
(
)
DecompressErrorInner
:
:
NeedsDictionary
{
.
.
}
=
>
Some
(
"
requires
a
dictionary
"
)
}
;
match
msg
{
Some
(
msg
)
=
>
write
!
(
f
"
deflate
decompression
error
:
{
}
"
msg
)
None
=
>
write
!
(
f
"
deflate
decompression
error
"
)
}
}
}
impl
Error
for
CompressError
{
}
impl
CompressError
{
pub
fn
message
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
msg
.
get
(
)
}
}
impl
From
<
CompressError
>
for
io
:
:
Error
{
fn
from
(
data
:
CompressError
)
-
>
io
:
:
Error
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
data
)
}
}
impl
fmt
:
:
Display
for
CompressError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
msg
.
get
(
)
{
Some
(
msg
)
=
>
write
!
(
f
"
deflate
compression
error
:
{
}
"
msg
)
None
=
>
write
!
(
f
"
deflate
compression
error
"
)
}
}
}
fn
write_to_spare_capacity_of_vec
<
T
>
(
output
:
&
mut
Vec
<
u8
>
writer
:
impl
FnOnce
(
&
mut
[
u8
]
)
-
>
(
usize
T
)
)
-
>
T
{
let
cap
=
output
.
capacity
(
)
;
let
len
=
output
.
len
(
)
;
output
.
resize
(
output
.
capacity
(
)
0
)
;
let
(
bytes_written
ret
)
=
writer
(
&
mut
output
[
len
.
.
]
)
;
let
new_len
=
core
:
:
cmp
:
:
min
(
len
+
bytes_written
cap
)
;
output
.
resize
(
new_len
0
)
;
ret
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
io
:
:
Write
;
use
crate
:
:
write
;
use
crate
:
:
{
Compression
Decompress
FlushDecompress
}
;
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
use
crate
:
:
{
Compress
FlushCompress
}
;
#
[
test
]
fn
issue51
(
)
{
let
data
=
vec
!
[
0x1f
0x8b
0x08
0x00
0x00
0x00
0x00
0x00
0x00
0x03
0xb3
0xc9
0x28
0xc9
0xcd
0xb1
0xe3
0xe5
0xb2
0xc9
0x48
0x4d
0x4c
0xb1
0xb3
0x29
0xc9
0x2c
0xc9
0x49
0xb5
0x33
0x31
0x30
0x51
0xf0
0xcb
0x2f
0x51
0x70
0xcb
0x2f
0xcd
0x4b
0xb1
0xd1
0x87
0x08
0xda
0xe8
0x83
0x95
0x00
0x95
0x26
0xe5
0xa7
0x54
0x2a
0x24
0xa5
0x27
0xe7
0xe7
0xe4
0x17
0xd9
0x2a
0x95
0x67
0x64
0x96
0xa4
0x2a
0x81
0x8c
0x48
0x4e
0xcd
0x2b
0x49
0x2d
0xb2
0xb3
0xc9
0x30
0x44
0x37
0x01
0x28
0x62
0xa3
0x0f
0x95
0x06
0xd9
0x05
0x54
0x04
0xe5
0xe5
0xa5
0x67
0xe6
0x55
0xe8
0x1b
0xea
0x99
0xe9
0x19
0x21
0xab
0xd0
0x07
0xd9
0x01
0x32
0x53
0x1f
0xea
0x3e
0x00
0x94
0x85
0xeb
0xe4
0xa8
0x00
0x00
0x00
]
;
let
mut
decoded
=
Vec
:
:
with_capacity
(
data
.
len
(
)
*
2
)
;
let
mut
d
=
Decompress
:
:
new
(
false
)
;
assert
!
(
d
.
decompress_vec
(
&
data
[
10
.
.
]
&
mut
decoded
FlushDecompress
:
:
Finish
)
.
is_ok
(
)
)
;
drop
(
d
.
decompress_vec
(
&
[
0
]
&
mut
decoded
FlushDecompress
:
:
None
)
)
;
}
#
[
test
]
fn
reset
(
)
{
let
string
=
"
hello
world
"
.
as_bytes
(
)
;
let
mut
zlib
=
Vec
:
:
new
(
)
;
let
mut
deflate
=
Vec
:
:
new
(
)
;
let
comp
=
Compression
:
:
default
(
)
;
write
:
:
ZlibEncoder
:
:
new
(
&
mut
zlib
comp
)
.
write_all
(
string
)
.
unwrap
(
)
;
write
:
:
DeflateEncoder
:
:
new
(
&
mut
deflate
comp
)
.
write_all
(
string
)
.
unwrap
(
)
;
let
mut
dst
=
[
0
;
1024
]
;
let
mut
decoder
=
Decompress
:
:
new
(
true
)
;
decoder
.
decompress
(
&
zlib
&
mut
dst
FlushDecompress
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
decoder
.
total_out
(
)
string
.
len
(
)
as
u64
)
;
assert
!
(
dst
.
starts_with
(
string
)
)
;
decoder
.
reset
(
false
)
;
decoder
.
decompress
(
&
deflate
&
mut
dst
FlushDecompress
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
decoder
.
total_out
(
)
string
.
len
(
)
as
u64
)
;
assert
!
(
dst
.
starts_with
(
string
)
)
;
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
#
[
test
]
fn
set_dictionary_with_zlib_header
(
)
{
let
string
=
"
hello
hello
!
"
.
as_bytes
(
)
;
let
dictionary
=
"
hello
"
.
as_bytes
(
)
;
let
mut
encoded
=
Vec
:
:
with_capacity
(
1024
)
;
let
mut
encoder
=
Compress
:
:
new
(
Compression
:
:
default
(
)
true
)
;
let
dictionary_adler
=
encoder
.
set_dictionary
(
&
dictionary
)
.
unwrap
(
)
;
encoder
.
compress_vec
(
string
&
mut
encoded
FlushCompress
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
encoder
.
total_in
(
)
string
.
len
(
)
as
u64
)
;
assert_eq
!
(
encoder
.
total_out
(
)
encoded
.
len
(
)
as
u64
)
;
let
mut
decoder
=
Decompress
:
:
new
(
true
)
;
let
mut
decoded
=
[
0
;
1024
]
;
let
decompress_error
=
decoder
.
decompress
(
&
encoded
&
mut
decoded
FlushDecompress
:
:
Finish
)
.
expect_err
(
"
decompression
should
fail
due
to
requiring
a
dictionary
"
)
;
let
required_adler
=
decompress_error
.
needs_dictionary
(
)
.
expect
(
"
the
first
call
to
decompress
should
indicate
a
dictionary
is
required
along
with
the
required
Adler
-
32
checksum
"
)
;
assert_eq
!
(
required_adler
dictionary_adler
"
the
Adler
-
32
checksum
should
match
the
value
when
the
dictionary
was
set
on
the
compressor
"
)
;
let
actual_adler
=
decoder
.
set_dictionary
(
&
dictionary
)
.
unwrap
(
)
;
assert_eq
!
(
required_adler
actual_adler
)
;
let
total_in
=
decoder
.
total_in
(
)
;
let
total_out
=
decoder
.
total_out
(
)
;
let
decompress_result
=
decoder
.
decompress
(
&
encoded
[
total_in
as
usize
.
.
]
&
mut
decoded
[
total_out
as
usize
.
.
]
FlushDecompress
:
:
Finish
)
;
assert
!
(
decompress_result
.
is_ok
(
)
)
;
assert_eq
!
(
&
decoded
[
.
.
decoder
.
total_out
(
)
as
usize
]
string
)
;
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
#
[
test
]
fn
set_dictionary_raw
(
)
{
let
string
=
"
hello
hello
!
"
.
as_bytes
(
)
;
let
dictionary
=
"
hello
"
.
as_bytes
(
)
;
let
mut
encoded
=
Vec
:
:
with_capacity
(
1024
)
;
let
mut
encoder
=
Compress
:
:
new
(
Compression
:
:
default
(
)
false
)
;
encoder
.
set_dictionary
(
&
dictionary
)
.
unwrap
(
)
;
encoder
.
compress_vec
(
string
&
mut
encoded
FlushCompress
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
encoder
.
total_in
(
)
string
.
len
(
)
as
u64
)
;
assert_eq
!
(
encoder
.
total_out
(
)
encoded
.
len
(
)
as
u64
)
;
let
mut
decoder
=
Decompress
:
:
new
(
false
)
;
decoder
.
set_dictionary
(
&
dictionary
)
.
unwrap
(
)
;
let
mut
decoded
=
[
0
;
1024
]
;
let
decompress_result
=
decoder
.
decompress
(
&
encoded
&
mut
decoded
FlushDecompress
:
:
Finish
)
;
assert
!
(
decompress_result
.
is_ok
(
)
)
;
assert_eq
!
(
&
decoded
[
.
.
decoder
.
total_out
(
)
as
usize
]
string
)
;
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
#
[
test
]
fn
test_gzip_flate
(
)
{
let
string
=
"
hello
hello
!
"
.
as_bytes
(
)
;
let
mut
encoded
=
Vec
:
:
with_capacity
(
1024
)
;
let
mut
encoder
=
Compress
:
:
new_gzip
(
Compression
:
:
default
(
)
9
)
;
encoder
.
compress_vec
(
string
&
mut
encoded
FlushCompress
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
encoder
.
total_in
(
)
string
.
len
(
)
as
u64
)
;
assert_eq
!
(
encoder
.
total_out
(
)
encoded
.
len
(
)
as
u64
)
;
let
mut
decoder
=
Decompress
:
:
new_gzip
(
9
)
;
let
mut
decoded
=
[
0
;
1024
]
;
decoder
.
decompress
(
&
encoded
&
mut
decoded
FlushDecompress
:
:
Finish
)
.
unwrap
(
)
;
assert_eq
!
(
&
decoded
[
.
.
decoder
.
total_out
(
)
as
usize
]
string
)
;
}
#
[
cfg
(
feature
=
"
any_zlib
"
)
]
#
[
test
]
fn
test_error_message
(
)
{
let
mut
decoder
=
Decompress
:
:
new
(
false
)
;
let
mut
decoded
=
[
0
;
128
]
;
let
garbage
=
b
"
xbvxzi
"
;
let
err
=
decoder
.
decompress
(
&
*
garbage
&
mut
decoded
FlushDecompress
:
:
Finish
)
.
unwrap_err
(
)
;
assert_eq
!
(
err
.
message
(
)
Some
(
"
invalid
stored
block
lengths
"
)
)
;
}
}
