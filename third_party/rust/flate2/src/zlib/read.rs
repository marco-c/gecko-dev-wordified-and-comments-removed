use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
;
#
[
cfg
(
feature
=
"
tokio
"
)
]
use
futures
:
:
Poll
;
#
[
cfg
(
feature
=
"
tokio
"
)
]
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
bufreader
:
:
BufReader
;
use
super
:
:
bufread
;
#
[
derive
(
Debug
)
]
pub
struct
ZlibEncoder
<
R
>
{
inner
:
bufread
:
:
ZlibEncoder
<
BufReader
<
R
>
>
}
impl
<
R
:
Read
>
ZlibEncoder
<
R
>
{
pub
fn
new
(
r
:
R
level
:
:
:
Compression
)
-
>
ZlibEncoder
<
R
>
{
ZlibEncoder
{
inner
:
bufread
:
:
ZlibEncoder
:
:
new
(
BufReader
:
:
new
(
r
)
level
)
}
}
}
impl
<
R
>
ZlibEncoder
<
R
>
{
pub
fn
reset
(
&
mut
self
r
:
R
)
-
>
R
{
super
:
:
bufread
:
:
reset_encoder_data
(
&
mut
self
.
inner
)
;
self
.
inner
.
get_mut
(
)
.
reset
(
r
)
}
pub
fn
get_ref
(
&
self
)
-
>
&
R
{
self
.
inner
.
get_ref
(
)
.
get_ref
(
)
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
self
.
inner
.
get_mut
(
)
.
get_mut
(
)
}
pub
fn
into_inner
(
self
)
-
>
R
{
self
.
inner
.
into_inner
(
)
.
into_inner
(
)
}
pub
fn
total_in
(
&
self
)
-
>
u64
{
self
.
inner
.
total_in
(
)
}
pub
fn
total_out
(
&
self
)
-
>
u64
{
self
.
inner
.
total_out
(
)
}
}
impl
<
R
:
Read
>
Read
for
ZlibEncoder
<
R
>
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
inner
.
read
(
buf
)
}
}
#
[
cfg
(
feature
=
"
tokio
"
)
]
impl
<
R
:
AsyncRead
>
AsyncRead
for
ZlibEncoder
<
R
>
{
}
impl
<
W
:
Read
+
Write
>
Write
for
ZlibEncoder
<
W
>
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
get_mut
(
)
.
write
(
buf
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
get_mut
(
)
.
flush
(
)
}
}
#
[
cfg
(
feature
=
"
tokio
"
)
]
impl
<
R
:
AsyncRead
+
AsyncWrite
>
AsyncWrite
for
ZlibEncoder
<
R
>
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
self
.
get_mut
(
)
.
shutdown
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ZlibDecoder
<
R
>
{
inner
:
bufread
:
:
ZlibDecoder
<
BufReader
<
R
>
>
}
impl
<
R
:
Read
>
ZlibDecoder
<
R
>
{
pub
fn
new
(
r
:
R
)
-
>
ZlibDecoder
<
R
>
{
ZlibDecoder
:
:
new_with_buf
(
r
vec
!
[
0
;
32
*
1024
]
)
}
pub
fn
new_with_buf
(
r
:
R
buf
:
Vec
<
u8
>
)
-
>
ZlibDecoder
<
R
>
{
ZlibDecoder
{
inner
:
bufread
:
:
ZlibDecoder
:
:
new
(
BufReader
:
:
with_buf
(
buf
r
)
)
}
}
}
impl
<
R
>
ZlibDecoder
<
R
>
{
pub
fn
reset
(
&
mut
self
r
:
R
)
-
>
R
{
super
:
:
bufread
:
:
reset_decoder_data
(
&
mut
self
.
inner
)
;
self
.
inner
.
get_mut
(
)
.
reset
(
r
)
}
pub
fn
get_ref
(
&
self
)
-
>
&
R
{
self
.
inner
.
get_ref
(
)
.
get_ref
(
)
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
R
{
self
.
inner
.
get_mut
(
)
.
get_mut
(
)
}
pub
fn
into_inner
(
self
)
-
>
R
{
self
.
inner
.
into_inner
(
)
.
into_inner
(
)
}
pub
fn
total_in
(
&
self
)
-
>
u64
{
self
.
inner
.
total_in
(
)
}
pub
fn
total_out
(
&
self
)
-
>
u64
{
self
.
inner
.
total_out
(
)
}
}
impl
<
R
:
Read
>
Read
for
ZlibDecoder
<
R
>
{
fn
read
(
&
mut
self
into
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
inner
.
read
(
into
)
}
}
#
[
cfg
(
feature
=
"
tokio
"
)
]
impl
<
R
:
AsyncRead
>
AsyncRead
for
ZlibDecoder
<
R
>
{
}
impl
<
R
:
Read
+
Write
>
Write
for
ZlibDecoder
<
R
>
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
get_mut
(
)
.
write
(
buf
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
get_mut
(
)
.
flush
(
)
}
}
#
[
cfg
(
feature
=
"
tokio
"
)
]
impl
<
R
:
AsyncWrite
+
AsyncRead
>
AsyncWrite
for
ZlibDecoder
<
R
>
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
self
.
get_mut
(
)
.
shutdown
(
)
}
}
