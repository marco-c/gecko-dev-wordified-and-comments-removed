use
lib
:
:
*
;
mod
fmt
;
mod
impls
;
mod
impossible
;
pub
use
self
:
:
impossible
:
:
Impossible
;
#
[
cfg
(
all
(
feature
=
"
unstable
"
not
(
feature
=
"
std
"
)
)
)
]
#
[
doc
(
inline
)
]
pub
use
core
:
:
error
:
:
Error
as
StdError
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
doc
(
no_inline
)
]
pub
use
std
:
:
error
:
:
Error
as
StdError
;
#
[
cfg
(
not
(
any
(
feature
=
"
std
"
feature
=
"
unstable
"
)
)
)
]
#
[
doc
(
no_inline
)
]
pub
use
std_error
:
:
Error
as
StdError
;
macro_rules
!
declare_error_trait
{
(
Error
:
Sized
(
+
(
supertrait
:
ident
)
:
:
+
)
*
)
=
>
{
/
/
/
Trait
used
by
Serialize
implementations
to
generically
construct
/
/
/
errors
belonging
to
the
Serializer
against
which
they
are
/
/
/
currently
running
.
/
/
/
/
/
/
#
Example
implementation
/
/
/
/
/
/
The
[
example
data
format
]
presented
on
the
website
shows
an
error
/
/
/
type
appropriate
for
a
basic
JSON
data
format
.
/
/
/
/
/
/
[
example
data
format
]
:
https
:
/
/
serde
.
rs
/
data
-
format
.
html
pub
trait
Error
:
Sized
(
+
(
supertrait
)
:
:
+
)
*
{
/
/
/
Used
when
a
[
Serialize
]
implementation
encounters
any
error
/
/
/
while
serializing
a
type
.
/
/
/
/
/
/
The
message
should
not
be
capitalized
and
should
not
end
with
a
/
/
/
period
.
/
/
/
/
/
/
For
example
a
filesystem
[
Path
]
may
refuse
to
serialize
/
/
/
itself
if
it
contains
invalid
UTF
-
8
data
.
/
/
/
/
/
/
edition2018
/
/
/
#
struct
Path
;
/
/
/
#
/
/
/
#
impl
Path
{
/
/
/
#
fn
to_str
(
&
self
)
-
>
Option
<
&
str
>
{
/
/
/
#
unimplemented
!
(
)
/
/
/
#
}
/
/
/
#
}
/
/
/
#
/
/
/
use
serde
:
:
ser
:
:
{
self
Serialize
Serializer
}
;
/
/
/
/
/
/
impl
Serialize
for
Path
{
/
/
/
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
/
/
/
where
/
/
/
S
:
Serializer
/
/
/
{
/
/
/
match
self
.
to_str
(
)
{
/
/
/
Some
(
s
)
=
>
serializer
.
serialize_str
(
s
)
/
/
/
None
=
>
Err
(
ser
:
:
Error
:
:
custom
(
"
path
contains
invalid
UTF
-
8
characters
"
)
)
/
/
/
}
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
/
[
Path
]
:
https
:
/
/
doc
.
rust
-
lang
.
org
/
std
/
path
/
struct
.
Path
.
html
/
/
/
[
Serialize
]
:
.
.
/
trait
.
Serialize
.
html
fn
custom
<
T
>
(
msg
:
T
)
-
>
Self
where
T
:
Display
;
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
declare_error_trait
!
(
Error
:
Sized
+
StdError
)
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
declare_error_trait
!
(
Error
:
Sized
+
Debug
+
Display
)
;
pub
trait
Serialize
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
;
}
pub
trait
Serializer
:
Sized
{
type
Ok
;
type
Error
:
Error
;
type
SerializeSeq
:
SerializeSeq
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
type
SerializeTuple
:
SerializeTuple
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
type
SerializeTupleStruct
:
SerializeTupleStruct
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
type
SerializeTupleVariant
:
SerializeTupleVariant
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
type
SerializeMap
:
SerializeMap
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
type
SerializeStruct
:
SerializeStruct
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
type
SerializeStructVariant
:
SerializeStructVariant
<
Ok
=
Self
:
:
Ok
Error
=
Self
:
:
Error
>
;
fn
serialize_bool
(
self
v
:
bool
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_i8
(
self
v
:
i8
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_i16
(
self
v
:
i16
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_i32
(
self
v
:
i32
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_i64
(
self
v
:
i64
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
serde_if_integer128
!
{
/
/
/
Serialize
an
i128
value
.
/
/
/
/
/
/
edition2018
/
/
/
#
use
serde
:
:
Serializer
;
/
/
/
#
/
/
/
#
serde
:
:
__private_serialize
!
(
)
;
/
/
/
#
/
/
/
impl
Serialize
for
i128
{
/
/
/
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
/
/
/
where
/
/
/
S
:
Serializer
/
/
/
{
/
/
/
serializer
.
serialize_i128
(
*
self
)
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
/
This
method
is
available
only
on
Rust
compiler
versions
>
=
1
.
26
.
The
/
/
/
default
behavior
unconditionally
returns
an
error
.
fn
serialize_i128
(
self
v
:
i128
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
{
let
_
=
v
;
Err
(
Error
:
:
custom
(
"
i128
is
not
supported
"
)
)
}
}
fn
serialize_u8
(
self
v
:
u8
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_u16
(
self
v
:
u16
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_u32
(
self
v
:
u32
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_u64
(
self
v
:
u64
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
serde_if_integer128
!
{
/
/
/
Serialize
a
u128
value
.
/
/
/
/
/
/
edition2018
/
/
/
#
use
serde
:
:
Serializer
;
/
/
/
#
/
/
/
#
serde
:
:
__private_serialize
!
(
)
;
/
/
/
#
/
/
/
impl
Serialize
for
u128
{
/
/
/
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
/
/
/
where
/
/
/
S
:
Serializer
/
/
/
{
/
/
/
serializer
.
serialize_u128
(
*
self
)
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
/
This
method
is
available
only
on
Rust
compiler
versions
>
=
1
.
26
.
The
/
/
/
default
behavior
unconditionally
returns
an
error
.
fn
serialize_u128
(
self
v
:
u128
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
{
let
_
=
v
;
Err
(
Error
:
:
custom
(
"
u128
is
not
supported
"
)
)
}
}
fn
serialize_f32
(
self
v
:
f32
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_f64
(
self
v
:
f64
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_char
(
self
v
:
char
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_str
(
self
v
:
&
str
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_bytes
(
self
v
:
&
[
u8
]
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_none
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_some
<
T
:
?
Sized
>
(
self
value
:
&
T
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
T
:
Serialize
;
fn
serialize_unit
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_unit_struct
(
self
name
:
&
'
static
str
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_unit_variant
(
self
name
:
&
'
static
str
variant_index
:
u32
variant
:
&
'
static
str
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
fn
serialize_newtype_struct
<
T
:
?
Sized
>
(
self
name
:
&
'
static
str
value
:
&
T
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
T
:
Serialize
;
fn
serialize_newtype_variant
<
T
:
?
Sized
>
(
self
name
:
&
'
static
str
variant_index
:
u32
variant
:
&
'
static
str
value
:
&
T
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
T
:
Serialize
;
fn
serialize_seq
(
self
len
:
Option
<
usize
>
)
-
>
Result
<
Self
:
:
SerializeSeq
Self
:
:
Error
>
;
fn
serialize_tuple
(
self
len
:
usize
)
-
>
Result
<
Self
:
:
SerializeTuple
Self
:
:
Error
>
;
fn
serialize_tuple_struct
(
self
name
:
&
'
static
str
len
:
usize
)
-
>
Result
<
Self
:
:
SerializeTupleStruct
Self
:
:
Error
>
;
fn
serialize_tuple_variant
(
self
name
:
&
'
static
str
variant_index
:
u32
variant
:
&
'
static
str
len
:
usize
)
-
>
Result
<
Self
:
:
SerializeTupleVariant
Self
:
:
Error
>
;
fn
serialize_map
(
self
len
:
Option
<
usize
>
)
-
>
Result
<
Self
:
:
SerializeMap
Self
:
:
Error
>
;
fn
serialize_struct
(
self
name
:
&
'
static
str
len
:
usize
)
-
>
Result
<
Self
:
:
SerializeStruct
Self
:
:
Error
>
;
fn
serialize_struct_variant
(
self
name
:
&
'
static
str
variant_index
:
u32
variant
:
&
'
static
str
len
:
usize
)
-
>
Result
<
Self
:
:
SerializeStructVariant
Self
:
:
Error
>
;
fn
collect_seq
<
I
>
(
self
iter
:
I
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
I
:
IntoIterator
<
I
as
IntoIterator
>
:
:
Item
:
Serialize
{
let
iter
=
iter
.
into_iter
(
)
;
let
mut
serializer
=
try
!
(
self
.
serialize_seq
(
iterator_len_hint
(
&
iter
)
)
)
;
#
[
cfg
(
not
(
no_iterator_try_fold
)
)
]
{
let
mut
iter
=
iter
;
try
!
(
iter
.
try_for_each
(
|
item
|
serializer
.
serialize_element
(
&
item
)
)
)
;
}
#
[
cfg
(
no_iterator_try_fold
)
]
{
for
item
in
iter
{
try
!
(
serializer
.
serialize_element
(
&
item
)
)
;
}
}
serializer
.
end
(
)
}
fn
collect_map
<
K
V
I
>
(
self
iter
:
I
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
K
:
Serialize
V
:
Serialize
I
:
IntoIterator
<
Item
=
(
K
V
)
>
{
let
iter
=
iter
.
into_iter
(
)
;
let
mut
serializer
=
try
!
(
self
.
serialize_map
(
iterator_len_hint
(
&
iter
)
)
)
;
#
[
cfg
(
not
(
no_iterator_try_fold
)
)
]
{
let
mut
iter
=
iter
;
try
!
(
iter
.
try_for_each
(
|
(
key
value
)
|
serializer
.
serialize_entry
(
&
key
&
value
)
)
)
;
}
#
[
cfg
(
no_iterator_try_fold
)
]
{
for
(
key
value
)
in
iter
{
try
!
(
serializer
.
serialize_entry
(
&
key
&
value
)
)
;
}
}
serializer
.
end
(
)
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
alloc
"
)
)
]
fn
collect_str
<
T
:
?
Sized
>
(
self
value
:
&
T
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
T
:
Display
{
self
.
serialize_str
(
&
value
.
to_string
(
)
)
}
#
[
cfg
(
not
(
any
(
feature
=
"
std
"
feature
=
"
alloc
"
)
)
)
]
fn
collect_str
<
T
:
?
Sized
>
(
self
value
:
&
T
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
where
T
:
Display
;
#
[
inline
]
fn
is_human_readable
(
&
self
)
-
>
bool
{
true
}
}
pub
trait
SerializeSeq
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_element
<
T
:
?
Sized
>
(
&
mut
self
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
pub
trait
SerializeTuple
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_element
<
T
:
?
Sized
>
(
&
mut
self
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
pub
trait
SerializeTupleStruct
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_field
<
T
:
?
Sized
>
(
&
mut
self
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
pub
trait
SerializeTupleVariant
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_field
<
T
:
?
Sized
>
(
&
mut
self
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
pub
trait
SerializeMap
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_key
<
T
:
?
Sized
>
(
&
mut
self
key
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
fn
serialize_value
<
T
:
?
Sized
>
(
&
mut
self
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
fn
serialize_entry
<
K
:
?
Sized
V
:
?
Sized
>
(
&
mut
self
key
:
&
K
value
:
&
V
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
K
:
Serialize
V
:
Serialize
{
try
!
(
self
.
serialize_key
(
key
)
)
;
self
.
serialize_value
(
value
)
}
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
pub
trait
SerializeStruct
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_field
<
T
:
?
Sized
>
(
&
mut
self
key
:
&
'
static
str
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
#
[
inline
]
fn
skip_field
(
&
mut
self
key
:
&
'
static
str
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
let
_
=
key
;
Ok
(
(
)
)
}
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
pub
trait
SerializeStructVariant
{
type
Ok
;
type
Error
:
Error
;
fn
serialize_field
<
T
:
?
Sized
>
(
&
mut
self
key
:
&
'
static
str
value
:
&
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
T
:
Serialize
;
#
[
inline
]
fn
skip_field
(
&
mut
self
key
:
&
'
static
str
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
let
_
=
key
;
Ok
(
(
)
)
}
fn
end
(
self
)
-
>
Result
<
Self
:
:
Ok
Self
:
:
Error
>
;
}
fn
iterator_len_hint
<
I
>
(
iter
:
&
I
)
-
>
Option
<
usize
>
where
I
:
Iterator
{
match
iter
.
size_hint
(
)
{
(
lo
Some
(
hi
)
)
if
lo
=
=
hi
=
>
Some
(
lo
)
_
=
>
None
}
}
