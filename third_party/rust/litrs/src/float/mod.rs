use
std
:
:
{
fmt
str
:
:
FromStr
}
;
use
crate
:
:
{
Buffer
ParseError
err
:
:
{
perr
ParseErrorKind
:
:
*
}
parse
:
:
{
end_dec_digits
first_byte_or_empty
check_suffix
}
}
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
FloatLit
<
B
:
Buffer
>
{
raw
:
B
end_integer_part
:
usize
end_fractional_part
:
usize
end_number_part
:
usize
}
impl
<
B
:
Buffer
>
FloatLit
<
B
>
{
pub
fn
parse
(
s
:
B
)
-
>
Result
<
Self
ParseError
>
{
match
first_byte_or_empty
(
&
s
)
?
{
b
'
0
'
.
.
=
b
'
9
'
=
>
{
let
FloatLit
{
end_integer_part
end_fractional_part
end_number_part
.
.
}
=
parse_impl
(
&
s
)
?
;
Ok
(
Self
{
raw
:
s
end_integer_part
end_fractional_part
end_number_part
}
)
}
_
=
>
Err
(
perr
(
0
DoesNotStartWithDigit
)
)
}
}
pub
fn
number_part
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
.
.
self
.
end_number_part
]
}
pub
fn
integer_part
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
.
.
self
.
end_integer_part
]
}
pub
fn
fractional_part
(
&
self
)
-
>
Option
<
&
str
>
{
if
self
.
end_integer_part
=
=
self
.
end_fractional_part
{
None
}
else
{
Some
(
&
(
*
self
.
raw
)
[
self
.
end_integer_part
+
1
.
.
self
.
end_fractional_part
]
)
}
}
pub
fn
exponent_part
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
self
.
end_fractional_part
.
.
self
.
end_number_part
]
}
pub
fn
suffix
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
self
.
end_number_part
.
.
]
}
pub
fn
raw_input
(
&
self
)
-
>
&
str
{
&
self
.
raw
}
pub
fn
into_raw_input
(
self
)
-
>
B
{
self
.
raw
}
}
impl
FloatLit
<
&
str
>
{
pub
fn
to_owned
(
&
self
)
-
>
FloatLit
<
String
>
{
FloatLit
{
raw
:
self
.
raw
.
to_owned
(
)
end_integer_part
:
self
.
end_integer_part
end_fractional_part
:
self
.
end_fractional_part
end_number_part
:
self
.
end_number_part
}
}
}
impl
<
B
:
Buffer
>
fmt
:
:
Display
for
FloatLit
<
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
&
*
self
.
raw
)
}
}
#
[
inline
(
never
)
]
pub
(
crate
)
fn
parse_impl
(
input
:
&
str
)
-
>
Result
<
FloatLit
<
&
str
>
ParseError
>
{
let
end_integer_part
=
end_dec_digits
(
input
.
as_bytes
(
)
)
;
let
rest
=
&
input
[
end_integer_part
.
.
]
;
let
end_fractional_part
=
if
rest
.
as_bytes
(
)
.
get
(
0
)
=
=
Some
(
&
b
'
.
'
)
{
if
rest
.
as_bytes
(
)
.
get
(
1
)
=
=
Some
(
&
b
'
_
'
)
{
return
Err
(
perr
(
end_integer_part
+
1
UnexpectedChar
)
)
;
}
end_dec_digits
(
rest
[
1
.
.
]
.
as_bytes
(
)
)
+
1
+
end_integer_part
}
else
{
end_integer_part
}
;
let
rest
=
&
input
[
end_fractional_part
.
.
]
;
if
end_integer_part
+
1
=
=
end_fractional_part
&
&
!
rest
.
is_empty
(
)
{
return
Err
(
perr
(
end_integer_part
+
1
UnexpectedChar
)
)
;
}
let
end_number_part
=
if
rest
.
starts_with
(
'
e
'
)
|
|
rest
.
starts_with
(
'
E
'
)
{
let
exp_number_start
=
match
rest
.
as_bytes
(
)
.
get
(
1
)
{
Some
(
b
'
-
'
)
|
Some
(
b
'
+
'
)
=
>
2
_
=
>
1
}
;
let
end_exponent
=
end_dec_digits
(
rest
[
exp_number_start
.
.
]
.
as_bytes
(
)
)
+
exp_number_start
;
if
!
rest
[
exp_number_start
.
.
end_exponent
]
.
bytes
(
)
.
any
(
|
b
|
matches
!
(
b
b
'
0
'
.
.
=
b
'
9
'
)
)
{
return
Err
(
perr
(
end_fractional_part
.
.
end_fractional_part
+
end_exponent
NoExponentDigits
)
)
;
}
end_exponent
+
end_fractional_part
}
else
{
end_fractional_part
}
;
let
suffix
=
&
input
[
end_number_part
.
.
]
;
check_suffix
(
suffix
)
.
map_err
(
|
kind
|
perr
(
end_number_part
.
.
input
.
len
(
)
kind
)
)
?
;
if
end_integer_part
=
=
end_number_part
{
return
Err
(
perr
(
None
UnexpectedIntegerLit
)
)
;
}
Ok
(
FloatLit
{
raw
:
input
end_integer_part
end_fractional_part
end_number_part
}
)
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
enum
FloatType
{
F32
F64
}
impl
FloatType
{
pub
fn
from_suffix
(
suffix
:
&
str
)
-
>
Option
<
Self
>
{
match
suffix
{
"
f32
"
=
>
Some
(
FloatType
:
:
F32
)
"
f64
"
=
>
Some
(
FloatType
:
:
F64
)
_
=
>
None
}
}
pub
fn
suffix
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
F32
=
>
"
f32
"
Self
:
:
F64
=
>
"
f64
"
}
}
}
impl
FromStr
for
FloatType
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Self
:
:
from_suffix
(
s
)
.
ok_or
(
(
)
)
}
}
impl
fmt
:
:
Display
for
FloatType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
suffix
(
)
.
fmt
(
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
;
