use
std
:
:
{
fmt
str
:
:
FromStr
}
;
use
crate
:
:
{
Buffer
ParseError
err
:
:
{
perr
ParseErrorKind
:
:
*
}
parse
:
:
{
first_byte_or_empty
hex_digit_value
check_suffix
}
}
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
struct
IntegerLit
<
B
:
Buffer
>
{
raw
:
B
start_main_part
:
usize
end_main_part
:
usize
base
:
IntegerBase
}
impl
<
B
:
Buffer
>
IntegerLit
<
B
>
{
pub
fn
parse
(
input
:
B
)
-
>
Result
<
Self
ParseError
>
{
match
first_byte_or_empty
(
&
input
)
?
{
digit
b
'
0
'
.
.
=
b
'
9
'
=
>
{
let
IntegerLit
{
start_main_part
end_main_part
base
.
.
}
=
parse_impl
(
&
input
digit
)
?
;
Ok
(
Self
{
raw
:
input
start_main_part
end_main_part
base
}
)
}
_
=
>
Err
(
perr
(
0
DoesNotStartWithDigit
)
)
}
}
pub
fn
value
<
N
:
FromIntegerLiteral
>
(
&
self
)
-
>
Option
<
N
>
{
let
base
=
N
:
:
from_small_number
(
self
.
base
.
value
(
)
)
;
let
mut
acc
=
N
:
:
from_small_number
(
0
)
;
for
digit
in
self
.
raw_main_part
(
)
.
bytes
(
)
{
if
digit
=
=
b
'
_
'
{
continue
;
}
let
digit
=
hex_digit_value
(
digit
)
.
unwrap_or_else
(
|
|
unreachable
!
(
"
bug
:
integer
main
part
contains
non
-
digit
"
)
)
;
acc
=
acc
.
checked_mul
(
base
)
?
;
acc
=
acc
.
checked_add
(
N
:
:
from_small_number
(
digit
)
)
?
;
}
Some
(
acc
)
}
pub
fn
base
(
&
self
)
-
>
IntegerBase
{
self
.
base
}
pub
fn
raw_main_part
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
self
.
start_main_part
.
.
self
.
end_main_part
]
}
pub
fn
suffix
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
self
.
end_main_part
.
.
]
}
pub
fn
raw_input
(
&
self
)
-
>
&
str
{
&
self
.
raw
}
pub
fn
into_raw_input
(
self
)
-
>
B
{
self
.
raw
}
}
impl
IntegerLit
<
&
str
>
{
pub
fn
to_owned
(
&
self
)
-
>
IntegerLit
<
String
>
{
IntegerLit
{
raw
:
self
.
raw
.
to_owned
(
)
start_main_part
:
self
.
start_main_part
end_main_part
:
self
.
end_main_part
base
:
self
.
base
}
}
}
impl
<
B
:
Buffer
>
fmt
:
:
Display
for
IntegerLit
<
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
&
*
self
.
raw
)
}
}
pub
trait
FromIntegerLiteral
:
self
:
:
sealed
:
:
Sealed
+
Copy
{
#
[
doc
(
hidden
)
]
fn
from_small_number
(
n
:
u8
)
-
>
Self
;
#
[
doc
(
hidden
)
]
fn
checked_add
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
#
[
doc
(
hidden
)
]
fn
checked_mul
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
#
[
doc
(
hidden
)
]
fn
ty
(
)
-
>
IntegerType
;
}
macro_rules
!
impl_from_int_literal
{
(
(
ty
:
ty
=
>
variant
:
ident
)
*
)
=
>
{
(
impl
self
:
:
sealed
:
:
Sealed
for
ty
{
}
impl
FromIntegerLiteral
for
ty
{
fn
from_small_number
(
n
:
u8
)
-
>
Self
{
n
as
Self
}
fn
checked_add
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
{
self
.
checked_add
(
rhs
)
}
fn
checked_mul
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
{
self
.
checked_mul
(
rhs
)
}
fn
ty
(
)
-
>
IntegerType
{
IntegerType
:
:
variant
}
}
)
*
}
;
}
impl_from_int_literal
!
(
u8
=
>
U8
u16
=
>
U16
u32
=
>
U32
u64
=
>
U64
u128
=
>
U128
usize
=
>
Usize
i8
=
>
I8
i16
=
>
I16
i32
=
>
I32
i64
=
>
I64
i128
=
>
I128
isize
=
>
Isize
)
;
mod
sealed
{
pub
trait
Sealed
{
}
}
#
[
inline
(
never
)
]
pub
(
crate
)
fn
parse_impl
(
input
:
&
str
first
:
u8
)
-
>
Result
<
IntegerLit
<
&
str
>
ParseError
>
{
let
(
end_prefix
base
)
=
match
(
first
input
.
as_bytes
(
)
.
get
(
1
)
)
{
(
b
'
0
'
Some
(
b
'
b
'
)
)
=
>
(
2
IntegerBase
:
:
Binary
)
(
b
'
0
'
Some
(
b
'
o
'
)
)
=
>
(
2
IntegerBase
:
:
Octal
)
(
b
'
0
'
Some
(
b
'
x
'
)
)
=
>
(
2
IntegerBase
:
:
Hexadecimal
)
_
=
>
(
0
IntegerBase
:
:
Decimal
)
}
;
let
without_prefix
=
&
input
[
end_prefix
.
.
]
;
let
is_valid_digit
=
match
base
{
IntegerBase
:
:
Binary
=
>
|
b
|
matches
!
(
b
b
'
0
'
|
b
'
1
'
|
b
'
_
'
)
IntegerBase
:
:
Octal
=
>
|
b
|
matches
!
(
b
b
'
0
'
.
.
=
b
'
7
'
|
b
'
_
'
)
IntegerBase
:
:
Decimal
=
>
|
b
|
matches
!
(
b
b
'
0
'
.
.
=
b
'
9
'
|
b
'
_
'
)
IntegerBase
:
:
Hexadecimal
=
>
|
b
|
matches
!
(
b
b
'
0
'
.
.
=
b
'
9
'
|
b
'
a
'
.
.
=
b
'
f
'
|
b
'
A
'
.
.
=
b
'
F
'
|
b
'
_
'
)
}
;
let
end_main
=
without_prefix
.
bytes
(
)
.
position
(
|
b
|
!
is_valid_digit
(
b
)
)
.
unwrap_or
(
without_prefix
.
len
(
)
)
;
let
(
main_part
suffix
)
=
without_prefix
.
split_at
(
end_main
)
;
check_suffix
(
suffix
)
.
map_err
(
|
kind
|
{
let
first
=
suffix
.
as_bytes
(
)
[
0
]
;
if
!
is_valid_digit
(
first
)
&
&
first
.
is_ascii_digit
(
)
{
perr
(
end_main
+
end_prefix
InvalidDigit
)
}
else
{
perr
(
end_main
+
end_prefix
.
.
input
.
len
(
)
kind
)
}
}
)
?
;
if
suffix
.
starts_with
(
'
e
'
)
|
|
suffix
.
starts_with
(
'
E
'
)
{
return
Err
(
perr
(
end_main
IntegerSuffixStartingWithE
)
)
;
}
if
main_part
.
bytes
(
)
.
filter
(
|
&
b
|
b
!
=
b
'
_
'
)
.
count
(
)
=
=
0
{
return
Err
(
perr
(
end_prefix
.
.
end_prefix
+
end_main
NoDigits
)
)
;
}
Ok
(
IntegerLit
{
raw
:
input
start_main_part
:
end_prefix
end_main_part
:
end_main
+
end_prefix
base
}
)
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
IntegerBase
{
Binary
Octal
Decimal
Hexadecimal
}
impl
IntegerBase
{
pub
fn
prefix
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Binary
=
>
"
0b
"
Self
:
:
Octal
=
>
"
0o
"
Self
:
:
Decimal
=
>
"
"
Self
:
:
Hexadecimal
=
>
"
0x
"
}
}
pub
fn
value
(
self
)
-
>
u8
{
match
self
{
Self
:
:
Binary
=
>
2
Self
:
:
Octal
=
>
8
Self
:
:
Decimal
=
>
10
Self
:
:
Hexadecimal
=
>
16
}
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
enum
IntegerType
{
U8
U16
U32
U64
U128
Usize
I8
I16
I32
I64
I128
Isize
}
impl
IntegerType
{
pub
fn
from_suffix
(
suffix
:
&
str
)
-
>
Option
<
Self
>
{
match
suffix
{
"
u8
"
=
>
Some
(
Self
:
:
U8
)
"
u16
"
=
>
Some
(
Self
:
:
U16
)
"
u32
"
=
>
Some
(
Self
:
:
U32
)
"
u64
"
=
>
Some
(
Self
:
:
U64
)
"
u128
"
=
>
Some
(
Self
:
:
U128
)
"
usize
"
=
>
Some
(
Self
:
:
Usize
)
"
i8
"
=
>
Some
(
Self
:
:
I8
)
"
i16
"
=
>
Some
(
Self
:
:
I16
)
"
i32
"
=
>
Some
(
Self
:
:
I32
)
"
i64
"
=
>
Some
(
Self
:
:
I64
)
"
i128
"
=
>
Some
(
Self
:
:
I128
)
"
isize
"
=
>
Some
(
Self
:
:
Isize
)
_
=
>
None
}
}
pub
fn
suffix
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
U8
=
>
"
u8
"
Self
:
:
U16
=
>
"
u16
"
Self
:
:
U32
=
>
"
u32
"
Self
:
:
U64
=
>
"
u64
"
Self
:
:
U128
=
>
"
u128
"
Self
:
:
Usize
=
>
"
usize
"
Self
:
:
I8
=
>
"
i8
"
Self
:
:
I16
=
>
"
i16
"
Self
:
:
I32
=
>
"
i32
"
Self
:
:
I64
=
>
"
i64
"
Self
:
:
I128
=
>
"
i128
"
Self
:
:
Isize
=
>
"
isize
"
}
}
}
impl
FromStr
for
IntegerType
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Self
:
:
from_suffix
(
s
)
.
ok_or
(
(
)
)
}
}
impl
fmt
:
:
Display
for
IntegerType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
suffix
(
)
.
fmt
(
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
;
