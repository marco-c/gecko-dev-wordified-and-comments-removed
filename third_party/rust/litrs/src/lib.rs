#
!
[
deny
(
missing_debug_implementations
)
]
extern
crate
proc_macro
;
#
[
cfg
(
test
)
]
#
[
macro_use
]
mod
test_util
;
#
[
cfg
(
test
)
]
mod
tests
;
mod
bool
;
mod
byte
;
mod
bytestr
;
mod
char
;
mod
err
;
mod
escape
;
mod
float
;
mod
impls
;
mod
integer
;
mod
parse
;
mod
string
;
use
std
:
:
{
borrow
:
:
{
Borrow
Cow
}
fmt
ops
:
:
{
Deref
Range
}
}
;
pub
use
self
:
:
{
bool
:
:
BoolLit
byte
:
:
ByteLit
bytestr
:
:
ByteStringLit
char
:
:
CharLit
err
:
:
{
InvalidToken
ParseError
}
float
:
:
{
FloatLit
FloatType
}
integer
:
:
{
FromIntegerLiteral
IntegerLit
IntegerBase
IntegerType
}
string
:
:
StringLit
}
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
enum
Literal
<
B
:
Buffer
>
{
Bool
(
BoolLit
)
Integer
(
IntegerLit
<
B
>
)
Float
(
FloatLit
<
B
>
)
Char
(
CharLit
<
B
>
)
String
(
StringLit
<
B
>
)
Byte
(
ByteLit
<
B
>
)
ByteString
(
ByteStringLit
<
B
>
)
}
impl
<
B
:
Buffer
>
Literal
<
B
>
{
pub
fn
parse
(
input
:
B
)
-
>
Result
<
Self
ParseError
>
{
parse
:
:
parse
(
input
)
}
pub
fn
suffix
(
&
self
)
-
>
&
str
{
match
self
{
Literal
:
:
Bool
(
_
)
=
>
"
"
Literal
:
:
Integer
(
l
)
=
>
l
.
suffix
(
)
Literal
:
:
Float
(
l
)
=
>
l
.
suffix
(
)
Literal
:
:
Char
(
l
)
=
>
l
.
suffix
(
)
Literal
:
:
String
(
l
)
=
>
l
.
suffix
(
)
Literal
:
:
Byte
(
l
)
=
>
l
.
suffix
(
)
Literal
:
:
ByteString
(
l
)
=
>
l
.
suffix
(
)
}
}
}
impl
Literal
<
&
str
>
{
pub
fn
into_owned
(
self
)
-
>
Literal
<
String
>
{
match
self
{
Literal
:
:
Bool
(
l
)
=
>
Literal
:
:
Bool
(
l
.
to_owned
(
)
)
Literal
:
:
Integer
(
l
)
=
>
Literal
:
:
Integer
(
l
.
to_owned
(
)
)
Literal
:
:
Float
(
l
)
=
>
Literal
:
:
Float
(
l
.
to_owned
(
)
)
Literal
:
:
Char
(
l
)
=
>
Literal
:
:
Char
(
l
.
to_owned
(
)
)
Literal
:
:
String
(
l
)
=
>
Literal
:
:
String
(
l
.
into_owned
(
)
)
Literal
:
:
Byte
(
l
)
=
>
Literal
:
:
Byte
(
l
.
to_owned
(
)
)
Literal
:
:
ByteString
(
l
)
=
>
Literal
:
:
ByteString
(
l
.
into_owned
(
)
)
}
}
}
impl
<
B
:
Buffer
>
fmt
:
:
Display
for
Literal
<
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Literal
:
:
Bool
(
l
)
=
>
l
.
fmt
(
f
)
Literal
:
:
Integer
(
l
)
=
>
l
.
fmt
(
f
)
Literal
:
:
Float
(
l
)
=
>
l
.
fmt
(
f
)
Literal
:
:
Char
(
l
)
=
>
l
.
fmt
(
f
)
Literal
:
:
String
(
l
)
=
>
l
.
fmt
(
f
)
Literal
:
:
Byte
(
l
)
=
>
l
.
fmt
(
f
)
Literal
:
:
ByteString
(
l
)
=
>
l
.
fmt
(
f
)
}
}
}
pub
trait
Buffer
:
sealed
:
:
Sealed
+
Deref
<
Target
=
str
>
{
type
Cow
:
From
<
String
>
+
AsRef
<
str
>
+
Borrow
<
str
>
+
Deref
<
Target
=
str
>
;
#
[
doc
(
hidden
)
]
fn
into_cow
(
self
)
-
>
Self
:
:
Cow
;
type
ByteCow
:
From
<
Vec
<
u8
>
>
+
AsRef
<
[
u8
]
>
+
Borrow
<
[
u8
]
>
+
Deref
<
Target
=
[
u8
]
>
;
#
[
doc
(
hidden
)
]
fn
into_byte_cow
(
self
)
-
>
Self
:
:
ByteCow
;
#
[
doc
(
hidden
)
]
fn
cut
(
self
range
:
Range
<
usize
>
)
-
>
Self
;
}
mod
sealed
{
pub
trait
Sealed
{
}
}
impl
<
'
a
>
sealed
:
:
Sealed
for
&
'
a
str
{
}
impl
<
'
a
>
Buffer
for
&
'
a
str
{
#
[
doc
(
hidden
)
]
fn
cut
(
self
range
:
Range
<
usize
>
)
-
>
Self
{
&
self
[
range
]
}
type
Cow
=
Cow
<
'
a
str
>
;
#
[
doc
(
hidden
)
]
fn
into_cow
(
self
)
-
>
Self
:
:
Cow
{
self
.
into
(
)
}
type
ByteCow
=
Cow
<
'
a
[
u8
]
>
;
#
[
doc
(
hidden
)
]
fn
into_byte_cow
(
self
)
-
>
Self
:
:
ByteCow
{
self
.
as_bytes
(
)
.
into
(
)
}
}
impl
sealed
:
:
Sealed
for
String
{
}
impl
Buffer
for
String
{
#
[
doc
(
hidden
)
]
fn
cut
(
mut
self
range
:
Range
<
usize
>
)
-
>
Self
{
self
.
truncate
(
range
.
end
)
;
self
.
drain
(
.
.
range
.
start
)
;
self
}
type
Cow
=
Cow
<
'
static
str
>
;
#
[
doc
(
hidden
)
]
fn
into_cow
(
self
)
-
>
Self
:
:
Cow
{
self
.
into
(
)
}
type
ByteCow
=
Cow
<
'
static
[
u8
]
>
;
#
[
doc
(
hidden
)
]
fn
into_byte_cow
(
self
)
-
>
Self
:
:
ByteCow
{
self
.
into_bytes
(
)
.
into
(
)
}
}
