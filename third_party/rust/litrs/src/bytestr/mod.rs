use
std
:
:
{
fmt
ops
:
:
Range
}
;
use
crate
:
:
{
Buffer
ParseError
err
:
:
{
perr
ParseErrorKind
:
:
*
}
escape
:
:
{
scan_raw_string
unescape_string
}
}
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
ByteStringLit
<
B
:
Buffer
>
{
raw
:
B
value
:
Option
<
Vec
<
u8
>
>
num_hashes
:
Option
<
u32
>
start_suffix
:
usize
}
impl
<
B
:
Buffer
>
ByteStringLit
<
B
>
{
pub
fn
parse
(
input
:
B
)
-
>
Result
<
Self
ParseError
>
{
if
input
.
is_empty
(
)
{
return
Err
(
perr
(
None
Empty
)
)
;
}
if
!
input
.
starts_with
(
r
#
"
b
"
"
#
)
&
&
!
input
.
starts_with
(
"
br
"
)
{
return
Err
(
perr
(
None
InvalidByteStringLiteralStart
)
)
;
}
let
(
value
num_hashes
start_suffix
)
=
parse_impl
(
&
input
)
?
;
Ok
(
Self
{
raw
:
input
value
num_hashes
start_suffix
}
)
}
pub
fn
value
(
&
self
)
-
>
&
[
u8
]
{
self
.
value
.
as_deref
(
)
.
unwrap_or
(
&
self
.
raw
.
as_bytes
(
)
[
self
.
inner_range
(
)
]
)
}
pub
fn
into_value
(
self
)
-
>
B
:
:
ByteCow
{
let
inner_range
=
self
.
inner_range
(
)
;
let
Self
{
raw
value
.
.
}
=
self
;
value
.
map
(
B
:
:
ByteCow
:
:
from
)
.
unwrap_or_else
(
|
|
raw
.
cut
(
inner_range
)
.
into_byte_cow
(
)
)
}
pub
fn
suffix
(
&
self
)
-
>
&
str
{
&
(
*
self
.
raw
)
[
self
.
start_suffix
.
.
]
}
pub
fn
is_raw_byte_string
(
&
self
)
-
>
bool
{
self
.
num_hashes
.
is_some
(
)
}
pub
fn
raw_input
(
&
self
)
-
>
&
str
{
&
self
.
raw
}
pub
fn
into_raw_input
(
self
)
-
>
B
{
self
.
raw
}
fn
inner_range
(
&
self
)
-
>
Range
<
usize
>
{
match
self
.
num_hashes
{
None
=
>
2
.
.
self
.
start_suffix
-
1
Some
(
n
)
=
>
2
+
n
as
usize
+
1
.
.
self
.
start_suffix
-
n
as
usize
-
1
}
}
}
impl
ByteStringLit
<
&
str
>
{
pub
fn
into_owned
(
self
)
-
>
ByteStringLit
<
String
>
{
ByteStringLit
{
raw
:
self
.
raw
.
to_owned
(
)
value
:
self
.
value
num_hashes
:
self
.
num_hashes
start_suffix
:
self
.
start_suffix
}
}
}
impl
<
B
:
Buffer
>
fmt
:
:
Display
for
ByteStringLit
<
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
pad
(
&
self
.
raw
)
}
}
#
[
inline
(
never
)
]
fn
parse_impl
(
input
:
&
str
)
-
>
Result
<
(
Option
<
Vec
<
u8
>
>
Option
<
u32
>
usize
)
ParseError
>
{
if
input
.
starts_with
(
"
br
"
)
{
scan_raw_string
:
:
<
u8
>
(
&
input
2
)
.
map
(
|
(
v
num
start_suffix
)
|
(
v
.
map
(
String
:
:
into_bytes
)
Some
(
num
)
start_suffix
)
)
}
else
{
unescape_string
:
:
<
u8
>
(
&
input
2
)
.
map
(
|
(
v
start_suffix
)
|
(
v
.
map
(
String
:
:
into_bytes
)
None
start_suffix
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
;
