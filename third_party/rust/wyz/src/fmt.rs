use
core
:
:
{
fmt
:
:
{
self
Binary
Debug
Display
Formatter
LowerExp
LowerHex
Octal
Pointer
UpperExp
UpperHex
}
ops
:
:
{
Deref
DerefMut
}
}
;
pub
trait
FmtForward
:
Sized
{
fn
fmt_binary
(
self
)
-
>
FmtBinary
<
Self
>
where
Self
:
Binary
{
FmtBinary
(
self
)
}
fn
fmt_display
(
self
)
-
>
FmtDisplay
<
Self
>
where
Self
:
Display
{
FmtDisplay
(
self
)
}
fn
fmt_lower_exp
(
self
)
-
>
FmtLowerExp
<
Self
>
where
Self
:
LowerExp
{
FmtLowerExp
(
self
)
}
fn
fmt_lower_hex
(
self
)
-
>
FmtLowerHex
<
Self
>
where
Self
:
LowerHex
{
FmtLowerHex
(
self
)
}
fn
fmt_octal
(
self
)
-
>
FmtOctal
<
Self
>
where
Self
:
Octal
{
FmtOctal
(
self
)
}
fn
fmt_pointer
(
self
)
-
>
FmtPointer
<
Self
>
where
Self
:
Pointer
{
FmtPointer
(
self
)
}
fn
fmt_upper_exp
(
self
)
-
>
FmtUpperExp
<
Self
>
where
Self
:
UpperExp
{
FmtUpperExp
(
self
)
}
fn
fmt_upper_hex
(
self
)
-
>
FmtUpperHex
<
Self
>
where
Self
:
UpperHex
{
FmtUpperHex
(
self
)
}
}
impl
<
T
:
Sized
>
FmtForward
for
T
{
}
#
[
repr
(
transparent
)
]
pub
struct
FmtBinary
<
T
:
Binary
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtDisplay
<
T
:
Display
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtLowerExp
<
T
:
LowerExp
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtLowerHex
<
T
:
LowerHex
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtOctal
<
T
:
Octal
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtPointer
<
T
:
Pointer
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtUpperExp
<
T
:
UpperExp
>
(
pub
T
)
;
#
[
repr
(
transparent
)
]
pub
struct
FmtUpperHex
<
T
:
UpperHex
>
(
pub
T
)
;
macro_rules
!
fmt
{
(
(
w
:
ty
=
>
t
:
ident
)
*
(
)
?
)
=
>
{
(
impl
<
T
:
t
+
Binary
>
Binary
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
Binary
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
>
Debug
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
<
T
as
t
>
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
Display
>
Display
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
LowerExp
>
LowerExp
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
LowerExp
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
LowerHex
>
LowerHex
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
LowerHex
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
Octal
>
Octal
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
Octal
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
Pointer
>
Pointer
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
Pointer
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
UpperExp
>
UpperExp
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
UpperExp
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
+
UpperHex
>
UpperHex
for
w
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
UpperHex
:
:
fmt
(
&
self
.
0
fmt
)
}
}
impl
<
T
:
t
>
Deref
for
w
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
<
T
:
t
>
DerefMut
for
w
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
<
T
:
t
>
AsRef
<
T
>
for
w
{
fn
as_ref
(
&
self
)
-
>
&
T
{
&
self
.
0
}
}
impl
<
T
:
t
>
AsMut
<
T
>
for
w
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
0
}
}
)
*
}
;
}
fmt
!
(
FmtBinary
<
T
>
=
>
Binary
FmtDisplay
<
T
>
=
>
Display
FmtLowerExp
<
T
>
=
>
LowerExp
FmtLowerHex
<
T
>
=
>
LowerHex
FmtOctal
<
T
>
=
>
Octal
FmtPointer
<
T
>
=
>
Pointer
FmtUpperExp
<
T
>
=
>
UpperExp
FmtUpperHex
<
T
>
=
>
UpperHex
)
;
