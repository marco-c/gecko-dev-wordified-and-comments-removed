#
!
[
allow
(
deprecated
)
]
mod
version
;
mod
channel
;
mod
date
;
use
std
:
:
env
;
use
std
:
:
process
:
:
Command
;
#
[
doc
(
inline
)
]
pub
use
version
:
:
*
;
#
[
doc
(
inline
)
]
pub
use
channel
:
:
*
;
#
[
doc
(
inline
)
]
pub
use
date
:
:
*
;
fn
version_and_date_from_rustc_version
(
s
:
&
str
)
-
>
(
Option
<
String
>
Option
<
String
>
)
{
let
last_line
=
s
.
lines
(
)
.
last
(
)
.
unwrap_or
(
s
)
;
let
mut
components
=
last_line
.
trim
(
)
.
split
(
"
"
)
;
let
version
=
components
.
nth
(
1
)
;
let
date
=
components
.
filter
(
|
c
|
c
.
ends_with
(
'
)
'
)
)
.
next
(
)
.
map
(
|
s
|
s
.
trim_right
(
)
.
trim_right_matches
(
"
)
"
)
.
trim_left
(
)
.
trim_left_matches
(
'
(
'
)
)
;
(
version
.
map
(
|
s
|
s
.
to_string
(
)
)
date
.
map
(
|
s
|
s
.
to_string
(
)
)
)
}
fn
get_version_and_date
(
)
-
>
Option
<
(
Option
<
String
>
Option
<
String
>
)
>
{
env
:
:
var
(
"
RUSTC
"
)
.
ok
(
)
.
and_then
(
|
rustc
|
Command
:
:
new
(
rustc
)
.
arg
(
"
-
-
version
"
)
.
output
(
)
.
ok
(
)
)
.
or_else
(
|
|
Command
:
:
new
(
"
rustc
"
)
.
arg
(
"
-
-
version
"
)
.
output
(
)
.
ok
(
)
)
.
and_then
(
|
output
|
String
:
:
from_utf8
(
output
.
stdout
)
.
ok
(
)
)
.
map
(
|
s
|
version_and_date_from_rustc_version
(
&
s
)
)
}
pub
fn
triple
(
)
-
>
Option
<
(
Version
Channel
Date
)
>
{
let
(
version_str
date_str
)
=
match
get_version_and_date
(
)
{
Some
(
(
Some
(
version
)
Some
(
date
)
)
)
=
>
(
version
date
)
_
=
>
return
None
}
;
match
Version
:
:
parse
(
&
version_str
)
{
Some
(
version
)
=
>
match
Channel
:
:
parse
(
&
version_str
)
{
Some
(
channel
)
=
>
match
Date
:
:
parse
(
&
date_str
)
{
Some
(
date
)
=
>
Some
(
(
version
channel
date
)
)
_
=
>
None
}
_
=
>
None
}
_
=
>
None
}
}
pub
fn
is_min_date
(
min_date
:
&
str
)
-
>
Option
<
bool
>
{
match
(
Date
:
:
read
(
)
Date
:
:
parse
(
min_date
)
)
{
(
Some
(
rustc_date
)
Some
(
min_date
)
)
=
>
Some
(
rustc_date
>
=
min_date
)
_
=
>
None
}
}
pub
fn
is_max_date
(
max_date
:
&
str
)
-
>
Option
<
bool
>
{
match
(
Date
:
:
read
(
)
Date
:
:
parse
(
max_date
)
)
{
(
Some
(
rustc_date
)
Some
(
max_date
)
)
=
>
Some
(
rustc_date
<
=
max_date
)
_
=
>
None
}
}
pub
fn
is_exact_date
(
date
:
&
str
)
-
>
Option
<
bool
>
{
match
(
Date
:
:
read
(
)
Date
:
:
parse
(
date
)
)
{
(
Some
(
rustc_date
)
Some
(
date
)
)
=
>
Some
(
rustc_date
=
=
date
)
_
=
>
None
}
}
pub
fn
is_min_version
(
min_version
:
&
str
)
-
>
Option
<
bool
>
{
match
(
Version
:
:
read
(
)
Version
:
:
parse
(
min_version
)
)
{
(
Some
(
rustc_ver
)
Some
(
min_ver
)
)
=
>
Some
(
rustc_ver
>
=
min_ver
)
_
=
>
None
}
}
pub
fn
is_max_version
(
max_version
:
&
str
)
-
>
Option
<
bool
>
{
match
(
Version
:
:
read
(
)
Version
:
:
parse
(
max_version
)
)
{
(
Some
(
rustc_ver
)
Some
(
max_ver
)
)
=
>
Some
(
rustc_ver
<
=
max_ver
)
_
=
>
None
}
}
pub
fn
is_exact_version
(
version
:
&
str
)
-
>
Option
<
bool
>
{
match
(
Version
:
:
read
(
)
Version
:
:
parse
(
version
)
)
{
(
Some
(
rustc_ver
)
Some
(
version
)
)
=
>
Some
(
rustc_ver
=
=
version
)
_
=
>
None
}
}
pub
fn
is_feature_flaggable
(
)
-
>
Option
<
bool
>
{
Channel
:
:
read
(
)
.
map
(
|
c
|
c
.
supports_features
(
)
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
version_and_date_from_rustc_version
;
macro_rules
!
check_parse
{
(
s
:
expr
=
>
v
:
expr
d
:
expr
)
=
>
(
if
let
(
Some
(
v
)
d
)
=
version_and_date_from_rustc_version
(
s
)
{
let
e_d
:
Option
<
&
str
>
=
d
.
into
(
)
;
assert_eq
!
(
(
v
d
)
(
v
.
into
(
)
e_d
.
map
(
|
s
|
s
.
into
(
)
)
)
)
;
}
else
{
panic
!
(
"
{
:
?
}
didn
'
t
parse
for
version
testing
.
"
s
)
;
}
)
}
#
[
test
]
fn
test_version_parse
(
)
{
check_parse
!
(
"
rustc
1
.
18
.
0
"
=
>
"
1
.
18
.
0
"
None
)
;
check_parse
!
(
"
rustc
1
.
8
.
0
"
=
>
"
1
.
8
.
0
"
None
)
;
check_parse
!
(
"
rustc
1
.
20
.
0
-
nightly
"
=
>
"
1
.
20
.
0
-
nightly
"
None
)
;
check_parse
!
(
"
rustc
1
.
20
"
=
>
"
1
.
20
"
None
)
;
check_parse
!
(
"
rustc
1
.
3
"
=
>
"
1
.
3
"
None
)
;
check_parse
!
(
"
rustc
1
"
=
>
"
1
"
None
)
;
check_parse
!
(
"
rustc
1
.
5
.
1
-
beta
"
=
>
"
1
.
5
.
1
-
beta
"
None
)
;
check_parse
!
(
"
rustc
1
.
20
.
0
(
2017
-
07
-
09
)
"
=
>
"
1
.
20
.
0
"
Some
(
"
2017
-
07
-
09
"
)
)
;
check_parse
!
(
"
rustc
1
.
20
.
0
-
dev
(
2017
-
07
-
09
)
"
=
>
"
1
.
20
.
0
-
dev
"
Some
(
"
2017
-
07
-
09
"
)
)
;
check_parse
!
(
"
rustc
1
.
20
.
0
-
nightly
(
d84693b93
2017
-
07
-
09
)
"
=
>
"
1
.
20
.
0
-
nightly
"
Some
(
"
2017
-
07
-
09
"
)
)
;
check_parse
!
(
"
rustc
1
.
20
.
0
(
d84693b93
2017
-
07
-
09
)
"
=
>
"
1
.
20
.
0
"
Some
(
"
2017
-
07
-
09
"
)
)
;
check_parse
!
(
"
warning
:
invalid
logging
spec
'
warning
'
ignoring
it
rustc
1
.
30
.
0
-
nightly
(
3bc2ca7e4
2018
-
09
-
20
)
"
=
>
"
1
.
30
.
0
-
nightly
"
Some
(
"
2018
-
09
-
20
"
)
)
;
check_parse
!
(
"
warning
:
invalid
logging
spec
'
warning
'
ignoring
it
\
n
rustc
1
.
30
.
0
-
nightly
(
3bc2ca7e4
2018
-
09
-
20
)
"
=
>
"
1
.
30
.
0
-
nightly
"
Some
(
"
2018
-
09
-
20
"
)
)
;
check_parse
!
(
"
warning
:
invalid
logging
spec
'
warning
'
ignoring
it
warning
:
something
else
went
wrong
rustc
1
.
30
.
0
-
nightly
(
3bc2ca7e4
2018
-
09
-
20
)
"
=
>
"
1
.
30
.
0
-
nightly
"
Some
(
"
2018
-
09
-
20
"
)
)
;
}
}
