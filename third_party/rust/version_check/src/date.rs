use
std
:
:
fmt
;
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
PartialOrd
Ord
)
]
pub
struct
Date
(
u32
)
;
impl
Date
{
pub
fn
read
(
)
-
>
Option
<
Date
>
{
:
:
get_version_and_date
(
)
.
and_then
(
|
(
_
date
)
|
date
)
.
and_then
(
|
date
|
Date
:
:
parse
(
&
date
)
)
}
fn
to_ymd
(
&
self
)
-
>
(
u16
u8
u8
)
{
let
y
=
self
.
0
>
>
9
;
let
m
=
(
self
.
0
<
<
23
)
>
>
28
;
let
d
=
(
self
.
0
<
<
27
)
>
>
27
;
(
y
as
u16
m
as
u8
d
as
u8
)
}
pub
fn
parse
(
date
:
&
str
)
-
>
Option
<
Date
>
{
let
ymd
:
Vec
<
u32
>
=
date
.
split
(
"
-
"
)
.
filter_map
(
|
s
|
s
.
parse
:
:
<
u32
>
(
)
.
ok
(
)
)
.
collect
(
)
;
if
ymd
.
len
(
)
!
=
3
{
return
None
}
let
(
y
m
d
)
=
(
ymd
[
0
]
ymd
[
1
]
ymd
[
2
]
)
;
Some
(
Date
(
(
y
<
<
9
)
|
(
(
m
&
0xF
)
<
<
5
)
|
(
d
&
0x1F
)
)
)
}
pub
fn
at_least
(
&
self
date
:
&
str
)
-
>
bool
{
Date
:
:
parse
(
date
)
.
map
(
|
date
|
self
>
=
&
date
)
.
unwrap_or
(
false
)
}
pub
fn
at_most
(
&
self
date
:
&
str
)
-
>
bool
{
Date
:
:
parse
(
date
)
.
map
(
|
date
|
self
<
=
&
date
)
.
unwrap_or
(
false
)
}
pub
fn
exactly
(
&
self
date
:
&
str
)
-
>
bool
{
Date
:
:
parse
(
date
)
.
map
(
|
date
|
self
=
=
&
date
)
.
unwrap_or
(
false
)
}
}
impl
fmt
:
:
Display
for
Date
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
(
y
m
d
)
=
self
.
to_ymd
(
)
;
write
!
(
f
"
{
}
-
{
:
02
}
-
{
:
02
}
"
y
m
d
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
Date
;
macro_rules
!
reflexive_display
{
(
string
:
expr
)
=
>
(
assert_eq
!
(
Date
:
:
parse
(
string
)
.
unwrap
(
)
.
to_string
(
)
string
)
;
)
}
#
[
test
]
fn
display
(
)
{
reflexive_display
!
(
"
2019
-
05
-
08
"
)
;
reflexive_display
!
(
"
2000
-
01
-
01
"
)
;
reflexive_display
!
(
"
2000
-
12
-
31
"
)
;
reflexive_display
!
(
"
2090
-
12
-
31
"
)
;
reflexive_display
!
(
"
1999
-
02
-
19
"
)
;
}
}
