use
crate
:
:
QlogSeq
;
#
[
allow
(
clippy
:
:
large_enum_variant
)
]
pub
enum
Event
{
Qlog
(
crate
:
:
events
:
:
Event
)
Json
(
crate
:
:
events
:
:
JsonEvent
)
}
pub
struct
QlogSeqReader
{
pub
qlog
:
QlogSeq
reader
:
Box
<
dyn
std
:
:
io
:
:
BufRead
+
Send
+
Sync
>
}
impl
QlogSeqReader
{
pub
fn
new
(
mut
reader
:
Box
<
dyn
std
:
:
io
:
:
BufRead
+
Send
+
Sync
>
)
-
>
Result
<
Self
Box
<
dyn
std
:
:
error
:
:
Error
>
>
{
Self
:
:
read_record
(
reader
.
as_mut
(
)
)
;
let
header
=
Self
:
:
read_record
(
reader
.
as_mut
(
)
)
.
ok_or_else
(
|
|
{
std
:
:
io
:
:
Error
:
:
new
(
std
:
:
io
:
:
ErrorKind
:
:
Other
"
error
reading
file
header
bytes
"
)
}
)
?
;
let
res
:
Result
<
QlogSeq
serde_json
:
:
Error
>
=
serde_json
:
:
from_slice
(
&
header
)
;
match
res
{
Ok
(
qlog
)
=
>
Ok
(
Self
{
qlog
reader
}
)
Err
(
e
)
=
>
Err
(
e
.
into
(
)
)
}
}
fn
read_record
(
reader
:
&
mut
(
dyn
std
:
:
io
:
:
BufRead
+
Send
+
Sync
)
)
-
>
Option
<
Vec
<
u8
>
>
{
let
mut
buf
=
Vec
:
:
<
u8
>
:
:
new
(
)
;
let
size
=
reader
.
read_until
(
b
'
'
&
mut
buf
)
.
unwrap
(
)
;
if
size
<
=
1
{
return
None
;
}
buf
.
truncate
(
buf
.
len
(
)
-
1
)
;
Some
(
buf
)
}
}
impl
Iterator
for
QlogSeqReader
{
type
Item
=
Event
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
while
let
Some
(
bytes
)
=
Self
:
:
read_record
(
&
mut
self
.
reader
)
{
let
r
:
serde_json
:
:
Result
<
crate
:
:
events
:
:
Event
>
=
serde_json
:
:
from_slice
(
&
bytes
)
;
if
let
Ok
(
event
)
=
r
{
return
Some
(
Event
:
:
Qlog
(
event
)
)
;
}
let
r
:
serde_json
:
:
Result
<
crate
:
:
events
:
:
JsonEvent
>
=
serde_json
:
:
from_slice
(
&
bytes
)
;
if
let
Ok
(
event
)
=
r
{
return
Some
(
Event
:
:
Json
(
event
)
)
;
}
}
None
}
}
