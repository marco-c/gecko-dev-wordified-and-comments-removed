extern
crate
cose
;
use
std
:
:
slice
;
use
cose
:
:
decoder
:
:
decode_signature
;
use
cose
:
:
SignatureAlgorithm
;
unsafe
fn
from_raw
(
ptr
:
*
const
u8
len
:
usize
)
-
>
Vec
<
u8
>
{
slice
:
:
from_raw_parts
(
ptr
len
)
.
to_vec
(
)
}
type
VerifyCallback
=
extern
"
C
"
fn
(
*
const
u8
usize
*
const
*
const
u8
usize
*
const
usize
*
const
u8
usize
*
const
u8
usize
u8
)
-
>
bool
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
verify_cose_signature_ffi
(
payload
:
*
const
u8
payload_len
:
usize
cose_signature
:
*
const
u8
cose_signature_len
:
usize
verify_callback
:
VerifyCallback
)
-
>
bool
{
if
payload
.
is_null
(
)
|
|
cose_signature
.
is_null
(
)
|
|
payload_len
=
=
0
|
|
cose_signature_len
=
=
0
{
return
false
;
}
let
payload
=
unsafe
{
from_raw
(
payload
payload_len
)
}
;
let
cose_signature
=
unsafe
{
from_raw
(
cose_signature
cose_signature_len
)
}
;
let
cose_signatures
=
decode_signature
(
&
cose_signature
&
payload
)
;
let
cose_signatures
=
match
cose_signatures
{
Ok
(
signatures
)
=
>
signatures
Err
(
_
)
=
>
Vec
:
:
new
(
)
}
;
if
cose_signatures
.
len
(
)
=
=
0
{
return
false
;
}
return
cose_signatures
.
into_iter
(
)
.
all
(
|
cose_signature
|
{
let
signature_type
=
cose_signature
.
signature_type
;
let
signature_type
=
match
signature_type
{
SignatureAlgorithm
:
:
ES256
=
>
0
SignatureAlgorithm
:
:
ES384
=
>
1
SignatureAlgorithm
:
:
ES512
=
>
2
SignatureAlgorithm
:
:
PS256
=
>
3
}
;
let
signature_bytes
=
cose_signature
.
signature
;
let
real_payload
=
cose_signature
.
to_verify
;
let
certs
:
Vec
<
_
>
=
cose_signature
.
certs
.
iter
(
)
.
map
(
|
c
|
c
.
as_ptr
(
)
)
.
collect
(
)
;
let
cert_lens
:
Vec
<
_
>
=
cose_signature
.
certs
.
iter
(
)
.
map
(
|
c
|
c
.
len
(
)
)
.
collect
(
)
;
verify_callback
(
real_payload
.
as_ptr
(
)
real_payload
.
len
(
)
certs
.
as_ptr
(
)
certs
.
len
(
)
cert_lens
.
as_ptr
(
)
cose_signature
.
signer_cert
.
as_ptr
(
)
cose_signature
.
signer_cert
.
len
(
)
signature_bytes
.
as_ptr
(
)
signature_bytes
.
len
(
)
signature_type
)
}
)
;
}
