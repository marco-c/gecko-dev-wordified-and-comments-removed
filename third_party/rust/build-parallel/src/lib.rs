use
crossbeam_utils
:
:
thread
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
env
;
use
std
:
:
io
;
#
[
derive
(
Debug
)
]
pub
enum
Error
<
E
>
{
IOError
(
io
:
:
Error
)
BuildError
(
E
)
BuildPanic
(
Box
<
dyn
Any
+
Send
+
'
static
>
)
}
fn
compile_object
<
T
R
E
F
>
(
f
:
F
obj
:
&
T
)
-
>
Result
<
R
Error
<
E
>
>
where
T
:
'
static
+
Sync
R
:
'
static
+
Sync
+
Send
E
:
'
static
+
Sync
+
Send
F
:
Fn
(
&
T
)
-
>
Result
<
R
E
>
+
Sync
+
Send
{
f
(
obj
)
.
map_err
(
Error
:
:
BuildError
)
}
pub
fn
compile_objects
<
T
R
E
F
>
(
f
:
&
F
objs
:
&
[
T
]
)
-
>
Result
<
Vec
<
R
>
Error
<
E
>
>
where
T
:
'
static
+
Sync
R
:
'
static
+
Sync
+
Send
E
:
'
static
+
Sync
+
Send
F
:
Fn
(
&
T
)
-
>
Result
<
R
E
>
+
Sync
+
Send
{
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
:
:
SeqCst
}
;
use
std
:
:
sync
:
:
Once
;
let
server
=
jobserver
(
)
;
let
reacquire
=
server
.
release_raw
(
)
.
is_ok
(
)
;
let
res
=
thread
:
:
scope
(
|
s
|
{
let
error
=
AtomicBool
:
:
new
(
false
)
;
let
mut
handles
=
Vec
:
:
new
(
)
;
for
obj
in
objs
{
if
error
.
load
(
SeqCst
)
{
break
;
}
let
token
=
server
.
acquire
(
)
.
map_err
(
Error
:
:
IOError
)
?
;
let
state
=
State
{
obj
error
:
&
error
}
;
let
state
=
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
State
<
T
>
State
<
'
static
T
>
>
(
state
)
}
;
handles
.
push
(
s
.
spawn
(
|
_
|
{
let
state
:
State
<
T
>
=
state
;
let
result
=
compile_object
(
f
state
.
obj
)
;
if
result
.
is_err
(
)
{
state
.
error
.
store
(
true
SeqCst
)
;
}
drop
(
token
)
;
result
}
)
)
;
}
let
mut
output
=
Vec
:
:
new
(
)
;
for
handle
in
handles
{
match
handle
.
join
(
)
.
map_err
(
Error
:
:
BuildPanic
)
?
{
Ok
(
r
)
=
>
output
.
push
(
r
)
Err
(
err
)
=
>
return
Err
(
err
)
}
}
Ok
(
output
)
}
)
.
map_err
(
Error
:
:
BuildPanic
)
?
;
if
reacquire
{
server
.
acquire_raw
(
)
.
map_err
(
Error
:
:
IOError
)
?
;
}
return
res
;
struct
State
<
'
a
O
>
{
obj
:
&
'
a
O
error
:
&
'
a
AtomicBool
}
fn
jobserver
(
)
-
>
&
'
static
jobserver
:
:
Client
{
static
INIT
:
Once
=
Once
:
:
new
(
)
;
static
mut
JOBSERVER
:
Option
<
jobserver
:
:
Client
>
=
None
;
fn
_assert_sync
<
T
:
Sync
>
(
)
{
}
_assert_sync
:
:
<
jobserver
:
:
Client
>
(
)
;
unsafe
{
INIT
.
call_once
(
|
|
{
let
server
=
default_jobserver
(
)
;
JOBSERVER
=
Some
(
server
)
;
}
)
;
JOBSERVER
.
as_ref
(
)
.
unwrap
(
)
}
}
unsafe
fn
default_jobserver
(
)
-
>
jobserver
:
:
Client
{
if
let
Some
(
client
)
=
jobserver
:
:
Client
:
:
from_env
(
)
{
return
client
;
}
let
mut
parallelism
=
num_cpus
:
:
get
(
)
;
if
let
Ok
(
amt
)
=
env
:
:
var
(
"
NUM_JOBS
"
)
{
if
let
Ok
(
amt
)
=
amt
.
parse
(
)
{
parallelism
=
amt
;
}
}
let
client
=
jobserver
:
:
Client
:
:
new
(
parallelism
)
.
expect
(
"
failed
to
create
jobserver
"
)
;
client
.
acquire_raw
(
)
.
expect
(
"
failed
to
acquire
initial
"
)
;
client
}
}
#
[
test
]
fn
it_works
(
)
{
struct
Object
;
let
mut
v
=
Vec
:
:
new
(
)
;
for
_
in
0
.
.
4000
{
v
.
push
(
Object
)
;
}
compile_objects
:
:
<
Object
(
)
(
)
_
>
(
&
|
_
|
{
println
!
(
"
compile
{
:
?
}
"
std
:
:
thread
:
:
current
(
)
.
id
(
)
)
;
Ok
(
(
)
)
}
&
v
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_build_error
(
)
{
struct
Object
;
let
mut
v
=
Vec
:
:
new
(
)
;
v
.
push
(
Object
)
;
let
err
=
compile_objects
:
:
<
Object
(
)
(
)
_
>
(
&
|
_
|
{
return
Err
(
(
)
)
;
}
&
v
)
.
unwrap_err
(
)
;
match
err
{
Error
:
:
BuildError
(
_
)
=
>
{
}
_
=
>
panic
!
(
"
Unexpected
error
.
"
)
}
}
#
[
test
]
fn
test_build_panic
(
)
{
struct
Object
;
let
mut
v
=
Vec
:
:
new
(
)
;
v
.
push
(
Object
)
;
let
err
=
compile_objects
:
:
<
Object
(
)
(
)
_
>
(
&
|
_
|
{
panic
!
(
"
Panic
.
"
)
;
}
&
v
)
.
unwrap_err
(
)
;
match
err
{
Error
:
:
BuildPanic
(
_
)
=
>
{
}
_
=
>
panic
!
(
"
Unexpected
error
.
"
)
}
}
