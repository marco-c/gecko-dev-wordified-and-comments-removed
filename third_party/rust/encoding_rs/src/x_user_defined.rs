use
handles
:
:
*
;
use
variant
:
:
*
;
use
super
:
:
*
;
pub
struct
UserDefinedDecoder
;
impl
UserDefinedDecoder
{
pub
fn
new
(
)
-
>
VariantDecoder
{
VariantDecoder
:
:
UserDefined
(
UserDefinedDecoder
)
}
pub
fn
max_utf16_buffer_length
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
Some
(
byte_length
)
}
pub
fn
max_utf8_buffer_length_without_replacement
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
byte_length
.
checked_mul
(
3
)
}
pub
fn
max_utf8_buffer_length
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
byte_length
.
checked_mul
(
3
)
}
decoder_functions
!
(
{
}
{
}
{
}
{
if
b
<
0x80
{
/
/
XXX
optimize
ASCII
destination_handle
.
write_ascii
(
b
)
;
continue
;
}
destination_handle
.
write_upper_bmp
(
(
b
as
usize
+
0xF700usize
)
as
u16
)
;
continue
;
}
self
src_consumed
dest
source
b
destination_handle
_unread_handle
check_space_bmp
)
;
}
pub
struct
UserDefinedEncoder
;
impl
UserDefinedEncoder
{
pub
fn
new
(
encoding
:
&
'
static
Encoding
)
-
>
Encoder
{
Encoder
:
:
new
(
encoding
VariantEncoder
:
:
UserDefined
(
UserDefinedEncoder
)
)
}
pub
fn
max_buffer_length_from_utf16_without_replacement
(
&
self
u16_length
:
usize
)
-
>
Option
<
usize
>
{
Some
(
u16_length
)
}
pub
fn
max_buffer_length_from_utf8_without_replacement
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
Some
(
byte_length
)
}
encoder_functions
!
(
{
}
{
if
c
<
=
'
\
u
{
7F
}
'
{
/
/
TODO
optimize
ASCII
run
destination_handle
.
write_one
(
c
as
u8
)
;
continue
;
}
if
c
<
'
\
u
{
F780
}
'
|
|
c
>
'
\
u
{
F7FF
}
'
{
return
(
EncoderResult
:
:
Unmappable
(
c
)
unread_handle
.
consumed
(
)
destination_handle
.
written
(
)
)
;
}
destination_handle
.
write_one
(
(
c
as
usize
-
0xF700usize
)
as
u8
)
;
continue
;
}
self
src_consumed
source
dest
c
destination_handle
unread_handle
check_space_one
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
super
:
:
testing
:
:
*
;
use
super
:
:
super
:
:
*
;
fn
decode_x_user_defined
(
bytes
:
&
[
u8
]
expect
:
&
str
)
{
decode
(
X_USER_DEFINED
bytes
expect
)
;
}
fn
encode_x_user_defined
(
string
:
&
str
expect
:
&
[
u8
]
)
{
encode
(
X_USER_DEFINED
string
expect
)
;
}
#
[
test
]
fn
test_x_user_defined_decode
(
)
{
decode_x_user_defined
(
b
"
"
"
"
)
;
decode_x_user_defined
(
b
"
\
x61
\
x62
"
"
\
u
{
0061
}
\
u
{
0062
}
"
)
;
decode_x_user_defined
(
b
"
\
x80
\
xFF
"
"
\
u
{
F780
}
\
u
{
F7FF
}
"
)
;
}
#
[
test
]
fn
test_x_user_defined_encode
(
)
{
encode_x_user_defined
(
"
"
b
"
"
)
;
encode_x_user_defined
(
"
\
u
{
0061
}
\
u
{
0062
}
"
b
"
\
x61
\
x62
"
)
;
encode_x_user_defined
(
"
\
u
{
F780
}
\
u
{
F7FF
}
"
b
"
\
x80
\
xFF
"
)
;
encode_x_user_defined
(
"
\
u
{
F77F
}
\
u
{
F800
}
"
b
"
&
#
63359
;
&
#
63488
;
"
)
;
}
#
[
test
]
fn
test_x_user_defined_from_two_low_surrogates
(
)
{
let
expectation
=
b
"
&
#
65533
;
&
#
65533
;
"
;
let
mut
output
=
[
0u8
;
40
]
;
let
mut
encoder
=
X_USER_DEFINED
.
new_encoder
(
)
;
let
(
result
read
written
had_errors
)
=
encoder
.
encode_from_utf16
(
&
[
0xDC00u16
0xDEDEu16
]
&
mut
output
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
assert_eq
!
(
read
2
)
;
assert_eq
!
(
written
expectation
.
len
(
)
)
;
assert
!
(
had_errors
)
;
assert_eq
!
(
&
output
[
.
.
written
]
expectation
)
;
}
}
