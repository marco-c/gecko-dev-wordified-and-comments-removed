#
!
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
doc_markdown
inline_always
new_ret_no_self
)
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
encoding_rs
/
0
.
8
.
14
"
)
]
#
!
[
cfg_attr
(
feature
=
"
simd
-
accel
"
feature
(
platform_intrinsics
core_intrinsics
)
)
]
#
[
macro_use
]
extern
crate
cfg_if
;
#
[
cfg
(
all
(
feature
=
"
simd
-
accel
"
any
(
target_feature
=
"
sse2
"
all
(
target_endian
=
"
little
"
target_arch
=
"
aarch64
"
)
all
(
target_endian
=
"
little
"
target_feature
=
"
neon
"
)
)
)
)
]
extern
crate
simd
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
#
[
cfg
(
all
(
test
feature
=
"
serde
"
)
)
]
extern
crate
bincode
;
#
[
cfg
(
all
(
test
feature
=
"
serde
"
)
)
]
#
[
macro_use
]
extern
crate
serde_derive
;
#
[
cfg
(
all
(
test
feature
=
"
serde
"
)
)
]
extern
crate
serde_json
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
all
(
feature
=
"
simd
-
accel
"
any
(
target_feature
=
"
sse2
"
all
(
target_endian
=
"
little
"
target_arch
=
"
aarch64
"
)
all
(
target_endian
=
"
little
"
target_feature
=
"
neon
"
)
)
)
)
]
mod
simd_funcs
;
#
[
cfg
(
test
)
]
mod
testing
;
mod
big5
;
mod
euc_jp
;
mod
euc_kr
;
mod
gb18030
;
mod
iso_2022_jp
;
mod
replacement
;
mod
shift_jis
;
mod
single_byte
;
mod
utf_16
;
mod
utf_8
;
mod
x_user_defined
;
mod
ascii
;
mod
data
;
mod
handles
;
mod
variant
;
pub
mod
mem
;
use
ascii
:
:
ascii_valid_up_to
;
use
ascii
:
:
iso_2022_jp_ascii_valid_up_to
;
use
utf_8
:
:
utf8_valid_up_to
;
use
variant
:
:
*
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
hash
:
:
Hasher
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
de
:
:
Visitor
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
{
Deserialize
Deserializer
Serialize
Serializer
}
;
const
NCR_EXTRA
:
usize
=
10
;
const
LONGEST_LABEL_LENGTH
:
usize
=
19
;
pub
static
BIG5_INIT
:
Encoding
=
Encoding
{
name
:
"
Big5
"
variant
:
VariantEncoding
:
:
Big5
}
;
pub
static
BIG5
:
&
'
static
Encoding
=
&
BIG5_INIT
;
pub
static
EUC_JP_INIT
:
Encoding
=
Encoding
{
name
:
"
EUC
-
JP
"
variant
:
VariantEncoding
:
:
EucJp
}
;
pub
static
EUC_JP
:
&
'
static
Encoding
=
&
EUC_JP_INIT
;
pub
static
EUC_KR_INIT
:
Encoding
=
Encoding
{
name
:
"
EUC
-
KR
"
variant
:
VariantEncoding
:
:
EucKr
}
;
pub
static
EUC_KR
:
&
'
static
Encoding
=
&
EUC_KR_INIT
;
pub
static
GBK_INIT
:
Encoding
=
Encoding
{
name
:
"
GBK
"
variant
:
VariantEncoding
:
:
Gbk
}
;
pub
static
GBK
:
&
'
static
Encoding
=
&
GBK_INIT
;
pub
static
IBM866_INIT
:
Encoding
=
Encoding
{
name
:
"
IBM866
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
ibm866
0x0440
96
16
)
}
;
pub
static
IBM866
:
&
'
static
Encoding
=
&
IBM866_INIT
;
pub
static
ISO_2022_JP_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
2022
-
JP
"
variant
:
VariantEncoding
:
:
Iso2022Jp
}
;
pub
static
ISO_2022_JP
:
&
'
static
Encoding
=
&
ISO_2022_JP_INIT
;
pub
static
ISO_8859_10_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
10
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_10
0x00DA
90
6
)
}
;
pub
static
ISO_8859_10
:
&
'
static
Encoding
=
&
ISO_8859_10_INIT
;
pub
static
ISO_8859_13_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
13
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_13
0x00DF
95
1
)
}
;
pub
static
ISO_8859_13
:
&
'
static
Encoding
=
&
ISO_8859_13_INIT
;
pub
static
ISO_8859_14_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
14
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_14
0x00DF
95
17
)
}
;
pub
static
ISO_8859_14
:
&
'
static
Encoding
=
&
ISO_8859_14_INIT
;
pub
static
ISO_8859_15_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
15
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_15
0x00BF
63
65
)
}
;
pub
static
ISO_8859_15
:
&
'
static
Encoding
=
&
ISO_8859_15_INIT
;
pub
static
ISO_8859_16_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
16
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_16
0x00DF
95
4
)
}
;
pub
static
ISO_8859_16
:
&
'
static
Encoding
=
&
ISO_8859_16_INIT
;
pub
static
ISO_8859_2_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
2
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_2
0x00DF
95
1
)
}
;
pub
static
ISO_8859_2
:
&
'
static
Encoding
=
&
ISO_8859_2_INIT
;
pub
static
ISO_8859_3_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
3
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_3
0x00DF
95
4
)
}
;
pub
static
ISO_8859_3
:
&
'
static
Encoding
=
&
ISO_8859_3_INIT
;
pub
static
ISO_8859_4_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
4
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_4
0x00DF
95
1
)
}
;
pub
static
ISO_8859_4
:
&
'
static
Encoding
=
&
ISO_8859_4_INIT
;
pub
static
ISO_8859_5_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
5
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_5
0x040E
46
66
)
}
;
pub
static
ISO_8859_5
:
&
'
static
Encoding
=
&
ISO_8859_5_INIT
;
pub
static
ISO_8859_6_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
6
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_6
0x0621
65
26
)
}
;
pub
static
ISO_8859_6
:
&
'
static
Encoding
=
&
ISO_8859_6_INIT
;
pub
static
ISO_8859_7_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
7
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_7
0x03A3
83
44
)
}
;
pub
static
ISO_8859_7
:
&
'
static
Encoding
=
&
ISO_8859_7_INIT
;
pub
static
ISO_8859_8_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
8
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_8
0x05D0
96
27
)
}
;
pub
static
ISO_8859_8
:
&
'
static
Encoding
=
&
ISO_8859_8_INIT
;
pub
static
ISO_8859_8_I_INIT
:
Encoding
=
Encoding
{
name
:
"
ISO
-
8859
-
8
-
I
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
iso_8859_8
0x05D0
96
27
)
}
;
pub
static
ISO_8859_8_I
:
&
'
static
Encoding
=
&
ISO_8859_8_I_INIT
;
pub
static
KOI8_R_INIT
:
Encoding
=
Encoding
{
name
:
"
KOI8
-
R
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
koi8_r
0x044E
64
1
)
}
;
pub
static
KOI8_R
:
&
'
static
Encoding
=
&
KOI8_R_INIT
;
pub
static
KOI8_U_INIT
:
Encoding
=
Encoding
{
name
:
"
KOI8
-
U
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
koi8_u
0x044E
64
1
)
}
;
pub
static
KOI8_U
:
&
'
static
Encoding
=
&
KOI8_U_INIT
;
pub
static
SHIFT_JIS_INIT
:
Encoding
=
Encoding
{
name
:
"
Shift_JIS
"
variant
:
VariantEncoding
:
:
ShiftJis
}
;
pub
static
SHIFT_JIS
:
&
'
static
Encoding
=
&
SHIFT_JIS_INIT
;
pub
static
UTF_16BE_INIT
:
Encoding
=
Encoding
{
name
:
"
UTF
-
16BE
"
variant
:
VariantEncoding
:
:
Utf16Be
}
;
pub
static
UTF_16BE
:
&
'
static
Encoding
=
&
UTF_16BE_INIT
;
pub
static
UTF_16LE_INIT
:
Encoding
=
Encoding
{
name
:
"
UTF
-
16LE
"
variant
:
VariantEncoding
:
:
Utf16Le
}
;
pub
static
UTF_16LE
:
&
'
static
Encoding
=
&
UTF_16LE_INIT
;
pub
static
UTF_8_INIT
:
Encoding
=
Encoding
{
name
:
"
UTF
-
8
"
variant
:
VariantEncoding
:
:
Utf8
}
;
pub
static
UTF_8
:
&
'
static
Encoding
=
&
UTF_8_INIT
;
pub
static
GB18030_INIT
:
Encoding
=
Encoding
{
name
:
"
gb18030
"
variant
:
VariantEncoding
:
:
Gb18030
}
;
pub
static
GB18030
:
&
'
static
Encoding
=
&
GB18030_INIT
;
pub
static
MACINTOSH_INIT
:
Encoding
=
Encoding
{
name
:
"
macintosh
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
macintosh
0x00CD
106
3
)
}
;
pub
static
MACINTOSH
:
&
'
static
Encoding
=
&
MACINTOSH_INIT
;
pub
static
REPLACEMENT_INIT
:
Encoding
=
Encoding
{
name
:
"
replacement
"
variant
:
VariantEncoding
:
:
Replacement
}
;
pub
static
REPLACEMENT
:
&
'
static
Encoding
=
&
REPLACEMENT_INIT
;
pub
static
WINDOWS_1250_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1250
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1250
0x00DC
92
2
)
}
;
pub
static
WINDOWS_1250
:
&
'
static
Encoding
=
&
WINDOWS_1250_INIT
;
pub
static
WINDOWS_1251_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1251
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1251
0x0410
64
64
)
}
;
pub
static
WINDOWS_1251
:
&
'
static
Encoding
=
&
WINDOWS_1251_INIT
;
pub
static
WINDOWS_1252_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1252
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1252
0x00A0
32
96
)
}
;
pub
static
WINDOWS_1252
:
&
'
static
Encoding
=
&
WINDOWS_1252_INIT
;
pub
static
WINDOWS_1253_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1253
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1253
0x03A3
83
44
)
}
;
pub
static
WINDOWS_1253
:
&
'
static
Encoding
=
&
WINDOWS_1253_INIT
;
pub
static
WINDOWS_1254_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1254
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1254
0x00DF
95
17
)
}
;
pub
static
WINDOWS_1254
:
&
'
static
Encoding
=
&
WINDOWS_1254_INIT
;
pub
static
WINDOWS_1255_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1255
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1255
0x05D0
96
27
)
}
;
pub
static
WINDOWS_1255
:
&
'
static
Encoding
=
&
WINDOWS_1255_INIT
;
pub
static
WINDOWS_1256_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1256
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1256
0x0621
65
22
)
}
;
pub
static
WINDOWS_1256
:
&
'
static
Encoding
=
&
WINDOWS_1256_INIT
;
pub
static
WINDOWS_1257_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1257
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1257
0x00DF
95
1
)
}
;
pub
static
WINDOWS_1257
:
&
'
static
Encoding
=
&
WINDOWS_1257_INIT
;
pub
static
WINDOWS_1258_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
1258
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_1258
0x00DF
95
4
)
}
;
pub
static
WINDOWS_1258
:
&
'
static
Encoding
=
&
WINDOWS_1258_INIT
;
pub
static
WINDOWS_874_INIT
:
Encoding
=
Encoding
{
name
:
"
windows
-
874
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
windows_874
0x0E01
33
58
)
}
;
pub
static
WINDOWS_874
:
&
'
static
Encoding
=
&
WINDOWS_874_INIT
;
pub
static
X_MAC_CYRILLIC_INIT
:
Encoding
=
Encoding
{
name
:
"
x
-
mac
-
cyrillic
"
variant
:
VariantEncoding
:
:
SingleByte
(
&
data
:
:
SINGLE_BYTE_DATA
.
x_mac_cyrillic
0x0430
96
31
)
}
;
pub
static
X_MAC_CYRILLIC
:
&
'
static
Encoding
=
&
X_MAC_CYRILLIC_INIT
;
pub
static
X_USER_DEFINED_INIT
:
Encoding
=
Encoding
{
name
:
"
x
-
user
-
defined
"
variant
:
VariantEncoding
:
:
UserDefined
}
;
pub
static
X_USER_DEFINED
:
&
'
static
Encoding
=
&
X_USER_DEFINED_INIT
;
static
LABELS_SORTED
:
[
&
'
static
str
;
219
]
=
[
"
l1
"
"
l2
"
"
l3
"
"
l4
"
"
l5
"
"
l6
"
"
l9
"
"
866
"
"
mac
"
"
koi
"
"
gbk
"
"
big5
"
"
utf8
"
"
koi8
"
"
sjis
"
"
ms932
"
"
cp866
"
"
utf
-
8
"
"
cp819
"
"
ascii
"
"
x
-
gbk
"
"
greek
"
"
cp1250
"
"
cp1251
"
"
latin1
"
"
gb2312
"
"
cp1252
"
"
latin2
"
"
cp1253
"
"
latin3
"
"
cp1254
"
"
latin4
"
"
cp1255
"
"
csbig5
"
"
latin5
"
"
utf
-
16
"
"
cp1256
"
"
ibm866
"
"
latin6
"
"
cp1257
"
"
cp1258
"
"
greek8
"
"
ibm819
"
"
arabic
"
"
visual
"
"
korean
"
"
euc
-
jp
"
"
koi8
-
r
"
"
koi8_r
"
"
euc
-
kr
"
"
x
-
sjis
"
"
koi8
-
u
"
"
hebrew
"
"
tis
-
620
"
"
gb18030
"
"
ksc5601
"
"
gb_2312
"
"
dos
-
874
"
"
cn
-
big5
"
"
chinese
"
"
logical
"
"
cskoi8r
"
"
cseuckr
"
"
koi8
-
ru
"
"
x
-
cp1250
"
"
ksc_5601
"
"
x
-
cp1251
"
"
iso88591
"
"
csgb2312
"
"
x
-
cp1252
"
"
iso88592
"
"
x
-
cp1253
"
"
iso88593
"
"
ecma
-
114
"
"
x
-
cp1254
"
"
iso88594
"
"
x
-
cp1255
"
"
iso88595
"
"
x
-
x
-
big5
"
"
x
-
cp1256
"
"
csibm866
"
"
iso88596
"
"
x
-
cp1257
"
"
iso88597
"
"
asmo
-
708
"
"
ecma
-
118
"
"
elot_928
"
"
x
-
cp1258
"
"
iso88598
"
"
iso88599
"
"
cyrillic
"
"
utf
-
16be
"
"
utf
-
16le
"
"
us
-
ascii
"
"
ms_kanji
"
"
x
-
euc
-
jp
"
"
iso885910
"
"
iso8859
-
1
"
"
iso885911
"
"
iso8859
-
2
"
"
iso8859
-
3
"
"
iso885913
"
"
iso8859
-
4
"
"
iso885914
"
"
iso8859
-
5
"
"
iso885915
"
"
iso8859
-
6
"
"
iso8859
-
7
"
"
iso8859
-
8
"
"
iso
-
ir
-
58
"
"
iso8859
-
9
"
"
macintosh
"
"
shift
-
jis
"
"
shift_jis
"
"
iso
-
ir
-
100
"
"
iso8859
-
10
"
"
iso
-
ir
-
110
"
"
gb_2312
-
80
"
"
iso
-
8859
-
1
"
"
iso_8859
-
1
"
"
iso
-
ir
-
101
"
"
iso8859
-
11
"
"
iso
-
8859
-
2
"
"
iso_8859
-
2
"
"
hz
-
gb
-
2312
"
"
iso
-
8859
-
3
"
"
iso_8859
-
3
"
"
iso8859
-
13
"
"
iso
-
8859
-
4
"
"
iso_8859
-
4
"
"
iso8859
-
14
"
"
iso
-
ir
-
144
"
"
iso
-
8859
-
5
"
"
iso_8859
-
5
"
"
iso8859
-
15
"
"
iso
-
8859
-
6
"
"
iso_8859
-
6
"
"
iso
-
ir
-
126
"
"
iso
-
8859
-
7
"
"
iso_8859
-
7
"
"
iso
-
ir
-
127
"
"
iso
-
ir
-
157
"
"
iso
-
8859
-
8
"
"
iso_8859
-
8
"
"
iso
-
ir
-
138
"
"
iso
-
ir
-
148
"
"
iso
-
8859
-
9
"
"
iso_8859
-
9
"
"
iso
-
ir
-
109
"
"
iso
-
ir
-
149
"
"
big5
-
hkscs
"
"
csshiftjis
"
"
iso
-
8859
-
10
"
"
iso
-
8859
-
11
"
"
csisolatin1
"
"
csisolatin2
"
"
iso
-
8859
-
13
"
"
csisolatin3
"
"
iso
-
8859
-
14
"
"
windows
-
874
"
"
csisolatin4
"
"
iso
-
8859
-
15
"
"
iso_8859
-
15
"
"
csisolatin5
"
"
iso
-
8859
-
16
"
"
csisolatin6
"
"
windows
-
949
"
"
csisolatin9
"
"
csiso88596e
"
"
csiso88598e
"
"
csmacintosh
"
"
csiso88596i
"
"
csiso88598i
"
"
windows
-
31j
"
"
x
-
mac
-
roman
"
"
iso
-
2022
-
cn
"
"
iso
-
2022
-
jp
"
"
csiso2022jp
"
"
iso
-
2022
-
kr
"
"
csiso2022kr
"
"
replacement
"
"
windows
-
1250
"
"
windows
-
1251
"
"
windows
-
1252
"
"
windows
-
1253
"
"
windows
-
1254
"
"
windows
-
1255
"
"
windows
-
1256
"
"
windows
-
1257
"
"
windows
-
1258
"
"
iso
-
8859
-
6
-
e
"
"
iso
-
8859
-
8
-
e
"
"
iso
-
8859
-
6
-
i
"
"
iso
-
8859
-
8
-
i
"
"
sun_eu_greek
"
"
csksc56011987
"
"
ks_c_5601
-
1987
"
"
ansi_x3
.
4
-
1968
"
"
ks_c_5601
-
1989
"
"
x
-
mac
-
cyrillic
"
"
x
-
user
-
defined
"
"
csiso58gb231280
"
"
iso_8859
-
1
:
1987
"
"
iso_8859
-
2
:
1987
"
"
iso_8859
-
6
:
1987
"
"
iso_8859
-
7
:
1987
"
"
iso_8859
-
3
:
1988
"
"
iso_8859
-
4
:
1988
"
"
iso_8859
-
5
:
1988
"
"
iso_8859
-
8
:
1988
"
"
iso_8859
-
9
:
1989
"
"
csisolatingreek
"
"
x
-
mac
-
ukrainian
"
"
iso
-
2022
-
cn
-
ext
"
"
csisolatinarabic
"
"
csisolatinhebrew
"
"
unicode
-
1
-
1
-
utf
-
8
"
"
csisolatincyrillic
"
"
cseucpkdfmtjapanese
"
]
;
static
ENCODINGS_IN_LABEL_SORT
:
[
&
'
static
Encoding
;
219
]
=
[
&
WINDOWS_1252_INIT
&
ISO_8859_2_INIT
&
ISO_8859_3_INIT
&
ISO_8859_4_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_10_INIT
&
ISO_8859_15_INIT
&
IBM866_INIT
&
MACINTOSH_INIT
&
KOI8_R_INIT
&
GBK_INIT
&
BIG5_INIT
&
UTF_8_INIT
&
KOI8_R_INIT
&
SHIFT_JIS_INIT
&
SHIFT_JIS_INIT
&
IBM866_INIT
&
UTF_8_INIT
&
WINDOWS_1252_INIT
&
WINDOWS_1252_INIT
&
GBK_INIT
&
ISO_8859_7_INIT
&
WINDOWS_1250_INIT
&
WINDOWS_1251_INIT
&
WINDOWS_1252_INIT
&
GBK_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_2_INIT
&
WINDOWS_1253_INIT
&
ISO_8859_3_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_4_INIT
&
WINDOWS_1255_INIT
&
BIG5_INIT
&
WINDOWS_1254_INIT
&
UTF_16LE_INIT
&
WINDOWS_1256_INIT
&
IBM866_INIT
&
ISO_8859_10_INIT
&
WINDOWS_1257_INIT
&
WINDOWS_1258_INIT
&
ISO_8859_7_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_6_INIT
&
ISO_8859_8_INIT
&
EUC_KR_INIT
&
EUC_JP_INIT
&
KOI8_R_INIT
&
KOI8_R_INIT
&
EUC_KR_INIT
&
SHIFT_JIS_INIT
&
KOI8_U_INIT
&
ISO_8859_8_INIT
&
WINDOWS_874_INIT
&
GB18030_INIT
&
EUC_KR_INIT
&
GBK_INIT
&
WINDOWS_874_INIT
&
BIG5_INIT
&
GBK_INIT
&
ISO_8859_8_I_INIT
&
KOI8_R_INIT
&
EUC_KR_INIT
&
KOI8_U_INIT
&
WINDOWS_1250_INIT
&
EUC_KR_INIT
&
WINDOWS_1251_INIT
&
WINDOWS_1252_INIT
&
GBK_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_2_INIT
&
WINDOWS_1253_INIT
&
ISO_8859_3_INIT
&
ISO_8859_6_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_4_INIT
&
WINDOWS_1255_INIT
&
ISO_8859_5_INIT
&
BIG5_INIT
&
WINDOWS_1256_INIT
&
IBM866_INIT
&
ISO_8859_6_INIT
&
WINDOWS_1257_INIT
&
ISO_8859_7_INIT
&
ISO_8859_6_INIT
&
ISO_8859_7_INIT
&
ISO_8859_7_INIT
&
WINDOWS_1258_INIT
&
ISO_8859_8_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_5_INIT
&
UTF_16BE_INIT
&
UTF_16LE_INIT
&
WINDOWS_1252_INIT
&
SHIFT_JIS_INIT
&
EUC_JP_INIT
&
ISO_8859_10_INIT
&
WINDOWS_1252_INIT
&
WINDOWS_874_INIT
&
ISO_8859_2_INIT
&
ISO_8859_3_INIT
&
ISO_8859_13_INIT
&
ISO_8859_4_INIT
&
ISO_8859_14_INIT
&
ISO_8859_5_INIT
&
ISO_8859_15_INIT
&
ISO_8859_6_INIT
&
ISO_8859_7_INIT
&
ISO_8859_8_INIT
&
GBK_INIT
&
WINDOWS_1254_INIT
&
MACINTOSH_INIT
&
SHIFT_JIS_INIT
&
SHIFT_JIS_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_10_INIT
&
ISO_8859_4_INIT
&
GBK_INIT
&
WINDOWS_1252_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_2_INIT
&
WINDOWS_874_INIT
&
ISO_8859_2_INIT
&
ISO_8859_2_INIT
&
REPLACEMENT_INIT
&
ISO_8859_3_INIT
&
ISO_8859_3_INIT
&
ISO_8859_13_INIT
&
ISO_8859_4_INIT
&
ISO_8859_4_INIT
&
ISO_8859_14_INIT
&
ISO_8859_5_INIT
&
ISO_8859_5_INIT
&
ISO_8859_5_INIT
&
ISO_8859_15_INIT
&
ISO_8859_6_INIT
&
ISO_8859_6_INIT
&
ISO_8859_7_INIT
&
ISO_8859_7_INIT
&
ISO_8859_7_INIT
&
ISO_8859_6_INIT
&
ISO_8859_10_INIT
&
ISO_8859_8_INIT
&
ISO_8859_8_INIT
&
ISO_8859_8_INIT
&
WINDOWS_1254_INIT
&
WINDOWS_1254_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_3_INIT
&
EUC_KR_INIT
&
BIG5_INIT
&
SHIFT_JIS_INIT
&
ISO_8859_10_INIT
&
WINDOWS_874_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_2_INIT
&
ISO_8859_13_INIT
&
ISO_8859_3_INIT
&
ISO_8859_14_INIT
&
WINDOWS_874_INIT
&
ISO_8859_4_INIT
&
ISO_8859_15_INIT
&
ISO_8859_15_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_16_INIT
&
ISO_8859_10_INIT
&
EUC_KR_INIT
&
ISO_8859_15_INIT
&
ISO_8859_6_INIT
&
ISO_8859_8_INIT
&
MACINTOSH_INIT
&
ISO_8859_6_INIT
&
ISO_8859_8_I_INIT
&
SHIFT_JIS_INIT
&
MACINTOSH_INIT
&
REPLACEMENT_INIT
&
ISO_2022_JP_INIT
&
ISO_2022_JP_INIT
&
REPLACEMENT_INIT
&
REPLACEMENT_INIT
&
REPLACEMENT_INIT
&
WINDOWS_1250_INIT
&
WINDOWS_1251_INIT
&
WINDOWS_1252_INIT
&
WINDOWS_1253_INIT
&
WINDOWS_1254_INIT
&
WINDOWS_1255_INIT
&
WINDOWS_1256_INIT
&
WINDOWS_1257_INIT
&
WINDOWS_1258_INIT
&
ISO_8859_6_INIT
&
ISO_8859_8_INIT
&
ISO_8859_6_INIT
&
ISO_8859_8_I_INIT
&
ISO_8859_7_INIT
&
EUC_KR_INIT
&
EUC_KR_INIT
&
WINDOWS_1252_INIT
&
EUC_KR_INIT
&
X_MAC_CYRILLIC_INIT
&
X_USER_DEFINED_INIT
&
GBK_INIT
&
WINDOWS_1252_INIT
&
ISO_8859_2_INIT
&
ISO_8859_6_INIT
&
ISO_8859_7_INIT
&
ISO_8859_3_INIT
&
ISO_8859_4_INIT
&
ISO_8859_5_INIT
&
ISO_8859_8_INIT
&
WINDOWS_1254_INIT
&
ISO_8859_7_INIT
&
X_MAC_CYRILLIC_INIT
&
REPLACEMENT_INIT
&
ISO_8859_6_INIT
&
ISO_8859_8_INIT
&
UTF_8_INIT
&
ISO_8859_5_INIT
&
EUC_JP_INIT
]
;
pub
struct
Encoding
{
name
:
&
'
static
str
variant
:
VariantEncoding
}
impl
Encoding
{
pub
fn
for_label
(
label
:
&
[
u8
]
)
-
>
Option
<
&
'
static
Encoding
>
{
let
mut
trimmed
=
[
0u8
;
LONGEST_LABEL_LENGTH
]
;
let
mut
trimmed_pos
=
0usize
;
let
mut
iter
=
label
.
into_iter
(
)
;
loop
{
match
iter
.
next
(
)
{
None
=
>
{
return
None
;
}
Some
(
byte
)
=
>
{
match
*
byte
{
0x09u8
|
0x0Au8
|
0x0Cu8
|
0x0Du8
|
0x20u8
=
>
{
continue
;
}
b
'
A
'
.
.
.
b
'
Z
'
=
>
{
trimmed
[
trimmed_pos
]
=
*
byte
+
0x20u8
;
trimmed_pos
=
1usize
;
break
;
}
b
'
a
'
.
.
.
b
'
z
'
|
b
'
0
'
.
.
.
b
'
9
'
|
b
'
-
'
|
b
'
_
'
|
b
'
:
'
|
b
'
.
'
=
>
{
trimmed
[
trimmed_pos
]
=
*
byte
;
trimmed_pos
=
1usize
;
break
;
}
_
=
>
{
return
None
;
}
}
}
}
}
loop
{
match
iter
.
next
(
)
{
None
=
>
{
break
;
}
Some
(
byte
)
=
>
{
match
*
byte
{
0x09u8
|
0x0Au8
|
0x0Cu8
|
0x0Du8
|
0x20u8
=
>
{
break
;
}
b
'
A
'
.
.
.
b
'
Z
'
=
>
{
if
trimmed_pos
=
=
LONGEST_LABEL_LENGTH
{
return
None
;
}
trimmed
[
trimmed_pos
]
=
*
byte
+
0x20u8
;
trimmed_pos
+
=
1usize
;
continue
;
}
b
'
a
'
.
.
.
b
'
z
'
|
b
'
0
'
.
.
.
b
'
9
'
|
b
'
-
'
|
b
'
_
'
|
b
'
:
'
|
b
'
.
'
=
>
{
if
trimmed_pos
=
=
LONGEST_LABEL_LENGTH
{
return
None
;
}
trimmed
[
trimmed_pos
]
=
*
byte
;
trimmed_pos
+
=
1usize
;
continue
;
}
_
=
>
{
return
None
;
}
}
}
}
}
loop
{
match
iter
.
next
(
)
{
None
=
>
{
break
;
}
Some
(
byte
)
=
>
{
match
*
byte
{
0x09u8
|
0x0Au8
|
0x0Cu8
|
0x0Du8
|
0x20u8
=
>
{
continue
;
}
_
=
>
{
return
None
;
}
}
}
}
}
let
candidate
=
&
trimmed
[
.
.
trimmed_pos
]
;
match
LABELS_SORTED
.
binary_search_by
(
|
probe
|
{
let
bytes
=
probe
.
as_bytes
(
)
;
let
c
=
bytes
.
len
(
)
.
cmp
(
&
candidate
.
len
(
)
)
;
if
c
!
=
Ordering
:
:
Equal
{
return
c
;
}
let
probe_iter
=
bytes
.
iter
(
)
.
rev
(
)
;
let
candidate_iter
=
candidate
.
iter
(
)
.
rev
(
)
;
probe_iter
.
cmp
(
candidate_iter
)
}
)
{
Ok
(
i
)
=
>
Some
(
ENCODINGS_IN_LABEL_SORT
[
i
]
)
Err
(
_
)
=
>
None
}
}
#
[
inline
]
pub
fn
for_label_no_replacement
(
label
:
&
[
u8
]
)
-
>
Option
<
&
'
static
Encoding
>
{
match
Encoding
:
:
for_label
(
label
)
{
None
=
>
None
Some
(
encoding
)
=
>
{
if
encoding
=
=
REPLACEMENT
{
None
}
else
{
Some
(
encoding
)
}
}
}
}
#
[
inline
]
pub
fn
for_bom
(
buffer
:
&
[
u8
]
)
-
>
Option
<
(
&
'
static
Encoding
usize
)
>
{
if
buffer
.
starts_with
(
b
"
\
xEF
\
xBB
\
xBF
"
)
{
Some
(
(
UTF_8
3
)
)
}
else
if
buffer
.
starts_with
(
b
"
\
xFF
\
xFE
"
)
{
Some
(
(
UTF_16LE
2
)
)
}
else
if
buffer
.
starts_with
(
b
"
\
xFE
\
xFF
"
)
{
Some
(
(
UTF_16BE
2
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
name
(
&
'
static
self
)
-
>
&
'
static
str
{
self
.
name
}
#
[
inline
]
pub
fn
can_encode_everything
(
&
'
static
self
)
-
>
bool
{
self
.
output_encoding
(
)
=
=
UTF_8
}
#
[
inline
]
pub
fn
is_ascii_compatible
(
&
'
static
self
)
-
>
bool
{
!
(
self
=
=
REPLACEMENT
|
|
self
=
=
UTF_16BE
|
|
self
=
=
UTF_16LE
|
|
self
=
=
ISO_2022_JP
)
}
#
[
inline
]
pub
fn
is_single_byte
(
&
'
static
self
)
-
>
bool
{
self
.
variant
.
is_single_byte
(
)
}
#
[
inline
]
fn
is_potentially_borrowable
(
&
'
static
self
)
-
>
bool
{
!
(
self
=
=
REPLACEMENT
|
|
self
=
=
UTF_16BE
|
|
self
=
=
UTF_16LE
)
}
#
[
inline
]
pub
fn
output_encoding
(
&
'
static
self
)
-
>
&
'
static
Encoding
{
if
self
=
=
REPLACEMENT
|
|
self
=
=
UTF_16BE
|
|
self
=
=
UTF_16LE
{
UTF_8
}
else
{
self
}
}
#
[
inline
]
pub
fn
decode
<
'
a
>
(
&
'
static
self
bytes
:
&
'
a
[
u8
]
)
-
>
(
Cow
<
'
a
str
>
&
'
static
Encoding
bool
)
{
let
(
encoding
without_bom
)
=
match
Encoding
:
:
for_bom
(
bytes
)
{
Some
(
(
encoding
bom_length
)
)
=
>
(
encoding
&
bytes
[
bom_length
.
.
]
)
None
=
>
(
self
bytes
)
}
;
let
(
cow
had_errors
)
=
encoding
.
decode_without_bom_handling
(
without_bom
)
;
(
cow
encoding
had_errors
)
}
#
[
inline
]
pub
fn
decode_with_bom_removal
<
'
a
>
(
&
'
static
self
bytes
:
&
'
a
[
u8
]
)
-
>
(
Cow
<
'
a
str
>
bool
)
{
let
without_bom
=
if
self
=
=
UTF_8
&
&
bytes
.
starts_with
(
b
"
\
xEF
\
xBB
\
xBF
"
)
{
&
bytes
[
3
.
.
]
}
else
if
(
self
=
=
UTF_16LE
&
&
bytes
.
starts_with
(
b
"
\
xFF
\
xFE
"
)
)
|
|
(
self
=
=
UTF_16BE
&
&
bytes
.
starts_with
(
b
"
\
xFE
\
xFF
"
)
)
{
&
bytes
[
2
.
.
]
}
else
{
bytes
}
;
self
.
decode_without_bom_handling
(
without_bom
)
}
pub
fn
decode_without_bom_handling
<
'
a
>
(
&
'
static
self
bytes
:
&
'
a
[
u8
]
)
-
>
(
Cow
<
'
a
str
>
bool
)
{
let
(
mut
decoder
mut
string
mut
total_read
)
=
if
self
.
is_potentially_borrowable
(
)
{
let
valid_up_to
=
if
self
=
=
UTF_8
{
utf8_valid_up_to
(
bytes
)
}
else
if
self
=
=
ISO_2022_JP
{
iso_2022_jp_ascii_valid_up_to
(
bytes
)
}
else
{
ascii_valid_up_to
(
bytes
)
}
;
if
valid_up_to
=
=
bytes
.
len
(
)
{
let
str
:
&
str
=
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
bytes
)
}
;
return
(
Cow
:
:
Borrowed
(
str
)
false
)
;
}
let
decoder
=
self
.
new_decoder_without_bom_handling
(
)
;
let
rounded_without_replacement
=
checked_next_power_of_two
(
checked_add
(
valid_up_to
decoder
.
max_utf8_buffer_length_without_replacement
(
bytes
.
len
(
)
-
valid_up_to
)
)
)
;
let
with_replacement
=
checked_add
(
valid_up_to
decoder
.
max_utf8_buffer_length
(
bytes
.
len
(
)
-
valid_up_to
)
)
;
let
mut
string
=
String
:
:
with_capacity
(
checked_min
(
rounded_without_replacement
with_replacement
)
.
unwrap
(
)
)
;
unsafe
{
let
vec
=
string
.
as_mut_vec
(
)
;
vec
.
set_len
(
valid_up_to
)
;
std
:
:
ptr
:
:
copy_nonoverlapping
(
bytes
.
as_ptr
(
)
vec
.
as_mut_ptr
(
)
valid_up_to
)
;
}
(
decoder
string
valid_up_to
)
}
else
{
let
decoder
=
self
.
new_decoder_without_bom_handling
(
)
;
let
rounded_without_replacement
=
checked_next_power_of_two
(
decoder
.
max_utf8_buffer_length_without_replacement
(
bytes
.
len
(
)
)
)
;
let
with_replacement
=
decoder
.
max_utf8_buffer_length
(
bytes
.
len
(
)
)
;
let
string
=
String
:
:
with_capacity
(
checked_min
(
rounded_without_replacement
with_replacement
)
.
unwrap
(
)
)
;
(
decoder
string
0
)
}
;
let
mut
total_had_errors
=
false
;
loop
{
let
(
result
read
had_errors
)
=
decoder
.
decode_to_string
(
&
bytes
[
total_read
.
.
]
&
mut
string
true
)
;
total_read
+
=
read
;
total_had_errors
|
=
had_errors
;
match
result
{
CoderResult
:
:
InputEmpty
=
>
{
debug_assert_eq
!
(
total_read
bytes
.
len
(
)
)
;
return
(
Cow
:
:
Owned
(
string
)
total_had_errors
)
;
}
CoderResult
:
:
OutputFull
=
>
{
let
needed
=
decoder
.
max_utf8_buffer_length
(
bytes
.
len
(
)
-
total_read
)
;
string
.
reserve
(
needed
.
unwrap
(
)
)
;
}
}
}
}
pub
fn
decode_without_bom_handling_and_without_replacement
<
'
a
>
(
&
'
static
self
bytes
:
&
'
a
[
u8
]
)
-
>
Option
<
Cow
<
'
a
str
>
>
{
if
self
=
=
UTF_8
{
let
valid_up_to
=
utf8_valid_up_to
(
bytes
)
;
if
valid_up_to
=
=
bytes
.
len
(
)
{
let
str
:
&
str
=
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
bytes
)
}
;
return
Some
(
Cow
:
:
Borrowed
(
str
)
)
;
}
return
None
;
}
let
(
mut
decoder
mut
string
input
)
=
if
self
.
is_potentially_borrowable
(
)
{
let
valid_up_to
=
if
self
=
=
ISO_2022_JP
{
iso_2022_jp_ascii_valid_up_to
(
bytes
)
}
else
{
ascii_valid_up_to
(
bytes
)
}
;
if
valid_up_to
=
=
bytes
.
len
(
)
{
let
str
:
&
str
=
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
bytes
)
}
;
return
Some
(
Cow
:
:
Borrowed
(
str
)
)
;
}
let
decoder
=
self
.
new_decoder_without_bom_handling
(
)
;
let
mut
string
=
String
:
:
with_capacity
(
checked_add
(
valid_up_to
decoder
.
max_utf8_buffer_length_without_replacement
(
bytes
.
len
(
)
-
valid_up_to
)
)
.
unwrap
(
)
)
;
unsafe
{
let
vec
=
string
.
as_mut_vec
(
)
;
vec
.
set_len
(
valid_up_to
)
;
std
:
:
ptr
:
:
copy_nonoverlapping
(
bytes
.
as_ptr
(
)
vec
.
as_mut_ptr
(
)
valid_up_to
)
;
}
(
decoder
string
&
bytes
[
valid_up_to
.
.
]
)
}
else
{
let
decoder
=
self
.
new_decoder_without_bom_handling
(
)
;
let
string
=
String
:
:
with_capacity
(
decoder
.
max_utf8_buffer_length_without_replacement
(
bytes
.
len
(
)
)
.
unwrap
(
)
)
;
(
decoder
string
bytes
)
}
;
let
(
result
read
)
=
decoder
.
decode_to_string_without_replacement
(
input
&
mut
string
true
)
;
match
result
{
DecoderResult
:
:
InputEmpty
=
>
{
debug_assert_eq
!
(
read
input
.
len
(
)
)
;
Some
(
Cow
:
:
Owned
(
string
)
)
}
DecoderResult
:
:
Malformed
(
_
_
)
=
>
None
DecoderResult
:
:
OutputFull
=
>
unreachable
!
(
)
}
}
pub
fn
encode
<
'
a
>
(
&
'
static
self
string
:
&
'
a
str
)
-
>
(
Cow
<
'
a
[
u8
]
>
&
'
static
Encoding
bool
)
{
let
output_encoding
=
self
.
output_encoding
(
)
;
if
output_encoding
=
=
UTF_8
{
return
(
Cow
:
:
Borrowed
(
string
.
as_bytes
(
)
)
output_encoding
false
)
;
}
debug_assert
!
(
output_encoding
.
is_potentially_borrowable
(
)
)
;
let
bytes
=
string
.
as_bytes
(
)
;
let
valid_up_to
=
if
output_encoding
=
=
ISO_2022_JP
{
iso_2022_jp_ascii_valid_up_to
(
bytes
)
}
else
{
ascii_valid_up_to
(
bytes
)
}
;
if
valid_up_to
=
=
bytes
.
len
(
)
{
return
(
Cow
:
:
Borrowed
(
bytes
)
output_encoding
false
)
;
}
let
mut
encoder
=
output_encoding
.
new_encoder
(
)
;
let
mut
vec
:
Vec
<
u8
>
=
Vec
:
:
with_capacity
(
(
checked_add
(
valid_up_to
encoder
.
max_buffer_length_from_utf8_if_no_unmappables
(
string
.
len
(
)
-
valid_up_to
)
)
)
.
unwrap
(
)
.
next_power_of_two
(
)
)
;
unsafe
{
vec
.
set_len
(
valid_up_to
)
;
std
:
:
ptr
:
:
copy_nonoverlapping
(
bytes
.
as_ptr
(
)
vec
.
as_mut_ptr
(
)
valid_up_to
)
;
}
let
mut
total_read
=
valid_up_to
;
let
mut
total_had_errors
=
false
;
loop
{
let
(
result
read
had_errors
)
=
encoder
.
encode_from_utf8_to_vec
(
&
string
[
total_read
.
.
]
&
mut
vec
true
)
;
total_read
+
=
read
;
total_had_errors
|
=
had_errors
;
match
result
{
CoderResult
:
:
InputEmpty
=
>
{
debug_assert_eq
!
(
total_read
string
.
len
(
)
)
;
return
(
Cow
:
:
Owned
(
vec
)
output_encoding
total_had_errors
)
;
}
CoderResult
:
:
OutputFull
=
>
{
let
needed
=
encoder
.
max_buffer_length_from_utf8_if_no_unmappables
(
string
.
len
(
)
-
total_read
)
;
let
rounded
=
(
checked_add
(
vec
.
capacity
(
)
needed
)
)
.
unwrap
(
)
.
next_power_of_two
(
)
;
let
additional
=
rounded
-
vec
.
len
(
)
;
vec
.
reserve_exact
(
additional
)
;
}
}
}
}
fn
new_variant_decoder
(
&
'
static
self
)
-
>
VariantDecoder
{
self
.
variant
.
new_variant_decoder
(
)
}
#
[
inline
]
pub
fn
new_decoder
(
&
'
static
self
)
-
>
Decoder
{
Decoder
:
:
new
(
self
self
.
new_variant_decoder
(
)
BomHandling
:
:
Sniff
)
}
#
[
inline
]
pub
fn
new_decoder_with_bom_removal
(
&
'
static
self
)
-
>
Decoder
{
Decoder
:
:
new
(
self
self
.
new_variant_decoder
(
)
BomHandling
:
:
Remove
)
}
#
[
inline
]
pub
fn
new_decoder_without_bom_handling
(
&
'
static
self
)
-
>
Decoder
{
Decoder
:
:
new
(
self
self
.
new_variant_decoder
(
)
BomHandling
:
:
Off
)
}
#
[
inline
]
pub
fn
new_encoder
(
&
'
static
self
)
-
>
Encoder
{
let
enc
=
self
.
output_encoding
(
)
;
enc
.
variant
.
new_encoder
(
enc
)
}
pub
fn
utf8_valid_up_to
(
bytes
:
&
[
u8
]
)
-
>
usize
{
utf8_valid_up_to
(
bytes
)
}
pub
fn
ascii_valid_up_to
(
bytes
:
&
[
u8
]
)
-
>
usize
{
ascii_valid_up_to
(
bytes
)
}
pub
fn
iso_2022_jp_ascii_valid_up_to
(
bytes
:
&
[
u8
]
)
-
>
usize
{
iso_2022_jp_ascii_valid_up_to
(
bytes
)
}
}
impl
PartialEq
for
Encoding
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Encoding
)
-
>
bool
{
(
self
as
*
const
Encoding
)
=
=
(
other
as
*
const
Encoding
)
}
}
impl
Eq
for
Encoding
{
}
impl
Hash
for
Encoding
{
#
[
inline
]
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
(
self
as
*
const
Encoding
)
.
hash
(
state
)
;
}
}
impl
std
:
:
fmt
:
:
Debug
for
Encoding
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Encoding
{
{
{
}
}
}
"
self
.
name
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
Serialize
for
Encoding
{
#
[
inline
]
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_str
(
self
.
name
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
struct
EncodingVisitor
;
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
Visitor
<
'
de
>
for
EncodingVisitor
{
type
Value
=
&
'
static
Encoding
;
fn
expecting
(
&
self
formatter
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
valid
encoding
label
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
&
'
static
Encoding
E
>
where
E
:
serde
:
:
de
:
:
Error
{
if
let
Some
(
enc
)
=
Encoding
:
:
for_label
(
value
.
as_bytes
(
)
)
{
Ok
(
enc
)
}
else
{
Err
(
E
:
:
custom
(
format
!
(
"
invalid
encoding
label
:
{
}
"
value
)
)
)
}
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
Deserialize
<
'
de
>
for
&
'
static
Encoding
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
&
'
static
Encoding
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_str
(
EncodingVisitor
)
}
}
#
[
derive
(
PartialEq
Debug
Copy
Clone
)
]
enum
DecoderLifeCycle
{
AtStart
AtUtf8Start
AtUtf16BeStart
AtUtf16LeStart
SeenUtf8First
SeenUtf8Second
SeenUtf16BeFirst
SeenUtf16LeFirst
ConvertingWithPendingBB
Converting
Finished
}
#
[
derive
(
Debug
Copy
Clone
)
]
enum
BomHandling
{
Off
Sniff
Remove
}
#
[
must_use
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
CoderResult
{
InputEmpty
OutputFull
}
#
[
must_use
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
DecoderResult
{
InputEmpty
OutputFull
Malformed
(
u8
u8
)
}
pub
struct
Decoder
{
encoding
:
&
'
static
Encoding
variant
:
VariantDecoder
life_cycle
:
DecoderLifeCycle
}
impl
Decoder
{
fn
new
(
enc
:
&
'
static
Encoding
decoder
:
VariantDecoder
sniffing
:
BomHandling
)
-
>
Decoder
{
Decoder
{
encoding
:
enc
variant
:
decoder
life_cycle
:
match
sniffing
{
BomHandling
:
:
Off
=
>
DecoderLifeCycle
:
:
Converting
BomHandling
:
:
Sniff
=
>
DecoderLifeCycle
:
:
AtStart
BomHandling
:
:
Remove
=
>
{
if
enc
=
=
UTF_8
{
DecoderLifeCycle
:
:
AtUtf8Start
}
else
if
enc
=
=
UTF_16BE
{
DecoderLifeCycle
:
:
AtUtf16BeStart
}
else
if
enc
=
=
UTF_16LE
{
DecoderLifeCycle
:
:
AtUtf16LeStart
}
else
{
DecoderLifeCycle
:
:
Converting
}
}
}
}
}
#
[
inline
]
pub
fn
encoding
(
&
self
)
-
>
&
'
static
Encoding
{
self
.
encoding
}
pub
fn
max_utf8_buffer_length
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
match
self
.
life_cycle
{
DecoderLifeCycle
:
:
Converting
|
DecoderLifeCycle
:
:
AtUtf8Start
|
DecoderLifeCycle
:
:
AtUtf16LeStart
|
DecoderLifeCycle
:
:
AtUtf16BeStart
=
>
{
return
self
.
variant
.
max_utf8_buffer_length
(
byte_length
)
;
}
DecoderLifeCycle
:
:
AtStart
=
>
{
if
let
Some
(
utf8_bom
)
=
checked_add
(
3
byte_length
.
checked_mul
(
3
)
)
{
if
let
Some
(
utf16_bom
)
=
checked_add
(
1
checked_mul
(
3
checked_div
(
byte_length
.
checked_add
(
1
)
2
)
)
)
{
let
utf_bom
=
std
:
:
cmp
:
:
max
(
utf8_bom
utf16_bom
)
;
let
encoding
=
self
.
encoding
(
)
;
if
encoding
=
=
UTF_8
|
|
encoding
=
=
UTF_16LE
|
|
encoding
=
=
UTF_16BE
{
return
Some
(
utf_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf8_buffer_length
(
byte_length
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
SeenUtf8First
|
DecoderLifeCycle
:
:
SeenUtf8Second
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
if
let
Some
(
utf8_bom
)
=
checked_add
(
3
sum
.
checked_mul
(
3
)
)
{
if
self
.
encoding
(
)
=
=
UTF_8
{
return
Some
(
utf8_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf8_buffer_length
(
sum
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf8_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
ConvertingWithPendingBB
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
return
self
.
variant
.
max_utf8_buffer_length
(
sum
)
;
}
}
DecoderLifeCycle
:
:
SeenUtf16LeFirst
|
DecoderLifeCycle
:
:
SeenUtf16BeFirst
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
if
let
Some
(
utf16_bom
)
=
checked_add
(
1
checked_mul
(
3
checked_div
(
sum
.
checked_add
(
1
)
2
)
)
)
{
let
encoding
=
self
.
encoding
(
)
;
if
encoding
=
=
UTF_16LE
|
|
encoding
=
=
UTF_16BE
{
return
Some
(
utf16_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf8_buffer_length
(
sum
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf16_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
Finished
=
>
panic
!
(
"
Must
not
use
a
decoder
that
has
finished
.
"
)
}
None
}
pub
fn
max_utf8_buffer_length_without_replacement
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
match
self
.
life_cycle
{
DecoderLifeCycle
:
:
Converting
|
DecoderLifeCycle
:
:
AtUtf8Start
|
DecoderLifeCycle
:
:
AtUtf16LeStart
|
DecoderLifeCycle
:
:
AtUtf16BeStart
=
>
{
return
self
.
variant
.
max_utf8_buffer_length_without_replacement
(
byte_length
)
;
}
DecoderLifeCycle
:
:
AtStart
=
>
{
if
let
Some
(
utf8_bom
)
=
byte_length
.
checked_add
(
3
)
{
if
let
Some
(
utf16_bom
)
=
checked_add
(
1
checked_mul
(
3
checked_div
(
byte_length
.
checked_add
(
1
)
2
)
)
)
{
let
utf_bom
=
std
:
:
cmp
:
:
max
(
utf8_bom
utf16_bom
)
;
let
encoding
=
self
.
encoding
(
)
;
if
encoding
=
=
UTF_8
|
|
encoding
=
=
UTF_16LE
|
|
encoding
=
=
UTF_16BE
{
return
Some
(
utf_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf8_buffer_length_without_replacement
(
byte_length
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
SeenUtf8First
|
DecoderLifeCycle
:
:
SeenUtf8Second
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
if
let
Some
(
utf8_bom
)
=
sum
.
checked_add
(
3
)
{
if
self
.
encoding
(
)
=
=
UTF_8
{
return
Some
(
utf8_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf8_buffer_length_without_replacement
(
sum
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf8_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
ConvertingWithPendingBB
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
return
self
.
variant
.
max_utf8_buffer_length_without_replacement
(
sum
)
;
}
}
DecoderLifeCycle
:
:
SeenUtf16LeFirst
|
DecoderLifeCycle
:
:
SeenUtf16BeFirst
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
if
let
Some
(
utf16_bom
)
=
checked_add
(
1
checked_mul
(
3
checked_div
(
sum
.
checked_add
(
1
)
2
)
)
)
{
let
encoding
=
self
.
encoding
(
)
;
if
encoding
=
=
UTF_16LE
|
|
encoding
=
=
UTF_16BE
{
return
Some
(
utf16_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf8_buffer_length_without_replacement
(
sum
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf16_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
Finished
=
>
panic
!
(
"
Must
not
use
a
decoder
that
has
finished
.
"
)
}
None
}
pub
fn
decode_to_utf8
(
&
mut
self
src
:
&
[
u8
]
dst
:
&
mut
[
u8
]
last
:
bool
)
-
>
(
CoderResult
usize
usize
bool
)
{
let
mut
had_errors
=
false
;
let
mut
total_read
=
0usize
;
let
mut
total_written
=
0usize
;
loop
{
let
(
result
read
written
)
=
self
.
decode_to_utf8_without_replacement
(
&
src
[
total_read
.
.
]
&
mut
dst
[
total_written
.
.
]
last
)
;
total_read
+
=
read
;
total_written
+
=
written
;
match
result
{
DecoderResult
:
:
InputEmpty
=
>
{
return
(
CoderResult
:
:
InputEmpty
total_read
total_written
had_errors
)
;
}
DecoderResult
:
:
OutputFull
=
>
{
return
(
CoderResult
:
:
OutputFull
total_read
total_written
had_errors
)
;
}
DecoderResult
:
:
Malformed
(
_
_
)
=
>
{
had_errors
=
true
;
dst
[
total_written
]
=
0xEFu8
;
total_written
+
=
1
;
dst
[
total_written
]
=
0xBFu8
;
total_written
+
=
1
;
dst
[
total_written
]
=
0xBDu8
;
total_written
+
=
1
;
}
}
}
}
pub
fn
decode_to_str
(
&
mut
self
src
:
&
[
u8
]
dst
:
&
mut
str
last
:
bool
)
-
>
(
CoderResult
usize
usize
bool
)
{
let
bytes
:
&
mut
[
u8
]
=
unsafe
{
dst
.
as_bytes_mut
(
)
}
;
let
(
result
read
written
replaced
)
=
self
.
decode_to_utf8
(
src
bytes
last
)
;
let
len
=
bytes
.
len
(
)
;
let
mut
trail
=
written
;
if
self
.
encoding
!
=
UTF_8
{
let
max
=
std
:
:
cmp
:
:
min
(
len
trail
+
ascii
:
:
MAX_STRIDE_SIZE
)
;
while
trail
<
max
{
bytes
[
trail
]
=
0
;
trail
+
=
1
;
}
}
while
trail
<
len
&
&
(
(
bytes
[
trail
]
&
0xC0
)
=
=
0x80
)
{
bytes
[
trail
]
=
0
;
trail
+
=
1
;
}
(
result
read
written
replaced
)
}
pub
fn
decode_to_string
(
&
mut
self
src
:
&
[
u8
]
dst
:
&
mut
String
last
:
bool
)
-
>
(
CoderResult
usize
bool
)
{
unsafe
{
let
vec
=
dst
.
as_mut_vec
(
)
;
let
old_len
=
vec
.
len
(
)
;
let
capacity
=
vec
.
capacity
(
)
;
vec
.
set_len
(
capacity
)
;
let
(
result
read
written
replaced
)
=
self
.
decode_to_utf8
(
src
&
mut
vec
[
old_len
.
.
]
last
)
;
vec
.
set_len
(
old_len
+
written
)
;
(
result
read
replaced
)
}
}
public_decode_function
!
(
/
/
/
Incrementally
decode
a
byte
stream
into
UTF
-
8
/
/
/
_without
replacement_
.
/
/
/
/
/
/
See
the
documentation
of
the
struct
for
/
/
/
documentation
for
decode_
*
methods
/
/
/
collectively
.
/
/
/
/
/
/
Available
via
the
C
wrapper
.
decode_to_utf8_without_replacement
decode_to_utf8_raw
decode_to_utf8_checking_end
decode_to_utf8_after_one_potential_bom_byte
decode_to_utf8_after_two_potential_bom_bytes
decode_to_utf8_checking_end_with_offset
u8
)
;
pub
fn
decode_to_str_without_replacement
(
&
mut
self
src
:
&
[
u8
]
dst
:
&
mut
str
last
:
bool
)
-
>
(
DecoderResult
usize
usize
)
{
let
bytes
:
&
mut
[
u8
]
=
unsafe
{
dst
.
as_bytes_mut
(
)
}
;
let
(
result
read
written
)
=
self
.
decode_to_utf8_without_replacement
(
src
bytes
last
)
;
let
len
=
bytes
.
len
(
)
;
let
mut
trail
=
written
;
if
self
.
encoding
!
=
UTF_8
{
let
max
=
std
:
:
cmp
:
:
min
(
len
trail
+
ascii
:
:
MAX_STRIDE_SIZE
)
;
while
trail
<
max
{
bytes
[
trail
]
=
0
;
trail
+
=
1
;
}
}
while
trail
<
len
&
&
(
(
bytes
[
trail
]
&
0xC0
)
=
=
0x80
)
{
bytes
[
trail
]
=
0
;
trail
+
=
1
;
}
(
result
read
written
)
}
pub
fn
decode_to_string_without_replacement
(
&
mut
self
src
:
&
[
u8
]
dst
:
&
mut
String
last
:
bool
)
-
>
(
DecoderResult
usize
)
{
unsafe
{
let
vec
=
dst
.
as_mut_vec
(
)
;
let
old_len
=
vec
.
len
(
)
;
let
capacity
=
vec
.
capacity
(
)
;
vec
.
set_len
(
capacity
)
;
let
(
result
read
written
)
=
self
.
decode_to_utf8_without_replacement
(
src
&
mut
vec
[
old_len
.
.
]
last
)
;
vec
.
set_len
(
old_len
+
written
)
;
(
result
read
)
}
}
pub
fn
max_utf16_buffer_length
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
match
self
.
life_cycle
{
DecoderLifeCycle
:
:
Converting
|
DecoderLifeCycle
:
:
AtUtf8Start
|
DecoderLifeCycle
:
:
AtUtf16LeStart
|
DecoderLifeCycle
:
:
AtUtf16BeStart
=
>
{
return
self
.
variant
.
max_utf16_buffer_length
(
byte_length
)
;
}
DecoderLifeCycle
:
:
AtStart
=
>
{
if
let
Some
(
utf8_bom
)
=
byte_length
.
checked_add
(
1
)
{
if
let
Some
(
utf16_bom
)
=
checked_add
(
1
checked_div
(
byte_length
.
checked_add
(
1
)
2
)
)
{
let
utf_bom
=
std
:
:
cmp
:
:
max
(
utf8_bom
utf16_bom
)
;
let
encoding
=
self
.
encoding
(
)
;
if
encoding
=
=
UTF_8
|
|
encoding
=
=
UTF_16LE
|
|
encoding
=
=
UTF_16BE
{
return
Some
(
utf_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf16_buffer_length
(
byte_length
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
SeenUtf8First
|
DecoderLifeCycle
:
:
SeenUtf8Second
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
if
let
Some
(
utf8_bom
)
=
sum
.
checked_add
(
1
)
{
if
self
.
encoding
(
)
=
=
UTF_8
{
return
Some
(
utf8_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf16_buffer_length
(
sum
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf8_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
ConvertingWithPendingBB
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
return
self
.
variant
.
max_utf16_buffer_length
(
sum
)
;
}
}
DecoderLifeCycle
:
:
SeenUtf16LeFirst
|
DecoderLifeCycle
:
:
SeenUtf16BeFirst
=
>
{
if
let
Some
(
sum
)
=
byte_length
.
checked_add
(
2
)
{
if
let
Some
(
utf16_bom
)
=
checked_add
(
1
checked_div
(
sum
.
checked_add
(
1
)
2
)
)
{
let
encoding
=
self
.
encoding
(
)
;
if
encoding
=
=
UTF_16LE
|
|
encoding
=
=
UTF_16BE
{
return
Some
(
utf16_bom
)
;
}
else
if
let
Some
(
non_bom
)
=
self
.
variant
.
max_utf16_buffer_length
(
sum
)
{
return
Some
(
std
:
:
cmp
:
:
max
(
utf16_bom
non_bom
)
)
;
}
}
}
}
DecoderLifeCycle
:
:
Finished
=
>
panic
!
(
"
Must
not
use
a
decoder
that
has
finished
.
"
)
}
None
}
pub
fn
decode_to_utf16
(
&
mut
self
src
:
&
[
u8
]
dst
:
&
mut
[
u16
]
last
:
bool
)
-
>
(
CoderResult
usize
usize
bool
)
{
let
mut
had_errors
=
false
;
let
mut
total_read
=
0usize
;
let
mut
total_written
=
0usize
;
loop
{
let
(
result
read
written
)
=
self
.
decode_to_utf16_without_replacement
(
&
src
[
total_read
.
.
]
&
mut
dst
[
total_written
.
.
]
last
)
;
total_read
+
=
read
;
total_written
+
=
written
;
match
result
{
DecoderResult
:
:
InputEmpty
=
>
{
return
(
CoderResult
:
:
InputEmpty
total_read
total_written
had_errors
)
;
}
DecoderResult
:
:
OutputFull
=
>
{
return
(
CoderResult
:
:
OutputFull
total_read
total_written
had_errors
)
;
}
DecoderResult
:
:
Malformed
(
_
_
)
=
>
{
had_errors
=
true
;
dst
[
total_written
]
=
0xFFFD
;
total_written
+
=
1
;
}
}
}
}
public_decode_function
!
(
/
/
/
Incrementally
decode
a
byte
stream
into
UTF
-
16
/
/
/
_without
replacement_
.
/
/
/
/
/
/
See
the
documentation
of
the
struct
for
/
/
/
documentation
for
decode_
*
methods
/
/
/
collectively
.
/
/
/
/
/
/
Available
via
the
C
wrapper
.
decode_to_utf16_without_replacement
decode_to_utf16_raw
decode_to_utf16_checking_end
decode_to_utf16_after_one_potential_bom_byte
decode_to_utf16_after_two_potential_bom_bytes
decode_to_utf16_checking_end_with_offset
u16
)
;
}
#
[
must_use
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
EncoderResult
{
InputEmpty
OutputFull
Unmappable
(
char
)
}
impl
EncoderResult
{
fn
unmappable_from_bmp
(
bmp
:
u16
)
-
>
EncoderResult
{
EncoderResult
:
:
Unmappable
(
:
:
std
:
:
char
:
:
from_u32
(
u32
:
:
from
(
bmp
)
)
.
unwrap
(
)
)
}
}
pub
struct
Encoder
{
encoding
:
&
'
static
Encoding
variant
:
VariantEncoder
}
impl
Encoder
{
fn
new
(
enc
:
&
'
static
Encoding
encoder
:
VariantEncoder
)
-
>
Encoder
{
Encoder
{
encoding
:
enc
variant
:
encoder
}
}
#
[
inline
]
pub
fn
encoding
(
&
self
)
-
>
&
'
static
Encoding
{
self
.
encoding
}
#
[
inline
]
pub
fn
has_pending_state
(
&
self
)
-
>
bool
{
self
.
variant
.
has_pending_state
(
)
}
pub
fn
max_buffer_length_from_utf8_if_no_unmappables
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
checked_add
(
if
self
.
encoding
(
)
.
can_encode_everything
(
)
{
0
}
else
{
NCR_EXTRA
}
self
.
max_buffer_length_from_utf8_without_replacement
(
byte_length
)
)
}
pub
fn
max_buffer_length_from_utf8_without_replacement
(
&
self
byte_length
:
usize
)
-
>
Option
<
usize
>
{
self
.
variant
.
max_buffer_length_from_utf8_without_replacement
(
byte_length
)
}
pub
fn
encode_from_utf8
(
&
mut
self
src
:
&
str
dst
:
&
mut
[
u8
]
last
:
bool
)
-
>
(
CoderResult
usize
usize
bool
)
{
let
dst_len
=
dst
.
len
(
)
;
let
effective_dst_len
=
if
self
.
encoding
(
)
.
can_encode_everything
(
)
{
dst_len
}
else
{
if
dst_len
<
NCR_EXTRA
{
if
src
.
is_empty
(
)
&
&
!
(
last
&
&
self
.
has_pending_state
(
)
)
{
return
(
CoderResult
:
:
InputEmpty
0
0
false
)
;
}
return
(
CoderResult
:
:
OutputFull
0
0
false
)
;
}
dst_len
-
NCR_EXTRA
}
;
let
mut
had_unmappables
=
false
;
let
mut
total_read
=
0usize
;
let
mut
total_written
=
0usize
;
loop
{
let
(
result
read
written
)
=
self
.
encode_from_utf8_without_replacement
(
&
src
[
total_read
.
.
]
&
mut
dst
[
total_written
.
.
effective_dst_len
]
last
)
;
total_read
+
=
read
;
total_written
+
=
written
;
match
result
{
EncoderResult
:
:
InputEmpty
=
>
{
return
(
CoderResult
:
:
InputEmpty
total_read
total_written
had_unmappables
)
;
}
EncoderResult
:
:
OutputFull
=
>
{
return
(
CoderResult
:
:
OutputFull
total_read
total_written
had_unmappables
)
;
}
EncoderResult
:
:
Unmappable
(
unmappable
)
=
>
{
had_unmappables
=
true
;
debug_assert
!
(
dst
.
len
(
)
-
total_written
>
=
NCR_EXTRA
)
;
debug_assert_ne
!
(
self
.
encoding
(
)
UTF_16BE
)
;
debug_assert_ne
!
(
self
.
encoding
(
)
UTF_16LE
)
;
total_written
+
=
write_ncr
(
unmappable
&
mut
dst
[
total_written
.
.
]
)
;
if
total_written
>
=
effective_dst_len
{
if
total_read
=
=
src
.
len
(
)
&
&
!
(
last
&
&
self
.
has_pending_state
(
)
)
{
return
(
CoderResult
:
:
InputEmpty
total_read
total_written
had_unmappables
)
;
}
return
(
CoderResult
:
:
OutputFull
total_read
total_written
had_unmappables
)
;
}
}
}
}
}
pub
fn
encode_from_utf8_to_vec
(
&
mut
self
src
:
&
str
dst
:
&
mut
Vec
<
u8
>
last
:
bool
)
-
>
(
CoderResult
usize
bool
)
{
unsafe
{
let
old_len
=
dst
.
len
(
)
;
let
capacity
=
dst
.
capacity
(
)
;
dst
.
set_len
(
capacity
)
;
let
(
result
read
written
replaced
)
=
self
.
encode_from_utf8
(
src
&
mut
dst
[
old_len
.
.
]
last
)
;
dst
.
set_len
(
old_len
+
written
)
;
(
result
read
replaced
)
}
}
pub
fn
encode_from_utf8_without_replacement
(
&
mut
self
src
:
&
str
dst
:
&
mut
[
u8
]
last
:
bool
)
-
>
(
EncoderResult
usize
usize
)
{
self
.
variant
.
encode_from_utf8_raw
(
src
dst
last
)
}
pub
fn
encode_from_utf8_to_vec_without_replacement
(
&
mut
self
src
:
&
str
dst
:
&
mut
Vec
<
u8
>
last
:
bool
)
-
>
(
EncoderResult
usize
)
{
unsafe
{
let
old_len
=
dst
.
len
(
)
;
let
capacity
=
dst
.
capacity
(
)
;
dst
.
set_len
(
capacity
)
;
let
(
result
read
written
)
=
self
.
encode_from_utf8_without_replacement
(
src
&
mut
dst
[
old_len
.
.
]
last
)
;
dst
.
set_len
(
old_len
+
written
)
;
(
result
read
)
}
}
pub
fn
max_buffer_length_from_utf16_if_no_unmappables
(
&
self
u16_length
:
usize
)
-
>
Option
<
usize
>
{
checked_add
(
if
self
.
encoding
(
)
.
can_encode_everything
(
)
{
0
}
else
{
NCR_EXTRA
}
self
.
max_buffer_length_from_utf16_without_replacement
(
u16_length
)
)
}
pub
fn
max_buffer_length_from_utf16_without_replacement
(
&
self
u16_length
:
usize
)
-
>
Option
<
usize
>
{
self
.
variant
.
max_buffer_length_from_utf16_without_replacement
(
u16_length
)
}
pub
fn
encode_from_utf16
(
&
mut
self
src
:
&
[
u16
]
dst
:
&
mut
[
u8
]
last
:
bool
)
-
>
(
CoderResult
usize
usize
bool
)
{
let
dst_len
=
dst
.
len
(
)
;
let
effective_dst_len
=
if
self
.
encoding
(
)
.
can_encode_everything
(
)
{
dst_len
}
else
{
if
dst_len
<
NCR_EXTRA
{
if
src
.
is_empty
(
)
&
&
!
(
last
&
&
self
.
has_pending_state
(
)
)
{
return
(
CoderResult
:
:
InputEmpty
0
0
false
)
;
}
return
(
CoderResult
:
:
OutputFull
0
0
false
)
;
}
dst_len
-
NCR_EXTRA
}
;
let
mut
had_unmappables
=
false
;
let
mut
total_read
=
0usize
;
let
mut
total_written
=
0usize
;
loop
{
let
(
result
read
written
)
=
self
.
encode_from_utf16_without_replacement
(
&
src
[
total_read
.
.
]
&
mut
dst
[
total_written
.
.
effective_dst_len
]
last
)
;
total_read
+
=
read
;
total_written
+
=
written
;
match
result
{
EncoderResult
:
:
InputEmpty
=
>
{
return
(
CoderResult
:
:
InputEmpty
total_read
total_written
had_unmappables
)
;
}
EncoderResult
:
:
OutputFull
=
>
{
return
(
CoderResult
:
:
OutputFull
total_read
total_written
had_unmappables
)
;
}
EncoderResult
:
:
Unmappable
(
unmappable
)
=
>
{
had_unmappables
=
true
;
debug_assert
!
(
dst
.
len
(
)
-
total_written
>
=
NCR_EXTRA
)
;
debug_assert_ne
!
(
self
.
encoding
(
)
UTF_16BE
)
;
debug_assert_ne
!
(
self
.
encoding
(
)
UTF_16LE
)
;
total_written
+
=
write_ncr
(
unmappable
&
mut
dst
[
total_written
.
.
]
)
;
if
total_written
>
=
effective_dst_len
{
if
total_read
=
=
src
.
len
(
)
&
&
!
(
last
&
&
self
.
has_pending_state
(
)
)
{
return
(
CoderResult
:
:
InputEmpty
total_read
total_written
had_unmappables
)
;
}
return
(
CoderResult
:
:
OutputFull
total_read
total_written
had_unmappables
)
;
}
}
}
}
}
pub
fn
encode_from_utf16_without_replacement
(
&
mut
self
src
:
&
[
u16
]
dst
:
&
mut
[
u8
]
last
:
bool
)
-
>
(
EncoderResult
usize
usize
)
{
self
.
variant
.
encode_from_utf16_raw
(
src
dst
last
)
}
}
fn
write_ncr
(
unmappable
:
char
dst
:
&
mut
[
u8
]
)
-
>
usize
{
let
mut
number
=
unmappable
as
u32
;
let
len
=
if
number
>
=
1_000_000u32
{
10usize
}
else
if
number
>
=
100_000u32
{
9usize
}
else
if
number
>
=
10_000u32
{
8usize
}
else
if
number
>
=
1_000u32
{
7usize
}
else
if
number
>
=
100u32
{
6usize
}
else
{
5usize
}
;
debug_assert
!
(
number
>
=
10u32
)
;
debug_assert
!
(
len
<
=
dst
.
len
(
)
)
;
let
mut
pos
=
len
-
1
;
dst
[
pos
]
=
b
'
;
'
;
pos
-
=
1
;
loop
{
let
rightmost
=
number
%
10
;
dst
[
pos
]
=
rightmost
as
u8
+
b
'
0
'
;
pos
-
=
1
;
if
number
<
10
{
break
;
}
number
/
=
10
;
}
dst
[
1
]
=
b
'
#
'
;
dst
[
0
]
=
b
'
&
'
;
len
}
#
[
inline
(
always
)
]
fn
in_range16
(
i
:
u16
start
:
u16
end
:
u16
)
-
>
bool
{
i
.
wrapping_sub
(
start
)
<
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
in_range32
(
i
:
u32
start
:
u32
end
:
u32
)
-
>
bool
{
i
.
wrapping_sub
(
start
)
<
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
in_inclusive_range8
(
i
:
u8
start
:
u8
end
:
u8
)
-
>
bool
{
i
.
wrapping_sub
(
start
)
<
=
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
in_inclusive_range16
(
i
:
u16
start
:
u16
end
:
u16
)
-
>
bool
{
i
.
wrapping_sub
(
start
)
<
=
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
in_inclusive_range32
(
i
:
u32
start
:
u32
end
:
u32
)
-
>
bool
{
i
.
wrapping_sub
(
start
)
<
=
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
in_inclusive_range
(
i
:
usize
start
:
usize
end
:
usize
)
-
>
bool
{
i
.
wrapping_sub
(
start
)
<
=
(
end
-
start
)
}
#
[
inline
(
always
)
]
fn
checked_add
(
num
:
usize
opt
:
Option
<
usize
>
)
-
>
Option
<
usize
>
{
if
let
Some
(
n
)
=
opt
{
n
.
checked_add
(
num
)
}
else
{
None
}
}
#
[
inline
(
always
)
]
fn
checked_add_opt
(
one
:
Option
<
usize
>
other
:
Option
<
usize
>
)
-
>
Option
<
usize
>
{
if
let
Some
(
n
)
=
one
{
checked_add
(
n
other
)
}
else
{
None
}
}
#
[
inline
(
always
)
]
fn
checked_mul
(
num
:
usize
opt
:
Option
<
usize
>
)
-
>
Option
<
usize
>
{
if
let
Some
(
n
)
=
opt
{
n
.
checked_mul
(
num
)
}
else
{
None
}
}
#
[
inline
(
always
)
]
fn
checked_div
(
opt
:
Option
<
usize
>
num
:
usize
)
-
>
Option
<
usize
>
{
if
let
Some
(
n
)
=
opt
{
n
.
checked_div
(
num
)
}
else
{
None
}
}
#
[
inline
(
always
)
]
fn
checked_next_power_of_two
(
opt
:
Option
<
usize
>
)
-
>
Option
<
usize
>
{
opt
.
map
(
|
n
|
n
.
next_power_of_two
(
)
)
}
#
[
inline
(
always
)
]
fn
checked_min
(
one
:
Option
<
usize
>
other
:
Option
<
usize
>
)
-
>
Option
<
usize
>
{
if
let
Some
(
a
)
=
one
{
if
let
Some
(
b
)
=
other
{
Some
(
:
:
std
:
:
cmp
:
:
min
(
a
b
)
)
}
else
{
Some
(
a
)
}
}
else
{
other
}
}
#
[
cfg
(
all
(
test
feature
=
"
serde
"
)
)
]
#
[
derive
(
Serialize
Deserialize
Debug
PartialEq
)
]
struct
Demo
{
num
:
u32
name
:
String
enc
:
&
'
static
Encoding
}
#
[
cfg
(
test
)
]
mod
test_labels_names
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
std
:
:
borrow
:
:
Cow
;
fn
sniff_to_utf16
(
initial_encoding
:
&
'
static
Encoding
expected_encoding
:
&
'
static
Encoding
bytes
:
&
[
u8
]
expect
:
&
[
u16
]
breaks
:
&
[
usize
]
)
{
let
mut
decoder
=
initial_encoding
.
new_decoder
(
)
;
let
mut
dest
:
Vec
<
u16
>
=
Vec
:
:
with_capacity
(
decoder
.
max_utf16_buffer_length
(
bytes
.
len
(
)
)
.
unwrap
(
)
)
;
let
capacity
=
dest
.
capacity
(
)
;
dest
.
resize
(
capacity
0u16
)
;
let
mut
total_written
=
0usize
;
let
mut
start
=
0usize
;
for
br
in
breaks
{
let
(
result
read
written
_
)
=
decoder
.
decode_to_utf16
(
&
bytes
[
start
.
.
*
br
]
&
mut
dest
[
total_written
.
.
]
false
)
;
total_written
+
=
written
;
assert_eq
!
(
read
*
br
-
start
)
;
match
result
{
CoderResult
:
:
InputEmpty
=
>
{
}
CoderResult
:
:
OutputFull
=
>
{
unreachable
!
(
)
;
}
}
start
=
*
br
;
}
let
(
result
read
written
_
)
=
decoder
.
decode_to_utf16
(
&
bytes
[
start
.
.
]
&
mut
dest
[
total_written
.
.
]
true
)
;
total_written
+
=
written
;
match
result
{
CoderResult
:
:
InputEmpty
=
>
{
}
CoderResult
:
:
OutputFull
=
>
{
unreachable
!
(
)
;
}
}
assert_eq
!
(
read
bytes
.
len
(
)
-
start
)
;
assert_eq
!
(
total_written
expect
.
len
(
)
)
;
assert_eq
!
(
&
dest
[
.
.
total_written
]
expect
)
;
assert_eq
!
(
decoder
.
encoding
(
)
expected_encoding
)
;
}
#
[
test
]
fn
test_bom_sniffing
(
)
{
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
2
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
3
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
4
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
2
3
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
1
2
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
1
3
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
\
x61
\
x62
"
&
[
0x0061u16
0x0062u16
]
&
[
1
2
3
4
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_8
b
"
\
xEF
\
xBB
\
xBF
"
&
[
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
\
xBB
\
x61
\
x62
"
&
[
0x00EFu16
0x00BBu16
0x0061u16
0x0062u16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
\
xBB
\
x61
\
x62
"
&
[
0x00EFu16
0x00BBu16
0x0061u16
0x0062u16
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
\
x61
\
x62
"
&
[
0x00EFu16
0x0061u16
0x0062u16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
\
x61
\
x62
"
&
[
0x00EFu16
0x0061u16
0x0062u16
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
\
xBB
"
&
[
0x00EFu16
0x00BBu16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
\
xBB
"
&
[
0x00EFu16
0x00BBu16
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xEF
"
&
[
0x00EFu16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xFE
\
x61
\
x62
"
&
[
0x00FEu16
0x0061u16
0x0062u16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xFE
\
x61
\
x62
"
&
[
0x00FEu16
0x0061u16
0x0062u16
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xFE
"
&
[
0x00FEu16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xFF
\
x61
\
x62
"
&
[
0x00FFu16
0x0061u16
0x0062u16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xFF
\
x61
\
x62
"
&
[
0x00FFu16
0x0061u16
0x0062u16
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
WINDOWS_1252
b
"
\
xFF
"
&
[
0x00FFu16
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_16BE
b
"
\
xFE
\
xFF
"
&
[
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_16BE
b
"
\
xFE
\
xFF
"
&
[
]
&
[
1
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_16LE
b
"
\
xFF
\
xFE
"
&
[
]
&
[
]
)
;
sniff_to_utf16
(
WINDOWS_1252
UTF_16LE
b
"
\
xFF
\
xFE
"
&
[
]
&
[
1
]
)
;
}
#
[
test
]
fn
test_output_encoding
(
)
{
assert_eq
!
(
REPLACEMENT
.
output_encoding
(
)
UTF_8
)
;
assert_eq
!
(
UTF_16BE
.
output_encoding
(
)
UTF_8
)
;
assert_eq
!
(
UTF_16LE
.
output_encoding
(
)
UTF_8
)
;
assert_eq
!
(
UTF_8
.
output_encoding
(
)
UTF_8
)
;
assert_eq
!
(
WINDOWS_1252
.
output_encoding
(
)
WINDOWS_1252
)
;
assert_eq
!
(
REPLACEMENT
.
new_encoder
(
)
.
encoding
(
)
UTF_8
)
;
assert_eq
!
(
UTF_16BE
.
new_encoder
(
)
.
encoding
(
)
UTF_8
)
;
assert_eq
!
(
UTF_16LE
.
new_encoder
(
)
.
encoding
(
)
UTF_8
)
;
assert_eq
!
(
UTF_8
.
new_encoder
(
)
.
encoding
(
)
UTF_8
)
;
assert_eq
!
(
WINDOWS_1252
.
new_encoder
(
)
.
encoding
(
)
WINDOWS_1252
)
;
}
#
[
test
]
fn
test_label_resolution
(
)
{
assert_eq
!
(
Encoding
:
:
for_label
(
b
"
utf
-
8
"
)
Some
(
UTF_8
)
)
;
assert_eq
!
(
Encoding
:
:
for_label
(
b
"
UTF
-
8
"
)
Some
(
UTF_8
)
)
;
assert_eq
!
(
Encoding
:
:
for_label
(
b
"
\
t
\
n
\
x0C
\
n
utf
-
8
\
r
\
n
\
t
\
x0C
"
)
Some
(
UTF_8
)
)
;
assert_eq
!
(
Encoding
:
:
for_label
(
b
"
utf
-
8
_
"
)
None
)
;
assert_eq
!
(
Encoding
:
:
for_label
(
b
"
bogus
"
)
None
)
;
assert_eq
!
(
Encoding
:
:
for_label
(
b
"
bogusbogusbogusbogus
"
)
None
)
;
}
#
[
test
]
fn
test_decode_valid_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
decode
(
b
"
abc
\
x80
\
xE4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
}
assert_eq
!
(
encoding
WINDOWS_1257
)
;
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_invalid_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
decode
(
b
"
abc
\
x80
\
xA1
\
xE4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
FFFD
}
\
u
{
00E4
}
"
)
;
}
}
assert_eq
!
(
encoding
WINDOWS_1257
)
;
assert
!
(
had_errors
)
;
}
#
[
test
]
fn
test_decode_ascii_only_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
decode
(
b
"
abc
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert_eq
!
(
encoding
WINDOWS_1257
)
;
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_valid_utf8_as_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
decode
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert_eq
!
(
encoding
UTF_8
)
;
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_invalid_utf8_as_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
decode
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
x80
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
20AC
}
\
u
{
FFFD
}
\
u
{
00E4
}
"
)
;
}
}
assert_eq
!
(
encoding
UTF_8
)
;
assert
!
(
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_valid_utf8_as_utf_8_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
UTF_8
.
decode
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert_eq
!
(
encoding
UTF_8
)
;
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_invalid_utf8_as_utf_8_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
UTF_8
.
decode
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
x80
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
20AC
}
\
u
{
FFFD
}
\
u
{
00E4
}
"
)
;
}
}
assert_eq
!
(
encoding
UTF_8
)
;
assert
!
(
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_valid_utf8_as_utf_8_to_cow_with_bom_removal
(
)
{
let
(
cow
had_errors
)
=
UTF_8
.
decode_with_bom_removal
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_valid_utf8_as_windows_1257_to_cow_with_bom_removal
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_with_bom_removal
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
013C
}
\
u
{
00BB
}
\
u
{
00E6
}
\
u
{
0101
}
\
u
{
201A
}
\
u
{
00AC
}
\
u
{
0106
}
\
u
{
00A4
}
"
)
;
}
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_valid_windows_1257_to_cow_with_bom_removal
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_with_bom_removal
(
b
"
abc
\
x80
\
xE4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_invalid_windows_1257_to_cow_with_bom_removal
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_with_bom_removal
(
b
"
abc
\
x80
\
xA1
\
xE4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
FFFD
}
\
u
{
00E4
}
"
)
;
}
}
assert
!
(
had_errors
)
;
}
#
[
test
]
fn
test_decode_ascii_only_windows_1257_to_cow_with_bom_removal
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_with_bom_removal
(
b
"
abc
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_valid_utf8_to_cow_without_bom_handling
(
)
{
let
(
cow
had_errors
)
=
UTF_8
.
decode_without_bom_handling
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
FEFF
}
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_invalid_utf8_to_cow_without_bom_handling
(
)
{
let
(
cow
had_errors
)
=
UTF_8
.
decode_without_bom_handling
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
x80
\
xC3
\
xA4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
FEFF
}
\
u
{
20AC
}
\
u
{
FFFD
}
\
u
{
00E4
}
"
)
;
}
}
assert
!
(
had_errors
)
;
}
#
[
test
]
fn
test_decode_valid_windows_1257_to_cow_without_bom_handling
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_without_bom_handling
(
b
"
abc
\
x80
\
xE4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_invalid_windows_1257_to_cow_without_bom_handling
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_without_bom_handling
(
b
"
abc
\
x80
\
xA1
\
xE4
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
FFFD
}
\
u
{
00E4
}
"
)
;
}
}
assert
!
(
had_errors
)
;
}
#
[
test
]
fn
test_decode_ascii_only_windows_1257_to_cow_without_bom_handling
(
)
{
let
(
cow
had_errors
)
=
WINDOWS_1257
.
decode_without_bom_handling
(
b
"
abc
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_decode_bomful_valid_utf8_to_cow_without_bom_handling_and_without_replacement
(
)
{
match
UTF_8
.
decode_without_bom_handling_and_without_replacement
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
xC3
\
xA4
"
)
{
Some
(
cow
)
=
>
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
\
u
{
FEFF
}
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
None
=
>
unreachable
!
(
)
}
}
#
[
test
]
fn
test_decode_bomful_invalid_utf8_to_cow_without_bom_handling_and_without_replacement
(
)
{
assert
!
(
UTF_8
.
decode_without_bom_handling_and_without_replacement
(
b
"
\
xEF
\
xBB
\
xBF
\
xE2
\
x82
\
xAC
\
x80
\
xC3
\
xA4
"
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_decode_valid_windows_1257_to_cow_without_bom_handling_and_without_replacement
(
)
{
match
WINDOWS_1257
.
decode_without_bom_handling_and_without_replacement
(
b
"
abc
\
x80
\
xE4
"
)
{
Some
(
cow
)
=
>
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
}
}
None
=
>
unreachable
!
(
)
}
}
#
[
test
]
fn
test_decode_invalid_windows_1257_to_cow_without_bom_handling_and_without_replacement
(
)
{
assert
!
(
WINDOWS_1257
.
decode_without_bom_handling_and_without_replacement
(
b
"
abc
\
x80
\
xA1
\
xE4
"
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_decode_ascii_only_windows_1257_to_cow_without_bom_handling_and_without_replacement
(
)
{
match
WINDOWS_1257
.
decode_without_bom_handling_and_without_replacement
(
b
"
abc
"
)
{
Some
(
cow
)
=
>
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
"
abc
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
None
=
>
unreachable
!
(
)
}
}
#
[
test
]
fn
test_encode_ascii_only_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
encode
(
"
abc
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
{
assert_eq
!
(
s
b
"
abc
"
)
;
}
Cow
:
:
Owned
(
_
)
=
>
unreachable
!
(
)
}
assert_eq
!
(
encoding
WINDOWS_1257
)
;
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_encode_valid_windows_1257_to_cow
(
)
{
let
(
cow
encoding
had_errors
)
=
WINDOWS_1257
.
encode
(
"
abc
\
u
{
20AC
}
\
u
{
00E4
}
"
)
;
match
cow
{
Cow
:
:
Borrowed
(
_
)
=
>
unreachable
!
(
)
Cow
:
:
Owned
(
s
)
=
>
{
assert_eq
!
(
s
b
"
abc
\
x80
\
xE4
"
)
;
}
}
assert_eq
!
(
encoding
WINDOWS_1257
)
;
assert
!
(
!
had_errors
)
;
}
#
[
test
]
fn
test_utf16_space_with_one_bom_byte
(
)
{
let
mut
decoder
=
UTF_16LE
.
new_decoder
(
)
;
let
mut
dst
=
[
0u16
;
12
]
;
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
"
&
mut
dst
[
.
.
needed
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
"
&
mut
dst
[
.
.
needed
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_utf8_space_with_one_bom_byte
(
)
{
let
mut
decoder
=
UTF_8
.
new_decoder
(
)
;
let
mut
dst
=
[
0u16
;
12
]
;
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
"
&
mut
dst
[
.
.
needed
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
"
&
mut
dst
[
.
.
needed
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_utf16_space_with_two_bom_bytes
(
)
{
let
mut
decoder
=
UTF_16LE
.
new_decoder
(
)
;
let
mut
dst
=
[
0u16
;
12
]
;
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xEF
"
&
mut
dst
[
.
.
needed
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xBB
"
&
mut
dst
[
.
.
needed
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
"
&
mut
dst
[
.
.
needed
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_utf8_space_with_two_bom_bytes
(
)
{
let
mut
decoder
=
UTF_8
.
new_decoder
(
)
;
let
mut
dst
=
[
0u16
;
12
]
;
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xEF
"
&
mut
dst
[
.
.
needed
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xBB
"
&
mut
dst
[
.
.
needed
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
1
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
"
&
mut
dst
[
.
.
needed
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_utf16_space_with_one_bom_byte_and_a_second_byte_in_same_call
(
)
{
let
mut
decoder
=
UTF_16LE
.
new_decoder
(
)
;
let
mut
dst
=
[
0u16
;
12
]
;
{
let
needed
=
decoder
.
max_utf16_buffer_length
(
2
)
.
unwrap
(
)
;
let
(
result
_
_
_
)
=
decoder
.
decode_to_utf16
(
b
"
\
xFF
\
xFF
"
&
mut
dst
[
.
.
needed
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_too_short_buffer_with_iso_2022_jp_ascii_from_utf8
(
)
{
let
mut
dst
=
[
0u8
;
8
]
;
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
"
&
mut
dst
[
.
.
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
"
&
mut
dst
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_too_short_buffer_with_iso_2022_jp_roman_from_utf8
(
)
{
let
mut
dst
=
[
0u8
;
16
]
;
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
\
u
{
A5
}
"
&
mut
dst
[
.
.
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
"
&
mut
dst
[
.
.
8
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
"
&
mut
dst
[
.
.
8
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
OutputFull
)
;
}
}
#
[
test
]
fn
test_buffer_end_iso_2022_jp_from_utf8
(
)
{
let
mut
dst
=
[
0u8
;
18
]
;
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
\
u
{
A5
}
\
u
{
1F4A9
}
"
&
mut
dst
[
.
.
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
\
u
{
A5
}
\
u
{
1F4A9
}
"
&
mut
dst
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
OutputFull
)
;
}
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
\
u
{
1F4A9
}
"
&
mut
dst
[
.
.
13
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
\
u
{
1F4A9
}
"
&
mut
dst
[
.
.
13
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_too_short_buffer_with_iso_2022_jp_ascii_from_utf16
(
)
{
let
mut
dst
=
[
0u8
;
8
]
;
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0u16
;
0
]
&
mut
dst
[
.
.
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0u16
;
0
]
&
mut
dst
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_too_short_buffer_with_iso_2022_jp_roman_from_utf16
(
)
{
let
mut
dst
=
[
0u8
;
16
]
;
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0xA5u16
]
&
mut
dst
[
.
.
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0u16
;
0
]
&
mut
dst
[
.
.
8
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0u16
;
0
]
&
mut
dst
[
.
.
8
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
OutputFull
)
;
}
}
#
[
test
]
fn
test_buffer_end_iso_2022_jp_from_utf16
(
)
{
let
mut
dst
=
[
0u8
;
18
]
;
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0xA5u16
0xD83Du16
0xDCA9u16
]
&
mut
dst
[
.
.
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0xA5u16
0xD83Du16
0xDCA9u16
]
&
mut
dst
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
OutputFull
)
;
}
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0xD83Du16
0xDCA9u16
]
&
mut
dst
[
.
.
13
]
false
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0xD83Du16
0xDCA9u16
]
&
mut
dst
[
.
.
13
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
InputEmpty
)
;
}
}
#
[
test
]
fn
test_hash
(
)
{
let
mut
encodings
=
:
:
std
:
:
collections
:
:
HashSet
:
:
new
(
)
;
encodings
.
insert
(
UTF_8
)
;
encodings
.
insert
(
ISO_2022_JP
)
;
assert
!
(
encodings
.
contains
(
UTF_8
)
)
;
assert
!
(
encodings
.
contains
(
ISO_2022_JP
)
)
;
assert
!
(
!
encodings
.
contains
(
WINDOWS_1252
)
)
;
encodings
.
remove
(
ISO_2022_JP
)
;
assert
!
(
!
encodings
.
contains
(
ISO_2022_JP
)
)
;
}
#
[
test
]
fn
test_iso_2022_jp_ncr_extra_from_utf16
(
)
{
let
mut
dst
=
[
0u8
;
17
]
;
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf16
(
&
[
0x3041u16
0xFFFFu16
]
&
mut
dst
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
OutputFull
)
;
}
}
#
[
test
]
fn
test_iso_2022_jp_ncr_extra_from_utf8
(
)
{
let
mut
dst
=
[
0u8
;
17
]
;
{
let
mut
encoder
=
ISO_2022_JP
.
new_encoder
(
)
;
let
(
result
_
_
_
)
=
encoder
.
encode_from_utf8
(
"
\
u
{
3041
}
\
u
{
FFFF
}
"
&
mut
dst
[
.
.
]
true
)
;
assert_eq
!
(
result
CoderResult
:
:
OutputFull
)
;
}
}
#
[
test
]
fn
test_max_length_with_bom_to_utf8
(
)
{
let
mut
output
=
[
0u8
;
20
]
;
let
mut
decoder
=
REPLACEMENT
.
new_decoder
(
)
;
let
input
=
b
"
\
xEF
\
xBB
\
xBFA
"
;
{
let
needed
=
decoder
.
max_utf8_buffer_length_without_replacement
(
input
.
len
(
)
)
.
unwrap
(
)
;
let
(
result
read
written
)
=
decoder
.
decode_to_utf8_without_replacement
(
input
&
mut
output
[
.
.
needed
]
true
)
;
assert_eq
!
(
result
DecoderResult
:
:
InputEmpty
)
;
assert_eq
!
(
read
input
.
len
(
)
)
;
assert_eq
!
(
written
1
)
;
assert_eq
!
(
output
[
0
]
0x41
)
;
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
#
[
test
]
fn
test_serde
(
)
{
let
demo
=
Demo
{
num
:
42
name
:
"
foo
"
.
into
(
)
enc
:
UTF_8
}
;
let
serialized
=
serde_json
:
:
to_string
(
&
demo
)
.
unwrap
(
)
;
let
deserialized
:
Demo
=
serde_json
:
:
from_str
(
&
serialized
)
.
unwrap
(
)
;
assert_eq
!
(
deserialized
demo
)
;
let
bincoded
=
bincode
:
:
serialize
(
&
demo
bincode
:
:
Infinite
)
.
unwrap
(
)
;
let
debincoded
:
Demo
=
bincode
:
:
deserialize
(
&
bincoded
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
debincoded
demo
)
;
}
#
[
test
]
fn
test_is_single_byte
(
)
{
assert
!
(
!
BIG5
.
is_single_byte
(
)
)
;
assert
!
(
!
EUC_JP
.
is_single_byte
(
)
)
;
assert
!
(
!
EUC_KR
.
is_single_byte
(
)
)
;
assert
!
(
!
GB18030
.
is_single_byte
(
)
)
;
assert
!
(
!
GBK
.
is_single_byte
(
)
)
;
assert
!
(
!
REPLACEMENT
.
is_single_byte
(
)
)
;
assert
!
(
!
SHIFT_JIS
.
is_single_byte
(
)
)
;
assert
!
(
!
UTF_8
.
is_single_byte
(
)
)
;
assert
!
(
!
UTF_16BE
.
is_single_byte
(
)
)
;
assert
!
(
!
UTF_16LE
.
is_single_byte
(
)
)
;
assert
!
(
!
ISO_2022_JP
.
is_single_byte
(
)
)
;
assert
!
(
IBM866
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_2
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_3
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_4
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_5
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_6
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_7
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_8
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_10
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_13
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_14
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_15
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_16
.
is_single_byte
(
)
)
;
assert
!
(
ISO_8859_8_I
.
is_single_byte
(
)
)
;
assert
!
(
KOI8_R
.
is_single_byte
(
)
)
;
assert
!
(
KOI8_U
.
is_single_byte
(
)
)
;
assert
!
(
MACINTOSH
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_874
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1250
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1251
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1252
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1253
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1254
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1255
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1256
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1257
.
is_single_byte
(
)
)
;
assert
!
(
WINDOWS_1258
.
is_single_byte
(
)
)
;
assert
!
(
X_MAC_CYRILLIC
.
is_single_byte
(
)
)
;
assert
!
(
X_USER_DEFINED
.
is_single_byte
(
)
)
;
}
}
