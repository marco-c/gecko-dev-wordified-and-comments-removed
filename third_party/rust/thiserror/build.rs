use
std
:
:
env
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fs
;
use
std
:
:
io
:
:
ErrorKind
;
use
std
:
:
iter
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
process
:
:
{
self
Command
Stdio
}
;
fn
main
(
)
{
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
build
/
probe
.
rs
"
)
;
println
!
(
"
cargo
:
rustc
-
check
-
cfg
=
cfg
(
error_generic_member_access
)
"
)
;
println
!
(
"
cargo
:
rustc
-
check
-
cfg
=
cfg
(
thiserror_nightly_testing
)
"
)
;
let
error_generic_member_access
;
let
consider_rustc_bootstrap
;
if
compile_probe
(
false
)
{
error_generic_member_access
=
true
;
consider_rustc_bootstrap
=
false
;
}
else
if
let
Some
(
rustc_bootstrap
)
=
env
:
:
var_os
(
"
RUSTC_BOOTSTRAP
"
)
{
if
compile_probe
(
true
)
{
error_generic_member_access
=
true
;
consider_rustc_bootstrap
=
true
;
}
else
if
rustc_bootstrap
=
=
"
1
"
{
error_generic_member_access
=
false
;
consider_rustc_bootstrap
=
false
;
}
else
{
error_generic_member_access
=
false
;
consider_rustc_bootstrap
=
true
;
}
}
else
{
error_generic_member_access
=
false
;
consider_rustc_bootstrap
=
true
;
}
if
error_generic_member_access
{
println
!
(
"
cargo
:
rustc
-
cfg
=
error_generic_member_access
"
)
;
}
if
consider_rustc_bootstrap
{
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
RUSTC_BOOTSTRAP
"
)
;
}
}
fn
compile_probe
(
rustc_bootstrap
:
bool
)
-
>
bool
{
if
env
:
:
var_os
(
"
RUSTC_STAGE
"
)
.
is_some
(
)
{
return
false
;
}
let
rustc
=
cargo_env_var
(
"
RUSTC
"
)
;
let
out_dir
=
cargo_env_var
(
"
OUT_DIR
"
)
;
let
out_subdir
=
Path
:
:
new
(
&
out_dir
)
.
join
(
"
probe
"
)
;
let
probefile
=
Path
:
:
new
(
"
build
"
)
.
join
(
"
probe
.
rs
"
)
;
if
let
Err
(
err
)
=
fs
:
:
create_dir
(
&
out_subdir
)
{
if
err
.
kind
(
)
!
=
ErrorKind
:
:
AlreadyExists
{
eprintln
!
(
"
Failed
to
create
{
}
:
{
}
"
out_subdir
.
display
(
)
err
)
;
process
:
:
exit
(
1
)
;
}
}
let
rustc_wrapper
=
env
:
:
var_os
(
"
RUSTC_WRAPPER
"
)
.
filter
(
|
wrapper
|
!
wrapper
.
is_empty
(
)
)
;
let
rustc_workspace_wrapper
=
env
:
:
var_os
(
"
RUSTC_WORKSPACE_WRAPPER
"
)
.
filter
(
|
wrapper
|
!
wrapper
.
is_empty
(
)
)
;
let
mut
rustc
=
rustc_wrapper
.
into_iter
(
)
.
chain
(
rustc_workspace_wrapper
)
.
chain
(
iter
:
:
once
(
rustc
)
)
;
let
mut
cmd
=
Command
:
:
new
(
rustc
.
next
(
)
.
unwrap
(
)
)
;
cmd
.
args
(
rustc
)
;
if
!
rustc_bootstrap
{
cmd
.
env_remove
(
"
RUSTC_BOOTSTRAP
"
)
;
}
cmd
.
stderr
(
Stdio
:
:
null
(
)
)
.
arg
(
"
-
-
edition
=
2018
"
)
.
arg
(
"
-
-
crate
-
name
=
thiserror
"
)
.
arg
(
"
-
-
crate
-
type
=
lib
"
)
.
arg
(
"
-
-
cap
-
lints
=
allow
"
)
.
arg
(
"
-
-
emit
=
dep
-
info
metadata
"
)
.
arg
(
"
-
-
out
-
dir
"
)
.
arg
(
&
out_subdir
)
.
arg
(
probefile
)
;
if
let
Some
(
target
)
=
env
:
:
var_os
(
"
TARGET
"
)
{
cmd
.
arg
(
"
-
-
target
"
)
.
arg
(
target
)
;
}
if
let
Ok
(
rustflags
)
=
env
:
:
var
(
"
CARGO_ENCODED_RUSTFLAGS
"
)
{
if
!
rustflags
.
is_empty
(
)
{
for
arg
in
rustflags
.
split
(
'
\
x1f
'
)
{
cmd
.
arg
(
arg
)
;
}
}
}
let
success
=
match
cmd
.
status
(
)
{
Ok
(
status
)
=
>
status
.
success
(
)
Err
(
_
)
=
>
false
}
;
if
let
Err
(
err
)
=
fs
:
:
remove_dir_all
(
&
out_subdir
)
{
if
err
.
kind
(
)
!
=
ErrorKind
:
:
NotFound
{
eprintln
!
(
"
Failed
to
clean
up
{
}
:
{
}
"
out_subdir
.
display
(
)
err
)
;
process
:
:
exit
(
1
)
;
}
}
success
}
fn
cargo_env_var
(
key
:
&
str
)
-
>
OsString
{
env
:
:
var_os
(
key
)
.
unwrap_or_else
(
|
|
{
eprintln
!
(
"
Environment
variable
{
key
}
is
not
set
during
execution
of
build
script
"
)
;
process
:
:
exit
(
1
)
;
}
)
}
