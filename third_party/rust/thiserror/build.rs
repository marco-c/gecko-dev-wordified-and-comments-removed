use
std
:
:
env
;
use
std
:
:
fs
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
process
:
:
{
Command
ExitStatus
Stdio
}
;
use
std
:
:
str
;
const
PROBE
:
&
str
=
r
#
"
#
!
[
feature
(
provide_any
)
]
use
std
:
:
any
:
:
{
Demand
Provider
}
;
fn
_f
<
'
a
P
:
Provider
>
(
p
:
&
'
a
P
demand
:
&
mut
Demand
<
'
a
>
)
{
p
.
provide
(
demand
)
;
}
"
#
;
fn
main
(
)
{
match
compile_probe
(
)
{
Some
(
status
)
if
status
.
success
(
)
=
>
println
!
(
"
cargo
:
rustc
-
cfg
=
provide_any
"
)
_
=
>
{
}
}
}
fn
compile_probe
(
)
-
>
Option
<
ExitStatus
>
{
let
rustc
=
env
:
:
var_os
(
"
RUSTC
"
)
?
;
let
out_dir
=
env
:
:
var_os
(
"
OUT_DIR
"
)
?
;
let
probefile
=
Path
:
:
new
(
&
out_dir
)
.
join
(
"
probe
.
rs
"
)
;
fs
:
:
write
(
&
probefile
PROBE
)
.
ok
(
)
?
;
let
mut
cmd
=
if
let
Some
(
wrapper
)
=
env
:
:
var_os
(
"
RUSTC_WRAPPER
"
)
{
let
mut
cmd
=
Command
:
:
new
(
wrapper
)
;
cmd
.
arg
(
rustc
)
;
cmd
}
else
{
Command
:
:
new
(
rustc
)
}
;
cmd
.
stderr
(
Stdio
:
:
null
(
)
)
.
arg
(
"
-
-
edition
=
2018
"
)
.
arg
(
"
-
-
crate
-
name
=
thiserror_build
"
)
.
arg
(
"
-
-
crate
-
type
=
lib
"
)
.
arg
(
"
-
-
emit
=
metadata
"
)
.
arg
(
"
-
-
out
-
dir
"
)
.
arg
(
out_dir
)
.
arg
(
probefile
)
;
if
let
Some
(
target
)
=
env
:
:
var_os
(
"
TARGET
"
)
{
cmd
.
arg
(
"
-
-
target
"
)
.
arg
(
target
)
;
}
if
let
Ok
(
rustflags
)
=
env
:
:
var
(
"
CARGO_ENCODED_RUSTFLAGS
"
)
{
if
!
rustflags
.
is_empty
(
)
{
for
arg
in
rustflags
.
split
(
'
\
x1f
'
)
{
cmd
.
arg
(
arg
)
;
}
}
}
cmd
.
status
(
)
.
ok
(
)
}
