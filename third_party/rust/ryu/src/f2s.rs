use
crate
:
:
common
:
:
*
;
use
crate
:
:
f2s_intrinsics
:
:
*
;
pub
const
FLOAT_MANTISSA_BITS
:
u32
=
23
;
pub
const
FLOAT_EXPONENT_BITS
:
u32
=
8
;
const
FLOAT_BIAS
:
i32
=
127
;
pub
use
crate
:
:
f2s_intrinsics
:
:
{
FLOAT_POW5_BITCOUNT
FLOAT_POW5_INV_BITCOUNT
}
;
pub
struct
FloatingDecimal32
{
pub
mantissa
:
u32
pub
exponent
:
i32
}
#
[
cfg_attr
(
feature
=
"
no
-
panic
"
inline
)
]
pub
fn
f2d
(
ieee_mantissa
:
u32
ieee_exponent
:
u32
)
-
>
FloatingDecimal32
{
let
(
e2
m2
)
=
if
ieee_exponent
=
=
0
{
(
1
-
FLOAT_BIAS
-
FLOAT_MANTISSA_BITS
as
i32
-
2
ieee_mantissa
)
}
else
{
(
ieee_exponent
as
i32
-
FLOAT_BIAS
-
FLOAT_MANTISSA_BITS
as
i32
-
2
(
1u32
<
<
FLOAT_MANTISSA_BITS
)
|
ieee_mantissa
)
}
;
let
even
=
(
m2
&
1
)
=
=
0
;
let
accept_bounds
=
even
;
let
mv
=
4
*
m2
;
let
mp
=
4
*
m2
+
2
;
let
mm_shift
=
(
ieee_mantissa
!
=
0
|
|
ieee_exponent
<
=
1
)
as
u32
;
let
mm
=
4
*
m2
-
1
-
mm_shift
;
let
mut
vr
:
u32
;
let
mut
vp
:
u32
;
let
mut
vm
:
u32
;
let
e10
:
i32
;
let
mut
vm_is_trailing_zeros
=
false
;
let
mut
vr_is_trailing_zeros
=
false
;
let
mut
last_removed_digit
=
0u8
;
if
e2
>
=
0
{
let
q
=
log10_pow2
(
e2
)
;
e10
=
q
as
i32
;
let
k
=
FLOAT_POW5_INV_BITCOUNT
+
pow5bits
(
q
as
i32
)
-
1
;
let
i
=
-
e2
+
q
as
i32
+
k
;
vr
=
mul_pow5_inv_div_pow2
(
mv
q
i
)
;
vp
=
mul_pow5_inv_div_pow2
(
mp
q
i
)
;
vm
=
mul_pow5_inv_div_pow2
(
mm
q
i
)
;
if
q
!
=
0
&
&
(
vp
-
1
)
/
10
<
=
vm
/
10
{
let
l
=
FLOAT_POW5_INV_BITCOUNT
+
pow5bits
(
q
as
i32
-
1
)
-
1
;
last_removed_digit
=
(
mul_pow5_inv_div_pow2
(
mv
q
-
1
-
e2
+
q
as
i32
-
1
+
l
)
%
10
)
as
u8
;
}
if
q
<
=
9
{
if
mv
%
5
=
=
0
{
vr_is_trailing_zeros
=
multiple_of_power_of_5_32
(
mv
q
)
;
}
else
if
accept_bounds
{
vm_is_trailing_zeros
=
multiple_of_power_of_5_32
(
mm
q
)
;
}
else
{
vp
-
=
multiple_of_power_of_5_32
(
mp
q
)
as
u32
;
}
}
}
else
{
let
q
=
log10_pow5
(
-
e2
)
;
e10
=
q
as
i32
+
e2
;
let
i
=
-
e2
-
q
as
i32
;
let
k
=
pow5bits
(
i
)
-
FLOAT_POW5_BITCOUNT
;
let
mut
j
=
q
as
i32
-
k
;
vr
=
mul_pow5_div_pow2
(
mv
i
as
u32
j
)
;
vp
=
mul_pow5_div_pow2
(
mp
i
as
u32
j
)
;
vm
=
mul_pow5_div_pow2
(
mm
i
as
u32
j
)
;
if
q
!
=
0
&
&
(
vp
-
1
)
/
10
<
=
vm
/
10
{
j
=
q
as
i32
-
1
-
(
pow5bits
(
i
+
1
)
-
FLOAT_POW5_BITCOUNT
)
;
last_removed_digit
=
(
mul_pow5_div_pow2
(
mv
(
i
+
1
)
as
u32
j
)
%
10
)
as
u8
;
}
if
q
<
=
1
{
vr_is_trailing_zeros
=
true
;
if
accept_bounds
{
vm_is_trailing_zeros
=
mm_shift
=
=
1
;
}
else
{
vp
-
=
1
;
}
}
else
if
q
<
31
{
vr_is_trailing_zeros
=
multiple_of_power_of_2_32
(
mv
q
-
1
)
;
}
}
let
mut
removed
=
0i32
;
let
output
=
if
vm_is_trailing_zeros
|
|
vr_is_trailing_zeros
{
while
vp
/
10
>
vm
/
10
{
vm_is_trailing_zeros
&
=
vm
-
(
vm
/
10
)
*
10
=
=
0
;
vr_is_trailing_zeros
&
=
last_removed_digit
=
=
0
;
last_removed_digit
=
(
vr
%
10
)
as
u8
;
vr
/
=
10
;
vp
/
=
10
;
vm
/
=
10
;
removed
+
=
1
;
}
if
vm_is_trailing_zeros
{
while
vm
%
10
=
=
0
{
vr_is_trailing_zeros
&
=
last_removed_digit
=
=
0
;
last_removed_digit
=
(
vr
%
10
)
as
u8
;
vr
/
=
10
;
vp
/
=
10
;
vm
/
=
10
;
removed
+
=
1
;
}
}
if
vr_is_trailing_zeros
&
&
last_removed_digit
=
=
5
&
&
vr
%
2
=
=
0
{
last_removed_digit
=
4
;
}
vr
+
(
(
vr
=
=
vm
&
&
(
!
accept_bounds
|
|
!
vm_is_trailing_zeros
)
)
|
|
last_removed_digit
>
=
5
)
as
u32
}
else
{
while
vp
/
10
>
vm
/
10
{
last_removed_digit
=
(
vr
%
10
)
as
u8
;
vr
/
=
10
;
vp
/
=
10
;
vm
/
=
10
;
removed
+
=
1
;
}
vr
+
(
vr
=
=
vm
|
|
last_removed_digit
>
=
5
)
as
u32
}
;
let
exp
=
e10
+
removed
;
FloatingDecimal32
{
exponent
:
exp
mantissa
:
output
}
}
