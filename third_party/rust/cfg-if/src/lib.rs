#
!
[
no_std
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
cfg
-
if
"
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
#
[
macro_export
]
macro_rules
!
cfg_if
{
(
(
if
#
[
cfg
(
(
meta
:
meta
)
*
)
]
{
(
tokens
:
tt
)
*
}
)
else
*
else
{
(
tokens2
:
tt
)
*
}
)
=
>
{
crate
:
:
cfg_if
!
{
__items
(
)
;
(
(
(
(
meta
)
*
)
(
(
tokens
)
*
)
)
)
*
(
(
)
(
(
tokens2
)
*
)
)
}
}
;
(
if
#
[
cfg
(
(
i_met
:
meta
)
*
)
]
{
(
i_tokens
:
tt
)
*
}
(
else
if
#
[
cfg
(
(
e_met
:
meta
)
*
)
]
{
(
e_tokens
:
tt
)
*
}
)
*
)
=
>
{
crate
:
:
cfg_if
!
{
__items
(
)
;
(
(
(
i_met
)
*
)
(
(
i_tokens
)
*
)
)
(
(
(
(
e_met
)
*
)
(
(
e_tokens
)
*
)
)
)
*
(
(
)
(
)
)
}
}
;
(
__items
(
(
not
:
meta
)
*
)
;
)
=
>
{
}
;
(
__items
(
(
not
:
meta
)
*
)
;
(
(
(
m
:
meta
)
*
)
(
(
tokens
:
tt
)
*
)
)
(
rest
:
tt
)
*
)
=
>
{
/
/
Emit
all
items
within
one
block
applying
an
appropriate
#
[
cfg
]
.
The
/
/
#
[
cfg
]
will
require
all
m
matchers
specified
and
must
also
negate
/
/
all
previous
matchers
.
#
[
cfg
(
all
(
(
m
)
*
not
(
any
(
(
not
)
*
)
)
)
)
]
crate
:
:
cfg_if
!
{
__identity
(
tokens
)
*
}
/
/
Recurse
to
emit
all
other
items
in
rest
and
when
we
do
so
add
all
/
/
our
m
matchers
to
the
list
of
not
matchers
as
future
emissions
/
/
will
have
to
negate
everything
we
just
matched
as
well
.
crate
:
:
cfg_if
!
{
__items
(
(
not
)
*
(
m
)
*
)
;
(
rest
)
*
}
}
;
(
__identity
(
tokens
:
tt
)
*
)
=
>
{
(
tokens
)
*
}
;
}
#
[
cfg
(
test
)
]
mod
tests
{
cfg_if
!
{
if
#
[
cfg
(
test
)
]
{
use
core
:
:
option
:
:
Option
as
Option2
;
fn
works1
(
)
-
>
Option2
<
u32
>
{
Some
(
1
)
}
}
else
{
fn
works1
(
)
-
>
Option
<
u32
>
{
None
}
}
}
cfg_if
!
{
if
#
[
cfg
(
foo
)
]
{
fn
works2
(
)
-
>
bool
{
false
}
}
else
if
#
[
cfg
(
test
)
]
{
fn
works2
(
)
-
>
bool
{
true
}
}
else
{
fn
works2
(
)
-
>
bool
{
false
}
}
}
cfg_if
!
{
if
#
[
cfg
(
foo
)
]
{
fn
works3
(
)
-
>
bool
{
false
}
}
else
{
fn
works3
(
)
-
>
bool
{
true
}
}
}
cfg_if
!
{
if
#
[
cfg
(
test
)
]
{
use
core
:
:
option
:
:
Option
as
Option3
;
fn
works4
(
)
-
>
Option3
<
u32
>
{
Some
(
1
)
}
}
}
cfg_if
!
{
if
#
[
cfg
(
foo
)
]
{
fn
works5
(
)
-
>
bool
{
false
}
}
else
if
#
[
cfg
(
test
)
]
{
fn
works5
(
)
-
>
bool
{
true
}
}
}
#
[
test
]
fn
it_works
(
)
{
assert
!
(
works1
(
)
.
is_some
(
)
)
;
assert
!
(
works2
(
)
)
;
assert
!
(
works3
(
)
)
;
assert
!
(
works4
(
)
.
is_some
(
)
)
;
assert
!
(
works5
(
)
)
;
}
#
[
test
]
#
[
allow
(
clippy
:
:
assertions_on_constants
)
]
fn
test_usage_within_a_function
(
)
{
cfg_if
!
{
if
#
[
cfg
(
debug_assertions
)
]
{
/
/
we
want
to
put
more
than
one
thing
here
to
make
sure
that
they
/
/
all
get
configured
properly
.
assert
!
(
cfg
!
(
debug_assertions
)
)
;
assert_eq
!
(
4
2
+
2
)
;
}
else
{
assert
!
(
works1
(
)
.
is_some
(
)
)
;
assert_eq
!
(
10
5
+
5
)
;
}
}
}
trait
Trait
{
fn
blah
(
&
self
)
;
}
#
[
allow
(
dead_code
)
]
struct
Struct
;
impl
Trait
for
Struct
{
cfg_if
!
{
if
#
[
cfg
(
feature
=
"
blah
"
)
]
{
fn
blah
(
&
self
)
{
unimplemented
!
(
)
;
}
}
else
{
fn
blah
(
&
self
)
{
unimplemented
!
(
)
;
}
}
}
}
}
