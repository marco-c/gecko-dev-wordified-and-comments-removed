use
{
RecvDgram
SendDgram
}
;
use
tokio_reactor
:
:
{
Handle
PollEvented
}
;
use
futures
:
:
{
Async
Poll
}
;
use
mio
:
:
Ready
;
use
mio_uds
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
net
:
:
Shutdown
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
RawFd
}
;
use
std
:
:
os
:
:
unix
:
:
net
:
:
{
self
SocketAddr
}
;
use
std
:
:
path
:
:
Path
;
pub
struct
UnixDatagram
{
io
:
PollEvented
<
mio_uds
:
:
UnixDatagram
>
}
impl
UnixDatagram
{
pub
fn
bind
<
P
>
(
path
:
P
)
-
>
io
:
:
Result
<
UnixDatagram
>
where
P
:
AsRef
<
Path
>
{
let
socket
=
mio_uds
:
:
UnixDatagram
:
:
bind
(
path
)
?
;
Ok
(
UnixDatagram
:
:
new
(
socket
)
)
}
pub
fn
pair
(
)
-
>
io
:
:
Result
<
(
UnixDatagram
UnixDatagram
)
>
{
let
(
a
b
)
=
mio_uds
:
:
UnixDatagram
:
:
pair
(
)
?
;
let
a
=
UnixDatagram
:
:
new
(
a
)
;
let
b
=
UnixDatagram
:
:
new
(
b
)
;
Ok
(
(
a
b
)
)
}
pub
fn
from_std
(
datagram
:
net
:
:
UnixDatagram
handle
:
&
Handle
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
let
socket
=
mio_uds
:
:
UnixDatagram
:
:
from_datagram
(
datagram
)
?
;
let
io
=
PollEvented
:
:
new_with_handle
(
socket
handle
)
?
;
Ok
(
UnixDatagram
{
io
}
)
}
fn
new
(
socket
:
mio_uds
:
:
UnixDatagram
)
-
>
UnixDatagram
{
let
io
=
PollEvented
:
:
new
(
socket
)
;
UnixDatagram
{
io
}
}
pub
fn
unbound
(
)
-
>
io
:
:
Result
<
UnixDatagram
>
{
let
socket
=
mio_uds
:
:
UnixDatagram
:
:
unbound
(
)
?
;
Ok
(
UnixDatagram
:
:
new
(
socket
)
)
}
pub
fn
connect
<
P
:
AsRef
<
Path
>
>
(
&
self
path
:
P
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
connect
(
path
)
}
pub
fn
poll_read_ready
(
&
self
ready
:
Ready
)
-
>
Poll
<
Ready
io
:
:
Error
>
{
self
.
io
.
poll_read_ready
(
ready
)
}
pub
fn
poll_write_ready
(
&
self
)
-
>
Poll
<
Ready
io
:
:
Error
>
{
self
.
io
.
poll_write_ready
(
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
local_addr
(
)
}
pub
fn
peer_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
peer_addr
(
)
}
pub
fn
poll_recv_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
(
usize
SocketAddr
)
io
:
:
Error
>
{
try_ready
!
(
self
.
io
.
poll_read_ready
(
Ready
:
:
readable
(
)
)
)
;
match
self
.
io
.
get_ref
(
)
.
recv_from
(
buf
)
{
Ok
(
ret
)
=
>
Ok
(
ret
.
into
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_read_ready
(
Ready
:
:
readable
(
)
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
poll_recv
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
usize
io
:
:
Error
>
{
try_ready
!
(
self
.
io
.
poll_read_ready
(
Ready
:
:
readable
(
)
)
)
;
match
self
.
io
.
get_ref
(
)
.
recv
(
buf
)
{
Ok
(
ret
)
=
>
Ok
(
ret
.
into
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_read_ready
(
Ready
:
:
readable
(
)
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
recv_dgram
<
T
>
(
self
buf
:
T
)
-
>
RecvDgram
<
T
>
where
T
:
AsMut
<
[
u8
]
>
{
RecvDgram
:
:
new
(
self
buf
)
}
pub
fn
poll_send_to
<
P
>
(
&
self
buf
:
&
[
u8
]
path
:
P
)
-
>
Poll
<
usize
io
:
:
Error
>
where
P
:
AsRef
<
Path
>
{
try_ready
!
(
self
.
io
.
poll_write_ready
(
)
)
;
match
self
.
io
.
get_ref
(
)
.
send_to
(
buf
path
)
{
Ok
(
ret
)
=
>
Ok
(
ret
.
into
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_write_ready
(
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
poll_send
(
&
self
buf
:
&
[
u8
]
)
-
>
Poll
<
usize
io
:
:
Error
>
{
try_ready
!
(
self
.
io
.
poll_write_ready
(
)
)
;
match
self
.
io
.
get_ref
(
)
.
send
(
buf
)
{
Ok
(
ret
)
=
>
Ok
(
ret
.
into
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_write_ready
(
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
send_dgram
<
T
P
>
(
self
buf
:
T
path
:
P
)
-
>
SendDgram
<
T
P
>
where
T
:
AsRef
<
[
u8
]
>
P
:
AsRef
<
Path
>
{
SendDgram
:
:
new
(
self
buf
path
)
}
pub
fn
take_error
(
&
self
)
-
>
io
:
:
Result
<
Option
<
io
:
:
Error
>
>
{
self
.
io
.
get_ref
(
)
.
take_error
(
)
}
pub
fn
shutdown
(
&
self
how
:
Shutdown
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
shutdown
(
how
)
}
}
impl
fmt
:
:
Debug
for
UnixDatagram
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
io
.
get_ref
(
)
.
fmt
(
f
)
}
}
impl
AsRawFd
for
UnixDatagram
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
get_ref
(
)
.
as_raw_fd
(
)
}
}
