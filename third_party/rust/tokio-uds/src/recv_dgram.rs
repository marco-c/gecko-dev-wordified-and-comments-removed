use
UnixDatagram
;
use
futures
:
:
{
Async
Future
Poll
}
;
use
std
:
:
io
;
use
std
:
:
mem
;
#
[
derive
(
Debug
)
]
pub
struct
RecvDgram
<
T
>
{
st
:
State
<
T
>
}
#
[
derive
(
Debug
)
]
enum
State
<
T
>
{
Receiving
{
sock
:
UnixDatagram
buf
:
T
}
Empty
}
impl
<
T
>
RecvDgram
<
T
>
where
T
:
AsMut
<
[
u8
]
>
{
pub
(
crate
)
fn
new
(
sock
:
UnixDatagram
buf
:
T
)
-
>
RecvDgram
<
T
>
{
RecvDgram
{
st
:
State
:
:
Receiving
{
sock
buf
}
}
}
}
impl
<
T
>
Future
for
RecvDgram
<
T
>
where
T
:
AsMut
<
[
u8
]
>
{
type
Item
=
(
UnixDatagram
T
usize
String
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
Self
:
:
Error
>
{
let
received
;
let
peer
;
if
let
State
:
:
Receiving
{
ref
mut
sock
ref
mut
buf
}
=
self
.
st
{
let
(
n
p
)
=
try_ready
!
(
sock
.
poll_recv_from
(
buf
.
as_mut
(
)
)
)
;
received
=
n
;
peer
=
p
.
as_pathname
(
)
.
map_or
(
String
:
:
new
(
)
|
p
|
{
p
.
to_str
(
)
.
map_or
(
String
:
:
new
(
)
|
s
|
s
.
to_string
(
)
)
}
)
;
}
else
{
panic
!
(
)
}
if
let
State
:
:
Receiving
{
sock
buf
}
=
mem
:
:
replace
(
&
mut
self
.
st
State
:
:
Empty
)
{
Ok
(
Async
:
:
Ready
(
(
sock
buf
received
peer
)
)
)
}
else
{
panic
!
(
)
}
}
}
