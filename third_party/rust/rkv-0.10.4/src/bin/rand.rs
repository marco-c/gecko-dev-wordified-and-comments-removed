extern
crate
rkv
;
use
rkv
:
:
{
Rkv
SingleStore
StoreOptions
Value
}
;
use
std
:
:
{
env
:
:
args
fs
:
:
{
create_dir_all
File
}
io
:
:
Read
path
:
:
Path
}
;
fn
main
(
)
{
let
mut
args
=
args
(
)
;
let
mut
database
=
None
;
let
mut
path
=
None
;
let
mut
num_pairs
=
50
;
args
.
next
(
)
;
while
let
Some
(
arg
)
=
args
.
next
(
)
{
if
&
arg
[
0
.
.
1
]
=
=
"
-
"
{
match
&
arg
[
1
.
.
]
{
"
s
"
=
>
{
database
=
match
args
.
next
(
)
{
None
=
>
panic
!
(
"
-
s
must
be
followed
by
database
arg
"
)
Some
(
str
)
=
>
Some
(
str
)
}
;
}
"
n
"
=
>
{
num_pairs
=
match
args
.
next
(
)
{
None
=
>
panic
!
(
"
-
s
must
be
followed
by
number
of
pairs
"
)
Some
(
str
)
=
>
str
.
parse
(
)
.
expect
(
"
number
"
)
}
;
}
str
=
>
panic
!
(
"
arg
-
{
}
not
recognized
"
str
)
}
}
else
{
if
path
.
is_some
(
)
{
panic
!
(
"
must
provide
only
one
path
to
the
LMDB
environment
"
)
;
}
path
=
Some
(
arg
)
;
}
}
if
path
.
is_none
(
)
{
panic
!
(
"
must
provide
a
path
to
the
LMDB
environment
"
)
;
}
let
path
=
path
.
unwrap
(
)
;
create_dir_all
(
&
path
)
.
expect
(
"
dir
created
"
)
;
let
mut
builder
=
Rkv
:
:
environment_builder
(
)
;
builder
.
set_max_dbs
(
2
)
;
builder
.
set_map_size
(
(
511
+
65535
)
*
num_pairs
*
2
)
;
let
rkv
=
Rkv
:
:
from_env
(
Path
:
:
new
(
&
path
)
builder
)
.
expect
(
"
Rkv
"
)
;
let
store
:
SingleStore
=
rkv
.
open_single
(
database
.
as_ref
(
)
.
map
(
|
x
|
x
.
as_str
(
)
)
StoreOptions
:
:
create
(
)
)
.
expect
(
"
opened
"
)
;
let
mut
writer
=
rkv
.
write
(
)
.
expect
(
"
writer
"
)
;
let
mut
random
=
File
:
:
open
(
"
/
dev
/
urandom
"
)
.
unwrap
(
)
;
let
mut
nums
=
[
0u8
;
4
]
;
random
.
read_exact
(
&
mut
nums
)
.
unwrap
(
)
;
for
_
in
0
.
.
num_pairs
{
let
key_len
=
(
(
u16
:
:
from
(
nums
[
0
]
)
+
(
u16
:
:
from
(
nums
[
1
]
)
<
<
8
)
)
%
511
+
1
)
as
usize
;
let
value_len
=
(
u16
:
:
from
(
nums
[
2
]
)
+
(
u16
:
:
from
(
nums
[
3
]
)
<
<
8
)
)
as
usize
;
let
mut
key
:
Vec
<
u8
>
=
vec
!
[
0
;
key_len
]
;
random
.
read_exact
(
&
mut
key
[
0
.
.
key_len
]
)
.
unwrap
(
)
;
let
mut
value
:
Vec
<
u8
>
=
vec
!
[
0
;
value_len
]
;
random
.
read_exact
(
&
mut
value
[
0
.
.
value_len
]
)
.
unwrap
(
)
;
store
.
put
(
&
mut
writer
key
&
Value
:
:
Blob
(
&
value
)
)
.
expect
(
"
wrote
"
)
;
}
writer
.
commit
(
)
.
expect
(
"
committed
"
)
;
}
