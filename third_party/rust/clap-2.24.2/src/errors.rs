use
std
:
:
convert
:
:
From
;
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
as
std_fmt
;
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
process
;
use
std
:
:
result
:
:
Result
as
StdResult
;
use
args
:
:
{
FlagBuilder
AnyArg
}
;
use
fmt
;
use
suggestions
;
pub
type
Result
<
T
>
=
StdResult
<
T
Error
>
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
ErrorKind
{
InvalidValue
UnknownArgument
#
[
cfg_attr
(
not
(
feature
=
"
suggestions
"
)
doc
=
"
no_run
"
)
]
#
[
cfg_attr
(
feature
=
"
suggestions
"
doc
=
"
"
)
]
InvalidSubcommand
UnrecognizedSubcommand
EmptyValue
ValueValidation
TooManyValues
TooFewValues
WrongNumberOfValues
ArgumentConflict
MissingRequiredArgument
MissingSubcommand
MissingArgumentOrSubcommand
UnexpectedMultipleUsage
#
[
cfg_attr
(
not
(
unix
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
unix
doc
=
"
"
)
]
InvalidUtf8
HelpDisplayed
VersionDisplayed
ArgumentNotFound
Io
Format
}
#
[
derive
(
Debug
)
]
pub
struct
Error
{
pub
message
:
String
pub
kind
:
ErrorKind
pub
info
:
Option
<
Vec
<
String
>
>
}
impl
Error
{
pub
fn
use_stderr
(
&
self
)
-
>
bool
{
match
self
.
kind
{
ErrorKind
:
:
HelpDisplayed
|
ErrorKind
:
:
VersionDisplayed
=
>
false
_
=
>
true
}
}
pub
fn
exit
(
&
self
)
-
>
!
{
if
self
.
use_stderr
(
)
{
wlnerr
!
(
"
{
}
"
self
.
message
)
;
process
:
:
exit
(
1
)
;
}
let
out
=
io
:
:
stdout
(
)
;
writeln
!
(
&
mut
out
.
lock
(
)
"
{
}
"
self
.
message
)
.
expect
(
"
Error
writing
Error
to
stdout
"
)
;
process
:
:
exit
(
0
)
;
}
#
[
doc
(
hidden
)
]
pub
fn
write_to
<
W
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
write
!
(
w
"
{
}
"
self
.
message
)
}
#
[
doc
(
hidden
)
]
pub
fn
argument_conflict
<
'
a
'
b
A
O
U
>
(
arg
:
&
A
other
:
Option
<
O
>
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
AnyArg
<
'
a
'
b
>
+
Display
O
:
Into
<
String
>
U
:
Display
{
let
mut
v
=
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
]
;
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
argument
'
{
}
'
cannot
be
used
with
{
}
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
&
*
arg
.
to_string
(
)
)
match
other
{
Some
(
name
)
=
>
{
let
n
=
name
.
into
(
)
;
v
.
push
(
n
.
clone
(
)
)
;
c
.
warning
(
format
!
(
"
'
{
}
'
"
n
)
)
}
None
=
>
{
c
.
none
(
"
one
or
more
of
the
other
specified
arguments
"
.
to_owned
(
)
)
}
}
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
ArgumentConflict
info
:
Some
(
v
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
empty_value
<
'
a
'
b
A
U
>
(
arg
:
&
A
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
AnyArg
<
'
a
'
b
>
+
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
argument
'
{
}
'
requires
a
value
but
none
was
supplied
\
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
arg
.
to_string
(
)
)
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
EmptyValue
info
:
Some
(
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
invalid_value
<
'
a
'
b
B
G
A
U
>
(
bad_val
:
B
good_vals
:
&
[
G
]
arg
:
&
A
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
B
:
AsRef
<
str
>
G
:
AsRef
<
str
>
+
Display
A
:
AnyArg
<
'
a
'
b
>
+
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
let
suffix
=
suggestions
:
:
did_you_mean_suffix
(
bad_val
.
as_ref
(
)
good_vals
.
iter
(
)
suggestions
:
:
DidYouMeanMessageStyle
:
:
EnumValue
)
;
let
mut
sorted
=
vec
!
[
]
;
for
v
in
good_vals
{
let
val
=
format
!
(
"
{
}
"
c
.
good
(
v
)
)
;
sorted
.
push
(
val
)
;
}
sorted
.
sort
(
)
;
let
valid_values
=
sorted
.
join
(
"
"
)
;
Error
{
message
:
format
!
(
"
{
}
'
{
}
'
isn
'
t
a
valid
value
for
'
{
}
'
\
n
\
t
\
[
values
:
{
}
]
\
n
\
{
}
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
bad_val
.
as_ref
(
)
)
c
.
warning
(
arg
.
to_string
(
)
)
valid_values
suffix
.
0
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
InvalidValue
info
:
Some
(
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
bad_val
.
as_ref
(
)
.
to_owned
(
)
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
invalid_subcommand
<
S
D
N
U
>
(
subcmd
:
S
did_you_mean
:
D
name
:
N
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
S
:
Into
<
String
>
D
:
AsRef
<
str
>
+
Display
N
:
Display
U
:
Display
{
let
s
=
subcmd
.
into
(
)
;
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
subcommand
'
{
}
'
wasn
'
t
recognized
\
n
\
t
\
Did
you
mean
'
{
}
'
?
\
n
\
n
\
If
you
believe
you
received
this
message
in
error
try
\
re
-
running
with
'
{
}
{
}
{
}
'
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
&
*
s
)
c
.
good
(
did_you_mean
.
as_ref
(
)
)
name
c
.
good
(
"
-
-
"
)
&
*
s
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
InvalidSubcommand
info
:
Some
(
vec
!
[
s
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
unrecognized_subcommand
<
S
N
>
(
subcmd
:
S
name
:
N
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
S
:
Into
<
String
>
N
:
Display
{
let
s
=
subcmd
.
into
(
)
;
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
subcommand
'
{
}
'
wasn
'
t
recognized
\
n
\
n
\
{
}
\
n
\
t
\
{
}
help
<
subcommands
>
.
.
.
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
&
*
s
)
c
.
warning
(
"
USAGE
:
"
)
name
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
UnrecognizedSubcommand
info
:
Some
(
vec
!
[
s
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
missing_required_argument
<
R
U
>
(
required
:
R
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
R
:
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
following
required
arguments
were
not
provided
:
{
}
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
required
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
MissingRequiredArgument
info
:
None
}
}
#
[
doc
(
hidden
)
]
pub
fn
missing_subcommand
<
N
U
>
(
name
:
N
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
N
:
AsRef
<
str
>
+
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
'
{
}
'
requires
a
subcommand
but
one
was
not
provided
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
name
)
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
MissingSubcommand
info
:
None
}
}
#
[
doc
(
hidden
)
]
pub
fn
invalid_utf8
<
U
>
(
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
Invalid
UTF
-
8
was
detected
in
one
or
more
arguments
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
InvalidUtf8
info
:
None
}
}
#
[
doc
(
hidden
)
]
pub
fn
too_many_values
<
'
a
'
b
V
A
U
>
(
val
:
V
arg
:
&
A
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
V
:
AsRef
<
str
>
+
Display
+
ToOwned
A
:
AnyArg
<
'
a
'
b
>
+
Display
U
:
Display
{
let
v
=
val
.
as_ref
(
)
;
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
value
'
{
}
'
was
provided
to
'
{
}
'
but
it
wasn
'
t
expecting
\
any
more
values
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
v
)
c
.
warning
(
arg
.
to_string
(
)
)
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
TooManyValues
info
:
Some
(
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
v
.
to_owned
(
)
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
too_few_values
<
'
a
'
b
A
U
>
(
arg
:
&
A
min_vals
:
u64
curr_vals
:
usize
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
AnyArg
<
'
a
'
b
>
+
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
argument
'
{
}
'
requires
at
least
{
}
values
but
only
{
}
w
{
}
\
provided
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
arg
.
to_string
(
)
)
c
.
warning
(
min_vals
.
to_string
(
)
)
c
.
warning
(
curr_vals
.
to_string
(
)
)
if
curr_vals
>
1
{
"
ere
"
}
else
{
"
as
"
}
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
TooFewValues
info
:
Some
(
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
value_validation
<
'
a
'
b
A
>
(
arg
:
Option
<
&
A
>
err
:
String
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
AnyArg
<
'
a
'
b
>
+
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
Invalid
value
{
}
:
{
}
"
c
.
error
(
"
error
:
"
)
if
let
Some
(
a
)
=
arg
{
format
!
(
"
for
'
{
}
'
"
c
.
warning
(
a
.
to_string
(
)
)
)
}
else
{
"
"
.
to_string
(
)
}
err
)
kind
:
ErrorKind
:
:
ValueValidation
info
:
None
}
}
#
[
doc
(
hidden
)
]
pub
fn
value_validation_auto
(
err
:
String
)
-
>
Self
{
let
n
:
Option
<
&
FlagBuilder
>
=
None
;
Error
:
:
value_validation
(
n
err
fmt
:
:
ColorWhen
:
:
Auto
)
}
#
[
doc
(
hidden
)
]
pub
fn
wrong_number_of_values
<
'
a
'
b
A
S
U
>
(
arg
:
&
A
num_vals
:
u64
curr_vals
:
usize
suffix
:
S
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
AnyArg
<
'
a
'
b
>
+
Display
S
:
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
argument
'
{
}
'
requires
{
}
values
but
{
}
w
{
}
\
provided
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
arg
.
to_string
(
)
)
c
.
warning
(
num_vals
.
to_string
(
)
)
c
.
warning
(
curr_vals
.
to_string
(
)
)
suffix
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
WrongNumberOfValues
info
:
Some
(
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
unexpected_multiple_usage
<
'
a
'
b
A
U
>
(
arg
:
&
A
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
AnyArg
<
'
a
'
b
>
+
Display
U
:
Display
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
The
argument
'
{
}
'
was
provided
more
than
once
but
cannot
\
be
used
multiple
times
\
n
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
arg
.
to_string
(
)
)
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
UnexpectedMultipleUsage
info
:
Some
(
vec
!
[
arg
.
name
(
)
.
to_owned
(
)
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
unknown_argument
<
A
U
>
(
arg
:
A
did_you_mean
:
&
str
usage
:
U
color
:
fmt
:
:
ColorWhen
)
-
>
Self
where
A
:
Into
<
String
>
U
:
Display
{
let
a
=
arg
.
into
(
)
;
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
Found
argument
'
{
}
'
which
wasn
'
t
expected
or
isn
'
t
valid
in
\
this
context
{
}
\
n
\
{
}
\
n
\
n
\
For
more
information
try
{
}
"
c
.
error
(
"
error
:
"
)
c
.
warning
(
&
*
a
)
if
did_you_mean
.
is_empty
(
)
{
"
\
n
"
.
to_owned
(
)
}
else
{
format
!
(
"
{
}
\
n
"
did_you_mean
)
}
usage
c
.
good
(
"
-
-
help
"
)
)
kind
:
ErrorKind
:
:
UnknownArgument
info
:
Some
(
vec
!
[
a
]
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
io_error
(
e
:
&
Error
color
:
fmt
:
:
ColorWhen
)
-
>
Self
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
color
}
;
Error
{
message
:
format
!
(
"
{
}
{
}
"
c
.
error
(
"
error
:
"
)
e
.
description
(
)
)
kind
:
ErrorKind
:
:
Io
info
:
None
}
}
#
[
doc
(
hidden
)
]
pub
fn
argument_not_found_auto
<
A
>
(
arg
:
A
)
-
>
Self
where
A
:
Into
<
String
>
{
let
a
=
arg
.
into
(
)
;
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
fmt
:
:
ColorWhen
:
:
Auto
}
;
Error
{
message
:
format
!
(
"
{
}
The
argument
'
{
}
'
wasn
'
t
found
"
c
.
error
(
"
error
:
"
)
a
.
clone
(
)
)
kind
:
ErrorKind
:
:
ArgumentNotFound
info
:
Some
(
vec
!
[
a
]
)
}
}
pub
fn
with_description
(
description
:
&
str
kind
:
ErrorKind
)
-
>
Self
{
let
c
=
fmt
:
:
Colorizer
{
use_stderr
:
true
when
:
fmt
:
:
ColorWhen
:
:
Auto
}
;
Error
{
message
:
format
!
(
"
{
}
{
}
"
c
.
error
(
"
error
:
"
)
description
)
kind
:
kind
info
:
None
}
}
}
impl
StdError
for
Error
{
fn
description
(
&
self
)
-
>
&
str
{
&
*
self
.
message
}
}
impl
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
std_fmt
:
:
Formatter
)
-
>
std_fmt
:
:
Result
{
writeln
!
(
f
"
{
}
"
self
.
message
)
}
}
impl
From
<
io
:
:
Error
>
for
Error
{
fn
from
(
e
:
io
:
:
Error
)
-
>
Self
{
Error
:
:
with_description
(
e
.
description
(
)
ErrorKind
:
:
Io
)
}
}
impl
From
<
std_fmt
:
:
Error
>
for
Error
{
fn
from
(
e
:
std_fmt
:
:
Error
)
-
>
Self
{
Error
:
:
with_description
(
e
.
description
(
)
ErrorKind
:
:
Format
)
}
}
