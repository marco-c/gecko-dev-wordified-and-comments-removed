use
super
:
:
*
;
pub
trait
Async
:
Interface
{
type
Output
:
Clone
;
type
CompletedHandler
:
Interface
;
fn
set_completed
<
F
:
Fn
(
&
Self
)
+
Send
+
'
static
>
(
&
self
handler
:
F
)
-
>
Result
<
(
)
>
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
invoke_completed
(
&
self
handler
:
&
Self
:
:
CompletedHandler
status
:
AsyncStatus
)
;
fn
get_results
(
&
self
)
-
>
Result
<
Self
:
:
Output
>
;
fn
status
(
&
self
)
-
>
Result
<
AsyncStatus
>
;
fn
join
(
&
self
)
-
>
Result
<
Self
:
:
Output
>
{
if
self
.
status
(
)
?
=
=
AsyncStatus
:
:
Started
{
let
(
_waiter
signaler
)
=
Waiter
:
:
new
(
)
?
;
self
.
set_completed
(
move
|
_
|
{
unsafe
{
signaler
.
signal
(
)
;
}
}
)
?
;
}
self
.
get_results
(
)
}
fn
when
<
F
>
(
&
self
op
:
F
)
-
>
Result
<
(
)
>
where
F
:
FnOnce
(
Result
<
Self
:
:
Output
>
)
+
Send
+
'
static
{
if
self
.
status
(
)
?
=
=
AsyncStatus
:
:
Started
{
let
op
=
core
:
:
cell
:
:
RefCell
:
:
new
(
Some
(
op
)
)
;
self
.
set_completed
(
move
|
sender
|
{
if
let
Some
(
op
)
=
op
.
take
(
)
{
op
(
sender
.
get_results
(
)
)
;
}
}
)
?
;
}
else
{
op
(
self
.
get_results
(
)
)
;
}
Ok
(
(
)
)
}
}
impl
Async
for
IAsyncAction
{
type
Output
=
(
)
;
type
CompletedHandler
=
AsyncActionCompletedHandler
;
fn
set_completed
<
F
:
Fn
(
&
Self
)
+
Send
+
'
static
>
(
&
self
handler
:
F
)
-
>
Result
<
(
)
>
{
self
.
SetCompleted
(
&
AsyncActionCompletedHandler
:
:
new
(
move
|
sender
_
|
{
handler
(
sender
.
ok
(
)
?
)
;
Ok
(
(
)
)
}
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
invoke_completed
(
&
self
handler
:
&
Self
:
:
CompletedHandler
status
:
AsyncStatus
)
{
_
=
handler
.
Invoke
(
self
status
)
;
}
fn
get_results
(
&
self
)
-
>
Result
<
Self
:
:
Output
>
{
self
.
GetResults
(
)
}
fn
status
(
&
self
)
-
>
Result
<
AsyncStatus
>
{
self
.
Status
(
)
}
}
impl
<
T
:
RuntimeType
>
Async
for
IAsyncOperation
<
T
>
{
type
Output
=
T
;
type
CompletedHandler
=
AsyncOperationCompletedHandler
<
T
>
;
fn
set_completed
<
F
:
Fn
(
&
Self
)
+
Send
+
'
static
>
(
&
self
handler
:
F
)
-
>
Result
<
(
)
>
{
self
.
SetCompleted
(
&
AsyncOperationCompletedHandler
:
:
new
(
move
|
sender
_
|
{
handler
(
sender
.
ok
(
)
?
)
;
Ok
(
(
)
)
}
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
invoke_completed
(
&
self
handler
:
&
Self
:
:
CompletedHandler
status
:
AsyncStatus
)
{
_
=
handler
.
Invoke
(
self
status
)
;
}
fn
get_results
(
&
self
)
-
>
Result
<
Self
:
:
Output
>
{
self
.
GetResults
(
)
}
fn
status
(
&
self
)
-
>
Result
<
AsyncStatus
>
{
self
.
Status
(
)
}
}
impl
<
P
:
RuntimeType
>
Async
for
IAsyncActionWithProgress
<
P
>
{
type
Output
=
(
)
;
type
CompletedHandler
=
AsyncActionWithProgressCompletedHandler
<
P
>
;
fn
set_completed
<
F
:
Fn
(
&
Self
)
+
Send
+
'
static
>
(
&
self
handler
:
F
)
-
>
Result
<
(
)
>
{
self
.
SetCompleted
(
&
AsyncActionWithProgressCompletedHandler
:
:
new
(
move
|
sender
_
|
{
handler
(
sender
.
ok
(
)
?
)
;
Ok
(
(
)
)
}
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
invoke_completed
(
&
self
handler
:
&
Self
:
:
CompletedHandler
status
:
AsyncStatus
)
{
_
=
handler
.
Invoke
(
self
status
)
;
}
fn
get_results
(
&
self
)
-
>
Result
<
Self
:
:
Output
>
{
self
.
GetResults
(
)
}
fn
status
(
&
self
)
-
>
Result
<
AsyncStatus
>
{
self
.
Status
(
)
}
}
impl
<
T
:
RuntimeType
P
:
RuntimeType
>
Async
for
IAsyncOperationWithProgress
<
T
P
>
{
type
Output
=
T
;
type
CompletedHandler
=
AsyncOperationWithProgressCompletedHandler
<
T
P
>
;
fn
set_completed
<
F
:
Fn
(
&
Self
)
+
Send
+
'
static
>
(
&
self
handler
:
F
)
-
>
Result
<
(
)
>
{
self
.
SetCompleted
(
&
AsyncOperationWithProgressCompletedHandler
:
:
new
(
move
|
sender
_
|
{
handler
(
sender
.
ok
(
)
?
)
;
Ok
(
(
)
)
}
)
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
invoke_completed
(
&
self
handler
:
&
Self
:
:
CompletedHandler
status
:
AsyncStatus
)
{
_
=
handler
.
Invoke
(
self
status
)
;
}
fn
get_results
(
&
self
)
-
>
Result
<
Self
:
:
Output
>
{
self
.
GetResults
(
)
}
fn
status
(
&
self
)
-
>
Result
<
AsyncStatus
>
{
self
.
Status
(
)
}
}
