use
crate
:
:
unicode
;
use
core
:
:
fmt
;
use
strck
:
:
{
Check
Ck
Invariant
}
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
RustIdent
;
pub
type
Ident
=
Ck
<
RustIdent
>
;
pub
type
IdentBuf
<
B
=
String
>
=
Check
<
RustIdent
B
>
;
#
[
derive
(
Debug
Copy
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
Error
{
Unicode
(
unicode
:
:
Error
)
Keyword
(
&
'
static
str
)
Wildcard
}
impl
std
:
:
error
:
:
Error
for
Error
{
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
Error
:
:
Unicode
(
err
)
=
>
err
.
fmt
(
f
)
Error
:
:
Keyword
(
keyword
)
=
>
{
write
!
(
f
"
Rust
keyword
:
'
{
keyword
}
'
"
)
}
Error
:
:
Wildcard
=
>
f
.
pad
(
"
wildcard
'
_
'
isn
'
t
a
valid
Rust
ident
"
)
}
}
}
impl
Invariant
for
RustIdent
{
type
Error
=
Error
;
fn
check
(
slice
:
&
str
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
match
unicode
:
:
UnicodeIdent
:
:
check
(
slice
)
{
Ok
(
(
)
)
=
>
match
KEYWORDS
.
binary_search
(
&
slice
)
{
Ok
(
index
)
=
>
Err
(
Error
:
:
Keyword
(
KEYWORDS
[
index
]
)
)
Err
(
_
)
=
>
Ok
(
(
)
)
}
Err
(
unicode
:
:
Error
:
:
Start
(
'
_
'
)
)
=
>
match
slice
.
len
(
)
{
1
=
>
Err
(
Error
:
:
Wildcard
)
_
=
>
Ok
(
(
)
)
}
Err
(
e
)
=
>
Err
(
Error
:
:
Unicode
(
e
)
)
}
}
}
static
KEYWORDS
:
[
&
str
;
51
]
=
[
"
Self
"
"
abstract
"
"
as
"
"
async
"
"
await
"
"
become
"
"
box
"
"
break
"
"
const
"
"
continue
"
"
crate
"
"
do
"
"
dyn
"
"
else
"
"
enum
"
"
extern
"
"
false
"
"
final
"
"
fn
"
"
for
"
"
if
"
"
impl
"
"
in
"
"
let
"
"
loop
"
"
macro
"
"
match
"
"
mod
"
"
move
"
"
mut
"
"
override
"
"
priv
"
"
pub
"
"
ref
"
"
return
"
"
self
"
"
static
"
"
struct
"
"
super
"
"
trait
"
"
true
"
"
try
"
"
type
"
"
typeof
"
"
unsafe
"
"
unsized
"
"
use
"
"
virtual
"
"
where
"
"
while
"
"
yield
"
]
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
Error
RustIdent
}
;
use
strck
:
:
IntoCk
;
#
[
test
]
fn
test_underscore
(
)
{
assert_eq
!
(
"
_
"
.
ck
:
:
<
RustIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Wildcard
)
;
assert
!
(
"
_unused
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
__private
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
snake_case
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
test_rust_reference
(
)
{
assert
!
(
"
foo
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
_identifier
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
"
.
ck
:
:
<
RustIdent
>
(
)
.
is_ok
(
)
)
;
}
}
