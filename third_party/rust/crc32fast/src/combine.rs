const
GF2_DIM
:
usize
=
32
;
fn
gf2_matrix_times
(
mat
:
&
[
u32
;
GF2_DIM
]
mut
vec
:
u32
)
-
>
u32
{
let
mut
sum
=
0
;
let
mut
idx
=
0
;
while
vec
>
0
{
if
vec
&
1
=
=
1
{
sum
^
=
mat
[
idx
]
;
}
vec
>
>
=
1
;
idx
+
=
1
;
}
return
sum
;
}
fn
gf2_matrix_square
(
square
:
&
mut
[
u32
;
GF2_DIM
]
mat
:
&
[
u32
;
GF2_DIM
]
)
{
for
n
in
0
.
.
GF2_DIM
{
square
[
n
]
=
gf2_matrix_times
(
mat
mat
[
n
]
)
;
}
}
pub
(
crate
)
fn
combine
(
mut
crc1
:
u32
crc2
:
u32
mut
len2
:
u64
)
-
>
u32
{
let
mut
row
:
u32
;
let
mut
even
=
[
0u32
;
GF2_DIM
]
;
let
mut
odd
=
[
0u32
;
GF2_DIM
]
;
if
len2
<
=
0
{
return
crc1
;
}
odd
[
0
]
=
0xedb88320
;
row
=
1
;
for
n
in
1
.
.
GF2_DIM
{
odd
[
n
]
=
row
;
row
<
<
=
1
;
}
gf2_matrix_square
(
&
mut
even
&
odd
)
;
gf2_matrix_square
(
&
mut
odd
&
even
)
;
loop
{
gf2_matrix_square
(
&
mut
even
&
odd
)
;
if
len2
&
1
=
=
1
{
crc1
=
gf2_matrix_times
(
&
even
crc1
)
;
}
len2
>
>
=
1
;
if
len2
=
=
0
{
break
;
}
gf2_matrix_square
(
&
mut
odd
&
even
)
;
if
len2
&
1
=
=
1
{
crc1
=
gf2_matrix_times
(
&
odd
crc1
)
;
}
len2
>
>
=
1
;
if
len2
=
=
0
{
break
;
}
}
crc1
^
=
crc2
;
return
crc1
;
}
