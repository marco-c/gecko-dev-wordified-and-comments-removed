use
crate
:
:
{
ComponentSection
ComponentSectionId
ComponentValType
Encode
encode_section
}
;
use
alloc
:
:
vec
:
:
Vec
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
CanonicalOption
{
UTF8
UTF16
CompactUTF16
Memory
(
u32
)
Realloc
(
u32
)
PostReturn
(
u32
)
Async
Callback
(
u32
)
CoreType
(
u32
)
Gc
}
impl
Encode
for
CanonicalOption
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
Self
:
:
UTF8
=
>
sink
.
push
(
0x00
)
Self
:
:
UTF16
=
>
sink
.
push
(
0x01
)
Self
:
:
CompactUTF16
=
>
sink
.
push
(
0x02
)
Self
:
:
Memory
(
idx
)
=
>
{
sink
.
push
(
0x03
)
;
idx
.
encode
(
sink
)
;
}
Self
:
:
Realloc
(
idx
)
=
>
{
sink
.
push
(
0x04
)
;
idx
.
encode
(
sink
)
;
}
Self
:
:
PostReturn
(
idx
)
=
>
{
sink
.
push
(
0x05
)
;
idx
.
encode
(
sink
)
;
}
Self
:
:
Async
=
>
{
sink
.
push
(
0x06
)
;
}
Self
:
:
Callback
(
idx
)
=
>
{
sink
.
push
(
0x07
)
;
idx
.
encode
(
sink
)
;
}
Self
:
:
CoreType
(
idx
)
=
>
{
sink
.
push
(
0x08
)
;
idx
.
encode
(
sink
)
;
}
Self
:
:
Gc
=
>
{
sink
.
push
(
0x09
)
;
}
}
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
CanonicalFunctionSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
CanonicalFunctionSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
lift
<
O
>
(
&
mut
self
core_func_index
:
u32
type_index
:
u32
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x00
)
;
self
.
bytes
.
push
(
0x00
)
;
core_func_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
encode_options
(
options
)
;
type_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
lower
<
O
>
(
&
mut
self
func_index
:
u32
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x01
)
;
self
.
bytes
.
push
(
0x00
)
;
func_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
resource_new
(
&
mut
self
ty_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
resource_drop
(
&
mut
self
ty_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x03
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
resource_drop_async
(
&
mut
self
ty_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x07
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
resource_rep
(
&
mut
self
ty_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x04
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_spawn_ref
(
&
mut
self
ty_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x40
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_spawn_indirect
(
&
mut
self
ty_index
:
u32
table_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x41
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
table_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_available_parallelism
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x42
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
backpressure_set
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x08
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
backpressure_inc
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x24
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
backpressure_dec
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x25
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
task_return
<
O
>
(
&
mut
self
ty
:
Option
<
ComponentValType
>
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x09
)
;
crate
:
:
encode_resultlist
(
&
mut
self
.
bytes
ty
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
task_cancel
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x05
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
context_get
(
&
mut
self
i
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x0a
)
;
self
.
bytes
.
push
(
0x7f
)
;
i
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
context_set
(
&
mut
self
i
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x0b
)
;
self
.
bytes
.
push
(
0x7f
)
;
i
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_yield
(
&
mut
self
cancellable
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x0c
)
;
self
.
bytes
.
push
(
if
cancellable
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
subtask_drop
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x0d
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
subtask_cancel
(
&
mut
self
async_
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x06
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_new
(
&
mut
self
ty
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x0e
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_read
<
O
>
(
&
mut
self
ty
:
u32
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x0f
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_write
<
O
>
(
&
mut
self
ty
:
u32
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x10
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_cancel_read
(
&
mut
self
ty
:
u32
async_
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x11
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_cancel_write
(
&
mut
self
ty
:
u32
async_
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x12
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_drop_readable
(
&
mut
self
ty
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x13
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
stream_drop_writable
(
&
mut
self
ty
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x14
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_new
(
&
mut
self
ty
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x15
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_read
<
O
>
(
&
mut
self
ty
:
u32
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x16
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_write
<
O
>
(
&
mut
self
ty
:
u32
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x17
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_cancel_read
(
&
mut
self
ty
:
u32
async_
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x18
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_cancel_write
(
&
mut
self
ty
:
u32
async_
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x19
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_drop_readable
(
&
mut
self
ty
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x1a
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
future_drop_writable
(
&
mut
self
ty
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x1b
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
error_context_new
<
O
>
(
&
mut
self
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x1c
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
error_context_debug_message
<
O
>
(
&
mut
self
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
self
.
bytes
.
push
(
0x1d
)
;
self
.
encode_options
(
options
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
error_context_drop
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x1e
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
waitable_set_new
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x1f
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
waitable_set_wait
(
&
mut
self
async_
:
bool
memory
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x20
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
memory
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
waitable_set_poll
(
&
mut
self
async_
:
bool
memory
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x21
)
;
self
.
bytes
.
push
(
if
async_
{
1
}
else
{
0
}
)
;
memory
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
waitable_set_drop
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x22
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
waitable_join
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x23
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_index
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x26
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_new_indirect
(
&
mut
self
ty_index
:
u32
table_index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x27
)
;
ty_index
.
encode
(
&
mut
self
.
bytes
)
;
table_index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_switch_to
(
&
mut
self
cancellable
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x28
)
;
self
.
bytes
.
push
(
if
cancellable
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_suspend
(
&
mut
self
cancellable
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x29
)
;
self
.
bytes
.
push
(
if
cancellable
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_resume_later
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x2a
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
thread_yield_to
(
&
mut
self
cancellable
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x2b
)
;
self
.
bytes
.
push
(
if
cancellable
{
1
}
else
{
0
}
)
;
self
.
num_added
+
=
1
;
self
}
fn
encode_options
<
O
>
(
&
mut
self
options
:
O
)
-
>
&
mut
Self
where
O
:
IntoIterator
<
Item
=
CanonicalOption
>
O
:
:
IntoIter
:
ExactSizeIterator
{
let
options
=
options
.
into_iter
(
)
;
options
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
for
option
in
options
{
option
.
encode
(
&
mut
self
.
bytes
)
;
}
self
}
}
impl
Encode
for
CanonicalFunctionSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
CanonicalFunctionSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
CanonicalFunction
.
into
(
)
}
}
