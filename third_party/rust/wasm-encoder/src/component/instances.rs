use
super
:
:
CORE_INSTANCE_SORT
;
use
crate
:
:
{
encode_section
ComponentExportKind
ComponentSection
ComponentSectionId
Encode
ExportKind
}
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
ModuleArg
{
Instance
(
u32
)
}
impl
Encode
for
ModuleArg
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
let
(
sort
idx
)
=
match
self
{
Self
:
:
Instance
(
idx
)
=
>
(
CORE_INSTANCE_SORT
*
idx
)
}
;
sink
.
push
(
sort
)
;
idx
.
encode
(
sink
)
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
InstanceSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
InstanceSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
instantiate
<
'
a
A
>
(
&
mut
self
module_index
:
u32
args
:
A
)
-
>
&
mut
Self
where
A
:
IntoIterator
<
Item
=
(
&
'
a
str
ModuleArg
)
>
A
:
:
IntoIter
:
ExactSizeIterator
{
let
args
=
args
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x00
)
;
module_index
.
encode
(
&
mut
self
.
bytes
)
;
args
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
for
(
name
arg
)
in
args
{
name
.
encode
(
&
mut
self
.
bytes
)
;
arg
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
fn
export_items
<
'
a
E
>
(
&
mut
self
exports
:
E
)
-
>
&
mut
Self
where
E
:
IntoIterator
<
Item
=
(
&
'
a
str
ExportKind
u32
)
>
E
:
:
IntoIter
:
ExactSizeIterator
{
let
exports
=
exports
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x01
)
;
exports
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
for
(
name
kind
index
)
in
exports
{
name
.
encode
(
&
mut
self
.
bytes
)
;
kind
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
}
impl
Encode
for
InstanceSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
InstanceSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
CoreInstance
.
into
(
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
ComponentInstanceSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
ComponentInstanceSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
instantiate
<
'
a
A
>
(
&
mut
self
component_index
:
u32
args
:
A
)
-
>
&
mut
Self
where
A
:
IntoIterator
<
Item
=
(
&
'
a
str
ComponentExportKind
u32
)
>
A
:
:
IntoIter
:
ExactSizeIterator
{
let
args
=
args
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x00
)
;
component_index
.
encode
(
&
mut
self
.
bytes
)
;
args
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
for
(
name
kind
index
)
in
args
{
name
.
encode
(
&
mut
self
.
bytes
)
;
kind
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
fn
export_items
<
'
a
E
>
(
&
mut
self
exports
:
E
)
-
>
&
mut
Self
where
E
:
IntoIterator
<
Item
=
(
&
'
a
str
ComponentExportKind
u32
)
>
E
:
:
IntoIter
:
ExactSizeIterator
{
let
exports
=
exports
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x01
)
;
exports
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
for
(
name
kind
index
)
in
exports
{
name
.
encode
(
&
mut
self
.
bytes
)
;
kind
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
}
impl
Encode
for
ComponentInstanceSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
ComponentInstanceSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
Instance
.
into
(
)
}
}
