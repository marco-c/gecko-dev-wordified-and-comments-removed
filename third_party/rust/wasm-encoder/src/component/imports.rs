use
crate
:
:
{
encode_section
ComponentExportKind
ComponentSection
ComponentSectionId
ComponentValType
Encode
}
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
pub
enum
TypeBounds
{
Eq
(
u32
)
SubResource
}
impl
Encode
for
TypeBounds
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
Self
:
:
Eq
(
i
)
=
>
{
sink
.
push
(
0x00
)
;
i
.
encode
(
sink
)
;
}
Self
:
:
SubResource
=
>
sink
.
push
(
0x01
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
pub
enum
ComponentTypeRef
{
Module
(
u32
)
Func
(
u32
)
Value
(
ComponentValType
)
Type
(
TypeBounds
)
Instance
(
u32
)
Component
(
u32
)
}
impl
ComponentTypeRef
{
pub
fn
kind
(
&
self
)
-
>
ComponentExportKind
{
match
self
{
Self
:
:
Module
(
_
)
=
>
ComponentExportKind
:
:
Module
Self
:
:
Func
(
_
)
=
>
ComponentExportKind
:
:
Func
Self
:
:
Value
(
_
)
=
>
ComponentExportKind
:
:
Value
Self
:
:
Type
(
.
.
)
=
>
ComponentExportKind
:
:
Type
Self
:
:
Instance
(
_
)
=
>
ComponentExportKind
:
:
Instance
Self
:
:
Component
(
_
)
=
>
ComponentExportKind
:
:
Component
}
}
}
impl
Encode
for
ComponentTypeRef
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
self
.
kind
(
)
.
encode
(
sink
)
;
match
self
{
Self
:
:
Module
(
idx
)
|
Self
:
:
Func
(
idx
)
|
Self
:
:
Instance
(
idx
)
|
Self
:
:
Component
(
idx
)
=
>
{
idx
.
encode
(
sink
)
;
}
Self
:
:
Value
(
ty
)
=
>
ty
.
encode
(
sink
)
Self
:
:
Type
(
bounds
)
=
>
bounds
.
encode
(
sink
)
}
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
ComponentImportSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
ComponentImportSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
import
(
&
mut
self
name
:
impl
AsComponentExternName
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
name
.
as_component_extern_name
(
)
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
}
impl
Encode
for
ComponentImportSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
ComponentImportSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
Import
.
into
(
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
ComponentExternName
<
'
a
>
{
Kebab
(
&
'
a
str
)
Interface
(
&
'
a
str
)
}
impl
Encode
for
ComponentExternName
<
'
_
>
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
ComponentExternName
:
:
Kebab
(
name
)
=
>
{
sink
.
push
(
0x00
)
;
name
.
encode
(
sink
)
;
}
ComponentExternName
:
:
Interface
(
name
)
=
>
{
sink
.
push
(
0x01
)
;
name
.
encode
(
sink
)
;
}
}
}
}
pub
trait
AsComponentExternName
{
fn
as_component_extern_name
(
&
self
)
-
>
ComponentExternName
<
'
_
>
;
}
impl
AsComponentExternName
for
ComponentExternName
<
'
_
>
{
fn
as_component_extern_name
(
&
self
)
-
>
ComponentExternName
<
'
_
>
{
*
self
}
}
impl
<
S
:
AsRef
<
str
>
>
AsComponentExternName
for
S
{
fn
as_component_extern_name
(
&
self
)
-
>
ComponentExternName
<
'
_
>
{
let
s
=
self
.
as_ref
(
)
;
if
s
.
contains
(
"
/
"
)
{
ComponentExternName
:
:
Interface
(
s
)
}
else
{
ComponentExternName
:
:
Kebab
(
s
)
}
}
}
