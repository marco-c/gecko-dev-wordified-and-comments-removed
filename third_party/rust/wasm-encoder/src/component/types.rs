use
super
:
:
CORE_TYPE_SORT
;
use
crate
:
:
{
Alias
ComponentExportKind
ComponentOuterAliasKind
ComponentSection
ComponentSectionId
ComponentTypeRef
CoreTypeEncoder
Encode
EntityType
ValType
encode_section
}
;
use
alloc
:
:
vec
:
:
Vec
;
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
ModuleType
{
bytes
:
Vec
<
u8
>
num_added
:
u32
types_added
:
u32
}
impl
ModuleType
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
import
(
&
mut
self
module
:
&
str
name
:
&
str
ty
:
EntityType
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x00
)
;
module
.
encode
(
&
mut
self
.
bytes
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
CoreTypeEncoder
<
'
_
>
{
self
.
bytes
.
push
(
0x01
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
CoreTypeEncoder
{
push_prefix_if_component_core_type
:
false
bytes
:
&
mut
self
.
bytes
}
}
pub
fn
alias_outer_core_type
(
&
mut
self
count
:
u32
index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
self
.
bytes
.
push
(
CORE_TYPE_SORT
)
;
self
.
bytes
.
push
(
0x01
)
;
count
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
self
}
pub
fn
export
(
&
mut
self
name
:
&
str
ty
:
EntityType
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x03
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
type_count
(
&
self
)
-
>
u32
{
self
.
types_added
}
}
impl
Encode
for
ModuleType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
0x50
)
;
self
.
num_added
.
encode
(
sink
)
;
sink
.
extend
(
&
self
.
bytes
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentCoreTypeEncoder
<
'
a
>
(
pub
(
crate
)
&
'
a
mut
Vec
<
u8
>
)
;
impl
<
'
a
>
ComponentCoreTypeEncoder
<
'
a
>
{
pub
fn
module
(
self
ty
:
&
ModuleType
)
{
ty
.
encode
(
self
.
0
)
;
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
core
(
self
)
-
>
CoreTypeEncoder
<
'
a
>
{
CoreTypeEncoder
{
bytes
:
self
.
0
push_prefix_if_component_core_type
:
true
}
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
CoreTypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
CoreTypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentCoreTypeEncoder
<
'
_
>
{
self
.
num_added
+
=
1
;
ComponentCoreTypeEncoder
(
&
mut
self
.
bytes
)
}
}
impl
Encode
for
CoreTypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
CoreTypeSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
CoreType
.
into
(
)
}
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
ComponentType
{
bytes
:
Vec
<
u8
>
num_added
:
u32
core_types_added
:
u32
types_added
:
u32
instances_added
:
u32
}
impl
ComponentType
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
core_type
(
&
mut
self
)
-
>
ComponentCoreTypeEncoder
<
'
_
>
{
self
.
bytes
.
push
(
0x00
)
;
self
.
num_added
+
=
1
;
self
.
core_types_added
+
=
1
;
ComponentCoreTypeEncoder
(
&
mut
self
.
bytes
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentTypeEncoder
<
'
_
>
{
self
.
bytes
.
push
(
0x01
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
ComponentTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
alias
(
&
mut
self
alias
:
Alias
<
'
_
>
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
alias
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
match
&
alias
{
Alias
:
:
InstanceExport
{
kind
:
ComponentExportKind
:
:
Type
.
.
}
|
Alias
:
:
Outer
{
kind
:
ComponentOuterAliasKind
:
:
Type
.
.
}
=
>
self
.
types_added
+
=
1
Alias
:
:
Outer
{
kind
:
ComponentOuterAliasKind
:
:
CoreType
.
.
}
=
>
self
.
core_types_added
+
=
1
Alias
:
:
InstanceExport
{
kind
:
ComponentExportKind
:
:
Instance
.
.
}
=
>
self
.
instances_added
+
=
1
_
=
>
{
}
}
self
}
pub
fn
import
(
&
mut
self
name
:
&
str
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x03
)
;
crate
:
:
encode_component_import_name
(
&
mut
self
.
bytes
name
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
match
ty
{
ComponentTypeRef
:
:
Type
(
.
.
)
=
>
self
.
types_added
+
=
1
ComponentTypeRef
:
:
Instance
(
.
.
)
=
>
self
.
instances_added
+
=
1
_
=
>
{
}
}
self
}
pub
fn
export
(
&
mut
self
name
:
&
str
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x04
)
;
crate
:
:
encode_component_export_name
(
&
mut
self
.
bytes
name
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
match
ty
{
ComponentTypeRef
:
:
Type
(
.
.
)
=
>
self
.
types_added
+
=
1
ComponentTypeRef
:
:
Instance
(
.
.
)
=
>
self
.
instances_added
+
=
1
_
=
>
{
}
}
self
}
pub
fn
core_type_count
(
&
self
)
-
>
u32
{
self
.
core_types_added
}
pub
fn
type_count
(
&
self
)
-
>
u32
{
self
.
types_added
}
pub
fn
instance_count
(
&
self
)
-
>
u32
{
self
.
instances_added
}
}
impl
Encode
for
ComponentType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
0x41
)
;
self
.
num_added
.
encode
(
sink
)
;
sink
.
extend
(
&
self
.
bytes
)
;
}
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
InstanceType
(
ComponentType
)
;
impl
InstanceType
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
core_type
(
&
mut
self
)
-
>
ComponentCoreTypeEncoder
<
'
_
>
{
self
.
0
.
core_type
(
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentTypeEncoder
<
'
_
>
{
self
.
0
.
ty
(
)
}
pub
fn
alias
(
&
mut
self
alias
:
Alias
<
'
_
>
)
-
>
&
mut
Self
{
self
.
0
.
alias
(
alias
)
;
self
}
pub
fn
export
(
&
mut
self
name
:
&
str
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
self
.
0
.
export
(
name
ty
)
;
self
}
pub
fn
core_type_count
(
&
self
)
-
>
u32
{
self
.
0
.
core_types_added
}
pub
fn
type_count
(
&
self
)
-
>
u32
{
self
.
0
.
types_added
}
pub
fn
instance_count
(
&
self
)
-
>
u32
{
self
.
0
.
instances_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
num_added
=
=
0
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
0
.
num_added
}
}
impl
Encode
for
InstanceType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
0x42
)
;
self
.
0
.
num_added
.
encode
(
sink
)
;
sink
.
extend
(
&
self
.
0
.
bytes
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentFuncTypeEncoder
<
'
a
>
{
async_encoded
:
bool
params_encoded
:
bool
results_encoded
:
bool
sink
:
&
'
a
mut
Vec
<
u8
>
}
impl
<
'
a
>
ComponentFuncTypeEncoder
<
'
a
>
{
fn
new
(
sink
:
&
'
a
mut
Vec
<
u8
>
)
-
>
Self
{
Self
{
async_encoded
:
false
params_encoded
:
false
results_encoded
:
false
sink
}
}
pub
fn
async_
(
&
mut
self
is_async
:
bool
)
-
>
&
mut
Self
{
assert
!
(
!
self
.
params_encoded
)
;
assert
!
(
!
self
.
results_encoded
)
;
assert
!
(
!
self
.
async_encoded
)
;
self
.
async_encoded
=
true
;
if
is_async
{
self
.
sink
.
push
(
0x43
)
;
}
else
{
self
.
sink
.
push
(
0x40
)
;
}
self
}
pub
fn
params
<
'
b
P
T
>
(
&
mut
self
params
:
P
)
-
>
&
mut
Self
where
P
:
IntoIterator
<
Item
=
(
&
'
b
str
T
)
>
P
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
assert
!
(
!
self
.
params_encoded
)
;
if
!
self
.
async_encoded
{
self
.
async_
(
false
)
;
}
self
.
params_encoded
=
true
;
let
params
=
params
.
into_iter
(
)
;
params
.
len
(
)
.
encode
(
self
.
sink
)
;
for
(
name
ty
)
in
params
{
name
.
encode
(
self
.
sink
)
;
ty
.
into
(
)
.
encode
(
self
.
sink
)
;
}
self
}
pub
fn
result
(
&
mut
self
ty
:
Option
<
ComponentValType
>
)
-
>
&
mut
Self
{
assert
!
(
self
.
async_encoded
)
;
assert
!
(
self
.
params_encoded
)
;
assert
!
(
!
self
.
results_encoded
)
;
self
.
results_encoded
=
true
;
encode_resultlist
(
self
.
sink
ty
)
;
self
}
}
pub
(
crate
)
fn
encode_resultlist
(
sink
:
&
mut
Vec
<
u8
>
ty
:
Option
<
ComponentValType
>
)
{
match
ty
{
Some
(
ty
)
=
>
{
sink
.
push
(
0x00
)
;
ty
.
encode
(
sink
)
;
}
None
=
>
{
sink
.
push
(
0x01
)
;
sink
.
push
(
0x00
)
;
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentTypeEncoder
<
'
a
>
(
&
'
a
mut
Vec
<
u8
>
)
;
impl
<
'
a
>
ComponentTypeEncoder
<
'
a
>
{
pub
fn
component
(
self
ty
:
&
ComponentType
)
{
ty
.
encode
(
self
.
0
)
;
}
pub
fn
instance
(
self
ty
:
&
InstanceType
)
{
ty
.
encode
(
self
.
0
)
;
}
pub
fn
function
(
self
)
-
>
ComponentFuncTypeEncoder
<
'
a
>
{
ComponentFuncTypeEncoder
:
:
new
(
self
.
0
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
defined_type
(
self
)
-
>
ComponentDefinedTypeEncoder
<
'
a
>
{
ComponentDefinedTypeEncoder
(
self
.
0
)
}
pub
fn
resource
(
self
rep
:
ValType
dtor
:
Option
<
u32
>
)
{
self
.
0
.
push
(
0x3f
)
;
rep
.
encode
(
self
.
0
)
;
match
dtor
{
Some
(
i
)
=
>
{
self
.
0
.
push
(
0x01
)
;
i
.
encode
(
self
.
0
)
;
}
None
=
>
self
.
0
.
push
(
0x00
)
}
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
enum
PrimitiveValType
{
Bool
S8
U8
S16
U16
S32
U32
S64
U64
F32
F64
Char
String
ErrorContext
}
impl
Encode
for
PrimitiveValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
match
self
{
Self
:
:
Bool
=
>
0x7f
Self
:
:
S8
=
>
0x7e
Self
:
:
U8
=
>
0x7d
Self
:
:
S16
=
>
0x7c
Self
:
:
U16
=
>
0x7b
Self
:
:
S32
=
>
0x7a
Self
:
:
U32
=
>
0x79
Self
:
:
S64
=
>
0x78
Self
:
:
U64
=
>
0x77
Self
:
:
F32
=
>
0x76
Self
:
:
F64
=
>
0x75
Self
:
:
Char
=
>
0x74
Self
:
:
String
=
>
0x73
Self
:
:
ErrorContext
=
>
0x64
}
)
;
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
enum
ComponentValType
{
Primitive
(
PrimitiveValType
)
Type
(
u32
)
}
impl
Encode
for
ComponentValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
ty
.
encode
(
sink
)
Self
:
:
Type
(
index
)
=
>
(
*
index
as
i64
)
.
encode
(
sink
)
}
}
}
impl
From
<
PrimitiveValType
>
for
ComponentValType
{
fn
from
(
ty
:
PrimitiveValType
)
-
>
Self
{
Self
:
:
Primitive
(
ty
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentDefinedTypeEncoder
<
'
a
>
(
&
'
a
mut
Vec
<
u8
>
)
;
impl
ComponentDefinedTypeEncoder
<
'
_
>
{
pub
fn
primitive
(
self
ty
:
PrimitiveValType
)
{
ty
.
encode
(
self
.
0
)
;
}
pub
fn
record
<
'
a
F
T
>
(
self
fields
:
F
)
where
F
:
IntoIterator
<
Item
=
(
&
'
a
str
T
)
>
F
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
fields
=
fields
.
into_iter
(
)
;
self
.
0
.
push
(
0x72
)
;
fields
.
len
(
)
.
encode
(
self
.
0
)
;
for
(
name
ty
)
in
fields
{
name
.
encode
(
self
.
0
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
}
pub
fn
variant
<
'
a
C
>
(
self
cases
:
C
)
where
C
:
IntoIterator
<
Item
=
(
&
'
a
str
Option
<
ComponentValType
>
Option
<
u32
>
)
>
C
:
:
IntoIter
:
ExactSizeIterator
{
let
cases
=
cases
.
into_iter
(
)
;
self
.
0
.
push
(
0x71
)
;
cases
.
len
(
)
.
encode
(
self
.
0
)
;
for
(
name
ty
refines
)
in
cases
{
name
.
encode
(
self
.
0
)
;
ty
.
encode
(
self
.
0
)
;
refines
.
encode
(
self
.
0
)
;
}
}
pub
fn
list
(
self
ty
:
impl
Into
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x70
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
pub
fn
fixed_size_list
(
self
ty
:
impl
Into
<
ComponentValType
>
elements
:
u32
)
{
self
.
0
.
push
(
0x67
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
elements
.
encode
(
self
.
0
)
;
}
pub
fn
tuple
<
I
T
>
(
self
types
:
I
)
where
I
:
IntoIterator
<
Item
=
T
>
I
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
types
=
types
.
into_iter
(
)
;
self
.
0
.
push
(
0x6F
)
;
types
.
len
(
)
.
encode
(
self
.
0
)
;
for
ty
in
types
{
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
}
pub
fn
flags
<
'
a
I
>
(
self
names
:
I
)
where
I
:
IntoIterator
<
Item
=
&
'
a
str
>
I
:
:
IntoIter
:
ExactSizeIterator
{
let
names
=
names
.
into_iter
(
)
;
self
.
0
.
push
(
0x6E
)
;
names
.
len
(
)
.
encode
(
self
.
0
)
;
for
name
in
names
{
name
.
encode
(
self
.
0
)
;
}
}
pub
fn
enum_type
<
'
a
I
>
(
self
tags
:
I
)
where
I
:
IntoIterator
<
Item
=
&
'
a
str
>
I
:
:
IntoIter
:
ExactSizeIterator
{
let
tags
=
tags
.
into_iter
(
)
;
self
.
0
.
push
(
0x6D
)
;
tags
.
len
(
)
.
encode
(
self
.
0
)
;
for
tag
in
tags
{
tag
.
encode
(
self
.
0
)
;
}
}
pub
fn
option
(
self
ty
:
impl
Into
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x6B
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
pub
fn
result
(
self
ok
:
Option
<
ComponentValType
>
err
:
Option
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x6A
)
;
ok
.
encode
(
self
.
0
)
;
err
.
encode
(
self
.
0
)
;
}
pub
fn
own
(
self
idx
:
u32
)
{
self
.
0
.
push
(
0x69
)
;
idx
.
encode
(
self
.
0
)
;
}
pub
fn
borrow
(
self
idx
:
u32
)
{
self
.
0
.
push
(
0x68
)
;
idx
.
encode
(
self
.
0
)
;
}
pub
fn
future
(
self
payload
:
Option
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x65
)
;
payload
.
encode
(
self
.
0
)
;
}
pub
fn
stream
(
self
payload
:
Option
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x66
)
;
payload
.
encode
(
self
.
0
)
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
ComponentTypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
ComponentTypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentTypeEncoder
<
'
_
>
{
self
.
num_added
+
=
1
;
ComponentTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
component
(
&
mut
self
ty
:
&
ComponentType
)
-
>
&
mut
Self
{
self
.
ty
(
)
.
component
(
ty
)
;
self
}
pub
fn
instance
(
&
mut
self
ty
:
&
InstanceType
)
-
>
&
mut
Self
{
self
.
ty
(
)
.
instance
(
ty
)
;
self
}
pub
fn
function
(
&
mut
self
)
-
>
ComponentFuncTypeEncoder
<
'
_
>
{
self
.
ty
(
)
.
function
(
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
defined_type
(
&
mut
self
)
-
>
ComponentDefinedTypeEncoder
<
'
_
>
{
self
.
ty
(
)
.
defined_type
(
)
}
pub
fn
resource
(
&
mut
self
rep
:
ValType
dtor
:
Option
<
u32
>
)
-
>
&
mut
Self
{
self
.
ty
(
)
.
resource
(
rep
dtor
)
;
self
}
}
impl
Encode
for
ComponentTypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
ComponentTypeSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
Type
.
into
(
)
}
}
