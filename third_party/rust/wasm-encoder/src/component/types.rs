use
crate
:
:
{
encode_section
ComponentOuterAliasKind
ComponentSection
ComponentSectionId
ComponentTypeRef
CoreOuterAliasKind
Encode
EntityType
ValType
}
;
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
ModuleType
{
bytes
:
Vec
<
u8
>
num_added
:
u32
types_added
:
u32
}
impl
ModuleType
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
alias_outer_core_type
(
&
mut
self
count
:
u32
index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
CoreOuterAliasKind
:
:
Type
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
0x01
)
;
count
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
self
}
pub
fn
import
(
&
mut
self
module
:
&
str
name
:
&
str
ty
:
EntityType
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x00
)
;
module
.
encode
(
&
mut
self
.
bytes
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
CoreTypeEncoder
{
self
.
bytes
.
push
(
0x01
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
CoreTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
export
(
&
mut
self
name
:
&
str
ty
:
EntityType
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x03
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
type_count
(
&
self
)
-
>
u32
{
self
.
types_added
}
}
impl
Encode
for
ModuleType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
0x50
)
;
self
.
num_added
.
encode
(
sink
)
;
sink
.
extend
(
&
self
.
bytes
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
CoreTypeEncoder
<
'
a
>
(
pub
(
crate
)
&
'
a
mut
Vec
<
u8
>
)
;
impl
<
'
a
>
CoreTypeEncoder
<
'
a
>
{
pub
fn
function
<
P
R
>
(
self
params
:
P
results
:
R
)
where
P
:
IntoIterator
<
Item
=
ValType
>
P
:
:
IntoIter
:
ExactSizeIterator
R
:
IntoIterator
<
Item
=
ValType
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
params
=
params
.
into_iter
(
)
;
let
results
=
results
.
into_iter
(
)
;
self
.
0
.
push
(
0x60
)
;
params
.
len
(
)
.
encode
(
self
.
0
)
;
self
.
0
.
extend
(
params
.
map
(
u8
:
:
from
)
)
;
results
.
len
(
)
.
encode
(
self
.
0
)
;
self
.
0
.
extend
(
results
.
map
(
u8
:
:
from
)
)
;
}
pub
fn
module
(
self
ty
:
&
ModuleType
)
{
ty
.
encode
(
self
.
0
)
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
CoreTypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
CoreTypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
CoreTypeEncoder
<
'
_
>
{
self
.
num_added
+
=
1
;
CoreTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
function
<
P
R
>
(
&
mut
self
params
:
P
results
:
R
)
-
>
&
mut
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
P
:
:
IntoIter
:
ExactSizeIterator
R
:
IntoIterator
<
Item
=
ValType
>
R
:
:
IntoIter
:
ExactSizeIterator
{
self
.
ty
(
)
.
function
(
params
results
)
;
self
}
pub
fn
module
(
&
mut
self
ty
:
&
ModuleType
)
-
>
&
mut
Self
{
self
.
ty
(
)
.
module
(
ty
)
;
self
}
}
impl
Encode
for
CoreTypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
CoreTypeSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
CoreType
.
into
(
)
}
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
ComponentType
{
bytes
:
Vec
<
u8
>
num_added
:
u32
core_types_added
:
u32
types_added
:
u32
}
impl
ComponentType
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
core_type
(
&
mut
self
)
-
>
CoreTypeEncoder
{
self
.
bytes
.
push
(
0x00
)
;
self
.
num_added
+
=
1
;
self
.
core_types_added
+
=
1
;
CoreTypeEncoder
(
&
mut
self
.
bytes
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentTypeEncoder
{
self
.
bytes
.
push
(
0x01
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
ComponentTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
alias_outer_core_type
(
&
mut
self
count
:
u32
index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
ComponentOuterAliasKind
:
:
CoreType
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
0x01
)
;
count
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
self
}
pub
fn
alias_outer_type
(
&
mut
self
count
:
u32
index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
ComponentOuterAliasKind
:
:
Type
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
0x01
)
;
count
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
self
}
pub
fn
import
(
&
mut
self
name
:
&
str
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x03
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
export
(
&
mut
self
name
:
&
str
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x04
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
core_type_count
(
&
self
)
-
>
u32
{
self
.
core_types_added
}
pub
fn
type_count
(
&
self
)
-
>
u32
{
self
.
types_added
}
}
impl
Encode
for
ComponentType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
0x41
)
;
self
.
num_added
.
encode
(
sink
)
;
sink
.
extend
(
&
self
.
bytes
)
;
}
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
InstanceType
{
bytes
:
Vec
<
u8
>
num_added
:
u32
core_types_added
:
u32
types_added
:
u32
}
impl
InstanceType
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
core_type
(
&
mut
self
)
-
>
CoreTypeEncoder
{
self
.
bytes
.
push
(
0x00
)
;
self
.
num_added
+
=
1
;
self
.
core_types_added
+
=
1
;
CoreTypeEncoder
(
&
mut
self
.
bytes
)
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentTypeEncoder
{
self
.
bytes
.
push
(
0x01
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
ComponentTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
alias_outer_core_type
(
&
mut
self
count
:
u32
index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
ComponentOuterAliasKind
:
:
CoreType
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
0x01
)
;
count
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
self
}
pub
fn
alias_outer_type
(
&
mut
self
count
:
u32
index
:
u32
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x02
)
;
ComponentOuterAliasKind
:
:
Type
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
0x01
)
;
count
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
.
types_added
+
=
1
;
self
}
pub
fn
export
(
&
mut
self
name
:
&
str
ty
:
ComponentTypeRef
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x04
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
core_type_count
(
&
self
)
-
>
u32
{
self
.
core_types_added
}
pub
fn
type_count
(
&
self
)
-
>
u32
{
self
.
types_added
}
}
impl
Encode
for
InstanceType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
0x42
)
;
self
.
num_added
.
encode
(
sink
)
;
sink
.
extend
(
&
self
.
bytes
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentTypeEncoder
<
'
a
>
(
&
'
a
mut
Vec
<
u8
>
)
;
impl
<
'
a
>
ComponentTypeEncoder
<
'
a
>
{
pub
fn
component
(
self
ty
:
&
ComponentType
)
{
ty
.
encode
(
self
.
0
)
;
}
pub
fn
instance
(
self
ty
:
&
InstanceType
)
{
ty
.
encode
(
self
.
0
)
;
}
pub
fn
function
<
'
b
P
T
>
(
self
params
:
P
result
:
impl
Into
<
ComponentValType
>
)
where
P
:
IntoIterator
<
Item
=
(
Option
<
&
'
b
str
>
T
)
>
P
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
params
=
params
.
into_iter
(
)
;
self
.
0
.
push
(
0x40
)
;
params
.
len
(
)
.
encode
(
self
.
0
)
;
for
(
name
ty
)
in
params
{
match
name
{
Some
(
name
)
=
>
{
self
.
0
.
push
(
0x01
)
;
name
.
encode
(
self
.
0
)
;
}
None
=
>
self
.
0
.
push
(
0x00
)
}
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
result
.
into
(
)
.
encode
(
self
.
0
)
;
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
defined_type
(
self
)
-
>
ComponentDefinedTypeEncoder
<
'
a
>
{
ComponentDefinedTypeEncoder
(
self
.
0
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
enum
PrimitiveValType
{
Unit
Bool
S8
U8
S16
U16
S32
U32
S64
U64
Float32
Float64
Char
String
}
impl
Encode
for
PrimitiveValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
match
self
{
Self
:
:
Unit
=
>
0x7f
Self
:
:
Bool
=
>
0x7e
Self
:
:
S8
=
>
0x7d
Self
:
:
U8
=
>
0x7c
Self
:
:
S16
=
>
0x7b
Self
:
:
U16
=
>
0x7a
Self
:
:
S32
=
>
0x79
Self
:
:
U32
=
>
0x78
Self
:
:
S64
=
>
0x77
Self
:
:
U64
=
>
0x76
Self
:
:
Float32
=
>
0x75
Self
:
:
Float64
=
>
0x74
Self
:
:
Char
=
>
0x73
Self
:
:
String
=
>
0x72
}
)
;
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
enum
ComponentValType
{
Primitive
(
PrimitiveValType
)
Type
(
u32
)
}
impl
Encode
for
ComponentValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
Self
:
:
Primitive
(
ty
)
=
>
ty
.
encode
(
sink
)
Self
:
:
Type
(
index
)
=
>
(
*
index
as
i64
)
.
encode
(
sink
)
}
}
}
impl
From
<
PrimitiveValType
>
for
ComponentValType
{
fn
from
(
ty
:
PrimitiveValType
)
-
>
Self
{
Self
:
:
Primitive
(
ty
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ComponentDefinedTypeEncoder
<
'
a
>
(
&
'
a
mut
Vec
<
u8
>
)
;
impl
ComponentDefinedTypeEncoder
<
'
_
>
{
pub
fn
primitive
(
self
ty
:
PrimitiveValType
)
{
ty
.
encode
(
self
.
0
)
;
}
pub
fn
record
<
'
a
F
T
>
(
self
fields
:
F
)
where
F
:
IntoIterator
<
Item
=
(
&
'
a
str
T
)
>
F
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
fields
=
fields
.
into_iter
(
)
;
self
.
0
.
push
(
0x71
)
;
fields
.
len
(
)
.
encode
(
self
.
0
)
;
for
(
name
ty
)
in
fields
{
name
.
encode
(
self
.
0
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
}
pub
fn
variant
<
'
a
C
T
>
(
self
cases
:
C
)
where
C
:
IntoIterator
<
Item
=
(
&
'
a
str
T
Option
<
u32
>
)
>
C
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
cases
=
cases
.
into_iter
(
)
;
self
.
0
.
push
(
0x70
)
;
cases
.
len
(
)
.
encode
(
self
.
0
)
;
for
(
name
ty
refines
)
in
cases
{
name
.
encode
(
self
.
0
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
if
let
Some
(
default
)
=
refines
{
self
.
0
.
push
(
0x01
)
;
default
.
encode
(
self
.
0
)
;
}
else
{
self
.
0
.
push
(
0x00
)
;
}
}
}
pub
fn
list
(
self
ty
:
impl
Into
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x6f
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
pub
fn
tuple
<
I
T
>
(
self
types
:
I
)
where
I
:
IntoIterator
<
Item
=
T
>
I
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
types
=
types
.
into_iter
(
)
;
self
.
0
.
push
(
0x6E
)
;
types
.
len
(
)
.
encode
(
self
.
0
)
;
for
ty
in
types
{
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
}
pub
fn
flags
<
'
a
I
>
(
self
names
:
I
)
where
I
:
IntoIterator
<
Item
=
&
'
a
str
>
I
:
:
IntoIter
:
ExactSizeIterator
{
let
names
=
names
.
into_iter
(
)
;
self
.
0
.
push
(
0x6D
)
;
names
.
len
(
)
.
encode
(
self
.
0
)
;
for
name
in
names
{
name
.
encode
(
self
.
0
)
;
}
}
pub
fn
enum_type
<
'
a
I
>
(
self
tags
:
I
)
where
I
:
IntoIterator
<
Item
=
&
'
a
str
>
I
:
:
IntoIter
:
ExactSizeIterator
{
let
tags
=
tags
.
into_iter
(
)
;
self
.
0
.
push
(
0x6C
)
;
tags
.
len
(
)
.
encode
(
self
.
0
)
;
for
tag
in
tags
{
tag
.
encode
(
self
.
0
)
;
}
}
pub
fn
union
<
I
T
>
(
self
types
:
I
)
where
I
:
IntoIterator
<
Item
=
T
>
I
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
let
types
=
types
.
into_iter
(
)
;
self
.
0
.
push
(
0x6B
)
;
types
.
len
(
)
.
encode
(
self
.
0
)
;
for
ty
in
types
{
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
}
pub
fn
option
(
self
ty
:
impl
Into
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x6A
)
;
ty
.
into
(
)
.
encode
(
self
.
0
)
;
}
pub
fn
expected
(
self
ok
:
impl
Into
<
ComponentValType
>
error
:
impl
Into
<
ComponentValType
>
)
{
self
.
0
.
push
(
0x69
)
;
ok
.
into
(
)
.
encode
(
self
.
0
)
;
error
.
into
(
)
.
encode
(
self
.
0
)
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
ComponentTypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
ComponentTypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
ComponentTypeEncoder
<
'
_
>
{
self
.
num_added
+
=
1
;
ComponentTypeEncoder
(
&
mut
self
.
bytes
)
}
pub
fn
component
(
&
mut
self
ty
:
&
ComponentType
)
-
>
&
mut
Self
{
self
.
ty
(
)
.
component
(
ty
)
;
self
}
pub
fn
instance
(
&
mut
self
ty
:
&
InstanceType
)
-
>
&
mut
Self
{
self
.
ty
(
)
.
instance
(
ty
)
;
self
}
pub
fn
function
<
'
a
P
T
>
(
&
mut
self
params
:
P
result
:
impl
Into
<
ComponentValType
>
)
-
>
&
mut
Self
where
P
:
IntoIterator
<
Item
=
(
Option
<
&
'
a
str
>
T
)
>
P
:
:
IntoIter
:
ExactSizeIterator
T
:
Into
<
ComponentValType
>
{
self
.
ty
(
)
.
function
(
params
result
)
;
self
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
defined_type
(
&
mut
self
)
-
>
ComponentDefinedTypeEncoder
<
'
_
>
{
self
.
ty
(
)
.
defined_type
(
)
}
}
impl
Encode
for
ComponentTypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
ComponentSection
for
ComponentTypeSection
{
fn
id
(
&
self
)
-
>
u8
{
ComponentSectionId
:
:
Type
.
into
(
)
}
}
