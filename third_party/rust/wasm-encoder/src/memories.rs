use
super
:
:
*
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
MemorySection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
MemorySection
{
pub
fn
new
(
)
-
>
MemorySection
{
MemorySection
{
bytes
:
vec
!
[
]
num_added
:
0
}
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
memory
(
&
mut
self
memory_type
:
MemoryType
)
-
>
&
mut
Self
{
memory_type
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
}
impl
Section
for
MemorySection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Memory
.
into
(
)
}
fn
encode
<
S
>
(
&
self
sink
:
&
mut
S
)
where
S
:
Extend
<
u8
>
{
let
num_added
=
encoders
:
:
u32
(
self
.
num_added
)
;
let
n
=
num_added
.
len
(
)
;
sink
.
extend
(
encoders
:
:
u32
(
u32
:
:
try_from
(
n
+
self
.
bytes
.
len
(
)
)
.
unwrap
(
)
)
.
chain
(
num_added
)
.
chain
(
self
.
bytes
.
iter
(
)
.
copied
(
)
)
)
;
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
MemoryType
{
pub
minimum
:
u64
pub
maximum
:
Option
<
u64
>
pub
memory64
:
bool
}
impl
MemoryType
{
pub
(
crate
)
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
let
mut
flags
=
0
;
if
self
.
maximum
.
is_some
(
)
{
flags
|
=
0b001
;
}
if
self
.
memory64
{
flags
|
=
0b100
;
}
bytes
.
push
(
flags
)
;
bytes
.
extend
(
encoders
:
:
u64
(
self
.
minimum
)
)
;
if
let
Some
(
max
)
=
self
.
maximum
{
bytes
.
extend
(
encoders
:
:
u64
(
max
)
)
;
}
}
}
