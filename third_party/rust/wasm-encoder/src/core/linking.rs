use
std
:
:
borrow
:
:
Cow
;
use
crate
:
:
{
encode_section
CustomSection
Encode
Section
SectionId
}
;
const
VERSION
:
u32
=
2
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
LinkingSection
{
bytes
:
Vec
<
u8
>
}
impl
LinkingSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
symbol_table
(
&
mut
self
symbol_table
:
&
SymbolTable
)
-
>
&
mut
Self
{
symbol_table
.
encode
(
&
mut
self
.
bytes
)
;
self
}
}
impl
Default
for
LinkingSection
{
fn
default
(
)
-
>
Self
{
let
mut
bytes
=
Vec
:
:
new
(
)
;
VERSION
.
encode
(
&
mut
bytes
)
;
Self
{
bytes
}
}
}
impl
Encode
for
LinkingSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
CustomSection
{
name
:
"
linking
"
.
into
(
)
data
:
Cow
:
:
Borrowed
(
&
self
.
bytes
)
}
.
encode
(
sink
)
;
}
}
impl
Section
for
LinkingSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Custom
.
into
(
)
}
}
#
[
allow
(
unused
)
]
const
WASM_SEGMENT_INFO
:
u8
=
5
;
#
[
allow
(
unused
)
]
const
WASM_INIT_FUNCS
:
u8
=
6
;
#
[
allow
(
unused
)
]
const
WASM_COMDAT_INFO
:
u8
=
7
;
const
WASM_SYMBOL_TABLE
:
u8
=
8
;
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
SymbolTable
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
const
SYMTAB_FUNCTION
:
u32
=
0
;
const
SYMTAB_DATA
:
u32
=
1
;
const
SYMTAB_GLOBAL
:
u32
=
2
;
#
[
allow
(
unused
)
]
const
SYMTAB_SECTION
:
u32
=
3
;
#
[
allow
(
unused
)
]
const
SYMTAB_TAG
:
u32
=
4
;
const
SYMTAB_TABLE
:
u32
=
5
;
impl
SymbolTable
{
pub
fn
new
(
)
-
>
Self
{
SymbolTable
{
bytes
:
vec
!
[
]
num_added
:
0
}
}
pub
fn
function
(
&
mut
self
flags
:
u32
index
:
u32
name
:
Option
<
&
str
>
)
-
>
&
mut
Self
{
SYMTAB_FUNCTION
.
encode
(
&
mut
self
.
bytes
)
;
flags
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
if
let
Some
(
name
)
=
name
{
name
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
fn
global
(
&
mut
self
flags
:
u32
index
:
u32
name
:
Option
<
&
str
>
)
-
>
&
mut
Self
{
SYMTAB_GLOBAL
.
encode
(
&
mut
self
.
bytes
)
;
flags
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
if
let
Some
(
name
)
=
name
{
name
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
fn
table
(
&
mut
self
flags
:
u32
index
:
u32
name
:
Option
<
&
str
>
)
-
>
&
mut
Self
{
SYMTAB_TABLE
.
encode
(
&
mut
self
.
bytes
)
;
flags
.
encode
(
&
mut
self
.
bytes
)
;
index
.
encode
(
&
mut
self
.
bytes
)
;
if
let
Some
(
name
)
=
name
{
name
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
fn
data
(
&
mut
self
flags
:
u32
name
:
&
str
definition
:
Option
<
DataSymbolDefinition
>
)
-
>
&
mut
Self
{
SYMTAB_DATA
.
encode
(
&
mut
self
.
bytes
)
;
flags
.
encode
(
&
mut
self
.
bytes
)
;
name
.
encode
(
&
mut
self
.
bytes
)
;
if
let
Some
(
def
)
=
definition
{
def
.
index
.
encode
(
&
mut
self
.
bytes
)
;
def
.
offset
.
encode
(
&
mut
self
.
bytes
)
;
def
.
size
.
encode
(
&
mut
self
.
bytes
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
const
WASM_SYM_BINDING_WEAK
:
u32
=
0x1
;
pub
const
WASM_SYM_BINDING_LOCAL
:
u32
=
0x02
;
pub
const
WASM_SYM_VISIBILITY_HIDDEN
:
u32
=
0x04
;
pub
const
WASM_SYM_UNDEFINED
:
u32
=
0x10
;
pub
const
WASM_SYM_EXPORTED
:
u32
=
0x20
;
pub
const
WASM_SYM_EXPLICIT_NAME
:
u32
=
0x40
;
pub
const
WASM_SYM_NO_STRIP
:
u32
=
0x80
;
}
impl
Encode
for
SymbolTable
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
WASM_SYMBOL_TABLE
)
;
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
DataSymbolDefinition
{
pub
index
:
u32
pub
offset
:
u32
pub
size
:
u32
}
