use
crate
:
:
{
encode_section
encoding_size
ConstExpr
Encode
Section
SectionId
}
;
#
[
derive
(
Clone
Default
Debug
)
]
pub
struct
DataSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
DataSegment
<
'
a
D
>
{
pub
mode
:
DataSegmentMode
<
'
a
>
pub
data
:
D
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
DataSegmentMode
<
'
a
>
{
Active
{
memory_index
:
u32
offset
:
&
'
a
ConstExpr
}
Passive
}
impl
DataSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
segment
<
D
>
(
&
mut
self
segment
:
DataSegment
<
D
>
)
-
>
&
mut
Self
where
D
:
IntoIterator
<
Item
=
u8
>
D
:
:
IntoIter
:
ExactSizeIterator
{
match
segment
.
mode
{
DataSegmentMode
:
:
Passive
=
>
{
self
.
bytes
.
push
(
0x01
)
;
}
DataSegmentMode
:
:
Active
{
memory_index
:
0
offset
}
=
>
{
self
.
bytes
.
push
(
0x00
)
;
offset
.
encode
(
&
mut
self
.
bytes
)
;
}
DataSegmentMode
:
:
Active
{
memory_index
offset
}
=
>
{
self
.
bytes
.
push
(
0x02
)
;
memory_index
.
encode
(
&
mut
self
.
bytes
)
;
offset
.
encode
(
&
mut
self
.
bytes
)
;
}
}
let
data
=
segment
.
data
.
into_iter
(
)
;
data
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
extend
(
data
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
active
<
D
>
(
&
mut
self
memory_index
:
u32
offset
:
&
ConstExpr
data
:
D
)
-
>
&
mut
Self
where
D
:
IntoIterator
<
Item
=
u8
>
D
:
:
IntoIter
:
ExactSizeIterator
{
self
.
segment
(
DataSegment
{
mode
:
DataSegmentMode
:
:
Active
{
memory_index
offset
}
data
}
)
}
pub
fn
passive
<
D
>
(
&
mut
self
data
:
D
)
-
>
&
mut
Self
where
D
:
IntoIterator
<
Item
=
u8
>
D
:
:
IntoIter
:
ExactSizeIterator
{
self
.
segment
(
DataSegment
{
mode
:
DataSegmentMode
:
:
Passive
data
}
)
}
pub
fn
raw
(
&
mut
self
already_encoded_data_segment
:
&
[
u8
]
)
-
>
&
mut
Self
{
self
.
bytes
.
extend_from_slice
(
already_encoded_data_segment
)
;
self
.
num_added
+
=
1
;
self
}
}
impl
Encode
for
DataSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
Section
for
DataSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Data
.
into
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DataCountSection
{
pub
count
:
u32
}
impl
Encode
for
DataCountSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encoding_size
(
self
.
count
)
.
encode
(
sink
)
;
self
.
count
.
encode
(
sink
)
;
}
}
impl
Section
for
DataCountSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
DataCount
.
into
(
)
}
}
