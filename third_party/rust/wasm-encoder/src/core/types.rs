use
crate
:
:
{
encode_section
Encode
Section
SectionId
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
#
[
repr
(
u8
)
]
pub
enum
ValType
{
I32
=
0x7F
I64
=
0x7E
F32
=
0x7D
F64
=
0x7C
V128
=
0x7B
FuncRef
=
0x70
ExternRef
=
0x6F
}
impl
From
<
ValType
>
for
u8
{
#
[
inline
]
fn
from
(
t
:
ValType
)
-
>
u8
{
t
as
u8
}
}
impl
Encode
for
ValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
*
self
as
u8
)
;
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
TypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
TypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
function
<
P
R
>
(
&
mut
self
params
:
P
results
:
R
)
-
>
&
mut
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
P
:
:
IntoIter
:
ExactSizeIterator
R
:
IntoIterator
<
Item
=
ValType
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
params
=
params
.
into_iter
(
)
;
let
results
=
results
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x60
)
;
params
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
extend
(
params
.
map
(
u8
:
:
from
)
)
;
results
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
extend
(
results
.
map
(
u8
:
:
from
)
)
;
self
.
num_added
+
=
1
;
self
}
}
impl
Encode
for
TypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
Section
for
TypeSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Type
.
into
(
)
}
}
