use
crate
:
:
{
encode_section
Encode
Section
SectionId
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
SubType
{
pub
is_final
:
bool
pub
supertype_idx
:
Option
<
u32
>
pub
structural_type
:
StructuralType
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
StructuralType
{
Func
(
FuncType
)
Array
(
ArrayType
)
Struct
(
StructType
)
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
FuncType
{
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
ArrayType
(
pub
FieldType
)
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
StructType
{
pub
fields
:
Box
<
[
FieldType
]
>
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
struct
FieldType
{
pub
element_type
:
StorageType
pub
mutable
:
bool
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
StorageType
{
I8
I16
Val
(
ValType
)
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
ValType
{
I32
I64
F32
F64
V128
Ref
(
RefType
)
}
impl
FuncType
{
pub
fn
new
<
P
R
>
(
params
:
P
results
:
R
)
-
>
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
R
:
IntoIterator
<
Item
=
ValType
>
{
let
mut
buffer
=
params
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
len_params
=
buffer
.
len
(
)
;
buffer
.
extend
(
results
)
;
Self
{
params_results
:
buffer
.
into
(
)
len_params
}
}
#
[
inline
]
pub
fn
params
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
pub
fn
results
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
self
.
len_params
.
.
]
}
}
impl
ValType
{
pub
const
FUNCREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
FUNCREF
)
;
pub
const
EXTERNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXTERNREF
)
;
}
impl
Encode
for
StorageType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
StorageType
:
:
I8
=
>
sink
.
push
(
0x7A
)
StorageType
:
:
I16
=
>
sink
.
push
(
0x79
)
StorageType
:
:
Val
(
vt
)
=
>
vt
.
encode
(
sink
)
}
}
}
impl
Encode
for
ValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
ValType
:
:
I32
=
>
sink
.
push
(
0x7F
)
ValType
:
:
I64
=
>
sink
.
push
(
0x7E
)
ValType
:
:
F32
=
>
sink
.
push
(
0x7D
)
ValType
:
:
F64
=
>
sink
.
push
(
0x7C
)
ValType
:
:
V128
=
>
sink
.
push
(
0x7B
)
ValType
:
:
Ref
(
rt
)
=
>
rt
.
encode
(
sink
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
RefType
{
pub
nullable
:
bool
pub
heap_type
:
HeapType
}
impl
RefType
{
pub
const
FUNCREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Func
}
;
pub
const
EXTERNREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Extern
}
;
}
impl
Encode
for
RefType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
if
self
.
nullable
{
match
self
.
heap_type
{
HeapType
:
:
Func
=
>
return
sink
.
push
(
0x70
)
HeapType
:
:
Extern
=
>
return
sink
.
push
(
0x6f
)
_
=
>
{
}
}
}
if
self
.
nullable
{
sink
.
push
(
0x6C
)
;
}
else
{
sink
.
push
(
0x6B
)
;
}
self
.
heap_type
.
encode
(
sink
)
;
}
}
impl
From
<
RefType
>
for
ValType
{
fn
from
(
ty
:
RefType
)
-
>
ValType
{
ValType
:
:
Ref
(
ty
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
HeapType
{
Func
Extern
Any
None
NoExtern
NoFunc
Eq
Struct
Array
I31
Indexed
(
u32
)
}
impl
Encode
for
HeapType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
HeapType
:
:
Func
=
>
sink
.
push
(
0x70
)
HeapType
:
:
Extern
=
>
sink
.
push
(
0x6F
)
HeapType
:
:
Any
=
>
sink
.
push
(
0x6E
)
HeapType
:
:
None
=
>
sink
.
push
(
0x65
)
HeapType
:
:
NoExtern
=
>
sink
.
push
(
0x69
)
HeapType
:
:
NoFunc
=
>
sink
.
push
(
0x68
)
HeapType
:
:
Eq
=
>
sink
.
push
(
0x6D
)
HeapType
:
:
Struct
=
>
sink
.
push
(
0x67
)
HeapType
:
:
Array
=
>
sink
.
push
(
0x66
)
HeapType
:
:
I31
=
>
sink
.
push
(
0x6A
)
HeapType
:
:
Indexed
(
i
)
=
>
i64
:
:
from
(
*
i
)
.
encode
(
sink
)
}
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
TypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
TypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
function
<
P
R
>
(
&
mut
self
params
:
P
results
:
R
)
-
>
&
mut
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
P
:
:
IntoIter
:
ExactSizeIterator
R
:
IntoIterator
<
Item
=
ValType
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
params
=
params
.
into_iter
(
)
;
let
results
=
results
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x60
)
;
params
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
params
.
for_each
(
|
p
|
p
.
encode
(
&
mut
self
.
bytes
)
)
;
results
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
results
.
for_each
(
|
p
|
p
.
encode
(
&
mut
self
.
bytes
)
)
;
self
.
num_added
+
=
1
;
self
}
pub
fn
array
(
&
mut
self
ty
:
&
StorageType
mutable
:
bool
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x5e
)
;
self
.
field
(
ty
mutable
)
;
self
.
num_added
+
=
1
;
self
}
fn
field
(
&
mut
self
ty
:
&
StorageType
mutable
:
bool
)
-
>
&
mut
Self
{
ty
.
encode
(
&
mut
self
.
bytes
)
;
self
.
bytes
.
push
(
mutable
as
u8
)
;
self
}
pub
fn
struct_
(
&
mut
self
fields
:
Vec
<
FieldType
>
)
-
>
&
mut
Self
{
self
.
bytes
.
push
(
0x5f
)
;
fields
.
len
(
)
.
encode
(
&
mut
self
.
bytes
)
;
for
f
in
fields
.
iter
(
)
{
self
.
field
(
&
f
.
element_type
f
.
mutable
)
;
}
self
.
num_added
+
=
1
;
self
}
pub
fn
subtype
(
&
mut
self
ty
:
&
SubType
)
-
>
&
mut
Self
{
let
st
=
match
ty
.
supertype_idx
{
Some
(
idx
)
=
>
vec
!
[
idx
]
None
=
>
vec
!
[
]
}
;
if
ty
.
is_final
{
self
.
bytes
.
push
(
0x4e
)
;
st
.
encode
(
&
mut
self
.
bytes
)
;
}
else
if
!
st
.
is_empty
(
)
{
self
.
bytes
.
push
(
0x50
)
;
st
.
encode
(
&
mut
self
.
bytes
)
;
}
match
&
ty
.
structural_type
{
StructuralType
:
:
Func
(
ty
)
=
>
{
self
.
function
(
ty
.
params
(
)
.
iter
(
)
.
copied
(
)
ty
.
results
(
)
.
iter
(
)
.
copied
(
)
)
;
}
StructuralType
:
:
Array
(
ArrayType
(
ty
)
)
=
>
{
self
.
array
(
&
ty
.
element_type
ty
.
mutable
)
;
}
StructuralType
:
:
Struct
(
ty
)
=
>
{
self
.
struct_
(
ty
.
fields
.
to_vec
(
)
)
;
}
}
self
}
}
impl
Encode
for
TypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
Section
for
TypeSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Type
.
into
(
)
}
}
