use
crate
:
:
{
encode_section
Encode
Section
SectionId
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
SubType
{
pub
is_final
:
bool
pub
supertype_idx
:
Option
<
u32
>
pub
composite_type
:
CompositeType
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
CompositeType
{
pub
inner
:
CompositeInnerType
pub
shared
:
bool
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
CompositeInnerType
{
Func
(
FuncType
)
Array
(
ArrayType
)
Struct
(
StructType
)
Cont
(
ContType
)
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
FuncType
{
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
struct
ArrayType
(
pub
FieldType
)
;
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
StructType
{
pub
fields
:
Box
<
[
FieldType
]
>
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
struct
FieldType
{
pub
element_type
:
StorageType
pub
mutable
:
bool
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
StorageType
{
I8
I16
Val
(
ValType
)
}
impl
StorageType
{
pub
fn
is_defaultable
(
&
self
)
-
>
bool
{
self
.
unpack
(
)
.
is_defaultable
(
)
}
pub
fn
unpack
(
&
self
)
-
>
ValType
{
match
self
{
StorageType
:
:
I8
|
StorageType
:
:
I16
=
>
ValType
:
:
I32
StorageType
:
:
Val
(
v
)
=
>
*
v
}
}
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
struct
ContType
(
pub
u32
)
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
ValType
{
I32
I64
F32
F64
V128
Ref
(
RefType
)
}
impl
ValType
{
pub
fn
is_numeric
(
&
self
)
-
>
bool
{
match
self
{
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
=
>
true
ValType
:
:
V128
|
ValType
:
:
Ref
(
_
)
=
>
false
}
}
pub
fn
is_vector
(
&
self
)
-
>
bool
{
match
self
{
ValType
:
:
V128
=
>
true
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
Ref
(
_
)
=
>
false
}
}
pub
fn
is_reference
(
&
self
)
-
>
bool
{
match
self
{
ValType
:
:
Ref
(
_
)
=
>
true
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
=
>
false
}
}
}
impl
FuncType
{
pub
fn
new
<
P
R
>
(
params
:
P
results
:
R
)
-
>
Self
where
P
:
IntoIterator
<
Item
=
ValType
>
R
:
IntoIterator
<
Item
=
ValType
>
{
let
mut
buffer
=
params
.
into_iter
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
len_params
=
buffer
.
len
(
)
;
buffer
.
extend
(
results
)
;
Self
:
:
from_parts
(
buffer
.
into
(
)
len_params
)
}
#
[
inline
]
pub
(
crate
)
fn
from_parts
(
params_results
:
Box
<
[
ValType
]
>
len_params
:
usize
)
-
>
Self
{
Self
{
params_results
len_params
}
}
#
[
inline
]
pub
fn
params
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
.
.
self
.
len_params
]
}
#
[
inline
]
pub
fn
results
(
&
self
)
-
>
&
[
ValType
]
{
&
self
.
params_results
[
self
.
len_params
.
.
]
}
}
impl
ValType
{
pub
const
FUNCREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
FUNCREF
)
;
pub
const
EXTERNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXTERNREF
)
;
pub
const
EXNREF
:
ValType
=
ValType
:
:
Ref
(
RefType
:
:
EXNREF
)
;
pub
fn
is_defaultable
(
&
self
)
-
>
bool
{
match
self
{
ValType
:
:
Ref
(
r
)
=
>
r
.
nullable
ValType
:
:
I32
|
ValType
:
:
I64
|
ValType
:
:
F32
|
ValType
:
:
F64
|
ValType
:
:
V128
=
>
true
}
}
}
impl
Encode
for
StorageType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
StorageType
:
:
I8
=
>
sink
.
push
(
0x78
)
StorageType
:
:
I16
=
>
sink
.
push
(
0x77
)
StorageType
:
:
Val
(
vt
)
=
>
vt
.
encode
(
sink
)
}
}
}
impl
Encode
for
ValType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
ValType
:
:
I32
=
>
sink
.
push
(
0x7F
)
ValType
:
:
I64
=
>
sink
.
push
(
0x7E
)
ValType
:
:
F32
=
>
sink
.
push
(
0x7D
)
ValType
:
:
F64
=
>
sink
.
push
(
0x7C
)
ValType
:
:
V128
=
>
sink
.
push
(
0x7B
)
ValType
:
:
Ref
(
rt
)
=
>
rt
.
encode
(
sink
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
RefType
{
pub
nullable
:
bool
pub
heap_type
:
HeapType
}
impl
RefType
{
pub
const
ANYREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Any
}
}
;
pub
const
EQREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Eq
}
}
;
pub
const
FUNCREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Func
}
}
;
pub
const
EXTERNREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Extern
}
}
;
pub
const
I31REF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
I31
}
}
;
pub
const
ARRAYREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Array
}
}
;
pub
const
EXNREF
:
RefType
=
RefType
{
nullable
:
true
heap_type
:
HeapType
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Exn
}
}
;
pub
fn
nullable
(
mut
self
nullable
:
bool
)
-
>
Self
{
self
.
nullable
=
nullable
;
self
}
}
impl
Encode
for
RefType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
RefType
{
nullable
:
true
heap_type
:
heap
HeapType
:
:
Abstract
{
.
.
}
}
=
>
{
heap
.
encode
(
sink
)
;
}
RefType
{
nullable
:
true
heap_type
}
=
>
{
sink
.
push
(
0x63
)
;
heap_type
.
encode
(
sink
)
;
}
RefType
{
nullable
:
false
heap_type
}
=
>
{
sink
.
push
(
0x64
)
;
heap_type
.
encode
(
sink
)
;
}
}
}
}
impl
From
<
RefType
>
for
ValType
{
fn
from
(
ty
:
RefType
)
-
>
ValType
{
ValType
:
:
Ref
(
ty
)
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
HeapType
{
Abstract
{
shared
:
bool
ty
:
AbstractHeapType
}
Concrete
(
u32
)
}
impl
HeapType
{
pub
const
ANY
:
Self
=
Self
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Any
}
;
pub
const
FUNC
:
Self
=
Self
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Func
}
;
pub
const
EXTERN
:
Self
=
Self
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
Extern
}
;
pub
const
I31
:
Self
=
Self
:
:
Abstract
{
shared
:
false
ty
:
AbstractHeapType
:
:
I31
}
;
}
impl
Encode
for
HeapType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
match
self
{
HeapType
:
:
Abstract
{
shared
ty
}
=
>
{
if
*
shared
{
sink
.
push
(
0x65
)
;
}
ty
.
encode
(
sink
)
;
}
HeapType
:
:
Concrete
(
i
)
=
>
i64
:
:
from
(
*
i
)
.
encode
(
sink
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
Ord
PartialOrd
)
]
pub
enum
AbstractHeapType
{
Func
Extern
Any
None
NoExtern
NoFunc
Eq
Struct
Array
I31
Exn
NoExn
Cont
NoCont
}
impl
Encode
for
AbstractHeapType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
use
AbstractHeapType
:
:
*
;
match
self
{
Func
=
>
sink
.
push
(
0x70
)
Extern
=
>
sink
.
push
(
0x6F
)
Any
=
>
sink
.
push
(
0x6E
)
None
=
>
sink
.
push
(
0x71
)
NoExtern
=
>
sink
.
push
(
0x72
)
NoFunc
=
>
sink
.
push
(
0x73
)
Eq
=
>
sink
.
push
(
0x6D
)
Struct
=
>
sink
.
push
(
0x6B
)
Array
=
>
sink
.
push
(
0x6A
)
I31
=
>
sink
.
push
(
0x6C
)
Exn
=
>
sink
.
push
(
0x69
)
NoExn
=
>
sink
.
push
(
0x74
)
Cont
=
>
sink
.
push
(
0x68
)
NoCont
=
>
sink
.
push
(
0x75
)
}
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
TypeSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
TypeSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
#
[
must_use
=
"
the
encoder
must
be
used
to
encode
the
type
"
]
pub
fn
ty
(
&
mut
self
)
-
>
CoreTypeEncoder
{
self
.
num_added
+
=
1
;
CoreTypeEncoder
{
bytes
:
&
mut
self
.
bytes
push_prefix_if_component_core_type
:
false
}
}
}
impl
Encode
for
TypeSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
Section
for
TypeSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Type
.
into
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
CoreTypeEncoder
<
'
a
>
{
pub
(
crate
)
bytes
:
&
'
a
mut
Vec
<
u8
>
pub
(
crate
)
push_prefix_if_component_core_type
:
bool
}
impl
<
'
a
>
CoreTypeEncoder
<
'
a
>
{
pub
fn
function
<
P
R
>
(
mut
self
params
:
P
results
:
R
)
where
P
:
IntoIterator
<
Item
=
ValType
>
P
:
:
IntoIter
:
ExactSizeIterator
R
:
IntoIterator
<
Item
=
ValType
>
R
:
:
IntoIter
:
ExactSizeIterator
{
self
.
encode_function
(
params
results
)
;
}
pub
fn
func_type
(
mut
self
ty
:
&
FuncType
)
{
self
.
encode_function
(
ty
.
params
(
)
.
iter
(
)
.
cloned
(
)
ty
.
results
(
)
.
iter
(
)
.
cloned
(
)
)
;
}
fn
encode_function
<
P
R
>
(
&
mut
self
params
:
P
results
:
R
)
where
P
:
IntoIterator
<
Item
=
ValType
>
P
:
:
IntoIter
:
ExactSizeIterator
R
:
IntoIterator
<
Item
=
ValType
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
params
=
params
.
into_iter
(
)
;
let
results
=
results
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x60
)
;
params
.
len
(
)
.
encode
(
self
.
bytes
)
;
params
.
for_each
(
|
p
|
p
.
encode
(
self
.
bytes
)
)
;
results
.
len
(
)
.
encode
(
self
.
bytes
)
;
results
.
for_each
(
|
p
|
p
.
encode
(
self
.
bytes
)
)
;
}
pub
fn
array
(
mut
self
ty
:
&
StorageType
mutable
:
bool
)
{
self
.
encode_array
(
ty
mutable
)
;
}
fn
encode_array
(
&
mut
self
ty
:
&
StorageType
mutable
:
bool
)
{
self
.
bytes
.
push
(
0x5e
)
;
self
.
encode_field
(
ty
mutable
)
;
}
fn
encode_field
(
&
mut
self
ty
:
&
StorageType
mutable
:
bool
)
{
ty
.
encode
(
self
.
bytes
)
;
self
.
bytes
.
push
(
mutable
as
u8
)
;
}
pub
fn
struct_
<
F
>
(
mut
self
fields
:
F
)
where
F
:
IntoIterator
<
Item
=
FieldType
>
F
:
:
IntoIter
:
ExactSizeIterator
{
self
.
encode_struct
(
fields
)
;
}
fn
encode_struct
<
F
>
(
&
mut
self
fields
:
F
)
where
F
:
IntoIterator
<
Item
=
FieldType
>
F
:
:
IntoIter
:
ExactSizeIterator
{
let
fields
=
fields
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x5f
)
;
fields
.
len
(
)
.
encode
(
self
.
bytes
)
;
for
f
in
fields
{
self
.
encode_field
(
&
f
.
element_type
f
.
mutable
)
;
}
}
fn
encode_cont
(
&
mut
self
ty
:
&
ContType
)
{
self
.
bytes
.
push
(
0x5d
)
;
i64
:
:
from
(
ty
.
0
)
.
encode
(
self
.
bytes
)
;
}
pub
fn
subtype
(
mut
self
ty
:
&
SubType
)
{
self
.
encode_subtype
(
ty
)
}
fn
encode_subtype
(
&
mut
self
ty
:
&
SubType
)
{
if
ty
.
supertype_idx
.
is_some
(
)
|
|
!
ty
.
is_final
{
if
ty
.
is_final
{
self
.
bytes
.
push
(
0x4f
)
;
}
else
{
if
self
.
push_prefix_if_component_core_type
{
self
.
bytes
.
push
(
0x00
)
;
}
self
.
bytes
.
push
(
0x50
)
;
}
ty
.
supertype_idx
.
encode
(
self
.
bytes
)
;
}
if
ty
.
composite_type
.
shared
{
self
.
bytes
.
push
(
0x65
)
;
}
match
&
ty
.
composite_type
.
inner
{
CompositeInnerType
:
:
Func
(
ty
)
=
>
{
self
.
encode_function
(
ty
.
params
(
)
.
iter
(
)
.
copied
(
)
ty
.
results
(
)
.
iter
(
)
.
copied
(
)
)
}
CompositeInnerType
:
:
Array
(
ArrayType
(
ty
)
)
=
>
{
self
.
encode_array
(
&
ty
.
element_type
ty
.
mutable
)
}
CompositeInnerType
:
:
Struct
(
ty
)
=
>
self
.
encode_struct
(
ty
.
fields
.
iter
(
)
.
cloned
(
)
)
CompositeInnerType
:
:
Cont
(
ty
)
=
>
self
.
encode_cont
(
ty
)
}
}
pub
fn
rec
<
T
>
(
mut
self
types
:
T
)
where
T
:
IntoIterator
<
Item
=
SubType
>
T
:
:
IntoIter
:
ExactSizeIterator
{
self
.
push_prefix_if_component_core_type
=
false
;
let
types
=
types
.
into_iter
(
)
;
self
.
bytes
.
push
(
0x4e
)
;
types
.
len
(
)
.
encode
(
self
.
bytes
)
;
types
.
for_each
(
|
t
|
{
self
.
encode_subtype
(
&
t
)
;
}
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
Module
;
use
wasmparser
:
:
WasmFeatures
;
#
[
test
]
fn
func_types_dont_require_wasm_gc
(
)
{
let
mut
types
=
TypeSection
:
:
new
(
)
;
types
.
ty
(
)
.
subtype
(
&
SubType
{
is_final
:
true
supertype_idx
:
None
composite_type
:
CompositeType
{
inner
:
CompositeInnerType
:
:
Func
(
FuncType
:
:
new
(
[
]
[
]
)
)
shared
:
false
}
}
)
;
let
mut
module
=
Module
:
:
new
(
)
;
module
.
section
(
&
types
)
;
let
wasm_bytes
=
module
.
finish
(
)
;
let
mut
validator
=
wasmparser
:
:
Validator
:
:
new_with_features
(
WasmFeatures
:
:
default
(
)
&
!
WasmFeatures
:
:
GC
)
;
validator
.
validate_all
(
&
wasm_bytes
)
.
expect
(
"
Encoding
pre
Wasm
GC
type
should
not
accidentally
use
Wasm
GC
specific
encoding
"
)
;
}
}
