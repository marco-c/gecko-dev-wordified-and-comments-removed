use
crate
:
:
{
encode_section
Encode
Section
SectionId
}
;
#
[
derive
(
Clone
Default
Debug
)
]
pub
struct
TagSection
{
bytes
:
Vec
<
u8
>
num_added
:
u32
}
impl
TagSection
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
len
(
&
self
)
-
>
u32
{
self
.
num_added
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
num_added
=
=
0
}
pub
fn
tag
(
&
mut
self
tag_type
:
TagType
)
-
>
&
mut
Self
{
tag_type
.
encode
(
&
mut
self
.
bytes
)
;
self
.
num_added
+
=
1
;
self
}
}
impl
Encode
for
TagSection
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
encode_section
(
sink
self
.
num_added
&
self
.
bytes
)
;
}
}
impl
Section
for
TagSection
{
fn
id
(
&
self
)
-
>
u8
{
SectionId
:
:
Tag
.
into
(
)
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
TagKind
{
Exception
=
0x0
}
#
[
cfg
(
feature
=
"
wasmparser
"
)
]
impl
From
<
wasmparser
:
:
TagKind
>
for
TagKind
{
fn
from
(
kind
:
wasmparser
:
:
TagKind
)
-
>
Self
{
match
kind
{
wasmparser
:
:
TagKind
:
:
Exception
=
>
TagKind
:
:
Exception
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
struct
TagType
{
pub
kind
:
TagKind
pub
func_type_idx
:
u32
}
impl
Encode
for
TagType
{
fn
encode
(
&
self
sink
:
&
mut
Vec
<
u8
>
)
{
sink
.
push
(
self
.
kind
as
u8
)
;
self
.
func_type_idx
.
encode
(
sink
)
;
}
}
#
[
cfg
(
feature
=
"
wasmparser
"
)
]
impl
From
<
wasmparser
:
:
TagType
>
for
TagType
{
fn
from
(
tag_ty
:
wasmparser
:
:
TagType
)
-
>
Self
{
TagType
{
kind
:
tag_ty
.
kind
.
into
(
)
func_type_idx
:
tag_ty
.
func_type_idx
}
}
}
