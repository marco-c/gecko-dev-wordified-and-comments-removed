use
serde
:
:
Serialize
;
use
std
:
:
{
io
:
:
{
self
Write
}
num
:
:
NonZeroUsize
}
;
pub
enum
Fit
{
All
Some
(
NonZeroUsize
)
None
Err
(
serde_json
:
:
Error
)
}
impl
Fit
{
#
[
inline
]
pub
fn
as_some
(
&
self
)
-
>
Option
<
NonZeroUsize
>
{
match
self
{
Fit
:
:
Some
(
count
)
=
>
Some
(
*
count
)
_
=
>
None
}
}
}
#
[
derive
(
Clone
Copy
Default
)
]
struct
ByteCountWriter
(
usize
)
;
impl
ByteCountWriter
{
#
[
inline
]
pub
fn
count
(
self
)
-
>
usize
{
self
.
0
}
}
impl
Write
for
ByteCountWriter
{
#
[
inline
]
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
0
+
=
buf
.
len
(
)
;
Ok
(
buf
.
len
(
)
)
}
#
[
inline
]
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
pub
fn
compute_serialized_size
<
T
:
Serialize
+
?
Sized
>
(
value
:
&
T
)
-
>
serde_json
:
:
Result
<
usize
>
{
let
mut
w
=
ByteCountWriter
:
:
default
(
)
;
serde_json
:
:
to_writer
(
&
mut
w
value
)
?
;
Ok
(
w
.
count
(
)
)
}
pub
fn
try_fit_items
<
T
:
Serialize
>
(
items
:
&
[
T
]
max_payload_size
:
usize
)
-
>
Fit
{
let
size
=
match
compute_serialized_size
(
&
items
)
{
Ok
(
size
)
=
>
size
Err
(
e
)
=
>
return
Fit
:
:
Err
(
e
)
}
;
let
max_serialized_size
=
match
(
(
max_payload_size
/
4
)
*
3
)
.
checked_sub
(
1500
)
{
Some
(
max_serialized_size
)
=
>
max_serialized_size
None
=
>
return
Fit
:
:
None
}
;
if
size
>
max_serialized_size
{
let
mut
cutoff
=
(
items
.
len
(
)
*
max_serialized_size
-
1
)
/
size
+
1
;
while
cutoff
>
0
{
let
size
=
match
compute_serialized_size
(
&
items
[
.
.
cutoff
]
)
{
Ok
(
size
)
=
>
size
Err
(
e
)
=
>
return
Fit
:
:
Err
(
e
)
}
;
if
size
<
=
max_serialized_size
{
break
;
}
cutoff
-
=
1
;
}
match
NonZeroUsize
:
:
new
(
cutoff
)
{
Some
(
count
)
=
>
Fit
:
:
Some
(
count
)
None
=
>
Fit
:
:
None
}
}
else
{
Fit
:
:
All
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
serde_derive
:
:
Serialize
;
#
[
derive
(
Serialize
)
]
struct
CommandRecord
{
#
[
serde
(
rename
=
"
command
"
)
]
name
:
&
'
static
str
#
[
serde
(
default
)
]
args
:
&
'
static
[
Option
<
&
'
static
str
>
]
#
[
serde
(
default
rename
=
"
flowID
"
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
flow_id
:
Option
<
&
'
static
str
>
}
const
COMMANDS
:
&
[
CommandRecord
]
=
&
[
CommandRecord
{
name
:
"
wipeEngine
"
args
:
&
[
Some
(
"
bookmarks
"
)
]
flow_id
:
Some
(
"
flow
"
)
}
CommandRecord
{
name
:
"
resetEngine
"
args
:
&
[
Some
(
"
history
"
)
]
flow_id
:
Some
(
"
flow
"
)
}
CommandRecord
{
name
:
"
logout
"
args
:
&
[
]
flow_id
:
None
}
]
;
#
[
test
]
fn
test_compute_serialized_size
(
)
{
assert_eq
!
(
compute_serialized_size
(
&
1
)
.
unwrap
(
)
1
)
;
assert_eq
!
(
compute_serialized_size
(
&
"
hi
"
)
.
unwrap
(
)
4
)
;
assert_eq
!
(
compute_serialized_size
(
&
[
"
hi
"
"
hello
"
"
bye
"
]
)
.
unwrap
(
)
20
)
;
let
sizes
=
COMMANDS
.
iter
(
)
.
map
(
|
c
|
compute_serialized_size
(
c
)
.
unwrap
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
sizes
&
[
61
60
30
]
)
;
}
#
[
test
]
fn
test_try_fit_items
(
)
{
assert
!
(
matches
!
(
try_fit_items
(
COMMANDS
4096
)
Fit
:
:
All
)
)
;
assert_eq
!
(
try_fit_items
(
COMMANDS
2168
)
.
as_some
(
)
.
unwrap
(
)
.
get
(
)
2
)
;
assert_eq
!
(
try_fit_items
(
COMMANDS
2084
)
.
as_some
(
)
.
unwrap
(
)
.
get
(
)
1
)
;
assert
!
(
matches
!
(
try_fit_items
(
COMMANDS
1024
)
Fit
:
:
None
)
)
;
}
}
