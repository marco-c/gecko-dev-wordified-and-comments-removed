#
[
cfg
(
feature
=
"
counters
"
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicIsize
Ordering
}
;
use
std
:
:
{
fmt
ops
:
:
Range
}
;
pub
struct
InternalCounter
{
#
[
cfg
(
feature
=
"
counters
"
)
]
value
:
AtomicIsize
}
impl
InternalCounter
{
#
[
inline
]
#
[
must_use
]
pub
const
fn
new
(
)
-
>
Self
{
InternalCounter
{
#
[
cfg
(
feature
=
"
counters
"
)
]
value
:
AtomicIsize
:
:
new
(
0
)
}
}
#
[
cfg
(
feature
=
"
counters
"
)
]
#
[
inline
]
pub
fn
read
(
&
self
)
-
>
isize
{
self
.
value
.
load
(
Ordering
:
:
Relaxed
)
}
#
[
cfg
(
not
(
feature
=
"
counters
"
)
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
read
(
&
self
)
-
>
isize
{
0
}
#
[
cfg
(
feature
=
"
counters
"
)
]
#
[
inline
]
pub
fn
take
(
&
self
)
-
>
isize
{
self
.
value
.
swap
(
0
Ordering
:
:
Relaxed
)
}
#
[
cfg
(
not
(
feature
=
"
counters
"
)
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
take
(
&
self
)
-
>
isize
{
0
}
#
[
inline
]
pub
fn
add
(
&
self
_val
:
isize
)
{
#
[
cfg
(
feature
=
"
counters
"
)
]
self
.
value
.
fetch_add
(
_val
Ordering
:
:
Relaxed
)
;
}
#
[
inline
]
pub
fn
sub
(
&
self
_val
:
isize
)
{
#
[
cfg
(
feature
=
"
counters
"
)
]
self
.
value
.
fetch_add
(
-
_val
Ordering
:
:
Relaxed
)
;
}
#
[
inline
]
pub
fn
set
(
&
self
_val
:
isize
)
{
#
[
cfg
(
feature
=
"
counters
"
)
]
self
.
value
.
store
(
_val
Ordering
:
:
Relaxed
)
;
}
}
impl
Clone
for
InternalCounter
{
fn
clone
(
&
self
)
-
>
Self
{
InternalCounter
{
#
[
cfg
(
feature
=
"
counters
"
)
]
value
:
AtomicIsize
:
:
new
(
self
.
read
(
)
)
}
}
}
impl
Default
for
InternalCounter
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
std
:
:
fmt
:
:
Debug
for
InternalCounter
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
self
.
read
(
)
.
fmt
(
f
)
}
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Default
)
]
pub
struct
HalCounters
{
pub
buffers
:
InternalCounter
pub
textures
:
InternalCounter
pub
texture_views
:
InternalCounter
pub
bind_groups
:
InternalCounter
pub
bind_group_layouts
:
InternalCounter
pub
render_pipelines
:
InternalCounter
pub
compute_pipelines
:
InternalCounter
pub
pipeline_layouts
:
InternalCounter
pub
samplers
:
InternalCounter
pub
command_encoders
:
InternalCounter
pub
shader_modules
:
InternalCounter
pub
query_sets
:
InternalCounter
pub
fences
:
InternalCounter
pub
buffer_memory
:
InternalCounter
pub
texture_memory
:
InternalCounter
pub
memory_allocations
:
InternalCounter
}
#
[
derive
(
Clone
Default
)
]
pub
struct
CoreCounters
{
}
#
[
derive
(
Clone
Default
)
]
pub
struct
InternalCounters
{
pub
core
:
CoreCounters
pub
hal
:
HalCounters
}
#
[
derive
(
Clone
)
]
pub
struct
AllocationReport
{
pub
name
:
String
pub
offset
:
u64
pub
size
:
u64
}
#
[
derive
(
Clone
)
]
pub
struct
MemoryBlockReport
{
pub
size
:
u64
pub
allocations
:
Range
<
usize
>
}
#
[
derive
(
Clone
)
]
pub
struct
AllocatorReport
{
pub
allocations
:
Vec
<
AllocationReport
>
pub
blocks
:
Vec
<
MemoryBlockReport
>
pub
total_allocated_bytes
:
u64
pub
total_reserved_bytes
:
u64
}
impl
fmt
:
:
Debug
for
AllocationReport
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
name
=
if
!
self
.
name
.
is_empty
(
)
{
self
.
name
.
as_str
(
)
}
else
{
"
-
-
"
}
;
write
!
(
f
"
{
name
:
?
}
:
{
}
"
FmtBytes
(
self
.
size
)
)
}
}
impl
fmt
:
:
Debug
for
AllocatorReport
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
allocations
=
self
.
allocations
.
clone
(
)
;
allocations
.
sort_by_key
(
|
alloc
|
std
:
:
cmp
:
:
Reverse
(
alloc
.
size
)
)
;
let
max_num_allocations_to_print
=
f
.
precision
(
)
.
unwrap_or
(
usize
:
:
MAX
)
;
allocations
.
truncate
(
max_num_allocations_to_print
)
;
f
.
debug_struct
(
"
AllocatorReport
"
)
.
field
(
"
summary
"
&
std
:
:
format_args
!
(
"
{
}
/
{
}
"
FmtBytes
(
self
.
total_allocated_bytes
)
FmtBytes
(
self
.
total_reserved_bytes
)
)
)
.
field
(
"
blocks
"
&
self
.
blocks
.
len
(
)
)
.
field
(
"
allocations
"
&
self
.
allocations
.
len
(
)
)
.
field
(
"
largest
"
&
allocations
.
as_slice
(
)
)
.
finish
(
)
}
}
struct
FmtBytes
(
u64
)
;
impl
fmt
:
:
Display
for
FmtBytes
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
const
SUFFIX
:
[
&
str
;
5
]
=
[
"
B
"
"
KB
"
"
MB
"
"
GB
"
"
TB
"
]
;
let
mut
idx
=
0
;
let
mut
amount
=
self
.
0
as
f64
;
loop
{
if
amount
<
1024
.
0
|
|
idx
=
=
SUFFIX
.
len
(
)
-
1
{
return
write
!
(
f
"
{
:
.
2
}
{
}
"
amount
SUFFIX
[
idx
]
)
;
}
amount
/
=
1024
.
0
;
idx
+
=
1
;
}
}
}
