use
core
:
:
cmp
:
:
Ordering
;
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
cfg
(
doc
)
]
use
crate
:
:
{
Features
TextureFormat
}
;
macro_rules
!
with_limits
{
(
macro_name
:
ident
)
=
>
{
macro_name
!
(
max_texture_dimension_1d
Ordering
:
:
Less
)
;
macro_name
!
(
max_texture_dimension_1d
Ordering
:
:
Less
)
;
macro_name
!
(
max_texture_dimension_2d
Ordering
:
:
Less
)
;
macro_name
!
(
max_texture_dimension_3d
Ordering
:
:
Less
)
;
macro_name
!
(
max_texture_array_layers
Ordering
:
:
Less
)
;
macro_name
!
(
max_bind_groups
Ordering
:
:
Less
)
;
macro_name
!
(
max_bindings_per_bind_group
Ordering
:
:
Less
)
;
macro_name
!
(
max_dynamic_uniform_buffers_per_pipeline_layout
Ordering
:
:
Less
)
;
macro_name
!
(
max_dynamic_storage_buffers_per_pipeline_layout
Ordering
:
:
Less
)
;
macro_name
!
(
max_sampled_textures_per_shader_stage
Ordering
:
:
Less
)
;
macro_name
!
(
max_samplers_per_shader_stage
Ordering
:
:
Less
)
;
macro_name
!
(
max_storage_buffers_per_shader_stage
Ordering
:
:
Less
)
;
macro_name
!
(
max_storage_textures_per_shader_stage
Ordering
:
:
Less
)
;
macro_name
!
(
max_uniform_buffers_per_shader_stage
Ordering
:
:
Less
)
;
macro_name
!
(
max_binding_array_elements_per_shader_stage
Ordering
:
:
Less
)
;
macro_name
!
(
max_uniform_buffer_binding_size
Ordering
:
:
Less
)
;
macro_name
!
(
max_storage_buffer_binding_size
Ordering
:
:
Less
)
;
macro_name
!
(
max_vertex_buffers
Ordering
:
:
Less
)
;
macro_name
!
(
max_buffer_size
Ordering
:
:
Less
)
;
macro_name
!
(
max_vertex_attributes
Ordering
:
:
Less
)
;
macro_name
!
(
max_vertex_buffer_array_stride
Ordering
:
:
Less
)
;
macro_name
!
(
min_uniform_buffer_offset_alignment
Ordering
:
:
Greater
)
;
macro_name
!
(
min_storage_buffer_offset_alignment
Ordering
:
:
Greater
)
;
macro_name
!
(
max_color_attachments
Ordering
:
:
Less
)
;
macro_name
!
(
max_color_attachment_bytes_per_sample
Ordering
:
:
Less
)
;
macro_name
!
(
max_compute_workgroup_storage_size
Ordering
:
:
Less
)
;
macro_name
!
(
max_compute_invocations_per_workgroup
Ordering
:
:
Less
)
;
macro_name
!
(
max_compute_workgroup_size_x
Ordering
:
:
Less
)
;
macro_name
!
(
max_compute_workgroup_size_y
Ordering
:
:
Less
)
;
macro_name
!
(
max_compute_workgroup_size_z
Ordering
:
:
Less
)
;
macro_name
!
(
max_compute_workgroups_per_dimension
Ordering
:
:
Less
)
;
macro_name
!
(
max_immediate_size
Ordering
:
:
Less
)
;
macro_name
!
(
max_non_sampler_bindings
Ordering
:
:
Less
)
;
macro_name
!
(
max_task_mesh_workgroup_total_count
Ordering
:
:
Less
)
;
macro_name
!
(
max_task_mesh_workgroups_per_dimension
Ordering
:
:
Less
)
;
macro_name
!
(
max_task_invocations_per_workgroup
Ordering
:
:
Less
)
;
macro_name
!
(
max_task_invocations_per_dimension
Ordering
:
:
Less
)
;
macro_name
!
(
max_mesh_invocations_per_workgroup
Ordering
:
:
Less
)
;
macro_name
!
(
max_mesh_invocations_per_dimension
Ordering
:
:
Less
)
;
macro_name
!
(
max_task_payload_size
Ordering
:
:
Less
)
;
macro_name
!
(
max_mesh_output_vertices
Ordering
:
:
Less
)
;
macro_name
!
(
max_mesh_output_primitives
Ordering
:
:
Less
)
;
macro_name
!
(
max_mesh_output_layers
Ordering
:
:
Less
)
;
macro_name
!
(
max_mesh_multiview_view_count
Ordering
:
:
Less
)
;
macro_name
!
(
max_blas_primitive_count
Ordering
:
:
Less
)
;
macro_name
!
(
max_blas_geometry_count
Ordering
:
:
Less
)
;
macro_name
!
(
max_tlas_instance_count
Ordering
:
:
Less
)
;
macro_name
!
(
max_multiview_view_count
Ordering
:
:
Less
)
;
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
default
)
)
]
pub
struct
Limits
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension1D
"
)
)
]
pub
max_texture_dimension_1d
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension2D
"
)
)
]
pub
max_texture_dimension_2d
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension3D
"
)
)
]
pub
max_texture_dimension_3d
:
u32
pub
max_texture_array_layers
:
u32
pub
max_bind_groups
:
u32
pub
max_bindings_per_bind_group
:
u32
pub
max_dynamic_uniform_buffers_per_pipeline_layout
:
u32
pub
max_dynamic_storage_buffers_per_pipeline_layout
:
u32
pub
max_sampled_textures_per_shader_stage
:
u32
pub
max_samplers_per_shader_stage
:
u32
pub
max_storage_buffers_per_shader_stage
:
u32
pub
max_storage_textures_per_shader_stage
:
u32
pub
max_uniform_buffers_per_shader_stage
:
u32
pub
max_binding_array_elements_per_shader_stage
:
u32
pub
max_binding_array_sampler_elements_per_shader_stage
:
u32
pub
max_uniform_buffer_binding_size
:
u32
pub
max_storage_buffer_binding_size
:
u32
pub
max_vertex_buffers
:
u32
pub
max_buffer_size
:
u64
pub
max_vertex_attributes
:
u32
pub
max_vertex_buffer_array_stride
:
u32
pub
max_inter_stage_shader_variables
:
u32
pub
min_uniform_buffer_offset_alignment
:
u32
pub
min_storage_buffer_offset_alignment
:
u32
pub
max_color_attachments
:
u32
pub
max_color_attachment_bytes_per_sample
:
u32
pub
max_compute_workgroup_storage_size
:
u32
pub
max_compute_invocations_per_workgroup
:
u32
pub
max_compute_workgroup_size_x
:
u32
pub
max_compute_workgroup_size_y
:
u32
pub
max_compute_workgroup_size_z
:
u32
pub
max_compute_workgroups_per_dimension
:
u32
pub
max_immediate_size
:
u32
pub
max_non_sampler_bindings
:
u32
pub
max_task_mesh_workgroup_total_count
:
u32
pub
max_task_mesh_workgroups_per_dimension
:
u32
pub
max_task_invocations_per_workgroup
:
u32
pub
max_task_invocations_per_dimension
:
u32
pub
max_mesh_invocations_per_workgroup
:
u32
pub
max_mesh_invocations_per_dimension
:
u32
pub
max_task_payload_size
:
u32
pub
max_mesh_output_vertices
:
u32
pub
max_mesh_output_primitives
:
u32
pub
max_mesh_output_layers
:
u32
pub
max_mesh_multiview_view_count
:
u32
pub
max_blas_primitive_count
:
u32
pub
max_blas_geometry_count
:
u32
pub
max_tlas_instance_count
:
u32
pub
max_acceleration_structures_per_shader_stage
:
u32
pub
max_multiview_view_count
:
u32
}
impl
Default
for
Limits
{
fn
default
(
)
-
>
Self
{
Self
:
:
defaults
(
)
}
}
impl
Limits
{
#
[
must_use
]
pub
const
fn
defaults
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
8192
max_texture_dimension_2d
:
8192
max_texture_dimension_3d
:
2048
max_texture_array_layers
:
256
max_bind_groups
:
4
max_bindings_per_bind_group
:
1000
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
8
max_storage_textures_per_shader_stage
:
4
max_uniform_buffers_per_shader_stage
:
12
max_binding_array_elements_per_shader_stage
:
0
max_binding_array_sampler_elements_per_shader_stage
:
0
max_uniform_buffer_binding_size
:
64
<
<
10
max_storage_buffer_binding_size
:
128
<
<
20
max_vertex_buffers
:
8
max_buffer_size
:
256
<
<
20
max_vertex_attributes
:
16
max_vertex_buffer_array_stride
:
2048
max_inter_stage_shader_variables
:
16
min_uniform_buffer_offset_alignment
:
256
min_storage_buffer_offset_alignment
:
256
max_color_attachments
:
8
max_color_attachment_bytes_per_sample
:
32
max_compute_workgroup_storage_size
:
16384
max_compute_invocations_per_workgroup
:
256
max_compute_workgroup_size_x
:
256
max_compute_workgroup_size_y
:
256
max_compute_workgroup_size_z
:
64
max_compute_workgroups_per_dimension
:
65535
max_immediate_size
:
0
max_non_sampler_bindings
:
1_000_000
max_task_mesh_workgroup_total_count
:
0
max_task_mesh_workgroups_per_dimension
:
0
max_task_invocations_per_workgroup
:
0
max_task_invocations_per_dimension
:
0
max_mesh_invocations_per_workgroup
:
0
max_mesh_invocations_per_dimension
:
0
max_task_payload_size
:
0
max_mesh_output_vertices
:
0
max_mesh_output_primitives
:
0
max_mesh_output_layers
:
0
max_mesh_multiview_view_count
:
0
max_blas_primitive_count
:
0
max_blas_geometry_count
:
0
max_tlas_instance_count
:
0
max_acceleration_structures_per_shader_stage
:
0
max_multiview_view_count
:
0
}
}
#
[
must_use
]
pub
const
fn
downlevel_defaults
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
2048
max_texture_dimension_2d
:
2048
max_texture_dimension_3d
:
256
max_storage_buffers_per_shader_stage
:
4
max_uniform_buffer_binding_size
:
16
<
<
10
max_inter_stage_shader_variables
:
15
max_color_attachments
:
4
max_compute_workgroup_storage_size
:
16352
.
.
Self
:
:
defaults
(
)
}
}
#
[
must_use
]
pub
const
fn
downlevel_webgl2_defaults
(
)
-
>
Self
{
Self
{
max_uniform_buffers_per_shader_stage
:
11
max_storage_buffers_per_shader_stage
:
0
max_storage_textures_per_shader_stage
:
0
max_dynamic_storage_buffers_per_pipeline_layout
:
0
max_storage_buffer_binding_size
:
0
max_vertex_buffer_array_stride
:
255
max_compute_workgroup_storage_size
:
0
max_compute_invocations_per_workgroup
:
0
max_compute_workgroup_size_x
:
0
max_compute_workgroup_size_y
:
0
max_compute_workgroup_size_z
:
0
max_compute_workgroups_per_dimension
:
0
max_inter_stage_shader_variables
:
15
.
.
Self
:
:
downlevel_defaults
(
)
}
}
#
[
must_use
]
pub
const
fn
using_resolution
(
self
other
:
Self
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
other
.
max_texture_dimension_1d
max_texture_dimension_2d
:
other
.
max_texture_dimension_2d
max_texture_dimension_3d
:
other
.
max_texture_dimension_3d
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_alignment
(
self
other
:
Self
)
-
>
Self
{
Self
{
min_uniform_buffer_offset_alignment
:
other
.
min_uniform_buffer_offset_alignment
min_storage_buffer_offset_alignment
:
other
.
min_storage_buffer_offset_alignment
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_minimum_supported_acceleration_structure_values
(
self
)
-
>
Self
{
Self
{
max_blas_geometry_count
:
(
1
<
<
24
)
-
1
max_tlas_instance_count
:
(
1
<
<
24
)
-
1
max_blas_primitive_count
:
1
<
<
28
max_acceleration_structures_per_shader_stage
:
16
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_acceleration_structure_values
(
self
other
:
Self
)
-
>
Self
{
Self
{
max_blas_geometry_count
:
other
.
max_blas_geometry_count
max_tlas_instance_count
:
other
.
max_tlas_instance_count
max_blas_primitive_count
:
other
.
max_blas_primitive_count
max_acceleration_structures_per_shader_stage
:
other
.
max_acceleration_structures_per_shader_stage
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_recommended_minimum_mesh_shader_values
(
self
)
-
>
Self
{
Self
{
max_task_mesh_workgroup_total_count
:
1024
max_task_mesh_workgroups_per_dimension
:
256
max_task_invocations_per_workgroup
:
128
max_task_invocations_per_dimension
:
64
max_mesh_invocations_per_workgroup
:
128
max_mesh_invocations_per_dimension
:
128
max_task_payload_size
:
16384
-
32
max_mesh_output_vertices
:
256
max_mesh_output_primitives
:
256
max_mesh_output_layers
:
8
max_mesh_multiview_view_count
:
0
.
.
self
}
}
#
[
must_use
]
pub
fn
check_limits
(
&
self
allowed
:
&
Self
)
-
>
bool
{
let
mut
within
=
true
;
self
.
check_limits_with_fail_fn
(
allowed
true
|
_
_
_
|
within
=
false
)
;
within
}
pub
fn
check_limits_with_fail_fn
(
&
self
allowed
:
&
Self
fatal
:
bool
mut
fail_fn
:
impl
FnMut
(
&
'
static
str
u64
u64
)
)
{
macro_rules
!
check_with_fail_fn
{
(
name
:
ident
ordering
:
expr
)
=
>
{
let
invalid_ord
=
ordering
.
reverse
(
)
;
if
self
.
name
.
cmp
(
&
allowed
.
name
)
=
=
invalid_ord
{
fail_fn
(
stringify
!
(
name
)
self
.
name
as
u64
allowed
.
name
as
u64
)
;
if
fatal
{
return
;
}
}
}
;
}
with_limits
!
(
check_with_fail_fn
)
;
}
#
[
must_use
]
pub
fn
or_better_values_from
(
mut
self
other
:
&
Self
)
-
>
Self
{
macro_rules
!
or_better_value_from
{
(
name
:
ident
ordering
:
expr
)
=
>
{
match
ordering
{
/
/
Limits
that
are
maximum
values
(
most
of
them
)
Ordering
:
:
Less
=
>
self
.
name
=
self
.
name
.
max
(
other
.
name
)
/
/
Limits
that
are
minimum
values
Ordering
:
:
Greater
=
>
self
.
name
=
self
.
name
.
min
(
other
.
name
)
Ordering
:
:
Equal
=
>
unreachable
!
(
)
}
}
;
}
with_limits
!
(
or_better_value_from
)
;
self
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
DownlevelLimits
{
}
#
[
allow
(
clippy
:
:
derivable_impls
)
]
impl
Default
for
DownlevelLimits
{
fn
default
(
)
-
>
Self
{
DownlevelLimits
{
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
DownlevelCapabilities
{
pub
flags
:
DownlevelFlags
pub
limits
:
DownlevelLimits
pub
shader_model
:
ShaderModel
}
impl
Default
for
DownlevelCapabilities
{
fn
default
(
)
-
>
Self
{
Self
{
flags
:
DownlevelFlags
:
:
all
(
)
limits
:
DownlevelLimits
:
:
default
(
)
shader_model
:
ShaderModel
:
:
Sm5
}
}
}
impl
DownlevelCapabilities
{
#
[
must_use
]
pub
fn
is_webgpu_compliant
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
DownlevelFlags
:
:
compliant
(
)
)
&
&
self
.
limits
=
=
DownlevelLimits
:
:
default
(
)
&
&
self
.
shader_model
>
=
ShaderModel
:
:
Sm5
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Binary
flags
listing
features
that
may
or
may
not
be
present
on
downlevel
adapters
.
/
/
/
/
/
/
A
downlevel
adapter
is
a
GPU
adapter
that
wgpu
supports
but
with
potentially
limited
/
/
/
features
due
to
the
lack
of
hardware
feature
support
.
/
/
/
/
/
/
Flags
that
are
*
*
not
*
*
present
for
a
downlevel
adapter
or
device
usually
indicates
/
/
/
non
-
compliance
with
the
WebGPU
specification
but
not
always
.
/
/
/
/
/
/
You
can
check
whether
a
set
of
flags
is
compliant
through
the
/
/
/
[
DownlevelCapabilities
:
:
is_webgpu_compliant
(
)
]
function
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelFlags
:
u32
{
/
/
/
The
device
supports
compiling
and
using
compute
shaders
.
/
/
/
/
/
/
WebGL2
and
GLES3
.
0
devices
do
not
support
compute
.
const
COMPUTE_SHADERS
=
1
<
<
0
;
/
/
/
Supports
binding
storage
buffers
and
textures
to
fragment
shaders
.
const
FRAGMENT_WRITABLE_STORAGE
=
1
<
<
1
;
/
/
/
Supports
indirect
drawing
and
dispatching
.
/
/
/
/
/
/
[
Self
:
:
COMPUTE_SHADERS
]
must
be
present
for
this
flag
.
/
/
/
/
/
/
WebGL2
GLES
3
.
0
and
Metal
on
Apple1
/
Apple2
GPUs
do
not
support
indirect
.
const
INDIRECT_EXECUTION
=
1
<
<
2
;
/
/
/
Supports
non
-
zero
base_vertex
parameter
to
direct
indexed
draw
calls
.
/
/
/
/
/
/
Indirect
calls
if
supported
always
support
non
-
zero
base_vertex
.
/
/
/
/
/
/
Supported
by
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
on
Apple3
+
or
Mac1
+
/
/
/
-
OpenGL
3
.
2
+
/
/
/
-
OpenGL
ES
3
.
2
const
BASE_VERTEX
=
1
<
<
3
;
/
/
/
Supports
reading
from
a
depth
/
stencil
texture
while
using
it
as
a
read
-
only
/
/
/
depth
/
stencil
attachment
.
/
/
/
/
/
/
The
WebGL2
and
GLES
backends
do
not
support
RODS
.
const
READ_ONLY_DEPTH_STENCIL
=
1
<
<
4
;
/
/
/
Supports
textures
with
mipmaps
which
have
a
non
power
of
two
size
.
const
NON_POWER_OF_TWO_MIPMAPPED_TEXTURES
=
1
<
<
5
;
/
/
/
Supports
textures
that
are
cube
arrays
.
const
CUBE_ARRAY_TEXTURES
=
1
<
<
6
;
/
/
/
Supports
comparison
samplers
.
const
COMPARISON_SAMPLERS
=
1
<
<
7
;
/
/
/
Supports
different
blend
operations
per
color
attachment
.
const
INDEPENDENT_BLEND
=
1
<
<
8
;
/
/
/
Supports
storage
buffers
in
vertex
shaders
.
const
VERTEX_STORAGE
=
1
<
<
9
;
/
/
/
Supports
samplers
with
anisotropic
filtering
.
Note
this
isn
'
t
actually
required
by
/
/
/
WebGPU
the
implementation
is
allowed
to
completely
ignore
aniso
clamp
.
This
flag
is
/
/
/
here
for
native
backends
so
they
can
communicate
to
the
user
of
aniso
is
enabled
.
/
/
/
/
/
/
All
backends
and
all
devices
support
anisotropic
filtering
.
const
ANISOTROPIC_FILTERING
=
1
<
<
10
;
/
/
/
Supports
storage
buffers
in
fragment
shaders
.
const
FRAGMENT_STORAGE
=
1
<
<
11
;
/
/
/
Supports
sample
-
rate
shading
.
const
MULTISAMPLED_SHADING
=
1
<
<
12
;
/
/
/
Supports
copies
between
depth
textures
and
buffers
.
/
/
/
/
/
/
GLES
/
WebGL
don
'
t
support
this
.
const
DEPTH_TEXTURE_AND_BUFFER_COPIES
=
1
<
<
13
;
/
/
/
Supports
all
the
texture
usages
described
in
WebGPU
.
If
this
isn
'
t
supported
you
/
/
/
should
call
get_texture_format_features
to
get
how
you
can
use
textures
of
a
given
format
const
WEBGPU_TEXTURE_FORMAT_SUPPORT
=
1
<
<
14
;
/
/
/
Supports
buffer
bindings
with
sizes
that
aren
'
t
a
multiple
of
16
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
const
BUFFER_BINDINGS_NOT_16_BYTE_ALIGNED
=
1
<
<
15
;
/
/
/
Supports
buffers
to
combine
[
BufferUsages
:
:
INDEX
]
with
usages
other
than
[
BufferUsages
:
:
COPY_DST
]
and
[
BufferUsages
:
:
COPY_SRC
]
.
/
/
/
Furthermore
in
absence
of
this
feature
it
is
not
allowed
to
copy
index
buffers
from
/
to
buffers
with
a
set
of
usage
flags
containing
/
/
/
[
BufferUsages
:
:
VERTEX
]
/
[
BufferUsages
:
:
UNIFORM
]
/
[
BufferUsages
:
:
STORAGE
]
or
[
BufferUsages
:
:
INDIRECT
]
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
const
UNRESTRICTED_INDEX_BUFFER
=
1
<
<
16
;
/
/
/
Supports
full
32
-
bit
range
indices
(
2
^
32
-
1
as
opposed
to
2
^
24
-
1
without
this
flag
)
/
/
/
/
/
/
Corresponds
to
Vulkan
'
s
VkPhysicalDeviceFeatures
.
fullDrawIndexUint32
const
FULL_DRAW_INDEX_UINT32
=
1
<
<
17
;
/
/
/
Supports
depth
bias
clamping
/
/
/
/
/
/
Corresponds
to
Vulkan
'
s
VkPhysicalDeviceFeatures
.
depthBiasClamp
const
DEPTH_BIAS_CLAMP
=
1
<
<
18
;
/
/
/
Supports
specifying
which
view
format
values
are
allowed
when
create_view
(
)
is
called
on
a
texture
.
/
/
/
/
/
/
The
WebGL
and
GLES
backends
doesn
'
t
support
this
.
const
VIEW_FORMATS
=
1
<
<
19
;
/
/
/
With
this
feature
not
present
there
are
the
following
restrictions
on
Queue
:
:
copy_external_image_to_texture
:
/
/
/
-
The
source
must
not
be
[
web_sys
:
:
OffscreenCanvas
]
/
/
/
-
[
CopyExternalImageSourceInfo
:
:
origin
]
must
be
zero
.
/
/
/
-
[
CopyExternalImageDestInfo
:
:
color_space
]
must
be
srgb
.
/
/
/
-
If
the
source
is
an
[
web_sys
:
:
ImageBitmap
]
:
/
/
/
-
[
CopyExternalImageSourceInfo
:
:
flip_y
]
must
be
false
.
/
/
/
-
[
CopyExternalImageDestInfo
:
:
premultiplied_alpha
]
must
be
false
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
WebGPU
does
.
const
UNRESTRICTED_EXTERNAL_TEXTURE_COPIES
=
1
<
<
20
;
/
/
/
Supports
specifying
which
view
formats
are
allowed
when
calling
create_view
on
the
texture
returned
by
/
/
/
Surface
:
:
get_current_texture
.
/
/
/
/
/
/
The
GLES
/
WebGL
and
Vulkan
on
Android
doesn
'
t
support
this
.
const
SURFACE_VIEW_FORMATS
=
1
<
<
21
;
/
/
/
If
this
is
true
calls
to
CommandEncoder
:
:
resolve_query_set
will
be
performed
on
the
queue
timeline
.
/
/
/
/
/
/
If
this
is
false
calls
to
CommandEncoder
:
:
resolve_query_set
will
be
performed
on
the
device
(
i
.
e
.
cpu
)
timeline
/
/
/
and
will
block
that
timeline
until
the
query
has
data
.
You
may
work
around
this
limitation
by
waiting
until
the
submit
/
/
/
whose
queries
you
are
resolving
is
fully
finished
(
through
use
of
queue
.
on_submitted_work_done
)
and
only
/
/
/
then
submitting
the
resolve_query_set
command
.
The
queries
will
be
guaranteed
finished
so
will
not
block
.
/
/
/
/
/
/
Supported
by
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
-
OpenGL
4
.
4
+
/
/
/
/
/
/
Not
Supported
by
:
/
/
/
-
GL
ES
/
WebGL
const
NONBLOCKING_QUERY_RESOLVE
=
1
<
<
22
;
/
/
/
Allows
shaders
to
use
quantizeToF16
pack2x16float
and
unpack2x16float
which
/
/
/
operate
on
f16
-
precision
values
stored
in
f32
s
.
/
/
/
/
/
/
Not
supported
by
Vulkan
on
Mesa
when
[
Features
:
:
SHADER_F16
]
is
absent
.
const
SHADER_F16_IN_F32
=
1
<
<
23
;
}
}
impl
DownlevelFlags
{
#
[
must_use
]
pub
const
fn
compliant
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
Self
:
:
all
(
)
.
bits
(
)
&
!
Self
:
:
ANISOTROPIC_FILTERING
.
bits
(
)
)
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
ShaderModel
{
Sm2
Sm4
Sm5
}
