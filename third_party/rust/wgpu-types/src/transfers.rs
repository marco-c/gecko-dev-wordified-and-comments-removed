use
crate
:
:
{
BufferAddress
Extent3d
TexelCopyBufferLayout
TextureAspect
TextureFormat
}
;
impl
TexelCopyBufferLayout
{
#
[
inline
(
always
)
]
pub
fn
get_buffer_texture_copy_info
(
&
self
format
:
TextureFormat
aspect
:
TextureAspect
copy_size
:
&
Extent3d
)
-
>
BufferTextureCopyInfo
{
let
copy_width
=
copy_size
.
width
as
BufferAddress
;
let
copy_height
=
copy_size
.
height
as
BufferAddress
;
let
depth_or_array_layers
=
copy_size
.
depth_or_array_layers
as
BufferAddress
;
let
block_size_bytes
=
format
.
block_copy_size
(
Some
(
aspect
)
)
.
unwrap
(
)
as
BufferAddress
;
let
(
block_width
block_height
)
=
format
.
block_dimensions
(
)
;
let
block_width_texels
=
block_width
as
BufferAddress
;
let
block_height_texels
=
block_height
as
BufferAddress
;
let
width_blocks
=
copy_width
.
div_ceil
(
block_width_texels
)
;
let
height_blocks
=
copy_height
.
div_ceil
(
block_height_texels
)
;
let
row_bytes_dense
=
width_blocks
*
block_size_bytes
;
let
row_stride_bytes
=
self
.
bytes_per_row
.
map_or
(
row_bytes_dense
u64
:
:
from
)
;
let
image_stride_rows
=
self
.
rows_per_image
.
map_or
(
height_blocks
u64
:
:
from
)
;
let
image_stride_bytes
=
row_stride_bytes
*
image_stride_rows
;
let
image_rows_dense
=
height_blocks
;
let
image_bytes_dense
=
image_rows_dense
.
saturating_sub
(
1
)
*
row_stride_bytes
+
row_bytes_dense
;
let
mut
bytes_in_copy
=
image_stride_bytes
*
depth_or_array_layers
.
saturating_sub
(
1
)
;
if
height_blocks
>
0
{
bytes_in_copy
+
=
row_stride_bytes
*
(
height_blocks
-
1
)
+
row_bytes_dense
;
}
BufferTextureCopyInfo
{
copy_width
copy_height
depth_or_array_layers
offset
:
self
.
offset
block_size_bytes
block_width_texels
block_height_texels
width_blocks
height_blocks
row_bytes_dense
row_stride_bytes
image_stride_rows
image_stride_bytes
image_rows_dense
image_bytes_dense
bytes_in_copy
}
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
BufferTextureCopyInfo
{
pub
copy_width
:
u64
pub
copy_height
:
u64
pub
depth_or_array_layers
:
u64
pub
offset
:
u64
pub
block_size_bytes
:
u64
pub
block_width_texels
:
u64
pub
block_height_texels
:
u64
pub
width_blocks
:
u64
pub
height_blocks
:
u64
pub
row_bytes_dense
:
u64
pub
row_stride_bytes
:
u64
pub
image_stride_rows
:
u64
pub
image_stride_bytes
:
u64
pub
image_rows_dense
:
u64
pub
image_bytes_dense
:
u64
pub
bytes_in_copy
:
u64
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
struct
LTDTest
{
layout
:
TexelCopyBufferLayout
format
:
TextureFormat
aspect
:
TextureAspect
copy_size
:
Extent3d
expected_result
:
BufferTextureCopyInfo
}
impl
LTDTest
{
#
[
track_caller
]
fn
run
(
&
self
)
{
let
linear_texture_data
=
self
.
layout
.
get_buffer_texture_copy_info
(
self
.
format
self
.
aspect
&
self
.
copy_size
)
;
assert_eq
!
(
linear_texture_data
self
.
expected_result
)
;
}
}
#
[
test
]
fn
linear_texture_data_1d_copy
(
)
{
let
mut
test
=
LTDTest
{
layout
:
TexelCopyBufferLayout
{
offset
:
0
bytes_per_row
:
None
rows_per_image
:
None
}
format
:
TextureFormat
:
:
Rgba8Unorm
aspect
:
TextureAspect
:
:
All
copy_size
:
Extent3d
{
width
:
4
height
:
1
depth_or_array_layers
:
1
}
expected_result
:
BufferTextureCopyInfo
{
copy_width
:
4
copy_height
:
1
depth_or_array_layers
:
1
offset
:
0
block_size_bytes
:
4
block_width_texels
:
1
block_height_texels
:
1
width_blocks
:
4
height_blocks
:
1
row_bytes_dense
:
16
row_stride_bytes
:
16
image_stride_rows
:
1
image_stride_bytes
:
16
image_rows_dense
:
1
image_bytes_dense
:
16
bytes_in_copy
:
16
}
}
;
test
.
run
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
32
)
;
test
.
expected_result
.
row_stride_bytes
=
32
;
test
.
expected_result
.
image_stride_bytes
=
32
;
test
.
run
(
)
;
test
.
layout
.
rows_per_image
=
Some
(
4
)
;
test
.
expected_result
.
image_stride_bytes
=
128
;
test
.
expected_result
.
image_stride_rows
=
4
;
test
.
run
(
)
;
test
.
layout
.
offset
=
4
;
test
.
expected_result
.
offset
=
4
;
test
.
run
(
)
;
}
#
[
test
]
fn
linear_texture_data_2d_3d_copy
(
)
{
let
mut
test
=
LTDTest
{
layout
:
TexelCopyBufferLayout
{
offset
:
0
bytes_per_row
:
None
rows_per_image
:
None
}
format
:
TextureFormat
:
:
Rgba8Unorm
aspect
:
TextureAspect
:
:
All
copy_size
:
Extent3d
{
width
:
7
height
:
12
depth_or_array_layers
:
1
}
expected_result
:
BufferTextureCopyInfo
{
copy_width
:
7
copy_height
:
12
depth_or_array_layers
:
1
offset
:
0
block_size_bytes
:
4
block_width_texels
:
1
block_height_texels
:
1
width_blocks
:
7
height_blocks
:
12
row_bytes_dense
:
4
*
7
row_stride_bytes
:
4
*
7
image_stride_rows
:
12
image_stride_bytes
:
4
*
7
*
12
image_rows_dense
:
12
image_bytes_dense
:
4
*
7
*
12
bytes_in_copy
:
4
*
7
*
12
}
}
;
test
.
run
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
48
)
;
test
.
expected_result
.
row_stride_bytes
=
48
;
test
.
expected_result
.
image_stride_bytes
=
48
*
12
;
test
.
expected_result
.
image_bytes_dense
=
48
*
11
+
(
4
*
7
)
;
test
.
expected_result
.
bytes_in_copy
=
48
*
11
+
(
4
*
7
)
;
test
.
copy_size
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
bytes_in_copy
=
48
*
12
*
3
+
48
*
11
+
(
4
*
7
)
;
test
.
run
(
)
;
}
#
[
test
]
fn
linear_texture_data_2d_3d_compressed_copy
(
)
{
let
mut
test
=
LTDTest
{
layout
:
TexelCopyBufferLayout
{
offset
:
0
bytes_per_row
:
None
rows_per_image
:
None
}
format
:
TextureFormat
:
:
Bc1RgbaUnorm
aspect
:
TextureAspect
:
:
All
copy_size
:
Extent3d
{
width
:
7
height
:
13
depth_or_array_layers
:
1
}
expected_result
:
BufferTextureCopyInfo
{
copy_width
:
7
copy_height
:
13
depth_or_array_layers
:
1
offset
:
0
block_size_bytes
:
8
block_width_texels
:
4
block_height_texels
:
4
width_blocks
:
2
height_blocks
:
4
row_bytes_dense
:
8
*
2
row_stride_bytes
:
8
*
2
image_stride_rows
:
4
image_stride_bytes
:
8
*
2
*
4
image_rows_dense
:
4
image_bytes_dense
:
8
*
2
*
4
bytes_in_copy
:
8
*
2
*
4
}
}
;
test
.
run
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
48
)
;
test
.
expected_result
.
row_stride_bytes
=
48
;
test
.
expected_result
.
image_stride_bytes
=
48
*
4
;
test
.
expected_result
.
image_bytes_dense
=
48
*
3
+
(
8
*
2
)
;
test
.
expected_result
.
bytes_in_copy
=
48
*
3
+
(
8
*
2
)
;
test
.
run
(
)
;
test
.
layout
.
rows_per_image
=
Some
(
8
)
;
test
.
expected_result
.
image_stride_bytes
=
48
*
8
;
test
.
expected_result
.
image_stride_rows
=
8
;
test
.
run
(
)
;
test
.
copy_size
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
bytes_in_copy
=
48
*
8
*
3
+
48
*
3
+
(
8
*
2
)
;
test
.
run
(
)
;
}
}
