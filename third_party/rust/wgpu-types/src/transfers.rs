use
crate
:
:
{
BufferAddress
Extent3d
TexelCopyBufferLayout
TextureAspect
TextureFormat
}
;
impl
TexelCopyBufferLayout
{
#
[
doc
(
hidden
)
]
#
[
inline
(
always
)
]
pub
fn
get_buffer_texture_copy_info
(
&
self
format
:
TextureFormat
aspect
:
TextureAspect
copy_size
:
&
Extent3d
)
-
>
Result
<
BufferTextureCopyInfo
Error
>
{
let
copy_width
=
BufferAddress
:
:
from
(
copy_size
.
width
)
;
let
copy_height
=
BufferAddress
:
:
from
(
copy_size
.
height
)
;
let
depth_or_array_layers
=
BufferAddress
:
:
from
(
copy_size
.
depth_or_array_layers
)
;
let
block_size_bytes
=
BufferAddress
:
:
from
(
format
.
block_copy_size
(
Some
(
aspect
)
)
.
unwrap
(
)
)
;
let
(
block_width
block_height
)
=
format
.
block_dimensions
(
)
;
let
block_width_texels
=
BufferAddress
:
:
from
(
block_width
)
;
let
block_height_texels
=
BufferAddress
:
:
from
(
block_height
)
;
let
width_blocks
=
copy_width
.
div_ceil
(
block_width_texels
)
;
let
height_blocks
=
copy_height
.
div_ceil
(
block_height_texels
)
;
let
row_bytes_dense
=
width_blocks
*
block_size_bytes
;
let
row_stride_bytes
=
match
self
.
bytes_per_row
.
map
(
BufferAddress
:
:
from
)
{
Some
(
bytes_per_row
)
if
bytes_per_row
>
=
row_bytes_dense
=
>
bytes_per_row
Some
(
_
)
=
>
return
Err
(
Error
:
:
InvalidBytesPerRow
)
None
=
>
row_bytes_dense
}
;
let
image_rows_dense
=
height_blocks
;
let
image_stride_rows
=
match
self
.
rows_per_image
.
map
(
BufferAddress
:
:
from
)
{
Some
(
rows_per_image
)
if
rows_per_image
>
=
image_rows_dense
=
>
rows_per_image
Some
(
_
)
=
>
return
Err
(
Error
:
:
InvalidRowsPerImage
)
None
=
>
image_rows_dense
}
;
let
image_bytes_dense
=
match
image_rows_dense
.
checked_sub
(
1
)
{
Some
(
rows_minus_one
)
=
>
rows_minus_one
.
checked_mul
(
row_stride_bytes
)
.
ok_or
(
Error
:
:
ImageBytesOverflow
(
false
)
)
?
.
checked_add
(
row_bytes_dense
)
.
ok_or
(
Error
:
:
ImageBytesOverflow
(
true
)
)
?
None
=
>
0
}
;
let
image_stride_bytes
=
row_stride_bytes
.
checked_mul
(
image_stride_rows
)
.
ok_or
(
Error
:
:
ImageStrideOverflow
)
?
;
let
bytes_in_copy
=
if
depth_or_array_layers
<
=
1
{
depth_or_array_layers
*
image_bytes_dense
}
else
{
(
depth_or_array_layers
-
1
)
.
checked_mul
(
image_stride_bytes
)
.
ok_or
(
Error
:
:
ArraySizeOverflow
(
false
)
)
?
.
checked_add
(
image_bytes_dense
)
.
ok_or
(
Error
:
:
ArraySizeOverflow
(
true
)
)
?
}
;
Ok
(
BufferTextureCopyInfo
{
copy_width
copy_height
depth_or_array_layers
offset
:
self
.
offset
block_size_bytes
block_width_texels
block_height_texels
width_blocks
height_blocks
row_bytes_dense
row_stride_bytes
image_stride_rows
image_stride_bytes
image_rows_dense
image_bytes_dense
bytes_in_copy
}
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
struct
BufferTextureCopyInfo
{
pub
copy_width
:
u64
pub
copy_height
:
u64
pub
depth_or_array_layers
:
u64
pub
offset
:
u64
pub
block_size_bytes
:
u64
pub
block_width_texels
:
u64
pub
block_height_texels
:
u64
pub
width_blocks
:
u64
pub
height_blocks
:
u64
pub
row_bytes_dense
:
u64
pub
row_stride_bytes
:
u64
pub
image_stride_rows
:
u64
pub
image_stride_bytes
:
u64
pub
image_rows_dense
:
u64
pub
image_bytes_dense
:
u64
pub
bytes_in_copy
:
u64
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
BufferTextureCopyInfoError
{
InvalidBytesPerRow
InvalidRowsPerImage
ImageStrideOverflow
ImageBytesOverflow
(
bool
)
ArraySizeOverflow
(
bool
)
}
type
Error
=
BufferTextureCopyInfoError
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
derive
(
Clone
)
]
struct
LTDTest
{
layout
:
TexelCopyBufferLayout
format
:
TextureFormat
aspect
:
TextureAspect
copy_size
:
Extent3d
expected_result
:
BufferTextureCopyInfo
expected_error
:
Option
<
Error
>
}
impl
LTDTest
{
#
[
track_caller
]
fn
run
(
&
self
)
{
let
linear_texture_data
=
self
.
layout
.
get_buffer_texture_copy_info
(
self
.
format
self
.
aspect
&
self
.
copy_size
)
;
let
expected
=
match
self
.
expected_error
{
Some
(
err
)
=
>
Err
(
err
)
None
=
>
Ok
(
self
.
expected_result
)
}
;
assert_eq
!
(
linear_texture_data
expected
)
;
}
}
#
[
test
]
fn
linear_texture_data_1d_copy
(
)
{
let
mut
test
=
LTDTest
{
layout
:
TexelCopyBufferLayout
{
offset
:
0
bytes_per_row
:
None
rows_per_image
:
None
}
format
:
TextureFormat
:
:
Rgba8Unorm
aspect
:
TextureAspect
:
:
All
copy_size
:
Extent3d
{
width
:
4
height
:
1
depth_or_array_layers
:
1
}
expected_result
:
BufferTextureCopyInfo
{
copy_width
:
4
copy_height
:
1
depth_or_array_layers
:
1
offset
:
0
block_size_bytes
:
4
block_width_texels
:
1
block_height_texels
:
1
width_blocks
:
4
height_blocks
:
1
row_bytes_dense
:
16
row_stride_bytes
:
16
image_stride_rows
:
1
image_stride_bytes
:
16
image_rows_dense
:
1
image_bytes_dense
:
16
bytes_in_copy
:
16
}
expected_error
:
None
}
;
test
.
run
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
32
)
;
test
.
expected_result
.
row_stride_bytes
=
32
;
test
.
expected_result
.
image_stride_bytes
=
32
;
test
.
run
(
)
;
test
.
layout
.
rows_per_image
=
Some
(
4
)
;
test
.
expected_result
.
image_stride_bytes
=
128
;
test
.
expected_result
.
image_stride_rows
=
4
;
test
.
run
(
)
;
test
.
layout
.
offset
=
4
;
test
.
expected_result
.
offset
=
4
;
test
.
run
(
)
;
}
#
[
test
]
fn
linear_texture_data_2d_3d_copy
(
)
{
let
template
=
LTDTest
{
layout
:
TexelCopyBufferLayout
{
offset
:
0
bytes_per_row
:
None
rows_per_image
:
None
}
format
:
TextureFormat
:
:
Rgba8Unorm
aspect
:
TextureAspect
:
:
All
copy_size
:
Extent3d
{
width
:
7
height
:
12
depth_or_array_layers
:
1
}
expected_result
:
BufferTextureCopyInfo
{
copy_width
:
7
copy_height
:
12
depth_or_array_layers
:
1
offset
:
0
block_size_bytes
:
4
block_width_texels
:
1
block_height_texels
:
1
width_blocks
:
7
height_blocks
:
12
row_bytes_dense
:
4
*
7
row_stride_bytes
:
4
*
7
image_stride_rows
:
12
image_stride_bytes
:
4
*
7
*
12
image_rows_dense
:
12
image_bytes_dense
:
4
*
7
*
12
bytes_in_copy
:
4
*
7
*
12
}
expected_error
:
None
}
;
let
mut
test
=
template
.
clone
(
)
;
test
.
run
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
48
)
;
test
.
expected_result
.
row_stride_bytes
=
48
;
test
.
expected_result
.
image_stride_bytes
=
48
*
12
;
test
.
expected_result
.
image_bytes_dense
=
48
*
11
+
(
4
*
7
)
;
test
.
expected_result
.
bytes_in_copy
=
48
*
11
+
(
4
*
7
)
;
test
.
run
(
)
;
test
.
copy_size
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
bytes_in_copy
=
48
*
12
*
3
+
48
*
11
+
(
4
*
7
)
;
test
.
run
(
)
;
test
.
layout
.
rows_per_image
=
Some
(
20
)
;
test
.
expected_result
.
image_stride_rows
=
20
;
test
.
expected_result
.
image_stride_bytes
=
20
*
test
.
expected_result
.
row_stride_bytes
;
test
.
expected_result
.
bytes_in_copy
=
48
*
20
*
3
+
48
*
11
+
(
4
*
7
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
20
)
;
test
.
expected_error
=
Some
(
Error
:
:
InvalidBytesPerRow
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
layout
.
rows_per_image
=
Some
(
8
)
;
test
.
expected_error
=
Some
(
Error
:
:
InvalidRowsPerImage
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
copy_size
.
width
=
u32
:
:
MAX
;
test
.
copy_size
.
height
=
u32
:
:
MAX
;
test
.
expected_error
=
Some
(
Error
:
:
ImageBytesOverflow
(
false
)
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
copy_size
.
width
=
0x8000_0000
;
test
.
copy_size
.
height
=
0x8000_0000
;
test
.
expected_error
=
Some
(
Error
:
:
ImageBytesOverflow
(
true
)
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
copy_size
.
width
=
0x8000_0000
;
test
.
layout
.
rows_per_image
=
Some
(
0x8000_0000
)
;
test
.
expected_result
.
image_stride_rows
=
0x8000_0000
;
test
.
expected_error
=
Some
(
Error
:
:
ImageStrideOverflow
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
copy_size
.
depth_or_array_layers
=
0x8000_0000
;
test
.
copy_size
.
width
=
0x1_0000
;
test
.
copy_size
.
height
=
0x1_0000
;
test
.
expected_error
=
Some
(
Error
:
:
ArraySizeOverflow
(
false
)
)
;
test
.
run
(
)
;
let
mut
test
=
template
.
clone
(
)
;
test
.
copy_size
.
depth_or_array_layers
=
0x3fff_8001
;
test
.
copy_size
.
width
=
0x1_0001
;
test
.
copy_size
.
height
=
0x1_0001
;
test
.
expected_error
=
Some
(
Error
:
:
ArraySizeOverflow
(
true
)
)
;
test
.
run
(
)
;
}
#
[
test
]
fn
linear_texture_data_2d_3d_compressed_copy
(
)
{
let
mut
test
=
LTDTest
{
layout
:
TexelCopyBufferLayout
{
offset
:
0
bytes_per_row
:
None
rows_per_image
:
None
}
format
:
TextureFormat
:
:
Bc1RgbaUnorm
aspect
:
TextureAspect
:
:
All
copy_size
:
Extent3d
{
width
:
7
height
:
13
depth_or_array_layers
:
1
}
expected_result
:
BufferTextureCopyInfo
{
copy_width
:
7
copy_height
:
13
depth_or_array_layers
:
1
offset
:
0
block_size_bytes
:
8
block_width_texels
:
4
block_height_texels
:
4
width_blocks
:
2
height_blocks
:
4
row_bytes_dense
:
8
*
2
row_stride_bytes
:
8
*
2
image_stride_rows
:
4
image_stride_bytes
:
8
*
2
*
4
image_rows_dense
:
4
image_bytes_dense
:
8
*
2
*
4
bytes_in_copy
:
8
*
2
*
4
}
expected_error
:
None
}
;
test
.
run
(
)
;
test
.
layout
.
bytes_per_row
=
Some
(
48
)
;
test
.
expected_result
.
row_stride_bytes
=
48
;
test
.
expected_result
.
image_stride_bytes
=
48
*
4
;
test
.
expected_result
.
image_bytes_dense
=
48
*
3
+
(
8
*
2
)
;
test
.
expected_result
.
bytes_in_copy
=
48
*
3
+
(
8
*
2
)
;
test
.
run
(
)
;
test
.
layout
.
rows_per_image
=
Some
(
8
)
;
test
.
expected_result
.
image_stride_bytes
=
48
*
8
;
test
.
expected_result
.
image_stride_rows
=
8
;
test
.
run
(
)
;
test
.
copy_size
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
depth_or_array_layers
=
4
;
test
.
expected_result
.
bytes_in_copy
=
48
*
8
*
3
+
48
*
3
+
(
8
*
2
)
;
test
.
run
(
)
;
}
}
