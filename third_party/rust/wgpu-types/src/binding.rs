use
core
:
:
num
:
:
NonZeroU32
;
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
crate
:
:
{
link_to_wgpu_docs
link_to_wgpu_item
BufferSize
}
;
#
[
cfg
(
doc
)
]
use
crate
:
:
Features
;
#
[
doc
=
link_to_wgpu_item
!
(
enum
BindingResource
)
]
#
[
doc
=
link_to_wgpu_item
!
(
struct
BindGroup
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BindingType
{
Buffer
{
ty
:
BufferBindingType
#
[
doc
=
link_to_wgpu_docs
!
(
[
"
RPsbg
"
]
:
"
struct
.
RenderPass
.
html
#
method
.
set_bind_group
"
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
has_dynamic_offset
:
bool
#
[
doc
=
link_to_wgpu_item
!
(
struct
BufferBinding
)
]
#
[
doc
=
link_to_wgpu_docs
!
(
[
"
create_bind_group
"
]
:
"
struct
.
Device
.
html
#
method
.
create_bind_group
"
)
]
#
[
doc
=
link_to_wgpu_docs
!
(
[
"
BindingResource
:
:
Buffer
"
]
:
"
enum
.
BindingResource
.
html
#
variant
.
Buffer
"
)
]
#
[
doc
=
link_to_wgpu_docs
!
(
[
"
create_render_pipeline
"
]
:
"
struct
.
Device
.
html
#
method
.
create_render_pipeline
"
)
]
#
[
doc
=
link_to_wgpu_docs
!
(
[
"
create_compute_pipeline
"
]
:
"
struct
.
Device
.
html
#
method
.
create_compute_pipeline
"
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
min_binding_size
:
Option
<
BufferSize
>
}
Sampler
(
SamplerBindingType
)
Texture
{
sample_type
:
crate
:
:
TextureSampleType
view_dimension
:
crate
:
:
TextureViewDimension
multisampled
:
bool
}
StorageTexture
{
access
:
crate
:
:
StorageTextureAccess
format
:
crate
:
:
TextureFormat
view_dimension
:
crate
:
:
TextureViewDimension
}
AccelerationStructure
{
vertex_return
:
bool
}
ExternalTexture
}
impl
BindingType
{
#
[
must_use
]
pub
fn
has_dynamic_offset
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Buffer
{
has_dynamic_offset
.
.
}
=
>
has_dynamic_offset
_
=
>
false
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Describes
the
shader
stages
that
a
binding
will
be
visible
from
.
/
/
/
/
/
/
These
can
be
combined
so
something
that
is
visible
from
both
vertex
and
fragment
shaders
can
be
defined
as
:
/
/
/
/
/
/
ShaderStages
:
:
VERTEX
|
ShaderStages
:
:
FRAGMENT
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
ShaderStages
:
u32
{
/
/
/
Binding
is
not
visible
from
any
shader
stage
.
const
NONE
=
0
;
/
/
/
Binding
is
visible
from
the
vertex
shader
of
a
render
pipeline
.
const
VERTEX
=
1
<
<
0
;
/
/
/
Binding
is
visible
from
the
fragment
shader
of
a
render
pipeline
.
const
FRAGMENT
=
1
<
<
1
;
/
/
/
Binding
is
visible
from
the
compute
shader
of
a
compute
pipeline
.
const
COMPUTE
=
1
<
<
2
;
/
/
/
Binding
is
visible
from
the
vertex
and
fragment
shaders
of
a
render
pipeline
.
const
VERTEX_FRAGMENT
=
Self
:
:
VERTEX
.
bits
(
)
|
Self
:
:
FRAGMENT
.
bits
(
)
;
/
/
/
Binding
is
visible
from
the
task
shader
of
a
mesh
pipeline
.
const
TASK
=
1
<
<
3
;
/
/
/
Binding
is
visible
from
the
mesh
shader
of
a
mesh
pipeline
.
const
MESH
=
1
<
<
4
;
}
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BufferBindingType
{
#
[
default
]
Uniform
Storage
{
read_only
:
bool
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
SamplerBindingType
{
Filtering
NonFiltering
Comparison
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
BindGroupLayoutEntry
{
pub
binding
:
u32
pub
visibility
:
ShaderStages
pub
ty
:
BindingType
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
count
:
Option
<
NonZeroU32
>
}
