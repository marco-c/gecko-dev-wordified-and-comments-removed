#
!
[
allow
(
broken_intra_doc_links
clippy
:
:
match_like_matches_macro
)
]
#
!
[
warn
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
{
num
:
:
NonZeroU32
ops
:
:
Range
}
;
pub
type
BufferAddress
=
u64
;
pub
type
BufferSize
=
std
:
:
num
:
:
NonZeroU64
;
pub
type
ShaderLocation
=
u32
;
pub
type
DynamicOffset
=
u32
;
pub
const
COPY_BYTES_PER_ROW_ALIGNMENT
:
u32
=
256
;
pub
const
QUERY_RESOLVE_BUFFER_ALIGNMENT
:
BufferAddress
=
256
;
pub
const
COPY_BUFFER_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
MAP_ALIGNMENT
:
BufferAddress
=
8
;
pub
const
VERTEX_STRIDE_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
PUSH_CONSTANT_ALIGNMENT
:
u32
=
4
;
pub
const
QUERY_SET_MAX_QUERIES
:
u32
=
8192
;
pub
const
QUERY_SIZE
:
u32
=
8
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Backend
{
Empty
=
0
Vulkan
=
1
Metal
=
2
Dx12
=
3
Dx11
=
4
Gl
=
5
BrowserWebGpu
=
6
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PowerPreference
{
LowPower
=
0
HighPerformance
=
1
}
impl
Default
for
PowerPreference
{
fn
default
(
)
-
>
Self
{
Self
:
:
LowPower
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Represents
the
backends
that
wgpu
will
use
.
#
[
repr
(
transparent
)
]
pub
struct
Backends
:
u32
{
/
/
/
Supported
on
Windows
Linux
/
Android
and
macOS
/
iOS
via
Vulkan
Portability
(
with
the
Vulkan
feature
enabled
)
const
VULKAN
=
1
<
<
Backend
:
:
Vulkan
as
u32
;
/
/
/
Currently
unsupported
const
GL
=
1
<
<
Backend
:
:
Gl
as
u32
;
/
/
/
Supported
on
macOS
/
iOS
const
METAL
=
1
<
<
Backend
:
:
Metal
as
u32
;
/
/
/
Supported
on
Windows
10
const
DX12
=
1
<
<
Backend
:
:
Dx12
as
u32
;
/
/
/
Supported
on
Windows
7
+
const
DX11
=
1
<
<
Backend
:
:
Dx11
as
u32
;
/
/
/
Supported
when
targeting
the
web
through
webassembly
const
BROWSER_WEBGPU
=
1
<
<
Backend
:
:
BrowserWebGpu
as
u32
;
/
/
/
All
the
apis
that
wgpu
offers
first
tier
of
support
for
.
/
/
/
/
/
/
Vulkan
+
Metal
+
DX12
+
Browser
WebGPU
const
PRIMARY
=
Self
:
:
VULKAN
.
bits
|
Self
:
:
METAL
.
bits
|
Self
:
:
DX12
.
bits
|
Self
:
:
BROWSER_WEBGPU
.
bits
;
/
/
/
All
the
apis
that
wgpu
offers
second
tier
of
support
for
.
These
may
/
/
/
be
unsupported
/
still
experimental
.
/
/
/
/
/
/
OpenGL
+
DX11
const
SECONDARY
=
Self
:
:
GL
.
bits
|
Self
:
:
DX11
.
bits
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
Backends
)
;
impl
From
<
Backend
>
for
Backends
{
fn
from
(
backend
:
Backend
)
-
>
Self
{
Self
:
:
from_bits
(
1
<
<
backend
as
u32
)
.
unwrap
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RequestAdapterOptions
<
S
>
{
pub
power_preference
:
PowerPreference
pub
compatible_surface
:
Option
<
S
>
}
impl
<
S
>
Default
for
RequestAdapterOptions
<
S
>
{
fn
default
(
)
-
>
Self
{
Self
{
power_preference
:
PowerPreference
:
:
default
(
)
compatible_surface
:
None
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Features
that
are
not
guaranteed
to
be
supported
.
/
/
/
/
/
/
These
are
either
part
of
the
webgpu
standard
or
are
extension
features
supported
by
/
/
/
wgpu
when
targeting
native
.
/
/
/
/
/
/
If
you
want
to
use
a
feature
you
need
to
first
verify
that
the
adapter
supports
/
/
/
the
feature
.
If
the
adapter
does
not
support
the
feature
requesting
a
device
with
it
enabled
/
/
/
will
panic
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Default
)
]
pub
struct
Features
:
u64
{
/
/
/
By
default
polygon
depth
is
clipped
to
0
-
1
range
.
Anything
outside
of
that
range
/
/
/
is
rejected
and
respective
fragments
are
not
touched
.
/
/
/
/
/
/
With
this
extension
we
can
force
clamping
of
the
polygon
depth
to
0
-
1
.
That
allows
/
/
/
shadow
map
occluders
to
be
rendered
into
a
tighter
depth
range
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
desktops
/
/
/
-
some
mobile
chips
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
DEPTH_CLAMPING
=
1
<
<
0
;
/
/
/
Enables
BCn
family
of
compressed
textures
.
All
BCn
textures
use
4x4
pixel
blocks
/
/
/
with
8
or
16
bytes
per
block
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
BCn
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
desktops
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TEXTURE_COMPRESSION_BC
=
1
<
<
1
;
/
/
/
Enables
use
of
Timestamp
Queries
.
These
queries
tell
the
current
gpu
timestamp
when
/
/
/
all
work
before
the
query
is
finished
.
Call
[
CommandEncoder
:
:
write_timestamp
]
/
/
/
[
RenderPassEncoder
:
:
write_timestamp
]
or
[
ComputePassEncoder
:
:
write_timestamp
]
to
/
/
/
write
out
a
timestamp
.
/
/
/
/
/
/
They
must
be
resolved
using
[
CommandEncoder
:
:
resolve_query_sets
]
into
a
buffer
/
/
/
then
the
result
must
be
multiplied
by
the
timestamp
period
[
Device
:
:
get_timestamp_period
]
/
/
/
to
get
the
timestamp
in
nanoseconds
.
Multiple
timestamps
can
then
be
diffed
to
get
the
/
/
/
time
for
operations
between
them
to
finish
.
/
/
/
/
/
/
Due
to
gfx
-
hal
limitations
this
is
only
supported
on
vulkan
for
now
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
(
works
)
/
/
/
-
DX12
(
works
)
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TIMESTAMP_QUERY
=
1
<
<
2
;
/
/
/
Enables
use
of
Pipeline
Statistics
Queries
.
These
queries
tell
the
count
of
various
operations
/
/
/
performed
between
the
start
and
stop
call
.
Call
[
RenderPassEncoder
:
:
begin_pipeline_statistics_query
]
to
start
/
/
/
a
query
then
call
[
RenderPassEncoder
:
:
end_pipeline_statistics_query
]
to
stop
one
.
/
/
/
/
/
/
They
must
be
resolved
using
[
CommandEncoder
:
:
resolve_query_sets
]
into
a
buffer
.
/
/
/
The
rules
on
how
these
resolve
into
buffers
are
detailed
in
the
documentation
for
[
PipelineStatisticsTypes
]
.
/
/
/
/
/
/
Due
to
gfx
-
hal
limitations
this
is
only
supported
on
vulkan
for
now
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
(
works
)
/
/
/
-
DX12
(
works
)
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
PIPELINE_STATISTICS_QUERY
=
1
<
<
3
;
/
/
/
Webgpu
only
allows
the
MAP_READ
and
MAP_WRITE
buffer
usage
to
be
matched
with
/
/
/
COPY_DST
and
COPY_SRC
respectively
.
This
removes
this
requirement
.
/
/
/
/
/
/
This
is
only
beneficial
on
systems
that
share
memory
between
CPU
and
GPU
.
If
enabled
/
/
/
on
a
system
that
doesn
'
t
this
can
severely
hinder
performance
.
Only
use
if
you
understand
/
/
/
the
consequences
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
All
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MAPPABLE_PRIMARY_BUFFERS
=
1
<
<
16
;
/
/
/
Allows
the
user
to
create
uniform
arrays
of
textures
in
shaders
:
/
/
/
/
/
/
eg
.
uniform
texture2D
textures
[
10
]
.
/
/
/
/
/
/
If
[
Features
:
:
STORAGE_RESOURCE_BINDING_ARRAY
]
is
supported
as
well
as
this
the
user
/
/
/
may
also
create
uniform
arrays
of
storage
textures
.
/
/
/
/
/
/
eg
.
uniform
image2D
textures
[
10
]
.
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
dynamically
uniform
/
/
/
values
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
TEXTURE_BINDING_ARRAY
=
1
<
<
17
;
/
/
/
Allows
the
user
to
create
arrays
of
buffers
in
shaders
:
/
/
/
/
/
/
eg
.
uniform
myBuffer
{
.
.
.
.
}
buffer_array
[
10
]
.
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
dynamically
uniform
/
/
/
values
.
/
/
/
/
/
/
If
[
Features
:
:
STORAGE_RESOURCE_BINDING_ARRAY
]
is
supported
as
well
as
this
the
user
/
/
/
may
also
create
arrays
of
storage
buffers
.
/
/
/
/
/
/
eg
.
buffer
myBuffer
{
.
.
.
}
buffer_array
[
10
]
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
BUFFER_BINDING_ARRAY
=
1
<
<
18
;
/
/
/
Allows
the
user
to
create
uniform
arrays
of
storage
buffers
or
textures
in
shaders
/
/
/
if
resp
.
[
Features
:
:
BUFFER_BINDING_ARRAY
]
or
[
Features
:
:
TEXTURE_BINDING_ARRAY
]
/
/
/
is
supported
.
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
dynamically
uniform
/
/
/
values
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Metal
(
with
MSL
2
.
2
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
STORAGE_RESOURCE_BINDING_ARRAY
=
1
<
<
19
;
/
/
/
Allows
shaders
to
index
sampled
texture
and
storage
buffer
resource
arrays
with
dynamically
non
-
uniform
values
:
/
/
/
/
/
/
eg
.
texture_array
[
vertex_data
]
/
/
/
/
/
/
In
order
to
use
this
capability
the
corresponding
GLSL
extension
must
be
enabled
like
so
:
/
/
/
/
/
/
#
extension
GL_EXT_nonuniform_qualifier
:
require
/
/
/
/
/
/
and
then
used
either
as
nonuniformEXT
qualifier
in
variable
declaration
:
/
/
/
/
/
/
eg
.
layout
(
location
=
0
)
nonuniformEXT
flat
in
int
vertex_data
;
/
/
/
/
/
/
or
as
nonuniformEXT
constructor
:
/
/
/
/
/
/
eg
.
texture_array
[
nonuniformEXT
(
vertex_data
)
]
/
/
/
/
/
/
HLSL
does
not
need
any
extension
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
shaderSampledImageArrayNonUniformIndexing
&
shaderStorageBufferArrayNonUniformIndexing
feature
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING
=
1
<
<
20
;
/
/
/
Allows
shaders
to
index
uniform
buffer
and
storage
texture
resource
arrays
with
dynamically
non
-
uniform
values
:
/
/
/
/
/
/
eg
.
texture_array
[
vertex_data
]
/
/
/
/
/
/
In
order
to
use
this
capability
the
corresponding
GLSL
extension
must
be
enabled
like
so
:
/
/
/
/
/
/
#
extension
GL_EXT_nonuniform_qualifier
:
require
/
/
/
/
/
/
and
then
used
either
as
nonuniformEXT
qualifier
in
variable
declaration
:
/
/
/
/
/
/
eg
.
layout
(
location
=
0
)
nonuniformEXT
flat
in
int
vertex_data
;
/
/
/
/
/
/
or
as
nonuniformEXT
constructor
:
/
/
/
/
/
/
eg
.
texture_array
[
nonuniformEXT
(
vertex_data
)
]
/
/
/
/
/
/
HLSL
does
not
need
any
extension
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
shaderUniformBufferArrayNonUniformIndexing
&
shaderStorageTextureArrayNonUniformIndexing
feature
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
UNIFORM_BUFFER_AND_STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING
=
1
<
<
21
;
/
/
/
Allows
the
user
to
create
unsized
uniform
arrays
of
bindings
:
/
/
/
/
/
/
eg
.
uniform
texture2D
textures
[
]
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
runtimeDescriptorArray
feature
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
UNSIZED_BINDING_ARRAY
=
1
<
<
22
;
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
multi_draw_indirect
]
and
[
RenderPass
:
:
multi_draw_indexed_indirect
]
.
/
/
/
/
/
/
Allows
multiple
indirect
calls
to
be
dispatched
from
a
single
buffer
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MULTI_DRAW_INDIRECT
=
1
<
<
23
;
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
multi_draw_indirect_count
]
and
[
RenderPass
:
:
multi_draw_indexed_indirect_count
]
.
/
/
/
/
/
/
This
allows
the
use
of
a
buffer
containing
the
actual
number
of
draw
calls
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_KHR_draw_indirect_count
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MULTI_DRAW_INDIRECT_COUNT
=
1
<
<
24
;
/
/
/
Allows
the
use
of
push
constants
:
small
fast
bits
of
memory
that
can
be
updated
/
/
/
inside
a
[
RenderPass
]
.
/
/
/
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
set_push_constants
]
provide
a
non
-
empty
array
/
/
/
to
[
PipelineLayoutDescriptor
]
and
provide
a
non
-
zero
limit
to
[
Limits
:
:
max_push_constant_size
]
.
/
/
/
/
/
/
A
block
of
push
constants
can
be
declared
with
layout
(
push_constant
)
uniform
Name
{
.
.
}
in
shaders
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
-
DX11
(
emulated
with
uniforms
)
/
/
/
-
OpenGL
(
emulated
with
uniforms
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
PUSH_CONSTANTS
=
1
<
<
25
;
/
/
/
Allows
the
use
of
[
AddressMode
:
:
ClampToBorder
]
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
(
macOS
10
.
12
+
only
)
/
/
/
-
DX11
/
/
/
-
OpenGL
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
ADDRESS_MODE_CLAMP_TO_BORDER
=
1
<
<
26
;
/
/
/
Allows
the
user
to
set
[
PolygonMode
:
:
Line
]
in
[
PrimitiveState
:
:
polygon_mode
]
/
/
/
/
/
/
This
allows
drawing
polygons
/
triangles
as
lines
(
wireframe
)
instead
of
filled
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
POLYGON_MODE_LINE
=
1
<
<
27
;
/
/
/
Allows
the
user
to
set
[
PolygonMode
:
:
Point
]
in
[
PrimitiveState
:
:
polygon_mode
]
/
/
/
/
/
/
This
allows
only
drawing
the
vertices
of
polygons
/
triangles
instead
of
filled
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
POLYGON_MODE_POINT
=
1
<
<
28
;
/
/
/
Enables
ETC
family
of
compressed
textures
.
All
ETC
textures
use
4x4
pixel
blocks
.
/
/
/
ETC2
RGB
and
RGBA1
are
8
bytes
per
block
.
RTC2
RGBA8
and
EAC
are
16
bytes
per
block
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
ETC2
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Intel
/
Vulkan
/
/
/
-
Mobile
(
some
)
/
/
/
/
/
/
This
is
a
native
-
only
feature
.
const
TEXTURE_COMPRESSION_ETC2
=
1
<
<
29
;
/
/
/
Enables
ASTC
family
of
compressed
textures
.
ASTC
textures
use
pixel
blocks
varying
from
4x4
to
12x12
.
/
/
/
Blocks
are
always
16
bytes
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
ASTC
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Intel
/
Vulkan
/
/
/
-
Mobile
(
some
)
/
/
/
/
/
/
This
is
a
native
-
only
feature
.
const
TEXTURE_COMPRESSION_ASTC_LDR
=
1
<
<
30
;
/
/
/
Enables
device
specific
texture
format
features
.
/
/
/
/
/
/
See
TextureFormatFeatures
for
a
listing
of
the
features
in
question
.
/
/
/
/
/
/
By
default
only
texture
format
properties
as
defined
by
the
WebGPU
specification
are
allowed
.
/
/
/
Enabling
this
feature
flag
extends
the
features
of
each
format
to
the
ones
supported
by
the
current
device
.
/
/
/
Note
that
without
this
flag
read
/
write
storage
access
is
not
allowed
at
all
.
/
/
/
/
/
/
This
extension
does
not
enable
additional
formats
.
/
/
/
/
/
/
This
is
a
native
-
only
feature
.
const
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
=
1
<
<
31
;
/
/
/
Enables
64
-
bit
floating
point
types
in
SPIR
-
V
shaders
.
/
/
/
/
/
/
Note
:
even
when
supported
by
GPU
hardware
64
-
bit
floating
point
operations
are
/
/
/
frequently
between
16
and
64
_times_
slower
than
equivalent
operations
on
32
-
bit
floats
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
-
only
feature
.
const
SHADER_FLOAT64
=
1
<
<
32
;
/
/
/
Enables
using
64
-
bit
types
for
vertex
attributes
.
/
/
/
/
/
/
Requires
SHADER_FLOAT64
.
/
/
/
/
/
/
Supported
Platforms
:
N
/
A
/
/
/
/
/
/
This
is
a
native
-
only
feature
.
const
VERTEX_ATTRIBUTE_64BIT
=
1
<
<
33
;
/
/
/
Allows
the
user
to
set
a
overestimation
-
conservative
-
rasterization
in
[
PrimitiveState
:
:
conservative
]
/
/
/
/
/
/
Processing
of
degenerate
triangles
/
lines
is
hardware
specific
.
/
/
/
Only
triangles
are
supported
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
CONSERVATIVE_RASTERIZATION
=
1
<
<
34
;
/
/
/
Enables
bindings
of
writable
storage
buffers
and
textures
visible
to
vertex
shaders
.
/
/
/
/
/
/
Note
:
some
(
tiled
-
based
)
platforms
do
not
support
vertex
shaders
with
any
side
-
effects
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
All
/
/
/
/
/
/
This
is
a
native
-
only
feature
.
const
VERTEX_WRITABLE_STORAGE
=
1
<
<
35
;
/
/
/
Enables
clear
to
zero
for
buffers
&
textures
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
All
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
CLEAR_COMMANDS
=
1
<
<
36
;
/
/
/
Enables
creating
shader
modules
from
SPIR
-
V
binary
data
(
unsafe
)
.
/
/
/
/
/
/
SPIR
-
V
data
is
not
parsed
or
interpreted
in
any
way
;
you
can
use
/
/
/
[
wgpu
:
:
make_spirv_raw
!
]
to
check
for
alignment
and
magic
number
when
converting
from
/
/
/
raw
bytes
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
in
case
shader
'
s
requested
capabilities
and
extensions
agree
with
/
/
/
Vulkan
implementation
.
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SPIRV_SHADER_PASSTHROUGH
=
1
<
<
37
;
/
/
/
Enables
builtin
(
primitive_index
)
in
fragment
shaders
.
/
/
/
/
/
/
Note
:
enables
geometry
processing
for
pipelines
using
the
builtin
.
/
/
/
This
may
come
with
a
significant
performance
impact
on
some
hardware
.
/
/
/
Other
pipelines
are
not
affected
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SHADER_PRIMITIVE_INDEX
=
1
<
<
38
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
Features
)
;
impl
Features
{
pub
const
fn
all_webgpu_mask
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
0x0000_0000_0000_FFFF
)
}
pub
const
fn
all_native_mask
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
0xFFFF_FFFF_FFFF_0000
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Limits
{
pub
max_texture_dimension_1d
:
u32
pub
max_texture_dimension_2d
:
u32
pub
max_texture_dimension_3d
:
u32
pub
max_texture_array_layers
:
u32
pub
max_bind_groups
:
u32
pub
max_dynamic_uniform_buffers_per_pipeline_layout
:
u32
pub
max_dynamic_storage_buffers_per_pipeline_layout
:
u32
pub
max_sampled_textures_per_shader_stage
:
u32
pub
max_samplers_per_shader_stage
:
u32
pub
max_storage_buffers_per_shader_stage
:
u32
pub
max_storage_textures_per_shader_stage
:
u32
pub
max_uniform_buffers_per_shader_stage
:
u32
pub
max_uniform_buffer_binding_size
:
u32
pub
max_storage_buffer_binding_size
:
u32
pub
max_vertex_buffers
:
u32
pub
max_vertex_attributes
:
u32
pub
max_vertex_buffer_array_stride
:
u32
pub
max_push_constant_size
:
u32
pub
min_uniform_buffer_offset_alignment
:
u32
pub
min_storage_buffer_offset_alignment
:
u32
}
impl
Default
for
Limits
{
fn
default
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
8192
max_texture_dimension_2d
:
8192
max_texture_dimension_3d
:
2048
max_texture_array_layers
:
2048
max_bind_groups
:
4
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
8
max_storage_textures_per_shader_stage
:
8
max_uniform_buffers_per_shader_stage
:
12
max_uniform_buffer_binding_size
:
16384
max_storage_buffer_binding_size
:
128
<
<
20
max_vertex_buffers
:
8
max_vertex_attributes
:
16
max_vertex_buffer_array_stride
:
2048
max_push_constant_size
:
0
min_uniform_buffer_offset_alignment
:
256
min_storage_buffer_offset_alignment
:
256
}
}
}
impl
Limits
{
pub
fn
downlevel_defaults
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
2096
max_texture_dimension_2d
:
2096
max_texture_dimension_3d
:
256
max_texture_array_layers
:
256
max_bind_groups
:
4
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
4
max_storage_textures_per_shader_stage
:
4
max_uniform_buffers_per_shader_stage
:
12
max_uniform_buffer_binding_size
:
16384
max_storage_buffer_binding_size
:
128
<
<
20
max_vertex_buffers
:
8
max_vertex_attributes
:
16
max_vertex_buffer_array_stride
:
2048
max_push_constant_size
:
0
min_uniform_buffer_offset_alignment
:
256
min_storage_buffer_offset_alignment
:
256
}
}
pub
fn
using_resolution
(
self
other
:
Self
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
other
.
max_texture_dimension_1d
max_texture_dimension_2d
:
other
.
max_texture_dimension_2d
max_texture_dimension_3d
:
other
.
max_texture_dimension_3d
.
.
self
}
}
pub
fn
using_alignment
(
self
other
:
Self
)
-
>
Self
{
Self
{
min_uniform_buffer_offset_alignment
:
other
.
min_uniform_buffer_offset_alignment
min_storage_buffer_offset_alignment
:
other
.
min_storage_buffer_offset_alignment
.
.
self
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelLimits
{
}
impl
Default
for
DownlevelLimits
{
fn
default
(
)
-
>
Self
{
DownlevelLimits
{
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelCapabilities
{
pub
flags
:
DownlevelFlags
pub
limits
:
DownlevelLimits
pub
shader_model
:
ShaderModel
}
impl
Default
for
DownlevelCapabilities
{
fn
default
(
)
-
>
Self
{
Self
{
flags
:
DownlevelFlags
:
:
compliant
(
)
limits
:
DownlevelLimits
:
:
default
(
)
shader_model
:
ShaderModel
:
:
Sm5
}
}
}
impl
DownlevelCapabilities
{
pub
fn
is_webgpu_compliant
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
DownlevelFlags
:
:
compliant
(
)
)
&
&
self
.
limits
=
=
DownlevelLimits
:
:
default
(
)
&
&
self
.
shader_model
>
=
ShaderModel
:
:
Sm5
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Binary
flags
listing
features
that
may
or
may
not
be
present
on
downlevel
adapters
.
/
/
/
/
/
/
A
downlevel
adapter
is
a
GPU
adapter
that
WGPU
supports
but
with
potentially
limited
/
/
/
features
due
to
the
lack
of
hardware
feature
support
.
/
/
/
/
/
/
Flags
that
are
*
*
not
*
*
present
for
a
downlevel
adapter
or
device
usually
indicates
/
/
/
non
-
compliance
with
the
WebGPU
specification
but
not
always
.
/
/
/
/
/
/
You
can
check
whether
a
set
of
flags
is
compliant
through
the
/
/
/
[
DownlevelCapabilities
:
:
is_webgpu_compliant
(
)
]
function
.
pub
struct
DownlevelFlags
:
u32
{
/
/
/
The
device
supports
compiling
and
using
compute
shaders
.
const
COMPUTE_SHADERS
=
1
<
<
0
;
/
/
/
Supports
binding
storage
buffers
and
textures
to
fragment
shaders
.
const
FRAGMENT_WRITABLE_STORAGE
=
1
<
<
1
;
/
/
/
Supports
indirect
drawing
and
dispatching
.
const
INDIRECT_EXECUTION
=
1
<
<
2
;
/
/
/
Supports
non
-
zero
base_vertex
parameter
to
indexed
draw
calls
.
const
BASE_VERTEX
=
1
<
<
3
;
/
/
/
Supports
reading
from
a
depth
/
stencil
buffer
while
using
as
a
read
-
only
depth
/
stencil
/
/
/
attachment
.
const
READ_ONLY_DEPTH_STENCIL
=
1
<
<
4
;
/
/
/
Supports
:
/
/
/
-
copy_image_to_image
/
/
/
-
copy_buffer_to_image
and
copy_image_to_buffer
with
a
buffer
without
a
MAP_
*
usage
const
DEVICE_LOCAL_IMAGE_COPIES
=
1
<
<
5
;
/
/
/
Supports
textures
with
mipmaps
which
have
a
non
power
of
two
size
.
const
NON_POWER_OF_TWO_MIPMAPPED_TEXTURES
=
1
<
<
6
;
/
/
/
Supports
textures
that
are
cube
arrays
.
const
CUBE_ARRAY_TEXTURES
=
1
<
<
7
;
/
/
/
Supports
comparison
samplers
.
const
COMPARISON_SAMPLERS
=
1
<
<
8
;
/
/
/
Supports
different
blending
modes
per
color
target
.
const
INDEPENDENT_BLENDING
=
1
<
<
9
;
/
/
/
Supports
storage
buffers
in
vertex
shaders
.
const
VERTEX_STORAGE
=
1
<
<
10
;
/
/
/
Supports
samplers
with
anisotropic
filtering
.
Note
this
isn
'
t
actually
required
by
/
/
/
WebGPU
the
implementation
is
allowed
to
completely
ignore
aniso
clamp
.
This
flag
is
/
/
/
here
for
native
backends
so
they
can
comunicate
to
the
user
of
aniso
is
enabled
.
const
ANISOTROPIC_FILTERING
=
1
<
<
11
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
DownlevelFlags
)
;
impl
DownlevelFlags
{
pub
const
fn
compliant
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
Self
:
:
all
(
)
.
bits
(
)
&
!
Self
:
:
ANISOTROPIC_FILTERING
.
bits
)
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
ShaderModel
{
Sm2
Sm4
Sm5
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
DeviceType
{
Other
IntegratedGpu
DiscreteGpu
VirtualGpu
Cpu
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
AdapterInfo
{
pub
name
:
String
pub
vendor
:
usize
pub
device
:
usize
pub
device_type
:
DeviceType
pub
backend
:
Backend
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DeviceDescriptor
<
L
>
{
pub
label
:
L
pub
features
:
Features
pub
limits
:
Limits
}
impl
<
L
>
DeviceDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
DeviceDescriptor
<
K
>
{
DeviceDescriptor
{
label
:
fun
(
&
self
.
label
)
features
:
self
.
features
limits
:
self
.
limits
.
clone
(
)
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Describes
the
shader
stages
that
a
binding
will
be
visible
from
.
/
/
/
/
/
/
These
can
be
combined
so
something
that
is
visible
from
both
vertex
and
fragment
shaders
can
be
defined
as
:
/
/
/
/
/
/
ShaderStages
:
:
VERTEX
|
ShaderStages
:
:
FRAGMENT
#
[
repr
(
transparent
)
]
pub
struct
ShaderStages
:
u32
{
/
/
/
Binding
is
not
visible
from
any
shader
stage
.
const
NONE
=
0
;
/
/
/
Binding
is
visible
from
the
vertex
shader
of
a
render
pipeline
.
const
VERTEX
=
1
<
<
0
;
/
/
/
Binding
is
visible
from
the
fragment
shader
of
a
render
pipeline
.
const
FRAGMENT
=
1
<
<
1
;
/
/
/
Binding
is
visible
from
the
compute
shader
of
a
compute
pipeline
.
const
COMPUTE
=
1
<
<
2
;
/
/
/
Binding
is
visible
from
the
vertex
and
fragment
shaders
of
a
render
pipeline
.
const
VERTEX_FRAGMENT
=
Self
:
:
VERTEX
.
bits
|
Self
:
:
FRAGMENT
.
bits
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
ShaderStages
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureViewDimension
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
1d
"
)
)
]
D1
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
"
)
)
]
D2
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
-
array
"
)
)
]
D2Array
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
cube
"
)
)
]
Cube
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
cube
-
array
"
)
)
]
CubeArray
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
3d
"
)
)
]
D3
}
impl
Default
for
TextureViewDimension
{
fn
default
(
)
-
>
Self
{
Self
:
:
D2
}
}
impl
TextureViewDimension
{
pub
fn
compatible_texture_dimension
(
self
)
-
>
TextureDimension
{
match
self
{
Self
:
:
D1
=
>
TextureDimension
:
:
D1
Self
:
:
D2
|
Self
:
:
D2Array
|
Self
:
:
Cube
|
Self
:
:
CubeArray
=
>
TextureDimension
:
:
D2
Self
:
:
D3
=
>
TextureDimension
:
:
D3
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
BlendFactor
{
Zero
=
0
One
=
1
Src
=
2
OneMinusSrc
=
3
SrcAlpha
=
4
OneMinusSrcAlpha
=
5
Dst
=
6
OneMinusDst
=
7
DstAlpha
=
8
OneMinusDstAlpha
=
9
SrcAlphaSaturated
=
10
Constant
=
11
OneMinusConstant
=
12
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
BlendOperation
{
Add
=
0
Subtract
=
1
ReverseSubtract
=
2
Min
=
3
Max
=
4
}
impl
Default
for
BlendOperation
{
fn
default
(
)
-
>
Self
{
Self
:
:
Add
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
BlendComponent
{
pub
src_factor
:
BlendFactor
pub
dst_factor
:
BlendFactor
pub
operation
:
BlendOperation
}
impl
BlendComponent
{
pub
const
REPLACE
:
Self
=
Self
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
Zero
operation
:
BlendOperation
:
:
Add
}
;
pub
const
OVER
:
Self
=
Self
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
OneMinusSrcAlpha
operation
:
BlendOperation
:
:
Add
}
;
pub
fn
uses_constant
(
&
self
)
-
>
bool
{
match
(
self
.
src_factor
self
.
dst_factor
)
{
(
BlendFactor
:
:
Constant
_
)
|
(
BlendFactor
:
:
OneMinusConstant
_
)
|
(
_
BlendFactor
:
:
Constant
)
|
(
_
BlendFactor
:
:
OneMinusConstant
)
=
>
true
(
_
_
)
=
>
false
}
}
}
impl
Default
for
BlendComponent
{
fn
default
(
)
-
>
Self
{
Self
:
:
REPLACE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
BlendState
{
pub
color
:
BlendComponent
pub
alpha
:
BlendComponent
}
impl
BlendState
{
pub
const
REPLACE
:
Self
=
Self
{
color
:
BlendComponent
:
:
REPLACE
alpha
:
BlendComponent
:
:
REPLACE
}
;
pub
const
ALPHA_BLENDING
:
Self
=
Self
{
color
:
BlendComponent
{
src_factor
:
BlendFactor
:
:
SrcAlpha
dst_factor
:
BlendFactor
:
:
OneMinusSrcAlpha
operation
:
BlendOperation
:
:
Add
}
alpha
:
BlendComponent
:
:
OVER
}
;
pub
const
PREMULTIPLIED_ALPHA_BLENDING
:
Self
=
Self
{
color
:
BlendComponent
:
:
OVER
alpha
:
BlendComponent
:
:
OVER
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
ColorTargetState
{
pub
format
:
TextureFormat
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
blend
:
Option
<
BlendState
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
write_mask
:
ColorWrites
}
impl
From
<
TextureFormat
>
for
ColorTargetState
{
fn
from
(
format
:
TextureFormat
)
-
>
Self
{
Self
{
format
blend
:
None
write_mask
:
ColorWrites
:
:
ALL
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PrimitiveTopology
{
PointList
=
0
LineList
=
1
LineStrip
=
2
TriangleList
=
3
TriangleStrip
=
4
}
impl
Default
for
PrimitiveTopology
{
fn
default
(
)
-
>
Self
{
PrimitiveTopology
:
:
TriangleList
}
}
impl
PrimitiveTopology
{
pub
fn
is_strip
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
PointList
|
Self
:
:
LineList
|
Self
:
:
TriangleList
=
>
false
Self
:
:
LineStrip
|
Self
:
:
TriangleStrip
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
FrontFace
{
Ccw
=
0
Cw
=
1
}
impl
Default
for
FrontFace
{
fn
default
(
)
-
>
Self
{
Self
:
:
Ccw
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
Face
{
Front
=
0
Back
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PolygonMode
{
Fill
=
0
Line
=
1
Point
=
2
}
impl
Default
for
PolygonMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
Fill
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
PrimitiveState
{
pub
topology
:
PrimitiveTopology
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
strip_index_format
:
Option
<
IndexFormat
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
front_face
:
FrontFace
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
cull_mode
:
Option
<
Face
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
clamp_depth
:
bool
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
polygon_mode
:
PolygonMode
pub
conservative
:
bool
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
MultisampleState
{
pub
count
:
u32
pub
mask
:
u64
pub
alpha_to_coverage_enabled
:
bool
}
impl
Default
for
MultisampleState
{
fn
default
(
)
-
>
Self
{
MultisampleState
{
count
:
1
mask
:
!
0
alpha_to_coverage_enabled
:
false
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Feature
flags
for
a
texture
format
.
#
[
repr
(
transparent
)
]
pub
struct
TextureFormatFeatureFlags
:
u32
{
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
bound
with
/
/
/
[
StorageTextureAccess
:
:
ReadOnly
]
or
[
StorageTextureAccess
:
:
ReadWrite
]
.
const
STORAGE_READ_WRITE
=
1
<
<
0
;
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
written
to
with
atomics
.
/
/
TODO
:
No
access
flag
exposed
as
of
writing
const
STORAGE_ATOMICS
=
1
<
<
1
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
TextureFormatFeatureFlags
)
;
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
pub
struct
TextureFormatFeatures
{
pub
allowed_usages
:
TextureUsages
pub
flags
:
TextureFormatFeatureFlags
pub
filterable
:
bool
}
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
pub
struct
TextureFormatInfo
{
pub
required_features
:
Features
pub
sample_type
:
TextureSampleType
pub
block_dimensions
:
(
u8
u8
)
pub
block_size
:
u8
pub
srgb
:
bool
pub
guaranteed_format_features
:
TextureFormatFeatures
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
pub
enum
TextureFormat
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r8unorm
"
)
)
]
R8Unorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r8snorm
"
)
)
]
R8Snorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r8uint
"
)
)
]
R8Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r8sint
"
)
)
]
R8Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r16uint
"
)
)
]
R16Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r16sint
"
)
)
]
R16Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r16float
"
)
)
]
R16Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg8unorm
"
)
)
]
Rg8Unorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg8snorm
"
)
)
]
Rg8Snorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg8uint
"
)
)
]
Rg8Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg8sint
"
)
)
]
Rg8Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r32uint
"
)
)
]
R32Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r32sint
"
)
)
]
R32Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
r32float
"
)
)
]
R32Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg16uint
"
)
)
]
Rg16Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg16sint
"
)
)
]
Rg16Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg16float
"
)
)
]
Rg16Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba8unorm
"
)
)
]
Rgba8Unorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba8unorm
-
srgb
"
)
)
]
Rgba8UnormSrgb
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba8snorm
"
)
)
]
Rgba8Snorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba8uint
"
)
)
]
Rgba8Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba8sint
"
)
)
]
Rgba8Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bgra8unorm
"
)
)
]
Bgra8Unorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bgra8unorm
-
srgb
"
)
)
]
Bgra8UnormSrgb
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgb10a2unorm
"
)
)
]
Rgb10a2Unorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg11b10ufloat
"
)
)
]
Rg11b10Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg32uint
"
)
)
]
Rg32Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg32sint
"
)
)
]
Rg32Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rg32float
"
)
)
]
Rg32Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba16uint
"
)
)
]
Rgba16Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba16sint
"
)
)
]
Rgba16Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba16float
"
)
)
]
Rgba16Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba32uint
"
)
)
]
Rgba32Uint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba32sint
"
)
)
]
Rgba32Sint
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgba32float
"
)
)
]
Rgba32Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
depth32float
"
)
)
]
Depth32Float
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
depth24plus
"
)
)
]
Depth24Plus
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
depth24plus
-
stencil8
"
)
)
]
Depth24PlusStencil8
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
rgb9e5ufloat
"
)
)
]
Rgb9e5Ufloat
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc1
-
rgba
-
unorm
"
)
)
]
Bc1RgbaUnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc1
-
rgba
-
unorm
-
srgb
"
)
)
]
Bc1RgbaUnormSrgb
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc2
-
rgba
-
unorm
"
)
)
]
Bc2RgbaUnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc2
-
rgba
-
unorm
-
srgb
"
)
)
]
Bc2RgbaUnormSrgb
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc3
-
rgba
-
unorm
"
)
)
]
Bc3RgbaUnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc3
-
rgba
-
unorm
-
srgb
"
)
)
]
Bc3RgbaUnormSrgb
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc4
-
r
-
unorm
"
)
)
]
Bc4RUnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc4
-
r
-
snorm
"
)
)
]
Bc4RSnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc5
-
rg
-
unorm
"
)
)
]
Bc5RgUnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc5
-
rg
-
snorm
"
)
)
]
Bc5RgSnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc6h
-
rgb
-
ufloat
"
)
)
]
Bc6hRgbUfloat
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc6h
-
rgb
-
float
"
)
)
]
Bc6hRgbSfloat
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc7
-
rgba
-
unorm
"
)
)
]
Bc7RgbaUnorm
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
bc7
-
rgba
-
unorm
-
srgb
"
)
)
]
Bc7RgbaUnormSrgb
Etc2RgbUnorm
Etc2RgbUnormSrgb
Etc2RgbA1Unorm
Etc2RgbA1UnormSrgb
EacRUnorm
EacRSnorm
EacRgUnorm
EacRgSnorm
Astc4x4RgbaUnorm
Astc4x4RgbaUnormSrgb
Astc5x4RgbaUnorm
Astc5x4RgbaUnormSrgb
Astc5x5RgbaUnorm
Astc5x5RgbaUnormSrgb
Astc6x5RgbaUnorm
Astc6x5RgbaUnormSrgb
Astc6x6RgbaUnorm
Astc6x6RgbaUnormSrgb
Astc8x5RgbaUnorm
Astc8x5RgbaUnormSrgb
Astc8x6RgbaUnorm
Astc8x6RgbaUnormSrgb
Astc10x5RgbaUnorm
Astc10x5RgbaUnormSrgb
Astc10x6RgbaUnorm
Astc10x6RgbaUnormSrgb
Astc8x8RgbaUnorm
Astc8x8RgbaUnormSrgb
Astc10x8RgbaUnorm
Astc10x8RgbaUnormSrgb
Astc10x10RgbaUnorm
Astc10x10RgbaUnormSrgb
Astc12x10RgbaUnorm
Astc12x10RgbaUnormSrgb
Astc12x12RgbaUnorm
Astc12x12RgbaUnormSrgb
}
impl
TextureFormat
{
pub
fn
describe
(
&
self
)
-
>
TextureFormatInfo
{
let
native
=
Features
:
:
empty
(
)
;
let
bc
=
Features
:
:
TEXTURE_COMPRESSION_BC
;
let
etc2
=
Features
:
:
TEXTURE_COMPRESSION_ETC2
;
let
astc_ldr
=
Features
:
:
TEXTURE_COMPRESSION_ASTC_LDR
;
let
uint
=
TextureSampleType
:
:
Uint
;
let
sint
=
TextureSampleType
:
:
Sint
;
let
nearest
=
TextureSampleType
:
:
Float
{
filterable
:
false
}
;
let
float
=
TextureSampleType
:
:
Float
{
filterable
:
true
}
;
let
depth
=
TextureSampleType
:
:
Depth
;
let
linear
=
false
;
let
srgb
=
true
;
let
basic
=
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
;
let
attachment
=
basic
|
TextureUsages
:
:
RENDER_ATTACHMENT
;
let
storage
=
basic
|
TextureUsages
:
:
STORAGE_BINDING
;
let
all_flags
=
TextureUsages
:
:
all
(
)
;
let
(
required_features
sample_type
srgb
block_dimensions
block_size
allowed_usages
)
=
match
self
{
Self
:
:
R8Unorm
=
>
(
native
float
linear
(
1
1
)
1
attachment
)
Self
:
:
R8Snorm
=
>
(
native
float
linear
(
1
1
)
1
basic
)
Self
:
:
R8Uint
=
>
(
native
uint
linear
(
1
1
)
1
attachment
)
Self
:
:
R8Sint
=
>
(
native
sint
linear
(
1
1
)
1
attachment
)
Self
:
:
R16Uint
=
>
(
native
uint
linear
(
1
1
)
2
attachment
)
Self
:
:
R16Sint
=
>
(
native
sint
linear
(
1
1
)
2
attachment
)
Self
:
:
R16Float
=
>
(
native
float
linear
(
1
1
)
2
attachment
)
Self
:
:
Rg8Unorm
=
>
(
native
float
linear
(
1
1
)
2
attachment
)
Self
:
:
Rg8Snorm
=
>
(
native
float
linear
(
1
1
)
2
attachment
)
Self
:
:
Rg8Uint
=
>
(
native
uint
linear
(
1
1
)
2
attachment
)
Self
:
:
Rg8Sint
=
>
(
native
sint
linear
(
1
1
)
2
basic
)
Self
:
:
R32Uint
=
>
(
native
uint
linear
(
1
1
)
4
all_flags
)
Self
:
:
R32Sint
=
>
(
native
sint
linear
(
1
1
)
4
all_flags
)
Self
:
:
R32Float
=
>
(
native
nearest
linear
(
1
1
)
4
all_flags
)
Self
:
:
Rg16Uint
=
>
(
native
uint
linear
(
1
1
)
4
attachment
)
Self
:
:
Rg16Sint
=
>
(
native
sint
linear
(
1
1
)
4
attachment
)
Self
:
:
Rg16Float
=
>
(
native
float
linear
(
1
1
)
4
attachment
)
Self
:
:
Rgba8Unorm
=
>
(
native
float
linear
(
1
1
)
4
all_flags
)
Self
:
:
Rgba8UnormSrgb
=
>
(
native
float
srgb
(
1
1
)
4
attachment
)
Self
:
:
Rgba8Snorm
=
>
(
native
float
linear
(
1
1
)
4
storage
)
Self
:
:
Rgba8Uint
=
>
(
native
uint
linear
(
1
1
)
4
all_flags
)
Self
:
:
Rgba8Sint
=
>
(
native
sint
linear
(
1
1
)
4
all_flags
)
Self
:
:
Bgra8Unorm
=
>
(
native
float
linear
(
1
1
)
4
attachment
)
Self
:
:
Bgra8UnormSrgb
=
>
(
native
float
srgb
(
1
1
)
4
attachment
)
Self
:
:
Rgb10a2Unorm
=
>
(
native
float
linear
(
1
1
)
4
attachment
)
Self
:
:
Rg11b10Float
=
>
(
native
float
linear
(
1
1
)
4
basic
)
Self
:
:
Rg32Uint
=
>
(
native
uint
linear
(
1
1
)
8
all_flags
)
Self
:
:
Rg32Sint
=
>
(
native
sint
linear
(
1
1
)
8
all_flags
)
Self
:
:
Rg32Float
=
>
(
native
nearest
linear
(
1
1
)
8
all_flags
)
Self
:
:
Rgba16Uint
=
>
(
native
uint
linear
(
1
1
)
8
all_flags
)
Self
:
:
Rgba16Sint
=
>
(
native
sint
linear
(
1
1
)
8
all_flags
)
Self
:
:
Rgba16Float
=
>
(
native
float
linear
(
1
1
)
8
all_flags
)
Self
:
:
Rgba32Uint
=
>
(
native
uint
linear
(
1
1
)
16
all_flags
)
Self
:
:
Rgba32Sint
=
>
(
native
sint
linear
(
1
1
)
16
all_flags
)
Self
:
:
Rgba32Float
=
>
(
native
nearest
linear
(
1
1
)
16
all_flags
)
Self
:
:
Depth32Float
=
>
(
native
depth
linear
(
1
1
)
4
attachment
)
Self
:
:
Depth24Plus
=
>
(
native
depth
linear
(
1
1
)
4
attachment
)
Self
:
:
Depth24PlusStencil8
=
>
(
native
depth
linear
(
1
1
)
4
attachment
)
Self
:
:
Rgb9e5Ufloat
=
>
(
native
float
linear
(
1
1
)
4
basic
)
Self
:
:
Bc1RgbaUnorm
=
>
(
bc
float
linear
(
4
4
)
8
basic
)
Self
:
:
Bc1RgbaUnormSrgb
=
>
(
bc
float
srgb
(
4
4
)
8
basic
)
Self
:
:
Bc2RgbaUnorm
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc2RgbaUnormSrgb
=
>
(
bc
float
srgb
(
4
4
)
16
basic
)
Self
:
:
Bc3RgbaUnorm
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc3RgbaUnormSrgb
=
>
(
bc
float
srgb
(
4
4
)
16
basic
)
Self
:
:
Bc4RUnorm
=
>
(
bc
float
linear
(
4
4
)
8
basic
)
Self
:
:
Bc4RSnorm
=
>
(
bc
float
linear
(
4
4
)
8
basic
)
Self
:
:
Bc5RgUnorm
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc5RgSnorm
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc6hRgbUfloat
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc6hRgbSfloat
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc7RgbaUnorm
=
>
(
bc
float
linear
(
4
4
)
16
basic
)
Self
:
:
Bc7RgbaUnormSrgb
=
>
(
bc
float
srgb
(
4
4
)
16
basic
)
Self
:
:
Etc2RgbUnorm
=
>
(
etc2
float
linear
(
4
4
)
8
basic
)
Self
:
:
Etc2RgbUnormSrgb
=
>
(
etc2
float
srgb
(
4
4
)
8
basic
)
Self
:
:
Etc2RgbA1Unorm
=
>
(
etc2
float
linear
(
4
4
)
8
basic
)
Self
:
:
Etc2RgbA1UnormSrgb
=
>
(
etc2
float
srgb
(
4
4
)
8
basic
)
Self
:
:
EacRUnorm
=
>
(
etc2
float
linear
(
4
4
)
8
basic
)
Self
:
:
EacRSnorm
=
>
(
etc2
float
linear
(
4
4
)
8
basic
)
Self
:
:
EacRgUnorm
=
>
(
etc2
float
linear
(
4
4
)
16
basic
)
Self
:
:
EacRgSnorm
=
>
(
etc2
float
linear
(
4
4
)
16
basic
)
Self
:
:
Astc4x4RgbaUnorm
=
>
(
astc_ldr
float
linear
(
4
4
)
16
basic
)
Self
:
:
Astc4x4RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
4
4
)
16
basic
)
Self
:
:
Astc5x4RgbaUnorm
=
>
(
astc_ldr
float
linear
(
5
4
)
16
basic
)
Self
:
:
Astc5x4RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
5
4
)
16
basic
)
Self
:
:
Astc5x5RgbaUnorm
=
>
(
astc_ldr
float
linear
(
5
5
)
16
basic
)
Self
:
:
Astc5x5RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
5
5
)
16
basic
)
Self
:
:
Astc6x5RgbaUnorm
=
>
(
astc_ldr
float
linear
(
6
5
)
16
basic
)
Self
:
:
Astc6x5RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
6
5
)
16
basic
)
Self
:
:
Astc6x6RgbaUnorm
=
>
(
astc_ldr
float
linear
(
6
6
)
16
basic
)
Self
:
:
Astc6x6RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
6
6
)
16
basic
)
Self
:
:
Astc8x5RgbaUnorm
=
>
(
astc_ldr
float
linear
(
8
5
)
16
basic
)
Self
:
:
Astc8x5RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
8
5
)
16
basic
)
Self
:
:
Astc8x6RgbaUnorm
=
>
(
astc_ldr
float
linear
(
8
6
)
16
basic
)
Self
:
:
Astc8x6RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
8
6
)
16
basic
)
Self
:
:
Astc10x5RgbaUnorm
=
>
(
astc_ldr
float
linear
(
10
5
)
16
basic
)
Self
:
:
Astc10x5RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
10
5
)
16
basic
)
Self
:
:
Astc10x6RgbaUnorm
=
>
(
astc_ldr
float
linear
(
10
6
)
16
basic
)
Self
:
:
Astc10x6RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
10
6
)
16
basic
)
Self
:
:
Astc8x8RgbaUnorm
=
>
(
astc_ldr
float
linear
(
8
8
)
16
basic
)
Self
:
:
Astc8x8RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
8
8
)
16
basic
)
Self
:
:
Astc10x8RgbaUnorm
=
>
(
astc_ldr
float
linear
(
10
8
)
16
basic
)
Self
:
:
Astc10x8RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
10
8
)
16
basic
)
Self
:
:
Astc10x10RgbaUnorm
=
>
(
astc_ldr
float
linear
(
10
10
)
16
basic
)
Self
:
:
Astc10x10RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
10
10
)
16
basic
)
Self
:
:
Astc12x10RgbaUnorm
=
>
(
astc_ldr
float
linear
(
12
10
)
16
basic
)
Self
:
:
Astc12x10RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
12
10
)
16
basic
)
Self
:
:
Astc12x12RgbaUnorm
=
>
(
astc_ldr
float
linear
(
12
12
)
16
basic
)
Self
:
:
Astc12x12RgbaUnormSrgb
=
>
(
astc_ldr
float
srgb
(
12
12
)
16
basic
)
}
;
TextureFormatInfo
{
required_features
sample_type
block_dimensions
block_size
srgb
guaranteed_format_features
:
TextureFormatFeatures
{
allowed_usages
flags
:
TextureFormatFeatureFlags
:
:
empty
(
)
filterable
:
sample_type
=
=
TextureSampleType
:
:
Float
{
filterable
:
true
}
}
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Color
write
mask
.
Disabled
color
channels
will
not
be
written
to
.
#
[
repr
(
transparent
)
]
pub
struct
ColorWrites
:
u32
{
/
/
/
Enable
red
channel
writes
const
RED
=
1
<
<
0
;
/
/
/
Enable
green
channel
writes
const
GREEN
=
1
<
<
1
;
/
/
/
Enable
blue
channel
writes
const
BLUE
=
1
<
<
2
;
/
/
/
Enable
alpha
channel
writes
const
ALPHA
=
1
<
<
3
;
/
/
/
Enable
red
green
and
blue
channel
writes
const
COLOR
=
Self
:
:
RED
.
bits
|
Self
:
:
GREEN
.
bits
|
Self
:
:
BLUE
.
bits
;
/
/
/
Enable
writes
to
all
channels
.
const
ALL
=
Self
:
:
RED
.
bits
|
Self
:
:
GREEN
.
bits
|
Self
:
:
BLUE
.
bits
|
Self
:
:
ALPHA
.
bits
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
ColorWrites
)
;
impl
Default
for
ColorWrites
{
fn
default
(
)
-
>
Self
{
Self
:
:
ALL
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
StencilState
{
pub
front
:
StencilFaceState
pub
back
:
StencilFaceState
pub
read_mask
:
u32
pub
write_mask
:
u32
}
impl
StencilState
{
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
(
self
.
front
!
=
StencilFaceState
:
:
IGNORE
|
|
self
.
back
!
=
StencilFaceState
:
:
IGNORE
)
&
&
(
self
.
read_mask
!
=
0
|
|
self
.
write_mask
!
=
0
)
}
pub
fn
is_read_only
(
&
self
)
-
>
bool
{
self
.
write_mask
=
=
0
}
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
front
.
needs_ref_value
(
)
|
|
self
.
back
.
needs_ref_value
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DepthBiasState
{
pub
constant
:
i32
pub
slope_scale
:
f32
pub
clamp
:
f32
}
impl
DepthBiasState
{
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
self
.
constant
!
=
0
|
|
self
.
slope_scale
!
=
0
.
0
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DepthStencilState
{
pub
format
:
TextureFormat
pub
depth_write_enabled
:
bool
pub
depth_compare
:
CompareFunction
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
stencil
:
StencilState
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
bias
:
DepthBiasState
}
impl
DepthStencilState
{
pub
fn
is_depth_enabled
(
&
self
)
-
>
bool
{
self
.
depth_compare
!
=
CompareFunction
:
:
Always
|
|
self
.
depth_write_enabled
}
pub
fn
is_read_only
(
&
self
)
-
>
bool
{
!
self
.
depth_write_enabled
&
&
self
.
stencil
.
is_read_only
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
IndexFormat
{
Uint16
=
0
Uint32
=
1
}
impl
Default
for
IndexFormat
{
fn
default
(
)
-
>
Self
{
Self
:
:
Uint32
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StencilOperation
{
Keep
=
0
Zero
=
1
Replace
=
2
Invert
=
3
IncrementClamp
=
4
DecrementClamp
=
5
IncrementWrap
=
6
DecrementWrap
=
7
}
impl
Default
for
StencilOperation
{
fn
default
(
)
-
>
Self
{
Self
:
:
Keep
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
StencilFaceState
{
pub
compare
:
CompareFunction
pub
fail_op
:
StencilOperation
pub
depth_fail_op
:
StencilOperation
pub
pass_op
:
StencilOperation
}
impl
StencilFaceState
{
pub
const
IGNORE
:
Self
=
StencilFaceState
{
compare
:
CompareFunction
:
:
Always
fail_op
:
StencilOperation
:
:
Keep
depth_fail_op
:
StencilOperation
:
:
Keep
pass_op
:
StencilOperation
:
:
Keep
}
;
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
compare
.
needs_ref_value
(
)
|
|
self
.
fail_op
=
=
StencilOperation
:
:
Replace
|
|
self
.
depth_fail_op
=
=
StencilOperation
:
:
Replace
|
|
self
.
pass_op
=
=
StencilOperation
:
:
Replace
}
}
impl
Default
for
StencilFaceState
{
fn
default
(
)
-
>
Self
{
Self
:
:
IGNORE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
CompareFunction
{
Never
=
1
Less
=
2
Equal
=
3
LessEqual
=
4
Greater
=
5
NotEqual
=
6
GreaterEqual
=
7
Always
=
8
}
impl
CompareFunction
{
pub
fn
needs_ref_value
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Never
|
Self
:
:
Always
=
>
false
_
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
VertexStepMode
{
Vertex
=
0
Instance
=
1
}
impl
Default
for
VertexStepMode
{
fn
default
(
)
-
>
Self
{
VertexStepMode
:
:
Vertex
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
VertexAttribute
{
pub
format
:
VertexFormat
pub
offset
:
BufferAddress
pub
shader_location
:
ShaderLocation
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
lowercase
"
)
)
]
pub
enum
VertexFormat
{
Uint8x2
=
0
Uint8x4
=
1
Sint8x2
=
2
Sint8x4
=
3
Unorm8x2
=
4
Unorm8x4
=
5
Snorm8x2
=
6
Snorm8x4
=
7
Uint16x2
=
8
Uint16x4
=
9
Sint16x2
=
10
Sint16x4
=
11
Unorm16x2
=
12
Unorm16x4
=
13
Snorm16x2
=
14
Snorm16x4
=
15
Float16x2
=
16
Float16x4
=
17
Float32
=
18
Float32x2
=
19
Float32x3
=
20
Float32x4
=
21
Uint32
=
22
Uint32x2
=
23
Uint32x3
=
24
Uint32x4
=
25
Sint32
=
26
Sint32x2
=
27
Sint32x3
=
28
Sint32x4
=
29
Float64
=
30
Float64x2
=
31
Float64x3
=
32
Float64x4
=
33
}
impl
VertexFormat
{
pub
const
fn
size
(
&
self
)
-
>
u64
{
match
self
{
Self
:
:
Uint8x2
|
Self
:
:
Sint8x2
|
Self
:
:
Unorm8x2
|
Self
:
:
Snorm8x2
=
>
2
Self
:
:
Uint8x4
|
Self
:
:
Sint8x4
|
Self
:
:
Unorm8x4
|
Self
:
:
Snorm8x4
|
Self
:
:
Uint16x2
|
Self
:
:
Sint16x2
|
Self
:
:
Unorm16x2
|
Self
:
:
Snorm16x2
|
Self
:
:
Float16x2
|
Self
:
:
Float32
|
Self
:
:
Uint32
|
Self
:
:
Sint32
=
>
4
Self
:
:
Uint16x4
|
Self
:
:
Sint16x4
|
Self
:
:
Unorm16x4
|
Self
:
:
Snorm16x4
|
Self
:
:
Float16x4
|
Self
:
:
Float32x2
|
Self
:
:
Uint32x2
|
Self
:
:
Sint32x2
|
Self
:
:
Float64
=
>
8
Self
:
:
Float32x3
|
Self
:
:
Uint32x3
|
Self
:
:
Sint32x3
=
>
12
Self
:
:
Float32x4
|
Self
:
:
Uint32x4
|
Self
:
:
Sint32x4
|
Self
:
:
Float64x2
=
>
16
Self
:
:
Float64x3
=
>
24
Self
:
:
Float64x4
=
>
32
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
buffer
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
buffer
is
allocated
from
and
what
/
/
/
actions
the
buffer
can
partake
in
.
#
[
repr
(
transparent
)
]
pub
struct
BufferUsages
:
u32
{
/
/
/
Allow
a
buffer
to
be
mapped
for
reading
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
[
BufferDescriptor
:
:
mapped_at_creation
]
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_DST
.
const
MAP_READ
=
1
<
<
0
;
/
/
/
Allow
a
buffer
to
be
mapped
for
writing
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range_mut
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
mapped_at_creation
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
feature
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_SRC
.
const
MAP_WRITE
=
1
<
<
1
;
/
/
/
Allow
a
buffer
to
be
the
source
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
or
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
operation
.
const
COPY_SRC
=
1
<
<
2
;
/
/
/
Allow
a
buffer
to
be
the
destination
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
[
CommandEncoder
:
:
copy_texture_to_buffer
]
/
/
/
[
CommandEncoder
:
:
clear_buffer
]
or
[
Queue
:
:
write_buffer
]
operation
.
const
COPY_DST
=
1
<
<
3
;
/
/
/
Allow
a
buffer
to
be
the
index
buffer
in
a
draw
operation
.
const
INDEX
=
1
<
<
4
;
/
/
/
Allow
a
buffer
to
be
the
vertex
buffer
in
a
draw
operation
.
const
VERTEX
=
1
<
<
5
;
/
/
/
Allow
a
buffer
to
be
a
[
BufferBindingType
:
:
Uniform
]
inside
a
bind
group
.
const
UNIFORM
=
1
<
<
6
;
/
/
/
Allow
a
buffer
to
be
a
[
BufferBindingType
:
:
Storage
]
inside
a
bind
group
.
const
STORAGE
=
1
<
<
7
;
/
/
/
Allow
a
buffer
to
be
the
indirect
buffer
in
an
indirect
draw
call
.
const
INDIRECT
=
1
<
<
8
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
BufferUsages
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BufferDescriptor
<
L
>
{
pub
label
:
L
pub
size
:
BufferAddress
pub
usage
:
BufferUsages
pub
mapped_at_creation
:
bool
}
impl
<
L
>
BufferDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
BufferDescriptor
<
K
>
{
BufferDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
usage
:
self
.
usage
mapped_at_creation
:
self
.
mapped_at_creation
}
}
}
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
CommandEncoderDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandEncoderDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandEncoderDescriptor
<
K
>
{
CommandEncoderDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
CommandEncoderDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PresentMode
{
Immediate
=
0
Mailbox
=
1
Fifo
=
2
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
texture
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
texture
is
allocated
from
and
what
/
/
/
actions
the
texture
can
partake
in
.
#
[
repr
(
transparent
)
]
pub
struct
TextureUsages
:
u32
{
/
/
/
Allows
a
texture
to
be
the
source
in
a
[
CommandEncoder
:
:
copy_texture_to_buffer
]
or
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
operation
.
const
COPY_SRC
=
1
<
<
0
;
/
/
/
Allows
a
texture
to
be
the
destination
in
a
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
or
[
Queue
:
:
write_texture
]
operation
.
const
COPY_DST
=
1
<
<
1
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
Texture
]
in
a
bind
group
.
const
TEXTURE_BINDING
=
1
<
<
2
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
StorageTexture
]
in
a
bind
group
.
const
STORAGE_BINDING
=
1
<
<
3
;
/
/
/
Allows
a
texture
to
be
an
output
attachment
of
a
renderpass
.
const
RENDER_ATTACHMENT
=
1
<
<
4
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
TextureUsages
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceConfiguration
{
pub
usage
:
TextureUsages
pub
format
:
TextureFormat
pub
width
:
u32
pub
height
:
u32
pub
present_mode
:
PresentMode
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
enum
SurfaceStatus
{
Good
Suboptimal
Timeout
Outdated
Lost
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Color
{
pub
r
:
f64
pub
g
:
f64
pub
b
:
f64
pub
a
:
f64
}
#
[
allow
(
missing_docs
)
]
impl
Color
{
pub
const
TRANSPARENT
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
0
.
0
}
;
pub
const
BLACK
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
WHITE
:
Self
=
Self
{
r
:
1
.
0
g
:
1
.
0
b
:
1
.
0
a
:
1
.
0
}
;
pub
const
RED
:
Self
=
Self
{
r
:
1
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
GREEN
:
Self
=
Self
{
r
:
0
.
0
g
:
1
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
BLUE
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
1
.
0
a
:
1
.
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureDimension
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
1d
"
)
)
]
D1
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
"
)
)
]
D2
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
3d
"
)
)
]
D3
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Origin3d
{
pub
x
:
u32
pub
y
:
u32
pub
z
:
u32
}
impl
Origin3d
{
pub
const
ZERO
:
Self
=
Self
{
x
:
0
y
:
0
z
:
0
}
;
}
impl
Default
for
Origin3d
{
fn
default
(
)
-
>
Self
{
Self
:
:
ZERO
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Extent3d
{
pub
width
:
u32
pub
height
:
u32
pub
depth_or_array_layers
:
u32
}
impl
Default
for
Extent3d
{
fn
default
(
)
-
>
Self
{
Self
{
width
:
1
height
:
1
depth_or_array_layers
:
1
}
}
}
impl
Extent3d
{
pub
fn
physical_size
(
&
self
format
:
TextureFormat
)
-
>
Self
{
let
(
block_width
block_height
)
=
format
.
describe
(
)
.
block_dimensions
;
let
block_width
=
block_width
as
u32
;
let
block_height
=
block_height
as
u32
;
let
width
=
(
(
self
.
width
+
block_width
-
1
)
/
block_width
)
*
block_width
;
let
height
=
(
(
self
.
height
+
block_height
-
1
)
/
block_height
)
*
block_height
;
Self
{
width
height
depth_or_array_layers
:
self
.
depth_or_array_layers
}
}
pub
fn
max_mips
(
&
self
)
-
>
u32
{
let
max_dim
=
self
.
width
.
max
(
self
.
height
.
max
(
self
.
depth_or_array_layers
)
)
;
32
-
max_dim
.
leading_zeros
(
)
}
pub
fn
mip_level_size
(
&
self
level
:
u32
is_3d_texture
:
bool
)
-
>
Extent3d
{
Extent3d
{
width
:
u32
:
:
max
(
1
self
.
width
>
>
level
)
height
:
u32
:
:
max
(
1
self
.
height
>
>
level
)
depth_or_array_layers
:
match
is_3d_texture
{
false
=
>
self
.
depth_or_array_layers
true
=
>
u32
:
:
max
(
1
self
.
depth_or_array_layers
>
>
level
)
}
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureDescriptor
<
L
>
{
pub
label
:
L
pub
size
:
Extent3d
pub
mip_level_count
:
u32
pub
sample_count
:
u32
pub
dimension
:
TextureDimension
pub
format
:
TextureFormat
pub
usage
:
TextureUsages
}
impl
<
L
>
TextureDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
TextureDescriptor
<
K
>
{
TextureDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
mip_level_count
:
self
.
mip_level_count
sample_count
:
self
.
sample_count
dimension
:
self
.
dimension
format
:
self
.
format
usage
:
self
.
usage
}
}
pub
fn
mip_level_size
(
&
self
level
:
u32
)
-
>
Option
<
Extent3d
>
{
if
level
>
=
self
.
mip_level_count
{
return
None
;
}
Some
(
self
.
size
.
mip_level_size
(
level
self
.
dimension
=
=
TextureDimension
:
:
D3
)
)
}
pub
fn
array_layer_count
(
&
self
)
-
>
u32
{
match
self
.
dimension
{
TextureDimension
:
:
D1
|
TextureDimension
:
:
D2
=
>
self
.
size
.
depth_or_array_layers
TextureDimension
:
:
D3
=
>
1
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
TextureAspect
{
All
StencilOnly
DepthOnly
}
impl
Default
for
TextureAspect
{
fn
default
(
)
-
>
Self
{
Self
:
:
All
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
AddressMode
{
ClampToEdge
=
0
Repeat
=
1
MirrorRepeat
=
2
ClampToBorder
=
3
}
impl
Default
for
AddressMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
ClampToEdge
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
FilterMode
{
Nearest
=
0
Linear
=
1
}
impl
Default
for
FilterMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
Nearest
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PushConstantRange
{
pub
stages
:
ShaderStages
pub
range
:
Range
<
u32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CommandBufferDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandBufferDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandBufferDescriptor
<
K
>
{
CommandBufferDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
RenderBundleDepthStencil
{
pub
format
:
TextureFormat
pub
depth_read_only
:
bool
pub
stencil_read_only
:
bool
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderBundleDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
RenderBundleDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
RenderBundleDescriptor
<
K
>
{
RenderBundleDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
RenderBundleDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageDataLayout
{
pub
offset
:
BufferAddress
pub
bytes_per_row
:
Option
<
NonZeroU32
>
pub
rows_per_image
:
Option
<
NonZeroU32
>
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BufferBindingType
{
Uniform
Storage
{
read_only
:
bool
}
}
impl
Default
for
BufferBindingType
{
fn
default
(
)
-
>
Self
{
Self
:
:
Uniform
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureSampleType
{
Float
{
filterable
:
bool
}
Depth
Sint
Uint
}
impl
Default
for
TextureSampleType
{
fn
default
(
)
-
>
Self
{
Self
:
:
Float
{
filterable
:
true
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StorageTextureAccess
{
WriteOnly
ReadOnly
ReadWrite
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BindingType
{
Buffer
{
ty
:
BufferBindingType
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
has_dynamic_offset
:
bool
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
min_binding_size
:
Option
<
BufferSize
>
}
Sampler
{
filtering
:
bool
comparison
:
bool
}
Texture
{
sample_type
:
TextureSampleType
view_dimension
:
TextureViewDimension
multisampled
:
bool
}
StorageTexture
{
access
:
StorageTextureAccess
format
:
TextureFormat
view_dimension
:
TextureViewDimension
}
}
impl
BindingType
{
pub
fn
has_dynamic_offset
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Buffer
{
has_dynamic_offset
.
.
}
=
>
has_dynamic_offset
_
=
>
false
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BindGroupLayoutEntry
{
pub
binding
:
u32
pub
visibility
:
ShaderStages
pub
ty
:
BindingType
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
count
:
Option
<
NonZeroU32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageCopyBuffer
<
B
>
{
pub
buffer
:
B
pub
layout
:
ImageDataLayout
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageCopyTexture
<
T
>
{
pub
texture
:
T
pub
mip_level
:
u32
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
origin
:
Origin3d
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
aspect
:
TextureAspect
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageSubresourceRange
{
pub
aspect
:
TextureAspect
pub
base_mip_level
:
u32
pub
mip_level_count
:
Option
<
NonZeroU32
>
pub
base_array_layer
:
u32
pub
array_layer_count
:
Option
<
NonZeroU32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
SamplerBorderColor
{
TransparentBlack
OpaqueBlack
OpaqueWhite
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
QuerySetDescriptor
<
L
>
{
pub
label
:
L
pub
ty
:
QueryType
pub
count
:
u32
}
impl
<
L
>
QuerySetDescriptor
<
L
>
{
pub
fn
map_label
<
'
a
K
>
(
&
'
a
self
fun
:
impl
FnOnce
(
&
'
a
L
)
-
>
K
)
-
>
QuerySetDescriptor
<
K
>
{
QuerySetDescriptor
{
label
:
fun
(
&
self
.
label
)
ty
:
self
.
ty
count
:
self
.
count
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
QueryType
{
Occlusion
PipelineStatistics
(
PipelineStatisticsTypes
)
Timestamp
}
bitflags
:
:
bitflags
!
{
/
/
/
Flags
for
which
pipeline
data
should
be
recorded
.
/
/
/
/
/
/
The
amount
of
values
written
when
resolved
depends
/
/
/
on
the
amount
of
flags
.
If
3
flags
are
enabled
3
/
/
/
64
-
bit
values
will
be
written
per
-
query
.
/
/
/
/
/
/
The
order
they
are
written
is
the
order
they
are
declared
/
/
/
in
this
bitflags
.
If
you
enabled
CLIPPER_PRIMITIVES_OUT
#
[
repr
(
transparent
)
]
pub
struct
PipelineStatisticsTypes
:
u8
{
/
/
/
Amount
of
times
the
vertex
shader
is
ran
.
Accounts
for
/
/
/
the
vertex
cache
when
doing
indexed
rendering
.
const
VERTEX_SHADER_INVOCATIONS
=
1
<
<
0
;
/
/
/
Amount
of
times
the
clipper
is
invoked
.
This
/
/
/
is
also
the
amount
of
triangles
output
by
the
vertex
shader
.
const
CLIPPER_INVOCATIONS
=
1
<
<
1
;
/
/
/
Amount
of
primitives
that
are
not
culled
by
the
clipper
.
/
/
/
This
is
the
amount
of
triangles
that
are
actually
on
screen
/
/
/
and
will
be
rasterized
and
rendered
.
const
CLIPPER_PRIMITIVES_OUT
=
1
<
<
2
;
/
/
/
Amount
of
times
the
fragment
shader
is
ran
.
Accounts
for
/
/
/
fragment
shaders
running
in
2x2
blocks
in
order
to
get
/
/
/
derivatives
.
const
FRAGMENT_SHADER_INVOCATIONS
=
1
<
<
3
;
/
/
/
Amount
of
times
a
compute
shader
is
invoked
.
This
will
/
/
/
be
equivalent
to
the
dispatch
count
times
the
workgroup
size
.
const
COMPUTE_SHADER_INVOCATIONS
=
1
<
<
4
;
}
}
#
[
cfg
(
feature
=
"
bitflags_serde_shim
"
)
]
bitflags_serde_shim
:
:
impl_serde_for_bitflags
!
(
PipelineStatisticsTypes
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DrawIndirectArgs
{
pub
vertex_count
:
u32
pub
instance_count
:
u32
pub
first_vertex
:
u32
pub
first_instance
:
u32
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DrawIndexedIndirectArgs
{
pub
index_count
:
u32
pub
instance_count
:
u32
pub
first_index
:
u32
pub
base_vertex
:
i32
pub
first_instance
:
u32
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DispatchIndirectArgs
{
pub
group_size_x
:
u32
pub
group_size_y
:
u32
pub
group_size_z
:
u32
}
