#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
doc_auto_cfg
)
)
]
#
!
[
allow
(
clippy
:
:
match_like_matches_macro
)
]
#
!
[
warn
(
clippy
:
:
ptr_as_ptr
missing_docs
unsafe_op_in_unsafe_fn
)
]
#
!
[
no_std
]
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
std
;
extern
crate
alloc
;
use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
{
string
:
:
String
vec
vec
:
:
Vec
}
;
use
core
:
:
{
fmt
hash
:
:
{
Hash
Hasher
}
mem
num
:
:
NonZeroU32
ops
:
:
Range
}
;
use
bytemuck
:
:
{
Pod
Zeroable
}
;
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
use
{
alloc
:
:
format
serde
:
:
{
Deserialize
Serialize
}
}
;
pub
mod
assertions
;
mod
cast_utils
;
mod
counters
;
mod
env
;
pub
mod
error
;
mod
features
;
pub
mod
instance
;
pub
mod
math
;
mod
transfers
;
pub
use
counters
:
:
*
;
pub
use
features
:
:
*
;
pub
use
instance
:
:
*
;
pub
use
transfers
:
:
*
;
pub
type
BufferAddress
=
u64
;
pub
type
BufferSize
=
core
:
:
num
:
:
NonZeroU64
;
pub
type
ShaderLocation
=
u32
;
pub
type
DynamicOffset
=
u32
;
pub
const
COPY_BYTES_PER_ROW_ALIGNMENT
:
u32
=
256
;
pub
const
QUERY_RESOLVE_BUFFER_ALIGNMENT
:
BufferAddress
=
256
;
pub
const
COPY_BUFFER_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
MAP_ALIGNMENT
:
BufferAddress
=
8
;
pub
const
VERTEX_ALIGNMENT
:
BufferAddress
=
4
;
#
[
deprecated
(
note
=
"
Use
VERTEX_ALIGNMENT
instead
"
since
=
"
27
.
0
.
0
"
)
]
pub
const
VERTEX_STRIDE_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
PUSH_CONSTANT_ALIGNMENT
:
u32
=
4
;
pub
const
QUERY_SET_MAX_QUERIES
:
u32
=
4096
;
pub
const
QUERY_SIZE
:
u32
=
8
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
Backend
{
Noop
=
0
Vulkan
=
1
Metal
=
2
Dx12
=
3
Gl
=
4
BrowserWebGpu
=
5
}
impl
Backend
{
pub
const
ALL
:
[
Backend
;
Backends
:
:
all
(
)
.
bits
(
)
.
count_ones
(
)
as
usize
]
=
[
Self
:
:
Noop
Self
:
:
Vulkan
Self
:
:
Metal
Self
:
:
Dx12
Self
:
:
Gl
Self
:
:
BrowserWebGpu
]
;
#
[
must_use
]
pub
const
fn
to_str
(
self
)
-
>
&
'
static
str
{
match
self
{
Backend
:
:
Noop
=
>
"
noop
"
Backend
:
:
Vulkan
=
>
"
vulkan
"
Backend
:
:
Metal
=
>
"
metal
"
Backend
:
:
Dx12
=
>
"
dx12
"
Backend
:
:
Gl
=
>
"
gl
"
Backend
:
:
BrowserWebGpu
=
>
"
webgpu
"
}
}
}
impl
core
:
:
fmt
:
:
Display
for
Backend
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
write_str
(
self
.
to_str
(
)
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PowerPreference
{
#
[
default
]
None
=
0
LowPower
=
1
HighPerformance
=
2
}
impl
PowerPreference
{
pub
fn
from_env
(
)
-
>
Option
<
Self
>
{
let
env
=
crate
:
:
env
:
:
var
(
"
WGPU_POWER_PREF
"
)
?
;
match
env
.
to_lowercase
(
)
.
as_str
(
)
{
"
low
"
=
>
Some
(
Self
:
:
LowPower
)
"
high
"
=
>
Some
(
Self
:
:
HighPerformance
)
"
none
"
=
>
Some
(
Self
:
:
None
)
_
=
>
None
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Represents
the
backends
that
wgpu
will
use
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
Backends
:
u32
{
/
/
/
[
Backend
:
:
Noop
]
.
const
NOOP
=
1
<
<
Backend
:
:
Noop
as
u32
;
/
/
/
[
Backend
:
:
Vulkan
]
.
/
/
/
Supported
on
Windows
Linux
/
Android
and
macOS
/
iOS
via
Vulkan
Portability
(
with
the
Vulkan
feature
enabled
)
const
VULKAN
=
1
<
<
Backend
:
:
Vulkan
as
u32
;
/
/
/
[
Backend
:
:
Gl
]
.
/
/
/
Supported
on
Linux
/
Android
the
web
through
webassembly
via
WebGL
and
Windows
and
/
/
/
macOS
/
iOS
via
ANGLE
const
GL
=
1
<
<
Backend
:
:
Gl
as
u32
;
/
/
/
[
Backend
:
:
Metal
]
.
/
/
/
Supported
on
macOS
and
iOS
.
const
METAL
=
1
<
<
Backend
:
:
Metal
as
u32
;
/
/
/
[
Backend
:
:
Dx12
]
.
/
/
/
Supported
on
Windows
10
and
later
const
DX12
=
1
<
<
Backend
:
:
Dx12
as
u32
;
/
/
/
[
Backend
:
:
BrowserWebGpu
]
.
/
/
/
Supported
when
targeting
the
web
through
WebAssembly
with
the
webgpu
feature
enabled
.
/
/
/
/
/
/
The
WebGPU
backend
is
special
in
several
ways
:
/
/
/
It
is
not
not
implemented
by
wgpu_core
and
instead
by
the
higher
level
wgpu
crate
.
/
/
/
Whether
WebGPU
is
targeted
is
decided
upon
the
creation
of
the
wgpu
:
:
Instance
/
/
/
*
not
*
upon
adapter
creation
.
See
wgpu
:
:
Instance
:
:
new
.
const
BROWSER_WEBGPU
=
1
<
<
Backend
:
:
BrowserWebGpu
as
u32
;
/
/
/
All
the
apis
that
wgpu
offers
first
tier
of
support
for
.
/
/
/
/
/
/
*
[
Backends
:
:
VULKAN
]
/
/
/
*
[
Backends
:
:
METAL
]
/
/
/
*
[
Backends
:
:
DX12
]
/
/
/
*
[
Backends
:
:
BROWSER_WEBGPU
]
const
PRIMARY
=
Self
:
:
VULKAN
.
bits
(
)
|
Self
:
:
METAL
.
bits
(
)
|
Self
:
:
DX12
.
bits
(
)
|
Self
:
:
BROWSER_WEBGPU
.
bits
(
)
;
/
/
/
All
the
apis
that
wgpu
offers
second
tier
of
support
for
.
These
may
/
/
/
be
unsupported
/
still
experimental
.
/
/
/
/
/
/
*
[
Backends
:
:
GL
]
const
SECONDARY
=
Self
:
:
GL
.
bits
(
)
;
}
}
impl
Default
for
Backends
{
fn
default
(
)
-
>
Self
{
Self
:
:
all
(
)
}
}
impl
From
<
Backend
>
for
Backends
{
fn
from
(
backend
:
Backend
)
-
>
Self
{
Self
:
:
from_bits
(
1
<
<
backend
as
u32
)
.
unwrap
(
)
}
}
impl
Backends
{
pub
fn
from_env
(
)
-
>
Option
<
Self
>
{
let
env
=
crate
:
:
env
:
:
var
(
"
WGPU_BACKEND
"
)
?
;
Some
(
Self
:
:
from_comma_list
(
&
env
)
)
}
pub
fn
with_env
(
&
self
)
-
>
Self
{
if
let
Some
(
env
)
=
Self
:
:
from_env
(
)
{
env
}
else
{
*
self
}
}
pub
fn
from_comma_list
(
string
:
&
str
)
-
>
Self
{
let
mut
backends
=
Self
:
:
empty
(
)
;
for
backend
in
string
.
to_lowercase
(
)
.
split
(
'
'
)
{
backends
|
=
match
backend
.
trim
(
)
{
"
vulkan
"
|
"
vk
"
=
>
Self
:
:
VULKAN
"
dx12
"
|
"
d3d12
"
=
>
Self
:
:
DX12
"
metal
"
|
"
mtl
"
=
>
Self
:
:
METAL
"
opengl
"
|
"
gles
"
|
"
gl
"
=
>
Self
:
:
GL
"
webgpu
"
=
>
Self
:
:
BROWSER_WEBGPU
"
noop
"
=
>
Self
:
:
NOOP
b
=
>
{
log
:
:
warn
!
(
"
unknown
backend
string
'
{
b
}
'
"
)
;
continue
;
}
}
}
if
backends
.
is_empty
(
)
{
log
:
:
warn
!
(
"
no
valid
backend
strings
found
!
"
)
;
}
backends
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
RequestAdapterOptions
<
S
>
{
pub
power_preference
:
PowerPreference
pub
force_fallback_adapter
:
bool
pub
compatible_surface
:
Option
<
S
>
}
impl
<
S
>
Default
for
RequestAdapterOptions
<
S
>
{
fn
default
(
)
-
>
Self
{
Self
{
power_preference
:
PowerPreference
:
:
default
(
)
force_fallback_adapter
:
false
compatible_surface
:
None
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
enum
RequestAdapterError
{
NotFound
{
#
[
doc
(
hidden
)
]
active_backends
:
Backends
#
[
doc
(
hidden
)
]
requested_backends
:
Backends
#
[
doc
(
hidden
)
]
supported_backends
:
Backends
#
[
doc
(
hidden
)
]
no_fallback_backends
:
Backends
#
[
doc
(
hidden
)
]
no_adapter_backends
:
Backends
#
[
doc
(
hidden
)
]
incompatible_surface_backends
:
Backends
}
EnvNotSet
}
impl
core
:
:
error
:
:
Error
for
RequestAdapterError
{
}
impl
fmt
:
:
Display
for
RequestAdapterError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
RequestAdapterError
:
:
NotFound
{
active_backends
requested_backends
supported_backends
no_fallback_backends
no_adapter_backends
incompatible_surface_backends
}
=
>
{
write
!
(
f
"
No
suitable
graphics
adapter
found
;
"
)
?
;
let
mut
first
=
true
;
for
backend
in
Backend
:
:
ALL
{
let
bit
=
Backends
:
:
from
(
backend
)
;
let
comma
=
if
mem
:
:
take
(
&
mut
first
)
{
"
"
}
else
{
"
"
}
;
let
explanation
=
if
!
requested_backends
.
contains
(
bit
)
{
"
not
requested
"
}
else
if
!
supported_backends
.
contains
(
bit
)
{
"
support
not
compiled
in
"
}
else
if
no_adapter_backends
.
contains
(
bit
)
{
"
found
no
adapters
"
}
else
if
incompatible_surface_backends
.
contains
(
bit
)
{
"
not
compatible
with
provided
surface
"
}
else
if
no_fallback_backends
.
contains
(
bit
)
{
"
had
no
fallback
adapters
"
}
else
if
!
active_backends
.
contains
(
bit
)
{
if
backend
=
=
Backend
:
:
Noop
{
"
not
explicitly
enabled
"
}
else
{
"
drivers
/
libraries
could
not
be
loaded
"
}
}
else
{
"
[
unknown
reason
]
"
}
;
write
!
(
f
"
{
comma
}
{
backend
}
{
explanation
}
"
)
?
;
}
}
RequestAdapterError
:
:
EnvNotSet
=
>
f
.
write_str
(
"
WGPU_ADAPTER_NAME
not
set
"
)
?
}
Ok
(
(
)
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
default
)
)
]
pub
struct
Limits
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension1D
"
)
)
]
pub
max_texture_dimension_1d
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension2D
"
)
)
]
pub
max_texture_dimension_2d
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension3D
"
)
)
]
pub
max_texture_dimension_3d
:
u32
pub
max_texture_array_layers
:
u32
pub
max_bind_groups
:
u32
pub
max_bindings_per_bind_group
:
u32
pub
max_dynamic_uniform_buffers_per_pipeline_layout
:
u32
pub
max_dynamic_storage_buffers_per_pipeline_layout
:
u32
pub
max_sampled_textures_per_shader_stage
:
u32
pub
max_samplers_per_shader_stage
:
u32
pub
max_storage_buffers_per_shader_stage
:
u32
pub
max_storage_textures_per_shader_stage
:
u32
pub
max_uniform_buffers_per_shader_stage
:
u32
pub
max_binding_array_elements_per_shader_stage
:
u32
pub
max_binding_array_sampler_elements_per_shader_stage
:
u32
pub
max_uniform_buffer_binding_size
:
u32
pub
max_storage_buffer_binding_size
:
u32
pub
max_vertex_buffers
:
u32
pub
max_buffer_size
:
u64
pub
max_vertex_attributes
:
u32
pub
max_vertex_buffer_array_stride
:
u32
pub
min_uniform_buffer_offset_alignment
:
u32
pub
min_storage_buffer_offset_alignment
:
u32
pub
max_inter_stage_shader_components
:
u32
pub
max_color_attachments
:
u32
pub
max_color_attachment_bytes_per_sample
:
u32
pub
max_compute_workgroup_storage_size
:
u32
pub
max_compute_invocations_per_workgroup
:
u32
pub
max_compute_workgroup_size_x
:
u32
pub
max_compute_workgroup_size_y
:
u32
pub
max_compute_workgroup_size_z
:
u32
pub
max_compute_workgroups_per_dimension
:
u32
pub
min_subgroup_size
:
u32
pub
max_subgroup_size
:
u32
pub
max_push_constant_size
:
u32
pub
max_non_sampler_bindings
:
u32
pub
max_task_workgroup_total_count
:
u32
pub
max_task_workgroups_per_dimension
:
u32
pub
max_mesh_output_layers
:
u32
pub
max_mesh_multiview_count
:
u32
pub
max_blas_primitive_count
:
u32
pub
max_blas_geometry_count
:
u32
pub
max_tlas_instance_count
:
u32
pub
max_acceleration_structures_per_shader_stage
:
u32
}
impl
Default
for
Limits
{
fn
default
(
)
-
>
Self
{
Self
:
:
defaults
(
)
}
}
impl
Limits
{
#
[
must_use
]
pub
const
fn
defaults
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
8192
max_texture_dimension_2d
:
8192
max_texture_dimension_3d
:
2048
max_texture_array_layers
:
256
max_bind_groups
:
4
max_bindings_per_bind_group
:
1000
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
8
max_storage_textures_per_shader_stage
:
4
max_uniform_buffers_per_shader_stage
:
12
max_binding_array_elements_per_shader_stage
:
0
max_binding_array_sampler_elements_per_shader_stage
:
0
max_uniform_buffer_binding_size
:
64
<
<
10
max_storage_buffer_binding_size
:
128
<
<
20
max_vertex_buffers
:
8
max_buffer_size
:
256
<
<
20
max_vertex_attributes
:
16
max_vertex_buffer_array_stride
:
2048
min_uniform_buffer_offset_alignment
:
256
min_storage_buffer_offset_alignment
:
256
max_inter_stage_shader_components
:
60
max_color_attachments
:
8
max_color_attachment_bytes_per_sample
:
32
max_compute_workgroup_storage_size
:
16384
max_compute_invocations_per_workgroup
:
256
max_compute_workgroup_size_x
:
256
max_compute_workgroup_size_y
:
256
max_compute_workgroup_size_z
:
64
max_compute_workgroups_per_dimension
:
65535
min_subgroup_size
:
0
max_subgroup_size
:
0
max_push_constant_size
:
0
max_non_sampler_bindings
:
1_000_000
max_task_workgroup_total_count
:
0
max_task_workgroups_per_dimension
:
0
max_mesh_multiview_count
:
0
max_mesh_output_layers
:
0
max_blas_primitive_count
:
0
max_blas_geometry_count
:
0
max_tlas_instance_count
:
0
max_acceleration_structures_per_shader_stage
:
0
}
}
#
[
must_use
]
pub
const
fn
downlevel_defaults
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
2048
max_texture_dimension_2d
:
2048
max_texture_dimension_3d
:
256
max_storage_buffers_per_shader_stage
:
4
max_uniform_buffer_binding_size
:
16
<
<
10
max_color_attachments
:
4
max_compute_workgroup_storage_size
:
16352
max_task_workgroups_per_dimension
:
0
max_task_workgroup_total_count
:
0
max_mesh_multiview_count
:
0
max_mesh_output_layers
:
0
.
.
Self
:
:
defaults
(
)
}
}
#
[
must_use
]
pub
const
fn
downlevel_webgl2_defaults
(
)
-
>
Self
{
Self
{
max_uniform_buffers_per_shader_stage
:
11
max_storage_buffers_per_shader_stage
:
0
max_storage_textures_per_shader_stage
:
0
max_dynamic_storage_buffers_per_pipeline_layout
:
0
max_storage_buffer_binding_size
:
0
max_vertex_buffer_array_stride
:
255
max_compute_workgroup_storage_size
:
0
max_compute_invocations_per_workgroup
:
0
max_compute_workgroup_size_x
:
0
max_compute_workgroup_size_y
:
0
max_compute_workgroup_size_z
:
0
max_compute_workgroups_per_dimension
:
0
min_subgroup_size
:
0
max_subgroup_size
:
0
max_inter_stage_shader_components
:
31
.
.
Self
:
:
downlevel_defaults
(
)
}
}
#
[
must_use
]
pub
const
fn
using_resolution
(
self
other
:
Self
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
other
.
max_texture_dimension_1d
max_texture_dimension_2d
:
other
.
max_texture_dimension_2d
max_texture_dimension_3d
:
other
.
max_texture_dimension_3d
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_alignment
(
self
other
:
Self
)
-
>
Self
{
Self
{
min_uniform_buffer_offset_alignment
:
other
.
min_uniform_buffer_offset_alignment
min_storage_buffer_offset_alignment
:
other
.
min_storage_buffer_offset_alignment
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_minimum_supported_acceleration_structure_values
(
self
)
-
>
Self
{
Self
{
max_blas_geometry_count
:
(
1
<
<
24
)
-
1
max_tlas_instance_count
:
(
1
<
<
24
)
-
1
max_blas_primitive_count
:
1
<
<
28
max_acceleration_structures_per_shader_stage
:
16
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_acceleration_structure_values
(
self
other
:
Self
)
-
>
Self
{
Self
{
max_blas_geometry_count
:
other
.
max_blas_geometry_count
max_tlas_instance_count
:
other
.
max_tlas_instance_count
max_blas_primitive_count
:
other
.
max_blas_primitive_count
max_acceleration_structures_per_shader_stage
:
other
.
max_acceleration_structures_per_shader_stage
.
.
self
}
}
#
[
must_use
]
pub
const
fn
using_recommended_minimum_mesh_shader_values
(
self
)
-
>
Self
{
Self
{
max_task_workgroup_total_count
:
65536
max_task_workgroups_per_dimension
:
256
max_mesh_multiview_count
:
0
max_mesh_output_layers
:
8
.
.
self
}
}
#
[
must_use
]
pub
fn
check_limits
(
&
self
allowed
:
&
Self
)
-
>
bool
{
let
mut
within
=
true
;
self
.
check_limits_with_fail_fn
(
allowed
true
|
_
_
_
|
within
=
false
)
;
within
}
pub
fn
check_limits_with_fail_fn
(
&
self
allowed
:
&
Self
fatal
:
bool
mut
fail_fn
:
impl
FnMut
(
&
'
static
str
u64
u64
)
)
{
use
core
:
:
cmp
:
:
Ordering
;
macro_rules
!
compare
{
(
name
:
ident
ordering
:
ident
)
=
>
{
match
self
.
name
.
cmp
(
&
allowed
.
name
)
{
Ordering
:
:
ordering
|
Ordering
:
:
Equal
=
>
(
)
_
=
>
{
fail_fn
(
stringify
!
(
name
)
self
.
name
as
u64
allowed
.
name
as
u64
)
;
if
fatal
{
return
;
}
}
}
}
;
}
compare
!
(
max_texture_dimension_1d
Less
)
;
compare
!
(
max_texture_dimension_2d
Less
)
;
compare
!
(
max_texture_dimension_3d
Less
)
;
compare
!
(
max_texture_array_layers
Less
)
;
compare
!
(
max_bind_groups
Less
)
;
compare
!
(
max_bindings_per_bind_group
Less
)
;
compare
!
(
max_dynamic_uniform_buffers_per_pipeline_layout
Less
)
;
compare
!
(
max_dynamic_storage_buffers_per_pipeline_layout
Less
)
;
compare
!
(
max_sampled_textures_per_shader_stage
Less
)
;
compare
!
(
max_samplers_per_shader_stage
Less
)
;
compare
!
(
max_storage_buffers_per_shader_stage
Less
)
;
compare
!
(
max_storage_textures_per_shader_stage
Less
)
;
compare
!
(
max_uniform_buffers_per_shader_stage
Less
)
;
compare
!
(
max_binding_array_elements_per_shader_stage
Less
)
;
compare
!
(
max_uniform_buffer_binding_size
Less
)
;
compare
!
(
max_storage_buffer_binding_size
Less
)
;
compare
!
(
max_vertex_buffers
Less
)
;
compare
!
(
max_buffer_size
Less
)
;
compare
!
(
max_vertex_attributes
Less
)
;
compare
!
(
max_vertex_buffer_array_stride
Less
)
;
compare
!
(
min_uniform_buffer_offset_alignment
Greater
)
;
compare
!
(
min_storage_buffer_offset_alignment
Greater
)
;
compare
!
(
max_inter_stage_shader_components
Less
)
;
compare
!
(
max_color_attachments
Less
)
;
compare
!
(
max_color_attachment_bytes_per_sample
Less
)
;
compare
!
(
max_compute_workgroup_storage_size
Less
)
;
compare
!
(
max_compute_invocations_per_workgroup
Less
)
;
compare
!
(
max_compute_workgroup_size_x
Less
)
;
compare
!
(
max_compute_workgroup_size_y
Less
)
;
compare
!
(
max_compute_workgroup_size_z
Less
)
;
compare
!
(
max_compute_workgroups_per_dimension
Less
)
;
if
self
.
min_subgroup_size
>
0
&
&
self
.
max_subgroup_size
>
0
{
compare
!
(
min_subgroup_size
Greater
)
;
compare
!
(
max_subgroup_size
Less
)
;
}
compare
!
(
max_push_constant_size
Less
)
;
compare
!
(
max_non_sampler_bindings
Less
)
;
compare
!
(
max_task_workgroup_total_count
Less
)
;
compare
!
(
max_task_workgroups_per_dimension
Less
)
;
compare
!
(
max_mesh_multiview_count
Less
)
;
compare
!
(
max_mesh_output_layers
Less
)
;
compare
!
(
max_blas_primitive_count
Less
)
;
compare
!
(
max_blas_geometry_count
Less
)
;
compare
!
(
max_tlas_instance_count
Less
)
;
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
DownlevelLimits
{
}
#
[
allow
(
clippy
:
:
derivable_impls
)
]
impl
Default
for
DownlevelLimits
{
fn
default
(
)
-
>
Self
{
DownlevelLimits
{
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
DownlevelCapabilities
{
pub
flags
:
DownlevelFlags
pub
limits
:
DownlevelLimits
pub
shader_model
:
ShaderModel
}
impl
Default
for
DownlevelCapabilities
{
fn
default
(
)
-
>
Self
{
Self
{
flags
:
DownlevelFlags
:
:
all
(
)
limits
:
DownlevelLimits
:
:
default
(
)
shader_model
:
ShaderModel
:
:
Sm5
}
}
}
impl
DownlevelCapabilities
{
#
[
must_use
]
pub
fn
is_webgpu_compliant
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
DownlevelFlags
:
:
compliant
(
)
)
&
&
self
.
limits
=
=
DownlevelLimits
:
:
default
(
)
&
&
self
.
shader_model
>
=
ShaderModel
:
:
Sm5
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Binary
flags
listing
features
that
may
or
may
not
be
present
on
downlevel
adapters
.
/
/
/
/
/
/
A
downlevel
adapter
is
a
GPU
adapter
that
WGPU
supports
but
with
potentially
limited
/
/
/
features
due
to
the
lack
of
hardware
feature
support
.
/
/
/
/
/
/
Flags
that
are
*
*
not
*
*
present
for
a
downlevel
adapter
or
device
usually
indicates
/
/
/
non
-
compliance
with
the
WebGPU
specification
but
not
always
.
/
/
/
/
/
/
You
can
check
whether
a
set
of
flags
is
compliant
through
the
/
/
/
[
DownlevelCapabilities
:
:
is_webgpu_compliant
(
)
]
function
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelFlags
:
u32
{
/
/
/
The
device
supports
compiling
and
using
compute
shaders
.
/
/
/
/
/
/
WebGL2
and
GLES3
.
0
devices
do
not
support
compute
.
const
COMPUTE_SHADERS
=
1
<
<
0
;
/
/
/
Supports
binding
storage
buffers
and
textures
to
fragment
shaders
.
const
FRAGMENT_WRITABLE_STORAGE
=
1
<
<
1
;
/
/
/
Supports
indirect
drawing
and
dispatching
.
/
/
/
/
/
/
[
Self
:
:
COMPUTE_SHADERS
]
must
be
present
for
this
flag
.
/
/
/
/
/
/
WebGL2
GLES
3
.
0
and
Metal
on
Apple1
/
Apple2
GPUs
do
not
support
indirect
.
const
INDIRECT_EXECUTION
=
1
<
<
2
;
/
/
/
Supports
non
-
zero
base_vertex
parameter
to
direct
indexed
draw
calls
.
/
/
/
/
/
/
Indirect
calls
if
supported
always
support
non
-
zero
base_vertex
.
/
/
/
/
/
/
Supported
by
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
on
Apple3
+
or
Mac1
+
/
/
/
-
OpenGL
3
.
2
+
/
/
/
-
OpenGL
ES
3
.
2
const
BASE_VERTEX
=
1
<
<
3
;
/
/
/
Supports
reading
from
a
depth
/
stencil
texture
while
using
it
as
a
read
-
only
/
/
/
depth
/
stencil
attachment
.
/
/
/
/
/
/
The
WebGL2
and
GLES
backends
do
not
support
RODS
.
const
READ_ONLY_DEPTH_STENCIL
=
1
<
<
4
;
/
/
/
Supports
textures
with
mipmaps
which
have
a
non
power
of
two
size
.
const
NON_POWER_OF_TWO_MIPMAPPED_TEXTURES
=
1
<
<
5
;
/
/
/
Supports
textures
that
are
cube
arrays
.
const
CUBE_ARRAY_TEXTURES
=
1
<
<
6
;
/
/
/
Supports
comparison
samplers
.
const
COMPARISON_SAMPLERS
=
1
<
<
7
;
/
/
/
Supports
different
blend
operations
per
color
attachment
.
const
INDEPENDENT_BLEND
=
1
<
<
8
;
/
/
/
Supports
storage
buffers
in
vertex
shaders
.
const
VERTEX_STORAGE
=
1
<
<
9
;
/
/
/
Supports
samplers
with
anisotropic
filtering
.
Note
this
isn
'
t
actually
required
by
/
/
/
WebGPU
the
implementation
is
allowed
to
completely
ignore
aniso
clamp
.
This
flag
is
/
/
/
here
for
native
backends
so
they
can
communicate
to
the
user
of
aniso
is
enabled
.
/
/
/
/
/
/
All
backends
and
all
devices
support
anisotropic
filtering
.
const
ANISOTROPIC_FILTERING
=
1
<
<
10
;
/
/
/
Supports
storage
buffers
in
fragment
shaders
.
const
FRAGMENT_STORAGE
=
1
<
<
11
;
/
/
/
Supports
sample
-
rate
shading
.
const
MULTISAMPLED_SHADING
=
1
<
<
12
;
/
/
/
Supports
copies
between
depth
textures
and
buffers
.
/
/
/
/
/
/
GLES
/
WebGL
don
'
t
support
this
.
const
DEPTH_TEXTURE_AND_BUFFER_COPIES
=
1
<
<
13
;
/
/
/
Supports
all
the
texture
usages
described
in
WebGPU
.
If
this
isn
'
t
supported
you
/
/
/
should
call
get_texture_format_features
to
get
how
you
can
use
textures
of
a
given
format
const
WEBGPU_TEXTURE_FORMAT_SUPPORT
=
1
<
<
14
;
/
/
/
Supports
buffer
bindings
with
sizes
that
aren
'
t
a
multiple
of
16
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
const
BUFFER_BINDINGS_NOT_16_BYTE_ALIGNED
=
1
<
<
15
;
/
/
/
Supports
buffers
to
combine
[
BufferUsages
:
:
INDEX
]
with
usages
other
than
[
BufferUsages
:
:
COPY_DST
]
and
[
BufferUsages
:
:
COPY_SRC
]
.
/
/
/
Furthermore
in
absence
of
this
feature
it
is
not
allowed
to
copy
index
buffers
from
/
to
buffers
with
a
set
of
usage
flags
containing
/
/
/
[
BufferUsages
:
:
VERTEX
]
/
[
BufferUsages
:
:
UNIFORM
]
/
[
BufferUsages
:
:
STORAGE
]
or
[
BufferUsages
:
:
INDIRECT
]
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
const
UNRESTRICTED_INDEX_BUFFER
=
1
<
<
16
;
/
/
/
Supports
full
32
-
bit
range
indices
(
2
^
32
-
1
as
opposed
to
2
^
24
-
1
without
this
flag
)
/
/
/
/
/
/
Corresponds
to
Vulkan
'
s
VkPhysicalDeviceFeatures
.
fullDrawIndexUint32
const
FULL_DRAW_INDEX_UINT32
=
1
<
<
17
;
/
/
/
Supports
depth
bias
clamping
/
/
/
/
/
/
Corresponds
to
Vulkan
'
s
VkPhysicalDeviceFeatures
.
depthBiasClamp
const
DEPTH_BIAS_CLAMP
=
1
<
<
18
;
/
/
/
Supports
specifying
which
view
format
values
are
allowed
when
create_view
(
)
is
called
on
a
texture
.
/
/
/
/
/
/
The
WebGL
and
GLES
backends
doesn
'
t
support
this
.
const
VIEW_FORMATS
=
1
<
<
19
;
/
/
/
With
this
feature
not
present
there
are
the
following
restrictions
on
Queue
:
:
copy_external_image_to_texture
:
/
/
/
-
The
source
must
not
be
[
web_sys
:
:
OffscreenCanvas
]
/
/
/
-
[
CopyExternalImageSourceInfo
:
:
origin
]
must
be
zero
.
/
/
/
-
[
CopyExternalImageDestInfo
:
:
color_space
]
must
be
srgb
.
/
/
/
-
If
the
source
is
an
[
web_sys
:
:
ImageBitmap
]
:
/
/
/
-
[
CopyExternalImageSourceInfo
:
:
flip_y
]
must
be
false
.
/
/
/
-
[
CopyExternalImageDestInfo
:
:
premultiplied_alpha
]
must
be
false
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
WebGPU
does
.
const
UNRESTRICTED_EXTERNAL_TEXTURE_COPIES
=
1
<
<
20
;
/
/
/
Supports
specifying
which
view
formats
are
allowed
when
calling
create_view
on
the
texture
returned
by
/
/
/
Surface
:
:
get_current_texture
.
/
/
/
/
/
/
The
GLES
/
WebGL
and
Vulkan
on
Android
doesn
'
t
support
this
.
const
SURFACE_VIEW_FORMATS
=
1
<
<
21
;
/
/
/
If
this
is
true
calls
to
CommandEncoder
:
:
resolve_query_set
will
be
performed
on
the
queue
timeline
.
/
/
/
/
/
/
If
this
is
false
calls
to
CommandEncoder
:
:
resolve_query_set
will
be
performed
on
the
device
(
i
.
e
.
cpu
)
timeline
/
/
/
and
will
block
that
timeline
until
the
query
has
data
.
You
may
work
around
this
limitation
by
waiting
until
the
submit
/
/
/
whose
queries
you
are
resolving
is
fully
finished
(
through
use
of
queue
.
on_submitted_work_done
)
and
only
/
/
/
then
submitting
the
resolve_query_set
command
.
The
queries
will
be
guaranteed
finished
so
will
not
block
.
/
/
/
/
/
/
Supported
by
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
-
OpenGL
4
.
4
+
/
/
/
/
/
/
Not
Supported
by
:
/
/
/
-
GL
ES
/
WebGL
const
NONBLOCKING_QUERY_RESOLVE
=
1
<
<
22
;
}
}
impl
DownlevelFlags
{
#
[
must_use
]
pub
const
fn
compliant
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
Self
:
:
all
(
)
.
bits
(
)
&
!
Self
:
:
ANISOTROPIC_FILTERING
.
bits
(
)
)
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
ShaderModel
{
Sm2
Sm4
Sm5
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
DeviceType
{
Other
IntegratedGpu
DiscreteGpu
VirtualGpu
Cpu
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
AdapterInfo
{
pub
name
:
String
pub
vendor
:
u32
pub
device
:
u32
pub
device_type
:
DeviceType
pub
driver
:
String
pub
driver_info
:
String
pub
backend
:
Backend
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
MemoryHints
{
#
[
default
]
Performance
MemoryUsage
Manual
{
suballocated_device_memory_block_size
:
Range
<
u64
>
}
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
DeviceDescriptor
<
L
>
{
pub
label
:
L
pub
required_features
:
Features
pub
required_limits
:
Limits
pub
memory_hints
:
MemoryHints
pub
trace
:
Trace
}
impl
<
L
>
DeviceDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
DeviceDescriptor
<
K
>
{
DeviceDescriptor
{
label
:
fun
(
&
self
.
label
)
required_features
:
self
.
required_features
required_limits
:
self
.
required_limits
.
clone
(
)
memory_hints
:
self
.
memory_hints
.
clone
(
)
trace
:
self
.
trace
.
clone
(
)
}
}
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
enum
Trace
{
#
[
default
]
Off
#
[
cfg
(
feature
=
"
trace
"
)
]
Directory
(
std
:
:
path
:
:
PathBuf
)
}
bitflags
:
:
bitflags
!
{
/
/
/
Describes
the
shader
stages
that
a
binding
will
be
visible
from
.
/
/
/
/
/
/
These
can
be
combined
so
something
that
is
visible
from
both
vertex
and
fragment
shaders
can
be
defined
as
:
/
/
/
/
/
/
ShaderStages
:
:
VERTEX
|
ShaderStages
:
:
FRAGMENT
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
ShaderStages
:
u32
{
/
/
/
Binding
is
not
visible
from
any
shader
stage
.
const
NONE
=
0
;
/
/
/
Binding
is
visible
from
the
vertex
shader
of
a
render
pipeline
.
const
VERTEX
=
1
<
<
0
;
/
/
/
Binding
is
visible
from
the
fragment
shader
of
a
render
pipeline
.
const
FRAGMENT
=
1
<
<
1
;
/
/
/
Binding
is
visible
from
the
compute
shader
of
a
compute
pipeline
.
const
COMPUTE
=
1
<
<
2
;
/
/
/
Binding
is
visible
from
the
vertex
and
fragment
shaders
of
a
render
pipeline
.
const
VERTEX_FRAGMENT
=
Self
:
:
VERTEX
.
bits
(
)
|
Self
:
:
FRAGMENT
.
bits
(
)
;
/
/
/
Binding
is
visible
from
the
task
shader
of
a
mesh
pipeline
.
const
TASK
=
1
<
<
3
;
/
/
/
Binding
is
visible
from
the
mesh
shader
of
a
mesh
pipeline
.
const
MESH
=
1
<
<
4
;
}
}
#
[
derive
(
Clone
Copy
Default
Debug
PartialEq
Eq
Hash
)
]
pub
enum
TextureDataOrder
{
#
[
default
]
LayerMajor
MipMajor
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
TextureViewDimension
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
1d
"
)
)
]
D1
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
"
)
)
]
#
[
default
]
D2
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
-
array
"
)
)
]
D2Array
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
cube
"
)
)
]
Cube
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
cube
-
array
"
)
)
]
CubeArray
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
3d
"
)
)
]
D3
}
impl
TextureViewDimension
{
#
[
must_use
]
pub
fn
compatible_texture_dimension
(
self
)
-
>
TextureDimension
{
match
self
{
Self
:
:
D1
=
>
TextureDimension
:
:
D1
Self
:
:
D2
|
Self
:
:
D2Array
|
Self
:
:
Cube
|
Self
:
:
CubeArray
=
>
TextureDimension
:
:
D2
Self
:
:
D3
=
>
TextureDimension
:
:
D3
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
BlendFactor
{
Zero
=
0
One
=
1
Src
=
2
OneMinusSrc
=
3
SrcAlpha
=
4
OneMinusSrcAlpha
=
5
Dst
=
6
OneMinusDst
=
7
DstAlpha
=
8
OneMinusDstAlpha
=
9
SrcAlphaSaturated
=
10
Constant
=
11
OneMinusConstant
=
12
Src1
=
13
OneMinusSrc1
=
14
Src1Alpha
=
15
OneMinusSrc1Alpha
=
16
}
impl
BlendFactor
{
#
[
must_use
]
pub
fn
ref_second_blend_source
(
&
self
)
-
>
bool
{
match
self
{
BlendFactor
:
:
Src1
|
BlendFactor
:
:
OneMinusSrc1
|
BlendFactor
:
:
Src1Alpha
|
BlendFactor
:
:
OneMinusSrc1Alpha
=
>
true
_
=
>
false
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
BlendOperation
{
#
[
default
]
Add
=
0
Subtract
=
1
ReverseSubtract
=
2
Min
=
3
Max
=
4
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
BlendComponent
{
pub
src_factor
:
BlendFactor
pub
dst_factor
:
BlendFactor
pub
operation
:
BlendOperation
}
impl
BlendComponent
{
pub
const
REPLACE
:
Self
=
Self
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
Zero
operation
:
BlendOperation
:
:
Add
}
;
pub
const
OVER
:
Self
=
Self
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
OneMinusSrcAlpha
operation
:
BlendOperation
:
:
Add
}
;
#
[
must_use
]
pub
fn
uses_constant
(
&
self
)
-
>
bool
{
match
(
self
.
src_factor
self
.
dst_factor
)
{
(
BlendFactor
:
:
Constant
_
)
|
(
BlendFactor
:
:
OneMinusConstant
_
)
|
(
_
BlendFactor
:
:
Constant
)
|
(
_
BlendFactor
:
:
OneMinusConstant
)
=
>
true
(
_
_
)
=
>
false
}
}
}
impl
Default
for
BlendComponent
{
fn
default
(
)
-
>
Self
{
Self
:
:
REPLACE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
BlendState
{
pub
color
:
BlendComponent
pub
alpha
:
BlendComponent
}
impl
BlendState
{
pub
const
REPLACE
:
Self
=
Self
{
color
:
BlendComponent
:
:
REPLACE
alpha
:
BlendComponent
:
:
REPLACE
}
;
pub
const
ALPHA_BLENDING
:
Self
=
Self
{
color
:
BlendComponent
{
src_factor
:
BlendFactor
:
:
SrcAlpha
dst_factor
:
BlendFactor
:
:
OneMinusSrcAlpha
operation
:
BlendOperation
:
:
Add
}
alpha
:
BlendComponent
:
:
OVER
}
;
pub
const
PREMULTIPLIED_ALPHA_BLENDING
:
Self
=
Self
{
color
:
BlendComponent
:
:
OVER
alpha
:
BlendComponent
:
:
OVER
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
ColorTargetState
{
pub
format
:
TextureFormat
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
blend
:
Option
<
BlendState
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
write_mask
:
ColorWrites
}
impl
From
<
TextureFormat
>
for
ColorTargetState
{
fn
from
(
format
:
TextureFormat
)
-
>
Self
{
Self
{
format
blend
:
None
write_mask
:
ColorWrites
:
:
ALL
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PrimitiveTopology
{
PointList
=
0
LineList
=
1
LineStrip
=
2
#
[
default
]
TriangleList
=
3
TriangleStrip
=
4
}
impl
PrimitiveTopology
{
#
[
must_use
]
pub
fn
is_strip
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
PointList
|
Self
:
:
LineList
|
Self
:
:
TriangleList
=
>
false
Self
:
:
LineStrip
|
Self
:
:
TriangleStrip
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
FrontFace
{
#
[
default
]
Ccw
=
0
Cw
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
Face
{
Front
=
0
Back
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PolygonMode
{
#
[
default
]
Fill
=
0
Line
=
1
Point
=
2
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
PrimitiveState
{
pub
topology
:
PrimitiveTopology
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
strip_index_format
:
Option
<
IndexFormat
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
front_face
:
FrontFace
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
cull_mode
:
Option
<
Face
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
unclipped_depth
:
bool
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
polygon_mode
:
PolygonMode
pub
conservative
:
bool
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
MultisampleState
{
pub
count
:
u32
pub
mask
:
u64
pub
alpha_to_coverage_enabled
:
bool
}
impl
Default
for
MultisampleState
{
fn
default
(
)
-
>
Self
{
MultisampleState
{
count
:
1
mask
:
!
0
alpha_to_coverage_enabled
:
false
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Feature
flags
for
a
texture
format
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TextureFormatFeatureFlags
:
u32
{
/
/
/
If
not
present
the
texture
can
'
t
be
sampled
with
a
filtering
sampler
.
/
/
/
This
may
overwrite
TextureSampleType
:
:
Float
.
filterable
const
FILTERABLE
=
1
<
<
0
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
2
.
const
MULTISAMPLE_X2
=
1
<
<
1
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
4
.
const
MULTISAMPLE_X4
=
1
<
<
2
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
8
.
const
MULTISAMPLE_X8
=
1
<
<
3
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
16
.
const
MULTISAMPLE_X16
=
1
<
<
4
;
/
/
/
Allows
a
texture
of
this
format
to
back
a
view
passed
as
resolve_target
/
/
/
to
a
render
pass
for
an
automatic
driver
-
implemented
resolve
.
const
MULTISAMPLE_RESOLVE
=
1
<
<
5
;
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
bound
with
/
/
/
[
StorageTextureAccess
:
:
ReadOnly
]
.
const
STORAGE_READ_ONLY
=
1
<
<
6
;
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
bound
with
/
/
/
[
StorageTextureAccess
:
:
WriteOnly
]
.
const
STORAGE_WRITE_ONLY
=
1
<
<
7
;
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
bound
with
/
/
/
[
StorageTextureAccess
:
:
ReadWrite
]
.
const
STORAGE_READ_WRITE
=
1
<
<
8
;
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
bound
with
/
/
/
[
StorageTextureAccess
:
:
Atomic
]
.
const
STORAGE_ATOMIC
=
1
<
<
9
;
/
/
/
If
not
present
the
texture
can
'
t
be
blended
into
the
render
target
.
const
BLENDABLE
=
1
<
<
10
;
}
}
impl
TextureFormatFeatureFlags
{
#
[
must_use
]
pub
fn
sample_count_supported
(
&
self
count
:
u32
)
-
>
bool
{
use
TextureFormatFeatureFlags
as
tfsc
;
match
count
{
1
=
>
true
2
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X2
)
4
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X4
)
8
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X8
)
16
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X16
)
_
=
>
false
}
}
#
[
must_use
]
pub
fn
supported_sample_counts
(
&
self
)
-
>
Vec
<
u32
>
{
let
all_possible_sample_counts
:
[
u32
;
5
]
=
[
1
2
4
8
16
]
;
all_possible_sample_counts
.
into_iter
(
)
.
filter
(
|
&
sc
|
self
.
sample_count_supported
(
sc
)
)
.
collect
(
)
}
}
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
TextureFormatFeatures
{
pub
allowed_usages
:
TextureUsages
pub
flags
:
TextureFormatFeatureFlags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
AstcBlock
{
B4x4
B5x4
B5x5
B6x5
B6x6
B8x5
B8x6
B8x8
B10x5
B10x6
B10x8
B10x10
B12x10
B12x12
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
AstcChannel
{
Unorm
UnormSrgb
Hdr
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
pub
enum
TextureFormat
{
R8Unorm
R8Snorm
R8Uint
R8Sint
R16Uint
R16Sint
R16Unorm
R16Snorm
R16Float
Rg8Unorm
Rg8Snorm
Rg8Uint
Rg8Sint
R32Uint
R32Sint
R32Float
Rg16Uint
Rg16Sint
Rg16Unorm
Rg16Snorm
Rg16Float
Rgba8Unorm
Rgba8UnormSrgb
Rgba8Snorm
Rgba8Uint
Rgba8Sint
Bgra8Unorm
Bgra8UnormSrgb
Rgb9e5Ufloat
Rgb10a2Uint
Rgb10a2Unorm
Rg11b10Ufloat
R64Uint
Rg32Uint
Rg32Sint
Rg32Float
Rgba16Uint
Rgba16Sint
Rgba16Unorm
Rgba16Snorm
Rgba16Float
Rgba32Uint
Rgba32Sint
Rgba32Float
Stencil8
Depth16Unorm
Depth24Plus
Depth24PlusStencil8
Depth32Float
Depth32FloatStencil8
NV12
Bc1RgbaUnorm
Bc1RgbaUnormSrgb
Bc2RgbaUnorm
Bc2RgbaUnormSrgb
Bc3RgbaUnorm
Bc3RgbaUnormSrgb
Bc4RUnorm
Bc4RSnorm
Bc5RgUnorm
Bc5RgSnorm
Bc6hRgbUfloat
Bc6hRgbFloat
Bc7RgbaUnorm
Bc7RgbaUnormSrgb
Etc2Rgb8Unorm
Etc2Rgb8UnormSrgb
Etc2Rgb8A1Unorm
Etc2Rgb8A1UnormSrgb
Etc2Rgba8Unorm
Etc2Rgba8UnormSrgb
EacR11Unorm
EacR11Snorm
EacRg11Unorm
EacRg11Snorm
Astc
{
block
:
AstcBlock
channel
:
AstcChannel
}
}
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
impl
<
'
de
>
Deserialize
<
'
de
>
for
TextureFormat
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
self
Error
Unexpected
}
;
struct
TextureFormatVisitor
;
impl
de
:
:
Visitor
<
'
_
>
for
TextureFormatVisitor
{
type
Value
=
TextureFormat
;
fn
expecting
(
&
self
formatter
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
valid
texture
format
"
)
}
fn
visit_str
<
E
:
Error
>
(
self
s
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
{
let
format
=
match
s
{
"
r8unorm
"
=
>
TextureFormat
:
:
R8Unorm
"
r8snorm
"
=
>
TextureFormat
:
:
R8Snorm
"
r8uint
"
=
>
TextureFormat
:
:
R8Uint
"
r8sint
"
=
>
TextureFormat
:
:
R8Sint
"
r16uint
"
=
>
TextureFormat
:
:
R16Uint
"
r16sint
"
=
>
TextureFormat
:
:
R16Sint
"
r16unorm
"
=
>
TextureFormat
:
:
R16Unorm
"
r16snorm
"
=
>
TextureFormat
:
:
R16Snorm
"
r16float
"
=
>
TextureFormat
:
:
R16Float
"
rg8unorm
"
=
>
TextureFormat
:
:
Rg8Unorm
"
rg8snorm
"
=
>
TextureFormat
:
:
Rg8Snorm
"
rg8uint
"
=
>
TextureFormat
:
:
Rg8Uint
"
rg8sint
"
=
>
TextureFormat
:
:
Rg8Sint
"
r32uint
"
=
>
TextureFormat
:
:
R32Uint
"
r32sint
"
=
>
TextureFormat
:
:
R32Sint
"
r32float
"
=
>
TextureFormat
:
:
R32Float
"
rg16uint
"
=
>
TextureFormat
:
:
Rg16Uint
"
rg16sint
"
=
>
TextureFormat
:
:
Rg16Sint
"
rg16unorm
"
=
>
TextureFormat
:
:
Rg16Unorm
"
rg16snorm
"
=
>
TextureFormat
:
:
Rg16Snorm
"
rg16float
"
=
>
TextureFormat
:
:
Rg16Float
"
rgba8unorm
"
=
>
TextureFormat
:
:
Rgba8Unorm
"
rgba8unorm
-
srgb
"
=
>
TextureFormat
:
:
Rgba8UnormSrgb
"
rgba8snorm
"
=
>
TextureFormat
:
:
Rgba8Snorm
"
rgba8uint
"
=
>
TextureFormat
:
:
Rgba8Uint
"
rgba8sint
"
=
>
TextureFormat
:
:
Rgba8Sint
"
bgra8unorm
"
=
>
TextureFormat
:
:
Bgra8Unorm
"
bgra8unorm
-
srgb
"
=
>
TextureFormat
:
:
Bgra8UnormSrgb
"
rgb10a2uint
"
=
>
TextureFormat
:
:
Rgb10a2Uint
"
rgb10a2unorm
"
=
>
TextureFormat
:
:
Rgb10a2Unorm
"
rg11b10ufloat
"
=
>
TextureFormat
:
:
Rg11b10Ufloat
"
r64uint
"
=
>
TextureFormat
:
:
R64Uint
"
rg32uint
"
=
>
TextureFormat
:
:
Rg32Uint
"
rg32sint
"
=
>
TextureFormat
:
:
Rg32Sint
"
rg32float
"
=
>
TextureFormat
:
:
Rg32Float
"
rgba16uint
"
=
>
TextureFormat
:
:
Rgba16Uint
"
rgba16sint
"
=
>
TextureFormat
:
:
Rgba16Sint
"
rgba16unorm
"
=
>
TextureFormat
:
:
Rgba16Unorm
"
rgba16snorm
"
=
>
TextureFormat
:
:
Rgba16Snorm
"
rgba16float
"
=
>
TextureFormat
:
:
Rgba16Float
"
rgba32uint
"
=
>
TextureFormat
:
:
Rgba32Uint
"
rgba32sint
"
=
>
TextureFormat
:
:
Rgba32Sint
"
rgba32float
"
=
>
TextureFormat
:
:
Rgba32Float
"
stencil8
"
=
>
TextureFormat
:
:
Stencil8
"
depth32float
"
=
>
TextureFormat
:
:
Depth32Float
"
depth32float
-
stencil8
"
=
>
TextureFormat
:
:
Depth32FloatStencil8
"
depth16unorm
"
=
>
TextureFormat
:
:
Depth16Unorm
"
depth24plus
"
=
>
TextureFormat
:
:
Depth24Plus
"
depth24plus
-
stencil8
"
=
>
TextureFormat
:
:
Depth24PlusStencil8
"
nv12
"
=
>
TextureFormat
:
:
NV12
"
rgb9e5ufloat
"
=
>
TextureFormat
:
:
Rgb9e5Ufloat
"
bc1
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc1RgbaUnorm
"
bc1
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc1RgbaUnormSrgb
"
bc2
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc2RgbaUnorm
"
bc2
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc2RgbaUnormSrgb
"
bc3
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc3RgbaUnorm
"
bc3
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc3RgbaUnormSrgb
"
bc4
-
r
-
unorm
"
=
>
TextureFormat
:
:
Bc4RUnorm
"
bc4
-
r
-
snorm
"
=
>
TextureFormat
:
:
Bc4RSnorm
"
bc5
-
rg
-
unorm
"
=
>
TextureFormat
:
:
Bc5RgUnorm
"
bc5
-
rg
-
snorm
"
=
>
TextureFormat
:
:
Bc5RgSnorm
"
bc6h
-
rgb
-
ufloat
"
=
>
TextureFormat
:
:
Bc6hRgbUfloat
"
bc6h
-
rgb
-
float
"
=
>
TextureFormat
:
:
Bc6hRgbFloat
"
bc7
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc7RgbaUnorm
"
bc7
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc7RgbaUnormSrgb
"
etc2
-
rgb8unorm
"
=
>
TextureFormat
:
:
Etc2Rgb8Unorm
"
etc2
-
rgb8unorm
-
srgb
"
=
>
TextureFormat
:
:
Etc2Rgb8UnormSrgb
"
etc2
-
rgb8a1unorm
"
=
>
TextureFormat
:
:
Etc2Rgb8A1Unorm
"
etc2
-
rgb8a1unorm
-
srgb
"
=
>
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
"
etc2
-
rgba8unorm
"
=
>
TextureFormat
:
:
Etc2Rgba8Unorm
"
etc2
-
rgba8unorm
-
srgb
"
=
>
TextureFormat
:
:
Etc2Rgba8UnormSrgb
"
eac
-
r11unorm
"
=
>
TextureFormat
:
:
EacR11Unorm
"
eac
-
r11snorm
"
=
>
TextureFormat
:
:
EacR11Snorm
"
eac
-
rg11unorm
"
=
>
TextureFormat
:
:
EacRg11Unorm
"
eac
-
rg11snorm
"
=
>
TextureFormat
:
:
EacRg11Snorm
other
=
>
{
if
let
Some
(
parts
)
=
other
.
strip_prefix
(
"
astc
-
"
)
{
let
(
block
channel
)
=
parts
.
split_once
(
'
-
'
)
.
ok_or_else
(
|
|
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
?
;
let
block
=
match
block
{
"
4x4
"
=
>
AstcBlock
:
:
B4x4
"
5x4
"
=
>
AstcBlock
:
:
B5x4
"
5x5
"
=
>
AstcBlock
:
:
B5x5
"
6x5
"
=
>
AstcBlock
:
:
B6x5
"
6x6
"
=
>
AstcBlock
:
:
B6x6
"
8x5
"
=
>
AstcBlock
:
:
B8x5
"
8x6
"
=
>
AstcBlock
:
:
B8x6
"
8x8
"
=
>
AstcBlock
:
:
B8x8
"
10x5
"
=
>
AstcBlock
:
:
B10x5
"
10x6
"
=
>
AstcBlock
:
:
B10x6
"
10x8
"
=
>
AstcBlock
:
:
B10x8
"
10x10
"
=
>
AstcBlock
:
:
B10x10
"
12x10
"
=
>
AstcBlock
:
:
B12x10
"
12x12
"
=
>
AstcBlock
:
:
B12x12
_
=
>
return
Err
(
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
}
;
let
channel
=
match
channel
{
"
unorm
"
=
>
AstcChannel
:
:
Unorm
"
unorm
-
srgb
"
=
>
AstcChannel
:
:
UnormSrgb
"
hdr
"
=
>
AstcChannel
:
:
Hdr
_
=
>
return
Err
(
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
}
;
TextureFormat
:
:
Astc
{
block
channel
}
}
else
{
return
Err
(
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
;
}
}
}
;
Ok
(
format
)
}
}
deserializer
.
deserialize_str
(
TextureFormatVisitor
)
}
}
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
impl
Serialize
for
TextureFormat
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
let
s
:
String
;
let
name
=
match
*
self
{
TextureFormat
:
:
R8Unorm
=
>
"
r8unorm
"
TextureFormat
:
:
R8Snorm
=
>
"
r8snorm
"
TextureFormat
:
:
R8Uint
=
>
"
r8uint
"
TextureFormat
:
:
R8Sint
=
>
"
r8sint
"
TextureFormat
:
:
R16Uint
=
>
"
r16uint
"
TextureFormat
:
:
R16Sint
=
>
"
r16sint
"
TextureFormat
:
:
R16Unorm
=
>
"
r16unorm
"
TextureFormat
:
:
R16Snorm
=
>
"
r16snorm
"
TextureFormat
:
:
R16Float
=
>
"
r16float
"
TextureFormat
:
:
Rg8Unorm
=
>
"
rg8unorm
"
TextureFormat
:
:
Rg8Snorm
=
>
"
rg8snorm
"
TextureFormat
:
:
Rg8Uint
=
>
"
rg8uint
"
TextureFormat
:
:
Rg8Sint
=
>
"
rg8sint
"
TextureFormat
:
:
R32Uint
=
>
"
r32uint
"
TextureFormat
:
:
R32Sint
=
>
"
r32sint
"
TextureFormat
:
:
R32Float
=
>
"
r32float
"
TextureFormat
:
:
Rg16Uint
=
>
"
rg16uint
"
TextureFormat
:
:
Rg16Sint
=
>
"
rg16sint
"
TextureFormat
:
:
Rg16Unorm
=
>
"
rg16unorm
"
TextureFormat
:
:
Rg16Snorm
=
>
"
rg16snorm
"
TextureFormat
:
:
Rg16Float
=
>
"
rg16float
"
TextureFormat
:
:
Rgba8Unorm
=
>
"
rgba8unorm
"
TextureFormat
:
:
Rgba8UnormSrgb
=
>
"
rgba8unorm
-
srgb
"
TextureFormat
:
:
Rgba8Snorm
=
>
"
rgba8snorm
"
TextureFormat
:
:
Rgba8Uint
=
>
"
rgba8uint
"
TextureFormat
:
:
Rgba8Sint
=
>
"
rgba8sint
"
TextureFormat
:
:
Bgra8Unorm
=
>
"
bgra8unorm
"
TextureFormat
:
:
Bgra8UnormSrgb
=
>
"
bgra8unorm
-
srgb
"
TextureFormat
:
:
Rgb10a2Uint
=
>
"
rgb10a2uint
"
TextureFormat
:
:
Rgb10a2Unorm
=
>
"
rgb10a2unorm
"
TextureFormat
:
:
Rg11b10Ufloat
=
>
"
rg11b10ufloat
"
TextureFormat
:
:
R64Uint
=
>
"
r64uint
"
TextureFormat
:
:
Rg32Uint
=
>
"
rg32uint
"
TextureFormat
:
:
Rg32Sint
=
>
"
rg32sint
"
TextureFormat
:
:
Rg32Float
=
>
"
rg32float
"
TextureFormat
:
:
Rgba16Uint
=
>
"
rgba16uint
"
TextureFormat
:
:
Rgba16Sint
=
>
"
rgba16sint
"
TextureFormat
:
:
Rgba16Unorm
=
>
"
rgba16unorm
"
TextureFormat
:
:
Rgba16Snorm
=
>
"
rgba16snorm
"
TextureFormat
:
:
Rgba16Float
=
>
"
rgba16float
"
TextureFormat
:
:
Rgba32Uint
=
>
"
rgba32uint
"
TextureFormat
:
:
Rgba32Sint
=
>
"
rgba32sint
"
TextureFormat
:
:
Rgba32Float
=
>
"
rgba32float
"
TextureFormat
:
:
Stencil8
=
>
"
stencil8
"
TextureFormat
:
:
Depth32Float
=
>
"
depth32float
"
TextureFormat
:
:
Depth16Unorm
=
>
"
depth16unorm
"
TextureFormat
:
:
Depth32FloatStencil8
=
>
"
depth32float
-
stencil8
"
TextureFormat
:
:
Depth24Plus
=
>
"
depth24plus
"
TextureFormat
:
:
Depth24PlusStencil8
=
>
"
depth24plus
-
stencil8
"
TextureFormat
:
:
NV12
=
>
"
nv12
"
TextureFormat
:
:
Rgb9e5Ufloat
=
>
"
rgb9e5ufloat
"
TextureFormat
:
:
Bc1RgbaUnorm
=
>
"
bc1
-
rgba
-
unorm
"
TextureFormat
:
:
Bc1RgbaUnormSrgb
=
>
"
bc1
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Bc2RgbaUnorm
=
>
"
bc2
-
rgba
-
unorm
"
TextureFormat
:
:
Bc2RgbaUnormSrgb
=
>
"
bc2
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Bc3RgbaUnorm
=
>
"
bc3
-
rgba
-
unorm
"
TextureFormat
:
:
Bc3RgbaUnormSrgb
=
>
"
bc3
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Bc4RUnorm
=
>
"
bc4
-
r
-
unorm
"
TextureFormat
:
:
Bc4RSnorm
=
>
"
bc4
-
r
-
snorm
"
TextureFormat
:
:
Bc5RgUnorm
=
>
"
bc5
-
rg
-
unorm
"
TextureFormat
:
:
Bc5RgSnorm
=
>
"
bc5
-
rg
-
snorm
"
TextureFormat
:
:
Bc6hRgbUfloat
=
>
"
bc6h
-
rgb
-
ufloat
"
TextureFormat
:
:
Bc6hRgbFloat
=
>
"
bc6h
-
rgb
-
float
"
TextureFormat
:
:
Bc7RgbaUnorm
=
>
"
bc7
-
rgba
-
unorm
"
TextureFormat
:
:
Bc7RgbaUnormSrgb
=
>
"
bc7
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Etc2Rgb8Unorm
=
>
"
etc2
-
rgb8unorm
"
TextureFormat
:
:
Etc2Rgb8UnormSrgb
=
>
"
etc2
-
rgb8unorm
-
srgb
"
TextureFormat
:
:
Etc2Rgb8A1Unorm
=
>
"
etc2
-
rgb8a1unorm
"
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
=
>
"
etc2
-
rgb8a1unorm
-
srgb
"
TextureFormat
:
:
Etc2Rgba8Unorm
=
>
"
etc2
-
rgba8unorm
"
TextureFormat
:
:
Etc2Rgba8UnormSrgb
=
>
"
etc2
-
rgba8unorm
-
srgb
"
TextureFormat
:
:
EacR11Unorm
=
>
"
eac
-
r11unorm
"
TextureFormat
:
:
EacR11Snorm
=
>
"
eac
-
r11snorm
"
TextureFormat
:
:
EacRg11Unorm
=
>
"
eac
-
rg11unorm
"
TextureFormat
:
:
EacRg11Snorm
=
>
"
eac
-
rg11snorm
"
TextureFormat
:
:
Astc
{
block
channel
}
=
>
{
let
block
=
match
block
{
AstcBlock
:
:
B4x4
=
>
"
4x4
"
AstcBlock
:
:
B5x4
=
>
"
5x4
"
AstcBlock
:
:
B5x5
=
>
"
5x5
"
AstcBlock
:
:
B6x5
=
>
"
6x5
"
AstcBlock
:
:
B6x6
=
>
"
6x6
"
AstcBlock
:
:
B8x5
=
>
"
8x5
"
AstcBlock
:
:
B8x6
=
>
"
8x6
"
AstcBlock
:
:
B8x8
=
>
"
8x8
"
AstcBlock
:
:
B10x5
=
>
"
10x5
"
AstcBlock
:
:
B10x6
=
>
"
10x6
"
AstcBlock
:
:
B10x8
=
>
"
10x8
"
AstcBlock
:
:
B10x10
=
>
"
10x10
"
AstcBlock
:
:
B12x10
=
>
"
12x10
"
AstcBlock
:
:
B12x12
=
>
"
12x12
"
}
;
let
channel
=
match
channel
{
AstcChannel
:
:
Unorm
=
>
"
unorm
"
AstcChannel
:
:
UnormSrgb
=
>
"
unorm
-
srgb
"
AstcChannel
:
:
Hdr
=
>
"
hdr
"
}
;
s
=
format
!
(
"
astc
-
{
block
}
-
{
channel
}
"
)
;
&
s
}
}
;
serializer
.
serialize_str
(
name
)
}
}
impl
TextureAspect
{
#
[
must_use
]
pub
fn
from_plane
(
plane
:
u32
)
-
>
Option
<
Self
>
{
Some
(
match
plane
{
0
=
>
Self
:
:
Plane0
1
=
>
Self
:
:
Plane1
2
=
>
Self
:
:
Plane2
_
=
>
return
None
}
)
}
}
impl
TextureFormat
{
#
[
must_use
]
pub
fn
aspect_specific_format
(
&
self
aspect
:
TextureAspect
)
-
>
Option
<
Self
>
{
match
(
*
self
aspect
)
{
(
Self
:
:
Stencil8
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
*
self
)
(
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth32Float
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
*
self
)
(
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
Self
:
:
Stencil8
)
(
Self
:
:
Depth24PlusStencil8
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
Self
:
:
Depth24Plus
)
(
Self
:
:
Depth32FloatStencil8
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
Self
:
:
Depth32Float
)
(
Self
:
:
NV12
TextureAspect
:
:
Plane0
)
=
>
Some
(
Self
:
:
R8Unorm
)
(
Self
:
:
NV12
TextureAspect
:
:
Plane1
)
=
>
Some
(
Self
:
:
Rg8Unorm
)
(
format
TextureAspect
:
:
All
)
if
!
format
.
is_multi_planar_format
(
)
=
>
Some
(
format
)
_
=
>
None
}
}
#
[
must_use
]
pub
fn
is_depth_stencil_component
(
&
self
combined_format
:
Self
)
-
>
bool
{
match
(
combined_format
*
self
)
{
(
Self
:
:
Depth24PlusStencil8
Self
:
:
Depth24Plus
|
Self
:
:
Stencil8
)
|
(
Self
:
:
Depth32FloatStencil8
Self
:
:
Depth32Float
|
Self
:
:
Stencil8
)
=
>
true
_
=
>
false
}
}
#
[
must_use
]
pub
fn
is_depth_stencil_format
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
#
[
must_use
]
pub
fn
is_combined_depth_stencil_format
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
#
[
must_use
]
pub
fn
is_multi_planar_format
(
&
self
)
-
>
bool
{
self
.
planes
(
)
.
is_some
(
)
}
#
[
must_use
]
pub
fn
planes
(
&
self
)
-
>
Option
<
u32
>
{
match
*
self
{
Self
:
:
NV12
=
>
Some
(
2
)
_
=
>
None
}
}
#
[
must_use
]
pub
fn
has_color_aspect
(
&
self
)
-
>
bool
{
!
self
.
is_depth_stencil_format
(
)
}
#
[
must_use
]
pub
fn
has_depth_aspect
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
#
[
must_use
]
pub
fn
has_stencil_aspect
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Stencil8
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
#
[
must_use
]
pub
fn
size_multiple_requirement
(
&
self
)
-
>
(
u32
u32
)
{
match
*
self
{
Self
:
:
NV12
=
>
(
2
2
)
_
=
>
self
.
block_dimensions
(
)
}
}
#
[
must_use
]
pub
fn
block_dimensions
(
&
self
)
-
>
(
u32
u32
)
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Float
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rgb10a2Uint
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Ufloat
|
Self
:
:
R64Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
|
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
|
Self
:
:
NV12
=
>
(
1
1
)
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
(
4
4
)
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
(
4
4
)
Self
:
:
Astc
{
block
.
.
}
=
>
match
block
{
AstcBlock
:
:
B4x4
=
>
(
4
4
)
AstcBlock
:
:
B5x4
=
>
(
5
4
)
AstcBlock
:
:
B5x5
=
>
(
5
5
)
AstcBlock
:
:
B6x5
=
>
(
6
5
)
AstcBlock
:
:
B6x6
=
>
(
6
6
)
AstcBlock
:
:
B8x5
=
>
(
8
5
)
AstcBlock
:
:
B8x6
=
>
(
8
6
)
AstcBlock
:
:
B8x8
=
>
(
8
8
)
AstcBlock
:
:
B10x5
=
>
(
10
5
)
AstcBlock
:
:
B10x6
=
>
(
10
6
)
AstcBlock
:
:
B10x8
=
>
(
10
8
)
AstcBlock
:
:
B10x10
=
>
(
10
10
)
AstcBlock
:
:
B12x10
=
>
(
12
10
)
AstcBlock
:
:
B12x12
=
>
(
12
12
)
}
}
}
#
[
must_use
]
pub
fn
is_compressed
(
&
self
)
-
>
bool
{
self
.
block_dimensions
(
)
!
=
(
1
1
)
}
#
[
must_use
]
pub
fn
is_bcn
(
&
self
)
-
>
bool
{
self
.
required_features
(
)
=
=
Features
:
:
TEXTURE_COMPRESSION_BC
}
#
[
must_use
]
pub
fn
is_astc
(
&
self
)
-
>
bool
{
self
.
required_features
(
)
=
=
Features
:
:
TEXTURE_COMPRESSION_ASTC
|
|
self
.
required_features
(
)
=
=
Features
:
:
TEXTURE_COMPRESSION_ASTC_HDR
}
#
[
must_use
]
pub
fn
required_features
(
&
self
)
-
>
Features
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Float
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rgb10a2Uint
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Ufloat
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
|
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
=
>
Features
:
:
empty
(
)
Self
:
:
R64Uint
=
>
Features
:
:
TEXTURE_INT64_ATOMIC
Self
:
:
Depth32FloatStencil8
=
>
Features
:
:
DEPTH32FLOAT_STENCIL8
Self
:
:
NV12
=
>
Features
:
:
TEXTURE_FORMAT_NV12
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
=
>
Features
:
:
TEXTURE_FORMAT_16BIT_NORM
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
Features
:
:
TEXTURE_COMPRESSION_BC
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
Features
:
:
TEXTURE_COMPRESSION_ETC2
Self
:
:
Astc
{
channel
.
.
}
=
>
match
channel
{
AstcChannel
:
:
Hdr
=
>
Features
:
:
TEXTURE_COMPRESSION_ASTC_HDR
AstcChannel
:
:
Unorm
|
AstcChannel
:
:
UnormSrgb
=
>
Features
:
:
TEXTURE_COMPRESSION_ASTC
}
}
}
#
[
must_use
]
pub
fn
guaranteed_format_features
(
&
self
device_features
:
Features
)
-
>
TextureFormatFeatures
{
let
none
=
TextureFormatFeatureFlags
:
:
empty
(
)
;
let
msaa
=
TextureFormatFeatureFlags
:
:
MULTISAMPLE_X4
;
let
msaa_resolve
=
msaa
|
TextureFormatFeatureFlags
:
:
MULTISAMPLE_RESOLVE
;
let
s_ro_wo
=
TextureFormatFeatureFlags
:
:
STORAGE_READ_ONLY
|
TextureFormatFeatureFlags
:
:
STORAGE_WRITE_ONLY
;
let
s_all
=
s_ro_wo
|
TextureFormatFeatureFlags
:
:
STORAGE_READ_WRITE
;
let
basic
=
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
;
let
attachment
=
basic
|
TextureUsages
:
:
RENDER_ATTACHMENT
;
let
storage
=
basic
|
TextureUsages
:
:
STORAGE_BINDING
;
let
binding
=
TextureUsages
:
:
TEXTURE_BINDING
;
let
all_flags
=
attachment
|
storage
|
binding
;
let
atomic_64
=
if
device_features
.
contains
(
Features
:
:
TEXTURE_ATOMIC
)
{
storage
|
binding
|
TextureUsages
:
:
STORAGE_ATOMIC
}
else
{
storage
|
binding
}
;
let
atomic
=
attachment
|
atomic_64
;
let
(
rg11b10f_f
rg11b10f_u
)
=
if
device_features
.
contains
(
Features
:
:
RG11B10UFLOAT_RENDERABLE
)
{
(
msaa_resolve
attachment
)
}
else
{
(
msaa
basic
)
}
;
let
(
bgra8unorm_f
bgra8unorm
)
=
if
device_features
.
contains
(
Features
:
:
BGRA8UNORM_STORAGE
)
{
(
msaa_resolve
|
TextureFormatFeatureFlags
:
:
STORAGE_WRITE_ONLY
attachment
|
TextureUsages
:
:
STORAGE_BINDING
)
}
else
{
(
msaa_resolve
attachment
)
}
;
#
[
rustfmt
:
:
skip
]
let
(
mut
flags
allowed_usages
)
=
match
*
self
{
Self
:
:
R8Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
R8Snorm
=
>
(
none
basic
)
Self
:
:
R8Uint
=
>
(
msaa
attachment
)
Self
:
:
R8Sint
=
>
(
msaa
attachment
)
Self
:
:
R16Uint
=
>
(
msaa
attachment
)
Self
:
:
R16Sint
=
>
(
msaa
attachment
)
Self
:
:
R16Float
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rg8Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rg8Snorm
=
>
(
none
basic
)
Self
:
:
Rg8Uint
=
>
(
msaa
attachment
)
Self
:
:
Rg8Sint
=
>
(
msaa
attachment
)
Self
:
:
R32Uint
=
>
(
s_all
atomic
)
Self
:
:
R32Sint
=
>
(
s_all
atomic
)
Self
:
:
R32Float
=
>
(
msaa
|
s_all
all_flags
)
Self
:
:
Rg16Uint
=
>
(
msaa
attachment
)
Self
:
:
Rg16Sint
=
>
(
msaa
attachment
)
Self
:
:
Rg16Float
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rgba8Unorm
=
>
(
msaa_resolve
|
s_ro_wo
all_flags
)
Self
:
:
Rgba8UnormSrgb
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rgba8Snorm
=
>
(
s_ro_wo
storage
)
Self
:
:
Rgba8Uint
=
>
(
msaa
|
s_ro_wo
all_flags
)
Self
:
:
Rgba8Sint
=
>
(
msaa
|
s_ro_wo
all_flags
)
Self
:
:
Bgra8Unorm
=
>
(
bgra8unorm_f
bgra8unorm
)
Self
:
:
Bgra8UnormSrgb
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rgb10a2Uint
=
>
(
msaa
attachment
)
Self
:
:
Rgb10a2Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rg11b10Ufloat
=
>
(
rg11b10f_f
rg11b10f_u
)
Self
:
:
R64Uint
=
>
(
s_ro_wo
atomic_64
)
Self
:
:
Rg32Uint
=
>
(
s_ro_wo
all_flags
)
Self
:
:
Rg32Sint
=
>
(
s_ro_wo
all_flags
)
Self
:
:
Rg32Float
=
>
(
s_ro_wo
all_flags
)
Self
:
:
Rgba16Uint
=
>
(
msaa
|
s_ro_wo
all_flags
)
Self
:
:
Rgba16Sint
=
>
(
msaa
|
s_ro_wo
all_flags
)
Self
:
:
Rgba16Float
=
>
(
msaa_resolve
|
s_ro_wo
all_flags
)
Self
:
:
Rgba32Uint
=
>
(
s_ro_wo
all_flags
)
Self
:
:
Rgba32Sint
=
>
(
s_ro_wo
all_flags
)
Self
:
:
Rgba32Float
=
>
(
s_ro_wo
all_flags
)
Self
:
:
Stencil8
=
>
(
msaa
attachment
)
Self
:
:
Depth16Unorm
=
>
(
msaa
attachment
)
Self
:
:
Depth24Plus
=
>
(
msaa
attachment
)
Self
:
:
Depth24PlusStencil8
=
>
(
msaa
attachment
)
Self
:
:
Depth32Float
=
>
(
msaa
attachment
)
Self
:
:
Depth32FloatStencil8
=
>
(
msaa
attachment
)
Self
:
:
NV12
=
>
(
none
binding
)
Self
:
:
R16Unorm
=
>
(
msaa
|
s_ro_wo
storage
)
Self
:
:
R16Snorm
=
>
(
msaa
|
s_ro_wo
storage
)
Self
:
:
Rg16Unorm
=
>
(
msaa
|
s_ro_wo
storage
)
Self
:
:
Rg16Snorm
=
>
(
msaa
|
s_ro_wo
storage
)
Self
:
:
Rgba16Unorm
=
>
(
msaa
|
s_ro_wo
storage
)
Self
:
:
Rgba16Snorm
=
>
(
msaa
|
s_ro_wo
storage
)
Self
:
:
Rgb9e5Ufloat
=
>
(
none
basic
)
Self
:
:
Bc1RgbaUnorm
=
>
(
none
basic
)
Self
:
:
Bc1RgbaUnormSrgb
=
>
(
none
basic
)
Self
:
:
Bc2RgbaUnorm
=
>
(
none
basic
)
Self
:
:
Bc2RgbaUnormSrgb
=
>
(
none
basic
)
Self
:
:
Bc3RgbaUnorm
=
>
(
none
basic
)
Self
:
:
Bc3RgbaUnormSrgb
=
>
(
none
basic
)
Self
:
:
Bc4RUnorm
=
>
(
none
basic
)
Self
:
:
Bc4RSnorm
=
>
(
none
basic
)
Self
:
:
Bc5RgUnorm
=
>
(
none
basic
)
Self
:
:
Bc5RgSnorm
=
>
(
none
basic
)
Self
:
:
Bc6hRgbUfloat
=
>
(
none
basic
)
Self
:
:
Bc6hRgbFloat
=
>
(
none
basic
)
Self
:
:
Bc7RgbaUnorm
=
>
(
none
basic
)
Self
:
:
Bc7RgbaUnormSrgb
=
>
(
none
basic
)
Self
:
:
Etc2Rgb8Unorm
=
>
(
none
basic
)
Self
:
:
Etc2Rgb8UnormSrgb
=
>
(
none
basic
)
Self
:
:
Etc2Rgb8A1Unorm
=
>
(
none
basic
)
Self
:
:
Etc2Rgb8A1UnormSrgb
=
>
(
none
basic
)
Self
:
:
Etc2Rgba8Unorm
=
>
(
none
basic
)
Self
:
:
Etc2Rgba8UnormSrgb
=
>
(
none
basic
)
Self
:
:
EacR11Unorm
=
>
(
none
basic
)
Self
:
:
EacR11Snorm
=
>
(
none
basic
)
Self
:
:
EacRg11Unorm
=
>
(
none
basic
)
Self
:
:
EacRg11Snorm
=
>
(
none
basic
)
Self
:
:
Astc
{
.
.
}
=
>
(
none
basic
)
}
;
let
sample_type1
=
self
.
sample_type
(
None
Some
(
device_features
)
)
;
let
is_filterable
=
sample_type1
=
=
Some
(
TextureSampleType
:
:
Float
{
filterable
:
true
}
)
;
let
sample_type2
=
self
.
sample_type
(
None
None
)
;
let
is_blendable
=
sample_type2
=
=
Some
(
TextureSampleType
:
:
Float
{
filterable
:
true
}
)
;
flags
.
set
(
TextureFormatFeatureFlags
:
:
FILTERABLE
is_filterable
)
;
flags
.
set
(
TextureFormatFeatureFlags
:
:
BLENDABLE
is_blendable
)
;
flags
.
set
(
TextureFormatFeatureFlags
:
:
STORAGE_ATOMIC
allowed_usages
.
contains
(
TextureUsages
:
:
STORAGE_ATOMIC
)
)
;
TextureFormatFeatures
{
allowed_usages
flags
}
}
#
[
must_use
]
pub
fn
sample_type
(
&
self
aspect
:
Option
<
TextureAspect
>
device_features
:
Option
<
Features
>
)
-
>
Option
<
TextureSampleType
>
{
let
float
=
TextureSampleType
:
:
Float
{
filterable
:
true
}
;
let
unfilterable_float
=
TextureSampleType
:
:
Float
{
filterable
:
false
}
;
let
float32_sample_type
=
TextureSampleType
:
:
Float
{
filterable
:
device_features
.
unwrap_or
(
Features
:
:
empty
(
)
)
.
contains
(
Features
:
:
FLOAT32_FILTERABLE
)
}
;
let
depth
=
TextureSampleType
:
:
Depth
;
let
uint
=
TextureSampleType
:
:
Uint
;
let
sint
=
TextureSampleType
:
:
Sint
;
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
R16Float
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Ufloat
=
>
Some
(
float
)
Self
:
:
R32Float
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba32Float
=
>
Some
(
float32_sample_type
)
Self
:
:
R8Uint
|
Self
:
:
Rg8Uint
|
Self
:
:
Rgba8Uint
|
Self
:
:
R16Uint
|
Self
:
:
Rg16Uint
|
Self
:
:
Rgba16Uint
|
Self
:
:
R32Uint
|
Self
:
:
R64Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgb10a2Uint
=
>
Some
(
uint
)
Self
:
:
R8Sint
|
Self
:
:
Rg8Sint
|
Self
:
:
Rgba8Sint
|
Self
:
:
R16Sint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rgba16Sint
|
Self
:
:
R32Sint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rgba32Sint
=
>
Some
(
sint
)
Self
:
:
Stencil8
=
>
Some
(
uint
)
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth32Float
=
>
Some
(
depth
)
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
match
aspect
{
Some
(
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
depth
)
Some
(
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
uint
)
_
=
>
None
}
Self
:
:
NV12
=
>
match
aspect
{
Some
(
TextureAspect
:
:
Plane0
)
|
Some
(
TextureAspect
:
:
Plane1
)
=
>
{
Some
(
unfilterable_float
)
}
_
=
>
None
}
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
=
>
Some
(
float
)
Self
:
:
Rgb9e5Ufloat
=
>
Some
(
float
)
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
Some
(
float
)
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
Some
(
float
)
Self
:
:
Astc
{
.
.
}
=
>
Some
(
float
)
}
}
#
[
deprecated
(
since
=
"
0
.
19
.
0
"
note
=
"
Use
block_copy_size
instead
.
"
)
]
#
[
must_use
]
pub
fn
block_size
(
&
self
aspect
:
Option
<
TextureAspect
>
)
-
>
Option
<
u32
>
{
self
.
block_copy_size
(
aspect
)
}
#
[
must_use
]
pub
fn
block_copy_size
(
&
self
aspect
:
Option
<
TextureAspect
>
)
-
>
Option
<
u32
>
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
=
>
Some
(
1
)
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
=
>
Some
(
2
)
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Float
=
>
{
Some
(
2
)
}
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
=
>
Some
(
4
)
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Float
=
>
Some
(
4
)
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
=
>
Some
(
4
)
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rgb10a2Uint
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Ufloat
=
>
{
Some
(
4
)
}
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Float
=
>
Some
(
8
)
Self
:
:
R64Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
=
>
Some
(
8
)
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
=
>
Some
(
16
)
Self
:
:
Stencil8
=
>
Some
(
1
)
Self
:
:
Depth16Unorm
=
>
Some
(
2
)
Self
:
:
Depth32Float
=
>
Some
(
4
)
Self
:
:
Depth24Plus
=
>
None
Self
:
:
Depth24PlusStencil8
=
>
match
aspect
{
Some
(
TextureAspect
:
:
DepthOnly
)
=
>
None
Some
(
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
1
)
_
=
>
None
}
Self
:
:
Depth32FloatStencil8
=
>
match
aspect
{
Some
(
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
4
)
Some
(
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
1
)
_
=
>
None
}
Self
:
:
NV12
=
>
match
aspect
{
Some
(
TextureAspect
:
:
Plane0
)
=
>
Some
(
1
)
Some
(
TextureAspect
:
:
Plane1
)
=
>
Some
(
2
)
_
=
>
None
}
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
=
>
{
Some
(
8
)
}
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
Some
(
16
)
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
=
>
Some
(
8
)
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
Some
(
16
)
Self
:
:
Astc
{
.
.
}
=
>
Some
(
16
)
}
}
pub
const
MAX_TARGET_PIXEL_BYTE_COST
:
u32
=
16
;
#
[
must_use
]
pub
fn
target_pixel_byte_cost
(
&
self
)
-
>
Option
<
u32
>
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
=
>
Some
(
1
)
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Float
=
>
Some
(
2
)
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Float
|
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
=
>
Some
(
4
)
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Float
|
Self
:
:
R64Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
|
Self
:
:
Rgb10a2Uint
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Ufloat
=
>
Some
(
8
)
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
=
>
Some
(
16
)
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
|
Self
:
:
NV12
|
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
|
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
|
Self
:
:
Astc
{
.
.
}
=
>
None
}
}
#
[
must_use
]
pub
fn
target_component_alignment
(
&
self
)
-
>
Option
<
u32
>
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
=
>
Some
(
1
)
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Float
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Float
=
>
Some
(
2
)
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
|
Self
:
:
R64Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
|
Self
:
:
Rgb10a2Uint
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Ufloat
=
>
Some
(
4
)
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
|
Self
:
:
NV12
|
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
|
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
|
Self
:
:
Astc
{
.
.
}
=
>
None
}
}
#
[
must_use
]
pub
fn
components
(
&
self
)
-
>
u8
{
self
.
components_with_aspect
(
TextureAspect
:
:
All
)
}
#
[
must_use
]
pub
fn
components_with_aspect
(
&
self
aspect
:
TextureAspect
)
-
>
u8
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
|
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Float
|
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
|
Self
:
:
R64Uint
=
>
1
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Float
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
=
>
2
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
=
>
4
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rg11b10Ufloat
=
>
3
Self
:
:
Rgb10a2Uint
|
Self
:
:
Rgb10a2Unorm
=
>
4
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth32Float
=
>
1
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
match
aspect
{
TextureAspect
:
:
DepthOnly
|
TextureAspect
:
:
StencilOnly
=
>
1
_
=
>
2
}
Self
:
:
NV12
=
>
match
aspect
{
TextureAspect
:
:
Plane0
=
>
1
TextureAspect
:
:
Plane1
=
>
2
_
=
>
3
}
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
=
>
1
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
=
>
2
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
=
>
3
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
4
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
=
>
1
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
2
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
=
>
3
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
=
>
4
Self
:
:
Astc
{
.
.
}
=
>
4
}
}
#
[
must_use
]
pub
fn
remove_srgb_suffix
(
&
self
)
-
>
TextureFormat
{
match
*
self
{
Self
:
:
Rgba8UnormSrgb
=
>
Self
:
:
Rgba8Unorm
Self
:
:
Bgra8UnormSrgb
=
>
Self
:
:
Bgra8Unorm
Self
:
:
Bc1RgbaUnormSrgb
=
>
Self
:
:
Bc1RgbaUnorm
Self
:
:
Bc2RgbaUnormSrgb
=
>
Self
:
:
Bc2RgbaUnorm
Self
:
:
Bc3RgbaUnormSrgb
=
>
Self
:
:
Bc3RgbaUnorm
Self
:
:
Bc7RgbaUnormSrgb
=
>
Self
:
:
Bc7RgbaUnorm
Self
:
:
Etc2Rgb8UnormSrgb
=
>
Self
:
:
Etc2Rgb8Unorm
Self
:
:
Etc2Rgb8A1UnormSrgb
=
>
Self
:
:
Etc2Rgb8A1Unorm
Self
:
:
Etc2Rgba8UnormSrgb
=
>
Self
:
:
Etc2Rgba8Unorm
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
UnormSrgb
}
=
>
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
Unorm
}
_
=
>
*
self
}
}
#
[
must_use
]
pub
fn
add_srgb_suffix
(
&
self
)
-
>
TextureFormat
{
match
*
self
{
Self
:
:
Rgba8Unorm
=
>
Self
:
:
Rgba8UnormSrgb
Self
:
:
Bgra8Unorm
=
>
Self
:
:
Bgra8UnormSrgb
Self
:
:
Bc1RgbaUnorm
=
>
Self
:
:
Bc1RgbaUnormSrgb
Self
:
:
Bc2RgbaUnorm
=
>
Self
:
:
Bc2RgbaUnormSrgb
Self
:
:
Bc3RgbaUnorm
=
>
Self
:
:
Bc3RgbaUnormSrgb
Self
:
:
Bc7RgbaUnorm
=
>
Self
:
:
Bc7RgbaUnormSrgb
Self
:
:
Etc2Rgb8Unorm
=
>
Self
:
:
Etc2Rgb8UnormSrgb
Self
:
:
Etc2Rgb8A1Unorm
=
>
Self
:
:
Etc2Rgb8A1UnormSrgb
Self
:
:
Etc2Rgba8Unorm
=
>
Self
:
:
Etc2Rgba8UnormSrgb
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
Unorm
}
=
>
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
UnormSrgb
}
_
=
>
*
self
}
}
#
[
must_use
]
pub
fn
is_srgb
(
&
self
)
-
>
bool
{
*
self
!
=
self
.
remove_srgb_suffix
(
)
}
#
[
must_use
]
pub
fn
theoretical_memory_footprint
(
&
self
size
:
Extent3d
)
-
>
u64
{
let
(
block_width
block_height
)
=
self
.
block_dimensions
(
)
;
let
block_size
=
self
.
block_copy_size
(
None
)
;
let
approximate_block_size
=
match
block_size
{
Some
(
size
)
=
>
size
None
=
>
match
self
{
Self
:
:
Depth16Unorm
=
>
2
Self
:
:
Depth24Plus
=
>
4
Self
:
:
Depth24PlusStencil8
=
>
4
Self
:
:
Depth32Float
=
>
4
Self
:
:
Depth32FloatStencil8
=
>
8
Self
:
:
Stencil8
=
>
1
Self
:
:
NV12
=
>
3
f
=
>
{
log
:
:
warn
!
(
"
Memory
footprint
for
format
{
f
:
?
}
is
not
implemented
"
)
;
0
}
}
}
;
let
width_blocks
=
size
.
width
.
div_ceil
(
block_width
)
as
u64
;
let
height_blocks
=
size
.
height
.
div_ceil
(
block_height
)
as
u64
;
let
total_blocks
=
width_blocks
*
height_blocks
*
size
.
depth_or_array_layers
as
u64
;
total_blocks
*
approximate_block_size
as
u64
}
}
#
[
test
]
fn
texture_format_serialize
(
)
{
use
alloc
:
:
string
:
:
ToString
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Unorm
)
.
unwrap
(
)
"
\
"
r8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Snorm
)
.
unwrap
(
)
"
\
"
r8snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Uint
)
.
unwrap
(
)
"
\
"
r8uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Sint
)
.
unwrap
(
)
"
\
"
r8sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Uint
)
.
unwrap
(
)
"
\
"
r16uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Sint
)
.
unwrap
(
)
"
\
"
r16sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Unorm
)
.
unwrap
(
)
"
\
"
r16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Snorm
)
.
unwrap
(
)
"
\
"
r16snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Float
)
.
unwrap
(
)
"
\
"
r16float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Unorm
)
.
unwrap
(
)
"
\
"
rg8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Snorm
)
.
unwrap
(
)
"
\
"
rg8snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Uint
)
.
unwrap
(
)
"
\
"
rg8uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Sint
)
.
unwrap
(
)
"
\
"
rg8sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R32Uint
)
.
unwrap
(
)
"
\
"
r32uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R32Sint
)
.
unwrap
(
)
"
\
"
r32sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R32Float
)
.
unwrap
(
)
"
\
"
r32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Uint
)
.
unwrap
(
)
"
\
"
rg16uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Sint
)
.
unwrap
(
)
"
\
"
rg16sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Unorm
)
.
unwrap
(
)
"
\
"
rg16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Snorm
)
.
unwrap
(
)
"
\
"
rg16snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Float
)
.
unwrap
(
)
"
\
"
rg16float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Unorm
)
.
unwrap
(
)
"
\
"
rgba8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8UnormSrgb
)
.
unwrap
(
)
"
\
"
rgba8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Snorm
)
.
unwrap
(
)
"
\
"
rgba8snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Uint
)
.
unwrap
(
)
"
\
"
rgba8uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Sint
)
.
unwrap
(
)
"
\
"
rgba8sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bgra8Unorm
)
.
unwrap
(
)
"
\
"
bgra8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bgra8UnormSrgb
)
.
unwrap
(
)
"
\
"
bgra8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgb10a2Uint
)
.
unwrap
(
)
"
\
"
rgb10a2uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgb10a2Unorm
)
.
unwrap
(
)
"
\
"
rgb10a2unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg11b10Ufloat
)
.
unwrap
(
)
"
\
"
rg11b10ufloat
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R64Uint
)
.
unwrap
(
)
"
\
"
r64uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg32Uint
)
.
unwrap
(
)
"
\
"
rg32uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg32Sint
)
.
unwrap
(
)
"
\
"
rg32sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg32Float
)
.
unwrap
(
)
"
\
"
rg32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Uint
)
.
unwrap
(
)
"
\
"
rgba16uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Sint
)
.
unwrap
(
)
"
\
"
rgba16sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Unorm
)
.
unwrap
(
)
"
\
"
rgba16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Snorm
)
.
unwrap
(
)
"
\
"
rgba16snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Float
)
.
unwrap
(
)
"
\
"
rgba16float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba32Uint
)
.
unwrap
(
)
"
\
"
rgba32uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba32Sint
)
.
unwrap
(
)
"
\
"
rgba32sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba32Float
)
.
unwrap
(
)
"
\
"
rgba32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Stencil8
)
.
unwrap
(
)
"
\
"
stencil8
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth32Float
)
.
unwrap
(
)
"
\
"
depth32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth16Unorm
)
.
unwrap
(
)
"
\
"
depth16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth32FloatStencil8
)
.
unwrap
(
)
"
\
"
depth32float
-
stencil8
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth24Plus
)
.
unwrap
(
)
"
\
"
depth24plus
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth24PlusStencil8
)
.
unwrap
(
)
"
\
"
depth24plus
-
stencil8
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgb9e5Ufloat
)
.
unwrap
(
)
"
\
"
rgb9e5ufloat
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc1RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc1
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc1RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc1
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc2RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc2
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc2RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc2
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc3RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc3
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc3RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc3
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc4RUnorm
)
.
unwrap
(
)
"
\
"
bc4
-
r
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc4RSnorm
)
.
unwrap
(
)
"
\
"
bc4
-
r
-
snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc5RgUnorm
)
.
unwrap
(
)
"
\
"
bc5
-
rg
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc5RgSnorm
)
.
unwrap
(
)
"
\
"
bc5
-
rg
-
snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc6hRgbUfloat
)
.
unwrap
(
)
"
\
"
bc6h
-
rgb
-
ufloat
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc6hRgbFloat
)
.
unwrap
(
)
"
\
"
bc6h
-
rgb
-
float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc7RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc7
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc7RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc7
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8Unorm
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8UnormSrgb
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8A1Unorm
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8a1unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8a1unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgba8Unorm
)
.
unwrap
(
)
"
\
"
etc2
-
rgba8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgba8UnormSrgb
)
.
unwrap
(
)
"
\
"
etc2
-
rgba8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacR11Unorm
)
.
unwrap
(
)
"
\
"
eac
-
r11unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacR11Snorm
)
.
unwrap
(
)
"
\
"
eac
-
r11snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacRg11Unorm
)
.
unwrap
(
)
"
\
"
eac
-
rg11unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacRg11Snorm
)
.
unwrap
(
)
"
\
"
eac
-
rg11snorm
\
"
"
.
to_string
(
)
)
;
}
#
[
test
]
fn
texture_format_deserialize
(
)
{
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r32uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R32Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r32sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R32Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bgra8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bgra8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bgra8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bgra8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgb10a2uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgb10a2Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgb10a2unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgb10a2Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg11b10ufloat
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg11b10Ufloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r64uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R64Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg32uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg32Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg32sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg32Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba32uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba32Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba32sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba32Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
stencil8
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Stencil8
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth32float
-
stencil8
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth32FloatStencil8
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth24plus
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth24Plus
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth24plus
-
stencil8
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth24PlusStencil8
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgb9e5ufloat
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgb9e5Ufloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc1
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc1RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc1
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc1RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc2
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc2RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc2
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc2RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc3
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc3RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc3
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc3RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc4
-
r
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc4RUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc4
-
r
-
snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc4RSnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc5
-
rg
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc5RgUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc5
-
rg
-
snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc5RgSnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc6h
-
rgb
-
ufloat
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc6hRgbUfloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc6h
-
rgb
-
float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc6hRgbFloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc7
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc7RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc7
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc7RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8a1unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8A1Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8a1unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgba8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgba8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgba8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgba8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
r11unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacR11Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
r11snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacR11Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
rg11unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacRg11Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
rg11snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacRg11Snorm
)
;
}
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
ColorWrites
(
u32
)
;
bitflags
:
:
bitflags
!
{
impl
ColorWrites
:
u32
{
/
/
/
Enable
red
channel
writes
const
RED
=
1
<
<
0
;
/
/
/
Enable
green
channel
writes
const
GREEN
=
1
<
<
1
;
/
/
/
Enable
blue
channel
writes
const
BLUE
=
1
<
<
2
;
/
/
/
Enable
alpha
channel
writes
const
ALPHA
=
1
<
<
3
;
/
/
/
Enable
red
green
and
blue
channel
writes
const
COLOR
=
Self
:
:
RED
.
bits
(
)
|
Self
:
:
GREEN
.
bits
(
)
|
Self
:
:
BLUE
.
bits
(
)
;
/
/
/
Enable
writes
to
all
channels
.
const
ALL
=
Self
:
:
RED
.
bits
(
)
|
Self
:
:
GREEN
.
bits
(
)
|
Self
:
:
BLUE
.
bits
(
)
|
Self
:
:
ALPHA
.
bits
(
)
;
}
}
impl
Default
for
ColorWrites
{
fn
default
(
)
-
>
Self
{
Self
:
:
ALL
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
PollType
<
T
>
{
WaitForSubmissionIndex
(
T
)
Wait
Poll
}
impl
<
T
>
PollType
<
T
>
{
#
[
must_use
]
pub
fn
wait
(
)
-
>
Self
{
Self
:
:
Wait
}
#
[
must_use
]
pub
fn
wait_for
(
submission_index
:
T
)
-
>
Self
{
Self
:
:
WaitForSubmissionIndex
(
submission_index
)
}
#
[
must_use
]
pub
fn
is_wait
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
WaitForSubmissionIndex
(
.
.
)
|
Self
:
:
Wait
=
>
true
Self
:
:
Poll
=
>
false
}
}
#
[
must_use
]
pub
fn
map_index
<
U
F
>
(
self
func
:
F
)
-
>
PollType
<
U
>
where
F
:
FnOnce
(
T
)
-
>
U
{
match
self
{
Self
:
:
WaitForSubmissionIndex
(
i
)
=
>
PollType
:
:
WaitForSubmissionIndex
(
func
(
i
)
)
Self
:
:
Wait
=
>
PollType
:
:
Wait
Self
:
:
Poll
=
>
PollType
:
:
Poll
}
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
std
"
derive
(
thiserror
:
:
Error
)
)
]
pub
enum
PollError
{
#
[
cfg_attr
(
feature
=
"
std
"
error
(
"
The
requested
Wait
timed
out
before
the
submission
was
completed
.
"
)
)
]
Timeout
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
PollStatus
{
QueueEmpty
WaitSucceeded
Poll
}
impl
PollStatus
{
#
[
must_use
]
pub
fn
is_queue_empty
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
QueueEmpty
)
}
#
[
must_use
]
pub
fn
wait_finished
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
WaitSucceeded
|
Self
:
:
QueueEmpty
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
StencilState
{
pub
front
:
StencilFaceState
pub
back
:
StencilFaceState
pub
read_mask
:
u32
pub
write_mask
:
u32
}
impl
StencilState
{
#
[
must_use
]
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
(
self
.
front
!
=
StencilFaceState
:
:
IGNORE
|
|
self
.
back
!
=
StencilFaceState
:
:
IGNORE
)
&
&
(
self
.
read_mask
!
=
0
|
|
self
.
write_mask
!
=
0
)
}
#
[
must_use
]
pub
fn
is_read_only
(
&
self
cull_mode
:
Option
<
Face
>
)
-
>
bool
{
if
self
.
write_mask
=
=
0
{
return
true
;
}
let
front_ro
=
cull_mode
=
=
Some
(
Face
:
:
Front
)
|
|
self
.
front
.
is_read_only
(
)
;
let
back_ro
=
cull_mode
=
=
Some
(
Face
:
:
Back
)
|
|
self
.
back
.
is_read_only
(
)
;
front_ro
&
&
back_ro
}
#
[
must_use
]
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
front
.
needs_ref_value
(
)
|
|
self
.
back
.
needs_ref_value
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
DepthBiasState
{
pub
constant
:
i32
pub
slope_scale
:
f32
pub
clamp
:
f32
}
impl
DepthBiasState
{
#
[
must_use
]
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
self
.
constant
!
=
0
|
|
self
.
slope_scale
!
=
0
.
0
}
}
impl
Hash
for
DepthBiasState
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
constant
.
hash
(
state
)
;
self
.
slope_scale
.
to_bits
(
)
.
hash
(
state
)
;
self
.
clamp
.
to_bits
(
)
.
hash
(
state
)
;
}
}
impl
PartialEq
for
DepthBiasState
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
(
self
.
constant
=
=
other
.
constant
)
&
&
(
self
.
slope_scale
.
to_bits
(
)
=
=
other
.
slope_scale
.
to_bits
(
)
)
&
&
(
self
.
clamp
.
to_bits
(
)
=
=
other
.
clamp
.
to_bits
(
)
)
}
}
impl
Eq
for
DepthBiasState
{
}
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
LoadOp
<
V
>
{
Clear
(
V
)
=
0
Load
=
1
}
impl
<
V
>
LoadOp
<
V
>
{
pub
fn
eq_variant
<
T
>
(
&
self
other
:
LoadOp
<
T
>
)
-
>
bool
{
matches
!
(
(
self
other
)
(
LoadOp
:
:
Clear
(
_
)
LoadOp
:
:
Clear
(
_
)
)
|
(
LoadOp
:
:
Load
LoadOp
:
:
Load
)
)
}
}
impl
<
V
:
Default
>
Default
for
LoadOp
<
V
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
Clear
(
Default
:
:
default
(
)
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StoreOp
{
#
[
default
]
Store
=
0
Discard
=
1
}
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
Operations
<
V
>
{
pub
load
:
LoadOp
<
V
>
pub
store
:
StoreOp
}
impl
<
V
:
Default
>
Default
for
Operations
<
V
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
{
load
:
LoadOp
:
:
<
V
>
:
:
default
(
)
store
:
StoreOp
:
:
default
(
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
DepthStencilState
{
pub
format
:
TextureFormat
pub
depth_write_enabled
:
bool
pub
depth_compare
:
CompareFunction
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
stencil
:
StencilState
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
bias
:
DepthBiasState
}
impl
DepthStencilState
{
#
[
must_use
]
pub
fn
is_depth_enabled
(
&
self
)
-
>
bool
{
self
.
depth_compare
!
=
CompareFunction
:
:
Always
|
|
self
.
depth_write_enabled
}
#
[
must_use
]
pub
fn
is_depth_read_only
(
&
self
)
-
>
bool
{
!
self
.
depth_write_enabled
}
#
[
must_use
]
pub
fn
is_stencil_read_only
(
&
self
cull_mode
:
Option
<
Face
>
)
-
>
bool
{
self
.
stencil
.
is_read_only
(
cull_mode
)
}
#
[
must_use
]
pub
fn
is_read_only
(
&
self
cull_mode
:
Option
<
Face
>
)
-
>
bool
{
self
.
is_depth_read_only
(
)
&
&
self
.
is_stencil_read_only
(
cull_mode
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
IndexFormat
{
Uint16
=
0
#
[
default
]
Uint32
=
1
}
impl
IndexFormat
{
pub
fn
byte_size
(
&
self
)
-
>
usize
{
match
self
{
IndexFormat
:
:
Uint16
=
>
2
IndexFormat
:
:
Uint32
=
>
4
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StencilOperation
{
#
[
default
]
Keep
=
0
Zero
=
1
Replace
=
2
Invert
=
3
IncrementClamp
=
4
DecrementClamp
=
5
IncrementWrap
=
6
DecrementWrap
=
7
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
StencilFaceState
{
pub
compare
:
CompareFunction
pub
fail_op
:
StencilOperation
pub
depth_fail_op
:
StencilOperation
pub
pass_op
:
StencilOperation
}
impl
StencilFaceState
{
pub
const
IGNORE
:
Self
=
StencilFaceState
{
compare
:
CompareFunction
:
:
Always
fail_op
:
StencilOperation
:
:
Keep
depth_fail_op
:
StencilOperation
:
:
Keep
pass_op
:
StencilOperation
:
:
Keep
}
;
#
[
must_use
]
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
compare
.
needs_ref_value
(
)
|
|
self
.
fail_op
=
=
StencilOperation
:
:
Replace
|
|
self
.
depth_fail_op
=
=
StencilOperation
:
:
Replace
|
|
self
.
pass_op
=
=
StencilOperation
:
:
Replace
}
#
[
must_use
]
pub
fn
is_read_only
(
&
self
)
-
>
bool
{
self
.
pass_op
=
=
StencilOperation
:
:
Keep
&
&
self
.
depth_fail_op
=
=
StencilOperation
:
:
Keep
&
&
self
.
fail_op
=
=
StencilOperation
:
:
Keep
}
}
impl
Default
for
StencilFaceState
{
fn
default
(
)
-
>
Self
{
Self
:
:
IGNORE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
CompareFunction
{
Never
=
1
Less
=
2
Equal
=
3
LessEqual
=
4
Greater
=
5
NotEqual
=
6
GreaterEqual
=
7
Always
=
8
}
impl
CompareFunction
{
#
[
must_use
]
pub
fn
needs_ref_value
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Never
|
Self
:
:
Always
=
>
false
_
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
VertexStepMode
{
#
[
default
]
Vertex
=
0
Instance
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
VertexAttribute
{
pub
format
:
VertexFormat
pub
offset
:
BufferAddress
pub
shader_location
:
ShaderLocation
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
lowercase
"
)
)
]
pub
enum
VertexFormat
{
Uint8
=
0
Uint8x2
=
1
Uint8x4
=
2
Sint8
=
3
Sint8x2
=
4
Sint8x4
=
5
Unorm8
=
6
Unorm8x2
=
7
Unorm8x4
=
8
Snorm8
=
9
Snorm8x2
=
10
Snorm8x4
=
11
Uint16
=
12
Uint16x2
=
13
Uint16x4
=
14
Sint16
=
15
Sint16x2
=
16
Sint16x4
=
17
Unorm16
=
18
Unorm16x2
=
19
Unorm16x4
=
20
Snorm16
=
21
Snorm16x2
=
22
Snorm16x4
=
23
Float16
=
24
Float16x2
=
25
Float16x4
=
26
Float32
=
27
Float32x2
=
28
Float32x3
=
29
Float32x4
=
30
Uint32
=
31
Uint32x2
=
32
Uint32x3
=
33
Uint32x4
=
34
Sint32
=
35
Sint32x2
=
36
Sint32x3
=
37
Sint32x4
=
38
Float64
=
39
Float64x2
=
40
Float64x3
=
41
Float64x4
=
42
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
unorm10
-
10
-
10
-
2
"
)
)
]
Unorm10_10_10_2
=
43
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
unorm8x4
-
bgra
"
)
)
]
Unorm8x4Bgra
=
44
}
impl
VertexFormat
{
#
[
must_use
]
pub
const
fn
size
(
&
self
)
-
>
u64
{
match
self
{
Self
:
:
Uint8
|
Self
:
:
Sint8
|
Self
:
:
Unorm8
|
Self
:
:
Snorm8
=
>
1
Self
:
:
Uint8x2
|
Self
:
:
Sint8x2
|
Self
:
:
Unorm8x2
|
Self
:
:
Snorm8x2
|
Self
:
:
Uint16
|
Self
:
:
Sint16
|
Self
:
:
Unorm16
|
Self
:
:
Snorm16
|
Self
:
:
Float16
=
>
2
Self
:
:
Uint8x4
|
Self
:
:
Sint8x4
|
Self
:
:
Unorm8x4
|
Self
:
:
Snorm8x4
|
Self
:
:
Uint16x2
|
Self
:
:
Sint16x2
|
Self
:
:
Unorm16x2
|
Self
:
:
Snorm16x2
|
Self
:
:
Float16x2
|
Self
:
:
Float32
|
Self
:
:
Uint32
|
Self
:
:
Sint32
|
Self
:
:
Unorm10_10_10_2
|
Self
:
:
Unorm8x4Bgra
=
>
4
Self
:
:
Uint16x4
|
Self
:
:
Sint16x4
|
Self
:
:
Unorm16x4
|
Self
:
:
Snorm16x4
|
Self
:
:
Float16x4
|
Self
:
:
Float32x2
|
Self
:
:
Uint32x2
|
Self
:
:
Sint32x2
|
Self
:
:
Float64
=
>
8
Self
:
:
Float32x3
|
Self
:
:
Uint32x3
|
Self
:
:
Sint32x3
=
>
12
Self
:
:
Float32x4
|
Self
:
:
Uint32x4
|
Self
:
:
Sint32x4
|
Self
:
:
Float64x2
=
>
16
Self
:
:
Float64x3
=
>
24
Self
:
:
Float64x4
=
>
32
}
}
#
[
must_use
]
pub
const
fn
min_acceleration_structure_vertex_stride
(
&
self
)
-
>
u64
{
match
self
{
Self
:
:
Float16x2
|
Self
:
:
Snorm16x2
=
>
4
Self
:
:
Float32x3
=
>
12
Self
:
:
Float32x2
=
>
8
Self
:
:
Float16x4
|
Self
:
:
Snorm16x4
=
>
6
_
=
>
unreachable
!
(
)
}
}
#
[
must_use
]
pub
const
fn
acceleration_structure_stride_alignment
(
&
self
)
-
>
u64
{
match
self
{
Self
:
:
Float16x4
|
Self
:
:
Float16x2
|
Self
:
:
Snorm16x4
|
Self
:
:
Snorm16x2
=
>
2
Self
:
:
Float32x2
|
Self
:
:
Float32x3
=
>
4
_
=
>
unreachable
!
(
)
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
buffer
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
buffer
is
allocated
from
and
what
/
/
/
actions
the
buffer
can
partake
in
.
/
/
/
/
/
/
Corresponds
to
[
WebGPU
GPUBufferUsageFlags
]
(
/
/
/
https
:
/
/
gpuweb
.
github
.
io
/
gpuweb
/
#
typedefdef
-
gpubufferusageflags
)
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
BufferUsages
:
u32
{
/
/
/
Allow
a
buffer
to
be
mapped
for
reading
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
[
BufferDescriptor
:
:
mapped_at_creation
]
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_DST
.
const
MAP_READ
=
1
<
<
0
;
/
/
/
Allow
a
buffer
to
be
mapped
for
writing
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range_mut
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
[
BufferDescriptor
:
:
mapped_at_creation
]
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
feature
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_SRC
.
const
MAP_WRITE
=
1
<
<
1
;
/
/
/
Allow
a
buffer
to
be
the
source
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
or
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
operation
.
const
COPY_SRC
=
1
<
<
2
;
/
/
/
Allow
a
buffer
to
be
the
destination
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
[
CommandEncoder
:
:
copy_texture_to_buffer
]
/
/
/
[
CommandEncoder
:
:
clear_buffer
]
or
[
Queue
:
:
write_buffer
]
operation
.
const
COPY_DST
=
1
<
<
3
;
/
/
/
Allow
a
buffer
to
be
the
index
buffer
in
a
draw
operation
.
const
INDEX
=
1
<
<
4
;
/
/
/
Allow
a
buffer
to
be
the
vertex
buffer
in
a
draw
operation
.
const
VERTEX
=
1
<
<
5
;
/
/
/
Allow
a
buffer
to
be
a
[
BufferBindingType
:
:
Uniform
]
inside
a
bind
group
.
const
UNIFORM
=
1
<
<
6
;
/
/
/
Allow
a
buffer
to
be
a
[
BufferBindingType
:
:
Storage
]
inside
a
bind
group
.
const
STORAGE
=
1
<
<
7
;
/
/
/
Allow
a
buffer
to
be
the
indirect
buffer
in
an
indirect
draw
call
.
const
INDIRECT
=
1
<
<
8
;
/
/
/
Allow
a
buffer
to
be
the
destination
buffer
for
a
[
CommandEncoder
:
:
resolve_query_set
]
operation
.
const
QUERY_RESOLVE
=
1
<
<
9
;
/
/
/
Allows
a
buffer
to
be
used
as
input
for
a
bottom
level
acceleration
structure
build
const
BLAS_INPUT
=
1
<
<
10
;
/
/
/
Allows
a
buffer
to
be
used
as
input
for
a
top
level
acceleration
structure
build
const
TLAS_INPUT
=
1
<
<
11
;
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Similar
to
BufferUsages
but
used
only
for
CommandEncoder
:
:
transition_resources
.
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
BufferUses
:
u16
{
/
/
/
The
argument
to
a
read
-
only
mapping
.
const
MAP_READ
=
1
<
<
0
;
/
/
/
The
argument
to
a
write
-
only
mapping
.
const
MAP_WRITE
=
1
<
<
1
;
/
/
/
The
source
of
a
hardware
copy
.
/
/
/
cbindgen
:
ignore
const
COPY_SRC
=
1
<
<
2
;
/
/
/
The
destination
of
a
hardware
copy
.
/
/
/
cbindgen
:
ignore
const
COPY_DST
=
1
<
<
3
;
/
/
/
The
index
buffer
used
for
drawing
.
const
INDEX
=
1
<
<
4
;
/
/
/
A
vertex
buffer
used
for
drawing
.
const
VERTEX
=
1
<
<
5
;
/
/
/
A
uniform
buffer
bound
in
a
bind
group
.
const
UNIFORM
=
1
<
<
6
;
/
/
/
A
read
-
only
storage
buffer
used
in
a
bind
group
.
/
/
/
cbindgen
:
ignore
const
STORAGE_READ_ONLY
=
1
<
<
7
;
/
/
/
A
read
-
write
buffer
used
in
a
bind
group
.
/
/
/
cbindgen
:
ignore
const
STORAGE_READ_WRITE
=
1
<
<
8
;
/
/
/
The
indirect
or
count
buffer
in
a
indirect
draw
or
dispatch
.
const
INDIRECT
=
1
<
<
9
;
/
/
/
A
buffer
used
to
store
query
results
.
const
QUERY_RESOLVE
=
1
<
<
10
;
/
/
/
Buffer
used
for
acceleration
structure
building
.
const
ACCELERATION_STRUCTURE_SCRATCH
=
1
<
<
11
;
/
/
/
Buffer
used
for
bottom
level
acceleration
structure
building
.
const
BOTTOM_LEVEL_ACCELERATION_STRUCTURE_INPUT
=
1
<
<
12
;
/
/
/
Buffer
used
for
top
level
acceleration
structure
building
.
const
TOP_LEVEL_ACCELERATION_STRUCTURE_INPUT
=
1
<
<
13
;
/
/
/
A
buffer
used
to
store
the
compacted
size
of
an
acceleration
structure
const
ACCELERATION_STRUCTURE_QUERY
=
1
<
<
14
;
/
/
/
The
combination
of
states
that
a
buffer
may
be
in
_at
the
same
time_
.
const
INCLUSIVE
=
Self
:
:
MAP_READ
.
bits
(
)
|
Self
:
:
COPY_SRC
.
bits
(
)
|
Self
:
:
INDEX
.
bits
(
)
|
Self
:
:
VERTEX
.
bits
(
)
|
Self
:
:
UNIFORM
.
bits
(
)
|
Self
:
:
STORAGE_READ_ONLY
.
bits
(
)
|
Self
:
:
INDIRECT
.
bits
(
)
|
Self
:
:
BOTTOM_LEVEL_ACCELERATION_STRUCTURE_INPUT
.
bits
(
)
|
Self
:
:
TOP_LEVEL_ACCELERATION_STRUCTURE_INPUT
.
bits
(
)
;
/
/
/
The
combination
of
states
that
a
buffer
must
exclusively
be
in
.
const
EXCLUSIVE
=
Self
:
:
MAP_WRITE
.
bits
(
)
|
Self
:
:
COPY_DST
.
bits
(
)
|
Self
:
:
STORAGE_READ_WRITE
.
bits
(
)
|
Self
:
:
ACCELERATION_STRUCTURE_SCRATCH
.
bits
(
)
;
/
/
/
The
combination
of
all
usages
that
the
are
guaranteed
to
be
be
ordered
by
the
hardware
.
/
/
/
If
a
usage
is
ordered
then
if
the
buffer
state
doesn
'
t
change
between
draw
calls
there
/
/
/
are
no
barriers
needed
for
synchronization
.
const
ORDERED
=
Self
:
:
INCLUSIVE
.
bits
(
)
|
Self
:
:
MAP_WRITE
.
bits
(
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
BufferTransition
<
T
>
{
pub
buffer
:
T
pub
state
:
BufferUses
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
BufferDescriptor
<
L
>
{
pub
label
:
L
pub
size
:
BufferAddress
pub
usage
:
BufferUsages
pub
mapped_at_creation
:
bool
}
impl
<
L
>
BufferDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
BufferDescriptor
<
K
>
{
BufferDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
usage
:
self
.
usage
mapped_at_creation
:
self
.
mapped_at_creation
}
}
}
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
CommandEncoderDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandEncoderDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandEncoderDescriptor
<
K
>
{
CommandEncoderDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
CommandEncoderDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
PresentMode
{
AutoVsync
=
0
AutoNoVsync
=
1
#
[
default
]
Fifo
=
2
FifoRelaxed
=
3
Immediate
=
4
Mailbox
=
5
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
lowercase
"
)
)
]
pub
enum
CompositeAlphaMode
{
Auto
=
0
Opaque
=
1
PreMultiplied
=
2
PostMultiplied
=
3
Inherit
=
4
}
impl
Default
for
CompositeAlphaMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
Auto
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
texture
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
texture
is
allocated
from
and
what
/
/
/
actions
the
texture
can
partake
in
.
/
/
/
/
/
/
Corresponds
to
[
WebGPU
GPUTextureUsageFlags
]
(
/
/
/
https
:
/
/
gpuweb
.
github
.
io
/
gpuweb
/
#
typedefdef
-
gputextureusageflags
)
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TextureUsages
:
u32
{
/
/
/
/
-
-
-
-
Start
numbering
at
1
<
<
0
-
-
-
-
/
/
/
/
WebGPU
features
:
/
/
/
/
/
Allows
a
texture
to
be
the
source
in
a
[
CommandEncoder
:
:
copy_texture_to_buffer
]
or
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
operation
.
const
COPY_SRC
=
1
<
<
0
;
/
/
/
Allows
a
texture
to
be
the
destination
in
a
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
or
[
Queue
:
:
write_texture
]
operation
.
const
COPY_DST
=
1
<
<
1
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
Texture
]
in
a
bind
group
.
const
TEXTURE_BINDING
=
1
<
<
2
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
StorageTexture
]
in
a
bind
group
.
const
STORAGE_BINDING
=
1
<
<
3
;
/
/
/
Allows
a
texture
to
be
an
output
attachment
of
a
render
pass
.
const
RENDER_ATTACHMENT
=
1
<
<
4
;
/
/
/
/
-
-
-
-
Restart
Numbering
for
Native
Features
-
-
-
/
/
/
/
Native
Features
:
/
/
/
/
/
Allows
a
texture
to
be
used
with
image
atomics
.
Requires
[
Features
:
:
TEXTURE_ATOMIC
]
.
const
STORAGE_ATOMIC
=
1
<
<
16
;
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Similar
to
TextureUsages
but
used
only
for
CommandEncoder
:
:
transition_resources
.
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TextureUses
:
u16
{
/
/
/
The
texture
is
in
unknown
state
.
const
UNINITIALIZED
=
1
<
<
0
;
/
/
/
Ready
to
present
image
to
the
surface
.
const
PRESENT
=
1
<
<
1
;
/
/
/
The
source
of
a
hardware
copy
.
/
/
/
cbindgen
:
ignore
const
COPY_SRC
=
1
<
<
2
;
/
/
/
The
destination
of
a
hardware
copy
.
/
/
/
cbindgen
:
ignore
const
COPY_DST
=
1
<
<
3
;
/
/
/
Read
-
only
sampled
or
fetched
resource
.
const
RESOURCE
=
1
<
<
4
;
/
/
/
The
color
target
of
a
renderpass
.
const
COLOR_TARGET
=
1
<
<
5
;
/
/
/
Read
-
only
depth
stencil
usage
.
const
DEPTH_STENCIL_READ
=
1
<
<
6
;
/
/
/
Read
-
write
depth
stencil
usage
const
DEPTH_STENCIL_WRITE
=
1
<
<
7
;
/
/
/
Read
-
only
storage
texture
usage
.
Corresponds
to
a
UAV
in
d3d
so
is
exclusive
despite
being
read
only
.
/
/
/
cbindgen
:
ignore
const
STORAGE_READ_ONLY
=
1
<
<
8
;
/
/
/
Write
-
only
storage
texture
usage
.
/
/
/
cbindgen
:
ignore
const
STORAGE_WRITE_ONLY
=
1
<
<
9
;
/
/
/
Read
-
write
storage
texture
usage
.
/
/
/
cbindgen
:
ignore
const
STORAGE_READ_WRITE
=
1
<
<
10
;
/
/
/
Image
atomic
enabled
storage
.
/
/
/
cbindgen
:
ignore
const
STORAGE_ATOMIC
=
1
<
<
11
;
/
/
/
The
combination
of
states
that
a
texture
may
be
in
_at
the
same
time_
.
/
/
/
cbindgen
:
ignore
const
INCLUSIVE
=
Self
:
:
COPY_SRC
.
bits
(
)
|
Self
:
:
RESOURCE
.
bits
(
)
|
Self
:
:
DEPTH_STENCIL_READ
.
bits
(
)
;
/
/
/
The
combination
of
states
that
a
texture
must
exclusively
be
in
.
/
/
/
cbindgen
:
ignore
const
EXCLUSIVE
=
Self
:
:
COPY_DST
.
bits
(
)
|
Self
:
:
COLOR_TARGET
.
bits
(
)
|
Self
:
:
DEPTH_STENCIL_WRITE
.
bits
(
)
|
Self
:
:
STORAGE_READ_ONLY
.
bits
(
)
|
Self
:
:
STORAGE_WRITE_ONLY
.
bits
(
)
|
Self
:
:
STORAGE_READ_WRITE
.
bits
(
)
|
Self
:
:
STORAGE_ATOMIC
.
bits
(
)
|
Self
:
:
PRESENT
.
bits
(
)
;
/
/
/
The
combination
of
all
usages
that
the
are
guaranteed
to
be
be
ordered
by
the
hardware
.
/
/
/
If
a
usage
is
ordered
then
if
the
texture
state
doesn
'
t
change
between
draw
calls
there
/
/
/
are
no
barriers
needed
for
synchronization
.
/
/
/
cbindgen
:
ignore
const
ORDERED
=
Self
:
:
INCLUSIVE
.
bits
(
)
|
Self
:
:
COLOR_TARGET
.
bits
(
)
|
Self
:
:
DEPTH_STENCIL_WRITE
.
bits
(
)
|
Self
:
:
STORAGE_READ_ONLY
.
bits
(
)
;
/
/
/
Flag
used
by
the
wgpu
-
core
texture
tracker
to
say
a
texture
is
in
different
states
for
every
sub
-
resource
const
COMPLEX
=
1
<
<
12
;
/
/
/
Flag
used
by
the
wgpu
-
core
texture
tracker
to
say
that
the
tracker
does
not
know
the
state
of
the
sub
-
resource
.
/
/
/
This
is
different
from
UNINITIALIZED
as
that
says
the
tracker
does
know
but
the
texture
has
not
been
initialized
.
const
UNKNOWN
=
1
<
<
13
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
TextureTransition
<
T
>
{
pub
texture
:
T
pub
selector
:
Option
<
TextureSelector
>
pub
state
:
TextureUses
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
TextureSelector
{
pub
mips
:
Range
<
u32
>
pub
layers
:
Range
<
u32
>
}
#
[
derive
(
Debug
)
]
pub
struct
SurfaceCapabilities
{
pub
formats
:
Vec
<
TextureFormat
>
pub
present_modes
:
Vec
<
PresentMode
>
pub
alpha_modes
:
Vec
<
CompositeAlphaMode
>
pub
usages
:
TextureUsages
}
impl
Default
for
SurfaceCapabilities
{
fn
default
(
)
-
>
Self
{
Self
{
formats
:
Vec
:
:
new
(
)
present_modes
:
Vec
:
:
new
(
)
alpha_modes
:
vec
!
[
CompositeAlphaMode
:
:
Opaque
]
usages
:
TextureUsages
:
:
RENDER_ATTACHMENT
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
SurfaceConfiguration
<
V
>
{
pub
usage
:
TextureUsages
pub
format
:
TextureFormat
pub
width
:
u32
pub
height
:
u32
pub
present_mode
:
PresentMode
pub
desired_maximum_frame_latency
:
u32
pub
alpha_mode
:
CompositeAlphaMode
pub
view_formats
:
V
}
impl
<
V
:
Clone
>
SurfaceConfiguration
<
V
>
{
pub
fn
map_view_formats
<
M
>
(
&
self
fun
:
impl
FnOnce
(
V
)
-
>
M
)
-
>
SurfaceConfiguration
<
M
>
{
SurfaceConfiguration
{
usage
:
self
.
usage
format
:
self
.
format
width
:
self
.
width
height
:
self
.
height
present_mode
:
self
.
present_mode
desired_maximum_frame_latency
:
self
.
desired_maximum_frame_latency
alpha_mode
:
self
.
alpha_mode
view_formats
:
fun
(
self
.
view_formats
.
clone
(
)
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
enum
SurfaceStatus
{
Good
Suboptimal
Timeout
Outdated
Lost
Unknown
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
PresentationTimestamp
(
pub
u128
)
;
impl
PresentationTimestamp
{
pub
const
INVALID_TIMESTAMP
:
Self
=
Self
(
u128
:
:
MAX
)
;
#
[
must_use
]
pub
fn
is_invalid
(
self
)
-
>
bool
{
self
=
=
Self
:
:
INVALID_TIMESTAMP
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Color
{
pub
r
:
f64
pub
g
:
f64
pub
b
:
f64
pub
a
:
f64
}
#
[
allow
(
missing_docs
)
]
impl
Color
{
pub
const
TRANSPARENT
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
0
.
0
}
;
pub
const
BLACK
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
WHITE
:
Self
=
Self
{
r
:
1
.
0
g
:
1
.
0
b
:
1
.
0
a
:
1
.
0
}
;
pub
const
RED
:
Self
=
Self
{
r
:
1
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
GREEN
:
Self
=
Self
{
r
:
0
.
0
g
:
1
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
BLUE
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
1
.
0
a
:
1
.
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
TextureDimension
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
1d
"
)
)
]
D1
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
"
)
)
]
D2
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
3d
"
)
)
]
D3
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Origin2d
{
#
[
allow
(
missing_docs
)
]
pub
x
:
u32
#
[
allow
(
missing_docs
)
]
pub
y
:
u32
}
impl
Origin2d
{
pub
const
ZERO
:
Self
=
Self
{
x
:
0
y
:
0
}
;
#
[
must_use
]
pub
fn
to_3d
(
self
z
:
u32
)
-
>
Origin3d
{
Origin3d
{
x
:
self
.
x
y
:
self
.
y
z
}
}
}
impl
core
:
:
fmt
:
:
Debug
for
Origin2d
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
(
self
.
x
self
.
y
)
.
fmt
(
f
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Origin3d
{
pub
x
:
u32
pub
y
:
u32
pub
z
:
u32
}
impl
Origin3d
{
pub
const
ZERO
:
Self
=
Self
{
x
:
0
y
:
0
z
:
0
}
;
#
[
must_use
]
pub
fn
to_2d
(
self
)
-
>
Origin2d
{
Origin2d
{
x
:
self
.
x
y
:
self
.
y
}
}
}
impl
Default
for
Origin3d
{
fn
default
(
)
-
>
Self
{
Self
:
:
ZERO
}
}
impl
core
:
:
fmt
:
:
Debug
for
Origin3d
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
(
self
.
x
self
.
y
self
.
z
)
.
fmt
(
f
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Extent3d
{
pub
width
:
u32
pub
height
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
=
"
default_depth
"
)
)
]
pub
depth_or_array_layers
:
u32
}
impl
core
:
:
fmt
:
:
Debug
for
Extent3d
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
(
self
.
width
self
.
height
self
.
depth_or_array_layers
)
.
fmt
(
f
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
fn
default_depth
(
)
-
>
u32
{
1
}
impl
Default
for
Extent3d
{
fn
default
(
)
-
>
Self
{
Self
{
width
:
1
height
:
1
depth_or_array_layers
:
1
}
}
}
impl
Extent3d
{
#
[
must_use
]
pub
fn
physical_size
(
&
self
format
:
TextureFormat
)
-
>
Self
{
let
(
block_width
block_height
)
=
format
.
block_dimensions
(
)
;
let
width
=
self
.
width
.
div_ceil
(
block_width
)
*
block_width
;
let
height
=
self
.
height
.
div_ceil
(
block_height
)
*
block_height
;
Self
{
width
height
depth_or_array_layers
:
self
.
depth_or_array_layers
}
}
#
[
must_use
]
pub
fn
max_mips
(
&
self
dim
:
TextureDimension
)
-
>
u32
{
match
dim
{
TextureDimension
:
:
D1
=
>
1
TextureDimension
:
:
D2
=
>
{
let
max_dim
=
self
.
width
.
max
(
self
.
height
)
;
32
-
max_dim
.
leading_zeros
(
)
}
TextureDimension
:
:
D3
=
>
{
let
max_dim
=
self
.
width
.
max
(
self
.
height
.
max
(
self
.
depth_or_array_layers
)
)
;
32
-
max_dim
.
leading_zeros
(
)
}
}
}
#
[
must_use
]
pub
fn
mip_level_size
(
&
self
level
:
u32
dim
:
TextureDimension
)
-
>
Self
{
Self
{
width
:
u32
:
:
max
(
1
self
.
width
>
>
level
)
height
:
match
dim
{
TextureDimension
:
:
D1
=
>
1
_
=
>
u32
:
:
max
(
1
self
.
height
>
>
level
)
}
depth_or_array_layers
:
match
dim
{
TextureDimension
:
:
D1
=
>
1
TextureDimension
:
:
D2
=
>
self
.
depth_or_array_layers
TextureDimension
:
:
D3
=
>
u32
:
:
max
(
1
self
.
depth_or_array_layers
>
>
level
)
}
}
}
}
#
[
test
]
fn
test_physical_size
(
)
{
let
format
=
TextureFormat
:
:
Bc1RgbaUnormSrgb
;
assert_eq
!
(
Extent3d
{
width
:
7
height
:
7
depth_or_array_layers
:
1
}
.
physical_size
(
format
)
Extent3d
{
width
:
8
height
:
8
depth_or_array_layers
:
1
}
)
;
assert_eq
!
(
Extent3d
{
width
:
8
height
:
8
depth_or_array_layers
:
1
}
.
physical_size
(
format
)
Extent3d
{
width
:
8
height
:
8
depth_or_array_layers
:
1
}
)
;
let
format
=
TextureFormat
:
:
Astc
{
block
:
AstcBlock
:
:
B8x5
channel
:
AstcChannel
:
:
Unorm
}
;
assert_eq
!
(
Extent3d
{
width
:
7
height
:
7
depth_or_array_layers
:
1
}
.
physical_size
(
format
)
Extent3d
{
width
:
8
height
:
10
depth_or_array_layers
:
1
}
)
;
}
#
[
test
]
fn
test_max_mips
(
)
{
assert_eq
!
(
Extent3d
{
width
:
240
height
:
1
depth_or_array_layers
:
1
}
.
max_mips
(
TextureDimension
:
:
D1
)
1
)
;
assert_eq
!
(
Extent3d
{
width
:
1
height
:
1
depth_or_array_layers
:
1
}
.
max_mips
(
TextureDimension
:
:
D2
)
1
)
;
assert_eq
!
(
Extent3d
{
width
:
60
height
:
60
depth_or_array_layers
:
1
}
.
max_mips
(
TextureDimension
:
:
D2
)
6
)
;
assert_eq
!
(
Extent3d
{
width
:
240
height
:
1
depth_or_array_layers
:
1000
}
.
max_mips
(
TextureDimension
:
:
D2
)
8
)
;
assert_eq
!
(
Extent3d
{
width
:
16
height
:
30
depth_or_array_layers
:
60
}
.
max_mips
(
TextureDimension
:
:
D3
)
6
)
;
}
#
[
derive
(
Clone
Debug
Default
Eq
PartialEq
)
]
pub
struct
TextureViewDescriptor
<
L
>
{
pub
label
:
L
pub
format
:
Option
<
TextureFormat
>
pub
dimension
:
Option
<
TextureViewDimension
>
pub
usage
:
Option
<
TextureUsages
>
pub
aspect
:
TextureAspect
pub
base_mip_level
:
u32
pub
mip_level_count
:
Option
<
u32
>
pub
base_array_layer
:
u32
pub
array_layer_count
:
Option
<
u32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
TextureDescriptor
<
L
V
>
{
pub
label
:
L
pub
size
:
Extent3d
pub
mip_level_count
:
u32
pub
sample_count
:
u32
pub
dimension
:
TextureDimension
pub
format
:
TextureFormat
pub
usage
:
TextureUsages
pub
view_formats
:
V
}
impl
<
L
V
>
TextureDescriptor
<
L
V
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
TextureDescriptor
<
K
V
>
where
V
:
Clone
{
TextureDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
mip_level_count
:
self
.
mip_level_count
sample_count
:
self
.
sample_count
dimension
:
self
.
dimension
format
:
self
.
format
usage
:
self
.
usage
view_formats
:
self
.
view_formats
.
clone
(
)
}
}
#
[
must_use
]
pub
fn
map_label_and_view_formats
<
K
M
>
(
&
self
l_fun
:
impl
FnOnce
(
&
L
)
-
>
K
v_fun
:
impl
FnOnce
(
V
)
-
>
M
)
-
>
TextureDescriptor
<
K
M
>
where
V
:
Clone
{
TextureDescriptor
{
label
:
l_fun
(
&
self
.
label
)
size
:
self
.
size
mip_level_count
:
self
.
mip_level_count
sample_count
:
self
.
sample_count
dimension
:
self
.
dimension
format
:
self
.
format
usage
:
self
.
usage
view_formats
:
v_fun
(
self
.
view_formats
.
clone
(
)
)
}
}
#
[
must_use
]
pub
fn
mip_level_size
(
&
self
level
:
u32
)
-
>
Option
<
Extent3d
>
{
if
level
>
=
self
.
mip_level_count
{
return
None
;
}
Some
(
self
.
size
.
mip_level_size
(
level
self
.
dimension
)
)
}
#
[
must_use
]
pub
fn
compute_render_extent
(
&
self
mip_level
:
u32
)
-
>
Extent3d
{
Extent3d
{
width
:
u32
:
:
max
(
1
self
.
size
.
width
>
>
mip_level
)
height
:
u32
:
:
max
(
1
self
.
size
.
height
>
>
mip_level
)
depth_or_array_layers
:
1
}
}
#
[
must_use
]
pub
fn
array_layer_count
(
&
self
)
-
>
u32
{
match
self
.
dimension
{
TextureDimension
:
:
D1
|
TextureDimension
:
:
D3
=
>
1
TextureDimension
:
:
D2
=
>
self
.
size
.
depth_or_array_layers
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
ExternalTextureFormat
{
Rgba
Nv12
Yu12
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
bytemuck
:
:
Zeroable
bytemuck
:
:
Pod
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
ExternalTextureTransferFunction
{
pub
a
:
f32
pub
b
:
f32
pub
g
:
f32
pub
k
:
f32
}
impl
Default
for
ExternalTextureTransferFunction
{
fn
default
(
)
-
>
Self
{
Self
{
a
:
1
.
0
b
:
1
.
0
g
:
1
.
0
k
:
1
.
0
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
ExternalTextureDescriptor
<
L
>
{
pub
label
:
L
pub
width
:
u32
pub
height
:
u32
pub
format
:
ExternalTextureFormat
pub
yuv_conversion_matrix
:
[
f32
;
16
]
pub
gamut_conversion_matrix
:
[
f32
;
9
]
pub
src_transfer_function
:
ExternalTextureTransferFunction
pub
dst_transfer_function
:
ExternalTextureTransferFunction
pub
sample_transform
:
[
f32
;
6
]
pub
load_transform
:
[
f32
;
6
]
}
impl
<
L
>
ExternalTextureDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
ExternalTextureDescriptor
<
K
>
{
ExternalTextureDescriptor
{
label
:
fun
(
&
self
.
label
)
width
:
self
.
width
height
:
self
.
height
format
:
self
.
format
yuv_conversion_matrix
:
self
.
yuv_conversion_matrix
sample_transform
:
self
.
sample_transform
load_transform
:
self
.
load_transform
gamut_conversion_matrix
:
self
.
gamut_conversion_matrix
src_transfer_function
:
self
.
src_transfer_function
dst_transfer_function
:
self
.
dst_transfer_function
}
}
pub
fn
num_planes
(
&
self
)
-
>
usize
{
match
self
.
format
{
ExternalTextureFormat
:
:
Rgba
=
>
1
ExternalTextureFormat
:
:
Nv12
=
>
2
ExternalTextureFormat
:
:
Yu12
=
>
3
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
SamplerDescriptor
<
L
>
{
pub
label
:
L
pub
address_mode_u
:
AddressMode
pub
address_mode_v
:
AddressMode
pub
address_mode_w
:
AddressMode
pub
mag_filter
:
FilterMode
pub
min_filter
:
FilterMode
pub
mipmap_filter
:
FilterMode
pub
lod_min_clamp
:
f32
pub
lod_max_clamp
:
f32
pub
compare
:
Option
<
CompareFunction
>
pub
anisotropy_clamp
:
u16
pub
border_color
:
Option
<
SamplerBorderColor
>
}
impl
<
L
:
Default
>
Default
for
SamplerDescriptor
<
L
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
Default
:
:
default
(
)
address_mode_u
:
Default
:
:
default
(
)
address_mode_v
:
Default
:
:
default
(
)
address_mode_w
:
Default
:
:
default
(
)
mag_filter
:
Default
:
:
default
(
)
min_filter
:
Default
:
:
default
(
)
mipmap_filter
:
Default
:
:
default
(
)
lod_min_clamp
:
0
.
0
lod_max_clamp
:
32
.
0
compare
:
None
anisotropy_clamp
:
1
border_color
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
TextureAspect
{
#
[
default
]
All
StencilOnly
DepthOnly
Plane0
Plane1
Plane2
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
AddressMode
{
#
[
default
]
ClampToEdge
=
0
Repeat
=
1
MirrorRepeat
=
2
ClampToBorder
=
3
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
FilterMode
{
#
[
default
]
Nearest
=
0
Linear
=
1
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
PushConstantRange
{
pub
stages
:
ShaderStages
pub
range
:
Range
<
u32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
CommandBufferDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandBufferDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandBufferDescriptor
<
K
>
{
CommandBufferDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
RenderBundleDepthStencil
{
pub
format
:
TextureFormat
pub
depth_read_only
:
bool
pub
stencil_read_only
:
bool
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
RenderBundleDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
RenderBundleDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
RenderBundleDescriptor
<
K
>
{
RenderBundleDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
RenderBundleDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
TexelCopyBufferLayout
{
pub
offset
:
BufferAddress
pub
bytes_per_row
:
Option
<
u32
>
pub
rows_per_image
:
Option
<
u32
>
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BufferBindingType
{
#
[
default
]
Uniform
Storage
{
read_only
:
bool
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
TextureSampleType
{
Float
{
filterable
:
bool
}
Depth
Sint
Uint
}
impl
Default
for
TextureSampleType
{
fn
default
(
)
-
>
Self
{
Self
:
:
Float
{
filterable
:
true
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StorageTextureAccess
{
WriteOnly
ReadOnly
ReadWrite
Atomic
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
SamplerBindingType
{
Filtering
NonFiltering
Comparison
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BindingType
{
Buffer
{
ty
:
BufferBindingType
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
has_dynamic_offset
:
bool
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
min_binding_size
:
Option
<
BufferSize
>
}
Sampler
(
SamplerBindingType
)
Texture
{
sample_type
:
TextureSampleType
view_dimension
:
TextureViewDimension
multisampled
:
bool
}
StorageTexture
{
access
:
StorageTextureAccess
format
:
TextureFormat
view_dimension
:
TextureViewDimension
}
AccelerationStructure
{
vertex_return
:
bool
}
ExternalTexture
}
impl
BindingType
{
#
[
must_use
]
pub
fn
has_dynamic_offset
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Buffer
{
has_dynamic_offset
.
.
}
=
>
has_dynamic_offset
_
=
>
false
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
BindGroupLayoutEntry
{
pub
binding
:
u32
pub
visibility
:
ShaderStages
pub
ty
:
BindingType
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
count
:
Option
<
NonZeroU32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
TexelCopyBufferInfo
<
B
>
{
pub
buffer
:
B
pub
layout
:
TexelCopyBufferLayout
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
TexelCopyTextureInfo
<
T
>
{
pub
texture
:
T
pub
mip_level
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
origin
:
Origin3d
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
aspect
:
TextureAspect
}
impl
<
T
>
TexelCopyTextureInfo
<
T
>
{
pub
fn
to_tagged
(
self
color_space
:
PredefinedColorSpace
premultiplied_alpha
:
bool
)
-
>
CopyExternalImageDestInfo
<
T
>
{
CopyExternalImageDestInfo
{
texture
:
self
.
texture
mip_level
:
self
.
mip_level
origin
:
self
.
origin
aspect
:
self
.
aspect
color_space
premultiplied_alpha
}
}
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
web
"
)
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
CopyExternalImageSourceInfo
{
pub
source
:
ExternalImageSource
pub
origin
:
Origin2d
pub
flip_y
:
bool
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
web
"
)
)
]
#
[
derive
(
Clone
Debug
)
]
pub
enum
ExternalImageSource
{
ImageBitmap
(
web_sys
:
:
ImageBitmap
)
HTMLImageElement
(
web_sys
:
:
HtmlImageElement
)
HTMLVideoElement
(
web_sys
:
:
HtmlVideoElement
)
ImageData
(
web_sys
:
:
ImageData
)
HTMLCanvasElement
(
web_sys
:
:
HtmlCanvasElement
)
OffscreenCanvas
(
web_sys
:
:
OffscreenCanvas
)
#
[
cfg
(
web_sys_unstable_apis
)
]
VideoFrame
(
web_sys
:
:
VideoFrame
)
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
web
"
)
)
]
impl
ExternalImageSource
{
pub
fn
width
(
&
self
)
-
>
u32
{
match
self
{
ExternalImageSource
:
:
ImageBitmap
(
b
)
=
>
b
.
width
(
)
ExternalImageSource
:
:
HTMLImageElement
(
i
)
=
>
i
.
width
(
)
ExternalImageSource
:
:
HTMLVideoElement
(
v
)
=
>
v
.
video_width
(
)
ExternalImageSource
:
:
ImageData
(
i
)
=
>
i
.
width
(
)
ExternalImageSource
:
:
HTMLCanvasElement
(
c
)
=
>
c
.
width
(
)
ExternalImageSource
:
:
OffscreenCanvas
(
c
)
=
>
c
.
width
(
)
#
[
cfg
(
web_sys_unstable_apis
)
]
ExternalImageSource
:
:
VideoFrame
(
v
)
=
>
v
.
display_width
(
)
}
}
pub
fn
height
(
&
self
)
-
>
u32
{
match
self
{
ExternalImageSource
:
:
ImageBitmap
(
b
)
=
>
b
.
height
(
)
ExternalImageSource
:
:
HTMLImageElement
(
i
)
=
>
i
.
height
(
)
ExternalImageSource
:
:
HTMLVideoElement
(
v
)
=
>
v
.
video_height
(
)
ExternalImageSource
:
:
ImageData
(
i
)
=
>
i
.
height
(
)
ExternalImageSource
:
:
HTMLCanvasElement
(
c
)
=
>
c
.
height
(
)
ExternalImageSource
:
:
OffscreenCanvas
(
c
)
=
>
c
.
height
(
)
#
[
cfg
(
web_sys_unstable_apis
)
]
ExternalImageSource
:
:
VideoFrame
(
v
)
=
>
v
.
display_height
(
)
}
}
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
web
"
)
)
]
impl
core
:
:
ops
:
:
Deref
for
ExternalImageSource
{
type
Target
=
js_sys
:
:
Object
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
match
self
{
Self
:
:
ImageBitmap
(
b
)
=
>
b
Self
:
:
HTMLImageElement
(
i
)
=
>
i
Self
:
:
HTMLVideoElement
(
v
)
=
>
v
Self
:
:
ImageData
(
i
)
=
>
i
Self
:
:
HTMLCanvasElement
(
c
)
=
>
c
Self
:
:
OffscreenCanvas
(
c
)
=
>
c
#
[
cfg
(
web_sys_unstable_apis
)
]
Self
:
:
VideoFrame
(
v
)
=
>
v
}
}
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
web
"
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
]
unsafe
impl
Send
for
ExternalImageSource
{
}
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
feature
=
"
web
"
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
]
unsafe
impl
Sync
for
ExternalImageSource
{
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PredefinedColorSpace
{
Srgb
DisplayP3
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
CopyExternalImageDestInfo
<
T
>
{
pub
texture
:
T
pub
mip_level
:
u32
pub
origin
:
Origin3d
pub
aspect
:
TextureAspect
pub
color_space
:
PredefinedColorSpace
pub
premultiplied_alpha
:
bool
}
impl
<
T
>
CopyExternalImageDestInfo
<
T
>
{
pub
fn
to_untagged
(
self
)
-
>
TexelCopyTextureInfo
<
T
>
{
TexelCopyTextureInfo
{
texture
:
self
.
texture
mip_level
:
self
.
mip_level
origin
:
self
.
origin
aspect
:
self
.
aspect
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
ImageSubresourceRange
{
pub
aspect
:
TextureAspect
pub
base_mip_level
:
u32
pub
mip_level_count
:
Option
<
u32
>
pub
base_array_layer
:
u32
pub
array_layer_count
:
Option
<
u32
>
}
impl
ImageSubresourceRange
{
#
[
must_use
]
pub
fn
is_full_resource
(
&
self
format
:
TextureFormat
mip_levels
:
u32
array_layers
:
u32
)
-
>
bool
{
let
mip_level_count
=
self
.
mip_level_count
.
unwrap_or
(
mip_levels
)
;
let
array_layer_count
=
self
.
array_layer_count
.
unwrap_or
(
array_layers
)
;
let
aspect_eq
=
Some
(
format
)
=
=
format
.
aspect_specific_format
(
self
.
aspect
)
;
let
base_mip_level_eq
=
self
.
base_mip_level
=
=
0
;
let
mip_level_count_eq
=
mip_level_count
=
=
mip_levels
;
let
base_array_layer_eq
=
self
.
base_array_layer
=
=
0
;
let
array_layer_count_eq
=
array_layer_count
=
=
array_layers
;
aspect_eq
&
&
base_mip_level_eq
&
&
mip_level_count_eq
&
&
base_array_layer_eq
&
&
array_layer_count_eq
}
#
[
must_use
]
pub
fn
mip_range
(
&
self
mip_level_count
:
u32
)
-
>
Range
<
u32
>
{
self
.
base_mip_level
.
.
match
self
.
mip_level_count
{
Some
(
mip_level_count
)
=
>
self
.
base_mip_level
+
mip_level_count
None
=
>
mip_level_count
}
}
#
[
must_use
]
pub
fn
layer_range
(
&
self
array_layer_count
:
u32
)
-
>
Range
<
u32
>
{
self
.
base_array_layer
.
.
match
self
.
array_layer_count
{
Some
(
array_layer_count
)
=
>
self
.
base_array_layer
+
array_layer_count
None
=
>
array_layer_count
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
SamplerBorderColor
{
TransparentBlack
OpaqueBlack
OpaqueWhite
Zero
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
QuerySetDescriptor
<
L
>
{
pub
label
:
L
pub
ty
:
QueryType
pub
count
:
u32
}
impl
<
L
>
QuerySetDescriptor
<
L
>
{
#
[
must_use
]
pub
fn
map_label
<
'
a
K
>
(
&
'
a
self
fun
:
impl
FnOnce
(
&
'
a
L
)
-
>
K
)
-
>
QuerySetDescriptor
<
K
>
{
QuerySetDescriptor
{
label
:
fun
(
&
self
.
label
)
ty
:
self
.
ty
count
:
self
.
count
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
QueryType
{
Occlusion
PipelineStatistics
(
PipelineStatisticsTypes
)
Timestamp
}
bitflags
:
:
bitflags
!
{
/
/
/
Flags
for
which
pipeline
data
should
be
recorded
in
a
query
.
/
/
/
/
/
/
Used
in
[
QueryType
]
.
/
/
/
/
/
/
The
amount
of
values
written
when
resolved
depends
/
/
/
on
the
amount
of
flags
set
.
For
example
if
3
flags
are
set
3
/
/
/
64
-
bit
values
will
be
written
per
query
.
/
/
/
/
/
/
The
order
they
are
written
is
the
order
they
are
declared
/
/
/
in
these
bitflags
.
For
example
if
you
enabled
CLIPPER_PRIMITIVES_OUT
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
PipelineStatisticsTypes
:
u8
{
/
/
/
Amount
of
times
the
vertex
shader
is
ran
.
Accounts
for
/
/
/
the
vertex
cache
when
doing
indexed
rendering
.
const
VERTEX_SHADER_INVOCATIONS
=
1
<
<
0
;
/
/
/
Amount
of
times
the
clipper
is
invoked
.
This
/
/
/
is
also
the
amount
of
triangles
output
by
the
vertex
shader
.
const
CLIPPER_INVOCATIONS
=
1
<
<
1
;
/
/
/
Amount
of
primitives
that
are
not
culled
by
the
clipper
.
/
/
/
This
is
the
amount
of
triangles
that
are
actually
on
screen
/
/
/
and
will
be
rasterized
and
rendered
.
const
CLIPPER_PRIMITIVES_OUT
=
1
<
<
2
;
/
/
/
Amount
of
times
the
fragment
shader
is
ran
.
Accounts
for
/
/
/
fragment
shaders
running
in
2x2
blocks
in
order
to
get
/
/
/
derivatives
.
const
FRAGMENT_SHADER_INVOCATIONS
=
1
<
<
3
;
/
/
/
Amount
of
times
a
compute
shader
is
invoked
.
This
will
/
/
/
be
equivalent
to
the
dispatch
count
times
the
workgroup
size
.
const
COMPUTE_SHADER_INVOCATIONS
=
1
<
<
4
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Pod
Zeroable
)
]
pub
struct
DrawIndirectArgs
{
pub
vertex_count
:
u32
pub
instance_count
:
u32
pub
first_vertex
:
u32
pub
first_instance
:
u32
}
impl
DrawIndirectArgs
{
#
[
must_use
]
pub
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
bytemuck
:
:
bytes_of
(
self
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Pod
Zeroable
)
]
pub
struct
DrawIndexedIndirectArgs
{
pub
index_count
:
u32
pub
instance_count
:
u32
pub
first_index
:
u32
pub
base_vertex
:
i32
pub
first_instance
:
u32
}
impl
DrawIndexedIndirectArgs
{
#
[
must_use
]
pub
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
bytemuck
:
:
bytes_of
(
self
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Pod
Zeroable
)
]
pub
struct
DispatchIndirectArgs
{
pub
x
:
u32
pub
y
:
u32
pub
z
:
u32
}
impl
DispatchIndirectArgs
{
#
[
must_use
]
pub
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
bytemuck
:
:
bytes_of
(
self
)
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
ShaderRuntimeChecks
{
pub
bounds_checks
:
bool
pub
force_loop_bounding
:
bool
}
impl
ShaderRuntimeChecks
{
#
[
must_use
]
pub
fn
checked
(
)
-
>
Self
{
unsafe
{
Self
:
:
all
(
true
)
}
}
#
[
must_use
]
pub
fn
unchecked
(
)
-
>
Self
{
unsafe
{
Self
:
:
all
(
false
)
}
}
#
[
must_use
]
pub
unsafe
fn
all
(
all_checks
:
bool
)
-
>
Self
{
Self
{
bounds_checks
:
all_checks
force_loop_bounding
:
all_checks
}
}
}
impl
Default
for
ShaderRuntimeChecks
{
fn
default
(
)
-
>
Self
{
Self
:
:
checked
(
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
BlasTriangleGeometrySizeDescriptor
{
pub
vertex_format
:
VertexFormat
pub
vertex_count
:
u32
pub
index_format
:
Option
<
IndexFormat
>
pub
index_count
:
Option
<
u32
>
pub
flags
:
AccelerationStructureGeometryFlags
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BlasGeometrySizeDescriptors
{
Triangles
{
descriptors
:
Vec
<
BlasTriangleGeometrySizeDescriptor
>
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
AccelerationStructureUpdateMode
{
Build
PreferUpdate
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
CreateBlasDescriptor
<
L
>
{
pub
label
:
L
pub
flags
:
AccelerationStructureFlags
pub
update_mode
:
AccelerationStructureUpdateMode
}
impl
<
L
>
CreateBlasDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CreateBlasDescriptor
<
K
>
{
CreateBlasDescriptor
{
label
:
fun
(
&
self
.
label
)
flags
:
self
.
flags
update_mode
:
self
.
update_mode
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
CreateTlasDescriptor
<
L
>
{
pub
label
:
L
pub
max_instances
:
u32
pub
flags
:
AccelerationStructureFlags
pub
update_mode
:
AccelerationStructureUpdateMode
}
impl
<
L
>
CreateTlasDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CreateTlasDescriptor
<
K
>
{
CreateTlasDescriptor
{
label
:
fun
(
&
self
.
label
)
flags
:
self
.
flags
update_mode
:
self
.
update_mode
max_instances
:
self
.
max_instances
}
}
}
bitflags
:
:
bitflags
!
(
/
/
/
Flags
for
acceleration
structures
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
pub
struct
AccelerationStructureFlags
:
u8
{
/
/
/
Allow
for
incremental
updates
(
no
change
in
size
)
currently
this
is
unimplemented
/
/
/
and
will
build
as
normal
(
this
is
fine
update
vs
build
should
be
unnoticeable
)
const
ALLOW_UPDATE
=
1
<
<
0
;
/
/
/
Allow
the
acceleration
structure
to
be
compacted
in
a
copy
operation
/
/
/
(
Blas
:
:
prepare_for_compaction
CommandEncoder
:
:
compact_blas
)
.
const
ALLOW_COMPACTION
=
1
<
<
1
;
/
/
/
Optimize
for
fast
ray
tracing
performance
recommended
if
the
geometry
is
unlikely
/
/
/
to
change
(
e
.
g
.
in
a
game
:
non
-
interactive
scene
geometry
)
const
PREFER_FAST_TRACE
=
1
<
<
2
;
/
/
/
Optimize
for
fast
build
time
recommended
if
geometry
is
likely
to
change
frequently
/
/
/
(
e
.
g
.
in
a
game
:
player
model
)
.
const
PREFER_FAST_BUILD
=
1
<
<
3
;
/
/
/
Optimize
for
low
memory
footprint
(
both
while
building
and
in
the
output
BLAS
)
.
const
LOW_MEMORY
=
1
<
<
4
;
/
/
/
Use
BlasTriangleGeometry
:
:
transform_buffer
when
building
a
BLAS
(
only
allowed
in
/
/
/
BLAS
creation
)
const
USE_TRANSFORM
=
1
<
<
5
;
/
/
/
Allow
retrieval
of
the
vertices
of
the
triangle
hit
by
a
ray
.
const
ALLOW_RAY_HIT_VERTEX_RETURN
=
1
<
<
6
;
}
)
;
bitflags
:
:
bitflags
!
(
/
/
/
Flags
for
acceleration
structure
geometries
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
transparent
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
pub
struct
AccelerationStructureGeometryFlags
:
u8
{
/
/
/
Is
OPAQUE
(
is
there
no
alpha
test
)
recommended
as
currently
in
naga
there
is
no
/
/
/
candidate
intersections
yet
so
currently
BLASes
without
this
flag
will
not
have
hits
.
/
/
/
Not
enabling
this
makes
the
BLAS
unable
to
be
interacted
with
in
WGSL
.
const
OPAQUE
=
1
<
<
0
;
/
/
/
NO_DUPLICATE_ANY_HIT_INVOCATION
not
useful
unless
using
hal
with
wgpu
ray
-
tracing
/
/
/
pipelines
are
not
supported
in
wgpu
so
any
-
hit
shaders
do
not
exist
.
For
when
any
-
hit
/
/
/
shaders
are
implemented
(
or
experienced
users
who
combine
this
with
an
underlying
library
:
/
/
/
for
any
primitive
(
triangle
or
AABB
)
multiple
any
-
hit
shaders
sometimes
may
be
invoked
/
/
/
(
especially
in
AABBs
like
a
sphere
)
if
this
flag
in
present
only
one
hit
on
a
primitive
may
/
/
/
invoke
an
any
-
hit
shader
.
const
NO_DUPLICATE_ANY_HIT_INVOCATION
=
1
<
<
1
;
}
)
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
/
/
/
What
a
copy
between
acceleration
structures
should
do
pub
enum
AccelerationStructureCopy
{
/
/
/
Directly
duplicate
an
acceleration
structure
to
another
Clone
/
/
/
Duplicate
and
compact
an
acceleration
structure
Compact
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
/
/
/
What
type
the
data
of
an
acceleration
structure
is
pub
enum
AccelerationStructureType
{
/
/
/
The
types
of
the
acceleration
structure
are
triangles
Triangles
/
/
/
The
types
of
the
acceleration
structure
are
axis
aligned
bounding
boxes
AABBs
/
/
/
The
types
of
the
acceleration
structure
are
instances
Instances
}
/
/
/
Alignment
requirement
for
transform
buffers
used
in
acceleration
structure
builds
pub
const
TRANSFORM_BUFFER_ALIGNMENT
:
BufferAddress
=
16
;
/
/
/
Alignment
requirement
for
instance
buffers
used
in
acceleration
structure
builds
(
build_acceleration_structures_unsafe_tlas
)
pub
const
INSTANCE_BUFFER_ALIGNMENT
:
BufferAddress
=
16
;
pub
use
send_sync
:
:
*
;
#
[
doc
(
hidden
)
]
mod
send_sync
{
pub
trait
WasmNotSendSync
:
WasmNotSend
+
WasmNotSync
{
}
impl
<
T
:
WasmNotSend
+
WasmNotSync
>
WasmNotSendSync
for
T
{
}
#
[
cfg
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
]
pub
trait
WasmNotSend
:
Send
{
}
#
[
cfg
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
]
impl
<
T
:
Send
>
WasmNotSend
for
T
{
}
#
[
cfg
(
not
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
)
]
pub
trait
WasmNotSend
{
}
#
[
cfg
(
not
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
)
]
impl
<
T
>
WasmNotSend
for
T
{
}
#
[
cfg
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
]
pub
trait
WasmNotSync
:
Sync
{
}
#
[
cfg
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
]
impl
<
T
:
Sync
>
WasmNotSync
for
T
{
}
#
[
cfg
(
not
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
)
]
pub
trait
WasmNotSync
{
}
#
[
cfg
(
not
(
any
(
not
(
target_arch
=
"
wasm32
"
)
all
(
feature
=
"
fragile
-
send
-
sync
-
non
-
atomic
-
wasm
"
not
(
target_feature
=
"
atomics
"
)
)
)
)
)
]
impl
<
T
>
WasmNotSync
for
T
{
}
}
/
/
/
Corresponds
to
a
[
GPUDeviceLostReason
]
.
/
/
/
/
/
/
[
GPUDeviceLostReason
]
:
https
:
/
/
www
.
w3
.
org
/
TR
/
webgpu
/
#
enumdef
-
gpudevicelostreason
#
[
repr
(
u8
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
DeviceLostReason
{
/
/
/
The
device
was
lost
for
an
unspecific
reason
including
driver
errors
.
Unknown
=
0
/
/
/
The
device
'
s
destroy
method
was
called
.
Destroyed
=
1
}
/
/
/
Descriptor
for
creating
a
shader
module
.
/
/
/
/
/
/
This
type
is
unique
to
the
Rust
API
of
wgpu
.
In
the
WebGPU
specification
/
/
/
only
WGSL
source
code
strings
are
accepted
.
#
[
derive
(
Debug
Clone
)
]
pub
enum
CreateShaderModuleDescriptorPassthrough
<
'
a
L
>
{
/
/
/
Passthrough
for
SPIR
-
V
binaries
.
SpirV
(
ShaderModuleDescriptorSpirV
<
'
a
L
>
)
/
/
/
Passthrough
for
MSL
source
code
.
Msl
(
ShaderModuleDescriptorMsl
<
'
a
L
>
)
/
/
/
Passthrough
for
DXIL
compiled
with
DXC
Dxil
(
ShaderModuleDescriptorDxil
<
'
a
L
>
)
/
/
/
Passthrough
for
HLSL
Hlsl
(
ShaderModuleDescriptorHlsl
<
'
a
L
>
)
}
impl
<
'
a
L
>
CreateShaderModuleDescriptorPassthrough
<
'
a
L
>
{
/
/
/
Takes
a
closure
and
maps
the
label
of
the
shader
module
descriptor
into
another
.
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CreateShaderModuleDescriptorPassthrough
<
'
_
K
>
{
match
self
{
CreateShaderModuleDescriptorPassthrough
:
:
SpirV
(
inner
)
=
>
{
CreateShaderModuleDescriptorPassthrough
:
:
<
'
_
K
>
:
:
SpirV
(
ShaderModuleDescriptorSpirV
{
label
:
fun
(
&
inner
.
label
)
source
:
inner
.
source
.
clone
(
)
}
)
}
CreateShaderModuleDescriptorPassthrough
:
:
Msl
(
inner
)
=
>
{
CreateShaderModuleDescriptorPassthrough
:
:
<
'
_
K
>
:
:
Msl
(
ShaderModuleDescriptorMsl
{
entry_point
:
inner
.
entry_point
.
clone
(
)
label
:
fun
(
&
inner
.
label
)
num_workgroups
:
inner
.
num_workgroups
source
:
inner
.
source
.
clone
(
)
}
)
}
CreateShaderModuleDescriptorPassthrough
:
:
Dxil
(
inner
)
=
>
{
CreateShaderModuleDescriptorPassthrough
:
:
<
'
_
K
>
:
:
Dxil
(
ShaderModuleDescriptorDxil
{
entry_point
:
inner
.
entry_point
.
clone
(
)
label
:
fun
(
&
inner
.
label
)
num_workgroups
:
inner
.
num_workgroups
source
:
inner
.
source
}
)
}
CreateShaderModuleDescriptorPassthrough
:
:
Hlsl
(
inner
)
=
>
{
CreateShaderModuleDescriptorPassthrough
:
:
<
'
_
K
>
:
:
Hlsl
(
ShaderModuleDescriptorHlsl
{
entry_point
:
inner
.
entry_point
.
clone
(
)
label
:
fun
(
&
inner
.
label
)
num_workgroups
:
inner
.
num_workgroups
source
:
inner
.
source
}
)
}
}
}
/
/
/
Returns
the
label
of
shader
module
passthrough
descriptor
.
pub
fn
label
(
&
'
a
self
)
-
>
&
'
a
L
{
match
self
{
CreateShaderModuleDescriptorPassthrough
:
:
SpirV
(
inner
)
=
>
&
inner
.
label
CreateShaderModuleDescriptorPassthrough
:
:
Msl
(
inner
)
=
>
&
inner
.
label
CreateShaderModuleDescriptorPassthrough
:
:
Dxil
(
inner
)
=
>
&
inner
.
label
CreateShaderModuleDescriptorPassthrough
:
:
Hlsl
(
inner
)
=
>
&
inner
.
label
}
}
#
[
cfg
(
feature
=
"
trace
"
)
]
/
/
/
Returns
the
source
data
for
tracing
purpose
.
pub
fn
trace_data
(
&
self
)
-
>
&
[
u8
]
{
match
self
{
CreateShaderModuleDescriptorPassthrough
:
:
SpirV
(
inner
)
=
>
{
bytemuck
:
:
cast_slice
(
&
inner
.
source
)
}
CreateShaderModuleDescriptorPassthrough
:
:
Msl
(
inner
)
=
>
inner
.
source
.
as_bytes
(
)
CreateShaderModuleDescriptorPassthrough
:
:
Dxil
(
inner
)
=
>
inner
.
source
CreateShaderModuleDescriptorPassthrough
:
:
Hlsl
(
inner
)
=
>
inner
.
source
.
as_bytes
(
)
}
}
#
[
cfg
(
feature
=
"
trace
"
)
]
/
/
/
Returns
the
binary
file
extension
for
tracing
purpose
.
pub
fn
trace_binary_ext
(
&
self
)
-
>
&
'
static
str
{
match
self
{
CreateShaderModuleDescriptorPassthrough
:
:
SpirV
(
.
.
)
=
>
"
spv
"
CreateShaderModuleDescriptorPassthrough
:
:
Msl
(
.
.
)
=
>
"
msl
"
CreateShaderModuleDescriptorPassthrough
:
:
Dxil
(
.
.
)
=
>
"
dxil
"
CreateShaderModuleDescriptorPassthrough
:
:
Hlsl
(
.
.
)
=
>
"
hlsl
"
}
}
}
/
/
/
Descriptor
for
a
shader
module
given
by
Metal
MSL
source
.
/
/
/
/
/
/
This
type
is
unique
to
the
Rust
API
of
wgpu
.
In
the
WebGPU
specification
/
/
/
only
WGSL
source
code
strings
are
accepted
.
#
[
derive
(
Debug
Clone
)
]
pub
struct
ShaderModuleDescriptorMsl
<
'
a
L
>
{
/
/
/
Entrypoint
.
pub
entry_point
:
String
/
/
/
Debug
label
of
the
shader
module
.
This
will
show
up
in
graphics
debuggers
for
easy
identification
.
pub
label
:
L
/
/
/
Number
of
workgroups
in
each
dimension
x
y
and
z
.
pub
num_workgroups
:
(
u32
u32
u32
)
/
/
/
Shader
MSL
source
.
pub
source
:
Cow
<
'
a
str
>
}
/
/
/
Descriptor
for
a
shader
module
given
by
DirectX
DXIL
source
.
/
/
/
/
/
/
This
type
is
unique
to
the
Rust
API
of
wgpu
.
In
the
WebGPU
specification
/
/
/
only
WGSL
source
code
strings
are
accepted
.
#
[
derive
(
Debug
Clone
)
]
pub
struct
ShaderModuleDescriptorDxil
<
'
a
L
>
{
/
/
/
Entrypoint
.
pub
entry_point
:
String
/
/
/
Debug
label
of
the
shader
module
.
This
will
show
up
in
graphics
debuggers
for
easy
identification
.
pub
label
:
L
/
/
/
Number
of
workgroups
in
each
dimension
x
y
and
z
.
pub
num_workgroups
:
(
u32
u32
u32
)
/
/
/
Shader
DXIL
source
.
pub
source
:
&
'
a
[
u8
]
}
/
/
/
Descriptor
for
a
shader
module
given
by
DirectX
HLSL
source
.
/
/
/
/
/
/
This
type
is
unique
to
the
Rust
API
of
wgpu
.
In
the
WebGPU
specification
/
/
/
only
WGSL
source
code
strings
are
accepted
.
#
[
derive
(
Debug
Clone
)
]
pub
struct
ShaderModuleDescriptorHlsl
<
'
a
L
>
{
/
/
/
Entrypoint
.
pub
entry_point
:
String
/
/
/
Debug
label
of
the
shader
module
.
This
will
show
up
in
graphics
debuggers
for
easy
identification
.
pub
label
:
L
/
/
/
Number
of
workgroups
in
each
dimension
x
y
and
z
.
pub
num_workgroups
:
(
u32
u32
u32
)
/
/
/
Shader
HLSL
source
.
pub
source
:
&
'
a
str
}
/
/
/
Descriptor
for
a
shader
module
given
by
SPIR
-
V
binary
.
/
/
/
/
/
/
This
type
is
unique
to
the
Rust
API
of
wgpu
.
In
the
WebGPU
specification
/
/
/
only
WGSL
source
code
strings
are
accepted
.
#
[
derive
(
Debug
Clone
)
]
pub
struct
ShaderModuleDescriptorSpirV
<
'
a
L
>
{
/
/
/
Debug
label
of
the
shader
module
.
This
will
show
up
in
graphics
debuggers
for
easy
identification
.
pub
label
:
L
/
/
/
Binary
SPIR
-
V
data
in
4
-
byte
words
.
pub
source
:
Cow
<
'
a
[
u32
]
>
}
