#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
doc_auto_cfg
)
)
]
#
!
[
allow
(
clippy
:
:
match_like_matches_macro
)
]
#
!
[
warn
(
missing_docs
unsafe_op_in_unsafe_fn
)
]
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
{
num
:
:
NonZeroU32
ops
:
:
Range
}
;
pub
mod
assertions
;
pub
mod
math
;
macro_rules
!
impl_bitflags
{
(
name
:
ident
)
=
>
{
#
[
cfg
(
feature
=
"
trace
"
)
]
impl
serde
:
:
Serialize
for
name
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
self
.
bits
(
)
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
replay
"
)
]
impl
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
for
name
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
name
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
let
value
=
<
_
as
serde
:
:
Deserialize
<
'
de
>
>
:
:
deserialize
(
deserializer
)
?
;
Ok
(
name
:
:
from_bits_retain
(
value
)
)
}
}
impl
name
{
/
/
/
Returns
true
if
the
bitflags
contains
bits
that
are
not
part
of
/
/
/
the
bitflags
definition
.
pub
fn
contains_invalid_bits
(
&
self
)
-
>
bool
{
let
all
=
Self
:
:
all
(
)
.
bits
(
)
;
(
self
.
bits
(
)
|
all
)
!
=
all
}
}
}
;
}
pub
type
BufferAddress
=
u64
;
pub
type
BufferSize
=
std
:
:
num
:
:
NonZeroU64
;
pub
type
ShaderLocation
=
u32
;
pub
type
DynamicOffset
=
u32
;
pub
const
COPY_BYTES_PER_ROW_ALIGNMENT
:
u32
=
256
;
pub
const
QUERY_RESOLVE_BUFFER_ALIGNMENT
:
BufferAddress
=
256
;
pub
const
COPY_BUFFER_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
MAP_ALIGNMENT
:
BufferAddress
=
8
;
pub
const
VERTEX_STRIDE_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
PUSH_CONSTANT_ALIGNMENT
:
u32
=
4
;
pub
const
QUERY_SET_MAX_QUERIES
:
u32
=
8192
;
pub
const
QUERY_SIZE
:
u32
=
8
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Backend
{
Empty
=
0
Vulkan
=
1
Metal
=
2
Dx12
=
3
Dx11
=
4
Gl
=
5
BrowserWebGpu
=
6
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PowerPreference
{
#
[
default
]
LowPower
=
0
HighPerformance
=
1
}
bitflags
:
:
bitflags
!
{
/
/
/
Represents
the
backends
that
wgpu
will
use
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
Backends
:
u32
{
/
/
/
Supported
on
Windows
Linux
/
Android
and
macOS
/
iOS
via
Vulkan
Portability
(
with
the
Vulkan
feature
enabled
)
const
VULKAN
=
1
<
<
Backend
:
:
Vulkan
as
u32
;
/
/
/
Supported
on
Linux
/
Android
the
web
through
webassembly
via
WebGL
and
Windows
and
/
/
/
macOS
/
iOS
via
ANGLE
const
GL
=
1
<
<
Backend
:
:
Gl
as
u32
;
/
/
/
Supported
on
macOS
/
iOS
const
METAL
=
1
<
<
Backend
:
:
Metal
as
u32
;
/
/
/
Supported
on
Windows
10
const
DX12
=
1
<
<
Backend
:
:
Dx12
as
u32
;
/
/
/
Supported
on
Windows
7
+
const
DX11
=
1
<
<
Backend
:
:
Dx11
as
u32
;
/
/
/
Supported
when
targeting
the
web
through
webassembly
const
BROWSER_WEBGPU
=
1
<
<
Backend
:
:
BrowserWebGpu
as
u32
;
/
/
/
All
the
apis
that
wgpu
offers
first
tier
of
support
for
.
/
/
/
/
/
/
Vulkan
+
Metal
+
DX12
+
Browser
WebGPU
const
PRIMARY
=
Self
:
:
VULKAN
.
bits
(
)
|
Self
:
:
METAL
.
bits
(
)
|
Self
:
:
DX12
.
bits
(
)
|
Self
:
:
BROWSER_WEBGPU
.
bits
(
)
;
/
/
/
All
the
apis
that
wgpu
offers
second
tier
of
support
for
.
These
may
/
/
/
be
unsupported
/
still
experimental
.
/
/
/
/
/
/
OpenGL
+
DX11
const
SECONDARY
=
Self
:
:
GL
.
bits
(
)
|
Self
:
:
DX11
.
bits
(
)
;
}
}
impl_bitflags
!
(
Backends
)
;
impl
From
<
Backend
>
for
Backends
{
fn
from
(
backend
:
Backend
)
-
>
Self
{
Self
:
:
from_bits
(
1
<
<
backend
as
u32
)
.
unwrap
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RequestAdapterOptions
<
S
>
{
pub
power_preference
:
PowerPreference
pub
force_fallback_adapter
:
bool
pub
compatible_surface
:
Option
<
S
>
}
impl
<
S
>
Default
for
RequestAdapterOptions
<
S
>
{
fn
default
(
)
-
>
Self
{
Self
{
power_preference
:
PowerPreference
:
:
default
(
)
force_fallback_adapter
:
false
compatible_surface
:
None
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Features
that
are
not
guaranteed
to
be
supported
.
/
/
/
/
/
/
These
are
either
part
of
the
webgpu
standard
or
are
extension
features
supported
by
/
/
/
wgpu
when
targeting
native
.
/
/
/
/
/
/
If
you
want
to
use
a
feature
you
need
to
first
verify
that
the
adapter
supports
/
/
/
the
feature
.
If
the
adapter
does
not
support
the
feature
requesting
a
device
with
it
enabled
/
/
/
will
panic
.
/
/
/
/
/
/
Corresponds
to
[
WebGPU
GPUFeatureName
]
(
/
/
/
https
:
/
/
gpuweb
.
github
.
io
/
gpuweb
/
#
enumdef
-
gpufeaturename
)
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Default
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
Features
:
u64
{
/
/
/
/
-
-
-
-
Start
numbering
at
1
<
<
0
-
-
-
-
/
/
/
/
WebGPU
features
:
/
/
/
/
API
:
/
/
/
By
default
polygon
depth
is
clipped
to
0
-
1
range
before
/
during
rasterization
.
/
/
/
Anything
outside
of
that
range
is
rejected
and
respective
fragments
are
not
touched
.
/
/
/
/
/
/
With
this
extension
we
can
disabling
clipping
.
That
allows
/
/
/
shadow
map
occluders
to
be
rendered
into
a
tighter
depth
range
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
desktops
/
/
/
-
some
mobile
chips
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
DEPTH_CLIP_CONTROL
=
1
<
<
0
;
/
/
/
Enables
use
of
Timestamp
Queries
.
These
queries
tell
the
current
gpu
timestamp
when
/
/
/
all
work
before
the
query
is
finished
.
Call
[
CommandEncoder
:
:
write_timestamp
]
/
/
/
[
RenderPassEncoder
:
:
write_timestamp
]
or
[
ComputePassEncoder
:
:
write_timestamp
]
to
/
/
/
write
out
a
timestamp
.
/
/
/
/
/
/
They
must
be
resolved
using
[
CommandEncoder
:
:
resolve_query_sets
]
into
a
buffer
/
/
/
then
the
result
must
be
multiplied
by
the
timestamp
period
[
Queue
:
:
get_timestamp_period
]
/
/
/
to
get
the
timestamp
in
nanoseconds
.
Multiple
timestamps
can
then
be
diffed
to
get
the
/
/
/
time
for
operations
between
them
to
finish
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
/
/
/
This
is
currently
unimplemented
on
Metal
.
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TIMESTAMP_QUERY
=
1
<
<
1
;
/
/
/
Allows
non
-
zero
value
for
the
"
first
instance
"
in
indirect
draw
calls
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
(
mostly
)
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
INDIRECT_FIRST_INSTANCE
=
1
<
<
2
;
/
/
3
.
.
8
available
/
/
Shader
:
/
/
/
Allows
shaders
to
acquire
the
FP16
ability
/
/
/
/
/
/
Note
:
this
is
not
supported
in
naga
yet
only
through
spirv
-
passthrough
right
now
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
SHADER_F16
=
1
<
<
8
;
/
/
9
.
.
14
available
/
/
Texture
Formats
:
/
/
The
features
starting
with
a
?
are
features
that
might
become
part
of
the
spec
or
/
/
at
the
very
least
we
can
implement
as
native
features
;
since
they
should
cover
all
/
/
possible
formats
and
capabilities
across
backends
.
/
/
/
/
?
const
FORMATS_TIER_1
=
1
<
<
14
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3837
)
/
/
?
const
RW_STORAGE_TEXTURE_TIER_1
=
1
<
<
15
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3838
)
/
/
TODO
const
BGRA8UNORM_STORAGE
=
1
<
<
16
;
/
/
?
const
NORM16_FILTERABLE
=
1
<
<
17
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3839
)
/
/
?
const
NORM16_RESOLVE
=
1
<
<
18
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3839
)
/
/
TODO
const
FLOAT32_FILTERABLE
=
1
<
<
19
;
/
/
?
const
FLOAT32_BLENDABLE
=
1
<
<
20
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3556
)
/
/
?
const
32BIT_FORMAT_MULTISAMPLE
=
1
<
<
21
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3844
)
/
/
?
const
32BIT_FORMAT_RESOLVE
=
1
<
<
22
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3844
)
/
/
/
Allows
for
usage
of
textures
of
format
[
TextureFormat
:
:
Rg11b10Float
]
as
a
render
target
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
RG11B10UFLOAT_RENDERABLE
=
1
<
<
23
;
/
/
/
Allows
for
explicit
creation
of
textures
of
format
[
TextureFormat
:
:
Depth32FloatStencil8
]
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
(
mostly
)
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
DEPTH32FLOAT_STENCIL8
=
1
<
<
24
;
/
/
/
Enables
BCn
family
of
compressed
textures
.
All
BCn
textures
use
4x4
pixel
blocks
/
/
/
with
8
or
16
bytes
per
block
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
BCn
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
desktops
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TEXTURE_COMPRESSION_BC
=
1
<
<
25
;
/
/
/
Enables
ETC
family
of
compressed
textures
.
All
ETC
textures
use
4x4
pixel
blocks
.
/
/
/
ETC2
RGB
and
RGBA1
are
8
bytes
per
block
.
RTC2
RGBA8
and
EAC
are
16
bytes
per
block
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
ETC2
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
on
Intel
/
/
/
-
Mobile
(
some
)
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TEXTURE_COMPRESSION_ETC2
=
1
<
<
26
;
/
/
/
Enables
ASTC
family
of
compressed
textures
.
ASTC
textures
use
pixel
blocks
varying
from
4x4
to
12x12
.
/
/
/
Blocks
are
always
16
bytes
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
ASTC
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
on
Intel
/
/
/
-
Mobile
(
some
)
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TEXTURE_COMPRESSION_ASTC
=
1
<
<
27
;
/
/
?
const
TEXTURE_COMPRESSION_ASTC_HDR
=
1
<
<
28
;
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
issues
/
3856
)
/
/
29
.
.
32
should
be
available
but
are
for
now
occupied
by
native
only
texture
related
features
/
/
TEXTURE_FORMAT_16BIT_NORM
&
TEXTURE_COMPRESSION_ASTC_HDR
will
most
likely
become
web
features
as
well
/
/
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
might
not
be
necessary
if
we
have
all
the
texture
features
implemented
/
/
/
/
-
-
-
-
Restart
Numbering
for
Native
Features
-
-
-
/
/
/
/
Native
Features
:
/
/
/
/
Texture
Formats
:
/
/
/
Enables
normalized
16
-
bit
texture
formats
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
TEXTURE_FORMAT_16BIT_NORM
=
1
<
<
29
;
/
/
/
Enables
ASTC
HDR
family
of
compressed
textures
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
significantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Support
for
this
feature
guarantees
availability
of
[
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
]
for
BCn
formats
.
/
/
/
[
Features
:
:
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
]
may
enable
additional
usages
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Metal
/
/
/
-
Vulkan
/
/
/
-
OpenGL
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
TEXTURE_COMPRESSION_ASTC_HDR
=
1
<
<
30
;
/
/
/
Enables
device
specific
texture
format
features
.
/
/
/
/
/
/
See
TextureFormatFeatures
for
a
listing
of
the
features
in
question
.
/
/
/
/
/
/
By
default
only
texture
format
properties
as
defined
by
the
WebGPU
specification
are
allowed
.
/
/
/
Enabling
this
feature
flag
extends
the
features
of
each
format
to
the
ones
supported
by
the
current
device
.
/
/
/
Note
that
without
this
flag
read
/
write
storage
access
is
not
allowed
at
all
.
/
/
/
/
/
/
This
extension
does
not
enable
additional
formats
.
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
=
1
<
<
31
;
/
/
API
:
/
/
/
Enables
use
of
Pipeline
Statistics
Queries
.
These
queries
tell
the
count
of
various
operations
/
/
/
performed
between
the
start
and
stop
call
.
Call
[
RenderPassEncoder
:
:
begin_pipeline_statistics_query
]
to
start
/
/
/
a
query
then
call
[
RenderPassEncoder
:
:
end_pipeline_statistics_query
]
to
stop
one
.
/
/
/
/
/
/
They
must
be
resolved
using
[
CommandEncoder
:
:
resolve_query_sets
]
into
a
buffer
.
/
/
/
The
rules
on
how
these
resolve
into
buffers
are
detailed
in
the
documentation
for
[
PipelineStatisticsTypes
]
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
/
/
/
This
is
a
native
only
feature
with
a
[
proposal
]
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
blob
/
0008bd30da2366af88180b511a5d0d0c1dffbc36
/
proposals
/
pipeline
-
statistics
-
query
.
md
)
for
the
web
.
const
PIPELINE_STATISTICS_QUERY
=
1
<
<
32
;
/
/
/
Allows
for
timestamp
queries
inside
render
passes
.
/
/
/
/
/
/
Implies
[
Features
:
:
TIMESTAMP_QUERY
]
is
supported
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
/
/
/
This
is
currently
unimplemented
on
Metal
.
/
/
/
When
implemented
it
will
be
supported
on
Metal
on
AMD
and
Intel
GPUs
but
not
Apple
GPUs
.
/
/
/
/
/
/
This
is
a
native
only
feature
with
a
[
proposal
]
(
https
:
/
/
github
.
com
/
gpuweb
/
gpuweb
/
blob
/
0008bd30da2366af88180b511a5d0d0c1dffbc36
/
proposals
/
timestamp
-
query
-
inside
-
passes
.
md
)
for
the
web
.
const
TIMESTAMP_QUERY_INSIDE_PASSES
=
1
<
<
33
;
/
/
/
Webgpu
only
allows
the
MAP_READ
and
MAP_WRITE
buffer
usage
to
be
matched
with
/
/
/
COPY_DST
and
COPY_SRC
respectively
.
This
removes
this
requirement
.
/
/
/
/
/
/
This
is
only
beneficial
on
systems
that
share
memory
between
CPU
and
GPU
.
If
enabled
/
/
/
on
a
system
that
doesn
'
t
this
can
severely
hinder
performance
.
Only
use
if
you
understand
/
/
/
the
consequences
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MAPPABLE_PRIMARY_BUFFERS
=
1
<
<
34
;
/
/
/
Allows
the
user
to
create
uniform
arrays
of
textures
in
shaders
:
/
/
/
/
/
/
ex
.
/
/
/
-
var
textures
:
binding_array
<
texture_2d
<
f32
>
10
>
(
WGSL
)
/
/
/
-
uniform
texture2D
textures
[
10
]
(
GLSL
)
/
/
/
/
/
/
If
[
Features
:
:
STORAGE_RESOURCE_BINDING_ARRAY
]
is
supported
as
well
as
this
the
user
/
/
/
may
also
create
uniform
arrays
of
storage
textures
.
/
/
/
/
/
/
ex
.
/
/
/
-
var
textures
:
array
<
texture_storage_2d
<
f32
write
>
10
>
(
WGSL
)
/
/
/
-
uniform
image2D
textures
[
10
]
(
GLSL
)
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
dynamically
uniform
/
/
/
values
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
TEXTURE_BINDING_ARRAY
=
1
<
<
35
;
/
/
/
Allows
the
user
to
create
arrays
of
buffers
in
shaders
:
/
/
/
/
/
/
ex
.
/
/
/
-
var
<
uniform
>
buffer_array
:
array
<
MyBuffer
10
>
(
WGSL
)
/
/
/
-
uniform
myBuffer
{
.
.
.
}
buffer_array
[
10
]
(
GLSL
)
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
dynamically
uniform
/
/
/
values
.
/
/
/
/
/
/
If
[
Features
:
:
STORAGE_RESOURCE_BINDING_ARRAY
]
is
supported
as
well
as
this
the
user
/
/
/
may
also
create
arrays
of
storage
buffers
.
/
/
/
/
/
/
ex
.
/
/
/
-
var
<
storage
>
buffer_array
:
array
<
MyBuffer
10
>
(
WGSL
)
/
/
/
-
buffer
myBuffer
{
.
.
.
}
buffer_array
[
10
]
(
GLSL
)
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
BUFFER_BINDING_ARRAY
=
1
<
<
36
;
/
/
/
Allows
the
user
to
create
uniform
arrays
of
storage
buffers
or
textures
in
shaders
/
/
/
if
resp
.
[
Features
:
:
BUFFER_BINDING_ARRAY
]
or
[
Features
:
:
TEXTURE_BINDING_ARRAY
]
/
/
/
is
supported
.
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
dynamically
uniform
/
/
/
values
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Metal
(
with
MSL
2
.
2
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
STORAGE_RESOURCE_BINDING_ARRAY
=
1
<
<
37
;
/
/
/
Allows
shaders
to
index
sampled
texture
and
storage
buffer
resource
arrays
with
dynamically
non
-
uniform
values
:
/
/
/
/
/
/
ex
.
texture_array
[
vertex_data
]
/
/
/
/
/
/
In
order
to
use
this
capability
the
corresponding
GLSL
extension
must
be
enabled
like
so
:
/
/
/
/
/
/
#
extension
GL_EXT_nonuniform_qualifier
:
require
/
/
/
/
/
/
and
then
used
either
as
nonuniformEXT
qualifier
in
variable
declaration
:
/
/
/
/
/
/
ex
.
layout
(
location
=
0
)
nonuniformEXT
flat
in
int
vertex_data
;
/
/
/
/
/
/
or
as
nonuniformEXT
constructor
:
/
/
/
/
/
/
ex
.
texture_array
[
nonuniformEXT
(
vertex_data
)
]
/
/
/
/
/
/
WGSL
and
HLSL
do
not
need
any
extension
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
shaderSampledImageArrayNonUniformIndexing
&
shaderStorageBufferArrayNonUniformIndexing
feature
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING
=
1
<
<
38
;
/
/
/
Allows
shaders
to
index
uniform
buffer
and
storage
texture
resource
arrays
with
dynamically
non
-
uniform
values
:
/
/
/
/
/
/
ex
.
texture_array
[
vertex_data
]
/
/
/
/
/
/
In
order
to
use
this
capability
the
corresponding
GLSL
extension
must
be
enabled
like
so
:
/
/
/
/
/
/
#
extension
GL_EXT_nonuniform_qualifier
:
require
/
/
/
/
/
/
and
then
used
either
as
nonuniformEXT
qualifier
in
variable
declaration
:
/
/
/
/
/
/
ex
.
layout
(
location
=
0
)
nonuniformEXT
flat
in
int
vertex_data
;
/
/
/
/
/
/
or
as
nonuniformEXT
constructor
:
/
/
/
/
/
/
ex
.
texture_array
[
nonuniformEXT
(
vertex_data
)
]
/
/
/
/
/
/
WGSL
and
HLSL
do
not
need
any
extension
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
shaderUniformBufferArrayNonUniformIndexing
&
shaderStorageTextureArrayNonUniformIndexing
feature
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
UNIFORM_BUFFER_AND_STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING
=
1
<
<
39
;
/
/
/
Allows
the
user
to
create
bind
groups
continaing
arrays
with
less
bindings
than
the
BindGroupLayout
.
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
PARTIALLY_BOUND_BINDING_ARRAY
=
1
<
<
40
;
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
multi_draw_indirect
]
and
[
RenderPass
:
:
multi_draw_indexed_indirect
]
.
/
/
/
/
/
/
Allows
multiple
indirect
calls
to
be
dispatched
from
a
single
buffer
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
(
Emulated
on
top
of
draw_indirect
and
draw_indexed_indirect
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
/
/
/
/
/
/
[
RenderPass
:
:
multi_draw_indirect
]
:
.
.
/
wgpu
/
struct
.
RenderPass
.
html
#
method
.
multi_draw_indirect
/
/
/
[
RenderPass
:
:
multi_draw_indexed_indirect
]
:
.
.
/
wgpu
/
struct
.
RenderPass
.
html
#
method
.
multi_draw_indexed_indirect
const
MULTI_DRAW_INDIRECT
=
1
<
<
41
;
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
multi_draw_indirect_count
]
and
[
RenderPass
:
:
multi_draw_indexed_indirect_count
]
.
/
/
/
/
/
/
This
allows
the
use
of
a
buffer
containing
the
actual
number
of
draw
calls
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_KHR_draw_indirect_count
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
/
/
/
/
/
/
[
RenderPass
:
:
multi_draw_indirect_count
]
:
.
.
/
wgpu
/
struct
.
RenderPass
.
html
#
method
.
multi_draw_indirect_count
/
/
/
[
RenderPass
:
:
multi_draw_indexed_indirect_count
]
:
.
.
/
wgpu
/
struct
.
RenderPass
.
html
#
method
.
multi_draw_indexed_indirect_count
const
MULTI_DRAW_INDIRECT_COUNT
=
1
<
<
42
;
/
/
/
Allows
the
use
of
push
constants
:
small
fast
bits
of
memory
that
can
be
updated
/
/
/
inside
a
[
RenderPass
]
.
/
/
/
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
set_push_constants
]
provide
a
non
-
empty
array
/
/
/
to
[
PipelineLayoutDescriptor
]
and
provide
a
non
-
zero
limit
to
[
Limits
:
:
max_push_constant_size
]
.
/
/
/
/
/
/
A
block
of
push
constants
can
be
declared
with
layout
(
push_constant
)
uniform
Name
{
.
.
}
in
shaders
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
-
DX11
(
emulated
with
uniforms
)
/
/
/
-
OpenGL
(
emulated
with
uniforms
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
/
/
/
/
/
/
[
RenderPass
]
:
.
.
/
wgpu
/
struct
.
RenderPass
.
html
/
/
/
[
PipelineLayoutDescriptor
]
:
.
.
/
wgpu
/
struct
.
PipelineLayoutDescriptor
.
html
/
/
/
[
RenderPass
:
:
set_push_constants
]
:
.
.
/
wgpu
/
struct
.
RenderPass
.
html
#
method
.
set_push_constants
const
PUSH_CONSTANTS
=
1
<
<
43
;
/
/
/
Allows
the
use
of
[
AddressMode
:
:
ClampToBorder
]
with
a
border
color
/
/
/
of
[
SamplerBorderColor
:
:
Zero
]
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
-
DX11
/
/
/
-
OpenGL
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
ADDRESS_MODE_CLAMP_TO_ZERO
=
1
<
<
44
;
/
/
/
Allows
the
use
of
[
AddressMode
:
:
ClampToBorder
]
with
a
border
color
/
/
/
other
than
[
SamplerBorderColor
:
:
Zero
]
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
(
macOS
10
.
12
+
only
)
/
/
/
-
DX11
/
/
/
-
OpenGL
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
ADDRESS_MODE_CLAMP_TO_BORDER
=
1
<
<
45
;
/
/
/
Allows
the
user
to
set
[
PolygonMode
:
:
Line
]
in
[
PrimitiveState
:
:
polygon_mode
]
/
/
/
/
/
/
This
allows
drawing
polygons
/
triangles
as
lines
(
wireframe
)
instead
of
filled
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
POLYGON_MODE_LINE
=
1
<
<
46
;
/
/
/
Allows
the
user
to
set
[
PolygonMode
:
:
Point
]
in
[
PrimitiveState
:
:
polygon_mode
]
/
/
/
/
/
/
This
allows
only
drawing
the
vertices
of
polygons
/
triangles
instead
of
filled
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
POLYGON_MODE_POINT
=
1
<
<
47
;
/
/
/
Allows
the
user
to
set
a
overestimation
-
conservative
-
rasterization
in
[
PrimitiveState
:
:
conservative
]
/
/
/
/
/
/
Processing
of
degenerate
triangles
/
lines
is
hardware
specific
.
/
/
/
Only
triangles
are
supported
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
CONSERVATIVE_RASTERIZATION
=
1
<
<
48
;
/
/
/
Enables
bindings
of
writable
storage
buffers
and
textures
visible
to
vertex
shaders
.
/
/
/
/
/
/
Note
:
some
(
tiled
-
based
)
platforms
do
not
support
vertex
shaders
with
any
side
-
effects
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
All
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
VERTEX_WRITABLE_STORAGE
=
1
<
<
49
;
/
/
/
Enables
clear
to
zero
for
textures
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
All
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
CLEAR_TEXTURE
=
1
<
<
50
;
/
/
/
Enables
creating
shader
modules
from
SPIR
-
V
binary
data
(
unsafe
)
.
/
/
/
/
/
/
SPIR
-
V
data
is
not
parsed
or
interpreted
in
any
way
;
you
can
use
/
/
/
[
wgpu
:
:
make_spirv_raw
!
]
to
check
for
alignment
and
magic
number
when
converting
from
/
/
/
raw
bytes
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
in
case
shader
'
s
requested
capabilities
and
extensions
agree
with
/
/
/
Vulkan
implementation
.
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SPIRV_SHADER_PASSTHROUGH
=
1
<
<
51
;
/
/
/
Enables
multiview
render
passes
and
builtin
(
view_index
)
in
vertex
shaders
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
-
OpenGL
(
web
only
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MULTIVIEW
=
1
<
<
52
;
/
/
/
Enables
using
64
-
bit
types
for
vertex
attributes
.
/
/
/
/
/
/
Requires
SHADER_FLOAT64
.
/
/
/
/
/
/
Supported
Platforms
:
N
/
A
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
VERTEX_ATTRIBUTE_64BIT
=
1
<
<
53
;
/
/
54
.
.
59
available
/
/
Shader
:
/
/
/
Enables
64
-
bit
floating
point
types
in
SPIR
-
V
shaders
.
/
/
/
/
/
/
Note
:
even
when
supported
by
GPU
hardware
64
-
bit
floating
point
operations
are
/
/
/
frequently
between
16
and
64
_times_
slower
than
equivalent
operations
on
32
-
bit
floats
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SHADER_F64
=
1
<
<
59
;
/
/
/
Allows
shaders
to
use
i16
.
Not
currently
supported
in
naga
only
available
through
spirv
-
passthrough
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SHADER_I16
=
1
<
<
60
;
/
/
/
Enables
builtin
(
primitive_index
)
in
fragment
shaders
.
/
/
/
/
/
/
Note
:
enables
geometry
processing
for
pipelines
using
the
builtin
.
/
/
/
This
may
come
with
a
significant
performance
impact
on
some
hardware
.
/
/
/
Other
pipelines
are
not
affected
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
Vulkan
/
/
/
-
DX11
(
feature
level
10
+
)
/
/
/
-
DX12
/
/
/
-
Metal
(
some
)
/
/
/
-
OpenGL
(
some
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SHADER_PRIMITIVE_INDEX
=
1
<
<
61
;
/
/
/
Allows
shaders
to
use
the
early_depth_test
attribute
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
GLES
3
.
1
+
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SHADER_EARLY_DEPTH_TEST
=
1
<
<
62
;
/
/
62
.
.
64
available
}
}
impl_bitflags
!
(
Features
)
;
impl
Features
{
pub
const
fn
all_webgpu_mask
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
0x0000_0000_0000_FFFF
)
}
pub
const
fn
all_native_mask
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
0xFFFF_FFFF_FFFF_0000
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
default
)
)
]
pub
struct
Limits
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension1D
"
)
)
]
pub
max_texture_dimension_1d
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension2D
"
)
)
]
pub
max_texture_dimension_2d
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
maxTextureDimension3D
"
)
)
]
pub
max_texture_dimension_3d
:
u32
pub
max_texture_array_layers
:
u32
pub
max_bind_groups
:
u32
pub
max_bindings_per_bind_group
:
u32
pub
max_dynamic_uniform_buffers_per_pipeline_layout
:
u32
pub
max_dynamic_storage_buffers_per_pipeline_layout
:
u32
pub
max_sampled_textures_per_shader_stage
:
u32
pub
max_samplers_per_shader_stage
:
u32
pub
max_storage_buffers_per_shader_stage
:
u32
pub
max_storage_textures_per_shader_stage
:
u32
pub
max_uniform_buffers_per_shader_stage
:
u32
pub
max_uniform_buffer_binding_size
:
u32
pub
max_storage_buffer_binding_size
:
u32
pub
max_vertex_buffers
:
u32
pub
max_buffer_size
:
u64
pub
max_vertex_attributes
:
u32
pub
max_vertex_buffer_array_stride
:
u32
pub
min_uniform_buffer_offset_alignment
:
u32
pub
min_storage_buffer_offset_alignment
:
u32
pub
max_inter_stage_shader_components
:
u32
pub
max_compute_workgroup_storage_size
:
u32
pub
max_compute_invocations_per_workgroup
:
u32
pub
max_compute_workgroup_size_x
:
u32
pub
max_compute_workgroup_size_y
:
u32
pub
max_compute_workgroup_size_z
:
u32
pub
max_compute_workgroups_per_dimension
:
u32
pub
max_push_constant_size
:
u32
}
impl
Default
for
Limits
{
fn
default
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
8192
max_texture_dimension_2d
:
8192
max_texture_dimension_3d
:
2048
max_texture_array_layers
:
256
max_bind_groups
:
4
max_bindings_per_bind_group
:
640
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
8
max_storage_textures_per_shader_stage
:
4
max_uniform_buffers_per_shader_stage
:
12
max_uniform_buffer_binding_size
:
64
<
<
10
max_storage_buffer_binding_size
:
128
<
<
20
max_vertex_buffers
:
8
max_buffer_size
:
1
<
<
28
max_vertex_attributes
:
16
max_vertex_buffer_array_stride
:
2048
min_uniform_buffer_offset_alignment
:
256
min_storage_buffer_offset_alignment
:
256
max_inter_stage_shader_components
:
60
max_compute_workgroup_storage_size
:
16384
max_compute_invocations_per_workgroup
:
256
max_compute_workgroup_size_x
:
256
max_compute_workgroup_size_y
:
256
max_compute_workgroup_size_z
:
64
max_compute_workgroups_per_dimension
:
65535
max_push_constant_size
:
0
}
}
}
impl
Limits
{
pub
fn
downlevel_defaults
(
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
2048
max_texture_dimension_2d
:
2048
max_texture_dimension_3d
:
256
max_texture_array_layers
:
256
max_bind_groups
:
4
max_bindings_per_bind_group
:
640
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
4
max_storage_textures_per_shader_stage
:
4
max_uniform_buffers_per_shader_stage
:
12
max_uniform_buffer_binding_size
:
16
<
<
10
max_storage_buffer_binding_size
:
128
<
<
20
max_vertex_buffers
:
8
max_vertex_attributes
:
16
max_vertex_buffer_array_stride
:
2048
max_push_constant_size
:
0
min_uniform_buffer_offset_alignment
:
256
min_storage_buffer_offset_alignment
:
256
max_inter_stage_shader_components
:
60
max_compute_workgroup_storage_size
:
16352
max_compute_invocations_per_workgroup
:
256
max_compute_workgroup_size_x
:
256
max_compute_workgroup_size_y
:
256
max_compute_workgroup_size_z
:
64
max_compute_workgroups_per_dimension
:
65535
max_buffer_size
:
1
<
<
28
}
}
pub
fn
downlevel_webgl2_defaults
(
)
-
>
Self
{
Self
{
max_uniform_buffers_per_shader_stage
:
11
max_storage_buffers_per_shader_stage
:
0
max_storage_textures_per_shader_stage
:
0
max_dynamic_storage_buffers_per_pipeline_layout
:
0
max_storage_buffer_binding_size
:
0
max_vertex_buffer_array_stride
:
255
max_compute_workgroup_storage_size
:
0
max_compute_invocations_per_workgroup
:
0
max_compute_workgroup_size_x
:
0
max_compute_workgroup_size_y
:
0
max_compute_workgroup_size_z
:
0
max_compute_workgroups_per_dimension
:
0
.
.
Self
:
:
downlevel_defaults
(
)
}
}
pub
fn
using_resolution
(
self
other
:
Self
)
-
>
Self
{
Self
{
max_texture_dimension_1d
:
other
.
max_texture_dimension_1d
max_texture_dimension_2d
:
other
.
max_texture_dimension_2d
max_texture_dimension_3d
:
other
.
max_texture_dimension_3d
.
.
self
}
}
pub
fn
using_alignment
(
self
other
:
Self
)
-
>
Self
{
Self
{
min_uniform_buffer_offset_alignment
:
other
.
min_uniform_buffer_offset_alignment
min_storage_buffer_offset_alignment
:
other
.
min_storage_buffer_offset_alignment
.
.
self
}
}
pub
fn
check_limits
(
&
self
allowed
:
&
Self
)
-
>
bool
{
let
mut
within
=
true
;
self
.
check_limits_with_fail_fn
(
allowed
true
|
_
_
_
|
within
=
false
)
;
within
}
pub
fn
check_limits_with_fail_fn
(
&
self
allowed
:
&
Self
fatal
:
bool
mut
fail_fn
:
impl
FnMut
(
&
'
static
str
u64
u64
)
)
{
use
std
:
:
cmp
:
:
Ordering
;
macro_rules
!
compare
{
(
name
:
ident
ordering
:
ident
)
=
>
{
match
self
.
name
.
cmp
(
&
allowed
.
name
)
{
Ordering
:
:
ordering
|
Ordering
:
:
Equal
=
>
(
)
_
=
>
{
fail_fn
(
stringify
!
(
name
)
self
.
name
as
u64
allowed
.
name
as
u64
)
;
if
fatal
{
return
;
}
}
}
}
;
}
compare
!
(
max_texture_dimension_1d
Less
)
;
compare
!
(
max_texture_dimension_2d
Less
)
;
compare
!
(
max_texture_dimension_3d
Less
)
;
compare
!
(
max_texture_array_layers
Less
)
;
compare
!
(
max_bind_groups
Less
)
;
compare
!
(
max_dynamic_uniform_buffers_per_pipeline_layout
Less
)
;
compare
!
(
max_dynamic_storage_buffers_per_pipeline_layout
Less
)
;
compare
!
(
max_sampled_textures_per_shader_stage
Less
)
;
compare
!
(
max_samplers_per_shader_stage
Less
)
;
compare
!
(
max_storage_buffers_per_shader_stage
Less
)
;
compare
!
(
max_storage_textures_per_shader_stage
Less
)
;
compare
!
(
max_uniform_buffers_per_shader_stage
Less
)
;
compare
!
(
max_uniform_buffer_binding_size
Less
)
;
compare
!
(
max_storage_buffer_binding_size
Less
)
;
compare
!
(
max_vertex_buffers
Less
)
;
compare
!
(
max_vertex_attributes
Less
)
;
compare
!
(
max_vertex_buffer_array_stride
Less
)
;
compare
!
(
max_push_constant_size
Less
)
;
compare
!
(
min_uniform_buffer_offset_alignment
Greater
)
;
compare
!
(
min_storage_buffer_offset_alignment
Greater
)
;
compare
!
(
max_inter_stage_shader_components
Less
)
;
compare
!
(
max_compute_workgroup_storage_size
Less
)
;
compare
!
(
max_compute_invocations_per_workgroup
Less
)
;
compare
!
(
max_compute_workgroup_size_x
Less
)
;
compare
!
(
max_compute_workgroup_size_y
Less
)
;
compare
!
(
max_compute_workgroup_size_z
Less
)
;
compare
!
(
max_compute_workgroups_per_dimension
Less
)
;
compare
!
(
max_buffer_size
Less
)
;
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelLimits
{
}
#
[
allow
(
unknown_lints
)
]
#
[
allow
(
clippy
:
:
derivable_impls
)
]
impl
Default
for
DownlevelLimits
{
fn
default
(
)
-
>
Self
{
DownlevelLimits
{
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelCapabilities
{
pub
flags
:
DownlevelFlags
pub
limits
:
DownlevelLimits
pub
shader_model
:
ShaderModel
}
impl
Default
for
DownlevelCapabilities
{
fn
default
(
)
-
>
Self
{
Self
{
flags
:
DownlevelFlags
:
:
all
(
)
limits
:
DownlevelLimits
:
:
default
(
)
shader_model
:
ShaderModel
:
:
Sm5
}
}
}
impl
DownlevelCapabilities
{
pub
fn
is_webgpu_compliant
(
&
self
)
-
>
bool
{
self
.
flags
.
contains
(
DownlevelFlags
:
:
compliant
(
)
)
&
&
self
.
limits
=
=
DownlevelLimits
:
:
default
(
)
&
&
self
.
shader_model
>
=
ShaderModel
:
:
Sm5
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Binary
flags
listing
features
that
may
or
may
not
be
present
on
downlevel
adapters
.
/
/
/
/
/
/
A
downlevel
adapter
is
a
GPU
adapter
that
WGPU
supports
but
with
potentially
limited
/
/
/
features
due
to
the
lack
of
hardware
feature
support
.
/
/
/
/
/
/
Flags
that
are
*
*
not
*
*
present
for
a
downlevel
adapter
or
device
usually
indicates
/
/
/
non
-
compliance
with
the
WebGPU
specification
but
not
always
.
/
/
/
/
/
/
You
can
check
whether
a
set
of
flags
is
compliant
through
the
/
/
/
[
DownlevelCapabilities
:
:
is_webgpu_compliant
(
)
]
function
.
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
DownlevelFlags
:
u32
{
/
/
/
The
device
supports
compiling
and
using
compute
shaders
.
/
/
/
/
/
/
DX11
on
FL10
level
hardware
WebGL2
and
GLES3
.
0
devices
do
not
support
compute
.
const
COMPUTE_SHADERS
=
1
<
<
0
;
/
/
/
Supports
binding
storage
buffers
and
textures
to
fragment
shaders
.
const
FRAGMENT_WRITABLE_STORAGE
=
1
<
<
1
;
/
/
/
Supports
indirect
drawing
and
dispatching
.
/
/
/
/
/
/
DX11
on
FL10
level
hardware
WebGL2
and
GLES
3
.
0
devices
do
not
support
indirect
.
const
INDIRECT_EXECUTION
=
1
<
<
2
;
/
/
/
Supports
non
-
zero
base_vertex
parameter
to
indexed
draw
calls
.
const
BASE_VERTEX
=
1
<
<
3
;
/
/
/
Supports
reading
from
a
depth
/
stencil
buffer
while
using
as
a
read
-
only
depth
/
stencil
/
/
/
attachment
.
/
/
/
/
/
/
The
WebGL2
and
GLES
backends
do
not
support
RODS
.
const
READ_ONLY_DEPTH_STENCIL
=
1
<
<
4
;
/
/
/
Supports
textures
with
mipmaps
which
have
a
non
power
of
two
size
.
const
NON_POWER_OF_TWO_MIPMAPPED_TEXTURES
=
1
<
<
5
;
/
/
/
Supports
textures
that
are
cube
arrays
.
const
CUBE_ARRAY_TEXTURES
=
1
<
<
6
;
/
/
/
Supports
comparison
samplers
.
const
COMPARISON_SAMPLERS
=
1
<
<
7
;
/
/
/
Supports
different
blend
operations
per
color
attachment
.
const
INDEPENDENT_BLEND
=
1
<
<
8
;
/
/
/
Supports
storage
buffers
in
vertex
shaders
.
const
VERTEX_STORAGE
=
1
<
<
9
;
/
/
/
Supports
samplers
with
anisotropic
filtering
.
Note
this
isn
'
t
actually
required
by
/
/
/
WebGPU
the
implementation
is
allowed
to
completely
ignore
aniso
clamp
.
This
flag
is
/
/
/
here
for
native
backends
so
they
can
communicate
to
the
user
of
aniso
is
enabled
.
/
/
/
/
/
/
All
backends
and
all
devices
support
anisotropic
filtering
.
const
ANISOTROPIC_FILTERING
=
1
<
<
10
;
/
/
/
Supports
storage
buffers
in
fragment
shaders
.
const
FRAGMENT_STORAGE
=
1
<
<
11
;
/
/
/
Supports
sample
-
rate
shading
.
const
MULTISAMPLED_SHADING
=
1
<
<
12
;
/
/
/
Supports
copies
between
depth
textures
and
buffers
.
/
/
/
/
/
/
GLES
/
WebGL
don
'
t
support
this
.
const
DEPTH_TEXTURE_AND_BUFFER_COPIES
=
1
<
<
13
;
/
/
/
Supports
all
the
texture
usages
described
in
WebGPU
.
If
this
isn
'
t
supported
you
/
/
/
should
call
get_texture_format_features
to
get
how
you
can
use
textures
of
a
given
format
const
WEBGPU_TEXTURE_FORMAT_SUPPORT
=
1
<
<
14
;
/
/
/
Supports
buffer
bindings
with
sizes
that
aren
'
t
a
multiple
of
16
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
const
BUFFER_BINDINGS_NOT_16_BYTE_ALIGNED
=
1
<
<
15
;
/
/
/
Supports
buffers
to
combine
[
BufferUsages
:
:
INDEX
]
with
usages
other
than
[
BufferUsages
:
:
COPY_DST
]
and
[
BufferUsages
:
:
COPY_SRC
]
.
/
/
/
Furthermore
in
absence
of
this
feature
it
is
not
allowed
to
copy
index
buffers
from
/
to
buffers
with
a
set
of
usage
flags
containing
/
/
/
[
BufferUsages
:
:
VERTEX
]
/
[
BufferUsages
:
:
UNIFORM
]
/
[
BufferUsages
:
:
STORAGE
]
or
[
BufferUsages
:
:
INDIRECT
]
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
const
UNRESTRICTED_INDEX_BUFFER
=
1
<
<
16
;
/
/
/
Supports
full
32
-
bit
range
indices
(
2
^
32
-
1
as
opposed
to
2
^
24
-
1
without
this
flag
)
/
/
/
/
/
/
Corresponds
to
Vulkan
'
s
VkPhysicalDeviceFeatures
.
fullDrawIndexUint32
const
FULL_DRAW_INDEX_UINT32
=
1
<
<
17
;
/
/
/
Supports
depth
bias
clamping
/
/
/
/
/
/
Corresponds
to
Vulkan
'
s
VkPhysicalDeviceFeatures
.
depthBiasClamp
const
DEPTH_BIAS_CLAMP
=
1
<
<
18
;
/
/
/
Supports
specifying
which
view
format
values
are
allowed
when
create_view
(
)
is
called
on
a
texture
.
/
/
/
/
/
/
The
WebGL
and
GLES
backends
doesn
'
t
support
this
.
const
VIEW_FORMATS
=
1
<
<
19
;
/
/
/
With
this
feature
not
present
there
are
the
following
restrictions
on
Queue
:
:
copy_external_image_to_texture
:
/
/
/
-
The
source
must
not
be
[
web_sys
:
:
OffscreenCanvas
]
/
/
/
-
[
ImageCopyExternalImage
:
:
origin
]
must
be
zero
.
/
/
/
-
[
ImageCopyTextureTagged
:
:
color_space
]
must
be
srgb
.
/
/
/
-
If
the
source
is
an
[
web_sys
:
:
ImageBitmap
]
:
/
/
/
-
[
ImageCopyExternalImage
:
:
flip_y
]
must
be
false
.
/
/
/
-
[
ImageCopyTextureTagged
:
:
premultiplied_alpha
]
must
be
false
.
/
/
/
/
/
/
WebGL
doesn
'
t
support
this
.
WebGPU
does
.
const
UNRESTRICTED_EXTERNAL_TEXTURE_COPIES
=
1
<
<
20
;
/
/
/
Supports
specifying
which
view
formats
are
allowed
when
calling
create_view
on
the
texture
returned
by
get_current_texture
.
/
/
/
/
/
/
The
GLES
/
WebGL
and
Vulkan
on
Android
doesn
'
t
support
this
.
const
SURFACE_VIEW_FORMATS
=
1
<
<
21
;
}
}
impl_bitflags
!
(
DownlevelFlags
)
;
impl
DownlevelFlags
{
pub
const
fn
compliant
(
)
-
>
Self
{
Self
:
:
from_bits_truncate
(
Self
:
:
all
(
)
.
bits
(
)
&
!
Self
:
:
ANISOTROPIC_FILTERING
.
bits
(
)
)
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
enum
ShaderModel
{
Sm2
Sm4
Sm5
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
DeviceType
{
Other
IntegratedGpu
DiscreteGpu
VirtualGpu
Cpu
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
AdapterInfo
{
pub
name
:
String
pub
vendor
:
u32
pub
device
:
u32
pub
device_type
:
DeviceType
pub
driver
:
String
pub
driver_info
:
String
pub
backend
:
Backend
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DeviceDescriptor
<
L
>
{
pub
label
:
L
pub
features
:
Features
pub
limits
:
Limits
}
impl
<
L
>
DeviceDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
DeviceDescriptor
<
K
>
{
DeviceDescriptor
{
label
:
fun
(
&
self
.
label
)
features
:
self
.
features
limits
:
self
.
limits
.
clone
(
)
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Describes
the
shader
stages
that
a
binding
will
be
visible
from
.
/
/
/
/
/
/
These
can
be
combined
so
something
that
is
visible
from
both
vertex
and
fragment
shaders
can
be
defined
as
:
/
/
/
/
/
/
ShaderStages
:
:
VERTEX
|
ShaderStages
:
:
FRAGMENT
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
ShaderStages
:
u32
{
/
/
/
Binding
is
not
visible
from
any
shader
stage
.
const
NONE
=
0
;
/
/
/
Binding
is
visible
from
the
vertex
shader
of
a
render
pipeline
.
const
VERTEX
=
1
<
<
0
;
/
/
/
Binding
is
visible
from
the
fragment
shader
of
a
render
pipeline
.
const
FRAGMENT
=
1
<
<
1
;
/
/
/
Binding
is
visible
from
the
compute
shader
of
a
compute
pipeline
.
const
COMPUTE
=
1
<
<
2
;
/
/
/
Binding
is
visible
from
the
vertex
and
fragment
shaders
of
a
render
pipeline
.
const
VERTEX_FRAGMENT
=
Self
:
:
VERTEX
.
bits
(
)
|
Self
:
:
FRAGMENT
.
bits
(
)
;
}
}
impl_bitflags
!
(
ShaderStages
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureViewDimension
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
1d
"
)
)
]
D1
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
"
)
)
]
#
[
default
]
D2
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
-
array
"
)
)
]
D2Array
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
cube
"
)
)
]
Cube
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
cube
-
array
"
)
)
]
CubeArray
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
3d
"
)
)
]
D3
}
impl
TextureViewDimension
{
pub
fn
compatible_texture_dimension
(
self
)
-
>
TextureDimension
{
match
self
{
Self
:
:
D1
=
>
TextureDimension
:
:
D1
Self
:
:
D2
|
Self
:
:
D2Array
|
Self
:
:
Cube
|
Self
:
:
CubeArray
=
>
TextureDimension
:
:
D2
Self
:
:
D3
=
>
TextureDimension
:
:
D3
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
BlendFactor
{
Zero
=
0
One
=
1
Src
=
2
OneMinusSrc
=
3
SrcAlpha
=
4
OneMinusSrcAlpha
=
5
Dst
=
6
OneMinusDst
=
7
DstAlpha
=
8
OneMinusDstAlpha
=
9
SrcAlphaSaturated
=
10
Constant
=
11
OneMinusConstant
=
12
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
BlendOperation
{
#
[
default
]
Add
=
0
Subtract
=
1
ReverseSubtract
=
2
Min
=
3
Max
=
4
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
BlendComponent
{
pub
src_factor
:
BlendFactor
pub
dst_factor
:
BlendFactor
pub
operation
:
BlendOperation
}
impl
BlendComponent
{
pub
const
REPLACE
:
Self
=
Self
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
Zero
operation
:
BlendOperation
:
:
Add
}
;
pub
const
OVER
:
Self
=
Self
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
OneMinusSrcAlpha
operation
:
BlendOperation
:
:
Add
}
;
pub
fn
uses_constant
(
&
self
)
-
>
bool
{
match
(
self
.
src_factor
self
.
dst_factor
)
{
(
BlendFactor
:
:
Constant
_
)
|
(
BlendFactor
:
:
OneMinusConstant
_
)
|
(
_
BlendFactor
:
:
Constant
)
|
(
_
BlendFactor
:
:
OneMinusConstant
)
=
>
true
(
_
_
)
=
>
false
}
}
}
impl
Default
for
BlendComponent
{
fn
default
(
)
-
>
Self
{
Self
:
:
REPLACE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
BlendState
{
pub
color
:
BlendComponent
pub
alpha
:
BlendComponent
}
impl
BlendState
{
pub
const
REPLACE
:
Self
=
Self
{
color
:
BlendComponent
:
:
REPLACE
alpha
:
BlendComponent
:
:
REPLACE
}
;
pub
const
ALPHA_BLENDING
:
Self
=
Self
{
color
:
BlendComponent
{
src_factor
:
BlendFactor
:
:
SrcAlpha
dst_factor
:
BlendFactor
:
:
OneMinusSrcAlpha
operation
:
BlendOperation
:
:
Add
}
alpha
:
BlendComponent
:
:
OVER
}
;
pub
const
PREMULTIPLIED_ALPHA_BLENDING
:
Self
=
Self
{
color
:
BlendComponent
:
:
OVER
alpha
:
BlendComponent
:
:
OVER
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
ColorTargetState
{
pub
format
:
TextureFormat
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
blend
:
Option
<
BlendState
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
write_mask
:
ColorWrites
}
impl
From
<
TextureFormat
>
for
ColorTargetState
{
fn
from
(
format
:
TextureFormat
)
-
>
Self
{
Self
{
format
blend
:
None
write_mask
:
ColorWrites
:
:
ALL
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PrimitiveTopology
{
PointList
=
0
LineList
=
1
LineStrip
=
2
#
[
default
]
TriangleList
=
3
TriangleStrip
=
4
}
impl
PrimitiveTopology
{
pub
fn
is_strip
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
PointList
|
Self
:
:
LineList
|
Self
:
:
TriangleList
=
>
false
Self
:
:
LineStrip
|
Self
:
:
TriangleStrip
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
FrontFace
{
#
[
default
]
Ccw
=
0
Cw
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
Face
{
Front
=
0
Back
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PolygonMode
{
#
[
default
]
Fill
=
0
Line
=
1
Point
=
2
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
PrimitiveState
{
pub
topology
:
PrimitiveTopology
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
strip_index_format
:
Option
<
IndexFormat
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
front_face
:
FrontFace
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
cull_mode
:
Option
<
Face
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
unclipped_depth
:
bool
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
)
)
]
pub
polygon_mode
:
PolygonMode
pub
conservative
:
bool
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
MultisampleState
{
pub
count
:
u32
pub
mask
:
u64
pub
alpha_to_coverage_enabled
:
bool
}
impl
Default
for
MultisampleState
{
fn
default
(
)
-
>
Self
{
MultisampleState
{
count
:
1
mask
:
!
0
alpha_to_coverage_enabled
:
false
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Feature
flags
for
a
texture
format
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TextureFormatFeatureFlags
:
u32
{
/
/
/
If
not
present
the
texture
can
'
t
be
sampled
with
a
filtering
sampler
.
/
/
/
This
may
overwrite
TextureSampleType
:
:
Float
.
filterable
const
FILTERABLE
=
1
<
<
0
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
2
.
const
MULTISAMPLE_X2
=
1
<
<
1
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
4
.
const
MULTISAMPLE_X4
=
1
<
<
2
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
8
.
const
MULTISAMPLE_X8
=
1
<
<
3
;
/
/
/
Allows
[
TextureDescriptor
:
:
sample_count
]
to
be
16
.
const
MULTISAMPLE_X16
=
1
<
<
4
;
/
/
/
Allows
a
texture
of
this
format
to
back
a
view
passed
as
resolve_target
/
/
/
to
a
render
pass
for
an
automatic
driver
-
implemented
resolve
.
const
MULTISAMPLE_RESOLVE
=
1
<
<
5
;
/
/
/
When
used
as
a
STORAGE
texture
then
a
texture
with
this
format
can
be
bound
with
/
/
/
[
StorageTextureAccess
:
:
ReadOnly
]
or
[
StorageTextureAccess
:
:
ReadWrite
]
.
const
STORAGE_READ_WRITE
=
1
<
<
6
;
/
/
/
If
not
present
the
texture
can
'
t
be
blended
into
the
render
target
.
const
BLENDABLE
=
1
<
<
7
;
}
}
impl
TextureFormatFeatureFlags
{
pub
fn
sample_count_supported
(
&
self
count
:
u32
)
-
>
bool
{
use
TextureFormatFeatureFlags
as
tfsc
;
match
count
{
1
=
>
true
2
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X2
)
4
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X4
)
8
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X8
)
16
=
>
self
.
contains
(
tfsc
:
:
MULTISAMPLE_X16
)
_
=
>
false
}
}
}
impl_bitflags
!
(
TextureFormatFeatureFlags
)
;
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
pub
struct
TextureFormatFeatures
{
pub
allowed_usages
:
TextureUsages
pub
flags
:
TextureFormatFeatureFlags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
pub
enum
AstcBlock
{
B4x4
B5x4
B5x5
B6x5
B6x6
B8x5
B8x6
B8x8
B10x5
B10x6
B10x8
B10x10
B12x10
B12x12
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
pub
enum
AstcChannel
{
Unorm
UnormSrgb
Hdr
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
pub
enum
TextureFormat
{
R8Unorm
R8Snorm
R8Uint
R8Sint
R16Uint
R16Sint
R16Unorm
R16Snorm
R16Float
Rg8Unorm
Rg8Snorm
Rg8Uint
Rg8Sint
R32Uint
R32Sint
R32Float
Rg16Uint
Rg16Sint
Rg16Unorm
Rg16Snorm
Rg16Float
Rgba8Unorm
Rgba8UnormSrgb
Rgba8Snorm
Rgba8Uint
Rgba8Sint
Bgra8Unorm
Bgra8UnormSrgb
Rgb9e5Ufloat
Rgb10a2Unorm
Rg11b10Float
Rg32Uint
Rg32Sint
Rg32Float
Rgba16Uint
Rgba16Sint
Rgba16Unorm
Rgba16Snorm
Rgba16Float
Rgba32Uint
Rgba32Sint
Rgba32Float
Stencil8
Depth16Unorm
Depth24Plus
Depth24PlusStencil8
Depth32Float
Depth32FloatStencil8
Bc1RgbaUnorm
Bc1RgbaUnormSrgb
Bc2RgbaUnorm
Bc2RgbaUnormSrgb
Bc3RgbaUnorm
Bc3RgbaUnormSrgb
Bc4RUnorm
Bc4RSnorm
Bc5RgUnorm
Bc5RgSnorm
Bc6hRgbUfloat
Bc6hRgbFloat
Bc7RgbaUnorm
Bc7RgbaUnormSrgb
Etc2Rgb8Unorm
Etc2Rgb8UnormSrgb
Etc2Rgb8A1Unorm
Etc2Rgb8A1UnormSrgb
Etc2Rgba8Unorm
Etc2Rgba8UnormSrgb
EacR11Unorm
EacR11Snorm
EacRg11Unorm
EacRg11Snorm
Astc
{
block
:
AstcBlock
channel
:
AstcChannel
}
}
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
impl
<
'
de
>
Deserialize
<
'
de
>
for
TextureFormat
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
self
Error
Unexpected
}
;
struct
TextureFormatVisitor
;
impl
<
'
de
>
de
:
:
Visitor
<
'
de
>
for
TextureFormatVisitor
{
type
Value
=
TextureFormat
;
fn
expecting
(
&
self
formatter
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
valid
texture
format
"
)
}
fn
visit_str
<
E
:
Error
>
(
self
s
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
{
let
format
=
match
s
{
"
r8unorm
"
=
>
TextureFormat
:
:
R8Unorm
"
r8snorm
"
=
>
TextureFormat
:
:
R8Snorm
"
r8uint
"
=
>
TextureFormat
:
:
R8Uint
"
r8sint
"
=
>
TextureFormat
:
:
R8Sint
"
r16uint
"
=
>
TextureFormat
:
:
R16Uint
"
r16sint
"
=
>
TextureFormat
:
:
R16Sint
"
r16unorm
"
=
>
TextureFormat
:
:
R16Unorm
"
r16snorm
"
=
>
TextureFormat
:
:
R16Snorm
"
r16float
"
=
>
TextureFormat
:
:
R16Float
"
rg8unorm
"
=
>
TextureFormat
:
:
Rg8Unorm
"
rg8snorm
"
=
>
TextureFormat
:
:
Rg8Snorm
"
rg8uint
"
=
>
TextureFormat
:
:
Rg8Uint
"
rg8sint
"
=
>
TextureFormat
:
:
Rg8Sint
"
r32uint
"
=
>
TextureFormat
:
:
R32Uint
"
r32sint
"
=
>
TextureFormat
:
:
R32Sint
"
r32float
"
=
>
TextureFormat
:
:
R32Float
"
rg16uint
"
=
>
TextureFormat
:
:
Rg16Uint
"
rg16sint
"
=
>
TextureFormat
:
:
Rg16Sint
"
rg16unorm
"
=
>
TextureFormat
:
:
Rg16Unorm
"
rg16snorm
"
=
>
TextureFormat
:
:
Rg16Snorm
"
rg16float
"
=
>
TextureFormat
:
:
Rg16Float
"
rgba8unorm
"
=
>
TextureFormat
:
:
Rgba8Unorm
"
rgba8unorm
-
srgb
"
=
>
TextureFormat
:
:
Rgba8UnormSrgb
"
rgba8snorm
"
=
>
TextureFormat
:
:
Rgba8Snorm
"
rgba8uint
"
=
>
TextureFormat
:
:
Rgba8Uint
"
rgba8sint
"
=
>
TextureFormat
:
:
Rgba8Sint
"
bgra8unorm
"
=
>
TextureFormat
:
:
Bgra8Unorm
"
bgra8unorm
-
srgb
"
=
>
TextureFormat
:
:
Bgra8UnormSrgb
"
rgb10a2unorm
"
=
>
TextureFormat
:
:
Rgb10a2Unorm
"
rg11b10ufloat
"
=
>
TextureFormat
:
:
Rg11b10Float
"
rg32uint
"
=
>
TextureFormat
:
:
Rg32Uint
"
rg32sint
"
=
>
TextureFormat
:
:
Rg32Sint
"
rg32float
"
=
>
TextureFormat
:
:
Rg32Float
"
rgba16uint
"
=
>
TextureFormat
:
:
Rgba16Uint
"
rgba16sint
"
=
>
TextureFormat
:
:
Rgba16Sint
"
rgba16unorm
"
=
>
TextureFormat
:
:
Rgba16Unorm
"
rgba16snorm
"
=
>
TextureFormat
:
:
Rgba16Snorm
"
rgba16float
"
=
>
TextureFormat
:
:
Rgba16Float
"
rgba32uint
"
=
>
TextureFormat
:
:
Rgba32Uint
"
rgba32sint
"
=
>
TextureFormat
:
:
Rgba32Sint
"
rgba32float
"
=
>
TextureFormat
:
:
Rgba32Float
"
stencil8
"
=
>
TextureFormat
:
:
Stencil8
"
depth32float
"
=
>
TextureFormat
:
:
Depth32Float
"
depth32float
-
stencil8
"
=
>
TextureFormat
:
:
Depth32FloatStencil8
"
depth16unorm
"
=
>
TextureFormat
:
:
Depth16Unorm
"
depth24plus
"
=
>
TextureFormat
:
:
Depth24Plus
"
depth24plus
-
stencil8
"
=
>
TextureFormat
:
:
Depth24PlusStencil8
"
rgb9e5ufloat
"
=
>
TextureFormat
:
:
Rgb9e5Ufloat
"
bc1
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc1RgbaUnorm
"
bc1
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc1RgbaUnormSrgb
"
bc2
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc2RgbaUnorm
"
bc2
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc2RgbaUnormSrgb
"
bc3
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc3RgbaUnorm
"
bc3
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc3RgbaUnormSrgb
"
bc4
-
r
-
unorm
"
=
>
TextureFormat
:
:
Bc4RUnorm
"
bc4
-
r
-
snorm
"
=
>
TextureFormat
:
:
Bc4RSnorm
"
bc5
-
rg
-
unorm
"
=
>
TextureFormat
:
:
Bc5RgUnorm
"
bc5
-
rg
-
snorm
"
=
>
TextureFormat
:
:
Bc5RgSnorm
"
bc6h
-
rgb
-
ufloat
"
=
>
TextureFormat
:
:
Bc6hRgbUfloat
"
bc6h
-
rgb
-
float
"
=
>
TextureFormat
:
:
Bc6hRgbFloat
"
bc7
-
rgba
-
unorm
"
=
>
TextureFormat
:
:
Bc7RgbaUnorm
"
bc7
-
rgba
-
unorm
-
srgb
"
=
>
TextureFormat
:
:
Bc7RgbaUnormSrgb
"
etc2
-
rgb8unorm
"
=
>
TextureFormat
:
:
Etc2Rgb8Unorm
"
etc2
-
rgb8unorm
-
srgb
"
=
>
TextureFormat
:
:
Etc2Rgb8UnormSrgb
"
etc2
-
rgb8a1unorm
"
=
>
TextureFormat
:
:
Etc2Rgb8A1Unorm
"
etc2
-
rgb8a1unorm
-
srgb
"
=
>
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
"
etc2
-
rgba8unorm
"
=
>
TextureFormat
:
:
Etc2Rgba8Unorm
"
etc2
-
rgba8unorm
-
srgb
"
=
>
TextureFormat
:
:
Etc2Rgba8UnormSrgb
"
eac
-
r11unorm
"
=
>
TextureFormat
:
:
EacR11Unorm
"
eac
-
r11snorm
"
=
>
TextureFormat
:
:
EacR11Snorm
"
eac
-
rg11unorm
"
=
>
TextureFormat
:
:
EacRg11Unorm
"
eac
-
rg11snorm
"
=
>
TextureFormat
:
:
EacRg11Snorm
other
=
>
{
if
let
Some
(
parts
)
=
other
.
strip_prefix
(
"
astc
-
"
)
{
let
(
block
channel
)
=
parts
.
split_once
(
'
-
'
)
.
ok_or_else
(
|
|
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
?
;
let
block
=
match
block
{
"
4x4
"
=
>
AstcBlock
:
:
B4x4
"
5x4
"
=
>
AstcBlock
:
:
B5x4
"
5x5
"
=
>
AstcBlock
:
:
B5x5
"
6x5
"
=
>
AstcBlock
:
:
B6x5
"
6x6
"
=
>
AstcBlock
:
:
B6x6
"
8x5
"
=
>
AstcBlock
:
:
B8x5
"
8x6
"
=
>
AstcBlock
:
:
B8x6
"
8x8
"
=
>
AstcBlock
:
:
B8x8
"
10x5
"
=
>
AstcBlock
:
:
B10x5
"
10x6
"
=
>
AstcBlock
:
:
B10x6
"
10x8
"
=
>
AstcBlock
:
:
B10x8
"
10x10
"
=
>
AstcBlock
:
:
B10x10
"
12x10
"
=
>
AstcBlock
:
:
B12x10
"
12x12
"
=
>
AstcBlock
:
:
B12x12
_
=
>
return
Err
(
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
}
;
let
channel
=
match
channel
{
"
unorm
"
=
>
AstcChannel
:
:
Unorm
"
unorm
-
srgb
"
=
>
AstcChannel
:
:
UnormSrgb
"
hdr
"
=
>
AstcChannel
:
:
Hdr
_
=
>
return
Err
(
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
}
;
TextureFormat
:
:
Astc
{
block
channel
}
}
else
{
return
Err
(
E
:
:
invalid_value
(
Unexpected
:
:
Str
(
s
)
&
self
)
)
;
}
}
}
;
Ok
(
format
)
}
}
deserializer
.
deserialize_str
(
TextureFormatVisitor
)
}
}
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
impl
Serialize
for
TextureFormat
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
let
s
:
String
;
let
name
=
match
*
self
{
TextureFormat
:
:
R8Unorm
=
>
"
r8unorm
"
TextureFormat
:
:
R8Snorm
=
>
"
r8snorm
"
TextureFormat
:
:
R8Uint
=
>
"
r8uint
"
TextureFormat
:
:
R8Sint
=
>
"
r8sint
"
TextureFormat
:
:
R16Uint
=
>
"
r16uint
"
TextureFormat
:
:
R16Sint
=
>
"
r16sint
"
TextureFormat
:
:
R16Unorm
=
>
"
r16unorm
"
TextureFormat
:
:
R16Snorm
=
>
"
r16snorm
"
TextureFormat
:
:
R16Float
=
>
"
r16float
"
TextureFormat
:
:
Rg8Unorm
=
>
"
rg8unorm
"
TextureFormat
:
:
Rg8Snorm
=
>
"
rg8snorm
"
TextureFormat
:
:
Rg8Uint
=
>
"
rg8uint
"
TextureFormat
:
:
Rg8Sint
=
>
"
rg8sint
"
TextureFormat
:
:
R32Uint
=
>
"
r32uint
"
TextureFormat
:
:
R32Sint
=
>
"
r32sint
"
TextureFormat
:
:
R32Float
=
>
"
r32float
"
TextureFormat
:
:
Rg16Uint
=
>
"
rg16uint
"
TextureFormat
:
:
Rg16Sint
=
>
"
rg16sint
"
TextureFormat
:
:
Rg16Unorm
=
>
"
rg16unorm
"
TextureFormat
:
:
Rg16Snorm
=
>
"
rg16snorm
"
TextureFormat
:
:
Rg16Float
=
>
"
rg16float
"
TextureFormat
:
:
Rgba8Unorm
=
>
"
rgba8unorm
"
TextureFormat
:
:
Rgba8UnormSrgb
=
>
"
rgba8unorm
-
srgb
"
TextureFormat
:
:
Rgba8Snorm
=
>
"
rgba8snorm
"
TextureFormat
:
:
Rgba8Uint
=
>
"
rgba8uint
"
TextureFormat
:
:
Rgba8Sint
=
>
"
rgba8sint
"
TextureFormat
:
:
Bgra8Unorm
=
>
"
bgra8unorm
"
TextureFormat
:
:
Bgra8UnormSrgb
=
>
"
bgra8unorm
-
srgb
"
TextureFormat
:
:
Rgb10a2Unorm
=
>
"
rgb10a2unorm
"
TextureFormat
:
:
Rg11b10Float
=
>
"
rg11b10ufloat
"
TextureFormat
:
:
Rg32Uint
=
>
"
rg32uint
"
TextureFormat
:
:
Rg32Sint
=
>
"
rg32sint
"
TextureFormat
:
:
Rg32Float
=
>
"
rg32float
"
TextureFormat
:
:
Rgba16Uint
=
>
"
rgba16uint
"
TextureFormat
:
:
Rgba16Sint
=
>
"
rgba16sint
"
TextureFormat
:
:
Rgba16Unorm
=
>
"
rgba16unorm
"
TextureFormat
:
:
Rgba16Snorm
=
>
"
rgba16snorm
"
TextureFormat
:
:
Rgba16Float
=
>
"
rgba16float
"
TextureFormat
:
:
Rgba32Uint
=
>
"
rgba32uint
"
TextureFormat
:
:
Rgba32Sint
=
>
"
rgba32sint
"
TextureFormat
:
:
Rgba32Float
=
>
"
rgba32float
"
TextureFormat
:
:
Stencil8
=
>
"
stencil8
"
TextureFormat
:
:
Depth32Float
=
>
"
depth32float
"
TextureFormat
:
:
Depth16Unorm
=
>
"
depth16unorm
"
TextureFormat
:
:
Depth32FloatStencil8
=
>
"
depth32float
-
stencil8
"
TextureFormat
:
:
Depth24Plus
=
>
"
depth24plus
"
TextureFormat
:
:
Depth24PlusStencil8
=
>
"
depth24plus
-
stencil8
"
TextureFormat
:
:
Rgb9e5Ufloat
=
>
"
rgb9e5ufloat
"
TextureFormat
:
:
Bc1RgbaUnorm
=
>
"
bc1
-
rgba
-
unorm
"
TextureFormat
:
:
Bc1RgbaUnormSrgb
=
>
"
bc1
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Bc2RgbaUnorm
=
>
"
bc2
-
rgba
-
unorm
"
TextureFormat
:
:
Bc2RgbaUnormSrgb
=
>
"
bc2
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Bc3RgbaUnorm
=
>
"
bc3
-
rgba
-
unorm
"
TextureFormat
:
:
Bc3RgbaUnormSrgb
=
>
"
bc3
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Bc4RUnorm
=
>
"
bc4
-
r
-
unorm
"
TextureFormat
:
:
Bc4RSnorm
=
>
"
bc4
-
r
-
snorm
"
TextureFormat
:
:
Bc5RgUnorm
=
>
"
bc5
-
rg
-
unorm
"
TextureFormat
:
:
Bc5RgSnorm
=
>
"
bc5
-
rg
-
snorm
"
TextureFormat
:
:
Bc6hRgbUfloat
=
>
"
bc6h
-
rgb
-
ufloat
"
TextureFormat
:
:
Bc6hRgbFloat
=
>
"
bc6h
-
rgb
-
float
"
TextureFormat
:
:
Bc7RgbaUnorm
=
>
"
bc7
-
rgba
-
unorm
"
TextureFormat
:
:
Bc7RgbaUnormSrgb
=
>
"
bc7
-
rgba
-
unorm
-
srgb
"
TextureFormat
:
:
Etc2Rgb8Unorm
=
>
"
etc2
-
rgb8unorm
"
TextureFormat
:
:
Etc2Rgb8UnormSrgb
=
>
"
etc2
-
rgb8unorm
-
srgb
"
TextureFormat
:
:
Etc2Rgb8A1Unorm
=
>
"
etc2
-
rgb8a1unorm
"
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
=
>
"
etc2
-
rgb8a1unorm
-
srgb
"
TextureFormat
:
:
Etc2Rgba8Unorm
=
>
"
etc2
-
rgba8unorm
"
TextureFormat
:
:
Etc2Rgba8UnormSrgb
=
>
"
etc2
-
rgba8unorm
-
srgb
"
TextureFormat
:
:
EacR11Unorm
=
>
"
eac
-
r11unorm
"
TextureFormat
:
:
EacR11Snorm
=
>
"
eac
-
r11snorm
"
TextureFormat
:
:
EacRg11Unorm
=
>
"
eac
-
rg11unorm
"
TextureFormat
:
:
EacRg11Snorm
=
>
"
eac
-
rg11snorm
"
TextureFormat
:
:
Astc
{
block
channel
}
=
>
{
let
block
=
match
block
{
AstcBlock
:
:
B4x4
=
>
"
4x4
"
AstcBlock
:
:
B5x4
=
>
"
5x4
"
AstcBlock
:
:
B5x5
=
>
"
5x5
"
AstcBlock
:
:
B6x5
=
>
"
6x5
"
AstcBlock
:
:
B6x6
=
>
"
6x6
"
AstcBlock
:
:
B8x5
=
>
"
8x5
"
AstcBlock
:
:
B8x6
=
>
"
8x6
"
AstcBlock
:
:
B8x8
=
>
"
8x8
"
AstcBlock
:
:
B10x5
=
>
"
10x5
"
AstcBlock
:
:
B10x6
=
>
"
10x6
"
AstcBlock
:
:
B10x8
=
>
"
10x8
"
AstcBlock
:
:
B10x10
=
>
"
10x10
"
AstcBlock
:
:
B12x10
=
>
"
12x10
"
AstcBlock
:
:
B12x12
=
>
"
12x12
"
}
;
let
channel
=
match
channel
{
AstcChannel
:
:
Unorm
=
>
"
unorm
"
AstcChannel
:
:
UnormSrgb
=
>
"
unorm
-
srgb
"
AstcChannel
:
:
Hdr
=
>
"
hdr
"
}
;
s
=
format
!
(
"
astc
-
{
block
}
-
{
channel
}
"
)
;
&
s
}
}
;
serializer
.
serialize_str
(
name
)
}
}
impl
TextureFormat
{
pub
fn
aspect_specific_format
(
&
self
aspect
:
TextureAspect
)
-
>
Option
<
Self
>
{
match
(
*
self
aspect
)
{
(
Self
:
:
Stencil8
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
*
self
)
(
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth32Float
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
*
self
)
(
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
Self
:
:
Stencil8
)
(
Self
:
:
Depth24PlusStencil8
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
Self
:
:
Depth24Plus
)
(
Self
:
:
Depth32FloatStencil8
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
Self
:
:
Depth32Float
)
(
format
TextureAspect
:
:
All
)
=
>
Some
(
format
)
_
=
>
None
}
}
pub
fn
is_depth_stencil_component
(
&
self
combined_format
:
Self
)
-
>
bool
{
match
(
combined_format
*
self
)
{
(
Self
:
:
Depth24PlusStencil8
Self
:
:
Depth24Plus
|
Self
:
:
Stencil8
)
|
(
Self
:
:
Depth32FloatStencil8
Self
:
:
Depth32Float
|
Self
:
:
Stencil8
)
=
>
true
_
=
>
false
}
}
pub
fn
is_depth_stencil_format
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
pub
fn
is_combined_depth_stencil_format
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
pub
fn
has_color_aspect
(
&
self
)
-
>
bool
{
!
self
.
is_depth_stencil_format
(
)
}
pub
fn
has_depth_aspect
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
pub
fn
has_stencil_aspect
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Stencil8
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
true
_
=
>
false
}
}
pub
fn
block_dimensions
(
&
self
)
-
>
(
u32
u32
)
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Float
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Float
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
|
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
|
Self
:
:
Depth32FloatStencil8
=
>
(
1
1
)
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
(
4
4
)
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
(
4
4
)
Self
:
:
Astc
{
block
.
.
}
=
>
match
block
{
AstcBlock
:
:
B4x4
=
>
(
4
4
)
AstcBlock
:
:
B5x4
=
>
(
5
4
)
AstcBlock
:
:
B5x5
=
>
(
5
5
)
AstcBlock
:
:
B6x5
=
>
(
6
5
)
AstcBlock
:
:
B6x6
=
>
(
6
6
)
AstcBlock
:
:
B8x5
=
>
(
8
5
)
AstcBlock
:
:
B8x6
=
>
(
8
6
)
AstcBlock
:
:
B8x8
=
>
(
8
8
)
AstcBlock
:
:
B10x5
=
>
(
10
5
)
AstcBlock
:
:
B10x6
=
>
(
10
6
)
AstcBlock
:
:
B10x8
=
>
(
10
8
)
AstcBlock
:
:
B10x10
=
>
(
10
10
)
AstcBlock
:
:
B12x10
=
>
(
12
10
)
AstcBlock
:
:
B12x12
=
>
(
12
12
)
}
}
}
pub
fn
is_compressed
(
&
self
)
-
>
bool
{
self
.
block_dimensions
(
)
!
=
(
1
1
)
}
pub
fn
required_features
(
&
self
)
-
>
Features
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Float
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
|
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Float
|
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
|
Self
:
:
Stencil8
|
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32Float
=
>
Features
:
:
empty
(
)
Self
:
:
Depth32FloatStencil8
=
>
Features
:
:
DEPTH32FLOAT_STENCIL8
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
=
>
Features
:
:
TEXTURE_FORMAT_16BIT_NORM
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
Features
:
:
TEXTURE_COMPRESSION_BC
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
Features
:
:
TEXTURE_COMPRESSION_ETC2
Self
:
:
Astc
{
channel
.
.
}
=
>
match
channel
{
AstcChannel
:
:
Hdr
=
>
Features
:
:
TEXTURE_COMPRESSION_ASTC_HDR
AstcChannel
:
:
Unorm
|
AstcChannel
:
:
UnormSrgb
=
>
Features
:
:
TEXTURE_COMPRESSION_ASTC
}
}
}
pub
fn
guaranteed_format_features
(
&
self
device_features
:
Features
)
-
>
TextureFormatFeatures
{
let
noaa
=
TextureFormatFeatureFlags
:
:
empty
(
)
;
let
msaa
=
TextureFormatFeatureFlags
:
:
MULTISAMPLE_X4
;
let
msaa_resolve
=
msaa
|
TextureFormatFeatureFlags
:
:
MULTISAMPLE_RESOLVE
;
let
basic
=
TextureUsages
:
:
COPY_SRC
|
TextureUsages
:
:
COPY_DST
|
TextureUsages
:
:
TEXTURE_BINDING
;
let
attachment
=
basic
|
TextureUsages
:
:
RENDER_ATTACHMENT
;
let
storage
=
basic
|
TextureUsages
:
:
STORAGE_BINDING
;
let
all_flags
=
TextureUsages
:
:
all
(
)
;
let
rg11b10f
=
if
device_features
.
contains
(
Features
:
:
RG11B10UFLOAT_RENDERABLE
)
{
attachment
}
else
{
basic
}
;
#
[
rustfmt
:
:
skip
]
let
(
mut
flags
allowed_usages
)
=
match
*
self
{
Self
:
:
R8Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
R8Snorm
=
>
(
noaa
basic
)
Self
:
:
R8Uint
=
>
(
msaa
attachment
)
Self
:
:
R8Sint
=
>
(
msaa
attachment
)
Self
:
:
R16Uint
=
>
(
msaa
attachment
)
Self
:
:
R16Sint
=
>
(
msaa
attachment
)
Self
:
:
R16Float
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rg8Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rg8Snorm
=
>
(
noaa
basic
)
Self
:
:
Rg8Uint
=
>
(
msaa
attachment
)
Self
:
:
Rg8Sint
=
>
(
msaa
attachment
)
Self
:
:
R32Uint
=
>
(
noaa
all_flags
)
Self
:
:
R32Sint
=
>
(
noaa
all_flags
)
Self
:
:
R32Float
=
>
(
msaa
all_flags
)
Self
:
:
Rg16Uint
=
>
(
msaa
attachment
)
Self
:
:
Rg16Sint
=
>
(
msaa
attachment
)
Self
:
:
Rg16Float
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rgba8Unorm
=
>
(
msaa_resolve
all_flags
)
Self
:
:
Rgba8UnormSrgb
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rgba8Snorm
=
>
(
noaa
storage
)
Self
:
:
Rgba8Uint
=
>
(
msaa
all_flags
)
Self
:
:
Rgba8Sint
=
>
(
msaa
all_flags
)
Self
:
:
Bgra8Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
Bgra8UnormSrgb
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rgb10a2Unorm
=
>
(
msaa_resolve
attachment
)
Self
:
:
Rg11b10Float
=
>
(
msaa
rg11b10f
)
Self
:
:
Rg32Uint
=
>
(
noaa
all_flags
)
Self
:
:
Rg32Sint
=
>
(
noaa
all_flags
)
Self
:
:
Rg32Float
=
>
(
noaa
all_flags
)
Self
:
:
Rgba16Uint
=
>
(
msaa
all_flags
)
Self
:
:
Rgba16Sint
=
>
(
msaa
all_flags
)
Self
:
:
Rgba16Float
=
>
(
msaa_resolve
all_flags
)
Self
:
:
Rgba32Uint
=
>
(
noaa
all_flags
)
Self
:
:
Rgba32Sint
=
>
(
noaa
all_flags
)
Self
:
:
Rgba32Float
=
>
(
noaa
all_flags
)
Self
:
:
Stencil8
=
>
(
msaa
attachment
)
Self
:
:
Depth16Unorm
=
>
(
msaa
attachment
)
Self
:
:
Depth24Plus
=
>
(
msaa
attachment
)
Self
:
:
Depth24PlusStencil8
=
>
(
msaa
attachment
)
Self
:
:
Depth32Float
=
>
(
msaa
attachment
)
Self
:
:
Depth32FloatStencil8
=
>
(
msaa
attachment
)
Self
:
:
R16Unorm
=
>
(
msaa
storage
)
Self
:
:
R16Snorm
=
>
(
msaa
storage
)
Self
:
:
Rg16Unorm
=
>
(
msaa
storage
)
Self
:
:
Rg16Snorm
=
>
(
msaa
storage
)
Self
:
:
Rgba16Unorm
=
>
(
msaa
storage
)
Self
:
:
Rgba16Snorm
=
>
(
msaa
storage
)
Self
:
:
Rgb9e5Ufloat
=
>
(
noaa
basic
)
Self
:
:
Bc1RgbaUnorm
=
>
(
noaa
basic
)
Self
:
:
Bc1RgbaUnormSrgb
=
>
(
noaa
basic
)
Self
:
:
Bc2RgbaUnorm
=
>
(
noaa
basic
)
Self
:
:
Bc2RgbaUnormSrgb
=
>
(
noaa
basic
)
Self
:
:
Bc3RgbaUnorm
=
>
(
noaa
basic
)
Self
:
:
Bc3RgbaUnormSrgb
=
>
(
noaa
basic
)
Self
:
:
Bc4RUnorm
=
>
(
noaa
basic
)
Self
:
:
Bc4RSnorm
=
>
(
noaa
basic
)
Self
:
:
Bc5RgUnorm
=
>
(
noaa
basic
)
Self
:
:
Bc5RgSnorm
=
>
(
noaa
basic
)
Self
:
:
Bc6hRgbUfloat
=
>
(
noaa
basic
)
Self
:
:
Bc6hRgbFloat
=
>
(
noaa
basic
)
Self
:
:
Bc7RgbaUnorm
=
>
(
noaa
basic
)
Self
:
:
Bc7RgbaUnormSrgb
=
>
(
noaa
basic
)
Self
:
:
Etc2Rgb8Unorm
=
>
(
noaa
basic
)
Self
:
:
Etc2Rgb8UnormSrgb
=
>
(
noaa
basic
)
Self
:
:
Etc2Rgb8A1Unorm
=
>
(
noaa
basic
)
Self
:
:
Etc2Rgb8A1UnormSrgb
=
>
(
noaa
basic
)
Self
:
:
Etc2Rgba8Unorm
=
>
(
noaa
basic
)
Self
:
:
Etc2Rgba8UnormSrgb
=
>
(
noaa
basic
)
Self
:
:
EacR11Unorm
=
>
(
noaa
basic
)
Self
:
:
EacR11Snorm
=
>
(
noaa
basic
)
Self
:
:
EacRg11Unorm
=
>
(
noaa
basic
)
Self
:
:
EacRg11Snorm
=
>
(
noaa
basic
)
Self
:
:
Astc
{
.
.
}
=
>
(
noaa
basic
)
}
;
let
is_filterable
=
self
.
sample_type
(
None
)
=
=
Some
(
TextureSampleType
:
:
Float
{
filterable
:
true
}
)
;
flags
.
set
(
TextureFormatFeatureFlags
:
:
FILTERABLE
is_filterable
)
;
flags
.
set
(
TextureFormatFeatureFlags
:
:
BLENDABLE
is_filterable
)
;
TextureFormatFeatures
{
allowed_usages
flags
}
}
pub
fn
sample_type
(
&
self
aspect
:
Option
<
TextureAspect
>
)
-
>
Option
<
TextureSampleType
>
{
let
float
=
TextureSampleType
:
:
Float
{
filterable
:
true
}
;
let
unfilterable_float
=
TextureSampleType
:
:
Float
{
filterable
:
false
}
;
let
depth
=
TextureSampleType
:
:
Depth
;
let
uint
=
TextureSampleType
:
:
Uint
;
let
sint
=
TextureSampleType
:
:
Sint
;
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
|
Self
:
:
R16Float
|
Self
:
:
Rg16Float
|
Self
:
:
Rgba16Float
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Float
=
>
Some
(
float
)
Self
:
:
R32Float
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba32Float
=
>
Some
(
unfilterable_float
)
Self
:
:
R8Uint
|
Self
:
:
Rg8Uint
|
Self
:
:
Rgba8Uint
|
Self
:
:
R16Uint
|
Self
:
:
Rg16Uint
|
Self
:
:
Rgba16Uint
|
Self
:
:
R32Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rgba32Uint
=
>
Some
(
uint
)
Self
:
:
R8Sint
|
Self
:
:
Rg8Sint
|
Self
:
:
Rgba8Sint
|
Self
:
:
R16Sint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rgba16Sint
|
Self
:
:
R32Sint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rgba32Sint
=
>
Some
(
sint
)
Self
:
:
Stencil8
=
>
Some
(
uint
)
Self
:
:
Depth16Unorm
|
Self
:
:
Depth24Plus
|
Self
:
:
Depth32Float
=
>
Some
(
depth
)
Self
:
:
Depth24PlusStencil8
|
Self
:
:
Depth32FloatStencil8
=
>
match
aspect
{
None
|
Some
(
TextureAspect
:
:
All
)
=
>
None
Some
(
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
depth
)
Some
(
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
uint
)
}
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
=
>
Some
(
float
)
Self
:
:
Rgb9e5Ufloat
=
>
Some
(
float
)
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
Some
(
float
)
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
Some
(
float
)
Self
:
:
Astc
{
.
.
}
=
>
Some
(
float
)
}
}
pub
fn
block_size
(
&
self
aspect
:
Option
<
TextureAspect
>
)
-
>
Option
<
u32
>
{
match
*
self
{
Self
:
:
R8Unorm
|
Self
:
:
R8Snorm
|
Self
:
:
R8Uint
|
Self
:
:
R8Sint
=
>
Some
(
1
)
Self
:
:
Rg8Unorm
|
Self
:
:
Rg8Snorm
|
Self
:
:
Rg8Uint
|
Self
:
:
Rg8Sint
=
>
Some
(
2
)
Self
:
:
R16Unorm
|
Self
:
:
R16Snorm
|
Self
:
:
R16Uint
|
Self
:
:
R16Sint
|
Self
:
:
R16Float
=
>
{
Some
(
2
)
}
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgba8UnormSrgb
|
Self
:
:
Rgba8Snorm
|
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba8Sint
|
Self
:
:
Bgra8Unorm
|
Self
:
:
Bgra8UnormSrgb
=
>
Some
(
4
)
Self
:
:
Rg16Unorm
|
Self
:
:
Rg16Snorm
|
Self
:
:
Rg16Uint
|
Self
:
:
Rg16Sint
|
Self
:
:
Rg16Float
=
>
Some
(
4
)
Self
:
:
R32Uint
|
Self
:
:
R32Sint
|
Self
:
:
R32Float
=
>
Some
(
4
)
Self
:
:
Rgb9e5Ufloat
|
Self
:
:
Rgb10a2Unorm
|
Self
:
:
Rg11b10Float
=
>
Some
(
4
)
Self
:
:
Rgba16Unorm
|
Self
:
:
Rgba16Snorm
|
Self
:
:
Rgba16Uint
|
Self
:
:
Rgba16Sint
|
Self
:
:
Rgba16Float
=
>
Some
(
8
)
Self
:
:
Rg32Uint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rg32Float
=
>
Some
(
8
)
Self
:
:
Rgba32Uint
|
Self
:
:
Rgba32Sint
|
Self
:
:
Rgba32Float
=
>
Some
(
16
)
Self
:
:
Stencil8
=
>
Some
(
1
)
Self
:
:
Depth16Unorm
=
>
Some
(
2
)
Self
:
:
Depth32Float
=
>
Some
(
4
)
Self
:
:
Depth24Plus
=
>
None
Self
:
:
Depth24PlusStencil8
=
>
match
aspect
{
None
|
Some
(
TextureAspect
:
:
All
)
=
>
None
Some
(
TextureAspect
:
:
DepthOnly
)
=
>
None
Some
(
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
1
)
}
Self
:
:
Depth32FloatStencil8
=
>
match
aspect
{
None
|
Some
(
TextureAspect
:
:
All
)
=
>
None
Some
(
TextureAspect
:
:
DepthOnly
)
=
>
Some
(
4
)
Some
(
TextureAspect
:
:
StencilOnly
)
=
>
Some
(
1
)
}
Self
:
:
Bc1RgbaUnorm
|
Self
:
:
Bc1RgbaUnormSrgb
|
Self
:
:
Bc4RUnorm
|
Self
:
:
Bc4RSnorm
=
>
{
Some
(
8
)
}
Self
:
:
Bc2RgbaUnorm
|
Self
:
:
Bc2RgbaUnormSrgb
|
Self
:
:
Bc3RgbaUnorm
|
Self
:
:
Bc3RgbaUnormSrgb
|
Self
:
:
Bc5RgUnorm
|
Self
:
:
Bc5RgSnorm
|
Self
:
:
Bc6hRgbUfloat
|
Self
:
:
Bc6hRgbFloat
|
Self
:
:
Bc7RgbaUnorm
|
Self
:
:
Bc7RgbaUnormSrgb
=
>
Some
(
16
)
Self
:
:
Etc2Rgb8Unorm
|
Self
:
:
Etc2Rgb8UnormSrgb
|
Self
:
:
Etc2Rgb8A1Unorm
|
Self
:
:
Etc2Rgb8A1UnormSrgb
|
Self
:
:
EacR11Unorm
|
Self
:
:
EacR11Snorm
=
>
Some
(
8
)
Self
:
:
Etc2Rgba8Unorm
|
Self
:
:
Etc2Rgba8UnormSrgb
|
Self
:
:
EacRg11Unorm
|
Self
:
:
EacRg11Snorm
=
>
Some
(
16
)
Self
:
:
Astc
{
.
.
}
=
>
Some
(
16
)
}
}
pub
fn
remove_srgb_suffix
(
&
self
)
-
>
TextureFormat
{
match
*
self
{
Self
:
:
Rgba8UnormSrgb
=
>
Self
:
:
Rgba8Unorm
Self
:
:
Bgra8UnormSrgb
=
>
Self
:
:
Bgra8Unorm
Self
:
:
Bc1RgbaUnormSrgb
=
>
Self
:
:
Bc1RgbaUnorm
Self
:
:
Bc2RgbaUnormSrgb
=
>
Self
:
:
Bc2RgbaUnorm
Self
:
:
Bc3RgbaUnormSrgb
=
>
Self
:
:
Bc3RgbaUnorm
Self
:
:
Bc7RgbaUnormSrgb
=
>
Self
:
:
Bc7RgbaUnorm
Self
:
:
Etc2Rgb8UnormSrgb
=
>
Self
:
:
Etc2Rgb8Unorm
Self
:
:
Etc2Rgb8A1UnormSrgb
=
>
Self
:
:
Etc2Rgb8A1Unorm
Self
:
:
Etc2Rgba8UnormSrgb
=
>
Self
:
:
Etc2Rgba8Unorm
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
UnormSrgb
}
=
>
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
Unorm
}
_
=
>
*
self
}
}
pub
fn
add_srgb_suffix
(
&
self
)
-
>
TextureFormat
{
match
*
self
{
Self
:
:
Rgba8Unorm
=
>
Self
:
:
Rgba8UnormSrgb
Self
:
:
Bgra8Unorm
=
>
Self
:
:
Bgra8UnormSrgb
Self
:
:
Bc1RgbaUnorm
=
>
Self
:
:
Bc1RgbaUnormSrgb
Self
:
:
Bc2RgbaUnorm
=
>
Self
:
:
Bc2RgbaUnormSrgb
Self
:
:
Bc3RgbaUnorm
=
>
Self
:
:
Bc3RgbaUnormSrgb
Self
:
:
Bc7RgbaUnorm
=
>
Self
:
:
Bc7RgbaUnormSrgb
Self
:
:
Etc2Rgb8Unorm
=
>
Self
:
:
Etc2Rgb8UnormSrgb
Self
:
:
Etc2Rgb8A1Unorm
=
>
Self
:
:
Etc2Rgb8A1UnormSrgb
Self
:
:
Etc2Rgba8Unorm
=
>
Self
:
:
Etc2Rgba8UnormSrgb
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
Unorm
}
=
>
Self
:
:
Astc
{
block
channel
:
AstcChannel
:
:
UnormSrgb
}
_
=
>
*
self
}
}
pub
fn
is_srgb
(
&
self
)
-
>
bool
{
*
self
!
=
self
.
remove_srgb_suffix
(
)
}
}
#
[
test
]
fn
texture_format_serialize
(
)
{
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Unorm
)
.
unwrap
(
)
"
\
"
r8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Snorm
)
.
unwrap
(
)
"
\
"
r8snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Uint
)
.
unwrap
(
)
"
\
"
r8uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R8Sint
)
.
unwrap
(
)
"
\
"
r8sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Uint
)
.
unwrap
(
)
"
\
"
r16uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Sint
)
.
unwrap
(
)
"
\
"
r16sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Unorm
)
.
unwrap
(
)
"
\
"
r16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Snorm
)
.
unwrap
(
)
"
\
"
r16snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R16Float
)
.
unwrap
(
)
"
\
"
r16float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Unorm
)
.
unwrap
(
)
"
\
"
rg8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Snorm
)
.
unwrap
(
)
"
\
"
rg8snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Uint
)
.
unwrap
(
)
"
\
"
rg8uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg8Sint
)
.
unwrap
(
)
"
\
"
rg8sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R32Uint
)
.
unwrap
(
)
"
\
"
r32uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R32Sint
)
.
unwrap
(
)
"
\
"
r32sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
R32Float
)
.
unwrap
(
)
"
\
"
r32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Uint
)
.
unwrap
(
)
"
\
"
rg16uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Sint
)
.
unwrap
(
)
"
\
"
rg16sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Unorm
)
.
unwrap
(
)
"
\
"
rg16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Snorm
)
.
unwrap
(
)
"
\
"
rg16snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg16Float
)
.
unwrap
(
)
"
\
"
rg16float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Unorm
)
.
unwrap
(
)
"
\
"
rgba8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8UnormSrgb
)
.
unwrap
(
)
"
\
"
rgba8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Snorm
)
.
unwrap
(
)
"
\
"
rgba8snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Uint
)
.
unwrap
(
)
"
\
"
rgba8uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba8Sint
)
.
unwrap
(
)
"
\
"
rgba8sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bgra8Unorm
)
.
unwrap
(
)
"
\
"
bgra8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bgra8UnormSrgb
)
.
unwrap
(
)
"
\
"
bgra8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgb10a2Unorm
)
.
unwrap
(
)
"
\
"
rgb10a2unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg11b10Float
)
.
unwrap
(
)
"
\
"
rg11b10ufloat
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg32Uint
)
.
unwrap
(
)
"
\
"
rg32uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg32Sint
)
.
unwrap
(
)
"
\
"
rg32sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rg32Float
)
.
unwrap
(
)
"
\
"
rg32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Uint
)
.
unwrap
(
)
"
\
"
rgba16uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Sint
)
.
unwrap
(
)
"
\
"
rgba16sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Unorm
)
.
unwrap
(
)
"
\
"
rgba16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Snorm
)
.
unwrap
(
)
"
\
"
rgba16snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba16Float
)
.
unwrap
(
)
"
\
"
rgba16float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba32Uint
)
.
unwrap
(
)
"
\
"
rgba32uint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba32Sint
)
.
unwrap
(
)
"
\
"
rgba32sint
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgba32Float
)
.
unwrap
(
)
"
\
"
rgba32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Stencil8
)
.
unwrap
(
)
"
\
"
stencil8
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth32Float
)
.
unwrap
(
)
"
\
"
depth32float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth16Unorm
)
.
unwrap
(
)
"
\
"
depth16unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth32FloatStencil8
)
.
unwrap
(
)
"
\
"
depth32float
-
stencil8
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth24Plus
)
.
unwrap
(
)
"
\
"
depth24plus
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Depth24PlusStencil8
)
.
unwrap
(
)
"
\
"
depth24plus
-
stencil8
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Rgb9e5Ufloat
)
.
unwrap
(
)
"
\
"
rgb9e5ufloat
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc1RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc1
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc1RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc1
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc2RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc2
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc2RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc2
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc3RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc3
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc3RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc3
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc4RUnorm
)
.
unwrap
(
)
"
\
"
bc4
-
r
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc4RSnorm
)
.
unwrap
(
)
"
\
"
bc4
-
r
-
snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc5RgUnorm
)
.
unwrap
(
)
"
\
"
bc5
-
rg
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc5RgSnorm
)
.
unwrap
(
)
"
\
"
bc5
-
rg
-
snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc6hRgbUfloat
)
.
unwrap
(
)
"
\
"
bc6h
-
rgb
-
ufloat
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc6hRgbFloat
)
.
unwrap
(
)
"
\
"
bc6h
-
rgb
-
float
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc7RgbaUnorm
)
.
unwrap
(
)
"
\
"
bc7
-
rgba
-
unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Bc7RgbaUnormSrgb
)
.
unwrap
(
)
"
\
"
bc7
-
rgba
-
unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8Unorm
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8UnormSrgb
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8A1Unorm
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8a1unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
)
.
unwrap
(
)
"
\
"
etc2
-
rgb8a1unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgba8Unorm
)
.
unwrap
(
)
"
\
"
etc2
-
rgba8unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
Etc2Rgba8UnormSrgb
)
.
unwrap
(
)
"
\
"
etc2
-
rgba8unorm
-
srgb
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacR11Unorm
)
.
unwrap
(
)
"
\
"
eac
-
r11unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacR11Snorm
)
.
unwrap
(
)
"
\
"
eac
-
r11snorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacRg11Unorm
)
.
unwrap
(
)
"
\
"
eac
-
rg11unorm
\
"
"
.
to_string
(
)
)
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
TextureFormat
:
:
EacRg11Snorm
)
.
unwrap
(
)
"
\
"
eac
-
rg11snorm
\
"
"
.
to_string
(
)
)
;
}
#
[
test
]
fn
texture_format_deserialize
(
)
{
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r8sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R8Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r16float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R16Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg8sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg8Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r32uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R32Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r32sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R32Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
r32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
R32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg16float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg16Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba8sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba8Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bgra8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bgra8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bgra8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bgra8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgb10a2unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgb10a2Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg11b10ufloat
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg11b10Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg32uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg32Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg32sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg32Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rg32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rg32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba16float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba16Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba32uint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba32Uint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba32sint
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba32Sint
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgba32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgba32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
stencil8
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Stencil8
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth32float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth32Float
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth16unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth16Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth32float
-
stencil8
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth32FloatStencil8
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth24plus
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth24Plus
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
depth24plus
-
stencil8
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Depth24PlusStencil8
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
rgb9e5ufloat
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Rgb9e5Ufloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc1
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc1RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc1
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc1RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc2
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc2RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc2
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc2RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc3
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc3RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc3
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc3RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc4
-
r
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc4RUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc4
-
r
-
snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc4RSnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc5
-
rg
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc5RgUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc5
-
rg
-
snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc5RgSnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc6h
-
rgb
-
ufloat
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc6hRgbUfloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc6h
-
rgb
-
float
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc6hRgbFloat
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc7
-
rgba
-
unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc7RgbaUnorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
bc7
-
rgba
-
unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Bc7RgbaUnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8a1unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8A1Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgb8a1unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgb8A1UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgba8unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgba8Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
etc2
-
rgba8unorm
-
srgb
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
Etc2Rgba8UnormSrgb
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
r11unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacR11Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
r11snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacR11Snorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
rg11unorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacRg11Unorm
)
;
assert_eq
!
(
serde_json
:
:
from_str
:
:
<
TextureFormat
>
(
"
\
"
eac
-
rg11snorm
\
"
"
)
.
unwrap
(
)
TextureFormat
:
:
EacRg11Snorm
)
;
}
bitflags
:
:
bitflags
!
{
/
/
/
Color
write
mask
.
Disabled
color
channels
will
not
be
written
to
.
/
/
/
/
/
/
Corresponds
to
[
WebGPU
GPUColorWriteFlags
]
(
/
/
/
https
:
/
/
gpuweb
.
github
.
io
/
gpuweb
/
#
typedefdef
-
gpucolorwriteflags
)
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
ColorWrites
:
u32
{
/
/
/
Enable
red
channel
writes
const
RED
=
1
<
<
0
;
/
/
/
Enable
green
channel
writes
const
GREEN
=
1
<
<
1
;
/
/
/
Enable
blue
channel
writes
const
BLUE
=
1
<
<
2
;
/
/
/
Enable
alpha
channel
writes
const
ALPHA
=
1
<
<
3
;
/
/
/
Enable
red
green
and
blue
channel
writes
const
COLOR
=
Self
:
:
RED
.
bits
(
)
|
Self
:
:
GREEN
.
bits
(
)
|
Self
:
:
BLUE
.
bits
(
)
;
/
/
/
Enable
writes
to
all
channels
.
const
ALL
=
Self
:
:
RED
.
bits
(
)
|
Self
:
:
GREEN
.
bits
(
)
|
Self
:
:
BLUE
.
bits
(
)
|
Self
:
:
ALPHA
.
bits
(
)
;
}
}
impl_bitflags
!
(
ColorWrites
)
;
impl
Default
for
ColorWrites
{
fn
default
(
)
-
>
Self
{
Self
:
:
ALL
}
}
#
[
derive
(
Clone
)
]
pub
enum
Maintain
<
T
>
{
WaitForSubmissionIndex
(
T
)
Wait
Poll
}
impl
<
T
>
Maintain
<
T
>
{
pub
fn
is_wait
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
WaitForSubmissionIndex
(
.
.
)
|
Self
:
:
Wait
=
>
true
Self
:
:
Poll
=
>
false
}
}
pub
fn
map_index
<
U
F
>
(
self
func
:
F
)
-
>
Maintain
<
U
>
where
F
:
FnOnce
(
T
)
-
>
U
{
match
self
{
Self
:
:
WaitForSubmissionIndex
(
i
)
=
>
Maintain
:
:
WaitForSubmissionIndex
(
func
(
i
)
)
Self
:
:
Wait
=
>
Maintain
:
:
Wait
Self
:
:
Poll
=
>
Maintain
:
:
Poll
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
StencilState
{
pub
front
:
StencilFaceState
pub
back
:
StencilFaceState
pub
read_mask
:
u32
pub
write_mask
:
u32
}
impl
StencilState
{
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
(
self
.
front
!
=
StencilFaceState
:
:
IGNORE
|
|
self
.
back
!
=
StencilFaceState
:
:
IGNORE
)
&
&
(
self
.
read_mask
!
=
0
|
|
self
.
write_mask
!
=
0
)
}
pub
fn
is_read_only
(
&
self
cull_mode
:
Option
<
Face
>
)
-
>
bool
{
if
self
.
write_mask
=
=
0
{
return
true
;
}
let
front_ro
=
cull_mode
=
=
Some
(
Face
:
:
Front
)
|
|
self
.
front
.
is_read_only
(
)
;
let
back_ro
=
cull_mode
=
=
Some
(
Face
:
:
Back
)
|
|
self
.
back
.
is_read_only
(
)
;
front_ro
&
&
back_ro
}
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
front
.
needs_ref_value
(
)
|
|
self
.
back
.
needs_ref_value
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DepthBiasState
{
pub
constant
:
i32
pub
slope_scale
:
f32
pub
clamp
:
f32
}
impl
DepthBiasState
{
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
self
.
constant
!
=
0
|
|
self
.
slope_scale
!
=
0
.
0
}
}
impl
Hash
for
DepthBiasState
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
constant
.
hash
(
state
)
;
self
.
slope_scale
.
to_bits
(
)
.
hash
(
state
)
;
self
.
clamp
.
to_bits
(
)
.
hash
(
state
)
;
}
}
impl
PartialEq
for
DepthBiasState
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
(
self
.
constant
=
=
other
.
constant
)
&
&
(
self
.
slope_scale
.
to_bits
(
)
=
=
other
.
slope_scale
.
to_bits
(
)
)
&
&
(
self
.
clamp
.
to_bits
(
)
=
=
other
.
clamp
.
to_bits
(
)
)
}
}
impl
Eq
for
DepthBiasState
{
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DepthStencilState
{
pub
format
:
TextureFormat
pub
depth_write_enabled
:
bool
pub
depth_compare
:
CompareFunction
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
stencil
:
StencilState
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
bias
:
DepthBiasState
}
impl
DepthStencilState
{
pub
fn
is_depth_enabled
(
&
self
)
-
>
bool
{
self
.
depth_compare
!
=
CompareFunction
:
:
Always
|
|
self
.
depth_write_enabled
}
pub
fn
is_depth_read_only
(
&
self
)
-
>
bool
{
!
self
.
depth_write_enabled
}
pub
fn
is_stencil_read_only
(
&
self
cull_mode
:
Option
<
Face
>
)
-
>
bool
{
self
.
stencil
.
is_read_only
(
cull_mode
)
}
pub
fn
is_read_only
(
&
self
cull_mode
:
Option
<
Face
>
)
-
>
bool
{
self
.
is_depth_read_only
(
)
&
&
self
.
is_stencil_read_only
(
cull_mode
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
IndexFormat
{
Uint16
=
0
#
[
default
]
Uint32
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StencilOperation
{
#
[
default
]
Keep
=
0
Zero
=
1
Replace
=
2
Invert
=
3
IncrementClamp
=
4
DecrementClamp
=
5
IncrementWrap
=
6
DecrementWrap
=
7
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
StencilFaceState
{
pub
compare
:
CompareFunction
pub
fail_op
:
StencilOperation
pub
depth_fail_op
:
StencilOperation
pub
pass_op
:
StencilOperation
}
impl
StencilFaceState
{
pub
const
IGNORE
:
Self
=
StencilFaceState
{
compare
:
CompareFunction
:
:
Always
fail_op
:
StencilOperation
:
:
Keep
depth_fail_op
:
StencilOperation
:
:
Keep
pass_op
:
StencilOperation
:
:
Keep
}
;
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
compare
.
needs_ref_value
(
)
|
|
self
.
fail_op
=
=
StencilOperation
:
:
Replace
|
|
self
.
depth_fail_op
=
=
StencilOperation
:
:
Replace
|
|
self
.
pass_op
=
=
StencilOperation
:
:
Replace
}
pub
fn
is_read_only
(
&
self
)
-
>
bool
{
self
.
pass_op
=
=
StencilOperation
:
:
Keep
&
&
self
.
depth_fail_op
=
=
StencilOperation
:
:
Keep
&
&
self
.
fail_op
=
=
StencilOperation
:
:
Keep
}
}
impl
Default
for
StencilFaceState
{
fn
default
(
)
-
>
Self
{
Self
:
:
IGNORE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
CompareFunction
{
Never
=
1
Less
=
2
Equal
=
3
LessEqual
=
4
Greater
=
5
NotEqual
=
6
GreaterEqual
=
7
Always
=
8
}
impl
CompareFunction
{
pub
fn
needs_ref_value
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Never
|
Self
:
:
Always
=
>
false
_
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
VertexStepMode
{
#
[
default
]
Vertex
=
0
Instance
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
VertexAttribute
{
pub
format
:
VertexFormat
pub
offset
:
BufferAddress
pub
shader_location
:
ShaderLocation
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
lowercase
"
)
)
]
pub
enum
VertexFormat
{
Uint8x2
=
0
Uint8x4
=
1
Sint8x2
=
2
Sint8x4
=
3
Unorm8x2
=
4
Unorm8x4
=
5
Snorm8x2
=
6
Snorm8x4
=
7
Uint16x2
=
8
Uint16x4
=
9
Sint16x2
=
10
Sint16x4
=
11
Unorm16x2
=
12
Unorm16x4
=
13
Snorm16x2
=
14
Snorm16x4
=
15
Float16x2
=
16
Float16x4
=
17
Float32
=
18
Float32x2
=
19
Float32x3
=
20
Float32x4
=
21
Uint32
=
22
Uint32x2
=
23
Uint32x3
=
24
Uint32x4
=
25
Sint32
=
26
Sint32x2
=
27
Sint32x3
=
28
Sint32x4
=
29
Float64
=
30
Float64x2
=
31
Float64x3
=
32
Float64x4
=
33
}
impl
VertexFormat
{
pub
const
fn
size
(
&
self
)
-
>
u64
{
match
self
{
Self
:
:
Uint8x2
|
Self
:
:
Sint8x2
|
Self
:
:
Unorm8x2
|
Self
:
:
Snorm8x2
=
>
2
Self
:
:
Uint8x4
|
Self
:
:
Sint8x4
|
Self
:
:
Unorm8x4
|
Self
:
:
Snorm8x4
|
Self
:
:
Uint16x2
|
Self
:
:
Sint16x2
|
Self
:
:
Unorm16x2
|
Self
:
:
Snorm16x2
|
Self
:
:
Float16x2
|
Self
:
:
Float32
|
Self
:
:
Uint32
|
Self
:
:
Sint32
=
>
4
Self
:
:
Uint16x4
|
Self
:
:
Sint16x4
|
Self
:
:
Unorm16x4
|
Self
:
:
Snorm16x4
|
Self
:
:
Float16x4
|
Self
:
:
Float32x2
|
Self
:
:
Uint32x2
|
Self
:
:
Sint32x2
|
Self
:
:
Float64
=
>
8
Self
:
:
Float32x3
|
Self
:
:
Uint32x3
|
Self
:
:
Sint32x3
=
>
12
Self
:
:
Float32x4
|
Self
:
:
Uint32x4
|
Self
:
:
Sint32x4
|
Self
:
:
Float64x2
=
>
16
Self
:
:
Float64x3
=
>
24
Self
:
:
Float64x4
=
>
32
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
buffer
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
buffer
is
allocated
from
and
what
/
/
/
actions
the
buffer
can
partake
in
.
/
/
/
/
/
/
Corresponds
to
[
WebGPU
GPUBufferUsageFlags
]
(
/
/
/
https
:
/
/
gpuweb
.
github
.
io
/
gpuweb
/
#
typedefdef
-
gpubufferusageflags
)
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
BufferUsages
:
u32
{
/
/
/
Allow
a
buffer
to
be
mapped
for
reading
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
[
BufferDescriptor
:
:
mapped_at_creation
]
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_DST
.
const
MAP_READ
=
1
<
<
0
;
/
/
/
Allow
a
buffer
to
be
mapped
for
writing
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range_mut
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
mapped_at_creation
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
feature
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_SRC
.
const
MAP_WRITE
=
1
<
<
1
;
/
/
/
Allow
a
buffer
to
be
the
source
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
or
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
operation
.
const
COPY_SRC
=
1
<
<
2
;
/
/
/
Allow
a
buffer
to
be
the
destination
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
[
CommandEncoder
:
:
copy_texture_to_buffer
]
/
/
/
[
CommandEncoder
:
:
clear_buffer
]
or
[
Queue
:
:
write_buffer
]
operation
.
const
COPY_DST
=
1
<
<
3
;
/
/
/
Allow
a
buffer
to
be
the
index
buffer
in
a
draw
operation
.
const
INDEX
=
1
<
<
4
;
/
/
/
Allow
a
buffer
to
be
the
vertex
buffer
in
a
draw
operation
.
const
VERTEX
=
1
<
<
5
;
/
/
/
Allow
a
buffer
to
be
a
[
BufferBindingType
:
:
Uniform
]
inside
a
bind
group
.
const
UNIFORM
=
1
<
<
6
;
/
/
/
Allow
a
buffer
to
be
a
[
BufferBindingType
:
:
Storage
]
inside
a
bind
group
.
const
STORAGE
=
1
<
<
7
;
/
/
/
Allow
a
buffer
to
be
the
indirect
buffer
in
an
indirect
draw
call
.
const
INDIRECT
=
1
<
<
8
;
/
/
/
Allow
a
buffer
to
be
the
destination
buffer
for
a
[
CommandEncoder
:
:
resolve_query_set
]
operation
.
const
QUERY_RESOLVE
=
1
<
<
9
;
}
}
impl_bitflags
!
(
BufferUsages
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BufferDescriptor
<
L
>
{
pub
label
:
L
pub
size
:
BufferAddress
pub
usage
:
BufferUsages
pub
mapped_at_creation
:
bool
}
impl
<
L
>
BufferDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
BufferDescriptor
<
K
>
{
BufferDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
usage
:
self
.
usage
mapped_at_creation
:
self
.
mapped_at_creation
}
}
}
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
CommandEncoderDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandEncoderDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandEncoderDescriptor
<
K
>
{
CommandEncoderDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
CommandEncoderDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PresentMode
{
AutoVsync
=
0
AutoNoVsync
=
1
#
[
default
]
Fifo
=
2
FifoRelaxed
=
3
Immediate
=
4
Mailbox
=
5
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
enum
CompositeAlphaMode
{
Auto
=
0
Opaque
=
1
PreMultiplied
=
2
PostMultiplied
=
3
Inherit
=
4
}
impl
Default
for
CompositeAlphaMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
Auto
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
texture
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
texture
is
allocated
from
and
what
/
/
/
actions
the
texture
can
partake
in
.
/
/
/
/
/
/
Corresponds
to
[
WebGPU
GPUTextureUsageFlags
]
(
/
/
/
https
:
/
/
gpuweb
.
github
.
io
/
gpuweb
/
#
typedefdef
-
gputextureusageflags
)
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
TextureUsages
:
u32
{
/
/
/
Allows
a
texture
to
be
the
source
in
a
[
CommandEncoder
:
:
copy_texture_to_buffer
]
or
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
operation
.
const
COPY_SRC
=
1
<
<
0
;
/
/
/
Allows
a
texture
to
be
the
destination
in
a
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
or
[
Queue
:
:
write_texture
]
operation
.
const
COPY_DST
=
1
<
<
1
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
Texture
]
in
a
bind
group
.
const
TEXTURE_BINDING
=
1
<
<
2
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
StorageTexture
]
in
a
bind
group
.
const
STORAGE_BINDING
=
1
<
<
3
;
/
/
/
Allows
a
texture
to
be
an
output
attachment
of
a
render
pass
.
const
RENDER_ATTACHMENT
=
1
<
<
4
;
}
}
impl_bitflags
!
(
TextureUsages
)
;
#
[
derive
(
Debug
)
]
pub
struct
SurfaceCapabilities
{
pub
formats
:
Vec
<
TextureFormat
>
pub
present_modes
:
Vec
<
PresentMode
>
pub
alpha_modes
:
Vec
<
CompositeAlphaMode
>
}
impl
Default
for
SurfaceCapabilities
{
fn
default
(
)
-
>
Self
{
Self
{
formats
:
Vec
:
:
new
(
)
present_modes
:
Vec
:
:
new
(
)
alpha_modes
:
vec
!
[
CompositeAlphaMode
:
:
Opaque
]
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceConfiguration
<
V
>
{
pub
usage
:
TextureUsages
pub
format
:
TextureFormat
pub
width
:
u32
pub
height
:
u32
pub
present_mode
:
PresentMode
pub
alpha_mode
:
CompositeAlphaMode
pub
view_formats
:
V
}
impl
<
V
:
Clone
>
SurfaceConfiguration
<
V
>
{
pub
fn
map_view_formats
<
M
>
(
&
self
fun
:
impl
FnOnce
(
V
)
-
>
M
)
-
>
SurfaceConfiguration
<
M
>
{
SurfaceConfiguration
{
usage
:
self
.
usage
format
:
self
.
format
width
:
self
.
width
height
:
self
.
height
present_mode
:
self
.
present_mode
alpha_mode
:
self
.
alpha_mode
view_formats
:
fun
(
self
.
view_formats
.
clone
(
)
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
enum
SurfaceStatus
{
Good
Suboptimal
Timeout
Outdated
Lost
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
PresentationTimestamp
(
pub
u128
)
;
impl
PresentationTimestamp
{
pub
const
INVALID_TIMESTAMP
:
Self
=
Self
(
u128
:
:
MAX
)
;
pub
fn
is_invalid
(
self
)
-
>
bool
{
self
=
=
Self
:
:
INVALID_TIMESTAMP
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Color
{
pub
r
:
f64
pub
g
:
f64
pub
b
:
f64
pub
a
:
f64
}
#
[
allow
(
missing_docs
)
]
impl
Color
{
pub
const
TRANSPARENT
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
0
.
0
}
;
pub
const
BLACK
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
WHITE
:
Self
=
Self
{
r
:
1
.
0
g
:
1
.
0
b
:
1
.
0
a
:
1
.
0
}
;
pub
const
RED
:
Self
=
Self
{
r
:
1
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
GREEN
:
Self
=
Self
{
r
:
0
.
0
g
:
1
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
BLUE
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
1
.
0
a
:
1
.
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureDimension
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
1d
"
)
)
]
D1
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
2d
"
)
)
]
D2
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename
=
"
3d
"
)
)
]
D3
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Origin2d
{
pub
x
:
u32
pub
y
:
u32
}
impl
Origin2d
{
pub
const
ZERO
:
Self
=
Self
{
x
:
0
y
:
0
}
;
pub
fn
to_3d
(
self
z
:
u32
)
-
>
Origin3d
{
Origin3d
{
x
:
self
.
x
y
:
self
.
y
z
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Origin3d
{
pub
x
:
u32
pub
y
:
u32
pub
z
:
u32
}
impl
Origin3d
{
pub
const
ZERO
:
Self
=
Self
{
x
:
0
y
:
0
z
:
0
}
;
pub
fn
to_2d
(
self
)
-
>
Origin2d
{
Origin2d
{
x
:
self
.
x
y
:
self
.
y
}
}
}
impl
Default
for
Origin3d
{
fn
default
(
)
-
>
Self
{
Self
:
:
ZERO
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
camelCase
"
)
)
]
pub
struct
Extent3d
{
pub
width
:
u32
pub
height
:
u32
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
=
"
default_depth
"
)
)
]
pub
depth_or_array_layers
:
u32
}
#
[
cfg
(
feature
=
"
serde
"
)
]
fn
default_depth
(
)
-
>
u32
{
1
}
impl
Default
for
Extent3d
{
fn
default
(
)
-
>
Self
{
Self
{
width
:
1
height
:
1
depth_or_array_layers
:
1
}
}
}
impl
Extent3d
{
pub
fn
physical_size
(
&
self
format
:
TextureFormat
)
-
>
Self
{
let
(
block_width
block_height
)
=
format
.
block_dimensions
(
)
;
let
width
=
(
(
self
.
width
+
block_width
-
1
)
/
block_width
)
*
block_width
;
let
height
=
(
(
self
.
height
+
block_height
-
1
)
/
block_height
)
*
block_height
;
Self
{
width
height
depth_or_array_layers
:
self
.
depth_or_array_layers
}
}
pub
fn
max_mips
(
&
self
dim
:
TextureDimension
)
-
>
u32
{
match
dim
{
TextureDimension
:
:
D1
=
>
1
TextureDimension
:
:
D2
=
>
{
let
max_dim
=
self
.
width
.
max
(
self
.
height
)
;
32
-
max_dim
.
leading_zeros
(
)
}
TextureDimension
:
:
D3
=
>
{
let
max_dim
=
self
.
width
.
max
(
self
.
height
.
max
(
self
.
depth_or_array_layers
)
)
;
32
-
max_dim
.
leading_zeros
(
)
}
}
}
pub
fn
mip_level_size
(
&
self
level
:
u32
dim
:
TextureDimension
)
-
>
Self
{
Self
{
width
:
u32
:
:
max
(
1
self
.
width
>
>
level
)
height
:
match
dim
{
TextureDimension
:
:
D1
=
>
1
_
=
>
u32
:
:
max
(
1
self
.
height
>
>
level
)
}
depth_or_array_layers
:
match
dim
{
TextureDimension
:
:
D1
=
>
1
TextureDimension
:
:
D2
=
>
self
.
depth_or_array_layers
TextureDimension
:
:
D3
=
>
u32
:
:
max
(
1
self
.
depth_or_array_layers
>
>
level
)
}
}
}
}
#
[
test
]
fn
test_physical_size
(
)
{
let
format
=
TextureFormat
:
:
Bc1RgbaUnormSrgb
;
assert_eq
!
(
Extent3d
{
width
:
7
height
:
7
depth_or_array_layers
:
1
}
.
physical_size
(
format
)
Extent3d
{
width
:
8
height
:
8
depth_or_array_layers
:
1
}
)
;
assert_eq
!
(
Extent3d
{
width
:
8
height
:
8
depth_or_array_layers
:
1
}
.
physical_size
(
format
)
Extent3d
{
width
:
8
height
:
8
depth_or_array_layers
:
1
}
)
;
let
format
=
TextureFormat
:
:
Astc
{
block
:
AstcBlock
:
:
B8x5
channel
:
AstcChannel
:
:
Unorm
}
;
assert_eq
!
(
Extent3d
{
width
:
7
height
:
7
depth_or_array_layers
:
1
}
.
physical_size
(
format
)
Extent3d
{
width
:
8
height
:
10
depth_or_array_layers
:
1
}
)
;
}
#
[
test
]
fn
test_max_mips
(
)
{
assert_eq
!
(
Extent3d
{
width
:
240
height
:
1
depth_or_array_layers
:
1
}
.
max_mips
(
TextureDimension
:
:
D1
)
1
)
;
assert_eq
!
(
Extent3d
{
width
:
1
height
:
1
depth_or_array_layers
:
1
}
.
max_mips
(
TextureDimension
:
:
D2
)
1
)
;
assert_eq
!
(
Extent3d
{
width
:
60
height
:
60
depth_or_array_layers
:
1
}
.
max_mips
(
TextureDimension
:
:
D2
)
6
)
;
assert_eq
!
(
Extent3d
{
width
:
240
height
:
1
depth_or_array_layers
:
1000
}
.
max_mips
(
TextureDimension
:
:
D2
)
8
)
;
assert_eq
!
(
Extent3d
{
width
:
16
height
:
30
depth_or_array_layers
:
60
}
.
max_mips
(
TextureDimension
:
:
D3
)
6
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureDescriptor
<
L
V
>
{
pub
label
:
L
pub
size
:
Extent3d
pub
mip_level_count
:
u32
pub
sample_count
:
u32
pub
dimension
:
TextureDimension
pub
format
:
TextureFormat
pub
usage
:
TextureUsages
pub
view_formats
:
V
}
impl
<
L
V
>
TextureDescriptor
<
L
V
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
TextureDescriptor
<
K
V
>
where
V
:
Clone
{
TextureDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
mip_level_count
:
self
.
mip_level_count
sample_count
:
self
.
sample_count
dimension
:
self
.
dimension
format
:
self
.
format
usage
:
self
.
usage
view_formats
:
self
.
view_formats
.
clone
(
)
}
}
pub
fn
map_label_and_view_formats
<
K
M
>
(
&
self
l_fun
:
impl
FnOnce
(
&
L
)
-
>
K
v_fun
:
impl
FnOnce
(
V
)
-
>
M
)
-
>
TextureDescriptor
<
K
M
>
where
V
:
Clone
{
TextureDescriptor
{
label
:
l_fun
(
&
self
.
label
)
size
:
self
.
size
mip_level_count
:
self
.
mip_level_count
sample_count
:
self
.
sample_count
dimension
:
self
.
dimension
format
:
self
.
format
usage
:
self
.
usage
view_formats
:
v_fun
(
self
.
view_formats
.
clone
(
)
)
}
}
pub
fn
mip_level_size
(
&
self
level
:
u32
)
-
>
Option
<
Extent3d
>
{
if
level
>
=
self
.
mip_level_count
{
return
None
;
}
Some
(
self
.
size
.
mip_level_size
(
level
self
.
dimension
)
)
}
pub
fn
compute_render_extent
(
&
self
mip_level
:
u32
)
-
>
Extent3d
{
Extent3d
{
width
:
u32
:
:
max
(
1
self
.
size
.
width
>
>
mip_level
)
height
:
u32
:
:
max
(
1
self
.
size
.
height
>
>
mip_level
)
depth_or_array_layers
:
1
}
}
pub
fn
array_layer_count
(
&
self
)
-
>
u32
{
match
self
.
dimension
{
TextureDimension
:
:
D1
|
TextureDimension
:
:
D3
=
>
1
TextureDimension
:
:
D2
=
>
self
.
size
.
depth_or_array_layers
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
TextureAspect
{
#
[
default
]
All
StencilOnly
DepthOnly
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
AddressMode
{
#
[
default
]
ClampToEdge
=
0
Repeat
=
1
MirrorRepeat
=
2
ClampToBorder
=
3
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Default
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
FilterMode
{
#
[
default
]
Nearest
=
0
Linear
=
1
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PushConstantRange
{
pub
stages
:
ShaderStages
pub
range
:
Range
<
u32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CommandBufferDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandBufferDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandBufferDescriptor
<
K
>
{
CommandBufferDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
RenderBundleDepthStencil
{
pub
format
:
TextureFormat
pub
depth_read_only
:
bool
pub
stencil_read_only
:
bool
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderBundleDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
RenderBundleDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
RenderBundleDescriptor
<
K
>
{
RenderBundleDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
RenderBundleDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageDataLayout
{
pub
offset
:
BufferAddress
pub
bytes_per_row
:
Option
<
u32
>
pub
rows_per_image
:
Option
<
u32
>
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BufferBindingType
{
#
[
default
]
Uniform
Storage
{
read_only
:
bool
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureSampleType
{
Float
{
filterable
:
bool
}
Depth
Sint
Uint
}
impl
Default
for
TextureSampleType
{
fn
default
(
)
-
>
Self
{
Self
:
:
Float
{
filterable
:
true
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
StorageTextureAccess
{
WriteOnly
ReadOnly
ReadWrite
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
SamplerBindingType
{
Filtering
NonFiltering
Comparison
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BindingType
{
Buffer
{
ty
:
BufferBindingType
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
has_dynamic_offset
:
bool
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
min_binding_size
:
Option
<
BufferSize
>
}
Sampler
(
SamplerBindingType
)
Texture
{
sample_type
:
TextureSampleType
view_dimension
:
TextureViewDimension
multisampled
:
bool
}
StorageTexture
{
access
:
StorageTextureAccess
format
:
TextureFormat
view_dimension
:
TextureViewDimension
}
}
impl
BindingType
{
pub
fn
has_dynamic_offset
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Buffer
{
has_dynamic_offset
.
.
}
=
>
has_dynamic_offset
_
=
>
false
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BindGroupLayoutEntry
{
pub
binding
:
u32
pub
visibility
:
ShaderStages
pub
ty
:
BindingType
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
count
:
Option
<
NonZeroU32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageCopyBuffer
<
B
>
{
pub
buffer
:
B
pub
layout
:
ImageDataLayout
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageCopyTexture
<
T
>
{
pub
texture
:
T
pub
mip_level
:
u32
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
origin
:
Origin3d
#
[
cfg_attr
(
any
(
feature
=
"
trace
"
feature
=
"
replay
"
)
serde
(
default
)
)
]
pub
aspect
:
TextureAspect
}
impl
<
T
>
ImageCopyTexture
<
T
>
{
pub
fn
to_tagged
(
self
color_space
:
PredefinedColorSpace
premultiplied_alpha
:
bool
)
-
>
ImageCopyTextureTagged
<
T
>
{
ImageCopyTextureTagged
{
texture
:
self
.
texture
mip_level
:
self
.
mip_level
origin
:
self
.
origin
aspect
:
self
.
aspect
color_space
premultiplied_alpha
}
}
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
ImageCopyExternalImage
{
pub
source
:
ExternalImageSource
pub
origin
:
Origin2d
pub
flip_y
:
bool
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
#
[
derive
(
Clone
Debug
)
]
pub
enum
ExternalImageSource
{
ImageBitmap
(
web_sys
:
:
ImageBitmap
)
HTMLVideoElement
(
web_sys
:
:
HtmlVideoElement
)
HTMLCanvasElement
(
web_sys
:
:
HtmlCanvasElement
)
OffscreenCanvas
(
web_sys
:
:
OffscreenCanvas
)
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
impl
ExternalImageSource
{
pub
fn
width
(
&
self
)
-
>
u32
{
match
self
{
ExternalImageSource
:
:
ImageBitmap
(
b
)
=
>
b
.
width
(
)
ExternalImageSource
:
:
HTMLVideoElement
(
v
)
=
>
v
.
video_width
(
)
ExternalImageSource
:
:
HTMLCanvasElement
(
c
)
=
>
c
.
width
(
)
ExternalImageSource
:
:
OffscreenCanvas
(
c
)
=
>
c
.
width
(
)
}
}
pub
fn
height
(
&
self
)
-
>
u32
{
match
self
{
ExternalImageSource
:
:
ImageBitmap
(
b
)
=
>
b
.
height
(
)
ExternalImageSource
:
:
HTMLVideoElement
(
v
)
=
>
v
.
video_height
(
)
ExternalImageSource
:
:
HTMLCanvasElement
(
c
)
=
>
c
.
height
(
)
ExternalImageSource
:
:
OffscreenCanvas
(
c
)
=
>
c
.
height
(
)
}
}
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
impl
std
:
:
ops
:
:
Deref
for
ExternalImageSource
{
type
Target
=
js_sys
:
:
Object
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
match
self
{
Self
:
:
ImageBitmap
(
b
)
=
>
b
Self
:
:
HTMLVideoElement
(
v
)
=
>
v
Self
:
:
HTMLCanvasElement
(
c
)
=
>
c
Self
:
:
OffscreenCanvas
(
c
)
=
>
c
}
}
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
unsafe
impl
Send
for
ExternalImageSource
{
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
unsafe
impl
Sync
for
ExternalImageSource
{
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PredefinedColorSpace
{
Srgb
DisplayP3
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageCopyTextureTagged
<
T
>
{
pub
texture
:
T
pub
mip_level
:
u32
pub
origin
:
Origin3d
pub
aspect
:
TextureAspect
pub
color_space
:
PredefinedColorSpace
pub
premultiplied_alpha
:
bool
}
impl
<
T
:
Copy
>
ImageCopyTextureTagged
<
T
>
{
pub
fn
to_untagged
(
self
)
-
>
ImageCopyTexture
<
T
>
{
ImageCopyTexture
{
texture
:
self
.
texture
mip_level
:
self
.
mip_level
origin
:
self
.
origin
aspect
:
self
.
aspect
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ImageSubresourceRange
{
pub
aspect
:
TextureAspect
pub
base_mip_level
:
u32
pub
mip_level_count
:
Option
<
u32
>
pub
base_array_layer
:
u32
pub
array_layer_count
:
Option
<
u32
>
}
impl
ImageSubresourceRange
{
pub
fn
is_full_resource
(
&
self
format
:
TextureFormat
mip_levels
:
u32
array_layers
:
u32
)
-
>
bool
{
let
mip_level_count
=
self
.
mip_level_count
.
unwrap_or
(
mip_levels
)
;
let
array_layer_count
=
self
.
array_layer_count
.
unwrap_or
(
array_layers
)
;
let
aspect_eq
=
Some
(
format
)
=
=
format
.
aspect_specific_format
(
self
.
aspect
)
;
let
base_mip_level_eq
=
self
.
base_mip_level
=
=
0
;
let
mip_level_count_eq
=
mip_level_count
=
=
mip_levels
;
let
base_array_layer_eq
=
self
.
base_array_layer
=
=
0
;
let
array_layer_count_eq
=
array_layer_count
=
=
array_layers
;
aspect_eq
&
&
base_mip_level_eq
&
&
mip_level_count_eq
&
&
base_array_layer_eq
&
&
array_layer_count_eq
}
pub
fn
mip_range
(
&
self
mip_level_count
:
u32
)
-
>
Range
<
u32
>
{
self
.
base_mip_level
.
.
match
self
.
mip_level_count
{
Some
(
mip_level_count
)
=
>
self
.
base_mip_level
+
mip_level_count
None
=
>
mip_level_count
}
}
pub
fn
layer_range
(
&
self
array_layer_count
:
u32
)
-
>
Range
<
u32
>
{
self
.
base_array_layer
.
.
match
self
.
array_layer_count
{
Some
(
array_layer_count
)
=
>
self
.
base_array_layer
+
array_layer_count
None
=
>
array_layer_count
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
SamplerBorderColor
{
TransparentBlack
OpaqueBlack
OpaqueWhite
Zero
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
QuerySetDescriptor
<
L
>
{
pub
label
:
L
pub
ty
:
QueryType
pub
count
:
u32
}
impl
<
L
>
QuerySetDescriptor
<
L
>
{
pub
fn
map_label
<
'
a
K
>
(
&
'
a
self
fun
:
impl
FnOnce
(
&
'
a
L
)
-
>
K
)
-
>
QuerySetDescriptor
<
K
>
{
QuerySetDescriptor
{
label
:
fun
(
&
self
.
label
)
ty
:
self
.
ty
count
:
self
.
count
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
QueryType
{
Occlusion
PipelineStatistics
(
PipelineStatisticsTypes
)
Timestamp
}
bitflags
:
:
bitflags
!
{
/
/
/
Flags
for
which
pipeline
data
should
be
recorded
.
/
/
/
/
/
/
The
amount
of
values
written
when
resolved
depends
/
/
/
on
the
amount
of
flags
.
If
3
flags
are
enabled
3
/
/
/
64
-
bit
values
will
be
written
per
-
query
.
/
/
/
/
/
/
The
order
they
are
written
is
the
order
they
are
declared
/
/
/
in
this
bitflags
.
If
you
enabled
CLIPPER_PRIMITIVES_OUT
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
PipelineStatisticsTypes
:
u8
{
/
/
/
Amount
of
times
the
vertex
shader
is
ran
.
Accounts
for
/
/
/
the
vertex
cache
when
doing
indexed
rendering
.
const
VERTEX_SHADER_INVOCATIONS
=
1
<
<
0
;
/
/
/
Amount
of
times
the
clipper
is
invoked
.
This
/
/
/
is
also
the
amount
of
triangles
output
by
the
vertex
shader
.
const
CLIPPER_INVOCATIONS
=
1
<
<
1
;
/
/
/
Amount
of
primitives
that
are
not
culled
by
the
clipper
.
/
/
/
This
is
the
amount
of
triangles
that
are
actually
on
screen
/
/
/
and
will
be
rasterized
and
rendered
.
const
CLIPPER_PRIMITIVES_OUT
=
1
<
<
2
;
/
/
/
Amount
of
times
the
fragment
shader
is
ran
.
Accounts
for
/
/
/
fragment
shaders
running
in
2x2
blocks
in
order
to
get
/
/
/
derivatives
.
const
FRAGMENT_SHADER_INVOCATIONS
=
1
<
<
3
;
/
/
/
Amount
of
times
a
compute
shader
is
invoked
.
This
will
/
/
/
be
equivalent
to
the
dispatch
count
times
the
workgroup
size
.
const
COMPUTE_SHADER_INVOCATIONS
=
1
<
<
4
;
}
}
impl_bitflags
!
(
PipelineStatisticsTypes
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DrawIndirectArgs
{
pub
vertex_count
:
u32
pub
instance_count
:
u32
pub
first_vertex
:
u32
pub
first_instance
:
u32
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DrawIndexedIndirectArgs
{
pub
index_count
:
u32
pub
instance_count
:
u32
pub
first_index
:
u32
pub
base_vertex
:
i32
pub
first_instance
:
u32
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
DispatchIndirectArgs
{
pub
group_size_x
:
u32
pub
group_size_y
:
u32
pub
group_size_z
:
u32
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
ShaderBoundChecks
{
runtime_checks
:
bool
}
impl
ShaderBoundChecks
{
pub
fn
new
(
)
-
>
Self
{
ShaderBoundChecks
{
runtime_checks
:
true
}
}
pub
unsafe
fn
unchecked
(
)
-
>
Self
{
ShaderBoundChecks
{
runtime_checks
:
false
}
}
pub
fn
runtime_checks
(
&
self
)
-
>
bool
{
self
.
runtime_checks
}
}
impl
Default
for
ShaderBoundChecks
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
enum
Dx12Compiler
{
#
[
default
]
Fxc
Dxc
{
dxil_path
:
Option
<
PathBuf
>
dxc_path
:
Option
<
PathBuf
>
}
}
pub
struct
InstanceDescriptor
{
pub
backends
:
Backends
pub
dx12_shader_compiler
:
Dx12Compiler
}
impl
Default
for
InstanceDescriptor
{
fn
default
(
)
-
>
Self
{
Self
{
backends
:
Backends
:
:
all
(
)
dx12_shader_compiler
:
Dx12Compiler
:
:
default
(
)
}
}
}
