use
alloc
:
:
string
:
:
String
;
use
core
:
:
{
fmt
mem
}
;
use
crate
:
:
{
link_to_wgpu_docs
Backend
Backends
}
;
#
[
cfg
(
any
(
feature
=
"
serde
"
test
)
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
cfg
(
doc
)
]
use
crate
:
:
{
Features
TextureUsages
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
RequestAdapterOptions
<
S
>
{
pub
power_preference
:
PowerPreference
pub
force_fallback_adapter
:
bool
pub
compatible_surface
:
Option
<
S
>
}
impl
<
S
>
Default
for
RequestAdapterOptions
<
S
>
{
fn
default
(
)
-
>
Self
{
Self
{
power_preference
:
PowerPreference
:
:
default
(
)
force_fallback_adapter
:
false
compatible_surface
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
Default
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
rename_all
=
"
kebab
-
case
"
)
)
]
pub
enum
PowerPreference
{
#
[
default
]
None
=
0
LowPower
=
1
HighPerformance
=
2
}
impl
PowerPreference
{
pub
fn
from_env
(
)
-
>
Option
<
Self
>
{
let
env
=
crate
:
:
env
:
:
var
(
"
WGPU_POWER_PREF
"
)
?
;
match
env
.
to_lowercase
(
)
.
as_str
(
)
{
"
low
"
=
>
Some
(
Self
:
:
LowPower
)
"
high
"
=
>
Some
(
Self
:
:
HighPerformance
)
"
none
"
=
>
Some
(
Self
:
:
None
)
_
=
>
None
}
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
DeviceType
{
Other
IntegratedGpu
DiscreteGpu
VirtualGpu
Cpu
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
AdapterInfo
{
pub
name
:
String
pub
vendor
:
u32
pub
device
:
u32
pub
device_type
:
DeviceType
pub
device_pci_bus_id
:
String
pub
driver
:
String
pub
driver_info
:
String
pub
backend
:
Backend
pub
subgroup_min_size
:
u32
pub
subgroup_max_size
:
u32
pub
transient_saves_memory
:
bool
}
#
[
doc
=
link_to_wgpu_docs
!
(
[
"
Instance
:
:
request_adapter
(
)
"
]
:
"
struct
.
Instance
.
html
#
method
.
request_adapter
"
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
enum
RequestAdapterError
{
NotFound
{
#
[
doc
(
hidden
)
]
active_backends
:
Backends
#
[
doc
(
hidden
)
]
requested_backends
:
Backends
#
[
doc
(
hidden
)
]
supported_backends
:
Backends
#
[
doc
(
hidden
)
]
no_fallback_backends
:
Backends
#
[
doc
(
hidden
)
]
no_adapter_backends
:
Backends
#
[
doc
(
hidden
)
]
incompatible_surface_backends
:
Backends
}
EnvNotSet
}
impl
core
:
:
error
:
:
Error
for
RequestAdapterError
{
}
impl
fmt
:
:
Display
for
RequestAdapterError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
RequestAdapterError
:
:
NotFound
{
active_backends
requested_backends
supported_backends
no_fallback_backends
no_adapter_backends
incompatible_surface_backends
}
=
>
{
write
!
(
f
"
No
suitable
graphics
adapter
found
;
"
)
?
;
let
mut
first
=
true
;
for
backend
in
Backend
:
:
ALL
{
let
bit
=
Backends
:
:
from
(
backend
)
;
let
comma
=
if
mem
:
:
take
(
&
mut
first
)
{
"
"
}
else
{
"
"
}
;
let
explanation
=
if
!
requested_backends
.
contains
(
bit
)
{
"
not
requested
"
}
else
if
!
supported_backends
.
contains
(
bit
)
{
"
support
not
compiled
in
"
}
else
if
no_adapter_backends
.
contains
(
bit
)
{
"
found
no
adapters
"
}
else
if
incompatible_surface_backends
.
contains
(
bit
)
{
"
not
compatible
with
provided
surface
"
}
else
if
no_fallback_backends
.
contains
(
bit
)
{
"
had
no
fallback
adapters
"
}
else
if
!
active_backends
.
contains
(
bit
)
{
if
backend
=
=
Backend
:
:
Noop
{
"
not
explicitly
enabled
"
}
else
{
"
drivers
/
libraries
could
not
be
loaded
"
}
}
else
{
"
[
unknown
reason
]
"
}
;
write
!
(
f
"
{
comma
}
{
backend
}
{
explanation
}
"
)
?
;
}
}
RequestAdapterError
:
:
EnvNotSet
=
>
f
.
write_str
(
"
WGPU_ADAPTER_NAME
not
set
"
)
?
}
Ok
(
(
)
)
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
enum
CooperativeScalarType
{
F32
F16
I32
U32
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
PartialEq
)
]
pub
struct
CooperativeMatrixProperties
{
pub
m_size
:
u32
pub
n_size
:
u32
pub
k_size
:
u32
pub
ab_type
:
CooperativeScalarType
pub
cr_type
:
CooperativeScalarType
pub
saturating_accumulation
:
bool
}
