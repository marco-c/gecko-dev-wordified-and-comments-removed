use
alloc
:
:
{
borrow
:
:
Cow
string
:
:
String
}
;
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
ShaderRuntimeChecks
{
pub
bounds_checks
:
bool
pub
force_loop_bounding
:
bool
pub
ray_query_initialization_tracking
:
bool
}
impl
ShaderRuntimeChecks
{
#
[
must_use
]
pub
const
fn
checked
(
)
-
>
Self
{
unsafe
{
Self
:
:
all
(
true
)
}
}
#
[
must_use
]
pub
const
fn
unchecked
(
)
-
>
Self
{
unsafe
{
Self
:
:
all
(
false
)
}
}
#
[
must_use
]
pub
const
unsafe
fn
all
(
all_checks
:
bool
)
-
>
Self
{
Self
{
bounds_checks
:
all_checks
force_loop_bounding
:
all_checks
ray_query_initialization_tracking
:
all_checks
}
}
}
impl
Default
for
ShaderRuntimeChecks
{
fn
default
(
)
-
>
Self
{
Self
:
:
checked
(
)
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
CreateShaderModuleDescriptorPassthrough
<
'
a
L
>
{
pub
entry_point
:
String
pub
label
:
L
pub
num_workgroups
:
(
u32
u32
u32
)
pub
runtime_checks
:
ShaderRuntimeChecks
pub
spirv
:
Option
<
Cow
<
'
a
[
u32
]
>
>
pub
dxil
:
Option
<
Cow
<
'
a
[
u8
]
>
>
pub
msl
:
Option
<
Cow
<
'
a
str
>
>
pub
hlsl
:
Option
<
Cow
<
'
a
str
>
>
pub
glsl
:
Option
<
Cow
<
'
a
str
>
>
pub
wgsl
:
Option
<
Cow
<
'
a
str
>
>
}
impl
<
'
a
L
:
Default
>
Default
for
CreateShaderModuleDescriptorPassthrough
<
'
a
L
>
{
fn
default
(
)
-
>
Self
{
Self
{
entry_point
:
"
"
.
into
(
)
label
:
Default
:
:
default
(
)
num_workgroups
:
(
0
0
0
)
runtime_checks
:
ShaderRuntimeChecks
:
:
unchecked
(
)
spirv
:
None
dxil
:
None
msl
:
None
hlsl
:
None
glsl
:
None
wgsl
:
None
}
}
}
impl
<
'
a
L
>
CreateShaderModuleDescriptorPassthrough
<
'
a
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CreateShaderModuleDescriptorPassthrough
<
'
a
K
>
{
CreateShaderModuleDescriptorPassthrough
{
entry_point
:
self
.
entry_point
.
clone
(
)
label
:
fun
(
&
self
.
label
)
num_workgroups
:
self
.
num_workgroups
runtime_checks
:
self
.
runtime_checks
spirv
:
self
.
spirv
.
clone
(
)
dxil
:
self
.
dxil
.
clone
(
)
msl
:
self
.
msl
.
clone
(
)
hlsl
:
self
.
hlsl
.
clone
(
)
glsl
:
self
.
glsl
.
clone
(
)
wgsl
:
self
.
wgsl
.
clone
(
)
}
}
#
[
cfg
(
feature
=
"
trace
"
)
]
pub
fn
trace_data
(
&
self
)
-
>
&
[
u8
]
{
if
let
Some
(
spirv
)
=
&
self
.
spirv
{
bytemuck
:
:
cast_slice
(
spirv
)
}
else
if
let
Some
(
msl
)
=
&
self
.
msl
{
msl
.
as_bytes
(
)
}
else
if
let
Some
(
dxil
)
=
&
self
.
dxil
{
dxil
}
else
{
panic
!
(
"
No
binary
data
provided
to
ShaderModuleDescriptorGeneric
"
)
}
}
#
[
cfg
(
feature
=
"
trace
"
)
]
pub
fn
trace_binary_ext
(
&
self
)
-
>
&
'
static
str
{
if
self
.
spirv
.
is_some
(
)
{
"
spv
"
}
else
if
self
.
msl
.
is_some
(
)
{
"
msl
"
}
else
if
self
.
dxil
.
is_some
(
)
{
"
dxil
"
}
else
{
panic
!
(
"
No
binary
data
provided
to
ShaderModuleDescriptorGeneric
"
)
}
}
}
