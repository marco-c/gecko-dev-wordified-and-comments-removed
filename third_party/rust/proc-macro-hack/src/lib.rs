#
!
[
recursion_limit
=
"
512
"
]
#
!
[
allow
(
clippy
:
:
needless_doctest_main
clippy
:
:
toplevel_ref_arg
)
]
extern
crate
proc_macro
;
#
[
macro_use
]
mod
quote
;
mod
error
;
mod
iter
;
mod
parse
;
use
crate
:
:
error
:
:
{
compile_error
Error
}
;
use
crate
:
:
iter
:
:
Iter
;
use
crate
:
:
parse
:
:
{
parse_define_args
parse_enum_hack
parse_export_args
parse_fake_call_site
parse_input
}
;
use
proc_macro
:
:
{
Ident
Punct
Spacing
Span
TokenStream
TokenTree
}
;
use
std
:
:
fmt
:
:
Write
;
type
Visibility
=
Option
<
Ident
>
;
enum
Input
{
Export
(
Export
)
Define
(
Define
)
}
struct
Export
{
attrs
:
TokenStream
vis
:
Visibility
from
:
Ident
macros
:
Vec
<
Macro
>
}
struct
Define
{
attrs
:
TokenStream
name
:
Ident
body
:
TokenStream
}
struct
Macro
{
name
:
Ident
export_as
:
Ident
}
#
[
proc_macro_attribute
]
pub
fn
proc_macro_hack
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
ref
mut
args
=
iter
:
:
new
(
args
)
;
let
ref
mut
input
=
iter
:
:
new
(
input
)
;
expand_proc_macro_hack
(
args
input
)
.
unwrap_or_else
(
compile_error
)
}
fn
expand_proc_macro_hack
(
args
:
Iter
input
:
Iter
)
-
>
Result
<
TokenStream
Error
>
{
match
parse_input
(
input
)
?
{
Input
:
:
Export
(
export
)
=
>
{
let
args
=
parse_export_args
(
args
)
?
;
Ok
(
expand_export
(
export
args
)
)
}
Input
:
:
Define
(
define
)
=
>
{
parse_define_args
(
args
)
?
;
Ok
(
expand_define
(
define
)
)
}
}
}
#
[
doc
(
hidden
)
]
#
[
proc_macro_derive
(
ProcMacroHack
)
]
pub
fn
enum_hack
(
input
:
TokenStream
)
-
>
TokenStream
{
let
ref
mut
input
=
iter
:
:
new
(
input
)
;
parse_enum_hack
(
input
)
.
unwrap_or_else
(
compile_error
)
}
struct
FakeCallSite
{
derive
:
Ident
rest
:
TokenStream
}
#
[
doc
(
hidden
)
]
#
[
proc_macro_attribute
]
pub
fn
fake_call_site
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
ref
mut
args
=
iter
:
:
new
(
args
)
;
let
ref
mut
input
=
iter
:
:
new
(
input
)
;
expand_fake_call_site
(
args
input
)
.
unwrap_or_else
(
compile_error
)
}
fn
expand_fake_call_site
(
args
:
Iter
input
:
Iter
)
-
>
Result
<
TokenStream
Error
>
{
let
span
=
match
args
.
next
(
)
{
Some
(
token
)
=
>
token
.
span
(
)
None
=
>
return
Ok
(
input
.
collect
(
)
)
}
;
let
input
=
parse_fake_call_site
(
input
)
?
;
let
mut
derive
=
input
.
derive
;
derive
.
set_span
(
span
)
;
let
rest
=
input
.
rest
;
Ok
(
quote
!
{
#
[
derive
(
#
derive
)
]
#
rest
}
)
}
struct
ExportArgs
{
support_nested
:
bool
internal_macro_calls
:
u16
fake_call_site
:
bool
only_hack_old_rustc
:
bool
}
fn
expand_export
(
export
:
Export
args
:
ExportArgs
)
-
>
TokenStream
{
if
args
.
only_hack_old_rustc
&
&
cfg
!
(
not
(
need_proc_macro_hack
)
)
{
return
expand_export_nohack
(
export
)
;
}
let
dummy
=
dummy_name_for_export
(
&
export
)
;
let
attrs
=
export
.
attrs
;
let
vis
=
export
.
vis
;
let
macro_export
=
match
vis
{
Some
(
_
)
=
>
quote
!
(
#
[
macro_export
]
)
None
=
>
quote
!
(
)
}
;
let
crate_prefix
=
vis
.
as_ref
(
)
.
map
(
|
_
|
quote
!
(
crate
:
:
)
)
;
let
enum_variant
=
if
args
.
support_nested
{
if
args
.
internal_macro_calls
=
=
0
{
Ident
:
:
new
(
"
Nested
"
Span
:
:
call_site
(
)
)
}
else
{
let
name
=
format
!
(
"
Nested
{
}
"
args
.
internal_macro_calls
)
;
Ident
:
:
new
(
&
name
Span
:
:
call_site
(
)
)
}
}
else
{
Ident
:
:
new
(
"
Value
"
Span
:
:
call_site
(
)
)
}
;
let
from
=
export
.
from
;
let
mut
actual_names
=
TokenStream
:
:
new
(
)
;
let
mut
export_dispatch
=
TokenStream
:
:
new
(
)
;
let
mut
export_call_site
=
TokenStream
:
:
new
(
)
;
let
mut
macro_rules
=
TokenStream
:
:
new
(
)
;
for
Macro
{
name
export_as
}
in
&
export
.
macros
{
let
hacked
=
hacked_proc_macro_name
(
&
name
)
;
let
dispatch
=
dispatch_macro_name
(
&
name
)
;
let
call_site
=
call_site_macro_name
(
&
name
)
;
if
!
actual_names
.
is_empty
(
)
{
actual_names
.
extend
(
quote
!
(
)
)
;
}
actual_names
.
extend
(
quote
!
(
#
hacked
)
)
;
if
!
export_dispatch
.
is_empty
(
)
{
export_dispatch
.
extend
(
quote
!
(
)
)
;
}
export_dispatch
.
extend
(
quote
!
(
dispatch
as
#
dispatch
)
)
;
if
!
export_call_site
.
is_empty
(
)
{
export_call_site
.
extend
(
quote
!
(
)
)
;
}
export_call_site
.
extend
(
quote
!
(
fake_call_site
as
#
call_site
)
)
;
let
do_derive
=
if
!
args
.
fake_call_site
{
quote
!
{
#
[
derive
(
#
crate_prefix
#
hacked
)
]
}
}
else
if
crate_prefix
.
is_some
(
)
{
quote
!
{
use
#
crate_prefix
#
hacked
;
#
[
#
crate_prefix
#
call_site
(
(
proc_macro
)
*
)
]
#
[
derive
(
#
hacked
)
]
}
}
else
{
quote
!
{
#
[
#
call_site
(
(
proc_macro
)
*
)
]
#
[
derive
(
#
hacked
)
]
}
}
;
let
proc_macro_call
=
if
args
.
support_nested
{
let
extra_bangs
=
(
0
.
.
args
.
internal_macro_calls
)
.
map
(
|
_
|
TokenTree
:
:
Punct
(
Punct
:
:
new
(
'
!
'
Spacing
:
:
Alone
)
)
)
.
collect
:
:
<
TokenStream
>
(
)
;
quote
!
{
#
crate_prefix
#
dispatch
!
{
(
(
proc_macro
)
*
)
#
extra_bangs
}
}
}
else
{
quote
!
{
proc_macro_call
!
(
)
}
}
;
macro_rules
.
extend
(
quote
!
{
#
attrs
#
macro_export
macro_rules
!
#
export_as
{
(
(
proc_macro
:
tt
)
*
)
=
>
{
{
#
do_derive
#
[
allow
(
dead_code
)
]
enum
ProcMacroHack
{
#
enum_variant
=
(
stringify
!
{
(
proc_macro
)
*
}
0
)
.
1
}
#
proc_macro_call
}
}
;
}
}
)
;
}
if
export
.
macros
.
len
(
)
!
=
1
{
export_dispatch
=
quote
!
(
{
#
export_dispatch
}
)
;
export_call_site
=
quote
!
(
{
#
export_call_site
}
)
;
actual_names
=
quote
!
(
{
#
actual_names
}
)
;
}
let
export_dispatch
=
if
args
.
support_nested
{
quote
!
{
#
[
doc
(
hidden
)
]
#
vis
use
proc_macro_nested
:
:
#
export_dispatch
;
}
}
else
{
quote
!
(
)
}
;
let
export_call_site
=
if
args
.
fake_call_site
{
quote
!
{
#
[
doc
(
hidden
)
]
#
vis
use
proc_macro_hack
:
:
#
export_call_site
;
}
}
else
{
quote
!
(
)
}
;
let
expanded
=
quote
!
{
#
[
doc
(
hidden
)
]
#
vis
use
#
from
:
:
#
actual_names
;
#
export_dispatch
#
export_call_site
#
macro_rules
}
;
wrap_in_enum_hack
(
dummy
expanded
)
}
fn
expand_export_nohack
(
export
:
Export
)
-
>
TokenStream
{
let
attrs
=
export
.
attrs
;
let
vis
=
export
.
vis
;
let
from
=
export
.
from
;
let
mut
names
=
TokenStream
:
:
new
(
)
;
for
Macro
{
name
export_as
}
in
&
export
.
macros
{
let
pub_name
=
pub_proc_macro_name
(
&
name
)
;
if
!
names
.
is_empty
(
)
{
names
.
extend
(
quote
!
(
)
)
;
}
names
.
extend
(
quote
!
(
#
pub_name
as
#
export_as
)
)
;
}
if
export
.
macros
.
len
(
)
!
=
1
{
names
=
quote
!
(
{
#
names
}
)
;
}
quote
!
{
#
attrs
#
vis
use
#
from
:
:
#
names
;
}
}
fn
expand_define
(
define
:
Define
)
-
>
TokenStream
{
let
attrs
=
define
.
attrs
;
let
name
=
define
.
name
;
let
pub_name
=
pub_proc_macro_name
(
&
name
)
;
let
hacked
=
hacked_proc_macro_name
(
&
name
)
;
let
body
=
define
.
body
;
quote
!
{
mod
#
pub_name
{
extern
crate
proc_macro
;
pub
use
self
:
:
proc_macro
:
:
*
;
}
#
attrs
#
[
doc
(
hidden
)
]
#
[
proc_macro_derive
(
#
hacked
)
]
pub
fn
#
hacked
(
input
:
#
pub_name
:
:
TokenStream
)
-
>
#
pub_name
:
:
TokenStream
{
use
std
:
:
iter
:
:
FromIterator
;
let
mut
iter
=
input
.
into_iter
(
)
;
iter
.
next
(
)
.
unwrap
(
)
;
/
/
enum
iter
.
next
(
)
.
unwrap
(
)
;
/
/
ProcMacroHack
iter
.
next
(
)
.
unwrap
(
)
;
/
/
#
iter
.
next
(
)
.
unwrap
(
)
;
/
/
[
allow
(
dead_code
)
]
let
mut
braces
=
match
iter
.
next
(
)
.
unwrap
(
)
{
#
pub_name
:
:
TokenTree
:
:
Group
(
group
)
=
>
group
.
stream
(
)
.
into_iter
(
)
_
=
>
unimplemented
!
(
)
}
;
let
variant
=
braces
.
next
(
)
.
unwrap
(
)
;
/
/
Value
or
Nested
let
varname
=
variant
.
to_string
(
)
;
let
support_nested
=
varname
.
starts_with
(
"
Nested
"
)
;
braces
.
next
(
)
.
unwrap
(
)
;
/
/
=
let
mut
parens
=
match
braces
.
next
(
)
.
unwrap
(
)
{
#
pub_name
:
:
TokenTree
:
:
Group
(
group
)
=
>
group
.
stream
(
)
.
into_iter
(
)
_
=
>
unimplemented
!
(
)
}
;
parens
.
next
(
)
.
unwrap
(
)
;
/
/
stringify
parens
.
next
(
)
.
unwrap
(
)
;
/
/
!
let
inner
=
match
parens
.
next
(
)
.
unwrap
(
)
{
#
pub_name
:
:
TokenTree
:
:
Group
(
group
)
=
>
group
.
stream
(
)
_
=
>
unimplemented
!
(
)
}
;
let
output
:
#
pub_name
:
:
TokenStream
=
#
name
(
inner
.
clone
(
)
)
;
fn
count_bangs
(
input
:
#
pub_name
:
:
TokenStream
)
-
>
usize
{
let
mut
count
=
0
;
for
token
in
input
{
match
token
{
#
pub_name
:
:
TokenTree
:
:
Punct
(
punct
)
=
>
{
if
punct
.
as_char
(
)
=
=
'
!
'
{
count
+
=
1
;
}
}
#
pub_name
:
:
TokenTree
:
:
Group
(
group
)
=
>
{
count
+
=
count_bangs
(
group
.
stream
(
)
)
;
}
_
=
>
{
}
}
}
count
}
/
/
macro_rules
!
proc_macro_call
{
/
/
(
)
=
>
{
#
output
}
/
/
}
#
pub_name
:
:
TokenStream
:
:
from_iter
(
vec
!
[
#
pub_name
:
:
TokenTree
:
:
Ident
(
#
pub_name
:
:
Ident
:
:
new
(
"
macro_rules
"
#
pub_name
:
:
Span
:
:
call_site
(
)
)
)
#
pub_name
:
:
TokenTree
:
:
Punct
(
#
pub_name
:
:
Punct
:
:
new
(
'
!
'
#
pub_name
:
:
Spacing
:
:
Alone
)
)
#
pub_name
:
:
TokenTree
:
:
Ident
(
#
pub_name
:
:
Ident
:
:
new
(
&
if
support_nested
{
let
extra_bangs
=
if
varname
=
=
"
Nested
"
{
0
}
else
{
varname
[
"
Nested
"
.
len
(
)
.
.
]
.
parse
(
)
.
unwrap
(
)
}
;
format
!
(
"
proc_macro_call_
{
}
"
extra_bangs
+
count_bangs
(
inner
)
)
}
else
{
String
:
:
from
(
"
proc_macro_call
"
)
}
#
pub_name
:
:
Span
:
:
call_site
(
)
)
)
#
pub_name
:
:
TokenTree
:
:
Group
(
#
pub_name
:
:
Group
:
:
new
(
#
pub_name
:
:
Delimiter
:
:
Brace
#
pub_name
:
:
TokenStream
:
:
from_iter
(
vec
!
[
#
pub_name
:
:
TokenTree
:
:
Group
(
#
pub_name
:
:
Group
:
:
new
(
#
pub_name
:
:
Delimiter
:
:
Parenthesis
#
pub_name
:
:
TokenStream
:
:
new
(
)
)
)
#
pub_name
:
:
TokenTree
:
:
Punct
(
#
pub_name
:
:
Punct
:
:
new
(
'
=
'
#
pub_name
:
:
Spacing
:
:
Joint
)
)
#
pub_name
:
:
TokenTree
:
:
Punct
(
#
pub_name
:
:
Punct
:
:
new
(
'
>
'
#
pub_name
:
:
Spacing
:
:
Alone
)
)
#
pub_name
:
:
TokenTree
:
:
Group
(
#
pub_name
:
:
Group
:
:
new
(
#
pub_name
:
:
Delimiter
:
:
Brace
output
)
)
]
)
)
)
]
)
}
#
attrs
#
[
proc_macro
]
pub
fn
#
pub_name
(
input
:
#
pub_name
:
:
TokenStream
)
-
>
#
pub_name
:
:
TokenStream
{
#
name
(
input
)
}
fn
#
name
#
body
}
}
fn
pub_proc_macro_name
(
conceptual
:
&
Ident
)
-
>
Ident
{
Ident
:
:
new
(
&
format
!
(
"
proc_macro_hack_
{
}
"
conceptual
)
conceptual
.
span
(
)
)
}
fn
hacked_proc_macro_name
(
conceptual
:
&
Ident
)
-
>
Ident
{
Ident
:
:
new
(
&
format
!
(
"
_proc_macro_hack_
{
}
"
conceptual
)
conceptual
.
span
(
)
)
}
fn
dispatch_macro_name
(
conceptual
:
&
Ident
)
-
>
Ident
{
Ident
:
:
new
(
&
format
!
(
"
proc_macro_call_
{
}
"
conceptual
)
conceptual
.
span
(
)
)
}
fn
call_site_macro_name
(
conceptual
:
&
Ident
)
-
>
Ident
{
Ident
:
:
new
(
&
format
!
(
"
proc_macro_fake_call_site_
{
}
"
conceptual
)
conceptual
.
span
(
)
)
}
fn
dummy_name_for_export
(
export
:
&
Export
)
-
>
String
{
let
mut
dummy
=
String
:
:
new
(
)
;
let
from
=
unraw
(
&
export
.
from
)
.
to_string
(
)
;
write
!
(
dummy
"
_
{
}
{
}
"
from
.
len
(
)
from
)
.
unwrap
(
)
;
for
m
in
&
export
.
macros
{
let
name
=
unraw
(
&
m
.
name
)
.
to_string
(
)
;
write
!
(
dummy
"
_
{
}
{
}
"
name
.
len
(
)
name
)
.
unwrap
(
)
;
}
dummy
}
fn
unraw
(
ident
:
&
Ident
)
-
>
Ident
{
let
string
=
ident
.
to_string
(
)
;
if
string
.
starts_with
(
"
r
#
"
)
{
Ident
:
:
new
(
&
string
[
2
.
.
]
ident
.
span
(
)
)
}
else
{
ident
.
clone
(
)
}
}
fn
wrap_in_enum_hack
(
dummy
:
String
inner
:
TokenStream
)
-
>
TokenStream
{
let
dummy
=
Ident
:
:
new
(
&
dummy
Span
:
:
call_site
(
)
)
;
quote
!
{
#
[
derive
(
proc_macro_hack
:
:
ProcMacroHack
)
]
enum
#
dummy
{
Value
=
(
stringify
!
{
#
inner
}
0
)
.
1
}
}
}
