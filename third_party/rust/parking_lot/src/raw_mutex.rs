#
[
cfg
(
feature
=
"
nightly
"
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU8
Ordering
}
;
#
[
cfg
(
feature
=
"
nightly
"
)
]
type
U8
=
u8
;
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
use
stable
:
:
{
AtomicU8
Ordering
}
;
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
type
U8
=
usize
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
parking_lot_core
:
:
{
self
ParkResult
UnparkResult
SpinWait
UnparkToken
DEFAULT_PARK_TOKEN
}
;
pub
const
TOKEN_NORMAL
:
UnparkToken
=
UnparkToken
(
0
)
;
pub
const
TOKEN_HANDOFF
:
UnparkToken
=
UnparkToken
(
1
)
;
const
LOCKED_BIT
:
U8
=
1
;
const
PARKED_BIT
:
U8
=
2
;
pub
struct
RawMutex
{
state
:
AtomicU8
}
impl
RawMutex
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
#
[
inline
]
pub
const
fn
new
(
)
-
>
RawMutex
{
RawMutex
{
state
:
AtomicU8
:
:
new
(
0
)
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
#
[
inline
]
pub
fn
new
(
)
-
>
RawMutex
{
RawMutex
{
state
:
AtomicU8
:
:
new
(
0
)
}
}
#
[
inline
]
pub
fn
lock
(
&
self
)
{
if
self
.
state
.
compare_exchange_weak
(
0
LOCKED_BIT
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
return
;
}
self
.
lock_slow
(
None
)
;
}
#
[
inline
]
pub
fn
try_lock_until
(
&
self
timeout
:
Instant
)
-
>
bool
{
if
self
.
state
.
compare_exchange_weak
(
0
LOCKED_BIT
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
return
true
;
}
self
.
lock_slow
(
Some
(
timeout
)
)
}
#
[
inline
]
pub
fn
try_lock_for
(
&
self
timeout
:
Duration
)
-
>
bool
{
if
self
.
state
.
compare_exchange_weak
(
0
LOCKED_BIT
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
return
true
;
}
self
.
lock_slow
(
Some
(
Instant
:
:
now
(
)
+
timeout
)
)
}
#
[
inline
]
pub
fn
try_lock
(
&
self
)
-
>
bool
{
let
mut
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
loop
{
if
state
&
LOCKED_BIT
!
=
0
{
return
false
;
}
match
self
.
state
.
compare_exchange_weak
(
state
state
|
LOCKED_BIT
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
{
Ok
(
_
)
=
>
return
true
Err
(
x
)
=
>
state
=
x
}
}
}
#
[
inline
]
pub
fn
unlock
(
&
self
force_fair
:
bool
)
{
if
self
.
state
.
compare_exchange_weak
(
LOCKED_BIT
0
Ordering
:
:
Release
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
return
;
}
self
.
unlock_slow
(
force_fair
)
;
}
#
[
inline
]
pub
fn
mark_parked_if_locked
(
&
self
)
-
>
bool
{
let
mut
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
loop
{
if
state
&
LOCKED_BIT
=
=
0
{
return
false
;
}
match
self
.
state
.
compare_exchange_weak
(
state
state
|
PARKED_BIT
Ordering
:
:
Relaxed
Ordering
:
:
Relaxed
)
{
Ok
(
_
)
=
>
return
true
Err
(
x
)
=
>
state
=
x
}
}
}
#
[
inline
]
pub
fn
mark_parked
(
&
self
)
{
self
.
state
.
fetch_or
(
PARKED_BIT
Ordering
:
:
Relaxed
)
;
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
lock_slow
(
&
self
timeout
:
Option
<
Instant
>
)
-
>
bool
{
let
mut
spinwait
=
SpinWait
:
:
new
(
)
;
let
mut
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
loop
{
if
state
&
LOCKED_BIT
=
=
0
{
match
self
.
state
.
compare_exchange_weak
(
state
state
|
LOCKED_BIT
Ordering
:
:
Acquire
Ordering
:
:
Relaxed
)
{
Ok
(
_
)
=
>
return
true
Err
(
x
)
=
>
state
=
x
}
continue
;
}
if
state
&
PARKED_BIT
=
=
0
&
&
spinwait
.
spin
(
)
{
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
continue
;
}
if
state
&
PARKED_BIT
=
=
0
{
if
let
Err
(
x
)
=
self
.
state
.
compare_exchange_weak
(
state
state
|
PARKED_BIT
Ordering
:
:
Relaxed
Ordering
:
:
Relaxed
)
{
state
=
x
;
continue
;
}
}
unsafe
{
let
addr
=
self
as
*
const
_
as
usize
;
let
validate
=
|
|
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
=
=
LOCKED_BIT
|
PARKED_BIT
;
let
before_sleep
=
|
|
{
}
;
let
timed_out
=
|
_
was_last_thread
|
{
if
was_last_thread
{
self
.
state
.
fetch_and
(
!
PARKED_BIT
Ordering
:
:
Relaxed
)
;
}
}
;
match
parking_lot_core
:
:
park
(
addr
validate
before_sleep
timed_out
DEFAULT_PARK_TOKEN
timeout
)
{
ParkResult
:
:
Unparked
(
TOKEN_HANDOFF
)
=
>
return
true
ParkResult
:
:
Unparked
(
_
)
=
>
(
)
ParkResult
:
:
Invalid
=
>
(
)
ParkResult
:
:
TimedOut
=
>
return
false
}
}
spinwait
.
reset
(
)
;
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
}
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
unlock_slow
(
&
self
force_fair
:
bool
)
{
if
self
.
state
.
compare_exchange
(
LOCKED_BIT
0
Ordering
:
:
Release
Ordering
:
:
Relaxed
)
.
is_ok
(
)
{
return
;
}
unsafe
{
let
addr
=
self
as
*
const
_
as
usize
;
let
callback
=
|
result
:
UnparkResult
|
{
if
result
.
unparked_threads
!
=
0
&
&
(
force_fair
|
|
result
.
be_fair
)
{
if
!
result
.
have_more_threads
{
self
.
state
.
store
(
LOCKED_BIT
Ordering
:
:
Relaxed
)
;
}
return
TOKEN_HANDOFF
;
}
if
result
.
have_more_threads
{
self
.
state
.
store
(
PARKED_BIT
Ordering
:
:
Release
)
;
}
else
{
self
.
state
.
store
(
0
Ordering
:
:
Release
)
;
}
TOKEN_NORMAL
}
;
parking_lot_core
:
:
unpark_one
(
addr
callback
)
;
}
}
}
