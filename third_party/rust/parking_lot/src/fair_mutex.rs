use
crate
:
:
raw_fair_mutex
:
:
RawFairMutex
;
use
lock_api
;
pub
type
FairMutex
<
T
>
=
lock_api
:
:
Mutex
<
RawFairMutex
T
>
;
pub
const
fn
const_fair_mutex
<
T
>
(
val
:
T
)
-
>
FairMutex
<
T
>
{
FairMutex
:
:
const_new
(
<
RawFairMutex
as
lock_api
:
:
RawMutex
>
:
:
INIT
val
)
}
pub
type
FairMutexGuard
<
'
a
T
>
=
lock_api
:
:
MutexGuard
<
'
a
RawFairMutex
T
>
;
pub
type
MappedFairMutexGuard
<
'
a
T
>
=
lock_api
:
:
MappedMutexGuard
<
'
a
RawFairMutex
T
>
;
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
FairMutex
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
bincode
:
:
{
deserialize
serialize
}
;
#
[
derive
(
Eq
PartialEq
Debug
)
]
struct
NonCopy
(
i32
)
;
#
[
test
]
fn
smoke
(
)
{
let
m
=
FairMutex
:
:
new
(
(
)
)
;
drop
(
m
.
lock
(
)
)
;
drop
(
m
.
lock
(
)
)
;
}
#
[
test
]
fn
lots_and_lots
(
)
{
const
J
:
u32
=
1000
;
const
K
:
u32
=
3
;
let
m
=
Arc
:
:
new
(
FairMutex
:
:
new
(
0
)
)
;
fn
inc
(
m
:
&
FairMutex
<
u32
>
)
{
for
_
in
0
.
.
J
{
*
m
.
lock
(
)
+
=
1
;
}
}
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
K
{
let
tx2
=
tx
.
clone
(
)
;
let
m2
=
m
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
inc
(
&
m2
)
;
tx2
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
let
tx2
=
tx
.
clone
(
)
;
let
m2
=
m
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
inc
(
&
m2
)
;
tx2
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
}
drop
(
tx
)
;
for
_
in
0
.
.
2
*
K
{
rx
.
recv
(
)
.
unwrap
(
)
;
}
assert_eq
!
(
*
m
.
lock
(
)
J
*
K
*
2
)
;
}
#
[
test
]
fn
try_lock
(
)
{
let
m
=
FairMutex
:
:
new
(
(
)
)
;
*
m
.
try_lock
(
)
.
unwrap
(
)
=
(
)
;
}
#
[
test
]
fn
test_into_inner
(
)
{
let
m
=
FairMutex
:
:
new
(
NonCopy
(
10
)
)
;
assert_eq
!
(
m
.
into_inner
(
)
NonCopy
(
10
)
)
;
}
#
[
test
]
fn
test_into_inner_drop
(
)
{
struct
Foo
(
Arc
<
AtomicUsize
>
)
;
impl
Drop
for
Foo
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
}
let
num_drops
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
m
=
FairMutex
:
:
new
(
Foo
(
num_drops
.
clone
(
)
)
)
;
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
0
)
;
{
let
_inner
=
m
.
into_inner
(
)
;
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
0
)
;
}
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
1
)
;
}
#
[
test
]
fn
test_get_mut
(
)
{
let
mut
m
=
FairMutex
:
:
new
(
NonCopy
(
10
)
)
;
*
m
.
get_mut
(
)
=
NonCopy
(
20
)
;
assert_eq
!
(
m
.
into_inner
(
)
NonCopy
(
20
)
)
;
}
#
[
test
]
fn
test_mutex_arc_nested
(
)
{
let
arc
=
Arc
:
:
new
(
FairMutex
:
:
new
(
1
)
)
;
let
arc2
=
Arc
:
:
new
(
FairMutex
:
:
new
(
arc
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
lock
=
arc2
.
lock
(
)
;
let
lock2
=
lock
.
lock
(
)
;
assert_eq
!
(
*
lock2
1
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
rx
.
recv
(
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_mutex_arc_access_in_unwind
(
)
{
let
arc
=
Arc
:
:
new
(
FairMutex
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
=
thread
:
:
spawn
(
move
|
|
{
struct
Unwinder
{
i
:
Arc
<
FairMutex
<
i32
>
>
}
impl
Drop
for
Unwinder
{
fn
drop
(
&
mut
self
)
{
*
self
.
i
.
lock
(
)
+
=
1
;
}
}
let
_u
=
Unwinder
{
i
:
arc2
}
;
panic
!
(
)
;
}
)
.
join
(
)
;
let
lock
=
arc
.
lock
(
)
;
assert_eq
!
(
*
lock
2
)
;
}
#
[
test
]
fn
test_mutex_unsized
(
)
{
let
mutex
:
&
FairMutex
<
[
i32
]
>
=
&
FairMutex
:
:
new
(
[
1
2
3
]
)
;
{
let
b
=
&
mut
*
mutex
.
lock
(
)
;
b
[
0
]
=
4
;
b
[
2
]
=
5
;
}
let
comp
:
&
[
i32
]
=
&
[
4
2
5
]
;
assert_eq
!
(
&
*
mutex
.
lock
(
)
comp
)
;
}
#
[
test
]
fn
test_mutexguard_sync
(
)
{
fn
sync
<
T
:
Sync
>
(
_
:
T
)
{
}
let
mutex
=
FairMutex
:
:
new
(
(
)
)
;
sync
(
mutex
.
lock
(
)
)
;
}
#
[
test
]
fn
test_mutex_debug
(
)
{
let
mutex
=
FairMutex
:
:
new
(
vec
!
[
0u8
10
]
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
mutex
)
"
Mutex
{
data
:
[
0
10
]
}
"
)
;
let
_lock
=
mutex
.
lock
(
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
mutex
)
"
Mutex
{
data
:
<
locked
>
}
"
)
;
}
#
[
cfg
(
feature
=
"
serde
"
)
]
#
[
test
]
fn
test_serde
(
)
{
let
contents
:
Vec
<
u8
>
=
vec
!
[
0
1
2
]
;
let
mutex
=
FairMutex
:
:
new
(
contents
.
clone
(
)
)
;
let
serialized
=
serialize
(
&
mutex
)
.
unwrap
(
)
;
let
deserialized
:
FairMutex
<
Vec
<
u8
>
>
=
deserialize
(
&
serialized
)
.
unwrap
(
)
;
assert_eq
!
(
*
(
mutex
.
lock
(
)
)
*
(
deserialized
.
lock
(
)
)
)
;
assert_eq
!
(
contents
*
(
deserialized
.
lock
(
)
)
)
;
}
}
