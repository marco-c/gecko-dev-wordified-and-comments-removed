use
crate
:
:
mutex
:
:
MutexGuard
;
use
crate
:
:
raw_mutex
:
:
{
RawMutex
TOKEN_HANDOFF
TOKEN_NORMAL
}
;
use
crate
:
:
{
deadlock
util
}
;
use
core
:
:
{
fmt
ptr
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
}
;
use
instant
:
:
Instant
;
use
lock_api
:
:
RawMutex
as
RawMutex_
;
use
parking_lot_core
:
:
{
self
ParkResult
RequeueOp
UnparkResult
DEFAULT_PARK_TOKEN
}
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
pub
struct
WaitTimeoutResult
(
bool
)
;
impl
WaitTimeoutResult
{
#
[
inline
]
pub
fn
timed_out
(
self
)
-
>
bool
{
self
.
0
}
}
pub
struct
Condvar
{
state
:
AtomicPtr
<
RawMutex
>
}
impl
Condvar
{
#
[
inline
]
pub
const
fn
new
(
)
-
>
Condvar
{
Condvar
{
state
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
#
[
inline
]
pub
fn
notify_one
(
&
self
)
-
>
bool
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
if
state
.
is_null
(
)
{
return
false
;
}
self
.
notify_one_slow
(
state
)
}
#
[
cold
]
fn
notify_one_slow
(
&
self
mutex
:
*
mut
RawMutex
)
-
>
bool
{
unsafe
{
let
from
=
self
as
*
const
_
as
usize
;
let
to
=
mutex
as
usize
;
let
validate
=
|
|
{
if
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
!
=
mutex
{
return
RequeueOp
:
:
Abort
;
}
if
(
*
mutex
)
.
mark_parked_if_locked
(
)
{
RequeueOp
:
:
RequeueOne
}
else
{
RequeueOp
:
:
UnparkOne
}
}
;
let
callback
=
|
_op
result
:
UnparkResult
|
{
if
!
result
.
have_more_threads
{
self
.
state
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
}
TOKEN_NORMAL
}
;
let
res
=
parking_lot_core
:
:
unpark_requeue
(
from
to
validate
callback
)
;
res
.
unparked_threads
+
res
.
requeued_threads
!
=
0
}
}
#
[
inline
]
pub
fn
notify_all
(
&
self
)
-
>
usize
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
if
state
.
is_null
(
)
{
return
0
;
}
self
.
notify_all_slow
(
state
)
}
#
[
cold
]
fn
notify_all_slow
(
&
self
mutex
:
*
mut
RawMutex
)
-
>
usize
{
unsafe
{
let
from
=
self
as
*
const
_
as
usize
;
let
to
=
mutex
as
usize
;
let
validate
=
|
|
{
if
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
!
=
mutex
{
return
RequeueOp
:
:
Abort
;
}
self
.
state
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
if
(
*
mutex
)
.
mark_parked_if_locked
(
)
{
RequeueOp
:
:
RequeueAll
}
else
{
RequeueOp
:
:
UnparkOneRequeueRest
}
}
;
let
callback
=
|
op
result
:
UnparkResult
|
{
if
op
=
=
RequeueOp
:
:
UnparkOneRequeueRest
&
&
result
.
requeued_threads
!
=
0
{
(
*
mutex
)
.
mark_parked
(
)
;
}
TOKEN_NORMAL
}
;
let
res
=
parking_lot_core
:
:
unpark_requeue
(
from
to
validate
callback
)
;
res
.
unparked_threads
+
res
.
requeued_threads
}
}
#
[
inline
]
pub
fn
wait
<
T
:
?
Sized
>
(
&
self
mutex_guard
:
&
mut
MutexGuard
<
'
_
T
>
)
{
self
.
wait_until_internal
(
unsafe
{
MutexGuard
:
:
mutex
(
mutex_guard
)
.
raw
(
)
}
None
)
;
}
#
[
inline
]
pub
fn
wait_until
<
T
:
?
Sized
>
(
&
self
mutex_guard
:
&
mut
MutexGuard
<
'
_
T
>
timeout
:
Instant
)
-
>
WaitTimeoutResult
{
self
.
wait_until_internal
(
unsafe
{
MutexGuard
:
:
mutex
(
mutex_guard
)
.
raw
(
)
}
Some
(
timeout
)
)
}
fn
wait_until_internal
(
&
self
mutex
:
&
RawMutex
timeout
:
Option
<
Instant
>
)
-
>
WaitTimeoutResult
{
unsafe
{
let
result
;
let
mut
bad_mutex
=
false
;
let
mut
requeued
=
false
;
{
let
addr
=
self
as
*
const
_
as
usize
;
let
lock_addr
=
mutex
as
*
const
_
as
*
mut
_
;
let
validate
=
|
|
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
if
state
.
is_null
(
)
{
self
.
state
.
store
(
lock_addr
Ordering
:
:
Relaxed
)
;
}
else
if
state
!
=
lock_addr
{
bad_mutex
=
true
;
return
false
;
}
true
}
;
let
before_sleep
=
|
|
{
mutex
.
unlock
(
)
;
}
;
let
timed_out
=
|
k
was_last_thread
|
{
requeued
=
k
!
=
addr
;
if
!
requeued
&
&
was_last_thread
{
self
.
state
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
}
}
;
result
=
parking_lot_core
:
:
park
(
addr
validate
before_sleep
timed_out
DEFAULT_PARK_TOKEN
timeout
)
;
}
if
bad_mutex
{
panic
!
(
"
attempted
to
use
a
condition
variable
with
more
than
one
mutex
"
)
;
}
if
result
=
=
ParkResult
:
:
Unparked
(
TOKEN_HANDOFF
)
{
deadlock
:
:
acquire_resource
(
mutex
as
*
const
_
as
usize
)
;
}
else
{
mutex
.
lock
(
)
;
}
WaitTimeoutResult
(
!
(
result
.
is_unparked
(
)
|
|
requeued
)
)
}
}
#
[
inline
]
pub
fn
wait_for
<
T
:
?
Sized
>
(
&
self
mutex_guard
:
&
mut
MutexGuard
<
'
_
T
>
timeout
:
Duration
)
-
>
WaitTimeoutResult
{
let
deadline
=
util
:
:
to_deadline
(
timeout
)
;
self
.
wait_until_internal
(
unsafe
{
MutexGuard
:
:
mutex
(
mutex_guard
)
.
raw
(
)
}
deadline
)
}
}
impl
Default
for
Condvar
{
#
[
inline
]
fn
default
(
)
-
>
Condvar
{
Condvar
:
:
new
(
)
}
}
impl
fmt
:
:
Debug
for
Condvar
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
pad
(
"
Condvar
{
.
.
}
"
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
{
Condvar
Mutex
MutexGuard
}
;
use
instant
:
:
Instant
;
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
Duration
;
#
[
test
]
fn
smoke
(
)
{
let
c
=
Condvar
:
:
new
(
)
;
c
.
notify_one
(
)
;
c
.
notify_all
(
)
;
}
#
[
test
]
fn
notify_one
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
c
.
wait
(
&
mut
g
)
;
}
#
[
test
]
fn
notify_all
(
)
{
const
N
:
usize
=
10
;
let
data
=
Arc
:
:
new
(
(
Mutex
:
:
new
(
0
)
Condvar
:
:
new
(
)
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
N
{
let
data
=
data
.
clone
(
)
;
let
tx
=
tx
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
&
(
ref
lock
ref
cond
)
=
&
*
data
;
let
mut
cnt
=
lock
.
lock
(
)
;
*
cnt
+
=
1
;
if
*
cnt
=
=
N
{
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
while
*
cnt
!
=
0
{
cond
.
wait
(
&
mut
cnt
)
;
}
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
}
drop
(
tx
)
;
let
&
(
ref
lock
ref
cond
)
=
&
*
data
;
rx
.
recv
(
)
.
unwrap
(
)
;
let
mut
cnt
=
lock
.
lock
(
)
;
*
cnt
=
0
;
cond
.
notify_all
(
)
;
drop
(
cnt
)
;
for
_
in
0
.
.
N
{
rx
.
recv
(
)
.
unwrap
(
)
;
}
}
#
[
test
]
fn
notify_one_return_true
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
assert
!
(
c2
.
notify_one
(
)
)
;
}
)
;
c
.
wait
(
&
mut
g
)
;
}
#
[
test
]
fn
notify_one_return_false
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m
.
lock
(
)
;
assert
!
(
!
c
.
notify_one
(
)
)
;
}
)
;
}
#
[
test
]
fn
notify_all_return
(
)
{
const
N
:
usize
=
10
;
let
data
=
Arc
:
:
new
(
(
Mutex
:
:
new
(
0
)
Condvar
:
:
new
(
)
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
N
{
let
data
=
data
.
clone
(
)
;
let
tx
=
tx
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
&
(
ref
lock
ref
cond
)
=
&
*
data
;
let
mut
cnt
=
lock
.
lock
(
)
;
*
cnt
+
=
1
;
if
*
cnt
=
=
N
{
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
while
*
cnt
!
=
0
{
cond
.
wait
(
&
mut
cnt
)
;
}
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
}
drop
(
tx
)
;
let
&
(
ref
lock
ref
cond
)
=
&
*
data
;
rx
.
recv
(
)
.
unwrap
(
)
;
let
mut
cnt
=
lock
.
lock
(
)
;
*
cnt
=
0
;
assert_eq
!
(
cond
.
notify_all
(
)
N
)
;
drop
(
cnt
)
;
for
_
in
0
.
.
N
{
rx
.
recv
(
)
.
unwrap
(
)
;
}
assert_eq
!
(
cond
.
notify_all
(
)
0
)
;
}
#
[
test
]
fn
wait_for
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
no_timeout
=
c
.
wait_for
(
&
mut
g
Duration
:
:
from_millis
(
1
)
)
;
assert
!
(
no_timeout
.
timed_out
(
)
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
let
very_long_timeout
=
if
cfg
!
(
feature
=
"
nightly
"
)
{
Duration
:
:
from_secs
(
u64
:
:
max_value
(
)
)
}
else
{
Duration
:
:
from_millis
(
u32
:
:
max_value
(
)
as
u64
)
}
;
let
timeout_res
=
c
.
wait_for
(
&
mut
g
very_long_timeout
)
;
assert
!
(
!
timeout_res
.
timed_out
(
)
)
;
drop
(
g
)
;
}
#
[
test
]
fn
wait_until
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
no_timeout
=
c
.
wait_until
(
&
mut
g
Instant
:
:
now
(
)
+
Duration
:
:
from_millis
(
1
)
)
;
assert
!
(
no_timeout
.
timed_out
(
)
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
let
timeout_res
=
c
.
wait_until
(
&
mut
g
Instant
:
:
now
(
)
+
Duration
:
:
from_millis
(
u32
:
:
max_value
(
)
as
u64
)
)
;
assert
!
(
!
timeout_res
.
timed_out
(
)
)
;
drop
(
g
)
;
}
#
[
test
]
#
[
should_panic
]
fn
two_mutexes
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
m3
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
struct
PanicGuard
<
'
a
>
(
&
'
a
Condvar
)
;
impl
<
'
a
>
Drop
for
PanicGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
notify_one
(
)
;
}
}
let
(
tx
rx
)
=
channel
(
)
;
let
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
mut
g
=
m2
.
lock
(
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
c2
.
wait
(
&
mut
g
)
;
}
)
;
drop
(
g
)
;
rx
.
recv
(
)
.
unwrap
(
)
;
let
_g
=
m
.
lock
(
)
;
let
_guard
=
PanicGuard
(
&
*
c
)
;
c
.
wait
(
&
mut
m3
.
lock
(
)
)
;
}
#
[
test
]
fn
two_mutexes_disjoint
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
m3
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
c
.
wait
(
&
mut
g
)
;
drop
(
g
)
;
let
_
=
c
.
wait_for
(
&
mut
m3
.
lock
(
)
Duration
:
:
from_millis
(
1
)
)
;
}
#
[
test
]
fn
test_debug_condvar
(
)
{
let
c
=
Condvar
:
:
new
(
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
c
)
"
Condvar
{
.
.
}
"
)
;
}
#
[
test
]
fn
test_condvar_requeue
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
t
=
thread
:
:
spawn
(
move
|
|
{
let
mut
g
=
m2
.
lock
(
)
;
c2
.
wait
(
&
mut
g
)
;
}
)
;
let
mut
g
=
m
.
lock
(
)
;
while
!
c
.
notify_one
(
)
{
MutexGuard
:
:
bump
(
&
mut
g
)
;
}
drop
(
g
)
;
t
.
join
(
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_issue_129
(
)
{
let
locks
=
Arc
:
:
new
(
(
Mutex
:
:
new
(
(
)
)
Condvar
:
:
new
(
)
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
4
{
let
locks
=
locks
.
clone
(
)
;
let
tx
=
tx
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
mut
guard
=
locks
.
0
.
lock
(
)
;
locks
.
1
.
wait
(
&
mut
guard
)
;
locks
.
1
.
wait_for
(
&
mut
guard
Duration
:
:
from_millis
(
1
)
)
;
locks
.
1
.
notify_one
(
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
}
thread
:
:
sleep
(
Duration
:
:
from_millis
(
100
)
)
;
locks
.
1
.
notify_one
(
)
;
for
_
in
0
.
.
4
{
assert_eq
!
(
rx
.
recv_timeout
(
Duration
:
:
from_millis
(
500
)
)
Ok
(
(
)
)
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
webkit_queue_test
{
use
crate
:
:
{
Condvar
Mutex
MutexGuard
}
;
use
std
:
:
{
collections
:
:
VecDeque
sync
:
:
Arc
thread
time
:
:
Duration
}
;
#
[
derive
(
Clone
Copy
)
]
enum
Timeout
{
Bounded
(
Duration
)
Forever
}
#
[
derive
(
Clone
Copy
)
]
enum
NotifyStyle
{
One
All
}
struct
Queue
{
items
:
VecDeque
<
usize
>
should_continue
:
bool
}
impl
Queue
{
fn
new
(
)
-
>
Self
{
Self
{
items
:
VecDeque
:
:
new
(
)
should_continue
:
true
}
}
}
fn
wait
<
T
:
?
Sized
>
(
condition
:
&
Condvar
lock
:
&
mut
MutexGuard
<
'
_
T
>
predicate
:
impl
Fn
(
&
mut
MutexGuard
<
'
_
T
>
)
-
>
bool
timeout
:
&
Timeout
)
{
while
!
predicate
(
lock
)
{
match
timeout
{
Timeout
:
:
Forever
=
>
condition
.
wait
(
lock
)
Timeout
:
:
Bounded
(
bound
)
=
>
{
condition
.
wait_for
(
lock
*
bound
)
;
}
}
}
}
fn
notify
(
style
:
NotifyStyle
condition
:
&
Condvar
should_notify
:
bool
)
{
match
style
{
NotifyStyle
:
:
One
=
>
{
condition
.
notify_one
(
)
;
}
NotifyStyle
:
:
All
=
>
{
if
should_notify
{
condition
.
notify_all
(
)
;
}
}
}
}
fn
run_queue_test
(
num_producers
:
usize
num_consumers
:
usize
max_queue_size
:
usize
messages_per_producer
:
usize
notify_style
:
NotifyStyle
timeout
:
Timeout
delay
:
Duration
)
{
let
input_queue
=
Arc
:
:
new
(
Mutex
:
:
new
(
Queue
:
:
new
(
)
)
)
;
let
empty_condition
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
full_condition
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
output_vec
=
Arc
:
:
new
(
Mutex
:
:
new
(
vec
!
[
]
)
)
;
let
consumers
=
(
0
.
.
num_consumers
)
.
map
(
|
_
|
{
consumer_thread
(
input_queue
.
clone
(
)
empty_condition
.
clone
(
)
full_condition
.
clone
(
)
timeout
notify_style
output_vec
.
clone
(
)
max_queue_size
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
producers
=
(
0
.
.
num_producers
)
.
map
(
|
_
|
{
producer_thread
(
messages_per_producer
input_queue
.
clone
(
)
empty_condition
.
clone
(
)
full_condition
.
clone
(
)
timeout
notify_style
max_queue_size
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
thread
:
:
sleep
(
delay
)
;
for
producer
in
producers
.
into_iter
(
)
{
producer
.
join
(
)
.
expect
(
"
Producer
thread
panicked
"
)
;
}
{
let
mut
input_queue
=
input_queue
.
lock
(
)
;
input_queue
.
should_continue
=
false
;
}
empty_condition
.
notify_all
(
)
;
for
consumer
in
consumers
.
into_iter
(
)
{
consumer
.
join
(
)
.
expect
(
"
Consumer
thread
panicked
"
)
;
}
let
mut
output_vec
=
output_vec
.
lock
(
)
;
assert_eq
!
(
output_vec
.
len
(
)
num_producers
*
messages_per_producer
)
;
output_vec
.
sort
(
)
;
for
msg_idx
in
0
.
.
messages_per_producer
{
for
producer_idx
in
0
.
.
num_producers
{
assert_eq
!
(
msg_idx
output_vec
[
msg_idx
*
num_producers
+
producer_idx
]
)
;
}
}
}
fn
consumer_thread
(
input_queue
:
Arc
<
Mutex
<
Queue
>
>
empty_condition
:
Arc
<
Condvar
>
full_condition
:
Arc
<
Condvar
>
timeout
:
Timeout
notify_style
:
NotifyStyle
output_queue
:
Arc
<
Mutex
<
Vec
<
usize
>
>
>
max_queue_size
:
usize
)
-
>
thread
:
:
JoinHandle
<
(
)
>
{
thread
:
:
spawn
(
move
|
|
loop
{
let
(
should_notify
result
)
=
{
let
mut
queue
=
input_queue
.
lock
(
)
;
wait
(
&
*
empty_condition
&
mut
queue
|
state
|
-
>
bool
{
!
state
.
items
.
is_empty
(
)
|
|
!
state
.
should_continue
}
&
timeout
)
;
if
queue
.
items
.
is_empty
(
)
&
&
!
queue
.
should_continue
{
return
;
}
let
should_notify
=
queue
.
items
.
len
(
)
=
=
max_queue_size
;
let
result
=
queue
.
items
.
pop_front
(
)
;
std
:
:
mem
:
:
drop
(
queue
)
;
(
should_notify
result
)
}
;
notify
(
notify_style
&
*
full_condition
should_notify
)
;
if
let
Some
(
result
)
=
result
{
output_queue
.
lock
(
)
.
push
(
result
)
;
}
}
)
}
fn
producer_thread
(
num_messages
:
usize
queue
:
Arc
<
Mutex
<
Queue
>
>
empty_condition
:
Arc
<
Condvar
>
full_condition
:
Arc
<
Condvar
>
timeout
:
Timeout
notify_style
:
NotifyStyle
max_queue_size
:
usize
)
-
>
thread
:
:
JoinHandle
<
(
)
>
{
thread
:
:
spawn
(
move
|
|
{
for
message
in
0
.
.
num_messages
{
let
should_notify
=
{
let
mut
queue
=
queue
.
lock
(
)
;
wait
(
&
*
full_condition
&
mut
queue
|
state
|
state
.
items
.
len
(
)
<
max_queue_size
&
timeout
)
;
let
should_notify
=
queue
.
items
.
is_empty
(
)
;
queue
.
items
.
push_back
(
message
)
;
std
:
:
mem
:
:
drop
(
queue
)
;
should_notify
}
;
notify
(
notify_style
&
*
empty_condition
should_notify
)
;
}
}
)
}
macro_rules
!
run_queue_tests
{
(
(
name
:
ident
(
num_producers
:
num_producers
:
expr
num_consumers
:
num_consumers
:
expr
max_queue_size
:
max_queue_size
:
expr
messages_per_producer
:
messages_per_producer
:
expr
notification_style
:
notification_style
:
expr
timeout
:
timeout
:
expr
delay_seconds
:
delay_seconds
:
expr
)
;
)
*
)
=
>
{
(
#
[
test
]
fn
name
(
)
{
let
delay
=
Duration
:
:
from_secs
(
delay_seconds
)
;
run_queue_test
(
num_producers
num_consumers
max_queue_size
messages_per_producer
notification_style
timeout
delay
)
;
}
)
*
}
;
}
run_queue_tests
!
{
sanity_check_queue
(
num_producers
:
1
num_consumers
:
1
max_queue_size
:
1
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Bounded
(
Duration
:
:
from_secs
(
1
)
)
delay_seconds
:
0
)
;
sanity_check_queue_timeout
(
num_producers
:
1
num_consumers
:
1
max_queue_size
:
1
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
new_test_without_timeout_5
(
num_producers
:
1
num_consumers
:
5
max_queue_size
:
1
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
one_producer_one_consumer_one_slot
(
num_producers
:
1
num_consumers
:
1
max_queue_size
:
1
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
one_producer_one_consumer_one_slot_timeout
(
num_producers
:
1
num_consumers
:
1
max_queue_size
:
1
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
1
)
;
one_producer_one_consumer_hundred_slots
(
num_producers
:
1
num_consumers
:
1
max_queue_size
:
100
messages_per_producer
:
1_000_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
ten_producers_one_consumer_one_slot
(
num_producers
:
10
num_consumers
:
1
max_queue_size
:
1
messages_per_producer
:
10000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
ten_producers_one_consumer_hundred_slots_notify_all
(
num_producers
:
10
num_consumers
:
1
max_queue_size
:
100
messages_per_producer
:
10000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
ten_producers_one_consumer_hundred_slots_notify_one
(
num_producers
:
10
num_consumers
:
1
max_queue_size
:
100
messages_per_producer
:
10000
notification_style
:
NotifyStyle
:
:
One
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
one_producer_ten_consumers_one_slot
(
num_producers
:
1
num_consumers
:
10
max_queue_size
:
1
messages_per_producer
:
10000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
one_producer_ten_consumers_hundred_slots_notify_all
(
num_producers
:
1
num_consumers
:
10
max_queue_size
:
100
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
one_producer_ten_consumers_hundred_slots_notify_one
(
num_producers
:
1
num_consumers
:
10
max_queue_size
:
100
messages_per_producer
:
100_000
notification_style
:
NotifyStyle
:
:
One
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
ten_producers_ten_consumers_one_slot
(
num_producers
:
10
num_consumers
:
10
max_queue_size
:
1
messages_per_producer
:
50000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
ten_producers_ten_consumers_hundred_slots_notify_all
(
num_producers
:
10
num_consumers
:
10
max_queue_size
:
100
messages_per_producer
:
50000
notification_style
:
NotifyStyle
:
:
All
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
ten_producers_ten_consumers_hundred_slots_notify_one
(
num_producers
:
10
num_consumers
:
10
max_queue_size
:
100
messages_per_producer
:
50000
notification_style
:
NotifyStyle
:
:
One
timeout
:
Timeout
:
:
Forever
delay_seconds
:
0
)
;
}
}
