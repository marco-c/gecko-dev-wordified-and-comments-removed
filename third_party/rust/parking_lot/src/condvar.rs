use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
std
:
:
ptr
;
use
parking_lot_core
:
:
{
self
ParkResult
UnparkResult
RequeueOp
DEFAULT_PARK_TOKEN
}
;
use
mutex
:
:
{
MutexGuard
guard_lock
}
;
use
raw_mutex
:
:
{
RawMutex
TOKEN_NORMAL
TOKEN_HANDOFF
}
;
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
pub
struct
WaitTimeoutResult
(
bool
)
;
impl
WaitTimeoutResult
{
#
[
inline
]
pub
fn
timed_out
(
&
self
)
-
>
bool
{
self
.
0
}
}
pub
struct
Condvar
{
state
:
AtomicPtr
<
RawMutex
>
}
impl
Condvar
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
#
[
inline
]
pub
const
fn
new
(
)
-
>
Condvar
{
Condvar
{
state
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
#
[
inline
]
pub
fn
new
(
)
-
>
Condvar
{
Condvar
{
state
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
#
[
inline
]
pub
fn
notify_one
(
&
self
)
{
if
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
{
return
;
}
self
.
notify_one_slow
(
)
;
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
notify_one_slow
(
&
self
)
{
unsafe
{
let
addr
=
self
as
*
const
_
as
usize
;
let
callback
=
|
result
:
UnparkResult
|
{
if
!
result
.
have_more_threads
{
self
.
state
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
}
TOKEN_NORMAL
}
;
parking_lot_core
:
:
unpark_one
(
addr
callback
)
;
}
}
#
[
inline
]
pub
fn
notify_all
(
&
self
)
{
if
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
.
is_null
(
)
{
return
;
}
self
.
notify_all_slow
(
)
;
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
notify_all_slow
(
&
self
)
{
unsafe
{
let
mutex
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
let
from
=
self
as
*
const
_
as
usize
;
let
to
=
mutex
as
usize
;
let
validate
=
|
|
{
if
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
!
=
mutex
{
return
RequeueOp
:
:
Abort
;
}
self
.
state
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
if
(
*
mutex
)
.
mark_parked_if_locked
(
)
{
RequeueOp
:
:
RequeueAll
}
else
{
RequeueOp
:
:
UnparkOneRequeueRest
}
}
;
let
callback
=
|
op
result
:
UnparkResult
|
{
if
op
=
=
RequeueOp
:
:
UnparkOneRequeueRest
&
&
result
.
have_more_threads
{
(
*
mutex
)
.
mark_parked
(
)
;
}
TOKEN_NORMAL
}
;
parking_lot_core
:
:
unpark_requeue
(
from
to
validate
callback
)
;
}
}
#
[
inline
]
pub
fn
wait
<
T
:
?
Sized
>
(
&
self
mutex_guard
:
&
mut
MutexGuard
<
T
>
)
{
self
.
wait_until_internal
(
guard_lock
(
mutex_guard
)
None
)
;
}
#
[
inline
]
pub
fn
wait_until
<
T
:
?
Sized
>
(
&
self
mutex_guard
:
&
mut
MutexGuard
<
T
>
timeout
:
Instant
)
-
>
WaitTimeoutResult
{
self
.
wait_until_internal
(
guard_lock
(
mutex_guard
)
Some
(
timeout
)
)
}
fn
wait_until_internal
(
&
self
mutex
:
&
RawMutex
timeout
:
Option
<
Instant
>
)
-
>
WaitTimeoutResult
{
unsafe
{
let
result
;
let
mut
bad_mutex
=
false
;
let
mut
requeued
=
false
;
{
let
addr
=
self
as
*
const
_
as
usize
;
let
lock_addr
=
mutex
as
*
const
_
as
*
mut
_
;
let
validate
=
|
|
{
let
state
=
self
.
state
.
load
(
Ordering
:
:
Relaxed
)
;
if
state
.
is_null
(
)
{
self
.
state
.
store
(
lock_addr
Ordering
:
:
Relaxed
)
;
}
else
if
state
!
=
lock_addr
{
bad_mutex
=
true
;
return
false
;
}
true
}
;
let
before_sleep
=
|
|
{
mutex
.
unlock
(
false
)
;
}
;
let
timed_out
=
|
k
was_last_thread
|
{
requeued
=
k
!
=
addr
;
if
!
requeued
&
&
was_last_thread
{
self
.
state
.
store
(
ptr
:
:
null_mut
(
)
Ordering
:
:
Relaxed
)
;
}
}
;
result
=
parking_lot_core
:
:
park
(
addr
validate
before_sleep
timed_out
DEFAULT_PARK_TOKEN
timeout
)
;
}
if
bad_mutex
{
panic
!
(
"
attempted
to
use
a
condition
variable
with
more
than
one
mutex
"
)
;
}
if
result
!
=
ParkResult
:
:
Unparked
(
TOKEN_HANDOFF
)
{
mutex
.
lock
(
)
;
}
WaitTimeoutResult
(
!
(
result
.
is_unparked
(
)
|
|
requeued
)
)
}
}
#
[
inline
]
pub
fn
wait_for
<
T
:
?
Sized
>
(
&
self
guard
:
&
mut
MutexGuard
<
T
>
timeout
:
Duration
)
-
>
WaitTimeoutResult
{
self
.
wait_until
(
guard
Instant
:
:
now
(
)
+
timeout
)
}
}
impl
Default
for
Condvar
{
#
[
inline
]
fn
default
(
)
-
>
Condvar
{
Condvar
:
:
new
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
{
Condvar
Mutex
}
;
#
[
test
]
fn
smoke
(
)
{
let
c
=
Condvar
:
:
new
(
)
;
c
.
notify_one
(
)
;
c
.
notify_all
(
)
;
}
#
[
test
]
fn
notify_one
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
c
.
wait
(
&
mut
g
)
;
}
#
[
test
]
fn
notify_all
(
)
{
const
N
:
usize
=
10
;
let
data
=
Arc
:
:
new
(
(
Mutex
:
:
new
(
0
)
Condvar
:
:
new
(
)
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
N
{
let
data
=
data
.
clone
(
)
;
let
tx
=
tx
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
&
(
ref
lock
ref
cond
)
=
&
*
data
;
let
mut
cnt
=
lock
.
lock
(
)
;
*
cnt
+
=
1
;
if
*
cnt
=
=
N
{
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
while
*
cnt
!
=
0
{
cond
.
wait
(
&
mut
cnt
)
;
}
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
}
drop
(
tx
)
;
let
&
(
ref
lock
ref
cond
)
=
&
*
data
;
rx
.
recv
(
)
.
unwrap
(
)
;
let
mut
cnt
=
lock
.
lock
(
)
;
*
cnt
=
0
;
cond
.
notify_all
(
)
;
drop
(
cnt
)
;
for
_
in
0
.
.
N
{
rx
.
recv
(
)
.
unwrap
(
)
;
}
}
#
[
test
]
fn
wait_for
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
no_timeout
=
c
.
wait_for
(
&
mut
g
Duration
:
:
from_millis
(
1
)
)
;
assert
!
(
no_timeout
.
timed_out
(
)
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
let
timeout_res
=
c
.
wait_for
(
&
mut
g
Duration
:
:
from_millis
(
u32
:
:
max_value
(
)
as
u64
)
)
;
assert
!
(
!
timeout_res
.
timed_out
(
)
)
;
drop
(
g
)
;
}
#
[
test
]
fn
wait_until
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
no_timeout
=
c
.
wait_until
(
&
mut
g
Instant
:
:
now
(
)
+
Duration
:
:
from_millis
(
1
)
)
;
assert
!
(
no_timeout
.
timed_out
(
)
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
let
timeout_res
=
c
.
wait_until
(
&
mut
g
Instant
:
:
now
(
)
+
Duration
:
:
from_millis
(
u32
:
:
max_value
(
)
as
u64
)
)
;
assert
!
(
!
timeout_res
.
timed_out
(
)
)
;
drop
(
g
)
;
}
#
[
test
]
#
[
should_panic
]
fn
two_mutexes
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
m3
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
struct
PanicGuard
<
'
a
>
(
&
'
a
Condvar
)
;
impl
<
'
a
>
Drop
for
PanicGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
notify_one
(
)
;
}
}
let
(
tx
rx
)
=
channel
(
)
;
let
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
mut
g
=
m2
.
lock
(
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
c2
.
wait
(
&
mut
g
)
;
}
)
;
drop
(
g
)
;
rx
.
recv
(
)
.
unwrap
(
)
;
let
_g
=
m
.
lock
(
)
;
let
_guard
=
PanicGuard
(
&
*
c
)
;
let
_
=
c
.
wait
(
&
mut
m3
.
lock
(
)
)
;
}
#
[
test
]
fn
two_mutexes_disjoint
(
)
{
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
m2
=
m
.
clone
(
)
;
let
m3
=
Arc
:
:
new
(
Mutex
:
:
new
(
(
)
)
)
;
let
c
=
Arc
:
:
new
(
Condvar
:
:
new
(
)
)
;
let
c2
=
c
.
clone
(
)
;
let
mut
g
=
m
.
lock
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
_g
=
m2
.
lock
(
)
;
c2
.
notify_one
(
)
;
}
)
;
c
.
wait
(
&
mut
g
)
;
drop
(
g
)
;
let
_
=
c
.
wait_for
(
&
mut
m3
.
lock
(
)
Duration
:
:
from_millis
(
1
)
)
;
}
}
