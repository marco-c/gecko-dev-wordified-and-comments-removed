#
!
[
allow
(
dead_code
)
]
use
std
:
:
sync
:
:
atomic
;
pub
use
std
:
:
sync
:
:
atomic
:
:
{
Ordering
fence
}
;
pub
struct
AtomicUsize
(
atomic
:
:
AtomicUsize
)
;
pub
use
self
:
:
AtomicUsize
as
AtomicU8
;
pub
const
ATOMIC_USIZE_INIT
:
AtomicUsize
=
AtomicUsize
(
atomic
:
:
ATOMIC_USIZE_INIT
)
;
pub
use
self
:
:
ATOMIC_USIZE_INIT
as
ATOMIC_U8_INIT
;
impl
AtomicUsize
{
#
[
inline
]
pub
fn
new
(
val
:
usize
)
-
>
AtomicUsize
{
AtomicUsize
(
atomic
:
:
AtomicUsize
:
:
new
(
val
)
)
}
#
[
inline
]
pub
fn
load
(
&
self
order
:
Ordering
)
-
>
usize
{
self
.
0
.
load
(
order
)
}
#
[
inline
]
pub
fn
store
(
&
self
val
:
usize
order
:
Ordering
)
{
self
.
0
.
store
(
val
order
)
;
}
#
[
inline
]
pub
fn
swap
(
&
self
val
:
usize
order
:
Ordering
)
-
>
usize
{
self
.
0
.
swap
(
val
order
)
}
#
[
inline
]
pub
fn
fetch_add
(
&
self
val
:
usize
order
:
Ordering
)
-
>
usize
{
self
.
0
.
fetch_add
(
val
order
)
}
#
[
inline
]
pub
fn
fetch_sub
(
&
self
val
:
usize
order
:
Ordering
)
-
>
usize
{
self
.
0
.
fetch_sub
(
val
order
)
}
#
[
inline
]
pub
fn
fetch_and
(
&
self
val
:
usize
order
:
Ordering
)
-
>
usize
{
self
.
0
.
fetch_and
(
val
order
)
}
#
[
inline
]
pub
fn
fetch_or
(
&
self
val
:
usize
order
:
Ordering
)
-
>
usize
{
self
.
0
.
fetch_or
(
val
order
)
}
#
[
inline
]
pub
fn
compare_exchange
(
&
self
old
:
usize
new
:
usize
order
:
Ordering
_
:
Ordering
)
-
>
Result
<
usize
usize
>
{
let
res
=
self
.
0
.
compare_and_swap
(
old
new
order
)
;
if
res
=
=
old
{
Ok
(
res
)
}
else
{
Err
(
res
)
}
}
#
[
inline
]
pub
fn
compare_exchange_weak
(
&
self
old
:
usize
new
:
usize
order
:
Ordering
_
:
Ordering
)
-
>
Result
<
usize
usize
>
{
let
res
=
self
.
0
.
compare_and_swap
(
old
new
order
)
;
if
res
=
=
old
{
Ok
(
res
)
}
else
{
Err
(
res
)
}
}
}
