use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
std
:
:
fmt
;
use
std
:
:
marker
:
:
PhantomData
;
use
raw_mutex
:
:
RawMutex
;
#
[
cfg
(
feature
=
"
owning_ref
"
)
]
use
owning_ref
:
:
StableAddress
;
pub
struct
Mutex
<
T
:
?
Sized
>
{
raw
:
RawMutex
data
:
UnsafeCell
<
T
>
}
unsafe
impl
<
T
:
Send
>
Send
for
Mutex
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Mutex
<
T
>
{
}
#
[
must_use
]
pub
struct
MutexGuard
<
'
a
T
:
?
Sized
+
'
a
>
{
mutex
:
&
'
a
Mutex
<
T
>
marker
:
PhantomData
<
&
'
a
mut
T
>
}
impl
<
T
>
Mutex
<
T
>
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
#
[
inline
]
pub
const
fn
new
(
val
:
T
)
-
>
Mutex
<
T
>
{
Mutex
{
data
:
UnsafeCell
:
:
new
(
val
)
raw
:
RawMutex
:
:
new
(
)
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
#
[
inline
]
pub
fn
new
(
val
:
T
)
-
>
Mutex
<
T
>
{
Mutex
{
data
:
UnsafeCell
:
:
new
(
val
)
raw
:
RawMutex
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
into_inner
(
self
)
-
>
T
{
unsafe
{
self
.
data
.
into_inner
(
)
}
}
}
impl
<
T
:
?
Sized
>
Mutex
<
T
>
{
#
[
inline
]
pub
fn
lock
(
&
self
)
-
>
MutexGuard
<
T
>
{
self
.
raw
.
lock
(
)
;
MutexGuard
{
mutex
:
self
marker
:
PhantomData
}
}
#
[
inline
]
pub
fn
try_lock
(
&
self
)
-
>
Option
<
MutexGuard
<
T
>
>
{
if
self
.
raw
.
try_lock
(
)
{
Some
(
MutexGuard
{
mutex
:
self
marker
:
PhantomData
}
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_lock_for
(
&
self
timeout
:
Duration
)
-
>
Option
<
MutexGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_for
(
timeout
)
{
Some
(
MutexGuard
{
mutex
:
self
marker
:
PhantomData
}
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_lock_until
(
&
self
timeout
:
Instant
)
-
>
Option
<
MutexGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_until
(
timeout
)
{
Some
(
MutexGuard
{
mutex
:
self
marker
:
PhantomData
}
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
data
.
get
(
)
}
}
#
[
inline
]
pub
unsafe
fn
raw_unlock
(
&
self
)
{
self
.
raw
.
unlock
(
false
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_fair
(
&
self
)
{
self
.
raw
.
unlock
(
true
)
;
}
}
impl
Mutex
<
(
)
>
{
#
[
inline
]
pub
fn
raw_lock
(
&
self
)
{
self
.
raw
.
lock
(
)
;
}
#
[
inline
]
pub
fn
raw_try_lock
(
&
self
)
-
>
bool
{
self
.
raw
.
try_lock
(
)
}
}
impl
<
T
:
?
Sized
+
Default
>
Default
for
Mutex
<
T
>
{
#
[
inline
]
fn
default
(
)
-
>
Mutex
<
T
>
{
Mutex
:
:
new
(
Default
:
:
default
(
)
)
}
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Mutex
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
try_lock
(
)
{
Some
(
guard
)
=
>
write
!
(
f
"
Mutex
{
{
data
:
{
:
?
}
}
}
"
&
*
guard
)
None
=
>
write
!
(
f
"
Mutex
{
{
<
locked
>
}
}
"
)
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
MutexGuard
<
'
a
T
>
{
#
[
inline
]
pub
fn
unlock_fair
(
self
)
{
self
.
mutex
.
raw
.
unlock
(
true
)
;
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Deref
for
MutexGuard
<
'
a
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
mutex
.
data
.
get
(
)
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
DerefMut
for
MutexGuard
<
'
a
T
>
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
mutex
.
data
.
get
(
)
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Drop
for
MutexGuard
<
'
a
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
mutex
.
raw
.
unlock
(
false
)
;
}
}
#
[
cfg
(
feature
=
"
owning_ref
"
)
]
unsafe
impl
<
'
a
T
:
?
Sized
>
StableAddress
for
MutexGuard
<
'
a
T
>
{
}
#
[
inline
]
pub
fn
guard_lock
<
'
a
T
:
?
Sized
>
(
guard
:
&
MutexGuard
<
'
a
T
>
)
-
>
&
'
a
RawMutex
{
&
guard
.
mutex
.
raw
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
thread
;
use
{
Mutex
Condvar
}
;
struct
Packet
<
T
>
(
Arc
<
(
Mutex
<
T
>
Condvar
)
>
)
;
#
[
derive
(
Eq
PartialEq
Debug
)
]
struct
NonCopy
(
i32
)
;
unsafe
impl
<
T
:
Send
>
Send
for
Packet
<
T
>
{
}
unsafe
impl
<
T
>
Sync
for
Packet
<
T
>
{
}
#
[
test
]
fn
smoke
(
)
{
let
m
=
Mutex
:
:
new
(
(
)
)
;
drop
(
m
.
lock
(
)
)
;
drop
(
m
.
lock
(
)
)
;
}
#
[
test
]
fn
lots_and_lots
(
)
{
const
J
:
u32
=
1000
;
const
K
:
u32
=
3
;
let
m
=
Arc
:
:
new
(
Mutex
:
:
new
(
0
)
)
;
fn
inc
(
m
:
&
Mutex
<
u32
>
)
{
for
_
in
0
.
.
J
{
*
m
.
lock
(
)
+
=
1
;
}
}
let
(
tx
rx
)
=
channel
(
)
;
for
_
in
0
.
.
K
{
let
tx2
=
tx
.
clone
(
)
;
let
m2
=
m
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
inc
(
&
m2
)
;
tx2
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
let
tx2
=
tx
.
clone
(
)
;
let
m2
=
m
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
inc
(
&
m2
)
;
tx2
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
}
drop
(
tx
)
;
for
_
in
0
.
.
2
*
K
{
rx
.
recv
(
)
.
unwrap
(
)
;
}
assert_eq
!
(
*
m
.
lock
(
)
J
*
K
*
2
)
;
}
#
[
test
]
fn
try_lock
(
)
{
let
m
=
Mutex
:
:
new
(
(
)
)
;
*
m
.
try_lock
(
)
.
unwrap
(
)
=
(
)
;
}
#
[
test
]
fn
test_into_inner
(
)
{
let
m
=
Mutex
:
:
new
(
NonCopy
(
10
)
)
;
assert_eq
!
(
m
.
into_inner
(
)
NonCopy
(
10
)
)
;
}
#
[
test
]
fn
test_into_inner_drop
(
)
{
struct
Foo
(
Arc
<
AtomicUsize
>
)
;
impl
Drop
for
Foo
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
}
let
num_drops
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
m
=
Mutex
:
:
new
(
Foo
(
num_drops
.
clone
(
)
)
)
;
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
0
)
;
{
let
_inner
=
m
.
into_inner
(
)
;
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
0
)
;
}
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
1
)
;
}
#
[
test
]
fn
test_get_mut
(
)
{
let
mut
m
=
Mutex
:
:
new
(
NonCopy
(
10
)
)
;
*
m
.
get_mut
(
)
=
NonCopy
(
20
)
;
assert_eq
!
(
m
.
into_inner
(
)
NonCopy
(
20
)
)
;
}
#
[
test
]
fn
test_mutex_arc_condvar
(
)
{
let
packet
=
Packet
(
Arc
:
:
new
(
(
Mutex
:
:
new
(
false
)
Condvar
:
:
new
(
)
)
)
)
;
let
packet2
=
Packet
(
packet
.
0
.
clone
(
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
rx
.
recv
(
)
.
unwrap
(
)
;
let
&
(
ref
lock
ref
cvar
)
=
&
*
packet2
.
0
;
let
mut
lock
=
lock
.
lock
(
)
;
*
lock
=
true
;
cvar
.
notify_one
(
)
;
}
)
;
let
&
(
ref
lock
ref
cvar
)
=
&
*
packet
.
0
;
let
mut
lock
=
lock
.
lock
(
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
assert
!
(
!
*
lock
)
;
while
!
*
lock
{
cvar
.
wait
(
&
mut
lock
)
;
}
}
#
[
test
]
fn
test_mutex_arc_nested
(
)
{
let
arc
=
Arc
:
:
new
(
Mutex
:
:
new
(
1
)
)
;
let
arc2
=
Arc
:
:
new
(
Mutex
:
:
new
(
arc
)
)
;
let
(
tx
rx
)
=
channel
(
)
;
let
_t
=
thread
:
:
spawn
(
move
|
|
{
let
lock
=
arc2
.
lock
(
)
;
let
lock2
=
lock
.
lock
(
)
;
assert_eq
!
(
*
lock2
1
)
;
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
rx
.
recv
(
)
.
unwrap
(
)
;
}
#
[
test
]
fn
test_mutex_arc_access_in_unwind
(
)
{
let
arc
=
Arc
:
:
new
(
Mutex
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
=
thread
:
:
spawn
(
move
|
|
-
>
(
)
{
struct
Unwinder
{
i
:
Arc
<
Mutex
<
i32
>
>
}
impl
Drop
for
Unwinder
{
fn
drop
(
&
mut
self
)
{
*
self
.
i
.
lock
(
)
+
=
1
;
}
}
let
_u
=
Unwinder
{
i
:
arc2
}
;
panic
!
(
)
;
}
)
.
join
(
)
;
let
lock
=
arc
.
lock
(
)
;
assert_eq
!
(
*
lock
2
)
;
}
#
[
test
]
fn
test_mutex_unsized
(
)
{
let
mutex
:
&
Mutex
<
[
i32
]
>
=
&
Mutex
:
:
new
(
[
1
2
3
]
)
;
{
let
b
=
&
mut
*
mutex
.
lock
(
)
;
b
[
0
]
=
4
;
b
[
2
]
=
5
;
}
let
comp
:
&
[
i32
]
=
&
[
4
2
5
]
;
assert_eq
!
(
&
*
mutex
.
lock
(
)
comp
)
;
}
#
[
test
]
fn
test_mutexguard_send
(
)
{
fn
send
<
T
:
Send
>
(
_
:
T
)
{
}
let
mutex
=
Mutex
:
:
new
(
(
)
)
;
send
(
mutex
.
lock
(
)
)
;
}
}
