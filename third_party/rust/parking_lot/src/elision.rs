use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
pub
trait
AtomicElisionExt
{
type
IntType
;
fn
elision_compare_exchange_acquire
(
&
self
current
:
Self
:
:
IntType
new
:
Self
:
:
IntType
)
-
>
Result
<
Self
:
:
IntType
Self
:
:
IntType
>
;
fn
elision_fetch_sub_release
(
&
self
val
:
Self
:
:
IntType
)
-
>
Self
:
:
IntType
;
}
#
[
inline
]
pub
fn
have_elision
(
)
-
>
bool
{
cfg
!
(
all
(
feature
=
"
nightly
"
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
}
#
[
cfg
(
not
(
all
(
feature
=
"
nightly
"
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
)
]
impl
AtomicElisionExt
for
AtomicUsize
{
type
IntType
=
usize
;
#
[
inline
]
fn
elision_compare_exchange_acquire
(
&
self
_
:
usize
_
:
usize
)
-
>
Result
<
usize
usize
>
{
unreachable
!
(
)
;
}
#
[
inline
]
fn
elision_fetch_sub_release
(
&
self
_
:
usize
)
-
>
usize
{
unreachable
!
(
)
;
}
}
#
[
cfg
(
all
(
feature
=
"
nightly
"
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
]
impl
AtomicElisionExt
for
AtomicUsize
{
type
IntType
=
usize
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
#
[
inline
]
fn
elision_compare_exchange_acquire
(
&
self
current
:
usize
new
:
usize
)
-
>
Result
<
usize
usize
>
{
unsafe
{
let
prev
:
usize
;
asm
!
(
"
xacquire
;
lock
;
cmpxchgl
2
1
"
:
"
=
{
eax
}
"
(
prev
)
"
+
*
m
"
(
self
)
:
"
r
"
(
new
)
"
{
eax
}
"
(
current
)
:
"
memory
"
:
"
volatile
"
)
;
if
prev
=
=
current
{
Ok
(
prev
)
}
else
{
Err
(
prev
)
}
}
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
#
[
inline
]
fn
elision_compare_exchange_acquire
(
&
self
current
:
usize
new
:
usize
)
-
>
Result
<
usize
usize
>
{
unsafe
{
let
prev
:
usize
;
asm
!
(
"
xacquire
;
lock
;
cmpxchgq
2
1
"
:
"
=
{
rax
}
"
(
prev
)
"
+
*
m
"
(
self
)
:
"
r
"
(
new
)
"
{
rax
}
"
(
current
)
:
"
memory
"
:
"
volatile
"
)
;
if
prev
=
=
current
{
Ok
(
prev
)
}
else
{
Err
(
prev
)
}
}
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
#
[
inline
]
fn
elision_fetch_sub_release
(
&
self
val
:
usize
)
-
>
usize
{
unsafe
{
let
prev
:
usize
;
asm
!
(
"
xrelease
;
lock
;
xaddl
2
1
"
:
"
=
r
"
(
prev
)
"
+
*
m
"
(
self
)
:
"
0
"
(
val
.
wrapping_neg
(
)
)
:
"
memory
"
:
"
volatile
"
)
;
prev
}
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
#
[
inline
]
fn
elision_fetch_sub_release
(
&
self
val
:
usize
)
-
>
usize
{
unsafe
{
let
prev
:
usize
;
asm
!
(
"
xrelease
;
lock
;
xaddq
2
1
"
:
"
=
r
"
(
prev
)
"
+
*
m
"
(
self
)
:
"
0
"
(
val
.
wrapping_neg
(
)
)
:
"
memory
"
:
"
volatile
"
)
;
prev
}
}
}
