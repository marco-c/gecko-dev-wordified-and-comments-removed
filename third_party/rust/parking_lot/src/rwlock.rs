use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
marker
:
:
PhantomData
;
use
raw_rwlock
:
:
RawRwLock
;
#
[
cfg
(
feature
=
"
owning_ref
"
)
]
use
owning_ref
:
:
StableAddress
;
pub
struct
RwLock
<
T
:
?
Sized
>
{
raw
:
RawRwLock
data
:
UnsafeCell
<
T
>
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
RwLock
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
+
Sync
>
Sync
for
RwLock
<
T
>
{
}
#
[
must_use
]
pub
struct
RwLockReadGuard
<
'
a
T
:
?
Sized
+
'
a
>
{
raw
:
&
'
a
RawRwLock
data
:
*
const
T
marker
:
PhantomData
<
&
'
a
T
>
}
unsafe
impl
<
'
a
T
:
?
Sized
+
Sync
+
'
a
>
Sync
for
RwLockReadGuard
<
'
a
T
>
{
}
#
[
must_use
]
pub
struct
RwLockWriteGuard
<
'
a
T
:
?
Sized
+
'
a
>
{
raw
:
&
'
a
RawRwLock
data
:
*
mut
T
marker
:
PhantomData
<
&
'
a
mut
T
>
}
unsafe
impl
<
'
a
T
:
?
Sized
+
Sync
+
'
a
>
Sync
for
RwLockWriteGuard
<
'
a
T
>
{
}
#
[
must_use
]
pub
struct
RwLockUpgradableReadGuard
<
'
a
T
:
?
Sized
+
'
a
>
{
raw
:
&
'
a
RawRwLock
data
:
*
mut
T
marker
:
PhantomData
<
&
'
a
T
>
}
unsafe
impl
<
'
a
T
:
?
Sized
+
Sync
+
'
a
>
Sync
for
RwLockUpgradableReadGuard
<
'
a
T
>
{
}
impl
<
T
>
RwLock
<
T
>
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
#
[
inline
]
pub
const
fn
new
(
val
:
T
)
-
>
RwLock
<
T
>
{
RwLock
{
data
:
UnsafeCell
:
:
new
(
val
)
raw
:
RawRwLock
:
:
new
(
)
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
#
[
inline
]
pub
fn
new
(
val
:
T
)
-
>
RwLock
<
T
>
{
RwLock
{
data
:
UnsafeCell
:
:
new
(
val
)
raw
:
RawRwLock
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
into_inner
(
self
)
-
>
T
{
unsafe
{
self
.
data
.
into_inner
(
)
}
}
}
impl
<
T
:
?
Sized
>
RwLock
<
T
>
{
#
[
inline
]
fn
read_guard
(
&
self
)
-
>
RwLockReadGuard
<
T
>
{
RwLockReadGuard
{
raw
:
&
self
.
raw
data
:
self
.
data
.
get
(
)
marker
:
PhantomData
}
}
#
[
inline
]
fn
write_guard
(
&
self
)
-
>
RwLockWriteGuard
<
T
>
{
RwLockWriteGuard
{
raw
:
&
self
.
raw
data
:
self
.
data
.
get
(
)
marker
:
PhantomData
}
}
#
[
inline
]
fn
upgradable_guard
(
&
self
)
-
>
RwLockUpgradableReadGuard
<
T
>
{
RwLockUpgradableReadGuard
{
raw
:
&
self
.
raw
data
:
self
.
data
.
get
(
)
marker
:
PhantomData
}
}
#
[
inline
]
pub
fn
read
(
&
self
)
-
>
RwLockReadGuard
<
T
>
{
self
.
raw
.
lock_shared
(
false
)
;
self
.
read_guard
(
)
}
#
[
inline
]
pub
fn
try_read
(
&
self
)
-
>
Option
<
RwLockReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_shared
(
false
)
{
Some
(
self
.
read_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_read_for
(
&
self
timeout
:
Duration
)
-
>
Option
<
RwLockReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_shared_for
(
false
timeout
)
{
Some
(
self
.
read_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_read_until
(
&
self
timeout
:
Instant
)
-
>
Option
<
RwLockReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_shared_until
(
false
timeout
)
{
Some
(
self
.
read_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
read_recursive
(
&
self
)
-
>
RwLockReadGuard
<
T
>
{
self
.
raw
.
lock_shared
(
true
)
;
self
.
read_guard
(
)
}
#
[
inline
]
pub
fn
try_read_recursive
(
&
self
)
-
>
Option
<
RwLockReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_shared
(
true
)
{
Some
(
self
.
read_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_read_recursive_for
(
&
self
timeout
:
Duration
)
-
>
Option
<
RwLockReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_shared_for
(
true
timeout
)
{
Some
(
self
.
read_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_read_recursive_until
(
&
self
timeout
:
Instant
)
-
>
Option
<
RwLockReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_shared_until
(
true
timeout
)
{
Some
(
self
.
read_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
write
(
&
self
)
-
>
RwLockWriteGuard
<
T
>
{
self
.
raw
.
lock_exclusive
(
)
;
self
.
write_guard
(
)
}
#
[
inline
]
pub
fn
try_write
(
&
self
)
-
>
Option
<
RwLockWriteGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_exclusive
(
)
{
Some
(
self
.
write_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_write_for
(
&
self
timeout
:
Duration
)
-
>
Option
<
RwLockWriteGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_exclusive_for
(
timeout
)
{
Some
(
self
.
write_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_write_until
(
&
self
timeout
:
Instant
)
-
>
Option
<
RwLockWriteGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_exclusive_until
(
timeout
)
{
Some
(
self
.
write_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
upgradable_read
(
&
self
)
-
>
RwLockUpgradableReadGuard
<
T
>
{
self
.
raw
.
lock_upgradable
(
)
;
self
.
upgradable_guard
(
)
}
#
[
inline
]
pub
fn
try_upgradable_read
(
&
self
)
-
>
Option
<
RwLockUpgradableReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_upgradable
(
)
{
Some
(
self
.
upgradable_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_upgradable_read_for
(
&
self
timeout
:
Duration
)
-
>
Option
<
RwLockUpgradableReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_upgradable_for
(
timeout
)
{
Some
(
self
.
upgradable_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
try_upgradable_read_until
(
&
self
timeout
:
Instant
)
-
>
Option
<
RwLockUpgradableReadGuard
<
T
>
>
{
if
self
.
raw
.
try_lock_upgradable_until
(
timeout
)
{
Some
(
self
.
upgradable_guard
(
)
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
data
.
get
(
)
}
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_read
(
&
self
)
{
self
.
raw
.
unlock_shared
(
false
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_write
(
&
self
)
{
self
.
raw
.
unlock_exclusive
(
false
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_upgradable_read
(
&
self
)
{
self
.
raw
.
unlock_upgradable
(
false
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_read_fair
(
&
self
)
{
self
.
raw
.
unlock_shared
(
true
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_write_fair
(
&
self
)
{
self
.
raw
.
unlock_exclusive
(
true
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_unlock_upgradable_read_fair
(
&
self
)
{
self
.
raw
.
unlock_upgradable
(
true
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_downgrade
(
&
self
)
{
self
.
raw
.
exclusive_to_shared
(
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_downgrade_upgradable_read
(
&
self
)
{
self
.
raw
.
upgradable_to_shared
(
)
;
}
}
impl
RwLock
<
(
)
>
{
#
[
inline
]
pub
fn
raw_read
(
&
self
)
{
self
.
raw
.
lock_shared
(
false
)
;
}
#
[
inline
]
pub
fn
raw_try_read
(
&
self
)
-
>
bool
{
self
.
raw
.
try_lock_shared
(
false
)
}
#
[
inline
]
pub
fn
raw_read_recursive
(
&
self
)
{
self
.
raw
.
lock_shared
(
true
)
;
}
#
[
inline
]
pub
fn
raw_try_read_recursive
(
&
self
)
-
>
bool
{
self
.
raw
.
try_lock_shared
(
true
)
}
#
[
inline
]
pub
fn
raw_write
(
&
self
)
{
self
.
raw
.
lock_exclusive
(
)
;
}
#
[
inline
]
pub
fn
raw_try_write
(
&
self
)
-
>
bool
{
self
.
raw
.
try_lock_exclusive
(
)
}
#
[
inline
]
pub
fn
raw_upgradable_read
(
&
self
)
{
self
.
raw
.
lock_upgradable
(
)
;
}
#
[
inline
]
pub
fn
raw_try_upgradable_read
(
&
self
)
-
>
bool
{
self
.
raw
.
try_lock_upgradable
(
)
}
#
[
inline
]
pub
unsafe
fn
raw_upgrade
(
&
self
)
{
self
.
raw
.
upgradable_to_exclusive
(
)
;
}
#
[
inline
]
pub
unsafe
fn
raw_try_upgrade
(
&
self
)
-
>
bool
{
self
.
raw
.
try_upgradable_to_exclusive
(
)
}
}
impl
<
T
:
?
Sized
+
Default
>
Default
for
RwLock
<
T
>
{
#
[
inline
]
fn
default
(
)
-
>
RwLock
<
T
>
{
RwLock
:
:
new
(
Default
:
:
default
(
)
)
}
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
RwLock
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
try_read
(
)
{
Some
(
guard
)
=
>
write
!
(
f
"
RwLock
{
{
data
:
{
:
?
}
}
}
"
&
*
guard
)
None
=
>
write
!
(
f
"
RwLock
{
{
<
locked
>
}
}
"
)
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
RwLockReadGuard
<
'
a
T
>
{
#
[
inline
]
pub
fn
unlock_fair
(
self
)
{
self
.
raw
.
unlock_shared
(
true
)
;
mem
:
:
forget
(
self
)
;
}
#
[
inline
]
pub
fn
map
<
U
:
?
Sized
F
>
(
orig
:
Self
f
:
F
)
-
>
RwLockReadGuard
<
'
a
U
>
where
F
:
FnOnce
(
&
T
)
-
>
&
U
{
let
raw
=
orig
.
raw
;
let
data
=
f
(
unsafe
{
&
*
orig
.
data
}
)
;
mem
:
:
forget
(
orig
)
;
RwLockReadGuard
{
raw
data
marker
:
PhantomData
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Deref
for
RwLockReadGuard
<
'
a
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
data
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Drop
for
RwLockReadGuard
<
'
a
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
raw
.
unlock_shared
(
false
)
;
}
}
#
[
cfg
(
feature
=
"
owning_ref
"
)
]
unsafe
impl
<
'
a
T
:
?
Sized
>
StableAddress
for
RwLockReadGuard
<
'
a
T
>
{
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
RwLockWriteGuard
<
'
a
T
>
{
pub
fn
downgrade
(
self
)
-
>
RwLockReadGuard
<
'
a
T
>
{
self
.
raw
.
exclusive_to_shared
(
)
;
let
raw
=
self
.
raw
;
let
data
=
unsafe
{
&
*
self
.
data
}
;
mem
:
:
forget
(
self
)
;
RwLockReadGuard
{
raw
data
marker
:
PhantomData
}
}
#
[
inline
]
pub
fn
map
<
U
:
?
Sized
F
>
(
orig
:
Self
f
:
F
)
-
>
RwLockWriteGuard
<
'
a
U
>
where
F
:
FnOnce
(
&
mut
T
)
-
>
&
mut
U
{
let
raw
=
orig
.
raw
;
let
data
=
f
(
unsafe
{
&
mut
*
orig
.
data
}
)
;
mem
:
:
forget
(
orig
)
;
RwLockWriteGuard
{
raw
data
marker
:
PhantomData
}
}
#
[
inline
]
pub
fn
unlock_fair
(
self
)
{
self
.
raw
.
unlock_exclusive
(
true
)
;
mem
:
:
forget
(
self
)
;
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Deref
for
RwLockWriteGuard
<
'
a
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
data
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
DerefMut
for
RwLockWriteGuard
<
'
a
T
>
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
unsafe
{
&
mut
*
self
.
data
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Drop
for
RwLockWriteGuard
<
'
a
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
raw
.
unlock_exclusive
(
false
)
;
}
}
#
[
cfg
(
feature
=
"
owning_ref
"
)
]
unsafe
impl
<
'
a
T
:
?
Sized
>
StableAddress
for
RwLockWriteGuard
<
'
a
T
>
{
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
RwLockUpgradableReadGuard
<
'
a
T
>
{
pub
fn
downgrade
(
self
)
-
>
RwLockReadGuard
<
'
a
T
>
{
self
.
raw
.
upgradable_to_shared
(
)
;
let
raw
=
self
.
raw
;
let
data
=
unsafe
{
&
*
self
.
data
}
;
mem
:
:
forget
(
self
)
;
RwLockReadGuard
{
raw
data
marker
:
PhantomData
}
}
pub
fn
upgrade
(
self
)
-
>
RwLockWriteGuard
<
'
a
T
>
{
self
.
raw
.
upgradable_to_exclusive
(
)
;
let
raw
=
self
.
raw
;
let
data
=
unsafe
{
&
mut
*
self
.
data
}
;
mem
:
:
forget
(
self
)
;
RwLockWriteGuard
{
raw
data
marker
:
PhantomData
}
}
pub
fn
try_upgrade
(
self
)
-
>
Result
<
RwLockWriteGuard
<
'
a
T
>
Self
>
{
if
self
.
raw
.
try_upgradable_to_exclusive
(
)
{
let
raw
=
self
.
raw
;
let
data
=
unsafe
{
&
mut
*
self
.
data
}
;
mem
:
:
forget
(
self
)
;
Ok
(
RwLockWriteGuard
{
raw
data
marker
:
PhantomData
}
)
}
else
{
Err
(
self
)
}
}
pub
fn
try_upgrade_for
(
self
timeout
:
Duration
)
-
>
Result
<
RwLockWriteGuard
<
'
a
T
>
Self
>
{
if
self
.
raw
.
try_upgradable_to_exclusive_for
(
timeout
)
{
let
raw
=
self
.
raw
;
let
data
=
unsafe
{
&
mut
*
self
.
data
}
;
mem
:
:
forget
(
self
)
;
Ok
(
RwLockWriteGuard
{
raw
data
marker
:
PhantomData
}
)
}
else
{
Err
(
self
)
}
}
#
[
inline
]
pub
fn
try_upgrade_until
(
self
timeout
:
Instant
)
-
>
Result
<
RwLockWriteGuard
<
'
a
T
>
Self
>
{
if
self
.
raw
.
try_upgradable_to_exclusive_until
(
timeout
)
{
let
raw
=
self
.
raw
;
let
data
=
unsafe
{
&
mut
*
self
.
data
}
;
mem
:
:
forget
(
self
)
;
Ok
(
RwLockWriteGuard
{
raw
data
marker
:
PhantomData
}
)
}
else
{
Err
(
self
)
}
}
#
[
inline
]
pub
fn
unlock_fair
(
self
)
{
self
.
raw
.
unlock_upgradable
(
true
)
;
mem
:
:
forget
(
self
)
;
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Deref
for
RwLockUpgradableReadGuard
<
'
a
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
&
*
self
.
data
}
}
}
impl
<
'
a
T
:
?
Sized
+
'
a
>
Drop
for
RwLockUpgradableReadGuard
<
'
a
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
raw
.
unlock_upgradable
(
false
)
;
}
}
#
[
cfg
(
feature
=
"
owning_ref
"
)
]
unsafe
impl
<
'
a
T
:
?
Sized
>
StableAddress
for
RwLockUpgradableReadGuard
<
'
a
T
>
{
}
#
[
cfg
(
test
)
]
mod
tests
{
extern
crate
rand
;
use
self
:
:
rand
:
:
Rng
;
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
use
std
:
:
thread
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
time
:
:
Duration
;
use
RwLock
;
#
[
derive
(
Eq
PartialEq
Debug
)
]
struct
NonCopy
(
i32
)
;
#
[
test
]
fn
smoke
(
)
{
let
l
=
RwLock
:
:
new
(
(
)
)
;
drop
(
l
.
read
(
)
)
;
drop
(
l
.
write
(
)
)
;
drop
(
l
.
upgradable_read
(
)
)
;
drop
(
(
l
.
read
(
)
l
.
read
(
)
)
)
;
drop
(
(
l
.
read
(
)
l
.
upgradable_read
(
)
)
)
;
drop
(
l
.
write
(
)
)
;
}
#
[
test
]
fn
frob
(
)
{
const
N
:
u32
=
10
;
const
M
:
u32
=
1000
;
let
r
=
Arc
:
:
new
(
RwLock
:
:
new
(
(
)
)
)
;
let
(
tx
rx
)
=
channel
:
:
<
(
)
>
(
)
;
for
_
in
0
.
.
N
{
let
tx
=
tx
.
clone
(
)
;
let
r
=
r
.
clone
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
mut
rng
=
rand
:
:
thread_rng
(
)
;
for
_
in
0
.
.
M
{
if
rng
.
gen_weighted_bool
(
N
)
{
drop
(
r
.
write
(
)
)
;
}
else
{
drop
(
r
.
read
(
)
)
;
}
}
drop
(
tx
)
;
}
)
;
}
drop
(
tx
)
;
let
_
=
rx
.
recv
(
)
;
}
#
[
test
]
fn
test_rw_arc_no_poison_wr
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
:
Result
<
(
)
_
>
=
thread
:
:
spawn
(
move
|
|
{
let
_lock
=
arc2
.
write
(
)
;
panic
!
(
)
;
}
)
.
join
(
)
;
let
lock
=
arc
.
read
(
)
;
assert_eq
!
(
*
lock
1
)
;
}
#
[
test
]
fn
test_rw_arc_no_poison_ww
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
:
Result
<
(
)
_
>
=
thread
:
:
spawn
(
move
|
|
{
let
_lock
=
arc2
.
write
(
)
;
panic
!
(
)
;
}
)
.
join
(
)
;
let
lock
=
arc
.
write
(
)
;
assert_eq
!
(
*
lock
1
)
;
}
#
[
test
]
fn
test_rw_arc_no_poison_rr
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
:
Result
<
(
)
_
>
=
thread
:
:
spawn
(
move
|
|
{
let
_lock
=
arc2
.
read
(
)
;
panic
!
(
)
;
}
)
.
join
(
)
;
let
lock
=
arc
.
read
(
)
;
assert_eq
!
(
*
lock
1
)
;
}
#
[
test
]
fn
test_rw_arc_no_poison_rw
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
:
Result
<
(
)
_
>
=
thread
:
:
spawn
(
move
|
|
{
let
_lock
=
arc2
.
read
(
)
;
panic
!
(
)
}
)
.
join
(
)
;
let
lock
=
arc
.
write
(
)
;
assert_eq
!
(
*
lock
1
)
;
}
#
[
test
]
fn
test_ruw_arc
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
0
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
(
tx
rx
)
=
channel
(
)
;
thread
:
:
spawn
(
move
|
|
{
for
_
in
0
.
.
10
{
let
mut
lock
=
arc2
.
write
(
)
;
let
tmp
=
*
lock
;
*
lock
=
-
1
;
thread
:
:
yield_now
(
)
;
*
lock
=
tmp
+
1
;
}
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
let
mut
children
=
Vec
:
:
new
(
)
;
for
_
in
0
.
.
5
{
let
arc3
=
arc
.
clone
(
)
;
children
.
push
(
thread
:
:
spawn
(
move
|
|
{
let
lock
=
arc3
.
upgradable_read
(
)
;
let
tmp
=
*
lock
;
assert
!
(
tmp
>
=
0
)
;
thread
:
:
yield_now
(
)
;
let
mut
lock
=
lock
.
upgrade
(
)
;
assert_eq
!
(
tmp
*
lock
)
;
*
lock
=
-
1
;
thread
:
:
yield_now
(
)
;
*
lock
=
tmp
+
1
;
}
)
)
;
}
for
_
in
0
.
.
5
{
let
arc4
=
arc
.
clone
(
)
;
children
.
push
(
thread
:
:
spawn
(
move
|
|
{
let
lock
=
arc4
.
read
(
)
;
assert
!
(
*
lock
>
=
0
)
;
}
)
)
;
}
for
r
in
children
{
assert
!
(
r
.
join
(
)
.
is_ok
(
)
)
;
}
rx
.
recv
(
)
.
unwrap
(
)
;
let
lock
=
arc
.
read
(
)
;
assert_eq
!
(
*
lock
15
)
;
}
#
[
test
]
fn
test_rw_arc
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
0
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
(
tx
rx
)
=
channel
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
mut
lock
=
arc2
.
write
(
)
;
for
_
in
0
.
.
10
{
let
tmp
=
*
lock
;
*
lock
=
-
1
;
thread
:
:
yield_now
(
)
;
*
lock
=
tmp
+
1
;
}
tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
)
;
let
mut
children
=
Vec
:
:
new
(
)
;
for
_
in
0
.
.
5
{
let
arc3
=
arc
.
clone
(
)
;
children
.
push
(
thread
:
:
spawn
(
move
|
|
{
let
lock
=
arc3
.
read
(
)
;
assert
!
(
*
lock
>
=
0
)
;
}
)
)
;
}
for
r
in
children
{
assert
!
(
r
.
join
(
)
.
is_ok
(
)
)
;
}
rx
.
recv
(
)
.
unwrap
(
)
;
let
lock
=
arc
.
read
(
)
;
assert_eq
!
(
*
lock
10
)
;
}
#
[
test
]
fn
test_rw_arc_access_in_unwind
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_
=
thread
:
:
spawn
(
move
|
|
-
>
(
)
{
struct
Unwinder
{
i
:
Arc
<
RwLock
<
isize
>
>
}
impl
Drop
for
Unwinder
{
fn
drop
(
&
mut
self
)
{
let
mut
lock
=
self
.
i
.
write
(
)
;
*
lock
+
=
1
;
}
}
let
_u
=
Unwinder
{
i
:
arc2
}
;
panic
!
(
)
;
}
)
.
join
(
)
;
let
lock
=
arc
.
read
(
)
;
assert_eq
!
(
*
lock
2
)
;
}
#
[
test
]
fn
test_rwlock_unsized
(
)
{
let
rw
:
&
RwLock
<
[
i32
]
>
=
&
RwLock
:
:
new
(
[
1
2
3
]
)
;
{
let
b
=
&
mut
*
rw
.
write
(
)
;
b
[
0
]
=
4
;
b
[
2
]
=
5
;
}
let
comp
:
&
[
i32
]
=
&
[
4
2
5
]
;
assert_eq
!
(
&
*
rw
.
read
(
)
comp
)
;
}
#
[
test
]
fn
test_rwlock_try_read
(
)
{
let
lock
=
RwLock
:
:
new
(
0isize
)
;
{
let
read_guard
=
lock
.
read
(
)
;
let
read_result
=
lock
.
try_read
(
)
;
assert
!
(
read_result
.
is_some
(
)
"
try_read
should
succeed
while
read_guard
is
in
scope
"
)
;
drop
(
read_guard
)
;
}
{
let
upgrade_guard
=
lock
.
upgradable_read
(
)
;
let
read_result
=
lock
.
try_read
(
)
;
assert
!
(
read_result
.
is_some
(
)
"
try_read
should
succeed
while
upgrade_guard
is
in
scope
"
)
;
drop
(
upgrade_guard
)
;
}
{
let
write_guard
=
lock
.
write
(
)
;
let
read_result
=
lock
.
try_read
(
)
;
assert
!
(
read_result
.
is_none
(
)
"
try_read
should
fail
while
write_guard
is
in
scope
"
)
;
drop
(
write_guard
)
;
}
}
#
[
test
]
fn
test_rwlock_try_write
(
)
{
let
lock
=
RwLock
:
:
new
(
0isize
)
;
{
let
read_guard
=
lock
.
read
(
)
;
let
write_result
=
lock
.
try_write
(
)
;
assert
!
(
write_result
.
is_none
(
)
"
try_write
should
fail
while
read_guard
is
in
scope
"
)
;
drop
(
read_guard
)
;
}
{
let
upgrade_guard
=
lock
.
upgradable_read
(
)
;
let
write_result
=
lock
.
try_write
(
)
;
assert
!
(
write_result
.
is_none
(
)
"
try_write
should
fail
while
upgrade_guard
is
in
scope
"
)
;
drop
(
upgrade_guard
)
;
}
{
let
write_guard
=
lock
.
write
(
)
;
let
write_result
=
lock
.
try_write
(
)
;
assert
!
(
write_result
.
is_none
(
)
"
try_write
should
fail
while
write_guard
is
in
scope
"
)
;
drop
(
write_guard
)
;
}
}
#
[
test
]
fn
test_rwlock_try_upgrade
(
)
{
let
lock
=
RwLock
:
:
new
(
0isize
)
;
{
let
read_guard
=
lock
.
read
(
)
;
let
upgrade_result
=
lock
.
try_upgradable_read
(
)
;
assert
!
(
upgrade_result
.
is_some
(
)
"
try_upgradable_read
should
succeed
while
read_guard
is
in
scope
"
)
;
drop
(
read_guard
)
;
}
{
let
upgrade_guard
=
lock
.
upgradable_read
(
)
;
let
upgrade_result
=
lock
.
try_upgradable_read
(
)
;
assert
!
(
upgrade_result
.
is_none
(
)
"
try_upgradable_read
should
fail
while
upgrade_guard
is
in
scope
"
)
;
drop
(
upgrade_guard
)
;
}
{
let
write_guard
=
lock
.
write
(
)
;
let
upgrade_result
=
lock
.
try_upgradable_read
(
)
;
assert
!
(
upgrade_result
.
is_none
(
)
"
try_upgradable
should
fail
while
write_guard
is
in
scope
"
)
;
drop
(
write_guard
)
;
}
}
#
[
test
]
fn
test_into_inner
(
)
{
let
m
=
RwLock
:
:
new
(
NonCopy
(
10
)
)
;
assert_eq
!
(
m
.
into_inner
(
)
NonCopy
(
10
)
)
;
}
#
[
test
]
fn
test_into_inner_drop
(
)
{
struct
Foo
(
Arc
<
AtomicUsize
>
)
;
impl
Drop
for
Foo
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
}
let
num_drops
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
m
=
RwLock
:
:
new
(
Foo
(
num_drops
.
clone
(
)
)
)
;
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
0
)
;
{
let
_inner
=
m
.
into_inner
(
)
;
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
0
)
;
}
assert_eq
!
(
num_drops
.
load
(
Ordering
:
:
SeqCst
)
1
)
;
}
#
[
test
]
fn
test_get_mut
(
)
{
let
mut
m
=
RwLock
:
:
new
(
NonCopy
(
10
)
)
;
*
m
.
get_mut
(
)
=
NonCopy
(
20
)
;
assert_eq
!
(
m
.
into_inner
(
)
NonCopy
(
20
)
)
;
}
#
[
test
]
fn
test_rwlockguard_sync
(
)
{
fn
sync
<
T
:
Sync
>
(
_
:
T
)
{
}
let
rwlock
=
RwLock
:
:
new
(
(
)
)
;
sync
(
rwlock
.
read
(
)
)
;
sync
(
rwlock
.
write
(
)
)
;
}
#
[
test
]
fn
test_rwlock_downgrade
(
)
{
let
x
=
Arc
:
:
new
(
RwLock
:
:
new
(
0
)
)
;
let
mut
handles
=
Vec
:
:
new
(
)
;
for
_
in
0
.
.
8
{
let
x
=
x
.
clone
(
)
;
handles
.
push
(
thread
:
:
spawn
(
move
|
|
{
for
_
in
0
.
.
100
{
let
mut
writer
=
x
.
write
(
)
;
*
writer
+
=
1
;
let
cur_val
=
*
writer
;
let
reader
=
writer
.
downgrade
(
)
;
assert_eq
!
(
cur_val
*
reader
)
;
}
}
)
)
;
}
for
handle
in
handles
{
handle
.
join
(
)
.
unwrap
(
)
}
assert_eq
!
(
*
x
.
read
(
)
800
)
;
}
#
[
test
]
fn
test_rwlock_recursive
(
)
{
let
arc
=
Arc
:
:
new
(
RwLock
:
:
new
(
1
)
)
;
let
arc2
=
arc
.
clone
(
)
;
let
_lock1
=
arc
.
read
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
_lock
=
arc2
.
write
(
)
;
}
)
;
thread
:
:
sleep
(
Duration
:
:
from_millis
(
100
)
)
;
let
_lock2
=
arc
.
read_recursive
(
)
;
}
}
