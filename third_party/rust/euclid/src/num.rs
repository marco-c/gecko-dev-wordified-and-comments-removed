use
num_traits
;
pub
trait
Zero
{
fn
zero
(
)
-
>
Self
;
}
impl
<
T
:
num_traits
:
:
Zero
>
Zero
for
T
{
fn
zero
(
)
-
>
T
{
num_traits
:
:
Zero
:
:
zero
(
)
}
}
pub
trait
One
{
fn
one
(
)
-
>
Self
;
}
impl
<
T
:
num_traits
:
:
One
>
One
for
T
{
fn
one
(
)
-
>
T
{
num_traits
:
:
One
:
:
one
(
)
}
}
pub
trait
Round
:
Copy
{
#
[
must_use
]
fn
round
(
self
)
-
>
Self
;
}
pub
trait
Floor
:
Copy
{
#
[
must_use
]
fn
floor
(
self
)
-
>
Self
;
}
pub
trait
Ceil
:
Copy
{
#
[
must_use
]
fn
ceil
(
self
)
-
>
Self
;
}
macro_rules
!
num_int
{
(
ty
:
ty
)
=
>
{
impl
Round
for
ty
{
#
[
inline
]
fn
round
(
self
)
-
>
ty
{
self
}
}
impl
Floor
for
ty
{
#
[
inline
]
fn
floor
(
self
)
-
>
ty
{
self
}
}
impl
Ceil
for
ty
{
#
[
inline
]
fn
ceil
(
self
)
-
>
ty
{
self
}
}
}
;
}
macro_rules
!
num_float
{
(
ty
:
ty
)
=
>
{
impl
Round
for
ty
{
#
[
inline
]
fn
round
(
self
)
-
>
ty
{
(
self
+
0
.
5
)
.
floor
(
)
}
}
impl
Floor
for
ty
{
#
[
inline
]
fn
floor
(
self
)
-
>
ty
{
num_traits
:
:
Float
:
:
floor
(
self
)
}
}
impl
Ceil
for
ty
{
#
[
inline
]
fn
ceil
(
self
)
-
>
ty
{
num_traits
:
:
Float
:
:
ceil
(
self
)
}
}
}
;
}
num_int
!
(
i16
)
;
num_int
!
(
u16
)
;
num_int
!
(
i32
)
;
num_int
!
(
u32
)
;
num_int
!
(
i64
)
;
num_int
!
(
u64
)
;
num_int
!
(
isize
)
;
num_int
!
(
usize
)
;
num_float
!
(
f32
)
;
num_float
!
(
f64
)
;
