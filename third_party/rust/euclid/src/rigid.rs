use
approxeq
:
:
ApproxEq
;
use
num_traits
:
:
Float
;
use
trig
:
:
Trig
;
use
{
Rotation3D
Transform3D
Vector3D
}
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
repr
(
C
)
]
pub
struct
RigidTransform3D
<
T
Src
Dst
>
{
pub
rotation
:
Rotation3D
<
T
Src
Dst
>
pub
translation
:
Vector3D
<
T
Dst
>
}
impl
<
T
:
Float
+
ApproxEq
<
T
>
Src
Dst
>
RigidTransform3D
<
T
Src
Dst
>
{
#
[
inline
]
pub
fn
new
(
rotation
:
Rotation3D
<
T
Src
Dst
>
translation
:
Vector3D
<
T
Dst
>
)
-
>
Self
{
Self
{
rotation
translation
}
}
#
[
inline
]
pub
fn
identity
(
)
-
>
Self
{
Self
{
rotation
:
Rotation3D
:
:
identity
(
)
translation
:
Vector3D
:
:
zero
(
)
}
}
#
[
inline
]
pub
fn
new_from_reversed
(
translation
:
Vector3D
<
T
Src
>
rotation
:
Rotation3D
<
T
Src
Dst
>
)
-
>
Self
{
let
translation
=
rotation
.
transform_vector3d
(
translation
)
;
Self
{
rotation
translation
}
}
#
[
inline
]
pub
fn
from_rotation
(
rotation
:
Rotation3D
<
T
Src
Dst
>
)
-
>
Self
{
Self
{
rotation
translation
:
Vector3D
:
:
zero
(
)
}
}
#
[
inline
]
pub
fn
from_translation
(
translation
:
Vector3D
<
T
Dst
>
)
-
>
Self
{
Self
{
translation
rotation
:
Rotation3D
:
:
identity
(
)
}
}
#
[
inline
]
pub
fn
decompose_reversed
(
&
self
)
-
>
(
Vector3D
<
T
Src
>
Rotation3D
<
T
Src
Dst
>
)
{
let
translation
=
self
.
rotation
.
inverse
(
)
.
transform_vector3d
(
self
.
translation
)
;
(
translation
self
.
rotation
)
}
#
[
inline
]
pub
fn
post_transform
<
Dst2
>
(
&
self
other
:
&
RigidTransform3D
<
T
Dst
Dst2
>
)
-
>
RigidTransform3D
<
T
Src
Dst2
>
{
let
t_prime
=
other
.
rotation
.
transform_vector3d
(
self
.
translation
)
;
let
r_prime
=
self
.
rotation
.
post_rotate
(
&
other
.
rotation
)
;
let
t_prime2
=
t_prime
+
other
.
translation
;
RigidTransform3D
{
rotation
:
r_prime
translation
:
t_prime2
}
}
#
[
inline
]
pub
fn
pre_transform
<
Src2
>
(
&
self
other
:
&
RigidTransform3D
<
T
Src2
Src
>
)
-
>
RigidTransform3D
<
T
Src2
Dst
>
{
other
.
post_transform
(
&
self
)
}
#
[
inline
]
pub
fn
inverse
(
&
self
)
-
>
RigidTransform3D
<
T
Dst
Src
>
{
RigidTransform3D
:
:
new_from_reversed
(
-
self
.
translation
self
.
rotation
.
inverse
(
)
)
}
pub
fn
to_transform
(
&
self
)
-
>
Transform3D
<
T
Src
Dst
>
where
T
:
Trig
{
self
.
translation
.
to_transform
(
)
.
pre_transform
(
&
self
.
rotation
.
to_transform
(
)
)
}
}
impl
<
T
:
Float
+
ApproxEq
<
T
>
Src
Dst
>
From
<
Rotation3D
<
T
Src
Dst
>
>
for
RigidTransform3D
<
T
Src
Dst
>
{
fn
from
(
rot
:
Rotation3D
<
T
Src
Dst
>
)
-
>
Self
{
Self
:
:
from_rotation
(
rot
)
}
}
impl
<
T
:
Float
+
ApproxEq
<
T
>
Src
Dst
>
From
<
Vector3D
<
T
Dst
>
>
for
RigidTransform3D
<
T
Src
Dst
>
{
fn
from
(
t
:
Vector3D
<
T
Dst
>
)
-
>
Self
{
Self
:
:
from_translation
(
t
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
RigidTransform3D
;
use
default
:
:
{
Rotation3D
Transform3D
Vector3D
}
;
#
[
test
]
fn
test_rigid_construction
(
)
{
let
translation
=
Vector3D
:
:
new
(
12
.
1
17
.
8
-
5
.
5
)
;
let
rotation
=
Rotation3D
:
:
unit_quaternion
(
0
.
5
-
7
.
8
2
.
2
4
.
3
)
;
let
rigid
=
RigidTransform3D
:
:
new
(
rotation
translation
)
;
assert
!
(
rigid
.
to_transform
(
)
.
approx_eq
(
&
translation
.
to_transform
(
)
.
pre_transform
(
&
rotation
.
to_transform
(
)
)
)
)
;
let
rigid
=
RigidTransform3D
:
:
new_from_reversed
(
translation
rotation
)
;
assert
!
(
rigid
.
to_transform
(
)
.
approx_eq
(
&
translation
.
to_transform
(
)
.
post_transform
(
&
rotation
.
to_transform
(
)
)
)
)
;
}
#
[
test
]
fn
test_rigid_decomposition
(
)
{
let
translation
=
Vector3D
:
:
new
(
12
.
1
17
.
8
-
5
.
5
)
;
let
rotation
=
Rotation3D
:
:
unit_quaternion
(
0
.
5
-
7
.
8
2
.
2
4
.
3
)
;
let
rigid
=
RigidTransform3D
:
:
new
(
rotation
translation
)
;
let
(
t2
r2
)
=
rigid
.
decompose_reversed
(
)
;
assert
!
(
rigid
.
to_transform
(
)
.
approx_eq
(
&
t2
.
to_transform
(
)
.
post_transform
(
&
r2
.
to_transform
(
)
)
)
)
;
}
#
[
test
]
fn
test_rigid_inverse
(
)
{
let
translation
=
Vector3D
:
:
new
(
12
.
1
17
.
8
-
5
.
5
)
;
let
rotation
=
Rotation3D
:
:
unit_quaternion
(
0
.
5
-
7
.
8
2
.
2
4
.
3
)
;
let
rigid
=
RigidTransform3D
:
:
new
(
rotation
translation
)
;
let
inverse
=
rigid
.
inverse
(
)
;
assert
!
(
rigid
.
post_transform
(
&
inverse
)
.
to_transform
(
)
.
approx_eq
(
&
Transform3D
:
:
identity
(
)
)
)
;
assert
!
(
inverse
.
to_transform
(
)
.
approx_eq
(
&
rigid
.
to_transform
(
)
.
inverse
(
)
.
unwrap
(
)
)
)
;
}
#
[
test
]
fn
test_rigid_multiply
(
)
{
let
translation
=
Vector3D
:
:
new
(
12
.
1
17
.
8
-
5
.
5
)
;
let
rotation
=
Rotation3D
:
:
unit_quaternion
(
0
.
5
-
7
.
8
2
.
2
4
.
3
)
;
let
translation2
=
Vector3D
:
:
new
(
9
.
3
-
3
.
9
1
.
1
)
;
let
rotation2
=
Rotation3D
:
:
unit_quaternion
(
0
.
1
0
.
2
0
.
3
-
0
.
4
)
;
let
rigid
=
RigidTransform3D
:
:
new
(
rotation
translation
)
;
let
rigid2
=
RigidTransform3D
:
:
new
(
rotation2
translation2
)
;
assert
!
(
rigid
.
post_transform
(
&
rigid2
)
.
to_transform
(
)
.
approx_eq
(
&
rigid
.
to_transform
(
)
.
post_transform
(
&
rigid2
.
to_transform
(
)
)
)
)
;
assert
!
(
rigid
.
pre_transform
(
&
rigid2
)
.
to_transform
(
)
.
approx_eq
(
&
rigid
.
to_transform
(
)
.
pre_transform
(
&
rigid2
.
to_transform
(
)
)
)
)
;
}
}
