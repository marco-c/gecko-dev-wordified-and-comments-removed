#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
deny
(
unconditional_recursion
)
]
use
core
:
:
{
convert
:
:
{
TryFrom
TryInto
}
fmt
:
:
{
Binary
Debug
Display
LowerExp
LowerHex
Octal
UpperExp
UpperHex
}
hash
:
:
Hash
iter
:
:
{
Product
Sum
}
num
:
:
{
FpCategory
ParseIntError
}
ops
:
:
{
Add
AddAssign
BitAnd
BitAndAssign
BitOr
BitOrAssign
BitXor
BitXorAssign
Div
DivAssign
Mul
MulAssign
Neg
Not
Rem
RemAssign
Shl
ShlAssign
Shr
ShrAssign
Sub
SubAssign
}
str
:
:
FromStr
}
;
pub
trait
IsNumber
:
Sized
+
Send
+
Sync
+
Unpin
+
Clone
+
Copy
+
Default
+
FromStr
+
PartialEq
<
Self
>
+
PartialOrd
<
Self
>
+
Debug
+
Display
+
Product
<
Self
>
+
for
<
'
a
>
Product
<
&
'
a
Self
>
+
Sum
<
Self
>
+
for
<
'
a
>
Sum
<
&
'
a
Self
>
+
Add
<
Self
Output
=
Self
>
+
for
<
'
a
>
Add
<
&
'
a
Self
Output
=
Self
>
+
AddAssign
<
Self
>
+
for
<
'
a
>
AddAssign
<
&
'
a
Self
>
+
Sub
<
Self
Output
=
Self
>
+
for
<
'
a
>
Sub
<
&
'
a
Self
Output
=
Self
>
+
SubAssign
<
Self
>
+
for
<
'
a
>
SubAssign
<
&
'
a
Self
>
+
Mul
<
Self
Output
=
Self
>
+
for
<
'
a
>
Mul
<
&
'
a
Self
Output
=
Self
>
+
MulAssign
<
Self
>
+
for
<
'
a
>
MulAssign
<
&
'
a
Self
>
+
Div
<
Self
Output
=
Self
>
+
for
<
'
a
>
Div
<
&
'
a
Self
Output
=
Self
>
+
DivAssign
<
Self
>
+
for
<
'
a
>
DivAssign
<
&
'
a
Self
>
+
Rem
<
Self
Output
=
Self
>
+
for
<
'
a
>
Rem
<
&
'
a
Self
Output
=
Self
>
+
RemAssign
<
Self
>
+
for
<
'
a
>
RemAssign
<
&
'
a
Self
>
{
type
Bytes
;
fn
to_be_bytes
(
self
)
-
>
Self
:
:
Bytes
;
fn
to_le_bytes
(
self
)
-
>
Self
:
:
Bytes
;
fn
to_ne_bytes
(
self
)
-
>
Self
:
:
Bytes
;
fn
from_be_bytes
(
bytes
:
Self
:
:
Bytes
)
-
>
Self
;
fn
from_le_bytes
(
bytes
:
Self
:
:
Bytes
)
-
>
Self
;
fn
from_ne_bytes
(
bytes
:
Self
:
:
Bytes
)
-
>
Self
;
}
pub
trait
IsInteger
:
IsNumber
+
Hash
+
Eq
+
Ord
+
Binary
+
LowerHex
+
UpperHex
+
Octal
+
BitAnd
<
Self
Output
=
Self
>
+
for
<
'
a
>
BitAnd
<
&
'
a
Self
Output
=
Self
>
+
BitAndAssign
<
Self
>
+
for
<
'
a
>
BitAndAssign
<
&
'
a
Self
>
+
BitOr
<
Self
Output
=
Self
>
+
for
<
'
a
>
BitOr
<
&
'
a
Self
Output
=
Self
>
+
BitOrAssign
<
Self
>
+
for
<
'
a
>
BitOrAssign
<
&
'
a
Self
>
+
BitXor
<
Self
Output
=
Self
>
+
for
<
'
a
>
BitXor
<
&
'
a
Self
Output
=
Self
>
+
BitXorAssign
<
Self
>
+
for
<
'
a
>
BitXorAssign
<
&
'
a
Self
>
+
Not
<
Output
=
Self
>
+
TryFrom
<
i8
>
+
TryFrom
<
u8
>
+
TryFrom
<
i16
>
+
TryFrom
<
u16
>
+
TryFrom
<
i32
>
+
TryFrom
<
u32
>
+
TryFrom
<
i64
>
+
TryFrom
<
u64
>
+
TryFrom
<
i128
>
+
TryFrom
<
u128
>
+
TryFrom
<
isize
>
+
TryFrom
<
usize
>
+
TryInto
<
i8
>
+
TryInto
<
u8
>
+
TryInto
<
i16
>
+
TryInto
<
u16
>
+
TryInto
<
i32
>
+
TryInto
<
u32
>
+
TryInto
<
i64
>
+
TryInto
<
u64
>
+
TryInto
<
i128
>
+
TryInto
<
u128
>
+
TryInto
<
isize
>
+
TryInto
<
usize
>
+
Shl
<
i8
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
i8
Output
=
Self
>
+
ShlAssign
<
i8
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
i8
>
+
Shr
<
i8
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
i8
Output
=
Self
>
+
ShrAssign
<
i8
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
i8
>
+
Shl
<
u8
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
u8
Output
=
Self
>
+
ShlAssign
<
u8
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
u8
>
+
Shr
<
u8
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
u8
Output
=
Self
>
+
ShrAssign
<
u8
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
u8
>
+
Shl
<
i16
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
i16
Output
=
Self
>
+
ShlAssign
<
i16
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
i16
>
+
Shr
<
i16
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
i16
Output
=
Self
>
+
ShrAssign
<
i16
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
i16
>
+
Shl
<
u16
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
u16
Output
=
Self
>
+
ShlAssign
<
u16
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
u16
>
+
Shr
<
u16
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
u16
Output
=
Self
>
+
ShrAssign
<
u16
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
u16
>
+
Shl
<
i32
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
i32
Output
=
Self
>
+
ShlAssign
<
i32
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
i32
>
+
Shr
<
i32
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
i32
Output
=
Self
>
+
ShrAssign
<
i32
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
i32
>
+
Shl
<
u32
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
u32
Output
=
Self
>
+
ShlAssign
<
u32
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
u32
>
+
Shr
<
u32
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
u32
Output
=
Self
>
+
ShrAssign
<
u32
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
u32
>
+
Shl
<
i64
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
i64
Output
=
Self
>
+
ShlAssign
<
i64
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
i64
>
+
Shr
<
i64
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
i64
Output
=
Self
>
+
ShrAssign
<
i64
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
i64
>
+
Shl
<
u64
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
u64
Output
=
Self
>
+
ShlAssign
<
u64
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
u64
>
+
Shr
<
u64
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
u64
Output
=
Self
>
+
ShrAssign
<
u64
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
u64
>
+
Shl
<
i128
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
i128
Output
=
Self
>
+
ShlAssign
<
i128
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
i128
>
+
Shr
<
i128
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
i128
Output
=
Self
>
+
ShrAssign
<
i128
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
i128
>
+
Shl
<
u128
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
u128
Output
=
Self
>
+
ShlAssign
<
u128
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
u128
>
+
Shr
<
u128
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
u128
Output
=
Self
>
+
ShrAssign
<
u128
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
u128
>
+
Shl
<
isize
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
isize
Output
=
Self
>
+
ShlAssign
<
isize
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
isize
>
+
Shr
<
isize
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
isize
Output
=
Self
>
+
ShrAssign
<
isize
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
isize
>
+
Shl
<
usize
Output
=
Self
>
+
for
<
'
a
>
Shl
<
&
'
a
usize
Output
=
Self
>
+
ShlAssign
<
usize
>
+
for
<
'
a
>
ShlAssign
<
&
'
a
usize
>
+
Shr
<
usize
Output
=
Self
>
+
for
<
'
a
>
Shr
<
&
'
a
usize
Output
=
Self
>
+
ShrAssign
<
usize
>
+
for
<
'
a
>
ShrAssign
<
&
'
a
usize
>
{
const
ZERO
:
Self
;
const
MIN
:
Self
;
const
MAX
:
Self
;
fn
min_value
(
)
-
>
Self
;
fn
max_value
(
)
-
>
Self
;
fn
from_str_radix
(
src
:
&
str
radix
:
u32
)
-
>
Result
<
Self
ParseIntError
>
;
fn
count_ones
(
self
)
-
>
u32
;
fn
count_zeros
(
self
)
-
>
u32
;
fn
leading_zeros
(
self
)
-
>
u32
;
fn
trailing_zeros
(
self
)
-
>
u32
;
fn
leading_ones
(
self
)
-
>
u32
;
fn
trailing_ones
(
self
)
-
>
u32
;
fn
rotate_left
(
self
n
:
u32
)
-
>
Self
;
fn
rotate_right
(
self
n
:
u32
)
-
>
Self
;
fn
swap_bytes
(
self
)
-
>
Self
;
fn
reverse_bits
(
self
)
-
>
Self
;
fn
from_be
(
self
)
-
>
Self
;
fn
from_le
(
self
)
-
>
Self
;
fn
to_be
(
self
)
-
>
Self
;
fn
to_le
(
self
)
-
>
Self
;
fn
checked_add
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_sub
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_mul
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_div
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_div_euclid
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_rem
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_rem_euclid
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
;
fn
checked_neg
(
self
)
-
>
Option
<
Self
>
;
fn
checked_shl
(
self
rhs
:
u32
)
-
>
Option
<
Self
>
;
fn
checked_shr
(
self
rhs
:
u32
)
-
>
Option
<
Self
>
;
fn
checked_pow
(
self
rhs
:
u32
)
-
>
Option
<
Self
>
;
fn
saturating_add
(
self
rhs
:
Self
)
-
>
Self
;
fn
saturating_sub
(
self
rhs
:
Self
)
-
>
Self
;
fn
saturating_mul
(
self
rhs
:
Self
)
-
>
Self
;
fn
saturating_pow
(
self
rhs
:
u32
)
-
>
Self
;
fn
wrapping_add
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_sub
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_mul
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_div
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_div_euclid
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_rem
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_rem_euclid
(
self
rhs
:
Self
)
-
>
Self
;
fn
wrapping_neg
(
self
)
-
>
Self
;
fn
wrapping_shl
(
self
rhs
:
u32
)
-
>
Self
;
fn
wrapping_shr
(
self
rhs
:
u32
)
-
>
Self
;
fn
wrapping_pow
(
self
rhs
:
u32
)
-
>
Self
;
fn
overflowing_add
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_sub
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_mul
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_div
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_div_euclid
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_rem
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_rem_euclid
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
;
fn
overflowing_neg
(
self
)
-
>
(
Self
bool
)
;
fn
overflowing_shl
(
self
rhs
:
u32
)
-
>
(
Self
bool
)
;
fn
overflowing_shr
(
self
rhs
:
u32
)
-
>
(
Self
bool
)
;
fn
overflowing_pow
(
self
rhs
:
u32
)
-
>
(
Self
bool
)
;
fn
pow
(
self
rhs
:
u32
)
-
>
Self
;
fn
div_euclid
(
self
rhs
:
Self
)
-
>
Self
;
fn
rem_euclid
(
self
rhs
:
Self
)
-
>
Self
;
}
pub
trait
IsSigned
:
IsInteger
+
Neg
{
fn
checked_abs
(
self
)
-
>
Option
<
Self
>
;
fn
wrapping_abs
(
self
)
-
>
Self
;
fn
overflowing_abs
(
self
)
-
>
(
Self
bool
)
;
fn
abs
(
self
)
-
>
Self
;
fn
signum
(
self
)
-
>
Self
;
fn
is_positive
(
self
)
-
>
bool
;
fn
is_negative
(
self
)
-
>
bool
;
}
pub
trait
IsUnsigned
:
IsInteger
{
fn
is_power_of_two
(
self
)
-
>
bool
;
fn
next_power_of_two
(
self
)
-
>
Self
;
fn
checked_next_power_of_two
(
self
)
-
>
Option
<
Self
>
;
}
pub
trait
IsFloat
:
IsNumber
+
LowerExp
+
UpperExp
+
Neg
+
From
<
f32
>
+
From
<
i8
>
+
From
<
i16
>
+
From
<
u8
>
+
From
<
u16
>
{
type
Raw
:
IsUnsigned
;
const
RADIX
:
u32
;
const
MANTISSA_DIGITS
:
u32
;
const
DIGITS
:
u32
;
const
EPSILON
:
Self
;
const
MIN
:
Self
;
const
MIN_POSITIVE
:
Self
;
const
MAX
:
Self
;
const
MIN_EXP
:
i32
;
const
MAX_EXP
:
i32
;
const
MIN_10_EXP
:
i32
;
const
MAX_10_EXP
:
i32
;
const
NAN
:
Self
;
const
INFINITY
:
Self
;
const
NEG_INFINITY
:
Self
;
const
PI
:
Self
;
const
FRAC_PI_2
:
Self
;
const
FRAC_PI_3
:
Self
;
const
FRAC_PI_4
:
Self
;
const
FRAC_PI_6
:
Self
;
const
FRAC_PI_8
:
Self
;
const
FRAC_1_PI
:
Self
;
const
FRAC_2_PI
:
Self
;
const
FRAC_2_SQRT_PI
:
Self
;
const
SQRT_2
:
Self
;
const
FRAC_1_SQRT_2
:
Self
;
const
E
:
Self
;
const
LOG2_E
:
Self
;
const
LOG10_E
:
Self
;
const
LN_2
:
Self
;
const
LN_10
:
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
floor
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
ceil
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
round
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
trunc
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
fract
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
abs
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
signum
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
copysign
(
self
sign
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
mul_add
(
self
a
:
Self
b
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
div_euclid
(
self
rhs
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
rem_euclid
(
self
rhs
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
powi
(
self
n
:
i32
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
powf
(
self
n
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
sqrt
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
exp
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
exp2
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
ln
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
log
(
self
base
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
log2
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
log10
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
cbrt
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
hypot
(
self
other
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
sin
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
cos
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
tan
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
asin
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
acos
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
atan
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
atan2
(
self
other
:
Self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
sin_cos
(
self
)
-
>
(
Self
Self
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
exp_m1
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
ln_1p
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
sinh
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
cosh
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
tanh
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
asinh
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
acosh
(
self
)
-
>
Self
;
#
[
cfg
(
feature
=
"
std
"
)
]
fn
atanh
(
self
)
-
>
Self
;
fn
is_nan
(
self
)
-
>
bool
;
fn
is_infinite
(
self
)
-
>
bool
;
fn
is_finite
(
self
)
-
>
bool
;
fn
is_normal
(
self
)
-
>
bool
;
fn
classify
(
self
)
-
>
FpCategory
;
fn
is_sign_positive
(
self
)
-
>
bool
;
fn
is_sign_negative
(
self
)
-
>
bool
;
fn
recip
(
self
)
-
>
Self
;
fn
to_degrees
(
self
)
-
>
Self
;
fn
to_radians
(
self
)
-
>
Self
;
fn
max
(
self
other
:
Self
)
-
>
Self
;
fn
min
(
self
other
:
Self
)
-
>
Self
;
fn
to_bits
(
self
)
-
>
Self
:
:
Raw
;
fn
from_bits
(
bits
:
Self
:
:
Raw
)
-
>
Self
;
}
pub
trait
Is8
:
IsNumber
{
}
pub
trait
Is16
:
IsNumber
{
}
pub
trait
Is32
:
IsNumber
{
}
pub
trait
Is64
:
IsNumber
{
}
pub
trait
Is128
:
IsNumber
{
}
pub
trait
AtLeast8
:
IsNumber
{
}
pub
trait
AtLeast16
:
IsNumber
{
}
pub
trait
AtLeast32
:
IsNumber
{
}
pub
trait
AtLeast64
:
IsNumber
{
}
pub
trait
AtLeast128
:
IsNumber
{
}
pub
trait
AtMost8
:
IsNumber
{
}
pub
trait
AtMost16
:
IsNumber
{
}
pub
trait
AtMost32
:
IsNumber
{
}
pub
trait
AtMost64
:
IsNumber
{
}
pub
trait
AtMost128
:
IsNumber
{
}
macro_rules
!
func
{
(
name
:
ident
(
self
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
fn
name
(
self
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
self
(
arg
)
*
)
}
}
;
(
name
:
ident
(
&
self
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
fn
name
(
&
self
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
&
self
(
arg
)
*
)
}
}
;
(
name
:
ident
(
&
mut
self
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
fn
name
(
&
mut
self
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
&
mut
self
(
arg
)
*
)
}
}
;
(
name
:
ident
(
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
fn
name
(
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
(
arg
)
*
)
}
}
;
}
macro_rules
!
stdfunc
{
(
name
:
ident
(
self
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
name
(
self
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
self
(
arg
)
*
)
}
}
;
(
name
:
ident
(
&
self
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
name
(
&
self
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
&
self
(
arg
)
*
)
}
}
;
(
name
:
ident
(
&
mut
self
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
name
(
&
mut
self
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
&
mut
self
(
arg
)
*
)
}
}
;
(
name
:
ident
(
(
arg
:
ident
:
t
:
ty
)
*
)
(
-
>
ret
:
ty
)
?
)
=
>
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
name
(
(
arg
:
t
)
*
)
(
-
>
ret
)
?
{
<
Self
>
:
:
name
(
(
arg
)
*
)
}
}
;
}
macro_rules
!
impl_for
{
(
IsNumber
=
>
(
t
:
ty
)
+
(
)
?
)
=
>
{
(
impl
IsNumber
for
t
{
type
Bytes
=
[
u8
;
core
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
;
func
!
(
to_be_bytes
(
self
)
-
>
Self
:
:
Bytes
)
;
func
!
(
to_le_bytes
(
self
)
-
>
Self
:
:
Bytes
)
;
func
!
(
to_ne_bytes
(
self
)
-
>
Self
:
:
Bytes
)
;
func
!
(
from_be_bytes
(
bytes
:
Self
:
:
Bytes
)
-
>
Self
)
;
func
!
(
from_le_bytes
(
bytes
:
Self
:
:
Bytes
)
-
>
Self
)
;
func
!
(
from_ne_bytes
(
bytes
:
Self
:
:
Bytes
)
-
>
Self
)
;
}
)
+
}
;
(
IsInteger
=
>
(
t
:
ty
)
+
(
)
?
)
=
>
{
(
impl
IsInteger
for
t
{
const
ZERO
:
Self
=
0
;
const
MIN
:
Self
=
<
Self
>
:
:
min_value
(
)
;
const
MAX
:
Self
=
<
Self
>
:
:
max_value
(
)
;
func
!
(
min_value
(
)
-
>
Self
)
;
func
!
(
max_value
(
)
-
>
Self
)
;
func
!
(
from_str_radix
(
src
:
&
str
radix
:
u32
)
-
>
Result
<
Self
ParseIntError
>
)
;
func
!
(
count_ones
(
self
)
-
>
u32
)
;
func
!
(
count_zeros
(
self
)
-
>
u32
)
;
func
!
(
leading_zeros
(
self
)
-
>
u32
)
;
func
!
(
trailing_zeros
(
self
)
-
>
u32
)
;
func
!
(
leading_ones
(
self
)
-
>
u32
)
;
func
!
(
trailing_ones
(
self
)
-
>
u32
)
;
func
!
(
rotate_left
(
self
n
:
u32
)
-
>
Self
)
;
func
!
(
rotate_right
(
self
n
:
u32
)
-
>
Self
)
;
func
!
(
swap_bytes
(
self
)
-
>
Self
)
;
func
!
(
reverse_bits
(
self
)
-
>
Self
)
;
func
!
(
from_be
(
self
)
-
>
Self
)
;
func
!
(
from_le
(
self
)
-
>
Self
)
;
func
!
(
to_be
(
self
)
-
>
Self
)
;
func
!
(
to_le
(
self
)
-
>
Self
)
;
func
!
(
checked_add
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_sub
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_mul
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_div
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_div_euclid
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_rem
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_rem_euclid
(
self
rhs
:
Self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_neg
(
self
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_shl
(
self
rhs
:
u32
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_shr
(
self
rhs
:
u32
)
-
>
Option
<
Self
>
)
;
func
!
(
checked_pow
(
self
rhs
:
u32
)
-
>
Option
<
Self
>
)
;
func
!
(
saturating_add
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
saturating_sub
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
saturating_mul
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
saturating_pow
(
self
rhs
:
u32
)
-
>
Self
)
;
func
!
(
wrapping_add
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_sub
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_mul
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_div
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_div_euclid
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_rem
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_rem_euclid
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
wrapping_neg
(
self
)
-
>
Self
)
;
func
!
(
wrapping_shl
(
self
rhs
:
u32
)
-
>
Self
)
;
func
!
(
wrapping_shr
(
self
rhs
:
u32
)
-
>
Self
)
;
func
!
(
wrapping_pow
(
self
rhs
:
u32
)
-
>
Self
)
;
func
!
(
overflowing_add
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_sub
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_mul
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_div
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_div_euclid
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_rem
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_rem_euclid
(
self
rhs
:
Self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_neg
(
self
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_shl
(
self
rhs
:
u32
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_shr
(
self
rhs
:
u32
)
-
>
(
Self
bool
)
)
;
func
!
(
overflowing_pow
(
self
rhs
:
u32
)
-
>
(
Self
bool
)
)
;
func
!
(
pow
(
self
rhs
:
u32
)
-
>
Self
)
;
func
!
(
div_euclid
(
self
rhs
:
Self
)
-
>
Self
)
;
func
!
(
rem_euclid
(
self
rhs
:
Self
)
-
>
Self
)
;
}
)
+
}
;
(
IsSigned
=
>
(
t
:
ty
)
+
(
)
?
)
=
>
{
(
impl
IsSigned
for
t
{
func
!
(
checked_abs
(
self
)
-
>
Option
<
Self
>
)
;
func
!
(
wrapping_abs
(
self
)
-
>
Self
)
;
func
!
(
overflowing_abs
(
self
)
-
>
(
Self
bool
)
)
;
func
!
(
abs
(
self
)
-
>
Self
)
;
func
!
(
signum
(
self
)
-
>
Self
)
;
func
!
(
is_positive
(
self
)
-
>
bool
)
;
func
!
(
is_negative
(
self
)
-
>
bool
)
;
}
)
+
}
;
(
IsUnsigned
=
>
(
t
:
ty
)
+
(
)
?
)
=
>
{
(
impl
IsUnsigned
for
t
{
func
!
(
is_power_of_two
(
self
)
-
>
bool
)
;
func
!
(
next_power_of_two
(
self
)
-
>
Self
)
;
func
!
(
checked_next_power_of_two
(
self
)
-
>
Option
<
Self
>
)
;
}
)
+
}
;
(
IsFloat
=
>
(
t
:
ident
|
u
:
ty
)
+
(
)
?
)
=
>
{
(
impl
IsFloat
for
t
{
type
Raw
=
u
;
const
RADIX
:
u32
=
core
:
:
t
:
:
RADIX
;
const
MANTISSA_DIGITS
:
u32
=
core
:
:
t
:
:
MANTISSA_DIGITS
;
const
DIGITS
:
u32
=
core
:
:
t
:
:
DIGITS
;
const
EPSILON
:
Self
=
core
:
:
t
:
:
EPSILON
;
const
MIN
:
Self
=
core
:
:
t
:
:
MIN
;
const
MIN_POSITIVE
:
Self
=
core
:
:
t
:
:
MIN_POSITIVE
;
const
MAX
:
Self
=
core
:
:
t
:
:
MAX
;
const
MIN_EXP
:
i32
=
core
:
:
t
:
:
MIN_EXP
;
const
MAX_EXP
:
i32
=
core
:
:
t
:
:
MAX_EXP
;
const
MIN_10_EXP
:
i32
=
core
:
:
t
:
:
MIN_10_EXP
;
const
MAX_10_EXP
:
i32
=
core
:
:
t
:
:
MAX_10_EXP
;
const
NAN
:
Self
=
core
:
:
t
:
:
NAN
;
const
INFINITY
:
Self
=
core
:
:
t
:
:
INFINITY
;
const
NEG_INFINITY
:
Self
=
core
:
:
t
:
:
NEG_INFINITY
;
const
PI
:
Self
=
core
:
:
t
:
:
consts
:
:
PI
;
const
FRAC_PI_2
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_PI_2
;
const
FRAC_PI_3
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_PI_3
;
const
FRAC_PI_4
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_PI_4
;
const
FRAC_PI_6
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_PI_6
;
const
FRAC_PI_8
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_PI_8
;
const
FRAC_1_PI
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_1_PI
;
const
FRAC_2_PI
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_2_PI
;
const
FRAC_2_SQRT_PI
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_2_SQRT_PI
;
const
SQRT_2
:
Self
=
core
:
:
t
:
:
consts
:
:
SQRT_2
;
const
FRAC_1_SQRT_2
:
Self
=
core
:
:
t
:
:
consts
:
:
FRAC_1_SQRT_2
;
const
E
:
Self
=
core
:
:
t
:
:
consts
:
:
E
;
const
LOG2_E
:
Self
=
core
:
:
t
:
:
consts
:
:
LOG2_E
;
const
LOG10_E
:
Self
=
core
:
:
t
:
:
consts
:
:
LOG10_E
;
const
LN_2
:
Self
=
core
:
:
t
:
:
consts
:
:
LN_2
;
const
LN_10
:
Self
=
core
:
:
t
:
:
consts
:
:
LN_10
;
stdfunc
!
(
floor
(
self
)
-
>
Self
)
;
stdfunc
!
(
ceil
(
self
)
-
>
Self
)
;
stdfunc
!
(
round
(
self
)
-
>
Self
)
;
stdfunc
!
(
trunc
(
self
)
-
>
Self
)
;
stdfunc
!
(
fract
(
self
)
-
>
Self
)
;
stdfunc
!
(
abs
(
self
)
-
>
Self
)
;
stdfunc
!
(
signum
(
self
)
-
>
Self
)
;
stdfunc
!
(
copysign
(
self
sign
:
Self
)
-
>
Self
)
;
stdfunc
!
(
mul_add
(
self
a
:
Self
b
:
Self
)
-
>
Self
)
;
stdfunc
!
(
div_euclid
(
self
rhs
:
Self
)
-
>
Self
)
;
stdfunc
!
(
rem_euclid
(
self
rhs
:
Self
)
-
>
Self
)
;
stdfunc
!
(
powi
(
self
n
:
i32
)
-
>
Self
)
;
stdfunc
!
(
powf
(
self
n
:
Self
)
-
>
Self
)
;
stdfunc
!
(
sqrt
(
self
)
-
>
Self
)
;
stdfunc
!
(
exp
(
self
)
-
>
Self
)
;
stdfunc
!
(
exp2
(
self
)
-
>
Self
)
;
stdfunc
!
(
ln
(
self
)
-
>
Self
)
;
stdfunc
!
(
log
(
self
base
:
Self
)
-
>
Self
)
;
stdfunc
!
(
log2
(
self
)
-
>
Self
)
;
stdfunc
!
(
log10
(
self
)
-
>
Self
)
;
stdfunc
!
(
cbrt
(
self
)
-
>
Self
)
;
stdfunc
!
(
hypot
(
self
other
:
Self
)
-
>
Self
)
;
stdfunc
!
(
sin
(
self
)
-
>
Self
)
;
stdfunc
!
(
cos
(
self
)
-
>
Self
)
;
stdfunc
!
(
tan
(
self
)
-
>
Self
)
;
stdfunc
!
(
asin
(
self
)
-
>
Self
)
;
stdfunc
!
(
acos
(
self
)
-
>
Self
)
;
stdfunc
!
(
atan
(
self
)
-
>
Self
)
;
stdfunc
!
(
atan2
(
self
other
:
Self
)
-
>
Self
)
;
stdfunc
!
(
sin_cos
(
self
)
-
>
(
Self
Self
)
)
;
stdfunc
!
(
exp_m1
(
self
)
-
>
Self
)
;
stdfunc
!
(
ln_1p
(
self
)
-
>
Self
)
;
stdfunc
!
(
sinh
(
self
)
-
>
Self
)
;
stdfunc
!
(
cosh
(
self
)
-
>
Self
)
;
stdfunc
!
(
tanh
(
self
)
-
>
Self
)
;
stdfunc
!
(
asinh
(
self
)
-
>
Self
)
;
stdfunc
!
(
acosh
(
self
)
-
>
Self
)
;
stdfunc
!
(
atanh
(
self
)
-
>
Self
)
;
func
!
(
is_nan
(
self
)
-
>
bool
)
;
func
!
(
is_infinite
(
self
)
-
>
bool
)
;
func
!
(
is_finite
(
self
)
-
>
bool
)
;
func
!
(
is_normal
(
self
)
-
>
bool
)
;
func
!
(
classify
(
self
)
-
>
FpCategory
)
;
func
!
(
is_sign_positive
(
self
)
-
>
bool
)
;
func
!
(
is_sign_negative
(
self
)
-
>
bool
)
;
func
!
(
recip
(
self
)
-
>
Self
)
;
func
!
(
to_degrees
(
self
)
-
>
Self
)
;
func
!
(
to_radians
(
self
)
-
>
Self
)
;
func
!
(
max
(
self
other
:
Self
)
-
>
Self
)
;
func
!
(
min
(
self
other
:
Self
)
-
>
Self
)
;
func
!
(
to_bits
(
self
)
-
>
Self
:
:
Raw
)
;
func
!
(
from_bits
(
bits
:
Self
:
:
Raw
)
-
>
Self
)
;
}
)
+
}
;
(
which
:
ty
=
>
(
t
:
ty
)
+
(
)
?
)
=
>
{
(
impl
which
for
t
{
}
)
+
}
;
}
impl_for
!
(
IsNumber
=
>
i8
i16
i32
i64
i128
isize
u8
u16
u32
u64
u128
usize
f32
f64
)
;
impl_for
!
(
IsInteger
=
>
i8
i16
i32
i64
i128
isize
u8
u16
u32
u64
u128
usize
)
;
impl_for
!
(
IsSigned
=
>
i8
i16
i32
i64
i128
isize
)
;
impl_for
!
(
IsUnsigned
=
>
u8
u16
u32
u64
u128
usize
)
;
impl_for
!
(
IsFloat
=
>
f32
|
u32
f64
|
u64
)
;
impl_for
!
(
Is8
=
>
i8
u8
)
;
impl_for
!
(
Is16
=
>
i16
u16
)
;
impl_for
!
(
Is32
=
>
i32
u32
f32
)
;
impl_for
!
(
Is64
=
>
i64
u64
f64
)
;
impl_for
!
(
Is128
=
>
i128
u128
)
;
#
[
cfg
(
target_pointer_width
=
"
16
"
)
]
impl_for
!
(
Is16
=
>
isize
usize
)
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
impl_for
!
(
Is32
=
>
isize
usize
)
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
impl_for
!
(
Is64
=
>
isize
usize
)
;
impl_for
!
(
AtLeast8
=
>
i8
i16
i32
i64
i128
isize
u8
u16
u32
u64
u128
usize
f32
f64
)
;
impl_for
!
(
AtLeast16
=
>
i16
i32
i64
i128
u16
u32
u64
u128
f32
f64
)
;
impl_for
!
(
AtLeast32
=
>
i32
i64
i128
u32
u64
u128
f32
f64
)
;
impl_for
!
(
AtLeast64
=
>
i64
i128
u64
u128
f64
)
;
impl_for
!
(
AtLeast128
=
>
i128
u128
)
;
#
[
cfg
(
any
(
target_pointer_width
=
"
16
"
target_pointer_width
=
"
32
"
target_pointer_width
=
"
64
"
)
)
]
impl_for
!
(
AtLeast16
=
>
isize
usize
)
;
#
[
cfg
(
any
(
target_pointer_width
=
"
32
"
target_pointer_width
=
"
64
"
)
)
]
impl_for
!
(
AtLeast32
=
>
isize
usize
)
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
impl_for
!
(
AtLeast64
=
>
isize
usize
)
;
impl_for
!
(
AtMost8
=
>
i8
u8
)
;
impl_for
!
(
AtMost16
=
>
i8
i16
u8
u16
)
;
impl_for
!
(
AtMost32
=
>
i8
i16
i32
u8
u16
u32
f32
)
;
impl_for
!
(
AtMost64
=
>
i8
i16
i32
i64
isize
u8
u16
u32
u64
usize
f32
f64
)
;
impl_for
!
(
AtMost128
=
>
i8
i16
i32
i64
i128
isize
u8
u16
u32
u64
u128
usize
f32
f64
)
;
#
[
cfg
(
target_pointer_width
=
"
16
"
)
]
impl_for
!
(
AtMost16
=
>
isize
usize
)
;
#
[
cfg
(
any
(
target_pointer_width
=
"
16
"
target_pointer_width
=
"
32
"
)
)
]
impl_for
!
(
AtMost32
=
>
isize
usize
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
static_assertions
:
:
*
;
assert_impl_all
!
(
i8
:
IsInteger
IsSigned
Is8
)
;
assert_impl_all
!
(
i16
:
IsInteger
IsSigned
Is16
)
;
assert_impl_all
!
(
i32
:
IsInteger
IsSigned
Is32
)
;
assert_impl_all
!
(
i64
:
IsInteger
IsSigned
Is64
)
;
assert_impl_all
!
(
i128
:
IsInteger
IsSigned
Is128
)
;
assert_impl_all
!
(
isize
:
IsInteger
IsSigned
)
;
assert_impl_all
!
(
u8
:
IsInteger
IsUnsigned
Is8
)
;
assert_impl_all
!
(
u16
:
IsInteger
IsUnsigned
Is16
)
;
assert_impl_all
!
(
u32
:
IsInteger
IsUnsigned
Is32
)
;
assert_impl_all
!
(
u64
:
IsInteger
IsUnsigned
Is64
)
;
assert_impl_all
!
(
u128
:
IsInteger
IsUnsigned
Is128
)
;
assert_impl_all
!
(
usize
:
IsInteger
IsUnsigned
)
;
assert_impl_all
!
(
f32
:
IsFloat
Is32
)
;
assert_impl_all
!
(
f64
:
IsFloat
Is64
)
;
}
