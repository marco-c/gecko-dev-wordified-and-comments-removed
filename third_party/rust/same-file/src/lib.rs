#
!
[
allow
(
bare_trait_objects
unknown_lints
)
]
#
!
[
deny
(
missing_docs
)
]
#
[
cfg
(
test
)
]
doc_comment
:
:
doctest
!
(
"
.
.
/
README
.
md
"
)
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
;
use
std
:
:
path
:
:
Path
;
#
[
cfg
(
any
(
target_os
=
"
redox
"
unix
)
)
]
use
crate
:
:
unix
as
imp
;
#
[
cfg
(
not
(
any
(
target_os
=
"
redox
"
unix
windows
)
)
)
]
use
unknown
as
imp
;
#
[
cfg
(
windows
)
]
use
win
as
imp
;
#
[
cfg
(
any
(
target_os
=
"
redox
"
unix
)
)
]
mod
unix
;
#
[
cfg
(
not
(
any
(
target_os
=
"
redox
"
unix
windows
)
)
)
]
mod
unknown
;
#
[
cfg
(
windows
)
]
mod
win
;
#
[
derive
(
Debug
Eq
PartialEq
Hash
)
]
pub
struct
Handle
(
imp
:
:
Handle
)
;
impl
Handle
{
pub
fn
from_path
<
P
:
AsRef
<
Path
>
>
(
p
:
P
)
-
>
io
:
:
Result
<
Handle
>
{
imp
:
:
Handle
:
:
from_path
(
p
)
.
map
(
Handle
)
}
pub
fn
from_file
(
file
:
File
)
-
>
io
:
:
Result
<
Handle
>
{
imp
:
:
Handle
:
:
from_file
(
file
)
.
map
(
Handle
)
}
pub
fn
stdin
(
)
-
>
io
:
:
Result
<
Handle
>
{
imp
:
:
Handle
:
:
stdin
(
)
.
map
(
Handle
)
}
pub
fn
stdout
(
)
-
>
io
:
:
Result
<
Handle
>
{
imp
:
:
Handle
:
:
stdout
(
)
.
map
(
Handle
)
}
pub
fn
stderr
(
)
-
>
io
:
:
Result
<
Handle
>
{
imp
:
:
Handle
:
:
stderr
(
)
.
map
(
Handle
)
}
pub
fn
as_file
(
&
self
)
-
>
&
File
{
self
.
0
.
as_file
(
)
}
pub
fn
as_file_mut
(
&
mut
self
)
-
>
&
mut
File
{
self
.
0
.
as_file_mut
(
)
}
#
[
cfg
(
any
(
target_os
=
"
redox
"
unix
)
)
]
pub
fn
dev
(
&
self
)
-
>
u64
{
self
.
0
.
dev
(
)
}
#
[
cfg
(
any
(
target_os
=
"
redox
"
unix
)
)
]
pub
fn
ino
(
&
self
)
-
>
u64
{
self
.
0
.
ino
(
)
}
}
pub
fn
is_same_file
<
P
Q
>
(
path1
:
P
path2
:
Q
)
-
>
io
:
:
Result
<
bool
>
where
P
:
AsRef
<
Path
>
Q
:
AsRef
<
Path
>
{
Ok
(
Handle
:
:
from_path
(
path1
)
?
=
=
Handle
:
:
from_path
(
path2
)
?
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
env
;
use
std
:
:
error
;
use
std
:
:
fs
:
:
{
self
File
}
;
use
std
:
:
io
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
result
;
use
super
:
:
is_same_file
;
type
Result
<
T
>
=
result
:
:
Result
<
T
Box
<
error
:
:
Error
+
Send
+
Sync
>
>
;
macro_rules
!
err
{
(
(
tt
:
tt
)
*
)
=
>
{
Box
:
:
<
error
:
:
Error
+
Send
+
Sync
>
:
:
from
(
format
!
(
(
tt
)
*
)
)
}
}
#
[
derive
(
Debug
)
]
struct
TempDir
(
PathBuf
)
;
impl
Drop
for
TempDir
{
fn
drop
(
&
mut
self
)
{
fs
:
:
remove_dir_all
(
&
self
.
0
)
.
unwrap
(
)
;
}
}
impl
TempDir
{
fn
new
(
)
-
>
Result
<
TempDir
>
{
#
!
[
allow
(
deprecated
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
ATOMIC_USIZE_INIT
}
;
static
TRIES
:
usize
=
100
;
static
COUNTER
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
let
tmpdir
=
env
:
:
temp_dir
(
)
;
for
_
in
0
.
.
TRIES
{
let
count
=
COUNTER
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
let
path
=
tmpdir
.
join
(
"
rust
-
walkdir
"
)
.
join
(
count
.
to_string
(
)
)
;
if
path
.
is_dir
(
)
{
continue
;
}
fs
:
:
create_dir_all
(
&
path
)
.
map_err
(
|
e
|
{
err
!
(
"
failed
to
create
{
}
:
{
}
"
path
.
display
(
)
e
)
}
)
?
;
return
Ok
(
TempDir
(
path
)
)
;
}
Err
(
err
!
(
"
failed
to
create
temp
dir
after
{
}
tries
"
TRIES
)
)
}
fn
path
(
&
self
)
-
>
&
Path
{
&
self
.
0
}
}
fn
tmpdir
(
)
-
>
TempDir
{
TempDir
:
:
new
(
)
.
unwrap
(
)
}
#
[
cfg
(
unix
)
]
pub
fn
soft_link_dir
<
P
:
AsRef
<
Path
>
Q
:
AsRef
<
Path
>
>
(
src
:
P
dst
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
symlink
;
symlink
(
src
dst
)
}
#
[
cfg
(
unix
)
]
pub
fn
soft_link_file
<
P
:
AsRef
<
Path
>
Q
:
AsRef
<
Path
>
>
(
src
:
P
dst
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
soft_link_dir
(
src
dst
)
}
#
[
cfg
(
windows
)
]
pub
fn
soft_link_dir
<
P
:
AsRef
<
Path
>
Q
:
AsRef
<
Path
>
>
(
src
:
P
dst
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
windows
:
:
fs
:
:
symlink_dir
;
symlink_dir
(
src
dst
)
}
#
[
cfg
(
windows
)
]
pub
fn
soft_link_file
<
P
:
AsRef
<
Path
>
Q
:
AsRef
<
Path
>
>
(
src
:
P
dst
:
Q
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
windows
:
:
fs
:
:
symlink_file
;
symlink_file
(
src
dst
)
}
#
[
test
]
fn
same_file_trivial
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
File
:
:
create
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
assert
!
(
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
same_dir_trivial
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
fs
:
:
create_dir
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
assert
!
(
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
not_same_file_trivial
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
File
:
:
create
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
File
:
:
create
(
dir
.
join
(
"
b
"
)
)
.
unwrap
(
)
;
assert
!
(
!
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
b
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
not_same_dir_trivial
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
fs
:
:
create_dir
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
fs
:
:
create_dir
(
dir
.
join
(
"
b
"
)
)
.
unwrap
(
)
;
assert
!
(
!
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
b
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
same_file_hard
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
File
:
:
create
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
fs
:
:
hard_link
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
alink
"
)
)
.
unwrap
(
)
;
assert
!
(
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
alink
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
same_file_soft
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
File
:
:
create
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
soft_link_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
alink
"
)
)
.
unwrap
(
)
;
assert
!
(
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
alink
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
same_dir_soft
(
)
{
let
tdir
=
tmpdir
(
)
;
let
dir
=
tdir
.
path
(
)
;
fs
:
:
create_dir
(
dir
.
join
(
"
a
"
)
)
.
unwrap
(
)
;
soft_link_dir
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
alink
"
)
)
.
unwrap
(
)
;
assert
!
(
is_same_file
(
dir
.
join
(
"
a
"
)
dir
.
join
(
"
alink
"
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_send
(
)
{
fn
assert_send
<
T
:
Send
>
(
)
{
}
assert_send
:
:
<
super
:
:
Handle
>
(
)
;
}
#
[
test
]
fn
test_sync
(
)
{
fn
assert_sync
<
T
:
Sync
>
(
)
{
}
assert_sync
:
:
<
super
:
:
Handle
>
(
)
;
}
}
