#
include
"
config
.
h
"
#
include
<
errno
.
h
>
#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
"
backtrace
.
h
"
#
include
"
internal
.
h
"
#
ifndef
MAP_ANONYMOUS
#
define
MAP_ANONYMOUS
MAP_ANON
#
endif
#
ifndef
MAP_FAILED
#
define
MAP_FAILED
(
(
void
*
)
-
1
)
#
endif
struct
backtrace_freelist_struct
{
struct
backtrace_freelist_struct
*
next
;
size_t
size
;
}
;
static
void
backtrace_free_locked
(
struct
backtrace_state
*
state
void
*
addr
size_t
size
)
{
if
(
size
>
=
sizeof
(
struct
backtrace_freelist_struct
)
)
{
struct
backtrace_freelist_struct
*
p
;
p
=
(
struct
backtrace_freelist_struct
*
)
addr
;
p
-
>
next
=
state
-
>
freelist
;
p
-
>
size
=
size
;
state
-
>
freelist
=
p
;
}
}
void
*
backtrace_alloc
(
struct
backtrace_state
*
state
size_t
size
backtrace_error_callback
error_callback
void
*
data
)
{
void
*
ret
;
int
locked
;
struct
backtrace_freelist_struct
*
*
pp
;
size_t
pagesize
;
size_t
asksize
;
void
*
page
;
ret
=
NULL
;
if
(
!
state
-
>
threaded
)
locked
=
1
;
else
locked
=
__sync_lock_test_and_set
(
&
state
-
>
lock_alloc
1
)
=
=
0
;
if
(
locked
)
{
for
(
pp
=
&
state
-
>
freelist
;
*
pp
!
=
NULL
;
pp
=
&
(
*
pp
)
-
>
next
)
{
if
(
(
*
pp
)
-
>
size
>
=
size
)
{
struct
backtrace_freelist_struct
*
p
;
p
=
*
pp
;
*
pp
=
p
-
>
next
;
size
=
(
size
+
7
)
&
~
(
size_t
)
7
;
if
(
size
<
p
-
>
size
)
backtrace_free_locked
(
state
(
char
*
)
p
+
size
p
-
>
size
-
size
)
;
ret
=
(
void
*
)
p
;
break
;
}
}
if
(
state
-
>
threaded
)
__sync_lock_release
(
&
state
-
>
lock_alloc
)
;
}
if
(
ret
=
=
NULL
)
{
pagesize
=
getpagesize
(
)
;
asksize
=
(
size
+
pagesize
-
1
)
&
~
(
pagesize
-
1
)
;
page
=
mmap
(
NULL
asksize
PROT_READ
|
PROT_WRITE
MAP_PRIVATE
|
MAP_ANONYMOUS
-
1
0
)
;
if
(
page
=
=
MAP_FAILED
)
{
if
(
error_callback
)
error_callback
(
data
"
mmap
"
errno
)
;
}
else
{
size
=
(
size
+
7
)
&
~
(
size_t
)
7
;
if
(
size
<
asksize
)
backtrace_free
(
state
(
char
*
)
page
+
size
asksize
-
size
error_callback
data
)
;
ret
=
page
;
}
}
return
ret
;
}
void
backtrace_free
(
struct
backtrace_state
*
state
void
*
addr
size_t
size
backtrace_error_callback
error_callback
ATTRIBUTE_UNUSED
void
*
data
ATTRIBUTE_UNUSED
)
{
int
locked
;
if
(
size
>
=
16
*
4096
)
{
size_t
pagesize
;
pagesize
=
getpagesize
(
)
;
if
(
(
(
uintptr_t
)
addr
&
(
pagesize
-
1
)
)
=
=
0
&
&
(
size
&
(
pagesize
-
1
)
)
=
=
0
)
{
if
(
munmap
(
addr
size
)
=
=
0
)
return
;
}
}
if
(
!
state
-
>
threaded
)
locked
=
1
;
else
locked
=
__sync_lock_test_and_set
(
&
state
-
>
lock_alloc
1
)
=
=
0
;
if
(
locked
)
{
backtrace_free_locked
(
state
addr
size
)
;
if
(
state
-
>
threaded
)
__sync_lock_release
(
&
state
-
>
lock_alloc
)
;
}
}
void
*
backtrace_vector_grow
(
struct
backtrace_state
*
state
size_t
size
backtrace_error_callback
error_callback
void
*
data
struct
backtrace_vector
*
vec
)
{
void
*
ret
;
if
(
size
>
vec
-
>
alc
)
{
size_t
pagesize
;
size_t
alc
;
void
*
base
;
pagesize
=
getpagesize
(
)
;
alc
=
vec
-
>
size
+
size
;
if
(
vec
-
>
size
=
=
0
)
alc
=
16
*
size
;
else
if
(
alc
<
pagesize
)
{
alc
*
=
2
;
if
(
alc
>
pagesize
)
alc
=
pagesize
;
}
else
{
alc
*
=
2
;
alc
=
(
alc
+
pagesize
-
1
)
&
~
(
pagesize
-
1
)
;
}
base
=
backtrace_alloc
(
state
alc
error_callback
data
)
;
if
(
base
=
=
NULL
)
return
NULL
;
if
(
vec
-
>
base
!
=
NULL
)
{
memcpy
(
base
vec
-
>
base
vec
-
>
size
)
;
backtrace_free
(
state
vec
-
>
base
vec
-
>
size
+
vec
-
>
alc
error_callback
data
)
;
}
vec
-
>
base
=
base
;
vec
-
>
alc
=
alc
-
vec
-
>
size
;
}
ret
=
(
char
*
)
vec
-
>
base
+
vec
-
>
size
;
vec
-
>
size
+
=
size
;
vec
-
>
alc
-
=
size
;
return
ret
;
}
void
*
backtrace_vector_finish
(
struct
backtrace_state
*
state
ATTRIBUTE_UNUSED
struct
backtrace_vector
*
vec
backtrace_error_callback
error_callback
ATTRIBUTE_UNUSED
void
*
data
ATTRIBUTE_UNUSED
)
{
void
*
ret
;
ret
=
vec
-
>
base
;
vec
-
>
base
=
(
char
*
)
vec
-
>
base
+
vec
-
>
size
;
vec
-
>
size
=
0
;
return
ret
;
}
int
backtrace_vector_release
(
struct
backtrace_state
*
state
struct
backtrace_vector
*
vec
backtrace_error_callback
error_callback
void
*
data
)
{
size_t
size
;
size_t
alc
;
size_t
aligned
;
size
=
vec
-
>
size
;
alc
=
vec
-
>
alc
;
aligned
=
(
size
+
7
)
&
~
(
size_t
)
7
;
alc
-
=
aligned
-
size
;
backtrace_free
(
state
(
char
*
)
vec
-
>
base
+
aligned
alc
error_callback
data
)
;
vec
-
>
alc
=
0
;
return
1
;
}
