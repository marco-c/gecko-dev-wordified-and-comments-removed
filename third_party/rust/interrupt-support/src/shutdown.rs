use
crate
:
:
Interruptee
;
use
parking_lot
:
:
Mutex
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
Weak
;
use
crate
:
:
SqlInterruptHandle
;
static
IN_SHUTDOWN
:
AtomicBool
=
AtomicBool
:
:
new
(
false
)
;
lazy_static
:
:
lazy_static
!
{
static
ref
REGISTERED_INTERRUPTS
:
Mutex
<
Vec
<
Weak
<
dyn
AsRef
<
SqlInterruptHandle
>
+
Send
+
Sync
>
>
>
=
Mutex
:
:
new
(
Vec
:
:
new
(
)
)
;
}
pub
fn
shutdown
(
)
{
IN_SHUTDOWN
.
store
(
true
Ordering
:
:
Relaxed
)
;
for
weak
in
REGISTERED_INTERRUPTS
.
lock
(
)
.
iter
(
)
{
if
let
Some
(
interrupt
)
=
weak
.
upgrade
(
)
{
interrupt
.
as_ref
(
)
.
as_ref
(
)
.
interrupt
(
)
}
}
}
pub
fn
in_shutdown
(
)
-
>
bool
{
IN_SHUTDOWN
.
load
(
Ordering
:
:
Relaxed
)
}
pub
fn
register_interrupt
(
interrupt
:
Weak
<
dyn
AsRef
<
SqlInterruptHandle
>
+
Send
+
Sync
>
)
{
let
mut
interrupts
=
REGISTERED_INTERRUPTS
.
lock
(
)
;
for
weak
in
interrupts
.
iter_mut
(
)
{
if
weak
.
strong_count
(
)
=
=
0
{
*
weak
=
interrupt
;
return
;
}
}
interrupts
.
push
(
interrupt
)
;
}
pub
struct
ShutdownInterruptee
;
impl
Interruptee
for
ShutdownInterruptee
{
#
[
inline
]
fn
was_interrupted
(
&
self
)
-
>
bool
{
in_shutdown
(
)
}
}
