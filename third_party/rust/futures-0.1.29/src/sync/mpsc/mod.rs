use
std
:
:
fmt
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
thread
;
use
std
:
:
usize
;
use
sync
:
:
mpsc
:
:
queue
:
:
{
Queue
PopResult
}
;
use
sync
:
:
oneshot
;
use
task
:
:
{
self
Task
}
;
use
future
:
:
Executor
;
use
sink
:
:
SendAll
;
use
resultstream
:
:
{
self
Results
}
;
use
{
Async
AsyncSink
Future
Poll
StartSend
Sink
Stream
}
;
mod
queue
;
#
[
derive
(
Debug
)
]
pub
struct
Sender
<
T
>
{
inner
:
Arc
<
Inner
<
T
>
>
sender_task
:
Arc
<
Mutex
<
SenderTask
>
>
maybe_parked
:
bool
}
#
[
derive
(
Debug
)
]
pub
struct
UnboundedSender
<
T
>
(
Sender
<
T
>
)
;
trait
AssertKinds
:
Send
+
Sync
+
Clone
{
}
impl
AssertKinds
for
UnboundedSender
<
u32
>
{
}
#
[
derive
(
Debug
)
]
pub
struct
Receiver
<
T
>
{
inner
:
Arc
<
Inner
<
T
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
UnboundedReceiver
<
T
>
(
Receiver
<
T
>
)
;
#
[
derive
(
Clone
PartialEq
Eq
)
]
pub
struct
SendError
<
T
>
(
T
)
;
#
[
derive
(
Clone
PartialEq
Eq
)
]
pub
struct
TrySendError
<
T
>
{
kind
:
TrySendErrorKind
<
T
>
}
#
[
derive
(
Clone
PartialEq
Eq
)
]
enum
TrySendErrorKind
<
T
>
{
Full
(
T
)
Disconnected
(
T
)
}
impl
<
T
>
fmt
:
:
Debug
for
SendError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_tuple
(
"
SendError
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
}
}
impl
<
T
>
fmt
:
:
Display
for
SendError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
send
failed
because
receiver
is
gone
"
)
}
}
impl
<
T
:
Any
>
Error
for
SendError
<
T
>
{
fn
description
(
&
self
)
-
>
&
str
{
"
send
failed
because
receiver
is
gone
"
}
}
impl
<
T
>
SendError
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
0
}
}
impl
<
T
>
fmt
:
:
Debug
for
TrySendError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_tuple
(
"
TrySendError
"
)
.
field
(
&
"
.
.
.
"
)
.
finish
(
)
}
}
impl
<
T
>
fmt
:
:
Display
for
TrySendError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
is_full
(
)
{
write
!
(
fmt
"
send
failed
because
channel
is
full
"
)
}
else
{
write
!
(
fmt
"
send
failed
because
receiver
is
gone
"
)
}
}
}
impl
<
T
:
Any
>
Error
for
TrySendError
<
T
>
{
fn
description
(
&
self
)
-
>
&
str
{
if
self
.
is_full
(
)
{
"
send
failed
because
channel
is
full
"
}
else
{
"
send
failed
because
receiver
is
gone
"
}
}
}
impl
<
T
>
TrySendError
<
T
>
{
pub
fn
is_full
(
&
self
)
-
>
bool
{
use
self
:
:
TrySendErrorKind
:
:
*
;
match
self
.
kind
{
Full
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
is_disconnected
(
&
self
)
-
>
bool
{
use
self
:
:
TrySendErrorKind
:
:
*
;
match
self
.
kind
{
Disconnected
(
_
)
=
>
true
_
=
>
false
}
}
pub
fn
into_inner
(
self
)
-
>
T
{
use
self
:
:
TrySendErrorKind
:
:
*
;
match
self
.
kind
{
Full
(
v
)
|
Disconnected
(
v
)
=
>
v
}
}
}
#
[
derive
(
Debug
)
]
struct
Inner
<
T
>
{
buffer
:
Option
<
usize
>
state
:
AtomicUsize
message_queue
:
Queue
<
Option
<
T
>
>
parked_queue
:
Queue
<
Arc
<
Mutex
<
SenderTask
>
>
>
num_senders
:
AtomicUsize
recv_task
:
Mutex
<
ReceiverTask
>
}
#
[
derive
(
Debug
Clone
Copy
)
]
struct
State
{
is_open
:
bool
num_messages
:
usize
}
#
[
derive
(
Debug
)
]
struct
ReceiverTask
{
unparked
:
bool
task
:
Option
<
Task
>
}
enum
TryPark
{
Parked
Closed
NotEmpty
}
const
OPEN_MASK
:
usize
=
usize
:
:
MAX
-
(
usize
:
:
MAX
>
>
1
)
;
const
INIT_STATE
:
usize
=
OPEN_MASK
;
const
MAX_CAPACITY
:
usize
=
!
(
OPEN_MASK
)
;
const
MAX_BUFFER
:
usize
=
MAX_CAPACITY
>
>
1
;
#
[
derive
(
Debug
)
]
struct
SenderTask
{
task
:
Option
<
Task
>
is_parked
:
bool
}
impl
SenderTask
{
fn
new
(
)
-
>
Self
{
SenderTask
{
task
:
None
is_parked
:
false
}
}
fn
notify
(
&
mut
self
)
{
self
.
is_parked
=
false
;
if
let
Some
(
task
)
=
self
.
task
.
take
(
)
{
task
.
notify
(
)
;
}
}
}
pub
fn
channel
<
T
>
(
buffer
:
usize
)
-
>
(
Sender
<
T
>
Receiver
<
T
>
)
{
assert
!
(
buffer
<
MAX_BUFFER
"
requested
buffer
size
too
large
"
)
;
channel2
(
Some
(
buffer
)
)
}
pub
fn
unbounded
<
T
>
(
)
-
>
(
UnboundedSender
<
T
>
UnboundedReceiver
<
T
>
)
{
let
(
tx
rx
)
=
channel2
(
None
)
;
(
UnboundedSender
(
tx
)
UnboundedReceiver
(
rx
)
)
}
fn
channel2
<
T
>
(
buffer
:
Option
<
usize
>
)
-
>
(
Sender
<
T
>
Receiver
<
T
>
)
{
let
inner
=
Arc
:
:
new
(
Inner
{
buffer
:
buffer
state
:
AtomicUsize
:
:
new
(
INIT_STATE
)
message_queue
:
Queue
:
:
new
(
)
parked_queue
:
Queue
:
:
new
(
)
num_senders
:
AtomicUsize
:
:
new
(
1
)
recv_task
:
Mutex
:
:
new
(
ReceiverTask
{
unparked
:
false
task
:
None
}
)
}
)
;
let
tx
=
Sender
{
inner
:
inner
.
clone
(
)
sender_task
:
Arc
:
:
new
(
Mutex
:
:
new
(
SenderTask
:
:
new
(
)
)
)
maybe_parked
:
false
}
;
let
rx
=
Receiver
{
inner
:
inner
}
;
(
tx
rx
)
}
impl
<
T
>
Sender
<
T
>
{
pub
fn
try_send
(
&
mut
self
msg
:
T
)
-
>
Result
<
(
)
TrySendError
<
T
>
>
{
if
!
self
.
poll_unparked
(
false
)
.
is_ready
(
)
{
return
Err
(
TrySendError
{
kind
:
TrySendErrorKind
:
:
Full
(
msg
)
}
)
;
}
self
.
do_send
(
Some
(
msg
)
false
)
.
map_err
(
|
SendError
(
v
)
|
{
TrySendError
{
kind
:
TrySendErrorKind
:
:
Disconnected
(
v
)
}
}
)
}
fn
do_send
(
&
mut
self
msg
:
Option
<
T
>
do_park
:
bool
)
-
>
Result
<
(
)
SendError
<
T
>
>
{
let
park_self
=
match
self
.
inc_num_messages
(
msg
.
is_none
(
)
)
{
Some
(
park_self
)
=
>
park_self
None
=
>
{
if
let
Some
(
msg
)
=
msg
{
return
Err
(
SendError
(
msg
)
)
;
}
else
{
return
Ok
(
(
)
)
;
}
}
}
;
if
park_self
{
self
.
park
(
do_park
)
;
}
self
.
queue_push_and_signal
(
msg
)
;
Ok
(
(
)
)
}
fn
do_send_nb
(
&
self
msg
:
T
)
-
>
Result
<
(
)
SendError
<
T
>
>
{
match
self
.
inc_num_messages
(
false
)
{
Some
(
park_self
)
=
>
assert
!
(
!
park_self
)
None
=
>
return
Err
(
SendError
(
msg
)
)
}
;
self
.
queue_push_and_signal
(
Some
(
msg
)
)
;
Ok
(
(
)
)
}
fn
queue_push_and_signal
(
&
self
msg
:
Option
<
T
>
)
{
self
.
inner
.
message_queue
.
push
(
msg
)
;
self
.
signal
(
)
;
}
fn
inc_num_messages
(
&
self
close
:
bool
)
-
>
Option
<
bool
>
{
let
mut
curr
=
self
.
inner
.
state
.
load
(
SeqCst
)
;
loop
{
let
mut
state
=
decode_state
(
curr
)
;
if
!
state
.
is_open
{
return
None
;
}
assert
!
(
state
.
num_messages
<
MAX_CAPACITY
"
buffer
space
exhausted
;
\
sending
this
messages
would
overflow
the
state
"
)
;
state
.
num_messages
+
=
1
;
if
close
{
state
.
is_open
=
false
;
}
let
next
=
encode_state
(
&
state
)
;
match
self
.
inner
.
state
.
compare_exchange
(
curr
next
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
{
let
park_self
=
match
self
.
inner
.
buffer
{
Some
(
buffer
)
=
>
state
.
num_messages
>
buffer
None
=
>
false
}
;
return
Some
(
park_self
)
}
Err
(
actual
)
=
>
curr
=
actual
}
}
}
fn
signal
(
&
self
)
{
let
task
=
{
let
mut
recv_task
=
self
.
inner
.
recv_task
.
lock
(
)
.
unwrap
(
)
;
if
recv_task
.
unparked
{
return
;
}
recv_task
.
unparked
=
true
;
recv_task
.
task
.
take
(
)
}
;
if
let
Some
(
task
)
=
task
{
task
.
notify
(
)
;
}
}
fn
park
(
&
mut
self
can_park
:
bool
)
{
let
task
=
if
can_park
{
Some
(
task
:
:
current
(
)
)
}
else
{
None
}
;
{
let
mut
sender
=
self
.
sender_task
.
lock
(
)
.
unwrap
(
)
;
sender
.
task
=
task
;
sender
.
is_parked
=
true
;
}
let
t
=
self
.
sender_task
.
clone
(
)
;
self
.
inner
.
parked_queue
.
push
(
t
)
;
let
state
=
decode_state
(
self
.
inner
.
state
.
load
(
SeqCst
)
)
;
self
.
maybe_parked
=
state
.
is_open
;
}
pub
fn
poll_ready
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
(
)
>
>
{
let
state
=
decode_state
(
self
.
inner
.
state
.
load
(
SeqCst
)
)
;
if
!
state
.
is_open
{
return
Err
(
SendError
(
(
)
)
)
;
}
Ok
(
self
.
poll_unparked
(
true
)
)
}
pub
fn
is_closed
(
&
self
)
-
>
bool
{
!
decode_state
(
self
.
inner
.
state
.
load
(
SeqCst
)
)
.
is_open
}
fn
poll_unparked
(
&
mut
self
do_park
:
bool
)
-
>
Async
<
(
)
>
{
if
self
.
maybe_parked
{
let
mut
task
=
self
.
sender_task
.
lock
(
)
.
unwrap
(
)
;
if
!
task
.
is_parked
{
self
.
maybe_parked
=
false
;
return
Async
:
:
Ready
(
(
)
)
}
task
.
task
=
if
do_park
{
Some
(
task
:
:
current
(
)
)
}
else
{
None
}
;
Async
:
:
NotReady
}
else
{
Async
:
:
Ready
(
(
)
)
}
}
}
impl
<
T
>
Sink
for
Sender
<
T
>
{
type
SinkItem
=
T
;
type
SinkError
=
SendError
<
T
>
;
fn
start_send
(
&
mut
self
msg
:
T
)
-
>
StartSend
<
T
SendError
<
T
>
>
{
if
!
self
.
poll_unparked
(
true
)
.
is_ready
(
)
{
return
Ok
(
AsyncSink
:
:
NotReady
(
msg
)
)
;
}
self
.
do_send
(
Some
(
msg
)
true
)
?
;
Ok
(
AsyncSink
:
:
Ready
)
}
fn
poll_complete
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
T
>
>
{
self
.
poll_ready
(
)
.
or_else
(
|
_
|
Ok
(
(
)
.
into
(
)
)
)
}
fn
close
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
T
>
>
{
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
}
impl
<
T
>
UnboundedSender
<
T
>
{
pub
fn
is_closed
(
&
self
)
-
>
bool
{
self
.
0
.
is_closed
(
)
}
#
[
deprecated
(
note
=
"
renamed
to
unbounded_send
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
send
(
&
self
msg
:
T
)
-
>
Result
<
(
)
SendError
<
T
>
>
{
self
.
unbounded_send
(
msg
)
}
pub
fn
unbounded_send
(
&
self
msg
:
T
)
-
>
Result
<
(
)
SendError
<
T
>
>
{
self
.
0
.
do_send_nb
(
msg
)
}
}
impl
<
T
>
Sink
for
UnboundedSender
<
T
>
{
type
SinkItem
=
T
;
type
SinkError
=
SendError
<
T
>
;
fn
start_send
(
&
mut
self
msg
:
T
)
-
>
StartSend
<
T
SendError
<
T
>
>
{
self
.
0
.
start_send
(
msg
)
}
fn
poll_complete
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
T
>
>
{
self
.
0
.
poll_complete
(
)
}
fn
close
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
T
>
>
{
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
}
impl
<
'
a
T
>
Sink
for
&
'
a
UnboundedSender
<
T
>
{
type
SinkItem
=
T
;
type
SinkError
=
SendError
<
T
>
;
fn
start_send
(
&
mut
self
msg
:
T
)
-
>
StartSend
<
T
SendError
<
T
>
>
{
self
.
0
.
do_send_nb
(
msg
)
?
;
Ok
(
AsyncSink
:
:
Ready
)
}
fn
poll_complete
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
T
>
>
{
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
fn
close
(
&
mut
self
)
-
>
Poll
<
(
)
SendError
<
T
>
>
{
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
}
impl
<
T
>
Clone
for
UnboundedSender
<
T
>
{
fn
clone
(
&
self
)
-
>
UnboundedSender
<
T
>
{
UnboundedSender
(
self
.
0
.
clone
(
)
)
}
}
impl
<
T
>
Clone
for
Sender
<
T
>
{
fn
clone
(
&
self
)
-
>
Sender
<
T
>
{
let
mut
curr
=
self
.
inner
.
num_senders
.
load
(
SeqCst
)
;
loop
{
if
curr
=
=
self
.
inner
.
max_senders
(
)
{
panic
!
(
"
cannot
clone
Sender
-
-
too
many
outstanding
senders
"
)
;
}
debug_assert
!
(
curr
<
self
.
inner
.
max_senders
(
)
)
;
let
next
=
curr
+
1
;
let
actual
=
self
.
inner
.
num_senders
.
compare_and_swap
(
curr
next
SeqCst
)
;
if
actual
=
=
curr
{
return
Sender
{
inner
:
self
.
inner
.
clone
(
)
sender_task
:
Arc
:
:
new
(
Mutex
:
:
new
(
SenderTask
:
:
new
(
)
)
)
maybe_parked
:
false
}
;
}
curr
=
actual
;
}
}
}
impl
<
T
>
Drop
for
Sender
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
prev
=
self
.
inner
.
num_senders
.
fetch_sub
(
1
SeqCst
)
;
if
prev
=
=
1
{
let
_
=
self
.
do_send
(
None
false
)
;
}
}
}
impl
<
T
>
Receiver
<
T
>
{
pub
fn
close
(
&
mut
self
)
{
let
mut
curr
=
self
.
inner
.
state
.
load
(
SeqCst
)
;
loop
{
let
mut
state
=
decode_state
(
curr
)
;
if
!
state
.
is_open
{
break
}
state
.
is_open
=
false
;
let
next
=
encode_state
(
&
state
)
;
match
self
.
inner
.
state
.
compare_exchange
(
curr
next
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
break
Err
(
actual
)
=
>
curr
=
actual
}
}
loop
{
match
unsafe
{
self
.
inner
.
parked_queue
.
pop
(
)
}
{
PopResult
:
:
Data
(
task
)
=
>
{
task
.
lock
(
)
.
unwrap
(
)
.
notify
(
)
;
}
PopResult
:
:
Empty
=
>
break
PopResult
:
:
Inconsistent
=
>
thread
:
:
yield_now
(
)
}
}
}
fn
next_message
(
&
mut
self
)
-
>
Async
<
Option
<
T
>
>
{
loop
{
match
unsafe
{
self
.
inner
.
message_queue
.
pop
(
)
}
{
PopResult
:
:
Data
(
msg
)
=
>
{
self
.
unpark_one
(
)
;
self
.
dec_num_messages
(
)
;
return
Async
:
:
Ready
(
msg
)
;
}
PopResult
:
:
Empty
=
>
{
return
Async
:
:
NotReady
;
}
PopResult
:
:
Inconsistent
=
>
{
thread
:
:
yield_now
(
)
;
}
}
}
}
fn
unpark_one
(
&
mut
self
)
{
loop
{
match
unsafe
{
self
.
inner
.
parked_queue
.
pop
(
)
}
{
PopResult
:
:
Data
(
task
)
=
>
{
task
.
lock
(
)
.
unwrap
(
)
.
notify
(
)
;
return
;
}
PopResult
:
:
Empty
=
>
{
return
;
}
PopResult
:
:
Inconsistent
=
>
{
thread
:
:
yield_now
(
)
;
}
}
}
}
fn
try_park
(
&
self
)
-
>
TryPark
{
let
curr
=
self
.
inner
.
state
.
load
(
SeqCst
)
;
let
state
=
decode_state
(
curr
)
;
if
state
.
is_closed
(
)
{
return
TryPark
:
:
Closed
;
}
let
mut
recv_task
=
self
.
inner
.
recv_task
.
lock
(
)
.
unwrap
(
)
;
if
recv_task
.
unparked
{
recv_task
.
unparked
=
false
;
return
TryPark
:
:
NotEmpty
;
}
recv_task
.
task
=
Some
(
task
:
:
current
(
)
)
;
TryPark
:
:
Parked
}
fn
dec_num_messages
(
&
self
)
{
let
mut
curr
=
self
.
inner
.
state
.
load
(
SeqCst
)
;
loop
{
let
mut
state
=
decode_state
(
curr
)
;
state
.
num_messages
-
=
1
;
let
next
=
encode_state
(
&
state
)
;
match
self
.
inner
.
state
.
compare_exchange
(
curr
next
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
break
Err
(
actual
)
=
>
curr
=
actual
}
}
}
}
impl
<
T
>
Stream
for
Receiver
<
T
>
{
type
Item
=
T
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
T
>
(
)
>
{
loop
{
match
self
.
next_message
(
)
{
Async
:
:
Ready
(
msg
)
=
>
return
Ok
(
Async
:
:
Ready
(
msg
)
)
Async
:
:
NotReady
=
>
{
match
self
.
try_park
(
)
{
TryPark
:
:
Parked
=
>
{
return
Ok
(
Async
:
:
NotReady
)
;
}
TryPark
:
:
Closed
=
>
{
return
Ok
(
Async
:
:
Ready
(
None
)
)
;
}
TryPark
:
:
NotEmpty
=
>
{
continue
;
}
}
}
}
}
}
}
impl
<
T
>
Drop
for
Receiver
<
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
close
(
)
;
loop
{
match
self
.
next_message
(
)
{
Async
:
:
Ready
(
_
)
=
>
{
}
Async
:
:
NotReady
=
>
{
let
curr
=
self
.
inner
.
state
.
load
(
SeqCst
)
;
let
state
=
decode_state
(
curr
)
;
if
state
.
is_closed
(
)
{
return
;
}
thread
:
:
yield_now
(
)
;
}
}
}
}
}
impl
<
T
>
UnboundedReceiver
<
T
>
{
pub
fn
close
(
&
mut
self
)
{
self
.
0
.
close
(
)
;
}
}
impl
<
T
>
Stream
for
UnboundedReceiver
<
T
>
{
type
Item
=
T
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
T
>
(
)
>
{
self
.
0
.
poll
(
)
}
}
pub
struct
SpawnHandle
<
Item
Error
>
{
rx
:
Receiver
<
Result
<
Item
Error
>
>
_cancel_tx
:
oneshot
:
:
Sender
<
(
)
>
}
pub
struct
Execute
<
S
:
Stream
>
{
inner
:
SendAll
<
Sender
<
Result
<
S
:
:
Item
S
:
:
Error
>
>
Results
<
S
SendError
<
Result
<
S
:
:
Item
S
:
:
Error
>
>
>
>
cancel_rx
:
oneshot
:
:
Receiver
<
(
)
>
}
pub
fn
spawn
<
S
E
>
(
stream
:
S
executor
:
&
E
buffer
:
usize
)
-
>
SpawnHandle
<
S
:
:
Item
S
:
:
Error
>
where
S
:
Stream
E
:
Executor
<
Execute
<
S
>
>
{
let
(
cancel_tx
cancel_rx
)
=
oneshot
:
:
channel
(
)
;
let
(
tx
rx
)
=
channel
(
buffer
)
;
executor
.
execute
(
Execute
{
inner
:
tx
.
send_all
(
resultstream
:
:
new
(
stream
)
)
cancel_rx
:
cancel_rx
}
)
.
expect
(
"
failed
to
spawn
stream
"
)
;
SpawnHandle
{
rx
:
rx
_cancel_tx
:
cancel_tx
}
}
pub
fn
spawn_unbounded
<
S
E
>
(
stream
:
S
executor
:
&
E
)
-
>
SpawnHandle
<
S
:
:
Item
S
:
:
Error
>
where
S
:
Stream
E
:
Executor
<
Execute
<
S
>
>
{
let
(
cancel_tx
cancel_rx
)
=
oneshot
:
:
channel
(
)
;
let
(
tx
rx
)
=
channel2
(
None
)
;
executor
.
execute
(
Execute
{
inner
:
tx
.
send_all
(
resultstream
:
:
new
(
stream
)
)
cancel_rx
:
cancel_rx
}
)
.
expect
(
"
failed
to
spawn
stream
"
)
;
SpawnHandle
{
rx
:
rx
_cancel_tx
:
cancel_tx
}
}
impl
<
I
E
>
Stream
for
SpawnHandle
<
I
E
>
{
type
Item
=
I
;
type
Error
=
E
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
I
>
E
>
{
match
self
.
rx
.
poll
(
)
{
Ok
(
Async
:
:
Ready
(
Some
(
Ok
(
t
)
)
)
)
=
>
Ok
(
Async
:
:
Ready
(
Some
(
t
.
into
(
)
)
)
)
Ok
(
Async
:
:
Ready
(
Some
(
Err
(
e
)
)
)
)
=
>
Err
(
e
)
Ok
(
Async
:
:
Ready
(
None
)
)
=
>
Ok
(
Async
:
:
Ready
(
None
)
)
Ok
(
Async
:
:
NotReady
)
=
>
Ok
(
Async
:
:
NotReady
)
Err
(
_
)
=
>
unreachable
!
(
"
mpsc
:
:
Receiver
should
never
return
Err
"
)
}
}
}
impl
<
I
E
>
fmt
:
:
Debug
for
SpawnHandle
<
I
E
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
SpawnHandle
"
)
.
finish
(
)
}
}
impl
<
S
:
Stream
>
Future
for
Execute
<
S
>
{
type
Item
=
(
)
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
)
(
)
>
{
match
self
.
cancel_rx
.
poll
(
)
{
Ok
(
Async
:
:
NotReady
)
=
>
(
)
_
=
>
return
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
match
self
.
inner
.
poll
(
)
{
Ok
(
Async
:
:
NotReady
)
=
>
Ok
(
Async
:
:
NotReady
)
_
=
>
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
}
}
impl
<
S
:
Stream
>
fmt
:
:
Debug
for
Execute
<
S
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Execute
"
)
.
finish
(
)
}
}
impl
<
T
>
Inner
<
T
>
{
fn
max_senders
(
&
self
)
-
>
usize
{
match
self
.
buffer
{
Some
(
buffer
)
=
>
MAX_CAPACITY
-
buffer
None
=
>
MAX_BUFFER
}
}
}
unsafe
impl
<
T
:
Send
>
Send
for
Inner
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Inner
<
T
>
{
}
impl
State
{
fn
is_closed
(
&
self
)
-
>
bool
{
!
self
.
is_open
&
&
self
.
num_messages
=
=
0
}
}
fn
decode_state
(
num
:
usize
)
-
>
State
{
State
{
is_open
:
num
&
OPEN_MASK
=
=
OPEN_MASK
num_messages
:
num
&
MAX_CAPACITY
}
}
fn
encode_state
(
state
:
&
State
)
-
>
usize
{
let
mut
num
=
state
.
num_messages
;
if
state
.
is_open
{
num
|
=
OPEN_MASK
;
}
num
}
