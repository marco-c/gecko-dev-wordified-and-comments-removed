use
{
IntoFuture
Poll
}
;
mod
iter
;
#
[
allow
(
deprecated
)
]
pub
use
self
:
:
iter
:
:
{
iter
Iter
}
;
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
allow
(
deprecated
)
]
pub
use
self
:
:
Iter
as
IterStream
;
mod
iter_ok
;
pub
use
self
:
:
iter_ok
:
:
{
iter_ok
IterOk
}
;
mod
iter_result
;
pub
use
self
:
:
iter_result
:
:
{
iter_result
IterResult
}
;
mod
repeat
;
pub
use
self
:
:
repeat
:
:
{
repeat
Repeat
}
;
mod
and_then
;
mod
chain
;
mod
concat
;
mod
empty
;
mod
filter
;
mod
filter_map
;
mod
flatten
;
mod
fold
;
mod
for_each
;
mod
from_err
;
mod
fuse
;
mod
future
;
mod
inspect
;
mod
inspect_err
;
mod
map
;
mod
map_err
;
mod
merge
;
mod
once
;
mod
or_else
;
mod
peek
;
mod
poll_fn
;
mod
select
;
mod
skip
;
mod
skip_while
;
mod
take
;
mod
take_while
;
mod
then
;
mod
unfold
;
mod
zip
;
mod
forward
;
pub
use
self
:
:
and_then
:
:
AndThen
;
pub
use
self
:
:
chain
:
:
Chain
;
#
[
allow
(
deprecated
)
]
pub
use
self
:
:
concat
:
:
Concat
;
pub
use
self
:
:
concat
:
:
Concat2
;
pub
use
self
:
:
empty
:
:
{
Empty
empty
}
;
pub
use
self
:
:
filter
:
:
Filter
;
pub
use
self
:
:
filter_map
:
:
FilterMap
;
pub
use
self
:
:
flatten
:
:
Flatten
;
pub
use
self
:
:
fold
:
:
Fold
;
pub
use
self
:
:
for_each
:
:
ForEach
;
pub
use
self
:
:
from_err
:
:
FromErr
;
pub
use
self
:
:
fuse
:
:
Fuse
;
pub
use
self
:
:
future
:
:
StreamFuture
;
pub
use
self
:
:
inspect
:
:
Inspect
;
pub
use
self
:
:
inspect_err
:
:
InspectErr
;
pub
use
self
:
:
map
:
:
Map
;
pub
use
self
:
:
map_err
:
:
MapErr
;
#
[
allow
(
deprecated
)
]
pub
use
self
:
:
merge
:
:
{
Merge
MergedItem
}
;
pub
use
self
:
:
once
:
:
{
Once
once
}
;
pub
use
self
:
:
or_else
:
:
OrElse
;
pub
use
self
:
:
peek
:
:
Peekable
;
pub
use
self
:
:
poll_fn
:
:
{
poll_fn
PollFn
}
;
pub
use
self
:
:
select
:
:
Select
;
pub
use
self
:
:
skip
:
:
Skip
;
pub
use
self
:
:
skip_while
:
:
SkipWhile
;
pub
use
self
:
:
take
:
:
Take
;
pub
use
self
:
:
take_while
:
:
TakeWhile
;
pub
use
self
:
:
then
:
:
Then
;
pub
use
self
:
:
unfold
:
:
{
Unfold
unfold
}
;
pub
use
self
:
:
zip
:
:
Zip
;
pub
use
self
:
:
forward
:
:
Forward
;
use
sink
:
:
{
Sink
}
;
if_std
!
{
use
std
;
mod
buffered
;
mod
buffer_unordered
;
mod
catch_unwind
;
mod
chunks
;
mod
collect
;
mod
wait
;
mod
channel
;
mod
split
;
pub
mod
futures_unordered
;
mod
futures_ordered
;
pub
use
self
:
:
buffered
:
:
Buffered
;
pub
use
self
:
:
buffer_unordered
:
:
BufferUnordered
;
pub
use
self
:
:
catch_unwind
:
:
CatchUnwind
;
pub
use
self
:
:
chunks
:
:
Chunks
;
pub
use
self
:
:
collect
:
:
Collect
;
pub
use
self
:
:
wait
:
:
Wait
;
pub
use
self
:
:
split
:
:
{
SplitStream
SplitSink
ReuniteError
}
;
pub
use
self
:
:
futures_unordered
:
:
FuturesUnordered
;
pub
use
self
:
:
futures_ordered
:
:
{
futures_ordered
FuturesOrdered
}
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
with
-
deprecated
"
)
]
#
[
allow
(
deprecated
)
]
pub
use
self
:
:
channel
:
:
{
channel
Sender
Receiver
FutureSender
SendError
}
;
/
/
/
A
type
alias
for
Box
<
Stream
+
Send
>
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
removed
without
replacement
recommended
to
use
a
\
local
extension
trait
or
function
if
needed
more
\
details
in
https
:
/
/
github
.
com
/
rust
-
lang
-
nursery
/
futures
-
rs
/
issues
/
228
"
)
]
pub
type
BoxStream
<
T
E
>
=
:
:
std
:
:
boxed
:
:
Box
<
Stream
<
Item
=
T
Error
=
E
>
+
Send
>
;
impl
<
S
:
?
Sized
+
Stream
>
Stream
for
:
:
std
:
:
boxed
:
:
Box
<
S
>
{
type
Item
=
S
:
:
Item
;
type
Error
=
S
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
(
*
*
self
)
.
poll
(
)
}
}
}
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
pub
trait
Stream
{
type
Item
;
type
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
wait
(
self
)
-
>
Wait
<
Self
>
where
Self
:
Sized
{
wait
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
removed
without
replacement
recommended
to
use
a
\
local
extension
trait
or
function
if
needed
more
\
details
in
https
:
/
/
github
.
com
/
rust
-
lang
-
nursery
/
futures
-
rs
/
issues
/
228
"
)
]
#
[
allow
(
deprecated
)
]
fn
boxed
(
self
)
-
>
BoxStream
<
Self
:
:
Item
Self
:
:
Error
>
where
Self
:
Sized
+
Send
+
'
static
{
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
self
)
}
fn
into_future
(
self
)
-
>
StreamFuture
<
Self
>
where
Self
:
Sized
{
future
:
:
new
(
self
)
}
fn
map
<
U
F
>
(
self
f
:
F
)
-
>
Map
<
Self
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
U
Self
:
Sized
{
map
:
:
new
(
self
f
)
}
fn
map_err
<
U
F
>
(
self
f
:
F
)
-
>
MapErr
<
Self
F
>
where
F
:
FnMut
(
Self
:
:
Error
)
-
>
U
Self
:
Sized
{
map_err
:
:
new
(
self
f
)
}
fn
filter
<
F
>
(
self
f
:
F
)
-
>
Filter
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
bool
Self
:
Sized
{
filter
:
:
new
(
self
f
)
}
fn
filter_map
<
F
B
>
(
self
f
:
F
)
-
>
FilterMap
<
Self
F
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
Option
<
B
>
Self
:
Sized
{
filter_map
:
:
new
(
self
f
)
}
fn
then
<
F
U
>
(
self
f
:
F
)
-
>
Then
<
Self
F
U
>
where
F
:
FnMut
(
Result
<
Self
:
:
Item
Self
:
:
Error
>
)
-
>
U
U
:
IntoFuture
Self
:
Sized
{
then
:
:
new
(
self
f
)
}
fn
and_then
<
F
U
>
(
self
f
:
F
)
-
>
AndThen
<
Self
F
U
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
U
U
:
IntoFuture
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
and_then
:
:
new
(
self
f
)
}
fn
or_else
<
F
U
>
(
self
f
:
F
)
-
>
OrElse
<
Self
F
U
>
where
F
:
FnMut
(
Self
:
:
Error
)
-
>
U
U
:
IntoFuture
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
or_else
:
:
new
(
self
f
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
collect
(
self
)
-
>
Collect
<
Self
>
where
Self
:
Sized
{
collect
:
:
new
(
self
)
}
fn
concat2
(
self
)
-
>
Concat2
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Extend
<
<
<
Self
as
Stream
>
:
:
Item
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
+
Default
{
concat
:
:
new2
(
self
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
14
"
note
=
"
please
use
Stream
:
:
concat2
instead
"
)
]
#
[
allow
(
deprecated
)
]
fn
concat
(
self
)
-
>
Concat
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Extend
<
<
<
Self
as
Stream
>
:
:
Item
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
{
concat
:
:
new
(
self
)
}
fn
fold
<
F
T
Fut
>
(
self
init
:
T
f
:
F
)
-
>
Fold
<
Self
F
Fut
T
>
where
F
:
FnMut
(
T
Self
:
:
Item
)
-
>
Fut
Fut
:
IntoFuture
<
Item
=
T
>
Self
:
:
Error
:
From
<
Fut
:
:
Error
>
Self
:
Sized
{
fold
:
:
new
(
self
f
init
)
}
fn
flatten
(
self
)
-
>
Flatten
<
Self
>
where
Self
:
:
Item
:
Stream
<
Self
:
:
Item
as
Stream
>
:
:
Error
:
From
<
Self
:
:
Error
>
Self
:
Sized
{
flatten
:
:
new
(
self
)
}
fn
skip_while
<
P
R
>
(
self
pred
:
P
)
-
>
SkipWhile
<
Self
P
R
>
where
P
:
FnMut
(
&
Self
:
:
Item
)
-
>
R
R
:
IntoFuture
<
Item
=
bool
Error
=
Self
:
:
Error
>
Self
:
Sized
{
skip_while
:
:
new
(
self
pred
)
}
fn
take_while
<
P
R
>
(
self
pred
:
P
)
-
>
TakeWhile
<
Self
P
R
>
where
P
:
FnMut
(
&
Self
:
:
Item
)
-
>
R
R
:
IntoFuture
<
Item
=
bool
Error
=
Self
:
:
Error
>
Self
:
Sized
{
take_while
:
:
new
(
self
pred
)
}
fn
for_each
<
F
U
>
(
self
f
:
F
)
-
>
ForEach
<
Self
F
U
>
where
F
:
FnMut
(
Self
:
:
Item
)
-
>
U
U
:
IntoFuture
<
Item
=
(
)
Error
=
Self
:
:
Error
>
Self
:
Sized
{
for_each
:
:
new
(
self
f
)
}
fn
from_err
<
E
:
From
<
Self
:
:
Error
>
>
(
self
)
-
>
FromErr
<
Self
E
>
where
Self
:
Sized
{
from_err
:
:
new
(
self
)
}
fn
take
(
self
amt
:
u64
)
-
>
Take
<
Self
>
where
Self
:
Sized
{
take
:
:
new
(
self
amt
)
}
fn
skip
(
self
amt
:
u64
)
-
>
Skip
<
Self
>
where
Self
:
Sized
{
skip
:
:
new
(
self
amt
)
}
fn
fuse
(
self
)
-
>
Fuse
<
Self
>
where
Self
:
Sized
{
fuse
:
:
new
(
self
)
}
fn
by_ref
(
&
mut
self
)
-
>
&
mut
Self
where
Self
:
Sized
{
self
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
catch_unwind
(
self
)
-
>
CatchUnwind
<
Self
>
where
Self
:
Sized
+
std
:
:
panic
:
:
UnwindSafe
{
catch_unwind
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
buffered
(
self
amt
:
usize
)
-
>
Buffered
<
Self
>
where
Self
:
:
Item
:
IntoFuture
<
Error
=
<
Self
as
Stream
>
:
:
Error
>
Self
:
Sized
{
buffered
:
:
new
(
self
amt
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
buffer_unordered
(
self
amt
:
usize
)
-
>
BufferUnordered
<
Self
>
where
Self
:
:
Item
:
IntoFuture
<
Error
=
<
Self
as
Stream
>
:
:
Error
>
Self
:
Sized
{
buffer_unordered
:
:
new
(
self
amt
)
}
#
[
deprecated
(
note
=
"
functionality
provided
by
select
now
"
)
]
#
[
allow
(
deprecated
)
]
fn
merge
<
S
>
(
self
other
:
S
)
-
>
Merge
<
Self
S
>
where
S
:
Stream
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
merge
:
:
new
(
self
other
)
}
fn
zip
<
S
>
(
self
other
:
S
)
-
>
Zip
<
Self
S
>
where
S
:
Stream
<
Error
=
Self
:
:
Error
>
Self
:
Sized
{
zip
:
:
new
(
self
other
)
}
fn
chain
<
S
>
(
self
other
:
S
)
-
>
Chain
<
Self
S
>
where
S
:
Stream
<
Item
=
Self
:
:
Item
Error
=
Self
:
:
Error
>
Self
:
Sized
{
chain
:
:
new
(
self
other
)
}
fn
peekable
(
self
)
-
>
Peekable
<
Self
>
where
Self
:
Sized
{
peek
:
:
new
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
chunks
(
self
capacity
:
usize
)
-
>
Chunks
<
Self
>
where
Self
:
Sized
{
chunks
:
:
new
(
self
capacity
)
}
fn
select
<
S
>
(
self
other
:
S
)
-
>
Select
<
Self
S
>
where
S
:
Stream
<
Item
=
Self
:
:
Item
Error
=
Self
:
:
Error
>
Self
:
Sized
{
select
:
:
new
(
self
other
)
}
fn
forward
<
S
>
(
self
sink
:
S
)
-
>
Forward
<
Self
S
>
where
S
:
Sink
<
SinkItem
=
Self
:
:
Item
>
Self
:
:
Error
:
From
<
S
:
:
SinkError
>
Self
:
Sized
{
forward
:
:
new
(
self
sink
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
split
(
self
)
-
>
(
SplitSink
<
Self
>
SplitStream
<
Self
>
)
where
Self
:
super
:
:
sink
:
:
Sink
+
Sized
{
split
:
:
split
(
self
)
}
fn
inspect
<
F
>
(
self
f
:
F
)
-
>
Inspect
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Item
)
Self
:
Sized
{
inspect
:
:
new
(
self
f
)
}
fn
inspect_err
<
F
>
(
self
f
:
F
)
-
>
InspectErr
<
Self
F
>
where
F
:
FnMut
(
&
Self
:
:
Error
)
Self
:
Sized
{
inspect_err
:
:
new
(
self
f
)
}
}
impl
<
'
a
S
:
?
Sized
+
Stream
>
Stream
for
&
'
a
mut
S
{
type
Item
=
S
:
:
Item
;
type
Error
=
S
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
(
*
*
self
)
.
poll
(
)
}
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
fn
futures_unordered
<
I
>
(
futures
:
I
)
-
>
FuturesUnordered
<
<
I
:
:
Item
as
IntoFuture
>
:
:
Future
>
where
I
:
IntoIterator
I
:
:
Item
:
IntoFuture
{
let
mut
set
=
FuturesUnordered
:
:
new
(
)
;
for
future
in
futures
{
set
.
push
(
future
.
into_future
(
)
)
;
}
return
set
}
