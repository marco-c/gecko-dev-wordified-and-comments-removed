#
!
[
feature
(
test
)
]
#
[
macro_use
]
extern
crate
futures
;
extern
crate
test
;
use
futures
:
:
{
Async
Poll
AsyncSink
}
;
use
futures
:
:
executor
;
use
futures
:
:
executor
:
:
{
Notify
NotifyHandle
}
;
use
futures
:
:
sink
:
:
Sink
;
use
futures
:
:
stream
:
:
Stream
;
use
futures
:
:
sync
:
:
mpsc
:
:
unbounded
;
use
futures
:
:
sync
:
:
mpsc
:
:
channel
;
use
futures
:
:
sync
:
:
mpsc
:
:
Sender
;
use
futures
:
:
sync
:
:
mpsc
:
:
UnboundedSender
;
use
test
:
:
Bencher
;
fn
notify_noop
(
)
-
>
NotifyHandle
{
struct
Noop
;
impl
Notify
for
Noop
{
fn
notify
(
&
self
_id
:
usize
)
{
}
}
const
NOOP
:
&
'
static
Noop
=
&
Noop
;
NotifyHandle
:
:
from
(
NOOP
)
}
#
[
bench
]
fn
unbounded_1_tx
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
{
let
(
tx
rx
)
=
unbounded
(
)
;
let
mut
rx
=
executor
:
:
spawn
(
rx
)
;
for
i
in
0
.
.
1000
{
assert_eq
!
(
Ok
(
Async
:
:
NotReady
)
rx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
UnboundedSender
:
:
unbounded_send
(
&
tx
i
)
.
unwrap
(
)
;
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
)
)
)
rx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
}
}
)
}
#
[
bench
]
fn
unbounded_100_tx
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
{
let
(
tx
rx
)
=
unbounded
(
)
;
let
mut
rx
=
executor
:
:
spawn
(
rx
)
;
let
tx
:
Vec
<
_
>
=
(
0
.
.
100
)
.
map
(
|
_
|
tx
.
clone
(
)
)
.
collect
(
)
;
for
_
in
0
.
.
10
{
for
i
in
0
.
.
tx
.
len
(
)
{
assert_eq
!
(
Ok
(
Async
:
:
NotReady
)
rx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
UnboundedSender
:
:
unbounded_send
(
&
tx
[
i
]
i
)
.
unwrap
(
)
;
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
)
)
)
rx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
}
}
}
)
}
#
[
bench
]
fn
unbounded_uncontended
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
{
let
(
tx
mut
rx
)
=
unbounded
(
)
;
for
i
in
0
.
.
1000
{
UnboundedSender
:
:
unbounded_send
(
&
tx
i
)
.
expect
(
"
send
"
)
;
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
)
)
)
rx
.
poll
(
)
)
;
}
}
)
}
struct
TestSender
{
tx
:
Sender
<
u32
>
last
:
u32
}
impl
Stream
for
TestSender
{
type
Item
=
u32
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
match
self
.
tx
.
start_send
(
self
.
last
+
1
)
{
Err
(
_
)
=
>
panic
!
(
)
Ok
(
AsyncSink
:
:
Ready
)
=
>
{
self
.
last
+
=
1
;
Ok
(
Async
:
:
Ready
(
Some
(
self
.
last
)
)
)
}
Ok
(
AsyncSink
:
:
NotReady
(
_
)
)
=
>
{
Ok
(
Async
:
:
NotReady
)
}
}
}
}
#
[
bench
]
fn
bounded_1_tx
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
{
let
(
tx
rx
)
=
channel
(
0
)
;
let
mut
tx
=
executor
:
:
spawn
(
TestSender
{
tx
:
tx
last
:
0
}
)
;
let
mut
rx
=
executor
:
:
spawn
(
rx
)
;
for
i
in
0
.
.
1000
{
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
+
1
)
)
)
tx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
assert_eq
!
(
Ok
(
Async
:
:
NotReady
)
tx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
+
1
)
)
)
rx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
}
}
)
}
#
[
bench
]
fn
bounded_100_tx
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
{
let
(
tx
rx
)
=
channel
(
0
)
;
let
mut
tx
:
Vec
<
_
>
=
(
0
.
.
100
)
.
map
(
|
_
|
{
executor
:
:
spawn
(
TestSender
{
tx
:
tx
.
clone
(
)
last
:
0
}
)
}
)
.
collect
(
)
;
let
mut
rx
=
executor
:
:
spawn
(
rx
)
;
for
i
in
0
.
.
10
{
for
j
in
0
.
.
tx
.
len
(
)
{
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
+
1
)
)
)
tx
[
j
]
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
assert_eq
!
(
Ok
(
Async
:
:
NotReady
)
tx
[
j
]
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
assert_eq
!
(
Ok
(
Async
:
:
Ready
(
Some
(
i
+
1
)
)
)
rx
.
poll_stream_notify
(
&
notify_noop
(
)
1
)
)
;
}
}
}
)
}
