use
core
:
:
{
mem
:
:
MaybeUninit
ops
:
:
{
RangeBounds
Bound
}
}
;
use
crate
:
:
guards
:
:
SliceMemoryGuard
;
pub
struct
UninitializedSliceMemoryGuard
<
'
a
T
>
{
memory
:
&
'
a
mut
[
MaybeUninit
<
T
>
]
}
impl
<
'
a
T
>
UninitializedSliceMemoryGuard
<
'
a
T
>
{
#
[
inline
]
pub
unsafe
fn
new
(
memory
:
&
'
a
mut
[
MaybeUninit
<
T
>
]
)
-
>
Self
{
Self
{
memory
}
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
memory
.
len
(
)
}
#
[
inline
]
pub
fn
slice
(
self
range
:
impl
RangeBounds
<
usize
>
)
-
>
Self
{
let
start
=
match
range
.
start_bound
(
)
{
Bound
:
:
Excluded
(
n
)
=
>
n
.
saturating_add
(
1
)
Bound
:
:
Included
(
n
)
=
>
*
n
Bound
:
:
Unbounded
=
>
0
}
;
let
end
=
match
range
.
end_bound
(
)
{
Bound
:
:
Excluded
(
n
)
=
>
*
n
Bound
:
:
Included
(
n
)
=
>
n
.
saturating_add
(
1
)
Bound
:
:
Unbounded
=
>
self
.
memory
.
len
(
)
}
;
Self
{
memory
:
&
mut
self
.
memory
[
start
.
.
end
]
}
}
#
[
inline
]
pub
fn
init
(
self
init
:
impl
FnMut
(
usize
)
-
>
T
)
-
>
SliceMemoryGuard
<
'
a
T
>
{
unsafe
{
SliceMemoryGuard
:
:
new
(
self
.
memory
init
)
}
}
#
[
inline
]
pub
fn
init_copy_of
(
self
source
:
&
[
T
]
)
-
>
SliceMemoryGuard
<
'
a
T
>
where
T
:
Clone
{
self
.
slice
(
.
.
source
.
len
(
)
)
.
init
(
|
index
|
{
source
[
index
]
.
clone
(
)
}
)
}
#
[
inline
]
pub
fn
init_with_iter
(
self
mut
iter
:
impl
ExactSizeIterator
<
Item
=
T
>
)
-
>
SliceMemoryGuard
<
'
a
T
>
{
self
.
slice
(
.
.
iter
.
len
(
)
)
.
init
(
|
_index
|
{
iter
.
next
(
)
.
unwrap
(
)
}
)
}
#
[
inline
]
pub
fn
borrow
(
&
mut
self
)
-
>
UninitializedSliceMemoryGuard
<
T
>
{
unsafe
{
UninitializedSliceMemoryGuard
:
:
new
(
self
.
memory
)
}
}
}
