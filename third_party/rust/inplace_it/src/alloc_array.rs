use
crate
:
:
guards
:
:
UninitializedSliceMemoryGuard
;
use
std
:
:
mem
:
:
MaybeUninit
;
use
crate
:
:
try_inplace_array
;
pub
fn
alloc_array
<
T
R
Consumer
:
FnOnce
(
UninitializedSliceMemoryGuard
<
T
>
)
-
>
R
>
(
size
:
usize
consumer
:
Consumer
)
-
>
R
{
unsafe
{
let
mut
memory_holder
=
Vec
:
:
<
MaybeUninit
<
T
>
>
:
:
with_capacity
(
size
)
;
memory_holder
.
set_len
(
size
)
;
let
result
=
consumer
(
UninitializedSliceMemoryGuard
:
:
new
(
&
mut
*
memory_holder
)
)
;
memory_holder
.
set_len
(
0
)
;
result
}
}
pub
fn
inplace_or_alloc_array
<
T
R
Consumer
>
(
size
:
usize
consumer
:
Consumer
)
-
>
R
where
Consumer
:
FnOnce
(
UninitializedSliceMemoryGuard
<
T
>
)
-
>
R
{
match
try_inplace_array
(
size
consumer
)
{
Ok
(
result
)
=
>
result
Err
(
consumer
)
=
>
alloc_array
(
size
consumer
)
}
}
pub
fn
inplace_or_alloc_from_iter
<
Iter
R
Consumer
>
(
iter
:
Iter
consumer
:
Consumer
)
-
>
R
where
Iter
:
Iterator
Consumer
:
FnOnce
(
&
mut
[
Iter
:
:
Item
]
)
-
>
R
{
match
iter
.
size_hint
(
)
.
1
{
Some
(
upper_bound_hint
)
=
>
{
inplace_or_alloc_array
(
upper_bound_hint
|
uninitialized_guard
|
{
match
uninitialized_guard
.
init_with_dyn_iter
(
iter
)
{
Ok
(
mut
guard
)
=
>
consumer
(
&
mut
*
guard
)
Err
(
mut
vec
)
=
>
consumer
(
&
mut
*
vec
)
}
}
)
}
None
=
>
{
let
mut
vec
=
iter
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
consumer
(
&
mut
*
vec
)
}
}
}
