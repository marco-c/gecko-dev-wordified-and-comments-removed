#
!
[
deny
(
missing_debug_implementations
missing_docs
unused
)
]
#
[
macro_use
]
extern
crate
bitflags
;
#
[
cfg
(
feature
=
"
serde
"
)
]
#
[
macro_use
]
extern
crate
serde
;
use
std
:
:
any
:
:
Any
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
Hash
;
pub
mod
adapter
;
pub
mod
buffer
;
pub
mod
command
;
pub
mod
device
;
pub
mod
format
;
pub
mod
image
;
pub
mod
memory
;
pub
mod
pass
;
pub
mod
pool
;
pub
mod
pso
;
pub
mod
query
;
pub
mod
queue
;
pub
mod
window
;
pub
mod
prelude
{
pub
use
crate
:
:
{
adapter
:
:
PhysicalDevice
as
_
command
:
:
CommandBuffer
as
_
device
:
:
Device
as
_
pool
:
:
CommandPool
as
_
pso
:
:
DescriptorPool
as
_
queue
:
:
{
CommandQueue
as
_
QueueFamily
as
_
}
window
:
:
{
PresentationSurface
as
_
Surface
as
_
Swapchain
as
_
}
Instance
as
_
}
;
}
pub
type
VertexCount
=
u32
;
pub
type
VertexOffset
=
i32
;
pub
type
IndexCount
=
u32
;
pub
type
InstanceCount
=
u32
;
pub
type
DrawCount
=
u32
;
pub
type
WorkGroupCount
=
[
u32
;
3
]
;
bitflags
!
{
/
/
TODO
:
add
a
feature
for
non
-
normalized
samplers
/
/
TODO
:
add
a
feature
for
mutable
comparison
samplers
/
/
/
Features
that
the
device
supports
.
/
/
/
These
only
include
features
of
the
core
interface
and
not
API
extensions
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Features
:
u128
{
/
/
/
Bit
mask
of
Vulkan
Core
/
Extension
features
.
const
CORE_MASK
=
0xFFFF_FFFF_FFFF_FFFF
;
/
/
/
Bit
mask
of
Vulkan
Portability
features
.
const
PORTABILITY_MASK
=
0x0000_FFFF_0000_0000_0000_0000
;
/
/
/
Bit
mask
for
extra
WebGPU
features
.
const
WEBGPU_MASK
=
0xFFFF_0000_0000_0000_0000_0000
;
/
/
/
Support
for
robust
buffer
access
.
/
/
/
Buffer
access
by
SPIR
-
V
shaders
is
checked
against
the
buffer
/
image
boundaries
.
const
ROBUST_BUFFER_ACCESS
=
0x0000_0000_0000_0001
;
/
/
/
Support
the
full
32
-
bit
range
of
indexed
for
draw
calls
.
/
/
/
If
not
supported
the
maximum
index
value
is
determined
by
Limits
:
:
max_draw_index_value
.
const
FULL_DRAW_INDEX_U32
=
0x0000_0000_0000_0002
;
/
/
/
Support
cube
array
image
views
.
const
IMAGE_CUBE_ARRAY
=
0x0000_0000_0000_0004
;
/
/
/
Support
different
color
blending
settings
per
attachments
on
graphics
pipeline
creation
.
const
INDEPENDENT_BLENDING
=
0x0000_0000_0000_0008
;
/
/
/
Support
geometry
shader
.
const
GEOMETRY_SHADER
=
0x0000_0000_0000_0010
;
/
/
/
Support
tessellation
shaders
.
const
TESSELLATION_SHADER
=
0x0000_0000_0000_0020
;
/
/
/
Support
per
-
sample
shading
and
multisample
interpolation
.
const
SAMPLE_RATE_SHADING
=
0x0000_0000_0000_0040
;
/
/
/
Support
dual
source
blending
.
const
DUAL_SRC_BLENDING
=
0x0000_0000_0000_0080
;
/
/
/
Support
logic
operations
.
const
LOGIC_OP
=
0x0000_0000_0000_0100
;
/
/
/
Support
multiple
draws
per
indirect
call
.
const
MULTI_DRAW_INDIRECT
=
0x0000_0000_0000_0200
;
/
/
/
Support
indirect
drawing
with
first
instance
value
.
/
/
/
If
not
supported
the
first
instance
value
*
*
must
*
*
be
0
.
const
DRAW_INDIRECT_FIRST_INSTANCE
=
0x0000_0000_0000_0400
;
/
/
/
Support
depth
clamping
.
const
DEPTH_CLAMP
=
0x0000_0000_0000_0800
;
/
/
/
Support
depth
bias
clamping
.
const
DEPTH_BIAS_CLAMP
=
0x0000_0000_0000_1000
;
/
/
/
Support
non
-
fill
polygon
modes
.
const
NON_FILL_POLYGON_MODE
=
0x0000_0000_0000_2000
;
/
/
/
Support
depth
bounds
test
.
const
DEPTH_BOUNDS
=
0x0000_0000_0000_4000
;
/
/
/
Support
lines
with
width
other
than
1
.
0
.
const
LINE_WIDTH
=
0x0000_0000_0000_8000
;
/
/
/
Support
points
with
size
greater
than
1
.
0
.
const
POINT_SIZE
=
0x0000_0000_0001_0000
;
/
/
/
Support
replacing
alpha
values
with
1
.
0
.
const
ALPHA_TO_ONE
=
0x0000_0000_0002_0000
;
/
/
/
Support
multiple
viewports
and
scissors
.
const
MULTI_VIEWPORTS
=
0x0000_0000_0004_0000
;
/
/
/
Support
anisotropic
filtering
.
const
SAMPLER_ANISOTROPY
=
0x0000_0000_0008_0000
;
/
/
/
Support
ETC2
texture
compression
formats
.
const
FORMAT_ETC2
=
0x0000_0000_0010_0000
;
/
/
/
Support
ASTC
(
LDR
)
texture
compression
formats
.
const
FORMAT_ASTC_LDR
=
0x0000_0000_0020_0000
;
/
/
/
Support
BC
texture
compression
formats
.
const
FORMAT_BC
=
0x0000_0000_0040_0000
;
/
/
/
Support
precise
occlusion
queries
returning
the
actual
number
of
samples
.
/
/
/
If
not
supported
queries
return
a
non
-
zero
value
when
at
least
*
*
one
*
*
sample
passes
.
const
PRECISE_OCCLUSION_QUERY
=
0x0000_0000_0080_0000
;
/
/
/
Support
query
of
pipeline
statistics
.
const
PIPELINE_STATISTICS_QUERY
=
0x0000_0000_0100_0000
;
/
/
/
Support
unordered
access
stores
and
atomic
ops
in
the
vertex
geometry
/
/
/
and
tessellation
shader
stage
.
/
/
/
If
not
supported
the
shader
resources
*
*
must
*
*
be
annotated
as
read
-
only
.
const
VERTEX_STORES_AND_ATOMICS
=
0x0000_0000_0200_0000
;
/
/
/
Support
unordered
access
stores
and
atomic
ops
in
the
fragment
shader
stage
/
/
/
If
not
supported
the
shader
resources
*
*
must
*
*
be
annotated
as
read
-
only
.
const
FRAGMENT_STORES_AND_ATOMICS
=
0x0000_0000_0400_0000
;
/
/
/
const
SHADER_TESSELLATION_AND_GEOMETRY_POINT_SIZE
=
0x0000_0000_0800_0000
;
/
/
/
const
SHADER_IMAGE_GATHER_EXTENDED
=
0x0000_0000_1000_0000
;
/
/
/
const
SHADER_STORAGE_IMAGE_EXTENDED_FORMATS
=
0x0000_0000_2000_0000
;
/
/
/
const
SHADER_STORAGE_IMAGE_MULTISAMPLE
=
0x0000_0000_4000_0000
;
/
/
/
const
SHADER_STORAGE_IMAGE_READ_WITHOUT_FORMAT
=
0x0000_0000_8000_0000
;
/
/
/
const
SHADER_STORAGE_IMAGE_WRITE_WITHOUT_FORMAT
=
0x0000_0001_0000_0000
;
/
/
/
const
SHADER_UNIFORM_BUFFER_ARRAY_DYNAMIC_INDEXING
=
0x0000_0002_0000_0000
;
/
/
/
const
SHADER_SAMPLED_IMAGE_ARRAY_DYNAMIC_INDEXING
=
0x0000_0004_0000_0000
;
/
/
/
const
SHADER_STORAGE_BUFFER_ARRAY_DYNAMIC_INDEXING
=
0x0000_0008_0000_0000
;
/
/
/
const
SHADER_STORAGE_IMAGE_ARRAY_DYNAMIC_INDEXING
=
0x0000_0010_0000_0000
;
/
/
/
const
SHADER_CLIP_DISTANCE
=
0x0000_0020_0000_0000
;
/
/
/
const
SHADER_CULL_DISTANCE
=
0x0000_0040_0000_0000
;
/
/
/
const
SHADER_FLOAT64
=
0x0000_0080_0000_0000
;
/
/
/
const
SHADER_INT64
=
0x0000_0100_0000_0000
;
/
/
/
const
SHADER_INT16
=
0x0000_0200_0000_0000
;
/
/
/
const
SHADER_RESOURCE_RESIDENCY
=
0x0000_0400_0000_0000
;
/
/
/
const
SHADER_RESOURCE_MIN_LOD
=
0x0000_0800_0000_0000
;
/
/
/
const
SPARSE_BINDING
=
0x0000_1000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_BUFFER
=
0x0000_2000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_IMAGE_2D
=
0x0000_4000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_IMAGE_3D
=
0x0000_8000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_2_SAMPLES
=
0x0001_0000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_4_SAMPLES
=
0x0002_0000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_8_SAMPLES
=
0x0004_0000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_16_SAMPLES
=
0x0008_0000_0000_0000
;
/
/
/
const
SPARSE_RESIDENCY_ALIASED
=
0x0010_0000_0000_0000
;
/
/
/
const
VARIABLE_MULTISAMPLE_RATE
=
0x0020_0000_0000_0000
;
/
/
/
const
INHERITED_QUERIES
=
0x0040_0000_0000_0000
;
/
/
/
Support
for
arrays
of
texture
descriptors
const
TEXTURE_DESCRIPTOR_ARRAY
=
0x0080_0000_0000_0000
;
/
/
/
Support
for
const
SAMPLER_MIRROR_CLAMP_EDGE
=
0x0100_0000_0000_0000
;
/
/
/
Allow
indexing
sampled
texture
descriptor
arrays
with
dynamically
non
-
uniform
data
const
SAMPLED_TEXTURE_DESCRIPTOR_INDEXING
=
0x0200_0000_0000_0000
;
/
/
/
Allow
indexing
storage
texture
descriptor
arrays
with
dynamically
non
-
uniform
data
const
STORAGE_TEXTURE_DESCRIPTOR_INDEXING
=
0x0400_0000_0000_0000
;
/
/
/
Allow
descriptor
arrays
to
be
unsized
in
shaders
const
UNSIZED_DESCRIPTOR_ARRAY
=
0x0800_0000_0000_0000
;
/
/
/
Enable
draw_indirect_count
and
draw_indexed_indirect_count
const
DRAW_INDIRECT_COUNT
=
0x1000_0000_0000_0000
;
/
/
/
Support
triangle
fan
primitive
topology
.
const
TRIANGLE_FAN
=
0x0001
<
<
64
;
/
/
/
Support
separate
stencil
reference
values
for
front
and
back
sides
.
const
SEPARATE_STENCIL_REF_VALUES
=
0x0002
<
<
64
;
/
/
/
Support
manually
specified
vertex
attribute
rates
(
divisors
)
.
const
INSTANCE_RATE
=
0x0004
<
<
64
;
/
/
/
Support
non
-
zero
mipmap
bias
on
samplers
.
const
SAMPLER_MIP_LOD_BIAS
=
0x0008
<
<
64
;
/
/
/
Make
the
NDC
coordinate
system
pointing
Y
up
to
match
D3D
and
Metal
.
const
NDC_Y_UP
=
0x0001
<
<
80
;
}
}
bitflags
!
{
/
/
/
Features
that
the
device
supports
natively
but
is
able
to
emulate
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Hints
:
u32
{
/
/
/
Support
indexed
instanced
drawing
with
base
vertex
and
instance
.
const
BASE_VERTEX_INSTANCE_DRAWING
=
0x0001
;
}
}
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Limits
{
pub
max_image_1d_size
:
image
:
:
Size
pub
max_image_2d_size
:
image
:
:
Size
pub
max_image_3d_size
:
image
:
:
Size
pub
max_image_cube_size
:
image
:
:
Size
pub
max_image_array_layers
:
image
:
:
Layer
pub
max_texel_elements
:
usize
pub
max_uniform_buffer_range
:
buffer
:
:
Offset
pub
max_storage_buffer_range
:
buffer
:
:
Offset
pub
max_push_constants_size
:
usize
pub
max_memory_allocation_count
:
usize
pub
max_sampler_allocation_count
:
usize
pub
max_bound_descriptor_sets
:
pso
:
:
DescriptorSetIndex
pub
max_framebuffer_layers
:
usize
pub
max_per_stage_descriptor_samplers
:
usize
pub
max_per_stage_descriptor_uniform_buffers
:
usize
pub
max_per_stage_descriptor_storage_buffers
:
usize
pub
max_per_stage_descriptor_sampled_images
:
usize
pub
max_per_stage_descriptor_storage_images
:
usize
pub
max_per_stage_descriptor_input_attachments
:
usize
pub
max_per_stage_resources
:
usize
pub
max_descriptor_set_samplers
:
usize
pub
max_descriptor_set_uniform_buffers
:
usize
pub
max_descriptor_set_uniform_buffers_dynamic
:
usize
pub
max_descriptor_set_storage_buffers
:
usize
pub
max_descriptor_set_storage_buffers_dynamic
:
usize
pub
max_descriptor_set_sampled_images
:
usize
pub
max_descriptor_set_storage_images
:
usize
pub
max_descriptor_set_input_attachments
:
usize
pub
max_vertex_input_attributes
:
usize
pub
max_vertex_input_bindings
:
usize
pub
max_vertex_input_attribute_offset
:
usize
pub
max_vertex_input_binding_stride
:
usize
pub
max_vertex_output_components
:
usize
pub
max_patch_size
:
pso
:
:
PatchSize
pub
max_geometry_shader_invocations
:
usize
pub
max_geometry_input_components
:
usize
pub
max_geometry_output_components
:
usize
pub
max_geometry_output_vertices
:
usize
pub
max_geometry_total_output_components
:
usize
pub
max_fragment_input_components
:
usize
pub
max_fragment_output_attachments
:
usize
pub
max_fragment_dual_source_attachments
:
usize
pub
max_fragment_combined_output_resources
:
usize
pub
max_compute_shared_memory_size
:
usize
pub
max_compute_work_group_count
:
WorkGroupCount
pub
max_compute_work_group_invocations
:
usize
pub
max_compute_work_group_size
:
[
u32
;
3
]
pub
max_draw_indexed_index_value
:
IndexCount
pub
max_draw_indirect_count
:
InstanceCount
pub
max_sampler_lod_bias
:
f32
pub
max_sampler_anisotropy
:
f32
pub
max_viewports
:
usize
pub
max_viewport_dimensions
:
[
image
:
:
Size
;
2
]
pub
max_framebuffer_extent
:
image
:
:
Extent
pub
min_memory_map_alignment
:
usize
pub
buffer_image_granularity
:
buffer
:
:
Offset
pub
min_texel_buffer_offset_alignment
:
buffer
:
:
Offset
pub
min_uniform_buffer_offset_alignment
:
buffer
:
:
Offset
pub
min_storage_buffer_offset_alignment
:
buffer
:
:
Offset
pub
framebuffer_color_sample_counts
:
image
:
:
NumSamples
pub
framebuffer_depth_sample_counts
:
image
:
:
NumSamples
pub
framebuffer_stencil_sample_counts
:
image
:
:
NumSamples
pub
max_color_attachments
:
usize
pub
standard_sample_locations
:
bool
pub
optimal_buffer_copy_offset_alignment
:
buffer
:
:
Offset
pub
optimal_buffer_copy_pitch_alignment
:
buffer
:
:
Offset
pub
non_coherent_atom_size
:
usize
pub
min_vertex_input_binding_stride_alignment
:
buffer
:
:
Offset
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
#
[
repr
(
u8
)
]
pub
enum
IndexType
{
U16
U32
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
UnsupportedBackend
;
pub
trait
Instance
<
B
:
Backend
>
:
Any
+
Send
+
Sync
+
Sized
{
fn
create
(
name
:
&
str
version
:
u32
)
-
>
Result
<
Self
UnsupportedBackend
>
;
fn
enumerate_adapters
(
&
self
)
-
>
Vec
<
adapter
:
:
Adapter
<
B
>
>
;
unsafe
fn
create_surface
(
&
self
_
:
&
impl
raw_window_handle
:
:
HasRawWindowHandle
)
-
>
Result
<
B
:
:
Surface
window
:
:
InitError
>
;
unsafe
fn
destroy_surface
(
&
self
surface
:
B
:
:
Surface
)
;
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
MemoryTypeId
(
pub
usize
)
;
impl
From
<
usize
>
for
MemoryTypeId
{
fn
from
(
id
:
usize
)
-
>
Self
{
MemoryTypeId
(
id
)
}
}
struct
PseudoVec
<
T
>
(
Option
<
T
>
)
;
impl
<
T
>
std
:
:
iter
:
:
Extend
<
T
>
for
PseudoVec
<
T
>
{
fn
extend
<
I
:
IntoIterator
<
Item
=
T
>
>
(
&
mut
self
iter
:
I
)
{
let
mut
iter
=
iter
.
into_iter
(
)
;
self
.
0
=
iter
.
next
(
)
;
assert
!
(
iter
.
next
(
)
.
is_none
(
)
)
;
}
}
#
[
allow
(
missing_docs
)
]
pub
trait
Backend
:
'
static
+
Sized
+
Eq
+
Clone
+
Hash
+
fmt
:
:
Debug
+
Any
+
Send
+
Sync
{
type
Instance
:
Instance
<
Self
>
;
type
PhysicalDevice
:
adapter
:
:
PhysicalDevice
<
Self
>
;
type
Device
:
device
:
:
Device
<
Self
>
;
type
Surface
:
window
:
:
PresentationSurface
<
Self
>
;
type
Swapchain
:
window
:
:
Swapchain
<
Self
>
;
type
QueueFamily
:
queue
:
:
QueueFamily
;
type
CommandQueue
:
queue
:
:
CommandQueue
<
Self
>
;
type
CommandBuffer
:
command
:
:
CommandBuffer
<
Self
>
;
type
ShaderModule
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
RenderPass
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Framebuffer
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Memory
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
CommandPool
:
pool
:
:
CommandPool
<
Self
>
;
type
Buffer
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
BufferView
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Image
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
ImageView
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Sampler
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
ComputePipeline
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
GraphicsPipeline
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
PipelineCache
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
PipelineLayout
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
DescriptorPool
:
pso
:
:
DescriptorPool
<
Self
>
;
type
DescriptorSet
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
DescriptorSetLayout
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Fence
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Semaphore
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
Event
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
type
QueryPool
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
;
}
