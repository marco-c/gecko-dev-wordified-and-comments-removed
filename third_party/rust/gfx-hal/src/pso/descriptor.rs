use
crate
:
:
{
buffer
:
:
SubRange
device
:
:
OutOfMemory
image
:
:
Layout
pso
:
:
ShaderStageFlags
Backend
PseudoVec
}
;
use
std
:
:
{
fmt
iter
}
;
pub
type
DescriptorSetIndex
=
u16
;
pub
type
DescriptorBinding
=
u32
;
pub
type
DescriptorArrayIndex
=
usize
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BufferDescriptorType
{
Storage
{
read_only
:
bool
}
Uniform
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
BufferDescriptorFormat
{
Structured
{
dynamic_offset
:
bool
}
Texel
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
ImageDescriptorType
{
Sampled
{
with_sampler
:
bool
}
Storage
{
read_only
:
bool
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
DescriptorType
{
Sampler
Image
{
ty
:
ImageDescriptorType
}
Buffer
{
ty
:
BufferDescriptorType
format
:
BufferDescriptorFormat
}
InputAttachment
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
DescriptorSetLayoutBinding
{
pub
binding
:
DescriptorBinding
pub
ty
:
DescriptorType
pub
count
:
DescriptorArrayIndex
pub
stage_flags
:
ShaderStageFlags
pub
immutable_samplers
:
bool
}
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
DescriptorRangeDesc
{
pub
ty
:
DescriptorType
pub
count
:
usize
}
#
[
derive
(
Clone
Debug
PartialEq
thiserror
:
:
Error
)
]
pub
enum
AllocationError
{
#
[
error
(
transparent
)
]
OutOfMemory
(
#
[
from
]
OutOfMemory
)
#
[
error
(
"
Out
of
pool
memory
"
)
]
OutOfPoolMemory
#
[
error
(
"
Pool
is
fragmented
"
)
]
FragmentedPool
#
[
error
(
"
Incompatible
layout
"
)
]
IncompatibleLayout
}
pub
trait
DescriptorPool
<
B
:
Backend
>
:
Send
+
Sync
+
fmt
:
:
Debug
{
unsafe
fn
allocate_one
(
&
mut
self
layout
:
&
B
:
:
DescriptorSetLayout
)
-
>
Result
<
B
:
:
DescriptorSet
AllocationError
>
{
let
mut
result
=
PseudoVec
(
None
)
;
self
.
allocate
(
iter
:
:
once
(
layout
)
&
mut
result
)
?
;
Ok
(
result
.
0
.
unwrap
(
)
)
}
unsafe
fn
allocate
<
'
a
I
E
>
(
&
mut
self
layouts
:
I
list
:
&
mut
E
)
-
>
Result
<
(
)
AllocationError
>
where
I
:
Iterator
<
Item
=
&
'
a
B
:
:
DescriptorSetLayout
>
E
:
Extend
<
B
:
:
DescriptorSet
>
{
for
layout
in
layouts
{
let
set
=
self
.
allocate_one
(
layout
)
?
;
list
.
extend
(
iter
:
:
once
(
set
)
)
;
}
Ok
(
(
)
)
}
unsafe
fn
free
<
I
>
(
&
mut
self
descriptor_sets
:
I
)
where
I
:
Iterator
<
Item
=
B
:
:
DescriptorSet
>
;
unsafe
fn
reset
(
&
mut
self
)
;
}
#
[
derive
(
Debug
)
]
pub
struct
DescriptorSetWrite
<
'
a
B
:
Backend
I
>
where
I
:
Iterator
<
Item
=
Descriptor
<
'
a
B
>
>
{
pub
set
:
&
'
a
mut
B
:
:
DescriptorSet
pub
binding
:
DescriptorBinding
pub
array_offset
:
DescriptorArrayIndex
pub
descriptors
:
I
}
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Debug
)
]
pub
enum
Descriptor
<
'
a
B
:
Backend
>
{
Sampler
(
&
'
a
B
:
:
Sampler
)
Image
(
&
'
a
B
:
:
ImageView
Layout
)
CombinedImageSampler
(
&
'
a
B
:
:
ImageView
Layout
&
'
a
B
:
:
Sampler
)
Buffer
(
&
'
a
B
:
:
Buffer
SubRange
)
TexelBuffer
(
&
'
a
B
:
:
BufferView
)
}
#
[
derive
(
Debug
)
]
pub
struct
DescriptorSetCopy
<
'
a
B
:
Backend
>
{
pub
src_set
:
&
'
a
B
:
:
DescriptorSet
pub
src_binding
:
DescriptorBinding
pub
src_array_offset
:
DescriptorArrayIndex
pub
dst_set
:
&
'
a
mut
B
:
:
DescriptorSet
pub
dst_binding
:
DescriptorBinding
pub
dst_array_offset
:
DescriptorArrayIndex
pub
count
:
usize
}
bitflags
!
{
/
/
/
Descriptor
pool
creation
flags
.
pub
struct
DescriptorPoolCreateFlags
:
u32
{
/
/
/
Specifies
that
descriptor
sets
are
allowed
to
be
freed
from
the
pool
/
/
/
individually
.
const
FREE_DESCRIPTOR_SET
=
0x1
;
}
}
