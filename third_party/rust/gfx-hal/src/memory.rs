use
crate
:
:
{
buffer
image
queue
Backend
}
;
use
std
:
:
ops
:
:
Range
;
bitflags
!
(
/
/
/
Memory
property
flags
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Properties
:
u16
{
/
/
/
Device
local
memory
on
the
GPU
.
const
DEVICE_LOCAL
=
0x1
;
/
/
/
Host
visible
memory
can
be
accessed
by
the
CPU
.
/
/
/
/
/
/
Backends
must
provide
at
least
one
cpu
visible
memory
.
const
CPU_VISIBLE
=
0x2
;
/
/
/
CPU
-
GPU
coherent
.
/
/
/
/
/
/
Non
-
coherent
memory
requires
explicit
flushing
.
const
COHERENT
=
0x4
;
/
/
/
Cached
memory
by
the
CPU
const
CPU_CACHED
=
0x8
;
/
/
/
Memory
that
may
be
lazily
allocated
as
needed
on
the
GPU
/
/
/
and
*
must
not
*
be
visible
to
the
CPU
.
const
LAZILY_ALLOCATED
=
0x10
;
}
)
;
bitflags
!
(
/
/
/
Memory
heap
flags
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
HeapFlags
:
u16
{
/
/
/
Device
local
memory
on
the
GPU
.
const
DEVICE_LOCAL
=
0x1
;
}
)
;
bitflags
!
(
/
/
/
Barrier
dependency
flags
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Dependencies
:
u32
{
/
/
/
Specifies
the
memory
dependency
to
be
framebuffer
-
local
.
const
BY_REGION
=
0x1
;
/
/
/
const
VIEW_LOCAL
=
0x2
;
/
/
/
const
DEVICE_GROUP
=
0x4
;
}
)
;
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Debug
)
]
pub
enum
Barrier
<
'
a
B
:
Backend
>
{
AllBuffers
(
Range
<
buffer
:
:
Access
>
)
AllImages
(
Range
<
image
:
:
Access
>
)
Buffer
{
states
:
Range
<
buffer
:
:
State
>
target
:
&
'
a
B
:
:
Buffer
range
:
buffer
:
:
SubRange
families
:
Option
<
Range
<
queue
:
:
QueueFamilyId
>
>
}
Image
{
states
:
Range
<
image
:
:
State
>
target
:
&
'
a
B
:
:
Image
range
:
image
:
:
SubresourceRange
families
:
Option
<
Range
<
queue
:
:
QueueFamilyId
>
>
}
}
impl
<
'
a
B
:
Backend
>
Barrier
<
'
a
B
>
{
pub
fn
whole_buffer
(
target
:
&
'
a
B
:
:
Buffer
states
:
Range
<
buffer
:
:
State
>
)
-
>
Self
{
Barrier
:
:
Buffer
{
states
target
families
:
None
range
:
buffer
:
:
SubRange
:
:
WHOLE
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Requirements
{
pub
size
:
u64
pub
alignment
:
u64
pub
type_mask
:
u32
}
#
[
derive
(
Clone
Debug
Default
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Segment
{
pub
offset
:
u64
pub
size
:
Option
<
u64
>
}
impl
Segment
{
pub
const
ALL
:
Self
=
Segment
{
offset
:
0
size
:
None
}
;
}
#
[
derive
(
Debug
)
]
pub
struct
SparseBind
<
M
>
{
pub
resource_offset
:
u64
pub
size
:
u64
pub
memory
:
Option
<
(
M
u64
)
>
}
#
[
derive
(
Debug
)
]
pub
struct
SparseImageBind
<
M
>
{
pub
subresource
:
image
:
:
Subresource
pub
offset
:
image
:
:
Offset
pub
extent
:
image
:
:
Extent
pub
memory
:
Option
<
(
M
u64
)
>
}
bitflags
!
(
/
/
/
Sparse
flags
for
creating
images
and
buffers
.
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
SparseFlags
:
u32
{
/
/
/
Specifies
the
view
will
be
backed
using
sparse
memory
binding
.
const
SPARSE_BINDING
=
0x0000_0001
;
/
/
/
Specifies
the
view
can
be
partially
backed
with
sparse
memory
binding
.
/
/
/
Must
have
SPARSE_BINDING
enabled
.
const
SPARSE_RESIDENCY
=
0x0000_0002
;
/
/
/
Specifies
the
view
will
be
backed
using
sparse
memory
binding
with
memory
bindings
that
/
/
/
might
alias
other
data
.
Must
have
SPARSE_BINDING
enabled
.
const
SPARSE_ALIASED
=
0x0000_0004
;
}
)
;
