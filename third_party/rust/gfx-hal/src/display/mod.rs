use
crate
:
:
{
window
:
:
{
Extent2D
Offset2D
}
Backend
}
;
use
std
:
:
ops
:
:
Range
;
pub
mod
control
;
bitflags
!
{
/
*
*
List
of
the
hardware
display
transformations
*
/
pub
struct
SurfaceTransformFlags
:
u32
{
/
/
/
Specify
that
image
content
is
presented
without
being
transformed
.
const
IDENTITY
=
0x00000001
;
/
/
/
Specify
that
image
content
is
rotated
90
degrees
clockwise
.
const
ROTATE_90
=
0x00000002
;
/
/
/
Specify
that
image
content
is
rotated
180
degrees
clockwise
.
const
ROTATE_180
=
0x00000004
;
/
/
/
Specify
that
image
content
is
rotated
270
degrees
clockwise
.
const
ROTATE_270
=
0x00000008
;
/
/
/
Specify
that
image
content
is
mirrored
horizontally
.
const
HORIZONTAL_MIRROR
=
0x00000010
;
/
/
/
Specify
that
image
content
is
mirrored
horizontally
then
rotated
90
degrees
clockwise
.
const
HORIZONTAL_MIRROR_ROTATE_90
=
0x00000020
;
/
/
/
Specify
that
image
content
is
mirrored
horizontally
then
rotated
180
degrees
clockwise
.
const
HORIZONTAL_MIRROR_ROTATE_180
=
0x00000040
;
/
/
/
Specify
that
image
content
is
mirrored
horizontally
then
rotated
270
degrees
clockwise
.
const
HORIZONTAL_MIRROR_ROTATE_270
=
0x00000080
;
/
/
/
Specify
that
the
presentation
transform
is
not
specified
and
is
instead
determined
by
platform
-
specific
considerations
and
mechanisms
outside
Vulkan
.
const
INHERIT
=
0x00000100
;
}
}
impl
From
<
SurfaceTransform
>
for
SurfaceTransformFlags
{
fn
from
(
surface_transformation
:
SurfaceTransform
)
-
>
Self
{
match
surface_transformation
{
SurfaceTransform
:
:
Identity
=
>
Self
:
:
IDENTITY
SurfaceTransform
:
:
Rotate90
=
>
Self
:
:
ROTATE_90
SurfaceTransform
:
:
Rotate180
=
>
Self
:
:
ROTATE_180
SurfaceTransform
:
:
Rotate270
=
>
Self
:
:
ROTATE_270
SurfaceTransform
:
:
HorizontalMirror
=
>
Self
:
:
HORIZONTAL_MIRROR
SurfaceTransform
:
:
HorizontalMirrorRotate90
=
>
Self
:
:
HORIZONTAL_MIRROR_ROTATE_90
SurfaceTransform
:
:
HorizontalMirrorRotate180
=
>
Self
:
:
HORIZONTAL_MIRROR_ROTATE_180
SurfaceTransform
:
:
HorizontalMirrorRotate270
=
>
Self
:
:
HORIZONTAL_MIRROR_ROTATE_270
SurfaceTransform
:
:
Inherit
=
>
Self
:
:
INHERIT
}
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
allow
(
non_camel_case_types
)
]
pub
enum
SurfaceTransform
{
Identity
Rotate90
Rotate180
Rotate270
HorizontalMirror
HorizontalMirrorRotate90
HorizontalMirrorRotate180
HorizontalMirrorRotate270
Inherit
}
impl
Default
for
SurfaceTransform
{
fn
default
(
)
-
>
Self
{
Self
:
:
Identity
}
}
#
[
derive
(
Debug
)
]
pub
struct
DisplayInfo
{
pub
name
:
Option
<
String
>
pub
physical_dimensions
:
Extent2D
pub
physical_resolution
:
Extent2D
pub
supported_transforms
:
SurfaceTransformFlags
pub
plane_reorder_possible
:
bool
pub
persistent_content
:
bool
}
bitflags
!
{
/
*
*
Alpha
mode
used
in
display
surface
creation
*
/
pub
struct
DisplayPlaneAlphaFlags
:
u32
{
/
/
/
Specifies
that
the
source
image
will
be
treated
as
opaque
const
OPAQUE
=
1
;
/
/
/
Specifies
that
the
provided
global
alpha
value
will
be
applied
to
all
pixels
in
the
source
image
.
const
GLOBAL
=
2
;
/
/
/
Specifies
that
the
alpha
value
will
be
determined
by
the
alpha
channel
of
the
source
image
s
pixels
.
/
/
/
If
the
source
format
contains
no
alpha
values
no
blending
will
be
applied
.
The
source
alpha
values
are
not
premultiplied
into
the
source
image
s
other
color
channels
.
const
PER_PIXEL
=
4
;
/
/
/
Equivalent
to
PerPixel
except
the
source
alpha
values
are
assumed
to
be
premultiplied
into
the
source
image
s
other
color
channels
.
const
PER_PIXEL_PREMULTIPLIED
=
8
;
}
}
impl
From
<
DisplayPlaneAlpha
>
for
DisplayPlaneAlphaFlags
{
fn
from
(
display_plane_alpha
:
DisplayPlaneAlpha
)
-
>
Self
{
match
display_plane_alpha
{
DisplayPlaneAlpha
:
:
Opaque
=
>
Self
:
:
OPAQUE
DisplayPlaneAlpha
:
:
Global
(
_
)
=
>
Self
:
:
GLOBAL
DisplayPlaneAlpha
:
:
PerPixel
=
>
Self
:
:
PER_PIXEL
DisplayPlaneAlpha
:
:
PerPixelPremultiplied
=
>
Self
:
:
PER_PIXEL_PREMULTIPLIED
}
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
non_camel_case_types
)
]
pub
enum
DisplayPlaneAlpha
{
Opaque
Global
(
f32
)
PerPixel
PerPixelPremultiplied
}
impl
Default
for
DisplayPlaneAlpha
{
fn
default
(
)
-
>
Self
{
Self
:
:
Opaque
}
}
#
[
derive
(
Clone
Debug
PartialEq
thiserror
:
:
Error
)
]
pub
enum
DisplayError
{
#
[
error
(
transparent
)
]
OutOfMemory
(
#
[
from
]
crate
:
:
device
:
:
OutOfMemory
)
#
[
error
(
"
Unsupported
feature
"
)
]
UnsupportedFeature
}
#
[
derive
(
Clone
Debug
PartialEq
thiserror
:
:
Error
)
]
pub
enum
DisplayModeError
{
#
[
error
(
transparent
)
]
OutOfMemory
(
#
[
from
]
crate
:
:
device
:
:
OutOfMemory
)
#
[
error
(
"
Unsupported
resolution
and
refresh
rate
combination
"
)
]
UnsupportedDisplayMode
}
#
[
derive
(
Clone
Debug
PartialEq
thiserror
:
:
Error
)
]
pub
enum
DisplayPlaneSurfaceError
{
#
[
error
(
transparent
)
]
OutOfMemory
(
#
[
from
]
crate
:
:
device
:
:
OutOfMemory
)
#
[
error
(
"
Unsupported
feature
"
)
]
UnsupportedFeature
}
#
[
derive
(
Debug
)
]
pub
struct
Display
<
B
:
Backend
>
{
pub
handle
:
B
:
:
Display
pub
info
:
DisplayInfo
pub
modes
:
Vec
<
DisplayMode
<
B
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
DisplayMode
<
B
:
Backend
>
{
pub
handle
:
B
:
:
DisplayMode
pub
resolution
:
(
u32
u32
)
pub
refresh_rate
:
u32
}
#
[
derive
(
Debug
)
]
pub
struct
Plane
{
pub
handle
:
u32
pub
z_index
:
u32
}
#
[
derive
(
Debug
)
]
pub
struct
DisplayPlane
<
'
a
B
:
Backend
>
{
pub
display_mode
:
&
'
a
DisplayMode
<
B
>
pub
plane
:
&
'
a
Plane
pub
supported_alpha
:
Vec
<
DisplayPlaneAlpha
>
pub
src_position
:
Range
<
Offset2D
>
pub
src_extent
:
Range
<
Extent2D
>
pub
dst_position
:
Range
<
Offset2D
>
pub
dst_extent
:
Range
<
Extent2D
>
}
