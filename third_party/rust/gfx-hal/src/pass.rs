use
crate
:
:
{
format
:
:
Format
image
memory
:
:
Dependencies
pso
:
:
PipelineStage
Backend
}
;
use
std
:
:
ops
:
:
Range
;
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
AttachmentLoadOp
{
Load
Clear
DontCare
}
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
AttachmentStoreOp
{
Store
DontCare
}
pub
type
AttachmentLayout
=
image
:
:
Layout
;
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
AttachmentOps
{
pub
load
:
AttachmentLoadOp
pub
store
:
AttachmentStoreOp
}
impl
AttachmentOps
{
pub
const
DONT_CARE
:
Self
=
AttachmentOps
{
load
:
AttachmentLoadOp
:
:
DontCare
store
:
AttachmentStoreOp
:
:
DontCare
}
;
pub
const
PRESERVE
:
Self
=
AttachmentOps
{
load
:
AttachmentLoadOp
:
:
Load
store
:
AttachmentStoreOp
:
:
Store
}
;
pub
fn
new
(
load
:
AttachmentLoadOp
store
:
AttachmentStoreOp
)
-
>
Self
{
AttachmentOps
{
load
store
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
fn
whatever
(
)
-
>
Self
{
Self
:
:
DONT_CARE
}
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Attachment
{
pub
format
:
Option
<
Format
>
pub
samples
:
image
:
:
NumSamples
pub
ops
:
AttachmentOps
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
default
=
"
AttachmentOps
:
:
whatever
"
)
)
]
pub
stencil_ops
:
AttachmentOps
pub
layouts
:
Range
<
AttachmentLayout
>
}
impl
Attachment
{
pub
fn
has_clears
(
&
self
)
-
>
bool
{
self
.
ops
.
load
=
=
AttachmentLoadOp
:
:
Clear
|
|
self
.
stencil_ops
.
load
=
=
AttachmentLoadOp
:
:
Clear
}
}
pub
type
AttachmentId
=
usize
;
pub
type
AttachmentRef
=
(
AttachmentId
AttachmentLayout
)
;
pub
const
ATTACHMENT_UNUSED
:
AttachmentId
=
!
0
;
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
SubpassRef
{
External
Pass
(
usize
)
}
#
[
derive
(
Clone
Debug
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
SubpassDependency
{
pub
passes
:
Range
<
SubpassRef
>
pub
stages
:
Range
<
PipelineStage
>
pub
accesses
:
Range
<
image
:
:
Access
>
pub
flags
:
Dependencies
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
SubpassDesc
<
'
a
>
{
pub
colors
:
&
'
a
[
AttachmentRef
]
pub
depth_stencil
:
Option
<
&
'
a
AttachmentRef
>
pub
inputs
:
&
'
a
[
AttachmentRef
]
pub
resolves
:
&
'
a
[
AttachmentRef
]
pub
preserves
:
&
'
a
[
AttachmentId
]
}
pub
type
SubpassId
=
usize
;
#
[
derive
(
Debug
)
]
pub
struct
Subpass
<
'
a
B
:
Backend
>
{
pub
index
:
SubpassId
pub
main_pass
:
&
'
a
B
:
:
RenderPass
}
impl
<
'
a
B
:
Backend
>
Clone
for
Subpass
<
'
a
B
>
{
fn
clone
(
&
self
)
-
>
Self
{
Subpass
{
index
:
self
.
index
main_pass
:
self
.
main_pass
}
}
}
impl
<
'
a
B
:
Backend
>
PartialEq
for
Subpass
<
'
a
B
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
index
=
=
other
.
index
&
&
self
.
main_pass
as
*
const
_
=
=
other
.
main_pass
as
*
const
_
}
}
impl
<
'
a
B
:
Backend
>
Copy
for
Subpass
<
'
a
B
>
{
}
impl
<
'
a
B
:
Backend
>
Eq
for
Subpass
<
'
a
B
>
{
}
