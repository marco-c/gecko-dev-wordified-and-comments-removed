pub
mod
family
;
use
crate
:
:
{
device
:
:
OutOfMemory
pso
window
:
:
{
PresentError
PresentationSurface
Suboptimal
SwapImageIndex
}
Backend
}
;
use
std
:
:
{
any
:
:
Any
borrow
:
:
Borrow
fmt
iter
}
;
pub
use
self
:
:
family
:
:
{
QueueFamily
QueueFamilyId
QueueGroup
}
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
QueueType
{
General
Graphics
Compute
Transfer
}
impl
QueueType
{
pub
fn
supports_graphics
(
&
self
)
-
>
bool
{
match
*
self
{
QueueType
:
:
General
|
QueueType
:
:
Graphics
=
>
true
QueueType
:
:
Compute
|
QueueType
:
:
Transfer
=
>
false
}
}
pub
fn
supports_compute
(
&
self
)
-
>
bool
{
match
*
self
{
QueueType
:
:
General
|
QueueType
:
:
Graphics
|
QueueType
:
:
Compute
=
>
true
QueueType
:
:
Transfer
=
>
false
}
}
pub
fn
supports_transfer
(
&
self
)
-
>
bool
{
true
}
}
pub
type
QueuePriority
=
f32
;
#
[
derive
(
Debug
)
]
pub
struct
Submission
<
Ic
Iw
Is
>
{
pub
command_buffers
:
Ic
pub
wait_semaphores
:
Iw
pub
signal_semaphores
:
Is
}
pub
trait
CommandQueue
<
B
:
Backend
>
:
fmt
:
:
Debug
+
Any
+
Send
+
Sync
{
unsafe
fn
submit
<
'
a
T
Ic
S
Iw
Is
>
(
&
mut
self
submission
:
Submission
<
Ic
Iw
Is
>
fence
:
Option
<
&
B
:
:
Fence
>
)
where
T
:
'
a
+
Borrow
<
B
:
:
CommandBuffer
>
Ic
:
IntoIterator
<
Item
=
&
'
a
T
>
S
:
'
a
+
Borrow
<
B
:
:
Semaphore
>
Iw
:
IntoIterator
<
Item
=
(
&
'
a
S
pso
:
:
PipelineStage
)
>
Is
:
IntoIterator
<
Item
=
&
'
a
S
>
;
unsafe
fn
submit_without_semaphores
<
'
a
T
Ic
>
(
&
mut
self
command_buffers
:
Ic
fence
:
Option
<
&
B
:
:
Fence
>
)
where
T
:
'
a
+
Borrow
<
B
:
:
CommandBuffer
>
Ic
:
IntoIterator
<
Item
=
&
'
a
T
>
{
let
submission
=
Submission
{
command_buffers
wait_semaphores
:
iter
:
:
empty
(
)
signal_semaphores
:
iter
:
:
empty
(
)
}
;
self
.
submit
:
:
<
_
_
B
:
:
Semaphore
_
_
>
(
submission
fence
)
}
unsafe
fn
present
<
'
a
W
Is
S
Iw
>
(
&
mut
self
swapchains
:
Is
wait_semaphores
:
Iw
)
-
>
Result
<
Option
<
Suboptimal
>
PresentError
>
where
Self
:
Sized
W
:
'
a
+
Borrow
<
B
:
:
Swapchain
>
Is
:
IntoIterator
<
Item
=
(
&
'
a
W
SwapImageIndex
)
>
S
:
'
a
+
Borrow
<
B
:
:
Semaphore
>
Iw
:
IntoIterator
<
Item
=
&
'
a
S
>
;
unsafe
fn
present_without_semaphores
<
'
a
W
Is
>
(
&
mut
self
swapchains
:
Is
)
-
>
Result
<
Option
<
Suboptimal
>
PresentError
>
where
Self
:
Sized
W
:
'
a
+
Borrow
<
B
:
:
Swapchain
>
Is
:
IntoIterator
<
Item
=
(
&
'
a
W
SwapImageIndex
)
>
{
self
.
present
:
:
<
_
_
B
:
:
Semaphore
_
>
(
swapchains
iter
:
:
empty
(
)
)
}
unsafe
fn
present_surface
(
&
mut
self
surface
:
&
mut
B
:
:
Surface
image
:
<
B
:
:
Surface
as
PresentationSurface
<
B
>
>
:
:
SwapchainImage
wait_semaphore
:
Option
<
&
B
:
:
Semaphore
>
)
-
>
Result
<
Option
<
Suboptimal
>
PresentError
>
;
fn
wait_idle
(
&
self
)
-
>
Result
<
(
)
OutOfMemory
>
;
}
