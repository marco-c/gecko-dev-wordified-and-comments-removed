use
core
:
:
cell
:
:
UnsafeCell
;
use
core
:
:
default
:
:
Default
;
use
core
:
:
fmt
;
use
core
:
:
marker
:
:
Sync
;
use
core
:
:
ops
:
:
{
Deref
DerefMut
Drop
}
;
use
core
:
:
option
:
:
Option
:
:
{
self
None
Some
}
;
use
core
:
:
sync
:
:
atomic
:
:
{
spin_loop_hint
as
cpu_relax
AtomicBool
Ordering
}
;
pub
(
crate
)
struct
Mutex
<
T
:
?
Sized
>
{
lock
:
AtomicBool
data
:
UnsafeCell
<
T
>
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
MutexGuard
<
'
a
T
:
?
Sized
>
{
lock
:
&
'
a
AtomicBool
data
:
&
'
a
mut
T
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Sync
for
Mutex
<
T
>
{
}
unsafe
impl
<
T
:
?
Sized
+
Send
>
Send
for
Mutex
<
T
>
{
}
impl
<
T
>
Mutex
<
T
>
{
pub
(
crate
)
const
fn
new
(
user_data
:
T
)
-
>
Mutex
<
T
>
{
Mutex
{
lock
:
AtomicBool
:
:
new
(
false
)
data
:
UnsafeCell
:
:
new
(
user_data
)
}
}
}
impl
<
T
:
?
Sized
>
Mutex
<
T
>
{
fn
obtain_lock
(
&
self
)
{
while
self
.
lock
.
compare_and_swap
(
false
true
Ordering
:
:
Acquire
)
!
=
false
{
while
self
.
lock
.
load
(
Ordering
:
:
Relaxed
)
{
cpu_relax
(
)
;
}
}
}
pub
(
crate
)
fn
lock
(
&
self
)
-
>
MutexGuard
<
'
_
T
>
{
self
.
obtain_lock
(
)
;
MutexGuard
{
lock
:
&
self
.
lock
data
:
unsafe
{
&
mut
*
self
.
data
.
get
(
)
}
}
}
pub
(
crate
)
fn
try_lock
(
&
self
)
-
>
Option
<
MutexGuard
<
'
_
T
>
>
{
if
self
.
lock
.
compare_and_swap
(
false
true
Ordering
:
:
Acquire
)
=
=
false
{
Some
(
MutexGuard
{
lock
:
&
self
.
lock
data
:
unsafe
{
&
mut
*
self
.
data
.
get
(
)
}
}
)
}
else
{
None
}
}
}
impl
<
T
:
?
Sized
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Mutex
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
.
try_lock
(
)
{
Some
(
guard
)
=
>
write
!
(
f
"
Mutex
{
{
data
:
"
)
.
and_then
(
|
(
)
|
(
&
*
guard
)
.
fmt
(
f
)
)
.
and_then
(
|
(
)
|
write
!
(
f
"
}
}
"
)
)
None
=
>
write
!
(
f
"
Mutex
{
{
<
locked
>
}
}
"
)
}
}
}
impl
<
T
:
?
Sized
+
Default
>
Default
for
Mutex
<
T
>
{
fn
default
(
)
-
>
Mutex
<
T
>
{
Mutex
:
:
new
(
Default
:
:
default
(
)
)
}
}
impl
<
'
a
T
:
?
Sized
>
Deref
for
MutexGuard
<
'
a
T
>
{
type
Target
=
T
;
fn
deref
<
'
b
>
(
&
'
b
self
)
-
>
&
'
b
T
{
&
*
self
.
data
}
}
impl
<
'
a
T
:
?
Sized
>
DerefMut
for
MutexGuard
<
'
a
T
>
{
fn
deref_mut
<
'
b
>
(
&
'
b
mut
self
)
-
>
&
'
b
mut
T
{
&
mut
*
self
.
data
}
}
impl
<
'
a
T
:
?
Sized
>
Drop
for
MutexGuard
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
lock
.
store
(
false
Ordering
:
:
Release
)
;
}
}
