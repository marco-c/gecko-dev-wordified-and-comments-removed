use
std
:
:
net
:
:
SocketAddr
;
use
crate
:
:
cid
:
:
{
ConnectionId
ConnectionIdRef
}
;
use
neqo_common
:
:
Datagram
;
pub
const
PATH_MTU_V6
:
usize
=
1337
;
pub
const
PATH_MTU_V4
:
usize
=
PATH_MTU_V6
+
20
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
Path
{
local
:
SocketAddr
remote
:
SocketAddr
local_cids
:
Vec
<
ConnectionId
>
remote_cid
:
ConnectionId
}
impl
Path
{
pub
fn
new
(
local
:
SocketAddr
remote
:
SocketAddr
local_cid
:
ConnectionId
remote_cid
:
ConnectionId
)
-
>
Self
{
Self
{
local
remote
local_cids
:
vec
!
[
local_cid
]
remote_cid
}
}
pub
fn
from_datagram
(
d
:
&
Datagram
remote_cid
:
ConnectionId
)
-
>
Self
{
Self
{
local
:
d
.
destination
(
)
remote
:
d
.
source
(
)
local_cids
:
Vec
:
:
new
(
)
remote_cid
}
}
pub
fn
received_on
(
&
self
d
:
&
Datagram
)
-
>
bool
{
self
.
local
=
=
d
.
destination
(
)
&
&
self
.
remote
=
=
d
.
source
(
)
}
pub
fn
mtu
(
&
self
)
-
>
usize
{
if
self
.
local
.
is_ipv4
(
)
{
PATH_MTU_V4
}
else
{
PATH_MTU_V6
}
}
pub
fn
add_local_cid
(
&
mut
self
cid
:
ConnectionId
)
{
self
.
local_cids
.
push
(
cid
)
;
}
pub
fn
valid_local_cid
(
&
self
cid
:
&
ConnectionIdRef
)
-
>
bool
{
self
.
local_cids
.
iter
(
)
.
any
(
|
c
|
c
=
=
cid
)
}
pub
fn
local_cid
(
&
self
)
-
>
&
ConnectionId
{
self
.
local_cids
.
first
(
)
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
set_remote_cid
(
&
mut
self
cid
:
&
ConnectionIdRef
)
{
self
.
remote_cid
=
ConnectionId
:
:
from
(
cid
)
;
}
pub
fn
remote_cid
(
&
self
)
-
>
&
ConnectionId
{
&
self
.
remote_cid
}
pub
fn
datagram
<
V
:
Into
<
Vec
<
u8
>
>
>
(
&
self
payload
:
V
)
-
>
Datagram
{
Datagram
:
:
new
(
self
.
local
self
.
remote
payload
)
}
}
