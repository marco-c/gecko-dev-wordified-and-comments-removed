#
!
[
allow
(
clippy
:
:
module_name_repetitions
)
]
use
std
:
:
{
cell
:
:
RefCell
fmt
:
:
{
self
Display
}
net
:
:
SocketAddr
rc
:
:
Rc
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
{
hex
qdebug
qinfo
qlog
:
:
NeqoQlog
qtrace
qwarn
Datagram
Encoder
IpTos
IpTosEcn
}
;
use
neqo_crypto
:
:
random
;
use
crate
:
:
{
ackrate
:
:
{
AckRate
PeerAckDelay
}
cc
:
:
CongestionControlAlgorithm
cid
:
:
{
ConnectionId
ConnectionIdRef
ConnectionIdStore
RemoteConnectionIdEntry
}
ecn
frame
:
:
{
FRAME_TYPE_PATH_CHALLENGE
FRAME_TYPE_PATH_RESPONSE
FRAME_TYPE_RETIRE_CONNECTION_ID
}
packet
:
:
PacketBuilder
pmtud
:
:
Pmtud
recovery
:
:
{
RecoveryToken
SentPacket
}
rtt
:
:
{
RttEstimate
RttSource
}
sender
:
:
PacketSender
stats
:
:
FrameStats
Stats
}
;
pub
const
MAX_PATH_PROBES
:
usize
=
3
;
const
MAX_PATHS
:
usize
=
15
;
pub
type
PathRef
=
Rc
<
RefCell
<
Path
>
>
;
#
[
derive
(
Debug
Default
)
]
pub
struct
Paths
{
#
[
allow
(
clippy
:
:
struct_field_names
)
]
paths
:
Vec
<
PathRef
>
primary
:
Option
<
PathRef
>
migration_target
:
Option
<
PathRef
>
to_retire
:
Vec
<
u64
>
qlog
:
NeqoQlog
}
impl
Paths
{
pub
fn
find_path
(
&
self
local
:
SocketAddr
remote
:
SocketAddr
cc
:
CongestionControlAlgorithm
pacing
:
bool
now
:
Instant
stats
:
&
mut
Stats
)
-
>
PathRef
{
self
.
paths
.
iter
(
)
.
find_map
(
|
p
|
p
.
borrow
(
)
.
received_on
(
local
remote
)
.
then
(
|
|
Rc
:
:
clone
(
p
)
)
)
.
unwrap_or_else
(
|
|
{
let
mut
p
=
Path
:
:
temporary
(
local
remote
cc
pacing
self
.
qlog
.
clone
(
)
now
stats
)
;
if
let
Some
(
primary
)
=
self
.
primary
.
as_ref
(
)
{
p
.
prime_rtt
(
primary
.
borrow
(
)
.
rtt
(
)
)
;
}
Rc
:
:
new
(
RefCell
:
:
new
(
p
)
)
}
)
}
pub
fn
primary
(
&
self
)
-
>
Option
<
PathRef
>
{
self
.
primary
.
clone
(
)
}
pub
fn
is_temporary
(
&
self
path
:
&
PathRef
)
-
>
bool
{
path
.
borrow
(
)
.
is_temporary
(
)
|
|
!
self
.
paths
.
iter
(
)
.
any
(
|
p
|
Rc
:
:
ptr_eq
(
p
path
)
)
}
fn
retire
(
to_retire
:
&
mut
Vec
<
u64
>
retired
:
&
PathRef
)
{
if
let
Some
(
cid
)
=
&
retired
.
borrow
(
)
.
remote_cid
{
let
seqno
=
cid
.
sequence_number
(
)
;
if
cid
.
connection_id
(
)
.
is_empty
(
)
{
qdebug
!
(
"
Connection
ID
{
seqno
}
is
zero
-
length
not
retiring
"
)
;
}
else
{
to_retire
.
push
(
seqno
)
;
}
}
}
pub
fn
make_permanent
(
&
mut
self
path
:
&
PathRef
local_cid
:
Option
<
ConnectionId
>
remote_cid
:
RemoteConnectionIdEntry
now
:
Instant
)
{
debug_assert
!
(
self
.
is_temporary
(
path
)
)
;
if
self
.
paths
.
len
(
)
>
=
MAX_PATHS
{
debug_assert_eq
!
(
self
.
paths
.
len
(
)
MAX_PATHS
)
;
let
removed
=
self
.
paths
.
remove
(
1
)
;
Self
:
:
retire
(
&
mut
self
.
to_retire
&
removed
)
;
if
self
.
migration_target
.
as_ref
(
)
.
is_some_and
(
|
target
|
Rc
:
:
ptr_eq
(
target
&
removed
)
)
{
qinfo
!
(
"
[
{
}
]
The
migration
target
path
had
to
be
removed
"
path
.
borrow
(
)
)
;
self
.
migration_target
=
None
;
}
debug_assert_eq
!
(
Rc
:
:
strong_count
(
&
removed
)
1
)
;
}
qdebug
!
(
"
[
{
}
]
Make
permanent
"
path
.
borrow
(
)
)
;
path
.
borrow_mut
(
)
.
make_permanent
(
local_cid
remote_cid
)
;
self
.
paths
.
push
(
Rc
:
:
clone
(
path
)
)
;
if
self
.
primary
.
is_none
(
)
{
assert
!
(
self
.
select_primary
(
path
now
)
.
is_none
(
)
)
;
}
}
#
[
must_use
]
fn
select_primary
(
&
mut
self
path
:
&
PathRef
now
:
Instant
)
-
>
Option
<
PathRef
>
{
qdebug
!
(
"
[
{
}
]
set
as
primary
path
"
path
.
borrow
(
)
)
;
let
old_path
=
self
.
primary
.
replace
(
Rc
:
:
clone
(
path
)
)
.
inspect
(
|
old
|
{
old
.
borrow_mut
(
)
.
set_primary
(
false
now
)
;
}
)
;
let
idx
=
self
.
paths
.
iter
(
)
.
enumerate
(
)
.
find_map
(
|
(
i
p
)
|
Rc
:
:
ptr_eq
(
p
path
)
.
then_some
(
i
)
)
.
expect
(
"
migration
target
should
be
permanent
"
)
;
self
.
paths
.
swap
(
0
idx
)
;
path
.
borrow_mut
(
)
.
set_primary
(
true
now
)
;
old_path
}
pub
fn
migrate
(
&
mut
self
path
:
&
PathRef
force
:
bool
now
:
Instant
stats
:
&
mut
Stats
)
-
>
bool
{
debug_assert
!
(
!
self
.
is_temporary
(
path
)
)
;
let
baseline
=
self
.
primary
(
)
.
map_or_else
(
|
|
ecn
:
:
Info
:
:
default
(
)
.
baseline
(
)
|
p
|
p
.
borrow
(
)
.
ecn_info
.
baseline
(
)
)
;
path
.
borrow_mut
(
)
.
set_ecn_baseline
(
baseline
)
;
if
force
|
|
path
.
borrow
(
)
.
is_valid
(
)
{
path
.
borrow_mut
(
)
.
set_valid
(
now
)
;
drop
(
self
.
select_primary
(
path
now
)
)
;
self
.
migration_target
=
None
;
}
else
{
self
.
migration_target
=
Some
(
Rc
:
:
clone
(
path
)
)
;
}
path
.
borrow_mut
(
)
.
probe
(
stats
)
;
self
.
migration_target
.
is_none
(
)
}
pub
fn
process_timeout
(
&
mut
self
now
:
Instant
pto
:
Duration
stats
:
&
mut
Stats
)
-
>
bool
{
let
to_retire
=
&
mut
self
.
to_retire
;
let
mut
primary_failed
=
false
;
self
.
paths
.
retain
(
|
p
|
{
if
p
.
borrow_mut
(
)
.
process_timeout
(
now
pto
stats
)
{
true
}
else
{
qdebug
!
(
"
[
{
}
]
Retiring
path
"
p
.
borrow
(
)
)
;
if
p
.
borrow
(
)
.
is_primary
(
)
{
primary_failed
=
true
;
}
Self
:
:
retire
(
to_retire
p
)
;
false
}
}
)
;
if
primary_failed
{
self
.
primary
=
None
;
#
[
allow
(
clippy
:
:
option_if_let_else
)
]
if
let
Some
(
fallback
)
=
self
.
paths
.
iter
(
)
.
rev
(
)
.
find
(
|
p
|
p
.
borrow
(
)
.
is_valid
(
)
)
{
let
path
=
Rc
:
:
clone
(
fallback
)
;
qinfo
!
(
"
[
{
}
]
Failing
over
after
primary
path
failed
"
path
.
borrow
(
)
)
;
drop
(
self
.
select_primary
(
&
path
now
)
)
;
true
}
else
{
false
}
}
else
{
if
let
Some
(
path
)
=
self
.
primary
(
)
{
path
.
borrow_mut
(
)
.
pmtud_mut
(
)
.
maybe_fire_raise_timer
(
now
stats
)
;
}
true
}
}
pub
fn
next_timeout
(
&
self
pto
:
Duration
)
-
>
Option
<
Instant
>
{
self
.
paths
.
iter
(
)
.
filter_map
(
|
p
|
p
.
borrow
(
)
.
next_timeout
(
pto
)
)
.
min
(
)
}
pub
fn
handle_migration
(
&
mut
self
path
:
&
PathRef
remote
:
SocketAddr
now
:
Instant
stats
:
&
mut
Stats
)
{
path
.
borrow_mut
(
)
.
update_port
(
remote
.
port
(
)
)
;
if
path
.
borrow
(
)
.
is_primary
(
)
{
path
.
borrow_mut
(
)
.
update
(
now
)
;
return
;
}
if
let
Some
(
old_path
)
=
self
.
select_primary
(
path
now
)
{
old_path
.
borrow_mut
(
)
.
probe
(
stats
)
;
}
}
pub
fn
select_path
(
&
self
)
-
>
Option
<
PathRef
>
{
self
.
paths
.
iter
(
)
.
find_map
(
|
p
|
p
.
borrow
(
)
.
has_probe
(
)
.
then
(
|
|
Rc
:
:
clone
(
p
)
)
)
.
or_else
(
|
|
self
.
primary
.
clone
(
)
)
}
#
[
must_use
]
pub
fn
path_response
(
&
mut
self
response
:
[
u8
;
8
]
now
:
Instant
stats
:
&
mut
Stats
)
-
>
bool
{
for
p
in
&
self
.
paths
{
if
p
.
borrow_mut
(
)
.
path_response
(
response
now
stats
)
{
if
self
.
migration_target
.
as_ref
(
)
.
is_some_and
(
|
target
|
Rc
:
:
ptr_eq
(
target
p
)
)
{
let
primary
=
self
.
migration_target
.
take
(
)
;
drop
(
self
.
select_primary
(
&
primary
.
unwrap
(
)
now
)
)
;
return
true
;
}
break
;
}
}
false
}
pub
fn
retire_cids
(
&
mut
self
retire_prior
:
u64
store
:
&
mut
ConnectionIdStore
<
[
u8
;
16
]
>
)
{
let
to_retire
=
&
mut
self
.
to_retire
;
let
migration_target
=
&
mut
self
.
migration_target
;
let
mut
retired
=
store
.
retire_prior_to
(
retire_prior
)
;
to_retire
.
append
(
&
mut
retired
)
;
self
.
paths
.
retain
(
|
p
|
{
let
mut
path
=
p
.
borrow_mut
(
)
;
let
current
=
path
.
remote_cid
.
as_ref
(
)
.
unwrap
(
)
;
if
current
.
sequence_number
(
)
<
retire_prior
&
&
!
current
.
connection_id
(
)
.
is_empty
(
)
{
to_retire
.
push
(
current
.
sequence_number
(
)
)
;
let
new_cid
=
store
.
next
(
)
;
let
has_replacement
=
new_cid
.
is_some
(
)
;
debug_assert
!
(
!
path
.
is_primary
(
)
|
|
has_replacement
)
;
path
.
remote_cid
=
new_cid
;
if
!
has_replacement
&
&
migration_target
.
as_ref
(
)
.
is_some_and
(
|
target
|
Rc
:
:
ptr_eq
(
target
p
)
)
{
qinfo
!
(
"
[
{
path
}
]
NEW_CONNECTION_ID
with
Retire
Prior
To
forced
migration
to
fail
"
)
;
*
migration_target
=
None
;
}
has_replacement
}
else
{
true
}
}
)
;
}
pub
fn
write_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
while
let
Some
(
seqno
)
=
self
.
to_retire
.
pop
(
)
{
if
builder
.
remaining
(
)
<
1
+
Encoder
:
:
varint_len
(
seqno
)
{
self
.
to_retire
.
push
(
seqno
)
;
break
;
}
builder
.
encode_varint
(
FRAME_TYPE_RETIRE_CONNECTION_ID
)
;
builder
.
encode_varint
(
seqno
)
;
tokens
.
push
(
RecoveryToken
:
:
RetireConnectionId
(
seqno
)
)
;
stats
.
retire_connection_id
+
=
1
;
}
if
let
Some
(
path
)
=
self
.
primary
(
)
{
path
.
borrow_mut
(
)
.
write_cc_frames
(
builder
tokens
stats
)
;
}
}
pub
fn
lost_retire_cid
(
&
mut
self
lost
:
u64
)
{
self
.
to_retire
.
push
(
lost
)
;
}
pub
fn
acked_retire_cid
(
&
mut
self
acked
:
u64
)
{
self
.
to_retire
.
retain
(
|
&
seqno
|
seqno
!
=
acked
)
;
}
pub
fn
lost_ack_frequency
(
&
self
lost
:
&
AckRate
)
{
if
let
Some
(
path
)
=
self
.
primary
(
)
{
path
.
borrow_mut
(
)
.
lost_ack_frequency
(
lost
)
;
}
}
pub
fn
acked_ack_frequency
(
&
self
acked
:
&
AckRate
)
{
if
let
Some
(
path
)
=
self
.
primary
(
)
{
path
.
borrow_mut
(
)
.
acked_ack_frequency
(
acked
)
;
}
}
#
[
cfg
(
test
)
]
pub
fn
rtt
(
&
self
)
-
>
Duration
{
self
.
primary
(
)
.
map_or_else
(
|
|
RttEstimate
:
:
default
(
)
.
estimate
(
)
|
p
|
p
.
borrow
(
)
.
rtt
(
)
.
estimate
(
)
)
}
pub
fn
set_qlog
(
&
mut
self
qlog
:
NeqoQlog
)
{
for
p
in
&
mut
self
.
paths
{
p
.
borrow_mut
(
)
.
set_qlog
(
qlog
.
clone
(
)
)
;
}
self
.
qlog
=
qlog
;
}
}
#
[
derive
(
Debug
)
]
enum
ProbeState
{
Valid
ProbeNeeded
{
probe_count
:
usize
}
Probing
{
probe_count
:
usize
data
:
[
u8
;
8
]
mtu
:
bool
sent
:
Instant
}
Failed
}
impl
ProbeState
{
const
fn
probe_needed
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
ProbeNeeded
{
.
.
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Path
{
local
:
SocketAddr
remote
:
SocketAddr
local_cid
:
Option
<
ConnectionId
>
remote_cid
:
Option
<
RemoteConnectionIdEntry
>
primary
:
bool
state
:
ProbeState
validated
:
Option
<
Instant
>
challenge
:
Option
<
[
u8
;
8
]
>
rtt
:
RttEstimate
sender
:
PacketSender
received_bytes
:
usize
sent_bytes
:
usize
ecn_info
:
ecn
:
:
Info
qlog
:
NeqoQlog
}
impl
Path
{
pub
fn
temporary
(
local
:
SocketAddr
remote
:
SocketAddr
cc
:
CongestionControlAlgorithm
pacing
:
bool
qlog
:
NeqoQlog
now
:
Instant
stats
:
&
mut
Stats
)
-
>
Self
{
let
iface_mtu
=
match
mtu
:
:
interface_and_mtu
(
remote
.
ip
(
)
)
{
Ok
(
(
name
mtu
)
)
=
>
{
qdebug
!
(
"
Outbound
interface
{
name
}
has
MTU
{
mtu
}
"
)
;
stats
.
pmtud_iface_mtu
=
mtu
;
Some
(
mtu
)
}
Err
(
e
)
=
>
{
qwarn
!
(
"
Failed
to
determine
outbound
interface
:
{
e
}
"
)
;
None
}
}
;
let
mut
sender
=
PacketSender
:
:
new
(
cc
pacing
Pmtud
:
:
new
(
remote
.
ip
(
)
iface_mtu
)
now
)
;
sender
.
set_qlog
(
qlog
.
clone
(
)
)
;
Self
{
local
remote
local_cid
:
None
remote_cid
:
None
primary
:
false
state
:
ProbeState
:
:
ProbeNeeded
{
probe_count
:
0
}
validated
:
None
challenge
:
None
rtt
:
RttEstimate
:
:
default
(
)
sender
received_bytes
:
0
sent_bytes
:
0
ecn_info
:
ecn
:
:
Info
:
:
default
(
)
qlog
}
}
pub
fn
set_ecn_baseline
(
&
mut
self
baseline
:
ecn
:
:
Count
)
{
self
.
ecn_info
.
set_baseline
(
baseline
)
;
}
pub
fn
tos
(
&
self
)
-
>
IpTos
{
self
.
ecn_info
.
ecn_mark
(
)
.
into
(
)
}
pub
const
fn
is_primary
(
&
self
)
-
>
bool
{
self
.
primary
}
pub
const
fn
is_temporary
(
&
self
)
-
>
bool
{
self
.
remote_cid
.
is_none
(
)
}
pub
(
crate
)
fn
make_permanent
(
&
mut
self
local_cid
:
Option
<
ConnectionId
>
remote_cid
:
RemoteConnectionIdEntry
)
{
if
self
.
local_cid
.
is_none
(
)
{
self
.
local_cid
=
local_cid
;
}
self
.
remote_cid
.
replace
(
remote_cid
)
;
}
fn
received_on
(
&
self
local
:
SocketAddr
remote
:
SocketAddr
)
-
>
bool
{
self
.
local
=
=
local
&
&
self
.
remote
=
=
remote
}
fn
update_port
(
&
mut
self
port
:
u16
)
{
self
.
remote
.
set_port
(
port
)
;
}
pub
(
crate
)
fn
set_primary
(
&
mut
self
primary
:
bool
now
:
Instant
)
{
qtrace
!
(
"
[
{
self
}
]
Make
primary
{
primary
}
"
)
;
debug_assert
!
(
self
.
remote_cid
.
is_some
(
)
)
;
self
.
primary
=
primary
;
if
!
primary
{
self
.
sender
.
discard_in_flight
(
now
)
;
}
}
pub
fn
set_valid
(
&
mut
self
now
:
Instant
)
{
qdebug
!
(
"
[
{
self
}
]
Path
validated
{
now
:
?
}
"
)
;
self
.
state
=
ProbeState
:
:
Valid
;
self
.
validated
=
Some
(
now
)
;
}
pub
fn
update
(
&
mut
self
now
:
Instant
)
{
if
self
.
validated
.
is_some
(
)
{
self
.
validated
=
Some
(
now
)
;
}
}
pub
fn
plpmtu
(
&
self
)
-
>
usize
{
self
.
pmtud
(
)
.
plpmtu
(
)
}
pub
fn
pmtud
(
&
self
)
-
>
&
Pmtud
{
self
.
sender
.
pmtud
(
)
}
pub
const
fn
local_cid
(
&
self
)
-
>
Option
<
&
ConnectionId
>
{
self
.
local_cid
.
as_ref
(
)
}
pub
fn
set_remote_cid
(
&
mut
self
cid
:
ConnectionIdRef
)
{
self
.
remote_cid
.
as_mut
(
)
.
unwrap
(
)
.
update_cid
(
ConnectionId
:
:
from
(
cid
)
)
;
}
pub
fn
remote_cid
(
&
self
)
-
>
Option
<
&
ConnectionId
>
{
self
.
remote_cid
.
as_ref
(
)
.
map
(
super
:
:
cid
:
:
ConnectionIdEntry
:
:
connection_id
)
}
pub
fn
set_reset_token
(
&
mut
self
token
:
[
u8
;
16
]
)
{
self
.
remote_cid
.
as_mut
(
)
.
unwrap
(
)
.
set_stateless_reset_token
(
token
)
;
}
pub
fn
is_stateless_reset
(
&
self
token
:
&
[
u8
;
16
]
)
-
>
bool
{
self
.
remote_cid
.
as_ref
(
)
.
is_some_and
(
|
rcid
|
rcid
.
is_stateless_reset
(
token
)
)
}
pub
fn
datagram
<
V
:
Into
<
Vec
<
u8
>
>
>
(
&
mut
self
payload
:
V
stats
:
&
mut
Stats
)
-
>
Datagram
{
let
tos
=
self
.
tos
(
)
;
self
.
ecn_info
.
on_packet_sent
(
stats
)
;
Datagram
:
:
new
(
self
.
local
self
.
remote
tos
payload
.
into
(
)
)
}
pub
const
fn
local_address
(
&
self
)
-
>
SocketAddr
{
self
.
local
}
pub
const
fn
remote_address
(
&
self
)
-
>
SocketAddr
{
self
.
remote
}
pub
const
fn
is_valid
(
&
self
)
-
>
bool
{
self
.
validated
.
is_some
(
)
}
pub
fn
path_response
(
&
mut
self
response
:
[
u8
;
8
]
now
:
Instant
stats
:
&
mut
Stats
)
-
>
bool
{
if
let
ProbeState
:
:
Probing
{
data
mtu
.
.
}
=
&
mut
self
.
state
{
if
response
=
=
*
data
{
let
need_full_probe
=
!
*
mtu
;
self
.
set_valid
(
now
)
;
if
need_full_probe
{
qdebug
!
(
"
[
{
self
}
]
Sub
-
MTU
probe
successful
reset
probe
count
"
)
;
self
.
probe
(
stats
)
;
}
true
}
else
{
false
}
}
else
{
false
}
}
pub
fn
challenged
(
&
mut
self
challenge
:
[
u8
;
8
]
)
{
self
.
challenge
=
Some
(
challenge
.
to_owned
(
)
)
;
}
fn
probe
(
&
mut
self
stats
:
&
mut
Stats
)
{
let
probe_count
=
match
&
self
.
state
{
ProbeState
:
:
Probing
{
probe_count
.
.
}
=
>
*
probe_count
+
1
ProbeState
:
:
ProbeNeeded
{
probe_count
.
.
}
=
>
*
probe_count
_
=
>
0
}
;
self
.
state
=
if
probe_count
>
=
MAX_PATH_PROBES
{
if
self
.
ecn_info
.
ecn_mark
(
)
=
=
IpTosEcn
:
:
Ect0
{
qinfo
!
(
"
[
{
self
}
]
Possible
ECN
blackhole
disabling
ECN
and
re
-
probing
path
"
)
;
self
.
ecn_info
.
disable_ecn
(
stats
crate
:
:
ecn
:
:
ValidationError
:
:
BlackHole
)
;
ProbeState
:
:
ProbeNeeded
{
probe_count
:
0
}
}
else
{
qinfo
!
(
"
[
{
self
}
]
Probing
failed
"
)
;
ProbeState
:
:
Failed
}
}
else
{
qdebug
!
(
"
[
{
self
}
]
Initiating
probe
"
)
;
ProbeState
:
:
ProbeNeeded
{
probe_count
}
}
;
}
pub
const
fn
has_probe
(
&
self
)
-
>
bool
{
self
.
challenge
.
is_some
(
)
|
|
self
.
state
.
probe_needed
(
)
}
pub
fn
write_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
stats
:
&
mut
FrameStats
mtu
:
bool
now
:
Instant
)
-
>
bool
{
if
builder
.
remaining
(
)
<
9
{
return
false
;
}
let
resp_sent
=
if
let
Some
(
challenge
)
=
self
.
challenge
.
take
(
)
{
qtrace
!
(
"
[
{
self
}
]
Responding
to
path
challenge
{
}
"
hex
(
challenge
)
)
;
builder
.
encode_varint
(
FRAME_TYPE_PATH_RESPONSE
)
;
builder
.
encode
(
&
challenge
[
.
.
]
)
;
stats
.
path_response
+
=
1
;
if
builder
.
remaining
(
)
<
9
{
return
true
;
}
true
}
else
{
false
}
;
if
let
ProbeState
:
:
ProbeNeeded
{
probe_count
}
=
self
.
state
{
qtrace
!
(
"
[
{
self
}
]
Initiating
path
challenge
{
probe_count
}
"
)
;
let
data
=
random
:
:
<
8
>
(
)
;
builder
.
encode_varint
(
FRAME_TYPE_PATH_CHALLENGE
)
;
builder
.
encode
(
&
data
)
;
stats
.
path_challenge
+
=
1
;
self
.
state
=
ProbeState
:
:
Probing
{
probe_count
data
mtu
sent
:
now
}
;
true
}
else
{
resp_sent
}
}
pub
fn
write_cc_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
self
.
rtt
.
write_frames
(
builder
tokens
stats
)
;
}
pub
fn
lost_ack_frequency
(
&
mut
self
lost
:
&
AckRate
)
{
self
.
rtt
.
frame_lost
(
lost
)
;
}
pub
fn
acked_ack_frequency
(
&
mut
self
acked
:
&
AckRate
)
{
self
.
rtt
.
frame_acked
(
acked
)
;
}
pub
fn
process_timeout
(
&
mut
self
now
:
Instant
pto
:
Duration
stats
:
&
mut
Stats
)
-
>
bool
{
if
let
ProbeState
:
:
Probing
{
sent
.
.
}
=
&
self
.
state
{
if
now
>
=
*
sent
+
pto
{
self
.
probe
(
stats
)
;
}
}
if
matches
!
(
self
.
state
ProbeState
:
:
Failed
)
{
false
}
else
if
self
.
primary
{
true
}
else
if
matches
!
(
self
.
state
ProbeState
:
:
Valid
)
{
let
count
=
u32
:
:
try_from
(
2
*
MAX_PATH_PROBES
+
1
)
.
unwrap
(
)
;
self
.
validated
.
unwrap
(
)
+
(
pto
*
count
)
>
now
}
else
{
true
}
}
pub
fn
next_timeout
(
&
self
pto
:
Duration
)
-
>
Option
<
Instant
>
{
if
let
ProbeState
:
:
Probing
{
sent
.
.
}
=
&
self
.
state
{
Some
(
*
sent
+
pto
)
}
else
{
None
}
}
pub
const
fn
rtt
(
&
self
)
-
>
&
RttEstimate
{
&
self
.
rtt
}
pub
fn
rtt_mut
(
&
mut
self
)
-
>
&
mut
RttEstimate
{
&
mut
self
.
rtt
}
pub
fn
pmtud_mut
(
&
mut
self
)
-
>
&
mut
Pmtud
{
self
.
sender
.
pmtud_mut
(
)
}
pub
const
fn
sender
(
&
self
)
-
>
&
PacketSender
{
&
self
.
sender
}
pub
fn
set_ack_delay
(
&
mut
self
max_ack_delay
:
Duration
min_ack_delay
:
Option
<
Duration
>
ack_ratio
:
u8
)
{
let
ack_delay
=
min_ack_delay
.
map_or_else
(
|
|
PeerAckDelay
:
:
fixed
(
max_ack_delay
)
|
m
|
{
PeerAckDelay
:
:
flexible
(
max_ack_delay
m
ack_ratio
self
.
sender
.
cwnd
(
)
self
.
plpmtu
(
)
self
.
rtt
.
estimate
(
)
)
}
)
;
self
.
rtt
.
set_ack_delay
(
ack_delay
)
;
}
pub
fn
prime_rtt
(
&
mut
self
rtt
:
&
RttEstimate
)
{
self
.
rtt
.
prime_rtt
(
rtt
)
;
}
pub
fn
add_received
(
&
mut
self
count
:
usize
)
{
self
.
received_bytes
=
self
.
received_bytes
.
saturating_add
(
count
)
;
}
pub
fn
add_sent
(
&
mut
self
count
:
usize
)
{
self
.
sent_bytes
=
self
.
sent_bytes
.
saturating_add
(
count
)
;
}
pub
fn
packet_sent
(
&
mut
self
sent
:
&
mut
SentPacket
now
:
Instant
)
{
if
!
self
.
is_primary
(
)
{
sent
.
clear_primary_path
(
)
;
}
self
.
sender
.
on_packet_sent
(
sent
self
.
rtt
.
estimate
(
)
now
)
;
}
pub
fn
discard_packet
(
&
mut
self
sent
:
&
SentPacket
now
:
Instant
stats
:
&
mut
Stats
)
{
if
self
.
rtt
.
first_sample_time
(
)
.
is_none
(
)
{
qinfo
!
(
"
[
{
self
}
]
discarding
a
packet
without
an
RTT
estimate
;
guessing
RTT
=
{
:
?
}
"
now
-
sent
.
time_sent
(
)
)
;
stats
.
rtt_init_guess
=
true
;
self
.
rtt
.
update
(
&
self
.
qlog
now
-
sent
.
time_sent
(
)
Duration
:
:
new
(
0
0
)
RttSource
:
:
Guesstimate
now
)
;
}
self
.
sender
.
discard
(
sent
now
)
;
}
pub
fn
on_packets_acked
(
&
mut
self
acked_pkts
:
&
[
SentPacket
]
ack_ecn
:
Option
<
ecn
:
:
Count
>
now
:
Instant
stats
:
&
mut
Stats
)
{
debug_assert
!
(
self
.
is_primary
(
)
)
;
let
ecn_ce_received
=
self
.
ecn_info
.
on_packets_acked
(
acked_pkts
ack_ecn
stats
)
;
if
ecn_ce_received
{
let
cwnd_reduced
=
self
.
sender
.
on_ecn_ce_received
(
acked_pkts
.
first
(
)
.
expect
(
"
must
be
there
"
)
now
)
;
if
cwnd_reduced
{
self
.
rtt
.
update_ack_delay
(
self
.
sender
.
cwnd
(
)
self
.
plpmtu
(
)
)
;
}
}
self
.
sender
.
on_packets_acked
(
acked_pkts
&
self
.
rtt
now
stats
)
;
}
pub
fn
on_packets_lost
(
&
mut
self
prev_largest_acked_sent
:
Option
<
Instant
>
confirmed
:
bool
lost_packets
:
&
[
SentPacket
]
stats
:
&
mut
Stats
now
:
Instant
)
{
debug_assert
!
(
self
.
is_primary
(
)
)
;
self
.
ecn_info
.
on_packets_lost
(
lost_packets
stats
)
;
let
cwnd_reduced
=
self
.
sender
.
on_packets_lost
(
self
.
rtt
.
first_sample_time
(
)
prev_largest_acked_sent
self
.
rtt
.
pto
(
confirmed
)
lost_packets
stats
now
)
;
if
cwnd_reduced
{
self
.
rtt
.
update_ack_delay
(
self
.
sender
.
cwnd
(
)
self
.
plpmtu
(
)
)
;
}
}
pub
fn
pto_possible
(
&
self
)
-
>
bool
{
self
.
amplification_limit
(
)
>
=
self
.
plpmtu
(
)
}
pub
fn
amplification_limit
(
&
self
)
-
>
usize
{
if
matches
!
(
self
.
state
ProbeState
:
:
Failed
)
{
0
}
else
if
self
.
is_valid
(
)
{
usize
:
:
MAX
}
else
{
self
.
received_bytes
.
checked_mul
(
3
)
.
map_or
(
usize
:
:
MAX
|
limit
|
{
let
budget
=
if
limit
=
=
0
{
self
.
plpmtu
(
)
*
5
}
else
{
limit
}
;
budget
.
saturating_sub
(
self
.
sent_bytes
)
}
)
}
}
pub
fn
set_qlog
(
&
mut
self
qlog
:
NeqoQlog
)
{
self
.
sender
.
set_qlog
(
qlog
)
;
}
}
impl
Display
for
Path
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
is_primary
(
)
{
write
!
(
f
"
pri
-
"
)
?
;
}
if
!
self
.
is_valid
(
)
{
write
!
(
f
"
unv
-
"
)
?
;
}
write
!
(
f
"
path
"
)
?
;
if
let
Some
(
entry
)
=
self
.
remote_cid
.
as_ref
(
)
{
write
!
(
f
"
:
{
}
"
entry
.
connection_id
(
)
)
?
;
}
write
!
(
f
"
{
}
-
>
{
}
"
self
.
local
self
.
remote
)
?
;
Ok
(
(
)
)
}
}
