use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
mem
;
use
neqo_common
:
:
{
qinfo
qtrace
qwarn
Encoder
}
;
use
crate
:
:
frame
:
:
{
Frame
StreamType
}
;
use
crate
:
:
recovery
:
:
RecoveryToken
;
use
crate
:
:
recv_stream
:
:
RecvStreams
;
use
crate
:
:
send_stream
:
:
SendStreams
;
use
crate
:
:
stream_id
:
:
{
StreamId
StreamIndex
StreamIndexes
}
;
use
crate
:
:
tracking
:
:
PNSpace
;
use
crate
:
:
AppError
;
pub
type
FlowControlRecoveryToken
=
Frame
;
#
[
derive
(
Debug
Default
)
]
pub
struct
FlowMgr
{
from_conn
:
HashMap
<
mem
:
:
Discriminant
<
Frame
>
Frame
>
from_streams
:
HashMap
<
(
StreamId
mem
:
:
Discriminant
<
Frame
>
)
Frame
>
from_stream_types
:
HashMap
<
(
StreamType
mem
:
:
Discriminant
<
Frame
>
)
Frame
>
used_data
:
u64
max_data
:
u64
}
impl
FlowMgr
{
pub
fn
conn_credit_avail
(
&
self
)
-
>
u64
{
self
.
max_data
-
self
.
used_data
}
pub
fn
conn_increase_credit_used
(
&
mut
self
amount
:
u64
)
{
self
.
used_data
+
=
amount
;
assert
!
(
self
.
used_data
<
=
self
.
max_data
)
}
pub
fn
conn_increase_max_credit
(
&
mut
self
new
:
u64
)
-
>
bool
{
if
new
>
self
.
max_data
{
self
.
max_data
=
new
;
const
DB_FRAME
:
Frame
=
Frame
:
:
DataBlocked
{
data_limit
:
0
}
;
self
.
from_conn
.
remove
(
&
mem
:
:
discriminant
(
&
DB_FRAME
)
)
;
true
}
else
{
false
}
}
pub
fn
data_blocked
(
&
mut
self
)
{
let
frame
=
Frame
:
:
DataBlocked
{
data_limit
:
self
.
max_data
}
;
self
.
from_conn
.
insert
(
mem
:
:
discriminant
(
&
frame
)
frame
)
;
}
pub
fn
path_response
(
&
mut
self
data
:
[
u8
;
8
]
)
{
let
frame
=
Frame
:
:
PathResponse
{
data
}
;
self
.
from_conn
.
insert
(
mem
:
:
discriminant
(
&
frame
)
frame
)
;
}
pub
fn
max_data
(
&
mut
self
maximum_data
:
u64
)
{
let
frame
=
Frame
:
:
MaxData
{
maximum_data
}
;
self
.
from_conn
.
insert
(
mem
:
:
discriminant
(
&
frame
)
frame
)
;
}
pub
fn
stream_reset
(
&
mut
self
stream_id
:
StreamId
application_error_code
:
AppError
final_size
:
u64
)
{
let
frame
=
Frame
:
:
ResetStream
{
stream_id
application_error_code
final_size
}
;
self
.
from_streams
.
insert
(
(
stream_id
mem
:
:
discriminant
(
&
frame
)
)
frame
)
;
}
pub
fn
stop_sending
(
&
mut
self
stream_id
:
StreamId
application_error_code
:
AppError
)
{
let
frame
=
Frame
:
:
StopSending
{
stream_id
application_error_code
}
;
self
.
from_streams
.
insert
(
(
stream_id
mem
:
:
discriminant
(
&
frame
)
)
frame
)
;
}
pub
fn
max_stream_data
(
&
mut
self
stream_id
:
StreamId
maximum_stream_data
:
u64
)
{
let
frame
=
Frame
:
:
MaxStreamData
{
stream_id
maximum_stream_data
}
;
self
.
from_streams
.
insert
(
(
stream_id
mem
:
:
discriminant
(
&
frame
)
)
frame
)
;
}
pub
fn
clear_max_stream_data
(
&
mut
self
stream_id
:
StreamId
)
{
let
frame
=
Frame
:
:
MaxStreamData
{
stream_id
maximum_stream_data
:
0
}
;
self
.
from_streams
.
remove
(
&
(
stream_id
mem
:
:
discriminant
(
&
frame
)
)
)
;
}
pub
fn
stream_data_blocked
(
&
mut
self
stream_id
:
StreamId
stream_data_limit
:
u64
)
{
let
frame
=
Frame
:
:
StreamDataBlocked
{
stream_id
stream_data_limit
}
;
self
.
from_streams
.
insert
(
(
stream_id
mem
:
:
discriminant
(
&
frame
)
)
frame
)
;
}
pub
fn
max_streams
(
&
mut
self
stream_limit
:
StreamIndex
stream_type
:
StreamType
)
{
let
frame
=
Frame
:
:
MaxStreams
{
stream_type
maximum_streams
:
stream_limit
}
;
self
.
from_stream_types
.
insert
(
(
stream_type
mem
:
:
discriminant
(
&
frame
)
)
frame
)
;
}
pub
fn
streams_blocked
(
&
mut
self
stream_limit
:
StreamIndex
stream_type
:
StreamType
)
{
let
frame
=
Frame
:
:
StreamsBlocked
{
stream_type
stream_limit
}
;
self
.
from_stream_types
.
insert
(
(
stream_type
mem
:
:
discriminant
(
&
frame
)
)
frame
)
;
}
pub
fn
peek
(
&
self
)
-
>
Option
<
&
Frame
>
{
if
let
Some
(
key
)
=
self
.
from_conn
.
keys
(
)
.
next
(
)
{
self
.
from_conn
.
get
(
key
)
}
else
if
let
Some
(
key
)
=
self
.
from_streams
.
keys
(
)
.
next
(
)
{
self
.
from_streams
.
get
(
key
)
}
else
if
let
Some
(
key
)
=
self
.
from_stream_types
.
keys
(
)
.
next
(
)
{
self
.
from_stream_types
.
get
(
key
)
}
else
{
None
}
}
pub
(
crate
)
fn
acked
(
&
mut
self
token
:
&
FlowControlRecoveryToken
send_streams
:
&
mut
SendStreams
)
{
const
RESET_STREAM
:
&
Frame
=
&
Frame
:
:
ResetStream
{
stream_id
:
StreamId
:
:
new
(
0
)
application_error_code
:
0
final_size
:
0
}
;
if
let
Frame
:
:
ResetStream
{
stream_id
.
.
}
=
token
{
qinfo
!
(
"
Reset
received
stream
=
{
}
"
stream_id
.
as_u64
(
)
)
;
if
self
.
from_streams
.
remove
(
&
(
*
stream_id
mem
:
:
discriminant
(
RESET_STREAM
)
)
)
.
is_some
(
)
{
qinfo
!
(
"
Removed
RESET_STREAM
frame
for
{
}
"
stream_id
.
as_u64
(
)
)
;
}
send_streams
.
reset_acked
(
*
stream_id
)
;
}
}
pub
(
crate
)
fn
lost
(
&
mut
self
token
:
&
FlowControlRecoveryToken
send_streams
:
&
mut
SendStreams
recv_streams
:
&
mut
RecvStreams
indexes
:
&
mut
StreamIndexes
)
{
match
*
token
{
Frame
:
:
ResetStream
{
stream_id
application_error_code
final_size
}
=
>
{
qinfo
!
(
"
Reset
lost
stream
=
{
}
err
=
{
}
final_size
=
{
}
"
stream_id
.
as_u64
(
)
application_error_code
final_size
)
;
if
send_streams
.
get
(
stream_id
)
.
is_ok
(
)
{
self
.
stream_reset
(
stream_id
application_error_code
final_size
)
;
}
}
Frame
:
:
MaxStreams
{
stream_type
.
.
}
=
>
{
let
local_max
=
match
stream_type
{
StreamType
:
:
BiDi
=
>
&
mut
indexes
.
local_max_stream_bidi
StreamType
:
:
UniDi
=
>
&
mut
indexes
.
local_max_stream_uni
}
;
self
.
max_streams
(
*
local_max
stream_type
)
}
Frame
:
:
DataBlocked
{
.
.
}
=
>
{
if
self
.
conn_credit_avail
(
)
=
=
0
{
self
.
data_blocked
(
)
}
}
Frame
:
:
StreamDataBlocked
{
stream_id
.
.
}
=
>
{
if
let
Ok
(
ss
)
=
send_streams
.
get
(
stream_id
)
{
if
ss
.
credit_avail
(
)
=
=
0
{
self
.
stream_data_blocked
(
stream_id
ss
.
max_stream_data
(
)
)
}
}
}
Frame
:
:
StreamsBlocked
{
stream_type
.
.
}
=
>
match
stream_type
{
StreamType
:
:
UniDi
=
>
{
if
indexes
.
remote_next_stream_uni
>
=
indexes
.
remote_max_stream_uni
{
self
.
streams_blocked
(
indexes
.
remote_max_stream_uni
StreamType
:
:
UniDi
)
;
}
}
StreamType
:
:
BiDi
=
>
{
if
indexes
.
remote_next_stream_bidi
>
=
indexes
.
remote_max_stream_bidi
{
self
.
streams_blocked
(
indexes
.
remote_max_stream_bidi
StreamType
:
:
BiDi
)
;
}
}
}
Frame
:
:
StopSending
{
stream_id
application_error_code
}
=
>
self
.
stop_sending
(
stream_id
application_error_code
)
Frame
:
:
MaxStreamData
{
stream_id
.
.
}
=
>
{
if
let
Some
(
rs
)
=
recv_streams
.
get_mut
(
&
stream_id
)
{
rs
.
flowc_lost
(
)
}
}
Frame
:
:
PathResponse
{
.
.
}
=
>
qinfo
!
(
"
Path
Response
lost
not
re
-
sent
"
)
_
=
>
qwarn
!
(
"
Unexpected
Flow
frame
{
:
?
}
lost
not
re
-
sent
"
token
)
}
}
pub
(
crate
)
fn
get_frame
(
&
mut
self
space
:
PNSpace
remaining
:
usize
)
-
>
Option
<
(
Frame
Option
<
RecoveryToken
>
)
>
{
if
space
!
=
PNSpace
:
:
ApplicationData
{
return
None
;
}
if
let
Some
(
frame
)
=
self
.
peek
(
)
{
let
mut
d
=
Encoder
:
:
default
(
)
;
frame
.
marshal
(
&
mut
d
)
;
if
d
.
len
(
)
>
remaining
{
qtrace
!
(
"
flowc
frame
doesn
'
t
fit
in
remaining
"
)
;
return
None
;
}
}
else
{
return
None
;
}
let
frame
=
self
.
next
(
)
.
expect
(
"
just
peeked
this
"
)
;
Some
(
(
frame
.
clone
(
)
Some
(
RecoveryToken
:
:
Flow
(
frame
)
)
)
)
}
}
impl
Iterator
for
FlowMgr
{
type
Item
=
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
Frame
>
{
let
first_key
=
self
.
from_conn
.
keys
(
)
.
next
(
)
;
if
let
Some
(
&
first_key
)
=
first_key
{
return
self
.
from_conn
.
remove
(
&
first_key
)
;
}
let
first_key
=
self
.
from_streams
.
keys
(
)
.
next
(
)
;
if
let
Some
(
&
first_key
)
=
first_key
{
return
self
.
from_streams
.
remove
(
&
first_key
)
;
}
let
first_key
=
self
.
from_stream_types
.
keys
(
)
.
next
(
)
;
if
let
Some
(
&
first_key
)
=
first_key
{
return
self
.
from_stream_types
.
remove
(
&
first_key
)
;
}
None
}
}
