use
std
:
:
ops
:
:
Range
;
use
neqo_common
:
:
{
qtrace
Decoder
}
;
#
[
must_use
]
pub
fn
find_sni
(
buf
:
&
[
u8
]
)
-
>
Option
<
Range
<
usize
>
>
{
#
[
must_use
]
fn
skip
(
dec
:
&
mut
Decoder
len
:
usize
)
-
>
Option
<
(
)
>
{
if
len
>
dec
.
remaining
(
)
{
return
None
;
}
dec
.
skip
(
len
)
;
Some
(
(
)
)
}
#
[
must_use
]
fn
skip_vec
<
T
>
(
dec
:
&
mut
Decoder
)
-
>
Option
<
(
)
>
where
T
:
TryFrom
<
u64
>
usize
:
TryFrom
<
T
>
{
let
len
=
dec
.
decode_uint
:
:
<
T
>
(
)
?
;
skip
(
dec
usize
:
:
try_from
(
len
)
.
ok
(
)
?
)
}
let
mut
dec
=
Decoder
:
:
from
(
buf
)
;
if
buf
.
is_empty
(
)
|
|
dec
.
decode_uint
:
:
<
u8
>
(
)
?
!
=
1
{
return
None
;
}
skip
(
&
mut
dec
3
+
2
+
32
)
?
;
skip_vec
:
:
<
u8
>
(
&
mut
dec
)
?
;
skip_vec
:
:
<
u16
>
(
&
mut
dec
)
?
;
skip_vec
:
:
<
u8
>
(
&
mut
dec
)
?
;
skip
(
&
mut
dec
2
)
?
;
while
dec
.
remaining
(
)
>
=
4
{
let
ext_type
:
u16
=
dec
.
decode_uint
(
)
?
;
let
ext_len
:
u16
=
dec
.
decode_uint
(
)
?
;
if
ext_type
=
=
0
{
let
sni_len
:
u16
=
dec
.
decode_uint
(
)
?
;
skip
(
&
mut
dec
3
)
?
;
let
start
=
dec
.
offset
(
)
;
let
end
=
start
+
usize
:
:
from
(
sni_len
)
-
3
;
if
end
>
dec
.
offset
(
)
+
dec
.
remaining
(
)
{
return
None
;
}
qtrace
!
(
"
SNI
range
{
start
}
.
.
{
end
}
:
{
:
?
}
"
String
:
:
from_utf8_lossy
(
&
buf
[
start
.
.
end
]
)
)
;
return
Some
(
start
.
.
end
)
;
}
skip
(
&
mut
dec
ext_len
.
into
(
)
)
?
;
}
None
}
#
[
cfg
(
test
)
]
mod
tests
{
const
BUF_WITH_SNI
:
&
[
u8
]
=
&
[
0x01
0x00
0x01
0xfc
0x03
0x03
0x0e
0x2d
0x03
0x37
0xd9
0x14
0x2b
0x32
0x4e
0xa8
0xcf
0x1f
0xfa
0x5b
0x6c
0xeb
0xdd
0x10
0xa6
0x49
0x6e
0xbf
0xe4
0x32
0x3d
0x0c
0xe4
0xbf
0x90
0xcf
0x08
0x42
0x00
0x00
0x08
0x13
0x01
0x13
0x03
0x13
0x02
0xca
0xca
0x01
0x00
0x01
0xcb
0xff
0x01
0x00
0x01
0x00
0x00
0x2d
0x00
0x03
0x02
0x01
0x87
0x00
0x00
0x00
0x0e
0x00
0x0c
0x00
0x00
0x09
0x6c
0x6f
0x63
0x61
0x6c
0x68
0x6f
0x73
0x74
0x00
0x05
0x00
0x05
0x01
0x00
0x00
0x00
0x00
]
;
#
[
test
]
fn
find_sni
(
)
{
let
range
=
super
:
:
find_sni
(
BUF_WITH_SNI
)
.
unwrap
(
)
;
let
expected_range
=
BUF_WITH_SNI
.
len
(
)
-
18
.
.
BUF_WITH_SNI
.
len
(
)
-
9
;
assert_eq
!
(
range
expected_range
)
;
assert_eq
!
(
&
BUF_WITH_SNI
[
range
]
b
"
localhost
"
)
;
}
#
[
test
]
fn
find_sni_no_sni
(
)
{
let
mut
buf
=
Vec
:
:
from
(
&
BUF_WITH_SNI
[
.
.
BUF_WITH_SNI
.
len
(
)
-
39
]
)
;
let
len
=
buf
.
len
(
)
;
assert
!
(
buf
[
len
-
2
]
=
=
0x01
&
&
buf
[
len
-
1
]
=
=
0xcb
)
;
buf
[
len
-
2
]
=
0x00
;
buf
[
len
-
1
]
=
0x00
;
assert
!
(
super
:
:
find_sni
(
&
buf
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
find_sni_invalid_sni
(
)
{
let
truncated
=
&
BUF_WITH_SNI
[
.
.
BUF_WITH_SNI
.
len
(
)
-
15
]
;
assert
!
(
super
:
:
find_sni
(
truncated
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
find_sni_no_ci
(
)
{
let
buf
=
[
0
;
1
]
;
assert
!
(
super
:
:
find_sni
(
&
buf
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
find_sni_malformed_ci
(
)
{
let
buf
=
[
1
;
1
]
;
assert
!
(
super
:
:
find_sni
(
&
buf
)
.
is_none
(
)
)
;
}
}
