use
std
:
:
{
cmp
:
:
min
fmt
:
:
{
Debug
Display
}
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
qtrace
;
use
crate
:
:
rtt
:
:
GRANULARITY
;
const
PACER_SPEEDUP
:
usize
=
2
;
pub
struct
Pacer
{
enabled
:
bool
t
:
Instant
m
:
usize
c
:
usize
p
:
usize
}
impl
Pacer
{
pub
fn
new
(
enabled
:
bool
now
:
Instant
m
:
usize
p
:
usize
)
-
>
Self
{
assert
!
(
m
>
=
p
"
maximum
capacity
has
to
be
at
least
one
packet
"
)
;
Self
{
enabled
t
:
now
m
c
:
m
p
}
}
pub
const
fn
mtu
(
&
self
)
-
>
usize
{
self
.
p
}
pub
fn
set_mtu
(
&
mut
self
mtu
:
usize
)
{
self
.
p
=
mtu
;
}
pub
fn
next
(
&
self
rtt
:
Duration
cwnd
:
usize
)
-
>
Instant
{
if
self
.
c
>
=
self
.
p
{
qtrace
!
(
[
self
]
"
next
{
cwnd
}
/
{
rtt
:
?
}
no
wait
=
{
:
?
}
"
self
.
t
)
;
return
self
.
t
;
}
let
r
=
rtt
.
as_nanos
(
)
;
let
d
=
r
.
saturating_mul
(
u128
:
:
try_from
(
self
.
p
-
self
.
c
)
.
unwrap
(
)
)
;
let
add
=
d
/
u128
:
:
try_from
(
cwnd
*
PACER_SPEEDUP
)
.
unwrap
(
)
;
let
w
=
u64
:
:
try_from
(
add
)
.
map
(
Duration
:
:
from_nanos
)
.
unwrap_or
(
rtt
)
;
if
w
<
GRANULARITY
{
qtrace
!
(
[
self
]
"
next
{
cwnd
}
/
{
rtt
:
?
}
below
granularity
(
{
w
:
?
}
)
"
)
;
return
self
.
t
;
}
let
nxt
=
self
.
t
+
w
;
qtrace
!
(
[
self
]
"
next
{
cwnd
}
/
{
rtt
:
?
}
wait
{
w
:
?
}
=
{
nxt
:
?
}
"
)
;
nxt
}
pub
fn
spend
(
&
mut
self
now
:
Instant
rtt
:
Duration
cwnd
:
usize
count
:
usize
)
{
if
!
self
.
enabled
{
self
.
t
=
now
;
return
;
}
qtrace
!
(
[
self
]
"
spend
{
}
over
{
}
{
:
?
}
"
count
cwnd
rtt
)
;
let
incr
=
now
.
saturating_duration_since
(
self
.
t
)
.
as_nanos
(
)
.
saturating_mul
(
u128
:
:
try_from
(
cwnd
*
PACER_SPEEDUP
)
.
unwrap
(
)
)
.
checked_div
(
rtt
.
as_nanos
(
)
)
.
and_then
(
|
i
|
usize
:
:
try_from
(
i
)
.
ok
(
)
)
.
unwrap_or
(
self
.
m
)
;
self
.
c
=
min
(
self
.
m
(
self
.
c
+
incr
)
.
saturating_sub
(
count
)
)
;
self
.
t
=
now
;
}
}
impl
Display
for
Pacer
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Pacer
{
}
/
{
}
"
self
.
c
self
.
p
)
}
}
impl
Debug
for
Pacer
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Pacer
{
:
?
}
{
}
/
{
}
.
.
{
}
"
self
.
t
self
.
c
self
.
p
self
.
m
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
time
:
:
Duration
;
use
test_fixture
:
:
now
;
use
super
:
:
Pacer
;
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
1000
)
;
const
PACKET
:
usize
=
1000
;
const
CWND
:
usize
=
PACKET
*
10
;
#
[
test
]
fn
even
(
)
{
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
)
;
p
.
spend
(
n
RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
+
(
RTT
/
20
)
)
;
}
#
[
test
]
fn
backwards_in_time
(
)
{
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
+
RTT
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
+
RTT
)
;
p
.
spend
(
n
RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
+
(
RTT
/
20
)
)
;
}
#
[
test
]
fn
pacing_disabled
(
)
{
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
false
n
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
)
;
p
.
spend
(
n
RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
)
;
}
#
[
test
]
fn
send_immediately_below_granularity
(
)
{
const
SHORT_RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
SHORT_RTT
CWND
)
n
)
;
p
.
spend
(
n
SHORT_RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
SHORT_RTT
CWND
)
n
"
Expect
packet
to
be
sent
immediately
instead
of
being
paced
below
timer
granularity
.
"
)
;
}
}
