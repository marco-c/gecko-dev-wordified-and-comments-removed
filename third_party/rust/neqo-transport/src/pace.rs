use
std
:
:
{
cmp
:
:
min
fmt
:
:
{
self
Debug
Display
Formatter
}
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
qtrace
;
use
crate
:
:
rtt
:
:
GRANULARITY
;
pub
struct
Pacer
{
enabled
:
bool
t
:
Instant
m
:
usize
c
:
isize
p
:
usize
}
impl
Pacer
{
const
SPEEDUP
:
usize
=
2
;
pub
fn
new
(
enabled
:
bool
now
:
Instant
m
:
usize
p
:
usize
)
-
>
Self
{
assert
!
(
m
>
=
p
"
maximum
capacity
has
to
be
at
least
one
packet
"
)
;
assert
!
(
isize
:
:
try_from
(
p
)
.
is_ok
(
)
"
p
(
{
p
}
)
exceeds
isize
:
:
MAX
"
)
;
Self
{
enabled
t
:
now
m
c
:
isize
:
:
try_from
(
m
)
.
expect
(
"
maximum
capacity
fits
into
isize
"
)
p
}
}
pub
const
fn
mtu
(
&
self
)
-
>
usize
{
self
.
p
}
pub
fn
set_mtu
(
&
mut
self
mtu
:
usize
)
{
self
.
p
=
mtu
;
}
pub
fn
next
(
&
self
rtt
:
Duration
cwnd
:
usize
)
-
>
Instant
{
let
packet
=
isize
:
:
try_from
(
self
.
p
)
.
expect
(
"
packet
size
fits
into
isize
"
)
;
if
self
.
c
>
=
packet
{
qtrace
!
(
"
[
{
self
}
]
next
{
cwnd
}
/
{
rtt
:
?
}
no
wait
=
{
:
?
}
"
self
.
t
)
;
return
self
.
t
;
}
let
r
=
rtt
.
as_nanos
(
)
;
let
deficit
=
u128
:
:
try_from
(
packet
-
self
.
c
)
.
expect
(
"
packet
is
larger
than
current
credit
"
)
;
let
d
=
r
.
saturating_mul
(
deficit
)
;
let
add
=
d
/
u128
:
:
try_from
(
cwnd
*
Self
:
:
SPEEDUP
)
.
expect
(
"
usize
fits
into
u128
"
)
;
let
w
=
u64
:
:
try_from
(
add
)
.
map
(
Duration
:
:
from_nanos
)
.
unwrap_or
(
rtt
)
;
if
w
<
GRANULARITY
{
qtrace
!
(
"
[
{
self
}
]
next
{
cwnd
}
/
{
rtt
:
?
}
below
granularity
(
{
w
:
?
}
)
"
)
;
return
self
.
t
;
}
let
nxt
=
self
.
t
+
w
;
qtrace
!
(
"
[
{
self
}
]
next
{
cwnd
}
/
{
rtt
:
?
}
wait
{
w
:
?
}
=
{
nxt
:
?
}
"
)
;
nxt
}
pub
fn
spend
(
&
mut
self
now
:
Instant
rtt
:
Duration
cwnd
:
usize
count
:
usize
)
{
if
!
self
.
enabled
{
self
.
t
=
now
;
return
;
}
qtrace
!
(
"
[
{
self
}
]
spend
{
count
}
over
{
cwnd
}
{
rtt
:
?
}
"
)
;
let
incr
=
now
.
saturating_duration_since
(
self
.
t
)
.
as_nanos
(
)
.
saturating_mul
(
u128
:
:
try_from
(
cwnd
*
Self
:
:
SPEEDUP
)
.
expect
(
"
usize
fits
into
u128
"
)
)
.
checked_div
(
rtt
.
as_nanos
(
)
)
.
and_then
(
|
i
|
usize
:
:
try_from
(
i
)
.
ok
(
)
)
.
unwrap_or
(
self
.
m
)
;
self
.
c
=
min
(
isize
:
:
try_from
(
self
.
m
)
.
unwrap_or
(
isize
:
:
MAX
)
self
.
c
.
saturating_add
(
isize
:
:
try_from
(
incr
)
.
unwrap_or
(
isize
:
:
MAX
)
)
.
saturating_sub
(
isize
:
:
try_from
(
count
)
.
unwrap_or
(
isize
:
:
MAX
)
)
)
;
self
.
t
=
now
;
}
}
impl
Display
for
Pacer
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Pacer
{
}
/
{
}
"
self
.
c
self
.
p
)
}
}
impl
Debug
for
Pacer
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Pacer
{
:
?
}
{
}
/
{
}
.
.
{
}
"
self
.
t
self
.
c
self
.
p
self
.
m
)
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
tests
{
use
std
:
:
time
:
:
Duration
;
use
test_fixture
:
:
now
;
use
super
:
:
Pacer
;
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
1000
)
;
const
PACKET
:
usize
=
1000
;
const
CWND
:
usize
=
PACKET
*
10
;
#
[
test
]
fn
even
(
)
{
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
)
;
p
.
spend
(
n
RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
+
(
RTT
/
20
)
)
;
}
#
[
test
]
fn
backwards_in_time
(
)
{
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
+
RTT
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
+
RTT
)
;
p
.
spend
(
n
RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
+
(
RTT
/
20
)
)
;
}
#
[
test
]
fn
pacing_disabled
(
)
{
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
false
n
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
)
;
p
.
spend
(
n
RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
RTT
CWND
)
n
)
;
}
#
[
test
]
fn
send_immediately_below_granularity
(
)
{
const
SHORT_RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
PACKET
PACKET
)
;
assert_eq
!
(
p
.
next
(
SHORT_RTT
CWND
)
n
)
;
p
.
spend
(
n
SHORT_RTT
CWND
PACKET
)
;
assert_eq
!
(
p
.
next
(
SHORT_RTT
CWND
)
n
"
Expect
packet
to
be
sent
immediately
instead
of
being
paced
below
timer
granularity
"
)
;
}
#
[
test
]
fn
sends_below_granularity_accumulate_eventually
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
const
BW
:
usize
=
50
*
1_000_000
;
let
bdp
=
usize
:
:
try_from
(
u128
:
:
try_from
(
BW
/
8
)
.
expect
(
"
usize
fits
in
u128
"
)
*
RTT
.
as_nanos
(
)
/
Duration
:
:
from_secs
(
1
)
.
as_nanos
(
)
)
.
expect
(
"
cwnd
fits
in
usize
"
)
;
let
mut
n
=
now
(
)
;
let
mut
p
=
Pacer
:
:
new
(
true
n
2
*
PACKET
PACKET
)
;
let
start
=
n
;
let
packet_count
=
10_000
;
for
_
in
0
.
.
packet_count
{
n
=
p
.
next
(
RTT
bdp
)
;
p
.
spend
(
n
RTT
bdp
PACKET
)
;
}
assert
!
(
n
-
start
>
Duration
:
:
ZERO
)
;
}
}
