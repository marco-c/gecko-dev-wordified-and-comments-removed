use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
cmp
:
:
{
max
min
Ordering
}
;
use
std
:
:
collections
:
:
{
BTreeMap
VecDeque
}
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Add
;
use
std
:
:
rc
:
:
Rc
;
use
indexmap
:
:
IndexMap
;
use
smallvec
:
:
SmallVec
;
use
neqo_common
:
:
{
qdebug
qerror
qinfo
qtrace
Encoder
Role
}
;
use
crate
:
:
events
:
:
ConnectionEvents
;
use
crate
:
:
fc
:
:
SenderFlowControl
;
use
crate
:
:
frame
:
:
{
Frame
FRAME_TYPE_RESET_STREAM
}
;
use
crate
:
:
packet
:
:
PacketBuilder
;
use
crate
:
:
recovery
:
:
{
RecoveryToken
StreamRecoveryToken
}
;
use
crate
:
:
stats
:
:
FrameStats
;
use
crate
:
:
stream_id
:
:
StreamId
;
use
crate
:
:
tparams
:
:
{
self
TransportParameters
}
;
use
crate
:
:
{
AppError
Error
Res
}
;
pub
const
SEND_BUFFER_SIZE
:
usize
=
0x10_0000
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
TransmissionPriority
{
Critical
Important
High
Normal
Low
}
impl
Default
for
TransmissionPriority
{
fn
default
(
)
-
>
Self
{
Self
:
:
Normal
}
}
impl
PartialOrd
for
TransmissionPriority
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
TransmissionPriority
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
if
self
=
=
other
{
return
Ordering
:
:
Equal
;
}
match
(
self
other
)
{
(
Self
:
:
Critical
_
)
=
>
Ordering
:
:
Greater
(
_
Self
:
:
Critical
)
=
>
Ordering
:
:
Less
(
Self
:
:
Important
_
)
=
>
Ordering
:
:
Greater
(
_
Self
:
:
Important
)
=
>
Ordering
:
:
Less
(
Self
:
:
High
_
)
=
>
Ordering
:
:
Greater
(
_
Self
:
:
High
)
=
>
Ordering
:
:
Less
(
Self
:
:
Normal
_
)
=
>
Ordering
:
:
Greater
(
_
Self
:
:
Normal
)
=
>
Ordering
:
:
Less
_
=
>
unreachable
!
(
)
}
}
}
impl
Add
<
RetransmissionPriority
>
for
TransmissionPriority
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
RetransmissionPriority
)
-
>
Self
:
:
Output
{
match
rhs
{
RetransmissionPriority
:
:
Fixed
(
fixed
)
=
>
fixed
RetransmissionPriority
:
:
Same
=
>
self
RetransmissionPriority
:
:
Higher
=
>
match
self
{
Self
:
:
Critical
=
>
Self
:
:
Critical
Self
:
:
Important
|
Self
:
:
High
=
>
Self
:
:
Important
Self
:
:
Normal
=
>
Self
:
:
High
Self
:
:
Low
=
>
Self
:
:
Normal
}
RetransmissionPriority
:
:
MuchHigher
=
>
match
self
{
Self
:
:
Critical
|
Self
:
:
Important
=
>
Self
:
:
Critical
Self
:
:
High
|
Self
:
:
Normal
=
>
Self
:
:
Important
Self
:
:
Low
=
>
Self
:
:
High
}
}
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
pub
enum
RetransmissionPriority
{
Fixed
(
TransmissionPriority
)
Same
Higher
MuchHigher
}
impl
Default
for
RetransmissionPriority
{
fn
default
(
)
-
>
Self
{
Self
:
:
Higher
}
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
enum
RangeState
{
Sent
Acked
}
#
[
derive
(
Debug
Default
PartialEq
)
]
struct
RangeTracker
{
used
:
BTreeMap
<
u64
(
u64
RangeState
)
>
}
impl
RangeTracker
{
fn
highest_offset
(
&
self
)
-
>
u64
{
self
.
used
.
range
(
.
.
)
.
next_back
(
)
.
map_or
(
0
|
(
k
(
v
_
)
)
|
*
k
+
*
v
)
}
fn
acked_from_zero
(
&
self
)
-
>
u64
{
self
.
used
.
get
(
&
0
)
.
filter
(
|
(
_
state
)
|
*
state
=
=
RangeState
:
:
Acked
)
.
map_or
(
0
|
(
v
_
)
|
*
v
)
}
fn
first_unmarked_range
(
&
self
)
-
>
(
u64
Option
<
u64
>
)
{
let
mut
prev_end
=
0
;
for
(
cur_off
(
cur_len
_
)
)
in
&
self
.
used
{
if
prev_end
=
=
*
cur_off
{
prev_end
=
cur_off
+
cur_len
;
}
else
{
return
(
prev_end
Some
(
cur_off
-
prev_end
)
)
;
}
}
(
prev_end
None
)
}
fn
chunk_range_on_edges
(
&
mut
self
new_off
:
u64
new_len
:
u64
new_state
:
RangeState
)
-
>
Vec
<
(
u64
u64
RangeState
)
>
{
let
mut
tmp_off
=
new_off
;
let
mut
tmp_len
=
new_len
;
let
mut
v
=
Vec
:
:
new
(
)
;
let
prev
=
self
.
used
.
range_mut
(
.
.
tmp_off
)
.
next_back
(
)
;
if
let
Some
(
(
prev_off
(
prev_len
prev_state
)
)
)
=
prev
{
let
prev_state
=
*
prev_state
;
let
overlap
=
(
*
prev_off
+
*
prev_len
)
.
saturating_sub
(
new_off
)
;
*
prev_len
-
=
overlap
;
if
overlap
>
0
{
self
.
used
.
insert
(
new_off
(
overlap
prev_state
)
)
;
}
}
let
mut
last_existing_remaining
=
None
;
for
(
off
(
len
state
)
)
in
self
.
used
.
range
(
tmp_off
.
.
tmp_off
+
tmp_len
)
{
if
tmp_off
<
*
off
{
let
sub_len
=
off
-
tmp_off
;
v
.
push
(
(
tmp_off
sub_len
new_state
)
)
;
tmp_off
+
=
sub_len
;
tmp_len
-
=
sub_len
;
}
let
sub_len
=
min
(
*
len
tmp_len
)
;
let
remaining_len
=
len
-
sub_len
;
if
new_state
=
=
RangeState
:
:
Sent
&
&
*
state
=
=
RangeState
:
:
Acked
{
qinfo
!
(
"
Attempted
to
downgrade
overlapping
range
Acked
range
{
}
-
{
}
with
Sent
{
}
-
{
}
"
off
len
new_off
new_len
)
;
}
else
{
v
.
push
(
(
tmp_off
sub_len
new_state
)
)
;
}
tmp_off
+
=
sub_len
;
tmp_len
-
=
sub_len
;
if
remaining_len
>
0
{
last_existing_remaining
=
Some
(
(
*
off
sub_len
remaining_len
*
state
)
)
;
}
}
if
let
Some
(
(
off
sub_len
remaining_len
state
)
)
=
last_existing_remaining
{
*
self
.
used
.
get_mut
(
&
off
)
.
expect
(
"
must
be
there
"
)
=
(
sub_len
state
)
;
self
.
used
.
insert
(
off
+
sub_len
(
remaining_len
state
)
)
;
}
if
tmp_len
>
0
{
v
.
push
(
(
tmp_off
tmp_len
new_state
)
)
}
v
}
fn
coalesce_acked_from_zero
(
&
mut
self
)
{
let
acked_range_from_zero
=
self
.
used
.
get_mut
(
&
0
)
.
filter
(
|
(
_
state
)
|
*
state
=
=
RangeState
:
:
Acked
)
.
map
(
|
(
len
_
)
|
*
len
)
;
if
let
Some
(
len_from_zero
)
=
acked_range_from_zero
{
let
mut
to_remove
=
SmallVec
:
:
<
[
_
;
8
]
>
:
:
new
(
)
;
let
mut
new_len_from_zero
=
len_from_zero
;
while
let
Some
(
(
next_len
_
)
)
=
self
.
used
.
get
(
&
new_len_from_zero
)
.
filter
(
|
(
_
state
)
|
*
state
=
=
RangeState
:
:
Acked
)
{
to_remove
.
push
(
new_len_from_zero
)
;
new_len_from_zero
+
=
*
next_len
;
}
if
len_from_zero
!
=
new_len_from_zero
{
self
.
used
.
get_mut
(
&
0
)
.
expect
(
"
must
be
there
"
)
.
0
=
new_len_from_zero
;
}
for
val
in
to_remove
{
self
.
used
.
remove
(
&
val
)
;
}
}
}
fn
mark_range
(
&
mut
self
off
:
u64
len
:
usize
state
:
RangeState
)
{
if
len
=
=
0
{
qinfo
!
(
"
mark
0
-
length
range
at
{
}
"
off
)
;
return
;
}
let
subranges
=
self
.
chunk_range_on_edges
(
off
len
as
u64
state
)
;
for
(
sub_off
sub_len
sub_state
)
in
subranges
{
self
.
used
.
insert
(
sub_off
(
sub_len
sub_state
)
)
;
}
self
.
coalesce_acked_from_zero
(
)
}
fn
unmark_range
(
&
mut
self
off
:
u64
len
:
usize
)
{
if
len
=
=
0
{
qdebug
!
(
"
unmark
0
-
length
range
at
{
}
"
off
)
;
return
;
}
let
len
=
u64
:
:
try_from
(
len
)
.
unwrap
(
)
;
let
end_off
=
off
+
len
;
let
mut
to_remove
=
SmallVec
:
:
<
[
_
;
8
]
>
:
:
new
(
)
;
let
mut
to_add
=
None
;
for
(
cur_off
(
cur_len
cur_state
)
)
in
self
.
used
.
range_mut
(
.
.
off
+
len
)
.
rev
(
)
{
if
*
cur_off
<
off
{
if
*
cur_off
+
*
cur_len
>
off
{
if
*
cur_state
=
=
RangeState
:
:
Acked
{
qdebug
!
(
"
Attempted
to
unmark
Acked
range
{
}
-
{
}
with
unmark_range
{
}
-
{
}
"
cur_off
cur_len
off
off
+
len
)
;
}
else
{
*
cur_len
=
off
-
cur_off
;
}
}
break
;
}
if
*
cur_state
=
=
RangeState
:
:
Acked
{
qdebug
!
(
"
Attempted
to
unmark
Acked
range
{
}
-
{
}
with
unmark_range
{
}
-
{
}
"
cur_off
cur_len
off
off
+
len
)
;
continue
;
}
let
cur_end_off
=
cur_off
+
*
cur_len
;
if
cur_end_off
>
end_off
{
let
new_cur_off
=
off
+
len
;
let
new_cur_len
=
cur_end_off
-
end_off
;
assert_eq
!
(
to_add
None
)
;
to_add
=
Some
(
(
new_cur_off
new_cur_len
*
cur_state
)
)
;
}
to_remove
.
push
(
*
cur_off
)
;
}
for
remove_off
in
to_remove
{
self
.
used
.
remove
(
&
remove_off
)
;
}
if
let
Some
(
(
new_cur_off
new_cur_len
cur_state
)
)
=
to_add
{
self
.
used
.
insert
(
new_cur_off
(
new_cur_len
cur_state
)
)
;
}
}
pub
fn
unmark_sent
(
&
mut
self
)
{
self
.
unmark_range
(
0
usize
:
:
try_from
(
self
.
highest_offset
(
)
)
.
unwrap
(
)
)
;
}
}
#
[
derive
(
Debug
Default
PartialEq
)
]
pub
struct
TxBuffer
{
retired
:
u64
send_buf
:
VecDeque
<
u8
>
ranges
:
RangeTracker
}
impl
TxBuffer
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
send
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
usize
{
let
can_buffer
=
min
(
SEND_BUFFER_SIZE
-
self
.
buffered
(
)
buf
.
len
(
)
)
;
if
can_buffer
>
0
{
self
.
send_buf
.
extend
(
&
buf
[
.
.
can_buffer
]
)
;
assert
!
(
self
.
send_buf
.
len
(
)
<
=
SEND_BUFFER_SIZE
)
;
}
can_buffer
}
pub
fn
next_bytes
(
&
self
)
-
>
Option
<
(
u64
&
[
u8
]
)
>
{
let
(
start
maybe_len
)
=
self
.
ranges
.
first_unmarked_range
(
)
;
if
start
=
=
self
.
retired
+
u64
:
:
try_from
(
self
.
buffered
(
)
)
.
unwrap
(
)
{
return
None
;
}
let
buff_off
=
usize
:
:
try_from
(
start
-
self
.
retired
)
.
unwrap
(
)
;
let
slc
=
if
buff_off
<
self
.
send_buf
.
as_slices
(
)
.
0
.
len
(
)
{
&
self
.
send_buf
.
as_slices
(
)
.
0
[
buff_off
.
.
]
}
else
{
&
self
.
send_buf
.
as_slices
(
)
.
1
[
buff_off
-
self
.
send_buf
.
as_slices
(
)
.
0
.
len
(
)
.
.
]
}
;
let
len
=
if
let
Some
(
range_len
)
=
maybe_len
{
min
(
usize
:
:
try_from
(
range_len
)
.
unwrap
(
)
slc
.
len
(
)
)
}
else
{
slc
.
len
(
)
}
;
debug_assert
!
(
len
>
0
)
;
debug_assert
!
(
len
<
=
slc
.
len
(
)
)
;
Some
(
(
start
&
slc
[
.
.
len
]
)
)
}
pub
fn
mark_as_sent
(
&
mut
self
offset
:
u64
len
:
usize
)
{
self
.
ranges
.
mark_range
(
offset
len
RangeState
:
:
Sent
)
}
pub
fn
mark_as_acked
(
&
mut
self
offset
:
u64
len
:
usize
)
{
self
.
ranges
.
mark_range
(
offset
len
RangeState
:
:
Acked
)
;
let
new_retirable
=
self
.
ranges
.
acked_from_zero
(
)
-
self
.
retired
;
debug_assert
!
(
new_retirable
<
=
self
.
buffered
(
)
as
u64
)
;
let
keep_len
=
self
.
buffered
(
)
-
usize
:
:
try_from
(
new_retirable
)
.
expect
(
"
should
fit
in
usize
"
)
;
self
.
send_buf
.
rotate_left
(
self
.
buffered
(
)
-
keep_len
)
;
self
.
send_buf
.
truncate
(
keep_len
)
;
self
.
retired
+
=
new_retirable
;
}
pub
fn
mark_as_lost
(
&
mut
self
offset
:
u64
len
:
usize
)
{
self
.
ranges
.
unmark_range
(
offset
len
)
}
pub
fn
unmark_sent
(
&
mut
self
)
{
self
.
ranges
.
unmark_sent
(
)
;
}
fn
buffered
(
&
self
)
-
>
usize
{
self
.
send_buf
.
len
(
)
}
fn
avail
(
&
self
)
-
>
usize
{
SEND_BUFFER_SIZE
-
self
.
buffered
(
)
}
fn
used
(
&
self
)
-
>
u64
{
self
.
retired
+
u64
:
:
try_from
(
self
.
buffered
(
)
)
.
unwrap
(
)
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
SendStreamState
{
Ready
{
fc
:
SenderFlowControl
<
StreamId
>
conn_fc
:
Rc
<
RefCell
<
SenderFlowControl
<
(
)
>
>
>
}
Send
{
fc
:
SenderFlowControl
<
StreamId
>
conn_fc
:
Rc
<
RefCell
<
SenderFlowControl
<
(
)
>
>
>
send_buf
:
TxBuffer
}
DataSent
{
send_buf
:
TxBuffer
fin_sent
:
bool
fin_acked
:
bool
}
DataRecvd
ResetSent
{
err
:
AppError
final_size
:
u64
priority
:
Option
<
TransmissionPriority
>
}
ResetRecvd
}
impl
SendStreamState
{
fn
tx_buf_mut
(
&
mut
self
)
-
>
Option
<
&
mut
TxBuffer
>
{
match
self
{
Self
:
:
Send
{
send_buf
.
.
}
|
Self
:
:
DataSent
{
send_buf
.
.
}
=
>
Some
(
send_buf
)
Self
:
:
Ready
{
.
.
}
|
Self
:
:
DataRecvd
{
.
.
}
|
Self
:
:
ResetSent
{
.
.
}
|
Self
:
:
ResetRecvd
=
>
None
}
}
fn
tx_avail
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Ready
{
.
.
}
=
>
SEND_BUFFER_SIZE
Self
:
:
Send
{
send_buf
.
.
}
|
Self
:
:
DataSent
{
send_buf
.
.
}
=
>
send_buf
.
avail
(
)
Self
:
:
DataRecvd
{
.
.
}
|
Self
:
:
ResetSent
{
.
.
}
|
Self
:
:
ResetRecvd
=
>
0
}
}
fn
name
(
&
self
)
-
>
&
str
{
match
self
{
Self
:
:
Ready
{
.
.
}
=
>
"
Ready
"
Self
:
:
Send
{
.
.
}
=
>
"
Send
"
Self
:
:
DataSent
{
.
.
}
=
>
"
DataSent
"
Self
:
:
DataRecvd
{
.
.
}
=
>
"
DataRecvd
"
Self
:
:
ResetSent
{
.
.
}
=
>
"
ResetSent
"
Self
:
:
ResetRecvd
=
>
"
ResetRecvd
"
}
}
fn
transition
(
&
mut
self
new_state
:
Self
)
{
qtrace
!
(
"
SendStream
state
{
}
-
>
{
}
"
self
.
name
(
)
new_state
.
name
(
)
)
;
*
self
=
new_state
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
SendStream
{
stream_id
:
StreamId
state
:
SendStreamState
conn_events
:
ConnectionEvents
priority
:
TransmissionPriority
retransmission_priority
:
RetransmissionPriority
retransmission_offset
:
u64
}
impl
SendStream
{
pub
fn
new
(
stream_id
:
StreamId
max_stream_data
:
u64
conn_fc
:
Rc
<
RefCell
<
SenderFlowControl
<
(
)
>
>
>
conn_events
:
ConnectionEvents
)
-
>
Self
{
let
ss
=
Self
{
stream_id
state
:
SendStreamState
:
:
Ready
{
fc
:
SenderFlowControl
:
:
new
(
stream_id
max_stream_data
)
conn_fc
}
conn_events
priority
:
TransmissionPriority
:
:
default
(
)
retransmission_priority
:
RetransmissionPriority
:
:
default
(
)
retransmission_offset
:
0
}
;
if
ss
.
avail
(
)
>
0
{
ss
.
conn_events
.
send_stream_writable
(
stream_id
)
;
}
ss
}
pub
fn
set_priority
(
&
mut
self
transmission
:
TransmissionPriority
retransmission
:
RetransmissionPriority
)
{
self
.
priority
=
transmission
;
self
.
retransmission_priority
=
retransmission
;
}
pub
fn
final_size
(
&
self
)
-
>
Option
<
u64
>
{
match
&
self
.
state
{
SendStreamState
:
:
DataSent
{
send_buf
.
.
}
=
>
Some
(
send_buf
.
used
(
)
)
SendStreamState
:
:
ResetSent
{
final_size
.
.
}
=
>
Some
(
*
final_size
)
_
=
>
None
}
}
fn
next_bytes
(
&
mut
self
retransmission_only
:
bool
)
-
>
Option
<
(
u64
&
[
u8
]
)
>
{
match
self
.
state
{
SendStreamState
:
:
Send
{
ref
send_buf
.
.
}
=
>
{
send_buf
.
next_bytes
(
)
.
and_then
(
|
(
offset
slice
)
|
{
if
retransmission_only
{
qtrace
!
(
[
self
]
"
next_bytes
apply
retransmission
limit
at
{
}
"
self
.
retransmission_offset
)
;
if
self
.
retransmission_offset
>
offset
{
let
len
=
min
(
usize
:
:
try_from
(
self
.
retransmission_offset
-
offset
)
.
unwrap
(
)
slice
.
len
(
)
)
;
Some
(
(
offset
&
slice
[
.
.
len
]
)
)
}
else
{
None
}
}
else
{
Some
(
(
offset
slice
)
)
}
}
)
}
SendStreamState
:
:
DataSent
{
ref
send_buf
fin_sent
.
.
}
=
>
{
let
bytes
=
send_buf
.
next_bytes
(
)
;
if
bytes
.
is_some
(
)
{
bytes
}
else
if
fin_sent
{
None
}
else
{
Some
(
(
send_buf
.
used
(
)
&
[
]
)
)
}
}
SendStreamState
:
:
Ready
{
.
.
}
|
SendStreamState
:
:
DataRecvd
{
.
.
}
|
SendStreamState
:
:
ResetSent
{
.
.
}
|
SendStreamState
:
:
ResetRecvd
=
>
None
}
}
fn
length_and_fill
(
data_len
:
usize
space
:
usize
)
-
>
(
usize
bool
)
{
if
data_len
>
=
space
{
qtrace
!
(
"
SendStream
:
:
length_and_fill
fill
{
}
"
space
)
;
return
(
space
true
)
;
}
let
length
=
min
(
space
.
saturating_sub
(
1
)
data_len
)
;
let
length_len
=
Encoder
:
:
varint_len
(
u64
:
:
try_from
(
length
)
.
unwrap
(
)
)
;
debug_assert
!
(
length_len
<
=
space
)
;
let
fill
=
data_len
+
length_len
+
PacketBuilder
:
:
MINIMUM_FRAME_SIZE
>
space
;
qtrace
!
(
"
SendStream
:
:
length_and_fill
{
}
fill
{
}
"
data_len
fill
)
;
(
data_len
fill
)
}
fn
write_stream_frame
(
&
mut
self
priority
:
TransmissionPriority
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
let
retransmission
=
if
priority
=
=
self
.
priority
{
false
}
else
if
priority
=
=
self
.
priority
+
self
.
retransmission_priority
{
true
}
else
{
return
;
}
;
let
id
=
self
.
stream_id
;
let
final_size
=
self
.
final_size
(
)
;
if
let
Some
(
(
offset
data
)
)
=
self
.
next_bytes
(
retransmission
)
{
let
overhead
=
1
+
Encoder
:
:
varint_len
(
id
.
as_u64
(
)
)
+
if
offset
>
0
{
Encoder
:
:
varint_len
(
offset
)
}
else
{
0
}
;
if
overhead
>
builder
.
remaining
(
)
{
qtrace
!
(
[
self
]
"
write_frame
no
space
for
header
"
)
;
return
;
}
let
(
length
fill
)
=
Self
:
:
length_and_fill
(
data
.
len
(
)
builder
.
remaining
(
)
-
overhead
)
;
let
fin
=
final_size
.
map_or
(
false
|
fs
|
fs
=
=
offset
+
u64
:
:
try_from
(
length
)
.
unwrap
(
)
)
;
if
length
=
=
0
&
&
!
fin
{
qtrace
!
(
[
self
]
"
write_frame
no
data
no
fin
"
)
;
return
;
}
builder
.
encode_varint
(
Frame
:
:
stream_type
(
fin
offset
>
0
fill
)
)
;
builder
.
encode_varint
(
id
.
as_u64
(
)
)
;
if
offset
>
0
{
builder
.
encode_varint
(
offset
)
;
}
if
fill
{
builder
.
encode
(
&
data
[
.
.
length
]
)
;
builder
.
mark_full
(
)
;
}
else
{
builder
.
encode_vvec
(
&
data
[
.
.
length
]
)
;
}
debug_assert
!
(
builder
.
len
(
)
<
=
builder
.
limit
(
)
)
;
self
.
mark_as_sent
(
offset
length
fin
)
;
tokens
.
push
(
RecoveryToken
:
:
Stream
(
StreamRecoveryToken
:
:
Stream
(
SendStreamRecoveryToken
{
id
offset
length
fin
}
)
)
)
;
stats
.
stream
+
=
1
;
}
}
pub
fn
reset_acked
(
&
mut
self
)
{
match
self
.
state
{
SendStreamState
:
:
Ready
{
.
.
}
|
SendStreamState
:
:
Send
{
.
.
}
|
SendStreamState
:
:
DataSent
{
.
.
}
|
SendStreamState
:
:
DataRecvd
{
.
.
}
=
>
{
qtrace
!
(
[
self
]
"
Reset
acked
while
in
{
}
state
?
"
self
.
state
.
name
(
)
)
}
SendStreamState
:
:
ResetSent
{
.
.
}
=
>
self
.
state
.
transition
(
SendStreamState
:
:
ResetRecvd
)
SendStreamState
:
:
ResetRecvd
=
>
qtrace
!
(
[
self
]
"
already
in
ResetRecvd
state
"
)
}
;
}
pub
fn
reset_lost
(
&
mut
self
)
{
match
self
.
state
{
SendStreamState
:
:
ResetSent
{
ref
mut
priority
.
.
}
=
>
{
*
priority
=
Some
(
self
.
priority
+
self
.
retransmission_priority
)
;
}
SendStreamState
:
:
ResetRecvd
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
pub
fn
write_reset_frame
(
&
mut
self
p
:
TransmissionPriority
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
-
>
bool
{
if
let
SendStreamState
:
:
ResetSent
{
final_size
err
ref
mut
priority
}
=
self
.
state
{
if
*
priority
!
=
Some
(
p
)
{
return
false
;
}
if
builder
.
write_varint_frame
(
&
[
FRAME_TYPE_RESET_STREAM
self
.
stream_id
.
as_u64
(
)
err
final_size
]
)
{
tokens
.
push
(
RecoveryToken
:
:
Stream
(
StreamRecoveryToken
:
:
ResetStream
{
stream_id
:
self
.
stream_id
}
)
)
;
stats
.
reset_stream
+
=
1
;
*
priority
=
None
;
true
}
else
{
false
}
}
else
{
false
}
}
pub
fn
blocked_lost
(
&
mut
self
limit
:
u64
)
{
if
let
SendStreamState
:
:
Ready
{
fc
.
.
}
|
SendStreamState
:
:
Send
{
fc
.
.
}
=
&
mut
self
.
state
{
fc
.
frame_lost
(
limit
)
;
}
else
{
qtrace
!
(
[
self
]
"
Ignoring
lost
STREAM_DATA_BLOCKED
(
{
}
)
"
limit
)
;
}
}
pub
fn
write_blocked_frame
(
&
mut
self
priority
:
TransmissionPriority
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
if
priority
=
=
self
.
priority
{
if
let
SendStreamState
:
:
Ready
{
fc
.
.
}
|
SendStreamState
:
:
Send
{
fc
.
.
}
=
&
mut
self
.
state
{
fc
.
write_frames
(
builder
tokens
stats
)
;
}
}
}
pub
fn
mark_as_sent
(
&
mut
self
offset
:
u64
len
:
usize
fin
:
bool
)
{
if
let
Some
(
buf
)
=
self
.
state
.
tx_buf_mut
(
)
{
buf
.
mark_as_sent
(
offset
len
)
;
self
.
send_blocked_if_space_needed
(
0
)
;
}
;
if
fin
{
if
let
SendStreamState
:
:
DataSent
{
fin_sent
.
.
}
=
&
mut
self
.
state
{
*
fin_sent
=
true
;
}
}
}
pub
fn
mark_as_acked
(
&
mut
self
offset
:
u64
len
:
usize
fin
:
bool
)
{
match
self
.
state
{
SendStreamState
:
:
Send
{
ref
mut
send_buf
.
.
}
=
>
{
send_buf
.
mark_as_acked
(
offset
len
)
;
if
self
.
avail
(
)
>
0
{
self
.
conn_events
.
send_stream_writable
(
self
.
stream_id
)
}
}
SendStreamState
:
:
DataSent
{
ref
mut
send_buf
ref
mut
fin_acked
.
.
}
=
>
{
send_buf
.
mark_as_acked
(
offset
len
)
;
if
fin
{
*
fin_acked
=
true
;
}
if
*
fin_acked
&
&
send_buf
.
buffered
(
)
=
=
0
{
self
.
conn_events
.
send_stream_complete
(
self
.
stream_id
)
;
self
.
state
.
transition
(
SendStreamState
:
:
DataRecvd
)
;
}
}
_
=
>
qtrace
!
(
[
self
]
"
mark_as_acked
called
from
state
{
}
"
self
.
state
.
name
(
)
)
}
}
pub
fn
mark_as_lost
(
&
mut
self
offset
:
u64
len
:
usize
fin
:
bool
)
{
self
.
retransmission_offset
=
max
(
self
.
retransmission_offset
offset
+
u64
:
:
try_from
(
len
)
.
unwrap
(
)
)
;
qtrace
!
(
[
self
]
"
mark_as_lost
retransmission
offset
=
{
}
"
self
.
retransmission_offset
)
;
if
let
Some
(
buf
)
=
self
.
state
.
tx_buf_mut
(
)
{
buf
.
mark_as_lost
(
offset
len
)
;
}
if
fin
{
if
let
SendStreamState
:
:
DataSent
{
fin_sent
fin_acked
.
.
}
=
&
mut
self
.
state
{
*
fin_sent
=
*
fin_acked
;
}
}
}
pub
fn
avail
(
&
self
)
-
>
usize
{
if
let
SendStreamState
:
:
Ready
{
fc
conn_fc
}
|
SendStreamState
:
:
Send
{
fc
conn_fc
.
.
}
=
&
self
.
state
{
min
(
min
(
fc
.
available
(
)
conn_fc
.
borrow
(
)
.
available
(
)
)
self
.
state
.
tx_avail
(
)
)
}
else
{
0
}
}
pub
fn
set_max_stream_data
(
&
mut
self
limit
:
u64
)
{
if
let
SendStreamState
:
:
Ready
{
fc
.
.
}
|
SendStreamState
:
:
Send
{
fc
.
.
}
=
&
mut
self
.
state
{
let
stream_was_blocked
=
fc
.
available
(
)
=
=
0
;
fc
.
update
(
limit
)
;
if
stream_was_blocked
&
&
self
.
avail
(
)
>
0
{
self
.
conn_events
.
send_stream_writable
(
self
.
stream_id
)
}
}
}
pub
fn
is_terminal
(
&
self
)
-
>
bool
{
matches
!
(
self
.
state
SendStreamState
:
:
DataRecvd
{
.
.
}
|
SendStreamState
:
:
ResetRecvd
)
}
pub
fn
send
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
Res
<
usize
>
{
self
.
send_internal
(
buf
false
)
}
pub
fn
send_atomic
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
Res
<
usize
>
{
self
.
send_internal
(
buf
true
)
}
fn
send_blocked_if_space_needed
(
&
mut
self
needed_space
:
usize
)
{
if
let
SendStreamState
:
:
Ready
{
fc
conn_fc
}
|
SendStreamState
:
:
Send
{
fc
conn_fc
.
.
}
=
&
mut
self
.
state
{
if
fc
.
available
(
)
<
=
needed_space
{
fc
.
blocked
(
)
;
}
if
conn_fc
.
borrow
(
)
.
available
(
)
<
=
needed_space
{
conn_fc
.
borrow_mut
(
)
.
blocked
(
)
;
}
}
}
fn
send_internal
(
&
mut
self
buf
:
&
[
u8
]
atomic
:
bool
)
-
>
Res
<
usize
>
{
if
buf
.
is_empty
(
)
{
qerror
!
(
[
self
]
"
zero
-
length
send
on
stream
"
)
;
return
Err
(
Error
:
:
InvalidInput
)
;
}
if
let
SendStreamState
:
:
Ready
{
fc
conn_fc
}
=
&
mut
self
.
state
{
let
owned_fc
=
mem
:
:
replace
(
fc
SenderFlowControl
:
:
new
(
self
.
stream_id
0
)
)
;
let
owned_conn_fc
=
Rc
:
:
clone
(
conn_fc
)
;
self
.
state
.
transition
(
SendStreamState
:
:
Send
{
fc
:
owned_fc
conn_fc
:
owned_conn_fc
send_buf
:
TxBuffer
:
:
new
(
)
}
)
;
}
if
!
matches
!
(
self
.
state
SendStreamState
:
:
Send
{
.
.
}
)
{
return
Err
(
Error
:
:
FinalSizeError
)
;
}
let
buf
=
if
buf
.
is_empty
(
)
|
|
(
self
.
avail
(
)
=
=
0
)
{
return
Ok
(
0
)
;
}
else
if
self
.
avail
(
)
<
buf
.
len
(
)
{
if
atomic
{
self
.
send_blocked_if_space_needed
(
buf
.
len
(
)
)
;
return
Ok
(
0
)
;
}
else
{
&
buf
[
.
.
self
.
avail
(
)
]
}
}
else
{
buf
}
;
match
&
mut
self
.
state
{
SendStreamState
:
:
Ready
{
.
.
}
=
>
unreachable
!
(
)
SendStreamState
:
:
Send
{
fc
conn_fc
send_buf
}
=
>
{
let
sent
=
send_buf
.
send
(
buf
)
;
fc
.
consume
(
sent
)
;
conn_fc
.
borrow_mut
(
)
.
consume
(
sent
)
;
Ok
(
sent
)
}
_
=
>
Err
(
Error
:
:
FinalSizeError
)
}
}
pub
fn
close
(
&
mut
self
)
{
match
&
mut
self
.
state
{
SendStreamState
:
:
Ready
{
.
.
}
=
>
{
self
.
state
.
transition
(
SendStreamState
:
:
DataSent
{
send_buf
:
TxBuffer
:
:
new
(
)
fin_sent
:
false
fin_acked
:
false
}
)
;
}
SendStreamState
:
:
Send
{
send_buf
.
.
}
=
>
{
let
owned_buf
=
mem
:
:
replace
(
send_buf
TxBuffer
:
:
new
(
)
)
;
self
.
state
.
transition
(
SendStreamState
:
:
DataSent
{
send_buf
:
owned_buf
fin_sent
:
false
fin_acked
:
false
}
)
;
}
SendStreamState
:
:
DataSent
{
.
.
}
=
>
qtrace
!
(
[
self
]
"
already
in
DataSent
state
"
)
SendStreamState
:
:
DataRecvd
{
.
.
}
=
>
qtrace
!
(
[
self
]
"
already
in
DataRecvd
state
"
)
SendStreamState
:
:
ResetSent
{
.
.
}
=
>
qtrace
!
(
[
self
]
"
already
in
ResetSent
state
"
)
SendStreamState
:
:
ResetRecvd
=
>
qtrace
!
(
[
self
]
"
already
in
ResetRecvd
state
"
)
}
}
pub
fn
reset
(
&
mut
self
err
:
AppError
)
{
match
&
self
.
state
{
SendStreamState
:
:
Ready
{
fc
.
.
}
|
SendStreamState
:
:
Send
{
fc
.
.
}
=
>
{
let
final_size
=
fc
.
used
(
)
;
self
.
state
.
transition
(
SendStreamState
:
:
ResetSent
{
err
final_size
priority
:
Some
(
self
.
priority
)
}
)
;
}
SendStreamState
:
:
DataSent
{
send_buf
.
.
}
=
>
{
let
final_size
=
send_buf
.
used
(
)
;
self
.
state
.
transition
(
SendStreamState
:
:
ResetSent
{
err
final_size
priority
:
Some
(
self
.
priority
)
}
)
;
}
SendStreamState
:
:
DataRecvd
{
.
.
}
=
>
qtrace
!
(
[
self
]
"
already
in
DataRecvd
state
"
)
SendStreamState
:
:
ResetSent
{
.
.
}
=
>
qtrace
!
(
[
self
]
"
already
in
ResetSent
state
"
)
SendStreamState
:
:
ResetRecvd
=
>
qtrace
!
(
[
self
]
"
already
in
ResetRecvd
state
"
)
}
;
}
#
[
cfg
(
test
)
]
pub
(
crate
)
fn
state
(
&
mut
self
)
-
>
&
mut
SendStreamState
{
&
mut
self
.
state
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
SendStream
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
SendStream
{
}
"
self
.
stream_id
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
SendStreams
(
IndexMap
<
StreamId
SendStream
>
)
;
impl
SendStreams
{
pub
fn
get
(
&
self
id
:
StreamId
)
-
>
Res
<
&
SendStream
>
{
self
.
0
.
get
(
&
id
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
}
pub
fn
get_mut
(
&
mut
self
id
:
StreamId
)
-
>
Res
<
&
mut
SendStream
>
{
self
.
0
.
get_mut
(
&
id
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
}
pub
fn
exists
(
&
self
id
:
StreamId
)
-
>
bool
{
self
.
0
.
contains_key
(
&
id
)
}
pub
fn
insert
(
&
mut
self
id
:
StreamId
stream
:
SendStream
)
{
self
.
0
.
insert
(
id
stream
)
;
}
pub
fn
acked
(
&
mut
self
token
:
&
SendStreamRecoveryToken
)
{
if
let
Some
(
ss
)
=
self
.
0
.
get_mut
(
&
token
.
id
)
{
ss
.
mark_as_acked
(
token
.
offset
token
.
length
token
.
fin
)
;
}
}
pub
fn
reset_acked
(
&
mut
self
id
:
StreamId
)
{
if
let
Some
(
ss
)
=
self
.
0
.
get_mut
(
&
id
)
{
ss
.
reset_acked
(
)
}
}
pub
fn
lost
(
&
mut
self
token
:
&
SendStreamRecoveryToken
)
{
if
let
Some
(
ss
)
=
self
.
0
.
get_mut
(
&
token
.
id
)
{
ss
.
mark_as_lost
(
token
.
offset
token
.
length
token
.
fin
)
;
}
}
pub
fn
reset_lost
(
&
mut
self
stream_id
:
StreamId
)
{
if
let
Some
(
ss
)
=
self
.
0
.
get_mut
(
&
stream_id
)
{
ss
.
reset_lost
(
)
;
}
}
pub
fn
blocked_lost
(
&
mut
self
stream_id
:
StreamId
limit
:
u64
)
{
if
let
Some
(
ss
)
=
self
.
0
.
get_mut
(
&
stream_id
)
{
ss
.
blocked_lost
(
limit
)
;
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
}
pub
fn
clear_terminal
(
&
mut
self
)
{
self
.
0
.
retain
(
|
_
stream
|
!
stream
.
is_terminal
(
)
)
}
pub
(
crate
)
fn
write_frames
(
&
mut
self
priority
:
TransmissionPriority
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
qtrace
!
(
"
write
STREAM
frames
at
priority
{
:
?
}
"
priority
)
;
for
stream
in
self
.
0
.
values_mut
(
)
{
if
!
stream
.
write_reset_frame
(
priority
builder
tokens
stats
)
{
stream
.
write_blocked_frame
(
priority
builder
tokens
stats
)
;
stream
.
write_stream_frame
(
priority
builder
tokens
stats
)
;
}
}
}
pub
fn
update_initial_limit
(
&
mut
self
remote
:
&
TransportParameters
)
{
for
(
id
ss
)
in
self
.
0
.
iter_mut
(
)
{
let
limit
=
if
id
.
is_bidi
(
)
{
assert
!
(
!
id
.
is_remote_initiated
(
Role
:
:
Client
)
)
;
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
)
}
else
{
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
)
}
;
ss
.
set_max_stream_data
(
limit
)
;
}
}
}
impl
<
'
a
>
IntoIterator
for
&
'
a
mut
SendStreams
{
type
Item
=
(
&
'
a
StreamId
&
'
a
mut
SendStream
)
;
type
IntoIter
=
indexmap
:
:
map
:
:
IterMut
<
'
a
StreamId
SendStream
>
;
fn
into_iter
(
self
)
-
>
indexmap
:
:
map
:
:
IterMut
<
'
a
StreamId
SendStream
>
{
self
.
0
.
iter_mut
(
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
SendStreamRecoveryToken
{
pub
(
crate
)
id
:
StreamId
offset
:
u64
length
:
usize
fin
:
bool
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
events
:
:
ConnectionEvent
;
use
neqo_common
:
:
{
event
:
:
Provider
hex_with_len
qtrace
}
;
fn
connection_fc
(
limit
:
u64
)
-
>
Rc
<
RefCell
<
SenderFlowControl
<
(
)
>
>
>
{
Rc
:
:
new
(
RefCell
:
:
new
(
SenderFlowControl
:
:
new
(
(
)
limit
)
)
)
}
#
[
test
]
fn
test_mark_range
(
)
{
let
mut
rt
=
RangeTracker
:
:
default
(
)
;
rt
.
mark_range
(
5
5
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
10
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
0
)
;
rt
.
mark_range
(
10
4
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
14
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
0
)
;
rt
.
mark_range
(
0
5
RangeState
:
:
Sent
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
14
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
0
)
;
rt
.
mark_range
(
0
5
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
14
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
14
)
;
rt
.
mark_range
(
12
20
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
32
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
32
)
;
rt
.
mark_range
(
0
400
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
400
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
400
)
;
rt
.
mark_range
(
0
200
RangeState
:
:
Sent
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
400
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
400
)
;
}
#
[
test
]
fn
unmark_sent_start
(
)
{
let
mut
rt
=
RangeTracker
:
:
default
(
)
;
rt
.
mark_range
(
0
5
RangeState
:
:
Sent
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
5
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
0
)
;
rt
.
unmark_sent
(
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
0
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
0
)
;
assert_eq
!
(
rt
.
first_unmarked_range
(
)
(
0
None
)
)
;
}
#
[
test
]
fn
unmark_sent_middle
(
)
{
let
mut
rt
=
RangeTracker
:
:
default
(
)
;
rt
.
mark_range
(
0
5
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
5
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
rt
.
mark_range
(
5
5
RangeState
:
:
Sent
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
10
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
rt
.
mark_range
(
10
5
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
15
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
assert_eq
!
(
rt
.
first_unmarked_range
(
)
(
15
None
)
)
;
rt
.
unmark_sent
(
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
15
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
assert_eq
!
(
rt
.
first_unmarked_range
(
)
(
5
Some
(
5
)
)
)
;
}
#
[
test
]
fn
unmark_sent_end
(
)
{
let
mut
rt
=
RangeTracker
:
:
default
(
)
;
rt
.
mark_range
(
0
5
RangeState
:
:
Acked
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
5
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
rt
.
mark_range
(
5
5
RangeState
:
:
Sent
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
10
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
assert_eq
!
(
rt
.
first_unmarked_range
(
)
(
10
None
)
)
;
rt
.
unmark_sent
(
)
;
assert_eq
!
(
rt
.
highest_offset
(
)
5
)
;
assert_eq
!
(
rt
.
acked_from_zero
(
)
5
)
;
assert_eq
!
(
rt
.
first_unmarked_range
(
)
(
5
None
)
)
;
}
#
[
test
]
fn
truncate_front
(
)
{
let
mut
v
=
VecDeque
:
:
new
(
)
;
v
.
push_back
(
5
)
;
v
.
push_back
(
6
)
;
v
.
push_back
(
7
)
;
v
.
push_front
(
4usize
)
;
v
.
rotate_left
(
1
)
;
v
.
truncate
(
3
)
;
assert_eq
!
(
*
v
.
front
(
)
.
unwrap
(
)
5
)
;
assert_eq
!
(
*
v
.
back
(
)
.
unwrap
(
)
7
)
;
}
#
[
test
]
fn
test_unmark_range
(
)
{
let
mut
rt
=
RangeTracker
:
:
default
(
)
;
rt
.
mark_range
(
5
5
RangeState
:
:
Acked
)
;
rt
.
mark_range
(
10
5
RangeState
:
:
Sent
)
;
rt
.
unmark_range
(
7
6
)
;
let
res
=
rt
.
first_unmarked_range
(
)
;
assert_eq
!
(
res
(
0
Some
(
5
)
)
)
;
assert_eq
!
(
rt
.
used
.
iter
(
)
.
next
(
)
.
unwrap
(
)
(
&
5
&
(
5
RangeState
:
:
Acked
)
)
)
;
assert_eq
!
(
rt
.
used
.
iter
(
)
.
nth
(
1
)
.
unwrap
(
)
(
&
13
&
(
2
RangeState
:
:
Sent
)
)
)
;
assert
!
(
rt
.
used
.
iter
(
)
.
nth
(
2
)
.
is_none
(
)
)
;
rt
.
mark_range
(
0
5
RangeState
:
:
Sent
)
;
let
res
=
rt
.
first_unmarked_range
(
)
;
assert_eq
!
(
res
(
10
Some
(
3
)
)
)
;
rt
.
mark_range
(
10
3
RangeState
:
:
Sent
)
;
let
res
=
rt
.
first_unmarked_range
(
)
;
assert_eq
!
(
res
(
15
None
)
)
;
}
#
[
test
]
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
tx_buffer_next_bytes_1
(
)
{
let
mut
txb
=
TxBuffer
:
:
new
(
)
;
assert_eq
!
(
txb
.
avail
(
)
SEND_BUFFER_SIZE
)
;
assert_eq
!
(
txb
.
send
(
&
[
1
;
SEND_BUFFER_SIZE
*
2
]
)
SEND_BUFFER_SIZE
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
0
x
)
)
if
x
.
len
(
)
=
=
SEND_BUFFER_SIZE
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
let
one_byte_from_end
=
SEND_BUFFER_SIZE
as
u64
-
1
;
txb
.
mark_as_sent
(
0
one_byte_from_end
as
usize
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
1
&
&
start
=
=
one_byte_from_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
txb
.
mark_as_sent
(
0
SEND_BUFFER_SIZE
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
None
)
)
;
txb
.
mark_as_lost
(
one_byte_from_end
1
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
1
&
&
start
=
=
one_byte_from_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
let
five_bytes_from_end
=
SEND_BUFFER_SIZE
as
u64
-
5
;
txb
.
mark_as_lost
(
five_bytes_from_end
100
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
5
&
&
start
=
=
five_bytes_from_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
txb
.
mark_as_acked
(
0
five_bytes_from_end
as
usize
)
;
assert_eq
!
(
txb
.
send
(
&
[
2
;
30
]
)
30
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
5
&
&
start
=
=
five_bytes_from_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
assert_eq
!
(
txb
.
retired
five_bytes_from_end
)
;
assert_eq
!
(
txb
.
buffered
(
)
35
)
;
txb
.
mark_as_sent
(
five_bytes_from_end
5
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
30
&
&
start
=
=
SEND_BUFFER_SIZE
as
u64
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
2
)
)
)
;
}
#
[
test
]
fn
tx_buffer_next_bytes_2
(
)
{
let
mut
txb
=
TxBuffer
:
:
new
(
)
;
assert_eq
!
(
txb
.
avail
(
)
SEND_BUFFER_SIZE
)
;
assert_eq
!
(
txb
.
send
(
&
[
1
;
SEND_BUFFER_SIZE
*
2
]
)
SEND_BUFFER_SIZE
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
0
x
)
)
if
x
.
len
(
)
=
=
SEND_BUFFER_SIZE
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
let
forty_bytes_from_end
=
SEND_BUFFER_SIZE
as
u64
-
40
;
txb
.
mark_as_acked
(
0
forty_bytes_from_end
as
usize
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
40
&
&
start
=
=
forty_bytes_from_end
)
)
;
assert_eq
!
(
txb
.
send
(
&
[
2
;
100
]
)
100
)
;
txb
.
mark_as_sent
(
forty_bytes_from_end
10
)
;
let
thirty_bytes_from_end
=
forty_bytes_from_end
+
10
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
30
&
&
start
=
=
thirty_bytes_from_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
let
range_a_start
=
SEND_BUFFER_SIZE
as
u64
+
30
;
let
range_a_end
=
range_a_start
+
10
;
txb
.
mark_as_sent
(
range_a_start
10
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
30
&
&
start
=
=
thirty_bytes_from_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
1
)
)
)
;
let
ten_bytes_past_end
=
SEND_BUFFER_SIZE
as
u64
+
10
;
txb
.
mark_as_acked
(
0
ten_bytes_past_end
as
usize
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
20
&
&
start
=
=
ten_bytes_past_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
2
)
)
)
;
txb
.
mark_as_sent
(
ten_bytes_past_end
20
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
Some
(
(
start
x
)
)
if
x
.
len
(
)
=
=
60
&
&
start
=
=
range_a_end
&
&
x
.
iter
(
)
.
all
(
|
ch
|
*
ch
=
=
2
)
)
)
;
txb
.
mark_as_sent
(
range_a_end
60
)
;
assert
!
(
matches
!
(
txb
.
next_bytes
(
)
None
)
)
;
}
#
[
test
]
fn
test_stream_tx
(
)
{
let
conn_fc
=
connection_fc
(
4096
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
mut
s
=
SendStream
:
:
new
(
4
.
into
(
)
1024
Rc
:
:
clone
(
&
conn_fc
)
conn_events
)
;
let
res
=
s
.
send
(
&
[
4
;
100
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
100
)
;
s
.
mark_as_sent
(
0
50
false
)
;
if
let
SendStreamState
:
:
Send
{
fc
.
.
}
=
s
.
state
(
)
{
assert_eq
!
(
fc
.
used
(
)
100
)
;
}
else
{
panic
!
(
"
unexpected
stream
state
"
)
;
}
let
res
=
s
.
send
(
&
[
4
;
SEND_BUFFER_SIZE
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
1024
-
100
)
;
s
.
set_max_stream_data
(
1024
)
;
let
res
=
s
.
send
(
&
[
4
;
SEND_BUFFER_SIZE
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
0
)
;
s
.
set_max_stream_data
(
1_048_576
)
;
let
res
=
s
.
send
(
&
[
4
;
SEND_BUFFER_SIZE
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
3072
)
;
conn_fc
.
borrow_mut
(
)
.
update
(
SEND_BUFFER_SIZE
as
u64
)
;
let
res
=
s
.
send
(
&
[
4
;
SEND_BUFFER_SIZE
+
100
]
)
.
unwrap
(
)
;
assert_eq
!
(
res
SEND_BUFFER_SIZE
-
4096
)
;
s
.
mark_as_acked
(
0
40
false
)
;
}
#
[
test
]
fn
test_tx_buffer_acks
(
)
{
let
mut
tx
=
TxBuffer
:
:
new
(
)
;
assert_eq
!
(
tx
.
send
(
&
[
4
;
100
]
)
100
)
;
let
res
=
tx
.
next_bytes
(
)
.
unwrap
(
)
;
assert_eq
!
(
res
.
0
0
)
;
assert_eq
!
(
res
.
1
.
len
(
)
100
)
;
tx
.
mark_as_sent
(
0
100
)
;
let
res
=
tx
.
next_bytes
(
)
;
assert_eq
!
(
res
None
)
;
tx
.
mark_as_acked
(
0
100
)
;
let
res
=
tx
.
next_bytes
(
)
;
assert_eq
!
(
res
None
)
;
}
#
[
test
]
fn
send_stream_writable_event_gen
(
)
{
let
conn_fc
=
connection_fc
(
2
)
;
let
mut
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
mut
s
=
SendStream
:
:
new
(
4
.
into
(
)
0
Rc
:
:
clone
(
&
conn_fc
)
conn_events
.
clone
(
)
)
;
assert_eq
!
(
s
.
send
(
b
"
hi
"
)
.
unwrap
(
)
0
)
;
s
.
set_max_stream_data
(
2
)
;
let
evts
=
conn_events
.
events
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
evts
.
len
(
)
1
)
;
assert
!
(
matches
!
(
evts
[
0
]
ConnectionEvent
:
:
SendStreamWritable
{
.
.
}
)
)
;
assert_eq
!
(
s
.
send
(
b
"
hello
"
)
.
unwrap
(
)
2
)
;
s
.
set_max_stream_data
(
4
)
;
assert_eq
!
(
conn_events
.
events
(
)
.
count
(
)
0
)
;
assert_eq
!
(
s
.
send
(
b
"
hello
"
)
.
unwrap
(
)
0
)
;
assert
!
(
conn_fc
.
borrow_mut
(
)
.
update
(
4
)
)
;
assert_eq
!
(
conn_events
.
events
(
)
.
count
(
)
0
)
;
assert_eq
!
(
s
.
avail
(
)
2
)
;
assert_eq
!
(
s
.
send
(
b
"
hello
"
)
.
unwrap
(
)
2
)
;
s
.
set_max_stream_data
(
1_000_000_000
)
;
assert_eq
!
(
conn_events
.
events
(
)
.
count
(
)
0
)
;
conn_fc
.
borrow_mut
(
)
.
update
(
1_000_000_000
)
;
assert_eq
!
(
conn_events
.
events
(
)
.
count
(
)
0
)
;
assert_eq
!
(
s
.
avail
(
)
SEND_BUFFER_SIZE
-
4
)
;
assert_eq
!
(
s
.
send
(
&
[
b
'
a
'
;
SEND_BUFFER_SIZE
]
)
.
unwrap
(
)
SEND_BUFFER_SIZE
-
4
)
;
s
.
set_max_stream_data
(
2_000_000_000
)
;
assert_eq
!
(
conn_events
.
events
(
)
.
count
(
)
0
)
;
assert_eq
!
(
s
.
send
(
b
"
hello
"
)
.
unwrap
(
)
0
)
;
}
#
[
test
]
fn
send_stream_writable_event_new_stream
(
)
{
let
conn_fc
=
connection_fc
(
2
)
;
let
mut
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
_s
=
SendStream
:
:
new
(
4
.
into
(
)
100
conn_fc
conn_events
.
clone
(
)
)
;
let
evts
=
conn_events
.
events
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
evts
.
len
(
)
1
)
;
assert
!
(
matches
!
(
evts
[
0
]
ConnectionEvent
:
:
SendStreamWritable
{
.
.
}
)
)
;
}
fn
as_stream_token
(
t
:
&
RecoveryToken
)
-
>
&
SendStreamRecoveryToken
{
if
let
RecoveryToken
:
:
Stream
(
StreamRecoveryToken
:
:
Stream
(
rt
)
)
=
&
t
{
rt
}
else
{
panic
!
(
)
;
}
}
#
[
test
]
fn
send_stream_get_frame_data
(
)
{
let
conn_fc
=
connection_fc
(
100
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
mut
s
=
SendStream
:
:
new
(
0
.
into
(
)
100
conn_fc
conn_events
)
;
s
.
send
(
&
[
0
;
10
]
)
.
unwrap
(
)
;
s
.
close
(
)
;
let
mut
ss
=
SendStreams
:
:
default
(
)
;
ss
.
insert
(
StreamId
:
:
from
(
0
)
s
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
written
=
builder
.
len
(
)
;
builder
.
set_limit
(
written
+
6
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
assert_eq
!
(
builder
.
len
(
)
written
+
6
)
;
assert_eq
!
(
tokens
.
len
(
)
1
)
;
let
f1_token
=
tokens
.
remove
(
0
)
;
assert
!
(
!
as_stream_token
(
&
f1_token
)
.
fin
)
;
let
written
=
builder
.
len
(
)
;
builder
.
set_limit
(
written
+
200
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
assert_eq
!
(
builder
.
len
(
)
written
+
10
)
;
assert_eq
!
(
tokens
.
len
(
)
1
)
;
let
f2_token
=
tokens
.
remove
(
0
)
;
assert
!
(
as_stream_token
(
&
f2_token
)
.
fin
)
;
let
written
=
builder
.
len
(
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
assert_eq
!
(
builder
.
len
(
)
written
)
;
assert
!
(
tokens
.
is_empty
(
)
)
;
ss
.
lost
(
as_stream_token
(
&
f1_token
)
)
;
let
written
=
builder
.
len
(
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
+
RetransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
assert_eq
!
(
builder
.
len
(
)
written
+
7
)
;
assert_eq
!
(
tokens
.
len
(
)
1
)
;
let
f4_token
=
tokens
.
remove
(
0
)
;
assert
!
(
!
as_stream_token
(
&
f4_token
)
.
fin
)
;
ss
.
lost
(
as_stream_token
(
&
f2_token
)
)
;
let
written
=
builder
.
len
(
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
+
RetransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
assert_eq
!
(
builder
.
len
(
)
written
+
10
)
;
assert_eq
!
(
tokens
.
len
(
)
1
)
;
let
f5_token
=
tokens
.
remove
(
0
)
;
assert
!
(
as_stream_token
(
&
f5_token
)
.
fin
)
;
}
#
[
test
]
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
send_stream_get_frame_zerolength_fin
(
)
{
let
conn_fc
=
connection_fc
(
100
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
mut
s
=
SendStream
:
:
new
(
0
.
into
(
)
100
conn_fc
conn_events
)
;
s
.
send
(
&
[
0
;
10
]
)
.
unwrap
(
)
;
let
mut
ss
=
SendStreams
:
:
default
(
)
;
ss
.
insert
(
StreamId
:
:
from
(
0
)
s
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
let
f1_token
=
tokens
.
remove
(
0
)
;
assert_eq
!
(
as_stream_token
(
&
f1_token
)
.
offset
0
)
;
assert_eq
!
(
as_stream_token
(
&
f1_token
)
.
length
10
)
;
assert
!
(
!
as_stream_token
(
&
f1_token
)
.
fin
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
assert
!
(
tokens
.
is_empty
(
)
)
;
ss
.
get_mut
(
StreamId
:
:
from
(
0
)
)
.
unwrap
(
)
.
close
(
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
let
f2_token
=
tokens
.
remove
(
0
)
;
assert_eq
!
(
as_stream_token
(
&
f2_token
)
.
offset
10
)
;
assert_eq
!
(
as_stream_token
(
&
f2_token
)
.
length
0
)
;
assert
!
(
as_stream_token
(
&
f2_token
)
.
fin
)
;
ss
.
lost
(
as_stream_token
(
&
f2_token
)
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
let
f3_token
=
tokens
.
remove
(
0
)
;
assert_eq
!
(
as_stream_token
(
&
f3_token
)
.
offset
10
)
;
assert_eq
!
(
as_stream_token
(
&
f3_token
)
.
length
0
)
;
assert
!
(
as_stream_token
(
&
f3_token
)
.
fin
)
;
ss
.
lost
(
as_stream_token
(
&
f1_token
)
)
;
ss
.
write_frames
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
;
let
f4_token
=
tokens
.
remove
(
0
)
;
assert_eq
!
(
as_stream_token
(
&
f4_token
)
.
offset
0
)
;
assert_eq
!
(
as_stream_token
(
&
f4_token
)
.
length
10
)
;
assert
!
(
as_stream_token
(
&
f4_token
)
.
fin
)
;
}
#
[
test
]
fn
data_blocked
(
)
{
let
conn_fc
=
connection_fc
(
5
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
stream_id
=
StreamId
:
:
from
(
4
)
;
let
mut
s
=
SendStream
:
:
new
(
stream_id
2
Rc
:
:
clone
(
&
conn_fc
)
conn_events
)
;
assert_eq
!
(
s
.
send
(
b
"
abc
"
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
s
.
next_bytes
(
false
)
Some
(
(
0
&
b
"
ab
"
[
.
.
]
)
)
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
s
.
write_blocked_frame
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
stream_data_blocked
0
)
;
s
.
mark_as_sent
(
0
2
false
)
;
s
.
write_blocked_frame
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
stream_data_blocked
1
)
;
s
.
set_max_stream_data
(
10
)
;
assert_eq
!
(
s
.
send
(
b
"
abcd
"
)
.
unwrap
(
)
3
)
;
assert_eq
!
(
s
.
next_bytes
(
false
)
Some
(
(
2
&
b
"
abc
"
[
.
.
]
)
)
)
;
conn_fc
.
borrow_mut
(
)
.
write_frames
(
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
data_blocked
0
)
;
s
.
mark_as_sent
(
2
3
false
)
;
conn_fc
.
borrow_mut
(
)
.
write_frames
(
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
data_blocked
1
)
;
}
#
[
test
]
fn
data_blocked_atomic
(
)
{
let
conn_fc
=
connection_fc
(
5
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
stream_id
=
StreamId
:
:
from
(
4
)
;
let
mut
s
=
SendStream
:
:
new
(
stream_id
2
Rc
:
:
clone
(
&
conn_fc
)
conn_events
)
;
assert_eq
!
(
s
.
send_atomic
(
b
"
abc
"
)
.
unwrap
(
)
0
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
s
.
write_blocked_frame
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
stream_data_blocked
1
)
;
assert_eq
!
(
s
.
send
(
b
"
abc
"
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
s
.
next_bytes
(
false
)
Some
(
(
0
&
b
"
ab
"
[
.
.
]
)
)
)
;
s
.
mark_as_sent
(
0
2
false
)
;
s
.
set_max_stream_data
(
10
)
;
assert_eq
!
(
s
.
send_atomic
(
b
"
abcd
"
)
.
unwrap
(
)
0
)
;
conn_fc
.
borrow_mut
(
)
.
write_frames
(
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
data_blocked
1
)
;
assert_eq
!
(
s
.
send
(
b
"
abcd
"
)
.
unwrap
(
)
3
)
;
assert_eq
!
(
s
.
next_bytes
(
false
)
Some
(
(
2
&
b
"
abc
"
[
.
.
]
)
)
)
;
s
.
mark_as_sent
(
2
3
false
)
;
s
.
set_max_stream_data
(
15
)
;
conn_fc
.
borrow_mut
(
)
.
update
(
15
)
;
assert_eq
!
(
s
.
send_atomic
(
b
"
abcdefghij
"
)
.
unwrap
(
)
10
)
;
}
#
[
test
]
fn
ack_fin_first
(
)
{
const
MESSAGE
:
&
[
u8
]
=
b
"
hello
"
;
let
len_u64
=
u64
:
:
try_from
(
MESSAGE
.
len
(
)
)
.
unwrap
(
)
;
let
conn_fc
=
connection_fc
(
len_u64
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
mut
s
=
SendStream
:
:
new
(
StreamId
:
:
new
(
100
)
0
conn_fc
conn_events
)
;
s
.
set_max_stream_data
(
len_u64
)
;
let
_
=
s
.
send
(
MESSAGE
)
.
unwrap
(
)
;
s
.
mark_as_sent
(
0
MESSAGE
.
len
(
)
false
)
;
s
.
close
(
)
;
s
.
mark_as_sent
(
len_u64
0
true
)
;
s
.
mark_as_acked
(
len_u64
0
true
)
;
s
.
mark_as_acked
(
0
MESSAGE
.
len
(
)
false
)
;
assert
!
(
s
.
is_terminal
(
)
)
;
}
#
[
test
]
fn
ack_then_lose_fin
(
)
{
const
MESSAGE
:
&
[
u8
]
=
b
"
hello
"
;
let
len_u64
=
u64
:
:
try_from
(
MESSAGE
.
len
(
)
)
.
unwrap
(
)
;
let
conn_fc
=
connection_fc
(
len_u64
)
;
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
id
=
StreamId
:
:
new
(
100
)
;
let
mut
s
=
SendStream
:
:
new
(
id
0
conn_fc
conn_events
)
;
s
.
set_max_stream_data
(
len_u64
)
;
let
_
=
s
.
send
(
MESSAGE
)
.
unwrap
(
)
;
s
.
mark_as_sent
(
0
MESSAGE
.
len
(
)
false
)
;
s
.
close
(
)
;
s
.
mark_as_sent
(
len_u64
0
true
)
;
s
.
mark_as_acked
(
len_u64
0
true
)
;
s
.
mark_as_lost
(
len_u64
0
true
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
s
.
write_stream_frame
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
stream
0
)
;
}
fn
stream_with_sent
(
stream
:
u64
offset
:
usize
)
-
>
SendStream
{
const
MAX_VARINT
:
u64
=
(
1
<
<
62
)
-
1
;
let
conn_fc
=
connection_fc
(
MAX_VARINT
)
;
let
mut
s
=
SendStream
:
:
new
(
StreamId
:
:
from
(
stream
)
MAX_VARINT
conn_fc
ConnectionEvents
:
:
default
(
)
)
;
let
mut
send_buf
=
TxBuffer
:
:
new
(
)
;
send_buf
.
retired
=
u64
:
:
try_from
(
offset
)
.
unwrap
(
)
;
send_buf
.
ranges
.
mark_range
(
0
offset
RangeState
:
:
Acked
)
;
let
mut
fc
=
SenderFlowControl
:
:
new
(
StreamId
:
:
from
(
stream
)
MAX_VARINT
)
;
fc
.
consume
(
offset
)
;
let
conn_fc
=
Rc
:
:
new
(
RefCell
:
:
new
(
SenderFlowControl
:
:
new
(
(
)
MAX_VARINT
)
)
)
;
s
.
state
=
SendStreamState
:
:
Send
{
fc
conn_fc
send_buf
}
;
s
}
fn
frame_sent_sid
(
stream
:
u64
offset
:
usize
len
:
usize
fin
:
bool
space
:
usize
)
-
>
bool
{
const
BUF
:
&
[
u8
]
=
&
[
0x42
;
128
]
;
qtrace
!
(
"
frame_sent
stream
=
{
}
offset
=
{
}
len
=
{
}
fin
=
{
}
space
=
{
}
"
stream
offset
len
fin
space
)
;
let
mut
s
=
stream_with_sent
(
stream
offset
)
;
if
len
>
0
{
s
.
send
(
&
BUF
[
.
.
len
]
)
.
unwrap
(
)
;
}
if
fin
{
s
.
close
(
)
;
}
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
header_len
=
builder
.
len
(
)
;
builder
.
set_limit
(
header_len
+
space
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
s
.
write_stream_frame
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
qtrace
!
(
"
STREAM
frame
:
{
}
"
hex_with_len
(
&
builder
[
header_len
.
.
]
)
)
;
stats
.
stream
>
0
}
fn
frame_sent
(
offset
:
usize
len
:
usize
fin
:
bool
space
:
usize
)
-
>
bool
{
frame_sent_sid
(
0
offset
len
fin
space
)
}
#
[
test
]
fn
stream_frame_empty
(
)
{
assert
!
(
!
frame_sent
(
10
0
false
2
)
)
;
assert
!
(
!
frame_sent
(
10
0
false
3
)
)
;
assert
!
(
!
frame_sent
(
10
0
false
4
)
)
;
assert
!
(
!
frame_sent
(
10
0
false
5
)
)
;
assert
!
(
!
frame_sent
(
10
0
false
100
)
)
;
assert
!
(
!
frame_sent
(
0
0
true
1
)
)
;
assert
!
(
frame_sent
(
0
0
true
2
)
)
;
assert
!
(
!
frame_sent
(
10
0
true
2
)
)
;
assert
!
(
frame_sent
(
10
0
true
3
)
)
;
assert
!
(
frame_sent
(
10
0
true
4
)
)
;
assert
!
(
frame_sent
(
10
0
true
5
)
)
;
assert
!
(
frame_sent
(
10
0
true
100
)
)
;
}
#
[
test
]
fn
stream_frame_minimum
(
)
{
assert
!
(
!
frame_sent
(
10
1
false
3
)
)
;
assert
!
(
!
frame_sent
(
10
1
true
3
)
)
;
assert
!
(
frame_sent
(
10
1
false
4
)
)
;
assert
!
(
frame_sent
(
10
1
true
4
)
)
;
assert
!
(
frame_sent
(
10
1
false
5
)
)
;
assert
!
(
frame_sent
(
10
1
true
5
)
)
;
assert
!
(
frame_sent
(
10
1
false
100
)
)
;
assert
!
(
frame_sent
(
10
1
true
100
)
)
;
}
#
[
test
]
fn
stream_frame_more
(
)
{
assert
!
(
!
frame_sent
(
10
100
false
3
)
)
;
assert
!
(
!
frame_sent
(
10
100
true
3
)
)
;
assert
!
(
frame_sent
(
10
100
false
4
)
)
;
assert
!
(
frame_sent
(
10
100
true
4
)
)
;
assert
!
(
frame_sent
(
10
100
false
5
)
)
;
assert
!
(
frame_sent
(
10
100
true
5
)
)
;
assert
!
(
frame_sent
(
10
100
false
100
)
)
;
assert
!
(
frame_sent
(
10
100
true
100
)
)
;
assert
!
(
frame_sent
(
10
100
false
1000
)
)
;
assert
!
(
frame_sent
(
10
100
true
1000
)
)
;
}
#
[
test
]
fn
stream_frame_big_id
(
)
{
const
BIG
:
u64
=
1
<
<
30
;
const
BIGSZ
:
usize
=
1
<
<
30
;
assert
!
(
!
frame_sent_sid
(
BIG
BIGSZ
0
false
16
)
)
;
assert
!
(
!
frame_sent_sid
(
BIG
BIGSZ
0
true
16
)
)
;
assert
!
(
!
frame_sent_sid
(
BIG
BIGSZ
0
false
17
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
0
true
17
)
)
;
assert
!
(
!
frame_sent_sid
(
BIG
BIGSZ
0
false
18
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
0
true
18
)
)
;
assert
!
(
!
frame_sent_sid
(
BIG
BIGSZ
1
false
17
)
)
;
assert
!
(
!
frame_sent_sid
(
BIG
BIGSZ
1
true
17
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
1
false
18
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
1
true
18
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
1
false
19
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
1
true
19
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
1
false
100
)
)
;
assert
!
(
frame_sent_sid
(
BIG
BIGSZ
1
true
100
)
)
;
}
fn
stream_frame_at_boundary
(
data
:
&
[
u8
]
)
{
fn
send_with_extra_capacity
(
data
:
&
[
u8
]
extra
:
usize
expect_full
:
bool
)
-
>
Vec
<
u8
>
{
qtrace
!
(
"
send_with_extra_capacity
{
}
+
{
}
"
data
.
len
(
)
extra
)
;
let
mut
s
=
stream_with_sent
(
0
0
)
;
s
.
send
(
data
)
.
unwrap
(
)
;
s
.
close
(
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
header_len
=
builder
.
len
(
)
;
builder
.
set_limit
(
header_len
+
data
.
len
(
)
+
2
+
extra
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
s
.
write_stream_frame
(
TransmissionPriority
:
:
default
(
)
&
mut
builder
&
mut
tokens
&
mut
stats
)
;
assert_eq
!
(
stats
.
stream
1
)
;
assert_eq
!
(
builder
.
is_full
(
)
expect_full
)
;
Vec
:
:
from
(
Encoder
:
:
from
(
builder
)
)
.
split_off
(
header_len
)
}
let
mut
enc
=
Encoder
:
:
new
(
)
;
enc
.
encode_varint
(
u64
:
:
try_from
(
data
.
len
(
)
)
.
unwrap
(
)
)
;
let
len_buf
=
Vec
:
:
from
(
enc
)
;
let
minimum_extra
=
len_buf
.
len
(
)
+
PacketBuilder
:
:
MINIMUM_FRAME_SIZE
;
for
i
in
0
.
.
minimum_extra
{
let
frame
=
send_with_extra_capacity
(
data
i
true
)
;
let
(
header
body
)
=
frame
.
split_at
(
2
)
;
assert_eq
!
(
header
&
[
0b1001
0
]
)
;
assert_eq
!
(
body
data
)
;
}
let
frame
=
send_with_extra_capacity
(
data
minimum_extra
false
)
;
let
(
header
rest
)
=
frame
.
split_at
(
2
)
;
assert_eq
!
(
header
&
[
0b1011
0
]
)
;
let
(
len
body
)
=
rest
.
split_at
(
len_buf
.
len
(
)
)
;
assert_eq
!
(
len
&
len_buf
)
;
assert_eq
!
(
body
data
)
;
}
#
[
test
]
fn
stream_frame_16384
(
)
{
stream_frame_at_boundary
(
&
[
4
;
16383
]
)
;
stream_frame_at_boundary
(
&
[
4
;
16384
]
)
;
}
#
[
test
]
fn
stream_frame_64
(
)
{
stream_frame_at_boundary
(
&
[
2
;
63
]
)
;
stream_frame_at_boundary
(
&
[
2
;
64
]
)
;
}
}
