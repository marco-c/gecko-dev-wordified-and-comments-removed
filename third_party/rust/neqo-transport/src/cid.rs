use
std
:
:
{
borrow
:
:
Borrow
cell
:
:
{
Ref
RefCell
}
cmp
:
:
{
max
min
}
ops
:
:
Deref
rc
:
:
Rc
}
;
use
neqo_common
:
:
{
hex
hex_with_len
qinfo
Decoder
Encoder
}
;
use
neqo_crypto
:
:
{
random
randomize
}
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
use
crate
:
:
{
frame
:
:
FRAME_TYPE_NEW_CONNECTION_ID
packet
:
:
PacketBuilder
recovery
:
:
RecoveryToken
stats
:
:
FrameStats
Error
Res
}
;
pub
const
MAX_CONNECTION_ID_LEN
:
usize
=
20
;
pub
const
LOCAL_ACTIVE_CID_LIMIT
:
usize
=
8
;
pub
const
CONNECTION_ID_SEQNO_INITIAL
:
u64
=
0
;
pub
const
CONNECTION_ID_SEQNO_PREFERRED
:
u64
=
1
;
const
CONNECTION_ID_SEQNO_ODCID
:
u64
=
u64
:
:
MAX
;
const
CONNECTION_ID_SEQNO_EMPTY
:
u64
=
u64
:
:
MAX
-
1
;
#
[
derive
(
Clone
Default
Eq
Hash
PartialEq
)
]
pub
struct
ConnectionId
{
pub
(
crate
)
cid
:
SmallVec
<
[
u8
;
MAX_CONNECTION_ID_LEN
]
>
}
impl
ConnectionId
{
#
[
must_use
]
pub
fn
generate
(
len
:
usize
)
-
>
Self
{
assert
!
(
matches
!
(
len
0
.
.
=
MAX_CONNECTION_ID_LEN
)
)
;
let
mut
cid
=
smallvec
!
[
0
;
len
]
;
randomize
(
&
mut
cid
)
;
Self
{
cid
}
}
#
[
must_use
]
pub
fn
generate_initial
(
)
-
>
Self
{
let
v
=
random
:
:
<
1
>
(
)
[
0
]
;
let
len
:
usize
=
max
(
8
5
+
(
v
&
(
v
>
>
4
)
)
)
.
into
(
)
;
Self
:
:
generate
(
len
)
}
#
[
must_use
]
pub
fn
as_cid_ref
(
&
self
)
-
>
ConnectionIdRef
{
ConnectionIdRef
:
:
from
(
&
self
.
cid
[
.
.
]
)
}
}
impl
AsRef
<
[
u8
]
>
for
ConnectionId
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
self
.
borrow
(
)
}
}
impl
Borrow
<
[
u8
]
>
for
ConnectionId
{
fn
borrow
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
cid
}
}
impl
From
<
SmallVec
<
[
u8
;
MAX_CONNECTION_ID_LEN
]
>
>
for
ConnectionId
{
fn
from
(
cid
:
SmallVec
<
[
u8
;
MAX_CONNECTION_ID_LEN
]
>
)
-
>
Self
{
Self
{
cid
}
}
}
impl
<
T
:
AsRef
<
[
u8
]
>
+
?
Sized
>
From
<
&
T
>
for
ConnectionId
{
fn
from
(
buf
:
&
T
)
-
>
Self
{
Self
:
:
from
(
SmallVec
:
:
from
(
buf
.
as_ref
(
)
)
)
}
}
impl
<
'
a
>
From
<
ConnectionIdRef
<
'
a
>
>
for
ConnectionId
{
fn
from
(
cidref
:
ConnectionIdRef
<
'
a
>
)
-
>
Self
{
Self
:
:
from
(
SmallVec
:
:
from
(
cidref
.
cid
)
)
}
}
impl
std
:
:
ops
:
:
Deref
for
ConnectionId
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
cid
}
}
impl
:
:
std
:
:
fmt
:
:
Debug
for
ConnectionId
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
CID
{
}
"
hex_with_len
(
&
self
.
cid
)
)
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
ConnectionId
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
hex
(
&
self
.
cid
)
)
}
}
impl
<
'
a
>
PartialEq
<
ConnectionIdRef
<
'
a
>
>
for
ConnectionId
{
fn
eq
(
&
self
other
:
&
ConnectionIdRef
<
'
a
>
)
-
>
bool
{
&
self
.
cid
[
.
.
]
=
=
other
.
cid
}
}
#
[
derive
(
Hash
Eq
PartialEq
Clone
Copy
)
]
pub
struct
ConnectionIdRef
<
'
a
>
{
cid
:
&
'
a
[
u8
]
}
impl
:
:
std
:
:
fmt
:
:
Debug
for
ConnectionIdRef
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
CID
{
}
"
hex_with_len
(
self
.
cid
)
)
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
ConnectionIdRef
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
hex
(
self
.
cid
)
)
}
}
impl
<
'
a
T
:
AsRef
<
[
u8
]
>
+
?
Sized
>
From
<
&
'
a
T
>
for
ConnectionIdRef
<
'
a
>
{
fn
from
(
cid
:
&
'
a
T
)
-
>
Self
{
Self
{
cid
:
cid
.
as_ref
(
)
}
}
}
impl
std
:
:
ops
:
:
Deref
for
ConnectionIdRef
<
'
_
>
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
self
.
cid
}
}
impl
PartialEq
<
ConnectionId
>
for
ConnectionIdRef
<
'
_
>
{
fn
eq
(
&
self
other
:
&
ConnectionId
)
-
>
bool
{
self
.
cid
=
=
&
other
.
cid
[
.
.
]
}
}
pub
trait
ConnectionIdDecoder
{
fn
decode_cid
<
'
a
>
(
&
self
dec
:
&
mut
Decoder
<
'
a
>
)
-
>
Option
<
ConnectionIdRef
<
'
a
>
>
;
}
pub
trait
ConnectionIdGenerator
:
ConnectionIdDecoder
{
fn
generate_cid
(
&
mut
self
)
-
>
Option
<
ConnectionId
>
;
fn
generates_empty_cids
(
&
self
)
-
>
bool
{
false
}
fn
as_decoder
(
&
self
)
-
>
&
dyn
ConnectionIdDecoder
;
}
#
[
derive
(
Default
)
]
pub
struct
EmptyConnectionIdGenerator
{
}
impl
ConnectionIdDecoder
for
EmptyConnectionIdGenerator
{
fn
decode_cid
<
'
a
>
(
&
self
_
:
&
mut
Decoder
<
'
a
>
)
-
>
Option
<
ConnectionIdRef
<
'
a
>
>
{
Some
(
ConnectionIdRef
:
:
from
(
&
[
]
)
)
}
}
impl
ConnectionIdGenerator
for
EmptyConnectionIdGenerator
{
fn
generate_cid
(
&
mut
self
)
-
>
Option
<
ConnectionId
>
{
Some
(
ConnectionId
:
:
from
(
&
[
]
)
)
}
fn
as_decoder
(
&
self
)
-
>
&
dyn
ConnectionIdDecoder
{
self
}
fn
generates_empty_cids
(
&
self
)
-
>
bool
{
true
}
}
pub
struct
RandomConnectionIdGenerator
{
len
:
usize
}
impl
RandomConnectionIdGenerator
{
#
[
must_use
]
pub
const
fn
new
(
len
:
usize
)
-
>
Self
{
Self
{
len
}
}
}
impl
ConnectionIdDecoder
for
RandomConnectionIdGenerator
{
fn
decode_cid
<
'
a
>
(
&
self
dec
:
&
mut
Decoder
<
'
a
>
)
-
>
Option
<
ConnectionIdRef
<
'
a
>
>
{
dec
.
decode
(
self
.
len
)
.
map
(
ConnectionIdRef
:
:
from
)
}
}
impl
ConnectionIdGenerator
for
RandomConnectionIdGenerator
{
fn
generate_cid
(
&
mut
self
)
-
>
Option
<
ConnectionId
>
{
let
mut
buf
=
smallvec
!
[
0
;
self
.
len
]
;
randomize
(
&
mut
buf
)
;
Some
(
ConnectionId
:
:
from
(
buf
)
)
}
fn
as_decoder
(
&
self
)
-
>
&
dyn
ConnectionIdDecoder
{
self
}
fn
generates_empty_cids
(
&
self
)
-
>
bool
{
self
.
len
=
=
0
}
}
#
[
derive
(
Debug
PartialEq
Eq
Clone
)
]
pub
struct
ConnectionIdEntry
<
SRT
:
Clone
+
PartialEq
>
{
seqno
:
u64
cid
:
ConnectionId
srt
:
SRT
}
impl
ConnectionIdEntry
<
[
u8
;
16
]
>
{
pub
fn
random_srt
(
)
-
>
[
u8
;
16
]
{
random
:
:
<
16
>
(
)
}
pub
fn
initial_remote
(
cid
:
ConnectionId
)
-
>
Self
{
Self
:
:
new
(
CONNECTION_ID_SEQNO_INITIAL
cid
Self
:
:
random_srt
(
)
)
}
pub
fn
empty_remote
(
)
-
>
Self
{
Self
:
:
new
(
CONNECTION_ID_SEQNO_EMPTY
ConnectionId
:
:
from
(
&
[
]
)
Self
:
:
random_srt
(
)
)
}
fn
token_equal
(
a
:
&
[
u8
;
16
]
b
:
&
[
u8
;
16
]
)
-
>
bool
{
let
mut
c
=
0
;
for
(
&
a
&
b
)
in
a
.
iter
(
)
.
zip
(
b
)
{
c
|
=
a
^
b
;
}
c
=
=
0
}
pub
fn
is_stateless_reset
(
&
self
token
:
&
[
u8
;
16
]
)
-
>
bool
{
(
self
.
seqno
<
(
1
<
<
62
)
)
&
&
Self
:
:
token_equal
(
&
self
.
srt
token
)
}
fn
any_part_equal
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
seqno
=
=
other
.
seqno
|
|
self
.
cid
=
=
other
.
cid
|
|
self
.
srt
=
=
other
.
srt
}
pub
const
fn
sequence_number
(
&
self
)
-
>
u64
{
self
.
seqno
}
pub
fn
write
(
&
self
builder
:
&
mut
PacketBuilder
stats
:
&
mut
FrameStats
)
-
>
bool
{
let
len
=
1
+
Encoder
:
:
varint_len
(
self
.
seqno
)
+
1
+
1
+
self
.
cid
.
len
(
)
+
16
;
if
builder
.
remaining
(
)
<
len
{
return
false
;
}
builder
.
encode_varint
(
FRAME_TYPE_NEW_CONNECTION_ID
)
;
builder
.
encode_varint
(
self
.
seqno
)
;
builder
.
encode_varint
(
0u64
)
;
builder
.
encode_vec
(
1
&
self
.
cid
)
;
builder
.
encode
(
&
self
.
srt
)
;
stats
.
new_connection_id
+
=
1
;
true
}
}
impl
ConnectionIdEntry
<
(
)
>
{
pub
const
fn
initial_local
(
cid
:
ConnectionId
)
-
>
Self
{
Self
:
:
new
(
0
cid
(
)
)
}
}
impl
<
SRT
:
Clone
+
PartialEq
>
ConnectionIdEntry
<
SRT
>
{
pub
const
fn
new
(
seqno
:
u64
cid
:
ConnectionId
srt
:
SRT
)
-
>
Self
{
Self
{
seqno
cid
srt
}
}
pub
fn
set_stateless_reset_token
(
&
mut
self
srt
:
SRT
)
{
assert_eq
!
(
self
.
seqno
CONNECTION_ID_SEQNO_INITIAL
)
;
self
.
srt
=
srt
;
}
pub
fn
update_cid
(
&
mut
self
cid
:
ConnectionId
)
{
assert_eq
!
(
self
.
seqno
CONNECTION_ID_SEQNO_INITIAL
)
;
self
.
cid
=
cid
;
}
pub
const
fn
connection_id
(
&
self
)
-
>
&
ConnectionId
{
&
self
.
cid
}
pub
const
fn
reset_token
(
&
self
)
-
>
&
SRT
{
&
self
.
srt
}
}
pub
type
RemoteConnectionIdEntry
=
ConnectionIdEntry
<
[
u8
;
16
]
>
;
#
[
derive
(
Debug
Default
)
]
pub
struct
ConnectionIdStore
<
SRT
:
Clone
+
PartialEq
>
{
cids
:
SmallVec
<
[
ConnectionIdEntry
<
SRT
>
;
8
]
>
}
impl
<
SRT
:
Clone
+
PartialEq
>
ConnectionIdStore
<
SRT
>
{
pub
fn
retire
(
&
mut
self
seqno
:
u64
)
{
self
.
cids
.
retain
(
|
c
|
c
.
seqno
!
=
seqno
)
;
}
pub
fn
contains
(
&
self
cid
:
ConnectionIdRef
)
-
>
bool
{
self
.
cids
.
iter
(
)
.
any
(
|
c
|
c
.
cid
=
=
cid
)
}
pub
fn
next
(
&
mut
self
)
-
>
Option
<
ConnectionIdEntry
<
SRT
>
>
{
if
self
.
cids
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
cids
.
remove
(
0
)
)
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
cids
.
len
(
)
}
}
impl
ConnectionIdStore
<
[
u8
;
16
]
>
{
pub
fn
add_remote
(
&
mut
self
entry
:
ConnectionIdEntry
<
[
u8
;
16
]
>
)
-
>
Res
<
(
)
>
{
if
self
.
cids
.
iter
(
)
.
any
(
|
c
|
c
=
=
&
entry
)
{
return
Ok
(
(
)
)
;
}
if
self
.
cids
.
iter
(
)
.
any
(
|
c
|
c
.
any_part_equal
(
&
entry
)
)
{
qinfo
!
(
"
ConnectionIdStore
found
reused
part
in
NEW_CONNECTION_ID
"
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
if
let
Err
(
idx
)
=
self
.
cids
.
binary_search_by_key
(
&
entry
.
seqno
|
e
|
e
.
seqno
)
{
self
.
cids
.
insert
(
idx
entry
)
;
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
ProtocolViolation
)
}
}
pub
fn
retire_prior_to
(
&
mut
self
retire_prior
:
u64
)
-
>
Vec
<
u64
>
{
let
mut
retired
=
Vec
:
:
new
(
)
;
self
.
cids
.
retain
(
|
e
|
{
if
e
.
seqno
<
retire_prior
{
retired
.
push
(
e
.
seqno
)
;
false
}
else
{
true
}
}
)
;
retired
}
}
impl
ConnectionIdStore
<
(
)
>
{
fn
add_local
(
&
mut
self
entry
:
ConnectionIdEntry
<
(
)
>
)
{
self
.
cids
.
push
(
entry
)
;
}
}
pub
struct
ConnectionIdDecoderRef
<
'
a
>
{
generator
:
Ref
<
'
a
dyn
ConnectionIdGenerator
>
}
impl
<
'
a
:
'
b
'
b
>
ConnectionIdDecoderRef
<
'
a
>
{
pub
fn
as_ref
(
&
'
a
self
)
-
>
&
'
b
dyn
ConnectionIdDecoder
{
self
.
generator
.
as_decoder
(
)
}
}
pub
struct
ConnectionIdManager
{
generator
:
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
connection_ids
:
ConnectionIdStore
<
(
)
>
limit
:
usize
next_seqno
:
u64
lost_new_connection_id
:
Vec
<
ConnectionIdEntry
<
[
u8
;
16
]
>
>
}
impl
ConnectionIdManager
{
pub
fn
new
(
generator
:
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
initial
:
ConnectionId
)
-
>
Self
{
let
mut
connection_ids
=
ConnectionIdStore
:
:
default
(
)
;
connection_ids
.
add_local
(
ConnectionIdEntry
:
:
initial_local
(
initial
)
)
;
Self
{
generator
connection_ids
limit
:
2
next_seqno
:
1
lost_new_connection_id
:
Vec
:
:
new
(
)
}
}
pub
fn
generator
(
&
self
)
-
>
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
{
Rc
:
:
clone
(
&
self
.
generator
)
}
pub
fn
decoder
(
&
self
)
-
>
ConnectionIdDecoderRef
{
ConnectionIdDecoderRef
{
generator
:
self
.
generator
.
deref
(
)
.
borrow
(
)
}
}
pub
fn
preferred_address_cid
(
&
mut
self
)
-
>
Res
<
(
ConnectionId
[
u8
;
16
]
)
>
{
if
self
.
generator
.
deref
(
)
.
borrow
(
)
.
generates_empty_cids
(
)
{
return
Err
(
Error
:
:
ConnectionIdsExhausted
)
;
}
if
let
Some
(
cid
)
=
self
.
generator
.
borrow_mut
(
)
.
generate_cid
(
)
{
assert_ne
!
(
cid
.
len
(
)
0
)
;
debug_assert_eq
!
(
self
.
next_seqno
CONNECTION_ID_SEQNO_PREFERRED
)
;
self
.
connection_ids
.
add_local
(
ConnectionIdEntry
:
:
new
(
self
.
next_seqno
cid
.
clone
(
)
(
)
)
)
;
self
.
next_seqno
+
=
1
;
let
srt
=
ConnectionIdEntry
:
:
random_srt
(
)
;
Ok
(
(
cid
srt
)
)
}
else
{
Err
(
Error
:
:
ConnectionIdsExhausted
)
}
}
pub
fn
is_valid
(
&
self
cid
:
ConnectionIdRef
)
-
>
bool
{
self
.
connection_ids
.
contains
(
cid
)
}
pub
fn
retire
(
&
mut
self
seqno
:
u64
)
{
self
.
connection_ids
.
retire
(
seqno
)
;
self
.
lost_new_connection_id
.
retain
(
|
cid
|
cid
.
seqno
!
=
seqno
)
;
}
pub
fn
add_odcid
(
&
mut
self
cid
:
ConnectionId
)
{
let
entry
=
ConnectionIdEntry
:
:
new
(
CONNECTION_ID_SEQNO_ODCID
cid
(
)
)
;
self
.
connection_ids
.
add_local
(
entry
)
;
}
pub
fn
remove_odcid
(
&
mut
self
)
{
self
.
connection_ids
.
retire
(
CONNECTION_ID_SEQNO_ODCID
)
;
}
pub
fn
set_limit
(
&
mut
self
limit
:
u64
)
{
debug_assert
!
(
limit
>
=
2
)
;
self
.
limit
=
min
(
LOCAL_ACTIVE_CID_LIMIT
usize
:
:
try_from
(
limit
)
.
unwrap_or
(
LOCAL_ACTIVE_CID_LIMIT
)
)
;
}
pub
fn
write_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
if
self
.
generator
.
deref
(
)
.
borrow
(
)
.
generates_empty_cids
(
)
{
debug_assert_eq
!
(
self
.
generator
.
borrow_mut
(
)
.
generate_cid
(
)
.
unwrap
(
)
.
len
(
)
0
)
;
return
;
}
while
let
Some
(
entry
)
=
self
.
lost_new_connection_id
.
pop
(
)
{
if
entry
.
write
(
builder
stats
)
{
tokens
.
push
(
RecoveryToken
:
:
NewConnectionId
(
entry
)
)
;
}
else
{
self
.
lost_new_connection_id
.
push
(
entry
)
;
break
;
}
}
while
self
.
connection_ids
.
len
(
)
<
self
.
limit
&
&
builder
.
remaining
(
)
>
=
47
{
let
maybe_cid
=
self
.
generator
.
borrow_mut
(
)
.
generate_cid
(
)
;
if
let
Some
(
cid
)
=
maybe_cid
{
assert_ne
!
(
cid
.
len
(
)
0
)
;
let
srt
=
ConnectionIdEntry
:
:
random_srt
(
)
;
let
seqno
=
self
.
next_seqno
;
self
.
next_seqno
+
=
1
;
self
.
connection_ids
.
add_local
(
ConnectionIdEntry
:
:
new
(
seqno
cid
.
clone
(
)
(
)
)
)
;
let
entry
=
ConnectionIdEntry
:
:
new
(
seqno
cid
srt
)
;
entry
.
write
(
builder
stats
)
;
tokens
.
push
(
RecoveryToken
:
:
NewConnectionId
(
entry
)
)
;
}
}
}
pub
fn
lost
(
&
mut
self
entry
:
&
ConnectionIdEntry
<
[
u8
;
16
]
>
)
{
self
.
lost_new_connection_id
.
push
(
entry
.
clone
(
)
)
;
}
pub
fn
acked
(
&
mut
self
entry
:
&
ConnectionIdEntry
<
[
u8
;
16
]
>
)
{
self
.
lost_new_connection_id
.
retain
(
|
e
|
e
.
seqno
!
=
entry
.
seqno
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
test_fixture
:
:
fixture_init
;
use
crate
:
:
{
cid
:
:
MAX_CONNECTION_ID_LEN
ConnectionId
}
;
#
[
test
]
fn
generate_initial_cid
(
)
{
fixture_init
(
)
;
for
_
in
0
.
.
100
{
let
cid
=
ConnectionId
:
:
generate_initial
(
)
;
assert
!
(
matches
!
(
cid
.
len
(
)
8
.
.
=
MAX_CONNECTION_ID_LEN
)
"
connection
ID
length
{
cid
:
?
}
"
)
;
}
}
}
