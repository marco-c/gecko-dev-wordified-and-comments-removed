use
std
:
:
cmp
:
:
max
;
use
std
:
:
collections
:
:
BTreeMap
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
mem
;
use
smallvec
:
:
SmallVec
;
use
crate
:
:
events
:
:
ConnectionEvents
;
use
crate
:
:
fc
:
:
ReceiverFlowControl
;
use
crate
:
:
frame
:
:
FRAME_TYPE_STOP_SENDING
;
use
crate
:
:
packet
:
:
PacketBuilder
;
use
crate
:
:
recovery
:
:
RecoveryToken
;
use
crate
:
:
send_stream
:
:
SendStreams
;
use
crate
:
:
stats
:
:
FrameStats
;
use
crate
:
:
stream_id
:
:
StreamId
;
use
crate
:
:
{
AppError
Error
Res
}
;
use
neqo_common
:
:
{
qtrace
Role
}
;
const
RX_STREAM_DATA_WINDOW
:
u64
=
0x10_0000
;
pub
const
RECV_BUFFER_SIZE
:
usize
=
RX_STREAM_DATA_WINDOW
as
usize
;
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
RecvStreams
{
streams
:
BTreeMap
<
StreamId
RecvStream
>
}
impl
RecvStreams
{
pub
fn
write_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
for
stream
in
self
.
streams
.
values_mut
(
)
{
stream
.
write_frame
(
builder
tokens
stats
)
;
if
builder
.
is_full
(
)
{
return
;
}
}
}
pub
fn
insert
(
&
mut
self
id
:
StreamId
stream
:
RecvStream
)
{
self
.
streams
.
insert
(
id
stream
)
;
}
pub
fn
get_mut
(
&
mut
self
id
:
StreamId
)
-
>
Res
<
&
mut
RecvStream
>
{
self
.
streams
.
get_mut
(
&
id
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
streams
.
clear
(
)
;
}
pub
fn
clear_terminal
(
&
mut
self
send_streams
:
&
SendStreams
role
:
Role
)
-
>
(
u64
u64
)
{
let
recv_to_remove
=
self
.
streams
.
iter
(
)
.
filter_map
(
|
(
id
stream
)
|
{
if
stream
.
is_terminal
(
)
&
&
(
id
.
is_uni
(
)
|
|
!
send_streams
.
exists
(
*
id
)
)
{
Some
(
*
id
)
}
else
{
None
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
removed_bidi
=
0
;
let
mut
removed_uni
=
0
;
for
id
in
&
recv_to_remove
{
self
.
streams
.
remove
(
&
id
)
;
if
id
.
is_remote_initiated
(
role
)
{
if
id
.
is_bidi
(
)
{
removed_bidi
+
=
1
;
}
else
{
removed_uni
+
=
1
;
}
}
}
(
removed_bidi
removed_uni
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
RxStreamOrderer
{
data_ranges
:
BTreeMap
<
u64
Vec
<
u8
>
>
retired
:
u64
}
impl
RxStreamOrderer
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
inbound_frame
(
&
mut
self
mut
new_start
:
u64
mut
new_data
:
&
[
u8
]
)
{
qtrace
!
(
"
Inbound
data
offset
=
{
}
len
=
{
}
"
new_start
new_data
.
len
(
)
)
;
let
new_end
=
new_start
+
u64
:
:
try_from
(
new_data
.
len
(
)
)
.
unwrap
(
)
;
if
new_end
<
=
self
.
retired
{
return
;
}
if
new_start
<
self
.
retired
{
new_data
=
&
new_data
[
usize
:
:
try_from
(
self
.
retired
-
new_start
)
.
unwrap
(
)
.
.
]
;
new_start
=
self
.
retired
;
}
if
new_data
.
is_empty
(
)
{
return
;
}
let
extend
=
if
let
Some
(
(
&
prev_start
prev_vec
)
)
=
self
.
data_ranges
.
range_mut
(
.
.
=
new_start
)
.
next_back
(
)
{
let
prev_end
=
prev_start
+
u64
:
:
try_from
(
prev_vec
.
len
(
)
)
.
unwrap
(
)
;
if
new_end
>
prev_end
{
let
overlap
=
prev_end
.
saturating_sub
(
new_start
)
;
qtrace
!
(
"
New
frame
{
}
-
{
}
received
overlap
:
{
}
"
new_start
new_end
overlap
)
;
new_start
+
=
overlap
;
new_data
=
&
new_data
[
usize
:
:
try_from
(
overlap
)
.
unwrap
(
)
.
.
]
;
prev_vec
.
len
(
)
<
4096
&
&
prev_end
=
=
new_start
}
else
{
qtrace
!
(
"
Dropping
frame
with
already
-
received
range
{
}
-
{
}
"
new_start
new_end
)
;
return
;
}
}
else
{
qtrace
!
(
"
New
frame
{
}
-
{
}
received
"
new_start
new_end
)
;
false
}
;
let
mut
to_remove
=
SmallVec
:
:
<
[
_
;
8
]
>
:
:
new
(
)
;
let
mut
to_add
=
new_data
;
for
(
&
next_start
next_data
)
in
self
.
data_ranges
.
range_mut
(
new_start
.
.
)
{
let
next_end
=
next_start
+
u64
:
:
try_from
(
next_data
.
len
(
)
)
.
unwrap
(
)
;
let
overlap
=
new_end
.
saturating_sub
(
next_start
)
;
if
overlap
=
=
0
{
break
;
}
else
if
next_end
>
=
new_end
{
qtrace
!
(
"
New
frame
{
}
-
{
}
overlaps
with
next
frame
by
{
}
truncating
"
new_start
new_end
overlap
)
;
let
truncate_to
=
new_data
.
len
(
)
-
usize
:
:
try_from
(
overlap
)
.
unwrap
(
)
;
to_add
=
&
new_data
[
.
.
truncate_to
]
;
break
;
}
else
{
qtrace
!
(
"
New
frame
{
}
-
{
}
spans
entire
next
frame
{
}
-
{
}
replacing
"
new_start
new_end
next_start
next_end
)
;
to_remove
.
push
(
next_start
)
;
}
}
for
start
in
to_remove
{
self
.
data_ranges
.
remove
(
&
start
)
;
}
if
!
to_add
.
is_empty
(
)
{
if
extend
{
let
(
_
buf
)
=
self
.
data_ranges
.
range_mut
(
.
.
=
new_start
)
.
next_back
(
)
.
unwrap
(
)
;
buf
.
extend_from_slice
(
to_add
)
;
}
else
{
self
.
data_ranges
.
insert
(
new_start
to_add
.
to_vec
(
)
)
;
}
}
}
pub
fn
data_ready
(
&
self
)
-
>
bool
{
self
.
data_ranges
.
keys
(
)
.
next
(
)
.
map_or
(
false
|
&
start
|
start
<
=
self
.
retired
)
}
fn
bytes_ready
(
&
self
)
-
>
usize
{
let
mut
prev_end
=
self
.
retired
;
self
.
data_ranges
.
iter
(
)
.
map
(
|
(
start_offset
data
)
|
{
let
data_len
=
data
.
len
(
)
as
u64
-
self
.
retired
.
saturating_sub
(
*
start_offset
)
;
(
start_offset
data_len
)
}
)
.
take_while
(
|
(
start_offset
data_len
)
|
{
if
*
*
start_offset
<
=
prev_end
{
prev_end
+
=
data_len
;
true
}
else
{
false
}
}
)
.
map
(
|
(
_
data_len
)
|
data_len
as
usize
)
.
sum
(
)
}
fn
retired
(
&
self
)
-
>
u64
{
self
.
retired
}
fn
buffered
(
&
self
)
-
>
u64
{
self
.
data_ranges
.
iter
(
)
.
map
(
|
(
&
start
data
)
|
data
.
len
(
)
as
u64
-
(
self
.
retired
.
saturating_sub
(
start
)
)
)
.
sum
(
)
}
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
usize
{
qtrace
!
(
"
Reading
{
}
bytes
{
}
available
"
buf
.
len
(
)
self
.
buffered
(
)
)
;
let
mut
copied
=
0
;
for
(
&
range_start
range_data
)
in
&
mut
self
.
data_ranges
{
let
mut
keep
=
false
;
if
self
.
retired
>
=
range_start
{
let
copy_offset
=
usize
:
:
try_from
(
max
(
range_start
self
.
retired
)
-
range_start
)
.
unwrap
(
)
;
assert
!
(
range_data
.
len
(
)
>
=
copy_offset
)
;
let
available
=
range_data
.
len
(
)
-
copy_offset
;
let
space
=
buf
.
len
(
)
-
copied
;
let
copy_bytes
=
if
available
>
space
{
keep
=
true
;
space
}
else
{
available
}
;
if
copy_bytes
>
0
{
let
copy_slc
=
&
range_data
[
copy_offset
.
.
copy_offset
+
copy_bytes
]
;
buf
[
copied
.
.
copied
+
copy_bytes
]
.
copy_from_slice
(
copy_slc
)
;
copied
+
=
copy_bytes
;
self
.
retired
+
=
u64
:
:
try_from
(
copy_bytes
)
.
unwrap
(
)
;
}
}
else
{
keep
=
true
;
}
if
keep
{
let
mut
keep
=
self
.
data_ranges
.
split_off
(
&
range_start
)
;
mem
:
:
swap
(
&
mut
self
.
data_ranges
&
mut
keep
)
;
return
copied
;
}
}
self
.
data_ranges
.
clear
(
)
;
copied
}
pub
fn
read_to_end
(
&
mut
self
buf
:
&
mut
Vec
<
u8
>
)
-
>
usize
{
let
orig_len
=
buf
.
len
(
)
;
buf
.
resize
(
orig_len
+
self
.
bytes_ready
(
)
0
)
;
self
.
read
(
&
mut
buf
[
orig_len
.
.
]
)
}
fn
highest_seen_offset
(
&
self
)
-
>
u64
{
let
maybe_ooo_last
=
self
.
data_ranges
.
iter
(
)
.
next_back
(
)
.
map
(
|
(
start
data
)
|
*
start
+
data
.
len
(
)
as
u64
)
;
maybe_ooo_last
.
unwrap_or
(
self
.
retired
)
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
dead_code
)
]
enum
RecvStreamState
{
Recv
{
fc
:
ReceiverFlowControl
<
StreamId
>
recv_buf
:
RxStreamOrderer
}
SizeKnown
{
recv_buf
:
RxStreamOrderer
final_size
:
u64
}
DataRecvd
{
recv_buf
:
RxStreamOrderer
}
DataRead
AbortReading
{
frame_needed
:
bool
err
:
AppError
}
ResetRecvd
}
impl
RecvStreamState
{
fn
new
(
max_bytes
:
u64
stream_id
:
StreamId
)
-
>
Self
{
Self
:
:
Recv
{
fc
:
ReceiverFlowControl
:
:
new
(
stream_id
max_bytes
)
recv_buf
:
RxStreamOrderer
:
:
new
(
)
}
}
fn
name
(
&
self
)
-
>
&
str
{
match
self
{
Self
:
:
Recv
{
.
.
}
=
>
"
Recv
"
Self
:
:
SizeKnown
{
.
.
}
=
>
"
SizeKnown
"
Self
:
:
DataRecvd
{
.
.
}
=
>
"
DataRecvd
"
Self
:
:
DataRead
=
>
"
DataRead
"
Self
:
:
AbortReading
{
.
.
}
=
>
"
AbortReading
"
Self
:
:
ResetRecvd
=
>
"
ResetRecvd
"
}
}
fn
recv_buf
(
&
self
)
-
>
Option
<
&
RxStreamOrderer
>
{
match
self
{
Self
:
:
Recv
{
recv_buf
.
.
}
|
Self
:
:
SizeKnown
{
recv_buf
.
.
}
|
Self
:
:
DataRecvd
{
recv_buf
}
=
>
Some
(
recv_buf
)
Self
:
:
DataRead
|
Self
:
:
AbortReading
{
.
.
}
|
Self
:
:
ResetRecvd
=
>
None
}
}
fn
final_size
(
&
self
)
-
>
Option
<
u64
>
{
match
self
{
Self
:
:
SizeKnown
{
final_size
.
.
}
=
>
Some
(
*
final_size
)
_
=
>
None
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
RecvStream
{
stream_id
:
StreamId
state
:
RecvStreamState
conn_events
:
ConnectionEvents
}
impl
RecvStream
{
pub
fn
new
(
stream_id
:
StreamId
max_stream_data
:
u64
conn_events
:
ConnectionEvents
)
-
>
Self
{
Self
{
stream_id
state
:
RecvStreamState
:
:
new
(
max_stream_data
stream_id
)
conn_events
}
}
fn
set_state
(
&
mut
self
new_state
:
RecvStreamState
)
{
debug_assert_ne
!
(
mem
:
:
discriminant
(
&
self
.
state
)
mem
:
:
discriminant
(
&
new_state
)
)
;
qtrace
!
(
"
RecvStream
{
}
state
{
}
-
>
{
}
"
self
.
stream_id
.
as_u64
(
)
self
.
state
.
name
(
)
new_state
.
name
(
)
)
;
if
let
RecvStreamState
:
:
DataRead
=
new_state
{
self
.
conn_events
.
recv_stream_complete
(
self
.
stream_id
)
;
}
self
.
state
=
new_state
;
}
pub
fn
inbound_stream_frame
(
&
mut
self
fin
:
bool
offset
:
u64
data
:
&
[
u8
]
)
-
>
Res
<
(
)
>
{
let
already_data_ready
=
self
.
data_ready
(
)
;
let
new_end
=
offset
+
u64
:
:
try_from
(
data
.
len
(
)
)
.
unwrap
(
)
;
if
let
Some
(
final_size
)
=
self
.
state
.
final_size
(
)
{
if
new_end
>
final_size
|
|
(
fin
&
&
new_end
!
=
final_size
)
{
return
Err
(
Error
:
:
FinalSizeError
)
;
}
}
match
&
mut
self
.
state
{
RecvStreamState
:
:
Recv
{
recv_buf
fc
.
.
}
=
>
{
if
new_end
!
=
0
&
&
!
fc
.
check_allowed
(
new_end
-
1
)
{
qtrace
!
(
"
Stream
RX
window
exceeded
:
{
}
"
new_end
)
;
return
Err
(
Error
:
:
FlowControlError
)
;
}
if
fin
{
let
final_size
=
offset
+
data
.
len
(
)
as
u64
;
if
final_size
<
recv_buf
.
highest_seen_offset
(
)
{
return
Err
(
Error
:
:
FinalSizeError
)
;
}
recv_buf
.
inbound_frame
(
offset
data
)
;
let
buf
=
mem
:
:
replace
(
recv_buf
RxStreamOrderer
:
:
new
(
)
)
;
if
final_size
=
=
buf
.
retired
(
)
+
buf
.
bytes_ready
(
)
as
u64
{
self
.
set_state
(
RecvStreamState
:
:
DataRecvd
{
recv_buf
:
buf
}
)
;
}
else
{
self
.
set_state
(
RecvStreamState
:
:
SizeKnown
{
recv_buf
:
buf
final_size
}
)
;
}
}
else
{
recv_buf
.
inbound_frame
(
offset
data
)
;
}
}
RecvStreamState
:
:
SizeKnown
{
recv_buf
final_size
}
=
>
{
recv_buf
.
inbound_frame
(
offset
data
)
;
if
*
final_size
=
=
recv_buf
.
retired
(
)
+
recv_buf
.
bytes_ready
(
)
as
u64
{
let
buf
=
mem
:
:
replace
(
recv_buf
RxStreamOrderer
:
:
new
(
)
)
;
self
.
set_state
(
RecvStreamState
:
:
DataRecvd
{
recv_buf
:
buf
}
)
;
}
}
RecvStreamState
:
:
DataRecvd
{
.
.
}
|
RecvStreamState
:
:
DataRead
|
RecvStreamState
:
:
AbortReading
{
.
.
}
|
RecvStreamState
:
:
ResetRecvd
=
>
{
qtrace
!
(
"
data
received
when
we
are
in
state
{
}
"
self
.
state
.
name
(
)
)
}
}
if
!
already_data_ready
&
&
(
self
.
data_ready
(
)
|
|
self
.
needs_to_inform_app_about_fin
(
)
)
{
self
.
conn_events
.
recv_stream_readable
(
self
.
stream_id
)
}
Ok
(
(
)
)
}
pub
fn
reset
(
&
mut
self
application_error_code
:
AppError
)
{
match
self
.
state
{
RecvStreamState
:
:
Recv
{
.
.
}
|
RecvStreamState
:
:
SizeKnown
{
.
.
}
|
RecvStreamState
:
:
AbortReading
{
.
.
}
=
>
{
self
.
conn_events
.
recv_stream_reset
(
self
.
stream_id
application_error_code
)
;
self
.
set_state
(
RecvStreamState
:
:
ResetRecvd
)
;
}
_
=
>
{
}
}
}
pub
fn
maybe_send_flowc_update
(
&
mut
self
)
{
if
let
RecvStreamState
:
:
Recv
{
fc
recv_buf
}
=
&
mut
self
.
state
{
fc
.
retired
(
recv_buf
.
retired
(
)
)
;
}
}
pub
fn
send_flowc_update
(
&
mut
self
)
{
if
let
RecvStreamState
:
:
Recv
{
fc
.
.
}
=
&
mut
self
.
state
{
fc
.
send_flowc_update
(
)
;
}
}
pub
fn
set_stream_max_data
(
&
mut
self
max_data
:
u64
)
{
if
let
RecvStreamState
:
:
Recv
{
fc
.
.
}
=
&
mut
self
.
state
{
fc
.
set_max_active
(
max_data
)
;
}
}
pub
fn
is_terminal
(
&
self
)
-
>
bool
{
matches
!
(
self
.
state
RecvStreamState
:
:
ResetRecvd
|
RecvStreamState
:
:
DataRead
)
}
fn
needs_to_inform_app_about_fin
(
&
self
)
-
>
bool
{
matches
!
(
self
.
state
RecvStreamState
:
:
DataRecvd
{
.
.
}
)
}
fn
data_ready
(
&
self
)
-
>
bool
{
self
.
state
.
recv_buf
(
)
.
map_or
(
false
RxStreamOrderer
:
:
data_ready
)
}
pub
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Res
<
(
usize
bool
)
>
{
let
res
=
match
&
mut
self
.
state
{
RecvStreamState
:
:
Recv
{
recv_buf
.
.
}
|
RecvStreamState
:
:
SizeKnown
{
recv_buf
.
.
}
=
>
Ok
(
(
recv_buf
.
read
(
buf
)
false
)
)
RecvStreamState
:
:
DataRecvd
{
recv_buf
}
=
>
{
let
bytes_read
=
recv_buf
.
read
(
buf
)
;
let
fin_read
=
recv_buf
.
buffered
(
)
=
=
0
;
if
fin_read
{
self
.
set_state
(
RecvStreamState
:
:
DataRead
)
;
}
Ok
(
(
bytes_read
fin_read
)
)
}
RecvStreamState
:
:
DataRead
|
RecvStreamState
:
:
AbortReading
{
.
.
}
|
RecvStreamState
:
:
ResetRecvd
=
>
Err
(
Error
:
:
NoMoreData
)
}
;
self
.
maybe_send_flowc_update
(
)
;
res
}
pub
fn
stop_sending
(
&
mut
self
err
:
AppError
)
{
qtrace
!
(
"
stop_sending
called
when
in
state
{
}
"
self
.
state
.
name
(
)
)
;
match
&
self
.
state
{
RecvStreamState
:
:
Recv
{
.
.
}
|
RecvStreamState
:
:
SizeKnown
{
.
.
}
=
>
{
self
.
set_state
(
RecvStreamState
:
:
AbortReading
{
frame_needed
:
true
err
}
)
}
RecvStreamState
:
:
DataRecvd
{
.
.
}
=
>
self
.
set_state
(
RecvStreamState
:
:
DataRead
)
RecvStreamState
:
:
DataRead
|
RecvStreamState
:
:
AbortReading
{
.
.
}
|
RecvStreamState
:
:
ResetRecvd
=
>
{
}
}
}
pub
fn
write_frame
(
&
mut
self
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
match
&
mut
self
.
state
{
RecvStreamState
:
:
Recv
{
fc
.
.
}
=
>
fc
.
write_frames
(
builder
tokens
stats
)
RecvStreamState
:
:
AbortReading
{
frame_needed
err
}
=
>
{
if
*
frame_needed
&
&
builder
.
write_varint_frame
(
&
[
FRAME_TYPE_STOP_SENDING
self
.
stream_id
.
as_u64
(
)
*
err
]
)
{
tokens
.
push
(
RecoveryToken
:
:
StopSending
{
stream_id
:
self
.
stream_id
}
)
;
stats
.
stop_sending
+
=
1
;
*
frame_needed
=
false
;
}
}
_
=
>
{
}
}
}
pub
fn
max_stream_data_lost
(
&
mut
self
maximum_data
:
u64
)
{
if
let
RecvStreamState
:
:
Recv
{
fc
.
.
}
=
&
mut
self
.
state
{
fc
.
frame_lost
(
maximum_data
)
;
}
}
pub
fn
stop_sending_lost
(
&
mut
self
)
{
if
let
RecvStreamState
:
:
AbortReading
{
frame_needed
.
.
}
=
&
mut
self
.
state
{
*
frame_needed
=
true
;
}
}
pub
fn
stop_sending_acked
(
&
mut
self
)
{
if
let
RecvStreamState
:
:
AbortReading
{
.
.
}
=
&
mut
self
.
state
{
self
.
set_state
(
RecvStreamState
:
:
ResetRecvd
)
;
}
}
#
[
cfg
(
test
)
]
pub
fn
has_frames_to_write
(
&
self
)
-
>
bool
{
if
let
RecvStreamState
:
:
Recv
{
fc
.
.
}
=
&
self
.
state
{
fc
.
frame_needed
(
)
.
is_some
(
)
}
else
{
false
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
neqo_common
:
:
Encoder
;
use
std
:
:
ops
:
:
Range
;
fn
recv_ranges
(
ranges
:
&
[
Range
<
u64
>
]
available
:
usize
)
{
const
ZEROES
:
&
[
u8
]
=
&
[
0
;
100
]
;
qtrace
!
(
"
recv_ranges
{
:
?
}
"
ranges
)
;
let
mut
s
=
RxStreamOrderer
:
:
default
(
)
;
for
r
in
ranges
{
let
data
=
&
ZEROES
[
.
.
usize
:
:
try_from
(
r
.
end
-
r
.
start
)
.
unwrap
(
)
]
;
s
.
inbound_frame
(
r
.
start
data
)
;
}
let
mut
buf
=
[
0xff
;
100
]
;
let
mut
total_recvd
=
0
;
loop
{
let
recvd
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
qtrace
!
(
"
recv_ranges
read
{
}
"
recvd
)
;
total_recvd
+
=
recvd
;
if
recvd
=
=
0
{
assert_eq
!
(
total_recvd
available
)
;
break
;
}
}
}
#
[
test
]
fn
recv_noncontiguous
(
)
{
recv_ranges
(
&
[
10
.
.
20
]
0
)
;
}
#
[
test
]
fn
recv_overlap_start
(
)
{
recv_ranges
(
&
[
10
.
.
20
4
.
.
18
0
.
.
4
]
20
)
;
recv_ranges
(
&
[
10
.
.
20
2
.
.
15
0
.
.
2
]
20
)
;
recv_ranges
(
&
[
10
.
.
20
8
.
.
14
0
.
.
8
]
20
)
;
recv_ranges
(
&
[
10
.
.
20
6
.
.
13
0
.
.
6
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
11
.
.
20
4
.
.
18
0
.
.
4
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
11
.
.
20
2
.
.
15
0
.
.
2
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
11
.
.
20
8
.
.
14
0
.
.
8
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
11
.
.
20
6
.
.
13
0
.
.
6
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
12
.
.
20
4
.
.
18
0
.
.
4
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
12
.
.
20
2
.
.
15
0
.
.
2
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
12
.
.
20
8
.
.
14
0
.
.
8
]
20
)
;
recv_ranges
(
&
[
10
.
.
11
12
.
.
20
6
.
.
13
0
.
.
6
]
20
)
;
}
#
[
test
]
fn
recv_overlap_end
(
)
{
recv_ranges
(
&
[
10
.
.
20
12
.
.
25
0
.
.
10
]
25
)
;
recv_ranges
(
&
[
10
.
.
20
17
.
.
33
0
.
.
10
]
33
)
;
recv_ranges
(
&
[
10
.
.
20
15
.
.
21
0
.
.
10
]
21
)
;
recv_ranges
(
&
[
10
.
.
20
17
.
.
25
0
.
.
10
]
25
)
;
recv_ranges
(
&
[
10
.
.
19
19
.
.
20
12
.
.
25
0
.
.
10
]
25
)
;
recv_ranges
(
&
[
10
.
.
19
19
.
.
20
17
.
.
33
0
.
.
10
]
33
)
;
recv_ranges
(
&
[
10
.
.
19
19
.
.
20
15
.
.
21
0
.
.
10
]
21
)
;
recv_ranges
(
&
[
10
.
.
19
19
.
.
20
17
.
.
25
0
.
.
10
]
25
)
;
recv_ranges
(
&
[
10
.
.
18
19
.
.
20
12
.
.
25
0
.
.
10
]
25
)
;
recv_ranges
(
&
[
10
.
.
18
19
.
.
20
17
.
.
33
0
.
.
10
]
33
)
;
recv_ranges
(
&
[
10
.
.
18
19
.
.
20
15
.
.
21
0
.
.
10
]
21
)
;
recv_ranges
(
&
[
10
.
.
18
19
.
.
20
17
.
.
25
0
.
.
10
]
25
)
;
}
#
[
test
]
fn
recv_overlap_complete
(
)
{
recv_ranges
(
&
[
10
.
.
20
9
.
.
23
0
.
.
9
]
23
)
;
recv_ranges
(
&
[
10
.
.
20
3
.
.
23
0
.
.
3
]
23
)
;
recv_ranges
(
&
[
10
.
.
20
5
.
.
20
0
.
.
5
]
20
)
;
recv_ranges
(
&
[
10
.
.
20
10
.
.
27
0
.
.
10
]
27
)
;
recv_ranges
(
&
[
10
.
.
20
0
.
.
23
]
23
)
;
recv_ranges
(
&
[
10
.
.
14
14
.
.
20
9
.
.
23
0
.
.
9
]
23
)
;
recv_ranges
(
&
[
10
.
.
14
14
.
.
20
3
.
.
23
0
.
.
3
]
23
)
;
recv_ranges
(
&
[
10
.
.
14
14
.
.
20
5
.
.
20
0
.
.
5
]
20
)
;
recv_ranges
(
&
[
10
.
.
14
14
.
.
20
10
.
.
27
0
.
.
10
]
27
)
;
recv_ranges
(
&
[
10
.
.
14
14
.
.
20
0
.
.
23
]
23
)
;
recv_ranges
(
&
[
10
.
.
13
14
.
.
20
9
.
.
23
0
.
.
9
]
23
)
;
recv_ranges
(
&
[
10
.
.
13
14
.
.
20
3
.
.
23
0
.
.
3
]
23
)
;
recv_ranges
(
&
[
10
.
.
13
14
.
.
20
5
.
.
20
0
.
.
5
]
20
)
;
recv_ranges
(
&
[
10
.
.
13
14
.
.
20
10
.
.
27
0
.
.
10
]
27
)
;
recv_ranges
(
&
[
10
.
.
13
14
.
.
20
0
.
.
23
]
23
)
;
}
#
[
test
]
fn
recv_overlap_duplicate
(
)
{
recv_ranges
(
&
[
10
.
.
20
11
.
.
12
0
.
.
10
]
20
)
;
recv_ranges
(
&
[
10
.
.
20
10
.
.
15
0
.
.
10
]
20
)
;
recv_ranges
(
&
[
10
.
.
20
14
.
.
20
0
.
.
10
]
20
)
;
recv_ranges
(
&
[
10
.
.
14
14
.
.
20
10
.
.
15
0
.
.
10
]
20
)
;
recv_ranges
(
&
[
10
.
.
15
16
.
.
20
21
.
.
25
10
.
.
25
0
.
.
10
]
25
)
;
}
#
[
test
]
fn
stop_reading_at_chunk
(
)
{
const
CHUNK_SIZE
:
usize
=
10
;
const
EXTRA_SIZE
:
usize
=
3
;
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
0
&
[
0
;
CHUNK_SIZE
]
)
;
let
offset
=
u64
:
:
try_from
(
CHUNK_SIZE
)
.
unwrap
(
)
;
s
.
inbound_frame
(
offset
&
[
0
;
EXTRA_SIZE
]
)
;
let
offset
=
u64
:
:
try_from
(
CHUNK_SIZE
+
EXTRA_SIZE
)
.
unwrap
(
)
;
s
.
inbound_frame
(
offset
&
[
0
;
EXTRA_SIZE
]
)
;
let
mut
buf
=
vec
!
[
0
;
100
]
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
CHUNK_SIZE
]
)
;
assert_eq
!
(
count
CHUNK_SIZE
)
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
count
EXTRA_SIZE
*
2
)
;
}
#
[
test
]
fn
recv_overlap_while_reading
(
)
{
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
0
&
[
0
;
150
]
)
;
assert_eq
!
(
s
.
data_ranges
.
get
(
&
0
)
.
unwrap
(
)
.
len
(
)
150
)
;
let
mut
buf
=
[
0
;
100
]
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
count
100
)
;
assert_eq
!
(
s
.
retired
100
)
;
s
.
inbound_frame
(
120
&
[
0
;
60
]
)
;
assert_eq
!
(
s
.
data_ranges
.
get
(
&
0
)
.
unwrap
(
)
.
len
(
)
180
)
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
count
80
)
;
}
#
[
test
]
fn
stop_reading_at_gap
(
)
{
const
CHUNK_SIZE
:
usize
=
10
;
const
EXTRA_SIZE
:
usize
=
3
;
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
0
&
[
0
;
CHUNK_SIZE
]
)
;
let
offset
=
u64
:
:
try_from
(
CHUNK_SIZE
+
EXTRA_SIZE
)
.
unwrap
(
)
;
s
.
inbound_frame
(
offset
&
[
0
;
EXTRA_SIZE
]
)
;
let
mut
buf
=
[
0
;
100
]
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
CHUNK_SIZE
]
)
;
assert_eq
!
(
count
CHUNK_SIZE
)
;
let
offset
=
u64
:
:
try_from
(
CHUNK_SIZE
)
.
unwrap
(
)
;
s
.
inbound_frame
(
offset
&
[
0
;
EXTRA_SIZE
]
)
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
count
EXTRA_SIZE
*
2
)
;
}
#
[
test
]
fn
stop_reading_in_chunk
(
)
{
const
CHUNK_SIZE
:
usize
=
10
;
const
EXTRA_SIZE
:
usize
=
3
;
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
0
&
[
0
;
CHUNK_SIZE
]
)
;
let
offset
=
u64
:
:
try_from
(
CHUNK_SIZE
)
.
unwrap
(
)
;
s
.
inbound_frame
(
offset
&
[
0
;
EXTRA_SIZE
]
)
;
let
mut
buf
=
[
0
;
100
]
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
CHUNK_SIZE
-
EXTRA_SIZE
]
)
;
assert_eq
!
(
count
CHUNK_SIZE
-
EXTRA_SIZE
)
;
let
count
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
count
EXTRA_SIZE
*
2
)
;
}
#
[
test
]
fn
read_byte_at_a_time
(
)
{
const
CHUNK_SIZE
:
usize
=
10
;
const
EXTRA_SIZE
:
usize
=
3
;
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
0
&
[
0
;
CHUNK_SIZE
]
)
;
let
offset
=
u64
:
:
try_from
(
CHUNK_SIZE
)
.
unwrap
(
)
;
s
.
inbound_frame
(
offset
&
[
0
;
EXTRA_SIZE
]
)
;
let
mut
buf
=
[
0
;
1
]
;
for
_
in
0
.
.
CHUNK_SIZE
+
EXTRA_SIZE
{
let
count
=
s
.
read
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
count
1
)
;
}
assert_eq
!
(
0
s
.
read
(
&
mut
buf
[
.
.
]
)
)
;
}
#
[
test
]
fn
stream_rx
(
)
{
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
mut
s
=
RecvStream
:
:
new
(
StreamId
:
:
from
(
567
)
1024
conn_events
)
;
s
.
inbound_stream_frame
(
false
0
&
[
1
;
10
]
)
.
unwrap
(
)
;
assert
!
(
s
.
data_ready
(
)
)
;
let
mut
buf
=
vec
!
[
0u8
;
100
]
;
assert_eq
!
(
s
.
read
(
&
mut
buf
)
.
unwrap
(
)
(
10
false
)
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
retired
(
)
10
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
buffered
(
)
0
)
;
s
.
inbound_stream_frame
(
false
12
&
[
2
;
12
]
)
.
unwrap
(
)
;
assert
!
(
!
s
.
data_ready
(
)
)
;
assert_eq
!
(
s
.
read
(
&
mut
buf
)
.
unwrap
(
)
(
0
false
)
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
retired
(
)
10
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
buffered
(
)
12
)
;
s
.
inbound_stream_frame
(
false
14
&
[
3
;
8
]
)
.
unwrap
(
)
;
assert
!
(
!
s
.
data_ready
(
)
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
retired
(
)
10
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
buffered
(
)
12
)
;
s
.
inbound_stream_frame
(
true
10
&
[
4
;
6
]
)
.
unwrap_err
(
)
;
assert
!
(
!
s
.
data_ready
(
)
)
;
assert_eq
!
(
s
.
read
(
&
mut
buf
)
.
unwrap
(
)
(
0
false
)
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
retired
(
)
10
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
buffered
(
)
12
)
;
s
.
inbound_stream_frame
(
false
10
&
[
5
;
10
]
)
.
unwrap
(
)
;
assert
!
(
s
.
data_ready
(
)
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
retired
(
)
10
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
buffered
(
)
14
)
;
s
.
inbound_stream_frame
(
true
24
&
[
6
;
18
]
)
.
unwrap
(
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
retired
(
)
10
)
;
assert_eq
!
(
s
.
state
.
recv_buf
(
)
.
unwrap
(
)
.
buffered
(
)
32
)
;
assert
!
(
s
.
data_ready
(
)
)
;
assert_eq
!
(
s
.
read
(
&
mut
buf
)
.
unwrap
(
)
(
32
true
)
)
;
s
.
read
(
&
mut
buf
)
.
unwrap_err
(
)
;
}
fn
check_chunks
(
s
:
&
mut
RxStreamOrderer
expected
:
&
[
(
u64
usize
)
]
)
{
assert_eq
!
(
s
.
data_ranges
.
len
(
)
expected
.
len
(
)
)
;
for
(
(
start
buf
)
(
expected_start
expected_len
)
)
in
s
.
data_ranges
.
iter
(
)
.
zip
(
expected
)
{
assert_eq
!
(
(
*
start
buf
.
len
(
)
)
(
*
expected_start
*
expected_len
)
)
;
}
}
#
[
test
]
fn
stream_rx_dedupe_tail
(
)
{
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
0
&
[
1
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
6
)
]
)
;
s
.
inbound_frame
(
0
&
[
2
;
3
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
6
)
]
)
;
s
.
inbound_frame
(
2
&
[
3
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
8
)
]
)
;
s
.
inbound_frame
(
4
&
[
4
;
4
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
8
)
]
)
;
s
.
inbound_frame
(
0
&
[
5
;
10
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
10
)
]
)
;
s
.
inbound_frame
(
2
&
[
6
;
2
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
10
)
]
)
;
let
mut
buf
=
[
0
;
16
]
;
assert_eq
!
(
s
.
read
(
&
mut
buf
[
.
.
]
)
10
)
;
assert_eq
!
(
buf
[
.
.
10
]
[
1
1
1
1
1
1
3
3
5
5
]
)
;
}
#
[
test
]
fn
stream_rx_dedupe_head
(
)
{
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
1
&
[
6
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
1
6
)
]
)
;
s
.
inbound_frame
(
0
&
[
7
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
1
)
(
1
6
)
]
)
;
s
.
inbound_frame
(
0
&
[
8
;
7
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
1
)
(
1
6
)
]
)
;
let
mut
buf
=
[
0
;
16
]
;
assert_eq
!
(
s
.
read
(
&
mut
buf
[
.
.
]
)
7
)
;
assert_eq
!
(
buf
[
.
.
7
]
[
7
6
6
6
6
6
6
]
)
;
}
#
[
test
]
fn
stream_rx_dedupe_new_tail
(
)
{
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
1
&
[
6
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
1
6
)
]
)
;
s
.
inbound_frame
(
0
&
[
7
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
1
)
(
1
6
)
]
)
;
s
.
inbound_frame
(
0
&
[
9
;
8
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
8
)
]
)
;
let
mut
buf
=
[
0
;
16
]
;
assert_eq
!
(
s
.
read
(
&
mut
buf
[
.
.
]
)
8
)
;
assert_eq
!
(
buf
[
.
.
8
]
[
7
9
9
9
9
9
9
9
]
)
;
}
#
[
test
]
fn
stream_rx_dedupe_replace
(
)
{
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
s
.
inbound_frame
(
2
&
[
6
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
2
6
)
]
)
;
s
.
inbound_frame
(
1
&
[
7
;
6
]
)
;
check_chunks
(
&
mut
s
&
[
(
1
1
)
(
2
6
)
]
)
;
s
.
inbound_frame
(
0
&
[
9
;
10
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
10
)
]
)
;
let
mut
buf
=
[
0
;
16
]
;
assert_eq
!
(
s
.
read
(
&
mut
buf
[
.
.
]
)
10
)
;
assert_eq
!
(
buf
[
.
.
10
]
[
9
;
10
]
)
;
}
#
[
test
]
fn
trim_retired
(
)
{
let
mut
s
=
RxStreamOrderer
:
:
new
(
)
;
let
mut
buf
=
[
0
;
18
]
;
s
.
inbound_frame
(
0
&
[
1
;
10
]
)
;
assert_eq
!
(
s
.
read
(
&
mut
buf
[
.
.
6
]
)
6
)
;
check_chunks
(
&
mut
s
&
[
(
0
10
)
]
)
;
s
.
inbound_frame
(
3
&
buf
[
.
.
10
]
)
;
check_chunks
(
&
mut
s
&
[
(
0
13
)
]
)
;
assert_eq
!
(
s
.
read
(
&
mut
buf
[
.
.
]
)
7
)
;
assert
!
(
s
.
data_ranges
.
is_empty
(
)
)
;
s
.
inbound_frame
(
0
&
buf
[
.
.
]
)
;
check_chunks
(
&
mut
s
&
[
(
13
5
)
]
)
;
}
#
[
test
]
fn
stream_flowc_update
(
)
{
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
frame1
=
vec
!
[
0
;
RECV_BUFFER_SIZE
]
;
let
mut
s
=
RecvStream
:
:
new
(
StreamId
:
:
from
(
4
)
RX_STREAM_DATA_WINDOW
conn_events
)
;
let
mut
buf
=
vec
!
[
0u8
;
RECV_BUFFER_SIZE
+
100
]
;
s
.
maybe_send_flowc_update
(
)
;
assert
!
(
!
s
.
has_frames_to_write
(
)
)
;
s
.
inbound_stream_frame
(
false
0
&
frame1
)
.
unwrap
(
)
;
s
.
maybe_send_flowc_update
(
)
;
assert
!
(
!
s
.
has_frames_to_write
(
)
)
;
assert_eq
!
(
s
.
read
(
&
mut
buf
)
.
unwrap
(
)
(
RECV_BUFFER_SIZE
false
)
)
;
assert
!
(
!
s
.
data_ready
(
)
)
;
s
.
maybe_send_flowc_update
(
)
;
assert
!
(
s
.
has_frames_to_write
(
)
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
mut
token
=
Vec
:
:
new
(
)
;
s
.
write_frame
(
&
mut
builder
&
mut
token
&
mut
FrameStats
:
:
default
(
)
)
;
s
.
maybe_send_flowc_update
(
)
;
assert
!
(
!
s
.
has_frames_to_write
(
)
)
;
}
#
[
test
]
fn
stream_max_stream_data
(
)
{
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
frame1
=
vec
!
[
0
;
RECV_BUFFER_SIZE
]
;
let
mut
s
=
RecvStream
:
:
new
(
StreamId
:
:
from
(
67
)
RX_STREAM_DATA_WINDOW
conn_events
)
;
s
.
maybe_send_flowc_update
(
)
;
assert
!
(
!
s
.
has_frames_to_write
(
)
)
;
s
.
inbound_stream_frame
(
false
0
&
frame1
)
.
unwrap
(
)
;
s
.
inbound_stream_frame
(
false
RX_STREAM_DATA_WINDOW
&
[
1
;
1
]
)
.
unwrap_err
(
)
;
}
#
[
test
]
fn
stream_orderer_bytes_ready
(
)
{
let
mut
rx_ord
=
RxStreamOrderer
:
:
new
(
)
;
rx_ord
.
inbound_frame
(
0
&
[
1
;
6
]
)
;
assert_eq
!
(
rx_ord
.
bytes_ready
(
)
6
)
;
assert_eq
!
(
rx_ord
.
buffered
(
)
6
)
;
assert_eq
!
(
rx_ord
.
retired
(
)
0
)
;
let
mut
buf
=
[
0u8
;
10
]
;
rx_ord
.
read
(
&
mut
buf
[
.
.
2
]
)
;
assert_eq
!
(
rx_ord
.
bytes_ready
(
)
4
)
;
assert_eq
!
(
rx_ord
.
buffered
(
)
4
)
;
assert_eq
!
(
rx_ord
.
retired
(
)
2
)
;
rx_ord
.
inbound_frame
(
5
&
[
2
;
6
]
)
;
assert_eq
!
(
rx_ord
.
bytes_ready
(
)
9
)
;
assert_eq
!
(
rx_ord
.
buffered
(
)
9
)
;
assert_eq
!
(
rx_ord
.
retired
(
)
2
)
;
rx_ord
.
inbound_frame
(
20
&
[
3
;
6
]
)
;
assert_eq
!
(
rx_ord
.
bytes_ready
(
)
9
)
;
assert_eq
!
(
rx_ord
.
buffered
(
)
15
)
;
assert_eq
!
(
rx_ord
.
retired
(
)
2
)
;
rx_ord
.
inbound_frame
(
0
&
[
4
;
2
]
)
;
assert_eq
!
(
rx_ord
.
bytes_ready
(
)
9
)
;
assert_eq
!
(
rx_ord
.
buffered
(
)
15
)
;
assert_eq
!
(
rx_ord
.
retired
(
)
2
)
;
}
#
[
test
]
fn
no_stream_flowc_event_after_exiting_recv
(
)
{
let
conn_events
=
ConnectionEvents
:
:
default
(
)
;
let
frame1
=
vec
!
[
0
;
RECV_BUFFER_SIZE
]
;
let
stream_id
=
StreamId
:
:
from
(
67
)
;
let
mut
s
=
RecvStream
:
:
new
(
stream_id
RX_STREAM_DATA_WINDOW
conn_events
)
;
s
.
inbound_stream_frame
(
false
0
&
frame1
)
.
unwrap
(
)
;
let
mut
buf
=
[
0
;
RECV_BUFFER_SIZE
]
;
s
.
read
(
&
mut
buf
)
.
unwrap
(
)
;
assert
!
(
s
.
has_frames_to_write
(
)
)
;
s
.
inbound_stream_frame
(
true
RX_STREAM_DATA_WINDOW
&
[
]
)
.
unwrap
(
)
;
assert
!
(
!
s
.
has_frames_to_write
(
)
)
;
}
}
