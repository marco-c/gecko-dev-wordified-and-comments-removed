use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
cmp
:
:
{
max
min
Ordering
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
use
std
:
:
mem
;
use
std
:
:
net
:
:
SocketAddr
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
smallvec
:
:
SmallVec
;
use
neqo_common
:
:
{
hex
hex_snip_middle
matches
qdebug
qerror
qinfo
qlog
:
:
NeqoQlog
qtrace
qwarn
Datagram
Decoder
Encoder
Role
}
;
use
neqo_crypto
:
:
agent
:
:
CertificateInfo
;
use
neqo_crypto
:
:
{
Agent
AntiReplay
AuthenticationStatus
Cipher
Client
HandshakeState
SecretAgentInfo
Server
}
;
use
crate
:
:
cid
:
:
{
ConnectionId
ConnectionIdDecoder
ConnectionIdManager
ConnectionIdRef
}
;
use
crate
:
:
crypto
:
:
{
Crypto
CryptoDxState
}
;
use
crate
:
:
dump
:
:
*
;
use
crate
:
:
events
:
:
{
ConnectionEvent
ConnectionEvents
}
;
use
crate
:
:
flow_mgr
:
:
FlowMgr
;
use
crate
:
:
frame
:
:
{
AckRange
CloseError
Frame
FrameType
StreamType
FRAME_TYPE_CONNECTION_CLOSE_APPLICATION
FRAME_TYPE_CONNECTION_CLOSE_TRANSPORT
}
;
use
crate
:
:
packet
:
:
{
DecryptedPacket
PacketBuilder
PacketNumber
PacketType
PublicPacket
QuicVersion
}
;
use
crate
:
:
path
:
:
Path
;
use
crate
:
:
qlog
;
use
crate
:
:
recovery
:
:
{
LossRecovery
RecoveryToken
SendProfile
GRANULARITY
}
;
use
crate
:
:
recv_stream
:
:
{
RecvStream
RecvStreams
RX_STREAM_DATA_WINDOW
}
;
use
crate
:
:
send_stream
:
:
{
SendStream
SendStreams
}
;
use
crate
:
:
stats
:
:
Stats
;
use
crate
:
:
stream_id
:
:
{
StreamId
StreamIndex
StreamIndexes
}
;
use
crate
:
:
tparams
:
:
{
self
TransportParameter
TransportParameterId
TransportParameters
TransportParametersHandler
}
;
use
crate
:
:
tracking
:
:
{
AckTracker
PNSpace
SentPacket
}
;
use
crate
:
:
{
AppError
ConnectionError
Error
Res
LOCAL_IDLE_TIMEOUT
}
;
#
[
derive
(
Debug
Default
)
]
struct
Packet
(
Vec
<
u8
>
)
;
pub
const
LOCAL_STREAM_LIMIT_BIDI
:
u64
=
16
;
pub
const
LOCAL_STREAM_LIMIT_UNI
:
u64
=
16
;
const
LOCAL_MAX_DATA
:
u64
=
0x3FFF_FFFF_FFFF_FFFF
;
#
[
derive
(
Clone
Debug
PartialEq
Ord
Eq
)
]
pub
enum
State
{
Init
WaitInitial
Handshaking
Connected
Confirmed
Closing
{
error
:
ConnectionError
timeout
:
Instant
}
Draining
{
error
:
ConnectionError
timeout
:
Instant
}
Closed
(
ConnectionError
)
}
impl
State
{
#
[
must_use
]
pub
fn
connected
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Connected
|
Self
:
:
Confirmed
)
}
#
[
must_use
]
pub
fn
closed
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Closing
{
.
.
}
|
Self
:
:
Draining
{
.
.
}
|
Self
:
:
Closed
(
_
)
)
}
}
impl
PartialOrd
for
State
{
#
[
allow
(
clippy
:
:
match_same_arms
)
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
if
mem
:
:
discriminant
(
self
)
=
=
mem
:
:
discriminant
(
other
)
{
return
Some
(
Ordering
:
:
Equal
)
;
}
Some
(
match
(
self
other
)
{
(
Self
:
:
Init
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Init
)
=
>
Ordering
:
:
Greater
(
Self
:
:
WaitInitial
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
WaitInitial
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Handshaking
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Handshaking
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Connected
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Connected
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Confirmed
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Confirmed
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Closing
{
.
.
}
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Closing
{
.
.
}
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Draining
{
.
.
}
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Draining
{
.
.
}
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Closed
(
_
)
_
)
=
>
unreachable
!
(
)
}
)
}
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
ZeroRttState
{
Init
Sending
AcceptedClient
AcceptedServer
Rejected
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
Output
{
None
Datagram
(
Datagram
)
Callback
(
Duration
)
}
impl
Output
{
#
[
must_use
]
pub
fn
dgram
(
self
)
-
>
Option
<
Datagram
>
{
match
self
{
Self
:
:
Datagram
(
dg
)
=
>
Some
(
dg
)
_
=
>
None
}
}
pub
fn
as_dgram_ref
(
&
self
)
-
>
Option
<
&
Datagram
>
{
match
self
{
Self
:
:
Datagram
(
dg
)
=
>
Some
(
dg
)
_
=
>
None
}
}
#
[
must_use
]
pub
fn
callback
(
&
self
)
-
>
Duration
{
match
self
{
Self
:
:
Callback
(
t
)
=
>
*
t
_
=
>
Duration
:
:
new
(
0
0
)
}
}
}
enum
SendOption
{
Yes
(
Datagram
)
No
(
bool
)
}
impl
Default
for
SendOption
{
fn
default
(
)
-
>
Self
{
Self
:
:
No
(
false
)
}
}
type
CidMgr
=
Rc
<
RefCell
<
dyn
ConnectionIdManager
>
>
;
pub
struct
FixedConnectionIdManager
{
len
:
usize
}
impl
FixedConnectionIdManager
{
pub
fn
new
(
len
:
usize
)
-
>
Self
{
Self
{
len
}
}
}
impl
ConnectionIdDecoder
for
FixedConnectionIdManager
{
fn
decode_cid
<
'
a
>
(
&
self
dec
:
&
mut
Decoder
<
'
a
>
)
-
>
Option
<
ConnectionIdRef
<
'
a
>
>
{
dec
.
decode
(
self
.
len
)
.
map
(
ConnectionIdRef
:
:
from
)
}
}
impl
ConnectionIdManager
for
FixedConnectionIdManager
{
fn
generate_cid
(
&
mut
self
)
-
>
ConnectionId
{
ConnectionId
:
:
generate
(
self
.
len
)
}
fn
as_decoder
(
&
self
)
-
>
&
dyn
ConnectionIdDecoder
{
self
}
}
struct
RetryInfo
{
token
:
Vec
<
u8
>
retry_source_cid
:
ConnectionId
}
impl
RetryInfo
{
fn
new
(
retry_source_cid
:
ConnectionId
token
:
Vec
<
u8
>
)
-
>
Self
{
Self
{
token
retry_source_cid
}
}
}
#
[
derive
(
Debug
Clone
)
]
enum
IdleTimeoutState
{
Init
PacketReceived
(
Instant
)
AckElicitingPacketSent
(
Instant
)
}
#
[
derive
(
Debug
Clone
)
]
struct
IdleTimeout
{
timeout
:
Duration
state
:
IdleTimeoutState
}
impl
Default
for
IdleTimeout
{
fn
default
(
)
-
>
Self
{
Self
{
timeout
:
LOCAL_IDLE_TIMEOUT
state
:
IdleTimeoutState
:
:
Init
}
}
}
impl
IdleTimeout
{
pub
fn
set_peer_timeout
(
&
mut
self
peer_timeout
:
Duration
)
{
self
.
timeout
=
min
(
self
.
timeout
peer_timeout
)
;
}
pub
fn
expiry
(
&
self
pto
:
Duration
)
-
>
Option
<
Instant
>
{
match
self
.
state
{
IdleTimeoutState
:
:
Init
=
>
None
IdleTimeoutState
:
:
PacketReceived
(
t
)
|
IdleTimeoutState
:
:
AckElicitingPacketSent
(
t
)
=
>
{
Some
(
t
+
max
(
self
.
timeout
pto
*
3
)
)
}
}
}
fn
on_packet_sent
(
&
mut
self
now
:
Instant
)
{
match
self
.
state
{
IdleTimeoutState
:
:
AckElicitingPacketSent
(
_
)
=
>
{
}
IdleTimeoutState
:
:
Init
|
IdleTimeoutState
:
:
PacketReceived
(
_
)
=
>
{
self
.
state
=
IdleTimeoutState
:
:
AckElicitingPacketSent
(
now
)
;
}
}
}
fn
on_packet_received
(
&
mut
self
now
:
Instant
)
{
self
.
state
=
IdleTimeoutState
:
:
PacketReceived
(
now
)
;
}
pub
fn
expired
(
&
self
now
:
Instant
pto
:
Duration
)
-
>
bool
{
if
let
Some
(
expiry
)
=
self
.
expiry
(
pto
)
{
now
>
=
expiry
}
else
{
false
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
StateSignaling
{
Idle
HandshakeDone
Closing
(
Frame
)
Draining
(
Frame
)
CloseSent
(
Option
<
Frame
>
)
Reset
}
impl
StateSignaling
{
pub
fn
handshake_done
(
&
mut
self
)
{
if
*
self
!
=
Self
:
:
Idle
{
debug_assert
!
(
false
"
StateSignaling
must
be
in
Idle
state
.
"
)
;
return
;
}
*
self
=
Self
:
:
HandshakeDone
}
pub
fn
send_done
(
&
mut
self
)
-
>
Option
<
(
Frame
Option
<
RecoveryToken
>
)
>
{
if
*
self
=
=
Self
:
:
HandshakeDone
{
*
self
=
Self
:
:
Idle
;
Some
(
(
Frame
:
:
HandshakeDone
Some
(
RecoveryToken
:
:
HandshakeDone
)
)
)
}
else
{
None
}
}
fn
make_close_frame
(
error
:
ConnectionError
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
-
>
Frame
{
let
reason_phrase
=
message
.
as_ref
(
)
.
as_bytes
(
)
.
to_owned
(
)
;
Frame
:
:
ConnectionClose
{
error_code
:
CloseError
:
:
from
(
error
)
frame_type
reason_phrase
}
}
pub
fn
close
(
&
mut
self
error
:
ConnectionError
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
{
if
*
self
!
=
Self
:
:
Reset
{
*
self
=
Self
:
:
Closing
(
Self
:
:
make_close_frame
(
error
frame_type
message
)
)
;
}
}
pub
fn
drain
(
&
mut
self
error
:
ConnectionError
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
{
if
*
self
!
=
Self
:
:
Reset
{
*
self
=
Self
:
:
Draining
(
Self
:
:
make_close_frame
(
error
frame_type
message
)
)
;
}
}
pub
fn
close_frame
(
&
mut
self
)
-
>
Option
<
Frame
>
{
match
self
{
Self
:
:
Closing
(
frame
)
=
>
{
let
frame
=
mem
:
:
replace
(
frame
Frame
:
:
Padding
)
;
*
self
=
Self
:
:
CloseSent
(
Some
(
frame
.
clone
(
)
)
)
;
Some
(
frame
)
}
Self
:
:
Draining
(
frame
)
=
>
{
let
frame
=
mem
:
:
replace
(
frame
Frame
:
:
Padding
)
;
*
self
=
Self
:
:
CloseSent
(
None
)
;
Some
(
frame
)
}
_
=
>
None
}
}
pub
fn
send_close
(
&
mut
self
)
{
if
let
Self
:
:
CloseSent
(
Some
(
frame
)
)
=
self
{
let
frame
=
mem
:
:
replace
(
frame
Frame
:
:
Padding
)
;
*
self
=
Self
:
:
Closing
(
frame
)
;
}
}
pub
fn
reset
(
&
mut
self
)
{
*
self
=
Self
:
:
Reset
;
}
}
pub
struct
Connection
{
role
:
Role
state
:
State
tps
:
Rc
<
RefCell
<
TransportParametersHandler
>
>
zero_rtt_state
:
ZeroRttState
cid_manager
:
CidMgr
path
:
Option
<
Path
>
valid_cids
:
Vec
<
ConnectionId
>
retry_info
:
Option
<
RetryInfo
>
local_initial_source_cid
:
ConnectionId
remote_initial_source_cid
:
Option
<
ConnectionId
>
remote_original_destination_cid
:
Option
<
ConnectionId
>
saved_datagram
:
Option
<
(
Datagram
bool
)
>
pub
(
crate
)
crypto
:
Crypto
pub
(
crate
)
acks
:
AckTracker
idle_timeout
:
IdleTimeout
pub
(
crate
)
indexes
:
StreamIndexes
connection_ids
:
HashMap
<
u64
(
Vec
<
u8
>
[
u8
;
16
]
)
>
pub
(
crate
)
send_streams
:
SendStreams
pub
(
crate
)
recv_streams
:
RecvStreams
pub
(
crate
)
flow_mgr
:
Rc
<
RefCell
<
FlowMgr
>
>
state_signaling
:
StateSignaling
loss_recovery
:
LossRecovery
events
:
ConnectionEvents
token
:
Option
<
Vec
<
u8
>
>
stats
:
Stats
qlog
:
Rc
<
RefCell
<
Option
<
NeqoQlog
>
>
>
quic_version
:
QuicVersion
}
impl
Debug
for
Connection
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
Connection
:
{
:
?
}
{
:
?
}
"
self
.
role
self
.
state
self
.
path
)
}
}
impl
Connection
{
pub
fn
new_client
(
server_name
:
&
str
protocols
:
&
[
impl
AsRef
<
str
>
]
cid_manager
:
CidMgr
local_addr
:
SocketAddr
remote_addr
:
SocketAddr
quic_version
:
QuicVersion
)
-
>
Res
<
Self
>
{
let
dcid
=
ConnectionId
:
:
generate_initial
(
)
;
let
mut
c
=
Self
:
:
new
(
Role
:
:
Client
Client
:
:
new
(
server_name
)
?
.
into
(
)
cid_manager
None
protocols
None
quic_version
)
?
;
c
.
crypto
.
states
.
init
(
quic_version
Role
:
:
Client
&
dcid
)
;
c
.
remote_original_destination_cid
=
Some
(
dcid
)
;
c
.
initialize_path
(
local_addr
remote_addr
)
;
Ok
(
c
)
}
pub
fn
new_server
(
certs
:
&
[
impl
AsRef
<
str
>
]
protocols
:
&
[
impl
AsRef
<
str
>
]
anti_replay
:
&
AntiReplay
cid_manager
:
CidMgr
quic_version
:
QuicVersion
)
-
>
Res
<
Self
>
{
Self
:
:
new
(
Role
:
:
Server
Server
:
:
new
(
certs
)
?
.
into
(
)
cid_manager
Some
(
anti_replay
)
protocols
None
quic_version
)
}
fn
set_tp_defaults
(
tps
:
&
mut
TransportParameters
)
{
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
RX_STREAM_DATA_WINDOW
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
RX_STREAM_DATA_WINDOW
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
RX_STREAM_DATA_WINDOW
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_BIDI
LOCAL_STREAM_LIMIT_BIDI
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_UNI
LOCAL_STREAM_LIMIT_UNI
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_DATA
LOCAL_MAX_DATA
)
;
tps
.
set_integer
(
tparams
:
:
IDLE_TIMEOUT
u64
:
:
try_from
(
LOCAL_IDLE_TIMEOUT
.
as_millis
(
)
)
.
unwrap
(
)
)
;
tps
.
set_empty
(
tparams
:
:
DISABLE_MIGRATION
)
;
}
fn
new
(
role
:
Role
agent
:
Agent
cid_manager
:
CidMgr
anti_replay
:
Option
<
&
AntiReplay
>
protocols
:
&
[
impl
AsRef
<
str
>
]
path
:
Option
<
Path
>
quic_version
:
QuicVersion
)
-
>
Res
<
Self
>
{
let
tphandler
=
Rc
:
:
new
(
RefCell
:
:
new
(
TransportParametersHandler
:
:
default
(
)
)
)
;
Self
:
:
set_tp_defaults
(
&
mut
tphandler
.
borrow_mut
(
)
.
local
)
;
let
local_initial_source_cid
=
cid_manager
.
borrow_mut
(
)
.
generate_cid
(
)
;
tphandler
.
borrow_mut
(
)
.
local
.
set_bytes
(
tparams
:
:
INITIAL_SOURCE_CONNECTION_ID
local_initial_source_cid
.
to_vec
(
)
)
;
let
crypto
=
Crypto
:
:
new
(
agent
protocols
tphandler
.
clone
(
)
anti_replay
)
?
;
let
mut
c
=
Self
{
role
state
:
State
:
:
Init
cid_manager
path
valid_cids
:
Vec
:
:
new
(
)
tps
:
tphandler
zero_rtt_state
:
ZeroRttState
:
:
Init
retry_info
:
None
local_initial_source_cid
remote_initial_source_cid
:
None
remote_original_destination_cid
:
None
saved_datagram
:
None
crypto
acks
:
AckTracker
:
:
default
(
)
idle_timeout
:
IdleTimeout
:
:
default
(
)
indexes
:
StreamIndexes
:
:
new
(
)
connection_ids
:
HashMap
:
:
new
(
)
send_streams
:
SendStreams
:
:
default
(
)
recv_streams
:
RecvStreams
:
:
default
(
)
flow_mgr
:
Rc
:
:
new
(
RefCell
:
:
new
(
FlowMgr
:
:
default
(
)
)
)
state_signaling
:
StateSignaling
:
:
Idle
loss_recovery
:
LossRecovery
:
:
new
(
)
events
:
ConnectionEvents
:
:
default
(
)
token
:
None
stats
:
Stats
:
:
default
(
)
qlog
:
Rc
:
:
new
(
RefCell
:
:
new
(
None
)
)
quic_version
}
;
c
.
stats
.
init
(
format
!
(
"
{
}
"
c
)
)
;
Ok
(
c
)
}
pub
fn
path
(
&
self
)
-
>
Option
<
&
Path
>
{
self
.
path
.
as_ref
(
)
}
pub
fn
set_qlog
(
&
mut
self
qlog
:
Option
<
NeqoQlog
>
)
{
let
conn_ql
=
Rc
:
:
new
(
RefCell
:
:
new
(
qlog
)
)
;
self
.
loss_recovery
.
set_qlog
(
conn_ql
.
clone
(
)
)
;
self
.
qlog
=
conn_ql
;
}
pub
fn
qlog_mut
(
&
mut
self
)
-
>
Rc
<
RefCell
<
Option
<
NeqoQlog
>
>
>
{
self
.
qlog
.
clone
(
)
}
pub
fn
set_local_tparam
(
&
self
tp
:
TransportParameterId
value
:
TransportParameter
)
-
>
Res
<
(
)
>
{
if
*
self
.
state
(
)
=
=
State
:
:
Init
{
self
.
tps
.
borrow_mut
(
)
.
local
.
set
(
tp
value
)
;
Ok
(
(
)
)
}
else
{
qerror
!
(
"
Current
state
:
{
:
?
}
"
self
.
state
(
)
)
;
qerror
!
(
"
Cannot
set
local
tparam
when
not
in
an
initial
connection
state
.
"
)
;
Err
(
Error
:
:
ConnectionState
)
}
}
pub
(
crate
)
fn
set_retry_cids
(
&
mut
self
odcid
:
ConnectionId
remote_cid
:
ConnectionId
retry_cid
:
ConnectionId
)
{
debug_assert_eq
!
(
self
.
role
Role
:
:
Server
)
;
qtrace
!
(
[
self
]
"
Retry
CIDs
:
odcid
=
{
}
remote
=
{
}
retry
=
{
}
"
odcid
remote_cid
retry_cid
)
;
let
local_tps
=
&
mut
self
.
tps
.
borrow_mut
(
)
.
local
;
local_tps
.
set_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
odcid
.
to_vec
(
)
)
;
local_tps
.
set_bytes
(
tparams
:
:
RETRY_SOURCE_CONNECTION_ID
retry_cid
.
to_vec
(
)
)
;
self
.
remote_initial_source_cid
=
Some
(
remote_cid
)
;
}
fn
retry_sent
(
&
self
)
-
>
bool
{
self
.
tps
.
borrow
(
)
.
local
.
get_bytes
(
tparams
:
:
RETRY_SOURCE_CONNECTION_ID
)
.
is_some
(
)
}
pub
fn
set_alpn
(
&
mut
self
protocols
:
&
[
impl
AsRef
<
str
>
]
)
-
>
Res
<
(
)
>
{
self
.
crypto
.
tls
.
set_alpn
(
protocols
)
?
;
Ok
(
(
)
)
}
pub
fn
set_ciphers
(
&
mut
self
ciphers
:
&
[
Cipher
]
)
-
>
Res
<
(
)
>
{
if
self
.
state
!
=
State
:
:
Init
{
qerror
!
(
[
self
]
"
Cannot
enable
ciphers
in
state
{
:
?
}
"
self
.
state
)
;
return
Err
(
Error
:
:
ConnectionState
)
;
}
self
.
crypto
.
tls
.
set_ciphers
(
ciphers
)
?
;
Ok
(
(
)
)
}
pub
fn
resumption_token
(
&
self
)
-
>
Option
<
Vec
<
u8
>
>
{
if
self
.
state
<
State
:
:
Connected
{
return
None
;
}
match
self
.
crypto
.
tls
{
Agent
:
:
Client
(
ref
c
)
=
>
match
c
.
resumption_token
(
)
{
Some
(
ref
t
)
=
>
{
qtrace
!
(
"
TLS
token
{
}
"
hex
(
&
t
)
)
;
let
mut
enc
=
Encoder
:
:
default
(
)
;
let
rtt
=
self
.
loss_recovery
.
rtt
(
)
;
let
rtt
=
u64
:
:
try_from
(
rtt
.
as_millis
(
)
)
.
unwrap_or
(
0
)
;
enc
.
encode_varint
(
rtt
)
;
enc
.
encode_vvec_with
(
|
enc_inner
|
{
self
.
tps
.
borrow
(
)
.
remote
.
as_ref
(
)
.
expect
(
"
should
have
transport
parameters
"
)
.
encode
(
enc_inner
)
;
}
)
;
enc
.
encode
(
&
t
[
.
.
]
)
;
qinfo
!
(
"
resumption
token
{
}
"
hex_snip_middle
(
&
enc
[
.
.
]
)
)
;
Some
(
enc
.
into
(
)
)
}
None
=
>
None
}
Agent
:
:
Server
(
_
)
=
>
None
}
}
pub
fn
set_resumption_token
(
&
mut
self
now
:
Instant
token
:
&
[
u8
]
)
-
>
Res
<
(
)
>
{
if
self
.
state
!
=
State
:
:
Init
{
qerror
!
(
[
self
]
"
set
token
in
state
{
:
?
}
"
self
.
state
)
;
return
Err
(
Error
:
:
ConnectionState
)
;
}
qinfo
!
(
[
self
]
"
resumption
token
{
}
"
hex_snip_middle
(
token
)
)
;
let
mut
dec
=
Decoder
:
:
from
(
token
)
;
let
smoothed_rtt
=
match
dec
.
decode_varint
(
)
{
Some
(
v
)
=
>
Duration
:
:
from_millis
(
v
)
_
=
>
return
Err
(
Error
:
:
InvalidResumptionToken
)
}
;
let
tp_slice
=
match
dec
.
decode_vvec
(
)
{
Some
(
v
)
=
>
v
_
=
>
return
Err
(
Error
:
:
InvalidResumptionToken
)
}
;
qtrace
!
(
[
self
]
"
transport
parameters
{
}
"
hex
(
&
tp_slice
)
)
;
let
mut
dec_tp
=
Decoder
:
:
from
(
tp_slice
)
;
let
tp
=
TransportParameters
:
:
decode
(
&
mut
dec_tp
)
?
;
let
tok
=
dec
.
decode_remainder
(
)
;
qtrace
!
(
[
self
]
"
TLS
token
{
}
"
hex
(
&
tok
)
)
;
match
self
.
crypto
.
tls
{
Agent
:
:
Client
(
ref
mut
c
)
=
>
c
.
set_resumption_token
(
&
tok
)
?
Agent
:
:
Server
(
_
)
=
>
return
Err
(
Error
:
:
WrongRole
)
}
self
.
tps
.
borrow_mut
(
)
.
remote_0rtt
=
Some
(
tp
)
;
if
smoothed_rtt
>
GRANULARITY
{
self
.
loss_recovery
.
set_initial_rtt
(
smoothed_rtt
)
;
}
self
.
set_initial_limits
(
)
;
self
.
client_start
(
now
)
}
pub
fn
send_ticket
(
&
mut
self
now
:
Instant
extra
:
&
[
u8
]
)
-
>
Res
<
(
)
>
{
let
tps
=
&
self
.
tps
;
match
self
.
crypto
.
tls
{
Agent
:
:
Server
(
ref
mut
s
)
=
>
{
let
mut
enc
=
Encoder
:
:
default
(
)
;
enc
.
encode_vvec_with
(
|
mut
enc_inner
|
{
tps
.
borrow
(
)
.
local
.
encode
(
&
mut
enc_inner
)
;
}
)
;
enc
.
encode
(
extra
)
;
let
records
=
s
.
send_ticket
(
now
&
enc
)
?
;
qinfo
!
(
[
self
]
"
send
session
ticket
{
}
"
hex
(
&
enc
)
)
;
self
.
crypto
.
buffer_records
(
records
)
?
;
Ok
(
(
)
)
}
Agent
:
:
Client
(
_
)
=
>
Err
(
Error
:
:
WrongRole
)
}
}
pub
fn
tls_info
(
&
self
)
-
>
Option
<
&
SecretAgentInfo
>
{
self
.
crypto
.
tls
.
info
(
)
}
pub
fn
peer_certificate
(
&
self
)
-
>
Option
<
CertificateInfo
>
{
self
.
crypto
.
tls
.
peer_certificate
(
)
}
pub
fn
authenticated
(
&
mut
self
status
:
AuthenticationStatus
now
:
Instant
)
{
qinfo
!
(
[
self
]
"
Authenticated
{
:
?
}
"
status
)
;
self
.
crypto
.
tls
.
authenticated
(
status
)
;
let
res
=
self
.
handshake
(
now
PNSpace
:
:
Handshake
None
)
;
self
.
absorb_error
(
now
res
)
;
self
.
process_saved
(
now
true
)
;
}
pub
fn
role
(
&
self
)
-
>
Role
{
self
.
role
}
pub
fn
state
(
&
self
)
-
>
&
State
{
&
self
.
state
}
pub
fn
zero_rtt_state
(
&
self
)
-
>
&
ZeroRttState
{
&
self
.
zero_rtt_state
}
pub
fn
stats
(
&
self
)
-
>
&
Stats
{
&
self
.
stats
}
fn
capture_error
<
T
>
(
&
mut
self
now
:
Instant
frame_type
:
FrameType
res
:
Res
<
T
>
)
-
>
Res
<
T
>
{
if
let
Err
(
v
)
=
&
res
{
#
[
cfg
(
debug_assertions
)
]
let
msg
=
format
!
(
"
{
:
?
}
"
v
)
;
#
[
cfg
(
not
(
debug_assertions
)
)
]
let
msg
=
"
"
;
let
error
=
ConnectionError
:
:
Transport
(
v
.
clone
(
)
)
;
match
&
self
.
state
{
State
:
:
Closing
{
error
:
err
.
.
}
|
State
:
:
Draining
{
error
:
err
.
.
}
|
State
:
:
Closed
(
err
)
=
>
{
qwarn
!
(
[
self
]
"
Closing
again
after
error
{
:
?
}
"
err
)
;
}
State
:
:
WaitInitial
=
>
{
self
.
state_signaling
.
close
(
error
.
clone
(
)
frame_type
msg
)
;
self
.
set_state
(
State
:
:
Closed
(
error
)
)
;
}
_
=
>
{
self
.
state_signaling
.
close
(
error
.
clone
(
)
frame_type
msg
)
;
self
.
set_state
(
State
:
:
Closing
{
error
timeout
:
self
.
get_closing_period_time
(
now
)
}
)
;
}
}
}
res
}
fn
absorb_error
<
T
>
(
&
mut
self
now
:
Instant
res
:
Res
<
T
>
)
-
>
Option
<
T
>
{
self
.
capture_error
(
now
0
res
)
.
ok
(
)
}
pub
fn
process_timer
(
&
mut
self
now
:
Instant
)
{
if
let
State
:
:
Closing
{
error
timeout
}
|
State
:
:
Draining
{
error
timeout
}
=
&
self
.
state
{
if
*
timeout
<
=
now
{
let
st
=
State
:
:
Closed
(
error
.
clone
(
)
)
;
self
.
set_state
(
st
)
;
qinfo
!
(
"
Closing
timer
expired
"
)
;
return
;
}
}
if
let
State
:
:
Closed
(
_
)
=
self
.
state
{
qdebug
!
(
"
Timer
fired
while
closed
"
)
;
return
;
}
if
self
.
idle_timeout
.
expired
(
now
self
.
loss_recovery
.
raw_pto
(
)
)
{
qinfo
!
(
[
self
]
"
idle
timeout
expired
"
)
;
self
.
set_state
(
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
IdleTimeout
)
)
)
;
return
;
}
self
.
process_saved
(
now
false
)
;
let
res
=
self
.
crypto
.
states
.
check_key_update
(
now
)
;
self
.
absorb_error
(
now
res
)
;
let
lost
=
self
.
loss_recovery
.
timeout
(
now
)
;
self
.
handle_lost_packets
(
&
lost
)
;
qlog
:
:
packets_lost
(
&
mut
self
.
qlog
.
borrow_mut
(
)
&
lost
)
;
}
pub
fn
process_input
(
&
mut
self
d
:
Datagram
now
:
Instant
)
{
let
res
=
self
.
input
(
d
now
)
;
self
.
absorb_error
(
now
res
)
;
self
.
cleanup_streams
(
)
;
}
#
[
cfg
(
test
)
]
pub
fn
test_process_input
(
&
mut
self
dgram
:
Datagram
now
:
Instant
)
-
>
Vec
<
(
Frame
PNSpace
)
>
{
let
res
=
self
.
input
(
dgram
now
)
;
let
frames
=
self
.
absorb_error
(
now
res
)
.
unwrap_or_default
(
)
;
self
.
cleanup_streams
(
)
;
frames
}
fn
next_delay
(
&
mut
self
now
:
Instant
paced
:
bool
)
-
>
Duration
{
qtrace
!
(
[
self
]
"
Get
callback
delay
{
:
?
}
"
now
)
;
if
let
State
:
:
Closing
{
timeout
.
.
}
|
State
:
:
Draining
{
timeout
.
.
}
=
self
.
state
{
return
timeout
.
duration_since
(
now
)
;
}
let
mut
delays
=
SmallVec
:
:
<
[
_
;
5
]
>
:
:
new
(
)
;
if
let
Some
(
ack_time
)
=
self
.
acks
.
ack_time
(
now
)
{
qtrace
!
(
[
self
]
"
Delayed
ACK
timer
{
:
?
}
"
ack_time
)
;
delays
.
push
(
ack_time
)
;
}
if
let
Some
(
idle_time
)
=
self
.
idle_timeout
.
expiry
(
self
.
loss_recovery
.
raw_pto
(
)
)
{
qtrace
!
(
[
self
]
"
Idle
timer
{
:
?
}
"
idle_time
)
;
delays
.
push
(
idle_time
)
;
}
if
let
Some
(
lr_time
)
=
self
.
loss_recovery
.
next_timeout
(
)
{
qtrace
!
(
[
self
]
"
Loss
recovery
timer
{
:
?
}
"
lr_time
)
;
delays
.
push
(
lr_time
)
;
}
if
let
Some
(
key_update_time
)
=
self
.
crypto
.
states
.
update_time
(
)
{
qtrace
!
(
[
self
]
"
Key
update
timer
{
:
?
}
"
key_update_time
)
;
delays
.
push
(
key_update_time
)
;
}
if
paced
{
if
let
Some
(
pace_time
)
=
self
.
loss_recovery
.
next_paced
(
)
{
qtrace
!
(
[
self
]
"
Pacing
timer
{
:
?
}
"
pace_time
)
;
delays
.
push
(
pace_time
)
;
}
}
assert
!
(
!
delays
.
is_empty
(
)
)
;
let
earliest
=
delays
.
into_iter
(
)
.
min
(
)
.
unwrap
(
)
;
qdebug
!
(
[
self
]
"
delay
duration
{
:
?
}
"
max
(
now
earliest
)
.
duration_since
(
now
)
)
;
debug_assert
!
(
earliest
>
now
)
;
max
(
now
earliest
)
.
duration_since
(
now
)
}
pub
fn
process_output
(
&
mut
self
now
:
Instant
)
-
>
Output
{
qtrace
!
(
[
self
]
"
process_output
{
:
?
}
{
:
?
}
"
self
.
state
now
)
;
if
self
.
state
=
=
State
:
:
Init
{
if
self
.
role
=
=
Role
:
:
Client
{
let
res
=
self
.
client_start
(
now
)
;
self
.
absorb_error
(
now
res
)
;
}
}
else
{
self
.
process_timer
(
now
)
;
}
match
self
.
output
(
now
)
{
SendOption
:
:
Yes
(
dgram
)
=
>
Output
:
:
Datagram
(
dgram
)
SendOption
:
:
No
(
paced
)
=
>
match
self
.
state
{
State
:
:
Init
|
State
:
:
Closed
(
_
)
=
>
Output
:
:
None
State
:
:
Closing
{
timeout
.
.
}
|
State
:
:
Draining
{
timeout
.
.
}
=
>
{
Output
:
:
Callback
(
timeout
.
duration_since
(
now
)
)
}
_
=
>
Output
:
:
Callback
(
self
.
next_delay
(
now
paced
)
)
}
}
}
#
[
must_use
=
"
Output
of
the
process
function
must
be
handled
"
]
pub
fn
process
(
&
mut
self
dgram
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Output
{
if
let
Some
(
d
)
=
dgram
{
self
.
process_input
(
d
now
)
;
}
self
.
process_output
(
now
)
}
fn
is_valid_cid
(
&
self
cid
:
&
ConnectionIdRef
)
-
>
bool
{
self
.
valid_cids
.
iter
(
)
.
any
(
|
c
|
c
=
=
cid
)
|
|
self
.
path
.
iter
(
)
.
any
(
|
p
|
p
.
valid_local_cid
(
cid
)
)
}
fn
handle_retry
(
&
mut
self
packet
:
PublicPacket
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
received
Retry
"
)
;
if
self
.
retry_info
.
is_some
(
)
{
self
.
stats
.
pkt_dropped
(
"
Extra
Retry
"
)
;
return
Ok
(
(
)
)
;
}
if
packet
.
token
(
)
.
is_empty
(
)
{
self
.
stats
.
pkt_dropped
(
"
Retry
without
a
token
"
)
;
return
Ok
(
(
)
)
;
}
if
!
packet
.
is_valid_retry
(
&
self
.
remote_original_destination_cid
.
as_ref
(
)
.
unwrap
(
)
)
{
self
.
stats
.
pkt_dropped
(
"
Retry
with
bad
integrity
tag
"
)
;
return
Ok
(
(
)
)
;
}
if
let
Some
(
p
)
=
&
mut
self
.
path
{
p
.
set_remote_cid
(
packet
.
scid
(
)
)
;
}
else
{
qinfo
!
(
[
self
]
"
No
path
but
we
received
a
Retry
"
)
;
return
Err
(
Error
:
:
InternalError
)
;
}
;
qinfo
!
(
[
self
]
"
Valid
Retry
received
token
=
{
}
scid
=
{
}
"
hex
(
packet
.
token
(
)
)
packet
.
scid
(
)
)
;
self
.
retry_info
=
Some
(
RetryInfo
:
:
new
(
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
packet
.
token
(
)
.
to_vec
(
)
)
)
;
let
lost_packets
=
self
.
loss_recovery
.
retry
(
)
;
self
.
handle_lost_packets
(
&
lost_packets
)
;
self
.
crypto
.
states
.
init
(
self
.
quic_version
self
.
role
packet
.
scid
(
)
)
;
Ok
(
(
)
)
}
fn
discard_keys
(
&
mut
self
space
:
PNSpace
)
{
if
self
.
crypto
.
discard
(
space
)
{
qinfo
!
(
[
self
]
"
Drop
packet
number
space
{
}
"
space
)
;
self
.
loss_recovery
.
discard
(
space
)
;
self
.
acks
.
drop_space
(
space
)
;
}
}
fn
token_equal
(
a
:
&
[
u8
;
16
]
b
:
&
[
u8
;
16
]
)
-
>
bool
{
let
mut
c
=
0
;
for
(
&
a
&
b
)
in
a
.
iter
(
)
.
zip
(
b
)
{
c
|
=
a
^
b
;
}
c
=
=
0
}
fn
is_stateless_reset
(
&
self
d
:
&
Datagram
)
-
>
bool
{
if
d
.
len
(
)
<
16
{
return
false
;
}
let
token
=
<
&
[
u8
;
16
]
>
:
:
try_from
(
&
d
[
d
.
len
(
)
-
16
.
.
]
)
.
unwrap
(
)
;
self
.
path
.
as_ref
(
)
.
map
(
|
p
|
p
.
reset_token
(
)
)
.
flatten
(
)
.
map_or
(
false
|
t
|
Self
:
:
token_equal
(
t
token
)
)
}
fn
check_stateless_reset
<
'
a
'
b
>
(
&
'
a
mut
self
d
:
&
'
b
Datagram
slice
:
&
'
b
[
u8
]
now
:
Instant
)
-
>
Res
<
(
)
>
{
if
d
.
len
(
)
=
=
slice
.
len
(
)
&
&
self
.
is_stateless_reset
(
d
)
{
qdebug
!
(
[
self
]
"
Stateless
reset
:
{
}
"
hex
(
&
d
[
d
.
len
(
)
-
16
.
.
]
)
)
;
self
.
state_signaling
.
reset
(
)
;
self
.
set_state
(
State
:
:
Draining
{
error
:
ConnectionError
:
:
Transport
(
Error
:
:
StatelessReset
)
timeout
:
self
.
get_closing_period_time
(
now
)
}
)
;
Err
(
Error
:
:
StatelessReset
)
}
else
{
Ok
(
(
)
)
}
}
fn
process_saved
(
&
mut
self
now
:
Instant
always
:
bool
)
{
if
let
Some
(
(
_
ref
mut
defer
)
)
=
self
.
saved_datagram
{
if
always
|
|
!
*
defer
{
let
d
=
self
.
saved_datagram
.
take
(
)
.
unwrap
(
)
.
0
;
qdebug
!
(
[
self
]
"
process
saved
datagram
:
{
:
?
}
"
d
)
;
self
.
process_input
(
d
now
)
;
}
else
{
*
defer
=
false
;
}
}
}
fn
maybe_save_datagram
<
'
a
'
b
>
(
&
'
a
mut
self
d
:
&
'
b
Datagram
slice
:
&
'
b
[
u8
]
now
:
Instant
)
-
>
bool
{
if
slice
.
len
(
)
<
d
.
len
(
)
{
let
save
=
Datagram
:
:
new
(
d
.
source
(
)
d
.
destination
(
)
slice
)
;
qdebug
!
(
[
self
]
"
saving
datagram
{
:
?
}
{
:
?
}
"
now
save
)
;
self
.
saved_datagram
=
Some
(
(
save
true
)
)
;
true
}
else
{
false
}
}
fn
input
(
&
mut
self
d
:
Datagram
now
:
Instant
)
-
>
Res
<
Vec
<
(
Frame
PNSpace
)
>
>
{
let
mut
slc
=
&
d
[
.
.
]
;
let
mut
frames
=
Vec
:
:
new
(
)
;
qtrace
!
(
[
self
]
"
input
{
}
"
hex
(
&
*
*
d
)
)
;
while
!
slc
.
is_empty
(
)
{
let
(
packet
remainder
)
=
match
PublicPacket
:
:
decode
(
slc
self
.
cid_manager
.
borrow
(
)
.
as_decoder
(
)
)
{
Ok
(
(
packet
remainder
)
)
=
>
(
packet
remainder
)
Err
(
e
)
=
>
{
qinfo
!
(
[
self
]
"
Garbage
packet
:
{
}
"
e
)
;
qtrace
!
(
[
self
]
"
Garbage
packet
contents
:
{
}
"
hex
(
slc
)
)
;
self
.
stats
.
pkt_dropped
(
"
Garbage
packet
"
)
;
break
;
}
}
;
self
.
stats
.
packets_rx
+
=
1
;
match
(
packet
.
packet_type
(
)
&
self
.
state
&
self
.
role
)
{
(
PacketType
:
:
Initial
State
:
:
Init
Role
:
:
Server
)
=
>
{
if
!
packet
.
is_valid_initial
(
)
{
self
.
stats
.
pkt_dropped
(
"
Invalid
Initial
"
)
;
break
;
}
qinfo
!
(
[
self
]
"
Received
valid
Initial
packet
with
scid
{
:
?
}
dcid
{
:
?
}
"
packet
.
scid
(
)
packet
.
dcid
(
)
)
;
self
.
set_state
(
State
:
:
WaitInitial
)
;
self
.
loss_recovery
.
start_pacer
(
now
)
;
self
.
crypto
.
states
.
init
(
self
.
quic_version
self
.
role
&
packet
.
dcid
(
)
)
;
if
!
self
.
retry_sent
(
)
{
self
.
tps
.
borrow_mut
(
)
.
local
.
set_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
packet
.
dcid
(
)
.
to_vec
(
)
)
}
}
(
PacketType
:
:
VersionNegotiation
State
:
:
WaitInitial
Role
:
:
Client
)
=
>
{
match
packet
.
supported_versions
(
)
{
Ok
(
versions
)
=
>
{
if
versions
.
is_empty
(
)
|
|
versions
.
contains
(
&
self
.
quic_version
.
as_u32
(
)
)
{
self
.
stats
.
dropped_rx
+
=
1
;
return
Ok
(
frames
)
;
}
self
.
set_state
(
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
VersionNegotiation
)
)
)
;
return
Err
(
Error
:
:
VersionNegotiation
)
;
}
Err
(
_
)
=
>
{
self
.
stats
.
dropped_rx
+
=
1
;
return
Ok
(
frames
)
;
}
}
}
(
PacketType
:
:
Retry
State
:
:
WaitInitial
Role
:
:
Client
)
=
>
{
self
.
handle_retry
(
packet
)
?
;
break
;
}
(
PacketType
:
:
VersionNegotiation
.
.
)
|
(
PacketType
:
:
Retry
.
.
)
|
(
PacketType
:
:
OtherVersion
.
.
)
=
>
{
self
.
stats
.
pkt_dropped
(
format
!
(
"
{
:
?
}
"
packet
.
packet_type
(
)
)
)
;
break
;
}
_
=
>
{
}
}
;
match
self
.
state
{
State
:
:
Init
=
>
{
self
.
stats
.
pkt_dropped
(
"
Received
while
in
Init
state
"
)
;
break
;
}
State
:
:
WaitInitial
=
>
{
}
State
:
:
Handshaking
|
State
:
:
Connected
|
State
:
:
Confirmed
=
>
{
if
!
self
.
is_valid_cid
(
packet
.
dcid
(
)
)
{
self
.
stats
.
pkt_dropped
(
format
!
(
"
Ignoring
packet
with
CID
{
:
?
}
"
packet
.
dcid
(
)
)
)
;
break
;
}
if
self
.
role
=
=
Role
:
:
Server
&
&
packet
.
packet_type
(
)
=
=
PacketType
:
:
Handshake
{
self
.
discard_keys
(
PNSpace
:
:
Initial
)
;
}
}
State
:
:
Closing
{
.
.
}
=
>
{
self
.
state_signaling
.
send_close
(
)
;
break
;
}
State
:
:
Draining
{
.
.
}
|
State
:
:
Closed
(
.
.
)
=
>
{
self
.
stats
.
pkt_dropped
(
format
!
(
"
State
{
:
?
}
"
self
.
state
)
)
;
break
;
}
}
qtrace
!
(
[
self
]
"
Received
unverified
packet
{
:
?
}
"
packet
)
;
let
pto
=
self
.
loss_recovery
.
pto
(
)
;
match
packet
.
decrypt
(
&
mut
self
.
crypto
.
states
now
+
pto
)
{
Ok
(
payload
)
=
>
{
self
.
idle_timeout
.
on_packet_received
(
now
)
;
dump_packet
(
self
"
-
>
RX
"
payload
.
packet_type
(
)
payload
.
pn
(
)
&
payload
[
.
.
]
)
;
qlog
:
:
packet_received
(
&
mut
self
.
qlog
.
borrow_mut
(
)
&
payload
)
;
let
res
=
self
.
process_packet
(
&
payload
now
)
;
if
res
.
is_err
(
)
&
&
self
.
path
.
is_none
(
)
{
self
.
remote_initial_source_cid
=
Some
(
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
)
;
self
.
initialize_path
(
d
.
destination
(
)
d
.
source
(
)
)
;
}
frames
.
extend
(
res
?
)
;
if
self
.
state
=
=
State
:
:
WaitInitial
{
self
.
start_handshake
(
&
packet
&
d
)
?
;
}
self
.
process_migrations
(
&
d
)
?
;
}
Err
(
e
)
=
>
{
if
matches
!
(
e
Error
:
:
KeysNotFound
)
&
&
self
.
maybe_save_datagram
(
&
d
slc
now
)
{
break
;
}
self
.
check_stateless_reset
(
&
d
slc
now
)
?
;
self
.
stats
.
pkt_dropped
(
"
Decryption
failure
"
)
;
qlog
:
:
packet_dropped
(
&
mut
self
.
qlog
.
borrow_mut
(
)
&
packet
)
;
}
}
slc
=
remainder
;
}
self
.
check_stateless_reset
(
&
d
slc
now
)
?
;
Ok
(
frames
)
}
fn
process_packet
(
&
mut
self
packet
:
&
DecryptedPacket
now
:
Instant
)
-
>
Res
<
Vec
<
(
Frame
PNSpace
)
>
>
{
let
space
=
PNSpace
:
:
from
(
packet
.
packet_type
(
)
)
;
if
self
.
acks
.
get_mut
(
space
)
.
unwrap
(
)
.
is_duplicate
(
packet
.
pn
(
)
)
{
qdebug
!
(
[
self
]
"
Duplicate
packet
from
{
}
pn
=
{
}
"
space
packet
.
pn
(
)
)
;
self
.
stats
.
dups_rx
+
=
1
;
return
Ok
(
vec
!
[
]
)
;
}
let
mut
ack_eliciting
=
false
;
let
mut
d
=
Decoder
:
:
from
(
&
packet
[
.
.
]
)
;
let
mut
consecutive_padding
=
0
;
#
[
allow
(
unused_mut
)
]
let
mut
frames
=
Vec
:
:
new
(
)
;
while
d
.
remaining
(
)
>
0
{
let
mut
f
=
Frame
:
:
decode
(
&
mut
d
)
?
;
while
f
=
=
Frame
:
:
Padding
&
&
d
.
remaining
(
)
>
0
{
consecutive_padding
+
=
1
;
f
=
Frame
:
:
decode
(
&
mut
d
)
?
;
}
if
consecutive_padding
>
0
{
qdebug
!
(
[
self
]
"
PADDING
frame
repeated
{
}
times
"
consecutive_padding
)
;
consecutive_padding
=
0
;
}
if
cfg
!
(
test
)
{
frames
.
push
(
(
f
.
clone
(
)
space
)
)
;
}
ack_eliciting
|
=
f
.
ack_eliciting
(
)
;
let
t
=
f
.
get_type
(
)
;
let
res
=
self
.
input_frame
(
packet
.
packet_type
(
)
f
now
)
;
self
.
capture_error
(
now
t
res
)
?
;
}
self
.
acks
.
get_mut
(
space
)
.
unwrap
(
)
.
set_received
(
now
packet
.
pn
(
)
ack_eliciting
)
;
Ok
(
frames
)
}
fn
initialize_path
(
&
mut
self
local_addr
:
SocketAddr
remote_addr
:
SocketAddr
)
{
debug_assert
!
(
self
.
path
.
is_none
(
)
)
;
self
.
path
=
Some
(
Path
:
:
new
(
local_addr
remote_addr
self
.
local_initial_source_cid
.
clone
(
)
self
.
remote_initial_source_cid
.
as_ref
(
)
.
or_else
(
|
|
self
.
remote_original_destination_cid
.
as_ref
(
)
)
.
unwrap
(
)
.
clone
(
)
)
)
;
}
fn
start_handshake
(
&
mut
self
packet
:
&
PublicPacket
d
:
&
Datagram
)
-
>
Res
<
(
)
>
{
self
.
remote_initial_source_cid
=
Some
(
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
)
;
if
self
.
role
=
=
Role
:
:
Server
{
assert_eq
!
(
packet
.
packet_type
(
)
PacketType
:
:
Initial
)
;
self
.
valid_cids
.
push
(
ConnectionId
:
:
from
(
packet
.
dcid
(
)
)
)
;
self
.
initialize_path
(
d
.
destination
(
)
d
.
source
(
)
)
;
self
.
zero_rtt_state
=
match
self
.
crypto
.
enable_0rtt
(
self
.
role
)
{
Ok
(
true
)
=
>
{
qdebug
!
(
[
self
]
"
Accepted
0
-
RTT
"
)
;
ZeroRttState
:
:
AcceptedServer
}
_
=
>
ZeroRttState
:
:
Rejected
}
;
}
else
{
qdebug
!
(
[
self
]
"
Changing
to
use
Server
CID
=
{
}
"
packet
.
scid
(
)
)
;
let
p
=
self
.
path
.
iter_mut
(
)
.
find
(
|
p
|
p
.
received_on
(
&
d
)
)
.
expect
(
"
should
have
a
path
for
sending
Initial
"
)
;
p
.
set_remote_cid
(
packet
.
scid
(
)
)
;
}
self
.
set_state
(
State
:
:
Handshaking
)
;
Ok
(
(
)
)
}
fn
process_migrations
(
&
self
d
:
&
Datagram
)
-
>
Res
<
(
)
>
{
if
self
.
path
.
iter
(
)
.
any
(
|
p
|
p
.
received_on
(
&
d
)
)
{
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
InvalidMigration
)
}
}
fn
output
(
&
mut
self
now
:
Instant
)
-
>
SendOption
{
qtrace
!
(
[
self
]
"
output
{
:
?
}
"
now
)
;
if
let
Some
(
mut
path
)
=
self
.
path
.
take
(
)
{
let
res
=
match
&
self
.
state
{
State
:
:
Init
|
State
:
:
WaitInitial
|
State
:
:
Handshaking
|
State
:
:
Connected
|
State
:
:
Confirmed
=
>
self
.
output_path
(
&
mut
path
now
)
State
:
:
Closing
{
.
.
}
|
State
:
:
Draining
{
.
.
}
|
State
:
:
Closed
(
_
)
=
>
{
if
let
Some
(
frame
)
=
self
.
state_signaling
.
close_frame
(
)
{
self
.
output_close
(
&
path
&
frame
)
}
else
{
Ok
(
SendOption
:
:
default
(
)
)
}
}
}
;
let
out
=
self
.
absorb_error
(
now
res
)
.
unwrap_or_default
(
)
;
self
.
path
=
Some
(
path
)
;
out
}
else
{
SendOption
:
:
default
(
)
}
}
fn
build_packet_header
(
path
:
&
Path
space
:
PNSpace
encoder
:
Encoder
tx
:
&
CryptoDxState
retry_info
:
&
Option
<
RetryInfo
>
quic_version
:
QuicVersion
)
-
>
(
PacketType
PacketNumber
PacketBuilder
)
{
let
pt
=
match
space
{
PNSpace
:
:
Initial
=
>
PacketType
:
:
Initial
PNSpace
:
:
Handshake
=
>
PacketType
:
:
Handshake
PNSpace
:
:
ApplicationData
=
>
{
if
tx
.
is_0rtt
(
)
{
PacketType
:
:
ZeroRtt
}
else
{
PacketType
:
:
Short
}
}
}
;
let
mut
builder
=
if
pt
=
=
PacketType
:
:
Short
{
qdebug
!
(
"
Building
Short
dcid
{
}
"
path
.
remote_cid
(
)
)
;
PacketBuilder
:
:
short
(
encoder
tx
.
key_phase
(
)
path
.
remote_cid
(
)
)
}
else
{
qdebug
!
(
"
Building
{
:
?
}
dcid
{
}
scid
{
}
"
pt
path
.
remote_cid
(
)
path
.
local_cid
(
)
)
;
PacketBuilder
:
:
long
(
encoder
pt
quic_version
path
.
remote_cid
(
)
path
.
local_cid
(
)
)
}
;
if
pt
=
=
PacketType
:
:
Initial
{
builder
.
initial_token
(
if
let
Some
(
info
)
=
retry_info
{
&
info
.
token
}
else
{
&
[
]
}
)
;
}
let
pn
=
tx
.
next_pn
(
)
;
builder
.
pn
(
pn
3
)
;
(
pt
pn
builder
)
}
fn
output_close
(
&
mut
self
path
:
&
Path
frame
:
&
Frame
)
-
>
Res
<
SendOption
>
{
let
mut
encoder
=
Encoder
:
:
with_capacity
(
path
.
mtu
(
)
)
;
for
space
in
PNSpace
:
:
iter
(
)
{
let
tx
=
if
let
Some
(
tx_state
)
=
self
.
crypto
.
states
.
tx
(
*
space
)
{
tx_state
}
else
{
continue
;
}
;
if
tx
.
is_0rtt
(
)
{
continue
;
}
let
(
_
_
mut
builder
)
=
Self
:
:
build_packet_header
(
path
*
space
encoder
tx
&
None
self
.
quic_version
)
;
if
*
space
=
=
PNSpace
:
:
ApplicationData
{
frame
.
marshal
(
&
mut
builder
)
;
}
else
{
frame
.
sanitize_close
(
)
.
marshal
(
&
mut
builder
)
;
}
encoder
=
builder
.
build
(
tx
)
?
;
}
Ok
(
SendOption
:
:
Yes
(
path
.
datagram
(
encoder
)
)
)
}
fn
add_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
space
:
PNSpace
limit
:
usize
profile
:
&
SendProfile
now
:
Instant
)
-
>
(
Vec
<
RecoveryToken
>
bool
)
{
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
ack_eliciting
=
if
profile
.
pto
(
)
{
builder
.
encode_varint
(
Frame
:
:
Ping
.
get_type
(
)
)
;
true
}
else
{
false
}
;
while
builder
.
len
(
)
+
2
<
limit
{
let
remaining
=
limit
-
builder
.
len
(
)
;
let
mut
frame
=
self
.
acks
.
get_frame
(
now
space
)
;
if
!
profile
.
ack_only
(
space
)
{
if
frame
.
is_none
(
)
&
&
space
=
=
PNSpace
:
:
ApplicationData
&
&
self
.
role
=
=
Role
:
:
Server
{
frame
=
self
.
state_signaling
.
send_done
(
)
;
}
if
frame
.
is_none
(
)
{
frame
=
self
.
crypto
.
streams
.
get_frame
(
space
remaining
)
}
if
frame
.
is_none
(
)
{
frame
=
self
.
flow_mgr
.
borrow_mut
(
)
.
get_frame
(
space
remaining
)
;
}
if
frame
.
is_none
(
)
{
frame
=
self
.
send_streams
.
get_frame
(
space
remaining
)
;
}
}
if
let
Some
(
(
frame
token
)
)
=
frame
{
ack_eliciting
|
=
frame
.
ack_eliciting
(
)
;
debug_assert_ne
!
(
frame
Frame
:
:
Padding
)
;
frame
.
marshal
(
builder
)
;
if
let
Some
(
t
)
=
token
{
tokens
.
push
(
t
)
;
}
}
else
{
return
(
tokens
ack_eliciting
)
;
}
}
(
tokens
ack_eliciting
)
}
fn
output_path
(
&
mut
self
path
:
&
mut
Path
now
:
Instant
)
-
>
Res
<
SendOption
>
{
let
mut
initial_sent
=
None
;
let
mut
needs_padding
=
false
;
let
profile
=
self
.
loss_recovery
.
send_profile
(
now
path
.
mtu
(
)
)
;
qdebug
!
(
[
self
]
"
output_path
send_profile
{
:
?
}
"
profile
)
;
let
mut
encoder
=
Encoder
:
:
with_capacity
(
profile
.
limit
(
)
)
;
for
space
in
PNSpace
:
:
iter
(
)
{
let
tx
=
if
let
Some
(
tx_state
)
=
self
.
crypto
.
states
.
tx
(
*
space
)
{
tx_state
}
else
{
continue
;
}
;
let
header_start
=
encoder
.
len
(
)
;
let
(
pt
pn
mut
builder
)
=
Self
:
:
build_packet_header
(
path
*
space
encoder
tx
&
self
.
retry_info
self
.
quic_version
)
;
let
payload_start
=
builder
.
len
(
)
;
if
builder
.
len
(
)
+
tx
.
expansion
(
)
>
profile
.
limit
(
)
{
encoder
=
builder
.
abort
(
)
;
continue
;
}
let
limit
=
profile
.
limit
(
)
-
tx
.
expansion
(
)
;
let
(
tokens
ack_eliciting
)
=
self
.
add_frames
(
&
mut
builder
*
space
limit
&
profile
now
)
;
if
builder
.
is_empty
(
)
{
encoder
=
builder
.
abort
(
)
;
continue
;
}
dump_packet
(
self
"
TX
-
>
"
pt
pn
&
builder
[
payload_start
.
.
]
)
;
qlog
:
:
packet_sent
(
&
mut
self
.
qlog
.
borrow_mut
(
)
pt
pn
&
builder
[
payload_start
.
.
]
)
;
self
.
stats
.
packets_tx
+
=
1
;
encoder
=
builder
.
build
(
self
.
crypto
.
states
.
tx
(
*
space
)
.
unwrap
(
)
)
?
;
debug_assert
!
(
encoder
.
len
(
)
<
=
path
.
mtu
(
)
)
;
let
in_flight
=
!
profile
.
pto
(
)
&
&
ack_eliciting
;
if
in_flight
{
self
.
idle_timeout
.
on_packet_sent
(
now
)
;
}
let
sent
=
SentPacket
:
:
new
(
pt
pn
now
ack_eliciting
Rc
:
:
new
(
tokens
)
encoder
.
len
(
)
-
header_start
in_flight
)
;
if
pt
=
=
PacketType
:
:
Initial
&
&
self
.
role
=
=
Role
:
:
Client
{
initial_sent
=
Some
(
sent
)
;
needs_padding
=
true
;
}
else
{
if
pt
!
=
PacketType
:
:
ZeroRtt
{
needs_padding
=
false
;
}
self
.
loss_recovery
.
on_packet_sent
(
sent
)
;
}
if
*
space
=
=
PNSpace
:
:
Handshake
{
if
self
.
role
=
=
Role
:
:
Client
{
self
.
discard_keys
(
PNSpace
:
:
Initial
)
;
}
else
if
self
.
state
=
=
State
:
:
Confirmed
{
self
.
discard_keys
(
PNSpace
:
:
Handshake
)
;
}
}
}
if
encoder
.
is_empty
(
)
{
Ok
(
SendOption
:
:
No
(
profile
.
paced
(
)
)
)
}
else
{
let
mut
packets
:
Vec
<
u8
>
=
encoder
.
into
(
)
;
if
let
Some
(
mut
initial
)
=
initial_sent
.
take
(
)
{
if
needs_padding
{
qdebug
!
(
[
self
]
"
pad
Initial
to
path
MTU
{
}
"
path
.
mtu
(
)
)
;
initial
.
size
+
=
path
.
mtu
(
)
-
packets
.
len
(
)
;
packets
.
resize
(
path
.
mtu
(
)
0
)
;
}
self
.
loss_recovery
.
on_packet_sent
(
initial
)
;
}
Ok
(
SendOption
:
:
Yes
(
path
.
datagram
(
packets
)
)
)
}
}
pub
fn
initiate_key_update
(
&
mut
self
)
-
>
Res
<
(
)
>
{
if
self
.
state
=
=
State
:
:
Confirmed
{
let
la
=
self
.
loss_recovery
.
largest_acknowledged_pn
(
PNSpace
:
:
ApplicationData
)
;
qinfo
!
(
[
self
]
"
Initiating
key
update
"
)
;
self
.
crypto
.
states
.
initiate_key_update
(
la
)
}
else
{
Err
(
Error
:
:
NotConnected
)
}
}
#
[
cfg
(
test
)
]
pub
fn
get_epochs
(
&
self
)
-
>
(
Option
<
usize
>
Option
<
usize
>
)
{
self
.
crypto
.
states
.
get_epochs
(
)
}
fn
client_start
(
&
mut
self
now
:
Instant
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
client_start
"
)
;
debug_assert_eq
!
(
self
.
role
Role
:
:
Client
)
;
qlog
:
:
client_connection_started
(
&
mut
self
.
qlog
.
borrow_mut
(
)
self
.
path
.
as_ref
(
)
.
unwrap
(
)
)
;
self
.
loss_recovery
.
start_pacer
(
now
)
;
self
.
handshake
(
now
PNSpace
:
:
Initial
None
)
?
;
self
.
set_state
(
State
:
:
WaitInitial
)
;
self
.
zero_rtt_state
=
if
self
.
crypto
.
enable_0rtt
(
self
.
role
)
?
{
qdebug
!
(
[
self
]
"
Enabled
0
-
RTT
"
)
;
ZeroRttState
:
:
Sending
}
else
{
ZeroRttState
:
:
Init
}
;
Ok
(
(
)
)
}
fn
get_closing_period_time
(
&
self
now
:
Instant
)
-
>
Instant
{
now
+
(
self
.
loss_recovery
.
pto
(
)
*
3
)
}
pub
fn
close
(
&
mut
self
now
:
Instant
app_error
:
AppError
msg
:
impl
AsRef
<
str
>
)
{
let
error
=
ConnectionError
:
:
Application
(
app_error
)
;
let
timeout
=
self
.
get_closing_period_time
(
now
)
;
self
.
state_signaling
.
close
(
error
.
clone
(
)
0
msg
)
;
self
.
set_state
(
State
:
:
Closing
{
error
timeout
}
)
;
}
fn
set_initial_limits
(
&
mut
self
)
{
let
tps
=
self
.
tps
.
borrow
(
)
;
let
remote
=
tps
.
remote
(
)
;
self
.
indexes
.
remote_max_stream_bidi
=
StreamIndex
:
:
new
(
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_BIDI
)
)
;
self
.
indexes
.
remote_max_stream_uni
=
StreamIndex
:
:
new
(
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_UNI
)
)
;
self
.
flow_mgr
.
borrow_mut
(
)
.
conn_increase_max_credit
(
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_DATA
)
)
;
let
peer_timeout
=
remote
.
get_integer
(
tparams
:
:
IDLE_TIMEOUT
)
;
if
peer_timeout
>
0
{
self
.
idle_timeout
.
set_peer_timeout
(
Duration
:
:
from_millis
(
peer_timeout
)
)
;
}
}
fn
process_tps
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
validate_cids
(
)
?
;
if
let
Some
(
token
)
=
self
.
tps
.
borrow
(
)
.
remote
.
as_ref
(
)
.
unwrap
(
)
.
get_bytes
(
tparams
:
:
STATELESS_RESET_TOKEN
)
{
let
reset_token
=
<
[
u8
;
16
]
>
:
:
try_from
(
token
)
.
unwrap
(
)
.
to_owned
(
)
;
self
.
path
.
as_mut
(
)
.
unwrap
(
)
.
set_reset_token
(
reset_token
)
;
}
self
.
set_initial_limits
(
)
;
Ok
(
(
)
)
}
fn
validate_cids
(
&
mut
self
)
-
>
Res
<
(
)
>
{
match
self
.
quic_version
{
QuicVersion
:
:
Draft27
=
>
self
.
validate_cids_draft_27
(
)
_
=
>
self
.
validate_cids_draft_28_plus
(
)
}
}
fn
validate_cids_draft_27
(
&
mut
self
)
-
>
Res
<
(
)
>
{
if
let
Some
(
info
)
=
&
self
.
retry_info
{
debug_assert
!
(
!
info
.
token
.
is_empty
(
)
)
;
let
tph
=
self
.
tps
.
borrow
(
)
;
let
tp
=
tph
.
remote
.
as_ref
(
)
.
unwrap
(
)
.
get_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
)
;
if
self
.
remote_original_destination_cid
.
as_ref
(
)
.
map
(
ConnectionId
:
:
as_cid_ref
)
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
return
Err
(
Error
:
:
InvalidRetry
)
;
}
}
Ok
(
(
)
)
}
fn
validate_cids_draft_28_plus
(
&
mut
self
)
-
>
Res
<
(
)
>
{
let
tph
=
self
.
tps
.
borrow
(
)
;
let
remote_tps
=
tph
.
remote
.
as_ref
(
)
.
unwrap
(
)
;
let
tp
=
remote_tps
.
get_bytes
(
tparams
:
:
INITIAL_SOURCE_CONNECTION_ID
)
;
if
self
.
remote_initial_source_cid
.
as_ref
(
)
.
map
(
ConnectionId
:
:
as_cid_ref
)
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
qwarn
!
(
"
{
}
ISCID
test
failed
:
self
cid
{
:
?
}
!
=
tp
cid
{
:
?
}
"
self
.
role
self
.
remote_initial_source_cid
tp
.
map
(
hex
)
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
if
self
.
role
=
=
Role
:
:
Client
{
let
tp
=
remote_tps
.
get_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
)
;
if
self
.
remote_original_destination_cid
.
as_ref
(
)
.
map
(
ConnectionId
:
:
as_cid_ref
)
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
qwarn
!
(
"
{
}
ODCID
test
failed
:
self
cid
{
:
?
}
!
=
tp
cid
{
:
?
}
"
self
.
role
self
.
remote_original_destination_cid
tp
.
map
(
hex
)
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
let
tp
=
remote_tps
.
get_bytes
(
tparams
:
:
RETRY_SOURCE_CONNECTION_ID
)
;
let
expected
=
self
.
retry_info
.
as_ref
(
)
.
map
(
|
ri
|
ri
.
retry_source_cid
.
as_cid_ref
(
)
)
;
if
expected
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
qwarn
!
(
"
{
}
RSCID
test
failed
.
self
cid
{
:
?
}
!
=
tp
cid
{
:
?
}
"
self
.
role
expected
tp
.
map
(
hex
)
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
}
Ok
(
(
)
)
}
fn
handshake
(
&
mut
self
now
:
Instant
space
:
PNSpace
data
:
Option
<
&
[
u8
]
>
)
-
>
Res
<
(
)
>
{
qtrace
!
(
[
self
]
"
Handshake
space
=
{
}
data
=
{
:
0x
?
}
"
space
data
)
;
let
try_update
=
data
.
is_some
(
)
;
match
self
.
crypto
.
handshake
(
now
space
data
)
?
{
HandshakeState
:
:
Authenticated
(
_
)
|
HandshakeState
:
:
InProgress
=
>
(
)
HandshakeState
:
:
AuthenticationPending
=
>
self
.
events
.
authentication_needed
(
)
HandshakeState
:
:
Complete
(
_
)
=
>
{
if
!
self
.
state
.
connected
(
)
{
self
.
set_connected
(
now
)
?
;
}
}
_
=
>
{
unreachable
!
(
"
Crypto
state
should
not
be
new
or
failed
after
successful
handshake
"
)
}
}
if
try_update
{
if
self
.
tps
.
borrow
(
)
.
remote
.
is_some
(
)
{
self
.
set_initial_limits
(
)
;
}
self
.
crypto
.
install_keys
(
self
.
role
)
;
}
Ok
(
(
)
)
}
fn
handle_max_data
(
&
mut
self
maximum_data
:
u64
)
{
let
conn_was_blocked
=
self
.
flow_mgr
.
borrow
(
)
.
conn_credit_avail
(
)
=
=
0
;
let
conn_credit_increased
=
self
.
flow_mgr
.
borrow_mut
(
)
.
conn_increase_max_credit
(
maximum_data
)
;
if
conn_was_blocked
&
&
conn_credit_increased
{
for
(
id
ss
)
in
&
mut
self
.
send_streams
{
if
ss
.
avail
(
)
>
0
{
self
.
events
.
send_stream_writable
(
*
id
)
}
}
}
}
fn
input_frame
(
&
mut
self
ptype
:
PacketType
frame
:
Frame
now
:
Instant
)
-
>
Res
<
(
)
>
{
if
!
frame
.
is_allowed
(
ptype
)
{
qerror
!
(
"
frame
not
allowed
:
{
:
?
}
{
:
?
}
"
frame
ptype
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
match
frame
{
Frame
:
:
Padding
=
>
{
}
Frame
:
:
Ping
=
>
{
}
Frame
:
:
Ack
{
largest_acknowledged
ack_delay
first_ack_range
ack_ranges
}
=
>
{
self
.
handle_ack
(
PNSpace
:
:
from
(
ptype
)
largest_acknowledged
ack_delay
first_ack_range
ack_ranges
now
)
?
;
}
Frame
:
:
ResetStream
{
stream_id
application_error_code
.
.
}
=
>
{
if
let
(
_
Some
(
rs
)
)
=
self
.
obtain_stream
(
stream_id
)
?
{
rs
.
reset
(
application_error_code
)
;
}
}
Frame
:
:
StopSending
{
stream_id
application_error_code
}
=
>
{
self
.
events
.
send_stream_stop_sending
(
stream_id
application_error_code
)
;
if
let
(
Some
(
ss
)
_
)
=
self
.
obtain_stream
(
stream_id
)
?
{
ss
.
reset
(
application_error_code
)
;
}
}
Frame
:
:
Crypto
{
offset
data
}
=
>
{
let
space
=
PNSpace
:
:
from
(
ptype
)
;
qtrace
!
(
[
self
]
"
Crypto
frame
on
space
=
{
}
offset
=
{
}
data
=
{
:
0x
?
}
"
space
offset
&
data
)
;
self
.
crypto
.
streams
.
inbound_frame
(
space
offset
data
)
?
;
if
self
.
crypto
.
streams
.
data_ready
(
space
)
{
let
mut
buf
=
Vec
:
:
new
(
)
;
let
read
=
self
.
crypto
.
streams
.
read_to_end
(
space
&
mut
buf
)
;
qdebug
!
(
"
Read
{
}
bytes
"
read
)
;
self
.
handshake
(
now
space
Some
(
&
buf
)
)
?
;
}
}
Frame
:
:
NewToken
{
token
}
=
>
self
.
token
=
Some
(
token
)
Frame
:
:
Stream
{
fin
stream_id
offset
data
.
.
}
=
>
{
if
let
(
_
Some
(
rs
)
)
=
self
.
obtain_stream
(
stream_id
)
?
{
rs
.
inbound_stream_frame
(
fin
offset
data
)
?
;
}
}
Frame
:
:
MaxData
{
maximum_data
}
=
>
self
.
handle_max_data
(
maximum_data
)
Frame
:
:
MaxStreamData
{
stream_id
maximum_stream_data
}
=
>
{
if
let
(
Some
(
ss
)
_
)
=
self
.
obtain_stream
(
stream_id
)
?
{
ss
.
set_max_stream_data
(
maximum_stream_data
)
;
}
}
Frame
:
:
MaxStreams
{
stream_type
maximum_streams
}
=
>
{
let
remote_max
=
match
stream_type
{
StreamType
:
:
BiDi
=
>
&
mut
self
.
indexes
.
remote_max_stream_bidi
StreamType
:
:
UniDi
=
>
&
mut
self
.
indexes
.
remote_max_stream_uni
}
;
if
maximum_streams
>
*
remote_max
{
*
remote_max
=
maximum_streams
;
self
.
events
.
send_stream_creatable
(
stream_type
)
;
}
}
Frame
:
:
DataBlocked
{
data_limit
}
=
>
{
qwarn
!
(
[
self
]
"
Received
DataBlocked
with
data
limit
{
}
"
data_limit
)
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_data
(
LOCAL_MAX_DATA
)
;
}
Frame
:
:
StreamDataBlocked
{
stream_id
stream_data_limit
}
=
>
{
if
stream_id
.
is_send_only
(
self
.
role
(
)
)
{
return
Err
(
Error
:
:
StreamStateError
)
;
}
if
let
(
_
Some
(
rs
)
)
=
self
.
obtain_stream
(
stream_id
)
?
{
if
let
Some
(
msd
)
=
rs
.
max_stream_data
(
)
{
qinfo
!
(
[
self
]
"
Got
StreamDataBlocked
(
id
{
}
MSD
{
}
)
;
curr
MSD
{
}
"
stream_id
.
as_u64
(
)
stream_data_limit
msd
)
;
if
stream_data_limit
!
=
msd
{
self
.
flow_mgr
.
borrow_mut
(
)
.
max_stream_data
(
stream_id
msd
)
}
}
}
}
Frame
:
:
StreamsBlocked
{
stream_type
.
.
}
=
>
{
let
local_max
=
match
stream_type
{
StreamType
:
:
BiDi
=
>
&
mut
self
.
indexes
.
local_max_stream_bidi
StreamType
:
:
UniDi
=
>
&
mut
self
.
indexes
.
local_max_stream_uni
}
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_streams
(
*
local_max
stream_type
)
}
Frame
:
:
NewConnectionId
{
sequence_number
connection_id
stateless_reset_token
.
.
}
=
>
{
self
.
connection_ids
.
insert
(
sequence_number
(
connection_id
stateless_reset_token
)
)
;
}
Frame
:
:
RetireConnectionId
{
sequence_number
}
=
>
{
self
.
connection_ids
.
remove
(
&
sequence_number
)
;
}
Frame
:
:
PathChallenge
{
data
}
=
>
self
.
flow_mgr
.
borrow_mut
(
)
.
path_response
(
data
)
Frame
:
:
PathResponse
{
.
.
}
=
>
{
qwarn
!
(
[
self
]
"
Received
Path
Response
"
)
;
}
Frame
:
:
ConnectionClose
{
error_code
frame_type
reason_phrase
}
=
>
{
let
reason_phrase
=
String
:
:
from_utf8_lossy
(
&
reason_phrase
)
;
qinfo
!
(
[
self
]
"
ConnectionClose
received
.
Error
code
:
{
:
?
}
frame
type
{
:
x
}
reason
{
}
"
error_code
frame_type
reason_phrase
)
;
let
(
detail
frame_type
)
=
if
let
CloseError
:
:
Application
(
_
)
=
error_code
{
(
Error
:
:
PeerApplicationError
(
error_code
.
code
(
)
)
FRAME_TYPE_CONNECTION_CLOSE_APPLICATION
)
}
else
{
(
Error
:
:
PeerError
(
error_code
.
code
(
)
)
FRAME_TYPE_CONNECTION_CLOSE_TRANSPORT
)
}
;
let
error
=
ConnectionError
:
:
Transport
(
detail
)
;
self
.
state_signaling
.
drain
(
error
.
clone
(
)
frame_type
"
"
)
;
self
.
set_state
(
State
:
:
Draining
{
error
timeout
:
self
.
get_closing_period_time
(
now
)
}
)
;
}
Frame
:
:
HandshakeDone
=
>
{
if
self
.
role
=
=
Role
:
:
Server
|
|
!
self
.
state
.
connected
(
)
{
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
self
.
set_state
(
State
:
:
Confirmed
)
;
self
.
discard_keys
(
PNSpace
:
:
Handshake
)
;
}
}
;
Ok
(
(
)
)
}
fn
handle_lost_packets
(
&
mut
self
lost_packets
:
&
[
SentPacket
]
)
{
for
lost
in
lost_packets
{
for
token
in
lost
.
tokens
.
as_ref
(
)
{
qdebug
!
(
[
self
]
"
Lost
:
{
:
?
}
"
token
)
;
match
token
{
RecoveryToken
:
:
Ack
(
_
)
=
>
{
}
RecoveryToken
:
:
Stream
(
st
)
=
>
self
.
send_streams
.
lost
(
&
st
)
RecoveryToken
:
:
Crypto
(
ct
)
=
>
self
.
crypto
.
lost
(
&
ct
)
RecoveryToken
:
:
Flow
(
ft
)
=
>
self
.
flow_mgr
.
borrow_mut
(
)
.
lost
(
&
ft
&
mut
self
.
send_streams
&
mut
self
.
recv_streams
&
mut
self
.
indexes
)
RecoveryToken
:
:
HandshakeDone
=
>
self
.
state_signaling
.
handshake_done
(
)
}
}
}
}
fn
handle_ack
(
&
mut
self
space
:
PNSpace
largest_acknowledged
:
u64
ack_delay
:
u64
first_ack_range
:
u64
ack_ranges
:
Vec
<
AckRange
>
now
:
Instant
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
Rx
ACK
space
=
{
}
largest_acked
=
{
}
first_ack_range
=
{
}
ranges
=
{
:
?
}
"
space
largest_acknowledged
first_ack_range
ack_ranges
)
;
let
acked_ranges
=
Frame
:
:
decode_ack_frame
(
largest_acknowledged
first_ack_range
&
ack_ranges
)
?
;
let
(
acked_packets
lost_packets
)
=
self
.
loss_recovery
.
on_ack_received
(
space
largest_acknowledged
acked_ranges
Duration
:
:
from_millis
(
ack_delay
)
now
)
;
for
acked
in
acked_packets
{
for
token
in
acked
.
tokens
.
as_ref
(
)
{
match
token
{
RecoveryToken
:
:
Ack
(
at
)
=
>
self
.
acks
.
acked
(
at
)
RecoveryToken
:
:
Stream
(
st
)
=
>
self
.
send_streams
.
acked
(
st
)
RecoveryToken
:
:
Crypto
(
ct
)
=
>
self
.
crypto
.
acked
(
ct
)
RecoveryToken
:
:
Flow
(
ft
)
=
>
{
self
.
flow_mgr
.
borrow_mut
(
)
.
acked
(
ft
&
mut
self
.
send_streams
)
}
RecoveryToken
:
:
HandshakeDone
=
>
(
)
}
}
}
self
.
handle_lost_packets
(
&
lost_packets
)
;
qlog
:
:
packets_lost
(
&
mut
self
.
qlog
.
borrow_mut
(
)
&
lost_packets
)
;
Ok
(
(
)
)
}
fn
client_0rtt_rejected
(
&
mut
self
)
{
if
!
matches
!
(
self
.
zero_rtt_state
ZeroRttState
:
:
Sending
)
{
return
;
}
qdebug
!
(
[
self
]
"
0
-
RTT
rejected
"
)
;
let
dropped
=
self
.
loss_recovery
.
drop_0rtt
(
)
;
self
.
handle_lost_packets
(
&
dropped
)
;
self
.
send_streams
.
clear
(
)
;
self
.
recv_streams
.
clear
(
)
;
self
.
indexes
=
StreamIndexes
:
:
new
(
)
;
self
.
crypto
.
states
.
discard_0rtt_keys
(
)
;
self
.
events
.
client_0rtt_rejected
(
)
;
}
fn
set_connected
(
&
mut
self
now
:
Instant
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
TLS
connection
complete
"
)
;
if
self
.
crypto
.
tls
.
info
(
)
.
map
(
SecretAgentInfo
:
:
alpn
)
.
is_none
(
)
{
qwarn
!
(
[
self
]
"
No
ALPN
.
Closing
connection
.
"
)
;
return
Err
(
Error
:
:
CryptoAlert
(
120
)
)
;
}
if
self
.
role
=
=
Role
:
:
Server
{
debug_assert_eq
!
(
1
self
.
valid_cids
.
len
(
)
)
;
self
.
valid_cids
.
clear
(
)
;
qlog
:
:
server_connection_started
(
&
mut
self
.
qlog
.
borrow_mut
(
)
self
.
path
.
as_ref
(
)
.
unwrap
(
)
)
;
}
else
{
self
.
zero_rtt_state
=
if
self
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
early_data_accepted
(
)
{
ZeroRttState
:
:
AcceptedClient
}
else
{
self
.
client_0rtt_rejected
(
)
;
ZeroRttState
:
:
Rejected
}
;
}
let
pto
=
self
.
loss_recovery
.
pto
(
)
;
self
.
crypto
.
install_application_keys
(
now
+
pto
)
?
;
self
.
process_tps
(
)
?
;
self
.
set_state
(
State
:
:
Connected
)
;
self
.
stats
.
resumed
=
self
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
resumed
(
)
;
if
self
.
role
=
=
Role
:
:
Server
{
self
.
state_signaling
.
handshake_done
(
)
;
self
.
set_state
(
State
:
:
Confirmed
)
;
}
qinfo
!
(
[
self
]
"
Connection
established
"
)
;
qlog
:
:
connection_tparams_set
(
&
mut
self
.
qlog
.
borrow_mut
(
)
&
*
self
.
tps
.
borrow
(
)
)
;
Ok
(
(
)
)
}
fn
set_state
(
&
mut
self
state
:
State
)
{
if
state
>
self
.
state
{
qinfo
!
(
[
self
]
"
State
change
from
{
:
?
}
-
>
{
:
?
}
"
self
.
state
state
)
;
self
.
state
=
state
.
clone
(
)
;
if
self
.
state
.
closed
(
)
{
self
.
send_streams
.
clear
(
)
;
self
.
recv_streams
.
clear
(
)
;
}
self
.
events
.
connection_state_change
(
state
)
;
}
else
if
mem
:
:
discriminant
(
&
state
)
!
=
mem
:
:
discriminant
(
&
self
.
state
)
{
debug_assert
!
(
matches
!
(
state
State
:
:
Closing
{
.
.
}
|
State
:
:
Draining
{
.
.
}
)
)
;
debug_assert
!
(
self
.
state
.
closed
(
)
)
;
}
}
fn
cleanup_streams
(
&
mut
self
)
{
let
recv_to_remove
=
self
.
recv_streams
.
iter
(
)
.
filter
(
|
(
_
stream
)
|
stream
.
is_terminal
(
)
)
.
map
(
|
(
id
_
)
|
*
id
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
removed_bidi
=
0
;
let
mut
removed_uni
=
0
;
for
id
in
&
recv_to_remove
{
self
.
recv_streams
.
remove
(
&
id
)
;
if
id
.
is_remote_initiated
(
self
.
role
(
)
)
{
if
id
.
is_bidi
(
)
{
removed_bidi
+
=
1
;
}
else
{
removed_uni
+
=
1
;
}
}
}
if
removed_bidi
>
0
{
self
.
indexes
.
local_max_stream_bidi
+
=
removed_bidi
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_streams
(
self
.
indexes
.
local_max_stream_bidi
StreamType
:
:
BiDi
)
}
if
removed_uni
>
0
{
self
.
indexes
.
local_max_stream_uni
+
=
removed_uni
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_streams
(
self
.
indexes
.
local_max_stream_uni
StreamType
:
:
UniDi
)
}
self
.
send_streams
.
clear_terminal
(
)
;
}
fn
obtain_stream
(
&
mut
self
stream_id
:
StreamId
)
-
>
Res
<
(
Option
<
&
mut
SendStream
>
Option
<
&
mut
RecvStream
>
)
>
{
if
!
self
.
state
.
connected
(
)
&
&
!
matches
!
(
(
&
self
.
state
&
self
.
zero_rtt_state
)
(
State
:
:
Handshaking
ZeroRttState
:
:
AcceptedServer
)
)
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
if
stream_id
.
is_remote_initiated
(
self
.
role
(
)
)
{
let
next_stream_idx
=
if
stream_id
.
is_bidi
(
)
{
&
mut
self
.
indexes
.
local_next_stream_bidi
}
else
{
&
mut
self
.
indexes
.
local_next_stream_uni
}
;
let
stream_idx
:
StreamIndex
=
stream_id
.
into
(
)
;
if
stream_idx
>
=
*
next_stream_idx
{
let
recv_initial_max_stream_data
=
if
stream_id
.
is_bidi
(
)
{
if
stream_idx
>
self
.
indexes
.
local_max_stream_bidi
{
qwarn
!
(
[
self
]
"
remote
bidi
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
stream_idx
self
.
indexes
.
local_max_stream_bidi
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
self
.
tps
.
borrow
(
)
.
local
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
)
}
else
{
if
stream_idx
>
self
.
indexes
.
local_max_stream_uni
{
qwarn
!
(
[
self
]
"
remote
uni
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
stream_idx
self
.
indexes
.
local_max_stream_uni
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
self
.
tps
.
borrow
(
)
.
local
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
)
}
;
loop
{
let
next_stream_id
=
next_stream_idx
.
to_stream_id
(
stream_id
.
stream_type
(
)
stream_id
.
role
(
)
)
;
self
.
recv_streams
.
insert
(
next_stream_id
RecvStream
:
:
new
(
next_stream_id
recv_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
if
next_stream_id
.
is_uni
(
)
{
self
.
events
.
new_stream
(
next_stream_id
)
;
}
else
{
let
send_initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
remote
(
)
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
)
;
self
.
send_streams
.
insert
(
next_stream_id
SendStream
:
:
new
(
next_stream_id
send_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
self
.
events
.
new_stream
(
next_stream_id
)
;
}
*
next_stream_idx
+
=
1
;
if
*
next_stream_idx
>
stream_idx
{
break
;
}
}
}
}
Ok
(
(
self
.
send_streams
.
get_mut
(
stream_id
)
.
ok
(
)
self
.
recv_streams
.
get_mut
(
&
stream_id
)
)
)
}
pub
fn
stream_create
(
&
mut
self
st
:
StreamType
)
-
>
Res
<
u64
>
{
match
self
.
state
{
State
:
:
Closing
{
.
.
}
|
State
:
:
Draining
{
.
.
}
|
State
:
:
Closed
{
.
.
}
=
>
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
State
:
:
WaitInitial
|
State
:
:
Handshaking
=
>
{
if
self
.
role
=
=
Role
:
:
Client
&
&
self
.
zero_rtt_state
!
=
ZeroRttState
:
:
Sending
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
}
_
=
>
(
)
}
Ok
(
match
st
{
StreamType
:
:
UniDi
=
>
{
if
self
.
indexes
.
remote_next_stream_uni
>
=
self
.
indexes
.
remote_max_stream_uni
{
self
.
flow_mgr
.
borrow_mut
(
)
.
streams_blocked
(
self
.
indexes
.
remote_max_stream_uni
StreamType
:
:
UniDi
)
;
qwarn
!
(
[
self
]
"
local
uni
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
self
.
indexes
.
remote_next_stream_uni
self
.
indexes
.
remote_max_stream_uni
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
let
new_id
=
self
.
indexes
.
remote_next_stream_uni
.
to_stream_id
(
StreamType
:
:
UniDi
self
.
role
)
;
self
.
indexes
.
remote_next_stream_uni
+
=
1
;
let
initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
remote
(
)
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
)
;
self
.
send_streams
.
insert
(
new_id
SendStream
:
:
new
(
new_id
initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
new_id
.
as_u64
(
)
}
StreamType
:
:
BiDi
=
>
{
if
self
.
indexes
.
remote_next_stream_bidi
>
=
self
.
indexes
.
remote_max_stream_bidi
{
self
.
flow_mgr
.
borrow_mut
(
)
.
streams_blocked
(
self
.
indexes
.
remote_max_stream_bidi
StreamType
:
:
BiDi
)
;
qwarn
!
(
[
self
]
"
local
bidi
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
self
.
indexes
.
remote_next_stream_bidi
self
.
indexes
.
remote_max_stream_bidi
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
let
new_id
=
self
.
indexes
.
remote_next_stream_bidi
.
to_stream_id
(
StreamType
:
:
BiDi
self
.
role
)
;
self
.
indexes
.
remote_next_stream_bidi
+
=
1
;
let
send_initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
remote
(
)
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
)
;
self
.
send_streams
.
insert
(
new_id
SendStream
:
:
new
(
new_id
send_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
let
recv_initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
local
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
)
;
self
.
recv_streams
.
insert
(
new_id
RecvStream
:
:
new
(
new_id
recv_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
new_id
.
as_u64
(
)
}
}
)
}
pub
fn
stream_send
(
&
mut
self
stream_id
:
u64
data
:
&
[
u8
]
)
-
>
Res
<
usize
>
{
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
send
(
data
)
}
pub
fn
stream_send_atomic
(
&
mut
self
stream_id
:
u64
data
:
&
[
u8
]
)
-
>
Res
<
bool
>
{
let
val
=
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
send_atomic
(
data
)
;
if
let
Ok
(
val
)
=
val
{
debug_assert
!
(
val
=
=
0
|
|
val
=
=
data
.
len
(
)
"
Unexpected
value
{
}
when
trying
to
send
{
}
bytes
atomically
"
val
data
.
len
(
)
)
;
}
val
.
map
(
|
v
|
v
=
=
data
.
len
(
)
)
}
pub
fn
stream_avail_send_space
(
&
self
stream_id
:
u64
)
-
>
Res
<
usize
>
{
Ok
(
self
.
send_streams
.
get
(
stream_id
.
into
(
)
)
?
.
avail
(
)
)
}
pub
fn
stream_close_send
(
&
mut
self
stream_id
:
u64
)
-
>
Res
<
(
)
>
{
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
close
(
)
;
Ok
(
(
)
)
}
pub
fn
stream_reset_send
(
&
mut
self
stream_id
:
u64
err
:
AppError
)
-
>
Res
<
(
)
>
{
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
reset
(
err
)
;
Ok
(
(
)
)
}
pub
fn
stream_recv
(
&
mut
self
stream_id
:
u64
data
:
&
mut
[
u8
]
)
-
>
Res
<
(
usize
bool
)
>
{
let
stream
=
self
.
recv_streams
.
get_mut
(
&
stream_id
.
into
(
)
)
.
ok_or_else
(
|
|
Error
:
:
InvalidStreamId
)
?
;
let
rb
=
stream
.
read
(
data
)
?
;
Ok
(
(
rb
.
0
as
usize
rb
.
1
)
)
}
pub
fn
stream_stop_sending
(
&
mut
self
stream_id
:
u64
err
:
AppError
)
-
>
Res
<
(
)
>
{
let
stream
=
self
.
recv_streams
.
get_mut
(
&
stream_id
.
into
(
)
)
.
ok_or_else
(
|
|
Error
:
:
InvalidStreamId
)
?
;
stream
.
stop_sending
(
err
)
;
Ok
(
(
)
)
}
pub
fn
events
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
ConnectionEvent
>
{
self
.
events
.
events
(
)
}
pub
fn
has_events
(
&
self
)
-
>
bool
{
self
.
events
.
has_events
(
)
}
pub
fn
next_event
(
&
mut
self
)
-
>
Option
<
ConnectionEvent
>
{
self
.
events
.
next_event
(
)
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
Connection
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
{
:
p
}
"
self
.
role
self
as
*
const
Self
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
cc
:
:
PACING_BURST_SIZE
;
use
crate
:
:
cc
:
:
{
INITIAL_CWND_PKTS
MIN_CONG_WINDOW
}
;
use
crate
:
:
frame
:
:
{
CloseError
StreamType
}
;
use
crate
:
:
packet
:
:
PACKET_BIT_LONG
;
use
crate
:
:
path
:
:
PATH_MTU_V6
;
use
crate
:
:
recovery
:
:
ACK_ONLY_SIZE_LIMIT
;
use
crate
:
:
recovery
:
:
PTO_PACKET_COUNT
;
use
crate
:
:
tracking
:
:
{
ACK_DELAY
MAX_UNACKED_PKTS
}
;
use
std
:
:
convert
:
:
TryInto
;
use
neqo_common
:
:
matches
;
use
neqo_crypto
:
:
constants
:
:
TLS_CHACHA20_POLY1305_SHA256
;
use
std
:
:
mem
;
use
test_fixture
:
:
{
self
assertions
fixture_init
loopback
now
}
;
const
AT_LEAST_PTO
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
const
DEFAULT_STREAM_DATA
:
&
[
u8
]
=
b
"
message
"
;
pub
fn
default_client
(
)
-
>
Connection
{
fixture_init
(
)
;
Connection
:
:
new_client
(
test_fixture
:
:
DEFAULT_SERVER_NAME
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
3
)
)
)
loopback
(
)
loopback
(
)
QuicVersion
:
:
default
(
)
)
.
expect
(
"
create
a
default
client
"
)
}
pub
fn
default_server
(
)
-
>
Connection
{
fixture_init
(
)
;
Connection
:
:
new_server
(
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
&
test_fixture
:
:
anti_replay
(
)
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
5
)
)
)
QuicVersion
:
:
default
(
)
)
.
expect
(
"
create
a
default
server
"
)
}
pub
fn
maybe_authenticate
(
conn
:
&
mut
Connection
)
-
>
bool
{
let
authentication_needed
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
AuthenticationNeeded
)
;
if
conn
.
events
(
)
.
any
(
authentication_needed
)
{
conn
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
return
true
;
}
false
}
#
[
test
]
fn
bidi_stream_properties
(
)
{
let
id1
=
StreamIndex
:
:
new
(
4
)
.
to_stream_id
(
StreamType
:
:
BiDi
Role
:
:
Client
)
;
assert_eq
!
(
id1
.
is_bidi
(
)
true
)
;
assert_eq
!
(
id1
.
is_uni
(
)
false
)
;
assert_eq
!
(
id1
.
is_client_initiated
(
)
true
)
;
assert_eq
!
(
id1
.
is_server_initiated
(
)
false
)
;
assert_eq
!
(
id1
.
role
(
)
Role
:
:
Client
)
;
assert_eq
!
(
id1
.
is_self_initiated
(
Role
:
:
Client
)
true
)
;
assert_eq
!
(
id1
.
is_self_initiated
(
Role
:
:
Server
)
false
)
;
assert_eq
!
(
id1
.
is_remote_initiated
(
Role
:
:
Client
)
false
)
;
assert_eq
!
(
id1
.
is_remote_initiated
(
Role
:
:
Server
)
true
)
;
assert_eq
!
(
id1
.
is_send_only
(
Role
:
:
Server
)
false
)
;
assert_eq
!
(
id1
.
is_send_only
(
Role
:
:
Client
)
false
)
;
assert_eq
!
(
id1
.
is_recv_only
(
Role
:
:
Server
)
false
)
;
assert_eq
!
(
id1
.
is_recv_only
(
Role
:
:
Client
)
false
)
;
assert_eq
!
(
id1
.
as_u64
(
)
16
)
;
}
#
[
test
]
fn
uni_stream_properties
(
)
{
let
id2
=
StreamIndex
:
:
new
(
8
)
.
to_stream_id
(
StreamType
:
:
UniDi
Role
:
:
Server
)
;
assert_eq
!
(
id2
.
is_bidi
(
)
false
)
;
assert_eq
!
(
id2
.
is_uni
(
)
true
)
;
assert_eq
!
(
id2
.
is_client_initiated
(
)
false
)
;
assert_eq
!
(
id2
.
is_server_initiated
(
)
true
)
;
assert_eq
!
(
id2
.
role
(
)
Role
:
:
Server
)
;
assert_eq
!
(
id2
.
is_self_initiated
(
Role
:
:
Client
)
false
)
;
assert_eq
!
(
id2
.
is_self_initiated
(
Role
:
:
Server
)
true
)
;
assert_eq
!
(
id2
.
is_remote_initiated
(
Role
:
:
Client
)
true
)
;
assert_eq
!
(
id2
.
is_remote_initiated
(
Role
:
:
Server
)
false
)
;
assert_eq
!
(
id2
.
is_send_only
(
Role
:
:
Server
)
true
)
;
assert_eq
!
(
id2
.
is_send_only
(
Role
:
:
Client
)
false
)
;
assert_eq
!
(
id2
.
is_recv_only
(
Role
:
:
Server
)
false
)
;
assert_eq
!
(
id2
.
is_recv_only
(
Role
:
:
Client
)
true
)
;
assert_eq
!
(
id2
.
as_u64
(
)
35
)
;
}
#
[
test
]
fn
test_conn_stream_create
(
)
{
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
6
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
4
)
;
let
_
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
3
)
;
assert_eq
!
(
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
7
)
;
assert_eq
!
(
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
1
)
;
assert_eq
!
(
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
5
)
;
}
#
[
test
]
fn
test_conn_handshake
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
qdebug
!
(
"
-
-
-
-
server
:
FIN
-
>
ACKS
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
qdebug
!
(
"
-
-
-
-
client
:
ACKS
-
>
0
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
handshake_failed_authentication
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
authentication_needed
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
AuthenticationNeeded
)
;
assert
!
(
client
.
events
(
)
.
any
(
authentication_needed
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
Alert
(
certificate_revoked
)
"
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
CertRevoked
now
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
-
>
Alert
(
certificate_revoked
)
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
Alert
(
certificate_revoked
)
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_error
(
&
client
ConnectionError
:
:
Transport
(
Error
:
:
CryptoAlert
(
44
)
)
)
;
assert_error
(
&
server
ConnectionError
:
:
Transport
(
Error
:
:
PeerError
(
300
)
)
)
;
}
#
[
test
]
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
test_conn_stream
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
qdebug
!
(
"
-
-
-
-
client
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
"
)
;
let
client_stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id
&
[
6
;
100
]
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id
&
[
7
;
40
]
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id
&
[
8
;
4000
]
)
.
unwrap
(
)
;
let
client_stream_id2
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id2
&
[
6
;
60
]
)
.
unwrap
(
)
;
client
.
stream_close_send
(
client_stream_id2
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id2
&
[
7
;
50
]
)
.
unwrap_err
(
)
;
let
mut
datagrams
=
vec
!
[
]
;
let
mut
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
d
)
=
out
.
dgram
(
)
{
datagrams
.
push
(
d
)
;
out
=
client
.
process
(
None
now
(
)
)
;
}
assert_eq
!
(
datagrams
.
len
(
)
4
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
qdebug
!
(
"
-
-
-
-
server
"
)
;
for
(
d_num
d
)
in
datagrams
.
into_iter
(
)
.
enumerate
(
)
{
let
out
=
server
.
process
(
Some
(
d
)
now
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
(
d_num
as
u64
+
1
)
%
(
MAX_UNACKED_PKTS
+
1
)
=
=
0
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
}
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
let
mut
buf
=
vec
!
[
0
;
4000
]
;
let
mut
stream_ids
=
server
.
events
(
)
.
filter_map
(
|
evt
|
match
evt
{
ConnectionEvent
:
:
NewStream
{
stream_id
.
.
}
=
>
Some
(
stream_id
)
_
=
>
None
}
)
;
let
stream_id
=
stream_ids
.
next
(
)
.
expect
(
"
should
have
a
new
stream
event
"
)
;
let
(
received
fin
)
=
server
.
stream_recv
(
stream_id
.
as_u64
(
)
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
received
4000
)
;
assert_eq
!
(
fin
false
)
;
let
(
received
fin
)
=
server
.
stream_recv
(
stream_id
.
as_u64
(
)
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
received
140
)
;
assert_eq
!
(
fin
false
)
;
let
stream_id
=
stream_ids
.
next
(
)
.
expect
(
"
should
have
a
second
new
stream
event
"
)
;
let
(
received
fin
)
=
server
.
stream_recv
(
stream_id
.
as_u64
(
)
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
received
60
)
;
assert_eq
!
(
fin
true
)
;
}
fn
handshake
(
client
:
&
mut
Connection
server
:
&
mut
Connection
now
:
Instant
rtt
:
Duration
)
-
>
Instant
{
let
mut
a
=
client
;
let
mut
b
=
server
;
let
mut
now
=
now
;
let
mut
input
=
None
;
let
is_done
=
|
c
:
&
mut
Connection
|
match
c
.
state
(
)
{
State
:
:
Confirmed
|
State
:
:
Closing
{
.
.
}
|
State
:
:
Closed
(
.
.
)
=
>
true
_
=
>
false
}
;
while
!
is_done
(
a
)
{
let
_
=
maybe_authenticate
(
a
)
;
let
had_input
=
input
.
is_some
(
)
;
let
output
=
a
.
process
(
input
now
)
.
dgram
(
)
;
assert
!
(
had_input
|
|
output
.
is_some
(
)
)
;
input
=
output
;
now
+
=
rtt
/
2
;
mem
:
:
swap
(
&
mut
a
&
mut
b
)
;
}
let
_
=
a
.
process
(
input
now
)
;
now
}
fn
connect_with_rtt
(
client
:
&
mut
Connection
server
:
&
mut
Connection
now
:
Instant
rtt
:
Duration
)
-
>
Instant
{
let
now
=
handshake
(
client
server
now
rtt
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
rtt
)
;
assert_eq
!
(
server
.
loss_recovery
.
rtt
(
)
rtt
)
;
now
}
fn
connect
(
client
:
&
mut
Connection
server
:
&
mut
Connection
)
{
connect_with_rtt
(
client
server
now
(
)
Duration
:
:
new
(
0
0
)
)
;
}
fn
assert_error
(
c
:
&
Connection
err
:
ConnectionError
)
{
match
c
.
state
(
)
{
State
:
:
Closing
{
error
.
.
}
|
State
:
:
Draining
{
error
.
.
}
|
State
:
:
Closed
(
error
)
=
>
{
assert_eq
!
(
*
error
err
)
;
}
_
=
>
panic
!
(
"
bad
state
{
:
?
}
"
c
.
state
(
)
)
}
}
#
[
test
]
fn
test_no_alpn
(
)
{
fixture_init
(
)
;
let
mut
client
=
Connection
:
:
new_client
(
"
example
.
com
"
&
[
"
bad
-
alpn
"
]
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
9
)
)
)
loopback
(
)
loopback
(
)
QuicVersion
:
:
default
(
)
)
.
unwrap
(
)
;
let
mut
server
=
default_server
(
)
;
handshake
(
&
mut
client
&
mut
server
now
(
)
Duration
:
:
new
(
0
0
)
)
;
assert_error
(
&
server
ConnectionError
:
:
Transport
(
Error
:
:
CryptoAlert
(
120
)
)
)
;
}
#
[
test
]
fn
test_dup_server_flight1
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
out_to_rep
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out_to_rep
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out_to_rep
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
Some
(
out_to_rep
.
as_dgram_ref
(
)
.
unwrap
(
)
.
clone
(
)
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
2
client
.
stats
(
)
.
packets_rx
)
;
assert_eq
!
(
0
client
.
stats
(
)
.
dups_rx
)
;
qdebug
!
(
"
-
-
-
-
Dup
ignored
"
)
;
let
out
=
client
.
process
(
out_to_rep
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
4
client
.
stats
(
)
.
packets_rx
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dups_rx
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
}
fn
exchange_ticket
(
client
:
&
mut
Connection
server
:
&
mut
Connection
now
:
Instant
)
-
>
Vec
<
u8
>
{
server
.
send_ticket
(
now
&
[
]
)
.
expect
(
"
can
send
ticket
"
)
;
let
ticket
=
server
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
ticket
.
is_some
(
)
)
;
client
.
process_input
(
ticket
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
client
.
resumption_token
(
)
.
expect
(
"
should
have
token
"
)
}
#
[
test
]
fn
connection_close
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
client
.
close
(
now
42
"
"
)
;
let
out
=
client
.
process
(
None
now
)
;
let
frames
=
server
.
test_process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert_eq
!
(
frames
.
len
(
)
1
)
;
assert
!
(
matches
!
(
frames
[
0
]
(
Frame
:
:
ConnectionClose
{
error_code
:
CloseError
:
:
Application
(
42
)
.
.
}
PNSpace
:
:
ApplicationData
)
)
)
;
}
#
[
test
]
fn
resume
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
default_client
(
)
;
client
.
set_resumption_token
(
now
(
)
&
token
[
.
.
]
)
.
expect
(
"
should
set
token
"
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert
!
(
client
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
assert
!
(
server
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
}
#
[
test
]
fn
remember_smoothed_rtt
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
const
RTT1
:
Duration
=
Duration
:
:
from_millis
(
130
)
;
let
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT1
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
RTT1
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
client
.
set_resumption_token
(
now
&
token
[
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
RTT1
"
client
should
remember
previous
RTT
"
)
;
const
RTT2
:
Duration
=
Duration
:
:
from_millis
(
70
)
;
connect_with_rtt
(
&
mut
client
&
mut
server
now
RTT2
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
RTT2
"
previous
RTT
should
be
completely
erased
"
)
;
}
#
[
test
]
fn
zero_rtt_negotiate
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
default_client
(
)
;
client
.
set_resumption_token
(
now
(
)
&
token
[
.
.
]
)
.
expect
(
"
should
set
token
"
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert
!
(
client
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
early_data_accepted
(
)
)
;
assert
!
(
server
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
early_data_accepted
(
)
)
;
}
#
[
test
]
fn
zero_rtt_send_recv
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
default_client
(
)
;
client
.
set_resumption_token
(
now
(
)
&
token
[
.
.
]
)
.
expect
(
"
should
set
token
"
)
;
let
mut
server
=
default_server
(
)
;
let
client_hs
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client_stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id
&
[
1
2
3
]
)
.
unwrap
(
)
;
let
client_0rtt
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_0rtt
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert
!
(
client_0rtt
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
<
1200
)
;
let
server_hs
=
server
.
process
(
client_hs
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_process_0rtt
=
server
.
process
(
client_0rtt
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_process_0rtt
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
server_stream_id
=
server
.
events
(
)
.
find_map
(
|
evt
|
match
evt
{
ConnectionEvent
:
:
NewStream
{
stream_id
.
.
}
=
>
Some
(
stream_id
)
_
=
>
None
}
)
.
expect
(
"
should
have
received
a
new
stream
event
"
)
;
assert_eq
!
(
client_stream_id
server_stream_id
.
as_u64
(
)
)
;
}
#
[
test
]
fn
zero_rtt_send_coalesce
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
default_client
(
)
;
client
.
set_resumption_token
(
now
(
)
&
token
[
.
.
]
)
.
expect
(
"
should
set
token
"
)
;
let
mut
server
=
default_server
(
)
;
let
client_stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id
&
[
1
2
3
]
)
.
unwrap
(
)
;
let
client_0rtt
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_0rtt
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assertions
:
:
assert_coalesced_0rtt
(
&
client_0rtt
.
as_dgram_ref
(
)
.
unwrap
(
)
[
.
.
]
)
;
let
server_hs
=
server
.
process
(
client_0rtt
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_stream_id
=
server
.
events
(
)
.
find_map
(
|
evt
|
match
evt
{
ConnectionEvent
:
:
NewStream
{
stream_id
}
=
>
Some
(
stream_id
)
_
=
>
None
}
)
.
expect
(
"
should
have
received
a
new
stream
event
"
)
;
assert_eq
!
(
client_stream_id
server_stream_id
.
as_u64
(
)
)
;
}
#
[
test
]
fn
zero_rtt_before_resumption_token
(
)
{
let
mut
client
=
default_client
(
)
;
assert
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
zero_rtt_send_reject
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
default_client
(
)
;
client
.
set_resumption_token
(
now
(
)
&
token
[
.
.
]
)
.
expect
(
"
should
set
token
"
)
;
let
ar
=
AntiReplay
:
:
new
(
now
(
)
test_fixture
:
:
ANTI_REPLAY_WINDOW
1
3
)
.
expect
(
"
setup
anti
-
replay
"
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
&
ar
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
10
)
)
)
QuicVersion
:
:
default
(
)
)
.
unwrap
(
)
;
let
client_hs
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
msg
=
&
[
1
2
3
]
;
client
.
stream_send
(
stream_id
msg
)
.
unwrap
(
)
;
let
client_0rtt
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_0rtt
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_hs
=
server
.
process
(
client_hs
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_ignored
=
server
.
process
(
client_0rtt
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_ignored
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
recvd_stream_evt
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
NewStream
{
.
.
}
)
;
assert
!
(
!
server
.
events
(
)
.
any
(
recvd_stream_evt
)
)
;
let
client_fin
=
client
.
process
(
server_hs
.
dgram
(
)
now
(
)
)
;
let
recvd_0rtt_reject
=
|
e
|
e
=
=
ConnectionEvent
:
:
ZeroRttRejected
;
assert
!
(
client
.
events
(
)
.
any
(
recvd_0rtt_reject
)
)
;
let
server_ack
=
server
.
process
(
client_fin
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_ack
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client_out
=
client
.
process
(
server_ack
.
dgram
(
)
now
(
)
)
;
assert
!
(
client_out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
res
=
client
.
stream_send
(
stream_id
msg
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
let
stream_id_after_reject
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
stream_id_after_reject
)
;
let
msg
=
&
[
1
2
3
]
;
client
.
stream_send
(
stream_id_after_reject
msg
)
.
unwrap
(
)
;
let
client_after_reject
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_after_reject
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_out
=
server
.
process
(
client_after_reject
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
recvd_stream_evt
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
NewStream
{
.
.
}
)
;
assert
!
(
server
.
events
(
)
.
any
(
recvd_stream_evt
)
)
;
}
#
[
test
]
fn
report_fin_when_stream_closed_wo_data
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
client
.
stream_send
(
stream_id
&
[
0x00
]
)
.
unwrap
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
stream_close_send
(
stream_id
)
)
;
let
out
=
server
.
process
(
None
now
(
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
stream_readable
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
.
.
}
)
;
assert
!
(
client
.
events
(
)
.
any
(
stream_readable
)
)
;
}
fn
connect_rtt_idle
(
client
:
&
mut
Connection
server
:
&
mut
Connection
rtt
:
Duration
)
-
>
Instant
{
let
mut
now
=
connect_with_rtt
(
client
server
now
(
)
rtt
)
;
let
p1
=
send_something
(
server
now
)
;
let
p2
=
send_something
(
server
now
)
;
now
+
=
rtt
/
2
;
client
.
process_input
(
p2
now
)
;
let
ack
=
client
.
process
(
Some
(
p1
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
assert_eq
!
(
server
.
process
(
ack
now
)
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
process_output
(
now
)
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
now
}
fn
connect_force_idle
(
client
:
&
mut
Connection
server
:
&
mut
Connection
)
{
connect_rtt_idle
(
client
server
Duration
:
:
new
(
0
0
)
)
;
}
#
[
test
]
fn
idle_timeout
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
-
Duration
:
:
from_secs
(
1
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
asymmetric_idle_timeout
(
)
{
const
LOWER_TIMEOUT_MS
:
u64
=
1000
;
const
LOWER_TIMEOUT
:
Duration
=
Duration
:
:
from_millis
(
LOWER_TIMEOUT_MS
)
;
assert
!
(
LOWER_TIMEOUT
<
LOCAL_IDLE_TIMEOUT
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
tps
.
borrow_mut
(
)
.
local
.
set_integer
(
tparams
:
:
IDLE_TIMEOUT
LOWER_TIMEOUT_MS
)
;
server
.
idle_timeout
.
timeout
=
LOWER_TIMEOUT
;
connect
(
&
mut
client
&
mut
server
)
;
let
p1
=
send_something
(
&
mut
server
now
(
)
)
;
let
p2
=
send_something
(
&
mut
server
now
(
)
)
;
client
.
process_input
(
p2
now
(
)
)
;
let
ack
=
client
.
process
(
Some
(
p1
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
assert_eq
!
(
server
.
process
(
ack
now
(
)
)
Output
:
:
Callback
(
LOWER_TIMEOUT
)
)
;
assert_eq
!
(
client
.
process
(
None
now
(
)
)
Output
:
:
Callback
(
LOWER_TIMEOUT
)
)
;
}
#
[
test
]
fn
tiny_idle_timeout
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
500
)
;
const
LOWER_TIMEOUT_MS
:
u64
=
100
;
const
LOWER_TIMEOUT
:
Duration
=
Duration
:
:
from_millis
(
LOWER_TIMEOUT_MS
)
;
assert
!
(
LOWER_TIMEOUT
<
3
*
RTT
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
set_local_tparam
(
tparams
:
:
IDLE_TIMEOUT
TransportParameter
:
:
Integer
(
LOWER_TIMEOUT_MS
)
)
.
unwrap
(
)
;
server
.
idle_timeout
.
timeout
=
LOWER_TIMEOUT
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
let
p1
=
send_something
(
&
mut
server
now
)
;
let
p2
=
send_something
(
&
mut
server
now
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
p2
now
)
;
let
ack
=
client
.
process
(
Some
(
p1
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
if
let
Output
:
:
Callback
(
t
)
=
client
.
process
(
None
now
)
{
assert
!
(
t
>
LOWER_TIMEOUT
)
;
}
else
{
panic
!
(
"
Client
not
idle
"
)
;
}
now
+
=
RTT
/
2
;
if
let
Output
:
:
Callback
(
t
)
=
client
.
process
(
ack
now
)
{
assert
!
(
t
>
LOWER_TIMEOUT
)
;
}
else
{
panic
!
(
"
Client
not
idle
"
)
;
}
}
#
[
test
]
fn
idle_send_packet1
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
hello
"
)
.
unwrap
(
)
5
)
;
let
out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
9
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
idle_send_packet2
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
hello
"
)
.
unwrap
(
)
5
)
;
let
_out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
there
"
)
.
unwrap
(
)
5
)
;
let
_out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
20
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
9
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
idle_recv_packet
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
assert_eq
!
(
client
.
stream_send
(
0
b
"
hello
"
)
.
unwrap
(
)
5
)
;
let
out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
server
.
stream_send
(
0
b
"
world
"
)
.
unwrap
(
)
5
)
;
let
out
=
server
.
process_output
(
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_ne
!
(
out
.
as_dgram_ref
(
)
None
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
20
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
19
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
20
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
max_data
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
const
SMALL_MAX_DATA
:
usize
=
16383
;
server
.
set_local_tparam
(
tparams
:
:
INITIAL_MAX_DATA
TransportParameter
:
:
Integer
(
SMALL_MAX_DATA
.
try_into
(
)
.
unwrap
(
)
)
)
.
unwrap
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
2
)
;
assert_eq
!
(
client
.
stream_avail_send_space
(
stream_id
)
.
unwrap
(
)
SMALL_MAX_DATA
)
;
assert_eq
!
(
client
.
stream_send
(
stream_id
&
[
b
'
a
'
;
RX_STREAM_DATA_WINDOW
as
usize
]
)
.
unwrap
(
)
SMALL_MAX_DATA
)
;
let
evts
=
client
.
events
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
evts
.
len
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
stream_id
b
"
hello
"
)
.
unwrap
(
)
0
)
;
let
ss
=
client
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
.
unwrap
(
)
;
ss
.
mark_as_sent
(
0
4096
false
)
;
ss
.
mark_as_acked
(
0
4096
false
)
;
let
evts
=
client
.
events
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
evts
.
len
(
)
0
)
;
client
.
handle_max_data
(
100_000
)
;
assert_eq
!
(
client
.
stream_avail_send_space
(
stream_id
)
.
unwrap
(
)
49152
)
;
let
evts
=
client
.
events
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
evts
.
len
(
)
1
)
;
assert
!
(
matches
!
(
evts
[
0
]
ConnectionEvent
:
:
SendStreamWritable
{
.
.
}
)
)
;
}
#
[
test
]
fn
test_crypto_frame_split
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
LONG_CERT_KEYS
test_fixture
:
:
DEFAULT_ALPN
&
test_fixture
:
:
anti_replay
(
)
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
6
)
)
)
QuicVersion
:
:
default
(
)
)
.
expect
(
"
create
a
server
"
)
;
let
client1
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server1
=
server
.
process
(
client1
.
dgram
(
)
now
(
)
)
;
assert
!
(
server1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server2
=
server
.
process
(
None
now
(
)
)
;
assert
!
(
server2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client2
=
client
.
process
(
server1
.
dgram
(
)
now
(
)
)
;
assert
!
(
client2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
auth1
=
maybe_authenticate
(
&
mut
client
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Handshaking
)
;
let
server3
=
server
.
process
(
client2
.
dgram
(
)
now
(
)
)
;
assert
!
(
server3
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
client3
=
client
.
process
(
server2
.
dgram
(
)
now
(
)
)
;
let
auth2
=
maybe_authenticate
(
&
mut
client
)
;
assert
!
(
auth1
^
auth2
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
client4
=
client
.
process
(
server3
.
dgram
(
)
now
(
)
)
;
assert
!
(
client3
.
as_dgram_ref
(
)
.
is_some
(
)
^
client4
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
_
=
server
.
process
(
client3
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
process
(
client4
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
set_local_tparam
(
)
{
let
client
=
default_client
(
)
;
client
.
set_local_tparam
(
tparams
:
:
INITIAL_MAX_DATA
TransportParameter
:
:
Integer
(
55
)
)
.
unwrap
(
)
}
#
[
test
]
fn
do_not_accept_data_after_stop_sending
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
client
.
stream_send
(
stream_id
&
[
0x00
]
)
.
unwrap
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
stream_readable
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
.
.
}
)
;
assert
!
(
server
.
events
(
)
.
any
(
stream_readable
)
)
;
client
.
stream_send
(
stream_id
&
[
0x00
]
)
.
unwrap
(
)
;
let
out_second_data_frame
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
stream_stop_sending
(
stream_id
Error
:
:
NoError
.
code
(
)
)
)
;
let
out
=
server
.
process
(
out_second_data_frame
.
dgram
(
)
now
(
)
)
;
assert
!
(
!
server
.
events
(
)
.
any
(
stream_readable
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
Err
(
Error
:
:
FinalSizeError
)
client
.
stream_send
(
stream_id
&
[
0x00
]
)
)
;
}
#
[
test
]
fn
simultaneous_stop_sending_and_reset
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
client
.
stream_send
(
stream_id
&
[
0x00
]
)
.
unwrap
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
stream_readable
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
.
.
}
)
;
assert
!
(
server
.
events
(
)
.
any
(
stream_readable
)
)
;
client
.
stream_reset_send
(
stream_id
Error
:
:
NoError
.
code
(
)
)
.
unwrap
(
)
;
let
out_reset_frame
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
stream_stop_sending
(
stream_id
Error
:
:
NoError
.
code
(
)
)
)
;
let
out
=
server
.
process
(
out_reset_frame
.
dgram
(
)
now
(
)
)
;
assert
!
(
!
server
.
events
(
)
.
any
(
stream_readable
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
Err
(
Error
:
:
InvalidStreamId
)
client
.
stream_send
(
stream_id
&
[
0x00
]
)
)
;
}
#
[
test
]
fn
test_client_fin_reorder
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
client_hs
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_hs
=
server
.
process
(
client_hs
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client_ack
=
client
.
process
(
server_hs
.
dgram
(
)
now
(
)
)
;
assert
!
(
client_ack
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_out
=
server
.
process
(
client_ack
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
client_fin
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_fin
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client_stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream_id
&
[
1
2
3
]
)
.
unwrap
(
)
;
let
client_stream_data
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_stream_data
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_out
=
server
.
process
(
client_stream_data
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Handshaking
)
;
let
server_out
=
server
.
process
(
client_fin
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
}
#
[
test
]
fn
pto_works_basic
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
hello
"
)
.
unwrap
(
)
5
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
world
"
)
.
unwrap
(
)
6
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
6
)
;
assert_eq
!
(
client
.
stream_send
(
6
b
"
there
!
"
)
.
unwrap
(
)
6
)
;
now
+
=
Duration
:
:
from_secs
(
10
)
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
out
.
dgram
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
_
)
)
)
;
now
+
=
AT_LEAST_PTO
;
let
out
=
client
.
process
(
None
now
)
;
let
frames
=
server
.
test_process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert
!
(
frames
.
iter
(
)
.
all
(
|
(
_
sp
)
|
*
sp
=
=
PNSpace
:
:
ApplicationData
)
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
*
f
=
=
Frame
:
:
Ping
)
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
matches
!
(
f
Frame
:
:
Stream
{
stream_id
.
.
}
if
stream_id
.
as_u64
(
)
=
=
2
)
)
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
matches
!
(
f
Frame
:
:
Stream
{
stream_id
.
.
}
if
stream_id
.
as_u64
(
)
=
=
6
)
)
)
;
}
#
[
test
]
fn
pto_works_full_cwnd
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
res
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
2
now
(
)
)
;
assert_full_cwnd
(
&
dgrams
POST_HANDSHAKE_CWND
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
2
now
+
AT_LEAST_PTO
)
;
assert_eq
!
(
dgrams
.
len
(
)
2
)
;
for
d
in
dgrams
{
assert_eq
!
(
d
.
len
(
)
PATH_MTU_V6
)
;
let
frames
=
server
.
test_process_input
(
d
now
)
;
assert_eq
!
(
frames
.
iter
(
)
.
filter
(
|
i
|
matches
!
(
i
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
)
.
count
(
)
1
)
;
assert
!
(
frames
.
iter
(
)
.
filter
(
|
i
|
matches
!
(
i
(
Frame
:
:
Stream
{
.
.
}
PNSpace
:
:
ApplicationData
)
)
)
.
count
(
)
>
=
1
)
;
}
}
#
[
test
]
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
pto_works_ping
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
zero
"
)
.
unwrap
(
)
4
)
;
let
pkt0
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
pkt0
Output
:
:
Datagram
(
_
)
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
one
"
)
.
unwrap
(
)
3
)
;
let
pkt1
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
two
"
)
.
unwrap
(
)
3
)
;
let
pkt2
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
three
"
)
.
unwrap
(
)
5
)
;
let
pkt3
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
let
out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
x
)
if
x
=
=
Duration
:
:
from_millis
(
45
)
)
)
;
let
srv0_pkt1
=
server
.
process
(
pkt1
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
srv0_pkt1
Output
:
:
Datagram
(
_
)
)
)
;
let
srv2
=
server
.
process
(
pkt2
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
20
)
)
;
assert
!
(
matches
!
(
srv2
Output
:
:
Callback
(
_
)
)
)
;
let
srv2
=
server
.
process
(
pkt3
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
20
)
)
;
assert
!
(
matches
!
(
srv2
Output
:
:
Datagram
(
_
)
)
)
;
let
pkt4
=
client
.
process
(
srv2
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
40
)
)
;
assert
!
(
matches
!
(
pkt4
Output
:
:
Datagram
(
_
)
)
)
;
let
srv_pkt2
=
server
.
process
(
pkt0
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
40
)
)
;
assert
!
(
matches
!
(
srv_pkt2
Output
:
:
Datagram
(
_
)
)
)
;
let
pkt5
=
client
.
process
(
srv_pkt2
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
40
)
)
;
assert
!
(
matches
!
(
pkt5
Output
:
:
Callback
(
_
)
)
)
;
let
pkt6
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
110
)
)
;
let
frames
=
server
.
test_process_input
(
pkt6
.
dgram
(
)
.
unwrap
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
110
)
)
;
assert_eq
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
;
}
#
[
test
]
fn
pto_initial
(
)
{
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
assert_eq
!
(
pkt1
.
clone
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
120
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
120
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
assert_eq
!
(
pkt2
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt3
.
is_some
(
)
)
;
assert_eq
!
(
pkt3
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
240
)
)
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
out
=
client
.
process
(
out
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
}
#
[
test
]
fn
pto_handshake
(
)
{
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
client
.
process
(
None
now
)
.
dgram
(
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
120
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
client
.
process
(
pkt
now
)
.
dgram
(
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
LOCAL_IDLE_TIMEOUT
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
assert
!
(
pkt
.
is_none
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
60
)
)
;
now
+
=
Duration
:
:
from_millis
(
60
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt3
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
120
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
pkt
.
is_some
(
)
)
;
let
dropped_before
=
server
.
stats
(
)
.
dropped_rx
;
let
frames
=
server
.
test_process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before
)
;
assert_eq
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
;
let
dropped_before
=
server
.
stats
(
)
.
dropped_rx
;
let
frames
=
server
.
test_process_input
(
pkt3
.
unwrap
(
)
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before
)
;
assert_eq
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
cb
=
client
.
process
(
pkt
now
)
.
callback
(
)
;
assert_eq
!
(
cb
ACK_DELAY
)
;
now
+
=
cb
;
let
out
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
LOCAL_IDLE_TIMEOUT
-
ACK_DELAY
)
;
}
#
[
test
]
fn
test_pto_handshake_and_app_data
(
)
{
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt
=
client
.
process
(
None
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
server
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
pkt
=
client
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
_pkt
=
server
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
zero
"
)
.
unwrap
(
)
4
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
and
1RTT
packet
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
60
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
60
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
frames
=
server
.
test_process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert
!
(
matches
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
Handshake
)
)
)
;
assert
!
(
matches
!
(
frames
[
1
]
(
Frame
:
:
Crypto
{
.
.
}
PNSpace
:
:
Handshake
)
)
)
;
assert
!
(
matches
!
(
frames
[
2
]
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
)
;
assert
!
(
matches
!
(
frames
[
3
]
(
Frame
:
:
Stream
{
.
.
}
PNSpace
:
:
ApplicationData
)
)
)
;
}
#
[
test
]
fn
pto_count_increase_across_spaces
(
)
{
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
pkt
=
client
.
process
(
pkt
now
)
.
dgram
(
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
_pkt
=
server
.
process
(
pkt
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
60
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
zero
"
)
.
unwrap
(
)
4
)
;
qdebug
!
(
"
-
-
-
-
client
:
1RTT
packet
"
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
50
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
50
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt3
.
is_some
(
)
)
;
let
pkt4
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt4
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
120
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
120
)
;
let
pkt5
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt5
.
is_some
(
)
)
;
let
assert_hs_and_app_pto
=
|
frames
:
&
[
(
Frame
PNSpace
)
]
|
{
assert
!
(
matches
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
Handshake
)
)
)
;
assert
!
(
matches
!
(
frames
[
1
]
(
Frame
:
:
Crypto
{
.
.
}
PNSpace
:
:
Handshake
)
)
)
;
assert
!
(
matches
!
(
frames
[
2
]
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
)
;
assert
!
(
matches
!
(
frames
[
3
]
(
Frame
:
:
Stream
{
.
.
}
PNSpace
:
:
ApplicationData
)
)
)
;
}
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
frames
=
server
.
test_process_input
(
pkt3
.
unwrap
(
)
now
)
;
assert_hs_and_app_pto
(
&
frames
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
frames
=
server
.
test_process_input
(
pkt5
.
unwrap
(
)
now
)
;
assert_hs_and_app_pto
(
&
frames
)
;
}
#
[
test
]
fn
verify_pkt_honors_mtu
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
&
[
0xbb
;
2000
]
)
.
unwrap
(
)
2000
)
;
let
pkt0
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
pkt0
Output
:
:
Datagram
(
_
)
)
)
;
assert_eq
!
(
pkt0
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
}
fn
fill_cwnd
(
src
:
&
mut
Connection
stream
:
u64
mut
now
:
Instant
)
-
>
(
Vec
<
Datagram
>
Instant
)
{
const
BLOCK_SIZE
:
usize
=
4_096
;
let
mut
total_dgrams
=
Vec
:
:
new
(
)
;
qtrace
!
(
"
fill_cwnd
starting
cwnd
:
{
}
"
src
.
loss_recovery
.
cwnd_avail
(
)
)
;
loop
{
let
bytes_sent
=
src
.
stream_send
(
stream
&
[
0x42
;
BLOCK_SIZE
]
)
.
unwrap
(
)
;
qtrace
!
(
"
fill_cwnd
wrote
{
}
bytes
"
bytes_sent
)
;
if
bytes_sent
<
BLOCK_SIZE
{
break
;
}
}
loop
{
let
pkt
=
src
.
process_output
(
now
)
;
qtrace
!
(
"
fill_cwnd
cwnd
remaining
=
{
}
output
:
{
:
?
}
"
src
.
loss_recovery
.
cwnd_avail
(
)
pkt
)
;
match
pkt
{
Output
:
:
Datagram
(
dgram
)
=
>
{
total_dgrams
.
push
(
dgram
)
;
}
Output
:
:
Callback
(
t
)
=
>
{
if
src
.
loss_recovery
.
cwnd_avail
(
)
<
ACK_ONLY_SIZE_LIMIT
{
break
;
}
now
+
=
t
;
}
_
=
>
panic
!
(
)
}
}
(
total_dgrams
now
)
}
fn
ack_bytes
(
dest
:
&
mut
Connection
stream
:
u64
in_dgrams
:
Vec
<
Datagram
>
now
:
Instant
)
-
>
(
Vec
<
Datagram
>
Vec
<
Frame
>
)
{
let
mut
srv_buf
=
[
0
;
4_096
]
;
let
mut
recvd_frames
=
Vec
:
:
new
(
)
;
for
dgram
in
in_dgrams
{
recvd_frames
.
extend
(
dest
.
test_process_input
(
dgram
now
)
)
;
}
loop
{
let
(
bytes_read
_fin
)
=
dest
.
stream_recv
(
stream
&
mut
srv_buf
)
.
unwrap
(
)
;
if
bytes_read
=
=
0
{
break
;
}
}
let
mut
tx_dgrams
=
Vec
:
:
new
(
)
;
while
let
Output
:
:
Datagram
(
dg
)
=
dest
.
process_output
(
now
)
{
tx_dgrams
.
push
(
dg
)
;
}
assert
!
(
(
tx_dgrams
.
len
(
)
=
=
1
)
|
|
(
tx_dgrams
.
len
(
)
=
=
2
)
)
;
(
tx_dgrams
recvd_frames
.
into_iter
(
)
.
map
(
|
(
f
_e
)
|
f
)
.
collect
(
)
)
}
const
POST_HANDSHAKE_CWND
:
usize
=
PATH_MTU_V6
*
(
INITIAL_CWND_PKTS
+
1
)
+
75
;
const
fn
cwnd_packets
(
data
:
usize
)
-
>
usize
{
(
data
+
ACK_ONLY_SIZE_LIMIT
-
1
)
/
PATH_MTU_V6
}
fn
last_packet
(
cwnd
:
usize
)
-
>
usize
{
if
(
cwnd
%
PATH_MTU_V6
)
>
ACK_ONLY_SIZE_LIMIT
{
cwnd
%
PATH_MTU_V6
}
else
{
PATH_MTU_V6
}
}
fn
assert_full_cwnd
(
packets
:
&
[
Datagram
]
cwnd
:
usize
)
{
assert_eq
!
(
packets
.
len
(
)
cwnd_packets
(
cwnd
)
)
;
let
(
last
rest
)
=
packets
.
split_last
(
)
.
unwrap
(
)
;
assert
!
(
rest
.
iter
(
)
.
all
(
|
d
|
d
.
len
(
)
=
=
PATH_MTU_V6
)
)
;
assert_eq
!
(
last
.
len
(
)
last_packet
(
cwnd
)
)
;
}
#
[
test
]
fn
cc_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
set_local_tparam
(
tparams
:
:
INITIAL_MAX_DATA
TransportParameter
:
:
Integer
(
65536
)
)
.
unwrap
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
2
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
assert
!
(
client
.
loss_recovery
.
cwnd_avail
(
)
<
ACK_ONLY_SIZE_LIMIT
)
;
}
#
[
test
]
fn
cc_slow_start_to_cong_avoidance_recovery_period
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
let
flight1_largest
=
PacketNumber
:
:
try_from
(
c_tx_dgrams
.
len
(
)
)
.
unwrap
(
)
;
let
(
s_tx_dgram
_recvd_frames
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
let
recvd_frames
=
client
.
test_process_input
(
dgram
now
)
;
if
let
(
Frame
:
:
Ack
{
largest_acknowledged
.
.
}
PNSpace
:
:
ApplicationData
)
=
recvd_frames
[
0
]
{
assert_eq
!
(
largest_acknowledged
flight1_largest
)
;
}
else
{
panic
!
(
"
Expected
an
application
ACK
"
)
;
}
}
let
(
mut
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
*
2
)
;
let
flight2_largest
=
flight1_largest
+
u64
:
:
try_from
(
c_tx_dgrams
.
len
(
)
)
.
unwrap
(
)
;
c_tx_dgrams
.
remove
(
0
)
;
let
(
s_tx_dgram
_recvd_frames
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
let
recvd_frames
=
client
.
test_process_input
(
dgram
now
)
;
if
let
(
Frame
:
:
Ack
{
largest_acknowledged
.
.
}
PNSpace
:
:
ApplicationData
)
=
recvd_frames
[
0
]
{
assert_eq
!
(
largest_acknowledged
flight2_largest
)
;
}
else
{
panic
!
(
"
Expected
an
application
ACK
"
)
;
}
}
assert_eq
!
(
client
.
loss_recovery
.
cwnd
(
)
client
.
loss_recovery
.
ssthresh
(
)
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_unchanged
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
mut
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
c_tx_dgrams
.
remove
(
0
)
;
let
c_tx_dgrams2
=
c_tx_dgrams
.
split_off
(
5
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
let
cwnd1
=
client
.
loss_recovery
.
cwnd
(
)
;
assert_eq
!
(
cwnd1
client
.
loss_recovery
.
ssthresh
(
)
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams2
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
let
cwnd2
=
client
.
loss_recovery
.
cwnd
(
)
;
assert_eq
!
(
cwnd1
cwnd2
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_to_cong_avoidance
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
c_tx_dgrams
.
remove
(
0
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
let
cwnd1
=
client
.
loss_recovery
.
cwnd
(
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
(
mut
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
now
=
next_now
;
c_tx_dgrams
.
truncate
(
2
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
let
cwnd2
=
client
.
loss_recovery
.
cwnd
(
)
;
assert
!
(
cwnd2
>
cwnd1
)
;
assert
!
(
cwnd2
<
cwnd1
+
500
)
;
}
fn
induce_persistent_congestion
(
client
:
&
mut
Connection
server
:
&
mut
Connection
mut
now
:
Instant
)
-
>
Instant
{
now
+
=
AT_LEAST_PTO
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
0
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
now
+
=
Duration
:
:
from_secs
(
2
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
0
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
now
+
=
Duration
:
:
from_secs
(
4
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
0
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
assert_eq
!
(
client
.
loss_recovery
.
cwnd
(
)
MIN_CONG_WINDOW
)
;
now
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_no_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
let
(
_s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
now
)
;
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_some_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
let
(
_c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
now
)
;
}
#
[
test
]
fn
cc_persistent_congestion_to_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
(
_s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
now
=
induce_persistent_congestion
(
&
mut
client
&
mut
server
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
let
(
s_tx_dgram
_
)
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
test_process_input
(
dgram
now
)
;
}
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
4
)
;
}
fn
check_discarded
(
peer
:
&
mut
Connection
pkt
:
Datagram
dropped
:
usize
dups
:
usize
)
{
let
_
=
peer
.
process_output
(
now
(
)
)
;
let
dropped_before
=
peer
.
stats
.
dropped_rx
;
let
dups_before
=
peer
.
stats
.
dups_rx
;
let
out
=
peer
.
process
(
Some
(
pkt
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert_eq
!
(
dropped
peer
.
stats
.
dropped_rx
-
dropped_before
)
;
assert_eq
!
(
dups
peer
.
stats
.
dups_rx
-
dups_before
)
;
}
#
[
test
]
fn
discarded_initial_keys
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
init_pkt_c
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
init_pkt_c
.
is_some
(
)
)
;
assert_eq
!
(
init_pkt_c
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
init_pkt_s
=
server
.
process
(
init_pkt_c
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
init_pkt_s
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
init_pkt_s
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
check_discarded
(
&
mut
client
init_pkt_s
.
unwrap
(
)
1
1
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
check_discarded
(
&
mut
server
init_pkt_c
.
clone
(
)
.
unwrap
(
)
1
1
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
check_discarded
(
&
mut
server
init_pkt_c
.
unwrap
(
)
1
0
)
;
}
#
[
must_use
]
fn
send_something
(
sender
:
&
mut
Connection
now
:
Instant
)
-
>
Datagram
{
let
stream_id
=
sender
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
sender
.
stream_send
(
stream_id
DEFAULT_STREAM_DATA
)
.
is_ok
(
)
)
;
assert
!
(
sender
.
stream_close_send
(
stream_id
)
.
is_ok
(
)
)
;
let
dgram
=
sender
.
process
(
None
now
)
.
dgram
(
)
;
dgram
.
expect
(
"
should
have
something
to
send
"
)
}
fn
send_and_receive
(
sender
:
&
mut
Connection
receiver
:
&
mut
Connection
now
:
Instant
)
-
>
Option
<
Datagram
>
{
let
dgram
=
send_something
(
sender
now
)
;
receiver
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
}
#
[
test
]
fn
key_update_client
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert_eq
!
(
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
client
.
process
(
None
now
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
assert
!
(
send_and_receive
(
&
mut
client
&
mut
server
now
)
.
is_none
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
res
=
server
.
process
(
None
now
)
;
if
let
Output
:
:
Callback
(
t
)
=
res
{
assert
!
(
t
<
LOCAL_IDLE_TIMEOUT
)
;
}
else
{
panic
!
(
"
server
should
now
be
waiting
to
clear
keys
"
)
;
}
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
_
=
server
.
process
(
None
now
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
send_and_receive
(
&
mut
client
&
mut
server
now
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
res
=
client
.
process
(
dgram
now
)
;
if
let
Output
:
:
Callback
(
t
)
=
res
{
assert
!
(
t
<
LOCAL_IDLE_TIMEOUT
)
;
}
else
{
panic
!
(
"
client
should
now
be
waiting
to
clear
keys
"
)
;
}
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
_
=
client
.
process
(
None
now
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
}
#
[
test
]
fn
key_update_consecutive
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
_
=
send_something
(
&
mut
server
now
)
;
let
dgram
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
if
let
Output
:
:
Callback
(
_
)
=
server
.
process
(
dgram
now
)
{
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
_
=
server
.
process
(
None
now
+
AT_LEAST_PTO
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
}
else
{
panic
!
(
"
server
should
have
a
timer
set
"
)
;
}
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
5
)
Some
(
4
)
)
)
;
let
dgram
=
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
;
check_discarded
(
&
mut
client
dgram
1
0
)
;
}
#
[
test
]
fn
key_update_before_confirmed
(
)
{
let
mut
client
=
default_client
(
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
mut
server
=
default_server
(
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
ack_are_not_cc
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
0
now
(
)
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
qdebug
!
(
[
server
]
"
Sending
ack
-
eliciting
"
)
;
assert_eq
!
(
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
1
)
;
server
.
stream_send
(
1
b
"
dropped
"
)
.
unwrap
(
)
;
let
dropped_packet
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dropped_packet
.
is_some
(
)
)
;
server
.
stream_send
(
1
b
"
sent
"
)
.
unwrap
(
)
;
let
ack_eliciting_packet
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
ack_eliciting_packet
.
is_some
(
)
)
;
qdebug
!
(
[
client
]
"
Process
ack
-
eliciting
"
)
;
let
ack_pkt
=
client
.
process
(
ack_eliciting_packet
now
)
.
dgram
(
)
;
assert
!
(
ack_pkt
.
is_some
(
)
)
;
qdebug
!
(
[
server
]
"
Handle
ACK
"
)
;
let
frames
=
server
.
test_process_input
(
ack_pkt
.
unwrap
(
)
now
)
;
assert_eq
!
(
frames
.
len
(
)
1
)
;
assert
!
(
matches
!
(
frames
[
0
]
(
Frame
:
:
Ack
{
.
.
}
PNSpace
:
:
ApplicationData
)
)
)
;
}
#
[
test
]
fn
after_fin_is_read_conn_events_for_stream_should_be_removed
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
id
=
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
server
.
stream_send
(
id
&
[
6
;
10
]
)
.
unwrap
(
)
;
server
.
stream_close_send
(
id
)
.
unwrap
(
)
;
let
out
=
server
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
_
=
client
.
process
(
out
now
(
)
)
;
let
mut
buf
=
vec
!
[
0
;
4000
]
;
let
(
_
fin
)
=
client
.
stream_recv
(
id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
let
readable_stream_evt
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
if
stream_id
=
=
id
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
readable_stream_evt
)
)
;
}
#
[
test
]
fn
after_stream_stop_sending_is_called_conn_events_for_stream_should_be_removed
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
id
=
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
server
.
stream_send
(
id
&
[
6
;
10
]
)
.
unwrap
(
)
;
server
.
stream_close_send
(
id
)
.
unwrap
(
)
;
let
out
=
server
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
_
=
client
.
process
(
out
now
(
)
)
;
client
.
stream_stop_sending
(
id
Error
:
:
NoError
.
code
(
)
)
.
unwrap
(
)
;
let
readable_stream_evt
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
if
stream_id
=
=
id
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
readable_stream_evt
)
)
;
}
#
[
test
]
fn
early_application_close
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
server
.
close
(
now
(
)
77
String
:
:
from
(
"
"
)
)
;
assert
!
(
server
.
state
(
)
.
closed
(
)
)
;
let
dgram
=
server
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
frames
=
client
.
test_process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert
!
(
matches
!
(
frames
[
0
]
(
Frame
:
:
ConnectionClose
{
error_code
:
CloseError
:
:
Transport
(
code
)
.
.
}
PNSpace
:
:
Initial
)
if
code
=
=
Error
:
:
ApplicationError
.
code
(
)
)
)
;
assert
!
(
client
.
state
(
)
.
closed
(
)
)
;
}
#
[
test
]
fn
bad_tls_version
(
)
{
let
mut
client
=
default_client
(
)
;
client
.
crypto
.
tls
.
set_option
(
neqo_crypto
:
:
Opt
:
:
Tls13CompatMode
true
)
.
unwrap
(
)
;
let
mut
server
=
default_server
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
ProtocolViolation
)
)
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
frames
=
client
.
test_process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert
!
(
matches
!
(
frames
[
0
]
(
Frame
:
:
ConnectionClose
{
error_code
:
CloseError
:
:
Transport
(
_
)
.
.
}
PNSpace
:
:
Initial
)
)
)
;
}
#
[
test
]
fn
pace
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
1000
)
;
const
DATA
:
&
[
u8
]
=
&
[
0xcc
;
4_096
]
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
loop
{
let
written
=
client
.
stream_send
(
stream
DATA
)
.
unwrap
(
)
;
if
written
<
DATA
.
len
(
)
{
break
;
}
}
let
mut
count
=
0
;
for
_
in
0
.
.
PACING_BURST_SIZE
{
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
gap
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
gap
Duration
:
:
new
(
0
0
)
)
;
for
_
in
PACING_BURST_SIZE
.
.
cwnd_packets
(
POST_HANDSHAKE_CWND
)
{
assert_eq
!
(
client
.
process_output
(
now
)
.
callback
(
)
gap
)
;
now
+
=
gap
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
assert_eq
!
(
count
cwnd_packets
(
POST_HANDSHAKE_CWND
)
)
;
let
fin
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
fin
Duration
:
:
new
(
0
0
)
)
;
assert_ne
!
(
fin
gap
)
;
}
#
[
test
]
fn
loss_recovery_crash
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
_
=
send_something
(
&
mut
server
now
)
;
let
ack
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
cb
=
server
.
process
(
ack
now
)
.
callback
(
)
;
assert
!
(
cb
>
Duration
:
:
from_secs
(
0
)
)
;
let
dgram
=
server
.
process
(
None
now
+
AT_LEAST_PTO
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
_
=
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
;
}
#
[
test
]
fn
ack_after_pto
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
_
=
send_something
(
&
mut
client
now
)
;
now
+
=
AT_LEAST_PTO
;
for
_
in
0
.
.
PTO_PACKET_COUNT
{
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
assert
!
(
client
.
process
(
None
now
)
.
dgram
(
)
.
is_none
(
)
)
;
let
_
=
send_something
(
&
mut
server
now
)
;
let
dgram
=
send_something
(
&
mut
server
now
)
;
let
ack
=
client
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
frames
=
server
.
test_process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
frames
.
len
(
)
1
)
;
for
(
frame
space
)
in
frames
{
assert_eq
!
(
space
PNSpace
:
:
ApplicationData
)
;
assert
!
(
matches
!
(
frame
Frame
:
:
Ack
{
.
.
}
)
)
;
}
}
#
[
test
]
fn
closing_timers_interation
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
_p1
=
send_something
(
&
mut
client
now
)
;
let
p2
=
send_something
(
&
mut
client
now
)
;
let
ack
=
server
.
process
(
Some
(
p2
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
ack
now
)
.
callback
(
)
;
assert_ne
!
(
cb
Duration
:
:
from_secs
(
0
)
)
;
now
+
=
cb
;
client
.
close
(
now
0
"
"
)
;
let
client_close
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
client_close
.
is_some
(
)
)
;
let
client_close_timer
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
client_close_timer
Duration
:
:
from_secs
(
0
)
)
;
}
#
[
test
]
fn
closing_and_draining
(
)
{
const
APP_ERROR
:
AppError
=
7
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
p1
=
send_something
(
&
mut
client
now
(
)
)
;
client
.
close
(
now
(
)
APP_ERROR
"
"
)
;
let
client_close
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_close
.
is_some
(
)
)
;
let
client_close_timer
=
client
.
process
(
None
now
(
)
)
.
callback
(
)
;
assert_ne
!
(
client_close_timer
Duration
:
:
from_secs
(
0
)
)
;
let
p3
=
send_something
(
&
mut
server
now
(
)
)
;
let
client_close2
=
client
.
process
(
Some
(
p3
)
now
(
)
)
.
dgram
(
)
;
assert_eq
!
(
client_close
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
client_close2
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
)
;
let
end
=
client
.
process
(
None
now
(
)
+
client_close_timer
)
;
assert_eq
!
(
end
Output
:
:
None
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Closed
(
ConnectionError
:
:
Application
(
APP_ERROR
)
)
)
;
let
server_close
=
server
.
process
(
client_close
now
(
)
)
.
dgram
(
)
;
assert
!
(
server
.
state
(
)
.
closed
(
)
)
;
assert
!
(
server_close
.
is_some
(
)
)
;
let
server_close_timer
=
server
.
process
(
client_close2
now
(
)
)
.
callback
(
)
;
assert_ne
!
(
server_close_timer
Duration
:
:
from_secs
(
0
)
)
;
let
server_close_timer2
=
server
.
process
(
Some
(
p1
)
now
(
)
)
.
callback
(
)
;
assert_eq
!
(
server_close_timer
server_close_timer2
)
;
let
end
=
server
.
process
(
None
now
(
)
+
server_close_timer
)
;
assert_eq
!
(
end
Output
:
:
None
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
PeerApplicationError
(
APP_ERROR
)
)
)
)
;
}
#
[
test
]
fn
lost_but_kept_and_lr_timer
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
let
_p1
=
send_something
(
&
mut
client
now
)
;
let
p2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
ack
=
server
.
process
(
Some
(
p2
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
_p3
=
send_something
(
&
mut
client
now
)
;
let
p4
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer
=
res
.
callback
(
)
;
assert_ne
!
(
lr_timer
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_timer
<
(
RTT
/
2
)
)
;
let
ack
=
server
.
process
(
Some
(
p4
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
None
now
)
;
assert
!
(
res
.
dgram
(
)
.
is_some
(
)
)
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer2
=
res
.
callback
(
)
;
assert_eq
!
(
lr_timer
lr_timer2
)
;
}
fn
split_packet
(
buf
:
&
[
u8
]
)
-
>
(
&
[
u8
]
Option
<
&
[
u8
]
>
)
{
if
buf
[
0
]
&
0x80
=
=
0
{
return
(
buf
None
)
;
}
let
mut
dec
=
Decoder
:
:
from
(
buf
)
;
let
first
=
dec
.
decode_byte
(
)
.
unwrap
(
)
;
dec
.
skip
(
4
)
;
dec
.
skip_vec
(
1
)
;
dec
.
skip_vec
(
1
)
;
if
first
&
0x30
=
=
0
{
dec
.
skip_vvec
(
)
;
}
dec
.
skip_vvec
(
)
;
let
p1
=
&
buf
[
.
.
dec
.
offset
(
)
]
;
let
p2
=
if
dec
.
remaining
(
)
>
0
{
Some
(
dec
.
decode_remainder
(
)
)
}
else
{
None
}
;
(
p1
p2
)
}
fn
split_datagram
(
d
:
Datagram
)
-
>
(
Datagram
Option
<
Datagram
>
)
{
let
(
a
b
)
=
split_packet
(
&
d
[
.
.
]
)
;
(
Datagram
:
:
new
(
d
.
source
(
)
d
.
destination
(
)
a
)
b
.
map
(
|
b
|
Datagram
:
:
new
(
d
.
source
(
)
d
.
destination
(
)
b
)
)
)
}
#
[
test
]
fn
loss_time_past_largest_acked
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
10
)
;
const
INCR
:
Duration
=
Duration
:
:
from_millis
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_in
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s_hs1
=
server
.
process
(
c_in
now
)
.
dgram
(
)
;
let
s_pto
=
server
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
s_pto
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
s_pto
<
RTT
)
;
let
s_hs2
=
server
.
process
(
None
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs2
.
is_some
(
)
)
;
let
s_hs3
=
server
.
process
(
None
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
c_hs1
=
client
.
process
(
s_hs1
now
)
.
dgram
(
)
;
assert
!
(
c_hs1
.
is_some
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c_hs2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c_hs2
.
is_some
(
)
)
;
let
_p1
=
send_something
(
&
mut
client
now
+
INCR
)
;
let
c_hs3
=
client
.
process
(
s_hs2
now
+
(
INCR
*
2
)
)
.
dgram
(
)
;
assert
!
(
c_hs3
.
is_some
(
)
)
;
let
c_hs4
=
client
.
process
(
s_hs3
now
+
(
INCR
*
3
)
)
.
dgram
(
)
;
assert
!
(
c_hs4
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s_ack1
=
server
.
process
(
c_hs4
now
)
.
dgram
(
)
;
assert
!
(
s_ack1
.
is_none
(
)
)
;
let
s_ack2
=
server
.
process
(
c_hs2
now
)
.
dgram
(
)
;
assert
!
(
s_ack2
.
is_some
(
)
)
;
let
(
s_hs_ack
_s_ap_ack
)
=
split_datagram
(
s_ack2
.
unwrap
(
)
)
;
now
+
=
RTT
/
2
;
let
c_ack
=
client
.
process
(
Some
(
s_hs_ack
)
now
)
.
dgram
(
)
;
assert
!
(
c_ack
.
is_none
(
)
)
;
let
lr_time
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
lr_time
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_time
<
(
RTT
/
2
)
)
;
now
+
=
lr_time
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
delay
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
delay
>
lr_time
)
;
}
#
[
test
]
fn
unknown_version
(
)
{
let
mut
client
=
default_client
(
)
;
let
_
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
mut
unknown_version_packet
=
vec
!
[
0x80
0x1a
0x1a
0x1a
0x1a
]
;
unknown_version_packet
.
resize
(
1200
0x0
)
;
let
_
=
client
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
unknown_version_packet
)
)
now
(
)
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
}
#
[
test
]
fn
chacha20poly1305
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
Connection
:
:
new_client
(
test_fixture
:
:
DEFAULT_SERVER_NAME
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
0
)
)
)
loopback
(
)
loopback
(
)
QuicVersion
:
:
default
(
)
)
.
expect
(
"
create
a
default
client
"
)
;
client
.
set_ciphers
(
&
[
TLS_CHACHA20_POLY1305_SHA256
]
)
.
unwrap
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
}
#
[
test
]
fn
stateless_reset_client
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
set_local_tparam
(
tparams
:
:
STATELESS_RESET_TOKEN
TransportParameter
:
:
Bytes
(
vec
!
[
77
;
16
]
)
)
.
unwrap
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
client
.
process_input
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
vec
!
[
77
;
21
]
)
now
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Draining
{
.
.
}
)
)
;
}
#
[
test
]
fn
send_05rtt
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
c1
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
let
s1
=
server
.
process
(
c1
now
(
)
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
s2
=
send_something
(
&
mut
server
now
(
)
)
;
let
_
=
client
.
process
(
s1
now
(
)
)
.
dgram
(
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
client
.
process_input
(
s2
now
(
)
)
;
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
stream_id
=
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
unwrap
(
)
;
let
(
l
ended
)
=
client
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
[
.
.
l
]
DEFAULT_STREAM_DATA
)
;
assert
!
(
ended
)
;
}
#
[
test
]
fn
coalesce_05rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
stream_id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
server
.
stream_send
(
stream_id
DEFAULT_STREAM_DATA
)
.
is_ok
(
)
)
;
assert
!
(
server
.
stream_close_send
(
stream_id
)
.
is_ok
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
c2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert
!
(
s2
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
assert_eq
!
(
client
.
stats
.
dropped_rx
0
)
;
let
_
=
client
.
process
(
s2
now
)
.
dgram
(
)
;
assert_eq
!
(
client
.
stats
.
dropped_rx
0
)
;
assert
!
(
client
.
saved_datagram
.
is_some
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
.
dropped_rx
0
)
;
assert
!
(
client
.
saved_datagram
.
is_none
(
)
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
;
assert
!
(
s3
.
is_some
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
now
+
=
RTT
/
2
;
let
c5
=
client
.
process
(
s3
now
)
.
dgram
(
)
;
assert
!
(
c5
.
is_none
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
}
#
[
test
]
fn
server_receive_unknown_first_packet
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
unknown_version_packet
=
vec
!
[
0x80
0x1a
0x1a
0x1a
0x1a
]
;
unknown_version_packet
.
resize
(
1200
0x0
)
;
assert_eq
!
(
server
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
unknown_version_packet
)
)
now
(
)
)
Output
:
:
None
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
)
;
}
fn
create_vn
(
initial_pkt
:
&
[
u8
]
versions
:
&
[
u32
]
)
-
>
Vec
<
u8
>
{
let
mut
dec
=
Decoder
:
:
from
(
&
initial_pkt
[
5
.
.
]
)
;
let
dcid
=
dec
.
decode_vec
(
1
)
.
expect
(
"
client
DCID
"
)
;
let
scid
=
dec
.
decode_vec
(
1
)
.
expect
(
"
client
SCID
"
)
;
let
mut
encoder
=
Encoder
:
:
default
(
)
;
encoder
.
encode_byte
(
PACKET_BIT_LONG
)
;
encoder
.
encode
(
&
[
0
;
4
]
)
;
encoder
.
encode_vec
(
1
dcid
)
;
encoder
.
encode_vec
(
1
scid
)
;
for
v
in
versions
{
encoder
.
encode_uint
(
4
*
v
)
;
}
encoder
.
into
(
)
}
#
[
test
]
fn
version_negotiation_current_version
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1_a1a1a
QuicVersion
:
:
default
(
)
.
as_u32
(
)
]
)
;
assert_eq
!
(
client
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
vn
)
)
now
(
)
)
Output
:
:
Callback
(
Duration
:
:
from_millis
(
120
)
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
}
#
[
test
]
fn
version_negotiation_only_reserved
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
]
)
;
assert_eq
!
(
client
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
vn
)
)
now
(
)
)
Output
:
:
None
)
;
match
client
.
state
(
)
{
State
:
:
Closed
(
err
)
=
>
{
assert_eq
!
(
*
err
ConnectionError
:
:
Transport
(
Error
:
:
VersionNegotiation
)
)
}
_
=
>
panic
!
(
"
Invalid
client
state
"
)
}
}
#
[
test
]
fn
version_negotiation_corrupted
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
]
)
;
assert_eq
!
(
client
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
&
vn
[
.
.
vn
.
len
(
)
-
1
]
)
)
now
(
)
)
Output
:
:
Callback
(
Duration
:
:
from_millis
(
120
)
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
}
#
[
test
]
fn
version_negotiation_empty
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
]
)
;
assert_eq
!
(
client
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
vn
)
)
now
(
)
)
Output
:
:
Callback
(
Duration
:
:
from_millis
(
120
)
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
}
#
[
test
]
fn
version_negotiation_not_supported
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
0xff00_0001
]
)
;
assert_eq
!
(
client
.
process
(
Some
(
Datagram
:
:
new
(
loopback
(
)
loopback
(
)
vn
)
)
now
(
)
)
Output
:
:
None
)
;
match
client
.
state
(
)
{
State
:
:
Closed
(
err
)
=
>
{
assert_eq
!
(
*
err
ConnectionError
:
:
Transport
(
Error
:
:
VersionNegotiation
)
)
}
_
=
>
panic
!
(
"
Invalid
client
state
"
)
}
}
#
[
test
]
fn
stream_data_blocked_generates_max_stream_data
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
server
.
flow_mgr
.
borrow_mut
(
)
.
stream_data_blocked
(
3
.
into
(
)
RX_STREAM_DATA_WINDOW
*
4
)
;
let
out
=
server
.
process
(
None
now
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
frames
=
client
.
test_process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
matches
!
(
f
Frame
:
:
StreamDataBlocked
{
.
.
}
)
)
)
;
let
out
=
client
.
process_output
(
now
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
frames
=
server
.
test_process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
matches
!
(
f
Frame
:
:
MaxStreamData
{
maximum_stream_data
.
.
}
if
*
maximum_stream_data
=
=
RX_STREAM_DATA_WINDOW
)
)
)
;
}
}
