pub
mod
sent
;
mod
token
;
use
std
:
:
{
cmp
:
:
{
max
min
}
fmt
:
:
{
self
Display
Formatter
}
ops
:
:
RangeInclusive
time
:
:
{
Duration
Instant
}
}
;
use
enum_map
:
:
EnumMap
;
use
enumset
:
:
enum_set
;
use
neqo_common
:
:
{
qdebug
qinfo
qlog
:
:
Qlog
qtrace
qwarn
}
;
use
strum
:
:
IntoEnumIterator
as
_
;
pub
use
token
:
:
{
StreamRecoveryToken
Token
Tokens
}
;
use
crate
:
:
{
ecn
packet
path
:
:
{
Path
PathRef
}
qlog
rtt
:
:
{
RttEstimate
RttSource
}
stats
:
:
{
Stats
StatsCell
}
tracking
:
:
{
PacketNumberSpace
PacketNumberSpaceSet
}
}
;
pub
const
PACKET_THRESHOLD
:
u64
=
3
;
pub
const
ACK_ONLY_SIZE_LIMIT
:
usize
=
256
;
pub
const
MAX_PTO_PACKET_COUNT
:
usize
=
2
;
pub
const
MAX_OUTSTANDING_UNACK
:
usize
=
200
;
pub
const
MIN_OUTSTANDING_UNACK
:
usize
=
16
;
pub
const
FAST_PTO_SCALE
:
u8
=
100
;
#
[
derive
(
Debug
)
]
pub
struct
SendProfile
{
limit
:
usize
pto
:
Option
<
PacketNumberSpace
>
probe
:
PacketNumberSpaceSet
paced
:
bool
}
impl
SendProfile
{
#
[
must_use
]
pub
fn
new_limited
(
limit
:
usize
)
-
>
Self
{
Self
{
limit
:
max
(
ACK_ONLY_SIZE_LIMIT
-
1
limit
)
pto
:
None
probe
:
PacketNumberSpaceSet
:
:
empty
(
)
paced
:
false
}
}
#
[
must_use
]
pub
fn
new_paced
(
)
-
>
Self
{
Self
{
limit
:
ACK_ONLY_SIZE_LIMIT
-
1
pto
:
None
probe
:
PacketNumberSpaceSet
:
:
empty
(
)
paced
:
true
}
}
#
[
must_use
]
pub
fn
new_pto
(
pn_space
:
PacketNumberSpace
mtu
:
usize
probe
:
PacketNumberSpaceSet
)
-
>
Self
{
debug_assert
!
(
mtu
>
ACK_ONLY_SIZE_LIMIT
)
;
Self
{
limit
:
mtu
pto
:
Some
(
pn_space
)
probe
paced
:
false
}
}
#
[
must_use
]
pub
fn
should_probe
(
&
self
space
:
PacketNumberSpace
)
-
>
bool
{
self
.
probe
.
contains
(
space
)
}
#
[
must_use
]
pub
fn
ack_only
(
&
self
space
:
PacketNumberSpace
)
-
>
bool
{
self
.
limit
<
ACK_ONLY_SIZE_LIMIT
|
|
self
.
pto
.
is_some_and
(
|
sp
|
space
<
sp
)
}
#
[
must_use
]
pub
const
fn
paced
(
&
self
)
-
>
bool
{
self
.
paced
}
#
[
must_use
]
pub
const
fn
limit
(
&
self
)
-
>
usize
{
self
.
limit
}
}
#
[
derive
(
Debug
)
]
pub
struct
LossRecoverySpace
{
space
:
PacketNumberSpace
largest_acked
:
Option
<
packet
:
:
Number
>
largest_acked_sent_time
:
Option
<
Instant
>
last_ack_eliciting
:
Option
<
Instant
>
in_flight_outstanding
:
usize
sent_packets
:
sent
:
:
Packets
first_ooo_time
:
Option
<
Instant
>
}
impl
LossRecoverySpace
{
#
[
must_use
]
pub
fn
new
(
space
:
PacketNumberSpace
)
-
>
Self
{
Self
{
space
largest_acked
:
None
largest_acked_sent_time
:
None
last_ack_eliciting
:
None
in_flight_outstanding
:
0
sent_packets
:
sent
:
:
Packets
:
:
default
(
)
first_ooo_time
:
None
}
}
#
[
must_use
]
pub
const
fn
loss_recovery_timer_start
(
&
self
)
-
>
Option
<
Instant
>
{
self
.
first_ooo_time
}
#
[
must_use
]
pub
const
fn
in_flight_outstanding
(
&
self
)
-
>
bool
{
self
.
in_flight_outstanding
>
0
}
pub
fn
pto_packets
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
sent
:
:
Packet
>
{
self
.
sent_packets
.
iter_mut
(
)
.
filter_map
(
|
sent
|
{
sent
.
pto
(
)
.
then
(
|
|
{
qtrace
!
(
"
PTO
:
marking
packet
{
}
lost
"
sent
.
pn
(
)
)
;
&
*
sent
}
)
}
)
}
#
[
must_use
]
pub
fn
pto_base_time
(
&
self
)
-
>
Option
<
Instant
>
{
if
self
.
in_flight_outstanding
(
)
{
debug_assert
!
(
self
.
last_ack_eliciting
.
is_some
(
)
)
;
self
.
last_ack_eliciting
}
else
if
self
.
space
=
=
PacketNumberSpace
:
:
ApplicationData
{
None
}
else
{
self
.
last_ack_eliciting
}
}
pub
fn
on_packet_sent
(
&
mut
self
sent_packet
:
sent
:
:
Packet
)
{
if
sent_packet
.
ack_eliciting
(
)
{
self
.
last_ack_eliciting
=
Some
(
sent_packet
.
time_sent
(
)
)
;
self
.
in_flight_outstanding
+
=
1
;
}
else
if
self
.
space
!
=
PacketNumberSpace
:
:
ApplicationData
&
&
self
.
last_ack_eliciting
.
is_none
(
)
{
self
.
last_ack_eliciting
=
Some
(
sent_packet
.
time_sent
(
)
)
;
}
self
.
sent_packets
.
track
(
sent_packet
)
;
}
#
[
must_use
]
pub
fn
should_probe
(
&
self
pto
:
Duration
now
:
Instant
)
-
>
bool
{
let
n_pto
=
if
self
.
sent_packets
.
len
(
)
>
=
MAX_OUTSTANDING_UNACK
{
1
}
else
if
self
.
sent_packets
.
len
(
)
>
=
MIN_OUTSTANDING_UNACK
{
2
}
else
{
return
false
;
}
;
self
.
last_ack_eliciting
.
is_some_and
(
|
t
|
now
>
t
+
(
pto
*
n_pto
)
)
}
fn
remove_outstanding
(
&
mut
self
count
:
usize
)
{
debug_assert
!
(
self
.
in_flight_outstanding
>
=
count
)
;
self
.
in_flight_outstanding
-
=
count
;
if
self
.
in_flight_outstanding
=
=
0
{
qtrace
!
(
"
remove_packet
outstanding
=
=
0
for
space
{
}
"
self
.
space
)
;
}
}
fn
remove_packet
(
&
mut
self
p
:
&
sent
:
:
Packet
)
{
if
p
.
ack_eliciting
(
)
{
self
.
remove_outstanding
(
1
)
;
}
}
fn
remove_acked
<
R
>
(
&
mut
self
acked_ranges
:
R
stats
:
&
mut
Stats
)
-
>
(
Vec
<
sent
:
:
Packet
>
bool
)
where
R
:
IntoIterator
<
Item
=
RangeInclusive
<
packet
:
:
Number
>
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
acked
=
self
.
sent_packets
.
take_ranges
(
acked_ranges
)
;
let
mut
eliciting
=
false
;
for
p
in
&
acked
{
self
.
remove_packet
(
p
)
;
eliciting
|
=
p
.
ack_eliciting
(
)
;
if
p
.
lost
(
)
{
stats
.
late_ack
+
=
1
;
}
if
p
.
pto_fired
(
)
{
stats
.
pto_ack
+
=
1
;
}
}
(
acked
eliciting
)
}
fn
remove_ignored
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
sent
:
:
Packet
>
{
self
.
in_flight_outstanding
=
0
;
std
:
:
mem
:
:
take
(
&
mut
self
.
sent_packets
)
.
drain_all
(
)
}
fn
migrate
(
&
mut
self
)
{
for
pkt
in
self
.
sent_packets
.
iter_mut
(
)
{
pkt
.
clear_primary_path
(
)
;
}
}
fn
remove_old_lost
(
&
mut
self
now
:
Instant
cd
:
Duration
)
{
let
removed
=
self
.
sent_packets
.
remove_expired
(
now
cd
)
;
self
.
remove_outstanding
(
removed
)
;
}
pub
fn
detect_lost_packets
(
&
mut
self
now
:
Instant
loss_delay
:
Duration
cleanup_delay
:
Duration
lost_packets
:
&
mut
Vec
<
sent
:
:
Packet
>
)
{
self
.
remove_old_lost
(
now
cleanup_delay
)
;
qtrace
!
(
"
detect
lost
{
}
:
now
=
{
now
:
?
}
delay
=
{
loss_delay
:
?
}
"
self
.
space
)
;
self
.
first_ooo_time
=
None
;
let
largest_acked
=
self
.
largest_acked
;
for
packet
in
self
.
sent_packets
.
iter_mut
(
)
.
take_while
(
|
p
|
largest_acked
.
is_some_and
(
|
largest_ack
|
p
.
pn
(
)
<
largest_ack
)
)
{
if
packet
.
time_sent
(
)
+
loss_delay
<
=
now
{
qtrace
!
(
"
lost
=
{
}
time
sent
{
:
?
}
is
before
lost_delay
{
loss_delay
:
?
}
"
packet
.
pn
(
)
packet
.
time_sent
(
)
)
;
}
else
if
largest_acked
>
=
Some
(
packet
.
pn
(
)
+
PACKET_THRESHOLD
)
{
qtrace
!
(
"
lost
=
{
}
is
>
=
{
PACKET_THRESHOLD
}
from
largest
acked
{
largest_acked
:
?
}
"
packet
.
pn
(
)
)
;
}
else
{
if
largest_acked
.
is_some
(
)
{
self
.
first_ooo_time
=
Some
(
packet
.
time_sent
(
)
)
;
}
break
;
}
if
packet
.
declare_lost
(
now
)
{
lost_packets
.
push
(
packet
.
clone
(
)
)
;
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
LossRecoverySpaces
{
spaces
:
EnumMap
<
PacketNumberSpace
Option
<
LossRecoverySpace
>
>
}
impl
LossRecoverySpaces
{
pub
fn
drop_space
(
&
mut
self
space
:
PacketNumberSpace
)
-
>
impl
IntoIterator
<
Item
=
sent
:
:
Packet
>
{
let
sp
=
self
.
spaces
[
space
]
.
take
(
)
;
assert_ne
!
(
space
PacketNumberSpace
:
:
ApplicationData
"
discarding
application
space
"
)
;
sp
.
expect
(
"
has
not
been
removed
"
)
.
remove_ignored
(
)
}
#
[
must_use
]
pub
fn
get
(
&
self
space
:
PacketNumberSpace
)
-
>
Option
<
&
LossRecoverySpace
>
{
self
.
spaces
[
space
]
.
as_ref
(
)
}
pub
fn
get_mut
(
&
mut
self
space
:
PacketNumberSpace
)
-
>
Option
<
&
mut
LossRecoverySpace
>
{
self
.
spaces
[
space
]
.
as_mut
(
)
}
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
LossRecoverySpace
>
{
self
.
spaces
.
iter
(
)
.
filter_map
(
|
(
_
recvd
)
|
recvd
.
as_ref
(
)
)
}
fn
iter_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
LossRecoverySpace
>
{
self
.
spaces
.
iter_mut
(
)
.
filter_map
(
|
(
_
recvd
)
|
recvd
.
as_mut
(
)
)
}
}
impl
Default
for
LossRecoverySpaces
{
fn
default
(
)
-
>
Self
{
Self
{
spaces
:
EnumMap
:
:
from_array
(
[
Some
(
LossRecoverySpace
:
:
new
(
PacketNumberSpace
:
:
Initial
)
)
Some
(
LossRecoverySpace
:
:
new
(
PacketNumberSpace
:
:
Handshake
)
)
Some
(
LossRecoverySpace
:
:
new
(
PacketNumberSpace
:
:
ApplicationData
)
)
]
)
}
}
}
#
[
derive
(
Debug
)
]
struct
PtoState
{
space
:
PacketNumberSpace
count
:
usize
packets
:
usize
probe
:
PacketNumberSpaceSet
}
impl
PtoState
{
pub
fn
new
(
space
:
PacketNumberSpace
probe
:
PacketNumberSpaceSet
)
-
>
Self
{
debug_assert
!
(
probe
.
contains
(
space
)
)
;
Self
{
space
count
:
1
packets
:
MAX_PTO_PACKET_COUNT
probe
}
}
pub
fn
pto
(
&
mut
self
space
:
PacketNumberSpace
probe
:
PacketNumberSpaceSet
)
{
debug_assert
!
(
probe
.
contains
(
space
)
)
;
self
.
space
=
min
(
space
self
.
space
)
;
self
.
count
+
=
1
;
self
.
packets
=
MAX_PTO_PACKET_COUNT
;
self
.
probe
|
=
probe
;
}
pub
const
fn
count
(
&
self
)
-
>
usize
{
self
.
count
}
pub
fn
count_pto
(
&
self
stats
:
&
mut
Stats
)
{
stats
.
add_pto_count
(
self
.
count
)
;
}
pub
fn
send_profile
(
&
mut
self
mtu
:
usize
)
-
>
Option
<
SendProfile
>
{
(
self
.
packets
>
0
)
.
then
(
|
|
{
self
.
packets
-
=
1
;
SendProfile
:
:
new_pto
(
self
.
space
mtu
self
.
probe
)
}
)
}
pub
fn
pto_sent
(
&
mut
self
space
:
PacketNumberSpace
)
{
if
self
.
packets
<
MAX_PTO_PACKET_COUNT
&
&
space
!
=
PacketNumberSpace
:
:
ApplicationData
{
self
.
probe
-
=
space
;
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Loss
{
confirmed_time
:
Option
<
Instant
>
pto_state
:
Option
<
PtoState
>
spaces
:
LossRecoverySpaces
qlog
:
Qlog
stats
:
StatsCell
fast_pto
:
u8
}
impl
Loss
{
#
[
must_use
]
pub
fn
new
(
stats
:
StatsCell
fast_pto
:
u8
)
-
>
Self
{
Self
{
confirmed_time
:
None
pto_state
:
None
spaces
:
LossRecoverySpaces
:
:
default
(
)
qlog
:
Qlog
:
:
default
(
)
stats
fast_pto
}
}
#
[
must_use
]
pub
fn
largest_acknowledged_pn
(
&
self
pn_space
:
PacketNumberSpace
)
-
>
Option
<
packet
:
:
Number
>
{
self
.
spaces
.
get
(
pn_space
)
?
.
largest_acked
}
pub
fn
set_qlog
(
&
mut
self
qlog
:
Qlog
)
{
self
.
qlog
=
qlog
;
}
pub
fn
drop_0rtt
(
&
mut
self
primary_path
:
&
PathRef
now
:
Instant
)
-
>
Vec
<
sent
:
:
Packet
>
{
let
Some
(
sp
)
=
self
.
spaces
.
get_mut
(
PacketNumberSpace
:
:
ApplicationData
)
else
{
return
Vec
:
:
new
(
)
;
}
;
if
sp
.
largest_acked
.
is_some
(
)
{
qwarn
!
(
"
0
-
RTT
packets
already
acknowledged
not
dropping
"
)
;
return
Vec
:
:
new
(
)
;
}
let
mut
dropped
=
sp
.
remove_ignored
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
path
=
primary_path
.
borrow_mut
(
)
;
for
p
in
&
mut
dropped
{
path
.
discard_packet
(
p
now
&
mut
self
.
stats
.
borrow_mut
(
)
)
;
}
dropped
}
pub
fn
on_packet_sent
(
&
mut
self
path
:
&
PathRef
mut
sent_packet
:
sent
:
:
Packet
now
:
Instant
)
{
let
pn_space
=
PacketNumberSpace
:
:
from
(
sent_packet
.
packet_type
(
)
)
;
qtrace
!
(
"
[
{
self
}
]
packet
{
pn_space
}
-
{
}
sent
"
sent_packet
.
pn
(
)
)
;
if
let
Some
(
pto
)
=
self
.
pto_state
.
as_mut
(
)
{
pto
.
pto_sent
(
pn_space
)
;
}
if
let
Some
(
space
)
=
self
.
spaces
.
get_mut
(
pn_space
)
{
path
.
borrow_mut
(
)
.
packet_sent
(
&
mut
sent_packet
now
)
;
space
.
on_packet_sent
(
sent_packet
)
;
}
else
{
qinfo
!
(
"
[
{
self
}
]
ignoring
packet
{
}
from
dropped
space
{
pn_space
}
"
sent_packet
.
pn
(
)
)
;
}
}
#
[
must_use
]
pub
fn
should_probe
(
&
self
pto
:
Duration
now
:
Instant
)
-
>
bool
{
self
.
spaces
.
get
(
PacketNumberSpace
:
:
ApplicationData
)
.
is_some_and
(
|
sp
|
sp
.
should_probe
(
pto
now
)
)
}
fn
rtt_sample
(
&
self
rtt
:
&
mut
RttEstimate
send_time
:
Instant
now
:
Instant
ack_delay
:
Duration
)
{
let
source
=
if
self
.
confirmed_time
.
is_some_and
(
|
t
|
t
<
send_time
)
{
RttSource
:
:
AckConfirmed
}
else
{
RttSource
:
:
Ack
}
;
if
let
Some
(
sample
)
=
now
.
checked_duration_since
(
send_time
)
{
rtt
.
update
(
&
self
.
qlog
sample
ack_delay
source
now
)
;
}
}
const
fn
confirmed
(
&
self
)
-
>
bool
{
self
.
confirmed_time
.
is_some
(
)
}
fn
maybe_prime_handshake_pto
(
&
mut
self
now
:
Instant
)
{
let
Some
(
pto
)
=
self
.
pto_state
.
as_ref
(
)
.
filter
(
|
pto
|
pto
.
space
=
=
PacketNumberSpace
:
:
Initial
)
else
{
return
;
}
;
if
!
self
.
spaces
.
get
(
PacketNumberSpace
:
:
Initial
)
.
is_some_and
(
|
space
|
space
.
largest_acked
.
is_some
(
)
)
{
return
;
}
let
Some
(
hs_space
)
=
self
.
spaces
.
get_mut
(
PacketNumberSpace
:
:
Handshake
)
else
{
return
;
}
;
if
hs_space
.
last_ack_eliciting
.
is_none
(
)
&
&
hs_space
.
largest_acked
.
is_none
(
)
{
qtrace
!
(
"
Priming
Handshake
PTO
baseline
(
no
HS
packets
after
{
}
Initial
PTOs
)
"
pto
.
count
(
)
)
;
hs_space
.
last_ack_eliciting
=
Some
(
now
)
;
}
}
pub
fn
on_ack_received
<
R
>
(
&
mut
self
primary_path
:
&
PathRef
pn_space
:
PacketNumberSpace
acked_ranges
:
R
ack_ecn
:
Option
<
&
ecn
:
:
Count
>
ack_delay
:
Duration
now
:
Instant
)
-
>
(
Vec
<
sent
:
:
Packet
>
Vec
<
sent
:
:
Packet
>
)
where
R
:
IntoIterator
<
Item
=
RangeInclusive
<
packet
:
:
Number
>
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
Some
(
space
)
=
self
.
spaces
.
get_mut
(
pn_space
)
else
{
qinfo
!
(
"
ACK
on
discarded
space
"
)
;
return
(
Vec
:
:
new
(
)
Vec
:
:
new
(
)
)
;
}
;
let
(
acked_packets
any_ack_eliciting
)
=
space
.
remove_acked
(
acked_ranges
&
mut
self
.
stats
.
borrow_mut
(
)
)
;
let
Some
(
largest_acked_pkt
)
=
acked_packets
.
first
(
)
else
{
return
(
Vec
:
:
new
(
)
Vec
:
:
new
(
)
)
;
}
;
let
prev_largest_acked
=
space
.
largest_acked_sent_time
;
if
Some
(
largest_acked_pkt
.
pn
(
)
)
>
space
.
largest_acked
{
space
.
largest_acked
=
Some
(
largest_acked_pkt
.
pn
(
)
)
;
space
.
largest_acked_sent_time
=
Some
(
largest_acked_pkt
.
time_sent
(
)
)
;
if
any_ack_eliciting
&
&
largest_acked_pkt
.
on_primary_path
(
)
{
self
.
rtt_sample
(
primary_path
.
borrow_mut
(
)
.
rtt_mut
(
)
largest_acked_pkt
.
time_sent
(
)
now
ack_delay
)
;
}
}
qdebug
!
(
"
[
{
self
}
]
ACK
for
{
pn_space
:
?
}
-
largest_acked
=
{
}
"
largest_acked_pkt
.
pn
(
)
)
;
let
cleanup_delay
=
self
.
pto_period
(
primary_path
.
borrow
(
)
.
rtt
(
)
)
;
let
Some
(
sp
)
=
self
.
spaces
.
get_mut
(
pn_space
)
else
{
return
(
Vec
:
:
new
(
)
Vec
:
:
new
(
)
)
;
}
;
let
loss_delay
=
primary_path
.
borrow
(
)
.
rtt
(
)
.
loss_delay
(
)
;
let
mut
lost
=
Vec
:
:
new
(
)
;
sp
.
detect_lost_packets
(
now
loss_delay
cleanup_delay
&
mut
lost
)
;
self
.
stats
.
borrow_mut
(
)
.
lost
+
=
lost
.
len
(
)
;
primary_path
.
borrow_mut
(
)
.
on_packets_lost
(
prev_largest_acked
self
.
confirmed
(
)
&
lost
&
mut
self
.
stats
.
borrow_mut
(
)
now
)
;
primary_path
.
borrow_mut
(
)
.
on_packets_acked
(
&
acked_packets
ack_ecn
now
&
mut
self
.
stats
.
borrow_mut
(
)
)
;
self
.
pto_state
=
None
;
(
acked_packets
lost
)
}
pub
fn
retry
(
&
mut
self
primary_path
:
&
PathRef
now
:
Instant
)
-
>
Vec
<
sent
:
:
Packet
>
{
self
.
pto_state
=
None
;
let
mut
dropped
=
self
.
spaces
.
iter_mut
(
)
.
flat_map
(
LossRecoverySpace
:
:
remove_ignored
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
path
=
primary_path
.
borrow_mut
(
)
;
for
p
in
&
mut
dropped
{
path
.
discard_packet
(
p
now
&
mut
self
.
stats
.
borrow_mut
(
)
)
;
}
dropped
}
fn
confirm
(
&
mut
self
rtt
:
&
RttEstimate
now
:
Instant
)
{
debug_assert
!
(
self
.
confirmed_time
.
is_none
(
)
)
;
self
.
confirmed_time
=
Some
(
now
)
;
if
let
Some
(
pto
)
=
self
.
pto_time
(
rtt
PacketNumberSpace
:
:
ApplicationData
)
{
if
pto
<
now
{
let
probes
=
enum_set
!
(
PacketNumberSpace
:
:
ApplicationData
)
;
self
.
fire_pto
(
PacketNumberSpace
:
:
ApplicationData
probes
now
)
;
}
}
}
pub
fn
migrate
(
&
mut
self
)
{
for
space
in
self
.
spaces
.
iter_mut
(
)
{
space
.
migrate
(
)
;
}
}
pub
fn
discard
(
&
mut
self
primary_path
:
&
PathRef
space
:
PacketNumberSpace
now
:
Instant
)
{
qdebug
!
(
"
[
{
self
}
]
Reset
loss
recovery
state
for
{
space
:
?
}
"
)
;
let
mut
path
=
primary_path
.
borrow_mut
(
)
;
for
p
in
self
.
spaces
.
drop_space
(
space
)
{
path
.
discard_packet
(
&
p
now
&
mut
self
.
stats
.
borrow_mut
(
)
)
;
}
self
.
pto_state
=
None
;
if
space
=
=
PacketNumberSpace
:
:
Handshake
{
self
.
confirm
(
path
.
rtt
(
)
now
)
;
}
}
#
[
must_use
]
pub
fn
next_timeout
(
&
self
path
:
&
Path
)
-
>
Option
<
Instant
>
{
let
rtt
=
path
.
rtt
(
)
;
let
loss_time
=
self
.
earliest_loss_time
(
rtt
)
;
let
pto_time
=
if
path
.
pto_possible
(
)
{
self
.
earliest_pto
(
rtt
)
}
else
{
None
}
;
qtrace
!
(
"
[
{
self
}
]
next_timeout
loss
=
{
loss_time
:
?
}
pto
=
{
pto_time
:
?
}
"
)
;
match
(
loss_time
pto_time
)
{
(
Some
(
loss_time
)
Some
(
pto_time
)
)
=
>
Some
(
min
(
loss_time
pto_time
)
)
(
Some
(
loss_time
)
None
)
=
>
Some
(
loss_time
)
(
None
Some
(
pto_time
)
)
=
>
Some
(
pto_time
)
(
None
None
)
=
>
None
}
}
fn
earliest_loss_time
(
&
self
rtt
:
&
RttEstimate
)
-
>
Option
<
Instant
>
{
self
.
spaces
.
iter
(
)
.
filter_map
(
LossRecoverySpace
:
:
loss_recovery_timer_start
)
.
min
(
)
.
map
(
|
val
|
val
+
rtt
.
loss_delay
(
)
)
}
fn
pto_period_inner
(
rtt
:
&
RttEstimate
pto_state
:
Option
<
&
PtoState
>
confirmed
:
bool
fast_pto
:
u8
)
-
>
Duration
{
let
pto_count
=
pto_state
.
map_or
(
0
|
p
|
u32
:
:
try_from
(
p
.
count
)
.
unwrap_or
(
0
)
)
;
rtt
.
pto
(
confirmed
)
.
checked_mul
(
u32
:
:
from
(
fast_pto
)
<
<
min
(
pto_count
u32
:
:
BITS
-
u8
:
:
BITS
)
)
.
map_or
(
Duration
:
:
from_secs
(
3600
)
|
p
|
p
/
u32
:
:
from
(
FAST_PTO_SCALE
)
)
}
fn
pto_period
(
&
self
rtt
:
&
RttEstimate
)
-
>
Duration
{
Self
:
:
pto_period_inner
(
rtt
self
.
pto_state
.
as_ref
(
)
self
.
confirmed
(
)
self
.
fast_pto
)
}
fn
pto_time
(
&
self
rtt
:
&
RttEstimate
pn_space
:
PacketNumberSpace
)
-
>
Option
<
Instant
>
{
self
.
spaces
.
get
(
pn_space
)
?
.
pto_base_time
(
)
.
map
(
|
t
|
t
+
self
.
pto_period
(
rtt
)
)
}
fn
earliest_pto
(
&
self
rtt
:
&
RttEstimate
)
-
>
Option
<
Instant
>
{
if
self
.
confirmed
(
)
{
self
.
pto_time
(
rtt
PacketNumberSpace
:
:
ApplicationData
)
}
else
{
self
.
pto_time
(
rtt
PacketNumberSpace
:
:
Initial
)
.
iter
(
)
.
chain
(
self
.
pto_time
(
rtt
PacketNumberSpace
:
:
Handshake
)
.
iter
(
)
)
.
min
(
)
.
copied
(
)
}
}
fn
fire_pto
(
&
mut
self
pn_space
:
PacketNumberSpace
allow_probes
:
PacketNumberSpaceSet
now
:
Instant
)
{
if
let
Some
(
st
)
=
&
mut
self
.
pto_state
{
st
.
pto
(
pn_space
allow_probes
)
;
}
else
{
self
.
pto_state
=
Some
(
PtoState
:
:
new
(
pn_space
allow_probes
)
)
;
}
if
let
Some
(
st
)
=
&
mut
self
.
pto_state
{
st
.
count_pto
(
&
mut
self
.
stats
.
borrow_mut
(
)
)
;
qlog
:
:
metrics_updated
(
&
self
.
qlog
&
[
qlog
:
:
Metric
:
:
PtoCount
(
st
.
count
(
)
)
]
now
)
;
}
}
fn
maybe_fire_pto
(
&
mut
self
primary_path
:
&
PathRef
now
:
Instant
lost
:
&
mut
Vec
<
sent
:
:
Packet
>
)
{
let
mut
pto_space
=
None
;
let
mut
allow_probes
=
PacketNumberSpaceSet
:
:
default
(
)
;
for
pn_space
in
PacketNumberSpace
:
:
iter
(
)
{
let
Some
(
t
)
=
self
.
pto_time
(
primary_path
.
borrow
(
)
.
rtt
(
)
pn_space
)
else
{
continue
;
}
;
allow_probes
.
insert
(
pn_space
)
;
if
t
>
now
{
continue
;
}
qdebug
!
(
"
[
{
self
}
]
PTO
timer
fired
for
{
pn_space
:
?
}
"
)
;
let
Some
(
space
)
=
self
.
spaces
.
get_mut
(
pn_space
)
else
{
continue
;
}
;
let
mut
size
=
0
;
let
mtu
=
primary_path
.
borrow
(
)
.
plpmtu
(
)
;
lost
.
extend
(
space
.
pto_packets
(
)
.
take_while
(
move
|
p
|
{
size
+
=
p
.
len
(
)
;
size
<
=
MAX_PTO_PACKET_COUNT
*
mtu
}
)
.
cloned
(
)
)
;
pto_space
=
pto_space
.
or
(
Some
(
pn_space
)
)
;
}
if
let
Some
(
pn_space
)
=
pto_space
{
qtrace
!
(
"
[
{
self
}
]
PTO
{
pn_space
}
probing
{
allow_probes
:
?
}
"
)
;
self
.
fire_pto
(
pn_space
allow_probes
now
)
;
if
pn_space
=
=
PacketNumberSpace
:
:
Initial
{
self
.
maybe_prime_handshake_pto
(
now
)
;
}
}
}
pub
fn
timeout
(
&
mut
self
primary_path
:
&
PathRef
now
:
Instant
)
-
>
Vec
<
sent
:
:
Packet
>
{
qtrace
!
(
"
[
{
self
}
]
timeout
{
now
:
?
}
"
)
;
let
loss_delay
=
primary_path
.
borrow
(
)
.
rtt
(
)
.
loss_delay
(
)
;
let
confirmed
=
self
.
confirmed
(
)
;
let
mut
lost_packets
=
Vec
:
:
new
(
)
;
for
space
in
self
.
spaces
.
iter_mut
(
)
{
let
first
=
lost_packets
.
len
(
)
;
let
pto
=
Self
:
:
pto_period_inner
(
primary_path
.
borrow
(
)
.
rtt
(
)
self
.
pto_state
.
as_ref
(
)
confirmed
self
.
fast_pto
)
;
space
.
detect_lost_packets
(
now
loss_delay
pto
&
mut
lost_packets
)
;
primary_path
.
borrow_mut
(
)
.
on_packets_lost
(
space
.
largest_acked_sent_time
confirmed
&
lost_packets
[
first
.
.
]
&
mut
self
.
stats
.
borrow_mut
(
)
now
)
;
}
self
.
stats
.
borrow_mut
(
)
.
lost
+
=
lost_packets
.
len
(
)
;
self
.
maybe_fire_pto
(
primary_path
now
&
mut
lost_packets
)
;
lost_packets
}
#
[
expect
(
clippy
:
:
option_if_let_else
reason
=
"
Alternative
is
less
readable
.
"
)
]
pub
fn
send_profile
(
&
mut
self
path
:
&
Path
now
:
Instant
)
-
>
SendProfile
{
qtrace
!
(
"
[
{
self
}
]
get
send
profile
{
now
:
?
}
"
)
;
let
sender
=
path
.
sender
(
)
;
let
mtu
=
path
.
plpmtu
(
)
;
#
[
allow
(
clippy
:
:
allow_attributes
clippy
:
:
return_and_then
reason
=
"
TODO
:
False
positive
on
nightly
;
function
isn
'
t
returning
Option
or
Result
"
)
]
if
let
Some
(
profile
)
=
self
.
pto_state
.
as_mut
(
)
.
and_then
(
|
pto
|
pto
.
send_profile
(
mtu
)
)
{
profile
}
else
{
let
limit
=
min
(
sender
.
cwnd_avail
(
)
path
.
amplification_limit
(
)
)
;
if
limit
>
mtu
{
if
sender
.
next_paced
(
path
.
rtt
(
)
.
estimate
(
)
)
.
is_some_and
(
|
t
|
t
>
now
)
{
SendProfile
:
:
new_paced
(
)
}
else
{
SendProfile
:
:
new_limited
(
mtu
)
}
}
else
if
sender
.
recovery_packet
(
)
{
SendProfile
:
:
new_pto
(
PacketNumberSpace
:
:
Initial
mtu
PacketNumberSpaceSet
:
:
all
(
)
)
}
else
{
SendProfile
:
:
new_limited
(
limit
)
}
}
}
}
impl
Display
for
Loss
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
recovery
:
:
Loss
"
)
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
tests
{
use
std
:
:
{
cell
:
:
RefCell
ops
:
:
{
Deref
DerefMut
RangeInclusive
}
rc
:
:
Rc
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
qlog
:
:
Qlog
;
use
test_fixture
:
:
{
now
DEFAULT_ADDR
}
;
use
super
:
:
{
LossRecoverySpace
PacketNumberSpace
PtoState
SendProfile
FAST_PTO_SCALE
}
;
use
crate
:
:
{
cid
:
:
{
ConnectionId
ConnectionIdEntry
}
ecn
packet
path
:
:
{
Path
PathRef
}
recovery
:
:
{
self
sent
MAX_PTO_PACKET_COUNT
}
stats
:
:
{
Stats
StatsCell
}
tracking
:
:
PacketNumberSpaceSet
ConnectionParameters
Token
as
Srt
}
;
const
fn
ms
(
t
:
u64
)
-
>
Duration
{
Duration
:
:
from_millis
(
t
)
}
const
ON_SENT_SIZE
:
usize
=
100
;
const
TEST_RTT
:
Duration
=
ms
(
7000
)
;
const
TEST_RTTVAR
:
Duration
=
ms
(
3500
)
;
struct
Fixture
{
lr
:
recovery
:
:
Loss
path
:
PathRef
}
impl
Fixture
{
pub
fn
on_ack_received
(
&
mut
self
pn_space
:
PacketNumberSpace
acked_ranges
:
Vec
<
RangeInclusive
<
packet
:
:
Number
>
>
ack_ecn
:
Option
<
&
ecn
:
:
Count
>
ack_delay
:
Duration
now
:
Instant
)
-
>
(
Vec
<
sent
:
:
Packet
>
Vec
<
sent
:
:
Packet
>
)
{
self
.
lr
.
on_ack_received
(
&
self
.
path
pn_space
acked_ranges
ack_ecn
ack_delay
now
)
}
pub
fn
on_packet_sent
(
&
mut
self
sent_packet
:
sent
:
:
Packet
now
:
Instant
)
{
self
.
lr
.
on_packet_sent
(
&
self
.
path
sent_packet
now
)
;
}
pub
fn
timeout
(
&
mut
self
now
:
Instant
)
-
>
Vec
<
sent
:
:
Packet
>
{
self
.
lr
.
timeout
(
&
self
.
path
now
)
}
pub
fn
next_timeout
(
&
self
)
-
>
Option
<
Instant
>
{
self
.
lr
.
next_timeout
(
&
self
.
path
.
borrow
(
)
)
}
pub
fn
discard
(
&
mut
self
space
:
PacketNumberSpace
now
:
Instant
)
{
self
.
lr
.
discard
(
&
self
.
path
space
now
)
;
}
pub
fn
pto_time
(
&
self
space
:
PacketNumberSpace
)
-
>
Option
<
Instant
>
{
self
.
lr
.
pto_time
(
self
.
path
.
borrow
(
)
.
rtt
(
)
space
)
}
pub
fn
send_profile
(
&
mut
self
now
:
Instant
)
-
>
SendProfile
{
self
.
lr
.
send_profile
(
&
self
.
path
.
borrow
(
)
now
)
}
}
impl
Default
for
Fixture
{
fn
default
(
)
-
>
Self
{
let
stats
=
StatsCell
:
:
default
(
)
;
let
mut
path
=
Path
:
:
temporary
(
DEFAULT_ADDR
DEFAULT_ADDR
&
ConnectionParameters
:
:
default
(
)
Qlog
:
:
default
(
)
now
(
)
&
mut
stats
.
borrow_mut
(
)
)
;
path
.
make_permanent
(
None
ConnectionIdEntry
:
:
new
(
0
ConnectionId
:
:
from
(
&
[
1
2
3
]
)
Srt
:
:
default
(
)
)
)
;
path
.
set_primary
(
true
now
(
)
)
;
path
.
rtt_mut
(
)
.
set_initial
(
TEST_RTT
)
;
Self
{
lr
:
recovery
:
:
Loss
:
:
new
(
stats
FAST_PTO_SCALE
)
path
:
Rc
:
:
new
(
RefCell
:
:
new
(
path
)
)
}
}
}
impl
Deref
for
Fixture
{
type
Target
=
recovery
:
:
Loss
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
lr
}
}
impl
DerefMut
for
Fixture
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
lr
}
}
fn
assert_rtts
(
lr
:
&
Fixture
latest_rtt
:
Duration
smoothed_rtt
:
Duration
rttvar
:
Duration
min_rtt
:
Duration
)
{
let
p
=
lr
.
path
.
borrow
(
)
;
let
rtt
=
p
.
rtt
(
)
;
println
!
(
"
rtts
:
{
:
?
}
{
:
?
}
{
:
?
}
{
:
?
}
"
rtt
.
latest
(
)
rtt
.
estimate
(
)
rtt
.
rttvar
(
)
rtt
.
minimum
(
)
)
;
assert_eq
!
(
rtt
.
latest
(
)
latest_rtt
"
latest
RTT
"
)
;
assert_eq
!
(
rtt
.
estimate
(
)
smoothed_rtt
"
smoothed
RTT
"
)
;
assert_eq
!
(
rtt
.
rttvar
(
)
rttvar
"
RTT
variance
"
)
;
assert_eq
!
(
rtt
.
minimum
(
)
min_rtt
"
min
RTT
"
)
;
}
fn
assert_sent_times
(
lr
:
&
Fixture
initial
:
Option
<
Instant
>
handshake
:
Option
<
Instant
>
app_data
:
Option
<
Instant
>
)
{
let
est
=
|
sp
|
{
lr
.
spaces
.
get
(
sp
)
.
and_then
(
LossRecoverySpace
:
:
loss_recovery_timer_start
)
}
;
println
!
(
"
loss
times
:
{
:
?
}
{
:
?
}
{
:
?
}
"
est
(
PacketNumberSpace
:
:
Initial
)
est
(
PacketNumberSpace
:
:
Handshake
)
est
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
assert_eq
!
(
est
(
PacketNumberSpace
:
:
Initial
)
initial
"
Initial
earliest
sent
time
"
)
;
assert_eq
!
(
est
(
PacketNumberSpace
:
:
Handshake
)
handshake
"
Handshake
earliest
sent
time
"
)
;
assert_eq
!
(
est
(
PacketNumberSpace
:
:
ApplicationData
)
app_data
"
AppData
earliest
sent
time
"
)
;
}
fn
assert_no_sent_times
(
lr
:
&
Fixture
)
{
assert_sent_times
(
lr
None
None
None
)
;
}
const
PACING
:
Duration
=
ms
(
7
)
;
fn
pn_time
(
pn
:
u64
)
-
>
Instant
{
now
(
)
+
(
PACING
*
pn
.
try_into
(
)
.
unwrap
(
)
)
}
fn
pace
(
lr
:
&
mut
Fixture
count
:
u64
)
{
for
pn
in
0
.
.
count
{
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
pn
pn_time
(
pn
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
}
}
const
ACK_DELAY
:
Duration
=
ms
(
24
)
;
fn
ack
(
lr
:
&
mut
Fixture
pn
:
u64
delay
:
Duration
)
{
lr
.
on_ack_received
(
PacketNumberSpace
:
:
ApplicationData
vec
!
[
pn
.
.
=
pn
]
None
ACK_DELAY
pn_time
(
pn
)
+
delay
)
;
}
fn
add_sent
(
lrs
:
&
mut
LossRecoverySpace
max_pn
:
packet
:
:
Number
)
{
for
pn
in
0
.
.
=
max_pn
{
lrs
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
pn
pn_time
(
pn
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
)
;
}
}
fn
match_acked
(
acked
:
&
[
sent
:
:
Packet
]
expected
:
&
[
packet
:
:
Number
]
)
{
assert_eq
!
(
acked
.
iter
(
)
.
map
(
sent
:
:
Packet
:
:
pn
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
expected
)
;
}
#
[
test
]
fn
remove_acked
(
)
{
let
mut
lrs
=
LossRecoverySpace
:
:
new
(
PacketNumberSpace
:
:
ApplicationData
)
;
let
mut
stats
=
Stats
:
:
default
(
)
;
add_sent
(
&
mut
lrs
10
)
;
let
(
acked
_
)
=
lrs
.
remove_acked
(
vec
!
[
]
&
mut
stats
)
;
assert
!
(
acked
.
is_empty
(
)
)
;
let
(
acked
_
)
=
lrs
.
remove_acked
(
vec
!
[
7
.
.
=
8
2
.
.
=
4
]
&
mut
stats
)
;
match_acked
(
&
acked
&
[
8
7
4
3
2
]
)
;
let
(
acked
_
)
=
lrs
.
remove_acked
(
vec
!
[
8
.
.
=
11
]
&
mut
stats
)
;
match_acked
(
&
acked
&
[
10
9
]
)
;
let
(
acked
_
)
=
lrs
.
remove_acked
(
vec
!
[
0
.
.
=
2
]
&
mut
stats
)
;
match_acked
(
&
acked
&
[
1
0
]
)
;
let
(
acked
_
)
=
lrs
.
remove_acked
(
vec
!
[
5
.
.
=
6
]
&
mut
stats
)
;
match_acked
(
&
acked
&
[
6
5
]
)
;
}
#
[
test
]
fn
initial_rtt
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
pace
(
&
mut
lr
1
)
;
let
rtt
=
ms
(
100
)
;
ack
(
&
mut
lr
0
rtt
)
;
assert_rtts
(
&
lr
rtt
rtt
rtt
/
2
rtt
)
;
assert_no_sent_times
(
&
lr
)
;
}
fn
setup_lr
(
n
:
u64
)
-
>
Fixture
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
pace
(
&
mut
lr
n
)
;
ack
(
&
mut
lr
0
TEST_RTT
)
;
assert_rtts
(
&
lr
TEST_RTT
TEST_RTT
TEST_RTTVAR
TEST_RTT
)
;
assert_no_sent_times
(
&
lr
)
;
lr
}
#
[
test
]
fn
ack_delay_adjusted
(
)
{
let
mut
lr
=
setup_lr
(
2
)
;
ack
(
&
mut
lr
1
TEST_RTT
+
ACK_DELAY
)
;
assert_rtts
(
&
lr
TEST_RTT
TEST_RTT
TEST_RTTVAR
*
3
/
4
TEST_RTT
)
;
assert_no_sent_times
(
&
lr
)
;
}
#
[
test
]
fn
ack_delay_ignored
(
)
{
let
mut
lr
=
setup_lr
(
2
)
;
let
extra
=
ms
(
8
)
;
assert
!
(
extra
<
ACK_DELAY
)
;
ack
(
&
mut
lr
1
TEST_RTT
+
extra
)
;
let
expected_rtt
=
TEST_RTT
+
(
extra
/
8
)
;
let
expected_rttvar
=
(
TEST_RTTVAR
*
3
+
extra
)
/
4
;
assert_rtts
(
&
lr
TEST_RTT
+
extra
expected_rtt
expected_rttvar
TEST_RTT
)
;
assert_no_sent_times
(
&
lr
)
;
}
#
[
test
]
fn
reduce_min_rtt
(
)
{
let
mut
lr
=
setup_lr
(
2
)
;
let
delta
=
ms
(
4
)
;
let
reduced_rtt
=
TEST_RTT
.
checked_sub
(
delta
)
.
unwrap
(
)
;
ack
(
&
mut
lr
1
reduced_rtt
)
;
let
expected_rtt
=
TEST_RTT
.
checked_sub
(
delta
/
8
)
.
unwrap
(
)
;
let
expected_rttvar
=
(
TEST_RTTVAR
*
3
+
delta
)
/
4
;
assert_rtts
(
&
lr
reduced_rtt
expected_rtt
expected_rttvar
reduced_rtt
)
;
assert_no_sent_times
(
&
lr
)
;
}
#
[
test
]
fn
no_new_acks
(
)
{
let
mut
lr
=
setup_lr
(
1
)
;
let
check
=
|
lr
:
&
Fixture
|
{
assert_rtts
(
lr
TEST_RTT
TEST_RTT
TEST_RTTVAR
TEST_RTT
)
;
assert_no_sent_times
(
lr
)
;
}
;
check
(
&
lr
)
;
ack
(
&
mut
lr
0
ms
(
1339
)
)
;
check
(
&
lr
)
;
ack
(
&
mut
lr
0
ms
(
3
)
)
;
check
(
&
lr
)
;
}
#
[
test
]
fn
time_loss_detection_gap
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
0
pn_time
(
0
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
1
pn_time
(
0
)
+
TEST_RTT
/
4
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
let
(
_
lost
)
=
lr
.
on_ack_received
(
PacketNumberSpace
:
:
ApplicationData
vec
!
[
1
.
.
=
1
]
None
ACK_DELAY
pn_time
(
0
)
+
(
TEST_RTT
*
5
/
4
)
)
;
assert_eq
!
(
lost
.
len
(
)
1
)
;
assert_no_sent_times
(
&
lr
)
;
}
#
[
test
]
fn
time_loss_detection_timeout
(
)
{
let
mut
lr
=
setup_lr
(
3
)
;
let
pn1_sent_time
=
pn_time
(
1
)
;
let
pn1_loss_time
=
pn1_sent_time
+
(
TEST_RTT
*
9
/
8
)
;
let
pn2_ack_time
=
pn_time
(
2
)
+
TEST_RTT
;
assert
!
(
pn1_loss_time
>
pn2_ack_time
)
;
let
(
_
lost
)
=
lr
.
on_ack_received
(
PacketNumberSpace
:
:
ApplicationData
vec
!
[
2
.
.
=
2
]
None
ACK_DELAY
pn2_ack_time
)
;
assert
!
(
lost
.
is_empty
(
)
)
;
let
lost
=
lr
.
timeout
(
pn2_ack_time
)
;
assert
!
(
lost
.
is_empty
(
)
)
;
assert_sent_times
(
&
lr
None
None
Some
(
pn1_sent_time
)
)
;
let
callback_time
=
lr
.
next_timeout
(
)
;
assert_eq
!
(
callback_time
Some
(
pn1_loss_time
)
)
;
let
packets
=
lr
.
timeout
(
pn1_loss_time
)
;
assert_eq
!
(
packets
.
len
(
)
1
)
;
assert
!
(
packets
[
0
]
.
expired
(
pn1_loss_time
Duration
:
:
new
(
0
0
)
)
)
;
assert_no_sent_times
(
&
lr
)
;
}
#
[
test
]
fn
big_gap_loss
(
)
{
let
mut
lr
=
setup_lr
(
5
)
;
assert_eq
!
(
super
:
:
PACKET_THRESHOLD
3
)
;
let
(
_
lost
)
=
lr
.
on_ack_received
(
PacketNumberSpace
:
:
ApplicationData
vec
!
[
2
.
.
=
4
]
None
ACK_DELAY
pn_time
(
4
)
)
;
assert_eq
!
(
lost
.
len
(
)
1
)
;
}
#
[
test
]
#
[
should_panic
(
expected
=
"
discarding
application
space
"
)
]
fn
drop_app
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
lr
.
discard
(
PacketNumberSpace
:
:
ApplicationData
now
(
)
)
;
}
#
[
test
]
fn
ack_after_drop
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
lr
.
discard
(
PacketNumberSpace
:
:
Initial
now
(
)
)
;
let
(
acked
lost
)
=
lr
.
on_ack_received
(
PacketNumberSpace
:
:
Initial
vec
!
[
]
None
Duration
:
:
from_millis
(
0
)
pn_time
(
0
)
)
;
assert
!
(
acked
.
is_empty
(
)
)
;
assert
!
(
lost
.
is_empty
(
)
)
;
}
#
[
test
]
fn
drop_spaces
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Initial
0
pn_time
(
0
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Handshake
0
pn_time
(
1
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
0
pn_time
(
2
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
for
sp
in
&
[
packet
:
:
Type
:
:
Initial
packet
:
:
Type
:
:
Handshake
packet
:
:
Type
:
:
Short
]
{
let
sent_pkt
=
sent
:
:
Packet
:
:
new
(
*
sp
1
pn_time
(
3
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
;
let
pn_space
=
PacketNumberSpace
:
:
from
(
sent_pkt
.
packet_type
(
)
)
;
lr
.
on_packet_sent
(
sent_pkt
now
(
)
)
;
lr
.
on_ack_received
(
pn_space
vec
!
[
1
.
.
=
1
]
None
Duration
:
:
from_secs
(
0
)
pn_time
(
3
)
)
;
let
mut
lost
=
Vec
:
:
new
(
)
;
lr
.
spaces
.
get_mut
(
pn_space
)
.
unwrap
(
)
.
detect_lost_packets
(
pn_time
(
3
)
TEST_RTT
TEST_RTT
*
3
&
mut
lost
)
;
assert
!
(
lost
.
is_empty
(
)
)
;
}
lr
.
discard
(
PacketNumberSpace
:
:
Initial
pn_time
(
3
)
)
;
assert_sent_times
(
&
lr
None
Some
(
pn_time
(
1
)
)
Some
(
pn_time
(
2
)
)
)
;
lr
.
discard
(
PacketNumberSpace
:
:
Handshake
pn_time
(
3
)
)
;
assert_sent_times
(
&
lr
None
None
Some
(
pn_time
(
2
)
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Initial
0
pn_time
(
3
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
assert_sent_times
(
&
lr
None
None
Some
(
pn_time
(
2
)
)
)
;
}
#
[
test
]
fn
rearm_pto_after_confirmed
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Initial
0
now
(
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
let
rtt
=
lr
.
path
.
borrow
(
)
.
rtt
(
)
.
estimate
(
)
;
lr
.
on_ack_received
(
PacketNumberSpace
:
:
Initial
vec
!
[
0
.
.
=
0
]
None
Duration
:
:
new
(
0
0
)
now
(
)
+
rtt
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Handshake
0
now
(
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
0
now
(
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
assert
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
ApplicationData
)
.
is_some
(
)
)
;
lr
.
discard
(
PacketNumberSpace
:
:
Initial
pn_time
(
1
)
)
;
assert
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
ApplicationData
)
.
is_some
(
)
)
;
let
default_pto
=
lr
.
path
.
borrow
(
)
.
rtt
(
)
.
pto
(
true
)
;
let
expected_pto
=
pn_time
(
2
)
+
default_pto
;
lr
.
discard
(
PacketNumberSpace
:
:
Handshake
expected_pto
)
;
let
profile
=
lr
.
send_profile
(
now
(
)
)
;
assert
!
(
profile
.
pto
.
is_some
(
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
}
#
[
test
]
fn
no_pto_if_amplification_limited
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
{
const
SPARE
:
usize
=
10
;
let
mut
path
=
lr
.
path
.
borrow_mut
(
)
;
let
limit
=
path
.
amplification_limit
(
)
;
path
.
add_sent
(
limit
-
SPARE
)
;
assert_eq
!
(
path
.
amplification_limit
(
)
SPARE
)
;
}
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Initial
0
now
(
)
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
(
)
)
;
let
handshake_pto
=
lr
.
path
.
borrow
(
)
.
rtt
(
)
.
pto
(
false
)
;
let
expected_pto
=
now
(
)
+
handshake_pto
;
assert_eq
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
Initial
)
Some
(
expected_pto
)
)
;
let
profile
=
lr
.
send_profile
(
now
(
)
)
;
assert
!
(
profile
.
ack_only
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
profile
.
pto
.
is_none
(
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
}
#
[
test
]
fn
pto_two_spaces
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
let
now
=
now
(
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Initial
0
now
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Handshake
0
now
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
)
;
let
handshake_pto
=
lr
.
path
.
borrow
(
)
.
rtt
(
)
.
pto
(
false
)
;
let
expected_pto
=
now
+
handshake_pto
;
assert_eq
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
Initial
)
Some
(
expected_pto
)
)
;
assert_eq
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
Handshake
)
Some
(
expected_pto
)
)
;
let
now
=
expected_pto
;
let
lost
=
lr
.
timeout
(
now
)
;
assert_eq
!
(
2
lost
.
len
(
)
)
;
assert
!
(
lost
.
iter
(
)
.
any
(
|
x
|
x
.
packet_type
(
)
=
=
packet
:
:
Type
:
:
Initial
)
)
;
assert
!
(
lost
.
iter
(
)
.
any
(
|
x
|
x
.
packet_type
(
)
=
=
packet
:
:
Type
:
:
Handshake
)
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_some
(
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Handshake
0
now
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_some
(
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
assert_eq
!
(
2
MAX_PTO_PACKET_COUNT
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_none
(
)
)
;
}
#
[
test
]
fn
pto_two_spaces_staggered
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
let
start_time
=
now
(
)
;
let
now
=
start_time
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Initial
0
now
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
)
;
let
initial_pto
=
now
+
lr
.
path
.
borrow
(
)
.
rtt
(
)
.
pto
(
false
)
;
assert_eq
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
Initial
)
Some
(
initial_pto
)
)
;
assert
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
ApplicationData
)
.
is_none
(
)
)
;
let
now
=
initial_pto
;
let
_lost
=
lr
.
timeout
(
now
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_some
(
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
lr
.
on_packet_sent
(
sent
:
:
Packet
:
:
new
(
packet
:
:
Type
:
:
Short
0
now
true
recovery
:
:
Tokens
:
:
new
(
)
ON_SENT_SIZE
)
now
)
;
let
two_pto
=
2
*
lr
.
path
.
borrow
(
)
.
rtt
(
)
.
pto
(
false
)
;
let
initial_pto2
=
start_time
+
two_pto
;
let
app_pto
=
now
+
two_pto
;
assert_eq
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
Initial
)
Some
(
initial_pto2
)
)
;
assert_eq
!
(
lr
.
pto_time
(
PacketNumberSpace
:
:
ApplicationData
)
Some
(
app_pto
)
)
;
let
now
=
app_pto
;
let
_lost
=
lr
.
timeout
(
now
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_some
(
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_some
(
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
Initial
)
)
;
assert
!
(
!
profile
.
should_probe
(
PacketNumberSpace
:
:
Handshake
)
)
;
assert
!
(
profile
.
should_probe
(
PacketNumberSpace
:
:
ApplicationData
)
)
;
assert_eq
!
(
2
MAX_PTO_PACKET_COUNT
)
;
let
profile
=
lr
.
send_profile
(
now
)
;
assert
!
(
profile
.
pto
.
is_none
(
)
)
;
}
fn
assert_no_handshake_last_ack_eliciting
(
lr
:
&
Fixture
)
{
assert
!
(
lr
.
spaces
.
get
(
PacketNumberSpace
:
:
Handshake
)
.
and_then
(
|
s
|
s
.
last_ack_eliciting
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
maybe_prime_handshake_pto_no_pto_state
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
assert
!
(
lr
.
pto_state
.
is_none
(
)
)
;
lr
.
maybe_prime_handshake_pto
(
now
(
)
)
;
assert_no_handshake_last_ack_eliciting
(
&
lr
)
;
}
#
[
test
]
fn
maybe_prime_handshake_pto_wrong_space
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
let
probe_set
=
PacketNumberSpaceSet
:
:
only
(
PacketNumberSpace
:
:
Handshake
)
;
lr
.
pto_state
=
Some
(
PtoState
:
:
new
(
PacketNumberSpace
:
:
Handshake
probe_set
)
)
;
lr
.
maybe_prime_handshake_pto
(
now
(
)
)
;
assert_no_handshake_last_ack_eliciting
(
&
lr
)
;
}
#
[
test
]
fn
maybe_prime_handshake_pto_no_handshake_space
(
)
{
let
mut
lr
=
Fixture
:
:
default
(
)
;
let
probe_set
=
PacketNumberSpaceSet
:
:
only
(
PacketNumberSpace
:
:
Initial
)
;
lr
.
pto_state
=
Some
(
PtoState
:
:
new
(
PacketNumberSpace
:
:
Initial
probe_set
)
)
;
lr
.
spaces
.
get_mut
(
PacketNumberSpace
:
:
Initial
)
.
unwrap
(
)
.
largest_acked
=
Some
(
0
)
;
lr
.
spaces
.
drop_space
(
PacketNumberSpace
:
:
Handshake
)
;
lr
.
maybe_prime_handshake_pto
(
now
(
)
)
;
assert
!
(
lr
.
spaces
.
get
(
PacketNumberSpace
:
:
Handshake
)
.
is_none
(
)
)
;
}
}
