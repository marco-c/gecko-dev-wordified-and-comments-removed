use
std
:
:
{
collections
:
:
BTreeMap
ops
:
:
RangeInclusive
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
IpTosEcn
;
use
crate
:
:
{
packet
:
:
{
PacketNumber
PacketType
}
recovery
:
:
RecoveryToken
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
SentPacket
{
pt
:
PacketType
pn
:
PacketNumber
ecn_mark
:
IpTosEcn
ack_eliciting
:
bool
time_sent
:
Instant
primary_path
:
bool
tokens
:
Vec
<
RecoveryToken
>
time_declared_lost
:
Option
<
Instant
>
pto
:
bool
len
:
usize
}
impl
SentPacket
{
#
[
must_use
]
pub
const
fn
new
(
pt
:
PacketType
pn
:
PacketNumber
ecn_mark
:
IpTosEcn
time_sent
:
Instant
ack_eliciting
:
bool
tokens
:
Vec
<
RecoveryToken
>
len
:
usize
)
-
>
Self
{
Self
{
pt
pn
ecn_mark
time_sent
ack_eliciting
primary_path
:
true
tokens
time_declared_lost
:
None
pto
:
false
len
}
}
#
[
must_use
]
pub
const
fn
packet_type
(
&
self
)
-
>
PacketType
{
self
.
pt
}
#
[
must_use
]
pub
const
fn
pn
(
&
self
)
-
>
PacketNumber
{
self
.
pn
}
#
[
must_use
]
pub
const
fn
ecn_mark
(
&
self
)
-
>
IpTosEcn
{
self
.
ecn_mark
}
#
[
must_use
]
pub
const
fn
time_sent
(
&
self
)
-
>
Instant
{
self
.
time_sent
}
#
[
must_use
]
pub
const
fn
ack_eliciting
(
&
self
)
-
>
bool
{
self
.
ack_eliciting
}
#
[
must_use
]
pub
const
fn
on_primary_path
(
&
self
)
-
>
bool
{
self
.
primary_path
}
#
[
allow
(
clippy
:
:
len_without_is_empty
)
]
#
[
must_use
]
pub
const
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
#
[
must_use
]
pub
fn
tokens
(
&
self
)
-
>
&
[
RecoveryToken
]
{
&
self
.
tokens
}
pub
fn
clear_primary_path
(
&
mut
self
)
{
self
.
primary_path
=
false
;
}
pub
fn
track_padding
(
&
mut
self
padding
:
usize
)
{
debug_assert_eq
!
(
self
.
pt
PacketType
:
:
Initial
)
;
self
.
len
+
=
padding
;
}
#
[
must_use
]
pub
const
fn
lost
(
&
self
)
-
>
bool
{
self
.
time_declared_lost
.
is_some
(
)
}
#
[
must_use
]
pub
const
fn
cc_outstanding
(
&
self
)
-
>
bool
{
self
.
ack_eliciting
(
)
&
&
self
.
on_primary_path
(
)
&
&
!
self
.
lost
(
)
}
#
[
must_use
]
pub
const
fn
cc_in_flight
(
&
self
)
-
>
bool
{
self
.
ack_eliciting
(
)
&
&
self
.
on_primary_path
(
)
}
pub
fn
declare_lost
(
&
mut
self
now
:
Instant
)
-
>
bool
{
if
self
.
lost
(
)
{
false
}
else
{
self
.
time_declared_lost
=
Some
(
now
)
;
true
}
}
#
[
must_use
]
pub
fn
expired
(
&
self
now
:
Instant
expiration_period
:
Duration
)
-
>
bool
{
self
.
time_declared_lost
.
is_some_and
(
|
loss_time
|
(
loss_time
+
expiration_period
)
<
=
now
)
}
#
[
must_use
]
pub
const
fn
pto_fired
(
&
self
)
-
>
bool
{
self
.
pto
}
#
[
must_use
]
pub
fn
pto
(
&
mut
self
)
-
>
bool
{
if
self
.
pto
|
|
self
.
lost
(
)
{
false
}
else
{
self
.
pto
=
true
;
true
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
SentPackets
{
packets
:
BTreeMap
<
u64
SentPacket
>
}
impl
SentPackets
{
#
[
allow
(
clippy
:
:
len_without_is_empty
)
]
#
[
must_use
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
packets
.
len
(
)
}
pub
fn
track
(
&
mut
self
packet
:
SentPacket
)
{
self
.
packets
.
insert
(
packet
.
pn
packet
)
;
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
SentPacket
>
{
self
.
packets
.
values_mut
(
)
}
pub
fn
take_ranges
<
R
>
(
&
mut
self
acked_ranges
:
R
)
-
>
Vec
<
SentPacket
>
where
R
:
IntoIterator
<
Item
=
RangeInclusive
<
PacketNumber
>
>
R
:
:
IntoIter
:
ExactSizeIterator
{
let
mut
result
=
Vec
:
:
new
(
)
;
let
mut
packets
=
std
:
:
mem
:
:
take
(
&
mut
self
.
packets
)
;
let
mut
previous_range_start
:
Option
<
PacketNumber
>
=
None
;
for
range
in
acked_ranges
{
let
after_acked_range
=
packets
.
split_off
(
&
(
*
range
.
end
(
)
+
1
)
)
;
let
acked_range
=
packets
.
split_off
(
range
.
start
(
)
)
;
debug_assert
!
(
previous_range_start
.
map_or
(
true
|
s
|
s
>
*
range
.
end
(
)
)
)
;
previous_range_start
=
Some
(
*
range
.
start
(
)
)
;
if
self
.
packets
.
is_empty
(
)
{
self
.
packets
=
after_acked_range
;
}
else
{
self
.
packets
.
extend
(
after_acked_range
)
;
}
result
.
extend
(
acked_range
.
into_values
(
)
.
rev
(
)
)
;
}
self
.
packets
.
extend
(
packets
)
;
result
}
pub
fn
drain_all
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
SentPacket
>
{
std
:
:
mem
:
:
take
(
&
mut
self
.
packets
)
.
into_values
(
)
}
pub
fn
remove_expired
(
&
mut
self
now
:
Instant
cd
:
Duration
)
-
>
usize
{
let
mut
it
=
self
.
packets
.
iter
(
)
;
if
it
.
next
(
)
.
is_some_and
(
|
(
_
p
)
|
p
.
expired
(
now
cd
)
)
{
let
to_remove
=
if
let
Some
(
first_keep
)
=
it
.
find_map
(
|
(
i
p
)
|
if
p
.
expired
(
now
cd
)
{
None
}
else
{
Some
(
*
i
)
}
)
{
let
keep
=
self
.
packets
.
split_off
(
&
first_keep
)
;
std
:
:
mem
:
:
replace
(
&
mut
self
.
packets
keep
)
}
else
{
std
:
:
mem
:
:
take
(
&
mut
self
.
packets
)
}
;
to_remove
.
into_values
(
)
.
filter
(
SentPacket
:
:
ack_eliciting
)
.
count
(
)
}
else
{
0
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
{
cell
:
:
OnceCell
convert
:
:
TryFrom
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
IpTosEcn
;
use
super
:
:
{
SentPacket
SentPackets
}
;
use
crate
:
:
packet
:
:
{
PacketNumber
PacketType
}
;
const
PACKET_GAP
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
fn
start_time
(
)
-
>
Instant
{
thread_local
!
(
static
STARTING_TIME
:
OnceCell
<
Instant
>
=
const
{
OnceCell
:
:
new
(
)
}
)
;
STARTING_TIME
.
with
(
|
t
|
*
t
.
get_or_init
(
Instant
:
:
now
)
)
}
fn
pkt
(
n
:
u32
)
-
>
SentPacket
{
SentPacket
:
:
new
(
PacketType
:
:
Short
PacketNumber
:
:
from
(
n
)
IpTosEcn
:
:
default
(
)
start_time
(
)
+
(
PACKET_GAP
*
n
)
true
Vec
:
:
new
(
)
100
)
}
fn
pkts
(
)
-
>
SentPackets
{
let
mut
pkts
=
SentPackets
:
:
default
(
)
;
pkts
.
track
(
pkt
(
0
)
)
;
pkts
.
track
(
pkt
(
1
)
)
;
pkts
.
track
(
pkt
(
2
)
)
;
assert_eq
!
(
pkts
.
len
(
)
3
)
;
pkts
}
trait
HasPacketNumber
{
fn
pn
(
&
self
)
-
>
PacketNumber
;
}
impl
HasPacketNumber
for
SentPacket
{
fn
pn
(
&
self
)
-
>
PacketNumber
{
self
.
pn
}
}
impl
HasPacketNumber
for
&
'
_
SentPacket
{
fn
pn
(
&
self
)
-
>
PacketNumber
{
self
.
pn
}
}
impl
HasPacketNumber
for
&
'
_
mut
SentPacket
{
fn
pn
(
&
self
)
-
>
PacketNumber
{
self
.
pn
}
}
fn
remove_one
(
pkts
:
&
mut
SentPackets
idx
:
PacketNumber
)
{
assert_eq
!
(
pkts
.
len
(
)
3
)
;
let
store
=
pkts
.
take_ranges
(
[
idx
.
.
=
idx
]
)
;
let
mut
it
=
store
.
into_iter
(
)
;
assert_eq
!
(
idx
it
.
next
(
)
.
unwrap
(
)
.
pn
(
)
)
;
assert
!
(
it
.
next
(
)
.
is_none
(
)
)
;
std
:
:
mem
:
:
drop
(
it
)
;
assert_eq
!
(
pkts
.
len
(
)
2
)
;
}
fn
assert_zero_and_two
<
'
a
'
b
:
'
a
>
(
mut
it
:
impl
Iterator
<
Item
=
impl
HasPacketNumber
+
'
b
>
+
'
a
)
{
assert_eq
!
(
it
.
next
(
)
.
unwrap
(
)
.
pn
(
)
0
)
;
assert_eq
!
(
it
.
next
(
)
.
unwrap
(
)
.
pn
(
)
2
)
;
assert
!
(
it
.
next
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
iterate_skipped
(
)
{
let
mut
pkts
=
pkts
(
)
;
for
(
i
p
)
in
pkts
.
packets
.
values
(
)
.
enumerate
(
)
{
assert_eq
!
(
i
usize
:
:
try_from
(
p
.
pn
)
.
unwrap
(
)
)
;
}
remove_one
(
&
mut
pkts
1
)
;
assert_zero_and_two
(
pkts
.
iter_mut
(
)
)
;
{
let
store
=
pkts
.
take_ranges
(
[
0
.
.
=
2
]
)
;
let
mut
it
=
store
.
into_iter
(
)
;
assert_eq
!
(
it
.
next
(
)
.
unwrap
(
)
.
pn
(
)
2
)
;
assert_eq
!
(
it
.
next
(
)
.
unwrap
(
)
.
pn
(
)
0
)
;
assert
!
(
it
.
next
(
)
.
is_none
(
)
)
;
}
;
assert_eq
!
(
pkts
.
packets
.
len
(
)
0
)
;
assert_eq
!
(
pkts
.
len
(
)
0
)
;
}
#
[
test
]
fn
drain
(
)
{
let
mut
pkts
=
pkts
(
)
;
remove_one
(
&
mut
pkts
1
)
;
assert_zero_and_two
(
pkts
.
drain_all
(
)
)
;
assert_eq
!
(
pkts
.
len
(
)
0
)
;
}
#
[
test
]
fn
remove_expired
(
)
{
let
mut
pkts
=
pkts
(
)
;
remove_one
(
&
mut
pkts
0
)
;
for
p
in
pkts
.
iter_mut
(
)
{
p
.
declare_lost
(
p
.
time_sent
)
;
}
let
count
=
pkts
.
remove_expired
(
start_time
(
)
+
PACKET_GAP
Duration
:
:
new
(
0
0
)
)
;
assert_eq
!
(
count
1
)
;
assert_eq
!
(
pkts
.
len
(
)
1
)
;
}
#
[
test
]
fn
first_skipped_ok
(
)
{
let
mut
pkts
=
SentPackets
:
:
default
(
)
;
pkts
.
track
(
pkt
(
4
)
)
;
assert_eq
!
(
pkts
.
len
(
)
1
)
;
}
#
[
test
]
fn
ignore_unknown
(
)
{
let
mut
pkts
=
SentPackets
:
:
default
(
)
;
pkts
.
track
(
pkt
(
0
)
)
;
assert
!
(
pkts
.
take_ranges
(
[
1
.
.
=
1
]
)
.
is_empty
(
)
)
;
}
}
