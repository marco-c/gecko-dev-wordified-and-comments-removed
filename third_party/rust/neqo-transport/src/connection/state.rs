use
std
:
:
{
cmp
:
:
min
rc
:
:
Rc
time
:
:
Instant
}
;
use
neqo_common
:
:
{
Buffer
Encoder
}
;
use
crate
:
:
{
frame
:
:
{
FrameEncoder
as
_
FrameType
}
packet
path
:
:
PathRef
recovery
CloseReason
Error
}
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
State
{
Init
WaitInitial
WaitVersion
Handshaking
Connected
Confirmed
Closing
{
error
:
CloseReason
timeout
:
Instant
}
Draining
{
error
:
CloseReason
timeout
:
Instant
}
Closed
(
CloseReason
)
}
impl
State
{
#
[
must_use
]
pub
const
fn
connected
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Connected
|
Self
:
:
Confirmed
)
}
#
[
must_use
]
pub
const
fn
closed
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Closing
{
.
.
}
|
Self
:
:
Draining
{
.
.
}
|
Self
:
:
Closed
(
_
)
)
}
#
[
must_use
]
pub
const
fn
error
(
&
self
)
-
>
Option
<
&
CloseReason
>
{
if
let
Self
:
:
Closing
{
error
.
.
}
|
Self
:
:
Draining
{
error
.
.
}
|
Self
:
:
Closed
(
error
)
=
self
{
Some
(
error
)
}
else
{
None
}
}
#
[
must_use
]
pub
const
fn
closing
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Closing
{
.
.
}
|
Self
:
:
Draining
{
.
.
}
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ClosingFrame
{
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
reason_phrase
:
Vec
<
u8
>
}
impl
ClosingFrame
{
fn
new
(
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
-
>
Self
{
let
reason_phrase
=
message
.
as_ref
(
)
.
as_bytes
(
)
.
to_vec
(
)
;
Self
{
path
error
frame_type
reason_phrase
}
}
pub
const
fn
path
(
&
self
)
-
>
&
PathRef
{
&
self
.
path
}
pub
fn
sanitize
(
&
self
)
-
>
Option
<
Self
>
{
if
let
CloseReason
:
:
Application
(
_
)
=
self
.
error
{
Some
(
Self
{
path
:
Rc
:
:
clone
(
&
self
.
path
)
error
:
CloseReason
:
:
Transport
(
Error
:
:
Application
)
frame_type
:
FrameType
:
:
Padding
reason_phrase
:
Vec
:
:
new
(
)
}
)
}
else
{
None
}
}
pub
const
MIN_LENGTH
:
usize
=
1
+
8
+
8
+
2
+
8
;
pub
fn
write_frame
<
B
:
Buffer
>
(
&
self
builder
:
&
mut
packet
:
:
Builder
<
B
>
)
{
if
builder
.
remaining
(
)
<
Self
:
:
MIN_LENGTH
{
return
;
}
let
available
=
min
(
256
builder
.
remaining
(
)
)
;
let
reason
=
if
available
<
Encoder
:
:
vvec_len
(
self
.
reason_phrase
.
len
(
)
)
{
&
self
.
reason_phrase
[
.
.
available
-
2
]
}
else
{
&
self
.
reason_phrase
}
;
match
&
self
.
error
{
CloseReason
:
:
Transport
(
e
)
=
>
{
builder
.
encode_frame
(
FrameType
:
:
ConnectionCloseTransport
|
b
|
{
b
.
encode_varint
(
e
.
code
(
)
)
;
b
.
encode_varint
(
self
.
frame_type
)
;
b
.
encode_vvec
(
reason
)
;
}
)
;
}
CloseReason
:
:
Application
(
code
)
=
>
{
builder
.
encode_frame
(
FrameType
:
:
ConnectionCloseApplication
|
b
|
{
b
.
encode_varint
(
*
code
)
;
b
.
encode_vvec
(
reason
)
;
}
)
;
}
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
StateSignaling
{
Idle
HandshakeDone
Closing
(
ClosingFrame
)
Draining
(
ClosingFrame
)
CloseSent
(
Option
<
ClosingFrame
>
)
Reset
}
impl
StateSignaling
{
pub
fn
handshake_done
(
&
mut
self
)
{
if
!
matches
!
(
self
Self
:
:
Idle
)
{
return
;
}
*
self
=
Self
:
:
HandshakeDone
;
}
pub
fn
write_done
<
B
:
Buffer
>
(
&
mut
self
builder
:
&
mut
packet
:
:
Builder
<
B
>
)
-
>
Option
<
recovery
:
:
Token
>
{
(
matches
!
(
self
Self
:
:
HandshakeDone
)
&
&
builder
.
remaining
(
)
>
=
1
)
.
then
(
|
|
{
*
self
=
Self
:
:
Idle
;
builder
.
encode_frame
(
FrameType
:
:
HandshakeDone
|
_
|
{
}
)
;
recovery
:
:
Token
:
:
HandshakeDone
}
)
}
pub
fn
close
<
A
:
AsRef
<
str
>
>
(
&
mut
self
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
message
:
A
)
{
if
!
matches
!
(
self
Self
:
:
Reset
)
{
*
self
=
Self
:
:
Closing
(
ClosingFrame
:
:
new
(
path
error
frame_type
message
)
)
;
}
}
pub
fn
drain
<
A
:
AsRef
<
str
>
>
(
&
mut
self
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
message
:
A
)
{
if
!
matches
!
(
self
Self
:
:
Reset
)
{
*
self
=
Self
:
:
Draining
(
ClosingFrame
:
:
new
(
path
error
frame_type
message
)
)
;
}
}
pub
fn
close_frame
(
&
mut
self
)
-
>
Option
<
ClosingFrame
>
{
match
self
{
Self
:
:
Closing
(
frame
)
=
>
{
let
res
=
Some
(
frame
.
clone
(
)
)
;
*
self
=
Self
:
:
CloseSent
(
Some
(
frame
.
clone
(
)
)
)
;
res
}
Self
:
:
Draining
(
frame
)
=
>
{
let
res
=
Some
(
frame
.
clone
(
)
)
;
*
self
=
Self
:
:
CloseSent
(
None
)
;
res
}
_
=
>
None
}
}
pub
fn
send_close
(
&
mut
self
)
{
if
let
Self
:
:
CloseSent
(
Some
(
frame
)
)
=
self
{
*
self
=
Self
:
:
Closing
(
frame
.
clone
(
)
)
;
}
}
pub
fn
reset
(
&
mut
self
)
{
*
self
=
Self
:
:
Reset
;
}
}
