use
std
:
:
{
cmp
:
:
{
min
Ordering
}
mem
rc
:
:
Rc
time
:
:
Instant
}
;
use
neqo_common
:
:
Encoder
;
use
crate
:
:
{
frame
:
:
{
FrameType
FRAME_TYPE_CONNECTION_CLOSE_APPLICATION
FRAME_TYPE_CONNECTION_CLOSE_TRANSPORT
FRAME_TYPE_HANDSHAKE_DONE
}
packet
:
:
PacketBuilder
path
:
:
PathRef
recovery
:
:
RecoveryToken
CloseReason
Error
}
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
State
{
Init
WaitInitial
WaitVersion
Handshaking
Connected
Confirmed
Closing
{
error
:
CloseReason
timeout
:
Instant
}
Draining
{
error
:
CloseReason
timeout
:
Instant
}
Closed
(
CloseReason
)
}
impl
State
{
#
[
must_use
]
pub
const
fn
connected
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Connected
|
Self
:
:
Confirmed
)
}
#
[
must_use
]
pub
const
fn
closed
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Closing
{
.
.
}
|
Self
:
:
Draining
{
.
.
}
|
Self
:
:
Closed
(
_
)
)
}
#
[
must_use
]
pub
const
fn
error
(
&
self
)
-
>
Option
<
&
CloseReason
>
{
if
let
Self
:
:
Closing
{
error
.
.
}
|
Self
:
:
Draining
{
error
.
.
}
|
Self
:
:
Closed
(
error
)
=
self
{
Some
(
error
)
}
else
{
None
}
}
#
[
must_use
]
pub
const
fn
closing
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Closing
{
.
.
}
|
Self
:
:
Draining
{
.
.
}
)
}
}
impl
PartialOrd
for
State
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
State
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
if
mem
:
:
discriminant
(
self
)
=
=
mem
:
:
discriminant
(
other
)
{
return
Ordering
:
:
Equal
;
}
match
(
self
other
)
{
(
Self
:
:
Init
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Init
)
=
>
Ordering
:
:
Greater
(
Self
:
:
WaitInitial
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
WaitInitial
)
=
>
Ordering
:
:
Greater
(
Self
:
:
WaitVersion
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
WaitVersion
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Handshaking
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Handshaking
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Connected
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Connected
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Confirmed
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Confirmed
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Closing
{
.
.
}
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Closing
{
.
.
}
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Draining
{
.
.
}
_
)
=
>
Ordering
:
:
Less
(
_
Self
:
:
Draining
{
.
.
}
)
=
>
Ordering
:
:
Greater
(
Self
:
:
Closed
(
_
)
_
)
=
>
unreachable
!
(
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ClosingFrame
{
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
reason_phrase
:
Vec
<
u8
>
}
impl
ClosingFrame
{
fn
new
(
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
-
>
Self
{
let
reason_phrase
=
message
.
as_ref
(
)
.
as_bytes
(
)
.
to_vec
(
)
;
Self
{
path
error
frame_type
reason_phrase
}
}
pub
const
fn
path
(
&
self
)
-
>
&
PathRef
{
&
self
.
path
}
pub
fn
sanitize
(
&
self
)
-
>
Option
<
Self
>
{
if
let
CloseReason
:
:
Application
(
_
)
=
self
.
error
{
Some
(
Self
{
path
:
Rc
:
:
clone
(
&
self
.
path
)
error
:
CloseReason
:
:
Transport
(
Error
:
:
ApplicationError
)
frame_type
:
0
reason_phrase
:
Vec
:
:
new
(
)
}
)
}
else
{
None
}
}
pub
const
MIN_LENGTH
:
usize
=
1
+
8
+
8
+
2
+
8
;
pub
fn
write_frame
(
&
self
builder
:
&
mut
PacketBuilder
)
{
if
builder
.
remaining
(
)
<
Self
:
:
MIN_LENGTH
{
return
;
}
match
&
self
.
error
{
CloseReason
:
:
Transport
(
e
)
=
>
{
builder
.
encode_varint
(
FRAME_TYPE_CONNECTION_CLOSE_TRANSPORT
)
;
builder
.
encode_varint
(
e
.
code
(
)
)
;
builder
.
encode_varint
(
self
.
frame_type
)
;
}
CloseReason
:
:
Application
(
code
)
=
>
{
builder
.
encode_varint
(
FRAME_TYPE_CONNECTION_CLOSE_APPLICATION
)
;
builder
.
encode_varint
(
*
code
)
;
}
}
let
available
=
min
(
256
builder
.
remaining
(
)
)
;
let
reason
=
if
available
<
Encoder
:
:
vvec_len
(
self
.
reason_phrase
.
len
(
)
)
{
&
self
.
reason_phrase
[
.
.
available
-
2
]
}
else
{
&
self
.
reason_phrase
}
;
builder
.
encode_vvec
(
reason
)
;
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
StateSignaling
{
Idle
HandshakeDone
Closing
(
ClosingFrame
)
Draining
(
ClosingFrame
)
CloseSent
(
Option
<
ClosingFrame
>
)
Reset
}
impl
StateSignaling
{
pub
fn
handshake_done
(
&
mut
self
)
{
if
!
matches
!
(
self
Self
:
:
Idle
)
{
return
;
}
*
self
=
Self
:
:
HandshakeDone
;
}
pub
fn
write_done
(
&
mut
self
builder
:
&
mut
PacketBuilder
)
-
>
Option
<
RecoveryToken
>
{
if
matches
!
(
self
Self
:
:
HandshakeDone
)
&
&
builder
.
remaining
(
)
>
=
1
{
*
self
=
Self
:
:
Idle
;
builder
.
encode_varint
(
FRAME_TYPE_HANDSHAKE_DONE
)
;
Some
(
RecoveryToken
:
:
HandshakeDone
)
}
else
{
None
}
}
pub
fn
close
(
&
mut
self
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
{
if
!
matches
!
(
self
Self
:
:
Reset
)
{
*
self
=
Self
:
:
Closing
(
ClosingFrame
:
:
new
(
path
error
frame_type
message
)
)
;
}
}
pub
fn
drain
(
&
mut
self
path
:
PathRef
error
:
CloseReason
frame_type
:
FrameType
message
:
impl
AsRef
<
str
>
)
{
if
!
matches
!
(
self
Self
:
:
Reset
)
{
*
self
=
Self
:
:
Draining
(
ClosingFrame
:
:
new
(
path
error
frame_type
message
)
)
;
}
}
pub
fn
close_frame
(
&
mut
self
)
-
>
Option
<
ClosingFrame
>
{
match
self
{
Self
:
:
Closing
(
frame
)
=
>
{
let
res
=
Some
(
frame
.
clone
(
)
)
;
*
self
=
Self
:
:
CloseSent
(
Some
(
frame
.
clone
(
)
)
)
;
res
}
Self
:
:
Draining
(
frame
)
=
>
{
let
res
=
Some
(
frame
.
clone
(
)
)
;
*
self
=
Self
:
:
CloseSent
(
None
)
;
res
}
_
=
>
None
}
}
pub
fn
send_close
(
&
mut
self
)
{
if
let
Self
:
:
CloseSent
(
Some
(
frame
)
)
=
self
{
*
self
=
Self
:
:
Closing
(
frame
.
clone
(
)
)
;
}
}
pub
fn
reset
(
&
mut
self
)
{
*
self
=
Self
:
:
Reset
;
}
}
