use
neqo_common
:
:
{
qdebug
Datagram
}
;
use
test_fixture
:
:
{
assertions
:
:
{
is_handshake
is_initial
}
now
split_datagram
}
;
use
super
:
:
{
super
:
:
{
super
:
:
{
CloseReason
ERROR_AEAD_LIMIT_REACHED
}
Connection
ConnectionParameters
Error
Output
State
StreamType
}
connect
connect_force_idle
default_client
default_server
maybe_authenticate
send_and_receive
send_something
AT_LEAST_PTO
}
;
use
crate
:
:
{
crypto
:
:
{
OVERWRITE_INVOCATIONS
UPDATE_WRITE_KEYS_AT
}
packet
MIN_INITIAL_PACKET_SIZE
}
;
fn
check_discarded
(
peer
:
&
mut
Connection
pkt
:
&
Datagram
response
:
bool
expected_drops
:
usize
expected_dups
:
usize
)
{
drop
(
peer
.
process_output
(
now
(
)
)
)
;
let
before
=
peer
.
stats
(
)
;
let
out
=
peer
.
process
(
Some
(
pkt
.
clone
(
)
)
now
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
response
)
;
let
after
=
peer
.
stats
(
)
;
assert_eq
!
(
expected_drops
after
.
dropped_rx
-
before
.
dropped_rx
)
;
assert_eq
!
(
expected_dups
after
.
dups_rx
-
before
.
dups_rx
)
;
}
fn
assert_update_blocked
(
c
:
&
mut
Connection
)
{
assert_eq
!
(
c
.
initiate_key_update
(
)
.
unwrap_err
(
)
Error
:
:
KeyUpdateBlocked
)
;
}
fn
overwrite_invocations
(
n
:
packet
:
:
Number
)
{
OVERWRITE_INVOCATIONS
.
with
(
|
v
|
{
*
v
.
borrow_mut
(
)
=
Some
(
n
)
;
}
)
;
}
#
[
test
]
fn
discarded_initial_keys
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
c_hs_1
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
c_hs_2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
c_hs_1
.
is_some
(
)
&
&
c_hs_2
.
is_some
(
)
)
;
assert_eq
!
(
c_hs_1
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
assert_eq
!
(
c_hs_2
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
c_hs_1
.
clone
(
)
.
unwrap
(
)
now
(
)
)
;
let
s_hs_1
=
server
.
process
(
c_hs_2
now
(
)
)
.
dgram
(
)
;
assert
!
(
s_hs_1
.
is_some
(
)
)
;
let
s_hs_2
=
server
.
process_output
(
now
(
)
)
.
dgram
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
client
.
process_input
(
s_hs_1
.
clone
(
)
.
unwrap
(
)
now
(
)
)
;
let
out
=
client
.
process
(
s_hs_2
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
(
s_init
_s_hs
)
=
split_datagram
(
&
s_hs_1
.
unwrap
(
)
)
;
check_discarded
(
&
mut
client
&
s_init
true
1
0
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
let
(
c_init
_c_hs
)
=
split_datagram
(
c_hs_1
.
as_ref
(
)
.
unwrap
(
)
)
;
check_discarded
(
&
mut
server
&
c_init
false
0
1
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
c_fin
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
c_fin
.
is_some
(
)
)
;
let
s_done
=
server
.
process
(
c_fin
now
(
)
)
.
dgram
(
)
;
assert
!
(
s_done
.
is_some
(
)
)
;
check_discarded
(
&
mut
server
&
c_init
false
1
0
)
;
}
#
[
test
]
fn
key_update_client
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_update_blocked
(
&
mut
client
)
;
assert_eq
!
(
ConnectionParameters
:
:
DEFAULT_IDLE_TIMEOUT
client
.
process_output
(
now
)
.
callback
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
assert
!
(
send_and_receive
(
&
mut
client
&
mut
server
now
)
.
is_some
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
res
=
server
.
process_output
(
now
)
;
if
let
Output
:
:
Callback
(
t
)
=
res
{
assert
!
(
t
<
ConnectionParameters
:
:
DEFAULT_IDLE_TIMEOUT
)
;
}
else
{
panic
!
(
"
server
should
now
be
waiting
to
clear
keys
"
)
;
}
assert_update_blocked
(
&
mut
client
)
;
assert_update_blocked
(
&
mut
server
)
;
now
+
=
AT_LEAST_PTO
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
drop
(
server
.
process_output
(
now
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
assert_update_blocked
(
&
mut
server
)
;
let
dgram
=
send_and_receive
(
&
mut
client
&
mut
server
now
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
res
=
client
.
process
(
dgram
now
)
;
if
let
Output
:
:
Callback
(
t
)
=
res
{
assert
!
(
t
<
ConnectionParameters
:
:
DEFAULT_IDLE_TIMEOUT
)
;
}
else
{
panic
!
(
"
client
should
now
be
waiting
to
clear
keys
"
)
;
}
assert_update_blocked
(
&
mut
client
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
assert_update_blocked
(
&
mut
server
)
;
now
+
=
AT_LEAST_PTO
;
drop
(
client
.
process_output
(
now
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
}
#
[
test
]
fn
key_update_consecutive
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
drop
(
send_something
(
&
mut
server
now
)
)
;
let
dgram
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
if
let
Output
:
:
Callback
(
_
)
=
server
.
process
(
dgram
now
)
{
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
drop
(
server
.
process_output
(
now
+
AT_LEAST_PTO
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
}
else
{
panic
!
(
"
server
should
have
a
timer
set
"
)
;
}
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
5
)
Some
(
4
)
)
)
;
let
dgram
=
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
;
check_discarded
(
&
mut
client
&
dgram
false
1
0
)
;
}
#
[
test
]
fn
key_update_before_confirmed
(
)
{
let
mut
client
=
default_client
(
)
;
assert_update_blocked
(
&
mut
client
)
;
let
mut
server
=
default_server
(
)
;
assert_update_blocked
(
&
mut
server
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
&
&
dgram2
.
is_some
(
)
)
;
assert_update_blocked
(
&
mut
client
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
dgram
=
server
.
process
(
dgram2
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_update_blocked
(
&
mut
server
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_update_blocked
(
&
mut
client
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_update_blocked
(
&
mut
server
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert_update_blocked
(
&
mut
client
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
assert_update_blocked
(
&
mut
client
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_update_blocked
(
&
mut
client
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
exhaust_write_keys
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
overwrite_invocations
(
0
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
client
.
stream_send
(
stream_id
b
"
explode
!
"
)
.
is_ok
(
)
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
CloseReason
:
:
Transport
(
Error
:
:
KeysExhausted
)
)
)
)
;
}
#
[
test
]
fn
exhaust_read_keys
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
dgram
=
send_something
(
&
mut
client
now
(
)
)
;
overwrite_invocations
(
0
)
;
let
dgram
=
server
.
process
(
Some
(
dgram
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
matches
!
(
server
.
state
(
)
State
:
:
Closed
(
CloseReason
:
:
Transport
(
Error
:
:
KeysExhausted
)
)
)
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Draining
{
error
:
CloseReason
:
:
Transport
(
Error
:
:
Peer
(
ERROR_AEAD_LIMIT_REACHED
)
)
.
.
}
)
)
;
}
#
[
test
]
fn
automatic_update_write_keys
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
overwrite_invocations
(
UPDATE_WRITE_KEYS_AT
)
;
drop
(
send_something
(
&
mut
client
now
(
)
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
}
#
[
test
]
fn
automatic_update_write_keys_later
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
overwrite_invocations
(
UPDATE_WRITE_KEYS_AT
+
2
)
;
drop
(
send_something
(
&
mut
client
now
(
)
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
drop
(
send_something
(
&
mut
client
now
(
)
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
}
#
[
test
]
fn
automatic_update_write_keys_blocked
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
client
.
initiate_key_update
(
)
.
unwrap
(
)
;
overwrite_invocations
(
UPDATE_WRITE_KEYS_AT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
client
.
stream_send
(
stream_id
b
"
explode
!
"
)
.
is_ok
(
)
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
CloseReason
:
:
Transport
(
Error
:
:
KeysExhausted
)
)
)
)
;
}
#
[
test
]
fn
initial_handshake_pto_padding
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
now
=
now
(
)
;
let
c_init1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c_init2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c_init1
.
is_some
(
)
&
&
c_init2
.
is_some
(
)
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
c_init1
.
unwrap
(
)
now
)
;
let
s_hs1
=
server
.
process
(
c_init2
now
)
.
dgram
(
)
;
assert
!
(
s_hs1
.
is_some
(
)
)
;
let
s_hs2
=
server
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
s_hs2
.
is_some
(
)
)
;
client
.
process_input
(
s_hs1
.
unwrap
(
)
now
)
;
client
.
process_input
(
s_hs2
.
unwrap
(
)
now
)
;
now
+
=
AT_LEAST_PTO
;
let
mut
pto_dgrams
=
Vec
:
:
new
(
)
;
while
let
Some
(
dgram
)
=
client
.
process_output
(
now
)
.
dgram
(
)
{
pto_dgrams
.
push
(
dgram
)
;
}
assert
!
(
!
pto_dgrams
.
is_empty
(
)
)
;
let
mut
found_coalesced
=
false
;
for
dgram
in
&
pto_dgrams
{
let
(
first
second
)
=
split_datagram
(
dgram
)
;
if
is_initial
(
&
first
false
)
{
assert
!
(
dgram
.
len
(
)
>
=
MIN_INITIAL_PACKET_SIZE
)
;
if
let
Some
(
hs
)
=
&
second
{
found_coalesced
|
=
is_handshake
(
hs
)
;
}
}
}
assert
!
(
found_coalesced
)
;
}
