use
super
:
:
super
:
:
{
Connection
Output
LOCAL_IDLE_TIMEOUT
}
;
use
super
:
:
{
connect
connect_force_idle
default_client
default_server
maybe_authenticate
send_and_receive
send_something
AT_LEAST_PTO
}
;
use
crate
:
:
path
:
:
PATH_MTU_V6
;
use
neqo_common
:
:
{
qdebug
Datagram
}
;
use
test_fixture
:
:
{
self
now
}
;
fn
check_discarded
(
peer
:
&
mut
Connection
pkt
:
Datagram
dropped
:
usize
dups
:
usize
)
{
let
_
=
peer
.
process_output
(
now
(
)
)
;
let
before
=
peer
.
stats
(
)
;
let
out
=
peer
.
process
(
Some
(
pkt
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
after
=
peer
.
stats
(
)
;
assert_eq
!
(
dropped
after
.
dropped_rx
-
before
.
dropped_rx
)
;
assert_eq
!
(
dups
after
.
dups_rx
-
before
.
dups_rx
)
;
}
#
[
test
]
fn
discarded_initial_keys
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
init_pkt_c
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
init_pkt_c
.
is_some
(
)
)
;
assert_eq
!
(
init_pkt_c
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
init_pkt_s
=
server
.
process
(
init_pkt_c
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
init_pkt_s
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
init_pkt_s
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
check_discarded
(
&
mut
client
init_pkt_s
.
unwrap
(
)
1
1
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
check_discarded
(
&
mut
server
init_pkt_c
.
clone
(
)
.
unwrap
(
)
1
1
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
now
(
)
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
check_discarded
(
&
mut
server
init_pkt_c
.
unwrap
(
)
1
0
)
;
}
#
[
test
]
fn
key_update_client
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
3
)
Some
(
3
)
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert_eq
!
(
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
client
.
process
(
None
now
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
assert
!
(
send_and_receive
(
&
mut
client
&
mut
server
now
)
.
is_none
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
res
=
server
.
process
(
None
now
)
;
if
let
Output
:
:
Callback
(
t
)
=
res
{
assert
!
(
t
<
LOCAL_IDLE_TIMEOUT
)
;
}
else
{
panic
!
(
"
server
should
now
be
waiting
to
clear
keys
"
)
;
}
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
_
=
server
.
process
(
None
now
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
send_and_receive
(
&
mut
client
&
mut
server
now
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
res
=
client
.
process
(
dgram
now
)
;
if
let
Output
:
:
Callback
(
t
)
=
res
{
assert
!
(
t
<
LOCAL_IDLE_TIMEOUT
)
;
}
else
{
panic
!
(
"
client
should
now
be
waiting
to
clear
keys
"
)
;
}
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
_
=
client
.
process
(
None
now
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
}
#
[
test
]
fn
key_update_consecutive
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
_
=
send_something
(
&
mut
server
now
)
;
let
dgram
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
client
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
if
let
Output
:
:
Callback
(
_
)
=
server
.
process
(
dgram
now
)
{
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
3
)
)
)
;
let
_
=
server
.
process
(
None
now
+
AT_LEAST_PTO
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
4
)
Some
(
4
)
)
)
;
}
else
{
panic
!
(
"
server
should
have
a
timer
set
"
)
;
}
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
assert_eq
!
(
server
.
get_epochs
(
)
(
Some
(
5
)
Some
(
4
)
)
)
;
let
dgram
=
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
;
check_discarded
(
&
mut
client
dgram
1
0
)
;
}
#
[
test
]
fn
key_update_before_confirmed
(
)
{
let
mut
client
=
default_client
(
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
mut
server
=
default_server
(
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_err
(
)
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_err
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
server
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert
!
(
client
.
initiate_key_update
(
)
.
is_ok
(
)
)
;
}
