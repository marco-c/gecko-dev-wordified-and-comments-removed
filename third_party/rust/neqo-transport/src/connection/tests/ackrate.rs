use
std
:
:
{
mem
time
:
:
Duration
}
;
use
test_fixture
:
:
{
assertions
DEFAULT_ADDR_V4
}
;
use
super
:
:
{
super
:
:
{
ConnectionParameters
ACK_RATIO_SCALE
}
ack_bytes
connect_rtt_idle
default_client
default_server
fill_cwnd
increase_cwnd
induce_persistent_congestion
new_client
new_server
send_something
DEFAULT_RTT
}
;
use
crate
:
:
stream_id
:
:
StreamType
;
#
[
test
]
fn
ack_rate_default
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
_
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
0
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
ack_frequency
0
)
;
}
#
[
test
]
fn
ack_rate_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
_
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
0
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ack_frequency
0
)
;
}
#
[
test
]
fn
ack_rate_exit_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
let
(
mut
pkts
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
pkts
.
remove
(
0
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
ack
=
ack_bytes
(
&
mut
server
stream
pkts
now
)
;
now
+
=
DEFAULT_RTT
/
2
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
0
)
;
let
af
=
client
.
process
(
Some
(
&
ack
)
now
)
.
dgram
(
)
;
assert
!
(
af
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
1
)
;
}
#
[
test
]
fn
ack_rate_persistent_congestion
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
3
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
ack_ratio
(
ACK_RATIO_SCALE
)
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
RTT
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
1
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
(
dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
now
+
=
RTT
/
2
;
mem
:
:
drop
(
ack_bytes
(
&
mut
server
stream
dgrams
now
)
)
;
let
now
=
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
let
af
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
af
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
2
)
;
}
#
[
test
]
fn
ack_rate_client_one_rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
3
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
ack_ratio
(
ACK_RATIO_SCALE
)
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
RTT
)
;
let
d
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
ack
=
server
.
process
(
Some
(
&
d
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
d
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
delay
=
server
.
process
(
Some
(
&
d
)
now
)
.
callback
(
)
;
assert_eq
!
(
delay
RTT
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
1
)
;
}
#
[
test
]
fn
ack_rate_server_half_rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
ack_ratio
(
ACK_RATIO_SCALE
*
2
)
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
RTT
)
;
let
d
=
send_something
(
&
mut
server
now
)
;
now
+
=
RTT
/
2
;
let
ack
=
client
.
process
(
Some
(
&
d
)
now
)
;
assert
!
(
ack
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
d
=
send_something
(
&
mut
server
now
)
;
now
+
=
RTT
/
2
;
let
delay
=
client
.
process
(
Some
(
&
d
)
now
)
.
callback
(
)
;
assert_eq
!
(
delay
RTT
/
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
ack_frequency
1
)
;
}
#
[
test
]
fn
migrate_ack_delay
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
ack_ratio
(
ACK_RATIO_SCALE
)
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
client
.
migrate
(
Some
(
DEFAULT_ADDR_V4
)
Some
(
DEFAULT_ADDR_V4
)
true
now
)
.
unwrap
(
)
;
let
client1
=
send_something
(
&
mut
client
now
)
;
assertions
:
:
assert_v4_path
(
&
client1
true
)
;
let
client2
=
send_something
(
&
mut
client
now
)
;
assertions
:
:
assert_v4_path
(
&
client2
false
)
;
now
+
=
DEFAULT_RTT
/
2
;
server
.
process_input
(
&
client1
now
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
let
now
=
increase_cwnd
(
&
mut
client
&
mut
server
stream
now
)
;
let
(
mut
pkts
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
pkts
.
remove
(
0
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
ack
=
ack_bytes
(
&
mut
server
stream
pkts
now
)
;
let
ad_before
=
client
.
stats
(
)
.
frame_tx
.
ack_frequency
;
let
af
=
client
.
process
(
Some
(
&
ack
)
now
)
.
dgram
(
)
;
assert
!
(
af
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack_frequency
ad_before
+
1
)
;
}
