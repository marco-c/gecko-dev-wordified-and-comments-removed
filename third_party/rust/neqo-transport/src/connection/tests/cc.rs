use
std
:
:
time
:
:
Duration
;
use
neqo_common
:
:
{
qdebug
qinfo
Datagram
Ecn
}
;
use
super
:
:
{
super
:
:
Output
ack_bytes
assert_full_cwnd
connect_rtt_idle
cwnd
cwnd_avail
cwnd_packets
default_client
default_server
fill_cwnd
induce_persistent_congestion
send_something
CLIENT_HANDSHAKE_1RTT_PACKETS
DEFAULT_RTT
POST_HANDSHAKE_CWND
}
;
use
crate
:
:
{
connection
:
:
tests
:
:
{
connect_with_rtt
new_client
new_server
now
}
packet
recovery
:
:
{
ACK_ONLY_SIZE_LIMIT
PACKET_THRESHOLD
}
sender
:
:
PACING_BURST_SIZE
stream_id
:
:
StreamType
CongestionControlAlgorithm
ConnectionParameters
}
;
#
[
test
]
fn
cc_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
assert
!
(
cwnd_avail
(
&
client
)
<
ACK_ONLY_SIZE_LIMIT
)
;
}
#
[
test
]
fn
cc_slow_start_pmtud
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
pmtud
(
true
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
pmtud
(
true
)
)
;
let
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
cwnd
=
cwnd_avail
(
&
client
)
;
let
(
dgrams
_
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
let
dgrams_len
=
dgrams
.
iter
(
)
.
map
(
Datagram
:
:
len
)
.
sum
:
:
<
usize
>
(
)
;
assert_eq
!
(
dgrams_len
cwnd
)
;
assert
!
(
cwnd_avail
(
&
client
)
<
ACK_ONLY_SIZE_LIMIT
)
;
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
)
]
enum
CongestionSignal
{
PacketLoss
EcnCe
}
fn
cc_slow_start_to_cong_avoidance_recovery_period
(
congestion_signal
:
CongestionSignal
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
randomize_first_pn
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
let
flight1_largest
=
packet
:
:
Number
:
:
try_from
(
c_tx_dgrams
.
len
(
)
+
CLIENT_HANDSHAKE_1RTT_PACKETS
)
.
unwrap
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
largest_acknowledged
flight1_largest
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
s_ack
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
largest_acknowledged
flight1_largest
)
;
let
cwnd_before_cong
=
cwnd
(
&
client
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
*
2
client
.
plpmtu
(
)
)
;
let
flight2_largest
=
flight1_largest
+
u64
:
:
try_from
(
c_tx_dgrams
.
len
(
)
)
.
unwrap
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
match
congestion_signal
{
CongestionSignal
:
:
PacketLoss
=
>
{
c_tx_dgrams
.
remove
(
0
)
;
}
CongestionSignal
:
:
EcnCe
=
>
{
c_tx_dgrams
.
last_mut
(
)
.
unwrap
(
)
.
set_tos
(
Ecn
:
:
Ce
.
into
(
)
)
;
}
}
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
largest_acknowledged
flight2_largest
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
s_ack
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
largest_acknowledged
flight2_largest
)
;
assert
!
(
cwnd
(
&
client
)
<
cwnd_before_cong
)
;
}
#
[
test
]
fn
cc_slow_start_to_cong_avoidance_recovery_period_due_to_packet_loss
(
)
{
cc_slow_start_to_cong_avoidance_recovery_period
(
CongestionSignal
:
:
PacketLoss
)
;
}
#
[
test
]
fn
cc_slow_start_to_cong_avoidance_recovery_period_due_to_ecn_ce
(
)
{
cc_slow_start_to_cong_avoidance_recovery_period
(
CongestionSignal
:
:
EcnCe
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_unchanged
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
mut
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
c_tx_dgrams
.
remove
(
0
)
;
let
c_tx_dgrams2
=
c_tx_dgrams
.
split_off
(
5
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
client
.
process_input
(
s_ack
now
)
;
let
cwnd1
=
cwnd
(
&
client
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams2
now
)
;
client
.
process_input
(
s_ack
now
)
;
let
cwnd2
=
cwnd
(
&
client
)
;
assert_eq
!
(
cwnd1
cwnd2
)
;
}
#
[
test
]
fn
single_packet_on_recovery
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
for
_
in
0
.
.
PACKET_THRESHOLD
{
let
_dropped
=
send_something
(
&
mut
client
now
)
;
}
let
delivered
=
send_something
(
&
mut
client
now
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
_
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert
!
(
cwnd_avail
(
&
client
)
<
ACK_ONLY_SIZE_LIMIT
)
;
let
ack
=
server
.
process
(
Some
(
delivered
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
client
.
process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
cwnd_avail
(
&
client
)
0
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
fn
cc_cong_avoidance_recovery_period_to_cong_avoidance
(
cc_algorithm
:
CongestionControlAlgorithm
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
cc_algorithm
(
cc_algorithm
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
cc_algorithm
(
cc_algorithm
)
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
c_tx_dgrams
.
remove
(
0
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
let
cwnd_before_loss
=
cwnd
(
&
client
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
s_ack
now
)
;
let
cwnd_after_loss
=
cwnd
(
&
client
)
;
now
+
=
DEFAULT_RTT
/
2
;
assert
!
(
cwnd_before_loss
>
cwnd_after_loss
)
;
qinfo
!
(
"
moving
to
congestion
avoidance
{
}
"
cwnd
(
&
client
)
)
;
for
i
in
0
.
.
6
{
qinfo
!
(
"
iteration
{
i
}
"
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
qinfo
!
(
"
client
sending
{
}
bytes
into
cwnd
of
{
}
"
c_tx_dgrams
.
iter
(
)
.
map
(
Datagram
:
:
len
)
.
sum
:
:
<
usize
>
(
)
cwnd
(
&
client
)
)
;
now
=
next_now
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
client
.
process_input
(
s_ack
now
)
;
}
assert
!
(
cwnd_before_loss
<
cwnd
(
&
client
)
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_to_cong_avoidance_new_reno
(
)
{
cc_cong_avoidance_recovery_period_to_cong_avoidance
(
CongestionControlAlgorithm
:
:
NewReno
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_to_cong_avoidance_cubic
(
)
{
cc_cong_avoidance_recovery_period_to_cong_avoidance
(
CongestionControlAlgorithm
:
:
Cubic
)
;
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_no_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
drop
(
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_some_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
client
.
process_input
(
s_ack
now
)
;
let
(
_
next_now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
}
#
[
test
]
fn
cc_persistent_congestion_to_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
drop
(
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
)
;
now
=
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
;
client
.
process_input
(
s_ack
now
)
;
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
4
)
;
}
#
[
test
]
fn
ack_are_not_cc
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream
0
)
;
let
(
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
qdebug
!
(
"
[
{
server
}
]
Sending
ack
-
eliciting
"
)
;
let
other_stream
=
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
other_stream
1
)
;
server
.
stream_send
(
other_stream
b
"
dropped
"
)
.
unwrap
(
)
;
let
dropped_packet
=
server
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dropped_packet
.
is_some
(
)
)
;
server
.
stream_send
(
other_stream
b
"
sent
"
)
.
unwrap
(
)
;
let
ack_eliciting_packet
=
server
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
ack_eliciting_packet
.
is_some
(
)
)
;
qdebug
!
(
"
[
{
client
}
]
Process
ack
-
eliciting
"
)
;
let
ack_pkt
=
client
.
process
(
ack_eliciting_packet
now
)
.
dgram
(
)
;
assert
!
(
ack_pkt
.
is_some
(
)
)
;
qdebug
!
(
"
[
{
server
}
]
Handle
ACK
"
)
;
let
prev_ack_count
=
server
.
stats
(
)
.
frame_rx
.
ack
;
server
.
process_input
(
ack_pkt
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ack
prev_ack_count
+
1
)
;
}
#
[
test
]
fn
pace
(
)
{
const
DATA
:
&
[
u8
]
=
&
[
0xcc
;
4_096
]
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
loop
{
let
written
=
client
.
stream_send
(
stream
DATA
)
.
unwrap
(
)
;
if
written
<
DATA
.
len
(
)
{
break
;
}
}
let
mut
count
=
0
;
for
_
in
0
.
.
=
PACING_BURST_SIZE
{
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
gap
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
gap
Duration
:
:
new
(
0
0
)
)
;
for
_
in
(
1
+
PACING_BURST_SIZE
)
.
.
cwnd_packets
(
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
{
match
client
.
process_output
(
now
)
{
Output
:
:
Callback
(
t
)
=
>
assert_eq
!
(
t
gap
)
Output
:
:
Datagram
(
_
)
=
>
{
count
+
=
1
;
break
;
}
Output
:
:
None
=
>
panic
!
(
)
}
now
+
=
gap
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert_eq
!
(
count
cwnd_packets
(
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
)
;
let
fin
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
fin
Duration
:
:
new
(
0
0
)
)
;
assert_ne
!
(
fin
gap
)
;
}
