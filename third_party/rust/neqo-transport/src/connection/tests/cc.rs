use
super
:
:
super
:
:
{
Connection
Output
}
;
use
super
:
:
{
assert_full_cwnd
connect_rtt_idle
cwnd_packets
default_client
default_server
fill_cwnd
send_something
AT_LEAST_PTO
DEFAULT_RTT
FORCE_IDLE_CLIENT_1RTT_PACKETS
POST_HANDSHAKE_CWND
}
;
use
crate
:
:
cc
:
:
{
CWND_MIN
MAX_DATAGRAM_SIZE
}
;
use
crate
:
:
packet
:
:
PacketNumber
;
use
crate
:
:
recovery
:
:
{
ACK_ONLY_SIZE_LIMIT
PACKET_THRESHOLD
}
;
use
crate
:
:
sender
:
:
PACING_BURST_SIZE
;
use
crate
:
:
stats
:
:
MAX_PTO_COUNTS
;
use
crate
:
:
stream_id
:
:
StreamType
;
use
crate
:
:
tracking
:
:
MAX_UNACKED_PKTS
;
use
neqo_common
:
:
{
qdebug
qinfo
qtrace
Datagram
}
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
fn
induce_persistent_congestion
(
client
:
&
mut
Connection
server
:
&
mut
Connection
mut
now
:
Instant
)
-
>
Instant
{
now
+
=
AT_LEAST_PTO
;
let
mut
pto_counts
=
[
0
;
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qtrace
!
(
[
client
]
"
first
PTO
"
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
0
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qtrace
!
(
[
client
]
"
second
PTO
"
)
;
now
+
=
AT_LEAST_PTO
*
2
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
0
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
pto_counts
[
0
]
=
0
;
pto_counts
[
1
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qtrace
!
(
[
client
]
"
third
PTO
"
)
;
now
+
=
AT_LEAST_PTO
*
4
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
0
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
pto_counts
[
1
]
=
0
;
pto_counts
[
2
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
s_tx_dgram
=
ack_bytes
(
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
assert_eq
!
(
client
.
loss_recovery
.
cwnd
(
)
CWND_MIN
)
;
now
}
fn
ack_bytes
<
D
>
(
dest
:
&
mut
Connection
stream
:
u64
in_dgrams
:
D
now
:
Instant
)
-
>
Vec
<
Datagram
>
where
D
:
IntoIterator
<
Item
=
Datagram
>
D
:
:
IntoIter
:
ExactSizeIterator
{
let
mut
srv_buf
=
[
0
;
4_096
]
;
let
in_dgrams
=
in_dgrams
.
into_iter
(
)
;
qdebug
!
(
[
dest
]
"
ack_bytes
{
}
datagrams
"
in_dgrams
.
len
(
)
)
;
for
dgram
in
in_dgrams
{
dest
.
process_input
(
dgram
now
)
;
}
loop
{
let
(
bytes_read
_fin
)
=
dest
.
stream_recv
(
stream
&
mut
srv_buf
)
.
unwrap
(
)
;
qtrace
!
(
[
dest
]
"
ack_bytes
read
{
}
bytes
"
bytes_read
)
;
if
bytes_read
=
=
0
{
break
;
}
}
let
mut
tx_dgrams
=
Vec
:
:
new
(
)
;
while
let
Output
:
:
Datagram
(
dg
)
=
dest
.
process_output
(
now
)
{
tx_dgrams
.
push
(
dg
)
;
}
assert
!
(
(
tx_dgrams
.
len
(
)
=
=
1
)
|
|
(
tx_dgrams
.
len
(
)
=
=
2
)
)
;
tx_dgrams
}
#
[
test
]
fn
cc_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
assert
!
(
client
.
loss_recovery
.
cwnd_avail
(
)
<
ACK_ONLY_SIZE_LIMIT
)
;
}
#
[
test
]
fn
cc_slow_start_to_cong_avoidance_recovery_period
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
let
flight1_largest
=
PacketNumber
:
:
try_from
(
c_tx_dgrams
.
len
(
)
+
FORCE_IDLE_CLIENT_1RTT_PACKETS
)
.
unwrap
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
largest_acknowledged
flight1_largest
)
;
now
+
=
DEFAULT_RTT
/
2
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
largest_acknowledged
flight1_largest
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
*
2
)
;
let
flight2_largest
=
flight1_largest
+
u64
:
:
try_from
(
c_tx_dgrams
.
len
(
)
)
.
unwrap
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
c_tx_dgrams
.
remove
(
0
)
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
largest_acknowledged
flight2_largest
)
;
now
+
=
DEFAULT_RTT
/
2
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
largest_acknowledged
flight2_largest
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_unchanged
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
mut
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
c_tx_dgrams
.
remove
(
0
)
;
let
c_tx_dgrams2
=
c_tx_dgrams
.
split_off
(
5
)
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
let
cwnd1
=
client
.
loss_recovery
.
cwnd
(
)
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams2
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
let
cwnd2
=
client
.
loss_recovery
.
cwnd
(
)
;
assert_eq
!
(
cwnd1
cwnd2
)
;
}
#
[
test
]
fn
single_packet_on_recovery
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
for
_
in
0
.
.
PACKET_THRESHOLD
{
let
_dropped
=
send_something
(
&
mut
client
now
)
;
}
let
delivered
=
send_something
(
&
mut
client
now
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
_
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert
!
(
client
.
loss_recovery
.
cwnd_avail
(
)
<
ACK_ONLY_SIZE_LIMIT
)
;
let
ack
=
server
.
process
(
Some
(
delivered
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
client
.
process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
client
.
loss_recovery
.
cwnd_avail
(
)
0
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_to_cong_avoidance
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
c_tx_dgrams
.
remove
(
0
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
now
+
=
DEFAULT_RTT
/
2
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
now
+
=
DEFAULT_RTT
/
2
;
qinfo
!
(
"
moving
to
congestion
avoidance
{
}
"
client
.
loss_recovery
.
cwnd
(
)
)
;
let
mut
expected_cwnd
=
client
.
loss_recovery
.
cwnd
(
)
;
let
(
mut
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
now
=
next_now
;
for
i
in
0
.
.
5
{
qinfo
!
(
"
iteration
{
}
"
i
)
;
let
c_tx_size
:
usize
=
c_tx_dgrams
.
iter
(
)
.
map
(
|
d
|
d
.
len
(
)
)
.
sum
(
)
;
qinfo
!
(
"
client
sending
{
}
bytes
into
cwnd
of
{
}
"
c_tx_size
client
.
loss_recovery
.
cwnd
(
)
)
;
assert_eq
!
(
c_tx_size
expected_cwnd
)
;
let
mut
next_c_tx_dgrams
:
Vec
<
Datagram
>
=
Vec
:
:
new
(
)
;
let
most
=
c_tx_dgrams
.
len
(
)
-
MAX_UNACKED_PKTS
-
1
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
.
drain
(
.
.
most
)
now
)
;
for
dgram
in
s_tx_dgram
{
assert_eq
!
(
client
.
loss_recovery
.
cwnd
(
)
expected_cwnd
)
;
client
.
process_input
(
dgram
now
)
;
let
(
mut
new_pkts
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
now
=
next_now
;
next_c_tx_dgrams
.
append
(
&
mut
new_pkts
)
;
}
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
assert_eq
!
(
client
.
loss_recovery
.
cwnd
(
)
expected_cwnd
)
;
client
.
process_input
(
dgram
now
)
;
let
(
mut
new_pkts
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
now
=
next_now
;
next_c_tx_dgrams
.
append
(
&
mut
new_pkts
)
;
}
expected_cwnd
+
=
MAX_DATAGRAM_SIZE
;
assert_eq
!
(
client
.
loss_recovery
.
cwnd
(
)
expected_cwnd
)
;
c_tx_dgrams
=
next_c_tx_dgrams
;
}
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_no_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
_
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
now
)
;
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_some_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
let
(
_
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
now
)
;
}
#
[
test
]
fn
cc_persistent_congestion_to_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
_
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
now
=
induce_persistent_congestion
(
&
mut
client
&
mut
server
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
let
s_tx_dgram
=
ack_bytes
(
&
mut
server
0
c_tx_dgrams
now
)
;
for
dgram
in
s_tx_dgram
{
client
.
process_input
(
dgram
now
)
;
}
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
4
)
;
}
#
[
test
]
fn
ack_are_not_cc
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
let
(
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
0
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
qdebug
!
(
[
server
]
"
Sending
ack
-
eliciting
"
)
;
assert_eq
!
(
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
1
)
;
server
.
stream_send
(
1
b
"
dropped
"
)
.
unwrap
(
)
;
let
dropped_packet
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dropped_packet
.
is_some
(
)
)
;
server
.
stream_send
(
1
b
"
sent
"
)
.
unwrap
(
)
;
let
ack_eliciting_packet
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
ack_eliciting_packet
.
is_some
(
)
)
;
qdebug
!
(
[
client
]
"
Process
ack
-
eliciting
"
)
;
let
ack_pkt
=
client
.
process
(
ack_eliciting_packet
now
)
.
dgram
(
)
;
assert
!
(
ack_pkt
.
is_some
(
)
)
;
qdebug
!
(
[
server
]
"
Handle
ACK
"
)
;
let
prev_ack_count
=
server
.
stats
(
)
.
frame_rx
.
ack
;
server
.
process_input
(
ack_pkt
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ack
prev_ack_count
+
1
)
;
}
#
[
test
]
fn
pace
(
)
{
const
DATA
:
&
[
u8
]
=
&
[
0xcc
;
4_096
]
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
loop
{
let
written
=
client
.
stream_send
(
stream
DATA
)
.
unwrap
(
)
;
if
written
<
DATA
.
len
(
)
{
break
;
}
}
let
mut
count
=
0
;
for
_
in
0
.
.
=
PACING_BURST_SIZE
{
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
gap
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
gap
Duration
:
:
new
(
0
0
)
)
;
for
_
in
(
1
+
PACING_BURST_SIZE
)
.
.
cwnd_packets
(
POST_HANDSHAKE_CWND
)
{
match
client
.
process_output
(
now
)
{
Output
:
:
Callback
(
t
)
=
>
assert_eq
!
(
t
gap
)
Output
:
:
Datagram
(
_
)
=
>
{
count
+
=
1
;
break
;
}
Output
:
:
None
=
>
panic
!
(
)
}
now
+
=
gap
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert_eq
!
(
count
cwnd_packets
(
POST_HANDSHAKE_CWND
)
)
;
let
fin
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
fin
Duration
:
:
new
(
0
0
)
)
;
assert_ne
!
(
fin
gap
)
;
}
