use
std
:
:
{
mem
time
:
:
Duration
}
;
use
neqo_common
:
:
{
qdebug
qinfo
Datagram
IpTosEcn
}
;
use
super
:
:
{
super
:
:
Output
ack_bytes
assert_full_cwnd
connect_rtt_idle
cwnd
cwnd_avail
cwnd_packets
default_client
default_server
fill_cwnd
induce_persistent_congestion
send_something
CLIENT_HANDSHAKE_1RTT_PACKETS
DEFAULT_RTT
POST_HANDSHAKE_CWND
}
;
use
crate
:
:
{
cc
:
:
MAX_DATAGRAM_SIZE
packet
:
:
PacketNumber
recovery
:
:
{
ACK_ONLY_SIZE_LIMIT
PACKET_THRESHOLD
}
sender
:
:
PACING_BURST_SIZE
stream_id
:
:
StreamType
tracking
:
:
DEFAULT_ACK_PACKET_TOLERANCE
}
;
#
[
test
]
fn
cc_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
assert
!
(
cwnd_avail
(
&
client
)
<
ACK_ONLY_SIZE_LIMIT
)
;
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
)
]
enum
CongestionSignal
{
PacketLoss
EcnCe
}
fn
cc_slow_start_to_cong_avoidance_recovery_period
(
congestion_signal
:
CongestionSignal
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
let
flight1_largest
=
PacketNumber
:
:
try_from
(
c_tx_dgrams
.
len
(
)
+
CLIENT_HANDSHAKE_1RTT_PACKETS
)
.
unwrap
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
largest_acknowledged
flight1_largest
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
&
s_ack
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
largest_acknowledged
flight1_largest
)
;
let
cwnd_before_cong
=
cwnd
(
&
client
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
*
2
)
;
let
flight2_largest
=
flight1_largest
+
u64
:
:
try_from
(
c_tx_dgrams
.
len
(
)
)
.
unwrap
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
match
congestion_signal
{
CongestionSignal
:
:
PacketLoss
=
>
{
c_tx_dgrams
.
remove
(
0
)
;
}
CongestionSignal
:
:
EcnCe
=
>
{
c_tx_dgrams
.
last_mut
(
)
.
unwrap
(
)
.
set_tos
(
IpTosEcn
:
:
Ce
.
into
(
)
)
;
}
}
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
largest_acknowledged
flight2_largest
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
&
s_ack
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
largest_acknowledged
flight2_largest
)
;
assert
!
(
cwnd
(
&
client
)
<
cwnd_before_cong
)
;
}
#
[
test
]
fn
cc_slow_start_to_cong_avoidance_recovery_period_due_to_packet_loss
(
)
{
cc_slow_start_to_cong_avoidance_recovery_period
(
CongestionSignal
:
:
PacketLoss
)
;
}
#
[
test
]
fn
cc_slow_start_to_cong_avoidance_recovery_period_due_to_ecn_ce
(
)
{
cc_slow_start_to_cong_avoidance_recovery_period
(
CongestionSignal
:
:
EcnCe
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_unchanged
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
mut
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
c_tx_dgrams
.
remove
(
0
)
;
let
c_tx_dgrams2
=
c_tx_dgrams
.
split_off
(
5
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
client
.
process_input
(
&
s_ack
now
)
;
let
cwnd1
=
cwnd
(
&
client
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams2
now
)
;
client
.
process_input
(
&
s_ack
now
)
;
let
cwnd2
=
cwnd
(
&
client
)
;
assert_eq
!
(
cwnd1
cwnd2
)
;
}
#
[
test
]
fn
single_packet_on_recovery
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
for
_
in
0
.
.
PACKET_THRESHOLD
{
let
_dropped
=
send_something
(
&
mut
client
now
)
;
}
let
delivered
=
send_something
(
&
mut
client
now
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
_
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert
!
(
cwnd_avail
(
&
client
)
<
ACK_ONLY_SIZE_LIMIT
)
;
let
ack
=
server
.
process
(
Some
(
&
delivered
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
client
.
process_input
(
&
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
cwnd_avail
(
&
client
)
0
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
#
[
test
]
fn
cc_cong_avoidance_recovery_period_to_cong_avoidance
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream_id
0
)
;
let
(
mut
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
c_tx_dgrams
.
remove
(
0
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
&
s_ack
now
)
;
now
+
=
DEFAULT_RTT
/
2
;
qinfo
!
(
"
moving
to
congestion
avoidance
{
}
"
cwnd
(
&
client
)
)
;
let
mut
expected_cwnd
=
cwnd
(
&
client
)
;
let
(
mut
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
now
=
next_now
;
for
i
in
0
.
.
5
{
qinfo
!
(
"
iteration
{
}
"
i
)
;
let
c_tx_size
:
usize
=
c_tx_dgrams
.
iter
(
)
.
map
(
|
d
|
d
.
len
(
)
)
.
sum
(
)
;
qinfo
!
(
"
client
sending
{
}
bytes
into
cwnd
of
{
}
"
c_tx_size
cwnd
(
&
client
)
)
;
assert_eq
!
(
c_tx_size
expected_cwnd
)
;
let
mut
next_c_tx_dgrams
:
Vec
<
Datagram
>
=
Vec
:
:
new
(
)
;
let
most
=
c_tx_dgrams
.
len
(
)
-
usize
:
:
try_from
(
DEFAULT_ACK_PACKET_TOLERANCE
)
.
unwrap
(
)
-
1
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
.
drain
(
.
.
most
)
now
)
;
assert_eq
!
(
cwnd
(
&
client
)
expected_cwnd
)
;
client
.
process_input
(
&
s_ack
now
)
;
let
(
mut
new_pkts
next_now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
now
=
next_now
;
next_c_tx_dgrams
.
append
(
&
mut
new_pkts
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream_id
c_tx_dgrams
now
)
;
assert_eq
!
(
cwnd
(
&
client
)
expected_cwnd
)
;
client
.
process_input
(
&
s_ack
now
)
;
let
(
mut
new_pkts
next_now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
now
=
next_now
;
next_c_tx_dgrams
.
append
(
&
mut
new_pkts
)
;
expected_cwnd
+
=
MAX_DATAGRAM_SIZE
;
assert_eq
!
(
cwnd
(
&
client
)
expected_cwnd
)
;
c_tx_dgrams
=
next_c_tx_dgrams
;
}
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_no_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
DEFAULT_RTT
/
2
;
mem
:
:
drop
(
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
}
#
[
test
]
fn
cc_slow_start_to_persistent_congestion_some_acks
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
;
now
+
=
Duration
:
:
from_millis
(
100
)
;
client
.
process_input
(
&
s_ack
now
)
;
let
(
_
next_now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
}
#
[
test
]
fn
cc_persistent_congestion_to_slow_start
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
let
(
c_tx_dgrams
mut
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
mem
:
:
drop
(
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
)
;
now
=
induce_persistent_congestion
(
&
mut
client
&
mut
server
stream
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
now
=
next_now
+
Duration
:
:
from_millis
(
100
)
;
let
s_ack
=
ack_bytes
(
&
mut
server
stream
c_tx_dgrams
now
)
;
client
.
process_input
(
&
s_ack
now
)
;
let
(
c_tx_dgrams
_
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
4
)
;
}
#
[
test
]
fn
ack_are_not_cc
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream
0
)
;
let
(
c_tx_dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream
now
)
;
assert_full_cwnd
(
&
c_tx_dgrams
POST_HANDSHAKE_CWND
)
;
qdebug
!
(
[
server
]
"
Sending
ack
-
eliciting
"
)
;
let
other_stream
=
server
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
assert_eq
!
(
other_stream
1
)
;
server
.
stream_send
(
other_stream
b
"
dropped
"
)
.
unwrap
(
)
;
let
dropped_packet
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dropped_packet
.
is_some
(
)
)
;
server
.
stream_send
(
other_stream
b
"
sent
"
)
.
unwrap
(
)
;
let
ack_eliciting_packet
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
ack_eliciting_packet
.
is_some
(
)
)
;
qdebug
!
(
[
client
]
"
Process
ack
-
eliciting
"
)
;
let
ack_pkt
=
client
.
process
(
ack_eliciting_packet
.
as_ref
(
)
now
)
.
dgram
(
)
;
assert
!
(
ack_pkt
.
is_some
(
)
)
;
qdebug
!
(
[
server
]
"
Handle
ACK
"
)
;
let
prev_ack_count
=
server
.
stats
(
)
.
frame_rx
.
ack
;
server
.
process_input
(
&
ack_pkt
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ack
prev_ack_count
+
1
)
;
}
#
[
test
]
fn
pace
(
)
{
const
DATA
:
&
[
u8
]
=
&
[
0xcc
;
4_096
]
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
;
loop
{
let
written
=
client
.
stream_send
(
stream
DATA
)
.
unwrap
(
)
;
if
written
<
DATA
.
len
(
)
{
break
;
}
}
let
mut
count
=
0
;
for
_
in
0
.
.
=
PACING_BURST_SIZE
{
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
gap
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
gap
Duration
:
:
new
(
0
0
)
)
;
for
_
in
(
1
+
PACING_BURST_SIZE
)
.
.
cwnd_packets
(
POST_HANDSHAKE_CWND
)
{
match
client
.
process_output
(
now
)
{
Output
:
:
Callback
(
t
)
=
>
assert_eq
!
(
t
gap
)
Output
:
:
Datagram
(
_
)
=
>
{
count
+
=
1
;
break
;
}
Output
:
:
None
=
>
panic
!
(
)
}
now
+
=
gap
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
count
+
=
1
;
}
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert_eq
!
(
count
cwnd_packets
(
POST_HANDSHAKE_CWND
)
)
;
let
fin
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
fin
Duration
:
:
new
(
0
0
)
)
;
assert_ne
!
(
fin
gap
)
;
}
