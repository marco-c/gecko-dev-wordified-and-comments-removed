#
!
[
deny
(
clippy
:
:
pedantic
)
]
use
super
:
:
{
Connection
ConnectionError
ConnectionId
Output
State
}
;
use
crate
:
:
addr_valid
:
:
{
AddressValidation
ValidateAddress
}
;
use
crate
:
:
cc
:
:
{
CWND_INITIAL_PKTS
CWND_MIN
}
;
use
crate
:
:
cid
:
:
ConnectionIdRef
;
use
crate
:
:
events
:
:
ConnectionEvent
;
use
crate
:
:
path
:
:
PATH_MTU_V6
;
use
crate
:
:
recovery
:
:
ACK_ONLY_SIZE_LIMIT
;
use
crate
:
:
stats
:
:
MAX_PTO_COUNTS
;
use
crate
:
:
{
ConnectionIdDecoder
ConnectionIdGenerator
ConnectionParameters
Error
StreamType
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
cmp
:
:
min
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
neqo_common
:
:
{
event
:
:
Provider
qdebug
qtrace
Datagram
Decoder
}
;
use
neqo_crypto
:
:
{
random
AllowZeroRtt
AuthenticationStatus
ResumptionToken
}
;
use
test_fixture
:
:
{
self
addr
fixture_init
now
}
;
mod
ackrate
;
mod
cc
;
mod
close
;
mod
datagram
;
mod
fuzzing
;
mod
handshake
;
mod
idle
;
mod
keys
;
mod
migration
;
mod
priority
;
mod
recovery
;
mod
resumption
;
mod
stream
;
mod
vn
;
mod
zerortt
;
const
DEFAULT_RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
const
AT_LEAST_PTO
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
const
DEFAULT_STREAM_DATA
:
&
[
u8
]
=
b
"
message
"
;
const
FORCE_IDLE_CLIENT_1RTT_PACKETS
:
usize
=
3
;
#
[
derive
(
Debug
Default
)
]
pub
struct
CountingConnectionIdGenerator
{
counter
:
u32
}
impl
ConnectionIdDecoder
for
CountingConnectionIdGenerator
{
fn
decode_cid
<
'
a
>
(
&
self
dec
:
&
mut
Decoder
<
'
a
>
)
-
>
Option
<
ConnectionIdRef
<
'
a
>
>
{
let
len
=
usize
:
:
from
(
dec
.
peek_byte
(
)
.
unwrap
(
)
)
;
dec
.
decode
(
len
)
.
map
(
ConnectionIdRef
:
:
from
)
}
}
impl
ConnectionIdGenerator
for
CountingConnectionIdGenerator
{
fn
generate_cid
(
&
mut
self
)
-
>
Option
<
ConnectionId
>
{
let
mut
r
=
random
(
20
)
;
r
[
0
]
=
8
;
r
[
1
]
=
u8
:
:
try_from
(
self
.
counter
>
>
24
)
.
unwrap
(
)
;
r
[
2
]
=
u8
:
:
try_from
(
(
self
.
counter
>
>
16
)
&
0xff
)
.
unwrap
(
)
;
r
[
3
]
=
u8
:
:
try_from
(
(
self
.
counter
>
>
8
)
&
0xff
)
.
unwrap
(
)
;
r
[
4
]
=
u8
:
:
try_from
(
self
.
counter
&
0xff
)
.
unwrap
(
)
;
self
.
counter
+
=
1
;
Some
(
ConnectionId
:
:
from
(
&
r
[
.
.
8
]
)
)
}
fn
as_decoder
(
&
self
)
-
>
&
dyn
ConnectionIdDecoder
{
self
}
}
pub
fn
new_client
(
params
:
ConnectionParameters
)
-
>
Connection
{
fixture_init
(
)
;
Connection
:
:
new_client
(
test_fixture
:
:
DEFAULT_SERVER_NAME
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
addr
(
)
addr
(
)
params
now
(
)
)
.
expect
(
"
create
a
default
client
"
)
}
pub
fn
default_client
(
)
-
>
Connection
{
new_client
(
ConnectionParameters
:
:
default
(
)
)
}
pub
fn
new_server
(
params
:
ConnectionParameters
)
-
>
Connection
{
fixture_init
(
)
;
let
mut
c
=
Connection
:
:
new_server
(
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
params
)
.
expect
(
"
create
a
default
server
"
)
;
c
.
server_enable_0rtt
(
&
test_fixture
:
:
anti_replay
(
)
AllowZeroRtt
{
}
)
.
expect
(
"
enable
0
-
RTT
"
)
;
c
}
pub
fn
default_server
(
)
-
>
Connection
{
new_server
(
ConnectionParameters
:
:
default
(
)
)
}
pub
fn
maybe_authenticate
(
conn
:
&
mut
Connection
)
-
>
bool
{
let
authentication_needed
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
AuthenticationNeeded
)
;
if
conn
.
events
(
)
.
any
(
authentication_needed
)
{
conn
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
return
true
;
}
false
}
fn
handshake
(
client
:
&
mut
Connection
server
:
&
mut
Connection
now
:
Instant
rtt
:
Duration
)
-
>
Instant
{
let
mut
a
=
client
;
let
mut
b
=
server
;
let
mut
now
=
now
;
let
mut
input
=
None
;
let
is_done
=
|
c
:
&
mut
Connection
|
{
matches
!
(
c
.
state
(
)
State
:
:
Confirmed
|
State
:
:
Closing
{
.
.
}
|
State
:
:
Closed
(
.
.
)
)
}
;
while
!
is_done
(
a
)
{
let
_
=
maybe_authenticate
(
a
)
;
let
had_input
=
input
.
is_some
(
)
;
let
output
=
a
.
process
(
input
now
)
.
dgram
(
)
;
assert
!
(
had_input
|
|
output
.
is_some
(
)
)
;
input
=
output
;
qtrace
!
(
"
handshake
:
t
+
=
{
:
?
}
"
rtt
/
2
)
;
now
+
=
rtt
/
2
;
mem
:
:
swap
(
&
mut
a
&
mut
b
)
;
}
if
let
Some
(
d
)
=
input
{
a
.
process_input
(
d
now
)
;
}
now
}
fn
connect_fail
(
client
:
&
mut
Connection
server
:
&
mut
Connection
client_error
:
Error
server_error
:
Error
)
{
handshake
(
client
server
now
(
)
Duration
:
:
new
(
0
0
)
)
;
assert_error
(
client
&
ConnectionError
:
:
Transport
(
client_error
)
)
;
assert_error
(
server
&
ConnectionError
:
:
Transport
(
server_error
)
)
;
}
fn
connect_with_rtt
(
client
:
&
mut
Connection
server
:
&
mut
Connection
now
:
Instant
rtt
:
Duration
)
-
>
Instant
{
let
now
=
handshake
(
client
server
now
rtt
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
paths
.
rtt
(
)
rtt
)
;
assert_eq
!
(
server
.
paths
.
rtt
(
)
rtt
)
;
now
}
fn
connect
(
client
:
&
mut
Connection
server
:
&
mut
Connection
)
{
connect_with_rtt
(
client
server
now
(
)
Duration
:
:
new
(
0
0
)
)
;
}
fn
assert_error
(
c
:
&
Connection
err
:
&
ConnectionError
)
{
match
c
.
state
(
)
{
State
:
:
Closing
{
error
.
.
}
|
State
:
:
Draining
{
error
.
.
}
|
State
:
:
Closed
(
error
)
=
>
{
assert_eq
!
(
*
error
*
err
)
;
}
_
=
>
panic
!
(
"
bad
state
{
:
?
}
"
c
.
state
(
)
)
}
}
fn
exchange_ticket
(
client
:
&
mut
Connection
server
:
&
mut
Connection
now
:
Instant
)
-
>
ResumptionToken
{
let
validation
=
AddressValidation
:
:
new
(
now
ValidateAddress
:
:
NoToken
)
.
unwrap
(
)
;
let
validation
=
Rc
:
:
new
(
RefCell
:
:
new
(
validation
)
)
;
server
.
set_validation
(
Rc
:
:
clone
(
&
validation
)
)
;
server
.
send_ticket
(
now
&
[
]
)
.
expect
(
"
can
send
ticket
"
)
;
let
ticket
=
server
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
ticket
.
is_some
(
)
)
;
client
.
process_input
(
ticket
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
get_tokens
(
client
)
.
pop
(
)
.
expect
(
"
should
have
token
"
)
}
fn
force_idle
(
client
:
&
mut
Connection
server
:
&
mut
Connection
rtt
:
Duration
mut
now
:
Instant
)
-
>
Instant
{
qtrace
!
(
"
force_idle
:
send
reordered
client
packets
"
)
;
let
c1
=
send_something
(
client
now
)
;
let
c2
=
send_something
(
client
now
)
;
now
+
=
rtt
/
2
;
server
.
process_input
(
c2
now
)
;
server
.
process_input
(
c1
now
)
;
qtrace
!
(
"
force_idle
:
send
reordered
server
packets
"
)
;
let
s1
=
send_something
(
server
now
)
;
let
s2
=
send_something
(
server
now
)
;
now
+
=
rtt
/
2
;
client
.
process_input
(
s2
now
)
;
let
ack
=
client
.
process
(
Some
(
s1
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
idle_timeout
=
min
(
client
.
conn_params
.
get_idle_timeout
(
)
server
.
conn_params
.
get_idle_timeout
(
)
)
;
assert_eq
!
(
client
.
process_output
(
now
)
Output
:
:
Callback
(
idle_timeout
)
)
;
now
+
=
rtt
/
2
;
assert_eq
!
(
server
.
process
(
ack
now
)
Output
:
:
Callback
(
idle_timeout
)
)
;
now
}
fn
connect_rtt_idle
(
client
:
&
mut
Connection
server
:
&
mut
Connection
rtt
:
Duration
)
-
>
Instant
{
let
now
=
connect_with_rtt
(
client
server
now
(
)
rtt
)
;
let
now
=
force_idle
(
client
server
rtt
now
)
;
let
_
=
client
.
events
(
)
.
count
(
)
;
let
_
=
server
.
events
(
)
.
count
(
)
;
qtrace
!
(
"
-
-
-
-
-
connected
and
idle
with
RTT
{
:
?
}
"
rtt
)
;
now
}
fn
connect_force_idle
(
client
:
&
mut
Connection
server
:
&
mut
Connection
)
{
connect_rtt_idle
(
client
server
Duration
:
:
new
(
0
0
)
)
;
}
fn
fill_stream
(
c
:
&
mut
Connection
stream
:
u64
)
{
const
BLOCK_SIZE
:
usize
=
4_096
;
loop
{
let
bytes_sent
=
c
.
stream_send
(
stream
&
[
0x42
;
BLOCK_SIZE
]
)
.
unwrap
(
)
;
qtrace
!
(
"
fill_cwnd
wrote
{
}
bytes
"
bytes_sent
)
;
if
bytes_sent
<
BLOCK_SIZE
{
break
;
}
}
}
fn
fill_cwnd
(
c
:
&
mut
Connection
stream
:
u64
mut
now
:
Instant
)
-
>
(
Vec
<
Datagram
>
Instant
)
{
fn
cwnd
(
c
:
&
Connection
)
-
>
usize
{
c
.
paths
.
primary
(
)
.
borrow
(
)
.
sender
(
)
.
cwnd_avail
(
)
}
qtrace
!
(
"
fill_cwnd
starting
cwnd
:
{
}
"
cwnd
(
c
)
)
;
fill_stream
(
c
stream
)
;
let
mut
total_dgrams
=
Vec
:
:
new
(
)
;
loop
{
let
pkt
=
c
.
process_output
(
now
)
;
qtrace
!
(
"
fill_cwnd
cwnd
remaining
=
{
}
output
:
{
:
?
}
"
cwnd
(
c
)
pkt
)
;
match
pkt
{
Output
:
:
Datagram
(
dgram
)
=
>
{
total_dgrams
.
push
(
dgram
)
;
}
Output
:
:
Callback
(
t
)
=
>
{
if
cwnd
(
c
)
<
ACK_ONLY_SIZE_LIMIT
{
break
;
}
now
+
=
t
;
}
Output
:
:
None
=
>
panic
!
(
)
}
}
qtrace
!
(
"
fill_cwnd
sent
{
}
bytes
"
total_dgrams
.
iter
(
)
.
map
(
|
d
|
d
.
len
(
)
)
.
sum
:
:
<
usize
>
(
)
)
;
(
total_dgrams
now
)
}
fn
increase_cwnd
(
sender
:
&
mut
Connection
receiver
:
&
mut
Connection
stream
:
u64
mut
now
:
Instant
)
-
>
Instant
{
fill_stream
(
sender
stream
)
;
loop
{
let
pkt
=
sender
.
process_output
(
now
)
;
match
pkt
{
Output
:
:
Datagram
(
dgram
)
=
>
{
receiver
.
process_input
(
dgram
now
+
DEFAULT_RTT
/
2
)
;
}
Output
:
:
Callback
(
t
)
=
>
{
if
t
<
DEFAULT_RTT
{
now
+
=
t
;
}
else
{
break
;
}
}
Output
:
:
None
=
>
panic
!
(
)
}
}
now
+
=
DEFAULT_RTT
/
2
;
let
ack
=
receiver
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
sender
.
process_input
(
ack
.
unwrap
(
)
now
)
;
now
}
fn
ack_bytes
<
D
>
(
dest
:
&
mut
Connection
stream
:
u64
in_dgrams
:
D
now
:
Instant
)
-
>
Datagram
where
D
:
IntoIterator
<
Item
=
Datagram
>
D
:
:
IntoIter
:
ExactSizeIterator
{
let
mut
srv_buf
=
[
0
;
4_096
]
;
let
in_dgrams
=
in_dgrams
.
into_iter
(
)
;
qdebug
!
(
[
dest
]
"
ack_bytes
{
}
datagrams
"
in_dgrams
.
len
(
)
)
;
for
dgram
in
in_dgrams
{
dest
.
process_input
(
dgram
now
)
;
}
loop
{
let
(
bytes_read
_fin
)
=
dest
.
stream_recv
(
stream
&
mut
srv_buf
)
.
unwrap
(
)
;
qtrace
!
(
[
dest
]
"
ack_bytes
read
{
}
bytes
"
bytes_read
)
;
if
bytes_read
=
=
0
{
break
;
}
}
dest
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
}
fn
cwnd
(
c
:
&
Connection
)
-
>
usize
{
c
.
paths
.
primary
(
)
.
borrow
(
)
.
sender
(
)
.
cwnd
(
)
}
fn
cwnd_avail
(
c
:
&
Connection
)
-
>
usize
{
c
.
paths
.
primary
(
)
.
borrow
(
)
.
sender
(
)
.
cwnd_avail
(
)
}
fn
induce_persistent_congestion
(
client
:
&
mut
Connection
server
:
&
mut
Connection
stream
:
u64
mut
now
:
Instant
)
-
>
Instant
{
qtrace
!
(
[
client
]
"
induce_persistent_congestion
"
)
;
now
+
=
AT_LEAST_PTO
;
let
mut
pto_counts
=
[
0
;
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qtrace
!
(
[
client
]
"
first
PTO
"
)
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
stream
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qtrace
!
(
[
client
]
"
second
PTO
"
)
;
now
+
=
AT_LEAST_PTO
*
2
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
stream
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
pto_counts
[
0
]
=
0
;
pto_counts
[
1
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qtrace
!
(
[
client
]
"
third
PTO
"
)
;
now
+
=
AT_LEAST_PTO
*
4
;
let
(
c_tx_dgrams
next_now
)
=
fill_cwnd
(
client
stream
now
)
;
now
=
next_now
;
assert_eq
!
(
c_tx_dgrams
.
len
(
)
2
)
;
pto_counts
[
1
]
=
0
;
pto_counts
[
2
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
s_ack
=
ack_bytes
(
server
stream
c_tx_dgrams
now
)
;
client
.
process_input
(
s_ack
now
)
;
assert_eq
!
(
cwnd
(
client
)
CWND_MIN
)
;
now
}
const
POST_HANDSHAKE_CWND
:
usize
=
PATH_MTU_V6
*
CWND_INITIAL_PKTS
;
const
fn
cwnd_packets
(
data
:
usize
)
-
>
usize
{
(
data
+
PATH_MTU_V6
-
ACK_ONLY_SIZE_LIMIT
)
/
PATH_MTU_V6
}
fn
last_packet
(
cwnd
:
usize
)
-
>
usize
{
if
(
cwnd
%
PATH_MTU_V6
)
>
ACK_ONLY_SIZE_LIMIT
{
cwnd
%
PATH_MTU_V6
}
else
{
PATH_MTU_V6
}
}
fn
assert_full_cwnd
(
packets
:
&
[
Datagram
]
cwnd
:
usize
)
{
assert_eq
!
(
packets
.
len
(
)
cwnd_packets
(
cwnd
)
)
;
let
(
last
rest
)
=
packets
.
split_last
(
)
.
unwrap
(
)
;
assert
!
(
rest
.
iter
(
)
.
all
(
|
d
|
d
.
len
(
)
=
=
PATH_MTU_V6
)
)
;
assert_eq
!
(
last
.
len
(
)
last_packet
(
cwnd
)
)
;
}
#
[
must_use
]
fn
send_something
(
sender
:
&
mut
Connection
now
:
Instant
)
-
>
Datagram
{
let
stream_id
=
sender
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
sender
.
stream_send
(
stream_id
DEFAULT_STREAM_DATA
)
.
is_ok
(
)
)
;
assert
!
(
sender
.
stream_close_send
(
stream_id
)
.
is_ok
(
)
)
;
qdebug
!
(
[
sender
]
"
send_something
on
{
}
"
stream_id
)
;
let
dgram
=
sender
.
process
(
None
now
)
.
dgram
(
)
;
dgram
.
expect
(
"
should
have
something
to
send
"
)
}
fn
send_and_receive
(
sender
:
&
mut
Connection
receiver
:
&
mut
Connection
now
:
Instant
)
-
>
Option
<
Datagram
>
{
let
dgram
=
send_something
(
sender
now
)
;
receiver
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
}
fn
get_tokens
(
client
:
&
mut
Connection
)
-
>
Vec
<
ResumptionToken
>
{
client
.
events
(
)
.
filter_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
ResumptionToken
(
token
)
=
e
{
Some
(
token
)
}
else
{
None
}
}
)
.
collect
(
)
}
