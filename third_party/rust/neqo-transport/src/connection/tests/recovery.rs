use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
neqo_common
:
:
qdebug
;
use
neqo_crypto
:
:
AuthenticationStatus
;
use
test_fixture
:
:
{
assertions
:
:
{
assert_handshake
assert_initial
is_handshake
is_initial
}
now
split_datagram
}
;
use
super
:
:
{
super
:
:
{
Connection
ConnectionParameters
Output
State
}
assert_full_cwnd
connect
connect_force_idle
connect_rtt_idle
connect_with_rtt
cwnd
default_client
default_server
fill_cwnd
maybe_authenticate
new_client
send_and_receive
send_something
AT_LEAST_PTO
DEFAULT_ADDR
DEFAULT_RTT
DEFAULT_STREAM_DATA
POST_HANDSHAKE_CWND
}
;
use
crate
:
:
{
connection
:
:
{
test_internal
:
:
FrameWriter
tests
:
:
cwnd_min
}
frame
:
:
FrameType
packet
recovery
:
:
{
FAST_PTO_SCALE
MAX_OUTSTANDING_UNACK
MAX_PTO_PACKET_COUNT
MIN_OUTSTANDING_UNACK
}
rtt
:
:
GRANULARITY
tparams
:
:
{
TransportParameter
TransportParameterId
:
:
*
}
tracking
:
:
{
DEFAULT_LOCAL_ACK_DELAY
DEFAULT_REMOTE_ACK_DELAY
}
CloseReason
Error
Pmtud
Stats
StreamType
}
;
#
[
test
]
fn
pto_works_basic
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
ConnectionParameters
:
:
DEFAULT_IDLE_TIMEOUT
)
;
let
stream1
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream1
b
"
hello
"
)
.
unwrap
(
)
5
)
;
assert_eq
!
(
client
.
stream_send
(
stream1
b
"
world
!
"
)
.
unwrap
(
)
7
)
;
let
stream2
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream2
b
"
there
!
"
)
.
unwrap
(
)
6
)
;
now
+
=
Duration
:
:
from_secs
(
10
)
;
let
out
=
client
.
process_output
(
now
)
;
assert
!
(
out
.
dgram
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process_output
(
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
_
)
)
)
;
now
+
=
AT_LEAST_PTO
;
let
out
=
client
.
process_output
(
now
)
;
let
stream_before
=
server
.
stats
(
)
.
frame_rx
.
stream
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
stream
stream_before
+
2
)
;
}
#
[
test
]
fn
pto_works_full_cwnd
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
dgrams
POST_HANDSHAKE_CWND
client
.
plpmtu
(
)
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
+
AT_LEAST_PTO
)
;
assert_eq
!
(
dgrams
.
len
(
)
2
)
;
assert_eq
!
(
dgrams
[
0
]
.
len
(
)
client
.
plpmtu
(
)
)
;
for
d
in
dgrams
{
let
stream_before
=
server
.
stats
(
)
.
frame_rx
.
stream
;
server
.
process_input
(
d
now
)
;
assert
!
(
server
.
stats
(
)
.
frame_rx
.
stream
>
stream_before
)
;
}
}
#
[
test
]
fn
pto_works_ping
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
+
Duration
:
:
from_secs
(
10
)
;
let
pkt0
=
send_something
(
&
mut
client
now
)
;
let
pkt1
=
send_something
(
&
mut
client
now
)
;
let
pkt2
=
send_something
(
&
mut
client
now
)
;
let
pkt3
=
send_something
(
&
mut
client
now
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
GRANULARITY
*
2
)
;
let
srv0
=
server
.
process
(
Some
(
pkt1
)
now
)
.
dgram
(
)
;
assert
!
(
srv0
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
20
)
;
let
srv1
=
server
.
process
(
Some
(
pkt2
)
now
)
.
dgram
(
)
;
assert
!
(
srv1
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
20
)
;
let
srv2
=
server
.
process
(
Some
(
pkt3
)
now
)
.
dgram
(
)
;
assert
!
(
srv2
.
is_some
(
)
)
;
let
pkt4
=
client
.
process
(
srv2
now
)
.
dgram
(
)
;
assert
!
(
pkt4
.
is_some
(
)
)
;
let
srv3
=
server
.
process
(
Some
(
pkt0
)
now
)
.
dgram
(
)
;
assert
!
(
srv3
.
is_some
(
)
)
;
let
pkt5
=
client
.
process
(
srv3
now
)
.
dgram
(
)
;
assert
!
(
pkt5
.
is_none
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
70
)
;
let
client_pings
=
client
.
stats
(
)
.
frame_tx
.
ping
;
let
pkt6
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ping
client_pings
+
1
)
;
let
server_pings
=
server
.
stats
(
)
.
frame_rx
.
ping
;
server
.
process_input
(
pkt6
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ping
server_pings
+
1
)
;
}
#
[
test
]
fn
pto_initial
(
)
{
const
INITIAL_PTO
:
Duration
=
Duration
:
:
from_millis
(
300
)
;
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
pkt1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
assert_eq
!
(
pkt1
.
clone
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
let
delay
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
now
+
=
delay
;
let
pkt2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
assert_eq
!
(
pkt2
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
let
delay
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
*
2
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
delay
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
*
3
)
;
}
#
[
test
]
fn
pto_handshake_complete
(
)
{
const
HALF_RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
pkt2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_initial
(
pkt
.
as_ref
(
)
.
unwrap
(
)
false
)
;
assert_initial
(
pkt2
.
as_ref
(
)
.
unwrap
(
)
false
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
5
)
)
;
now
+
=
HALF_RTT
;
server
.
process_input
(
pkt
.
unwrap
(
)
now
)
;
let
pkt
=
server
.
process
(
pkt2
now
)
.
dgram
(
)
;
assert_initial
(
pkt
.
as_ref
(
)
.
unwrap
(
)
false
)
;
now
+
=
HALF_RTT
;
let
pkt
=
client
.
process
(
pkt
now
)
.
dgram
(
)
;
assert_initial
(
pkt
.
as_ref
(
)
.
unwrap
(
)
false
)
;
now
+
=
HALF_RTT
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
assert_handshake
(
pkt
.
as_ref
(
)
.
unwrap
(
)
)
;
now
+
=
HALF_RTT
;
let
pkt
=
client
.
process
(
pkt
now
)
.
dgram
(
)
;
assert_handshake
(
pkt
.
as_ref
(
)
.
unwrap
(
)
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
let
pto
=
HALF_RTT
*
6
;
assert_eq
!
(
cb
pto
)
;
now
+
=
HALF_RTT
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
assert
!
(
pkt
.
is_none
(
)
)
;
now
+
=
HALF_RTT
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
let
pkt1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_handshake
(
pkt1
.
as_ref
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
pto
)
;
let
mut
pto_counts
=
[
0
;
Stats
:
:
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
pto
;
let
pkt2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_handshake
(
pkt2
.
as_ref
(
)
.
unwrap
(
)
)
;
let
ping
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
ping
.
as_ref
(
)
.
unwrap
(
)
[
0
]
&
0x80
0
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
pto
=
2
*
pto
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
pto
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
now
+
=
pto
;
let
pkt3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_handshake
(
pkt3
.
as_ref
(
)
.
unwrap
(
)
)
;
let
(
pkt3_hs
pkt3_1rtt
)
=
split_datagram
(
&
pkt3
.
unwrap
(
)
)
;
assert_handshake
(
&
pkt3_hs
)
;
assert
!
(
pkt3_1rtt
.
is_some
(
)
)
;
let
ping
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
ping
.
as_ref
(
)
.
unwrap
(
)
[
0
]
&
0x80
0
)
;
let
pto
=
pto
*
2
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
pto
)
;
pto_counts
[
0
]
=
0
;
pto_counts
[
1
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
HALF_RTT
;
let
server_acks
=
server
.
stats
(
)
.
frame_tx
.
ack
;
let
server_done
=
server
.
stats
(
)
.
frame_tx
.
handshake_done
;
server
.
process_input
(
pkt3_1rtt
.
unwrap
(
)
now
)
;
let
ack
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
ack
server_acks
+
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
handshake_done
server_done
+
1
)
;
let
(
pkt2_hs
pkt2_1rtt
)
=
split_datagram
(
&
pkt2
.
unwrap
(
)
)
;
assert_handshake
(
&
pkt2_hs
)
;
assert
!
(
pkt2_1rtt
.
is_some
(
)
)
;
let
dropped_before1
=
server
.
stats
(
)
.
dropped_rx
;
let
server_frames
=
server
.
stats
(
)
.
frame_rx
.
all
(
)
;
server
.
process_input
(
pkt2_hs
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before1
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
all
(
)
server_frames
)
;
server
.
process_input
(
pkt2_1rtt
.
unwrap
(
)
now
)
;
let
server_frames2
=
server
.
stats
(
)
.
frame_rx
.
all
(
)
;
let
dropped_before2
=
server
.
stats
(
)
.
dropped_rx
;
server
.
process_input
(
pkt3_hs
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before2
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
all
(
)
server_frames2
)
;
now
+
=
HALF_RTT
;
let
_retransmissions
=
client
.
process
(
ack
now
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
let
expected_ack_delay
=
HALF_RTT
*
2
/
4
;
assert_eq
!
(
cb
expected_ack_delay
)
;
now
+
=
cb
;
let
out
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
}
#
[
test
]
fn
pto_handshake_frames
(
)
{
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt
=
client
.
process_output
(
now
)
;
let
pkt2
=
client
.
process_output
(
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
pkt
.
dgram
(
)
.
unwrap
(
)
now
)
;
let
pkt
=
server
.
process
(
pkt2
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
pkt
=
client
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
client
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
drop
(
server
.
process
(
pkt
.
dgram
(
)
now
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
stream
2
)
;
assert_eq
!
(
client
.
stream_send
(
stream
b
"
zero
"
)
.
unwrap
(
)
4
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
and
1RTT
packet
"
)
;
let
pkt1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
out
=
client
.
process_output
(
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
60
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
60
)
;
let
pkt2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
crypto_before
=
server
.
stats
(
)
.
frame_rx
.
crypto
;
server
.
process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
crypto
crypto_before
+
1
)
;
}
#
[
test
]
fn
pto_retransmits_previous_frames_across_datagrams
(
)
{
const
NUM_PACKETS_BEFORE_PTO
:
usize
=
10
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
mut
client_stream_frame_tx
=
client
.
stats
(
)
.
frame_tx
.
stream
;
for
_
in
0
.
.
NUM_PACKETS_BEFORE_PTO
{
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream
b
"
42
"
)
.
unwrap
(
)
2
)
;
let
lost
=
client
.
process_output
(
now
)
;
assert
!
(
lost
.
dgram
(
)
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
stream
client_stream_frame_tx
+
1
)
;
client_stream_frame_tx
=
client
.
stats
(
)
.
frame_tx
.
stream
;
}
let
out
=
client
.
process_output
(
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
_
)
)
)
;
now
+
=
AT_LEAST_PTO
;
let
client_pto
=
client
.
process_output
(
now
)
;
let
server_stream_frame_rx
=
server
.
stats
(
)
.
frame_rx
.
stream
;
server
.
process_input
(
client_pto
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
stream
server_stream_frame_rx
+
NUM_PACKETS_BEFORE_PTO
)
;
}
#
[
test
]
fn
handshake_ack_pto
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
now
=
now
(
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
big
=
TransportParameter
:
:
Bytes
(
vec
!
[
0
;
Pmtud
:
:
default_plpmtu
(
DEFAULT_ADDR
.
ip
(
)
)
]
)
;
server
.
set_local_tparam
(
TestTransportParameter
big
)
.
unwrap
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
s2
=
server
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
(
initial
_
)
=
split_datagram
(
&
s1
.
unwrap
(
)
)
;
client
.
process_input
(
initial
now
)
;
let
c2
=
client
.
process
(
s2
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
let
delay
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
delay
RTT
*
3
)
;
let
mut
pto_counts
=
[
0
;
Stats
:
:
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
delay
;
let
c3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
ping_before
=
server
.
stats
(
)
.
frame_rx
.
ping
;
server
.
process_input
(
c3
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ping
ping_before
+
1
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
dgram
=
server
.
process_output
(
now
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
}
#
[
test
]
fn
loss_recovery_crash
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
drop
(
send_something
(
&
mut
server
now
)
)
;
let
ack
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
cb
=
server
.
process
(
ack
now
)
.
callback
(
)
;
assert
!
(
cb
>
Duration
:
:
from_secs
(
0
)
)
;
let
dgram
=
server
.
process_output
(
now
+
AT_LEAST_PTO
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
drop
(
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
)
;
}
#
[
test
]
fn
ack_after_pto
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
drop
(
send_something
(
&
mut
client
now
)
)
;
now
+
=
AT_LEAST_PTO
;
for
_
in
0
.
.
MAX_PTO_PACKET_COUNT
{
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
assert
!
(
client
.
process_output
(
now
)
.
dgram
(
)
.
is_none
(
)
)
;
drop
(
send_something
(
&
mut
server
now
)
)
;
let
dgram
=
send_something
(
&
mut
server
now
)
;
let
ack
=
client
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
all_frames_before
=
server
.
stats
(
)
.
frame_rx
.
all
(
)
;
let
ack_before
=
server
.
stats
(
)
.
frame_rx
.
ack
;
server
.
process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
all
(
)
all_frames_before
+
1
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ack
ack_before
+
1
)
;
}
#
[
test
]
fn
lost_but_kept_and_lr_timer
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
let
_p1
=
send_something
(
&
mut
client
now
)
;
let
p2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
ack
=
server
.
process
(
Some
(
p2
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
_p3
=
send_something
(
&
mut
client
now
)
;
let
p4
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer
=
res
.
callback
(
)
;
assert_ne
!
(
lr_timer
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_timer
<
(
RTT
/
2
)
)
;
let
ack
=
server
.
process
(
Some
(
p4
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process_output
(
now
)
;
assert
!
(
res
.
dgram
(
)
.
is_some
(
)
)
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer2
=
res
.
callback
(
)
;
assert_eq
!
(
lr_timer
lr_timer2
)
;
}
#
[
test
]
fn
loss_time_past_largest_acked
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
10
)
;
const
INCR
:
Duration
=
Duration
:
:
from_millis
(
1
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_in
=
client
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s_hs1
=
server
.
process
(
c_in
now
)
.
dgram
(
)
;
let
s_pto
=
server
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
s_pto
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
s_pto
<
RTT
)
;
let
s_hs2
=
server
.
process_output
(
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs2
.
is_some
(
)
)
;
let
s_pto
=
server
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
s_pto
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
s_pto
<
RTT
)
;
let
s_hs3
=
server
.
process_output
(
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs3
.
is_some
(
)
)
;
let
cb
=
server
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
server
.
conn_params
.
get_idle_timeout
(
)
)
;
now
+
=
RTT
/
2
;
let
c_hs1
=
client
.
process
(
s_hs1
now
)
.
dgram
(
)
;
assert
!
(
c_hs1
.
is_some
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c_hs2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c_hs2
.
is_some
(
)
)
;
let
_p1
=
send_something
(
&
mut
client
now
+
INCR
)
;
let
c_hs3
=
client
.
process
(
s_hs2
now
+
(
INCR
*
2
)
)
.
dgram
(
)
;
assert
!
(
c_hs3
.
is_some
(
)
)
;
let
c_hs4
=
client
.
process
(
s_hs3
now
+
(
INCR
*
3
)
)
.
dgram
(
)
;
assert
!
(
c_hs4
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c_hs4
.
unwrap
(
)
now
)
;
let
s_ack
=
server
.
process
(
c_hs2
now
)
.
dgram
(
)
;
assert
!
(
s_ack
.
is_some
(
)
)
;
let
(
s_hs_ack
_s_ap_ack
)
=
split_datagram
(
&
s_ack
.
unwrap
(
)
)
;
now
+
=
RTT
/
2
;
let
_c_ack
=
client
.
process
(
Some
(
s_hs_ack
)
now
)
.
dgram
(
)
;
let
c_ack
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c_ack
.
is_none
(
)
)
;
let
lr_time
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
lr_time
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_time
<
(
RTT
/
2
)
)
;
}
fn
trickle
(
sender
:
&
mut
Connection
receiver
:
&
mut
Connection
mut
count
:
usize
now
:
Instant
)
{
let
id
=
sender
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
mut
maybe_ack
=
None
;
while
count
>
0
{
qdebug
!
(
"
trickle
:
remaining
=
{
count
}
"
)
;
assert_eq
!
(
sender
.
stream_send
(
id
&
[
9
]
)
.
unwrap
(
)
1
)
;
let
dgram
=
sender
.
process
(
maybe_ack
now
)
.
dgram
(
)
;
maybe_ack
=
receiver
.
process
(
dgram
now
)
.
dgram
(
)
;
count
-
=
usize
:
:
from
(
maybe_ack
.
is_some
(
)
)
;
}
sender
.
process_input
(
maybe_ack
.
unwrap
(
)
now
)
;
}
fn
ping_with_ack
(
fast
:
bool
)
{
let
mut
sender
=
default_client
(
)
;
let
mut
receiver
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
connect_force_idle
(
&
mut
sender
&
mut
receiver
)
;
let
sender_acks_before
=
sender
.
stats
(
)
.
frame_tx
.
ack
;
let
receiver_acks_before
=
receiver
.
stats
(
)
.
frame_tx
.
ack
;
let
count
=
if
fast
{
MAX_OUTSTANDING_UNACK
}
else
{
MIN_OUTSTANDING_UNACK
}
;
trickle
(
&
mut
sender
&
mut
receiver
count
now
)
;
assert_eq
!
(
sender
.
stats
(
)
.
frame_tx
.
ack
sender_acks_before
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ack
receiver_acks_before
+
count
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
if
!
fast
{
now
+
=
receiver
.
pto
(
)
+
Duration
:
:
from_micros
(
1
)
;
trickle
(
&
mut
sender
&
mut
receiver
1
now
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
}
now
+
=
receiver
.
pto
(
)
+
Duration
:
:
from_micros
(
1
)
;
trickle
(
&
mut
sender
&
mut
receiver
1
now
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
1
)
;
if
let
Output
:
:
Callback
(
t
)
=
sender
.
process_output
(
now
)
{
assert_eq
!
(
t
DEFAULT_LOCAL_ACK_DELAY
)
;
assert
!
(
sender
.
process_output
(
now
+
t
)
.
dgram
(
)
.
is_some
(
)
)
;
}
assert_eq
!
(
sender
.
stats
(
)
.
frame_tx
.
ack
sender_acks_before
+
1
)
;
}
#
[
test
]
fn
ping_with_ack_fast
(
)
{
ping_with_ack
(
true
)
;
}
#
[
test
]
fn
ping_with_ack_slow
(
)
{
ping_with_ack
(
false
)
;
}
#
[
test
]
fn
ping_with_ack_min
(
)
{
const
COUNT
:
usize
=
MIN_OUTSTANDING_UNACK
-
2
;
let
mut
sender
=
default_client
(
)
;
let
mut
receiver
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
connect_force_idle
(
&
mut
sender
&
mut
receiver
)
;
let
sender_acks_before
=
sender
.
stats
(
)
.
frame_tx
.
ack
;
let
receiver_acks_before
=
receiver
.
stats
(
)
.
frame_tx
.
ack
;
trickle
(
&
mut
sender
&
mut
receiver
COUNT
now
)
;
assert_eq
!
(
sender
.
stats
(
)
.
frame_tx
.
ack
sender_acks_before
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ack
receiver_acks_before
+
COUNT
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
now
+
=
receiver
.
pto
(
)
*
3
+
Duration
:
:
from_micros
(
1
)
;
trickle
(
&
mut
sender
&
mut
receiver
1
now
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
}
fn
expected_pto
(
rtt
:
Duration
)
-
>
Duration
{
rtt
+
rtt
*
9
/
8
+
DEFAULT_REMOTE_ACK_DELAY
}
#
[
test
]
fn
fast_pto
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
fast_pto
(
FAST_PTO_SCALE
/
2
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
res
=
client
.
process_output
(
now
)
;
let
idle_timeout
=
ConnectionParameters
:
:
DEFAULT_IDLE_TIMEOUT
.
checked_sub
(
DEFAULT_RTT
/
2
)
.
unwrap
(
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
idle_timeout
)
)
;
let
stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream
DEFAULT_STREAM_DATA
)
.
unwrap
(
)
DEFAULT_STREAM_DATA
.
len
(
)
)
;
now
+
=
idle_timeout
/
2
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
expected_pto
(
DEFAULT_RTT
)
/
2
cb
)
;
now
+
=
cb
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
stream_before
=
server
.
stats
(
)
.
frame_rx
.
stream
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
stream
stream_before
+
1
)
;
}
#
[
test
]
fn
fast_pto_persistent_congestion
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
fast_pto
(
FAST_PTO_SCALE
*
2
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
res
=
client
.
process_output
(
now
)
;
let
idle_timeout
=
ConnectionParameters
:
:
DEFAULT_IDLE_TIMEOUT
.
checked_sub
(
DEFAULT_RTT
/
2
)
.
unwrap
(
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
idle_timeout
)
)
;
let
pc_interval
=
expected_pto
(
DEFAULT_RTT
)
*
3
;
println
!
(
"
pc_interval
{
pc_interval
:
?
}
"
)
;
let
_drop1
=
send_something
(
&
mut
client
now
)
;
let
cb
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
expected_pto
(
DEFAULT_RTT
)
*
2
cb
)
;
now
+
=
pc_interval
;
let
_drop2
=
send_something
(
&
mut
client
now
)
;
let
_drop3
=
send_something
(
&
mut
client
now
)
;
let
_drop4
=
send_something
(
&
mut
client
now
)
;
let
dgram
=
send_something
(
&
mut
client
now
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
ack
=
server
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
cwnd
(
&
client
)
cwnd_min
(
&
client
)
)
;
}
#
[
test
]
fn
ack_for_unsent
(
)
{
struct
AckforUnsentWriter
{
}
impl
FrameWriter
for
AckforUnsentWriter
{
fn
write_frames
(
&
mut
self
builder
:
&
mut
packet
:
:
Builder
<
&
mut
Vec
<
u8
>
>
)
{
builder
.
encode_varint
(
FrameType
:
:
Ack
)
;
builder
.
encode_varint
(
666u16
)
;
builder
.
encode_varint
(
0u8
)
;
builder
.
encode_varint
(
0u8
)
;
builder
.
encode_varint
(
0u8
)
;
}
}
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
spoofed
=
server
.
test_write_frames
(
AckforUnsentWriter
{
}
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
client
.
process_input
(
spoofed
now
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closing
{
error
:
CloseReason
:
:
Transport
(
Error
:
:
AckedUnsentPacket
)
.
.
}
)
)
;
}
#
[
test
]
fn
pto_handshake_space_when_server_flight_lost
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
now
=
now
(
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
big
=
TransportParameter
:
:
Bytes
(
vec
!
[
0
;
Pmtud
:
:
default_plpmtu
(
DEFAULT_ADDR
.
ip
(
)
)
]
)
;
server
.
set_local_tparam
(
TestTransportParameter
big
)
.
unwrap
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
mut
server_dgrams
=
Vec
:
:
new
(
)
;
server_dgrams
.
push
(
server
.
process
(
c1
now
)
.
dgram
(
)
.
unwrap
(
)
)
;
while
let
Some
(
dgram
)
=
server
.
process_output
(
now
)
.
dgram
(
)
{
server_dgrams
.
push
(
dgram
)
;
}
assert
!
(
!
server_dgrams
.
is_empty
(
)
)
;
now
+
=
RTT
/
2
;
let
mut
found_hs
=
false
;
for
dgram
in
server_dgrams
{
let
(
first
second
)
=
split_datagram
(
&
dgram
)
;
if
is_initial
(
&
first
false
)
{
assert
!
(
!
found_hs
"
got
Initial
after
Handshake
"
)
;
if
let
Some
(
hs
)
=
second
{
found_hs
|
=
is_handshake
(
&
hs
)
;
}
client
.
process_input
(
first
now
)
;
}
else
{
found_hs
|
=
is_handshake
(
&
first
)
;
}
}
assert
!
(
found_hs
)
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Handshaking
)
;
let
pto
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_ne
!
(
pto
Duration
:
:
ZERO
)
;
now
+
=
pto
;
let
next_timeout
=
loop
{
if
let
Output
:
:
Callback
(
callback
)
=
client
.
process_output
(
now
)
{
break
callback
;
}
}
;
now
+
=
next_timeout
;
let
stats_before
=
client
.
stats
(
)
.
frame_tx
;
let
mut
pto_packets
=
Vec
:
:
new
(
)
;
while
let
Some
(
dgram
)
=
client
.
process_output
(
now
)
.
dgram
(
)
{
pto_packets
.
push
(
dgram
)
;
}
let
mut
has_handshake
=
false
;
for
dgram
in
&
pto_packets
{
let
(
first
second
)
=
split_datagram
(
dgram
)
;
has_handshake
|
=
is_handshake
(
&
first
)
|
|
second
.
as_ref
(
)
.
is_some_and
(
|
s
|
is_handshake
(
s
)
)
;
}
assert
!
(
has_handshake
&
&
client
.
stats
(
)
.
frame_tx
.
ping
>
stats_before
.
ping
)
;
}
