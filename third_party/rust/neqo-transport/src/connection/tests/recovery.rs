use
super
:
:
super
:
:
{
Output
State
LOCAL_IDLE_TIMEOUT
}
;
use
super
:
:
{
assert_full_cwnd
connect
connect_force_idle
connect_with_rtt
default_client
default_server
fill_cwnd
maybe_authenticate
send_and_receive
send_something
split_datagram
AT_LEAST_PTO
POST_HANDSHAKE_CWND
}
;
use
crate
:
:
frame
:
:
{
Frame
StreamType
}
;
use
crate
:
:
path
:
:
PATH_MTU_V6
;
use
crate
:
:
recovery
:
:
PTO_PACKET_COUNT
;
use
crate
:
:
stats
:
:
MAX_PTO_COUNTS
;
use
crate
:
:
tparams
:
:
TransportParameter
;
use
crate
:
:
tracking
:
:
{
PNSpace
ACK_DELAY
}
;
use
neqo_common
:
:
qdebug
;
use
neqo_crypto
:
:
AuthenticationStatus
;
use
std
:
:
time
:
:
Duration
;
use
test_fixture
:
:
{
self
now
}
;
#
[
test
]
fn
pto_works_basic
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
hello
"
)
.
unwrap
(
)
5
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
world
"
)
.
unwrap
(
)
6
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
6
)
;
assert_eq
!
(
client
.
stream_send
(
6
b
"
there
!
"
)
.
unwrap
(
)
6
)
;
now
+
=
Duration
:
:
from_secs
(
10
)
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
out
.
dgram
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
_
)
)
)
;
now
+
=
AT_LEAST_PTO
;
let
out
=
client
.
process
(
None
now
)
;
let
frames
=
server
.
test_process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert
!
(
frames
.
iter
(
)
.
all
(
|
(
_
sp
)
|
*
sp
=
=
PNSpace
:
:
ApplicationData
)
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
*
f
=
=
Frame
:
:
Ping
)
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
matches
!
(
f
Frame
:
:
Stream
{
stream_id
.
.
}
if
stream_id
.
as_u64
(
)
=
=
2
)
)
)
;
assert
!
(
frames
.
iter
(
)
.
any
(
|
(
f
_
)
|
matches
!
(
f
Frame
:
:
Stream
{
stream_id
.
.
}
if
stream_id
.
as_u64
(
)
=
=
6
)
)
)
;
}
#
[
test
]
fn
pto_works_full_cwnd
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
res
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
2
now
(
)
)
;
assert_full_cwnd
(
&
dgrams
POST_HANDSHAKE_CWND
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
2
now
+
AT_LEAST_PTO
)
;
assert_eq
!
(
dgrams
.
len
(
)
2
)
;
for
d
in
dgrams
{
assert_eq
!
(
d
.
len
(
)
PATH_MTU_V6
)
;
let
frames
=
server
.
test_process_input
(
d
now
)
;
assert_eq
!
(
frames
.
iter
(
)
.
filter
(
|
i
|
matches
!
(
i
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
)
.
count
(
)
1
)
;
assert
!
(
frames
.
iter
(
)
.
filter
(
|
i
|
matches
!
(
i
(
Frame
:
:
Stream
{
.
.
}
PNSpace
:
:
ApplicationData
)
)
)
.
count
(
)
>
=
1
)
;
}
}
#
[
test
]
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
fn
pto_works_ping
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
zero
"
)
.
unwrap
(
)
4
)
;
let
pkt0
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
pkt0
Output
:
:
Datagram
(
_
)
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
one
"
)
.
unwrap
(
)
3
)
;
let
pkt1
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
two
"
)
.
unwrap
(
)
3
)
;
let
pkt2
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
three
"
)
.
unwrap
(
)
5
)
;
let
pkt3
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
let
out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
x
)
if
x
=
=
Duration
:
:
from_millis
(
45
)
)
)
;
let
srv0_pkt1
=
server
.
process
(
pkt1
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert
!
(
matches
!
(
srv0_pkt1
Output
:
:
Datagram
(
_
)
)
)
;
let
srv2
=
server
.
process
(
pkt2
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
20
)
)
;
assert
!
(
matches
!
(
srv2
Output
:
:
Callback
(
_
)
)
)
;
let
srv2
=
server
.
process
(
pkt3
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
20
)
)
;
assert
!
(
matches
!
(
srv2
Output
:
:
Datagram
(
_
)
)
)
;
let
pkt4
=
client
.
process
(
srv2
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
40
)
)
;
assert
!
(
matches
!
(
pkt4
Output
:
:
Datagram
(
_
)
)
)
;
let
srv_pkt2
=
server
.
process
(
pkt0
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
40
)
)
;
assert
!
(
matches
!
(
srv_pkt2
Output
:
:
Datagram
(
_
)
)
)
;
let
pkt5
=
client
.
process
(
srv_pkt2
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
40
)
)
;
assert
!
(
matches
!
(
pkt5
Output
:
:
Callback
(
_
)
)
)
;
let
pkt6
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
110
)
)
;
let
frames
=
server
.
test_process_input
(
pkt6
.
dgram
(
)
.
unwrap
(
)
now
+
Duration
:
:
from_secs
(
10
)
+
Duration
:
:
from_millis
(
110
)
)
;
assert_eq
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
ApplicationData
)
)
;
}
#
[
test
]
fn
pto_initial
(
)
{
const
INITIAL_PTO
:
Duration
=
Duration
:
:
from_millis
(
300
)
;
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
assert_eq
!
(
pkt1
.
clone
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
now
+
=
delay
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
assert_eq
!
(
pkt2
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt3
.
is_some
(
)
)
;
assert_eq
!
(
pkt3
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
*
2
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
*
3
)
;
}
#
[
test
]
fn
pto_handshake_complete
(
)
{
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
client
.
process
(
None
now
)
.
dgram
(
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
300
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
client
.
process
(
pkt
now
)
.
dgram
(
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
60
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
assert
!
(
pkt
.
is_none
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
60
)
)
;
let
mut
pto_counts
=
[
0
;
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
Duration
:
:
from_millis
(
60
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt3
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
120
)
)
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
pkt
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
pkt
.
is_some
(
)
)
;
let
dropped_before1
=
server
.
stats
(
)
.
dropped_rx
;
let
frames
=
server
.
test_process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before1
)
;
assert
!
(
frames
.
is_empty
(
)
)
;
let
dropped_before2
=
server
.
stats
(
)
.
dropped_rx
;
let
frames
=
server
.
test_process_input
(
pkt3
.
unwrap
(
)
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before2
)
;
assert
!
(
frames
.
is_empty
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
cb
=
client
.
process
(
pkt
now
)
.
callback
(
)
;
assert_eq
!
(
cb
ACK_DELAY
)
;
now
+
=
cb
;
let
out
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
assert_eq
!
(
cb
LOCAL_IDLE_TIMEOUT
-
ACK_DELAY
)
;
}
#
[
test
]
fn
pto_handshake_frames
(
)
{
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt
=
client
.
process
(
None
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
server
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
pkt
=
client
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
_
=
server
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
zero
"
)
.
unwrap
(
)
4
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
and
1RTT
packet
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
60
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
60
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
frames
=
server
.
test_process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert_eq
!
(
frames
.
len
(
)
2
)
;
assert_eq
!
(
frames
[
0
]
(
Frame
:
:
Ping
PNSpace
:
:
Handshake
)
)
;
assert
!
(
matches
!
(
frames
[
1
]
(
Frame
:
:
Crypto
{
.
.
}
PNSpace
:
:
Handshake
)
)
)
;
}
#
[
test
]
fn
handshake_ack_pto
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
big
=
TransportParameter
:
:
Bytes
(
vec
!
[
0
;
PATH_MTU_V6
]
)
;
server
.
set_local_tparam
(
0xce16
big
)
.
unwrap
(
)
;
let
c1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
s2
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
(
initial
_
)
=
split_datagram
(
&
s1
.
unwrap
(
)
)
;
client
.
process_input
(
initial
now
)
;
let
c2
=
client
.
process
(
s2
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
RTT
*
3
)
;
let
mut
pto_counts
=
[
0
;
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
delay
;
let
c3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
frames
=
server
.
test_process_input
(
c3
.
unwrap
(
)
now
)
;
assert_eq
!
(
frames
vec
!
[
(
Frame
:
:
Ping
PNSpace
:
:
Handshake
)
]
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
dgram
=
server
.
process
(
None
now
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
}
#
[
test
]
fn
loss_recovery_crash
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
_
=
send_something
(
&
mut
server
now
)
;
let
ack
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
cb
=
server
.
process
(
ack
now
)
.
callback
(
)
;
assert
!
(
cb
>
Duration
:
:
from_secs
(
0
)
)
;
let
dgram
=
server
.
process
(
None
now
+
AT_LEAST_PTO
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
_
=
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
;
}
#
[
test
]
fn
ack_after_pto
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
_
=
send_something
(
&
mut
client
now
)
;
now
+
=
AT_LEAST_PTO
;
for
_
in
0
.
.
PTO_PACKET_COUNT
{
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
assert
!
(
client
.
process
(
None
now
)
.
dgram
(
)
.
is_none
(
)
)
;
let
_
=
send_something
(
&
mut
server
now
)
;
let
dgram
=
send_something
(
&
mut
server
now
)
;
let
ack
=
client
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
frames
=
server
.
test_process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
frames
.
len
(
)
1
)
;
for
(
frame
space
)
in
frames
{
assert_eq
!
(
space
PNSpace
:
:
ApplicationData
)
;
assert
!
(
matches
!
(
frame
Frame
:
:
Ack
{
.
.
}
)
)
;
}
}
#
[
test
]
fn
lost_but_kept_and_lr_timer
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
let
_p1
=
send_something
(
&
mut
client
now
)
;
let
p2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
ack
=
server
.
process
(
Some
(
p2
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
_p3
=
send_something
(
&
mut
client
now
)
;
let
p4
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer
=
res
.
callback
(
)
;
assert_ne
!
(
lr_timer
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_timer
<
(
RTT
/
2
)
)
;
let
ack
=
server
.
process
(
Some
(
p4
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
None
now
)
;
assert
!
(
res
.
dgram
(
)
.
is_some
(
)
)
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer2
=
res
.
callback
(
)
;
assert_eq
!
(
lr_timer
lr_timer2
)
;
}
#
[
test
]
fn
loss_time_past_largest_acked
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
10
)
;
const
INCR
:
Duration
=
Duration
:
:
from_millis
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_in
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s_hs1
=
server
.
process
(
c_in
now
)
.
dgram
(
)
;
let
s_pto
=
server
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
s_pto
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
s_pto
<
RTT
)
;
let
s_hs2
=
server
.
process
(
None
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs2
.
is_some
(
)
)
;
let
s_hs3
=
server
.
process
(
None
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
c_hs1
=
client
.
process
(
s_hs1
now
)
.
dgram
(
)
;
assert
!
(
c_hs1
.
is_some
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c_hs2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c_hs2
.
is_some
(
)
)
;
let
_p1
=
send_something
(
&
mut
client
now
+
INCR
)
;
let
c_hs3
=
client
.
process
(
s_hs2
now
+
(
INCR
*
2
)
)
.
dgram
(
)
;
assert
!
(
c_hs3
.
is_some
(
)
)
;
let
c_hs4
=
client
.
process
(
s_hs3
now
+
(
INCR
*
3
)
)
.
dgram
(
)
;
assert
!
(
c_hs4
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c_hs4
.
unwrap
(
)
now
)
;
let
s_ack
=
server
.
process
(
c_hs2
now
)
.
dgram
(
)
;
assert
!
(
s_ack
.
is_some
(
)
)
;
let
(
s_hs_ack
_s_ap_ack
)
=
split_datagram
(
&
s_ack
.
unwrap
(
)
)
;
now
+
=
RTT
/
2
;
let
c_ack
=
client
.
process
(
Some
(
s_hs_ack
)
now
)
.
dgram
(
)
;
assert
!
(
c_ack
.
is_none
(
)
)
;
let
lr_time
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
lr_time
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_time
<
(
RTT
/
2
)
)
;
now
+
=
lr_time
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
delay
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
delay
>
lr_time
)
;
}
