use
super
:
:
super
:
:
{
Connection
ConnectionParameters
Output
State
}
;
use
super
:
:
{
assert_full_cwnd
connect
connect_force_idle
connect_rtt_idle
connect_with_rtt
default_client
default_server
fill_cwnd
maybe_authenticate
send_and_receive
send_something
AT_LEAST_PTO
DEFAULT_RTT
POST_HANDSHAKE_CWND
}
;
use
crate
:
:
path
:
:
PATH_MTU_V6
;
use
crate
:
:
recovery
:
:
{
MAX_OUTSTANDING_UNACK
MIN_OUTSTANDING_UNACK
PTO_PACKET_COUNT
}
;
use
crate
:
:
rtt
:
:
GRANULARITY
;
use
crate
:
:
stats
:
:
MAX_PTO_COUNTS
;
use
crate
:
:
tparams
:
:
TransportParameter
;
use
crate
:
:
tracking
:
:
DEFAULT_ACK_DELAY
;
use
crate
:
:
StreamType
;
use
neqo_common
:
:
qdebug
;
use
neqo_crypto
:
:
AuthenticationStatus
;
use
std
:
:
mem
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
test_fixture
:
:
{
self
now
split_datagram
}
;
#
[
test
]
fn
pto_works_basic
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
let
idle_timeout
=
ConnectionParameters
:
:
default
(
)
.
get_idle_timeout
(
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
idle_timeout
)
)
;
let
stream1
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream1
b
"
hello
"
)
.
unwrap
(
)
5
)
;
assert_eq
!
(
client
.
stream_send
(
stream1
b
"
world
!
"
)
.
unwrap
(
)
7
)
;
let
stream2
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream2
b
"
there
!
"
)
.
unwrap
(
)
6
)
;
now
+
=
Duration
:
:
from_secs
(
10
)
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
out
.
dgram
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
Callback
(
_
)
)
)
;
now
+
=
AT_LEAST_PTO
;
let
out
=
client
.
process
(
None
now
)
;
let
stream_before
=
server
.
stats
(
)
.
frame_rx
.
stream
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
stream
stream_before
+
2
)
;
}
#
[
test
]
fn
pto_works_full_cwnd
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
connect_rtt_idle
(
&
mut
client
&
mut
server
DEFAULT_RTT
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
)
;
assert_full_cwnd
(
&
dgrams
POST_HANDSHAKE_CWND
)
;
let
(
dgrams
now
)
=
fill_cwnd
(
&
mut
client
stream_id
now
+
AT_LEAST_PTO
)
;
assert_eq
!
(
dgrams
.
len
(
)
2
)
;
assert_eq
!
(
dgrams
[
0
]
.
len
(
)
PATH_MTU_V6
)
;
for
d
in
dgrams
{
let
stream_before
=
server
.
stats
(
)
.
frame_rx
.
stream
;
server
.
process_input
(
d
now
)
;
assert
!
(
server
.
stats
(
)
.
frame_rx
.
stream
>
stream_before
)
;
}
}
#
[
test
]
fn
pto_works_ping
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
ConnectionParameters
:
:
default
(
)
.
get_idle_timeout
(
)
)
)
;
now
+
=
Duration
:
:
from_secs
(
10
)
;
let
pkt0
=
send_something
(
&
mut
client
now
)
;
let
pkt1
=
send_something
(
&
mut
client
now
)
;
let
pkt2
=
send_something
(
&
mut
client
now
)
;
let
pkt3
=
send_something
(
&
mut
client
now
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
GRANULARITY
*
2
)
;
let
srv0
=
server
.
process
(
Some
(
pkt1
)
now
)
.
dgram
(
)
;
assert
!
(
srv0
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
20
)
;
let
srv1
=
server
.
process
(
Some
(
pkt2
)
now
)
.
dgram
(
)
;
assert
!
(
srv1
.
is_none
(
)
)
;
let
srv2
=
server
.
process
(
Some
(
pkt3
)
now
)
.
dgram
(
)
;
assert
!
(
srv2
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
20
)
;
let
pkt4
=
client
.
process
(
srv2
now
)
.
dgram
(
)
;
assert
!
(
pkt4
.
is_some
(
)
)
;
let
srv3
=
server
.
process
(
Some
(
pkt0
)
now
)
.
dgram
(
)
;
assert
!
(
srv3
.
is_some
(
)
)
;
let
pkt5
=
client
.
process
(
srv3
now
)
.
dgram
(
)
;
assert
!
(
pkt5
.
is_none
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
70
)
;
let
client_pings
=
client
.
stats
(
)
.
frame_tx
.
ping
;
let
pkt6
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ping
client_pings
+
1
)
;
let
server_pings
=
server
.
stats
(
)
.
frame_rx
.
ping
;
server
.
process_input
(
pkt6
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ping
server_pings
+
1
)
;
}
#
[
test
]
fn
pto_initial
(
)
{
const
INITIAL_PTO
:
Duration
=
Duration
:
:
from_millis
(
300
)
;
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
assert_eq
!
(
pkt1
.
clone
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
now
+
=
delay
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
assert_eq
!
(
pkt2
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt3
.
is_some
(
)
)
;
assert_eq
!
(
pkt3
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
*
2
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
*
3
)
;
}
#
[
test
]
fn
pto_handshake_complete
(
)
{
const
HALF_RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
client
.
process
(
None
now
)
.
dgram
(
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
Duration
:
:
from_millis
(
300
)
)
;
now
+
=
HALF_RTT
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
now
+
=
HALF_RTT
;
let
pkt
=
client
.
process
(
pkt
now
)
.
dgram
(
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
HALF_RTT
*
6
)
;
now
+
=
HALF_RTT
;
let
pkt
=
server
.
process
(
pkt
now
)
.
dgram
(
)
;
assert
!
(
pkt
.
is_none
(
)
)
;
now
+
=
HALF_RTT
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
HALF_RTT
*
6
)
;
let
mut
pto_counts
=
[
0
;
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qdebug
!
(
"
-
-
-
-
client
:
PTO
"
)
;
now
+
=
HALF_RTT
*
6
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
let
pkt3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
let
(
pkt3_hs
pkt3_1rtt
)
=
split_datagram
(
&
pkt3
.
unwrap
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
cb
HALF_RTT
*
12
)
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
qdebug
!
(
"
-
-
-
-
server
:
receive
FIN
and
send
ACK
"
)
;
now
+
=
HALF_RTT
;
let
server_acks
=
server
.
stats
(
)
.
frame_tx
.
ack
;
let
server_done
=
server
.
stats
(
)
.
frame_tx
.
handshake_done
;
server
.
process_input
(
pkt3_1rtt
.
unwrap
(
)
now
)
;
let
ack
=
server
.
process
(
pkt1
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
ack
server_acks
+
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
.
handshake_done
server_done
+
1
)
;
let
dropped_before1
=
server
.
stats
(
)
.
dropped_rx
;
let
server_frames
=
server
.
stats
(
)
.
frame_rx
.
all
;
server
.
process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before1
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
all
server_frames
)
;
let
dropped_before2
=
server
.
stats
(
)
.
dropped_rx
;
server
.
process_input
(
pkt3_hs
now
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
-
dropped_before2
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
all
server_frames
)
;
now
+
=
HALF_RTT
;
let
cb
=
client
.
process
(
ack
now
)
.
callback
(
)
;
let
expected_ack_delay
=
HALF_RTT
*
2
/
4
;
assert_eq
!
(
cb
expected_ack_delay
)
;
now
+
=
cb
;
let
out
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
out
.
is_some
(
)
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
let
idle_timeout
=
ConnectionParameters
:
:
default
(
)
.
get_idle_timeout
(
)
;
assert_eq
!
(
cb
idle_timeout
-
expected_ack_delay
)
;
}
#
[
test
]
fn
pto_handshake_frames
(
)
{
let
mut
now
=
now
(
)
;
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
pkt
=
client
.
process
(
None
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
pkt
=
server
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
pkt
=
client
.
process
(
pkt
.
dgram
(
)
now
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
mem
:
:
drop
(
server
.
process
(
pkt
.
dgram
(
)
now
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
b
"
zero
"
)
.
unwrap
(
)
4
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
and
1RTT
packet
"
)
;
let
pkt1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt1
.
is_some
(
)
)
;
let
out
=
client
.
process
(
None
now
)
;
assert_eq
!
(
out
Output
:
:
Callback
(
Duration
:
:
from_millis
(
60
)
)
)
;
now
+
=
Duration
:
:
from_millis
(
60
)
;
let
pkt2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pkt2
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_millis
(
10
)
;
let
crypto_before
=
server
.
stats
(
)
.
frame_rx
.
crypto
;
server
.
process_input
(
pkt2
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
crypto
crypto_before
+
1
)
}
#
[
test
]
fn
handshake_ack_pto
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
big
=
TransportParameter
:
:
Bytes
(
vec
!
[
0
;
PATH_MTU_V6
]
)
;
server
.
set_local_tparam
(
0xce16
big
)
.
unwrap
(
)
;
let
c1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
s2
=
server
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
(
initial
_
)
=
split_datagram
(
&
s1
.
unwrap
(
)
)
;
client
.
process_input
(
initial
now
)
;
let
c2
=
client
.
process
(
s2
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
delay
RTT
*
3
)
;
let
mut
pto_counts
=
[
0
;
MAX_PTO_COUNTS
]
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
now
+
=
delay
;
let
c3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
ping_before
=
server
.
stats
(
)
.
frame_rx
.
ping
;
server
.
process_input
(
c3
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ping
ping_before
+
1
)
;
pto_counts
[
0
]
=
1
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
let
dgram
=
server
.
process
(
None
now
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
stats
.
borrow
(
)
.
pto_counts
pto_counts
)
;
}
#
[
test
]
fn
loss_recovery_crash
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
mem
:
:
drop
(
send_something
(
&
mut
server
now
)
)
;
let
ack
=
send_and_receive
(
&
mut
server
&
mut
client
now
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
cb
=
server
.
process
(
ack
now
)
.
callback
(
)
;
assert
!
(
cb
>
Duration
:
:
from_secs
(
0
)
)
;
let
dgram
=
server
.
process
(
None
now
+
AT_LEAST_PTO
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
mem
:
:
drop
(
send_something
(
&
mut
server
now
+
AT_LEAST_PTO
)
)
;
}
#
[
test
]
fn
ack_after_pto
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
mem
:
:
drop
(
send_something
(
&
mut
client
now
)
)
;
now
+
=
AT_LEAST_PTO
;
for
_
in
0
.
.
PTO_PACKET_COUNT
{
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
}
assert
!
(
client
.
process
(
None
now
)
.
dgram
(
)
.
is_none
(
)
)
;
mem
:
:
drop
(
send_something
(
&
mut
server
now
)
)
;
let
dgram
=
send_something
(
&
mut
server
now
)
;
let
ack
=
client
.
process
(
Some
(
dgram
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
all_frames_before
=
server
.
stats
(
)
.
frame_rx
.
all
;
let
ack_before
=
server
.
stats
(
)
.
frame_rx
.
ack
;
server
.
process_input
(
ack
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
all
all_frames_before
+
1
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ack
ack_before
+
1
)
;
}
#
[
test
]
fn
lost_but_kept_and_lr_timer
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
let
_p1
=
send_something
(
&
mut
client
now
)
;
let
p2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
ack
=
server
.
process
(
Some
(
p2
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
let
_p3
=
send_something
(
&
mut
client
now
)
;
let
p4
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer
=
res
.
callback
(
)
;
assert_ne
!
(
lr_timer
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_timer
<
(
RTT
/
2
)
)
;
let
ack
=
server
.
process
(
Some
(
p4
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
res
=
client
.
process
(
None
now
)
;
assert
!
(
res
.
dgram
(
)
.
is_some
(
)
)
;
let
res
=
client
.
process
(
ack
now
)
;
let
lr_timer2
=
res
.
callback
(
)
;
assert_eq
!
(
lr_timer
lr_timer2
)
;
}
#
[
test
]
fn
loss_time_past_largest_acked
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
10
)
;
const
INCR
:
Duration
=
Duration
:
:
from_millis
(
1
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_in
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s_hs1
=
server
.
process
(
c_in
now
)
.
dgram
(
)
;
let
s_pto
=
server
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
s_pto
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
s_pto
<
RTT
)
;
let
s_hs2
=
server
.
process
(
None
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs2
.
is_some
(
)
)
;
let
s_hs3
=
server
.
process
(
None
now
+
s_pto
)
.
dgram
(
)
;
assert
!
(
s_hs3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
c_hs1
=
client
.
process
(
s_hs1
now
)
.
dgram
(
)
;
assert
!
(
c_hs1
.
is_some
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c_hs2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c_hs2
.
is_some
(
)
)
;
let
_p1
=
send_something
(
&
mut
client
now
+
INCR
)
;
let
c_hs3
=
client
.
process
(
s_hs2
now
+
(
INCR
*
2
)
)
.
dgram
(
)
;
assert
!
(
c_hs3
.
is_some
(
)
)
;
let
c_hs4
=
client
.
process
(
s_hs3
now
+
(
INCR
*
3
)
)
.
dgram
(
)
;
assert
!
(
c_hs4
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c_hs4
.
unwrap
(
)
now
)
;
let
s_ack
=
server
.
process
(
c_hs2
now
)
.
dgram
(
)
;
assert
!
(
s_ack
.
is_some
(
)
)
;
let
(
s_hs_ack
_s_ap_ack
)
=
split_datagram
(
&
s_ack
.
unwrap
(
)
)
;
now
+
=
RTT
/
2
;
let
c_ack
=
client
.
process
(
Some
(
s_hs_ack
)
now
)
.
dgram
(
)
;
assert
!
(
c_ack
.
is_none
(
)
)
;
let
lr_time
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
lr_time
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
lr_time
<
(
RTT
/
2
)
)
;
now
+
=
lr_time
;
let
delay
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
delay
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
delay
>
lr_time
)
;
}
fn
trickle
(
sender
:
&
mut
Connection
receiver
:
&
mut
Connection
mut
count
:
usize
now
:
Instant
)
{
let
id
=
sender
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
mut
maybe_ack
=
None
;
while
count
>
0
{
qdebug
!
(
"
trickle
:
remaining
=
{
}
"
count
)
;
assert_eq
!
(
sender
.
stream_send
(
id
&
[
9
]
)
.
unwrap
(
)
1
)
;
let
dgram
=
sender
.
process
(
maybe_ack
now
)
.
dgram
(
)
;
maybe_ack
=
receiver
.
process
(
dgram
now
)
.
dgram
(
)
;
count
-
=
usize
:
:
from
(
maybe_ack
.
is_some
(
)
)
;
}
sender
.
process_input
(
maybe_ack
.
unwrap
(
)
now
)
;
}
fn
ping_with_ack
(
fast
:
bool
)
{
let
mut
sender
=
default_client
(
)
;
let
mut
receiver
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
connect_force_idle
(
&
mut
sender
&
mut
receiver
)
;
let
sender_acks_before
=
sender
.
stats
(
)
.
frame_tx
.
ack
;
let
receiver_acks_before
=
receiver
.
stats
(
)
.
frame_tx
.
ack
;
let
count
=
if
fast
{
MAX_OUTSTANDING_UNACK
}
else
{
MIN_OUTSTANDING_UNACK
}
;
trickle
(
&
mut
sender
&
mut
receiver
count
now
)
;
assert_eq
!
(
sender
.
stats
(
)
.
frame_tx
.
ack
sender_acks_before
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ack
receiver_acks_before
+
count
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
if
!
fast
{
now
+
=
receiver
.
pto
(
)
+
Duration
:
:
from_micros
(
1
)
;
trickle
(
&
mut
sender
&
mut
receiver
1
now
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
}
now
+
=
receiver
.
pto
(
)
+
Duration
:
:
from_micros
(
1
)
;
trickle
(
&
mut
sender
&
mut
receiver
1
now
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
1
)
;
if
let
Output
:
:
Callback
(
t
)
=
sender
.
process_output
(
now
)
{
assert_eq
!
(
t
DEFAULT_ACK_DELAY
)
;
assert
!
(
sender
.
process_output
(
now
+
t
)
.
dgram
(
)
.
is_some
(
)
)
;
}
assert_eq
!
(
sender
.
stats
(
)
.
frame_tx
.
ack
sender_acks_before
+
1
)
;
}
#
[
test
]
fn
ping_with_ack_fast
(
)
{
ping_with_ack
(
true
)
;
}
#
[
test
]
fn
ping_with_ack_slow
(
)
{
ping_with_ack
(
false
)
;
}
#
[
test
]
fn
ping_with_ack_min
(
)
{
const
COUNT
:
usize
=
MIN_OUTSTANDING_UNACK
-
2
;
let
mut
sender
=
default_client
(
)
;
let
mut
receiver
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
connect_force_idle
(
&
mut
sender
&
mut
receiver
)
;
let
sender_acks_before
=
sender
.
stats
(
)
.
frame_tx
.
ack
;
let
receiver_acks_before
=
receiver
.
stats
(
)
.
frame_tx
.
ack
;
trickle
(
&
mut
sender
&
mut
receiver
COUNT
now
)
;
assert_eq
!
(
sender
.
stats
(
)
.
frame_tx
.
ack
sender_acks_before
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ack
receiver_acks_before
+
COUNT
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
now
+
=
receiver
.
pto
(
)
*
3
+
Duration
:
:
from_micros
(
1
)
;
trickle
(
&
mut
sender
&
mut
receiver
1
now
)
;
assert_eq
!
(
receiver
.
stats
(
)
.
frame_tx
.
ping
0
)
;
}
