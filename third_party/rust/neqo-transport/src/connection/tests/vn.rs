use
std
:
:
time
:
:
Duration
;
use
neqo_common
:
:
{
event
:
:
Provider
as
_
Decoder
Dscp
Encoder
}
;
use
test_fixture
:
:
{
assertions
:
:
{
self
assert_initial
assert_version
}
datagram
now
split_datagram
strip_padding
}
;
use
super
:
:
{
super
:
:
{
CloseReason
ConnectionEvent
Output
State
ZeroRttState
}
connect
connect_fail
default_client
default_server
exchange_ticket
new_client
new_server
send_something
}
;
use
crate
:
:
{
connection
:
:
{
test_internal
tests
:
:
{
connect_rtt_idle_with_modifier
AT_LEAST_PTO
}
}
frame
:
:
FrameType
packet
:
:
{
self
}
tparams
:
:
{
TransportParameter
TransportParameterId
:
:
*
}
ConnectionParameters
Error
Stats
Version
MIN_INITIAL_PACKET_SIZE
}
;
const
INITIAL_PTO
:
Duration
=
Duration
:
:
from_millis
(
300
)
;
pub
fn
assert_dscp
(
stats
:
&
Stats
)
{
assert_eq
!
(
stats
.
dscp_rx
[
Dscp
:
:
Cs0
]
stats
.
packets_rx
)
;
}
#
[
test
]
fn
unknown_version
(
)
{
let
mut
client
=
default_client
(
)
;
drop
(
client
.
process_output
(
now
(
)
)
.
dgram
(
)
)
;
let
mut
unknown_version_packet
=
vec
!
[
0x80
0x1a
0x1a
0x1a
0x1a
]
;
unknown_version_packet
.
resize
(
MIN_INITIAL_PACKET_SIZE
0x0
)
;
drop
(
client
.
process
(
Some
(
datagram
(
unknown_version_packet
)
)
now
(
)
)
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
server_receive_unknown_first_packet
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
unknown_version_packet
=
vec
!
[
0x80
0x1a
0x1a
0x1a
0x1a
]
;
unknown_version_packet
.
resize
(
MIN_INITIAL_PACKET_SIZE
0x0
)
;
assert_eq
!
(
server
.
process
(
Some
(
datagram
(
unknown_version_packet
)
)
now
(
)
)
Output
:
:
None
)
;
assert_eq
!
(
1
server
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
server
.
stats
(
)
)
;
}
fn
create_vn
(
initial_pkt
:
&
[
u8
]
versions
:
&
[
u32
]
)
-
>
Vec
<
u8
>
{
let
mut
dec
=
Decoder
:
:
from
(
&
initial_pkt
[
5
.
.
]
)
;
let
dst_cid
=
dec
.
decode_vec
(
1
)
.
expect
(
"
client
DCID
"
)
;
let
src_cid
=
dec
.
decode_vec
(
1
)
.
expect
(
"
client
SCID
"
)
;
let
mut
encoder
=
Encoder
:
:
default
(
)
;
encoder
.
encode_byte
(
packet
:
:
BIT_LONG
)
;
encoder
.
encode
(
[
0
;
4
]
)
;
encoder
.
encode_vec
(
1
src_cid
)
;
encoder
.
encode_vec
(
1
dst_cid
)
;
for
v
in
versions
{
encoder
.
encode_uint
(
4
*
v
)
;
}
encoder
.
into
(
)
}
#
[
test
]
fn
version_negotiation_current_version
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
_
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
Version
:
:
default
(
)
.
wire_version
(
)
]
)
;
let
dgram
=
datagram
(
vn
)
;
let
mut
delay
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
.
callback
(
)
;
delay
+
=
client
.
process_output
(
now
(
)
+
delay
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
version_negotiation_version0
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
_
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0
0x1a1a_1a1a
]
)
;
let
dgram
=
datagram
(
vn
)
;
let
mut
delay
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
.
callback
(
)
;
delay
+
=
client
.
process_output
(
now
(
)
+
delay
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
version_negotiation_only_reserved
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
]
)
;
let
dgram
=
datagram
(
vn
)
;
assert_eq
!
(
client
.
process
(
Some
(
dgram
)
now
(
)
)
Output
:
:
None
)
;
match
client
.
state
(
)
{
State
:
:
Closed
(
err
)
=
>
{
assert_eq
!
(
*
err
CloseReason
:
:
Transport
(
Error
:
:
VersionNegotiation
)
)
;
}
_
=
>
panic
!
(
"
Invalid
client
state
"
)
}
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
version_negotiation_corrupted
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
_
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
]
)
;
let
dgram
=
datagram
(
vn
[
.
.
vn
.
len
(
)
-
1
]
.
to_vec
(
)
)
;
let
mut
delay
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
.
callback
(
)
;
delay
+
=
client
.
process_output
(
now
(
)
+
delay
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
version_negotiation_empty
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
_
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
]
)
;
let
dgram
=
datagram
(
vn
)
;
let
mut
delay
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
.
callback
(
)
;
delay
+
=
client
.
process_output
(
now
(
)
+
delay
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
version_negotiation_not_supported
(
)
{
let
mut
client
=
default_client
(
)
;
let
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
0xff00_0001
]
)
;
let
dgram
=
datagram
(
vn
)
;
assert_eq
!
(
client
.
process
(
Some
(
dgram
)
now
(
)
)
Output
:
:
None
)
;
match
client
.
state
(
)
{
State
:
:
Closed
(
err
)
=
>
{
assert_eq
!
(
*
err
CloseReason
:
:
Transport
(
Error
:
:
VersionNegotiation
)
)
;
}
_
=
>
panic
!
(
"
Invalid
client
state
"
)
}
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
version_negotiation_bad_cid
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
initial_pkt
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
.
to_vec
(
)
;
_
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
initial_pkt
[
6
]
^
=
0xc4
;
let
vn
=
create_vn
(
&
initial_pkt
&
[
0x1a1a_1a1a
0x2a2a_2a2a
0xff00_0001
]
)
;
let
dgram
=
datagram
(
vn
)
;
let
mut
delay
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
.
callback
(
)
;
delay
+
=
client
.
process_output
(
now
(
)
+
delay
)
.
callback
(
)
;
assert_eq
!
(
delay
INITIAL_PTO
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
WaitInitial
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
}
#
[
test
]
fn
compatible_upgrade
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
version
(
)
Version
:
:
Version2
)
;
assert_eq
!
(
server
.
version
(
)
Version
:
:
Version2
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
assert_dscp
(
&
server
.
stats
(
)
)
;
}
#
[
test
]
fn
compatible_upgrade_large_initial
(
)
{
let
params
=
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
;
let
mut
client
=
new_client
(
params
.
clone
(
)
)
;
client
.
set_local_tparam
(
TestTransportParameter
TransportParameter
:
:
Bytes
(
vec
!
[
0
;
2048
]
)
)
.
unwrap
(
)
;
let
mut
server
=
new_server
(
params
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
map
(
strip_padding
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
map
(
strip_padding
)
;
assert
!
(
dgram
.
is_some
(
)
&
&
dgram2
.
is_some
(
)
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
dgram
=
server
.
process
(
dgram2
now
(
)
)
.
dgram
(
)
.
map
(
strip_padding
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_version
(
dgram
.
as_ref
(
)
.
unwrap
(
)
Version
:
:
Version1
.
wire_version
(
)
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
connect_rtt_idle_with_modifier
(
&
mut
client
&
mut
server
Duration
:
:
new
(
0
0
)
|
dgram
|
{
Some
(
strip_padding
(
dgram
)
)
}
)
;
assert_eq
!
(
client
.
version
(
)
Version
:
:
Version2
)
;
assert_eq
!
(
server
.
version
(
)
Version
:
:
Version2
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
0
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
assert_dscp
(
&
server
.
stats
(
)
)
;
}
#
[
test
]
fn
compatible_no_upgrade
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version1
Version
:
:
Version2
]
)
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
version
(
)
Version
:
:
Version1
)
;
assert_eq
!
(
server
.
version
(
)
Version
:
:
Version1
)
;
}
#
[
test
]
fn
compatible_downgrade
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version2
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version2
vec
!
[
Version
:
:
Version1
Version
:
:
Version2
]
)
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
version
(
)
Version
:
:
Version1
)
;
assert_eq
!
(
server
.
version
(
)
Version
:
:
Version1
)
;
}
#
[
test
]
fn
version_negotiation_downgrade
(
)
{
const
DOWNGRADE
:
Version
=
Version
:
:
Draft29
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
DOWNGRADE
Version
:
:
all
(
)
)
)
;
let
initial
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
vn
=
create_vn
(
&
initial
&
[
DOWNGRADE
.
wire_version
(
)
]
)
;
let
dgram
=
datagram
(
vn
)
;
client
.
process_input
(
dgram
now
(
)
)
;
connect_fail
(
&
mut
client
&
mut
server
Error
:
:
VersionNegotiation
Error
:
:
Peer
(
Error
:
:
VersionNegotiation
.
code
(
)
)
)
;
}
#
[
test
]
fn
invalid_server_version
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
Version
:
:
all
(
)
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version2
Version
:
:
all
(
)
)
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
server
.
process_input
(
dgram2
.
unwrap
(
)
now
(
)
)
;
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
3
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
1
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
0
)
;
match
server
.
state
(
)
{
State
:
:
Closed
(
err
)
=
>
{
assert_eq
!
(
*
err
CloseReason
:
:
Transport
(
Error
:
:
CryptoAlert
(
47
)
)
)
;
}
_
=
>
panic
!
(
"
invalid
server
state
"
)
}
}
#
[
test
]
fn
invalid_current_version_client
(
)
{
const
OTHER_VERSION
:
Version
=
Version
:
:
Draft29
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
assert_ne
!
(
OTHER_VERSION
client
.
version
(
)
)
;
client
.
set_local_tparam
(
VersionInformation
TransportParameter
:
:
Versions
{
current
:
OTHER_VERSION
.
wire_version
(
)
other
:
Version
:
:
all
(
)
.
iter
(
)
.
copied
(
)
.
map
(
Version
:
:
wire_version
)
.
collect
(
)
}
)
.
unwrap
(
)
;
connect_fail
(
&
mut
client
&
mut
server
Error
:
:
Peer
(
Error
:
:
CryptoAlert
(
47
)
.
code
(
)
)
Error
:
:
CryptoAlert
(
47
)
)
;
}
#
[
test
]
fn
invalid_current_version_server
(
)
{
const
OTHER_VERSION
:
Version
=
Version
:
:
Draft29
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
default
(
)
vec
!
[
Version
:
:
default
(
)
]
)
)
;
assert
!
(
!
Version
:
:
default
(
)
.
is_compatible
(
OTHER_VERSION
)
)
;
server
.
set_local_tparam
(
VersionInformation
TransportParameter
:
:
Versions
{
current
:
OTHER_VERSION
.
wire_version
(
)
other
:
vec
!
[
OTHER_VERSION
.
wire_version
(
)
]
}
)
.
unwrap
(
)
;
connect_fail
(
&
mut
client
&
mut
server
Error
:
:
CryptoAlert
(
47
)
Error
:
:
Peer
(
Error
:
:
CryptoAlert
(
47
)
.
code
(
)
)
)
;
}
#
[
test
]
fn
no_compatible_version
(
)
{
const
OTHER_VERSION
:
Version
=
Version
:
:
Draft29
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
assert_ne
!
(
OTHER_VERSION
client
.
version
(
)
)
;
client
.
set_local_tparam
(
VersionInformation
TransportParameter
:
:
Versions
{
current
:
Version
:
:
default
(
)
.
wire_version
(
)
other
:
vec
!
[
OTHER_VERSION
.
wire_version
(
)
]
}
)
.
unwrap
(
)
;
connect_fail
(
&
mut
client
&
mut
server
Error
:
:
Peer
(
Error
:
:
CryptoAlert
(
47
)
.
code
(
)
)
Error
:
:
CryptoAlert
(
47
)
)
;
}
#
[
test
]
fn
compatible_upgrade_0rtt_rejected
(
)
{
let
prefer_v2
=
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
;
let
mut
client
=
new_client
(
prefer_v2
.
clone
(
)
)
;
let
just_v1
=
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version1
]
)
;
let
mut
server
=
new_server
(
just_v1
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
version
(
)
Version
:
:
Version1
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
new_client
(
prefer_v2
.
clone
(
)
)
;
let
mut
server
=
new_server
(
prefer_v2
)
;
client
.
enable_resumption
(
now
(
)
token
)
.
unwrap
(
)
;
let
initial
=
send_something
(
&
mut
client
now
(
)
)
;
let
initial2
=
send_something
(
&
mut
client
now
(
)
)
;
assert_version
(
&
initial
Version
:
:
Version1
.
wire_version
(
)
)
;
assertions
:
:
assert_coalesced_0rtt
(
&
initial2
)
;
server
.
process_input
(
initial
now
(
)
)
;
server
.
process_input
(
initial2
now
(
)
)
;
assert
!
(
!
server
.
events
(
)
.
any
(
|
e
|
matches
!
(
e
ConnectionEvent
:
:
NewStream
{
.
.
}
)
)
)
;
let
dgram
=
server
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
assert
!
(
matches
!
(
server
.
state
(
)
State
:
:
Confirmed
)
)
;
assert
!
(
client
.
events
(
)
.
any
(
|
e
|
{
println
!
(
"
client
event
:
{
e
:
?
}
"
)
;
matches
!
(
e
ConnectionEvent
:
:
ZeroRttRejected
)
}
)
)
;
assert_eq
!
(
client
.
zero_rtt_state
(
)
ZeroRttState
:
:
Rejected
)
;
}
#
[
test
]
fn
server_initial_versions
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
)
;
let
now
=
now
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
&
&
c2
.
is_some
(
)
)
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert_version
(
s1
.
as_ref
(
)
.
unwrap
(
)
Version
:
:
Version1
.
wire_version
(
)
)
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert_version
(
s2
.
as_ref
(
)
.
unwrap
(
)
Version
:
:
Version2
.
wire_version
(
)
)
;
client
.
process_input
(
s1
.
unwrap
(
)
now
)
;
let
(
s2_init
_s2_hs
)
=
split_datagram
(
&
s2
.
unwrap
(
)
)
;
client
.
process_input
(
s2_init
now
)
;
let
c3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_initial
(
c3
.
as_ref
(
)
.
unwrap
(
)
false
)
;
let
(
c3_init
_padding
)
=
split_datagram
(
&
c3
.
unwrap
(
)
)
;
let
before
=
server
.
stats
(
)
;
server
.
process_input
(
c3_init
now
)
;
let
after
=
server
.
stats
(
)
;
assert_eq
!
(
before
.
packets_rx
+
1
after
.
packets_rx
)
;
assert_eq
!
(
before
.
dropped_rx
after
.
dropped_rx
)
;
}
#
[
test
]
fn
client_initial_versions
(
)
{
pub
struct
CryptoWriter
{
}
impl
test_internal
:
:
FrameWriter
for
CryptoWriter
{
fn
write_frames
(
&
mut
self
builder
:
&
mut
packet
:
:
Builder
<
&
mut
Vec
<
u8
>
>
)
{
builder
.
encode_varint
(
FrameType
:
:
Crypto
)
;
builder
.
encode_varint
(
0_u64
)
;
builder
.
encode_varint
(
1_u64
)
;
builder
.
encode_byte
(
2
)
;
}
}
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
versions
(
Version
:
:
Version1
vec
!
[
Version
:
:
Version2
Version
:
:
Version1
]
)
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
&
&
c2
.
is_some
(
)
)
;
server
.
test_frame_writer
=
Some
(
Box
:
:
new
(
CryptoWriter
{
}
)
)
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
server
.
test_frame_writer
=
None
;
assert_version
(
s1
.
as_ref
(
)
.
unwrap
(
)
Version
:
:
Version1
.
wire_version
(
)
)
;
client
.
process_input
(
s1
.
unwrap
(
)
now
)
;
now
+
=
AT_LEAST_PTO
;
let
c3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
server
.
process_input
(
c3
.
unwrap
(
)
now
)
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert_version
(
s2
.
as_ref
(
)
.
unwrap
(
)
Version
:
:
Version2
.
wire_version
(
)
)
;
let
(
s2_init
_padding
)
=
split_datagram
(
&
s2
.
unwrap
(
)
)
;
let
before
=
client
.
stats
(
)
;
client
.
process_input
(
s2_init
now
)
;
let
after
=
client
.
stats
(
)
;
assert_eq
!
(
before
.
packets_rx
+
1
after
.
packets_rx
)
;
assert_eq
!
(
before
.
dropped_rx
after
.
dropped_rx
)
;
}
#
[
test
]
fn
tls_hello_retry_request
(
)
{
use
neqo_crypto
:
:
constants
:
:
{
TLS_GRP_EC_SECP256R1
TLS_GRP_EC_SECP384R1
TLS_GRP_EC_X25519
}
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
client
.
set_groups
(
&
[
TLS_GRP_EC_X25519
TLS_GRP_EC_SECP384R1
TLS_GRP_EC_SECP256R1
]
)
.
unwrap
(
)
;
server
.
set_groups
(
&
[
TLS_GRP_EC_SECP256R1
]
)
.
unwrap
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
}
