use
super
:
:
super
:
:
{
IdleTimeout
Output
State
LOCAL_IDLE_TIMEOUT
}
;
use
super
:
:
{
connect
connect_force_idle
connect_with_rtt
default_client
default_server
maybe_authenticate
send_and_receive
send_something
AT_LEAST_PTO
}
;
use
crate
:
:
packet
:
:
PacketBuilder
;
use
crate
:
:
stats
:
:
FrameStats
;
use
crate
:
:
tparams
:
:
{
self
TransportParameter
}
;
use
crate
:
:
tracking
:
:
PacketNumberSpace
;
use
crate
:
:
StreamType
;
use
neqo_common
:
:
Encoder
;
use
std
:
:
time
:
:
Duration
;
use
test_fixture
:
:
{
self
now
split_datagram
}
;
#
[
test
]
fn
idle_timeout
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
-
Duration
:
:
from_secs
(
1
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
asymmetric_idle_timeout
(
)
{
const
LOWER_TIMEOUT_MS
:
u64
=
1000
;
const
LOWER_TIMEOUT
:
Duration
=
Duration
:
:
from_millis
(
LOWER_TIMEOUT_MS
)
;
assert
!
(
LOWER_TIMEOUT
<
LOCAL_IDLE_TIMEOUT
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
tps
.
borrow_mut
(
)
.
local
.
set_integer
(
tparams
:
:
IDLE_TIMEOUT
LOWER_TIMEOUT_MS
)
;
server
.
idle_timeout
=
IdleTimeout
:
:
new
(
LOWER_TIMEOUT
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
c1
=
send_something
(
&
mut
client
now
(
)
)
;
let
c2
=
send_something
(
&
mut
client
now
(
)
)
;
server
.
process_input
(
c2
now
(
)
)
;
server
.
process_input
(
c1
now
(
)
)
;
let
s1
=
send_something
(
&
mut
server
now
(
)
)
;
let
s2
=
send_something
(
&
mut
server
now
(
)
)
;
client
.
process_input
(
s2
now
(
)
)
;
let
ack
=
client
.
process
(
Some
(
s1
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
assert_eq
!
(
server
.
process
(
ack
now
(
)
)
Output
:
:
Callback
(
LOWER_TIMEOUT
)
)
;
assert_eq
!
(
client
.
process
(
None
now
(
)
)
Output
:
:
Callback
(
LOWER_TIMEOUT
)
)
;
}
#
[
test
]
fn
tiny_idle_timeout
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
500
)
;
const
LOWER_TIMEOUT_MS
:
u64
=
100
;
const
LOWER_TIMEOUT
:
Duration
=
Duration
:
:
from_millis
(
LOWER_TIMEOUT_MS
)
;
assert
!
(
LOWER_TIMEOUT
<
3
*
RTT
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
set_local_tparam
(
tparams
:
:
IDLE_TIMEOUT
TransportParameter
:
:
Integer
(
LOWER_TIMEOUT_MS
)
)
.
unwrap
(
)
;
server
.
idle_timeout
=
IdleTimeout
:
:
new
(
LOWER_TIMEOUT
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
let
c1
=
send_something
(
&
mut
client
now
)
;
let
c2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c2
now
)
;
server
.
process_input
(
c1
now
)
;
let
s1
=
send_something
(
&
mut
server
now
)
;
let
s2
=
send_something
(
&
mut
server
now
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s2
now
)
;
let
ack
=
client
.
process
(
Some
(
s1
)
now
)
.
dgram
(
)
;
assert
!
(
ack
.
is_some
(
)
)
;
if
let
Output
:
:
Callback
(
t
)
=
client
.
process
(
None
now
)
{
assert
!
(
t
>
LOWER_TIMEOUT
)
;
}
else
{
panic
!
(
"
Client
not
idle
"
)
;
}
now
+
=
RTT
/
2
;
if
let
Output
:
:
Callback
(
t
)
=
client
.
process
(
ack
now
)
{
assert
!
(
t
>
LOWER_TIMEOUT
)
;
}
else
{
panic
!
(
"
Client
not
idle
"
)
;
}
}
#
[
test
]
fn
idle_send_packet1
(
)
{
const
DELTA
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
timeout
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
timeout
LOCAL_IDLE_TIMEOUT
)
;
now
+
=
Duration
:
:
from_secs
(
10
)
;
let
dgram
=
send_and_receive
(
&
mut
client
&
mut
server
now
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
now
+
=
LOCAL_IDLE_TIMEOUT
-
DELTA
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
client
.
state
(
)
.
connected
(
)
)
;
now
+
=
DELTA
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
None
)
)
;
assert
!
(
client
.
state
(
)
.
closed
(
)
)
;
}
#
[
test
]
fn
idle_send_packet2
(
)
{
const
GAP
:
Duration
=
Duration
:
:
from_secs
(
10
)
;
const
DELTA
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
timeout
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_eq
!
(
timeout
LOCAL_IDLE_TIMEOUT
)
;
now
+
=
GAP
;
let
_
=
send_something
(
&
mut
client
now
)
;
let
_
=
send_something
(
&
mut
client
now
+
GAP
)
;
assert
!
(
(
GAP
*
2
+
DELTA
)
<
LOCAL_IDLE_TIMEOUT
)
;
now
+
=
LOCAL_IDLE_TIMEOUT
-
DELTA
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
now
+
=
DELTA
;
let
out
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
out
Output
:
:
None
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
idle_recv_packet
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
BiDi
)
.
unwrap
(
)
0
)
;
assert_eq
!
(
client
.
stream_send
(
0
b
"
hello
"
)
.
unwrap
(
)
5
)
;
let
out
=
client
.
process
(
None
now
+
Duration
:
:
from_secs
(
10
)
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_eq
!
(
server
.
stream_send
(
0
b
"
world
"
)
.
unwrap
(
)
5
)
;
let
out
=
server
.
process_output
(
now
+
Duration
:
:
from_secs
(
10
)
)
;
assert_ne
!
(
out
.
as_dgram_ref
(
)
None
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
+
Duration
:
:
from_secs
(
20
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
19
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Confirmed
)
)
;
let
_
=
client
.
process
(
None
now
+
LOCAL_IDLE_TIMEOUT
+
Duration
:
:
from_secs
(
20
)
)
;
assert
!
(
matches
!
(
client
.
state
(
)
State
:
:
Closed
(
_
)
)
)
;
}
#
[
test
]
fn
idle_caching
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
start
=
now
(
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
let
dgram
=
client
.
process_output
(
start
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
start
)
.
dgram
(
)
;
let
(
_
handshake
)
=
split_datagram
(
&
dgram
.
unwrap
(
)
)
;
client
.
process_input
(
handshake
.
unwrap
(
)
start
)
;
let
middle
=
start
+
AT_LEAST_PTO
;
let
_
=
client
.
process_output
(
middle
)
;
let
dgram
=
client
.
process_output
(
middle
)
.
dgram
(
)
;
let
_
=
server
.
process_output
(
middle
)
.
dgram
(
)
;
let
ping_before_s
=
server
.
stats
(
)
.
frame_rx
.
ping
;
server
.
process_input
(
dgram
.
unwrap
(
)
middle
)
;
assert_eq
!
(
server
.
stats
(
)
.
frame_rx
.
ping
ping_before_s
+
1
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
server
.
crypto
.
streams
.
write_frame
(
PacketNumberSpace
:
:
Initial
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
.
unwrap
(
)
;
assert_eq
!
(
tokens
.
len
(
)
1
)
;
tokens
.
clear
(
)
;
server
.
crypto
.
streams
.
write_frame
(
PacketNumberSpace
:
:
Initial
&
mut
builder
&
mut
tokens
&
mut
FrameStats
:
:
default
(
)
)
.
unwrap
(
)
;
assert
!
(
tokens
.
is_empty
(
)
)
;
let
dgram
=
server
.
process_output
(
middle
)
.
dgram
(
)
;
let
(
initial
_
)
=
split_datagram
(
&
dgram
.
unwrap
(
)
)
;
let
ping_before_c
=
client
.
stats
(
)
.
frame_rx
.
ping
;
let
ack_before
=
client
.
stats
(
)
.
frame_rx
.
ack
;
client
.
process_input
(
initial
middle
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
ping
ping_before_c
+
1
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
ack
ack_before
+
1
)
;
let
end
=
start
+
LOCAL_IDLE_TIMEOUT
+
(
AT_LEAST_PTO
/
2
)
;
let
dgram
=
server
.
process_output
(
end
)
.
dgram
(
)
;
let
(
initial
_
)
=
split_datagram
(
&
dgram
.
unwrap
(
)
)
;
neqo_common
:
:
qwarn
!
(
"
client
ingests
initial
finally
"
)
;
let
_
=
client
.
process
(
Some
(
initial
)
end
)
;
maybe_authenticate
(
&
mut
client
)
;
let
dgram
=
client
.
process_output
(
end
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
end
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
end
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
