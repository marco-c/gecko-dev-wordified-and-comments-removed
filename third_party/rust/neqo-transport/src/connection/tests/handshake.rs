use
std
:
:
{
cell
:
:
RefCell
net
:
:
{
IpAddr
Ipv6Addr
SocketAddr
}
rc
:
:
Rc
time
:
:
Duration
}
;
use
neqo_common
:
:
{
event
:
:
Provider
as
_
qdebug
Datagram
}
;
use
neqo_crypto
:
:
{
constants
:
:
TLS_CHACHA20_POLY1305_SHA256
generate_ech_keys
AuthenticationStatus
}
;
#
[
cfg
(
not
(
feature
=
"
disable
-
encryption
"
)
)
]
use
test_fixture
:
:
datagram
;
use
test_fixture
:
:
{
assertions
assertions
:
:
assert_coalesced_0rtt
fixture_init
now
split_datagram
DEFAULT_ADDR
}
;
use
super
:
:
{
super
:
:
{
Connection
Output
State
}
assert_error
connect
connect_force_idle
connect_with_rtt
default_client
default_server
get_tokens
handshake
maybe_authenticate
resumed_server
send_something
zero_len_cid_client
CountingConnectionIdGenerator
AT_LEAST_PTO
DEFAULT_RTT
DEFAULT_STREAM_DATA
}
;
use
crate
:
:
{
connection
:
:
{
tests
:
:
{
exchange_ticket
new_client
new_server
}
AddressValidation
}
events
:
:
ConnectionEvent
server
:
:
ValidateAddress
stats
:
:
FrameStats
tparams
:
:
{
TransportParameter
TransportParameterId
:
:
*
}
tracking
:
:
DEFAULT_LOCAL_ACK_DELAY
CloseReason
ConnectionParameters
Error
Pmtud
StreamType
Version
}
;
const
ECH_CONFIG_ID
:
u8
=
7
;
const
ECH_PUBLIC_NAME
:
&
str
=
"
public
.
example
"
;
fn
full_handshake
(
pmtud
:
bool
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
pmtud
(
pmtud
)
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
let
out2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
out2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
assert_eq
!
(
out2
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
pmtud
(
pmtud
)
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
server
.
plpmtu
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
qdebug
!
(
"
-
-
-
-
server
:
FIN
-
>
ACKS
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
qdebug
!
(
"
-
-
-
-
client
:
ACKS
-
>
0
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
if
pmtud
{
let
pkt
=
out
.
dgram
(
)
.
unwrap
(
)
;
assert
!
(
pkt
.
len
(
)
>
client
.
plpmtu
(
)
)
;
}
else
{
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
}
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
handshake_no_pmtud
(
)
{
full_handshake
(
false
)
;
}
#
[
test
]
fn
handshake_pmtud
(
)
{
full_handshake
(
true
)
;
}
#
[
test
]
fn
handshake_failed_authentication
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
let
out2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
out2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
authentication_needed
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
AuthenticationNeeded
)
;
assert
!
(
client
.
events
(
)
.
any
(
authentication_needed
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
Alert
(
certificate_revoked
)
"
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
CertRevoked
now
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
-
>
Alert
(
certificate_revoked
)
"
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
Alert
(
certificate_revoked
)
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_error
(
&
client
&
CloseReason
:
:
Transport
(
Error
:
:
CryptoAlert
(
44
)
)
)
;
assert_error
(
&
server
&
CloseReason
:
:
Transport
(
Error
:
:
PeerError
(
300
)
)
)
;
}
#
[
test
]
fn
no_alpn
(
)
{
fixture_init
(
)
;
let
mut
client
=
Connection
:
:
new_client
(
"
example
.
com
"
&
[
"
bad
-
alpn
"
]
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
DEFAULT_ADDR
DEFAULT_ADDR
ConnectionParameters
:
:
default
(
)
now
(
)
)
.
unwrap
(
)
;
let
mut
server
=
default_server
(
)
;
handshake
(
&
mut
client
&
mut
server
now
(
)
Duration
:
:
new
(
0
0
)
)
;
assert_error
(
&
server
&
CloseReason
:
:
Transport
(
Error
:
:
CryptoAlert
(
120
)
)
)
;
}
#
[
test
]
#
[
expect
(
clippy
:
:
cognitive_complexity
reason
=
"
OK
in
a
test
.
"
)
]
fn
dup_server_flight1
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
let
out2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
out2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
assert_eq
!
(
out2
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
out2
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
out_to_rep
=
server
.
process
(
out2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out_to_rep
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out_to_rep
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
Some
(
out_to_rep
.
as_dgram_ref
(
)
.
cloned
(
)
.
unwrap
(
)
)
now
(
)
)
;
let
out_to_rep2
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
client
.
process
(
out_to_rep2
.
clone
(
)
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
4
client
.
stats
(
)
.
packets_rx
)
;
assert_eq
!
(
0
client
.
stats
(
)
.
dups_rx
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
qdebug
!
(
"
-
-
-
-
Dup
ignored
"
)
;
client
.
process_input
(
out_to_rep
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
out
=
client
.
process
(
out_to_rep2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
8
client
.
stats
(
)
.
packets_rx
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dups_rx
)
;
assert_eq
!
(
4
client
.
stats
(
)
.
dropped_rx
)
;
}
#
[
test
]
fn
crypto_frame_split
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
LONG_CERT_KEYS
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
ConnectionParameters
:
:
default
(
)
)
.
expect
(
"
create
a
server
"
)
;
let
client1
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
client1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server1
=
server
.
process
(
client1
.
dgram
(
)
now
(
)
)
;
assert
!
(
server1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server2
=
server
.
process_output
(
now
(
)
)
;
assert
!
(
server2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client2
=
client
.
process
(
server1
.
dgram
(
)
now
(
)
)
;
assert
!
(
client2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
auth1
=
maybe_authenticate
(
&
mut
client
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Handshaking
)
;
let
server3
=
server
.
process
(
client2
.
dgram
(
)
now
(
)
)
;
assert
!
(
server3
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
client3
=
client
.
process
(
server2
.
dgram
(
)
now
(
)
)
;
let
auth2
=
maybe_authenticate
(
&
mut
client
)
;
assert
!
(
auth1
^
auth2
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
client4
=
client
.
process
(
server3
.
dgram
(
)
now
(
)
)
;
assert
!
(
client3
.
as_dgram_ref
(
)
.
is_some
(
)
^
client4
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
drop
(
server
.
process
(
client3
.
dgram
(
)
now
(
)
)
)
;
drop
(
server
.
process
(
client4
.
dgram
(
)
now
(
)
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
chacha20poly1305
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
zero_len_cid_client
(
DEFAULT_ADDR
DEFAULT_ADDR
)
;
client
.
set_ciphers
(
&
[
TLS_CHACHA20_POLY1305_SHA256
]
)
.
unwrap
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
}
#
[
test
]
fn
send_05rtt
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
c1
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
c2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
&
&
c2
.
is_some
(
)
)
;
server
.
process_input
(
c1
.
unwrap
(
)
now
(
)
)
;
let
s1
=
server
.
process
(
c2
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
s1
.
len
(
)
server
.
plpmtu
(
)
)
;
let
s2
=
send_something
(
&
mut
server
now
(
)
)
;
client
.
process_input
(
s1
now
(
)
)
;
client
.
process_input
(
s2
now
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
stream_id
=
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
unwrap
(
)
;
let
(
l
ended
)
=
client
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
[
.
.
l
]
DEFAULT_STREAM_DATA
)
;
assert
!
(
ended
)
;
}
#
[
test
]
fn
reorder_05rtt
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
c1
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
let
s1
=
server
.
process
(
c1
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
s2
=
send_something
(
&
mut
server
now
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
0
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
0
)
;
client
.
process_input
(
s2
now
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
0
)
;
client
.
process_input
(
s1
now
(
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
stream_id
=
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
unwrap
(
)
;
let
(
l
ended
)
=
client
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
[
.
.
l
]
DEFAULT_STREAM_DATA
)
;
assert
!
(
ended
)
;
}
#
[
test
]
fn
reorder_05rtt_with_0rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
validation
=
AddressValidation
:
:
new
(
now
(
)
ValidateAddress
:
:
NoToken
)
.
unwrap
(
)
;
let
validation
=
Rc
:
:
new
(
RefCell
:
:
new
(
validation
)
)
;
server
.
set_validation
(
&
validation
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
now
+
=
RTT
/
2
;
server
.
send_ticket
(
now
&
[
]
)
.
unwrap
(
)
;
let
ticket
=
server
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
ticket
now
)
;
let
token
=
get_tokens
(
&
mut
client
)
.
pop
(
)
.
unwrap
(
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
client
.
enable_resumption
(
now
token
)
.
unwrap
(
)
;
let
mut
server
=
resumed_server
(
&
client
)
;
let
c1
=
send_something
(
&
mut
client
now
)
;
assert_coalesced_0rtt
(
&
c1
[
.
.
]
)
;
let
(
c1
_
)
=
split_datagram
(
&
c1
)
;
let
c2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
drop
(
server
.
process
(
Some
(
c1
)
now
)
.
dgram
(
)
.
unwrap
(
)
)
;
server
.
process_input
(
c2
now
)
;
let
s2
=
send_something
(
&
mut
server
now
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s2
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
now
+
=
AT_LEAST_PTO
;
let
c3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_coalesced_0rtt
(
c3
.
as_ref
(
)
.
unwrap
(
)
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
.
unwrap
(
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s3
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c4
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
assert_eq
!
(
client
.
paths
.
rtt
(
)
RTT
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c4
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
coalesce_05rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c11
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
&
&
c11
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c1
.
unwrap
(
)
now
)
;
let
s1
=
server
.
process
(
c11
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
stream_id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
server
.
stream_send
(
stream_id
DEFAULT_STREAM_DATA
)
.
is_ok
(
)
)
;
assert
!
(
server
.
stream_close_send
(
stream_id
)
.
is_ok
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c21
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
&
&
c21
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c21
.
unwrap
(
)
now
)
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
s2
now
)
.
dgram
(
)
;
let
s2
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert_eq
!
(
s2
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
server
.
plpmtu
(
)
)
;
now
+
=
RTT
/
2
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
drop
(
client
.
process
(
s2
now
)
.
dgram
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
3
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
4
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
assert
!
(
client
.
stats
(
)
.
frame_rx
.
padding
>
0
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
;
assert
!
(
s3
.
is_some
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
now
+
=
RTT
/
2
;
drop
(
client
.
process
(
s3
now
)
.
dgram
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
}
#
[
test
]
fn
reorder_handshake
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
&
&
c2
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c1
.
unwrap
(
)
now
)
;
let
s1
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
dgram
=
client
.
process
(
s1
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
(
_
s_hs
)
=
split_datagram
(
&
s1
.
unwrap
(
)
)
;
assert
!
(
s_hs
.
is_some
(
)
)
;
now
+
=
RTT
+
RTT
/
2
;
let
dgram
=
client
.
process
(
s_hs
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
false
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
1
)
;
now
+
=
AT_LEAST_PTO
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert
!
(
s2
.
is_some
(
)
)
;
let
(
s_init
s_hs
)
=
split_datagram
(
&
s2
.
unwrap
(
)
)
;
assert
!
(
s_hs
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s_hs
.
unwrap
(
)
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
2
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
1
)
;
client
.
process_input
(
s_init
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
6
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c3
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s3
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
paths
.
rtt
(
)
RTT
)
;
}
#
[
test
]
fn
reorder_1rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
const
PACKETS
:
usize
=
4
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
&
&
c2
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c1
.
unwrap
(
)
now
)
;
let
s1
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
dgram
=
client
.
process
(
s1
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
for
_
in
0
.
.
PACKETS
{
let
d
=
send_something
(
&
mut
client
now
)
;
server
.
process_input
(
d
now
+
RTT
/
2
)
;
}
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
PACKETS
+
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
PACKETS
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
3
)
;
now
+
=
RTT
/
2
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
PACKETS
*
2
+
5
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
PACKETS
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
3
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
server
.
paths
.
rtt
(
)
RTT
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s2
.
unwrap
(
)
now
)
;
assert_eq
!
(
client
.
paths
.
rtt
(
)
RTT
)
;
let
streams
=
server
.
events
(
)
.
filter_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
streams
.
len
(
)
PACKETS
)
;
for
stream_id
in
streams
{
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
(
recvd
fin
)
=
server
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
recvd
DEFAULT_STREAM_DATA
.
len
(
)
)
;
assert
!
(
fin
)
;
}
}
#
[
cfg
(
not
(
feature
=
"
disable
-
encryption
"
)
)
]
#
[
test
]
fn
corrupted_initial
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
d
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
mut
corrupted
=
Vec
:
:
from
(
&
d
[
.
.
]
)
;
let
(
idx
_
)
=
corrupted
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
.
find
(
|
(
_
&
v
)
|
v
!
=
0
)
.
unwrap
(
)
;
corrupted
[
idx
]
^
=
0x76
;
let
dgram
=
Datagram
:
:
new
(
d
.
source
(
)
d
.
destination
(
)
d
.
tos
(
)
corrupted
)
;
server
.
process_input
(
dgram
now
(
)
)
;
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
0
)
;
}
#
[
test
]
fn
verify_pkt_honors_mtu
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process_output
(
now
)
;
let
idle_timeout
=
ConnectionParameters
:
:
default
(
)
.
get_idle_timeout
(
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
idle_timeout
)
)
;
let
stream_id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
client
.
stream_send
(
stream_id
&
[
0xbb
;
2000
]
)
.
unwrap
(
)
2000
)
;
let
pkt0
=
client
.
process_output
(
now
)
;
assert
!
(
matches
!
(
pkt0
Output
:
:
Datagram
(
_
)
)
)
;
assert_eq
!
(
pkt0
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
client
.
plpmtu
(
)
)
;
}
#
[
test
]
fn
extra_initial_hs
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_init
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c_init2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c_init
.
is_some
(
)
&
&
c_init2
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
server
.
process_input
(
c_init
.
unwrap
(
)
now
)
;
let
s_init
=
server
.
process
(
c_init2
now
)
.
dgram
(
)
;
assert
!
(
s_init
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
dgram
=
client
.
process
(
s_init
now
)
.
dgram
(
)
;
let
s_init
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
let
(
_
undecryptable
)
=
split_datagram
(
&
s_init
.
unwrap
(
)
)
;
assert
!
(
undecryptable
.
is_some
(
)
)
;
for
_
in
0
.
.
=
super
:
:
super
:
:
EXTRA_INITIALS
{
let
c_init
=
match
client
.
process
(
undecryptable
.
clone
(
)
now
)
{
Output
:
:
None
=
>
todo
!
(
)
Output
:
:
Datagram
(
c_init
)
=
>
Some
(
c_init
)
Output
:
:
Callback
(
duration
)
=
>
{
now
+
=
duration
;
client
.
process_output
(
now
)
.
dgram
(
)
}
}
;
assertions
:
:
assert_initial
(
c_init
.
as_ref
(
)
.
unwrap
(
)
false
)
;
now
+
=
DEFAULT_RTT
/
10
;
}
let
nothing
=
client
.
process
(
undecryptable
now
)
.
dgram
(
)
;
assert
!
(
nothing
.
is_none
(
)
)
;
now
+
=
client
.
process_output
(
now
)
.
callback
(
)
;
let
c_init
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
c_init
.
as_ref
(
)
.
unwrap
(
)
false
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_init
=
server
.
process
(
c_init
now
)
.
dgram
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
s_init
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c_fin
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
now
+
=
DEFAULT_RTT
/
2
;
server
.
process_input
(
c_fin
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
extra_initial_invalid_cid
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_init
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
c_init2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
c_init
.
is_some
(
)
&
&
c_init2
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
server
.
process_input
(
c_init
.
unwrap
(
)
now
)
;
let
s_init
=
server
.
process
(
c_init2
now
)
.
dgram
(
)
;
assert
!
(
s_init
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
dgram
=
client
.
process
(
s_init
now
)
.
dgram
(
)
;
let
s_init
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
let
(
_
hs
)
=
split_datagram
(
&
s_init
.
unwrap
(
)
)
;
let
hs
=
hs
.
unwrap
(
)
;
let
mut
copy
=
hs
.
to_vec
(
)
;
assert_ne
!
(
copy
[
5
]
0
)
;
copy
[
6
]
^
=
0xc4
;
let
dgram_copy
=
Datagram
:
:
new
(
hs
.
destination
(
)
hs
.
source
(
)
hs
.
tos
(
)
copy
)
;
let
nothing
=
client
.
process
(
Some
(
dgram_copy
)
now
)
.
dgram
(
)
;
assert
!
(
nothing
.
is_none
(
)
)
;
}
#
[
test
]
fn
connect_one_version
(
)
{
fn
connect_v
(
version
:
Version
)
{
fixture_init
(
)
;
let
mut
client
=
Connection
:
:
new_client
(
test_fixture
:
:
DEFAULT_SERVER_NAME
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
DEFAULT_ADDR
DEFAULT_ADDR
ConnectionParameters
:
:
default
(
)
.
versions
(
version
vec
!
[
version
]
)
now
(
)
)
.
unwrap
(
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
ConnectionParameters
:
:
default
(
)
.
versions
(
version
vec
!
[
version
]
)
)
.
unwrap
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client
.
version
(
)
version
)
;
assert_eq
!
(
server
.
version
(
)
version
)
;
}
for
v
in
Version
:
:
all
(
)
{
println
!
(
"
Connecting
with
{
v
:
?
}
"
)
;
connect_v
(
v
)
;
}
}
#
[
test
]
fn
anti_amplification
(
)
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
mlkem
(
false
)
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
very_big
=
TransportParameter
:
:
Bytes
(
vec
!
[
0
;
Pmtud
:
:
default_plpmtu
(
DEFAULT_ADDR
.
ip
(
)
)
*
3
]
)
;
server
.
set_local_tparam
(
TestTransportParameter
very_big
)
.
unwrap
(
)
;
let
c_init
=
client
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_init1
=
server
.
process
(
c_init
now
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
s_init1
.
len
(
)
server
.
plpmtu
(
)
)
;
let
s_init2
=
server
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
s_init2
.
len
(
)
server
.
plpmtu
(
)
)
;
let
s_init3
=
server
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
s_init3
.
len
(
)
server
.
plpmtu
(
)
)
;
let
cb
=
server
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
cb
server
.
conn_params
.
get_idle_timeout
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
s_init1
now
)
;
client
.
process_input
(
s_init2
now
)
;
let
ack_count
=
client
.
stats
(
)
.
frame_tx
.
ack
;
let
frame_count
=
client
.
stats
(
)
.
frame_tx
.
all
(
)
;
let
ack
=
client
.
process
(
Some
(
s_init3
)
now
)
.
dgram
(
)
.
unwrap
(
)
;
assert
!
(
!
maybe_authenticate
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack
ack_count
+
2
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
all
(
)
frame_count
+
2
)
;
assert_ne
!
(
ack
.
len
(
)
client
.
plpmtu
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
remainder
=
server
.
process
(
Some
(
ack
)
now
)
.
dgram
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
remainder
.
unwrap
(
)
now
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
let
fin
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
now
+
=
DEFAULT_RTT
/
2
;
server
.
process_input
(
fin
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
cfg
(
not
(
feature
=
"
disable
-
encryption
"
)
)
]
#
[
test
]
fn
garbage_initial
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
(
initial
rest
)
=
split_datagram
(
&
dgram
)
;
let
mut
corrupted
=
Vec
:
:
from
(
&
initial
[
.
.
initial
.
len
(
)
-
1
]
)
;
corrupted
.
push
(
initial
[
initial
.
len
(
)
-
1
]
^
0xb7
)
;
corrupted
.
extend_from_slice
(
rest
.
as_ref
(
)
.
map_or
(
&
[
]
|
r
|
&
r
[
.
.
]
)
)
;
let
garbage
=
datagram
(
corrupted
)
;
assert_eq
!
(
Output
:
:
None
server
.
process
(
Some
(
garbage
)
now
(
)
)
)
;
}
#
[
test
]
fn
drop_initial_packet_from_wrong_address
(
)
{
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
let
out2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
out2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
p
=
out
.
dgram
(
)
.
unwrap
(
)
;
let
dgram
=
Datagram
:
:
new
(
SocketAddr
:
:
new
(
IpAddr
:
:
V6
(
Ipv6Addr
:
:
new
(
0xfe80
0
0
0
0
0
0
2
)
)
443
)
p
.
destination
(
)
p
.
tos
(
)
&
p
[
.
.
]
)
;
let
out
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
drop_handshake_packet_from_wrong_address
(
)
{
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
let
out2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
out2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
mut
server
=
default_server
(
)
;
server
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
(
s_in
s_hs
)
=
split_datagram
(
&
out
.
dgram
(
)
.
unwrap
(
)
)
;
drop
(
client
.
process
(
Some
(
s_in
)
now
(
)
)
.
dgram
(
)
)
;
let
p
=
s_hs
.
unwrap
(
)
;
let
dgram
=
Datagram
:
:
new
(
SocketAddr
:
:
new
(
IpAddr
:
:
V6
(
Ipv6Addr
:
:
new
(
0xfe80
0
0
0
0
0
0
2
)
)
443
)
p
.
destination
(
)
p
.
tos
(
)
&
p
[
.
.
]
)
;
let
out
=
client
.
process
(
Some
(
dgram
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
ech
(
)
{
let
mut
server
=
default_server
(
)
;
let
(
sk
pk
)
=
generate_ech_keys
(
)
.
unwrap
(
)
;
server
.
server_enable_ech
(
ECH_CONFIG_ID
ECH_PUBLIC_NAME
&
sk
&
pk
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
client
.
client_enable_ech
(
server
.
ech_config
(
)
)
.
unwrap
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
server
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
client
.
tls_preinfo
(
)
.
unwrap
(
)
.
ech_accepted
(
)
.
unwrap
(
)
)
;
assert
!
(
server
.
tls_preinfo
(
)
.
unwrap
(
)
.
ech_accepted
(
)
.
unwrap
(
)
)
;
}
fn
damaged_ech_config
(
config
:
&
[
u8
]
)
-
>
Vec
<
u8
>
{
let
mut
cfg
=
Vec
:
:
from
(
config
)
;
assert_eq
!
(
cfg
[
2
]
0xfe
)
;
assert_eq
!
(
cfg
[
3
]
0x0d
)
;
assert_eq
!
(
cfg
[
6
]
ECH_CONFIG_ID
)
;
cfg
[
6
]
^
=
0x94
;
cfg
}
#
[
test
]
fn
ech_retry
(
)
{
fixture_init
(
)
;
let
mut
server
=
default_server
(
)
;
let
(
sk
pk
)
=
generate_ech_keys
(
)
.
unwrap
(
)
;
server
.
server_enable_ech
(
ECH_CONFIG_ID
ECH_PUBLIC_NAME
&
sk
&
pk
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
client
.
client_enable_ech
(
damaged_ech_config
(
server
.
ech_config
(
)
)
)
.
unwrap
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
dgram
=
server
.
process
(
dgram2
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
auth_event
=
ConnectionEvent
:
:
EchFallbackAuthenticationNeeded
{
public_name
:
String
:
:
from
(
ECH_PUBLIC_NAME
)
}
;
assert
!
(
client
.
events
(
)
.
any
(
|
e
|
e
=
=
auth_event
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
assert
!
(
client
.
state
(
)
.
error
(
)
.
is_some
(
)
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert_eq
!
(
server
.
state
(
)
.
error
(
)
Some
(
&
CloseReason
:
:
Transport
(
Error
:
:
PeerError
(
0x100
+
121
)
)
)
)
;
let
Some
(
CloseReason
:
:
Transport
(
Error
:
:
EchRetry
(
updated_config
)
)
)
=
client
.
state
(
)
.
error
(
)
else
{
panic
!
(
"
Client
state
should
be
failed
with
EchRetry
is
{
:
?
}
"
client
.
state
(
)
)
;
}
;
let
mut
server
=
default_server
(
)
;
server
.
server_enable_ech
(
ECH_CONFIG_ID
ECH_PUBLIC_NAME
&
sk
&
pk
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
client
.
client_enable_ech
(
updated_config
)
.
unwrap
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
server
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
client
.
tls_preinfo
(
)
.
unwrap
(
)
.
ech_accepted
(
)
.
unwrap
(
)
)
;
assert
!
(
server
.
tls_preinfo
(
)
.
unwrap
(
)
.
ech_accepted
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
ech_retry_fallback_rejected
(
)
{
fixture_init
(
)
;
let
mut
server
=
default_server
(
)
;
let
(
sk
pk
)
=
generate_ech_keys
(
)
.
unwrap
(
)
;
server
.
server_enable_ech
(
ECH_CONFIG_ID
ECH_PUBLIC_NAME
&
sk
&
pk
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
client
.
client_enable_ech
(
damaged_ech_config
(
server
.
ech_config
(
)
)
)
.
unwrap
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
dgram
=
server
.
process
(
dgram2
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
auth_event
=
ConnectionEvent
:
:
EchFallbackAuthenticationNeeded
{
public_name
:
String
:
:
from
(
ECH_PUBLIC_NAME
)
}
;
assert
!
(
client
.
events
(
)
.
any
(
|
e
|
e
=
=
auth_event
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
PolicyRejection
now
(
)
)
;
assert
!
(
client
.
state
(
)
.
error
(
)
.
is_some
(
)
)
;
if
let
Some
(
CloseReason
:
:
Transport
(
Error
:
:
EchRetry
(
_
)
)
)
=
client
.
state
(
)
.
error
(
)
{
panic
!
(
"
Client
should
not
get
EchRetry
error
"
)
;
}
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert_eq
!
(
server
.
state
(
)
.
error
(
)
Some
(
&
CloseReason
:
:
Transport
(
Error
:
:
PeerError
(
298
)
)
)
)
;
}
#
[
test
]
fn
bad_min_ack_delay
(
)
{
const
EXPECTED_ERROR
:
CloseReason
=
CloseReason
:
:
Transport
(
Error
:
:
TransportParameterError
)
;
let
mut
server
=
default_server
(
)
;
let
max_ad
=
u64
:
:
try_from
(
DEFAULT_LOCAL_ACK_DELAY
.
as_micros
(
)
)
.
unwrap
(
)
;
server
.
set_local_tparam
(
MinAckDelay
TransportParameter
:
:
Integer
(
max_ad
+
1
)
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
dgram
=
server
.
process
(
dgram2
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
.
error
(
)
Some
(
&
EXPECTED_ERROR
)
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert_eq
!
(
server
.
state
(
)
.
error
(
)
Some
(
&
CloseReason
:
:
Transport
(
Error
:
:
PeerError
(
Error
:
:
TransportParameterError
.
code
(
)
)
)
)
)
;
}
#
[
test
]
fn
only_server_initial
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
now
=
now
(
)
;
let
client_dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
client_dgram2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
server
.
process_input
(
client_dgram
.
unwrap
(
)
now
)
;
let
dgram
=
server
.
process
(
client_dgram2
now
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
)
.
dgram
(
)
;
let
server_dgram1
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
let
server_dgram2
=
server
.
process_output
(
now
+
AT_LEAST_PTO
)
.
dgram
(
)
;
let
(
initial
handshake
)
=
split_datagram
(
&
server_dgram1
.
unwrap
(
)
)
;
assert
!
(
handshake
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack
1
)
;
let
probe
=
client
.
process
(
Some
(
initial
)
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
&
probe
.
unwrap
(
)
false
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack
2
)
;
let
(
initial
handshake
)
=
split_datagram
(
&
server_dgram2
.
unwrap
(
)
)
;
assert
!
(
handshake
.
is_some
(
)
)
;
now
+
=
AT_LEAST_PTO
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack
2
)
;
let
discarded
=
client
.
stats
(
)
.
dropped_rx
;
let
probe
=
client
.
process
(
Some
(
initial
)
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
&
probe
.
unwrap
(
)
false
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
.
ack
3
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
discarded
)
;
client
.
process_input
(
handshake
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
no_extra_probes_after_confirmed
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
now
=
now
(
)
;
let
spare_initial
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
spare_initial2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert
!
(
spare_initial
.
is_some
(
)
&
&
spare_initial2
.
is_some
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
dgram1
=
client
.
process_output
(
now
)
.
dgram
(
)
;
_
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
(
replay_initial
_
)
=
split_datagram
(
dgram1
.
as_ref
(
)
.
unwrap
(
)
)
;
now
+
=
AT_LEAST_PTO
*
2
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
let
dgram
=
server
.
process
(
dgram2
now
)
.
dgram
(
)
;
let
spare_handshake
=
server
.
process
(
Some
(
replay_initial
)
now
)
.
dgram
(
)
;
assert
!
(
spare_handshake
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
let
probe
=
server
.
process
(
spare_initial
now
)
.
dgram
(
)
;
assert
!
(
probe
.
is_none
(
)
)
;
let
probe
=
client
.
process
(
spare_handshake
now
)
.
dgram
(
)
;
assert
!
(
probe
.
is_none
(
)
)
;
}
#
[
test
]
fn
implicit_rtt_server
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_secs
(
2
)
;
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
now
=
now
(
)
;
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
let
dgram
=
server
.
process
(
dgram2
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
dgram
=
client
.
process
(
dgram
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
dgram
=
client
.
process
(
dgram
now
)
.
dgram
(
)
;
let
(
initial
handshake
)
=
split_datagram
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
assertions
:
:
assert_initial
(
&
initial
false
)
;
assertions
:
:
assert_handshake
(
handshake
.
as_ref
(
)
.
unwrap
(
)
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert_eq
!
(
server
.
stats
(
)
.
rtt
RTT
)
;
}
#
[
test
]
fn
emit_authentication_needed_once
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
LONG_CERT_KEYS
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
ConnectionParameters
:
:
default
(
)
.
pacing
(
false
)
)
.
expect
(
"
create
a
server
"
)
;
let
client1
=
client
.
process_output
(
now
(
)
)
;
let
client2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
client1
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
client2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
_
=
server
.
process
(
client1
.
dgram
(
)
now
(
)
)
;
let
server1
=
server
.
process
(
client2
.
dgram
(
)
now
(
)
)
;
assert
!
(
server1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server2
=
server
.
process_output
(
now
(
)
)
;
assert
!
(
server2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server3
=
server
.
process_output
(
now
(
)
)
;
assert
!
(
server3
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
authentication_needed_count
=
|
client
:
&
mut
Connection
|
{
client
.
events
(
)
.
filter
(
|
e
|
matches
!
(
e
ConnectionEvent
:
:
AuthenticationNeeded
)
)
.
count
(
)
}
;
_
=
client
.
process
(
server1
.
dgram
(
)
now
(
)
)
;
_
=
client
.
process
(
server2
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
1
authentication_needed_count
(
&
mut
client
)
)
;
assert
!
(
client
.
peer_certificate
(
)
.
is_some
(
)
)
;
_
=
client
.
process
(
server3
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
0
authentication_needed_count
(
&
mut
client
)
)
;
}
#
[
test
]
fn
client_initial_retransmits_identical
(
)
{
let
mut
now
=
now
(
)
;
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
pacing
(
false
)
)
;
for
i
in
1
.
.
=
5
{
let
ci
=
client
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
ci
.
len
(
)
client
.
plpmtu
(
)
)
;
let
ci2
=
client
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
ci2
.
len
(
)
client
.
plpmtu
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_tx
FrameStats
{
crypto
:
3
*
i
.
.
Default
:
:
default
(
)
}
)
;
let
pto
=
client
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
pto
DEFAULT_RTT
*
3
*
(
1
<
<
(
i
-
1
)
)
)
;
now
+
=
pto
;
}
}
#
[
test
]
fn
server_initial_retransmits_identical
(
)
{
let
mut
now
=
now
(
)
;
let
mut
client
=
default_client
(
)
;
let
mut
ci
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
mut
ci2
=
client
.
process_output
(
now
)
.
dgram
(
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
pacing
(
false
)
)
;
let
mut
total_ptos
=
Duration
:
:
from_secs
(
0
)
;
for
i
in
1
.
.
=
3
{
_
=
server
.
process
(
ci
.
take
(
)
now
)
;
_
=
server
.
process
(
ci2
.
take
(
)
now
)
;
if
i
=
=
1
{
_
=
server
.
process
(
ci2
.
take
(
)
now
)
;
}
assert_eq
!
(
server
.
stats
(
)
.
frame_tx
FrameStats
{
crypto
:
i
*
3
ack
:
i
*
2
-
i
.
saturating_sub
(
1
)
largest_acknowledged
:
(
i
-
i
.
saturating_sub
(
1
)
)
as
u64
.
.
Default
:
:
default
(
)
}
)
;
let
pto
=
server
.
process_output
(
now
)
.
callback
(
)
;
now
+
=
pto
;
total_ptos
+
=
pto
;
}
let
pto
=
server
.
process_output
(
now
)
.
callback
(
)
;
assert_eq
!
(
pto
server
.
conn_params
.
get_idle_timeout
(
)
-
total_ptos
)
;
}
#
[
test
]
fn
grease_quic_bit_transport_parameter
(
)
{
fn
get_remote_tp
(
conn
:
&
Connection
)
-
>
bool
{
conn
.
tps
.
borrow
(
)
.
remote
.
as_ref
(
)
.
unwrap
(
)
.
get_empty
(
GreaseQuicBit
)
}
for
client_grease
in
[
true
false
]
{
for
server_grease
in
[
true
false
]
{
let
mut
client
=
new_client
(
ConnectionParameters
:
:
default
(
)
.
grease
(
client_grease
)
)
;
let
mut
server
=
new_server
(
ConnectionParameters
:
:
default
(
)
.
grease
(
server_grease
)
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
client_grease
get_remote_tp
(
&
server
)
)
;
assert_eq
!
(
server_grease
get_remote_tp
(
&
client
)
)
;
}
}
}
#
[
test
]
fn
zero_rtt_with_ech
(
)
{
let
mut
server
=
default_server
(
)
;
let
(
sk
pk
)
=
generate_ech_keys
(
)
.
unwrap
(
)
;
server
.
server_enable_ech
(
ECH_CONFIG_ID
ECH_PUBLIC_NAME
&
sk
&
pk
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
client
.
client_enable_ech
(
server
.
ech_config
(
)
)
.
unwrap
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
server
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
let
token
=
exchange_ticket
(
&
mut
client
&
mut
server
now
(
)
)
;
let
mut
client
=
default_client
(
)
;
client
.
client_enable_ech
(
server
.
ech_config
(
)
)
.
unwrap
(
)
;
client
.
enable_resumption
(
now
(
)
token
)
.
expect
(
"
should
set
token
"
)
;
let
mut
server
=
resumed_server
(
&
client
)
;
server
.
server_enable_ech
(
ECH_CONFIG_ID
ECH_PUBLIC_NAME
&
sk
&
pk
)
.
unwrap
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
server
.
tls_info
(
)
.
unwrap
(
)
.
ech_accepted
(
)
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
early_data_accepted
(
)
)
;
assert
!
(
server
.
tls_info
(
)
.
unwrap
(
)
.
early_data_accepted
(
)
)
;
}
