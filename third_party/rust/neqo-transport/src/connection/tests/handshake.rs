use
super
:
:
super
:
:
{
Connection
FixedConnectionIdManager
Output
State
LOCAL_IDLE_TIMEOUT
}
;
use
super
:
:
{
assert_error
connect_force_idle
connect_with_rtt
default_client
default_server
get_tokens
handshake
maybe_authenticate
send_something
AT_LEAST_PTO
DEFAULT_RTT
DEFAULT_STREAM_DATA
}
;
use
crate
:
:
connection
:
:
AddressValidation
;
use
crate
:
:
events
:
:
ConnectionEvent
;
use
crate
:
:
frame
:
:
StreamType
;
use
crate
:
:
path
:
:
PATH_MTU_V6
;
use
crate
:
:
server
:
:
ValidateAddress
;
use
crate
:
:
{
ConnectionError
ConnectionParameters
Error
}
;
use
neqo_common
:
:
{
event
:
:
Provider
qdebug
Datagram
}
;
use
neqo_crypto
:
:
{
constants
:
:
TLS_CHACHA20_POLY1305_SHA256
AuthenticationStatus
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
Duration
;
use
test_fixture
:
:
{
self
assertions
fixture_init
loopback
now
split_datagram
}
;
#
[
test
]
fn
full_handshake
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
qdebug
!
(
"
-
-
-
-
server
:
FIN
-
>
ACKS
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
qdebug
!
(
"
-
-
-
-
client
:
ACKS
-
>
0
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
handshake_failed_authentication
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
authentication_needed
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
AuthenticationNeeded
)
;
assert
!
(
client
.
events
(
)
.
any
(
authentication_needed
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
Alert
(
certificate_revoked
)
"
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
CertRevoked
now
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
-
>
Alert
(
certificate_revoked
)
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
Alert
(
certificate_revoked
)
"
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_error
(
&
client
&
ConnectionError
:
:
Transport
(
Error
:
:
CryptoAlert
(
44
)
)
)
;
assert_error
(
&
server
&
ConnectionError
:
:
Transport
(
Error
:
:
PeerError
(
300
)
)
)
;
}
#
[
test
]
fn
no_alpn
(
)
{
fixture_init
(
)
;
let
mut
client
=
Connection
:
:
new_client
(
"
example
.
com
"
&
[
"
bad
-
alpn
"
]
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
9
)
)
)
loopback
(
)
loopback
(
)
&
ConnectionParameters
:
:
default
(
)
)
.
unwrap
(
)
;
let
mut
server
=
default_server
(
)
;
handshake
(
&
mut
client
&
mut
server
now
(
)
Duration
:
:
new
(
0
0
)
)
;
assert_error
(
&
server
&
ConnectionError
:
:
Transport
(
Error
:
:
CryptoAlert
(
120
)
)
)
;
}
#
[
test
]
fn
dup_server_flight1
(
)
{
qdebug
!
(
"
-
-
-
-
client
:
generate
CH
"
)
;
let
mut
client
=
default_client
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
out
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
server
:
CH
-
>
SH
EE
CERT
CV
FIN
"
)
;
let
mut
server
=
default_server
(
)
;
let
out_to_rep
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out_to_rep
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out_to_rep
.
as_dgram_ref
(
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
cert
verification
"
)
;
let
out
=
client
.
process
(
Some
(
out_to_rep
.
as_dgram_ref
(
)
.
unwrap
(
)
.
clone
(
)
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert
!
(
maybe_authenticate
(
&
mut
client
)
)
;
qdebug
!
(
"
-
-
-
-
client
:
SH
.
.
FIN
-
>
FIN
"
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
3
client
.
stats
(
)
.
packets_rx
)
;
assert_eq
!
(
0
client
.
stats
(
)
.
dups_rx
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dropped_rx
)
;
qdebug
!
(
"
-
-
-
-
Dup
ignored
"
)
;
let
out
=
client
.
process
(
out_to_rep
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
qdebug
!
(
"
Output
=
{
:
0x
?
}
"
out
.
as_dgram_ref
(
)
)
;
assert_eq
!
(
6
client
.
stats
(
)
.
packets_rx
)
;
assert_eq
!
(
1
client
.
stats
(
)
.
dups_rx
)
;
assert_eq
!
(
3
client
.
stats
(
)
.
dropped_rx
)
;
}
#
[
test
]
fn
crypto_frame_split
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
LONG_CERT_KEYS
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
6
)
)
)
&
ConnectionParameters
:
:
default
(
)
)
.
expect
(
"
create
a
server
"
)
;
let
client1
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server1
=
server
.
process
(
client1
.
dgram
(
)
now
(
)
)
;
assert
!
(
server1
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server2
=
server
.
process
(
None
now
(
)
)
;
assert
!
(
server2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
client2
=
client
.
process
(
server1
.
dgram
(
)
now
(
)
)
;
assert
!
(
client2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
auth1
=
maybe_authenticate
(
&
mut
client
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Handshaking
)
;
let
server3
=
server
.
process
(
client2
.
dgram
(
)
now
(
)
)
;
assert
!
(
server3
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
client3
=
client
.
process
(
server2
.
dgram
(
)
now
(
)
)
;
let
auth2
=
maybe_authenticate
(
&
mut
client
)
;
assert
!
(
auth1
^
auth2
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
client4
=
client
.
process
(
server3
.
dgram
(
)
now
(
)
)
;
assert
!
(
client3
.
as_dgram_ref
(
)
.
is_some
(
)
^
client4
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
_
=
server
.
process
(
client3
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
process
(
client4
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
chacha20poly1305
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
Connection
:
:
new_client
(
test_fixture
:
:
DEFAULT_SERVER_NAME
test_fixture
:
:
DEFAULT_ALPN
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
0
)
)
)
loopback
(
)
loopback
(
)
&
ConnectionParameters
:
:
default
(
)
)
.
expect
(
"
create
a
default
client
"
)
;
client
.
set_ciphers
(
&
[
TLS_CHACHA20_POLY1305_SHA256
]
)
.
unwrap
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
}
#
[
test
]
fn
send_05rtt
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
c1
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
let
s1
=
server
.
process
(
c1
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
assert_eq
!
(
s1
.
len
(
)
PATH_MTU_V6
)
;
let
s2
=
send_something
(
&
mut
server
now
(
)
)
;
client
.
process_input
(
s1
now
(
)
)
;
maybe_authenticate
(
&
mut
client
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
client
.
process_input
(
s2
now
(
)
)
;
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
stream_id
=
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
unwrap
(
)
;
let
(
l
ended
)
=
client
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
[
.
.
l
]
DEFAULT_STREAM_DATA
)
;
assert
!
(
ended
)
;
}
#
[
test
]
fn
reorder_05rtt
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
c1
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
let
s1
=
server
.
process
(
c1
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
s2
=
send_something
(
&
mut
server
now
(
)
)
;
client
.
process_input
(
s2
now
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
client
.
process_input
(
s1
now
(
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
stream_id
=
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
unwrap
(
)
;
let
(
l
ended
)
=
client
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
&
buf
[
.
.
l
]
DEFAULT_STREAM_DATA
)
;
assert
!
(
ended
)
;
}
#
[
test
]
fn
reorder_05rtt_with_0rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
validation
=
AddressValidation
:
:
new
(
now
(
)
ValidateAddress
:
:
NoToken
)
.
unwrap
(
)
;
let
validation
=
Rc
:
:
new
(
RefCell
:
:
new
(
validation
)
)
;
server
.
set_validation
(
Rc
:
:
clone
(
&
validation
)
)
;
let
mut
now
=
connect_with_rtt
(
&
mut
client
&
mut
server
now
(
)
RTT
)
;
now
+
=
RTT
/
2
;
server
.
send_ticket
(
now
&
[
]
)
.
unwrap
(
)
;
let
ticket
=
server
.
process_output
(
now
)
.
dgram
(
)
.
unwrap
(
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
ticket
now
)
;
let
token
=
get_tokens
(
&
mut
client
)
.
pop
(
)
.
unwrap
(
)
;
let
mut
client
=
default_client
(
)
;
client
.
enable_resumption
(
now
token
)
.
unwrap
(
)
;
let
mut
server
=
default_server
(
)
;
let
c1
=
send_something
(
&
mut
client
now
)
;
assertions
:
:
assert_coalesced_0rtt
(
&
c1
[
.
.
]
)
;
let
(
c1
_
)
=
split_datagram
(
&
c1
)
;
let
c2
=
send_something
(
&
mut
client
now
)
;
now
+
=
RTT
/
2
;
let
_
=
server
.
process
(
Some
(
c1
)
now
)
.
dgram
(
)
.
unwrap
(
)
;
server
.
process_input
(
c2
now
)
;
let
s2
=
send_something
(
&
mut
server
now
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s2
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
now
+
=
AT_LEAST_PTO
;
let
c3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
.
unwrap
(
)
;
assertions
:
:
assert_no_1rtt
(
&
s3
[
.
.
]
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s3
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c4
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
RTT
)
;
now
+
=
RTT
/
2
;
server
.
process_input
(
c4
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
server
.
loss_recovery
.
rtt
(
)
RTT
)
;
}
#
[
test
]
fn
coalesce_05rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
stream_id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert
!
(
server
.
stream_send
(
stream_id
DEFAULT_STREAM_DATA
)
.
is_ok
(
)
)
;
assert
!
(
server
.
stream_close_send
(
stream_id
)
.
is_ok
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
c2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert_eq
!
(
s2
.
as_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
now
+
=
RTT
/
2
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
let
_
=
client
.
process
(
s2
now
)
.
dgram
(
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
3
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
4
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
assert_eq
!
(
client
.
stats
(
)
.
frame_rx
.
padding
1
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
;
assert
!
(
s3
.
is_some
(
)
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
now
+
=
RTT
/
2
;
let
_
=
client
.
process
(
s3
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
stats
(
)
.
dropped_rx
0
)
;
}
#
[
test
]
fn
reorder_handshake
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
let
(
_
s_hs
)
=
split_datagram
(
&
s1
.
unwrap
(
)
)
;
assert
!
(
s_hs
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
dgram
=
client
.
process
(
s_hs
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
&
dgram
.
as_ref
(
)
.
unwrap
(
)
false
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
1
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
1
)
;
now
+
=
AT_LEAST_PTO
;
let
c2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
now
+
=
RTT
/
2
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert
!
(
s2
.
is_some
(
)
)
;
let
(
s_init
s_hs
)
=
split_datagram
(
&
s2
.
unwrap
(
)
)
;
assert
!
(
s_hs
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s_hs
.
unwrap
(
)
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
saved_datagrams
2
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
2
)
;
client
.
process_input
(
s_init
now
)
;
assert_eq
!
(
client
.
stats
(
)
.
packets_rx
7
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c3
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c3
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s3
=
server
.
process
(
c3
now
)
.
dgram
(
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
server
.
loss_recovery
.
rtt
(
)
RTT
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s3
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
RTT
)
;
}
#
[
test
]
fn
reorder_1rtt
(
)
{
const
RTT
:
Duration
=
Duration
:
:
from_millis
(
100
)
;
const
PACKETS
:
usize
=
6
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
let
s1
=
server
.
process
(
c1
now
)
.
dgram
(
)
;
assert
!
(
s1
.
is_some
(
)
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s1
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c2
.
is_some
(
)
)
;
for
_
in
0
.
.
PACKETS
{
let
d
=
send_something
(
&
mut
client
now
)
;
server
.
process_input
(
d
now
+
RTT
/
2
)
;
}
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
PACKETS
+
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
PACKETS
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
1
)
;
now
+
=
RTT
/
2
;
let
s2
=
server
.
process
(
c2
now
)
.
dgram
(
)
;
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
PACKETS
*
2
+
4
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
PACKETS
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
1
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
assert_eq
!
(
server
.
loss_recovery
.
rtt
(
)
RTT
)
;
now
+
=
RTT
/
2
;
client
.
process_input
(
s2
.
unwrap
(
)
now
)
;
assert_eq
!
(
client
.
loss_recovery
.
rtt
(
)
RTT
)
;
let
streams
=
server
.
events
(
)
.
filter_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
Some
(
stream_id
)
}
else
{
None
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
streams
.
len
(
)
PACKETS
)
;
for
stream_id
in
streams
{
let
mut
buf
=
vec
!
[
0
;
DEFAULT_STREAM_DATA
.
len
(
)
+
1
]
;
let
(
recvd
fin
)
=
server
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
recvd
DEFAULT_STREAM_DATA
.
len
(
)
)
;
assert
!
(
fin
)
;
}
}
#
[
test
]
fn
corrupted_initial
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
d
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
mut
corrupted
=
Vec
:
:
from
(
&
d
[
.
.
]
)
;
let
(
idx
_
)
=
corrupted
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
.
find
(
|
(
_
&
v
)
|
v
!
=
0
)
.
unwrap
(
)
;
corrupted
[
idx
]
^
=
0x76
;
let
dgram
=
Datagram
:
:
new
(
d
.
source
(
)
d
.
destination
(
)
corrupted
)
;
server
.
process_input
(
dgram
now
(
)
)
;
assert_eq
!
(
server
.
stats
(
)
.
packets_rx
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
dropped_rx
2
)
;
assert_eq
!
(
server
.
stats
(
)
.
saved_datagrams
0
)
;
}
#
[
test
]
fn
verify_pkt_honors_mtu
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect_force_idle
(
&
mut
client
&
mut
server
)
;
let
now
=
now
(
)
;
let
res
=
client
.
process
(
None
now
)
;
assert_eq
!
(
res
Output
:
:
Callback
(
LOCAL_IDLE_TIMEOUT
)
)
;
assert_eq
!
(
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
2
)
;
assert_eq
!
(
client
.
stream_send
(
2
&
[
0xbb
;
2000
]
)
.
unwrap
(
)
2000
)
;
let
pkt0
=
client
.
process
(
None
now
)
;
assert
!
(
matches
!
(
pkt0
Output
:
:
Datagram
(
_
)
)
)
;
assert_eq
!
(
pkt0
.
as_dgram_ref
(
)
.
unwrap
(
)
.
len
(
)
PATH_MTU_V6
)
;
}
#
[
test
]
fn
extra_initial_hs
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_init
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c_init
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_init
=
server
.
process
(
c_init
now
)
.
dgram
(
)
;
assert
!
(
s_init
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
(
_
undecryptable
)
=
split_datagram
(
&
s_init
.
unwrap
(
)
)
;
assert
!
(
undecryptable
.
is_some
(
)
)
;
for
_
in
0
.
.
=
super
:
:
super
:
:
EXTRA_INITIALS
{
let
c_init
=
client
.
process
(
undecryptable
.
clone
(
)
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
&
c_init
.
as_ref
(
)
.
unwrap
(
)
false
)
;
now
+
=
DEFAULT_RTT
/
10
;
}
let
nothing
=
client
.
process
(
undecryptable
now
)
.
dgram
(
)
;
assert
!
(
nothing
.
is_none
(
)
)
;
now
+
=
AT_LEAST_PTO
;
let
c_init
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assertions
:
:
assert_initial
(
c_init
.
as_ref
(
)
.
unwrap
(
)
false
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_init
=
server
.
process
(
c_init
now
)
.
dgram
(
)
;
now
+
=
DEFAULT_RTT
/
2
;
client
.
process_input
(
s_init
.
unwrap
(
)
now
)
;
maybe_authenticate
(
&
mut
client
)
;
let
c_fin
=
client
.
process_output
(
now
)
.
dgram
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
now
+
=
DEFAULT_RTT
/
2
;
server
.
process_input
(
c_fin
.
unwrap
(
)
now
)
;
assert_eq
!
(
*
server
.
state
(
)
State
:
:
Confirmed
)
;
}
#
[
test
]
fn
extra_initial_invalid_cid
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
mut
now
=
now
(
)
;
let
c_init
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
c_init
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
s_init
=
server
.
process
(
c_init
now
)
.
dgram
(
)
;
assert
!
(
s_init
.
is_some
(
)
)
;
now
+
=
DEFAULT_RTT
/
2
;
let
(
_
hs
)
=
split_datagram
(
&
s_init
.
unwrap
(
)
)
;
let
hs
=
hs
.
unwrap
(
)
;
let
mut
copy
=
hs
.
to_vec
(
)
;
assert_ne
!
(
copy
[
5
]
0
)
;
copy
[
6
]
^
=
0xc4
;
let
dgram_copy
=
Datagram
:
:
new
(
hs
.
destination
(
)
hs
.
source
(
)
copy
)
;
let
nothing
=
client
.
process
(
Some
(
dgram_copy
)
now
)
.
dgram
(
)
;
assert
!
(
nothing
.
is_none
(
)
)
;
}
