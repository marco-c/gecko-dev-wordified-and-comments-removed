use
std
:
:
{
cell
:
:
RefCell
rc
:
:
Rc
}
;
use
neqo_common
:
:
{
event
:
:
Provider
as
_
Datagram
}
;
use
test_fixture
:
:
now
;
use
super
:
:
{
super
:
:
{
Connection
Error
Output
}
connect
default_client
default_server
fill_cwnd
maybe_authenticate
}
;
use
crate
:
:
{
addr_valid
:
:
{
AddressValidation
ValidateAddress
}
send_stream
:
:
{
RetransmissionPriority
TransmissionPriority
}
ConnectionEvent
StreamId
StreamType
}
;
const
BLOCK_SIZE
:
usize
=
4_096
;
fn
fill_stream
(
c
:
&
mut
Connection
id
:
StreamId
)
{
loop
{
if
c
.
stream_send
(
id
&
[
0x42
;
BLOCK_SIZE
]
)
.
unwrap
(
)
<
BLOCK_SIZE
{
return
;
}
}
}
#
[
test
]
fn
receive_stream
(
)
{
const
MESSAGE
:
&
[
u8
]
=
b
"
hello
"
;
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
id
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
assert_eq
!
(
MESSAGE
.
len
(
)
client
.
stream_send
(
id
MESSAGE
)
.
unwrap
(
)
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert_eq
!
(
server
.
stream_priority
(
id
TransmissionPriority
:
:
default
(
)
RetransmissionPriority
:
:
default
(
)
)
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
"
Priority
doesn
'
t
apply
to
inbound
unidirectional
streams
"
)
;
let
mut
buf
=
[
0
;
10
]
;
let
(
len
end
)
=
server
.
stream_recv
(
id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
MESSAGE
&
buf
[
.
.
len
]
)
;
assert
!
(
!
end
)
;
}
#
[
test
]
fn
relative
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
id_normal
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
fill_stream
(
&
mut
client
id_normal
)
;
let
high
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
fill_stream
(
&
mut
client
high
)
;
client
.
stream_priority
(
high
TransmissionPriority
:
:
High
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
for
e
in
server
.
events
(
)
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
assert_ne
!
(
stream_id
id_normal
)
;
}
}
}
#
[
test
]
fn
reprioritize
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
id_normal
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
fill_stream
(
&
mut
client
id_normal
)
;
let
id_high
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
fill_stream
(
&
mut
client
id_high
)
;
client
.
stream_priority
(
id_high
TransmissionPriority
:
:
High
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
for
e
in
server
.
events
(
)
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
assert_ne
!
(
stream_id
id_normal
)
;
}
}
client
.
stream_priority
(
id_high
TransmissionPriority
:
:
Normal
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
for
e
in
server
.
events
(
)
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
assert_ne
!
(
stream_id
id_high
)
;
}
}
}
#
[
test
]
fn
repairing_loss
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
mut
now
=
now
(
)
;
let
id_low
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
fill_stream
(
&
mut
client
id_low
)
;
client
.
stream_priority
(
id_low
TransmissionPriority
:
:
Low
RetransmissionPriority
:
:
Higher
)
.
unwrap
(
)
;
let
_lost
=
client
.
process_output
(
now
)
.
dgram
(
)
;
for
_
in
0
.
.
5
{
match
client
.
process_output
(
now
)
{
Output
:
:
Datagram
(
d
)
=
>
server
.
process_input
(
d
now
)
Output
:
:
Callback
(
delay
)
=
>
now
+
=
delay
Output
:
:
None
=
>
unreachable
!
(
)
}
}
let
ack
=
server
.
process_output
(
now
)
.
dgram
(
)
;
_
=
server
.
events
(
)
.
count
(
)
;
let
id_normal
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
fill_stream
(
&
mut
client
id_normal
)
;
let
dgram
=
client
.
process
(
ack
now
)
.
dgram
(
)
;
assert_eq
!
(
client
.
stats
(
)
.
lost
1
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
for
e
in
server
.
events
(
)
{
println
!
(
"
Event
:
{
e
:
?
}
"
)
;
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
assert_eq
!
(
stream_id
id_low
)
;
}
}
let
dgram
=
client
.
process_output
(
now
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
)
;
assert
!
(
server
.
events
(
)
.
any
(
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
if
stream_id
=
=
id_normal
)
)
)
;
}
fn
connect_for_0rtt
(
)
-
>
(
Connection
Connection
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram2
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
dgram
=
server
.
process
(
dgram2
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
(
client
server
)
}
fn
complete_handshake
(
client
:
&
mut
Connection
server
:
&
mut
Connection
dgram
:
Option
<
Datagram
>
)
{
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
maybe_authenticate
(
client
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
server
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
}
#
[
test
]
fn
critical
(
)
{
let
(
mut
client
mut
server
)
=
connect_for_0rtt
(
)
;
let
id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
server
.
stream_priority
(
id
TransmissionPriority
:
:
Critical
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
while
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
is_ok
(
)
{
}
fill_stream
(
&
mut
server
id
)
;
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
let
dgram
=
server
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
+
1
)
;
assert_eq
!
(
stats_after
.
streams_blocked
0
)
;
assert_eq
!
(
stats_after
.
new_connection_id
0
)
;
assert_eq
!
(
stats_after
.
new_token
0
)
;
assert_eq
!
(
stats_after
.
handshake_done
0
)
;
complete_handshake
(
&
mut
client
&
mut
server
dgram
)
;
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
drop
(
fill_cwnd
(
&
mut
server
id
now
(
)
)
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
)
;
assert_eq
!
(
stats_after
.
streams_blocked
0
)
;
assert_eq
!
(
stats_after
.
new_connection_id
0
)
;
assert_eq
!
(
stats_after
.
new_token
0
)
;
assert_eq
!
(
stats_after
.
handshake_done
1
)
;
}
#
[
test
]
fn
important
(
)
{
let
(
mut
client
mut
server
)
=
connect_for_0rtt
(
)
;
let
id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
server
.
stream_priority
(
id
TransmissionPriority
:
:
Important
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
fill_stream
(
&
mut
server
id
)
;
while
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
is_ok
(
)
{
}
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
let
dgram
=
server
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
+
1
)
;
assert_eq
!
(
stats_after
.
streams_blocked
1
)
;
assert_eq
!
(
stats_after
.
new_connection_id
0
)
;
assert_eq
!
(
stats_after
.
new_token
0
)
;
assert_eq
!
(
stats_after
.
handshake_done
0
)
;
assert_eq
!
(
stats_after
.
stream
stats_before
.
stream
+
1
)
;
complete_handshake
(
&
mut
client
&
mut
server
dgram
)
;
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
drop
(
fill_cwnd
(
&
mut
server
id
now
(
)
)
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
)
;
assert_eq
!
(
stats_after
.
streams_blocked
1
)
;
assert_eq
!
(
stats_after
.
new_connection_id
0
)
;
assert_eq
!
(
stats_after
.
new_token
0
)
;
assert_eq
!
(
stats_after
.
handshake_done
1
)
;
assert
!
(
stats_after
.
stream
>
stats_before
.
stream
)
;
}
#
[
test
]
fn
high_normal
(
)
{
let
(
mut
client
mut
server
)
=
connect_for_0rtt
(
)
;
let
id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
server
.
stream_priority
(
id
TransmissionPriority
:
:
High
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
fill_stream
(
&
mut
server
id
)
;
while
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
is_ok
(
)
{
}
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
let
dgram
=
server
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
+
1
)
;
assert_eq
!
(
stats_after
.
streams_blocked
1
)
;
assert_eq
!
(
stats_after
.
new_connection_id
0
)
;
assert_eq
!
(
stats_after
.
new_token
0
)
;
assert_eq
!
(
stats_after
.
handshake_done
0
)
;
assert_eq
!
(
stats_after
.
stream
stats_before
.
stream
+
1
)
;
complete_handshake
(
&
mut
client
&
mut
server
dgram
)
;
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
server
.
send_ticket
(
now
(
)
&
[
]
)
.
unwrap
(
)
;
drop
(
fill_cwnd
(
&
mut
server
id
now
(
)
)
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
)
;
assert_eq
!
(
stats_after
.
streams_blocked
1
)
;
assert_ne
!
(
stats_after
.
new_connection_id
0
)
;
assert_eq
!
(
stats_after
.
new_token
0
)
;
assert_eq
!
(
stats_after
.
handshake_done
1
)
;
assert
!
(
stats_after
.
stream
>
stats_before
.
stream
)
;
}
#
[
test
]
fn
low
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
now
=
now
(
)
;
let
validation
=
Rc
:
:
new
(
RefCell
:
:
new
(
AddressValidation
:
:
new
(
now
ValidateAddress
:
:
Never
)
.
unwrap
(
)
)
)
;
server
.
set_validation
(
&
validation
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
id
=
server
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
server
.
stream_priority
(
id
TransmissionPriority
:
:
Low
RetransmissionPriority
:
:
default
(
)
)
.
unwrap
(
)
;
fill_stream
(
&
mut
server
id
)
;
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
server
.
send_ticket
(
now
&
vec
!
[
0
;
server
.
plpmtu
(
)
]
)
.
unwrap
(
)
;
drop
(
server
.
process_output
(
now
)
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
+
1
)
;
assert_eq
!
(
stats_after
.
stream
stats_before
.
stream
)
;
let
stats_before
=
server
.
stats
(
)
.
frame_tx
;
drop
(
server
.
process_output
(
now
)
)
;
let
stats_after
=
server
.
stats
(
)
.
frame_tx
;
assert_eq
!
(
stats_after
.
crypto
stats_before
.
crypto
+
1
)
;
assert_eq
!
(
stats_after
.
new_token
1
)
;
assert_eq
!
(
stats_after
.
stream
stats_before
.
stream
+
1
)
;
}
