use
std
:
:
{
cmp
:
:
max
time
:
:
Duration
}
;
pub
use
crate
:
:
recovery
:
:
FAST_PTO_SCALE
;
use
crate
:
:
{
connection
:
:
{
ConnectionIdManager
Role
LOCAL_ACTIVE_CID_LIMIT
}
recv_stream
:
:
RECV_BUFFER_SIZE
rtt
:
:
GRANULARITY
stream_id
:
:
StreamType
tparams
:
:
{
self
PreferredAddress
TransportParameter
TransportParametersHandler
}
tracking
:
:
DEFAULT_ACK_DELAY
version
:
:
{
Version
VersionConfig
}
CongestionControlAlgorithm
Res
}
;
const
LOCAL_MAX_DATA
:
u64
=
0x3FFF_FFFF_FFFF_FFFF
;
const
LOCAL_STREAM_LIMIT_BIDI
:
u64
=
16
;
const
LOCAL_STREAM_LIMIT_UNI
:
u64
=
16
;
pub
const
ACK_RATIO_SCALE
:
u8
=
10
;
const
DEFAULT_ACK_RATIO
:
u8
=
4
*
ACK_RATIO_SCALE
;
const
DEFAULT_IDLE_TIMEOUT
:
Duration
=
Duration
:
:
from_secs
(
30
)
;
const
MAX_QUEUED_DATAGRAMS_DEFAULT
:
usize
=
10
;
#
[
derive
(
Debug
Clone
)
]
pub
enum
PreferredAddressConfig
{
Disabled
Default
Address
(
PreferredAddress
)
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ConnectionParameters
{
versions
:
VersionConfig
cc_algorithm
:
CongestionControlAlgorithm
max_data
:
u64
max_stream_data_bidi_remote
:
u64
max_stream_data_bidi_local
:
u64
max_stream_data_uni
:
u64
max_streams_bidi
:
u64
max_streams_uni
:
u64
ack_ratio
:
u8
idle_timeout
:
Duration
preferred_address
:
PreferredAddressConfig
datagram_size
:
u64
outgoing_datagram_queue
:
usize
incoming_datagram_queue
:
usize
fast_pto
:
u8
grease
:
bool
pacing
:
bool
pmtud
:
bool
}
impl
Default
for
ConnectionParameters
{
fn
default
(
)
-
>
Self
{
Self
{
versions
:
VersionConfig
:
:
default
(
)
cc_algorithm
:
CongestionControlAlgorithm
:
:
NewReno
max_data
:
LOCAL_MAX_DATA
max_stream_data_bidi_remote
:
u64
:
:
try_from
(
RECV_BUFFER_SIZE
)
.
unwrap
(
)
max_stream_data_bidi_local
:
u64
:
:
try_from
(
RECV_BUFFER_SIZE
)
.
unwrap
(
)
max_stream_data_uni
:
u64
:
:
try_from
(
RECV_BUFFER_SIZE
)
.
unwrap
(
)
max_streams_bidi
:
LOCAL_STREAM_LIMIT_BIDI
max_streams_uni
:
LOCAL_STREAM_LIMIT_UNI
ack_ratio
:
DEFAULT_ACK_RATIO
idle_timeout
:
DEFAULT_IDLE_TIMEOUT
preferred_address
:
PreferredAddressConfig
:
:
Default
datagram_size
:
0
outgoing_datagram_queue
:
MAX_QUEUED_DATAGRAMS_DEFAULT
incoming_datagram_queue
:
MAX_QUEUED_DATAGRAMS_DEFAULT
fast_pto
:
FAST_PTO_SCALE
grease
:
true
pacing
:
true
pmtud
:
false
}
}
}
impl
ConnectionParameters
{
#
[
must_use
]
pub
const
fn
get_versions
(
&
self
)
-
>
&
VersionConfig
{
&
self
.
versions
}
pub
(
crate
)
fn
get_versions_mut
(
&
mut
self
)
-
>
&
mut
VersionConfig
{
&
mut
self
.
versions
}
#
[
must_use
]
pub
fn
versions
(
mut
self
initial
:
Version
all
:
Vec
<
Version
>
)
-
>
Self
{
self
.
versions
=
VersionConfig
:
:
new
(
initial
all
)
;
self
}
#
[
must_use
]
pub
const
fn
get_cc_algorithm
(
&
self
)
-
>
CongestionControlAlgorithm
{
self
.
cc_algorithm
}
#
[
must_use
]
pub
const
fn
cc_algorithm
(
mut
self
v
:
CongestionControlAlgorithm
)
-
>
Self
{
self
.
cc_algorithm
=
v
;
self
}
#
[
must_use
]
pub
const
fn
get_max_data
(
&
self
)
-
>
u64
{
self
.
max_data
}
#
[
must_use
]
pub
const
fn
max_data
(
mut
self
v
:
u64
)
-
>
Self
{
self
.
max_data
=
v
;
self
}
#
[
must_use
]
pub
const
fn
get_max_streams
(
&
self
stream_type
:
StreamType
)
-
>
u64
{
match
stream_type
{
StreamType
:
:
BiDi
=
>
self
.
max_streams_bidi
StreamType
:
:
UniDi
=
>
self
.
max_streams_uni
}
}
#
[
must_use
]
pub
fn
max_streams
(
mut
self
stream_type
:
StreamType
v
:
u64
)
-
>
Self
{
assert
!
(
v
<
=
(
1
<
<
60
)
"
max_streams
is
too
large
"
)
;
match
stream_type
{
StreamType
:
:
BiDi
=
>
{
self
.
max_streams_bidi
=
v
;
}
StreamType
:
:
UniDi
=
>
{
self
.
max_streams_uni
=
v
;
}
}
self
}
#
[
must_use
]
pub
fn
get_max_stream_data
(
&
self
stream_type
:
StreamType
remote
:
bool
)
-
>
u64
{
match
(
stream_type
remote
)
{
(
StreamType
:
:
BiDi
false
)
=
>
self
.
max_stream_data_bidi_local
(
StreamType
:
:
BiDi
true
)
=
>
self
.
max_stream_data_bidi_remote
(
StreamType
:
:
UniDi
false
)
=
>
{
panic
!
(
"
Can
'
t
get
receive
limit
on
a
stream
that
can
only
be
sent
.
"
)
}
(
StreamType
:
:
UniDi
true
)
=
>
self
.
max_stream_data_uni
}
}
#
[
must_use
]
pub
fn
max_stream_data
(
mut
self
stream_type
:
StreamType
remote
:
bool
v
:
u64
)
-
>
Self
{
assert
!
(
v
<
(
1
<
<
62
)
"
max
stream
data
is
too
large
"
)
;
match
(
stream_type
remote
)
{
(
StreamType
:
:
BiDi
false
)
=
>
{
self
.
max_stream_data_bidi_local
=
v
;
}
(
StreamType
:
:
BiDi
true
)
=
>
{
self
.
max_stream_data_bidi_remote
=
v
;
}
(
StreamType
:
:
UniDi
false
)
=
>
{
panic
!
(
"
Can
'
t
set
receive
limit
on
a
stream
that
can
only
be
sent
.
"
)
}
(
StreamType
:
:
UniDi
true
)
=
>
{
self
.
max_stream_data_uni
=
v
;
}
}
self
}
#
[
must_use
]
pub
const
fn
preferred_address
(
mut
self
preferred
:
PreferredAddress
)
-
>
Self
{
self
.
preferred_address
=
PreferredAddressConfig
:
:
Address
(
preferred
)
;
self
}
#
[
must_use
]
pub
const
fn
disable_preferred_address
(
mut
self
)
-
>
Self
{
self
.
preferred_address
=
PreferredAddressConfig
:
:
Disabled
;
self
}
#
[
must_use
]
pub
const
fn
get_preferred_address
(
&
self
)
-
>
&
PreferredAddressConfig
{
&
self
.
preferred_address
}
#
[
must_use
]
pub
const
fn
ack_ratio
(
mut
self
ack_ratio
:
u8
)
-
>
Self
{
self
.
ack_ratio
=
ack_ratio
;
self
}
#
[
must_use
]
pub
const
fn
get_ack_ratio
(
&
self
)
-
>
u8
{
self
.
ack_ratio
}
#
[
must_use
]
pub
fn
idle_timeout
(
mut
self
timeout
:
Duration
)
-
>
Self
{
assert
!
(
timeout
.
as_millis
(
)
<
(
1
<
<
62
)
"
idle
timeout
is
too
long
"
)
;
self
.
idle_timeout
=
timeout
;
self
}
#
[
must_use
]
pub
const
fn
get_idle_timeout
(
&
self
)
-
>
Duration
{
self
.
idle_timeout
}
#
[
must_use
]
pub
const
fn
get_datagram_size
(
&
self
)
-
>
u64
{
self
.
datagram_size
}
#
[
must_use
]
pub
const
fn
datagram_size
(
mut
self
v
:
u64
)
-
>
Self
{
self
.
datagram_size
=
v
;
self
}
#
[
must_use
]
pub
const
fn
get_outgoing_datagram_queue
(
&
self
)
-
>
usize
{
self
.
outgoing_datagram_queue
}
#
[
must_use
]
pub
fn
outgoing_datagram_queue
(
mut
self
v
:
usize
)
-
>
Self
{
self
.
outgoing_datagram_queue
=
max
(
v
1
)
;
self
}
#
[
must_use
]
pub
const
fn
get_incoming_datagram_queue
(
&
self
)
-
>
usize
{
self
.
incoming_datagram_queue
}
#
[
must_use
]
pub
fn
incoming_datagram_queue
(
mut
self
v
:
usize
)
-
>
Self
{
self
.
incoming_datagram_queue
=
max
(
v
1
)
;
self
}
#
[
must_use
]
pub
const
fn
get_fast_pto
(
&
self
)
-
>
u8
{
self
.
fast_pto
}
#
[
must_use
]
pub
fn
fast_pto
(
mut
self
scale
:
u8
)
-
>
Self
{
assert_ne
!
(
scale
0
)
;
self
.
fast_pto
=
scale
;
self
}
#
[
must_use
]
pub
const
fn
is_greasing
(
&
self
)
-
>
bool
{
self
.
grease
}
#
[
must_use
]
pub
const
fn
grease
(
mut
self
grease
:
bool
)
-
>
Self
{
self
.
grease
=
grease
;
self
}
#
[
must_use
]
pub
const
fn
pacing_enabled
(
&
self
)
-
>
bool
{
self
.
pacing
}
#
[
must_use
]
pub
const
fn
pacing
(
mut
self
pacing
:
bool
)
-
>
Self
{
self
.
pacing
=
pacing
;
self
}
#
[
must_use
]
pub
const
fn
pmtud_enabled
(
&
self
)
-
>
bool
{
self
.
pmtud
}
#
[
must_use
]
pub
const
fn
pmtud
(
mut
self
pmtud
:
bool
)
-
>
Self
{
self
.
pmtud
=
pmtud
;
self
}
pub
fn
create_transport_parameter
(
&
self
role
:
Role
cid_manager
:
&
mut
ConnectionIdManager
)
-
>
Res
<
TransportParametersHandler
>
{
let
mut
tps
=
TransportParametersHandler
:
:
new
(
role
self
.
versions
.
clone
(
)
)
;
tps
.
local
.
set_integer
(
tparams
:
:
ACTIVE_CONNECTION_ID_LIMIT
u64
:
:
try_from
(
LOCAL_ACTIVE_CID_LIMIT
)
?
)
;
tps
.
local
.
set_empty
(
tparams
:
:
DISABLE_MIGRATION
)
;
tps
.
local
.
set_empty
(
tparams
:
:
GREASE_QUIC_BIT
)
;
tps
.
local
.
set_integer
(
tparams
:
:
MAX_ACK_DELAY
u64
:
:
try_from
(
DEFAULT_ACK_DELAY
.
as_millis
(
)
)
?
)
;
tps
.
local
.
set_integer
(
tparams
:
:
MIN_ACK_DELAY
u64
:
:
try_from
(
GRANULARITY
.
as_micros
(
)
)
?
)
;
tps
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_DATA
self
.
max_data
)
;
tps
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
self
.
max_stream_data_bidi_local
)
;
tps
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
self
.
max_stream_data_bidi_remote
)
;
tps
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
self
.
max_stream_data_uni
)
;
tps
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_BIDI
self
.
max_streams_bidi
)
;
tps
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_UNI
self
.
max_streams_uni
)
;
tps
.
local
.
set_integer
(
tparams
:
:
IDLE_TIMEOUT
u64
:
:
try_from
(
self
.
idle_timeout
.
as_millis
(
)
)
.
unwrap_or
(
0
)
)
;
if
let
PreferredAddressConfig
:
:
Address
(
preferred
)
=
&
self
.
preferred_address
{
if
role
=
=
Role
:
:
Server
{
let
(
cid
srt
)
=
cid_manager
.
preferred_address_cid
(
)
?
;
tps
.
local
.
set
(
tparams
:
:
PREFERRED_ADDRESS
TransportParameter
:
:
PreferredAddress
{
v4
:
preferred
.
ipv4
(
)
v6
:
preferred
.
ipv6
(
)
cid
srt
}
)
;
}
}
tps
.
local
.
set_integer
(
tparams
:
:
MAX_DATAGRAM_FRAME_SIZE
self
.
datagram_size
)
;
Ok
(
tps
)
}
}
