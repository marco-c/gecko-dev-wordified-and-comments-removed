use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
cmp
:
:
{
max
min
}
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
use
std
:
:
mem
;
use
std
:
:
net
:
:
{
IpAddr
SocketAddr
}
;
use
std
:
:
rc
:
:
{
Rc
Weak
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
smallvec
:
:
SmallVec
;
use
neqo_common
:
:
{
event
:
:
Provider
as
EventProvider
hex
hex_snip_middle
qdebug
qerror
qinfo
qlog
:
:
NeqoQlog
qtrace
qwarn
Datagram
Decoder
Encoder
Role
}
;
use
neqo_crypto
:
:
{
agent
:
:
CertificateInfo
random
Agent
AntiReplay
AuthenticationStatus
Cipher
Client
HandshakeState
ResumptionToken
SecretAgentInfo
Server
ZeroRttChecker
}
;
use
crate
:
:
addr_valid
:
:
{
AddressValidation
NewTokenState
}
;
use
crate
:
:
cid
:
:
{
ConnectionId
ConnectionIdEntry
ConnectionIdGenerator
ConnectionIdManager
ConnectionIdRef
ConnectionIdStore
LOCAL_ACTIVE_CID_LIMIT
}
;
use
crate
:
:
crypto
:
:
{
Crypto
CryptoDxState
CryptoSpace
}
;
use
crate
:
:
dump
:
:
*
;
use
crate
:
:
events
:
:
{
ConnectionEvent
ConnectionEvents
}
;
use
crate
:
:
flow_mgr
:
:
FlowMgr
;
use
crate
:
:
frame
:
:
{
AckRange
CloseError
Frame
FrameType
FRAME_TYPE_CONNECTION_CLOSE_APPLICATION
FRAME_TYPE_CONNECTION_CLOSE_TRANSPORT
}
;
use
crate
:
:
packet
:
:
{
DecryptedPacket
PacketBuilder
PacketNumber
PacketType
PublicPacket
QuicVersion
}
;
use
crate
:
:
path
:
:
{
Path
PathRef
Paths
}
;
use
crate
:
:
qlog
;
use
crate
:
:
recovery
:
:
{
LossRecovery
RecoveryToken
SendProfile
GRANULARITY
}
;
use
crate
:
:
recv_stream
:
:
{
RecvStream
RecvStreams
RECV_BUFFER_SIZE
}
;
use
crate
:
:
send_stream
:
:
{
SendStream
SendStreams
}
;
use
crate
:
:
stats
:
:
{
Stats
StatsCell
}
;
use
crate
:
:
stream_id
:
:
{
StreamId
StreamIndex
StreamIndexes
StreamType
}
;
use
crate
:
:
tparams
:
:
{
self
TransportParameter
TransportParameters
TransportParametersHandler
}
;
use
crate
:
:
tracking
:
:
{
AckTracker
PNSpace
SentPacket
}
;
use
crate
:
:
{
AppError
ConnectionError
Error
Res
}
;
mod
idle
;
pub
mod
params
;
mod
saved
;
mod
state
;
use
idle
:
:
IdleTimeout
;
pub
use
idle
:
:
LOCAL_IDLE_TIMEOUT
;
pub
use
params
:
:
ConnectionParameters
;
use
params
:
:
PreferredAddressConfig
;
use
saved
:
:
SavedDatagrams
;
use
state
:
:
StateSignaling
;
pub
use
state
:
:
{
ClosingFrame
State
}
;
#
[
derive
(
Debug
Default
)
]
struct
Packet
(
Vec
<
u8
>
)
;
const
EXTRA_INITIALS
:
usize
=
4
;
const
LOCAL_MAX_DATA
:
u64
=
0x3FFF_FFFF_FFFF_FFFF
;
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
ZeroRttState
{
Init
Sending
AcceptedClient
AcceptedServer
Rejected
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
Output
{
None
Datagram
(
Datagram
)
Callback
(
Duration
)
}
impl
Output
{
#
[
must_use
]
pub
fn
dgram
(
self
)
-
>
Option
<
Datagram
>
{
match
self
{
Self
:
:
Datagram
(
dg
)
=
>
Some
(
dg
)
_
=
>
None
}
}
pub
fn
as_dgram_ref
(
&
self
)
-
>
Option
<
&
Datagram
>
{
match
self
{
Self
:
:
Datagram
(
dg
)
=
>
Some
(
dg
)
_
=
>
None
}
}
#
[
must_use
]
pub
fn
callback
(
&
self
)
-
>
Duration
{
match
self
{
Self
:
:
Callback
(
t
)
=
>
*
t
_
=
>
Duration
:
:
new
(
0
0
)
}
}
}
enum
SendOption
{
Yes
(
Datagram
)
No
(
bool
)
}
impl
Default
for
SendOption
{
fn
default
(
)
-
>
Self
{
Self
:
:
No
(
false
)
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
enum
PreprocessResult
{
End
Next
Continue
}
enum
AddressValidationInfo
{
None
NewToken
(
Vec
<
u8
>
)
Retry
{
token
:
Vec
<
u8
>
retry_source_cid
:
ConnectionId
}
Server
(
Weak
<
RefCell
<
AddressValidation
>
>
)
}
impl
AddressValidationInfo
{
pub
fn
token
(
&
self
)
-
>
&
[
u8
]
{
match
self
{
Self
:
:
NewToken
(
token
)
|
Self
:
:
Retry
{
token
.
.
}
=
>
&
token
_
=
>
&
[
]
}
}
pub
fn
generate_new_token
(
&
mut
self
peer_address
:
SocketAddr
now
:
Instant
)
-
>
Option
<
Vec
<
u8
>
>
{
match
self
{
Self
:
:
Server
(
ref
w
)
=
>
{
if
let
Some
(
validation
)
=
w
.
upgrade
(
)
{
validation
.
borrow
(
)
.
generate_new_token
(
peer_address
now
)
.
ok
(
)
}
else
{
None
}
}
Self
:
:
None
=
>
None
_
=
>
unreachable
!
(
"
called
a
server
function
on
a
client
"
)
}
}
}
pub
struct
Connection
{
role
:
Role
state
:
State
tps
:
Rc
<
RefCell
<
TransportParametersHandler
>
>
zero_rtt_state
:
ZeroRttState
paths
:
Paths
cid_manager
:
ConnectionIdManager
address_validation
:
AddressValidationInfo
connection_ids
:
ConnectionIdStore
<
[
u8
;
16
]
>
local_initial_source_cid
:
ConnectionId
remote_initial_source_cid
:
Option
<
ConnectionId
>
original_destination_cid
:
Option
<
ConnectionId
>
saved_datagrams
:
SavedDatagrams
pub
(
crate
)
crypto
:
Crypto
pub
(
crate
)
acks
:
AckTracker
idle_timeout
:
IdleTimeout
pub
(
crate
)
indexes
:
StreamIndexes
pub
(
crate
)
send_streams
:
SendStreams
pub
(
crate
)
recv_streams
:
RecvStreams
pub
(
crate
)
flow_mgr
:
Rc
<
RefCell
<
FlowMgr
>
>
state_signaling
:
StateSignaling
loss_recovery
:
LossRecovery
events
:
ConnectionEvents
new_token
:
NewTokenState
stats
:
StatsCell
qlog
:
NeqoQlog
release_resumption_token_timer
:
Option
<
Instant
>
conn_params
:
ConnectionParameters
}
impl
Debug
for
Connection
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
Connection
:
{
:
?
}
{
:
?
}
"
self
.
role
self
.
state
self
.
paths
.
primary_fallible
(
)
)
}
}
impl
Connection
{
pub
fn
new_client
(
server_name
:
&
str
protocols
:
&
[
impl
AsRef
<
str
>
]
cid_generator
:
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
local_addr
:
SocketAddr
remote_addr
:
SocketAddr
conn_params
:
ConnectionParameters
)
-
>
Res
<
Self
>
{
let
dcid
=
ConnectionId
:
:
generate_initial
(
)
;
let
mut
c
=
Self
:
:
new
(
Role
:
:
Client
Client
:
:
new
(
server_name
)
?
.
into
(
)
cid_generator
protocols
conn_params
)
?
;
c
.
crypto
.
states
.
init
(
c
.
version
(
)
Role
:
:
Client
&
dcid
)
;
c
.
original_destination_cid
=
Some
(
dcid
)
;
let
path
=
Path
:
:
temporary
(
local_addr
remote_addr
)
;
c
.
setup_handshake_path
(
&
Rc
:
:
new
(
RefCell
:
:
new
(
path
)
)
)
;
Ok
(
c
)
}
pub
fn
new_server
(
certs
:
&
[
impl
AsRef
<
str
>
]
protocols
:
&
[
impl
AsRef
<
str
>
]
cid_generator
:
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
conn_params
:
ConnectionParameters
)
-
>
Res
<
Self
>
{
Self
:
:
new
(
Role
:
:
Server
Server
:
:
new
(
certs
)
?
.
into
(
)
cid_generator
protocols
conn_params
)
}
pub
fn
server_enable_0rtt
(
&
mut
self
anti_replay
:
&
AntiReplay
zero_rtt_checker
:
impl
ZeroRttChecker
+
'
static
)
-
>
Res
<
(
)
>
{
self
.
crypto
.
server_enable_0rtt
(
self
.
tps
.
clone
(
)
anti_replay
zero_rtt_checker
)
}
fn
set_tp_defaults
(
tps
:
&
mut
TransportParameters
)
{
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
u64
:
:
try_from
(
RECV_BUFFER_SIZE
)
.
unwrap
(
)
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
u64
:
:
try_from
(
RECV_BUFFER_SIZE
)
.
unwrap
(
)
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
u64
:
:
try_from
(
RECV_BUFFER_SIZE
)
.
unwrap
(
)
)
;
tps
.
set_integer
(
tparams
:
:
INITIAL_MAX_DATA
LOCAL_MAX_DATA
)
;
tps
.
set_integer
(
tparams
:
:
IDLE_TIMEOUT
u64
:
:
try_from
(
LOCAL_IDLE_TIMEOUT
.
as_millis
(
)
)
.
unwrap
(
)
)
;
tps
.
set_integer
(
tparams
:
:
ACTIVE_CONNECTION_ID_LIMIT
u64
:
:
try_from
(
LOCAL_ACTIVE_CID_LIMIT
)
.
unwrap
(
)
)
;
tps
.
set_empty
(
tparams
:
:
DISABLE_MIGRATION
)
;
tps
.
set_empty
(
tparams
:
:
GREASE_QUIC_BIT
)
;
}
fn
read_parameters
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
tps
.
borrow_mut
(
)
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_BIDI
self
.
conn_params
.
get_max_streams
(
StreamType
:
:
BiDi
)
.
as_u64
(
)
)
;
self
.
tps
.
borrow_mut
(
)
.
local
.
set_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_UNI
self
.
conn_params
.
get_max_streams
(
StreamType
:
:
UniDi
)
.
as_u64
(
)
)
;
if
let
PreferredAddressConfig
:
:
Address
(
preferred
)
=
self
.
conn_params
.
get_preferred_address
(
)
{
if
self
.
role
=
=
Role
:
:
Server
{
let
(
cid
srt
)
=
self
.
cid_manager
.
preferred_address_cid
(
)
?
;
self
.
tps
.
borrow_mut
(
)
.
local
.
set
(
tparams
:
:
PREFERRED_ADDRESS
TransportParameter
:
:
PreferredAddress
{
v4
:
preferred
.
ipv4
(
)
v6
:
preferred
.
ipv6
(
)
cid
srt
}
)
;
}
}
Ok
(
(
)
)
}
fn
new
(
role
:
Role
agent
:
Agent
cid_generator
:
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
protocols
:
&
[
impl
AsRef
<
str
>
]
conn_params
:
ConnectionParameters
)
-
>
Res
<
Self
>
{
let
mut
tps
=
TransportParametersHandler
:
:
default
(
)
;
Self
:
:
set_tp_defaults
(
&
mut
tps
.
local
)
;
let
local_initial_source_cid
=
cid_generator
.
borrow_mut
(
)
.
generate_cid
(
)
.
ok_or
(
Error
:
:
ConnectionIdsExhausted
)
?
;
tps
.
local
.
set_bytes
(
tparams
:
:
INITIAL_SOURCE_CONNECTION_ID
local_initial_source_cid
.
to_vec
(
)
)
;
let
cid_manager
=
ConnectionIdManager
:
:
new
(
cid_generator
local_initial_source_cid
.
clone
(
)
)
;
let
tphandler
=
Rc
:
:
new
(
RefCell
:
:
new
(
tps
)
)
;
let
crypto
=
Crypto
:
:
new
(
agent
protocols
tphandler
.
clone
(
)
)
?
;
let
stats
=
StatsCell
:
:
default
(
)
;
let
indexes
=
StreamIndexes
:
:
new
(
conn_params
.
get_max_streams
(
StreamType
:
:
BiDi
)
conn_params
.
get_max_streams
(
StreamType
:
:
UniDi
)
)
;
let
mut
c
=
Self
{
role
state
:
State
:
:
Init
paths
:
Paths
:
:
default
(
)
cid_manager
tps
:
tphandler
zero_rtt_state
:
ZeroRttState
:
:
Init
address_validation
:
AddressValidationInfo
:
:
None
local_initial_source_cid
remote_initial_source_cid
:
None
original_destination_cid
:
None
saved_datagrams
:
SavedDatagrams
:
:
default
(
)
crypto
acks
:
AckTracker
:
:
default
(
)
idle_timeout
:
IdleTimeout
:
:
default
(
)
indexes
connection_ids
:
ConnectionIdStore
:
:
default
(
)
send_streams
:
SendStreams
:
:
default
(
)
recv_streams
:
RecvStreams
:
:
default
(
)
flow_mgr
:
Rc
:
:
new
(
RefCell
:
:
new
(
FlowMgr
:
:
default
(
)
)
)
state_signaling
:
StateSignaling
:
:
Idle
loss_recovery
:
LossRecovery
:
:
new
(
conn_params
.
get_cc_algorithm
(
)
stats
.
clone
(
)
)
events
:
ConnectionEvents
:
:
default
(
)
new_token
:
NewTokenState
:
:
new
(
role
)
stats
qlog
:
NeqoQlog
:
:
disabled
(
)
release_resumption_token_timer
:
None
conn_params
}
;
c
.
read_parameters
(
)
?
;
c
.
stats
.
borrow_mut
(
)
.
init
(
format
!
(
"
{
}
"
c
)
)
;
Ok
(
c
)
}
pub
fn
set_qlog
(
&
mut
self
qlog
:
NeqoQlog
)
{
self
.
loss_recovery
.
set_qlog
(
qlog
.
clone
(
)
)
;
self
.
qlog
=
qlog
;
}
pub
fn
qlog_mut
(
&
mut
self
)
-
>
&
mut
NeqoQlog
{
&
mut
self
.
qlog
}
pub
fn
odcid
(
&
self
)
-
>
Option
<
&
ConnectionId
>
{
self
.
original_destination_cid
.
as_ref
(
)
}
pub
fn
set_local_tparam
(
&
self
tp
:
crate
:
:
tparams
:
:
TransportParameterId
value
:
TransportParameter
)
-
>
Res
<
(
)
>
{
if
*
self
.
state
(
)
=
=
State
:
:
Init
{
self
.
tps
.
borrow_mut
(
)
.
local
.
set
(
tp
value
)
;
Ok
(
(
)
)
}
else
{
qerror
!
(
"
Current
state
:
{
:
?
}
"
self
.
state
(
)
)
;
qerror
!
(
"
Cannot
set
local
tparam
when
not
in
an
initial
connection
state
.
"
)
;
Err
(
Error
:
:
ConnectionState
)
}
}
pub
(
crate
)
fn
set_retry_cids
(
&
mut
self
odcid
:
ConnectionId
remote_cid
:
ConnectionId
retry_cid
:
ConnectionId
)
{
debug_assert_eq
!
(
self
.
role
Role
:
:
Server
)
;
qtrace
!
(
[
self
]
"
Retry
CIDs
:
odcid
=
{
}
remote
=
{
}
retry
=
{
}
"
odcid
remote_cid
retry_cid
)
;
let
local_tps
=
&
mut
self
.
tps
.
borrow_mut
(
)
.
local
;
local_tps
.
set_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
odcid
.
to_vec
(
)
)
;
local_tps
.
set_bytes
(
tparams
:
:
RETRY_SOURCE_CONNECTION_ID
retry_cid
.
to_vec
(
)
)
;
self
.
remote_initial_source_cid
=
Some
(
remote_cid
)
;
}
fn
retry_sent
(
&
self
)
-
>
bool
{
self
.
tps
.
borrow
(
)
.
local
.
get_bytes
(
tparams
:
:
RETRY_SOURCE_CONNECTION_ID
)
.
is_some
(
)
}
pub
fn
set_alpn
(
&
mut
self
protocols
:
&
[
impl
AsRef
<
str
>
]
)
-
>
Res
<
(
)
>
{
self
.
crypto
.
tls
.
set_alpn
(
protocols
)
?
;
Ok
(
(
)
)
}
pub
fn
set_ciphers
(
&
mut
self
ciphers
:
&
[
Cipher
]
)
-
>
Res
<
(
)
>
{
if
self
.
state
!
=
State
:
:
Init
{
qerror
!
(
[
self
]
"
Cannot
enable
ciphers
in
state
{
:
?
}
"
self
.
state
)
;
return
Err
(
Error
:
:
ConnectionState
)
;
}
self
.
crypto
.
tls
.
set_ciphers
(
ciphers
)
?
;
Ok
(
(
)
)
}
fn
make_resumption_token
(
&
mut
self
)
-
>
ResumptionToken
{
debug_assert_eq
!
(
self
.
role
Role
:
:
Client
)
;
debug_assert
!
(
self
.
crypto
.
has_resumption_token
(
)
)
;
self
.
crypto
.
create_resumption_token
(
self
.
new_token
.
take_token
(
)
self
.
tps
.
borrow
(
)
.
remote
.
as_ref
(
)
.
expect
(
"
should
have
transport
parameters
"
)
u64
:
:
try_from
(
self
.
loss_recovery
.
rtt
(
)
.
as_millis
(
)
)
.
unwrap_or
(
0
)
)
.
unwrap
(
)
}
fn
create_resumption_token
(
&
mut
self
now
:
Instant
)
{
if
self
.
role
=
=
Role
:
:
Server
|
|
self
.
state
<
State
:
:
Connected
{
return
;
}
qtrace
!
(
[
self
]
"
Maybe
create
resumption
token
:
{
}
{
}
"
self
.
crypto
.
has_resumption_token
(
)
self
.
new_token
.
has_token
(
)
)
;
while
self
.
crypto
.
has_resumption_token
(
)
&
&
self
.
new_token
.
has_token
(
)
{
let
token
=
self
.
make_resumption_token
(
)
;
self
.
events
.
client_resumption_token
(
token
)
;
}
if
self
.
crypto
.
has_resumption_token
(
)
{
let
arm
=
if
let
Some
(
expiration_time
)
=
self
.
release_resumption_token_timer
{
if
expiration_time
<
=
now
{
let
token
=
self
.
make_resumption_token
(
)
;
self
.
events
.
client_resumption_token
(
token
)
;
self
.
release_resumption_token_timer
=
None
;
self
.
crypto
.
has_resumption_token
(
)
}
else
{
false
}
}
else
{
true
}
;
if
arm
{
self
.
release_resumption_token_timer
=
Some
(
now
+
3
*
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
)
;
}
}
}
pub
fn
take_resumption_token
(
&
mut
self
now
:
Instant
)
-
>
Option
<
ResumptionToken
>
{
assert_eq
!
(
self
.
role
Role
:
:
Client
)
;
if
self
.
crypto
.
has_resumption_token
(
)
{
let
token
=
self
.
make_resumption_token
(
)
;
if
self
.
crypto
.
has_resumption_token
(
)
{
self
.
release_resumption_token_timer
=
Some
(
now
+
3
*
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
)
;
}
Some
(
token
)
}
else
{
None
}
}
pub
fn
enable_resumption
(
&
mut
self
now
:
Instant
token
:
impl
AsRef
<
[
u8
]
>
)
-
>
Res
<
(
)
>
{
if
self
.
state
!
=
State
:
:
Init
{
qerror
!
(
[
self
]
"
set
token
in
state
{
:
?
}
"
self
.
state
)
;
return
Err
(
Error
:
:
ConnectionState
)
;
}
if
self
.
role
=
=
Role
:
:
Server
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
qinfo
!
(
[
self
]
"
resumption
token
{
}
"
hex_snip_middle
(
token
.
as_ref
(
)
)
)
;
let
mut
dec
=
Decoder
:
:
from
(
token
.
as_ref
(
)
)
;
let
smoothed_rtt
=
Duration
:
:
from_millis
(
dec
.
decode_varint
(
)
.
ok_or
(
Error
:
:
InvalidResumptionToken
)
?
)
;
qtrace
!
(
[
self
]
"
RTT
{
:
?
}
"
smoothed_rtt
)
;
let
tp_slice
=
dec
.
decode_vvec
(
)
.
ok_or
(
Error
:
:
InvalidResumptionToken
)
?
;
qtrace
!
(
[
self
]
"
transport
parameters
{
}
"
hex
(
&
tp_slice
)
)
;
let
mut
dec_tp
=
Decoder
:
:
from
(
tp_slice
)
;
let
tp
=
TransportParameters
:
:
decode
(
&
mut
dec_tp
)
.
map_err
(
|
_
|
Error
:
:
InvalidResumptionToken
)
?
;
let
init_token
=
dec
.
decode_vvec
(
)
.
ok_or
(
Error
:
:
InvalidResumptionToken
)
?
;
qtrace
!
(
[
self
]
"
Initial
token
{
}
"
hex
(
&
init_token
)
)
;
let
tok
=
dec
.
decode_remainder
(
)
;
qtrace
!
(
[
self
]
"
TLS
token
{
}
"
hex
(
&
tok
)
)
;
match
self
.
crypto
.
tls
{
Agent
:
:
Client
(
ref
mut
c
)
=
>
{
let
res
=
c
.
enable_resumption
(
&
tok
)
;
if
let
Err
(
e
)
=
res
{
self
.
absorb_error
:
:
<
Error
>
(
now
Err
(
Error
:
:
from
(
e
)
)
)
;
return
Ok
(
(
)
)
;
}
}
Agent
:
:
Server
(
_
)
=
>
return
Err
(
Error
:
:
WrongRole
)
}
self
.
tps
.
borrow_mut
(
)
.
remote_0rtt
=
Some
(
tp
)
;
if
!
init_token
.
is_empty
(
)
{
self
.
address_validation
=
AddressValidationInfo
:
:
NewToken
(
init_token
.
to_vec
(
)
)
;
}
if
smoothed_rtt
>
GRANULARITY
{
self
.
loss_recovery
.
set_initial_rtt
(
smoothed_rtt
)
;
}
self
.
set_initial_limits
(
)
;
let
res
=
self
.
client_start
(
now
)
;
self
.
absorb_error
(
now
res
)
;
Ok
(
(
)
)
}
pub
(
crate
)
fn
set_validation
(
&
mut
self
validation
:
Rc
<
RefCell
<
AddressValidation
>
>
)
{
qtrace
!
(
[
self
]
"
Enabling
NEW_TOKEN
"
)
;
assert_eq
!
(
self
.
role
Role
:
:
Server
)
;
self
.
address_validation
=
AddressValidationInfo
:
:
Server
(
Rc
:
:
downgrade
(
&
validation
)
)
;
}
pub
fn
send_ticket
(
&
mut
self
now
:
Instant
extra
:
&
[
u8
]
)
-
>
Res
<
(
)
>
{
if
self
.
role
=
=
Role
:
:
Client
{
return
Err
(
Error
:
:
WrongRole
)
;
}
let
tps
=
&
self
.
tps
;
if
let
Agent
:
:
Server
(
ref
mut
s
)
=
self
.
crypto
.
tls
{
let
mut
enc
=
Encoder
:
:
default
(
)
;
enc
.
encode_vvec_with
(
|
mut
enc_inner
|
{
tps
.
borrow
(
)
.
local
.
encode
(
&
mut
enc_inner
)
;
}
)
;
enc
.
encode
(
extra
)
;
let
records
=
s
.
send_ticket
(
now
&
enc
)
?
;
qinfo
!
(
[
self
]
"
send
session
ticket
{
}
"
hex
(
&
enc
)
)
;
self
.
crypto
.
buffer_records
(
records
)
?
;
}
else
{
unreachable
!
(
)
;
}
if
let
Some
(
path
)
=
self
.
paths
.
primary_fallible
(
)
{
if
let
Some
(
token
)
=
self
.
address_validation
.
generate_new_token
(
path
.
borrow
(
)
.
remote_address
(
)
now
)
{
self
.
new_token
.
send_new_token
(
token
)
;
}
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
NotConnected
)
}
}
pub
fn
tls_info
(
&
self
)
-
>
Option
<
&
SecretAgentInfo
>
{
self
.
crypto
.
tls
.
info
(
)
}
pub
fn
peer_certificate
(
&
self
)
-
>
Option
<
CertificateInfo
>
{
self
.
crypto
.
tls
.
peer_certificate
(
)
}
pub
fn
authenticated
(
&
mut
self
status
:
AuthenticationStatus
now
:
Instant
)
{
qinfo
!
(
[
self
]
"
Authenticated
{
:
?
}
"
status
)
;
self
.
crypto
.
tls
.
authenticated
(
status
)
;
let
res
=
self
.
handshake
(
now
PNSpace
:
:
Handshake
None
)
;
self
.
absorb_error
(
now
res
)
;
self
.
process_saved
(
now
)
;
}
pub
fn
role
(
&
self
)
-
>
Role
{
self
.
role
}
pub
fn
state
(
&
self
)
-
>
&
State
{
&
self
.
state
}
pub
fn
version
(
&
self
)
-
>
QuicVersion
{
self
.
conn_params
.
get_quic_version
(
)
}
pub
fn
zero_rtt_state
(
&
self
)
-
>
&
ZeroRttState
{
&
self
.
zero_rtt_state
}
pub
fn
stats
(
&
self
)
-
>
Stats
{
self
.
stats
.
borrow
(
)
.
clone
(
)
}
fn
capture_error
<
T
>
(
&
mut
self
path
:
Option
<
PathRef
>
now
:
Instant
frame_type
:
FrameType
res
:
Res
<
T
>
)
-
>
Res
<
T
>
{
if
let
Err
(
v
)
=
&
res
{
#
[
cfg
(
debug_assertions
)
]
let
msg
=
format
!
(
"
{
:
?
}
"
v
)
;
#
[
cfg
(
not
(
debug_assertions
)
)
]
let
msg
=
"
"
;
let
error
=
ConnectionError
:
:
Transport
(
v
.
clone
(
)
)
;
match
&
self
.
state
{
State
:
:
Closing
{
error
:
err
.
.
}
|
State
:
:
Draining
{
error
:
err
.
.
}
|
State
:
:
Closed
(
err
)
=
>
{
qwarn
!
(
[
self
]
"
Closing
again
after
error
{
:
?
}
"
err
)
;
}
State
:
:
Init
=
>
{
self
.
set_state
(
State
:
:
Closed
(
error
)
)
;
}
State
:
:
WaitInitial
=
>
{
if
let
Some
(
path
)
=
path
.
or_else
(
|
|
self
.
paths
.
primary_fallible
(
)
)
{
self
.
state_signaling
.
close
(
path
error
.
clone
(
)
frame_type
msg
)
;
}
self
.
set_state
(
State
:
:
Closed
(
error
)
)
;
}
_
=
>
{
if
let
Some
(
path
)
=
path
.
or_else
(
|
|
self
.
paths
.
primary_fallible
(
)
)
{
self
.
state_signaling
.
close
(
path
error
.
clone
(
)
frame_type
msg
)
;
if
matches
!
(
v
Error
:
:
KeysExhausted
)
{
self
.
set_state
(
State
:
:
Closed
(
error
)
)
;
}
else
{
self
.
set_state
(
State
:
:
Closing
{
error
timeout
:
self
.
get_closing_period_time
(
now
)
}
)
;
}
}
else
{
self
.
set_state
(
State
:
:
Closed
(
error
)
)
;
}
}
}
}
res
}
fn
absorb_error
<
T
>
(
&
mut
self
now
:
Instant
res
:
Res
<
T
>
)
-
>
Option
<
T
>
{
self
.
capture_error
(
None
now
0
res
)
.
ok
(
)
}
fn
process_timer
(
&
mut
self
now
:
Instant
)
{
if
let
State
:
:
Closing
{
error
timeout
}
|
State
:
:
Draining
{
error
timeout
}
=
&
self
.
state
{
if
*
timeout
<
=
now
{
let
st
=
State
:
:
Closed
(
error
.
clone
(
)
)
;
self
.
set_state
(
st
)
;
qinfo
!
(
"
Closing
timer
expired
"
)
;
return
;
}
}
if
let
State
:
:
Closed
(
_
)
=
self
.
state
{
qdebug
!
(
"
Timer
fired
while
closed
"
)
;
return
;
}
let
pto
=
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
;
if
self
.
idle_timeout
.
expired
(
now
pto
)
{
qinfo
!
(
[
self
]
"
idle
timeout
expired
"
)
;
self
.
set_state
(
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
IdleTimeout
)
)
)
;
return
;
}
self
.
cleanup_streams
(
)
;
let
res
=
self
.
crypto
.
states
.
check_key_update
(
now
)
;
self
.
absorb_error
(
now
res
)
;
let
lost
=
self
.
loss_recovery
.
timeout
(
now
)
;
self
.
handle_lost_packets
(
&
lost
)
;
qlog
:
:
packets_lost
(
&
mut
self
.
qlog
&
lost
)
;
if
self
.
release_resumption_token_timer
.
is_some
(
)
{
self
.
create_resumption_token
(
now
)
;
}
if
!
self
.
paths
.
process_timeout
(
now
pto
)
{
qinfo
!
(
[
self
]
"
last
available
path
failed
"
)
;
self
.
absorb_error
:
:
<
Error
>
(
now
Err
(
Error
:
:
NoAvailablePath
)
)
;
}
}
pub
fn
process_input
(
&
mut
self
d
:
Datagram
now
:
Instant
)
{
self
.
input
(
d
now
now
)
;
self
.
process_saved
(
now
)
;
self
.
cleanup_streams
(
)
;
}
fn
next_delay
(
&
mut
self
now
:
Instant
paced
:
bool
)
-
>
Duration
{
qtrace
!
(
[
self
]
"
Get
callback
delay
{
:
?
}
"
now
)
;
if
let
State
:
:
Closing
{
timeout
.
.
}
|
State
:
:
Draining
{
timeout
.
.
}
=
self
.
state
{
return
timeout
.
duration_since
(
now
)
;
}
let
mut
delays
=
SmallVec
:
:
<
[
_
;
6
]
>
:
:
new
(
)
;
if
let
Some
(
ack_time
)
=
self
.
acks
.
ack_time
(
now
)
{
qtrace
!
(
[
self
]
"
Delayed
ACK
timer
{
:
?
}
"
ack_time
)
;
delays
.
push
(
ack_time
)
;
}
let
pto
=
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
;
let
idle_time
=
self
.
idle_timeout
.
expiry
(
now
pto
)
;
qtrace
!
(
[
self
]
"
Idle
timer
{
:
?
}
"
idle_time
)
;
delays
.
push
(
idle_time
)
;
if
let
Some
(
lr_time
)
=
self
.
loss_recovery
.
next_timeout
(
)
{
qtrace
!
(
[
self
]
"
Loss
recovery
timer
{
:
?
}
"
lr_time
)
;
delays
.
push
(
lr_time
)
;
}
if
let
Some
(
key_update_time
)
=
self
.
crypto
.
states
.
update_time
(
)
{
qtrace
!
(
[
self
]
"
Key
update
timer
{
:
?
}
"
key_update_time
)
;
delays
.
push
(
key_update_time
)
;
}
if
paced
{
if
let
Some
(
pace_time
)
=
self
.
loss_recovery
.
next_paced
(
)
{
qtrace
!
(
[
self
]
"
Pacing
timer
{
:
?
}
"
pace_time
)
;
delays
.
push
(
pace_time
)
;
}
}
if
let
Some
(
path_time
)
=
self
.
paths
.
next_timeout
(
pto
)
{
qtrace
!
(
[
self
]
"
Path
probe
timer
{
:
?
}
"
path_time
)
;
delays
.
push
(
path_time
)
;
}
let
earliest
=
delays
.
into_iter
(
)
.
min
(
)
.
unwrap
(
)
;
qdebug
!
(
[
self
]
"
delay
duration
{
:
?
}
"
max
(
now
earliest
)
.
duration_since
(
now
)
)
;
debug_assert
!
(
earliest
>
now
)
;
max
(
now
earliest
)
.
duration_since
(
now
)
}
#
[
must_use
=
"
Output
of
the
process_output
function
must
be
handled
"
]
pub
fn
process_output
(
&
mut
self
now
:
Instant
)
-
>
Output
{
qtrace
!
(
[
self
]
"
process_output
{
:
?
}
{
:
?
}
"
self
.
state
now
)
;
if
self
.
state
=
=
State
:
:
Init
{
if
self
.
role
=
=
Role
:
:
Client
{
let
res
=
self
.
client_start
(
now
)
;
self
.
absorb_error
(
now
res
)
;
}
}
else
{
self
.
process_timer
(
now
)
;
}
match
self
.
output
(
now
)
{
SendOption
:
:
Yes
(
dgram
)
=
>
Output
:
:
Datagram
(
dgram
)
SendOption
:
:
No
(
paced
)
=
>
match
self
.
state
{
State
:
:
Init
|
State
:
:
Closed
(
_
)
=
>
Output
:
:
None
State
:
:
Closing
{
timeout
.
.
}
|
State
:
:
Draining
{
timeout
.
.
}
=
>
{
Output
:
:
Callback
(
timeout
.
duration_since
(
now
)
)
}
_
=
>
Output
:
:
Callback
(
self
.
next_delay
(
now
paced
)
)
}
}
}
#
[
must_use
=
"
Output
of
the
process
function
must
be
handled
"
]
pub
fn
process
(
&
mut
self
dgram
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Output
{
if
let
Some
(
d
)
=
dgram
{
self
.
input
(
d
now
now
)
;
self
.
process_saved
(
now
)
;
}
self
.
process_output
(
now
)
}
fn
handle_retry
(
&
mut
self
packet
:
&
PublicPacket
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
received
Retry
"
)
;
if
matches
!
(
self
.
address_validation
AddressValidationInfo
:
:
Retry
{
.
.
}
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Extra
Retry
"
)
;
return
Ok
(
(
)
)
;
}
if
packet
.
token
(
)
.
is_empty
(
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Retry
without
a
token
"
)
;
return
Ok
(
(
)
)
;
}
if
!
packet
.
is_valid_retry
(
&
self
.
original_destination_cid
.
as_ref
(
)
.
unwrap
(
)
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Retry
with
bad
integrity
tag
"
)
;
return
Ok
(
(
)
)
;
}
let
path
=
self
.
paths
.
primary
(
)
;
path
.
borrow_mut
(
)
.
set_remote_cid
(
packet
.
scid
(
)
)
;
let
retry_scid
=
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
;
qinfo
!
(
[
self
]
"
Valid
Retry
received
token
=
{
}
scid
=
{
}
"
hex
(
packet
.
token
(
)
)
retry_scid
)
;
let
lost_packets
=
self
.
loss_recovery
.
retry
(
)
;
self
.
handle_lost_packets
(
&
lost_packets
)
;
self
.
crypto
.
states
.
init
(
self
.
version
(
)
self
.
role
&
retry_scid
)
;
self
.
address_validation
=
AddressValidationInfo
:
:
Retry
{
token
:
packet
.
token
(
)
.
to_vec
(
)
retry_source_cid
:
retry_scid
}
;
Ok
(
(
)
)
}
fn
discard_keys
(
&
mut
self
space
:
PNSpace
now
:
Instant
)
{
if
self
.
crypto
.
discard
(
space
)
{
qinfo
!
(
[
self
]
"
Drop
packet
number
space
{
}
"
space
)
;
self
.
loss_recovery
.
discard
(
space
now
)
;
self
.
acks
.
drop_space
(
space
)
;
}
}
fn
is_stateless_reset
(
&
self
path
:
&
PathRef
d
:
&
Datagram
)
-
>
bool
{
if
d
.
len
(
)
<
16
|
|
!
self
.
state
.
connected
(
)
{
return
false
;
}
let
token
=
<
&
[
u8
;
16
]
>
:
:
try_from
(
&
d
[
d
.
len
(
)
-
16
.
.
]
)
.
unwrap
(
)
;
path
.
borrow
(
)
.
is_stateless_reset
(
token
)
}
fn
check_stateless_reset
<
'
a
'
b
>
(
&
'
a
mut
self
path
:
&
PathRef
d
:
&
'
b
Datagram
first
:
bool
now
:
Instant
)
-
>
Res
<
(
)
>
{
if
first
&
&
self
.
is_stateless_reset
(
path
d
)
{
qdebug
!
(
[
self
]
"
Stateless
reset
:
{
}
"
hex
(
&
d
[
d
.
len
(
)
-
16
.
.
]
)
)
;
self
.
state_signaling
.
reset
(
)
;
self
.
set_state
(
State
:
:
Draining
{
error
:
ConnectionError
:
:
Transport
(
Error
:
:
StatelessReset
)
timeout
:
self
.
get_closing_period_time
(
now
)
}
)
;
Err
(
Error
:
:
StatelessReset
)
}
else
{
Ok
(
(
)
)
}
}
fn
process_saved
(
&
mut
self
now
:
Instant
)
{
while
let
Some
(
cspace
)
=
self
.
saved_datagrams
.
available
(
)
{
qdebug
!
(
[
self
]
"
process
saved
for
space
{
:
?
}
"
cspace
)
;
debug_assert
!
(
self
.
crypto
.
states
.
rx_hp
(
cspace
)
.
is_some
(
)
)
;
for
saved
in
self
.
saved_datagrams
.
take_saved
(
)
{
qtrace
!
(
[
self
]
"
input
saved
{
:
?
}
:
{
:
?
}
"
saved
.
t
saved
.
d
)
;
self
.
input
(
saved
.
d
saved
.
t
now
)
;
}
}
}
fn
save_datagram
(
&
mut
self
cspace
:
CryptoSpace
d
:
Datagram
remaining
:
usize
now
:
Instant
)
{
let
d
=
if
remaining
<
d
.
len
(
)
{
Datagram
:
:
new
(
d
.
source
(
)
d
.
destination
(
)
&
d
[
d
.
len
(
)
-
remaining
.
.
]
)
}
else
{
d
}
;
self
.
saved_datagrams
.
save
(
cspace
d
now
)
;
self
.
stats
.
borrow_mut
(
)
.
saved_datagrams
+
=
1
;
}
fn
preprocess_packet
(
&
mut
self
packet
:
&
PublicPacket
dcid
:
Option
<
&
ConnectionId
>
now
:
Instant
)
-
>
Res
<
PreprocessResult
>
{
if
dcid
.
map_or
(
false
|
d
|
d
!
=
packet
.
dcid
(
)
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Coalesced
packet
has
different
DCID
"
)
;
return
Ok
(
PreprocessResult
:
:
Next
)
;
}
match
(
packet
.
packet_type
(
)
&
self
.
state
&
self
.
role
)
{
(
PacketType
:
:
Initial
State
:
:
Init
Role
:
:
Server
)
=
>
{
if
!
packet
.
is_valid_initial
(
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Invalid
Initial
"
)
;
return
Ok
(
PreprocessResult
:
:
Next
)
;
}
qinfo
!
(
[
self
]
"
Received
valid
Initial
packet
with
scid
{
:
?
}
dcid
{
:
?
}
"
packet
.
scid
(
)
packet
.
dcid
(
)
)
;
self
.
set_state
(
State
:
:
WaitInitial
)
;
self
.
loss_recovery
.
start_pacer
(
now
)
;
self
.
crypto
.
states
.
init
(
self
.
version
(
)
self
.
role
&
packet
.
dcid
(
)
)
;
if
!
self
.
retry_sent
(
)
{
self
.
tps
.
borrow_mut
(
)
.
local
.
set_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
packet
.
dcid
(
)
.
to_vec
(
)
)
}
}
(
PacketType
:
:
VersionNegotiation
State
:
:
WaitInitial
Role
:
:
Client
)
=
>
{
match
packet
.
supported_versions
(
)
{
Ok
(
versions
)
=
>
{
if
versions
.
is_empty
(
)
|
|
versions
.
contains
(
&
self
.
version
(
)
.
as_u32
(
)
)
|
|
packet
.
dcid
(
)
!
=
self
.
odcid
(
)
.
unwrap
(
)
|
|
matches
!
(
self
.
address_validation
AddressValidationInfo
:
:
Retry
{
.
.
}
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Invalid
VN
"
)
;
return
Ok
(
PreprocessResult
:
:
End
)
;
}
self
.
set_state
(
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
VersionNegotiation
)
)
)
;
return
Err
(
Error
:
:
VersionNegotiation
)
;
}
Err
(
_
)
=
>
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Invalid
VN
"
)
;
return
Ok
(
PreprocessResult
:
:
End
)
;
}
}
}
(
PacketType
:
:
Retry
State
:
:
WaitInitial
Role
:
:
Client
)
=
>
{
self
.
handle_retry
(
packet
)
?
;
return
Ok
(
PreprocessResult
:
:
Next
)
;
}
(
PacketType
:
:
Handshake
State
:
:
WaitInitial
Role
:
:
Client
)
|
(
PacketType
:
:
Short
State
:
:
WaitInitial
Role
:
:
Client
)
=
>
{
if
dcid
.
is_none
(
)
&
&
self
.
cid_manager
.
is_valid
(
packet
.
dcid
(
)
)
&
&
self
.
stats
.
borrow
(
)
.
saved_datagrams
<
=
EXTRA_INITIALS
{
self
.
crypto
.
resend_unacked
(
PNSpace
:
:
Initial
)
;
}
}
(
PacketType
:
:
VersionNegotiation
.
.
)
|
(
PacketType
:
:
Retry
.
.
)
|
(
PacketType
:
:
OtherVersion
.
.
)
=
>
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
format
!
(
"
{
:
?
}
"
packet
.
packet_type
(
)
)
)
;
return
Ok
(
PreprocessResult
:
:
Next
)
;
}
_
=
>
{
}
}
let
res
=
match
self
.
state
{
State
:
:
Init
=
>
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Received
while
in
Init
state
"
)
;
PreprocessResult
:
:
Next
}
State
:
:
WaitInitial
=
>
PreprocessResult
:
:
Continue
State
:
:
Handshaking
|
State
:
:
Connected
|
State
:
:
Confirmed
=
>
{
if
!
self
.
cid_manager
.
is_valid
(
packet
.
dcid
(
)
)
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
format
!
(
"
Invalid
DCID
{
:
?
}
"
packet
.
dcid
(
)
)
)
;
PreprocessResult
:
:
Next
}
else
{
if
self
.
role
=
=
Role
:
:
Server
&
&
packet
.
packet_type
(
)
=
=
PacketType
:
:
Handshake
{
self
.
discard_keys
(
PNSpace
:
:
Initial
now
)
;
}
PreprocessResult
:
:
Continue
}
}
State
:
:
Closing
{
.
.
}
=
>
{
self
.
state_signaling
.
send_close
(
)
;
PreprocessResult
:
:
Next
}
State
:
:
Draining
{
.
.
}
|
State
:
:
Closed
(
.
.
)
=
>
{
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
format
!
(
"
State
{
:
?
}
"
self
.
state
)
)
;
PreprocessResult
:
:
Next
}
}
;
Ok
(
res
)
}
fn
postprocess_packet
(
&
mut
self
path
:
&
PathRef
d
:
&
Datagram
packet
:
&
PublicPacket
migrate
:
bool
now
:
Instant
)
{
if
self
.
state
=
=
State
:
:
WaitInitial
{
self
.
start_handshake
(
path
&
packet
)
;
}
if
self
.
state
.
connected
(
)
{
self
.
handle_migration
(
path
d
migrate
now
)
;
}
else
if
self
.
role
!
=
Role
:
:
Client
&
&
(
packet
.
packet_type
(
)
=
=
PacketType
:
:
Handshake
|
|
(
packet
.
dcid
(
)
.
len
(
)
>
=
8
&
&
packet
.
dcid
(
)
=
=
&
self
.
local_initial_source_cid
)
)
{
path
.
borrow_mut
(
)
.
set_valid
(
now
)
;
}
}
fn
input
(
&
mut
self
d
:
Datagram
received
:
Instant
now
:
Instant
)
{
let
path
=
self
.
paths
.
find_path_with_rebinding
(
d
.
destination
(
)
d
.
source
(
)
)
;
path
.
borrow_mut
(
)
.
add_received
(
d
.
len
(
)
)
;
let
res
=
self
.
input_path
(
&
path
d
received
)
;
self
.
capture_error
(
Some
(
path
)
now
0
res
)
.
ok
(
)
;
}
fn
input_path
(
&
mut
self
path
:
&
PathRef
d
:
Datagram
now
:
Instant
)
-
>
Res
<
(
)
>
{
let
mut
slc
=
&
d
[
.
.
]
;
let
mut
dcid
=
None
;
qtrace
!
(
[
self
]
"
{
}
input
{
}
"
path
.
borrow
(
)
hex
(
&
*
*
d
)
)
;
while
!
slc
.
is_empty
(
)
{
self
.
stats
.
borrow_mut
(
)
.
packets_rx
+
=
1
;
let
(
packet
remainder
)
=
match
PublicPacket
:
:
decode
(
slc
self
.
cid_manager
.
decoder
(
)
.
as_ref
(
)
)
{
Ok
(
(
packet
remainder
)
)
=
>
(
packet
remainder
)
Err
(
e
)
=
>
{
qinfo
!
(
[
self
]
"
Garbage
packet
:
{
}
"
e
)
;
qtrace
!
(
[
self
]
"
Garbage
packet
contents
:
{
}
"
hex
(
slc
)
)
;
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Garbage
packet
"
)
;
break
;
}
}
;
match
self
.
preprocess_packet
(
&
packet
dcid
.
as_ref
(
)
now
)
?
{
PreprocessResult
:
:
Continue
=
>
(
)
PreprocessResult
:
:
Next
=
>
break
PreprocessResult
:
:
End
=
>
return
Ok
(
(
)
)
}
qtrace
!
(
[
self
]
"
Received
unverified
packet
{
:
?
}
"
packet
)
;
let
pto
=
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
;
match
packet
.
decrypt
(
&
mut
self
.
crypto
.
states
now
+
pto
)
{
Ok
(
payload
)
=
>
{
self
.
idle_timeout
.
on_packet_received
(
now
)
;
dump_packet
(
self
path
"
-
>
RX
"
payload
.
packet_type
(
)
payload
.
pn
(
)
&
payload
[
.
.
]
)
;
qlog
:
:
packet_received
(
&
mut
self
.
qlog
&
packet
&
payload
)
;
let
space
=
PNSpace
:
:
from
(
payload
.
packet_type
(
)
)
;
if
self
.
acks
.
get_mut
(
space
)
.
unwrap
(
)
.
is_duplicate
(
payload
.
pn
(
)
)
{
qdebug
!
(
[
self
]
"
Duplicate
packet
{
}
-
{
}
"
space
payload
.
pn
(
)
)
;
self
.
stats
.
borrow_mut
(
)
.
dups_rx
+
=
1
;
}
else
{
match
self
.
process_packet
(
&
path
&
payload
now
)
{
Ok
(
migrate
)
=
>
{
self
.
postprocess_packet
(
&
path
&
d
&
packet
migrate
now
)
}
Err
(
e
)
=
>
{
self
.
ensure_error_path
(
path
&
packet
now
)
;
return
Err
(
e
)
;
}
}
}
}
Err
(
e
)
=
>
{
match
e
{
Error
:
:
KeysPending
(
cspace
)
=
>
{
let
remaining
=
slc
.
len
(
)
;
self
.
save_datagram
(
cspace
d
remaining
now
)
;
return
Ok
(
(
)
)
;
}
Error
:
:
KeysExhausted
=
>
{
return
Err
(
e
)
;
}
_
=
>
(
)
}
self
.
check_stateless_reset
(
&
path
&
d
dcid
.
is_none
(
)
now
)
?
;
self
.
stats
.
borrow_mut
(
)
.
pkt_dropped
(
"
Decryption
failure
"
)
;
qlog
:
:
packet_dropped
(
&
mut
self
.
qlog
&
packet
)
;
}
}
slc
=
remainder
;
dcid
=
Some
(
ConnectionId
:
:
from
(
packet
.
dcid
(
)
)
)
;
}
self
.
check_stateless_reset
(
&
path
&
d
dcid
.
is_none
(
)
now
)
?
;
Ok
(
(
)
)
}
fn
process_packet
(
&
mut
self
path
:
&
PathRef
packet
:
&
DecryptedPacket
now
:
Instant
)
-
>
Res
<
bool
>
{
let
mut
ack_eliciting
=
false
;
let
mut
probing
=
true
;
let
mut
d
=
Decoder
:
:
from
(
&
packet
[
.
.
]
)
;
let
mut
consecutive_padding
=
0
;
while
d
.
remaining
(
)
>
0
{
let
mut
f
=
Frame
:
:
decode
(
&
mut
d
)
?
;
while
f
=
=
Frame
:
:
Padding
&
&
d
.
remaining
(
)
>
0
{
consecutive_padding
+
=
1
;
f
=
Frame
:
:
decode
(
&
mut
d
)
?
;
}
if
consecutive_padding
>
0
{
qdebug
!
(
[
self
]
"
PADDING
frame
repeated
{
}
times
"
consecutive_padding
)
;
consecutive_padding
=
0
;
}
ack_eliciting
|
=
f
.
ack_eliciting
(
)
;
probing
&
=
f
.
path_probing
(
)
;
let
t
=
f
.
get_type
(
)
;
if
let
Err
(
e
)
=
self
.
input_frame
(
&
path
packet
.
packet_type
(
)
f
now
)
{
self
.
capture_error
(
Some
(
Rc
:
:
clone
(
path
)
)
now
t
Err
(
e
)
)
?
;
}
}
let
largest_received
=
self
.
acks
.
get_mut
(
PNSpace
:
:
from
(
packet
.
packet_type
(
)
)
)
.
unwrap
(
)
.
set_received
(
now
packet
.
pn
(
)
ack_eliciting
)
;
Ok
(
largest_received
&
&
!
probing
)
}
fn
setup_handshake_path
(
&
mut
self
path
:
&
PathRef
)
{
self
.
paths
.
make_permanent
(
&
path
Some
(
self
.
local_initial_source_cid
.
clone
(
)
)
ConnectionIdEntry
:
:
initial_remote
(
self
.
remote_initial_source_cid
.
as_ref
(
)
.
or_else
(
|
|
self
.
original_destination_cid
.
as_ref
(
)
)
.
unwrap
(
)
.
clone
(
)
)
)
;
}
fn
ensure_permanent
(
&
mut
self
path
:
&
PathRef
)
-
>
Res
<
(
)
>
{
if
self
.
paths
.
is_temporary
(
&
path
)
{
if
let
Some
(
cid
)
=
self
.
connection_ids
.
next
(
)
{
self
.
paths
.
make_permanent
(
path
None
cid
)
;
Ok
(
(
)
)
}
else
if
self
.
paths
.
primary
(
)
.
borrow
(
)
.
remote_cid
(
)
.
is_empty
(
)
{
self
.
paths
.
make_permanent
(
path
None
ConnectionIdEntry
:
:
empty_remote
(
)
)
;
Ok
(
(
)
)
}
else
{
qtrace
!
(
[
self
]
"
Unable
to
make
path
permanent
:
{
}
"
path
.
borrow
(
)
)
;
Err
(
Error
:
:
InvalidMigration
)
}
}
else
{
Ok
(
(
)
)
}
}
fn
ensure_error_path
(
&
mut
self
path
:
&
PathRef
packet
:
&
PublicPacket
now
:
Instant
)
{
path
.
borrow_mut
(
)
.
set_valid
(
now
)
;
if
self
.
paths
.
is_temporary
(
&
path
)
{
if
packet
.
packet_type
(
)
=
=
PacketType
:
:
Initial
{
self
.
remote_initial_source_cid
=
Some
(
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
)
;
self
.
setup_handshake_path
(
&
path
)
;
}
else
{
let
_
=
self
.
ensure_permanent
(
&
path
)
;
}
}
}
fn
start_handshake
(
&
mut
self
path
:
&
PathRef
packet
:
&
PublicPacket
)
{
qtrace
!
(
[
self
]
"
starting
handshake
"
)
;
debug_assert_eq
!
(
packet
.
packet_type
(
)
PacketType
:
:
Initial
)
;
self
.
remote_initial_source_cid
=
Some
(
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
)
;
if
self
.
role
=
=
Role
:
:
Server
{
let
dcid
=
ConnectionId
:
:
from
(
packet
.
dcid
(
)
)
;
self
.
original_destination_cid
=
Some
(
dcid
.
clone
(
)
)
;
self
.
cid_manager
.
add_odcid
(
dcid
)
;
self
.
setup_handshake_path
(
path
)
;
self
.
zero_rtt_state
=
match
self
.
crypto
.
enable_0rtt
(
self
.
role
)
{
Ok
(
true
)
=
>
{
qdebug
!
(
[
self
]
"
Accepted
0
-
RTT
"
)
;
ZeroRttState
:
:
AcceptedServer
}
_
=
>
ZeroRttState
:
:
Rejected
}
;
}
else
{
qdebug
!
(
[
self
]
"
Changing
to
use
Server
CID
=
{
}
"
packet
.
scid
(
)
)
;
debug_assert
!
(
path
.
borrow
(
)
.
is_primary
(
)
)
;
path
.
borrow_mut
(
)
.
set_remote_cid
(
packet
.
scid
(
)
)
;
}
self
.
set_state
(
State
:
:
Handshaking
)
;
}
pub
fn
migrate
(
&
mut
self
local
:
Option
<
SocketAddr
>
remote
:
Option
<
SocketAddr
>
force
:
bool
now
:
Instant
)
-
>
Res
<
(
)
>
{
if
self
.
role
!
=
Role
:
:
Client
{
return
Err
(
Error
:
:
InvalidMigration
)
;
}
if
!
matches
!
(
self
.
state
(
)
State
:
:
Confirmed
)
{
return
Err
(
Error
:
:
InvalidMigration
)
;
}
if
local
.
is_none
(
)
&
&
remote
.
is_none
(
)
{
return
Err
(
Error
:
:
InvalidMigration
)
;
}
let
local
=
local
.
unwrap_or_else
(
|
|
self
.
paths
.
primary
(
)
.
borrow
(
)
.
local_address
(
)
)
;
let
remote
=
remote
.
unwrap_or_else
(
|
|
self
.
paths
.
primary
(
)
.
borrow
(
)
.
remote_address
(
)
)
;
if
mem
:
:
discriminant
(
&
local
.
ip
(
)
)
!
=
mem
:
:
discriminant
(
&
remote
.
ip
(
)
)
{
return
Err
(
Error
:
:
InvalidMigration
)
;
}
if
local
.
port
(
)
=
=
0
|
|
remote
.
ip
(
)
.
is_unspecified
(
)
|
|
remote
.
port
(
)
=
=
0
{
return
Err
(
Error
:
:
InvalidMigration
)
;
}
if
(
local
.
ip
(
)
.
is_loopback
(
)
^
remote
.
ip
(
)
.
is_loopback
(
)
)
&
&
!
local
.
ip
(
)
.
is_unspecified
(
)
{
return
Err
(
Error
:
:
InvalidMigration
)
;
}
let
path
=
self
.
paths
.
find_path
(
local
remote
)
;
self
.
ensure_permanent
(
&
path
)
?
;
qinfo
!
(
[
self
]
"
Migrate
to
{
}
probe
{
}
"
path
.
borrow
(
)
if
force
{
"
now
"
}
else
{
"
after
"
}
)
;
self
.
paths
.
migrate
(
&
path
force
now
)
;
Ok
(
(
)
)
}
fn
migrate_to_preferred_address
(
&
mut
self
now
:
Instant
)
-
>
Res
<
(
)
>
{
let
spa
=
if
matches
!
(
self
.
conn_params
.
get_preferred_address
(
)
PreferredAddressConfig
:
:
Disabled
)
{
None
}
else
{
self
.
tps
.
borrow_mut
(
)
.
remote
(
)
.
get_preferred_address
(
)
}
;
if
let
Some
(
(
addr
cid
)
)
=
spa
{
self
.
connection_ids
.
add_remote
(
cid
)
?
;
let
prev
=
self
.
paths
.
primary
(
)
.
borrow
(
)
.
remote_address
(
)
;
let
remote
=
match
prev
.
ip
(
)
{
IpAddr
:
:
V4
(
_
)
=
>
addr
.
ipv4
(
)
IpAddr
:
:
V6
(
_
)
=
>
addr
.
ipv6
(
)
}
;
if
let
Some
(
remote
)
=
remote
{
if
!
prev
.
ip
(
)
.
is_loopback
(
)
&
&
remote
.
ip
(
)
.
is_loopback
(
)
{
qwarn
!
(
[
self
]
"
Ignoring
a
move
to
a
loopback
address
:
{
}
"
remote
)
;
return
Ok
(
(
)
)
;
}
if
self
.
migrate
(
None
Some
(
remote
)
false
now
)
.
is_err
(
)
{
qwarn
!
(
[
self
]
"
Ignoring
bad
preferred
address
:
{
}
"
remote
)
;
}
}
else
{
qwarn
!
(
[
self
]
"
Unable
to
migrate
to
a
different
address
family
"
)
;
}
}
Ok
(
(
)
)
}
fn
handle_migration
(
&
mut
self
path
:
&
PathRef
d
:
&
Datagram
migrate
:
bool
now
:
Instant
)
{
if
!
migrate
{
return
;
}
if
self
.
role
=
=
Role
:
:
Client
{
return
;
}
if
self
.
ensure_permanent
(
path
)
.
is_ok
(
)
{
self
.
paths
.
handle_migration
(
path
d
.
source
(
)
now
)
;
}
else
{
qinfo
!
(
[
self
]
"
{
}
Peer
migrated
but
no
connection
ID
available
"
path
.
borrow
(
)
)
;
}
}
fn
output
(
&
mut
self
now
:
Instant
)
-
>
SendOption
{
qtrace
!
(
[
self
]
"
output
{
:
?
}
"
now
)
;
let
res
=
match
&
self
.
state
{
State
:
:
Init
|
State
:
:
WaitInitial
|
State
:
:
Handshaking
|
State
:
:
Connected
|
State
:
:
Confirmed
=
>
{
if
let
Some
(
path
)
=
self
.
paths
.
select_path
(
)
{
let
res
=
self
.
output_path
(
&
path
now
)
;
self
.
capture_error
(
Some
(
path
)
now
0
res
)
}
else
{
Ok
(
SendOption
:
:
default
(
)
)
}
}
State
:
:
Closing
{
.
.
}
|
State
:
:
Draining
{
.
.
}
|
State
:
:
Closed
(
_
)
=
>
{
if
let
Some
(
details
)
=
self
.
state_signaling
.
close_frame
(
)
{
let
path
=
Rc
:
:
clone
(
details
.
path
(
)
)
;
let
res
=
self
.
output_close
(
details
)
;
self
.
capture_error
(
Some
(
path
)
now
0
res
)
}
else
{
Ok
(
SendOption
:
:
default
(
)
)
}
}
}
;
res
.
unwrap_or_default
(
)
}
fn
build_packet_header
(
path
:
&
Path
cspace
:
CryptoSpace
encoder
:
Encoder
tx
:
&
CryptoDxState
address_validation
:
&
AddressValidationInfo
quic_version
:
QuicVersion
grease_quic_bit
:
bool
)
-
>
Res
<
(
PacketType
PacketBuilder
)
>
{
let
pt
=
PacketType
:
:
from
(
cspace
)
;
let
mut
builder
=
if
pt
=
=
PacketType
:
:
Short
{
qdebug
!
(
"
Building
Short
dcid
{
}
"
path
.
remote_cid
(
)
)
;
PacketBuilder
:
:
short
(
encoder
tx
.
key_phase
(
)
path
.
remote_cid
(
)
)
}
else
{
qdebug
!
(
"
Building
{
:
?
}
dcid
{
}
scid
{
}
"
pt
path
.
remote_cid
(
)
path
.
local_cid
(
)
)
;
PacketBuilder
:
:
long
(
encoder
pt
quic_version
path
.
remote_cid
(
)
path
.
local_cid
(
)
)
}
;
builder
.
scramble
(
grease_quic_bit
)
;
if
pt
=
=
PacketType
:
:
Initial
{
builder
.
initial_token
(
address_validation
.
token
(
)
)
?
;
}
Ok
(
(
pt
builder
)
)
}
fn
add_packet_number
(
builder
:
&
mut
PacketBuilder
tx
:
&
CryptoDxState
largest_acknowledged
:
Option
<
PacketNumber
>
)
-
>
Res
<
PacketNumber
>
{
let
pn
=
tx
.
next_pn
(
)
;
let
unacked_range
=
if
let
Some
(
la
)
=
largest_acknowledged
{
(
pn
-
la
)
<
<
1
}
else
{
pn
+
1
}
;
let
pn_len
=
mem
:
:
size_of
:
:
<
PacketNumber
>
(
)
-
usize
:
:
try_from
(
unacked_range
.
leading_zeros
(
)
/
8
)
.
unwrap
(
)
;
builder
.
pn
(
pn
pn_len
)
?
;
Ok
(
pn
)
}
fn
can_grease_quic_bit
(
&
self
)
-
>
bool
{
let
tph
=
self
.
tps
.
borrow
(
)
;
if
let
Some
(
r
)
=
&
tph
.
remote
{
r
.
get_empty
(
tparams
:
:
GREASE_QUIC_BIT
)
}
else
if
let
Some
(
r
)
=
&
tph
.
remote_0rtt
{
r
.
get_empty
(
tparams
:
:
GREASE_QUIC_BIT
)
}
else
{
false
}
}
fn
output_close
(
&
mut
self
close
:
ClosingFrame
)
-
>
Res
<
SendOption
>
{
let
mut
encoder
=
Encoder
:
:
with_capacity
(
256
)
;
let
grease_quic_bit
=
self
.
can_grease_quic_bit
(
)
;
let
version
=
self
.
version
(
)
;
for
space
in
PNSpace
:
:
iter
(
)
{
let
(
cspace
tx
)
=
if
let
Some
(
crypto
)
=
self
.
crypto
.
states
.
select_tx
(
*
space
)
{
crypto
}
else
{
continue
;
}
;
let
path
=
close
.
path
(
)
.
borrow
(
)
;
let
(
_
mut
builder
)
=
Self
:
:
build_packet_header
(
&
path
cspace
encoder
tx
&
AddressValidationInfo
:
:
None
version
grease_quic_bit
)
?
;
builder
.
set_limit
(
min
(
path
.
amplification_limit
(
)
path
.
mtu
(
)
)
-
tx
.
expansion
(
)
)
;
if
builder
.
limit
(
)
>
2048
{
return
Err
(
Error
:
:
InternalError
(
9
)
)
;
}
if
builder
.
len
(
)
>
builder
.
limit
(
)
{
return
Err
(
Error
:
:
InternalError
(
25
)
)
;
}
let
_
=
Self
:
:
add_packet_number
(
&
mut
builder
tx
self
.
loss_recovery
.
largest_acknowledged_pn
(
*
space
)
)
?
;
let
sanitized
=
if
*
space
=
=
PNSpace
:
:
ApplicationData
{
None
}
else
{
close
.
sanitize
(
)
}
;
sanitized
.
as_ref
(
)
.
unwrap_or
(
&
close
)
.
write_frame
(
&
mut
builder
)
;
if
builder
.
len
(
)
>
builder
.
limit
(
)
{
return
Err
(
Error
:
:
InternalError
(
10
)
)
;
}
encoder
=
builder
.
build
(
tx
)
?
;
}
Ok
(
SendOption
:
:
Yes
(
close
.
path
(
)
.
borrow
(
)
.
datagram
(
encoder
)
)
)
}
fn
write_frames
(
&
mut
self
path
:
&
PathRef
space
:
PNSpace
profile
:
&
SendProfile
builder
:
&
mut
PacketBuilder
mut
pad
:
bool
now
:
Instant
)
-
>
Res
<
(
Vec
<
RecoveryToken
>
bool
bool
)
>
{
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
stats
=
&
mut
self
.
stats
.
borrow_mut
(
)
.
frame_tx
;
let
primary
=
path
.
borrow
(
)
.
is_primary
(
)
;
let
mut
ack_eliciting
=
false
;
let
ack_token
=
if
primary
{
self
.
acks
.
write_frame
(
space
now
builder
stats
)
?
}
else
{
None
}
;
let
full_mtu
=
profile
.
limit
(
)
=
=
path
.
borrow
(
)
.
mtu
(
)
;
if
space
=
=
PNSpace
:
:
ApplicationData
&
&
self
.
state
.
connected
(
)
{
if
path
.
borrow_mut
(
)
.
write_frames
(
builder
stats
full_mtu
now
)
?
{
pad
=
true
;
ack_eliciting
=
true
;
}
}
if
profile
.
ack_only
(
space
)
{
if
let
Some
(
t
)
=
ack_token
{
tokens
.
push
(
t
)
;
}
return
Ok
(
(
tokens
false
false
)
)
;
}
if
primary
{
if
space
=
=
PNSpace
:
:
ApplicationData
&
&
self
.
role
=
=
Role
:
:
Server
{
if
let
Some
(
t
)
=
self
.
state_signaling
.
write_done
(
builder
)
?
{
tokens
.
push
(
t
)
;
stats
.
handshake_done
+
=
1
;
}
}
if
let
Some
(
t
)
=
self
.
crypto
.
streams
.
write_frame
(
space
builder
)
?
{
tokens
.
push
(
t
)
;
stats
.
crypto
+
=
1
;
}
if
space
=
=
PNSpace
:
:
ApplicationData
{
self
.
flow_mgr
.
borrow_mut
(
)
.
write_frames
(
builder
&
mut
tokens
stats
)
?
;
self
.
send_streams
.
write_frames
(
builder
&
mut
tokens
stats
)
?
;
self
.
new_token
.
write_frames
(
builder
&
mut
tokens
stats
)
?
;
self
.
cid_manager
.
write_frames
(
builder
&
mut
tokens
stats
)
?
;
self
.
paths
.
write_frames
(
builder
&
mut
tokens
stats
)
?
;
}
}
ack_eliciting
|
=
!
tokens
.
is_empty
(
)
;
if
!
ack_eliciting
&
&
profile
.
should_probe
(
space
)
{
debug_assert_ne
!
(
builder
.
remaining
(
)
0
)
;
builder
.
encode_varint
(
crate
:
:
frame
:
:
FRAME_TYPE_PING
)
;
if
builder
.
len
(
)
>
builder
.
limit
(
)
{
return
Err
(
Error
:
:
InternalError
(
11
)
)
;
}
stats
.
ping
+
=
1
;
stats
.
all
+
=
1
;
ack_eliciting
=
true
;
}
debug_assert
!
(
primary
|
|
ack_eliciting
)
;
pad
&
=
ack_eliciting
&
&
space
=
=
PNSpace
:
:
ApplicationData
&
&
full_mtu
;
if
pad
{
builder
.
pad
(
)
?
;
stats
.
padding
+
=
1
;
stats
.
all
+
=
1
;
}
if
let
Some
(
t
)
=
ack_token
{
tokens
.
push
(
t
)
;
}
stats
.
all
+
=
tokens
.
len
(
)
;
Ok
(
(
tokens
ack_eliciting
pad
)
)
}
fn
output_path
(
&
mut
self
path
:
&
PathRef
now
:
Instant
)
-
>
Res
<
SendOption
>
{
let
mut
initial_sent
=
None
;
let
mut
needs_padding
=
false
;
let
grease_quic_bit
=
self
.
can_grease_quic_bit
(
)
;
let
version
=
self
.
version
(
)
;
let
mtu
=
path
.
borrow
(
)
.
mtu
(
)
;
let
amplification_limit
=
path
.
borrow
(
)
.
amplification_limit
(
)
;
let
profile
=
self
.
loss_recovery
.
send_profile
(
now
mtu
amplification_limit
)
;
qdebug
!
(
[
self
]
"
output_path
send_profile
{
:
?
}
"
profile
)
;
let
mut
encoder
=
Encoder
:
:
with_capacity
(
profile
.
limit
(
)
)
;
for
space
in
PNSpace
:
:
iter
(
)
{
let
(
cspace
tx
)
=
if
let
Some
(
crypto
)
=
self
.
crypto
.
states
.
select_tx
(
*
space
)
{
crypto
}
else
{
continue
;
}
;
let
header_start
=
encoder
.
len
(
)
;
let
(
pt
mut
builder
)
=
Self
:
:
build_packet_header
(
&
path
.
borrow
(
)
cspace
encoder
tx
&
self
.
address_validation
version
grease_quic_bit
)
?
;
let
pn
=
Self
:
:
add_packet_number
(
&
mut
builder
tx
self
.
loss_recovery
.
largest_acknowledged_pn
(
*
space
)
)
?
;
let
payload_start
=
builder
.
len
(
)
;
let
aead_expansion
=
tx
.
expansion
(
)
;
if
builder
.
len
(
)
+
aead_expansion
>
profile
.
limit
(
)
{
encoder
=
builder
.
abort
(
)
;
continue
;
}
let
limit
=
profile
.
limit
(
)
-
aead_expansion
;
builder
.
set_limit
(
limit
)
;
if
builder
.
limit
(
)
>
2048
{
return
Err
(
Error
:
:
InternalError
(
12
)
)
;
}
if
builder
.
len
(
)
>
builder
.
limit
(
)
{
return
Err
(
Error
:
:
InternalError
(
13
)
)
;
}
let
(
tokens
ack_eliciting
padded
)
=
self
.
write_frames
(
path
*
space
&
profile
&
mut
builder
needs_padding
now
)
?
;
if
builder
.
packet_empty
(
)
{
encoder
=
builder
.
abort
(
)
;
continue
;
}
dump_packet
(
self
path
"
TX
-
>
"
pt
pn
&
builder
[
payload_start
.
.
]
)
;
qlog
:
:
packet_sent
(
&
mut
self
.
qlog
pt
pn
builder
.
len
(
)
-
header_start
+
aead_expansion
&
builder
[
payload_start
.
.
]
)
;
self
.
stats
.
borrow_mut
(
)
.
packets_tx
+
=
1
;
encoder
=
builder
.
build
(
self
.
crypto
.
states
.
tx
(
cspace
)
.
unwrap
(
)
)
?
;
debug_assert
!
(
encoder
.
len
(
)
<
=
mtu
)
;
self
.
crypto
.
states
.
auto_update
(
)
?
;
if
ack_eliciting
{
self
.
idle_timeout
.
on_packet_sent
(
now
)
;
}
let
sent
=
SentPacket
:
:
new
(
pt
pn
now
ack_eliciting
tokens
encoder
.
len
(
)
-
header_start
)
;
if
padded
{
needs_padding
=
false
;
self
.
loss_recovery
.
on_packet_sent
(
sent
)
;
}
else
if
pt
=
=
PacketType
:
:
Initial
&
&
(
self
.
role
=
=
Role
:
:
Client
|
|
ack_eliciting
)
{
initial_sent
=
Some
(
sent
)
;
needs_padding
=
true
;
}
else
{
if
pt
=
=
PacketType
:
:
Handshake
&
&
self
.
role
=
=
Role
:
:
Client
{
needs_padding
=
false
;
}
self
.
loss_recovery
.
on_packet_sent
(
sent
)
;
}
if
*
space
=
=
PNSpace
:
:
Handshake
{
if
self
.
role
=
=
Role
:
:
Client
{
self
.
discard_keys
(
PNSpace
:
:
Initial
now
)
;
}
else
if
self
.
state
=
=
State
:
:
Confirmed
{
self
.
discard_keys
(
PNSpace
:
:
Handshake
now
)
;
}
}
}
if
encoder
.
is_empty
(
)
{
Ok
(
SendOption
:
:
No
(
profile
.
paced
(
)
)
)
}
else
{
let
mut
packets
:
Vec
<
u8
>
=
encoder
.
into
(
)
;
if
let
Some
(
mut
initial
)
=
initial_sent
.
take
(
)
{
if
needs_padding
{
qdebug
!
(
[
self
]
"
pad
Initial
to
path
MTU
{
}
"
mtu
)
;
initial
.
size
+
=
mtu
-
packets
.
len
(
)
;
packets
.
resize
(
mtu
0
)
;
}
self
.
loss_recovery
.
on_packet_sent
(
initial
)
;
}
path
.
borrow_mut
(
)
.
add_sent
(
packets
.
len
(
)
)
;
Ok
(
SendOption
:
:
Yes
(
path
.
borrow
(
)
.
datagram
(
packets
)
)
)
}
}
pub
fn
initiate_key_update
(
&
mut
self
)
-
>
Res
<
(
)
>
{
if
self
.
state
=
=
State
:
:
Confirmed
{
let
la
=
self
.
loss_recovery
.
largest_acknowledged_pn
(
PNSpace
:
:
ApplicationData
)
;
qinfo
!
(
[
self
]
"
Initiating
key
update
"
)
;
self
.
crypto
.
states
.
initiate_key_update
(
la
)
}
else
{
Err
(
Error
:
:
KeyUpdateBlocked
)
}
}
#
[
cfg
(
test
)
]
pub
fn
get_epochs
(
&
self
)
-
>
(
Option
<
usize
>
Option
<
usize
>
)
{
self
.
crypto
.
states
.
get_epochs
(
)
}
fn
client_start
(
&
mut
self
now
:
Instant
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
client_start
"
)
;
debug_assert_eq
!
(
self
.
role
Role
:
:
Client
)
;
qlog
:
:
client_connection_started
(
&
mut
self
.
qlog
&
self
.
paths
.
primary
(
)
)
;
self
.
loss_recovery
.
start_pacer
(
now
)
;
self
.
handshake
(
now
PNSpace
:
:
Initial
None
)
?
;
self
.
set_state
(
State
:
:
WaitInitial
)
;
self
.
paths
.
primary
(
)
.
borrow_mut
(
)
.
set_valid
(
now
)
;
self
.
zero_rtt_state
=
if
self
.
crypto
.
enable_0rtt
(
self
.
role
)
?
{
qdebug
!
(
[
self
]
"
Enabled
0
-
RTT
"
)
;
ZeroRttState
:
:
Sending
}
else
{
ZeroRttState
:
:
Init
}
;
Ok
(
(
)
)
}
fn
get_closing_period_time
(
&
self
now
:
Instant
)
-
>
Instant
{
now
+
(
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
*
3
)
}
pub
fn
close
(
&
mut
self
now
:
Instant
app_error
:
AppError
msg
:
impl
AsRef
<
str
>
)
{
let
error
=
ConnectionError
:
:
Application
(
app_error
)
;
let
timeout
=
self
.
get_closing_period_time
(
now
)
;
if
let
Some
(
path
)
=
self
.
paths
.
primary_fallible
(
)
{
self
.
state_signaling
.
close
(
path
error
.
clone
(
)
0
msg
)
;
self
.
set_state
(
State
:
:
Closing
{
error
timeout
}
)
;
}
else
{
self
.
set_state
(
State
:
:
Closed
(
error
)
)
;
}
}
fn
set_initial_limits
(
&
mut
self
)
{
let
tps
=
self
.
tps
.
borrow
(
)
;
let
remote
=
tps
.
remote
(
)
;
self
.
indexes
.
remote_max_stream_bidi
=
StreamIndex
:
:
new
(
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_BIDI
)
)
;
self
.
indexes
.
remote_max_stream_uni
=
StreamIndex
:
:
new
(
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAMS_UNI
)
)
;
self
.
flow_mgr
.
borrow_mut
(
)
.
conn_increase_max_credit
(
remote
.
get_integer
(
tparams
:
:
INITIAL_MAX_DATA
)
)
;
let
peer_timeout
=
remote
.
get_integer
(
tparams
:
:
IDLE_TIMEOUT
)
;
if
peer_timeout
>
0
{
self
.
idle_timeout
.
set_peer_timeout
(
Duration
:
:
from_millis
(
peer_timeout
)
)
;
}
}
fn
process_tps
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
validate_cids
(
)
?
;
{
let
tps
=
self
.
tps
.
borrow
(
)
;
let
remote
=
tps
.
remote
.
as_ref
(
)
.
unwrap
(
)
;
if
remote
.
get_preferred_address
(
)
.
is_some
(
)
&
&
(
self
.
role
=
=
Role
:
:
Server
|
|
self
.
remote_initial_source_cid
.
as_ref
(
)
.
unwrap
(
)
.
is_empty
(
)
)
{
return
Err
(
Error
:
:
TransportParameterError
)
;
}
let
reset_token
=
if
let
Some
(
token
)
=
remote
.
get_bytes
(
tparams
:
:
STATELESS_RESET_TOKEN
)
{
<
[
u8
;
16
]
>
:
:
try_from
(
token
)
.
unwrap
(
)
}
else
{
<
[
u8
;
16
]
>
:
:
try_from
(
&
random
(
16
)
[
.
.
]
)
.
unwrap
(
)
}
;
self
.
paths
.
primary
(
)
.
borrow_mut
(
)
.
set_reset_token
(
reset_token
)
;
let
mad
=
Duration
:
:
from_millis
(
remote
.
get_integer
(
tparams
:
:
MAX_ACK_DELAY
)
)
;
self
.
loss_recovery
.
set_peer_max_ack_delay
(
mad
)
;
let
max_active_cids
=
remote
.
get_integer
(
tparams
:
:
ACTIVE_CONNECTION_ID_LIMIT
)
;
self
.
cid_manager
.
set_limit
(
max_active_cids
)
;
}
self
.
set_initial_limits
(
)
;
qlog
:
:
connection_tparams_set
(
&
mut
self
.
qlog
&
*
self
.
tps
.
borrow
(
)
)
;
Ok
(
(
)
)
}
fn
validate_cids
(
&
mut
self
)
-
>
Res
<
(
)
>
{
match
self
.
version
(
)
{
QuicVersion
:
:
Draft27
=
>
self
.
validate_cids_draft_27
(
)
_
=
>
self
.
validate_cids_draft_28_plus
(
)
}
}
fn
validate_cids_draft_27
(
&
mut
self
)
-
>
Res
<
(
)
>
{
if
let
AddressValidationInfo
:
:
Retry
{
token
.
.
}
=
&
self
.
address_validation
{
debug_assert
!
(
!
token
.
is_empty
(
)
)
;
let
tph
=
self
.
tps
.
borrow
(
)
;
let
tp
=
tph
.
remote
.
as_ref
(
)
.
unwrap
(
)
.
get_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
)
;
if
self
.
original_destination_cid
.
as_ref
(
)
.
map
(
ConnectionId
:
:
as_cid_ref
)
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
return
Err
(
Error
:
:
InvalidRetry
)
;
}
}
Ok
(
(
)
)
}
fn
validate_cids_draft_28_plus
(
&
mut
self
)
-
>
Res
<
(
)
>
{
let
tph
=
self
.
tps
.
borrow
(
)
;
let
remote_tps
=
tph
.
remote
.
as_ref
(
)
.
unwrap
(
)
;
let
tp
=
remote_tps
.
get_bytes
(
tparams
:
:
INITIAL_SOURCE_CONNECTION_ID
)
;
if
self
.
remote_initial_source_cid
.
as_ref
(
)
.
map
(
ConnectionId
:
:
as_cid_ref
)
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
qwarn
!
(
[
self
]
"
ISCID
test
failed
:
self
cid
{
:
?
}
!
=
tp
cid
{
:
?
}
"
self
.
remote_initial_source_cid
tp
.
map
(
hex
)
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
if
self
.
role
=
=
Role
:
:
Client
{
let
tp
=
remote_tps
.
get_bytes
(
tparams
:
:
ORIGINAL_DESTINATION_CONNECTION_ID
)
;
if
self
.
original_destination_cid
.
as_ref
(
)
.
map
(
ConnectionId
:
:
as_cid_ref
)
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
qwarn
!
(
[
self
]
"
ODCID
test
failed
:
self
cid
{
:
?
}
!
=
tp
cid
{
:
?
}
"
self
.
original_destination_cid
tp
.
map
(
hex
)
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
let
tp
=
remote_tps
.
get_bytes
(
tparams
:
:
RETRY_SOURCE_CONNECTION_ID
)
;
let
expected
=
if
let
AddressValidationInfo
:
:
Retry
{
retry_source_cid
.
.
}
=
&
self
.
address_validation
{
Some
(
retry_source_cid
.
as_cid_ref
(
)
)
}
else
{
None
}
;
if
expected
!
=
tp
.
map
(
ConnectionIdRef
:
:
from
)
{
qwarn
!
(
[
self
]
"
RSCID
test
failed
.
self
cid
{
:
?
}
!
=
tp
cid
{
:
?
}
"
expected
tp
.
map
(
hex
)
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
}
Ok
(
(
)
)
}
fn
handshake
(
&
mut
self
now
:
Instant
space
:
PNSpace
data
:
Option
<
&
[
u8
]
>
)
-
>
Res
<
(
)
>
{
qtrace
!
(
[
self
]
"
Handshake
space
=
{
}
data
=
{
:
0x
?
}
"
space
data
)
;
let
try_update
=
data
.
is_some
(
)
;
match
self
.
crypto
.
handshake
(
now
space
data
)
?
{
HandshakeState
:
:
Authenticated
(
_
)
|
HandshakeState
:
:
InProgress
=
>
(
)
HandshakeState
:
:
AuthenticationPending
=
>
self
.
events
.
authentication_needed
(
)
HandshakeState
:
:
Complete
(
_
)
=
>
{
if
!
self
.
state
.
connected
(
)
{
self
.
set_connected
(
now
)
?
;
}
}
_
=
>
{
unreachable
!
(
"
Crypto
state
should
not
be
new
or
failed
after
successful
handshake
"
)
}
}
if
try_update
{
if
self
.
tps
.
borrow
(
)
.
remote
.
is_some
(
)
{
self
.
set_initial_limits
(
)
;
}
if
self
.
crypto
.
install_keys
(
self
.
role
)
?
{
self
.
saved_datagrams
.
make_available
(
CryptoSpace
:
:
Handshake
)
;
}
}
Ok
(
(
)
)
}
fn
handle_max_data
(
&
mut
self
maximum_data
:
u64
)
{
let
conn_was_blocked
=
self
.
flow_mgr
.
borrow
(
)
.
conn_credit_avail
(
)
=
=
0
;
let
conn_credit_increased
=
self
.
flow_mgr
.
borrow_mut
(
)
.
conn_increase_max_credit
(
maximum_data
)
;
if
conn_was_blocked
&
&
conn_credit_increased
{
for
(
id
ss
)
in
&
mut
self
.
send_streams
{
if
ss
.
avail
(
)
>
0
{
self
.
events
.
send_stream_writable
(
*
id
)
}
}
}
}
fn
input_frame
(
&
mut
self
path
:
&
PathRef
ptype
:
PacketType
frame
:
Frame
now
:
Instant
)
-
>
Res
<
(
)
>
{
if
!
frame
.
is_allowed
(
ptype
)
{
qinfo
!
(
"
frame
not
allowed
:
{
:
?
}
{
:
?
}
"
frame
ptype
)
;
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
all
+
=
1
;
let
space
=
PNSpace
:
:
from
(
ptype
)
;
match
frame
{
Frame
:
:
Padding
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
padding
+
=
1
;
}
Frame
:
:
Ping
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
ping
+
=
1
;
self
.
crypto
.
resend_unacked
(
space
)
;
}
Frame
:
:
Ack
{
largest_acknowledged
ack_delay
first_ack_range
ack_ranges
}
=
>
{
self
.
handle_ack
(
space
largest_acknowledged
ack_delay
first_ack_range
ack_ranges
now
)
?
;
}
Frame
:
:
ResetStream
{
stream_id
application_error_code
.
.
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
reset_stream
+
=
1
;
if
let
(
_
Some
(
rs
)
)
=
self
.
obtain_stream
(
stream_id
)
?
{
rs
.
reset
(
application_error_code
)
;
}
}
Frame
:
:
StopSending
{
stream_id
application_error_code
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
stop_sending
+
=
1
;
self
.
events
.
send_stream_stop_sending
(
stream_id
application_error_code
)
;
if
let
(
Some
(
ss
)
_
)
=
self
.
obtain_stream
(
stream_id
)
?
{
ss
.
reset
(
application_error_code
)
;
}
}
Frame
:
:
Crypto
{
offset
data
}
=
>
{
qtrace
!
(
[
self
]
"
Crypto
frame
on
space
=
{
}
offset
=
{
}
data
=
{
:
0x
?
}
"
space
offset
&
data
)
;
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
crypto
+
=
1
;
self
.
crypto
.
streams
.
inbound_frame
(
space
offset
data
)
;
if
self
.
crypto
.
streams
.
data_ready
(
space
)
{
let
mut
buf
=
Vec
:
:
new
(
)
;
let
read
=
self
.
crypto
.
streams
.
read_to_end
(
space
&
mut
buf
)
;
qdebug
!
(
"
Read
{
}
bytes
"
read
)
;
self
.
handshake
(
now
space
Some
(
&
buf
)
)
?
;
self
.
create_resumption_token
(
now
)
;
}
else
{
self
.
crypto
.
resend_unacked
(
space
)
;
}
}
Frame
:
:
NewToken
{
token
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
new_token
+
=
1
;
self
.
new_token
.
save_token
(
token
.
to_vec
(
)
)
;
self
.
create_resumption_token
(
now
)
;
}
Frame
:
:
Stream
{
fin
stream_id
offset
data
.
.
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
stream
+
=
1
;
if
let
(
_
Some
(
rs
)
)
=
self
.
obtain_stream
(
stream_id
)
?
{
rs
.
inbound_stream_frame
(
fin
offset
data
)
?
;
}
}
Frame
:
:
MaxData
{
maximum_data
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
max_data
+
=
1
;
self
.
handle_max_data
(
maximum_data
)
;
}
Frame
:
:
MaxStreamData
{
stream_id
maximum_stream_data
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
max_stream_data
+
=
1
;
if
let
(
Some
(
ss
)
_
)
=
self
.
obtain_stream
(
stream_id
)
?
{
ss
.
set_max_stream_data
(
maximum_stream_data
)
;
}
}
Frame
:
:
MaxStreams
{
stream_type
maximum_streams
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
max_streams
+
=
1
;
let
remote_max
=
match
stream_type
{
StreamType
:
:
BiDi
=
>
&
mut
self
.
indexes
.
remote_max_stream_bidi
StreamType
:
:
UniDi
=
>
&
mut
self
.
indexes
.
remote_max_stream_uni
}
;
if
maximum_streams
>
*
remote_max
{
*
remote_max
=
maximum_streams
;
self
.
events
.
send_stream_creatable
(
stream_type
)
;
}
}
Frame
:
:
DataBlocked
{
data_limit
}
=
>
{
qwarn
!
(
[
self
]
"
Received
DataBlocked
with
data
limit
{
}
"
data_limit
)
;
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
data_blocked
+
=
1
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_data
(
LOCAL_MAX_DATA
)
;
}
Frame
:
:
StreamDataBlocked
{
stream_id
stream_data_limit
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
stream_data_blocked
+
=
1
;
if
stream_id
.
is_send_only
(
self
.
role
(
)
)
{
return
Err
(
Error
:
:
StreamStateError
)
;
}
if
let
(
_
Some
(
rs
)
)
=
self
.
obtain_stream
(
stream_id
)
?
{
if
let
Some
(
msd
)
=
rs
.
max_stream_data
(
)
{
qinfo
!
(
[
self
]
"
Got
StreamDataBlocked
(
id
{
}
MSD
{
}
)
;
curr
MSD
{
}
"
stream_id
.
as_u64
(
)
stream_data_limit
msd
)
;
if
stream_data_limit
!
=
msd
{
self
.
flow_mgr
.
borrow_mut
(
)
.
max_stream_data
(
stream_id
msd
)
}
}
}
}
Frame
:
:
StreamsBlocked
{
stream_type
.
.
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
streams_blocked
+
=
1
;
let
local_max
=
match
stream_type
{
StreamType
:
:
BiDi
=
>
&
mut
self
.
indexes
.
local_max_stream_bidi
StreamType
:
:
UniDi
=
>
&
mut
self
.
indexes
.
local_max_stream_uni
}
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_streams
(
*
local_max
stream_type
)
}
Frame
:
:
NewConnectionId
{
sequence_number
connection_id
stateless_reset_token
.
.
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
new_connection_id
+
=
1
;
self
.
connection_ids
.
add_remote
(
ConnectionIdEntry
:
:
new
(
sequence_number
ConnectionId
:
:
from
(
connection_id
)
stateless_reset_token
.
to_owned
(
)
)
)
?
;
}
Frame
:
:
RetireConnectionId
{
sequence_number
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
retire_connection_id
+
=
1
;
self
.
cid_manager
.
retire
(
sequence_number
)
;
}
Frame
:
:
PathChallenge
{
data
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
path_challenge
+
=
1
;
self
.
ensure_permanent
(
path
)
?
;
path
.
borrow_mut
(
)
.
challenged
(
data
)
;
}
Frame
:
:
PathResponse
{
data
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
path_response
+
=
1
;
self
.
paths
.
path_response
(
data
now
)
;
}
Frame
:
:
ConnectionClose
{
error_code
frame_type
reason_phrase
}
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
connection_close
+
=
1
;
let
reason_phrase
=
String
:
:
from_utf8_lossy
(
&
reason_phrase
)
;
qinfo
!
(
[
self
]
"
ConnectionClose
received
.
Error
code
:
{
:
?
}
frame
type
{
:
x
}
reason
{
}
"
error_code
frame_type
reason_phrase
)
;
let
(
detail
frame_type
)
=
if
let
CloseError
:
:
Application
(
_
)
=
error_code
{
(
Error
:
:
PeerApplicationError
(
error_code
.
code
(
)
)
FRAME_TYPE_CONNECTION_CLOSE_APPLICATION
)
}
else
{
(
Error
:
:
PeerError
(
error_code
.
code
(
)
)
FRAME_TYPE_CONNECTION_CLOSE_TRANSPORT
)
}
;
let
error
=
ConnectionError
:
:
Transport
(
detail
)
;
self
.
state_signaling
.
drain
(
Rc
:
:
clone
(
path
)
error
.
clone
(
)
frame_type
"
"
)
;
self
.
set_state
(
State
:
:
Draining
{
error
timeout
:
self
.
get_closing_period_time
(
now
)
}
)
;
}
Frame
:
:
HandshakeDone
=
>
{
self
.
stats
.
borrow_mut
(
)
.
frame_rx
.
handshake_done
+
=
1
;
if
self
.
role
=
=
Role
:
:
Server
|
|
!
self
.
state
.
connected
(
)
{
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
self
.
set_state
(
State
:
:
Confirmed
)
;
self
.
discard_keys
(
PNSpace
:
:
Handshake
now
)
;
self
.
migrate_to_preferred_address
(
now
)
?
;
}
}
;
Ok
(
(
)
)
}
fn
handle_lost_packets
(
&
mut
self
lost_packets
:
&
[
SentPacket
]
)
{
for
lost
in
lost_packets
{
for
token
in
&
lost
.
tokens
{
qdebug
!
(
[
self
]
"
Lost
:
{
:
?
}
"
token
)
;
match
token
{
RecoveryToken
:
:
Ack
(
_
)
=
>
{
}
RecoveryToken
:
:
Stream
(
st
)
=
>
self
.
send_streams
.
lost
(
&
st
)
RecoveryToken
:
:
Crypto
(
ct
)
=
>
self
.
crypto
.
lost
(
&
ct
)
RecoveryToken
:
:
Flow
(
ft
)
=
>
self
.
flow_mgr
.
borrow_mut
(
)
.
lost
(
&
ft
&
mut
self
.
send_streams
&
mut
self
.
recv_streams
&
mut
self
.
indexes
)
RecoveryToken
:
:
HandshakeDone
=
>
self
.
state_signaling
.
handshake_done
(
)
RecoveryToken
:
:
NewToken
(
seqno
)
=
>
self
.
new_token
.
lost
(
*
seqno
)
RecoveryToken
:
:
NewConnectionId
(
ncid
)
=
>
self
.
cid_manager
.
lost
(
ncid
)
RecoveryToken
:
:
RetireConnectionId
(
seqno
)
=
>
self
.
paths
.
lost_retire_cid
(
*
seqno
)
}
}
}
}
fn
decode_ack_delay
(
&
self
v
:
u64
)
-
>
Duration
{
if
let
Some
(
r
)
=
self
.
tps
.
borrow
(
)
.
remote
.
as_ref
(
)
{
let
exponent
=
u32
:
:
try_from
(
r
.
get_integer
(
tparams
:
:
ACK_DELAY_EXPONENT
)
)
.
unwrap
(
)
;
Duration
:
:
from_micros
(
v
.
checked_shl
(
exponent
)
.
unwrap_or
(
u64
:
:
MAX
)
)
}
else
{
Duration
:
:
new
(
0
0
)
}
}
fn
handle_ack
(
&
mut
self
space
:
PNSpace
largest_acknowledged
:
u64
ack_delay
:
u64
first_ack_range
:
u64
ack_ranges
:
Vec
<
AckRange
>
now
:
Instant
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
Rx
ACK
space
=
{
}
largest_acked
=
{
}
first_ack_range
=
{
}
ranges
=
{
:
?
}
"
space
largest_acknowledged
first_ack_range
ack_ranges
)
;
let
acked_ranges
=
Frame
:
:
decode_ack_frame
(
largest_acknowledged
first_ack_range
&
ack_ranges
)
?
;
let
(
acked_packets
lost_packets
)
=
self
.
loss_recovery
.
on_ack_received
(
space
largest_acknowledged
acked_ranges
self
.
decode_ack_delay
(
ack_delay
)
now
)
;
for
acked
in
acked_packets
{
for
token
in
&
acked
.
tokens
{
match
token
{
RecoveryToken
:
:
Ack
(
at
)
=
>
self
.
acks
.
acked
(
at
)
RecoveryToken
:
:
Stream
(
st
)
=
>
self
.
send_streams
.
acked
(
st
)
RecoveryToken
:
:
Crypto
(
ct
)
=
>
self
.
crypto
.
acked
(
ct
)
RecoveryToken
:
:
Flow
(
ft
)
=
>
{
self
.
flow_mgr
.
borrow_mut
(
)
.
acked
(
ft
&
mut
self
.
send_streams
)
}
RecoveryToken
:
:
NewToken
(
seqno
)
=
>
self
.
new_token
.
acked
(
*
seqno
)
RecoveryToken
:
:
NewConnectionId
(
entry
)
=
>
self
.
cid_manager
.
acked
(
entry
)
RecoveryToken
:
:
RetireConnectionId
(
seqno
)
=
>
self
.
paths
.
acked_retire_cid
(
*
seqno
)
RecoveryToken
:
:
HandshakeDone
=
>
(
)
}
}
}
self
.
handle_lost_packets
(
&
lost_packets
)
;
qlog
:
:
packets_lost
(
&
mut
self
.
qlog
&
lost_packets
)
;
let
stats
=
&
mut
self
.
stats
.
borrow_mut
(
)
.
frame_rx
;
stats
.
ack
+
=
1
;
stats
.
largest_acknowledged
=
max
(
stats
.
largest_acknowledged
largest_acknowledged
)
;
Ok
(
(
)
)
}
fn
client_0rtt_rejected
(
&
mut
self
)
{
if
!
matches
!
(
self
.
zero_rtt_state
ZeroRttState
:
:
Sending
)
{
return
;
}
qdebug
!
(
[
self
]
"
0
-
RTT
rejected
"
)
;
let
dropped
=
self
.
loss_recovery
.
drop_0rtt
(
)
;
self
.
handle_lost_packets
(
&
dropped
)
;
self
.
send_streams
.
clear
(
)
;
self
.
recv_streams
.
clear
(
)
;
self
.
indexes
=
StreamIndexes
:
:
new
(
self
.
conn_params
.
get_max_streams
(
StreamType
:
:
BiDi
)
self
.
conn_params
.
get_max_streams
(
StreamType
:
:
UniDi
)
)
;
self
.
crypto
.
states
.
discard_0rtt_keys
(
)
;
self
.
events
.
client_0rtt_rejected
(
)
;
}
fn
set_connected
(
&
mut
self
now
:
Instant
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
TLS
connection
complete
"
)
;
if
self
.
crypto
.
tls
.
info
(
)
.
map
(
SecretAgentInfo
:
:
alpn
)
.
is_none
(
)
{
qwarn
!
(
[
self
]
"
No
ALPN
.
Closing
connection
.
"
)
;
return
Err
(
Error
:
:
CryptoAlert
(
120
)
)
;
}
if
self
.
role
=
=
Role
:
:
Server
{
self
.
cid_manager
.
remove_odcid
(
)
;
let
path
=
self
.
paths
.
primary
(
)
;
path
.
borrow_mut
(
)
.
set_valid
(
now
)
;
qlog
:
:
server_connection_started
(
&
mut
self
.
qlog
&
path
)
;
}
else
{
self
.
zero_rtt_state
=
if
self
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
early_data_accepted
(
)
{
ZeroRttState
:
:
AcceptedClient
}
else
{
self
.
client_0rtt_rejected
(
)
;
ZeroRttState
:
:
Rejected
}
;
}
let
pto
=
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
;
self
.
crypto
.
install_application_keys
(
now
+
pto
)
?
;
self
.
process_tps
(
)
?
;
self
.
set_state
(
State
:
:
Connected
)
;
self
.
create_resumption_token
(
now
)
;
self
.
saved_datagrams
.
make_available
(
CryptoSpace
:
:
ApplicationData
)
;
self
.
stats
.
borrow_mut
(
)
.
resumed
=
self
.
crypto
.
tls
.
info
(
)
.
unwrap
(
)
.
resumed
(
)
;
if
self
.
role
=
=
Role
:
:
Server
{
self
.
state_signaling
.
handshake_done
(
)
;
self
.
set_state
(
State
:
:
Confirmed
)
;
}
qinfo
!
(
[
self
]
"
Connection
established
"
)
;
Ok
(
(
)
)
}
fn
set_state
(
&
mut
self
state
:
State
)
{
if
state
>
self
.
state
{
qinfo
!
(
[
self
]
"
State
change
from
{
:
?
}
-
>
{
:
?
}
"
self
.
state
state
)
;
self
.
state
=
state
.
clone
(
)
;
if
self
.
state
.
closed
(
)
{
self
.
send_streams
.
clear
(
)
;
self
.
recv_streams
.
clear
(
)
;
}
self
.
events
.
connection_state_change
(
state
)
;
qlog
:
:
connection_state_updated
(
&
mut
self
.
qlog
&
self
.
state
)
}
else
if
mem
:
:
discriminant
(
&
state
)
!
=
mem
:
:
discriminant
(
&
self
.
state
)
{
debug_assert
!
(
matches
!
(
state
State
:
:
Closing
{
.
.
}
|
State
:
:
Draining
{
.
.
}
)
)
;
debug_assert
!
(
self
.
state
.
closed
(
)
)
;
}
}
fn
cleanup_streams
(
&
mut
self
)
{
self
.
send_streams
.
clear_terminal
(
)
;
let
recv_to_remove
=
self
.
recv_streams
.
iter
(
)
.
filter_map
(
|
(
id
stream
)
|
{
if
stream
.
is_terminal
(
)
&
&
(
id
.
is_uni
(
)
|
|
!
self
.
send_streams
.
exists
(
*
id
)
)
{
Some
(
*
id
)
}
else
{
None
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
mut
removed_bidi
=
0
;
let
mut
removed_uni
=
0
;
for
id
in
&
recv_to_remove
{
self
.
recv_streams
.
remove
(
&
id
)
;
if
id
.
is_remote_initiated
(
self
.
role
(
)
)
{
if
id
.
is_bidi
(
)
{
removed_bidi
+
=
1
;
}
else
{
removed_uni
+
=
1
;
}
}
}
if
removed_bidi
>
0
{
self
.
indexes
.
local_max_stream_bidi
+
=
removed_bidi
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_streams
(
self
.
indexes
.
local_max_stream_bidi
StreamType
:
:
BiDi
)
}
if
removed_uni
>
0
{
self
.
indexes
.
local_max_stream_uni
+
=
removed_uni
;
self
.
flow_mgr
.
borrow_mut
(
)
.
max_streams
(
self
.
indexes
.
local_max_stream_uni
StreamType
:
:
UniDi
)
}
}
fn
obtain_stream
(
&
mut
self
stream_id
:
StreamId
)
-
>
Res
<
(
Option
<
&
mut
SendStream
>
Option
<
&
mut
RecvStream
>
)
>
{
if
!
self
.
state
.
connected
(
)
&
&
!
matches
!
(
(
&
self
.
state
&
self
.
zero_rtt_state
)
(
State
:
:
Handshaking
ZeroRttState
:
:
AcceptedServer
)
)
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
if
stream_id
.
is_remote_initiated
(
self
.
role
(
)
)
{
let
next_stream_idx
=
if
stream_id
.
is_bidi
(
)
{
&
mut
self
.
indexes
.
local_next_stream_bidi
}
else
{
&
mut
self
.
indexes
.
local_next_stream_uni
}
;
let
stream_idx
:
StreamIndex
=
stream_id
.
into
(
)
;
if
stream_idx
>
=
*
next_stream_idx
{
let
recv_initial_max_stream_data
=
if
stream_id
.
is_bidi
(
)
{
if
stream_idx
>
self
.
indexes
.
local_max_stream_bidi
{
qwarn
!
(
[
self
]
"
remote
bidi
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
stream_idx
self
.
indexes
.
local_max_stream_bidi
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
self
.
tps
.
borrow
(
)
.
local
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
)
}
else
{
if
stream_idx
>
self
.
indexes
.
local_max_stream_uni
{
qwarn
!
(
[
self
]
"
remote
uni
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
stream_idx
self
.
indexes
.
local_max_stream_uni
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
self
.
tps
.
borrow
(
)
.
local
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
)
}
;
loop
{
let
next_stream_id
=
next_stream_idx
.
to_stream_id
(
stream_id
.
stream_type
(
)
stream_id
.
role
(
)
)
;
self
.
events
.
new_stream
(
next_stream_id
)
;
self
.
recv_streams
.
insert
(
next_stream_id
RecvStream
:
:
new
(
next_stream_id
recv_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
if
next_stream_id
.
is_bidi
(
)
{
let
send_initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
remote
(
)
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
)
;
self
.
send_streams
.
insert
(
next_stream_id
SendStream
:
:
new
(
next_stream_id
send_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
}
*
next_stream_idx
+
=
1
;
if
*
next_stream_idx
>
stream_idx
{
break
;
}
}
}
}
Ok
(
(
self
.
send_streams
.
get_mut
(
stream_id
)
.
ok
(
)
self
.
recv_streams
.
get_mut
(
&
stream_id
)
)
)
}
pub
fn
stream_create
(
&
mut
self
st
:
StreamType
)
-
>
Res
<
u64
>
{
match
self
.
state
{
State
:
:
Closing
{
.
.
}
|
State
:
:
Draining
{
.
.
}
|
State
:
:
Closed
{
.
.
}
=
>
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
State
:
:
WaitInitial
|
State
:
:
Handshaking
=
>
{
if
self
.
role
=
=
Role
:
:
Client
&
&
self
.
zero_rtt_state
!
=
ZeroRttState
:
:
Sending
{
return
Err
(
Error
:
:
ConnectionState
)
;
}
}
_
=
>
(
)
}
Ok
(
match
st
{
StreamType
:
:
UniDi
=
>
{
if
self
.
indexes
.
remote_next_stream_uni
>
=
self
.
indexes
.
remote_max_stream_uni
{
self
.
flow_mgr
.
borrow_mut
(
)
.
streams_blocked
(
self
.
indexes
.
remote_max_stream_uni
StreamType
:
:
UniDi
)
;
qwarn
!
(
[
self
]
"
local
uni
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
self
.
indexes
.
remote_next_stream_uni
self
.
indexes
.
remote_max_stream_uni
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
let
new_id
=
self
.
indexes
.
remote_next_stream_uni
.
to_stream_id
(
StreamType
:
:
UniDi
self
.
role
)
;
self
.
indexes
.
remote_next_stream_uni
+
=
1
;
let
initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
remote
(
)
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_UNI
)
;
self
.
send_streams
.
insert
(
new_id
SendStream
:
:
new
(
new_id
initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
new_id
.
as_u64
(
)
}
StreamType
:
:
BiDi
=
>
{
if
self
.
indexes
.
remote_next_stream_bidi
>
=
self
.
indexes
.
remote_max_stream_bidi
{
self
.
flow_mgr
.
borrow_mut
(
)
.
streams_blocked
(
self
.
indexes
.
remote_max_stream_bidi
StreamType
:
:
BiDi
)
;
qwarn
!
(
[
self
]
"
local
bidi
stream
create
blocked
next
=
{
:
?
}
max
=
{
:
?
}
"
self
.
indexes
.
remote_next_stream_bidi
self
.
indexes
.
remote_max_stream_bidi
)
;
return
Err
(
Error
:
:
StreamLimitError
)
;
}
let
new_id
=
self
.
indexes
.
remote_next_stream_bidi
.
to_stream_id
(
StreamType
:
:
BiDi
self
.
role
)
;
self
.
indexes
.
remote_next_stream_bidi
+
=
1
;
let
send_initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
remote
(
)
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
)
;
self
.
send_streams
.
insert
(
new_id
SendStream
:
:
new
(
new_id
send_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
let
recv_initial_max_stream_data
=
self
.
tps
.
borrow
(
)
.
local
.
get_integer
(
tparams
:
:
INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
)
;
self
.
recv_streams
.
insert
(
new_id
RecvStream
:
:
new
(
new_id
recv_initial_max_stream_data
self
.
flow_mgr
.
clone
(
)
self
.
events
.
clone
(
)
)
)
;
new_id
.
as_u64
(
)
}
}
)
}
pub
fn
stream_send
(
&
mut
self
stream_id
:
u64
data
:
&
[
u8
]
)
-
>
Res
<
usize
>
{
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
send
(
data
)
}
pub
fn
stream_send_atomic
(
&
mut
self
stream_id
:
u64
data
:
&
[
u8
]
)
-
>
Res
<
bool
>
{
let
val
=
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
send_atomic
(
data
)
;
if
let
Ok
(
val
)
=
val
{
debug_assert
!
(
val
=
=
0
|
|
val
=
=
data
.
len
(
)
"
Unexpected
value
{
}
when
trying
to
send
{
}
bytes
atomically
"
val
data
.
len
(
)
)
;
}
val
.
map
(
|
v
|
v
=
=
data
.
len
(
)
)
}
pub
fn
stream_avail_send_space
(
&
self
stream_id
:
u64
)
-
>
Res
<
usize
>
{
Ok
(
self
.
send_streams
.
get
(
stream_id
.
into
(
)
)
?
.
avail
(
)
)
}
pub
fn
stream_close_send
(
&
mut
self
stream_id
:
u64
)
-
>
Res
<
(
)
>
{
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
close
(
)
;
Ok
(
(
)
)
}
pub
fn
stream_reset_send
(
&
mut
self
stream_id
:
u64
err
:
AppError
)
-
>
Res
<
(
)
>
{
self
.
send_streams
.
get_mut
(
stream_id
.
into
(
)
)
?
.
reset
(
err
)
;
Ok
(
(
)
)
}
pub
fn
stream_recv
(
&
mut
self
stream_id
:
u64
data
:
&
mut
[
u8
]
)
-
>
Res
<
(
usize
bool
)
>
{
let
stream
=
self
.
recv_streams
.
get_mut
(
&
stream_id
.
into
(
)
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
?
;
let
rb
=
stream
.
read
(
data
)
?
;
Ok
(
(
rb
.
0
as
usize
rb
.
1
)
)
}
pub
fn
stream_stop_sending
(
&
mut
self
stream_id
:
u64
err
:
AppError
)
-
>
Res
<
(
)
>
{
let
stream
=
self
.
recv_streams
.
get_mut
(
&
stream_id
.
into
(
)
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
?
;
stream
.
stop_sending
(
err
)
;
Ok
(
(
)
)
}
#
[
cfg
(
test
)
]
pub
fn
get_pto
(
&
self
)
-
>
Duration
{
self
.
loss_recovery
.
pto_raw
(
PNSpace
:
:
ApplicationData
)
}
}
impl
EventProvider
for
Connection
{
type
Event
=
ConnectionEvent
;
fn
has_events
(
&
self
)
-
>
bool
{
self
.
events
.
has_events
(
)
}
fn
next_event
(
&
mut
self
)
-
>
Option
<
Self
:
:
Event
>
{
self
.
events
.
next_event
(
)
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
Connection
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
"
self
.
role
)
?
;
if
let
Some
(
cid
)
=
self
.
odcid
(
)
{
std
:
:
fmt
:
:
Display
:
:
fmt
(
&
cid
f
)
}
else
{
write
!
(
f
"
.
.
.
"
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
;
