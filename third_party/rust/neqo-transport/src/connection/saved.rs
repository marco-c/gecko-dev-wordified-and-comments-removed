use
std
:
:
mem
;
use
std
:
:
time
:
:
Instant
;
use
crate
:
:
crypto
:
:
CryptoSpace
;
use
neqo_common
:
:
{
qdebug
qinfo
Datagram
}
;
const
MAX_SAVED_DATAGRAMS
:
usize
=
32
;
pub
struct
SavedDatagram
{
pub
d
:
Datagram
pub
t
:
Instant
}
#
[
derive
(
Default
)
]
pub
struct
SavedDatagrams
{
handshake
:
Vec
<
SavedDatagram
>
application_data
:
Vec
<
SavedDatagram
>
available
:
Option
<
CryptoSpace
>
}
impl
SavedDatagrams
{
fn
store
(
&
mut
self
cspace
:
CryptoSpace
)
-
>
&
mut
Vec
<
SavedDatagram
>
{
match
cspace
{
CryptoSpace
:
:
Handshake
=
>
&
mut
self
.
handshake
CryptoSpace
:
:
ApplicationData
=
>
&
mut
self
.
application_data
_
=
>
panic
!
(
"
unexpected
space
"
)
}
}
pub
fn
save
(
&
mut
self
cspace
:
CryptoSpace
d
:
Datagram
t
:
Instant
)
{
let
store
=
self
.
store
(
cspace
)
;
if
store
.
len
(
)
<
MAX_SAVED_DATAGRAMS
{
qdebug
!
(
"
saving
datagram
of
{
}
bytes
"
d
.
len
(
)
)
;
store
.
push
(
SavedDatagram
{
d
t
}
)
;
}
else
{
qinfo
!
(
"
not
saving
datagram
of
{
}
bytes
"
d
.
len
(
)
)
;
}
}
pub
fn
make_available
(
&
mut
self
cspace
:
CryptoSpace
)
{
debug_assert_ne
!
(
cspace
CryptoSpace
:
:
ZeroRtt
)
;
debug_assert_ne
!
(
cspace
CryptoSpace
:
:
Initial
)
;
if
!
self
.
store
(
cspace
)
.
is_empty
(
)
{
self
.
available
=
Some
(
cspace
)
;
}
}
pub
fn
available
(
&
self
)
-
>
Option
<
CryptoSpace
>
{
self
.
available
}
pub
fn
take_saved
(
&
mut
self
)
-
>
Vec
<
SavedDatagram
>
{
self
.
available
.
take
(
)
.
map_or_else
(
Vec
:
:
new
|
cspace
|
mem
:
:
take
(
self
.
store
(
cspace
)
)
)
}
}
