use
neqo_common
:
:
{
self
as
common
hex
qdebug
qerror
qinfo
qlog
:
:
NeqoQlog
qtrace
qwarn
timer
:
:
Timer
Datagram
Decoder
Role
}
;
use
neqo_crypto
:
:
{
AntiReplay
ZeroRttCheckResult
ZeroRttChecker
}
;
pub
use
crate
:
:
addr_valid
:
:
ValidateAddress
;
use
crate
:
:
addr_valid
:
:
{
AddressValidation
AddressValidationResult
}
;
use
crate
:
:
cid
:
:
{
ConnectionId
ConnectionIdDecoder
ConnectionIdManager
ConnectionIdRef
}
;
use
crate
:
:
connection
:
:
{
Connection
Output
State
}
;
use
crate
:
:
packet
:
:
{
PacketBuilder
PacketType
PublicPacket
}
;
use
crate
:
:
{
QuicVersion
Res
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
VecDeque
}
;
use
std
:
:
fs
:
:
OpenOptions
;
use
std
:
:
mem
;
use
std
:
:
net
:
:
SocketAddr
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
rc
:
:
{
Rc
Weak
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
pub
enum
InitialResult
{
Accept
Drop
Retry
(
Vec
<
u8
>
)
}
const
MIN_INITIAL_PACKET_SIZE
:
usize
=
1200
;
const
TIMER_GRANULARITY
:
Duration
=
Duration
:
:
from_millis
(
10
)
;
const
TIMER_CAPACITY
:
usize
=
16384
;
type
StateRef
=
Rc
<
RefCell
<
ServerConnectionState
>
>
;
type
CidMgr
=
Rc
<
RefCell
<
dyn
ConnectionIdManager
>
>
;
type
ConnectionTableRef
=
Rc
<
RefCell
<
HashMap
<
ConnectionId
StateRef
>
>
>
;
#
[
derive
(
Debug
)
]
pub
struct
ServerConnectionState
{
c
:
Connection
active_attempt
:
Option
<
AttemptKey
>
last_timer
:
Instant
}
impl
Deref
for
ServerConnectionState
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
c
}
}
impl
DerefMut
for
ServerConnectionState
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
c
}
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
)
]
struct
AttemptKey
{
remote_address
:
SocketAddr
odcid
:
ConnectionId
}
#
[
derive
(
Clone
Debug
)
]
struct
ServerZeroRttChecker
{
checker
:
Rc
<
RefCell
<
Box
<
dyn
ZeroRttChecker
>
>
>
}
impl
ServerZeroRttChecker
{
pub
fn
new
(
checker
:
Box
<
dyn
ZeroRttChecker
>
)
-
>
Self
{
Self
{
checker
:
Rc
:
:
new
(
RefCell
:
:
new
(
checker
)
)
}
}
}
impl
ZeroRttChecker
for
ServerZeroRttChecker
{
fn
check
(
&
self
token
:
&
[
u8
]
)
-
>
ZeroRttCheckResult
{
self
.
checker
.
borrow
(
)
.
check
(
token
)
}
}
struct
InitialDetails
{
src_cid
:
ConnectionId
dst_cid
:
ConnectionId
token
:
Vec
<
u8
>
quic_version
:
QuicVersion
}
impl
InitialDetails
{
fn
new
(
packet
:
&
PublicPacket
)
-
>
Self
{
Self
{
src_cid
:
ConnectionId
:
:
from
(
packet
.
scid
(
)
)
dst_cid
:
ConnectionId
:
:
from
(
packet
.
dcid
(
)
)
token
:
packet
.
token
(
)
.
to_vec
(
)
quic_version
:
packet
.
version
(
)
.
unwrap
(
)
}
}
}
pub
struct
Server
{
certs
:
Vec
<
String
>
protocols
:
Vec
<
String
>
anti_replay
:
AntiReplay
zero_rtt_checker
:
ServerZeroRttChecker
cid_manager
:
CidMgr
active_attempts
:
HashMap
<
AttemptKey
StateRef
>
connections
:
ConnectionTableRef
active
:
HashSet
<
ActiveConnectionRef
>
waiting
:
VecDeque
<
StateRef
>
timers
:
Timer
<
StateRef
>
address_validation
:
Rc
<
RefCell
<
AddressValidation
>
>
qlog_dir
:
Option
<
PathBuf
>
}
impl
Server
{
pub
fn
new
(
now
:
Instant
certs
:
&
[
impl
AsRef
<
str
>
]
protocols
:
&
[
impl
AsRef
<
str
>
]
anti_replay
:
AntiReplay
zero_rtt_checker
:
Box
<
dyn
ZeroRttChecker
>
cid_manager
:
CidMgr
)
-
>
Res
<
Self
>
{
let
validation
=
AddressValidation
:
:
new
(
now
ValidateAddress
:
:
Never
)
?
;
Ok
(
Self
{
certs
:
certs
.
iter
(
)
.
map
(
|
x
|
String
:
:
from
(
x
.
as_ref
(
)
)
)
.
collect
(
)
protocols
:
protocols
.
iter
(
)
.
map
(
|
x
|
String
:
:
from
(
x
.
as_ref
(
)
)
)
.
collect
(
)
anti_replay
zero_rtt_checker
:
ServerZeroRttChecker
:
:
new
(
zero_rtt_checker
)
cid_manager
active_attempts
:
HashMap
:
:
default
(
)
connections
:
Rc
:
:
default
(
)
active
:
HashSet
:
:
default
(
)
waiting
:
VecDeque
:
:
default
(
)
timers
:
Timer
:
:
new
(
now
TIMER_GRANULARITY
TIMER_CAPACITY
)
address_validation
:
Rc
:
:
new
(
RefCell
:
:
new
(
validation
)
)
qlog_dir
:
None
}
)
}
pub
fn
set_qlog_dir
(
&
mut
self
dir
:
Option
<
PathBuf
>
)
{
self
.
qlog_dir
=
dir
;
}
pub
fn
set_validation
(
&
mut
self
v
:
ValidateAddress
)
{
self
.
address_validation
.
borrow_mut
(
)
.
set_validation
(
v
)
;
}
fn
remove_timer
(
&
mut
self
c
:
&
StateRef
)
{
let
last
=
c
.
borrow
(
)
.
last_timer
;
self
.
timers
.
remove
(
last
|
t
|
Rc
:
:
ptr_eq
(
t
c
)
)
;
}
fn
process_connection
(
&
mut
self
c
:
StateRef
dgram
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Option
<
Datagram
>
{
qtrace
!
(
[
self
]
"
Process
connection
{
:
?
}
"
c
)
;
let
out
=
c
.
borrow_mut
(
)
.
process
(
dgram
now
)
;
match
out
{
Output
:
:
Datagram
(
_
)
=
>
{
qtrace
!
(
[
self
]
"
Sending
packet
added
to
waiting
connections
"
)
;
self
.
waiting
.
push_back
(
Rc
:
:
clone
(
&
c
)
)
;
}
Output
:
:
Callback
(
delay
)
=
>
{
let
next
=
now
+
delay
;
if
next
!
=
c
.
borrow
(
)
.
last_timer
{
qtrace
!
(
[
self
]
"
Change
timer
to
{
:
?
}
"
next
)
;
self
.
remove_timer
(
&
c
)
;
c
.
borrow_mut
(
)
.
last_timer
=
next
;
self
.
timers
.
add
(
next
Rc
:
:
clone
(
&
c
)
)
;
}
}
_
=
>
{
self
.
remove_timer
(
&
c
)
;
}
}
if
c
.
borrow
(
)
.
has_events
(
)
{
qtrace
!
(
[
self
]
"
Connection
active
:
{
:
?
}
"
c
)
;
self
.
active
.
insert
(
ActiveConnectionRef
{
c
:
Rc
:
:
clone
(
&
c
)
}
)
;
}
if
*
c
.
borrow
(
)
.
state
(
)
>
State
:
:
Handshaking
{
if
let
Some
(
k
)
=
c
.
borrow_mut
(
)
.
active_attempt
.
take
(
)
{
self
.
active_attempts
.
remove
(
&
k
)
;
}
}
if
matches
!
(
c
.
borrow
(
)
.
state
(
)
State
:
:
Closed
(
_
)
)
{
c
.
borrow_mut
(
)
.
set_qlog
(
NeqoQlog
:
:
disabled
(
)
)
;
self
.
connections
.
borrow_mut
(
)
.
retain
(
|
_
v
|
!
Rc
:
:
ptr_eq
(
v
&
c
)
)
;
}
out
.
dgram
(
)
}
fn
connection
(
&
self
cid
:
&
ConnectionIdRef
)
-
>
Option
<
StateRef
>
{
if
let
Some
(
c
)
=
self
.
connections
.
borrow
(
)
.
get
(
&
cid
[
.
.
]
)
{
Some
(
Rc
:
:
clone
(
&
c
)
)
}
else
{
None
}
}
fn
handle_initial
(
&
mut
self
initial
:
InitialDetails
dgram
:
Datagram
now
:
Instant
)
-
>
Option
<
Datagram
>
{
qdebug
!
(
[
self
]
"
Handle
initial
"
)
;
let
res
=
self
.
address_validation
.
borrow
(
)
.
validate
(
&
initial
.
token
dgram
.
source
(
)
now
)
;
match
res
{
AddressValidationResult
:
:
Invalid
=
>
None
AddressValidationResult
:
:
Pass
=
>
self
.
connection_attempt
(
initial
dgram
None
now
)
AddressValidationResult
:
:
ValidRetry
(
orig_dcid
)
=
>
{
self
.
connection_attempt
(
initial
dgram
Some
(
orig_dcid
)
now
)
}
AddressValidationResult
:
:
Validate
=
>
{
qinfo
!
(
[
self
]
"
Send
retry
for
{
:
?
}
"
initial
.
dst_cid
)
;
let
res
=
self
.
address_validation
.
borrow
(
)
.
generate_retry_token
(
&
initial
.
dst_cid
dgram
.
source
(
)
now
)
;
let
token
=
if
let
Ok
(
t
)
=
res
{
t
}
else
{
qerror
!
(
[
self
]
"
unable
to
generate
token
dropping
packet
"
)
;
return
None
;
}
;
let
new_dcid
=
self
.
cid_manager
.
borrow_mut
(
)
.
generate_cid
(
)
;
let
packet
=
PacketBuilder
:
:
retry
(
initial
.
quic_version
&
initial
.
src_cid
&
new_dcid
&
token
&
initial
.
dst_cid
)
;
if
let
Ok
(
p
)
=
packet
{
let
retry
=
Datagram
:
:
new
(
dgram
.
destination
(
)
dgram
.
source
(
)
p
)
;
Some
(
retry
)
}
else
{
qerror
!
(
[
self
]
"
unable
to
encode
retry
dropping
packet
"
)
;
None
}
}
}
}
fn
connection_attempt
(
&
mut
self
initial
:
InitialDetails
dgram
:
Datagram
orig_dcid
:
Option
<
ConnectionId
>
now
:
Instant
)
-
>
Option
<
Datagram
>
{
let
attempt_key
=
AttemptKey
{
remote_address
:
dgram
.
source
(
)
odcid
:
orig_dcid
.
as_ref
(
)
.
unwrap_or
(
&
initial
.
dst_cid
)
.
clone
(
)
}
;
if
let
Some
(
c
)
=
self
.
active_attempts
.
get
(
&
attempt_key
)
{
qdebug
!
(
[
self
]
"
Handle
Initial
for
existing
connection
attempt
{
:
?
}
"
attempt_key
)
;
let
c
=
Rc
:
:
clone
(
c
)
;
self
.
process_connection
(
c
Some
(
dgram
)
now
)
}
else
{
self
.
accept_connection
(
attempt_key
initial
dgram
orig_dcid
now
)
}
}
fn
create_qlog_trace
(
&
self
attempt_key
:
&
AttemptKey
)
-
>
NeqoQlog
{
if
let
Some
(
qlog_dir
)
=
&
self
.
qlog_dir
{
let
mut
qlog_path
=
qlog_dir
.
to_path_buf
(
)
;
qlog_path
.
push
(
format
!
(
"
{
}
.
qlog
"
attempt_key
.
odcid
)
)
;
match
OpenOptions
:
:
new
(
)
.
write
(
true
)
.
create_new
(
true
)
.
open
(
&
qlog_path
)
{
Ok
(
f
)
=
>
{
qinfo
!
(
"
Qlog
output
to
{
}
"
qlog_path
.
display
(
)
)
;
let
streamer
=
:
:
qlog
:
:
QlogStreamer
:
:
new
(
qlog
:
:
QLOG_VERSION
.
to_string
(
)
Some
(
"
Neqo
server
qlog
"
.
to_string
(
)
)
Some
(
"
Neqo
server
qlog
"
.
to_string
(
)
)
None
std
:
:
time
:
:
Instant
:
:
now
(
)
common
:
:
qlog
:
:
new_trace
(
Role
:
:
Server
)
Box
:
:
new
(
f
)
)
;
let
n_qlog
=
NeqoQlog
:
:
enabled
(
streamer
qlog_path
)
;
match
n_qlog
{
Ok
(
nql
)
=
>
nql
Err
(
e
)
=
>
{
qerror
!
(
"
NeqoQlog
error
:
{
}
"
e
)
;
NeqoQlog
:
:
disabled
(
)
}
}
}
Err
(
e
)
=
>
{
qerror
!
(
"
Could
not
open
file
{
}
for
qlog
output
:
{
}
"
qlog_path
.
display
(
)
e
)
;
NeqoQlog
:
:
disabled
(
)
}
}
}
else
{
NeqoQlog
:
:
disabled
(
)
}
}
fn
accept_connection
(
&
mut
self
attempt_key
:
AttemptKey
initial
:
InitialDetails
dgram
:
Datagram
orig_dcid
:
Option
<
ConnectionId
>
now
:
Instant
)
-
>
Option
<
Datagram
>
{
qinfo
!
(
[
self
]
"
Accept
connection
{
:
?
}
"
attempt_key
)
;
let
cid_mgr
=
Rc
:
:
new
(
RefCell
:
:
new
(
ServerConnectionIdManager
{
c
:
Weak
:
:
new
(
)
cid_manager
:
Rc
:
:
clone
(
&
self
.
cid_manager
)
connections
:
Rc
:
:
clone
(
&
self
.
connections
)
saved_cids
:
Vec
:
:
new
(
)
}
)
)
;
let
sconn
=
Connection
:
:
new_server
(
&
self
.
certs
&
self
.
protocols
Rc
:
:
clone
(
&
cid_mgr
)
as
_
initial
.
quic_version
)
;
if
let
Ok
(
mut
c
)
=
sconn
{
let
zcheck
=
self
.
zero_rtt_checker
.
clone
(
)
;
if
c
.
server_enable_0rtt
(
&
self
.
anti_replay
zcheck
)
.
is_err
(
)
{
qwarn
!
(
[
self
]
"
Unable
to
enable
0
-
RTT
"
)
;
}
if
let
Some
(
odcid
)
=
orig_dcid
{
c
.
set_retry_cids
(
odcid
initial
.
src_cid
initial
.
dst_cid
)
;
}
c
.
set_validation
(
Rc
:
:
clone
(
&
self
.
address_validation
)
)
;
c
.
set_qlog
(
self
.
create_qlog_trace
(
&
attempt_key
)
)
;
let
c
=
Rc
:
:
new
(
RefCell
:
:
new
(
ServerConnectionState
{
c
last_timer
:
now
active_attempt
:
Some
(
attempt_key
.
clone
(
)
)
}
)
)
;
cid_mgr
.
borrow_mut
(
)
.
set_connection
(
Rc
:
:
clone
(
&
c
)
)
;
let
previous_attempt
=
self
.
active_attempts
.
insert
(
attempt_key
Rc
:
:
clone
(
&
c
)
)
;
debug_assert
!
(
previous_attempt
.
is_none
(
)
)
;
self
.
process_connection
(
c
Some
(
dgram
)
now
)
}
else
{
qwarn
!
(
[
self
]
"
Unable
to
create
connection
"
)
;
None
}
}
fn
process_input
(
&
mut
self
dgram
:
Datagram
now
:
Instant
)
-
>
Option
<
Datagram
>
{
qtrace
!
(
"
Process
datagram
:
{
}
"
hex
(
&
dgram
[
.
.
]
)
)
;
let
res
=
PublicPacket
:
:
decode
(
&
dgram
[
.
.
]
self
.
cid_manager
.
borrow
(
)
.
as_decoder
(
)
)
;
let
(
packet
_remainder
)
=
match
res
{
Ok
(
res
)
=
>
res
_
=
>
{
qtrace
!
(
[
self
]
"
Discarding
{
:
?
}
"
dgram
)
;
return
None
;
}
}
;
if
let
Some
(
c
)
=
self
.
connection
(
packet
.
dcid
(
)
)
{
return
self
.
process_connection
(
c
Some
(
dgram
)
now
)
;
}
if
packet
.
packet_type
(
)
=
=
PacketType
:
:
Short
{
qtrace
!
(
[
self
]
"
Short
header
packet
for
an
unknown
connection
"
)
;
return
None
;
}
if
dgram
.
len
(
)
<
MIN_INITIAL_PACKET_SIZE
{
qtrace
!
(
[
self
]
"
Bogus
packet
:
too
short
"
)
;
return
None
;
}
match
packet
.
packet_type
(
)
{
PacketType
:
:
Initial
=
>
{
let
initial
=
InitialDetails
:
:
new
(
&
packet
)
;
self
.
handle_initial
(
initial
dgram
now
)
}
PacketType
:
:
OtherVersion
=
>
{
let
vn
=
PacketBuilder
:
:
version_negotiation
(
packet
.
scid
(
)
packet
.
dcid
(
)
)
;
Some
(
Datagram
:
:
new
(
dgram
.
destination
(
)
dgram
.
source
(
)
vn
)
)
}
_
=
>
{
qtrace
!
(
[
self
]
"
Not
an
initial
packet
"
)
;
None
}
}
}
fn
process_next_output
(
&
mut
self
now
:
Instant
)
-
>
Option
<
Datagram
>
{
qtrace
!
(
[
self
]
"
No
packet
to
send
look
at
waiting
connections
"
)
;
while
let
Some
(
c
)
=
self
.
waiting
.
pop_front
(
)
{
if
let
Some
(
d
)
=
self
.
process_connection
(
c
None
now
)
{
return
Some
(
d
)
;
}
}
qtrace
!
(
[
self
]
"
No
packet
to
send
still
run
timers
"
)
;
while
let
Some
(
c
)
=
self
.
timers
.
take_next
(
now
)
{
if
let
Some
(
d
)
=
self
.
process_connection
(
c
None
now
)
{
return
Some
(
d
)
;
}
}
None
}
fn
next_time
(
&
mut
self
now
:
Instant
)
-
>
Option
<
Duration
>
{
if
self
.
waiting
.
is_empty
(
)
{
self
.
timers
.
next_time
(
)
.
map
(
|
x
|
x
-
now
)
}
else
{
Some
(
Duration
:
:
new
(
0
0
)
)
}
}
pub
fn
process
(
&
mut
self
dgram
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Output
{
let
out
=
if
let
Some
(
d
)
=
dgram
{
self
.
process_input
(
d
now
)
}
else
{
None
}
;
let
out
=
out
.
or_else
(
|
|
self
.
process_next_output
(
now
)
)
;
match
out
{
Some
(
d
)
=
>
{
qtrace
!
(
[
self
]
"
Send
packet
:
{
:
?
}
"
d
)
;
Output
:
:
Datagram
(
d
)
}
_
=
>
match
self
.
next_time
(
now
)
{
Some
(
delay
)
=
>
{
qtrace
!
(
[
self
]
"
Wait
:
{
:
?
}
"
delay
)
;
Output
:
:
Callback
(
delay
)
}
_
=
>
{
qtrace
!
(
[
self
]
"
Go
dormant
"
)
;
Output
:
:
None
}
}
}
}
pub
fn
active_connections
(
&
mut
self
)
-
>
Vec
<
ActiveConnectionRef
>
{
mem
:
:
take
(
&
mut
self
.
active
)
.
into_iter
(
)
.
collect
(
)
}
pub
fn
add_to_waiting
(
&
mut
self
c
:
ActiveConnectionRef
)
{
self
.
waiting
.
push_back
(
c
.
connection
(
)
)
;
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ActiveConnectionRef
{
c
:
StateRef
}
impl
ActiveConnectionRef
{
pub
fn
borrow
<
'
a
>
(
&
'
a
self
)
-
>
impl
Deref
<
Target
=
Connection
>
+
'
a
{
std
:
:
cell
:
:
Ref
:
:
map
(
self
.
c
.
borrow
(
)
|
c
|
&
c
.
c
)
}
pub
fn
borrow_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
impl
DerefMut
<
Target
=
Connection
>
+
'
a
{
std
:
:
cell
:
:
RefMut
:
:
map
(
self
.
c
.
borrow_mut
(
)
|
c
|
&
mut
c
.
c
)
}
pub
fn
connection
(
&
self
)
-
>
StateRef
{
Rc
:
:
clone
(
&
self
.
c
)
}
}
impl
std
:
:
hash
:
:
Hash
for
ActiveConnectionRef
{
fn
hash
<
H
:
std
:
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
let
ptr
:
*
const
_
=
self
.
c
.
as_ref
(
)
;
ptr
.
hash
(
state
)
}
}
impl
PartialEq
for
ActiveConnectionRef
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
Rc
:
:
ptr_eq
(
&
self
.
c
&
other
.
c
)
}
}
impl
Eq
for
ActiveConnectionRef
{
}
struct
ServerConnectionIdManager
{
c
:
Weak
<
RefCell
<
ServerConnectionState
>
>
connections
:
ConnectionTableRef
cid_manager
:
CidMgr
saved_cids
:
Vec
<
ConnectionId
>
}
impl
ServerConnectionIdManager
{
pub
fn
set_connection
(
&
mut
self
c
:
StateRef
)
{
let
saved
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
saved_cids
Vec
:
:
with_capacity
(
0
)
)
;
for
cid
in
saved
{
qtrace
!
(
"
ServerConnectionIdManager
inserting
saved
cid
{
}
"
cid
)
;
self
.
insert_cid
(
cid
Rc
:
:
clone
(
&
c
)
)
;
}
self
.
c
=
Rc
:
:
downgrade
(
&
c
)
;
}
fn
insert_cid
(
&
mut
self
cid
:
ConnectionId
rc
:
StateRef
)
{
debug_assert
!
(
!
cid
.
is_empty
(
)
)
;
self
.
connections
.
borrow_mut
(
)
.
insert
(
cid
rc
)
;
}
}
impl
ConnectionIdDecoder
for
ServerConnectionIdManager
{
fn
decode_cid
<
'
a
>
(
&
self
dec
:
&
mut
Decoder
<
'
a
>
)
-
>
Option
<
ConnectionIdRef
<
'
a
>
>
{
self
.
cid_manager
.
borrow_mut
(
)
.
decode_cid
(
dec
)
}
}
impl
ConnectionIdManager
for
ServerConnectionIdManager
{
fn
generate_cid
(
&
mut
self
)
-
>
ConnectionId
{
let
cid
=
self
.
cid_manager
.
borrow_mut
(
)
.
generate_cid
(
)
;
if
let
Some
(
rc
)
=
self
.
c
.
upgrade
(
)
{
self
.
insert_cid
(
cid
.
clone
(
)
rc
)
;
}
else
{
qtrace
!
(
"
ServerConnectionIdManager
saving
cid
{
}
"
cid
)
;
self
.
saved_cids
.
push
(
cid
.
clone
(
)
)
;
}
cid
}
fn
as_decoder
(
&
self
)
-
>
&
dyn
ConnectionIdDecoder
{
self
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
Server
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Server
"
)
}
}
