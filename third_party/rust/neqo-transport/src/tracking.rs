#
!
[
deny
(
clippy
:
:
pedantic
)
]
use
std
:
:
cmp
:
:
min
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
ops
:
:
{
Index
IndexMut
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
neqo_common
:
:
{
qdebug
qinfo
qtrace
qwarn
}
;
use
neqo_crypto
:
:
{
Epoch
TLS_EPOCH_HANDSHAKE
TLS_EPOCH_INITIAL
}
;
use
crate
:
:
packet
:
:
{
PacketBuilder
PacketNumber
PacketType
}
;
use
crate
:
:
recovery
:
:
RecoveryToken
;
use
crate
:
:
stats
:
:
FrameStats
;
use
crate
:
:
{
Error
Res
}
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
PartialOrd
Ord
Eq
)
]
pub
enum
PNSpace
{
Initial
Handshake
ApplicationData
}
#
[
allow
(
clippy
:
:
use_self
)
]
impl
PNSpace
{
pub
fn
iter
(
)
-
>
impl
Iterator
<
Item
=
&
'
static
PNSpace
>
{
const
SPACES
:
&
[
PNSpace
]
=
&
[
PNSpace
:
:
Initial
PNSpace
:
:
Handshake
PNSpace
:
:
ApplicationData
]
;
SPACES
.
iter
(
)
}
}
impl
From
<
Epoch
>
for
PNSpace
{
fn
from
(
epoch
:
Epoch
)
-
>
Self
{
match
epoch
{
TLS_EPOCH_INITIAL
=
>
Self
:
:
Initial
TLS_EPOCH_HANDSHAKE
=
>
Self
:
:
Handshake
_
=
>
Self
:
:
ApplicationData
}
}
}
impl
From
<
PacketType
>
for
PNSpace
{
fn
from
(
pt
:
PacketType
)
-
>
Self
{
match
pt
{
PacketType
:
:
Initial
=
>
Self
:
:
Initial
PacketType
:
:
Handshake
=
>
Self
:
:
Handshake
PacketType
:
:
ZeroRtt
|
PacketType
:
:
Short
=
>
Self
:
:
ApplicationData
_
=
>
panic
!
(
"
Attempted
to
get
space
from
wrong
packet
type
"
)
}
}
}
#
[
derive
(
Clone
Copy
Default
)
]
pub
struct
PNSpaceSet
{
initial
:
bool
handshake
:
bool
application_data
:
bool
}
impl
PNSpaceSet
{
pub
fn
all
(
)
-
>
Self
{
Self
{
initial
:
true
handshake
:
true
application_data
:
true
}
}
}
impl
Index
<
PNSpace
>
for
PNSpaceSet
{
type
Output
=
bool
;
fn
index
(
&
self
space
:
PNSpace
)
-
>
&
Self
:
:
Output
{
match
space
{
PNSpace
:
:
Initial
=
>
&
self
.
initial
PNSpace
:
:
Handshake
=
>
&
self
.
handshake
PNSpace
:
:
ApplicationData
=
>
&
self
.
application_data
}
}
}
impl
IndexMut
<
PNSpace
>
for
PNSpaceSet
{
fn
index_mut
(
&
mut
self
space
:
PNSpace
)
-
>
&
mut
Self
:
:
Output
{
match
space
{
PNSpace
:
:
Initial
=
>
&
mut
self
.
initial
PNSpace
:
:
Handshake
=
>
&
mut
self
.
handshake
PNSpace
:
:
ApplicationData
=
>
&
mut
self
.
application_data
}
}
}
impl
<
T
:
AsRef
<
[
PNSpace
]
>
>
From
<
T
>
for
PNSpaceSet
{
fn
from
(
spaces
:
T
)
-
>
Self
{
let
mut
v
=
Self
:
:
default
(
)
;
for
sp
in
spaces
.
as_ref
(
)
{
v
[
*
sp
]
=
true
;
}
v
}
}
impl
std
:
:
fmt
:
:
Debug
for
PNSpaceSet
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
let
mut
first
=
true
;
f
.
write_str
(
"
(
"
)
?
;
for
sp
in
PNSpace
:
:
iter
(
)
{
if
self
[
*
sp
]
{
if
!
first
{
f
.
write_str
(
"
+
"
)
?
;
first
=
false
;
}
std
:
:
fmt
:
:
Display
:
:
fmt
(
sp
f
)
?
;
}
}
f
.
write_str
(
"
)
"
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
SentPacket
{
pub
pt
:
PacketType
pub
pn
:
PacketNumber
ack_eliciting
:
bool
pub
time_sent
:
Instant
primary_path
:
bool
pub
tokens
:
Vec
<
RecoveryToken
>
time_declared_lost
:
Option
<
Instant
>
pto
:
bool
pub
size
:
usize
}
impl
SentPacket
{
pub
fn
new
(
pt
:
PacketType
pn
:
PacketNumber
time_sent
:
Instant
ack_eliciting
:
bool
tokens
:
Vec
<
RecoveryToken
>
size
:
usize
)
-
>
Self
{
Self
{
pt
pn
time_sent
ack_eliciting
primary_path
:
true
tokens
time_declared_lost
:
None
pto
:
false
size
}
}
pub
fn
ack_eliciting
(
&
self
)
-
>
bool
{
self
.
ack_eliciting
}
pub
fn
on_primary_path
(
&
self
)
-
>
bool
{
self
.
primary_path
}
pub
fn
clear_primary_path
(
&
mut
self
)
{
self
.
primary_path
=
false
;
}
pub
fn
lost
(
&
self
)
-
>
bool
{
self
.
time_declared_lost
.
is_some
(
)
}
pub
fn
cc_outstanding
(
&
self
)
-
>
bool
{
self
.
ack_eliciting
(
)
&
&
self
.
on_primary_path
(
)
&
&
!
self
.
lost
(
)
}
pub
fn
cc_in_flight
(
&
self
)
-
>
bool
{
self
.
ack_eliciting
(
)
&
&
self
.
on_primary_path
(
)
}
pub
fn
declare_lost
(
&
mut
self
now
:
Instant
)
-
>
bool
{
if
self
.
lost
(
)
{
false
}
else
{
self
.
time_declared_lost
=
Some
(
now
)
;
true
}
}
pub
fn
expired
(
&
self
now
:
Instant
expiration_period
:
Duration
)
-
>
bool
{
self
.
time_declared_lost
.
map_or
(
false
|
loss_time
|
(
loss_time
+
expiration_period
)
<
=
now
)
}
pub
fn
pto_fired
(
&
self
)
-
>
bool
{
self
.
pto
}
pub
fn
pto
(
&
mut
self
)
-
>
bool
{
if
self
.
pto
|
|
self
.
lost
(
)
{
false
}
else
{
self
.
pto
=
true
;
true
}
}
}
impl
std
:
:
fmt
:
:
Display
for
PNSpace
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
write_str
(
match
self
{
Self
:
:
Initial
=
>
"
in
"
Self
:
:
Handshake
=
>
"
hs
"
Self
:
:
ApplicationData
=
>
"
ap
"
}
)
}
}
pub
enum
InsertionResult
{
Largest
Smallest
NotInserted
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
PacketRange
{
largest
:
PacketNumber
smallest
:
PacketNumber
ack_needed
:
bool
}
impl
PacketRange
{
pub
fn
new
(
pn
:
PacketNumber
)
-
>
Self
{
Self
{
largest
:
pn
smallest
:
pn
ack_needed
:
true
}
}
pub
fn
len
(
&
self
)
-
>
u64
{
self
.
largest
-
self
.
smallest
+
1
}
pub
fn
ack_needed
(
&
self
)
-
>
bool
{
self
.
ack_needed
}
pub
fn
contains
(
&
self
pn
:
PacketNumber
)
-
>
bool
{
(
pn
>
=
self
.
smallest
)
&
&
(
pn
<
=
self
.
largest
)
}
pub
fn
add
(
&
mut
self
pn
:
PacketNumber
)
-
>
InsertionResult
{
assert
!
(
!
self
.
contains
(
pn
)
)
;
if
(
self
.
largest
+
1
)
=
=
pn
{
qtrace
!
(
[
self
]
"
Adding
largest
{
}
"
pn
)
;
self
.
largest
+
=
1
;
self
.
ack_needed
=
true
;
InsertionResult
:
:
Largest
}
else
if
self
.
smallest
=
=
(
pn
+
1
)
{
qtrace
!
(
[
self
]
"
Adding
smallest
{
}
"
pn
)
;
self
.
smallest
-
=
1
;
self
.
ack_needed
=
true
;
InsertionResult
:
:
Smallest
}
else
{
InsertionResult
:
:
NotInserted
}
}
fn
merge_larger
(
&
mut
self
other
:
&
Self
)
{
qinfo
!
(
[
self
]
"
Merging
{
}
"
other
)
;
assert_eq
!
(
self
.
largest
+
1
other
.
smallest
)
;
self
.
largest
=
other
.
largest
;
self
.
ack_needed
=
self
.
ack_needed
|
|
other
.
ack_needed
;
}
pub
fn
acknowledged
(
&
mut
self
other
:
&
Self
)
{
if
(
other
.
smallest
<
=
self
.
smallest
)
&
&
(
other
.
largest
>
=
self
.
largest
)
{
self
.
ack_needed
=
false
;
}
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
PacketRange
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
-
>
{
}
"
self
.
largest
self
.
smallest
)
}
}
pub
const
ACK_DELAY
:
Duration
=
Duration
:
:
from_millis
(
20
)
;
pub
const
MAX_UNACKED_PKTS
:
usize
=
1
;
const
MAX_TRACKED_RANGES
:
usize
=
32
;
const
MAX_ACKS_PER_FRAME
:
usize
=
32
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
AckToken
{
space
:
PNSpace
ranges
:
Vec
<
PacketRange
>
}
#
[
derive
(
Debug
)
]
pub
struct
RecvdPackets
{
space
:
PNSpace
ranges
:
VecDeque
<
PacketRange
>
min_tracked
:
PacketNumber
largest_pn_time
:
Option
<
Instant
>
ack_time
:
Option
<
Instant
>
pkts_since_last_ack
:
usize
}
impl
RecvdPackets
{
pub
fn
new
(
space
:
PNSpace
)
-
>
Self
{
Self
{
space
ranges
:
VecDeque
:
:
new
(
)
min_tracked
:
0
largest_pn_time
:
None
ack_time
:
None
pkts_since_last_ack
:
0
}
}
pub
fn
ack_time
(
&
self
)
-
>
Option
<
Instant
>
{
self
.
ack_time
}
fn
ack_now
(
&
self
now
:
Instant
)
-
>
bool
{
match
self
.
ack_time
{
Some
(
t
)
=
>
t
<
=
now
None
=
>
false
}
}
fn
add
(
&
mut
self
pn
:
PacketNumber
)
{
for
i
in
0
.
.
self
.
ranges
.
len
(
)
{
match
self
.
ranges
[
i
]
.
add
(
pn
)
{
InsertionResult
:
:
Largest
=
>
return
InsertionResult
:
:
Smallest
=
>
{
let
nxt
=
i
+
1
;
if
(
nxt
<
self
.
ranges
.
len
(
)
)
&
&
(
pn
-
1
=
=
self
.
ranges
[
nxt
]
.
largest
)
{
let
larger
=
self
.
ranges
.
remove
(
i
)
.
unwrap
(
)
;
self
.
ranges
[
i
]
.
merge_larger
(
&
larger
)
;
}
return
;
}
InsertionResult
:
:
NotInserted
=
>
{
if
self
.
ranges
[
i
]
.
largest
<
pn
{
self
.
ranges
.
insert
(
i
PacketRange
:
:
new
(
pn
)
)
;
return
;
}
}
}
}
self
.
ranges
.
push_back
(
PacketRange
:
:
new
(
pn
)
)
;
}
fn
trim_ranges
(
&
mut
self
)
{
if
self
.
ranges
.
len
(
)
>
MAX_TRACKED_RANGES
{
let
oldest
=
self
.
ranges
.
pop_back
(
)
.
unwrap
(
)
;
if
oldest
.
ack_needed
{
qwarn
!
(
[
self
]
"
Dropping
unacknowledged
ACK
range
:
{
}
"
oldest
)
;
}
else
{
qdebug
!
(
[
self
]
"
Drop
ACK
range
:
{
}
"
oldest
)
;
}
self
.
min_tracked
=
oldest
.
largest
+
1
;
}
}
pub
fn
set_received
(
&
mut
self
now
:
Instant
pn
:
PacketNumber
ack_eliciting
:
bool
)
-
>
bool
{
let
next_in_order_pn
=
self
.
ranges
.
front
(
)
.
map_or
(
0
|
pr
|
pr
.
largest
+
1
)
;
qdebug
!
(
[
self
]
"
received
{
}
next
in
order
pn
:
{
}
"
pn
next_in_order_pn
)
;
self
.
add
(
pn
)
;
self
.
trim_ranges
(
)
;
let
largest
=
if
pn
>
=
next_in_order_pn
{
self
.
largest_pn_time
=
Some
(
now
)
;
true
}
else
{
false
}
;
if
ack_eliciting
{
self
.
pkts_since_last_ack
+
=
1
;
if
pn
!
=
next_in_order_pn
{
self
.
ack_time
=
Some
(
now
)
;
}
else
if
self
.
space
=
=
PNSpace
:
:
ApplicationData
{
match
&
mut
self
.
pkts_since_last_ack
{
0
=
>
unreachable
!
(
)
1
=
>
self
.
ack_time
=
Some
(
now
+
ACK_DELAY
)
x
if
*
x
>
MAX_UNACKED_PKTS
=
>
self
.
ack_time
=
Some
(
now
)
_
=
>
debug_assert
!
(
self
.
ack_time
.
is_some
(
)
)
}
}
else
{
self
.
ack_time
=
Some
(
now
)
;
}
qdebug
!
(
[
self
]
"
Set
ACK
timer
to
{
:
?
}
"
self
.
ack_time
)
;
}
largest
}
pub
fn
is_duplicate
(
&
self
pn
:
PacketNumber
)
-
>
bool
{
if
pn
<
self
.
min_tracked
{
return
true
;
}
for
range
in
&
self
.
ranges
{
if
range
.
contains
(
pn
)
{
return
true
;
}
}
false
}
pub
fn
acknowledged
(
&
mut
self
acked
:
&
[
PacketRange
]
)
{
let
mut
range_iter
=
self
.
ranges
.
iter_mut
(
)
;
let
mut
cur
=
range_iter
.
next
(
)
.
expect
(
"
should
have
at
least
one
range
"
)
;
for
ack
in
acked
{
while
cur
.
smallest
>
ack
.
largest
{
cur
=
match
range_iter
.
next
(
)
{
Some
(
c
)
=
>
c
None
=
>
return
}
;
}
cur
.
acknowledged
(
&
ack
)
;
}
}
fn
write_frame
(
&
mut
self
now
:
Instant
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
{
const
LONGEST_ACK_HEADER
:
usize
=
1
+
8
+
8
+
1
+
8
;
if
!
self
.
ack_now
(
now
)
{
return
;
}
let
max_ranges
=
if
let
Some
(
avail
)
=
builder
.
remaining
(
)
.
checked_sub
(
LONGEST_ACK_HEADER
)
{
min
(
1
+
(
avail
/
16
)
MAX_ACKS_PER_FRAME
)
}
else
{
return
;
}
;
let
ranges
=
self
.
ranges
.
iter
(
)
.
filter
(
|
r
|
r
.
ack_needed
(
)
)
.
take
(
max_ranges
)
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
builder
.
encode_varint
(
crate
:
:
frame
:
:
FRAME_TYPE_ACK
)
;
let
mut
iter
=
ranges
.
iter
(
)
;
let
first
=
match
iter
.
next
(
)
{
Some
(
v
)
=
>
v
None
=
>
return
}
;
builder
.
encode_varint
(
first
.
largest
)
;
stats
.
largest_acknowledged
=
first
.
largest
;
stats
.
ack
+
=
1
;
let
elapsed
=
now
.
duration_since
(
self
.
largest_pn_time
.
unwrap
(
)
)
;
let
ack_delay
=
u64
:
:
try_from
(
elapsed
.
as_micros
(
)
/
8
)
.
unwrap_or
(
u64
:
:
MAX
)
;
let
ack_delay
=
min
(
(
1
<
<
62
)
-
1
ack_delay
)
;
builder
.
encode_varint
(
ack_delay
)
;
builder
.
encode_varint
(
u64
:
:
try_from
(
ranges
.
len
(
)
-
1
)
.
unwrap
(
)
)
;
builder
.
encode_varint
(
first
.
len
(
)
-
1
)
;
let
mut
last
=
first
.
smallest
;
for
r
in
iter
{
builder
.
encode_varint
(
last
-
r
.
largest
-
2
)
;
builder
.
encode_varint
(
r
.
len
(
)
-
1
)
;
last
=
r
.
smallest
;
}
self
.
ack_time
=
None
;
self
.
pkts_since_last_ack
=
0
;
tokens
.
push
(
RecoveryToken
:
:
Ack
(
AckToken
{
space
:
self
.
space
ranges
}
)
)
;
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
RecvdPackets
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Recvd
-
{
}
"
self
.
space
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
AckTracker
{
spaces
:
SmallVec
<
[
RecvdPackets
;
1
]
>
}
impl
AckTracker
{
pub
fn
drop_space
(
&
mut
self
space
:
PNSpace
)
{
let
sp
=
match
space
{
PNSpace
:
:
Initial
=
>
self
.
spaces
.
pop
(
)
PNSpace
:
:
Handshake
=
>
{
let
sp
=
self
.
spaces
.
pop
(
)
;
self
.
spaces
.
shrink_to_fit
(
)
;
sp
}
PNSpace
:
:
ApplicationData
=
>
panic
!
(
"
discarding
application
space
"
)
}
;
assert_eq
!
(
sp
.
unwrap
(
)
.
space
space
"
dropping
spaces
out
of
order
"
)
;
}
pub
fn
get_mut
(
&
mut
self
space
:
PNSpace
)
-
>
Option
<
&
mut
RecvdPackets
>
{
self
.
spaces
.
get_mut
(
match
space
{
PNSpace
:
:
ApplicationData
=
>
0
PNSpace
:
:
Handshake
=
>
1
PNSpace
:
:
Initial
=
>
2
}
)
}
pub
fn
ack_time
(
&
self
now
:
Instant
)
-
>
Option
<
Instant
>
{
if
self
.
spaces
.
len
(
)
=
=
1
{
self
.
spaces
[
0
]
.
ack_time
(
)
}
else
{
self
.
spaces
.
iter
(
)
.
filter_map
(
|
recvd
|
recvd
.
ack_time
(
)
.
filter
(
|
t
|
*
t
>
now
)
)
.
min
(
)
}
}
pub
fn
acked
(
&
mut
self
token
:
&
AckToken
)
{
if
let
Some
(
space
)
=
self
.
get_mut
(
token
.
space
)
{
space
.
acknowledged
(
&
token
.
ranges
)
;
}
}
pub
(
crate
)
fn
write_frame
(
&
mut
self
pn_space
:
PNSpace
now
:
Instant
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
FrameStats
)
-
>
Res
<
(
)
>
{
if
let
Some
(
space
)
=
self
.
get_mut
(
pn_space
)
{
space
.
write_frame
(
now
builder
tokens
stats
)
;
if
builder
.
len
(
)
>
builder
.
limit
(
)
{
return
Err
(
Error
:
:
InternalError
(
24
)
)
;
}
}
Ok
(
(
)
)
}
}
impl
Default
for
AckTracker
{
fn
default
(
)
-
>
Self
{
Self
{
spaces
:
smallvec
!
[
RecvdPackets
:
:
new
(
PNSpace
:
:
ApplicationData
)
RecvdPackets
:
:
new
(
PNSpace
:
:
Handshake
)
RecvdPackets
:
:
new
(
PNSpace
:
:
Initial
)
]
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
AckTracker
Duration
Instant
PNSpace
PNSpaceSet
RecoveryToken
RecvdPackets
ACK_DELAY
MAX_TRACKED_RANGES
MAX_UNACKED_PKTS
}
;
use
crate
:
:
frame
:
:
Frame
;
use
crate
:
:
packet
:
:
PacketBuilder
;
use
crate
:
:
stats
:
:
FrameStats
;
use
lazy_static
:
:
lazy_static
;
use
neqo_common
:
:
Encoder
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
convert
:
:
TryFrom
;
lazy_static
!
{
static
ref
NOW
:
Instant
=
Instant
:
:
now
(
)
;
}
fn
test_ack_range
(
pns
:
&
[
u64
]
nranges
:
usize
)
{
let
mut
rp
=
RecvdPackets
:
:
new
(
PNSpace
:
:
Initial
)
;
let
mut
packets
=
HashSet
:
:
new
(
)
;
for
pn
in
pns
{
rp
.
set_received
(
*
NOW
*
pn
true
)
;
packets
.
insert
(
*
pn
)
;
}
assert_eq
!
(
rp
.
ranges
.
len
(
)
nranges
)
;
for
pn
in
pns
{
assert
!
(
rp
.
is_duplicate
(
*
pn
)
)
;
}
let
mut
iter
=
rp
.
ranges
.
iter
(
)
;
let
mut
last
=
iter
.
next
(
)
.
expect
(
"
should
have
at
least
one
"
)
;
for
n
in
iter
{
assert
!
(
n
.
largest
+
1
<
last
.
smallest
)
;
last
=
n
;
}
let
mut
in_ranges
=
HashSet
:
:
new
(
)
;
for
range
in
&
rp
.
ranges
{
for
included
in
range
.
smallest
.
.
=
range
.
largest
{
in_ranges
.
insert
(
included
)
;
}
}
assert_eq
!
(
packets
in_ranges
)
;
}
#
[
test
]
fn
pn0
(
)
{
test_ack_range
(
&
[
0
]
1
)
;
}
#
[
test
]
fn
pn1
(
)
{
test_ack_range
(
&
[
1
]
1
)
;
}
#
[
test
]
fn
two_ranges
(
)
{
test_ack_range
(
&
[
0
1
2
5
6
7
]
2
)
;
}
#
[
test
]
fn
fill_in_range
(
)
{
test_ack_range
(
&
[
0
1
2
5
6
7
3
4
]
1
)
;
}
#
[
test
]
fn
too_many_ranges
(
)
{
let
mut
rp
=
RecvdPackets
:
:
new
(
PNSpace
:
:
Initial
)
;
for
i
in
0
.
.
=
MAX_TRACKED_RANGES
{
rp
.
set_received
(
*
NOW
(
i
*
2
)
as
u64
true
)
;
}
assert_eq
!
(
rp
.
ranges
.
len
(
)
MAX_TRACKED_RANGES
)
;
assert_eq
!
(
rp
.
ranges
.
back
(
)
.
unwrap
(
)
.
largest
2
)
;
assert
!
(
rp
.
is_duplicate
(
0
)
)
;
assert
!
(
!
rp
.
is_duplicate
(
1
)
)
;
assert
!
(
rp
.
is_duplicate
(
2
)
)
;
}
#
[
test
]
fn
ack_delay
(
)
{
let
mut
rp
=
RecvdPackets
:
:
new
(
PNSpace
:
:
ApplicationData
)
;
assert
!
(
rp
.
ack_time
(
)
.
is_none
(
)
)
;
assert
!
(
!
rp
.
ack_now
(
*
NOW
)
)
;
let
max_unacked
=
u64
:
:
try_from
(
MAX_UNACKED_PKTS
)
.
unwrap
(
)
;
for
num
in
0
.
.
max_unacked
{
rp
.
set_received
(
*
NOW
num
true
)
;
assert_eq
!
(
Some
(
*
NOW
+
ACK_DELAY
)
rp
.
ack_time
(
)
)
;
assert
!
(
!
rp
.
ack_now
(
*
NOW
)
)
;
assert
!
(
rp
.
ack_now
(
*
NOW
+
ACK_DELAY
)
)
;
}
rp
.
set_received
(
*
NOW
max_unacked
true
)
;
assert_eq
!
(
Some
(
*
NOW
)
rp
.
ack_time
(
)
)
;
assert
!
(
rp
.
ack_now
(
*
NOW
)
)
;
}
#
[
test
]
fn
no_ack_delay
(
)
{
for
space
in
&
[
PNSpace
:
:
Initial
PNSpace
:
:
Handshake
]
{
let
mut
rp
=
RecvdPackets
:
:
new
(
*
space
)
;
assert
!
(
rp
.
ack_time
(
)
.
is_none
(
)
)
;
assert
!
(
!
rp
.
ack_now
(
*
NOW
)
)
;
rp
.
set_received
(
*
NOW
0
true
)
;
assert_eq
!
(
Some
(
*
NOW
)
rp
.
ack_time
(
)
)
;
assert
!
(
rp
.
ack_now
(
*
NOW
)
)
;
}
}
#
[
test
]
fn
ooo_no_ack_delay
(
)
{
for
space
in
&
[
PNSpace
:
:
Initial
PNSpace
:
:
Handshake
PNSpace
:
:
ApplicationData
]
{
let
mut
rp
=
RecvdPackets
:
:
new
(
*
space
)
;
assert
!
(
rp
.
ack_time
(
)
.
is_none
(
)
)
;
assert
!
(
!
rp
.
ack_now
(
*
NOW
)
)
;
rp
.
set_received
(
*
NOW
3
true
)
;
assert_eq
!
(
Some
(
*
NOW
)
rp
.
ack_time
(
)
)
;
assert
!
(
rp
.
ack_now
(
*
NOW
)
)
;
}
}
#
[
test
]
fn
aggregate_ack_time
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
tracker
.
get_mut
(
PNSpace
:
:
Handshake
)
.
unwrap
(
)
.
set_received
(
*
NOW
0
false
)
;
assert_eq
!
(
None
tracker
.
ack_time
(
*
NOW
)
)
;
tracker
.
get_mut
(
PNSpace
:
:
ApplicationData
)
.
unwrap
(
)
.
set_received
(
*
NOW
0
true
)
;
assert_eq
!
(
Some
(
*
NOW
+
ACK_DELAY
)
tracker
.
ack_time
(
*
NOW
)
)
;
let
later
=
*
NOW
+
ACK_DELAY
.
checked_div
(
2
)
.
unwrap
(
)
;
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
unwrap
(
)
.
set_received
(
later
0
true
)
;
assert_eq
!
(
Some
(
later
)
tracker
.
ack_time
(
*
NOW
)
)
;
}
#
[
test
]
#
[
should_panic
(
expected
=
"
discarding
application
space
"
)
]
fn
drop_app
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
tracker
.
drop_space
(
PNSpace
:
:
ApplicationData
)
;
}
#
[
test
]
#
[
should_panic
(
expected
=
"
dropping
spaces
out
of
order
"
)
]
fn
drop_out_of_order
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
tracker
.
drop_space
(
PNSpace
:
:
Handshake
)
;
}
#
[
test
]
fn
drop_spaces
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
unwrap
(
)
.
set_received
(
*
NOW
0
true
)
;
assert
!
(
tracker
.
ack_time
(
*
NOW
-
Duration
:
:
from_millis
(
1
)
)
.
is_some
(
)
)
;
let
mut
tokens
=
Vec
:
:
new
(
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
tracker
.
write_frame
(
PNSpace
:
:
Initial
*
NOW
&
mut
builder
&
mut
tokens
&
mut
stats
)
.
unwrap
(
)
;
assert_eq
!
(
stats
.
ack
1
)
;
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
unwrap
(
)
.
set_received
(
*
NOW
1
true
)
;
assert
!
(
tracker
.
ack_time
(
*
NOW
-
Duration
:
:
from_millis
(
1
)
)
.
is_some
(
)
)
;
tracker
.
drop_space
(
PNSpace
:
:
Initial
)
;
assert
!
(
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
is_none
(
)
)
;
assert
!
(
tracker
.
ack_time
(
*
NOW
-
Duration
:
:
from_millis
(
1
)
)
.
is_none
(
)
)
;
tracker
.
write_frame
(
PNSpace
:
:
Initial
*
NOW
&
mut
builder
&
mut
tokens
&
mut
stats
)
.
unwrap
(
)
;
assert_eq
!
(
stats
.
ack
1
)
;
if
let
RecoveryToken
:
:
Ack
(
tok
)
=
&
tokens
[
0
]
{
tracker
.
acked
(
tok
)
;
}
else
{
panic
!
(
"
not
an
ACK
token
"
)
;
}
}
#
[
test
]
fn
no_room_for_ack
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
unwrap
(
)
.
set_received
(
*
NOW
0
true
)
;
assert
!
(
tracker
.
ack_time
(
*
NOW
-
Duration
:
:
from_millis
(
1
)
)
.
is_some
(
)
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
builder
.
set_limit
(
10
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
tracker
.
write_frame
(
PNSpace
:
:
Initial
*
NOW
&
mut
builder
&
mut
Vec
:
:
new
(
)
&
mut
stats
)
.
unwrap
(
)
;
assert_eq
!
(
stats
.
ack
0
)
;
assert_eq
!
(
builder
.
len
(
)
1
)
;
}
#
[
test
]
fn
no_room_for_extra_range
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
unwrap
(
)
.
set_received
(
*
NOW
0
true
)
;
tracker
.
get_mut
(
PNSpace
:
:
Initial
)
.
unwrap
(
)
.
set_received
(
*
NOW
2
true
)
;
assert
!
(
tracker
.
ack_time
(
*
NOW
-
Duration
:
:
from_millis
(
1
)
)
.
is_some
(
)
)
;
let
mut
builder
=
PacketBuilder
:
:
short
(
Encoder
:
:
new
(
)
false
&
[
]
)
;
builder
.
set_limit
(
32
)
;
let
mut
stats
=
FrameStats
:
:
default
(
)
;
tracker
.
write_frame
(
PNSpace
:
:
Initial
*
NOW
&
mut
builder
&
mut
Vec
:
:
new
(
)
&
mut
stats
)
.
unwrap
(
)
;
assert_eq
!
(
stats
.
ack
1
)
;
let
mut
dec
=
builder
.
as_decoder
(
)
;
let
_
=
dec
.
decode_byte
(
)
.
unwrap
(
)
;
let
frame
=
Frame
:
:
decode
(
&
mut
dec
)
.
unwrap
(
)
;
if
let
Frame
:
:
Ack
{
ack_ranges
.
.
}
=
frame
{
assert_eq
!
(
ack_ranges
.
len
(
)
0
)
;
}
else
{
panic
!
(
"
not
an
ACK
!
"
)
;
}
}
#
[
test
]
fn
ack_time_elapsed
(
)
{
let
mut
tracker
=
AckTracker
:
:
default
(
)
;
tracker
.
get_mut
(
PNSpace
:
:
ApplicationData
)
.
unwrap
(
)
.
set_received
(
*
NOW
3
true
)
;
assert
!
(
tracker
.
ack_time
(
*
NOW
+
Duration
:
:
from_millis
(
1
)
)
.
is_none
(
)
)
;
tracker
.
drop_space
(
PNSpace
:
:
Initial
)
;
tracker
.
drop_space
(
PNSpace
:
:
Handshake
)
;
assert_eq
!
(
tracker
.
ack_time
(
*
NOW
+
Duration
:
:
from_millis
(
1
)
)
Some
(
*
NOW
)
)
;
}
#
[
test
]
fn
pnspaceset_default
(
)
{
let
set
=
PNSpaceSet
:
:
default
(
)
;
assert
!
(
!
set
[
PNSpace
:
:
Initial
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
Handshake
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
ApplicationData
]
)
;
}
#
[
test
]
fn
pnspaceset_from
(
)
{
let
set
=
PNSpaceSet
:
:
from
(
&
[
PNSpace
:
:
Initial
]
)
;
assert
!
(
set
[
PNSpace
:
:
Initial
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
Handshake
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
ApplicationData
]
)
;
let
set
=
PNSpaceSet
:
:
from
(
&
[
PNSpace
:
:
Handshake
PNSpace
:
:
Initial
]
)
;
assert
!
(
set
[
PNSpace
:
:
Initial
]
)
;
assert
!
(
set
[
PNSpace
:
:
Handshake
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
ApplicationData
]
)
;
let
set
=
PNSpaceSet
:
:
from
(
&
[
PNSpace
:
:
ApplicationData
PNSpace
:
:
ApplicationData
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
Initial
]
)
;
assert
!
(
!
set
[
PNSpace
:
:
Handshake
]
)
;
assert
!
(
set
[
PNSpace
:
:
ApplicationData
]
)
;
}
#
[
test
]
fn
pnspaceset_copy
(
)
{
let
set
=
PNSpaceSet
:
:
from
(
&
[
PNSpace
:
:
Handshake
PNSpace
:
:
ApplicationData
]
)
;
let
copy
=
set
;
assert
!
(
!
copy
[
PNSpace
:
:
Initial
]
)
;
assert
!
(
copy
[
PNSpace
:
:
Handshake
]
)
;
assert
!
(
copy
[
PNSpace
:
:
ApplicationData
]
)
;
}
}
