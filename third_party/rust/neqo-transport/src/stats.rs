use
std
:
:
{
cell
:
:
RefCell
fmt
:
:
{
self
Debug
}
ops
:
:
{
Deref
DerefMut
}
rc
:
:
Rc
time
:
:
Duration
}
;
use
enum_map
:
:
EnumMap
;
use
neqo_common
:
:
{
qwarn
Dscp
Ecn
}
;
use
strum
:
:
IntoEnumIterator
as
_
;
use
crate
:
:
{
ecn
packet
}
;
pub
const
MAX_PTO_COUNTS
:
usize
=
16
;
#
[
derive
(
Default
Clone
PartialEq
Eq
)
]
pub
struct
FrameStats
{
pub
ack
:
usize
pub
largest_acknowledged
:
packet
:
:
Number
pub
crypto
:
usize
pub
stream
:
usize
pub
reset_stream
:
usize
pub
stop_sending
:
usize
pub
ping
:
usize
pub
padding
:
usize
pub
max_streams
:
usize
pub
streams_blocked
:
usize
pub
max_data
:
usize
pub
data_blocked
:
usize
pub
max_stream_data
:
usize
pub
stream_data_blocked
:
usize
pub
new_connection_id
:
usize
pub
retire_connection_id
:
usize
pub
path_challenge
:
usize
pub
path_response
:
usize
pub
connection_close
:
usize
pub
handshake_done
:
usize
pub
new_token
:
usize
pub
ack_frequency
:
usize
pub
datagram
:
usize
}
impl
Debug
for
FrameStats
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
crypto
{
}
done
{
}
token
{
}
close
{
}
"
self
.
crypto
self
.
handshake_done
self
.
new_token
self
.
connection_close
)
?
;
writeln
!
(
f
"
ack
{
}
(
max
{
}
)
ping
{
}
padding
{
}
"
self
.
ack
self
.
largest_acknowledged
self
.
ping
self
.
padding
)
?
;
writeln
!
(
f
"
stream
{
}
reset
{
}
stop
{
}
"
self
.
stream
self
.
reset_stream
self
.
stop_sending
)
?
;
writeln
!
(
f
"
max
:
stream
{
}
data
{
}
stream_data
{
}
"
self
.
max_streams
self
.
max_data
self
.
max_stream_data
)
?
;
writeln
!
(
f
"
blocked
:
stream
{
}
data
{
}
stream_data
{
}
"
self
.
streams_blocked
self
.
data_blocked
self
.
stream_data_blocked
)
?
;
writeln
!
(
f
"
datagram
{
}
"
self
.
datagram
)
?
;
writeln
!
(
f
"
ncid
{
}
rcid
{
}
pchallenge
{
}
presponse
{
}
"
self
.
new_connection_id
self
.
retire_connection_id
self
.
path_challenge
self
.
path_response
)
?
;
writeln
!
(
f
"
ack_frequency
{
}
"
self
.
ack_frequency
)
}
}
#
[
cfg
(
test
)
]
impl
FrameStats
{
pub
const
fn
all
(
&
self
)
-
>
usize
{
self
.
ack
+
self
.
crypto
+
self
.
stream
+
self
.
reset_stream
+
self
.
stop_sending
+
self
.
ping
+
self
.
padding
+
self
.
max_streams
+
self
.
streams_blocked
+
self
.
max_data
+
self
.
data_blocked
+
self
.
max_stream_data
+
self
.
stream_data_blocked
+
self
.
new_connection_id
+
self
.
retire_connection_id
+
self
.
path_challenge
+
self
.
path_response
+
self
.
connection_close
+
self
.
handshake_done
+
self
.
new_token
+
self
.
ack_frequency
+
self
.
datagram
}
}
#
[
derive
(
Default
Clone
PartialEq
Eq
)
]
pub
struct
DatagramStats
{
pub
lost
:
usize
pub
dropped_too_big
:
usize
pub
dropped_queue_full
:
usize
}
#
[
derive
(
Default
Clone
PartialEq
Eq
)
]
pub
struct
EcnCount
(
EnumMap
<
packet
:
:
Type
ecn
:
:
Count
>
)
;
impl
Debug
for
EcnCount
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
for
(
pt
count
)
in
self
.
0
{
if
count
.
is_empty
(
)
{
continue
;
}
writeln
!
(
f
"
{
pt
:
?
}
{
count
:
?
}
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
Deref
for
EcnCount
{
type
Target
=
EnumMap
<
packet
:
:
Type
ecn
:
:
Count
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
EcnCount
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
derive
(
Default
Clone
PartialEq
Eq
)
]
pub
struct
EcnTransitions
(
EnumMap
<
Ecn
EnumMap
<
Ecn
Option
<
(
packet
:
:
Type
packet
:
:
Number
)
>
>
>
)
;
impl
Deref
for
EcnTransitions
{
type
Target
=
EnumMap
<
Ecn
EnumMap
<
Ecn
Option
<
(
packet
:
:
Type
packet
:
:
Number
)
>
>
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
EcnTransitions
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
Debug
for
EcnTransitions
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
for
from
in
Ecn
:
:
iter
(
)
{
if
self
.
0
[
from
]
.
iter
(
)
.
all
(
|
(
_
v
)
|
v
.
is_none
(
)
)
{
continue
;
}
write
!
(
f
"
First
{
from
:
?
}
"
)
?
;
for
to
in
Ecn
:
:
iter
(
)
{
if
let
Some
(
pkt
)
=
self
.
0
[
from
]
[
to
]
{
write
!
(
f
"
to
{
to
:
?
}
{
pkt
:
?
}
"
)
?
;
}
}
writeln
!
(
f
)
?
;
}
Ok
(
(
)
)
}
}
#
[
derive
(
Default
Clone
PartialEq
Eq
)
]
pub
struct
DscpCount
(
EnumMap
<
Dscp
usize
>
)
;
impl
Debug
for
DscpCount
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
for
(
dscp
count
)
in
self
.
0
{
if
count
=
=
0
{
continue
;
}
write
!
(
f
"
{
dscp
:
?
}
:
{
count
}
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
Deref
for
DscpCount
{
type
Target
=
EnumMap
<
Dscp
usize
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
DscpCount
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
derive
(
Default
Clone
PartialEq
Eq
)
]
pub
struct
Stats
{
pub
info
:
String
pub
packets_rx
:
usize
pub
dups_rx
:
usize
pub
dropped_rx
:
usize
pub
saved_datagrams
:
usize
pub
packets_tx
:
usize
pub
lost
:
usize
pub
late_ack
:
usize
pub
pto_ack
:
usize
pub
unacked_range_dropped
:
usize
pub
pmtud_tx
:
usize
pub
pmtud_ack
:
usize
pub
pmtud_lost
:
usize
pub
pmtud_change
:
usize
pub
pmtud_iface_mtu
:
usize
pub
pmtud_pmtu
:
usize
pub
resumed
:
bool
pub
rtt
:
Duration
pub
rttvar
:
Duration
pub
rtt_init_guess
:
bool
pub
pto_counts
:
[
usize
;
MAX_PTO_COUNTS
]
pub
frame_rx
:
FrameStats
pub
frame_tx
:
FrameStats
pub
incoming_datagram_dropped
:
usize
pub
datagram_tx
:
DatagramStats
pub
ecn_path_validation
:
ecn
:
:
ValidationCount
pub
ecn_tx
:
EcnCount
pub
ecn_tx_acked
:
EcnCount
pub
ecn_rx
:
EcnCount
pub
ecn_last_mark
:
Option
<
Ecn
>
pub
ecn_rx_transition
:
EcnTransitions
pub
dscp_rx
:
DscpCount
}
impl
Stats
{
pub
fn
init
(
&
mut
self
info
:
String
)
{
self
.
info
=
info
;
}
pub
fn
pkt_dropped
<
A
:
AsRef
<
str
>
>
(
&
mut
self
reason
:
A
)
{
self
.
dropped_rx
+
=
1
;
qwarn
!
(
"
[
{
}
]
Dropped
received
packet
:
{
}
;
Total
:
{
}
"
self
.
info
reason
.
as_ref
(
)
self
.
dropped_rx
)
;
}
pub
fn
add_pto_count
(
&
mut
self
count
:
usize
)
{
debug_assert
!
(
count
>
0
)
;
if
count
>
=
MAX_PTO_COUNTS
{
return
;
}
self
.
pto_counts
[
count
-
1
]
+
=
1
;
if
count
>
1
{
debug_assert
!
(
self
.
pto_counts
[
count
-
2
]
>
0
)
;
self
.
pto_counts
[
count
-
2
]
-
=
1
;
}
}
}
impl
Debug
for
Stats
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
stats
for
{
}
"
self
.
info
)
?
;
writeln
!
(
f
"
rx
:
{
}
drop
{
}
dup
{
}
saved
{
}
"
self
.
packets_rx
self
.
dropped_rx
self
.
dups_rx
self
.
saved_datagrams
)
?
;
writeln
!
(
f
"
tx
:
{
}
lost
{
}
lateack
{
}
ptoack
{
}
unackdrop
{
}
"
self
.
packets_tx
self
.
lost
self
.
late_ack
self
.
pto_ack
self
.
unacked_range_dropped
)
?
;
writeln
!
(
f
"
pmtud
:
{
}
sent
{
}
acked
{
}
lost
{
}
change
{
}
iface_mtu
{
}
pmtu
"
self
.
pmtud_tx
self
.
pmtud_ack
self
.
pmtud_lost
self
.
pmtud_change
self
.
pmtud_iface_mtu
self
.
pmtud_pmtu
)
?
;
writeln
!
(
f
"
resumed
:
{
}
"
self
.
resumed
)
?
;
writeln
!
(
f
"
frames
rx
:
"
)
?
;
self
.
frame_rx
.
fmt
(
f
)
?
;
writeln
!
(
f
"
frames
tx
:
"
)
?
;
self
.
frame_tx
.
fmt
(
f
)
?
;
writeln
!
(
f
"
ecn
:
\
n
tx
:
"
)
?
;
self
.
ecn_tx
.
fmt
(
f
)
?
;
writeln
!
(
f
"
acked
:
"
)
?
;
self
.
ecn_tx_acked
.
fmt
(
f
)
?
;
writeln
!
(
f
"
rx
:
"
)
?
;
self
.
ecn_rx
.
fmt
(
f
)
?
;
writeln
!
(
f
"
path
validation
outcomes
:
{
:
?
}
"
self
.
ecn_path_validation
)
?
;
writeln
!
(
f
"
mark
transitions
:
"
)
?
;
self
.
ecn_rx_transition
.
fmt
(
f
)
?
;
writeln
!
(
f
"
dscp
:
{
:
?
}
"
self
.
dscp_rx
)
}
}
#
[
derive
(
Default
Clone
)
]
pub
struct
StatsCell
{
stats
:
Rc
<
RefCell
<
Stats
>
>
}
impl
Deref
for
StatsCell
{
type
Target
=
RefCell
<
Stats
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
stats
}
}
impl
Debug
for
StatsCell
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
stats
.
borrow
(
)
.
fmt
(
f
)
}
}
