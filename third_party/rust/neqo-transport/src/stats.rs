use
std
:
:
{
cell
:
:
RefCell
fmt
:
:
{
self
Debug
}
ops
:
:
Deref
rc
:
:
Rc
time
:
:
Duration
}
;
use
neqo_common
:
:
qwarn
;
use
crate
:
:
{
ecn
:
:
EcnCount
packet
:
:
PacketNumber
}
;
pub
const
MAX_PTO_COUNTS
:
usize
=
16
;
#
[
derive
(
Default
Clone
)
]
#
[
cfg_attr
(
test
derive
(
PartialEq
Eq
)
)
]
#
[
allow
(
clippy
:
:
module_name_repetitions
)
]
pub
struct
FrameStats
{
pub
all
:
usize
pub
ack
:
usize
pub
largest_acknowledged
:
PacketNumber
pub
crypto
:
usize
pub
stream
:
usize
pub
reset_stream
:
usize
pub
stop_sending
:
usize
pub
ping
:
usize
pub
padding
:
usize
pub
max_streams
:
usize
pub
streams_blocked
:
usize
pub
max_data
:
usize
pub
data_blocked
:
usize
pub
max_stream_data
:
usize
pub
stream_data_blocked
:
usize
pub
new_connection_id
:
usize
pub
retire_connection_id
:
usize
pub
path_challenge
:
usize
pub
path_response
:
usize
pub
connection_close
:
usize
pub
handshake_done
:
usize
pub
new_token
:
usize
pub
ack_frequency
:
usize
pub
datagram
:
usize
}
impl
Debug
for
FrameStats
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
crypto
{
}
done
{
}
token
{
}
close
{
}
"
self
.
crypto
self
.
handshake_done
self
.
new_token
self
.
connection_close
)
?
;
writeln
!
(
f
"
ack
{
}
(
max
{
}
)
ping
{
}
padding
{
}
"
self
.
ack
self
.
largest_acknowledged
self
.
ping
self
.
padding
)
?
;
writeln
!
(
f
"
stream
{
}
reset
{
}
stop
{
}
"
self
.
stream
self
.
reset_stream
self
.
stop_sending
)
?
;
writeln
!
(
f
"
max
:
stream
{
}
data
{
}
stream_data
{
}
"
self
.
max_streams
self
.
max_data
self
.
max_stream_data
)
?
;
writeln
!
(
f
"
blocked
:
stream
{
}
data
{
}
stream_data
{
}
"
self
.
streams_blocked
self
.
data_blocked
self
.
stream_data_blocked
)
?
;
writeln
!
(
f
"
datagram
{
}
"
self
.
datagram
)
?
;
writeln
!
(
f
"
ncid
{
}
rcid
{
}
pchallenge
{
}
presponse
{
}
"
self
.
new_connection_id
self
.
retire_connection_id
self
.
path_challenge
self
.
path_response
)
?
;
writeln
!
(
f
"
ack_frequency
{
}
"
self
.
ack_frequency
)
}
}
#
[
derive
(
Default
Clone
)
]
#
[
allow
(
clippy
:
:
module_name_repetitions
)
]
pub
struct
DatagramStats
{
pub
lost
:
usize
pub
dropped_too_big
:
usize
pub
dropped_queue_full
:
usize
}
#
[
derive
(
Default
Clone
)
]
pub
struct
Stats
{
info
:
String
pub
packets_rx
:
usize
pub
dups_rx
:
usize
pub
dropped_rx
:
usize
pub
saved_datagrams
:
usize
pub
packets_tx
:
usize
pub
lost
:
usize
pub
late_ack
:
usize
pub
pto_ack
:
usize
pub
pmtud_tx
:
usize
pub
pmtud_ack
:
usize
pub
pmtud_lost
:
usize
pub
pmtud_change
:
usize
pub
resumed
:
bool
pub
rtt
:
Duration
pub
rttvar
:
Duration
pub
rtt_init_guess
:
bool
pub
pto_counts
:
[
usize
;
MAX_PTO_COUNTS
]
pub
frame_rx
:
FrameStats
pub
frame_tx
:
FrameStats
pub
incoming_datagram_dropped
:
usize
pub
datagram_tx
:
DatagramStats
pub
ecn_paths_capable
:
usize
pub
ecn_paths_not_capable
:
usize
pub
ecn_tx
:
EcnCount
pub
ecn_rx
:
EcnCount
}
impl
Stats
{
pub
fn
init
(
&
mut
self
info
:
String
)
{
self
.
info
=
info
;
}
pub
fn
pkt_dropped
(
&
mut
self
reason
:
impl
AsRef
<
str
>
)
{
self
.
dropped_rx
+
=
1
;
qwarn
!
(
[
self
.
info
]
"
Dropped
received
packet
:
{
}
;
Total
:
{
}
"
reason
.
as_ref
(
)
self
.
dropped_rx
)
;
}
pub
fn
add_pto_count
(
&
mut
self
count
:
usize
)
{
debug_assert
!
(
count
>
0
)
;
if
count
>
=
MAX_PTO_COUNTS
{
return
;
}
self
.
pto_counts
[
count
-
1
]
+
=
1
;
if
count
>
1
{
debug_assert
!
(
self
.
pto_counts
[
count
-
2
]
>
0
)
;
self
.
pto_counts
[
count
-
2
]
-
=
1
;
}
}
}
impl
Debug
for
Stats
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
stats
for
{
}
"
self
.
info
)
?
;
writeln
!
(
f
"
rx
:
{
}
drop
{
}
dup
{
}
saved
{
}
"
self
.
packets_rx
self
.
dropped_rx
self
.
dups_rx
self
.
saved_datagrams
)
?
;
writeln
!
(
f
"
tx
:
{
}
lost
{
}
lateack
{
}
ptoack
{
}
"
self
.
packets_tx
self
.
lost
self
.
late_ack
self
.
pto_ack
)
?
;
writeln
!
(
f
"
pmtud
:
{
}
sent
{
}
acked
{
}
lost
{
}
change
"
self
.
pmtud_tx
self
.
pmtud_ack
self
.
pmtud_lost
self
.
pmtud_change
)
?
;
writeln
!
(
f
"
resumed
:
{
}
"
self
.
resumed
)
?
;
writeln
!
(
f
"
frames
rx
:
"
)
?
;
self
.
frame_rx
.
fmt
(
f
)
?
;
writeln
!
(
f
"
frames
tx
:
"
)
?
;
self
.
frame_tx
.
fmt
(
f
)
?
;
writeln
!
(
f
"
ecn
:
{
:
?
}
for
tx
{
:
?
}
for
rx
{
}
capable
paths
{
}
not
capable
paths
"
self
.
ecn_tx
self
.
ecn_rx
self
.
ecn_paths_capable
self
.
ecn_paths_not_capable
)
}
}
#
[
derive
(
Default
Clone
)
]
#
[
allow
(
clippy
:
:
module_name_repetitions
)
]
pub
struct
StatsCell
{
stats
:
Rc
<
RefCell
<
Stats
>
>
}
impl
Deref
for
StatsCell
{
type
Target
=
RefCell
<
Stats
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
stats
}
}
impl
Debug
for
StatsCell
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
stats
.
borrow
(
)
.
fmt
(
f
)
}
}
