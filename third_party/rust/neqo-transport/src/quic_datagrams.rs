use
std
:
:
{
cmp
:
:
min
collections
:
:
VecDeque
}
;
use
neqo_common
:
:
{
qdebug
Buffer
Encoder
}
;
use
crate
:
:
{
events
:
:
OutgoingDatagramOutcome
frame
:
:
FrameType
packet
recovery
ConnectionEvents
Error
Res
Stats
}
;
pub
const
MAX_QUIC_DATAGRAM
:
u64
=
65535
;
pub
const
DATAGRAM_FRAME_TYPE_VARINT_LEN
:
usize
=
1
;
static_assertions
:
:
const_assert_eq
!
(
Encoder
:
:
varint_len
(
FrameType
:
:
Datagram
as
u64
)
DATAGRAM_FRAME_TYPE_VARINT_LEN
)
;
static_assertions
:
:
const_assert_eq
!
(
Encoder
:
:
varint_len
(
FrameType
:
:
DatagramWithLen
as
u64
)
DATAGRAM_FRAME_TYPE_VARINT_LEN
)
;
#
[
derive
(
Debug
Clone
Copy
)
]
pub
enum
DatagramTracking
{
None
Id
(
u64
)
}
impl
From
<
Option
<
u64
>
>
for
DatagramTracking
{
fn
from
(
v
:
Option
<
u64
>
)
-
>
Self
{
v
.
map_or
(
Self
:
:
None
Self
:
:
Id
)
}
}
struct
QuicDatagram
{
data
:
Vec
<
u8
>
tracking
:
DatagramTracking
}
impl
QuicDatagram
{
const
fn
tracking
(
&
self
)
-
>
&
DatagramTracking
{
&
self
.
tracking
}
}
impl
AsRef
<
[
u8
]
>
for
QuicDatagram
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
data
[
.
.
]
}
}
pub
struct
QuicDatagrams
{
local_datagram_size
:
u64
remote_datagram_size
:
u64
max_queued_outgoing_datagrams
:
usize
max_queued_incoming_datagrams
:
usize
datagrams
:
VecDeque
<
QuicDatagram
>
conn_events
:
ConnectionEvents
}
impl
QuicDatagrams
{
pub
fn
new
(
local_datagram_size
:
u64
max_queued_outgoing_datagrams
:
usize
max_queued_incoming_datagrams
:
usize
conn_events
:
ConnectionEvents
)
-
>
Self
{
Self
{
local_datagram_size
remote_datagram_size
:
0
max_queued_outgoing_datagrams
max_queued_incoming_datagrams
datagrams
:
VecDeque
:
:
with_capacity
(
max_queued_outgoing_datagrams
)
conn_events
}
}
pub
const
fn
remote_datagram_size
(
&
self
)
-
>
u64
{
self
.
remote_datagram_size
}
pub
fn
set_remote_datagram_size
(
&
mut
self
v
:
u64
)
{
self
.
remote_datagram_size
=
min
(
v
MAX_QUIC_DATAGRAM
)
;
}
pub
fn
write_frames
<
B
:
Buffer
>
(
&
mut
self
builder
:
&
mut
packet
:
:
Builder
<
B
>
tokens
:
&
mut
recovery
:
:
Tokens
stats
:
&
mut
Stats
)
{
while
let
Some
(
dgram
)
=
self
.
datagrams
.
pop_front
(
)
{
let
len
=
dgram
.
as_ref
(
)
.
len
(
)
;
if
len
+
DATAGRAM_FRAME_TYPE_VARINT_LEN
<
=
builder
.
remaining
(
)
{
let
length_len
=
Encoder
:
:
varint_len
(
u64
:
:
try_from
(
len
)
.
expect
(
"
usize
fits
in
u64
"
)
)
;
if
builder
.
remaining
(
)
>
=
DATAGRAM_FRAME_TYPE_VARINT_LEN
+
length_len
+
len
+
packet
:
:
Builder
:
:
MINIMUM_FRAME_SIZE
{
builder
.
encode_varint
(
FrameType
:
:
DatagramWithLen
)
;
builder
.
encode_vvec
(
dgram
.
as_ref
(
)
)
;
}
else
{
builder
.
encode_varint
(
FrameType
:
:
Datagram
)
;
builder
.
encode
(
dgram
.
as_ref
(
)
)
;
builder
.
mark_full
(
)
;
}
debug_assert
!
(
builder
.
len
(
)
<
=
builder
.
limit
(
)
)
;
stats
.
frame_tx
.
datagram
+
=
1
;
tokens
.
push
(
recovery
:
:
Token
:
:
Datagram
(
*
dgram
.
tracking
(
)
)
)
;
}
else
if
tokens
.
is_empty
(
)
{
qdebug
!
(
"
QUIC
datagram
(
{
}
)
does
not
fit
MTU
.
"
dgram
.
data
.
len
(
)
)
;
self
.
conn_events
.
datagram_outcome
(
dgram
.
tracking
(
)
OutgoingDatagramOutcome
:
:
DroppedTooBig
)
;
stats
.
datagram_tx
.
dropped_too_big
+
=
1
;
}
else
{
self
.
datagrams
.
push_front
(
dgram
)
;
return
;
}
}
}
pub
fn
add_datagram
(
&
mut
self
data
:
Vec
<
u8
>
tracking
:
DatagramTracking
stats
:
&
mut
Stats
)
-
>
Res
<
(
)
>
{
if
u64
:
:
try_from
(
data
.
len
(
)
)
?
>
self
.
remote_datagram_size
{
qdebug
!
(
"
QUIC
datagram
exceeds
remote
limit
dropping
it
datagram
size
{
}
remote
datagram
size
limit
{
}
.
"
data
.
len
(
)
self
.
remote_datagram_size
)
;
return
Err
(
Error
:
:
TooMuchData
)
;
}
if
self
.
datagrams
.
len
(
)
=
=
self
.
max_queued_outgoing_datagrams
{
qdebug
!
(
"
QUIC
datagram
queue
full
dropping
first
datagram
in
queue
(
head
-
drop
)
.
"
)
;
self
.
conn_events
.
datagram_outcome
(
self
.
datagrams
.
pop_front
(
)
.
ok_or
(
Error
:
:
Internal
)
?
.
tracking
(
)
OutgoingDatagramOutcome
:
:
DroppedQueueFull
)
;
stats
.
datagram_tx
.
dropped_queue_full
+
=
1
;
}
self
.
datagrams
.
push_back
(
QuicDatagram
{
data
tracking
}
)
;
Ok
(
(
)
)
}
pub
fn
handle_datagram
(
&
self
data
:
&
[
u8
]
stats
:
&
mut
Stats
)
-
>
Res
<
(
)
>
{
if
self
.
local_datagram_size
<
u64
:
:
try_from
(
data
.
len
(
)
)
?
{
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
self
.
conn_events
.
add_datagram
(
self
.
max_queued_incoming_datagrams
data
stats
)
;
Ok
(
(
)
)
}
}
