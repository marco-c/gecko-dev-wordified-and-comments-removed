use
std
:
:
{
cmp
:
:
min
collections
:
:
VecDeque
}
;
use
neqo_common
:
:
Encoder
;
use
crate
:
:
{
events
:
:
OutgoingDatagramOutcome
frame
:
:
{
FRAME_TYPE_DATAGRAM
FRAME_TYPE_DATAGRAM_WITH_LEN
}
packet
:
:
PacketBuilder
recovery
:
:
RecoveryToken
ConnectionEvents
Error
Res
Stats
}
;
pub
const
MAX_QUIC_DATAGRAM
:
u64
=
65535
;
#
[
derive
(
Debug
Clone
Copy
)
]
pub
enum
DatagramTracking
{
None
Id
(
u64
)
}
impl
From
<
Option
<
u64
>
>
for
DatagramTracking
{
fn
from
(
v
:
Option
<
u64
>
)
-
>
Self
{
match
v
{
Some
(
id
)
=
>
Self
:
:
Id
(
id
)
None
=
>
Self
:
:
None
}
}
}
impl
From
<
DatagramTracking
>
for
Option
<
u64
>
{
fn
from
(
v
:
DatagramTracking
)
-
>
Self
{
match
v
{
DatagramTracking
:
:
Id
(
id
)
=
>
Some
(
id
)
DatagramTracking
:
:
None
=
>
None
}
}
}
struct
QuicDatagram
{
data
:
Vec
<
u8
>
tracking
:
DatagramTracking
}
impl
QuicDatagram
{
fn
tracking
(
&
self
)
-
>
&
DatagramTracking
{
&
self
.
tracking
}
}
impl
AsRef
<
[
u8
]
>
for
QuicDatagram
{
#
[
must_use
]
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
data
[
.
.
]
}
}
pub
struct
QuicDatagrams
{
local_datagram_size
:
u64
remote_datagram_size
:
u64
max_queued_outgoing_datagrams
:
usize
max_queued_incoming_datagrams
:
usize
datagrams
:
VecDeque
<
QuicDatagram
>
conn_events
:
ConnectionEvents
}
impl
QuicDatagrams
{
pub
fn
new
(
local_datagram_size
:
u64
max_queued_outgoing_datagrams
:
usize
max_queued_incoming_datagrams
:
usize
conn_events
:
ConnectionEvents
)
-
>
Self
{
Self
{
local_datagram_size
remote_datagram_size
:
0
max_queued_outgoing_datagrams
max_queued_incoming_datagrams
datagrams
:
VecDeque
:
:
with_capacity
(
max_queued_outgoing_datagrams
)
conn_events
}
}
pub
fn
remote_datagram_size
(
&
self
)
-
>
u64
{
self
.
remote_datagram_size
}
pub
fn
set_remote_datagram_size
(
&
mut
self
v
:
u64
)
{
self
.
remote_datagram_size
=
min
(
v
MAX_QUIC_DATAGRAM
)
;
}
pub
fn
write_frames
(
&
mut
self
builder
:
&
mut
PacketBuilder
tokens
:
&
mut
Vec
<
RecoveryToken
>
stats
:
&
mut
Stats
)
{
while
let
Some
(
dgram
)
=
self
.
datagrams
.
pop_front
(
)
{
let
len
=
dgram
.
as_ref
(
)
.
len
(
)
;
if
builder
.
remaining
(
)
>
len
{
let
length_len
=
Encoder
:
:
varint_len
(
u64
:
:
try_from
(
len
)
.
unwrap
(
)
)
;
if
builder
.
remaining
(
)
>
=
1
+
length_len
+
len
+
PacketBuilder
:
:
MINIMUM_FRAME_SIZE
{
builder
.
encode_varint
(
FRAME_TYPE_DATAGRAM_WITH_LEN
)
;
builder
.
encode_vvec
(
dgram
.
as_ref
(
)
)
;
}
else
{
builder
.
encode_varint
(
FRAME_TYPE_DATAGRAM
)
;
builder
.
encode
(
dgram
.
as_ref
(
)
)
;
builder
.
mark_full
(
)
;
}
debug_assert
!
(
builder
.
len
(
)
<
=
builder
.
limit
(
)
)
;
stats
.
frame_tx
.
datagram
+
=
1
;
tokens
.
push
(
RecoveryToken
:
:
Datagram
(
*
dgram
.
tracking
(
)
)
)
;
}
else
if
tokens
.
is_empty
(
)
{
self
.
conn_events
.
datagram_outcome
(
dgram
.
tracking
(
)
OutgoingDatagramOutcome
:
:
DroppedTooBig
)
;
stats
.
datagram_tx
.
dropped_too_big
+
=
1
;
}
else
{
self
.
datagrams
.
push_front
(
dgram
)
;
return
;
}
}
}
pub
fn
add_datagram
(
&
mut
self
buf
:
&
[
u8
]
tracking
:
DatagramTracking
stats
:
&
mut
Stats
)
-
>
Res
<
(
)
>
{
if
u64
:
:
try_from
(
buf
.
len
(
)
)
.
unwrap
(
)
>
self
.
remote_datagram_size
{
return
Err
(
Error
:
:
TooMuchData
)
;
}
if
self
.
datagrams
.
len
(
)
=
=
self
.
max_queued_outgoing_datagrams
{
self
.
conn_events
.
datagram_outcome
(
self
.
datagrams
.
pop_front
(
)
.
unwrap
(
)
.
tracking
(
)
OutgoingDatagramOutcome
:
:
DroppedQueueFull
)
;
stats
.
datagram_tx
.
dropped_queue_full
+
=
1
;
}
self
.
datagrams
.
push_back
(
QuicDatagram
{
data
:
buf
.
to_vec
(
)
tracking
}
)
;
Ok
(
(
)
)
}
pub
fn
handle_datagram
(
&
self
data
:
&
[
u8
]
stats
:
&
mut
Stats
)
-
>
Res
<
(
)
>
{
if
self
.
local_datagram_size
<
u64
:
:
try_from
(
data
.
len
(
)
)
.
unwrap
(
)
{
return
Err
(
Error
:
:
ProtocolViolation
)
;
}
self
.
conn_events
.
add_datagram
(
self
.
max_queued_incoming_datagrams
data
stats
)
;
Ok
(
(
)
)
}
}
