use
std
:
:
{
iter
:
:
zip
net
:
:
IpAddr
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
{
qdebug
qinfo
Buffer
}
;
use
static_assertions
:
:
const_assert
;
use
crate
:
:
{
frame
:
:
{
FrameEncoder
as
_
FrameType
}
packet
recovery
:
:
sent
Stats
}
;
const
MTU_SIZES_V4
:
&
[
usize
]
=
&
[
1280
1380
1420
1472
1500
2047
4095
8191
16383
32767
65535
]
;
const
MTU_SIZES_V6
:
&
[
usize
]
=
&
[
1280
1380
1420
1470
1500
2047
4095
8191
16383
32767
65535
]
;
const_assert
!
(
MTU_SIZES_V4
.
len
(
)
=
=
MTU_SIZES_V6
.
len
(
)
)
;
const
SEARCH_TABLE_LEN
:
usize
=
MTU_SIZES_V4
.
len
(
)
;
const
MAX_PROBES
:
usize
=
3
;
const
PMTU_RAISE_TIMER
:
Duration
=
Duration
:
:
from_secs
(
600
)
;
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
enum
Probe
{
NotNeeded
Needed
Sent
}
#
[
derive
(
Debug
)
]
pub
struct
Pmtud
{
search_table
:
&
'
static
[
usize
]
header_size
:
usize
mtu
:
usize
iface_mtu
:
usize
probe_index
:
usize
probe_count
:
usize
probe_state
:
Probe
loss_counts
:
[
usize
;
SEARCH_TABLE_LEN
]
raise_timer
:
Option
<
Instant
>
}
impl
Pmtud
{
const
fn
search_table
(
remote_ip
:
IpAddr
)
-
>
&
'
static
[
usize
]
{
match
remote_ip
{
IpAddr
:
:
V4
(
_
)
=
>
MTU_SIZES_V4
IpAddr
:
:
V6
(
_
)
=
>
MTU_SIZES_V6
}
}
const
fn
header_size
(
remote_ip
:
IpAddr
)
-
>
usize
{
match
remote_ip
{
IpAddr
:
:
V4
(
_
)
=
>
20
+
8
IpAddr
:
:
V6
(
_
)
=
>
40
+
8
}
}
#
[
must_use
]
pub
fn
new
(
remote_ip
:
IpAddr
iface_mtu
:
Option
<
usize
>
)
-
>
Self
{
let
search_table
=
Self
:
:
search_table
(
remote_ip
)
;
let
probe_index
=
0
;
Self
{
search_table
header_size
:
Self
:
:
header_size
(
remote_ip
)
mtu
:
search_table
[
probe_index
]
iface_mtu
:
iface_mtu
.
unwrap_or
(
usize
:
:
MAX
)
probe_index
probe_count
:
0
probe_state
:
Probe
:
:
NotNeeded
loss_counts
:
[
0
;
SEARCH_TABLE_LEN
]
raise_timer
:
None
}
}
pub
fn
maybe_fire_raise_timer
(
&
mut
self
now
:
Instant
stats
:
&
mut
Stats
)
{
if
self
.
probe_state
=
=
Probe
:
:
NotNeeded
&
&
self
.
raise_timer
.
is_some_and
(
|
t
|
now
>
=
t
)
{
qdebug
!
(
"
PMTUD
raise
timer
fired
"
)
;
self
.
raise_timer
=
None
;
self
.
start
(
now
stats
)
;
}
}
#
[
must_use
]
pub
const
fn
plpmtu
(
&
self
)
-
>
usize
{
self
.
mtu
-
self
.
header_size
}
#
[
must_use
]
pub
fn
needs_probe
(
&
self
)
-
>
bool
{
self
.
probe_state
=
=
Probe
:
:
Needed
}
#
[
must_use
]
pub
const
fn
probe_size
(
&
self
)
-
>
usize
{
self
.
search_table
[
self
.
probe_index
]
-
self
.
header_size
}
pub
fn
send_probe
<
B
:
Buffer
>
(
&
mut
self
builder
:
&
mut
packet
:
:
Builder
<
B
>
stats
:
&
mut
Stats
)
{
builder
.
encode_frame
(
FrameType
:
:
Ping
|
_
|
{
}
)
;
stats
.
frame_tx
.
ping
+
=
1
;
stats
.
pmtud_tx
+
=
1
;
self
.
probe_count
+
=
1
;
self
.
probe_state
=
Probe
:
:
Sent
;
qdebug
!
(
"
Sending
PMTUD
probe
of
size
{
}
count
{
}
"
self
.
search_table
[
self
.
probe_index
]
self
.
probe_count
)
;
}
#
[
expect
(
rustdoc
:
:
private_intra_doc_links
reason
=
"
Nicer
docs
.
"
)
]
pub
fn
is_probe_filter
(
&
self
)
-
>
impl
Fn
(
&
sent
:
:
Packet
)
-
>
bool
{
let
probe_state
=
self
.
probe_state
;
let
probe_size
=
self
.
probe_size
(
)
;
move
|
p
:
&
sent
:
:
Packet
|
-
>
bool
{
probe_state
=
=
Probe
:
:
Sent
&
&
p
.
len
(
)
=
=
probe_size
}
}
#
[
expect
(
clippy
:
:
missing_panics_doc
reason
=
"
search
table
is
never
empty
"
)
]
#
[
must_use
]
pub
fn
address_family_max_mtu
(
&
self
)
-
>
usize
{
*
self
.
search_table
.
last
(
)
.
expect
(
"
search
table
is
empty
"
)
}
fn
is_probe
(
&
self
p
:
&
sent
:
:
Packet
)
-
>
bool
{
self
.
is_probe_filter
(
)
(
p
)
}
fn
count_probes
(
&
self
pkts
:
&
[
sent
:
:
Packet
]
)
-
>
usize
{
pkts
.
iter
(
)
.
filter
(
|
p
|
self
.
is_probe
(
p
)
)
.
count
(
)
}
pub
fn
on_packets_acked
(
&
mut
self
acked_pkts
:
&
[
sent
:
:
Packet
]
now
:
Instant
stats
:
&
mut
Stats
)
{
let
Some
(
max_len
)
=
acked_pkts
.
iter
(
)
.
map
(
sent
:
:
Packet
:
:
len
)
.
max
(
)
else
{
return
;
}
;
let
idx
=
self
.
search_table
.
iter
(
)
.
position
(
|
&
mtu
|
mtu
>
max_len
+
self
.
header_size
)
.
unwrap_or
(
SEARCH_TABLE_LEN
)
;
self
.
loss_counts
.
iter_mut
(
)
.
take
(
idx
)
.
for_each
(
|
c
|
*
c
=
0
)
;
let
acked
=
self
.
count_probes
(
acked_pkts
)
;
if
acked
=
=
0
{
return
;
}
stats
.
pmtud_ack
+
=
acked
;
self
.
mtu
=
self
.
search_table
[
self
.
probe_index
]
;
stats
.
pmtud_pmtu
=
self
.
mtu
;
qdebug
!
(
"
PMTUD
probe
of
size
{
}
succeeded
"
self
.
mtu
)
;
self
.
start
(
now
stats
)
;
}
fn
stop
(
&
mut
self
idx
:
usize
now
:
Instant
stats
:
&
mut
Stats
)
{
self
.
probe_state
=
Probe
:
:
NotNeeded
;
self
.
probe_index
=
idx
;
self
.
mtu
=
self
.
search_table
[
idx
]
;
stats
.
pmtud_pmtu
=
self
.
mtu
;
self
.
probe_count
=
0
;
self
.
loss_counts
.
fill
(
0
)
;
self
.
raise_timer
=
Some
(
now
+
PMTU_RAISE_TIMER
)
;
qinfo
!
(
"
PMTUD
stopped
PLPMTU
is
now
{
}
raise
timer
{
:
?
}
"
self
.
mtu
self
.
raise_timer
)
;
}
pub
fn
on_packets_lost
(
&
mut
self
lost_packets
:
&
[
sent
:
:
Packet
]
stats
:
&
mut
Stats
now
:
Instant
)
{
if
lost_packets
.
is_empty
(
)
{
return
;
}
let
mut
increase
=
[
0
;
SEARCH_TABLE_LEN
]
;
let
mut
loss_counts_updated
=
false
;
for
p
in
lost_packets
{
let
Some
(
idx
)
=
self
.
search_table
.
iter
(
)
.
position
(
|
&
mtu
|
p
.
len
(
)
+
self
.
header_size
<
=
mtu
)
else
{
continue
;
}
;
if
idx
>
0
&
&
(
increase
[
idx
]
=
=
0
|
|
p
.
len
(
)
>
self
.
plpmtu
(
)
)
{
loss_counts_updated
=
true
;
increase
[
idx
]
+
=
1
;
}
}
if
!
loss_counts_updated
{
return
;
}
let
mut
accum
=
0
;
for
(
c
incr
)
in
zip
(
&
mut
self
.
loss_counts
increase
)
{
accum
+
=
incr
;
*
c
+
=
accum
;
}
let
lost
=
self
.
count_probes
(
lost_packets
)
;
stats
.
pmtud_lost
+
=
lost
;
let
Some
(
first_failed
)
=
self
.
loss_counts
.
iter
(
)
.
position
(
|
&
c
|
c
>
=
MAX_PROBES
)
else
{
if
lost
>
0
{
self
.
probe_state
=
Probe
:
:
Needed
;
}
return
;
}
;
let
largest_ok_idx
=
first_failed
-
1
;
let
largest_ok_mtu
=
self
.
search_table
[
largest_ok_idx
]
;
qdebug
!
(
"
PMTUD
Packet
of
size
>
{
largest_ok_mtu
}
lost
>
=
{
MAX_PROBES
}
times
state
{
:
?
}
"
self
.
probe_state
)
;
if
largest_ok_mtu
<
self
.
mtu
{
self
.
reset
(
stats
)
;
qdebug
!
(
"
PMTUD
reset
and
restarting
PLPMTU
is
now
{
}
"
self
.
mtu
)
;
self
.
start
(
now
stats
)
;
}
else
{
self
.
stop
(
largest_ok_idx
now
stats
)
;
}
}
fn
reset
(
&
mut
self
stats
:
&
mut
Stats
)
{
self
.
probe_index
=
0
;
self
.
mtu
=
self
.
search_table
[
self
.
probe_index
]
;
stats
.
pmtud_pmtu
=
self
.
mtu
;
self
.
loss_counts
.
fill
(
0
)
;
self
.
raise_timer
=
None
;
stats
.
pmtud_change
+
=
1
;
}
pub
fn
start
(
&
mut
self
now
:
Instant
stats
:
&
mut
Stats
)
{
if
self
.
probe_index
=
=
SEARCH_TABLE_LEN
-
1
{
qdebug
!
(
"
PMTUD
reached
end
of
search
table
i
.
e
.
{
}
stopping
upwards
search
"
self
.
mtu
)
;
self
.
stop
(
self
.
probe_index
now
stats
)
;
return
;
}
if
self
.
search_table
[
self
.
probe_index
+
1
]
>
self
.
iface_mtu
{
qdebug
!
(
"
PMTUD
reached
interface
MTU
limit
{
}
stopping
upwards
search
at
{
}
"
self
.
iface_mtu
self
.
mtu
)
;
self
.
stop
(
self
.
probe_index
now
stats
)
;
return
;
}
self
.
probe_state
=
Probe
:
:
Needed
;
self
.
probe_count
=
0
;
self
.
probe_index
+
=
1
;
qdebug
!
(
"
PMTUD
started
with
probe
size
{
}
"
self
.
search_table
[
self
.
probe_index
]
)
;
}
#
[
must_use
]
pub
const
fn
default_plpmtu
(
remote_ip
:
IpAddr
)
-
>
usize
{
let
search_table
=
Self
:
:
search_table
(
remote_ip
)
;
search_table
[
0
]
-
Self
:
:
header_size
(
remote_ip
)
}
}
#
[
cfg
(
all
(
not
(
feature
=
"
disable
-
encryption
"
)
test
)
)
]
mod
tests
{
use
std
:
:
{
cmp
:
:
min
iter
:
:
zip
net
:
:
{
IpAddr
Ipv4Addr
Ipv6Addr
}
time
:
:
Instant
}
;
use
neqo_common
:
:
{
qdebug
qinfo
Encoder
}
;
use
test_fixture
:
:
{
fixture_init
now
}
;
use
crate
:
:
{
crypto
:
:
CryptoDxState
packet
pmtud
:
:
{
Probe
PMTU_RAISE_TIMER
SEARCH_TABLE_LEN
}
recovery
:
:
{
sent
SendProfile
}
Pmtud
Stats
}
;
const
V4
:
IpAddr
=
IpAddr
:
:
V4
(
Ipv4Addr
:
:
UNSPECIFIED
)
;
const
V6
:
IpAddr
=
IpAddr
:
:
V6
(
Ipv6Addr
:
:
UNSPECIFIED
)
;
const
IFACE_MTUS
:
&
[
Option
<
usize
>
]
=
&
[
None
Some
(
1300
)
Some
(
1500
)
Some
(
5000
)
Some
(
u16
:
:
MAX
as
usize
)
]
;
#
[
cfg
(
test
)
]
fn
assert_mtu
(
pmtud
:
&
Pmtud
mtu
:
usize
)
{
let
idx
=
pmtud
.
search_table
.
iter
(
)
.
position
(
|
mtu
|
*
mtu
=
=
pmtud
.
mtu
)
.
unwrap
(
)
;
assert
!
(
(
idx
=
=
0
&
&
mtu
<
=
pmtud
.
search_table
[
idx
]
)
|
|
(
mtu
>
=
pmtud
.
search_table
[
idx
]
)
)
;
if
idx
<
SEARCH_TABLE_LEN
-
1
{
assert
!
(
mtu
<
pmtud
.
search_table
[
idx
+
1
]
)
;
}
assert_eq
!
(
Probe
:
:
NotNeeded
pmtud
.
probe_state
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
}
#
[
cfg
(
test
)
]
fn
pmtud_step
(
pmtud
:
&
mut
Pmtud
stats
:
&
mut
Stats
prot
:
&
mut
CryptoDxState
addr
:
IpAddr
mtu
:
usize
now
:
Instant
)
{
const
AEAD_EXPANSION
:
usize
=
16
;
let
stats_before
=
stats
.
clone
(
)
;
let
profile
=
SendProfile
:
:
new_limited
(
pmtud
.
plpmtu
(
)
)
;
let
limit
=
if
pmtud
.
needs_probe
(
)
{
pmtud
.
probe_size
(
)
-
AEAD_EXPANSION
}
else
{
profile
.
limit
(
)
-
AEAD_EXPANSION
}
;
let
mut
builder
=
packet
:
:
Builder
:
:
short
(
Encoder
:
:
new
(
)
false
None
:
:
<
&
[
u8
]
>
limit
)
;
let
pn
=
prot
.
next_pn
(
)
;
builder
.
pn
(
pn
4
)
;
builder
.
enable_padding
(
true
)
;
pmtud
.
send_probe
(
&
mut
builder
stats
)
;
builder
.
pad
(
)
;
let
encoder
=
builder
.
build
(
prot
)
.
unwrap
(
)
;
assert_eq
!
(
encoder
.
len
(
)
pmtud
.
probe_size
(
)
)
;
assert
!
(
!
pmtud
.
needs_probe
(
)
)
;
assert_eq
!
(
stats_before
.
pmtud_tx
+
1
stats
.
pmtud_tx
)
;
let
packet
=
sent
:
:
make_packet
(
pn
now
encoder
.
len
(
)
)
;
if
encoder
.
len
(
)
+
Pmtud
:
:
header_size
(
addr
)
<
=
mtu
{
pmtud
.
on_packets_acked
(
&
[
packet
]
now
stats
)
;
assert_eq
!
(
stats_before
.
pmtud_ack
+
1
stats
.
pmtud_ack
)
;
}
else
{
pmtud
.
on_packets_lost
(
&
[
packet
]
stats
now
)
;
assert_eq
!
(
stats_before
.
pmtud_lost
+
1
stats
.
pmtud_lost
)
;
}
}
fn
find_pmtu
(
addr
:
IpAddr
mtu
:
usize
iface_mtu
:
Option
<
usize
>
)
-
>
(
Pmtud
Stats
CryptoDxState
Instant
)
{
fixture_init
(
)
;
let
now
=
now
(
)
;
let
mut
pmtud
=
Pmtud
:
:
new
(
addr
iface_mtu
)
;
let
mut
stats
=
Stats
:
:
default
(
)
;
let
mut
prot
=
CryptoDxState
:
:
test_default
(
)
;
pmtud
.
start
(
now
&
mut
stats
)
;
if
let
Some
(
iface_mtu
)
=
iface_mtu
{
assert
!
(
iface_mtu
<
=
pmtud
.
search_table
[
1
]
|
|
pmtud
.
needs_probe
(
)
)
;
}
else
{
assert
!
(
pmtud
.
needs_probe
(
)
)
;
}
while
pmtud
.
needs_probe
(
)
{
pmtud_step
(
&
mut
pmtud
&
mut
stats
&
mut
prot
addr
mtu
now
)
;
}
let
final_mtu
=
iface_mtu
.
map_or
(
mtu
|
iface_mtu
|
min
(
mtu
iface_mtu
)
)
;
assert_mtu
(
&
pmtud
final_mtu
)
;
(
pmtud
stats
prot
now
)
}
fn
find_pmtu_with_reduction
(
addr
:
IpAddr
mtu
:
usize
smaller_mtu
:
usize
)
{
assert
!
(
mtu
>
smaller_mtu
)
;
let
(
mut
pmtud
mut
stats
mut
prot
now
)
=
find_pmtu
(
addr
mtu
None
)
;
qdebug
!
(
"
Reducing
MTU
to
{
smaller_mtu
}
"
)
;
while
!
pmtud
.
needs_probe
(
)
{
pmtud_step
(
&
mut
pmtud
&
mut
stats
&
mut
prot
addr
smaller_mtu
now
)
;
}
while
pmtud
.
needs_probe
(
)
{
pmtud_step
(
&
mut
pmtud
&
mut
stats
&
mut
prot
addr
smaller_mtu
now
)
;
}
assert_mtu
(
&
pmtud
smaller_mtu
)
;
}
fn
find_pmtu_with_increase
(
addr
:
IpAddr
mtu
:
usize
larger_mtu
:
usize
)
{
assert
!
(
mtu
<
larger_mtu
)
;
let
(
mut
pmtud
mut
stats
mut
prot
now
)
=
find_pmtu
(
addr
mtu
None
)
;
assert
!
(
larger_mtu
>
=
pmtud
.
search_table
[
0
]
)
;
pmtud
.
start
(
now
&
mut
stats
)
;
assert
!
(
pmtud
.
needs_probe
(
)
)
;
while
pmtud
.
needs_probe
(
)
{
pmtud_step
(
&
mut
pmtud
&
mut
stats
&
mut
prot
addr
mtu
now
)
;
}
assert_mtu
(
&
pmtud
mtu
)
;
qdebug
!
(
"
Increasing
MTU
to
{
larger_mtu
}
"
)
;
let
now
=
now
+
PMTU_RAISE_TIMER
;
pmtud
.
maybe_fire_raise_timer
(
now
&
mut
stats
)
;
while
pmtud
.
needs_probe
(
)
{
pmtud_step
(
&
mut
pmtud
&
mut
stats
&
mut
prot
addr
larger_mtu
now
)
;
}
assert_mtu
(
&
pmtud
larger_mtu
)
;
}
fn
path_mtus
(
)
-
>
Vec
<
usize
>
{
IFACE_MTUS
.
iter
(
)
.
flatten
(
)
.
copied
(
)
.
collect
(
)
}
#
[
test
]
fn
pmtud
(
)
{
for
&
addr
in
&
[
V4
V6
]
{
for
path_mtu
in
path_mtus
(
)
{
for
&
iface_mtu
in
IFACE_MTUS
{
qinfo
!
(
"
PMTUD
for
{
addr
}
path
MTU
{
path_mtu
}
iface
MTU
{
iface_mtu
:
?
}
"
)
;
find_pmtu
(
addr
path_mtu
iface_mtu
)
;
}
}
}
}
#
[
test
]
fn
pmtud_with_reduction
(
)
{
for
&
addr
in
&
[
V4
V6
]
{
for
path_mtu
in
path_mtus
(
)
{
let
path_mtus
=
path_mtus
(
)
;
let
smaller_mtus
=
path_mtus
.
iter
(
)
.
filter
(
|
&
mtu
|
*
mtu
<
path_mtu
)
;
for
&
smaller_mtu
in
smaller_mtus
{
qinfo
!
(
"
PMTUD
for
{
addr
}
path
MTU
{
path_mtu
}
smaller
path
MTU
{
smaller_mtu
}
"
)
;
find_pmtu_with_reduction
(
addr
path_mtu
smaller_mtu
)
;
}
}
}
}
#
[
test
]
fn
pmtud_with_increase
(
)
{
for
&
addr
in
&
[
V4
V6
]
{
for
path_mtu
in
path_mtus
(
)
{
let
path_mtus
=
path_mtus
(
)
;
let
larger_mtus
=
path_mtus
.
iter
(
)
.
filter
(
|
&
mtu
|
*
mtu
>
path_mtu
)
;
for
&
larger_mtu
in
larger_mtus
{
qinfo
!
(
"
PMTUD
for
{
addr
}
path
MTU
{
path_mtu
}
larger
path
MTU
{
larger_mtu
}
"
)
;
find_pmtu_with_increase
(
addr
path_mtu
larger_mtu
)
;
}
}
}
}
fn
search_table_inc
(
pmtud
:
&
Pmtud
loss_counts
:
&
[
usize
]
lost_size
:
usize
)
-
>
Vec
<
usize
>
{
zip
(
pmtud
.
search_table
loss_counts
.
iter
(
)
)
.
map
(
|
(
&
size
&
count
)
|
{
if
size
>
=
lost_size
+
pmtud
.
header_size
{
count
+
1
}
else
{
count
}
}
)
.
collect
(
)
}
fn
assert_pmtud_restarted
(
pmtud
:
&
Pmtud
)
{
assert_eq
!
(
Probe
:
:
Needed
pmtud
.
probe_state
)
;
assert_eq
!
(
pmtud
.
mtu
pmtud
.
search_table
[
0
]
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
}
#
[
test
]
fn
pmtud_on_packets_lost
(
)
{
const
MTU
:
usize
=
1500
;
let
now
=
now
(
)
;
let
mut
pmtud
=
Pmtud
:
:
new
(
V4
Some
(
MTU
)
)
;
let
mut
stats
=
Stats
:
:
default
(
)
;
pmtud
.
stop
(
pmtud
.
search_table
.
iter
(
)
.
position
(
|
&
mtu
|
mtu
=
=
MTU
)
.
unwrap
(
)
now
&
mut
stats
)
;
assert_mtu
(
&
pmtud
MTU
)
;
pmtud
.
on_packets_lost
(
&
[
]
&
mut
stats
now
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
100
)
]
&
mut
stats
now
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
100_000
)
]
&
mut
stats
now
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
pmtud
.
loss_counts
.
fill
(
0
)
;
let
plen
=
MTU
-
pmtud
.
header_size
;
let
mut
expected_lc
=
search_table_inc
(
&
pmtud
&
pmtud
.
loss_counts
plen
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
plen
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
expected_lc
=
search_table_inc
(
&
pmtud
&
expected_lc
2000
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
2000
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
expected_lc
=
search_table_inc
(
&
pmtud
&
expected_lc
5000
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
5000
)
]
&
mut
stats
now
)
;
assert_mtu
(
&
pmtud
4095
)
;
expected_lc
.
fill
(
0
)
;
expected_lc
=
search_table_inc
(
&
pmtud
&
expected_lc
4000
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
4000
)
sent
:
:
make_packet
(
1
now
4000
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
expected_lc
=
search_table_inc
(
&
pmtud
&
expected_lc
2000
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
2000
)
sent
:
:
make_packet
(
1
now
2000
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
let
plen
=
MTU
-
pmtud
.
header_size
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
plen
)
sent
:
:
make_packet
(
1
now
plen
)
]
&
mut
stats
now
)
;
assert_pmtud_restarted
(
&
pmtud
)
;
}
fn
search_table_zero
(
pmtud
:
&
Pmtud
loss_counts
:
&
[
usize
]
sz
:
usize
)
-
>
Vec
<
usize
>
{
zip
(
pmtud
.
search_table
loss_counts
.
iter
(
)
)
.
map
(
|
(
&
s
&
c
)
|
if
s
<
=
sz
+
pmtud
.
header_size
{
0
}
else
{
c
}
)
.
collect
(
)
}
#
[
test
]
fn
pmtud_on_packets_lost_and_acked
(
)
{
const
MTU
:
usize
=
1500
;
let
now
=
now
(
)
;
let
mut
pmtud
=
Pmtud
:
:
new
(
V4
Some
(
MTU
)
)
;
let
mut
stats
=
Stats
:
:
default
(
)
;
pmtud
.
stop
(
pmtud
.
search_table
.
iter
(
)
.
position
(
|
&
mtu
|
mtu
=
=
MTU
)
.
unwrap
(
)
now
&
mut
stats
)
;
assert_mtu
(
&
pmtud
MTU
)
;
pmtud
.
on_packets_acked
(
&
[
sent
:
:
make_packet
(
0
now
100
)
]
now
&
mut
stats
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
pmtud
.
on_packets_acked
(
&
[
sent
:
:
make_packet
(
0
now
100_000
)
]
now
&
mut
stats
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
pmtud
.
loss_counts
.
fill
(
0
)
;
pmtud
.
on_packets_acked
(
&
[
]
now
&
mut
stats
)
;
assert_eq
!
(
[
0
;
SEARCH_TABLE_LEN
]
pmtud
.
loss_counts
)
;
let
mut
expected_lc
=
search_table_inc
(
&
pmtud
&
pmtud
.
loss_counts
4000
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
4000
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
pmtud
.
on_packets_acked
(
&
[
sent
:
:
make_packet
(
0
now
5000
)
]
now
&
mut
stats
)
;
expected_lc
=
search_table_zero
(
&
pmtud
&
pmtud
.
loss_counts
5000
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
expected_lc
=
search_table_inc
(
&
pmtud
&
expected_lc
4000
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
4000
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
pmtud
.
on_packets_acked
(
&
[
sent
:
:
make_packet
(
0
now
8000
)
]
now
&
mut
stats
)
;
expected_lc
=
search_table_zero
(
&
pmtud
&
pmtud
.
loss_counts
8000
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
9000
)
]
&
mut
stats
now
)
;
for
_
in
0
.
.
2
{
expected_lc
=
search_table_inc
(
&
pmtud
&
pmtud
.
loss_counts
1400
)
;
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
1400
)
]
&
mut
stats
now
)
;
assert_eq
!
(
expected_lc
pmtud
.
loss_counts
)
;
}
pmtud
.
on_packets_lost
(
&
[
sent
:
:
make_packet
(
0
now
1400
)
]
&
mut
stats
now
)
;
assert_pmtud_restarted
(
&
pmtud
)
;
}
}
