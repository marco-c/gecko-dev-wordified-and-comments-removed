use
std
:
:
{
fmt
:
:
{
self
Display
}
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
qtrace
;
use
crate
:
:
cc
:
:
classic_cc
:
:
WindowAdjustment
;
pub
const
CUBIC_C
:
f64
=
0
.
4
;
pub
const
CUBIC_ALPHA
:
f64
=
3
.
0
*
(
1
.
0
-
0
.
7
)
/
(
1
.
0
+
0
.
7
)
;
pub
const
CUBIC_BETA_USIZE_DIVIDEND
:
usize
=
7
;
pub
const
CUBIC_BETA_USIZE_DIVISOR
:
usize
=
10
;
pub
const
CUBIC_FAST_CONVERGENCE
:
f64
=
0
.
85
;
const
EXPONENTIAL_GROWTH_REDUCTION
:
f64
=
2
.
0
;
pub
fn
convert_to_f64
(
v
:
usize
)
-
>
f64
{
let
mut
f_64
=
f64
:
:
from
(
u32
:
:
try_from
(
v
>
>
21
)
.
unwrap_or
(
u32
:
:
MAX
)
)
;
f_64
*
=
2_097_152
.
0
;
#
[
expect
(
clippy
:
:
cast_possible_truncation
reason
=
"
The
mask
makes
this
safe
.
"
)
]
let
v_trunc
=
(
v
&
0x1f_ffff
)
as
u32
;
f_64
+
=
f64
:
:
from
(
v_trunc
)
;
f_64
}
#
[
derive
(
Debug
Default
)
]
pub
struct
Cubic
{
last_max_cwnd
:
f64
estimated_tcp_cwnd
:
f64
k
:
f64
w_max
:
f64
ca_epoch_start
:
Option
<
Instant
>
tcp_acked_bytes
:
f64
}
impl
Display
for
Cubic
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Cubic
[
last_max_cwnd
:
{
}
k
:
{
}
w_max
:
{
}
ca_epoch_start
:
{
:
?
}
]
"
self
.
last_max_cwnd
self
.
k
self
.
w_max
self
.
ca_epoch_start
)
?
;
Ok
(
(
)
)
}
}
#
[
expect
(
clippy
:
:
doc_markdown
reason
=
"
Not
doc
items
;
names
from
RFC
.
"
)
]
impl
Cubic
{
fn
calc_k
(
&
self
curr_cwnd
:
f64
max_datagram_size
:
f64
)
-
>
f64
{
(
(
self
.
w_max
-
curr_cwnd
)
/
CUBIC_C
/
max_datagram_size
)
.
cbrt
(
)
}
fn
w_cubic
(
&
self
t
:
f64
max_datagram_size
:
f64
)
-
>
f64
{
(
CUBIC_C
*
(
t
-
self
.
k
)
.
powi
(
3
)
)
.
mul_add
(
max_datagram_size
self
.
w_max
)
}
fn
start_epoch
(
&
mut
self
curr_cwnd
:
f64
new_acked
:
f64
max_datagram_size
:
f64
now
:
Instant
)
{
self
.
ca_epoch_start
=
Some
(
now
)
;
self
.
tcp_acked_bytes
=
new_acked
;
self
.
estimated_tcp_cwnd
=
curr_cwnd
;
if
self
.
last_max_cwnd
<
=
curr_cwnd
{
self
.
w_max
=
curr_cwnd
;
self
.
k
=
0
.
0
;
}
else
{
self
.
w_max
=
self
.
last_max_cwnd
;
self
.
k
=
self
.
calc_k
(
curr_cwnd
max_datagram_size
)
;
}
qtrace
!
(
"
[
{
self
}
]
New
epoch
"
)
;
}
#
[
cfg
(
test
)
]
pub
const
fn
last_max_cwnd
(
&
self
)
-
>
f64
{
self
.
last_max_cwnd
}
#
[
cfg
(
test
)
]
pub
fn
set_last_max_cwnd
(
&
mut
self
last_max_cwnd
:
f64
)
{
self
.
last_max_cwnd
=
last_max_cwnd
;
}
}
impl
WindowAdjustment
for
Cubic
{
#
[
expect
(
clippy
:
:
cast_possible_truncation
clippy
:
:
cast_sign_loss
reason
=
"
Cast
from
f64
to
usize
.
"
)
]
fn
bytes_for_cwnd_increase
(
&
mut
self
curr_cwnd
:
usize
new_acked_bytes
:
usize
min_rtt
:
Duration
max_datagram_size
:
usize
now
:
Instant
)
-
>
usize
{
let
curr_cwnd_f64
=
convert_to_f64
(
curr_cwnd
)
;
let
new_acked_f64
=
convert_to_f64
(
new_acked_bytes
)
;
let
max_datagram_size_f64
=
convert_to_f64
(
max_datagram_size
)
;
if
self
.
ca_epoch_start
.
is_none
(
)
{
self
.
start_epoch
(
curr_cwnd_f64
new_acked_f64
max_datagram_size_f64
now
)
;
}
else
{
self
.
tcp_acked_bytes
+
=
new_acked_f64
;
}
let
time_ca
=
self
.
ca_epoch_start
.
map_or
(
min_rtt
|
t
|
{
if
now
+
min_rtt
<
t
{
min_rtt
}
else
{
now
+
min_rtt
-
t
}
}
)
.
as_secs_f64
(
)
;
let
target_cubic
=
self
.
w_cubic
(
time_ca
max_datagram_size_f64
)
;
let
tcp_cnt
=
self
.
estimated_tcp_cwnd
/
CUBIC_ALPHA
;
let
incr
=
(
self
.
tcp_acked_bytes
/
tcp_cnt
)
.
floor
(
)
;
if
incr
>
0
.
0
{
self
.
tcp_acked_bytes
-
=
incr
*
tcp_cnt
;
self
.
estimated_tcp_cwnd
+
=
incr
*
max_datagram_size_f64
;
}
let
target_cwnd
=
target_cubic
.
max
(
self
.
estimated_tcp_cwnd
)
;
let
mut
acked_to_increase
=
max_datagram_size_f64
*
curr_cwnd_f64
/
(
target_cwnd
-
curr_cwnd_f64
)
.
max
(
1
.
0
)
;
acked_to_increase
=
acked_to_increase
.
max
(
EXPONENTIAL_GROWTH_REDUCTION
*
max_datagram_size_f64
)
;
acked_to_increase
as
usize
}
fn
reduce_cwnd
(
&
mut
self
curr_cwnd
:
usize
acked_bytes
:
usize
max_datagram_size
:
usize
)
-
>
(
usize
usize
)
{
let
curr_cwnd_f64
=
convert_to_f64
(
curr_cwnd
)
;
self
.
last_max_cwnd
=
if
curr_cwnd_f64
+
convert_to_f64
(
max_datagram_size
)
<
self
.
last_max_cwnd
{
curr_cwnd_f64
*
CUBIC_FAST_CONVERGENCE
}
else
{
curr_cwnd_f64
}
;
self
.
ca_epoch_start
=
None
;
(
curr_cwnd
*
CUBIC_BETA_USIZE_DIVIDEND
/
CUBIC_BETA_USIZE_DIVISOR
acked_bytes
*
CUBIC_BETA_USIZE_DIVIDEND
/
CUBIC_BETA_USIZE_DIVISOR
)
}
fn
on_app_limited
(
&
mut
self
)
{
self
.
ca_epoch_start
=
None
;
}
}
