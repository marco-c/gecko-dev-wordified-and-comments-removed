use
std
:
:
{
fmt
:
:
{
self
Display
}
time
:
:
{
Duration
Instant
}
}
;
use
neqo_common
:
:
qtrace
;
use
crate
:
:
cc
:
:
classic_cc
:
:
WindowAdjustment
;
pub
fn
convert_to_f64
(
v
:
usize
)
-
>
f64
{
let
mut
f_64
=
f64
:
:
from
(
u32
:
:
try_from
(
v
>
>
21
)
.
unwrap_or
(
u32
:
:
MAX
)
)
;
f_64
*
=
2_097_152
.
0
;
#
[
expect
(
clippy
:
:
cast_possible_truncation
reason
=
"
The
mask
makes
this
safe
.
"
)
]
let
v_trunc
=
(
v
&
0x1f_ffff
)
as
u32
;
f_64
+
=
f64
:
:
from
(
v_trunc
)
;
f_64
}
#
[
derive
(
Debug
Default
)
]
pub
struct
Cubic
{
w_est
:
f64
k
:
f64
w_max
:
f64
t_epoch
:
Option
<
Instant
>
reno_acked_bytes
:
f64
}
impl
Display
for
Cubic
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Cubic
[
w_max
:
{
}
k
:
{
}
t_epoch
:
{
:
?
}
]
"
self
.
w_max
self
.
k
self
.
t_epoch
)
?
;
Ok
(
(
)
)
}
}
impl
Cubic
{
pub
const
C
:
f64
=
0
.
4
;
pub
const
ALPHA
:
f64
=
3
.
0
*
(
1
.
0
-
0
.
7
)
/
(
1
.
0
+
0
.
7
)
;
pub
const
BETA_USIZE_DIVIDEND
:
usize
=
7
;
pub
const
BETA_USIZE_DIVISOR
:
usize
=
10
;
pub
const
FAST_CONVERGENCE_FACTOR
:
f64
=
(
1
.
0
+
0
.
7
)
/
2
.
0
;
fn
calc_k
(
&
self
cwnd_epoch
:
f64
max_datagram_size
:
f64
)
-
>
f64
{
(
(
self
.
w_max
-
cwnd_epoch
)
/
max_datagram_size
/
Self
:
:
C
)
.
cbrt
(
)
}
fn
w_cubic
(
&
self
t
:
f64
max_datagram_size
:
f64
)
-
>
f64
{
(
Self
:
:
C
*
(
t
-
self
.
k
)
.
powi
(
3
)
)
.
mul_add
(
max_datagram_size
self
.
w_max
)
}
fn
start_epoch
(
&
mut
self
curr_cwnd
:
f64
new_acked_bytes
:
f64
max_datagram_size
:
f64
now
:
Instant
)
{
self
.
t_epoch
=
Some
(
now
)
;
self
.
reno_acked_bytes
=
new_acked_bytes
;
self
.
w_est
=
curr_cwnd
;
self
.
k
=
if
self
.
w_max
<
=
curr_cwnd
{
self
.
w_max
=
curr_cwnd
;
0
.
0
}
else
{
self
.
calc_k
(
curr_cwnd
max_datagram_size
)
}
;
qtrace
!
(
"
[
{
self
}
]
New
epoch
"
)
;
}
#
[
cfg
(
test
)
]
pub
const
fn
w_max
(
&
self
)
-
>
f64
{
self
.
w_max
}
#
[
cfg
(
test
)
]
pub
fn
set_w_max
(
&
mut
self
w_max
:
f64
)
{
self
.
w_max
=
w_max
;
}
}
impl
WindowAdjustment
for
Cubic
{
#
[
expect
(
clippy
:
:
cast_possible_truncation
clippy
:
:
cast_sign_loss
reason
=
"
Cast
from
f64
to
usize
.
"
)
]
fn
bytes_for_cwnd_increase
(
&
mut
self
curr_cwnd
:
usize
new_acked_bytes
:
usize
min_rtt
:
Duration
max_datagram_size
:
usize
now
:
Instant
)
-
>
usize
{
let
curr_cwnd
=
convert_to_f64
(
curr_cwnd
)
;
let
new_acked_bytes
=
convert_to_f64
(
new_acked_bytes
)
;
let
max_datagram_size
=
convert_to_f64
(
max_datagram_size
)
;
let
t_epoch
=
if
let
Some
(
t
)
=
self
.
t_epoch
{
self
.
reno_acked_bytes
+
=
new_acked_bytes
;
t
}
else
{
self
.
start_epoch
(
curr_cwnd
new_acked_bytes
max_datagram_size
now
)
;
self
.
t_epoch
.
expect
(
"
unwrapping
None
value
-
-
it
should
'
ve
been
set
by
start_epoch
"
)
}
;
let
t
=
now
.
saturating_duration_since
(
t_epoch
)
;
let
target_cubic
=
f64
:
:
clamp
(
self
.
w_cubic
(
(
t
+
min_rtt
)
.
as_secs_f64
(
)
max_datagram_size
)
curr_cwnd
curr_cwnd
*
1
.
5
)
;
let
increase
=
(
Self
:
:
ALPHA
*
self
.
reno_acked_bytes
/
curr_cwnd
)
.
floor
(
)
;
if
increase
>
0
.
0
{
self
.
w_est
+
=
increase
*
max_datagram_size
;
let
acked_bytes_used
=
increase
*
curr_cwnd
/
Self
:
:
ALPHA
;
self
.
reno_acked_bytes
-
=
acked_bytes_used
;
}
let
target
=
target_cubic
.
max
(
self
.
w_est
)
;
let
cwnd_increase
=
target
-
curr_cwnd
;
(
max_datagram_size
*
curr_cwnd
/
cwnd_increase
.
max
(
1
.
0
)
)
as
usize
}
fn
reduce_cwnd
(
&
mut
self
curr_cwnd
:
usize
acked_bytes
:
usize
max_datagram_size
:
usize
)
-
>
(
usize
usize
)
{
let
curr_cwnd_f64
=
convert_to_f64
(
curr_cwnd
)
;
self
.
w_max
=
if
curr_cwnd_f64
+
convert_to_f64
(
max_datagram_size
)
<
self
.
w_max
{
curr_cwnd_f64
*
Self
:
:
FAST_CONVERGENCE_FACTOR
}
else
{
curr_cwnd_f64
}
;
self
.
t_epoch
=
None
;
(
curr_cwnd
*
Self
:
:
BETA_USIZE_DIVIDEND
/
Self
:
:
BETA_USIZE_DIVISOR
acked_bytes
*
Self
:
:
BETA_USIZE_DIVIDEND
/
Self
:
:
BETA_USIZE_DIVISOR
)
}
fn
on_app_limited
(
&
mut
self
)
{
self
.
t_epoch
=
None
;
}
}
