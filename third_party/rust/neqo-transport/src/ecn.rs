use
std
:
:
ops
:
:
{
AddAssign
Deref
DerefMut
Sub
}
;
use
enum_map
:
:
{
Enum
EnumMap
}
;
use
neqo_common
:
:
{
qdebug
qinfo
qwarn
IpTosEcn
}
;
use
crate
:
:
{
packet
:
:
{
PacketNumber
PacketType
}
recovery
:
:
{
RecoveryToken
SentPacket
}
Stats
}
;
pub
(
crate
)
const
TEST_COUNT
:
usize
=
10
;
const
TEST_COUNT_INITIAL_PHASE
:
usize
=
3
;
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
enum
ValidationState
{
Testing
{
probes_sent
:
usize
initial_probes_lost
:
usize
}
Unknown
Failed
(
ValidationError
)
Capable
}
impl
Default
for
ValidationState
{
fn
default
(
)
-
>
Self
{
Self
:
:
Testing
{
probes_sent
:
0
initial_probes_lost
:
0
}
}
}
impl
ValidationState
{
fn
set
(
&
mut
self
new
:
Self
stats
:
&
mut
Stats
)
{
let
old
=
std
:
:
mem
:
:
replace
(
self
new
)
;
match
old
{
Self
:
:
Testing
{
.
.
}
|
Self
:
:
Unknown
=
>
{
}
Self
:
:
Failed
(
_
)
=
>
debug_assert
!
(
false
"
Failed
is
a
terminal
state
"
)
Self
:
:
Capable
=
>
stats
.
ecn_path_validation
[
ValidationOutcome
:
:
Capable
]
-
=
1
}
match
new
{
Self
:
:
Testing
{
.
.
}
|
Self
:
:
Unknown
=
>
{
}
Self
:
:
Failed
(
error
)
=
>
{
stats
.
ecn_path_validation
[
ValidationOutcome
:
:
NotCapable
(
error
)
]
+
=
1
;
}
Self
:
:
Capable
=
>
stats
.
ecn_path_validation
[
ValidationOutcome
:
:
Capable
]
+
=
1
}
}
}
#
[
derive
(
PartialEq
Eq
Debug
Clone
Copy
Default
)
]
pub
struct
Count
(
EnumMap
<
IpTosEcn
u64
>
)
;
impl
Deref
for
Count
{
type
Target
=
EnumMap
<
IpTosEcn
u64
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
Count
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
Count
{
#
[
must_use
]
pub
const
fn
new
(
not_ect
:
u64
ect0
:
u64
ect1
:
u64
ce
:
u64
)
-
>
Self
{
Self
(
EnumMap
:
:
from_array
(
[
not_ect
ect1
ect0
ce
]
)
)
}
#
[
must_use
]
pub
fn
is_some
(
&
self
)
-
>
bool
{
self
[
IpTosEcn
:
:
Ect0
]
>
0
|
|
self
[
IpTosEcn
:
:
Ect1
]
>
0
|
|
self
[
IpTosEcn
:
:
Ce
]
>
0
}
#
[
must_use
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
iter
(
)
.
all
(
|
(
_
count
)
|
*
count
=
=
0
)
}
}
impl
Sub
<
Self
>
for
Count
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
{
let
mut
diff
=
Self
:
:
default
(
)
;
for
(
ecn
count
)
in
&
mut
*
diff
{
*
count
=
self
[
ecn
]
.
saturating_sub
(
rhs
[
ecn
]
)
;
}
diff
}
}
impl
AddAssign
<
IpTosEcn
>
for
Count
{
fn
add_assign
(
&
mut
self
rhs
:
IpTosEcn
)
{
self
[
rhs
]
+
=
1
;
}
}
#
[
derive
(
PartialEq
Eq
Debug
Clone
Copy
Default
)
]
pub
struct
ValidationCount
(
EnumMap
<
ValidationOutcome
u64
>
)
;
impl
Deref
for
ValidationCount
{
type
Target
=
EnumMap
<
ValidationOutcome
u64
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
ValidationCount
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
derive
(
Debug
Clone
Copy
Enum
PartialEq
Eq
)
]
pub
enum
ValidationError
{
BlackHole
Bleaching
ReceivedUnsentECT1
}
#
[
derive
(
Debug
Clone
Copy
Enum
PartialEq
Eq
)
]
pub
enum
ValidationOutcome
{
Capable
NotCapable
(
ValidationError
)
}
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
Info
{
state
:
ValidationState
largest_acked
:
PacketNumber
baseline
:
Count
}
impl
Info
{
pub
(
crate
)
fn
set_baseline
(
&
mut
self
baseline
:
Count
)
{
self
.
baseline
=
baseline
;
}
pub
(
crate
)
const
fn
baseline
(
&
self
)
-
>
Count
{
self
.
baseline
}
pub
(
crate
)
fn
on_packet_sent
(
&
mut
self
stats
:
&
mut
Stats
)
{
if
let
ValidationState
:
:
Testing
{
probes_sent
.
.
}
=
&
mut
self
.
state
{
*
probes_sent
+
=
1
;
qdebug
!
(
"
ECN
probing
:
sent
{
probes_sent
}
probes
"
)
;
if
*
probes_sent
=
=
TEST_COUNT
{
qdebug
!
(
"
ECN
probing
concluded
with
{
probes_sent
}
probes
sent
"
)
;
self
.
state
.
set
(
ValidationState
:
:
Unknown
stats
)
;
}
}
}
pub
(
crate
)
fn
disable_ecn
(
&
mut
self
stats
:
&
mut
Stats
reason
:
ValidationError
)
{
self
.
state
.
set
(
ValidationState
:
:
Failed
(
reason
)
stats
)
;
}
pub
(
crate
)
fn
on_packets_acked
(
&
mut
self
acked_packets
:
&
[
SentPacket
]
ack_ecn
:
Option
<
Count
>
stats
:
&
mut
Stats
)
-
>
bool
{
let
prev_baseline
=
self
.
baseline
;
self
.
validate_ack_ecn_and_update
(
acked_packets
ack_ecn
stats
)
;
matches
!
(
self
.
state
ValidationState
:
:
Capable
)
&
&
(
self
.
baseline
-
prev_baseline
)
[
IpTosEcn
:
:
Ce
]
>
0
}
pub
(
crate
)
fn
lost_ecn
(
&
mut
self
pt
:
PacketType
stats
:
&
mut
Stats
)
{
if
pt
!
=
PacketType
:
:
Initial
{
return
;
}
if
let
ValidationState
:
:
Testing
{
probes_sent
initial_probes_lost
:
probes_lost
}
=
&
mut
self
.
state
{
*
probes_lost
+
=
1
;
if
*
probes_sent
=
=
*
probes_lost
&
&
*
probes_lost
=
=
TEST_COUNT_INITIAL_PHASE
{
qdebug
!
(
"
ECN
validation
failed
all
{
probes_lost
}
initial
marked
packets
were
lost
"
)
;
self
.
disable_ecn
(
stats
ValidationError
:
:
BlackHole
)
;
}
}
}
fn
validate_ack_ecn_and_update
(
&
mut
self
acked_packets
:
&
[
SentPacket
]
ack_ecn
:
Option
<
Count
>
stats
:
&
mut
Stats
)
{
let
largest_acked
=
acked_packets
.
first
(
)
.
expect
(
"
must
be
there
"
)
;
if
largest_acked
.
pn
(
)
<
=
self
.
largest_acked
{
return
;
}
match
self
.
state
{
ValidationState
:
:
Testing
{
.
.
}
|
ValidationState
:
:
Failed
(
_
)
=
>
return
ValidationState
:
:
Unknown
|
ValidationState
:
:
Capable
=
>
{
}
}
let
Some
(
ack_ecn
)
=
ack_ecn
else
{
qwarn
!
(
"
ECN
validation
failed
no
ECN
counts
in
ACK
frame
"
)
;
self
.
disable_ecn
(
stats
ValidationError
:
:
Bleaching
)
;
return
;
}
;
stats
.
ecn_tx_acked
[
largest_acked
.
packet_type
(
)
]
=
ack_ecn
;
let
newly_acked_sent_with_ect0
:
u64
=
acked_packets
.
iter
(
)
.
filter
(
|
p
|
p
.
ecn_marked_ect0
(
)
)
.
count
(
)
.
try_into
(
)
.
expect
(
"
usize
fits
into
u64
"
)
;
if
newly_acked_sent_with_ect0
=
=
0
{
qwarn
!
(
"
ECN
validation
failed
no
ECT
(
0
)
packets
were
newly
acked
"
)
;
self
.
disable_ecn
(
stats
ValidationError
:
:
Bleaching
)
;
return
;
}
let
ecn_diff
=
ack_ecn
-
self
.
baseline
;
let
sum_inc
=
ecn_diff
[
IpTosEcn
:
:
Ect0
]
+
ecn_diff
[
IpTosEcn
:
:
Ce
]
;
if
sum_inc
<
newly_acked_sent_with_ect0
{
qwarn
!
(
"
ECN
validation
failed
ACK
counted
{
sum_inc
}
new
marks
but
{
newly_acked_sent_with_ect0
}
of
newly
acked
packets
were
sent
with
ECT
(
0
)
"
)
;
self
.
disable_ecn
(
stats
ValidationError
:
:
Bleaching
)
;
}
else
if
ecn_diff
[
IpTosEcn
:
:
Ect1
]
>
0
{
qwarn
!
(
"
ECN
validation
failed
ACK
counted
ECT
(
1
)
marks
that
were
never
sent
"
)
;
self
.
disable_ecn
(
stats
ValidationError
:
:
ReceivedUnsentECT1
)
;
}
else
if
self
.
state
!
=
ValidationState
:
:
Capable
{
qinfo
!
(
"
ECN
validation
succeeded
path
is
capable
"
)
;
self
.
state
.
set
(
ValidationState
:
:
Capable
stats
)
;
}
self
.
baseline
=
ack_ecn
;
self
.
largest_acked
=
largest_acked
.
pn
(
)
;
}
pub
(
crate
)
const
fn
is_marking
(
&
self
)
-
>
bool
{
match
self
.
state
{
ValidationState
:
:
Testing
{
.
.
}
|
ValidationState
:
:
Capable
=
>
true
ValidationState
:
:
Failed
(
_
)
|
ValidationState
:
:
Unknown
=
>
false
}
}
pub
(
crate
)
fn
ecn_mark
(
&
self
tokens
:
&
mut
Vec
<
RecoveryToken
>
)
-
>
IpTosEcn
{
if
self
.
is_marking
(
)
{
tokens
.
push
(
RecoveryToken
:
:
EcnEct0
)
;
IpTosEcn
:
:
Ect0
}
else
{
IpTosEcn
:
:
NotEct
}
}
}
