use
std
:
:
ops
:
:
{
AddAssign
Deref
DerefMut
Sub
}
;
use
enum_map
:
:
EnumMap
;
use
neqo_common
:
:
{
qdebug
qinfo
qwarn
IpTosEcn
}
;
use
crate
:
:
{
packet
:
:
PacketNumber
recovery
:
:
SentPacket
}
;
pub
const
ECN_TEST_COUNT
:
usize
=
10
;
#
[
derive
(
Debug
PartialEq
Clone
)
]
enum
EcnValidationState
{
Testing
(
usize
)
Unknown
Failed
Capable
}
impl
Default
for
EcnValidationState
{
fn
default
(
)
-
>
Self
{
EcnValidationState
:
:
Testing
(
0
)
}
}
#
[
derive
(
PartialEq
Eq
Debug
Clone
Copy
Default
)
]
pub
struct
EcnCount
(
EnumMap
<
IpTosEcn
u64
>
)
;
impl
Deref
for
EcnCount
{
type
Target
=
EnumMap
<
IpTosEcn
u64
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
EcnCount
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
EcnCount
{
pub
fn
new
(
not_ect
:
u64
ect0
:
u64
ect1
:
u64
ce
:
u64
)
-
>
Self
{
Self
(
EnumMap
:
:
from_array
(
[
not_ect
ect1
ect0
ce
]
)
)
}
pub
fn
is_some
(
&
self
)
-
>
bool
{
self
[
IpTosEcn
:
:
Ect0
]
>
0
|
|
self
[
IpTosEcn
:
:
Ect1
]
>
0
|
|
self
[
IpTosEcn
:
:
Ce
]
>
0
}
}
impl
Sub
<
EcnCount
>
for
EcnCount
{
type
Output
=
EcnCount
;
fn
sub
(
self
other
:
EcnCount
)
-
>
EcnCount
{
let
mut
diff
=
EcnCount
:
:
default
(
)
;
for
(
ecn
count
)
in
&
mut
*
diff
{
*
count
=
self
[
ecn
]
.
saturating_sub
(
other
[
ecn
]
)
;
}
diff
}
}
impl
AddAssign
<
IpTosEcn
>
for
EcnCount
{
fn
add_assign
(
&
mut
self
ecn
:
IpTosEcn
)
{
self
[
ecn
]
+
=
1
;
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
EcnInfo
{
state
:
EcnValidationState
largest_acked
:
PacketNumber
baseline
:
EcnCount
}
impl
EcnInfo
{
pub
fn
set_baseline
(
&
mut
self
baseline
:
EcnCount
)
{
self
.
baseline
=
baseline
;
}
pub
fn
baseline
(
&
self
)
-
>
EcnCount
{
self
.
baseline
}
pub
fn
on_packet_sent
(
&
mut
self
)
{
if
let
EcnValidationState
:
:
Testing
(
ref
mut
probes_sent
)
=
&
mut
self
.
state
{
*
probes_sent
+
=
1
;
qdebug
!
(
"
ECN
probing
:
sent
{
}
probes
"
probes_sent
)
;
if
*
probes_sent
=
=
ECN_TEST_COUNT
{
qdebug
!
(
"
ECN
probing
concluded
with
{
}
probes
sent
"
probes_sent
)
;
self
.
state
=
EcnValidationState
:
:
Unknown
;
}
}
}
pub
fn
on_packets_acked
(
&
mut
self
acked_packets
:
&
[
SentPacket
]
ack_ecn
:
Option
<
EcnCount
>
)
-
>
bool
{
let
prev_baseline
=
self
.
baseline
;
self
.
validate_ack_ecn_and_update
(
acked_packets
ack_ecn
)
;
matches
!
(
self
.
state
EcnValidationState
:
:
Capable
)
&
&
(
self
.
baseline
-
prev_baseline
)
[
IpTosEcn
:
:
Ce
]
>
0
}
pub
fn
validate_ack_ecn_and_update
(
&
mut
self
acked_packets
:
&
[
SentPacket
]
ack_ecn
:
Option
<
EcnCount
>
)
{
match
self
.
state
{
EcnValidationState
:
:
Testing
{
.
.
}
|
EcnValidationState
:
:
Failed
=
>
return
EcnValidationState
:
:
Unknown
|
EcnValidationState
:
:
Capable
=
>
{
}
}
let
largest_acked
=
acked_packets
.
first
(
)
.
expect
(
"
must
be
there
"
)
.
pn
(
)
;
if
largest_acked
<
=
self
.
largest_acked
{
return
;
}
let
Some
(
ack_ecn
)
=
ack_ecn
else
{
qwarn
!
(
"
ECN
validation
failed
no
ECN
counts
in
ACK
frame
"
)
;
self
.
state
=
EcnValidationState
:
:
Failed
;
return
;
}
;
let
newly_acked_sent_with_ect0
:
u64
=
acked_packets
.
iter
(
)
.
filter
(
|
p
|
p
.
ecn_mark
(
)
=
=
IpTosEcn
:
:
Ect0
)
.
count
(
)
.
try_into
(
)
.
unwrap
(
)
;
if
newly_acked_sent_with_ect0
=
=
0
{
qwarn
!
(
"
ECN
validation
failed
no
ECT
(
0
)
packets
were
newly
acked
"
)
;
self
.
state
=
EcnValidationState
:
:
Failed
;
return
;
}
let
ecn_diff
=
ack_ecn
-
self
.
baseline
;
let
sum_inc
=
ecn_diff
[
IpTosEcn
:
:
Ect0
]
+
ecn_diff
[
IpTosEcn
:
:
Ce
]
;
if
sum_inc
<
newly_acked_sent_with_ect0
{
qwarn
!
(
"
ECN
validation
failed
ACK
counted
{
}
new
marks
but
{
}
of
newly
acked
packets
were
sent
with
ECT
(
0
)
"
sum_inc
newly_acked_sent_with_ect0
)
;
self
.
state
=
EcnValidationState
:
:
Failed
;
}
else
if
ecn_diff
[
IpTosEcn
:
:
Ect1
]
>
0
{
qwarn
!
(
"
ECN
validation
failed
ACK
counted
ECT
(
1
)
marks
that
were
never
sent
"
)
;
self
.
state
=
EcnValidationState
:
:
Failed
;
}
else
{
qinfo
!
(
"
ECN
validation
succeeded
path
is
capable
"
)
;
self
.
state
=
EcnValidationState
:
:
Capable
;
}
self
.
baseline
=
ack_ecn
;
self
.
largest_acked
=
largest_acked
;
}
pub
fn
ecn_mark
(
&
self
)
-
>
IpTosEcn
{
match
self
.
state
{
EcnValidationState
:
:
Testing
{
.
.
}
|
EcnValidationState
:
:
Capable
=
>
IpTosEcn
:
:
Ect0
EcnValidationState
:
:
Failed
|
EcnValidationState
:
:
Unknown
=
>
IpTosEcn
:
:
NotEct
}
}
}
