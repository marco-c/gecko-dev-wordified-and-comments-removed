#
!
[
allow
(
clippy
:
:
allow_attributes
dead_code
reason
=
"
Exported
.
"
)
]
use
std
:
:
{
cell
:
:
RefCell
rc
:
:
Rc
}
;
use
neqo_common
:
:
{
event
:
:
Provider
as
_
IpTosDscp
}
;
use
neqo_crypto
:
:
{
AllowZeroRtt
AuthenticationStatus
ResumptionToken
}
;
use
neqo_transport
:
:
{
server
:
:
{
ConnectionRef
Server
ValidateAddress
}
Connection
ConnectionEvent
ConnectionParameters
State
Stats
}
;
use
test_fixture
:
:
{
default_client
now
CountingConnectionIdGenerator
}
;
pub
fn
assert_dscp
(
stats
:
&
Stats
)
{
assert_eq
!
(
stats
.
dscp_rx
[
IpTosDscp
:
:
Cs0
]
stats
.
packets_rx
)
;
}
pub
fn
new_server
(
params
:
ConnectionParameters
)
-
>
Server
{
Server
:
:
new
(
now
(
)
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
test_fixture
:
:
anti_replay
(
)
Box
:
:
new
(
AllowZeroRtt
{
}
)
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
params
)
.
expect
(
"
should
create
a
server
"
)
}
pub
fn
default_server
(
)
-
>
Server
{
new_server
(
ConnectionParameters
:
:
default
(
)
)
}
pub
fn
connected_server
(
server
:
&
Server
)
-
>
ConnectionRef
{
#
[
expect
(
clippy
:
:
mutable_key_type
reason
=
"
ActiveConnectionRef
:
:
Hash
doesn
'
t
access
any
of
the
interior
mutable
types
.
"
)
]
let
server_connections
=
server
.
active_connections
(
)
;
let
mut
confirmed
=
server_connections
.
iter
(
)
.
filter
(
|
c
:
&
&
ConnectionRef
|
*
c
.
borrow
(
)
.
state
(
)
=
=
State
:
:
Confirmed
)
;
let
c
=
confirmed
.
next
(
)
.
expect
(
"
one
confirmed
"
)
;
c
.
clone
(
)
}
pub
fn
connect
(
client
:
&
mut
Connection
server
:
&
mut
Server
)
-
>
ConnectionRef
{
server
.
set_validation
(
ValidateAddress
:
:
Never
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Init
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
let
out2
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
&
&
out2
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
_
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out2
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
assert_dscp
(
&
client
.
stats
(
)
)
;
connected_server
(
server
)
}
#
[
cfg
(
test
)
]
pub
fn
find_ticket
(
client
:
&
mut
Connection
)
-
>
ResumptionToken
{
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
ResumptionToken
(
token
)
=
e
{
Some
(
token
)
}
else
{
None
}
}
)
.
unwrap
(
)
}
#
[
cfg
(
test
)
]
pub
fn
generate_ticket
(
server
:
&
mut
Server
)
-
>
ResumptionToken
{
let
mut
client
=
default_client
(
)
;
let
server_conn
=
connect
(
&
mut
client
server
)
;
server_conn
.
borrow_mut
(
)
.
send_ticket
(
now
(
)
&
[
]
)
.
unwrap
(
)
;
let
out
=
server
.
process_output
(
now
(
)
)
;
client
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
let
ticket
=
find_ticket
(
&
mut
client
)
;
client
.
close
(
now
(
)
0
"
got
a
ticket
"
)
;
let
out
=
client
.
process_output
(
now
(
)
)
;
drop
(
server
.
process
(
out
.
dgram
(
)
now
(
)
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
1
)
;
ticket
}
