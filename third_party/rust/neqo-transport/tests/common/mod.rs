#
!
[
cfg_attr
(
feature
=
"
deny
-
warnings
"
deny
(
warnings
)
)
]
#
!
[
warn
(
clippy
:
:
pedantic
)
]
use
neqo_common
:
:
{
event
:
:
Provider
hex_with_len
qtrace
Datagram
Decoder
}
;
use
neqo_crypto
:
:
{
constants
:
:
{
TLS_AES_128_GCM_SHA256
TLS_VERSION_1_3
}
hkdf
hp
:
:
HpKey
Aead
AllowZeroRtt
AuthenticationStatus
ResumptionToken
}
;
use
neqo_transport
:
:
{
server
:
:
{
ActiveConnectionRef
Server
ValidateAddress
}
Connection
ConnectionEvent
ConnectionParameters
State
}
;
use
test_fixture
:
:
{
self
default_client
now
CountingConnectionIdGenerator
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
ops
:
:
Range
;
use
std
:
:
rc
:
:
Rc
;
pub
fn
default_server
(
)
-
>
Server
{
Server
:
:
new
(
now
(
)
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
test_fixture
:
:
anti_replay
(
)
Box
:
:
new
(
AllowZeroRtt
{
}
)
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
ConnectionParameters
:
:
default
(
)
)
.
expect
(
"
should
create
a
server
"
)
}
pub
fn
connected_server
(
server
:
&
mut
Server
)
-
>
ActiveConnectionRef
{
let
server_connections
=
server
.
active_connections
(
)
;
let
mut
confirmed
=
server_connections
.
iter
(
)
.
filter
(
|
c
:
&
&
ActiveConnectionRef
|
*
c
.
borrow
(
)
.
state
(
)
=
=
State
:
:
Confirmed
)
;
let
c
=
confirmed
.
next
(
)
.
expect
(
"
one
confirmed
"
)
;
assert
!
(
confirmed
.
next
(
)
.
is_none
(
)
"
only
one
confirmed
"
)
;
c
.
clone
(
)
}
pub
fn
connect
(
client
:
&
mut
Connection
server
:
&
mut
Server
)
-
>
ActiveConnectionRef
{
server
.
set_validation
(
ValidateAddress
:
:
Never
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Init
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
connected_server
(
server
)
}
#
[
must_use
]
pub
fn
decode_initial_header
(
dgram
:
&
Datagram
)
-
>
(
&
[
u8
]
&
[
u8
]
&
[
u8
]
&
[
u8
]
)
{
let
mut
dec
=
Decoder
:
:
new
(
&
dgram
[
.
.
]
)
;
let
type_and_ver
=
dec
.
decode
(
5
)
.
unwrap
(
)
.
to_vec
(
)
;
assert_eq
!
(
type_and_ver
[
0
]
&
0xf0
0xc0
)
;
let
dest_cid
=
dec
.
decode_vec
(
1
)
.
unwrap
(
)
;
let
src_cid
=
dec
.
decode_vec
(
1
)
.
unwrap
(
)
;
dec
.
skip_vvec
(
)
;
let
payload_len
=
usize
:
:
try_from
(
dec
.
decode_varint
(
)
.
unwrap
(
)
)
.
unwrap
(
)
;
let
pn_offset
=
dgram
.
len
(
)
-
dec
.
remaining
(
)
;
(
&
dgram
[
.
.
pn_offset
]
dest_cid
src_cid
dec
.
decode
(
payload_len
)
.
unwrap
(
)
)
}
#
[
must_use
]
pub
fn
client_initial_aead_and_hp
(
dcid
:
&
[
u8
]
)
-
>
(
Aead
HpKey
)
{
const
INITIAL_SALT
:
&
[
u8
]
=
&
[
0x38
0x76
0x2c
0xf7
0xf5
0x59
0x34
0xb3
0x4d
0x17
0x9a
0xe6
0xa4
0xc8
0x0c
0xad
0xcc
0xbb
0x7f
0x0a
]
;
let
initial_secret
=
hkdf
:
:
extract
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
Some
(
hkdf
:
:
import_key
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
INITIAL_SALT
)
.
as_ref
(
)
.
unwrap
(
)
)
hkdf
:
:
import_key
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
dcid
)
.
as_ref
(
)
.
unwrap
(
)
)
.
unwrap
(
)
;
let
secret
=
hkdf
:
:
expand_label
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
&
initial_secret
&
[
]
"
client
in
"
)
.
unwrap
(
)
;
(
Aead
:
:
new
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
&
secret
"
quic
"
)
.
unwrap
(
)
HpKey
:
:
extract
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
&
secret
"
quic
hp
"
)
.
unwrap
(
)
)
}
#
[
must_use
]
pub
fn
remove_header_protection
(
hp
:
&
HpKey
header
:
&
[
u8
]
payload
:
&
[
u8
]
)
-
>
(
Vec
<
u8
>
u64
)
{
let
mut
fixed_header
=
header
.
to_vec
(
)
;
let
pn_offset
=
header
.
len
(
)
;
fixed_header
.
extend_from_slice
(
&
payload
[
.
.
4
]
)
;
let
mask
=
hp
.
mask
(
&
payload
[
4
.
.
20
]
)
.
unwrap
(
)
;
fixed_header
[
0
]
^
=
mask
[
0
]
&
0xf
;
let
pn_len
=
1
+
usize
:
:
from
(
fixed_header
[
0
]
&
0x3
)
;
for
i
in
0
.
.
pn_len
{
fixed_header
[
pn_offset
+
i
]
^
=
mask
[
1
+
i
]
;
}
fixed_header
.
truncate
(
pn_offset
+
pn_len
)
;
let
pn
=
Decoder
:
:
new
(
&
fixed_header
[
pn_offset
.
.
]
)
.
decode_uint
(
pn_len
)
.
unwrap
(
)
;
(
fixed_header
pn
)
}
pub
fn
apply_header_protection
(
hp
:
&
HpKey
packet
:
&
mut
[
u8
]
pn_bytes
:
Range
<
usize
>
)
{
let
sample_start
=
pn_bytes
.
start
+
4
;
let
sample_end
=
sample_start
+
16
;
let
mask
=
hp
.
mask
(
&
packet
[
sample_start
.
.
sample_end
]
)
.
unwrap
(
)
;
qtrace
!
(
"
sample
=
{
}
mask
=
{
}
"
hex_with_len
(
&
packet
[
sample_start
.
.
sample_end
]
)
hex_with_len
(
&
mask
)
)
;
packet
[
0
]
^
=
mask
[
0
]
&
0xf
;
for
i
in
0
.
.
(
pn_bytes
.
end
-
pn_bytes
.
start
)
{
packet
[
pn_bytes
.
start
+
i
]
^
=
mask
[
1
+
i
]
;
}
}
pub
fn
get_ticket
(
server
:
&
mut
Server
)
-
>
ResumptionToken
{
let
mut
client
=
default_client
(
)
;
let
mut
server_conn
=
connect
(
&
mut
client
server
)
;
server_conn
.
borrow_mut
(
)
.
send_ticket
(
now
(
)
&
[
]
)
.
unwrap
(
)
;
let
dgram
=
server
.
process
(
None
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
ticket
=
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
ConnectionEvent
:
:
ResumptionToken
(
token
)
=
e
{
Some
(
token
)
}
else
{
None
}
}
)
.
unwrap
(
)
;
client
.
close
(
now
(
)
0
"
got
a
ticket
"
)
;
let
dgram
=
client
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
_
=
server
.
process
(
dgram
now
(
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
1
)
;
ticket
}
