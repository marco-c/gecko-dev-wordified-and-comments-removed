#
!
[
cfg_attr
(
feature
=
"
deny
-
warnings
"
deny
(
warnings
)
)
]
#
!
[
warn
(
clippy
:
:
pedantic
)
]
pub
mod
connection
;
mod
delay
;
mod
drop
;
pub
mod
rng
;
mod
taildrop
;
use
neqo_common
:
:
{
qdebug
qinfo
qtrace
Datagram
Encoder
}
;
use
neqo_transport
:
:
Output
;
use
rng
:
:
Random
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
cmp
:
:
min
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
test_fixture
:
:
{
self
now
}
;
use
NodeState
:
:
{
Active
Idle
Waiting
}
;
pub
mod
network
{
pub
use
super
:
:
delay
:
:
Delay
;
pub
use
super
:
:
drop
:
:
Drop
;
pub
use
super
:
:
taildrop
:
:
TailDrop
;
}
type
Rng
=
Rc
<
RefCell
<
Random
>
>
;
#
[
macro_export
]
macro_rules
!
boxed
{
[
(
v
:
expr
)
+
(
)
?
]
=
>
{
vec
!
[
(
Box
:
:
new
(
v
)
as
_
)
+
]
}
;
}
#
[
macro_export
]
macro_rules
!
simulate
{
(
n
:
ident
[
(
v
:
expr
)
+
(
)
?
]
(
)
?
)
=
>
{
simulate
!
(
n
(
)
[
(
|
_
|
v
)
+
]
)
;
}
;
(
n
:
ident
setup
:
expr
[
(
v
:
expr
)
+
(
)
?
]
(
)
?
)
=
>
{
#
[
test
]
fn
n
(
)
{
let
fixture
=
setup
;
let
mut
nodes
:
Vec
<
Box
<
dyn
crate
:
:
sim
:
:
Node
>
>
=
Vec
:
:
new
(
)
;
(
let
f
:
Box
<
dyn
FnOnce
(
&
_
)
-
>
_
>
=
Box
:
:
new
(
v
)
;
nodes
.
push
(
Box
:
:
new
(
f
(
&
fixture
)
)
)
;
)
*
let
mut
sim
=
Simulator
:
:
new
(
stringify
!
(
n
)
nodes
)
;
if
let
Ok
(
seed
)
=
std
:
:
env
:
:
var
(
"
SIMULATION_SEED
"
)
{
sim
.
seed_str
(
seed
)
;
}
sim
.
run
(
)
;
}
}
;
}
pub
trait
Node
:
Debug
{
fn
init
(
&
mut
self
_rng
:
Rng
_now
:
Instant
)
{
}
fn
process
(
&
mut
self
d
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Output
;
fn
done
(
&
self
)
-
>
bool
{
true
}
fn
print_summary
(
&
self
_test_name
:
&
str
)
{
}
}
#
[
derive
(
Debug
PartialEq
)
]
enum
NodeState
{
Active
Waiting
(
Instant
)
Idle
}
#
[
derive
(
Debug
)
]
struct
NodeHolder
{
node
:
Box
<
dyn
Node
>
state
:
NodeState
}
impl
NodeHolder
{
fn
ready
(
&
self
now
:
Instant
)
-
>
bool
{
match
self
.
state
{
Active
=
>
true
Waiting
(
t
)
=
>
t
>
=
now
Idle
=
>
false
}
}
}
pub
struct
Simulator
{
name
:
String
nodes
:
Vec
<
NodeHolder
>
rng
:
Rng
}
impl
Simulator
{
pub
fn
new
(
name
:
impl
AsRef
<
str
>
nodes
:
impl
IntoIterator
<
Item
=
Box
<
dyn
Node
>
>
)
-
>
Self
{
let
name
=
String
:
:
from
(
name
.
as_ref
(
)
)
;
let
mut
it
=
nodes
.
into_iter
(
)
;
let
nodes
=
it
.
next
(
)
.
map
(
|
node
|
NodeHolder
{
node
state
:
Active
}
)
.
into_iter
(
)
.
chain
(
it
.
map
(
|
node
|
NodeHolder
{
node
state
:
Idle
}
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
Self
{
name
nodes
rng
:
Rc
:
:
default
(
)
}
}
pub
fn
seed
(
&
mut
self
seed
:
[
u8
;
32
]
)
{
self
.
rng
=
Rc
:
:
new
(
RefCell
:
:
new
(
Random
:
:
new
(
seed
)
)
)
;
}
pub
fn
seed_str
(
&
mut
self
seed
:
impl
AsRef
<
str
>
)
{
let
seed
=
Encoder
:
:
from_hex
(
seed
)
;
self
.
seed
(
<
[
u8
;
32
]
>
:
:
try_from
(
seed
.
as_ref
(
)
)
.
unwrap
(
)
)
;
}
fn
next_time
(
&
self
now
:
Instant
)
-
>
Instant
{
let
mut
next
=
None
;
for
n
in
&
self
.
nodes
{
match
n
.
state
{
Idle
=
>
continue
Active
=
>
return
now
Waiting
(
a
)
=
>
next
=
Some
(
next
.
map_or
(
a
|
b
|
min
(
a
b
)
)
)
}
}
next
.
expect
(
"
a
node
cannot
be
idle
and
not
done
"
)
}
pub
fn
run
(
mut
self
)
-
>
Duration
{
let
start
=
now
(
)
;
let
mut
now
=
start
;
let
mut
dgram
=
None
;
for
n
in
&
mut
self
.
nodes
{
n
.
node
.
init
(
self
.
rng
.
clone
(
)
now
)
;
}
println
!
(
"
{
}
:
seed
{
}
"
self
.
name
self
.
rng
.
borrow
(
)
.
seed_str
(
)
)
;
let
real_start
=
Instant
:
:
now
(
)
;
loop
{
for
n
in
&
mut
self
.
nodes
{
if
dgram
.
is_none
(
)
&
&
!
n
.
ready
(
now
)
{
qdebug
!
(
[
self
.
name
]
"
skipping
{
:
?
}
"
n
.
node
)
;
continue
;
}
qdebug
!
(
[
self
.
name
]
"
processing
{
:
?
}
"
n
.
node
)
;
let
res
=
n
.
node
.
process
(
dgram
.
take
(
)
now
)
;
n
.
state
=
match
res
{
Output
:
:
Datagram
(
d
)
=
>
{
qtrace
!
(
[
self
.
name
]
"
=
>
datagram
{
}
"
d
.
len
(
)
)
;
dgram
=
Some
(
d
)
;
Active
}
Output
:
:
Callback
(
delay
)
=
>
{
qtrace
!
(
[
self
.
name
]
"
=
>
callback
{
:
?
}
"
delay
)
;
assert_ne
!
(
delay
Duration
:
:
new
(
0
0
)
)
;
Waiting
(
now
+
delay
)
}
Output
:
:
None
=
>
{
qtrace
!
(
[
self
.
name
]
"
=
>
nothing
"
)
;
assert
!
(
n
.
node
.
done
(
)
"
nodes
have
to
be
done
when
they
go
idle
"
)
;
Idle
}
}
;
}
if
self
.
nodes
.
iter
(
)
.
all
(
|
n
|
n
.
node
.
done
(
)
)
{
let
real_elapsed
=
Instant
:
:
now
(
)
-
real_start
;
println
!
(
"
{
}
:
real
elapsed
time
:
{
:
?
}
"
self
.
name
real_elapsed
)
;
let
elapsed
=
now
-
start
;
println
!
(
"
{
}
:
simulated
elapsed
time
:
{
:
?
}
"
self
.
name
elapsed
)
;
for
n
in
&
self
.
nodes
{
n
.
node
.
print_summary
(
&
self
.
name
)
;
}
return
elapsed
;
}
if
dgram
.
is_none
(
)
{
let
next
=
self
.
next_time
(
now
)
;
if
next
>
now
{
qinfo
!
(
[
self
.
name
]
"
advancing
time
by
{
:
?
}
to
{
:
?
}
"
next
-
now
next
-
start
)
;
now
=
next
;
}
}
}
}
}
