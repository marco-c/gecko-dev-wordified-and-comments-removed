#
!
[
allow
(
clippy
:
:
module_name_repetitions
)
]
use
super
:
:
Node
;
use
neqo_common
:
:
{
qtrace
Datagram
}
;
use
neqo_transport
:
:
Output
;
use
std
:
:
cmp
:
:
max
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
const
ONE_SECOND_NS
:
u128
=
1_000_000_000
;
pub
struct
TailDrop
{
overhead
:
usize
rate
:
usize
capacity
:
usize
used
:
usize
queue
:
VecDeque
<
Datagram
>
next_deque
:
Option
<
Instant
>
sub_ns_delay
:
u32
delay
:
Duration
on_link
:
VecDeque
<
(
Instant
Datagram
)
>
received
:
usize
dropped
:
usize
delivered
:
usize
maxq
:
usize
}
impl
TailDrop
{
pub
fn
new
(
rate
:
usize
capacity
:
usize
delay
:
Duration
)
-
>
Self
{
Self
{
overhead
:
64
rate
capacity
used
:
0
queue
:
VecDeque
:
:
new
(
)
next_deque
:
None
sub_ns_delay
:
0
delay
on_link
:
VecDeque
:
:
new
(
)
received
:
0
dropped
:
0
delivered
:
0
maxq
:
0
}
}
pub
fn
dsl_uplink
(
)
-
>
Self
{
TailDrop
:
:
new
(
1_000_000
32_768
Duration
:
:
from_millis
(
50
)
)
}
pub
fn
dsl_downlink
(
)
-
>
Self
{
TailDrop
:
:
new
(
200_000
8_192
Duration
:
:
from_millis
(
50
)
)
}
fn
size
(
&
self
d
:
&
Datagram
)
-
>
usize
{
d
.
len
(
)
+
self
.
overhead
}
fn
send
(
&
mut
self
d
:
Datagram
now
:
Instant
)
{
let
sz
=
u128
:
:
try_from
(
self
.
size
(
&
d
)
)
.
unwrap
(
)
;
let
t
=
sz
*
(
ONE_SECOND_NS
<
<
32
)
/
u128
:
:
try_from
(
self
.
rate
)
.
unwrap
(
)
+
u128
:
:
from
(
self
.
sub_ns_delay
)
;
let
send_ns
=
u64
:
:
try_from
(
t
>
>
32
)
.
unwrap
(
)
;
assert_ne
!
(
send_ns
0
"
sending
a
packet
takes
<
1ns
"
)
;
self
.
sub_ns_delay
=
u32
:
:
try_from
(
t
&
u128
:
:
from
(
u32
:
:
MAX
)
)
.
unwrap
(
)
;
let
deque_time
=
now
+
Duration
:
:
from_nanos
(
send_ns
)
;
self
.
next_deque
=
Some
(
deque_time
)
;
let
delivery_time
=
deque_time
+
self
.
delay
;
self
.
on_link
.
push_back
(
(
delivery_time
d
)
)
;
}
fn
maybe_enqueue
(
&
mut
self
d
:
Datagram
now
:
Instant
)
{
self
.
received
+
=
1
;
if
self
.
next_deque
.
is_none
(
)
{
debug_assert
!
(
self
.
queue
.
is_empty
(
)
)
;
self
.
send
(
d
now
)
;
}
else
if
self
.
used
+
self
.
size
(
&
d
)
<
=
self
.
capacity
{
self
.
used
+
=
self
.
size
(
&
d
)
;
self
.
maxq
=
max
(
self
.
maxq
self
.
used
)
;
self
.
queue
.
push_back
(
d
)
;
}
else
{
qtrace
!
(
"
taildrop
dropping
{
}
bytes
"
d
.
len
(
)
)
;
self
.
dropped
+
=
1
;
}
}
fn
maybe_send
(
&
mut
self
now
:
Instant
)
{
if
self
.
next_deque
.
as_ref
(
)
.
map_or
(
false
|
t
|
*
t
<
=
now
)
{
if
let
Some
(
d
)
=
self
.
queue
.
pop_front
(
)
{
self
.
used
-
=
self
.
size
(
&
d
)
;
self
.
send
(
d
now
)
;
}
else
{
self
.
next_deque
=
None
;
self
.
sub_ns_delay
=
0
;
}
}
}
}
impl
Node
for
TailDrop
{
fn
process
(
&
mut
self
d
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Output
{
if
let
Some
(
dgram
)
=
d
{
self
.
maybe_enqueue
(
dgram
now
)
;
}
self
.
maybe_send
(
now
)
;
if
let
Some
(
(
t
_
)
)
=
self
.
on_link
.
front
(
)
{
if
*
t
<
=
now
{
let
(
_
d
)
=
self
.
on_link
.
pop_front
(
)
.
unwrap
(
)
;
self
.
delivered
+
=
1
;
Output
:
:
Datagram
(
d
)
}
else
{
Output
:
:
Callback
(
*
t
-
now
)
}
}
else
{
Output
:
:
None
}
}
fn
print_summary
(
&
self
test_name
:
&
str
)
{
println
!
(
"
{
}
:
taildrop
:
rx
{
}
drop
{
}
tx
{
}
maxq
{
}
"
test_name
self
.
received
self
.
dropped
self
.
delivered
self
.
maxq
)
;
}
}
impl
Debug
for
TailDrop
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
taildrop
"
)
}
}
