#
!
[
cfg_attr
(
feature
=
"
deny
-
warnings
"
deny
(
warnings
)
)
]
#
!
[
warn
(
clippy
:
:
pedantic
)
]
use
neqo_common
:
:
{
hex_with_len
qdebug
qtrace
Datagram
Decoder
Encoder
}
;
use
neqo_crypto
:
:
{
aead
:
:
Aead
constants
:
:
{
TLS_AES_128_GCM_SHA256
TLS_VERSION_1_3
}
hkdf
hp
:
:
HpKey
AllowZeroRtt
AuthenticationStatus
}
;
use
neqo_transport
:
:
{
server
:
:
{
ActiveConnectionRef
Server
ValidateAddress
}
Connection
ConnectionError
Error
FixedConnectionIdManager
Output
QuicVersion
State
StreamType
}
;
use
test_fixture
:
:
{
self
assertions
default_client
now
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
net
:
:
{
IpAddr
Ipv4Addr
SocketAddr
}
;
use
std
:
:
ops
:
:
Range
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
Duration
;
fn
default_server
(
)
-
>
Server
{
Server
:
:
new
(
now
(
)
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN
test_fixture
:
:
anti_replay
(
)
Box
:
:
new
(
AllowZeroRtt
{
}
)
Rc
:
:
new
(
RefCell
:
:
new
(
FixedConnectionIdManager
:
:
new
(
9
)
)
)
)
.
expect
(
"
should
create
a
server
"
)
}
fn
connected_server
(
server
:
&
mut
Server
)
-
>
ActiveConnectionRef
{
let
server_connections
=
server
.
active_connections
(
)
;
let
mut
confirmed
=
server_connections
.
iter
(
)
.
filter
(
|
c
:
&
&
ActiveConnectionRef
|
*
c
.
borrow
(
)
.
state
(
)
=
=
State
:
:
Confirmed
)
;
let
c
=
confirmed
.
next
(
)
.
expect
(
"
one
confirmed
"
)
;
assert
!
(
confirmed
.
next
(
)
.
is_none
(
)
"
only
one
confirmed
"
)
;
c
.
clone
(
)
}
fn
connect
(
client
:
&
mut
Connection
server
:
&
mut
Server
)
-
>
ActiveConnectionRef
{
server
.
set_validation
(
ValidateAddress
:
:
Never
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Init
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
connected_server
(
server
)
}
fn
complete_connection
(
client
:
&
mut
Connection
server
:
&
mut
Server
mut
datagram
:
Option
<
Datagram
>
)
-
>
ActiveConnectionRef
{
let
is_done
=
|
c
:
&
Connection
|
matches
!
(
c
.
state
(
)
State
:
:
Confirmed
|
State
:
:
Closing
{
.
.
}
|
State
:
:
Closed
(
.
.
)
)
;
while
!
is_done
(
client
)
{
let
_
=
test_fixture
:
:
maybe_authenticate
(
client
)
;
let
out
=
client
.
process
(
datagram
now
(
)
)
;
let
out
=
server
.
process
(
out
.
dgram
(
)
now
(
)
)
;
datagram
=
out
.
dgram
(
)
;
}
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Confirmed
)
;
connected_server
(
server
)
}
#
[
test
]
fn
single_client
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
}
#
[
test
]
fn
duplicate_initial
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Init
)
;
let
initial
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
initial
.
is_some
(
)
)
;
let
server_initial
=
server
.
process
(
initial
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
server_initial
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
initial
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
1
)
;
complete_connection
(
&
mut
client
&
mut
server
server_initial
)
;
}
#
[
test
]
fn
duplicate_initial_new_path
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Init
)
;
let
initial
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
unwrap
(
)
;
let
other
=
Datagram
:
:
new
(
SocketAddr
:
:
new
(
initial
.
source
(
)
.
ip
(
)
initial
.
source
(
)
.
port
(
)
^
23
)
initial
.
destination
(
)
&
initial
[
.
.
]
)
;
let
dgram
=
server
.
process
(
Some
(
other
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
server_initial
=
server
.
process
(
Some
(
initial
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
server_initial
.
is_some
(
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
2
)
;
complete_connection
(
&
mut
client
&
mut
server
server_initial
)
;
}
#
[
test
]
fn
different_initials_same_path
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client1
=
default_client
(
)
;
let
mut
client2
=
default_client
(
)
;
let
client_initial1
=
client1
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial1
.
is_some
(
)
)
;
let
client_initial2
=
client2
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial2
.
is_some
(
)
)
;
let
server_initial1
=
server
.
process
(
client_initial1
now
(
)
)
.
dgram
(
)
;
assert
!
(
server_initial1
.
is_some
(
)
)
;
let
server_initial2
=
server
.
process
(
client_initial2
now
(
)
)
.
dgram
(
)
;
assert
!
(
server_initial2
.
is_some
(
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
2
)
;
complete_connection
(
&
mut
client1
&
mut
server
server_initial1
)
;
complete_connection
(
&
mut
client2
&
mut
server
server_initial2
)
;
}
#
[
test
]
fn
same_initial_after_connected
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
let
client_initial
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial
.
is_some
(
)
)
;
let
server_initial
=
server
.
process
(
client_initial
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
server_initial
.
is_some
(
)
)
;
complete_connection
(
&
mut
client
&
mut
server
server_initial
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
0
)
;
let
dgram
=
server
.
process
(
client_initial
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
1
)
;
}
#
[
test
]
fn
drop_non_initial
(
)
{
const
CID
:
&
[
u8
]
=
&
[
55
;
8
]
;
let
mut
server
=
default_server
(
)
;
let
mut
header
=
neqo_common
:
:
Encoder
:
:
with_capacity
(
1200
)
;
header
.
encode_byte
(
0xfa
)
.
encode_uint
(
4
QuicVersion
:
:
default
(
)
.
as_u32
(
)
)
.
encode_vec
(
1
CID
)
.
encode_vec
(
1
CID
)
;
let
mut
bogus_data
:
Vec
<
u8
>
=
header
.
into
(
)
;
bogus_data
.
resize
(
1200
66
)
;
let
bogus
=
Datagram
:
:
new
(
test_fixture
:
:
loopback
(
)
test_fixture
:
:
loopback
(
)
bogus_data
)
;
assert
!
(
server
.
process
(
Some
(
bogus
)
now
(
)
)
.
dgram
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
retry_basic
(
)
{
let
mut
server
=
default_server
(
)
;
server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
client
=
default_client
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
&
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
_
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
connected_server
(
&
mut
server
)
;
}
#
[
test
]
fn
retry_expired
(
)
{
let
mut
server
=
default_server
(
)
;
server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
client
=
default_client
(
)
;
let
mut
now
=
now
(
)
;
let
dgram
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
&
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_secs
(
60
)
;
let
dgram
=
server
.
process
(
dgram
now
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
}
fn
get_ticket
(
server
:
&
mut
Server
)
-
>
Vec
<
u8
>
{
let
mut
client
=
default_client
(
)
;
let
mut
server_conn
=
connect
(
&
mut
client
server
)
;
server_conn
.
borrow_mut
(
)
.
send_ticket
(
now
(
)
&
[
]
)
.
unwrap
(
)
;
let
dgram
=
server
.
process
(
None
now
(
)
)
.
dgram
(
)
;
client
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
assert_eq
!
(
server
.
active_connections
(
)
.
len
(
)
1
)
;
client
.
resumption_token
(
)
.
unwrap
(
)
}
#
[
test
]
fn
retry_0rtt
(
)
{
let
mut
server
=
default_server
(
)
;
let
token
=
get_ticket
(
&
mut
server
)
;
server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
client
=
default_client
(
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
unwrap
(
)
;
let
client_stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream
&
[
1
2
3
]
)
.
unwrap
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_coalesced_0rtt
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_coalesced_0rtt
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
connected_server
(
&
mut
server
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
}
#
[
test
]
fn
new_token_0rtt
(
)
{
let
mut
server
=
default_server
(
)
;
let
token
=
get_ticket
(
&
mut
server
)
;
server
.
set_validation
(
ValidateAddress
:
:
NoToken
)
;
let
mut
client
=
default_client
(
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
unwrap
(
)
;
let
client_stream
=
client
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
client
.
stream_send
(
client_stream
&
[
1
2
3
]
)
.
unwrap
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
true
)
;
assertions
:
:
assert_coalesced_0rtt
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
false
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
connected_server
(
&
mut
server
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
}
#
[
test
]
fn
retry_different_ip
(
)
{
let
mut
server
=
default_server
(
)
;
server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
client
=
default_client
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
&
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
dgram
.
unwrap
(
)
;
let
other_v4
=
IpAddr
:
:
V4
(
Ipv4Addr
:
:
new
(
127
0
0
2
)
)
;
let
other_addr
=
SocketAddr
:
:
new
(
other_v4
443
)
;
let
from_other
=
Datagram
:
:
new
(
other_addr
dgram
.
destination
(
)
&
dgram
[
.
.
]
)
;
let
dgram
=
server
.
process
(
Some
(
from_other
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
}
#
[
test
]
fn
new_token_different_ip
(
)
{
let
mut
server
=
default_server
(
)
;
let
token
=
get_ticket
(
&
mut
server
)
;
server
.
set_validation
(
ValidateAddress
:
:
NoToken
)
;
let
mut
client
=
default_client
(
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
unwrap
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
true
)
;
let
d
=
dgram
.
unwrap
(
)
;
let
src
=
SocketAddr
:
:
new
(
IpAddr
:
:
V4
(
Ipv4Addr
:
:
new
(
127
0
0
2
)
)
d
.
source
(
)
.
port
(
)
)
;
let
dgram
=
Some
(
Datagram
:
:
new
(
src
d
.
destination
(
)
&
d
[
.
.
]
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
new_token_different_port
(
)
{
let
mut
server
=
default_server
(
)
;
let
token
=
get_ticket
(
&
mut
server
)
;
server
.
set_validation
(
ValidateAddress
:
:
NoToken
)
;
let
mut
client
=
default_client
(
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
unwrap
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
true
)
;
let
d
=
dgram
.
unwrap
(
)
;
let
src
=
SocketAddr
:
:
new
(
d
.
source
(
)
.
ip
(
)
d
.
source
(
)
.
port
(
)
+
1
)
;
let
dgram
=
Some
(
Datagram
:
:
new
(
src
d
.
destination
(
)
&
d
[
.
.
]
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
false
)
;
}
#
[
test
]
fn
new_token_expired
(
)
{
let
mut
server
=
default_server
(
)
;
let
token
=
get_ticket
(
&
mut
server
)
;
server
.
set_validation
(
ValidateAddress
:
:
NoToken
)
;
let
mut
client
=
default_client
(
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
unwrap
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_initial
(
dgram
.
as_ref
(
)
.
unwrap
(
)
true
)
;
let
the_future
=
now
(
)
+
Duration
:
:
from_secs
(
60
*
60
*
24
*
30
)
;
let
d
=
dgram
.
unwrap
(
)
;
let
src
=
SocketAddr
:
:
new
(
d
.
source
(
)
.
ip
(
)
d
.
source
(
)
.
port
(
)
+
1
)
;
let
dgram
=
Some
(
Datagram
:
:
new
(
src
d
.
destination
(
)
&
d
[
.
.
]
)
)
;
let
dgram
=
server
.
process
(
dgram
the_future
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
dgram
.
as_ref
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
retry_after_initial
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
retry_server
=
default_server
(
)
;
retry_server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
client
=
default_client
(
)
;
let
cinit
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
cinit
.
is_some
(
)
)
;
let
server_flight
=
server
.
process
(
cinit
.
clone
(
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
server_flight
.
is_some
(
)
)
;
let
si
=
server_flight
.
as_ref
(
)
.
unwrap
(
)
;
let
truncated
=
&
si
[
.
.
(
si
.
len
(
)
-
1
)
]
;
let
just_initial
=
Datagram
:
:
new
(
si
.
source
(
)
si
.
destination
(
)
truncated
)
;
let
dgram
=
client
.
process
(
Some
(
just_initial
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
*
client
.
state
(
)
!
=
State
:
:
Connected
)
;
let
retry
=
retry_server
.
process
(
cinit
now
(
)
)
.
dgram
(
)
;
assert
!
(
retry
.
is_some
(
)
)
;
assertions
:
:
assert_retry
(
&
retry
.
as_ref
(
)
.
unwrap
(
)
)
;
let
junk
=
client
.
process
(
retry
now
(
)
)
.
dgram
(
)
;
assert
!
(
junk
.
is_none
(
)
)
;
let
dgram
=
client
.
process
(
server_flight
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
test_fixture
:
:
maybe_authenticate
(
&
mut
client
)
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert_eq
!
(
*
client
.
state
(
)
State
:
:
Connected
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
connected_server
(
&
mut
server
)
;
}
#
[
test
]
fn
retry_bad_integrity
(
)
{
let
mut
server
=
default_server
(
)
;
server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
client
=
default_client
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
retry
=
&
dgram
.
as_ref
(
)
.
unwrap
(
)
;
assertions
:
:
assert_retry
(
retry
)
;
let
mut
tweaked
=
retry
.
to_vec
(
)
;
tweaked
[
retry
.
len
(
)
-
1
]
^
=
0x45
;
let
tweaked_packet
=
Datagram
:
:
new
(
retry
.
source
(
)
retry
.
destination
(
)
tweaked
)
;
let
dgram
=
client
.
process
(
Some
(
tweaked_packet
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
}
#
[
test
]
fn
retry_bad_token
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
retry_server
=
default_server
(
)
;
retry_server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
server
=
default_server
(
)
;
let
client_initial1
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial1
.
is_some
(
)
)
;
let
retry
=
retry_server
.
process
(
client_initial1
now
(
)
)
.
dgram
(
)
;
assert
!
(
retry
.
is_some
(
)
)
;
let
client_initial2
=
client
.
process
(
retry
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial2
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
client_initial2
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
}
#
[
test
]
fn
retry_after_pto
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
now
=
now
(
)
;
let
ci
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
ci
.
is_some
(
)
)
;
now
+
=
Duration
:
:
from_secs
(
1
)
;
let
pto1
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pto1
.
unwrap
(
)
.
len
(
)
>
=
1200
)
;
let
pto2
=
client
.
process
(
None
now
)
.
dgram
(
)
;
assert
!
(
pto2
.
unwrap
(
)
.
len
(
)
>
=
1200
)
;
let
cb
=
client
.
process
(
None
now
)
.
callback
(
)
;
assert_ne
!
(
cb
Duration
:
:
new
(
0
0
)
)
;
let
retry
=
server
.
process
(
ci
now
)
.
dgram
(
)
;
assertions
:
:
assert_retry
(
&
retry
.
as_ref
(
)
.
unwrap
(
)
)
;
let
ci2
=
client
.
process
(
retry
now
)
.
dgram
(
)
;
assert
!
(
ci2
.
unwrap
(
)
.
len
(
)
>
=
1200
)
;
}
fn
client_initial_aead_and_hp
(
dcid
:
&
[
u8
]
)
-
>
(
Aead
HpKey
)
{
const
INITIAL_SALT
:
&
[
u8
]
=
&
[
0xaf
0xbf
0xec
0x28
0x99
0x93
0xd2
0x4c
0x9e
0x97
0x86
0xf1
0x9c
0x61
0x11
0xe0
0x43
0x90
0xa8
0x99
]
;
let
initial_secret
=
hkdf
:
:
extract
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
Some
(
hkdf
:
:
import_key
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
INITIAL_SALT
)
.
as_ref
(
)
.
unwrap
(
)
)
hkdf
:
:
import_key
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
dcid
)
.
as_ref
(
)
.
unwrap
(
)
)
.
unwrap
(
)
;
let
secret
=
hkdf
:
:
expand_label
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
&
initial_secret
&
[
]
"
client
in
"
)
.
unwrap
(
)
;
(
Aead
:
:
new
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
&
secret
"
quic
"
)
.
unwrap
(
)
HpKey
:
:
extract
(
TLS_VERSION_1_3
TLS_AES_128_GCM_SHA256
&
secret
"
quic
hp
"
)
.
unwrap
(
)
)
}
fn
decode_initial_header
(
dgram
:
&
Datagram
)
-
>
(
&
[
u8
]
&
[
u8
]
&
[
u8
]
&
[
u8
]
)
{
let
mut
dec
=
Decoder
:
:
new
(
&
dgram
[
.
.
]
)
;
let
type_and_ver
=
dec
.
decode
(
5
)
.
unwrap
(
)
.
to_vec
(
)
;
assert_eq
!
(
type_and_ver
[
0
]
&
0xf0
0xc0
)
;
let
dest_cid
=
dec
.
decode_vec
(
1
)
.
unwrap
(
)
;
let
src_cid
=
dec
.
decode_vec
(
1
)
.
unwrap
(
)
;
dec
.
skip_vvec
(
)
;
let
payload_len
=
usize
:
:
try_from
(
dec
.
decode_varint
(
)
.
unwrap
(
)
)
.
unwrap
(
)
;
let
pn_offset
=
dgram
.
len
(
)
-
dec
.
remaining
(
)
;
(
&
dgram
[
.
.
pn_offset
]
dest_cid
src_cid
dec
.
decode
(
payload_len
)
.
unwrap
(
)
)
}
fn
remove_header_protection
(
hp
:
&
HpKey
header
:
&
[
u8
]
payload
:
&
[
u8
]
)
-
>
(
Vec
<
u8
>
u64
)
{
let
mut
fixed_header
=
header
.
to_vec
(
)
;
let
pn_offset
=
header
.
len
(
)
;
fixed_header
.
extend_from_slice
(
&
payload
[
.
.
4
]
)
;
let
mask
=
hp
.
mask
(
&
payload
[
4
.
.
20
]
)
.
unwrap
(
)
;
fixed_header
[
0
]
^
=
mask
[
0
]
&
0xf
;
let
pn_len
=
1
+
usize
:
:
from
(
fixed_header
[
0
]
&
0x3
)
;
for
i
in
0
.
.
pn_len
{
fixed_header
[
pn_offset
+
i
]
^
=
mask
[
1
+
i
]
;
}
fixed_header
.
truncate
(
pn_offset
+
pn_len
)
;
let
pn
=
Decoder
:
:
new
(
&
fixed_header
[
pn_offset
.
.
]
)
.
decode_uint
(
pn_len
)
.
unwrap
(
)
;
(
fixed_header
pn
)
}
fn
apply_header_protection
(
hp
:
&
HpKey
packet
:
&
mut
[
u8
]
pn_bytes
:
Range
<
usize
>
)
{
let
sample_start
=
pn_bytes
.
start
+
4
;
let
sample_end
=
sample_start
+
16
;
let
mask
=
hp
.
mask
(
&
packet
[
sample_start
.
.
sample_end
]
)
.
unwrap
(
)
;
qtrace
!
(
"
sample
=
{
}
mask
=
{
}
"
hex_with_len
(
&
packet
[
sample_start
.
.
sample_end
]
)
hex_with_len
(
&
mask
)
)
;
packet
[
0
]
^
=
mask
[
0
]
&
0xf
;
for
i
in
0
.
.
(
pn_bytes
.
end
-
pn_bytes
.
start
)
{
packet
[
pn_bytes
.
start
+
i
]
^
=
mask
[
1
+
i
]
;
}
}
#
[
test
]
#
[
allow
(
clippy
:
:
shadow_unrelated
)
]
fn
mitm_retry
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
retry_server
=
default_server
(
)
;
retry_server
.
set_validation
(
ValidateAddress
:
:
Always
)
;
let
mut
server
=
default_server
(
)
;
let
client_initial1
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial1
.
is_some
(
)
)
;
let
retry
=
retry_server
.
process
(
client_initial1
now
(
)
)
.
dgram
(
)
;
assert
!
(
retry
.
is_some
(
)
)
;
let
client_initial2
=
client
.
process
(
retry
now
(
)
)
.
dgram
(
)
;
assert
!
(
client_initial2
.
is_some
(
)
)
;
let
client_initial2
=
client_initial2
.
unwrap
(
)
;
let
(
protected_header
d_cid
s_cid
payload
)
=
decode_initial_header
(
&
client_initial2
)
;
let
(
aead
hp
)
=
client_initial_aead_and_hp
(
&
d_cid
)
;
let
(
header
pn
)
=
remove_header_protection
(
&
hp
protected_header
payload
)
;
let
pn_len
=
header
.
len
(
)
-
protected_header
.
len
(
)
;
assert_eq
!
(
pn
1
)
;
let
mut
plaintext_buf
=
vec
!
[
0
;
client_initial2
.
len
(
)
]
;
let
plaintext
=
aead
.
decrypt
(
pn
&
header
&
payload
[
pn_len
.
.
]
&
mut
plaintext_buf
)
.
unwrap
(
)
;
let
mut
enc
=
Encoder
:
:
with_capacity
(
header
.
len
(
)
)
;
enc
.
encode
(
&
header
[
.
.
5
]
)
.
encode_vec
(
1
d_cid
)
.
encode_vec
(
1
s_cid
)
.
encode_vvec
(
&
[
]
)
.
encode_varint
(
u64
:
:
try_from
(
payload
.
len
(
)
)
.
unwrap
(
)
)
;
let
pn_offset
=
enc
.
len
(
)
;
let
notoken_header
=
enc
.
encode_uint
(
pn_len
pn
)
.
to_vec
(
)
;
qtrace
!
(
"
notoken_header
=
{
}
"
hex_with_len
(
&
notoken_header
)
)
;
let
mut
notoken_packet
=
Encoder
:
:
with_capacity
(
1200
)
.
encode
(
&
notoken_header
)
.
to_vec
(
)
;
notoken_packet
.
resize_with
(
1200
u8
:
:
default
)
;
aead
.
encrypt
(
pn
&
notoken_header
plaintext
&
mut
notoken_packet
[
notoken_header
.
len
(
)
.
.
]
)
.
unwrap
(
)
;
apply_header_protection
(
&
hp
&
mut
notoken_packet
pn_offset
.
.
(
pn_offset
+
pn_len
)
)
;
qtrace
!
(
"
packet
=
{
}
"
hex_with_len
(
&
notoken_packet
)
)
;
let
new_datagram
=
Datagram
:
:
new
(
client_initial2
.
source
(
)
client_initial2
.
destination
(
)
notoken_packet
)
;
qdebug
!
(
"
passing
modified
Initial
to
the
main
server
"
)
;
let
dgram
=
server
.
process
(
Some
(
new_datagram
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
let
dgram
=
server
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_none
(
)
)
;
assert
!
(
test_fixture
:
:
maybe_authenticate
(
&
mut
client
)
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
assert
!
(
dgram
.
is_some
(
)
)
;
assert
!
(
matches
!
(
*
client
.
state
(
)
State
:
:
Closing
{
error
:
ConnectionError
:
:
Transport
(
Error
:
:
ProtocolViolation
)
.
.
}
)
)
;
}
#
[
test
]
fn
bad_client_initial
(
)
{
let
mut
client
=
default_client
(
)
;
let
mut
server
=
default_server
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
let
(
header
d_cid
s_cid
payload
)
=
decode_initial_header
(
&
dgram
)
;
let
(
aead
hp
)
=
client_initial_aead_and_hp
(
d_cid
)
;
let
(
fixed_header
pn
)
=
remove_header_protection
(
&
hp
header
payload
)
;
let
payload
=
&
payload
[
(
fixed_header
.
len
(
)
-
header
.
len
(
)
)
.
.
]
;
let
mut
plaintext_buf
=
vec
!
[
0
;
dgram
.
len
(
)
]
;
let
plaintext
=
aead
.
decrypt
(
pn
&
fixed_header
payload
&
mut
plaintext_buf
)
.
unwrap
(
)
;
let
mut
payload_enc
=
Encoder
:
:
from
(
plaintext
)
;
payload_enc
.
encode
(
&
[
0x08
0x02
0x00
0x00
]
)
;
let
mut
header_enc
=
Encoder
:
:
new
(
)
;
header_enc
.
encode_byte
(
0xc0
)
.
encode_uint
(
4
QuicVersion
:
:
default
(
)
.
as_u32
(
)
)
.
encode_vec
(
1
d_cid
)
.
encode_vec
(
1
s_cid
)
.
encode_vvec
(
&
[
]
)
.
encode_varint
(
u64
:
:
try_from
(
payload_enc
.
len
(
)
+
aead
.
expansion
(
)
+
1
)
.
unwrap
(
)
)
.
encode_byte
(
u8
:
:
try_from
(
pn
)
.
unwrap
(
)
)
;
let
mut
ciphertext
=
header_enc
.
to_vec
(
)
;
ciphertext
.
resize
(
header_enc
.
len
(
)
+
payload_enc
.
len
(
)
+
aead
.
expansion
(
)
0
)
;
let
v
=
aead
.
encrypt
(
pn
&
header_enc
&
payload_enc
&
mut
ciphertext
[
header_enc
.
len
(
)
.
.
]
)
.
unwrap
(
)
;
assert_eq
!
(
header_enc
.
len
(
)
+
v
.
len
(
)
ciphertext
.
len
(
)
)
;
ciphertext
.
resize
(
1200
0
)
;
apply_header_protection
(
&
hp
&
mut
ciphertext
(
header_enc
.
len
(
)
-
1
)
.
.
header_enc
.
len
(
)
)
;
let
bad_dgram
=
Datagram
:
:
new
(
dgram
.
source
(
)
dgram
.
destination
(
)
ciphertext
)
;
let
response
=
server
.
process
(
Some
(
bad_dgram
)
now
(
)
)
;
let
close_dgram
=
response
.
dgram
(
)
.
unwrap
(
)
;
assert
!
(
close_dgram
.
len
(
)
<
200
)
;
let
response
=
client
.
process
(
Some
(
close_dgram
)
now
(
)
)
.
dgram
(
)
;
assert
!
(
response
.
is_some
(
)
)
;
let
delay
=
client
.
process
(
None
now
(
)
)
.
callback
(
)
;
assert_ne
!
(
delay
Duration
:
:
from_secs
(
0
)
)
;
assert
!
(
matches
!
(
*
client
.
state
(
)
State
:
:
Draining
{
error
:
ConnectionError
:
:
Transport
(
Error
:
:
PeerError
(
code
)
)
.
.
}
if
code
=
=
Error
:
:
ProtocolViolation
.
code
(
)
)
)
;
for
server
in
server
.
active_connections
(
)
{
assert_eq
!
(
*
server
.
borrow
(
)
.
state
(
)
State
:
:
Closed
(
ConnectionError
:
:
Transport
(
Error
:
:
ProtocolViolation
)
)
)
;
}
let
res
=
server
.
process
(
None
now
(
)
)
;
assert_eq
!
(
res
Output
:
:
None
)
;
}
#
[
test
]
fn
version_negotiation
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
let
dgram
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
.
expect
(
"
a
datagram
"
)
;
let
mut
input
=
dgram
.
to_vec
(
)
;
input
[
1
]
^
=
0x12
;
let
damaged
=
Datagram
:
:
new
(
dgram
.
source
(
)
dgram
.
destination
(
)
input
.
clone
(
)
)
;
let
vn
=
server
.
process
(
Some
(
damaged
)
now
(
)
)
.
dgram
(
)
;
let
mut
dec
=
Decoder
:
:
from
(
&
input
[
5
.
.
]
)
;
let
d_cid
=
dec
.
decode_vec
(
1
)
.
expect
(
"
client
DCID
"
)
.
to_vec
(
)
;
let
s_cid
=
dec
.
decode_vec
(
1
)
.
expect
(
"
client
SCID
"
)
.
to_vec
(
)
;
let
vn
=
vn
.
expect
(
"
a
vn
packet
"
)
;
let
mut
dec
=
Decoder
:
:
from
(
&
vn
[
1
.
.
]
)
;
assert_eq
!
(
dec
.
decode_uint
(
4
)
.
expect
(
"
VN
"
)
0
)
;
assert_eq
!
(
dec
.
decode_vec
(
1
)
.
expect
(
"
VN
DCID
"
)
&
s_cid
[
.
.
]
)
;
assert_eq
!
(
dec
.
decode_vec
(
1
)
.
expect
(
"
VN
SCID
"
)
&
d_cid
[
.
.
]
)
;
let
mut
found
=
false
;
while
dec
.
remaining
(
)
>
0
{
let
v
=
dec
.
decode_uint
(
4
)
.
expect
(
"
supported
version
"
)
;
found
|
=
v
=
=
u64
:
:
from
(
QuicVersion
:
:
default
(
)
.
as_u32
(
)
)
;
}
assert
!
(
found
"
valid
version
not
found
"
)
;
let
res
=
client
.
process
(
Some
(
vn
)
now
(
)
)
;
assert
!
(
res
.
callback
(
)
>
Duration
:
:
new
(
0
120
)
)
;
assert_eq
!
(
client
.
state
(
)
&
State
:
:
WaitInitial
)
;
}
#
[
test
]
fn
closed
(
)
{
let
mut
server
=
default_server
(
)
;
let
mut
client
=
default_client
(
)
;
connect
(
&
mut
client
&
mut
server
)
;
let
res
=
server
.
process
(
None
now
(
)
)
;
assert
!
(
res
.
callback
(
)
>
Duration
:
:
new
(
0
0
)
)
;
let
res
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
res
.
callback
(
)
>
Duration
:
:
new
(
0
0
)
)
;
qtrace
!
(
"
60s
later
"
)
;
let
res
=
server
.
process
(
None
now
(
)
+
Duration
:
:
from_secs
(
60
)
)
;
assert_eq
!
(
res
Output
:
:
None
)
;
}
