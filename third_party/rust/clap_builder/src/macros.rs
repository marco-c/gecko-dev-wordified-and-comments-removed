#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_version
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_VERSION
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_authors
{
(
sep
:
expr
)
=
>
{
{
static
authors
:
&
str
=
env
!
(
"
CARGO_PKG_AUTHORS
"
)
;
if
authors
.
contains
(
'
:
'
)
{
static
CACHED
:
clap
:
:
__macro_refs
:
:
once_cell
:
:
sync
:
:
Lazy
<
String
>
=
clap
:
:
__macro_refs
:
:
once_cell
:
:
sync
:
:
Lazy
:
:
new
(
|
|
authors
.
replace
(
'
:
'
sep
)
)
;
let
s
:
&
'
static
str
=
&
*
CACHED
;
s
}
else
{
authors
}
}
}
;
(
)
=
>
{
env
!
(
"
CARGO_PKG_AUTHORS
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_description
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_DESCRIPTION
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
crate_name
{
(
)
=
>
{
env
!
(
"
CARGO_PKG_NAME
"
)
}
;
}
#
[
cfg
(
feature
=
"
cargo
"
)
]
#
[
macro_export
]
macro_rules
!
command
{
(
)
=
>
{
{
crate
:
:
command
!
(
crate
:
:
crate_name
!
(
)
)
}
}
;
(
name
:
expr
)
=
>
{
{
let
mut
cmd
=
crate
:
:
Command
:
:
new
(
name
)
.
version
(
crate
:
:
crate_version
!
(
)
)
;
let
author
=
crate
:
:
crate_authors
!
(
)
;
if
!
author
.
is_empty
(
)
{
cmd
=
cmd
.
author
(
author
)
}
let
about
=
crate
:
:
crate_description
!
(
)
;
if
!
about
.
is_empty
(
)
{
cmd
=
cmd
.
about
(
about
)
}
cmd
}
}
;
}
#
[
cfg
(
not
(
feature
=
"
cargo
"
)
)
]
#
[
macro_export
]
macro_rules
!
command
{
(
)
=
>
{
{
compile_error
!
(
"
cargo
feature
flag
is
required
"
)
;
}
}
;
(
name
:
expr
)
=
>
{
{
compile_error
!
(
"
cargo
feature
flag
is
required
"
)
;
}
}
;
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
arg_impl
{
(
string
val
:
ident
)
=
>
{
stringify
!
(
val
)
}
;
(
string
val
:
literal
)
=
>
{
{
let
ident_or_string_literal
:
&
str
=
val
;
ident_or_string_literal
}
}
;
(
string
val
:
tt
)
=
>
{
:
:
std
:
:
compile_error
!
(
"
Only
identifiers
or
string
literals
supported
"
)
;
}
;
(
string
)
=
>
{
None
}
;
(
char
val
:
ident
)
=
>
{
{
let
ident_or_char_literal
=
stringify
!
(
val
)
;
debug_assert_eq
!
(
ident_or_char_literal
.
len
(
)
1
"
Single
-
letter
identifier
expected
got
{
}
"
ident_or_char_literal
)
;
ident_or_char_literal
.
chars
(
)
.
next
(
)
.
unwrap
(
)
}
}
;
(
char
val
:
literal
)
=
>
{
{
let
ident_or_char_literal
:
char
=
val
;
ident_or_char_literal
}
}
;
(
char
)
=
>
{
{
None
}
}
;
(
arg
(
arg
:
expr
)
-
-
long
:
ident
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
let
mut
arg
=
arg
;
let
long
=
crate
:
:
arg_impl
!
{
string
long
}
;
if
arg
.
get_id
(
)
=
=
"
"
{
arg
=
arg
.
id
(
long
)
;
}
let
action
=
crate
:
:
ArgAction
:
:
SetTrue
;
let
arg
=
arg
.
long
(
long
)
.
action
(
action
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
-
-
long
:
literal
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
let
mut
arg
=
arg
;
let
long
=
crate
:
:
arg_impl
!
{
string
long
}
;
if
arg
.
get_id
(
)
=
=
"
"
{
arg
=
arg
.
id
(
long
)
;
}
let
action
=
crate
:
:
ArgAction
:
:
SetTrue
;
let
arg
=
arg
.
long
(
long
)
.
action
(
action
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
-
short
:
ident
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert_eq
!
(
arg
.
get_long
(
)
None
"
Short
flags
should
precede
long
flags
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
let
action
=
crate
:
:
ArgAction
:
:
SetTrue
;
let
arg
=
arg
.
short
(
crate
:
:
arg_impl
!
{
char
short
}
)
.
action
(
action
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
-
short
:
literal
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert_eq
!
(
arg
.
get_long
(
)
None
"
Short
flags
should
precede
long
flags
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Flags
should
precede
values
"
)
;
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
let
action
=
crate
:
:
ArgAction
:
:
SetTrue
;
let
arg
=
arg
.
short
(
crate
:
:
arg_impl
!
{
char
short
}
)
.
action
(
action
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
<
value_name
:
ident
>
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
=
arg
.
required
(
true
)
;
}
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
=
=
"
"
{
arg
=
arg
.
id
(
value_name
)
;
}
let
arg
=
arg
.
value_name
(
value_name
)
.
action
(
crate
:
:
ArgAction
:
:
Set
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
<
value_name
:
literal
>
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
=
arg
.
required
(
true
)
;
}
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
=
=
"
"
{
arg
=
arg
.
id
(
value_name
)
;
}
let
arg
=
arg
.
value_name
(
value_name
)
.
action
(
crate
:
:
ArgAction
:
:
Set
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
[
value_name
:
ident
]
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
=
arg
.
required
(
false
)
;
}
else
{
arg
=
arg
.
num_args
(
0
.
.
=
1
)
;
}
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
=
=
"
"
{
arg
=
arg
.
id
(
value_name
)
;
}
let
arg
=
arg
.
value_name
(
value_name
)
.
action
(
crate
:
:
ArgAction
:
:
Set
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
[
value_name
:
literal
]
(
tail
:
tt
)
*
)
=
>
{
{
debug_assert
!
(
!
matches
!
(
arg
.
get_action
(
)
crate
:
:
ArgAction
:
:
Append
)
"
Flags
should
precede
.
.
.
"
)
;
debug_assert_eq
!
(
arg
.
get_value_names
(
)
None
"
Multiple
values
not
yet
supported
"
)
;
let
mut
arg
=
arg
;
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
=
arg
.
required
(
false
)
;
}
else
{
arg
=
arg
.
num_args
(
0
.
.
=
1
)
;
}
let
value_name
=
crate
:
:
arg_impl
!
{
string
value_name
}
;
if
arg
.
get_id
(
)
=
=
"
"
{
arg
=
arg
.
id
(
value_name
)
;
}
let
arg
=
arg
.
value_name
(
value_name
)
.
action
(
crate
:
:
ArgAction
:
:
Set
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
.
.
.
(
tail
:
tt
)
*
)
=
>
{
{
let
arg
=
match
arg
.
get_action
(
)
{
crate
:
:
ArgAction
:
:
Set
=
>
{
if
arg
.
get_long
(
)
.
is_none
(
)
&
&
arg
.
get_short
(
)
.
is_none
(
)
{
arg
.
num_args
(
1
.
.
)
/
/
Allow
collecting
arguments
interleaved
with
flags
.
action
(
crate
:
:
ArgAction
:
:
Append
)
}
else
{
arg
.
action
(
crate
:
:
ArgAction
:
:
Append
)
}
}
crate
:
:
ArgAction
:
:
SetTrue
|
crate
:
:
ArgAction
:
:
Help
|
crate
:
:
ArgAction
:
:
Version
=
>
{
arg
.
action
(
crate
:
:
ArgAction
:
:
Count
)
}
action
=
>
{
panic
!
(
"
Unexpected
action
{
:
?
}
"
action
)
}
}
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
*
}
;
arg
}
}
;
(
arg
(
arg
:
expr
)
help
:
literal
)
=
>
{
{
arg
.
help
(
help
)
}
}
;
(
arg
(
arg
:
expr
)
)
=
>
{
{
arg
}
}
;
}
#
[
macro_export
]
macro_rules
!
arg
{
(
name
:
ident
:
(
tail
:
tt
)
+
)
=
>
{
{
let
arg
=
crate
:
:
Arg
:
:
new
(
crate
:
:
arg_impl
!
{
string
name
}
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
+
}
;
arg
}
}
;
(
(
tail
:
tt
)
+
)
=
>
{
{
let
arg
=
crate
:
:
Arg
:
:
default
(
)
;
let
arg
=
crate
:
:
arg_impl
!
{
arg
(
arg
)
(
tail
)
+
}
;
debug_assert_ne
!
(
arg
.
get_id
(
)
"
"
"
Without
a
value
or
long
flag
the
name
:
prefix
is
required
"
)
;
arg
}
}
;
}
macro_rules
!
impl_settings
{
(
settings
:
ident
flags
:
ident
(
(
#
[
inner
:
ident
(
args
:
tt
)
*
]
)
*
setting
:
ident
=
>
flag
:
path
)
+
)
=
>
{
impl
flags
{
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
empty
(
)
-
>
Self
{
flags
(
Flags
:
:
empty
(
)
)
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
insert
(
&
mut
self
rhs
:
Self
)
{
self
.
0
.
insert
(
rhs
.
0
)
;
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
remove
(
&
mut
self
rhs
:
Self
)
{
self
.
0
.
remove
(
rhs
.
0
)
;
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
set
(
&
mut
self
s
:
settings
)
{
match
s
{
(
(
#
[
inner
(
args
)
*
]
)
*
settings
:
:
setting
=
>
self
.
0
.
insert
(
flag
)
)
*
}
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
unset
(
&
mut
self
s
:
settings
)
{
match
s
{
(
(
#
[
inner
(
args
)
*
]
)
*
settings
:
:
setting
=
>
self
.
0
.
remove
(
flag
)
)
*
}
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
is_set
(
&
self
s
:
settings
)
-
>
bool
{
match
s
{
(
(
#
[
inner
(
args
)
*
]
)
*
settings
:
:
setting
=
>
self
.
0
.
contains
(
flag
)
)
*
}
}
}
impl
BitOr
for
flags
{
type
Output
=
Self
;
fn
bitor
(
mut
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
0
.
insert
(
rhs
.
0
)
;
self
}
}
impl
From
<
settings
>
for
flags
{
fn
from
(
setting
:
settings
)
-
>
Self
{
let
mut
flags
=
flags
:
:
empty
(
)
;
flags
.
set
(
setting
)
;
flags
}
}
impl
BitOr
<
settings
>
for
flags
{
type
Output
=
Self
;
fn
bitor
(
mut
self
rhs
:
settings
)
-
>
Self
:
:
Output
{
self
.
set
(
rhs
)
;
self
}
}
impl
BitOr
for
settings
{
type
Output
=
flags
;
fn
bitor
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
let
mut
flags
=
flags
:
:
empty
(
)
;
flags
.
set
(
self
)
;
flags
.
set
(
rhs
)
;
flags
}
}
}
}
#
[
cfg
(
feature
=
"
debug
"
)
]
macro_rules
!
debug
{
(
(
arg
:
tt
)
*
)
=
>
(
{
let
prefix
=
format
!
(
"
[
{
:
>
w
}
]
\
t
"
module_path
!
(
)
w
=
28
)
;
let
body
=
format
!
(
(
arg
)
*
)
;
let
mut
styled
=
crate
:
:
builder
:
:
StyledStr
:
:
new
(
)
;
styled
.
hint
(
prefix
)
;
styled
.
hint
(
body
)
;
styled
.
none
(
"
\
n
"
)
;
let
color
=
crate
:
:
output
:
:
fmt
:
:
Colorizer
:
:
new
(
crate
:
:
output
:
:
fmt
:
:
Stream
:
:
Stderr
crate
:
:
ColorChoice
:
:
Auto
)
.
with_content
(
styled
)
;
let
_
=
color
.
print
(
)
;
}
)
}
#
[
cfg
(
not
(
feature
=
"
debug
"
)
)
]
macro_rules
!
debug
{
(
(
arg
:
tt
)
*
)
=
>
{
}
;
}
macro_rules
!
ok
{
(
expr
:
expr
)
=
>
{
match
expr
{
Ok
(
val
)
=
>
val
Err
(
err
)
=
>
{
return
Err
(
err
)
;
}
}
}
;
}
macro_rules
!
some
{
(
expr
:
expr
)
=
>
{
match
expr
{
Some
(
val
)
=
>
val
None
=
>
{
return
None
;
}
}
}
;
}
