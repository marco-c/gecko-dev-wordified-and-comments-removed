#
[
cfg
(
feature
=
"
env
"
)
]
use
std
:
:
env
;
#
[
cfg
(
feature
=
"
env
"
)
]
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
{
cmp
:
:
{
Ord
Ordering
}
fmt
:
:
{
self
Display
Formatter
}
str
}
;
use
super
:
:
{
ArgFlags
ArgSettings
}
;
#
[
cfg
(
feature
=
"
unstable
-
ext
"
)
]
use
crate
:
:
builder
:
:
ext
:
:
Extension
;
use
crate
:
:
builder
:
:
ext
:
:
Extensions
;
use
crate
:
:
builder
:
:
ArgPredicate
;
use
crate
:
:
builder
:
:
IntoResettable
;
use
crate
:
:
builder
:
:
OsStr
;
use
crate
:
:
builder
:
:
PossibleValue
;
use
crate
:
:
builder
:
:
Str
;
use
crate
:
:
builder
:
:
StyledStr
;
use
crate
:
:
builder
:
:
Styles
;
use
crate
:
:
builder
:
:
ValueRange
;
use
crate
:
:
util
:
:
AnyValueId
;
use
crate
:
:
ArgAction
;
use
crate
:
:
Id
;
use
crate
:
:
ValueHint
;
use
crate
:
:
INTERNAL_ERROR_MSG
;
#
[
derive
(
Default
Clone
)
]
pub
struct
Arg
{
pub
(
crate
)
id
:
Id
pub
(
crate
)
help
:
Option
<
StyledStr
>
pub
(
crate
)
long_help
:
Option
<
StyledStr
>
pub
(
crate
)
action
:
Option
<
ArgAction
>
pub
(
crate
)
value_parser
:
Option
<
super
:
:
ValueParser
>
pub
(
crate
)
blacklist
:
Vec
<
Id
>
pub
(
crate
)
settings
:
ArgFlags
pub
(
crate
)
overrides
:
Vec
<
Id
>
pub
(
crate
)
groups
:
Vec
<
Id
>
pub
(
crate
)
requires
:
Vec
<
(
ArgPredicate
Id
)
>
pub
(
crate
)
r_ifs
:
Vec
<
(
Id
OsStr
)
>
pub
(
crate
)
r_ifs_all
:
Vec
<
(
Id
OsStr
)
>
pub
(
crate
)
r_unless
:
Vec
<
Id
>
pub
(
crate
)
r_unless_all
:
Vec
<
Id
>
pub
(
crate
)
short
:
Option
<
char
>
pub
(
crate
)
long
:
Option
<
Str
>
pub
(
crate
)
aliases
:
Vec
<
(
Str
bool
)
>
pub
(
crate
)
short_aliases
:
Vec
<
(
char
bool
)
>
pub
(
crate
)
disp_ord
:
Option
<
usize
>
pub
(
crate
)
val_names
:
Vec
<
Str
>
pub
(
crate
)
num_vals
:
Option
<
ValueRange
>
pub
(
crate
)
val_delim
:
Option
<
char
>
pub
(
crate
)
default_vals
:
Vec
<
OsStr
>
pub
(
crate
)
default_vals_ifs
:
Vec
<
(
Id
ArgPredicate
Option
<
OsStr
>
)
>
pub
(
crate
)
default_missing_vals
:
Vec
<
OsStr
>
#
[
cfg
(
feature
=
"
env
"
)
]
pub
(
crate
)
env
:
Option
<
(
OsStr
Option
<
OsString
>
)
>
pub
(
crate
)
terminator
:
Option
<
Str
>
pub
(
crate
)
index
:
Option
<
usize
>
pub
(
crate
)
help_heading
:
Option
<
Option
<
Str
>
>
pub
(
crate
)
ext
:
Extensions
}
impl
Arg
{
pub
fn
new
(
id
:
impl
Into
<
Id
>
)
-
>
Self
{
Arg
:
:
default
(
)
.
id
(
id
)
}
#
[
must_use
]
pub
fn
id
(
mut
self
id
:
impl
Into
<
Id
>
)
-
>
Self
{
self
.
id
=
id
.
into
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
short
(
mut
self
s
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
if
let
Some
(
s
)
=
s
.
into_resettable
(
)
.
into_option
(
)
{
debug_assert
!
(
s
!
=
'
-
'
"
short
option
name
cannot
be
-
"
)
;
self
.
short
=
Some
(
s
)
;
}
else
{
self
.
short
=
None
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
long
(
mut
self
l
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
long
=
l
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
aliases
.
push
(
(
name
false
)
)
;
}
else
{
self
.
aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
short_alias
(
mut
self
name
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
debug_assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
name
false
)
)
;
}
else
{
self
.
short_aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
into_iter
(
)
.
map
(
|
x
|
(
x
.
into
(
)
false
)
)
)
;
self
}
#
[
must_use
]
pub
fn
short_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
char
>
)
-
>
Self
{
for
s
in
names
{
debug_assert
!
(
s
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
s
false
)
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
aliases
.
push
(
(
name
true
)
)
;
}
else
{
self
.
aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_short_alias
(
mut
self
name
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
debug_assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
name
true
)
)
;
}
else
{
self
.
short_aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
into_iter
(
)
.
map
(
|
n
|
(
n
.
into
(
)
true
)
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_short_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
char
>
)
-
>
Self
{
for
n
in
names
{
debug_assert
!
(
n
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_aliases
.
push
(
(
n
true
)
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
index
(
mut
self
idx
:
impl
IntoResettable
<
usize
>
)
-
>
Self
{
self
.
index
=
idx
.
into_resettable
(
)
.
into_option
(
)
;
self
}
pub
fn
trailing_var_arg
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
TrailingVarArg
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
TrailingVarArg
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
last
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Last
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Last
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
required
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Required
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Required
)
}
}
#
[
must_use
]
pub
fn
requires
(
mut
self
arg_id
:
impl
IntoResettable
<
Id
>
)
-
>
Self
{
if
let
Some
(
arg_id
)
=
arg_id
.
into_resettable
(
)
.
into_option
(
)
{
self
.
requires
.
push
(
(
ArgPredicate
:
:
IsPresent
arg_id
)
)
;
}
else
{
self
.
requires
.
clear
(
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
exclusive
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Exclusive
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Exclusive
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
global
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Global
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Global
)
}
}
#
[
inline
]
pub
(
crate
)
fn
is_set
(
&
self
s
:
ArgSettings
)
-
>
bool
{
self
.
settings
.
is_set
(
s
)
}
#
[
inline
]
#
[
must_use
]
pub
(
crate
)
fn
setting
(
mut
self
setting
:
ArgSettings
)
-
>
Self
{
self
.
settings
.
set
(
setting
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
(
crate
)
fn
unset_setting
(
mut
self
setting
:
ArgSettings
)
-
>
Self
{
self
.
settings
.
unset
(
setting
)
;
self
}
#
[
cfg
(
feature
=
"
unstable
-
ext
"
)
]
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
add
<
T
:
ArgExt
+
Extension
>
(
mut
self
tagged
:
T
)
-
>
Self
{
self
.
ext
.
set
(
tagged
)
;
self
}
}
impl
Arg
{
#
[
inline
]
#
[
must_use
]
pub
fn
action
(
mut
self
action
:
impl
IntoResettable
<
ArgAction
>
)
-
>
Self
{
self
.
action
=
action
.
into_resettable
(
)
.
into_option
(
)
;
self
}
pub
fn
value_parser
(
mut
self
parser
:
impl
IntoResettable
<
super
:
:
ValueParser
>
)
-
>
Self
{
self
.
value_parser
=
parser
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
num_args
(
mut
self
qty
:
impl
IntoResettable
<
ValueRange
>
)
-
>
Self
{
self
.
num_vals
=
qty
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
num_args
"
)
)
]
pub
fn
number_of_values
(
self
qty
:
usize
)
-
>
Self
{
self
.
num_args
(
qty
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
value_name
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
value_names
(
[
name
]
)
}
else
{
self
.
val_names
.
clear
(
)
;
self
}
}
#
[
must_use
]
pub
fn
value_names
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
self
.
val_names
=
names
.
into_iter
(
)
.
map
(
|
s
|
s
.
into
(
)
)
.
collect
(
)
;
self
}
#
[
must_use
]
pub
fn
value_hint
(
mut
self
value_hint
:
impl
IntoResettable
<
ValueHint
>
)
-
>
Self
{
match
value_hint
.
into_resettable
(
)
.
into_option
(
)
{
Some
(
value_hint
)
=
>
{
self
.
ext
.
set
(
value_hint
)
;
}
None
=
>
{
self
.
ext
.
remove
:
:
<
ValueHint
>
(
)
;
}
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
ignore_case
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
IgnoreCase
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
IgnoreCase
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
allow_hyphen_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
AllowHyphenValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
AllowHyphenValues
)
}
}
#
[
inline
]
pub
fn
allow_negative_numbers
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
AllowNegativeNumbers
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
AllowNegativeNumbers
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
require_equals
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
RequireEquals
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
RequireEquals
)
}
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
value_delimiter
"
)
)
]
pub
fn
use_value_delimiter
(
mut
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
val_delim
.
get_or_insert
(
'
'
)
;
}
else
{
self
.
val_delim
=
None
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
value_delimiter
(
mut
self
d
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
self
.
val_delim
=
d
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
value_terminator
(
mut
self
term
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
terminator
=
term
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
raw
(
mut
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
num_vals
.
get_or_insert_with
(
|
|
(
1
.
.
)
.
into
(
)
)
;
}
self
.
allow_hyphen_values
(
yes
)
.
last
(
yes
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_value
(
mut
self
val
:
impl
IntoResettable
<
OsStr
>
)
-
>
Self
{
if
let
Some
(
val
)
=
val
.
into_resettable
(
)
.
into_option
(
)
{
self
.
default_values
(
[
val
]
)
}
else
{
self
.
default_vals
.
clear
(
)
;
self
}
}
#
[
inline
]
#
[
must_use
]
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
default_value
"
)
)
]
pub
fn
default_value_os
(
self
val
:
impl
Into
<
OsStr
>
)
-
>
Self
{
self
.
default_values
(
[
val
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_values
(
mut
self
vals
:
impl
IntoIterator
<
Item
=
impl
Into
<
OsStr
>
>
)
-
>
Self
{
self
.
default_vals
=
vals
.
into_iter
(
)
.
map
(
|
s
|
s
.
into
(
)
)
.
collect
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
default_values
"
)
)
]
pub
fn
default_values_os
(
self
vals
:
impl
IntoIterator
<
Item
=
impl
Into
<
OsStr
>
>
)
-
>
Self
{
self
.
default_values
(
vals
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_value
(
mut
self
val
:
impl
IntoResettable
<
OsStr
>
)
-
>
Self
{
if
let
Some
(
val
)
=
val
.
into_resettable
(
)
.
into_option
(
)
{
self
.
default_missing_values_os
(
[
val
]
)
}
else
{
self
.
default_missing_vals
.
clear
(
)
;
self
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_value_os
(
self
val
:
impl
Into
<
OsStr
>
)
-
>
Self
{
self
.
default_missing_values_os
(
[
val
]
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_values
(
self
vals
:
impl
IntoIterator
<
Item
=
impl
Into
<
OsStr
>
>
)
-
>
Self
{
self
.
default_missing_values_os
(
vals
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
default_missing_values_os
(
mut
self
vals
:
impl
IntoIterator
<
Item
=
impl
Into
<
OsStr
>
>
)
-
>
Self
{
self
.
default_missing_vals
=
vals
.
into_iter
(
)
.
map
(
|
s
|
s
.
into
(
)
)
.
collect
(
)
;
self
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
env
(
mut
self
name
:
impl
IntoResettable
<
OsStr
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
let
value
=
env
:
:
var_os
(
&
name
)
;
self
.
env
=
Some
(
(
name
value
)
)
;
}
else
{
self
.
env
=
None
;
}
self
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
env
"
)
)
]
pub
fn
env_os
(
self
name
:
impl
Into
<
OsStr
>
)
-
>
Self
{
self
.
env
(
name
)
}
}
impl
Arg
{
#
[
inline
]
#
[
must_use
]
pub
fn
help
(
mut
self
h
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
help
=
h
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
long_help
(
mut
self
h
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
long_help
=
h
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
display_order
(
mut
self
ord
:
impl
IntoResettable
<
usize
>
)
-
>
Self
{
self
.
disp_ord
=
ord
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
help_heading
(
mut
self
heading
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
help_heading
=
Some
(
heading
.
into_resettable
(
)
.
into_option
(
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
next_line_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
NextLineHelp
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
NextLineHelp
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
Hidden
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
Hidden
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_possible_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HidePossibleValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HidePossibleValues
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_default_value
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HideDefaultValue
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HideDefaultValue
)
}
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hide_env
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HideEnv
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HideEnv
)
}
}
#
[
cfg
(
feature
=
"
env
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
hide_env_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HideEnvValues
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HideEnvValues
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_short_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HiddenShortHelp
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HiddenShortHelp
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide_long_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
ArgSettings
:
:
HiddenLongHelp
)
}
else
{
self
.
unset_setting
(
ArgSettings
:
:
HiddenLongHelp
)
}
}
}
impl
Arg
{
#
[
must_use
]
pub
fn
group
(
mut
self
group_id
:
impl
IntoResettable
<
Id
>
)
-
>
Self
{
if
let
Some
(
group_id
)
=
group_id
.
into_resettable
(
)
.
into_option
(
)
{
self
.
groups
.
push
(
group_id
)
;
}
else
{
self
.
groups
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
groups
(
mut
self
group_ids
:
impl
IntoIterator
<
Item
=
impl
Into
<
Id
>
>
)
-
>
Self
{
self
.
groups
.
extend
(
group_ids
.
into_iter
(
)
.
map
(
Into
:
:
into
)
)
;
self
}
#
[
must_use
]
pub
fn
default_value_if
(
mut
self
arg_id
:
impl
Into
<
Id
>
predicate
:
impl
Into
<
ArgPredicate
>
default
:
impl
IntoResettable
<
OsStr
>
)
-
>
Self
{
self
.
default_vals_ifs
.
push
(
(
arg_id
.
into
(
)
predicate
.
into
(
)
default
.
into_resettable
(
)
.
into_option
(
)
)
)
;
self
}
#
[
must_use
]
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
default_value_if
"
)
)
]
pub
fn
default_value_if_os
(
self
arg_id
:
impl
Into
<
Id
>
predicate
:
impl
Into
<
ArgPredicate
>
default
:
impl
IntoResettable
<
OsStr
>
)
-
>
Self
{
self
.
default_value_if
(
arg_id
predicate
default
)
}
#
[
must_use
]
pub
fn
default_value_ifs
(
mut
self
ifs
:
impl
IntoIterator
<
Item
=
(
impl
Into
<
Id
>
impl
Into
<
ArgPredicate
>
impl
IntoResettable
<
OsStr
>
)
>
)
-
>
Self
{
for
(
arg
predicate
default
)
in
ifs
{
self
=
self
.
default_value_if
(
arg
predicate
default
)
;
}
self
}
#
[
must_use
]
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
default_value_ifs
"
)
)
]
pub
fn
default_value_ifs_os
(
self
ifs
:
impl
IntoIterator
<
Item
=
(
impl
Into
<
Id
>
impl
Into
<
ArgPredicate
>
impl
IntoResettable
<
OsStr
>
)
>
)
-
>
Self
{
self
.
default_value_ifs
(
ifs
)
}
#
[
must_use
]
pub
fn
required_unless_present
(
mut
self
arg_id
:
impl
IntoResettable
<
Id
>
)
-
>
Self
{
if
let
Some
(
arg_id
)
=
arg_id
.
into_resettable
(
)
.
into_option
(
)
{
self
.
r_unless
.
push
(
arg_id
)
;
}
else
{
self
.
r_unless
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
required_unless_present_all
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Id
>
>
)
-
>
Self
{
self
.
r_unless_all
.
extend
(
names
.
into_iter
(
)
.
map
(
Into
:
:
into
)
)
;
self
}
#
[
must_use
]
pub
fn
required_unless_present_any
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Id
>
>
)
-
>
Self
{
self
.
r_unless
.
extend
(
names
.
into_iter
(
)
.
map
(
Into
:
:
into
)
)
;
self
}
#
[
must_use
]
pub
fn
required_if_eq
(
mut
self
arg_id
:
impl
Into
<
Id
>
val
:
impl
Into
<
OsStr
>
)
-
>
Self
{
self
.
r_ifs
.
push
(
(
arg_id
.
into
(
)
val
.
into
(
)
)
)
;
self
}
#
[
must_use
]
pub
fn
required_if_eq_any
(
mut
self
ifs
:
impl
IntoIterator
<
Item
=
(
impl
Into
<
Id
>
impl
Into
<
OsStr
>
)
>
)
-
>
Self
{
self
.
r_ifs
.
extend
(
ifs
.
into_iter
(
)
.
map
(
|
(
id
val
)
|
(
id
.
into
(
)
val
.
into
(
)
)
)
)
;
self
}
#
[
must_use
]
pub
fn
required_if_eq_all
(
mut
self
ifs
:
impl
IntoIterator
<
Item
=
(
impl
Into
<
Id
>
impl
Into
<
OsStr
>
)
>
)
-
>
Self
{
self
.
r_ifs_all
.
extend
(
ifs
.
into_iter
(
)
.
map
(
|
(
id
val
)
|
(
id
.
into
(
)
val
.
into
(
)
)
)
)
;
self
}
#
[
must_use
]
pub
fn
requires_if
(
mut
self
val
:
impl
Into
<
ArgPredicate
>
arg_id
:
impl
Into
<
Id
>
)
-
>
Self
{
self
.
requires
.
push
(
(
val
.
into
(
)
arg_id
.
into
(
)
)
)
;
self
}
#
[
must_use
]
pub
fn
requires_ifs
(
mut
self
ifs
:
impl
IntoIterator
<
Item
=
(
impl
Into
<
ArgPredicate
>
impl
Into
<
Id
>
)
>
)
-
>
Self
{
self
.
requires
.
extend
(
ifs
.
into_iter
(
)
.
map
(
|
(
val
arg
)
|
(
val
.
into
(
)
arg
.
into
(
)
)
)
)
;
self
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
requires_ifs
"
)
)
]
pub
fn
requires_all
(
self
ids
:
impl
IntoIterator
<
Item
=
impl
Into
<
Id
>
>
)
-
>
Self
{
self
.
requires_ifs
(
ids
.
into_iter
(
)
.
map
(
|
id
|
(
ArgPredicate
:
:
IsPresent
id
)
)
)
}
#
[
must_use
]
pub
fn
conflicts_with
(
mut
self
arg_id
:
impl
IntoResettable
<
Id
>
)
-
>
Self
{
if
let
Some
(
arg_id
)
=
arg_id
.
into_resettable
(
)
.
into_option
(
)
{
self
.
blacklist
.
push
(
arg_id
)
;
}
else
{
self
.
blacklist
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
conflicts_with_all
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Id
>
>
)
-
>
Self
{
self
.
blacklist
.
extend
(
names
.
into_iter
(
)
.
map
(
Into
:
:
into
)
)
;
self
}
#
[
must_use
]
pub
fn
overrides_with
(
mut
self
arg_id
:
impl
IntoResettable
<
Id
>
)
-
>
Self
{
if
let
Some
(
arg_id
)
=
arg_id
.
into_resettable
(
)
.
into_option
(
)
{
self
.
overrides
.
push
(
arg_id
)
;
}
else
{
self
.
overrides
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
overrides_with_all
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Id
>
>
)
-
>
Self
{
self
.
overrides
.
extend
(
names
.
into_iter
(
)
.
map
(
Into
:
:
into
)
)
;
self
}
}
impl
Arg
{
#
[
inline
]
pub
fn
get_id
(
&
self
)
-
>
&
Id
{
&
self
.
id
}
#
[
inline
]
pub
fn
get_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_long_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
long_help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_help_heading
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
help_heading
.
as_ref
(
)
.
map
(
|
s
|
s
.
as_deref
(
)
)
.
unwrap_or_default
(
)
}
#
[
inline
]
pub
fn
get_short
(
&
self
)
-
>
Option
<
char
>
{
self
.
short
}
#
[
inline
]
pub
fn
get_visible_short_aliases
(
&
self
)
-
>
Option
<
Vec
<
char
>
>
{
if
self
.
short_aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
short_aliases
.
iter
(
)
.
filter_map
(
|
(
c
v
)
|
if
*
v
{
Some
(
c
)
}
else
{
None
}
)
.
copied
(
)
.
collect
(
)
)
}
}
#
[
inline
]
pub
fn
get_all_short_aliases
(
&
self
)
-
>
Option
<
Vec
<
char
>
>
{
if
self
.
short_aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
short_aliases
.
iter
(
)
.
map
(
|
(
s
_
)
|
s
)
.
copied
(
)
.
collect
(
)
)
}
}
#
[
inline
]
pub
fn
get_short_and_visible_aliases
(
&
self
)
-
>
Option
<
Vec
<
char
>
>
{
let
mut
shorts
=
match
self
.
short
{
Some
(
short
)
=
>
vec
!
[
short
]
None
=
>
return
None
}
;
if
let
Some
(
aliases
)
=
self
.
get_visible_short_aliases
(
)
{
shorts
.
extend
(
aliases
)
;
}
Some
(
shorts
)
}
#
[
inline
]
pub
fn
get_long
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
long
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_visible_aliases
(
&
self
)
-
>
Option
<
Vec
<
&
str
>
>
{
if
self
.
aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
aliases
.
iter
(
)
.
filter_map
(
|
(
s
v
)
|
if
*
v
{
Some
(
s
.
as_str
(
)
)
}
else
{
None
}
)
.
collect
(
)
)
}
}
#
[
inline
]
pub
fn
get_all_aliases
(
&
self
)
-
>
Option
<
Vec
<
&
str
>
>
{
if
self
.
aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
aliases
.
iter
(
)
.
map
(
|
(
s
_
)
|
s
.
as_str
(
)
)
.
collect
(
)
)
}
}
#
[
inline
]
pub
fn
get_long_and_visible_aliases
(
&
self
)
-
>
Option
<
Vec
<
&
str
>
>
{
let
mut
longs
=
match
self
.
get_long
(
)
{
Some
(
long
)
=
>
vec
!
[
long
]
None
=
>
return
None
}
;
if
let
Some
(
aliases
)
=
self
.
get_visible_aliases
(
)
{
longs
.
extend
(
aliases
)
;
}
Some
(
longs
)
}
#
[
inline
]
pub
fn
get_aliases
(
&
self
)
-
>
Option
<
Vec
<
&
str
>
>
{
if
self
.
aliases
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
aliases
.
iter
(
)
.
filter_map
(
|
(
s
v
)
|
if
!
*
v
{
Some
(
s
.
as_str
(
)
)
}
else
{
None
}
)
.
collect
(
)
)
}
}
pub
fn
get_possible_values
(
&
self
)
-
>
Vec
<
PossibleValue
>
{
if
!
self
.
is_takes_value_set
(
)
{
vec
!
[
]
}
else
{
self
.
get_value_parser
(
)
.
possible_values
(
)
.
map
(
|
pvs
|
pvs
.
collect
(
)
)
.
unwrap_or_default
(
)
}
}
#
[
inline
]
pub
fn
get_value_names
(
&
self
)
-
>
Option
<
&
[
Str
]
>
{
if
self
.
val_names
.
is_empty
(
)
{
None
}
else
{
Some
(
&
self
.
val_names
)
}
}
#
[
inline
]
pub
fn
get_num_args
(
&
self
)
-
>
Option
<
ValueRange
>
{
self
.
num_vals
}
#
[
inline
]
pub
(
crate
)
fn
get_min_vals
(
&
self
)
-
>
usize
{
self
.
get_num_args
(
)
.
expect
(
INTERNAL_ERROR_MSG
)
.
min_values
(
)
}
#
[
inline
]
pub
fn
get_value_delimiter
(
&
self
)
-
>
Option
<
char
>
{
self
.
val_delim
}
#
[
inline
]
pub
fn
get_value_terminator
(
&
self
)
-
>
Option
<
&
Str
>
{
self
.
terminator
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_index
(
&
self
)
-
>
Option
<
usize
>
{
self
.
index
}
pub
fn
get_value_hint
(
&
self
)
-
>
ValueHint
{
self
.
ext
.
get
:
:
<
ValueHint
>
(
)
.
copied
(
)
.
unwrap_or_else
(
|
|
{
if
self
.
is_takes_value_set
(
)
{
let
type_id
=
self
.
get_value_parser
(
)
.
type_id
(
)
;
if
type_id
=
=
AnyValueId
:
:
of
:
:
<
std
:
:
path
:
:
PathBuf
>
(
)
{
ValueHint
:
:
AnyPath
}
else
{
ValueHint
:
:
default
(
)
}
}
else
{
ValueHint
:
:
default
(
)
}
}
)
}
#
[
cfg
(
feature
=
"
env
"
)
]
pub
fn
get_env
(
&
self
)
-
>
Option
<
&
std
:
:
ffi
:
:
OsStr
>
{
self
.
env
.
as_ref
(
)
.
map
(
|
x
|
x
.
0
.
as_os_str
(
)
)
}
pub
fn
get_default_values
(
&
self
)
-
>
&
[
OsStr
]
{
&
self
.
default_vals
}
pub
fn
is_positional
(
&
self
)
-
>
bool
{
self
.
get_long
(
)
.
is_none
(
)
&
&
self
.
get_short
(
)
.
is_none
(
)
}
pub
fn
is_required_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
Required
)
}
pub
(
crate
)
fn
is_multiple_values_set
(
&
self
)
-
>
bool
{
self
.
get_num_args
(
)
.
unwrap_or_default
(
)
.
is_multiple
(
)
}
pub
(
crate
)
fn
is_takes_value_set
(
&
self
)
-
>
bool
{
self
.
get_num_args
(
)
.
unwrap_or_else
(
|
|
1
.
into
(
)
)
.
takes_values
(
)
}
pub
fn
is_allow_hyphen_values_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
AllowHyphenValues
)
}
pub
fn
is_allow_negative_numbers_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
AllowNegativeNumbers
)
}
pub
fn
get_action
(
&
self
)
-
>
&
ArgAction
{
const
DEFAULT
:
ArgAction
=
ArgAction
:
:
Set
;
self
.
action
.
as_ref
(
)
.
unwrap_or
(
&
DEFAULT
)
}
pub
fn
get_value_parser
(
&
self
)
-
>
&
super
:
:
ValueParser
{
if
let
Some
(
value_parser
)
=
self
.
value_parser
.
as_ref
(
)
{
value_parser
}
else
{
static
DEFAULT
:
super
:
:
ValueParser
=
super
:
:
ValueParser
:
:
string
(
)
;
&
DEFAULT
}
}
pub
fn
is_global_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
Global
)
}
pub
fn
is_next_line_help_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
NextLineHelp
)
}
pub
fn
is_hide_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
Hidden
)
}
pub
fn
is_hide_default_value_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
HideDefaultValue
)
}
pub
fn
is_hide_possible_values_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
HidePossibleValues
)
}
#
[
cfg
(
feature
=
"
env
"
)
]
pub
fn
is_hide_env_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
HideEnv
)
}
#
[
cfg
(
feature
=
"
env
"
)
]
pub
fn
is_hide_env_values_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
HideEnvValues
)
}
pub
fn
is_hide_short_help_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
HiddenShortHelp
)
}
pub
fn
is_hide_long_help_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
HiddenLongHelp
)
}
pub
fn
is_require_equals_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
RequireEquals
)
}
pub
fn
is_exclusive_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
Exclusive
)
}
pub
fn
is_trailing_var_arg_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
TrailingVarArg
)
}
pub
fn
is_last_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
Last
)
}
pub
fn
is_ignore_case_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
ArgSettings
:
:
IgnoreCase
)
}
#
[
cfg
(
feature
=
"
unstable
-
ext
"
)
]
pub
fn
get
<
T
:
ArgExt
+
Extension
>
(
&
self
)
-
>
Option
<
&
T
>
{
self
.
ext
.
get
:
:
<
T
>
(
)
}
#
[
cfg
(
feature
=
"
unstable
-
ext
"
)
]
pub
fn
remove
<
T
:
ArgExt
+
Extension
>
(
mut
self
)
-
>
Option
<
T
>
{
self
.
ext
.
remove
:
:
<
T
>
(
)
}
}
impl
Arg
{
pub
(
crate
)
fn
_build
(
&
mut
self
)
{
if
self
.
action
.
is_none
(
)
{
if
self
.
num_vals
=
=
Some
(
ValueRange
:
:
EMPTY
)
{
let
action
=
ArgAction
:
:
SetTrue
;
self
.
action
=
Some
(
action
)
;
}
else
{
let
action
=
if
self
.
is_positional
(
)
&
&
self
.
num_vals
.
unwrap_or_default
(
)
.
is_unbounded
(
)
{
ArgAction
:
:
Append
}
else
{
ArgAction
:
:
Set
}
;
self
.
action
=
Some
(
action
)
;
}
}
if
let
Some
(
action
)
=
self
.
action
.
as_ref
(
)
{
if
let
Some
(
default_value
)
=
action
.
default_value
(
)
{
if
self
.
default_vals
.
is_empty
(
)
{
self
.
default_vals
=
vec
!
[
default_value
.
into
(
)
]
;
}
}
if
let
Some
(
default_value
)
=
action
.
default_missing_value
(
)
{
if
self
.
default_missing_vals
.
is_empty
(
)
{
self
.
default_missing_vals
=
vec
!
[
default_value
.
into
(
)
]
;
}
}
}
if
self
.
value_parser
.
is_none
(
)
{
if
let
Some
(
default
)
=
self
.
action
.
as_ref
(
)
.
and_then
(
|
a
|
a
.
default_value_parser
(
)
)
{
self
.
value_parser
=
Some
(
default
)
;
}
else
{
self
.
value_parser
=
Some
(
super
:
:
ValueParser
:
:
string
(
)
)
;
}
}
let
val_names_len
=
self
.
val_names
.
len
(
)
;
if
val_names_len
>
1
{
self
.
num_vals
.
get_or_insert
(
val_names_len
.
into
(
)
)
;
}
else
{
let
nargs
=
if
self
.
get_action
(
)
.
takes_values
(
)
{
ValueRange
:
:
SINGLE
}
else
{
ValueRange
:
:
EMPTY
}
;
self
.
num_vals
.
get_or_insert
(
nargs
)
;
}
}
pub
(
crate
)
fn
name_no_brackets
(
&
self
)
-
>
String
{
debug
!
(
"
Arg
:
:
name_no_brackets
:
{
}
"
self
.
get_id
(
)
)
;
let
delim
=
"
"
;
if
!
self
.
val_names
.
is_empty
(
)
{
debug
!
(
"
Arg
:
:
name_no_brackets
:
val_names
=
{
:
#
?
}
"
self
.
val_names
)
;
if
self
.
val_names
.
len
(
)
>
1
{
self
.
val_names
.
iter
(
)
.
map
(
|
n
|
format
!
(
"
<
{
n
}
>
"
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
delim
)
}
else
{
self
.
val_names
.
first
(
)
.
expect
(
INTERNAL_ERROR_MSG
)
.
as_str
(
)
.
to_owned
(
)
}
}
else
{
debug
!
(
"
Arg
:
:
name_no_brackets
:
just
name
"
)
;
self
.
get_id
(
)
.
as_str
(
)
.
to_owned
(
)
}
}
pub
(
crate
)
fn
stylized
(
&
self
styles
:
&
Styles
required
:
Option
<
bool
>
)
-
>
StyledStr
{
use
std
:
:
fmt
:
:
Write
as
_
;
let
literal
=
styles
.
get_literal
(
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
if
let
Some
(
l
)
=
self
.
get_long
(
)
{
let
_
=
write
!
(
styled
"
{
}
-
-
{
l
}
{
}
"
literal
.
render
(
)
literal
.
render_reset
(
)
)
;
}
else
if
let
Some
(
s
)
=
self
.
get_short
(
)
{
let
_
=
write
!
(
styled
"
{
}
-
{
s
}
{
}
"
literal
.
render
(
)
literal
.
render_reset
(
)
)
;
}
styled
.
push_styled
(
&
self
.
stylize_arg_suffix
(
styles
required
)
)
;
styled
}
pub
(
crate
)
fn
stylize_arg_suffix
(
&
self
styles
:
&
Styles
required
:
Option
<
bool
>
)
-
>
StyledStr
{
use
std
:
:
fmt
:
:
Write
as
_
;
let
literal
=
styles
.
get_literal
(
)
;
let
placeholder
=
styles
.
get_placeholder
(
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
mut
need_closing_bracket
=
false
;
if
self
.
is_takes_value_set
(
)
&
&
!
self
.
is_positional
(
)
{
let
is_optional_val
=
self
.
get_min_vals
(
)
=
=
0
;
let
(
style
start
)
=
if
self
.
is_require_equals_set
(
)
{
if
is_optional_val
{
need_closing_bracket
=
true
;
(
placeholder
"
[
=
"
)
}
else
{
(
literal
"
=
"
)
}
}
else
if
is_optional_val
{
need_closing_bracket
=
true
;
(
placeholder
"
[
"
)
}
else
{
(
placeholder
"
"
)
}
;
let
_
=
write
!
(
styled
"
{
}
{
start
}
{
}
"
style
.
render
(
)
style
.
render_reset
(
)
)
;
}
if
self
.
is_takes_value_set
(
)
|
|
self
.
is_positional
(
)
{
let
required
=
required
.
unwrap_or_else
(
|
|
self
.
is_required_set
(
)
)
;
let
arg_val
=
self
.
render_arg_val
(
required
)
;
let
_
=
write
!
(
styled
"
{
}
{
arg_val
}
{
}
"
placeholder
.
render
(
)
placeholder
.
render_reset
(
)
)
;
}
else
if
matches
!
(
*
self
.
get_action
(
)
ArgAction
:
:
Count
)
{
let
_
=
write
!
(
styled
"
{
}
.
.
.
{
}
"
placeholder
.
render
(
)
placeholder
.
render_reset
(
)
)
;
}
if
need_closing_bracket
{
let
_
=
write
!
(
styled
"
{
}
]
{
}
"
placeholder
.
render
(
)
placeholder
.
render_reset
(
)
)
;
}
styled
}
fn
render_arg_val
(
&
self
required
:
bool
)
-
>
String
{
let
mut
rendered
=
String
:
:
new
(
)
;
let
num_vals
=
self
.
get_num_args
(
)
.
unwrap_or_else
(
|
|
1
.
into
(
)
)
;
let
mut
val_names
=
if
self
.
val_names
.
is_empty
(
)
{
vec
!
[
self
.
id
.
as_internal_str
(
)
.
to_owned
(
)
]
}
else
{
self
.
val_names
.
clone
(
)
}
;
if
val_names
.
len
(
)
=
=
1
{
let
min
=
num_vals
.
min_values
(
)
.
max
(
1
)
;
let
val_name
=
val_names
.
pop
(
)
.
unwrap
(
)
;
val_names
=
vec
!
[
val_name
;
min
]
;
}
debug_assert
!
(
self
.
is_takes_value_set
(
)
)
;
for
(
n
val_name
)
in
val_names
.
iter
(
)
.
enumerate
(
)
{
let
arg_name
=
if
self
.
is_positional
(
)
&
&
(
num_vals
.
min_values
(
)
=
=
0
|
|
!
required
)
{
format
!
(
"
[
{
val_name
}
]
"
)
}
else
{
format
!
(
"
<
{
val_name
}
>
"
)
}
;
if
n
!
=
0
{
rendered
.
push
(
'
'
)
;
}
rendered
.
push_str
(
&
arg_name
)
;
}
let
mut
extra_values
=
false
;
extra_values
|
=
val_names
.
len
(
)
<
num_vals
.
max_values
(
)
;
if
self
.
is_positional
(
)
&
&
matches
!
(
*
self
.
get_action
(
)
ArgAction
:
:
Append
)
{
extra_values
=
true
;
}
if
extra_values
{
rendered
.
push_str
(
"
.
.
.
"
)
;
}
rendered
}
pub
(
crate
)
fn
is_multiple
(
&
self
)
-
>
bool
{
self
.
is_multiple_values_set
(
)
|
|
matches
!
(
*
self
.
get_action
(
)
ArgAction
:
:
Append
)
}
#
[
cfg
(
feature
=
"
help
"
)
]
pub
(
crate
)
fn
get_display_order
(
&
self
)
-
>
usize
{
self
.
disp_ord
.
unwrap_or
(
999
)
}
}
impl
From
<
&
'
_
Arg
>
for
Arg
{
fn
from
(
a
:
&
Arg
)
-
>
Self
{
a
.
clone
(
)
}
}
impl
PartialEq
for
Arg
{
fn
eq
(
&
self
other
:
&
Arg
)
-
>
bool
{
self
.
get_id
(
)
=
=
other
.
get_id
(
)
}
}
impl
PartialOrd
for
Arg
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
Arg
{
fn
cmp
(
&
self
other
:
&
Arg
)
-
>
Ordering
{
self
.
get_id
(
)
.
cmp
(
other
.
get_id
(
)
)
}
}
impl
Eq
for
Arg
{
}
impl
Display
for
Arg
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
plain
=
Styles
:
:
plain
(
)
;
self
.
stylized
(
&
plain
None
)
.
fmt
(
f
)
}
}
impl
fmt
:
:
Debug
for
Arg
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
let
mut
ds
=
f
.
debug_struct
(
"
Arg
"
)
;
#
[
allow
(
unused_mut
)
]
let
mut
ds
=
ds
.
field
(
"
id
"
&
self
.
id
)
.
field
(
"
help
"
&
self
.
help
)
.
field
(
"
long_help
"
&
self
.
long_help
)
.
field
(
"
action
"
&
self
.
action
)
.
field
(
"
value_parser
"
&
self
.
value_parser
)
.
field
(
"
blacklist
"
&
self
.
blacklist
)
.
field
(
"
settings
"
&
self
.
settings
)
.
field
(
"
overrides
"
&
self
.
overrides
)
.
field
(
"
groups
"
&
self
.
groups
)
.
field
(
"
requires
"
&
self
.
requires
)
.
field
(
"
r_ifs
"
&
self
.
r_ifs
)
.
field
(
"
r_unless
"
&
self
.
r_unless
)
.
field
(
"
short
"
&
self
.
short
)
.
field
(
"
long
"
&
self
.
long
)
.
field
(
"
aliases
"
&
self
.
aliases
)
.
field
(
"
short_aliases
"
&
self
.
short_aliases
)
.
field
(
"
disp_ord
"
&
self
.
disp_ord
)
.
field
(
"
val_names
"
&
self
.
val_names
)
.
field
(
"
num_vals
"
&
self
.
num_vals
)
.
field
(
"
val_delim
"
&
self
.
val_delim
)
.
field
(
"
default_vals
"
&
self
.
default_vals
)
.
field
(
"
default_vals_ifs
"
&
self
.
default_vals_ifs
)
.
field
(
"
terminator
"
&
self
.
terminator
)
.
field
(
"
index
"
&
self
.
index
)
.
field
(
"
help_heading
"
&
self
.
help_heading
)
.
field
(
"
default_missing_vals
"
&
self
.
default_missing_vals
)
.
field
(
"
ext
"
&
self
.
ext
)
;
#
[
cfg
(
feature
=
"
env
"
)
]
{
ds
=
ds
.
field
(
"
env
"
&
self
.
env
)
;
}
ds
.
finish
(
)
}
}
#
[
cfg
(
feature
=
"
unstable
-
ext
"
)
]
pub
trait
ArgExt
:
Extension
{
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Arg
;
use
super
:
:
ArgAction
;
#
[
test
]
fn
flag_display_long
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
.
long
(
"
flag
"
)
.
action
(
ArgAction
:
:
SetTrue
)
;
f
.
_build
(
)
;
assert_eq
!
(
f
.
to_string
(
)
"
-
-
flag
"
)
;
}
#
[
test
]
fn
flag_display_short
(
)
{
let
mut
f2
=
Arg
:
:
new
(
"
flg
"
)
.
short
(
'
f
'
)
.
action
(
ArgAction
:
:
SetTrue
)
;
f2
.
_build
(
)
;
assert_eq
!
(
f2
.
to_string
(
)
"
-
f
"
)
;
}
#
[
test
]
fn
flag_display_count
(
)
{
let
mut
f2
=
Arg
:
:
new
(
"
flg
"
)
.
long
(
"
flag
"
)
.
action
(
ArgAction
:
:
Count
)
;
f2
.
_build
(
)
;
assert_eq
!
(
f2
.
to_string
(
)
"
-
-
flag
.
.
.
"
)
;
}
#
[
test
]
fn
flag_display_single_alias
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
.
long
(
"
flag
"
)
.
visible_alias
(
"
als
"
)
.
action
(
ArgAction
:
:
SetTrue
)
;
f
.
_build
(
)
;
assert_eq
!
(
f
.
to_string
(
)
"
-
-
flag
"
)
;
}
#
[
test
]
fn
flag_display_multiple_aliases
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
.
short
(
'
f
'
)
.
action
(
ArgAction
:
:
SetTrue
)
;
f
.
aliases
=
vec
!
[
(
"
alias_not_visible
"
.
into
(
)
false
)
(
"
f2
"
.
into
(
)
true
)
(
"
f3
"
.
into
(
)
true
)
(
"
f4
"
.
into
(
)
true
)
]
;
f
.
_build
(
)
;
assert_eq
!
(
f
.
to_string
(
)
"
-
f
"
)
;
}
#
[
test
]
fn
flag_display_single_short_alias
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
.
short
(
'
a
'
)
.
action
(
ArgAction
:
:
SetTrue
)
;
f
.
short_aliases
=
vec
!
[
(
'
b
'
true
)
]
;
f
.
_build
(
)
;
assert_eq
!
(
f
.
to_string
(
)
"
-
a
"
)
;
}
#
[
test
]
fn
flag_display_multiple_short_aliases
(
)
{
let
mut
f
=
Arg
:
:
new
(
"
flg
"
)
.
short
(
'
a
'
)
.
action
(
ArgAction
:
:
SetTrue
)
;
f
.
short_aliases
=
vec
!
[
(
'
b
'
false
)
(
'
c
'
true
)
(
'
d
'
true
)
(
'
e
'
true
)
]
;
f
.
_build
(
)
;
assert_eq
!
(
f
.
to_string
(
)
"
-
a
"
)
;
}
#
[
test
]
fn
option_display_multiple_occurrences
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Append
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_multiple_values
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Set
)
.
num_args
(
1
.
.
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
<
opt
>
.
.
.
"
)
;
}
#
[
test
]
fn
option_display_zero_or_more_values
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Set
)
.
num_args
(
0
.
.
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
[
<
opt
>
.
.
.
]
"
)
;
}
#
[
test
]
fn
option_display_one_or_more_values
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Set
)
.
num_args
(
1
.
.
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
<
opt
>
.
.
.
"
)
;
}
#
[
test
]
fn
option_display_zero_or_more_values_with_value_name
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
o
'
)
.
action
(
ArgAction
:
:
Set
)
.
num_args
(
0
.
.
)
.
value_names
(
[
"
file
"
]
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
o
[
<
file
>
.
.
.
]
"
)
;
}
#
[
test
]
fn
option_display_one_or_more_values_with_value_name
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
o
'
)
.
action
(
ArgAction
:
:
Set
)
.
num_args
(
1
.
.
)
.
value_names
(
[
"
file
"
]
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
o
<
file
>
.
.
.
"
)
;
}
#
[
test
]
fn
option_display_optional_value
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Set
)
.
num_args
(
0
.
.
=
1
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
[
<
opt
>
]
"
)
;
}
#
[
test
]
fn
option_display_value_names
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
o
'
)
.
action
(
ArgAction
:
:
Set
)
.
value_names
(
[
"
file
"
"
name
"
]
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
o
<
file
>
<
name
>
"
)
;
}
#
[
test
]
fn
option_display3
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
o
'
)
.
num_args
(
1
.
.
)
.
action
(
ArgAction
:
:
Set
)
.
value_names
(
[
"
file
"
"
name
"
]
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
o
<
file
>
<
name
>
.
.
.
"
)
;
}
#
[
test
]
fn
option_display_single_alias
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Set
)
.
visible_alias
(
"
als
"
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_multiple_aliases
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
long
(
"
option
"
)
.
action
(
ArgAction
:
:
Set
)
.
visible_aliases
(
[
"
als2
"
"
als3
"
"
als4
"
]
)
.
alias
(
"
als_not_visible
"
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
-
option
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_single_short_alias
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
a
'
)
.
action
(
ArgAction
:
:
Set
)
.
visible_short_alias
(
'
b
'
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
a
<
opt
>
"
)
;
}
#
[
test
]
fn
option_display_multiple_short_aliases
(
)
{
let
mut
o
=
Arg
:
:
new
(
"
opt
"
)
.
short
(
'
a
'
)
.
action
(
ArgAction
:
:
Set
)
.
visible_short_aliases
(
[
'
b
'
'
c
'
'
d
'
]
)
.
short_alias
(
'
e
'
)
;
o
.
_build
(
)
;
assert_eq
!
(
o
.
to_string
(
)
"
-
a
<
opt
>
"
)
;
}
#
[
test
]
fn
positional_display_multiple_values
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
num_args
(
1
.
.
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
[
pos
]
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_multiple_values_required
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
num_args
(
1
.
.
)
.
required
(
true
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
<
pos
>
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_zero_or_more_values
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
num_args
(
0
.
.
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
[
pos
]
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_one_or_more_values
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
num_args
(
1
.
.
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
[
pos
]
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_one_or_more_values_required
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
num_args
(
1
.
.
)
.
required
(
true
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
<
pos
>
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_optional_value
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
num_args
(
0
.
.
=
1
)
.
action
(
ArgAction
:
:
Set
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
[
pos
]
"
)
;
}
#
[
test
]
fn
positional_display_multiple_occurrences
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
action
(
ArgAction
:
:
Append
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
[
pos
]
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_multiple_occurrences_required
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
action
(
ArgAction
:
:
Append
)
.
required
(
true
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
<
pos
>
.
.
.
"
)
;
}
#
[
test
]
fn
positional_display_required
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
required
(
true
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
<
pos
>
"
)
;
}
#
[
test
]
fn
positional_display_val_names
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
value_names
(
[
"
file1
"
"
file2
"
]
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
[
file1
]
[
file2
]
"
)
;
}
#
[
test
]
fn
positional_display_val_names_required
(
)
{
let
mut
p
=
Arg
:
:
new
(
"
pos
"
)
.
index
(
1
)
.
value_names
(
[
"
file1
"
"
file2
"
]
)
.
required
(
true
)
;
p
.
_build
(
)
;
assert_eq
!
(
p
.
to_string
(
)
"
<
file1
>
<
file2
>
"
)
;
}
}
