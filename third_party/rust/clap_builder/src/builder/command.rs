#
!
[
cfg_attr
(
not
(
feature
=
"
usage
"
)
allow
(
unused_mut
)
)
]
use
std
:
:
env
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
Index
;
use
std
:
:
path
:
:
Path
;
use
crate
:
:
builder
:
:
app_settings
:
:
{
AppFlags
AppSettings
}
;
use
crate
:
:
builder
:
:
arg_settings
:
:
ArgSettings
;
use
crate
:
:
builder
:
:
ext
:
:
Extensions
;
use
crate
:
:
builder
:
:
ArgAction
;
use
crate
:
:
builder
:
:
IntoResettable
;
use
crate
:
:
builder
:
:
PossibleValue
;
use
crate
:
:
builder
:
:
Str
;
use
crate
:
:
builder
:
:
StyledStr
;
use
crate
:
:
builder
:
:
Styles
;
use
crate
:
:
builder
:
:
{
Arg
ArgGroup
ArgPredicate
}
;
use
crate
:
:
error
:
:
ErrorKind
;
use
crate
:
:
error
:
:
Result
as
ClapResult
;
use
crate
:
:
mkeymap
:
:
MKeyMap
;
use
crate
:
:
output
:
:
fmt
:
:
Stream
;
use
crate
:
:
output
:
:
{
fmt
:
:
Colorizer
write_help
Usage
}
;
use
crate
:
:
parser
:
:
{
ArgMatcher
ArgMatches
Parser
}
;
use
crate
:
:
util
:
:
ChildGraph
;
use
crate
:
:
util
:
:
{
color
:
:
ColorChoice
Id
}
;
use
crate
:
:
{
Error
INTERNAL_ERROR_MSG
}
;
#
[
cfg
(
debug_assertions
)
]
use
crate
:
:
builder
:
:
debug_asserts
:
:
assert_app
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Command
{
name
:
Str
long_flag
:
Option
<
Str
>
short_flag
:
Option
<
char
>
display_name
:
Option
<
String
>
bin_name
:
Option
<
String
>
author
:
Option
<
Str
>
version
:
Option
<
Str
>
long_version
:
Option
<
Str
>
about
:
Option
<
StyledStr
>
long_about
:
Option
<
StyledStr
>
before_help
:
Option
<
StyledStr
>
before_long_help
:
Option
<
StyledStr
>
after_help
:
Option
<
StyledStr
>
after_long_help
:
Option
<
StyledStr
>
aliases
:
Vec
<
(
Str
bool
)
>
short_flag_aliases
:
Vec
<
(
char
bool
)
>
long_flag_aliases
:
Vec
<
(
Str
bool
)
>
usage_str
:
Option
<
StyledStr
>
usage_name
:
Option
<
String
>
help_str
:
Option
<
StyledStr
>
disp_ord
:
Option
<
usize
>
#
[
cfg
(
feature
=
"
help
"
)
]
template
:
Option
<
StyledStr
>
settings
:
AppFlags
g_settings
:
AppFlags
args
:
MKeyMap
subcommands
:
Vec
<
Command
>
groups
:
Vec
<
ArgGroup
>
current_help_heading
:
Option
<
Str
>
current_disp_ord
:
Option
<
usize
>
subcommand_value_name
:
Option
<
Str
>
subcommand_heading
:
Option
<
Str
>
external_value_parser
:
Option
<
super
:
:
ValueParser
>
long_help_exists
:
bool
deferred
:
Option
<
fn
(
Command
)
-
>
Command
>
app_ext
:
Extensions
}
impl
Command
{
pub
fn
new
(
name
:
impl
Into
<
Str
>
)
-
>
Self
{
fn
new_inner
(
name
:
Str
)
-
>
Command
{
Command
{
name
.
.
Default
:
:
default
(
)
}
}
new_inner
(
name
.
into
(
)
)
}
#
[
must_use
]
pub
fn
arg
(
mut
self
a
:
impl
Into
<
Arg
>
)
-
>
Self
{
let
arg
=
a
.
into
(
)
;
self
.
arg_internal
(
arg
)
;
self
}
fn
arg_internal
(
&
mut
self
mut
arg
:
Arg
)
{
if
let
Some
(
current_disp_ord
)
=
self
.
current_disp_ord
.
as_mut
(
)
{
if
!
arg
.
is_positional
(
)
{
let
current
=
*
current_disp_ord
;
arg
.
disp_ord
.
get_or_insert
(
current
)
;
*
current_disp_ord
=
current
+
1
;
}
}
arg
.
help_heading
.
get_or_insert_with
(
|
|
self
.
current_help_heading
.
clone
(
)
)
;
self
.
args
.
push
(
arg
)
;
}
#
[
must_use
]
pub
fn
args
(
mut
self
args
:
impl
IntoIterator
<
Item
=
impl
Into
<
Arg
>
>
)
-
>
Self
{
for
arg
in
args
{
self
=
self
.
arg
(
arg
)
;
}
self
}
#
[
must_use
]
#
[
cfg_attr
(
debug_assertions
track_caller
)
]
pub
fn
mut_arg
<
F
>
(
mut
self
arg_id
:
impl
AsRef
<
str
>
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
Arg
)
-
>
Arg
{
let
id
=
arg_id
.
as_ref
(
)
;
let
a
=
self
.
args
.
remove_by_name
(
id
)
.
unwrap_or_else
(
|
|
panic
!
(
"
Argument
{
id
}
is
undefined
"
)
)
;
self
.
args
.
push
(
f
(
a
)
)
;
self
}
#
[
cfg_attr
(
feature
=
"
string
"
doc
=
"
"
)
]
#
[
cfg_attr
(
not
(
feature
=
"
string
"
)
doc
=
"
ignore
"
)
]
#
[
must_use
]
#
[
cfg_attr
(
debug_assertions
track_caller
)
]
pub
fn
mut_args
<
F
>
(
mut
self
f
:
F
)
-
>
Self
where
F
:
FnMut
(
Arg
)
-
>
Arg
{
self
.
args
.
mut_args
(
f
)
;
self
}
#
[
must_use
]
pub
fn
mut_subcommand
<
F
>
(
mut
self
name
:
impl
AsRef
<
str
>
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
Self
)
-
>
Self
{
let
name
=
name
.
as_ref
(
)
;
let
pos
=
self
.
subcommands
.
iter
(
)
.
position
(
|
s
|
s
.
name
=
=
name
)
;
let
subcmd
=
if
let
Some
(
idx
)
=
pos
{
self
.
subcommands
.
remove
(
idx
)
}
else
{
panic
!
(
"
Command
{
name
}
is
undefined
"
)
}
;
self
.
subcommands
.
push
(
f
(
subcmd
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
group
(
mut
self
group
:
impl
Into
<
ArgGroup
>
)
-
>
Self
{
self
.
groups
.
push
(
group
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
groups
(
mut
self
groups
:
impl
IntoIterator
<
Item
=
impl
Into
<
ArgGroup
>
>
)
-
>
Self
{
for
g
in
groups
.
into_iter
(
)
{
self
=
self
.
group
(
g
.
into
(
)
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
subcommand
(
self
subcmd
:
impl
Into
<
Command
>
)
-
>
Self
{
let
subcmd
=
subcmd
.
into
(
)
;
self
.
subcommand_internal
(
subcmd
)
}
fn
subcommand_internal
(
mut
self
mut
subcmd
:
Self
)
-
>
Self
{
if
let
Some
(
current_disp_ord
)
=
self
.
current_disp_ord
.
as_mut
(
)
{
let
current
=
*
current_disp_ord
;
subcmd
.
disp_ord
.
get_or_insert
(
current
)
;
*
current_disp_ord
=
current
+
1
;
}
self
.
subcommands
.
push
(
subcmd
)
;
self
}
#
[
must_use
]
pub
fn
subcommands
(
mut
self
subcmds
:
impl
IntoIterator
<
Item
=
impl
Into
<
Self
>
>
)
-
>
Self
{
for
subcmd
in
subcmds
{
self
=
self
.
subcommand
(
subcmd
)
;
}
self
}
pub
fn
defer
(
mut
self
deferred
:
fn
(
Command
)
-
>
Command
)
-
>
Self
{
self
.
deferred
=
Some
(
deferred
)
;
self
}
pub
fn
debug_assert
(
mut
self
)
{
self
.
build
(
)
;
}
pub
fn
error
(
&
mut
self
kind
:
ErrorKind
message
:
impl
std
:
:
fmt
:
:
Display
)
-
>
Error
{
Error
:
:
raw
(
kind
message
)
.
format
(
self
)
}
#
[
inline
]
pub
fn
get_matches
(
self
)
-
>
ArgMatches
{
self
.
get_matches_from
(
env
:
:
args_os
(
)
)
}
pub
fn
get_matches_mut
(
&
mut
self
)
-
>
ArgMatches
{
self
.
try_get_matches_from_mut
(
&
mut
env
:
:
args_os
(
)
)
.
unwrap_or_else
(
|
e
|
e
.
exit
(
)
)
}
#
[
inline
]
pub
fn
try_get_matches
(
self
)
-
>
ClapResult
<
ArgMatches
>
{
self
.
try_get_matches_from
(
env
:
:
args_os
(
)
)
}
pub
fn
get_matches_from
<
I
T
>
(
mut
self
itr
:
I
)
-
>
ArgMatches
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
try_get_matches_from_mut
(
itr
)
.
unwrap_or_else
(
|
e
|
{
drop
(
self
)
;
e
.
exit
(
)
}
)
}
pub
fn
try_get_matches_from
<
I
T
>
(
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
self
.
try_get_matches_from_mut
(
itr
)
}
pub
fn
try_get_matches_from_mut
<
I
T
>
(
&
mut
self
itr
:
I
)
-
>
ClapResult
<
ArgMatches
>
where
I
:
IntoIterator
<
Item
=
T
>
T
:
Into
<
OsString
>
+
Clone
{
let
mut
raw_args
=
clap_lex
:
:
RawArgs
:
:
new
(
itr
.
into_iter
(
)
)
;
let
mut
cursor
=
raw_args
.
cursor
(
)
;
if
self
.
settings
.
is_set
(
AppSettings
:
:
Multicall
)
{
if
let
Some
(
argv0
)
=
raw_args
.
next_os
(
&
mut
cursor
)
{
let
argv0
=
Path
:
:
new
(
&
argv0
)
;
if
let
Some
(
command
)
=
argv0
.
file_stem
(
)
.
and_then
(
|
f
|
f
.
to_str
(
)
)
{
let
command
=
command
.
to_owned
(
)
;
debug
!
(
"
Command
:
:
try_get_matches_from_mut
:
Parsed
command
{
command
}
from
argv
"
)
;
debug
!
(
"
Command
:
:
try_get_matches_from_mut
:
Reinserting
command
into
arguments
so
subcommand
parser
matches
it
"
)
;
raw_args
.
insert
(
&
cursor
[
&
command
]
)
;
debug
!
(
"
Command
:
:
try_get_matches_from_mut
:
Clearing
name
and
bin_name
so
that
displayed
command
name
starts
with
applet
name
"
)
;
self
.
name
=
"
"
.
into
(
)
;
self
.
bin_name
=
None
;
return
self
.
_do_parse
(
&
mut
raw_args
cursor
)
;
}
}
}
;
if
!
self
.
settings
.
is_set
(
AppSettings
:
:
NoBinaryName
)
{
if
let
Some
(
name
)
=
raw_args
.
next_os
(
&
mut
cursor
)
{
let
p
=
Path
:
:
new
(
name
)
;
if
let
Some
(
f
)
=
p
.
file_name
(
)
{
if
let
Some
(
s
)
=
f
.
to_str
(
)
{
if
self
.
bin_name
.
is_none
(
)
{
self
.
bin_name
=
Some
(
s
.
to_owned
(
)
)
;
}
}
}
}
}
self
.
_do_parse
(
&
mut
raw_args
cursor
)
}
pub
fn
print_help
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build_self
(
false
)
;
let
color
=
self
.
color_help
(
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
write_help
(
&
mut
styled
self
&
usage
false
)
;
let
c
=
Colorizer
:
:
new
(
Stream
:
:
Stdout
color
)
.
with_content
(
styled
)
;
c
.
print
(
)
}
pub
fn
print_long_help
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build_self
(
false
)
;
let
color
=
self
.
color_help
(
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
write_help
(
&
mut
styled
self
&
usage
true
)
;
let
c
=
Colorizer
:
:
new
(
Stream
:
:
Stdout
color
)
.
with_content
(
styled
)
;
c
.
print
(
)
}
pub
fn
render_help
(
&
mut
self
)
-
>
StyledStr
{
self
.
_build_self
(
false
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
write_help
(
&
mut
styled
self
&
usage
false
)
;
styled
}
pub
fn
render_long_help
(
&
mut
self
)
-
>
StyledStr
{
self
.
_build_self
(
false
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
write_help
(
&
mut
styled
self
&
usage
true
)
;
styled
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Command
:
:
render_help
"
)
)
]
pub
fn
write_help
<
W
:
io
:
:
Write
>
(
&
mut
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build_self
(
false
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
write_help
(
&
mut
styled
self
&
usage
false
)
;
ok
!
(
write
!
(
w
"
{
styled
}
"
)
)
;
w
.
flush
(
)
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Command
:
:
render_long_help
"
)
)
]
pub
fn
write_long_help
<
W
:
io
:
:
Write
>
(
&
mut
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_build_self
(
false
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
write_help
(
&
mut
styled
self
&
usage
true
)
;
ok
!
(
write
!
(
w
"
{
styled
}
"
)
)
;
w
.
flush
(
)
}
pub
fn
render_version
(
&
self
)
-
>
String
{
self
.
_render_version
(
false
)
}
pub
fn
render_long_version
(
&
self
)
-
>
String
{
self
.
_render_version
(
true
)
}
pub
fn
render_usage
(
&
mut
self
)
-
>
StyledStr
{
self
.
render_usage_
(
)
.
unwrap_or_default
(
)
}
pub
(
crate
)
fn
render_usage_
(
&
mut
self
)
-
>
Option
<
StyledStr
>
{
self
.
_build_self
(
false
)
;
Usage
:
:
new
(
self
)
.
create_usage_with_title
(
&
[
]
)
}
}
impl
Command
{
#
[
inline
]
pub
fn
no_binary_name
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
NoBinaryName
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
NoBinaryName
)
}
}
#
[
inline
]
pub
fn
ignore_errors
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
IgnoreErrors
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
IgnoreErrors
)
}
}
#
[
inline
]
pub
fn
args_override_self
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
AllArgsOverrideSelf
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
AllArgsOverrideSelf
)
}
}
#
[
inline
]
pub
fn
dont_delimit_trailing_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
DontDelimitTrailingValues
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
DontDelimitTrailingValues
)
}
}
#
[
cfg
(
feature
=
"
color
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
color
(
self
color
:
ColorChoice
)
-
>
Self
{
let
cmd
=
self
.
unset_global_setting
(
AppSettings
:
:
ColorAuto
)
.
unset_global_setting
(
AppSettings
:
:
ColorAlways
)
.
unset_global_setting
(
AppSettings
:
:
ColorNever
)
;
match
color
{
ColorChoice
:
:
Auto
=
>
cmd
.
global_setting
(
AppSettings
:
:
ColorAuto
)
ColorChoice
:
:
Always
=
>
cmd
.
global_setting
(
AppSettings
:
:
ColorAlways
)
ColorChoice
:
:
Never
=
>
cmd
.
global_setting
(
AppSettings
:
:
ColorNever
)
}
}
#
[
cfg
(
feature
=
"
color
"
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
styles
(
mut
self
styles
:
Styles
)
-
>
Self
{
self
.
app_ext
.
set
(
styles
)
;
self
}
#
[
inline
]
#
[
must_use
]
#
[
cfg
(
any
(
not
(
feature
=
"
unstable
-
v5
"
)
feature
=
"
wrap_help
"
)
)
]
pub
fn
term_width
(
mut
self
width
:
usize
)
-
>
Self
{
self
.
app_ext
.
set
(
TermWidth
(
width
)
)
;
self
}
#
[
inline
]
#
[
must_use
]
#
[
cfg
(
any
(
not
(
feature
=
"
unstable
-
v5
"
)
feature
=
"
wrap_help
"
)
)
]
pub
fn
max_term_width
(
mut
self
width
:
usize
)
-
>
Self
{
self
.
app_ext
.
set
(
MaxTermWidth
(
width
)
)
;
self
}
#
[
inline
]
pub
fn
disable_version_flag
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
DisableVersionFlag
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
DisableVersionFlag
)
}
}
#
[
inline
]
pub
fn
propagate_version
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
PropagateVersion
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
PropagateVersion
)
}
}
#
[
inline
]
pub
fn
next_line_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
NextLineHelp
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
NextLineHelp
)
}
}
#
[
inline
]
pub
fn
disable_help_flag
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
DisableHelpFlag
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
DisableHelpFlag
)
}
}
#
[
inline
]
pub
fn
disable_help_subcommand
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
DisableHelpSubcommand
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
DisableHelpSubcommand
)
}
}
#
[
inline
]
pub
fn
disable_colored_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
DisableColoredHelp
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
DisableColoredHelp
)
}
}
#
[
inline
]
pub
fn
help_expected
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
HelpExpected
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
HelpExpected
)
}
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
This
is
now
the
default
"
)
)
]
pub
fn
dont_collapse_args_in_usage
(
self
_yes
:
bool
)
-
>
Self
{
self
}
#
[
inline
]
pub
fn
hide_possible_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
HidePossibleValues
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
HidePossibleValues
)
}
}
#
[
inline
]
pub
fn
infer_long_args
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
InferLongArgs
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
InferLongArgs
)
}
}
#
[
inline
]
pub
fn
infer_subcommands
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
global_setting
(
AppSettings
:
:
InferSubcommands
)
}
else
{
self
.
unset_global_setting
(
AppSettings
:
:
InferSubcommands
)
}
}
}
impl
Command
{
#
[
must_use
]
pub
fn
name
(
mut
self
name
:
impl
Into
<
Str
>
)
-
>
Self
{
self
.
name
=
name
.
into
(
)
;
self
}
#
[
must_use
]
pub
fn
bin_name
(
mut
self
name
:
impl
IntoResettable
<
String
>
)
-
>
Self
{
self
.
bin_name
=
name
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
display_name
(
mut
self
name
:
impl
IntoResettable
<
String
>
)
-
>
Self
{
self
.
display_name
=
name
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
author
(
mut
self
author
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
author
=
author
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
about
(
mut
self
about
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
about
=
about
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
long_about
(
mut
self
long_about
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
long_about
=
long_about
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
after_help
(
mut
self
help
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
after_help
=
help
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
after_long_help
(
mut
self
help
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
after_long_help
=
help
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
before_help
(
mut
self
help
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
before_help
=
help
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
before_long_help
(
mut
self
help
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
before_long_help
=
help
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
version
(
mut
self
ver
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
version
=
ver
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
long_version
(
mut
self
ver
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
long_version
=
ver
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
override_usage
(
mut
self
usage
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
usage_str
=
usage
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
override_help
(
mut
self
help
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
help_str
=
help
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
#
[
cfg
(
feature
=
"
help
"
)
]
pub
fn
help_template
(
mut
self
s
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
template
=
s
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
(
crate
)
fn
setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
settings
.
set
(
setting
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
(
crate
)
fn
unset_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
settings
.
unset
(
setting
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
(
crate
)
fn
global_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
settings
.
set
(
setting
)
;
self
.
g_settings
.
set
(
setting
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
(
crate
)
fn
unset_global_setting
(
mut
self
setting
:
AppSettings
)
-
>
Self
{
self
.
settings
.
unset
(
setting
)
;
self
.
g_settings
.
unset
(
setting
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
next_help_heading
(
mut
self
heading
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
current_help_heading
=
heading
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
next_display_order
(
mut
self
disp_ord
:
impl
IntoResettable
<
usize
>
)
-
>
Self
{
self
.
current_disp_ord
=
disp_ord
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
pub
fn
arg_required_else_help
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
ArgRequiredElseHelp
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
ArgRequiredElseHelp
)
}
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
allow_hyphen_values
"
)
)
]
pub
fn
allow_hyphen_values
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
AllowHyphenValues
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
AllowHyphenValues
)
}
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
allow_negative_numbers
"
)
)
]
pub
fn
allow_negative_numbers
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
AllowNegativeNumbers
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
AllowNegativeNumbers
)
}
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
trailing_var_arg
"
)
)
]
pub
fn
trailing_var_arg
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
TrailingVarArg
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
TrailingVarArg
)
}
}
#
[
inline
]
pub
fn
allow_missing_positional
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
AllowMissingPositional
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
AllowMissingPositional
)
}
}
}
impl
Command
{
#
[
must_use
]
pub
fn
short_flag
(
mut
self
short
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
self
.
short_flag
=
short
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
long_flag
(
mut
self
long
:
impl
Into
<
Str
>
)
-
>
Self
{
self
.
long_flag
=
Some
(
long
.
into
(
)
)
;
self
}
#
[
must_use
]
pub
fn
alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
aliases
.
push
(
(
name
false
)
)
;
}
else
{
self
.
aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
short_flag_alias
(
mut
self
name
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
debug_assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
name
false
)
)
;
}
else
{
self
.
short_flag_aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
long_flag_alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
long_flag_aliases
.
push
(
(
name
false
)
)
;
}
else
{
self
.
long_flag_aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
into_iter
(
)
.
map
(
|
n
|
(
n
.
into
(
)
false
)
)
)
;
self
}
#
[
must_use
]
pub
fn
short_flag_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
char
>
)
-
>
Self
{
for
s
in
names
{
debug_assert
!
(
s
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
s
false
)
)
;
}
self
}
#
[
must_use
]
pub
fn
long_flag_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
for
s
in
names
{
self
=
self
.
long_flag_alias
(
s
)
}
self
}
#
[
must_use
]
pub
fn
visible_alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
aliases
.
push
(
(
name
true
)
)
;
}
else
{
self
.
aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_short_flag_alias
(
mut
self
name
:
impl
IntoResettable
<
char
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
debug_assert
!
(
name
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
name
true
)
)
;
}
else
{
self
.
short_flag_aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_long_flag_alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
long_flag_aliases
.
push
(
(
name
true
)
)
;
}
else
{
self
.
long_flag_aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
into_iter
(
)
.
map
(
|
n
|
(
n
.
into
(
)
true
)
)
)
;
self
}
#
[
must_use
]
pub
fn
visible_short_flag_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
char
>
)
-
>
Self
{
for
s
in
names
{
debug_assert
!
(
s
!
=
'
-
'
"
short
alias
name
cannot
be
-
"
)
;
self
.
short_flag_aliases
.
push
(
(
s
true
)
)
;
}
self
}
#
[
must_use
]
pub
fn
visible_long_flag_aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
for
s
in
names
{
self
=
self
.
visible_long_flag_alias
(
s
)
;
}
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
display_order
(
mut
self
ord
:
impl
IntoResettable
<
usize
>
)
-
>
Self
{
self
.
disp_ord
=
ord
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
pub
fn
hide
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
Hidden
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
Hidden
)
}
}
pub
fn
subcommand_required
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
SubcommandRequired
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
SubcommandRequired
)
}
}
pub
fn
allow_external_subcommands
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
AllowExternalSubcommands
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
AllowExternalSubcommands
)
}
}
pub
fn
external_subcommand_value_parser
(
mut
self
parser
:
impl
IntoResettable
<
super
:
:
ValueParser
>
)
-
>
Self
{
self
.
external_value_parser
=
parser
.
into_resettable
(
)
.
into_option
(
)
;
self
}
pub
fn
args_conflicts_with_subcommands
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
ArgsNegateSubcommands
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
ArgsNegateSubcommands
)
}
}
pub
fn
subcommand_precedence_over_arg
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
SubcommandPrecedenceOverArg
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
SubcommandPrecedenceOverArg
)
}
}
pub
fn
subcommand_negates_reqs
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
SubcommandsNegateReqs
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
SubcommandsNegateReqs
)
}
}
#
[
inline
]
pub
fn
multicall
(
self
yes
:
bool
)
-
>
Self
{
if
yes
{
self
.
setting
(
AppSettings
:
:
Multicall
)
}
else
{
self
.
unset_setting
(
AppSettings
:
:
Multicall
)
}
}
#
[
must_use
]
pub
fn
subcommand_value_name
(
mut
self
value_name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
subcommand_value_name
=
value_name
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
must_use
]
pub
fn
subcommand_help_heading
(
mut
self
heading
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
self
.
subcommand_heading
=
heading
.
into_resettable
(
)
.
into_option
(
)
;
self
}
}
impl
Command
{
#
[
inline
]
#
[
cfg
(
feature
=
"
usage
"
)
]
pub
(
crate
)
fn
get_usage_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
usage_name
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_display_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
display_name
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_bin_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
bin_name
.
as_deref
(
)
}
pub
fn
set_bin_name
(
&
mut
self
name
:
impl
Into
<
String
>
)
{
self
.
bin_name
=
Some
(
name
.
into
(
)
)
;
}
#
[
inline
]
pub
fn
get_name
(
&
self
)
-
>
&
str
{
self
.
name
.
as_str
(
)
}
#
[
inline
]
#
[
cfg
(
debug_assertions
)
]
pub
(
crate
)
fn
get_name_str
(
&
self
)
-
>
&
Str
{
&
self
.
name
}
#
[
inline
]
pub
fn
get_version
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
version
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_long_version
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
long_version
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_author
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
author
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_short_flag
(
&
self
)
-
>
Option
<
char
>
{
self
.
short_flag
}
#
[
inline
]
pub
fn
get_long_flag
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
long_flag
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_about
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
about
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_long_about
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
long_about
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_next_help_heading
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
current_help_heading
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_visible_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
'
_
{
self
.
aliases
.
iter
(
)
.
filter
(
|
(
_
vis
)
|
*
vis
)
.
map
(
|
a
|
a
.
0
.
as_str
(
)
)
}
#
[
inline
]
pub
fn
get_visible_short_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
char
>
+
'
_
{
self
.
short_flag_aliases
.
iter
(
)
.
filter
(
|
(
_
vis
)
|
*
vis
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_visible_long_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
'
_
{
self
.
long_flag_aliases
.
iter
(
)
.
filter
(
|
(
_
vis
)
|
*
vis
)
.
map
(
|
a
|
a
.
0
.
as_str
(
)
)
}
#
[
inline
]
pub
fn
get_all_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
'
_
{
self
.
aliases
.
iter
(
)
.
map
(
|
a
|
a
.
0
.
as_str
(
)
)
}
#
[
inline
]
pub
fn
get_all_short_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
char
>
+
'
_
{
self
.
short_flag_aliases
.
iter
(
)
.
map
(
|
a
|
a
.
0
)
}
#
[
inline
]
pub
fn
get_all_long_flag_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
'
_
{
self
.
long_flag_aliases
.
iter
(
)
.
map
(
|
a
|
a
.
0
.
as_str
(
)
)
}
#
[
inline
]
pub
(
crate
)
fn
is_set
(
&
self
s
:
AppSettings
)
-
>
bool
{
self
.
settings
.
is_set
(
s
)
|
|
self
.
g_settings
.
is_set
(
s
)
}
pub
fn
get_color
(
&
self
)
-
>
ColorChoice
{
debug
!
(
"
Command
:
:
color
:
Color
setting
.
.
.
"
)
;
if
cfg
!
(
feature
=
"
color
"
)
{
if
self
.
is_set
(
AppSettings
:
:
ColorNever
)
{
debug
!
(
"
Never
"
)
;
ColorChoice
:
:
Never
}
else
if
self
.
is_set
(
AppSettings
:
:
ColorAlways
)
{
debug
!
(
"
Always
"
)
;
ColorChoice
:
:
Always
}
else
{
debug
!
(
"
Auto
"
)
;
ColorChoice
:
:
Auto
}
}
else
{
ColorChoice
:
:
Never
}
}
#
[
inline
]
pub
fn
get_styles
(
&
self
)
-
>
&
Styles
{
self
.
app_ext
.
get
(
)
.
unwrap_or_default
(
)
}
#
[
inline
]
pub
fn
get_subcommands
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Command
>
{
self
.
subcommands
.
iter
(
)
}
#
[
inline
]
pub
fn
get_subcommands_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
Command
>
{
self
.
subcommands
.
iter_mut
(
)
}
#
[
inline
]
pub
fn
has_subcommands
(
&
self
)
-
>
bool
{
!
self
.
subcommands
.
is_empty
(
)
}
#
[
inline
]
pub
fn
get_subcommand_help_heading
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
subcommand_heading
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_subcommand_value_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
subcommand_value_name
.
as_deref
(
)
}
#
[
inline
]
pub
fn
get_before_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
before_help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_before_long_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
before_long_help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_after_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
after_help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
get_after_long_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
after_long_help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
find_subcommand
(
&
self
name
:
impl
AsRef
<
std
:
:
ffi
:
:
OsStr
>
)
-
>
Option
<
&
Command
>
{
let
name
=
name
.
as_ref
(
)
;
self
.
get_subcommands
(
)
.
find
(
|
s
|
s
.
aliases_to
(
name
)
)
}
#
[
inline
]
pub
fn
find_subcommand_mut
(
&
mut
self
name
:
impl
AsRef
<
std
:
:
ffi
:
:
OsStr
>
)
-
>
Option
<
&
mut
Command
>
{
let
name
=
name
.
as_ref
(
)
;
self
.
get_subcommands_mut
(
)
.
find
(
|
s
|
s
.
aliases_to
(
name
)
)
}
#
[
inline
]
pub
fn
get_groups
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
ArgGroup
>
{
self
.
groups
.
iter
(
)
}
#
[
inline
]
pub
fn
get_arguments
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
>
{
self
.
args
.
args
(
)
}
#
[
inline
]
pub
fn
get_positionals
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
>
{
self
.
get_arguments
(
)
.
filter
(
|
a
|
a
.
is_positional
(
)
)
}
pub
fn
get_opts
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
>
{
self
.
get_arguments
(
)
.
filter
(
|
a
|
a
.
is_takes_value_set
(
)
&
&
!
a
.
is_positional
(
)
)
}
pub
fn
get_arg_conflicts_with
(
&
self
arg
:
&
Arg
)
-
>
Vec
<
&
Arg
>
{
if
arg
.
is_global_set
(
)
{
self
.
get_global_arg_conflicts_with
(
arg
)
}
else
{
let
mut
result
=
Vec
:
:
new
(
)
;
for
id
in
arg
.
blacklist
.
iter
(
)
{
if
let
Some
(
arg
)
=
self
.
find
(
id
)
{
result
.
push
(
arg
)
;
}
else
if
let
Some
(
group
)
=
self
.
find_group
(
id
)
{
result
.
extend
(
self
.
unroll_args_in_group
(
&
group
.
id
)
.
iter
(
)
.
map
(
|
id
|
self
.
find
(
id
)
.
expect
(
INTERNAL_ERROR_MSG
)
)
)
;
}
else
{
panic
!
(
"
Command
:
:
get_arg_conflicts_with
:
The
passed
arg
conflicts
with
an
arg
unknown
to
the
cmd
"
)
;
}
}
result
}
}
fn
get_global_arg_conflicts_with
(
&
self
arg
:
&
Arg
)
-
>
Vec
<
&
Arg
>
{
arg
.
blacklist
.
iter
(
)
.
map
(
|
id
|
{
self
.
args
.
args
(
)
.
chain
(
self
.
get_subcommands_containing
(
arg
)
.
iter
(
)
.
flat_map
(
|
x
|
x
.
args
.
args
(
)
)
)
.
find
(
|
arg
|
arg
.
get_id
(
)
=
=
id
)
.
expect
(
"
Command
:
:
get_arg_conflicts_with
:
\
The
passed
arg
conflicts
with
an
arg
unknown
to
the
cmd
"
)
}
)
.
collect
(
)
}
fn
get_subcommands_containing
(
&
self
arg
:
&
Arg
)
-
>
Vec
<
&
Self
>
{
let
mut
vec
=
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
for
idx
in
0
.
.
self
.
subcommands
.
len
(
)
{
if
self
.
subcommands
[
idx
]
.
args
.
args
(
)
.
any
(
|
ar
|
ar
.
get_id
(
)
=
=
arg
.
get_id
(
)
)
{
vec
.
push
(
&
self
.
subcommands
[
idx
]
)
;
vec
.
append
(
&
mut
self
.
subcommands
[
idx
]
.
get_subcommands_containing
(
arg
)
)
;
}
}
vec
}
pub
fn
is_no_binary_name_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
NoBinaryName
)
}
pub
(
crate
)
fn
is_ignore_errors_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
IgnoreErrors
)
}
pub
fn
is_dont_delimit_trailing_values_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
DontDelimitTrailingValues
)
}
pub
fn
is_disable_version_flag_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
DisableVersionFlag
)
|
|
(
self
.
version
.
is_none
(
)
&
&
self
.
long_version
.
is_none
(
)
)
}
pub
fn
is_propagate_version_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
PropagateVersion
)
}
pub
fn
is_next_line_help_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
NextLineHelp
)
}
pub
fn
is_disable_help_flag_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
DisableHelpFlag
)
}
pub
fn
is_disable_help_subcommand_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
DisableHelpSubcommand
)
}
pub
fn
is_disable_colored_help_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
DisableColoredHelp
)
}
#
[
cfg
(
debug_assertions
)
]
pub
(
crate
)
fn
is_help_expected_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
HelpExpected
)
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
This
is
now
the
default
"
)
)
]
pub
fn
is_dont_collapse_args_in_usage_set
(
&
self
)
-
>
bool
{
true
}
pub
(
crate
)
fn
is_infer_long_args_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
InferLongArgs
)
}
pub
(
crate
)
fn
is_infer_subcommands_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
InferSubcommands
)
}
pub
fn
is_arg_required_else_help_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
ArgRequiredElseHelp
)
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
is_allow_hyphen_values_set
"
)
)
]
pub
(
crate
)
fn
is_allow_hyphen_values_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
AllowHyphenValues
)
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
is_allow_negative_numbers_set
"
)
)
]
pub
fn
is_allow_negative_numbers_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
AllowNegativeNumbers
)
}
#
[
doc
(
hidden
)
]
#
[
cfg_attr
(
feature
=
"
deprecated
"
deprecated
(
since
=
"
4
.
0
.
0
"
note
=
"
Replaced
with
Arg
:
:
is_trailing_var_arg_set
"
)
)
]
pub
fn
is_trailing_var_arg_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
TrailingVarArg
)
}
pub
fn
is_allow_missing_positional_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
AllowMissingPositional
)
}
pub
fn
is_hide_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
Hidden
)
}
pub
fn
is_subcommand_required_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
SubcommandRequired
)
}
pub
fn
is_allow_external_subcommands_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
AllowExternalSubcommands
)
}
pub
fn
get_external_subcommand_value_parser
(
&
self
)
-
>
Option
<
&
super
:
:
ValueParser
>
{
if
!
self
.
is_allow_external_subcommands_set
(
)
{
None
}
else
{
static
DEFAULT
:
super
:
:
ValueParser
=
super
:
:
ValueParser
:
:
os_string
(
)
;
Some
(
self
.
external_value_parser
.
as_ref
(
)
.
unwrap_or
(
&
DEFAULT
)
)
}
}
pub
fn
is_args_conflicts_with_subcommands_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
ArgsNegateSubcommands
)
}
#
[
doc
(
hidden
)
]
pub
fn
is_args_override_self
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
AllArgsOverrideSelf
)
}
pub
fn
is_subcommand_precedence_over_arg_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
SubcommandPrecedenceOverArg
)
}
pub
fn
is_subcommand_negates_reqs_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
SubcommandsNegateReqs
)
}
pub
fn
is_multicall_set
(
&
self
)
-
>
bool
{
self
.
is_set
(
AppSettings
:
:
Multicall
)
}
}
impl
Command
{
pub
(
crate
)
fn
get_override_usage
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
usage_str
.
as_ref
(
)
}
pub
(
crate
)
fn
get_override_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
help_str
.
as_ref
(
)
}
#
[
cfg
(
feature
=
"
help
"
)
]
pub
(
crate
)
fn
get_help_template
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
template
.
as_ref
(
)
}
#
[
cfg
(
feature
=
"
help
"
)
]
pub
(
crate
)
fn
get_term_width
(
&
self
)
-
>
Option
<
usize
>
{
self
.
app_ext
.
get
:
:
<
TermWidth
>
(
)
.
map
(
|
e
|
e
.
0
)
}
#
[
cfg
(
feature
=
"
help
"
)
]
pub
(
crate
)
fn
get_max_term_width
(
&
self
)
-
>
Option
<
usize
>
{
self
.
app_ext
.
get
:
:
<
MaxTermWidth
>
(
)
.
map
(
|
e
|
e
.
0
)
}
pub
(
crate
)
fn
get_keymap
(
&
self
)
-
>
&
MKeyMap
{
&
self
.
args
}
fn
get_used_global_args
(
&
self
matches
:
&
ArgMatches
global_arg_vec
:
&
mut
Vec
<
Id
>
)
{
global_arg_vec
.
extend
(
self
.
args
.
args
(
)
.
filter
(
|
a
|
a
.
is_global_set
(
)
)
.
map
(
|
ga
|
ga
.
id
.
clone
(
)
)
)
;
if
let
Some
(
(
id
matches
)
)
=
matches
.
subcommand
(
)
{
if
let
Some
(
used_sub
)
=
self
.
find_subcommand
(
id
)
{
used_sub
.
get_used_global_args
(
matches
global_arg_vec
)
;
}
}
}
fn
_do_parse
(
&
mut
self
raw_args
:
&
mut
clap_lex
:
:
RawArgs
args_cursor
:
clap_lex
:
:
ArgCursor
)
-
>
ClapResult
<
ArgMatches
>
{
debug
!
(
"
Command
:
:
_do_parse
"
)
;
self
.
_build_self
(
false
)
;
let
mut
matcher
=
ArgMatcher
:
:
new
(
self
)
;
let
mut
parser
=
Parser
:
:
new
(
self
)
;
if
let
Err
(
error
)
=
parser
.
get_matches_with
(
&
mut
matcher
raw_args
args_cursor
)
{
if
self
.
is_set
(
AppSettings
:
:
IgnoreErrors
)
&
&
error
.
use_stderr
(
)
{
debug
!
(
"
Command
:
:
_do_parse
:
ignoring
error
:
{
error
}
"
)
;
}
else
{
return
Err
(
error
)
;
}
}
let
mut
global_arg_vec
=
Default
:
:
default
(
)
;
self
.
get_used_global_args
(
&
matcher
&
mut
global_arg_vec
)
;
matcher
.
propagate_globals
(
&
global_arg_vec
)
;
Ok
(
matcher
.
into_inner
(
)
)
}
pub
fn
build
(
&
mut
self
)
{
self
.
_build_recursive
(
true
)
;
self
.
_build_bin_names_internal
(
)
;
}
pub
(
crate
)
fn
_build_recursive
(
&
mut
self
expand_help_tree
:
bool
)
{
self
.
_build_self
(
expand_help_tree
)
;
for
subcmd
in
self
.
get_subcommands_mut
(
)
{
subcmd
.
_build_recursive
(
expand_help_tree
)
;
}
}
pub
(
crate
)
fn
_build_self
(
&
mut
self
expand_help_tree
:
bool
)
{
debug
!
(
"
Command
:
:
_build
:
name
=
{
:
?
}
"
self
.
get_name
(
)
)
;
if
!
self
.
settings
.
is_set
(
AppSettings
:
:
Built
)
{
if
let
Some
(
deferred
)
=
self
.
deferred
.
take
(
)
{
*
self
=
(
deferred
)
(
std
:
:
mem
:
:
take
(
self
)
)
;
}
self
.
settings
=
self
.
settings
|
self
.
g_settings
;
if
self
.
is_multicall_set
(
)
{
self
.
settings
.
set
(
AppSettings
:
:
SubcommandRequired
)
;
self
.
settings
.
set
(
AppSettings
:
:
DisableHelpFlag
)
;
self
.
settings
.
set
(
AppSettings
:
:
DisableVersionFlag
)
;
}
if
!
cfg
!
(
feature
=
"
help
"
)
&
&
self
.
get_override_help
(
)
.
is_none
(
)
{
self
.
settings
.
set
(
AppSettings
:
:
DisableHelpFlag
)
;
self
.
settings
.
set
(
AppSettings
:
:
DisableHelpSubcommand
)
;
}
if
self
.
is_set
(
AppSettings
:
:
ArgsNegateSubcommands
)
{
self
.
settings
.
set
(
AppSettings
:
:
SubcommandsNegateReqs
)
;
}
if
self
.
external_value_parser
.
is_some
(
)
{
self
.
settings
.
set
(
AppSettings
:
:
AllowExternalSubcommands
)
;
}
if
!
self
.
has_subcommands
(
)
{
self
.
settings
.
set
(
AppSettings
:
:
DisableHelpSubcommand
)
;
}
self
.
_propagate
(
)
;
self
.
_check_help_and_version
(
expand_help_tree
)
;
self
.
_propagate_global_args
(
)
;
let
mut
pos_counter
=
1
;
let
hide_pv
=
self
.
is_set
(
AppSettings
:
:
HidePossibleValues
)
;
for
a
in
self
.
args
.
args_mut
(
)
{
for
g
in
&
a
.
groups
{
if
let
Some
(
ag
)
=
self
.
groups
.
iter_mut
(
)
.
find
(
|
grp
|
grp
.
id
=
=
*
g
)
{
ag
.
args
.
push
(
a
.
get_id
(
)
.
clone
(
)
)
;
}
else
{
let
mut
ag
=
ArgGroup
:
:
new
(
g
)
;
ag
.
args
.
push
(
a
.
get_id
(
)
.
clone
(
)
)
;
self
.
groups
.
push
(
ag
)
;
}
}
a
.
_build
(
)
;
if
hide_pv
&
&
a
.
is_takes_value_set
(
)
{
a
.
settings
.
set
(
ArgSettings
:
:
HidePossibleValues
)
;
}
if
a
.
is_positional
(
)
&
&
a
.
index
.
is_none
(
)
{
a
.
index
=
Some
(
pos_counter
)
;
pos_counter
+
=
1
;
}
}
self
.
args
.
_build
(
)
;
#
[
allow
(
deprecated
)
]
{
let
highest_idx
=
self
.
get_keymap
(
)
.
keys
(
)
.
filter_map
(
|
x
|
{
if
let
crate
:
:
mkeymap
:
:
KeyType
:
:
Position
(
n
)
=
x
{
Some
(
*
n
)
}
else
{
None
}
}
)
.
max
(
)
.
unwrap_or
(
0
)
;
let
is_trailing_var_arg_set
=
self
.
is_trailing_var_arg_set
(
)
;
let
is_allow_hyphen_values_set
=
self
.
is_allow_hyphen_values_set
(
)
;
let
is_allow_negative_numbers_set
=
self
.
is_allow_negative_numbers_set
(
)
;
for
arg
in
self
.
args
.
args_mut
(
)
{
if
is_allow_hyphen_values_set
&
&
arg
.
is_takes_value_set
(
)
{
arg
.
settings
.
set
(
ArgSettings
:
:
AllowHyphenValues
)
;
}
if
is_allow_negative_numbers_set
&
&
arg
.
is_takes_value_set
(
)
{
arg
.
settings
.
set
(
ArgSettings
:
:
AllowNegativeNumbers
)
;
}
if
is_trailing_var_arg_set
&
&
arg
.
get_index
(
)
=
=
Some
(
highest_idx
)
{
arg
.
settings
.
set
(
ArgSettings
:
:
TrailingVarArg
)
;
}
}
}
#
[
cfg
(
debug_assertions
)
]
assert_app
(
self
)
;
self
.
settings
.
set
(
AppSettings
:
:
Built
)
;
}
else
{
debug
!
(
"
Command
:
:
_build
:
already
built
"
)
;
}
}
pub
(
crate
)
fn
_build_subcommand
(
&
mut
self
name
:
&
str
)
-
>
Option
<
&
mut
Self
>
{
use
std
:
:
fmt
:
:
Write
;
let
mut
mid_string
=
String
:
:
from
(
"
"
)
;
#
[
cfg
(
feature
=
"
usage
"
)
]
if
!
self
.
is_subcommand_negates_reqs_set
(
)
&
&
!
self
.
is_args_conflicts_with_subcommands_set
(
)
{
let
reqs
=
Usage
:
:
new
(
self
)
.
get_required_usage_from
(
&
[
]
None
true
)
;
for
s
in
&
reqs
{
mid_string
.
push_str
(
&
s
.
to_string
(
)
)
;
mid_string
.
push
(
'
'
)
;
}
}
let
is_multicall_set
=
self
.
is_multicall_set
(
)
;
let
sc
=
some
!
(
self
.
subcommands
.
iter_mut
(
)
.
find
(
|
s
|
s
.
name
=
=
name
)
)
;
let
mut
sc_names
=
String
:
:
new
(
)
;
sc_names
.
push_str
(
sc
.
name
.
as_str
(
)
)
;
let
mut
flag_subcmd
=
false
;
if
let
Some
(
l
)
=
sc
.
get_long_flag
(
)
{
write
!
(
sc_names
"
|
-
-
{
l
}
"
)
.
unwrap
(
)
;
flag_subcmd
=
true
;
}
if
let
Some
(
s
)
=
sc
.
get_short_flag
(
)
{
write
!
(
sc_names
"
|
-
{
s
}
"
)
.
unwrap
(
)
;
flag_subcmd
=
true
;
}
if
flag_subcmd
{
sc_names
=
format
!
(
"
{
{
{
sc_names
}
}
}
"
)
;
}
let
usage_name
=
self
.
bin_name
.
as_ref
(
)
.
map
(
|
bin_name
|
format
!
(
"
{
bin_name
}
{
mid_string
}
{
sc_names
}
"
)
)
.
unwrap_or
(
sc_names
)
;
sc
.
usage_name
=
Some
(
usage_name
)
;
let
bin_name
=
format
!
(
"
{
}
{
}
{
}
"
self
.
bin_name
.
as_deref
(
)
.
unwrap_or_default
(
)
if
self
.
bin_name
.
is_some
(
)
{
"
"
}
else
{
"
"
}
&
*
sc
.
name
)
;
debug
!
(
"
Command
:
:
_build_subcommand
Setting
bin_name
of
{
}
to
{
:
?
}
"
sc
.
name
bin_name
)
;
sc
.
bin_name
=
Some
(
bin_name
)
;
if
sc
.
display_name
.
is_none
(
)
{
let
self_display_name
=
if
is_multicall_set
{
self
.
display_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
}
else
{
self
.
display_name
.
as_deref
(
)
.
unwrap_or
(
&
self
.
name
)
}
;
let
display_name
=
format
!
(
"
{
}
{
}
{
}
"
self_display_name
if
!
self_display_name
.
is_empty
(
)
{
"
-
"
}
else
{
"
"
}
&
*
sc
.
name
)
;
debug
!
(
"
Command
:
:
_build_subcommand
Setting
display_name
of
{
}
to
{
:
?
}
"
sc
.
name
display_name
)
;
sc
.
display_name
=
Some
(
display_name
)
;
}
sc
.
_build_self
(
false
)
;
Some
(
sc
)
}
fn
_build_bin_names_internal
(
&
mut
self
)
{
debug
!
(
"
Command
:
:
_build_bin_names
"
)
;
if
!
self
.
is_set
(
AppSettings
:
:
BinNameBuilt
)
{
let
mut
mid_string
=
String
:
:
from
(
"
"
)
;
#
[
cfg
(
feature
=
"
usage
"
)
]
if
!
self
.
is_subcommand_negates_reqs_set
(
)
&
&
!
self
.
is_args_conflicts_with_subcommands_set
(
)
{
let
reqs
=
Usage
:
:
new
(
self
)
.
get_required_usage_from
(
&
[
]
None
true
)
;
for
s
in
&
reqs
{
mid_string
.
push_str
(
&
s
.
to_string
(
)
)
;
mid_string
.
push
(
'
'
)
;
}
}
let
is_multicall_set
=
self
.
is_multicall_set
(
)
;
let
self_bin_name
=
if
is_multicall_set
{
self
.
bin_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
}
else
{
self
.
bin_name
.
as_deref
(
)
.
unwrap_or
(
&
self
.
name
)
}
.
to_owned
(
)
;
for
sc
in
&
mut
self
.
subcommands
{
debug
!
(
"
Command
:
:
_build_bin_names
:
iter
:
bin_name
set
.
.
.
"
)
;
if
sc
.
usage_name
.
is_none
(
)
{
use
std
:
:
fmt
:
:
Write
;
let
mut
sc_names
=
String
:
:
new
(
)
;
sc_names
.
push_str
(
sc
.
name
.
as_str
(
)
)
;
let
mut
flag_subcmd
=
false
;
if
let
Some
(
l
)
=
sc
.
get_long_flag
(
)
{
write
!
(
sc_names
"
|
-
-
{
l
}
"
)
.
unwrap
(
)
;
flag_subcmd
=
true
;
}
if
let
Some
(
s
)
=
sc
.
get_short_flag
(
)
{
write
!
(
sc_names
"
|
-
{
s
}
"
)
.
unwrap
(
)
;
flag_subcmd
=
true
;
}
if
flag_subcmd
{
sc_names
=
format
!
(
"
{
{
{
sc_names
}
}
}
"
)
;
}
let
usage_name
=
format
!
(
"
{
self_bin_name
}
{
mid_string
}
{
sc_names
}
"
)
;
debug
!
(
"
Command
:
:
_build_bin_names
:
iter
:
Setting
usage_name
of
{
}
to
{
:
?
}
"
sc
.
name
usage_name
)
;
sc
.
usage_name
=
Some
(
usage_name
)
;
}
else
{
debug
!
(
"
Command
:
:
_build_bin_names
:
:
iter
:
Using
existing
usage_name
of
{
}
(
{
:
?
}
)
"
sc
.
name
sc
.
usage_name
)
;
}
if
sc
.
bin_name
.
is_none
(
)
{
let
bin_name
=
format
!
(
"
{
}
{
}
{
}
"
self_bin_name
if
!
self_bin_name
.
is_empty
(
)
{
"
"
}
else
{
"
"
}
&
*
sc
.
name
)
;
debug
!
(
"
Command
:
:
_build_bin_names
:
iter
:
Setting
bin_name
of
{
}
to
{
:
?
}
"
sc
.
name
bin_name
)
;
sc
.
bin_name
=
Some
(
bin_name
)
;
}
else
{
debug
!
(
"
Command
:
:
_build_bin_names
:
:
iter
:
Using
existing
bin_name
of
{
}
(
{
:
?
}
)
"
sc
.
name
sc
.
bin_name
)
;
}
if
sc
.
display_name
.
is_none
(
)
{
let
self_display_name
=
if
is_multicall_set
{
self
.
display_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
}
else
{
self
.
display_name
.
as_deref
(
)
.
unwrap_or
(
&
self
.
name
)
}
;
let
display_name
=
format
!
(
"
{
}
{
}
{
}
"
self_display_name
if
!
self_display_name
.
is_empty
(
)
{
"
-
"
}
else
{
"
"
}
&
*
sc
.
name
)
;
debug
!
(
"
Command
:
:
_build_bin_names
:
iter
:
Setting
display_name
of
{
}
to
{
:
?
}
"
sc
.
name
display_name
)
;
sc
.
display_name
=
Some
(
display_name
)
;
}
else
{
debug
!
(
"
Command
:
:
_build_bin_names
:
:
iter
:
Using
existing
display_name
of
{
}
(
{
:
?
}
)
"
sc
.
name
sc
.
display_name
)
;
}
sc
.
_build_bin_names_internal
(
)
;
}
self
.
set
(
AppSettings
:
:
BinNameBuilt
)
;
}
else
{
debug
!
(
"
Command
:
:
_build_bin_names
:
already
built
"
)
;
}
}
pub
(
crate
)
fn
_panic_on_missing_help
(
&
self
help_required_globally
:
bool
)
{
if
self
.
is_set
(
AppSettings
:
:
HelpExpected
)
|
|
help_required_globally
{
let
args_missing_help
:
Vec
<
Id
>
=
self
.
args
.
args
(
)
.
filter
(
|
arg
|
arg
.
get_help
(
)
.
is_none
(
)
&
&
arg
.
get_long_help
(
)
.
is_none
(
)
)
.
map
(
|
arg
|
arg
.
get_id
(
)
.
clone
(
)
)
.
collect
(
)
;
debug_assert
!
(
args_missing_help
.
is_empty
(
)
"
Command
:
:
help_expected
is
enabled
for
the
Command
{
}
but
at
least
one
of
its
arguments
does
not
have
either
help
or
long_help
set
.
List
of
such
arguments
:
{
}
"
self
.
name
args_missing_help
.
join
(
"
"
)
)
;
}
for
sub_app
in
&
self
.
subcommands
{
sub_app
.
_panic_on_missing_help
(
help_required_globally
)
;
}
}
#
[
cfg
(
debug_assertions
)
]
pub
(
crate
)
fn
two_args_of
<
F
>
(
&
self
condition
:
F
)
-
>
Option
<
(
&
Arg
&
Arg
)
>
where
F
:
Fn
(
&
Arg
)
-
>
bool
{
two_elements_of
(
self
.
args
.
args
(
)
.
filter
(
|
a
:
&
&
Arg
|
condition
(
a
)
)
)
}
#
[
allow
(
unused
)
]
fn
two_groups_of
<
F
>
(
&
self
condition
:
F
)
-
>
Option
<
(
&
ArgGroup
&
ArgGroup
)
>
where
F
:
Fn
(
&
ArgGroup
)
-
>
bool
{
two_elements_of
(
self
.
groups
.
iter
(
)
.
filter
(
|
a
|
condition
(
a
)
)
)
}
pub
(
crate
)
fn
_propagate_global_args
(
&
mut
self
)
{
debug
!
(
"
Command
:
:
_propagate_global_args
:
{
}
"
self
.
name
)
;
let
autogenerated_help_subcommand
=
!
self
.
is_disable_help_subcommand_set
(
)
;
for
sc
in
&
mut
self
.
subcommands
{
if
sc
.
get_name
(
)
=
=
"
help
"
&
&
autogenerated_help_subcommand
{
continue
;
}
for
a
in
self
.
args
.
args
(
)
.
filter
(
|
a
|
a
.
is_global_set
(
)
)
{
if
sc
.
find
(
&
a
.
id
)
.
is_some
(
)
{
debug
!
(
"
Command
:
:
_propagate
skipping
{
:
?
}
to
{
}
already
exists
"
a
.
id
sc
.
get_name
(
)
)
;
continue
;
}
debug
!
(
"
Command
:
:
_propagate
pushing
{
:
?
}
to
{
}
"
a
.
id
sc
.
get_name
(
)
)
;
sc
.
args
.
push
(
a
.
clone
(
)
)
;
}
}
}
pub
(
crate
)
fn
_propagate
(
&
mut
self
)
{
debug
!
(
"
Command
:
:
_propagate
:
{
}
"
self
.
name
)
;
let
mut
subcommands
=
std
:
:
mem
:
:
take
(
&
mut
self
.
subcommands
)
;
for
sc
in
&
mut
subcommands
{
self
.
_propagate_subcommand
(
sc
)
;
}
self
.
subcommands
=
subcommands
;
}
fn
_propagate_subcommand
(
&
self
sc
:
&
mut
Self
)
{
{
if
self
.
settings
.
is_set
(
AppSettings
:
:
PropagateVersion
)
{
if
let
Some
(
version
)
=
self
.
version
.
as_ref
(
)
{
sc
.
version
.
get_or_insert_with
(
|
|
version
.
clone
(
)
)
;
}
if
let
Some
(
long_version
)
=
self
.
long_version
.
as_ref
(
)
{
sc
.
long_version
.
get_or_insert_with
(
|
|
long_version
.
clone
(
)
)
;
}
}
sc
.
settings
=
sc
.
settings
|
self
.
g_settings
;
sc
.
g_settings
=
sc
.
g_settings
|
self
.
g_settings
;
sc
.
app_ext
.
update
(
&
self
.
app_ext
)
;
}
}
pub
(
crate
)
fn
_check_help_and_version
(
&
mut
self
expand_help_tree
:
bool
)
{
debug
!
(
"
Command
:
:
_check_help_and_version
:
{
}
expand_help_tree
=
{
}
"
self
.
name
expand_help_tree
)
;
self
.
long_help_exists
=
self
.
long_help_exists_
(
)
;
if
!
self
.
is_disable_help_flag_set
(
)
{
debug
!
(
"
Command
:
:
_check_help_and_version
:
Building
default
-
-
help
"
)
;
let
mut
arg
=
Arg
:
:
new
(
Id
:
:
HELP
)
.
short
(
'
h
'
)
.
long
(
"
help
"
)
.
action
(
ArgAction
:
:
Help
)
;
if
self
.
long_help_exists
{
arg
=
arg
.
help
(
"
Print
help
(
see
more
with
'
-
-
help
'
)
"
)
.
long_help
(
"
Print
help
(
see
a
summary
with
'
-
h
'
)
"
)
;
}
else
{
arg
=
arg
.
help
(
"
Print
help
"
)
;
}
self
.
args
.
push
(
arg
)
;
}
if
!
self
.
is_disable_version_flag_set
(
)
{
debug
!
(
"
Command
:
:
_check_help_and_version
:
Building
default
-
-
version
"
)
;
let
arg
=
Arg
:
:
new
(
Id
:
:
VERSION
)
.
short
(
'
V
'
)
.
long
(
"
version
"
)
.
action
(
ArgAction
:
:
Version
)
.
help
(
"
Print
version
"
)
;
self
.
args
.
push
(
arg
)
;
}
if
!
self
.
is_set
(
AppSettings
:
:
DisableHelpSubcommand
)
{
debug
!
(
"
Command
:
:
_check_help_and_version
:
Building
help
subcommand
"
)
;
let
help_about
=
"
Print
this
message
or
the
help
of
the
given
subcommand
(
s
)
"
;
let
mut
help_subcmd
=
if
expand_help_tree
{
let
help_subcmd
=
Command
:
:
new
(
"
help
"
)
.
about
(
help_about
)
.
global_setting
(
AppSettings
:
:
DisableHelpSubcommand
)
.
subcommands
(
self
.
get_subcommands
(
)
.
map
(
Command
:
:
_copy_subtree_for_help
)
)
;
let
mut
help_help_subcmd
=
Command
:
:
new
(
"
help
"
)
.
about
(
help_about
)
;
help_help_subcmd
.
version
=
None
;
help_help_subcmd
.
long_version
=
None
;
help_help_subcmd
=
help_help_subcmd
.
setting
(
AppSettings
:
:
DisableHelpFlag
)
.
setting
(
AppSettings
:
:
DisableVersionFlag
)
;
help_subcmd
.
subcommand
(
help_help_subcmd
)
}
else
{
Command
:
:
new
(
"
help
"
)
.
about
(
help_about
)
.
arg
(
Arg
:
:
new
(
"
subcommand
"
)
.
action
(
ArgAction
:
:
Append
)
.
num_args
(
.
.
)
.
value_name
(
"
COMMAND
"
)
.
help
(
"
Print
help
for
the
subcommand
(
s
)
"
)
)
}
;
self
.
_propagate_subcommand
(
&
mut
help_subcmd
)
;
help_subcmd
.
version
=
None
;
help_subcmd
.
long_version
=
None
;
help_subcmd
=
help_subcmd
.
setting
(
AppSettings
:
:
DisableHelpFlag
)
.
setting
(
AppSettings
:
:
DisableVersionFlag
)
.
unset_global_setting
(
AppSettings
:
:
PropagateVersion
)
;
self
.
subcommands
.
push
(
help_subcmd
)
;
}
}
fn
_copy_subtree_for_help
(
&
self
)
-
>
Command
{
let
mut
cmd
=
Command
:
:
new
(
self
.
name
.
clone
(
)
)
.
hide
(
self
.
is_hide_set
(
)
)
.
global_setting
(
AppSettings
:
:
DisableHelpFlag
)
.
global_setting
(
AppSettings
:
:
DisableVersionFlag
)
.
subcommands
(
self
.
get_subcommands
(
)
.
map
(
Command
:
:
_copy_subtree_for_help
)
)
;
if
self
.
get_about
(
)
.
is_some
(
)
{
cmd
=
cmd
.
about
(
self
.
get_about
(
)
.
unwrap
(
)
.
clone
(
)
)
;
}
cmd
}
pub
(
crate
)
fn
_render_version
(
&
self
use_long
:
bool
)
-
>
String
{
debug
!
(
"
Command
:
:
_render_version
"
)
;
let
ver
=
if
use_long
{
self
.
long_version
.
as_deref
(
)
.
or
(
self
.
version
.
as_deref
(
)
)
.
unwrap_or_default
(
)
}
else
{
self
.
version
.
as_deref
(
)
.
or
(
self
.
long_version
.
as_deref
(
)
)
.
unwrap_or_default
(
)
}
;
let
display_name
=
self
.
get_display_name
(
)
.
unwrap_or_else
(
|
|
self
.
get_name
(
)
)
;
format
!
(
"
{
display_name
}
{
ver
}
\
n
"
)
}
pub
(
crate
)
fn
format_group
(
&
self
g
:
&
Id
)
-
>
StyledStr
{
let
g_string
=
self
.
unroll_args_in_group
(
g
)
.
iter
(
)
.
filter_map
(
|
x
|
self
.
find
(
x
)
)
.
map
(
|
x
|
{
if
x
.
is_positional
(
)
{
x
.
name_no_brackets
(
)
}
else
{
x
.
to_string
(
)
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
|
"
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
styled
.
push_str
(
"
<
"
)
;
styled
.
push_string
(
g_string
)
;
styled
.
push_str
(
"
>
"
)
;
styled
}
}
pub
(
crate
)
trait
Captures
<
'
a
>
{
}
impl
<
'
a
T
>
Captures
<
'
a
>
for
T
{
}
impl
Command
{
#
[
cfg
(
any
(
feature
=
"
usage
"
feature
=
"
help
"
)
)
]
pub
(
crate
)
fn
get_non_positionals
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Arg
>
{
self
.
get_arguments
(
)
.
filter
(
|
a
|
!
a
.
is_positional
(
)
)
}
pub
(
crate
)
fn
find
(
&
self
arg_id
:
&
Id
)
-
>
Option
<
&
Arg
>
{
self
.
args
.
args
(
)
.
find
(
|
a
|
a
.
get_id
(
)
=
=
arg_id
)
}
#
[
inline
]
pub
(
crate
)
fn
contains_short
(
&
self
s
:
char
)
-
>
bool
{
debug_assert
!
(
self
.
is_set
(
AppSettings
:
:
Built
)
"
If
Command
:
:
_build
hasn
'
t
been
called
manually
search
through
Arg
shorts
"
)
;
self
.
args
.
contains
(
s
)
}
#
[
inline
]
pub
(
crate
)
fn
set
(
&
mut
self
s
:
AppSettings
)
{
self
.
settings
.
set
(
s
)
}
#
[
inline
]
pub
(
crate
)
fn
has_positionals
(
&
self
)
-
>
bool
{
self
.
get_positionals
(
)
.
next
(
)
.
is_some
(
)
}
#
[
cfg
(
any
(
feature
=
"
usage
"
feature
=
"
help
"
)
)
]
pub
(
crate
)
fn
has_visible_subcommands
(
&
self
)
-
>
bool
{
self
.
subcommands
.
iter
(
)
.
any
(
|
sc
|
sc
.
name
!
=
"
help
"
&
&
!
sc
.
is_set
(
AppSettings
:
:
Hidden
)
)
}
#
[
inline
]
pub
(
crate
)
fn
aliases_to
(
&
self
name
:
impl
AsRef
<
std
:
:
ffi
:
:
OsStr
>
)
-
>
bool
{
let
name
=
name
.
as_ref
(
)
;
self
.
get_name
(
)
=
=
name
|
|
self
.
get_all_aliases
(
)
.
any
(
|
alias
|
alias
=
=
name
)
}
#
[
inline
]
pub
(
crate
)
fn
short_flag_aliases_to
(
&
self
flag
:
char
)
-
>
bool
{
Some
(
flag
)
=
=
self
.
short_flag
|
|
self
.
get_all_short_flag_aliases
(
)
.
any
(
|
alias
|
flag
=
=
alias
)
}
#
[
inline
]
pub
(
crate
)
fn
long_flag_aliases_to
(
&
self
flag
:
&
str
)
-
>
bool
{
match
self
.
long_flag
.
as_ref
(
)
{
Some
(
long_flag
)
=
>
{
long_flag
=
=
flag
|
|
self
.
get_all_long_flag_aliases
(
)
.
any
(
|
alias
|
alias
=
=
flag
)
}
None
=
>
self
.
get_all_long_flag_aliases
(
)
.
any
(
|
alias
|
alias
=
=
flag
)
}
}
#
[
cfg
(
debug_assertions
)
]
pub
(
crate
)
fn
id_exists
(
&
self
id
:
&
Id
)
-
>
bool
{
self
.
args
.
args
(
)
.
any
(
|
x
|
x
.
get_id
(
)
=
=
id
)
|
|
self
.
groups
.
iter
(
)
.
any
(
|
x
|
x
.
id
=
=
*
id
)
}
pub
(
crate
)
fn
groups_for_arg
<
'
a
>
(
&
'
a
self
arg
:
&
Id
)
-
>
impl
Iterator
<
Item
=
Id
>
+
'
a
{
debug
!
(
"
Command
:
:
groups_for_arg
:
id
=
{
arg
:
?
}
"
)
;
let
arg
=
arg
.
clone
(
)
;
self
.
groups
.
iter
(
)
.
filter
(
move
|
grp
|
grp
.
args
.
iter
(
)
.
any
(
|
a
|
a
=
=
&
arg
)
)
.
map
(
|
grp
|
grp
.
id
.
clone
(
)
)
}
pub
(
crate
)
fn
find_group
(
&
self
group_id
:
&
Id
)
-
>
Option
<
&
ArgGroup
>
{
self
.
groups
.
iter
(
)
.
find
(
|
g
|
g
.
id
=
=
*
group_id
)
}
pub
(
crate
)
fn
all_subcommand_names
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
Captures
{
self
.
get_subcommands
(
)
.
flat_map
(
|
sc
|
{
let
name
=
sc
.
get_name
(
)
;
let
aliases
=
sc
.
get_all_aliases
(
)
;
std
:
:
iter
:
:
once
(
name
)
.
chain
(
aliases
)
}
)
}
pub
(
crate
)
fn
required_graph
(
&
self
)
-
>
ChildGraph
<
Id
>
{
let
mut
reqs
=
ChildGraph
:
:
with_capacity
(
5
)
;
for
a
in
self
.
args
.
args
(
)
.
filter
(
|
a
|
a
.
is_required_set
(
)
)
{
reqs
.
insert
(
a
.
get_id
(
)
.
clone
(
)
)
;
}
for
group
in
&
self
.
groups
{
if
group
.
required
{
let
idx
=
reqs
.
insert
(
group
.
id
.
clone
(
)
)
;
for
a
in
&
group
.
requires
{
reqs
.
insert_child
(
idx
a
.
clone
(
)
)
;
}
}
}
reqs
}
pub
(
crate
)
fn
unroll_args_in_group
(
&
self
group
:
&
Id
)
-
>
Vec
<
Id
>
{
debug
!
(
"
Command
:
:
unroll_args_in_group
:
group
=
{
group
:
?
}
"
)
;
let
mut
g_vec
=
vec
!
[
group
]
;
let
mut
args
=
vec
!
[
]
;
while
let
Some
(
g
)
=
g_vec
.
pop
(
)
{
for
n
in
self
.
groups
.
iter
(
)
.
find
(
|
grp
|
grp
.
id
=
=
*
g
)
.
expect
(
INTERNAL_ERROR_MSG
)
.
args
.
iter
(
)
{
debug
!
(
"
Command
:
:
unroll_args_in_group
:
iter
:
entity
=
{
n
:
?
}
"
)
;
if
!
args
.
contains
(
n
)
{
if
self
.
find
(
n
)
.
is_some
(
)
{
debug
!
(
"
Command
:
:
unroll_args_in_group
:
iter
:
this
is
an
arg
"
)
;
args
.
push
(
n
.
clone
(
)
)
}
else
{
debug
!
(
"
Command
:
:
unroll_args_in_group
:
iter
:
this
is
a
group
"
)
;
g_vec
.
push
(
n
)
;
}
}
}
}
args
}
pub
(
crate
)
fn
unroll_arg_requires
<
F
>
(
&
self
func
:
F
arg
:
&
Id
)
-
>
Vec
<
Id
>
where
F
:
Fn
(
&
(
ArgPredicate
Id
)
)
-
>
Option
<
Id
>
{
let
mut
processed
=
vec
!
[
]
;
let
mut
r_vec
=
vec
!
[
arg
]
;
let
mut
args
=
vec
!
[
]
;
while
let
Some
(
a
)
=
r_vec
.
pop
(
)
{
if
processed
.
contains
(
&
a
)
{
continue
;
}
processed
.
push
(
a
)
;
if
let
Some
(
arg
)
=
self
.
find
(
a
)
{
for
r
in
arg
.
requires
.
iter
(
)
.
filter_map
(
&
func
)
{
if
let
Some
(
req
)
=
self
.
find
(
&
r
)
{
if
!
req
.
requires
.
is_empty
(
)
{
r_vec
.
push
(
req
.
get_id
(
)
)
}
}
args
.
push
(
r
)
;
}
}
}
args
}
pub
(
crate
)
fn
find_short_subcmd
(
&
self
c
:
char
)
-
>
Option
<
&
str
>
{
self
.
get_subcommands
(
)
.
find
(
|
sc
|
sc
.
short_flag_aliases_to
(
c
)
)
.
map
(
|
sc
|
sc
.
get_name
(
)
)
}
pub
(
crate
)
fn
find_long_subcmd
(
&
self
long
:
&
str
)
-
>
Option
<
&
str
>
{
self
.
get_subcommands
(
)
.
find
(
|
sc
|
sc
.
long_flag_aliases_to
(
long
)
)
.
map
(
|
sc
|
sc
.
get_name
(
)
)
}
#
[
cfg
(
feature
=
"
help
"
)
]
pub
(
crate
)
fn
get_display_order
(
&
self
)
-
>
usize
{
self
.
disp_ord
.
unwrap_or
(
999
)
}
pub
(
crate
)
fn
write_help_err
(
&
self
mut
use_long
:
bool
)
-
>
StyledStr
{
debug
!
(
"
Command
:
:
write_help_err
:
{
}
use_long
=
{
:
?
}
"
self
.
get_display_name
(
)
.
unwrap_or_else
(
|
|
self
.
get_name
(
)
)
use_long
&
&
self
.
long_help_exists
(
)
)
;
use_long
=
use_long
&
&
self
.
long_help_exists
(
)
;
let
usage
=
Usage
:
:
new
(
self
)
;
let
mut
styled
=
StyledStr
:
:
new
(
)
;
write_help
(
&
mut
styled
self
&
usage
use_long
)
;
styled
}
pub
(
crate
)
fn
write_version_err
(
&
self
use_long
:
bool
)
-
>
StyledStr
{
let
msg
=
self
.
_render_version
(
use_long
)
;
StyledStr
:
:
from
(
msg
)
}
pub
(
crate
)
fn
long_help_exists
(
&
self
)
-
>
bool
{
debug
!
(
"
Command
:
:
long_help_exists
:
{
}
"
self
.
long_help_exists
)
;
self
.
long_help_exists
}
fn
long_help_exists_
(
&
self
)
-
>
bool
{
debug
!
(
"
Command
:
:
long_help_exists
"
)
;
let
should_long
=
|
v
:
&
Arg
|
{
!
v
.
is_hide_set
(
)
&
&
(
v
.
get_long_help
(
)
.
is_some
(
)
|
|
v
.
is_hide_long_help_set
(
)
|
|
v
.
is_hide_short_help_set
(
)
|
|
(
!
v
.
is_hide_possible_values_set
(
)
&
&
v
.
get_possible_values
(
)
.
iter
(
)
.
any
(
PossibleValue
:
:
should_show_help
)
)
)
}
;
self
.
get_long_about
(
)
.
is_some
(
)
|
|
self
.
get_before_long_help
(
)
.
is_some
(
)
|
|
self
.
get_after_long_help
(
)
.
is_some
(
)
|
|
self
.
get_arguments
(
)
.
any
(
should_long
)
}
pub
(
crate
)
fn
color_help
(
&
self
)
-
>
ColorChoice
{
#
[
cfg
(
feature
=
"
color
"
)
]
if
self
.
is_disable_colored_help_set
(
)
{
return
ColorChoice
:
:
Never
;
}
self
.
get_color
(
)
}
}
impl
Default
for
Command
{
fn
default
(
)
-
>
Self
{
Self
{
name
:
Default
:
:
default
(
)
long_flag
:
Default
:
:
default
(
)
short_flag
:
Default
:
:
default
(
)
display_name
:
Default
:
:
default
(
)
bin_name
:
Default
:
:
default
(
)
author
:
Default
:
:
default
(
)
version
:
Default
:
:
default
(
)
long_version
:
Default
:
:
default
(
)
about
:
Default
:
:
default
(
)
long_about
:
Default
:
:
default
(
)
before_help
:
Default
:
:
default
(
)
before_long_help
:
Default
:
:
default
(
)
after_help
:
Default
:
:
default
(
)
after_long_help
:
Default
:
:
default
(
)
aliases
:
Default
:
:
default
(
)
short_flag_aliases
:
Default
:
:
default
(
)
long_flag_aliases
:
Default
:
:
default
(
)
usage_str
:
Default
:
:
default
(
)
usage_name
:
Default
:
:
default
(
)
help_str
:
Default
:
:
default
(
)
disp_ord
:
Default
:
:
default
(
)
#
[
cfg
(
feature
=
"
help
"
)
]
template
:
Default
:
:
default
(
)
settings
:
Default
:
:
default
(
)
g_settings
:
Default
:
:
default
(
)
args
:
Default
:
:
default
(
)
subcommands
:
Default
:
:
default
(
)
groups
:
Default
:
:
default
(
)
current_help_heading
:
Default
:
:
default
(
)
current_disp_ord
:
Some
(
0
)
subcommand_value_name
:
Default
:
:
default
(
)
subcommand_heading
:
Default
:
:
default
(
)
external_value_parser
:
Default
:
:
default
(
)
long_help_exists
:
false
deferred
:
None
app_ext
:
Default
:
:
default
(
)
}
}
}
impl
Index
<
&
'
_
Id
>
for
Command
{
type
Output
=
Arg
;
fn
index
(
&
self
key
:
&
Id
)
-
>
&
Self
:
:
Output
{
self
.
find
(
key
)
.
expect
(
INTERNAL_ERROR_MSG
)
}
}
impl
From
<
&
'
_
Command
>
for
Command
{
fn
from
(
cmd
:
&
'
_
Command
)
-
>
Self
{
cmd
.
clone
(
)
}
}
impl
fmt
:
:
Display
for
Command
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
name
)
}
}
pub
(
crate
)
trait
AppTag
:
crate
:
:
builder
:
:
ext
:
:
Extension
{
}
#
[
derive
(
Default
Copy
Clone
Debug
)
]
struct
TermWidth
(
usize
)
;
impl
AppTag
for
TermWidth
{
}
#
[
derive
(
Default
Copy
Clone
Debug
)
]
struct
MaxTermWidth
(
usize
)
;
impl
AppTag
for
MaxTermWidth
{
}
fn
two_elements_of
<
I
T
>
(
mut
iter
:
I
)
-
>
Option
<
(
T
T
)
>
where
I
:
Iterator
<
Item
=
T
>
{
let
first
=
iter
.
next
(
)
;
let
second
=
iter
.
next
(
)
;
match
(
first
second
)
{
(
Some
(
first
)
Some
(
second
)
)
=
>
Some
(
(
first
second
)
)
_
=
>
None
}
}
#
[
test
]
fn
check_auto_traits
(
)
{
static_assertions
:
:
assert_impl_all
!
(
Command
:
Send
Sync
Unpin
)
;
}
