use
crate
:
:
builder
:
:
IntoResettable
;
use
crate
:
:
builder
:
:
Str
;
use
crate
:
:
builder
:
:
StyledStr
;
use
crate
:
:
util
:
:
eq_ignore_case
;
#
[
derive
(
Debug
Default
Clone
PartialEq
Eq
)
]
pub
struct
PossibleValue
{
name
:
Str
help
:
Option
<
StyledStr
>
aliases
:
Vec
<
Str
>
hide
:
bool
}
impl
PossibleValue
{
pub
fn
new
(
name
:
impl
Into
<
Str
>
)
-
>
Self
{
PossibleValue
{
name
:
name
.
into
(
)
.
.
Default
:
:
default
(
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
help
(
mut
self
help
:
impl
IntoResettable
<
StyledStr
>
)
-
>
Self
{
self
.
help
=
help
.
into_resettable
(
)
.
into_option
(
)
;
self
}
#
[
inline
]
#
[
must_use
]
pub
fn
hide
(
mut
self
yes
:
bool
)
-
>
Self
{
self
.
hide
=
yes
;
self
}
#
[
must_use
]
pub
fn
alias
(
mut
self
name
:
impl
IntoResettable
<
Str
>
)
-
>
Self
{
if
let
Some
(
name
)
=
name
.
into_resettable
(
)
.
into_option
(
)
{
self
.
aliases
.
push
(
name
)
;
}
else
{
self
.
aliases
.
clear
(
)
;
}
self
}
#
[
must_use
]
pub
fn
aliases
(
mut
self
names
:
impl
IntoIterator
<
Item
=
impl
Into
<
Str
>
>
)
-
>
Self
{
self
.
aliases
.
extend
(
names
.
into_iter
(
)
.
map
(
|
a
|
a
.
into
(
)
)
)
;
self
}
}
impl
PossibleValue
{
#
[
inline
]
pub
fn
get_name
(
&
self
)
-
>
&
str
{
self
.
name
.
as_str
(
)
}
#
[
inline
]
pub
fn
get_help
(
&
self
)
-
>
Option
<
&
StyledStr
>
{
self
.
help
.
as_ref
(
)
}
#
[
inline
]
pub
fn
is_hide_set
(
&
self
)
-
>
bool
{
self
.
hide
}
pub
(
crate
)
fn
should_show_help
(
&
self
)
-
>
bool
{
!
self
.
hide
&
&
self
.
help
.
is_some
(
)
}
#
[
cfg
(
feature
=
"
help
"
)
]
pub
(
crate
)
fn
get_visible_quoted_name
(
&
self
)
-
>
Option
<
std
:
:
borrow
:
:
Cow
<
'
_
str
>
>
{
if
!
self
.
hide
{
Some
(
if
self
.
name
.
contains
(
char
:
:
is_whitespace
)
{
format
!
(
"
{
:
?
}
"
self
.
name
)
.
into
(
)
}
else
{
self
.
name
.
as_str
(
)
.
into
(
)
}
)
}
else
{
None
}
}
pub
fn
get_name_and_aliases
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
str
>
+
'
_
{
std
:
:
iter
:
:
once
(
self
.
get_name
(
)
)
.
chain
(
self
.
aliases
.
iter
(
)
.
map
(
|
s
|
s
.
as_str
(
)
)
)
}
pub
fn
matches
(
&
self
value
:
&
str
ignore_case
:
bool
)
-
>
bool
{
if
ignore_case
{
self
.
get_name_and_aliases
(
)
.
any
(
|
name
|
eq_ignore_case
(
name
value
)
)
}
else
{
self
.
get_name_and_aliases
(
)
.
any
(
|
name
|
name
=
=
value
)
}
}
}
impl
<
S
:
Into
<
Str
>
>
From
<
S
>
for
PossibleValue
{
fn
from
(
s
:
S
)
-
>
Self
{
Self
:
:
new
(
s
)
}
}
