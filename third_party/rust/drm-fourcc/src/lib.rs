#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
warn
(
clippy
:
:
cargo
)
]
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
{
Debug
Display
Formatter
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
pub
use
as_enum
:
:
{
DrmFourcc
DrmModifier
DrmVendor
}
;
mod
as_enum
;
mod
consts
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
DrmFormat
{
pub
code
:
DrmFourcc
pub
modifier
:
DrmModifier
}
impl
DrmFourcc
{
pub
fn
string_form
(
&
self
)
-
>
String
{
fourcc_string_form
(
*
self
as
u32
)
.
expect
(
"
Must
be
valid
fourcc
"
)
}
}
impl
Debug
for
DrmFourcc
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
DrmFourcc
"
)
.
field
(
&
self
.
string_form
(
)
)
.
finish
(
)
}
}
impl
Display
for
DrmFourcc
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
self
f
)
}
}
impl
TryFrom
<
u32
>
for
DrmFourcc
{
type
Error
=
UnrecognizedFourcc
;
fn
try_from
(
value
:
u32
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Self
:
:
from_u32
(
value
)
.
ok_or
(
UnrecognizedFourcc
(
value
)
)
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
UnrecognizedFourcc
(
pub
u32
)
;
impl
UnrecognizedFourcc
{
pub
fn
string_form
(
&
self
)
-
>
Option
<
String
>
{
fourcc_string_form
(
self
.
0
)
}
}
impl
Debug
for
UnrecognizedFourcc
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
debug
=
&
mut
f
.
debug_tuple
(
"
UnrecognizedFourcc
"
)
;
if
let
Some
(
string_form
)
=
self
.
string_form
(
)
{
debug
=
debug
.
field
(
&
string_form
)
;
}
debug
.
field
(
&
self
.
0
)
.
finish
(
)
}
}
impl
Display
for
UnrecognizedFourcc
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
f
)
}
}
impl
Error
for
UnrecognizedFourcc
{
}
fn
fourcc_string_form
(
fourcc
:
u32
)
-
>
Option
<
String
>
{
let
string
=
String
:
:
from_utf8
(
fourcc
.
to_le_bytes
(
)
.
to_vec
(
)
)
.
ok
(
)
?
;
let
mut
out
=
String
:
:
new
(
)
;
let
chars
:
Vec
<
char
>
=
string
.
chars
(
)
.
collect
(
)
;
let
(
start
end
)
=
chars
.
split_at
(
2
)
;
for
char
in
start
{
if
char
.
is_ascii_alphanumeric
(
)
{
out
.
push
(
*
char
)
;
}
else
{
return
None
;
}
}
for
char
in
end
{
if
*
char
=
=
'
\
0
'
{
out
.
push
(
'
'
)
;
}
else
{
out
.
push
(
*
char
)
;
}
}
Some
(
out
)
}
impl
TryFrom
<
u8
>
for
DrmVendor
{
type
Error
=
UnrecognizedVendor
;
fn
try_from
(
value
:
u8
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Self
:
:
from_u8
(
value
)
.
ok_or
(
UnrecognizedVendor
(
value
)
)
}
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
UnrecognizedVendor
(
pub
u8
)
;
impl
Display
for
UnrecognizedVendor
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
f
)
}
}
impl
Error
for
UnrecognizedVendor
{
}
impl
From
<
u64
>
for
DrmModifier
{
fn
from
(
value
:
u64
)
-
>
Self
{
Self
:
:
from_u64
(
value
)
}
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
UnrecognizedModifier
(
pub
u64
)
;
impl
Display
for
UnrecognizedModifier
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
f
)
}
}
impl
Error
for
UnrecognizedModifier
{
}
impl
UnrecognizedModifier
{
pub
fn
vendor
(
&
self
)
-
>
Result
<
Option
<
DrmVendor
>
UnrecognizedVendor
>
{
let
vendor
=
(
self
.
0
>
>
56
)
as
u8
;
if
vendor
=
=
0
{
Ok
(
None
)
}
else
{
DrmVendor
:
:
try_from
(
vendor
)
.
map
(
|
x
|
Some
(
x
)
)
}
}
}
impl
Into
<
u64
>
for
DrmModifier
{
fn
into
(
self
)
-
>
u64
{
self
.
into_u64
(
)
}
}
impl
PartialEq
for
DrmModifier
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
into_u64
(
)
=
=
other
.
into_u64
(
)
}
}
impl
Eq
for
DrmModifier
{
}
impl
PartialEq
<
u64
>
for
DrmModifier
{
fn
eq
(
&
self
other
:
&
u64
)
-
>
bool
{
&
self
.
into_u64
(
)
=
=
other
}
}
impl
Hash
for
DrmModifier
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
into_u64
(
)
.
hash
(
state
)
;
}
}
impl
DrmModifier
{
pub
fn
vendor
(
&
self
)
-
>
Result
<
Option
<
DrmVendor
>
UnrecognizedVendor
>
{
let
vendor
=
(
self
.
into_u64
(
)
>
>
56
)
as
u8
;
if
vendor
=
=
0
{
Ok
(
None
)
}
else
{
DrmVendor
:
:
try_from
(
vendor
)
.
map
(
|
x
|
Some
(
x
)
)
}
}
}
#
[
cfg
(
test
)
]
pub
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
a_specific_var_has_correct_value
(
)
{
assert_eq
!
(
consts
:
:
DRM_FOURCC_AYUV
1448433985
)
;
}
#
[
test
]
fn
enum_member_casts_to_const
(
)
{
assert_eq
!
(
DrmFourcc
:
:
Xrgb8888
as
u32
consts
:
:
DRM_FOURCC_XRGB8888
as
u32
)
;
}
#
[
test
]
fn
enum_member_has_correct_string_format
(
)
{
assert_eq
!
(
DrmFourcc
:
:
Xrgb8888
.
string_form
(
)
"
XR24
"
)
;
}
#
[
test
]
fn
fourcc_string_form_handles_valid
(
)
{
assert_eq
!
(
fourcc_string_form
(
875713112
)
.
unwrap
(
)
"
XR24
"
)
;
assert_eq
!
(
fourcc_string_form
(
828601953
)
.
unwrap
(
)
"
avc1
"
)
;
assert_eq
!
(
fourcc_string_form
(
0x316376
)
.
unwrap
(
)
"
vc1
"
)
;
}
#
[
test
]
fn
unrecognized_handles_valid_fourcc
(
)
{
assert_eq
!
(
format
!
(
"
{
}
"
UnrecognizedFourcc
(
828601953
)
)
"
UnrecognizedFourcc
(
\
"
avc1
\
"
828601953
)
"
)
;
}
#
[
test
]
fn
unrecognized_handles_invalid_fourcc
(
)
{
assert_eq
!
(
format
!
(
"
{
}
"
UnrecognizedFourcc
(
0
)
)
"
UnrecognizedFourcc
(
0
)
"
)
;
}
#
[
test
]
fn
can_clone_result
(
)
{
let
a
=
DrmFourcc
:
:
try_from
(
0
)
;
let
b
=
a
;
assert_eq
!
(
a
b
)
;
}
}
