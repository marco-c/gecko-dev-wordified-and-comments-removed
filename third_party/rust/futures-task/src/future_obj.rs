use
core
:
:
{
fmt
future
:
:
Future
marker
:
:
PhantomData
mem
pin
:
:
Pin
task
:
:
{
Context
Poll
}
}
;
pub
struct
LocalFutureObj
<
'
a
T
>
{
future
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
static
)
drop_fn
:
unsafe
fn
(
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
static
)
)
_marker
:
PhantomData
<
&
'
a
(
)
>
}
impl
<
T
>
Unpin
for
LocalFutureObj
<
'
_
T
>
{
}
#
[
allow
(
single_use_lifetimes
)
]
#
[
allow
(
clippy
:
:
transmute_ptr_to_ptr
)
]
unsafe
fn
remove_future_lifetime
<
'
a
T
>
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
static
)
{
unsafe
{
mem
:
:
transmute
(
ptr
)
}
}
#
[
allow
(
single_use_lifetimes
)
]
unsafe
fn
remove_drop_lifetime
<
'
a
T
>
(
ptr
:
unsafe
fn
(
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
)
-
>
unsafe
fn
(
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
static
)
)
{
unsafe
{
mem
:
:
transmute
(
ptr
)
}
}
impl
<
'
a
T
>
LocalFutureObj
<
'
a
T
>
{
#
[
inline
]
pub
fn
new
<
F
:
UnsafeFutureObj
<
'
a
T
>
+
'
a
>
(
f
:
F
)
-
>
Self
{
Self
{
future
:
unsafe
{
remove_future_lifetime
(
f
.
into_raw
(
)
)
}
drop_fn
:
unsafe
{
remove_drop_lifetime
(
F
:
:
drop
)
}
_marker
:
PhantomData
}
}
#
[
inline
]
pub
unsafe
fn
into_future_obj
(
self
)
-
>
FutureObj
<
'
a
T
>
{
FutureObj
(
self
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
LocalFutureObj
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
LocalFutureObj
"
)
.
finish
(
)
}
}
impl
<
'
a
T
>
From
<
FutureObj
<
'
a
T
>
>
for
LocalFutureObj
<
'
a
T
>
{
#
[
inline
]
fn
from
(
f
:
FutureObj
<
'
a
T
>
)
-
>
Self
{
f
.
0
}
}
impl
<
T
>
Future
for
LocalFutureObj
<
'
_
T
>
{
type
Output
=
T
;
#
[
inline
]
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
T
>
{
unsafe
{
Pin
:
:
new_unchecked
(
&
mut
*
self
.
future
)
.
poll
(
cx
)
}
}
}
impl
<
T
>
Drop
for
LocalFutureObj
<
'
_
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
(
self
.
drop_fn
)
(
self
.
future
)
}
}
}
pub
struct
FutureObj
<
'
a
T
>
(
LocalFutureObj
<
'
a
T
>
)
;
impl
<
T
>
Unpin
for
FutureObj
<
'
_
T
>
{
}
unsafe
impl
<
T
>
Send
for
FutureObj
<
'
_
T
>
{
}
impl
<
'
a
T
>
FutureObj
<
'
a
T
>
{
#
[
inline
]
pub
fn
new
<
F
:
UnsafeFutureObj
<
'
a
T
>
+
Send
>
(
f
:
F
)
-
>
Self
{
Self
(
LocalFutureObj
:
:
new
(
f
)
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
FutureObj
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FutureObj
"
)
.
finish
(
)
}
}
impl
<
T
>
Future
for
FutureObj
<
'
_
T
>
{
type
Output
=
T
;
#
[
inline
]
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
T
>
{
Pin
:
:
new
(
&
mut
self
.
0
)
.
poll
(
cx
)
}
}
pub
unsafe
trait
UnsafeFutureObj
<
'
a
T
>
:
'
a
{
#
[
allow
(
clippy
:
:
unnecessary_safety_doc
)
]
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
;
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
;
}
unsafe
impl
<
'
a
T
F
>
UnsafeFutureObj
<
'
a
T
>
for
&
'
a
mut
F
where
F
:
Future
<
Output
=
T
>
+
Unpin
+
'
a
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
self
as
*
mut
dyn
Future
<
Output
=
T
>
}
unsafe
fn
drop
(
_ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
}
}
unsafe
impl
<
'
a
T
>
UnsafeFutureObj
<
'
a
T
>
for
&
'
a
mut
(
dyn
Future
<
Output
=
T
>
+
Unpin
+
'
a
)
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
self
as
*
mut
dyn
Future
<
Output
=
T
>
}
unsafe
fn
drop
(
_ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
}
}
unsafe
impl
<
'
a
T
F
>
UnsafeFutureObj
<
'
a
T
>
for
Pin
<
&
'
a
mut
F
>
where
F
:
Future
<
Output
=
T
>
+
'
a
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
unsafe
{
self
.
get_unchecked_mut
(
)
as
*
mut
dyn
Future
<
Output
=
T
>
}
}
unsafe
fn
drop
(
_ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
}
}
unsafe
impl
<
'
a
T
>
UnsafeFutureObj
<
'
a
T
>
for
Pin
<
&
'
a
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
>
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
unsafe
{
self
.
get_unchecked_mut
(
)
as
*
mut
dyn
Future
<
Output
=
T
>
}
}
unsafe
fn
drop
(
_ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
if_alloc
{
use
super
:
:
*
;
use
alloc
:
:
boxed
:
:
Box
;
unsafe
impl
<
'
a
T
F
>
UnsafeFutureObj
<
'
a
T
>
for
Box
<
F
>
where
F
:
Future
<
Output
=
T
>
+
'
a
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
Box
:
:
into_raw
(
self
)
}
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
drop
(
unsafe
{
Box
:
:
from_raw
(
ptr
.
cast
:
:
<
F
>
(
)
)
}
)
}
}
unsafe
impl
<
'
a
T
:
'
a
>
UnsafeFutureObj
<
'
a
T
>
for
Box
<
dyn
Future
<
Output
=
T
>
+
'
a
>
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
Box
:
:
into_raw
(
self
)
}
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
drop
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
}
}
unsafe
impl
<
'
a
T
:
'
a
>
UnsafeFutureObj
<
'
a
T
>
for
Box
<
dyn
Future
<
Output
=
T
>
+
Send
+
'
a
>
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
Box
:
:
into_raw
(
self
)
}
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
drop
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
}
}
unsafe
impl
<
'
a
T
F
>
UnsafeFutureObj
<
'
a
T
>
for
Pin
<
Box
<
F
>
>
where
F
:
Future
<
Output
=
T
>
+
'
a
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
let
mut
this
=
mem
:
:
ManuallyDrop
:
:
new
(
self
)
;
unsafe
{
this
.
as_mut
(
)
.
get_unchecked_mut
(
)
as
*
mut
_
}
}
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
drop
(
Pin
:
:
from
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
)
}
}
unsafe
impl
<
'
a
T
:
'
a
>
UnsafeFutureObj
<
'
a
T
>
for
Pin
<
Box
<
dyn
Future
<
Output
=
T
>
+
'
a
>
>
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
let
mut
this
=
mem
:
:
ManuallyDrop
:
:
new
(
self
)
;
unsafe
{
this
.
as_mut
(
)
.
get_unchecked_mut
(
)
as
*
mut
_
}
}
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
drop
(
Pin
:
:
from
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
)
}
}
unsafe
impl
<
'
a
T
:
'
a
>
UnsafeFutureObj
<
'
a
T
>
for
Pin
<
Box
<
dyn
Future
<
Output
=
T
>
+
Send
+
'
a
>
>
{
fn
into_raw
(
self
)
-
>
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
{
let
mut
this
=
mem
:
:
ManuallyDrop
:
:
new
(
self
)
;
unsafe
{
this
.
as_mut
(
)
.
get_unchecked_mut
(
)
as
*
mut
_
}
}
unsafe
fn
drop
(
ptr
:
*
mut
(
dyn
Future
<
Output
=
T
>
+
'
a
)
)
{
drop
(
Pin
:
:
from
(
unsafe
{
Box
:
:
from_raw
(
ptr
)
}
)
)
}
}
impl
<
'
a
F
:
Future
<
Output
=
(
)
>
+
Send
+
'
a
>
From
<
Box
<
F
>
>
for
FutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Box
<
F
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
>
From
<
Box
<
dyn
Future
<
Output
=
(
)
>
+
Send
+
'
a
>
>
for
FutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Box
<
dyn
Future
<
Output
=
(
)
>
+
Send
+
'
a
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
F
:
Future
<
Output
=
(
)
>
+
Send
+
'
a
>
From
<
Pin
<
Box
<
F
>
>
>
for
FutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Pin
<
Box
<
F
>
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
>
From
<
Pin
<
Box
<
dyn
Future
<
Output
=
(
)
>
+
Send
+
'
a
>
>
>
for
FutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Pin
<
Box
<
dyn
Future
<
Output
=
(
)
>
+
Send
+
'
a
>
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
F
:
Future
<
Output
=
(
)
>
+
'
a
>
From
<
Box
<
F
>
>
for
LocalFutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Box
<
F
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
>
From
<
Box
<
dyn
Future
<
Output
=
(
)
>
+
'
a
>
>
for
LocalFutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Box
<
dyn
Future
<
Output
=
(
)
>
+
'
a
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
F
:
Future
<
Output
=
(
)
>
+
'
a
>
From
<
Pin
<
Box
<
F
>
>
>
for
LocalFutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Pin
<
Box
<
F
>
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
impl
<
'
a
>
From
<
Pin
<
Box
<
dyn
Future
<
Output
=
(
)
>
+
'
a
>
>
>
for
LocalFutureObj
<
'
a
(
)
>
{
fn
from
(
boxed
:
Pin
<
Box
<
dyn
Future
<
Output
=
(
)
>
+
'
a
>
>
)
-
>
Self
{
Self
:
:
new
(
boxed
)
}
}
}
