#
!
[
allow
(
dead_code
)
]
use
super
:
:
Task
;
use
std
:
:
fmt
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
Release
AcqRel
}
;
pub
(
crate
)
struct
AtomicTask
{
state
:
AtomicUsize
task
:
UnsafeCell
<
Option
<
Task
>
>
}
const
WAITING
:
usize
=
0
;
const
REGISTERING
:
usize
=
0b01
;
const
NOTIFYING
:
usize
=
0b10
;
impl
AtomicTask
{
pub
fn
new
(
)
-
>
AtomicTask
{
trait
AssertSync
:
Sync
{
}
impl
AssertSync
for
Task
{
}
AtomicTask
{
state
:
AtomicUsize
:
:
new
(
WAITING
)
task
:
UnsafeCell
:
:
new
(
None
)
}
}
pub
fn
register_task
(
&
self
task
:
Task
)
{
match
self
.
state
.
compare_and_swap
(
WAITING
REGISTERING
Acquire
)
{
WAITING
=
>
{
unsafe
{
*
self
.
task
.
get
(
)
=
Some
(
task
.
clone
(
)
)
;
let
mut
curr
=
REGISTERING
;
let
mut
notify
:
Option
<
Task
>
=
None
;
loop
{
let
res
=
self
.
state
.
compare_exchange
(
curr
WAITING
AcqRel
Acquire
)
;
match
res
{
Ok
(
_
)
=
>
{
if
let
Some
(
task
)
=
notify
{
task
.
notify
(
)
;
}
return
;
}
Err
(
actual
)
=
>
{
debug_assert_eq
!
(
actual
REGISTERING
|
NOTIFYING
)
;
notify
=
(
*
self
.
task
.
get
(
)
)
.
take
(
)
;
curr
=
actual
;
}
}
}
}
}
NOTIFYING
=
>
{
task
.
notify
(
)
;
}
state
=
>
{
debug_assert
!
(
state
=
=
REGISTERING
|
|
state
=
=
REGISTERING
|
NOTIFYING
)
;
}
}
}
pub
fn
take_to_notify
(
&
self
)
-
>
Option
<
Task
>
{
match
self
.
state
.
fetch_or
(
NOTIFYING
AcqRel
)
{
WAITING
=
>
{
let
task
=
unsafe
{
(
*
self
.
task
.
get
(
)
)
.
take
(
)
}
;
self
.
state
.
fetch_and
(
!
NOTIFYING
Release
)
;
task
}
state
=
>
{
debug_assert
!
(
state
=
=
REGISTERING
|
|
state
=
=
REGISTERING
|
NOTIFYING
|
|
state
=
=
NOTIFYING
)
;
None
}
}
}
pub
fn
notify
(
&
self
)
{
if
let
Some
(
task
)
=
self
.
take_to_notify
(
)
{
task
.
notify
(
)
;
}
}
}
impl
Default
for
AtomicTask
{
fn
default
(
)
-
>
Self
{
AtomicTask
:
:
new
(
)
}
}
impl
fmt
:
:
Debug
for
AtomicTask
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
AtomicTask
"
)
}
}
unsafe
impl
Send
for
AtomicTask
{
}
unsafe
impl
Sync
for
AtomicTask
{
}
