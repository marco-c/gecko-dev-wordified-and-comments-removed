use
rustc_serialize_crate
:
:
{
Encodable
Decodable
}
;
use
std
:
:
io
:
:
{
Write
Read
}
;
use
:
:
SizeLimit
;
pub
use
self
:
:
writer
:
:
{
SizeChecker
EncoderWriter
EncodingResult
EncodingError
}
;
pub
use
self
:
:
reader
:
:
{
DecoderReader
DecodingResult
DecodingError
InvalidEncoding
}
;
mod
reader
;
mod
writer
;
pub
fn
encode
<
T
:
Encodable
>
(
t
:
&
T
size_limit
:
SizeLimit
)
-
>
EncodingResult
<
Vec
<
u8
>
>
{
let
mut
w
=
if
let
SizeLimit
:
:
Bounded
(
l
)
=
size_limit
{
let
actual_size
=
encoded_size_bounded
(
t
l
)
;
let
actual_size
=
try
!
(
actual_size
.
ok_or
(
EncodingError
:
:
SizeLimit
)
)
;
Vec
:
:
with_capacity
(
actual_size
as
usize
)
}
else
{
vec
!
[
]
}
;
match
encode_into
(
t
&
mut
w
SizeLimit
:
:
Infinite
)
{
Ok
(
(
)
)
=
>
Ok
(
w
)
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
decode
<
T
:
Decodable
>
(
b
:
&
[
u8
]
)
-
>
DecodingResult
<
T
>
{
let
mut
b
=
b
;
decode_from
(
&
mut
b
SizeLimit
:
:
Infinite
)
}
pub
fn
encode_into
<
T
:
Encodable
W
:
Write
>
(
t
:
&
T
w
:
&
mut
W
size_limit
:
SizeLimit
)
-
>
EncodingResult
<
(
)
>
{
try
!
(
match
size_limit
{
SizeLimit
:
:
Infinite
=
>
Ok
(
(
)
)
SizeLimit
:
:
Bounded
(
x
)
=
>
{
let
mut
size_checker
=
SizeChecker
:
:
new
(
x
)
;
t
.
encode
(
&
mut
size_checker
)
}
}
)
;
t
.
encode
(
&
mut
writer
:
:
EncoderWriter
:
:
new
(
w
)
)
}
pub
fn
decode_from
<
R
:
Read
T
:
Decodable
>
(
r
:
&
mut
R
size_limit
:
SizeLimit
)
-
>
DecodingResult
<
T
>
{
Decodable
:
:
decode
(
&
mut
reader
:
:
DecoderReader
:
:
new
(
r
size_limit
)
)
}
pub
fn
encoded_size
<
T
:
Encodable
>
(
t
:
&
T
)
-
>
u64
{
use
std
:
:
u64
:
:
MAX
;
let
mut
size_checker
=
SizeChecker
:
:
new
(
MAX
)
;
t
.
encode
(
&
mut
size_checker
)
.
ok
(
)
;
size_checker
.
written
}
pub
fn
encoded_size_bounded
<
T
:
Encodable
>
(
t
:
&
T
max
:
u64
)
-
>
Option
<
u64
>
{
let
mut
size_checker
=
SizeChecker
:
:
new
(
max
)
;
t
.
encode
(
&
mut
size_checker
)
.
ok
(
)
.
map
(
|
_
|
size_checker
.
written
)
}
