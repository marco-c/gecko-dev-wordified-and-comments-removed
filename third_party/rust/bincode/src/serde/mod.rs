use
std
:
:
io
:
:
{
Write
Read
}
;
use
std
:
:
io
:
:
Error
as
IoError
;
use
std
:
:
{
error
fmt
result
}
;
use
:
:
SizeLimit
;
pub
use
self
:
:
reader
:
:
{
Deserializer
}
;
pub
use
self
:
:
writer
:
:
{
Serializer
}
;
use
self
:
:
writer
:
:
SizeChecker
;
use
serde_crate
as
serde
;
mod
reader
;
mod
writer
;
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
Error
>
;
pub
type
Error
=
Box
<
ErrorKind
>
;
#
[
derive
(
Debug
)
]
pub
enum
ErrorKind
{
IoError
(
IoError
)
InvalidEncoding
{
desc
:
&
'
static
str
detail
:
Option
<
String
>
}
SizeLimit
SequenceMustHaveLength
Custom
(
String
)
}
impl
error
:
:
Error
for
ErrorKind
{
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
ErrorKind
:
:
IoError
(
ref
err
)
=
>
error
:
:
Error
:
:
description
(
err
)
ErrorKind
:
:
InvalidEncoding
{
desc
.
.
}
=
>
desc
ErrorKind
:
:
SequenceMustHaveLength
=
>
"
bincode
can
'
t
encode
infinite
sequences
"
ErrorKind
:
:
SizeLimit
=
>
"
the
size
limit
for
decoding
has
been
reached
"
ErrorKind
:
:
Custom
(
ref
msg
)
=
>
msg
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
error
:
:
Error
>
{
match
*
self
{
ErrorKind
:
:
IoError
(
ref
err
)
=
>
err
.
cause
(
)
ErrorKind
:
:
InvalidEncoding
{
.
.
}
=
>
None
ErrorKind
:
:
SequenceMustHaveLength
=
>
None
ErrorKind
:
:
SizeLimit
=
>
None
ErrorKind
:
:
Custom
(
_
)
=
>
None
}
}
}
impl
From
<
IoError
>
for
Error
{
fn
from
(
err
:
IoError
)
-
>
Error
{
ErrorKind
:
:
IoError
(
err
)
.
into
(
)
}
}
impl
fmt
:
:
Display
for
ErrorKind
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
ErrorKind
:
:
IoError
(
ref
ioerr
)
=
>
write
!
(
fmt
"
IoError
:
{
}
"
ioerr
)
ErrorKind
:
:
InvalidEncoding
{
desc
detail
:
None
}
=
>
write
!
(
fmt
"
InvalidEncoding
:
{
}
"
desc
)
ErrorKind
:
:
InvalidEncoding
{
desc
detail
:
Some
(
ref
detail
)
}
=
>
write
!
(
fmt
"
InvalidEncoding
:
{
}
(
{
}
)
"
desc
detail
)
ErrorKind
:
:
SequenceMustHaveLength
=
>
write
!
(
fmt
"
Bincode
can
only
encode
sequences
and
maps
that
have
a
knowable
size
ahead
of
time
.
"
)
ErrorKind
:
:
SizeLimit
=
>
write
!
(
fmt
"
SizeLimit
"
)
ErrorKind
:
:
Custom
(
ref
s
)
=
>
s
.
fmt
(
fmt
)
}
}
}
impl
serde
:
:
de
:
:
Error
for
Error
{
fn
custom
<
T
:
fmt
:
:
Display
>
(
desc
:
T
)
-
>
Error
{
ErrorKind
:
:
Custom
(
desc
.
to_string
(
)
)
.
into
(
)
}
}
impl
serde
:
:
ser
:
:
Error
for
Error
{
fn
custom
<
T
:
fmt
:
:
Display
>
(
msg
:
T
)
-
>
Self
{
ErrorKind
:
:
Custom
(
msg
.
to_string
(
)
)
.
into
(
)
}
}
pub
fn
serialize_into
<
W
:
?
Sized
T
:
?
Sized
>
(
writer
:
&
mut
W
value
:
&
T
size_limit
:
SizeLimit
)
-
>
Result
<
(
)
>
where
W
:
Write
T
:
serde
:
:
Serialize
{
match
size_limit
{
SizeLimit
:
:
Infinite
=
>
{
}
SizeLimit
:
:
Bounded
(
x
)
=
>
{
let
mut
size_checker
=
SizeChecker
:
:
new
(
x
)
;
try
!
(
value
.
serialize
(
&
mut
size_checker
)
)
}
}
let
mut
serializer
=
Serializer
:
:
new
(
writer
)
;
serde
:
:
Serialize
:
:
serialize
(
value
&
mut
serializer
)
}
pub
fn
serialize
<
T
:
?
Sized
>
(
value
:
&
T
size_limit
:
SizeLimit
)
-
>
Result
<
Vec
<
u8
>
>
where
T
:
serde
:
:
Serialize
{
let
mut
writer
=
match
size_limit
{
SizeLimit
:
:
Bounded
(
size_limit
)
=
>
{
let
actual_size
=
try
!
(
serialized_size_bounded
(
value
size_limit
)
.
ok_or
(
ErrorKind
:
:
SizeLimit
)
)
;
Vec
:
:
with_capacity
(
actual_size
as
usize
)
}
SizeLimit
:
:
Infinite
=
>
Vec
:
:
new
(
)
}
;
try
!
(
serialize_into
(
&
mut
writer
value
SizeLimit
:
:
Infinite
)
)
;
Ok
(
writer
)
}
pub
fn
serialized_size
<
T
:
?
Sized
>
(
value
:
&
T
)
-
>
u64
where
T
:
serde
:
:
Serialize
{
use
std
:
:
u64
:
:
MAX
;
let
mut
size_checker
=
SizeChecker
:
:
new
(
MAX
)
;
value
.
serialize
(
&
mut
size_checker
)
.
ok
(
)
;
size_checker
.
written
}
pub
fn
serialized_size_bounded
<
T
:
?
Sized
>
(
value
:
&
T
max
:
u64
)
-
>
Option
<
u64
>
where
T
:
serde
:
:
Serialize
{
let
mut
size_checker
=
SizeChecker
:
:
new
(
max
)
;
value
.
serialize
(
&
mut
size_checker
)
.
ok
(
)
.
map
(
|
_
|
size_checker
.
written
)
}
pub
fn
deserialize_from
<
R
:
?
Sized
T
>
(
reader
:
&
mut
R
size_limit
:
SizeLimit
)
-
>
Result
<
T
>
where
R
:
Read
T
:
serde
:
:
Deserialize
{
let
mut
deserializer
=
Deserializer
:
:
new
(
reader
size_limit
)
;
serde
:
:
Deserialize
:
:
deserialize
(
&
mut
deserializer
)
}
pub
fn
deserialize
<
T
>
(
bytes
:
&
[
u8
]
)
-
>
Result
<
T
>
where
T
:
serde
:
:
Deserialize
{
let
mut
reader
=
bytes
;
deserialize_from
(
&
mut
reader
SizeLimit
:
:
Infinite
)
}
