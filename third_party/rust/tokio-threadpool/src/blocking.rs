use
worker
:
:
Worker
;
use
futures
:
:
Poll
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
pub
struct
BlockingError
{
_p
:
(
)
}
pub
fn
blocking
<
F
T
>
(
f
:
F
)
-
>
Poll
<
T
BlockingError
>
where
F
:
FnOnce
(
)
-
>
T
{
let
res
=
Worker
:
:
with_current
(
|
worker
|
{
let
worker
=
match
worker
{
Some
(
worker
)
=
>
worker
None
=
>
{
return
Err
(
BlockingError
{
_p
:
(
)
}
)
;
}
}
;
worker
.
transition_to_blocking
(
)
}
)
;
try_ready
!
(
res
)
;
let
ret
=
f
(
)
;
Worker
:
:
with_current
(
|
worker
|
{
worker
.
unwrap
(
)
.
transition_from_blocking
(
)
;
}
)
;
Ok
(
ret
.
into
(
)
)
}
impl
fmt
:
:
Display
for
BlockingError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
self
.
description
(
)
)
}
}
impl
fmt
:
:
Debug
for
BlockingError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
BlockingError
"
)
.
field
(
"
reason
"
&
self
.
description
(
)
)
.
finish
(
)
}
}
impl
Error
for
BlockingError
{
fn
description
(
&
self
)
-
>
&
str
{
"
blocking
annotation
used
from
outside
the
context
of
a
thread
pool
"
}
}
