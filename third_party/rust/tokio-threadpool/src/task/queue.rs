use
task
:
:
Task
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicPtr
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
Release
AcqRel
Relaxed
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Queue
{
head
:
AtomicPtr
<
Task
>
tail
:
UnsafeCell
<
*
mut
Task
>
stub
:
Box
<
Task
>
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
Poll
{
Empty
Inconsistent
Data
(
Arc
<
Task
>
)
}
impl
Queue
{
pub
fn
new
(
)
-
>
Queue
{
let
stub
=
Box
:
:
new
(
Task
:
:
stub
(
)
)
;
let
ptr
=
&
*
stub
as
*
const
_
as
*
mut
_
;
Queue
{
head
:
AtomicPtr
:
:
new
(
ptr
)
tail
:
UnsafeCell
:
:
new
(
ptr
)
stub
:
stub
}
}
pub
fn
push
(
&
self
task
:
Arc
<
Task
>
)
{
unsafe
{
self
.
push2
(
Arc
:
:
into_raw
(
task
)
)
;
}
}
unsafe
fn
push2
(
&
self
task
:
*
const
Task
)
{
let
task
=
task
as
*
mut
Task
;
(
*
task
)
.
next
.
store
(
ptr
:
:
null_mut
(
)
Relaxed
)
;
let
prev
=
self
.
head
.
swap
(
task
AcqRel
)
;
(
*
prev
)
.
next
.
store
(
task
Release
)
;
}
pub
unsafe
fn
poll
(
&
self
)
-
>
Poll
{
let
mut
tail
=
*
self
.
tail
.
get
(
)
;
let
mut
next
=
(
*
tail
)
.
next
.
load
(
Acquire
)
;
let
stub
=
&
*
self
.
stub
as
*
const
_
as
*
mut
_
;
if
tail
=
=
stub
{
if
next
.
is_null
(
)
{
return
Poll
:
:
Empty
;
}
*
self
.
tail
.
get
(
)
=
next
;
tail
=
next
;
next
=
(
*
next
)
.
next
.
load
(
Acquire
)
;
}
if
!
next
.
is_null
(
)
{
*
self
.
tail
.
get
(
)
=
next
;
return
Poll
:
:
Data
(
Arc
:
:
from_raw
(
tail
)
)
;
}
if
self
.
head
.
load
(
Acquire
)
!
=
tail
{
return
Poll
:
:
Inconsistent
;
}
self
.
push2
(
stub
)
;
next
=
(
*
tail
)
.
next
.
load
(
Acquire
)
;
if
!
next
.
is_null
(
)
{
*
self
.
tail
.
get
(
)
=
next
;
return
Poll
:
:
Data
(
Arc
:
:
from_raw
(
tail
)
)
;
}
Poll
:
:
Inconsistent
}
}
