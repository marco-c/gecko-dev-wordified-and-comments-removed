mod
blocking
;
mod
blocking_state
;
mod
queue
;
mod
state
;
pub
(
crate
)
use
self
:
:
blocking
:
:
{
Blocking
CanBlock
}
;
pub
(
crate
)
use
self
:
:
queue
:
:
{
Queue
Poll
}
;
use
self
:
:
blocking_state
:
:
BlockingState
;
use
self
:
:
state
:
:
State
;
use
notifier
:
:
Notifier
;
use
pool
:
:
Pool
;
use
sender
:
:
Sender
;
use
futures
:
:
{
self
Future
Async
}
;
use
futures
:
:
executor
:
:
{
self
Spawn
}
;
use
std
:
:
{
fmt
panic
ptr
}
;
use
std
:
:
cell
:
:
{
UnsafeCell
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
AtomicPtr
}
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
AcqRel
Release
Relaxed
}
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
use
futures2
;
pub
(
crate
)
struct
Task
{
state
:
AtomicUsize
blocking
:
AtomicUsize
next
:
AtomicPtr
<
Task
>
next_blocking
:
AtomicPtr
<
Task
>
future
:
UnsafeCell
<
Option
<
TaskFuture
>
>
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
Run
{
Idle
Schedule
Complete
}
type
BoxFuture
=
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
>
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
type
BoxFuture2
=
Box
<
futures2
:
:
Future
<
Item
=
(
)
Error
=
futures2
:
:
Never
>
+
Send
>
;
enum
TaskFuture
{
Futures1
(
Spawn
<
BoxFuture
>
)
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
Futures2
{
tls
:
futures2
:
:
task
:
:
LocalMap
waker
:
futures2
:
:
task
:
:
Waker
fut
:
BoxFuture2
}
}
impl
Task
{
pub
fn
new
(
future
:
BoxFuture
)
-
>
Task
{
let
task_fut
=
TaskFuture
:
:
Futures1
(
executor
:
:
spawn
(
future
)
)
;
Task
{
state
:
AtomicUsize
:
:
new
(
State
:
:
new
(
)
.
into
(
)
)
blocking
:
AtomicUsize
:
:
new
(
BlockingState
:
:
new
(
)
.
into
(
)
)
next
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_blocking
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
future
:
UnsafeCell
:
:
new
(
Some
(
task_fut
)
)
}
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
pub
fn
new2
<
F
>
(
fut
:
BoxFuture2
make_waker
:
F
)
-
>
Task
where
F
:
FnOnce
(
usize
)
-
>
futures2
:
:
task
:
:
Waker
{
let
mut
inner
=
Box
:
:
new
(
Task
{
state
:
AtomicUsize
:
:
new
(
State
:
:
new
(
)
.
into
(
)
)
blocking
:
AtomicUsize
:
:
new
(
BlockingState
:
:
new
(
)
.
into
(
)
)
next
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_blocking
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
future
:
None
}
)
;
let
waker
=
make_waker
(
(
&
*
inner
)
as
*
const
_
as
usize
)
;
let
tls
=
futures2
:
:
task
:
:
LocalMap
:
:
new
(
)
;
inner
.
future
=
Some
(
TaskFuture
:
:
Futures2
{
waker
tls
fut
}
)
;
Task
{
ptr
:
Box
:
:
into_raw
(
inner
)
}
}
fn
stub
(
)
-
>
Task
{
let
future
=
Box
:
:
new
(
futures
:
:
empty
(
)
)
;
let
task_fut
=
TaskFuture
:
:
Futures1
(
executor
:
:
spawn
(
future
)
)
;
Task
{
state
:
AtomicUsize
:
:
new
(
State
:
:
stub
(
)
.
into
(
)
)
blocking
:
AtomicUsize
:
:
new
(
BlockingState
:
:
new
(
)
.
into
(
)
)
next
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
next_blocking
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
future
:
UnsafeCell
:
:
new
(
Some
(
task_fut
)
)
}
}
pub
fn
run
(
&
self
unpark
:
&
Arc
<
Notifier
>
exec
:
&
mut
Sender
)
-
>
Run
{
use
self
:
:
State
:
:
*
;
let
actual
:
State
=
self
.
state
.
compare_and_swap
(
Scheduled
.
into
(
)
Running
.
into
(
)
AcqRel
)
.
into
(
)
;
match
actual
{
Scheduled
=
>
{
}
_
=
>
panic
!
(
"
unexpected
task
state
;
{
:
?
}
"
actual
)
}
trace
!
(
"
Task
:
:
run
;
state
=
{
:
?
}
"
State
:
:
from
(
self
.
state
.
load
(
Relaxed
)
)
)
;
let
fut
=
unsafe
{
&
mut
(
*
self
.
future
.
get
(
)
)
}
;
let
res
=
panic
:
:
catch_unwind
(
panic
:
:
AssertUnwindSafe
(
|
|
{
struct
Guard
<
'
a
>
(
&
'
a
mut
Option
<
TaskFuture
>
bool
)
;
impl
<
'
a
>
Drop
for
Guard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
self
.
1
{
let
_
=
self
.
0
.
take
(
)
;
}
}
}
let
mut
g
=
Guard
(
fut
true
)
;
let
ret
=
g
.
0
.
as_mut
(
)
.
unwrap
(
)
.
poll
(
unpark
self
as
*
const
_
as
usize
exec
)
;
g
.
1
=
false
;
ret
}
)
)
;
match
res
{
Ok
(
Ok
(
Async
:
:
Ready
(
_
)
)
)
|
Ok
(
Err
(
_
)
)
|
Err
(
_
)
=
>
{
trace
!
(
"
-
>
task
complete
"
)
;
self
.
drop_future
(
)
;
self
.
state
.
store
(
State
:
:
Complete
.
into
(
)
Release
)
;
Run
:
:
Complete
}
Ok
(
Ok
(
Async
:
:
NotReady
)
)
=
>
{
trace
!
(
"
-
>
not
ready
"
)
;
let
prev
:
State
=
self
.
state
.
compare_and_swap
(
Running
.
into
(
)
Idle
.
into
(
)
AcqRel
)
.
into
(
)
;
match
prev
{
Running
=
>
Run
:
:
Idle
Notified
=
>
{
self
.
state
.
store
(
Scheduled
.
into
(
)
Release
)
;
Run
:
:
Schedule
}
_
=
>
unreachable
!
(
)
}
}
}
}
pub
fn
notify
(
me
:
Arc
<
Task
>
pool
:
&
Arc
<
Pool
>
)
{
if
me
.
schedule
(
)
{
let
_
=
pool
.
submit
(
me
pool
)
;
}
}
pub
fn
notify_blocking
(
me
:
Arc
<
Task
>
pool
:
&
Arc
<
Pool
>
)
{
BlockingState
:
:
notify_blocking
(
&
me
.
blocking
AcqRel
)
;
Task
:
:
notify
(
me
pool
)
;
}
pub
fn
schedule
(
&
self
)
-
>
bool
{
use
self
:
:
State
:
:
*
;
loop
{
let
actual
=
self
.
state
.
compare_and_swap
(
Idle
.
into
(
)
Scheduled
.
into
(
)
AcqRel
)
.
into
(
)
;
match
actual
{
Idle
=
>
return
true
Running
=
>
{
let
actual
=
self
.
state
.
compare_and_swap
(
Running
.
into
(
)
Notified
.
into
(
)
AcqRel
)
.
into
(
)
;
match
actual
{
Idle
=
>
continue
_
=
>
return
false
}
}
Complete
|
Notified
|
Scheduled
=
>
return
false
}
}
}
pub
fn
consume_blocking_allocation
(
&
self
)
-
>
CanBlock
{
BlockingState
:
:
consume_allocation
(
&
self
.
blocking
AcqRel
)
}
fn
drop_future
(
&
self
)
{
let
_
=
unsafe
{
(
*
self
.
future
.
get
(
)
)
.
take
(
)
}
;
}
}
impl
fmt
:
:
Debug
for
Task
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Task
"
)
.
field
(
"
next
"
&
self
.
next
)
.
field
(
"
state
"
&
self
.
state
)
.
field
(
"
future
"
&
"
Spawn
<
BoxFuture
>
"
)
.
finish
(
)
}
}
impl
TaskFuture
{
#
[
allow
(
unused_variables
)
]
fn
poll
(
&
mut
self
unpark
:
&
Arc
<
Notifier
>
id
:
usize
exec
:
&
mut
Sender
)
-
>
futures
:
:
Poll
<
(
)
(
)
>
{
match
*
self
{
TaskFuture
:
:
Futures1
(
ref
mut
fut
)
=
>
fut
.
poll_future_notify
(
unpark
id
)
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
TaskFuture
:
:
Futures2
{
ref
mut
fut
ref
waker
ref
mut
tls
}
=
>
{
let
mut
cx
=
futures2
:
:
task
:
:
Context
:
:
new
(
tls
waker
exec
)
;
match
fut
.
poll
(
&
mut
cx
)
.
unwrap
(
)
{
futures2
:
:
Async
:
:
Pending
=
>
Ok
(
Async
:
:
NotReady
)
futures2
:
:
Async
:
:
Ready
(
x
)
=
>
Ok
(
Async
:
:
Ready
(
x
)
)
}
}
}
}
}
