use
task
:
:
CanBlock
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
#
[
derive
(
Eq
PartialEq
)
]
pub
(
crate
)
struct
BlockingState
(
usize
)
;
const
QUEUED
:
usize
=
0b01
;
const
ALLOCATED
:
usize
=
0b10
;
impl
BlockingState
{
pub
fn
new
(
)
-
>
BlockingState
{
BlockingState
(
0
)
}
pub
fn
is_queued
(
&
self
)
-
>
bool
{
self
.
0
&
QUEUED
=
=
QUEUED
}
pub
fn
toggle_queued
(
state
:
&
AtomicUsize
ordering
:
Ordering
)
-
>
BlockingState
{
state
.
fetch_xor
(
QUEUED
ordering
)
.
into
(
)
}
pub
fn
is_allocated
(
&
self
)
-
>
bool
{
self
.
0
&
ALLOCATED
=
=
ALLOCATED
}
pub
fn
consume_allocation
(
state
:
&
AtomicUsize
ordering
:
Ordering
)
-
>
CanBlock
{
let
state
:
Self
=
state
.
fetch_and
(
!
ALLOCATED
ordering
)
.
into
(
)
;
if
state
.
is_allocated
(
)
{
CanBlock
:
:
Allocated
}
else
if
state
.
is_queued
(
)
{
CanBlock
:
:
NoCapacity
}
else
{
CanBlock
:
:
CanRequest
}
}
pub
fn
notify_blocking
(
state
:
&
AtomicUsize
ordering
:
Ordering
)
{
let
prev
:
Self
=
state
.
fetch_xor
(
ALLOCATED
|
QUEUED
ordering
)
.
into
(
)
;
debug_assert
!
(
prev
.
is_queued
(
)
)
;
debug_assert
!
(
!
prev
.
is_allocated
(
)
)
;
}
}
impl
From
<
usize
>
for
BlockingState
{
fn
from
(
src
:
usize
)
-
>
BlockingState
{
BlockingState
(
src
)
}
}
impl
From
<
BlockingState
>
for
usize
{
fn
from
(
src
:
BlockingState
)
-
>
usize
{
src
.
0
}
}
impl
fmt
:
:
Debug
for
BlockingState
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
BlockingState
"
)
.
field
(
"
is_queued
"
&
self
.
is_queued
(
)
)
.
field
(
"
is_allocated
"
&
self
.
is_allocated
(
)
)
.
finish
(
)
}
}
