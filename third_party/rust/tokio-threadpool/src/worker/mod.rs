mod
entry
;
mod
stack
;
mod
state
;
pub
(
crate
)
use
self
:
:
entry
:
:
WorkerEntry
as
Entry
;
pub
(
crate
)
use
self
:
:
stack
:
:
Stack
;
pub
(
crate
)
use
self
:
:
state
:
:
{
Lifecycle
State
}
;
use
notifier
:
:
Notifier
;
use
pool
:
:
{
self
BackupId
Pool
}
;
use
sender
:
:
Sender
;
use
shutdown
:
:
ShutdownTrigger
;
use
task
:
:
{
self
CanBlock
Task
}
;
use
tokio_executor
;
use
futures
:
:
{
Async
Poll
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
AcqRel
Acquire
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
Duration
;
#
[
derive
(
Debug
)
]
pub
struct
Worker
{
pub
(
crate
)
pool
:
Arc
<
Pool
>
pub
(
crate
)
id
:
WorkerId
backup_id
:
BackupId
current_task
:
CurrentTask
is_blocking
:
Cell
<
bool
>
should_finalize
:
Cell
<
bool
>
trigger
:
Arc
<
ShutdownTrigger
>
_p
:
PhantomData
<
Rc
<
(
)
>
>
}
#
[
derive
(
Debug
)
]
struct
CurrentTask
{
task
:
Cell
<
Option
<
*
const
Arc
<
Task
>
>
>
can_block
:
Cell
<
CanBlock
>
}
#
[
derive
(
Debug
Clone
Hash
Eq
PartialEq
)
]
pub
struct
WorkerId
(
pub
(
crate
)
usize
)
;
thread_local
!
(
static
CURRENT_WORKER
:
Cell
<
*
const
Worker
>
=
Cell
:
:
new
(
0
as
*
const
_
)
)
;
impl
Worker
{
pub
(
crate
)
fn
new
(
id
:
WorkerId
backup_id
:
BackupId
pool
:
Arc
<
Pool
>
trigger
:
Arc
<
ShutdownTrigger
>
)
-
>
Worker
{
Worker
{
pool
id
backup_id
current_task
:
CurrentTask
:
:
new
(
)
is_blocking
:
Cell
:
:
new
(
false
)
should_finalize
:
Cell
:
:
new
(
false
)
trigger
_p
:
PhantomData
}
}
pub
(
crate
)
fn
is_blocking
(
&
self
)
-
>
bool
{
self
.
is_blocking
.
get
(
)
}
pub
(
crate
)
fn
do_run
(
&
self
)
-
>
bool
{
CURRENT_WORKER
.
with
(
|
c
|
{
c
.
set
(
self
as
*
const
_
)
;
let
pool
=
self
.
pool
.
clone
(
)
;
let
mut
sender
=
Sender
{
pool
}
;
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
unwrap
(
)
;
tokio_executor
:
:
with_default
(
&
mut
sender
&
mut
enter
|
enter
|
{
if
let
Some
(
ref
callback
)
=
self
.
pool
.
config
.
around_worker
{
callback
.
call
(
self
enter
)
;
}
else
{
self
.
run
(
)
;
}
}
)
;
}
)
;
debug_assert
!
(
!
self
.
is_blocking
.
get
(
)
|
|
!
self
.
should_finalize
.
get
(
)
)
;
self
.
is_blocking
.
get
(
)
}
pub
(
crate
)
fn
with_current
<
F
:
FnOnce
(
Option
<
&
Worker
>
)
-
>
R
R
>
(
f
:
F
)
-
>
R
{
CURRENT_WORKER
.
with
(
move
|
c
|
{
let
ptr
=
c
.
get
(
)
;
if
ptr
.
is_null
(
)
{
f
(
None
)
}
else
{
f
(
Some
(
unsafe
{
&
*
ptr
}
)
)
}
}
)
}
pub
(
crate
)
fn
transition_to_blocking
(
&
self
)
-
>
Poll
<
(
)
:
:
BlockingError
>
{
use
self
:
:
CanBlock
:
:
*
;
let
task_ref
=
self
.
current_task
.
get_ref
(
)
;
match
self
.
current_task
.
can_block
(
)
{
Allocated
=
>
{
}
NoCapacity
=
>
return
Ok
(
Async
:
:
NotReady
)
CanRequest
=
>
{
match
self
.
pool
.
poll_blocking_capacity
(
task_ref
)
?
{
Async
:
:
Ready
(
(
)
)
=
>
{
self
.
current_task
.
set_can_block
(
Allocated
)
;
}
Async
:
:
NotReady
=
>
{
self
.
current_task
.
set_can_block
(
NoCapacity
)
;
return
Ok
(
Async
:
:
NotReady
)
;
}
}
}
}
if
self
.
is_blocking
.
get
(
)
{
return
Ok
(
(
)
.
into
(
)
)
;
}
trace
!
(
"
transition
to
blocking
state
"
)
;
self
.
pool
.
spawn_thread
(
self
.
id
.
clone
(
)
&
self
.
pool
)
;
self
.
is_blocking
.
set
(
true
)
;
Ok
(
(
)
.
into
(
)
)
}
pub
(
crate
)
fn
transition_from_blocking
(
&
self
)
{
}
pub
fn
id
(
&
self
)
-
>
&
WorkerId
{
&
self
.
id
}
pub
fn
run
(
&
self
)
{
const
MAX_SPINS
:
usize
=
3
;
const
LIGHT_SLEEP_INTERVAL
:
usize
=
32
;
let
notify
=
Arc
:
:
new
(
Notifier
{
pool
:
self
.
pool
.
clone
(
)
}
)
;
let
mut
first
=
true
;
let
mut
spin_cnt
=
0
;
let
mut
tick
=
0
;
while
self
.
check_run_state
(
first
)
{
first
=
false
;
if
self
.
try_run_task
(
&
notify
)
{
if
self
.
is_blocking
.
get
(
)
{
return
;
}
if
tick
%
LIGHT_SLEEP_INTERVAL
=
=
0
{
self
.
sleep_light
(
)
;
}
tick
=
tick
.
wrapping_add
(
1
)
;
spin_cnt
=
0
;
continue
;
}
spin_cnt
+
=
1
;
if
spin_cnt
<
=
MAX_SPINS
{
thread
:
:
yield_now
(
)
;
continue
;
}
tick
=
0
;
spin_cnt
=
0
;
if
!
self
.
sleep
(
)
{
return
;
}
}
let
_
=
self
.
pool
.
release_backup
(
self
.
backup_id
)
;
self
.
should_finalize
.
set
(
true
)
;
}
#
[
inline
]
fn
try_run_task
(
&
self
notify
:
&
Arc
<
Notifier
>
)
-
>
bool
{
if
self
.
try_run_owned_task
(
notify
)
{
return
true
;
}
self
.
try_steal_task
(
notify
)
}
#
[
inline
]
fn
check_run_state
(
&
self
first
:
bool
)
-
>
bool
{
use
self
:
:
Lifecycle
:
:
*
;
debug_assert
!
(
!
self
.
is_blocking
.
get
(
)
)
;
let
mut
state
:
State
=
self
.
entry
(
)
.
state
.
load
(
Acquire
)
.
into
(
)
;
loop
{
let
pool_state
:
pool
:
:
State
=
self
.
pool
.
state
.
load
(
Acquire
)
.
into
(
)
;
if
pool_state
.
is_terminated
(
)
{
return
false
;
}
let
mut
next
=
state
;
match
state
.
lifecycle
(
)
{
Running
=
>
break
Notified
|
Signaled
=
>
{
next
.
set_lifecycle
(
Running
)
;
}
Shutdown
|
Sleeping
=
>
{
panic
!
(
"
unexpected
worker
state
;
lifecycle
=
{
:
?
}
"
state
.
lifecycle
(
)
)
;
}
}
let
actual
=
self
.
entry
(
)
.
state
.
compare_and_swap
(
state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
actual
=
=
state
{
break
;
}
state
=
actual
;
}
if
!
first
&
&
state
.
is_signaled
(
)
{
trace
!
(
"
Worker
:
:
check_run_state
;
delegate
signal
"
)
;
self
.
pool
.
signal_work
(
&
self
.
pool
)
;
}
true
}
fn
try_run_owned_task
(
&
self
notify
:
&
Arc
<
Notifier
>
)
-
>
bool
{
match
self
.
entry
(
)
.
pop_task
(
)
{
Some
(
task
)
=
>
{
self
.
run_task
(
task
notify
)
;
true
}
None
=
>
false
}
}
fn
try_steal_task
(
&
self
notify
:
&
Arc
<
Notifier
>
)
-
>
bool
{
use
crossbeam_deque
:
:
Steal
;
debug_assert
!
(
!
self
.
is_blocking
.
get
(
)
)
;
let
len
=
self
.
pool
.
workers
.
len
(
)
;
let
mut
idx
=
self
.
pool
.
rand_usize
(
)
%
len
;
let
mut
found_work
=
false
;
let
start
=
idx
;
loop
{
if
idx
<
len
{
match
self
.
pool
.
workers
[
idx
]
.
steal_tasks
(
self
.
entry
(
)
)
{
Steal
:
:
Success
(
task
)
=
>
{
trace
!
(
"
stole
task
from
another
worker
"
)
;
self
.
run_task
(
task
notify
)
;
trace
!
(
"
try_steal_task
-
-
signal_work
;
self
=
{
}
;
from
=
{
}
"
self
.
id
.
0
idx
)
;
self
.
pool
.
signal_work
(
&
self
.
pool
)
;
return
true
;
}
Steal
:
:
Empty
=
>
{
}
Steal
:
:
Retry
=
>
found_work
=
true
}
idx
+
=
1
;
}
else
{
idx
=
0
;
}
if
idx
=
=
start
{
break
;
}
}
found_work
}
fn
run_task
(
&
self
task
:
Arc
<
Task
>
notify
:
&
Arc
<
Notifier
>
)
{
use
task
:
:
Run
:
:
*
;
if
task
.
reg_worker
.
get
(
)
.
is_none
(
)
{
task
.
reg_worker
.
set
(
Some
(
self
.
id
.
0
as
u32
)
)
;
self
.
entry
(
)
.
register_task
(
&
task
)
;
}
let
run
=
self
.
run_task2
(
&
task
notify
)
;
match
run
{
Idle
=
>
{
}
Schedule
=
>
{
if
self
.
is_blocking
.
get
(
)
{
self
.
pool
.
submit_external
(
task
&
self
.
pool
)
;
}
else
{
self
.
entry
(
)
.
push_internal
(
task
)
;
}
}
Complete
=
>
{
let
mut
state
:
pool
:
:
State
=
self
.
pool
.
state
.
load
(
Acquire
)
.
into
(
)
;
loop
{
let
mut
next
=
state
;
next
.
dec_num_futures
(
)
;
let
actual
=
self
.
pool
.
state
.
compare_and_swap
(
state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
actual
=
=
state
{
trace
!
(
"
task
complete
;
state
=
{
:
?
}
"
next
)
;
if
state
.
num_futures
(
)
=
=
1
{
if
next
.
is_terminated
(
)
{
self
.
pool
.
terminate_sleeping_workers
(
)
;
}
}
let
worker
=
task
.
reg_worker
.
get
(
)
.
unwrap
(
)
as
usize
;
if
!
self
.
is_blocking
.
get
(
)
&
&
worker
=
=
self
.
id
.
0
{
self
.
entry
(
)
.
unregister_task
(
task
)
;
}
else
{
self
.
pool
.
workers
[
worker
]
.
remotely_complete_task
(
task
)
;
}
return
;
}
state
=
actual
;
}
}
}
}
fn
run_task2
(
&
self
task
:
&
Arc
<
Task
>
notify
:
&
Arc
<
Notifier
>
)
-
>
task
:
:
Run
{
struct
Guard
<
'
a
>
{
worker
:
&
'
a
Worker
}
impl
<
'
a
>
Drop
for
Guard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
!
self
.
worker
.
is_blocking
.
get
(
)
{
let
can_block
=
self
.
worker
.
current_task
.
can_block
(
)
;
if
can_block
=
=
CanBlock
:
:
Allocated
{
self
.
worker
.
pool
.
notify_blocking_task
(
&
self
.
worker
.
pool
)
;
}
}
self
.
worker
.
current_task
.
clear
(
)
;
}
}
self
.
current_task
.
set
(
task
CanBlock
:
:
CanRequest
)
;
let
_g
=
Guard
{
worker
:
self
}
;
task
.
run
(
notify
)
}
fn
sleep
(
&
self
)
-
>
bool
{
use
self
:
:
Lifecycle
:
:
*
;
trace
!
(
"
Worker
:
:
sleep
;
worker
=
{
:
?
}
"
self
.
id
)
;
let
mut
state
:
State
=
self
.
entry
(
)
.
state
.
load
(
Acquire
)
.
into
(
)
;
loop
{
let
mut
next
=
state
;
match
state
.
lifecycle
(
)
{
Running
=
>
{
next
.
set_pushed
(
)
;
next
.
set_lifecycle
(
Sleeping
)
;
}
Notified
|
Signaled
=
>
{
next
.
set_lifecycle
(
Running
)
;
}
Shutdown
|
Sleeping
=
>
{
panic
!
(
"
unexpected
worker
state
;
actual
=
{
:
?
}
"
state
.
lifecycle
(
)
)
;
}
}
let
actual
=
self
.
entry
(
)
.
state
.
compare_and_swap
(
state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
actual
=
=
state
{
if
state
.
is_notified
(
)
{
return
true
;
}
if
!
state
.
is_pushed
(
)
{
debug_assert
!
(
next
.
is_pushed
(
)
)
;
trace
!
(
"
sleeping
-
-
push
to
stack
;
idx
=
{
}
"
self
.
id
.
0
)
;
if
let
Err
(
_
)
=
self
.
pool
.
push_sleeper
(
self
.
id
.
0
)
{
trace
!
(
"
sleeping
-
-
push
to
stack
failed
;
idx
=
{
}
"
self
.
id
.
0
)
;
return
true
;
}
}
break
;
}
state
=
actual
;
}
trace
!
(
"
-
>
starting
to
sleep
;
idx
=
{
}
"
self
.
id
.
0
)
;
self
.
sleep_light
(
)
;
loop
{
state
=
self
.
entry
(
)
.
state
.
load
(
Acquire
)
.
into
(
)
;
match
state
.
lifecycle
(
)
{
Sleeping
=
>
{
}
Notified
|
Signaled
=
>
{
loop
{
let
mut
next
=
state
;
next
.
set_lifecycle
(
Running
)
;
let
actual
=
self
.
entry
(
)
.
state
.
compare_and_swap
(
state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
actual
=
=
state
{
return
true
;
}
state
=
actual
;
}
}
Shutdown
|
Running
=
>
{
unreachable
!
(
)
;
}
}
self
.
entry
(
)
.
park
(
)
;
trace
!
(
"
-
>
wakeup
;
idx
=
{
}
"
self
.
id
.
0
)
;
}
}
fn
sleep_light
(
&
self
)
{
self
.
entry
(
)
.
park_timeout
(
Duration
:
:
from_millis
(
0
)
)
;
use
crossbeam_deque
:
:
Steal
;
loop
{
match
self
.
pool
.
queue
.
steal_batch
(
&
self
.
entry
(
)
.
worker
)
{
Steal
:
:
Success
(
(
)
)
=
>
{
self
.
pool
.
signal_work
(
&
self
.
pool
)
;
break
;
}
Steal
:
:
Empty
=
>
break
Steal
:
:
Retry
=
>
{
}
}
}
}
fn
entry
(
&
self
)
-
>
&
Entry
{
debug_assert
!
(
!
self
.
is_blocking
.
get
(
)
)
;
&
self
.
pool
.
workers
[
self
.
id
.
0
]
}
}
impl
Drop
for
Worker
{
fn
drop
(
&
mut
self
)
{
trace
!
(
"
shutting
down
thread
;
idx
=
{
}
"
self
.
id
.
0
)
;
if
self
.
should_finalize
.
get
(
)
{
self
.
entry
(
)
.
drain_tasks
(
)
;
}
}
}
impl
CurrentTask
{
fn
new
(
)
-
>
CurrentTask
{
CurrentTask
{
task
:
Cell
:
:
new
(
None
)
can_block
:
Cell
:
:
new
(
CanBlock
:
:
CanRequest
)
}
}
fn
get_ref
(
&
self
)
-
>
&
Arc
<
Task
>
{
unsafe
{
&
*
self
.
task
.
get
(
)
.
unwrap
(
)
}
}
fn
can_block
(
&
self
)
-
>
CanBlock
{
use
self
:
:
CanBlock
:
:
*
;
match
self
.
can_block
.
get
(
)
{
Allocated
=
>
Allocated
CanRequest
|
NoCapacity
=
>
{
let
can_block
=
self
.
get_ref
(
)
.
consume_blocking_allocation
(
)
;
self
.
can_block
.
set
(
can_block
)
;
can_block
}
}
}
fn
set_can_block
(
&
self
can_block
:
CanBlock
)
{
self
.
can_block
.
set
(
can_block
)
;
}
fn
set
(
&
self
task
:
&
Arc
<
Task
>
can_block
:
CanBlock
)
{
self
.
task
.
set
(
Some
(
task
as
*
const
_
)
)
;
self
.
can_block
.
set
(
can_block
)
;
}
fn
clear
(
&
self
)
{
self
.
task
.
set
(
None
)
;
self
.
can_block
.
set
(
CanBlock
:
:
CanRequest
)
;
}
}
impl
WorkerId
{
pub
(
crate
)
fn
new
(
idx
:
usize
)
-
>
WorkerId
{
WorkerId
(
idx
)
}
pub
fn
to_usize
(
&
self
)
-
>
usize
{
self
.
0
}
}
