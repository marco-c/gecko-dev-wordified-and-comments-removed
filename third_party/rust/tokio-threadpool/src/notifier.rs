use
pool
:
:
Pool
;
use
task
:
:
Task
;
use
std
:
:
mem
;
use
std
:
:
ops
;
use
std
:
:
sync
:
:
{
Arc
Weak
}
;
use
futures
:
:
executor
:
:
Notify
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Notifier
{
pub
inner
:
Weak
<
Pool
>
}
#
[
derive
(
Debug
)
]
struct
Forget
<
T
>
(
Option
<
T
>
)
;
impl
Notify
for
Notifier
{
fn
notify
(
&
self
id
:
usize
)
{
trace
!
(
"
Notifier
:
:
notify
;
id
=
0x
{
:
x
}
"
id
)
;
unsafe
{
let
ptr
=
id
as
*
const
Task
;
let
task
=
Forget
:
:
new
(
Arc
:
:
from_raw
(
ptr
)
)
;
if
task
.
schedule
(
)
{
let
task
=
task
.
clone
(
)
;
if
let
Some
(
inner
)
=
self
.
inner
.
upgrade
(
)
{
let
_
=
inner
.
submit
(
task
&
inner
)
;
}
}
}
}
fn
clone_id
(
&
self
id
:
usize
)
-
>
usize
{
let
ptr
=
id
as
*
const
Task
;
let
t1
=
Forget
:
:
new
(
unsafe
{
Arc
:
:
from_raw
(
ptr
)
}
)
;
let
_
=
Forget
:
:
new
(
t1
.
clone
(
)
)
;
id
}
fn
drop_id
(
&
self
id
:
usize
)
{
unsafe
{
let
ptr
=
id
as
*
const
Task
;
let
_
=
Arc
:
:
from_raw
(
ptr
)
;
}
}
}
impl
<
T
>
Forget
<
T
>
{
fn
new
(
t
:
T
)
-
>
Self
{
Forget
(
Some
(
t
)
)
}
}
impl
<
T
>
ops
:
:
Deref
for
Forget
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
self
.
0
.
as_ref
(
)
.
unwrap
(
)
}
}
impl
<
T
>
Drop
for
Forget
<
T
>
{
fn
drop
(
&
mut
self
)
{
mem
:
:
forget
(
self
.
0
.
take
(
)
)
;
}
}
