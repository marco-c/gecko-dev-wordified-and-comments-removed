use
super
:
:
{
BlockingError
BlockingImpl
}
;
use
futures
:
:
Poll
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
fmt
;
use
std
:
:
marker
:
:
PhantomData
;
use
tokio_executor
:
:
Enter
;
thread_local
!
{
static
CURRENT
:
Cell
<
BlockingImpl
>
=
Cell
:
:
new
(
super
:
:
default_blocking
)
;
}
pub
struct
DefaultGuard
<
'
a
>
{
prior
:
BlockingImpl
_lifetime
:
PhantomData
<
&
'
a
(
)
>
}
pub
fn
set_default
<
'
a
>
(
blocking
:
BlockingImpl
)
-
>
DefaultGuard
<
'
a
>
{
CURRENT
.
with
(
|
cell
|
{
let
prior
=
cell
.
replace
(
blocking
)
;
DefaultGuard
{
prior
_lifetime
:
PhantomData
}
}
)
}
pub
fn
with_default
<
F
R
>
(
blocking
:
BlockingImpl
enter
:
&
mut
Enter
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Enter
)
-
>
R
{
let
_guard
=
set_default
(
blocking
)
;
f
(
enter
)
}
pub
fn
blocking
<
F
T
>
(
f
:
F
)
-
>
Poll
<
T
BlockingError
>
where
F
:
FnOnce
(
)
-
>
T
{
CURRENT
.
with
(
|
cell
|
{
let
blocking
=
cell
.
get
(
)
;
let
mut
f
=
Some
(
f
)
;
let
mut
ret
=
None
;
{
let
ret2
=
&
mut
ret
;
let
mut
run
=
move
|
|
{
let
f
=
f
.
take
(
)
.
expect
(
"
blocking
closure
invoked
twice
;
this
is
a
bug
!
"
)
;
*
ret2
=
Some
(
(
f
)
(
)
)
;
}
;
try_ready
!
(
(
blocking
)
(
&
mut
run
)
)
;
}
let
ret
=
ret
.
expect
(
"
blocking
function
finished
but
return
value
was
unset
;
this
is
a
bug
!
"
)
;
Ok
(
ret
.
into
(
)
)
}
)
}
impl
<
'
a
>
fmt
:
:
Debug
for
DefaultGuard
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
pad
(
"
DefaultGuard
{
.
.
}
"
)
}
}
impl
<
'
a
>
Drop
for
DefaultGuard
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
let
_
=
CURRENT
.
try_with
(
|
cell
|
{
cell
.
set
(
self
.
prior
)
;
}
)
;
}
}
