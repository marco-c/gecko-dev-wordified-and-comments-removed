mod
backup
;
mod
backup_stack
;
mod
state
;
pub
(
crate
)
use
self
:
:
backup
:
:
{
Backup
BackupId
}
;
pub
(
crate
)
use
self
:
:
backup_stack
:
:
MAX_BACKUP
;
pub
(
crate
)
use
self
:
:
state
:
:
{
State
Lifecycle
MAX_FUTURES
}
;
use
self
:
:
backup
:
:
Handoff
;
use
self
:
:
backup_stack
:
:
BackupStack
;
use
config
:
:
Config
;
use
shutdown_task
:
:
ShutdownTask
;
use
task
:
:
{
Task
Blocking
}
;
use
worker
:
:
{
self
Worker
WorkerId
}
;
use
futures
:
:
Poll
;
use
futures
:
:
task
:
:
AtomicTask
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
AcqRel
Relaxed
}
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
rand
:
:
{
Rng
SeedableRng
XorShiftRng
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Pool
{
pub
state
:
AtomicUsize
sleep_stack
:
worker
:
:
Stack
pub
num_workers
:
AtomicUsize
pub
next_thread_id
:
AtomicUsize
pub
workers
:
Box
<
[
worker
:
:
Entry
]
>
backup
:
Box
<
[
Backup
]
>
pub
backup_stack
:
BackupStack
blocking
:
Blocking
pub
shutdown_task
:
ShutdownTask
pub
config
:
Config
}
const
TERMINATED
:
usize
=
1
;
impl
Pool
{
pub
fn
new
(
workers
:
Box
<
[
worker
:
:
Entry
]
>
max_blocking
:
usize
config
:
Config
)
-
>
Pool
{
let
pool_size
=
workers
.
len
(
)
;
let
total_size
=
max_blocking
+
pool_size
;
let
backup
=
(
0
.
.
total_size
)
.
map
(
|
_
|
{
Backup
:
:
new
(
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
;
let
backup_stack
=
BackupStack
:
:
new
(
)
;
for
i
in
(
0
.
.
backup
.
len
(
)
)
.
rev
(
)
{
backup_stack
.
push
(
&
backup
BackupId
(
i
)
)
.
unwrap
(
)
;
}
let
blocking
=
Blocking
:
:
new
(
max_blocking
)
;
let
ret
=
Pool
{
state
:
AtomicUsize
:
:
new
(
State
:
:
new
(
)
.
into
(
)
)
sleep_stack
:
worker
:
:
Stack
:
:
new
(
)
num_workers
:
AtomicUsize
:
:
new
(
0
)
next_thread_id
:
AtomicUsize
:
:
new
(
0
)
workers
backup
backup_stack
blocking
shutdown_task
:
ShutdownTask
{
task1
:
AtomicTask
:
:
new
(
)
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
task2
:
futures2
:
:
task
:
:
AtomicWaker
:
:
new
(
)
}
config
}
;
for
i
in
0
.
.
pool_size
{
ret
.
sleep_stack
.
push
(
&
ret
.
workers
i
)
.
unwrap
(
)
;
}
ret
}
pub
fn
shutdown
(
&
self
now
:
bool
purge_queue
:
bool
)
{
let
mut
state
:
State
=
self
.
state
.
load
(
Acquire
)
.
into
(
)
;
trace
!
(
"
shutdown
;
state
=
{
:
?
}
"
state
)
;
debug_assert
!
(
!
purge_queue
|
|
now
)
;
loop
{
let
mut
next
=
state
;
let
num_futures
=
next
.
num_futures
(
)
;
if
next
.
lifecycle
(
)
=
=
Lifecycle
:
:
ShutdownNow
{
if
!
purge_queue
|
|
num_futures
=
=
0
{
return
;
}
debug_assert
!
(
purge_queue
)
;
next
.
clear_num_futures
(
)
;
}
else
{
next
.
set_lifecycle
(
if
now
|
|
num_futures
=
=
0
{
Lifecycle
:
:
ShutdownNow
}
else
{
Lifecycle
:
:
ShutdownOnIdle
}
)
;
if
purge_queue
{
next
.
clear_num_futures
(
)
;
}
}
let
actual
=
self
.
state
.
compare_and_swap
(
state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
state
=
=
actual
{
state
=
next
;
break
;
}
state
=
actual
;
}
trace
!
(
"
-
>
transitioned
to
shutdown
"
)
;
if
state
.
num_futures
(
)
!
=
0
{
return
;
}
self
.
terminate_sleeping_workers
(
)
;
}
pub
fn
is_shutdown
(
&
self
)
-
>
bool
{
self
.
num_workers
.
load
(
Acquire
)
=
=
TERMINATED
}
pub
fn
push_sleeper
(
&
self
idx
:
usize
)
-
>
Result
<
(
)
(
)
>
{
self
.
sleep_stack
.
push
(
&
self
.
workers
idx
)
}
pub
fn
terminate_sleeping_workers
(
&
self
)
{
use
worker
:
:
Lifecycle
:
:
Signaled
;
let
prev
=
self
.
num_workers
.
fetch_or
(
TERMINATED
AcqRel
)
;
let
notify
=
prev
=
=
0
;
trace
!
(
"
-
>
shutting
down
workers
"
)
;
while
let
Some
(
(
idx
worker_state
)
)
=
self
.
sleep_stack
.
pop
(
&
self
.
workers
Signaled
true
)
{
self
.
workers
[
idx
]
.
signal_stop
(
worker_state
)
;
}
while
let
Ok
(
Some
(
backup_id
)
)
=
self
.
backup_stack
.
pop
(
&
self
.
backup
true
)
{
self
.
backup
[
backup_id
.
0
]
.
signal_stop
(
)
;
}
if
notify
{
self
.
shutdown_task
.
notify
(
)
;
}
}
fn
thread_started
(
&
self
)
-
>
Result
<
(
)
(
)
>
{
let
mut
curr
=
self
.
num_workers
.
load
(
Acquire
)
;
loop
{
if
curr
&
TERMINATED
=
=
TERMINATED
{
return
Err
(
(
)
)
;
}
let
actual
=
self
.
num_workers
.
compare_and_swap
(
curr
curr
+
2
AcqRel
)
;
if
curr
=
=
actual
{
return
Ok
(
(
)
)
;
}
curr
=
actual
;
}
}
fn
thread_stopped
(
&
self
)
{
let
prev
=
self
.
num_workers
.
fetch_sub
(
2
AcqRel
)
;
if
prev
=
=
TERMINATED
|
2
{
self
.
shutdown_task
.
notify
(
)
;
}
}
pub
fn
poll_blocking_capacity
(
&
self
task
:
&
Arc
<
Task
>
)
-
>
Poll
<
(
)
:
:
BlockingError
>
{
self
.
blocking
.
poll_blocking_capacity
(
task
)
}
pub
fn
submit
(
&
self
task
:
Arc
<
Task
>
inner
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
inner
)
;
Worker
:
:
with_current
(
|
worker
|
{
if
let
Some
(
worker
)
=
worker
{
if
!
worker
.
is_blocking
(
)
&
&
*
self
=
=
*
worker
.
inner
{
let
idx
=
worker
.
id
.
0
;
trace
!
(
"
-
>
submit
internal
;
idx
=
{
}
"
idx
)
;
worker
.
inner
.
workers
[
idx
]
.
submit_internal
(
task
)
;
worker
.
inner
.
signal_work
(
inner
)
;
return
;
}
}
self
.
submit_external
(
task
inner
)
;
}
)
;
}
pub
fn
submit_external
(
&
self
task
:
Arc
<
Task
>
inner
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
inner
)
;
use
worker
:
:
Lifecycle
:
:
Notified
;
if
let
Some
(
(
idx
worker_state
)
)
=
self
.
sleep_stack
.
pop
(
&
self
.
workers
Notified
false
)
{
trace
!
(
"
submit
to
existing
worker
;
idx
=
{
}
;
state
=
{
:
?
}
"
idx
worker_state
)
;
self
.
submit_to_external
(
idx
task
worker_state
inner
)
;
return
;
}
let
len
=
self
.
workers
.
len
(
)
;
let
idx
=
self
.
rand_usize
(
)
%
len
;
trace
!
(
"
-
>
submitting
to
random
;
idx
=
{
}
"
idx
)
;
let
state
=
self
.
workers
[
idx
]
.
load_state
(
)
;
self
.
submit_to_external
(
idx
task
state
inner
)
;
}
fn
submit_to_external
(
&
self
idx
:
usize
task
:
Arc
<
Task
>
state
:
worker
:
:
State
inner
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
inner
)
;
let
entry
=
&
self
.
workers
[
idx
]
;
if
!
entry
.
submit_external
(
task
state
)
{
self
.
spawn_thread
(
WorkerId
:
:
new
(
idx
)
inner
)
;
}
}
pub
fn
release_backup
(
&
self
backup_id
:
BackupId
)
-
>
Result
<
(
)
(
)
>
{
self
.
backup
[
backup_id
.
0
]
.
release
(
)
;
self
.
backup_stack
.
push
(
&
self
.
backup
backup_id
)
}
pub
fn
notify_blocking_task
(
&
self
inner
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
inner
)
;
self
.
blocking
.
notify_task
(
&
inner
)
;
}
pub
fn
spawn_thread
(
&
self
id
:
WorkerId
inner
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
inner
)
;
let
backup_id
=
match
self
.
backup_stack
.
pop
(
&
self
.
backup
false
)
{
Ok
(
Some
(
backup_id
)
)
=
>
backup_id
Ok
(
None
)
=
>
panic
!
(
"
no
thread
available
"
)
Err
(
_
)
=
>
{
debug
!
(
"
failed
to
spawn
worker
thread
due
to
the
thread
pool
shutting
down
"
)
;
return
;
}
}
;
let
need_spawn
=
self
.
backup
[
backup_id
.
0
]
.
worker_handoff
(
id
.
clone
(
)
)
;
if
!
need_spawn
{
return
;
}
if
self
.
thread_started
(
)
.
is_err
(
)
{
return
;
}
let
mut
th
=
thread
:
:
Builder
:
:
new
(
)
;
if
let
Some
(
ref
prefix
)
=
inner
.
config
.
name_prefix
{
th
=
th
.
name
(
format
!
(
"
{
}
{
}
"
prefix
backup_id
.
0
)
)
;
}
if
let
Some
(
stack
)
=
inner
.
config
.
stack_size
{
th
=
th
.
stack_size
(
stack
)
;
}
let
inner
=
inner
.
clone
(
)
;
let
res
=
th
.
spawn
(
move
|
|
{
if
let
Some
(
ref
f
)
=
inner
.
config
.
after_start
{
f
(
)
;
}
let
mut
worker_id
=
id
;
inner
.
backup
[
backup_id
.
0
]
.
start
(
&
worker_id
)
;
loop
{
debug_assert
!
(
inner
.
backup
[
backup_id
.
0
]
.
is_running
(
)
)
;
let
worker
=
Worker
:
:
new
(
worker_id
backup_id
inner
.
clone
(
)
)
;
if
!
worker
.
do_run
(
)
{
break
;
}
let
res
=
inner
.
backup_stack
.
push
(
&
inner
.
backup
backup_id
)
;
if
res
.
is_err
(
)
{
break
;
}
inner
.
notify_blocking_task
(
&
inner
)
;
debug_assert
!
(
inner
.
backup
[
backup_id
.
0
]
.
is_running
(
)
)
;
let
handoff
=
inner
.
backup
[
backup_id
.
0
]
.
wait_for_handoff
(
true
)
;
match
handoff
{
Handoff
:
:
Worker
(
id
)
=
>
{
debug_assert
!
(
inner
.
backup
[
backup_id
.
0
]
.
is_running
(
)
)
;
worker_id
=
id
;
}
Handoff
:
:
Idle
=
>
{
break
;
}
Handoff
:
:
Terminated
=
>
{
break
;
}
}
}
if
let
Some
(
ref
f
)
=
inner
.
config
.
before_stop
{
f
(
)
;
}
inner
.
thread_stopped
(
)
;
}
)
;
if
let
Err
(
e
)
=
res
{
warn
!
(
"
failed
to
spawn
worker
thread
;
err
=
{
:
?
}
"
e
)
;
}
}
pub
fn
signal_work
(
&
self
inner
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
inner
)
;
use
worker
:
:
Lifecycle
:
:
*
;
if
let
Some
(
(
idx
mut
worker_state
)
)
=
self
.
sleep_stack
.
pop
(
&
self
.
workers
Signaled
false
)
{
let
entry
=
&
self
.
workers
[
idx
]
;
debug_assert
!
(
worker_state
.
lifecycle
(
)
!
=
Signaled
"
actual
=
{
:
?
}
"
worker_state
.
lifecycle
(
)
)
;
loop
{
let
mut
next
=
worker_state
;
next
.
set_lifecycle
(
Signaled
)
;
let
actual
=
entry
.
state
.
compare_and_swap
(
worker_state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
actual
=
=
worker_state
{
break
;
}
worker_state
=
actual
;
}
match
worker_state
.
lifecycle
(
)
{
Sleeping
=
>
{
trace
!
(
"
signal_work
-
-
wakeup
;
idx
=
{
}
"
idx
)
;
self
.
workers
[
idx
]
.
wakeup
(
)
;
}
Shutdown
=
>
{
trace
!
(
"
signal_work
-
-
spawn
;
idx
=
{
}
"
idx
)
;
self
.
spawn_thread
(
WorkerId
(
idx
)
inner
)
;
}
Running
|
Notified
|
Signaled
=
>
{
}
}
}
}
pub
fn
rand_usize
(
&
self
)
-
>
usize
{
thread_local
!
(
static
THREAD_RNG_KEY
:
UnsafeCell
<
Option
<
XorShiftRng
>
>
=
UnsafeCell
:
:
new
(
None
)
)
;
THREAD_RNG_KEY
.
with
(
|
t
|
{
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
new_rng
(
thread_id
:
usize
)
-
>
XorShiftRng
{
XorShiftRng
:
:
from_seed
(
[
thread_id
as
u32
0x00000000
0xa8a7d469
0x97830e05
]
)
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
new_rng
(
thread_id
:
usize
)
-
>
XorShiftRng
{
XorShiftRng
:
:
from_seed
(
[
thread_id
as
u32
(
thread_id
>
>
32
)
as
u32
0xa8a7d469
0x97830e05
]
)
}
let
thread_id
=
self
.
next_thread_id
.
fetch_add
(
1
Relaxed
)
;
let
rng
=
unsafe
{
&
mut
*
t
.
get
(
)
}
;
if
rng
.
is_none
(
)
{
*
rng
=
Some
(
new_rng
(
thread_id
)
)
;
}
rng
.
as_mut
(
)
.
unwrap
(
)
.
next_u32
(
)
as
usize
}
)
}
}
impl
PartialEq
for
Pool
{
fn
eq
(
&
self
other
:
&
Pool
)
-
>
bool
{
self
as
*
const
_
=
=
other
as
*
const
_
}
}
unsafe
impl
Send
for
Pool
{
}
unsafe
impl
Sync
for
Pool
{
}
