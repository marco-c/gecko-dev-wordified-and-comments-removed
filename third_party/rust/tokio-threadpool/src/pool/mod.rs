mod
backup
;
mod
backup_stack
;
mod
state
;
pub
(
crate
)
use
self
:
:
backup
:
:
{
Backup
BackupId
}
;
pub
(
crate
)
use
self
:
:
backup_stack
:
:
MAX_BACKUP
;
pub
(
crate
)
use
self
:
:
state
:
:
{
State
Lifecycle
MAX_FUTURES
}
;
use
self
:
:
backup
:
:
Handoff
;
use
self
:
:
backup_stack
:
:
BackupStack
;
use
config
:
:
Config
;
use
shutdown
:
:
ShutdownTrigger
;
use
task
:
:
{
Blocking
Queue
Task
}
;
use
worker
:
:
{
self
Worker
WorkerId
}
;
use
futures
:
:
Poll
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
num
:
:
Wrapping
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
AcqRel
}
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
{
Arc
Weak
}
;
use
std
:
:
thread
;
use
crossbeam_utils
:
:
CachePadded
;
use
rand
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Pool
{
pub
state
:
CachePadded
<
AtomicUsize
>
sleep_stack
:
CachePadded
<
worker
:
:
Stack
>
pub
num_workers
:
AtomicUsize
pub
workers
:
Arc
<
[
worker
:
:
Entry
]
>
pub
queue
:
Arc
<
Queue
>
pub
trigger
:
Weak
<
ShutdownTrigger
>
backup
:
Box
<
[
Backup
]
>
pub
backup_stack
:
BackupStack
blocking
:
Blocking
pub
config
:
Config
}
impl
Pool
{
pub
fn
new
(
workers
:
Arc
<
[
worker
:
:
Entry
]
>
trigger
:
Weak
<
ShutdownTrigger
>
max_blocking
:
usize
config
:
Config
queue
:
Arc
<
Queue
>
)
-
>
Pool
{
let
pool_size
=
workers
.
len
(
)
;
let
total_size
=
max_blocking
+
pool_size
;
let
backup
=
(
0
.
.
total_size
)
.
map
(
|
_
|
{
Backup
:
:
new
(
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
into_boxed_slice
(
)
;
let
backup_stack
=
BackupStack
:
:
new
(
)
;
for
i
in
(
0
.
.
backup
.
len
(
)
)
.
rev
(
)
{
backup_stack
.
push
(
&
backup
BackupId
(
i
)
)
.
unwrap
(
)
;
}
let
blocking
=
Blocking
:
:
new
(
max_blocking
)
;
let
ret
=
Pool
{
state
:
CachePadded
:
:
new
(
AtomicUsize
:
:
new
(
State
:
:
new
(
)
.
into
(
)
)
)
sleep_stack
:
CachePadded
:
:
new
(
worker
:
:
Stack
:
:
new
(
)
)
num_workers
:
AtomicUsize
:
:
new
(
0
)
workers
queue
trigger
backup
backup_stack
blocking
config
}
;
for
i
in
0
.
.
pool_size
{
ret
.
sleep_stack
.
push
(
&
ret
.
workers
i
)
.
unwrap
(
)
;
}
ret
}
pub
fn
shutdown
(
&
self
now
:
bool
purge_queue
:
bool
)
{
let
mut
state
:
State
=
self
.
state
.
load
(
Acquire
)
.
into
(
)
;
trace
!
(
"
shutdown
;
state
=
{
:
?
}
"
state
)
;
debug_assert
!
(
!
purge_queue
|
|
now
)
;
loop
{
let
mut
next
=
state
;
let
num_futures
=
next
.
num_futures
(
)
;
if
next
.
lifecycle
(
)
=
=
Lifecycle
:
:
ShutdownNow
{
if
!
purge_queue
|
|
num_futures
=
=
0
{
return
;
}
debug_assert
!
(
purge_queue
)
;
next
.
clear_num_futures
(
)
;
}
else
{
next
.
set_lifecycle
(
if
now
|
|
num_futures
=
=
0
{
Lifecycle
:
:
ShutdownNow
}
else
{
Lifecycle
:
:
ShutdownOnIdle
}
)
;
if
purge_queue
{
next
.
clear_num_futures
(
)
;
}
}
let
actual
=
self
.
state
.
compare_and_swap
(
state
.
into
(
)
next
.
into
(
)
AcqRel
)
.
into
(
)
;
if
state
=
=
actual
{
state
=
next
;
break
;
}
state
=
actual
;
}
trace
!
(
"
-
>
transitioned
to
shutdown
"
)
;
if
state
.
num_futures
(
)
!
=
0
{
return
;
}
self
.
terminate_sleeping_workers
(
)
;
}
pub
fn
push_sleeper
(
&
self
idx
:
usize
)
-
>
Result
<
(
)
(
)
>
{
self
.
sleep_stack
.
push
(
&
self
.
workers
idx
)
}
pub
fn
terminate_sleeping_workers
(
&
self
)
{
use
worker
:
:
Lifecycle
:
:
Signaled
;
trace
!
(
"
-
>
shutting
down
workers
"
)
;
while
let
Some
(
(
idx
worker_state
)
)
=
self
.
sleep_stack
.
pop
(
&
self
.
workers
Signaled
true
)
{
self
.
workers
[
idx
]
.
signal_stop
(
worker_state
)
;
}
while
let
Ok
(
Some
(
backup_id
)
)
=
self
.
backup_stack
.
pop
(
&
self
.
backup
true
)
{
self
.
backup
[
backup_id
.
0
]
.
signal_stop
(
)
;
}
}
pub
fn
poll_blocking_capacity
(
&
self
task
:
&
Arc
<
Task
>
)
-
>
Poll
<
(
)
:
:
BlockingError
>
{
self
.
blocking
.
poll_blocking_capacity
(
task
)
}
pub
fn
submit
(
&
self
task
:
Arc
<
Task
>
pool
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
pool
)
;
Worker
:
:
with_current
(
|
worker
|
{
if
let
Some
(
worker
)
=
worker
{
if
!
worker
.
is_blocking
(
)
&
&
*
self
=
=
*
worker
.
pool
{
let
idx
=
worker
.
id
.
0
;
trace
!
(
"
-
>
submit
internal
;
idx
=
{
}
"
idx
)
;
worker
.
pool
.
workers
[
idx
]
.
submit_internal
(
task
)
;
worker
.
pool
.
signal_work
(
pool
)
;
return
;
}
}
self
.
submit_external
(
task
pool
)
;
}
)
;
}
pub
fn
submit_external
(
&
self
task
:
Arc
<
Task
>
pool
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
pool
)
;
trace
!
(
"
-
>
submit
external
"
)
;
self
.
queue
.
push
(
task
)
;
self
.
signal_work
(
pool
)
;
}
pub
fn
release_backup
(
&
self
backup_id
:
BackupId
)
-
>
Result
<
(
)
(
)
>
{
self
.
backup
[
backup_id
.
0
]
.
release
(
)
;
self
.
backup_stack
.
push
(
&
self
.
backup
backup_id
)
}
pub
fn
notify_blocking_task
(
&
self
pool
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
pool
)
;
self
.
blocking
.
notify_task
(
&
pool
)
;
}
pub
fn
spawn_thread
(
&
self
id
:
WorkerId
pool
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
pool
)
;
let
backup_id
=
match
self
.
backup_stack
.
pop
(
&
self
.
backup
false
)
{
Ok
(
Some
(
backup_id
)
)
=
>
backup_id
Ok
(
None
)
=
>
panic
!
(
"
no
thread
available
"
)
Err
(
_
)
=
>
{
debug
!
(
"
failed
to
spawn
worker
thread
due
to
the
thread
pool
shutting
down
"
)
;
return
;
}
}
;
let
need_spawn
=
self
.
backup
[
backup_id
.
0
]
.
worker_handoff
(
id
.
clone
(
)
)
;
if
!
need_spawn
{
return
;
}
let
trigger
=
match
self
.
trigger
.
upgrade
(
)
{
None
=
>
{
return
;
}
Some
(
t
)
=
>
t
}
;
let
mut
th
=
thread
:
:
Builder
:
:
new
(
)
;
if
let
Some
(
ref
prefix
)
=
pool
.
config
.
name_prefix
{
th
=
th
.
name
(
format
!
(
"
{
}
{
}
"
prefix
backup_id
.
0
)
)
;
}
if
let
Some
(
stack
)
=
pool
.
config
.
stack_size
{
th
=
th
.
stack_size
(
stack
)
;
}
let
pool
=
pool
.
clone
(
)
;
let
res
=
th
.
spawn
(
move
|
|
{
if
let
Some
(
ref
f
)
=
pool
.
config
.
after_start
{
f
(
)
;
}
let
mut
worker_id
=
id
;
pool
.
backup
[
backup_id
.
0
]
.
start
(
&
worker_id
)
;
loop
{
debug_assert
!
(
pool
.
backup
[
backup_id
.
0
]
.
is_running
(
)
)
;
let
worker
=
Worker
:
:
new
(
worker_id
backup_id
pool
.
clone
(
)
trigger
.
clone
(
)
)
;
if
!
worker
.
do_run
(
)
{
break
;
}
debug_assert
!
(
!
pool
.
backup
[
backup_id
.
0
]
.
is_pushed
(
)
)
;
let
res
=
pool
.
backup_stack
.
push
(
&
pool
.
backup
backup_id
)
;
if
res
.
is_err
(
)
{
break
;
}
pool
.
notify_blocking_task
(
&
pool
)
;
debug_assert
!
(
pool
.
backup
[
backup_id
.
0
]
.
is_running
(
)
)
;
let
handoff
=
pool
.
backup
[
backup_id
.
0
]
.
wait_for_handoff
(
pool
.
config
.
keep_alive
)
;
match
handoff
{
Handoff
:
:
Worker
(
id
)
=
>
{
debug_assert
!
(
pool
.
backup
[
backup_id
.
0
]
.
is_running
(
)
)
;
worker_id
=
id
;
}
Handoff
:
:
Idle
|
Handoff
:
:
Terminated
=
>
{
break
;
}
}
}
if
let
Some
(
ref
f
)
=
pool
.
config
.
before_stop
{
f
(
)
;
}
}
)
;
if
let
Err
(
e
)
=
res
{
error
!
(
"
failed
to
spawn
worker
thread
;
err
=
{
:
?
}
"
e
)
;
panic
!
(
"
failed
to
spawn
worker
thread
:
{
:
?
}
"
e
)
;
}
}
pub
fn
signal_work
(
&
self
pool
:
&
Arc
<
Pool
>
)
{
debug_assert_eq
!
(
*
self
*
*
pool
)
;
use
worker
:
:
Lifecycle
:
:
Signaled
;
if
let
Some
(
(
idx
worker_state
)
)
=
self
.
sleep_stack
.
pop
(
&
self
.
workers
Signaled
false
)
{
let
entry
=
&
self
.
workers
[
idx
]
;
debug_assert
!
(
worker_state
.
lifecycle
(
)
!
=
Signaled
"
actual
=
{
:
?
}
"
worker_state
.
lifecycle
(
)
)
;
trace
!
(
"
signal_work
-
-
notify
;
idx
=
{
}
"
idx
)
;
if
!
entry
.
notify
(
worker_state
)
{
trace
!
(
"
signal_work
-
-
spawn
;
idx
=
{
}
"
idx
)
;
self
.
spawn_thread
(
WorkerId
(
idx
)
pool
)
;
}
}
}
pub
fn
rand_usize
(
&
self
)
-
>
usize
{
thread_local
!
{
static
RNG
:
Cell
<
Wrapping
<
u32
>
>
=
{
/
/
The
initial
seed
must
be
non
-
zero
.
let
init
=
rand
:
:
random
:
:
<
u32
>
(
)
|
1
;
Cell
:
:
new
(
Wrapping
(
init
)
)
}
}
RNG
.
with
(
|
rng
|
{
let
mut
x
=
rng
.
get
(
)
;
x
^
=
x
<
<
13
;
x
^
=
x
>
>
17
;
x
^
=
x
<
<
5
;
rng
.
set
(
x
)
;
x
.
0
as
usize
}
)
}
}
impl
PartialEq
for
Pool
{
fn
eq
(
&
self
other
:
&
Pool
)
-
>
bool
{
self
as
*
const
_
=
=
other
as
*
const
_
}
}
unsafe
impl
Send
for
Pool
{
}
unsafe
impl
Sync
for
Pool
{
}
