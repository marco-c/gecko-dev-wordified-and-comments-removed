use
pool
:
:
Pool
;
use
sender
:
:
Sender
;
use
futures
:
:
{
Future
Poll
Async
}
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
use
futures2
;
#
[
derive
(
Debug
)
]
pub
struct
Shutdown
{
pub
(
crate
)
inner
:
Sender
}
impl
Shutdown
{
fn
inner
(
&
self
)
-
>
&
Pool
{
&
*
self
.
inner
.
inner
}
}
impl
Future
for
Shutdown
{
type
Item
=
(
)
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
)
(
)
>
{
use
futures
:
:
task
;
self
.
inner
(
)
.
shutdown_task
.
task1
.
register_task
(
task
:
:
current
(
)
)
;
if
!
self
.
inner
(
)
.
is_shutdown
(
)
{
return
Ok
(
Async
:
:
NotReady
)
;
}
Ok
(
(
)
.
into
(
)
)
}
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
impl
futures2
:
:
Future
for
Shutdown
{
type
Item
=
(
)
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
cx
:
&
mut
futures2
:
:
task
:
:
Context
)
-
>
futures2
:
:
Poll
<
(
)
(
)
>
{
trace
!
(
"
Shutdown
:
:
poll
"
)
;
self
.
inner
(
)
.
shutdown_task
.
task2
.
register
(
cx
.
waker
(
)
)
;
if
0
!
=
self
.
inner
(
)
.
num_workers
.
load
(
Acquire
)
{
return
Ok
(
futures2
:
:
Async
:
:
Pending
)
;
}
Ok
(
(
)
.
into
(
)
)
}
}
