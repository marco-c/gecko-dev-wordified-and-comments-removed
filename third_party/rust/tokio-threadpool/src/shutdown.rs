use
task
:
:
Task
;
use
worker
;
use
crossbeam_deque
:
:
Injector
;
use
futures
:
:
task
:
:
AtomicTask
;
use
futures
:
:
{
Async
Future
Poll
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
#
[
derive
(
Debug
)
]
pub
struct
Shutdown
{
inner
:
Arc
<
Mutex
<
Inner
>
>
}
#
[
derive
(
Debug
)
]
struct
Inner
{
task
:
AtomicTask
completed
:
bool
}
impl
Shutdown
{
pub
(
crate
)
fn
new
(
trigger
:
&
ShutdownTrigger
)
-
>
Shutdown
{
Shutdown
{
inner
:
trigger
.
inner
.
clone
(
)
}
}
}
impl
Future
for
Shutdown
{
type
Item
=
(
)
;
type
Error
=
(
)
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
)
(
)
>
{
let
inner
=
self
.
inner
.
lock
(
)
.
unwrap
(
)
;
if
!
inner
.
completed
{
inner
.
task
.
register
(
)
;
Ok
(
Async
:
:
NotReady
)
}
else
{
Ok
(
(
)
.
into
(
)
)
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
ShutdownTrigger
{
inner
:
Arc
<
Mutex
<
Inner
>
>
workers
:
Arc
<
[
worker
:
:
Entry
]
>
queue
:
Arc
<
Injector
<
Arc
<
Task
>
>
>
}
unsafe
impl
Send
for
ShutdownTrigger
{
}
unsafe
impl
Sync
for
ShutdownTrigger
{
}
impl
ShutdownTrigger
{
pub
(
crate
)
fn
new
(
workers
:
Arc
<
[
worker
:
:
Entry
]
>
queue
:
Arc
<
Injector
<
Arc
<
Task
>
>
>
)
-
>
ShutdownTrigger
{
ShutdownTrigger
{
inner
:
Arc
:
:
new
(
Mutex
:
:
new
(
Inner
{
task
:
AtomicTask
:
:
new
(
)
completed
:
false
}
)
)
workers
queue
}
}
}
impl
Drop
for
ShutdownTrigger
{
fn
drop
(
&
mut
self
)
{
while
!
self
.
queue
.
steal
(
)
.
is_empty
(
)
{
}
for
worker
in
self
.
workers
.
iter
(
)
{
worker
.
shutdown
(
)
;
}
let
mut
inner
=
self
.
inner
.
lock
(
)
.
unwrap
(
)
;
inner
.
completed
=
true
;
inner
.
task
.
notify
(
)
;
}
}
