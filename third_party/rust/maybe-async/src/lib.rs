extern
crate
proc_macro
;
use
proc_macro
:
:
TokenStream
;
use
proc_macro2
:
:
{
Span
TokenStream
as
TokenStream2
}
;
use
syn
:
:
{
ext
:
:
IdentExt
parenthesized
parse
:
:
{
ParseStream
Parser
}
parse_macro_input
token
Ident
ImplItem
LitStr
Meta
Result
Token
TraitItem
}
;
use
quote
:
:
quote
;
use
crate
:
:
{
parse
:
:
Item
visit
:
:
AsyncAwaitRemoval
}
;
mod
parse
;
mod
visit
;
enum
AsyncTraitMode
{
Send
NotSend
Off
}
fn
convert_async
(
input
:
&
mut
Item
async_trait_mode
:
AsyncTraitMode
)
-
>
TokenStream2
{
match
input
{
Item
:
:
Trait
(
item
)
=
>
match
async_trait_mode
{
AsyncTraitMode
:
:
Send
=
>
quote
!
(
#
[
async_trait
:
:
async_trait
]
#
item
)
AsyncTraitMode
:
:
NotSend
=
>
quote
!
(
#
[
async_trait
:
:
async_trait
(
?
Send
)
]
#
item
)
AsyncTraitMode
:
:
Off
=
>
quote
!
(
#
item
)
}
Item
:
:
Impl
(
item
)
=
>
{
let
async_trait_mode
=
item
.
trait_
.
as_ref
(
)
.
map_or
(
AsyncTraitMode
:
:
Off
|
_
|
async_trait_mode
)
;
match
async_trait_mode
{
AsyncTraitMode
:
:
Send
=
>
quote
!
(
#
[
async_trait
:
:
async_trait
]
#
item
)
AsyncTraitMode
:
:
NotSend
=
>
quote
!
(
#
[
async_trait
:
:
async_trait
(
?
Send
)
]
#
item
)
AsyncTraitMode
:
:
Off
=
>
quote
!
(
#
item
)
}
}
Item
:
:
Fn
(
item
)
=
>
quote
!
(
#
item
)
Item
:
:
Static
(
item
)
=
>
quote
!
(
#
item
)
}
}
fn
convert_sync
(
input
:
&
mut
Item
)
-
>
TokenStream2
{
match
input
{
Item
:
:
Impl
(
item
)
=
>
{
for
inner
in
&
mut
item
.
items
{
if
let
ImplItem
:
:
Fn
(
ref
mut
method
)
=
inner
{
if
method
.
sig
.
asyncness
.
is_some
(
)
{
method
.
sig
.
asyncness
=
None
;
}
}
}
AsyncAwaitRemoval
.
remove_async_await
(
quote
!
(
#
item
)
)
}
Item
:
:
Trait
(
item
)
=
>
{
for
inner
in
&
mut
item
.
items
{
if
let
TraitItem
:
:
Fn
(
ref
mut
method
)
=
inner
{
if
method
.
sig
.
asyncness
.
is_some
(
)
{
method
.
sig
.
asyncness
=
None
;
}
}
}
AsyncAwaitRemoval
.
remove_async_await
(
quote
!
(
#
item
)
)
}
Item
:
:
Fn
(
item
)
=
>
{
if
item
.
sig
.
asyncness
.
is_some
(
)
{
item
.
sig
.
asyncness
=
None
;
}
AsyncAwaitRemoval
.
remove_async_await
(
quote
!
(
#
item
)
)
}
Item
:
:
Static
(
item
)
=
>
AsyncAwaitRemoval
.
remove_async_await
(
quote
!
(
#
item
)
)
}
}
fn
async_mode
(
arg
:
&
str
)
-
>
Result
<
AsyncTraitMode
>
{
match
arg
{
"
"
|
"
Send
"
=
>
Ok
(
AsyncTraitMode
:
:
Send
)
"
?
Send
"
=
>
Ok
(
AsyncTraitMode
:
:
NotSend
)
"
AFIT
"
=
>
Ok
(
AsyncTraitMode
:
:
Off
)
_
=
>
Err
(
syn
:
:
Error
:
:
new
(
Span
:
:
call_site
(
)
"
Only
accepts
Send
?
Send
or
AFIT
(
native
async
function
in
trait
)
"
)
)
}
}
#
[
proc_macro_attribute
]
pub
fn
maybe_async
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
mode
=
match
async_mode
(
args
.
to_string
(
)
.
replace
(
"
"
"
"
)
.
as_str
(
)
)
{
Ok
(
m
)
=
>
m
Err
(
e
)
=
>
return
e
.
to_compile_error
(
)
.
into
(
)
}
;
let
mut
item
=
parse_macro_input
!
(
input
as
Item
)
;
let
token
=
if
cfg
!
(
feature
=
"
is_sync
"
)
{
convert_sync
(
&
mut
item
)
}
else
{
convert_async
(
&
mut
item
mode
)
}
;
token
.
into
(
)
}
#
[
proc_macro_attribute
]
pub
fn
must_be_async
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
mode
=
match
async_mode
(
args
.
to_string
(
)
.
replace
(
"
"
"
"
)
.
as_str
(
)
)
{
Ok
(
m
)
=
>
m
Err
(
e
)
=
>
return
e
.
to_compile_error
(
)
.
into
(
)
}
;
let
mut
item
=
parse_macro_input
!
(
input
as
Item
)
;
convert_async
(
&
mut
item
mode
)
.
into
(
)
}
#
[
proc_macro_attribute
]
pub
fn
must_be_sync
(
_args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
mut
item
=
parse_macro_input
!
(
input
as
Item
)
;
convert_sync
(
&
mut
item
)
.
into
(
)
}
#
[
proc_macro_attribute
]
pub
fn
sync_impl
(
_args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
input
=
TokenStream2
:
:
from
(
input
)
;
let
token
=
if
cfg
!
(
feature
=
"
is_sync
"
)
{
quote
!
(
#
input
)
}
else
{
quote
!
(
)
}
;
token
.
into
(
)
}
#
[
proc_macro_attribute
]
pub
fn
async_impl
(
args
:
TokenStream
_input
:
TokenStream
)
-
>
TokenStream
{
let
mode
=
match
async_mode
(
args
.
to_string
(
)
.
replace
(
"
"
"
"
)
.
as_str
(
)
)
{
Ok
(
m
)
=
>
m
Err
(
e
)
=
>
return
e
.
to_compile_error
(
)
.
into
(
)
}
;
let
token
=
if
cfg
!
(
feature
=
"
is_sync
"
)
{
quote
!
(
)
}
else
{
let
mut
item
=
parse_macro_input
!
(
_input
as
Item
)
;
convert_async
(
&
mut
item
mode
)
}
;
token
.
into
(
)
}
fn
parse_nested_meta_or_str
(
input
:
ParseStream
)
-
>
Result
<
TokenStream2
>
{
if
let
Some
(
s
)
=
input
.
parse
:
:
<
Option
<
LitStr
>
>
(
)
?
{
let
tokens
=
s
.
value
(
)
.
parse
(
)
?
;
Ok
(
tokens
)
}
else
{
let
meta
:
Meta
=
input
.
parse
(
)
?
;
Ok
(
quote
!
(
#
meta
)
)
}
}
#
[
proc_macro_attribute
]
pub
fn
test
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
match
parse_test_cfg
.
parse
(
args
)
{
Ok
(
test_cfg
)
=
>
[
test_cfg
.
into
(
)
input
]
.
into_iter
(
)
.
collect
(
)
Err
(
err
)
=
>
err
.
to_compile_error
(
)
.
into
(
)
}
}
fn
parse_test_cfg
(
input
:
ParseStream
)
-
>
Result
<
TokenStream2
>
{
if
input
.
is_empty
(
)
{
return
Err
(
syn
:
:
Error
:
:
new
(
Span
:
:
call_site
(
)
"
Arguments
cannot
be
empty
at
least
specify
the
condition
for
sync
code
"
)
)
;
}
let
sync_cond
=
input
.
call
(
parse_nested_meta_or_str
)
?
;
let
mut
ts
=
quote
!
(
#
[
cfg_attr
(
#
sync_cond
maybe_async
:
:
must_be_sync
test
)
]
)
;
let
mut
async_conditions
=
Vec
:
:
new
(
)
;
while
!
input
.
is_empty
(
)
{
input
.
parse
:
:
<
Token
!
[
]
>
(
)
?
;
if
input
.
is_empty
(
)
{
break
;
}
if
!
input
.
peek
(
Ident
:
:
peek_any
)
{
return
Err
(
input
.
error
(
"
Must
be
list
of
metas
like
:
async
(
condition
async_test_macro
)
"
)
)
;
}
let
name
=
input
.
call
(
Ident
:
:
parse_any
)
?
;
if
name
!
=
"
async
"
{
return
Err
(
syn
:
:
Error
:
:
new
(
name
.
span
(
)
format
!
(
"
Unknown
path
:
{
}
must
be
async
"
name
)
)
)
;
}
if
!
input
.
peek
(
token
:
:
Paren
)
{
return
Err
(
input
.
error
(
"
Must
be
list
of
metas
like
:
async
(
condition
async_test_macro
)
"
)
)
;
}
let
nested
;
parenthesized
!
(
nested
in
input
)
;
let
list
=
nested
.
parse_terminated
(
parse_nested_meta_or_str
Token
!
[
]
)
?
;
let
len
=
list
.
len
(
)
;
let
mut
iter
=
list
.
into_iter
(
)
;
let
(
Some
(
async_cond
)
Some
(
async_test
)
None
)
=
(
iter
.
next
(
)
iter
.
next
(
)
iter
.
next
(
)
)
else
{
let
msg
=
format
!
(
"
Must
pass
two
metas
or
string
literals
like
async
(
condition
\
async_test_macro
)
you
passed
{
len
}
metas
.
"
)
;
return
Err
(
syn
:
:
Error
:
:
new
(
name
.
span
(
)
msg
)
)
;
}
;
let
attr
=
quote
!
(
#
[
cfg_attr
(
#
async_cond
maybe_async
:
:
must_be_async
#
async_test
)
]
)
;
async_conditions
.
push
(
async_cond
)
;
ts
.
extend
(
attr
)
;
}
Ok
(
if
!
async_conditions
.
is_empty
(
)
{
quote
!
{
#
[
cfg
(
any
(
#
sync_cond
#
(
#
async_conditions
)
*
)
)
]
#
ts
}
}
else
{
quote
!
{
#
[
cfg
(
#
sync_cond
)
]
#
ts
}
}
)
}
