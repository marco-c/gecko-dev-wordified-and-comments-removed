use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
hash_map
:
:
{
Entry
HashMap
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicBool
;
use
ident_case
;
use
syn
:
:
{
self
Lit
MetaItem
NestedMetaItem
}
;
use
{
Error
Result
}
;
pub
trait
FromMetaItem
:
Sized
{
fn
from_nested_meta_item
(
item
:
&
NestedMetaItem
)
-
>
Result
<
Self
>
{
match
*
item
{
NestedMetaItem
:
:
Literal
(
ref
lit
)
=
>
Self
:
:
from_value
(
lit
)
NestedMetaItem
:
:
MetaItem
(
ref
mi
)
=
>
Self
:
:
from_meta_item
(
mi
)
}
}
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
match
*
item
{
MetaItem
:
:
Word
(
_
)
=
>
Self
:
:
from_word
(
)
MetaItem
:
:
List
(
_
ref
items
)
=
>
Self
:
:
from_list
(
items
)
MetaItem
:
:
NameValue
(
_
ref
val
)
=
>
Self
:
:
from_value
(
val
)
}
}
fn
from_word
(
)
-
>
Result
<
Self
>
{
Err
(
Error
:
:
unsupported_format
(
"
word
"
)
)
}
#
[
allow
(
unused_variables
)
]
fn
from_list
(
items
:
&
[
NestedMetaItem
]
)
-
>
Result
<
Self
>
{
Err
(
Error
:
:
unsupported_format
(
"
list
"
)
)
}
fn
from_value
(
value
:
&
Lit
)
-
>
Result
<
Self
>
{
match
*
value
{
Lit
:
:
Bool
(
ref
b
)
=
>
Self
:
:
from_bool
(
b
.
clone
(
)
)
Lit
:
:
Str
(
ref
s
_
)
=
>
Self
:
:
from_string
(
s
)
ref
_other
=
>
Err
(
Error
:
:
unexpected_type
(
"
other
"
)
)
}
}
#
[
allow
(
unused_variables
)
]
fn
from_char
(
value
:
char
)
-
>
Result
<
Self
>
{
Err
(
Error
:
:
unexpected_type
(
"
char
"
)
)
}
#
[
allow
(
unused_variables
)
]
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
Err
(
Error
:
:
unexpected_type
(
"
string
"
)
)
}
#
[
allow
(
unused_variables
)
]
fn
from_bool
(
value
:
bool
)
-
>
Result
<
Self
>
{
Err
(
Error
:
:
unexpected_type
(
"
bool
"
)
)
}
}
impl
FromMetaItem
for
(
)
{
fn
from_word
(
)
-
>
Result
<
Self
>
{
Ok
(
(
)
)
}
}
impl
FromMetaItem
for
bool
{
fn
from_word
(
)
-
>
Result
<
Self
>
{
Ok
(
true
)
}
fn
from_bool
(
value
:
bool
)
-
>
Result
<
Self
>
{
Ok
(
value
)
}
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
value
.
parse
(
)
.
or_else
(
|
_
|
Err
(
Error
:
:
unknown_value
(
value
)
)
)
}
}
impl
FromMetaItem
for
AtomicBool
{
fn
from_meta_item
(
mi
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
AtomicBool
:
:
new
(
FromMetaItem
:
:
from_meta_item
(
mi
)
?
)
)
}
}
impl
FromMetaItem
for
String
{
fn
from_string
(
s
:
&
str
)
-
>
Result
<
Self
>
{
Ok
(
s
.
to_string
(
)
)
}
}
impl
FromMetaItem
for
syn
:
:
Ident
{
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
Ok
(
syn
:
:
Ident
:
:
new
(
value
)
)
}
}
impl
FromMetaItem
for
syn
:
:
Path
{
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
syn
:
:
parse_path
(
value
)
.
or_else
(
|
_
|
Err
(
Error
:
:
unknown_value
(
value
)
)
)
}
}
impl
FromMetaItem
for
syn
:
:
TyParamBound
{
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
syn
:
:
parse_ty_param_bound
(
value
)
.
or_else
(
|
_
|
Err
(
Error
:
:
unknown_value
(
value
)
)
)
}
}
impl
FromMetaItem
for
syn
:
:
MetaItem
{
fn
from_meta_item
(
value
:
&
syn
:
:
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
value
.
clone
(
)
)
}
}
impl
FromMetaItem
for
syn
:
:
WhereClause
{
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
syn
:
:
parse_where_clause
(
value
)
.
or_else
(
|
_
|
Err
(
Error
:
:
unknown_value
(
value
)
)
)
}
}
impl
FromMetaItem
for
Vec
<
syn
:
:
WherePredicate
>
{
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
syn
:
:
WhereClause
:
:
from_string
(
&
format
!
(
"
where
{
}
"
value
)
)
.
map
(
|
c
|
c
.
predicates
)
}
}
impl
FromMetaItem
for
ident_case
:
:
RenameRule
{
fn
from_string
(
value
:
&
str
)
-
>
Result
<
Self
>
{
value
.
parse
(
)
.
or_else
(
|
_
|
Err
(
Error
:
:
unknown_value
(
value
)
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
Option
<
T
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
Some
(
FromMetaItem
:
:
from_meta_item
(
item
)
?
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
Box
<
T
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
Box
:
:
new
(
FromMetaItem
:
:
from_meta_item
(
item
)
?
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
Result
<
T
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
FromMetaItem
:
:
from_meta_item
(
item
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
:
:
std
:
:
result
:
:
Result
<
T
MetaItem
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
T
:
:
from_meta_item
(
item
)
.
map
(
Ok
)
.
or_else
(
|
_
|
Ok
(
Err
(
item
.
clone
(
)
)
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
Rc
<
T
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
Rc
:
:
new
(
FromMetaItem
:
:
from_meta_item
(
item
)
?
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
Arc
<
T
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
Arc
:
:
new
(
FromMetaItem
:
:
from_meta_item
(
item
)
?
)
)
}
}
impl
<
T
:
FromMetaItem
>
FromMetaItem
for
RefCell
<
T
>
{
fn
from_meta_item
(
item
:
&
MetaItem
)
-
>
Result
<
Self
>
{
Ok
(
RefCell
:
:
new
(
FromMetaItem
:
:
from_meta_item
(
item
)
?
)
)
}
}
impl
<
V
:
FromMetaItem
>
FromMetaItem
for
HashMap
<
String
V
>
{
fn
from_list
(
nested
:
&
[
syn
:
:
NestedMetaItem
]
)
-
>
Result
<
Self
>
{
let
mut
map
=
HashMap
:
:
with_capacity
(
nested
.
len
(
)
)
;
for
item
in
nested
{
if
let
syn
:
:
NestedMetaItem
:
:
MetaItem
(
ref
inner
)
=
*
item
{
match
map
.
entry
(
inner
.
name
(
)
.
to_string
(
)
)
{
Entry
:
:
Occupied
(
_
)
=
>
return
Err
(
Error
:
:
duplicate_field
(
inner
.
name
(
)
)
)
Entry
:
:
Vacant
(
entry
)
=
>
{
entry
.
insert
(
FromMetaItem
:
:
from_meta_item
(
inner
)
.
map_err
(
|
e
|
e
.
at
(
inner
.
name
(
)
)
)
?
)
;
}
}
}
}
Ok
(
map
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
syn
;
use
{
FromMetaItem
Result
}
;
fn
pmi
(
s
:
&
str
)
-
>
:
:
std
:
:
result
:
:
Result
<
syn
:
:
MetaItem
String
>
{
Ok
(
syn
:
:
parse_outer_attr
(
&
format
!
(
"
#
[
{
}
]
"
s
)
)
?
.
value
)
}
fn
fmi
<
T
:
FromMetaItem
>
(
s
:
&
str
)
-
>
T
{
FromMetaItem
:
:
from_meta_item
(
&
pmi
(
s
)
.
expect
(
"
Tests
should
pass
well
-
formed
input
"
)
)
.
expect
(
"
Tests
should
pass
valid
input
"
)
}
#
[
test
]
fn
unit_succeeds
(
)
{
assert_eq
!
(
fmi
:
:
<
(
)
>
(
"
ignore
"
)
(
)
)
;
}
#
[
test
]
fn
bool_succeeds
(
)
{
assert_eq
!
(
fmi
:
:
<
bool
>
(
"
ignore
"
)
true
)
;
assert_eq
!
(
fmi
:
:
<
bool
>
(
"
ignore
=
true
"
)
true
)
;
assert_eq
!
(
fmi
:
:
<
bool
>
(
"
ignore
=
false
"
)
false
)
;
assert_eq
!
(
fmi
:
:
<
bool
>
(
r
#
"
ignore
=
"
true
"
"
#
)
true
)
;
assert_eq
!
(
fmi
:
:
<
bool
>
(
r
#
"
ignore
=
"
false
"
"
#
)
false
)
;
}
#
[
test
]
fn
string_succeeds
(
)
{
assert_eq
!
(
&
fmi
:
:
<
String
>
(
r
#
"
ignore
=
"
world
"
"
#
)
"
world
"
)
;
assert_eq
!
(
&
fmi
:
:
<
String
>
(
r
#
#
"
ignore
=
r
#
"
world
"
#
"
#
#
)
"
world
"
)
;
}
#
[
test
]
fn
meta_item_succeeds
(
)
{
use
syn
:
:
MetaItem
;
assert_eq
!
(
fmi
:
:
<
MetaItem
>
(
"
hello
(
world
today
)
"
)
pmi
(
"
hello
(
world
today
)
"
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
hash_map_succeeds
(
)
{
use
std
:
:
collections
:
:
HashMap
;
let
comparison
=
{
let
mut
c
=
HashMap
:
:
new
(
)
;
c
.
insert
(
"
hello
"
.
to_string
(
)
true
)
;
c
.
insert
(
"
world
"
.
to_string
(
)
false
)
;
c
.
insert
(
"
there
"
.
to_string
(
)
true
)
;
c
}
;
assert_eq
!
(
fmi
:
:
<
HashMap
<
String
bool
>
>
(
r
#
"
ignore
(
hello
world
=
false
there
=
"
true
"
)
"
#
)
comparison
)
;
}
#
[
test
]
fn
darling_result_succeeds
(
)
{
fmi
:
:
<
Result
<
(
)
>
>
(
"
ignore
"
)
.
unwrap
(
)
;
fmi
:
:
<
Result
<
(
)
>
>
(
"
ignore
(
world
)
"
)
.
unwrap_err
(
)
;
}
}
