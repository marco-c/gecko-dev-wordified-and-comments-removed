#
!
[
warn
(
rust_2018_idioms
unused_qualifications
)
]
use
anyhow
:
:
bail
;
use
bytes
:
:
buf
:
:
Buf
;
pub
use
anyhow
:
:
Result
;
pub
mod
ffi
;
mod
ffi_converter_impls
;
pub
mod
metadata
;
pub
use
ffi
:
:
*
;
pub
use
metadata
:
:
*
;
pub
mod
deps
{
pub
use
anyhow
;
#
[
cfg
(
feature
=
"
tokio
"
)
]
pub
use
async_compat
;
pub
use
bytes
;
pub
use
log
;
pub
use
static_assertions
;
}
mod
panichook
;
const
PACKAGE_VERSION
:
&
str
=
env
!
(
"
CARGO_PKG_VERSION
"
)
;
static_assertions
:
:
const_assert
!
(
PACKAGE_VERSION
.
as_bytes
(
)
.
len
(
)
<
10
)
;
#
[
allow
(
clippy
:
:
len_zero
)
]
pub
const
fn
check_compatible_version
(
bindgen_version
:
&
'
static
str
)
-
>
bool
{
let
package_version
=
PACKAGE_VERSION
.
as_bytes
(
)
;
let
bindgen_version
=
bindgen_version
.
as_bytes
(
)
;
package_version
.
len
(
)
=
=
bindgen_version
.
len
(
)
&
&
(
package_version
.
len
(
)
=
=
0
|
|
package_version
[
0
]
=
=
bindgen_version
[
0
]
)
&
&
(
package_version
.
len
(
)
<
=
1
|
|
package_version
[
1
]
=
=
bindgen_version
[
1
]
)
&
&
(
package_version
.
len
(
)
<
=
2
|
|
package_version
[
2
]
=
=
bindgen_version
[
2
]
)
&
&
(
package_version
.
len
(
)
<
=
3
|
|
package_version
[
3
]
=
=
bindgen_version
[
3
]
)
&
&
(
package_version
.
len
(
)
<
=
4
|
|
package_version
[
4
]
=
=
bindgen_version
[
4
]
)
&
&
(
package_version
.
len
(
)
<
=
5
|
|
package_version
[
5
]
=
=
bindgen_version
[
5
]
)
&
&
(
package_version
.
len
(
)
<
=
6
|
|
package_version
[
6
]
=
=
bindgen_version
[
6
]
)
&
&
(
package_version
.
len
(
)
<
=
7
|
|
package_version
[
7
]
=
=
bindgen_version
[
7
]
)
&
&
(
package_version
.
len
(
)
<
=
8
|
|
package_version
[
8
]
=
=
bindgen_version
[
8
]
)
&
&
(
package_version
.
len
(
)
<
=
9
|
|
package_version
[
9
]
=
=
bindgen_version
[
9
]
)
&
&
package_version
.
len
(
)
<
10
}
#
[
macro_export
]
macro_rules
!
assert_compatible_version
{
(
v
:
expr
(
)
?
)
=
>
{
uniffi
:
:
deps
:
:
static_assertions
:
:
const_assert
!
(
uniffi
:
:
check_compatible_version
(
v
)
)
;
}
;
}
pub
unsafe
trait
FfiConverter
<
UT
>
:
Sized
{
type
FfiType
;
type
ReturnType
:
FfiDefault
;
type
FutureCallback
:
Copy
;
fn
lower
(
obj
:
Self
)
-
>
Self
:
:
FfiType
;
fn
lower_return
(
obj
:
Self
)
-
>
Result
<
Self
:
:
ReturnType
RustBuffer
>
;
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
Self
>
;
fn
lift_callback_return
(
buf
:
RustBuffer
)
-
>
Self
{
try_lift_from_rust_buffer
(
buf
)
.
expect
(
"
Error
reading
callback
interface
result
"
)
}
fn
lift_callback_error
(
_buf
:
RustBuffer
)
-
>
Self
{
panic
!
(
"
Callback
interface
method
returned
unexpected
error
"
)
}
fn
handle_callback_unexpected_error
(
_e
:
UnexpectedUniFFICallbackError
)
-
>
Self
{
panic
!
(
"
Callback
interface
method
returned
unexpected
error
"
)
}
fn
write
(
obj
:
Self
buf
:
&
mut
Vec
<
u8
>
)
;
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
>
;
fn
invoke_future_callback
(
callback
:
Self
:
:
FutureCallback
callback_data
:
*
const
(
)
return_value
:
Self
:
:
ReturnType
call_status
:
RustCallStatus
)
;
const
TYPE_ID_META
:
MetadataBuffer
;
}
pub
trait
Interface
<
UT
>
:
Send
+
Sync
+
Sized
{
const
NAME
:
&
'
static
str
;
}
struct
UniFfiTag
;
pub
fn
check_remaining
(
buf
:
&
[
u8
]
num_bytes
:
usize
)
-
>
Result
<
(
)
>
{
if
buf
.
remaining
(
)
<
num_bytes
{
bail
!
(
"
not
enough
bytes
remaining
in
buffer
(
{
}
<
{
num_bytes
}
)
"
buf
.
remaining
(
)
)
;
}
Ok
(
(
)
)
}
pub
fn
lower_anyhow_error_or_panic
<
UT
E
>
(
err
:
anyhow
:
:
Error
arg_name
:
&
str
)
-
>
RustBuffer
where
E
:
'
static
+
FfiConverter
<
UT
>
+
Sync
+
Send
+
std
:
:
fmt
:
:
Debug
+
std
:
:
fmt
:
:
Display
{
match
err
.
downcast
:
:
<
E
>
(
)
{
Ok
(
actual_error
)
=
>
lower_into_rust_buffer
(
actual_error
)
Err
(
ohno
)
=
>
panic
!
(
"
Failed
to
convert
arg
'
{
arg_name
}
'
:
{
ohno
}
"
)
}
}
pub
fn
lower_into_rust_buffer
<
T
:
FfiConverter
<
UT
>
UT
>
(
obj
:
T
)
-
>
RustBuffer
{
let
mut
buf
=
:
:
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
T
:
:
write
(
obj
&
mut
buf
)
;
RustBuffer
:
:
from_vec
(
buf
)
}
pub
fn
try_lift_from_rust_buffer
<
T
:
FfiConverter
<
UT
>
UT
>
(
v
:
RustBuffer
)
-
>
Result
<
T
>
{
let
vec
=
v
.
destroy_into_vec
(
)
;
let
mut
buf
=
vec
.
as_slice
(
)
;
let
value
=
T
:
:
try_read
(
&
mut
buf
)
?
;
match
Buf
:
:
remaining
(
&
buf
)
{
0
=
>
Ok
(
value
)
n
=
>
bail
!
(
"
junk
data
left
in
buffer
after
lifting
(
count
:
{
n
}
)
"
)
}
}
#
[
macro_export
]
macro_rules
!
ffi_converter_default_return
{
(
uniffi_tag
:
ty
)
=
>
{
type
ReturnType
=
<
Self
as
crate
:
:
FfiConverter
<
uniffi_tag
>
>
:
:
FfiType
;
type
FutureCallback
=
crate
:
:
FutureCallback
<
Self
:
:
ReturnType
>
;
fn
lower_return
(
v
:
Self
)
-
>
:
:
std
:
:
result
:
:
Result
<
Self
:
:
FfiType
crate
:
:
RustBuffer
>
{
Ok
(
<
Self
as
crate
:
:
FfiConverter
<
uniffi_tag
>
>
:
:
lower
(
v
)
)
}
fn
invoke_future_callback
(
callback
:
Self
:
:
FutureCallback
callback_data
:
*
const
(
)
return_value
:
Self
:
:
ReturnType
call_status
:
crate
:
:
RustCallStatus
)
{
callback
(
callback_data
return_value
call_status
)
;
}
}
;
}
#
[
macro_export
]
macro_rules
!
ffi_converter_rust_buffer_lift_and_lower
{
(
uniffi_tag
:
ty
)
=
>
{
type
FfiType
=
crate
:
:
RustBuffer
;
fn
lower
(
v
:
Self
)
-
>
crate
:
:
RustBuffer
{
crate
:
:
lower_into_rust_buffer
:
:
<
Self
uniffi_tag
>
(
v
)
}
fn
try_lift
(
buf
:
crate
:
:
RustBuffer
)
-
>
crate
:
:
Result
<
Self
>
{
crate
:
:
try_lift_from_rust_buffer
:
:
<
Self
uniffi_tag
>
(
buf
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
ffi_converter_forward
{
(
T
:
ty
existing_impl_tag
:
ty
new_impl_tag
:
ty
)
=
>
{
unsafe
impl
crate
:
:
FfiConverter
<
new_impl_tag
>
for
T
{
type
FfiType
=
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
FfiType
;
type
ReturnType
=
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
FfiType
;
type
FutureCallback
=
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
FutureCallback
;
fn
lower
(
obj
:
T
)
-
>
Self
:
:
FfiType
{
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
lower
(
obj
)
}
fn
lower_return
(
v
:
Self
)
-
>
:
:
std
:
:
result
:
:
Result
<
Self
:
:
ReturnType
crate
:
:
RustBuffer
>
{
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
lower_return
(
v
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
crate
:
:
Result
<
T
>
{
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
try_lift
(
v
)
}
fn
write
(
obj
:
T
buf
:
&
mut
Vec
<
u8
>
)
{
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
write
(
obj
buf
)
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
crate
:
:
Result
<
T
>
{
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
try_read
(
buf
)
}
fn
invoke_future_callback
(
callback
:
Self
:
:
FutureCallback
callback_data
:
*
const
(
)
return_value
:
Self
:
:
ReturnType
call_status
:
crate
:
:
RustCallStatus
)
{
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
invoke_future_callback
(
callback
callback_data
return_value
call_status
)
}
const
TYPE_ID_META
:
:
:
uniffi
:
:
MetadataBuffer
=
<
T
as
crate
:
:
FfiConverter
<
existing_impl_tag
>
>
:
:
TYPE_ID_META
;
}
}
;
}
#
[
macro_export
]
macro_rules
!
ffi_converter_trait_decl
{
(
T
:
ty
name
:
expr
uniffi_tag
:
ty
)
=
>
{
use
crate
:
:
deps
:
:
bytes
:
:
{
Buf
BufMut
}
;
unsafe
impl
crate
:
:
FfiConverter
<
uniffi_tag
>
for
std
:
:
sync
:
:
Arc
<
T
>
{
type
FfiType
=
*
const
std
:
:
os
:
:
raw
:
:
c_void
;
crate
:
:
ffi_converter_default_return
!
(
uniffi_tag
)
;
/
/
type
ReturnType
=
*
const
std
:
:
os
:
:
raw
:
:
c_void
;
fn
lower
(
obj
:
std
:
:
sync
:
:
Arc
<
T
>
)
-
>
Self
:
:
FfiType
{
Box
:
:
into_raw
(
Box
:
:
new
(
obj
)
)
as
*
const
std
:
:
os
:
:
raw
:
:
c_void
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
crate
:
:
Result
<
std
:
:
sync
:
:
Arc
<
T
>
>
{
let
foreign_arc
=
Box
:
:
leak
(
unsafe
{
Box
:
:
from_raw
(
v
as
*
mut
std
:
:
sync
:
:
Arc
<
T
>
)
}
)
;
/
/
Take
a
clone
for
our
own
use
.
Ok
(
std
:
:
sync
:
:
Arc
:
:
clone
(
foreign_arc
)
)
}
fn
write
(
obj
:
std
:
:
sync
:
:
Arc
<
T
>
buf
:
&
mut
Vec
<
u8
>
)
{
crate
:
:
deps
:
:
static_assertions
:
:
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
*
const
std
:
:
ffi
:
:
c_void
>
(
)
<
=
8
)
;
buf
.
put_u64
(
<
Self
as
crate
:
:
FfiConverter
<
uniffi_tag
>
>
:
:
lower
(
obj
)
as
u64
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
crate
:
:
Result
<
std
:
:
sync
:
:
Arc
<
T
>
>
{
crate
:
:
deps
:
:
static_assertions
:
:
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
*
const
std
:
:
ffi
:
:
c_void
>
(
)
<
=
8
)
;
crate
:
:
check_remaining
(
buf
8
)
?
;
<
Self
as
crate
:
:
FfiConverter
<
uniffi_tag
>
>
:
:
try_lift
(
buf
.
get_u64
(
)
as
Self
:
:
FfiType
)
}
const
TYPE_ID_META
:
crate
:
:
MetadataBuffer
=
crate
:
:
MetadataBuffer
:
:
from_code
(
crate
:
:
metadata
:
:
codes
:
:
TYPE_INTERFACE
)
.
concat_str
(
name
)
.
concat_bool
(
true
)
;
}
}
}
#
[
macro_export
]
macro_rules
!
ffi_converter_callback_interface
{
(
trait
:
ident
T
:
ty
name
:
expr
uniffi_tag
:
ty
)
=
>
{
unsafe
impl
:
:
uniffi
:
:
FfiConverter
<
uniffi_tag
>
for
Box
<
dyn
trait
>
{
type
FfiType
=
u64
;
/
/
Lower
and
write
are
tricky
to
implement
because
we
have
a
dyn
trait
as
our
type
.
There
'
s
/
/
probably
a
way
to
but
this
carries
lots
of
thread
safety
risks
down
to
impedance
/
/
mismatches
between
Rust
and
foreign
languages
and
our
uncertainty
around
implementations
of
/
/
concurrent
handlemaps
.
/
/
/
/
The
use
case
for
them
is
also
quite
exotic
:
it
'
s
passing
a
foreign
callback
back
to
the
foreign
/
/
language
.
/
/
/
/
Until
we
have
some
certainty
and
use
cases
we
shouldn
'
t
use
them
.
fn
lower
(
_obj
:
Box
<
dyn
trait
>
)
-
>
Self
:
:
FfiType
{
panic
!
(
"
Lowering
CallbackInterface
not
supported
"
)
}
fn
write
(
_obj
:
Box
<
dyn
trait
>
_buf
:
&
mut
std
:
:
vec
:
:
Vec
<
u8
>
)
{
panic
!
(
"
Writing
CallbackInterface
not
supported
"
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
uniffi
:
:
deps
:
:
anyhow
:
:
Result
<
Box
<
dyn
trait
>
>
{
Ok
(
Box
:
:
new
(
<
T
>
:
:
new
(
v
)
)
)
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
uniffi
:
:
deps
:
:
anyhow
:
:
Result
<
Box
<
dyn
trait
>
>
{
use
uniffi
:
:
deps
:
:
bytes
:
:
Buf
;
uniffi
:
:
check_remaining
(
buf
8
)
?
;
Self
:
:
try_lift
(
buf
.
get_u64
(
)
)
}
:
:
uniffi
:
:
ffi_converter_default_return
!
(
uniffi_tag
)
;
const
TYPE_ID_META
:
:
:
uniffi
:
:
MetadataBuffer
=
:
:
uniffi
:
:
MetadataBuffer
:
:
from_code
(
:
:
uniffi
:
:
metadata
:
:
codes
:
:
TYPE_CALLBACK_INTERFACE
)
.
concat_str
(
name
)
;
}
}
;
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
{
FfiConverter
UniFfiTag
}
;
use
std
:
:
time
:
:
{
Duration
SystemTime
}
;
#
[
test
]
fn
timestamp_roundtrip_post_epoch
(
)
{
let
expected
=
SystemTime
:
:
UNIX_EPOCH
+
Duration
:
:
new
(
100
100
)
;
let
result
=
<
SystemTime
as
FfiConverter
<
UniFfiTag
>
>
:
:
try_lift
(
<
SystemTime
as
FfiConverter
<
UniFfiTag
>
>
:
:
lower
(
expected
)
)
.
expect
(
"
Failed
to
lift
!
"
)
;
assert_eq
!
(
expected
result
)
}
#
[
test
]
fn
timestamp_roundtrip_pre_epoch
(
)
{
let
expected
=
SystemTime
:
:
UNIX_EPOCH
-
Duration
:
:
new
(
100
100
)
;
let
result
=
<
SystemTime
as
FfiConverter
<
UniFfiTag
>
>
:
:
try_lift
(
<
SystemTime
as
FfiConverter
<
UniFfiTag
>
>
:
:
lower
(
expected
)
)
.
expect
(
"
Failed
to
lift
!
"
)
;
assert_eq
!
(
expected
result
"
Expected
results
after
lowering
and
lifting
to
be
equal
"
)
}
}
