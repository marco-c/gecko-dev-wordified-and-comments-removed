use
crate
:
:
{
check_remaining
ffi_converter_default_return
ffi_converter_rust_buffer_lift_and_lower
lower_into_rust_buffer
metadata
try_lift_from_rust_buffer
FfiConverter
FutureCallback
Interface
MetadataBuffer
Result
RustBuffer
RustCallStatus
UnexpectedUniFFICallbackError
}
;
use
anyhow
:
:
bail
;
use
bytes
:
:
buf
:
:
{
Buf
BufMut
}
;
use
paste
:
:
paste
;
use
std
:
:
{
collections
:
:
HashMap
convert
:
:
{
Infallible
TryFrom
}
time
:
:
{
Duration
SystemTime
}
}
;
macro_rules
!
impl_ffi_converter_for_num_primitive
{
(
T
:
ty
type_code
:
expr
)
=
>
{
paste
!
{
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
T
{
ffi_converter_default_return
!
(
UT
)
;
type
FfiType
=
T
;
fn
lower
(
obj
:
T
)
-
>
Self
:
:
FfiType
{
obj
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
T
>
{
Ok
(
v
)
}
fn
write
(
obj
:
T
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
[
<
put_
T
>
]
(
obj
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
T
>
{
check_remaining
(
buf
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
)
?
;
Ok
(
buf
.
[
<
get_
T
>
]
(
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
type_code
)
;
}
}
}
;
}
impl_ffi_converter_for_num_primitive
!
(
u8
metadata
:
:
codes
:
:
TYPE_U8
)
;
impl_ffi_converter_for_num_primitive
!
(
i8
metadata
:
:
codes
:
:
TYPE_I8
)
;
impl_ffi_converter_for_num_primitive
!
(
u16
metadata
:
:
codes
:
:
TYPE_U16
)
;
impl_ffi_converter_for_num_primitive
!
(
i16
metadata
:
:
codes
:
:
TYPE_I16
)
;
impl_ffi_converter_for_num_primitive
!
(
u32
metadata
:
:
codes
:
:
TYPE_U32
)
;
impl_ffi_converter_for_num_primitive
!
(
i32
metadata
:
:
codes
:
:
TYPE_I32
)
;
impl_ffi_converter_for_num_primitive
!
(
u64
metadata
:
:
codes
:
:
TYPE_U64
)
;
impl_ffi_converter_for_num_primitive
!
(
i64
metadata
:
:
codes
:
:
TYPE_I64
)
;
impl_ffi_converter_for_num_primitive
!
(
f32
metadata
:
:
codes
:
:
TYPE_F32
)
;
impl_ffi_converter_for_num_primitive
!
(
f64
metadata
:
:
codes
:
:
TYPE_F64
)
;
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
bool
{
ffi_converter_default_return
!
(
UT
)
;
type
FfiType
=
i8
;
fn
lower
(
obj
:
bool
)
-
>
Self
:
:
FfiType
{
i8
:
:
from
(
obj
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
bool
>
{
Ok
(
match
v
{
0
=
>
false
1
=
>
true
_
=
>
bail
!
(
"
unexpected
byte
for
Boolean
"
)
}
)
}
fn
write
(
obj
:
bool
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
put_i8
(
<
Self
as
FfiConverter
<
UT
>
>
:
:
lower
(
obj
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
bool
>
{
check_remaining
(
buf
1
)
?
;
<
Self
as
FfiConverter
<
UT
>
>
:
:
try_lift
(
buf
.
get_i8
(
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_BOOL
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
(
)
{
type
FfiType
=
(
)
;
type
ReturnType
=
(
)
;
type
FutureCallback
=
FutureCallback
<
u8
>
;
fn
try_lift
(
_
:
Self
:
:
FfiType
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
lower
(
_
:
(
)
)
-
>
Self
:
:
FfiType
{
}
fn
write
(
_
:
(
)
_
:
&
mut
Vec
<
u8
>
)
{
}
fn
try_read
(
_
:
&
mut
&
[
u8
]
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
lower_return
(
_
:
(
)
)
-
>
Result
<
Self
:
:
ReturnType
RustBuffer
>
{
Ok
(
(
)
)
}
fn
invoke_future_callback
(
callback
:
Self
:
:
FutureCallback
callback_data
:
*
const
(
)
_return_value
:
(
)
call_status
:
RustCallStatus
)
{
callback
(
callback_data
0
call_status
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_UNIT
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
Infallible
{
ffi_converter_default_return
!
(
UT
)
;
type
FfiType
=
RustBuffer
;
fn
try_lift
(
_
:
Self
:
:
FfiType
)
-
>
Result
<
Infallible
>
{
unreachable
!
(
)
}
fn
lower
(
_
:
Infallible
)
-
>
Self
:
:
FfiType
{
unreachable
!
(
)
}
fn
write
(
_
:
Infallible
_
:
&
mut
Vec
<
u8
>
)
{
unreachable
!
(
)
}
fn
try_read
(
_
:
&
mut
&
[
u8
]
)
-
>
Result
<
Infallible
>
{
unreachable
!
(
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
new
(
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
String
{
ffi_converter_default_return
!
(
UT
)
;
type
FfiType
=
RustBuffer
;
fn
lower
(
obj
:
String
)
-
>
Self
:
:
FfiType
{
RustBuffer
:
:
from_vec
(
obj
.
into_bytes
(
)
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
String
>
{
let
v
=
v
.
destroy_into_vec
(
)
;
Ok
(
unsafe
{
String
:
:
from_utf8_unchecked
(
v
)
}
)
}
fn
write
(
obj
:
String
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
buf
.
put
(
obj
.
as_bytes
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
String
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
check_remaining
(
buf
len
)
?
;
let
bytes
=
&
buf
.
chunk
(
)
[
.
.
len
]
;
let
res
=
String
:
:
from_utf8
(
bytes
.
to_vec
(
)
)
?
;
buf
.
advance
(
len
)
;
Ok
(
res
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_STRING
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
SystemTime
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
ffi_converter_default_return
!
(
UT
)
;
fn
write
(
obj
:
SystemTime
buf
:
&
mut
Vec
<
u8
>
)
{
let
mut
sign
=
1
;
let
epoch_offset
=
obj
.
duration_since
(
SystemTime
:
:
UNIX_EPOCH
)
.
unwrap_or_else
(
|
error
|
{
sign
=
-
1
;
error
.
duration
(
)
}
)
;
let
seconds
=
sign
*
i64
:
:
try_from
(
epoch_offset
.
as_secs
(
)
)
.
expect
(
"
SystemTime
overflow
seconds
greater
than
i64
:
:
MAX
"
)
;
buf
.
put_i64
(
seconds
)
;
buf
.
put_u32
(
epoch_offset
.
subsec_nanos
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
SystemTime
>
{
check_remaining
(
buf
12
)
?
;
let
seconds
=
buf
.
get_i64
(
)
;
let
nanos
=
buf
.
get_u32
(
)
;
let
epoch_offset
=
Duration
:
:
new
(
seconds
.
wrapping_abs
(
)
as
u64
nanos
)
;
if
seconds
>
=
0
{
Ok
(
SystemTime
:
:
UNIX_EPOCH
+
epoch_offset
)
}
else
{
Ok
(
SystemTime
:
:
UNIX_EPOCH
-
epoch_offset
)
}
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_SYSTEM_TIME
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
Duration
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
ffi_converter_default_return
!
(
UT
)
;
fn
write
(
obj
:
Duration
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
put_u64
(
obj
.
as_secs
(
)
)
;
buf
.
put_u32
(
obj
.
subsec_nanos
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Duration
>
{
check_remaining
(
buf
12
)
?
;
Ok
(
Duration
:
:
new
(
buf
.
get_u64
(
)
buf
.
get_u32
(
)
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_DURATION
)
;
}
unsafe
impl
<
UT
T
:
FfiConverter
<
UT
>
>
FfiConverter
<
UT
>
for
Option
<
T
>
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
ffi_converter_default_return
!
(
UT
)
;
fn
write
(
obj
:
Option
<
T
>
buf
:
&
mut
Vec
<
u8
>
)
{
match
obj
{
None
=
>
buf
.
put_i8
(
0
)
Some
(
v
)
=
>
{
buf
.
put_i8
(
1
)
;
T
:
:
write
(
v
buf
)
;
}
}
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Option
<
T
>
>
{
check_remaining
(
buf
1
)
?
;
Ok
(
match
buf
.
get_i8
(
)
{
0
=
>
None
1
=
>
Some
(
T
:
:
try_read
(
buf
)
?
)
_
=
>
bail
!
(
"
unexpected
tag
byte
for
Option
"
)
}
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_OPTION
)
.
concat
(
T
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
UT
T
:
FfiConverter
<
UT
>
>
FfiConverter
<
UT
>
for
Vec
<
T
>
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
ffi_converter_default_return
!
(
UT
)
;
fn
write
(
obj
:
Vec
<
T
>
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
for
item
in
obj
{
<
T
as
FfiConverter
<
UT
>
>
:
:
write
(
item
buf
)
;
}
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Vec
<
T
>
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
let
mut
vec
=
Vec
:
:
with_capacity
(
len
)
;
for
_
in
0
.
.
len
{
vec
.
push
(
<
T
as
FfiConverter
<
UT
>
>
:
:
try_read
(
buf
)
?
)
}
Ok
(
vec
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_VEC
)
.
concat
(
T
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
K
V
UT
>
FfiConverter
<
UT
>
for
HashMap
<
K
V
>
where
K
:
FfiConverter
<
UT
>
+
std
:
:
hash
:
:
Hash
+
Eq
V
:
FfiConverter
<
UT
>
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
ffi_converter_default_return
!
(
UT
)
;
fn
write
(
obj
:
HashMap
<
K
V
>
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
for
(
key
value
)
in
obj
{
<
K
as
FfiConverter
<
UT
>
>
:
:
write
(
key
buf
)
;
<
V
as
FfiConverter
<
UT
>
>
:
:
write
(
value
buf
)
;
}
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
HashMap
<
K
V
>
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
let
mut
map
=
HashMap
:
:
with_capacity
(
len
)
;
for
_
in
0
.
.
len
{
let
key
=
<
K
as
FfiConverter
<
UT
>
>
:
:
try_read
(
buf
)
?
;
let
value
=
<
V
as
FfiConverter
<
UT
>
>
:
:
try_read
(
buf
)
?
;
map
.
insert
(
key
value
)
;
}
Ok
(
map
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_HASH_MAP
)
.
concat
(
K
:
:
TYPE_ID_META
)
.
concat
(
V
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
UT
T
:
Interface
<
UT
>
>
FfiConverter
<
UT
>
for
std
:
:
sync
:
:
Arc
<
T
>
{
type
FfiType
=
*
const
std
:
:
os
:
:
raw
:
:
c_void
;
fn
lower
(
obj
:
std
:
:
sync
:
:
Arc
<
T
>
)
-
>
Self
:
:
FfiType
{
std
:
:
sync
:
:
Arc
:
:
into_raw
(
obj
)
as
Self
:
:
FfiType
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
std
:
:
sync
:
:
Arc
<
T
>
>
{
let
v
=
v
as
*
const
T
;
let
foreign_arc
=
std
:
:
mem
:
:
ManuallyDrop
:
:
new
(
unsafe
{
std
:
:
sync
:
:
Arc
:
:
<
T
>
:
:
from_raw
(
v
)
}
)
;
Ok
(
std
:
:
sync
:
:
Arc
:
:
clone
(
&
*
foreign_arc
)
)
}
fn
write
(
obj
:
std
:
:
sync
:
:
Arc
<
T
>
buf
:
&
mut
Vec
<
u8
>
)
{
static_assertions
:
:
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
*
const
std
:
:
ffi
:
:
c_void
>
(
)
<
=
8
)
;
buf
.
put_u64
(
<
Self
as
FfiConverter
<
UT
>
>
:
:
lower
(
obj
)
as
u64
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
std
:
:
sync
:
:
Arc
<
T
>
>
{
static_assertions
:
:
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
*
const
std
:
:
ffi
:
:
c_void
>
(
)
<
=
8
)
;
check_remaining
(
buf
8
)
?
;
<
Self
as
FfiConverter
<
UT
>
>
:
:
try_lift
(
buf
.
get_u64
(
)
as
Self
:
:
FfiType
)
}
ffi_converter_default_return
!
(
UT
)
;
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_INTERFACE
)
.
concat_str
(
T
:
:
NAME
)
.
concat_bool
(
false
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
crate
:
:
ForeignExecutor
{
type
FfiType
=
crate
:
:
ForeignExecutorHandle
;
fn
lower
(
executor
:
Self
)
-
>
Self
:
:
FfiType
{
executor
.
handle
}
fn
write
(
executor
:
Self
buf
:
&
mut
Vec
<
u8
>
)
{
match
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
{
4
=
>
buf
.
put_u32_ne
(
executor
.
handle
.
0
as
u32
)
8
=
>
buf
.
put_u64_ne
(
executor
.
handle
.
0
as
u64
)
n
=
>
panic
!
(
"
Invalid
usize
width
:
{
n
}
"
)
}
;
}
fn
try_lift
(
executor
:
Self
:
:
FfiType
)
-
>
Result
<
Self
>
{
Ok
(
crate
:
:
ForeignExecutor
:
:
new
(
executor
)
)
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
>
{
let
usize_val
=
match
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
{
4
=
>
buf
.
get_u32_ne
(
)
as
usize
8
=
>
buf
.
get_u64_ne
(
)
as
usize
n
=
>
panic
!
(
"
Invalid
usize
width
:
{
n
}
"
)
}
;
<
Self
as
FfiConverter
<
UT
>
>
:
:
try_lift
(
crate
:
:
ForeignExecutorHandle
(
usize_val
as
*
const
(
)
)
)
}
ffi_converter_default_return
!
(
UT
)
;
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_FOREIGN_EXECUTOR
)
;
}
unsafe
impl
<
UT
R
E
>
FfiConverter
<
UT
>
for
Result
<
R
E
>
where
R
:
FfiConverter
<
UT
>
E
:
FfiConverter
<
UT
>
{
type
FfiType
=
(
)
;
type
ReturnType
=
R
:
:
ReturnType
;
type
FutureCallback
=
R
:
:
FutureCallback
;
fn
try_lift
(
_
:
Self
:
:
FfiType
)
-
>
Result
<
Self
>
{
unimplemented
!
(
"
try_lift
"
)
;
}
fn
lower
(
_
:
Self
)
-
>
Self
:
:
FfiType
{
unimplemented
!
(
"
lower
"
)
;
}
fn
write
(
_
:
Self
_
:
&
mut
Vec
<
u8
>
)
{
unimplemented
!
(
"
write
"
)
;
}
fn
try_read
(
_
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
>
{
unimplemented
!
(
"
try_read
"
)
;
}
fn
lower_return
(
v
:
Self
)
-
>
Result
<
Self
:
:
ReturnType
RustBuffer
>
{
match
v
{
Ok
(
r
)
=
>
R
:
:
lower_return
(
r
)
Err
(
e
)
=
>
Err
(
lower_into_rust_buffer
(
e
)
)
}
}
fn
lift_callback_return
(
buf
:
RustBuffer
)
-
>
Self
{
Ok
(
try_lift_from_rust_buffer
:
:
<
R
UT
>
(
buf
)
.
expect
(
"
Error
reading
callback
interface
result
"
)
)
}
fn
lift_callback_error
(
buf
:
RustBuffer
)
-
>
Self
{
Err
(
try_lift_from_rust_buffer
:
:
<
E
UT
>
(
buf
)
.
expect
(
"
Error
reading
callback
interface
Err
result
"
)
)
}
fn
handle_callback_unexpected_error
(
e
:
UnexpectedUniFFICallbackError
)
-
>
Self
{
Err
(
E
:
:
handle_callback_unexpected_error
(
e
)
)
}
fn
invoke_future_callback
(
callback
:
Self
:
:
FutureCallback
callback_data
:
*
const
(
)
return_value
:
Self
:
:
ReturnType
call_status
:
RustCallStatus
)
{
R
:
:
invoke_future_callback
(
callback
callback_data
return_value
call_status
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_RESULT
)
.
concat
(
R
:
:
TYPE_ID_META
)
.
concat
(
E
:
:
TYPE_ID_META
)
;
}
