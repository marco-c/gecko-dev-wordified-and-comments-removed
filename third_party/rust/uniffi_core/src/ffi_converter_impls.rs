use
crate
:
:
{
check_remaining
derive_ffi_traits
ffi_converter_rust_buffer_lift_and_lower
metadata
ConvertError
FfiConverter
Lift
LiftRef
LiftReturn
Lower
LowerReturn
MetadataBuffer
Result
RustBuffer
UnexpectedUniFFICallbackError
}
;
use
anyhow
:
:
bail
;
use
bytes
:
:
buf
:
:
{
Buf
BufMut
}
;
use
paste
:
:
paste
;
use
std
:
:
{
collections
:
:
HashMap
convert
:
:
TryFrom
error
:
:
Error
sync
:
:
Arc
time
:
:
{
Duration
SystemTime
}
}
;
macro_rules
!
impl_ffi_converter_for_num_primitive
{
(
T
:
ty
type_code
:
expr
)
=
>
{
paste
!
{
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
T
{
type
FfiType
=
T
;
fn
lower
(
obj
:
T
)
-
>
Self
:
:
FfiType
{
obj
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
T
>
{
Ok
(
v
)
}
fn
write
(
obj
:
T
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
[
<
put_
T
>
]
(
obj
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
T
>
{
check_remaining
(
buf
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
)
?
;
Ok
(
buf
.
[
<
get_
T
>
]
(
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
type_code
)
;
}
}
}
;
}
impl_ffi_converter_for_num_primitive
!
(
u8
metadata
:
:
codes
:
:
TYPE_U8
)
;
impl_ffi_converter_for_num_primitive
!
(
i8
metadata
:
:
codes
:
:
TYPE_I8
)
;
impl_ffi_converter_for_num_primitive
!
(
u16
metadata
:
:
codes
:
:
TYPE_U16
)
;
impl_ffi_converter_for_num_primitive
!
(
i16
metadata
:
:
codes
:
:
TYPE_I16
)
;
impl_ffi_converter_for_num_primitive
!
(
u32
metadata
:
:
codes
:
:
TYPE_U32
)
;
impl_ffi_converter_for_num_primitive
!
(
i32
metadata
:
:
codes
:
:
TYPE_I32
)
;
impl_ffi_converter_for_num_primitive
!
(
u64
metadata
:
:
codes
:
:
TYPE_U64
)
;
impl_ffi_converter_for_num_primitive
!
(
i64
metadata
:
:
codes
:
:
TYPE_I64
)
;
impl_ffi_converter_for_num_primitive
!
(
f32
metadata
:
:
codes
:
:
TYPE_F32
)
;
impl_ffi_converter_for_num_primitive
!
(
f64
metadata
:
:
codes
:
:
TYPE_F64
)
;
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
bool
{
type
FfiType
=
i8
;
fn
lower
(
obj
:
bool
)
-
>
Self
:
:
FfiType
{
i8
:
:
from
(
obj
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
bool
>
{
Ok
(
match
v
{
0
=
>
false
1
=
>
true
_
=
>
bail
!
(
"
unexpected
byte
for
Boolean
"
)
}
)
}
fn
write
(
obj
:
bool
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
put_i8
(
<
Self
as
FfiConverter
<
UT
>
>
:
:
lower
(
obj
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
bool
>
{
check_remaining
(
buf
1
)
?
;
<
Self
as
FfiConverter
<
UT
>
>
:
:
try_lift
(
buf
.
get_i8
(
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_BOOL
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
String
{
type
FfiType
=
RustBuffer
;
fn
lower
(
obj
:
String
)
-
>
Self
:
:
FfiType
{
RustBuffer
:
:
from_vec
(
obj
.
into_bytes
(
)
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
String
>
{
let
v
=
v
.
destroy_into_vec
(
)
;
Ok
(
unsafe
{
String
:
:
from_utf8_unchecked
(
v
)
}
)
}
fn
write
(
obj
:
String
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
buf
.
put
(
obj
.
as_bytes
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
String
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
check_remaining
(
buf
len
)
?
;
let
bytes
=
&
buf
.
chunk
(
)
[
.
.
len
]
;
let
res
=
String
:
:
from_utf8
(
bytes
.
to_vec
(
)
)
?
;
buf
.
advance
(
len
)
;
Ok
(
res
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_STRING
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
SystemTime
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
fn
write
(
obj
:
SystemTime
buf
:
&
mut
Vec
<
u8
>
)
{
let
mut
sign
=
1
;
let
epoch_offset
=
obj
.
duration_since
(
SystemTime
:
:
UNIX_EPOCH
)
.
unwrap_or_else
(
|
error
|
{
sign
=
-
1
;
error
.
duration
(
)
}
)
;
let
seconds
=
sign
*
i64
:
:
try_from
(
epoch_offset
.
as_secs
(
)
)
.
expect
(
"
SystemTime
overflow
seconds
greater
than
i64
:
:
MAX
"
)
;
buf
.
put_i64
(
seconds
)
;
buf
.
put_u32
(
epoch_offset
.
subsec_nanos
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
SystemTime
>
{
check_remaining
(
buf
12
)
?
;
let
seconds
=
buf
.
get_i64
(
)
;
let
nanos
=
buf
.
get_u32
(
)
;
let
epoch_offset
=
Duration
:
:
new
(
seconds
.
wrapping_abs
(
)
as
u64
nanos
)
;
if
seconds
>
=
0
{
Ok
(
SystemTime
:
:
UNIX_EPOCH
+
epoch_offset
)
}
else
{
Ok
(
SystemTime
:
:
UNIX_EPOCH
-
epoch_offset
)
}
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_SYSTEM_TIME
)
;
}
unsafe
impl
<
UT
>
FfiConverter
<
UT
>
for
Duration
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UT
)
;
fn
write
(
obj
:
Duration
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
put_u64
(
obj
.
as_secs
(
)
)
;
buf
.
put_u32
(
obj
.
subsec_nanos
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Duration
>
{
check_remaining
(
buf
12
)
?
;
Ok
(
Duration
:
:
new
(
buf
.
get_u64
(
)
buf
.
get_u32
(
)
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_DURATION
)
;
}
unsafe
impl
<
UT
T
:
Lower
<
UT
>
>
Lower
<
UT
>
for
Option
<
T
>
{
type
FfiType
=
RustBuffer
;
fn
write
(
obj
:
Option
<
T
>
buf
:
&
mut
Vec
<
u8
>
)
{
match
obj
{
None
=
>
buf
.
put_i8
(
0
)
Some
(
v
)
=
>
{
buf
.
put_i8
(
1
)
;
T
:
:
write
(
v
buf
)
;
}
}
}
fn
lower
(
obj
:
Option
<
T
>
)
-
>
RustBuffer
{
Self
:
:
lower_into_rust_buffer
(
obj
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_OPTION
)
.
concat
(
T
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
UT
T
:
Lift
<
UT
>
>
Lift
<
UT
>
for
Option
<
T
>
{
type
FfiType
=
RustBuffer
;
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Option
<
T
>
>
{
check_remaining
(
buf
1
)
?
;
Ok
(
match
buf
.
get_i8
(
)
{
0
=
>
None
1
=
>
Some
(
T
:
:
try_read
(
buf
)
?
)
_
=
>
bail
!
(
"
unexpected
tag
byte
for
Option
"
)
}
)
}
fn
try_lift
(
buf
:
RustBuffer
)
-
>
Result
<
Option
<
T
>
>
{
Self
:
:
try_lift_from_rust_buffer
(
buf
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_OPTION
)
.
concat
(
T
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
UT
T
:
Lower
<
UT
>
>
Lower
<
UT
>
for
Vec
<
T
>
{
type
FfiType
=
RustBuffer
;
fn
write
(
obj
:
Vec
<
T
>
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
for
item
in
obj
{
<
T
as
Lower
<
UT
>
>
:
:
write
(
item
buf
)
;
}
}
fn
lower
(
obj
:
Vec
<
T
>
)
-
>
RustBuffer
{
Self
:
:
lower_into_rust_buffer
(
obj
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_VEC
)
.
concat
(
T
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
UT
T
:
Lift
<
UT
>
>
Lift
<
UT
>
for
Vec
<
T
>
{
type
FfiType
=
RustBuffer
;
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Vec
<
T
>
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
let
mut
vec
=
Vec
:
:
with_capacity
(
len
)
;
for
_
in
0
.
.
len
{
vec
.
push
(
<
T
as
Lift
<
UT
>
>
:
:
try_read
(
buf
)
?
)
}
Ok
(
vec
)
}
fn
try_lift
(
buf
:
RustBuffer
)
-
>
Result
<
Vec
<
T
>
>
{
Self
:
:
try_lift_from_rust_buffer
(
buf
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_VEC
)
.
concat
(
T
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
K
V
UT
>
Lower
<
UT
>
for
HashMap
<
K
V
>
where
K
:
Lower
<
UT
>
+
std
:
:
hash
:
:
Hash
+
Eq
V
:
Lower
<
UT
>
{
type
FfiType
=
RustBuffer
;
fn
write
(
obj
:
HashMap
<
K
V
>
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
for
(
key
value
)
in
obj
{
<
K
as
Lower
<
UT
>
>
:
:
write
(
key
buf
)
;
<
V
as
Lower
<
UT
>
>
:
:
write
(
value
buf
)
;
}
}
fn
lower
(
obj
:
HashMap
<
K
V
>
)
-
>
RustBuffer
{
Self
:
:
lower_into_rust_buffer
(
obj
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_HASH_MAP
)
.
concat
(
K
:
:
TYPE_ID_META
)
.
concat
(
V
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
K
V
UT
>
Lift
<
UT
>
for
HashMap
<
K
V
>
where
K
:
Lift
<
UT
>
+
std
:
:
hash
:
:
Hash
+
Eq
V
:
Lift
<
UT
>
{
type
FfiType
=
RustBuffer
;
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
HashMap
<
K
V
>
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
let
mut
map
=
HashMap
:
:
with_capacity
(
len
)
;
for
_
in
0
.
.
len
{
let
key
=
<
K
as
Lift
<
UT
>
>
:
:
try_read
(
buf
)
?
;
let
value
=
<
V
as
Lift
<
UT
>
>
:
:
try_read
(
buf
)
?
;
map
.
insert
(
key
value
)
;
}
Ok
(
map
)
}
fn
try_lift
(
buf
:
RustBuffer
)
-
>
Result
<
HashMap
<
K
V
>
>
{
Self
:
:
try_lift_from_rust_buffer
(
buf
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_HASH_MAP
)
.
concat
(
K
:
:
TYPE_ID_META
)
.
concat
(
V
:
:
TYPE_ID_META
)
;
}
derive_ffi_traits
!
(
blanket
u8
)
;
derive_ffi_traits
!
(
blanket
i8
)
;
derive_ffi_traits
!
(
blanket
u16
)
;
derive_ffi_traits
!
(
blanket
i16
)
;
derive_ffi_traits
!
(
blanket
u32
)
;
derive_ffi_traits
!
(
blanket
i32
)
;
derive_ffi_traits
!
(
blanket
u64
)
;
derive_ffi_traits
!
(
blanket
i64
)
;
derive_ffi_traits
!
(
blanket
f32
)
;
derive_ffi_traits
!
(
blanket
f64
)
;
derive_ffi_traits
!
(
blanket
bool
)
;
derive_ffi_traits
!
(
blanket
String
)
;
derive_ffi_traits
!
(
blanket
Duration
)
;
derive_ffi_traits
!
(
blanket
SystemTime
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LowerReturn
<
UT
>
for
Option
<
T
>
where
Option
<
T
>
:
Lower
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LiftReturn
<
UT
>
for
Option
<
T
>
where
Option
<
T
>
:
Lift
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LiftRef
<
UT
>
for
Option
<
T
>
where
Option
<
T
>
:
Lift
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LowerReturn
<
UT
>
for
Vec
<
T
>
where
Vec
<
T
>
:
Lower
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LiftReturn
<
UT
>
for
Vec
<
T
>
where
Vec
<
T
>
:
Lift
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LiftRef
<
UT
>
for
Vec
<
T
>
where
Vec
<
T
>
:
Lift
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
K
V
UT
>
LowerReturn
<
UT
>
for
HashMap
<
K
V
>
where
HashMap
<
K
V
>
:
Lower
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
K
V
UT
>
LiftReturn
<
UT
>
for
HashMap
<
K
V
>
where
HashMap
<
K
V
>
:
Lift
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
K
V
UT
>
LiftRef
<
UT
>
for
HashMap
<
K
V
>
where
HashMap
<
K
V
>
:
Lift
<
UT
>
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
Lower
<
UT
>
for
Arc
<
T
>
where
Arc
<
T
>
:
FfiConverter
<
UT
>
T
:
?
Sized
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
Lift
<
UT
>
for
Arc
<
T
>
where
Arc
<
T
>
:
FfiConverter
<
UT
>
T
:
?
Sized
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LowerReturn
<
UT
>
for
Arc
<
T
>
where
Arc
<
T
>
:
Lower
<
UT
>
T
:
?
Sized
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LiftReturn
<
UT
>
for
Arc
<
T
>
where
Arc
<
T
>
:
Lift
<
UT
>
T
:
?
Sized
)
;
derive_ffi_traits
!
(
impl
<
T
UT
>
LiftRef
<
UT
>
for
Arc
<
T
>
where
Arc
<
T
>
:
Lift
<
UT
>
T
:
?
Sized
)
;
unsafe
impl
<
UT
>
LowerReturn
<
UT
>
for
(
)
{
type
ReturnType
=
(
)
;
fn
lower_return
(
_
:
(
)
)
-
>
Result
<
Self
:
:
ReturnType
RustBuffer
>
{
Ok
(
(
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_UNIT
)
;
}
unsafe
impl
<
UT
>
LiftReturn
<
UT
>
for
(
)
{
type
ReturnType
=
(
)
;
fn
try_lift_successful_return
(
_
:
(
)
)
-
>
Result
<
Self
>
{
Ok
(
(
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_UNIT
)
;
}
unsafe
impl
<
UT
R
E
>
LowerReturn
<
UT
>
for
Result
<
R
E
>
where
R
:
LowerReturn
<
UT
>
E
:
Lower
<
UT
>
+
Error
+
Send
+
Sync
+
'
static
{
type
ReturnType
=
R
:
:
ReturnType
;
fn
lower_return
(
v
:
Self
)
-
>
Result
<
Self
:
:
ReturnType
RustBuffer
>
{
match
v
{
Ok
(
r
)
=
>
R
:
:
lower_return
(
r
)
Err
(
e
)
=
>
Err
(
E
:
:
lower_into_rust_buffer
(
e
)
)
}
}
fn
handle_failed_lift
(
arg_name
:
&
str
err
:
anyhow
:
:
Error
)
-
>
Self
{
match
err
.
downcast
:
:
<
E
>
(
)
{
Ok
(
actual_error
)
=
>
Err
(
actual_error
)
Err
(
ohno
)
=
>
panic
!
(
"
Failed
to
convert
arg
'
{
arg_name
}
'
:
{
ohno
}
"
)
}
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_RESULT
)
.
concat
(
R
:
:
TYPE_ID_META
)
.
concat
(
E
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
UT
R
E
>
LiftReturn
<
UT
>
for
Result
<
R
E
>
where
R
:
LiftReturn
<
UT
>
E
:
Lift
<
UT
FfiType
=
RustBuffer
>
+
ConvertError
<
UT
>
{
type
ReturnType
=
R
:
:
ReturnType
;
fn
try_lift_successful_return
(
v
:
R
:
:
ReturnType
)
-
>
Result
<
Self
>
{
R
:
:
try_lift_successful_return
(
v
)
.
map
(
Ok
)
}
fn
lift_error
(
buf
:
RustBuffer
)
-
>
Self
{
match
E
:
:
try_lift_from_rust_buffer
(
buf
)
{
Ok
(
lifted_error
)
=
>
Err
(
lifted_error
)
Err
(
anyhow_error
)
=
>
{
Self
:
:
handle_callback_unexpected_error
(
UnexpectedUniFFICallbackError
{
reason
:
format
!
(
"
Error
lifting
from
rust
buffer
:
{
anyhow_error
}
"
)
}
)
}
}
}
fn
handle_callback_unexpected_error
(
e
:
UnexpectedUniFFICallbackError
)
-
>
Self
{
Err
(
E
:
:
try_convert_unexpected_callback_error
(
e
)
.
unwrap_or_else
(
|
e
|
panic
!
(
"
{
e
}
"
)
)
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
from_code
(
metadata
:
:
codes
:
:
TYPE_RESULT
)
.
concat
(
R
:
:
TYPE_ID_META
)
.
concat
(
E
:
:
TYPE_ID_META
)
;
}
unsafe
impl
<
T
UT
>
LiftRef
<
UT
>
for
[
T
]
where
T
:
Lift
<
UT
>
{
type
LiftType
=
Vec
<
T
>
;
}
unsafe
impl
<
UT
>
LiftRef
<
UT
>
for
str
{
type
LiftType
=
String
;
}
