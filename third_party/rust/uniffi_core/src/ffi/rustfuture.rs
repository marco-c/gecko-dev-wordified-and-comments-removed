use
crate
:
:
{
rust_call_with_out_status
schedule_raw
FfiConverter
FfiDefault
ForeignExecutor
ForeignExecutorHandle
RustCallStatus
}
;
use
std
:
:
{
cell
:
:
UnsafeCell
future
:
:
Future
panic
pin
:
:
Pin
sync
:
:
{
atomic
:
:
{
AtomicU32
Ordering
}
Arc
}
task
:
:
{
Context
Poll
RawWaker
RawWakerVTable
Waker
}
}
;
pub
type
FutureCallback
<
T
>
=
extern
"
C
"
fn
(
callback_data
:
*
const
(
)
result
:
T
status
:
RustCallStatus
)
;
pub
struct
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
T
>
+
Send
T
:
FfiConverter
<
UT
>
{
future
:
UnsafeCell
<
F
>
executor
:
ForeignExecutor
wake_counter
:
AtomicU32
callback
:
T
:
:
FutureCallback
callback_data
:
*
const
(
)
}
unsafe
impl
<
F
T
UT
>
Send
for
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
T
>
+
Send
T
:
FfiConverter
<
UT
>
{
}
unsafe
impl
<
F
T
UT
>
Sync
for
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
T
>
+
Send
T
:
FfiConverter
<
UT
>
{
}
impl
<
F
T
UT
>
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
T
>
+
Send
T
:
FfiConverter
<
UT
>
{
pub
fn
new
(
future
:
F
executor_handle
:
ForeignExecutorHandle
callback
:
T
:
:
FutureCallback
callback_data
:
*
const
(
)
)
-
>
Pin
<
Arc
<
Self
>
>
{
let
executor
=
<
ForeignExecutor
as
FfiConverter
<
crate
:
:
UniFfiTag
>
>
:
:
try_lift
(
executor_handle
)
.
expect
(
"
Error
lifting
ForeignExecutorHandle
"
)
;
Arc
:
:
pin
(
Self
{
future
:
UnsafeCell
:
:
new
(
future
)
wake_counter
:
AtomicU32
:
:
new
(
0
)
executor
callback
callback_data
}
)
}
pub
fn
wake
(
self
:
Pin
<
Arc
<
Self
>
>
)
{
if
self
.
wake_counter
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
=
=
0
{
self
.
schedule_do_wake
(
)
;
}
}
fn
schedule_do_wake
(
self
:
Pin
<
Arc
<
Self
>
>
)
{
unsafe
{
let
handle
=
self
.
executor
.
handle
;
let
raw_ptr
=
Arc
:
:
into_raw
(
Pin
:
:
into_inner_unchecked
(
self
)
)
as
*
const
(
)
;
schedule_raw
(
handle
0
Self
:
:
wake_callback
raw_ptr
)
;
}
}
extern
"
C
"
fn
wake_callback
(
self_ptr
:
*
const
(
)
)
{
unsafe
{
Pin
:
:
new_unchecked
(
Arc
:
:
from_raw
(
self_ptr
as
*
const
Self
)
)
.
do_wake
(
)
;
}
;
}
fn
do_wake
(
self
:
Pin
<
Arc
<
Self
>
>
)
{
self
.
wake_counter
.
store
(
1
Ordering
:
:
Relaxed
)
;
let
future
=
unsafe
{
Pin
:
:
new_unchecked
(
&
mut
*
self
.
future
.
get
(
)
)
}
;
let
waker
=
self
.
make_waker
(
)
;
let
mut
out_status
=
RustCallStatus
:
:
default
(
)
;
let
result
:
Option
<
Poll
<
T
:
:
ReturnType
>
>
=
rust_call_with_out_status
(
&
mut
out_status
panic
:
:
AssertUnwindSafe
(
|
|
match
future
.
poll
(
&
mut
Context
:
:
from_waker
(
&
waker
)
)
{
Poll
:
:
Pending
=
>
Ok
(
Poll
:
:
Pending
)
Poll
:
:
Ready
(
v
)
=
>
T
:
:
lower_return
(
v
)
.
map
(
Poll
:
:
Ready
)
}
)
)
;
match
result
{
Some
(
Poll
:
:
Pending
)
=
>
{
if
self
.
wake_counter
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
>
1
{
self
.
schedule_do_wake
(
)
;
}
}
Some
(
Poll
:
:
Ready
(
v
)
)
=
>
{
T
:
:
invoke_future_callback
(
self
.
callback
self
.
callback_data
v
out_status
)
;
}
None
=
>
{
T
:
:
invoke_future_callback
(
self
.
callback
self
.
callback_data
T
:
:
ReturnType
:
:
ffi_default
(
)
out_status
)
;
}
}
;
}
fn
make_waker
(
self
:
&
Pin
<
Arc
<
Self
>
>
)
-
>
Waker
{
unsafe
{
Waker
:
:
from_raw
(
RawWaker
:
:
new
(
self
.
clone
(
)
.
into_raw
(
)
&
Self
:
:
RAW_WAKER_VTABLE
)
)
}
}
fn
into_raw
(
self
:
Pin
<
Arc
<
Self
>
>
)
-
>
*
const
(
)
{
unsafe
{
Arc
:
:
into_raw
(
Pin
:
:
into_inner_unchecked
(
self
)
)
as
*
const
(
)
}
}
fn
from_raw
(
self_ptr
:
*
const
(
)
)
-
>
Pin
<
Arc
<
Self
>
>
{
unsafe
{
Pin
:
:
new_unchecked
(
Arc
:
:
from_raw
(
self_ptr
as
*
const
Self
)
)
}
}
const
RAW_WAKER_VTABLE
:
RawWakerVTable
=
RawWakerVTable
:
:
new
(
Self
:
:
raw_clone
Self
:
:
raw_wake
Self
:
:
raw_wake_by_ref
Self
:
:
raw_drop
)
;
unsafe
fn
raw_clone
(
self_ptr
:
*
const
(
)
)
-
>
RawWaker
{
Arc
:
:
increment_strong_count
(
self_ptr
as
*
const
Self
)
;
RawWaker
:
:
new
(
self_ptr
&
Self
:
:
RAW_WAKER_VTABLE
)
}
unsafe
fn
raw_wake
(
self_ptr
:
*
const
(
)
)
{
Self
:
:
from_raw
(
self_ptr
)
.
wake
(
)
}
unsafe
fn
raw_wake_by_ref
(
self_ptr
:
*
const
(
)
)
{
Arc
:
:
increment_strong_count
(
self_ptr
as
*
const
Self
)
;
Self
:
:
from_raw
(
self_ptr
)
.
wake
(
)
}
unsafe
fn
raw_drop
(
self_ptr
:
*
const
(
)
)
{
drop
(
Self
:
:
from_raw
(
self_ptr
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
{
try_lift_from_rust_buffer
MockExecutor
}
;
use
std
:
:
sync
:
:
Weak
;
struct
MockFuture
(
Option
<
Result
<
bool
String
>
>
)
;
impl
Future
for
MockFuture
{
type
Output
=
Result
<
bool
String
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
_context
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
match
&
self
.
0
{
Some
(
v
)
=
>
Poll
:
:
Ready
(
v
.
clone
(
)
)
None
=
>
Poll
:
:
Pending
}
}
}
type
TestRustFuture
=
RustFuture
<
MockFuture
Result
<
bool
String
>
crate
:
:
UniFfiTag
>
;
#
[
derive
(
Default
)
]
struct
MockForeignResult
{
value
:
i8
status
:
RustCallStatus
}
extern
"
C
"
fn
mock_foreign_callback
(
data_ptr
:
*
const
(
)
value
:
i8
status
:
RustCallStatus
)
{
println
!
(
"
mock_foreign_callback
:
{
value
}
{
data_ptr
:
?
}
"
)
;
let
result
:
&
mut
Option
<
MockForeignResult
>
=
unsafe
{
&
mut
*
(
data_ptr
as
*
mut
Option
<
MockForeignResult
>
)
}
;
*
result
=
Some
(
MockForeignResult
{
value
status
}
)
;
}
struct
TestFutureEnvironment
{
rust_future
:
Pin
<
Arc
<
TestRustFuture
>
>
executor
:
MockExecutor
foreign_result
:
Pin
<
Box
<
Option
<
MockForeignResult
>
>
>
}
impl
TestFutureEnvironment
{
fn
new
(
)
-
>
Self
{
let
foreign_result
=
Box
:
:
pin
(
None
)
;
let
foreign_result_ptr
=
&
*
foreign_result
as
*
const
Option
<
_
>
as
*
const
(
)
;
let
executor
=
MockExecutor
:
:
new
(
)
;
let
rust_future
=
TestRustFuture
:
:
new
(
MockFuture
(
None
)
executor
.
handle
(
)
.
unwrap
(
)
mock_foreign_callback
foreign_result_ptr
)
;
Self
{
executor
rust_future
foreign_result
}
}
fn
scheduled_call_count
(
&
self
)
-
>
usize
{
self
.
executor
.
call_count
(
)
}
fn
run_scheduled_calls
(
&
self
)
{
self
.
executor
.
run_all_calls
(
)
;
}
fn
wake
(
&
self
)
{
self
.
rust_future
.
clone
(
)
.
wake
(
)
;
}
fn
rust_future_weak
(
&
self
)
-
>
Weak
<
TestRustFuture
>
{
Arc
:
:
downgrade
(
&
Pin
:
:
into_inner
(
Clone
:
:
clone
(
&
self
.
rust_future
)
)
)
}
fn
complete_future
(
&
self
value
:
Result
<
bool
String
>
)
{
unsafe
{
(
*
self
.
rust_future
.
future
.
get
(
)
)
.
0
=
Some
(
value
)
;
}
}
}
#
[
test
]
fn
test_wake
(
)
{
let
mut
test_env
=
TestFutureEnvironment
:
:
new
(
)
;
assert
!
(
test_env
.
foreign_result
.
is_none
(
)
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
0
)
;
test_env
.
wake
(
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
1
)
;
test_env
.
run_scheduled_calls
(
)
;
assert
!
(
test_env
.
foreign_result
.
is_none
(
)
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
0
)
;
test_env
.
wake
(
)
;
test_env
.
wake
(
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
1
)
;
test_env
.
complete_future
(
Ok
(
true
)
)
;
test_env
.
run_scheduled_calls
(
)
;
let
result
=
test_env
.
foreign_result
.
take
(
)
.
expect
(
"
Expected
result
to
be
set
"
)
;
assert_eq
!
(
result
.
value
1
)
;
assert_eq
!
(
result
.
status
.
code
0
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
0
)
;
test_env
.
wake
(
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
0
)
;
}
#
[
test
]
fn
test_error
(
)
{
let
mut
test_env
=
TestFutureEnvironment
:
:
new
(
)
;
test_env
.
complete_future
(
Err
(
"
Something
went
wrong
"
.
into
(
)
)
)
;
test_env
.
wake
(
)
;
test_env
.
run_scheduled_calls
(
)
;
let
result
=
test_env
.
foreign_result
.
take
(
)
.
expect
(
"
Expected
result
to
be
set
"
)
;
assert_eq
!
(
result
.
status
.
code
1
)
;
unsafe
{
assert_eq
!
(
try_lift_from_rust_buffer
:
:
<
String
crate
:
:
UniFfiTag
>
(
result
.
status
.
error_buf
.
assume_init
(
)
)
.
unwrap
(
)
String
:
:
from
(
"
Something
went
wrong
"
)
)
}
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
0
)
;
}
#
[
test
]
fn
test_raw_clone_and_drop
(
)
{
let
test_env
=
TestFutureEnvironment
:
:
new
(
)
;
let
waker
=
test_env
.
rust_future
.
make_waker
(
)
;
let
weak_ref
=
test_env
.
rust_future_weak
(
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
2
)
;
let
waker2
=
waker
.
clone
(
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
3
)
;
drop
(
waker
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
2
)
;
drop
(
waker2
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
1
)
;
drop
(
test_env
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
0
)
;
assert
!
(
weak_ref
.
upgrade
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_raw_wake
(
)
{
let
test_env
=
TestFutureEnvironment
:
:
new
(
)
;
let
waker
=
test_env
.
rust_future
.
make_waker
(
)
;
let
weak_ref
=
test_env
.
rust_future_weak
(
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
2
)
;
waker
.
wake_by_ref
(
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
1
)
;
test_env
.
run_scheduled_calls
(
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
2
)
;
waker
.
wake
(
)
;
assert_eq
!
(
test_env
.
scheduled_call_count
(
)
1
)
;
test_env
.
run_scheduled_calls
(
)
;
assert_eq
!
(
weak_ref
.
strong_count
(
)
1
)
;
}
}
