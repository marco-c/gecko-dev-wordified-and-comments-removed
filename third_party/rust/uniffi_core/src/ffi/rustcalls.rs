use
crate
:
:
{
FfiConverter
FfiDefault
RustBuffer
UniFfiTag
}
;
use
std
:
:
mem
:
:
MaybeUninit
;
use
std
:
:
panic
;
#
[
repr
(
C
)
]
pub
struct
RustCallStatus
{
pub
code
:
i8
pub
error_buf
:
MaybeUninit
<
RustBuffer
>
}
impl
Default
for
RustCallStatus
{
fn
default
(
)
-
>
Self
{
Self
{
code
:
0
error_buf
:
MaybeUninit
:
:
uninit
(
)
}
}
}
#
[
allow
(
dead_code
)
]
const
CALL_SUCCESS
:
i8
=
0
;
const
CALL_ERROR
:
i8
=
1
;
const
CALL_PANIC
:
i8
=
2
;
pub
fn
rust_call
<
F
R
>
(
out_status
:
&
mut
RustCallStatus
callback
:
F
)
-
>
R
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
RustBuffer
>
R
:
FfiDefault
{
rust_call_with_out_status
(
out_status
callback
)
.
unwrap_or_else
(
R
:
:
ffi_default
)
}
pub
(
crate
)
fn
rust_call_with_out_status
<
F
R
>
(
out_status
:
&
mut
RustCallStatus
callback
:
F
)
-
>
Option
<
R
>
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
RustBuffer
>
{
let
result
=
panic
:
:
catch_unwind
(
|
|
{
crate
:
:
panichook
:
:
ensure_setup
(
)
;
callback
(
)
}
)
;
match
result
{
Ok
(
Ok
(
v
)
)
=
>
Some
(
v
)
Ok
(
Err
(
buf
)
)
=
>
{
out_status
.
code
=
CALL_ERROR
;
unsafe
{
out_status
.
error_buf
.
as_mut_ptr
(
)
.
write
(
buf
)
;
}
None
}
Err
(
cause
)
=
>
{
out_status
.
code
=
CALL_PANIC
;
let
message_result
=
panic
:
:
catch_unwind
(
panic
:
:
AssertUnwindSafe
(
move
|
|
{
let
message
=
if
let
Some
(
s
)
=
cause
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
(
*
s
)
.
to_string
(
)
}
else
if
let
Some
(
s
)
=
cause
.
downcast_ref
:
:
<
String
>
(
)
{
s
.
clone
(
)
}
else
{
"
Unknown
panic
!
"
.
to_string
(
)
}
;
log
:
:
error
!
(
"
Caught
a
panic
calling
rust
code
:
{
:
?
}
"
message
)
;
<
String
as
FfiConverter
<
UniFfiTag
>
>
:
:
lower
(
message
)
}
)
)
;
if
let
Ok
(
buf
)
=
message_result
{
unsafe
{
out_status
.
error_buf
.
as_mut_ptr
(
)
.
write
(
buf
)
;
}
}
None
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
{
ffi_converter_default_return
ffi_converter_rust_buffer_lift_and_lower
MetadataBuffer
UniFfiTag
}
;
fn
create_call_status
(
)
-
>
RustCallStatus
{
RustCallStatus
{
code
:
0
error_buf
:
MaybeUninit
:
:
new
(
RustBuffer
:
:
new
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
struct
TestError
(
String
)
;
unsafe
impl
FfiConverter
<
UniFfiTag
>
for
TestError
{
ffi_converter_rust_buffer_lift_and_lower
!
(
UniFfiTag
)
;
ffi_converter_default_return
!
(
UniFfiTag
)
;
fn
write
(
obj
:
TestError
buf
:
&
mut
Vec
<
u8
>
)
{
<
String
as
FfiConverter
<
UniFfiTag
>
>
:
:
write
(
obj
.
0
buf
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
anyhow
:
:
Result
<
TestError
>
{
<
String
as
FfiConverter
<
UniFfiTag
>
>
:
:
try_read
(
buf
)
.
map
(
TestError
)
}
const
TYPE_ID_META
:
MetadataBuffer
=
MetadataBuffer
:
:
new
(
)
;
}
fn
test_callback
(
a
:
u8
)
-
>
Result
<
i8
TestError
>
{
match
a
{
0
=
>
Ok
(
100
)
1
=
>
Err
(
TestError
(
"
Error
"
.
to_owned
(
)
)
)
x
=
>
panic
!
(
"
Unexpected
value
:
{
x
}
"
)
}
}
#
[
test
]
fn
test_rust_call
(
)
{
let
mut
status
=
create_call_status
(
)
;
let
return_value
=
rust_call
(
&
mut
status
|
|
{
<
Result
<
i8
TestError
>
as
FfiConverter
<
UniFfiTag
>
>
:
:
lower_return
(
test_callback
(
0
)
)
}
)
;
assert_eq
!
(
status
.
code
CALL_SUCCESS
)
;
assert_eq
!
(
return_value
100
)
;
rust_call
(
&
mut
status
|
|
{
<
Result
<
i8
TestError
>
as
FfiConverter
<
UniFfiTag
>
>
:
:
lower_return
(
test_callback
(
1
)
)
}
)
;
assert_eq
!
(
status
.
code
CALL_ERROR
)
;
unsafe
{
assert_eq
!
(
<
TestError
as
FfiConverter
<
UniFfiTag
>
>
:
:
try_lift
(
status
.
error_buf
.
assume_init
(
)
)
.
unwrap
(
)
TestError
(
"
Error
"
.
to_owned
(
)
)
)
;
}
let
mut
status
=
create_call_status
(
)
;
rust_call
(
&
mut
status
|
|
{
<
Result
<
i8
TestError
>
as
FfiConverter
<
UniFfiTag
>
>
:
:
lower_return
(
test_callback
(
2
)
)
}
)
;
assert_eq
!
(
status
.
code
CALL_PANIC
)
;
unsafe
{
assert_eq
!
(
<
String
as
FfiConverter
<
UniFfiTag
>
>
:
:
try_lift
(
status
.
error_buf
.
assume_init
(
)
)
.
unwrap
(
)
"
Unexpected
value
:
2
"
)
;
}
}
}
