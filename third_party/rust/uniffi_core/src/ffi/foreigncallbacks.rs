use
crate
:
:
{
FfiConverter
RustBuffer
}
;
use
std
:
:
fmt
;
use
std
:
:
os
:
:
raw
:
:
c_int
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
pub
type
ForeignCallback
=
unsafe
extern
"
C
"
fn
(
handle
:
u64
method
:
u32
args_data
:
*
const
u8
args_len
:
i32
buf_ptr
:
*
mut
RustBuffer
)
-
>
c_int
;
pub
const
IDX_CALLBACK_FREE
:
u32
=
0
;
pub
const
CALLBACK_SUCCESS
:
i32
=
0
;
pub
const
CALLBACK_ERROR
:
i32
=
1
;
pub
const
CALLBACK_UNEXPECTED_ERROR
:
i32
=
2
;
static_assertions
:
:
assert_eq_size
!
(
usize
ForeignCallback
)
;
static_assertions
:
:
assert_eq_size
!
(
usize
Option
<
ForeignCallback
>
)
;
pub
struct
ForeignCallbackInternals
{
callback_ptr
:
AtomicUsize
}
const
EMPTY_PTR
:
usize
=
0
;
impl
ForeignCallbackInternals
{
pub
const
fn
new
(
)
-
>
Self
{
ForeignCallbackInternals
{
callback_ptr
:
AtomicUsize
:
:
new
(
EMPTY_PTR
)
}
}
pub
fn
set_callback
(
&
self
callback
:
ForeignCallback
)
{
let
as_usize
=
callback
as
usize
;
let
old_ptr
=
self
.
callback_ptr
.
compare_exchange
(
EMPTY_PTR
as_usize
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
)
;
match
old_ptr
{
Ok
(
EMPTY_PTR
)
=
>
(
)
_
=
>
{
panic
!
(
"
Bug
:
call
set_callback
multiple
times
.
This
is
likely
a
uniffi
bug
"
)
}
}
;
}
fn
call_callback
(
&
self
handle
:
u64
method
:
u32
args
:
RustBuffer
ret_rbuf
:
&
mut
RustBuffer
)
-
>
c_int
{
let
ptr_value
=
self
.
callback_ptr
.
load
(
Ordering
:
:
SeqCst
)
;
unsafe
{
let
callback
=
std
:
:
mem
:
:
transmute
:
:
<
usize
Option
<
ForeignCallback
>
>
(
ptr_value
)
.
expect
(
"
Callback
interface
handler
not
set
"
)
;
callback
(
handle
method
args
.
data_pointer
(
)
args
.
len
(
)
as
i32
ret_rbuf
)
}
}
pub
fn
invoke_callback
<
R
UniFfiTag
>
(
&
self
handle
:
u64
method
:
u32
args
:
RustBuffer
)
-
>
R
where
R
:
FfiConverter
<
UniFfiTag
>
{
let
mut
ret_rbuf
=
RustBuffer
:
:
new
(
)
;
let
callback_result
=
self
.
call_callback
(
handle
method
args
&
mut
ret_rbuf
)
;
match
callback_result
{
CALLBACK_SUCCESS
=
>
R
:
:
lift_callback_return
(
ret_rbuf
)
CALLBACK_ERROR
=
>
R
:
:
lift_callback_error
(
ret_rbuf
)
CALLBACK_UNEXPECTED_ERROR
=
>
{
let
reason
=
if
!
ret_rbuf
.
is_empty
(
)
{
match
<
String
as
FfiConverter
<
UniFfiTag
>
>
:
:
try_lift
(
ret_rbuf
)
{
Ok
(
s
)
=
>
s
Err
(
e
)
=
>
{
log
:
:
error
!
(
"
{
{
trait_name
}
}
Error
reading
ret_buf
:
{
e
}
"
)
;
String
:
:
from
(
"
[
Error
reading
reason
]
"
)
}
}
}
else
{
RustBuffer
:
:
destroy
(
ret_rbuf
)
;
String
:
:
from
(
"
[
Unknown
Reason
]
"
)
}
;
R
:
:
handle_callback_unexpected_error
(
UnexpectedUniFFICallbackError
{
reason
}
)
}
_
=
>
panic
!
(
"
Callback
failed
with
unexpected
return
code
"
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
UnexpectedUniFFICallbackError
{
pub
reason
:
String
}
impl
UnexpectedUniFFICallbackError
{
pub
fn
from_reason
(
reason
:
String
)
-
>
Self
{
Self
{
reason
}
}
}
impl
fmt
:
:
Display
for
UnexpectedUniFFICallbackError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
UnexpectedUniFFICallbackError
(
reason
:
{
:
?
}
)
"
self
.
reason
)
}
}
impl
std
:
:
error
:
:
Error
for
UnexpectedUniFFICallbackError
{
}
