use
super
:
:
RustBuffer
;
use
std
:
:
fmt
;
use
std
:
:
os
:
:
raw
:
:
c_int
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
pub
type
ForeignCallback
=
unsafe
extern
"
C
"
fn
(
handle
:
u64
method
:
u32
args
:
RustBuffer
buf_ptr
:
*
mut
RustBuffer
)
-
>
c_int
;
pub
const
IDX_CALLBACK_FREE
:
u32
=
0
;
static_assertions
:
:
assert_eq_size
!
(
usize
ForeignCallback
)
;
static_assertions
:
:
assert_eq_size
!
(
usize
Option
<
ForeignCallback
>
)
;
pub
struct
ForeignCallbackInternals
{
callback_ptr
:
AtomicUsize
}
const
EMPTY_PTR
:
usize
=
0
;
impl
ForeignCallbackInternals
{
pub
const
fn
new
(
)
-
>
Self
{
ForeignCallbackInternals
{
callback_ptr
:
AtomicUsize
:
:
new
(
EMPTY_PTR
)
}
}
pub
fn
set_callback
(
&
self
callback
:
ForeignCallback
)
{
let
as_usize
=
callback
as
usize
;
let
old_ptr
=
self
.
callback_ptr
.
compare_exchange
(
EMPTY_PTR
as_usize
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
)
;
match
old_ptr
{
Ok
(
EMPTY_PTR
)
=
>
(
)
_
=
>
{
panic
!
(
"
Bug
:
call
set_callback
multiple
times
.
This
is
likely
a
uniffi
bug
"
)
}
}
;
}
pub
fn
get_callback
(
&
self
)
-
>
Option
<
ForeignCallback
>
{
let
ptr_value
=
self
.
callback_ptr
.
load
(
Ordering
:
:
SeqCst
)
;
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
usize
Option
<
ForeignCallback
>
>
(
ptr_value
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
UnexpectedUniFFICallbackError
{
pub
reason
:
String
}
impl
UnexpectedUniFFICallbackError
{
pub
fn
from_reason
(
reason
:
String
)
-
>
Self
{
Self
{
reason
}
}
}
impl
fmt
:
:
Display
for
UnexpectedUniFFICallbackError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
UnexpectedUniFFICallbackError
(
reason
:
{
:
?
}
)
"
self
.
reason
)
}
}
impl
std
:
:
error
:
:
Error
for
UnexpectedUniFFICallbackError
{
}
