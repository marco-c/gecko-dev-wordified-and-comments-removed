use
std
:
:
{
future
:
:
Future
marker
:
:
PhantomData
ops
:
:
Deref
panic
pin
:
:
Pin
sync
:
:
{
Arc
Mutex
}
task
:
:
{
Context
Poll
Wake
}
}
;
use
super
:
:
{
RustFutureContinuationCallback
RustFuturePoll
Scheduler
}
;
use
crate
:
:
{
rust_call_with_out_status
FfiDefault
LiftArgsError
LowerReturn
RustCallStatus
}
;
struct
WrappedFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
future
:
Option
<
F
>
result
:
Option
<
Result
<
T
:
:
ReturnType
RustCallStatus
>
>
}
impl
<
F
T
UT
>
WrappedFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
fn
new
(
future
:
F
)
-
>
Self
{
Self
{
future
:
Some
(
future
)
result
:
None
}
}
fn
poll
(
&
mut
self
context
:
&
mut
Context
<
'
_
>
)
-
>
bool
{
if
self
.
result
.
is_some
(
)
{
true
}
else
if
let
Some
(
future
)
=
&
mut
self
.
future
{
let
pinned
=
unsafe
{
Pin
:
:
new_unchecked
(
future
)
}
;
let
mut
out_status
=
RustCallStatus
:
:
default
(
)
;
let
result
:
Option
<
Poll
<
T
:
:
ReturnType
>
>
=
rust_call_with_out_status
(
&
mut
out_status
panic
:
:
AssertUnwindSafe
(
|
|
match
pinned
.
poll
(
context
)
{
Poll
:
:
Pending
=
>
Ok
(
Poll
:
:
Pending
)
Poll
:
:
Ready
(
Ok
(
v
)
)
=
>
T
:
:
lower_return
(
v
)
.
map
(
Poll
:
:
Ready
)
Poll
:
:
Ready
(
Err
(
e
)
)
=
>
T
:
:
handle_failed_lift
(
e
)
.
map
(
Poll
:
:
Ready
)
}
)
)
;
match
result
{
Some
(
Poll
:
:
Pending
)
=
>
false
Some
(
Poll
:
:
Ready
(
v
)
)
=
>
{
self
.
future
=
None
;
self
.
result
=
Some
(
Ok
(
v
)
)
;
true
}
None
=
>
{
self
.
future
=
None
;
self
.
result
=
Some
(
Err
(
out_status
)
)
;
true
}
}
}
else
{
log
:
:
error
!
(
"
poll
with
neither
future
nor
result
set
"
)
;
true
}
}
fn
complete
(
&
mut
self
out_status
:
&
mut
RustCallStatus
)
-
>
T
:
:
ReturnType
{
let
mut
return_value
=
T
:
:
ReturnType
:
:
ffi_default
(
)
;
match
self
.
result
.
take
(
)
{
Some
(
Ok
(
v
)
)
=
>
return_value
=
v
Some
(
Err
(
call_status
)
)
=
>
*
out_status
=
call_status
None
=
>
*
out_status
=
RustCallStatus
:
:
cancelled
(
)
}
self
.
free
(
)
;
return_value
}
fn
free
(
&
mut
self
)
{
self
.
future
=
None
;
self
.
result
=
None
;
}
}
unsafe
impl
<
F
T
UT
>
Send
for
WrappedFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
}
pub
(
super
)
struct
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
future
:
Mutex
<
WrappedFuture
<
F
T
UT
>
>
scheduler
:
Mutex
<
Scheduler
>
_phantom
:
PhantomData
<
fn
(
UT
)
-
>
(
)
>
}
impl
<
F
T
UT
>
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
pub
(
super
)
fn
new
(
future
:
F
_tag
:
UT
)
-
>
Arc
<
Self
>
{
Arc
:
:
new
(
Self
{
future
:
Mutex
:
:
new
(
WrappedFuture
:
:
new
(
future
)
)
scheduler
:
Mutex
:
:
new
(
Scheduler
:
:
new
(
)
)
_phantom
:
PhantomData
}
)
}
pub
(
super
)
fn
poll
(
self
:
Arc
<
Self
>
callback
:
RustFutureContinuationCallback
data
:
u64
)
{
let
ready
=
self
.
is_cancelled
(
)
|
|
{
let
mut
locked
=
self
.
future
.
lock
(
)
.
unwrap
(
)
;
let
waker
:
std
:
:
task
:
:
Waker
=
Arc
:
:
clone
(
&
self
)
.
into
(
)
;
locked
.
poll
(
&
mut
Context
:
:
from_waker
(
&
waker
)
)
}
;
if
ready
{
callback
(
data
RustFuturePoll
:
:
Ready
)
}
else
{
self
.
scheduler
.
lock
(
)
.
unwrap
(
)
.
store
(
callback
data
)
;
}
}
pub
(
super
)
fn
is_cancelled
(
&
self
)
-
>
bool
{
self
.
scheduler
.
lock
(
)
.
unwrap
(
)
.
is_cancelled
(
)
}
pub
(
super
)
fn
wake
(
&
self
)
{
self
.
scheduler
.
lock
(
)
.
unwrap
(
)
.
wake
(
)
;
}
pub
(
super
)
fn
cancel
(
&
self
)
{
self
.
scheduler
.
lock
(
)
.
unwrap
(
)
.
cancel
(
)
;
}
pub
(
super
)
fn
complete
(
&
self
call_status
:
&
mut
RustCallStatus
)
-
>
T
:
:
ReturnType
{
self
.
future
.
lock
(
)
.
unwrap
(
)
.
complete
(
call_status
)
}
pub
(
super
)
fn
free
(
self
:
Arc
<
Self
>
)
{
self
.
scheduler
.
lock
(
)
.
unwrap
(
)
.
cancel
(
)
;
self
.
future
.
lock
(
)
.
unwrap
(
)
.
free
(
)
;
}
}
impl
<
F
T
UT
>
Wake
for
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
fn
wake
(
self
:
Arc
<
Self
>
)
{
self
.
deref
(
)
.
wake
(
)
}
fn
wake_by_ref
(
self
:
&
Arc
<
Self
>
)
{
self
.
deref
(
)
.
wake
(
)
}
}
#
[
doc
(
hidden
)
]
pub
trait
RustFutureFfi
<
ReturnType
>
:
Send
+
Sync
{
fn
ffi_poll
(
self
:
Arc
<
Self
>
callback
:
RustFutureContinuationCallback
data
:
u64
)
;
fn
ffi_cancel
(
&
self
)
;
fn
ffi_complete
(
&
self
call_status
:
&
mut
RustCallStatus
)
-
>
ReturnType
;
fn
ffi_free
(
self
:
Arc
<
Self
>
)
;
}
impl
<
F
T
UT
>
RustFutureFfi
<
T
:
:
ReturnType
>
for
RustFuture
<
F
T
UT
>
where
F
:
Future
<
Output
=
Result
<
T
LiftArgsError
>
>
+
Send
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
{
fn
ffi_poll
(
self
:
Arc
<
Self
>
callback
:
RustFutureContinuationCallback
data
:
u64
)
{
self
.
poll
(
callback
data
)
}
fn
ffi_cancel
(
&
self
)
{
self
.
cancel
(
)
}
fn
ffi_complete
(
&
self
call_status
:
&
mut
RustCallStatus
)
-
>
T
:
:
ReturnType
{
self
.
complete
(
call_status
)
}
fn
ffi_free
(
self
:
Arc
<
Self
>
)
{
self
.
free
(
)
;
}
}
