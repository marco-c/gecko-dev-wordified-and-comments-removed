use
std
:
:
{
future
:
:
Future
sync
:
:
Arc
}
;
mod
future
;
mod
scheduler
;
use
future
:
:
*
;
use
scheduler
:
:
*
;
#
[
cfg
(
test
)
]
mod
tests
;
use
crate
:
:
{
derive_ffi_traits
Handle
HandleAlloc
LiftArgsError
LowerReturn
RustCallStatus
}
;
#
[
repr
(
i8
)
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
RustFuturePoll
{
Ready
=
0
MaybeReady
=
1
}
pub
type
RustFutureContinuationCallback
=
extern
"
C
"
fn
(
callback_data
:
u64
RustFuturePoll
)
;
#
[
doc
(
hidden
)
]
pub
trait
UniffiCompatibleFuture
<
T
>
:
Future
<
Output
=
T
>
{
}
#
[
cfg
(
not
(
target_arch
=
"
wasm32
"
)
)
]
impl
<
T
F
>
UniffiCompatibleFuture
<
T
>
for
F
where
F
:
Future
<
Output
=
T
>
+
Send
{
}
#
[
cfg
(
target_arch
=
"
wasm32
"
)
]
impl
<
T
F
>
UniffiCompatibleFuture
<
T
>
for
F
where
F
:
Future
<
Output
=
T
>
{
}
#
[
allow
(
clippy
:
:
let_and_return
)
]
pub
fn
rust_future_new
<
F
T
UT
>
(
future
:
F
tag
:
UT
)
-
>
Handle
where
F
:
UniffiCompatibleFuture
<
Result
<
T
LiftArgsError
>
>
+
'
static
T
:
LowerReturn
<
UT
>
+
Send
+
'
static
UT
:
Send
+
'
static
dyn
RustFutureFfi
<
T
:
:
ReturnType
>
:
HandleAlloc
<
UT
>
{
let
handle
=
<
dyn
RustFutureFfi
<
T
:
:
ReturnType
>
as
HandleAlloc
<
UT
>
>
:
:
new_handle
(
RustFuture
:
:
new
(
future
tag
)
as
Arc
<
dyn
RustFutureFfi
<
T
:
:
ReturnType
>
>
)
;
trace
!
(
"
rust_future_new
:
{
handle
:
?
}
"
)
;
handle
}
pub
unsafe
fn
rust_future_poll
<
ReturnType
UT
>
(
handle
:
Handle
callback
:
RustFutureContinuationCallback
data
:
u64
)
where
dyn
RustFutureFfi
<
ReturnType
>
:
HandleAlloc
<
UT
>
{
trace
!
(
"
rust_future_poll
:
{
handle
:
?
}
"
)
;
<
dyn
RustFutureFfi
<
ReturnType
>
as
HandleAlloc
<
UT
>
>
:
:
get_arc
(
handle
)
.
ffi_poll
(
callback
data
)
}
pub
unsafe
fn
rust_future_cancel
<
ReturnType
UT
>
(
handle
:
Handle
)
where
dyn
RustFutureFfi
<
ReturnType
>
:
HandleAlloc
<
UT
>
{
trace
!
(
"
rust_future_cancel
:
{
handle
:
?
}
"
)
;
<
dyn
RustFutureFfi
<
ReturnType
>
as
HandleAlloc
<
UT
>
>
:
:
get_arc
(
handle
)
.
ffi_cancel
(
)
}
pub
unsafe
fn
rust_future_complete
<
ReturnType
UT
>
(
handle
:
Handle
out_status
:
&
mut
RustCallStatus
)
-
>
ReturnType
where
dyn
RustFutureFfi
<
ReturnType
>
:
HandleAlloc
<
UT
>
{
trace
!
(
"
rust_future_complete
:
{
handle
:
?
}
"
)
;
<
dyn
RustFutureFfi
<
ReturnType
>
as
HandleAlloc
<
UT
>
>
:
:
get_arc
(
handle
)
.
ffi_complete
(
out_status
)
}
pub
unsafe
fn
rust_future_free
<
ReturnType
UT
>
(
handle
:
Handle
)
where
dyn
RustFutureFfi
<
ReturnType
>
:
HandleAlloc
<
UT
>
{
trace
!
(
"
rust_future_free
:
{
handle
:
?
}
"
)
;
<
dyn
RustFutureFfi
<
ReturnType
>
as
HandleAlloc
<
UT
>
>
:
:
consume_handle
(
handle
)
.
ffi_free
(
)
}
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
u8
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
i8
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
u16
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
i16
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
u32
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
i32
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
u64
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
i64
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
f32
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
f64
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
*
const
std
:
:
ffi
:
:
c_void
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
crate
:
:
RustBuffer
>
)
;
derive_ffi_traits
!
(
impl
<
UT
>
HandleAlloc
<
UT
>
for
dyn
RustFutureFfi
<
(
)
>
)
;
