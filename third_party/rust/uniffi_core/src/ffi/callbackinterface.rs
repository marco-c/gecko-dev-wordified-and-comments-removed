use
crate
:
:
{
ForeignCallback
ForeignCallbackCell
Lift
LiftReturn
RustBuffer
}
;
use
std
:
:
fmt
;
pub
const
IDX_CALLBACK_FREE
:
u32
=
0
;
#
[
repr
(
i32
)
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
CallbackResult
{
Success
=
0
Error
=
1
UnexpectedError
=
2
}
impl
TryFrom
<
i32
>
for
CallbackResult
{
type
Error
=
i32
;
fn
try_from
(
value
:
i32
)
-
>
Result
<
Self
i32
>
{
match
value
{
0
=
>
Ok
(
Self
:
:
Success
)
1
=
>
Ok
(
Self
:
:
Error
)
2
=
>
Ok
(
Self
:
:
UnexpectedError
)
n
=
>
Err
(
n
)
}
}
}
pub
struct
ForeignCallbackInternals
{
callback_cell
:
ForeignCallbackCell
}
impl
ForeignCallbackInternals
{
pub
const
fn
new
(
)
-
>
Self
{
ForeignCallbackInternals
{
callback_cell
:
ForeignCallbackCell
:
:
new
(
)
}
}
pub
fn
set_callback
(
&
self
callback
:
ForeignCallback
)
{
self
.
callback_cell
.
set
(
callback
)
;
}
pub
fn
invoke_callback
<
R
UniFfiTag
>
(
&
self
handle
:
u64
method
:
u32
args
:
RustBuffer
)
-
>
R
where
R
:
LiftReturn
<
UniFfiTag
>
{
let
mut
ret_rbuf
=
RustBuffer
:
:
new
(
)
;
let
callback
=
self
.
callback_cell
.
get
(
)
;
let
raw_result
=
unsafe
{
callback
(
handle
method
args
.
data_pointer
(
)
args
.
len
(
)
as
i32
&
mut
ret_rbuf
)
}
;
let
result
=
CallbackResult
:
:
try_from
(
raw_result
)
.
unwrap_or_else
(
|
code
|
panic
!
(
"
Callback
failed
with
unexpected
return
code
:
{
code
}
"
)
)
;
match
result
{
CallbackResult
:
:
Success
=
>
R
:
:
lift_callback_return
(
ret_rbuf
)
CallbackResult
:
:
Error
=
>
R
:
:
lift_callback_error
(
ret_rbuf
)
CallbackResult
:
:
UnexpectedError
=
>
{
let
reason
=
if
!
ret_rbuf
.
is_empty
(
)
{
match
<
String
as
Lift
<
UniFfiTag
>
>
:
:
try_lift
(
ret_rbuf
)
{
Ok
(
s
)
=
>
s
Err
(
e
)
=
>
{
log
:
:
error
!
(
"
{
{
trait_name
}
}
Error
reading
ret_buf
:
{
e
}
"
)
;
String
:
:
from
(
"
[
Error
reading
reason
]
"
)
}
}
}
else
{
RustBuffer
:
:
destroy
(
ret_rbuf
)
;
String
:
:
from
(
"
[
Unknown
Reason
]
"
)
}
;
R
:
:
handle_callback_unexpected_error
(
UnexpectedUniFFICallbackError
{
reason
}
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
UnexpectedUniFFICallbackError
{
pub
reason
:
String
}
impl
UnexpectedUniFFICallbackError
{
pub
fn
from_reason
(
reason
:
String
)
-
>
Self
{
Self
{
reason
}
}
}
impl
fmt
:
:
Display
for
UnexpectedUniFFICallbackError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
UnexpectedUniFFICallbackError
(
reason
:
{
:
?
}
)
"
self
.
reason
)
}
}
impl
std
:
:
error
:
:
Error
for
UnexpectedUniFFICallbackError
{
}
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
UnexpectedUniFFICallbackErrorConverterGeneric
;
impl
UnexpectedUniFFICallbackErrorConverterGeneric
{
pub
fn
try_convert_unexpected_callback_error
<
E
>
(
&
self
e
:
UnexpectedUniFFICallbackError
)
-
>
anyhow
:
:
Result
<
E
>
{
Err
(
e
.
into
(
)
)
}
}
#
[
doc
(
hidden
)
]
#
[
derive
(
Debug
)
]
pub
struct
UnexpectedUniFFICallbackErrorConverterSpecialized
;
impl
UnexpectedUniFFICallbackErrorConverterSpecialized
{
pub
fn
try_convert_unexpected_callback_error
<
E
>
(
&
self
e
:
UnexpectedUniFFICallbackError
)
-
>
anyhow
:
:
Result
<
E
>
where
E
:
From
<
UnexpectedUniFFICallbackError
>
{
Ok
(
E
:
:
from
(
e
)
)
}
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
convert_unexpected_error
{
(
error
:
ident
ty
:
ty
)
=
>
{
{
/
/
Trait
for
generic
conversion
implemented
for
all
&
T
.
pub
trait
GetConverterGeneric
{
fn
get_converter
(
&
self
)
-
>
crate
:
:
UnexpectedUniFFICallbackErrorConverterGeneric
;
}
impl
<
T
>
GetConverterGeneric
for
&
T
{
fn
get_converter
(
&
self
)
-
>
crate
:
:
UnexpectedUniFFICallbackErrorConverterGeneric
{
crate
:
:
UnexpectedUniFFICallbackErrorConverterGeneric
}
}
/
/
Trait
for
specialized
conversion
implemented
for
all
T
that
implements
/
/
Into
<
ErrorType
>
.
I
.
e
.
it
'
s
implemented
for
UnexpectedUniFFICallbackError
when
/
/
ErrorType
implements
From
<
UnexpectedUniFFICallbackError
>
.
pub
trait
GetConverterSpecialized
{
fn
get_converter
(
&
self
)
-
>
crate
:
:
UnexpectedUniFFICallbackErrorConverterSpecialized
;
}
impl
<
T
:
Into
<
ty
>
>
GetConverterSpecialized
for
T
{
fn
get_converter
(
&
self
)
-
>
crate
:
:
UnexpectedUniFFICallbackErrorConverterSpecialized
{
crate
:
:
UnexpectedUniFFICallbackErrorConverterSpecialized
}
}
/
/
Here
'
s
the
hack
.
Because
of
the
auto
-
ref
rules
this
will
use
GetConverterSpecialized
/
/
if
it
'
s
implemented
and
GetConverterGeneric
if
not
.
(
&
error
)
.
get_converter
(
)
.
try_convert_unexpected_callback_error
(
error
)
}
}
;
}
