use
std
:
:
panic
;
use
crate
:
:
{
ForeignExecutorCallback
ForeignExecutorCallbackCell
}
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ForeignExecutorHandle
(
pub
(
crate
)
*
const
(
)
)
;
unsafe
impl
Send
for
ForeignExecutorHandle
{
}
unsafe
impl
Sync
for
ForeignExecutorHandle
{
}
#
[
repr
(
i8
)
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
ForeignExecutorCallbackResult
{
Success
=
0
Cancelled
=
1
Error
=
2
}
impl
ForeignExecutorCallbackResult
{
pub
fn
check_result_code
(
result
:
i8
)
-
>
bool
{
match
result
{
n
if
n
=
=
ForeignExecutorCallbackResult
:
:
Success
as
i8
=
>
true
n
if
n
=
=
ForeignExecutorCallbackResult
:
:
Cancelled
as
i8
=
>
false
n
if
n
=
=
ForeignExecutorCallbackResult
:
:
Error
as
i8
=
>
{
log
:
:
error
!
(
"
ForeignExecutorCallbackResult
:
:
Error
returned
by
foreign
executor
callback
"
)
;
false
}
n
=
>
{
log
:
:
error
!
(
"
Unknown
code
(
{
n
}
)
returned
by
foreign
executor
callback
"
)
;
false
}
}
}
}
static_assertions
:
:
assert_eq_size
!
(
usize
Option
<
RustTaskCallback
>
)
;
pub
type
RustTaskCallback
=
extern
"
C
"
fn
(
*
const
(
)
RustTaskCallbackCode
)
;
#
[
repr
(
i8
)
]
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
RustTaskCallbackCode
{
Success
=
0
Cancelled
=
1
}
static
FOREIGN_EXECUTOR_CALLBACK
:
ForeignExecutorCallbackCell
=
ForeignExecutorCallbackCell
:
:
new
(
)
;
pub
fn
foreign_executor_callback_set
(
callback
:
ForeignExecutorCallback
)
{
FOREIGN_EXECUTOR_CALLBACK
.
set
(
callback
)
;
}
#
[
derive
(
Debug
)
]
pub
struct
ForeignExecutor
{
pub
(
crate
)
handle
:
ForeignExecutorHandle
}
impl
ForeignExecutor
{
pub
fn
new
(
executor
:
ForeignExecutorHandle
)
-
>
Self
{
Self
{
handle
:
executor
}
}
pub
fn
schedule
<
F
:
FnOnce
(
)
+
Send
+
'
static
+
panic
:
:
UnwindSafe
>
(
&
self
delay
:
u32
task
:
F
)
{
let
leaked_ptr
:
*
mut
F
=
Box
:
:
leak
(
Box
:
:
new
(
task
)
)
;
if
!
schedule_raw
(
self
.
handle
delay
schedule_callback
:
:
<
F
>
leaked_ptr
as
*
const
(
)
)
{
unsafe
{
drop
(
Box
:
:
<
F
>
:
:
from_raw
(
leaked_ptr
)
)
;
}
;
}
}
pub
async
fn
run
<
F
T
>
(
&
self
delay
:
u32
closure
:
F
)
-
>
T
where
F
:
FnOnce
(
)
-
>
T
+
Send
+
'
static
+
panic
:
:
UnwindSafe
T
:
Send
+
'
static
{
let
(
sender
receiver
)
=
oneshot
:
:
channel
(
)
;
self
.
schedule
(
delay
panic
:
:
AssertUnwindSafe
(
move
|
|
{
sender
.
send
(
closure
(
)
)
.
expect
(
"
Error
sending
future
result
"
)
}
)
)
;
receiver
.
await
.
expect
(
"
Error
receiving
future
result
"
)
}
}
pub
(
crate
)
fn
schedule_raw
(
handle
:
ForeignExecutorHandle
delay
:
u32
callback
:
RustTaskCallback
data
:
*
const
(
)
)
-
>
bool
{
let
result_code
=
(
FOREIGN_EXECUTOR_CALLBACK
.
get
(
)
)
(
handle
delay
Some
(
callback
)
data
)
;
ForeignExecutorCallbackResult
:
:
check_result_code
(
result_code
)
}
impl
Drop
for
ForeignExecutor
{
fn
drop
(
&
mut
self
)
{
(
FOREIGN_EXECUTOR_CALLBACK
.
get
(
)
)
(
self
.
handle
0
None
std
:
:
ptr
:
:
null
(
)
)
;
}
}
extern
"
C
"
fn
schedule_callback
<
F
>
(
data
:
*
const
(
)
status_code
:
RustTaskCallbackCode
)
where
F
:
FnOnce
(
)
+
Send
+
'
static
+
panic
:
:
UnwindSafe
{
let
task
=
unsafe
{
Box
:
:
from_raw
(
data
as
*
mut
F
)
}
;
if
status_code
=
=
RustTaskCallbackCode
:
:
Success
{
run_task
(
task
)
;
}
}
fn
run_task
<
F
:
FnOnce
(
)
-
>
T
+
panic
:
:
UnwindSafe
T
>
(
task
:
F
)
-
>
Option
<
T
>
{
match
panic
:
:
catch_unwind
(
task
)
{
Ok
(
v
)
=
>
Some
(
v
)
Err
(
cause
)
=
>
{
let
message
=
if
let
Some
(
s
)
=
cause
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
(
*
s
)
.
to_string
(
)
}
else
if
let
Some
(
s
)
=
cause
.
downcast_ref
:
:
<
String
>
(
)
{
s
.
clone
(
)
}
else
{
"
Unknown
panic
!
"
.
to_string
(
)
}
;
log
:
:
warn
!
(
"
Error
calling
UniFFI
callback
function
:
{
message
}
"
)
;
None
}
}
}
#
[
cfg
(
test
)
]
pub
use
test
:
:
MockEventLoop
;
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
std
:
:
{
future
:
:
Future
pin
:
:
Pin
sync
:
:
{
atomic
:
:
{
AtomicU32
Ordering
}
Arc
Mutex
Once
}
task
:
:
{
Context
Poll
Wake
Waker
}
}
;
pub
struct
MockEventLoop
{
inner
:
Mutex
<
MockEventLoopInner
>
}
pub
struct
MockEventLoopInner
{
calls
:
Vec
<
(
u32
Option
<
RustTaskCallback
>
*
const
(
)
)
>
is_shutdown
:
bool
}
unsafe
impl
Send
for
MockEventLoopInner
{
}
static
FOREIGN_EXECUTOR_CALLBACK_INIT
:
Once
=
Once
:
:
new
(
)
;
impl
MockEventLoop
{
pub
fn
new
(
)
-
>
Arc
<
Self
>
{
FOREIGN_EXECUTOR_CALLBACK_INIT
.
call_once
(
|
|
foreign_executor_callback_set
(
mock_executor_callback
)
)
;
Arc
:
:
new
(
Self
{
inner
:
Mutex
:
:
new
(
MockEventLoopInner
{
calls
:
vec
!
[
]
is_shutdown
:
false
}
)
}
)
}
pub
fn
new_handle
(
self
:
&
Arc
<
Self
>
)
-
>
ForeignExecutorHandle
{
ForeignExecutorHandle
(
Arc
:
:
into_raw
(
Arc
:
:
clone
(
self
)
)
as
*
const
(
)
)
}
pub
fn
new_executor
(
self
:
&
Arc
<
Self
>
)
-
>
ForeignExecutor
{
ForeignExecutor
{
handle
:
self
.
new_handle
(
)
}
}
pub
fn
call_count
(
&
self
)
-
>
usize
{
self
.
inner
.
lock
(
)
.
unwrap
(
)
.
calls
.
len
(
)
}
pub
fn
last_call
(
&
self
)
-
>
(
u32
Option
<
RustTaskCallback
>
*
const
(
)
)
{
self
.
inner
.
lock
(
)
.
unwrap
(
)
.
calls
.
last
(
)
.
cloned
(
)
.
expect
(
"
no
calls
scheduled
"
)
}
pub
fn
run_all_calls
(
&
self
)
{
let
mut
inner
=
self
.
inner
.
lock
(
)
.
unwrap
(
)
;
let
is_shutdown
=
inner
.
is_shutdown
;
for
(
_delay
callback
data
)
in
inner
.
calls
.
drain
(
.
.
)
{
if
!
is_shutdown
{
callback
.
unwrap
(
)
(
data
RustTaskCallbackCode
:
:
Success
)
;
}
else
{
callback
.
unwrap
(
)
(
data
RustTaskCallbackCode
:
:
Cancelled
)
;
}
}
}
pub
fn
shutdown
(
&
self
)
{
self
.
inner
.
lock
(
)
.
unwrap
(
)
.
is_shutdown
=
true
;
}
}
extern
"
C
"
fn
mock_executor_callback
(
handle
:
ForeignExecutorHandle
delay
:
u32
task
:
Option
<
RustTaskCallback
>
task_data
:
*
const
(
)
)
-
>
i8
{
let
eventloop
=
handle
.
0
as
*
const
MockEventLoop
;
let
mut
inner
=
unsafe
{
(
*
eventloop
)
.
inner
.
lock
(
)
.
unwrap
(
)
}
;
if
inner
.
is_shutdown
{
ForeignExecutorCallbackResult
:
:
Cancelled
as
i8
}
else
{
inner
.
calls
.
push
(
(
delay
task
task_data
)
)
;
ForeignExecutorCallbackResult
:
:
Success
as
i8
}
}
#
[
test
]
fn
test_schedule_raw
(
)
{
extern
"
C
"
fn
callback
(
data
:
*
const
(
)
_status_code
:
RustTaskCallbackCode
)
{
unsafe
{
*
(
data
as
*
mut
u32
)
+
=
1
;
}
}
let
eventloop
=
MockEventLoop
:
:
new
(
)
;
let
value
:
u32
=
0
;
assert_eq
!
(
eventloop
.
call_count
(
)
0
)
;
schedule_raw
(
eventloop
.
new_handle
(
)
0
callback
&
value
as
*
const
u32
as
*
const
(
)
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
1
)
;
assert_eq
!
(
value
0
)
;
eventloop
.
run_all_calls
(
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
0
)
;
assert_eq
!
(
value
1
)
;
}
#
[
test
]
fn
test_schedule
(
)
{
let
eventloop
=
MockEventLoop
:
:
new
(
)
;
let
executor
=
eventloop
.
new_executor
(
)
;
let
value
=
Arc
:
:
new
(
AtomicU32
:
:
new
(
0
)
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
0
)
;
let
value2
=
value
.
clone
(
)
;
executor
.
schedule
(
0
move
|
|
{
value2
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
1
)
;
assert_eq
!
(
value
.
load
(
Ordering
:
:
Relaxed
)
0
)
;
eventloop
.
run_all_calls
(
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
0
)
;
assert_eq
!
(
value
.
load
(
Ordering
:
:
Relaxed
)
1
)
;
}
#
[
derive
(
Default
)
]
struct
MockWaker
{
wake_count
:
AtomicU32
}
impl
Wake
for
MockWaker
{
fn
wake
(
self
:
Arc
<
Self
>
)
{
self
.
wake_count
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
}
#
[
test
]
fn
test_run
(
)
{
let
eventloop
=
MockEventLoop
:
:
new
(
)
;
let
executor
=
eventloop
.
new_executor
(
)
;
let
mock_waker
=
Arc
:
:
new
(
MockWaker
:
:
default
(
)
)
;
let
waker
=
Waker
:
:
from
(
mock_waker
.
clone
(
)
)
;
let
mut
context
=
Context
:
:
from_waker
(
&
waker
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
0
)
;
let
mut
future
=
executor
.
run
(
0
move
|
|
"
test
-
return
-
value
"
)
;
unsafe
{
assert_eq
!
(
Pin
:
:
new_unchecked
(
&
mut
future
)
.
poll
(
&
mut
context
)
Poll
:
:
Pending
)
;
}
assert_eq
!
(
eventloop
.
call_count
(
)
1
)
;
assert_eq
!
(
mock_waker
.
wake_count
.
load
(
Ordering
:
:
Relaxed
)
0
)
;
eventloop
.
run_all_calls
(
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
0
)
;
assert_eq
!
(
mock_waker
.
wake_count
.
load
(
Ordering
:
:
Relaxed
)
1
)
;
unsafe
{
assert_eq
!
(
Pin
:
:
new_unchecked
(
&
mut
future
)
.
poll
(
&
mut
context
)
Poll
:
:
Ready
(
"
test
-
return
-
value
"
)
)
;
}
}
#
[
test
]
fn
test_drop
(
)
{
let
eventloop
=
MockEventLoop
:
:
new
(
)
;
let
executor
=
eventloop
.
new_executor
(
)
;
drop
(
executor
)
;
assert_eq
!
(
eventloop
.
call_count
(
)
1
)
;
assert_eq
!
(
eventloop
.
last_call
(
)
.
1
None
)
;
}
#
[
test
]
fn
test_cancelled_call
(
)
{
let
eventloop
=
MockEventLoop
:
:
new
(
)
;
let
executor
=
eventloop
.
new_executor
(
)
;
let
counter
=
Arc
:
:
new
(
AtomicU32
:
:
new
(
0
)
)
;
let
counter_clone
=
Arc
:
:
clone
(
&
counter
)
;
executor
.
schedule
(
0
move
|
|
{
counter_clone
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
)
;
let
counter_clone
=
Arc
:
:
clone
(
&
counter
)
;
let
future
=
executor
.
run
(
0
move
|
|
{
counter_clone
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
)
;
eventloop
.
shutdown
(
)
;
eventloop
.
run_all_calls
(
)
;
assert_eq
!
(
counter
.
load
(
Ordering
:
:
Relaxed
)
0
)
;
drop
(
future
)
;
}
#
[
test
]
fn
test_cancellation_drops_closures
(
)
{
let
eventloop
=
MockEventLoop
:
:
new
(
)
;
let
executor
=
eventloop
.
new_executor
(
)
;
let
arc
=
Arc
:
:
new
(
0
)
;
let
arc_clone
=
Arc
:
:
clone
(
&
arc
)
;
executor
.
schedule
(
0
move
|
|
assert_eq
!
(
*
arc_clone
0
)
)
;
let
arc_clone
=
Arc
:
:
clone
(
&
arc
)
;
let
future
=
executor
.
run
(
0
move
|
|
assert_eq
!
(
*
arc_clone
0
)
)
;
eventloop
.
shutdown
(
)
;
eventloop
.
run_all_calls
(
)
;
let
arc_clone
=
Arc
:
:
clone
(
&
arc
)
;
executor
.
schedule
(
0
move
|
|
assert_eq
!
(
*
arc_clone
0
)
)
;
let
arc_clone
=
Arc
:
:
clone
(
&
arc
)
;
let
future2
=
executor
.
run
(
0
move
|
|
assert_eq
!
(
*
arc_clone
0
)
)
;
drop
(
future
)
;
drop
(
future2
)
;
assert_eq
!
(
Arc
:
:
strong_count
(
&
arc
)
1
)
;
}
}
