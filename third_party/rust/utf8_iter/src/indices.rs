use
super
:
:
Utf8Chars
;
use
core
:
:
iter
:
:
FusedIterator
;
#
[
derive
(
Clone
Debug
)
]
#
[
must_use
=
"
iterators
are
lazy
and
do
nothing
unless
consumed
"
]
pub
struct
Utf8CharIndices
<
'
a
>
{
front_offset
:
usize
iter
:
Utf8Chars
<
'
a
>
}
impl
<
'
a
>
Iterator
for
Utf8CharIndices
<
'
a
>
{
type
Item
=
(
usize
char
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
(
usize
char
)
>
{
let
pre_len
=
self
.
as_slice
(
)
.
len
(
)
;
match
self
.
iter
.
next
(
)
{
None
=
>
None
Some
(
ch
)
=
>
{
let
index
=
self
.
front_offset
;
let
len
=
self
.
as_slice
(
)
.
len
(
)
;
self
.
front_offset
+
=
pre_len
-
len
;
Some
(
(
index
ch
)
)
}
}
}
#
[
inline
]
fn
count
(
self
)
-
>
usize
{
self
.
iter
.
count
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
#
[
inline
]
fn
last
(
mut
self
)
-
>
Option
<
(
usize
char
)
>
{
self
.
next_back
(
)
}
}
impl
<
'
a
>
DoubleEndedIterator
for
Utf8CharIndices
<
'
a
>
{
#
[
inline
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
(
usize
char
)
>
{
self
.
iter
.
next_back
(
)
.
map
(
|
ch
|
{
let
index
=
self
.
front_offset
+
self
.
as_slice
(
)
.
len
(
)
;
(
index
ch
)
}
)
}
}
impl
FusedIterator
for
Utf8CharIndices
<
'
_
>
{
}
impl
<
'
a
>
Utf8CharIndices
<
'
a
>
{
#
[
inline
(
always
)
]
pub
fn
new
(
bytes
:
&
'
a
[
u8
]
)
-
>
Self
{
Utf8CharIndices
:
:
<
'
a
>
{
front_offset
:
0
iter
:
Utf8Chars
:
:
new
(
bytes
)
}
}
#
[
must_use
]
#
[
inline
]
pub
fn
as_slice
(
&
self
)
-
>
&
'
a
[
u8
]
{
self
.
iter
.
as_slice
(
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
offset
(
&
self
)
-
>
usize
{
self
.
front_offset
}
}
