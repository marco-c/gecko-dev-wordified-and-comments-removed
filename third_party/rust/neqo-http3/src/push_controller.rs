use
crate
:
:
client_events
:
:
{
Http3ClientEvent
Http3ClientEvents
}
;
use
crate
:
:
connection
:
:
Http3Connection
;
use
crate
:
:
hframe
:
:
HFrame
;
use
crate
:
:
RecvMessageEvents
;
use
crate
:
:
{
Error
Header
Res
}
;
use
neqo_common
:
:
{
qerror
qinfo
qtrace
}
;
use
neqo_transport
:
:
{
AppError
Connection
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
slice
:
:
SliceIndex
;
#
[
derive
(
Debug
PartialEq
Clone
)
]
enum
PushState
{
Init
PushPromise
{
headers
:
Vec
<
Header
>
}
OnlyPushStream
{
stream_id
:
u64
events
:
Vec
<
Http3ClientEvent
>
}
Active
{
stream_id
:
u64
headers
:
Vec
<
Header
>
}
Closed
}
#
[
derive
(
Debug
)
]
struct
ActivePushStreams
{
push_streams
:
VecDeque
<
PushState
>
first_push_id
:
u64
}
impl
ActivePushStreams
{
pub
fn
new
(
)
-
>
Self
{
Self
{
push_streams
:
VecDeque
:
:
new
(
)
first_push_id
:
0
}
}
pub
fn
get_mut
(
&
mut
self
push_id
:
u64
)
-
>
Option
<
&
mut
<
usize
as
SliceIndex
<
[
PushState
]
>
>
:
:
Output
>
{
if
push_id
<
self
.
first_push_id
{
return
None
;
}
let
inx
=
usize
:
:
try_from
(
push_id
-
self
.
first_push_id
)
.
unwrap
(
)
;
if
inx
>
=
self
.
push_streams
.
len
(
)
{
self
.
push_streams
.
resize
(
inx
+
1
PushState
:
:
Init
)
;
}
match
self
.
push_streams
.
get_mut
(
inx
)
{
Some
(
PushState
:
:
Closed
)
=
>
None
e
=
>
e
}
}
pub
fn
get
(
&
mut
self
push_id
:
u64
)
-
>
Option
<
&
mut
PushState
>
{
self
.
get_mut
(
push_id
)
}
pub
fn
close
(
&
mut
self
push_id
:
u64
)
-
>
Option
<
PushState
>
{
match
self
.
get_mut
(
push_id
)
{
None
|
Some
(
PushState
:
:
Closed
)
=
>
None
Some
(
s
)
=
>
{
let
res
=
mem
:
:
replace
(
s
PushState
:
:
Closed
)
;
while
self
.
push_streams
.
get
(
0
)
.
is_some
(
)
&
&
*
self
.
push_streams
.
get
(
0
)
.
unwrap
(
)
=
=
PushState
:
:
Closed
{
self
.
push_streams
.
pop_front
(
)
;
self
.
first_push_id
+
=
1
;
}
Some
(
res
)
}
}
}
#
[
must_use
]
pub
fn
number_done
(
&
self
)
-
>
u64
{
self
.
first_push_id
+
u64
:
:
try_from
(
self
.
push_streams
.
iter
(
)
.
filter
(
|
&
e
|
e
=
=
&
PushState
:
:
Closed
)
.
count
(
)
)
.
unwrap
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
first_push_id
=
0
;
self
.
push_streams
.
clear
(
)
;
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
PushController
{
max_concurent_push
:
u64
current_max_push_id
:
u64
push_streams
:
ActivePushStreams
conn_events
:
Http3ClientEvents
}
impl
PushController
{
pub
fn
new
(
max_concurent_push
:
u64
conn_events
:
Http3ClientEvents
)
-
>
Self
{
PushController
{
max_concurent_push
current_max_push_id
:
0
push_streams
:
ActivePushStreams
:
:
new
(
)
conn_events
}
}
}
impl
Display
for
PushController
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Push
controler
"
)
}
}
impl
PushController
{
pub
fn
new_push_promise
(
&
mut
self
push_id
:
u64
ref_stream_id
:
u64
new_headers
:
Vec
<
Header
>
)
-
>
Res
<
(
)
>
{
qtrace
!
(
[
self
]
"
New
push
promise
push_id
=
{
}
headers
=
{
:
?
}
max_push
=
{
}
"
push_id
new_headers
self
.
max_concurent_push
)
;
self
.
check_push_id
(
push_id
)
?
;
match
self
.
push_streams
.
get_mut
(
push_id
)
{
None
=
>
{
qtrace
!
(
"
Push
has
been
closed
already
{
}
.
"
push_id
)
;
Ok
(
(
)
)
}
Some
(
push_state
)
=
>
match
push_state
{
PushState
:
:
Init
=
>
{
self
.
conn_events
.
push_promise
(
push_id
ref_stream_id
new_headers
.
clone
(
)
)
;
*
push_state
=
PushState
:
:
PushPromise
{
headers
:
new_headers
}
;
Ok
(
(
)
)
}
PushState
:
:
PushPromise
{
headers
}
|
PushState
:
:
Active
{
headers
.
.
}
=
>
{
if
new_headers
!
=
*
headers
{
return
Err
(
Error
:
:
HttpGeneralProtocol
)
;
}
self
.
conn_events
.
push_promise
(
push_id
ref_stream_id
new_headers
)
;
Ok
(
(
)
)
}
PushState
:
:
OnlyPushStream
{
stream_id
events
}
=
>
{
let
stream_id_tmp
=
*
stream_id
;
self
.
conn_events
.
push_promise
(
push_id
ref_stream_id
new_headers
.
clone
(
)
)
;
for
e
in
events
.
drain
(
.
.
)
{
self
.
conn_events
.
insert
(
e
)
;
}
*
push_state
=
PushState
:
:
Active
{
stream_id
:
stream_id_tmp
headers
:
new_headers
}
;
Ok
(
(
)
)
}
PushState
:
:
Closed
=
>
unreachable
!
(
"
This
is
only
internal
;
it
is
transfer
to
None
"
)
}
}
}
pub
fn
add_new_push_stream
(
&
mut
self
push_id
:
u64
stream_id
:
u64
)
-
>
Res
<
bool
>
{
qtrace
!
(
"
A
new
push
stream
with
push_id
=
{
}
stream_id
=
{
}
"
push_id
stream_id
)
;
self
.
check_push_id
(
push_id
)
?
;
match
self
.
push_streams
.
get_mut
(
push_id
)
{
None
=
>
{
qinfo
!
(
"
Push
has
been
closed
already
.
"
)
;
Ok
(
false
)
}
Some
(
push_state
)
=
>
match
push_state
{
PushState
:
:
Init
=
>
{
*
push_state
=
PushState
:
:
OnlyPushStream
{
stream_id
events
:
Vec
:
:
new
(
)
}
;
Ok
(
true
)
}
PushState
:
:
PushPromise
{
headers
}
=
>
{
let
tmp
=
mem
:
:
replace
(
headers
Vec
:
:
new
(
)
)
;
*
push_state
=
PushState
:
:
Active
{
stream_id
headers
:
tmp
}
;
Ok
(
true
)
}
_
=
>
{
qerror
!
(
"
Duplicate
push
stream
.
"
)
;
Err
(
Error
:
:
HttpId
)
}
}
}
}
fn
check_push_id
(
&
mut
self
push_id
:
u64
)
-
>
Res
<
(
)
>
{
if
push_id
>
self
.
current_max_push_id
{
qerror
!
(
"
Push
id
is
greater
than
current_max_push_id
.
"
)
;
Err
(
Error
:
:
HttpId
)
}
else
{
Ok
(
(
)
)
}
}
pub
fn
handle_cancel_push
(
&
mut
self
push_id
:
u64
conn
:
&
mut
Connection
base_handler
:
&
mut
Http3Connection
)
-
>
Res
<
(
)
>
{
qtrace
!
(
"
CANCEL_PUSH
frame
has
been
received
push_id
=
{
}
"
push_id
)
;
self
.
check_push_id
(
push_id
)
?
;
match
self
.
push_streams
.
close
(
push_id
)
{
None
=
>
{
qtrace
!
(
"
Push
has
already
been
closed
(
push_id
=
{
}
)
.
"
push_id
)
;
Ok
(
(
)
)
}
Some
(
ps
)
=
>
match
ps
{
PushState
:
:
Init
=
>
Ok
(
(
)
)
PushState
:
:
PushPromise
{
.
.
}
=
>
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
self
.
conn_events
.
push_canceled
(
push_id
)
;
Ok
(
(
)
)
}
PushState
:
:
OnlyPushStream
{
stream_id
.
.
}
|
PushState
:
:
Active
{
stream_id
.
.
}
=
>
{
let
_
=
base_handler
.
stream_reset
(
conn
stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
self
.
conn_events
.
push_canceled
(
push_id
)
;
Ok
(
(
)
)
}
PushState
:
:
Closed
=
>
unreachable
!
(
"
This
is
only
internal
;
it
is
transfer
to
None
"
)
}
}
}
pub
fn
close
(
&
mut
self
push_id
:
u64
)
{
qtrace
!
(
"
Push
stream
has
been
closed
.
"
)
;
if
let
Some
(
push_state
)
=
self
.
push_streams
.
close
(
push_id
)
{
debug_assert
!
(
matches
!
(
push_state
PushState
:
:
Active
{
.
.
}
)
)
;
}
else
{
debug_assert
!
(
false
"
Closing
non
existing
push
stream
!
"
)
;
}
}
pub
fn
cancel
(
&
mut
self
push_id
:
u64
conn
:
&
mut
Connection
base_handler
:
&
mut
Http3Connection
)
-
>
Res
<
(
)
>
{
qtrace
!
(
"
Cancel
push_id
=
{
}
"
push_id
)
;
self
.
check_push_id
(
push_id
)
.
map_err
(
|
_
|
Error
:
:
InvalidStreamId
)
?
;
match
self
.
push_streams
.
get
(
push_id
)
{
None
=
>
{
qtrace
!
(
"
Push
has
already
been
closed
.
"
)
;
if
self
.
conn_events
.
has_push
(
push_id
)
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
InvalidStreamId
)
}
}
Some
(
PushState
:
:
PushPromise
{
.
.
}
)
=
>
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
base_handler
.
queue_control_frame
(
&
HFrame
:
:
CancelPush
{
push_id
}
)
;
self
.
push_streams
.
close
(
push_id
)
;
Ok
(
(
)
)
}
Some
(
PushState
:
:
Active
{
stream_id
.
.
}
)
=
>
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
let
_
=
base_handler
.
stream_reset
(
conn
*
stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
self
.
push_streams
.
close
(
push_id
)
;
Ok
(
(
)
)
}
_
=
>
Err
(
Error
:
:
InvalidStreamId
)
}
}
pub
fn
push_stream_reset
(
&
mut
self
push_id
:
u64
)
{
qtrace
!
(
"
Push
stream
has
been
reset
push_id
=
{
}
"
push_id
)
;
if
let
Some
(
push_state
)
=
self
.
push_streams
.
get
(
push_id
)
{
match
push_state
{
PushState
:
:
OnlyPushStream
{
.
.
}
=
>
{
self
.
push_streams
.
close
(
push_id
)
;
}
PushState
:
:
Active
{
.
.
}
=
>
{
self
.
push_streams
.
close
(
push_id
)
;
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
self
.
conn_events
.
push_canceled
(
push_id
)
;
}
_
=
>
{
debug_assert
!
(
false
"
Reset
cannot
actually
happen
because
we
do
not
have
a
stream
.
"
)
;
}
}
}
}
pub
fn
get_active_stream_id
(
&
mut
self
push_id
:
u64
)
-
>
Option
<
u64
>
{
match
self
.
push_streams
.
get
(
push_id
)
{
Some
(
PushState
:
:
Active
{
stream_id
.
.
}
)
=
>
Some
(
*
stream_id
)
_
=
>
None
}
}
pub
fn
maybe_send_max_push_id_frame
(
&
mut
self
base_handler
:
&
mut
Http3Connection
)
{
let
push_done
=
self
.
push_streams
.
number_done
(
)
;
if
self
.
max_concurent_push
>
0
&
&
(
self
.
current_max_push_id
-
push_done
)
<
=
(
self
.
max_concurent_push
/
2
)
{
self
.
current_max_push_id
=
push_done
+
self
.
max_concurent_push
;
base_handler
.
queue_control_frame
(
&
HFrame
:
:
MaxPushId
{
push_id
:
self
.
current_max_push_id
}
)
;
}
}
pub
fn
handle_zero_rtt_rejected
(
&
mut
self
)
{
self
.
current_max_push_id
=
0
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
push_streams
.
clear
(
)
;
}
pub
fn
can_receive_push
(
&
self
)
-
>
bool
{
self
.
max_concurent_push
>
0
}
pub
fn
new_stream_event
(
&
mut
self
push_id
:
u64
event
:
Http3ClientEvent
)
{
match
self
.
push_streams
.
get_mut
(
push_id
)
{
None
=
>
{
debug_assert
!
(
false
"
Push
has
been
closed
already
.
"
)
;
}
Some
(
PushState
:
:
OnlyPushStream
{
events
.
.
}
)
=
>
{
events
.
push
(
event
)
;
}
Some
(
PushState
:
:
Active
{
.
.
}
)
=
>
{
self
.
conn_events
.
insert
(
event
)
;
}
_
=
>
{
debug_assert
!
(
false
"
No
record
of
a
stream
!
"
)
;
}
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
RecvPushEvents
{
push_id
:
u64
push_handler
:
Rc
<
RefCell
<
PushController
>
>
}
impl
RecvPushEvents
{
pub
fn
new
(
push_id
:
u64
push_handler
:
Rc
<
RefCell
<
PushController
>
>
)
-
>
Self
{
Self
{
push_id
push_handler
}
}
}
impl
RecvMessageEvents
for
RecvPushEvents
{
fn
header_ready
(
&
self
_stream_id
:
u64
headers
:
Option
<
Vec
<
Header
>
>
fin
:
bool
)
{
self
.
push_handler
.
borrow_mut
(
)
.
new_stream_event
(
self
.
push_id
Http3ClientEvent
:
:
PushHeaderReady
{
push_id
:
self
.
push_id
headers
fin
}
)
;
}
fn
data_readable
(
&
self
_stream_id
:
u64
)
{
self
.
push_handler
.
borrow_mut
(
)
.
new_stream_event
(
self
.
push_id
Http3ClientEvent
:
:
PushDataReadable
{
push_id
:
self
.
push_id
}
)
;
}
fn
reset
(
&
self
_stream_id
:
u64
_error
:
AppError
)
{
}
}
