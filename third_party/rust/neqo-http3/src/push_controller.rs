use
std
:
:
{
cell
:
:
RefCell
collections
:
:
VecDeque
fmt
:
:
{
self
Debug
Display
Formatter
}
mem
rc
:
:
Rc
slice
:
:
SliceIndex
}
;
use
neqo_common
:
:
{
qerror
qinfo
qtrace
Header
}
;
use
neqo_transport
:
:
{
Connection
StreamId
}
;
use
crate
:
:
{
client_events
:
:
{
Http3ClientEvent
Http3ClientEvents
}
connection
:
:
Http3Connection
frames
:
:
HFrame
CloseType
Error
Http3StreamInfo
HttpRecvStreamEvents
PushId
RecvStreamEvents
Res
}
;
#
[
derive
(
Debug
PartialEq
Clone
)
]
enum
PushState
{
Init
PushPromise
{
headers
:
Vec
<
Header
>
}
OnlyPushStream
{
stream_id
:
StreamId
events
:
Vec
<
Http3ClientEvent
>
}
Active
{
stream_id
:
StreamId
headers
:
Vec
<
Header
>
}
Closed
}
#
[
derive
(
Debug
)
]
struct
ActivePushStreams
{
push_streams
:
VecDeque
<
PushState
>
first_push_id
:
PushId
}
impl
ActivePushStreams
{
pub
const
fn
new
(
)
-
>
Self
{
Self
{
push_streams
:
VecDeque
:
:
new
(
)
first_push_id
:
PushId
:
:
new
(
0
)
}
}
pub
fn
get_mut
(
&
mut
self
push_id
:
PushId
)
-
>
Option
<
&
mut
<
usize
as
SliceIndex
<
[
PushState
]
>
>
:
:
Output
>
{
if
push_id
<
self
.
first_push_id
{
return
None
;
}
let
inx
=
usize
:
:
try_from
(
u64
:
:
from
(
push_id
-
self
.
first_push_id
)
)
.
ok
(
)
?
;
if
inx
>
=
self
.
push_streams
.
len
(
)
{
self
.
push_streams
.
resize
(
inx
+
1
PushState
:
:
Init
)
;
}
match
self
.
push_streams
.
get_mut
(
inx
)
{
Some
(
PushState
:
:
Closed
)
=
>
None
e
=
>
e
}
}
pub
fn
get
(
&
mut
self
push_id
:
PushId
)
-
>
Option
<
&
mut
PushState
>
{
self
.
get_mut
(
push_id
)
}
pub
fn
close
(
&
mut
self
push_id
:
PushId
)
-
>
Option
<
PushState
>
{
match
self
.
get_mut
(
push_id
)
{
None
|
Some
(
PushState
:
:
Closed
)
=
>
None
Some
(
s
)
=
>
{
let
res
=
mem
:
:
replace
(
s
PushState
:
:
Closed
)
;
while
self
.
push_streams
.
front
(
)
=
=
Some
(
&
PushState
:
:
Closed
)
{
self
.
push_streams
.
pop_front
(
)
;
self
.
first_push_id
.
next
(
)
;
}
Some
(
res
)
}
}
}
#
[
must_use
]
pub
fn
number_done
(
&
self
)
-
>
PushId
{
self
.
first_push_id
+
u64
:
:
try_from
(
self
.
push_streams
.
iter
(
)
.
filter
(
|
&
e
|
e
=
=
&
PushState
:
:
Closed
)
.
count
(
)
)
.
expect
(
"
usize
fits
in
u64
"
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
first_push_id
=
PushId
:
:
new
(
0
)
;
self
.
push_streams
.
clear
(
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
PushController
{
max_concurent_push
:
u64
current_max_push_id
:
PushId
push_streams
:
ActivePushStreams
conn_events
:
Http3ClientEvents
}
impl
Display
for
PushController
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Push
controller
"
)
}
}
impl
PushController
{
pub
const
fn
new
(
max_concurent_push
:
u64
conn_events
:
Http3ClientEvents
)
-
>
Self
{
Self
{
max_concurent_push
current_max_push_id
:
PushId
:
:
new
(
0
)
push_streams
:
ActivePushStreams
:
:
new
(
)
conn_events
}
}
pub
fn
new_push_promise
(
&
mut
self
push_id
:
PushId
ref_stream_id
:
StreamId
new_headers
:
Vec
<
Header
>
)
-
>
Res
<
(
)
>
{
qtrace
!
(
"
[
{
self
}
]
New
push
promise
push_id
=
{
push_id
}
headers
=
{
new_headers
:
?
}
max_push
=
{
}
"
self
.
max_concurent_push
)
;
self
.
check_push_id
(
push_id
)
?
;
match
self
.
push_streams
.
get_mut
(
push_id
)
{
None
=
>
{
qtrace
!
(
"
Push
has
been
closed
already
{
push_id
}
"
)
;
Ok
(
(
)
)
}
Some
(
push_state
)
=
>
match
push_state
{
PushState
:
:
Init
=
>
{
self
.
conn_events
.
push_promise
(
push_id
ref_stream_id
new_headers
.
clone
(
)
)
;
*
push_state
=
PushState
:
:
PushPromise
{
headers
:
new_headers
}
;
Ok
(
(
)
)
}
PushState
:
:
PushPromise
{
headers
}
|
PushState
:
:
Active
{
headers
.
.
}
=
>
{
if
new_headers
!
=
*
headers
{
return
Err
(
Error
:
:
HttpGeneralProtocol
)
;
}
self
.
conn_events
.
push_promise
(
push_id
ref_stream_id
new_headers
)
;
Ok
(
(
)
)
}
PushState
:
:
OnlyPushStream
{
stream_id
events
}
=
>
{
let
stream_id_tmp
=
*
stream_id
;
self
.
conn_events
.
push_promise
(
push_id
ref_stream_id
new_headers
.
clone
(
)
)
;
for
e
in
events
.
drain
(
.
.
)
{
self
.
conn_events
.
insert
(
e
)
;
}
*
push_state
=
PushState
:
:
Active
{
stream_id
:
stream_id_tmp
headers
:
new_headers
}
;
Ok
(
(
)
)
}
PushState
:
:
Closed
=
>
unreachable
!
(
"
This
is
only
internal
;
it
is
transfer
to
None
"
)
}
}
}
pub
fn
add_new_push_stream
(
&
mut
self
push_id
:
PushId
stream_id
:
StreamId
)
-
>
Res
<
bool
>
{
qtrace
!
(
"
A
new
push
stream
with
push_id
=
{
push_id
}
stream_id
=
{
stream_id
}
"
)
;
self
.
check_push_id
(
push_id
)
?
;
self
.
push_streams
.
get_mut
(
push_id
)
.
map_or_else
(
|
|
{
qinfo
!
(
"
Push
has
been
closed
already
"
)
;
Ok
(
false
)
}
|
push_state
|
match
push_state
{
PushState
:
:
Init
=
>
{
*
push_state
=
PushState
:
:
OnlyPushStream
{
stream_id
events
:
Vec
:
:
new
(
)
}
;
Ok
(
true
)
}
PushState
:
:
PushPromise
{
headers
}
=
>
{
let
tmp
=
mem
:
:
take
(
headers
)
;
*
push_state
=
PushState
:
:
Active
{
stream_id
headers
:
tmp
}
;
Ok
(
true
)
}
_
=
>
{
qerror
!
(
"
Duplicate
push
stream
"
)
;
Err
(
Error
:
:
HttpId
)
}
}
)
}
fn
check_push_id
(
&
self
push_id
:
PushId
)
-
>
Res
<
(
)
>
{
if
push_id
>
self
.
current_max_push_id
{
qerror
!
(
"
Push
id
is
greater
than
current_max_push_id
"
)
;
Err
(
Error
:
:
HttpId
)
}
else
{
Ok
(
(
)
)
}
}
pub
fn
handle_cancel_push
(
&
mut
self
push_id
:
PushId
conn
:
&
mut
Connection
base_handler
:
&
mut
Http3Connection
)
-
>
Res
<
(
)
>
{
qtrace
!
(
"
CANCEL_PUSH
frame
has
been
received
push_id
=
{
push_id
}
"
)
;
self
.
check_push_id
(
push_id
)
?
;
match
self
.
push_streams
.
close
(
push_id
)
{
None
=
>
{
qtrace
!
(
"
Push
has
already
been
closed
(
push_id
=
{
push_id
}
)
"
)
;
Ok
(
(
)
)
}
Some
(
ps
)
=
>
match
ps
{
PushState
:
:
Init
=
>
Ok
(
(
)
)
PushState
:
:
PushPromise
{
.
.
}
=
>
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
self
.
conn_events
.
push_canceled
(
push_id
)
;
Ok
(
(
)
)
}
PushState
:
:
OnlyPushStream
{
stream_id
.
.
}
|
PushState
:
:
Active
{
stream_id
.
.
}
=
>
{
drop
(
base_handler
.
stream_stop_sending
(
conn
stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
)
;
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
self
.
conn_events
.
push_canceled
(
push_id
)
;
Ok
(
(
)
)
}
PushState
:
:
Closed
=
>
unreachable
!
(
"
This
is
only
internal
;
it
is
transfer
to
None
"
)
}
}
}
pub
fn
close
(
&
mut
self
push_id
:
PushId
)
{
qtrace
!
(
"
Push
stream
has
been
closed
"
)
;
if
let
Some
(
push_state
)
=
self
.
push_streams
.
close
(
push_id
)
{
debug_assert
!
(
matches
!
(
push_state
PushState
:
:
Active
{
.
.
}
)
)
;
}
else
{
debug_assert
!
(
false
"
Closing
non
existing
push
stream
!
"
)
;
}
}
pub
fn
cancel
(
&
mut
self
push_id
:
PushId
conn
:
&
mut
Connection
base_handler
:
&
mut
Http3Connection
)
-
>
Res
<
(
)
>
{
qtrace
!
(
"
Cancel
push_id
=
{
push_id
}
"
)
;
self
.
check_push_id
(
push_id
)
?
;
match
self
.
push_streams
.
get
(
push_id
)
{
None
=
>
{
qtrace
!
(
"
Push
has
already
been
closed
"
)
;
if
self
.
conn_events
.
has_push
(
push_id
)
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
InvalidStreamId
)
}
}
Some
(
PushState
:
:
PushPromise
{
.
.
}
)
=
>
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
base_handler
.
queue_control_frame
(
&
HFrame
:
:
CancelPush
{
push_id
}
)
;
self
.
push_streams
.
close
(
push_id
)
;
Ok
(
(
)
)
}
Some
(
PushState
:
:
Active
{
stream_id
.
.
}
)
=
>
{
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
drop
(
base_handler
.
stream_stop_sending
(
conn
*
stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
)
;
self
.
push_streams
.
close
(
push_id
)
;
Ok
(
(
)
)
}
Some
(
_
)
=
>
Err
(
Error
:
:
InvalidStreamId
)
}
}
pub
fn
push_stream_reset
(
&
mut
self
push_id
:
PushId
close_type
:
CloseType
)
{
qtrace
!
(
"
Push
stream
has
been
reset
push_id
=
{
push_id
}
"
)
;
if
let
Some
(
push_state
)
=
self
.
push_streams
.
get
(
push_id
)
{
match
push_state
{
PushState
:
:
OnlyPushStream
{
.
.
}
=
>
{
self
.
push_streams
.
close
(
push_id
)
;
}
PushState
:
:
Active
{
.
.
}
=
>
{
self
.
push_streams
.
close
(
push_id
)
;
self
.
conn_events
.
remove_events_for_push_id
(
push_id
)
;
if
let
CloseType
:
:
LocalError
(
app_error
)
=
close_type
{
self
.
conn_events
.
push_reset
(
push_id
app_error
)
;
}
else
{
self
.
conn_events
.
push_canceled
(
push_id
)
;
}
}
_
=
>
{
debug_assert
!
(
false
"
Reset
cannot
actually
happen
because
we
do
not
have
a
stream
"
)
;
}
}
}
}
pub
fn
get_active_stream_id
(
&
mut
self
push_id
:
PushId
)
-
>
Option
<
StreamId
>
{
match
self
.
push_streams
.
get
(
push_id
)
{
Some
(
PushState
:
:
Active
{
stream_id
.
.
}
)
=
>
Some
(
*
stream_id
)
_
=
>
None
}
}
pub
fn
maybe_send_max_push_id_frame
(
&
mut
self
base_handler
:
&
mut
Http3Connection
)
{
let
push_done
=
self
.
push_streams
.
number_done
(
)
;
if
self
.
max_concurent_push
>
0
&
&
(
self
.
current_max_push_id
-
push_done
)
<
=
(
self
.
max_concurent_push
/
2
)
.
into
(
)
{
self
.
current_max_push_id
=
push_done
+
self
.
max_concurent_push
;
base_handler
.
queue_control_frame
(
&
HFrame
:
:
MaxPushId
{
push_id
:
self
.
current_max_push_id
}
)
;
}
}
pub
fn
handle_zero_rtt_rejected
(
&
mut
self
)
{
self
.
current_max_push_id
=
PushId
:
:
new
(
0
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
push_streams
.
clear
(
)
;
}
pub
const
fn
can_receive_push
(
&
self
)
-
>
bool
{
self
.
max_concurent_push
>
0
}
pub
fn
new_stream_event
(
&
mut
self
push_id
:
PushId
event
:
Http3ClientEvent
)
{
match
self
.
push_streams
.
get_mut
(
push_id
)
{
None
=
>
{
debug_assert
!
(
false
"
Push
has
been
closed
already
"
)
;
}
Some
(
PushState
:
:
OnlyPushStream
{
events
.
.
}
)
=
>
{
events
.
push
(
event
)
;
}
Some
(
PushState
:
:
Active
{
.
.
}
)
=
>
{
self
.
conn_events
.
insert
(
event
)
;
}
Some
(
_
)
=
>
{
debug_assert
!
(
false
"
No
record
of
a
stream
!
"
)
;
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
RecvPushEvents
{
push_id
:
PushId
push_handler
:
Rc
<
RefCell
<
PushController
>
>
}
impl
RecvPushEvents
{
pub
const
fn
new
(
push_id
:
PushId
push_handler
:
Rc
<
RefCell
<
PushController
>
>
)
-
>
Self
{
Self
{
push_id
push_handler
}
}
}
impl
RecvStreamEvents
for
RecvPushEvents
{
fn
data_readable
(
&
self
_stream_info
:
&
Http3StreamInfo
)
{
self
.
push_handler
.
borrow_mut
(
)
.
new_stream_event
(
self
.
push_id
Http3ClientEvent
:
:
PushDataReadable
{
push_id
:
self
.
push_id
}
)
;
}
fn
recv_closed
(
&
self
_stream_info
:
&
Http3StreamInfo
close_type
:
CloseType
)
{
match
close_type
{
CloseType
:
:
ResetApp
(
_
)
=
>
{
}
CloseType
:
:
ResetRemote
(
_
)
|
CloseType
:
:
LocalError
(
_
)
=
>
self
.
push_handler
.
borrow_mut
(
)
.
push_stream_reset
(
self
.
push_id
close_type
)
CloseType
:
:
Done
=
>
self
.
push_handler
.
borrow_mut
(
)
.
close
(
self
.
push_id
)
}
}
}
impl
HttpRecvStreamEvents
for
RecvPushEvents
{
fn
header_ready
(
&
self
_stream_info
:
&
Http3StreamInfo
headers
:
Vec
<
Header
>
interim
:
bool
fin
:
bool
)
{
self
.
push_handler
.
borrow_mut
(
)
.
new_stream_event
(
self
.
push_id
Http3ClientEvent
:
:
PushHeaderReady
{
push_id
:
self
.
push_id
headers
interim
fin
}
)
;
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
tests
{
use
super
:
:
{
Http3ClientEvents
PushController
}
;
#
[
test
]
fn
can_receive_push
(
)
{
let
events
=
Http3ClientEvents
:
:
default
(
)
;
let
disabled
=
PushController
:
:
new
(
0
events
.
clone
(
)
)
;
assert
!
(
!
disabled
.
can_receive_push
(
)
)
;
let
enabled
=
PushController
:
:
new
(
1
events
)
;
assert
!
(
enabled
.
can_receive_push
(
)
)
;
}
}
