#
!
[
cfg_attr
(
coverage_nightly
feature
(
coverage_attribute
)
)
]
mod
buffered_send_stream
;
mod
client_events
;
mod
conn_params
;
mod
connection
;
mod
connection_client
;
mod
connection_server
;
mod
control_stream_local
;
mod
control_stream_remote
;
pub
mod
features
;
#
[
cfg
(
fuzzing
)
]
pub
mod
frames
;
#
[
cfg
(
not
(
fuzzing
)
)
]
mod
frames
;
mod
headers_checks
;
mod
priority
;
mod
push_controller
;
mod
push_id
;
mod
qlog
;
mod
qpack_decoder_receiver
;
mod
qpack_encoder_receiver
;
mod
recv_message
;
mod
request_target
;
mod
send_message
;
mod
server
;
mod
server_connection_events
;
mod
server_events
;
mod
settings
;
mod
stream_type_reader
;
use
std
:
:
{
cell
:
:
RefCell
fmt
:
:
Debug
rc
:
:
Rc
time
:
:
Instant
}
;
use
buffered_send_stream
:
:
BufferedStream
;
pub
use
client_events
:
:
{
ConnectUdpEvent
Http3ClientEvent
WebTransportEvent
}
;
pub
use
conn_params
:
:
Http3Parameters
;
pub
use
connection
:
:
{
Http3State
SessionAcceptAction
}
;
pub
use
connection_client
:
:
Http3Client
;
use
frames
:
:
HFrame
;
pub
use
neqo_common
:
:
Header
;
use
neqo_common
:
:
MessageType
;
use
neqo_qpack
:
:
Error
as
QpackError
;
use
neqo_transport
:
:
{
recv_stream
send_stream
AppError
Connection
Error
as
TransportError
}
;
pub
use
neqo_transport
:
:
{
streams
:
:
SendOrder
Output
StreamId
}
;
pub
use
priority
:
:
Priority
;
pub
use
push_id
:
:
PushId
;
pub
use
server
:
:
Http3Server
;
pub
use
server_events
:
:
{
ConnectUdpRequest
ConnectUdpServerEvent
Http3OrWebTransportStream
Http3ServerEvent
WebTransportRequest
WebTransportServerEvent
}
;
#
[
cfg
(
fuzzing
)
]
pub
use
settings
:
:
HSettings
;
use
stream_type_reader
:
:
NewStreamType
;
use
thiserror
:
:
Error
;
use
crate
:
:
{
features
:
:
extended_connect
priority
:
:
PriorityHandler
}
;
type
Res
<
T
>
=
Result
<
T
Error
>
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
Error
)
]
pub
enum
Error
{
#
[
error
(
"
HTTP
no
error
"
)
]
HttpNone
#
[
error
(
"
HTTP
general
protocol
error
"
)
]
HttpGeneralProtocol
#
[
error
(
"
HTTP
protocol
error
on
stream
"
)
]
HttpGeneralProtocolStream
#
[
error
(
"
HTTP
internal
error
:
{
0
}
"
)
]
HttpInternal
(
u16
)
#
[
error
(
"
HTTP
stream
creation
error
"
)
]
HttpStreamCreation
#
[
error
(
"
HTTP
closed
critical
stream
"
)
]
HttpClosedCriticalStream
#
[
error
(
"
HTTP
unexpected
frame
"
)
]
HttpFrameUnexpected
#
[
error
(
"
HTTP
frame
error
"
)
]
HttpFrame
#
[
error
(
"
HTTP
excessive
load
"
)
]
HttpExcessiveLoad
#
[
error
(
"
HTTP
ID
error
"
)
]
HttpId
#
[
error
(
"
HTTP
settings
error
"
)
]
HttpSettings
#
[
error
(
"
HTTP
missing
settings
"
)
]
HttpMissingSettings
#
[
error
(
"
HTTP
request
rejected
"
)
]
HttpRequestRejected
#
[
error
(
"
HTTP
request
cancelled
"
)
]
HttpRequestCancelled
#
[
error
(
"
HTTP
request
incomplete
"
)
]
HttpRequestIncomplete
#
[
error
(
"
HTTP
connect
error
"
)
]
HttpConnect
#
[
error
(
"
HTTP
version
fallback
"
)
]
HttpVersionFallback
#
[
error
(
"
HTTP
message
error
"
)
]
HttpMessage
#
[
error
(
"
QPACK
error
:
{
0
}
"
)
]
Qpack
(
#
[
source
]
neqo_qpack
:
:
Error
)
#
[
error
(
"
Already
closed
"
)
]
AlreadyClosed
#
[
error
(
"
Already
initialized
"
)
]
AlreadyInitialized
#
[
error
(
"
Fatal
error
"
)
]
Fatal
#
[
error
(
"
HTTP
GOAWAY
received
"
)
]
HttpGoaway
#
[
error
(
"
Internal
error
"
)
]
Internal
#
[
error
(
"
Invalid
header
"
)
]
InvalidHeader
#
[
error
(
"
Invalid
input
"
)
]
InvalidInput
#
[
error
(
"
Invalid
request
target
"
)
]
InvalidRequestTarget
#
[
error
(
"
Invalid
resumption
token
"
)
]
InvalidResumptionToken
#
[
error
(
"
Invalid
state
"
)
]
InvalidState
#
[
error
(
"
Invalid
stream
ID
"
)
]
InvalidStreamId
#
[
error
(
"
No
more
data
"
)
]
NoMoreData
#
[
error
(
"
Not
enough
data
"
)
]
NotEnoughData
#
[
error
(
"
Stream
limit
reached
"
)
]
StreamLimit
#
[
error
(
"
Transport
error
:
{
0
}
"
)
]
Transport
(
#
[
from
]
#
[
source
]
TransportError
)
#
[
error
(
"
Transport
stream
does
not
exist
"
)
]
TransportStreamDoesNotExist
#
[
error
(
"
Operation
unavailable
"
)
]
Unavailable
#
[
error
(
"
Unexpected
condition
"
)
]
Unexpected
}
impl
Error
{
#
[
must_use
]
pub
const
fn
code
(
&
self
)
-
>
AppError
{
match
self
{
Self
:
:
HttpNone
=
>
0x100
Self
:
:
HttpGeneralProtocol
|
Self
:
:
HttpGeneralProtocolStream
|
Self
:
:
InvalidHeader
=
>
{
0x101
}
Self
:
:
HttpInternal
(
.
.
)
=
>
0x102
Self
:
:
HttpStreamCreation
=
>
0x103
Self
:
:
HttpClosedCriticalStream
=
>
0x104
Self
:
:
HttpFrameUnexpected
=
>
0x105
Self
:
:
HttpFrame
=
>
0x106
Self
:
:
HttpExcessiveLoad
=
>
0x107
Self
:
:
HttpId
=
>
0x108
Self
:
:
HttpSettings
=
>
0x109
Self
:
:
HttpMissingSettings
=
>
0x10a
Self
:
:
HttpRequestRejected
=
>
0x10b
Self
:
:
HttpRequestCancelled
=
>
0x10c
Self
:
:
HttpRequestIncomplete
=
>
0x10d
Self
:
:
HttpMessage
=
>
0x10e
Self
:
:
HttpConnect
=
>
0x10f
Self
:
:
HttpVersionFallback
=
>
0x110
Self
:
:
Qpack
(
e
)
=
>
e
.
code
(
)
_
=
>
3
}
}
#
[
must_use
]
pub
const
fn
connection_error
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
HttpGeneralProtocol
|
Self
:
:
HttpInternal
(
.
.
)
|
Self
:
:
HttpStreamCreation
|
Self
:
:
HttpClosedCriticalStream
|
Self
:
:
HttpFrameUnexpected
|
Self
:
:
HttpFrame
|
Self
:
:
HttpExcessiveLoad
|
Self
:
:
HttpId
|
Self
:
:
HttpSettings
|
Self
:
:
HttpMissingSettings
|
Self
:
:
Qpack
(
QpackError
:
:
EncoderStream
|
QpackError
:
:
DecoderStream
)
)
}
#
[
must_use
]
pub
const
fn
stream_reset_error
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
HttpGeneralProtocolStream
|
Self
:
:
InvalidHeader
)
}
#
[
must_use
]
pub
fn
map_stream_send_errors
(
err
:
&
Self
)
-
>
Self
{
match
err
{
Self
:
:
Transport
(
TransportError
:
:
InvalidStreamId
|
TransportError
:
:
FinalSize
)
=
>
{
Self
:
:
TransportStreamDoesNotExist
}
Self
:
:
Transport
(
TransportError
:
:
InvalidInput
)
=
>
Self
:
:
InvalidInput
_
=
>
{
debug_assert
!
(
false
"
Unexpected
error
"
)
;
Self
:
:
TransportStreamDoesNotExist
}
}
}
#
[
must_use
]
pub
fn
map_stream_create_errors
(
err
:
&
TransportError
)
-
>
Self
{
match
err
{
TransportError
:
:
ConnectionState
=
>
Self
:
:
Unavailable
TransportError
:
:
StreamLimit
=
>
Self
:
:
StreamLimit
_
=
>
{
debug_assert
!
(
false
"
Unexpected
error
"
)
;
Self
:
:
TransportStreamDoesNotExist
}
}
}
#
[
must_use
]
pub
fn
map_stream_recv_errors
(
err
:
&
Self
)
-
>
Self
{
match
err
{
Self
:
:
Transport
(
TransportError
:
:
NoMoreData
)
=
>
{
debug_assert
!
(
false
"
Do
not
call
stream_recv
if
FIN
has
been
previously
read
"
)
;
}
Self
:
:
Transport
(
TransportError
:
:
InvalidStreamId
)
=
>
{
}
_
=
>
{
debug_assert
!
(
false
"
Unexpected
error
"
)
;
}
}
Self
:
:
TransportStreamDoesNotExist
}
fn
map_error
<
R
>
(
r
:
Result
<
R
impl
Into
<
Self
>
>
err
:
Self
)
-
>
Result
<
R
Self
>
{
r
.
map_err
(
|
e
|
{
debug_assert
!
(
!
matches
!
(
e
.
into
(
)
Self
:
:
HttpInternal
(
.
.
)
)
)
;
debug_assert
!
(
!
matches
!
(
err
Self
:
:
HttpInternal
(
.
.
)
)
)
;
err
}
)
}
}
impl
From
<
QpackError
>
for
Error
{
fn
from
(
err
:
QpackError
)
-
>
Self
{
match
err
{
QpackError
:
:
ClosedCriticalStream
=
>
Self
:
:
HttpClosedCriticalStream
e
=
>
Self
:
:
Qpack
(
e
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
Http3StreamType
{
Control
Decoder
Encoder
NewStream
Http
Push
ExtendedConnect
WebTransport
(
StreamId
)
Unknown
}
#
[
must_use
]
#
[
derive
(
Default
PartialEq
Eq
Debug
)
]
enum
ReceiveOutput
{
#
[
default
]
NoOutput
ControlFrames
(
Vec
<
HFrame
>
)
UnblockedStreams
(
Vec
<
StreamId
>
)
NewStream
(
NewStreamType
)
}
trait
Stream
:
Debug
{
fn
stream_type
(
&
self
)
-
>
Http3StreamType
;
}
trait
RecvStream
:
Stream
{
fn
receive
(
&
mut
self
conn
:
&
mut
Connection
now
:
Instant
)
-
>
Res
<
(
ReceiveOutput
bool
)
>
;
fn
reset
(
&
mut
self
close_type
:
CloseType
)
-
>
Res
<
(
)
>
;
fn
read_data
(
&
mut
self
_conn
:
&
mut
Connection
_buf
:
&
mut
[
u8
]
_now
:
Instant
)
-
>
Res
<
(
usize
bool
)
>
{
Err
(
Error
:
:
InvalidStreamId
)
}
fn
http_stream
(
&
mut
self
)
-
>
Option
<
&
mut
dyn
HttpRecvStream
>
{
None
}
fn
extended_connect_session
(
&
self
)
-
>
Option
<
Rc
<
RefCell
<
extended_connect
:
:
session
:
:
Session
>
>
>
{
None
}
fn
stats
(
&
mut
self
_conn
:
&
mut
Connection
)
-
>
Res
<
recv_stream
:
:
Stats
>
{
Err
(
Error
:
:
Unavailable
)
}
}
trait
HttpRecvStream
:
RecvStream
{
fn
header_unblocked
(
&
mut
self
conn
:
&
mut
Connection
now
:
Instant
)
-
>
Res
<
(
ReceiveOutput
bool
)
>
;
fn
maybe_update_priority
(
&
mut
self
priority
:
Priority
)
-
>
Res
<
bool
>
;
fn
priority_update_frame
(
&
mut
self
)
-
>
Option
<
HFrame
>
;
fn
priority_update_sent
(
&
mut
self
)
-
>
Res
<
(
)
>
;
fn
set_new_listener
(
&
mut
self
_conn_events
:
Box
<
dyn
HttpRecvStreamEvents
>
)
{
}
fn
extended_connect_wait_for_response
(
&
self
)
-
>
bool
{
false
}
}
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
pub
struct
Http3StreamInfo
{
stream_id
:
StreamId
stream_type
:
Http3StreamType
}
impl
Http3StreamInfo
{
#
[
must_use
]
pub
const
fn
new
(
stream_id
:
StreamId
stream_type
:
Http3StreamType
)
-
>
Self
{
Self
{
stream_id
stream_type
}
}
#
[
must_use
]
pub
const
fn
stream_id
(
&
self
)
-
>
StreamId
{
self
.
stream_id
}
#
[
must_use
]
pub
const
fn
session_id
(
&
self
)
-
>
Option
<
StreamId
>
{
if
let
Http3StreamType
:
:
WebTransport
(
session
)
=
self
.
stream_type
{
Some
(
session
)
}
else
{
None
}
}
#
[
must_use
]
pub
fn
is_http
(
&
self
)
-
>
bool
{
self
.
stream_type
=
=
Http3StreamType
:
:
Http
}
}
trait
RecvStreamEvents
:
Debug
{
fn
data_readable
(
&
self
_stream_info
:
&
Http3StreamInfo
)
{
}
fn
recv_closed
(
&
self
_stream_info
:
&
Http3StreamInfo
_close_type
:
CloseType
)
{
}
}
trait
HttpRecvStreamEvents
:
RecvStreamEvents
{
fn
header_ready
(
&
self
stream_info
:
&
Http3StreamInfo
headers
:
Vec
<
Header
>
interim
:
bool
fin
:
bool
)
;
fn
extended_connect_new_session
(
&
self
_stream_id
:
StreamId
_headers
:
Vec
<
Header
>
)
{
}
}
trait
SendStream
:
Stream
{
fn
send
(
&
mut
self
conn
:
&
mut
Connection
now
:
Instant
)
-
>
Res
<
(
)
>
;
fn
has_data_to_send
(
&
self
)
-
>
bool
;
fn
stream_writable
(
&
self
)
;
fn
done
(
&
self
)
-
>
bool
;
fn
send_data
(
&
mut
self
_conn
:
&
mut
Connection
_buf
:
&
[
u8
]
now
:
Instant
)
-
>
Res
<
usize
>
;
fn
close
(
&
mut
self
conn
:
&
mut
Connection
now
:
Instant
)
-
>
Res
<
(
)
>
;
fn
close_with_message
(
&
mut
self
_conn
:
&
mut
Connection
_error
:
u32
_message
:
&
str
_now
:
Instant
)
-
>
Res
<
(
)
>
{
Err
(
Error
:
:
InvalidStreamId
)
}
fn
handle_stop_sending
(
&
mut
self
close_type
:
CloseType
)
;
fn
http_stream
(
&
mut
self
)
-
>
Option
<
&
mut
dyn
HttpSendStream
>
{
None
}
fn
send_data_atomic
(
&
mut
self
_conn
:
&
mut
Connection
_buf
:
&
[
u8
]
_now
:
Instant
)
-
>
Res
<
(
)
>
{
Err
(
Error
:
:
InvalidStreamId
)
}
fn
stats
(
&
mut
self
_conn
:
&
mut
Connection
)
-
>
Res
<
send_stream
:
:
Stats
>
{
Err
(
Error
:
:
Unavailable
)
}
}
trait
HttpSendStream
:
SendStream
{
fn
send_headers
(
&
mut
self
headers
:
&
[
Header
]
conn
:
&
mut
Connection
)
-
>
Res
<
(
)
>
;
fn
set_new_listener
(
&
mut
self
_conn_events
:
Box
<
dyn
SendStreamEvents
>
)
{
}
}
trait
SendStreamEvents
:
Debug
{
fn
send_closed
(
&
self
_stream_info
:
&
Http3StreamInfo
_close_type
:
CloseType
)
{
}
fn
data_writable
(
&
self
_stream_info
:
&
Http3StreamInfo
)
{
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
enum
CloseType
{
ResetApp
(
AppError
)
ResetRemote
(
AppError
)
LocalError
(
AppError
)
Done
}
impl
CloseType
{
#
[
must_use
]
pub
const
fn
error
(
&
self
)
-
>
Option
<
AppError
>
{
match
self
{
Self
:
:
ResetApp
(
error
)
|
Self
:
:
ResetRemote
(
error
)
|
Self
:
:
LocalError
(
error
)
=
>
{
Some
(
*
error
)
}
Self
:
:
Done
=
>
None
}
}
#
[
must_use
]
pub
const
fn
locally_initiated
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
ResetApp
(
_
)
)
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
tests
{
use
neqo_transport
:
:
StreamId
;
use
super
:
:
{
Error
Http3StreamInfo
Http3StreamType
}
;
#
[
test
]
fn
stream_info_is_http
(
)
{
let
http
=
Http3StreamInfo
:
:
new
(
StreamId
:
:
new
(
0
)
Http3StreamType
:
:
Http
)
;
assert
!
(
http
.
is_http
(
)
)
;
let
control
=
Http3StreamInfo
:
:
new
(
StreamId
:
:
new
(
2
)
Http3StreamType
:
:
Control
)
;
assert
!
(
!
control
.
is_http
(
)
)
;
let
wt
=
Http3StreamInfo
:
:
new
(
StreamId
:
:
new
(
4
)
Http3StreamType
:
:
WebTransport
(
StreamId
:
:
new
(
0
)
)
)
;
assert
!
(
!
wt
.
is_http
(
)
)
;
}
#
[
test
]
fn
error_codes
(
)
{
for
(
error
expected
)
in
[
(
Error
:
:
HttpNone
0x100
)
(
Error
:
:
HttpGeneralProtocol
0x101
)
(
Error
:
:
HttpGeneralProtocolStream
0x101
)
(
Error
:
:
InvalidHeader
0x101
)
(
Error
:
:
HttpInternal
(
0
)
0x102
)
(
Error
:
:
HttpStreamCreation
0x103
)
(
Error
:
:
HttpClosedCriticalStream
0x104
)
(
Error
:
:
HttpFrameUnexpected
0x105
)
(
Error
:
:
HttpFrame
0x106
)
(
Error
:
:
HttpExcessiveLoad
0x107
)
(
Error
:
:
HttpId
0x108
)
(
Error
:
:
HttpSettings
0x109
)
(
Error
:
:
HttpMissingSettings
0x10a
)
(
Error
:
:
HttpRequestRejected
0x10b
)
(
Error
:
:
HttpRequestCancelled
0x10c
)
(
Error
:
:
HttpRequestIncomplete
0x10d
)
(
Error
:
:
HttpMessage
0x10e
)
(
Error
:
:
HttpConnect
0x10f
)
(
Error
:
:
HttpVersionFallback
0x110
)
]
{
assert_eq
!
(
error
.
code
(
)
expected
)
;
}
}
#
[
test
]
fn
error_mapping
(
)
{
use
neqo_transport
:
:
Error
as
Te
;
use
Error
:
:
{
InvalidInput
StreamLimit
Transport
TransportStreamDoesNotExist
Unavailable
}
;
assert
!
(
matches
!
(
Error
:
:
map_stream_send_errors
(
&
Transport
(
Te
:
:
InvalidStreamId
)
)
TransportStreamDoesNotExist
)
)
;
assert
!
(
matches
!
(
Error
:
:
map_stream_send_errors
(
&
Transport
(
Te
:
:
FinalSize
)
)
TransportStreamDoesNotExist
)
)
;
assert
!
(
matches
!
(
Error
:
:
map_stream_send_errors
(
&
Transport
(
Te
:
:
InvalidInput
)
)
InvalidInput
)
)
;
assert
!
(
matches
!
(
Error
:
:
map_stream_create_errors
(
&
Te
:
:
ConnectionState
)
Unavailable
)
)
;
assert
!
(
matches
!
(
Error
:
:
map_stream_create_errors
(
&
Te
:
:
StreamLimit
)
StreamLimit
)
)
;
assert
!
(
matches
!
(
Error
:
:
map_stream_recv_errors
(
&
Transport
(
Te
:
:
InvalidStreamId
)
)
TransportStreamDoesNotExist
)
)
;
}
}
