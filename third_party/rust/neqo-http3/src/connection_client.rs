use
crate
:
:
client_events
:
:
{
Http3ClientEvent
Http3ClientEvents
}
;
use
crate
:
:
connection
:
:
{
HandleReadableOutput
Http3Connection
Http3State
}
;
use
crate
:
:
hframe
:
:
HFrame
;
use
crate
:
:
push_controller
:
:
PushController
;
use
crate
:
:
push_stream
:
:
PushStream
;
use
crate
:
:
recv_message
:
:
{
MessageType
RecvMessage
}
;
use
crate
:
:
send_message
:
:
{
SendMessage
SendMessageEvents
}
;
use
crate
:
:
settings
:
:
HSettings
;
use
crate
:
:
{
Header
RecvMessageEvents
ResetType
}
;
use
neqo_common
:
:
{
event
:
:
Provider
as
EventProvider
hex
hex_with_len
qdebug
qinfo
qlog
:
:
NeqoQlog
qtrace
Datagram
Decoder
Encoder
Role
}
;
use
neqo_crypto
:
:
{
agent
:
:
CertificateInfo
AuthenticationStatus
ResumptionToken
SecretAgentInfo
}
;
use
neqo_qpack
:
:
{
QpackSettings
Stats
as
QpackStats
}
;
use
neqo_transport
:
:
{
AppError
Connection
ConnectionEvent
ConnectionId
ConnectionIdGenerator
ConnectionParameters
Output
QuicVersion
Stats
as
TransportStats
StreamId
StreamType
ZeroRttState
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
net
:
:
SocketAddr
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
Instant
;
use
crate
:
:
{
Error
Res
}
;
fn
id_gte
<
U
>
(
base
:
StreamId
)
-
>
impl
FnMut
(
(
&
u64
&
U
)
)
-
>
Option
<
u64
>
+
'
static
where
U
:
?
Sized
{
move
|
(
id
_
)
|
{
if
*
id
>
=
base
.
as_u64
(
)
&
&
!
(
StreamId
:
:
from
(
*
id
)
.
is_bidi
(
)
^
base
.
is_bidi
(
)
)
{
Some
(
*
id
)
}
else
{
None
}
}
}
fn
id_lt
<
U
>
(
base
:
StreamId
)
-
>
impl
FnMut
(
&
u64
&
mut
U
)
-
>
bool
where
U
:
?
Sized
{
let
mut
f
=
id_gte
(
base
)
;
move
|
id
v
|
f
(
(
id
v
)
)
.
is_none
(
)
}
fn
alpn_from_quic_version
(
version
:
QuicVersion
)
-
>
&
'
static
str
{
match
version
{
QuicVersion
:
:
Version1
=
>
"
h3
"
QuicVersion
:
:
Draft27
=
>
"
h3
-
27
"
QuicVersion
:
:
Draft28
=
>
"
h3
-
28
"
QuicVersion
:
:
Draft29
=
>
"
h3
-
29
"
QuicVersion
:
:
Draft30
=
>
"
h3
-
30
"
QuicVersion
:
:
Draft31
=
>
"
h3
-
31
"
QuicVersion
:
:
Draft32
=
>
"
h3
-
32
"
}
}
pub
struct
Http3Parameters
{
pub
qpack_settings
:
QpackSettings
pub
max_concurrent_push_streams
:
u64
}
pub
struct
Http3Client
{
conn
:
Connection
base_handler
:
Http3Connection
events
:
Http3ClientEvents
push_handler
:
Rc
<
RefCell
<
PushController
>
>
}
impl
Display
for
Http3Client
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Http3
client
"
)
}
}
impl
Http3Client
{
pub
fn
new
(
server_name
:
&
str
cid_manager
:
Rc
<
RefCell
<
dyn
ConnectionIdGenerator
>
>
local_addr
:
SocketAddr
remote_addr
:
SocketAddr
conn_params
:
ConnectionParameters
http3_parameters
:
&
Http3Parameters
now
:
Instant
)
-
>
Res
<
Self
>
{
Ok
(
Self
:
:
new_with_conn
(
Connection
:
:
new_client
(
server_name
&
[
alpn_from_quic_version
(
conn_params
.
get_quic_version
(
)
)
]
cid_manager
local_addr
remote_addr
conn_params
now
)
?
http3_parameters
)
)
}
#
[
must_use
]
pub
fn
new_with_conn
(
c
:
Connection
http3_parameters
:
&
Http3Parameters
)
-
>
Self
{
let
events
=
Http3ClientEvents
:
:
default
(
)
;
Self
{
conn
:
c
base_handler
:
Http3Connection
:
:
new
(
http3_parameters
.
qpack_settings
)
events
:
events
.
clone
(
)
push_handler
:
Rc
:
:
new
(
RefCell
:
:
new
(
PushController
:
:
new
(
http3_parameters
.
max_concurrent_push_streams
events
)
)
)
}
}
#
[
must_use
]
pub
fn
role
(
&
self
)
-
>
Role
{
self
.
conn
.
role
(
)
}
#
[
must_use
]
pub
fn
state
(
&
self
)
-
>
Http3State
{
self
.
base_handler
.
state
(
)
}
#
[
must_use
]
pub
fn
tls_info
(
&
self
)
-
>
Option
<
&
SecretAgentInfo
>
{
self
.
conn
.
tls_info
(
)
}
#
[
must_use
]
pub
fn
peer_certificate
(
&
self
)
-
>
Option
<
CertificateInfo
>
{
self
.
conn
.
peer_certificate
(
)
}
pub
fn
authenticated
(
&
mut
self
status
:
AuthenticationStatus
now
:
Instant
)
{
self
.
conn
.
authenticated
(
status
now
)
;
}
pub
fn
set_qlog
(
&
mut
self
qlog
:
NeqoQlog
)
{
self
.
conn
.
set_qlog
(
qlog
)
;
}
#
[
must_use
]
pub
fn
connection_id
(
&
self
)
-
>
&
ConnectionId
{
&
self
.
conn
.
odcid
(
)
.
expect
(
"
Client
always
has
odcid
"
)
}
fn
create_resumption_token
(
&
mut
self
token
:
&
ResumptionToken
)
{
if
let
Some
(
settings
)
=
self
.
base_handler
.
get_settings
(
)
{
let
mut
enc
=
Encoder
:
:
default
(
)
;
settings
.
encode_frame_contents
(
&
mut
enc
)
;
enc
.
encode
(
token
.
as_ref
(
)
)
;
self
.
events
.
resumption_token
(
ResumptionToken
:
:
new
(
enc
.
into
(
)
token
.
expiration_time
(
)
)
)
;
}
}
pub
fn
enable_resumption
(
&
mut
self
now
:
Instant
token
:
impl
AsRef
<
[
u8
]
>
)
-
>
Res
<
(
)
>
{
if
self
.
base_handler
.
state
!
=
Http3State
:
:
Initializing
{
return
Err
(
Error
:
:
InvalidState
)
;
}
let
mut
dec
=
Decoder
:
:
from
(
token
.
as_ref
(
)
)
;
let
settings_slice
=
match
dec
.
decode_vvec
(
)
{
Some
(
v
)
=
>
v
None
=
>
return
Err
(
Error
:
:
InvalidResumptionToken
)
}
;
qtrace
!
(
[
self
]
"
settings
{
}
"
hex_with_len
(
&
settings_slice
)
)
;
let
mut
dec_settings
=
Decoder
:
:
from
(
settings_slice
)
;
let
mut
settings
=
HSettings
:
:
default
(
)
;
Error
:
:
map_error
(
settings
.
decode_frame_contents
(
&
mut
dec_settings
)
Error
:
:
InvalidResumptionToken
)
?
;
let
tok
=
dec
.
decode_remainder
(
)
;
qtrace
!
(
[
self
]
"
Transport
token
{
}
"
hex
(
&
tok
)
)
;
self
.
conn
.
enable_resumption
(
now
tok
)
?
;
if
self
.
conn
.
state
(
)
.
closed
(
)
{
let
state
=
self
.
conn
.
state
(
)
.
clone
(
)
;
let
res
=
self
.
base_handler
.
handle_state_change
(
&
mut
self
.
conn
&
state
)
;
debug_assert_eq
!
(
Ok
(
true
)
res
)
;
return
Err
(
Error
:
:
FatalError
)
;
}
if
*
self
.
conn
.
zero_rtt_state
(
)
=
=
ZeroRttState
:
:
Sending
{
self
.
base_handler
.
set_0rtt_settings
(
&
mut
self
.
conn
settings
)
?
;
self
.
events
.
connection_state_change
(
self
.
base_handler
.
state
(
)
)
;
self
.
push_handler
.
borrow_mut
(
)
.
maybe_send_max_push_id_frame
(
&
mut
self
.
base_handler
)
;
}
Ok
(
(
)
)
}
pub
fn
close
<
S
>
(
&
mut
self
now
:
Instant
error
:
AppError
msg
:
S
)
where
S
:
AsRef
<
str
>
+
Display
{
qinfo
!
(
[
self
]
"
Close
the
connection
error
=
{
}
msg
=
{
}
.
"
error
msg
)
;
if
!
matches
!
(
self
.
base_handler
.
state
Http3State
:
:
Closing
(
_
)
|
Http3State
:
:
Closed
(
_
)
)
{
self
.
push_handler
.
borrow_mut
(
)
.
clear
(
)
;
self
.
conn
.
close
(
now
error
msg
)
;
self
.
base_handler
.
close
(
error
)
;
self
.
events
.
connection_state_change
(
self
.
base_handler
.
state
(
)
)
;
}
}
pub
fn
initiate_key_update
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
conn
.
initiate_key_update
(
)
?
;
Ok
(
(
)
)
}
pub
fn
fetch
(
&
mut
self
now
:
Instant
method
:
&
str
scheme
:
&
str
host
:
&
str
path
:
&
str
headers
:
&
[
Header
]
)
-
>
Res
<
u64
>
{
qinfo
!
(
[
self
]
"
Fetch
method
=
{
}
scheme
=
{
}
host
=
{
}
path
=
{
}
"
method
scheme
host
path
)
;
match
self
.
base_handler
.
state
(
)
{
Http3State
:
:
GoingAway
(
.
.
)
|
Http3State
:
:
Closing
(
.
.
)
|
Http3State
:
:
Closed
(
.
.
)
=
>
{
return
Err
(
Error
:
:
AlreadyClosed
)
}
Http3State
:
:
Initializing
=
>
return
Err
(
Error
:
:
Unavailable
)
_
=
>
{
}
}
let
id
=
self
.
conn
.
stream_create
(
StreamType
:
:
BiDi
)
.
map_err
(
|
e
|
Error
:
:
map_stream_create_errors
(
&
e
)
)
?
;
let
mut
final_headers
=
vec
!
[
(
"
:
method
"
.
into
(
)
method
.
to_owned
(
)
)
(
"
:
scheme
"
.
into
(
)
scheme
.
to_owned
(
)
)
(
"
:
authority
"
.
into
(
)
host
.
to_owned
(
)
)
(
"
:
path
"
.
into
(
)
path
.
to_owned
(
)
)
]
;
final_headers
.
extend_from_slice
(
headers
)
;
self
.
base_handler
.
add_streams
(
id
SendMessage
:
:
new_with_headers
(
id
final_headers
Box
:
:
new
(
self
.
events
.
clone
(
)
)
)
Box
:
:
new
(
RecvMessage
:
:
new
(
MessageType
:
:
Response
id
Box
:
:
new
(
self
.
events
.
clone
(
)
)
Some
(
self
.
push_handler
.
clone
(
)
)
)
)
)
;
if
let
Err
(
e
)
=
self
.
base_handler
.
send_streams
.
get_mut
(
&
id
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
?
.
send
(
&
mut
self
.
conn
&
mut
self
.
base_handler
.
qpack_encoder
)
{
if
e
.
connection_error
(
)
{
self
.
close
(
now
e
.
code
(
)
"
"
)
;
}
return
Err
(
e
)
;
}
Ok
(
id
)
}
pub
fn
stream_reset
(
&
mut
self
stream_id
:
u64
error
:
AppError
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
reset_stream
{
}
error
=
{
}
.
"
stream_id
error
)
;
self
.
base_handler
.
stream_reset
(
&
mut
self
.
conn
stream_id
error
)
?
;
self
.
events
.
remove_events_for_stream_id
(
stream_id
)
;
Ok
(
(
)
)
}
pub
fn
stream_close_send
(
&
mut
self
stream_id
:
u64
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
Close
sending
side
stream
=
{
}
.
"
stream_id
)
;
self
.
base_handler
.
stream_close_send
(
&
mut
self
.
conn
stream_id
)
}
pub
fn
send_request_body
(
&
mut
self
stream_id
:
u64
buf
:
&
[
u8
]
)
-
>
Res
<
usize
>
{
qinfo
!
(
[
self
]
"
send_request_body
from
stream
{
}
sending
{
}
bytes
.
"
stream_id
buf
.
len
(
)
)
;
self
.
base_handler
.
send_streams
.
get_mut
(
&
stream_id
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
?
.
send_body
(
&
mut
self
.
conn
buf
)
}
pub
fn
read_response_data
(
&
mut
self
now
:
Instant
stream_id
:
u64
buf
:
&
mut
[
u8
]
)
-
>
Res
<
(
usize
bool
)
>
{
qinfo
!
(
[
self
]
"
read_data
from
stream
{
}
.
"
stream_id
)
;
let
recv_stream
=
self
.
base_handler
.
recv_streams
.
get_mut
(
&
stream_id
)
.
ok_or
(
Error
:
:
InvalidStreamId
)
?
;
let
res
=
recv_stream
.
read_data
(
&
mut
self
.
conn
&
mut
self
.
base_handler
.
qpack_decoder
buf
)
;
match
res
{
Ok
(
(
amount
fin
)
)
=
>
{
if
recv_stream
.
done
(
)
{
self
.
base_handler
.
recv_streams
.
remove
(
&
stream_id
)
;
}
Ok
(
(
amount
fin
)
)
}
Err
(
e
)
=
>
{
if
e
.
stream_reset_error
(
)
{
self
.
reset_stream_on_error
(
stream_id
e
.
code
(
)
)
;
Ok
(
(
0
false
)
)
}
else
if
e
.
connection_error
(
)
{
self
.
close
(
now
e
.
code
(
)
"
"
)
;
Err
(
e
)
}
else
{
Err
(
e
)
}
}
}
}
pub
fn
cancel_push
(
&
mut
self
push_id
:
u64
)
-
>
Res
<
(
)
>
{
self
.
push_handler
.
borrow_mut
(
)
.
cancel
(
push_id
&
mut
self
.
conn
&
mut
self
.
base_handler
)
}
pub
fn
push_read_data
(
&
mut
self
now
:
Instant
push_id
:
u64
buf
:
&
mut
[
u8
]
)
-
>
Res
<
(
usize
bool
)
>
{
let
stream_id
=
self
.
push_handler
.
borrow_mut
(
)
.
get_active_stream_id
(
push_id
)
;
stream_id
.
map_or
(
Err
(
Error
:
:
InvalidStreamId
)
|
id
|
{
self
.
read_response_data
(
now
id
buf
)
}
)
}
pub
fn
process
(
&
mut
self
dgram
:
Option
<
Datagram
>
now
:
Instant
)
-
>
Output
{
qtrace
!
(
[
self
]
"
Process
.
"
)
;
if
let
Some
(
d
)
=
dgram
{
self
.
process_input
(
d
now
)
;
}
self
.
process_output
(
now
)
}
pub
fn
process_input
(
&
mut
self
dgram
:
Datagram
now
:
Instant
)
{
qtrace
!
(
[
self
]
"
Process
input
.
"
)
;
self
.
conn
.
process_input
(
dgram
now
)
;
self
.
process_http3
(
now
)
;
}
pub
fn
conn
(
&
mut
self
)
-
>
&
mut
Connection
{
&
mut
self
.
conn
}
fn
process_http3
(
&
mut
self
now
:
Instant
)
{
qtrace
!
(
[
self
]
"
Process
http3
internal
.
"
)
;
match
self
.
base_handler
.
state
(
)
{
Http3State
:
:
ZeroRtt
|
Http3State
:
:
Connected
|
Http3State
:
:
GoingAway
(
.
.
)
=
>
{
let
res
=
self
.
check_connection_events
(
)
;
if
self
.
check_result
(
now
&
res
)
{
return
;
}
self
.
push_handler
.
borrow_mut
(
)
.
maybe_send_max_push_id_frame
(
&
mut
self
.
base_handler
)
;
let
res
=
self
.
base_handler
.
process_sending
(
&
mut
self
.
conn
)
;
self
.
check_result
(
now
&
res
)
;
}
Http3State
:
:
Closed
{
.
.
}
=
>
{
}
_
=
>
{
let
res
=
self
.
check_connection_events
(
)
;
let
_
=
self
.
check_result
(
now
&
res
)
;
}
}
}
pub
fn
process_output
(
&
mut
self
now
:
Instant
)
-
>
Output
{
qtrace
!
(
[
self
]
"
Process
output
.
"
)
;
self
.
process_http3
(
now
)
;
let
out
=
self
.
conn
.
process_output
(
now
)
;
self
.
process_http3
(
now
)
;
out
}
fn
check_result
<
ERR
>
(
&
mut
self
now
:
Instant
res
:
&
Res
<
ERR
>
)
-
>
bool
{
match
&
res
{
Err
(
Error
:
:
HttpGoaway
)
=
>
{
qinfo
!
(
[
self
]
"
Connection
error
:
goaway
stream_id
increased
.
"
)
;
self
.
close
(
now
Error
:
:
HttpGeneralProtocol
.
code
(
)
"
Connection
error
:
goaway
stream_id
increased
"
)
;
true
}
Err
(
e
)
=
>
{
qinfo
!
(
[
self
]
"
Connection
error
:
{
}
.
"
e
)
;
self
.
close
(
now
e
.
code
(
)
&
format
!
(
"
{
}
"
e
)
)
;
true
}
_
=
>
false
}
}
fn
check_connection_events
(
&
mut
self
)
-
>
Res
<
(
)
>
{
qtrace
!
(
[
self
]
"
Check
connection
events
.
"
)
;
while
let
Some
(
e
)
=
self
.
conn
.
next_event
(
)
{
qdebug
!
(
[
self
]
"
check_connection_events
-
event
{
:
?
}
.
"
e
)
;
match
e
{
ConnectionEvent
:
:
NewStream
{
stream_id
}
=
>
match
stream_id
.
stream_type
(
)
{
StreamType
:
:
BiDi
=
>
return
Err
(
Error
:
:
HttpStreamCreation
)
StreamType
:
:
UniDi
=
>
{
if
self
.
base_handler
.
handle_new_unidi_stream
(
&
mut
self
.
conn
stream_id
.
as_u64
(
)
)
?
{
self
.
handle_new_push_stream
(
stream_id
.
as_u64
(
)
false
)
?
;
}
}
}
ConnectionEvent
:
:
SendStreamWritable
{
stream_id
}
=
>
{
if
let
Some
(
s
)
=
self
.
base_handler
.
send_streams
.
get_mut
(
&
stream_id
.
as_u64
(
)
)
{
s
.
stream_writable
(
)
;
}
}
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
>
{
if
let
Err
(
e
)
=
self
.
handle_stream_readable
(
stream_id
)
{
if
e
.
stream_reset_error
(
)
{
self
.
reset_stream_on_error
(
stream_id
e
.
code
(
)
)
;
}
else
{
return
Err
(
e
)
;
}
}
}
ConnectionEvent
:
:
RecvStreamReset
{
stream_id
app_error
}
=
>
self
.
base_handler
.
handle_stream_reset
(
stream_id
app_error
)
?
ConnectionEvent
:
:
SendStreamStopSending
{
stream_id
app_error
}
=
>
self
.
base_handler
.
handle_stream_stop_sending
(
stream_id
app_error
)
?
ConnectionEvent
:
:
SendStreamComplete
{
.
.
}
=
>
{
}
ConnectionEvent
:
:
SendStreamCreatable
{
stream_type
}
=
>
{
self
.
events
.
new_requests_creatable
(
stream_type
)
}
ConnectionEvent
:
:
AuthenticationNeeded
=
>
self
.
events
.
authentication_needed
(
)
ConnectionEvent
:
:
StateChange
(
state
)
=
>
{
if
self
.
base_handler
.
handle_state_change
(
&
mut
self
.
conn
&
state
)
?
{
self
.
events
.
connection_state_change
(
self
.
base_handler
.
state
(
)
)
;
}
}
ConnectionEvent
:
:
ZeroRttRejected
=
>
{
self
.
base_handler
.
handle_zero_rtt_rejected
(
)
?
;
self
.
events
.
zero_rtt_rejected
(
)
;
self
.
push_handler
.
borrow_mut
(
)
.
handle_zero_rtt_rejected
(
)
;
}
ConnectionEvent
:
:
ResumptionToken
(
token
)
=
>
{
self
.
create_resumption_token
(
&
token
)
;
}
}
}
Ok
(
(
)
)
}
fn
handle_stream_readable
(
&
mut
self
stream_id
:
u64
)
-
>
Res
<
(
)
>
{
match
self
.
base_handler
.
handle_stream_readable
(
&
mut
self
.
conn
stream_id
)
?
{
HandleReadableOutput
:
:
PushStream
=
>
self
.
handle_new_push_stream
(
stream_id
true
)
HandleReadableOutput
:
:
ControlFrames
(
control_frames
)
=
>
{
for
f
in
control_frames
{
match
f
{
HFrame
:
:
CancelPush
{
push_id
}
=
>
self
.
push_handler
.
borrow_mut
(
)
.
handle_cancel_push
(
push_id
&
mut
self
.
conn
&
mut
self
.
base_handler
)
HFrame
:
:
MaxPushId
{
.
.
}
=
>
Err
(
Error
:
:
HttpFrameUnexpected
)
HFrame
:
:
Goaway
{
stream_id
}
=
>
self
.
handle_goaway
(
stream_id
)
_
=
>
{
unreachable
!
(
"
we
should
only
put
MaxPushId
and
Goaway
into
control_frames
.
"
)
;
}
}
?
;
}
Ok
(
(
)
)
}
_
=
>
Ok
(
(
)
)
}
}
fn
handle_new_push_stream
(
&
mut
self
stream_id
:
u64
force_read
:
bool
)
-
>
Res
<
(
)
>
{
if
self
.
push_handler
.
borrow
(
)
.
can_receive_push
(
)
{
self
.
base_handler
.
add_recv_stream
(
stream_id
Box
:
:
new
(
PushStream
:
:
new
(
stream_id
self
.
push_handler
.
clone
(
)
self
.
events
.
clone
(
)
)
)
)
;
if
force_read
{
let
res2
=
self
.
base_handler
.
handle_stream_readable
(
&
mut
self
.
conn
stream_id
)
?
;
debug_assert
!
(
matches
!
(
res2
HandleReadableOutput
:
:
NoOutput
)
)
;
}
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
HttpId
)
}
}
fn
handle_goaway
(
&
mut
self
goaway_stream_id
:
u64
)
-
>
Res
<
(
)
>
{
qinfo
!
(
[
self
]
"
handle_goaway
{
}
"
goaway_stream_id
)
;
let
id
=
StreamId
:
:
from
(
goaway_stream_id
)
;
if
id
.
is_uni
(
)
|
|
id
.
is_server_initiated
(
)
{
return
Err
(
Error
:
:
HttpId
)
;
}
match
self
.
base_handler
.
state
{
Http3State
:
:
Connected
=
>
{
self
.
base_handler
.
state
=
Http3State
:
:
GoingAway
(
goaway_stream_id
)
;
}
Http3State
:
:
GoingAway
(
ref
mut
stream_id
)
=
>
{
if
goaway_stream_id
>
*
stream_id
{
return
Err
(
Error
:
:
HttpGoaway
)
;
}
*
stream_id
=
goaway_stream_id
;
}
Http3State
:
:
Closing
(
.
.
)
|
Http3State
:
:
Closed
(
.
.
)
=
>
{
}
_
=
>
unreachable
!
(
"
Should
not
receive
Goaway
frame
in
this
state
.
"
)
}
let
goaway_stream_id
=
StreamId
:
:
from
(
goaway_stream_id
)
;
for
id
in
self
.
base_handler
.
send_streams
.
iter
(
)
.
filter_map
(
id_gte
(
goaway_stream_id
)
)
{
self
.
events
.
reset
(
id
Error
:
:
HttpRequestRejected
.
code
(
)
false
)
;
}
for
id
in
self
.
base_handler
.
recv_streams
.
iter
(
)
.
filter_map
(
id_gte
(
goaway_stream_id
)
)
{
self
.
events
.
stop_sending
(
id
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
}
self
.
events
.
goaway_received
(
)
;
self
.
base_handler
.
send_streams
.
retain
(
id_lt
(
goaway_stream_id
)
)
;
self
.
base_handler
.
recv_streams
.
retain
(
id_lt
(
goaway_stream_id
)
)
;
Ok
(
(
)
)
}
pub
fn
set_stream_max_data
(
&
mut
self
stream_id
:
u64
max_data
:
u64
)
-
>
Res
<
(
)
>
{
self
.
conn
.
set_stream_max_data
(
stream_id
max_data
)
?
;
Ok
(
(
)
)
}
#
[
must_use
]
pub
fn
qpack_decoder_stats
(
&
self
)
-
>
QpackStats
{
self
.
base_handler
.
qpack_decoder
.
stats
(
)
}
#
[
must_use
]
pub
fn
qpack_encoder_stats
(
&
self
)
-
>
QpackStats
{
self
.
base_handler
.
qpack_encoder
.
stats
(
)
}
#
[
must_use
]
pub
fn
transport_stats
(
&
self
)
-
>
TransportStats
{
self
.
conn
.
stats
(
)
}
fn
reset_stream_on_error
(
&
mut
self
stream_id
:
u64
app_error
:
AppError
)
{
let
_
=
self
.
conn
.
stream_stop_sending
(
stream_id
app_error
)
;
if
let
Some
(
rs
)
=
self
.
base_handler
.
recv_streams
.
remove
(
&
stream_id
)
{
rs
.
stream_reset
(
app_error
&
mut
self
.
base_handler
.
qpack_decoder
ResetType
:
:
Local
)
;
}
}
}
impl
EventProvider
for
Http3Client
{
type
Event
=
Http3ClientEvent
;
fn
has_events
(
&
self
)
-
>
bool
{
self
.
events
.
has_events
(
)
}
fn
next_event
(
&
mut
self
)
-
>
Option
<
Self
:
:
Event
>
{
self
.
events
.
next_event
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
AuthenticationStatus
Connection
Error
HSettings
Header
Http3Client
Http3ClientEvent
Http3Parameters
Http3State
QpackSettings
Rc
RefCell
StreamType
}
;
use
crate
:
:
hframe
:
:
{
HFrame
H3_FRAME_TYPE_SETTINGS
H3_RESERVED_FRAME_TYPES
}
;
use
crate
:
:
settings
:
:
{
HSetting
HSettingType
H3_RESERVED_SETTINGS
}
;
use
crate
:
:
Http3Server
;
use
neqo_common
:
:
{
event
:
:
Provider
Datagram
Decoder
Encoder
}
;
use
neqo_crypto
:
:
{
AllowZeroRtt
AntiReplay
ResumptionToken
}
;
use
neqo_qpack
:
:
encoder
:
:
QPackEncoder
;
use
neqo_transport
:
:
tparams
:
:
{
self
TransportParameter
}
;
use
neqo_transport
:
:
{
ConnectionError
ConnectionEvent
ConnectionParameters
Output
State
RECV_BUFFER_SIZE
SEND_BUFFER_SIZE
}
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
time
:
:
Duration
;
use
test_fixture
:
:
{
addr
anti_replay
default_server_h3
fixture_init
now
CountingConnectionIdGenerator
DEFAULT_ALPN_H3
DEFAULT_KEYS
DEFAULT_SERVER_NAME
}
;
fn
assert_closed
(
client
:
&
Http3Client
expected
:
&
Error
)
{
match
client
.
state
(
)
{
Http3State
:
:
Closing
(
err
)
|
Http3State
:
:
Closed
(
err
)
=
>
{
assert_eq
!
(
err
ConnectionError
:
:
Application
(
expected
.
code
(
)
)
)
}
_
=
>
panic
!
(
"
Wrong
state
{
:
?
}
"
client
.
state
(
)
)
}
;
}
pub
fn
default_http3_client
(
)
-
>
Http3Client
{
default_http3_client_param
(
100
)
}
pub
fn
default_http3_client_param
(
max_table_size
:
u64
)
-
>
Http3Client
{
fixture_init
(
)
;
Http3Client
:
:
new
(
DEFAULT_SERVER_NAME
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
addr
(
)
addr
(
)
ConnectionParameters
:
:
default
(
)
&
Http3Parameters
{
qpack_settings
:
QpackSettings
{
max_table_size_encoder
:
max_table_size
max_table_size_decoder
:
max_table_size
max_blocked_streams
:
100
}
max_concurrent_push_streams
:
5
}
now
(
)
)
.
expect
(
"
create
a
default
client
"
)
}
const
CONTROL_STREAM_TYPE
:
&
[
u8
]
=
&
[
0x0
]
;
const
ENCODER_STREAM_DATA
:
&
[
u8
]
=
&
[
0x2
]
;
const
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
:
&
[
u8
]
=
&
[
0x2
0x3f
0x45
]
;
const
ENCODER_STREAM_DATA_WITH_CAP_INST_AND_ENCODING_INST
:
&
[
u8
]
=
&
[
0x2
0x3f
0x45
0x67
0xa7
0xd4
0xe5
0x1c
0x85
0xb1
0x1f
0x86
0xa7
0xd7
0x71
0xd1
0x69
0x7f
]
;
const
DECODER_STREAM_DATA
:
&
[
u8
]
=
&
[
0x3
]
;
const
PUSH_STREAM_TYPE
:
&
[
u8
]
=
&
[
0x1
]
;
const
CLIENT_SIDE_CONTROL_STREAM_ID
:
u64
=
2
;
const
CLIENT_SIDE_ENCODER_STREAM_ID
:
u64
=
6
;
const
CLIENT_SIDE_DECODER_STREAM_ID
:
u64
=
10
;
struct
TestServer
{
settings
:
HFrame
conn
:
Connection
control_stream_id
:
Option
<
u64
>
encoder
:
QPackEncoder
encoder_stream_id
:
Option
<
u64
>
decoder_stream_id
:
Option
<
u64
>
}
impl
TestServer
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
new_with_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
)
}
pub
fn
new_with_settings
(
server_settings
:
&
[
HSetting
]
)
-
>
Self
{
fixture_init
(
)
;
Self
{
settings
:
HFrame
:
:
Settings
{
settings
:
HSettings
:
:
new
(
server_settings
)
}
conn
:
default_server_h3
(
)
control_stream_id
:
None
encoder
:
QPackEncoder
:
:
new
(
QpackSettings
{
max_table_size_encoder
:
128
max_table_size_decoder
:
128
max_blocked_streams
:
0
}
true
)
encoder_stream_id
:
None
decoder_stream_id
:
None
}
}
pub
fn
new_with_conn
(
conn
:
Connection
)
-
>
Self
{
Self
{
settings
:
HFrame
:
:
Settings
{
settings
:
HSettings
:
:
new
(
&
[
]
)
}
conn
control_stream_id
:
None
encoder
:
QPackEncoder
:
:
new
(
QpackSettings
{
max_table_size_encoder
:
128
max_table_size_decoder
:
128
max_blocked_streams
:
0
}
true
)
encoder_stream_id
:
None
decoder_stream_id
:
None
}
}
pub
fn
create_qpack_streams
(
&
mut
self
)
{
self
.
encoder_stream_id
=
Some
(
self
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
)
;
self
.
encoder
.
add_send_stream
(
self
.
encoder_stream_id
.
unwrap
(
)
)
;
self
.
encoder
.
send
(
&
mut
self
.
conn
)
.
unwrap
(
)
;
self
.
decoder_stream_id
=
Some
(
self
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
)
;
assert_eq
!
(
self
.
conn
.
stream_send
(
self
.
decoder_stream_id
.
unwrap
(
)
DECODER_STREAM_DATA
)
.
unwrap
(
)
1
)
;
self
.
encoder
.
add_recv_stream
(
CLIENT_SIDE_DECODER_STREAM_ID
)
.
unwrap
(
)
;
}
pub
fn
create_control_stream
(
&
mut
self
)
{
self
.
control_stream_id
=
Some
(
self
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
)
;
assert_eq
!
(
self
.
conn
.
stream_send
(
self
.
control_stream_id
.
unwrap
(
)
CONTROL_STREAM_TYPE
)
.
unwrap
(
)
1
)
;
let
mut
enc
=
Encoder
:
:
default
(
)
;
self
.
settings
.
encode
(
&
mut
enc
)
;
assert_eq
!
(
self
.
conn
.
stream_send
(
self
.
control_stream_id
.
unwrap
(
)
&
enc
[
.
.
]
)
.
unwrap
(
)
enc
[
.
.
]
.
len
(
)
)
;
}
pub
fn
check_client_control_qpack_streams_no_resumption
(
&
mut
self
)
{
self
.
check_client_control_qpack_streams
(
ENCODER_STREAM_DATA
EXPECTED_REQUEST_HEADER_FRAME
false
true
)
;
}
pub
fn
check_control_qpack_request_streams_resumption
(
&
mut
self
expect_encoder_stream_data
:
&
[
u8
]
expect_request_header
:
&
[
u8
]
expect_request
:
bool
)
{
self
.
check_client_control_qpack_streams
(
expect_encoder_stream_data
expect_request_header
expect_request
false
)
;
}
pub
fn
check_client_control_qpack_streams
(
&
mut
self
expect_encoder_stream_data
:
&
[
u8
]
expect_request_header
:
&
[
u8
]
expect_request
:
bool
expect_connected
:
bool
)
{
let
mut
connected
=
false
;
let
mut
control_stream
=
false
;
let
mut
qpack_decoder_stream
=
false
;
let
mut
qpack_encoder_stream
=
false
;
let
mut
request
=
false
;
while
let
Some
(
e
)
=
self
.
conn
.
next_event
(
)
{
match
e
{
ConnectionEvent
:
:
NewStream
{
stream_id
}
|
ConnectionEvent
:
:
SendStreamWritable
{
stream_id
}
=
>
{
if
expect_request
{
assert
!
(
matches
!
(
stream_id
.
as_u64
(
)
2
|
6
|
10
|
0
)
)
;
}
else
{
assert
!
(
matches
!
(
stream_id
.
as_u64
(
)
2
|
6
|
10
)
)
;
}
}
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
>
{
if
stream_id
=
=
CLIENT_SIDE_CONTROL_STREAM_ID
{
self
.
check_control_stream
(
)
;
control_stream
=
true
;
}
else
if
stream_id
=
=
CLIENT_SIDE_ENCODER_STREAM_ID
{
self
.
read_and_check_stream_data
(
stream_id
expect_encoder_stream_data
false
)
;
qpack_encoder_stream
=
true
;
}
else
if
stream_id
=
=
CLIENT_SIDE_DECODER_STREAM_ID
{
self
.
read_and_check_stream_data
(
stream_id
DECODER_STREAM_DATA
false
)
;
qpack_decoder_stream
=
true
;
}
else
if
stream_id
=
=
0
{
assert
!
(
expect_request
)
;
self
.
read_and_check_stream_data
(
stream_id
expect_request_header
true
)
;
request
=
true
;
}
else
{
panic
!
(
"
unexpected
event
"
)
;
}
}
ConnectionEvent
:
:
StateChange
(
State
:
:
Connected
)
=
>
connected
=
true
ConnectionEvent
:
:
StateChange
(
_
)
=
>
{
}
_
=
>
panic
!
(
"
unexpected
event
"
)
}
}
assert_eq
!
(
connected
expect_connected
)
;
assert
!
(
control_stream
)
;
assert
!
(
qpack_encoder_stream
)
;
assert
!
(
qpack_decoder_stream
)
;
assert_eq
!
(
request
expect_request
)
;
}
fn
check_control_stream
(
&
mut
self
)
{
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
self
.
conn
.
stream_recv
(
CLIENT_SIDE_CONTROL_STREAM_ID
&
mut
buf
)
.
unwrap
(
)
;
let
mut
dec
=
Decoder
:
:
from
(
&
buf
[
.
.
amount
]
)
;
assert_eq
!
(
dec
.
decode_varint
(
)
.
unwrap
(
)
0
)
;
assert_eq
!
(
dec
.
decode_varint
(
)
.
unwrap
(
)
4
)
;
assert_eq
!
(
dec
.
decode_vvec
(
)
.
unwrap
(
)
&
[
1
0x40
0x64
7
0x40
0x64
]
)
;
assert_eq
!
(
(
dec
.
decode_varint
(
)
.
unwrap
(
)
-
0x21
)
%
0x1f
0
)
;
assert
!
(
dec
.
decode_vvec
(
)
.
unwrap
(
)
.
len
(
)
<
8
)
;
assert_eq
!
(
dec
.
decode_varint
(
)
.
unwrap
(
)
0xd
)
;
assert_eq
!
(
dec
.
decode_vvec
(
)
.
unwrap
(
)
&
[
5
]
)
;
assert_eq
!
(
dec
.
remaining
(
)
0
)
;
assert
!
(
!
fin
)
;
}
pub
fn
read_and_check_stream_data
(
&
mut
self
stream_id
:
u64
expected_data
:
&
[
u8
]
expected_fin
:
bool
)
{
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
self
.
conn
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
expected_fin
)
;
assert_eq
!
(
amount
expected_data
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
expected_data
)
;
}
pub
fn
encode_headers
(
&
mut
self
stream_id
:
u64
headers
:
&
[
Header
]
encoder
:
&
mut
Encoder
)
{
let
header_block
=
self
.
encoder
.
encode_header_block
(
&
mut
self
.
conn
&
headers
stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
header_block
.
to_vec
(
)
}
;
hframe
.
encode
(
encoder
)
;
}
pub
fn
set_max_uni_stream
(
&
mut
self
max_stream
:
u64
)
{
self
.
conn
.
set_local_tparam
(
tparams
:
:
INITIAL_MAX_STREAMS_UNI
TransportParameter
:
:
Integer
(
max_stream
)
)
.
unwrap
(
)
;
}
}
fn
handshake_only
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
)
-
>
Output
{
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Initializing
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Initializing
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Init
)
;
let
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Handshaking
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
authentication_needed
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
AuthenticationNeeded
)
;
assert
!
(
client
.
events
(
)
.
any
(
authentication_needed
)
)
;
client
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
out
}
fn
connect_only_transport_with
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
)
{
let
out
=
handshake_only
(
client
server
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
connected
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
StateChange
(
Http3State
:
:
Connected
)
)
;
assert
!
(
client
.
events
(
)
.
any
(
connected
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
server
.
conn
.
state
(
)
.
connected
(
)
)
;
}
fn
connect_only_transport
(
)
-
>
(
Http3Client
TestServer
)
{
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
TestServer
:
:
new
(
)
;
connect_only_transport_with
(
&
mut
client
&
mut
server
)
;
(
client
server
)
}
fn
send_and_receive_client_settings
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
)
{
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
server
.
check_client_control_qpack_streams_no_resumption
(
)
;
}
fn
connect_with
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
)
{
connect_only_transport_with
(
client
server
)
;
send_and_receive_client_settings
(
client
server
)
;
server
.
create_control_stream
(
)
;
server
.
create_qpack_streams
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
fn
connect
(
)
-
>
(
Http3Client
TestServer
)
{
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
TestServer
:
:
new
(
)
;
connect_with
(
&
mut
client
&
mut
server
)
;
(
client
server
)
}
fn
make_request
(
client
:
&
mut
Http3Client
close_sending_side
:
bool
headers
:
&
[
Header
]
)
-
>
u64
{
let
request_stream_id
=
client
.
fetch
(
now
(
)
"
GET
"
"
https
"
"
something
.
com
"
"
/
"
headers
)
.
unwrap
(
)
;
if
close_sending_side
{
let
_
=
client
.
stream_close_send
(
request_stream_id
)
;
}
request_stream_id
}
const
EXPECTED_REQUEST_HEADER_FRAME
:
&
[
u8
]
=
&
[
0x01
0x10
0x00
0x00
0xd1
0xd7
0x50
0x89
0x41
0xe9
0x2a
0x67
0x35
0x53
0x2e
0x43
0xd3
0xc1
]
;
const
EXPECTED_REQUEST_HEADER_FRAME_VERSION2
:
&
[
u8
]
=
&
[
0x01
0x11
0x02
0x80
0xd1
0xd7
0x50
0x89
0x41
0xe9
0x2a
0x67
0x35
0x53
0x2e
0x43
0xd3
0xc1
0x10
]
;
const
HTTP_HEADER_FRAME_0
:
&
[
u8
]
=
&
[
0x01
0x06
0x00
0x00
0xd9
0x54
0x01
0x30
]
;
fn
check_response_header_0
(
header
:
&
[
Header
]
)
{
let
expected_response_header_0
=
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
0
"
)
)
]
;
assert_eq
!
(
header
expected_response_header_0
)
;
}
const
HTTP_RESPONSE_1
:
&
[
u8
]
=
&
[
0x01
0x06
0x00
0x00
0xd9
0x54
0x01
0x37
0x0
0x3
0x61
0x62
0x63
0x0
0x4
0x64
0x65
0x66
0x67
]
;
const
HTTP_RESPONSE_HEADER_ONLY_1
:
&
[
u8
]
=
&
[
0x01
0x06
0x00
0x00
0xd9
0x54
0x01
0x37
]
;
const
HTTP_RESPONSE_DATA_FRAME_1_ONLY_1
:
&
[
u8
]
=
&
[
0x0
0x3
0x61
0x62
0x63
]
;
const
HTTP_RESPONSE_DATA_FRAME_2_ONLY_1
:
&
[
u8
]
=
&
[
0x0
0x4
0x64
0x65
0x66
0x67
]
;
fn
check_response_header_1
(
header
:
&
[
Header
]
)
{
let
expected_response_header_1
=
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
7
"
)
)
]
;
assert_eq
!
(
header
expected_response_header_1
)
;
}
const
EXPECTED_RESPONSE_DATA_1
:
&
[
u8
]
=
&
[
0x61
0x62
0x63
0x64
0x65
0x66
0x67
]
;
const
HTTP_RESPONSE_2
:
&
[
u8
]
=
&
[
0x01
0x06
0x00
0x00
0xd9
0x54
0x01
0x33
0x0
0x3
0x61
0x62
0x63
]
;
const
HTTP_RESPONSE_HEADER_ONLY_2
:
&
[
u8
]
=
&
[
0x01
0x06
0x00
0x00
0xd9
0x54
0x01
0x33
]
;
const
HTTP_RESPONSE_DATA_FRAME_ONLY_2
:
&
[
u8
]
=
&
[
0x0
0x3
0x61
0x62
0x63
]
;
fn
check_response_header_2
(
header
:
&
[
Header
]
)
{
let
expected_response_header_2
=
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
assert_eq
!
(
header
expected_response_header_2
)
;
}
const
EXPECTED_RESPONSE_DATA_2_FRAME_1
:
&
[
u8
]
=
&
[
0x61
0x62
0x63
]
;
fn
make_request_and_exchange_pkts
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
close_sending_side
:
bool
)
-
>
u64
{
let
request_stream_id
=
make_request
(
client
close_sending_side
&
[
]
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
server
.
conn
.
next_event
(
)
{
match
e
{
ConnectionEvent
:
:
NewStream
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
.
as_u64
(
)
request_stream_id
)
;
assert_eq
!
(
stream_id
.
stream_type
(
)
StreamType
:
:
BiDi
)
;
}
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
server
.
read_and_check_stream_data
(
stream_id
EXPECTED_REQUEST_HEADER_FRAME
close_sending_side
)
;
}
_
=
>
{
}
}
}
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
request_stream_id
}
fn
connect_and_send_request
(
close_sending_side
:
bool
)
-
>
(
Http3Client
TestServer
u64
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
request_stream_id
=
make_request_and_exchange_pkts
(
&
mut
client
&
mut
server
close_sending_side
)
;
assert_eq
!
(
request_stream_id
0
)
;
(
client
server
request_stream_id
)
}
fn
server_send_response_and_exchange_packet
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
stream_id
:
u64
response
:
&
[
u8
]
close_stream
:
bool
)
{
let
_
=
server
.
conn
.
stream_send
(
stream_id
response
)
.
unwrap
(
)
;
if
close_stream
{
server
.
conn
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
}
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
}
const
PUSH_PROMISE_DATA
:
&
[
u8
]
=
&
[
0x00
0x00
0xd1
0xd7
0x50
0x89
0x41
0xe9
0x2a
0x67
0x35
0x53
0x2e
0x43
0xd3
0xc1
]
;
fn
check_pushpromise_header
(
header
:
&
[
Header
]
)
{
let
expected_response_header_1
=
&
[
(
String
:
:
from
(
"
:
method
"
)
String
:
:
from
(
"
GET
"
)
)
(
String
:
:
from
(
"
:
scheme
"
)
String
:
:
from
(
"
https
"
)
)
(
String
:
:
from
(
"
:
authority
"
)
String
:
:
from
(
"
something
.
com
"
)
)
(
String
:
:
from
(
"
:
path
"
)
String
:
:
from
(
"
/
"
)
)
]
;
assert_eq
!
(
header
expected_response_header_1
)
;
}
fn
send_push_promise
(
conn
:
&
mut
Connection
stream_id
:
u64
push_id
:
u64
)
{
let
frame
=
HFrame
:
:
PushPromise
{
push_id
header_block
:
PUSH_PROMISE_DATA
.
to_vec
(
)
}
;
let
mut
d
=
Encoder
:
:
default
(
)
;
frame
.
encode
(
&
mut
d
)
;
let
_
=
conn
.
stream_send
(
stream_id
&
d
)
.
unwrap
(
)
;
}
fn
send_push_data_and_exchange_packets
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
push_id
:
u8
close_push_stream
:
bool
)
-
>
u64
{
let
push_stream_id
=
send_push_data
(
&
mut
server
.
conn
push_id
close_push_stream
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
push_stream_id
}
fn
send_push_promise_and_exchange_packets
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
stream_id
:
u64
push_id
:
u64
)
{
send_push_promise
(
&
mut
server
.
conn
stream_id
push_id
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
}
fn
send_cancel_push_and_exchange_packets
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
push_id
:
u64
)
{
let
frame
=
HFrame
:
:
CancelPush
{
push_id
}
;
let
mut
d
=
Encoder
:
:
default
(
)
;
frame
.
encode
(
&
mut
d
)
;
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
d
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
}
const
PUSH_DATA
:
&
[
u8
]
=
&
[
0x01
0x06
0x00
0x00
0xd9
0x54
0x01
0x34
0x0
0x4
0x61
0x62
0x63
0x64
]
;
fn
check_push_response_header
(
header
:
&
[
Header
]
)
{
let
expected_push_response_header
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
4
"
)
)
]
;
assert_eq
!
(
header
&
expected_push_response_header
[
.
.
]
)
;
}
const
EXPECTED_PUSH_RESPONSE_DATA_FRAME
:
&
[
u8
]
=
&
[
0x61
0x62
0x63
0x64
]
;
fn
send_data_on_push
(
conn
:
&
mut
Connection
push_stream_id
:
u64
push_id
:
u8
data
:
&
[
u8
]
close_push_stream
:
bool
)
{
let
_
=
conn
.
stream_send
(
push_stream_id
PUSH_STREAM_TYPE
)
.
unwrap
(
)
;
let
_
=
conn
.
stream_send
(
push_stream_id
&
[
push_id
]
)
.
unwrap
(
)
;
let
_
=
conn
.
stream_send
(
push_stream_id
data
)
.
unwrap
(
)
;
if
close_push_stream
{
conn
.
stream_close_send
(
push_stream_id
)
.
unwrap
(
)
;
}
}
fn
send_push_data
(
conn
:
&
mut
Connection
push_id
:
u8
close_push_stream
:
bool
)
-
>
u64
{
send_push_with_data
(
conn
push_id
PUSH_DATA
close_push_stream
)
}
fn
send_push_with_data
(
conn
:
&
mut
Connection
push_id
:
u8
data
:
&
[
u8
]
close_push_stream
:
bool
)
-
>
u64
{
let
push_stream_id
=
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
send_data_on_push
(
conn
push_stream_id
push_id
data
close_push_stream
)
;
push_stream_id
}
struct
PushPromiseInfo
{
pub
push_id
:
u64
pub
ref_stream_id
:
u64
}
fn
read_response_and_push_events
(
client
:
&
mut
Http3Client
push_promises
:
&
[
PushPromiseInfo
]
push_streams
:
&
[
u64
]
response_stream_id
:
u64
)
{
let
mut
num_push_promises
=
0
;
let
mut
num_push_stream_headers
=
0
;
let
mut
num_push_stream_data
=
0
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
PushPromise
{
push_id
request_stream_id
headers
}
=
>
{
assert
!
(
push_promises
.
iter
(
)
.
any
(
|
p
|
p
.
push_id
=
=
push_id
&
&
p
.
ref_stream_id
=
=
request_stream_id
)
)
;
check_pushpromise_header
(
&
headers
[
.
.
]
)
;
num_push_promises
+
=
1
;
}
Http3ClientEvent
:
:
PushHeaderReady
{
push_id
headers
interim
fin
}
=
>
{
assert
!
(
push_streams
.
contains
(
&
push_id
)
)
;
check_push_response_header
(
&
headers
)
;
num_push_stream_headers
+
=
1
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
PushDataReadable
{
push_id
}
=
>
{
assert
!
(
push_streams
.
contains
(
&
push_id
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
client
.
push_read_data
(
now
(
)
push_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
EXPECTED_PUSH_RESPONSE_DATA_FRAME
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_PUSH_RESPONSE_DATA_FRAME
)
;
num_push_stream_data
+
=
1
;
}
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
response_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
response_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
_
)
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
amount
EXPECTED_RESPONSE_DATA_2_FRAME_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_RESPONSE_DATA_2_FRAME_1
)
;
}
_
=
>
{
}
}
}
assert_eq
!
(
num_push_promises
push_promises
.
len
(
)
)
;
assert_eq
!
(
num_push_stream_headers
push_streams
.
len
(
)
)
;
assert_eq
!
(
num_push_stream_data
push_streams
.
len
(
)
)
;
}
#
[
test
]
fn
test_client_connect_and_exchange_qpack_and_control_streams
(
)
{
let
_
=
connect
(
)
;
}
#
[
test
]
fn
test_client_close_control_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_close_send
(
server
.
control_stream_id
.
unwrap
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_reset_control_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_reset_send
(
server
.
control_stream_id
.
unwrap
(
)
Error
:
:
HttpNoError
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_reset_server_side_encoder_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_reset_send
(
server
.
encoder_stream_id
.
unwrap
(
)
Error
:
:
HttpNoError
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_reset_server_side_decoder_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_reset_send
(
server
.
decoder_stream_id
.
unwrap
(
)
Error
:
:
HttpNoError
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_stop_sending_control_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_stop_sending
(
CLIENT_SIDE_CONTROL_STREAM_ID
Error
:
:
HttpNoError
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_stop_sending_encoder_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_stop_sending
(
CLIENT_SIDE_ENCODER_STREAM_ID
Error
:
:
HttpNoError
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_stop_sending_decoder_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
server
.
conn
.
stream_stop_sending
(
CLIENT_SIDE_DECODER_STREAM_ID
Error
:
:
HttpNoError
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpClosedCriticalStream
)
;
}
#
[
test
]
fn
test_client_missing_settings
(
)
{
let
(
mut
client
mut
server
)
=
connect_only_transport
(
)
;
let
control_stream
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x0
0x1
0x3
0x0
0x1
0x2
]
)
;
assert_eq
!
(
sent
Ok
(
6
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpMissingSettings
)
;
}
#
[
test
]
fn
test_client_receive_settings_twice
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
sent
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x4
0x6
0x1
0x40
0x64
0x7
0x40
0x64
]
)
;
assert_eq
!
(
sent
Ok
(
8
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpFrameUnexpected
)
;
}
fn
test_wrong_frame_on_control_stream
(
v
:
&
[
u8
]
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
v
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpFrameUnexpected
)
;
}
#
[
test
]
fn
test_data_frame_on_control_stream
(
)
{
test_wrong_frame_on_control_stream
(
&
[
0x0
0x2
0x1
0x2
]
)
;
}
#
[
test
]
fn
test_headers_frame_on_control_stream
(
)
{
test_wrong_frame_on_control_stream
(
&
[
0x1
0x2
0x1
0x2
]
)
;
}
#
[
test
]
fn
test_push_promise_frame_on_control_stream
(
)
{
test_wrong_frame_on_control_stream
(
&
[
0x5
0x2
0x1
0x2
]
)
;
}
fn
test_wrong_frame_on_push_stream
(
v
:
&
[
u8
]
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
let
push_stream_id
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
_
=
server
.
conn
.
stream_send
(
push_stream_id
&
[
0x01
0x0
]
)
.
unwrap
(
)
;
let
_
=
server
.
conn
.
stream_send
(
push_stream_id
v
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpFrameUnexpected
)
;
}
#
[
test
]
fn
test_cancel_push_frame_on_push_stream
(
)
{
test_wrong_frame_on_push_stream
(
&
[
0x3
0x1
0x5
]
)
;
}
#
[
test
]
fn
test_settings_frame_on_push_stream
(
)
{
test_wrong_frame_on_push_stream
(
&
[
0x4
0x4
0x6
0x4
0x8
0x4
]
)
;
}
#
[
test
]
fn
test_push_promise_frame_on_push_stream
(
)
{
test_wrong_frame_on_push_stream
(
&
[
0x5
0x2
0x1
0x2
]
)
;
}
#
[
test
]
fn
test_goaway_frame_on_push_stream
(
)
{
test_wrong_frame_on_push_stream
(
&
[
0x7
0x1
0x5
]
)
;
}
#
[
test
]
fn
test_max_push_id_frame_on_push_stream
(
)
{
test_wrong_frame_on_push_stream
(
&
[
0xd
0x1
0x5
]
)
;
}
#
[
test
]
fn
test_data_frame_on_push_stream
(
)
{
test_wrong_frame_on_push_stream
(
&
[
0x0
0x2
0x1
0x2
]
)
;
}
#
[
test
]
fn
test_client_received_unknown_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
new_stream_id
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
_
=
server
.
conn
.
stream_send
(
new_stream_id
&
[
0x41
0x19
0x4
0x4
0x6
0x0
0x8
0x0
]
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
stop_sending_event_found
=
false
;
while
let
Some
(
e
)
=
server
.
conn
.
next_event
(
)
{
if
let
ConnectionEvent
:
:
SendStreamStopSending
{
stream_id
app_error
}
=
e
{
stop_sending_event_found
=
true
;
assert_eq
!
(
stream_id
new_stream_id
)
;
assert_eq
!
(
app_error
Error
:
:
HttpStreamCreation
.
code
(
)
)
;
}
}
assert
!
(
stop_sending_event_found
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
fn
test_wrong_frame_on_request_stream
(
v
:
&
[
u8
]
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
v
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpFrameUnexpected
)
;
}
#
[
test
]
fn
test_cancel_push_frame_on_request_stream
(
)
{
test_wrong_frame_on_request_stream
(
&
[
0x3
0x1
0x5
]
)
;
}
#
[
test
]
fn
test_settings_frame_on_request_stream
(
)
{
test_wrong_frame_on_request_stream
(
&
[
0x4
0x4
0x6
0x4
0x8
0x4
]
)
;
}
#
[
test
]
fn
test_goaway_frame_on_request_stream
(
)
{
test_wrong_frame_on_request_stream
(
&
[
0x7
0x1
0x5
]
)
;
}
#
[
test
]
fn
test_max_push_id_frame_on_request_stream
(
)
{
test_wrong_frame_on_request_stream
(
&
[
0xd
0x1
0x5
]
)
;
}
#
[
test
]
fn
test_frame_reading
(
)
{
let
(
mut
client
mut
server
)
=
connect_only_transport
(
)
;
let
control_stream
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
mut
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x0
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x4
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x4
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x6
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x0
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x8
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x0
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x5
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x5
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x4
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x61
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x62
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x63
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
[
0x64
]
)
;
assert_eq
!
(
sent
Ok
(
1
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpFrameUnexpected
)
;
}
#
[
test
]
fn
fetch_basic
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_1
true
)
;
let
http_events
=
client
.
events
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
assert_eq
!
(
http_events
.
len
(
)
2
)
;
for
e
in
http_events
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_1
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
EXPECTED_RESPONSE_DATA_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_RESPONSE_DATA_1
)
;
}
_
=
>
{
}
}
}
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
fn
read_response
(
client
:
&
mut
Http3Client
server
:
&
mut
Connection
request_stream_id
:
u64
)
{
let
out
=
server
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
EXPECTED_RESPONSE_DATA_2_FRAME_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_RESPONSE_DATA_2_FRAME_1
)
;
}
_
=
>
{
}
}
}
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
const
REQUEST_BODY
:
&
[
u8
]
=
&
[
0x64
0x65
0x66
]
;
const
EXPECTED_REQUEST_BODY_FRAME
:
&
[
u8
]
=
&
[
0x0
0x3
0x64
0x65
0x66
]
;
#
[
test
]
fn
fetch_with_data
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
let
data_writable
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataWritable
{
.
.
}
)
;
assert
!
(
client
.
events
(
)
.
any
(
data_writable
)
)
;
let
sent
=
client
.
send_request_body
(
request_stream_id
REQUEST_BODY
)
.
unwrap
(
)
;
assert_eq
!
(
sent
REQUEST_BODY
.
len
(
)
)
;
let
_
=
client
.
stream_close_send
(
request_stream_id
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
server
.
conn
.
next_event
(
)
{
match
e
{
ConnectionEvent
:
:
NewStream
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
.
as_u64
(
)
request_stream_id
)
;
assert_eq
!
(
stream_id
.
stream_type
(
)
StreamType
:
:
BiDi
)
;
}
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
server
.
conn
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
EXPECTED_REQUEST_BODY_FRAME
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_REQUEST_BODY_FRAME
)
;
let
_
=
server
.
conn
.
stream_send
(
stream_id
HTTP_RESPONSE_2
)
;
server
.
conn
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
}
_
=
>
{
}
}
}
read_response
(
&
mut
client
&
mut
server
.
conn
request_stream_id
)
;
}
fn
fetch_with_data_length_xbytes
(
request_body
:
&
[
u8
]
expected_data_frame_header
:
&
[
u8
]
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
let
data_writable
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataWritable
{
.
.
}
)
;
assert
!
(
client
.
events
(
)
.
any
(
data_writable
)
)
;
let
sent
=
client
.
send_request_body
(
request_stream_id
request_body
)
;
assert_eq
!
(
sent
Ok
(
request_body
.
len
(
)
)
)
;
let
_
=
client
.
stream_close_send
(
request_stream_id
)
;
let
mut
out
=
client
.
process
(
None
now
(
)
)
;
for
_i
in
0
.
.
20
{
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
}
while
let
Some
(
e
)
=
server
.
conn
.
next_event
(
)
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
if
stream_id
=
=
request_stream_id
{
let
mut
buf
=
vec
!
[
1_u8
;
RECV_BUFFER_SIZE
]
;
let
(
amount
fin
)
=
server
.
conn
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
request_body
.
len
(
)
+
expected_data_frame_header
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
expected_data_frame_header
.
len
(
)
]
expected_data_frame_header
)
;
assert_eq
!
(
&
buf
[
expected_data_frame_header
.
len
(
)
.
.
amount
]
request_body
)
;
let
_
=
server
.
conn
.
stream_send
(
stream_id
HTTP_RESPONSE_2
)
;
server
.
conn
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
}
}
}
read_response
(
&
mut
client
&
mut
server
.
conn
request_stream_id
)
;
}
#
[
test
]
fn
fetch_with_data_length_63bytes
(
)
{
fetch_with_data_length_xbytes
(
&
[
0_u8
;
63
]
&
[
0x0
0x3f
]
)
;
}
#
[
test
]
fn
fetch_with_data_length_64bytes
(
)
{
fetch_with_data_length_xbytes
(
&
[
0_u8
;
64
]
&
[
0x0
0x40
0x40
]
)
;
}
#
[
test
]
fn
fetch_with_data_length_16383bytes
(
)
{
fetch_with_data_length_xbytes
(
&
[
0_u8
;
16383
]
&
[
0x0
0x7f
0xff
]
)
;
}
#
[
test
]
fn
fetch_with_data_length_16384bytes
(
)
{
fetch_with_data_length_xbytes
(
&
[
0_u8
;
16384
]
&
[
0x0
0x80
0x0
0x40
0x0
]
)
;
}
#
[
allow
(
clippy
:
:
useless_vec
)
]
fn
fetch_with_two_data_frames
(
first_frame
:
&
[
u8
]
expected_first_data_frame_header
:
&
[
u8
]
expected_second_data_frame_header
:
&
[
u8
]
expected_second_data_frame
:
&
[
u8
]
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
let
data_writable
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataWritable
{
.
.
}
)
;
assert
!
(
client
.
events
(
)
.
any
(
data_writable
)
)
;
let
sent
=
client
.
send_request_body
(
request_stream_id
first_frame
)
;
assert_eq
!
(
sent
Ok
(
first_frame
.
len
(
)
)
)
;
let
sent
=
client
.
send_request_body
(
request_stream_id
&
vec
!
[
0_u8
;
SEND_BUFFER_SIZE
]
)
;
assert_eq
!
(
sent
Ok
(
expected_second_data_frame
.
len
(
)
)
)
;
let
_
=
client
.
stream_close_send
(
request_stream_id
)
;
let
mut
out
=
client
.
process
(
None
now
(
)
)
;
for
_i
in
0
.
.
SEND_BUFFER_SIZE
/
1000
{
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
}
while
let
Some
(
e
)
=
server
.
conn
.
next_event
(
)
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
if
stream_id
=
=
request_stream_id
{
let
mut
buf
=
vec
!
[
1_u8
;
RECV_BUFFER_SIZE
]
;
let
(
amount
fin
)
=
server
.
conn
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
expected_first_data_frame_header
.
len
(
)
+
first_frame
.
len
(
)
+
expected_second_data_frame_header
.
len
(
)
+
expected_second_data_frame
.
len
(
)
)
;
let
end
=
expected_first_data_frame_header
.
len
(
)
;
assert_eq
!
(
&
buf
[
.
.
end
]
expected_first_data_frame_header
)
;
let
start
=
end
;
let
end
=
end
+
first_frame
.
len
(
)
;
assert_eq
!
(
&
buf
[
start
.
.
end
]
first_frame
)
;
let
start2
=
end
;
let
end2
=
end
+
expected_second_data_frame_header
.
len
(
)
;
assert_eq
!
(
&
buf
[
start2
.
.
end2
]
expected_second_data_frame_header
)
;
let
start3
=
end2
;
let
end3
=
end2
+
expected_second_data_frame
.
len
(
)
;
assert_eq
!
(
&
buf
[
start3
.
.
end3
]
expected_second_data_frame
)
;
let
_
=
server
.
conn
.
stream_send
(
stream_id
HTTP_RESPONSE_2
)
;
server
.
conn
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
}
}
}
read_response
(
&
mut
client
&
mut
server
.
conn
request_stream_id
)
;
}
fn
alloc_buffer
(
size
:
usize
)
-
>
(
Vec
<
u8
>
Vec
<
u8
>
)
{
let
data_frame
=
HFrame
:
:
Data
{
len
:
size
as
u64
}
;
let
mut
enc
=
Encoder
:
:
default
(
)
;
data_frame
.
encode
(
&
mut
enc
)
;
(
vec
!
[
0_u8
;
size
]
enc
.
to_vec
(
)
)
}
#
[
test
]
fn
fetch_two_data_frame_second_63bytes
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
88
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x3f
]
&
[
0_u8
;
63
]
)
;
}
#
[
test
]
fn
fetch_two_data_frame_second_63bytes_place_for_66
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
89
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x3f
]
&
[
0_u8
;
63
]
)
;
}
#
[
test
]
fn
fetch_two_data_frame_second_64bytes_place_for_67
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
90
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x40
0x40
]
&
[
0_u8
;
64
]
)
;
}
#
[
test
]
fn
fetch_two_data_frame_second_16383bytes
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
16409
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x7f
0xff
]
&
[
0_u8
;
16383
]
)
;
}
#
[
test
]
fn
fetch_two_data_frame_second_16383bytes_place_for_16387
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
16410
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x7f
0xff
]
&
[
0_u8
;
16383
]
)
;
}
#
[
test
]
fn
fetch_two_data_frame_second_16383bytes_place_for_16388
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
16411
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x7f
0xff
]
&
[
0_u8
;
16383
]
)
;
}
#
[
test
]
fn
fetch_two_data_frame_second_16384bytes_place_for_16389
(
)
{
let
(
buf
hdr
)
=
alloc_buffer
(
SEND_BUFFER_SIZE
-
16412
)
;
fetch_with_two_data_frames
(
&
buf
&
hdr
&
[
0x0
0x80
0x0
0x40
0x0
]
&
[
0_u8
;
16384
]
)
;
}
#
[
test
]
fn
test_stop_sending_early_response
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_stop_sending
(
request_stream_id
Error
:
:
HttpNoError
.
code
(
)
)
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
let
mut
stop_sending
=
false
;
let
mut
response_headers
=
false
;
let
mut
response_body
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
StopSending
{
stream_id
error
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpNoError
.
code
(
)
)
;
assert_eq
!
(
Err
(
Error
:
:
InvalidStreamId
)
client
.
send_request_body
(
request_stream_id
&
[
0_u8
;
10
]
)
)
;
stop_sending
=
true
;
}
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
response_headers
=
true
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
amount
EXPECTED_RESPONSE_DATA_2_FRAME_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_RESPONSE_DATA_2_FRAME_1
)
;
response_body
=
true
;
}
_
=
>
{
}
}
}
assert
!
(
response_headers
)
;
assert
!
(
response_body
)
;
assert
!
(
stop_sending
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
#
[
test
]
fn
test_stop_sending_other_error_with_reset
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_stop_sending
(
request_stream_id
Error
:
:
HttpRequestRejected
.
code
(
)
)
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_reset_send
(
request_stream_id
Error
:
:
HttpRequestRejected
.
code
(
)
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
reset
=
false
;
let
mut
stop_sending
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
StopSending
{
stream_id
error
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
stop_sending
=
true
;
}
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
assert_eq
!
(
local
false
)
;
reset
=
true
;
}
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
any
headers
or
data
"
)
;
}
_
=
>
{
}
}
}
assert
!
(
reset
)
;
assert
!
(
stop_sending
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
#
[
test
]
fn
test_stop_sending_other_error_wo_reset
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_stop_sending
(
request_stream_id
Error
:
:
HttpRequestRejected
.
code
(
)
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
stop_sending
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
StopSending
{
stream_id
error
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
stop_sending
=
true
;
}
Http3ClientEvent
:
:
Reset
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
StopSending
.
"
)
;
}
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
any
headers
or
data
"
)
;
}
_
=
>
{
}
}
}
assert
!
(
stop_sending
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert
!
(
res
.
is_ok
(
)
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
#
[
test
]
fn
test_stop_sending_and_reset_other_error_with_events
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
false
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_stop_sending
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_reset_send
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
reset
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
StopSending
{
stream_id
error
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
}
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
local
false
)
;
reset
=
true
;
}
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
any
headers
or
data
"
)
;
}
_
=
>
{
}
}
}
assert
!
(
reset
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
#
[
test
]
fn
test_stop_sending_other_error_with_events
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
false
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_stop_sending
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
stop_sending
=
false
;
let
mut
header_ready
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
StopSending
{
stream_id
error
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
stop_sending
=
true
;
}
Http3ClientEvent
:
:
Reset
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
StopSending
.
"
)
;
}
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
header_ready
=
true
;
}
_
=
>
{
}
}
}
assert
!
(
stop_sending
)
;
assert
!
(
header_ready
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
amount
EXPECTED_RESPONSE_DATA_2_FRAME_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
amount
]
EXPECTED_RESPONSE_DATA_2_FRAME_1
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
#
[
test
]
fn
test_reset_wo_stop_sending
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
assert_eq
!
(
Ok
(
(
)
)
server
.
conn
.
stream_reset_send
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
reset
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
StopSending
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
StopSending
.
"
)
;
}
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
local
false
)
;
reset
=
true
;
}
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
any
headers
or
data
"
)
;
}
_
=
>
{
}
}
}
assert
!
(
reset
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
fn
test_incomplet_frame
(
buf
:
&
[
u8
]
error
:
&
Error
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
buf
true
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf_res
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf_res
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
HttpFrame
)
;
}
}
assert_closed
(
&
client
&
error
)
;
}
#
[
test
]
fn
test_incomplet_data_frame
(
)
{
test_incomplet_frame
(
&
HTTP_RESPONSE_2
[
.
.
12
]
&
Error
:
:
HttpFrame
)
;
}
#
[
test
]
fn
test_incomplet_headers_frame
(
)
{
test_incomplet_frame
(
&
HTTP_RESPONSE_2
[
.
.
7
]
&
Error
:
:
HttpFrame
)
;
}
#
[
test
]
fn
test_incomplet_unknown_frame
(
)
{
test_incomplet_frame
(
&
[
0x21
]
&
Error
:
:
HttpFrame
)
;
}
#
[
test
]
fn
test_goaway
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
request_stream_id_1
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_1
0
)
;
let
request_stream_id_2
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_2
4
)
;
let
request_stream_id_3
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_3
8
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x7
0x1
0x8
]
)
;
while
let
Some
(
e
)
=
server
.
conn
.
next_event
(
)
{
if
let
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
}
=
e
{
let
mut
buf
=
[
0_u8
;
100
]
;
let
_
=
server
.
conn
.
stream_recv
(
stream_id
&
mut
buf
)
.
unwrap
(
)
;
if
(
stream_id
=
=
request_stream_id_1
)
|
|
(
stream_id
=
=
request_stream_id_2
)
{
let
_
=
server
.
conn
.
stream_send
(
stream_id
HTTP_RESPONSE_1
)
;
server
.
conn
.
stream_close_send
(
stream_id
)
.
unwrap
(
)
;
}
}
}
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
stream_reset
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
headers
fin
.
.
}
=
>
{
check_response_header_1
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert
!
(
(
stream_id
=
=
request_stream_id_1
)
|
|
(
stream_id
=
=
request_stream_id_2
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
(
EXPECTED_RESPONSE_DATA_1
.
len
(
)
true
)
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
)
;
}
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id_3
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
assert_eq
!
(
local
false
)
;
stream_reset
=
true
;
}
_
=
>
{
}
}
}
assert
!
(
stream_reset
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
GoingAway
(
8
)
)
;
assert_eq
!
(
client
.
fetch
(
now
(
)
"
GET
"
"
https
"
"
something
.
com
"
"
/
"
&
[
]
)
Err
(
Error
:
:
AlreadyClosed
)
)
;
client
.
close
(
now
(
)
0
"
"
)
;
}
#
[
test
]
fn
multiple_goaways
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
request_stream_id_1
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_1
0
)
;
let
request_stream_id_2
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_2
4
)
;
let
request_stream_id_3
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_3
8
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x7
0x1
0x8
]
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
stream_reset_1
=
0
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id_3
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
assert_eq
!
(
local
false
)
;
stream_reset_1
+
=
1
;
}
}
assert_eq
!
(
stream_reset_1
1
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
GoingAway
(
8
)
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x7
0x1
0x4
]
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id_1
HTTP_RESPONSE_1
true
)
;
let
mut
stream_reset_2
=
0
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
headers
fin
.
.
}
=
>
{
check_response_header_1
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert
!
(
stream_id
=
=
request_stream_id_1
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
(
EXPECTED_RESPONSE_DATA_1
.
len
(
)
true
)
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
)
;
}
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id_2
)
;
assert_eq
!
(
error
Error
:
:
HttpRequestRejected
.
code
(
)
)
;
assert_eq
!
(
local
false
)
;
stream_reset_2
+
=
1
;
}
_
=
>
{
}
}
}
assert_eq
!
(
stream_reset_2
1
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
GoingAway
(
4
)
)
;
}
#
[
test
]
fn
multiple_goaways_stream_id_increased
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
request_stream_id_1
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_1
0
)
;
let
request_stream_id_2
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_2
4
)
;
let
request_stream_id_3
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_3
8
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x7
0x1
0x4
]
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
GoingAway
(
4
)
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x7
0x1
0x8
]
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpGeneralProtocol
)
;
}
#
[
test
]
fn
goaway_wrong_stream_id
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
_
=
server
.
conn
.
stream_send
(
server
.
control_stream_id
.
unwrap
(
)
&
[
0x7
0x1
0x9
]
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpId
)
;
}
#
[
test
]
fn
test_stream_fin_wo_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
e
=
client
.
events
(
)
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
e
Http3ClientEvent
:
:
Reset
{
stream_id
:
request_stream_id
error
:
Error
:
:
HttpGeneralProtocolStream
.
code
(
)
local
:
true
}
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_stream_fin_after_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_2
true
)
;
let
e
=
client
.
events
(
)
.
next
(
)
.
unwrap
(
)
;
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
interim
false
)
;
}
else
{
panic
!
(
"
wrong
event
type
"
)
;
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_stream_fin_after_headers_are_read_wo_data_frame
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_2
false
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
receive
a
DataGeadable
event
!
"
)
;
}
_
=
>
{
}
}
;
}
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
another
HeaderReady
!
"
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
;
let
(
len
fin
)
=
res
.
expect
(
"
should
read
"
)
;
assert_eq
!
(
0
len
)
;
assert_eq
!
(
fin
true
)
;
}
_
=
>
{
}
}
;
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_stream_fin_after_headers_and_a_empty_data_frame
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_2
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
&
[
0x00
0x00
]
)
;
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
Ok
(
(
0
true
)
)
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
)
;
}
_
=
>
{
}
}
;
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_stream_fin_after_headers_an_empty_data_frame_are_read
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_2
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
&
[
0x00
0x00
]
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
receive
a
DataGeadable
event
!
"
)
;
}
_
=
>
{
}
}
;
}
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
=
>
{
panic
!
(
"
We
should
not
get
another
HeaderReady
!
"
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
;
let
(
len
fin
)
=
res
.
expect
(
"
should
read
"
)
;
assert_eq
!
(
0
len
)
;
assert_eq
!
(
fin
true
)
;
}
_
=
>
{
}
}
;
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_stream_fin_after_a_data_frame
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
false
)
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_2
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
;
let
(
len
fin
)
=
res
.
expect
(
"
should
have
data
"
)
;
assert_eq
!
(
len
EXPECTED_RESPONSE_DATA_2_FRAME_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
len
]
EXPECTED_RESPONSE_DATA_2_FRAME_1
)
;
assert_eq
!
(
fin
false
)
;
}
_
=
>
{
}
}
;
}
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
e
=
client
.
events
(
)
.
next
(
)
.
unwrap
(
)
;
if
let
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0
;
100
]
;
let
res
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
;
let
(
len
fin
)
=
res
.
expect
(
"
should
read
"
)
;
assert_eq
!
(
0
len
)
;
assert_eq
!
(
fin
true
)
;
}
else
{
panic
!
(
"
wrong
event
type
"
)
;
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_multiple_data_frames
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_1
true
)
;
match
client
.
events
(
)
.
nth
(
1
)
.
unwrap
(
)
{
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
(
EXPECTED_RESPONSE_DATA_1
.
len
(
)
true
)
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
)
;
}
x
=
>
{
eprintln
!
(
"
event
{
:
?
}
"
x
)
;
panic
!
(
)
}
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_receive_grease_before_response
(
)
{
const
UNKNOWN_FRAME_LEN
:
usize
=
832
;
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
mut
enc
=
Encoder
:
:
with_capacity
(
UNKNOWN_FRAME_LEN
+
4
)
;
enc
.
encode_varint
(
1028_u64
)
;
enc
.
encode_varint
(
UNKNOWN_FRAME_LEN
as
u64
)
;
let
mut
buf
:
Vec
<
_
>
=
enc
.
into
(
)
;
buf
.
resize
(
UNKNOWN_FRAME_LEN
+
buf
.
len
(
)
0
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
&
buf
)
.
unwrap
(
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
match
client
.
events
(
)
.
nth
(
1
)
.
unwrap
(
)
{
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
len
fin
)
=
client
.
read_response_data
(
now
(
)
stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
len
EXPECTED_RESPONSE_DATA_2_FRAME_1
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
len
]
EXPECTED_RESPONSE_DATA_2_FRAME_1
)
;
assert_eq
!
(
fin
true
)
;
}
x
=
>
{
eprintln
!
(
"
event
{
:
?
}
"
x
)
;
panic
!
(
)
}
}
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
test_read_frames_header_blocked
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
encoder_inst_pkt
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
let
d_frame
=
HFrame
:
:
Data
{
len
:
3
}
;
d_frame
.
encode
(
&
mut
d
)
;
d
.
encode
(
&
[
0x61
0x62
0x63
]
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
true
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_
=
client
.
process
(
encoder_inst_pkt
.
dgram
(
)
now
(
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
client
.
process
(
None
now
(
)
)
;
let
mut
recv_header
=
false
;
let
mut
recv_data
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
match
e
{
Http3ClientEvent
:
:
HeaderReady
{
stream_id
.
.
}
=
>
{
assert_eq
!
(
stream_id
request_stream_id
)
;
recv_header
=
true
;
}
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
=
>
{
recv_data
=
true
;
assert_eq
!
(
stream_id
request_stream_id
)
;
}
x
=
>
{
eprintln
!
(
"
event
{
:
?
}
"
x
)
;
panic
!
(
)
}
}
}
assert
!
(
recv_header
&
&
recv_data
)
;
}
#
[
test
]
fn
test_read_frames_header_blocked_with_fin_after_headers
(
)
{
let
(
mut
hconn
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
hconn
&
mut
server
)
;
let
sent_headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
0
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
sent_headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
encoder_inst_pkt
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
hconn
&
mut
server
request_stream_id
&
d
true
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
hconn
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_out
=
hconn
.
process
(
encoder_inst_pkt
.
dgram
(
)
now
(
)
)
;
let
mut
recv_header
=
false
;
while
let
Some
(
e
)
=
hconn
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
assert_eq
!
(
headers
sent_headers
)
;
assert_eq
!
(
fin
true
)
;
assert_eq
!
(
interim
false
)
;
recv_header
=
true
;
}
else
{
panic
!
(
"
event
{
:
?
}
"
e
)
;
}
}
assert
!
(
recv_header
)
;
}
fn
exchange_token
(
client
:
&
mut
Http3Client
server
:
&
mut
Connection
)
-
>
ResumptionToken
{
server
.
send_ticket
(
now
(
)
&
[
]
)
.
expect
(
"
can
send
ticket
"
)
;
let
out
=
server
.
process_output
(
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
client
.
process_input
(
out
.
dgram
(
)
.
unwrap
(
)
now
(
)
)
;
client
.
process_output
(
now
(
)
+
Duration
:
:
from_millis
(
250
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
Http3ClientEvent
:
:
ResumptionToken
(
token
)
=
e
{
Some
(
token
)
}
else
{
None
}
}
)
.
unwrap
(
)
}
fn
start_with_0rtt
(
)
-
>
(
Http3Client
TestServer
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
token
=
exchange_token
(
&
mut
client
&
mut
server
.
conn
)
;
let
mut
client
=
default_http3_client
(
)
;
let
server
=
TestServer
:
:
new
(
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Initializing
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
expect
(
"
Set
resumption
token
.
"
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
ZeroRtt
)
;
let
zerortt_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
StateChange
(
Http3State
:
:
ZeroRtt
)
)
;
assert
!
(
client
.
events
(
)
.
any
(
zerortt_event
)
)
;
(
client
server
)
}
#
[
test
]
fn
zero_rtt_negotiated
(
)
{
let
(
mut
client
mut
server
)
=
start_with_0rtt
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
ZeroRtt
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Init
)
;
let
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
server
.
check_control_qpack_request_streams_resumption
(
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
EXPECTED_REQUEST_HEADER_FRAME
false
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Handshaking
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
server
.
conn
.
state
(
)
.
connected
(
)
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
assert
!
(
server
.
conn
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
}
#
[
test
]
fn
zero_rtt_send_request
(
)
{
let
(
mut
client
mut
server
)
=
start_with_0rtt
(
)
;
let
request_stream_id
=
make_request
(
&
mut
client
true
&
[
(
String
:
:
from
(
"
myheaders
"
)
String
:
:
from
(
"
myvalue
"
)
)
]
)
;
assert_eq
!
(
request_stream_id
0
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
ZeroRtt
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Init
)
;
let
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
server
.
check_control_qpack_request_streams_resumption
(
ENCODER_STREAM_DATA_WITH_CAP_INST_AND_ENCODING_INST
EXPECTED_REQUEST_HEADER_FRAME_VERSION2
true
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Handshaking
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
let
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
server
.
conn
.
state
(
)
.
connected
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
out
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
res
=
server
.
conn
.
stream_send
(
request_stream_id
HTTP_RESPONSE_2
)
;
assert_eq
!
(
res
Ok
(
HTTP_RESPONSE_2
.
len
(
)
)
)
;
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
read_response
(
&
mut
client
&
mut
server
.
conn
request_stream_id
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
assert
!
(
server
.
conn
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
}
#
[
test
]
fn
zero_rtt_before_resumption_token
(
)
{
let
mut
client
=
default_http3_client
(
)
;
assert
!
(
client
.
fetch
(
now
(
)
"
GET
"
"
https
"
"
something
.
com
"
"
/
"
&
[
]
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
zero_rtt_send_reject
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
let
token
=
exchange_token
(
&
mut
client
&
mut
server
.
conn
)
;
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
Connection
:
:
new_server
(
test_fixture
:
:
DEFAULT_KEYS
test_fixture
:
:
DEFAULT_ALPN_H3
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
ConnectionParameters
:
:
default
(
)
)
.
unwrap
(
)
;
let
ar
=
AntiReplay
:
:
new
(
now
(
)
test_fixture
:
:
ANTI_REPLAY_WINDOW
1
3
)
.
expect
(
"
setup
anti
-
replay
"
)
;
server
.
server_enable_0rtt
(
&
ar
AllowZeroRtt
{
}
)
.
expect
(
"
enable
0
-
RTT
"
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Initializing
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
expect
(
"
Set
resumption
token
.
"
)
;
let
zerortt_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
StateChange
(
Http3State
:
:
ZeroRtt
)
)
;
assert
!
(
client
.
events
(
)
.
any
(
zerortt_event
)
)
;
let
client_hs
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
request_stream_id
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id
0
)
;
let
client_0rtt
=
client
.
process
(
None
now
(
)
)
;
assert
!
(
client_0rtt
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_hs
=
server
.
process
(
client_hs
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_hs
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
server_ignored
=
server
.
process
(
client_0rtt
.
dgram
(
)
now
(
)
)
;
assert
!
(
server_ignored
.
as_dgram_ref
(
)
.
is_none
(
)
)
;
let
recvd_stream_evt
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
NewStream
{
.
.
}
)
;
assert
!
(
!
server
.
events
(
)
.
any
(
recvd_stream_evt
)
)
;
let
client_out
=
client
.
process
(
server_hs
.
dgram
(
)
now
(
)
)
;
assert
!
(
client_out
.
as_dgram_ref
(
)
.
is_some
(
)
)
;
let
recvd_0rtt_reject
=
|
e
|
e
=
=
Http3ClientEvent
:
:
ZeroRttRejected
;
assert
!
(
client
.
events
(
)
.
any
(
recvd_0rtt_reject
)
)
;
let
res
=
client
.
stream_close_send
(
request_stream_id
)
;
assert
!
(
res
.
is_err
(
)
)
;
assert_eq
!
(
res
.
unwrap_err
(
)
Error
:
:
InvalidStreamId
)
;
let
_
=
server
.
process
(
client_out
.
dgram
(
)
now
(
)
)
;
TestServer
:
:
new_with_conn
(
server
)
.
check_client_control_qpack_streams_no_resumption
(
)
;
assert_eq
!
(
make_request
(
&
mut
client
false
&
[
]
)
0
)
;
}
fn
zero_rtt_change_settings
(
original_settings
:
&
[
HSetting
]
resumption_settings
:
&
[
HSetting
]
expected_client_state
:
&
Http3State
expected_encoder_stream_data
:
&
[
u8
]
)
{
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
TestServer
:
:
new_with_settings
(
original_settings
)
;
connect_with
(
&
mut
client
&
mut
server
)
;
let
token
=
exchange_token
(
&
mut
client
&
mut
server
.
conn
)
;
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
TestServer
:
:
new_with_settings
(
resumption_settings
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Initializing
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
expect
(
"
Set
resumption
token
.
"
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
ZeroRtt
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
ZeroRtt
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Init
)
;
let
out
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
server
.
check_control_qpack_request_streams_resumption
(
expected_encoder_stream_data
EXPECTED_REQUEST_HEADER_FRAME
false
)
;
assert_eq
!
(
*
server
.
conn
.
state
(
)
State
:
:
Handshaking
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert
!
(
server
.
conn
.
state
(
)
.
connected
(
)
)
;
assert
!
(
client
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
assert
!
(
server
.
conn
.
tls_info
(
)
.
unwrap
(
)
.
resumed
(
)
)
;
let
control_stream
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
mut
enc
=
Encoder
:
:
default
(
)
;
server
.
settings
.
encode
(
&
mut
enc
)
;
let
mut
sent
=
server
.
conn
.
stream_send
(
control_stream
CONTROL_STREAM_TYPE
)
;
assert_eq
!
(
sent
.
unwrap
(
)
CONTROL_STREAM_TYPE
.
len
(
)
)
;
sent
=
server
.
conn
.
stream_send
(
control_stream
&
enc
)
;
assert_eq
!
(
sent
.
unwrap
(
)
enc
.
len
(
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
&
client
.
state
(
)
expected_client_state
)
;
assert
!
(
server
.
conn
.
state
(
)
.
connected
(
)
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_are_the_same
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Connected
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_omit_max_table
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
265
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_omit_blocked_streams
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
265
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_omit_header_list_size
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
]
&
Http3State
:
:
Connected
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_max_table_size_bigger
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
200
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
514
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_max_table_size_smaller
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
50
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
265
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_blocked_streams_bigger
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
200
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Connected
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_blocked_streams_smaller
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
50
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
265
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_max_header_size_bigger
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
20000
)
]
&
Http3State
:
:
Connected
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_new_server_setting_max_headers_size_smaller
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
5000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
265
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_max_table_size_first_omitted
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Connected
ENCODER_STREAM_DATA
)
;
}
#
[
test
]
fn
zero_rtt_blocked_streams_first_omitted
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Connected
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
zero_rtt_max_header_size_first_omitted
(
)
{
zero_rtt_change_settings
(
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
10000
)
]
&
[
HSetting
:
:
new
(
HSettingType
:
:
MaxTableCapacity
100
)
HSetting
:
:
new
(
HSettingType
:
:
BlockedStreams
100
)
HSetting
:
:
new
(
HSettingType
:
:
MaxHeaderListSize
10000
)
]
&
Http3State
:
:
Closing
(
ConnectionError
:
:
Application
(
265
)
)
ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION
)
;
}
#
[
test
]
fn
test_trailers_with_fin_after_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_HEADER_FRAME_0
false
)
;
let
mut
response_headers
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_0
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
response_headers
=
true
;
}
}
assert
!
(
response_headers
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_HEADER_FRAME_0
true
)
;
let
events
:
Vec
<
Http3ClientEvent
>
=
client
.
events
(
)
.
collect
(
)
;
let
header_ready
:
fn
(
&
Http3ClientEvent
)
-
>
_
=
|
e
|
matches
!
(
*
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
events
.
iter
(
)
.
any
(
header_ready
)
)
;
let
data_readable
:
fn
(
&
Http3ClientEvent
)
-
>
_
=
|
e
|
matches
!
(
*
e
Http3ClientEvent
:
:
DataReadable
{
.
.
}
)
;
assert
!
(
events
.
iter
(
)
.
any
(
data_readable
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
len
fin
)
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
0
len
)
;
assert_eq
!
(
fin
true
)
}
#
[
test
]
fn
test_trailers_with_later_fin_after_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_HEADER_FRAME_0
false
)
;
let
mut
response_headers
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_0
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
response_headers
=
true
;
}
}
assert
!
(
response_headers
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_HEADER_FRAME_0
false
)
;
let
data_readable
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataReadable
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable
)
)
;
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
events
:
Vec
<
Http3ClientEvent
>
=
client
.
events
(
)
.
collect
(
)
;
let
header_ready
:
fn
(
&
Http3ClientEvent
)
-
>
_
=
|
e
|
matches
!
(
*
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
events
.
iter
(
)
.
any
(
header_ready
)
)
;
let
data_readable_fn
:
fn
(
&
Http3ClientEvent
)
-
>
_
=
|
e
|
matches
!
(
*
e
Http3ClientEvent
:
:
DataReadable
{
.
.
}
)
;
assert
!
(
events
.
iter
(
)
.
any
(
data_readable_fn
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
len
fin
)
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
0
len
)
;
assert_eq
!
(
fin
true
)
;
}
#
[
test
]
fn
test_data_after_trailers_after_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_HEADER_FRAME_0
false
)
;
let
mut
response_headers
=
false
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
headers
interim
fin
}
=
e
{
assert_eq
!
(
stream_id
request_stream_id
)
;
check_response_header_0
(
&
headers
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
interim
false
)
;
response_headers
=
true
;
}
}
assert
!
(
response_headers
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_HEADER_FRAME_0
false
)
;
let
data_readable
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataReadable
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable
)
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
[
0x0
0x3
0x61
0x62
0x63
]
false
)
;
assert_closed
(
&
client
&
Error
:
:
HttpFrameUnexpected
)
;
}
#
[
test
]
fn
transport_stream_readable_event_after_all_data
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
false
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
false
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
[
0x0
0x0
]
true
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Ok
(
(
3
true
)
)
)
;
client
.
process
(
None
now
(
)
)
;
}
#
[
test
]
fn
no_data_ready_events_after_fin
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_1
true
)
;
let
data_readable_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
if
stream_id
=
=
request_stream_id
)
;
assert
!
(
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
(
EXPECTED_RESPONSE_DATA_1
.
len
(
)
true
)
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
.
unwrap
(
)
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
}
#
[
test
]
fn
reading_small_chunks_of_data
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_1
true
)
;
let
data_readable_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
if
stream_id
=
=
request_stream_id
)
;
assert
!
(
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
let
mut
buf1
=
[
0_u8
;
1
]
;
assert_eq
!
(
(
1
false
)
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf1
)
.
unwrap
(
)
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
let
mut
buf2
=
[
0_u8
;
2
]
;
assert_eq
!
(
(
2
false
)
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf2
)
.
unwrap
(
)
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
assert_eq
!
(
(
2
false
)
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf2
)
.
unwrap
(
)
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
assert_eq
!
(
(
2
true
)
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf2
)
.
unwrap
(
)
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
data_readable_event
)
)
;
}
#
[
test
]
fn
zero_length_data_at_end
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_1
false
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
&
[
0
0
]
)
.
unwrap
(
)
;
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
dgram
=
server
.
conn
.
process_output
(
now
(
)
)
.
dgram
(
)
;
let
dgram
=
client
.
process
(
dgram
now
(
)
)
.
dgram
(
)
;
server
.
conn
.
process_input
(
dgram
.
unwrap
(
)
now
(
)
)
;
let
data_readable_event
=
|
e
:
&
_
|
matches
!
(
e
Http3ClientEvent
:
:
DataReadable
{
stream_id
}
if
*
stream_id
=
=
request_stream_id
)
;
assert_eq
!
(
client
.
events
(
)
.
filter
(
data_readable_event
)
.
count
(
)
1
)
;
let
mut
buf
=
[
0_u8
;
10
]
;
assert_eq
!
(
(
7
true
)
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
.
unwrap
(
)
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
|
e
|
data_readable_event
(
&
e
)
)
)
;
}
#
[
test
]
fn
stream_blocked_no_remote_encoder_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect_only_transport
(
)
;
send_and_receive_client_settings
(
&
mut
client
&
mut
server
)
;
server
.
create_control_stream
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
server
.
create_qpack_streams
(
)
;
let
qpack_pkt1
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
request_stream_id
=
make_request
(
&
mut
client
true
&
[
]
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
let
d_frame
=
HFrame
:
:
Data
{
len
:
3
}
;
d_frame
.
encode
(
&
mut
d
)
;
d
.
encode
(
&
[
0x61
0x62
0x63
]
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
&
d
[
.
.
]
)
;
server
.
conn
.
stream_close_send
(
request_stream_id
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_
=
client
.
process
(
qpack_pkt1
.
dgram
(
)
now
(
)
)
;
assert
!
(
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
}
#
[
test
]
fn
push_single
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
let
_
=
send_push_data
(
&
mut
server
.
conn
0
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
0
ref_stream_id
:
request_stream_id
}
]
&
[
0
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
push_multiple
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
1
)
;
let
_
=
send_push_data
(
&
mut
server
.
conn
0
true
)
;
let
_
=
send_push_data
(
&
mut
server
.
conn
1
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
0
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
1
ref_stream_id
:
request_stream_id
}
]
&
[
0
1
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_eq
!
(
client
.
cancel_push
(
1
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
push_after_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_2
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
let
_
=
send_push_data
(
&
mut
server
.
conn
0
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_DATA_FRAME_ONLY_2
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
0
ref_stream_id
:
request_stream_id
}
]
&
[
0
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
push_after_response
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
_
=
server
.
conn
.
stream_send
(
request_stream_id
HTTP_RESPONSE_2
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
0
ref_stream_id
:
request_stream_id
}
]
&
[
0
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
fn
check_push_events
(
client
:
&
mut
Http3Client
)
-
>
bool
{
let
any_push_event
=
|
e
|
{
matches
!
(
e
Http3ClientEvent
:
:
PushPromise
{
.
.
}
|
Http3ClientEvent
:
:
PushHeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
PushDataReadable
{
.
.
}
)
}
;
client
.
events
(
)
.
any
(
any_push_event
)
}
fn
check_data_readable
(
client
:
&
mut
Http3Client
)
-
>
bool
{
let
any_data_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
DataReadable
{
.
.
}
)
;
client
.
events
(
)
.
any
(
any_data_event
)
}
fn
check_header_ready
(
client
:
&
mut
Http3Client
)
-
>
bool
{
let
any_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
client
.
events
(
)
.
any
(
any_event
)
}
fn
check_header_ready_and_push_promise
(
client
:
&
mut
Http3Client
)
-
>
bool
{
let
any_event
=
|
e
|
{
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
|
Http3ClientEvent
:
:
PushPromise
{
.
.
}
)
}
;
client
.
events
(
)
.
any
(
any_event
)
}
#
[
test
]
fn
push_stream_before_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
true
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
0
ref_stream_id
:
request_stream_id
}
]
&
[
0
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
push_out_of_order_1
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
5
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
3
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
3
true
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
3
ref_stream_id
:
request_stream_id
}
]
&
[
3
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
push_out_of_order_2
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
5
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
3
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
3
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
3
ref_stream_id
:
request_stream_id
}
]
&
[
3
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
push_out_of_order_3
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
5
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
5
true
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id
}
]
&
[
5
]
request_stream_id
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
3
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
3
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
3
ref_stream_id
:
request_stream_id
}
]
&
[
3
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
multiple_push_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
5
)
;
let
request_stream_id_2
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_2
4
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id_2
5
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id_2
}
]
&
[
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
multiple_push_promise_active
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
5
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
5
true
)
;
let
request_stream_id_2
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_2
4
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id_2
5
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id_2
}
]
&
[
5
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
multiple_push_promise_closed
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
5
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
5
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
5
ref_stream_id
:
request_stream_id
}
]
&
[
5
]
request_stream_id
)
;
let
request_stream_id_2
=
make_request
(
&
mut
client
false
&
[
]
)
;
assert_eq
!
(
request_stream_id_2
4
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id_2
5
)
;
let
push_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
PushPromise
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
push_event
)
)
;
}
#
[
test
]
fn
exceed_max_push_id_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
6
)
;
assert_closed
(
&
client
&
Error
:
:
HttpId
)
;
}
#
[
test
]
fn
exceed_max_push_id_push_stream
(
)
{
let
(
mut
client
mut
server
)
=
connect
(
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
6
true
)
;
assert_closed
(
&
client
&
Error
:
:
HttpId
)
;
}
#
[
test
]
fn
exceed_max_push_id_cancel_push
(
)
{
let
(
mut
client
mut
server
_request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_cancel_push_and_exchange_packets
(
&
mut
client
&
mut
server
6
)
;
assert_closed
(
&
client
&
Error
:
:
HttpId
)
;
}
#
[
test
]
fn
exceed_max_push_id_cancel_api
(
)
{
let
(
mut
client
_
_
)
=
connect_and_send_request
(
true
)
;
assert_eq
!
(
client
.
cancel_push
(
6
)
Err
(
Error
:
:
HttpId
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
test_max_push_id_frame_update_is_sent
(
)
{
const
MAX_PUSH_ID_FRAME
:
&
[
u8
]
=
&
[
0xd
0x1
0x8
]
;
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
1
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
2
)
;
send_push_data
(
&
mut
server
.
conn
0
true
)
;
send_push_data
(
&
mut
server
.
conn
1
true
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
2
true
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
0
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
1
ref_stream_id
:
request_stream_id
}
PushPromiseInfo
{
push_id
:
2
ref_stream_id
:
request_stream_id
}
]
&
[
0
1
2
]
request_stream_id
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
control_stream_readable
=
|
e
|
matches
!
(
e
ConnectionEvent
:
:
RecvStreamReadable
{
stream_id
:
x
}
if
x
=
=
2
)
;
assert
!
(
server
.
conn
.
events
(
)
.
any
(
control_stream_readable
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
server
.
conn
.
stream_recv
(
2
&
mut
buf
)
.
unwrap
(
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
amount
MAX_PUSH_ID_FRAME
.
len
(
)
)
;
assert_eq
!
(
&
buf
[
.
.
3
]
MAX_PUSH_ID_FRAME
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
8
)
;
send_push_data
(
&
mut
server
.
conn
8
true
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
read_response_and_push_events
(
&
mut
client
&
[
PushPromiseInfo
{
push_id
:
8
ref_stream_id
:
request_stream_id
}
]
&
[
8
]
request_stream_id
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
duplicate_push_stream
(
)
{
let
(
mut
client
mut
server
_request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
true
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
true
)
;
assert_closed
(
&
client
&
Error
:
:
HttpId
)
;
}
#
[
test
]
fn
duplicate_push_stream_active
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
true
)
;
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
true
)
;
assert_closed
(
&
client
&
Error
:
:
HttpId
)
;
}
fn
assert_stop_sending_event
(
server
:
&
mut
TestServer
push_stream_id
:
u64
expected_error
:
u64
)
{
assert
!
(
server
.
conn
.
events
(
)
.
any
(
|
e
|
matches
!
(
e
ConnectionEvent
:
:
SendStreamStopSending
{
stream_id
app_error
}
if
stream_id
=
=
push_stream_id
&
&
app_error
=
=
expected_error
)
)
)
;
}
#
[
test
]
fn
cancel_push_ignore_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_cancel_push_and_exchange_packets
(
&
mut
client
&
mut
server
0
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_stop_sending_event
(
&
mut
server
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
cancel_push_removes_push_events
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
send_cancel_push_and_exchange_packets
(
&
mut
client
&
mut
server
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_stop_sending_event
(
&
mut
server
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
cancel_push_frame_after_push_stream
(
)
{
let
(
mut
client
mut
server
_
)
=
connect_and_send_request
(
true
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
send_cancel_push_and_exchange_packets
(
&
mut
client
&
mut
server
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_stop_sending_event
(
&
mut
server
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
cancel_push_stream_after_push_promise_and_push_stream
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
0
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
server
.
conn
.
stream_reset_send
(
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
.
dgram
(
)
;
client
.
process
(
out
now
(
)
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
cancel_push_stream_before_push_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
server
.
conn
.
stream_reset_send
(
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
.
dgram
(
)
;
client
.
process
(
out
now
(
)
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
app_cancel_push_after_push_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
client
.
cancel_push
(
0
)
.
is_ok
(
)
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
app_cancel_push_after_push_promise_and_push_stream
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
assert
!
(
client
.
cancel_push
(
0
)
.
is_ok
(
)
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
_
=
server
.
conn
.
process
(
out
now
(
)
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_stop_sending_event
(
&
mut
server
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
#
[
test
]
fn
app_cancel_push_before_push_promise
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
let
push_stream_id
=
send_push_data_and_exchange_packets
(
&
mut
client
&
mut
server
0
false
)
;
assert
!
(
client
.
cancel_push
(
0
)
.
is_ok
(
)
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
_
=
server
.
conn
.
process
(
out
now
(
)
)
;
send_push_promise_and_exchange_packets
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
assert_eq
!
(
client
.
cancel_push
(
0
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
assert_stop_sending_event
(
&
mut
server
push_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Connected
)
;
}
fn
setup_server_side_encoder
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
)
{
server
.
encoder
.
set_max_capacity
(
100
)
.
unwrap
(
)
;
server
.
encoder
.
set_max_blocked_streams
(
100
)
.
unwrap
(
)
;
server
.
encoder
.
send
(
&
mut
server
.
conn
)
.
unwrap
(
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
}
fn
send_push_promise_using_encoder
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
stream_id
:
u64
push_id
:
u64
)
-
>
Option
<
Datagram
>
{
let
headers
=
vec
!
[
(
String
:
:
from
(
"
:
method
"
)
String
:
:
from
(
"
GET
"
)
)
(
String
:
:
from
(
"
:
scheme
"
)
String
:
:
from
(
"
https
"
)
)
(
String
:
:
from
(
"
:
authority
"
)
String
:
:
from
(
"
something
.
com
"
)
)
(
String
:
:
from
(
"
:
path
"
)
String
:
:
from
(
"
/
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
stream_id
)
.
unwrap
(
)
;
let
push_promise_frame
=
HFrame
:
:
PushPromise
{
push_id
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
encoder_inst_pkt
=
server
.
conn
.
process
(
None
now
(
)
)
.
dgram
(
)
;
assert
!
(
encoder_inst_pkt
.
is_some
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
push_promise_frame
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
client
server
stream_id
&
d
false
)
;
encoder_inst_pkt
}
#
[
test
]
fn
push_promise_header_decoder_block
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
encoder_inst_pkt
=
send_push_promise_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
let
_out
=
client
.
process
(
encoder_inst_pkt
now
(
)
)
;
assert
!
(
check_push_events
(
&
mut
client
)
)
;
}
#
[
test
]
fn
push_promise_blocked_but_stream_is_not_blocked
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_1
false
)
;
let
encoder_inst_pkt
=
send_push_promise_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_DATA_FRAME_1_ONLY_1
false
)
;
assert
!
(
check_data_readable
(
&
mut
client
)
)
;
let
_out
=
client
.
process
(
encoder_inst_pkt
now
(
)
)
;
assert
!
(
check_push_events
(
&
mut
client
)
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_DATA_FRAME_2_ONLY_1
false
)
;
assert
!
(
check_data_readable
(
&
mut
client
)
)
;
}
#
[
test
]
fn
push_promise_does_not_block_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
encoder_inst_pkt
=
send_push_promise_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_HEADER_ONLY_1
false
)
;
assert
!
(
check_header_ready
(
&
mut
client
)
)
;
let
_out
=
client
.
process
(
encoder_inst_pkt
now
(
)
)
;
assert
!
(
check_push_events
(
&
mut
client
)
)
;
}
#
[
test
]
fn
push_promise_block_headers
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
server
.
encoder
.
send_and_insert
(
&
mut
server
.
conn
b
"
content
-
length
"
b
"
1234
"
)
.
unwrap
(
)
;
let
encoder_inst_pkt1
=
server
.
conn
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
_out
=
client
.
process
(
encoder_inst_pkt1
now
(
)
)
;
let
encoder_inst_pkt2
=
send_push_promise_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
assert
!
(
!
check_push_events
(
&
mut
client
)
)
;
let
response_headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
1234
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
response_headers
request_stream_id
)
.
unwrap
(
)
;
let
header_hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
mut
d
=
Encoder
:
:
default
(
)
;
header_hframe
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
false
)
;
assert
!
(
!
check_header_ready
(
&
mut
client
)
)
;
let
_out
=
client
.
process
(
encoder_inst_pkt2
now
(
)
)
;
assert
!
(
check_header_ready_and_push_promise
(
&
mut
client
)
)
;
}
#
[
test
]
fn
blocked_push_promises_canceled
(
)
{
const
STREAM_CANCELED_ID_0
:
&
[
u8
]
=
&
[
0x40
]
;
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
_encoder_inst_pkt
=
send_push_promise_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_1
true
)
;
assert
!
(
check_header_ready
(
&
mut
client
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
let
_
=
client
.
read_response_data
(
now
(
)
request_stream_id
&
mut
buf
)
.
unwrap
(
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
mut
inst
=
[
0_u8
;
100
]
;
let
(
amount
fin
)
=
server
.
conn
.
stream_recv
(
CLIENT_SIDE_DECODER_STREAM_ID
&
mut
inst
)
.
unwrap
(
)
;
assert_eq
!
(
fin
false
)
;
assert_eq
!
(
amount
STREAM_CANCELED_ID_0
.
len
(
)
)
;
assert_eq
!
(
&
inst
[
.
.
amount
]
STREAM_CANCELED_ID_0
)
;
}
#
[
test
]
fn
data_readable_in_decoder_blocked_state
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
0
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
encoder_insts
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
false
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
let
d_frame
=
HFrame
:
:
Data
{
len
:
0
}
;
d_frame
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
true
)
;
let
_
=
client
.
process
(
encoder_insts
.
dgram
(
)
now
(
)
)
;
}
#
[
test
]
fn
qpack_stream_reset
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
_
=
client
.
stream_reset
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
encoder
.
recv_if_encoder_stream
(
&
mut
server
.
conn
CLIENT_SIDE_DECODER_STREAM_ID
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
1
)
;
}
fn
send_headers_using_encoder
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
request_stream_id
:
u64
headers
:
&
[
(
String
String
)
]
data
:
&
[
u8
]
)
-
>
Option
<
Datagram
>
{
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
let
d_frame
=
HFrame
:
:
Data
{
len
:
u64
:
:
try_from
(
data
.
len
(
)
)
.
unwrap
(
)
}
;
d_frame
.
encode
(
&
mut
d
)
;
d
.
encode
(
data
)
;
server_send_response_and_exchange_packet
(
client
server
request_stream_id
&
d
true
)
;
out
.
dgram
(
)
}
#
[
test
]
fn
qpack_stream_reset_recv
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
_
=
server
.
conn
.
stream_reset_send
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
out
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
encoder
.
recv_if_encoder_stream
(
&
mut
server
.
conn
CLIENT_SIDE_DECODER_STREAM_ID
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
1
)
;
}
#
[
test
]
fn
qpack_stream_reset_during_header_qpack_blocked
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
_
=
send_headers_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
&
[
0x61
0x62
0x63
]
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_
=
client
.
stream_reset
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
encoder
.
recv_if_encoder_stream
(
&
mut
server
.
conn
CLIENT_SIDE_DECODER_STREAM_ID
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
1
)
;
}
#
[
test
]
fn
qpack_no_stream_cancelled_after_fin
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
encoder_instruct
=
send_headers_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
&
[
]
)
;
let
_
=
client
.
process
(
encoder_instruct
now
(
)
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_
=
client
.
stream_reset
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
encoder
.
recv_if_encoder_stream
(
&
mut
server
.
conn
CLIENT_SIDE_DECODER_STREAM_ID
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
}
#
[
test
]
fn
qpack_stream_reset_push_promise_header_decoder_block
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
_
=
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
send_push_promise_using_encoder
(
&
mut
client
&
mut
server
request_stream_id
0
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
let
d_frame
=
HFrame
:
:
Data
{
len
:
0
}
;
d_frame
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
true
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_
=
client
.
stream_reset
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
encoder
.
recv_if_encoder_stream
(
&
mut
server
.
conn
CLIENT_SIDE_DECODER_STREAM_ID
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
1
)
;
}
#
[
test
]
fn
qpack_stream_reset_dynamic_table_zero
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
let
_
=
client
.
stream_reset
(
request_stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
let
out
=
client
.
process
(
None
now
(
)
)
;
let
_
=
server
.
conn
.
process
(
out
.
dgram
(
)
now
(
)
)
;
let
_
=
server
.
encoder
.
recv_if_encoder_stream
(
&
mut
server
.
conn
CLIENT_SIDE_DECODER_STREAM_ID
)
;
assert_eq
!
(
server
.
encoder
.
stats
(
)
.
stream_cancelled_recv
0
)
;
}
#
[
test
]
fn
multiple_streams_in_decoder_blocked_state
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
0
"
)
)
]
;
let
encoded_headers
=
server
.
encoder
.
encode_header_block
(
&
mut
server
.
conn
&
headers
request_stream_id
)
.
unwrap
(
)
;
let
hframe
=
HFrame
:
:
Headers
{
header_block
:
encoded_headers
.
to_vec
(
)
}
;
let
encoder_insts
=
server
.
conn
.
process
(
None
now
(
)
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
hframe
.
encode
(
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
true
)
;
let
header_ready_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
HeaderReady
{
.
.
}
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
request2
=
make_request_and_exchange_pkts
(
&
mut
client
&
mut
server
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request2
&
d
true
)
;
assert
!
(
!
client
.
events
(
)
.
any
(
header_ready_event
)
)
;
let
_
=
client
.
process
(
encoder_insts
.
dgram
(
)
now
(
)
)
;
let
mut
count_responses
=
0
;
while
let
Some
(
e
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
.
.
}
=
e
{
assert
!
(
(
stream_id
=
=
request_stream_id
)
|
|
(
stream_id
=
=
request2
)
)
;
count_responses
+
=
1
;
}
}
assert_eq
!
(
count_responses
2
)
;
}
#
[
test
]
fn
reserved_frames
(
)
{
for
f
in
H3_RESERVED_FRAME_TYPES
{
let
mut
enc
=
Encoder
:
:
default
(
)
;
enc
.
encode_varint
(
*
f
)
;
test_wrong_frame_on_control_stream
(
&
enc
)
;
test_wrong_frame_on_push_stream
(
&
enc
)
;
test_wrong_frame_on_request_stream
(
&
enc
)
;
}
}
#
[
test
]
fn
send_reserved_settings
(
)
{
for
s
in
H3_RESERVED_SETTINGS
{
let
(
mut
client
mut
server
)
=
connect_only_transport
(
)
;
let
control_stream
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
_
=
server
.
conn
.
stream_send
(
control_stream
CONTROL_STREAM_TYPE
)
;
let
mut
enc
=
Encoder
:
:
default
(
)
;
enc
.
encode_varint
(
H3_FRAME_TYPE_SETTINGS
)
;
enc
.
encode_varint
(
2_u64
)
;
enc
.
encode_varint
(
*
s
)
;
enc
.
encode_varint
(
1_u64
)
;
let
sent
=
server
.
conn
.
stream_send
(
control_stream
&
enc
)
;
assert_eq
!
(
sent
Ok
(
4
)
)
;
let
out
=
server
.
conn
.
process
(
None
now
(
)
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
&
Error
:
:
HttpSettings
)
;
}
}
#
[
test
]
fn
response_w_1xx
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
let
headers1xx
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
103
"
)
)
]
;
server
.
encode_headers
(
request_stream_id
&
headers1xx
&
mut
d
)
;
let
headers200
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
server
.
encode_headers
(
request_stream_id
&
headers200
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
false
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_DATA_FRAME_ONLY_2
true
)
;
let
mut
events
=
client
.
events
(
)
.
filter_map
(
|
e
|
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
stream_id
interim
headers
.
.
}
=
e
{
Some
(
(
stream_id
interim
headers
)
)
}
else
{
None
}
}
)
;
let
(
stream_id_1xx_rec
interim1xx_rec
headers1xx_rec
)
=
events
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
(
stream_id_1xx_rec
interim1xx_rec
headers1xx_rec
)
(
request_stream_id
true
headers1xx
)
)
;
let
(
stream_id_200_rec
interim200_rec
headers200_rec
)
=
events
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
(
stream_id_200_rec
interim200_rec
headers200_rec
)
(
request_stream_id
false
headers200
)
)
;
assert
!
(
events
.
next
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
response_wo_status
(
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
server
.
encode_headers
(
request_stream_id
&
headers
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
false
)
;
let
e
=
client
.
events
(
)
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
e
Http3ClientEvent
:
:
Reset
{
stream_id
:
request_stream_id
error
:
Error
:
:
InvalidHeader
.
code
(
)
local
:
true
}
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
_
=
server
.
conn
.
process
(
out
now
(
)
)
;
let
stop_sending_event
=
|
e
|
{
matches
!
(
e
ConnectionEvent
:
:
SendStreamStopSending
{
stream_id
app_error
}
if
stream_id
=
=
request_stream_id
&
&
app_error
=
=
Error
:
:
InvalidHeader
.
code
(
)
)
}
;
assert
!
(
server
.
conn
.
events
(
)
.
any
(
stop_sending_event
)
)
;
let
mut
buf
=
[
0_u8
;
100
]
;
assert_eq
!
(
client
.
read_response_data
(
now
(
)
0
&
mut
buf
)
Err
(
Error
:
:
InvalidStreamId
)
)
;
}
#
[
test
]
fn
push_single_with_1xx
(
)
{
const
FIRST_PUSH_ID
:
u64
=
0
;
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
FIRST_PUSH_ID
)
;
let
push_stream_id
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
let
headers1xx
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
101
"
)
)
]
;
server
.
encode_headers
(
push_stream_id
&
headers1xx
&
mut
d
)
;
let
headers200
=
vec
!
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
server
.
encode_headers
(
push_stream_id
&
headers200
&
mut
d
)
;
send_data_on_push
(
&
mut
server
.
conn
push_stream_id
u8
:
:
try_from
(
FIRST_PUSH_ID
)
.
unwrap
(
)
&
d
true
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
let
mut
events
=
client
.
events
(
)
.
filter_map
(
|
e
|
{
if
let
Http3ClientEvent
:
:
PushHeaderReady
{
push_id
interim
headers
.
.
}
=
e
{
Some
(
(
push_id
interim
headers
)
)
}
else
{
None
}
}
)
;
let
(
push_id_1xx_rec
interim1xx_rec
headers1xx_rec
)
=
events
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
(
push_id_1xx_rec
interim1xx_rec
headers1xx_rec
)
(
FIRST_PUSH_ID
true
headers1xx
)
)
;
let
(
push_id_200_rec
interim200_rec
headers200_rec
)
=
events
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
(
push_id_200_rec
interim200_rec
headers200_rec
)
(
FIRST_PUSH_ID
false
headers200
)
)
;
assert
!
(
events
.
next
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
push_single_wo_status
(
)
{
const
FIRST_PUSH_ID
:
u64
=
0
;
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
send_push_promise
(
&
mut
server
.
conn
request_stream_id
FIRST_PUSH_ID
)
;
let
push_stream_id
=
server
.
conn
.
stream_create
(
StreamType
:
:
UniDi
)
.
unwrap
(
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
let
headers
=
vec
!
[
(
String
:
:
from
(
"
my
-
header
"
)
String
:
:
from
(
"
my
-
header
"
)
)
(
String
:
:
from
(
"
content
-
length
"
)
String
:
:
from
(
"
3
"
)
)
]
;
server
.
encode_headers
(
request_stream_id
&
headers
&
mut
d
)
;
send_data_on_push
(
&
mut
server
.
conn
push_stream_id
u8
:
:
try_from
(
FIRST_PUSH_ID
)
.
unwrap
(
)
&
d
false
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
HTTP_RESPONSE_2
true
)
;
let
push_reset_event
=
|
e
|
{
matches
!
(
e
Http3ClientEvent
:
:
PushReset
{
push_id
error
}
if
push_id
=
=
FIRST_PUSH_ID
&
&
error
=
=
Error
:
:
InvalidHeader
.
code
(
)
)
}
;
assert
!
(
client
.
events
(
)
.
any
(
push_reset_event
)
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
_
=
server
.
conn
.
process
(
out
now
(
)
)
;
let
stop_sending_event
=
|
e
|
{
matches
!
(
e
ConnectionEvent
:
:
SendStreamStopSending
{
stream_id
app_error
}
if
stream_id
=
=
push_stream_id
&
&
app_error
=
=
Error
:
:
InvalidHeader
.
code
(
)
)
}
;
assert
!
(
server
.
conn
.
events
(
)
.
any
(
stop_sending_event
)
)
;
}
fn
handshake_client_error
(
client
:
&
mut
Http3Client
server
:
&
mut
TestServer
error
:
&
Error
)
{
let
out
=
handshake_only
(
client
server
)
;
client
.
process
(
out
.
dgram
(
)
now
(
)
)
;
assert_closed
(
&
client
error
)
;
}
#
[
test
]
fn
client_control_stream_create_failed
(
)
{
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
TestServer
:
:
new
(
)
;
server
.
set_max_uni_stream
(
0
)
;
handshake_client_error
(
&
mut
client
&
mut
server
&
Error
:
:
StreamLimitError
)
;
}
#
[
test
]
fn
client_qpack_stream_create_failed
(
)
{
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
TestServer
:
:
new
(
)
;
server
.
set_max_uni_stream
(
2
)
;
handshake_client_error
(
&
mut
client
&
mut
server
&
Error
:
:
StreamLimitError
)
;
}
fn
do_malformed_response_test
(
headers
:
&
[
Header
]
)
{
let
(
mut
client
mut
server
request_stream_id
)
=
connect_and_send_request
(
true
)
;
setup_server_side_encoder
(
&
mut
client
&
mut
server
)
;
let
mut
d
=
Encoder
:
:
default
(
)
;
server
.
encode_headers
(
request_stream_id
&
headers
&
mut
d
)
;
server_send_response_and_exchange_packet
(
&
mut
client
&
mut
server
request_stream_id
&
d
false
)
;
let
e
=
client
.
events
(
)
.
next
(
)
.
unwrap
(
)
;
assert_eq
!
(
e
Http3ClientEvent
:
:
Reset
{
stream_id
:
request_stream_id
error
:
Error
:
:
InvalidHeader
.
code
(
)
local
:
true
}
)
;
}
#
[
test
]
fn
malformed_response_pseudo_header_after_regular_header
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
content
-
type
"
)
String
:
:
from
(
"
text
/
plain
"
)
)
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
100
"
)
)
]
)
;
}
#
[
test
]
fn
malformed_response_undefined_pseudo_header
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
:
cheese
"
)
String
:
:
from
(
"
200
"
)
)
]
)
;
}
#
[
test
]
fn
malformed_response_duplicate_pseudo_header
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
100
"
)
)
(
String
:
:
from
(
"
content
-
type
"
)
String
:
:
from
(
"
text
/
plain
"
)
)
]
)
;
}
#
[
test
]
fn
malformed_response_uppercase_header
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
Type
"
)
String
:
:
from
(
"
text
/
plain
"
)
)
]
)
;
}
#
[
test
]
fn
malformed_response_excluded_header
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
-
type
"
)
String
:
:
from
(
"
text
/
plain
"
)
)
(
String
:
:
from
(
"
connection
"
)
String
:
:
from
(
"
close
"
)
)
]
)
;
}
#
[
test
]
fn
malformed_response_excluded_byte_in_header
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
content
:
type
"
)
String
:
:
from
(
"
text
/
plain
"
)
)
]
)
;
}
#
[
test
]
fn
malformed_response_request_header_in_response
(
)
{
do_malformed_response_test
(
&
[
(
String
:
:
from
(
"
:
status
"
)
String
:
:
from
(
"
200
"
)
)
(
String
:
:
from
(
"
:
method
"
)
String
:
:
from
(
"
GET
"
)
)
(
String
:
:
from
(
"
content
-
type
"
)
String
:
:
from
(
"
text
/
plain
"
)
)
]
)
;
}
fn
maybe_authenticate
(
conn
:
&
mut
Http3Client
)
{
let
authentication_needed
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
AuthenticationNeeded
)
;
if
conn
.
events
(
)
.
any
(
authentication_needed
)
{
conn
.
authenticated
(
AuthenticationStatus
:
:
Ok
now
(
)
)
;
}
}
const
MAX_TABLE_SIZE
:
u64
=
65536
;
const
MAX_BLOCKED_STREAMS
:
u16
=
5
;
fn
get_resumption_token
(
server
:
&
mut
Http3Server
)
-
>
ResumptionToken
{
let
mut
client
=
default_http3_client_param
(
MAX_TABLE_SIZE
)
;
let
mut
datagram
=
None
;
let
is_done
=
|
c
:
&
Http3Client
|
matches
!
(
c
.
state
(
)
Http3State
:
:
Connected
)
;
while
!
is_done
(
&
mut
client
)
{
maybe_authenticate
(
&
mut
client
)
;
datagram
=
client
.
process
(
datagram
now
(
)
)
.
dgram
(
)
;
datagram
=
server
.
process
(
datagram
now
(
)
)
.
dgram
(
)
;
}
datagram
=
client
.
process
(
datagram
now
(
)
)
.
dgram
(
)
;
datagram
=
server
.
process
(
datagram
now
(
)
)
.
dgram
(
)
;
let
_
=
client
.
process
(
datagram
now
(
)
)
.
dgram
(
)
;
client
.
events
(
)
.
find_map
(
|
e
|
{
if
let
Http3ClientEvent
:
:
ResumptionToken
(
token
)
=
e
{
Some
(
token
)
}
else
{
None
}
}
)
.
unwrap
(
)
}
#
[
test
]
fn
zerortt_request_use_dynamic_table
(
)
{
let
mut
server
=
Http3Server
:
:
new
(
now
(
)
DEFAULT_KEYS
DEFAULT_ALPN_H3
anti_replay
(
)
Rc
:
:
new
(
RefCell
:
:
new
(
CountingConnectionIdGenerator
:
:
default
(
)
)
)
QpackSettings
{
max_table_size_encoder
:
MAX_TABLE_SIZE
max_table_size_decoder
:
MAX_TABLE_SIZE
max_blocked_streams
:
MAX_BLOCKED_STREAMS
}
None
)
.
unwrap
(
)
;
let
token
=
get_resumption_token
(
&
mut
server
)
;
let
mut
client
=
default_http3_client_param
(
MAX_TABLE_SIZE
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
Initializing
)
;
client
.
enable_resumption
(
now
(
)
&
token
)
.
expect
(
"
Set
resumption
token
.
"
)
;
assert_eq
!
(
client
.
state
(
)
Http3State
:
:
ZeroRtt
)
;
let
zerortt_event
=
|
e
|
matches
!
(
e
Http3ClientEvent
:
:
StateChange
(
Http3State
:
:
ZeroRtt
)
)
;
assert
!
(
client
.
events
(
)
.
any
(
zerortt_event
)
)
;
let
_
=
make_request
(
&
mut
client
true
&
[
(
String
:
:
from
(
"
myheaders
"
)
String
:
:
from
(
"
myvalue
"
)
)
]
)
;
assert_eq
!
(
client
.
qpack_encoder_stats
(
)
.
dynamic_table_references
1
)
;
let
out
=
client
.
process
(
None
now
(
)
)
.
dgram
(
)
;
let
out
=
server
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
out
=
client
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
out
=
server
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
out
=
client
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
out
=
server
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
out
=
client
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
out
=
server
.
process
(
out
now
(
)
)
.
dgram
(
)
;
let
_
=
client
.
process
(
out
now
(
)
)
;
assert_eq
!
(
client
.
qpack_encoder_stats
(
)
.
header_acks_recv
1
)
;
}
}
