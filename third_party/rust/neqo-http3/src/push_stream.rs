use
crate
:
:
client_events
:
:
Http3ClientEvents
;
use
crate
:
:
push_controller
:
:
{
PushController
RecvPushEvents
}
;
use
crate
:
:
recv_message
:
:
RecvMessage
;
use
crate
:
:
stream_type_reader
:
:
NewStreamTypeReader
;
use
crate
:
:
{
Error
RecvStream
Res
}
;
use
neqo_qpack
:
:
decoder
:
:
QPackDecoder
;
use
neqo_transport
:
:
{
AppError
Connection
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
rc
:
:
Rc
;
#
[
derive
(
Debug
)
]
enum
PushStreamState
{
ReadPushId
(
NewStreamTypeReader
)
ReadResponse
{
push_id
:
u64
response
:
RecvMessage
}
Closed
}
impl
PushStreamState
{
pub
fn
push_id
(
&
self
)
-
>
Option
<
u64
>
{
match
self
{
Self
:
:
ReadResponse
{
push_id
.
.
}
=
>
Some
(
*
push_id
)
_
=
>
None
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
PushStream
{
state
:
PushStreamState
stream_id
:
u64
push_handler
:
Rc
<
RefCell
<
PushController
>
>
events
:
Http3ClientEvents
}
impl
PushStream
{
pub
fn
new
(
stream_id
:
u64
push_handler
:
Rc
<
RefCell
<
PushController
>
>
events
:
Http3ClientEvents
)
-
>
Self
{
Self
{
state
:
PushStreamState
:
:
ReadPushId
(
NewStreamTypeReader
:
:
new
(
)
)
stream_id
push_handler
events
}
}
}
impl
Display
for
PushStream
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Push
stream
{
:
?
}
"
self
.
stream_id
)
}
}
impl
RecvStream
for
PushStream
{
fn
receive
(
&
mut
self
conn
:
&
mut
Connection
decoder
:
&
mut
QPackDecoder
)
-
>
Res
<
(
)
>
{
loop
{
match
&
mut
self
.
state
{
PushStreamState
:
:
ReadPushId
(
id_reader
)
=
>
{
let
push_id
=
id_reader
.
get_type
(
conn
self
.
stream_id
)
;
let
fin
=
id_reader
.
fin
(
)
;
if
fin
{
self
.
state
=
PushStreamState
:
:
Closed
;
return
Ok
(
(
)
)
;
}
if
let
Some
(
p
)
=
push_id
{
if
self
.
push_handler
.
borrow_mut
(
)
.
add_new_push_stream
(
p
self
.
stream_id
)
?
{
self
.
state
=
PushStreamState
:
:
ReadResponse
{
push_id
:
p
response
:
RecvMessage
:
:
new
(
self
.
stream_id
Box
:
:
new
(
RecvPushEvents
:
:
new
(
p
self
.
push_handler
.
clone
(
)
)
)
None
)
}
;
}
else
{
let
_
=
conn
.
stream_stop_sending
(
self
.
stream_id
Error
:
:
HttpRequestCancelled
.
code
(
)
)
;
self
.
state
=
PushStreamState
:
:
Closed
;
return
Ok
(
(
)
)
;
}
}
}
PushStreamState
:
:
ReadResponse
{
response
push_id
}
=
>
{
response
.
receive
(
conn
decoder
)
?
;
if
response
.
done
(
)
{
self
.
push_handler
.
borrow_mut
(
)
.
close
(
*
push_id
)
;
self
.
state
=
PushStreamState
:
:
Closed
;
}
return
Ok
(
(
)
)
;
}
_
=
>
return
Ok
(
(
)
)
}
}
}
fn
header_unblocked
(
&
mut
self
conn
:
&
mut
Connection
decoder
:
&
mut
QPackDecoder
)
-
>
Res
<
(
)
>
{
self
.
receive
(
conn
decoder
)
}
fn
done
(
&
self
)
-
>
bool
{
matches
!
(
self
.
state
PushStreamState
:
:
Closed
)
}
fn
stream_reset
(
&
self
_app_error
:
AppError
)
{
if
let
Some
(
push_id
)
=
self
.
state
.
push_id
(
)
{
self
.
push_handler
.
borrow_mut
(
)
.
push_stream_reset
(
push_id
)
;
}
}
fn
read_data
(
&
mut
self
conn
:
&
mut
Connection
decoder
:
&
mut
QPackDecoder
buf
:
&
mut
[
u8
]
)
-
>
Res
<
(
usize
bool
)
>
{
if
let
PushStreamState
:
:
ReadResponse
{
response
push_id
}
=
&
mut
self
.
state
{
let
res
=
response
.
read_data
(
conn
decoder
buf
)
;
if
response
.
done
(
)
{
self
.
push_handler
.
borrow_mut
(
)
.
close
(
*
push_id
)
;
}
res
}
else
{
Err
(
Error
:
:
InvalidStreamId
)
}
}
}
