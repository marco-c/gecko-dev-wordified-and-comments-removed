use
std
:
:
{
cell
:
:
RefCell
collections
:
:
VecDeque
rc
:
:
Rc
}
;
use
neqo_common
:
:
{
event
:
:
Provider
as
EventProvider
qtrace
Bytes
Header
}
;
use
neqo_crypto
:
:
ResumptionToken
;
use
neqo_transport
:
:
{
AppError
StreamId
StreamType
}
;
use
crate
:
:
{
connection
:
:
Http3State
features
:
:
extended_connect
:
:
{
self
ExtendedConnectEvents
ExtendedConnectType
}
settings
:
:
HSettingType
CloseType
Error
Http3StreamInfo
HttpRecvStreamEvents
PushId
RecvStreamEvents
Res
SendStreamEvents
}
;
#
[
derive
(
Debug
PartialEq
Eq
Clone
)
]
pub
enum
WebTransportEvent
{
Negotiated
(
bool
)
NewSession
{
stream_id
:
StreamId
status
:
u16
headers
:
Vec
<
Header
>
}
SessionClosed
{
stream_id
:
StreamId
reason
:
extended_connect
:
:
session
:
:
CloseReason
headers
:
Option
<
Vec
<
Header
>
>
}
NewStream
{
stream_id
:
StreamId
session_id
:
StreamId
}
Datagram
{
session_id
:
StreamId
datagram
:
Bytes
}
}
#
[
derive
(
Debug
PartialEq
Eq
Clone
)
]
pub
enum
ConnectUdpEvent
{
Negotiated
(
bool
)
NewSession
{
stream_id
:
StreamId
status
:
u16
headers
:
Vec
<
Header
>
}
SessionClosed
{
stream_id
:
StreamId
reason
:
extended_connect
:
:
session
:
:
CloseReason
headers
:
Option
<
Vec
<
Header
>
>
}
Datagram
{
session_id
:
StreamId
datagram
:
Bytes
}
}
#
[
derive
(
Debug
PartialEq
Eq
Clone
)
]
pub
enum
Http3ClientEvent
{
HeaderReady
{
stream_id
:
StreamId
headers
:
Vec
<
Header
>
interim
:
bool
fin
:
bool
}
DataWritable
{
stream_id
:
StreamId
}
DataReadable
{
stream_id
:
StreamId
}
Reset
{
stream_id
:
StreamId
error
:
AppError
local
:
bool
}
StopSending
{
stream_id
:
StreamId
error
:
AppError
}
PushPromise
{
push_id
:
PushId
request_stream_id
:
StreamId
headers
:
Vec
<
Header
>
}
PushHeaderReady
{
push_id
:
PushId
headers
:
Vec
<
Header
>
interim
:
bool
fin
:
bool
}
PushDataReadable
{
push_id
:
PushId
}
PushCanceled
{
push_id
:
PushId
}
PushReset
{
push_id
:
PushId
error
:
AppError
}
RequestsCreatable
AuthenticationNeeded
EchFallbackAuthenticationNeeded
{
public_name
:
String
}
ResumptionToken
(
ResumptionToken
)
ZeroRttRejected
GoawayReceived
StateChange
(
Http3State
)
WebTransport
(
WebTransportEvent
)
ConnectUdp
(
ConnectUdpEvent
)
}
#
[
derive
(
Debug
Default
Clone
)
]
pub
struct
Http3ClientEvents
{
events
:
Rc
<
RefCell
<
VecDeque
<
Http3ClientEvent
>
>
>
}
impl
RecvStreamEvents
for
Http3ClientEvents
{
fn
data_readable
(
&
self
stream_info
:
&
Http3StreamInfo
)
{
self
.
insert
(
Http3ClientEvent
:
:
DataReadable
{
stream_id
:
stream_info
.
stream_id
(
)
}
)
;
}
fn
recv_closed
(
&
self
stream_info
:
&
Http3StreamInfo
close_type
:
CloseType
)
{
let
stream_id
=
stream_info
.
stream_id
(
)
;
let
(
local
error
)
=
match
close_type
{
CloseType
:
:
ResetApp
(
_
)
=
>
{
self
.
remove_recv_stream_events
(
stream_id
)
;
return
;
}
CloseType
:
:
Done
=
>
return
CloseType
:
:
ResetRemote
(
e
)
=
>
{
self
.
remove_recv_stream_events
(
stream_id
)
;
(
false
e
)
}
CloseType
:
:
LocalError
(
e
)
=
>
{
self
.
remove_recv_stream_events
(
stream_id
)
;
(
true
e
)
}
}
;
self
.
insert
(
Http3ClientEvent
:
:
Reset
{
stream_id
error
local
}
)
;
}
}
impl
HttpRecvStreamEvents
for
Http3ClientEvents
{
fn
header_ready
(
&
self
stream_info
:
&
Http3StreamInfo
headers
:
Vec
<
Header
>
interim
:
bool
fin
:
bool
)
{
self
.
insert
(
Http3ClientEvent
:
:
HeaderReady
{
stream_id
:
stream_info
.
stream_id
(
)
headers
interim
fin
}
)
;
}
}
impl
SendStreamEvents
for
Http3ClientEvents
{
fn
data_writable
(
&
self
stream_info
:
&
Http3StreamInfo
)
{
self
.
insert
(
Http3ClientEvent
:
:
DataWritable
{
stream_id
:
stream_info
.
stream_id
(
)
}
)
;
}
fn
send_closed
(
&
self
stream_info
:
&
Http3StreamInfo
close_type
:
CloseType
)
{
let
stream_id
=
stream_info
.
stream_id
(
)
;
self
.
remove_send_stream_events
(
stream_id
)
;
if
let
CloseType
:
:
ResetRemote
(
error
)
=
close_type
{
self
.
insert
(
Http3ClientEvent
:
:
StopSending
{
stream_id
error
}
)
;
}
}
}
impl
ExtendedConnectEvents
for
Http3ClientEvents
{
fn
session_start
(
&
self
connect_type
:
ExtendedConnectType
stream_id
:
StreamId
status
:
u16
headers
:
Vec
<
Header
>
)
{
match
connect_type
{
ExtendedConnectType
:
:
WebTransport
=
>
{
self
.
insert
(
Http3ClientEvent
:
:
WebTransport
(
WebTransportEvent
:
:
NewSession
{
stream_id
status
headers
}
)
)
;
}
ExtendedConnectType
:
:
ConnectUdp
=
>
{
self
.
insert
(
Http3ClientEvent
:
:
ConnectUdp
(
ConnectUdpEvent
:
:
NewSession
{
stream_id
status
headers
}
)
)
;
}
}
}
fn
session_end
(
&
self
connect_type
:
ExtendedConnectType
stream_id
:
StreamId
reason
:
extended_connect
:
:
session
:
:
CloseReason
headers
:
Option
<
Vec
<
Header
>
>
)
{
let
event
=
match
connect_type
{
ExtendedConnectType
:
:
WebTransport
=
>
{
Http3ClientEvent
:
:
WebTransport
(
WebTransportEvent
:
:
SessionClosed
{
stream_id
reason
headers
}
)
}
ExtendedConnectType
:
:
ConnectUdp
=
>
{
Http3ClientEvent
:
:
ConnectUdp
(
ConnectUdpEvent
:
:
SessionClosed
{
stream_id
reason
headers
}
)
}
}
;
self
.
insert
(
event
)
;
}
fn
extended_connect_new_stream
(
&
self
stream_info
:
Http3StreamInfo
emit_readable
:
bool
)
-
>
Res
<
(
)
>
{
self
.
insert
(
Http3ClientEvent
:
:
WebTransport
(
WebTransportEvent
:
:
NewStream
{
stream_id
:
stream_info
.
stream_id
(
)
session_id
:
stream_info
.
session_id
(
)
.
ok_or
(
Error
:
:
Internal
)
?
}
)
)
;
if
emit_readable
{
self
.
insert
(
Http3ClientEvent
:
:
DataReadable
{
stream_id
:
stream_info
.
stream_id
(
)
}
)
;
}
Ok
(
(
)
)
}
fn
new_datagram
(
&
self
session_id
:
StreamId
datagram
:
Bytes
connect_type
:
ExtendedConnectType
)
{
let
event
=
match
connect_type
{
ExtendedConnectType
:
:
WebTransport
=
>
{
Http3ClientEvent
:
:
WebTransport
(
WebTransportEvent
:
:
Datagram
{
session_id
datagram
}
)
}
ExtendedConnectType
:
:
ConnectUdp
=
>
{
Http3ClientEvent
:
:
ConnectUdp
(
ConnectUdpEvent
:
:
Datagram
{
session_id
datagram
}
)
}
}
;
self
.
insert
(
event
)
;
}
}
impl
Http3ClientEvents
{
pub
fn
push_promise
(
&
self
push_id
:
PushId
request_stream_id
:
StreamId
headers
:
Vec
<
Header
>
)
{
self
.
insert
(
Http3ClientEvent
:
:
PushPromise
{
push_id
request_stream_id
headers
}
)
;
}
pub
fn
push_canceled
(
&
self
push_id
:
PushId
)
{
self
.
remove_events_for_push_id
(
push_id
)
;
self
.
insert
(
Http3ClientEvent
:
:
PushCanceled
{
push_id
}
)
;
}
pub
fn
push_reset
(
&
self
push_id
:
PushId
error
:
AppError
)
{
self
.
remove_events_for_push_id
(
push_id
)
;
self
.
insert
(
Http3ClientEvent
:
:
PushReset
{
push_id
error
}
)
;
}
pub
(
crate
)
fn
new_requests_creatable
(
&
self
stream_type
:
StreamType
)
{
if
stream_type
=
=
StreamType
:
:
BiDi
{
self
.
insert
(
Http3ClientEvent
:
:
RequestsCreatable
)
;
}
}
pub
(
crate
)
fn
authentication_needed
(
&
self
)
{
self
.
insert
(
Http3ClientEvent
:
:
AuthenticationNeeded
)
;
}
pub
(
crate
)
fn
ech_fallback_authentication_needed
(
&
self
public_name
:
String
)
{
self
.
insert
(
Http3ClientEvent
:
:
EchFallbackAuthenticationNeeded
{
public_name
}
)
;
}
pub
(
crate
)
fn
resumption_token
(
&
self
token
:
ResumptionToken
)
{
self
.
insert
(
Http3ClientEvent
:
:
ResumptionToken
(
token
)
)
;
}
pub
(
crate
)
fn
zero_rtt_rejected
(
&
self
)
{
self
.
insert
(
Http3ClientEvent
:
:
ZeroRttRejected
)
;
}
pub
(
crate
)
fn
goaway_received
(
&
self
)
{
self
.
remove
(
|
evt
|
matches
!
(
evt
Http3ClientEvent
:
:
RequestsCreatable
)
)
;
self
.
insert
(
Http3ClientEvent
:
:
GoawayReceived
)
;
}
pub
fn
insert
(
&
self
event
:
Http3ClientEvent
)
{
self
.
events
.
borrow_mut
(
)
.
push_back
(
event
)
;
}
fn
remove
<
F
>
(
&
self
f
:
F
)
where
F
:
Fn
(
&
Http3ClientEvent
)
-
>
bool
{
self
.
events
.
borrow_mut
(
)
.
retain
(
|
evt
|
!
f
(
evt
)
)
;
}
pub
(
crate
)
fn
connection_state_change
(
&
self
state
:
Http3State
)
{
match
state
{
Http3State
:
:
Closing
{
.
.
}
|
Http3State
:
:
Closed
(
_
)
=
>
self
.
events
.
borrow_mut
(
)
.
clear
(
)
Http3State
:
:
Connected
=
>
{
self
.
remove
(
|
evt
|
{
matches
!
(
evt
Http3ClientEvent
:
:
StateChange
(
Http3State
:
:
ZeroRtt
)
)
}
)
;
}
_
=
>
(
)
}
self
.
insert
(
Http3ClientEvent
:
:
StateChange
(
state
)
)
;
}
fn
remove_recv_stream_events
(
&
self
stream_id
:
StreamId
)
{
self
.
remove
(
|
evt
|
{
matches
!
(
evt
Http3ClientEvent
:
:
HeaderReady
{
stream_id
:
x
.
.
}
|
Http3ClientEvent
:
:
DataReadable
{
stream_id
:
x
}
|
Http3ClientEvent
:
:
PushPromise
{
request_stream_id
:
x
.
.
}
|
Http3ClientEvent
:
:
Reset
{
stream_id
:
x
.
.
}
if
*
x
=
=
stream_id
)
}
)
;
}
fn
remove_send_stream_events
(
&
self
stream_id
:
StreamId
)
{
self
.
remove
(
|
evt
|
{
matches
!
(
evt
Http3ClientEvent
:
:
DataWritable
{
stream_id
:
x
}
|
Http3ClientEvent
:
:
StopSending
{
stream_id
:
x
.
.
}
if
*
x
=
=
stream_id
)
}
)
;
}
pub
fn
has_push
(
&
self
push_id
:
PushId
)
-
>
bool
{
for
iter
in
&
*
self
.
events
.
borrow
(
)
{
if
matches
!
(
iter
Http3ClientEvent
:
:
PushPromise
{
push_id
:
x
.
.
}
if
*
x
=
=
push_id
)
{
return
true
;
}
}
false
}
pub
fn
remove_events_for_push_id
(
&
self
push_id
:
PushId
)
{
self
.
remove
(
|
evt
|
{
matches
!
(
evt
Http3ClientEvent
:
:
PushPromise
{
push_id
:
x
.
.
}
|
Http3ClientEvent
:
:
PushHeaderReady
{
push_id
:
x
.
.
}
|
Http3ClientEvent
:
:
PushDataReadable
{
push_id
:
x
.
.
}
|
Http3ClientEvent
:
:
PushCanceled
{
push_id
:
x
.
.
}
if
*
x
=
=
push_id
)
}
)
;
}
pub
fn
negotiation_done
(
&
self
feature_type
:
HSettingType
succeeded
:
bool
)
{
match
feature_type
{
HSettingType
:
:
EnableWebTransport
=
>
{
self
.
insert
(
Http3ClientEvent
:
:
WebTransport
(
WebTransportEvent
:
:
Negotiated
(
succeeded
)
)
)
;
}
HSettingType
:
:
EnableConnect
=
>
{
self
.
insert
(
Http3ClientEvent
:
:
ConnectUdp
(
ConnectUdpEvent
:
:
Negotiated
(
succeeded
)
)
)
;
}
_
=
>
qtrace
!
(
"
HSetting
{
:
?
}
{
succeeded
}
not
handled
"
feature_type
)
}
}
}
impl
EventProvider
for
Http3ClientEvents
{
type
Event
=
Http3ClientEvent
;
fn
has_events
(
&
self
)
-
>
bool
{
!
self
.
events
.
borrow
(
)
.
is_empty
(
)
}
fn
next_event
(
&
mut
self
)
-
>
Option
<
Self
:
:
Event
>
{
self
.
events
.
borrow_mut
(
)
.
pop_front
(
)
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
tests
{
use
neqo_common
:
:
event
:
:
Provider
as
_
;
use
super
:
:
{
Http3ClientEvent
Http3ClientEvents
}
;
#
[
test
]
fn
has_events
(
)
{
let
events
=
Http3ClientEvents
:
:
default
(
)
;
assert
!
(
!
events
.
has_events
(
)
)
;
events
.
insert
(
Http3ClientEvent
:
:
GoawayReceived
)
;
assert
!
(
events
.
has_events
(
)
)
;
}
}
