#
!
[
expect
(
clippy
:
:
unwrap_used
reason
=
"
OK
in
test
code
.
"
)
]
use
neqo_common
:
:
{
event
:
:
Provider
as
_
header
:
:
HeadersExt
as
_
}
;
use
neqo_http3
:
:
{
Header
Http3ClientEvent
Http3ServerEvent
Priority
}
;
use
test_fixture
:
:
{
default_http3_client
default_http3_server
exchange_packets
now
}
;
fn
echo_header
(
request_header_name
:
&
str
response_header_name
:
&
str
test_data
:
&
[
u8
]
)
{
let
mut
client
=
default_http3_client
(
)
;
let
mut
server
=
default_http3_server
(
)
;
let
out
=
test_fixture
:
:
connect_peers
(
&
mut
client
&
mut
server
)
;
assert_eq
!
(
server
.
process
(
out
now
(
)
)
.
dgram
(
)
None
)
;
drop
(
server
.
events
(
)
)
;
let
custom_header
=
Header
:
:
new
(
request_header_name
test_data
)
;
let
stream_id
=
client
.
fetch
(
now
(
)
"
GET
"
(
"
https
"
"
something
.
com
"
"
/
"
)
&
[
custom_header
]
Priority
:
:
default
(
)
)
.
unwrap
(
)
;
client
.
stream_close_send
(
stream_id
now
(
)
)
.
unwrap
(
)
;
exchange_packets
(
&
mut
client
&
mut
server
false
None
)
;
let
mut
received_stream
=
None
;
let
mut
received_headers
=
None
;
while
let
Some
(
event
)
=
server
.
next_event
(
)
{
if
let
Http3ServerEvent
:
:
Headers
{
stream
headers
.
.
}
=
event
{
received_stream
=
Some
(
stream
)
;
received_headers
=
Some
(
headers
)
;
break
;
}
}
let
stream
=
received_stream
.
expect
(
"
No
Headers
event
received
from
server
"
)
;
let
headers
=
received_headers
.
expect
(
"
No
headers
received
"
)
;
let
received_header
=
headers
.
find_header
(
request_header_name
)
.
expect
(
"
Custom
header
not
found
"
)
;
assert_eq
!
(
received_header
.
value
(
)
test_data
)
;
stream
.
send_headers
(
&
[
Header
:
:
new
(
"
:
status
"
"
200
"
)
Header
:
:
new
(
response_header_name
received_header
.
value
(
)
)
]
)
.
unwrap
(
)
;
stream
.
stream_close_send
(
now
(
)
)
.
unwrap
(
)
;
exchange_packets
(
&
mut
client
&
mut
server
false
None
)
;
let
mut
response_headers
=
None
;
while
let
Some
(
event
)
=
client
.
next_event
(
)
{
if
let
Http3ClientEvent
:
:
HeaderReady
{
headers
.
.
}
=
event
{
response_headers
=
Some
(
headers
)
;
break
;
}
}
let
headers
=
response_headers
.
expect
(
"
No
response
headers
received
"
)
;
let
echoed_header
=
headers
.
find_header
(
response_header_name
)
.
expect
(
"
Echoed
header
not
found
"
)
;
assert_eq
!
(
echoed_header
.
value
(
)
test_data
)
;
}
#
[
test
]
fn
extended_ascii_non_utf8_header_echo
(
)
{
let
test_bytes
:
Vec
<
u8
>
=
vec
!
[
0xE4
]
;
echo_header
(
"
x
-
custom
-
data
"
"
x
-
echoed
-
data
"
&
test_bytes
)
;
}
#
[
test
]
fn
non_ascii_emoji_header_echo
(
)
{
let
emoji_data
=
b
"
\
xF0
\
x9F
\
x9A
\
x80
\
xF0
\
x9F
\
x8C
\
x9F
\
xF0
\
x9F
\
x92
\
xBB
"
;
echo_header
(
"
x
-
emoji
-
data
"
"
x
-
echoed
-
emoji
"
emoji_data
)
;
}
