#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
static
/
images
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
docs
.
rs
/
env_logger
/
0
.
8
.
2
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
#
!
[
cfg_attr
(
rustbuild
feature
(
staged_api
rustc_private
)
)
]
#
!
[
cfg_attr
(
rustbuild
unstable
(
feature
=
"
rustc_private
"
issue
=
"
27812
"
)
)
]
#
!
[
deny
(
missing_debug_implementations
missing_docs
warnings
)
]
use
std
:
:
{
borrow
:
:
Cow
cell
:
:
RefCell
env
io
}
;
use
log
:
:
{
LevelFilter
Log
Metadata
Record
SetLoggerError
}
;
pub
mod
filter
;
pub
mod
fmt
;
pub
use
self
:
:
fmt
:
:
glob
:
:
*
;
use
self
:
:
filter
:
:
Filter
;
use
self
:
:
fmt
:
:
writer
:
:
{
self
Writer
}
;
use
self
:
:
fmt
:
:
{
FormatFn
Formatter
}
;
pub
const
DEFAULT_FILTER_ENV
:
&
str
=
"
RUST_LOG
"
;
pub
const
DEFAULT_WRITE_STYLE_ENV
:
&
str
=
"
RUST_LOG_STYLE
"
;
#
[
derive
(
Debug
)
]
pub
struct
Env
<
'
a
>
{
filter
:
Var
<
'
a
>
write_style
:
Var
<
'
a
>
}
#
[
derive
(
Debug
)
]
struct
Var
<
'
a
>
{
name
:
Cow
<
'
a
str
>
default
:
Option
<
Cow
<
'
a
str
>
>
}
pub
struct
Logger
{
writer
:
Writer
filter
:
Filter
format
:
FormatFn
}
#
[
derive
(
Default
)
]
pub
struct
Builder
{
filter
:
filter
:
:
Builder
writer
:
writer
:
:
Builder
format
:
fmt
:
:
Builder
built
:
bool
}
impl
Builder
{
pub
fn
new
(
)
-
>
Builder
{
Default
:
:
default
(
)
}
pub
fn
from_env
<
'
a
E
>
(
env
:
E
)
-
>
Self
where
E
:
Into
<
Env
<
'
a
>
>
{
let
mut
builder
=
Builder
:
:
new
(
)
;
builder
.
parse_env
(
env
)
;
builder
}
pub
fn
parse_env
<
'
a
E
>
(
&
mut
self
env
:
E
)
-
>
&
mut
Self
where
E
:
Into
<
Env
<
'
a
>
>
{
let
env
=
env
.
into
(
)
;
if
let
Some
(
s
)
=
env
.
get_filter
(
)
{
self
.
parse_filters
(
&
s
)
;
}
if
let
Some
(
s
)
=
env
.
get_write_style
(
)
{
self
.
parse_write_style
(
&
s
)
;
}
self
}
pub
fn
from_default_env
(
)
-
>
Self
{
Self
:
:
from_env
(
Env
:
:
default
(
)
)
}
pub
fn
parse_default_env
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
parse_env
(
Env
:
:
default
(
)
)
}
pub
fn
format
<
F
:
'
static
>
(
&
mut
self
format
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
&
mut
Formatter
&
Record
)
-
>
io
:
:
Result
<
(
)
>
+
Sync
+
Send
{
self
.
format
.
custom_format
=
Some
(
Box
:
:
new
(
format
)
)
;
self
}
pub
fn
default_format
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
format
=
Default
:
:
default
(
)
;
self
}
pub
fn
format_level
(
&
mut
self
write
:
bool
)
-
>
&
mut
Self
{
self
.
format
.
format_level
=
write
;
self
}
pub
fn
format_module_path
(
&
mut
self
write
:
bool
)
-
>
&
mut
Self
{
self
.
format
.
format_module_path
=
write
;
self
}
pub
fn
format_indent
(
&
mut
self
indent
:
Option
<
usize
>
)
-
>
&
mut
Self
{
self
.
format
.
format_indent
=
indent
;
self
}
pub
fn
format_timestamp
(
&
mut
self
timestamp
:
Option
<
fmt
:
:
TimestampPrecision
>
)
-
>
&
mut
Self
{
self
.
format
.
format_timestamp
=
timestamp
;
self
}
pub
fn
format_timestamp_secs
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
format_timestamp
(
Some
(
fmt
:
:
TimestampPrecision
:
:
Seconds
)
)
}
pub
fn
format_timestamp_millis
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
format_timestamp
(
Some
(
fmt
:
:
TimestampPrecision
:
:
Millis
)
)
}
pub
fn
format_timestamp_micros
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
format_timestamp
(
Some
(
fmt
:
:
TimestampPrecision
:
:
Micros
)
)
}
pub
fn
format_timestamp_nanos
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
format_timestamp
(
Some
(
fmt
:
:
TimestampPrecision
:
:
Nanos
)
)
}
pub
fn
filter_module
(
&
mut
self
module
:
&
str
level
:
LevelFilter
)
-
>
&
mut
Self
{
self
.
filter
.
filter_module
(
module
level
)
;
self
}
pub
fn
filter_level
(
&
mut
self
level
:
LevelFilter
)
-
>
&
mut
Self
{
self
.
filter
.
filter_level
(
level
)
;
self
}
pub
fn
filter
(
&
mut
self
module
:
Option
<
&
str
>
level
:
LevelFilter
)
-
>
&
mut
Self
{
self
.
filter
.
filter
(
module
level
)
;
self
}
pub
fn
parse_filters
(
&
mut
self
filters
:
&
str
)
-
>
&
mut
Self
{
self
.
filter
.
parse
(
filters
)
;
self
}
pub
fn
target
(
&
mut
self
target
:
fmt
:
:
Target
)
-
>
&
mut
Self
{
self
.
writer
.
target
(
target
)
;
self
}
pub
fn
write_style
(
&
mut
self
write_style
:
fmt
:
:
WriteStyle
)
-
>
&
mut
Self
{
self
.
writer
.
write_style
(
write_style
)
;
self
}
pub
fn
parse_write_style
(
&
mut
self
write_style
:
&
str
)
-
>
&
mut
Self
{
self
.
writer
.
parse_write_style
(
write_style
)
;
self
}
pub
fn
is_test
(
&
mut
self
is_test
:
bool
)
-
>
&
mut
Self
{
self
.
writer
.
is_test
(
is_test
)
;
self
}
pub
fn
try_init
(
&
mut
self
)
-
>
Result
<
(
)
SetLoggerError
>
{
let
logger
=
self
.
build
(
)
;
let
max_level
=
logger
.
filter
(
)
;
let
r
=
log
:
:
set_boxed_logger
(
Box
:
:
new
(
logger
)
)
;
if
r
.
is_ok
(
)
{
log
:
:
set_max_level
(
max_level
)
;
}
r
}
pub
fn
init
(
&
mut
self
)
{
self
.
try_init
(
)
.
expect
(
"
Builder
:
:
init
should
not
be
called
after
logger
initialized
"
)
;
}
pub
fn
build
(
&
mut
self
)
-
>
Logger
{
assert
!
(
!
self
.
built
"
attempt
to
re
-
use
consumed
builder
"
)
;
self
.
built
=
true
;
Logger
{
writer
:
self
.
writer
.
build
(
)
filter
:
self
.
filter
.
build
(
)
format
:
self
.
format
.
build
(
)
}
}
}
impl
Logger
{
pub
fn
from_env
<
'
a
E
>
(
env
:
E
)
-
>
Self
where
E
:
Into
<
Env
<
'
a
>
>
{
Builder
:
:
from_env
(
env
)
.
build
(
)
}
pub
fn
from_default_env
(
)
-
>
Self
{
Builder
:
:
from_default_env
(
)
.
build
(
)
}
pub
fn
filter
(
&
self
)
-
>
LevelFilter
{
self
.
filter
.
filter
(
)
}
pub
fn
matches
(
&
self
record
:
&
Record
)
-
>
bool
{
self
.
filter
.
matches
(
record
)
}
}
impl
Log
for
Logger
{
fn
enabled
(
&
self
metadata
:
&
Metadata
)
-
>
bool
{
self
.
filter
.
enabled
(
metadata
)
}
fn
log
(
&
self
record
:
&
Record
)
{
if
self
.
matches
(
record
)
{
thread_local
!
{
static
FORMATTER
:
RefCell
<
Option
<
Formatter
>
>
=
RefCell
:
:
new
(
None
)
;
}
let
print
=
|
formatter
:
&
mut
Formatter
record
:
&
Record
|
{
let
_
=
(
self
.
format
)
(
formatter
record
)
.
and_then
(
|
_
|
formatter
.
print
(
&
self
.
writer
)
)
;
formatter
.
clear
(
)
;
}
;
let
printed
=
FORMATTER
.
try_with
(
|
tl_buf
|
{
match
tl_buf
.
try_borrow_mut
(
)
{
Ok
(
mut
tl_buf
)
=
>
match
*
tl_buf
{
Some
(
ref
mut
formatter
)
=
>
{
if
formatter
.
write_style
(
)
!
=
self
.
writer
.
write_style
(
)
{
*
formatter
=
Formatter
:
:
new
(
&
self
.
writer
)
;
}
print
(
formatter
record
)
;
}
None
=
>
{
let
mut
formatter
=
Formatter
:
:
new
(
&
self
.
writer
)
;
print
(
&
mut
formatter
record
)
;
*
tl_buf
=
Some
(
formatter
)
;
}
}
Err
(
_
)
=
>
{
print
(
&
mut
Formatter
:
:
new
(
&
self
.
writer
)
record
)
;
}
}
}
)
.
is_ok
(
)
;
if
!
printed
{
print
(
&
mut
Formatter
:
:
new
(
&
self
.
writer
)
record
)
;
}
}
}
fn
flush
(
&
self
)
{
}
}
impl
<
'
a
>
Env
<
'
a
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
filter
<
E
>
(
mut
self
filter_env
:
E
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
filter
=
Var
:
:
new
(
filter_env
)
;
self
}
pub
fn
filter_or
<
E
V
>
(
mut
self
filter_env
:
E
default
:
V
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
V
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
filter
=
Var
:
:
new_with_default
(
filter_env
default
)
;
self
}
pub
fn
default_filter_or
<
V
>
(
mut
self
default
:
V
)
-
>
Self
where
V
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
filter
=
Var
:
:
new_with_default
(
DEFAULT_FILTER_ENV
default
)
;
self
}
fn
get_filter
(
&
self
)
-
>
Option
<
String
>
{
self
.
filter
.
get
(
)
}
pub
fn
write_style
<
E
>
(
mut
self
write_style_env
:
E
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
write_style
=
Var
:
:
new
(
write_style_env
)
;
self
}
pub
fn
write_style_or
<
E
V
>
(
mut
self
write_style_env
:
E
default
:
V
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
V
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
write_style
=
Var
:
:
new_with_default
(
write_style_env
default
)
;
self
}
pub
fn
default_write_style_or
<
V
>
(
mut
self
default
:
V
)
-
>
Self
where
V
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
write_style
=
Var
:
:
new_with_default
(
DEFAULT_WRITE_STYLE_ENV
default
)
;
self
}
fn
get_write_style
(
&
self
)
-
>
Option
<
String
>
{
self
.
write_style
.
get
(
)
}
}
impl
<
'
a
>
Var
<
'
a
>
{
fn
new
<
E
>
(
name
:
E
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
{
Var
{
name
:
name
.
into
(
)
default
:
None
}
}
fn
new_with_default
<
E
V
>
(
name
:
E
default
:
V
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
V
:
Into
<
Cow
<
'
a
str
>
>
{
Var
{
name
:
name
.
into
(
)
default
:
Some
(
default
.
into
(
)
)
}
}
fn
get
(
&
self
)
-
>
Option
<
String
>
{
env
:
:
var
(
&
*
self
.
name
)
.
ok
(
)
.
or_else
(
|
|
self
.
default
.
to_owned
(
)
.
map
(
|
v
|
v
.
into_owned
(
)
)
)
}
}
impl
<
'
a
T
>
From
<
T
>
for
Env
<
'
a
>
where
T
:
Into
<
Cow
<
'
a
str
>
>
{
fn
from
(
filter_env
:
T
)
-
>
Self
{
Env
:
:
default
(
)
.
filter
(
filter_env
.
into
(
)
)
}
}
impl
<
'
a
>
Default
for
Env
<
'
a
>
{
fn
default
(
)
-
>
Self
{
Env
{
filter
:
Var
:
:
new
(
DEFAULT_FILTER_ENV
)
write_style
:
Var
:
:
new
(
DEFAULT_WRITE_STYLE_ENV
)
}
}
}
mod
std_fmt_impls
{
use
super
:
:
*
;
use
std
:
:
fmt
;
impl
fmt
:
:
Debug
for
Logger
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Logger
"
)
.
field
(
"
filter
"
&
self
.
filter
)
.
finish
(
)
}
}
impl
fmt
:
:
Debug
for
Builder
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
built
{
f
.
debug_struct
(
"
Logger
"
)
.
field
(
"
built
"
&
true
)
.
finish
(
)
}
else
{
f
.
debug_struct
(
"
Logger
"
)
.
field
(
"
filter
"
&
self
.
filter
)
.
field
(
"
writer
"
&
self
.
writer
)
.
finish
(
)
}
}
}
}
pub
fn
try_init
(
)
-
>
Result
<
(
)
SetLoggerError
>
{
try_init_from_env
(
Env
:
:
default
(
)
)
}
pub
fn
init
(
)
{
try_init
(
)
.
expect
(
"
env_logger
:
:
init
should
not
be
called
after
logger
initialized
"
)
;
}
pub
fn
try_init_from_env
<
'
a
E
>
(
env
:
E
)
-
>
Result
<
(
)
SetLoggerError
>
where
E
:
Into
<
Env
<
'
a
>
>
{
let
mut
builder
=
Builder
:
:
from_env
(
env
)
;
builder
.
try_init
(
)
}
pub
fn
init_from_env
<
'
a
E
>
(
env
:
E
)
where
E
:
Into
<
Env
<
'
a
>
>
{
try_init_from_env
(
env
)
.
expect
(
"
env_logger
:
:
init_from_env
should
not
be
called
after
logger
initialized
"
)
;
}
pub
fn
builder
(
)
-
>
Builder
{
Builder
:
:
from_default_env
(
)
}
#
[
deprecated
(
since
=
"
0
.
8
.
0
"
note
=
"
Prefer
env_logger
:
:
Builder
:
:
from_env
(
)
instead
.
"
)
]
pub
fn
from_env
<
'
a
E
>
(
env
:
E
)
-
>
Builder
where
E
:
Into
<
Env
<
'
a
>
>
{
Builder
:
:
from_env
(
env
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
env_get_filter_reads_from_var_if_set
(
)
{
env
:
:
set_var
(
"
env_get_filter_reads_from_var_if_set
"
"
from
var
"
)
;
let
env
=
Env
:
:
new
(
)
.
filter_or
(
"
env_get_filter_reads_from_var_if_set
"
"
from
default
"
)
;
assert_eq
!
(
Some
(
"
from
var
"
.
to_owned
(
)
)
env
.
get_filter
(
)
)
;
}
#
[
test
]
fn
env_get_filter_reads_from_default_if_var_not_set
(
)
{
env
:
:
remove_var
(
"
env_get_filter_reads_from_default_if_var_not_set
"
)
;
let
env
=
Env
:
:
new
(
)
.
filter_or
(
"
env_get_filter_reads_from_default_if_var_not_set
"
"
from
default
"
)
;
assert_eq
!
(
Some
(
"
from
default
"
.
to_owned
(
)
)
env
.
get_filter
(
)
)
;
}
#
[
test
]
fn
env_get_write_style_reads_from_var_if_set
(
)
{
env
:
:
set_var
(
"
env_get_write_style_reads_from_var_if_set
"
"
from
var
"
)
;
let
env
=
Env
:
:
new
(
)
.
write_style_or
(
"
env_get_write_style_reads_from_var_if_set
"
"
from
default
"
)
;
assert_eq
!
(
Some
(
"
from
var
"
.
to_owned
(
)
)
env
.
get_write_style
(
)
)
;
}
#
[
test
]
fn
env_get_write_style_reads_from_default_if_var_not_set
(
)
{
env
:
:
remove_var
(
"
env_get_write_style_reads_from_default_if_var_not_set
"
)
;
let
env
=
Env
:
:
new
(
)
.
write_style_or
(
"
env_get_write_style_reads_from_default_if_var_not_set
"
"
from
default
"
)
;
assert_eq
!
(
Some
(
"
from
default
"
.
to_owned
(
)
)
env
.
get_write_style
(
)
)
;
}
}
