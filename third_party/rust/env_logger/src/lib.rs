#
!
[
doc
(
html_logo_url
=
"
http
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
http
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
docs
.
rs
/
env_logger
/
0
.
5
.
4
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
#
!
[
cfg_attr
(
rustbuild
feature
(
staged_api
rustc_private
)
)
]
#
!
[
cfg_attr
(
rustbuild
unstable
(
feature
=
"
rustc_private
"
issue
=
"
27812
"
)
)
]
#
!
[
deny
(
missing_debug_implementations
missing_docs
warnings
)
]
extern
crate
log
;
extern
crate
termcolor
;
extern
crate
humantime
;
extern
crate
atty
;
use
std
:
:
env
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
;
use
std
:
:
mem
;
use
std
:
:
cell
:
:
RefCell
;
use
log
:
:
{
Log
LevelFilter
Level
Record
SetLoggerError
Metadata
}
;
pub
mod
filter
;
pub
mod
fmt
;
pub
use
self
:
:
fmt
:
:
{
Target
WriteStyle
Color
Formatter
}
;
const
DEFAULT_FILTER_ENV
:
&
'
static
str
=
"
RUST_LOG
"
;
const
DEFAULT_WRITE_STYLE_ENV
:
&
'
static
str
=
"
RUST_LOG_STYLE
"
;
#
[
derive
(
Debug
)
]
pub
struct
Env
<
'
a
>
{
filter
:
Cow
<
'
a
str
>
write_style
:
Cow
<
'
a
str
>
}
pub
struct
Logger
{
writer
:
fmt
:
:
Writer
filter
:
filter
:
:
Filter
format
:
Box
<
Fn
(
&
mut
Formatter
&
Record
)
-
>
io
:
:
Result
<
(
)
>
+
Sync
+
Send
>
}
pub
struct
Builder
{
filter
:
filter
:
:
Builder
writer
:
fmt
:
:
Builder
format
:
Box
<
Fn
(
&
mut
Formatter
&
Record
)
-
>
io
:
:
Result
<
(
)
>
+
Sync
+
Send
>
}
impl
Builder
{
pub
fn
new
(
)
-
>
Builder
{
Builder
{
filter
:
Default
:
:
default
(
)
writer
:
Default
:
:
default
(
)
format
:
Box
:
:
new
(
|
buf
record
|
{
let
ts
=
buf
.
timestamp
(
)
;
let
level
=
record
.
level
(
)
;
let
mut
level_style
=
buf
.
style
(
)
;
match
level
{
Level
:
:
Trace
=
>
level_style
.
set_color
(
Color
:
:
White
)
Level
:
:
Debug
=
>
level_style
.
set_color
(
Color
:
:
Blue
)
Level
:
:
Info
=
>
level_style
.
set_color
(
Color
:
:
Green
)
Level
:
:
Warn
=
>
level_style
.
set_color
(
Color
:
:
Yellow
)
Level
:
:
Error
=
>
level_style
.
set_color
(
Color
:
:
Red
)
.
set_bold
(
true
)
}
;
if
let
Some
(
module_path
)
=
record
.
module_path
(
)
{
writeln
!
(
buf
"
{
:
>
5
}
{
}
:
{
}
:
{
}
"
level_style
.
value
(
level
)
ts
module_path
record
.
args
(
)
)
}
else
{
writeln
!
(
buf
"
{
:
>
5
}
{
}
:
{
}
"
level_style
.
value
(
level
)
ts
record
.
args
(
)
)
}
}
)
}
}
pub
fn
from_env
<
'
a
E
>
(
env
:
E
)
-
>
Self
where
E
:
Into
<
Env
<
'
a
>
>
{
let
mut
builder
=
Builder
:
:
new
(
)
;
let
env
=
env
.
into
(
)
;
if
let
Some
(
s
)
=
env
.
get_filter
(
)
{
builder
.
parse
(
&
s
)
;
}
if
let
Some
(
s
)
=
env
.
get_write_style
(
)
{
builder
.
parse_write_style
(
&
s
)
;
}
builder
}
pub
fn
filter
(
&
mut
self
module
:
Option
<
&
str
>
level
:
LevelFilter
)
-
>
&
mut
Self
{
self
.
filter
.
filter
(
module
level
)
;
self
}
pub
fn
format
<
F
:
'
static
>
(
&
mut
self
format
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
&
mut
Formatter
&
Record
)
-
>
io
:
:
Result
<
(
)
>
+
Sync
+
Send
{
self
.
format
=
Box
:
:
new
(
format
)
;
self
}
pub
fn
target
(
&
mut
self
target
:
fmt
:
:
Target
)
-
>
&
mut
Self
{
self
.
writer
.
target
(
target
)
;
self
}
pub
fn
write_style
(
&
mut
self
write_style
:
fmt
:
:
WriteStyle
)
-
>
&
mut
Self
{
self
.
writer
.
write_style
(
write_style
)
;
self
}
pub
fn
parse
(
&
mut
self
filters
:
&
str
)
-
>
&
mut
Self
{
self
.
filter
.
parse
(
filters
)
;
self
}
pub
fn
parse_write_style
(
&
mut
self
write_style
:
&
str
)
-
>
&
mut
Self
{
self
.
writer
.
parse
(
write_style
)
;
self
}
pub
fn
try_init
(
&
mut
self
)
-
>
Result
<
(
)
SetLoggerError
>
{
let
logger
=
self
.
build
(
)
;
log
:
:
set_max_level
(
logger
.
filter
(
)
)
;
log
:
:
set_boxed_logger
(
Box
:
:
new
(
logger
)
)
}
pub
fn
init
(
&
mut
self
)
{
self
.
try_init
(
)
.
expect
(
"
Builder
:
:
init
should
not
be
called
after
logger
initialized
"
)
;
}
pub
fn
build
(
&
mut
self
)
-
>
Logger
{
Logger
{
writer
:
self
.
writer
.
build
(
)
filter
:
self
.
filter
.
build
(
)
format
:
mem
:
:
replace
(
&
mut
self
.
format
Box
:
:
new
(
|
_
_
|
Ok
(
(
)
)
)
)
}
}
}
impl
Logger
{
pub
fn
filter
(
&
self
)
-
>
LevelFilter
{
self
.
filter
.
filter
(
)
}
pub
fn
matches
(
&
self
record
:
&
Record
)
-
>
bool
{
self
.
filter
.
matches
(
record
)
}
}
impl
Log
for
Logger
{
fn
enabled
(
&
self
metadata
:
&
Metadata
)
-
>
bool
{
self
.
filter
.
enabled
(
metadata
)
}
fn
log
(
&
self
record
:
&
Record
)
{
if
self
.
matches
(
record
)
{
thread_local
!
{
static
FORMATTER
:
RefCell
<
Option
<
Formatter
>
>
=
RefCell
:
:
new
(
None
)
;
}
FORMATTER
.
with
(
|
tl_buf
|
{
let
mut
a
;
let
mut
b
=
None
;
let
tl_buf
=
match
tl_buf
.
try_borrow_mut
(
)
{
Ok
(
f
)
=
>
{
a
=
f
;
&
mut
*
a
}
Err
(
_
)
=
>
&
mut
b
}
;
match
*
tl_buf
{
Some
(
ref
mut
formatter
)
=
>
{
if
formatter
.
write_style
(
)
!
=
self
.
writer
.
write_style
(
)
{
*
formatter
=
Formatter
:
:
new
(
&
self
.
writer
)
}
}
ref
mut
tl_buf
=
>
*
tl_buf
=
Some
(
Formatter
:
:
new
(
&
self
.
writer
)
)
}
let
mut
formatter
=
tl_buf
.
as_mut
(
)
.
unwrap
(
)
;
let
_
=
(
self
.
format
)
(
&
mut
formatter
record
)
.
and_then
(
|
_
|
formatter
.
print
(
&
self
.
writer
)
)
;
formatter
.
clear
(
)
;
}
)
;
}
}
fn
flush
(
&
self
)
{
}
}
impl
<
'
a
>
Env
<
'
a
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
filter
<
E
>
(
mut
self
filter_env
:
E
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
filter
=
filter_env
.
into
(
)
;
self
}
fn
get_filter
(
&
self
)
-
>
Option
<
String
>
{
env
:
:
var
(
&
*
self
.
filter
)
.
ok
(
)
}
pub
fn
write_style
<
E
>
(
mut
self
write_style_env
:
E
)
-
>
Self
where
E
:
Into
<
Cow
<
'
a
str
>
>
{
self
.
write_style
=
write_style_env
.
into
(
)
;
self
}
fn
get_write_style
(
&
self
)
-
>
Option
<
String
>
{
env
:
:
var
(
&
*
self
.
write_style
)
.
ok
(
)
}
}
impl
<
'
a
T
>
From
<
T
>
for
Env
<
'
a
>
where
T
:
Into
<
Cow
<
'
a
str
>
>
{
fn
from
(
filter_env
:
T
)
-
>
Self
{
Env
:
:
default
(
)
.
filter
(
filter_env
.
into
(
)
)
}
}
impl
<
'
a
>
Default
for
Env
<
'
a
>
{
fn
default
(
)
-
>
Self
{
Env
{
filter
:
DEFAULT_FILTER_ENV
.
into
(
)
write_style
:
DEFAULT_WRITE_STYLE_ENV
.
into
(
)
}
}
}
mod
std_fmt_impls
{
use
std
:
:
fmt
;
use
super
:
:
*
;
impl
fmt
:
:
Debug
for
Logger
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Logger
"
)
.
field
(
"
filter
"
&
self
.
filter
)
.
finish
(
)
}
}
impl
fmt
:
:
Debug
for
Builder
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Logger
"
)
.
field
(
"
filter
"
&
self
.
filter
)
.
field
(
"
writer
"
&
self
.
writer
)
.
finish
(
)
}
}
}
pub
fn
try_init
(
)
-
>
Result
<
(
)
SetLoggerError
>
{
try_init_from_env
(
Env
:
:
default
(
)
)
}
pub
fn
init
(
)
{
try_init
(
)
.
expect
(
"
env_logger
:
:
init
should
not
be
called
after
logger
initialized
"
)
;
}
pub
fn
try_init_from_env
<
'
a
E
>
(
env
:
E
)
-
>
Result
<
(
)
SetLoggerError
>
where
E
:
Into
<
Env
<
'
a
>
>
{
let
mut
builder
=
Builder
:
:
from_env
(
env
)
;
builder
.
try_init
(
)
}
pub
fn
init_from_env
<
'
a
E
>
(
env
:
E
)
where
E
:
Into
<
Env
<
'
a
>
>
{
try_init_from_env
(
env
)
.
expect
(
"
env_logger
:
:
init_from_env
should
not
be
called
after
logger
initialized
"
)
;
}
