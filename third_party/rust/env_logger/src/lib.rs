#
!
[
doc
(
html_logo_url
=
"
http
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
http
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
http
:
/
/
doc
.
rust
-
lang
.
org
/
env_logger
/
"
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
extern
crate
log
;
use
std
:
:
env
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
io
;
use
std
:
:
mem
;
use
log
:
:
{
Log
LogLevel
LogLevelFilter
LogRecord
SetLoggerError
LogMetadata
}
;
#
[
cfg
(
feature
=
"
regex
"
)
]
#
[
path
=
"
regex
.
rs
"
]
mod
filter
;
#
[
cfg
(
not
(
feature
=
"
regex
"
)
)
]
#
[
path
=
"
string
.
rs
"
]
mod
filter
;
pub
struct
Logger
{
directives
:
Vec
<
LogDirective
>
filter
:
Option
<
filter
:
:
Filter
>
format
:
Box
<
Fn
(
&
LogRecord
)
-
>
String
+
Sync
+
Send
>
}
pub
struct
LogBuilder
{
directives
:
Vec
<
LogDirective
>
filter
:
Option
<
filter
:
:
Filter
>
format
:
Box
<
Fn
(
&
LogRecord
)
-
>
String
+
Sync
+
Send
>
}
impl
LogBuilder
{
pub
fn
new
(
)
-
>
LogBuilder
{
LogBuilder
{
directives
:
Vec
:
:
new
(
)
filter
:
None
format
:
Box
:
:
new
(
|
record
:
&
LogRecord
|
{
format
!
(
"
{
}
:
{
}
:
{
}
"
record
.
level
(
)
record
.
location
(
)
.
module_path
(
)
record
.
args
(
)
)
}
)
}
}
pub
fn
filter
(
&
mut
self
module
:
Option
<
&
str
>
level
:
LogLevelFilter
)
-
>
&
mut
Self
{
self
.
directives
.
push
(
LogDirective
{
name
:
module
.
map
(
|
s
|
s
.
to_string
(
)
)
level
:
level
}
)
;
self
}
pub
fn
format
<
F
:
'
static
>
(
&
mut
self
format
:
F
)
-
>
&
mut
Self
where
F
:
Fn
(
&
LogRecord
)
-
>
String
+
Sync
+
Send
{
self
.
format
=
Box
:
:
new
(
format
)
;
self
}
pub
fn
parse
(
&
mut
self
filters
:
&
str
)
-
>
&
mut
Self
{
let
(
directives
filter
)
=
parse_logging_spec
(
filters
)
;
self
.
filter
=
filter
;
for
directive
in
directives
{
self
.
directives
.
push
(
directive
)
;
}
self
}
pub
fn
init
(
&
mut
self
)
-
>
Result
<
(
)
SetLoggerError
>
{
log
:
:
set_logger
(
|
max_level
|
{
let
logger
=
self
.
build
(
)
;
max_level
.
set
(
logger
.
filter
(
)
)
;
Box
:
:
new
(
logger
)
}
)
}
pub
fn
build
(
&
mut
self
)
-
>
Logger
{
if
self
.
directives
.
is_empty
(
)
{
self
.
directives
.
push
(
LogDirective
{
name
:
None
level
:
LogLevelFilter
:
:
Error
}
)
;
}
else
{
self
.
directives
.
sort_by
(
|
a
b
|
{
let
alen
=
a
.
name
.
as_ref
(
)
.
map
(
|
a
|
a
.
len
(
)
)
.
unwrap_or
(
0
)
;
let
blen
=
b
.
name
.
as_ref
(
)
.
map
(
|
b
|
b
.
len
(
)
)
.
unwrap_or
(
0
)
;
alen
.
cmp
(
&
blen
)
}
)
;
}
Logger
{
directives
:
mem
:
:
replace
(
&
mut
self
.
directives
Vec
:
:
new
(
)
)
filter
:
mem
:
:
replace
(
&
mut
self
.
filter
None
)
format
:
mem
:
:
replace
(
&
mut
self
.
format
Box
:
:
new
(
|
_
|
String
:
:
new
(
)
)
)
}
}
}
impl
Logger
{
pub
fn
new
(
)
-
>
Logger
{
let
mut
builder
=
LogBuilder
:
:
new
(
)
;
if
let
Ok
(
s
)
=
env
:
:
var
(
"
RUST_LOG
"
)
{
builder
.
parse
(
&
s
)
;
}
builder
.
build
(
)
}
pub
fn
filter
(
&
self
)
-
>
LogLevelFilter
{
self
.
directives
.
iter
(
)
.
map
(
|
d
|
d
.
level
)
.
max
(
)
.
unwrap_or
(
LogLevelFilter
:
:
Off
)
}
fn
enabled
(
&
self
level
:
LogLevel
target
:
&
str
)
-
>
bool
{
for
directive
in
self
.
directives
.
iter
(
)
.
rev
(
)
{
match
directive
.
name
{
Some
(
ref
name
)
if
!
target
.
starts_with
(
&
*
*
name
)
=
>
{
}
Some
(
.
.
)
|
None
=
>
{
return
level
<
=
directive
.
level
}
}
}
false
}
}
impl
Log
for
Logger
{
fn
enabled
(
&
self
metadata
:
&
LogMetadata
)
-
>
bool
{
self
.
enabled
(
metadata
.
level
(
)
metadata
.
target
(
)
)
}
fn
log
(
&
self
record
:
&
LogRecord
)
{
if
!
Log
:
:
enabled
(
self
record
.
metadata
(
)
)
{
return
;
}
if
let
Some
(
filter
)
=
self
.
filter
.
as_ref
(
)
{
if
!
filter
.
is_match
(
&
*
record
.
args
(
)
.
to_string
(
)
)
{
return
;
}
}
let
_
=
writeln
!
(
&
mut
io
:
:
stderr
(
)
"
{
}
"
(
self
.
format
)
(
record
)
)
;
}
}
struct
LogDirective
{
name
:
Option
<
String
>
level
:
LogLevelFilter
}
pub
fn
init
(
)
-
>
Result
<
(
)
SetLoggerError
>
{
let
mut
builder
=
LogBuilder
:
:
new
(
)
;
if
let
Ok
(
s
)
=
env
:
:
var
(
"
RUST_LOG
"
)
{
builder
.
parse
(
&
s
)
;
}
builder
.
init
(
)
}
fn
parse_logging_spec
(
spec
:
&
str
)
-
>
(
Vec
<
LogDirective
>
Option
<
filter
:
:
Filter
>
)
{
let
mut
dirs
=
Vec
:
:
new
(
)
;
let
mut
parts
=
spec
.
split
(
'
/
'
)
;
let
mods
=
parts
.
next
(
)
;
let
filter
=
parts
.
next
(
)
;
if
parts
.
next
(
)
.
is_some
(
)
{
println
!
(
"
warning
:
invalid
logging
spec
'
{
}
'
\
ignoring
it
(
too
many
'
/
'
s
)
"
spec
)
;
return
(
dirs
None
)
;
}
mods
.
map
(
|
m
|
{
for
s
in
m
.
split
(
'
'
)
{
if
s
.
len
(
)
=
=
0
{
continue
}
let
mut
parts
=
s
.
split
(
'
=
'
)
;
let
(
log_level
name
)
=
match
(
parts
.
next
(
)
parts
.
next
(
)
.
map
(
|
s
|
s
.
trim
(
)
)
parts
.
next
(
)
)
{
(
Some
(
part0
)
None
None
)
=
>
{
match
part0
.
parse
(
)
{
Ok
(
num
)
=
>
(
num
None
)
Err
(
_
)
=
>
(
LogLevelFilter
:
:
max
(
)
Some
(
part0
)
)
}
}
(
Some
(
part0
)
Some
(
"
"
)
None
)
=
>
(
LogLevelFilter
:
:
max
(
)
Some
(
part0
)
)
(
Some
(
part0
)
Some
(
part1
)
None
)
=
>
{
match
part1
.
parse
(
)
{
Ok
(
num
)
=
>
(
num
Some
(
part0
)
)
_
=
>
{
println
!
(
"
warning
:
invalid
logging
spec
'
{
}
'
\
ignoring
it
"
part1
)
;
continue
}
}
}
_
=
>
{
println
!
(
"
warning
:
invalid
logging
spec
'
{
}
'
\
ignoring
it
"
s
)
;
continue
}
}
;
dirs
.
push
(
LogDirective
{
name
:
name
.
map
(
|
s
|
s
.
to_string
(
)
)
level
:
log_level
}
)
;
}
}
)
;
let
filter
=
filter
.
map_or
(
None
|
filter
|
{
match
filter
:
:
Filter
:
:
new
(
filter
)
{
Ok
(
re
)
=
>
Some
(
re
)
Err
(
e
)
=
>
{
println
!
(
"
warning
:
invalid
regex
filter
-
{
}
"
e
)
;
None
}
}
}
)
;
return
(
dirs
filter
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
log
:
:
{
LogLevel
LogLevelFilter
}
;
use
super
:
:
{
LogBuilder
Logger
LogDirective
parse_logging_spec
}
;
fn
make_logger
(
dirs
:
Vec
<
LogDirective
>
)
-
>
Logger
{
let
mut
logger
=
LogBuilder
:
:
new
(
)
.
build
(
)
;
logger
.
directives
=
dirs
;
logger
}
#
[
test
]
fn
filter_info
(
)
{
let
logger
=
LogBuilder
:
:
new
(
)
.
filter
(
None
LogLevelFilter
:
:
Info
)
.
build
(
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Info
"
crate1
"
)
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Debug
"
crate1
"
)
)
;
}
#
[
test
]
fn
filter_beginning_longest_match
(
)
{
let
logger
=
LogBuilder
:
:
new
(
)
.
filter
(
Some
(
"
crate2
"
)
LogLevelFilter
:
:
Info
)
.
filter
(
Some
(
"
crate2
:
:
mod
"
)
LogLevelFilter
:
:
Debug
)
.
filter
(
Some
(
"
crate1
:
:
mod1
"
)
LogLevelFilter
:
:
Warn
)
.
build
(
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Debug
"
crate2
:
:
mod1
"
)
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Debug
"
crate2
"
)
)
;
}
#
[
test
]
fn
parse_default
(
)
{
let
logger
=
LogBuilder
:
:
new
(
)
.
parse
(
"
info
crate1
:
:
mod1
=
warn
"
)
.
build
(
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Warn
"
crate1
:
:
mod1
"
)
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Info
"
crate2
:
:
mod2
"
)
)
;
}
#
[
test
]
fn
match_full_path
(
)
{
let
logger
=
make_logger
(
vec
!
[
LogDirective
{
name
:
Some
(
"
crate2
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Info
}
LogDirective
{
name
:
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Warn
}
]
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Warn
"
crate1
:
:
mod1
"
)
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Info
"
crate1
:
:
mod1
"
)
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Info
"
crate2
"
)
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Debug
"
crate2
"
)
)
;
}
#
[
test
]
fn
no_match
(
)
{
let
logger
=
make_logger
(
vec
!
[
LogDirective
{
name
:
Some
(
"
crate2
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Info
}
LogDirective
{
name
:
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Warn
}
]
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Warn
"
crate3
"
)
)
;
}
#
[
test
]
fn
match_beginning
(
)
{
let
logger
=
make_logger
(
vec
!
[
LogDirective
{
name
:
Some
(
"
crate2
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Info
}
LogDirective
{
name
:
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Warn
}
]
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Info
"
crate2
:
:
mod1
"
)
)
;
}
#
[
test
]
fn
match_beginning_longest_match
(
)
{
let
logger
=
make_logger
(
vec
!
[
LogDirective
{
name
:
Some
(
"
crate2
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Info
}
LogDirective
{
name
:
Some
(
"
crate2
:
:
mod
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Debug
}
LogDirective
{
name
:
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Warn
}
]
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Debug
"
crate2
:
:
mod1
"
)
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Debug
"
crate2
"
)
)
;
}
#
[
test
]
fn
match_default
(
)
{
let
logger
=
make_logger
(
vec
!
[
LogDirective
{
name
:
None
level
:
LogLevelFilter
:
:
Info
}
LogDirective
{
name
:
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Warn
}
]
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Warn
"
crate1
:
:
mod1
"
)
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Info
"
crate2
:
:
mod2
"
)
)
;
}
#
[
test
]
fn
zero_level
(
)
{
let
logger
=
make_logger
(
vec
!
[
LogDirective
{
name
:
None
level
:
LogLevelFilter
:
:
Info
}
LogDirective
{
name
:
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
level
:
LogLevelFilter
:
:
Off
}
]
)
;
assert
!
(
!
logger
.
enabled
(
LogLevel
:
:
Error
"
crate1
:
:
mod1
"
)
)
;
assert
!
(
logger
.
enabled
(
LogLevel
:
:
Info
"
crate2
:
:
mod2
"
)
)
;
}
#
[
test
]
fn
parse_logging_spec_valid
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
error
crate1
:
:
mod2
crate2
=
debug
"
)
;
assert_eq
!
(
dirs
.
len
(
)
3
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Error
)
;
assert_eq
!
(
dirs
[
1
]
.
name
Some
(
"
crate1
:
:
mod2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
1
]
.
level
LogLevelFilter
:
:
max
(
)
)
;
assert_eq
!
(
dirs
[
2
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
2
]
.
level
LogLevelFilter
:
:
Debug
)
;
assert
!
(
filter
.
is_none
(
)
)
;
}
#
[
test
]
fn
parse_logging_spec_invalid_crate
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
warn
=
info
crate2
=
debug
"
)
;
assert_eq
!
(
dirs
.
len
(
)
1
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Debug
)
;
assert
!
(
filter
.
is_none
(
)
)
;
}
#
[
test
]
fn
parse_logging_spec_invalid_log_level
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
noNumber
crate2
=
debug
"
)
;
assert_eq
!
(
dirs
.
len
(
)
1
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Debug
)
;
assert
!
(
filter
.
is_none
(
)
)
;
}
#
[
test
]
fn
parse_logging_spec_string_log_level
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
wrong
crate2
=
warn
"
)
;
assert_eq
!
(
dirs
.
len
(
)
1
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Warn
)
;
assert
!
(
filter
.
is_none
(
)
)
;
}
#
[
test
]
fn
parse_logging_spec_empty_log_level
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
wrong
crate2
=
"
)
;
assert_eq
!
(
dirs
.
len
(
)
1
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
max
(
)
)
;
assert
!
(
filter
.
is_none
(
)
)
;
}
#
[
test
]
fn
parse_logging_spec_global
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
warn
crate2
=
debug
"
)
;
assert_eq
!
(
dirs
.
len
(
)
2
)
;
assert_eq
!
(
dirs
[
0
]
.
name
None
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Warn
)
;
assert_eq
!
(
dirs
[
1
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
1
]
.
level
LogLevelFilter
:
:
Debug
)
;
assert
!
(
filter
.
is_none
(
)
)
;
}
#
[
test
]
fn
parse_logging_spec_valid_filter
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
error
crate1
:
:
mod2
crate2
=
debug
/
abc
"
)
;
assert_eq
!
(
dirs
.
len
(
)
3
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate1
:
:
mod1
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Error
)
;
assert_eq
!
(
dirs
[
1
]
.
name
Some
(
"
crate1
:
:
mod2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
1
]
.
level
LogLevelFilter
:
:
max
(
)
)
;
assert_eq
!
(
dirs
[
2
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
2
]
.
level
LogLevelFilter
:
:
Debug
)
;
assert
!
(
filter
.
is_some
(
)
&
&
filter
.
unwrap
(
)
.
to_string
(
)
=
=
"
abc
"
)
;
}
#
[
test
]
fn
parse_logging_spec_invalid_crate_filter
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
:
:
mod1
=
error
=
warn
crate2
=
debug
/
a
.
c
"
)
;
assert_eq
!
(
dirs
.
len
(
)
1
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate2
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
Debug
)
;
assert
!
(
filter
.
is_some
(
)
&
&
filter
.
unwrap
(
)
.
to_string
(
)
=
=
"
a
.
c
"
)
;
}
#
[
test
]
fn
parse_logging_spec_empty_with_filter
(
)
{
let
(
dirs
filter
)
=
parse_logging_spec
(
"
crate1
/
a
*
c
"
)
;
assert_eq
!
(
dirs
.
len
(
)
1
)
;
assert_eq
!
(
dirs
[
0
]
.
name
Some
(
"
crate1
"
.
to_string
(
)
)
)
;
assert_eq
!
(
dirs
[
0
]
.
level
LogLevelFilter
:
:
max
(
)
)
;
assert
!
(
filter
.
is_some
(
)
&
&
filter
.
unwrap
(
)
.
to_string
(
)
=
=
"
a
*
c
"
)
;
}
}
