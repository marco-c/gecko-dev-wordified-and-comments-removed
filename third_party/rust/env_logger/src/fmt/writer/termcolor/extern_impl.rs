use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
rc
:
:
Rc
;
use
log
:
:
Level
;
use
termcolor
:
:
{
self
ColorChoice
ColorSpec
WriteColor
}
;
use
crate
:
:
fmt
:
:
{
Formatter
Target
WriteStyle
}
;
pub
(
in
crate
:
:
fmt
:
:
writer
)
mod
glob
{
pub
use
super
:
:
*
;
}
impl
Formatter
{
pub
fn
style
(
&
self
)
-
>
Style
{
Style
{
buf
:
self
.
buf
.
clone
(
)
spec
:
ColorSpec
:
:
new
(
)
}
}
pub
fn
default_level_style
(
&
self
level
:
Level
)
-
>
Style
{
let
mut
level_style
=
self
.
style
(
)
;
match
level
{
Level
:
:
Trace
=
>
level_style
.
set_color
(
Color
:
:
Black
)
.
set_intense
(
true
)
Level
:
:
Debug
=
>
level_style
.
set_color
(
Color
:
:
White
)
Level
:
:
Info
=
>
level_style
.
set_color
(
Color
:
:
Green
)
Level
:
:
Warn
=
>
level_style
.
set_color
(
Color
:
:
Yellow
)
Level
:
:
Error
=
>
level_style
.
set_color
(
Color
:
:
Red
)
.
set_bold
(
true
)
}
;
level_style
}
pub
fn
default_styled_level
(
&
self
level
:
Level
)
-
>
StyledValue
<
'
static
Level
>
{
self
.
default_level_style
(
level
)
.
into_value
(
level
)
}
}
pub
(
in
crate
:
:
fmt
:
:
writer
)
struct
BufferWriter
{
inner
:
termcolor
:
:
BufferWriter
test_target
:
Option
<
Target
>
}
pub
(
in
crate
:
:
fmt
)
struct
Buffer
{
inner
:
termcolor
:
:
Buffer
test_target
:
Option
<
Target
>
}
impl
BufferWriter
{
pub
(
in
crate
:
:
fmt
:
:
writer
)
fn
stderr
(
is_test
:
bool
write_style
:
WriteStyle
)
-
>
Self
{
BufferWriter
{
inner
:
termcolor
:
:
BufferWriter
:
:
stderr
(
write_style
.
into_color_choice
(
)
)
test_target
:
if
is_test
{
Some
(
Target
:
:
Stderr
)
}
else
{
None
}
}
}
pub
(
in
crate
:
:
fmt
:
:
writer
)
fn
stdout
(
is_test
:
bool
write_style
:
WriteStyle
)
-
>
Self
{
BufferWriter
{
inner
:
termcolor
:
:
BufferWriter
:
:
stdout
(
write_style
.
into_color_choice
(
)
)
test_target
:
if
is_test
{
Some
(
Target
:
:
Stdout
)
}
else
{
None
}
}
}
pub
(
in
crate
:
:
fmt
:
:
writer
)
fn
buffer
(
&
self
)
-
>
Buffer
{
Buffer
{
inner
:
self
.
inner
.
buffer
(
)
test_target
:
self
.
test_target
}
}
pub
(
in
crate
:
:
fmt
:
:
writer
)
fn
print
(
&
self
buf
:
&
Buffer
)
-
>
io
:
:
Result
<
(
)
>
{
if
let
Some
(
target
)
=
self
.
test_target
{
let
log
=
String
:
:
from_utf8_lossy
(
buf
.
bytes
(
)
)
;
match
target
{
Target
:
:
Stderr
=
>
eprint
!
(
"
{
}
"
log
)
Target
:
:
Stdout
=
>
print
!
(
"
{
}
"
log
)
}
Ok
(
(
)
)
}
else
{
self
.
inner
.
print
(
&
buf
.
inner
)
}
}
}
impl
Buffer
{
pub
(
in
crate
:
:
fmt
)
fn
clear
(
&
mut
self
)
{
self
.
inner
.
clear
(
)
}
pub
(
in
crate
:
:
fmt
)
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
inner
.
write
(
buf
)
}
pub
(
in
crate
:
:
fmt
)
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
flush
(
)
}
pub
(
in
crate
:
:
fmt
)
fn
bytes
(
&
self
)
-
>
&
[
u8
]
{
self
.
inner
.
as_slice
(
)
}
fn
set_color
(
&
mut
self
spec
:
&
ColorSpec
)
-
>
io
:
:
Result
<
(
)
>
{
if
self
.
test_target
.
is_none
(
)
{
self
.
inner
.
set_color
(
spec
)
}
else
{
Ok
(
(
)
)
}
}
fn
reset
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
self
.
test_target
.
is_none
(
)
{
self
.
inner
.
reset
(
)
}
else
{
Ok
(
(
)
)
}
}
}
impl
WriteStyle
{
fn
into_color_choice
(
self
)
-
>
ColorChoice
{
match
self
{
WriteStyle
:
:
Always
=
>
ColorChoice
:
:
Always
WriteStyle
:
:
Auto
=
>
ColorChoice
:
:
Auto
WriteStyle
:
:
Never
=
>
ColorChoice
:
:
Never
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
Style
{
buf
:
Rc
<
RefCell
<
Buffer
>
>
spec
:
ColorSpec
}
pub
struct
StyledValue
<
'
a
T
>
{
style
:
Cow
<
'
a
Style
>
value
:
T
}
impl
Style
{
pub
fn
set_color
(
&
mut
self
color
:
Color
)
-
>
&
mut
Style
{
self
.
spec
.
set_fg
(
color
.
into_termcolor
(
)
)
;
self
}
pub
fn
set_bold
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Style
{
self
.
spec
.
set_bold
(
yes
)
;
self
}
pub
fn
set_intense
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Style
{
self
.
spec
.
set_intense
(
yes
)
;
self
}
pub
fn
set_bg
(
&
mut
self
color
:
Color
)
-
>
&
mut
Style
{
self
.
spec
.
set_bg
(
color
.
into_termcolor
(
)
)
;
self
}
pub
fn
value
<
T
>
(
&
self
value
:
T
)
-
>
StyledValue
<
T
>
{
StyledValue
{
style
:
Cow
:
:
Borrowed
(
self
)
value
}
}
pub
(
crate
)
fn
into_value
<
T
>
(
&
mut
self
value
:
T
)
-
>
StyledValue
<
'
static
T
>
{
StyledValue
{
style
:
Cow
:
:
Owned
(
self
.
clone
(
)
)
value
}
}
}
impl
<
'
a
T
>
StyledValue
<
'
a
T
>
{
fn
write_fmt
<
F
>
(
&
self
f
:
F
)
-
>
fmt
:
:
Result
where
F
:
FnOnce
(
)
-
>
fmt
:
:
Result
{
self
.
style
.
buf
.
borrow_mut
(
)
.
set_color
(
&
self
.
style
.
spec
)
.
map_err
(
|
_
|
fmt
:
:
Error
)
?
;
let
write
=
f
(
)
;
let
reset
=
self
.
style
.
buf
.
borrow_mut
(
)
.
reset
(
)
.
map_err
(
|
_
|
fmt
:
:
Error
)
;
write
.
and
(
reset
)
}
}
impl
fmt
:
:
Debug
for
Style
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Style
"
)
.
field
(
"
spec
"
&
self
.
spec
)
.
finish
(
)
}
}
macro_rules
!
impl_styled_value_fmt
{
(
(
fmt_trait
:
path
)
*
)
=
>
{
(
impl
<
'
a
T
:
fmt_trait
>
fmt_trait
for
StyledValue
<
'
a
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
write_fmt
(
|
|
T
:
:
fmt
(
&
self
.
value
f
)
)
}
}
)
*
}
;
}
impl_styled_value_fmt
!
(
fmt
:
:
Debug
fmt
:
:
Display
fmt
:
:
Pointer
fmt
:
:
Octal
fmt
:
:
Binary
fmt
:
:
UpperHex
fmt
:
:
LowerHex
fmt
:
:
UpperExp
fmt
:
:
LowerExp
)
;
#
[
allow
(
missing_docs
)
]
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
enum
Color
{
Black
Blue
Green
Red
Cyan
Magenta
Yellow
White
Ansi256
(
u8
)
Rgb
(
u8
u8
u8
)
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
impl
Color
{
fn
into_termcolor
(
self
)
-
>
Option
<
termcolor
:
:
Color
>
{
match
self
{
Color
:
:
Black
=
>
Some
(
termcolor
:
:
Color
:
:
Black
)
Color
:
:
Blue
=
>
Some
(
termcolor
:
:
Color
:
:
Blue
)
Color
:
:
Green
=
>
Some
(
termcolor
:
:
Color
:
:
Green
)
Color
:
:
Red
=
>
Some
(
termcolor
:
:
Color
:
:
Red
)
Color
:
:
Cyan
=
>
Some
(
termcolor
:
:
Color
:
:
Cyan
)
Color
:
:
Magenta
=
>
Some
(
termcolor
:
:
Color
:
:
Magenta
)
Color
:
:
Yellow
=
>
Some
(
termcolor
:
:
Color
:
:
Yellow
)
Color
:
:
White
=
>
Some
(
termcolor
:
:
Color
:
:
White
)
Color
:
:
Ansi256
(
value
)
=
>
Some
(
termcolor
:
:
Color
:
:
Ansi256
(
value
)
)
Color
:
:
Rgb
(
r
g
b
)
=
>
Some
(
termcolor
:
:
Color
:
:
Rgb
(
r
g
b
)
)
_
=
>
None
}
}
}
