#
[
cfg
(
any
(
target_arch
=
"
arm
"
target_arch
=
"
aarch64
"
)
)
]
use
crate
:
:
primitive
:
:
sync
:
:
atomic
:
:
compiler_fence
;
#
[
cfg
(
not
(
crossbeam_no_atomic
)
)
]
use
core
:
:
sync
:
:
atomic
:
:
Ordering
;
pub
trait
AtomicConsume
{
type
Val
;
fn
load_consume
(
&
self
)
-
>
Self
:
:
Val
;
}
#
[
cfg
(
not
(
crossbeam_no_atomic
)
)
]
#
[
cfg
(
any
(
target_arch
=
"
arm
"
target_arch
=
"
aarch64
"
)
)
]
macro_rules
!
impl_consume
{
(
)
=
>
{
#
[
inline
]
fn
load_consume
(
&
self
)
-
>
Self
:
:
Val
{
let
result
=
self
.
load
(
Ordering
:
:
Relaxed
)
;
compiler_fence
(
Ordering
:
:
Acquire
)
;
result
}
}
;
}
#
[
cfg
(
not
(
crossbeam_no_atomic
)
)
]
#
[
cfg
(
not
(
any
(
target_arch
=
"
arm
"
target_arch
=
"
aarch64
"
)
)
)
]
macro_rules
!
impl_consume
{
(
)
=
>
{
#
[
inline
]
fn
load_consume
(
&
self
)
-
>
Self
:
:
Val
{
self
.
load
(
Ordering
:
:
Acquire
)
}
}
;
}
macro_rules
!
impl_atomic
{
(
atomic
:
ident
val
:
ty
)
=
>
{
#
[
cfg
(
not
(
crossbeam_no_atomic
)
)
]
impl
AtomicConsume
for
core
:
:
sync
:
:
atomic
:
:
atomic
{
type
Val
=
val
;
impl_consume
!
(
)
;
}
#
[
cfg
(
crossbeam_loom
)
]
impl
AtomicConsume
for
loom
:
:
sync
:
:
atomic
:
:
atomic
{
type
Val
=
val
;
impl_consume
!
(
)
;
}
}
;
}
impl_atomic
!
(
AtomicBool
bool
)
;
impl_atomic
!
(
AtomicUsize
usize
)
;
impl_atomic
!
(
AtomicIsize
isize
)
;
impl_atomic
!
(
AtomicU8
u8
)
;
impl_atomic
!
(
AtomicI8
i8
)
;
impl_atomic
!
(
AtomicU16
u16
)
;
impl_atomic
!
(
AtomicI16
i16
)
;
impl_atomic
!
(
AtomicU32
u32
)
;
impl_atomic
!
(
AtomicI32
i32
)
;
#
[
cfg
(
not
(
crossbeam_no_atomic_64
)
)
]
impl_atomic
!
(
AtomicU64
u64
)
;
#
[
cfg
(
not
(
crossbeam_no_atomic_64
)
)
]
impl_atomic
!
(
AtomicI64
i64
)
;
#
[
cfg
(
not
(
crossbeam_no_atomic
)
)
]
impl
<
T
>
AtomicConsume
for
core
:
:
sync
:
:
atomic
:
:
AtomicPtr
<
T
>
{
type
Val
=
*
mut
T
;
impl_consume
!
(
)
;
}
#
[
cfg
(
crossbeam_loom
)
]
impl
<
T
>
AtomicConsume
for
loom
:
:
sync
:
:
atomic
:
:
AtomicPtr
<
T
>
{
type
Val
=
*
mut
T
;
impl_consume
!
(
)
;
}
