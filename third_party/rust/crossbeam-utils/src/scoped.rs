use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
std
:
:
io
;
use
atomic_option
:
:
AtomicOption
;
#
[
doc
(
hidden
)
]
trait
FnBox
{
fn
call_box
(
self
:
Box
<
Self
>
)
;
}
impl
<
F
:
FnOnce
(
)
>
FnBox
for
F
{
fn
call_box
(
self
:
Box
<
Self
>
)
{
(
*
self
)
(
)
}
}
pub
unsafe
fn
spawn_unsafe
<
'
a
F
>
(
f
:
F
)
-
>
thread
:
:
JoinHandle
<
(
)
>
where
F
:
FnOnce
(
)
+
Send
+
'
a
{
let
builder
=
thread
:
:
Builder
:
:
new
(
)
;
builder_spawn_unsafe
(
builder
f
)
.
unwrap
(
)
}
pub
unsafe
fn
builder_spawn_unsafe
<
'
a
F
>
(
builder
:
thread
:
:
Builder
f
:
F
)
-
>
io
:
:
Result
<
thread
:
:
JoinHandle
<
(
)
>
>
where
F
:
FnOnce
(
)
+
Send
+
'
a
{
use
std
:
:
mem
;
let
closure
:
Box
<
FnBox
+
'
a
>
=
Box
:
:
new
(
f
)
;
let
closure
:
Box
<
FnBox
+
Send
>
=
mem
:
:
transmute
(
closure
)
;
builder
.
spawn
(
move
|
|
closure
.
call_box
(
)
)
}
pub
struct
Scope
<
'
a
>
{
dtors
:
RefCell
<
Option
<
DtorChain
<
'
a
>
>
>
}
struct
DtorChain
<
'
a
>
{
dtor
:
Box
<
FnBox
+
'
a
>
next
:
Option
<
Box
<
DtorChain
<
'
a
>
>
>
}
enum
JoinState
{
Running
(
thread
:
:
JoinHandle
<
(
)
>
)
Joined
}
impl
JoinState
{
fn
join
(
&
mut
self
)
{
let
mut
state
=
JoinState
:
:
Joined
;
mem
:
:
swap
(
self
&
mut
state
)
;
if
let
JoinState
:
:
Running
(
handle
)
=
state
{
let
res
=
handle
.
join
(
)
;
if
!
thread
:
:
panicking
(
)
{
res
.
unwrap
(
)
;
}
}
}
}
pub
struct
ScopedJoinHandle
<
T
>
{
inner
:
Rc
<
RefCell
<
JoinState
>
>
packet
:
Arc
<
AtomicOption
<
T
>
>
thread
:
thread
:
:
Thread
}
pub
fn
scope
<
'
a
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
Scope
<
'
a
>
)
-
>
R
{
let
mut
scope
=
Scope
{
dtors
:
RefCell
:
:
new
(
None
)
}
;
let
ret
=
f
(
&
scope
)
;
scope
.
drop_all
(
)
;
ret
}
impl
<
'
a
>
fmt
:
:
Debug
for
Scope
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Scope
{
{
.
.
.
}
}
"
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
ScopedJoinHandle
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ScopedJoinHandle
{
{
.
.
.
}
}
"
)
}
}
impl
<
'
a
>
Scope
<
'
a
>
{
fn
drop_all
(
&
mut
self
)
{
loop
{
let
dtor
=
{
let
mut
dtors
=
self
.
dtors
.
borrow_mut
(
)
;
if
let
Some
(
mut
node
)
=
dtors
.
take
(
)
{
*
dtors
=
node
.
next
.
take
(
)
.
map
(
|
b
|
*
b
)
;
node
.
dtor
}
else
{
return
;
}
}
;
dtor
.
call_box
(
)
}
}
pub
fn
defer
<
F
>
(
&
self
f
:
F
)
where
F
:
FnOnce
(
)
+
'
a
{
let
mut
dtors
=
self
.
dtors
.
borrow_mut
(
)
;
*
dtors
=
Some
(
DtorChain
{
dtor
:
Box
:
:
new
(
f
)
next
:
dtors
.
take
(
)
.
map
(
Box
:
:
new
)
}
)
;
}
pub
fn
spawn
<
F
T
>
(
&
self
f
:
F
)
-
>
ScopedJoinHandle
<
T
>
where
F
:
FnOnce
(
)
-
>
T
+
Send
+
'
a
T
:
Send
+
'
a
{
self
.
builder
(
)
.
spawn
(
f
)
.
unwrap
(
)
}
pub
fn
builder
<
'
s
>
(
&
'
s
self
)
-
>
ScopedThreadBuilder
<
'
s
'
a
>
{
ScopedThreadBuilder
{
scope
:
self
builder
:
thread
:
:
Builder
:
:
new
(
)
}
}
}
pub
struct
ScopedThreadBuilder
<
'
s
'
a
:
'
s
>
{
scope
:
&
'
s
Scope
<
'
a
>
builder
:
thread
:
:
Builder
}
impl
<
'
s
'
a
:
'
s
>
ScopedThreadBuilder
<
'
s
'
a
>
{
pub
fn
name
(
mut
self
name
:
String
)
-
>
ScopedThreadBuilder
<
'
s
'
a
>
{
self
.
builder
=
self
.
builder
.
name
(
name
)
;
self
}
pub
fn
stack_size
(
mut
self
size
:
usize
)
-
>
ScopedThreadBuilder
<
'
s
'
a
>
{
self
.
builder
=
self
.
builder
.
stack_size
(
size
)
;
self
}
pub
fn
spawn
<
F
T
>
(
self
f
:
F
)
-
>
io
:
:
Result
<
ScopedJoinHandle
<
T
>
>
where
F
:
FnOnce
(
)
-
>
T
+
Send
+
'
a
T
:
Send
+
'
a
{
let
their_packet
=
Arc
:
:
new
(
AtomicOption
:
:
new
(
)
)
;
let
my_packet
=
their_packet
.
clone
(
)
;
let
join_handle
=
try
!
(
unsafe
{
builder_spawn_unsafe
(
self
.
builder
move
|
|
{
their_packet
.
swap
(
f
(
)
Ordering
:
:
Relaxed
)
;
}
)
}
)
;
let
thread
=
join_handle
.
thread
(
)
.
clone
(
)
;
let
deferred_handle
=
Rc
:
:
new
(
RefCell
:
:
new
(
JoinState
:
:
Running
(
join_handle
)
)
)
;
let
my_handle
=
deferred_handle
.
clone
(
)
;
self
.
scope
.
defer
(
move
|
|
{
let
mut
state
=
deferred_handle
.
borrow_mut
(
)
;
state
.
join
(
)
;
}
)
;
Ok
(
ScopedJoinHandle
{
inner
:
my_handle
packet
:
my_packet
thread
:
thread
}
)
}
}
impl
<
T
>
ScopedJoinHandle
<
T
>
{
pub
fn
join
(
self
)
-
>
T
{
self
.
inner
.
borrow_mut
(
)
.
join
(
)
;
self
.
packet
.
take
(
Ordering
:
:
Relaxed
)
.
unwrap
(
)
}
pub
fn
thread
(
&
self
)
-
>
&
thread
:
:
Thread
{
&
self
.
thread
}
}
impl
<
'
a
>
Drop
for
Scope
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
drop_all
(
)
}
}
