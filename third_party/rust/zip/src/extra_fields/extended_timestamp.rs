use
crate
:
:
result
:
:
{
ZipError
ZipResult
}
;
use
crate
:
:
unstable
:
:
LittleEndianReadExt
;
use
std
:
:
io
:
:
Read
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
ExtendedTimestamp
{
mod_time
:
Option
<
u32
>
ac_time
:
Option
<
u32
>
cr_time
:
Option
<
u32
>
}
impl
ExtendedTimestamp
{
pub
fn
try_from_reader
<
R
>
(
reader
:
&
mut
R
len
:
u16
)
-
>
ZipResult
<
Self
>
where
R
:
Read
{
let
mut
flags
=
[
0u8
]
;
reader
.
read_exact
(
&
mut
flags
)
?
;
let
flags
=
flags
[
0
]
;
if
len
!
=
5
&
&
len
as
u32
!
=
1
+
4
*
flags
.
count_ones
(
)
{
return
Err
(
ZipError
:
:
UnsupportedArchive
(
"
flags
and
len
don
'
t
match
in
extended
timestamp
field
"
)
)
;
}
if
flags
&
0b11111000
!
=
0
{
return
Err
(
ZipError
:
:
UnsupportedArchive
(
"
found
unsupported
timestamps
in
the
extended
timestamp
header
"
)
)
;
}
let
mod_time
=
if
(
flags
&
0b00000001u8
=
=
0b00000001u8
)
|
|
len
=
=
5
{
Some
(
reader
.
read_u32_le
(
)
?
)
}
else
{
None
}
;
let
ac_time
=
if
flags
&
0b00000010u8
=
=
0b00000010u8
&
&
len
>
5
{
Some
(
reader
.
read_u32_le
(
)
?
)
}
else
{
None
}
;
let
cr_time
=
if
flags
&
0b00000100u8
=
=
0b00000100u8
&
&
len
>
5
{
Some
(
reader
.
read_u32_le
(
)
?
)
}
else
{
None
}
;
Ok
(
Self
{
mod_time
ac_time
cr_time
}
)
}
pub
fn
mod_time
(
&
self
)
-
>
Option
<
u32
>
{
self
.
mod_time
}
pub
fn
ac_time
(
&
self
)
-
>
Option
<
u32
>
{
self
.
ac_time
}
pub
fn
cr_time
(
&
self
)
-
>
Option
<
u32
>
{
self
.
cr_time
}
}
