use
std
:
:
fs
;
use
std
:
:
io
:
:
{
self
Read
}
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
super
:
:
{
central_header_to_zip_file_inner
read_zipfile_from_stream
ZipCentralEntryBlock
ZipError
ZipFile
ZipFileData
ZipResult
}
;
use
crate
:
:
spec
:
:
FixedSizeBlock
;
#
[
derive
(
Debug
)
]
pub
struct
ZipStreamReader
<
R
>
(
R
)
;
impl
<
R
>
ZipStreamReader
<
R
>
{
pub
const
fn
new
(
reader
:
R
)
-
>
Self
{
Self
(
reader
)
}
}
impl
<
R
:
Read
>
ZipStreamReader
<
R
>
{
fn
parse_central_directory
(
&
mut
self
)
-
>
ZipResult
<
ZipStreamFileMetadata
>
{
let
archive_offset
=
0
;
let
central_header_start
=
0
;
let
block
=
ZipCentralEntryBlock
:
:
parse
(
&
mut
self
.
0
)
?
;
let
file
=
central_header_to_zip_file_inner
(
&
mut
self
.
0
archive_offset
central_header_start
block
)
?
;
Ok
(
ZipStreamFileMetadata
(
file
)
)
}
pub
fn
visit
<
V
:
ZipStreamVisitor
>
(
mut
self
visitor
:
&
mut
V
)
-
>
ZipResult
<
(
)
>
{
while
let
Some
(
mut
file
)
=
read_zipfile_from_stream
(
&
mut
self
.
0
)
?
{
visitor
.
visit_file
(
&
mut
file
)
?
;
}
while
let
Ok
(
metadata
)
=
self
.
parse_central_directory
(
)
{
visitor
.
visit_additional_metadata
(
&
metadata
)
?
;
}
Ok
(
(
)
)
}
pub
fn
extract
<
P
:
AsRef
<
Path
>
>
(
self
directory
:
P
)
-
>
ZipResult
<
(
)
>
{
struct
Extractor
<
'
a
>
(
&
'
a
Path
)
;
impl
ZipStreamVisitor
for
Extractor
<
'
_
>
{
fn
visit_file
(
&
mut
self
file
:
&
mut
ZipFile
<
'
_
>
)
-
>
ZipResult
<
(
)
>
{
let
filepath
=
file
.
enclosed_name
(
)
.
ok_or
(
ZipError
:
:
InvalidArchive
(
"
Invalid
file
path
"
)
)
?
;
let
outpath
=
self
.
0
.
join
(
filepath
)
;
if
file
.
is_dir
(
)
{
fs
:
:
create_dir_all
(
&
outpath
)
?
;
}
else
{
if
let
Some
(
p
)
=
outpath
.
parent
(
)
{
fs
:
:
create_dir_all
(
p
)
?
;
}
let
mut
outfile
=
fs
:
:
File
:
:
create
(
&
outpath
)
?
;
io
:
:
copy
(
file
&
mut
outfile
)
?
;
}
Ok
(
(
)
)
}
#
[
allow
(
unused
)
]
fn
visit_additional_metadata
(
&
mut
self
metadata
:
&
ZipStreamFileMetadata
)
-
>
ZipResult
<
(
)
>
{
#
[
cfg
(
unix
)
]
{
let
filepath
=
metadata
.
enclosed_name
(
)
.
ok_or
(
ZipError
:
:
InvalidArchive
(
"
Invalid
file
path
"
)
)
?
;
let
outpath
=
self
.
0
.
join
(
filepath
)
;
use
std
:
:
os
:
:
unix
:
:
fs
:
:
PermissionsExt
;
if
let
Some
(
mode
)
=
metadata
.
unix_mode
(
)
{
fs
:
:
set_permissions
(
outpath
fs
:
:
Permissions
:
:
from_mode
(
mode
)
)
?
;
}
}
Ok
(
(
)
)
}
}
self
.
visit
(
&
mut
Extractor
(
directory
.
as_ref
(
)
)
)
}
}
pub
trait
ZipStreamVisitor
{
fn
visit_file
(
&
mut
self
file
:
&
mut
ZipFile
<
'
_
>
)
-
>
ZipResult
<
(
)
>
;
fn
visit_additional_metadata
(
&
mut
self
metadata
:
&
ZipStreamFileMetadata
)
-
>
ZipResult
<
(
)
>
;
}
#
[
derive
(
Debug
)
]
pub
struct
ZipStreamFileMetadata
(
ZipFileData
)
;
impl
ZipStreamFileMetadata
{
pub
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
0
.
file_name
}
pub
fn
name_raw
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
.
file_name_raw
}
pub
fn
mangled_name
(
&
self
)
-
>
PathBuf
{
self
.
0
.
file_name_sanitized
(
)
}
pub
fn
enclosed_name
(
&
self
)
-
>
Option
<
PathBuf
>
{
self
.
0
.
enclosed_name
(
)
}
pub
fn
is_dir
(
&
self
)
-
>
bool
{
self
.
name
(
)
.
chars
(
)
.
next_back
(
)
.
map_or
(
false
|
c
|
c
=
=
'
/
'
|
|
c
=
=
'
\
\
'
)
}
pub
fn
is_file
(
&
self
)
-
>
bool
{
!
self
.
is_dir
(
)
}
pub
fn
comment
(
&
self
)
-
>
&
str
{
&
self
.
0
.
file_comment
}
pub
fn
data_start
(
&
self
)
-
>
u64
{
*
self
.
0
.
data_start
.
get
(
)
.
unwrap_or
(
&
0
)
}
pub
const
fn
unix_mode
(
&
self
)
-
>
Option
<
u32
>
{
self
.
0
.
unix_mode
(
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
std
:
:
collections
:
:
BTreeSet
;
struct
DummyVisitor
;
impl
ZipStreamVisitor
for
DummyVisitor
{
fn
visit_file
(
&
mut
self
_file
:
&
mut
ZipFile
<
'
_
>
)
-
>
ZipResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
visit_additional_metadata
(
&
mut
self
_metadata
:
&
ZipStreamFileMetadata
)
-
>
ZipResult
<
(
)
>
{
Ok
(
(
)
)
}
}
#
[
derive
(
Default
Debug
Eq
PartialEq
)
]
struct
CounterVisitor
(
u64
u64
)
;
impl
ZipStreamVisitor
for
CounterVisitor
{
fn
visit_file
(
&
mut
self
_file
:
&
mut
ZipFile
<
'
_
>
)
-
>
ZipResult
<
(
)
>
{
self
.
0
+
=
1
;
Ok
(
(
)
)
}
fn
visit_additional_metadata
(
&
mut
self
_metadata
:
&
ZipStreamFileMetadata
)
-
>
ZipResult
<
(
)
>
{
self
.
1
+
=
1
;
Ok
(
(
)
)
}
}
#
[
test
]
fn
invalid_offset
(
)
{
ZipStreamReader
:
:
new
(
io
:
:
Cursor
:
:
new
(
include_bytes
!
(
"
.
.
/
.
.
/
tests
/
data
/
invalid_offset
.
zip
"
)
)
)
.
visit
(
&
mut
DummyVisitor
)
.
unwrap_err
(
)
;
}
#
[
test
]
fn
invalid_offset2
(
)
{
ZipStreamReader
:
:
new
(
io
:
:
Cursor
:
:
new
(
include_bytes
!
(
"
.
.
/
.
.
/
tests
/
data
/
invalid_offset2
.
zip
"
)
)
)
.
visit
(
&
mut
DummyVisitor
)
.
unwrap_err
(
)
;
}
#
[
test
]
fn
zip_read_streaming
(
)
{
let
reader
=
ZipStreamReader
:
:
new
(
io
:
:
Cursor
:
:
new
(
include_bytes
!
(
"
.
.
/
.
.
/
tests
/
data
/
mimetype
.
zip
"
)
)
)
;
#
[
derive
(
Default
)
]
struct
V
{
filenames
:
BTreeSet
<
Box
<
str
>
>
}
impl
ZipStreamVisitor
for
V
{
fn
visit_file
(
&
mut
self
file
:
&
mut
ZipFile
<
'
_
>
)
-
>
ZipResult
<
(
)
>
{
if
file
.
is_file
(
)
{
self
.
filenames
.
insert
(
file
.
name
(
)
.
into
(
)
)
;
}
Ok
(
(
)
)
}
fn
visit_additional_metadata
(
&
mut
self
metadata
:
&
ZipStreamFileMetadata
)
-
>
ZipResult
<
(
)
>
{
if
metadata
.
is_file
(
)
{
assert
!
(
self
.
filenames
.
contains
(
metadata
.
name
(
)
)
"
{
}
is
missing
its
file
content
"
metadata
.
name
(
)
)
;
}
Ok
(
(
)
)
}
}
reader
.
visit
(
&
mut
V
:
:
default
(
)
)
.
unwrap
(
)
;
}
#
[
test
]
fn
file_and_dir_predicates
(
)
{
let
reader
=
ZipStreamReader
:
:
new
(
io
:
:
Cursor
:
:
new
(
include_bytes
!
(
"
.
.
/
.
.
/
tests
/
data
/
files_and_dirs
.
zip
"
)
)
)
;
#
[
derive
(
Default
)
]
struct
V
{
filenames
:
BTreeSet
<
Box
<
str
>
>
}
impl
ZipStreamVisitor
for
V
{
fn
visit_file
(
&
mut
self
file
:
&
mut
ZipFile
<
'
_
>
)
-
>
ZipResult
<
(
)
>
{
let
full_name
=
file
.
enclosed_name
(
)
.
unwrap
(
)
;
let
file_name
=
full_name
.
file_name
(
)
.
unwrap
(
)
.
to_str
(
)
.
unwrap
(
)
;
assert
!
(
(
file_name
.
starts_with
(
"
dir
"
)
&
&
file
.
is_dir
(
)
)
|
|
(
file_name
.
starts_with
(
"
file
"
)
&
&
file
.
is_file
(
)
)
)
;
if
file
.
is_file
(
)
{
self
.
filenames
.
insert
(
file
.
name
(
)
.
into
(
)
)
;
}
Ok
(
(
)
)
}
fn
visit_additional_metadata
(
&
mut
self
metadata
:
&
ZipStreamFileMetadata
)
-
>
ZipResult
<
(
)
>
{
if
metadata
.
is_file
(
)
{
assert
!
(
self
.
filenames
.
contains
(
metadata
.
name
(
)
)
"
{
}
is
missing
its
file
content
"
metadata
.
name
(
)
)
;
}
Ok
(
(
)
)
}
}
reader
.
visit
(
&
mut
V
:
:
default
(
)
)
.
unwrap
(
)
;
}
#
[
test
]
fn
invalid_cde_number_of_files_allocation_smaller_offset
(
)
{
ZipStreamReader
:
:
new
(
io
:
:
Cursor
:
:
new
(
include_bytes
!
(
"
.
.
/
.
.
/
tests
/
data
/
invalid_cde_number_of_files_allocation_smaller_offset
.
zip
"
)
)
)
.
visit
(
&
mut
DummyVisitor
)
.
unwrap_err
(
)
;
}
#
[
test
]
fn
invalid_cde_number_of_files_allocation_greater_offset
(
)
{
ZipStreamReader
:
:
new
(
io
:
:
Cursor
:
:
new
(
include_bytes
!
(
"
.
.
/
.
.
/
tests
/
data
/
invalid_cde_number_of_files_allocation_greater_offset
.
zip
"
)
)
)
.
visit
(
&
mut
DummyVisitor
)
.
unwrap_err
(
)
;
}
}
