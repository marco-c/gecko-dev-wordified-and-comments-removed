use
crate
:
:
convert
:
:
*
;
use
crate
:
:
operations
:
:
folded_multiply
;
use
crate
:
:
operations
:
:
read_small
;
use
crate
:
:
operations
:
:
MULTIPLE
;
use
crate
:
:
random_state
:
:
PI
;
use
crate
:
:
RandomState
;
use
core
:
:
hash
:
:
Hasher
;
const
ROT
:
u32
=
23
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
AHasher
{
buffer
:
u64
pad
:
u64
extra_keys
:
[
u64
;
2
]
}
impl
AHasher
{
#
[
inline
]
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
new_with_keys
(
key1
:
u128
key2
:
u128
)
-
>
AHasher
{
let
pi
:
[
u128
;
2
]
=
PI
.
convert
(
)
;
let
key1
:
[
u64
;
2
]
=
(
key1
^
pi
[
0
]
)
.
convert
(
)
;
let
key2
:
[
u64
;
2
]
=
(
key2
^
pi
[
1
]
)
.
convert
(
)
;
AHasher
{
buffer
:
key1
[
0
]
pad
:
key1
[
1
]
extra_keys
:
key2
}
}
#
[
allow
(
unused
)
]
pub
(
crate
)
fn
test_with_keys
(
key1
:
u128
key2
:
u128
)
-
>
Self
{
let
key1
:
[
u64
;
2
]
=
key1
.
convert
(
)
;
let
key2
:
[
u64
;
2
]
=
key2
.
convert
(
)
;
Self
{
buffer
:
key1
[
0
]
pad
:
key1
[
1
]
extra_keys
:
key2
}
}
#
[
inline
]
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
from_random_state
(
rand_state
:
&
RandomState
)
-
>
AHasher
{
AHasher
{
buffer
:
rand_state
.
k1
pad
:
rand_state
.
k0
extra_keys
:
[
rand_state
.
k2
rand_state
.
k3
]
}
}
#
[
inline
(
always
)
]
fn
update
(
&
mut
self
new_data
:
u64
)
{
self
.
buffer
=
folded_multiply
(
new_data
^
self
.
buffer
MULTIPLE
)
;
}
#
[
inline
(
always
)
]
fn
large_update
(
&
mut
self
new_data
:
u128
)
{
let
block
:
[
u64
;
2
]
=
new_data
.
convert
(
)
;
let
combined
=
folded_multiply
(
block
[
0
]
^
self
.
extra_keys
[
0
]
block
[
1
]
^
self
.
extra_keys
[
1
]
)
;
self
.
buffer
=
(
self
.
buffer
.
wrapping_add
(
self
.
pad
)
^
combined
)
.
rotate_left
(
ROT
)
;
}
#
[
inline
]
#
[
cfg
(
feature
=
"
specialize
"
)
]
fn
short_finish
(
&
self
)
-
>
u64
{
folded_multiply
(
self
.
buffer
self
.
pad
)
}
}
impl
Hasher
for
AHasher
{
#
[
inline
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u16
(
&
mut
self
i
:
u16
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u128
(
&
mut
self
i
:
u128
)
{
self
.
large_update
(
i
)
;
}
#
[
inline
]
#
[
cfg
(
any
(
target_pointer_width
=
"
64
"
target_pointer_width
=
"
32
"
target_pointer_width
=
"
16
"
)
)
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
#
[
cfg
(
target_pointer_width
=
"
128
"
)
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
self
.
write_u128
(
i
as
u128
)
;
}
#
[
inline
]
#
[
allow
(
clippy
:
:
collapsible_if
)
]
fn
write
(
&
mut
self
input
:
&
[
u8
]
)
{
let
mut
data
=
input
;
let
length
=
data
.
len
(
)
as
u64
;
self
.
buffer
=
self
.
buffer
.
wrapping_add
(
length
)
.
wrapping_mul
(
MULTIPLE
)
;
if
data
.
len
(
)
>
8
{
if
data
.
len
(
)
>
16
{
let
tail
=
data
.
read_last_u128
(
)
;
self
.
large_update
(
tail
)
;
while
data
.
len
(
)
>
16
{
let
(
block
rest
)
=
data
.
read_u128
(
)
;
self
.
large_update
(
block
)
;
data
=
rest
;
}
}
else
{
self
.
large_update
(
[
data
.
read_u64
(
)
.
0
data
.
read_last_u64
(
)
]
.
convert
(
)
)
;
}
}
else
{
let
value
=
read_small
(
data
)
;
self
.
large_update
(
value
.
convert
(
)
)
;
}
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
let
rot
=
(
self
.
buffer
&
63
)
as
u32
;
folded_multiply
(
self
.
buffer
self
.
pad
)
.
rotate_left
(
rot
)
}
}
#
[
cfg
(
feature
=
"
specialize
"
)
]
pub
(
crate
)
struct
AHasherU64
{
pub
(
crate
)
buffer
:
u64
pub
(
crate
)
pad
:
u64
}
#
[
cfg
(
feature
=
"
specialize
"
)
]
impl
Hasher
for
AHasherU64
{
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
folded_multiply
(
self
.
buffer
self
.
pad
)
}
#
[
inline
]
fn
write
(
&
mut
self
_bytes
:
&
[
u8
]
)
{
unreachable
!
(
"
Specialized
hasher
was
called
with
a
different
type
of
object
"
)
}
#
[
inline
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u16
(
&
mut
self
i
:
u16
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
self
.
buffer
=
folded_multiply
(
i
^
self
.
buffer
MULTIPLE
)
;
}
#
[
inline
]
fn
write_u128
(
&
mut
self
_i
:
u128
)
{
unreachable
!
(
"
Specialized
hasher
was
called
with
a
different
type
of
object
"
)
}
#
[
inline
]
fn
write_usize
(
&
mut
self
_i
:
usize
)
{
unreachable
!
(
"
Specialized
hasher
was
called
with
a
different
type
of
object
"
)
}
}
#
[
cfg
(
feature
=
"
specialize
"
)
]
pub
(
crate
)
struct
AHasherFixed
(
pub
AHasher
)
;
#
[
cfg
(
feature
=
"
specialize
"
)
]
impl
Hasher
for
AHasherFixed
{
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
0
.
short_finish
(
)
}
#
[
inline
]
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
{
self
.
0
.
write
(
bytes
)
}
#
[
inline
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u16
(
&
mut
self
i
:
u16
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
self
.
0
.
write_u64
(
i
)
;
}
#
[
inline
]
fn
write_u128
(
&
mut
self
i
:
u128
)
{
self
.
0
.
write_u128
(
i
)
;
}
#
[
inline
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
self
.
0
.
write_usize
(
i
)
;
}
}
#
[
cfg
(
feature
=
"
specialize
"
)
]
pub
(
crate
)
struct
AHasherStr
(
pub
AHasher
)
;
#
[
cfg
(
feature
=
"
specialize
"
)
]
impl
Hasher
for
AHasherStr
{
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
0
.
finish
(
)
}
#
[
inline
]
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
{
if
bytes
.
len
(
)
>
8
{
self
.
0
.
write
(
bytes
)
}
else
{
let
value
=
read_small
(
bytes
)
;
self
.
0
.
buffer
=
folded_multiply
(
value
[
0
]
^
self
.
0
.
buffer
value
[
1
]
^
self
.
0
.
extra_keys
[
1
]
)
;
self
.
0
.
pad
=
self
.
0
.
pad
.
wrapping_add
(
bytes
.
len
(
)
as
u64
)
;
}
}
#
[
inline
]
fn
write_u8
(
&
mut
self
_i
:
u8
)
{
}
#
[
inline
]
fn
write_u16
(
&
mut
self
_i
:
u16
)
{
}
#
[
inline
]
fn
write_u32
(
&
mut
self
_i
:
u32
)
{
}
#
[
inline
]
fn
write_u64
(
&
mut
self
_i
:
u64
)
{
}
#
[
inline
]
fn
write_u128
(
&
mut
self
_i
:
u128
)
{
}
#
[
inline
]
fn
write_usize
(
&
mut
self
_i
:
usize
)
{
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
fallback_hash
:
:
*
;
#
[
test
]
fn
test_hash
(
)
{
let
mut
hasher
=
AHasher
:
:
new_with_keys
(
0
0
)
;
let
value
:
u64
=
1
<
<
32
;
hasher
.
update
(
value
)
;
let
result
=
hasher
.
buffer
;
let
mut
hasher
=
AHasher
:
:
new_with_keys
(
0
0
)
;
let
value2
:
u64
=
1
;
hasher
.
update
(
value2
)
;
let
result2
=
hasher
.
buffer
;
let
result
:
[
u8
;
8
]
=
result
.
convert
(
)
;
let
result2
:
[
u8
;
8
]
=
result2
.
convert
(
)
;
assert_ne
!
(
hex
:
:
encode
(
result
)
hex
:
:
encode
(
result2
)
)
;
}
#
[
test
]
fn
test_conversion
(
)
{
let
input
:
&
[
u8
]
=
"
dddddddd
"
.
as_bytes
(
)
;
let
bytes
:
u64
=
as_array
!
(
input
8
)
.
convert
(
)
;
assert_eq
!
(
bytes
0x6464646464646464
)
;
}
}
