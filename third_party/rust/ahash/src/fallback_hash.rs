use
crate
:
:
convert
:
:
*
;
use
crate
:
:
operations
:
:
folded_multiply
;
#
[
cfg
(
feature
=
"
specialize
"
)
]
use
crate
:
:
HasherExt
;
use
core
:
:
hash
:
:
Hasher
;
pub
(
crate
)
const
MULTIPLE
:
u64
=
6364136223846793005
;
const
ROT
:
u32
=
23
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
AHasher
{
buffer
:
u64
pad
:
u64
extra_keys
:
[
u64
;
2
]
}
impl
AHasher
{
#
[
inline
]
#
[
allow
(
dead_code
)
]
pub
fn
new_with_keys
(
key1
:
u128
key2
:
u128
)
-
>
AHasher
{
AHasher
{
buffer
:
key1
as
u64
pad
:
key2
as
u64
extra_keys
:
(
key1
^
key2
)
.
convert
(
)
}
}
#
[
cfg
(
test
)
]
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
test_with_keys
(
key1
:
u64
key2
:
u64
)
-
>
AHasher
{
use
crate
:
:
random_state
:
:
scramble_keys
;
let
(
k1
k2
k3
k4
)
=
scramble_keys
(
key1
key2
)
;
AHasher
{
buffer
:
k1
pad
:
k2
extra_keys
:
[
k3
k4
]
}
}
#
[
inline
(
always
)
]
fn
update
(
&
mut
self
new_data
:
u64
)
{
self
.
buffer
=
folded_multiply
(
new_data
^
self
.
buffer
MULTIPLE
)
;
}
#
[
inline
(
always
)
]
fn
large_update
(
&
mut
self
new_data
:
u128
)
{
let
block
:
[
u64
;
2
]
=
new_data
.
convert
(
)
;
let
combined
=
folded_multiply
(
block
[
0
]
^
self
.
extra_keys
[
0
]
block
[
1
]
^
self
.
extra_keys
[
1
]
)
;
self
.
buffer
=
(
combined
.
wrapping_add
(
self
.
buffer
)
^
self
.
pad
)
.
rotate_left
(
ROT
)
;
}
}
#
[
cfg
(
feature
=
"
specialize
"
)
]
impl
HasherExt
for
AHasher
{
#
[
inline
]
fn
hash_u64
(
self
value
:
u64
)
-
>
u64
{
let
rot
=
(
self
.
pad
&
64
)
as
u32
;
folded_multiply
(
value
^
self
.
buffer
MULTIPLE
)
.
rotate_left
(
rot
)
}
#
[
inline
]
fn
short_finish
(
&
self
)
-
>
u64
{
self
.
buffer
.
wrapping_add
(
self
.
pad
)
}
}
impl
Hasher
for
AHasher
{
#
[
inline
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u16
(
&
mut
self
i
:
u16
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
self
.
update
(
i
as
u64
)
;
}
#
[
inline
]
fn
write_u128
(
&
mut
self
i
:
u128
)
{
let
data
:
[
u64
;
2
]
=
i
.
convert
(
)
;
self
.
update
(
data
[
0
]
)
;
self
.
update
(
data
[
1
]
)
;
}
#
[
inline
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
self
.
write_u64
(
i
as
u64
)
;
}
#
[
inline
]
#
[
allow
(
clippy
:
:
collapsible_if
)
]
fn
write
(
&
mut
self
input
:
&
[
u8
]
)
{
let
mut
data
=
input
;
let
length
=
data
.
len
(
)
as
u64
;
self
.
buffer
=
self
.
buffer
.
wrapping_add
(
length
)
.
wrapping_mul
(
MULTIPLE
)
;
if
data
.
len
(
)
>
8
{
if
data
.
len
(
)
>
16
{
let
tail
=
data
.
read_last_u128
(
)
;
self
.
large_update
(
tail
)
;
while
data
.
len
(
)
>
16
{
let
(
block
rest
)
=
data
.
read_u128
(
)
;
self
.
large_update
(
block
)
;
data
=
rest
;
}
}
else
{
self
.
large_update
(
[
data
.
read_u64
(
)
.
0
data
.
read_last_u64
(
)
]
.
convert
(
)
)
;
}
}
else
{
if
data
.
len
(
)
>
=
2
{
if
data
.
len
(
)
>
=
4
{
let
block
=
[
data
.
read_u32
(
)
.
0
as
u64
data
.
read_last_u32
(
)
as
u64
]
;
self
.
large_update
(
block
.
convert
(
)
)
;
}
else
{
let
value
=
[
data
.
read_u16
(
)
.
0
as
u32
data
[
data
.
len
(
)
-
1
]
as
u32
]
;
self
.
update
(
value
.
convert
(
)
)
;
}
}
else
{
if
data
.
len
(
)
>
0
{
self
.
update
(
data
[
0
]
as
u64
)
;
}
}
}
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
let
rot
=
(
self
.
buffer
&
63
)
as
u32
;
folded_multiply
(
self
.
buffer
self
.
pad
)
.
rotate_left
(
rot
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
convert
:
:
Convert
;
use
crate
:
:
fallback_hash
:
:
*
;
#
[
test
]
fn
test_hash
(
)
{
let
mut
hasher
=
AHasher
:
:
new_with_keys
(
0
0
)
;
let
value
:
u64
=
1
<
<
32
;
hasher
.
update
(
value
)
;
let
result
=
hasher
.
buffer
;
let
mut
hasher
=
AHasher
:
:
new_with_keys
(
0
0
)
;
let
value2
:
u64
=
1
;
hasher
.
update
(
value2
)
;
let
result2
=
hasher
.
buffer
;
let
result
:
[
u8
;
8
]
=
result
.
convert
(
)
;
let
result2
:
[
u8
;
8
]
=
result2
.
convert
(
)
;
assert_ne
!
(
hex
:
:
encode
(
result
)
hex
:
:
encode
(
result2
)
)
;
}
#
[
test
]
fn
test_conversion
(
)
{
let
input
:
&
[
u8
]
=
"
dddddddd
"
.
as_bytes
(
)
;
let
bytes
:
u64
=
as_array
!
(
input
8
)
.
convert
(
)
;
assert_eq
!
(
bytes
0x6464646464646464
)
;
}
}
