use
crate
:
:
{
FrameSymbolizer
FrameWalker
Module
SymbolError
}
;
pub
use
crate
:
:
sym_file
:
:
types
:
:
*
;
pub
use
parser
:
:
SymbolParser
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
path
:
:
Path
;
use
tracing
:
:
trace
;
mod
parser
;
mod
types
;
pub
mod
walker
;
static
MAX_BUFFER_CAPACITY
:
usize
=
1024
*
160
;
static
INITIAL_BUFFER_CAPACITY
:
usize
=
1024
*
10
;
impl
SymbolFile
{
pub
fn
parse
<
R
:
Read
>
(
mut
input_reader
:
R
mut
callback
:
impl
FnMut
(
&
[
u8
]
)
)
-
>
Result
<
SymbolFile
SymbolError
>
{
let
mut
buf
=
circular
:
:
Buffer
:
:
with_capacity
(
INITIAL_BUFFER_CAPACITY
)
;
let
mut
parser
=
SymbolParser
:
:
new
(
)
;
let
mut
fully_consumed
=
false
;
let
mut
tried_to_grow
=
false
;
let
mut
in_panic_recovery
=
false
;
let
mut
just_finished_recovering
=
false
;
let
mut
total_consumed
=
0u64
;
loop
{
if
in_panic_recovery
{
let
input
=
buf
.
data
(
)
;
if
let
Some
(
new_line_idx
)
=
input
.
iter
(
)
.
position
(
|
&
byte
|
byte
=
=
b
'
\
n
'
)
{
let
amount
=
new_line_idx
+
1
;
callback
(
&
input
[
.
.
amount
]
)
;
buf
.
consume
(
amount
)
;
total_consumed
+
=
amount
as
u64
;
in_panic_recovery
=
false
;
fully_consumed
=
false
;
just_finished_recovering
=
true
;
parser
.
lines
+
=
1
;
trace
!
(
"
RECOVERY
:
complete
!
"
)
;
}
else
{
let
amount
=
input
.
len
(
)
;
callback
(
&
input
[
.
.
amount
]
)
;
buf
.
consume
(
amount
)
;
total_consumed
+
=
amount
as
u64
;
fully_consumed
=
true
;
}
}
let
size
=
input_reader
.
read
(
buf
.
space
(
)
)
?
;
buf
.
fill
(
size
)
;
if
size
=
=
0
{
if
just_finished_recovering
&
&
!
buf
.
data
(
)
.
is_empty
(
)
{
}
else
if
fully_consumed
{
return
Ok
(
parser
.
finish
(
)
)
;
}
else
if
!
tried_to_grow
{
let
new_cap
=
buf
.
capacity
(
)
.
saturating_mul
(
2
)
;
if
new_cap
>
MAX_BUFFER_CAPACITY
{
trace
!
(
"
RECOVERY
:
discarding
enormous
line
{
}
"
parser
.
lines
)
;
in_panic_recovery
=
true
;
continue
;
}
trace
!
(
"
parser
out
of
space
?
trying
more
(
{
}
KB
)
"
new_cap
/
1024
)
;
buf
.
grow
(
new_cap
)
;
tried_to_grow
=
true
;
continue
;
}
else
if
total_consumed
=
=
0
{
return
Err
(
SymbolError
:
:
ParseError
(
"
empty
SymbolFile
(
probably
something
wrong
with
your
debuginfo
tooling
?
)
"
0
)
)
;
}
else
{
return
Err
(
SymbolError
:
:
ParseError
(
"
unexpected
EOF
during
parsing
of
SymbolFile
(
or
a
line
was
too
long
?
)
"
parser
.
lines
)
)
;
}
}
else
{
tried_to_grow
=
false
;
}
if
in_panic_recovery
{
continue
;
}
just_finished_recovering
=
false
;
let
input
=
buf
.
data
(
)
;
let
consumed
=
parser
.
parse_more
(
input
)
?
;
total_consumed
+
=
consumed
as
u64
;
callback
(
&
input
[
.
.
consumed
]
)
;
fully_consumed
=
input
.
len
(
)
=
=
consumed
;
buf
.
consume
(
consumed
)
;
}
}
#
[
cfg
(
feature
=
"
http
"
)
]
pub
async
fn
parse_async
(
mut
response
:
reqwest
:
:
Response
mut
callback
:
impl
FnMut
(
&
[
u8
]
)
)
-
>
Result
<
SymbolFile
SymbolError
>
{
let
mut
chunk
;
let
mut
slice
=
&
[
]
[
.
.
]
;
let
mut
input_reader
=
&
mut
slice
;
let
mut
buf
=
circular
:
:
Buffer
:
:
with_capacity
(
INITIAL_BUFFER_CAPACITY
)
;
let
mut
parser
=
SymbolParser
:
:
new
(
)
;
let
mut
fully_consumed
=
false
;
let
mut
tried_to_grow
=
false
;
let
mut
in_panic_recovery
=
false
;
let
mut
just_finished_recovering
=
false
;
let
mut
total_consumed
=
0u64
;
loop
{
if
in_panic_recovery
{
let
input
=
buf
.
data
(
)
;
if
let
Some
(
new_line_idx
)
=
input
.
iter
(
)
.
position
(
|
&
byte
|
byte
=
=
b
'
\
n
'
)
{
let
amount
=
new_line_idx
+
1
;
callback
(
&
input
[
.
.
amount
]
)
;
buf
.
consume
(
amount
)
;
total_consumed
+
=
amount
as
u64
;
in_panic_recovery
=
false
;
fully_consumed
=
false
;
just_finished_recovering
=
true
;
parser
.
lines
+
=
1
;
trace
!
(
"
PANIC
RECOVERY
:
complete
!
"
)
;
}
else
{
let
amount
=
input
.
len
(
)
;
callback
(
&
input
[
.
.
amount
]
)
;
buf
.
consume
(
amount
)
;
total_consumed
+
=
amount
as
u64
;
fully_consumed
=
true
;
}
}
if
input_reader
.
is_empty
(
)
{
chunk
=
response
.
chunk
(
)
.
await
.
map_err
(
|
e
|
std
:
:
io
:
:
Error
:
:
new
(
std
:
:
io
:
:
ErrorKind
:
:
Other
e
)
)
?
.
unwrap_or_default
(
)
;
slice
=
&
chunk
[
.
.
]
;
input_reader
=
&
mut
slice
;
}
let
size
=
input_reader
.
read
(
buf
.
space
(
)
)
?
;
buf
.
fill
(
size
)
;
if
size
=
=
0
{
if
just_finished_recovering
&
&
!
buf
.
data
(
)
.
is_empty
(
)
{
}
else
if
fully_consumed
{
return
Ok
(
parser
.
finish
(
)
)
;
}
else
if
!
tried_to_grow
{
let
new_cap
=
buf
.
capacity
(
)
.
saturating_mul
(
2
)
;
if
new_cap
>
MAX_BUFFER_CAPACITY
{
trace
!
(
"
RECOVERY
:
discarding
enormous
line
{
}
"
parser
.
lines
)
;
in_panic_recovery
=
true
;
continue
;
}
trace
!
(
"
parser
out
of
space
?
trying
more
(
{
}
KB
)
"
new_cap
/
1024
)
;
buf
.
grow
(
new_cap
)
;
tried_to_grow
=
true
;
continue
;
}
else
if
total_consumed
=
=
0
{
return
Err
(
SymbolError
:
:
ParseError
(
"
empty
SymbolFile
(
probably
something
wrong
with
your
debuginfo
tooling
?
)
"
0
)
)
;
}
else
{
return
Err
(
SymbolError
:
:
ParseError
(
"
unexpected
EOF
during
parsing
of
SymbolFile
(
or
a
line
was
too
long
?
)
"
parser
.
lines
)
)
;
}
}
else
{
tried_to_grow
=
false
;
}
if
in_panic_recovery
{
continue
;
}
just_finished_recovering
=
false
;
let
input
=
buf
.
data
(
)
;
let
consumed
=
parser
.
parse_more
(
input
)
?
;
total_consumed
+
=
consumed
as
u64
;
callback
(
&
input
[
.
.
consumed
]
)
;
fully_consumed
=
input
.
len
(
)
=
=
consumed
;
buf
.
consume
(
consumed
)
;
}
}
pub
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
SymbolFile
SymbolError
>
{
Self
:
:
parse
(
bytes
|
_
|
(
)
)
}
pub
fn
from_file
(
path
:
&
Path
)
-
>
Result
<
SymbolFile
SymbolError
>
{
let
file
=
File
:
:
open
(
path
)
?
;
Self
:
:
parse
(
file
|
_
|
(
)
)
}
pub
fn
fill_symbol
(
&
self
module
:
&
dyn
Module
frame
:
&
mut
dyn
FrameSymbolizer
)
{
if
frame
.
get_instruction
(
)
<
module
.
base_address
(
)
{
return
;
}
let
addr
=
frame
.
get_instruction
(
)
-
module
.
base_address
(
)
;
if
let
Some
(
func
)
=
self
.
functions
.
get
(
addr
)
{
let
parameter_size
=
if
let
Some
(
info
)
=
self
.
win_stack_framedata_info
.
get
(
addr
)
{
info
.
parameter_size
}
else
if
let
Some
(
info
)
=
self
.
win_stack_fpo_info
.
get
(
addr
)
{
info
.
parameter_size
}
else
{
func
.
parameter_size
}
;
frame
.
set_function
(
&
func
.
name
func
.
address
+
module
.
base_address
(
)
parameter_size
)
;
if
let
Some
(
(
file_id
line
address
next_inline_origin
)
)
=
func
.
get_outermost_sourceloc
(
addr
)
{
if
let
Some
(
file
)
=
self
.
files
.
get
(
&
file_id
)
{
frame
.
set_source_file
(
file
line
address
+
module
.
base_address
(
)
)
;
}
if
let
Some
(
mut
inline_origin
)
=
next_inline_origin
{
for
depth
in
1
.
.
{
match
func
.
get_inlinee_at_depth
(
depth
addr
)
{
Some
(
(
call_file_id
call_line
_address
next_inline_origin
)
)
=
>
{
let
call_file
=
self
.
files
.
get
(
&
call_file_id
)
.
map
(
Deref
:
:
deref
)
;
if
let
Some
(
name
)
=
self
.
inline_origins
.
get
(
&
inline_origin
)
{
frame
.
add_inline_frame
(
name
call_file
Some
(
call_line
)
)
;
}
inline_origin
=
next_inline_origin
;
}
None
=
>
break
}
}
let
(
file
line
)
=
match
func
.
get_innermost_sourceloc
(
addr
)
{
Some
(
(
file_id
line
_
)
)
=
>
(
self
.
files
.
get
(
&
file_id
)
.
map
(
Deref
:
:
deref
)
if
line
!
=
0
{
Some
(
line
)
}
else
{
None
}
)
None
=
>
(
None
None
)
}
;
if
let
Some
(
name
)
=
self
.
inline_origins
.
get
(
&
inline_origin
)
{
frame
.
add_inline_frame
(
name
file
line
)
;
}
}
}
}
else
if
let
Some
(
public
)
=
self
.
find_nearest_public
(
addr
)
{
let
funcs_slice
=
self
.
functions
.
ranges_values
(
)
.
as_slice
(
)
;
let
prev_func
=
funcs_slice
.
binary_search_by_key
(
&
addr
|
(
range
_
)
|
range
.
start
)
.
err
(
)
.
and_then
(
|
idx
|
idx
.
checked_sub
(
1
)
)
.
and_then
(
|
idx
|
funcs_slice
.
get
(
idx
)
)
;
if
let
Some
(
prev_func
)
=
prev_func
{
if
public
.
address
<
=
prev_func
.
1
.
address
{
return
;
}
}
frame
.
set_function
(
&
public
.
name
public
.
address
+
module
.
base_address
(
)
public
.
parameter_size
)
;
}
}
pub
fn
walk_frame
(
&
self
module
:
&
dyn
Module
walker
:
&
mut
dyn
FrameWalker
)
-
>
Option
<
(
)
>
{
if
walker
.
get_instruction
(
)
<
module
.
base_address
(
)
{
return
None
;
}
let
addr
=
walker
.
get_instruction
(
)
-
module
.
base_address
(
)
;
let
win_stack_result
=
if
let
Some
(
info
)
=
self
.
win_stack_framedata_info
.
get
(
addr
)
{
walker
:
:
walk_with_stack_win_framedata
(
info
walker
)
}
else
if
let
Some
(
info
)
=
self
.
win_stack_fpo_info
.
get
(
addr
)
{
walker
:
:
walk_with_stack_win_fpo
(
info
walker
)
}
else
{
None
}
;
win_stack_result
.
or_else
(
|
|
{
if
let
Some
(
info
)
=
self
.
cfi_stack_info
.
get
(
addr
)
{
let
mut
count
=
0
;
let
len
=
info
.
add_rules
.
len
(
)
;
while
count
<
len
&
&
info
.
add_rules
[
count
]
.
address
<
=
addr
{
count
+
=
1
;
}
walker
:
:
walk_with_stack_cfi
(
&
info
.
init
&
info
.
add_rules
[
0
.
.
count
]
walker
)
}
else
{
None
}
}
)
}
pub
fn
find_nearest_public
(
&
self
addr
:
u64
)
-
>
Option
<
&
PublicSymbol
>
{
self
.
publics
.
iter
(
)
.
rev
(
)
.
find
(
|
&
p
|
p
.
address
<
=
addr
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
std
:
:
ffi
:
:
OsStr
;
fn
test_symbolfile_from_file
(
rel_path
:
&
str
)
{
let
mut
path
=
std
:
:
env
:
:
current_dir
(
)
.
unwrap
(
)
;
if
path
.
file_name
(
)
=
=
Some
(
OsStr
:
:
new
(
"
rust
-
minidump
"
)
)
{
path
.
push
(
"
breakpad
-
symbols
"
)
;
}
path
.
push
(
rel_path
)
;
let
sym
=
SymbolFile
:
:
from_file
(
&
path
)
.
unwrap
(
)
;
assert_eq
!
(
sym
.
files
.
len
(
)
6661
)
;
assert_eq
!
(
sym
.
publics
.
len
(
)
5
)
;
assert_eq
!
(
sym
.
find_nearest_public
(
0x9b07
)
.
unwrap
(
)
.
name
"
_NLG_Return
"
)
;
assert_eq
!
(
sym
.
find_nearest_public
(
0x142e7
)
.
unwrap
(
)
.
name
"
_NLG_Return
"
)
;
assert_eq
!
(
sym
.
find_nearest_public
(
0x23b06
)
.
unwrap
(
)
.
name
"
__from_strstr_to_strchr
"
)
;
assert_eq
!
(
sym
.
find_nearest_public
(
0xFFFFFFFF
)
.
unwrap
(
)
.
name
"
__from_strstr_to_strchr
"
)
;
assert_eq
!
(
sym
.
functions
.
ranges_values
(
)
.
count
(
)
1065
)
;
assert_eq
!
(
sym
.
functions
.
get
(
0x1000
)
.
unwrap
(
)
.
name
"
vswprintf
"
)
;
assert_eq
!
(
sym
.
functions
.
get
(
0x1012
)
.
unwrap
(
)
.
name
"
vswprintf
"
)
;
assert
!
(
sym
.
functions
.
get
(
0x1013
)
.
is_none
(
)
)
;
assert_eq
!
(
sym
.
win_stack_framedata_info
.
ranges_values
(
)
.
count
(
)
1556
)
;
assert_eq
!
(
sym
.
win_stack_fpo_info
.
ranges_values
(
)
.
count
(
)
259
)
;
assert_eq
!
(
sym
.
win_stack_framedata_info
.
get
(
0x41b0
)
.
unwrap
(
)
.
address
0x41b0
)
;
}
#
[
test
]
fn
test_symbolfile_from_lf_file
(
)
{
test_symbolfile_from_file
(
"
testdata
/
symbols
/
test_app
.
pdb
/
5A9832E5287241C1838ED98914E9B7FF1
/
test_app
.
sym
"
)
;
}
#
[
test
]
fn
test_symbolfile_from_crlf_file
(
)
{
test_symbolfile_from_file
(
"
testdata
/
symbols
/
test_app
.
pdb
/
6A9832E5287241C1838ED98914E9B7FF1
/
test_app
.
sym
"
)
;
}
fn
test_symbolfile_from_bytes
(
symbolfile_bytes
:
&
[
u8
]
)
{
let
sym
=
SymbolFile
:
:
from_bytes
(
symbolfile_bytes
)
.
unwrap
(
)
;
assert_eq
!
(
sym
.
files
.
len
(
)
1
)
;
assert_eq
!
(
sym
.
publics
.
len
(
)
1
)
;
assert_eq
!
(
sym
.
functions
.
ranges_values
(
)
.
count
(
)
1
)
;
assert_eq
!
(
sym
.
functions
.
get
(
0x1000
)
.
unwrap
(
)
.
name
"
another
func
"
)
;
assert_eq
!
(
sym
.
functions
.
get
(
0x1000
)
.
unwrap
(
)
.
lines
.
ranges_values
(
)
.
count
(
)
1
)
;
assert_eq
!
(
sym
.
functions
.
get
(
0x1001
)
.
unwrap
(
)
.
name
"
another
func
"
)
;
}
#
[
test
]
fn
test_symbolfile_from_bytes_with_lf
(
)
{
test_symbolfile_from_bytes
(
b
"
MODULE
Linux
x86
ffff0000
bar
FILE
53
bar
.
c
PUBLIC
1234
10
some
public
FUNC
1000
30
10
another
func
1000
30
7
53
"
)
;
}
#
[
test
]
fn
test_symbolfile_from_bytes_with_crlf
(
)
{
test_symbolfile_from_bytes
(
b
"
MODULE
Linux
x86
ffff0000
bar
FILE
53
bar
.
c
PUBLIC
1234
10
some
public
FUNC
1000
30
10
another
func
1000
30
7
53
"
)
;
}
}
