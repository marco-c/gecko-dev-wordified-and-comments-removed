use
super
:
:
{
CfiRules
StackInfoWin
WinStackThing
}
;
use
crate
:
:
FrameWalker
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
str
:
:
FromStr
;
use
tracing
:
:
{
debug
trace
}
;
pub
fn
walk_with_stack_cfi
(
init
:
&
CfiRules
additional
:
&
[
CfiRules
]
walker
:
&
mut
dyn
FrameWalker
)
-
>
Option
<
(
)
>
{
trace
!
(
"
trying
STACK
CFI
exprs
"
)
;
trace
!
(
"
{
}
"
init
.
rules
)
;
for
line
in
additional
{
trace
!
(
"
{
}
"
line
.
rules
)
;
}
let
mut
exprs
=
HashMap
:
:
new
(
)
;
parse_cfi_exprs
(
&
init
.
rules
&
mut
exprs
)
?
;
for
line
in
additional
{
parse_cfi_exprs
(
&
line
.
rules
&
mut
exprs
)
?
;
}
trace
!
(
"
STACK
CFI
parse
successful
"
)
;
let
cfa_expr
=
exprs
.
remove
(
&
CfiReg
:
:
Cfa
)
?
;
let
ra_expr
=
exprs
.
remove
(
&
CfiReg
:
:
Ra
)
?
;
trace
!
(
"
STACK
CFI
seems
reasonable
evaluating
"
)
;
let
cfa
=
eval_cfi_expr
(
cfa_expr
walker
None
)
?
;
trace
!
(
"
successfully
evaluated
.
cfa
(
frame
address
)
"
)
;
let
ra
=
eval_cfi_expr
(
ra_expr
walker
Some
(
cfa
)
)
?
;
trace
!
(
"
successfully
evaluated
.
ra
(
return
address
)
"
)
;
walker
.
set_cfa
(
cfa
)
?
;
walker
.
set_ra
(
ra
)
?
;
for
(
reg
expr
)
in
exprs
{
if
let
CfiReg
:
:
Other
(
reg
)
=
reg
{
match
eval_cfi_expr
(
expr
walker
Some
(
cfa
)
)
{
Some
(
val
)
=
>
{
walker
.
set_caller_register
(
reg
val
)
;
trace
!
(
"
successfully
evaluated
{
}
"
reg
)
;
}
None
=
>
{
walker
.
clear_caller_register
(
reg
)
;
trace
!
(
"
optional
register
{
}
failed
to
evaluate
dropping
it
"
reg
)
;
}
}
}
else
{
unreachable
!
(
)
}
}
Some
(
(
)
)
}
fn
parse_cfi_exprs
<
'
a
>
(
input
:
&
'
a
str
output
:
&
mut
HashMap
<
CfiReg
<
'
a
>
&
'
a
str
>
)
-
>
Option
<
(
)
>
{
let
base_addr
=
input
.
as_ptr
(
)
as
usize
;
let
mut
cur_reg
=
None
;
let
mut
expr_first
:
Option
<
&
str
>
=
None
;
let
mut
expr_last
:
Option
<
&
str
>
=
None
;
for
token
in
input
.
split_ascii_whitespace
(
)
{
if
let
Some
(
token
)
=
token
.
strip_suffix
(
'
:
'
)
{
if
let
Some
(
reg
)
=
cur_reg
{
let
min_addr
=
expr_first
?
.
as_ptr
(
)
as
usize
;
let
max_addr
=
expr_last
?
.
as_ptr
(
)
as
usize
+
expr_last
?
.
len
(
)
;
let
expr
=
&
input
[
min_addr
-
base_addr
.
.
max_addr
-
base_addr
]
;
output
.
insert
(
reg
expr
)
;
expr_first
=
None
;
expr_last
=
None
;
}
cur_reg
=
if
token
=
=
"
.
cfa
"
{
Some
(
CfiReg
:
:
Cfa
)
}
else
if
token
=
=
"
.
ra
"
{
Some
(
CfiReg
:
:
Ra
)
}
else
if
let
Some
(
token
)
=
token
.
strip_prefix
(
'
'
)
{
Some
(
CfiReg
:
:
Other
(
token
)
)
}
else
{
Some
(
CfiReg
:
:
Other
(
token
)
)
}
;
}
else
{
cur_reg
.
as_ref
(
)
?
;
if
expr_first
.
is_none
(
)
{
expr_first
=
Some
(
token
)
;
}
expr_last
=
Some
(
token
)
;
}
}
let
min_addr
=
expr_first
?
.
as_ptr
(
)
as
usize
;
let
max_addr
=
expr_last
?
.
as_ptr
(
)
as
usize
+
expr_last
?
.
len
(
)
;
let
expr
=
&
input
[
min_addr
-
base_addr
.
.
max_addr
-
base_addr
]
;
output
.
insert
(
cur_reg
?
expr
)
;
Some
(
(
)
)
}
fn
eval_cfi_expr
(
expr
:
&
str
walker
:
&
mut
dyn
FrameWalker
cfa
:
Option
<
u64
>
)
-
>
Option
<
u64
>
{
let
mut
stack
:
Vec
<
u64
>
=
Vec
:
:
new
(
)
;
for
token
in
expr
.
split_ascii_whitespace
(
)
{
match
token
{
"
+
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
;
stack
.
push
(
lhs
.
wrapping_add
(
rhs
)
)
;
}
"
-
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
;
stack
.
push
(
lhs
.
wrapping_sub
(
rhs
)
)
;
}
"
*
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
;
stack
.
push
(
lhs
.
wrapping_mul
(
rhs
)
)
;
}
"
/
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
;
if
rhs
=
=
0
{
return
None
;
}
stack
.
push
(
lhs
.
wrapping_div
(
rhs
)
)
;
}
"
%
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
;
if
rhs
=
=
0
{
return
None
;
}
stack
.
push
(
lhs
.
wrapping_rem
(
rhs
)
)
;
}
"
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
;
if
rhs
=
=
0
|
|
!
rhs
.
is_power_of_two
(
)
{
return
None
;
}
stack
.
push
(
lhs
&
(
-
1i64
as
u64
^
(
rhs
-
1
)
)
)
}
"
^
"
=
>
{
let
ptr
=
stack
.
pop
(
)
?
;
stack
.
push
(
walker
.
get_register_at_address
(
ptr
)
?
)
;
}
"
.
cfa
"
=
>
{
stack
.
push
(
cfa
?
)
;
}
"
.
undef
"
=
>
{
return
None
;
}
_
=
>
{
if
let
Some
(
(
_
reg
)
)
=
token
.
split_once
(
'
'
)
{
stack
.
push
(
walker
.
get_callee_register
(
reg
)
?
)
;
}
else
if
let
Ok
(
value
)
=
i64
:
:
from_str
(
token
)
{
stack
.
push
(
value
as
u64
)
}
else
if
let
Some
(
reg
)
=
walker
.
get_callee_register
(
token
)
{
stack
.
push
(
reg
)
;
}
else
{
debug
!
(
"
STACK
CFI
expression
eval
failed
-
unknown
token
:
{
}
"
token
)
;
return
None
;
}
}
}
}
if
stack
.
len
(
)
=
=
1
{
stack
.
pop
(
)
}
else
{
None
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
enum
CfiReg
<
'
a
>
{
Cfa
Ra
Other
(
&
'
a
str
)
}
#
[
cfg
(
feature
=
"
fuzz
"
)
]
pub
fn
eval_win_expr_for_fuzzer
(
expr
:
&
str
info
:
&
StackInfoWin
walker
:
&
mut
dyn
FrameWalker
)
-
>
Option
<
(
)
>
{
eval_win_expr
(
expr
info
walker
)
}
fn
eval_win_expr
(
expr
:
&
str
info
:
&
StackInfoWin
walker
:
&
mut
dyn
FrameWalker
)
-
>
Option
<
(
)
>
{
let
mut
vars
=
HashMap
:
:
new
(
)
;
let
callee_esp
=
walker
.
get_callee_register
(
"
esp
"
)
?
as
u32
;
let
callee_ebp
=
walker
.
get_callee_register
(
"
ebp
"
)
?
as
u32
;
let
grand_callee_param_size
=
walker
.
get_grand_callee_parameter_size
(
)
;
let
frame_size
=
win_frame_size
(
info
grand_callee_param_size
)
;
vars
.
insert
(
"
esp
"
callee_esp
)
;
vars
.
insert
(
"
ebp
"
callee_ebp
)
;
if
let
Some
(
callee_ebx
)
=
walker
.
get_callee_register
(
"
ebx
"
)
{
vars
.
insert
(
"
ebx
"
callee_ebx
as
u32
)
;
}
let
search_start
=
if
expr
.
contains
(
'
'
)
{
trace
!
(
"
program
used
operator
using
ebp
instead
of
esp
for
return
addr
"
)
;
callee_ebp
.
checked_add
(
4
)
?
}
else
{
callee_esp
.
checked_add
(
frame_size
)
?
}
;
trace
!
(
"
raSearchStart
=
0x
{
:
08x
}
(
0x
{
:
08x
}
0x
{
:
08x
}
0x
{
:
08x
}
)
"
search_start
grand_callee_param_size
info
.
local_size
info
.
saved_register_size
)
;
vars
.
insert
(
"
.
cbParams
"
info
.
parameter_size
)
;
vars
.
insert
(
"
.
cbCalleeParams
"
grand_callee_param_size
)
;
vars
.
insert
(
"
.
cbSavedRegs
"
info
.
saved_register_size
)
;
vars
.
insert
(
"
.
cbLocals
"
info
.
local_size
)
;
vars
.
insert
(
"
.
raSearch
"
search_start
)
;
vars
.
insert
(
"
.
raSearchStart
"
search_start
)
;
let
mut
stack
:
Vec
<
WinVal
>
=
Vec
:
:
new
(
)
;
let
tokens
=
expr
.
split_ascii_whitespace
(
)
.
flat_map
(
|
x
|
{
if
x
.
starts_with
(
'
=
'
)
&
&
x
.
len
(
)
>
1
{
[
Some
(
&
x
[
0
.
.
1
]
)
Some
(
&
x
[
1
.
.
]
)
]
}
else
{
[
Some
(
x
)
None
]
}
}
)
.
flatten
(
)
;
for
token
in
tokens
{
match
token
{
"
+
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
stack
.
push
(
WinVal
:
:
Int
(
lhs
.
wrapping_add
(
rhs
)
)
)
;
}
"
-
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
stack
.
push
(
WinVal
:
:
Int
(
lhs
.
wrapping_sub
(
rhs
)
)
)
;
}
"
*
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
stack
.
push
(
WinVal
:
:
Int
(
lhs
.
wrapping_mul
(
rhs
)
)
)
;
}
"
/
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
if
rhs
=
=
0
{
return
None
;
}
stack
.
push
(
WinVal
:
:
Int
(
lhs
.
wrapping_div
(
rhs
)
)
)
;
}
"
%
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
if
rhs
=
=
0
{
return
None
;
}
stack
.
push
(
WinVal
:
:
Int
(
lhs
.
wrapping_rem
(
rhs
)
)
)
;
}
"
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
if
rhs
=
=
0
|
|
!
rhs
.
is_power_of_two
(
)
{
return
None
;
}
stack
.
push
(
WinVal
:
:
Int
(
lhs
&
(
-
1i32
as
u32
^
(
rhs
-
1
)
)
)
)
;
}
"
=
"
=
>
{
let
rhs
=
stack
.
pop
(
)
?
;
let
lhs
=
stack
.
pop
(
)
?
.
into_var
(
)
?
;
if
let
WinVal
:
:
Undef
=
rhs
{
vars
.
remove
(
&
lhs
)
;
}
else
{
vars
.
insert
(
lhs
rhs
.
into_int
(
&
vars
)
?
)
;
}
}
"
^
"
=
>
{
let
ptr
=
stack
.
pop
(
)
?
.
into_int
(
&
vars
)
?
;
stack
.
push
(
WinVal
:
:
Int
(
walker
.
get_register_at_address
(
ptr
as
u64
)
?
as
u32
)
)
;
}
"
.
undef
"
=
>
{
stack
.
push
(
WinVal
:
:
Undef
)
;
}
_
=
>
{
if
token
=
=
"
.
undef
"
{
stack
.
push
(
WinVal
:
:
Undef
)
;
}
else
if
token
.
starts_with
(
'
'
)
|
|
token
.
starts_with
(
'
.
'
)
{
stack
.
push
(
WinVal
:
:
Var
(
token
)
)
;
}
else
if
let
Ok
(
value
)
=
i32
:
:
from_str
(
token
)
{
stack
.
push
(
WinVal
:
:
Int
(
value
as
u32
)
)
;
}
else
{
trace
!
(
"
STACK
WIN
expression
eval
failed
-
unknown
token
:
{
}
"
token
)
;
return
None
;
}
}
}
}
let
output_regs
=
[
"
eip
"
"
esp
"
"
ebp
"
"
ebx
"
"
esi
"
"
edi
"
]
;
for
reg
in
&
output_regs
{
if
let
Some
(
&
val
)
=
vars
.
get
(
reg
)
{
walker
.
set_caller_register
(
&
reg
[
1
.
.
]
val
as
u64
)
?
;
}
}
trace
!
(
"
STACK
WIN
expression
eval
succeeded
!
"
)
;
Some
(
(
)
)
}
fn
win_frame_size
(
info
:
&
StackInfoWin
grand_callee_param_size
:
u32
)
-
>
u32
{
info
.
local_size
+
info
.
saved_register_size
+
grand_callee_param_size
}
enum
WinVal
<
'
a
>
{
Var
(
&
'
a
str
)
Int
(
u32
)
Undef
}
impl
<
'
a
>
WinVal
<
'
a
>
{
fn
into_var
(
self
)
-
>
Option
<
&
'
a
str
>
{
if
let
WinVal
:
:
Var
(
var
)
=
self
{
Some
(
var
)
}
else
{
None
}
}
fn
into_int
(
self
map
:
&
HashMap
<
&
'
a
str
u32
>
)
-
>
Option
<
u32
>
{
match
self
{
WinVal
:
:
Var
(
var
)
=
>
map
.
get
(
&
var
)
.
cloned
(
)
WinVal
:
:
Int
(
int
)
=
>
Some
(
int
)
WinVal
:
:
Undef
=
>
None
}
}
}
pub
fn
walk_with_stack_win_framedata
(
info
:
&
StackInfoWin
walker
:
&
mut
dyn
FrameWalker
)
-
>
Option
<
(
)
>
{
if
let
WinStackThing
:
:
ProgramString
(
ref
expr
)
=
info
.
program_string_or_base_pointer
{
trace
!
(
"
trying
STACK
WIN
framedata
-
-
{
}
"
expr
)
;
clear_stack_win_caller_registers
(
walker
)
;
eval_win_expr
(
expr
info
walker
)
}
else
{
unreachable
!
(
)
}
}
pub
fn
walk_with_stack_win_fpo
(
info
:
&
StackInfoWin
walker
:
&
mut
dyn
FrameWalker
)
-
>
Option
<
(
)
>
{
if
let
WinStackThing
:
:
AllocatesBasePointer
(
allocates_base_pointer
)
=
info
.
program_string_or_base_pointer
{
trace
!
(
"
trying
STACK
WIN
fpo
"
)
;
clear_stack_win_caller_registers
(
walker
)
;
let
grand_callee_param_size
=
walker
.
get_grand_callee_parameter_size
(
)
;
let
frame_size
=
win_frame_size
(
info
grand_callee_param_size
)
as
u64
;
let
callee_esp
=
walker
.
get_callee_register
(
"
esp
"
)
?
;
let
mut
eip_address
=
callee_esp
+
frame_size
;
let
mut
caller_eip
=
walker
.
get_register_at_address
(
eip_address
)
?
;
let
callee_is_context_frame
=
!
walker
.
has_grand_callee
(
)
;
if
callee_is_context_frame
&
&
caller_eip
=
=
walker
.
get_callee_register
(
"
eip
"
)
?
{
eip_address
+
=
4
;
caller_eip
=
walker
.
get_register_at_address
(
eip_address
)
?
;
}
let
caller_esp
=
eip_address
+
4
;
trace
!
(
"
found
caller
eip
and
esp
"
)
;
let
caller_ebp
=
if
allocates_base_pointer
{
let
ebp_address
=
callee_esp
+
grand_callee_param_size
as
u64
+
info
.
saved_register_size
as
u64
-
8
;
walker
.
get_register_at_address
(
ebp_address
)
?
}
else
{
if
let
Some
(
callee_ebx
)
=
walker
.
get_callee_register
(
"
ebx
"
)
{
walker
.
set_caller_register
(
"
ebx
"
callee_ebx
)
?
;
}
walker
.
get_callee_register
(
"
ebp
"
)
?
}
;
trace
!
(
"
found
caller
ebp
"
)
;
walker
.
set_caller_register
(
"
eip
"
caller_eip
)
?
;
walker
.
set_caller_register
(
"
esp
"
caller_esp
)
?
;
walker
.
set_caller_register
(
"
ebp
"
caller_ebp
)
?
;
trace
!
(
"
STACK
WIN
fpo
eval
succeeded
!
"
)
;
Some
(
(
)
)
}
else
{
unreachable
!
(
)
}
}
fn
clear_stack_win_caller_registers
(
walker
:
&
mut
dyn
FrameWalker
)
{
let
output_regs
=
[
"
eip
"
"
esp
"
"
ebp
"
"
ebx
"
"
esi
"
"
edi
"
]
;
for
reg
in
output_regs
{
walker
.
clear_caller_register
(
reg
)
;
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
super
:
:
types
:
:
{
CfiRules
StackInfoWin
WinStackThing
}
;
use
super
:
:
{
eval_win_expr
walk_with_stack_cfi
walk_with_stack_win_fpo
}
;
use
crate
:
:
FrameWalker
;
use
std
:
:
collections
:
:
HashMap
;
static
STATIC_REGS
:
[
&
str
;
14
]
=
[
"
cfa
"
"
ra
"
"
esp
"
"
eip
"
"
ebp
"
"
eax
"
"
ebx
"
"
rsp
"
"
rip
"
"
rbp
"
"
rax
"
"
rbx
"
"
x11
"
"
x12
"
]
;
struct
TestFrameWalker
<
Reg
>
{
instruction
:
Reg
has_grand_callee
:
bool
grand_callee_param_size
:
u32
callee_regs
:
HashMap
<
&
'
static
str
Reg
>
caller_regs
:
HashMap
<
&
'
static
str
Reg
>
stack
:
Vec
<
u8
>
}
trait
Int
{
const
BYTES
:
usize
;
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
Self
;
fn
into_u64
(
self
)
-
>
u64
;
fn
from_u64
(
val
:
u64
)
-
>
Self
;
}
impl
Int
for
u32
{
const
BYTES
:
usize
=
4
;
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
Self
{
let
mut
buf
=
[
0
;
Self
:
:
BYTES
]
;
buf
.
copy_from_slice
(
bytes
)
;
u32
:
:
from_le_bytes
(
buf
)
}
fn
into_u64
(
self
)
-
>
u64
{
self
as
u64
}
fn
from_u64
(
val
:
u64
)
-
>
Self
{
val
as
u32
}
}
impl
Int
for
u64
{
const
BYTES
:
usize
=
8
;
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
Self
{
let
mut
buf
=
[
0
;
Self
:
:
BYTES
]
;
buf
.
copy_from_slice
(
bytes
)
;
u64
:
:
from_le_bytes
(
buf
)
}
fn
into_u64
(
self
)
-
>
u64
{
self
}
fn
from_u64
(
val
:
u64
)
-
>
Self
{
val
}
}
impl
<
Reg
:
Int
+
Copy
>
FrameWalker
for
TestFrameWalker
<
Reg
>
{
fn
get_instruction
(
&
self
)
-
>
u64
{
self
.
instruction
.
into_u64
(
)
}
fn
has_grand_callee
(
&
self
)
-
>
bool
{
self
.
has_grand_callee
}
fn
get_grand_callee_parameter_size
(
&
self
)
-
>
u32
{
self
.
grand_callee_param_size
}
fn
get_register_at_address
(
&
self
address
:
u64
)
-
>
Option
<
u64
>
{
let
addr
=
address
as
usize
;
self
.
stack
.
get
(
addr
.
.
addr
+
Reg
:
:
BYTES
)
.
map
(
|
slice
|
Reg
:
:
from_bytes
(
slice
)
.
into_u64
(
)
)
}
fn
get_callee_register
(
&
self
name
:
&
str
)
-
>
Option
<
u64
>
{
self
.
callee_regs
.
get
(
name
)
.
map
(
|
val
|
val
.
into_u64
(
)
)
}
fn
set_caller_register
(
&
mut
self
name
:
&
str
val
:
u64
)
-
>
Option
<
(
)
>
{
STATIC_REGS
.
iter
(
)
.
position
(
|
&
reg
|
reg
=
=
name
)
.
map
(
|
idx
|
{
let
memoized_reg
=
STATIC_REGS
[
idx
]
;
self
.
caller_regs
.
insert
(
memoized_reg
Reg
:
:
from_u64
(
val
)
)
;
}
)
}
fn
clear_caller_register
(
&
mut
self
name
:
&
str
)
{
self
.
caller_regs
.
remove
(
name
)
;
}
fn
set_cfa
(
&
mut
self
val
:
u64
)
-
>
Option
<
(
)
>
{
self
.
caller_regs
.
insert
(
"
cfa
"
Reg
:
:
from_u64
(
val
)
)
;
Some
(
(
)
)
}
fn
set_ra
(
&
mut
self
val
:
u64
)
-
>
Option
<
(
)
>
{
self
.
caller_regs
.
insert
(
"
ra
"
Reg
:
:
from_u64
(
val
)
)
;
Some
(
(
)
)
}
}
impl
<
Reg
:
Int
+
Copy
>
TestFrameWalker
<
Reg
>
{
fn
new
(
stack
:
Vec
<
u8
>
callee_regs
:
HashMap
<
&
'
static
str
Reg
>
)
-
>
Self
{
TestFrameWalker
{
stack
callee_regs
caller_regs
:
HashMap
:
:
new
(
)
instruction
:
Reg
:
:
from_u64
(
0xF1CEFA32
)
has_grand_callee
:
true
grand_callee_param_size
:
4
}
}
}
fn
whatever_win_info
(
)
-
>
StackInfoWin
{
StackInfoWin
{
address
:
0xFEA4A123
size
:
16
prologue_size
:
4
epilogue_size
:
8
parameter_size
:
16
saved_register_size
:
12
local_size
:
24
max_stack_size
:
64
program_string_or_base_pointer
:
WinStackThing
:
:
AllocatesBasePointer
(
false
)
}
}
fn
build_cfi_rules
(
init
:
&
str
additional
:
&
[
&
str
]
)
-
>
(
CfiRules
Vec
<
CfiRules
>
)
{
let
init
=
CfiRules
{
address
:
0
rules
:
init
.
to_string
(
)
}
;
let
additional
=
additional
.
iter
(
)
.
enumerate
(
)
.
map
(
|
(
idx
rules
)
|
CfiRules
{
address
:
idx
as
u64
+
1
rules
:
rules
.
to_string
(
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
(
init
additional
)
}
#
[
test
]
fn
test_stack_win_doc_example
(
)
{
let
expr
=
"
T0
ebp
=
eip
T0
4
+
^
=
ebp
T0
^
=
esp
T0
8
+
=
"
;
let
input
=
vec
!
[
(
"
ebp
"
16u32
)
(
"
esp
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
mut
stack
=
vec
!
[
0
;
1600
]
;
const
FINAL_EBP
:
u32
=
0xFA1EF2E6
;
const
FINAL_EIP
:
u32
=
0xB3EF04CE
;
stack
[
16
.
.
20
]
.
copy_from_slice
(
&
FINAL_EBP
.
to_le_bytes
(
)
)
;
stack
[
20
.
.
24
]
.
copy_from_slice
(
&
FINAL_EIP
.
to_le_bytes
(
)
)
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
info
=
whatever_win_info
(
)
;
eval_win_expr
(
expr
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
24
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
FINAL_EBP
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
eip
"
]
FINAL_EIP
)
;
}
#
[
test
]
fn
test_stack_win_ops
(
)
{
let
input
=
vec
!
[
(
"
esp
"
32u32
)
(
"
ebp
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
info
=
whatever_win_info
(
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
1
2
+
=
ebp
-
4
0
+
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
-
4i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
5
3
-
=
ebp
-
4
2
-
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
-
6i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
5
3
*
=
ebp
-
4
2
*
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
15
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
-
8i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
5
3
/
=
ebp
-
4
2
/
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
1
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
5
3
%
=
ebp
-
1
2
%
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
1
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
8
16
=
ebp
161
8
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
0
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
160
)
;
assert
!
(
eval_win_expr
(
"
1
+
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
1
-
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
1
*
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
1
/
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
1
%
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
1
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
^
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
1
0
/
=
ebp
1
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
1
0
%
=
ebp
1
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
1
0
=
ebp
1
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
1
3
=
ebp
1
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_stack_win_corners
(
)
{
let
input
=
vec
!
[
(
"
esp
"
32u32
)
(
"
ebp
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
info
=
whatever_win_info
(
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
32
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
1600
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
.
undef
=
ebp
.
undef
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
0
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
esp
=
ebp
ebp
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
32
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
1600
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
1
=
ebp
2
=
3
4
5
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
2
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
1
=
ebp
2
=
3
4
5
esp
eax
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
2
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
t0
1
=
esp
t0
5
+
=
ebp
2
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
6
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
2
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
T0
T0
2
=
=
ebp
3
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
3
)
;
}
#
[
test
]
fn
test_stack_win_errors
(
)
{
let
input
=
vec
!
[
(
"
esp
"
32u32
)
(
"
ebp
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
info
=
whatever_win_info
(
)
;
assert
!
(
eval_win_expr
(
"
esp
2000
^
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
kitties
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
kitties
=
kitties
1
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
.
undef
=
ebp
esp
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
0
2
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
0
esp
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
assert
!
(
eval_win_expr
(
"
esp
2
=
ebp
3
=
"
&
info
&
mut
walker
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_stack_win_equal_fixup
(
)
{
let
input
=
vec
!
[
(
"
esp
"
32u32
)
(
"
ebp
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
info
=
whatever_win_info
(
)
;
eval_win_expr
(
"
esp
1
=
ebp
2
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
2
)
;
}
#
[
test
]
#
[
ignore
]
fn
test_stack_win_negative_division
(
)
{
let
input
=
vec
!
[
(
"
esp
"
32u32
)
(
"
ebp
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
info
=
whatever_win_info
(
)
;
walker
.
caller_regs
.
clear
(
)
;
eval_win_expr
(
"
esp
5
3
/
=
ebp
-
4
2
/
=
"
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
-
2i32
as
u32
)
;
}
#
[
test
]
fn
test_stack_win_leftover_return_address
(
)
{
let
stack
=
vec
!
[
0x34
0x12
0xCD
0xAB
0x78
0x56
0xCD
0xAB
]
;
let
mut
walker
=
TestFrameWalker
{
instruction
:
0xABCD_1234u32
has_grand_callee
:
false
grand_callee_param_size
:
0
callee_regs
:
vec
!
[
(
"
eip
"
0xABCD_1234
)
(
"
esp
"
0
)
(
"
ebp
"
17
)
]
.
into_iter
(
)
.
collect
(
)
caller_regs
:
HashMap
:
:
new
(
)
stack
}
;
let
info
=
StackInfoWin
{
address
:
0
size
:
0
prologue_size
:
0
epilogue_size
:
0
parameter_size
:
0
saved_register_size
:
0
local_size
:
0
max_stack_size
:
0
program_string_or_base_pointer
:
WinStackThing
:
:
AllocatesBasePointer
(
false
)
}
;
walk_with_stack_win_fpo
(
&
info
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
esp
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ebp
"
]
17
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
eip
"
]
0xABCD_5678
)
;
}
#
[
test
]
fn
test_stack_cfi_doc_example
(
)
{
let
init
=
"
.
cfa
:
rsp
8
+
.
ra
:
.
cfa
-
8
+
^
"
;
let
additional
=
&
[
"
.
cfa
:
rsp
16
+
rax
:
.
cfa
-
16
+
^
"
"
.
cfa
:
rsp
24
+
"
]
;
let
input
=
vec
!
[
(
"
rsp
"
32u64
)
(
"
rip
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
mut
stack
=
vec
!
[
0
;
1600
]
;
const
FINAL_CFA
:
usize
=
32
+
24
;
const
FINAL_RA
:
u64
=
0xFA1E_F2E6_A2DF_2B68
;
const
FINAL_RAX
:
u64
=
0xB3EF_04CE_4321_FE2A
;
stack
[
FINAL_CFA
-
8
.
.
FINAL_CFA
]
.
copy_from_slice
(
&
FINAL_RA
.
to_le_bytes
(
)
)
;
stack
[
FINAL_CFA
-
16
.
.
FINAL_CFA
-
8
]
.
copy_from_slice
(
&
FINAL_RAX
.
to_le_bytes
(
)
)
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
(
init
additional
)
=
build_cfi_rules
(
init
additional
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
FINAL_CFA
as
u64
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
FINAL_RA
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
rax
"
]
FINAL_RAX
)
;
}
#
[
test
]
fn
test_stack_cfi_ops
(
)
{
let
input
=
vec
!
[
(
"
esp
"
32u32
)
(
"
eip
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
2
+
.
ra
:
-
4
0
+
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
-
4i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
5
3
-
.
ra
:
-
4
2
-
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
-
6i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
5
3
*
.
ra
:
-
4
2
*
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
15
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
-
8i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
5
3
/
.
ra
:
-
4
2
/
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
-
2i32
as
u32
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
5
3
%
.
ra
:
-
1
2
%
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
1
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
16
.
ra
:
161
8
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
0
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
160
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
+
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
-
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
*
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
/
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
%
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
^
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
0
/
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
0
%
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
0
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
3
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_stack_cfi_errors
(
)
{
let
input
=
vec
!
[
(
"
rsp
"
32u64
)
(
"
rip
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
16
+
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
ra
:
8
16
*
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
8
16
*
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
esp
8
16
*
.
cfa
:
16
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
12
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
12
.
ra
:
8
rax
:
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
12
.
ra
:
8
rax
:
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
12
.
ra
:
8
rax
:
rbx
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
12
.
ra
:
rsp
rip
=
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
.
undef
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
.
undef
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
2000
^
.
ra
:
8
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
kitties
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
rax
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
.
cfa
.
ra
:
2
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
.
ra
.
ra
:
2
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
.
ra
:
.
ra
"
&
[
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
rsp
8
+
.
ra
:
.
cfa
-
8
+
^
"
&
[
"
.
cfa
rsp
16
+
rax
:
.
cfa
-
16
+
^
"
"
.
cfa
rsp
24
+
"
]
)
;
assert
!
(
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_stack_cfi_corners
(
)
{
let
input
=
vec
!
[
(
"
rsp
"
32u64
)
(
"
rip
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
12
rax
:
16
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
12
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
rax
"
]
16
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
12
rax
:
.
undef
rbx
:
1
.
undef
+
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
12
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
12
kitties
:
16
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
12
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
12
.
ra
:
8
rax
:
rbx
:
8
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
12
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
8
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
.
ra
:
8
rax
:
1
0
/
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
8
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
.
cfa
:
2
.
ra
:
3
.
ra
:
4
rax
:
5
rax
:
6
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
4
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
rax
"
]
6
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
7
.
ra
:
.
cfa
1
+
rax
:
.
cfa
2
-
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
3
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
7
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
rax
"
]
5
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
1
.
ra
:
2
rax
:
.
ra
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
1
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
2
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
12
.
kitties
:
16
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
12
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
12
.
undef
:
16
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
2
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
12
)
;
}
#
[
test
]
fn
test_stack_cfi_arm
(
)
{
let
input
=
vec
!
[
(
"
pc
"
32u64
)
(
"
x11
"
1600
)
]
.
into_iter
(
)
.
collect
(
)
;
let
stack
=
vec
!
[
0
;
1600
]
;
let
mut
walker
=
TestFrameWalker
:
:
new
(
stack
input
)
;
walker
.
caller_regs
.
clear
(
)
;
let
(
init
additional
)
=
build_cfi_rules
(
"
.
cfa
:
8
.
ra
:
12
x11
:
16
x12
:
x11
.
cfa
+
"
&
[
]
)
;
walk_with_stack_cfi
(
&
init
&
additional
&
mut
walker
)
.
unwrap
(
)
;
assert_eq
!
(
walker
.
caller_regs
.
len
(
)
4
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
cfa
"
]
8
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
ra
"
]
12
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
x11
"
]
16
)
;
assert_eq
!
(
walker
.
caller_regs
[
"
x12
"
]
1608
)
;
}
}
