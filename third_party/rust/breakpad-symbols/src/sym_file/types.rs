use
range_map
:
:
{
Range
RangeMap
}
;
use
std
:
:
collections
:
:
HashMap
;
#
[
derive
(
Debug
Eq
PartialEq
Ord
PartialOrd
)
]
pub
struct
PublicSymbol
{
pub
address
:
u64
pub
name
:
String
pub
parameter_size
:
u32
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
SourceLine
{
pub
address
:
u64
pub
size
:
u32
pub
file
:
u32
pub
line
:
u32
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
Inlinee
{
pub
depth
:
u32
pub
address
:
u64
pub
size
:
u32
pub
call_file
:
u32
pub
call_line
:
u32
pub
origin_id
:
u32
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
Function
{
pub
address
:
u64
pub
size
:
u32
pub
parameter_size
:
u32
pub
name
:
String
pub
lines
:
RangeMap
<
u64
SourceLine
>
pub
inlinees
:
Vec
<
Inlinee
>
}
impl
Function
{
pub
fn
memory_range
(
&
self
)
-
>
Option
<
Range
<
u64
>
>
{
if
self
.
size
=
=
0
{
return
None
;
}
Some
(
Range
:
:
new
(
self
.
address
self
.
address
.
checked_add
(
self
.
size
as
u64
)
?
-
1
)
)
}
pub
fn
get_outermost_sourceloc
(
&
self
addr
:
u64
)
-
>
Option
<
(
u32
u32
u64
Option
<
u32
>
)
>
{
if
let
Some
(
(
call_file
call_line
address
origin
)
)
=
self
.
get_inlinee_at_depth
(
0
addr
)
{
return
Some
(
(
call_file
call_line
address
Some
(
origin
)
)
)
;
}
let
line
=
self
.
lines
.
get
(
addr
)
?
;
Some
(
(
line
.
file
line
.
line
line
.
address
None
)
)
}
pub
fn
get_innermost_sourceloc
(
&
self
addr
:
u64
)
-
>
Option
<
(
u32
u32
u64
)
>
{
let
line
=
self
.
lines
.
get
(
addr
)
?
;
Some
(
(
line
.
file
line
.
line
line
.
address
)
)
}
pub
fn
get_inlinee_at_depth
(
&
self
depth
:
u32
addr
:
u64
)
-
>
Option
<
(
u32
u32
u64
u32
)
>
{
let
inlinee
=
match
self
.
inlinees
.
binary_search_by_key
(
&
(
depth
addr
)
|
inlinee
|
(
inlinee
.
depth
inlinee
.
address
)
)
{
Ok
(
index
)
=
>
&
self
.
inlinees
[
index
]
Err
(
0
)
=
>
return
None
Err
(
index
)
=
>
&
self
.
inlinees
[
index
-
1
]
}
;
if
inlinee
.
depth
!
=
depth
{
return
None
;
}
let
end_address
=
inlinee
.
address
.
checked_add
(
inlinee
.
size
as
u64
)
?
;
if
addr
<
end_address
{
Some
(
(
inlinee
.
call_file
inlinee
.
call_line
inlinee
.
address
inlinee
.
origin_id
)
)
}
else
{
None
}
}
}
#
[
derive
(
Clone
Debug
Eq
Ord
PartialEq
PartialOrd
)
]
pub
enum
Info
{
Url
(
String
)
Unknown
}
#
[
derive
(
Clone
Debug
Eq
Ord
PartialEq
PartialOrd
)
]
pub
struct
CfiRules
{
pub
address
:
u64
pub
rules
:
String
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
StackInfoCfi
{
pub
init
:
CfiRules
pub
size
:
u32
pub
add_rules
:
Vec
<
CfiRules
>
}
impl
StackInfoCfi
{
pub
fn
memory_range
(
&
self
)
-
>
Option
<
Range
<
u64
>
>
{
if
self
.
size
=
=
0
{
return
None
;
}
Some
(
Range
:
:
new
(
self
.
init
.
address
self
.
init
.
address
.
checked_add
(
self
.
size
as
u64
)
?
-
1
)
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
WinFrameType
{
Fpo
(
StackInfoWin
)
FrameData
(
StackInfoWin
)
Unhandled
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
WinStackThing
{
ProgramString
(
String
)
AllocatesBasePointer
(
bool
)
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
StackInfoWin
{
pub
address
:
u64
pub
size
:
u32
pub
prologue_size
:
u32
pub
epilogue_size
:
u32
pub
parameter_size
:
u32
pub
saved_register_size
:
u32
pub
local_size
:
u32
pub
max_stack_size
:
u32
pub
program_string_or_base_pointer
:
WinStackThing
}
impl
StackInfoWin
{
pub
fn
memory_range
(
&
self
)
-
>
Option
<
Range
<
u64
>
>
{
if
self
.
size
=
=
0
{
return
None
;
}
Some
(
Range
:
:
new
(
self
.
address
self
.
address
.
checked_add
(
self
.
size
as
u64
)
?
-
1
)
)
}
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
struct
SymbolFile
{
pub
module_id
:
String
pub
debug_file
:
String
pub
files
:
HashMap
<
u32
String
>
pub
publics
:
Vec
<
PublicSymbol
>
pub
functions
:
RangeMap
<
u64
Function
>
pub
inline_origins
:
HashMap
<
u32
String
>
pub
cfi_stack_info
:
RangeMap
<
u64
StackInfoCfi
>
pub
win_stack_framedata_info
:
RangeMap
<
u64
StackInfoWin
>
pub
win_stack_fpo_info
:
RangeMap
<
u64
StackInfoWin
>
pub
url
:
Option
<
String
>
pub
ambiguities_repaired
:
u64
pub
ambiguities_discarded
:
u64
pub
corruptions_discarded
:
u64
pub
cfi_eval_corruptions
:
u64
}
