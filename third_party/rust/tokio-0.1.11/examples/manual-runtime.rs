extern
crate
futures
;
extern
crate
tokio
;
extern
crate
tokio_current_thread
;
extern
crate
tokio_executor
;
extern
crate
tokio_reactor
;
extern
crate
tokio_timer
;
use
std
:
:
io
:
:
Error
as
IoError
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
futures
:
:
{
future
Future
}
;
use
tokio_current_thread
:
:
CurrentThread
;
use
tokio_reactor
:
:
Reactor
;
use
tokio_timer
:
:
timer
:
:
{
self
Timer
}
;
fn
run
<
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
>
(
f
:
F
)
-
>
Result
<
(
)
IoError
>
{
let
reactor
=
Reactor
:
:
new
(
)
?
;
let
reactor_handle
=
reactor
.
handle
(
)
;
let
timer
=
Timer
:
:
new
(
reactor
)
;
let
timer_handle
=
timer
.
handle
(
)
;
let
mut
executor
=
CurrentThread
:
:
new_with_park
(
timer
)
;
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
Multiple
executors
at
once
"
)
;
tokio_reactor
:
:
with_default
(
&
reactor_handle
&
mut
enter
|
enter
|
{
timer
:
:
with_default
(
&
timer_handle
enter
|
enter
|
{
let
mut
default_executor
=
tokio_current_thread
:
:
TaskExecutor
:
:
current
(
)
;
tokio_executor
:
:
with_default
(
&
mut
default_executor
enter
|
enter
|
{
let
mut
executor
=
executor
.
enter
(
enter
)
;
executor
.
block_on
(
f
)
.
unwrap
(
)
;
executor
.
run
(
)
.
unwrap
(
)
;
}
)
;
}
)
;
}
)
;
Ok
(
(
)
)
}
fn
main
(
)
{
run
(
future
:
:
lazy
(
|
|
{
let
connect
=
tokio
:
:
net
:
:
TcpStream
:
:
connect
(
&
"
127
.
0
.
0
.
1
:
53
"
.
parse
(
)
.
unwrap
(
)
)
.
map
(
|
_
|
println
!
(
"
Connected
"
)
)
.
map_err
(
|
e
|
println
!
(
"
Failed
to
connect
:
{
}
"
e
)
)
;
tokio_current_thread
:
:
spawn
(
connect
)
;
let
deadline
=
tokio
:
:
timer
:
:
Delay
:
:
new
(
Instant
:
:
now
(
)
+
Duration
:
:
from_secs
(
5
)
)
.
map
(
|
(
)
|
println
!
(
"
5
seconds
are
over
"
)
)
.
map_err
(
|
e
|
println
!
(
"
Failed
to
wait
:
{
}
"
e
)
)
;
tokio
:
:
executor
:
:
spawn
(
deadline
)
;
Ok
(
(
)
)
}
)
)
.
unwrap
(
)
;
}
