use
tokio_threadpool
:
:
Sender
;
use
futures
:
:
future
:
:
{
self
Future
}
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
TaskExecutor
{
pub
(
super
)
inner
:
Sender
}
impl
TaskExecutor
{
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
self
.
inner
.
spawn
(
future
)
.
unwrap
(
)
;
}
}
impl
<
T
>
future
:
:
Executor
<
T
>
for
TaskExecutor
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
execute
(
&
self
future
:
T
)
-
>
Result
<
(
)
future
:
:
ExecuteError
<
T
>
>
{
self
.
inner
.
execute
(
future
)
}
}
impl
:
:
executor
:
:
Executor
for
TaskExecutor
{
fn
spawn
(
&
mut
self
future
:
Box
<
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
:
:
executor
:
:
SpawnError
>
{
self
.
inner
.
spawn
(
future
)
}
}
