#
!
[
warn
(
clippy
:
:
all
)
]
#
!
[
warn
(
clippy
:
:
cargo
)
]
#
!
[
warn
(
clippy
:
:
undocumented_unsafe_blocks
)
]
#
!
[
allow
(
unknown_lints
)
]
#
!
[
warn
(
missing_copy_implementations
)
]
#
!
[
warn
(
missing_debug_implementations
)
]
#
!
[
warn
(
missing_docs
)
]
#
!
[
warn
(
rust_2018_idioms
)
]
#
!
[
warn
(
trivial_casts
trivial_numeric_casts
)
]
#
!
[
warn
(
unsafe_op_in_unsafe_fn
)
]
#
!
[
warn
(
unused_qualifications
)
]
#
!
[
warn
(
variant_size_differences
)
]
use
std
:
:
os
:
:
raw
:
:
c_char
;
extern
"
C
"
{
fn
iana_time_zone_haiku_get_tz
(
buf
:
*
mut
c_char
buf_size
:
usize
)
-
>
usize
;
}
#
[
must_use
]
pub
fn
get_timezone
(
)
-
>
Option
<
String
>
{
let
mut
buf
=
[
0u8
;
32
]
;
let
len
=
unsafe
{
let
buf_size
=
buf
.
len
(
)
;
let
buf_ptr
=
buf
.
as_mut_ptr
(
)
.
cast
:
:
<
c_char
>
(
)
;
iana_time_zone_haiku_get_tz
(
buf_ptr
buf_size
)
}
;
match
buf
.
get
(
.
.
len
)
?
{
b
"
"
=
>
None
s
=
>
Some
(
std
:
:
str
:
:
from_utf8
(
s
)
.
ok
(
)
?
.
to_owned
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
test
]
#
[
cfg
(
not
(
target_os
=
"
haiku
"
)
)
]
fn
test_fallback_on_non_haiku_platforms
(
)
{
assert
!
(
super
:
:
get_timezone
(
)
.
is_none
(
)
)
;
}
#
[
test
]
#
[
cfg
(
target_os
=
"
haiku
"
)
]
fn
test_retrieve_time_zone_on_haiku_platforms
(
)
{
let
timezone
=
super
:
:
get_timezone
(
)
.
unwrap
(
)
;
assert
!
(
!
timezone
.
is_empty
(
)
)
;
}
}
