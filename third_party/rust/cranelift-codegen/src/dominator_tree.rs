use
crate
:
:
entity
:
:
SecondaryMap
;
use
crate
:
:
flowgraph
:
:
{
BlockPredecessor
ControlFlowGraph
}
;
use
crate
:
:
ir
:
:
instructions
:
:
BranchInfo
;
use
crate
:
:
ir
:
:
{
Block
ExpandedProgramPoint
Function
Inst
Layout
ProgramOrder
Value
}
;
use
crate
:
:
packed_option
:
:
PackedOption
;
use
crate
:
:
timing
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
cmp
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
mem
;
const
STRIDE
:
u32
=
4
;
const
DONE
:
u32
=
1
;
const
SEEN
:
u32
=
2
;
#
[
derive
(
Clone
Default
)
]
struct
DomNode
{
rpo_number
:
u32
idom
:
PackedOption
<
Inst
>
}
pub
struct
DominatorTree
{
nodes
:
SecondaryMap
<
Block
DomNode
>
postorder
:
Vec
<
Block
>
stack
:
Vec
<
Block
>
valid
:
bool
}
impl
DominatorTree
{
pub
fn
is_reachable
(
&
self
block
:
Block
)
-
>
bool
{
self
.
nodes
[
block
]
.
rpo_number
!
=
0
}
pub
fn
cfg_postorder
(
&
self
)
-
>
&
[
Block
]
{
debug_assert
!
(
self
.
is_valid
(
)
)
;
&
self
.
postorder
}
pub
fn
idom
(
&
self
block
:
Block
)
-
>
Option
<
Inst
>
{
self
.
nodes
[
block
]
.
idom
.
into
(
)
}
fn
rpo_cmp_block
(
&
self
a
:
Block
b
:
Block
)
-
>
Ordering
{
self
.
nodes
[
a
]
.
rpo_number
.
cmp
(
&
self
.
nodes
[
b
]
.
rpo_number
)
}
pub
fn
rpo_cmp
<
A
B
>
(
&
self
a
:
A
b
:
B
layout
:
&
Layout
)
-
>
Ordering
where
A
:
Into
<
ExpandedProgramPoint
>
B
:
Into
<
ExpandedProgramPoint
>
{
let
a
=
a
.
into
(
)
;
let
b
=
b
.
into
(
)
;
self
.
rpo_cmp_block
(
layout
.
pp_block
(
a
)
layout
.
pp_block
(
b
)
)
.
then
(
layout
.
cmp
(
a
b
)
)
}
pub
fn
dominates
<
A
B
>
(
&
self
a
:
A
b
:
B
layout
:
&
Layout
)
-
>
bool
where
A
:
Into
<
ExpandedProgramPoint
>
B
:
Into
<
ExpandedProgramPoint
>
{
let
a
=
a
.
into
(
)
;
let
b
=
b
.
into
(
)
;
match
a
{
ExpandedProgramPoint
:
:
Block
(
block_a
)
=
>
{
a
=
=
b
|
|
self
.
last_dominator
(
block_a
b
layout
)
.
is_some
(
)
}
ExpandedProgramPoint
:
:
Inst
(
inst_a
)
=
>
{
let
block_a
=
layout
.
inst_block
(
inst_a
)
.
expect
(
"
Instruction
not
in
layout
.
"
)
;
match
self
.
last_dominator
(
block_a
b
layout
)
{
Some
(
last
)
=
>
layout
.
cmp
(
inst_a
last
)
!
=
Ordering
:
:
Greater
None
=
>
false
}
}
}
}
pub
fn
last_dominator
<
B
>
(
&
self
a
:
Block
b
:
B
layout
:
&
Layout
)
-
>
Option
<
Inst
>
where
B
:
Into
<
ExpandedProgramPoint
>
{
let
(
mut
block_b
mut
inst_b
)
=
match
b
.
into
(
)
{
ExpandedProgramPoint
:
:
Block
(
block
)
=
>
(
block
None
)
ExpandedProgramPoint
:
:
Inst
(
inst
)
=
>
(
layout
.
inst_block
(
inst
)
.
expect
(
"
Instruction
not
in
layout
.
"
)
Some
(
inst
)
)
}
;
let
rpo_a
=
self
.
nodes
[
a
]
.
rpo_number
;
while
rpo_a
<
self
.
nodes
[
block_b
]
.
rpo_number
{
let
idom
=
match
self
.
idom
(
block_b
)
{
Some
(
idom
)
=
>
idom
None
=
>
return
None
}
;
block_b
=
layout
.
inst_block
(
idom
)
.
expect
(
"
Dominator
got
removed
.
"
)
;
inst_b
=
Some
(
idom
)
;
}
if
a
=
=
block_b
{
inst_b
}
else
{
None
}
}
pub
fn
common_dominator
(
&
self
mut
a
:
BlockPredecessor
mut
b
:
BlockPredecessor
layout
:
&
Layout
)
-
>
BlockPredecessor
{
loop
{
match
self
.
rpo_cmp_block
(
a
.
block
b
.
block
)
{
Ordering
:
:
Less
=
>
{
let
idom
=
self
.
nodes
[
b
.
block
]
.
idom
.
expect
(
"
Unreachable
basic
block
?
"
)
;
b
=
BlockPredecessor
:
:
new
(
layout
.
inst_block
(
idom
)
.
expect
(
"
Dangling
idom
instruction
"
)
idom
)
;
}
Ordering
:
:
Greater
=
>
{
let
idom
=
self
.
nodes
[
a
.
block
]
.
idom
.
expect
(
"
Unreachable
basic
block
?
"
)
;
a
=
BlockPredecessor
:
:
new
(
layout
.
inst_block
(
idom
)
.
expect
(
"
Dangling
idom
instruction
"
)
idom
)
;
}
Ordering
:
:
Equal
=
>
break
}
}
debug_assert_eq
!
(
a
.
block
b
.
block
"
Unreachable
block
passed
to
common_dominator
?
"
)
;
if
layout
.
cmp
(
a
.
inst
b
.
inst
)
=
=
Ordering
:
:
Less
{
a
}
else
{
b
}
}
}
impl
DominatorTree
{
pub
fn
new
(
)
-
>
Self
{
Self
{
nodes
:
SecondaryMap
:
:
new
(
)
postorder
:
Vec
:
:
new
(
)
stack
:
Vec
:
:
new
(
)
valid
:
false
}
}
pub
fn
with_function
(
func
:
&
Function
cfg
:
&
ControlFlowGraph
)
-
>
Self
{
let
block_capacity
=
func
.
layout
.
block_capacity
(
)
;
let
mut
domtree
=
Self
{
nodes
:
SecondaryMap
:
:
with_capacity
(
block_capacity
)
postorder
:
Vec
:
:
with_capacity
(
block_capacity
)
stack
:
Vec
:
:
new
(
)
valid
:
false
}
;
domtree
.
compute
(
func
cfg
)
;
domtree
}
pub
fn
compute
(
&
mut
self
func
:
&
Function
cfg
:
&
ControlFlowGraph
)
{
let
_tt
=
timing
:
:
domtree
(
)
;
debug_assert
!
(
cfg
.
is_valid
(
)
)
;
self
.
compute_postorder
(
func
)
;
self
.
compute_domtree
(
func
cfg
)
;
self
.
valid
=
true
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
nodes
.
clear
(
)
;
self
.
postorder
.
clear
(
)
;
debug_assert
!
(
self
.
stack
.
is_empty
(
)
)
;
self
.
valid
=
false
;
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
self
.
valid
}
fn
compute_postorder
(
&
mut
self
func
:
&
Function
)
{
self
.
clear
(
)
;
self
.
nodes
.
resize
(
func
.
dfg
.
num_blocks
(
)
)
;
match
func
.
layout
.
entry_block
(
)
{
Some
(
block
)
=
>
{
self
.
stack
.
push
(
block
)
;
self
.
nodes
[
block
]
.
rpo_number
=
SEEN
;
}
None
=
>
return
}
while
let
Some
(
block
)
=
self
.
stack
.
pop
(
)
{
match
self
.
nodes
[
block
]
.
rpo_number
{
SEEN
=
>
{
self
.
nodes
[
block
]
.
rpo_number
=
DONE
;
self
.
stack
.
push
(
block
)
;
self
.
push_successors
(
func
block
)
;
}
DONE
=
>
{
self
.
postorder
.
push
(
block
)
;
}
_
=
>
unreachable
!
(
)
}
}
}
fn
push_successors
(
&
mut
self
func
:
&
Function
block
:
Block
)
{
for
inst
in
func
.
layout
.
block_likely_branches
(
block
)
{
match
func
.
dfg
.
analyze_branch
(
inst
)
{
BranchInfo
:
:
SingleDest
(
succ
_
)
=
>
self
.
push_if_unseen
(
succ
)
BranchInfo
:
:
Table
(
jt
dest
)
=
>
{
for
succ
in
func
.
jump_tables
[
jt
]
.
iter
(
)
{
self
.
push_if_unseen
(
*
succ
)
;
}
if
let
Some
(
dest
)
=
dest
{
self
.
push_if_unseen
(
dest
)
;
}
}
BranchInfo
:
:
NotABranch
=
>
{
}
}
}
}
fn
push_if_unseen
(
&
mut
self
block
:
Block
)
{
if
self
.
nodes
[
block
]
.
rpo_number
=
=
0
{
self
.
nodes
[
block
]
.
rpo_number
=
SEEN
;
self
.
stack
.
push
(
block
)
;
}
}
fn
compute_domtree
(
&
mut
self
func
:
&
Function
cfg
:
&
ControlFlowGraph
)
{
let
(
entry_block
postorder
)
=
match
self
.
postorder
.
as_slice
(
)
.
split_last
(
)
{
Some
(
(
&
eb
rest
)
)
=
>
(
eb
rest
)
None
=
>
return
}
;
debug_assert_eq
!
(
Some
(
entry_block
)
func
.
layout
.
entry_block
(
)
)
;
self
.
nodes
[
entry_block
]
.
rpo_number
=
2
*
STRIDE
;
for
(
rpo_idx
&
block
)
in
postorder
.
iter
(
)
.
rev
(
)
.
enumerate
(
)
{
self
.
nodes
[
block
]
=
DomNode
{
idom
:
self
.
compute_idom
(
block
cfg
&
func
.
layout
)
.
into
(
)
rpo_number
:
(
rpo_idx
as
u32
+
3
)
*
STRIDE
}
}
let
mut
changed
=
true
;
while
changed
{
changed
=
false
;
for
&
block
in
postorder
.
iter
(
)
.
rev
(
)
{
let
idom
=
self
.
compute_idom
(
block
cfg
&
func
.
layout
)
.
into
(
)
;
if
self
.
nodes
[
block
]
.
idom
!
=
idom
{
self
.
nodes
[
block
]
.
idom
=
idom
;
changed
=
true
;
}
}
}
}
fn
compute_idom
(
&
self
block
:
Block
cfg
:
&
ControlFlowGraph
layout
:
&
Layout
)
-
>
Inst
{
let
mut
reachable_preds
=
cfg
.
pred_iter
(
block
)
.
filter
(
|
&
BlockPredecessor
{
block
:
pred
.
.
}
|
self
.
nodes
[
pred
]
.
rpo_number
>
1
)
;
let
mut
idom
=
reachable_preds
.
next
(
)
.
expect
(
"
block
node
must
have
one
reachable
predecessor
"
)
;
for
pred
in
reachable_preds
{
idom
=
self
.
common_dominator
(
idom
pred
layout
)
;
}
idom
.
inst
}
}
pub
struct
DominatorTreePreorder
{
nodes
:
SecondaryMap
<
Block
ExtraNode
>
stack
:
Vec
<
Block
>
}
#
[
derive
(
Default
Clone
)
]
struct
ExtraNode
{
child
:
PackedOption
<
Block
>
sibling
:
PackedOption
<
Block
>
pre_number
:
u32
pre_max
:
u32
}
impl
DominatorTreePreorder
{
pub
fn
new
(
)
-
>
Self
{
Self
{
nodes
:
SecondaryMap
:
:
new
(
)
stack
:
Vec
:
:
new
(
)
}
}
pub
fn
compute
(
&
mut
self
domtree
:
&
DominatorTree
layout
:
&
Layout
)
{
self
.
nodes
.
clear
(
)
;
debug_assert_eq
!
(
self
.
stack
.
len
(
)
0
)
;
for
&
block
in
domtree
.
cfg_postorder
(
)
{
if
let
Some
(
idom_inst
)
=
domtree
.
idom
(
block
)
{
let
idom
=
layout
.
pp_block
(
idom_inst
)
;
let
sib
=
mem
:
:
replace
(
&
mut
self
.
nodes
[
idom
]
.
child
block
.
into
(
)
)
;
self
.
nodes
[
block
]
.
sibling
=
sib
;
}
else
{
self
.
stack
.
push
(
block
)
;
}
}
debug_assert
!
(
self
.
stack
.
len
(
)
<
=
1
)
;
let
mut
n
=
0
;
while
let
Some
(
block
)
=
self
.
stack
.
pop
(
)
{
n
+
=
1
;
let
node
=
&
mut
self
.
nodes
[
block
]
;
node
.
pre_number
=
n
;
node
.
pre_max
=
n
;
if
let
Some
(
n
)
=
node
.
sibling
.
expand
(
)
{
self
.
stack
.
push
(
n
)
;
}
if
let
Some
(
n
)
=
node
.
child
.
expand
(
)
{
self
.
stack
.
push
(
n
)
;
}
}
for
&
block
in
domtree
.
cfg_postorder
(
)
{
if
let
Some
(
idom_inst
)
=
domtree
.
idom
(
block
)
{
let
idom
=
layout
.
pp_block
(
idom_inst
)
;
let
pre_max
=
cmp
:
:
max
(
self
.
nodes
[
block
]
.
pre_max
self
.
nodes
[
idom
]
.
pre_max
)
;
self
.
nodes
[
idom
]
.
pre_max
=
pre_max
;
}
}
}
}
pub
struct
ChildIter
<
'
a
>
{
dtpo
:
&
'
a
DominatorTreePreorder
next
:
PackedOption
<
Block
>
}
impl
<
'
a
>
Iterator
for
ChildIter
<
'
a
>
{
type
Item
=
Block
;
fn
next
(
&
mut
self
)
-
>
Option
<
Block
>
{
let
n
=
self
.
next
.
expand
(
)
;
if
let
Some
(
block
)
=
n
{
self
.
next
=
self
.
dtpo
.
nodes
[
block
]
.
sibling
;
}
n
}
}
impl
DominatorTreePreorder
{
pub
fn
children
(
&
self
block
:
Block
)
-
>
ChildIter
{
ChildIter
{
dtpo
:
self
next
:
self
.
nodes
[
block
]
.
child
}
}
pub
fn
dominates
(
&
self
a
:
Block
b
:
Block
)
-
>
bool
{
let
na
=
&
self
.
nodes
[
a
]
;
let
nb
=
&
self
.
nodes
[
b
]
;
na
.
pre_number
<
=
nb
.
pre_number
&
&
na
.
pre_max
>
=
nb
.
pre_max
}
pub
fn
pre_cmp_block
(
&
self
a
:
Block
b
:
Block
)
-
>
Ordering
{
self
.
nodes
[
a
]
.
pre_number
.
cmp
(
&
self
.
nodes
[
b
]
.
pre_number
)
}
pub
fn
pre_cmp
<
A
B
>
(
&
self
a
:
A
b
:
B
layout
:
&
Layout
)
-
>
Ordering
where
A
:
Into
<
ExpandedProgramPoint
>
B
:
Into
<
ExpandedProgramPoint
>
{
let
a
=
a
.
into
(
)
;
let
b
=
b
.
into
(
)
;
self
.
pre_cmp_block
(
layout
.
pp_block
(
a
)
layout
.
pp_block
(
b
)
)
.
then
(
layout
.
cmp
(
a
b
)
)
}
pub
fn
pre_cmp_def
(
&
self
a
:
Value
b
:
Value
func
:
&
Function
)
-
>
Ordering
{
let
da
=
func
.
dfg
.
value_def
(
a
)
;
let
db
=
func
.
dfg
.
value_def
(
b
)
;
self
.
pre_cmp
(
da
db
&
func
.
layout
)
.
then_with
(
|
|
da
.
num
(
)
.
cmp
(
&
db
.
num
(
)
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
crate
:
:
flowgraph
:
:
ControlFlowGraph
;
use
crate
:
:
ir
:
:
types
:
:
*
;
use
crate
:
:
ir
:
:
{
Function
InstBuilder
TrapCode
}
;
#
[
test
]
fn
empty
(
)
{
let
func
=
Function
:
:
new
(
)
;
let
cfg
=
ControlFlowGraph
:
:
with_function
(
&
func
)
;
debug_assert
!
(
cfg
.
is_valid
(
)
)
;
let
dtree
=
DominatorTree
:
:
with_function
(
&
func
&
cfg
)
;
assert_eq
!
(
0
dtree
.
nodes
.
keys
(
)
.
count
(
)
)
;
assert_eq
!
(
dtree
.
cfg_postorder
(
)
&
[
]
)
;
let
mut
dtpo
=
DominatorTreePreorder
:
:
new
(
)
;
dtpo
.
compute
(
&
dtree
&
func
.
layout
)
;
}
#
[
test
]
fn
unreachable_node
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
v0
=
func
.
dfg
.
append_block_param
(
block0
I32
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
block2
=
func
.
dfg
.
make_block
(
)
;
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
cur
.
ins
(
)
.
brnz
(
v0
block2
&
[
]
)
;
cur
.
ins
(
)
.
trap
(
TrapCode
:
:
User
(
0
)
)
;
cur
.
insert_block
(
block1
)
;
let
v1
=
cur
.
ins
(
)
.
iconst
(
I32
1
)
;
let
v2
=
cur
.
ins
(
)
.
iadd
(
v0
v1
)
;
cur
.
ins
(
)
.
jump
(
block0
&
[
v2
]
)
;
cur
.
insert_block
(
block2
)
;
cur
.
ins
(
)
.
return_
(
&
[
v0
]
)
;
let
cfg
=
ControlFlowGraph
:
:
with_function
(
cur
.
func
)
;
let
dt
=
DominatorTree
:
:
with_function
(
cur
.
func
&
cfg
)
;
assert_eq
!
(
dt
.
cfg_postorder
(
)
&
[
block2
block0
]
)
;
let
v2_def
=
cur
.
func
.
dfg
.
value_def
(
v2
)
.
unwrap_inst
(
)
;
assert
!
(
!
dt
.
dominates
(
v2_def
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block0
v2_def
&
cur
.
func
.
layout
)
)
;
let
mut
dtpo
=
DominatorTreePreorder
:
:
new
(
)
;
dtpo
.
compute
(
&
dt
&
cur
.
func
.
layout
)
;
assert
!
(
dtpo
.
dominates
(
block0
block0
)
)
;
assert
!
(
!
dtpo
.
dominates
(
block0
block1
)
)
;
assert
!
(
dtpo
.
dominates
(
block0
block2
)
)
;
assert
!
(
!
dtpo
.
dominates
(
block1
block0
)
)
;
assert
!
(
dtpo
.
dominates
(
block1
block1
)
)
;
assert
!
(
!
dtpo
.
dominates
(
block1
block2
)
)
;
assert
!
(
!
dtpo
.
dominates
(
block2
block0
)
)
;
assert
!
(
!
dtpo
.
dominates
(
block2
block1
)
)
;
assert
!
(
dtpo
.
dominates
(
block2
block2
)
)
;
}
#
[
test
]
fn
non_zero_entry_block
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
block2
=
func
.
dfg
.
make_block
(
)
;
let
block3
=
func
.
dfg
.
make_block
(
)
;
let
cond
=
func
.
dfg
.
append_block_param
(
block3
I32
)
;
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block3
)
;
let
jmp_block3_block1
=
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
cur
.
insert_block
(
block1
)
;
let
br_block1_block0
=
cur
.
ins
(
)
.
brnz
(
cond
block0
&
[
]
)
;
let
jmp_block1_block2
=
cur
.
ins
(
)
.
jump
(
block2
&
[
]
)
;
cur
.
insert_block
(
block2
)
;
cur
.
ins
(
)
.
jump
(
block0
&
[
]
)
;
cur
.
insert_block
(
block0
)
;
let
cfg
=
ControlFlowGraph
:
:
with_function
(
cur
.
func
)
;
let
dt
=
DominatorTree
:
:
with_function
(
cur
.
func
&
cfg
)
;
assert_eq
!
(
dt
.
cfg_postorder
(
)
&
[
block2
block0
block1
block3
]
)
;
assert_eq
!
(
cur
.
func
.
layout
.
entry_block
(
)
.
unwrap
(
)
block3
)
;
assert_eq
!
(
dt
.
idom
(
block3
)
None
)
;
assert_eq
!
(
dt
.
idom
(
block1
)
.
unwrap
(
)
jmp_block3_block1
)
;
assert_eq
!
(
dt
.
idom
(
block2
)
.
unwrap
(
)
jmp_block1_block2
)
;
assert_eq
!
(
dt
.
idom
(
block0
)
.
unwrap
(
)
br_block1_block0
)
;
assert
!
(
dt
.
dominates
(
br_block1_block0
br_block1_block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
br_block1_block0
jmp_block3_block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp_block3_block1
br_block1_block0
&
cur
.
func
.
layout
)
)
;
assert_eq
!
(
dt
.
rpo_cmp
(
block3
block3
&
cur
.
func
.
layout
)
Ordering
:
:
Equal
)
;
assert_eq
!
(
dt
.
rpo_cmp
(
block3
block1
&
cur
.
func
.
layout
)
Ordering
:
:
Less
)
;
assert_eq
!
(
dt
.
rpo_cmp
(
block3
jmp_block3_block1
&
cur
.
func
.
layout
)
Ordering
:
:
Less
)
;
assert_eq
!
(
dt
.
rpo_cmp
(
jmp_block3_block1
jmp_block1_block2
&
cur
.
func
.
layout
)
Ordering
:
:
Less
)
;
}
#
[
test
]
fn
backwards_layout
(
)
{
let
mut
func
=
Function
:
:
new
(
)
;
let
block0
=
func
.
dfg
.
make_block
(
)
;
let
block1
=
func
.
dfg
.
make_block
(
)
;
let
block2
=
func
.
dfg
.
make_block
(
)
;
let
mut
cur
=
FuncCursor
:
:
new
(
&
mut
func
)
;
cur
.
insert_block
(
block0
)
;
let
jmp02
=
cur
.
ins
(
)
.
jump
(
block2
&
[
]
)
;
cur
.
insert_block
(
block1
)
;
let
trap
=
cur
.
ins
(
)
.
trap
(
TrapCode
:
:
User
(
5
)
)
;
cur
.
insert_block
(
block2
)
;
let
jmp21
=
cur
.
ins
(
)
.
jump
(
block1
&
[
]
)
;
let
cfg
=
ControlFlowGraph
:
:
with_function
(
cur
.
func
)
;
let
dt
=
DominatorTree
:
:
with_function
(
cur
.
func
&
cfg
)
;
assert_eq
!
(
cur
.
func
.
layout
.
entry_block
(
)
Some
(
block0
)
)
;
assert_eq
!
(
dt
.
idom
(
block0
)
None
)
;
assert_eq
!
(
dt
.
idom
(
block1
)
Some
(
jmp21
)
)
;
assert_eq
!
(
dt
.
idom
(
block2
)
Some
(
jmp02
)
)
;
assert
!
(
dt
.
dominates
(
block0
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block0
jmp02
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block0
block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block0
trap
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block0
block2
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block0
jmp21
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
jmp02
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp02
jmp02
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp02
block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp02
trap
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp02
block2
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp02
jmp21
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block1
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block1
jmp02
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block1
block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block1
trap
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block1
block2
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block1
jmp21
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
trap
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
trap
jmp02
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
trap
block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
trap
trap
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
trap
block2
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
trap
jmp21
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block2
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
block2
jmp02
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block2
block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block2
trap
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block2
block2
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
block2
jmp21
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
jmp21
block0
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
jmp21
jmp02
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp21
block1
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp21
trap
&
cur
.
func
.
layout
)
)
;
assert
!
(
!
dt
.
dominates
(
jmp21
block2
&
cur
.
func
.
layout
)
)
;
assert
!
(
dt
.
dominates
(
jmp21
jmp21
&
cur
.
func
.
layout
)
)
;
}
}
