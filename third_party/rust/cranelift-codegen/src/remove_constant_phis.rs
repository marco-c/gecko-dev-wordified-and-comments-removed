use
crate
:
:
dominator_tree
:
:
DominatorTree
;
use
crate
:
:
entity
:
:
EntityList
;
use
crate
:
:
fx
:
:
FxHashMap
;
use
crate
:
:
fx
:
:
FxHashSet
;
use
crate
:
:
ir
:
:
instructions
:
:
BranchInfo
;
use
crate
:
:
ir
:
:
Function
;
use
crate
:
:
ir
:
:
{
Block
Inst
Value
}
;
use
crate
:
:
timing
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
use
std
:
:
vec
:
:
Vec
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
enum
AbstractValue
{
Many
One
(
Value
)
None
}
impl
AbstractValue
{
fn
join
(
self
other
:
AbstractValue
)
-
>
AbstractValue
{
match
(
self
other
)
{
(
AbstractValue
:
:
None
p2
)
=
>
p2
(
p1
AbstractValue
:
:
None
)
=
>
p1
(
AbstractValue
:
:
Many
_p2
)
=
>
AbstractValue
:
:
Many
(
_p1
AbstractValue
:
:
Many
)
=
>
AbstractValue
:
:
Many
(
AbstractValue
:
:
One
(
v1
)
AbstractValue
:
:
One
(
v2
)
)
=
>
{
if
v1
=
=
v2
{
AbstractValue
:
:
One
(
v1
)
}
else
{
AbstractValue
:
:
Many
}
}
}
}
fn
is_one
(
self
)
-
>
bool
{
if
let
AbstractValue
:
:
One
(
_
)
=
self
{
true
}
else
{
false
}
}
}
#
[
derive
(
Debug
)
]
struct
BlockSummary
{
formals
:
SmallVec
<
[
Value
;
4
]
>
dests
:
SmallVec
<
[
(
Inst
Block
SmallVec
<
[
Value
;
4
]
>
)
;
2
]
>
}
impl
BlockSummary
{
fn
new
(
formals
:
SmallVec
<
[
Value
;
4
]
>
)
-
>
Self
{
Self
{
formals
dests
:
smallvec
!
[
]
}
}
}
struct
SolverState
{
absvals
:
FxHashMap
<
Value
AbstractValue
>
}
impl
SolverState
{
fn
new
(
)
-
>
Self
{
Self
{
absvals
:
FxHashMap
:
:
default
(
)
}
}
fn
get
(
&
self
actual
:
Value
)
-
>
AbstractValue
{
match
self
.
absvals
.
get
(
&
actual
)
{
Some
(
lp
)
=
>
*
lp
None
=
>
panic
!
(
"
SolverState
:
:
get
:
formal
param
{
:
?
}
is
untracked
?
!
"
actual
)
}
}
fn
maybe_get
(
&
self
actual
:
Value
)
-
>
Option
<
&
AbstractValue
>
{
self
.
absvals
.
get
(
&
actual
)
}
fn
set
(
&
mut
self
actual
:
Value
lp
:
AbstractValue
)
{
match
self
.
absvals
.
insert
(
actual
lp
)
{
Some
(
_old_lp
)
=
>
{
}
None
=
>
panic
!
(
"
SolverState
:
:
set
:
formal
param
{
:
?
}
is
untracked
?
!
"
actual
)
}
}
}
#
[
inline
(
never
)
]
pub
fn
do_remove_constant_phis
(
func
:
&
mut
Function
domtree
:
&
mut
DominatorTree
)
{
let
_tt
=
timing
:
:
remove_constant_phis
(
)
;
debug_assert
!
(
domtree
.
is_valid
(
)
)
;
let
mut
blocks_reverse_postorder
=
Vec
:
:
<
Block
>
:
:
new
(
)
;
for
block
in
domtree
.
cfg_postorder
(
)
{
blocks_reverse_postorder
.
push
(
*
block
)
;
}
blocks_reverse_postorder
.
reverse
(
)
;
let
mut
summaries
=
FxHashMap
:
:
<
Block
BlockSummary
>
:
:
default
(
)
;
for
b
in
&
blocks_reverse_postorder
{
let
formals
=
func
.
dfg
.
block_params
(
*
b
)
;
let
mut
summary
=
BlockSummary
:
:
new
(
SmallVec
:
:
from
(
formals
)
)
;
for
inst
in
func
.
layout
.
block_insts
(
*
b
)
{
let
idetails
=
&
func
.
dfg
[
inst
]
;
if
let
BranchInfo
:
:
SingleDest
(
dest
_
)
=
idetails
.
analyze_branch
(
&
func
.
dfg
.
value_lists
)
{
let
inst_var_args
=
func
.
dfg
.
inst_variable_args
(
inst
)
;
if
inst_var_args
.
len
(
)
>
0
{
let
mut
actuals
=
SmallVec
:
:
<
[
Value
;
4
]
>
:
:
new
(
)
;
for
arg
in
inst_var_args
{
let
arg
=
func
.
dfg
.
resolve_aliases
(
*
arg
)
;
actuals
.
push
(
arg
)
;
}
summary
.
dests
.
push
(
(
inst
dest
actuals
)
)
;
}
}
}
if
formals
.
len
(
)
>
0
|
|
summary
.
dests
.
len
(
)
>
0
{
summaries
.
insert
(
*
b
summary
)
;
}
}
let
entry_block
=
func
.
layout
.
entry_block
(
)
.
expect
(
"
remove_constant_phis
:
entry
block
unknown
"
)
;
let
mut
state
=
SolverState
:
:
new
(
)
;
for
b
in
&
blocks_reverse_postorder
{
if
*
b
=
=
entry_block
{
continue
;
}
let
formals
:
&
[
Value
]
=
func
.
dfg
.
block_params
(
*
b
)
;
for
formal
in
formals
{
let
mb_old_absval
=
state
.
absvals
.
insert
(
*
formal
AbstractValue
:
:
None
)
;
assert
!
(
mb_old_absval
.
is_none
(
)
)
;
}
}
let
mut
iter_no
=
0
;
loop
{
iter_no
+
=
1
;
let
mut
changed
=
false
;
for
src
in
&
blocks_reverse_postorder
{
let
mb_src_summary
=
summaries
.
get
(
src
)
;
if
mb_src_summary
.
is_none
(
)
{
continue
;
}
let
src_summary
=
mb_src_summary
.
unwrap
(
)
;
for
(
_inst
dst
src_actuals
)
in
&
src_summary
.
dests
{
assert
!
(
*
dst
!
=
entry_block
)
;
let
dst_summary
=
summaries
.
get
(
dst
)
.
expect
(
"
remove_constant_phis
:
dst
block
has
no
summary
"
)
;
let
dst_formals
=
&
dst_summary
.
formals
;
assert
!
(
src_actuals
.
len
(
)
=
=
dst_formals
.
len
(
)
)
;
for
(
formal
actual
)
in
dst_formals
.
iter
(
)
.
zip
(
src_actuals
.
iter
(
)
)
{
let
actual_absval
=
match
state
.
maybe_get
(
*
actual
)
{
Some
(
pt
)
=
>
*
pt
None
=
>
AbstractValue
:
:
One
(
*
actual
)
}
;
let
formal_absval_old
=
state
.
get
(
*
formal
)
;
let
formal_absval_new
=
formal_absval_old
.
join
(
actual_absval
)
;
if
formal_absval_new
!
=
formal_absval_old
{
changed
=
true
;
state
.
set
(
*
formal
formal_absval_new
)
;
}
}
}
}
if
!
changed
{
break
;
}
}
let
mut
n_consts
=
0
;
for
absval
in
state
.
absvals
.
values
(
)
{
if
absval
.
is_one
(
)
{
n_consts
+
=
1
;
}
}
let
mut
need_editing
=
FxHashSet
:
:
<
Block
>
:
:
default
(
)
;
for
(
block
summary
)
in
&
summaries
{
if
*
block
=
=
entry_block
{
continue
;
}
for
formal
in
&
summary
.
formals
{
let
formal_absval
=
state
.
get
(
*
formal
)
;
if
formal_absval
.
is_one
(
)
{
need_editing
.
insert
(
*
block
)
;
break
;
}
}
}
for
b
in
&
need_editing
{
let
mut
del_these
=
SmallVec
:
:
<
[
(
Value
Value
)
;
32
]
>
:
:
new
(
)
;
let
formals
:
&
[
Value
]
=
func
.
dfg
.
block_params
(
*
b
)
;
for
formal
in
formals
{
if
let
AbstractValue
:
:
One
(
replacement_val
)
=
state
.
get
(
*
formal
)
{
del_these
.
push
(
(
*
formal
replacement_val
)
)
;
}
}
del_these
.
reverse
(
)
;
for
(
redundant_formal
replacement_val
)
in
del_these
{
func
.
dfg
.
remove_block_param
(
redundant_formal
)
;
func
.
dfg
.
change_to_alias
(
redundant_formal
replacement_val
)
;
}
}
for
(
_src_block
summary
)
in
&
summaries
{
for
(
inst
dst_block
_src_actuals
)
in
&
summary
.
dests
{
if
!
need_editing
.
contains
(
dst_block
)
{
continue
;
}
let
old_actuals
=
func
.
dfg
[
*
inst
]
.
take_value_list
(
)
.
unwrap
(
)
;
let
num_old_actuals
=
old_actuals
.
len
(
&
func
.
dfg
.
value_lists
)
;
let
num_fixed_actuals
=
func
.
dfg
[
*
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
let
dst_summary
=
summaries
.
get
(
&
dst_block
)
.
unwrap
(
)
;
assert
!
(
num_fixed_actuals
<
=
num_old_actuals
)
;
assert
!
(
num_fixed_actuals
+
dst_summary
.
formals
.
len
(
)
=
=
num_old_actuals
)
;
let
mut
new_actuals
=
EntityList
:
:
<
Value
>
:
:
new
(
)
;
for
i
in
0
.
.
num_fixed_actuals
{
let
val
=
old_actuals
.
get
(
i
&
func
.
dfg
.
value_lists
)
.
unwrap
(
)
;
new_actuals
.
push
(
val
&
mut
func
.
dfg
.
value_lists
)
;
}
for
i
in
0
.
.
dst_summary
.
formals
.
len
(
)
{
let
actual_i
=
old_actuals
.
get
(
num_fixed_actuals
+
i
&
func
.
dfg
.
value_lists
)
.
unwrap
(
)
;
let
formal_i
=
dst_summary
.
formals
[
i
]
;
let
is_redundant
=
state
.
get
(
formal_i
)
.
is_one
(
)
;
if
!
is_redundant
{
new_actuals
.
push
(
actual_i
&
mut
func
.
dfg
.
value_lists
)
;
}
}
func
.
dfg
[
*
inst
]
.
put_value_list
(
new_actuals
)
;
}
}
log
:
:
debug
!
(
"
do_remove_constant_phis
:
done
{
}
iters
.
{
}
formals
of
which
{
}
const
.
"
iter_no
state
.
absvals
.
len
(
)
n_consts
)
;
}
