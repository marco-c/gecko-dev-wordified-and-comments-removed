use
crate
:
:
binemit
:
:
{
CodeInfo
CodeOffset
}
;
use
crate
:
:
ir
:
:
condcodes
:
:
IntCC
;
use
crate
:
:
ir
:
:
{
Function
Type
}
;
use
crate
:
:
result
:
:
CodegenResult
;
use
crate
:
:
settings
:
:
Flags
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
fmt
:
:
Debug
;
use
regalloc
:
:
RegUsageCollector
;
use
regalloc
:
:
{
RealReg
RealRegUniverse
Reg
RegClass
RegUsageMapper
SpillSlot
VirtualReg
Writable
}
;
use
std
:
:
string
:
:
String
;
use
target_lexicon
:
:
Triple
;
pub
mod
lower
;
pub
use
lower
:
:
*
;
pub
mod
vcode
;
pub
use
vcode
:
:
*
;
pub
mod
compile
;
pub
use
compile
:
:
*
;
pub
mod
blockorder
;
pub
use
blockorder
:
:
*
;
pub
mod
abi
;
pub
use
abi
:
:
*
;
pub
mod
pretty_print
;
pub
use
pretty_print
:
:
*
;
pub
mod
sections
;
pub
use
sections
:
:
*
;
pub
mod
adapter
;
pub
use
adapter
:
:
*
;
pub
trait
MachInst
:
Clone
+
Debug
{
fn
get_regs
(
&
self
collector
:
&
mut
RegUsageCollector
)
;
fn
map_regs
(
&
mut
self
maps
:
&
RegUsageMapper
)
;
fn
is_move
(
&
self
)
-
>
Option
<
(
Writable
<
Reg
>
Reg
)
>
;
fn
is_term
<
'
a
>
(
&
'
a
self
)
-
>
MachTerminator
<
'
a
>
;
fn
is_epilogue_placeholder
(
&
self
)
-
>
bool
;
fn
gen_move
(
to_reg
:
Writable
<
Reg
>
from_reg
:
Reg
ty
:
Type
)
-
>
Self
;
fn
gen_zero_len_nop
(
)
-
>
Self
;
fn
maybe_direct_reload
(
&
self
reg
:
VirtualReg
slot
:
SpillSlot
)
-
>
Option
<
Self
>
;
fn
rc_for_type
(
ty
:
Type
)
-
>
CodegenResult
<
RegClass
>
;
fn
gen_jump
(
target
:
BlockIndex
)
-
>
Self
;
fn
gen_nop
(
preferred_size
:
usize
)
-
>
Self
;
fn
with_block_rewrites
(
&
mut
self
block_target_map
:
&
[
BlockIndex
]
)
;
fn
with_fallthrough_block
(
&
mut
self
fallthrough_block
:
Option
<
BlockIndex
>
)
;
fn
with_block_offsets
(
&
mut
self
my_offset
:
CodeOffset
targets
:
&
[
CodeOffset
]
)
;
fn
reg_universe
(
flags
:
&
Flags
)
-
>
RealRegUniverse
;
fn
align_basic_block
(
offset
:
CodeOffset
)
-
>
CodeOffset
{
offset
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
MachTerminator
<
'
a
>
{
None
Ret
Uncond
(
BlockIndex
)
Cond
(
BlockIndex
BlockIndex
)
Indirect
(
&
'
a
[
BlockIndex
]
)
}
pub
trait
MachInstEmit
<
O
:
MachSectionOutput
>
{
fn
emit
(
&
self
code
:
&
mut
O
flags
:
&
Flags
)
;
}
pub
struct
MachCompileResult
{
pub
sections
:
MachSections
pub
frame_size
:
u32
pub
disasm
:
Option
<
String
>
}
impl
MachCompileResult
{
pub
fn
code_info
(
&
self
)
-
>
CodeInfo
{
let
code_size
=
self
.
sections
.
total_size
(
)
;
CodeInfo
{
code_size
jumptables_size
:
0
rodata_size
:
0
total_size
:
code_size
}
}
}
pub
trait
MachBackend
{
fn
compile_function
(
&
self
func
:
&
Function
want_disasm
:
bool
)
-
>
CodegenResult
<
MachCompileResult
>
;
fn
flags
(
&
self
)
-
>
&
Flags
;
fn
triple
(
&
self
)
-
>
Triple
;
fn
name
(
&
self
)
-
>
&
'
static
str
;
fn
reg_universe
(
&
self
)
-
>
RealRegUniverse
;
fn
unsigned_add_overflow_condition
(
&
self
)
-
>
IntCC
{
IntCC
:
:
UnsignedLessThan
}
fn
unsigned_sub_overflow_condition
(
&
self
)
-
>
IntCC
{
IntCC
:
:
UnsignedLessThan
}
}
