use
crate
:
:
binemit
:
:
{
CodeInfo
CodeOffset
StackMap
}
;
use
crate
:
:
ir
:
:
condcodes
:
:
IntCC
;
use
crate
:
:
ir
:
:
{
Function
SourceLoc
Type
}
;
use
crate
:
:
isa
:
:
unwind
:
:
input
as
unwind_input
;
use
crate
:
:
result
:
:
CodegenResult
;
use
crate
:
:
settings
:
:
Flags
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
fmt
:
:
Debug
;
use
core
:
:
ops
:
:
Range
;
use
regalloc
:
:
RegUsageCollector
;
use
regalloc
:
:
{
RealReg
RealRegUniverse
Reg
RegClass
RegUsageMapper
SpillSlot
VirtualReg
Writable
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
string
:
:
String
;
use
target_lexicon
:
:
Triple
;
pub
mod
lower
;
pub
use
lower
:
:
*
;
pub
mod
vcode
;
pub
use
vcode
:
:
*
;
pub
mod
compile
;
pub
use
compile
:
:
*
;
pub
mod
blockorder
;
pub
use
blockorder
:
:
*
;
pub
mod
abi
;
pub
use
abi
:
:
*
;
pub
mod
abi_impl
;
pub
use
abi_impl
:
:
*
;
pub
mod
buffer
;
pub
use
buffer
:
:
*
;
pub
mod
adapter
;
pub
use
adapter
:
:
*
;
pub
mod
helpers
;
pub
use
helpers
:
:
*
;
pub
mod
inst_common
;
pub
use
inst_common
:
:
*
;
pub
trait
MachInst
:
Clone
+
Debug
{
fn
get_regs
(
&
self
collector
:
&
mut
RegUsageCollector
)
;
fn
map_regs
<
RUM
:
RegUsageMapper
>
(
&
mut
self
maps
:
&
RUM
)
;
fn
is_move
(
&
self
)
-
>
Option
<
(
Writable
<
Reg
>
Reg
)
>
;
fn
is_term
<
'
a
>
(
&
'
a
self
)
-
>
MachTerminator
<
'
a
>
;
fn
is_epilogue_placeholder
(
&
self
)
-
>
bool
;
fn
is_included_in_clobbers
(
&
self
)
-
>
bool
{
true
}
fn
gen_move
(
to_reg
:
Writable
<
Reg
>
from_reg
:
Reg
ty
:
Type
)
-
>
Self
;
fn
gen_constant
<
F
:
FnMut
(
RegClass
Type
)
-
>
Writable
<
Reg
>
>
(
to_reg
:
Writable
<
Reg
>
value
:
u64
ty
:
Type
alloc_tmp
:
F
)
-
>
SmallVec
<
[
Self
;
4
]
>
;
fn
gen_zero_len_nop
(
)
-
>
Self
;
fn
maybe_direct_reload
(
&
self
reg
:
VirtualReg
slot
:
SpillSlot
)
-
>
Option
<
Self
>
;
fn
rc_for_type
(
ty
:
Type
)
-
>
CodegenResult
<
RegClass
>
;
fn
gen_jump
(
target
:
MachLabel
)
-
>
Self
;
fn
gen_nop
(
preferred_size
:
usize
)
-
>
Self
;
fn
reg_universe
(
flags
:
&
Flags
)
-
>
RealRegUniverse
;
fn
align_basic_block
(
offset
:
CodeOffset
)
-
>
CodeOffset
{
offset
}
fn
worst_case_size
(
)
-
>
CodeOffset
;
fn
ref_type_regclass
(
_flags
:
&
Flags
)
-
>
RegClass
;
type
LabelUse
:
MachInstLabelUse
;
}
pub
trait
MachInstLabelUse
:
Clone
+
Copy
+
Debug
+
Eq
{
const
ALIGN
:
CodeOffset
;
fn
max_pos_range
(
self
)
-
>
CodeOffset
;
fn
max_neg_range
(
self
)
-
>
CodeOffset
;
fn
patch_size
(
self
)
-
>
CodeOffset
;
fn
patch
(
self
buffer
:
&
mut
[
u8
]
use_offset
:
CodeOffset
label_offset
:
CodeOffset
)
;
fn
supports_veneer
(
self
)
-
>
bool
;
fn
veneer_size
(
self
)
-
>
CodeOffset
;
fn
generate_veneer
(
self
buffer
:
&
mut
[
u8
]
veneer_offset
:
CodeOffset
)
-
>
(
CodeOffset
Self
)
;
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
MachTerminator
<
'
a
>
{
None
Ret
Uncond
(
MachLabel
)
Cond
(
MachLabel
MachLabel
)
Indirect
(
&
'
a
[
MachLabel
]
)
}
pub
trait
MachInstEmit
:
MachInst
{
type
State
:
MachInstEmitState
<
Self
>
;
type
Info
:
MachInstEmitInfo
;
type
UnwindInfo
:
UnwindInfoGenerator
<
Self
>
;
fn
emit
(
&
self
code
:
&
mut
MachBuffer
<
Self
>
info
:
&
Self
:
:
Info
state
:
&
mut
Self
:
:
State
)
;
fn
pretty_print
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
state
:
&
mut
Self
:
:
State
)
-
>
String
;
}
pub
trait
MachInstEmitInfo
{
fn
flags
(
&
self
)
-
>
&
Flags
;
}
pub
trait
MachInstEmitState
<
I
:
MachInst
>
:
Default
+
Clone
+
Debug
{
fn
new
(
abi
:
&
dyn
ABICallee
<
I
=
I
>
)
-
>
Self
;
fn
pre_safepoint
(
&
mut
self
_stack_map
:
StackMap
)
{
}
fn
pre_sourceloc
(
&
mut
self
_srcloc
:
SourceLoc
)
{
}
}
pub
struct
MachCompileResult
{
pub
buffer
:
MachBufferFinalized
pub
frame_size
:
u32
pub
disasm
:
Option
<
String
>
pub
unwind_info
:
Option
<
unwind_input
:
:
UnwindInfo
<
Reg
>
>
}
impl
MachCompileResult
{
pub
fn
code_info
(
&
self
)
-
>
CodeInfo
{
let
code_size
=
self
.
buffer
.
total_size
(
)
;
CodeInfo
{
code_size
jumptables_size
:
0
rodata_size
:
0
total_size
:
code_size
}
}
}
pub
trait
MachBackend
{
fn
compile_function
(
&
self
func
:
&
Function
want_disasm
:
bool
)
-
>
CodegenResult
<
MachCompileResult
>
;
fn
flags
(
&
self
)
-
>
&
Flags
;
fn
triple
(
&
self
)
-
>
Triple
;
fn
name
(
&
self
)
-
>
&
'
static
str
;
fn
reg_universe
(
&
self
)
-
>
&
RealRegUniverse
;
fn
unsigned_add_overflow_condition
(
&
self
)
-
>
IntCC
;
fn
unsigned_sub_overflow_condition
(
&
self
)
-
>
IntCC
;
#
[
cfg
(
feature
=
"
unwind
"
)
]
fn
emit_unwind_info
(
&
self
_result
:
&
MachCompileResult
_kind
:
UnwindInfoKind
)
-
>
CodegenResult
<
Option
<
crate
:
:
isa
:
:
unwind
:
:
UnwindInfo
>
>
{
Ok
(
None
)
}
#
[
cfg
(
feature
=
"
unwind
"
)
]
fn
create_systemv_cie
(
&
self
)
-
>
Option
<
gimli
:
:
write
:
:
CommonInformationEntry
>
{
None
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
enum
UnwindInfoKind
{
None
#
[
cfg
(
feature
=
"
unwind
"
)
]
SystemV
#
[
cfg
(
feature
=
"
unwind
"
)
]
Windows
}
pub
struct
UnwindInfoContext
<
'
a
Inst
:
MachInstEmit
>
{
pub
insts
:
&
'
a
[
Inst
]
pub
insts_layout
:
&
'
a
[
CodeOffset
]
pub
len
:
CodeOffset
pub
prologue
:
Range
<
u32
>
pub
epilogues
:
&
'
a
[
Range
<
u32
>
]
}
pub
trait
UnwindInfoGenerator
<
I
:
MachInstEmit
>
{
fn
create_unwind_info
(
context
:
UnwindInfoContext
<
I
>
)
-
>
CodegenResult
<
Option
<
unwind_input
:
:
UnwindInfo
<
Reg
>
>
>
;
}
