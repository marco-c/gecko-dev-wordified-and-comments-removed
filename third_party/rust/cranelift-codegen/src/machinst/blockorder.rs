use
crate
:
:
entity
:
:
SecondaryMap
;
use
crate
:
:
fx
:
:
{
FxHashMap
FxHashSet
}
;
use
crate
:
:
ir
:
:
{
Block
Function
Inst
Opcode
}
;
use
crate
:
:
machinst
:
:
lower
:
:
visit_block_succs
;
use
crate
:
:
machinst
:
:
*
;
use
log
:
:
debug
;
use
smallvec
:
:
SmallVec
;
#
[
derive
(
Debug
)
]
pub
struct
BlockLoweringOrder
{
lowered_order
:
Vec
<
LoweredBlock
>
lowered_succs
:
Vec
<
(
Inst
LoweredBlock
)
>
lowered_succ_indices
:
Vec
<
(
Inst
BlockIndex
)
>
lowered_succ_ranges
:
Vec
<
(
usize
usize
)
>
orig_map
:
SecondaryMap
<
Block
Option
<
BlockIndex
>
>
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
pub
enum
LoweredBlock
{
Orig
{
block
:
Block
}
OrigAndEdge
{
block
:
Block
edge_inst
:
Inst
succ
:
Block
}
EdgeAndOrig
{
pred
:
Block
edge_inst
:
Inst
block
:
Block
}
Edge
{
pred
:
Block
edge_inst
:
Inst
succ
:
Block
}
}
impl
LoweredBlock
{
pub
fn
orig_block
(
self
)
-
>
Option
<
Block
>
{
match
self
{
LoweredBlock
:
:
Orig
{
block
.
.
}
|
LoweredBlock
:
:
OrigAndEdge
{
block
.
.
}
|
LoweredBlock
:
:
EdgeAndOrig
{
block
.
.
}
=
>
Some
(
block
)
LoweredBlock
:
:
Edge
{
.
.
}
=
>
None
}
}
pub
fn
in_edge
(
self
)
-
>
Option
<
(
Block
Inst
Block
)
>
{
match
self
{
LoweredBlock
:
:
EdgeAndOrig
{
pred
edge_inst
block
}
=
>
Some
(
(
pred
edge_inst
block
)
)
_
=
>
None
}
}
pub
fn
out_edge
(
self
)
-
>
Option
<
(
Block
Inst
Block
)
>
{
match
self
{
LoweredBlock
:
:
OrigAndEdge
{
block
edge_inst
succ
}
=
>
Some
(
(
block
edge_inst
succ
)
)
LoweredBlock
:
:
Edge
{
pred
edge_inst
succ
}
=
>
Some
(
(
pred
edge_inst
succ
)
)
_
=
>
None
}
}
}
impl
BlockLoweringOrder
{
pub
fn
new
(
f
:
&
Function
)
-
>
BlockLoweringOrder
{
debug
!
(
"
BlockLoweringOrder
:
function
body
{
:
?
}
"
f
)
;
let
mut
block_in_count
=
SecondaryMap
:
:
with_default
(
0
)
;
let
mut
block_out_count
=
SecondaryMap
:
:
with_default
(
0
)
;
let
mut
block_succs
:
SmallVec
<
[
(
Inst
Block
)
;
128
]
>
=
SmallVec
:
:
new
(
)
;
let
mut
block_succ_range
=
SecondaryMap
:
:
with_default
(
(
0
0
)
)
;
let
mut
fallthrough_return_block
=
None
;
for
block
in
f
.
layout
.
blocks
(
)
{
let
block_succ_start
=
block_succs
.
len
(
)
;
visit_block_succs
(
f
block
|
inst
succ
|
{
block_out_count
[
block
]
+
=
1
;
block_in_count
[
succ
]
+
=
1
;
block_succs
.
push
(
(
inst
succ
)
)
;
}
)
;
let
block_succ_end
=
block_succs
.
len
(
)
;
block_succ_range
[
block
]
=
(
block_succ_start
block_succ_end
)
;
for
inst
in
f
.
layout
.
block_likely_branches
(
block
)
{
if
f
.
dfg
[
inst
]
.
opcode
(
)
=
=
Opcode
:
:
Return
{
block_out_count
[
block
]
+
=
1
;
}
if
f
.
dfg
[
inst
]
.
opcode
(
)
=
=
Opcode
:
:
FallthroughReturn
{
debug_assert
!
(
fallthrough_return_block
=
=
None
)
;
fallthrough_return_block
=
Some
(
block
)
;
}
}
}
if
let
Some
(
entry
)
=
f
.
layout
.
entry_block
(
)
{
block_in_count
[
entry
]
+
=
1
;
}
let
compute_lowered_succs
=
|
ret
:
&
mut
Vec
<
(
Inst
LoweredBlock
)
>
block
:
LoweredBlock
|
{
let
start_idx
=
ret
.
len
(
)
;
match
block
{
LoweredBlock
:
:
Orig
{
block
}
|
LoweredBlock
:
:
EdgeAndOrig
{
block
.
.
}
=
>
{
let
range
=
block_succ_range
[
block
]
;
for
&
(
edge_inst
succ
)
in
&
block_succs
[
range
.
0
.
.
range
.
1
]
{
if
block_in_count
[
succ
]
=
=
1
{
ret
.
push
(
(
edge_inst
LoweredBlock
:
:
EdgeAndOrig
{
pred
:
block
edge_inst
block
:
succ
}
)
)
;
}
else
{
ret
.
push
(
(
edge_inst
LoweredBlock
:
:
Edge
{
pred
:
block
edge_inst
succ
}
)
)
;
}
}
}
LoweredBlock
:
:
Edge
{
succ
edge_inst
.
.
}
|
LoweredBlock
:
:
OrigAndEdge
{
succ
edge_inst
.
.
}
=
>
{
if
block_out_count
[
succ
]
=
=
1
{
let
range
=
block_succ_range
[
succ
]
;
if
range
.
1
-
range
.
0
>
0
{
debug_assert
!
(
range
.
1
-
range
.
0
=
=
1
)
;
let
(
succ_edge_inst
succ_succ
)
=
block_succs
[
range
.
0
]
;
ret
.
push
(
(
edge_inst
LoweredBlock
:
:
OrigAndEdge
{
block
:
succ
edge_inst
:
succ_edge_inst
succ
:
succ_succ
}
)
)
;
}
else
{
ret
.
push
(
(
edge_inst
LoweredBlock
:
:
Orig
{
block
:
succ
}
)
)
;
}
}
else
{
ret
.
push
(
(
edge_inst
LoweredBlock
:
:
Orig
{
block
:
succ
}
)
)
;
}
}
}
let
end_idx
=
ret
.
len
(
)
;
(
start_idx
end_idx
)
}
;
let
mut
lowered_succs
=
vec
!
[
]
;
let
mut
lowered_succ_indices
=
vec
!
[
]
;
#
[
derive
(
Debug
)
]
struct
StackEntry
{
this
:
LoweredBlock
succs
:
(
usize
usize
)
cur_succ
:
usize
}
let
mut
stack
:
SmallVec
<
[
StackEntry
;
16
]
>
=
SmallVec
:
:
new
(
)
;
let
mut
visited
=
FxHashSet
:
:
default
(
)
;
let
mut
postorder
=
vec
!
[
]
;
if
let
Some
(
entry
)
=
f
.
layout
.
entry_block
(
)
{
let
block
=
LoweredBlock
:
:
Orig
{
block
:
entry
}
;
visited
.
insert
(
block
)
;
let
range
=
compute_lowered_succs
(
&
mut
lowered_succs
block
)
;
lowered_succ_indices
.
resize
(
lowered_succs
.
len
(
)
0
)
;
stack
.
push
(
StackEntry
{
this
:
block
succs
:
range
cur_succ
:
range
.
1
}
)
;
}
let
mut
deferred_last
=
None
;
while
!
stack
.
is_empty
(
)
{
let
stack_entry
=
stack
.
last_mut
(
)
.
unwrap
(
)
;
let
range
=
stack_entry
.
succs
;
if
stack_entry
.
cur_succ
=
=
range
.
0
{
let
orig_block
=
stack_entry
.
this
.
orig_block
(
)
;
if
orig_block
.
is_some
(
)
&
&
orig_block
=
=
fallthrough_return_block
{
deferred_last
=
Some
(
(
stack_entry
.
this
range
)
)
;
}
else
{
postorder
.
push
(
(
stack_entry
.
this
range
)
)
;
}
stack
.
pop
(
)
;
}
else
{
let
next
=
lowered_succs
[
stack_entry
.
cur_succ
-
1
]
.
1
;
stack_entry
.
cur_succ
-
=
1
;
if
visited
.
contains
(
&
next
)
{
continue
;
}
visited
.
insert
(
next
)
;
let
range
=
compute_lowered_succs
(
&
mut
lowered_succs
next
)
;
lowered_succ_indices
.
resize
(
lowered_succs
.
len
(
)
0
)
;
stack
.
push
(
StackEntry
{
this
:
next
succs
:
range
cur_succ
:
range
.
1
}
)
;
}
}
postorder
.
reverse
(
)
;
let
mut
rpo
=
postorder
;
if
let
Some
(
d
)
=
deferred_last
{
rpo
.
push
(
d
)
;
}
let
mut
lowered_order
=
vec
!
[
]
;
let
mut
lowered_succ_ranges
=
vec
!
[
]
;
let
mut
lb_to_bindex
=
FxHashMap
:
:
default
(
)
;
for
(
block
succ_range
)
in
rpo
.
into_iter
(
)
{
lb_to_bindex
.
insert
(
block
lowered_order
.
len
(
)
as
BlockIndex
)
;
lowered_order
.
push
(
block
)
;
lowered_succ_ranges
.
push
(
succ_range
)
;
}
let
lowered_succ_indices
=
lowered_succs
.
iter
(
)
.
map
(
|
&
(
inst
succ
)
|
(
inst
lb_to_bindex
.
get
(
&
succ
)
.
cloned
(
)
.
unwrap
(
)
)
)
.
collect
(
)
;
let
mut
orig_map
=
SecondaryMap
:
:
with_default
(
None
)
;
for
(
i
lb
)
in
lowered_order
.
iter
(
)
.
enumerate
(
)
{
let
i
=
i
as
BlockIndex
;
if
let
Some
(
b
)
=
lb
.
orig_block
(
)
{
orig_map
[
b
]
=
Some
(
i
)
;
}
}
let
result
=
BlockLoweringOrder
{
lowered_order
lowered_succs
lowered_succ_indices
lowered_succ_ranges
orig_map
}
;
debug
!
(
"
BlockLoweringOrder
:
{
:
?
}
"
result
)
;
result
}
pub
fn
lowered_order
(
&
self
)
-
>
&
[
LoweredBlock
]
{
&
self
.
lowered_order
[
.
.
]
}
pub
fn
succs
(
&
self
block
:
BlockIndex
)
-
>
&
[
(
Inst
LoweredBlock
)
]
{
let
range
=
self
.
lowered_succ_ranges
[
block
as
usize
]
;
&
self
.
lowered_succs
[
range
.
0
.
.
range
.
1
]
}
pub
fn
succ_indices
(
&
self
block
:
BlockIndex
)
-
>
&
[
(
Inst
BlockIndex
)
]
{
let
range
=
self
.
lowered_succ_ranges
[
block
as
usize
]
;
&
self
.
lowered_succ_indices
[
range
.
0
.
.
range
.
1
]
}
pub
fn
lowered_block_for_bb
(
&
self
bb
:
Block
)
-
>
Option
<
BlockIndex
>
{
self
.
orig_map
[
bb
]
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
crate
:
:
ir
:
:
types
:
:
*
;
use
crate
:
:
ir
:
:
{
AbiParam
ExternalName
Function
InstBuilder
Signature
}
;
use
crate
:
:
isa
:
:
CallConv
;
fn
build_test_func
(
n_blocks
:
usize
edges
:
&
[
(
usize
usize
)
]
)
-
>
Function
{
assert
!
(
n_blocks
>
0
)
;
let
name
=
ExternalName
:
:
testcase
(
"
test0
"
)
;
let
mut
sig
=
Signature
:
:
new
(
CallConv
:
:
SystemV
)
;
sig
.
params
.
push
(
AbiParam
:
:
new
(
I32
)
)
;
let
mut
func
=
Function
:
:
with_name_signature
(
name
sig
)
;
let
blocks
=
(
0
.
.
n_blocks
)
.
map
(
|
i
|
{
let
bb
=
func
.
dfg
.
make_block
(
)
;
assert
!
(
bb
.
as_u32
(
)
=
=
i
as
u32
)
;
bb
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
arg0
=
func
.
dfg
.
append_block_param
(
blocks
[
0
]
I32
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
&
mut
func
)
;
let
mut
edge
=
0
;
for
i
in
0
.
.
n_blocks
{
pos
.
insert_block
(
blocks
[
i
]
)
;
let
mut
succs
=
vec
!
[
]
;
while
edge
<
edges
.
len
(
)
&
&
edges
[
edge
]
.
0
=
=
i
{
succs
.
push
(
edges
[
edge
]
.
1
)
;
edge
+
=
1
;
}
if
succs
.
len
(
)
=
=
0
{
pos
.
ins
(
)
.
return_
(
&
[
arg0
]
)
;
}
else
if
succs
.
len
(
)
=
=
1
{
pos
.
ins
(
)
.
jump
(
blocks
[
succs
[
0
]
]
&
[
]
)
;
}
else
if
succs
.
len
(
)
=
=
2
{
pos
.
ins
(
)
.
brnz
(
arg0
blocks
[
succs
[
0
]
]
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
blocks
[
succs
[
1
]
]
&
[
]
)
;
}
else
{
panic
!
(
"
Too
many
successors
"
)
;
}
}
func
}
#
[
test
]
fn
test_blockorder_diamond
(
)
{
let
func
=
build_test_func
(
4
&
[
(
0
1
)
(
0
2
)
(
1
3
)
(
2
3
)
]
)
;
let
order
=
BlockLoweringOrder
:
:
new
(
&
func
)
;
assert_eq
!
(
order
.
lowered_order
.
len
(
)
6
)
;
assert
!
(
order
.
lowered_order
[
0
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
0
)
;
assert
!
(
order
.
lowered_order
[
0
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
0
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
in_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
0
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
in_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
orig_block
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
out_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
out_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
2
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
in_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
0
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
in_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
2
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
orig_block
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
out_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
2
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
out_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
out_edge
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_blockorder_critedge
(
)
{
let
func
=
build_test_func
(
7
&
[
(
0
1
)
(
0
2
)
(
1
3
)
(
1
4
)
(
2
5
)
(
3
5
)
(
3
6
)
(
4
6
)
]
)
;
let
order
=
BlockLoweringOrder
:
:
new
(
&
func
)
;
assert_eq
!
(
order
.
lowered_order
.
len
(
)
11
)
;
println
!
(
"
ordered
=
{
:
?
}
"
order
.
lowered_order
)
;
assert
!
(
order
.
lowered_order
[
0
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
0
)
;
assert
!
(
order
.
lowered_order
[
0
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
0
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
in_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
0
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
in_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
1
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
in_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
in_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
2
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
orig_block
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
out_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
3
]
.
out_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
5
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
orig_block
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
out_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
3
)
;
assert
!
(
order
.
lowered_order
[
4
]
.
out_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
6
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
4
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
in_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
1
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
in_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
4
)
;
assert
!
(
order
.
lowered_order
[
5
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
6
]
.
orig_block
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
6
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
6
]
.
out_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
4
)
;
assert
!
(
order
.
lowered_order
[
6
]
.
out_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
6
)
;
assert
!
(
order
.
lowered_order
[
7
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
6
)
;
assert
!
(
order
.
lowered_order
[
7
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
7
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
8
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
2
)
;
assert
!
(
order
.
lowered_order
[
8
]
.
in_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
0
)
;
assert
!
(
order
.
lowered_order
[
8
]
.
in_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
2
)
;
assert
!
(
order
.
lowered_order
[
8
]
.
out_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
9
]
.
orig_block
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
9
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
9
]
.
out_edge
(
)
.
unwrap
(
)
.
0
.
as_u32
(
)
=
=
2
)
;
assert
!
(
order
.
lowered_order
[
9
]
.
out_edge
(
)
.
unwrap
(
)
.
2
.
as_u32
(
)
=
=
5
)
;
assert
!
(
order
.
lowered_order
[
10
]
.
orig_block
(
)
.
unwrap
(
)
.
as_u32
(
)
=
=
5
)
;
assert
!
(
order
.
lowered_order
[
10
]
.
in_edge
(
)
.
is_none
(
)
)
;
assert
!
(
order
.
lowered_order
[
10
]
.
out_edge
(
)
.
is_none
(
)
)
;
}
}
