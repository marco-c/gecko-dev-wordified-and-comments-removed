use
crate
:
:
ir
:
:
ValueLabel
;
use
crate
:
:
machinst
:
:
*
;
use
crate
:
:
value_label
:
:
{
LabelValueLoc
ValueLabelsRanges
ValueLocRange
}
;
use
log
:
:
trace
;
use
regalloc
:
:
{
Reg
RegUsageCollector
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
hash
:
:
Hash
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
enum
ValueLoc
{
Reg
(
Reg
)
Stack
(
i64
)
}
impl
From
<
ValueLoc
>
for
LabelValueLoc
{
fn
from
(
v
:
ValueLoc
)
-
>
Self
{
match
v
{
ValueLoc
:
:
Reg
(
r
)
=
>
LabelValueLoc
:
:
Reg
(
r
)
ValueLoc
:
:
Stack
(
off
)
=
>
LabelValueLoc
:
:
SPOffset
(
off
)
}
}
}
impl
ValueLoc
{
fn
is_reg
(
self
)
-
>
bool
{
match
self
{
ValueLoc
:
:
Reg
(
_
)
=
>
true
_
=
>
false
}
}
fn
is_stack
(
self
)
-
>
bool
{
match
self
{
ValueLoc
:
:
Stack
(
_
)
=
>
true
_
=
>
false
}
}
}
#
[
derive
(
Clone
Debug
)
]
struct
AnalysisInfo
{
nominal_sp_offset
:
Option
<
i64
>
label_to_locs
:
HashMap
<
ValueLabel
HashSet
<
ValueLoc
>
>
reg_to_label
:
HashMap
<
Reg
ValueLabel
>
stack_to_label
:
HashMap
<
i64
ValueLabel
>
}
fn
get_inst_writes
<
M
:
MachInst
>
(
m
:
&
M
)
-
>
Vec
<
Reg
>
{
let
mut
vecs
=
RegUsageCollector
:
:
get_empty_reg_vecs_test_framework_only
(
false
)
;
let
mut
coll
=
RegUsageCollector
:
:
new
(
&
mut
vecs
)
;
m
.
get_regs
(
&
mut
coll
)
;
vecs
.
defs
.
extend
(
vecs
.
mods
.
into_iter
(
)
)
;
vecs
.
defs
}
impl
AnalysisInfo
{
fn
new
(
)
-
>
Self
{
AnalysisInfo
{
nominal_sp_offset
:
Some
(
0
)
label_to_locs
:
HashMap
:
:
new
(
)
reg_to_label
:
HashMap
:
:
new
(
)
stack_to_label
:
HashMap
:
:
new
(
)
}
}
fn
clear_label
(
&
mut
self
label
:
ValueLabel
)
{
if
let
Some
(
locs
)
=
self
.
label_to_locs
.
remove
(
&
label
)
{
for
loc
in
locs
{
match
loc
{
ValueLoc
:
:
Reg
(
r
)
=
>
{
self
.
reg_to_label
.
remove
(
&
r
)
;
}
ValueLoc
:
:
Stack
(
off
)
=
>
{
self
.
stack_to_label
.
remove
(
&
off
)
;
}
}
}
}
}
fn
clear_reg
(
&
mut
self
reg
:
Reg
)
{
if
let
Some
(
label
)
=
self
.
reg_to_label
.
remove
(
&
reg
)
{
if
let
Some
(
locs
)
=
self
.
label_to_locs
.
get_mut
(
&
label
)
{
locs
.
remove
(
&
ValueLoc
:
:
Reg
(
reg
)
)
;
}
}
}
fn
clear_stack_off
(
&
mut
self
off
:
i64
)
{
if
let
Some
(
label
)
=
self
.
stack_to_label
.
remove
(
&
off
)
{
if
let
Some
(
locs
)
=
self
.
label_to_locs
.
get_mut
(
&
label
)
{
locs
.
remove
(
&
ValueLoc
:
:
Stack
(
off
)
)
;
}
}
}
fn
def_label_at_reg
(
&
mut
self
label
:
ValueLabel
reg
:
Reg
)
{
self
.
clear_label
(
label
)
;
self
.
label_to_locs
.
entry
(
label
)
.
or_insert_with
(
|
|
HashSet
:
:
new
(
)
)
.
insert
(
ValueLoc
:
:
Reg
(
reg
)
)
;
self
.
reg_to_label
.
insert
(
reg
label
)
;
}
fn
store_reg
(
&
mut
self
reg
:
Reg
off
:
i64
)
{
self
.
clear_stack_off
(
off
)
;
if
let
Some
(
label
)
=
self
.
reg_to_label
.
get
(
&
reg
)
{
if
let
Some
(
locs
)
=
self
.
label_to_locs
.
get_mut
(
label
)
{
locs
.
insert
(
ValueLoc
:
:
Stack
(
off
)
)
;
}
self
.
stack_to_label
.
insert
(
off
*
label
)
;
}
}
fn
load_reg
(
&
mut
self
reg
:
Reg
off
:
i64
)
{
self
.
clear_reg
(
reg
)
;
if
let
Some
(
&
label
)
=
self
.
stack_to_label
.
get
(
&
off
)
{
if
let
Some
(
locs
)
=
self
.
label_to_locs
.
get_mut
(
&
label
)
{
locs
.
insert
(
ValueLoc
:
:
Reg
(
reg
)
)
;
}
self
.
reg_to_label
.
insert
(
reg
label
)
;
}
}
fn
move_reg
(
&
mut
self
to
:
Reg
from
:
Reg
)
{
self
.
clear_reg
(
to
)
;
if
let
Some
(
&
label
)
=
self
.
reg_to_label
.
get
(
&
from
)
{
if
let
Some
(
locs
)
=
self
.
label_to_locs
.
get_mut
(
&
label
)
{
locs
.
insert
(
ValueLoc
:
:
Reg
(
to
)
)
;
}
self
.
reg_to_label
.
insert
(
to
label
)
;
}
}
fn
step
<
M
:
MachInst
>
(
&
mut
self
inst
:
&
M
)
{
for
write
in
get_inst_writes
(
inst
)
{
self
.
clear_reg
(
write
)
;
}
if
let
Some
(
(
label
reg
)
)
=
inst
.
defines_value_label
(
)
{
self
.
def_label_at_reg
(
label
reg
)
;
}
match
inst
.
stack_op_info
(
)
{
Some
(
MachInstStackOpInfo
:
:
LoadNomSPOff
(
reg
offset
)
)
=
>
{
self
.
load_reg
(
reg
offset
+
self
.
nominal_sp_offset
.
unwrap
(
)
)
;
}
Some
(
MachInstStackOpInfo
:
:
StoreNomSPOff
(
reg
offset
)
)
=
>
{
self
.
store_reg
(
reg
offset
+
self
.
nominal_sp_offset
.
unwrap
(
)
)
;
}
Some
(
MachInstStackOpInfo
:
:
NomSPAdj
(
offset
)
)
=
>
{
if
self
.
nominal_sp_offset
.
is_some
(
)
{
self
.
nominal_sp_offset
=
Some
(
self
.
nominal_sp_offset
.
unwrap
(
)
+
offset
)
;
}
}
_
=
>
{
}
}
if
let
Some
(
(
to
from
)
)
=
inst
.
is_move
(
)
{
let
to
=
to
.
to_reg
(
)
;
self
.
move_reg
(
to
from
)
;
}
}
}
trait
IntersectFrom
{
fn
intersect_from
(
&
mut
self
other
:
&
Self
)
-
>
IntersectResult
;
}
struct
IntersectResult
{
changed
:
bool
is_empty
:
bool
}
impl
IntersectFrom
for
AnalysisInfo
{
fn
intersect_from
(
&
mut
self
other
:
&
Self
)
-
>
IntersectResult
{
let
mut
changed
=
false
;
changed
|
=
self
.
nominal_sp_offset
.
intersect_from
(
&
other
.
nominal_sp_offset
)
.
changed
;
changed
|
=
self
.
label_to_locs
.
intersect_from
(
&
other
.
label_to_locs
)
.
changed
;
changed
|
=
self
.
reg_to_label
.
intersect_from
(
&
other
.
reg_to_label
)
.
changed
;
changed
|
=
self
.
stack_to_label
.
intersect_from
(
&
other
.
stack_to_label
)
.
changed
;
IntersectResult
{
changed
is_empty
:
false
}
}
}
impl
<
K
V
>
IntersectFrom
for
HashMap
<
K
V
>
where
K
:
Copy
+
Eq
+
Hash
V
:
IntersectFrom
{
fn
intersect_from
(
&
mut
self
other
:
&
Self
)
-
>
IntersectResult
{
let
mut
changed
=
false
;
let
mut
remove_keys
=
vec
!
[
]
;
for
k
in
self
.
keys
(
)
{
if
!
other
.
contains_key
(
k
)
{
remove_keys
.
push
(
*
k
)
;
}
}
for
k
in
&
remove_keys
{
changed
=
true
;
self
.
remove
(
k
)
;
}
remove_keys
.
clear
(
)
;
for
k
in
other
.
keys
(
)
{
if
let
Some
(
v
)
=
self
.
get_mut
(
k
)
{
let
result
=
v
.
intersect_from
(
other
.
get
(
k
)
.
unwrap
(
)
)
;
changed
|
=
result
.
changed
;
if
result
.
is_empty
{
remove_keys
.
push
(
*
k
)
;
}
}
}
for
k
in
&
remove_keys
{
changed
=
true
;
self
.
remove
(
k
)
;
}
IntersectResult
{
changed
is_empty
:
self
.
len
(
)
=
=
0
}
}
}
impl
<
T
>
IntersectFrom
for
HashSet
<
T
>
where
T
:
Copy
+
Eq
+
Hash
{
fn
intersect_from
(
&
mut
self
other
:
&
Self
)
-
>
IntersectResult
{
let
mut
changed
=
false
;
let
mut
remove
=
vec
!
[
]
;
for
val
in
self
.
iter
(
)
{
if
!
other
.
contains
(
val
)
{
remove
.
push
(
*
val
)
;
}
}
for
val
in
remove
{
changed
=
true
;
self
.
remove
(
&
val
)
;
}
IntersectResult
{
changed
is_empty
:
self
.
len
(
)
=
=
0
}
}
}
impl
IntersectFrom
for
ValueLabel
{
fn
intersect_from
(
&
mut
self
other
:
&
Self
)
-
>
IntersectResult
{
IntersectResult
{
changed
:
false
is_empty
:
*
self
!
=
*
other
}
}
}
impl
<
T
>
IntersectFrom
for
Option
<
T
>
where
T
:
Copy
+
Eq
{
fn
intersect_from
(
&
mut
self
other
:
&
Self
)
-
>
IntersectResult
{
let
mut
changed
=
false
;
if
!
(
self
.
is_some
(
)
&
&
other
.
is_some
(
)
&
&
self
=
=
other
)
{
changed
=
true
;
*
self
=
None
;
}
IntersectResult
{
changed
is_empty
:
self
.
is_none
(
)
}
}
}
pub
(
crate
)
fn
compute
<
I
:
VCodeInst
>
(
insts
:
&
[
I
]
inst_ends
:
&
[
u32
]
label_insn_index
:
&
[
u32
]
)
-
>
ValueLabelsRanges
{
let
inst_start
=
|
idx
:
usize
|
if
idx
=
=
0
{
0
}
else
{
inst_ends
[
idx
-
1
]
}
;
trace
!
(
"
compute
:
insts
=
"
)
;
for
i
in
0
.
.
insts
.
len
(
)
{
trace
!
(
"
#
{
}
end
:
{
}
-
>
{
:
?
}
"
i
inst_ends
[
i
]
insts
[
i
]
)
;
}
trace
!
(
"
label_insn_index
:
{
:
?
}
"
label_insn_index
)
;
let
mut
block_starts
:
HashMap
<
u32
AnalysisInfo
>
=
HashMap
:
:
new
(
)
;
block_starts
.
insert
(
0
AnalysisInfo
:
:
new
(
)
)
;
let
mut
worklist
=
Vec
:
:
new
(
)
;
let
mut
worklist_set
=
HashSet
:
:
new
(
)
;
worklist
.
push
(
0
)
;
worklist_set
.
insert
(
0
)
;
while
!
worklist
.
is_empty
(
)
{
let
block
=
worklist
.
pop
(
)
.
unwrap
(
)
;
worklist_set
.
remove
(
&
block
)
;
let
mut
state
=
block_starts
.
get
(
&
block
)
.
unwrap
(
)
.
clone
(
)
;
trace
!
(
"
at
block
{
}
-
>
state
:
{
:
?
}
"
block
state
)
;
let
mut
index
=
label_insn_index
[
block
as
usize
]
;
while
index
<
insts
.
len
(
)
as
u32
{
state
.
step
(
&
insts
[
index
as
usize
]
)
;
trace
!
(
"
-
>
inst
#
{
}
:
{
:
?
}
"
index
insts
[
index
as
usize
]
)
;
trace
!
(
"
-
-
>
state
:
{
:
?
}
"
state
)
;
let
term
=
insts
[
index
as
usize
]
.
is_term
(
)
;
if
term
.
is_term
(
)
{
for
succ
in
term
.
get_succs
(
)
{
trace
!
(
"
SUCCESSOR
block
{
}
"
succ
.
get
(
)
)
;
if
let
Some
(
succ_state
)
=
block_starts
.
get_mut
(
&
succ
.
get
(
)
)
{
trace
!
(
"
orig
state
:
{
:
?
}
"
succ_state
)
;
if
succ_state
.
intersect_from
(
&
state
)
.
changed
{
if
worklist_set
.
insert
(
succ
.
get
(
)
)
{
worklist
.
push
(
succ
.
get
(
)
)
;
}
trace
!
(
"
(
changed
)
"
)
;
}
trace
!
(
"
new
state
:
{
:
?
}
"
succ_state
)
;
}
else
{
block_starts
.
insert
(
succ
.
get
(
)
state
.
clone
(
)
)
;
worklist
.
push
(
succ
.
get
(
)
)
;
worklist_set
.
insert
(
succ
.
get
(
)
)
;
}
}
break
;
}
index
+
=
1
;
}
}
let
mut
value_labels_ranges
:
ValueLabelsRanges
=
HashMap
:
:
new
(
)
;
for
block
in
0
.
.
label_insn_index
.
len
(
)
{
let
start_index
=
label_insn_index
[
block
]
;
let
end_index
=
if
block
=
=
label_insn_index
.
len
(
)
-
1
{
insts
.
len
(
)
as
u32
}
else
{
label_insn_index
[
block
+
1
]
}
;
let
block
=
block
as
u32
;
let
mut
state
=
block_starts
.
get
(
&
block
)
.
unwrap
(
)
.
clone
(
)
;
for
index
in
start_index
.
.
end_index
{
let
offset
=
inst_start
(
index
as
usize
)
;
let
end
=
inst_ends
[
index
as
usize
]
;
state
.
step
(
&
insts
[
index
as
usize
]
)
;
for
(
label
locs
)
in
&
state
.
label_to_locs
{
trace
!
(
"
inst
{
}
has
label
{
:
?
}
-
>
locs
{
:
?
}
"
index
label
locs
)
;
let
reg
=
locs
.
iter
(
)
.
cloned
(
)
.
find
(
|
l
|
l
.
is_reg
(
)
)
;
let
loc
=
reg
.
or_else
(
|
|
locs
.
iter
(
)
.
cloned
(
)
.
find
(
|
l
|
l
.
is_stack
(
)
)
)
;
if
let
Some
(
loc
)
=
loc
{
let
loc
=
LabelValueLoc
:
:
from
(
loc
)
;
let
list
=
value_labels_ranges
.
entry
(
*
label
)
.
or_insert_with
(
|
|
vec
!
[
]
)
;
if
list
.
last
(
)
.
map
(
|
last
|
last
.
end
<
=
offset
|
|
last
.
loc
!
=
loc
)
.
unwrap_or
(
true
)
{
list
.
push
(
ValueLocRange
{
loc
start
:
end
end
:
end
+
1
}
)
;
}
else
{
list
.
last_mut
(
)
.
unwrap
(
)
.
end
=
end
+
1
;
}
}
}
}
}
trace
!
(
"
ret
:
{
:
?
}
"
value_labels_ranges
)
;
value_labels_ranges
}
