use
crate
:
:
binemit
:
:
{
Addend
CodeOffset
CodeSink
Reloc
}
;
use
crate
:
:
ir
:
:
{
ExternalName
Opcode
SourceLoc
TrapCode
}
;
use
alloc
:
:
vec
:
:
Vec
;
pub
struct
MachSections
{
pub
sections
:
Vec
<
MachSection
>
}
impl
MachSections
{
pub
fn
new
(
)
-
>
MachSections
{
MachSections
{
sections
:
vec
!
[
]
}
}
pub
fn
add_section
(
&
mut
self
start
:
CodeOffset
length
:
CodeOffset
)
-
>
usize
{
let
idx
=
self
.
sections
.
len
(
)
;
self
.
sections
.
push
(
MachSection
:
:
new
(
start
length
)
)
;
idx
}
pub
fn
get_section
<
'
a
>
(
&
'
a
mut
self
idx
:
usize
)
-
>
&
'
a
mut
MachSection
{
&
mut
self
.
sections
[
idx
]
}
pub
fn
two_sections
<
'
a
>
(
&
'
a
mut
self
idx1
:
usize
idx2
:
usize
)
-
>
(
&
'
a
mut
MachSection
&
'
a
mut
MachSection
)
{
assert
!
(
idx1
<
idx2
)
;
assert
!
(
idx1
<
self
.
sections
.
len
(
)
)
;
assert
!
(
idx2
<
self
.
sections
.
len
(
)
)
;
let
(
first
rest
)
=
self
.
sections
.
split_at_mut
(
idx2
)
;
(
&
mut
first
[
idx1
]
&
mut
rest
[
0
]
)
}
pub
fn
emit
<
CS
:
CodeSink
>
(
&
self
sink
:
&
mut
CS
)
{
for
section
in
&
self
.
sections
{
if
section
.
data
.
len
(
)
>
0
{
while
sink
.
offset
(
)
<
section
.
start_offset
{
sink
.
put1
(
0
)
;
}
section
.
emit
(
sink
)
;
}
}
sink
.
begin_jumptables
(
)
;
sink
.
begin_rodata
(
)
;
sink
.
end_codegen
(
)
;
}
pub
fn
get_srclocs_sorted
<
'
a
>
(
&
'
a
self
)
-
>
MachSectionsSrcLocs
<
'
a
>
{
MachSectionsSrcLocs
:
:
new
(
&
self
.
sections
)
}
pub
fn
total_size
(
&
self
)
-
>
CodeOffset
{
if
self
.
sections
.
len
(
)
=
=
0
{
0
}
else
{
self
.
sections
.
iter
(
)
.
rev
(
)
.
find
(
|
s
|
s
.
data
.
len
(
)
>
0
)
.
map
(
|
s
|
s
.
cur_offset_from_start
(
)
)
.
unwrap_or
(
0
)
}
}
}
pub
struct
MachSectionsSrcLocs
<
'
a
>
{
sections
:
&
'
a
[
MachSection
]
cur_section
:
usize
cur_srcloc
:
usize
last_offset
:
CodeOffset
}
impl
<
'
a
>
MachSectionsSrcLocs
<
'
a
>
{
fn
new
(
sections
:
&
'
a
[
MachSection
]
)
-
>
MachSectionsSrcLocs
<
'
a
>
{
MachSectionsSrcLocs
{
sections
cur_section
:
0
cur_srcloc
:
0
last_offset
:
0
}
}
}
impl
<
'
a
>
Iterator
for
MachSectionsSrcLocs
<
'
a
>
{
type
Item
=
&
'
a
MachSrcLoc
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
MachSrcLoc
>
{
if
self
.
cur_section
>
=
self
.
sections
.
len
(
)
{
return
None
;
}
while
self
.
cur_srcloc
>
=
self
.
sections
[
self
.
cur_section
]
.
srclocs
.
len
(
)
{
self
.
cur_srcloc
=
0
;
self
.
cur_section
+
=
1
;
if
self
.
cur_section
>
=
self
.
sections
.
len
(
)
{
return
None
;
}
}
let
loc
=
&
self
.
sections
[
self
.
cur_section
]
.
srclocs
[
self
.
cur_srcloc
]
;
self
.
cur_srcloc
+
=
1
;
debug_assert
!
(
loc
.
start
>
=
self
.
last_offset
)
;
self
.
last_offset
=
loc
.
start
;
Some
(
loc
)
}
}
pub
trait
MachSectionOutput
{
fn
cur_offset_from_start
(
&
self
)
-
>
CodeOffset
;
fn
start_offset
(
&
self
)
-
>
CodeOffset
;
fn
put1
(
&
mut
self
_
:
u8
)
;
fn
put2
(
&
mut
self
value
:
u16
)
{
let
[
b0
b1
]
=
value
.
to_le_bytes
(
)
;
self
.
put1
(
b0
)
;
self
.
put1
(
b1
)
;
}
fn
put4
(
&
mut
self
value
:
u32
)
{
let
[
b0
b1
b2
b3
]
=
value
.
to_le_bytes
(
)
;
self
.
put1
(
b0
)
;
self
.
put1
(
b1
)
;
self
.
put1
(
b2
)
;
self
.
put1
(
b3
)
;
}
fn
put8
(
&
mut
self
value
:
u64
)
{
let
[
b0
b1
b2
b3
b4
b5
b6
b7
]
=
value
.
to_le_bytes
(
)
;
self
.
put1
(
b0
)
;
self
.
put1
(
b1
)
;
self
.
put1
(
b2
)
;
self
.
put1
(
b3
)
;
self
.
put1
(
b4
)
;
self
.
put1
(
b5
)
;
self
.
put1
(
b6
)
;
self
.
put1
(
b7
)
;
}
fn
put_data
(
&
mut
self
data
:
&
[
u8
]
)
;
fn
add_reloc
(
&
mut
self
loc
:
SourceLoc
kind
:
Reloc
name
:
&
ExternalName
addend
:
Addend
)
;
fn
add_trap
(
&
mut
self
loc
:
SourceLoc
code
:
TrapCode
)
;
fn
add_call_site
(
&
mut
self
loc
:
SourceLoc
opcode
:
Opcode
)
;
fn
start_srcloc
(
&
mut
self
loc
:
SourceLoc
)
;
fn
end_srcloc
(
&
mut
self
)
;
fn
align_to
(
&
mut
self
align_to
:
CodeOffset
)
{
assert
!
(
align_to
.
is_power_of_two
(
)
)
;
while
self
.
cur_offset_from_start
(
)
&
(
align_to
-
1
)
!
=
0
{
self
.
put1
(
0
)
;
}
}
}
pub
struct
MachSection
{
pub
start_offset
:
CodeOffset
pub
length_limit
:
CodeOffset
pub
data
:
Vec
<
u8
>
pub
relocs
:
Vec
<
MachReloc
>
pub
traps
:
Vec
<
MachTrap
>
pub
call_sites
:
Vec
<
MachCallSite
>
pub
srclocs
:
Vec
<
MachSrcLoc
>
pub
cur_srcloc
:
Option
<
(
CodeOffset
SourceLoc
)
>
}
impl
MachSection
{
pub
fn
new
(
start_offset
:
CodeOffset
length_limit
:
CodeOffset
)
-
>
MachSection
{
MachSection
{
start_offset
length_limit
data
:
vec
!
[
]
relocs
:
vec
!
[
]
traps
:
vec
!
[
]
call_sites
:
vec
!
[
]
srclocs
:
vec
!
[
]
cur_srcloc
:
None
}
}
pub
fn
emit
<
CS
:
CodeSink
>
(
&
self
sink
:
&
mut
CS
)
{
assert
!
(
sink
.
offset
(
)
=
=
self
.
start_offset
)
;
let
mut
next_reloc
=
0
;
let
mut
next_trap
=
0
;
let
mut
next_call_site
=
0
;
for
(
idx
byte
)
in
self
.
data
.
iter
(
)
.
enumerate
(
)
{
if
next_reloc
<
self
.
relocs
.
len
(
)
{
let
reloc
=
&
self
.
relocs
[
next_reloc
]
;
if
reloc
.
offset
=
=
idx
as
CodeOffset
{
sink
.
reloc_external
(
reloc
.
srcloc
reloc
.
kind
&
reloc
.
name
reloc
.
addend
)
;
next_reloc
+
=
1
;
}
}
if
next_trap
<
self
.
traps
.
len
(
)
{
let
trap
=
&
self
.
traps
[
next_trap
]
;
if
trap
.
offset
=
=
idx
as
CodeOffset
{
sink
.
trap
(
trap
.
code
trap
.
srcloc
)
;
next_trap
+
=
1
;
}
}
if
next_call_site
<
self
.
call_sites
.
len
(
)
{
let
call_site
=
&
self
.
call_sites
[
next_call_site
]
;
if
call_site
.
ret_addr
=
=
idx
as
CodeOffset
{
sink
.
add_call_site
(
call_site
.
opcode
call_site
.
srcloc
)
;
next_call_site
+
=
1
;
}
}
sink
.
put1
(
*
byte
)
;
}
}
}
impl
MachSectionOutput
for
MachSection
{
fn
cur_offset_from_start
(
&
self
)
-
>
CodeOffset
{
self
.
start_offset
+
self
.
data
.
len
(
)
as
CodeOffset
}
fn
start_offset
(
&
self
)
-
>
CodeOffset
{
self
.
start_offset
}
fn
put1
(
&
mut
self
value
:
u8
)
{
assert
!
(
(
(
self
.
data
.
len
(
)
+
1
)
as
CodeOffset
)
<
=
self
.
length_limit
)
;
self
.
data
.
push
(
value
)
;
}
fn
put_data
(
&
mut
self
data
:
&
[
u8
]
)
{
assert
!
(
(
(
self
.
data
.
len
(
)
+
data
.
len
(
)
)
as
CodeOffset
)
<
=
self
.
length_limit
)
;
self
.
data
.
extend_from_slice
(
data
)
;
}
fn
add_reloc
(
&
mut
self
srcloc
:
SourceLoc
kind
:
Reloc
name
:
&
ExternalName
addend
:
Addend
)
{
let
name
=
name
.
clone
(
)
;
self
.
relocs
.
push
(
MachReloc
{
offset
:
self
.
data
.
len
(
)
as
CodeOffset
srcloc
kind
name
addend
}
)
;
}
fn
add_trap
(
&
mut
self
srcloc
:
SourceLoc
code
:
TrapCode
)
{
self
.
traps
.
push
(
MachTrap
{
offset
:
self
.
data
.
len
(
)
as
CodeOffset
srcloc
code
}
)
;
}
fn
add_call_site
(
&
mut
self
srcloc
:
SourceLoc
opcode
:
Opcode
)
{
self
.
call_sites
.
push
(
MachCallSite
{
ret_addr
:
self
.
data
.
len
(
)
as
CodeOffset
srcloc
opcode
}
)
;
}
fn
start_srcloc
(
&
mut
self
loc
:
SourceLoc
)
{
self
.
cur_srcloc
=
Some
(
(
self
.
cur_offset_from_start
(
)
loc
)
)
;
}
fn
end_srcloc
(
&
mut
self
)
{
let
(
start
loc
)
=
self
.
cur_srcloc
.
take
(
)
.
expect
(
"
end_srcloc
(
)
called
without
start_srcloc
(
)
"
)
;
let
end
=
self
.
cur_offset_from_start
(
)
;
debug_assert
!
(
end
>
=
start
)
;
if
end
>
start
{
self
.
srclocs
.
push
(
MachSrcLoc
{
start
end
loc
}
)
;
}
}
}
pub
struct
MachSectionSize
{
pub
start_offset
:
CodeOffset
pub
offset
:
CodeOffset
}
impl
MachSectionSize
{
pub
fn
new
(
start_offset
:
CodeOffset
)
-
>
MachSectionSize
{
MachSectionSize
{
start_offset
offset
:
start_offset
}
}
pub
fn
size
(
&
self
)
-
>
CodeOffset
{
self
.
offset
-
self
.
start_offset
}
}
impl
MachSectionOutput
for
MachSectionSize
{
fn
cur_offset_from_start
(
&
self
)
-
>
CodeOffset
{
self
.
offset
}
fn
start_offset
(
&
self
)
-
>
CodeOffset
{
self
.
start_offset
}
fn
put1
(
&
mut
self
_
:
u8
)
{
self
.
offset
+
=
1
;
}
fn
put_data
(
&
mut
self
data
:
&
[
u8
]
)
{
self
.
offset
+
=
data
.
len
(
)
as
CodeOffset
;
}
fn
add_reloc
(
&
mut
self
_
:
SourceLoc
_
:
Reloc
_
:
&
ExternalName
_
:
Addend
)
{
}
fn
add_trap
(
&
mut
self
_
:
SourceLoc
_
:
TrapCode
)
{
}
fn
add_call_site
(
&
mut
self
_
:
SourceLoc
_
:
Opcode
)
{
}
fn
start_srcloc
(
&
mut
self
_
:
SourceLoc
)
{
}
fn
end_srcloc
(
&
mut
self
)
{
}
}
pub
struct
MachReloc
{
pub
offset
:
CodeOffset
pub
srcloc
:
SourceLoc
pub
kind
:
Reloc
pub
name
:
ExternalName
pub
addend
:
i64
}
pub
struct
MachTrap
{
pub
offset
:
CodeOffset
pub
srcloc
:
SourceLoc
pub
code
:
TrapCode
}
pub
struct
MachCallSite
{
pub
ret_addr
:
CodeOffset
pub
srcloc
:
SourceLoc
pub
opcode
:
Opcode
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
MachSrcLoc
{
pub
start
:
CodeOffset
pub
end
:
CodeOffset
pub
loc
:
SourceLoc
}
