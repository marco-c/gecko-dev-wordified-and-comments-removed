use
crate
:
:
ir
:
:
Function
;
use
crate
:
:
machinst
:
:
*
;
use
crate
:
:
settings
;
use
crate
:
:
timing
;
use
log
:
:
debug
;
use
regalloc
:
:
{
allocate_registers_with_opts
Algorithm
Options
}
;
pub
fn
compile
<
B
:
LowerBackend
+
MachBackend
>
(
f
:
&
Function
b
:
&
B
abi
:
Box
<
dyn
ABIBody
<
I
=
B
:
:
MInst
>
>
)
-
>
CodegenResult
<
VCode
<
B
:
:
MInst
>
>
where
B
:
:
MInst
:
ShowWithRRU
{
let
block_order
=
BlockLoweringOrder
:
:
new
(
f
)
;
let
lower
=
Lower
:
:
new
(
f
abi
block_order
)
?
;
let
mut
vcode
=
lower
.
lower
(
b
)
?
;
debug
!
(
"
vcode
from
lowering
:
\
n
{
}
"
vcode
.
show_rru
(
Some
(
b
.
reg_universe
(
)
)
)
)
;
let
(
run_checker
algorithm
)
=
match
vcode
.
flags
(
)
.
regalloc
(
)
{
settings
:
:
Regalloc
:
:
Backtracking
=
>
(
false
Algorithm
:
:
Backtracking
(
Default
:
:
default
(
)
)
)
settings
:
:
Regalloc
:
:
BacktrackingChecked
=
>
{
(
true
Algorithm
:
:
Backtracking
(
Default
:
:
default
(
)
)
)
}
settings
:
:
Regalloc
:
:
ExperimentalLinearScan
=
>
{
(
false
Algorithm
:
:
LinearScan
(
Default
:
:
default
(
)
)
)
}
settings
:
:
Regalloc
:
:
ExperimentalLinearScanChecked
=
>
{
(
true
Algorithm
:
:
LinearScan
(
Default
:
:
default
(
)
)
)
}
}
;
let
result
=
{
let
_tt
=
timing
:
:
regalloc
(
)
;
allocate_registers_with_opts
(
&
mut
vcode
b
.
reg_universe
(
)
Options
{
run_checker
algorithm
}
)
.
map_err
(
|
err
|
{
debug
!
(
"
Register
allocation
error
for
vcode
\
n
{
}
\
nError
:
{
:
?
}
"
vcode
.
show_rru
(
Some
(
b
.
reg_universe
(
)
)
)
err
)
;
err
}
)
.
expect
(
"
register
allocation
"
)
}
;
vcode
.
replace_insns_from_regalloc
(
result
)
;
debug
!
(
"
vcode
after
regalloc
:
final
version
:
\
n
{
}
"
vcode
.
show_rru
(
Some
(
b
.
reg_universe
(
)
)
)
)
;
Ok
(
vcode
)
}
