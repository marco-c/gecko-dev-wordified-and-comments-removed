use
constant_hash
:
:
{
probe
simple_hash
}
;
use
isa
:
:
TargetIsa
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
fmt
;
use
std
:
:
str
;
use
std
:
:
string
:
:
{
String
ToString
}
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
std
:
:
slice
:
:
SliceConcatExt
;
pub
trait
Configurable
{
fn
set
(
&
mut
self
name
:
&
str
value
:
&
str
)
-
>
SetResult
<
(
)
>
;
fn
enable
(
&
mut
self
name
:
&
str
)
-
>
SetResult
<
(
)
>
;
}
#
[
derive
(
Clone
)
]
pub
struct
Builder
{
template
:
&
'
static
detail
:
:
Template
bytes
:
Box
<
[
u8
]
>
}
impl
Builder
{
pub
fn
new
(
tmpl
:
&
'
static
detail
:
:
Template
)
-
>
Self
{
Self
{
template
:
tmpl
bytes
:
tmpl
.
defaults
.
into
(
)
}
}
pub
fn
state_for
(
self
name
:
&
str
)
-
>
Box
<
[
u8
]
>
{
assert_eq
!
(
name
self
.
template
.
name
)
;
self
.
bytes
}
fn
set_bit
(
&
mut
self
offset
:
usize
bit
:
u8
value
:
bool
)
{
let
byte
=
&
mut
self
.
bytes
[
offset
]
;
let
mask
=
1
<
<
bit
;
if
value
{
*
byte
|
=
mask
;
}
else
{
*
byte
&
=
!
mask
;
}
}
fn
apply_preset
(
&
mut
self
values
:
&
[
(
u8
u8
)
]
)
{
for
(
byte
&
(
mask
value
)
)
in
self
.
bytes
.
iter_mut
(
)
.
zip
(
values
)
{
*
byte
=
(
*
byte
&
!
mask
)
|
value
;
}
}
fn
lookup
(
&
self
name
:
&
str
)
-
>
SetResult
<
(
usize
detail
:
:
Detail
)
>
{
match
probe
(
self
.
template
name
simple_hash
(
name
)
)
{
Err
(
_
)
=
>
Err
(
SetError
:
:
BadName
(
name
.
to_string
(
)
)
)
Ok
(
entry
)
=
>
{
let
d
=
&
self
.
template
.
descriptors
[
self
.
template
.
hash_table
[
entry
]
as
usize
]
;
Ok
(
(
d
.
offset
as
usize
d
.
detail
)
)
}
}
}
}
fn
parse_bool_value
(
value
:
&
str
)
-
>
SetResult
<
bool
>
{
match
value
{
"
true
"
|
"
on
"
|
"
yes
"
|
"
1
"
=
>
Ok
(
true
)
"
false
"
|
"
off
"
|
"
no
"
|
"
0
"
=
>
Ok
(
false
)
_
=
>
Err
(
SetError
:
:
BadValue
(
"
bool
"
.
to_string
(
)
)
)
}
}
fn
parse_enum_value
(
value
:
&
str
choices
:
&
[
&
str
]
)
-
>
SetResult
<
u8
>
{
match
choices
.
iter
(
)
.
position
(
|
&
tag
|
tag
=
=
value
)
{
Some
(
idx
)
=
>
Ok
(
idx
as
u8
)
None
=
>
Err
(
SetError
:
:
BadValue
(
format
!
(
"
any
among
{
}
"
choices
.
join
(
"
"
)
)
)
)
}
}
impl
Configurable
for
Builder
{
fn
enable
(
&
mut
self
name
:
&
str
)
-
>
SetResult
<
(
)
>
{
use
self
:
:
detail
:
:
Detail
;
let
(
offset
detail
)
=
self
.
lookup
(
name
)
?
;
match
detail
{
Detail
:
:
Bool
{
bit
}
=
>
{
self
.
set_bit
(
offset
bit
true
)
;
Ok
(
(
)
)
}
Detail
:
:
Preset
=
>
{
self
.
apply_preset
(
&
self
.
template
.
presets
[
offset
.
.
]
)
;
Ok
(
(
)
)
}
_
=
>
Err
(
SetError
:
:
BadType
)
}
}
fn
set
(
&
mut
self
name
:
&
str
value
:
&
str
)
-
>
SetResult
<
(
)
>
{
use
self
:
:
detail
:
:
Detail
;
let
(
offset
detail
)
=
self
.
lookup
(
name
)
?
;
match
detail
{
Detail
:
:
Bool
{
bit
}
=
>
{
self
.
set_bit
(
offset
bit
parse_bool_value
(
value
)
?
)
;
}
Detail
:
:
Num
=
>
{
self
.
bytes
[
offset
]
=
value
.
parse
(
)
.
map_err
(
|
_
|
SetError
:
:
BadValue
(
"
number
"
.
to_string
(
)
)
)
?
;
}
Detail
:
:
Enum
{
last
enumerators
}
=
>
{
self
.
bytes
[
offset
]
=
parse_enum_value
(
value
self
.
template
.
enums
(
last
enumerators
)
)
?
;
}
Detail
:
:
Preset
=
>
return
Err
(
SetError
:
:
BadName
(
name
.
to_string
(
)
)
)
}
Ok
(
(
)
)
}
}
#
[
derive
(
Fail
Debug
PartialEq
Eq
)
]
pub
enum
SetError
{
#
[
fail
(
display
=
"
No
existing
setting
named
'
{
}
'
"
_0
)
]
BadName
(
String
)
#
[
fail
(
display
=
"
Trying
to
set
a
setting
with
the
wrong
type
"
)
]
BadType
#
[
fail
(
display
=
"
Unexpected
value
for
a
setting
expected
{
}
"
_0
)
]
BadValue
(
String
)
}
pub
type
SetResult
<
T
>
=
Result
<
T
SetError
>
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
PredicateView
<
'
a
>
(
&
'
a
[
u8
]
)
;
impl
<
'
a
>
PredicateView
<
'
a
>
{
pub
fn
new
(
bits
:
&
'
a
[
u8
]
)
-
>
Self
{
PredicateView
(
bits
)
}
pub
fn
test
(
self
p
:
usize
)
-
>
bool
{
self
.
0
[
p
/
8
]
&
(
1
<
<
(
p
%
8
)
)
!
=
0
}
}
pub
mod
detail
{
use
constant_hash
;
use
std
:
:
fmt
;
pub
struct
Template
{
pub
name
:
&
'
static
str
pub
descriptors
:
&
'
static
[
Descriptor
]
pub
enumerators
:
&
'
static
[
&
'
static
str
]
pub
hash_table
:
&
'
static
[
u16
]
pub
defaults
:
&
'
static
[
u8
]
pub
presets
:
&
'
static
[
(
u8
u8
)
]
}
impl
Template
{
pub
fn
enums
(
&
self
last
:
u8
enumerators
:
u16
)
-
>
&
[
&
'
static
str
]
{
let
from
=
enumerators
as
usize
;
let
len
=
usize
:
:
from
(
last
)
+
1
;
&
self
.
enumerators
[
from
.
.
from
+
len
]
}
pub
fn
format_toml_value
(
&
self
detail
:
Detail
byte
:
u8
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
detail
{
Detail
:
:
Bool
{
bit
}
=
>
write
!
(
f
"
{
}
"
(
byte
&
(
1
<
<
bit
)
)
!
=
0
)
Detail
:
:
Num
=
>
write
!
(
f
"
{
}
"
byte
)
Detail
:
:
Enum
{
last
enumerators
}
=
>
{
if
byte
<
=
last
{
let
tags
=
self
.
enums
(
last
enumerators
)
;
write
!
(
f
"
\
"
{
}
\
"
"
tags
[
usize
:
:
from
(
byte
)
]
)
}
else
{
write
!
(
f
"
{
}
"
byte
)
}
}
Detail
:
:
Preset
{
.
.
}
=
>
Ok
(
(
)
)
}
}
}
impl
<
'
a
>
constant_hash
:
:
Table
<
&
'
a
str
>
for
Template
{
fn
len
(
&
self
)
-
>
usize
{
self
.
hash_table
.
len
(
)
}
fn
key
(
&
self
idx
:
usize
)
-
>
Option
<
&
'
a
str
>
{
let
e
=
self
.
hash_table
[
idx
]
as
usize
;
if
e
<
self
.
descriptors
.
len
(
)
{
Some
(
self
.
descriptors
[
e
]
.
name
)
}
else
{
None
}
}
}
pub
struct
Descriptor
{
pub
name
:
&
'
static
str
pub
offset
:
u32
pub
detail
:
Detail
}
#
[
derive
(
Clone
Copy
)
]
pub
enum
Detail
{
Bool
{
bit
:
u8
}
Num
Enum
{
last
:
u8
enumerators
:
u16
}
Preset
}
impl
Detail
{
pub
fn
is_preset
(
self
)
-
>
bool
{
match
self
{
Detail
:
:
Preset
=
>
true
_
=
>
false
}
}
}
}
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
settings
.
rs
"
)
)
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
FlagsOrIsa
<
'
a
>
{
pub
flags
:
&
'
a
Flags
pub
isa
:
Option
<
&
'
a
TargetIsa
>
}
impl
<
'
a
>
From
<
&
'
a
Flags
>
for
FlagsOrIsa
<
'
a
>
{
fn
from
(
flags
:
&
'
a
Flags
)
-
>
FlagsOrIsa
{
FlagsOrIsa
{
flags
isa
:
None
}
}
}
impl
<
'
a
>
From
<
&
'
a
TargetIsa
>
for
FlagsOrIsa
<
'
a
>
{
fn
from
(
isa
:
&
'
a
TargetIsa
)
-
>
FlagsOrIsa
{
FlagsOrIsa
{
flags
:
isa
.
flags
(
)
isa
:
Some
(
isa
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
Configurable
;
use
super
:
:
SetError
:
:
*
;
use
super
:
:
{
builder
Flags
}
;
use
std
:
:
string
:
:
ToString
;
#
[
test
]
fn
display_default
(
)
{
let
b
=
builder
(
)
;
let
f
=
Flags
:
:
new
(
b
)
;
assert_eq
!
(
f
.
to_string
(
)
"
[
shared
]
\
n
\
opt_level
=
\
"
default
\
"
\
n
\
enable_verifier
=
true
\
n
\
is_pic
=
false
\
n
\
colocated_libcalls
=
false
\
n
\
avoid_div_traps
=
false
\
n
\
enable_float
=
true
\
n
\
enable_nan_canonicalization
=
false
\
n
\
enable_simd
=
true
\
n
\
enable_atomics
=
true
\
n
\
baldrdash_prologue_words
=
0
\
n
\
allones_funcaddrs
=
false
\
n
\
probestack_enabled
=
true
\
n
\
probestack_func_adjusts_sp
=
false
\
n
\
probestack_size_log2
=
12
\
n
\
jump_tables_enabled
=
true
\
n
"
)
;
assert_eq
!
(
f
.
opt_level
(
)
super
:
:
OptLevel
:
:
Default
)
;
assert_eq
!
(
f
.
enable_simd
(
)
true
)
;
assert_eq
!
(
f
.
baldrdash_prologue_words
(
)
0
)
;
}
#
[
test
]
fn
modify_bool
(
)
{
let
mut
b
=
builder
(
)
;
assert_eq
!
(
b
.
enable
(
"
not_there
"
)
Err
(
BadName
(
"
not_there
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
enable
(
"
enable_simd
"
)
Ok
(
(
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
false
"
)
Ok
(
(
)
)
)
;
let
f
=
Flags
:
:
new
(
b
)
;
assert_eq
!
(
f
.
enable_simd
(
)
false
)
;
}
#
[
test
]
fn
modify_string
(
)
{
let
mut
b
=
builder
(
)
;
assert_eq
!
(
b
.
set
(
"
not_there
"
"
true
"
)
Err
(
BadName
(
"
not_there
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
"
)
Err
(
BadValue
(
"
bool
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
best
"
)
Err
(
BadValue
(
"
bool
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
opt_level
"
"
true
"
)
Err
(
BadValue
(
"
any
among
default
best
fastest
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
opt_level
"
"
best
"
)
Ok
(
(
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
0
"
)
Ok
(
(
)
)
)
;
let
f
=
Flags
:
:
new
(
b
)
;
assert_eq
!
(
f
.
enable_simd
(
)
false
)
;
assert_eq
!
(
f
.
opt_level
(
)
super
:
:
OptLevel
:
:
Best
)
;
}
}
