use
crate
:
:
constant_hash
:
:
{
probe
simple_hash
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
string
:
:
{
String
ToString
}
;
use
core
:
:
fmt
;
use
core
:
:
str
;
pub
trait
Configurable
{
fn
set
(
&
mut
self
name
:
&
str
value
:
&
str
)
-
>
SetResult
<
(
)
>
;
fn
enable
(
&
mut
self
name
:
&
str
)
-
>
SetResult
<
(
)
>
;
}
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
enum
SettingKind
{
Enum
Num
Bool
Preset
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Setting
{
pub
name
:
&
'
static
str
pub
description
:
&
'
static
str
pub
kind
:
SettingKind
pub
values
:
Option
<
&
'
static
[
&
'
static
str
]
>
}
pub
struct
Value
{
pub
name
:
&
'
static
str
pub
(
crate
)
detail
:
detail
:
:
Detail
pub
(
crate
)
values
:
Option
<
&
'
static
[
&
'
static
str
]
>
pub
(
crate
)
value
:
u8
}
impl
Value
{
pub
fn
kind
(
&
self
)
-
>
SettingKind
{
match
&
self
.
detail
{
detail
:
:
Detail
:
:
Enum
{
.
.
}
=
>
SettingKind
:
:
Enum
detail
:
:
Detail
:
:
Num
=
>
SettingKind
:
:
Num
detail
:
:
Detail
:
:
Bool
{
.
.
}
=
>
SettingKind
:
:
Bool
detail
:
:
Detail
:
:
Preset
=
>
unreachable
!
(
)
}
}
pub
fn
as_enum
(
&
self
)
-
>
Option
<
&
'
static
str
>
{
self
.
values
.
map
(
|
v
|
v
[
self
.
value
as
usize
]
)
}
pub
fn
as_num
(
&
self
)
-
>
Option
<
u8
>
{
match
&
self
.
detail
{
detail
:
:
Detail
:
:
Num
=
>
Some
(
self
.
value
)
_
=
>
None
}
}
pub
fn
as_bool
(
&
self
)
-
>
Option
<
bool
>
{
match
&
self
.
detail
{
detail
:
:
Detail
:
:
Bool
{
bit
}
=
>
Some
(
self
.
value
&
(
1
<
<
bit
)
!
=
0
)
_
=
>
None
}
}
}
#
[
derive
(
Clone
Hash
)
]
pub
struct
Builder
{
template
:
&
'
static
detail
:
:
Template
bytes
:
Box
<
[
u8
]
>
}
impl
Builder
{
pub
fn
new
(
tmpl
:
&
'
static
detail
:
:
Template
)
-
>
Self
{
Self
{
template
:
tmpl
bytes
:
tmpl
.
defaults
.
into
(
)
}
}
pub
fn
state_for
(
self
name
:
&
str
)
-
>
Box
<
[
u8
]
>
{
assert_eq
!
(
name
self
.
template
.
name
)
;
self
.
bytes
}
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
Setting
>
{
let
template
=
self
.
template
;
template
.
descriptors
.
iter
(
)
.
map
(
move
|
d
|
{
let
(
kind
values
)
=
match
d
.
detail
{
detail
:
:
Detail
:
:
Enum
{
last
enumerators
}
=
>
{
let
values
=
template
.
enums
(
last
enumerators
)
;
(
SettingKind
:
:
Enum
Some
(
values
)
)
}
detail
:
:
Detail
:
:
Num
=
>
(
SettingKind
:
:
Num
None
)
detail
:
:
Detail
:
:
Bool
{
.
.
}
=
>
(
SettingKind
:
:
Bool
None
)
detail
:
:
Detail
:
:
Preset
=
>
(
SettingKind
:
:
Preset
None
)
}
;
Setting
{
name
:
d
.
name
description
:
d
.
description
kind
values
}
}
)
}
fn
set_bit
(
&
mut
self
offset
:
usize
bit
:
u8
value
:
bool
)
{
let
byte
=
&
mut
self
.
bytes
[
offset
]
;
let
mask
=
1
<
<
bit
;
if
value
{
*
byte
|
=
mask
;
}
else
{
*
byte
&
=
!
mask
;
}
}
fn
apply_preset
(
&
mut
self
values
:
&
[
(
u8
u8
)
]
)
{
for
(
byte
&
(
mask
value
)
)
in
self
.
bytes
.
iter_mut
(
)
.
zip
(
values
)
{
*
byte
=
(
*
byte
&
!
mask
)
|
value
;
}
}
fn
lookup
(
&
self
name
:
&
str
)
-
>
SetResult
<
(
usize
detail
:
:
Detail
)
>
{
match
probe
(
self
.
template
name
simple_hash
(
name
)
)
{
Err
(
_
)
=
>
Err
(
SetError
:
:
BadName
(
name
.
to_string
(
)
)
)
Ok
(
entry
)
=
>
{
let
d
=
&
self
.
template
.
descriptors
[
self
.
template
.
hash_table
[
entry
]
as
usize
]
;
Ok
(
(
d
.
offset
as
usize
d
.
detail
)
)
}
}
}
}
fn
parse_bool_value
(
value
:
&
str
)
-
>
SetResult
<
bool
>
{
match
value
{
"
true
"
|
"
on
"
|
"
yes
"
|
"
1
"
=
>
Ok
(
true
)
"
false
"
|
"
off
"
|
"
no
"
|
"
0
"
=
>
Ok
(
false
)
_
=
>
Err
(
SetError
:
:
BadValue
(
"
bool
"
.
to_string
(
)
)
)
}
}
fn
parse_enum_value
(
value
:
&
str
choices
:
&
[
&
str
]
)
-
>
SetResult
<
u8
>
{
match
choices
.
iter
(
)
.
position
(
|
&
tag
|
tag
=
=
value
)
{
Some
(
idx
)
=
>
Ok
(
idx
as
u8
)
None
=
>
{
let
mut
all_choices
=
String
:
:
new
(
)
;
let
mut
first
=
true
;
for
choice
in
choices
{
if
first
{
first
=
false
}
else
{
all_choices
+
=
"
"
;
}
all_choices
+
=
choice
;
}
Err
(
SetError
:
:
BadValue
(
format
!
(
"
any
among
{
}
"
all_choices
)
)
)
}
}
}
impl
Configurable
for
Builder
{
fn
enable
(
&
mut
self
name
:
&
str
)
-
>
SetResult
<
(
)
>
{
use
self
:
:
detail
:
:
Detail
;
let
(
offset
detail
)
=
self
.
lookup
(
name
)
?
;
match
detail
{
Detail
:
:
Bool
{
bit
}
=
>
{
self
.
set_bit
(
offset
bit
true
)
;
Ok
(
(
)
)
}
Detail
:
:
Preset
=
>
{
self
.
apply_preset
(
&
self
.
template
.
presets
[
offset
.
.
]
)
;
Ok
(
(
)
)
}
_
=
>
Err
(
SetError
:
:
BadType
)
}
}
fn
set
(
&
mut
self
name
:
&
str
value
:
&
str
)
-
>
SetResult
<
(
)
>
{
use
self
:
:
detail
:
:
Detail
;
let
(
offset
detail
)
=
self
.
lookup
(
name
)
?
;
match
detail
{
Detail
:
:
Bool
{
bit
}
=
>
{
self
.
set_bit
(
offset
bit
parse_bool_value
(
value
)
?
)
;
}
Detail
:
:
Num
=
>
{
self
.
bytes
[
offset
]
=
value
.
parse
(
)
.
map_err
(
|
_
|
SetError
:
:
BadValue
(
"
number
"
.
to_string
(
)
)
)
?
;
}
Detail
:
:
Enum
{
last
enumerators
}
=
>
{
self
.
bytes
[
offset
]
=
parse_enum_value
(
value
self
.
template
.
enums
(
last
enumerators
)
)
?
;
}
Detail
:
:
Preset
=
>
return
Err
(
SetError
:
:
BadName
(
name
.
to_string
(
)
)
)
}
Ok
(
(
)
)
}
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
pub
enum
SetError
{
BadName
(
String
)
BadType
BadValue
(
String
)
}
impl
std
:
:
error
:
:
Error
for
SetError
{
}
impl
fmt
:
:
Display
for
SetError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
SetError
:
:
BadName
(
name
)
=
>
write
!
(
f
"
No
existing
setting
named
'
{
}
'
"
name
)
SetError
:
:
BadType
=
>
{
write
!
(
f
"
Trying
to
set
a
setting
with
the
wrong
type
"
)
}
SetError
:
:
BadValue
(
value
)
=
>
{
write
!
(
f
"
Unexpected
value
for
a
setting
expected
{
}
"
value
)
}
}
}
}
pub
type
SetResult
<
T
>
=
Result
<
T
SetError
>
;
#
[
derive
(
Clone
Copy
Hash
)
]
pub
struct
PredicateView
<
'
a
>
(
&
'
a
[
u8
]
)
;
impl
<
'
a
>
PredicateView
<
'
a
>
{
pub
fn
new
(
bits
:
&
'
a
[
u8
]
)
-
>
Self
{
PredicateView
(
bits
)
}
pub
fn
test
(
self
p
:
usize
)
-
>
bool
{
self
.
0
[
p
/
8
]
&
(
1
<
<
(
p
%
8
)
)
!
=
0
}
}
pub
mod
detail
{
use
crate
:
:
constant_hash
;
use
core
:
:
fmt
;
use
core
:
:
hash
:
:
Hash
;
#
[
derive
(
Hash
)
]
pub
struct
Template
{
pub
name
:
&
'
static
str
pub
descriptors
:
&
'
static
[
Descriptor
]
pub
enumerators
:
&
'
static
[
&
'
static
str
]
pub
hash_table
:
&
'
static
[
u16
]
pub
defaults
:
&
'
static
[
u8
]
pub
presets
:
&
'
static
[
(
u8
u8
)
]
}
impl
Template
{
pub
fn
enums
(
&
self
last
:
u8
enumerators
:
u16
)
-
>
&
[
&
'
static
str
]
{
let
from
=
enumerators
as
usize
;
let
len
=
usize
:
:
from
(
last
)
+
1
;
&
self
.
enumerators
[
from
.
.
from
+
len
]
}
pub
fn
format_toml_value
(
&
self
detail
:
Detail
byte
:
u8
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
detail
{
Detail
:
:
Bool
{
bit
}
=
>
write
!
(
f
"
{
}
"
(
byte
&
(
1
<
<
bit
)
)
!
=
0
)
Detail
:
:
Num
=
>
write
!
(
f
"
{
}
"
byte
)
Detail
:
:
Enum
{
last
enumerators
}
=
>
{
if
byte
<
=
last
{
let
tags
=
self
.
enums
(
last
enumerators
)
;
write
!
(
f
"
\
"
{
}
\
"
"
tags
[
usize
:
:
from
(
byte
)
]
)
}
else
{
write
!
(
f
"
{
}
"
byte
)
}
}
Detail
:
:
Preset
{
.
.
}
=
>
Ok
(
(
)
)
}
}
}
impl
<
'
a
>
constant_hash
:
:
Table
<
&
'
a
str
>
for
Template
{
fn
len
(
&
self
)
-
>
usize
{
self
.
hash_table
.
len
(
)
}
fn
key
(
&
self
idx
:
usize
)
-
>
Option
<
&
'
a
str
>
{
let
e
=
self
.
hash_table
[
idx
]
as
usize
;
if
e
<
self
.
descriptors
.
len
(
)
{
Some
(
self
.
descriptors
[
e
]
.
name
)
}
else
{
None
}
}
}
#
[
derive
(
Hash
)
]
pub
struct
Descriptor
{
pub
name
:
&
'
static
str
pub
description
:
&
'
static
str
pub
offset
:
u32
pub
detail
:
Detail
}
#
[
derive
(
Clone
Copy
Hash
)
]
pub
enum
Detail
{
Bool
{
bit
:
u8
}
Num
Enum
{
last
:
u8
enumerators
:
u16
}
Preset
}
impl
Detail
{
pub
fn
is_preset
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Preset
=
>
true
_
=
>
false
}
}
}
}
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
settings
.
rs
"
)
)
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
FlagsOrIsa
<
'
a
>
{
pub
flags
:
&
'
a
Flags
pub
isa
:
Option
<
&
'
a
dyn
TargetIsa
>
}
impl
<
'
a
>
From
<
&
'
a
Flags
>
for
FlagsOrIsa
<
'
a
>
{
fn
from
(
flags
:
&
'
a
Flags
)
-
>
FlagsOrIsa
{
FlagsOrIsa
{
flags
isa
:
None
}
}
}
impl
<
'
a
>
From
<
&
'
a
dyn
TargetIsa
>
for
FlagsOrIsa
<
'
a
>
{
fn
from
(
isa
:
&
'
a
dyn
TargetIsa
)
-
>
FlagsOrIsa
{
FlagsOrIsa
{
flags
:
isa
.
flags
(
)
isa
:
Some
(
isa
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
Configurable
;
use
super
:
:
SetError
:
:
*
;
use
super
:
:
{
builder
Flags
}
;
use
alloc
:
:
string
:
:
ToString
;
#
[
test
]
fn
display_default
(
)
{
let
b
=
builder
(
)
;
let
f
=
Flags
:
:
new
(
b
)
;
assert_eq
!
(
f
.
to_string
(
)
r
#
"
[
shared
]
regalloc
=
"
backtracking
"
opt_level
=
"
none
"
tls_model
=
"
none
"
libcall_call_conv
=
"
isa_default
"
baldrdash_prologue_words
=
0
probestack_size_log2
=
12
enable_verifier
=
true
is_pic
=
false
use_colocated_libcalls
=
false
avoid_div_traps
=
false
enable_float
=
true
enable_nan_canonicalization
=
false
enable_pinned_reg
=
false
use_pinned_reg_as_heap_base
=
false
enable_simd
=
false
enable_atomics
=
true
enable_safepoints
=
false
enable_llvm_abi_extensions
=
false
unwind_info
=
true
emit_all_ones_funcaddrs
=
false
enable_probestack
=
true
probestack_func_adjusts_sp
=
false
enable_jump_tables
=
true
enable_heap_access_spectre_mitigation
=
true
"
#
)
;
assert_eq
!
(
f
.
opt_level
(
)
super
:
:
OptLevel
:
:
None
)
;
assert_eq
!
(
f
.
enable_simd
(
)
false
)
;
assert_eq
!
(
f
.
baldrdash_prologue_words
(
)
0
)
;
}
#
[
test
]
fn
modify_bool
(
)
{
let
mut
b
=
builder
(
)
;
assert_eq
!
(
b
.
enable
(
"
not_there
"
)
Err
(
BadName
(
"
not_there
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
enable
(
"
enable_simd
"
)
Ok
(
(
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
false
"
)
Ok
(
(
)
)
)
;
let
f
=
Flags
:
:
new
(
b
)
;
assert_eq
!
(
f
.
enable_simd
(
)
false
)
;
}
#
[
test
]
fn
modify_string
(
)
{
let
mut
b
=
builder
(
)
;
assert_eq
!
(
b
.
set
(
"
not_there
"
"
true
"
)
Err
(
BadName
(
"
not_there
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
"
)
Err
(
BadValue
(
"
bool
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
best
"
)
Err
(
BadValue
(
"
bool
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
opt_level
"
"
true
"
)
Err
(
BadValue
(
"
any
among
none
speed
speed_and_size
"
.
to_string
(
)
)
)
)
;
assert_eq
!
(
b
.
set
(
"
opt_level
"
"
speed
"
)
Ok
(
(
)
)
)
;
assert_eq
!
(
b
.
set
(
"
enable_simd
"
"
0
"
)
Ok
(
(
)
)
)
;
let
f
=
Flags
:
:
new
(
b
)
;
assert_eq
!
(
f
.
enable_simd
(
)
false
)
;
assert_eq
!
(
f
.
opt_level
(
)
super
:
:
OptLevel
:
:
Speed
)
;
}
}
