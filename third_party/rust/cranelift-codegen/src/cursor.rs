use
crate
:
:
ir
;
use
crate
:
:
isa
:
:
TargetIsa
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Debug
)
]
pub
enum
CursorPosition
{
Nowhere
At
(
ir
:
:
Inst
)
Before
(
ir
:
:
Block
)
After
(
ir
:
:
Block
)
}
pub
trait
Cursor
{
fn
position
(
&
self
)
-
>
CursorPosition
;
fn
set_position
(
&
mut
self
pos
:
CursorPosition
)
;
fn
srcloc
(
&
self
)
-
>
ir
:
:
SourceLoc
;
fn
set_srcloc
(
&
mut
self
srcloc
:
ir
:
:
SourceLoc
)
;
fn
layout
(
&
self
)
-
>
&
ir
:
:
Layout
;
fn
layout_mut
(
&
mut
self
)
-
>
&
mut
ir
:
:
Layout
;
fn
with_srcloc
(
mut
self
srcloc
:
ir
:
:
SourceLoc
)
-
>
Self
where
Self
:
Sized
{
self
.
set_srcloc
(
srcloc
)
;
self
}
fn
at_position
(
mut
self
pos
:
CursorPosition
)
-
>
Self
where
Self
:
Sized
{
self
.
set_position
(
pos
)
;
self
}
fn
at_inst
(
mut
self
inst
:
ir
:
:
Inst
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_inst
(
inst
)
;
self
}
fn
at_first_insertion_point
(
mut
self
block
:
ir
:
:
Block
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_first_insertion_point
(
block
)
;
self
}
fn
at_first_inst
(
mut
self
block
:
ir
:
:
Block
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_first_inst
(
block
)
;
self
}
fn
at_last_inst
(
mut
self
block
:
ir
:
:
Block
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_last_inst
(
block
)
;
self
}
fn
after_inst
(
mut
self
inst
:
ir
:
:
Inst
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_after_inst
(
inst
)
;
self
}
fn
at_top
(
mut
self
block
:
ir
:
:
Block
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_top
(
block
)
;
self
}
fn
at_bottom
(
mut
self
block
:
ir
:
:
Block
)
-
>
Self
where
Self
:
Sized
{
self
.
goto_bottom
(
block
)
;
self
}
fn
current_block
(
&
self
)
-
>
Option
<
ir
:
:
Block
>
{
use
self
:
:
CursorPosition
:
:
*
;
match
self
.
position
(
)
{
Nowhere
=
>
None
At
(
inst
)
=
>
self
.
layout
(
)
.
inst_block
(
inst
)
Before
(
block
)
|
After
(
block
)
=
>
Some
(
block
)
}
}
fn
current_inst
(
&
self
)
-
>
Option
<
ir
:
:
Inst
>
{
use
self
:
:
CursorPosition
:
:
*
;
match
self
.
position
(
)
{
At
(
inst
)
=
>
Some
(
inst
)
_
=
>
None
}
}
fn
goto_after_inst
(
&
mut
self
inst
:
ir
:
:
Inst
)
{
debug_assert
!
(
self
.
layout
(
)
.
inst_block
(
inst
)
.
is_some
(
)
)
;
let
new_pos
=
if
let
Some
(
next
)
=
self
.
layout
(
)
.
next_inst
(
inst
)
{
CursorPosition
:
:
At
(
next
)
}
else
{
CursorPosition
:
:
After
(
self
.
layout
(
)
.
inst_block
(
inst
)
.
expect
(
"
current
instruction
removed
?
"
)
)
}
;
self
.
set_position
(
new_pos
)
;
}
fn
goto_inst
(
&
mut
self
inst
:
ir
:
:
Inst
)
{
debug_assert
!
(
self
.
layout
(
)
.
inst_block
(
inst
)
.
is_some
(
)
)
;
self
.
set_position
(
CursorPosition
:
:
At
(
inst
)
)
;
}
fn
goto_first_insertion_point
(
&
mut
self
block
:
ir
:
:
Block
)
{
if
let
Some
(
inst
)
=
self
.
layout
(
)
.
first_inst
(
block
)
{
self
.
goto_inst
(
inst
)
;
}
else
{
self
.
goto_bottom
(
block
)
;
}
}
fn
goto_first_inst
(
&
mut
self
block
:
ir
:
:
Block
)
{
let
inst
=
self
.
layout
(
)
.
first_inst
(
block
)
.
expect
(
"
Empty
block
"
)
;
self
.
goto_inst
(
inst
)
;
}
fn
goto_last_inst
(
&
mut
self
block
:
ir
:
:
Block
)
{
let
inst
=
self
.
layout
(
)
.
last_inst
(
block
)
.
expect
(
"
Empty
block
"
)
;
self
.
goto_inst
(
inst
)
;
}
fn
goto_top
(
&
mut
self
block
:
ir
:
:
Block
)
{
debug_assert
!
(
self
.
layout
(
)
.
is_block_inserted
(
block
)
)
;
self
.
set_position
(
CursorPosition
:
:
Before
(
block
)
)
;
}
fn
goto_bottom
(
&
mut
self
block
:
ir
:
:
Block
)
{
debug_assert
!
(
self
.
layout
(
)
.
is_block_inserted
(
block
)
)
;
self
.
set_position
(
CursorPosition
:
:
After
(
block
)
)
;
}
fn
next_block
(
&
mut
self
)
-
>
Option
<
ir
:
:
Block
>
{
let
next
=
if
let
Some
(
block
)
=
self
.
current_block
(
)
{
self
.
layout
(
)
.
next_block
(
block
)
}
else
{
self
.
layout
(
)
.
entry_block
(
)
}
;
self
.
set_position
(
match
next
{
Some
(
block
)
=
>
CursorPosition
:
:
Before
(
block
)
None
=
>
CursorPosition
:
:
Nowhere
}
)
;
next
}
fn
prev_block
(
&
mut
self
)
-
>
Option
<
ir
:
:
Block
>
{
let
prev
=
if
let
Some
(
block
)
=
self
.
current_block
(
)
{
self
.
layout
(
)
.
prev_block
(
block
)
}
else
{
self
.
layout
(
)
.
last_block
(
)
}
;
self
.
set_position
(
match
prev
{
Some
(
block
)
=
>
CursorPosition
:
:
After
(
block
)
None
=
>
CursorPosition
:
:
Nowhere
}
)
;
prev
}
fn
next_inst
(
&
mut
self
)
-
>
Option
<
ir
:
:
Inst
>
{
use
self
:
:
CursorPosition
:
:
*
;
match
self
.
position
(
)
{
Nowhere
|
After
(
.
.
)
=
>
None
At
(
inst
)
=
>
{
if
let
Some
(
next
)
=
self
.
layout
(
)
.
next_inst
(
inst
)
{
self
.
set_position
(
At
(
next
)
)
;
Some
(
next
)
}
else
{
let
pos
=
After
(
self
.
layout
(
)
.
inst_block
(
inst
)
.
expect
(
"
current
instruction
removed
?
"
)
)
;
self
.
set_position
(
pos
)
;
None
}
}
Before
(
block
)
=
>
{
if
let
Some
(
next
)
=
self
.
layout
(
)
.
first_inst
(
block
)
{
self
.
set_position
(
At
(
next
)
)
;
Some
(
next
)
}
else
{
self
.
set_position
(
After
(
block
)
)
;
None
}
}
}
}
fn
prev_inst
(
&
mut
self
)
-
>
Option
<
ir
:
:
Inst
>
{
use
self
:
:
CursorPosition
:
:
*
;
match
self
.
position
(
)
{
Nowhere
|
Before
(
.
.
)
=
>
None
At
(
inst
)
=
>
{
if
let
Some
(
prev
)
=
self
.
layout
(
)
.
prev_inst
(
inst
)
{
self
.
set_position
(
At
(
prev
)
)
;
Some
(
prev
)
}
else
{
let
pos
=
Before
(
self
.
layout
(
)
.
inst_block
(
inst
)
.
expect
(
"
current
instruction
removed
?
"
)
)
;
self
.
set_position
(
pos
)
;
None
}
}
After
(
block
)
=
>
{
if
let
Some
(
prev
)
=
self
.
layout
(
)
.
last_inst
(
block
)
{
self
.
set_position
(
At
(
prev
)
)
;
Some
(
prev
)
}
else
{
self
.
set_position
(
Before
(
block
)
)
;
None
}
}
}
}
fn
insert_inst
(
&
mut
self
inst
:
ir
:
:
Inst
)
{
use
self
:
:
CursorPosition
:
:
*
;
match
self
.
position
(
)
{
Nowhere
|
Before
(
.
.
)
=
>
panic
!
(
"
Invalid
insert_inst
position
"
)
At
(
cur
)
=
>
self
.
layout_mut
(
)
.
insert_inst
(
inst
cur
)
After
(
block
)
=
>
self
.
layout_mut
(
)
.
append_inst
(
inst
block
)
}
}
fn
remove_inst
(
&
mut
self
)
-
>
ir
:
:
Inst
{
let
inst
=
self
.
current_inst
(
)
.
expect
(
"
No
instruction
to
remove
"
)
;
self
.
next_inst
(
)
;
self
.
layout_mut
(
)
.
remove_inst
(
inst
)
;
inst
}
fn
remove_inst_and_step_back
(
&
mut
self
)
-
>
ir
:
:
Inst
{
let
inst
=
self
.
current_inst
(
)
.
expect
(
"
No
instruction
to
remove
"
)
;
self
.
prev_inst
(
)
;
self
.
layout_mut
(
)
.
remove_inst
(
inst
)
;
inst
}
fn
insert_block
(
&
mut
self
new_block
:
ir
:
:
Block
)
{
use
self
:
:
CursorPosition
:
:
*
;
match
self
.
position
(
)
{
At
(
inst
)
=
>
{
self
.
layout_mut
(
)
.
split_block
(
new_block
inst
)
;
return
;
}
Nowhere
=
>
self
.
layout_mut
(
)
.
append_block
(
new_block
)
Before
(
block
)
=
>
self
.
layout_mut
(
)
.
insert_block
(
new_block
block
)
After
(
block
)
=
>
self
.
layout_mut
(
)
.
insert_block_after
(
new_block
block
)
}
self
.
set_position
(
After
(
new_block
)
)
;
}
}
pub
struct
FuncCursor
<
'
f
>
{
pos
:
CursorPosition
srcloc
:
ir
:
:
SourceLoc
pub
func
:
&
'
f
mut
ir
:
:
Function
}
impl
<
'
f
>
FuncCursor
<
'
f
>
{
pub
fn
new
(
func
:
&
'
f
mut
ir
:
:
Function
)
-
>
Self
{
Self
{
pos
:
CursorPosition
:
:
Nowhere
srcloc
:
Default
:
:
default
(
)
func
}
}
pub
fn
use_srcloc
(
&
mut
self
inst
:
ir
:
:
Inst
)
{
self
.
srcloc
=
self
.
func
.
srclocs
[
inst
]
;
}
pub
fn
ins
(
&
mut
self
)
-
>
ir
:
:
InsertBuilder
<
&
mut
FuncCursor
<
'
f
>
>
{
ir
:
:
InsertBuilder
:
:
new
(
self
)
}
}
impl
<
'
f
>
Cursor
for
FuncCursor
<
'
f
>
{
fn
position
(
&
self
)
-
>
CursorPosition
{
self
.
pos
}
fn
set_position
(
&
mut
self
pos
:
CursorPosition
)
{
self
.
pos
=
pos
}
fn
srcloc
(
&
self
)
-
>
ir
:
:
SourceLoc
{
self
.
srcloc
}
fn
set_srcloc
(
&
mut
self
srcloc
:
ir
:
:
SourceLoc
)
{
self
.
srcloc
=
srcloc
;
}
fn
layout
(
&
self
)
-
>
&
ir
:
:
Layout
{
&
self
.
func
.
layout
}
fn
layout_mut
(
&
mut
self
)
-
>
&
mut
ir
:
:
Layout
{
&
mut
self
.
func
.
layout
}
}
impl
<
'
c
'
f
>
ir
:
:
InstInserterBase
<
'
c
>
for
&
'
c
mut
FuncCursor
<
'
f
>
{
fn
data_flow_graph
(
&
self
)
-
>
&
ir
:
:
DataFlowGraph
{
&
self
.
func
.
dfg
}
fn
data_flow_graph_mut
(
&
mut
self
)
-
>
&
mut
ir
:
:
DataFlowGraph
{
&
mut
self
.
func
.
dfg
}
fn
insert_built_inst
(
self
inst
:
ir
:
:
Inst
_
:
ir
:
:
Type
)
-
>
&
'
c
mut
ir
:
:
DataFlowGraph
{
#
[
cfg
(
debug_assertions
)
]
{
if
let
CursorPosition
:
:
At
(
_
)
=
self
.
position
(
)
{
if
let
Some
(
curr
)
=
self
.
current_inst
(
)
{
if
let
Some
(
prev
)
=
self
.
layout
(
)
.
prev_inst
(
curr
)
{
let
prev_op
=
self
.
data_flow_graph
(
)
[
prev
]
.
opcode
(
)
;
let
inst_op
=
self
.
data_flow_graph
(
)
[
inst
]
.
opcode
(
)
;
let
curr_op
=
self
.
data_flow_graph
(
)
[
curr
]
.
opcode
(
)
;
if
prev_op
.
is_branch
(
)
&
&
!
prev_op
.
is_terminator
(
)
&
&
!
inst_op
.
is_terminator
(
)
{
panic
!
(
"
Inserting
instruction
{
}
after
{
}
and
before
{
}
"
inst_op
prev_op
curr_op
)
}
}
;
}
;
}
;
}
self
.
insert_inst
(
inst
)
;
if
!
self
.
srcloc
.
is_default
(
)
{
self
.
func
.
srclocs
[
inst
]
=
self
.
srcloc
;
}
&
mut
self
.
func
.
dfg
}
}
pub
struct
EncCursor
<
'
f
>
{
pos
:
CursorPosition
srcloc
:
ir
:
:
SourceLoc
built_inst
:
Option
<
ir
:
:
Inst
>
pub
func
:
&
'
f
mut
ir
:
:
Function
pub
isa
:
&
'
f
dyn
TargetIsa
}
impl
<
'
f
>
EncCursor
<
'
f
>
{
pub
fn
new
(
func
:
&
'
f
mut
ir
:
:
Function
isa
:
&
'
f
dyn
TargetIsa
)
-
>
Self
{
Self
{
pos
:
CursorPosition
:
:
Nowhere
srcloc
:
Default
:
:
default
(
)
built_inst
:
None
func
isa
}
}
pub
fn
use_srcloc
(
&
mut
self
inst
:
ir
:
:
Inst
)
{
self
.
srcloc
=
self
.
func
.
srclocs
[
inst
]
;
}
pub
fn
ins
(
&
mut
self
)
-
>
ir
:
:
InsertBuilder
<
&
mut
EncCursor
<
'
f
>
>
{
ir
:
:
InsertBuilder
:
:
new
(
self
)
}
pub
fn
built_inst
(
&
self
)
-
>
ir
:
:
Inst
{
self
.
built_inst
.
expect
(
"
No
instruction
was
inserted
"
)
}
pub
fn
display_inst
(
&
self
inst
:
ir
:
:
Inst
)
-
>
ir
:
:
dfg
:
:
DisplayInst
{
self
.
func
.
dfg
.
display_inst
(
inst
self
.
isa
)
}
}
impl
<
'
f
>
Cursor
for
EncCursor
<
'
f
>
{
fn
position
(
&
self
)
-
>
CursorPosition
{
self
.
pos
}
fn
set_position
(
&
mut
self
pos
:
CursorPosition
)
{
self
.
pos
=
pos
}
fn
srcloc
(
&
self
)
-
>
ir
:
:
SourceLoc
{
self
.
srcloc
}
fn
set_srcloc
(
&
mut
self
srcloc
:
ir
:
:
SourceLoc
)
{
self
.
srcloc
=
srcloc
;
}
fn
layout
(
&
self
)
-
>
&
ir
:
:
Layout
{
&
self
.
func
.
layout
}
fn
layout_mut
(
&
mut
self
)
-
>
&
mut
ir
:
:
Layout
{
&
mut
self
.
func
.
layout
}
}
impl
<
'
c
'
f
>
ir
:
:
InstInserterBase
<
'
c
>
for
&
'
c
mut
EncCursor
<
'
f
>
{
fn
data_flow_graph
(
&
self
)
-
>
&
ir
:
:
DataFlowGraph
{
&
self
.
func
.
dfg
}
fn
data_flow_graph_mut
(
&
mut
self
)
-
>
&
mut
ir
:
:
DataFlowGraph
{
&
mut
self
.
func
.
dfg
}
fn
insert_built_inst
(
self
inst
:
ir
:
:
Inst
ctrl_typevar
:
ir
:
:
Type
)
-
>
&
'
c
mut
ir
:
:
DataFlowGraph
{
#
[
cfg
(
debug_assertions
)
]
{
if
let
CursorPosition
:
:
At
(
_
)
=
self
.
position
(
)
{
if
let
Some
(
curr
)
=
self
.
current_inst
(
)
{
if
let
Some
(
prev
)
=
self
.
layout
(
)
.
prev_inst
(
curr
)
{
let
prev_op
=
self
.
data_flow_graph
(
)
[
prev
]
.
opcode
(
)
;
let
inst_op
=
self
.
data_flow_graph
(
)
[
inst
]
.
opcode
(
)
;
if
prev_op
.
is_branch
(
)
&
&
!
prev_op
.
is_terminator
(
)
&
&
!
inst_op
.
is_terminator
(
)
{
panic
!
(
"
Inserting
instruction
{
}
after
{
}
and
before
{
}
"
self
.
display_inst
(
inst
)
self
.
display_inst
(
prev
)
self
.
display_inst
(
curr
)
)
}
}
;
}
;
}
;
}
self
.
insert_inst
(
inst
)
;
self
.
built_inst
=
Some
(
inst
)
;
if
!
self
.
srcloc
.
is_default
(
)
{
self
.
func
.
srclocs
[
inst
]
=
self
.
srcloc
;
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
match_wild_err_arm
)
)
]
match
self
.
isa
.
encode
(
&
self
.
func
&
self
.
func
.
dfg
[
inst
]
ctrl_typevar
)
{
Ok
(
e
)
=
>
self
.
func
.
encodings
[
inst
]
=
e
Err
(
_
)
=
>
panic
!
(
"
can
'
t
encode
{
}
"
self
.
display_inst
(
inst
)
)
}
&
mut
self
.
func
.
dfg
}
}
