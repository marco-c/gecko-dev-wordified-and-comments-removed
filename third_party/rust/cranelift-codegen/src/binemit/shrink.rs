use
crate
:
:
ir
:
:
instructions
:
:
InstructionData
;
use
crate
:
:
ir
:
:
Function
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
crate
:
:
regalloc
:
:
RegDiversions
;
use
crate
:
:
timing
;
use
log
:
:
debug
;
pub
fn
shrink_instructions
(
func
:
&
mut
Function
isa
:
&
TargetIsa
)
{
let
_tt
=
timing
:
:
shrink_instructions
(
)
;
let
encinfo
=
isa
.
encoding_info
(
)
;
let
mut
divert
=
RegDiversions
:
:
new
(
)
;
for
ebb
in
func
.
layout
.
ebbs
(
)
{
divert
.
clear
(
)
;
for
inst
in
func
.
layout
.
ebb_insts
(
ebb
)
{
let
enc
=
func
.
encodings
[
inst
]
;
if
enc
.
is_legal
(
)
{
match
func
.
dfg
[
inst
]
{
InstructionData
:
:
RegMove
{
.
.
}
|
InstructionData
:
:
RegFill
{
.
.
}
|
InstructionData
:
:
RegSpill
{
.
.
}
=
>
{
divert
.
apply
(
&
func
.
dfg
[
inst
]
)
;
continue
;
}
_
=
>
(
)
}
let
ctrl_type
=
func
.
dfg
.
ctrl_typevar
(
inst
)
;
let
best_enc
=
isa
.
legal_encodings
(
func
&
func
.
dfg
[
inst
]
ctrl_type
)
.
filter
(
|
e
|
encinfo
.
constraints
[
e
.
recipe
(
)
]
.
satisfied
(
inst
&
divert
&
func
)
)
.
min_by_key
(
|
e
|
encinfo
.
byte_size
(
*
e
inst
&
divert
&
func
)
)
.
unwrap
(
)
;
if
best_enc
!
=
enc
{
func
.
encodings
[
inst
]
=
best_enc
;
debug
!
(
"
Shrunk
[
{
}
]
to
[
{
}
]
in
{
}
reducing
the
size
from
{
}
to
{
}
"
encinfo
.
display
(
enc
)
encinfo
.
display
(
best_enc
)
func
.
dfg
.
display_inst
(
inst
isa
)
encinfo
.
byte_size
(
enc
inst
&
divert
&
func
)
encinfo
.
byte_size
(
best_enc
inst
&
divert
&
func
)
)
;
}
}
}
}
}
