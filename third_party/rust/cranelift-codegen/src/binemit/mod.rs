mod
memorysink
;
mod
relaxation
;
mod
shrink
;
mod
stack_map
;
pub
use
self
:
:
memorysink
:
:
{
MemoryCodeSink
NullRelocSink
NullStackMapSink
NullTrapSink
RelocSink
StackMapSink
TrapSink
}
;
pub
use
self
:
:
relaxation
:
:
relax_branches
;
pub
use
self
:
:
shrink
:
:
shrink_instructions
;
pub
use
self
:
:
stack_map
:
:
StackMap
;
use
crate
:
:
ir
:
:
entities
:
:
Value
;
use
crate
:
:
ir
:
:
{
ConstantOffset
ExternalName
Function
Inst
JumpTable
Opcode
SourceLoc
TrapCode
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
pub
use
crate
:
:
regalloc
:
:
RegDiversions
;
use
core
:
:
fmt
;
#
[
cfg
(
feature
=
"
enable
-
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
pub
type
CodeOffset
=
u32
;
pub
type
Addend
=
i64
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
Reloc
{
Abs4
Abs8
X86PCRel4
X86PCRelRodata4
X86CallPCRel4
X86CallPLTRel4
X86GOTPCRel4
Arm32Call
Arm64Call
RiscvCall
S390xPCRel32Dbl
ElfX86_64TlsGd
MachOX86_64Tlv
}
impl
fmt
:
:
Display
for
Reloc
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
Self
:
:
Abs4
=
>
write
!
(
f
"
Abs4
"
)
Self
:
:
Abs8
=
>
write
!
(
f
"
Abs8
"
)
Self
:
:
S390xPCRel32Dbl
=
>
write
!
(
f
"
PCRel32Dbl
"
)
Self
:
:
X86PCRel4
=
>
write
!
(
f
"
PCRel4
"
)
Self
:
:
X86PCRelRodata4
=
>
write
!
(
f
"
PCRelRodata4
"
)
Self
:
:
X86CallPCRel4
=
>
write
!
(
f
"
CallPCRel4
"
)
Self
:
:
X86CallPLTRel4
=
>
write
!
(
f
"
CallPLTRel4
"
)
Self
:
:
X86GOTPCRel4
=
>
write
!
(
f
"
GOTPCRel4
"
)
Self
:
:
Arm32Call
|
Self
:
:
Arm64Call
|
Self
:
:
RiscvCall
=
>
write
!
(
f
"
Call
"
)
Self
:
:
ElfX86_64TlsGd
=
>
write
!
(
f
"
ElfX86_64TlsGd
"
)
Self
:
:
MachOX86_64Tlv
=
>
write
!
(
f
"
MachOX86_64Tlv
"
)
}
}
}
#
[
derive
(
PartialEq
)
]
pub
struct
CodeInfo
{
pub
code_size
:
CodeOffset
pub
jumptables_size
:
CodeOffset
pub
rodata_size
:
CodeOffset
pub
total_size
:
CodeOffset
}
impl
CodeInfo
{
pub
fn
jumptables
(
&
self
)
-
>
CodeOffset
{
self
.
code_size
}
pub
fn
rodata
(
&
self
)
-
>
CodeOffset
{
self
.
code_size
+
self
.
jumptables_size
}
}
pub
trait
CodeSink
{
fn
offset
(
&
self
)
-
>
CodeOffset
;
fn
put1
(
&
mut
self
_
:
u8
)
;
fn
put2
(
&
mut
self
_
:
u16
)
;
fn
put4
(
&
mut
self
_
:
u32
)
;
fn
put8
(
&
mut
self
_
:
u64
)
;
fn
reloc_external
(
&
mut
self
_
:
SourceLoc
_
:
Reloc
_
:
&
ExternalName
_
:
Addend
)
;
fn
reloc_constant
(
&
mut
self
_
:
Reloc
_
:
ConstantOffset
)
;
fn
reloc_jt
(
&
mut
self
_
:
Reloc
_
:
JumpTable
)
;
fn
trap
(
&
mut
self
_
:
TrapCode
_
:
SourceLoc
)
;
fn
begin_jumptables
(
&
mut
self
)
;
fn
begin_rodata
(
&
mut
self
)
;
fn
end_codegen
(
&
mut
self
)
;
fn
add_stack_map
(
&
mut
self
_
:
&
[
Value
]
_
:
&
Function
_
:
&
dyn
TargetIsa
)
;
fn
add_call_site
(
&
mut
self
_
:
Opcode
_
:
SourceLoc
)
{
}
}
#
[
cold
]
pub
fn
bad_encoding
(
func
:
&
Function
inst
:
Inst
)
-
>
!
{
panic
!
(
"
Bad
encoding
{
}
for
{
}
"
func
.
encodings
[
inst
]
func
.
dfg
.
display_inst
(
inst
None
)
)
;
}
pub
fn
emit_function
<
CS
EI
>
(
func
:
&
Function
emit_inst
:
EI
sink
:
&
mut
CS
isa
:
&
dyn
TargetIsa
)
where
CS
:
CodeSink
EI
:
Fn
(
&
Function
Inst
&
mut
RegDiversions
&
mut
CS
&
dyn
TargetIsa
)
{
let
mut
divert
=
RegDiversions
:
:
new
(
)
;
for
block
in
func
.
layout
.
blocks
(
)
{
divert
.
at_block
(
&
func
.
entry_diversions
block
)
;
debug_assert_eq
!
(
func
.
offsets
[
block
]
sink
.
offset
(
)
)
;
for
inst
in
func
.
layout
.
block_insts
(
block
)
{
emit_inst
(
func
inst
&
mut
divert
sink
isa
)
;
}
}
sink
.
begin_jumptables
(
)
;
for
(
jt
jt_data
)
in
func
.
jump_tables
.
iter
(
)
{
let
jt_offset
=
func
.
jt_offsets
[
jt
]
;
for
block
in
jt_data
.
iter
(
)
{
let
rel_offset
:
i32
=
func
.
offsets
[
*
block
]
as
i32
-
jt_offset
as
i32
;
sink
.
put4
(
rel_offset
as
u32
)
}
}
sink
.
begin_rodata
(
)
;
for
(
_
constant_data
)
in
func
.
dfg
.
constants
.
iter
(
)
{
for
byte
in
constant_data
.
iter
(
)
{
sink
.
put1
(
*
byte
)
}
}
sink
.
end_codegen
(
)
;
}
