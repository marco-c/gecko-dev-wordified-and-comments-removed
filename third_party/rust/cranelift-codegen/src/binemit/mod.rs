mod
memorysink
;
mod
relaxation
;
mod
shrink
;
pub
use
self
:
:
memorysink
:
:
{
MemoryCodeSink
NullTrapSink
RelocSink
TrapSink
}
;
pub
use
self
:
:
relaxation
:
:
relax_branches
;
pub
use
self
:
:
shrink
:
:
shrink_instructions
;
pub
use
crate
:
:
regalloc
:
:
RegDiversions
;
use
crate
:
:
ir
:
:
{
ExternalName
Function
Inst
JumpTable
SourceLoc
TrapCode
}
;
use
core
:
:
fmt
;
pub
type
CodeOffset
=
u32
;
pub
type
Addend
=
i64
;
#
[
derive
(
Copy
Clone
Debug
)
]
pub
enum
Reloc
{
Abs4
Abs8
X86PCRel4
X86CallPCRel4
X86CallPLTRel4
X86GOTPCRel4
Arm32Call
Arm64Call
RiscvCall
}
impl
fmt
:
:
Display
for
Reloc
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
Reloc
:
:
Abs4
=
>
write
!
(
f
"
Abs4
"
)
Reloc
:
:
Abs8
=
>
write
!
(
f
"
Abs8
"
)
Reloc
:
:
X86PCRel4
=
>
write
!
(
f
"
PCRel4
"
)
Reloc
:
:
X86CallPCRel4
=
>
write
!
(
f
"
CallPCRel4
"
)
Reloc
:
:
X86CallPLTRel4
=
>
write
!
(
f
"
CallPLTRel4
"
)
Reloc
:
:
X86GOTPCRel4
=
>
write
!
(
f
"
GOTPCRel4
"
)
Reloc
:
:
Arm32Call
|
Reloc
:
:
Arm64Call
|
Reloc
:
:
RiscvCall
=
>
write
!
(
f
"
Call
"
)
}
}
}
pub
trait
CodeSink
{
fn
offset
(
&
self
)
-
>
CodeOffset
;
fn
put1
(
&
mut
self
_
:
u8
)
;
fn
put2
(
&
mut
self
_
:
u16
)
;
fn
put4
(
&
mut
self
_
:
u32
)
;
fn
put8
(
&
mut
self
_
:
u64
)
;
fn
reloc_ebb
(
&
mut
self
_
:
Reloc
_
:
CodeOffset
)
;
fn
reloc_external
(
&
mut
self
_
:
Reloc
_
:
&
ExternalName
_
:
Addend
)
;
fn
reloc_jt
(
&
mut
self
_
:
Reloc
_
:
JumpTable
)
;
fn
trap
(
&
mut
self
_
:
TrapCode
_
:
SourceLoc
)
;
fn
begin_rodata
(
&
mut
self
)
;
}
#
[
cold
]
pub
fn
bad_encoding
(
func
:
&
Function
inst
:
Inst
)
-
>
!
{
panic
!
(
"
Bad
encoding
{
}
for
{
}
"
func
.
encodings
[
inst
]
func
.
dfg
.
display_inst
(
inst
None
)
)
;
}
pub
fn
emit_function
<
CS
EI
>
(
func
:
&
Function
emit_inst
:
EI
sink
:
&
mut
CS
)
where
CS
:
CodeSink
EI
:
Fn
(
&
Function
Inst
&
mut
RegDiversions
&
mut
CS
)
{
let
mut
divert
=
RegDiversions
:
:
new
(
)
;
for
ebb
in
func
.
layout
.
ebbs
(
)
{
divert
.
clear
(
)
;
debug_assert_eq
!
(
func
.
offsets
[
ebb
]
sink
.
offset
(
)
)
;
for
inst
in
func
.
layout
.
ebb_insts
(
ebb
)
{
emit_inst
(
func
inst
&
mut
divert
sink
)
;
}
}
sink
.
begin_rodata
(
)
;
for
(
jt
jt_data
)
in
func
.
jump_tables
.
iter
(
)
{
let
jt_offset
=
func
.
jt_offsets
[
jt
]
;
for
ebb
in
jt_data
.
iter
(
)
{
let
rel_offset
:
i32
=
func
.
offsets
[
*
ebb
]
as
i32
-
jt_offset
as
i32
;
sink
.
put4
(
rel_offset
as
u32
)
}
}
}
