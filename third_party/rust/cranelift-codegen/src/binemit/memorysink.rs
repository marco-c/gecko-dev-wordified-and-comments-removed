use
super
:
:
{
Addend
CodeInfo
CodeOffset
CodeSink
Reloc
}
;
use
crate
:
:
ir
:
:
{
ExternalName
JumpTable
SourceLoc
TrapCode
}
;
use
core
:
:
ptr
:
:
write_unaligned
;
pub
struct
MemoryCodeSink
<
'
a
>
{
data
:
*
mut
u8
offset
:
isize
relocs
:
&
'
a
mut
dyn
RelocSink
traps
:
&
'
a
mut
dyn
TrapSink
pub
info
:
CodeInfo
}
impl
<
'
a
>
MemoryCodeSink
<
'
a
>
{
pub
unsafe
fn
new
(
data
:
*
mut
u8
relocs
:
&
'
a
mut
dyn
RelocSink
traps
:
&
'
a
mut
dyn
TrapSink
)
-
>
Self
{
Self
{
data
offset
:
0
info
:
CodeInfo
{
code_size
:
0
jumptables_size
:
0
rodata_size
:
0
total_size
:
0
}
relocs
traps
}
}
}
pub
trait
RelocSink
{
fn
reloc_ebb
(
&
mut
self
_
:
CodeOffset
_
:
Reloc
_
:
CodeOffset
)
;
fn
reloc_external
(
&
mut
self
_
:
CodeOffset
_
:
Reloc
_
:
&
ExternalName
_
:
Addend
)
;
fn
reloc_jt
(
&
mut
self
_
:
CodeOffset
_
:
Reloc
_
:
JumpTable
)
;
}
pub
trait
TrapSink
{
fn
trap
(
&
mut
self
_
:
CodeOffset
_
:
SourceLoc
_
:
TrapCode
)
;
}
impl
<
'
a
>
MemoryCodeSink
<
'
a
>
{
fn
write
<
T
>
(
&
mut
self
x
:
T
)
{
unsafe
{
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
cast_ptr_alignment
)
)
]
write_unaligned
(
self
.
data
.
offset
(
self
.
offset
)
as
*
mut
T
x
)
;
self
.
offset
+
=
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
as
isize
;
}
}
}
impl
<
'
a
>
CodeSink
for
MemoryCodeSink
<
'
a
>
{
fn
offset
(
&
self
)
-
>
CodeOffset
{
self
.
offset
as
CodeOffset
}
fn
put1
(
&
mut
self
x
:
u8
)
{
self
.
write
(
x
)
;
}
fn
put2
(
&
mut
self
x
:
u16
)
{
self
.
write
(
x
)
;
}
fn
put4
(
&
mut
self
x
:
u32
)
{
self
.
write
(
x
)
;
}
fn
put8
(
&
mut
self
x
:
u64
)
{
self
.
write
(
x
)
;
}
fn
reloc_ebb
(
&
mut
self
rel
:
Reloc
ebb_offset
:
CodeOffset
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
relocs
.
reloc_ebb
(
ofs
rel
ebb_offset
)
;
}
fn
reloc_external
(
&
mut
self
rel
:
Reloc
name
:
&
ExternalName
addend
:
Addend
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
relocs
.
reloc_external
(
ofs
rel
name
addend
)
;
}
fn
reloc_jt
(
&
mut
self
rel
:
Reloc
jt
:
JumpTable
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
relocs
.
reloc_jt
(
ofs
rel
jt
)
;
}
fn
trap
(
&
mut
self
code
:
TrapCode
srcloc
:
SourceLoc
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
traps
.
trap
(
ofs
srcloc
code
)
;
}
fn
begin_jumptables
(
&
mut
self
)
{
self
.
info
.
code_size
=
self
.
offset
(
)
;
}
fn
begin_rodata
(
&
mut
self
)
{
self
.
info
.
jumptables_size
=
self
.
offset
(
)
-
self
.
info
.
code_size
;
}
fn
end_codegen
(
&
mut
self
)
{
self
.
info
.
rodata_size
=
self
.
offset
(
)
-
(
self
.
info
.
jumptables_size
+
self
.
info
.
code_size
)
;
self
.
info
.
total_size
=
self
.
offset
(
)
;
}
}
pub
struct
NullTrapSink
{
}
impl
TrapSink
for
NullTrapSink
{
fn
trap
(
&
mut
self
_offset
:
CodeOffset
_srcloc
:
SourceLoc
_code
:
TrapCode
)
{
}
}
