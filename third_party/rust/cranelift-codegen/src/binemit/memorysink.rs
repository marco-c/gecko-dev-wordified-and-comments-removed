use
super
:
:
{
Addend
CodeInfo
CodeOffset
CodeSink
Reloc
}
;
use
crate
:
:
binemit
:
:
stackmap
:
:
Stackmap
;
use
crate
:
:
ir
:
:
entities
:
:
Value
;
use
crate
:
:
ir
:
:
{
ExternalName
Function
JumpTable
SourceLoc
TrapCode
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
core
:
:
ptr
:
:
write_unaligned
;
pub
struct
MemoryCodeSink
<
'
a
>
{
data
:
*
mut
u8
offset
:
isize
relocs
:
&
'
a
mut
dyn
RelocSink
traps
:
&
'
a
mut
dyn
TrapSink
stackmaps
:
&
'
a
mut
dyn
StackmapSink
pub
info
:
CodeInfo
}
impl
<
'
a
>
MemoryCodeSink
<
'
a
>
{
pub
unsafe
fn
new
(
data
:
*
mut
u8
relocs
:
&
'
a
mut
dyn
RelocSink
traps
:
&
'
a
mut
dyn
TrapSink
stackmaps
:
&
'
a
mut
dyn
StackmapSink
)
-
>
Self
{
Self
{
data
offset
:
0
info
:
CodeInfo
{
code_size
:
0
jumptables_size
:
0
rodata_size
:
0
total_size
:
0
}
relocs
traps
stackmaps
}
}
}
pub
trait
RelocSink
{
fn
reloc_ebb
(
&
mut
self
_
:
CodeOffset
_
:
Reloc
_
:
CodeOffset
)
;
fn
reloc_external
(
&
mut
self
_
:
CodeOffset
_
:
Reloc
_
:
&
ExternalName
_
:
Addend
)
;
fn
reloc_jt
(
&
mut
self
_
:
CodeOffset
_
:
Reloc
_
:
JumpTable
)
;
}
pub
trait
TrapSink
{
fn
trap
(
&
mut
self
_
:
CodeOffset
_
:
SourceLoc
_
:
TrapCode
)
;
}
impl
<
'
a
>
MemoryCodeSink
<
'
a
>
{
fn
write
<
T
>
(
&
mut
self
x
:
T
)
{
unsafe
{
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
cast_ptr_alignment
)
)
]
write_unaligned
(
self
.
data
.
offset
(
self
.
offset
)
as
*
mut
T
x
)
;
self
.
offset
+
=
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
as
isize
;
}
}
}
impl
<
'
a
>
CodeSink
for
MemoryCodeSink
<
'
a
>
{
fn
offset
(
&
self
)
-
>
CodeOffset
{
self
.
offset
as
CodeOffset
}
fn
put1
(
&
mut
self
x
:
u8
)
{
self
.
write
(
x
)
;
}
fn
put2
(
&
mut
self
x
:
u16
)
{
self
.
write
(
x
)
;
}
fn
put4
(
&
mut
self
x
:
u32
)
{
self
.
write
(
x
)
;
}
fn
put8
(
&
mut
self
x
:
u64
)
{
self
.
write
(
x
)
;
}
fn
reloc_ebb
(
&
mut
self
rel
:
Reloc
ebb_offset
:
CodeOffset
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
relocs
.
reloc_ebb
(
ofs
rel
ebb_offset
)
;
}
fn
reloc_external
(
&
mut
self
rel
:
Reloc
name
:
&
ExternalName
addend
:
Addend
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
relocs
.
reloc_external
(
ofs
rel
name
addend
)
;
}
fn
reloc_jt
(
&
mut
self
rel
:
Reloc
jt
:
JumpTable
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
relocs
.
reloc_jt
(
ofs
rel
jt
)
;
}
fn
trap
(
&
mut
self
code
:
TrapCode
srcloc
:
SourceLoc
)
{
let
ofs
=
self
.
offset
(
)
;
self
.
traps
.
trap
(
ofs
srcloc
code
)
;
}
fn
begin_jumptables
(
&
mut
self
)
{
self
.
info
.
code_size
=
self
.
offset
(
)
;
}
fn
begin_rodata
(
&
mut
self
)
{
self
.
info
.
jumptables_size
=
self
.
offset
(
)
-
self
.
info
.
code_size
;
}
fn
end_codegen
(
&
mut
self
)
{
self
.
info
.
rodata_size
=
self
.
offset
(
)
-
(
self
.
info
.
jumptables_size
+
self
.
info
.
code_size
)
;
self
.
info
.
total_size
=
self
.
offset
(
)
;
}
fn
add_stackmap
(
&
mut
self
val_list
:
&
[
Value
]
func
:
&
Function
isa
:
&
dyn
TargetIsa
)
{
let
ofs
=
self
.
offset
(
)
;
let
stackmap
=
Stackmap
:
:
from_values
(
&
val_list
func
isa
)
;
self
.
stackmaps
.
add_stackmap
(
ofs
stackmap
)
;
}
}
pub
struct
NullRelocSink
{
}
impl
RelocSink
for
NullRelocSink
{
fn
reloc_ebb
(
&
mut
self
_
:
u32
_
:
Reloc
_
:
u32
)
{
}
fn
reloc_external
(
&
mut
self
_
:
u32
_
:
Reloc
_
:
&
ExternalName
_
:
i64
)
{
}
fn
reloc_jt
(
&
mut
self
_
:
u32
_
:
Reloc
_
:
JumpTable
)
{
}
}
pub
struct
NullTrapSink
{
}
impl
TrapSink
for
NullTrapSink
{
fn
trap
(
&
mut
self
_offset
:
CodeOffset
_srcloc
:
SourceLoc
_code
:
TrapCode
)
{
}
}
pub
trait
StackmapSink
{
fn
add_stackmap
(
&
mut
self
_
:
CodeOffset
_
:
Stackmap
)
;
}
pub
struct
NullStackmapSink
{
}
impl
StackmapSink
for
NullStackmapSink
{
fn
add_stackmap
(
&
mut
self
_
:
CodeOffset
_
:
Stackmap
)
{
}
}
