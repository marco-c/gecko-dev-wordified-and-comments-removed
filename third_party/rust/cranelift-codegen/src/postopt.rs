#
!
[
allow
(
non_snake_case
)
]
use
cursor
:
:
{
Cursor
EncCursor
}
;
use
ir
:
:
condcodes
:
:
{
CondCode
FloatCC
IntCC
}
;
use
ir
:
:
dfg
:
:
ValueDef
;
use
ir
:
:
immediates
:
:
{
Imm64
Offset32
}
;
use
ir
:
:
instructions
:
:
{
Opcode
ValueList
}
;
use
ir
:
:
{
Ebb
Function
Inst
InstBuilder
InstructionData
MemFlags
Type
Value
}
;
use
isa
:
:
TargetIsa
;
use
timing
;
struct
CmpBrInfo
{
br_inst
:
Inst
cmp_inst
:
Inst
destination
:
Ebb
args
:
ValueList
cmp_arg
:
Value
invert_branch_cond
:
bool
kind
:
CmpBrKind
}
enum
CmpBrKind
{
Icmp
{
cond
:
IntCC
arg
:
Value
}
IcmpImm
{
cond
:
IntCC
imm
:
Imm64
}
Fcmp
{
cond
:
FloatCC
arg
:
Value
}
}
fn
optimize_cpu_flags
(
pos
:
&
mut
EncCursor
inst
:
Inst
last_flags_clobber
:
Option
<
Inst
>
isa
:
&
TargetIsa
)
{
let
info
=
match
pos
.
func
.
dfg
[
inst
]
{
InstructionData
:
:
Branch
{
opcode
destination
ref
args
}
=
>
{
let
first_arg
=
args
.
first
(
&
pos
.
func
.
dfg
.
value_lists
)
.
unwrap
(
)
;
let
invert_branch_cond
=
match
opcode
{
Opcode
:
:
Brz
=
>
true
Opcode
:
:
Brnz
=
>
false
_
=
>
panic
!
(
)
}
;
if
let
ValueDef
:
:
Result
(
cond_inst
_
)
=
pos
.
func
.
dfg
.
value_def
(
first_arg
)
{
match
pos
.
func
.
dfg
[
cond_inst
]
{
InstructionData
:
:
IntCompare
{
cond
args
:
cmp_args
.
.
}
=
>
CmpBrInfo
{
br_inst
:
inst
cmp_inst
:
cond_inst
destination
args
:
args
.
clone
(
)
cmp_arg
:
cmp_args
[
0
]
invert_branch_cond
kind
:
CmpBrKind
:
:
Icmp
{
cond
arg
:
cmp_args
[
1
]
}
}
InstructionData
:
:
IntCompareImm
{
cond
arg
:
cmp_arg
imm
:
cmp_imm
.
.
}
=
>
CmpBrInfo
{
br_inst
:
inst
cmp_inst
:
cond_inst
destination
args
:
args
.
clone
(
)
cmp_arg
invert_branch_cond
kind
:
CmpBrKind
:
:
IcmpImm
{
cond
imm
:
cmp_imm
}
}
InstructionData
:
:
FloatCompare
{
cond
args
:
cmp_args
.
.
}
=
>
CmpBrInfo
{
br_inst
:
inst
cmp_inst
:
cond_inst
destination
args
:
args
.
clone
(
)
cmp_arg
:
cmp_args
[
0
]
invert_branch_cond
kind
:
CmpBrKind
:
:
Fcmp
{
cond
arg
:
cmp_args
[
1
]
}
}
_
=
>
return
}
}
else
{
return
;
}
}
_
=
>
return
}
;
if
last_flags_clobber
!
=
Some
(
info
.
cmp_inst
)
{
return
;
}
let
args
=
info
.
args
.
as_slice
(
&
pos
.
func
.
dfg
.
value_lists
)
[
1
.
.
]
.
to_vec
(
)
;
pos
.
goto_inst
(
info
.
cmp_inst
)
;
match
info
.
kind
{
CmpBrKind
:
:
Icmp
{
mut
cond
arg
}
=
>
{
let
flags
=
pos
.
ins
(
)
.
ifcmp
(
info
.
cmp_arg
arg
)
;
pos
.
func
.
dfg
.
replace
(
info
.
cmp_inst
)
.
trueif
(
cond
flags
)
;
if
info
.
invert_branch_cond
{
cond
=
cond
.
inverse
(
)
;
}
pos
.
func
.
dfg
.
replace
(
info
.
br_inst
)
.
brif
(
cond
flags
info
.
destination
&
args
)
;
}
CmpBrKind
:
:
IcmpImm
{
mut
cond
imm
}
=
>
{
let
flags
=
pos
.
ins
(
)
.
ifcmp_imm
(
info
.
cmp_arg
imm
)
;
pos
.
func
.
dfg
.
replace
(
info
.
cmp_inst
)
.
trueif
(
cond
flags
)
;
if
info
.
invert_branch_cond
{
cond
=
cond
.
inverse
(
)
;
}
pos
.
func
.
dfg
.
replace
(
info
.
br_inst
)
.
brif
(
cond
flags
info
.
destination
&
args
)
;
}
CmpBrKind
:
:
Fcmp
{
mut
cond
arg
}
=
>
{
let
flags
=
pos
.
ins
(
)
.
ffcmp
(
info
.
cmp_arg
arg
)
;
pos
.
func
.
dfg
.
replace
(
info
.
cmp_inst
)
.
trueff
(
cond
flags
)
;
if
info
.
invert_branch_cond
{
cond
=
cond
.
inverse
(
)
;
}
pos
.
func
.
dfg
.
replace
(
info
.
br_inst
)
.
brff
(
cond
flags
info
.
destination
&
args
)
;
}
}
let
ok
=
pos
.
func
.
update_encoding
(
info
.
cmp_inst
isa
)
.
is_ok
(
)
;
debug_assert
!
(
ok
)
;
let
ok
=
pos
.
func
.
update_encoding
(
info
.
br_inst
isa
)
.
is_ok
(
)
;
debug_assert
!
(
ok
)
;
}
struct
MemOpInfo
{
opcode
:
Opcode
itype
:
Type
arg
:
Value
st_arg
:
Option
<
Value
>
flags
:
MemFlags
offset
:
Offset32
}
fn
optimize_complex_addresses
(
pos
:
&
mut
EncCursor
inst
:
Inst
isa
:
&
TargetIsa
)
{
let
info
=
match
pos
.
func
.
dfg
[
inst
]
{
InstructionData
:
:
Load
{
opcode
arg
flags
offset
}
=
>
MemOpInfo
{
opcode
itype
:
pos
.
func
.
dfg
.
ctrl_typevar
(
inst
)
arg
st_arg
:
None
flags
offset
}
InstructionData
:
:
Store
{
opcode
args
flags
offset
}
=
>
MemOpInfo
{
opcode
itype
:
pos
.
func
.
dfg
.
ctrl_typevar
(
inst
)
arg
:
args
[
1
]
st_arg
:
Some
(
args
[
0
]
)
flags
offset
}
_
=
>
return
}
;
if
let
ValueDef
:
:
Result
(
result_inst
_
)
=
pos
.
func
.
dfg
.
value_def
(
info
.
arg
)
{
match
pos
.
func
.
dfg
[
result_inst
]
{
InstructionData
:
:
Binary
{
opcode
:
Opcode
:
:
Iadd
args
}
=
>
match
info
.
opcode
{
Opcode
:
:
Load
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
load_complex
(
info
.
itype
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Uload8
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
uload8_complex
(
info
.
itype
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Sload8
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
sload8_complex
(
info
.
itype
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Uload16
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
uload16_complex
(
info
.
itype
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Sload16
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
sload16_complex
(
info
.
itype
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Uload32
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
uload32_complex
(
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Sload32
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
sload32_complex
(
info
.
flags
&
args
info
.
offset
)
;
}
Opcode
:
:
Store
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
store_complex
(
info
.
flags
info
.
st_arg
.
unwrap
(
)
&
args
info
.
offset
)
;
}
Opcode
:
:
Istore8
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
istore8_complex
(
info
.
flags
info
.
st_arg
.
unwrap
(
)
&
args
info
.
offset
)
;
}
Opcode
:
:
Istore16
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
istore16_complex
(
info
.
flags
info
.
st_arg
.
unwrap
(
)
&
args
info
.
offset
)
;
}
Opcode
:
:
Istore32
=
>
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
istore32_complex
(
info
.
flags
info
.
st_arg
.
unwrap
(
)
&
args
info
.
offset
)
;
}
_
=
>
panic
!
(
"
Unsupported
load
or
store
opcode
"
)
}
InstructionData
:
:
BinaryImm
{
opcode
:
Opcode
:
:
IaddImm
arg
imm
}
=
>
match
pos
.
func
.
dfg
[
inst
]
{
InstructionData
:
:
Load
{
arg
:
ref
mut
load_arg
ref
mut
offset
.
.
}
=
>
{
if
let
Some
(
imm
)
=
offset
.
try_add_i64
(
imm
.
into
(
)
)
{
*
load_arg
=
arg
;
*
offset
=
imm
;
}
else
{
return
;
}
}
InstructionData
:
:
Store
{
args
:
ref
mut
store_args
ref
mut
offset
.
.
}
=
>
{
if
let
Some
(
imm
)
=
offset
.
try_add_i64
(
imm
.
into
(
)
)
{
store_args
[
1
]
=
arg
;
*
offset
=
imm
;
}
else
{
return
;
}
}
_
=
>
panic
!
(
)
}
_
=
>
{
return
;
}
}
}
else
{
return
;
}
let
ok
=
pos
.
func
.
update_encoding
(
inst
isa
)
.
is_ok
(
)
;
debug_assert
!
(
ok
)
;
}
pub
fn
do_postopt
(
func
:
&
mut
Function
isa
:
&
TargetIsa
)
{
let
_tt
=
timing
:
:
postopt
(
)
;
let
mut
pos
=
EncCursor
:
:
new
(
func
isa
)
;
while
let
Some
(
_ebb
)
=
pos
.
next_ebb
(
)
{
let
mut
last_flags_clobber
=
None
;
while
let
Some
(
inst
)
=
pos
.
next_inst
(
)
{
if
isa
.
uses_cpu_flags
(
)
{
optimize_cpu_flags
(
&
mut
pos
inst
last_flags_clobber
isa
)
;
if
let
Some
(
constraints
)
=
isa
.
encoding_info
(
)
.
operand_constraints
(
pos
.
func
.
encodings
[
inst
]
)
{
if
constraints
.
clobbers_flags
{
last_flags_clobber
=
Some
(
inst
)
}
}
}
if
isa
.
uses_complex_addresses
(
)
{
optimize_complex_addresses
(
&
mut
pos
inst
isa
)
;
}
}
}
}
