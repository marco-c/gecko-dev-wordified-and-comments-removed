use
crate
:
:
ir
:
:
{
ArgumentLoc
ExternalName
SigRef
Type
}
;
use
crate
:
:
isa
:
:
{
CallConv
RegInfo
RegUnit
}
;
use
crate
:
:
machinst
:
:
RelocDistance
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
fmt
;
use
core
:
:
str
:
:
FromStr
;
#
[
cfg
(
feature
=
"
enable
-
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Signature
{
pub
params
:
Vec
<
AbiParam
>
pub
returns
:
Vec
<
AbiParam
>
pub
call_conv
:
CallConv
}
impl
Signature
{
pub
fn
new
(
call_conv
:
CallConv
)
-
>
Self
{
Self
{
params
:
Vec
:
:
new
(
)
returns
:
Vec
:
:
new
(
)
call_conv
}
}
pub
fn
clear
(
&
mut
self
call_conv
:
CallConv
)
{
self
.
params
.
clear
(
)
;
self
.
returns
.
clear
(
)
;
self
.
call_conv
=
call_conv
;
}
pub
fn
display
<
'
a
R
:
Into
<
Option
<
&
'
a
RegInfo
>
>
>
(
&
'
a
self
regs
:
R
)
-
>
DisplaySignature
<
'
a
>
{
DisplaySignature
(
self
regs
.
into
(
)
)
}
pub
fn
special_param_index
(
&
self
purpose
:
ArgumentPurpose
)
-
>
Option
<
usize
>
{
self
.
params
.
iter
(
)
.
rposition
(
|
arg
|
arg
.
purpose
=
=
purpose
)
}
pub
fn
special_return_index
(
&
self
purpose
:
ArgumentPurpose
)
-
>
Option
<
usize
>
{
self
.
returns
.
iter
(
)
.
rposition
(
|
arg
|
arg
.
purpose
=
=
purpose
)
}
pub
fn
uses_special_param
(
&
self
purpose
:
ArgumentPurpose
)
-
>
bool
{
self
.
special_param_index
(
purpose
)
.
is_some
(
)
}
pub
fn
uses_special_return
(
&
self
purpose
:
ArgumentPurpose
)
-
>
bool
{
self
.
special_return_index
(
purpose
)
.
is_some
(
)
}
pub
fn
num_special_params
(
&
self
)
-
>
usize
{
self
.
params
.
iter
(
)
.
filter
(
|
p
|
p
.
purpose
!
=
ArgumentPurpose
:
:
Normal
)
.
count
(
)
}
pub
fn
num_special_returns
(
&
self
)
-
>
usize
{
self
.
returns
.
iter
(
)
.
filter
(
|
r
|
r
.
purpose
!
=
ArgumentPurpose
:
:
Normal
)
.
count
(
)
}
pub
fn
uses_struct_return_param
(
&
self
)
-
>
bool
{
self
.
uses_special_param
(
ArgumentPurpose
:
:
StructReturn
)
}
pub
fn
is_multi_return
(
&
self
)
-
>
bool
{
self
.
returns
.
iter
(
)
.
filter
(
|
r
|
r
.
purpose
=
=
ArgumentPurpose
:
:
Normal
)
.
count
(
)
>
1
}
}
pub
struct
DisplaySignature
<
'
a
>
(
&
'
a
Signature
Option
<
&
'
a
RegInfo
>
)
;
fn
write_list
(
f
:
&
mut
fmt
:
:
Formatter
args
:
&
[
AbiParam
]
regs
:
Option
<
&
RegInfo
>
)
-
>
fmt
:
:
Result
{
match
args
.
split_first
(
)
{
None
=
>
{
}
Some
(
(
first
rest
)
)
=
>
{
write
!
(
f
"
{
}
"
first
.
display
(
regs
)
)
?
;
for
arg
in
rest
{
write
!
(
f
"
{
}
"
arg
.
display
(
regs
)
)
?
;
}
}
}
Ok
(
(
)
)
}
impl
<
'
a
>
fmt
:
:
Display
for
DisplaySignature
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
(
"
)
?
;
write_list
(
f
&
self
.
0
.
params
self
.
1
)
?
;
write
!
(
f
"
)
"
)
?
;
if
!
self
.
0
.
returns
.
is_empty
(
)
{
write
!
(
f
"
-
>
"
)
?
;
write_list
(
f
&
self
.
0
.
returns
self
.
1
)
?
;
}
write
!
(
f
"
{
}
"
self
.
0
.
call_conv
)
}
}
impl
fmt
:
:
Display
for
Signature
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
display
(
None
)
.
fmt
(
f
)
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
AbiParam
{
pub
value_type
:
Type
pub
purpose
:
ArgumentPurpose
pub
extension
:
ArgumentExtension
pub
location
:
ArgumentLoc
pub
legalized_to_pointer
:
bool
}
impl
AbiParam
{
pub
fn
new
(
vt
:
Type
)
-
>
Self
{
Self
{
value_type
:
vt
extension
:
ArgumentExtension
:
:
None
purpose
:
ArgumentPurpose
:
:
Normal
location
:
Default
:
:
default
(
)
legalized_to_pointer
:
false
}
}
pub
fn
special
(
vt
:
Type
purpose
:
ArgumentPurpose
)
-
>
Self
{
Self
{
value_type
:
vt
extension
:
ArgumentExtension
:
:
None
purpose
location
:
Default
:
:
default
(
)
legalized_to_pointer
:
false
}
}
pub
fn
special_reg
(
vt
:
Type
purpose
:
ArgumentPurpose
regunit
:
RegUnit
)
-
>
Self
{
Self
{
value_type
:
vt
extension
:
ArgumentExtension
:
:
None
purpose
location
:
ArgumentLoc
:
:
Reg
(
regunit
)
legalized_to_pointer
:
false
}
}
pub
fn
uext
(
self
)
-
>
Self
{
debug_assert
!
(
self
.
value_type
.
is_int
(
)
"
uext
on
{
}
arg
"
self
.
value_type
)
;
Self
{
extension
:
ArgumentExtension
:
:
Uext
.
.
self
}
}
pub
fn
sext
(
self
)
-
>
Self
{
debug_assert
!
(
self
.
value_type
.
is_int
(
)
"
sext
on
{
}
arg
"
self
.
value_type
)
;
Self
{
extension
:
ArgumentExtension
:
:
Sext
.
.
self
}
}
pub
fn
display
<
'
a
R
:
Into
<
Option
<
&
'
a
RegInfo
>
>
>
(
&
'
a
self
regs
:
R
)
-
>
DisplayAbiParam
<
'
a
>
{
DisplayAbiParam
(
self
regs
.
into
(
)
)
}
}
pub
struct
DisplayAbiParam
<
'
a
>
(
&
'
a
AbiParam
Option
<
&
'
a
RegInfo
>
)
;
impl
<
'
a
>
fmt
:
:
Display
for
DisplayAbiParam
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
0
.
value_type
)
?
;
if
self
.
0
.
legalized_to_pointer
{
write
!
(
f
"
ptr
"
)
?
;
}
match
self
.
0
.
extension
{
ArgumentExtension
:
:
None
=
>
{
}
ArgumentExtension
:
:
Uext
=
>
write
!
(
f
"
uext
"
)
?
ArgumentExtension
:
:
Sext
=
>
write
!
(
f
"
sext
"
)
?
}
if
self
.
0
.
purpose
!
=
ArgumentPurpose
:
:
Normal
{
write
!
(
f
"
{
}
"
self
.
0
.
purpose
)
?
;
}
if
self
.
0
.
location
.
is_assigned
(
)
{
write
!
(
f
"
[
{
}
]
"
self
.
0
.
location
.
display
(
self
.
1
)
)
?
;
}
Ok
(
(
)
)
}
}
impl
fmt
:
:
Display
for
AbiParam
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
display
(
None
)
.
fmt
(
f
)
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
Hash
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
ArgumentExtension
{
None
Uext
Sext
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
Hash
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
ArgumentPurpose
{
Normal
StructArgument
(
u32
)
StructReturn
Link
FramePointer
CalleeSaved
VMContext
SignatureId
StackLimit
CalleeTLS
CallerTLS
}
impl
fmt
:
:
Display
for
ArgumentPurpose
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
self
{
Self
:
:
Normal
=
>
"
normal
"
Self
:
:
StructArgument
(
size
)
=
>
return
write
!
(
f
"
sarg
(
{
}
)
"
size
)
Self
:
:
StructReturn
=
>
"
sret
"
Self
:
:
Link
=
>
"
link
"
Self
:
:
FramePointer
=
>
"
fp
"
Self
:
:
CalleeSaved
=
>
"
csr
"
Self
:
:
VMContext
=
>
"
vmctx
"
Self
:
:
SignatureId
=
>
"
sigid
"
Self
:
:
StackLimit
=
>
"
stack_limit
"
Self
:
:
CalleeTLS
=
>
"
callee_tls
"
Self
:
:
CallerTLS
=
>
"
caller_tls
"
}
)
}
}
impl
FromStr
for
ArgumentPurpose
{
type
Err
=
(
)
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
(
)
>
{
match
s
{
"
normal
"
=
>
Ok
(
Self
:
:
Normal
)
"
sret
"
=
>
Ok
(
Self
:
:
StructReturn
)
"
link
"
=
>
Ok
(
Self
:
:
Link
)
"
fp
"
=
>
Ok
(
Self
:
:
FramePointer
)
"
csr
"
=
>
Ok
(
Self
:
:
CalleeSaved
)
"
vmctx
"
=
>
Ok
(
Self
:
:
VMContext
)
"
sigid
"
=
>
Ok
(
Self
:
:
SignatureId
)
"
stack_limit
"
=
>
Ok
(
Self
:
:
StackLimit
)
_
if
s
.
starts_with
(
"
sarg
(
"
)
=
>
{
if
!
s
.
ends_with
(
"
)
"
)
{
return
Err
(
(
)
)
;
}
let
size
:
u32
=
s
[
"
sarg
(
"
.
len
(
)
.
.
s
.
len
(
)
-
1
]
.
parse
(
)
.
map_err
(
|
_
|
(
)
)
?
;
Ok
(
Self
:
:
StructArgument
(
size
)
)
}
_
=
>
Err
(
(
)
)
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
ExtFuncData
{
pub
name
:
ExternalName
pub
signature
:
SigRef
pub
colocated
:
bool
}
impl
fmt
:
:
Display
for
ExtFuncData
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
colocated
{
write
!
(
f
"
colocated
"
)
?
;
}
write
!
(
f
"
{
}
{
}
"
self
.
name
self
.
signature
)
}
}
impl
ExtFuncData
{
pub
fn
reloc_distance
(
&
self
)
-
>
RelocDistance
{
if
self
.
colocated
{
RelocDistance
:
:
Near
}
else
{
RelocDistance
:
:
Far
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
ir
:
:
types
:
:
{
B8
F32
I32
}
;
use
alloc
:
:
string
:
:
ToString
;
#
[
test
]
fn
argument_type
(
)
{
let
t
=
AbiParam
:
:
new
(
I32
)
;
assert_eq
!
(
t
.
to_string
(
)
"
i32
"
)
;
let
mut
t
=
t
.
uext
(
)
;
assert_eq
!
(
t
.
to_string
(
)
"
i32
uext
"
)
;
assert_eq
!
(
t
.
sext
(
)
.
to_string
(
)
"
i32
sext
"
)
;
t
.
purpose
=
ArgumentPurpose
:
:
StructReturn
;
assert_eq
!
(
t
.
to_string
(
)
"
i32
uext
sret
"
)
;
t
.
legalized_to_pointer
=
true
;
assert_eq
!
(
t
.
to_string
(
)
"
i32
ptr
uext
sret
"
)
;
}
#
[
test
]
fn
argument_purpose
(
)
{
let
all_purpose
=
[
(
ArgumentPurpose
:
:
Normal
"
normal
"
)
(
ArgumentPurpose
:
:
StructReturn
"
sret
"
)
(
ArgumentPurpose
:
:
Link
"
link
"
)
(
ArgumentPurpose
:
:
FramePointer
"
fp
"
)
(
ArgumentPurpose
:
:
CalleeSaved
"
csr
"
)
(
ArgumentPurpose
:
:
VMContext
"
vmctx
"
)
(
ArgumentPurpose
:
:
SignatureId
"
sigid
"
)
(
ArgumentPurpose
:
:
StackLimit
"
stack_limit
"
)
(
ArgumentPurpose
:
:
StructArgument
(
42
)
"
sarg
(
42
)
"
)
]
;
for
&
(
e
n
)
in
&
all_purpose
{
assert_eq
!
(
e
.
to_string
(
)
n
)
;
assert_eq
!
(
Ok
(
e
)
n
.
parse
(
)
)
;
}
}
#
[
test
]
fn
call_conv
(
)
{
for
&
cc
in
&
[
CallConv
:
:
Fast
CallConv
:
:
Cold
CallConv
:
:
SystemV
CallConv
:
:
WindowsFastcall
CallConv
:
:
BaldrdashSystemV
CallConv
:
:
BaldrdashWindows
CallConv
:
:
Baldrdash2020
]
{
assert_eq
!
(
Ok
(
cc
)
cc
.
to_string
(
)
.
parse
(
)
)
}
}
#
[
test
]
fn
signatures
(
)
{
let
mut
sig
=
Signature
:
:
new
(
CallConv
:
:
BaldrdashSystemV
)
;
assert_eq
!
(
sig
.
to_string
(
)
"
(
)
baldrdash_system_v
"
)
;
sig
.
params
.
push
(
AbiParam
:
:
new
(
I32
)
)
;
assert_eq
!
(
sig
.
to_string
(
)
"
(
i32
)
baldrdash_system_v
"
)
;
sig
.
returns
.
push
(
AbiParam
:
:
new
(
F32
)
)
;
assert_eq
!
(
sig
.
to_string
(
)
"
(
i32
)
-
>
f32
baldrdash_system_v
"
)
;
sig
.
params
.
push
(
AbiParam
:
:
new
(
I32
.
by
(
4
)
.
unwrap
(
)
)
)
;
assert_eq
!
(
sig
.
to_string
(
)
"
(
i32
i32x4
)
-
>
f32
baldrdash_system_v
"
)
;
sig
.
returns
.
push
(
AbiParam
:
:
new
(
B8
)
)
;
assert_eq
!
(
sig
.
to_string
(
)
"
(
i32
i32x4
)
-
>
f32
b8
baldrdash_system_v
"
)
;
sig
.
params
[
0
]
.
location
=
ArgumentLoc
:
:
Stack
(
24
)
;
sig
.
params
[
1
]
.
location
=
ArgumentLoc
:
:
Stack
(
8
)
;
assert_eq
!
(
sig
.
to_string
(
)
"
(
i32
[
24
]
i32x4
[
8
]
)
-
>
f32
b8
baldrdash_system_v
"
)
;
}
}
