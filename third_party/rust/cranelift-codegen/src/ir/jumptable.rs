use
ir
:
:
entities
:
:
Ebb
;
use
packed_option
:
:
PackedOption
;
use
std
:
:
fmt
:
:
{
self
Display
Formatter
}
;
use
std
:
:
iter
;
use
std
:
:
slice
;
use
std
:
:
vec
:
:
Vec
;
#
[
derive
(
Clone
)
]
pub
struct
JumpTableData
{
table
:
Vec
<
PackedOption
<
Ebb
>
>
holes
:
usize
}
impl
JumpTableData
{
pub
fn
new
(
)
-
>
Self
{
Self
{
table
:
Vec
:
:
new
(
)
holes
:
0
}
}
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
table
:
Vec
:
:
with_capacity
(
capacity
)
holes
:
0
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
table
.
len
(
)
}
pub
fn
set_entry
(
&
mut
self
idx
:
usize
dest
:
Ebb
)
{
if
idx
>
=
self
.
table
.
len
(
)
{
self
.
holes
+
=
idx
-
self
.
table
.
len
(
)
;
self
.
table
.
resize
(
idx
+
1
None
.
into
(
)
)
;
}
else
if
self
.
table
[
idx
]
.
is_none
(
)
{
self
.
holes
-
=
1
;
}
self
.
table
[
idx
]
=
dest
.
into
(
)
;
}
pub
fn
push_entry
(
&
mut
self
dest
:
Ebb
)
{
self
.
table
.
push
(
dest
.
into
(
)
)
}
pub
fn
clear_entry
(
&
mut
self
idx
:
usize
)
{
if
idx
<
self
.
table
.
len
(
)
&
&
self
.
table
[
idx
]
.
is_some
(
)
{
self
.
holes
+
=
1
;
self
.
table
[
idx
]
=
None
.
into
(
)
;
}
}
pub
fn
get_entry
(
&
self
idx
:
usize
)
-
>
Option
<
Ebb
>
{
self
.
table
.
get
(
idx
)
.
and_then
(
|
e
|
e
.
expand
(
)
)
}
pub
fn
entries
(
&
self
)
-
>
Entries
{
Entries
(
self
.
table
.
iter
(
)
.
cloned
(
)
.
enumerate
(
)
)
}
pub
fn
branches_to
(
&
self
ebb
:
Ebb
)
-
>
bool
{
self
.
table
.
iter
(
)
.
any
(
|
target_ebb
|
target_ebb
.
expand
(
)
=
=
Some
(
ebb
)
)
}
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
PackedOption
<
Ebb
>
]
{
self
.
table
.
as_mut_slice
(
)
}
}
pub
struct
Entries
<
'
a
>
(
iter
:
:
Enumerate
<
iter
:
:
Cloned
<
slice
:
:
Iter
<
'
a
PackedOption
<
Ebb
>
>
>
>
)
;
impl
<
'
a
>
Iterator
for
Entries
<
'
a
>
{
type
Item
=
(
usize
Ebb
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
loop
{
if
let
Some
(
(
idx
dest
)
)
=
self
.
0
.
next
(
)
{
if
let
Some
(
ebb
)
=
dest
.
expand
(
)
{
return
Some
(
(
idx
ebb
)
)
;
}
}
else
{
return
None
;
}
}
}
}
impl
Display
for
JumpTableData
{
fn
fmt
(
&
self
fmt
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
match
self
.
table
.
first
(
)
.
and_then
(
|
e
|
e
.
expand
(
)
)
{
None
=
>
write
!
(
fmt
"
jump_table
0
"
)
?
Some
(
first
)
=
>
write
!
(
fmt
"
jump_table
{
}
"
first
)
?
}
for
dest
in
self
.
table
.
iter
(
)
.
skip
(
1
)
.
map
(
|
e
|
e
.
expand
(
)
)
{
match
dest
{
None
=
>
write
!
(
fmt
"
0
"
)
?
Some
(
ebb
)
=
>
write
!
(
fmt
"
{
}
"
ebb
)
?
}
}
Ok
(
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
JumpTableData
;
use
entity
:
:
EntityRef
;
use
ir
:
:
Ebb
;
use
std
:
:
string
:
:
ToString
;
use
std
:
:
vec
:
:
Vec
;
#
[
test
]
fn
empty
(
)
{
let
jt
=
JumpTableData
:
:
new
(
)
;
assert_eq
!
(
jt
.
get_entry
(
0
)
None
)
;
assert_eq
!
(
jt
.
get_entry
(
10
)
None
)
;
assert_eq
!
(
jt
.
to_string
(
)
"
jump_table
0
"
)
;
let
v
:
Vec
<
(
usize
Ebb
)
>
=
jt
.
entries
(
)
.
collect
(
)
;
assert_eq
!
(
v
[
]
)
;
}
#
[
test
]
fn
insert
(
)
{
let
e1
=
Ebb
:
:
new
(
1
)
;
let
e2
=
Ebb
:
:
new
(
2
)
;
let
mut
jt
=
JumpTableData
:
:
new
(
)
;
jt
.
set_entry
(
0
e1
)
;
jt
.
set_entry
(
0
e2
)
;
jt
.
set_entry
(
10
e1
)
;
assert_eq
!
(
jt
.
to_string
(
)
"
jump_table
ebb2
0
0
0
0
0
0
0
0
0
ebb1
"
)
;
let
v
:
Vec
<
(
usize
Ebb
)
>
=
jt
.
entries
(
)
.
collect
(
)
;
assert_eq
!
(
v
[
(
0
e2
)
(
10
e1
)
]
)
;
}
}
