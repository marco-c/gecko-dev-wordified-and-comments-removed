use
crate
:
:
entity
:
:
{
self
PrimaryMap
SecondaryMap
}
;
use
crate
:
:
ir
;
use
crate
:
:
ir
:
:
builder
:
:
ReplaceBuilder
;
use
crate
:
:
ir
:
:
extfunc
:
:
ExtFuncData
;
use
crate
:
:
ir
:
:
instructions
:
:
{
BranchInfo
CallInfo
InstructionData
}
;
use
crate
:
:
ir
:
:
{
types
ConstantPool
}
;
use
crate
:
:
ir
:
:
{
Ebb
FuncRef
Inst
SigRef
Signature
Type
Value
ValueLabelAssignments
ValueList
ValueListPool
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
crate
:
:
packed_option
:
:
ReservedValue
;
use
crate
:
:
write
:
:
write_operands
;
use
core
:
:
fmt
;
use
core
:
:
iter
;
use
core
:
:
mem
;
use
core
:
:
ops
:
:
{
Index
IndexMut
}
;
use
core
:
:
u16
;
use
std
:
:
collections
:
:
HashMap
;
#
[
derive
(
Clone
)
]
pub
struct
DataFlowGraph
{
insts
:
PrimaryMap
<
Inst
InstructionData
>
results
:
SecondaryMap
<
Inst
ValueList
>
ebbs
:
PrimaryMap
<
Ebb
EbbData
>
pub
value_lists
:
ValueListPool
values
:
PrimaryMap
<
Value
ValueData
>
pub
signatures
:
PrimaryMap
<
SigRef
Signature
>
pub
ext_funcs
:
PrimaryMap
<
FuncRef
ExtFuncData
>
pub
values_labels
:
Option
<
HashMap
<
Value
ValueLabelAssignments
>
>
pub
constants
:
ConstantPool
}
impl
DataFlowGraph
{
pub
fn
new
(
)
-
>
Self
{
Self
{
insts
:
PrimaryMap
:
:
new
(
)
results
:
SecondaryMap
:
:
new
(
)
ebbs
:
PrimaryMap
:
:
new
(
)
value_lists
:
ValueListPool
:
:
new
(
)
values
:
PrimaryMap
:
:
new
(
)
signatures
:
PrimaryMap
:
:
new
(
)
ext_funcs
:
PrimaryMap
:
:
new
(
)
values_labels
:
None
constants
:
ConstantPool
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
insts
.
clear
(
)
;
self
.
results
.
clear
(
)
;
self
.
ebbs
.
clear
(
)
;
self
.
value_lists
.
clear
(
)
;
self
.
values
.
clear
(
)
;
self
.
signatures
.
clear
(
)
;
self
.
ext_funcs
.
clear
(
)
;
self
.
values_labels
=
None
;
self
.
constants
.
clear
(
)
}
pub
fn
num_insts
(
&
self
)
-
>
usize
{
self
.
insts
.
len
(
)
}
pub
fn
inst_is_valid
(
&
self
inst
:
Inst
)
-
>
bool
{
self
.
insts
.
is_valid
(
inst
)
}
pub
fn
num_ebbs
(
&
self
)
-
>
usize
{
self
.
ebbs
.
len
(
)
}
pub
fn
ebb_is_valid
(
&
self
ebb
:
Ebb
)
-
>
bool
{
self
.
ebbs
.
is_valid
(
ebb
)
}
pub
fn
num_values
(
&
self
)
-
>
usize
{
self
.
values
.
len
(
)
}
pub
fn
collect_debug_info
(
&
mut
self
)
{
if
self
.
values_labels
.
is_none
(
)
{
self
.
values_labels
=
Some
(
HashMap
:
:
new
(
)
)
;
}
}
}
fn
maybe_resolve_aliases
(
values
:
&
PrimaryMap
<
Value
ValueData
>
value
:
Value
)
-
>
Option
<
Value
>
{
let
mut
v
=
value
;
for
_
in
0
.
.
=
values
.
len
(
)
{
if
let
ValueData
:
:
Alias
{
original
.
.
}
=
values
[
v
]
{
v
=
original
;
}
else
{
return
Some
(
v
)
;
}
}
None
}
fn
resolve_aliases
(
values
:
&
PrimaryMap
<
Value
ValueData
>
value
:
Value
)
-
>
Value
{
if
let
Some
(
v
)
=
maybe_resolve_aliases
(
values
value
)
{
v
}
else
{
panic
!
(
"
Value
alias
loop
detected
for
{
}
"
value
)
;
}
}
pub
struct
Values
<
'
a
>
{
inner
:
entity
:
:
Iter
<
'
a
Value
ValueData
>
}
fn
valid_valuedata
(
data
:
&
ValueData
)
-
>
bool
{
if
let
ValueData
:
:
Alias
{
ty
:
types
:
:
INVALID
original
}
=
*
data
{
if
original
=
=
Value
:
:
reserved_value
(
)
{
return
false
;
}
}
true
}
impl
<
'
a
>
Iterator
for
Values
<
'
a
>
{
type
Item
=
Value
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
by_ref
(
)
.
find
(
|
kv
|
valid_valuedata
(
kv
.
1
)
)
.
map
(
|
kv
|
kv
.
0
)
}
}
impl
DataFlowGraph
{
fn
make_value
(
&
mut
self
data
:
ValueData
)
-
>
Value
{
self
.
values
.
push
(
data
)
}
pub
fn
values
<
'
a
>
(
&
'
a
self
)
-
>
Values
{
Values
{
inner
:
self
.
values
.
iter
(
)
}
}
pub
fn
value_is_valid
(
&
self
v
:
Value
)
-
>
bool
{
self
.
values
.
is_valid
(
v
)
}
pub
fn
value_type
(
&
self
v
:
Value
)
-
>
Type
{
match
self
.
values
[
v
]
{
ValueData
:
:
Inst
{
ty
.
.
}
|
ValueData
:
:
Param
{
ty
.
.
}
|
ValueData
:
:
Alias
{
ty
.
.
}
=
>
ty
}
}
pub
fn
value_def
(
&
self
v
:
Value
)
-
>
ValueDef
{
match
self
.
values
[
v
]
{
ValueData
:
:
Inst
{
inst
num
.
.
}
=
>
ValueDef
:
:
Result
(
inst
num
as
usize
)
ValueData
:
:
Param
{
ebb
num
.
.
}
=
>
ValueDef
:
:
Param
(
ebb
num
as
usize
)
ValueData
:
:
Alias
{
original
.
.
}
=
>
{
self
.
value_def
(
self
.
resolve_aliases
(
original
)
)
}
}
}
pub
fn
value_is_attached
(
&
self
v
:
Value
)
-
>
bool
{
use
self
:
:
ValueData
:
:
*
;
match
self
.
values
[
v
]
{
Inst
{
inst
num
.
.
}
=
>
Some
(
&
v
)
=
=
self
.
inst_results
(
inst
)
.
get
(
num
as
usize
)
Param
{
ebb
num
.
.
}
=
>
Some
(
&
v
)
=
=
self
.
ebb_params
(
ebb
)
.
get
(
num
as
usize
)
Alias
{
.
.
}
=
>
false
}
}
pub
fn
resolve_aliases
(
&
self
value
:
Value
)
-
>
Value
{
resolve_aliases
(
&
self
.
values
value
)
}
pub
fn
resolve_aliases_in_arguments
(
&
mut
self
inst
:
Inst
)
{
for
arg
in
self
.
insts
[
inst
]
.
arguments_mut
(
&
mut
self
.
value_lists
)
{
let
resolved
=
resolve_aliases
(
&
self
.
values
*
arg
)
;
if
resolved
!
=
*
arg
{
*
arg
=
resolved
;
}
}
}
pub
fn
change_to_alias
(
&
mut
self
dest
:
Value
src
:
Value
)
{
debug_assert
!
(
!
self
.
value_is_attached
(
dest
)
)
;
let
original
=
self
.
resolve_aliases
(
src
)
;
debug_assert_ne
!
(
dest
original
"
Aliasing
{
}
to
{
}
would
create
a
loop
"
dest
src
)
;
let
ty
=
self
.
value_type
(
original
)
;
debug_assert_eq
!
(
self
.
value_type
(
dest
)
ty
"
Aliasing
{
}
to
{
}
would
change
its
type
{
}
to
{
}
"
dest
src
self
.
value_type
(
dest
)
ty
)
;
debug_assert_ne
!
(
ty
types
:
:
INVALID
)
;
self
.
values
[
dest
]
=
ValueData
:
:
Alias
{
ty
original
}
;
}
pub
fn
replace_with_aliases
(
&
mut
self
dest_inst
:
Inst
src_inst
:
Inst
)
{
debug_assert_ne
!
(
dest_inst
src_inst
"
Replacing
{
}
with
itself
would
create
a
loop
"
dest_inst
)
;
debug_assert_eq
!
(
self
.
results
[
dest_inst
]
.
len
(
&
self
.
value_lists
)
self
.
results
[
src_inst
]
.
len
(
&
self
.
value_lists
)
"
Replacing
{
}
with
{
}
would
produce
a
different
number
of
results
.
"
dest_inst
src_inst
)
;
for
(
&
dest
&
src
)
in
self
.
results
[
dest_inst
]
.
as_slice
(
&
self
.
value_lists
)
.
iter
(
)
.
zip
(
self
.
results
[
src_inst
]
.
as_slice
(
&
self
.
value_lists
)
)
{
let
original
=
src
;
let
ty
=
self
.
value_type
(
original
)
;
debug_assert_eq
!
(
self
.
value_type
(
dest
)
ty
"
Aliasing
{
}
to
{
}
would
change
its
type
{
}
to
{
}
"
dest
src
self
.
value_type
(
dest
)
ty
)
;
debug_assert_ne
!
(
ty
types
:
:
INVALID
)
;
self
.
values
[
dest
]
=
ValueData
:
:
Alias
{
ty
original
}
;
}
self
.
clear_results
(
dest_inst
)
;
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
ValueDef
{
Result
(
Inst
usize
)
Param
(
Ebb
usize
)
}
impl
ValueDef
{
pub
fn
unwrap_inst
(
&
self
)
-
>
Inst
{
match
*
self
{
ValueDef
:
:
Result
(
inst
_
)
=
>
inst
_
=
>
panic
!
(
"
Value
is
not
an
instruction
result
"
)
}
}
pub
fn
unwrap_ebb
(
&
self
)
-
>
Ebb
{
match
*
self
{
ValueDef
:
:
Param
(
ebb
_
)
=
>
ebb
_
=
>
panic
!
(
"
Value
is
not
an
EBB
parameter
"
)
}
}
pub
fn
pp
(
self
)
-
>
ir
:
:
ExpandedProgramPoint
{
self
.
into
(
)
}
pub
fn
num
(
self
)
-
>
usize
{
match
self
{
ValueDef
:
:
Result
(
_
n
)
|
ValueDef
:
:
Param
(
_
n
)
=
>
n
}
}
}
#
[
derive
(
Clone
Debug
)
]
enum
ValueData
{
Inst
{
ty
:
Type
num
:
u16
inst
:
Inst
}
Param
{
ty
:
Type
num
:
u16
ebb
:
Ebb
}
Alias
{
ty
:
Type
original
:
Value
}
}
impl
DataFlowGraph
{
pub
fn
make_inst
(
&
mut
self
data
:
InstructionData
)
-
>
Inst
{
let
n
=
self
.
num_insts
(
)
+
1
;
self
.
results
.
resize
(
n
)
;
self
.
insts
.
push
(
data
)
}
pub
fn
display_inst
<
'
a
I
:
Into
<
Option
<
&
'
a
dyn
TargetIsa
>
>
>
(
&
'
a
self
inst
:
Inst
isa
:
I
)
-
>
DisplayInst
<
'
a
>
{
DisplayInst
(
self
isa
.
into
(
)
inst
)
}
pub
fn
inst_args
(
&
self
inst
:
Inst
)
-
>
&
[
Value
]
{
self
.
insts
[
inst
]
.
arguments
(
&
self
.
value_lists
)
}
pub
fn
inst_args_mut
(
&
mut
self
inst
:
Inst
)
-
>
&
mut
[
Value
]
{
self
.
insts
[
inst
]
.
arguments_mut
(
&
mut
self
.
value_lists
)
}
pub
fn
inst_fixed_args
(
&
self
inst
:
Inst
)
-
>
&
[
Value
]
{
let
num_fixed_args
=
self
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
&
self
.
inst_args
(
inst
)
[
.
.
num_fixed_args
]
}
pub
fn
inst_fixed_args_mut
(
&
mut
self
inst
:
Inst
)
-
>
&
mut
[
Value
]
{
let
num_fixed_args
=
self
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
&
mut
self
.
inst_args_mut
(
inst
)
[
.
.
num_fixed_args
]
}
pub
fn
inst_variable_args
(
&
self
inst
:
Inst
)
-
>
&
[
Value
]
{
let
num_fixed_args
=
self
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
&
self
.
inst_args
(
inst
)
[
num_fixed_args
.
.
]
}
pub
fn
inst_variable_args_mut
(
&
mut
self
inst
:
Inst
)
-
>
&
mut
[
Value
]
{
let
num_fixed_args
=
self
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
&
mut
self
.
inst_args_mut
(
inst
)
[
num_fixed_args
.
.
]
}
pub
fn
make_inst_results
(
&
mut
self
inst
:
Inst
ctrl_typevar
:
Type
)
-
>
usize
{
self
.
make_inst_results_reusing
(
inst
ctrl_typevar
iter
:
:
empty
(
)
)
}
pub
fn
make_inst_results_reusing
<
I
>
(
&
mut
self
inst
:
Inst
ctrl_typevar
:
Type
reuse
:
I
)
-
>
usize
where
I
:
Iterator
<
Item
=
Option
<
Value
>
>
{
let
mut
reuse
=
reuse
.
fuse
(
)
;
self
.
results
[
inst
]
.
clear
(
&
mut
self
.
value_lists
)
;
if
let
Some
(
sig
)
=
self
.
call_signature
(
inst
)
{
debug_assert_eq
!
(
self
.
insts
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_results
(
)
0
)
;
let
num_results
=
self
.
signatures
[
sig
]
.
returns
.
len
(
)
;
for
res_idx
in
0
.
.
num_results
{
let
ty
=
self
.
signatures
[
sig
]
.
returns
[
res_idx
]
.
value_type
;
if
let
Some
(
Some
(
v
)
)
=
reuse
.
next
(
)
{
debug_assert_eq
!
(
self
.
value_type
(
v
)
ty
"
Reused
{
}
is
wrong
type
"
ty
)
;
self
.
attach_result
(
inst
v
)
;
}
else
{
self
.
append_result
(
inst
ty
)
;
}
}
num_results
}
else
{
let
constraints
=
self
.
insts
[
inst
]
.
opcode
(
)
.
constraints
(
)
;
let
num_results
=
constraints
.
num_fixed_results
(
)
;
for
res_idx
in
0
.
.
num_results
{
let
ty
=
constraints
.
result_type
(
res_idx
ctrl_typevar
)
;
if
let
Some
(
Some
(
v
)
)
=
reuse
.
next
(
)
{
debug_assert_eq
!
(
self
.
value_type
(
v
)
ty
"
Reused
{
}
is
wrong
type
"
ty
)
;
self
.
attach_result
(
inst
v
)
;
}
else
{
self
.
append_result
(
inst
ty
)
;
}
}
num_results
}
}
pub
fn
replace
(
&
mut
self
inst
:
Inst
)
-
>
ReplaceBuilder
{
ReplaceBuilder
:
:
new
(
self
inst
)
}
pub
fn
detach_results
(
&
mut
self
inst
:
Inst
)
-
>
ValueList
{
self
.
results
[
inst
]
.
take
(
)
}
pub
fn
clear_results
(
&
mut
self
inst
:
Inst
)
{
self
.
results
[
inst
]
.
clear
(
&
mut
self
.
value_lists
)
}
pub
fn
attach_result
(
&
mut
self
inst
:
Inst
res
:
Value
)
{
debug_assert
!
(
!
self
.
value_is_attached
(
res
)
)
;
let
num
=
self
.
results
[
inst
]
.
push
(
res
&
mut
self
.
value_lists
)
;
debug_assert
!
(
num
<
=
u16
:
:
MAX
as
usize
"
Too
many
result
values
"
)
;
let
ty
=
self
.
value_type
(
res
)
;
self
.
values
[
res
]
=
ValueData
:
:
Inst
{
ty
num
:
num
as
u16
inst
}
;
}
pub
fn
replace_result
(
&
mut
self
old_value
:
Value
new_type
:
Type
)
-
>
Value
{
let
(
num
inst
)
=
match
self
.
values
[
old_value
]
{
ValueData
:
:
Inst
{
num
inst
.
.
}
=
>
(
num
inst
)
_
=
>
panic
!
(
"
{
}
is
not
an
instruction
result
value
"
old_value
)
}
;
let
new_value
=
self
.
make_value
(
ValueData
:
:
Inst
{
ty
:
new_type
num
inst
}
)
;
let
num
=
num
as
usize
;
let
attached
=
mem
:
:
replace
(
self
.
results
[
inst
]
.
get_mut
(
num
&
mut
self
.
value_lists
)
.
expect
(
"
Replacing
detached
result
"
)
new_value
)
;
debug_assert_eq
!
(
attached
old_value
"
{
}
wasn
'
t
detached
from
{
}
"
old_value
self
.
display_inst
(
inst
None
)
)
;
new_value
}
pub
fn
append_result
(
&
mut
self
inst
:
Inst
ty
:
Type
)
-
>
Value
{
let
res
=
self
.
values
.
next_key
(
)
;
let
num
=
self
.
results
[
inst
]
.
push
(
res
&
mut
self
.
value_lists
)
;
debug_assert
!
(
num
<
=
u16
:
:
MAX
as
usize
"
Too
many
result
values
"
)
;
self
.
make_value
(
ValueData
:
:
Inst
{
ty
inst
num
:
num
as
u16
}
)
}
pub
fn
append_inst_arg
(
&
mut
self
inst
:
Inst
new_arg
:
Value
)
{
let
mut
branch_values
=
self
.
insts
[
inst
]
.
take_value_list
(
)
.
expect
(
"
the
instruction
doesn
'
t
have
value
arguments
"
)
;
branch_values
.
push
(
new_arg
&
mut
self
.
value_lists
)
;
self
.
insts
[
inst
]
.
put_value_list
(
branch_values
)
}
pub
fn
first_result
(
&
self
inst
:
Inst
)
-
>
Value
{
self
.
results
[
inst
]
.
first
(
&
self
.
value_lists
)
.
expect
(
"
Instruction
has
no
results
"
)
}
pub
fn
has_results
(
&
self
inst
:
Inst
)
-
>
bool
{
!
self
.
results
[
inst
]
.
is_empty
(
)
}
pub
fn
inst_results
(
&
self
inst
:
Inst
)
-
>
&
[
Value
]
{
self
.
results
[
inst
]
.
as_slice
(
&
self
.
value_lists
)
}
pub
fn
call_signature
(
&
self
inst
:
Inst
)
-
>
Option
<
SigRef
>
{
match
self
.
insts
[
inst
]
.
analyze_call
(
&
self
.
value_lists
)
{
CallInfo
:
:
NotACall
=
>
None
CallInfo
:
:
Direct
(
f
_
)
=
>
Some
(
self
.
ext_funcs
[
f
]
.
signature
)
CallInfo
:
:
Indirect
(
s
_
)
=
>
Some
(
s
)
}
}
pub
fn
analyze_branch
(
&
self
inst
:
Inst
)
-
>
BranchInfo
{
self
.
insts
[
inst
]
.
analyze_branch
(
&
self
.
value_lists
)
}
pub
fn
compute_result_type
(
&
self
inst
:
Inst
result_idx
:
usize
ctrl_typevar
:
Type
)
-
>
Option
<
Type
>
{
let
constraints
=
self
.
insts
[
inst
]
.
opcode
(
)
.
constraints
(
)
;
let
num_fixed_results
=
constraints
.
num_fixed_results
(
)
;
if
result_idx
<
num_fixed_results
{
return
Some
(
constraints
.
result_type
(
result_idx
ctrl_typevar
)
)
;
}
self
.
call_signature
(
inst
)
.
and_then
(
|
sigref
|
{
self
.
signatures
[
sigref
]
.
returns
.
get
(
result_idx
-
num_fixed_results
)
.
map
(
|
&
arg
|
arg
.
value_type
)
}
)
}
pub
fn
ctrl_typevar
(
&
self
inst
:
Inst
)
-
>
Type
{
let
constraints
=
self
[
inst
]
.
opcode
(
)
.
constraints
(
)
;
if
!
constraints
.
is_polymorphic
(
)
{
types
:
:
INVALID
}
else
if
constraints
.
requires_typevar_operand
(
)
{
self
.
value_type
(
self
[
inst
]
.
typevar_operand
(
&
self
.
value_lists
)
.
expect
(
"
Instruction
format
doesn
'
t
have
a
designated
operand
bad
opcode
.
"
)
)
}
else
{
self
.
value_type
(
self
.
first_result
(
inst
)
)
}
}
}
impl
Index
<
Inst
>
for
DataFlowGraph
{
type
Output
=
InstructionData
;
fn
index
(
&
self
inst
:
Inst
)
-
>
&
InstructionData
{
&
self
.
insts
[
inst
]
}
}
impl
IndexMut
<
Inst
>
for
DataFlowGraph
{
fn
index_mut
(
&
mut
self
inst
:
Inst
)
-
>
&
mut
InstructionData
{
&
mut
self
.
insts
[
inst
]
}
}
impl
DataFlowGraph
{
pub
fn
make_ebb
(
&
mut
self
)
-
>
Ebb
{
self
.
ebbs
.
push
(
EbbData
:
:
new
(
)
)
}
pub
fn
num_ebb_params
(
&
self
ebb
:
Ebb
)
-
>
usize
{
self
.
ebbs
[
ebb
]
.
params
.
len
(
&
self
.
value_lists
)
}
pub
fn
ebb_params
(
&
self
ebb
:
Ebb
)
-
>
&
[
Value
]
{
self
.
ebbs
[
ebb
]
.
params
.
as_slice
(
&
self
.
value_lists
)
}
pub
fn
append_ebb_param
(
&
mut
self
ebb
:
Ebb
ty
:
Type
)
-
>
Value
{
let
param
=
self
.
values
.
next_key
(
)
;
let
num
=
self
.
ebbs
[
ebb
]
.
params
.
push
(
param
&
mut
self
.
value_lists
)
;
debug_assert
!
(
num
<
=
u16
:
:
MAX
as
usize
"
Too
many
parameters
on
EBB
"
)
;
self
.
make_value
(
ValueData
:
:
Param
{
ty
num
:
num
as
u16
ebb
}
)
}
pub
fn
swap_remove_ebb_param
(
&
mut
self
val
:
Value
)
-
>
usize
{
let
(
ebb
num
)
=
if
let
ValueData
:
:
Param
{
num
ebb
.
.
}
=
self
.
values
[
val
]
{
(
ebb
num
)
}
else
{
panic
!
(
"
{
}
must
be
an
EBB
parameter
"
val
)
;
}
;
self
.
ebbs
[
ebb
]
.
params
.
swap_remove
(
num
as
usize
&
mut
self
.
value_lists
)
;
if
let
Some
(
last_arg_val
)
=
self
.
ebbs
[
ebb
]
.
params
.
get
(
num
as
usize
&
self
.
value_lists
)
{
if
let
ValueData
:
:
Param
{
num
:
ref
mut
old_num
.
.
}
=
self
.
values
[
last_arg_val
]
{
*
old_num
=
num
;
}
else
{
panic
!
(
"
{
}
should
be
an
Ebb
parameter
"
last_arg_val
)
;
}
}
num
as
usize
}
pub
fn
remove_ebb_param
(
&
mut
self
val
:
Value
)
{
let
(
ebb
num
)
=
if
let
ValueData
:
:
Param
{
num
ebb
.
.
}
=
self
.
values
[
val
]
{
(
ebb
num
)
}
else
{
panic
!
(
"
{
}
must
be
an
EBB
parameter
"
val
)
;
}
;
self
.
ebbs
[
ebb
]
.
params
.
remove
(
num
as
usize
&
mut
self
.
value_lists
)
;
for
index
in
num
.
.
(
self
.
num_ebb_params
(
ebb
)
as
u16
)
{
match
self
.
values
[
self
.
ebbs
[
ebb
]
.
params
.
get
(
index
as
usize
&
self
.
value_lists
)
.
unwrap
(
)
]
{
ValueData
:
:
Param
{
ref
mut
num
.
.
}
=
>
{
*
num
-
=
1
;
}
_
=
>
panic
!
(
"
{
}
must
be
an
EBB
parameter
"
self
.
ebbs
[
ebb
]
.
params
.
get
(
index
as
usize
&
self
.
value_lists
)
.
unwrap
(
)
)
}
}
}
pub
fn
attach_ebb_param
(
&
mut
self
ebb
:
Ebb
param
:
Value
)
{
debug_assert
!
(
!
self
.
value_is_attached
(
param
)
)
;
let
num
=
self
.
ebbs
[
ebb
]
.
params
.
push
(
param
&
mut
self
.
value_lists
)
;
debug_assert
!
(
num
<
=
u16
:
:
MAX
as
usize
"
Too
many
parameters
on
EBB
"
)
;
let
ty
=
self
.
value_type
(
param
)
;
self
.
values
[
param
]
=
ValueData
:
:
Param
{
ty
num
:
num
as
u16
ebb
}
;
}
pub
fn
replace_ebb_param
(
&
mut
self
old_value
:
Value
new_type
:
Type
)
-
>
Value
{
let
(
ebb
num
)
=
if
let
ValueData
:
:
Param
{
num
ebb
.
.
}
=
self
.
values
[
old_value
]
{
(
ebb
num
)
}
else
{
panic
!
(
"
{
}
must
be
an
EBB
parameter
"
old_value
)
;
}
;
let
new_arg
=
self
.
make_value
(
ValueData
:
:
Param
{
ty
:
new_type
num
ebb
}
)
;
self
.
ebbs
[
ebb
]
.
params
.
as_mut_slice
(
&
mut
self
.
value_lists
)
[
num
as
usize
]
=
new_arg
;
new_arg
}
pub
fn
detach_ebb_params
(
&
mut
self
ebb
:
Ebb
)
-
>
ValueList
{
self
.
ebbs
[
ebb
]
.
params
.
take
(
)
}
}
#
[
derive
(
Clone
)
]
struct
EbbData
{
params
:
ValueList
}
impl
EbbData
{
fn
new
(
)
-
>
Self
{
Self
{
params
:
ValueList
:
:
new
(
)
}
}
}
pub
struct
DisplayInst
<
'
a
>
(
&
'
a
DataFlowGraph
Option
<
&
'
a
dyn
TargetIsa
>
Inst
)
;
impl
<
'
a
>
fmt
:
:
Display
for
DisplayInst
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
dfg
=
self
.
0
;
let
isa
=
self
.
1
;
let
inst
=
self
.
2
;
if
let
Some
(
(
first
rest
)
)
=
dfg
.
inst_results
(
inst
)
.
split_first
(
)
{
write
!
(
f
"
{
}
"
first
)
?
;
for
v
in
rest
{
write
!
(
f
"
{
}
"
v
)
?
;
}
write
!
(
f
"
=
"
)
?
;
}
let
typevar
=
dfg
.
ctrl_typevar
(
inst
)
;
if
typevar
.
is_invalid
(
)
{
write
!
(
f
"
{
}
"
dfg
[
inst
]
.
opcode
(
)
)
?
;
}
else
{
write
!
(
f
"
{
}
.
{
}
"
dfg
[
inst
]
.
opcode
(
)
typevar
)
?
;
}
write_operands
(
f
dfg
isa
inst
)
}
}
impl
DataFlowGraph
{
#
[
cold
]
fn
set_value_type_for_parser
(
&
mut
self
v
:
Value
t
:
Type
)
{
assert_eq
!
(
self
.
value_type
(
v
)
types
:
:
INVALID
"
this
function
is
only
for
assigning
types
to
previously
invalid
values
"
)
;
match
self
.
values
[
v
]
{
ValueData
:
:
Inst
{
ref
mut
ty
.
.
}
|
ValueData
:
:
Param
{
ref
mut
ty
.
.
}
|
ValueData
:
:
Alias
{
ref
mut
ty
.
.
}
=
>
*
ty
=
t
}
}
#
[
cold
]
pub
fn
make_inst_results_for_parser
(
&
mut
self
inst
:
Inst
ctrl_typevar
:
Type
reuse
:
&
[
Value
]
)
-
>
usize
{
if
let
Some
(
sig
)
=
self
.
call_signature
(
inst
)
{
assert_eq
!
(
self
.
insts
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_results
(
)
0
)
;
for
res_idx
in
0
.
.
self
.
signatures
[
sig
]
.
returns
.
len
(
)
{
let
ty
=
self
.
signatures
[
sig
]
.
returns
[
res_idx
]
.
value_type
;
if
let
Some
(
v
)
=
reuse
.
get
(
res_idx
)
{
self
.
set_value_type_for_parser
(
*
v
ty
)
;
}
}
}
else
{
let
constraints
=
self
.
insts
[
inst
]
.
opcode
(
)
.
constraints
(
)
;
for
res_idx
in
0
.
.
constraints
.
num_fixed_results
(
)
{
let
ty
=
constraints
.
result_type
(
res_idx
ctrl_typevar
)
;
if
let
Some
(
v
)
=
reuse
.
get
(
res_idx
)
{
self
.
set_value_type_for_parser
(
*
v
ty
)
;
}
}
}
self
.
make_inst_results_reusing
(
inst
ctrl_typevar
reuse
.
iter
(
)
.
map
(
|
x
|
Some
(
*
x
)
)
)
}
#
[
cold
]
pub
fn
append_ebb_param_for_parser
(
&
mut
self
ebb
:
Ebb
ty
:
Type
val
:
Value
)
{
let
num
=
self
.
ebbs
[
ebb
]
.
params
.
push
(
val
&
mut
self
.
value_lists
)
;
assert
!
(
num
<
=
u16
:
:
MAX
as
usize
"
Too
many
parameters
on
EBB
"
)
;
self
.
values
[
val
]
=
ValueData
:
:
Param
{
ty
num
:
num
as
u16
ebb
}
;
}
#
[
cold
]
pub
fn
make_value_alias_for_serialization
(
&
mut
self
src
:
Value
dest
:
Value
)
{
assert_ne
!
(
src
Value
:
:
reserved_value
(
)
)
;
assert_ne
!
(
dest
Value
:
:
reserved_value
(
)
)
;
let
ty
=
if
self
.
values
.
is_valid
(
src
)
{
self
.
value_type
(
src
)
}
else
{
types
:
:
INVALID
}
;
let
data
=
ValueData
:
:
Alias
{
ty
original
:
src
}
;
self
.
values
[
dest
]
=
data
;
}
#
[
cold
]
pub
fn
value_alias_dest_for_serialization
(
&
self
v
:
Value
)
-
>
Option
<
Value
>
{
if
let
ValueData
:
:
Alias
{
original
.
.
}
=
self
.
values
[
v
]
{
Some
(
original
)
}
else
{
None
}
}
#
[
cold
]
pub
fn
set_alias_type_for_parser
(
&
mut
self
v
:
Value
)
-
>
bool
{
if
let
Some
(
resolved
)
=
maybe_resolve_aliases
(
&
self
.
values
v
)
{
let
old_ty
=
self
.
value_type
(
v
)
;
let
new_ty
=
self
.
value_type
(
resolved
)
;
if
old_ty
=
=
types
:
:
INVALID
{
self
.
set_value_type_for_parser
(
v
new_ty
)
;
}
else
{
assert_eq
!
(
old_ty
new_ty
)
;
}
true
}
else
{
false
}
}
#
[
cold
]
pub
fn
make_invalid_value_for_parser
(
&
mut
self
)
{
let
data
=
ValueData
:
:
Alias
{
ty
:
types
:
:
INVALID
original
:
Value
:
:
reserved_value
(
)
}
;
self
.
make_value
(
data
)
;
}
#
[
cold
]
pub
fn
value_is_valid_for_parser
(
&
self
v
:
Value
)
-
>
bool
{
if
!
self
.
value_is_valid
(
v
)
{
return
false
;
}
if
let
ValueData
:
:
Alias
{
ty
.
.
}
=
self
.
values
[
v
]
{
ty
!
=
types
:
:
INVALID
}
else
{
true
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
crate
:
:
ir
:
:
types
;
use
crate
:
:
ir
:
:
{
Function
InstructionData
Opcode
TrapCode
}
;
use
std
:
:
string
:
:
ToString
;
#
[
test
]
fn
make_inst
(
)
{
let
mut
dfg
=
DataFlowGraph
:
:
new
(
)
;
let
idata
=
InstructionData
:
:
UnaryImm
{
opcode
:
Opcode
:
:
Iconst
imm
:
0
.
into
(
)
}
;
let
inst
=
dfg
.
make_inst
(
idata
)
;
dfg
.
make_inst_results
(
inst
types
:
:
I32
)
;
assert_eq
!
(
inst
.
to_string
(
)
"
inst0
"
)
;
assert_eq
!
(
dfg
.
display_inst
(
inst
None
)
.
to_string
(
)
"
v0
=
iconst
.
i32
0
"
)
;
{
let
immdfg
=
&
dfg
;
let
ins
=
&
immdfg
[
inst
]
;
assert_eq
!
(
ins
.
opcode
(
)
Opcode
:
:
Iconst
)
;
}
let
val
=
dfg
.
first_result
(
inst
)
;
assert_eq
!
(
dfg
.
inst_results
(
inst
)
&
[
val
]
)
;
assert_eq
!
(
dfg
.
value_def
(
val
)
ValueDef
:
:
Result
(
inst
0
)
)
;
assert_eq
!
(
dfg
.
value_type
(
val
)
types
:
:
I32
)
;
assert
!
(
dfg
.
value_is_attached
(
val
)
)
;
let
v2
=
dfg
.
replace_result
(
val
types
:
:
F64
)
;
assert
!
(
!
dfg
.
value_is_attached
(
val
)
)
;
assert
!
(
dfg
.
value_is_attached
(
v2
)
)
;
assert_eq
!
(
dfg
.
inst_results
(
inst
)
&
[
v2
]
)
;
assert_eq
!
(
dfg
.
value_def
(
v2
)
ValueDef
:
:
Result
(
inst
0
)
)
;
assert_eq
!
(
dfg
.
value_type
(
v2
)
types
:
:
F64
)
;
}
#
[
test
]
fn
no_results
(
)
{
let
mut
dfg
=
DataFlowGraph
:
:
new
(
)
;
let
idata
=
InstructionData
:
:
Trap
{
opcode
:
Opcode
:
:
Trap
code
:
TrapCode
:
:
User
(
0
)
}
;
let
inst
=
dfg
.
make_inst
(
idata
)
;
assert_eq
!
(
dfg
.
display_inst
(
inst
None
)
.
to_string
(
)
"
trap
user0
"
)
;
assert_eq
!
(
dfg
.
inst_results
(
inst
)
&
[
]
)
;
}
#
[
test
]
fn
ebb
(
)
{
let
mut
dfg
=
DataFlowGraph
:
:
new
(
)
;
let
ebb
=
dfg
.
make_ebb
(
)
;
assert_eq
!
(
ebb
.
to_string
(
)
"
ebb0
"
)
;
assert_eq
!
(
dfg
.
num_ebb_params
(
ebb
)
0
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
]
)
;
assert
!
(
dfg
.
detach_ebb_params
(
ebb
)
.
is_empty
(
)
)
;
assert_eq
!
(
dfg
.
num_ebb_params
(
ebb
)
0
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
]
)
;
let
arg1
=
dfg
.
append_ebb_param
(
ebb
types
:
:
F32
)
;
assert_eq
!
(
arg1
.
to_string
(
)
"
v0
"
)
;
assert_eq
!
(
dfg
.
num_ebb_params
(
ebb
)
1
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
arg1
]
)
;
let
arg2
=
dfg
.
append_ebb_param
(
ebb
types
:
:
I16
)
;
assert_eq
!
(
arg2
.
to_string
(
)
"
v1
"
)
;
assert_eq
!
(
dfg
.
num_ebb_params
(
ebb
)
2
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
arg1
arg2
]
)
;
assert_eq
!
(
dfg
.
value_def
(
arg1
)
ValueDef
:
:
Param
(
ebb
0
)
)
;
assert_eq
!
(
dfg
.
value_def
(
arg2
)
ValueDef
:
:
Param
(
ebb
1
)
)
;
assert_eq
!
(
dfg
.
value_type
(
arg1
)
types
:
:
F32
)
;
assert_eq
!
(
dfg
.
value_type
(
arg2
)
types
:
:
I16
)
;
let
vlist
=
dfg
.
detach_ebb_params
(
ebb
)
;
assert_eq
!
(
dfg
.
num_ebb_params
(
ebb
)
0
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
]
)
;
assert_eq
!
(
vlist
.
as_slice
(
&
dfg
.
value_lists
)
&
[
arg1
arg2
]
)
;
dfg
.
attach_ebb_param
(
ebb
arg2
)
;
let
arg3
=
dfg
.
append_ebb_param
(
ebb
types
:
:
I32
)
;
dfg
.
attach_ebb_param
(
ebb
arg1
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
arg2
arg3
arg1
]
)
;
}
#
[
test
]
fn
replace_ebb_params
(
)
{
let
mut
dfg
=
DataFlowGraph
:
:
new
(
)
;
let
ebb
=
dfg
.
make_ebb
(
)
;
let
arg1
=
dfg
.
append_ebb_param
(
ebb
types
:
:
F32
)
;
let
new1
=
dfg
.
replace_ebb_param
(
arg1
types
:
:
I64
)
;
assert_eq
!
(
dfg
.
value_type
(
arg1
)
types
:
:
F32
)
;
assert_eq
!
(
dfg
.
value_type
(
new1
)
types
:
:
I64
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
new1
]
)
;
dfg
.
attach_ebb_param
(
ebb
arg1
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
new1
arg1
]
)
;
let
new2
=
dfg
.
replace_ebb_param
(
arg1
types
:
:
I8
)
;
assert_eq
!
(
dfg
.
value_type
(
arg1
)
types
:
:
F32
)
;
assert_eq
!
(
dfg
.
value_type
(
new2
)
types
:
:
I8
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
new1
new2
]
)
;
dfg
.
attach_ebb_param
(
ebb
arg1
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
new1
new2
arg1
]
)
;
let
new3
=
dfg
.
replace_ebb_param
(
new2
types
:
:
I16
)
;
assert_eq
!
(
dfg
.
value_type
(
new1
)
types
:
:
I64
)
;
assert_eq
!
(
dfg
.
value_type
(
new2
)
types
:
:
I8
)
;
assert_eq
!
(
dfg
.
value_type
(
new3
)
types
:
:
I16
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
new1
new3
arg1
]
)
;
}
#
[
test
]
fn
swap_remove_ebb_params
(
)
{
let
mut
dfg
=
DataFlowGraph
:
:
new
(
)
;
let
ebb
=
dfg
.
make_ebb
(
)
;
let
arg1
=
dfg
.
append_ebb_param
(
ebb
types
:
:
F32
)
;
let
arg2
=
dfg
.
append_ebb_param
(
ebb
types
:
:
F32
)
;
let
arg3
=
dfg
.
append_ebb_param
(
ebb
types
:
:
F32
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
arg1
arg2
arg3
]
)
;
dfg
.
swap_remove_ebb_param
(
arg1
)
;
assert_eq
!
(
dfg
.
value_is_attached
(
arg1
)
false
)
;
assert_eq
!
(
dfg
.
value_is_attached
(
arg2
)
true
)
;
assert_eq
!
(
dfg
.
value_is_attached
(
arg3
)
true
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
arg3
arg2
]
)
;
dfg
.
swap_remove_ebb_param
(
arg2
)
;
assert_eq
!
(
dfg
.
value_is_attached
(
arg2
)
false
)
;
assert_eq
!
(
dfg
.
value_is_attached
(
arg3
)
true
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
arg3
]
)
;
dfg
.
swap_remove_ebb_param
(
arg3
)
;
assert_eq
!
(
dfg
.
value_is_attached
(
arg3
)
false
)
;
assert_eq
!
(
dfg
.
ebb_params
(
ebb
)
&
[
]
)
;
}
#
[
test
]
fn
aliases
(
)
{
use
crate
:
:
ir
:
:
InstBuilder
;
let
mut
func
=
Function
:
:
new
(
)
;
let
ebb0
=
func
.
dfg
.
make_ebb
(
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
&
mut
func
)
;
pos
.
insert_ebb
(
ebb0
)
;
let
v1
=
pos
.
ins
(
)
.
iconst
(
types
:
:
I32
42
)
;
assert_eq
!
(
pos
.
func
.
dfg
.
resolve_aliases
(
v1
)
v1
)
;
let
arg0
=
pos
.
func
.
dfg
.
append_ebb_param
(
ebb0
types
:
:
I32
)
;
let
(
s
c
)
=
pos
.
ins
(
)
.
iadd_cout
(
v1
arg0
)
;
let
iadd
=
match
pos
.
func
.
dfg
.
value_def
(
s
)
{
ValueDef
:
:
Result
(
i
0
)
=
>
i
_
=
>
panic
!
(
)
}
;
pos
.
func
.
dfg
.
clear_results
(
iadd
)
;
pos
.
func
.
dfg
.
attach_result
(
iadd
s
)
;
pos
.
func
.
dfg
.
replace
(
iadd
)
.
iadd
(
v1
arg0
)
;
let
c2
=
pos
.
ins
(
)
.
ifcmp
(
s
v1
)
;
pos
.
func
.
dfg
.
change_to_alias
(
c
c2
)
;
assert_eq
!
(
pos
.
func
.
dfg
.
resolve_aliases
(
c2
)
c2
)
;
assert_eq
!
(
pos
.
func
.
dfg
.
resolve_aliases
(
c
)
c2
)
;
let
c3
=
pos
.
ins
(
)
.
copy
(
c
)
;
assert_eq
!
(
pos
.
func
.
dfg
.
resolve_aliases
(
c3
)
c3
)
;
}
}
