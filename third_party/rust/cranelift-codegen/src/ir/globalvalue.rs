use
crate
:
:
ir
:
:
immediates
:
:
{
Imm64
Offset32
}
;
use
crate
:
:
ir
:
:
{
ExternalName
GlobalValue
Type
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
core
:
:
fmt
;
#
[
derive
(
Clone
)
]
pub
enum
GlobalValueData
{
VMContext
Load
{
base
:
GlobalValue
offset
:
Offset32
global_type
:
Type
readonly
:
bool
}
IAddImm
{
base
:
GlobalValue
offset
:
Imm64
global_type
:
Type
}
Symbol
{
name
:
ExternalName
offset
:
Imm64
colocated
:
bool
}
}
impl
GlobalValueData
{
pub
fn
symbol_name
(
&
self
)
-
>
&
ExternalName
{
match
*
self
{
Self
:
:
Symbol
{
ref
name
.
.
}
=
>
name
_
=
>
panic
!
(
"
only
symbols
have
names
"
)
}
}
pub
fn
global_type
(
&
self
isa
:
&
dyn
TargetIsa
)
-
>
Type
{
match
*
self
{
Self
:
:
VMContext
{
.
.
}
|
Self
:
:
Symbol
{
.
.
}
=
>
isa
.
pointer_type
(
)
Self
:
:
IAddImm
{
global_type
.
.
}
|
Self
:
:
Load
{
global_type
.
.
}
=
>
global_type
}
}
}
impl
fmt
:
:
Display
for
GlobalValueData
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
Self
:
:
VMContext
=
>
write
!
(
f
"
vmctx
"
)
Self
:
:
Load
{
base
offset
global_type
readonly
}
=
>
write
!
(
f
"
load
.
{
}
notrap
aligned
{
}
{
}
{
}
"
global_type
if
readonly
{
"
readonly
"
}
else
{
"
"
}
base
offset
)
Self
:
:
IAddImm
{
global_type
base
offset
}
=
>
write
!
(
f
"
iadd_imm
.
{
}
{
}
{
}
"
global_type
base
offset
)
Self
:
:
Symbol
{
ref
name
offset
colocated
}
=
>
{
write
!
(
f
"
symbol
{
}
{
}
"
if
colocated
{
"
colocated
"
}
else
{
"
"
}
name
)
?
;
let
offset_val
:
i64
=
offset
.
into
(
)
;
if
offset_val
>
0
{
write
!
(
f
"
+
"
)
?
;
}
if
offset_val
!
=
0
{
write
!
(
f
"
{
}
"
offset
)
?
;
}
Ok
(
(
)
)
}
}
}
}
