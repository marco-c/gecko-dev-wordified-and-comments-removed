use
std
:
:
fmt
;
use
std
:
:
u32
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Ebb
(
u32
)
;
entity_impl
!
(
Ebb
"
ebb
"
)
;
impl
Ebb
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
Ebb
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Value
(
u32
)
;
entity_impl
!
(
Value
"
v
"
)
;
impl
Value
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
/
2
{
Some
(
Value
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
PartialOrd
Ord
)
]
pub
struct
Inst
(
u32
)
;
entity_impl
!
(
Inst
"
inst
"
)
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
StackSlot
(
u32
)
;
entity_impl
!
(
StackSlot
"
ss
"
)
;
impl
StackSlot
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
StackSlot
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
GlobalValue
(
u32
)
;
entity_impl
!
(
GlobalValue
"
gv
"
)
;
impl
GlobalValue
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
GlobalValue
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
JumpTable
(
u32
)
;
entity_impl
!
(
JumpTable
"
jt
"
)
;
impl
JumpTable
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
JumpTable
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
FuncRef
(
u32
)
;
entity_impl
!
(
FuncRef
"
fn
"
)
;
impl
FuncRef
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
FuncRef
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
SigRef
(
u32
)
;
entity_impl
!
(
SigRef
"
sig
"
)
;
impl
SigRef
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
SigRef
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
Heap
(
u32
)
;
entity_impl
!
(
Heap
"
heap
"
)
;
impl
Heap
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
Heap
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
Table
(
u32
)
;
entity_impl
!
(
Table
"
table
"
)
;
impl
Table
{
pub
fn
with_number
(
n
:
u32
)
-
>
Option
<
Self
>
{
if
n
<
u32
:
:
MAX
{
Some
(
Table
(
n
)
)
}
else
{
None
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
enum
AnyEntity
{
Function
Ebb
(
Ebb
)
Inst
(
Inst
)
Value
(
Value
)
StackSlot
(
StackSlot
)
GlobalValue
(
GlobalValue
)
JumpTable
(
JumpTable
)
FuncRef
(
FuncRef
)
SigRef
(
SigRef
)
Heap
(
Heap
)
Table
(
Table
)
}
impl
fmt
:
:
Display
for
AnyEntity
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
AnyEntity
:
:
Function
=
>
write
!
(
f
"
function
"
)
AnyEntity
:
:
Ebb
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
Inst
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
Value
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
StackSlot
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
GlobalValue
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
JumpTable
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
FuncRef
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
SigRef
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
Heap
(
r
)
=
>
r
.
fmt
(
f
)
AnyEntity
:
:
Table
(
r
)
=
>
r
.
fmt
(
f
)
}
}
}
impl
fmt
:
:
Debug
for
AnyEntity
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
(
self
as
&
fmt
:
:
Display
)
.
fmt
(
f
)
}
}
impl
From
<
Ebb
>
for
AnyEntity
{
fn
from
(
r
:
Ebb
)
-
>
Self
{
AnyEntity
:
:
Ebb
(
r
)
}
}
impl
From
<
Inst
>
for
AnyEntity
{
fn
from
(
r
:
Inst
)
-
>
Self
{
AnyEntity
:
:
Inst
(
r
)
}
}
impl
From
<
Value
>
for
AnyEntity
{
fn
from
(
r
:
Value
)
-
>
Self
{
AnyEntity
:
:
Value
(
r
)
}
}
impl
From
<
StackSlot
>
for
AnyEntity
{
fn
from
(
r
:
StackSlot
)
-
>
Self
{
AnyEntity
:
:
StackSlot
(
r
)
}
}
impl
From
<
GlobalValue
>
for
AnyEntity
{
fn
from
(
r
:
GlobalValue
)
-
>
Self
{
AnyEntity
:
:
GlobalValue
(
r
)
}
}
impl
From
<
JumpTable
>
for
AnyEntity
{
fn
from
(
r
:
JumpTable
)
-
>
Self
{
AnyEntity
:
:
JumpTable
(
r
)
}
}
impl
From
<
FuncRef
>
for
AnyEntity
{
fn
from
(
r
:
FuncRef
)
-
>
Self
{
AnyEntity
:
:
FuncRef
(
r
)
}
}
impl
From
<
SigRef
>
for
AnyEntity
{
fn
from
(
r
:
SigRef
)
-
>
Self
{
AnyEntity
:
:
SigRef
(
r
)
}
}
impl
From
<
Heap
>
for
AnyEntity
{
fn
from
(
r
:
Heap
)
-
>
Self
{
AnyEntity
:
:
Heap
(
r
)
}
}
impl
From
<
Table
>
for
AnyEntity
{
fn
from
(
r
:
Table
)
-
>
Self
{
AnyEntity
:
:
Table
(
r
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
std
:
:
string
:
:
ToString
;
use
std
:
:
u32
;
#
[
test
]
fn
value_with_number
(
)
{
assert_eq
!
(
Value
:
:
with_number
(
0
)
.
unwrap
(
)
.
to_string
(
)
"
v0
"
)
;
assert_eq
!
(
Value
:
:
with_number
(
1
)
.
unwrap
(
)
.
to_string
(
)
"
v1
"
)
;
assert_eq
!
(
Value
:
:
with_number
(
u32
:
:
MAX
/
2
)
None
)
;
assert
!
(
Value
:
:
with_number
(
u32
:
:
MAX
/
2
-
1
)
.
is_some
(
)
)
;
}
#
[
test
]
fn
memory
(
)
{
use
packed_option
:
:
PackedOption
;
use
std
:
:
mem
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
Value
>
(
)
mem
:
:
size_of
:
:
<
PackedOption
<
Value
>
>
(
)
)
;
}
}
