use
core
:
:
fmt
;
#
[
cfg
(
feature
=
"
enable
-
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
enum
FlagBit
{
Notrap
Aligned
Readonly
LittleEndian
BigEndian
}
const
NAMES
:
[
&
str
;
5
]
=
[
"
notrap
"
"
aligned
"
"
readonly
"
"
little
"
"
big
"
]
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Debug
Hash
)
]
pub
enum
Endianness
{
Little
Big
}
#
[
derive
(
Clone
Copy
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
MemFlags
{
bits
:
u8
}
impl
MemFlags
{
pub
fn
new
(
)
-
>
Self
{
Self
{
bits
:
0
}
}
pub
fn
trusted
(
)
-
>
Self
{
let
mut
result
=
Self
:
:
new
(
)
;
result
.
set_notrap
(
)
;
result
.
set_aligned
(
)
;
result
}
fn
read
(
self
bit
:
FlagBit
)
-
>
bool
{
self
.
bits
&
(
1
<
<
bit
as
usize
)
!
=
0
}
fn
set
(
&
mut
self
bit
:
FlagBit
)
{
self
.
bits
|
=
1
<
<
bit
as
usize
}
pub
fn
set_by_name
(
&
mut
self
name
:
&
str
)
-
>
bool
{
match
NAMES
.
iter
(
)
.
position
(
|
&
s
|
s
=
=
name
)
{
Some
(
bit
)
=
>
{
let
bits
=
self
.
bits
|
1
<
<
bit
;
if
(
bits
&
(
1
<
<
FlagBit
:
:
LittleEndian
as
usize
)
)
!
=
0
&
&
(
bits
&
(
1
<
<
FlagBit
:
:
BigEndian
as
usize
)
)
!
=
0
{
false
}
else
{
self
.
bits
=
bits
;
true
}
}
None
=
>
false
}
}
pub
fn
endianness
(
self
native_endianness
:
Endianness
)
-
>
Endianness
{
if
self
.
read
(
FlagBit
:
:
LittleEndian
)
{
Endianness
:
:
Little
}
else
if
self
.
read
(
FlagBit
:
:
BigEndian
)
{
Endianness
:
:
Big
}
else
{
native_endianness
}
}
pub
fn
set_endianness
(
&
mut
self
endianness
:
Endianness
)
{
match
endianness
{
Endianness
:
:
Little
=
>
self
.
set
(
FlagBit
:
:
LittleEndian
)
Endianness
:
:
Big
=
>
self
.
set
(
FlagBit
:
:
BigEndian
)
}
;
assert
!
(
!
(
self
.
read
(
FlagBit
:
:
LittleEndian
)
&
&
self
.
read
(
FlagBit
:
:
BigEndian
)
)
)
;
}
pub
fn
notrap
(
self
)
-
>
bool
{
self
.
read
(
FlagBit
:
:
Notrap
)
}
pub
fn
set_notrap
(
&
mut
self
)
{
self
.
set
(
FlagBit
:
:
Notrap
)
}
pub
fn
aligned
(
self
)
-
>
bool
{
self
.
read
(
FlagBit
:
:
Aligned
)
}
pub
fn
set_aligned
(
&
mut
self
)
{
self
.
set
(
FlagBit
:
:
Aligned
)
}
pub
fn
readonly
(
self
)
-
>
bool
{
self
.
read
(
FlagBit
:
:
Readonly
)
}
pub
fn
set_readonly
(
&
mut
self
)
{
self
.
set
(
FlagBit
:
:
Readonly
)
}
}
impl
fmt
:
:
Display
for
MemFlags
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
for
(
i
n
)
in
NAMES
.
iter
(
)
.
enumerate
(
)
{
if
self
.
bits
&
(
1
<
<
i
)
!
=
0
{
write
!
(
f
"
{
}
"
n
)
?
;
}
}
Ok
(
(
)
)
}
}
