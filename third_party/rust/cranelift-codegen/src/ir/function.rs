use
crate
:
:
binemit
:
:
CodeOffset
;
use
crate
:
:
entity
:
:
{
PrimaryMap
SecondaryMap
}
;
use
crate
:
:
ir
;
use
crate
:
:
ir
:
:
{
instructions
:
:
BranchInfo
Block
ExtFuncData
FuncRef
GlobalValue
GlobalValueData
Heap
HeapData
Inst
InstructionData
JumpTable
JumpTableData
Opcode
SigRef
StackSlot
StackSlotData
Table
TableData
}
;
use
crate
:
:
ir
:
:
{
BlockOffsets
InstEncodings
SourceLocs
StackSlots
ValueLocations
}
;
use
crate
:
:
ir
:
:
{
DataFlowGraph
ExternalName
Layout
Signature
}
;
use
crate
:
:
ir
:
:
{
JumpTableOffsets
JumpTables
}
;
use
crate
:
:
isa
:
:
{
CallConv
EncInfo
Encoding
Legalize
TargetIsa
}
;
use
crate
:
:
regalloc
:
:
{
EntryRegDiversions
RegDiversions
}
;
use
crate
:
:
value_label
:
:
ValueLabelsRanges
;
use
crate
:
:
write
:
:
write_function
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
fmt
;
#
[
derive
(
Clone
)
]
pub
struct
Function
{
pub
name
:
ExternalName
pub
signature
:
Signature
pub
old_signature
:
Option
<
Signature
>
pub
stack_slots
:
StackSlots
pub
global_values
:
PrimaryMap
<
ir
:
:
GlobalValue
ir
:
:
GlobalValueData
>
pub
heaps
:
PrimaryMap
<
ir
:
:
Heap
ir
:
:
HeapData
>
pub
tables
:
PrimaryMap
<
ir
:
:
Table
ir
:
:
TableData
>
pub
jump_tables
:
JumpTables
pub
dfg
:
DataFlowGraph
pub
layout
:
Layout
pub
encodings
:
InstEncodings
pub
locations
:
ValueLocations
pub
entry_diversions
:
EntryRegDiversions
pub
offsets
:
BlockOffsets
pub
jt_offsets
:
JumpTableOffsets
pub
srclocs
:
SourceLocs
pub
prologue_end
:
Option
<
Inst
>
pub
epilogues_start
:
Vec
<
(
Inst
Block
)
>
pub
stack_limit
:
Option
<
ir
:
:
GlobalValue
>
}
impl
Function
{
pub
fn
with_name_signature
(
name
:
ExternalName
sig
:
Signature
)
-
>
Self
{
Self
{
name
signature
:
sig
old_signature
:
None
stack_slots
:
StackSlots
:
:
new
(
)
global_values
:
PrimaryMap
:
:
new
(
)
heaps
:
PrimaryMap
:
:
new
(
)
tables
:
PrimaryMap
:
:
new
(
)
jump_tables
:
PrimaryMap
:
:
new
(
)
dfg
:
DataFlowGraph
:
:
new
(
)
layout
:
Layout
:
:
new
(
)
encodings
:
SecondaryMap
:
:
new
(
)
locations
:
SecondaryMap
:
:
new
(
)
entry_diversions
:
EntryRegDiversions
:
:
new
(
)
offsets
:
SecondaryMap
:
:
new
(
)
jt_offsets
:
SecondaryMap
:
:
new
(
)
srclocs
:
SecondaryMap
:
:
new
(
)
prologue_end
:
None
epilogues_start
:
Vec
:
:
new
(
)
stack_limit
:
None
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
signature
.
clear
(
CallConv
:
:
Fast
)
;
self
.
stack_slots
.
clear
(
)
;
self
.
global_values
.
clear
(
)
;
self
.
heaps
.
clear
(
)
;
self
.
tables
.
clear
(
)
;
self
.
jump_tables
.
clear
(
)
;
self
.
dfg
.
clear
(
)
;
self
.
layout
.
clear
(
)
;
self
.
encodings
.
clear
(
)
;
self
.
locations
.
clear
(
)
;
self
.
entry_diversions
.
clear
(
)
;
self
.
offsets
.
clear
(
)
;
self
.
jt_offsets
.
clear
(
)
;
self
.
srclocs
.
clear
(
)
;
self
.
prologue_end
=
None
;
self
.
epilogues_start
.
clear
(
)
;
self
.
stack_limit
=
None
;
}
pub
fn
new
(
)
-
>
Self
{
Self
:
:
with_name_signature
(
ExternalName
:
:
default
(
)
Signature
:
:
new
(
CallConv
:
:
Fast
)
)
}
pub
fn
create_jump_table
(
&
mut
self
data
:
JumpTableData
)
-
>
JumpTable
{
self
.
jump_tables
.
push
(
data
)
}
pub
fn
create_stack_slot
(
&
mut
self
data
:
StackSlotData
)
-
>
StackSlot
{
self
.
stack_slots
.
push
(
data
)
}
pub
fn
import_signature
(
&
mut
self
signature
:
Signature
)
-
>
SigRef
{
self
.
dfg
.
signatures
.
push
(
signature
)
}
pub
fn
import_function
(
&
mut
self
data
:
ExtFuncData
)
-
>
FuncRef
{
self
.
dfg
.
ext_funcs
.
push
(
data
)
}
pub
fn
create_global_value
(
&
mut
self
data
:
GlobalValueData
)
-
>
GlobalValue
{
self
.
global_values
.
push
(
data
)
}
pub
fn
create_heap
(
&
mut
self
data
:
HeapData
)
-
>
Heap
{
self
.
heaps
.
push
(
data
)
}
pub
fn
create_table
(
&
mut
self
data
:
TableData
)
-
>
Table
{
self
.
tables
.
push
(
data
)
}
pub
fn
display
<
'
a
I
:
Into
<
Option
<
&
'
a
dyn
TargetIsa
>
>
>
(
&
'
a
self
isa
:
I
)
-
>
DisplayFunction
<
'
a
>
{
DisplayFunction
(
self
isa
.
into
(
)
.
into
(
)
)
}
pub
fn
display_with
<
'
a
>
(
&
'
a
self
annotations
:
DisplayFunctionAnnotations
<
'
a
>
)
-
>
DisplayFunction
<
'
a
>
{
DisplayFunction
(
self
annotations
)
}
pub
fn
special_param
(
&
self
purpose
:
ir
:
:
ArgumentPurpose
)
-
>
Option
<
ir
:
:
Value
>
{
let
entry
=
self
.
layout
.
entry_block
(
)
.
expect
(
"
Function
is
empty
"
)
;
self
.
signature
.
special_param_index
(
purpose
)
.
map
(
|
i
|
self
.
dfg
.
block_params
(
entry
)
[
i
]
)
}
pub
fn
inst_offsets
<
'
a
>
(
&
'
a
self
block
:
Block
encinfo
:
&
EncInfo
)
-
>
InstOffsetIter
<
'
a
>
{
assert
!
(
!
self
.
offsets
.
is_empty
(
)
"
Code
layout
must
be
computed
first
"
)
;
let
mut
divert
=
RegDiversions
:
:
new
(
)
;
divert
.
at_block
(
&
self
.
entry_diversions
block
)
;
InstOffsetIter
{
encinfo
:
encinfo
.
clone
(
)
func
:
self
divert
encodings
:
&
self
.
encodings
offset
:
self
.
offsets
[
block
]
iter
:
self
.
layout
.
block_insts
(
block
)
}
}
pub
fn
update_encoding
(
&
mut
self
inst
:
ir
:
:
Inst
isa
:
&
dyn
TargetIsa
)
-
>
Result
<
(
)
Legalize
>
{
if
isa
.
get_mach_backend
(
)
.
is_some
(
)
{
Ok
(
(
)
)
}
else
{
self
.
encode
(
inst
isa
)
.
map
(
|
e
|
self
.
encodings
[
inst
]
=
e
)
}
}
pub
fn
encode
(
&
self
inst
:
ir
:
:
Inst
isa
:
&
dyn
TargetIsa
)
-
>
Result
<
Encoding
Legalize
>
{
if
isa
.
get_mach_backend
(
)
.
is_some
(
)
{
Ok
(
Encoding
:
:
new
(
0
0
)
)
}
else
{
isa
.
encode
(
&
self
&
self
.
dfg
[
inst
]
self
.
dfg
.
ctrl_typevar
(
inst
)
)
}
}
pub
fn
collect_debug_info
(
&
mut
self
)
{
self
.
dfg
.
collect_debug_info
(
)
;
}
pub
fn
change_branch_destination
(
&
mut
self
inst
:
Inst
new_dest
:
Block
)
{
match
self
.
dfg
[
inst
]
.
branch_destination_mut
(
)
{
None
=
>
(
)
Some
(
inst_dest
)
=
>
*
inst_dest
=
new_dest
}
}
pub
fn
rewrite_branch_destination
(
&
mut
self
inst
:
Inst
old_dest
:
Block
new_dest
:
Block
)
{
match
self
.
dfg
.
analyze_branch
(
inst
)
{
BranchInfo
:
:
SingleDest
(
dest
.
.
)
=
>
{
if
dest
=
=
old_dest
{
self
.
change_branch_destination
(
inst
new_dest
)
;
}
}
BranchInfo
:
:
Table
(
table
default_dest
)
=
>
{
self
.
jump_tables
[
table
]
.
iter_mut
(
)
.
for_each
(
|
entry
|
{
if
*
entry
=
=
old_dest
{
*
entry
=
new_dest
;
}
}
)
;
if
default_dest
=
=
Some
(
old_dest
)
{
match
&
mut
self
.
dfg
[
inst
]
{
InstructionData
:
:
BranchTable
{
destination
.
.
}
=
>
{
*
destination
=
new_dest
;
}
_
=
>
panic
!
(
"
Unexpected
instruction
{
}
having
default
destination
"
self
.
dfg
.
display_inst
(
inst
None
)
)
}
}
}
BranchInfo
:
:
NotABranch
=
>
{
}
}
}
pub
fn
is_block_basic
(
&
self
block
:
Block
)
-
>
Result
<
(
)
(
Inst
&
'
static
str
)
>
{
let
dfg
=
&
self
.
dfg
;
let
inst_iter
=
self
.
layout
.
block_insts
(
block
)
;
let
mut
inst_iter
=
inst_iter
.
skip_while
(
|
&
inst
|
!
dfg
[
inst
]
.
opcode
(
)
.
is_branch
(
)
)
;
if
let
Some
(
_branch
)
=
inst_iter
.
next
(
)
{
if
let
Some
(
next
)
=
inst_iter
.
next
(
)
{
match
dfg
[
next
]
.
opcode
(
)
{
Opcode
:
:
Fallthrough
|
Opcode
:
:
Jump
=
>
(
)
_
=
>
return
Err
(
(
next
"
post
-
branch
instruction
not
fallthrough
or
jump
"
)
)
}
}
}
Ok
(
(
)
)
}
pub
fn
is_leaf
(
&
self
)
-
>
bool
{
self
.
dfg
.
signatures
.
is_empty
(
)
}
pub
fn
transplant_inst
(
&
mut
self
dst
:
Inst
src
:
Inst
)
{
debug_assert_eq
!
(
self
.
dfg
.
inst_results
(
dst
)
.
len
(
)
self
.
dfg
.
inst_results
(
src
)
.
len
(
)
)
;
debug_assert
!
(
self
.
dfg
.
inst_results
(
dst
)
.
iter
(
)
.
zip
(
self
.
dfg
.
inst_results
(
src
)
)
.
all
(
|
(
a
b
)
|
self
.
dfg
.
value_type
(
*
a
)
=
=
self
.
dfg
.
value_type
(
*
b
)
)
)
;
self
.
dfg
[
dst
]
=
self
.
dfg
[
src
]
.
clone
(
)
;
self
.
layout
.
remove_inst
(
src
)
;
}
}
#
[
derive
(
Default
)
]
pub
struct
DisplayFunctionAnnotations
<
'
a
>
{
pub
isa
:
Option
<
&
'
a
dyn
TargetIsa
>
pub
value_ranges
:
Option
<
&
'
a
ValueLabelsRanges
>
}
impl
<
'
a
>
From
<
Option
<
&
'
a
dyn
TargetIsa
>
>
for
DisplayFunctionAnnotations
<
'
a
>
{
fn
from
(
isa
:
Option
<
&
'
a
dyn
TargetIsa
>
)
-
>
DisplayFunctionAnnotations
{
DisplayFunctionAnnotations
{
isa
value_ranges
:
None
}
}
}
pub
struct
DisplayFunction
<
'
a
>
(
&
'
a
Function
DisplayFunctionAnnotations
<
'
a
>
)
;
impl
<
'
a
>
fmt
:
:
Display
for
DisplayFunction
<
'
a
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write_function
(
fmt
self
.
0
&
self
.
1
)
}
}
impl
fmt
:
:
Display
for
Function
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write_function
(
fmt
self
&
DisplayFunctionAnnotations
:
:
default
(
)
)
}
}
impl
fmt
:
:
Debug
for
Function
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write_function
(
fmt
self
&
DisplayFunctionAnnotations
:
:
default
(
)
)
}
}
pub
struct
InstOffsetIter
<
'
a
>
{
encinfo
:
EncInfo
divert
:
RegDiversions
func
:
&
'
a
Function
encodings
:
&
'
a
InstEncodings
offset
:
CodeOffset
iter
:
ir
:
:
layout
:
:
Insts
<
'
a
>
}
impl
<
'
a
>
Iterator
for
InstOffsetIter
<
'
a
>
{
type
Item
=
(
CodeOffset
ir
:
:
Inst
CodeOffset
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
.
map
(
|
inst
|
{
self
.
divert
.
apply
(
&
self
.
func
.
dfg
[
inst
]
)
;
let
byte_size
=
self
.
encinfo
.
byte_size
(
self
.
encodings
[
inst
]
inst
&
self
.
divert
self
.
func
)
;
let
offset
=
self
.
offset
;
self
.
offset
+
=
byte_size
;
(
offset
inst
byte_size
)
}
)
}
}
