use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
hash
:
:
{
BuildHasherDefault
Hash
Hasher
}
;
use
std
:
:
ops
:
:
BitXor
;
pub
type
FxHashMap
<
K
V
>
=
HashMap
<
K
V
BuildHasherDefault
<
FxHasher
>
>
;
pub
type
FxHashSet
<
V
>
=
HashSet
<
V
BuildHasherDefault
<
FxHasher
>
>
;
#
[
allow
(
non_snake_case
)
]
pub
fn
FxHashMap
<
K
:
Hash
+
Eq
V
>
(
)
-
>
FxHashMap
<
K
V
>
{
HashMap
:
:
default
(
)
}
#
[
allow
(
non_snake_case
)
]
pub
fn
FxHashSet
<
V
:
Hash
+
Eq
>
(
)
-
>
FxHashSet
<
V
>
{
HashSet
:
:
default
(
)
}
pub
struct
FxHasher
{
hash
:
usize
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
const
K
:
usize
=
0x9e3779b9
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
const
K
:
usize
=
0x517cc1b727220a95
;
impl
Default
for
FxHasher
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
{
hash
:
0
}
}
}
impl
FxHasher
{
#
[
inline
]
fn
add_to_hash
(
&
mut
self
i
:
usize
)
{
self
.
hash
=
self
.
hash
.
rotate_left
(
5
)
.
bitxor
(
i
)
.
wrapping_mul
(
K
)
;
}
}
impl
Hasher
for
FxHasher
{
#
[
inline
]
fn
write
(
&
mut
self
bytes
:
&
[
u8
]
)
{
for
byte
in
bytes
{
let
i
=
*
byte
;
self
.
add_to_hash
(
i
as
usize
)
;
}
}
#
[
inline
]
fn
write_u8
(
&
mut
self
i
:
u8
)
{
self
.
add_to_hash
(
i
as
usize
)
;
}
#
[
inline
]
fn
write_u16
(
&
mut
self
i
:
u16
)
{
self
.
add_to_hash
(
i
as
usize
)
;
}
#
[
inline
]
fn
write_u32
(
&
mut
self
i
:
u32
)
{
self
.
add_to_hash
(
i
as
usize
)
;
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
#
[
inline
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
self
.
add_to_hash
(
i
as
usize
)
;
self
.
add_to_hash
(
(
i
>
>
32
)
as
usize
)
;
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
#
[
inline
]
fn
write_u64
(
&
mut
self
i
:
u64
)
{
self
.
add_to_hash
(
i
as
usize
)
;
}
#
[
inline
]
fn
write_usize
(
&
mut
self
i
:
usize
)
{
self
.
add_to_hash
(
i
)
;
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
hash
as
u64
}
}
