use
crate
:
:
ir
:
:
{
DataFlowGraph
Function
Inst
InstructionData
Opcode
}
;
use
cranelift_entity
:
:
EntityRef
;
pub
fn
any_inst_results_used
(
inst
:
Inst
live
:
&
[
bool
]
dfg
:
&
DataFlowGraph
)
-
>
bool
{
dfg
.
inst_results
(
inst
)
.
iter
(
)
.
any
(
|
v
|
live
[
v
.
index
(
)
]
)
}
fn
trivially_has_side_effects
(
opcode
:
Opcode
)
-
>
bool
{
opcode
.
is_call
(
)
|
|
opcode
.
is_branch
(
)
|
|
opcode
.
is_terminator
(
)
|
|
opcode
.
is_return
(
)
|
|
opcode
.
can_trap
(
)
|
|
opcode
.
other_side_effects
(
)
|
|
opcode
.
can_store
(
)
}
fn
is_load_with_defined_trapping
(
opcode
:
Opcode
data
:
&
InstructionData
)
-
>
bool
{
if
!
opcode
.
can_load
(
)
{
return
false
;
}
match
*
data
{
InstructionData
:
:
StackLoad
{
.
.
}
=
>
false
InstructionData
:
:
Load
{
flags
.
.
}
=
>
!
flags
.
notrap
(
)
_
=
>
true
}
}
pub
fn
has_side_effect
(
func
:
&
Function
inst
:
Inst
)
-
>
bool
{
let
data
=
&
func
.
dfg
[
inst
]
;
let
opcode
=
data
.
opcode
(
)
;
trivially_has_side_effects
(
opcode
)
|
|
is_load_with_defined_trapping
(
opcode
data
)
}
pub
fn
has_lowering_side_effect
(
func
:
&
Function
inst
:
Inst
)
-
>
bool
{
let
op
=
func
.
dfg
[
inst
]
.
opcode
(
)
;
op
!
=
Opcode
:
:
GetPinnedReg
&
&
(
has_side_effect
(
func
inst
)
|
|
op
.
can_load
(
)
)
}
pub
fn
is_constant_64bit
(
func
:
&
Function
inst
:
Inst
)
-
>
Option
<
u64
>
{
let
data
=
&
func
.
dfg
[
inst
]
;
if
data
.
opcode
(
)
=
=
Opcode
:
:
Null
{
return
Some
(
0
)
;
}
match
data
{
&
InstructionData
:
:
UnaryImm
{
imm
.
.
}
=
>
Some
(
imm
.
bits
(
)
as
u64
)
&
InstructionData
:
:
UnaryIeee32
{
imm
.
.
}
=
>
Some
(
imm
.
bits
(
)
as
u64
)
&
InstructionData
:
:
UnaryIeee64
{
imm
.
.
}
=
>
Some
(
imm
.
bits
(
)
)
&
InstructionData
:
:
UnaryBool
{
imm
.
.
}
=
>
Some
(
if
imm
{
1
}
else
{
0
}
)
_
=
>
None
}
}
pub
fn
is_safepoint
(
func
:
&
Function
inst
:
Inst
)
-
>
bool
{
let
op
=
func
.
dfg
[
inst
]
.
opcode
(
)
;
op
.
is_resumable_trap
(
)
|
|
op
.
is_call
(
)
}
