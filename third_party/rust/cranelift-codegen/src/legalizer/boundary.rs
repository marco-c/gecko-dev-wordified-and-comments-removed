use
crate
:
:
abi
:
:
{
legalize_abi_value
ValueConversion
}
;
use
crate
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
crate
:
:
flowgraph
:
:
ControlFlowGraph
;
use
crate
:
:
ir
:
:
instructions
:
:
CallInfo
;
use
crate
:
:
ir
:
:
{
AbiParam
ArgumentLoc
ArgumentPurpose
DataFlowGraph
Ebb
Function
Inst
InstBuilder
SigRef
Signature
Type
Value
ValueLoc
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
crate
:
:
legalizer
:
:
split
:
:
{
isplit
vsplit
}
;
use
alloc
:
:
vec
:
:
Vec
;
use
log
:
:
debug
;
pub
fn
legalize_signatures
(
func
:
&
mut
Function
isa
:
&
dyn
TargetIsa
)
{
legalize_signature
(
&
mut
func
.
signature
true
isa
)
;
for
sig_data
in
func
.
dfg
.
signatures
.
values_mut
(
)
{
legalize_signature
(
sig_data
false
isa
)
;
}
if
let
Some
(
entry
)
=
func
.
layout
.
entry_block
(
)
{
legalize_entry_params
(
func
entry
)
;
spill_entry_params
(
func
entry
)
;
}
}
pub
fn
legalize_libcall_signature
(
signature
:
&
mut
Signature
isa
:
&
dyn
TargetIsa
)
{
legalize_signature
(
signature
false
isa
)
;
}
fn
legalize_signature
(
signature
:
&
mut
Signature
current
:
bool
isa
:
&
dyn
TargetIsa
)
{
isa
.
legalize_signature
(
signature
current
)
;
}
fn
legalize_entry_params
(
func
:
&
mut
Function
entry
:
Ebb
)
{
let
mut
has_sret
=
false
;
let
mut
has_link
=
false
;
let
mut
has_vmctx
=
false
;
let
mut
has_sigid
=
false
;
let
mut
has_stack_limit
=
false
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_first_inst
(
entry
)
;
let
mut
abi_arg
=
0
;
let
ebb_params
=
pos
.
func
.
dfg
.
detach_ebb_params
(
entry
)
;
let
mut
old_arg
=
0
;
while
let
Some
(
arg
)
=
ebb_params
.
get
(
old_arg
&
pos
.
func
.
dfg
.
value_lists
)
{
old_arg
+
=
1
;
let
abi_type
=
pos
.
func
.
signature
.
params
[
abi_arg
]
;
let
arg_type
=
pos
.
func
.
dfg
.
value_type
(
arg
)
;
if
arg_type
=
=
abi_type
.
value_type
{
pos
.
func
.
dfg
.
attach_ebb_param
(
entry
arg
)
;
match
abi_type
.
purpose
{
ArgumentPurpose
:
:
Normal
=
>
{
}
ArgumentPurpose
:
:
FramePointer
=
>
{
}
ArgumentPurpose
:
:
CalleeSaved
=
>
{
}
ArgumentPurpose
:
:
StructReturn
=
>
{
debug_assert
!
(
!
has_sret
"
Multiple
sret
arguments
found
"
)
;
has_sret
=
true
;
}
ArgumentPurpose
:
:
VMContext
=
>
{
debug_assert
!
(
!
has_vmctx
"
Multiple
vmctx
arguments
found
"
)
;
has_vmctx
=
true
;
}
ArgumentPurpose
:
:
SignatureId
=
>
{
debug_assert
!
(
!
has_sigid
"
Multiple
sigid
arguments
found
"
)
;
has_sigid
=
true
;
}
ArgumentPurpose
:
:
StackLimit
=
>
{
debug_assert
!
(
!
has_stack_limit
"
Multiple
stack_limit
arguments
found
"
)
;
has_stack_limit
=
true
;
}
_
=
>
panic
!
(
"
Unexpected
special
-
purpose
arg
{
}
"
abi_type
)
}
abi_arg
+
=
1
;
}
else
{
let
mut
get_arg
=
|
func
:
&
mut
Function
ty
|
{
let
abi_type
=
func
.
signature
.
params
[
abi_arg
]
;
debug_assert_eq
!
(
abi_type
.
purpose
ArgumentPurpose
:
:
Normal
"
Can
'
t
legalize
special
-
purpose
argument
"
)
;
if
ty
=
=
abi_type
.
value_type
{
abi_arg
+
=
1
;
Ok
(
func
.
dfg
.
append_ebb_param
(
entry
ty
)
)
}
else
{
Err
(
abi_type
)
}
}
;
let
converted
=
convert_from_abi
(
&
mut
pos
arg_type
Some
(
arg
)
&
mut
get_arg
)
;
debug_assert_eq
!
(
pos
.
func
.
dfg
.
resolve_aliases
(
arg
)
converted
)
;
}
}
for
&
arg
in
&
pos
.
func
.
signature
.
params
[
abi_arg
.
.
]
{
match
arg
.
purpose
{
ArgumentPurpose
:
:
Normal
=
>
{
panic
!
(
"
Leftover
arg
:
{
}
"
arg
)
;
}
ArgumentPurpose
:
:
FramePointer
|
ArgumentPurpose
:
:
CalleeSaved
=
>
{
panic
!
(
"
Premature
callee
-
saved
arg
{
}
"
arg
)
;
}
ArgumentPurpose
:
:
Link
=
>
{
debug_assert
!
(
!
has_link
"
Multiple
link
parameters
found
"
)
;
has_link
=
true
;
}
ArgumentPurpose
:
:
StructReturn
=
>
{
debug_assert
!
(
!
has_sret
"
Multiple
sret
parameters
found
"
)
;
has_sret
=
true
;
}
ArgumentPurpose
:
:
VMContext
=
>
{
debug_assert
!
(
!
has_vmctx
"
Multiple
vmctx
parameters
found
"
)
;
has_vmctx
=
true
;
}
ArgumentPurpose
:
:
SignatureId
=
>
{
debug_assert
!
(
!
has_sigid
"
Multiple
sigid
parameters
found
"
)
;
has_sigid
=
true
;
}
ArgumentPurpose
:
:
StackLimit
=
>
{
debug_assert
!
(
!
has_stack_limit
"
Multiple
stack_limit
parameters
found
"
)
;
has_stack_limit
=
true
;
}
}
pos
.
func
.
dfg
.
append_ebb_param
(
entry
arg
.
value_type
)
;
}
}
fn
legalize_inst_results
<
ResType
>
(
pos
:
&
mut
FuncCursor
mut
get_abi_type
:
ResType
)
-
>
Inst
where
ResType
:
FnMut
(
&
Function
usize
)
-
>
AbiParam
{
let
call
=
pos
.
current_inst
(
)
.
expect
(
"
Cursor
must
point
to
a
call
instruction
"
)
;
debug_assert_eq
!
(
pos
.
func
.
dfg
[
call
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_results
(
)
0
"
Fixed
results
on
calls
not
supported
"
)
;
let
results
=
pos
.
func
.
dfg
.
detach_results
(
call
)
;
let
mut
next_res
=
0
;
let
mut
abi_res
=
0
;
pos
.
next_inst
(
)
;
while
let
Some
(
res
)
=
results
.
get
(
next_res
&
pos
.
func
.
dfg
.
value_lists
)
{
next_res
+
=
1
;
let
res_type
=
pos
.
func
.
dfg
.
value_type
(
res
)
;
if
res_type
=
=
get_abi_type
(
pos
.
func
abi_res
)
.
value_type
{
pos
.
func
.
dfg
.
attach_result
(
call
res
)
;
abi_res
+
=
1
;
}
else
{
let
mut
get_res
=
|
func
:
&
mut
Function
ty
|
{
let
abi_type
=
get_abi_type
(
func
abi_res
)
;
if
ty
=
=
abi_type
.
value_type
{
let
last_res
=
func
.
dfg
.
append_result
(
call
ty
)
;
abi_res
+
=
1
;
Ok
(
last_res
)
}
else
{
Err
(
abi_type
)
}
}
;
let
v
=
convert_from_abi
(
pos
res_type
Some
(
res
)
&
mut
get_res
)
;
debug_assert_eq
!
(
pos
.
func
.
dfg
.
resolve_aliases
(
res
)
v
)
;
}
}
call
}
fn
convert_from_abi
<
GetArg
>
(
pos
:
&
mut
FuncCursor
ty
:
Type
into_result
:
Option
<
Value
>
get_arg
:
&
mut
GetArg
)
-
>
Value
where
GetArg
:
FnMut
(
&
mut
Function
Type
)
-
>
Result
<
Value
AbiParam
>
{
let
arg_type
=
match
get_arg
(
pos
.
func
ty
)
{
Ok
(
v
)
=
>
{
debug_assert_eq
!
(
pos
.
func
.
dfg
.
value_type
(
v
)
ty
)
;
debug_assert_eq
!
(
into_result
None
)
;
return
v
;
}
Err
(
t
)
=
>
t
}
;
let
conversion
=
legalize_abi_value
(
ty
&
arg_type
)
;
debug
!
(
"
convert_from_abi
(
{
}
)
:
{
:
?
}
"
ty
conversion
)
;
match
conversion
{
ValueConversion
:
:
IntSplit
=
>
{
let
abi_ty
=
ty
.
half_width
(
)
.
expect
(
"
Invalid
type
for
conversion
"
)
;
let
lo
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
let
hi
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
debug
!
(
"
intsplit
{
}
:
{
}
{
}
:
{
}
"
lo
pos
.
func
.
dfg
.
value_type
(
lo
)
hi
pos
.
func
.
dfg
.
value_type
(
hi
)
)
;
pos
.
ins
(
)
.
with_results
(
[
into_result
]
)
.
iconcat
(
lo
hi
)
}
ValueConversion
:
:
VectorSplit
=
>
{
let
abi_ty
=
ty
.
half_vector
(
)
.
expect
(
"
Invalid
type
for
conversion
"
)
;
let
lo
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
let
hi
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
pos
.
ins
(
)
.
with_results
(
[
into_result
]
)
.
vconcat
(
lo
hi
)
}
ValueConversion
:
:
IntBits
=
>
{
debug_assert
!
(
!
ty
.
is_int
(
)
)
;
let
abi_ty
=
Type
:
:
int
(
ty
.
bits
(
)
)
.
expect
(
"
Invalid
type
for
conversion
"
)
;
let
arg
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
pos
.
ins
(
)
.
with_results
(
[
into_result
]
)
.
bitcast
(
ty
arg
)
}
ValueConversion
:
:
Sext
(
abi_ty
)
=
>
{
let
arg
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
pos
.
ins
(
)
.
with_results
(
[
into_result
]
)
.
ireduce
(
ty
arg
)
}
ValueConversion
:
:
Uext
(
abi_ty
)
=
>
{
let
arg
=
convert_from_abi
(
pos
abi_ty
None
get_arg
)
;
pos
.
ins
(
)
.
with_results
(
[
into_result
]
)
.
ireduce
(
ty
arg
)
}
}
}
fn
convert_to_abi
<
PutArg
>
(
pos
:
&
mut
FuncCursor
cfg
:
&
ControlFlowGraph
value
:
Value
put_arg
:
&
mut
PutArg
)
where
PutArg
:
FnMut
(
&
mut
Function
Value
)
-
>
Result
<
(
)
AbiParam
>
{
let
arg_type
=
match
put_arg
(
pos
.
func
value
)
{
Ok
(
_
)
=
>
return
Err
(
t
)
=
>
t
}
;
let
ty
=
pos
.
func
.
dfg
.
value_type
(
value
)
;
match
legalize_abi_value
(
ty
&
arg_type
)
{
ValueConversion
:
:
IntSplit
=
>
{
let
curpos
=
pos
.
position
(
)
;
let
srcloc
=
pos
.
srcloc
(
)
;
let
(
lo
hi
)
=
isplit
(
&
mut
pos
.
func
cfg
curpos
srcloc
value
)
;
convert_to_abi
(
pos
cfg
lo
put_arg
)
;
convert_to_abi
(
pos
cfg
hi
put_arg
)
;
}
ValueConversion
:
:
VectorSplit
=
>
{
let
curpos
=
pos
.
position
(
)
;
let
srcloc
=
pos
.
srcloc
(
)
;
let
(
lo
hi
)
=
vsplit
(
&
mut
pos
.
func
cfg
curpos
srcloc
value
)
;
convert_to_abi
(
pos
cfg
lo
put_arg
)
;
convert_to_abi
(
pos
cfg
hi
put_arg
)
;
}
ValueConversion
:
:
IntBits
=
>
{
debug_assert
!
(
!
ty
.
is_int
(
)
)
;
let
abi_ty
=
Type
:
:
int
(
ty
.
bits
(
)
)
.
expect
(
"
Invalid
type
for
conversion
"
)
;
let
arg
=
pos
.
ins
(
)
.
bitcast
(
abi_ty
value
)
;
convert_to_abi
(
pos
cfg
arg
put_arg
)
;
}
ValueConversion
:
:
Sext
(
abi_ty
)
=
>
{
let
arg
=
pos
.
ins
(
)
.
sextend
(
abi_ty
value
)
;
convert_to_abi
(
pos
cfg
arg
put_arg
)
;
}
ValueConversion
:
:
Uext
(
abi_ty
)
=
>
{
let
arg
=
pos
.
ins
(
)
.
uextend
(
abi_ty
value
)
;
convert_to_abi
(
pos
cfg
arg
put_arg
)
;
}
}
}
fn
check_arg_types
(
dfg
:
&
DataFlowGraph
args
:
&
[
Value
]
types
:
&
[
AbiParam
]
)
-
>
bool
{
let
arg_types
=
args
.
iter
(
)
.
map
(
|
&
v
|
dfg
.
value_type
(
v
)
)
;
let
sig_types
=
types
.
iter
(
)
.
map
(
|
&
at
|
at
.
value_type
)
;
arg_types
.
eq
(
sig_types
)
}
fn
check_call_signature
(
dfg
:
&
DataFlowGraph
inst
:
Inst
)
-
>
Result
<
(
)
SigRef
>
{
let
(
sig_ref
args
)
=
match
dfg
[
inst
]
.
analyze_call
(
&
dfg
.
value_lists
)
{
CallInfo
:
:
Direct
(
func
args
)
=
>
(
dfg
.
ext_funcs
[
func
]
.
signature
args
)
CallInfo
:
:
Indirect
(
sig_ref
args
)
=
>
(
sig_ref
args
)
CallInfo
:
:
NotACall
=
>
panic
!
(
"
Expected
call
got
{
:
?
}
"
dfg
[
inst
]
)
}
;
let
sig
=
&
dfg
.
signatures
[
sig_ref
]
;
if
check_arg_types
(
dfg
args
&
sig
.
params
[
.
.
]
)
&
&
check_arg_types
(
dfg
dfg
.
inst_results
(
inst
)
&
sig
.
returns
[
.
.
]
)
{
Ok
(
(
)
)
}
else
{
Err
(
sig_ref
)
}
}
fn
check_return_signature
(
dfg
:
&
DataFlowGraph
inst
:
Inst
sig
:
&
Signature
)
-
>
bool
{
check_arg_types
(
dfg
dfg
.
inst_variable_args
(
inst
)
&
sig
.
returns
)
}
fn
legalize_inst_arguments
<
ArgType
>
(
pos
:
&
mut
FuncCursor
cfg
:
&
ControlFlowGraph
abi_args
:
usize
mut
get_abi_type
:
ArgType
)
where
ArgType
:
FnMut
(
&
Function
usize
)
-
>
AbiParam
{
let
inst
=
pos
.
current_inst
(
)
.
expect
(
"
Cursor
must
point
to
a
call
instruction
"
)
;
let
mut
vlist
=
pos
.
func
.
dfg
[
inst
]
.
take_value_list
(
)
.
expect
(
"
Call
must
have
a
value
list
"
)
;
let
num_fixed_values
=
pos
.
func
.
dfg
[
inst
]
.
opcode
(
)
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
let
have_args
=
vlist
.
len
(
&
pos
.
func
.
dfg
.
value_lists
)
-
num_fixed_values
;
vlist
.
grow_at
(
num_fixed_values
abi_args
-
have_args
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
let
old_arg_offset
=
num_fixed_values
+
abi_args
-
have_args
;
let
mut
abi_arg
=
0
;
for
old_arg
in
0
.
.
have_args
{
let
old_value
=
vlist
.
get
(
old_arg_offset
+
old_arg
&
pos
.
func
.
dfg
.
value_lists
)
.
unwrap
(
)
;
let
mut
put_arg
=
|
func
:
&
mut
Function
arg
|
{
let
abi_type
=
get_abi_type
(
func
abi_arg
)
;
if
func
.
dfg
.
value_type
(
arg
)
=
=
abi_type
.
value_type
{
vlist
.
as_mut_slice
(
&
mut
func
.
dfg
.
value_lists
)
[
num_fixed_values
+
abi_arg
]
=
arg
;
abi_arg
+
=
1
;
Ok
(
(
)
)
}
else
{
Err
(
abi_type
)
}
}
;
convert_to_abi
(
pos
cfg
old_value
&
mut
put_arg
)
;
}
pos
.
func
.
dfg
[
inst
]
.
put_value_list
(
vlist
)
;
}
pub
fn
handle_call_abi
(
mut
inst
:
Inst
func
:
&
mut
Function
cfg
:
&
ControlFlowGraph
)
-
>
bool
{
let
pos
=
&
mut
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
sig_ref
=
match
check_call_signature
(
&
pos
.
func
.
dfg
inst
)
{
Ok
(
_
)
=
>
return
spill_call_arguments
(
pos
)
Err
(
s
)
=
>
s
}
;
let
abi_args
=
pos
.
func
.
dfg
.
signatures
[
sig_ref
]
.
params
.
len
(
)
;
legalize_inst_arguments
(
pos
cfg
abi_args
|
func
abi_arg
|
{
func
.
dfg
.
signatures
[
sig_ref
]
.
params
[
abi_arg
]
}
)
;
if
!
pos
.
func
.
dfg
.
signatures
[
sig_ref
]
.
returns
.
is_empty
(
)
{
inst
=
legalize_inst_results
(
pos
|
func
abi_res
|
{
func
.
dfg
.
signatures
[
sig_ref
]
.
returns
[
abi_res
]
}
)
;
}
debug_assert
!
(
check_call_signature
(
&
pos
.
func
.
dfg
inst
)
.
is_ok
(
)
"
Signature
still
wrong
:
{
}
{
}
{
}
"
pos
.
func
.
dfg
.
display_inst
(
inst
None
)
sig_ref
pos
.
func
.
dfg
.
signatures
[
sig_ref
]
)
;
pos
.
goto_inst
(
inst
)
;
spill_call_arguments
(
pos
)
;
true
}
pub
fn
handle_return_abi
(
inst
:
Inst
func
:
&
mut
Function
cfg
:
&
ControlFlowGraph
)
-
>
bool
{
if
check_return_signature
(
&
func
.
dfg
inst
&
func
.
signature
)
{
return
false
;
}
let
special_args
=
func
.
signature
.
returns
.
iter
(
)
.
rev
(
)
.
take_while
(
|
&
rt
|
{
rt
.
purpose
=
=
ArgumentPurpose
:
:
Link
|
|
rt
.
purpose
=
=
ArgumentPurpose
:
:
StructReturn
|
|
rt
.
purpose
=
=
ArgumentPurpose
:
:
VMContext
}
)
.
count
(
)
;
let
abi_args
=
func
.
signature
.
returns
.
len
(
)
-
special_args
;
let
pos
=
&
mut
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
legalize_inst_arguments
(
pos
cfg
abi_args
|
func
abi_arg
|
{
func
.
signature
.
returns
[
abi_arg
]
}
)
;
debug_assert_eq
!
(
pos
.
func
.
dfg
.
inst_variable_args
(
inst
)
.
len
(
)
abi_args
)
;
if
special_args
>
0
{
debug
!
(
"
Adding
{
}
special
-
purpose
arguments
to
{
}
"
special_args
pos
.
func
.
dfg
.
display_inst
(
inst
None
)
)
;
let
mut
vlist
=
pos
.
func
.
dfg
[
inst
]
.
take_value_list
(
)
.
unwrap
(
)
;
for
arg
in
&
pos
.
func
.
signature
.
returns
[
abi_args
.
.
]
{
match
arg
.
purpose
{
ArgumentPurpose
:
:
Link
|
ArgumentPurpose
:
:
StructReturn
|
ArgumentPurpose
:
:
VMContext
=
>
{
}
ArgumentPurpose
:
:
Normal
=
>
panic
!
(
"
unexpected
return
value
{
}
"
arg
)
_
=
>
panic
!
(
"
Unsupported
special
purpose
return
value
{
}
"
arg
)
}
let
idx
=
pos
.
func
.
signature
.
params
.
iter
(
)
.
rposition
(
|
t
|
t
.
purpose
=
=
arg
.
purpose
)
.
expect
(
"
No
matching
special
purpose
argument
.
"
)
;
let
val
=
pos
.
func
.
dfg
.
ebb_params
(
pos
.
func
.
layout
.
entry_block
(
)
.
unwrap
(
)
)
[
idx
]
;
debug_assert_eq
!
(
pos
.
func
.
dfg
.
value_type
(
val
)
arg
.
value_type
)
;
vlist
.
push
(
val
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
}
pos
.
func
.
dfg
[
inst
]
.
put_value_list
(
vlist
)
;
}
debug_assert
!
(
check_return_signature
(
&
pos
.
func
.
dfg
inst
&
pos
.
func
.
signature
)
"
Signature
still
wrong
:
{
}
/
signature
{
}
"
pos
.
func
.
dfg
.
display_inst
(
inst
None
)
pos
.
func
.
signature
)
;
true
}
fn
spill_entry_params
(
func
:
&
mut
Function
entry
:
Ebb
)
{
for
(
abi
&
arg
)
in
func
.
signature
.
params
.
iter
(
)
.
zip
(
func
.
dfg
.
ebb_params
(
entry
)
)
{
if
let
ArgumentLoc
:
:
Stack
(
offset
)
=
abi
.
location
{
let
ss
=
func
.
stack_slots
.
make_incoming_arg
(
abi
.
value_type
offset
)
;
func
.
locations
[
arg
]
=
ValueLoc
:
:
Stack
(
ss
)
;
}
}
}
fn
spill_call_arguments
(
pos
:
&
mut
FuncCursor
)
-
>
bool
{
let
inst
=
pos
.
current_inst
(
)
.
expect
(
"
Cursor
must
point
to
a
call
instruction
"
)
;
let
sig_ref
=
pos
.
func
.
dfg
.
call_signature
(
inst
)
.
expect
(
"
Call
instruction
expected
.
"
)
;
let
arglist
=
{
let
locations
=
&
pos
.
func
.
locations
;
let
stack_slots
=
&
mut
pos
.
func
.
stack_slots
;
pos
.
func
.
dfg
.
inst_variable_args
(
inst
)
.
iter
(
)
.
zip
(
&
pos
.
func
.
dfg
.
signatures
[
sig_ref
]
.
params
)
.
enumerate
(
)
.
filter_map
(
|
(
idx
(
&
arg
abi
)
)
|
{
match
abi
.
location
{
ArgumentLoc
:
:
Stack
(
offset
)
=
>
{
let
ss
=
stack_slots
.
get_outgoing_arg
(
abi
.
value_type
offset
)
;
if
locations
[
arg
]
!
=
ValueLoc
:
:
Stack
(
ss
)
{
Some
(
(
idx
arg
ss
)
)
}
else
{
None
}
}
_
=
>
None
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
;
if
arglist
.
is_empty
(
)
{
return
false
;
}
for
(
idx
arg
ss
)
in
arglist
{
let
stack_val
=
pos
.
ins
(
)
.
spill
(
arg
)
;
pos
.
func
.
locations
[
stack_val
]
=
ValueLoc
:
:
Stack
(
ss
)
;
pos
.
func
.
dfg
.
inst_variable_args_mut
(
inst
)
[
idx
]
=
stack_val
;
}
true
}
