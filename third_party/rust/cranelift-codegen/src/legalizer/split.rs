use
crate
:
:
cursor
:
:
{
Cursor
CursorPosition
FuncCursor
}
;
use
crate
:
:
flowgraph
:
:
{
BasicBlock
ControlFlowGraph
}
;
use
crate
:
:
ir
:
:
{
self
Ebb
Inst
InstBuilder
InstructionData
Opcode
Type
Value
ValueDef
}
;
use
core
:
:
iter
;
use
std
:
:
vec
:
:
Vec
;
pub
fn
isplit
(
func
:
&
mut
ir
:
:
Function
cfg
:
&
ControlFlowGraph
pos
:
CursorPosition
srcloc
:
ir
:
:
SourceLoc
value
:
Value
)
-
>
(
Value
Value
)
{
split_any
(
func
cfg
pos
srcloc
value
Opcode
:
:
Iconcat
)
}
pub
fn
vsplit
(
func
:
&
mut
ir
:
:
Function
cfg
:
&
ControlFlowGraph
pos
:
CursorPosition
srcloc
:
ir
:
:
SourceLoc
value
:
Value
)
-
>
(
Value
Value
)
{
split_any
(
func
cfg
pos
srcloc
value
Opcode
:
:
Vconcat
)
}
struct
Repair
{
concat
:
Opcode
split_type
:
Type
ebb
:
Ebb
num
:
usize
hi_num
:
usize
}
fn
split_any
(
func
:
&
mut
ir
:
:
Function
cfg
:
&
ControlFlowGraph
pos
:
CursorPosition
srcloc
:
ir
:
:
SourceLoc
value
:
Value
concat
:
Opcode
)
-
>
(
Value
Value
)
{
let
mut
repairs
=
Vec
:
:
new
(
)
;
let
pos
=
&
mut
FuncCursor
:
:
new
(
func
)
.
at_position
(
pos
)
.
with_srcloc
(
srcloc
)
;
let
result
=
split_value
(
pos
value
concat
&
mut
repairs
)
;
while
let
Some
(
repair
)
=
repairs
.
pop
(
)
{
for
BasicBlock
{
inst
.
.
}
in
cfg
.
pred_iter
(
repair
.
ebb
)
{
let
branch_opc
=
pos
.
func
.
dfg
[
inst
]
.
opcode
(
)
;
debug_assert
!
(
branch_opc
.
is_branch
(
)
"
Predecessor
not
a
branch
:
{
}
"
pos
.
func
.
dfg
.
display_inst
(
inst
None
)
)
;
let
num_fixed_args
=
branch_opc
.
constraints
(
)
.
num_fixed_value_arguments
(
)
;
let
mut
args
=
pos
.
func
.
dfg
[
inst
]
.
take_value_list
(
)
.
expect
(
"
Branches
must
have
value
lists
.
"
)
;
let
num_args
=
args
.
len
(
&
pos
.
func
.
dfg
.
value_lists
)
;
let
old_arg
=
args
.
get
(
num_fixed_args
+
repair
.
num
&
pos
.
func
.
dfg
.
value_lists
)
.
expect
(
"
Too
few
branch
arguments
"
)
;
if
pos
.
func
.
dfg
.
value_type
(
old_arg
)
=
=
repair
.
split_type
{
pos
.
func
.
dfg
[
inst
]
.
put_value_list
(
args
)
;
continue
;
}
pos
.
goto_inst
(
inst
)
;
let
(
lo
hi
)
=
split_value
(
pos
old_arg
repair
.
concat
&
mut
repairs
)
;
*
args
.
get_mut
(
num_fixed_args
+
repair
.
num
&
mut
pos
.
func
.
dfg
.
value_lists
)
.
unwrap
(
)
=
lo
;
if
num_args
>
num_fixed_args
+
repair
.
hi_num
{
*
args
.
get_mut
(
num_fixed_args
+
repair
.
hi_num
&
mut
pos
.
func
.
dfg
.
value_lists
)
.
unwrap
(
)
=
hi
;
}
else
{
args
.
extend
(
iter
:
:
repeat
(
hi
)
.
take
(
1
+
num_fixed_args
+
repair
.
hi_num
-
num_args
)
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
}
pos
.
func
.
dfg
[
inst
]
.
put_value_list
(
args
)
;
}
}
result
}
fn
split_value
(
pos
:
&
mut
FuncCursor
value
:
Value
concat
:
Opcode
repairs
:
&
mut
Vec
<
Repair
>
)
-
>
(
Value
Value
)
{
let
value
=
pos
.
func
.
dfg
.
resolve_aliases
(
value
)
;
let
mut
reuse
=
None
;
match
pos
.
func
.
dfg
.
value_def
(
value
)
{
ValueDef
:
:
Result
(
inst
num
)
=
>
{
if
let
InstructionData
:
:
Binary
{
opcode
args
.
.
}
=
pos
.
func
.
dfg
[
inst
]
{
debug_assert_eq
!
(
num
0
)
;
if
opcode
=
=
concat
{
reuse
=
Some
(
(
args
[
0
]
args
[
1
]
)
)
;
}
}
}
ValueDef
:
:
Param
(
ebb
num
)
=
>
{
if
pos
.
func
.
layout
.
entry_block
(
)
!
=
Some
(
ebb
)
{
let
ty
=
pos
.
func
.
dfg
.
value_type
(
value
)
;
let
split_type
=
match
concat
{
Opcode
:
:
Iconcat
=
>
ty
.
half_width
(
)
.
expect
(
"
Invalid
type
for
isplit
"
)
Opcode
:
:
Vconcat
=
>
ty
.
half_vector
(
)
.
expect
(
"
Invalid
type
for
vsplit
"
)
_
=
>
panic
!
(
"
Unhandled
concat
opcode
:
{
}
"
concat
)
}
;
let
lo
=
pos
.
func
.
dfg
.
replace_ebb_param
(
value
split_type
)
;
let
hi_num
=
pos
.
func
.
dfg
.
num_ebb_params
(
ebb
)
;
let
hi
=
pos
.
func
.
dfg
.
append_ebb_param
(
ebb
split_type
)
;
reuse
=
Some
(
(
lo
hi
)
)
;
pos
.
goto_first_inst
(
ebb
)
;
pos
.
ins
(
)
.
with_result
(
value
)
.
Binary
(
concat
split_type
lo
hi
)
;
add_repair
(
concat
split_type
ebb
num
hi_num
repairs
)
;
}
}
}
if
let
Some
(
pair
)
=
reuse
{
pair
}
else
{
match
concat
{
Opcode
:
:
Iconcat
=
>
pos
.
ins
(
)
.
isplit
(
value
)
Opcode
:
:
Vconcat
=
>
pos
.
ins
(
)
.
vsplit
(
value
)
_
=
>
panic
!
(
"
Unhandled
concat
opcode
:
{
}
"
concat
)
}
}
}
fn
add_repair
(
concat
:
Opcode
split_type
:
Type
ebb
:
Ebb
num
:
usize
hi_num
:
usize
repairs
:
&
mut
Vec
<
Repair
>
)
{
repairs
.
push
(
Repair
{
concat
split_type
ebb
num
hi_num
}
)
;
}
fn
resolve_splits
(
dfg
:
&
ir
:
:
DataFlowGraph
value
:
Value
)
-
>
Value
{
let
value
=
dfg
.
resolve_aliases
(
value
)
;
let
split_res
;
let
concat_opc
;
let
split_arg
;
if
let
ValueDef
:
:
Result
(
inst
num
)
=
dfg
.
value_def
(
value
)
{
split_res
=
num
;
concat_opc
=
match
dfg
[
inst
]
.
opcode
(
)
{
Opcode
:
:
Isplit
=
>
Opcode
:
:
Iconcat
Opcode
:
:
Vsplit
=
>
Opcode
:
:
Vconcat
_
=
>
return
value
}
;
split_arg
=
dfg
.
inst_args
(
inst
)
[
0
]
;
}
else
{
return
value
;
}
if
let
ValueDef
:
:
Result
(
inst
_
)
=
dfg
.
value_def
(
split_arg
)
{
if
dfg
[
inst
]
.
opcode
(
)
=
=
concat_opc
{
return
dfg
.
inst_args
(
inst
)
[
split_res
]
;
}
}
value
}
pub
fn
simplify_branch_arguments
(
dfg
:
&
mut
ir
:
:
DataFlowGraph
branch
:
Inst
)
{
let
mut
new_args
=
Vec
:
:
new
(
)
;
for
&
arg
in
dfg
.
inst_args
(
branch
)
{
let
new_arg
=
resolve_splits
(
dfg
arg
)
;
new_args
.
push
(
new_arg
)
;
}
dfg
.
inst_args_mut
(
branch
)
.
copy_from_slice
(
&
new_args
)
;
}
