use
crate
:
:
ir
;
use
crate
:
:
ir
:
:
{
get_libcall_funcref
InstBuilder
}
;
use
crate
:
:
isa
:
:
TargetIsa
;
use
crate
:
:
legalizer
:
:
boundary
:
:
legalize_libcall_signature
;
use
std
:
:
vec
:
:
Vec
;
pub
fn
expand_as_libcall
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
isa
:
&
TargetIsa
)
-
>
bool
{
let
libcall
=
match
ir
:
:
LibCall
:
:
for_inst
(
func
.
dfg
[
inst
]
.
opcode
(
)
func
.
dfg
.
ctrl_typevar
(
inst
)
)
{
Some
(
lc
)
=
>
lc
None
=
>
return
false
}
;
let
mut
args
=
Vec
:
:
new
(
)
;
args
.
extend_from_slice
(
func
.
dfg
.
inst_args
(
inst
)
)
;
let
funcref
=
get_libcall_funcref
(
libcall
func
inst
isa
)
;
func
.
dfg
.
replace
(
inst
)
.
call
(
funcref
&
args
)
;
let
fn_data
=
&
func
.
dfg
.
ext_funcs
[
funcref
]
;
let
sig_data
=
&
mut
func
.
dfg
.
signatures
[
fn_data
.
signature
]
;
legalize_libcall_signature
(
sig_data
isa
)
;
true
}
