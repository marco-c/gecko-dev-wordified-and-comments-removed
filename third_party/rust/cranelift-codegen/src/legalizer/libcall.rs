use
crate
:
:
ir
;
use
crate
:
:
ir
:
:
{
libcall
:
:
get_libcall_funcref
InstBuilder
}
;
use
crate
:
:
isa
:
:
{
CallConv
TargetIsa
}
;
use
crate
:
:
legalizer
:
:
boundary
:
:
legalize_libcall_signature
;
use
alloc
:
:
vec
:
:
Vec
;
pub
fn
expand_as_libcall
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
isa
:
&
dyn
TargetIsa
)
-
>
bool
{
let
libcall
=
match
ir
:
:
LibCall
:
:
for_inst
(
func
.
dfg
[
inst
]
.
opcode
(
)
func
.
dfg
.
ctrl_typevar
(
inst
)
)
{
Some
(
lc
)
=
>
lc
None
=
>
return
false
}
;
let
mut
args
=
Vec
:
:
new
(
)
;
args
.
extend_from_slice
(
func
.
dfg
.
inst_args
(
inst
)
)
;
let
call_conv
=
CallConv
:
:
for_libcall
(
isa
)
;
if
call_conv
.
extends_baldrdash
(
)
{
let
vmctx
=
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
parameter
for
baldrdash
libcall
"
)
;
args
.
push
(
vmctx
)
;
}
let
funcref
=
get_libcall_funcref
(
libcall
call_conv
func
inst
isa
)
;
func
.
dfg
.
replace
(
inst
)
.
call
(
funcref
&
args
)
;
let
fn_data
=
&
func
.
dfg
.
ext_funcs
[
funcref
]
;
let
sig_data
=
&
mut
func
.
dfg
.
signatures
[
fn_data
.
signature
]
;
legalize_libcall_signature
(
sig_data
isa
)
;
true
}
