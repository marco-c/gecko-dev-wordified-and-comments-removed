use
cursor
:
:
{
Cursor
FuncCursor
}
;
use
flowgraph
:
:
ControlFlowGraph
;
use
ir
:
:
{
self
InstBuilder
}
;
use
isa
:
:
TargetIsa
;
pub
fn
expand_global_value
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
TargetIsa
)
{
let
gv
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
UnaryGlobalValue
{
opcode
global_value
}
=
>
{
debug_assert_eq
!
(
opcode
ir
:
:
Opcode
:
:
GlobalValue
)
;
global_value
}
_
=
>
panic
!
(
"
Wanted
global_value
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
match
func
.
global_values
[
gv
]
{
ir
:
:
GlobalValueData
:
:
VMContext
{
offset
}
=
>
vmctx_addr
(
inst
func
offset
.
into
(
)
)
ir
:
:
GlobalValueData
:
:
Deref
{
base
offset
memory_type
}
=
>
deref_addr
(
inst
func
base
offset
.
into
(
)
memory_type
isa
)
ir
:
:
GlobalValueData
:
:
Sym
{
.
.
}
=
>
globalsym
(
inst
func
gv
isa
)
}
}
fn
vmctx_addr
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
offset
:
i64
)
{
let
vmctx
=
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
parameter
"
)
;
func
.
dfg
.
replace
(
inst
)
.
iadd_imm
(
vmctx
offset
)
;
}
fn
deref_addr
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
base
:
ir
:
:
GlobalValue
offset
:
i64
memory_type
:
ir
:
:
Type
isa
:
&
TargetIsa
)
{
let
ptr_ty
=
isa
.
pointer_type
(
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
base_addr
=
pos
.
ins
(
)
.
global_value
(
ptr_ty
base
)
;
let
mut
mflags
=
ir
:
:
MemFlags
:
:
new
(
)
;
mflags
.
set_notrap
(
)
;
mflags
.
set_aligned
(
)
;
let
loaded
=
pos
.
ins
(
)
.
load
(
memory_type
mflags
base_addr
0
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
iadd_imm
(
loaded
offset
)
;
}
fn
globalsym
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
gv
:
ir
:
:
GlobalValue
isa
:
&
TargetIsa
)
{
let
ptr_ty
=
isa
.
pointer_type
(
)
;
func
.
dfg
.
replace
(
inst
)
.
globalsym_addr
(
ptr_ty
gv
)
;
}
