use
crate
:
:
cursor
:
:
{
Cursor
EncCursor
}
;
use
crate
:
:
dominator_tree
:
:
DominatorTree
;
use
crate
:
:
ir
:
:
{
AbiParam
ArgumentLoc
InstBuilder
ValueDef
}
;
use
crate
:
:
ir
:
:
{
Ebb
Function
Inst
Layout
SigRef
Value
ValueLoc
}
;
use
crate
:
:
isa
:
:
{
regs_overlap
RegClass
RegInfo
RegUnit
}
;
use
crate
:
:
isa
:
:
{
ConstraintKind
EncInfo
OperandConstraint
RecipeConstraints
TargetIsa
}
;
use
crate
:
:
packed_option
:
:
PackedOption
;
use
crate
:
:
regalloc
:
:
affinity
:
:
Affinity
;
use
crate
:
:
regalloc
:
:
live_value_tracker
:
:
{
LiveValue
LiveValueTracker
}
;
use
crate
:
:
regalloc
:
:
liveness
:
:
Liveness
;
use
crate
:
:
regalloc
:
:
liverange
:
:
{
LiveRange
LiveRangeContext
}
;
use
crate
:
:
regalloc
:
:
register_set
:
:
RegisterSet
;
use
crate
:
:
regalloc
:
:
solver
:
:
{
Solver
SolverError
}
;
use
crate
:
:
regalloc
:
:
RegDiversions
;
use
crate
:
:
timing
;
use
core
:
:
mem
;
use
log
:
:
debug
;
pub
struct
Coloring
{
divert
:
RegDiversions
solver
:
Solver
}
struct
Context
<
'
a
>
{
cur
:
EncCursor
<
'
a
>
reginfo
:
RegInfo
encinfo
:
EncInfo
domtree
:
&
'
a
DominatorTree
liveness
:
&
'
a
mut
Liveness
divert
:
&
'
a
mut
RegDiversions
solver
:
&
'
a
mut
Solver
usable_regs
:
RegisterSet
}
impl
Coloring
{
pub
fn
new
(
)
-
>
Self
{
Self
{
divert
:
RegDiversions
:
:
new
(
)
solver
:
Solver
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
divert
.
clear
(
)
;
self
.
solver
.
clear
(
)
;
}
pub
fn
run
(
&
mut
self
isa
:
&
TargetIsa
func
:
&
mut
Function
domtree
:
&
DominatorTree
liveness
:
&
mut
Liveness
tracker
:
&
mut
LiveValueTracker
)
{
let
_tt
=
timing
:
:
ra_coloring
(
)
;
debug
!
(
"
Coloring
for
:
\
n
{
}
"
func
.
display
(
isa
)
)
;
let
mut
ctx
=
Context
{
usable_regs
:
isa
.
allocatable_registers
(
func
)
cur
:
EncCursor
:
:
new
(
func
isa
)
reginfo
:
isa
.
register_info
(
)
encinfo
:
isa
.
encoding_info
(
)
domtree
liveness
divert
:
&
mut
self
.
divert
solver
:
&
mut
self
.
solver
}
;
ctx
.
run
(
tracker
)
}
}
impl
<
'
a
>
Context
<
'
a
>
{
fn
run
(
&
mut
self
tracker
:
&
mut
LiveValueTracker
)
{
self
.
cur
.
func
.
locations
.
resize
(
self
.
cur
.
func
.
dfg
.
num_values
(
)
)
;
for
&
ebb
in
self
.
domtree
.
cfg_postorder
(
)
.
iter
(
)
.
rev
(
)
{
self
.
visit_ebb
(
ebb
tracker
)
;
}
}
fn
visit_ebb
(
&
mut
self
ebb
:
Ebb
tracker
:
&
mut
LiveValueTracker
)
{
debug
!
(
"
Coloring
{
}
:
"
ebb
)
;
let
mut
regs
=
self
.
visit_ebb_header
(
ebb
tracker
)
;
tracker
.
drop_dead_params
(
)
;
self
.
divert
.
clear
(
)
;
self
.
cur
.
goto_top
(
ebb
)
;
while
let
Some
(
inst
)
=
self
.
cur
.
next_inst
(
)
{
self
.
cur
.
use_srcloc
(
inst
)
;
if
!
self
.
cur
.
func
.
dfg
[
inst
]
.
opcode
(
)
.
is_ghost
(
)
{
let
enc
=
self
.
cur
.
func
.
encodings
[
inst
]
;
let
constraints
=
self
.
encinfo
.
operand_constraints
(
enc
)
;
if
self
.
visit_inst
(
inst
constraints
tracker
&
mut
regs
)
{
self
.
replace_global_defines
(
inst
tracker
)
;
self
.
cur
.
goto_inst
(
inst
)
;
}
}
else
{
let
(
_throughs
kills
)
=
tracker
.
process_ghost
(
inst
)
;
self
.
process_ghost_kills
(
kills
&
mut
regs
)
;
}
tracker
.
drop_dead
(
inst
)
;
}
}
fn
visit_ebb_header
(
&
mut
self
ebb
:
Ebb
tracker
:
&
mut
LiveValueTracker
)
-
>
AvailableRegs
{
tracker
.
ebb_top
(
ebb
&
self
.
cur
.
func
.
dfg
self
.
liveness
&
self
.
cur
.
func
.
layout
self
.
domtree
)
;
if
self
.
cur
.
func
.
layout
.
entry_block
(
)
=
=
Some
(
ebb
)
{
self
.
color_entry_params
(
tracker
.
live
(
)
)
}
else
{
self
.
livein_regs
(
tracker
.
live
(
)
)
}
}
fn
livein_regs
(
&
self
live
:
&
[
LiveValue
]
)
-
>
AvailableRegs
{
let
mut
regs
=
AvailableRegs
:
:
new
(
&
self
.
usable_regs
)
;
for
lv
in
live
.
iter
(
)
.
filter
(
|
lv
|
!
lv
.
is_dead
)
{
debug
!
(
"
Live
-
in
:
{
}
:
{
}
in
{
}
"
lv
.
value
lv
.
affinity
.
display
(
&
self
.
reginfo
)
self
.
cur
.
func
.
locations
[
lv
.
value
]
.
display
(
&
self
.
reginfo
)
)
;
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
let
loc
=
self
.
cur
.
func
.
locations
[
lv
.
value
]
;
match
loc
{
ValueLoc
:
:
Reg
(
reg
)
=
>
regs
.
take
(
rc
reg
lv
.
is_local
)
ValueLoc
:
:
Unassigned
=
>
panic
!
(
"
Live
-
in
{
}
wasn
'
t
assigned
"
lv
.
value
)
ValueLoc
:
:
Stack
(
ss
)
=
>
{
panic
!
(
"
Live
-
in
{
}
is
in
{
}
should
be
register
"
lv
.
value
ss
)
}
}
}
}
regs
}
fn
color_entry_params
(
&
mut
self
args
:
&
[
LiveValue
]
)
-
>
AvailableRegs
{
let
sig
=
&
self
.
cur
.
func
.
signature
;
debug_assert_eq
!
(
sig
.
params
.
len
(
)
args
.
len
(
)
)
;
let
mut
regs
=
AvailableRegs
:
:
new
(
&
self
.
usable_regs
)
;
for
(
lv
abi
)
in
args
.
iter
(
)
.
zip
(
&
sig
.
params
)
{
match
lv
.
affinity
{
Affinity
:
:
Reg
(
rci
)
=
>
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
if
let
ArgumentLoc
:
:
Reg
(
reg
)
=
abi
.
location
{
if
!
lv
.
is_dead
{
regs
.
take
(
rc
reg
lv
.
is_local
)
;
}
self
.
cur
.
func
.
locations
[
lv
.
value
]
=
ValueLoc
:
:
Reg
(
reg
)
;
}
else
{
panic
!
(
"
Entry
arg
{
}
has
{
}
affinity
but
ABI
{
}
"
lv
.
value
lv
.
affinity
.
display
(
&
self
.
reginfo
)
abi
.
display
(
&
self
.
reginfo
)
)
;
}
}
Affinity
:
:
Stack
=
>
debug_assert
!
(
abi
.
location
.
is_stack
(
)
)
Affinity
:
:
Unassigned
=
>
{
}
}
}
regs
}
fn
visit_inst
(
&
mut
self
inst
:
Inst
constraints
:
Option
<
&
RecipeConstraints
>
tracker
:
&
mut
LiveValueTracker
regs
:
&
mut
AvailableRegs
)
-
>
bool
{
debug
!
(
"
Coloring
{
}
\
n
from
{
}
"
self
.
cur
.
display_inst
(
inst
)
regs
.
input
.
display
(
&
self
.
reginfo
)
)
;
let
mut
color_dest_args
=
None
;
self
.
solver
.
reset
(
&
regs
.
input
)
;
if
let
Some
(
constraints
)
=
constraints
{
self
.
program_input_constraints
(
inst
constraints
.
ins
)
;
}
let
call_sig
=
self
.
cur
.
func
.
dfg
.
call_signature
(
inst
)
;
if
let
Some
(
sig
)
=
call_sig
{
program_input_abi
(
&
mut
self
.
solver
inst
&
self
.
cur
.
func
.
dfg
.
signatures
[
sig
]
.
params
&
self
.
cur
.
func
&
self
.
liveness
&
self
.
reginfo
&
self
.
divert
)
;
}
else
if
self
.
cur
.
func
.
dfg
[
inst
]
.
opcode
(
)
.
is_return
(
)
{
program_input_abi
(
&
mut
self
.
solver
inst
&
self
.
cur
.
func
.
signature
.
returns
&
self
.
cur
.
func
&
self
.
liveness
&
self
.
reginfo
&
self
.
divert
)
;
}
else
if
self
.
cur
.
func
.
dfg
[
inst
]
.
opcode
(
)
.
is_branch
(
)
{
if
let
Some
(
dest
)
=
self
.
cur
.
func
.
dfg
[
inst
]
.
branch_destination
(
)
{
if
self
.
program_ebb_arguments
(
inst
dest
)
{
color_dest_args
=
Some
(
dest
)
;
}
}
else
{
debug_assert_eq
!
(
self
.
cur
.
func
.
dfg
.
inst_variable_args
(
inst
)
.
len
(
)
0
"
Can
'
t
handle
EBB
arguments
:
{
}
"
self
.
cur
.
display_inst
(
inst
)
)
;
self
.
undivert_regs
(
|
lr
_
|
!
lr
.
is_local
(
)
)
;
}
}
if
self
.
solver
.
has_fixed_input_conflicts
(
)
{
self
.
divert_fixed_input_conflicts
(
tracker
.
live
(
)
)
;
}
self
.
solver
.
inputs_done
(
)
;
let
(
throughs
kills
defs
)
=
tracker
.
process_inst
(
inst
&
self
.
cur
.
func
.
dfg
self
.
liveness
)
;
for
lv
in
kills
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
let
reg
=
self
.
divert
.
reg
(
lv
.
value
&
self
.
cur
.
func
.
locations
)
;
debug
!
(
"
kill
{
}
in
{
}
(
{
}
{
}
)
"
lv
.
value
self
.
reginfo
.
display_regunit
(
reg
)
if
lv
.
is_local
{
"
local
"
}
else
{
"
global
"
}
rc
)
;
self
.
solver
.
add_kill
(
lv
.
value
rc
reg
)
;
if
!
lv
.
is_local
{
regs
.
global
.
free
(
rc
self
.
cur
.
func
.
locations
[
lv
.
value
]
.
unwrap_reg
(
)
)
;
}
}
}
debug
!
(
"
glob
{
}
"
regs
.
global
.
display
(
&
self
.
reginfo
)
)
;
let
mut
replace_global_defines
=
false
;
if
let
Some
(
constraints
)
=
constraints
{
if
constraints
.
fixed_outs
{
self
.
program_fixed_outputs
(
constraints
.
outs
defs
throughs
&
mut
replace_global_defines
&
regs
.
global
)
;
}
}
if
let
Some
(
sig
)
=
call_sig
{
self
.
program_output_abi
(
sig
defs
throughs
&
mut
replace_global_defines
&
regs
.
global
)
;
}
if
let
Some
(
constraints
)
=
constraints
{
self
.
program_output_constraints
(
inst
constraints
.
outs
defs
&
mut
replace_global_defines
&
regs
.
global
)
;
}
let
output_regs
=
self
.
solver
.
quick_solve
(
&
regs
.
global
)
.
unwrap_or_else
(
|
_
|
{
debug
!
(
"
quick_solve
failed
for
{
}
"
self
.
solver
)
;
self
.
iterate_solution
(
throughs
&
regs
.
global
&
mut
replace_global_defines
)
}
)
;
self
.
shuffle_inputs
(
&
mut
regs
.
input
)
;
if
let
Some
(
dest
)
=
color_dest_args
{
self
.
color_ebb_params
(
inst
dest
)
;
}
for
v
in
self
.
solver
.
vars
(
)
.
iter
(
)
.
filter
(
|
&
v
|
v
.
is_define
(
)
)
{
self
.
cur
.
func
.
locations
[
v
.
value
]
=
ValueLoc
:
:
Reg
(
v
.
solution
)
;
}
if
let
Some
(
constraints
)
=
constraints
{
if
constraints
.
tied_ops
{
for
(
op
lv
)
in
constraints
.
outs
.
iter
(
)
.
zip
(
defs
)
{
if
let
ConstraintKind
:
:
Tied
(
num
)
=
op
.
kind
{
let
arg
=
self
.
cur
.
func
.
dfg
.
inst_args
(
inst
)
[
num
as
usize
]
;
let
reg
=
self
.
divert
.
reg
(
arg
&
self
.
cur
.
func
.
locations
)
;
self
.
cur
.
func
.
locations
[
lv
.
value
]
=
ValueLoc
:
:
Reg
(
reg
)
;
}
}
}
}
regs
.
input
=
output_regs
;
for
lv
in
defs
{
let
loc
=
self
.
cur
.
func
.
locations
[
lv
.
value
]
;
debug
!
(
"
color
{
}
-
>
{
}
{
}
"
lv
.
value
loc
.
display
(
&
self
.
reginfo
)
if
lv
.
is_local
{
"
"
}
else
if
replace_global_defines
{
"
(
global
to
be
replaced
)
"
}
else
{
"
(
global
)
"
}
)
;
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
if
lv
.
endpoint
=
=
inst
{
regs
.
input
.
free
(
rc
loc
.
unwrap_reg
(
)
)
;
debug_assert
!
(
lv
.
is_local
)
;
}
if
!
lv
.
is_local
&
&
!
replace_global_defines
{
regs
.
global
.
take
(
rc
loc
.
unwrap_reg
(
)
)
;
}
}
}
self
.
forget_diverted
(
kills
)
;
replace_global_defines
}
fn
program_input_constraints
(
&
mut
self
inst
:
Inst
constraints
:
&
[
OperandConstraint
]
)
{
for
(
op
&
value
)
in
constraints
.
iter
(
)
.
zip
(
self
.
cur
.
func
.
dfg
.
inst_args
(
inst
)
)
.
filter
(
|
&
(
op
_
)
|
op
.
kind
!
=
ConstraintKind
:
:
Stack
)
{
let
cur_reg
=
self
.
divert
.
reg
(
value
&
self
.
cur
.
func
.
locations
)
;
match
op
.
kind
{
ConstraintKind
:
:
FixedReg
(
regunit
)
|
ConstraintKind
:
:
FixedTied
(
regunit
)
=
>
{
self
.
solver
.
reassign_in
(
value
op
.
regclass
cur_reg
regunit
)
;
}
ConstraintKind
:
:
Reg
|
ConstraintKind
:
:
Tied
(
_
)
=
>
{
if
!
op
.
regclass
.
contains
(
cur_reg
)
{
self
.
solver
.
add_var
(
value
op
.
regclass
cur_reg
)
;
}
}
ConstraintKind
:
:
Stack
=
>
unreachable
!
(
)
}
}
}
fn
program_complete_input_constraints
(
&
mut
self
)
{
let
inst
=
self
.
cur
.
current_inst
(
)
.
expect
(
"
Not
on
an
instruction
"
)
;
let
constraints
=
self
.
encinfo
.
operand_constraints
(
self
.
cur
.
func
.
encodings
[
inst
]
)
.
expect
(
"
Current
instruction
not
encoded
"
)
.
ins
;
for
(
op
&
value
)
in
constraints
.
iter
(
)
.
zip
(
self
.
cur
.
func
.
dfg
.
inst_args
(
inst
)
)
{
match
op
.
kind
{
ConstraintKind
:
:
Reg
|
ConstraintKind
:
:
Tied
(
_
)
=
>
{
let
cur_reg
=
self
.
divert
.
reg
(
value
&
self
.
cur
.
func
.
locations
)
;
if
op
.
regclass
.
contains
(
cur_reg
)
{
let
ctx
=
self
.
liveness
.
context
(
&
self
.
cur
.
func
.
layout
)
;
if
self
.
liveness
[
value
]
.
killed_at
(
inst
ctx
.
order
.
pp_ebb
(
inst
)
ctx
)
{
self
.
solver
.
add_killed_var
(
value
op
.
regclass
cur_reg
)
;
}
else
{
self
.
solver
.
add_through_var
(
value
op
.
regclass
cur_reg
)
;
}
}
}
ConstraintKind
:
:
FixedReg
(
_
)
|
ConstraintKind
:
:
FixedTied
(
_
)
|
ConstraintKind
:
:
Stack
=
>
{
}
}
}
}
fn
program_ebb_arguments
(
&
mut
self
inst
:
Inst
dest
:
Ebb
)
-
>
bool
{
self
.
undivert_regs
(
|
lr
ctx
|
lr
.
is_livein
(
dest
ctx
)
)
;
let
br_args
=
self
.
cur
.
func
.
dfg
.
inst_variable_args
(
inst
)
;
let
dest_args
=
self
.
cur
.
func
.
dfg
.
ebb_params
(
dest
)
;
debug_assert_eq
!
(
br_args
.
len
(
)
dest_args
.
len
(
)
)
;
for
(
&
dest_arg
&
br_arg
)
in
dest_args
.
iter
(
)
.
zip
(
br_args
)
{
match
self
.
cur
.
func
.
locations
[
dest_arg
]
{
ValueLoc
:
:
Unassigned
=
>
{
if
self
.
liveness
[
dest_arg
]
.
affinity
.
is_reg
(
)
{
return
true
;
}
}
ValueLoc
:
:
Reg
(
dest_reg
)
=
>
{
if
let
Affinity
:
:
Reg
(
rci
)
=
self
.
liveness
[
br_arg
]
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
let
br_reg
=
self
.
divert
.
reg
(
br_arg
&
self
.
cur
.
func
.
locations
)
;
self
.
solver
.
reassign_in
(
br_arg
rc
br_reg
dest_reg
)
;
}
else
{
panic
!
(
"
Branch
argument
{
}
is
not
in
a
register
"
br_arg
)
;
}
}
ValueLoc
:
:
Stack
(
ss
)
=
>
{
debug_assert_eq
!
(
ValueLoc
:
:
Stack
(
ss
)
self
.
cur
.
func
.
locations
[
br_arg
]
)
;
}
}
}
false
}
fn
color_ebb_params
(
&
mut
self
inst
:
Inst
dest
:
Ebb
)
{
let
br_args
=
self
.
cur
.
func
.
dfg
.
inst_variable_args
(
inst
)
;
let
dest_args
=
self
.
cur
.
func
.
dfg
.
ebb_params
(
dest
)
;
debug_assert_eq
!
(
br_args
.
len
(
)
dest_args
.
len
(
)
)
;
for
(
&
dest_arg
&
br_arg
)
in
dest_args
.
iter
(
)
.
zip
(
br_args
)
{
match
self
.
cur
.
func
.
locations
[
dest_arg
]
{
ValueLoc
:
:
Unassigned
=
>
{
if
self
.
liveness
[
dest_arg
]
.
affinity
.
is_reg
(
)
{
let
br_reg
=
self
.
divert
.
reg
(
br_arg
&
self
.
cur
.
func
.
locations
)
;
self
.
cur
.
func
.
locations
[
dest_arg
]
=
ValueLoc
:
:
Reg
(
br_reg
)
;
}
}
ValueLoc
:
:
Reg
(
_
)
=
>
panic
!
(
"
{
}
arg
{
}
already
colored
"
dest
dest_arg
)
ValueLoc
:
:
Stack
(
_
)
=
>
{
}
}
}
}
fn
undivert_regs
<
Pred
>
(
&
mut
self
mut
pred
:
Pred
)
where
Pred
:
FnMut
(
&
LiveRange
LiveRangeContext
<
Layout
>
)
-
>
bool
{
for
(
&
value
rdiv
)
in
self
.
divert
.
iter
(
)
{
let
lr
=
self
.
liveness
.
get
(
value
)
.
expect
(
"
Missing
live
range
for
diverted
register
"
)
;
if
pred
(
lr
self
.
liveness
.
context
(
&
self
.
cur
.
func
.
layout
)
)
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lr
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
self
.
solver
.
reassign_in
(
value
rc
rdiv
.
to
.
unwrap_reg
(
)
rdiv
.
from
.
unwrap_reg
(
)
)
;
}
else
{
panic
!
(
"
Diverted
register
{
}
with
{
}
affinity
"
value
lr
.
affinity
.
display
(
&
self
.
reginfo
)
)
;
}
}
}
}
fn
divert_fixed_input_conflicts
(
&
mut
self
live
:
&
[
LiveValue
]
)
{
for
lv
in
live
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
toprc
=
self
.
reginfo
.
toprc
(
rci
)
;
let
reg
=
self
.
divert
.
reg
(
lv
.
value
&
self
.
cur
.
func
.
locations
)
;
if
self
.
solver
.
is_fixed_input_conflict
(
toprc
reg
)
{
self
.
solver
.
add_var
(
lv
.
value
toprc
reg
)
;
}
}
}
}
fn
program_fixed_outputs
(
&
mut
self
constraints
:
&
[
OperandConstraint
]
defs
:
&
[
LiveValue
]
throughs
:
&
[
LiveValue
]
replace_global_defines
:
&
mut
bool
global_regs
:
&
RegisterSet
)
{
for
(
op
lv
)
in
constraints
.
iter
(
)
.
zip
(
defs
)
{
match
op
.
kind
{
ConstraintKind
:
:
FixedReg
(
reg
)
|
ConstraintKind
:
:
FixedTied
(
reg
)
=
>
{
self
.
add_fixed_output
(
lv
.
value
op
.
regclass
reg
throughs
)
;
if
!
lv
.
is_local
&
&
!
global_regs
.
is_avail
(
op
.
regclass
reg
)
{
debug
!
(
"
Fixed
output
{
}
in
{
}
:
{
}
is
not
available
in
global
regs
"
lv
.
value
op
.
regclass
self
.
reginfo
.
display_regunit
(
reg
)
)
;
*
replace_global_defines
=
true
;
}
}
ConstraintKind
:
:
Reg
|
ConstraintKind
:
:
Tied
(
_
)
|
ConstraintKind
:
:
Stack
=
>
{
}
}
}
}
fn
program_output_abi
(
&
mut
self
sig
:
SigRef
defs
:
&
[
LiveValue
]
throughs
:
&
[
LiveValue
]
replace_global_defines
:
&
mut
bool
global_regs
:
&
RegisterSet
)
{
debug_assert_eq
!
(
defs
.
len
(
)
self
.
cur
.
func
.
dfg
.
signatures
[
sig
]
.
returns
.
len
(
)
)
;
for
(
i
lv
)
in
defs
.
iter
(
)
.
enumerate
(
)
{
let
abi
=
self
.
cur
.
func
.
dfg
.
signatures
[
sig
]
.
returns
[
i
]
;
if
let
ArgumentLoc
:
:
Reg
(
reg
)
=
abi
.
location
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
self
.
add_fixed_output
(
lv
.
value
rc
reg
throughs
)
;
if
!
lv
.
is_local
&
&
!
global_regs
.
is_avail
(
rc
reg
)
{
debug
!
(
"
ABI
output
{
}
in
{
}
:
{
}
is
not
available
in
global
regs
"
lv
.
value
rc
self
.
reginfo
.
display_regunit
(
reg
)
)
;
*
replace_global_defines
=
true
;
}
}
else
{
panic
!
(
"
ABI
argument
{
}
should
be
in
a
register
"
lv
.
value
)
;
}
}
}
}
fn
add_fixed_output
(
&
mut
self
value
:
Value
rc
:
RegClass
reg
:
RegUnit
throughs
:
&
[
LiveValue
]
)
{
if
!
self
.
solver
.
add_fixed_output
(
rc
reg
)
{
for
lv
in
throughs
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
toprc2
=
self
.
reginfo
.
toprc
(
rci
)
;
let
reg2
=
self
.
divert
.
reg
(
lv
.
value
&
self
.
cur
.
func
.
locations
)
;
if
regs_overlap
(
rc
reg
toprc2
reg2
)
{
self
.
solver
.
add_through_var
(
lv
.
value
toprc2
reg2
)
;
}
}
}
let
ok
=
self
.
solver
.
add_fixed_output
(
rc
reg
)
;
debug_assert
!
(
ok
"
Couldn
'
t
clear
fixed
output
interference
for
{
}
"
value
)
;
}
self
.
cur
.
func
.
locations
[
value
]
=
ValueLoc
:
:
Reg
(
reg
)
;
}
fn
program_output_constraints
(
&
mut
self
inst
:
Inst
constraints
:
&
[
OperandConstraint
]
defs
:
&
[
LiveValue
]
replace_global_defines
:
&
mut
bool
global_regs
:
&
RegisterSet
)
{
for
(
op
lv
)
in
constraints
.
iter
(
)
.
zip
(
defs
)
{
match
op
.
kind
{
ConstraintKind
:
:
FixedReg
(
_
)
|
ConstraintKind
:
:
FixedTied
(
_
)
|
ConstraintKind
:
:
Stack
=
>
continue
ConstraintKind
:
:
Reg
=
>
{
self
.
solver
.
add_def
(
lv
.
value
op
.
regclass
!
lv
.
is_local
)
;
}
ConstraintKind
:
:
Tied
(
num
)
=
>
{
let
arg
=
self
.
cur
.
func
.
dfg
.
inst_args
(
inst
)
[
num
as
usize
]
;
if
let
Some
(
reg
)
=
self
.
solver
.
add_tied_input
(
arg
op
.
regclass
self
.
divert
.
reg
(
arg
&
self
.
cur
.
func
.
locations
)
!
lv
.
is_local
)
{
if
!
lv
.
is_local
&
&
!
global_regs
.
is_avail
(
op
.
regclass
reg
)
{
debug
!
(
"
Tied
output
{
}
in
{
}
:
{
}
is
not
available
in
global
regs
"
lv
.
value
op
.
regclass
self
.
reginfo
.
display_regunit
(
reg
)
)
;
*
replace_global_defines
=
true
;
}
}
}
}
}
}
fn
iterate_solution
(
&
mut
self
throughs
:
&
[
LiveValue
]
global_regs
:
&
RegisterSet
replace_global_defines
:
&
mut
bool
)
-
>
RegisterSet
{
self
.
program_complete_input_constraints
(
)
;
loop
{
match
self
.
solver
.
real_solve
(
global_regs
)
{
Ok
(
regs
)
=
>
return
regs
Err
(
SolverError
:
:
Divert
(
rc
)
)
=
>
{
let
added
=
self
.
try_add_var
(
rc
throughs
)
;
debug_assert
!
(
added
"
Ran
out
of
registers
in
{
}
"
rc
)
;
}
Err
(
SolverError
:
:
Global
(
_value
)
)
=
>
{
debug
!
(
"
Not
enough
global
registers
for
{
}
trying
as
local
"
_value
)
;
*
replace_global_defines
=
true
;
self
.
solver
.
clear_all_global_flags
(
)
;
}
}
;
}
}
fn
try_add_var
(
&
mut
self
rc
:
RegClass
throughs
:
&
[
LiveValue
]
)
-
>
bool
{
debug
!
(
"
Trying
to
add
a
{
}
reg
from
{
}
values
"
rc
throughs
.
len
(
)
)
;
for
lv
in
throughs
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
toprc2
=
self
.
reginfo
.
toprc
(
rci
)
;
let
reg2
=
self
.
divert
.
reg
(
lv
.
value
&
self
.
cur
.
func
.
locations
)
;
if
rc
.
contains
(
reg2
)
&
&
self
.
solver
.
can_add_var
(
lv
.
value
toprc2
reg2
)
&
&
!
self
.
is_live_on_outgoing_edge
(
lv
.
value
)
{
self
.
solver
.
add_through_var
(
lv
.
value
toprc2
reg2
)
;
return
true
;
}
}
}
false
}
fn
is_live_on_outgoing_edge
(
&
self
value
:
Value
)
-
>
bool
{
use
crate
:
:
ir
:
:
instructions
:
:
BranchInfo
:
:
*
;
let
inst
=
self
.
cur
.
current_inst
(
)
.
expect
(
"
Not
on
an
instruction
"
)
;
let
ctx
=
self
.
liveness
.
context
(
&
self
.
cur
.
func
.
layout
)
;
match
self
.
cur
.
func
.
dfg
.
analyze_branch
(
inst
)
{
NotABranch
=
>
false
SingleDest
(
ebb
_
)
=
>
{
let
lr
=
&
self
.
liveness
[
value
]
;
lr
.
is_livein
(
ebb
ctx
)
}
Table
(
jt
ebb
)
=
>
{
let
lr
=
&
self
.
liveness
[
value
]
;
!
lr
.
is_local
(
)
&
&
(
ebb
.
map_or
(
false
|
ebb
|
lr
.
is_livein
(
ebb
ctx
)
)
|
|
self
.
cur
.
func
.
jump_tables
[
jt
]
.
iter
(
)
.
any
(
|
ebb
|
lr
.
is_livein
(
*
ebb
ctx
)
)
)
}
}
}
fn
shuffle_inputs
(
&
mut
self
regs
:
&
mut
RegisterSet
)
{
use
crate
:
:
regalloc
:
:
solver
:
:
Move
:
:
*
;
let
spills
=
self
.
solver
.
schedule_moves
(
regs
)
;
let
mut
slot
=
[
PackedOption
:
:
default
(
)
;
8
]
;
debug_assert
!
(
spills
<
=
slot
.
len
(
)
"
Too
many
spills
(
{
}
)
"
spills
)
;
for
m
in
self
.
solver
.
moves
(
)
{
match
*
m
{
Reg
{
value
from
to
.
.
}
=
>
{
self
.
divert
.
regmove
(
value
from
to
)
;
self
.
cur
.
ins
(
)
.
regmove
(
value
from
to
)
;
}
Spill
{
value
from
to_slot
.
.
}
=
>
{
debug_assert_eq
!
(
slot
[
to_slot
]
.
expand
(
)
None
"
Overwriting
slot
in
use
"
)
;
let
ss
=
self
.
cur
.
func
.
stack_slots
.
get_emergency_slot
(
self
.
cur
.
func
.
dfg
.
value_type
(
value
)
&
slot
[
0
.
.
spills
]
)
;
slot
[
to_slot
]
=
ss
.
into
(
)
;
self
.
divert
.
regspill
(
value
from
ss
)
;
self
.
cur
.
ins
(
)
.
regspill
(
value
from
ss
)
;
}
Fill
{
value
from_slot
to
.
.
}
=
>
{
let
ss
=
slot
[
from_slot
]
.
take
(
)
.
expect
(
"
Using
unallocated
slot
"
)
;
self
.
divert
.
regfill
(
value
ss
to
)
;
self
.
cur
.
ins
(
)
.
regfill
(
value
ss
to
)
;
}
}
}
}
fn
forget_diverted
(
&
mut
self
kills
:
&
[
LiveValue
]
)
{
if
self
.
divert
.
is_empty
(
)
{
return
;
}
for
lv
in
kills
{
if
lv
.
affinity
.
is_reg
(
)
{
self
.
divert
.
remove
(
lv
.
value
)
;
}
}
}
fn
replace_global_defines
(
&
mut
self
inst
:
Inst
tracker
:
&
mut
LiveValueTracker
)
{
debug
!
(
"
Replacing
global
defs
on
{
}
"
self
.
cur
.
display_inst
(
inst
)
)
;
self
.
cur
.
next_inst
(
)
;
for
lv
in
tracker
.
live_mut
(
)
.
iter_mut
(
)
.
rev
(
)
{
if
match
self
.
cur
.
func
.
dfg
.
value_def
(
lv
.
value
)
{
ValueDef
:
:
Result
(
i
_
)
=
>
i
!
=
inst
_
=
>
true
}
{
break
;
}
if
lv
.
is_local
|
|
!
lv
.
affinity
.
is_reg
(
)
{
continue
;
}
let
ty
=
self
.
cur
.
func
.
dfg
.
value_type
(
lv
.
value
)
;
let
local
=
self
.
cur
.
func
.
dfg
.
replace_result
(
lv
.
value
ty
)
;
self
.
cur
.
ins
(
)
.
with_result
(
lv
.
value
)
.
copy
(
local
)
;
let
copy
=
self
.
cur
.
built_inst
(
)
;
self
.
liveness
.
create_dead
(
local
inst
lv
.
affinity
)
;
self
.
liveness
.
extend_locally
(
local
self
.
cur
.
func
.
layout
.
pp_ebb
(
inst
)
copy
&
self
.
cur
.
func
.
layout
)
;
self
.
liveness
.
move_def_locally
(
lv
.
value
copy
)
;
let
loc
=
mem
:
:
replace
(
&
mut
self
.
cur
.
func
.
locations
[
lv
.
value
]
ValueLoc
:
:
default
(
)
)
;
self
.
cur
.
func
.
locations
[
local
]
=
loc
;
lv
.
value
=
local
;
lv
.
endpoint
=
copy
;
lv
.
is_local
=
true
;
debug
!
(
"
+
{
}
with
{
}
in
{
}
"
self
.
cur
.
display_inst
(
copy
)
local
loc
.
display
(
&
self
.
reginfo
)
)
;
}
debug
!
(
"
Done
:
{
}
"
self
.
cur
.
display_inst
(
inst
)
)
;
}
fn
process_ghost_kills
(
&
mut
self
kills
:
&
[
LiveValue
]
regs
:
&
mut
AvailableRegs
)
{
for
lv
in
kills
{
if
let
Affinity
:
:
Reg
(
rci
)
=
lv
.
affinity
{
let
rc
=
self
.
reginfo
.
rc
(
rci
)
;
let
loc
=
match
self
.
divert
.
remove
(
lv
.
value
)
{
Some
(
loc
)
=
>
loc
None
=
>
self
.
cur
.
func
.
locations
[
lv
.
value
]
}
;
regs
.
input
.
free
(
rc
loc
.
unwrap_reg
(
)
)
;
if
!
lv
.
is_local
{
regs
.
global
.
free
(
rc
self
.
cur
.
func
.
locations
[
lv
.
value
]
.
unwrap_reg
(
)
)
;
}
}
}
}
}
fn
program_input_abi
(
solver
:
&
mut
Solver
inst
:
Inst
abi_types
:
&
[
AbiParam
]
func
:
&
Function
liveness
:
&
Liveness
reginfo
:
&
RegInfo
divert
:
&
RegDiversions
)
{
for
(
abi
&
value
)
in
abi_types
.
iter
(
)
.
zip
(
func
.
dfg
.
inst_variable_args
(
inst
)
)
{
if
let
ArgumentLoc
:
:
Reg
(
reg
)
=
abi
.
location
{
if
let
Affinity
:
:
Reg
(
rci
)
=
liveness
.
get
(
value
)
.
expect
(
"
ABI
register
must
have
live
range
"
)
.
affinity
{
let
rc
=
reginfo
.
rc
(
rci
)
;
let
cur_reg
=
divert
.
reg
(
value
&
func
.
locations
)
;
solver
.
reassign_in
(
value
rc
cur_reg
reg
)
;
}
else
{
panic
!
(
"
ABI
argument
{
}
should
be
in
a
register
"
value
)
;
}
}
}
}
struct
AvailableRegs
{
input
:
RegisterSet
global
:
RegisterSet
}
impl
AvailableRegs
{
pub
fn
new
(
regs
:
&
RegisterSet
)
-
>
Self
{
Self
{
input
:
regs
.
clone
(
)
global
:
regs
.
clone
(
)
}
}
pub
fn
take
(
&
mut
self
rc
:
RegClass
reg
:
RegUnit
is_local
:
bool
)
{
self
.
input
.
take
(
rc
reg
)
;
if
!
is_local
{
self
.
global
.
take
(
rc
reg
)
;
}
}
}
