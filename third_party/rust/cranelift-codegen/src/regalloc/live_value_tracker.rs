use
crate
:
:
dominator_tree
:
:
DominatorTree
;
use
crate
:
:
entity
:
:
{
EntityList
ListPool
}
;
use
crate
:
:
fx
:
:
FxHashMap
;
use
crate
:
:
ir
:
:
{
DataFlowGraph
Ebb
ExpandedProgramPoint
Inst
Layout
Value
}
;
use
crate
:
:
partition_slice
:
:
partition_slice
;
use
crate
:
:
regalloc
:
:
affinity
:
:
Affinity
;
use
crate
:
:
regalloc
:
:
liveness
:
:
Liveness
;
use
crate
:
:
regalloc
:
:
liverange
:
:
LiveRange
;
use
std
:
:
vec
:
:
Vec
;
type
ValueList
=
EntityList
<
Value
>
;
pub
struct
LiveValueTracker
{
live
:
LiveValueVec
idom_sets
:
FxHashMap
<
Inst
ValueList
>
idom_pool
:
ListPool
<
Value
>
}
#
[
derive
(
Debug
)
]
pub
struct
LiveValue
{
pub
value
:
Value
pub
endpoint
:
Inst
pub
affinity
:
Affinity
pub
is_local
:
bool
pub
is_dead
:
bool
}
struct
LiveValueVec
{
values
:
Vec
<
LiveValue
>
live_prefix
:
Option
<
(
Inst
usize
)
>
}
impl
LiveValueVec
{
fn
new
(
)
-
>
Self
{
Self
{
values
:
Vec
:
:
new
(
)
live_prefix
:
None
}
}
fn
push
(
&
mut
self
value
:
Value
endpoint
:
Inst
lr
:
&
LiveRange
)
{
self
.
values
.
push
(
LiveValue
{
value
endpoint
affinity
:
lr
.
affinity
is_local
:
lr
.
is_local
(
)
is_dead
:
lr
.
is_dead
(
)
}
)
;
}
fn
clear
(
&
mut
self
)
{
self
.
values
.
clear
(
)
;
self
.
live_prefix
=
None
;
}
fn
live_after
(
&
mut
self
next_inst
:
Inst
)
-
>
usize
{
let
keep
=
match
self
.
live_prefix
{
Some
(
(
i
prefix
)
)
if
i
=
=
next_inst
=
>
prefix
_
=
>
0
}
;
let
prefix
=
keep
+
partition_slice
(
&
mut
self
.
values
[
keep
.
.
]
|
v
|
v
.
endpoint
!
=
next_inst
)
;
self
.
live_prefix
=
Some
(
(
next_inst
prefix
)
)
;
prefix
}
fn
remove_kill_values
(
&
mut
self
next_inst
:
Inst
)
{
let
keep
=
self
.
live_after
(
next_inst
)
;
self
.
values
.
truncate
(
keep
)
;
}
fn
remove_dead_values
(
&
mut
self
)
{
self
.
values
.
retain
(
|
v
|
!
v
.
is_dead
)
;
self
.
live_prefix
=
None
;
}
}
impl
LiveValueTracker
{
pub
fn
new
(
)
-
>
Self
{
Self
{
live
:
LiveValueVec
:
:
new
(
)
idom_sets
:
FxHashMap
(
)
idom_pool
:
ListPool
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
live
.
clear
(
)
;
self
.
idom_sets
.
clear
(
)
;
self
.
idom_pool
.
clear
(
)
;
}
pub
fn
live
(
&
self
)
-
>
&
[
LiveValue
]
{
&
self
.
live
.
values
}
pub
fn
live_mut
(
&
mut
self
)
-
>
&
mut
[
LiveValue
]
{
&
mut
self
.
live
.
values
}
pub
fn
ebb_top
(
&
mut
self
ebb
:
Ebb
dfg
:
&
DataFlowGraph
liveness
:
&
Liveness
layout
:
&
Layout
domtree
:
&
DominatorTree
)
-
>
(
&
[
LiveValue
]
&
[
LiveValue
]
)
{
self
.
live
.
clear
(
)
;
if
let
Some
(
idom
)
=
domtree
.
idom
(
ebb
)
{
let
idom_live_list
=
self
.
idom_sets
.
get
(
&
idom
)
.
expect
(
"
No
stored
live
set
for
dominator
"
)
;
for
&
value
in
idom_live_list
.
as_slice
(
&
self
.
idom_pool
)
{
let
lr
=
liveness
.
get
(
value
)
.
expect
(
"
Immediate
dominator
value
has
no
live
range
"
)
;
if
let
Some
(
endpoint
)
=
lr
.
livein_local_end
(
ebb
liveness
.
forest
(
)
layout
)
{
self
.
live
.
push
(
value
endpoint
lr
)
;
}
}
}
let
first_arg
=
self
.
live
.
values
.
len
(
)
;
for
&
value
in
dfg
.
ebb_params
(
ebb
)
{
let
lr
=
&
liveness
[
value
]
;
debug_assert_eq
!
(
lr
.
def
(
)
ebb
.
into
(
)
)
;
match
lr
.
def_local_end
(
)
.
into
(
)
{
ExpandedProgramPoint
:
:
Inst
(
endpoint
)
=
>
{
self
.
live
.
push
(
value
endpoint
lr
)
;
}
ExpandedProgramPoint
:
:
Ebb
(
local_ebb
)
=
>
{
debug_assert_eq
!
(
local_ebb
ebb
"
EBB
parameter
live
range
ends
at
wrong
EBB
header
"
)
;
self
.
live
.
push
(
value
layout
.
first_inst
(
ebb
)
.
expect
(
"
Empty
EBB
"
)
lr
)
;
}
}
}
self
.
live
.
values
.
split_at
(
first_arg
)
}
pub
fn
process_inst
(
&
mut
self
inst
:
Inst
dfg
:
&
DataFlowGraph
liveness
:
&
Liveness
)
-
>
(
&
[
LiveValue
]
&
[
LiveValue
]
&
[
LiveValue
]
)
{
if
dfg
[
inst
]
.
opcode
(
)
.
is_branch
(
)
{
self
.
save_idom_live_set
(
inst
)
;
}
let
first_kill
=
self
.
live
.
live_after
(
inst
)
;
let
first_def
=
self
.
live
.
values
.
len
(
)
;
for
&
value
in
dfg
.
inst_results
(
inst
)
{
let
lr
=
&
liveness
[
value
]
;
debug_assert_eq
!
(
lr
.
def
(
)
inst
.
into
(
)
)
;
match
lr
.
def_local_end
(
)
.
into
(
)
{
ExpandedProgramPoint
:
:
Inst
(
endpoint
)
=
>
{
self
.
live
.
push
(
value
endpoint
lr
)
;
}
ExpandedProgramPoint
:
:
Ebb
(
ebb
)
=
>
{
panic
!
(
"
Instruction
result
live
range
can
'
t
end
at
{
}
"
ebb
)
;
}
}
}
(
&
self
.
live
.
values
[
0
.
.
first_kill
]
&
self
.
live
.
values
[
first_kill
.
.
first_def
]
&
self
.
live
.
values
[
first_def
.
.
]
)
}
pub
fn
process_ghost
(
&
mut
self
inst
:
Inst
)
-
>
(
&
[
LiveValue
]
&
[
LiveValue
]
)
{
let
first_kill
=
self
.
live
.
live_after
(
inst
)
;
self
.
live
.
values
.
as_slice
(
)
.
split_at
(
first_kill
)
}
pub
fn
drop_dead
(
&
mut
self
inst
:
Inst
)
{
self
.
live
.
remove_kill_values
(
inst
)
;
}
pub
fn
drop_dead_params
(
&
mut
self
)
{
self
.
live
.
remove_dead_values
(
)
;
}
pub
fn
process_spills
<
F
>
(
&
mut
self
mut
f
:
F
)
where
F
:
FnMut
(
Value
)
-
>
bool
{
for
lv
in
&
mut
self
.
live
.
values
{
if
f
(
lv
.
value
)
{
lv
.
affinity
=
Affinity
:
:
Stack
;
}
}
}
fn
save_idom_live_set
(
&
mut
self
idom
:
Inst
)
{
let
values
=
self
.
live
.
values
.
iter
(
)
.
map
(
|
lv
|
lv
.
value
)
;
let
pool
=
&
mut
self
.
idom_pool
;
self
.
idom_sets
.
entry
(
idom
)
.
or_insert_with
(
|
|
{
let
mut
list
=
ValueList
:
:
default
(
)
;
list
.
extend
(
values
pool
)
;
list
}
)
;
}
}
