use
isa
:
:
registers
:
:
{
RegClass
RegInfo
RegUnit
RegUnitMask
}
;
use
std
:
:
char
;
use
std
:
:
fmt
;
use
std
:
:
iter
:
:
ExactSizeIterator
;
use
std
:
:
mem
:
:
size_of_val
;
#
[
derive
(
Clone
)
]
pub
struct
RegisterSet
{
avail
:
RegUnitMask
}
fn
bitmask
(
rc
:
RegClass
reg
:
RegUnit
)
-
>
(
usize
u32
)
{
let
width_bits
=
(
1
<
<
rc
.
width
)
-
1
;
let
word_index
=
(
reg
/
32
)
as
usize
;
let
reg_bits
=
width_bits
<
<
(
reg
%
32
)
;
(
word_index
reg_bits
)
}
impl
RegisterSet
{
pub
fn
new
(
)
-
>
Self
{
Self
{
avail
:
[
!
0
;
3
]
}
}
pub
fn
empty
(
)
-
>
Self
{
Self
{
avail
:
[
0
;
3
]
}
}
pub
fn
is_avail
(
&
self
rc
:
RegClass
reg
:
RegUnit
)
-
>
bool
{
let
(
idx
bits
)
=
bitmask
(
rc
reg
)
;
(
self
.
avail
[
idx
]
&
bits
)
=
=
bits
}
pub
fn
take
(
&
mut
self
rc
:
RegClass
reg
:
RegUnit
)
{
let
(
idx
bits
)
=
bitmask
(
rc
reg
)
;
debug_assert
!
(
(
self
.
avail
[
idx
]
&
bits
)
=
=
bits
"
{
}
:
{
}
not
available
in
{
}
"
rc
rc
.
info
.
display_regunit
(
reg
)
self
.
display
(
rc
.
info
)
)
;
self
.
avail
[
idx
]
&
=
!
bits
;
}
pub
fn
free
(
&
mut
self
rc
:
RegClass
reg
:
RegUnit
)
{
let
(
idx
bits
)
=
bitmask
(
rc
reg
)
;
debug_assert
!
(
(
self
.
avail
[
idx
]
&
bits
)
=
=
0
"
{
}
:
{
}
is
already
free
in
{
}
"
rc
rc
.
info
.
display_regunit
(
reg
)
self
.
display
(
rc
.
info
)
)
;
self
.
avail
[
idx
]
|
=
bits
;
}
pub
fn
iter
(
&
self
rc
:
RegClass
)
-
>
RegSetIter
{
let
mut
rsi
=
RegSetIter
{
regs
:
rc
.
mask
}
;
for
idx
in
0
.
.
self
.
avail
.
len
(
)
{
for
i
in
0
.
.
rc
.
width
{
rsi
.
regs
[
idx
]
&
=
self
.
avail
[
idx
]
>
>
i
;
}
}
rsi
}
pub
fn
interferes_with
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
avail
.
iter
(
)
.
zip
(
&
other
.
avail
)
.
any
(
|
(
&
x
&
y
)
|
(
x
|
y
)
!
=
!
0
)
}
pub
fn
intersect
(
&
mut
self
other
:
&
Self
)
{
for
(
x
&
y
)
in
self
.
avail
.
iter_mut
(
)
.
zip
(
&
other
.
avail
)
{
*
x
&
=
y
;
}
}
pub
fn
display
<
'
a
R
:
Into
<
Option
<
&
'
a
RegInfo
>
>
>
(
&
self
regs
:
R
)
-
>
DisplayRegisterSet
<
'
a
>
{
DisplayRegisterSet
(
self
.
clone
(
)
regs
.
into
(
)
)
}
}
pub
struct
RegSetIter
{
regs
:
RegUnitMask
}
impl
Iterator
for
RegSetIter
{
type
Item
=
RegUnit
;
fn
next
(
&
mut
self
)
-
>
Option
<
RegUnit
>
{
let
mut
unit_offset
=
0
;
for
word
in
&
mut
self
.
regs
{
if
*
word
!
=
0
{
let
unit
=
unit_offset
+
word
.
trailing_zeros
(
)
as
RegUnit
;
*
word
&
=
*
word
-
1
;
return
Some
(
unit
)
;
}
unit_offset
+
=
8
*
size_of_val
(
word
)
as
RegUnit
;
}
None
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
bits
=
self
.
regs
.
iter
(
)
.
map
(
|
&
w
|
w
.
count_ones
(
)
as
usize
)
.
sum
(
)
;
(
bits
Some
(
bits
)
)
}
}
impl
ExactSizeIterator
for
RegSetIter
{
}
pub
struct
DisplayRegisterSet
<
'
a
>
(
RegisterSet
Option
<
&
'
a
RegInfo
>
)
;
impl
<
'
a
>
fmt
:
:
Display
for
DisplayRegisterSet
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
[
"
)
?
;
match
self
.
1
{
None
=
>
{
for
w
in
&
self
.
0
.
avail
{
write
!
(
f
"
#
{
:
08x
}
"
w
)
?
;
}
}
Some
(
reginfo
)
=
>
{
let
toprcs
=
reginfo
.
banks
.
iter
(
)
.
map
(
|
b
|
b
.
first_toprc
+
b
.
num_toprcs
)
.
max
(
)
.
expect
(
"
No
register
banks
"
)
;
for
rc
in
&
reginfo
.
classes
[
0
.
.
toprcs
]
{
if
rc
.
width
=
=
1
{
let
bank
=
&
reginfo
.
banks
[
rc
.
bank
as
usize
]
;
write
!
(
f
"
{
}
:
"
rc
)
?
;
for
offset
in
0
.
.
bank
.
units
{
let
reg
=
bank
.
first_unit
+
offset
;
if
!
rc
.
contains
(
reg
)
{
continue
;
}
if
!
self
.
0
.
is_avail
(
rc
reg
)
{
write
!
(
f
"
-
"
)
?
;
continue
;
}
write
!
(
f
"
{
}
"
bank
.
names
.
get
(
offset
as
usize
)
.
and_then
(
|
name
|
name
.
chars
(
)
.
nth
(
1
)
)
.
unwrap_or_else
(
|
|
char
:
:
from_digit
(
u32
:
:
from
(
offset
%
10
)
10
)
.
unwrap
(
)
)
)
?
;
}
}
}
}
}
write
!
(
f
"
]
"
)
}
}
impl
fmt
:
:
Display
for
RegisterSet
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
display
(
None
)
.
fmt
(
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
isa
:
:
registers
:
:
{
RegClass
RegClassData
}
;
use
std
:
:
vec
:
:
Vec
;
const
GPR
:
RegClass
=
&
RegClassData
{
name
:
"
GPR
"
index
:
0
width
:
1
bank
:
0
toprc
:
0
first
:
28
subclasses
:
0
mask
:
[
0xf0000000
0x0000000f
0
]
info
:
&
INFO
}
;
const
DPR
:
RegClass
=
&
RegClassData
{
name
:
"
DPR
"
index
:
0
width
:
2
bank
:
0
toprc
:
0
first
:
28
subclasses
:
0
mask
:
[
0x50000000
0x0000000a
0
]
info
:
&
INFO
}
;
const
INFO
:
RegInfo
=
RegInfo
{
banks
:
&
[
]
classes
:
&
[
]
}
;
#
[
test
]
fn
put_and_take
(
)
{
let
mut
regs
=
RegisterSet
:
:
new
(
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
len
(
)
8
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
count
(
)
8
)
;
assert_eq
!
(
regs
.
iter
(
DPR
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
28
30
33
35
]
)
;
assert
!
(
regs
.
is_avail
(
GPR
29
)
)
;
regs
.
take
(
&
GPR
29
)
;
assert
!
(
!
regs
.
is_avail
(
GPR
29
)
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
count
(
)
7
)
;
assert_eq
!
(
regs
.
iter
(
DPR
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
30
33
35
]
)
;
assert
!
(
regs
.
is_avail
(
GPR
30
)
)
;
regs
.
take
(
&
GPR
30
)
;
assert
!
(
!
regs
.
is_avail
(
GPR
30
)
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
count
(
)
6
)
;
assert_eq
!
(
regs
.
iter
(
DPR
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
33
35
]
)
;
assert
!
(
regs
.
is_avail
(
GPR
32
)
)
;
regs
.
take
(
&
GPR
32
)
;
assert
!
(
!
regs
.
is_avail
(
GPR
32
)
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
count
(
)
5
)
;
assert_eq
!
(
regs
.
iter
(
DPR
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
33
35
]
)
;
regs
.
free
(
&
GPR
30
)
;
assert
!
(
regs
.
is_avail
(
GPR
30
)
)
;
assert
!
(
!
regs
.
is_avail
(
GPR
29
)
)
;
assert
!
(
!
regs
.
is_avail
(
GPR
32
)
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
count
(
)
6
)
;
assert_eq
!
(
regs
.
iter
(
DPR
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
30
33
35
]
)
;
regs
.
free
(
&
GPR
32
)
;
assert
!
(
regs
.
is_avail
(
GPR
31
)
)
;
assert
!
(
!
regs
.
is_avail
(
GPR
29
)
)
;
assert
!
(
regs
.
is_avail
(
GPR
32
)
)
;
assert_eq
!
(
regs
.
iter
(
GPR
)
.
count
(
)
7
)
;
assert_eq
!
(
regs
.
iter
(
DPR
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
30
33
35
]
)
;
}
#
[
test
]
fn
interference
(
)
{
let
mut
regs1
=
RegisterSet
:
:
new
(
)
;
let
mut
regs2
=
RegisterSet
:
:
new
(
)
;
assert
!
(
!
regs1
.
interferes_with
(
&
regs2
)
)
;
regs1
.
take
(
&
GPR
32
)
;
assert
!
(
!
regs1
.
interferes_with
(
&
regs2
)
)
;
regs2
.
take
(
&
GPR
31
)
;
assert
!
(
!
regs1
.
interferes_with
(
&
regs2
)
)
;
regs1
.
intersect
(
&
regs2
)
;
assert
!
(
regs1
.
interferes_with
(
&
regs2
)
)
;
}
}
