use
ir
:
:
{
InstructionData
Opcode
}
;
use
ir
:
:
{
StackSlot
Value
ValueLoc
ValueLocations
}
;
use
isa
:
:
{
RegInfo
RegUnit
}
;
use
std
:
:
fmt
;
use
std
:
:
vec
:
:
Vec
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
struct
Diversion
{
pub
value
:
Value
pub
from
:
ValueLoc
pub
to
:
ValueLoc
}
impl
Diversion
{
pub
fn
new
(
value
:
Value
from
:
ValueLoc
to
:
ValueLoc
)
-
>
Self
{
debug_assert
!
(
from
.
is_assigned
(
)
&
&
to
.
is_assigned
(
)
)
;
Self
{
value
from
to
}
}
}
pub
struct
RegDiversions
{
current
:
Vec
<
Diversion
>
}
impl
RegDiversions
{
pub
fn
new
(
)
-
>
Self
{
Self
{
current
:
Vec
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
current
.
clear
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
current
.
is_empty
(
)
}
pub
fn
diversion
(
&
self
value
:
Value
)
-
>
Option
<
&
Diversion
>
{
self
.
current
.
iter
(
)
.
find
(
|
d
|
d
.
value
=
=
value
)
}
pub
fn
all
(
&
self
)
-
>
&
[
Diversion
]
{
self
.
current
.
as_slice
(
)
}
pub
fn
get
(
&
self
value
:
Value
locations
:
&
ValueLocations
)
-
>
ValueLoc
{
match
self
.
diversion
(
value
)
{
Some
(
d
)
=
>
d
.
to
None
=
>
locations
[
value
]
}
}
pub
fn
reg
(
&
self
value
:
Value
locations
:
&
ValueLocations
)
-
>
RegUnit
{
self
.
get
(
value
locations
)
.
unwrap_reg
(
)
}
pub
fn
stack
(
&
self
value
:
Value
locations
:
&
ValueLocations
)
-
>
StackSlot
{
self
.
get
(
value
locations
)
.
unwrap_stack
(
)
}
pub
fn
divert
(
&
mut
self
value
:
Value
from
:
ValueLoc
to
:
ValueLoc
)
{
debug_assert
!
(
from
.
is_assigned
(
)
&
&
to
.
is_assigned
(
)
)
;
if
let
Some
(
i
)
=
self
.
current
.
iter
(
)
.
position
(
|
d
|
d
.
value
=
=
value
)
{
debug_assert_eq
!
(
self
.
current
[
i
]
.
to
from
"
Bad
regmove
chain
for
{
}
"
value
)
;
if
self
.
current
[
i
]
.
from
!
=
to
{
self
.
current
[
i
]
.
to
=
to
;
}
else
{
self
.
current
.
swap_remove
(
i
)
;
}
}
else
{
self
.
current
.
push
(
Diversion
:
:
new
(
value
from
to
)
)
;
}
}
pub
fn
regmove
(
&
mut
self
value
:
Value
from
:
RegUnit
to
:
RegUnit
)
{
self
.
divert
(
value
ValueLoc
:
:
Reg
(
from
)
ValueLoc
:
:
Reg
(
to
)
)
;
}
pub
fn
regspill
(
&
mut
self
value
:
Value
from
:
RegUnit
to
:
StackSlot
)
{
self
.
divert
(
value
ValueLoc
:
:
Reg
(
from
)
ValueLoc
:
:
Stack
(
to
)
)
;
}
pub
fn
regfill
(
&
mut
self
value
:
Value
from
:
StackSlot
to
:
RegUnit
)
{
self
.
divert
(
value
ValueLoc
:
:
Stack
(
from
)
ValueLoc
:
:
Reg
(
to
)
)
;
}
pub
fn
apply
(
&
mut
self
inst
:
&
InstructionData
)
{
match
*
inst
{
InstructionData
:
:
RegMove
{
opcode
:
Opcode
:
:
Regmove
arg
src
dst
}
=
>
self
.
regmove
(
arg
src
dst
)
InstructionData
:
:
RegSpill
{
opcode
:
Opcode
:
:
Regspill
arg
src
dst
}
=
>
self
.
regspill
(
arg
src
dst
)
InstructionData
:
:
RegFill
{
opcode
:
Opcode
:
:
Regfill
arg
src
dst
}
=
>
self
.
regfill
(
arg
src
dst
)
_
=
>
{
}
}
}
pub
fn
remove
(
&
mut
self
value
:
Value
)
-
>
Option
<
ValueLoc
>
{
self
.
current
.
iter
(
)
.
position
(
|
d
|
d
.
value
=
=
value
)
.
map
(
|
i
|
self
.
current
.
swap_remove
(
i
)
.
to
)
}
pub
fn
display
<
'
a
R
:
Into
<
Option
<
&
'
a
RegInfo
>
>
>
(
&
'
a
self
regs
:
R
)
-
>
DisplayDiversions
<
'
a
>
{
DisplayDiversions
(
self
regs
.
into
(
)
)
}
}
pub
struct
DisplayDiversions
<
'
a
>
(
&
'
a
RegDiversions
Option
<
&
'
a
RegInfo
>
)
;
impl
<
'
a
>
fmt
:
:
Display
for
DisplayDiversions
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
{
"
)
?
;
for
div
in
self
.
0
.
all
(
)
{
write
!
(
f
"
{
}
:
{
}
-
>
{
}
"
div
.
value
div
.
from
.
display
(
self
.
1
)
div
.
to
.
display
(
self
.
1
)
)
?
}
write
!
(
f
"
}
}
"
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
entity
:
:
EntityRef
;
use
ir
:
:
Value
;
#
[
test
]
fn
inserts
(
)
{
let
mut
divs
=
RegDiversions
:
:
new
(
)
;
let
v1
=
Value
:
:
new
(
1
)
;
let
v2
=
Value
:
:
new
(
2
)
;
divs
.
regmove
(
v1
10
12
)
;
assert_eq
!
(
divs
.
diversion
(
v1
)
Some
(
&
Diversion
{
value
:
v1
from
:
ValueLoc
:
:
Reg
(
10
)
to
:
ValueLoc
:
:
Reg
(
12
)
}
)
)
;
assert_eq
!
(
divs
.
diversion
(
v2
)
None
)
;
divs
.
regmove
(
v1
12
11
)
;
assert_eq
!
(
divs
.
diversion
(
v1
)
.
unwrap
(
)
.
to
ValueLoc
:
:
Reg
(
11
)
)
;
divs
.
regmove
(
v1
11
10
)
;
assert_eq
!
(
divs
.
diversion
(
v1
)
None
)
;
}
}
