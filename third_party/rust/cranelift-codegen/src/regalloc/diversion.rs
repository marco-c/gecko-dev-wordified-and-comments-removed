use
crate
:
:
fx
:
:
FxHashMap
;
use
crate
:
:
hash_map
:
:
{
Entry
Iter
}
;
use
crate
:
:
ir
:
:
{
Block
StackSlot
Value
ValueLoc
ValueLocations
}
;
use
crate
:
:
ir
:
:
{
InstructionData
Opcode
}
;
use
crate
:
:
isa
:
:
{
RegInfo
RegUnit
}
;
use
core
:
:
fmt
;
use
cranelift_entity
:
:
{
SparseMap
SparseMapValue
}
;
#
[
cfg
(
feature
=
"
enable
-
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Diversion
{
pub
from
:
ValueLoc
pub
to
:
ValueLoc
}
impl
Diversion
{
pub
fn
new
(
from
:
ValueLoc
to
:
ValueLoc
)
-
>
Self
{
debug_assert
!
(
from
.
is_assigned
(
)
&
&
to
.
is_assigned
(
)
)
;
Self
{
from
to
}
}
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
RegDiversions
{
current
:
FxHashMap
<
Value
Diversion
>
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
struct
EntryRegDiversionsValue
{
key
:
Block
divert
:
RegDiversions
}
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
EntryRegDiversions
{
map
:
SparseMap
<
Block
EntryRegDiversionsValue
>
}
impl
RegDiversions
{
pub
fn
new
(
)
-
>
Self
{
Self
{
current
:
FxHashMap
:
:
default
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
current
.
clear
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
current
.
is_empty
(
)
}
pub
fn
diversion
(
&
self
value
:
Value
)
-
>
Option
<
&
Diversion
>
{
self
.
current
.
get
(
&
value
)
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
'
_
Value
Diversion
>
{
self
.
current
.
iter
(
)
}
pub
fn
get
(
&
self
value
:
Value
locations
:
&
ValueLocations
)
-
>
ValueLoc
{
match
self
.
diversion
(
value
)
{
Some
(
d
)
=
>
d
.
to
None
=
>
locations
[
value
]
}
}
pub
fn
reg
(
&
self
value
:
Value
locations
:
&
ValueLocations
)
-
>
RegUnit
{
self
.
get
(
value
locations
)
.
unwrap_reg
(
)
}
pub
fn
stack
(
&
self
value
:
Value
locations
:
&
ValueLocations
)
-
>
StackSlot
{
self
.
get
(
value
locations
)
.
unwrap_stack
(
)
}
fn
divert
(
&
mut
self
value
:
Value
from
:
ValueLoc
to
:
ValueLoc
)
{
debug_assert
!
(
from
.
is_assigned
(
)
&
&
to
.
is_assigned
(
)
)
;
match
self
.
current
.
entry
(
value
)
{
Entry
:
:
Occupied
(
mut
e
)
=
>
{
{
let
d
=
e
.
get_mut
(
)
;
debug_assert_eq
!
(
d
.
to
from
"
Bad
regmove
chain
for
{
}
"
value
)
;
if
d
.
from
!
=
to
{
d
.
to
=
to
;
return
;
}
}
e
.
remove
(
)
;
}
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert
(
Diversion
:
:
new
(
from
to
)
)
;
}
}
}
pub
fn
regmove
(
&
mut
self
value
:
Value
from
:
RegUnit
to
:
RegUnit
)
{
self
.
divert
(
value
ValueLoc
:
:
Reg
(
from
)
ValueLoc
:
:
Reg
(
to
)
)
;
}
pub
fn
regspill
(
&
mut
self
value
:
Value
from
:
RegUnit
to
:
StackSlot
)
{
self
.
divert
(
value
ValueLoc
:
:
Reg
(
from
)
ValueLoc
:
:
Stack
(
to
)
)
;
}
pub
fn
regfill
(
&
mut
self
value
:
Value
from
:
StackSlot
to
:
RegUnit
)
{
self
.
divert
(
value
ValueLoc
:
:
Stack
(
from
)
ValueLoc
:
:
Reg
(
to
)
)
;
}
pub
fn
apply
(
&
mut
self
inst
:
&
InstructionData
)
{
match
*
inst
{
InstructionData
:
:
RegMove
{
opcode
:
Opcode
:
:
Regmove
arg
src
dst
}
=
>
self
.
regmove
(
arg
src
dst
)
InstructionData
:
:
RegSpill
{
opcode
:
Opcode
:
:
Regspill
arg
src
dst
}
=
>
self
.
regspill
(
arg
src
dst
)
InstructionData
:
:
RegFill
{
opcode
:
Opcode
:
:
Regfill
arg
src
dst
}
=
>
self
.
regfill
(
arg
src
dst
)
_
=
>
{
}
}
}
pub
fn
remove
(
&
mut
self
value
:
Value
)
-
>
Option
<
ValueLoc
>
{
self
.
current
.
remove
(
&
value
)
.
map
(
|
d
|
d
.
to
)
}
pub
fn
at_block
(
&
mut
self
entry_diversions
:
&
EntryRegDiversions
block
:
Block
)
{
self
.
clear
(
)
;
if
let
Some
(
entry_divert
)
=
entry_diversions
.
map
.
get
(
block
)
{
let
iter
=
entry_divert
.
divert
.
current
.
iter
(
)
;
self
.
current
.
extend
(
iter
)
;
}
}
pub
fn
save_for_block
(
&
mut
self
entry_diversions
:
&
mut
EntryRegDiversions
target
:
Block
)
{
if
self
.
is_empty
(
)
{
return
;
}
debug_assert
!
(
!
entry_diversions
.
map
.
contains_key
(
target
)
)
;
let
iter
=
self
.
current
.
iter
(
)
;
let
mut
entry_divert
=
Self
:
:
new
(
)
;
entry_divert
.
current
.
extend
(
iter
)
;
entry_diversions
.
map
.
insert
(
EntryRegDiversionsValue
{
key
:
target
divert
:
entry_divert
}
)
;
}
pub
fn
check_block_entry
(
&
self
entry_diversions
:
&
EntryRegDiversions
target
:
Block
)
-
>
bool
{
let
entry_divert
=
match
entry_diversions
.
map
.
get
(
target
)
{
Some
(
entry_divert
)
=
>
entry_divert
None
=
>
return
self
.
is_empty
(
)
}
;
if
entry_divert
.
divert
.
current
.
len
(
)
!
=
self
.
current
.
len
(
)
{
return
false
;
}
for
(
val
_
)
in
entry_divert
.
divert
.
current
.
iter
(
)
{
if
!
self
.
current
.
contains_key
(
val
)
{
return
false
;
}
}
true
}
pub
fn
display
<
'
a
R
:
Into
<
Option
<
&
'
a
RegInfo
>
>
>
(
&
'
a
self
regs
:
R
)
-
>
DisplayDiversions
<
'
a
>
{
DisplayDiversions
(
&
self
regs
.
into
(
)
)
}
}
impl
EntryRegDiversions
{
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
SparseMap
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
map
.
clear
(
)
;
}
}
impl
Clone
for
EntryRegDiversions
{
fn
clone
(
&
self
)
-
>
Self
{
let
mut
tmp
=
Self
:
:
new
(
)
;
for
v
in
self
.
map
.
values
(
)
{
tmp
.
map
.
insert
(
v
.
clone
(
)
)
;
}
tmp
}
}
impl
SparseMapValue
<
Block
>
for
EntryRegDiversionsValue
{
fn
key
(
&
self
)
-
>
Block
{
self
.
key
}
}
pub
struct
DisplayDiversions
<
'
a
>
(
&
'
a
RegDiversions
Option
<
&
'
a
RegInfo
>
)
;
impl
<
'
a
>
fmt
:
:
Display
for
DisplayDiversions
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
{
"
)
?
;
for
(
value
div
)
in
self
.
0
.
current
.
iter
(
)
{
write
!
(
f
"
{
}
:
{
}
-
>
{
}
"
value
div
.
from
.
display
(
self
.
1
)
div
.
to
.
display
(
self
.
1
)
)
?
}
write
!
(
f
"
}
}
"
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
entity
:
:
EntityRef
;
use
crate
:
:
ir
:
:
Value
;
#
[
test
]
fn
inserts
(
)
{
let
mut
divs
=
RegDiversions
:
:
new
(
)
;
let
v1
=
Value
:
:
new
(
1
)
;
let
v2
=
Value
:
:
new
(
2
)
;
divs
.
regmove
(
v1
10
12
)
;
assert_eq
!
(
divs
.
diversion
(
v1
)
Some
(
&
Diversion
{
from
:
ValueLoc
:
:
Reg
(
10
)
to
:
ValueLoc
:
:
Reg
(
12
)
}
)
)
;
assert_eq
!
(
divs
.
diversion
(
v2
)
None
)
;
divs
.
regmove
(
v1
12
11
)
;
assert_eq
!
(
divs
.
diversion
(
v1
)
.
unwrap
(
)
.
to
ValueLoc
:
:
Reg
(
11
)
)
;
divs
.
regmove
(
v1
11
10
)
;
assert_eq
!
(
divs
.
diversion
(
v1
)
None
)
;
}
}
