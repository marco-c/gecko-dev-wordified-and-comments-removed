use
crate
:
:
entity
:
:
SparseMapValue
;
use
crate
:
:
ir
:
:
{
Block
ExpandedProgramPoint
Inst
Layout
ProgramOrder
ProgramPoint
Value
}
;
use
crate
:
:
regalloc
:
:
affinity
:
:
Affinity
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
marker
:
:
PhantomData
;
use
smallvec
:
:
SmallVec
;
pub
type
LiveRange
=
GenericLiveRange
<
Layout
>
;
pub
struct
Interval
{
begin
:
Block
end
:
Inst
}
pub
struct
GenericLiveRange
<
PO
:
ProgramOrder
>
{
value
:
Value
pub
affinity
:
Affinity
def_begin
:
ProgramPoint
def_end
:
ProgramPoint
liveins
:
SmallVec
<
[
Interval
;
2
]
>
po
:
PhantomData
<
*
const
PO
>
}
macro_rules
!
cmp
{
(
order
:
ident
a
:
ident
>
b
:
expr
)
=
>
{
order
.
cmp
(
a
b
)
=
=
Ordering
:
:
Greater
}
;
(
order
:
ident
a
:
ident
>
=
b
:
expr
)
=
>
{
order
.
cmp
(
a
b
)
!
=
Ordering
:
:
Less
}
;
(
order
:
ident
a
:
ident
<
b
:
expr
)
=
>
{
order
.
cmp
(
a
b
)
=
=
Ordering
:
:
Less
}
;
(
order
:
ident
a
:
ident
<
=
b
:
expr
)
=
>
{
order
.
cmp
(
a
b
)
!
=
Ordering
:
:
Greater
}
;
}
impl
<
PO
:
ProgramOrder
>
GenericLiveRange
<
PO
>
{
pub
fn
new
(
value
:
Value
def
:
ProgramPoint
affinity
:
Affinity
)
-
>
Self
{
Self
{
value
affinity
def_begin
:
def
def_end
:
def
liveins
:
SmallVec
:
:
new
(
)
po
:
PhantomData
}
}
fn
lookup_entry_containing_block
(
&
self
block
:
Block
order
:
&
PO
)
-
>
Result
<
usize
usize
>
{
self
.
liveins
.
binary_search_by
(
|
interval
|
order
.
cmp
(
interval
.
begin
block
)
)
.
or_else
(
|
n
|
{
if
n
>
0
&
&
cmp
!
(
order
block
<
=
self
.
liveins
[
n
-
1
]
.
end
)
{
Ok
(
n
-
1
)
}
else
{
Err
(
n
)
}
}
)
}
pub
fn
extend_in_block
(
&
mut
self
block
:
Block
inst
:
Inst
order
:
&
PO
)
-
>
bool
{
if
cmp
!
(
order
block
<
=
self
.
def_end
)
&
&
cmp
!
(
order
inst
>
=
self
.
def_begin
)
{
let
inst_pp
=
inst
.
into
(
)
;
debug_assert_ne
!
(
inst_pp
self
.
def_begin
"
Can
'
t
use
value
in
the
defining
instruction
.
"
)
;
if
cmp
!
(
order
inst
>
self
.
def_end
)
{
self
.
def_end
=
inst_pp
;
}
return
false
;
}
match
self
.
lookup_entry_containing_block
(
block
order
)
{
Ok
(
n
)
=
>
{
if
cmp
!
(
order
inst
<
=
self
.
liveins
[
n
]
.
end
)
{
return
false
;
}
if
let
Some
(
next
)
=
&
self
.
liveins
.
get
(
n
+
1
)
{
if
order
.
is_block_gap
(
inst
next
.
begin
)
{
let
next_end
=
next
.
end
;
debug_assert
!
(
cmp
!
(
order
next_end
>
self
.
liveins
[
n
]
.
end
)
)
;
self
.
liveins
[
n
]
.
end
=
next_end
;
self
.
liveins
.
remove
(
n
+
1
)
;
return
false
;
}
}
self
.
liveins
[
n
]
.
end
=
inst
;
false
}
Err
(
n
)
=
>
{
let
coalesce_next
=
self
.
liveins
.
get
(
n
)
.
filter
(
|
next
|
order
.
is_block_gap
(
inst
next
.
begin
)
)
.
is_some
(
)
;
let
coalesce_prev
=
self
.
liveins
.
get
(
n
.
wrapping_sub
(
1
)
)
.
filter
(
|
prev
|
order
.
is_block_gap
(
prev
.
end
block
)
)
.
is_some
(
)
;
match
(
coalesce_prev
coalesce_next
)
{
(
true
true
)
=
>
{
let
prev_end
=
self
.
liveins
[
n
-
1
]
.
end
;
debug_assert
!
(
cmp
!
(
order
prev_end
<
=
self
.
liveins
[
n
]
.
end
)
)
;
self
.
liveins
[
n
-
1
]
.
end
=
self
.
liveins
[
n
]
.
end
;
self
.
liveins
.
remove
(
n
)
;
}
(
true
false
)
=
>
{
debug_assert
!
(
cmp
!
(
order
inst
>
=
self
.
liveins
[
n
-
1
]
.
end
)
)
;
self
.
liveins
[
n
-
1
]
.
end
=
inst
;
}
(
false
true
)
=
>
{
debug_assert
!
(
cmp
!
(
order
block
<
=
self
.
liveins
[
n
]
.
begin
)
)
;
self
.
liveins
[
n
]
.
begin
=
block
;
}
(
false
false
)
=
>
{
self
.
liveins
.
insert
(
n
Interval
{
begin
:
block
end
:
inst
}
)
;
}
}
true
}
}
}
pub
fn
is_dead
(
&
self
)
-
>
bool
{
self
.
def_begin
=
=
self
.
def_end
}
pub
fn
is_local
(
&
self
)
-
>
bool
{
self
.
liveins
.
is_empty
(
)
}
pub
fn
def
(
&
self
)
-
>
ProgramPoint
{
self
.
def_begin
}
pub
fn
move_def_locally
(
&
mut
self
def
:
ProgramPoint
)
{
self
.
def_begin
=
def
;
}
pub
fn
def_local_end
(
&
self
)
-
>
ProgramPoint
{
self
.
def_end
}
pub
fn
livein_local_end
(
&
self
block
:
Block
order
:
&
PO
)
-
>
Option
<
Inst
>
{
self
.
lookup_entry_containing_block
(
block
order
)
.
and_then
(
|
i
|
{
let
inst
=
self
.
liveins
[
i
]
.
end
;
if
cmp
!
(
order
block
<
inst
)
{
Ok
(
inst
)
}
else
{
Err
(
i
)
}
}
)
.
ok
(
)
}
pub
fn
is_livein
(
&
self
block
:
Block
order
:
&
PO
)
-
>
bool
{
self
.
livein_local_end
(
block
order
)
.
is_some
(
)
}
pub
fn
liveins
<
'
a
>
(
&
'
a
self
)
-
>
impl
Iterator
<
Item
=
(
Block
Inst
)
>
+
'
a
{
self
.
liveins
.
iter
(
)
.
map
(
|
interval
|
(
interval
.
begin
interval
.
end
)
)
}
pub
fn
overlaps_def
(
&
self
def
:
ExpandedProgramPoint
block
:
Block
order
:
&
PO
)
-
>
bool
{
if
def
=
=
self
.
def_begin
.
into
(
)
{
return
true
;
}
if
cmp
!
(
order
def
>
=
self
.
def_begin
)
&
&
cmp
!
(
order
def
<
self
.
def_end
)
{
return
true
;
}
match
self
.
livein_local_end
(
block
order
)
{
Some
(
inst
)
=
>
cmp
!
(
order
def
<
inst
)
None
=
>
false
}
}
pub
fn
reaches_use
(
&
self
user
:
Inst
block
:
Block
order
:
&
PO
)
-
>
bool
{
if
cmp
!
(
order
user
>
self
.
def_begin
)
&
&
cmp
!
(
order
user
<
=
self
.
def_end
)
{
return
true
;
}
match
self
.
livein_local_end
(
block
order
)
{
Some
(
inst
)
=
>
cmp
!
(
order
user
<
=
inst
)
None
=
>
false
}
}
pub
fn
killed_at
(
&
self
user
:
Inst
block
:
Block
order
:
&
PO
)
-
>
bool
{
self
.
def_local_end
(
)
=
=
user
.
into
(
)
|
|
self
.
livein_local_end
(
block
order
)
=
=
Some
(
user
)
}
}
impl
<
PO
:
ProgramOrder
>
SparseMapValue
<
Value
>
for
GenericLiveRange
<
PO
>
{
fn
key
(
&
self
)
-
>
Value
{
self
.
value
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
GenericLiveRange
Interval
}
;
use
crate
:
:
entity
:
:
EntityRef
;
use
crate
:
:
ir
:
:
{
Block
Inst
Value
}
;
use
crate
:
:
ir
:
:
{
ExpandedProgramPoint
ProgramOrder
}
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
cmp
:
:
Ordering
;
struct
ProgOrder
{
}
impl
ProgramOrder
for
ProgOrder
{
fn
cmp
<
A
B
>
(
&
self
a
:
A
b
:
B
)
-
>
Ordering
where
A
:
Into
<
ExpandedProgramPoint
>
B
:
Into
<
ExpandedProgramPoint
>
{
fn
idx
(
pp
:
ExpandedProgramPoint
)
-
>
usize
{
match
pp
{
ExpandedProgramPoint
:
:
Inst
(
i
)
=
>
i
.
index
(
)
ExpandedProgramPoint
:
:
Block
(
e
)
=
>
e
.
index
(
)
}
}
let
ia
=
idx
(
a
.
into
(
)
)
;
let
ib
=
idx
(
b
.
into
(
)
)
;
ia
.
cmp
(
&
ib
)
}
fn
is_block_gap
(
&
self
inst
:
Inst
block
:
Block
)
-
>
bool
{
inst
.
index
(
)
%
10
=
=
1
&
&
block
.
index
(
)
/
10
=
=
inst
.
index
(
)
/
10
+
1
}
}
impl
ProgOrder
{
fn
inst_block
(
&
self
inst
:
Inst
)
-
>
Block
{
let
i
=
inst
.
index
(
)
;
Block
:
:
new
(
i
-
i
%
10
)
}
fn
pp_block
<
PP
:
Into
<
ExpandedProgramPoint
>
>
(
&
self
pp
:
PP
)
-
>
Block
{
match
pp
.
into
(
)
{
ExpandedProgramPoint
:
:
Inst
(
i
)
=
>
self
.
inst_block
(
i
)
ExpandedProgramPoint
:
:
Block
(
e
)
=
>
e
}
}
fn
validate
(
&
self
lr
:
&
GenericLiveRange
<
Self
>
)
{
let
def_block
=
self
.
pp_block
(
lr
.
def_begin
)
;
assert_eq
!
(
def_block
self
.
pp_block
(
lr
.
def_end
)
)
;
match
self
.
cmp
(
lr
.
def_begin
lr
.
def_end
)
{
Ordering
:
:
Equal
=
>
assert
!
(
lr
.
liveins
.
is_empty
(
)
)
Ordering
:
:
Greater
=
>
{
panic
!
(
"
Backwards
def
interval
:
{
}
-
{
}
"
lr
.
def_begin
lr
.
def_end
)
}
Ordering
:
:
Less
=
>
{
}
}
let
mut
prev_end
=
None
;
for
Interval
{
begin
end
}
in
lr
.
liveins
.
iter
(
)
{
let
begin
=
*
begin
;
let
end
=
*
end
;
assert_eq
!
(
self
.
cmp
(
begin
end
)
Ordering
:
:
Less
)
;
if
let
Some
(
e
)
=
prev_end
{
assert_eq
!
(
self
.
cmp
(
e
begin
)
Ordering
:
:
Less
)
;
}
assert
!
(
self
.
cmp
(
lr
.
def_end
begin
)
=
=
Ordering
:
:
Less
|
|
self
.
cmp
(
lr
.
def_begin
end
)
=
=
Ordering
:
:
Greater
"
Interval
can
'
t
overlap
the
def
block
"
)
;
prev_end
=
Some
(
end
)
;
}
}
}
const
PO
:
&
'
static
ProgOrder
=
&
ProgOrder
{
}
;
#
[
test
]
fn
dead_def_range
(
)
{
let
v0
=
Value
:
:
new
(
0
)
;
let
e0
=
Block
:
:
new
(
0
)
;
let
i1
=
Inst
:
:
new
(
1
)
;
let
i2
=
Inst
:
:
new
(
2
)
;
let
e2
=
Block
:
:
new
(
2
)
;
let
lr
=
GenericLiveRange
:
:
new
(
v0
i1
.
into
(
)
Default
:
:
default
(
)
)
;
assert
!
(
lr
.
is_dead
(
)
)
;
assert
!
(
lr
.
is_local
(
)
)
;
assert_eq
!
(
lr
.
def
(
)
i1
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
i1
.
into
(
)
)
;
assert_eq
!
(
lr
.
livein_local_end
(
e2
PO
)
None
)
;
PO
.
validate
(
&
lr
)
;
assert
!
(
lr
.
overlaps_def
(
i1
.
into
(
)
e0
PO
)
)
;
assert
!
(
!
lr
.
overlaps_def
(
i2
.
into
(
)
e0
PO
)
)
;
assert
!
(
!
lr
.
overlaps_def
(
e0
.
into
(
)
e0
PO
)
)
;
}
#
[
test
]
fn
dead_arg_range
(
)
{
let
v0
=
Value
:
:
new
(
0
)
;
let
e2
=
Block
:
:
new
(
2
)
;
let
lr
=
GenericLiveRange
:
:
new
(
v0
e2
.
into
(
)
Default
:
:
default
(
)
)
;
assert
!
(
lr
.
is_dead
(
)
)
;
assert
!
(
lr
.
is_local
(
)
)
;
assert_eq
!
(
lr
.
def
(
)
e2
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
e2
.
into
(
)
)
;
assert_eq
!
(
lr
.
livein_local_end
(
e2
PO
)
None
)
;
PO
.
validate
(
&
lr
)
;
}
#
[
test
]
fn
local_def
(
)
{
let
v0
=
Value
:
:
new
(
0
)
;
let
e10
=
Block
:
:
new
(
10
)
;
let
i11
=
Inst
:
:
new
(
11
)
;
let
i12
=
Inst
:
:
new
(
12
)
;
let
i13
=
Inst
:
:
new
(
13
)
;
let
mut
lr
=
GenericLiveRange
:
:
new
(
v0
i11
.
into
(
)
Default
:
:
default
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e10
i13
PO
)
false
)
;
PO
.
validate
(
&
lr
)
;
assert
!
(
!
lr
.
is_dead
(
)
)
;
assert
!
(
lr
.
is_local
(
)
)
;
assert_eq
!
(
lr
.
def
(
)
i11
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
i13
.
into
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e10
i12
PO
)
false
)
;
PO
.
validate
(
&
lr
)
;
assert_eq
!
(
lr
.
def
(
)
i11
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
i13
.
into
(
)
)
;
}
#
[
test
]
fn
local_arg
(
)
{
let
v0
=
Value
:
:
new
(
0
)
;
let
e10
=
Block
:
:
new
(
10
)
;
let
i11
=
Inst
:
:
new
(
11
)
;
let
i12
=
Inst
:
:
new
(
12
)
;
let
i13
=
Inst
:
:
new
(
13
)
;
let
mut
lr
=
GenericLiveRange
:
:
new
(
v0
e10
.
into
(
)
Default
:
:
default
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e10
i12
PO
)
false
)
;
PO
.
validate
(
&
lr
)
;
assert
!
(
!
lr
.
is_dead
(
)
)
;
assert
!
(
lr
.
is_local
(
)
)
;
assert_eq
!
(
lr
.
def
(
)
e10
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
i12
.
into
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e10
i11
PO
)
false
)
;
PO
.
validate
(
&
lr
)
;
assert_eq
!
(
lr
.
def
(
)
e10
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
i12
.
into
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e10
i13
PO
)
false
)
;
PO
.
validate
(
&
lr
)
;
assert_eq
!
(
lr
.
def
(
)
e10
.
into
(
)
)
;
assert_eq
!
(
lr
.
def_local_end
(
)
i13
.
into
(
)
)
;
}
#
[
test
]
fn
global_def
(
)
{
let
v0
=
Value
:
:
new
(
0
)
;
let
e10
=
Block
:
:
new
(
10
)
;
let
i11
=
Inst
:
:
new
(
11
)
;
let
i12
=
Inst
:
:
new
(
12
)
;
let
e20
=
Block
:
:
new
(
20
)
;
let
i21
=
Inst
:
:
new
(
21
)
;
let
i22
=
Inst
:
:
new
(
22
)
;
let
i23
=
Inst
:
:
new
(
23
)
;
let
mut
lr
=
GenericLiveRange
:
:
new
(
v0
i11
.
into
(
)
Default
:
:
default
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e10
i12
PO
)
false
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e20
i22
PO
)
true
)
;
PO
.
validate
(
&
lr
)
;
assert_eq
!
(
lr
.
livein_local_end
(
e20
PO
)
Some
(
i22
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e20
i21
PO
)
false
)
;
assert_eq
!
(
lr
.
livein_local_end
(
e20
PO
)
Some
(
i22
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e20
i23
PO
)
false
)
;
PO
.
validate
(
&
lr
)
;
assert_eq
!
(
lr
.
livein_local_end
(
e20
PO
)
Some
(
i23
)
)
;
}
#
[
test
]
fn
coalesce
(
)
{
let
v0
=
Value
:
:
new
(
0
)
;
let
i11
=
Inst
:
:
new
(
11
)
;
let
e20
=
Block
:
:
new
(
20
)
;
let
i21
=
Inst
:
:
new
(
21
)
;
let
e30
=
Block
:
:
new
(
30
)
;
let
i31
=
Inst
:
:
new
(
31
)
;
let
e40
=
Block
:
:
new
(
40
)
;
let
i41
=
Inst
:
:
new
(
41
)
;
let
mut
lr
=
GenericLiveRange
:
:
new
(
v0
i11
.
into
(
)
Default
:
:
default
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e30
i31
PO
)
true
)
;
assert_eq
!
(
lr
.
liveins
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
(
e30
i31
)
]
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e40
i41
PO
)
true
)
;
assert_eq
!
(
lr
.
liveins
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
(
e30
i41
)
]
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e20
i21
PO
)
true
)
;
assert_eq
!
(
lr
.
liveins
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
(
e20
i41
)
]
)
;
let
mut
lr
=
GenericLiveRange
:
:
new
(
v0
i11
.
into
(
)
Default
:
:
default
(
)
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e40
i41
PO
)
true
)
;
assert_eq
!
(
lr
.
liveins
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
(
e40
i41
)
]
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e20
i21
PO
)
true
)
;
assert_eq
!
(
lr
.
liveins
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
(
e20
i21
)
(
e40
i41
)
]
)
;
assert_eq
!
(
lr
.
extend_in_block
(
e30
i31
PO
)
true
)
;
assert_eq
!
(
lr
.
liveins
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
(
e20
i41
)
]
)
;
}
}
