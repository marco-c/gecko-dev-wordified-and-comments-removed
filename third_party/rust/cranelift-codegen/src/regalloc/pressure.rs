#
!
[
allow
(
dead_code
)
]
use
isa
:
:
registers
:
:
{
RegClass
RegClassMask
RegInfo
MAX_TRACKED_TOPRCS
}
;
use
regalloc
:
:
RegisterSet
;
use
std
:
:
cmp
:
:
min
;
use
std
:
:
fmt
;
use
std
:
:
iter
:
:
ExactSizeIterator
;
#
[
derive
(
Default
)
]
struct
TopRC
{
base_count
:
u32
transient_count
:
u32
limit
:
u32
width
:
u8
first_toprc
:
u8
num_toprcs
:
u8
}
impl
TopRC
{
fn
total_count
(
&
self
)
-
>
u32
{
self
.
base_count
+
self
.
transient_count
}
}
pub
struct
Pressure
{
aliased
:
RegClassMask
toprc
:
[
TopRC
;
MAX_TRACKED_TOPRCS
]
}
impl
Pressure
{
pub
fn
new
(
reginfo
:
&
RegInfo
usable
:
&
RegisterSet
)
-
>
Self
{
let
mut
p
=
Self
{
aliased
:
0
toprc
:
Default
:
:
default
(
)
}
;
for
bank
in
reginfo
.
banks
{
let
first
=
bank
.
first_toprc
;
let
num
=
bank
.
num_toprcs
;
if
bank
.
pressure_tracking
{
for
rc
in
&
mut
p
.
toprc
[
first
.
.
first
+
num
]
{
rc
.
first_toprc
=
first
as
u8
;
rc
.
num_toprcs
=
num
as
u8
;
}
if
num
>
1
{
p
.
aliased
|
=
(
(
1
<
<
num
)
-
1
)
<
<
first
;
}
}
else
{
for
rc
in
&
mut
p
.
toprc
[
first
.
.
min
(
first
+
num
MAX_TRACKED_TOPRCS
)
]
{
rc
.
first_toprc
=
!
0
;
rc
.
limit
=
!
0
;
}
}
}
for
(
toprc
rc
)
in
p
.
toprc
.
iter_mut
(
)
.
take_while
(
|
t
|
t
.
num_toprcs
>
0
)
.
zip
(
reginfo
.
classes
)
{
toprc
.
limit
=
usable
.
iter
(
rc
)
.
len
(
)
as
u32
;
toprc
.
width
=
rc
.
width
;
}
p
}
fn
check_avail
(
&
self
rc
:
RegClass
)
-
>
RegClassMask
{
let
entry
=
match
self
.
toprc
.
get
(
rc
.
toprc
as
usize
)
{
None
=
>
return
0
Some
(
e
)
=
>
e
}
;
let
mask
=
1
<
<
rc
.
toprc
;
if
(
self
.
aliased
&
mask
)
=
=
0
{
if
entry
.
total_count
(
)
<
entry
.
limit
{
0
}
else
{
mask
}
}
else
{
self
.
check_avail_aliased
(
entry
)
}
}
fn
check_avail_aliased
(
&
self
entry
:
&
TopRC
)
-
>
RegClassMask
{
let
first
=
usize
:
:
from
(
entry
.
first_toprc
)
;
let
num
=
usize
:
:
from
(
entry
.
num_toprcs
)
;
let
width
=
u32
:
:
from
(
entry
.
width
)
;
let
ulimit
=
entry
.
limit
*
width
;
let
mut
units
=
0
;
for
(
rc
rci
)
in
self
.
toprc
[
first
.
.
first
+
num
]
.
iter
(
)
.
zip
(
first
.
.
)
{
let
rcw
=
u32
:
:
from
(
rc
.
width
)
;
let
u
=
if
rcw
<
width
{
min
(
rc
.
total_count
(
)
*
width
rc
.
limit
*
rcw
)
}
else
{
rc
.
total_count
(
)
*
rcw
}
;
if
u
>
=
ulimit
{
return
1
<
<
rci
;
}
units
+
=
u
;
}
if
units
<
ulimit
{
0
}
else
{
(
(
1
<
<
num
)
-
1
)
<
<
first
}
}
pub
fn
take
(
&
mut
self
rc
:
RegClass
)
{
if
let
Some
(
t
)
=
self
.
toprc
.
get_mut
(
rc
.
toprc
as
usize
)
{
t
.
base_count
+
=
1
;
}
}
pub
fn
free
(
&
mut
self
rc
:
RegClass
)
{
if
let
Some
(
t
)
=
self
.
toprc
.
get_mut
(
rc
.
toprc
as
usize
)
{
t
.
base_count
-
=
1
;
}
}
pub
fn
reset
(
&
mut
self
)
{
for
e
in
&
mut
self
.
toprc
{
e
.
base_count
=
0
;
e
.
transient_count
=
0
;
}
}
pub
fn
take_transient
(
&
mut
self
rc
:
RegClass
)
-
>
Result
<
(
)
RegClassMask
>
{
let
mask
=
self
.
check_avail
(
rc
)
;
if
mask
=
=
0
{
if
let
Some
(
t
)
=
self
.
toprc
.
get_mut
(
rc
.
toprc
as
usize
)
{
t
.
transient_count
+
=
1
;
}
Ok
(
(
)
)
}
else
{
Err
(
mask
)
}
}
pub
fn
reset_transient
(
&
mut
self
)
{
for
e
in
&
mut
self
.
toprc
{
e
.
transient_count
=
0
;
}
}
pub
fn
preserve_transient
(
&
mut
self
)
{
for
e
in
&
mut
self
.
toprc
{
e
.
base_count
+
=
e
.
transient_count
;
e
.
transient_count
=
0
;
}
}
}
impl
fmt
:
:
Display
for
Pressure
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Pressure
[
"
)
?
;
for
rc
in
&
self
.
toprc
{
if
rc
.
limit
>
0
&
&
rc
.
limit
<
!
0
{
write
!
(
f
"
{
}
+
{
}
/
{
}
"
rc
.
base_count
rc
.
transient_count
rc
.
limit
)
?
;
}
}
write
!
(
f
"
]
"
)
}
}
#
[
cfg
(
test
)
]
#
[
cfg
(
build_arm32
)
]
mod
tests
{
use
super
:
:
Pressure
;
use
isa
:
:
{
RegClass
TargetIsa
}
;
use
regalloc
:
:
RegisterSet
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
str
:
:
FromStr
;
use
target_lexicon
;
fn
arm32
(
)
-
>
Option
<
Box
<
TargetIsa
>
>
{
use
isa
;
use
settings
;
let
shared_builder
=
settings
:
:
builder
(
)
;
let
shared_flags
=
settings
:
:
Flags
:
:
new
(
shared_builder
)
;
isa
:
:
lookup
(
triple
!
(
"
arm
"
)
)
.
ok
(
)
.
map
(
|
b
|
b
.
finish
(
shared_flags
)
)
}
fn
rc_by_name
(
isa
:
&
TargetIsa
name
:
&
str
)
-
>
RegClass
{
isa
.
register_info
(
)
.
classes
.
iter
(
)
.
find
(
|
rc
|
rc
.
name
=
=
name
)
.
expect
(
"
Can
'
t
find
named
register
class
.
"
)
}
#
[
test
]
fn
basic_counting
(
)
{
let
isa
=
arm32
(
)
.
expect
(
"
This
test
requires
arm32
support
"
)
;
let
isa
=
isa
.
borrow
(
)
;
let
gpr
=
rc_by_name
(
isa
"
GPR
"
)
;
let
s
=
rc_by_name
(
isa
"
S
"
)
;
let
reginfo
=
isa
.
register_info
(
)
;
let
regs
=
RegisterSet
:
:
new
(
)
;
let
mut
pressure
=
Pressure
:
:
new
(
&
reginfo
&
regs
)
;
let
mut
count
=
0
;
while
pressure
.
check_avail
(
gpr
)
=
=
0
{
pressure
.
take
(
gpr
)
;
count
+
=
1
;
}
assert_eq
!
(
count
16
)
;
assert_eq
!
(
pressure
.
check_avail
(
gpr
)
1
<
<
gpr
.
toprc
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
pressure
.
free
(
gpr
)
;
assert_eq
!
(
pressure
.
check_avail
(
gpr
)
0
)
;
pressure
.
take
(
gpr
)
;
assert_eq
!
(
pressure
.
check_avail
(
gpr
)
1
<
<
gpr
.
toprc
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
pressure
.
reset
(
)
;
assert_eq
!
(
pressure
.
check_avail
(
gpr
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
}
#
[
test
]
fn
arm_float_bank
(
)
{
let
isa
=
arm32
(
)
.
expect
(
"
This
test
requires
arm32
support
"
)
;
let
isa
=
isa
.
borrow
(
)
;
let
s
=
rc_by_name
(
isa
"
S
"
)
;
let
d
=
rc_by_name
(
isa
"
D
"
)
;
let
q
=
rc_by_name
(
isa
"
Q
"
)
;
let
reginfo
=
isa
.
register_info
(
)
;
let
regs
=
RegisterSet
:
:
new
(
)
;
let
mut
pressure
=
Pressure
:
:
new
(
&
reginfo
&
regs
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
q
)
0
)
;
pressure
.
take
(
s
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
q
)
0
)
;
pressure
.
take
(
d
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
q
)
0
)
;
pressure
.
take
(
q
)
;
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
q
)
0
)
;
for
_
in
1
.
.
16
{
pressure
.
take
(
s
)
;
}
assert_eq
!
(
pressure
.
check_avail
(
s
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
q
)
0
)
;
for
_
in
0
.
.
6
{
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
q
)
0
)
;
pressure
.
take
(
q
)
;
}
assert
!
(
pressure
.
check_avail
(
s
)
!
=
0
)
;
assert_eq
!
(
pressure
.
check_avail
(
d
)
0
)
;
assert
!
(
pressure
.
check_avail
(
q
)
!
=
0
)
;
}
}
