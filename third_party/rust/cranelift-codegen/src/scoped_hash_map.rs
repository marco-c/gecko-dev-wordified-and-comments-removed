use
fx
:
:
FxHashMap
;
use
std
:
:
collections
:
:
hash_map
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
mem
;
struct
Val
<
K
V
>
{
value
:
V
next_key
:
Option
<
K
>
depth
:
usize
}
pub
struct
OccupiedEntry
<
'
a
K
:
'
a
V
:
'
a
>
{
entry
:
hash_map
:
:
OccupiedEntry
<
'
a
K
Val
<
K
V
>
>
}
impl
<
'
a
K
V
>
OccupiedEntry
<
'
a
K
V
>
{
pub
fn
get
(
&
self
)
-
>
&
V
{
&
self
.
entry
.
get
(
)
.
value
}
}
pub
struct
VacantEntry
<
'
a
K
:
'
a
V
:
'
a
>
{
entry
:
hash_map
:
:
VacantEntry
<
'
a
K
Val
<
K
V
>
>
next_key
:
Option
<
K
>
depth
:
usize
}
impl
<
'
a
K
V
>
VacantEntry
<
'
a
K
V
>
{
pub
fn
insert
(
self
value
:
V
)
{
self
.
entry
.
insert
(
Val
{
value
next_key
:
self
.
next_key
depth
:
self
.
depth
}
)
;
}
}
pub
enum
Entry
<
'
a
K
:
'
a
V
:
'
a
>
{
Occupied
(
OccupiedEntry
<
'
a
K
V
>
)
Vacant
(
VacantEntry
<
'
a
K
V
>
)
}
pub
struct
ScopedHashMap
<
K
V
>
{
map
:
FxHashMap
<
K
Val
<
K
V
>
>
last_insert
:
Option
<
K
>
current_depth
:
usize
}
impl
<
K
V
>
ScopedHashMap
<
K
V
>
where
K
:
PartialEq
+
Eq
+
Hash
+
Clone
{
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
FxHashMap
(
)
last_insert
:
None
current_depth
:
0
}
}
pub
fn
entry
(
&
mut
self
key
:
K
)
-
>
Entry
<
K
V
>
{
use
self
:
:
hash_map
:
:
Entry
:
:
*
;
match
self
.
map
.
entry
(
key
)
{
Occupied
(
entry
)
=
>
Entry
:
:
Occupied
(
OccupiedEntry
{
entry
}
)
Vacant
(
entry
)
=
>
{
let
clone_key
=
entry
.
key
(
)
.
clone
(
)
;
Entry
:
:
Vacant
(
VacantEntry
{
entry
next_key
:
mem
:
:
replace
(
&
mut
self
.
last_insert
Some
(
clone_key
)
)
depth
:
self
.
current_depth
}
)
}
}
}
pub
fn
increment_depth
(
&
mut
self
)
{
self
.
current_depth
=
self
.
current_depth
.
checked_add
(
1
)
.
unwrap
(
)
;
}
pub
fn
decrement_depth
(
&
mut
self
)
{
while
let
Some
(
key
)
=
self
.
last_insert
.
clone
(
)
{
use
self
:
:
hash_map
:
:
Entry
:
:
*
;
match
self
.
map
.
entry
(
key
)
{
Occupied
(
entry
)
=
>
{
if
entry
.
get
(
)
.
depth
!
=
self
.
current_depth
{
break
;
}
self
.
last_insert
=
entry
.
remove_entry
(
)
.
1
.
next_key
;
}
Vacant
(
_
)
=
>
panic
!
(
)
}
}
self
.
current_depth
=
self
.
current_depth
.
checked_sub
(
1
)
.
unwrap
(
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
basic
(
)
{
let
mut
map
:
ScopedHashMap
<
i32
i32
>
=
ScopedHashMap
:
:
new
(
)
;
match
map
.
entry
(
0
)
{
Entry
:
:
Occupied
(
_entry
)
=
>
panic
!
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
1
)
}
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
_entry
)
=
>
panic
!
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
8
)
}
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
map
.
increment_depth
(
)
;
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
_entry
)
=
>
panic
!
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
3
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
3
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
0
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
1
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
map
.
decrement_depth
(
)
;
match
map
.
entry
(
0
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
1
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
map
.
increment_depth
(
)
;
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
_entry
)
=
>
panic
!
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
4
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
4
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
map
.
decrement_depth
(
)
;
map
.
increment_depth
(
)
;
map
.
increment_depth
(
)
;
map
.
increment_depth
(
)
;
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
_entry
)
=
>
panic
!
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
5
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
5
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
map
.
decrement_depth
(
)
;
map
.
decrement_depth
(
)
;
map
.
decrement_depth
(
)
;
match
map
.
entry
(
2
)
{
Entry
:
:
Occupied
(
entry
)
=
>
assert
!
(
*
entry
.
get
(
)
=
=
8
)
Entry
:
:
Vacant
(
_entry
)
=
>
panic
!
(
)
}
match
map
.
entry
(
1
)
{
Entry
:
:
Occupied
(
_entry
)
=
>
panic
!
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
3
)
}
}
}
