pub
trait
Table
<
K
:
Copy
+
Eq
>
{
fn
len
(
&
self
)
-
>
usize
;
fn
key
(
&
self
idx
:
usize
)
-
>
Option
<
K
>
;
}
pub
fn
probe
<
K
:
Copy
+
Eq
T
:
Table
<
K
>
+
?
Sized
>
(
table
:
&
T
key
:
K
hash
:
usize
)
-
>
Result
<
usize
usize
>
{
debug_assert
!
(
table
.
len
(
)
.
is_power_of_two
(
)
)
;
let
mask
=
table
.
len
(
)
-
1
;
let
mut
idx
=
hash
;
let
mut
step
=
0
;
loop
{
idx
&
=
mask
;
match
table
.
key
(
idx
)
{
None
=
>
return
Err
(
idx
)
Some
(
k
)
if
k
=
=
key
=
>
return
Ok
(
idx
)
_
=
>
{
}
}
step
+
=
1
;
debug_assert
!
(
step
<
table
.
len
(
)
)
;
idx
+
=
step
;
}
}
pub
fn
simple_hash
(
s
:
&
str
)
-
>
usize
{
let
mut
h
:
u32
=
5381
;
for
c
in
s
.
chars
(
)
{
h
=
(
h
^
c
as
u32
)
.
wrapping_add
(
h
.
rotate_right
(
6
)
)
;
}
h
as
usize
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
simple_hash
;
#
[
test
]
fn
basic
(
)
{
assert_eq
!
(
simple_hash
(
"
Hello
"
)
0x2fa70c01
)
;
assert_eq
!
(
simple_hash
(
"
world
"
)
0x5b0c31d5
)
;
}
}
