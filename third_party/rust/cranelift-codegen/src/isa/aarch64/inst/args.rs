#
!
[
allow
(
dead_code
)
]
use
crate
:
:
binemit
:
:
CodeOffset
;
use
crate
:
:
ir
:
:
Type
;
use
crate
:
:
isa
:
:
aarch64
:
:
inst
:
:
*
;
use
crate
:
:
isa
:
:
aarch64
:
:
lower
:
:
ty_bits
;
use
regalloc
:
:
{
RealRegUniverse
Reg
Writable
}
;
use
core
:
:
convert
:
:
{
Into
TryFrom
}
;
use
std
:
:
string
:
:
String
;
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
repr
(
u8
)
]
pub
enum
ShiftOp
{
LSL
=
0b00
LSR
=
0b01
ASR
=
0b10
ROR
=
0b11
}
impl
ShiftOp
{
pub
fn
bits
(
self
)
-
>
u8
{
self
as
u8
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ShiftOpShiftImm
(
u8
)
;
impl
ShiftOpShiftImm
{
pub
const
MAX_SHIFT
:
u64
=
63
;
pub
fn
maybe_from_shift
(
shift
:
u64
)
-
>
Option
<
ShiftOpShiftImm
>
{
if
shift
<
=
Self
:
:
MAX_SHIFT
{
Some
(
ShiftOpShiftImm
(
shift
as
u8
)
)
}
else
{
None
}
}
pub
fn
value
(
self
)
-
>
u8
{
self
.
0
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ShiftOpAndAmt
{
op
:
ShiftOp
shift
:
ShiftOpShiftImm
}
impl
ShiftOpAndAmt
{
pub
fn
new
(
op
:
ShiftOp
shift
:
ShiftOpShiftImm
)
-
>
ShiftOpAndAmt
{
ShiftOpAndAmt
{
op
shift
}
}
pub
fn
op
(
&
self
)
-
>
ShiftOp
{
self
.
op
}
pub
fn
amt
(
&
self
)
-
>
ShiftOpShiftImm
{
self
.
shift
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
repr
(
u8
)
]
pub
enum
ExtendOp
{
UXTB
=
0b000
UXTH
=
0b001
UXTW
=
0b010
UXTX
=
0b011
SXTB
=
0b100
SXTH
=
0b101
SXTW
=
0b110
SXTX
=
0b111
}
impl
ExtendOp
{
pub
fn
bits
(
self
)
-
>
u8
{
self
as
u8
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
MemLabel
{
PCRel
(
i32
)
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
MemArg
{
Label
(
MemLabel
)
PostIndexed
(
Writable
<
Reg
>
SImm9
)
PreIndexed
(
Writable
<
Reg
>
SImm9
)
RegReg
(
Reg
Reg
)
RegScaled
(
Reg
Reg
Type
)
RegScaledExtended
(
Reg
Reg
Type
ExtendOp
)
Unscaled
(
Reg
SImm9
)
UnsignedOffset
(
Reg
UImm12Scaled
)
SPOffset
(
i64
)
FPOffset
(
i64
)
}
impl
MemArg
{
pub
fn
reg
(
reg
:
Reg
)
-
>
MemArg
{
MemArg
:
:
UnsignedOffset
(
reg
UImm12Scaled
:
:
zero
(
I64
)
)
}
pub
fn
reg_maybe_offset
(
reg
:
Reg
offset
:
i64
value_type
:
Type
)
-
>
Option
<
MemArg
>
{
if
let
Some
(
simm9
)
=
SImm9
:
:
maybe_from_i64
(
offset
)
{
Some
(
MemArg
:
:
Unscaled
(
reg
simm9
)
)
}
else
if
let
Some
(
uimm12s
)
=
UImm12Scaled
:
:
maybe_from_i64
(
offset
value_type
)
{
Some
(
MemArg
:
:
UnsignedOffset
(
reg
uimm12s
)
)
}
else
{
None
}
}
pub
fn
reg_plus_reg
(
reg1
:
Reg
reg2
:
Reg
)
-
>
MemArg
{
MemArg
:
:
RegReg
(
reg1
reg2
)
}
pub
fn
reg_plus_reg_scaled
(
reg1
:
Reg
reg2
:
Reg
ty
:
Type
)
-
>
MemArg
{
MemArg
:
:
RegScaled
(
reg1
reg2
ty
)
}
pub
fn
reg_plus_reg_scaled_extended
(
reg1
:
Reg
reg2
:
Reg
ty
:
Type
op
:
ExtendOp
)
-
>
MemArg
{
MemArg
:
:
RegScaledExtended
(
reg1
reg2
ty
op
)
}
pub
fn
label
(
label
:
MemLabel
)
-
>
MemArg
{
MemArg
:
:
Label
(
label
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
PairMemArg
{
SignedOffset
(
Reg
SImm7Scaled
)
PreIndexed
(
Writable
<
Reg
>
SImm7Scaled
)
PostIndexed
(
Writable
<
Reg
>
SImm7Scaled
)
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
#
[
repr
(
u8
)
]
pub
enum
Cond
{
Eq
=
0
Ne
=
1
Hs
=
2
Lo
=
3
Mi
=
4
Pl
=
5
Vs
=
6
Vc
=
7
Hi
=
8
Ls
=
9
Ge
=
10
Lt
=
11
Gt
=
12
Le
=
13
Al
=
14
Nv
=
15
}
impl
Cond
{
pub
fn
invert
(
self
)
-
>
Cond
{
match
self
{
Cond
:
:
Eq
=
>
Cond
:
:
Ne
Cond
:
:
Ne
=
>
Cond
:
:
Eq
Cond
:
:
Hs
=
>
Cond
:
:
Lo
Cond
:
:
Lo
=
>
Cond
:
:
Hs
Cond
:
:
Mi
=
>
Cond
:
:
Pl
Cond
:
:
Pl
=
>
Cond
:
:
Mi
Cond
:
:
Vs
=
>
Cond
:
:
Vc
Cond
:
:
Vc
=
>
Cond
:
:
Vs
Cond
:
:
Hi
=
>
Cond
:
:
Ls
Cond
:
:
Ls
=
>
Cond
:
:
Hi
Cond
:
:
Ge
=
>
Cond
:
:
Lt
Cond
:
:
Lt
=
>
Cond
:
:
Ge
Cond
:
:
Gt
=
>
Cond
:
:
Le
Cond
:
:
Le
=
>
Cond
:
:
Gt
Cond
:
:
Al
=
>
Cond
:
:
Nv
Cond
:
:
Nv
=
>
Cond
:
:
Al
}
}
pub
fn
bits
(
self
)
-
>
u32
{
self
as
u32
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
CondBrKind
{
Zero
(
Reg
)
NotZero
(
Reg
)
Cond
(
Cond
)
}
impl
CondBrKind
{
pub
fn
invert
(
self
)
-
>
CondBrKind
{
match
self
{
CondBrKind
:
:
Zero
(
reg
)
=
>
CondBrKind
:
:
NotZero
(
reg
)
CondBrKind
:
:
NotZero
(
reg
)
=
>
CondBrKind
:
:
Zero
(
reg
)
CondBrKind
:
:
Cond
(
c
)
=
>
CondBrKind
:
:
Cond
(
c
.
invert
(
)
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
BranchTarget
{
Block
(
BlockIndex
)
ResolvedOffset
(
isize
)
}
impl
BranchTarget
{
pub
fn
lower
(
&
mut
self
targets
:
&
[
CodeOffset
]
my_offset
:
CodeOffset
)
{
match
self
{
&
mut
BranchTarget
:
:
Block
(
bix
)
=
>
{
let
bix
=
usize
:
:
try_from
(
bix
)
.
unwrap
(
)
;
assert
!
(
bix
<
targets
.
len
(
)
)
;
let
block_offset_in_func
=
targets
[
bix
]
;
let
branch_offset
=
(
block_offset_in_func
as
isize
)
-
(
my_offset
as
isize
)
;
*
self
=
BranchTarget
:
:
ResolvedOffset
(
branch_offset
)
;
}
&
mut
BranchTarget
:
:
ResolvedOffset
(
.
.
)
=
>
{
}
}
}
pub
fn
as_block_index
(
&
self
)
-
>
Option
<
BlockIndex
>
{
match
self
{
&
BranchTarget
:
:
Block
(
bix
)
=
>
Some
(
bix
)
_
=
>
None
}
}
pub
fn
as_offset_words
(
&
self
)
-
>
isize
{
match
self
{
&
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
off
>
>
2
_
=
>
0
}
}
pub
fn
as_off26
(
&
self
)
-
>
Option
<
u32
>
{
let
off
=
self
.
as_offset_words
(
)
;
if
(
off
<
(
1
<
<
25
)
)
&
&
(
off
>
=
-
(
1
<
<
25
)
)
{
Some
(
(
off
as
u32
)
&
(
(
1
<
<
26
)
-
1
)
)
}
else
{
None
}
}
pub
fn
as_off19
(
&
self
)
-
>
Option
<
u32
>
{
let
off
=
self
.
as_offset_words
(
)
;
if
(
off
<
(
1
<
<
18
)
)
&
&
(
off
>
=
-
(
1
<
<
18
)
)
{
Some
(
(
off
as
u32
)
&
(
(
1
<
<
19
)
-
1
)
)
}
else
{
None
}
}
pub
fn
map
(
&
mut
self
block_index_map
:
&
[
BlockIndex
]
)
{
match
self
{
&
mut
BranchTarget
:
:
Block
(
ref
mut
bix
)
=
>
{
let
n
=
block_index_map
[
usize
:
:
try_from
(
*
bix
)
.
unwrap
(
)
]
;
*
bix
=
n
;
}
&
mut
BranchTarget
:
:
ResolvedOffset
(
_
)
=
>
{
}
}
}
}
impl
ShowWithRRU
for
ShiftOpAndAmt
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
{
:
?
}
{
}
"
self
.
op
(
)
self
.
amt
(
)
.
value
(
)
)
}
}
impl
ShowWithRRU
for
ExtendOp
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
{
:
?
}
"
self
)
}
}
impl
ShowWithRRU
for
MemLabel
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
MemLabel
:
:
PCRel
(
off
)
=
>
format
!
(
"
pc
+
{
}
"
off
)
}
}
}
fn
shift_for_type
(
ty
:
Type
)
-
>
usize
{
match
ty
.
bytes
(
)
{
1
=
>
0
2
=
>
1
4
=
>
2
8
=
>
3
16
=
>
4
_
=
>
panic
!
(
"
unknown
type
:
{
}
"
ty
)
}
}
impl
ShowWithRRU
for
MemArg
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
MemArg
:
:
Unscaled
(
reg
simm9
)
=
>
{
if
simm9
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
MemArg
:
:
UnsignedOffset
(
reg
uimm12
)
=
>
{
if
uimm12
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
uimm12
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
MemArg
:
:
RegReg
(
r1
r2
)
=
>
{
format
!
(
"
[
{
}
{
}
]
"
r1
.
show_rru
(
mb_rru
)
r2
.
show_rru
(
mb_rru
)
)
}
&
MemArg
:
:
RegScaled
(
r1
r2
ty
)
=
>
{
let
shift
=
shift_for_type
(
ty
)
;
format
!
(
"
[
{
}
{
}
LSL
#
{
}
]
"
r1
.
show_rru
(
mb_rru
)
r2
.
show_rru
(
mb_rru
)
shift
)
}
&
MemArg
:
:
RegScaledExtended
(
r1
r2
ty
op
)
=
>
{
let
shift
=
shift_for_type
(
ty
)
;
let
size
=
match
op
{
ExtendOp
:
:
SXTW
|
ExtendOp
:
:
UXTW
=
>
InstSize
:
:
Size32
_
=
>
InstSize
:
:
Size64
}
;
let
op
=
op
.
show_rru
(
mb_rru
)
;
format
!
(
"
[
{
}
{
}
{
}
#
{
}
]
"
r1
.
show_rru
(
mb_rru
)
show_ireg_sized
(
r2
mb_rru
size
)
op
shift
)
}
&
MemArg
:
:
Label
(
ref
label
)
=
>
label
.
show_rru
(
mb_rru
)
&
MemArg
:
:
PreIndexed
(
r
simm9
)
=
>
format
!
(
"
[
{
}
{
}
]
!
"
r
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
&
MemArg
:
:
PostIndexed
(
r
simm9
)
=
>
format
!
(
"
[
{
}
]
{
}
"
r
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
&
MemArg
:
:
SPOffset
(
.
.
)
|
&
MemArg
:
:
FPOffset
(
.
.
)
=
>
{
panic
!
(
"
Unexpected
stack
-
offset
mem
-
arg
mode
!
"
)
}
}
}
}
impl
ShowWithRRU
for
PairMemArg
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
PairMemArg
:
:
SignedOffset
(
reg
simm7
)
=
>
{
if
simm7
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
PairMemArg
:
:
PreIndexed
(
reg
simm7
)
=
>
format
!
(
"
[
{
}
{
}
]
!
"
reg
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
&
PairMemArg
:
:
PostIndexed
(
reg
simm7
)
=
>
format
!
(
"
[
{
}
]
{
}
"
reg
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
}
}
}
impl
ShowWithRRU
for
Cond
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
let
mut
s
=
format
!
(
"
{
:
?
}
"
self
)
;
s
.
make_ascii_lowercase
(
)
;
s
}
}
impl
ShowWithRRU
for
BranchTarget
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
BranchTarget
:
:
Block
(
block
)
=
>
format
!
(
"
block
{
}
"
block
)
&
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
format
!
(
"
{
}
"
off
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
InstSize
{
Size32
Size64
}
impl
InstSize
{
pub
fn
is32
(
self
)
-
>
bool
{
self
=
=
InstSize
:
:
Size32
}
pub
fn
is64
(
self
)
-
>
bool
{
self
=
=
InstSize
:
:
Size64
}
pub
fn
from_is32
(
is32
:
bool
)
-
>
InstSize
{
if
is32
{
InstSize
:
:
Size32
}
else
{
InstSize
:
:
Size64
}
}
pub
fn
from_bits
<
I
:
Into
<
usize
>
>
(
bits
:
I
)
-
>
InstSize
{
let
bits
:
usize
=
bits
.
into
(
)
;
assert
!
(
bits
<
=
64
)
;
if
bits
<
=
32
{
InstSize
:
:
Size32
}
else
{
InstSize
:
:
Size64
}
}
pub
fn
from_ty
(
ty
:
Type
)
-
>
InstSize
{
Self
:
:
from_bits
(
ty_bits
(
ty
)
)
}
pub
fn
to_ty
(
self
)
-
>
Type
{
match
self
{
InstSize
:
:
Size32
=
>
I32
InstSize
:
:
Size64
=
>
I64
}
}
pub
fn
sf_bit
(
&
self
)
-
>
u32
{
match
self
{
InstSize
:
:
Size32
=
>
0
InstSize
:
:
Size64
=
>
1
}
}
}
