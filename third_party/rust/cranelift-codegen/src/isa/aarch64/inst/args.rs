#
!
[
allow
(
dead_code
)
]
use
crate
:
:
ir
:
:
types
:
:
{
F32X2
F32X4
F64X2
I16X4
I16X8
I32X2
I32X4
I64X2
I8X16
I8X8
}
;
use
crate
:
:
ir
:
:
Type
;
use
crate
:
:
isa
:
:
aarch64
:
:
inst
:
:
*
;
use
crate
:
:
machinst
:
:
{
ty_bits
MachLabel
}
;
use
regalloc
:
:
{
RealRegUniverse
Reg
Writable
}
;
use
core
:
:
convert
:
:
Into
;
use
std
:
:
string
:
:
String
;
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
repr
(
u8
)
]
pub
enum
ShiftOp
{
LSL
=
0b00
LSR
=
0b01
ASR
=
0b10
ROR
=
0b11
}
impl
ShiftOp
{
pub
fn
bits
(
self
)
-
>
u8
{
self
as
u8
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ShiftOpShiftImm
(
u8
)
;
impl
ShiftOpShiftImm
{
pub
const
MAX_SHIFT
:
u64
=
63
;
pub
fn
maybe_from_shift
(
shift
:
u64
)
-
>
Option
<
ShiftOpShiftImm
>
{
if
shift
<
=
Self
:
:
MAX_SHIFT
{
Some
(
ShiftOpShiftImm
(
shift
as
u8
)
)
}
else
{
None
}
}
pub
fn
value
(
self
)
-
>
u8
{
self
.
0
}
pub
fn
mask
(
self
bits
:
u8
)
-
>
ShiftOpShiftImm
{
ShiftOpShiftImm
(
self
.
0
&
(
bits
-
1
)
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ShiftOpAndAmt
{
op
:
ShiftOp
shift
:
ShiftOpShiftImm
}
impl
ShiftOpAndAmt
{
pub
fn
new
(
op
:
ShiftOp
shift
:
ShiftOpShiftImm
)
-
>
ShiftOpAndAmt
{
ShiftOpAndAmt
{
op
shift
}
}
pub
fn
op
(
&
self
)
-
>
ShiftOp
{
self
.
op
}
pub
fn
amt
(
&
self
)
-
>
ShiftOpShiftImm
{
self
.
shift
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
repr
(
u8
)
]
pub
enum
ExtendOp
{
UXTB
=
0b000
UXTH
=
0b001
UXTW
=
0b010
UXTX
=
0b011
SXTB
=
0b100
SXTH
=
0b101
SXTW
=
0b110
SXTX
=
0b111
}
impl
ExtendOp
{
pub
fn
bits
(
self
)
-
>
u8
{
self
as
u8
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
MemLabel
{
PCRel
(
i32
)
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
AMode
{
PostIndexed
(
Writable
<
Reg
>
SImm9
)
PreIndexed
(
Writable
<
Reg
>
SImm9
)
RegReg
(
Reg
Reg
)
RegScaled
(
Reg
Reg
Type
)
RegScaledExtended
(
Reg
Reg
Type
ExtendOp
)
RegExtended
(
Reg
Reg
ExtendOp
)
Unscaled
(
Reg
SImm9
)
UnsignedOffset
(
Reg
UImm12Scaled
)
Label
(
MemLabel
)
RegOffset
(
Reg
i64
Type
)
SPOffset
(
i64
Type
)
FPOffset
(
i64
Type
)
NominalSPOffset
(
i64
Type
)
}
impl
AMode
{
pub
fn
reg
(
reg
:
Reg
)
-
>
AMode
{
AMode
:
:
UnsignedOffset
(
reg
UImm12Scaled
:
:
zero
(
I64
)
)
}
pub
fn
reg_plus_reg
(
reg1
:
Reg
reg2
:
Reg
)
-
>
AMode
{
AMode
:
:
RegReg
(
reg1
reg2
)
}
pub
fn
reg_plus_reg_scaled
(
reg1
:
Reg
reg2
:
Reg
ty
:
Type
)
-
>
AMode
{
AMode
:
:
RegScaled
(
reg1
reg2
ty
)
}
pub
fn
reg_plus_reg_scaled_extended
(
reg1
:
Reg
reg2
:
Reg
ty
:
Type
op
:
ExtendOp
)
-
>
AMode
{
AMode
:
:
RegScaledExtended
(
reg1
reg2
ty
op
)
}
pub
fn
label
(
label
:
MemLabel
)
-
>
AMode
{
AMode
:
:
Label
(
label
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
PairAMode
{
SignedOffset
(
Reg
SImm7Scaled
)
PreIndexed
(
Writable
<
Reg
>
SImm7Scaled
)
PostIndexed
(
Writable
<
Reg
>
SImm7Scaled
)
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
#
[
repr
(
u8
)
]
pub
enum
Cond
{
Eq
=
0
Ne
=
1
Hs
=
2
Lo
=
3
Mi
=
4
Pl
=
5
Vs
=
6
Vc
=
7
Hi
=
8
Ls
=
9
Ge
=
10
Lt
=
11
Gt
=
12
Le
=
13
Al
=
14
Nv
=
15
}
impl
Cond
{
pub
fn
invert
(
self
)
-
>
Cond
{
match
self
{
Cond
:
:
Eq
=
>
Cond
:
:
Ne
Cond
:
:
Ne
=
>
Cond
:
:
Eq
Cond
:
:
Hs
=
>
Cond
:
:
Lo
Cond
:
:
Lo
=
>
Cond
:
:
Hs
Cond
:
:
Mi
=
>
Cond
:
:
Pl
Cond
:
:
Pl
=
>
Cond
:
:
Mi
Cond
:
:
Vs
=
>
Cond
:
:
Vc
Cond
:
:
Vc
=
>
Cond
:
:
Vs
Cond
:
:
Hi
=
>
Cond
:
:
Ls
Cond
:
:
Ls
=
>
Cond
:
:
Hi
Cond
:
:
Ge
=
>
Cond
:
:
Lt
Cond
:
:
Lt
=
>
Cond
:
:
Ge
Cond
:
:
Gt
=
>
Cond
:
:
Le
Cond
:
:
Le
=
>
Cond
:
:
Gt
Cond
:
:
Al
=
>
Cond
:
:
Nv
Cond
:
:
Nv
=
>
Cond
:
:
Al
}
}
pub
fn
bits
(
self
)
-
>
u32
{
self
as
u32
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
CondBrKind
{
Zero
(
Reg
)
NotZero
(
Reg
)
Cond
(
Cond
)
}
impl
CondBrKind
{
pub
fn
invert
(
self
)
-
>
CondBrKind
{
match
self
{
CondBrKind
:
:
Zero
(
reg
)
=
>
CondBrKind
:
:
NotZero
(
reg
)
CondBrKind
:
:
NotZero
(
reg
)
=
>
CondBrKind
:
:
Zero
(
reg
)
CondBrKind
:
:
Cond
(
c
)
=
>
CondBrKind
:
:
Cond
(
c
.
invert
(
)
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
BranchTarget
{
Label
(
MachLabel
)
ResolvedOffset
(
i32
)
}
impl
BranchTarget
{
pub
fn
as_label
(
self
)
-
>
Option
<
MachLabel
>
{
match
self
{
BranchTarget
:
:
Label
(
l
)
=
>
Some
(
l
)
_
=
>
None
}
}
pub
fn
as_offset19_or_zero
(
self
)
-
>
u32
{
let
off
=
match
self
{
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
off
>
>
2
_
=
>
0
}
;
assert
!
(
off
<
=
0x3ffff
)
;
assert
!
(
off
>
=
-
0x40000
)
;
(
off
as
u32
)
&
0x7ffff
}
pub
fn
as_offset26_or_zero
(
self
)
-
>
u32
{
let
off
=
match
self
{
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
off
>
>
2
_
=
>
0
}
;
assert
!
(
off
<
=
0x1ffffff
)
;
assert
!
(
off
>
=
-
0x2000000
)
;
(
off
as
u32
)
&
0x3ffffff
}
}
impl
ShowWithRRU
for
ShiftOpAndAmt
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
{
:
?
}
{
}
"
self
.
op
(
)
self
.
amt
(
)
.
value
(
)
)
}
}
impl
ShowWithRRU
for
ExtendOp
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
{
:
?
}
"
self
)
}
}
impl
ShowWithRRU
for
MemLabel
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
MemLabel
:
:
PCRel
(
off
)
=
>
format
!
(
"
pc
+
{
}
"
off
)
}
}
}
fn
shift_for_type
(
ty
:
Type
)
-
>
usize
{
match
ty
.
bytes
(
)
{
1
=
>
0
2
=
>
1
4
=
>
2
8
=
>
3
16
=
>
4
_
=
>
panic
!
(
"
unknown
type
:
{
}
"
ty
)
}
}
impl
ShowWithRRU
for
AMode
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
AMode
:
:
Unscaled
(
reg
simm9
)
=
>
{
if
simm9
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
AMode
:
:
UnsignedOffset
(
reg
uimm12
)
=
>
{
if
uimm12
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
uimm12
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
AMode
:
:
RegReg
(
r1
r2
)
=
>
{
format
!
(
"
[
{
}
{
}
]
"
r1
.
show_rru
(
mb_rru
)
r2
.
show_rru
(
mb_rru
)
)
}
&
AMode
:
:
RegScaled
(
r1
r2
ty
)
=
>
{
let
shift
=
shift_for_type
(
ty
)
;
format
!
(
"
[
{
}
{
}
LSL
#
{
}
]
"
r1
.
show_rru
(
mb_rru
)
r2
.
show_rru
(
mb_rru
)
shift
)
}
&
AMode
:
:
RegScaledExtended
(
r1
r2
ty
op
)
=
>
{
let
shift
=
shift_for_type
(
ty
)
;
let
size
=
match
op
{
ExtendOp
:
:
SXTW
|
ExtendOp
:
:
UXTW
=
>
OperandSize
:
:
Size32
_
=
>
OperandSize
:
:
Size64
}
;
let
op
=
op
.
show_rru
(
mb_rru
)
;
format
!
(
"
[
{
}
{
}
{
}
#
{
}
]
"
r1
.
show_rru
(
mb_rru
)
show_ireg_sized
(
r2
mb_rru
size
)
op
shift
)
}
&
AMode
:
:
RegExtended
(
r1
r2
op
)
=
>
{
let
size
=
match
op
{
ExtendOp
:
:
SXTW
|
ExtendOp
:
:
UXTW
=
>
OperandSize
:
:
Size32
_
=
>
OperandSize
:
:
Size64
}
;
let
op
=
op
.
show_rru
(
mb_rru
)
;
format
!
(
"
[
{
}
{
}
{
}
]
"
r1
.
show_rru
(
mb_rru
)
show_ireg_sized
(
r2
mb_rru
size
)
op
)
}
&
AMode
:
:
Label
(
ref
label
)
=
>
label
.
show_rru
(
mb_rru
)
&
AMode
:
:
PreIndexed
(
r
simm9
)
=
>
format
!
(
"
[
{
}
{
}
]
!
"
r
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
&
AMode
:
:
PostIndexed
(
r
simm9
)
=
>
format
!
(
"
[
{
}
]
{
}
"
r
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
&
AMode
:
:
SPOffset
(
.
.
)
|
&
AMode
:
:
FPOffset
(
.
.
)
|
&
AMode
:
:
NominalSPOffset
(
.
.
)
|
&
AMode
:
:
RegOffset
(
.
.
)
=
>
{
panic
!
(
"
Unexpected
pseudo
mem
-
arg
mode
(
stack
-
offset
or
generic
reg
-
offset
)
!
"
)
}
}
}
}
impl
ShowWithRRU
for
PairAMode
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
PairAMode
:
:
SignedOffset
(
reg
simm7
)
=
>
{
if
simm7
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
PairAMode
:
:
PreIndexed
(
reg
simm7
)
=
>
format
!
(
"
[
{
}
{
}
]
!
"
reg
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
&
PairAMode
:
:
PostIndexed
(
reg
simm7
)
=
>
format
!
(
"
[
{
}
]
{
}
"
reg
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
}
}
}
impl
ShowWithRRU
for
Cond
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
let
mut
s
=
format
!
(
"
{
:
?
}
"
self
)
;
s
.
make_ascii_lowercase
(
)
;
s
}
}
impl
ShowWithRRU
for
BranchTarget
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
BranchTarget
:
:
Label
(
label
)
=
>
format
!
(
"
label
{
:
?
}
"
label
.
get
(
)
)
&
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
format
!
(
"
{
}
"
off
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
OperandSize
{
Size32
Size64
}
impl
OperandSize
{
pub
fn
is32
(
self
)
-
>
bool
{
self
=
=
OperandSize
:
:
Size32
}
pub
fn
is64
(
self
)
-
>
bool
{
self
=
=
OperandSize
:
:
Size64
}
pub
fn
from_is32
(
is32
:
bool
)
-
>
OperandSize
{
if
is32
{
OperandSize
:
:
Size32
}
else
{
OperandSize
:
:
Size64
}
}
pub
fn
from_bits
<
I
:
Into
<
usize
>
>
(
bits
:
I
)
-
>
OperandSize
{
let
bits
:
usize
=
bits
.
into
(
)
;
assert
!
(
bits
<
=
64
)
;
if
bits
<
=
32
{
OperandSize
:
:
Size32
}
else
{
OperandSize
:
:
Size64
}
}
pub
fn
from_ty
(
ty
:
Type
)
-
>
OperandSize
{
Self
:
:
from_bits
(
ty_bits
(
ty
)
)
}
pub
fn
to_ty
(
self
)
-
>
Type
{
match
self
{
OperandSize
:
:
Size32
=
>
I32
OperandSize
:
:
Size64
=
>
I64
}
}
pub
fn
sf_bit
(
&
self
)
-
>
u32
{
match
self
{
OperandSize
:
:
Size32
=
>
0
OperandSize
:
:
Size64
=
>
1
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
ScalarSize
{
Size8
Size16
Size32
Size64
Size128
}
impl
ScalarSize
{
pub
fn
from_bits
<
I
:
Into
<
usize
>
>
(
bits
:
I
)
-
>
ScalarSize
{
match
bits
.
into
(
)
.
next_power_of_two
(
)
{
8
=
>
ScalarSize
:
:
Size8
16
=
>
ScalarSize
:
:
Size16
32
=
>
ScalarSize
:
:
Size32
64
=
>
ScalarSize
:
:
Size64
128
=
>
ScalarSize
:
:
Size128
w
=
>
panic
!
(
"
Unexpected
type
width
:
{
}
"
w
)
}
}
pub
fn
from_ty
(
ty
:
Type
)
-
>
ScalarSize
{
Self
:
:
from_bits
(
ty_bits
(
ty
)
)
}
pub
fn
ftype
(
&
self
)
-
>
u32
{
match
self
{
ScalarSize
:
:
Size16
=
>
0b11
ScalarSize
:
:
Size32
=
>
0b00
ScalarSize
:
:
Size64
=
>
0b01
_
=
>
panic
!
(
"
Unexpected
scalar
FP
operand
size
:
{
:
?
}
"
self
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
VectorSize
{
Size8x8
Size8x16
Size16x4
Size16x8
Size32x2
Size32x4
Size64x2
}
impl
VectorSize
{
pub
fn
from_ty
(
ty
:
Type
)
-
>
VectorSize
{
match
ty
{
B32X4
=
>
VectorSize
:
:
Size32x4
F32X2
=
>
VectorSize
:
:
Size32x2
F32X4
=
>
VectorSize
:
:
Size32x4
F64X2
=
>
VectorSize
:
:
Size64x2
I8X8
=
>
VectorSize
:
:
Size8x8
I8X16
=
>
VectorSize
:
:
Size8x16
I16X4
=
>
VectorSize
:
:
Size16x4
I16X8
=
>
VectorSize
:
:
Size16x8
I32X2
=
>
VectorSize
:
:
Size32x2
I32X4
=
>
VectorSize
:
:
Size32x4
I64X2
=
>
VectorSize
:
:
Size64x2
_
=
>
unimplemented
!
(
"
Unsupported
type
:
{
}
"
ty
)
}
}
pub
fn
operand_size
(
&
self
)
-
>
OperandSize
{
match
self
{
VectorSize
:
:
Size64x2
=
>
OperandSize
:
:
Size64
_
=
>
OperandSize
:
:
Size32
}
}
pub
fn
lane_size
(
&
self
)
-
>
ScalarSize
{
match
self
{
VectorSize
:
:
Size8x8
=
>
ScalarSize
:
:
Size8
VectorSize
:
:
Size8x16
=
>
ScalarSize
:
:
Size8
VectorSize
:
:
Size16x4
=
>
ScalarSize
:
:
Size16
VectorSize
:
:
Size16x8
=
>
ScalarSize
:
:
Size16
VectorSize
:
:
Size32x2
=
>
ScalarSize
:
:
Size32
VectorSize
:
:
Size32x4
=
>
ScalarSize
:
:
Size32
VectorSize
:
:
Size64x2
=
>
ScalarSize
:
:
Size64
}
}
pub
fn
is_128bits
(
&
self
)
-
>
bool
{
match
self
{
VectorSize
:
:
Size8x8
=
>
false
VectorSize
:
:
Size8x16
=
>
true
VectorSize
:
:
Size16x4
=
>
false
VectorSize
:
:
Size16x8
=
>
true
VectorSize
:
:
Size32x2
=
>
false
VectorSize
:
:
Size32x4
=
>
true
VectorSize
:
:
Size64x2
=
>
true
}
}
pub
fn
widen
(
&
self
)
-
>
VectorSize
{
match
self
{
VectorSize
:
:
Size8x8
=
>
VectorSize
:
:
Size16x8
VectorSize
:
:
Size8x16
=
>
VectorSize
:
:
Size16x8
VectorSize
:
:
Size16x4
=
>
VectorSize
:
:
Size32x4
VectorSize
:
:
Size16x8
=
>
VectorSize
:
:
Size32x4
VectorSize
:
:
Size32x2
=
>
VectorSize
:
:
Size64x2
VectorSize
:
:
Size32x4
=
>
VectorSize
:
:
Size64x2
VectorSize
:
:
Size64x2
=
>
unreachable
!
(
)
}
}
pub
fn
halve
(
&
self
)
-
>
VectorSize
{
match
self
{
VectorSize
:
:
Size8x16
=
>
VectorSize
:
:
Size8x8
VectorSize
:
:
Size16x8
=
>
VectorSize
:
:
Size16x4
VectorSize
:
:
Size32x4
=
>
VectorSize
:
:
Size32x2
_
=
>
*
self
}
}
}
