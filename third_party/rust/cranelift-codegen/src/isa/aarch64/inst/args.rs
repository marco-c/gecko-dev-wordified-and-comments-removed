#
!
[
allow
(
dead_code
)
]
use
crate
:
:
ir
:
:
Type
;
use
crate
:
:
isa
:
:
aarch64
:
:
inst
:
:
*
;
use
crate
:
:
isa
:
:
aarch64
:
:
lower
:
:
ty_bits
;
use
crate
:
:
machinst
:
:
MachLabel
;
use
regalloc
:
:
{
RealRegUniverse
Reg
Writable
}
;
use
core
:
:
convert
:
:
Into
;
use
std
:
:
string
:
:
String
;
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
repr
(
u8
)
]
pub
enum
ShiftOp
{
LSL
=
0b00
LSR
=
0b01
ASR
=
0b10
ROR
=
0b11
}
impl
ShiftOp
{
pub
fn
bits
(
self
)
-
>
u8
{
self
as
u8
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ShiftOpShiftImm
(
u8
)
;
impl
ShiftOpShiftImm
{
pub
const
MAX_SHIFT
:
u64
=
63
;
pub
fn
maybe_from_shift
(
shift
:
u64
)
-
>
Option
<
ShiftOpShiftImm
>
{
if
shift
<
=
Self
:
:
MAX_SHIFT
{
Some
(
ShiftOpShiftImm
(
shift
as
u8
)
)
}
else
{
None
}
}
pub
fn
value
(
self
)
-
>
u8
{
self
.
0
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ShiftOpAndAmt
{
op
:
ShiftOp
shift
:
ShiftOpShiftImm
}
impl
ShiftOpAndAmt
{
pub
fn
new
(
op
:
ShiftOp
shift
:
ShiftOpShiftImm
)
-
>
ShiftOpAndAmt
{
ShiftOpAndAmt
{
op
shift
}
}
pub
fn
op
(
&
self
)
-
>
ShiftOp
{
self
.
op
}
pub
fn
amt
(
&
self
)
-
>
ShiftOpShiftImm
{
self
.
shift
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
repr
(
u8
)
]
pub
enum
ExtendOp
{
UXTB
=
0b000
UXTH
=
0b001
UXTW
=
0b010
UXTX
=
0b011
SXTB
=
0b100
SXTH
=
0b101
SXTW
=
0b110
SXTX
=
0b111
}
impl
ExtendOp
{
pub
fn
bits
(
self
)
-
>
u8
{
self
as
u8
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
MemLabel
{
PCRel
(
i32
)
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
MemArg
{
PostIndexed
(
Writable
<
Reg
>
SImm9
)
PreIndexed
(
Writable
<
Reg
>
SImm9
)
RegReg
(
Reg
Reg
)
RegScaled
(
Reg
Reg
Type
)
RegScaledExtended
(
Reg
Reg
Type
ExtendOp
)
RegExtended
(
Reg
Reg
ExtendOp
)
Unscaled
(
Reg
SImm9
)
UnsignedOffset
(
Reg
UImm12Scaled
)
Label
(
MemLabel
)
RegOffset
(
Reg
i64
Type
)
SPOffset
(
i64
Type
)
FPOffset
(
i64
Type
)
NominalSPOffset
(
i64
Type
)
}
impl
MemArg
{
pub
fn
reg
(
reg
:
Reg
)
-
>
MemArg
{
MemArg
:
:
UnsignedOffset
(
reg
UImm12Scaled
:
:
zero
(
I64
)
)
}
pub
fn
reg_plus_reg
(
reg1
:
Reg
reg2
:
Reg
)
-
>
MemArg
{
MemArg
:
:
RegReg
(
reg1
reg2
)
}
pub
fn
reg_plus_reg_scaled
(
reg1
:
Reg
reg2
:
Reg
ty
:
Type
)
-
>
MemArg
{
MemArg
:
:
RegScaled
(
reg1
reg2
ty
)
}
pub
fn
reg_plus_reg_scaled_extended
(
reg1
:
Reg
reg2
:
Reg
ty
:
Type
op
:
ExtendOp
)
-
>
MemArg
{
MemArg
:
:
RegScaledExtended
(
reg1
reg2
ty
op
)
}
pub
fn
label
(
label
:
MemLabel
)
-
>
MemArg
{
MemArg
:
:
Label
(
label
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
PairMemArg
{
SignedOffset
(
Reg
SImm7Scaled
)
PreIndexed
(
Writable
<
Reg
>
SImm7Scaled
)
PostIndexed
(
Writable
<
Reg
>
SImm7Scaled
)
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
#
[
repr
(
u8
)
]
pub
enum
Cond
{
Eq
=
0
Ne
=
1
Hs
=
2
Lo
=
3
Mi
=
4
Pl
=
5
Vs
=
6
Vc
=
7
Hi
=
8
Ls
=
9
Ge
=
10
Lt
=
11
Gt
=
12
Le
=
13
Al
=
14
Nv
=
15
}
impl
Cond
{
pub
fn
invert
(
self
)
-
>
Cond
{
match
self
{
Cond
:
:
Eq
=
>
Cond
:
:
Ne
Cond
:
:
Ne
=
>
Cond
:
:
Eq
Cond
:
:
Hs
=
>
Cond
:
:
Lo
Cond
:
:
Lo
=
>
Cond
:
:
Hs
Cond
:
:
Mi
=
>
Cond
:
:
Pl
Cond
:
:
Pl
=
>
Cond
:
:
Mi
Cond
:
:
Vs
=
>
Cond
:
:
Vc
Cond
:
:
Vc
=
>
Cond
:
:
Vs
Cond
:
:
Hi
=
>
Cond
:
:
Ls
Cond
:
:
Ls
=
>
Cond
:
:
Hi
Cond
:
:
Ge
=
>
Cond
:
:
Lt
Cond
:
:
Lt
=
>
Cond
:
:
Ge
Cond
:
:
Gt
=
>
Cond
:
:
Le
Cond
:
:
Le
=
>
Cond
:
:
Gt
Cond
:
:
Al
=
>
Cond
:
:
Nv
Cond
:
:
Nv
=
>
Cond
:
:
Al
}
}
pub
fn
bits
(
self
)
-
>
u32
{
self
as
u32
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
CondBrKind
{
Zero
(
Reg
)
NotZero
(
Reg
)
Cond
(
Cond
)
}
impl
CondBrKind
{
pub
fn
invert
(
self
)
-
>
CondBrKind
{
match
self
{
CondBrKind
:
:
Zero
(
reg
)
=
>
CondBrKind
:
:
NotZero
(
reg
)
CondBrKind
:
:
NotZero
(
reg
)
=
>
CondBrKind
:
:
Zero
(
reg
)
CondBrKind
:
:
Cond
(
c
)
=
>
CondBrKind
:
:
Cond
(
c
.
invert
(
)
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
BranchTarget
{
Label
(
MachLabel
)
ResolvedOffset
(
i32
)
}
impl
BranchTarget
{
pub
fn
as_label
(
self
)
-
>
Option
<
MachLabel
>
{
match
self
{
BranchTarget
:
:
Label
(
l
)
=
>
Some
(
l
)
_
=
>
None
}
}
pub
fn
as_offset19_or_zero
(
self
)
-
>
u32
{
let
off
=
match
self
{
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
off
>
>
2
_
=
>
0
}
;
assert
!
(
off
<
=
0x3ffff
)
;
assert
!
(
off
>
=
-
0x40000
)
;
(
off
as
u32
)
&
0x7ffff
}
pub
fn
as_offset26_or_zero
(
self
)
-
>
u32
{
let
off
=
match
self
{
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
off
>
>
2
_
=
>
0
}
;
assert
!
(
off
<
=
0x1ffffff
)
;
assert
!
(
off
>
=
-
0x2000000
)
;
(
off
as
u32
)
&
0x3ffffff
}
}
impl
ShowWithRRU
for
ShiftOpAndAmt
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
{
:
?
}
{
}
"
self
.
op
(
)
self
.
amt
(
)
.
value
(
)
)
}
}
impl
ShowWithRRU
for
ExtendOp
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
{
:
?
}
"
self
)
}
}
impl
ShowWithRRU
for
MemLabel
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
MemLabel
:
:
PCRel
(
off
)
=
>
format
!
(
"
pc
+
{
}
"
off
)
}
}
}
fn
shift_for_type
(
ty
:
Type
)
-
>
usize
{
match
ty
.
bytes
(
)
{
1
=
>
0
2
=
>
1
4
=
>
2
8
=
>
3
16
=
>
4
_
=
>
panic
!
(
"
unknown
type
:
{
}
"
ty
)
}
}
impl
ShowWithRRU
for
MemArg
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
MemArg
:
:
Unscaled
(
reg
simm9
)
=
>
{
if
simm9
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
MemArg
:
:
UnsignedOffset
(
reg
uimm12
)
=
>
{
if
uimm12
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
uimm12
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
MemArg
:
:
RegReg
(
r1
r2
)
=
>
{
format
!
(
"
[
{
}
{
}
]
"
r1
.
show_rru
(
mb_rru
)
r2
.
show_rru
(
mb_rru
)
)
}
&
MemArg
:
:
RegScaled
(
r1
r2
ty
)
=
>
{
let
shift
=
shift_for_type
(
ty
)
;
format
!
(
"
[
{
}
{
}
LSL
#
{
}
]
"
r1
.
show_rru
(
mb_rru
)
r2
.
show_rru
(
mb_rru
)
shift
)
}
&
MemArg
:
:
RegScaledExtended
(
r1
r2
ty
op
)
=
>
{
let
shift
=
shift_for_type
(
ty
)
;
let
size
=
match
op
{
ExtendOp
:
:
SXTW
|
ExtendOp
:
:
UXTW
=
>
InstSize
:
:
Size32
_
=
>
InstSize
:
:
Size64
}
;
let
op
=
op
.
show_rru
(
mb_rru
)
;
format
!
(
"
[
{
}
{
}
{
}
#
{
}
]
"
r1
.
show_rru
(
mb_rru
)
show_ireg_sized
(
r2
mb_rru
size
)
op
shift
)
}
&
MemArg
:
:
RegExtended
(
r1
r2
op
)
=
>
{
let
size
=
match
op
{
ExtendOp
:
:
SXTW
|
ExtendOp
:
:
UXTW
=
>
InstSize
:
:
Size32
_
=
>
InstSize
:
:
Size64
}
;
let
op
=
op
.
show_rru
(
mb_rru
)
;
format
!
(
"
[
{
}
{
}
{
}
]
"
r1
.
show_rru
(
mb_rru
)
show_ireg_sized
(
r2
mb_rru
size
)
op
)
}
&
MemArg
:
:
Label
(
ref
label
)
=
>
label
.
show_rru
(
mb_rru
)
&
MemArg
:
:
PreIndexed
(
r
simm9
)
=
>
format
!
(
"
[
{
}
{
}
]
!
"
r
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
&
MemArg
:
:
PostIndexed
(
r
simm9
)
=
>
format
!
(
"
[
{
}
]
{
}
"
r
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm9
.
show_rru
(
mb_rru
)
)
&
MemArg
:
:
SPOffset
(
.
.
)
|
&
MemArg
:
:
FPOffset
(
.
.
)
|
&
MemArg
:
:
NominalSPOffset
(
.
.
)
|
&
MemArg
:
:
RegOffset
(
.
.
)
=
>
{
panic
!
(
"
Unexpected
pseudo
mem
-
arg
mode
(
stack
-
offset
or
generic
reg
-
offset
)
!
"
)
}
}
}
}
impl
ShowWithRRU
for
PairMemArg
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
PairMemArg
:
:
SignedOffset
(
reg
simm7
)
=
>
{
if
simm7
.
value
!
=
0
{
format
!
(
"
[
{
}
{
}
]
"
reg
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
}
else
{
format
!
(
"
[
{
}
]
"
reg
.
show_rru
(
mb_rru
)
)
}
}
&
PairMemArg
:
:
PreIndexed
(
reg
simm7
)
=
>
format
!
(
"
[
{
}
{
}
]
!
"
reg
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
&
PairMemArg
:
:
PostIndexed
(
reg
simm7
)
=
>
format
!
(
"
[
{
}
]
{
}
"
reg
.
to_reg
(
)
.
show_rru
(
mb_rru
)
simm7
.
show_rru
(
mb_rru
)
)
}
}
}
impl
ShowWithRRU
for
Cond
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
let
mut
s
=
format
!
(
"
{
:
?
}
"
self
)
;
s
.
make_ascii_lowercase
(
)
;
s
}
}
impl
ShowWithRRU
for
BranchTarget
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
&
BranchTarget
:
:
Label
(
label
)
=
>
format
!
(
"
label
{
:
?
}
"
label
.
get
(
)
)
&
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
format
!
(
"
{
}
"
off
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
InstSize
{
Size32
Size64
Size128
}
impl
InstSize
{
pub
fn
is32
(
self
)
-
>
bool
{
self
=
=
InstSize
:
:
Size32
}
pub
fn
is64
(
self
)
-
>
bool
{
self
=
=
InstSize
:
:
Size64
}
pub
fn
from_is32
(
is32
:
bool
)
-
>
InstSize
{
if
is32
{
InstSize
:
:
Size32
}
else
{
InstSize
:
:
Size64
}
}
pub
fn
from_bits
<
I
:
Into
<
usize
>
>
(
bits
:
I
)
-
>
InstSize
{
let
bits
:
usize
=
bits
.
into
(
)
;
assert
!
(
bits
<
=
128
)
;
if
bits
<
=
32
{
InstSize
:
:
Size32
}
else
if
bits
<
=
64
{
InstSize
:
:
Size64
}
else
{
InstSize
:
:
Size128
}
}
pub
fn
from_ty
(
ty
:
Type
)
-
>
InstSize
{
Self
:
:
from_bits
(
ty_bits
(
ty
)
)
}
pub
fn
to_ty
(
self
)
-
>
Type
{
match
self
{
InstSize
:
:
Size32
=
>
I32
InstSize
:
:
Size64
=
>
I64
InstSize
:
:
Size128
=
>
I128
}
}
pub
fn
sf_bit
(
&
self
)
-
>
u32
{
match
self
{
InstSize
:
:
Size32
=
>
0
InstSize
:
:
Size64
=
>
1
_
=
>
{
panic
!
(
"
Unexpected
size
"
)
;
}
}
}
}
