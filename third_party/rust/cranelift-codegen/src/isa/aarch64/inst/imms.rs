#
[
allow
(
dead_code
)
]
use
crate
:
:
ir
:
:
types
:
:
*
;
use
crate
:
:
ir
:
:
Type
;
use
crate
:
:
isa
:
:
aarch64
:
:
inst
:
:
{
OperandSize
ScalarSize
}
;
use
regalloc
:
:
{
PrettyPrint
RealRegUniverse
}
;
use
core
:
:
convert
:
:
TryFrom
;
use
std
:
:
string
:
:
String
;
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
NZCV
{
n
:
bool
z
:
bool
c
:
bool
v
:
bool
}
impl
NZCV
{
pub
fn
new
(
n
:
bool
z
:
bool
c
:
bool
v
:
bool
)
-
>
NZCV
{
NZCV
{
n
z
c
v
}
}
pub
fn
bits
(
&
self
)
-
>
u32
{
(
u32
:
:
from
(
self
.
n
)
<
<
3
)
|
(
u32
:
:
from
(
self
.
z
)
<
<
2
)
|
(
u32
:
:
from
(
self
.
c
)
<
<
1
)
|
u32
:
:
from
(
self
.
v
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
UImm5
{
value
:
u8
}
impl
UImm5
{
pub
fn
maybe_from_u8
(
value
:
u8
)
-
>
Option
<
UImm5
>
{
if
value
<
32
{
Some
(
UImm5
{
value
}
)
}
else
{
None
}
}
pub
fn
bits
(
&
self
)
-
>
u32
{
u32
:
:
from
(
self
.
value
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
SImm7Scaled
{
pub
value
:
i16
pub
scale_ty
:
Type
}
impl
SImm7Scaled
{
pub
fn
maybe_from_i64
(
value
:
i64
scale_ty
:
Type
)
-
>
Option
<
SImm7Scaled
>
{
assert
!
(
scale_ty
=
=
I64
|
|
scale_ty
=
=
I32
)
;
let
scale
=
scale_ty
.
bytes
(
)
;
assert
!
(
scale
.
is_power_of_two
(
)
)
;
let
scale
=
i64
:
:
from
(
scale
)
;
let
upper_limit
=
63
*
scale
;
let
lower_limit
=
-
(
64
*
scale
)
;
if
value
>
=
lower_limit
&
&
value
<
=
upper_limit
&
&
(
value
&
(
scale
-
1
)
)
=
=
0
{
Some
(
SImm7Scaled
{
value
:
i16
:
:
try_from
(
value
)
.
unwrap
(
)
scale_ty
}
)
}
else
{
None
}
}
pub
fn
zero
(
scale_ty
:
Type
)
-
>
SImm7Scaled
{
SImm7Scaled
{
value
:
0
scale_ty
}
}
pub
fn
bits
(
&
self
)
-
>
u32
{
let
ty_bytes
:
i16
=
self
.
scale_ty
.
bytes
(
)
as
i16
;
let
scaled
:
i16
=
self
.
value
/
ty_bytes
;
assert
!
(
scaled
<
=
63
&
&
scaled
>
=
-
64
)
;
let
scaled
:
i8
=
scaled
as
i8
;
let
encoded
:
u32
=
scaled
as
u32
;
encoded
&
0x7f
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
FPULeftShiftImm
{
pub
amount
:
u8
pub
lane_size_in_bits
:
u8
}
impl
FPULeftShiftImm
{
pub
fn
maybe_from_u8
(
amount
:
u8
lane_size_in_bits
:
u8
)
-
>
Option
<
Self
>
{
debug_assert
!
(
lane_size_in_bits
=
=
32
|
|
lane_size_in_bits
=
=
64
)
;
if
amount
<
lane_size_in_bits
{
Some
(
Self
{
amount
lane_size_in_bits
}
)
}
else
{
None
}
}
pub
fn
enc
(
&
self
)
-
>
u32
{
debug_assert
!
(
self
.
lane_size_in_bits
.
is_power_of_two
(
)
)
;
debug_assert
!
(
self
.
lane_size_in_bits
>
self
.
amount
)
;
u32
:
:
from
(
self
.
lane_size_in_bits
|
self
.
amount
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
FPURightShiftImm
{
pub
amount
:
u8
pub
lane_size_in_bits
:
u8
}
impl
FPURightShiftImm
{
pub
fn
maybe_from_u8
(
amount
:
u8
lane_size_in_bits
:
u8
)
-
>
Option
<
Self
>
{
debug_assert
!
(
lane_size_in_bits
=
=
32
|
|
lane_size_in_bits
=
=
64
)
;
if
amount
>
0
&
&
amount
<
=
lane_size_in_bits
{
Some
(
Self
{
amount
lane_size_in_bits
}
)
}
else
{
None
}
}
pub
fn
enc
(
&
self
)
-
>
u32
{
debug_assert_ne
!
(
0
self
.
amount
)
;
u32
:
:
from
(
(
self
.
lane_size_in_bits
*
2
)
-
self
.
amount
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
SImm9
{
pub
value
:
i16
}
impl
SImm9
{
pub
fn
maybe_from_i64
(
value
:
i64
)
-
>
Option
<
SImm9
>
{
if
value
>
=
-
256
&
&
value
<
=
255
{
Some
(
SImm9
{
value
:
value
as
i16
}
)
}
else
{
None
}
}
pub
fn
zero
(
)
-
>
SImm9
{
SImm9
{
value
:
0
}
}
pub
fn
bits
(
&
self
)
-
>
u32
{
(
self
.
value
as
u32
)
&
0x1ff
}
pub
fn
value
(
&
self
)
-
>
i32
{
self
.
value
as
i32
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
UImm12Scaled
{
pub
value
:
u16
pub
scale_ty
:
Type
}
impl
UImm12Scaled
{
pub
fn
maybe_from_i64
(
value
:
i64
scale_ty
:
Type
)
-
>
Option
<
UImm12Scaled
>
{
let
scale_ty
=
if
scale_ty
=
=
B1
{
B8
}
else
{
scale_ty
}
;
let
scale
=
scale_ty
.
bytes
(
)
;
assert
!
(
scale
.
is_power_of_two
(
)
)
;
let
scale
=
scale
as
i64
;
let
limit
=
4095
*
scale
;
if
value
>
=
0
&
&
value
<
=
limit
&
&
(
value
&
(
scale
-
1
)
)
=
=
0
{
Some
(
UImm12Scaled
{
value
:
value
as
u16
scale_ty
}
)
}
else
{
None
}
}
pub
fn
zero
(
scale_ty
:
Type
)
-
>
UImm12Scaled
{
UImm12Scaled
{
value
:
0
scale_ty
}
}
pub
fn
bits
(
&
self
)
-
>
u32
{
(
self
.
value
as
u32
/
self
.
scale_ty
.
bytes
(
)
)
&
0xfff
}
pub
fn
value
(
&
self
)
-
>
u32
{
self
.
value
as
u32
}
pub
fn
scale_ty
(
&
self
)
-
>
Type
{
self
.
scale_ty
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Imm12
{
pub
bits
:
u16
pub
shift12
:
bool
}
impl
Imm12
{
pub
fn
maybe_from_u64
(
val
:
u64
)
-
>
Option
<
Imm12
>
{
if
val
=
=
0
{
Some
(
Imm12
{
bits
:
0
shift12
:
false
}
)
}
else
if
val
<
0xfff
{
Some
(
Imm12
{
bits
:
val
as
u16
shift12
:
false
}
)
}
else
if
val
<
0xfff_000
&
&
(
val
&
0xfff
=
=
0
)
{
Some
(
Imm12
{
bits
:
(
val
>
>
12
)
as
u16
shift12
:
true
}
)
}
else
{
None
}
}
pub
fn
zero
(
)
-
>
Self
{
Imm12
{
bits
:
0
shift12
:
false
}
}
pub
fn
shift_bits
(
&
self
)
-
>
u32
{
if
self
.
shift12
{
0b01
}
else
{
0b00
}
}
pub
fn
imm_bits
(
&
self
)
-
>
u32
{
self
.
bits
as
u32
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
ImmLogic
{
value
:
u64
pub
n
:
bool
pub
r
:
u8
pub
s
:
u8
pub
size
:
OperandSize
}
impl
ImmLogic
{
pub
fn
maybe_from_u64
(
value
:
u64
ty
:
Type
)
-
>
Option
<
ImmLogic
>
{
if
ty
!
=
I64
&
&
ty
!
=
I32
{
return
None
;
}
let
operand_size
=
OperandSize
:
:
from_ty
(
ty
)
;
let
original_value
=
value
;
let
value
=
if
ty
=
=
I32
{
let
value
=
value
<
<
32
;
value
|
value
>
>
32
}
else
{
value
}
;
let
(
value
inverted
)
=
if
value
&
1
=
=
1
{
(
!
value
true
)
}
else
{
(
value
false
)
}
;
if
value
=
=
0
{
return
None
;
}
fn
lowest_set_bit
(
value
:
u64
)
-
>
u64
{
let
bit
=
value
.
trailing_zeros
(
)
;
1u64
.
checked_shl
(
bit
)
.
unwrap_or
(
0
)
}
let
a
=
lowest_set_bit
(
value
)
;
assert_ne
!
(
0
a
)
;
let
value_plus_a
=
value
.
wrapping_add
(
a
)
;
let
b
=
lowest_set_bit
(
value_plus_a
)
;
let
value_plus_a_minus_b
=
value_plus_a
-
b
;
let
c
=
lowest_set_bit
(
value_plus_a_minus_b
)
;
let
(
d
clz_a
out_n
mask
)
=
if
c
!
=
0
{
let
clz_a
=
a
.
leading_zeros
(
)
;
let
clz_c
=
c
.
leading_zeros
(
)
;
let
d
=
clz_a
-
clz_c
;
let
mask
=
(
1
<
<
d
)
-
1
;
(
d
clz_a
0
mask
)
}
else
{
(
64
a
.
leading_zeros
(
)
1
u64
:
:
max_value
(
)
)
}
;
if
!
d
.
is_power_of_two
(
)
{
return
None
;
}
if
(
(
b
.
wrapping_sub
(
a
)
)
&
!
mask
)
!
=
0
{
return
None
;
}
const
MULTIPLIERS
:
[
u64
;
6
]
=
[
0x0000000000000001
0x0000000100000001
0x0001000100010001
0x0101010101010101
0x1111111111111111
0x5555555555555555
]
;
let
multiplier
=
MULTIPLIERS
[
(
u64
:
:
from
(
d
)
.
leading_zeros
(
)
-
57
)
as
usize
]
;
let
candidate
=
b
.
wrapping_sub
(
a
)
*
multiplier
;
if
value
!
=
candidate
{
return
None
;
}
let
clz_b
=
if
b
=
=
0
{
u32
:
:
max_value
(
)
}
else
{
b
.
leading_zeros
(
)
}
;
let
s
=
clz_a
.
wrapping_sub
(
clz_b
)
;
let
(
s
r
)
=
if
inverted
{
(
d
-
s
clz_b
.
wrapping_add
(
1
)
&
(
d
-
1
)
)
}
else
{
(
s
(
clz_a
+
1
)
&
(
d
-
1
)
)
}
;
let
s
=
(
(
d
*
2
)
.
wrapping_neg
(
)
|
(
s
-
1
)
)
&
0x3f
;
debug_assert
!
(
u8
:
:
try_from
(
r
)
.
is_ok
(
)
)
;
debug_assert
!
(
u8
:
:
try_from
(
s
)
.
is_ok
(
)
)
;
Some
(
ImmLogic
{
value
:
original_value
n
:
out_n
!
=
0
r
:
r
as
u8
s
:
s
as
u8
size
:
operand_size
}
)
}
pub
fn
enc_bits
(
&
self
)
-
>
u32
{
(
(
self
.
n
as
u32
)
<
<
12
)
|
(
(
self
.
r
as
u32
)
<
<
6
)
|
(
self
.
s
as
u32
)
}
pub
fn
value
(
&
self
)
-
>
u64
{
self
.
value
}
pub
fn
invert
(
&
self
)
-
>
ImmLogic
{
Self
:
:
maybe_from_u64
(
!
self
.
value
self
.
size
.
to_ty
(
)
)
.
unwrap
(
)
}
pub
fn
from_n_r_s
(
value_to_check
:
u64
n
:
bool
r
:
u8
s
:
u8
size
:
OperandSize
)
-
>
Self
{
let
imml
=
Self
{
value
:
value_to_check
n
r
s
size
}
;
debug_assert
!
(
match
ImmLogic
:
:
maybe_from_u64
(
value_to_check
if
size
=
=
OperandSize
:
:
Size64
{
I64
}
else
{
I32
}
)
{
None
=
>
false
/
/
fail
:
value
is
unrepresentable
Some
(
imml_check
)
=
>
imml_check
=
=
imml
}
)
;
imml
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ImmShift
{
pub
imm
:
u8
}
impl
ImmShift
{
pub
fn
maybe_from_u64
(
val
:
u64
)
-
>
Option
<
ImmShift
>
{
if
val
<
64
{
Some
(
ImmShift
{
imm
:
val
as
u8
}
)
}
else
{
None
}
}
pub
fn
value
(
&
self
)
-
>
u8
{
self
.
imm
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
MoveWideConst
{
pub
bits
:
u16
pub
shift
:
u8
}
impl
MoveWideConst
{
pub
fn
maybe_from_u64
(
value
:
u64
)
-
>
Option
<
MoveWideConst
>
{
let
mask0
=
0x0000_0000_0000_ffffu64
;
let
mask1
=
0x0000_0000_ffff_0000u64
;
let
mask2
=
0x0000_ffff_0000_0000u64
;
let
mask3
=
0xffff_0000_0000_0000u64
;
if
value
=
=
(
value
&
mask0
)
{
return
Some
(
MoveWideConst
{
bits
:
(
value
&
mask0
)
as
u16
shift
:
0
}
)
;
}
if
value
=
=
(
value
&
mask1
)
{
return
Some
(
MoveWideConst
{
bits
:
(
(
value
>
>
16
)
&
mask0
)
as
u16
shift
:
1
}
)
;
}
if
value
=
=
(
value
&
mask2
)
{
return
Some
(
MoveWideConst
{
bits
:
(
(
value
>
>
32
)
&
mask0
)
as
u16
shift
:
2
}
)
;
}
if
value
=
=
(
value
&
mask3
)
{
return
Some
(
MoveWideConst
{
bits
:
(
(
value
>
>
48
)
&
mask0
)
as
u16
shift
:
3
}
)
;
}
None
}
pub
fn
maybe_with_shift
(
imm
:
u16
shift
:
u8
)
-
>
Option
<
MoveWideConst
>
{
let
shift_enc
=
shift
/
16
;
if
shift_enc
>
3
{
None
}
else
{
Some
(
MoveWideConst
{
bits
:
imm
shift
:
shift_enc
}
)
}
}
pub
fn
value
(
&
self
)
-
>
u64
{
(
self
.
bits
as
u64
)
<
<
(
16
*
self
.
shift
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ASIMDMovModImm
{
imm
:
u8
shift
:
u8
shift_ones
:
bool
}
impl
ASIMDMovModImm
{
pub
fn
maybe_from_u64
(
value
:
u64
size
:
ScalarSize
)
-
>
Option
<
ASIMDMovModImm
>
{
match
size
{
ScalarSize
:
:
Size8
=
>
Some
(
ASIMDMovModImm
{
imm
:
value
as
u8
shift
:
0
shift_ones
:
false
}
)
_
=
>
None
}
}
pub
fn
zero
(
)
-
>
Self
{
ASIMDMovModImm
{
imm
:
0
shift
:
0
shift_ones
:
false
}
}
pub
fn
value
(
&
self
)
-
>
(
u8
u32
bool
)
{
(
self
.
imm
self
.
shift
as
u32
self
.
shift_ones
)
}
}
impl
PrettyPrint
for
NZCV
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
let
fmt
=
|
c
:
char
v
|
if
v
{
c
.
to_ascii_uppercase
(
)
}
else
{
c
}
;
format
!
(
"
#
{
}
{
}
{
}
{
}
"
fmt
(
'
n
'
self
.
n
)
fmt
(
'
z
'
self
.
z
)
fmt
(
'
c
'
self
.
c
)
fmt
(
'
v
'
self
.
v
)
)
}
}
impl
PrettyPrint
for
UImm5
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
value
)
}
}
impl
PrettyPrint
for
Imm12
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
let
shift
=
if
self
.
shift12
{
12
}
else
{
0
}
;
let
value
=
u32
:
:
from
(
self
.
bits
)
<
<
shift
;
format
!
(
"
#
{
}
"
value
)
}
}
impl
PrettyPrint
for
SImm7Scaled
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
value
)
}
}
impl
PrettyPrint
for
FPULeftShiftImm
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
amount
)
}
}
impl
PrettyPrint
for
FPURightShiftImm
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
amount
)
}
}
impl
PrettyPrint
for
SImm9
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
value
)
}
}
impl
PrettyPrint
for
UImm12Scaled
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
value
)
}
}
impl
PrettyPrint
for
ImmLogic
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
value
(
)
)
}
}
impl
PrettyPrint
for
ImmShift
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
format
!
(
"
#
{
}
"
self
.
imm
)
}
}
impl
PrettyPrint
for
MoveWideConst
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
if
self
.
shift
=
=
0
{
format
!
(
"
#
{
}
"
self
.
bits
)
}
else
{
format
!
(
"
#
{
}
LSL
#
{
}
"
self
.
bits
self
.
shift
*
16
)
}
}
}
impl
PrettyPrint
for
ASIMDMovModImm
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
if
self
.
shift
=
=
0
{
format
!
(
"
#
{
}
"
self
.
imm
)
}
else
{
let
shift_type
=
if
self
.
shift_ones
{
"
MSL
"
}
else
{
"
LSL
"
}
;
format
!
(
"
#
{
}
{
}
#
{
}
"
self
.
imm
shift_type
self
.
shift
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
imm_logical_test
(
)
{
assert_eq
!
(
None
ImmLogic
:
:
maybe_from_u64
(
0
I64
)
)
;
assert_eq
!
(
None
ImmLogic
:
:
maybe_from_u64
(
u64
:
:
max_value
(
)
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
1
n
:
true
r
:
0
s
:
0
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
1
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
2
n
:
true
r
:
63
s
:
0
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
2
I64
)
)
;
assert_eq
!
(
None
ImmLogic
:
:
maybe_from_u64
(
5
I64
)
)
;
assert_eq
!
(
None
ImmLogic
:
:
maybe_from_u64
(
11
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
248
n
:
true
r
:
61
s
:
4
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
248
I64
)
)
;
assert_eq
!
(
None
ImmLogic
:
:
maybe_from_u64
(
249
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
1920
n
:
true
r
:
57
s
:
3
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
1920
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0x7ffe
n
:
true
r
:
63
s
:
13
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0x7ffe
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0x30000
n
:
true
r
:
48
s
:
1
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0x30000
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0x100000
n
:
true
r
:
44
s
:
0
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0x100000
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
u64
:
:
max_value
(
)
-
1
n
:
true
r
:
63
s
:
62
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
u64
:
:
max_value
(
)
-
1
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0xaaaaaaaaaaaaaaaa
n
:
false
r
:
1
s
:
60
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0xaaaaaaaaaaaaaaaa
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0x8181818181818181
n
:
false
r
:
1
s
:
49
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0x8181818181818181
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0xffc3ffc3ffc3ffc3
n
:
false
r
:
10
s
:
43
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0xffc3ffc3ffc3ffc3
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0x100000001
n
:
false
r
:
0
s
:
0
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0x100000001
I64
)
)
;
assert_eq
!
(
Some
(
ImmLogic
{
value
:
0x1111111111111111
n
:
false
r
:
0
s
:
56
size
:
OperandSize
:
:
Size64
}
)
ImmLogic
:
:
maybe_from_u64
(
0x1111111111111111
I64
)
)
;
for
n
in
0
.
.
2
{
let
types
=
if
n
=
=
0
{
vec
!
[
I64
I32
]
}
else
{
vec
!
[
I64
]
}
;
for
s
in
0
.
.
64
{
for
r
in
0
.
.
64
{
let
imm
=
get_logical_imm
(
n
s
r
)
;
for
&
ty
in
&
types
{
match
ImmLogic
:
:
maybe_from_u64
(
imm
ty
)
{
Some
(
ImmLogic
{
value
.
.
}
)
=
>
{
assert_eq
!
(
imm
value
)
;
ImmLogic
:
:
maybe_from_u64
(
!
value
ty
)
.
unwrap
(
)
;
}
None
=
>
assert_eq
!
(
0
imm
)
}
;
}
}
}
}
}
fn
repeat
(
value
:
u64
width
:
u64
)
-
>
u64
{
let
mut
result
=
value
&
(
(
1
<
<
width
)
-
1
)
;
let
mut
i
=
width
;
while
i
<
64
{
result
|
=
result
<
<
i
;
i
*
=
2
;
}
result
}
fn
get_logical_imm
(
n
:
u32
s
:
u32
r
:
u32
)
-
>
u64
{
if
n
=
=
1
{
if
s
=
=
0x3f
{
return
0
;
}
let
bits
=
(
1u64
<
<
(
s
+
1
)
)
-
1
;
bits
.
rotate_right
(
r
)
}
else
{
if
(
s
>
>
1
)
=
=
0x1f
{
return
0
;
}
let
mut
width
=
0x20
;
while
width
>
=
0x2
{
if
(
s
&
width
)
=
=
0
{
let
mask
=
width
-
1
;
if
(
s
&
mask
)
=
=
mask
{
return
0
;
}
let
bits
=
(
1u64
<
<
(
(
s
&
mask
)
+
1
)
)
-
1
;
return
repeat
(
bits
.
rotate_right
(
r
&
mask
)
width
.
into
(
)
)
;
}
width
>
>
=
1
;
}
unreachable
!
(
)
;
}
}
}
