use
crate
:
:
isa
:
:
{
unwind
:
:
input
RegUnit
}
;
use
crate
:
:
result
:
:
{
CodegenError
CodegenResult
}
;
use
alloc
:
:
vec
:
:
Vec
;
use
byteorder
:
:
{
ByteOrder
LittleEndian
}
;
use
log
:
:
warn
;
#
[
cfg
(
feature
=
"
enable
-
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
const
SMALL_ALLOC_MAX_SIZE
:
u32
=
128
;
const
LARGE_ALLOC_16BIT_MAX_SIZE
:
u32
=
524280
;
struct
Writer
<
'
a
>
{
buf
:
&
'
a
mut
[
u8
]
offset
:
usize
}
impl
<
'
a
>
Writer
<
'
a
>
{
pub
fn
new
(
buf
:
&
'
a
mut
[
u8
]
)
-
>
Self
{
Self
{
buf
offset
:
0
}
}
fn
write_u8
(
&
mut
self
v
:
u8
)
{
self
.
buf
[
self
.
offset
]
=
v
;
self
.
offset
+
=
1
;
}
fn
write_u16
<
T
:
ByteOrder
>
(
&
mut
self
v
:
u16
)
{
T
:
:
write_u16
(
&
mut
self
.
buf
[
self
.
offset
.
.
(
self
.
offset
+
2
)
]
v
)
;
self
.
offset
+
=
2
;
}
fn
write_u32
<
T
:
ByteOrder
>
(
&
mut
self
v
:
u32
)
{
T
:
:
write_u32
(
&
mut
self
.
buf
[
self
.
offset
.
.
(
self
.
offset
+
4
)
]
v
)
;
self
.
offset
+
=
4
;
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
(
crate
)
enum
UnwindCode
{
PushRegister
{
offset
:
u8
reg
:
u8
}
SaveXmm
{
offset
:
u8
reg
:
u8
stack_offset
:
u32
}
StackAlloc
{
offset
:
u8
size
:
u32
}
}
impl
UnwindCode
{
fn
emit
(
&
self
writer
:
&
mut
Writer
)
{
enum
UnwindOperation
{
PushNonvolatileRegister
=
0
LargeStackAlloc
=
1
SmallStackAlloc
=
2
SaveXmm128
=
8
SaveXmm128Far
=
9
}
match
self
{
Self
:
:
PushRegister
{
offset
reg
}
=
>
{
writer
.
write_u8
(
*
offset
)
;
writer
.
write_u8
(
(
*
reg
<
<
4
)
|
(
UnwindOperation
:
:
PushNonvolatileRegister
as
u8
)
)
;
}
Self
:
:
SaveXmm
{
offset
reg
stack_offset
}
=
>
{
writer
.
write_u8
(
*
offset
)
;
let
scaled_stack_offset
=
stack_offset
/
16
;
if
scaled_stack_offset
<
=
core
:
:
u16
:
:
MAX
as
u32
{
writer
.
write_u8
(
(
*
reg
<
<
4
)
|
(
UnwindOperation
:
:
SaveXmm128
as
u8
)
)
;
writer
.
write_u16
:
:
<
LittleEndian
>
(
scaled_stack_offset
as
u16
)
;
}
else
{
writer
.
write_u8
(
(
*
reg
<
<
4
)
|
(
UnwindOperation
:
:
SaveXmm128Far
as
u8
)
)
;
writer
.
write_u16
:
:
<
LittleEndian
>
(
*
stack_offset
as
u16
)
;
writer
.
write_u16
:
:
<
LittleEndian
>
(
(
stack_offset
>
>
16
)
as
u16
)
;
}
}
Self
:
:
StackAlloc
{
offset
size
}
=
>
{
assert
!
(
*
size
>
=
8
)
;
assert
!
(
(
*
size
%
8
)
=
=
0
)
;
writer
.
write_u8
(
*
offset
)
;
if
*
size
<
=
SMALL_ALLOC_MAX_SIZE
{
writer
.
write_u8
(
(
(
(
(
*
size
-
8
)
/
8
)
as
u8
)
<
<
4
)
|
UnwindOperation
:
:
SmallStackAlloc
as
u8
)
;
}
else
if
*
size
<
=
LARGE_ALLOC_16BIT_MAX_SIZE
{
writer
.
write_u8
(
UnwindOperation
:
:
LargeStackAlloc
as
u8
)
;
writer
.
write_u16
:
:
<
LittleEndian
>
(
(
*
size
/
8
)
as
u16
)
;
}
else
{
writer
.
write_u8
(
(
1
<
<
4
)
|
(
UnwindOperation
:
:
LargeStackAlloc
as
u8
)
)
;
writer
.
write_u32
:
:
<
LittleEndian
>
(
*
size
)
;
}
}
}
;
}
fn
node_count
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
StackAlloc
{
size
.
.
}
=
>
{
if
*
size
<
=
SMALL_ALLOC_MAX_SIZE
{
1
}
else
if
*
size
<
=
LARGE_ALLOC_16BIT_MAX_SIZE
{
2
}
else
{
3
}
}
Self
:
:
SaveXmm
{
stack_offset
.
.
}
=
>
{
if
*
stack_offset
<
=
core
:
:
u16
:
:
MAX
as
u32
{
2
}
else
{
3
}
}
_
=
>
1
}
}
}
pub
(
crate
)
enum
MappedRegister
{
Int
(
u8
)
Xmm
(
u8
)
}
pub
(
crate
)
trait
RegisterMapper
{
fn
map
(
reg
:
RegUnit
)
-
>
MappedRegister
;
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
UnwindInfo
{
pub
(
crate
)
flags
:
u8
pub
(
crate
)
prologue_size
:
u8
pub
(
crate
)
frame_register
:
Option
<
u8
>
pub
(
crate
)
frame_register_offset
:
u8
pub
(
crate
)
unwind_codes
:
Vec
<
UnwindCode
>
}
impl
UnwindInfo
{
pub
fn
emit_size
(
&
self
)
-
>
usize
{
let
node_count
=
self
.
node_count
(
)
;
assert
!
(
self
.
flags
=
=
0
)
;
4
+
(
node_count
*
2
)
+
if
(
node_count
&
1
)
=
=
1
{
2
}
else
{
0
}
}
pub
fn
emit
(
&
self
buf
:
&
mut
[
u8
]
)
{
const
UNWIND_INFO_VERSION
:
u8
=
1
;
let
node_count
=
self
.
node_count
(
)
;
assert
!
(
node_count
<
=
256
)
;
let
mut
writer
=
Writer
:
:
new
(
buf
)
;
writer
.
write_u8
(
(
self
.
flags
<
<
3
)
|
UNWIND_INFO_VERSION
)
;
writer
.
write_u8
(
self
.
prologue_size
)
;
writer
.
write_u8
(
node_count
as
u8
)
;
if
let
Some
(
reg
)
=
self
.
frame_register
{
writer
.
write_u8
(
(
self
.
frame_register_offset
<
<
4
)
|
reg
)
;
}
else
{
writer
.
write_u8
(
0
)
;
}
for
code
in
self
.
unwind_codes
.
iter
(
)
.
rev
(
)
{
code
.
emit
(
&
mut
writer
)
;
}
if
(
node_count
&
1
)
=
=
1
{
writer
.
write_u16
:
:
<
LittleEndian
>
(
0
)
;
}
assert_eq
!
(
writer
.
offset
self
.
emit_size
(
)
)
;
}
fn
node_count
(
&
self
)
-
>
usize
{
self
.
unwind_codes
.
iter
(
)
.
fold
(
0
|
nodes
c
|
nodes
+
c
.
node_count
(
)
)
}
pub
(
crate
)
fn
build
<
MR
:
RegisterMapper
>
(
unwind
:
input
:
:
UnwindInfo
<
RegUnit
>
)
-
>
CodegenResult
<
Self
>
{
use
crate
:
:
isa
:
:
unwind
:
:
input
:
:
UnwindCode
as
InputUnwindCode
;
let
word_size
:
u32
=
unwind
.
word_size
.
into
(
)
;
let
mut
unwind_codes
=
Vec
:
:
new
(
)
;
for
(
offset
c
)
in
unwind
.
prologue_unwind_codes
.
iter
(
)
{
match
c
{
InputUnwindCode
:
:
SaveRegister
{
reg
stack_offset
}
=
>
{
let
reg
=
MR
:
:
map
(
*
reg
)
;
let
offset
=
ensure_unwind_offset
(
*
offset
)
?
;
match
reg
{
MappedRegister
:
:
Int
(
reg
)
=
>
{
let
push_reg_sequence
=
if
let
Some
(
UnwindCode
:
:
StackAlloc
{
offset
:
alloc_offset
size
}
)
=
unwind_codes
.
last
(
)
{
*
size
=
=
word_size
&
&
offset
=
=
*
alloc_offset
&
&
*
stack_offset
=
=
0
}
else
{
false
}
;
if
push_reg_sequence
{
*
unwind_codes
.
last_mut
(
)
.
unwrap
(
)
=
UnwindCode
:
:
PushRegister
{
offset
reg
}
;
}
else
{
return
Err
(
CodegenError
:
:
Unsupported
(
"
Unsupported
UnwindCode
:
:
PushRegister
sequence
"
.
into
(
)
)
)
;
}
}
MappedRegister
:
:
Xmm
(
reg
)
=
>
{
unwind_codes
.
push
(
UnwindCode
:
:
SaveXmm
{
offset
reg
stack_offset
:
*
stack_offset
}
)
;
}
}
}
InputUnwindCode
:
:
StackAlloc
{
size
}
=
>
{
unwind_codes
.
push
(
UnwindCode
:
:
StackAlloc
{
offset
:
ensure_unwind_offset
(
*
offset
)
?
size
:
*
size
}
)
;
}
_
=
>
{
}
}
}
Ok
(
Self
{
flags
:
0
prologue_size
:
ensure_unwind_offset
(
unwind
.
prologue_size
)
?
frame_register
:
None
frame_register_offset
:
0
unwind_codes
}
)
}
}
fn
ensure_unwind_offset
(
offset
:
u32
)
-
>
CodegenResult
<
u8
>
{
if
offset
>
255
{
warn
!
(
"
function
prologues
cannot
exceed
255
bytes
in
size
for
Windows
x64
"
)
;
return
Err
(
CodegenError
:
:
CodeTooLarge
)
;
}
Ok
(
offset
as
u8
)
}
