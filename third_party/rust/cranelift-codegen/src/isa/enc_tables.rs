use
constant_hash
:
:
{
probe
Table
}
;
use
ir
:
:
{
Function
InstructionData
Opcode
Type
}
;
use
isa
:
:
{
Encoding
Legalize
}
;
use
settings
:
:
PredicateView
;
use
std
:
:
ops
:
:
Range
;
pub
type
RecipePredicate
=
Option
<
fn
(
PredicateView
&
InstructionData
)
-
>
bool
>
;
pub
type
InstPredicate
=
fn
(
&
Function
&
InstructionData
)
-
>
bool
;
pub
type
LegalizeCode
=
u8
;
pub
struct
Level1Entry
<
OffT
:
Into
<
u32
>
+
Copy
>
{
pub
ty
:
Type
pub
log2len
:
u8
pub
legalize
:
LegalizeCode
pub
offset
:
OffT
}
impl
<
OffT
:
Into
<
u32
>
+
Copy
>
Level1Entry
<
OffT
>
{
fn
range
(
&
self
)
-
>
Range
<
usize
>
{
let
b
=
self
.
offset
.
into
(
)
as
usize
;
b
.
.
b
+
(
1
<
<
self
.
log2len
)
}
}
impl
<
OffT
:
Into
<
u32
>
+
Copy
>
Table
<
Type
>
for
[
Level1Entry
<
OffT
>
]
{
fn
len
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
key
(
&
self
idx
:
usize
)
-
>
Option
<
Type
>
{
if
self
[
idx
]
.
log2len
!
=
!
0
{
Some
(
self
[
idx
]
.
ty
)
}
else
{
None
}
}
}
pub
struct
Level2Entry
<
OffT
:
Into
<
u32
>
+
Copy
>
{
pub
opcode
:
Option
<
Opcode
>
pub
offset
:
OffT
}
impl
<
OffT
:
Into
<
u32
>
+
Copy
>
Table
<
Opcode
>
for
[
Level2Entry
<
OffT
>
]
{
fn
len
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
key
(
&
self
idx
:
usize
)
-
>
Option
<
Opcode
>
{
self
[
idx
]
.
opcode
}
}
pub
fn
lookup_enclist
<
'
a
OffT1
OffT2
>
(
ctrl_typevar
:
Type
inst
:
&
'
a
InstructionData
func
:
&
'
a
Function
level1_table
:
&
'
static
[
Level1Entry
<
OffT1
>
]
level2_table
:
&
'
static
[
Level2Entry
<
OffT2
>
]
enclist
:
&
'
static
[
EncListEntry
]
legalize_actions
:
&
'
static
[
Legalize
]
recipe_preds
:
&
'
static
[
RecipePredicate
]
inst_preds
:
&
'
static
[
InstPredicate
]
isa_preds
:
PredicateView
<
'
a
>
)
-
>
Encodings
<
'
a
>
where
OffT1
:
Into
<
u32
>
+
Copy
OffT2
:
Into
<
u32
>
+
Copy
{
let
(
offset
legalize
)
=
match
probe
(
level1_table
ctrl_typevar
ctrl_typevar
.
index
(
)
)
{
Err
(
l1idx
)
=
>
{
(
!
0
level1_table
[
l1idx
]
.
legalize
)
}
Ok
(
l1idx
)
=
>
{
let
l1ent
=
&
level1_table
[
l1idx
]
;
let
offset
=
match
level2_table
.
get
(
l1ent
.
range
(
)
)
{
Some
(
l2tab
)
=
>
{
let
opcode
=
inst
.
opcode
(
)
;
match
probe
(
l2tab
opcode
opcode
as
usize
)
{
Ok
(
l2idx
)
=
>
l2tab
[
l2idx
]
.
offset
.
into
(
)
as
usize
Err
(
_
)
=
>
!
0
}
}
None
=
>
!
0
}
;
(
offset
l1ent
.
legalize
)
}
}
;
Encodings
:
:
new
(
offset
legalize
inst
func
enclist
legalize_actions
recipe_preds
inst_preds
isa_preds
)
}
pub
type
EncListEntry
=
u16
;
const
PRED_BITS
:
u8
=
12
;
const
PRED_MASK
:
usize
=
(
1
<
<
PRED_BITS
)
-
1
;
const
PRED_START
:
usize
=
0x1000
;
pub
struct
Encodings
<
'
a
>
{
offset
:
usize
legalize
:
LegalizeCode
inst
:
&
'
a
InstructionData
func
:
&
'
a
Function
enclist
:
&
'
static
[
EncListEntry
]
legalize_actions
:
&
'
static
[
Legalize
]
recipe_preds
:
&
'
static
[
RecipePredicate
]
inst_preds
:
&
'
static
[
InstPredicate
]
isa_preds
:
PredicateView
<
'
a
>
}
impl
<
'
a
>
Encodings
<
'
a
>
{
pub
fn
new
(
offset
:
usize
legalize
:
LegalizeCode
inst
:
&
'
a
InstructionData
func
:
&
'
a
Function
enclist
:
&
'
static
[
EncListEntry
]
legalize_actions
:
&
'
static
[
Legalize
]
recipe_preds
:
&
'
static
[
RecipePredicate
]
inst_preds
:
&
'
static
[
InstPredicate
]
isa_preds
:
PredicateView
<
'
a
>
)
-
>
Self
{
Encodings
{
offset
inst
func
legalize
isa_preds
recipe_preds
inst_preds
enclist
legalize_actions
}
}
pub
fn
legalize
(
&
self
)
-
>
Legalize
{
debug_assert_eq
!
(
self
.
offset
!
0
"
Premature
Encodings
:
:
legalize
(
)
"
)
;
self
.
legalize_actions
[
self
.
legalize
as
usize
]
}
fn
check_recipe
(
&
self
rpred
:
RecipePredicate
)
-
>
bool
{
match
rpred
{
Some
(
p
)
=
>
p
(
self
.
isa_preds
self
.
inst
)
None
=
>
true
}
}
fn
check_pred
(
&
self
pred
:
usize
)
-
>
bool
{
if
let
Some
(
&
p
)
=
self
.
inst_preds
.
get
(
pred
)
{
p
(
self
.
func
self
.
inst
)
}
else
{
let
pred
=
pred
-
self
.
inst_preds
.
len
(
)
;
self
.
isa_preds
.
test
(
pred
)
}
}
}
impl
<
'
a
>
Iterator
for
Encodings
<
'
a
>
{
type
Item
=
Encoding
;
fn
next
(
&
mut
self
)
-
>
Option
<
Encoding
>
{
while
let
Some
(
entryref
)
=
self
.
enclist
.
get
(
self
.
offset
)
{
let
entry
=
*
entryref
as
usize
;
let
recipe
=
entry
>
>
1
;
if
let
Some
(
&
rpred
)
=
self
.
recipe_preds
.
get
(
recipe
)
{
let
bits
=
self
.
offset
+
1
;
if
entry
&
1
=
=
0
{
self
.
offset
+
=
2
;
}
else
{
self
.
offset
=
!
0
;
}
if
self
.
check_recipe
(
rpred
)
{
return
Some
(
Encoding
:
:
new
(
recipe
as
u16
self
.
enclist
[
bits
]
)
)
;
}
continue
;
}
if
entry
<
PRED_START
{
self
.
legalize
=
(
entry
-
2
*
self
.
recipe_preds
.
len
(
)
)
as
LegalizeCode
;
self
.
offset
=
!
0
;
return
None
;
}
let
pred_entry
=
entry
-
PRED_START
;
let
skip
=
pred_entry
>
>
PRED_BITS
;
let
pred
=
pred_entry
&
PRED_MASK
;
if
self
.
check_pred
(
pred
)
{
self
.
offset
+
=
1
;
}
else
if
skip
=
=
0
{
self
.
offset
=
!
0
;
return
None
;
}
else
{
self
.
offset
+
=
1
+
skip
;
}
}
None
}
}
