use
crate
:
:
binemit
:
:
Reloc
;
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
use
crate
:
:
ir
:
:
{
types
TrapCode
}
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
args
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
*
;
use
crate
:
:
machinst
:
:
{
MachBuffer
MachInstEmit
MachLabel
}
;
use
core
:
:
convert
:
:
TryInto
;
use
log
:
:
debug
;
use
regalloc
:
:
{
Reg
RegClass
Writable
}
;
use
std
:
:
convert
:
:
TryFrom
;
fn
low8_will_sign_extend_to_64
(
x
:
u32
)
-
>
bool
{
let
xs
=
(
x
as
i32
)
as
i64
;
xs
=
=
(
(
xs
<
<
56
)
>
>
56
)
}
fn
low8_will_sign_extend_to_32
(
x
:
u32
)
-
>
bool
{
let
xs
=
x
as
i32
;
xs
=
=
(
(
xs
<
<
24
)
>
>
24
)
}
#
[
inline
(
always
)
]
fn
encode_modrm
(
m0d
:
u8
enc_reg_g
:
u8
rm_e
:
u8
)
-
>
u8
{
debug_assert
!
(
m0d
<
4
)
;
debug_assert
!
(
enc_reg_g
<
8
)
;
debug_assert
!
(
rm_e
<
8
)
;
(
(
m0d
&
3
)
<
<
6
)
|
(
(
enc_reg_g
&
7
)
<
<
3
)
|
(
rm_e
&
7
)
}
#
[
inline
(
always
)
]
fn
encode_sib
(
shift
:
u8
enc_index
:
u8
enc_base
:
u8
)
-
>
u8
{
debug_assert
!
(
shift
<
4
)
;
debug_assert
!
(
enc_index
<
8
)
;
debug_assert
!
(
enc_base
<
8
)
;
(
(
shift
&
3
)
<
<
6
)
|
(
(
enc_index
&
7
)
<
<
3
)
|
(
enc_base
&
7
)
}
#
[
inline
(
always
)
]
fn
int_reg_enc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
debug_assert_eq
!
(
reg
.
get_class
(
)
RegClass
:
:
I64
)
;
reg
.
get_hw_encoding
(
)
}
#
[
inline
(
always
)
]
fn
reg_enc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
reg
.
get_hw_encoding
(
)
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Copy
)
]
struct
RexFlags
(
u8
)
;
impl
RexFlags
{
#
[
inline
(
always
)
]
fn
set_w
(
)
-
>
Self
{
Self
(
0
)
}
#
[
inline
(
always
)
]
fn
clear_w
(
)
-
>
Self
{
Self
(
1
)
}
#
[
inline
(
always
)
]
fn
always_emit
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
0
=
self
.
0
|
2
;
self
}
#
[
inline
(
always
)
]
fn
must_clear_w
(
&
self
)
-
>
bool
{
(
self
.
0
&
1
)
!
=
0
}
#
[
inline
(
always
)
]
fn
must_always_emit
(
&
self
)
-
>
bool
{
(
self
.
0
&
2
)
!
=
0
}
#
[
inline
(
always
)
]
fn
emit_two_op
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
enc_g
:
u8
enc_e
:
u8
)
{
let
w
=
if
self
.
must_clear_w
(
)
{
0
}
else
{
1
}
;
let
r
=
(
enc_g
>
>
3
)
&
1
;
let
x
=
0
;
let
b
=
(
enc_e
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
self
.
must_always_emit
(
)
{
sink
.
put1
(
rex
)
;
}
}
#
[
inline
(
always
)
]
fn
emit_three_op
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
enc_g
:
u8
enc_index
:
u8
enc_base
:
u8
)
{
let
w
=
if
self
.
must_clear_w
(
)
{
0
}
else
{
1
}
;
let
r
=
(
enc_g
>
>
3
)
&
1
;
let
x
=
(
enc_index
>
>
3
)
&
1
;
let
b
=
(
enc_base
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
self
.
must_always_emit
(
)
{
sink
.
put1
(
rex
)
;
}
}
}
enum
LegacyPrefix
{
None
_66
_F2
_F3
}
impl
LegacyPrefix
{
#
[
inline
(
always
)
]
fn
emit
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
)
{
match
self
{
LegacyPrefix
:
:
_66
=
>
sink
.
put1
(
0x66
)
LegacyPrefix
:
:
_F2
=
>
sink
.
put1
(
0xF2
)
LegacyPrefix
:
:
_F3
=
>
sink
.
put1
(
0xF3
)
LegacyPrefix
:
:
None
=
>
(
)
}
}
}
fn
emit_std_enc_mem
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
mut
num_opcodes
:
usize
enc_g
:
u8
mem_e
:
&
Amode
rex
:
RexFlags
)
{
prefix
.
emit
(
sink
)
;
match
mem_e
{
Amode
:
:
ImmReg
{
simm32
base
}
=
>
{
let
enc_e
=
int_reg_enc
(
*
base
)
;
rex
.
emit_two_op
(
sink
enc_g
enc_e
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
*
simm32
=
=
0
&
&
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_RBP
&
&
enc_e
!
=
regs
:
:
ENC_R12
&
&
enc_e
!
=
regs
:
:
ENC_R13
{
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
enc_e
&
7
)
)
;
}
else
if
*
simm32
=
=
0
&
&
(
enc_e
=
=
regs
:
:
ENC_RSP
|
|
enc_e
=
=
regs
:
:
ENC_R12
)
{
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
}
else
if
low8_will_sign_extend_to_32
(
*
simm32
)
&
&
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
enc_e
&
7
)
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
enc_e
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
if
(
enc_e
=
=
regs
:
:
ENC_RSP
|
|
enc_e
=
=
regs
:
:
ENC_R12
)
&
&
low8_will_sign_extend_to_32
(
*
simm32
)
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
enc_e
=
=
regs
:
:
ENC_R12
|
|
enc_e
=
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
unreachable
!
(
"
ImmReg
"
)
;
}
}
Amode
:
:
ImmRegRegShift
{
simm32
base
:
reg_base
index
:
reg_index
shift
}
=
>
{
let
enc_base
=
int_reg_enc
(
*
reg_base
)
;
let
enc_index
=
int_reg_enc
(
*
reg_index
)
;
rex
.
emit_three_op
(
sink
enc_g
enc_index
enc_base
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
low8_will_sign_extend_to_32
(
*
simm32
)
&
&
enc_index
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
4
)
)
;
sink
.
put1
(
encode_sib
(
*
shift
enc_index
&
7
enc_base
&
7
)
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
if
enc_index
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
4
)
)
;
sink
.
put1
(
encode_sib
(
*
shift
enc_index
&
7
enc_base
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
panic
!
(
"
ImmRegRegShift
"
)
;
}
}
Amode
:
:
RipRelative
{
ref
target
}
=
>
{
rex
.
emit_two_op
(
sink
enc_g
0
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
0b101
)
)
;
match
*
target
{
BranchTarget
:
:
Label
(
label
)
=
>
{
let
offset
=
sink
.
cur_offset
(
)
;
sink
.
use_label_at_offset
(
offset
label
LabelUse
:
:
JmpRel32
)
;
sink
.
put4
(
0
)
;
}
BranchTarget
:
:
ResolvedOffset
(
offset
)
=
>
{
let
offset
=
u32
:
:
try_from
(
offset
)
.
expect
(
"
rip
-
relative
can
'
t
hold
>
=
U32_MAX
values
"
)
;
sink
.
put4
(
offset
)
;
}
}
}
}
}
fn
emit_std_enc_enc
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
mut
num_opcodes
:
usize
enc_g
:
u8
enc_e
:
u8
rex
:
RexFlags
)
{
prefix
.
emit
(
sink
)
;
rex
.
emit_two_op
(
sink
enc_g
enc_e
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
sink
.
put1
(
encode_modrm
(
3
enc_g
&
7
enc_e
&
7
)
)
;
}
fn
emit_std_reg_mem
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
num_opcodes
:
usize
reg_g
:
Reg
mem_e
:
&
Amode
rex
:
RexFlags
)
{
let
enc_g
=
reg_enc
(
reg_g
)
;
emit_std_enc_mem
(
sink
prefix
opcodes
num_opcodes
enc_g
mem_e
rex
)
;
}
fn
emit_std_reg_reg
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
num_opcodes
:
usize
reg_g
:
Reg
reg_e
:
Reg
rex
:
RexFlags
)
{
let
enc_g
=
reg_enc
(
reg_g
)
;
let
enc_e
=
reg_enc
(
reg_e
)
;
emit_std_enc_enc
(
sink
prefix
opcodes
num_opcodes
enc_g
enc_e
rex
)
;
}
fn
emit_simm
(
sink
:
&
mut
MachBuffer
<
Inst
>
size
:
u8
simm32
:
u32
)
{
match
size
{
8
|
4
=
>
sink
.
put4
(
simm32
)
2
=
>
sink
.
put2
(
simm32
as
u16
)
1
=
>
sink
.
put1
(
simm32
as
u8
)
_
=
>
unreachable
!
(
)
}
}
fn
emit_signed_cvt
(
sink
:
&
mut
MachBuffer
<
Inst
>
flags
:
&
settings
:
:
Flags
state
:
&
mut
EmitState
src
:
Reg
dst
:
Writable
<
Reg
>
to_f64
:
bool
)
{
let
op
=
if
to_f64
{
SseOpcode
:
:
Cvtsi2sd
}
else
{
SseOpcode
:
:
Cvtsi2ss
}
;
let
inst
=
Inst
:
:
gpr_to_xmm
(
op
RegMem
:
:
reg
(
src
)
OperandSize
:
:
Size64
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
}
fn
one_way_jmp
(
sink
:
&
mut
MachBuffer
<
Inst
>
cc
:
CC
label
:
MachLabel
)
{
let
cond_start
=
sink
.
cur_offset
(
)
;
let
cond_disp_off
=
cond_start
+
2
;
sink
.
use_label_at_offset
(
cond_disp_off
label
LabelUse
:
:
JmpRel32
)
;
sink
.
put1
(
0x0F
)
;
sink
.
put1
(
0x80
+
cc
.
get_enc
(
)
)
;
sink
.
put4
(
0x0
)
;
}
pub
(
crate
)
fn
emit
(
inst
:
&
Inst
sink
:
&
mut
MachBuffer
<
Inst
>
flags
:
&
settings
:
:
Flags
state
:
&
mut
EmitState
)
{
match
inst
{
Inst
:
:
Alu_RMI_R
{
is_64
op
src
dst
:
reg_g
}
=
>
{
let
rex
=
if
*
is_64
{
RexFlags
:
:
set_w
(
)
}
else
{
RexFlags
:
:
clear_w
(
)
}
;
if
*
op
=
=
AluRmiROpcode
:
:
Mul
{
match
src
{
RegMemImm
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
0x0FAF
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x0FAF
2
reg_g
.
to_reg
(
)
&
addr
.
finalize
(
state
)
rex
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
let
useImm8
=
low8_will_sign_extend_to_32
(
*
simm32
)
;
let
opcode
=
if
useImm8
{
0x6B
}
else
{
0x69
}
;
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcode
1
reg_g
.
to_reg
(
)
reg_g
.
to_reg
(
)
rex
)
;
emit_simm
(
sink
if
useImm8
{
1
}
else
{
4
}
*
simm32
)
;
}
}
}
else
{
let
(
opcode_r
opcode_m
subopcode_i
)
=
match
op
{
AluRmiROpcode
:
:
Add
=
>
(
0x01
0x03
0
)
AluRmiROpcode
:
:
Sub
=
>
(
0x29
0x2B
5
)
AluRmiROpcode
:
:
And
=
>
(
0x21
0x23
4
)
AluRmiROpcode
:
:
Or
=
>
(
0x09
0x0B
1
)
AluRmiROpcode
:
:
Xor
=
>
(
0x31
0x33
6
)
AluRmiROpcode
:
:
Mul
=
>
panic
!
(
"
unreachable
"
)
}
;
match
src
{
RegMemImm
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcode_r
1
*
reg_e
reg_g
.
to_reg
(
)
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
opcode_m
1
reg_g
.
to_reg
(
)
&
addr
.
finalize
(
state
)
rex
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
let
use_imm8
=
low8_will_sign_extend_to_32
(
*
simm32
)
;
let
opcode
=
if
use_imm8
{
0x83
}
else
{
0x81
}
;
let
enc_g
=
int_reg_enc
(
reg_g
.
to_reg
(
)
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
opcode
1
subopcode_i
enc_g
rex
)
;
emit_simm
(
sink
if
use_imm8
{
1
}
else
{
4
}
*
simm32
)
;
}
}
}
}
Inst
:
:
UnaryRmR
{
size
op
src
dst
}
=
>
{
let
(
prefix
rex_flags
)
=
match
size
{
2
=
>
(
LegacyPrefix
:
:
_66
RexFlags
:
:
clear_w
(
)
)
4
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
clear_w
(
)
)
8
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
set_w
(
)
)
_
=
>
unreachable
!
(
)
}
;
let
(
opcode
num_opcodes
)
=
match
op
{
UnaryRmROpcode
:
:
Bsr
=
>
(
0x0fbd
2
)
UnaryRmROpcode
:
:
Bsf
=
>
(
0x0fbc
2
)
}
;
match
src
{
RegMem
:
:
Reg
{
reg
:
src
}
=
>
emit_std_reg_reg
(
sink
prefix
opcode
num_opcodes
dst
.
to_reg
(
)
*
src
rex_flags
)
RegMem
:
:
Mem
{
addr
:
src
}
=
>
emit_std_reg_mem
(
sink
prefix
opcode
num_opcodes
dst
.
to_reg
(
)
&
src
.
finalize
(
state
)
rex_flags
)
}
}
Inst
:
:
Div
{
size
signed
divisor
loc
}
=
>
{
let
(
prefix
rex_flags
)
=
match
size
{
2
=
>
(
LegacyPrefix
:
:
_66
RexFlags
:
:
clear_w
(
)
)
4
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
clear_w
(
)
)
8
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
set_w
(
)
)
_
=
>
unreachable
!
(
)
}
;
sink
.
add_trap
(
*
loc
TrapCode
:
:
IntegerDivisionByZero
)
;
let
subopcode
=
if
*
signed
{
7
}
else
{
6
}
;
match
divisor
{
RegMem
:
:
Reg
{
reg
}
=
>
{
let
src
=
int_reg_enc
(
*
reg
)
;
emit_std_enc_enc
(
sink
prefix
0xF7
1
subopcode
src
rex_flags
)
}
RegMem
:
:
Mem
{
addr
:
src
}
=
>
emit_std_enc_mem
(
sink
prefix
0xF7
1
subopcode
&
src
.
finalize
(
state
)
rex_flags
)
}
}
Inst
:
:
MulHi
{
size
signed
rhs
}
=
>
{
let
(
prefix
rex_flags
)
=
match
size
{
2
=
>
(
LegacyPrefix
:
:
_66
RexFlags
:
:
clear_w
(
)
)
4
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
clear_w
(
)
)
8
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
set_w
(
)
)
_
=
>
unreachable
!
(
)
}
;
let
subopcode
=
if
*
signed
{
5
}
else
{
4
}
;
match
rhs
{
RegMem
:
:
Reg
{
reg
}
=
>
{
let
src
=
int_reg_enc
(
*
reg
)
;
emit_std_enc_enc
(
sink
prefix
0xF7
1
subopcode
src
rex_flags
)
}
RegMem
:
:
Mem
{
addr
:
src
}
=
>
emit_std_enc_mem
(
sink
prefix
0xF7
1
subopcode
&
src
.
finalize
(
state
)
rex_flags
)
}
}
Inst
:
:
SignExtendRaxRdx
{
size
}
=
>
{
match
size
{
2
=
>
sink
.
put1
(
0x66
)
4
=
>
{
}
8
=
>
sink
.
put1
(
0x48
)
_
=
>
unreachable
!
(
)
}
sink
.
put1
(
0x99
)
;
}
Inst
:
:
CheckedDivOrRemSeq
{
kind
size
divisor
loc
tmp
}
=
>
{
debug_assert
!
(
flags
.
avoid_div_traps
(
)
)
;
let
inst
=
Inst
:
:
cmp_rmi_r
(
*
size
RegMemImm
:
:
imm
(
0
)
divisor
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
trap_if
(
CC
:
:
Z
TrapCode
:
:
IntegerDivisionByZero
*
loc
)
;
inst
.
emit
(
sink
flags
state
)
;
let
(
do_op
done_label
)
=
if
kind
.
is_signed
(
)
{
let
inst
=
Inst
:
:
cmp_rmi_r
(
*
size
RegMemImm
:
:
imm
(
0xffffffff
)
divisor
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
let
do_op
=
sink
.
get_label
(
)
;
one_way_jmp
(
sink
CC
:
:
NZ
do_op
)
;
if
!
kind
.
is_div
(
)
{
let
done_label
=
sink
.
get_label
(
)
;
let
inst
=
Inst
:
:
imm_r
(
*
size
=
=
8
0
Writable
:
:
from_reg
(
regs
:
:
rdx
(
)
)
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done_label
)
)
;
inst
.
emit
(
sink
flags
state
)
;
(
Some
(
do_op
)
Some
(
done_label
)
)
}
else
{
if
*
size
=
=
8
{
let
tmp
=
tmp
.
expect
(
"
temporary
for
i64
sdiv
"
)
;
let
inst
=
Inst
:
:
imm_r
(
true
0x8000000000000000
tmp
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
cmp_rmi_r
(
8
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
regs
:
:
rax
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
cmp_rmi_r
(
*
size
RegMemImm
:
:
imm
(
0x80000000
)
regs
:
:
rax
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
}
let
inst
=
Inst
:
:
trap_if
(
CC
:
:
Z
TrapCode
:
:
IntegerOverflow
*
loc
)
;
inst
.
emit
(
sink
flags
state
)
;
(
Some
(
do_op
)
None
)
}
}
else
{
(
None
None
)
}
;
if
let
Some
(
do_op
)
=
do_op
{
sink
.
bind_label
(
do_op
)
;
}
if
kind
.
is_signed
(
)
{
let
inst
=
Inst
:
:
sign_extend_rax_to_rdx
(
*
size
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
imm_r
(
true
0
Writable
:
:
from_reg
(
regs
:
:
rdx
(
)
)
)
;
inst
.
emit
(
sink
flags
state
)
;
}
let
inst
=
Inst
:
:
div
(
*
size
kind
.
is_signed
(
)
RegMem
:
:
reg
(
divisor
.
to_reg
(
)
)
*
loc
)
;
inst
.
emit
(
sink
flags
state
)
;
if
let
Some
(
done
)
=
done_label
{
sink
.
bind_label
(
done
)
;
}
}
Inst
:
:
Imm_R
{
dst_is_64
simm64
dst
}
=
>
{
let
enc_dst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
if
*
dst_is_64
{
sink
.
put1
(
0x48
|
(
(
enc_dst
>
>
3
)
&
1
)
)
;
sink
.
put1
(
0xB8
|
(
enc_dst
&
7
)
)
;
sink
.
put8
(
*
simm64
)
;
}
else
{
if
(
(
enc_dst
>
>
3
)
&
1
)
=
=
1
{
sink
.
put1
(
0x41
)
;
}
sink
.
put1
(
0xB8
|
(
enc_dst
&
7
)
)
;
sink
.
put4
(
*
simm64
as
u32
)
;
}
}
Inst
:
:
Mov_R_R
{
is_64
src
dst
}
=
>
{
let
rex
=
if
*
is_64
{
RexFlags
:
:
set_w
(
)
}
else
{
RexFlags
:
:
clear_w
(
)
}
;
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
0x89
1
*
src
dst
.
to_reg
(
)
rex
)
;
}
Inst
:
:
MovZX_RM_R
{
ext_mode
src
dst
srcloc
}
=
>
{
let
(
opcodes
num_opcodes
mut
rex_flags
)
=
match
ext_mode
{
ExtMode
:
:
BL
=
>
{
(
0x0FB6
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
BQ
=
>
{
(
0x0FB6
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
WL
=
>
{
(
0x0FB7
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
WQ
=
>
{
(
0x0FB7
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
LQ
=
>
{
(
0x8B
1
RexFlags
:
:
clear_w
(
)
)
}
}
;
match
src
{
RegMem
:
:
Reg
{
reg
:
src
}
=
>
{
match
ext_mode
{
ExtMode
:
:
BL
|
ExtMode
:
:
BQ
=
>
{
let
enc_src
=
int_reg_enc
(
*
src
)
;
if
enc_src
>
=
4
&
&
enc_src
<
=
7
{
rex_flags
.
always_emit
(
)
;
}
;
}
_
=
>
{
}
}
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
*
src
rex_flags
)
}
RegMem
:
:
Mem
{
addr
:
src
}
=
>
{
let
src
=
&
src
.
finalize
(
state
)
;
if
let
Some
(
srcloc
)
=
*
srcloc
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
src
rex_flags
)
}
}
}
Inst
:
:
Mov64_M_R
{
src
dst
srcloc
}
=
>
{
let
src
=
&
src
.
finalize
(
state
)
;
if
let
Some
(
srcloc
)
=
*
srcloc
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x8B
1
dst
.
to_reg
(
)
src
RexFlags
:
:
set_w
(
)
)
}
Inst
:
:
LoadEffectiveAddress
{
addr
dst
}
=
>
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x8D
1
dst
.
to_reg
(
)
&
addr
.
finalize
(
state
)
RexFlags
:
:
set_w
(
)
)
Inst
:
:
MovSX_RM_R
{
ext_mode
src
dst
srcloc
}
=
>
{
let
(
opcodes
num_opcodes
mut
rex_flags
)
=
match
ext_mode
{
ExtMode
:
:
BL
=
>
{
(
0x0FBE
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
BQ
=
>
{
(
0x0FBE
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
WL
=
>
{
(
0x0FBF
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
WQ
=
>
{
(
0x0FBF
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
LQ
=
>
{
(
0x63
1
RexFlags
:
:
set_w
(
)
)
}
}
;
match
src
{
RegMem
:
:
Reg
{
reg
:
src
}
=
>
{
match
ext_mode
{
ExtMode
:
:
BL
|
ExtMode
:
:
BQ
=
>
{
let
enc_src
=
int_reg_enc
(
*
src
)
;
if
enc_src
>
=
4
&
&
enc_src
<
=
7
{
rex_flags
.
always_emit
(
)
;
}
;
}
_
=
>
{
}
}
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
*
src
rex_flags
)
}
RegMem
:
:
Mem
{
addr
:
src
}
=
>
{
let
src
=
&
src
.
finalize
(
state
)
;
if
let
Some
(
srcloc
)
=
*
srcloc
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
src
rex_flags
)
}
}
}
Inst
:
:
Mov_R_M
{
size
src
dst
srcloc
}
=
>
{
let
dst
=
&
dst
.
finalize
(
state
)
;
if
let
Some
(
srcloc
)
=
*
srcloc
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
match
size
{
1
=
>
{
let
mut
rex
=
RexFlags
:
:
clear_w
(
)
;
let
enc_src
=
int_reg_enc
(
*
src
)
;
if
enc_src
>
=
4
&
&
enc_src
<
=
7
{
rex
.
always_emit
(
)
;
}
;
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x88
1
*
src
dst
rex
)
}
2
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
_66
0x89
1
*
src
dst
RexFlags
:
:
clear_w
(
)
)
}
4
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x89
1
*
src
dst
RexFlags
:
:
clear_w
(
)
)
}
8
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x89
1
*
src
dst
RexFlags
:
:
set_w
(
)
)
}
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
Mov_R_M
:
:
emit
:
unreachable
"
)
}
}
Inst
:
:
Shift_R
{
is_64
kind
num_bits
dst
}
=
>
{
let
enc_dst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
let
subopcode
=
match
kind
{
ShiftKind
:
:
RotateLeft
=
>
0
ShiftKind
:
:
RotateRight
=
>
1
ShiftKind
:
:
ShiftLeft
=
>
4
ShiftKind
:
:
ShiftRightLogical
=
>
5
ShiftKind
:
:
ShiftRightArithmetic
=
>
7
}
;
let
rex
=
if
*
is_64
{
RexFlags
:
:
set_w
(
)
}
else
{
RexFlags
:
:
clear_w
(
)
}
;
match
num_bits
{
None
=
>
{
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xD3
1
subopcode
enc_dst
rex
)
;
}
Some
(
num_bits
)
=
>
{
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xC1
1
subopcode
enc_dst
rex
)
;
sink
.
put1
(
*
num_bits
)
;
}
}
}
Inst
:
:
XmmRmiReg
{
opcode
src
dst
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
prefix
=
LegacyPrefix
:
:
_66
;
if
let
RegMemImm
:
:
Imm
{
simm32
}
=
src
{
let
(
opcode_bytes
reg_digit
)
=
match
opcode
{
SseOpcode
:
:
Psllw
=
>
(
0x0F71
6
)
SseOpcode
:
:
Pslld
=
>
(
0x0F72
6
)
SseOpcode
:
:
Psllq
=
>
(
0x0F73
6
)
SseOpcode
:
:
Psraw
=
>
(
0x0F71
4
)
SseOpcode
:
:
Psrad
=
>
(
0x0F72
4
)
SseOpcode
:
:
Psrlw
=
>
(
0x0F71
2
)
SseOpcode
:
:
Psrld
=
>
(
0x0F72
2
)
SseOpcode
:
:
Psrlq
=
>
(
0x0F73
2
)
_
=
>
panic
!
(
"
invalid
opcode
:
{
}
"
opcode
)
}
;
let
dst_enc
=
reg_enc
(
dst
.
to_reg
(
)
)
;
emit_std_enc_enc
(
sink
prefix
opcode_bytes
2
reg_digit
dst_enc
rex
)
;
let
imm
=
(
*
simm32
)
.
try_into
(
)
.
expect
(
"
the
immediate
must
be
convertible
to
a
u8
"
)
;
sink
.
put1
(
imm
)
;
}
else
{
let
opcode_bytes
=
match
opcode
{
SseOpcode
:
:
Psllw
=
>
0x0FF1
SseOpcode
:
:
Pslld
=
>
0x0FF2
SseOpcode
:
:
Psllq
=
>
0x0FF3
SseOpcode
:
:
Psraw
=
>
0x0FE1
SseOpcode
:
:
Psrad
=
>
0x0FE2
SseOpcode
:
:
Psrlw
=
>
0x0FD1
SseOpcode
:
:
Psrld
=
>
0x0FD2
SseOpcode
:
:
Psrlq
=
>
0x0FD3
_
=
>
panic
!
(
"
invalid
opcode
:
{
}
"
opcode
)
}
;
match
src
{
RegMemImm
:
:
Reg
{
reg
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode_bytes
2
dst
.
to_reg
(
)
*
reg
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode_bytes
2
dst
.
to_reg
(
)
addr
rex
)
;
}
RegMemImm
:
:
Imm
{
.
.
}
=
>
unreachable
!
(
)
}
}
;
}
Inst
:
:
Cmp_RMI_R
{
size
src
:
src_e
dst
:
reg_g
}
=
>
{
let
mut
prefix
=
LegacyPrefix
:
:
None
;
if
*
size
=
=
2
{
prefix
=
LegacyPrefix
:
:
_66
;
}
let
mut
rex
=
match
size
{
8
=
>
RexFlags
:
:
set_w
(
)
4
|
2
=
>
RexFlags
:
:
clear_w
(
)
1
=
>
{
let
mut
rex
=
RexFlags
:
:
clear_w
(
)
;
let
enc_g
=
int_reg_enc
(
*
reg_g
)
;
if
enc_g
>
=
4
&
&
enc_g
<
=
7
{
rex
.
always_emit
(
)
;
}
rex
}
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
Cmp_RMI_R
:
:
emit
:
unreachable
"
)
}
;
match
src_e
{
RegMemImm
:
:
Reg
{
reg
:
reg_e
}
=
>
{
if
*
size
=
=
1
{
let
enc_e
=
int_reg_enc
(
*
reg_e
)
;
if
enc_e
>
=
4
&
&
enc_e
<
=
7
{
rex
.
always_emit
(
)
;
}
}
let
opcode
=
if
*
size
=
=
1
{
0x38
}
else
{
0x39
}
;
emit_std_reg_reg
(
sink
prefix
opcode
1
*
reg_e
*
reg_g
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
let
opcode
=
if
*
size
=
=
1
{
0x3A
}
else
{
0x3B
}
;
emit_std_reg_mem
(
sink
prefix
opcode
1
*
reg_g
addr
rex
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
let
use_imm8
=
low8_will_sign_extend_to_32
(
*
simm32
)
;
let
opcode
=
if
*
size
=
=
1
{
0x80
}
else
if
use_imm8
{
0x83
}
else
{
0x81
}
;
let
enc_g
=
int_reg_enc
(
*
reg_g
)
;
emit_std_enc_enc
(
sink
prefix
opcode
1
7
enc_g
rex
)
;
emit_simm
(
sink
if
use_imm8
{
1
}
else
{
*
size
}
*
simm32
)
;
}
}
}
Inst
:
:
Setcc
{
cc
dst
}
=
>
{
let
opcode
=
0x0f90
+
cc
.
get_enc
(
)
as
u32
;
let
mut
rex_flags
=
RexFlags
:
:
clear_w
(
)
;
rex_flags
.
always_emit
(
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
opcode
2
0
reg_enc
(
dst
.
to_reg
(
)
)
rex_flags
)
;
}
Inst
:
:
Cmove
{
size
cc
src
dst
:
reg_g
}
=
>
{
let
(
prefix
rex_flags
)
=
match
size
{
2
=
>
(
LegacyPrefix
:
:
_66
RexFlags
:
:
clear_w
(
)
)
4
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
clear_w
(
)
)
8
=
>
(
LegacyPrefix
:
:
None
RexFlags
:
:
set_w
(
)
)
_
=
>
unreachable
!
(
"
invalid
size
spec
for
cmove
"
)
}
;
let
opcode
=
0x0F40
+
cc
.
get_enc
(
)
as
u32
;
match
src
{
RegMem
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
*
reg_e
rex_flags
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
addr
rex_flags
)
;
}
}
}
Inst
:
:
XmmCmove
{
is_64
cc
src
dst
}
=
>
{
let
next
=
sink
.
get_label
(
)
;
one_way_jmp
(
sink
cc
.
invert
(
)
next
)
;
let
op
=
if
*
is_64
{
SseOpcode
:
:
Movsd
}
else
{
SseOpcode
:
:
Movss
}
;
let
inst
=
Inst
:
:
xmm_unary_rm_r
(
op
src
.
clone
(
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
next
)
;
}
Inst
:
:
Push64
{
src
}
=
>
{
match
src
{
RegMemImm
:
:
Reg
{
reg
}
=
>
{
let
enc_reg
=
int_reg_enc
(
*
reg
)
;
let
rex
=
0x40
|
(
(
enc_reg
>
>
3
)
&
1
)
;
if
rex
!
=
0x40
{
sink
.
put1
(
rex
)
;
}
sink
.
put1
(
0x50
|
(
enc_reg
&
7
)
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_enc_mem
(
sink
LegacyPrefix
:
:
None
0xFF
1
6
addr
RexFlags
:
:
clear_w
(
)
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
if
low8_will_sign_extend_to_64
(
*
simm32
)
{
sink
.
put1
(
0x6A
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
{
sink
.
put1
(
0x68
)
;
sink
.
put4
(
*
simm32
)
;
}
}
}
}
Inst
:
:
Pop64
{
dst
}
=
>
{
let
encDst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
if
encDst
>
=
8
{
sink
.
put1
(
0x41
)
;
}
sink
.
put1
(
0x58
+
(
encDst
&
7
)
)
;
}
Inst
:
:
CallKnown
{
dest
loc
opcode
.
.
}
=
>
{
if
let
Some
(
s
)
=
state
.
take_stackmap
(
)
{
sink
.
add_stackmap
(
StackmapExtent
:
:
UpcomingBytes
(
5
)
s
)
;
}
sink
.
put1
(
0xE8
)
;
sink
.
add_reloc
(
*
loc
Reloc
:
:
X86CallPCRel4
&
dest
-
4
)
;
sink
.
put4
(
0
)
;
if
opcode
.
is_call
(
)
{
sink
.
add_call_site
(
*
loc
*
opcode
)
;
}
}
Inst
:
:
CallUnknown
{
dest
opcode
loc
.
.
}
=
>
{
let
start_offset
=
sink
.
cur_offset
(
)
;
match
dest
{
RegMem
:
:
Reg
{
reg
}
=
>
{
let
reg_enc
=
int_reg_enc
(
*
reg
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xFF
1
2
reg_enc
RexFlags
:
:
clear_w
(
)
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_enc_mem
(
sink
LegacyPrefix
:
:
None
0xFF
1
2
addr
RexFlags
:
:
clear_w
(
)
)
;
}
}
if
let
Some
(
s
)
=
state
.
take_stackmap
(
)
{
sink
.
add_stackmap
(
StackmapExtent
:
:
StartedAtOffset
(
start_offset
)
s
)
;
}
if
opcode
.
is_call
(
)
{
sink
.
add_call_site
(
*
loc
*
opcode
)
;
}
}
Inst
:
:
Ret
{
}
=
>
sink
.
put1
(
0xC3
)
Inst
:
:
JmpKnown
{
dst
}
=
>
{
let
br_start
=
sink
.
cur_offset
(
)
;
let
br_disp_off
=
br_start
+
1
;
let
br_end
=
br_start
+
5
;
if
let
Some
(
l
)
=
dst
.
as_label
(
)
{
sink
.
use_label_at_offset
(
br_disp_off
l
LabelUse
:
:
JmpRel32
)
;
sink
.
add_uncond_branch
(
br_start
br_end
l
)
;
}
let
disp
=
dst
.
as_offset32_or_zero
(
)
;
let
disp
=
disp
as
u32
;
sink
.
put1
(
0xE9
)
;
sink
.
put4
(
disp
)
;
}
Inst
:
:
JmpCond
{
cc
taken
not_taken
}
=
>
{
let
cond_start
=
sink
.
cur_offset
(
)
;
let
cond_disp_off
=
cond_start
+
2
;
let
cond_end
=
cond_start
+
6
;
if
let
Some
(
l
)
=
taken
.
as_label
(
)
{
sink
.
use_label_at_offset
(
cond_disp_off
l
LabelUse
:
:
JmpRel32
)
;
let
inverted
:
[
u8
;
6
]
=
[
0x0F
0x80
+
(
cc
.
invert
(
)
.
get_enc
(
)
)
0x00
0x00
0x00
0x00
]
;
sink
.
add_cond_branch
(
cond_start
cond_end
l
&
inverted
[
.
.
]
)
;
}
let
taken_disp
=
taken
.
as_offset32_or_zero
(
)
;
let
taken_disp
=
taken_disp
as
u32
;
sink
.
put1
(
0x0F
)
;
sink
.
put1
(
0x80
+
cc
.
get_enc
(
)
)
;
sink
.
put4
(
taken_disp
)
;
let
uncond_start
=
sink
.
cur_offset
(
)
;
let
uncond_disp_off
=
uncond_start
+
1
;
let
uncond_end
=
uncond_start
+
5
;
if
let
Some
(
l
)
=
not_taken
.
as_label
(
)
{
sink
.
use_label_at_offset
(
uncond_disp_off
l
LabelUse
:
:
JmpRel32
)
;
sink
.
add_uncond_branch
(
uncond_start
uncond_end
l
)
;
}
let
nt_disp
=
not_taken
.
as_offset32_or_zero
(
)
;
let
nt_disp
=
nt_disp
as
u32
;
sink
.
put1
(
0xE9
)
;
sink
.
put4
(
nt_disp
)
;
}
Inst
:
:
JmpUnknown
{
target
}
=
>
{
match
target
{
RegMem
:
:
Reg
{
reg
}
=
>
{
let
reg_enc
=
int_reg_enc
(
*
reg
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xFF
1
4
reg_enc
RexFlags
:
:
clear_w
(
)
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_enc_mem
(
sink
LegacyPrefix
:
:
None
0xFF
1
4
addr
RexFlags
:
:
clear_w
(
)
)
;
}
}
}
Inst
:
:
JmpTableSeq
{
idx
tmp1
tmp2
ref
targets
default_target
.
.
}
=
>
{
let
default_label
=
match
default_target
{
BranchTarget
:
:
Label
(
label
)
=
>
label
_
=
>
unreachable
!
(
)
}
;
one_way_jmp
(
sink
CC
:
:
NB
*
default_label
)
;
let
inst
=
Inst
:
:
movzx_rm_r
(
ExtMode
:
:
LQ
RegMem
:
:
reg
(
*
idx
)
*
tmp2
None
)
;
inst
.
emit
(
sink
flags
state
)
;
let
start_of_jumptable
=
sink
.
get_label
(
)
;
let
inst
=
Inst
:
:
lea
(
Amode
:
:
rip_relative
(
BranchTarget
:
:
Label
(
start_of_jumptable
)
)
*
tmp1
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
movsx_rm_r
(
ExtMode
:
:
LQ
RegMem
:
:
mem
(
Amode
:
:
imm_reg_reg_shift
(
0
tmp1
.
to_reg
(
)
tmp2
.
to_reg
(
)
2
)
)
*
tmp2
None
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
alu_rmi_r
(
true
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
*
tmp1
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_unknown
(
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
start_of_jumptable
)
;
let
jt_off
=
sink
.
cur_offset
(
)
;
for
&
target
in
targets
.
iter
(
)
{
let
word_off
=
sink
.
cur_offset
(
)
;
let
off_into_table
=
word_off
-
jt_off
;
sink
.
use_label_at_offset
(
word_off
target
.
as_label
(
)
.
unwrap
(
)
LabelUse
:
:
PCRel32
)
;
sink
.
put4
(
off_into_table
)
;
}
}
Inst
:
:
TrapIf
{
cc
trap_code
srcloc
}
=
>
{
let
else_label
=
sink
.
get_label
(
)
;
one_way_jmp
(
sink
cc
.
invert
(
)
else_label
)
;
let
inst
=
Inst
:
:
trap
(
*
srcloc
*
trap_code
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
else_label
)
;
}
Inst
:
:
XmmUnaryRmR
{
op
src
:
src_e
dst
:
reg_g
srcloc
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Movaps
=
>
(
LegacyPrefix
:
:
None
0x0F28
)
SseOpcode
:
:
Movapd
=
>
(
LegacyPrefix
:
:
_66
0x0F28
)
SseOpcode
:
:
Movsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F10
)
SseOpcode
:
:
Movss
=
>
(
LegacyPrefix
:
:
_F3
0x0F10
)
SseOpcode
:
:
Movups
=
>
(
LegacyPrefix
:
:
None
0x0F10
)
SseOpcode
:
:
Movupd
=
>
(
LegacyPrefix
:
:
_66
0x0F10
)
SseOpcode
:
:
Sqrtps
=
>
(
LegacyPrefix
:
:
None
0x0F51
)
SseOpcode
:
:
Sqrtpd
=
>
(
LegacyPrefix
:
:
_66
0x0F51
)
SseOpcode
:
:
Sqrtss
=
>
(
LegacyPrefix
:
:
_F3
0x0F51
)
SseOpcode
:
:
Sqrtsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F51
)
SseOpcode
:
:
Cvtss2sd
=
>
(
LegacyPrefix
:
:
_F3
0x0F5A
)
SseOpcode
:
:
Cvtsd2ss
=
>
(
LegacyPrefix
:
:
_F2
0x0F5A
)
_
=
>
unimplemented
!
(
"
Opcode
{
:
?
}
not
implemented
"
op
)
}
;
match
src_e
{
RegMem
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
if
let
Some
(
srcloc
)
=
*
srcloc
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
emit_std_reg_mem
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
addr
rex
)
;
}
}
;
}
Inst
:
:
XMM_RM_R
{
op
src
:
src_e
dst
:
reg_g
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Addps
=
>
(
LegacyPrefix
:
:
None
0x0F58
)
SseOpcode
:
:
Addpd
=
>
(
LegacyPrefix
:
:
_66
0x0F58
)
SseOpcode
:
:
Addss
=
>
(
LegacyPrefix
:
:
_F3
0x0F58
)
SseOpcode
:
:
Addsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F58
)
SseOpcode
:
:
Andpd
=
>
(
LegacyPrefix
:
:
_66
0x0F54
)
SseOpcode
:
:
Andps
=
>
(
LegacyPrefix
:
:
None
0x0F54
)
SseOpcode
:
:
Andnps
=
>
(
LegacyPrefix
:
:
None
0x0F55
)
SseOpcode
:
:
Andnpd
=
>
(
LegacyPrefix
:
:
_66
0x0F55
)
SseOpcode
:
:
Divps
=
>
(
LegacyPrefix
:
:
None
0x0F5E
)
SseOpcode
:
:
Divpd
=
>
(
LegacyPrefix
:
:
_66
0x0F5E
)
SseOpcode
:
:
Divss
=
>
(
LegacyPrefix
:
:
_F3
0x0F5E
)
SseOpcode
:
:
Divsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F5E
)
SseOpcode
:
:
Minps
=
>
(
LegacyPrefix
:
:
None
0x0F5D
)
SseOpcode
:
:
Minpd
=
>
(
LegacyPrefix
:
:
_66
0x0F5D
)
SseOpcode
:
:
Minss
=
>
(
LegacyPrefix
:
:
_F3
0x0F5D
)
SseOpcode
:
:
Minsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F5D
)
SseOpcode
:
:
Maxps
=
>
(
LegacyPrefix
:
:
None
0x0F5F
)
SseOpcode
:
:
Maxpd
=
>
(
LegacyPrefix
:
:
_66
0x0F5F
)
SseOpcode
:
:
Maxss
=
>
(
LegacyPrefix
:
:
_F3
0x0F5F
)
SseOpcode
:
:
Maxsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F5F
)
SseOpcode
:
:
Mulps
=
>
(
LegacyPrefix
:
:
None
0x0F59
)
SseOpcode
:
:
Mulpd
=
>
(
LegacyPrefix
:
:
_66
0x0F59
)
SseOpcode
:
:
Mulss
=
>
(
LegacyPrefix
:
:
_F3
0x0F59
)
SseOpcode
:
:
Mulsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F59
)
SseOpcode
:
:
Orpd
=
>
(
LegacyPrefix
:
:
_66
0x0F56
)
SseOpcode
:
:
Orps
=
>
(
LegacyPrefix
:
:
None
0x0F56
)
SseOpcode
:
:
Subps
=
>
(
LegacyPrefix
:
:
None
0x0F5C
)
SseOpcode
:
:
Subpd
=
>
(
LegacyPrefix
:
:
_66
0x0F5C
)
SseOpcode
:
:
Subss
=
>
(
LegacyPrefix
:
:
_F3
0x0F5C
)
SseOpcode
:
:
Subsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F5C
)
SseOpcode
:
:
Xorps
=
>
(
LegacyPrefix
:
:
None
0x0F57
)
SseOpcode
:
:
Xorpd
=
>
(
LegacyPrefix
:
:
_66
0x0F57
)
_
=
>
unimplemented
!
(
"
Opcode
{
:
?
}
not
implemented
"
op
)
}
;
match
src_e
{
RegMem
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
addr
rex
)
;
}
}
}
Inst
:
:
XmmMinMaxSeq
{
size
is_min
lhs
rhs_dst
}
=
>
{
let
done
=
sink
.
get_label
(
)
;
let
propagate_nan
=
sink
.
get_label
(
)
;
let
do_min_max
=
sink
.
get_label
(
)
;
let
(
add_op
cmp_op
and_op
or_op
min_max_op
)
=
match
size
{
OperandSize
:
:
Size32
=
>
(
SseOpcode
:
:
Addss
SseOpcode
:
:
Ucomiss
SseOpcode
:
:
Andps
SseOpcode
:
:
Orps
if
*
is_min
{
SseOpcode
:
:
Minss
}
else
{
SseOpcode
:
:
Maxss
}
)
OperandSize
:
:
Size64
=
>
(
SseOpcode
:
:
Addsd
SseOpcode
:
:
Ucomisd
SseOpcode
:
:
Andpd
SseOpcode
:
:
Orpd
if
*
is_min
{
SseOpcode
:
:
Minsd
}
else
{
SseOpcode
:
:
Maxsd
}
)
}
;
let
inst
=
Inst
:
:
xmm_cmp_rm_r
(
cmp_op
RegMem
:
:
reg
(
*
lhs
)
rhs_dst
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
NZ
do_min_max
)
;
one_way_jmp
(
sink
CC
:
:
P
propagate_nan
)
;
let
op
=
if
*
is_min
{
or_op
}
else
{
and_op
}
;
let
inst
=
Inst
:
:
xmm_rm_r
(
op
RegMem
:
:
reg
(
*
lhs
)
*
rhs_dst
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done
)
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
propagate_nan
)
;
let
inst
=
Inst
:
:
xmm_rm_r
(
add_op
RegMem
:
:
reg
(
*
lhs
)
*
rhs_dst
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
P
done
)
;
sink
.
bind_label
(
do_min_max
)
;
let
inst
=
Inst
:
:
xmm_rm_r
(
min_max_op
RegMem
:
:
reg
(
*
lhs
)
*
rhs_dst
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
done
)
;
}
Inst
:
:
XmmRmRImm
{
op
src
dst
imm
}
=
>
{
let
prefix
=
match
op
{
SseOpcode
:
:
Cmpps
=
>
LegacyPrefix
:
:
_66
SseOpcode
:
:
Cmppd
=
>
LegacyPrefix
:
:
None
SseOpcode
:
:
Cmpss
=
>
LegacyPrefix
:
:
_F3
SseOpcode
:
:
Cmpsd
=
>
LegacyPrefix
:
:
_F2
_
=
>
unimplemented
!
(
"
Opcode
{
:
?
}
not
implemented
"
op
)
}
;
let
opcode
=
0x0FC2
;
let
rex
=
RexFlags
:
:
clear_w
(
)
;
match
src
{
RegMem
:
:
Reg
{
reg
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
dst
.
to_reg
(
)
*
reg
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
dst
.
to_reg
(
)
addr
rex
)
;
}
}
sink
.
put1
(
*
imm
)
}
Inst
:
:
XmmLoadConstSeq
{
val
dst
ty
}
=
>
{
let
opcode
=
match
*
ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Movups
types
:
:
F64X2
=
>
SseOpcode
:
:
Movupd
types
:
:
I8X16
=
>
SseOpcode
:
:
Movupd
_
=
>
unimplemented
!
(
"
cannot
yet
load
constants
for
type
:
{
}
"
ty
)
}
;
let
constant_start_label
=
sink
.
get_label
(
)
;
let
load_offset
=
RegMem
:
:
mem
(
Amode
:
:
rip_relative
(
BranchTarget
:
:
Label
(
constant_start_label
)
)
)
;
let
load
=
Inst
:
:
xmm_unary_rm_r
(
opcode
load_offset
*
dst
)
;
load
.
emit
(
sink
flags
state
)
;
let
constant_end_label
=
sink
.
get_label
(
)
;
let
continue_at_offset
=
BranchTarget
:
:
Label
(
constant_end_label
)
;
let
jump
=
Inst
:
:
jmp_known
(
continue_at_offset
)
;
jump
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
constant_start_label
)
;
for
i
in
val
.
iter
(
)
{
sink
.
put1
(
*
i
)
;
}
sink
.
bind_label
(
constant_end_label
)
;
}
Inst
:
:
Xmm_Mov_R_M
{
op
src
dst
srcloc
}
=
>
{
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Movss
=
>
(
LegacyPrefix
:
:
_F3
0x0F11
)
SseOpcode
:
:
Movsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F11
)
SseOpcode
:
:
Movaps
=
>
(
LegacyPrefix
:
:
None
0x0F29
)
SseOpcode
:
:
Movups
=
>
(
LegacyPrefix
:
:
None
0x0F11
)
_
=
>
unimplemented
!
(
"
Opcode
{
:
?
}
not
implemented
"
op
)
}
;
let
dst
=
&
dst
.
finalize
(
state
)
;
if
let
Some
(
srcloc
)
=
*
srcloc
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
emit_std_reg_mem
(
sink
prefix
opcode
2
*
src
dst
RexFlags
:
:
clear_w
(
)
)
;
}
Inst
:
:
XmmToGpr
{
op
src
dst
dst_size
}
=
>
{
let
(
prefix
opcode
dst_first
)
=
match
op
{
SseOpcode
:
:
Movd
|
SseOpcode
:
:
Movq
=
>
(
LegacyPrefix
:
:
_66
0x0F7E
false
)
SseOpcode
:
:
Cvttss2si
=
>
(
LegacyPrefix
:
:
_F3
0x0F2C
true
)
SseOpcode
:
:
Cvttsd2si
=
>
(
LegacyPrefix
:
:
_F2
0x0F2C
true
)
_
=
>
panic
!
(
"
unexpected
opcode
{
:
?
}
"
op
)
}
;
let
rex
=
match
dst_size
{
OperandSize
:
:
Size32
=
>
RexFlags
:
:
clear_w
(
)
OperandSize
:
:
Size64
=
>
RexFlags
:
:
set_w
(
)
}
;
let
(
src
dst
)
=
if
dst_first
{
(
dst
.
to_reg
(
)
*
src
)
}
else
{
(
*
src
dst
.
to_reg
(
)
)
}
;
emit_std_reg_reg
(
sink
prefix
opcode
2
src
dst
rex
)
;
}
Inst
:
:
GprToXmm
{
op
src
:
src_e
dst
:
reg_g
src_size
}
=
>
{
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Movd
|
SseOpcode
:
:
Movq
=
>
(
LegacyPrefix
:
:
_66
0x0F6E
)
SseOpcode
:
:
Cvtsi2ss
=
>
(
LegacyPrefix
:
:
_F3
0x0F2A
)
SseOpcode
:
:
Cvtsi2sd
=
>
(
LegacyPrefix
:
:
_F2
0x0F2A
)
_
=
>
panic
!
(
"
unexpected
opcode
{
:
?
}
"
op
)
}
;
let
rex
=
match
*
src_size
{
OperandSize
:
:
Size32
=
>
RexFlags
:
:
clear_w
(
)
OperandSize
:
:
Size64
=
>
RexFlags
:
:
set_w
(
)
}
;
match
src_e
{
RegMem
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
addr
rex
)
;
}
}
}
Inst
:
:
XMM_Cmp_RM_R
{
op
src
dst
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Ucomisd
=
>
(
LegacyPrefix
:
:
_66
0x0F2E
)
SseOpcode
:
:
Ucomiss
=
>
(
LegacyPrefix
:
:
None
0x0F2E
)
_
=
>
unimplemented
!
(
"
Emit
xmm
cmp
rm
r
"
)
}
;
match
src
{
RegMem
:
:
Reg
{
reg
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
*
dst
*
reg
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
*
dst
addr
rex
)
;
}
}
}
Inst
:
:
CvtUint64ToFloatSeq
{
to_f64
src
dst
tmp_gpr1
tmp_gpr2
}
=
>
{
assert
!
(
src
!
=
tmp_gpr1
)
;
assert
!
(
src
!
=
tmp_gpr2
)
;
assert
!
(
tmp_gpr1
!
=
tmp_gpr2
)
;
let
handle_negative
=
sink
.
get_label
(
)
;
let
done
=
sink
.
get_label
(
)
;
let
inst
=
Inst
:
:
cmp_rmi_r
(
8
RegMemImm
:
:
imm
(
0
)
src
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
L
handle_negative
)
;
emit_signed_cvt
(
sink
flags
state
src
.
to_reg
(
)
*
dst
*
to_f64
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done
)
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
handle_negative
)
;
let
inst
=
Inst
:
:
gen_move
(
*
tmp_gpr1
src
.
to_reg
(
)
I64
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
shift_r
(
true
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
*
tmp_gpr1
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
gen_move
(
*
tmp_gpr2
src
.
to_reg
(
)
I64
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
alu_rmi_r
(
true
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
1
)
*
tmp_gpr2
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
alu_rmi_r
(
true
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp_gpr1
.
to_reg
(
)
)
*
tmp_gpr2
)
;
inst
.
emit
(
sink
flags
state
)
;
emit_signed_cvt
(
sink
flags
state
tmp_gpr2
.
to_reg
(
)
*
dst
*
to_f64
)
;
let
add_op
=
if
*
to_f64
{
SseOpcode
:
:
Addsd
}
else
{
SseOpcode
:
:
Addss
}
;
let
inst
=
Inst
:
:
xmm_rm_r
(
add_op
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
done
)
;
}
Inst
:
:
CvtFloatToSintSeq
{
src_size
dst_size
is_saturating
src
dst
tmp_gpr
tmp_xmm
srcloc
}
=
>
{
let
src
=
src
.
to_reg
(
)
;
let
(
cast_op
cmp_op
trunc_op
)
=
match
src_size
{
OperandSize
:
:
Size64
=
>
(
SseOpcode
:
:
Movq
SseOpcode
:
:
Ucomisd
SseOpcode
:
:
Cvttsd2si
)
OperandSize
:
:
Size32
=
>
(
SseOpcode
:
:
Movd
SseOpcode
:
:
Ucomiss
SseOpcode
:
:
Cvttss2si
)
}
;
let
done
=
sink
.
get_label
(
)
;
let
not_nan
=
sink
.
get_label
(
)
;
let
inst
=
Inst
:
:
xmm_to_gpr
(
trunc_op
src
*
dst
*
dst_size
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
cmp_rmi_r
(
dst_size
.
to_bytes
(
)
RegMemImm
:
:
imm
(
1
)
dst
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
NO
done
)
;
let
inst
=
Inst
:
:
xmm_cmp_rm_r
(
cmp_op
RegMem
:
:
reg
(
src
)
src
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
NP
not_nan
)
;
if
*
is_saturating
{
let
inst
=
Inst
:
:
alu_rmi_r
(
*
dst_size
=
=
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst
.
to_reg
(
)
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done
)
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
not_nan
)
;
let
inst
=
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Xorpd
RegMem
:
:
reg
(
tmp_xmm
.
to_reg
(
)
)
*
tmp_xmm
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
xmm_cmp_rm_r
(
cmp_op
RegMem
:
:
reg
(
src
)
tmp_xmm
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
NB
done
)
;
if
*
dst_size
=
=
OperandSize
:
:
Size64
{
let
inst
=
Inst
:
:
imm_r
(
true
0x7fffffffffffffff
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
imm_r
(
false
0x7fffffff
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
}
}
else
{
let
check_positive
=
sink
.
get_label
(
)
;
let
inst
=
Inst
:
:
trap
(
*
srcloc
TrapCode
:
:
BadConversionToInteger
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
not_nan
)
;
let
mut
no_overflow_cc
=
CC
:
:
NB
;
let
output_bits
=
dst_size
.
to_bits
(
)
;
match
*
src_size
{
OperandSize
:
:
Size32
=
>
{
let
cst
=
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
.
bits
(
)
;
let
inst
=
Inst
:
:
imm32_r_unchecked
(
cst
as
u64
*
tmp_gpr
)
;
inst
.
emit
(
sink
flags
state
)
;
}
OperandSize
:
:
Size64
=
>
{
let
cst
=
if
output_bits
<
64
{
no_overflow_cc
=
CC
:
:
NBE
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
;
let
inst
=
Inst
:
:
imm_r
(
true
cst
.
bits
(
)
*
tmp_gpr
)
;
inst
.
emit
(
sink
flags
state
)
;
}
}
let
inst
=
Inst
:
:
gpr_to_xmm
(
cast_op
RegMem
:
:
reg
(
tmp_gpr
.
to_reg
(
)
)
*
src_size
*
tmp_xmm
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
xmm_cmp_rm_r
(
cmp_op
RegMem
:
:
reg
(
tmp_xmm
.
to_reg
(
)
)
src
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
no_overflow_cc
check_positive
)
;
let
inst
=
Inst
:
:
trap
(
*
srcloc
TrapCode
:
:
IntegerOverflow
)
;
inst
.
emit
(
sink
flags
state
)
;
sink
.
bind_label
(
check_positive
)
;
let
inst
=
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Xorpd
RegMem
:
:
reg
(
tmp_xmm
.
to_reg
(
)
)
*
tmp_xmm
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
xmm_cmp_rm_r
(
cmp_op
RegMem
:
:
reg
(
src
)
tmp_xmm
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
NB
done
)
;
let
inst
=
Inst
:
:
trap
(
*
srcloc
TrapCode
:
:
IntegerOverflow
)
;
inst
.
emit
(
sink
flags
state
)
;
}
sink
.
bind_label
(
done
)
;
}
Inst
:
:
CvtFloatToUintSeq
{
src_size
dst_size
is_saturating
src
dst
tmp_gpr
tmp_xmm
srcloc
}
=
>
{
assert
!
(
tmp_xmm
!
=
src
"
tmp_xmm
clobbers
src
!
"
)
;
let
(
sub_op
cast_op
cmp_op
trunc_op
)
=
if
*
src_size
=
=
OperandSize
:
:
Size64
{
(
SseOpcode
:
:
Subsd
SseOpcode
:
:
Movq
SseOpcode
:
:
Ucomisd
SseOpcode
:
:
Cvttsd2si
)
}
else
{
(
SseOpcode
:
:
Subss
SseOpcode
:
:
Movd
SseOpcode
:
:
Ucomiss
SseOpcode
:
:
Cvttss2si
)
}
;
let
done
=
sink
.
get_label
(
)
;
if
*
src_size
=
=
OperandSize
:
:
Size64
{
let
cst
=
Ieee64
:
:
pow2
(
dst_size
.
to_bits
(
)
-
1
)
.
bits
(
)
;
let
inst
=
Inst
:
:
imm_r
(
true
cst
*
tmp_gpr
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
cst
=
Ieee32
:
:
pow2
(
dst_size
.
to_bits
(
)
-
1
)
.
bits
(
)
as
u64
;
let
inst
=
Inst
:
:
imm32_r_unchecked
(
cst
*
tmp_gpr
)
;
inst
.
emit
(
sink
flags
state
)
;
}
let
inst
=
Inst
:
:
gpr_to_xmm
(
cast_op
RegMem
:
:
reg
(
tmp_gpr
.
to_reg
(
)
)
*
src_size
*
tmp_xmm
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
xmm_cmp_rm_r
(
cmp_op
RegMem
:
:
reg
(
tmp_xmm
.
to_reg
(
)
)
src
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
let
handle_large
=
sink
.
get_label
(
)
;
one_way_jmp
(
sink
CC
:
:
NB
handle_large
)
;
let
not_nan
=
sink
.
get_label
(
)
;
one_way_jmp
(
sink
CC
:
:
NP
not_nan
)
;
if
*
is_saturating
{
let
inst
=
Inst
:
:
alu_rmi_r
(
*
dst_size
=
=
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst
.
to_reg
(
)
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done
)
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
trap
(
*
srcloc
TrapCode
:
:
BadConversionToInteger
)
;
inst
.
emit
(
sink
flags
state
)
;
}
sink
.
bind_label
(
not_nan
)
;
let
inst
=
Inst
:
:
xmm_to_gpr
(
trunc_op
src
.
to_reg
(
)
*
dst
*
dst_size
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
cmp_rmi_r
(
dst_size
.
to_bytes
(
)
RegMemImm
:
:
imm
(
0
)
dst
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
one_way_jmp
(
sink
CC
:
:
NL
done
)
;
if
*
is_saturating
{
let
inst
=
Inst
:
:
alu_rmi_r
(
*
dst_size
=
=
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst
.
to_reg
(
)
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done
)
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
trap
(
*
srcloc
TrapCode
:
:
IntegerOverflow
)
;
inst
.
emit
(
sink
flags
state
)
;
}
sink
.
bind_label
(
handle_large
)
;
let
inst
=
Inst
:
:
xmm_rm_r
(
sub_op
RegMem
:
:
reg
(
tmp_xmm
.
to_reg
(
)
)
*
src
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
xmm_to_gpr
(
trunc_op
src
.
to_reg
(
)
*
dst
*
dst_size
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
cmp_rmi_r
(
dst_size
.
to_bytes
(
)
RegMemImm
:
:
imm
(
0
)
dst
.
to_reg
(
)
)
;
inst
.
emit
(
sink
flags
state
)
;
let
next_is_large
=
sink
.
get_label
(
)
;
one_way_jmp
(
sink
CC
:
:
NL
next_is_large
)
;
if
*
is_saturating
{
let
inst
=
Inst
:
:
imm_r
(
true
if
*
dst_size
=
=
OperandSize
:
:
Size64
{
u64
:
:
max_value
(
)
}
else
{
u32
:
:
max_value
(
)
as
u64
}
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
done
)
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
trap
(
*
srcloc
TrapCode
:
:
IntegerOverflow
)
;
inst
.
emit
(
sink
flags
state
)
;
}
sink
.
bind_label
(
next_is_large
)
;
if
*
dst_size
=
=
OperandSize
:
:
Size64
{
let
inst
=
Inst
:
:
imm_r
(
true
1
<
<
63
*
tmp_gpr
)
;
inst
.
emit
(
sink
flags
state
)
;
let
inst
=
Inst
:
:
alu_rmi_r
(
true
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp_gpr
.
to_reg
(
)
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
}
else
{
let
inst
=
Inst
:
:
alu_rmi_r
(
false
AluRmiROpcode
:
:
Add
RegMemImm
:
:
imm
(
1
<
<
31
)
*
dst
)
;
inst
.
emit
(
sink
flags
state
)
;
}
sink
.
bind_label
(
done
)
;
}
Inst
:
:
LoadExtName
{
dst
name
offset
srcloc
}
=
>
{
let
enc_dst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
sink
.
put1
(
0x48
|
(
(
enc_dst
>
>
3
)
&
1
)
)
;
sink
.
put1
(
0xB8
|
(
enc_dst
&
7
)
)
;
sink
.
add_reloc
(
*
srcloc
Reloc
:
:
Abs8
name
*
offset
)
;
if
flags
.
emit_all_ones_funcaddrs
(
)
{
sink
.
put8
(
u64
:
:
max_value
(
)
)
;
}
else
{
sink
.
put8
(
0
)
;
}
}
Inst
:
:
Hlt
=
>
{
sink
.
put1
(
0xcc
)
;
}
Inst
:
:
Ud2
{
trap_info
}
=
>
{
sink
.
add_trap
(
trap_info
.
0
trap_info
.
1
)
;
if
let
Some
(
s
)
=
state
.
take_stackmap
(
)
{
sink
.
add_stackmap
(
StackmapExtent
:
:
UpcomingBytes
(
2
)
s
)
;
}
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
0x0b
)
;
}
Inst
:
:
VirtualSPOffsetAdj
{
offset
}
=
>
{
debug
!
(
"
virtual
sp
offset
adjusted
by
{
}
-
>
{
}
"
offset
state
.
virtual_sp_offset
+
offset
)
;
state
.
virtual_sp_offset
+
=
offset
;
}
Inst
:
:
Nop
{
.
.
}
|
Inst
:
:
EpiloguePlaceholder
=
>
{
}
}
state
.
clear_post_insn
(
)
;
}
