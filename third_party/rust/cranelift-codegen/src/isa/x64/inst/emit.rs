use
regalloc
:
:
{
Reg
RegClass
}
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
*
;
fn
low8willSXto64
(
x
:
u32
)
-
>
bool
{
let
xs
=
(
x
as
i32
)
as
i64
;
xs
=
=
(
(
xs
<
<
56
)
>
>
56
)
}
fn
low8willSXto32
(
x
:
u32
)
-
>
bool
{
let
xs
=
x
as
i32
;
xs
=
=
(
(
xs
<
<
24
)
>
>
24
)
}
#
[
inline
(
always
)
]
fn
mkModRegRM
(
m0d
:
u8
encRegG
:
u8
rmE
:
u8
)
-
>
u8
{
debug_assert
!
(
m0d
<
4
)
;
debug_assert
!
(
encRegG
<
8
)
;
debug_assert
!
(
rmE
<
8
)
;
(
(
m0d
&
3
)
<
<
6
)
|
(
(
encRegG
&
7
)
<
<
3
)
|
(
rmE
&
7
)
}
#
[
inline
(
always
)
]
fn
mkSIB
(
shift
:
u8
encIndex
:
u8
encBase
:
u8
)
-
>
u8
{
debug_assert
!
(
shift
<
4
)
;
debug_assert
!
(
encIndex
<
8
)
;
debug_assert
!
(
encBase
<
8
)
;
(
(
shift
&
3
)
<
<
6
)
|
(
(
encIndex
&
7
)
<
<
3
)
|
(
encBase
&
7
)
}
#
[
inline
(
always
)
]
fn
iregEnc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
debug_assert
!
(
reg
.
get_class
(
)
=
=
RegClass
:
:
I64
)
;
reg
.
get_hw_encoding
(
)
}
const
F_NONE
:
u32
=
0
;
const
F_RETAIN_REDUNDANT_REX
:
u32
=
1
;
const
F_CLEAR_REX_W
:
u32
=
2
;
const
F_PREFIX_66
:
u32
=
4
;
fn
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
(
sink
:
&
mut
MachBuffer
<
Inst
>
opcodes
:
u32
mut
numOpcodes
:
usize
encG
:
u8
memE
:
&
Addr
flags
:
u32
)
{
let
prefix66
=
(
flags
&
F_PREFIX_66
)
!
=
0
;
let
clearRexW
=
(
flags
&
F_CLEAR_REX_W
)
!
=
0
;
let
retainRedundant
=
(
flags
&
F_RETAIN_REDUNDANT_REX
)
!
=
0
;
if
prefix66
{
sink
.
put1
(
0x66
)
;
}
match
memE
{
Addr
:
:
IR
{
simm32
base
:
regE
}
=
>
{
let
encE
=
iregEnc
(
*
regE
)
;
let
w
=
if
clearRexW
{
0
}
else
{
1
}
;
let
r
=
(
encG
>
>
3
)
&
1
;
let
x
=
0
;
let
b
=
(
encE
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
retainRedundant
{
sink
.
put1
(
rex
)
;
}
while
numOpcodes
>
0
{
numOpcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
numOpcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
*
simm32
=
=
0
&
&
encE
!
=
regs
:
:
ENC_RSP
&
&
encE
!
=
regs
:
:
ENC_RBP
&
&
encE
!
=
regs
:
:
ENC_R12
&
&
encE
!
=
regs
:
:
ENC_R13
{
sink
.
put1
(
mkModRegRM
(
0
encG
&
7
encE
&
7
)
)
;
}
else
if
*
simm32
=
=
0
&
&
(
encE
=
=
regs
:
:
ENC_RSP
|
|
encE
=
=
regs
:
:
ENC_R12
)
{
sink
.
put1
(
mkModRegRM
(
0
encG
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
}
else
if
low8willSXto32
(
*
simm32
)
&
&
encE
!
=
regs
:
:
ENC_RSP
&
&
encE
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
mkModRegRM
(
1
encG
&
7
encE
&
7
)
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
encE
!
=
regs
:
:
ENC_RSP
&
&
encE
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
mkModRegRM
(
2
encG
&
7
encE
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
if
(
encE
=
=
regs
:
:
ENC_RSP
|
|
encE
=
=
regs
:
:
ENC_R12
)
&
&
low8willSXto32
(
*
simm32
)
{
sink
.
put1
(
mkModRegRM
(
1
encG
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
encE
=
=
regs
:
:
ENC_R12
|
|
encE
=
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
mkModRegRM
(
2
encG
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
unreachable
!
(
"
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
:
IR
"
)
;
}
}
Addr
:
:
IRRS
{
simm32
base
:
regBase
index
:
regIndex
shift
}
=
>
{
let
encBase
=
iregEnc
(
*
regBase
)
;
let
encIndex
=
iregEnc
(
*
regIndex
)
;
let
w
=
if
clearRexW
{
0
}
else
{
1
}
;
let
r
=
(
encG
>
>
3
)
&
1
;
let
x
=
(
encIndex
>
>
3
)
&
1
;
let
b
=
(
encBase
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
retainRedundant
{
sink
.
put1
(
rex
)
;
}
while
numOpcodes
>
0
{
numOpcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
numOpcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
low8willSXto32
(
*
simm32
)
&
&
encIndex
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
mkModRegRM
(
1
encG
&
7
4
)
)
;
sink
.
put1
(
mkSIB
(
*
shift
encIndex
&
7
encBase
&
7
)
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
if
encIndex
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
mkModRegRM
(
2
encG
&
7
4
)
)
;
sink
.
put1
(
mkSIB
(
*
shift
encIndex
&
7
encBase
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
panic
!
(
"
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
:
IRRS
"
)
;
}
}
}
}
fn
emit_REX_OPCODES_MODRM_encG_encE
(
sink
:
&
mut
MachBuffer
<
Inst
>
opcodes
:
u32
mut
numOpcodes
:
usize
encG
:
u8
encE
:
u8
flags
:
u32
)
{
let
prefix66
=
(
flags
&
F_PREFIX_66
)
!
=
0
;
let
clearRexW
=
(
flags
&
F_CLEAR_REX_W
)
!
=
0
;
let
retainRedundant
=
(
flags
&
F_RETAIN_REDUNDANT_REX
)
!
=
0
;
if
prefix66
{
sink
.
put1
(
0x66
)
;
}
let
w
=
if
clearRexW
{
0
}
else
{
1
}
;
let
r
=
(
encG
>
>
3
)
&
1
;
let
x
=
0
;
let
b
=
(
encE
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
retainRedundant
{
sink
.
put1
(
rex
)
;
}
while
numOpcodes
>
0
{
numOpcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
numOpcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
sink
.
put1
(
mkModRegRM
(
3
encG
&
7
encE
&
7
)
)
;
}
fn
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
:
&
mut
MachBuffer
<
Inst
>
opcodes
:
u32
numOpcodes
:
usize
regG
:
Reg
memE
:
&
Addr
flags
:
u32
)
{
let
encG
=
iregEnc
(
regG
)
;
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
(
sink
opcodes
numOpcodes
encG
memE
flags
)
;
}
fn
emit_REX_OPCODES_MODRM_regG_regE
(
sink
:
&
mut
MachBuffer
<
Inst
>
opcodes
:
u32
numOpcodes
:
usize
regG
:
Reg
regE
:
Reg
flags
:
u32
)
{
let
encG
=
iregEnc
(
regG
)
;
let
encE
=
iregEnc
(
regE
)
;
emit_REX_OPCODES_MODRM_encG_encE
(
sink
opcodes
numOpcodes
encG
encE
flags
)
;
}
fn
emit_simm
(
sink
:
&
mut
MachBuffer
<
Inst
>
size
:
u8
simm32
:
u32
)
{
match
size
{
8
|
4
=
>
sink
.
put4
(
simm32
)
2
=
>
sink
.
put2
(
simm32
as
u16
)
1
=
>
sink
.
put1
(
simm32
as
u8
)
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
emit_simm
:
unreachable
"
)
}
}
pub
(
crate
)
fn
emit
(
inst
:
&
Inst
sink
:
&
mut
MachBuffer
<
Inst
>
)
{
match
inst
{
Inst
:
:
Nop
{
len
:
0
}
=
>
{
}
Inst
:
:
Alu_RMI_R
{
is_64
op
src
:
srcE
dst
:
regG
}
=
>
{
let
flags
=
if
*
is_64
{
F_NONE
}
else
{
F_CLEAR_REX_W
}
;
if
*
op
=
=
RMI_R_Op
:
:
Mul
{
match
srcE
{
RMI
:
:
R
{
reg
:
regE
}
=
>
{
emit_REX_OPCODES_MODRM_regG_regE
(
sink
0x0FAF
2
regG
.
to_reg
(
)
*
regE
flags
)
;
}
RMI
:
:
M
{
addr
}
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FAF
2
regG
.
to_reg
(
)
addr
flags
)
;
}
RMI
:
:
I
{
simm32
}
=
>
{
let
useImm8
=
low8willSXto32
(
*
simm32
)
;
let
opcode
=
if
useImm8
{
0x6B
}
else
{
0x69
}
;
emit_REX_OPCODES_MODRM_regG_regE
(
sink
opcode
1
regG
.
to_reg
(
)
regG
.
to_reg
(
)
flags
)
;
emit_simm
(
sink
if
useImm8
{
1
}
else
{
4
}
*
simm32
)
;
}
}
}
else
{
let
(
opcode_R
opcode_M
subopcode_I
)
=
match
op
{
RMI_R_Op
:
:
Add
=
>
(
0x01
0x03
0
)
RMI_R_Op
:
:
Sub
=
>
(
0x29
0x2B
5
)
RMI_R_Op
:
:
And
=
>
(
0x21
0x23
4
)
RMI_R_Op
:
:
Or
=
>
(
0x09
0x0B
1
)
RMI_R_Op
:
:
Xor
=
>
(
0x31
0x33
6
)
RMI_R_Op
:
:
Mul
=
>
panic
!
(
"
unreachable
"
)
}
;
match
srcE
{
RMI
:
:
R
{
reg
:
regE
}
=
>
{
emit_REX_OPCODES_MODRM_regG_regE
(
sink
opcode_R
1
*
regE
regG
.
to_reg
(
)
flags
)
;
}
RMI
:
:
M
{
addr
}
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
opcode_M
1
regG
.
to_reg
(
)
addr
flags
)
;
}
RMI
:
:
I
{
simm32
}
=
>
{
let
useImm8
=
low8willSXto32
(
*
simm32
)
;
let
opcode
=
if
useImm8
{
0x83
}
else
{
0x81
}
;
let
encG
=
iregEnc
(
regG
.
to_reg
(
)
)
;
emit_REX_OPCODES_MODRM_encG_encE
(
sink
opcode
1
subopcode_I
encG
flags
)
;
emit_simm
(
sink
if
useImm8
{
1
}
else
{
4
}
*
simm32
)
;
}
}
}
}
Inst
:
:
Imm_R
{
dst_is_64
simm64
dst
}
=
>
{
let
encDst
=
iregEnc
(
dst
.
to_reg
(
)
)
;
if
*
dst_is_64
{
sink
.
put1
(
0x48
|
(
(
encDst
>
>
3
)
&
1
)
)
;
sink
.
put1
(
0xB8
|
(
encDst
&
7
)
)
;
sink
.
put8
(
*
simm64
)
;
}
else
{
if
(
(
encDst
>
>
3
)
&
1
)
=
=
1
{
sink
.
put1
(
0x41
)
;
}
sink
.
put1
(
0xB8
|
(
encDst
&
7
)
)
;
sink
.
put4
(
*
simm64
as
u32
)
;
}
}
Inst
:
:
Mov_R_R
{
is_64
src
dst
}
=
>
{
let
flags
=
if
*
is_64
{
F_NONE
}
else
{
F_CLEAR_REX_W
}
;
emit_REX_OPCODES_MODRM_regG_regE
(
sink
0x89
1
*
src
dst
.
to_reg
(
)
flags
)
;
}
Inst
:
:
MovZX_M_R
{
extMode
addr
dst
}
=
>
{
match
extMode
{
ExtMode
:
:
BL
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FB6
2
dst
.
to_reg
(
)
addr
F_CLEAR_REX_W
)
}
ExtMode
:
:
BQ
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FB6
2
dst
.
to_reg
(
)
addr
F_NONE
)
}
ExtMode
:
:
WL
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FB7
2
dst
.
to_reg
(
)
addr
F_CLEAR_REX_W
)
}
ExtMode
:
:
WQ
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FB7
2
dst
.
to_reg
(
)
addr
F_NONE
)
}
ExtMode
:
:
LQ
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x8B
1
dst
.
to_reg
(
)
addr
F_CLEAR_REX_W
)
}
}
}
Inst
:
:
Mov64_M_R
{
addr
dst
}
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x8B
1
dst
.
to_reg
(
)
addr
F_NONE
)
}
Inst
:
:
MovSX_M_R
{
extMode
addr
dst
}
=
>
{
match
extMode
{
ExtMode
:
:
BL
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FBE
2
dst
.
to_reg
(
)
addr
F_CLEAR_REX_W
)
}
ExtMode
:
:
BQ
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FBE
2
dst
.
to_reg
(
)
addr
F_NONE
)
}
ExtMode
:
:
WL
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FBF
2
dst
.
to_reg
(
)
addr
F_CLEAR_REX_W
)
}
ExtMode
:
:
WQ
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x0FBF
2
dst
.
to_reg
(
)
addr
F_NONE
)
}
ExtMode
:
:
LQ
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x63
1
dst
.
to_reg
(
)
addr
F_NONE
)
}
}
}
Inst
:
:
Mov_R_M
{
size
src
addr
}
=
>
{
match
size
{
1
=
>
{
let
encSrc
=
iregEnc
(
*
src
)
;
let
retainRedundantRex
=
if
encSrc
>
=
4
&
&
encSrc
<
=
7
{
F_RETAIN_REDUNDANT_REX
}
else
{
0
}
;
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x88
1
*
src
addr
F_CLEAR_REX_W
|
retainRedundantRex
)
}
2
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x89
1
*
src
addr
F_CLEAR_REX_W
|
F_PREFIX_66
)
}
4
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x89
1
*
src
addr
F_CLEAR_REX_W
)
}
8
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
0x89
1
*
src
addr
F_NONE
)
}
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
Mov_R_M
:
:
emit
:
unreachable
"
)
}
}
Inst
:
:
Shift_R
{
is_64
kind
num_bits
dst
}
=
>
{
let
encDst
=
iregEnc
(
dst
.
to_reg
(
)
)
;
let
subopcode
=
match
kind
{
ShiftKind
:
:
Left
=
>
4
ShiftKind
:
:
RightZ
=
>
5
ShiftKind
:
:
RightS
=
>
7
}
;
match
num_bits
{
None
=
>
{
emit_REX_OPCODES_MODRM_encG_encE
(
sink
0xD3
1
subopcode
encDst
if
*
is_64
{
F_NONE
}
else
{
F_CLEAR_REX_W
}
)
;
}
Some
(
num_bits
)
=
>
{
emit_REX_OPCODES_MODRM_encG_encE
(
sink
0xC1
1
subopcode
encDst
if
*
is_64
{
F_NONE
}
else
{
F_CLEAR_REX_W
}
)
;
sink
.
put1
(
*
num_bits
)
;
}
}
}
Inst
:
:
Cmp_RMI_R
{
size
src
:
srcE
dst
:
regG
}
=
>
{
let
mut
retainRedundantRex
=
0
;
if
*
size
=
=
1
{
let
encG
=
iregEnc
(
*
regG
)
;
if
encG
>
=
4
&
&
encG
<
=
7
{
retainRedundantRex
=
F_RETAIN_REDUNDANT_REX
;
}
}
let
mut
flags
=
match
size
{
8
=
>
F_NONE
4
=
>
F_CLEAR_REX_W
2
=
>
F_CLEAR_REX_W
|
F_PREFIX_66
1
=
>
F_CLEAR_REX_W
|
retainRedundantRex
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
Cmp_RMI_R
:
:
emit
:
unreachable
"
)
}
;
match
srcE
{
RMI
:
:
R
{
reg
:
regE
}
=
>
{
let
opcode
=
if
*
size
=
=
1
{
0x38
}
else
{
0x39
}
;
if
*
size
=
=
1
{
let
encE
=
iregEnc
(
*
regE
)
;
if
encE
>
=
4
&
&
encE
<
=
7
{
flags
|
=
F_RETAIN_REDUNDANT_REX
;
}
}
emit_REX_OPCODES_MODRM_regG_regE
(
sink
opcode
1
*
regE
*
regG
flags
)
;
}
RMI
:
:
M
{
addr
}
=
>
{
let
opcode
=
if
*
size
=
=
1
{
0x3A
}
else
{
0x3B
}
;
emit_REX_OPCODES_MODRM_SIB_IMM_regG_memE
(
sink
opcode
1
*
regG
addr
flags
)
;
}
RMI
:
:
I
{
simm32
}
=
>
{
let
useImm8
=
low8willSXto32
(
*
simm32
)
;
let
opcode
=
if
*
size
=
=
1
{
0x80
}
else
if
useImm8
{
0x83
}
else
{
0x81
}
;
let
encG
=
iregEnc
(
*
regG
)
;
emit_REX_OPCODES_MODRM_encG_encE
(
sink
opcode
1
7
encG
flags
)
;
emit_simm
(
sink
if
useImm8
{
1
}
else
{
*
size
}
*
simm32
)
;
}
}
}
Inst
:
:
Push64
{
src
}
=
>
{
match
src
{
RMI
:
:
R
{
reg
}
=
>
{
let
encReg
=
iregEnc
(
*
reg
)
;
let
rex
=
0x40
|
(
(
encReg
>
>
3
)
&
1
)
;
if
rex
!
=
0x40
{
sink
.
put1
(
rex
)
;
}
sink
.
put1
(
0x50
|
(
encReg
&
7
)
)
;
}
RMI
:
:
M
{
addr
}
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
(
sink
0xFF
1
6
addr
F_CLEAR_REX_W
)
;
}
RMI
:
:
I
{
simm32
}
=
>
{
if
low8willSXto64
(
*
simm32
)
{
sink
.
put1
(
0x6A
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
{
sink
.
put1
(
0x68
)
;
sink
.
put4
(
*
simm32
)
;
}
}
}
}
Inst
:
:
Pop64
{
dst
}
=
>
{
let
encDst
=
iregEnc
(
dst
.
to_reg
(
)
)
;
if
encDst
>
=
8
{
sink
.
put1
(
0x41
)
;
}
sink
.
put1
(
0x58
+
(
encDst
&
7
)
)
;
}
Inst
:
:
CallUnknown
{
dest
}
=
>
{
match
dest
{
RM
:
:
R
{
reg
}
=
>
{
let
regEnc
=
iregEnc
(
*
reg
)
;
emit_REX_OPCODES_MODRM_encG_encE
(
sink
0xFF
1
2
regEnc
F_CLEAR_REX_W
)
;
}
RM
:
:
M
{
addr
}
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
(
sink
0xFF
1
2
addr
F_CLEAR_REX_W
)
;
}
}
}
Inst
:
:
Ret
{
}
=
>
sink
.
put1
(
0xC3
)
Inst
:
:
JmpKnown
{
dest
}
=
>
{
let
disp
=
dest
.
as_offset32_or_zero
(
)
-
5
;
let
disp
=
disp
as
u32
;
let
br_start
=
sink
.
cur_offset
(
)
;
let
br_disp_off
=
br_start
+
1
;
let
br_end
=
br_start
+
5
;
if
let
Some
(
l
)
=
dest
.
as_label
(
)
{
sink
.
use_label_at_offset
(
br_disp_off
l
LabelUse
:
:
Rel32
)
;
sink
.
add_uncond_branch
(
br_start
br_end
l
)
;
}
sink
.
put1
(
0xE9
)
;
sink
.
put4
(
disp
)
;
}
Inst
:
:
JmpCondSymm
{
cc
taken
not_taken
}
=
>
{
let
taken_disp
=
taken
.
as_offset32_or_zero
(
)
-
6
;
let
taken_disp
=
taken_disp
as
u32
;
let
cond_start
=
sink
.
cur_offset
(
)
;
let
cond_disp_off
=
cond_start
+
2
;
let
cond_end
=
cond_start
+
6
;
if
let
Some
(
l
)
=
taken
.
as_label
(
)
{
sink
.
use_label_at_offset
(
cond_disp_off
l
LabelUse
:
:
Rel32
)
;
let
inverted
:
[
u8
;
6
]
=
[
0x0F
0x80
+
(
cc
.
invert
(
)
.
get_enc
(
)
)
0xFA
0xFF
0xFF
0xFF
]
;
sink
.
add_cond_branch
(
cond_start
cond_end
l
&
inverted
[
.
.
]
)
;
}
sink
.
put1
(
0x0F
)
;
sink
.
put1
(
0x80
+
cc
.
get_enc
(
)
)
;
sink
.
put4
(
taken_disp
)
;
let
nt_disp
=
not_taken
.
as_offset32_or_zero
(
)
-
5
;
let
nt_disp
=
nt_disp
as
u32
;
let
uncond_start
=
sink
.
cur_offset
(
)
;
let
uncond_disp_off
=
uncond_start
+
1
;
let
uncond_end
=
uncond_start
+
5
;
if
let
Some
(
l
)
=
not_taken
.
as_label
(
)
{
sink
.
use_label_at_offset
(
uncond_disp_off
l
LabelUse
:
:
Rel32
)
;
sink
.
add_uncond_branch
(
uncond_start
uncond_end
l
)
;
}
sink
.
put1
(
0xE9
)
;
sink
.
put4
(
nt_disp
)
;
}
Inst
:
:
JmpUnknown
{
target
}
=
>
{
match
target
{
RM
:
:
R
{
reg
}
=
>
{
let
regEnc
=
iregEnc
(
*
reg
)
;
emit_REX_OPCODES_MODRM_encG_encE
(
sink
0xFF
1
4
regEnc
F_CLEAR_REX_W
)
;
}
RM
:
:
M
{
addr
}
=
>
{
emit_REX_OPCODES_MODRM_SIB_IMM_encG_memE
(
sink
0xFF
1
4
addr
F_CLEAR_REX_W
)
;
}
}
}
_
=
>
panic
!
(
"
x64_emit
:
unhandled
:
{
}
"
inst
.
show_rru
(
None
)
)
}
}
