use
log
:
:
debug
;
use
regalloc
:
:
Reg
;
use
crate
:
:
binemit
:
:
Reloc
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
*
;
fn
low8_will_sign_extend_to_64
(
x
:
u32
)
-
>
bool
{
let
xs
=
(
x
as
i32
)
as
i64
;
xs
=
=
(
(
xs
<
<
56
)
>
>
56
)
}
fn
low8_will_sign_extend_to_32
(
x
:
u32
)
-
>
bool
{
let
xs
=
x
as
i32
;
xs
=
=
(
(
xs
<
<
24
)
>
>
24
)
}
#
[
inline
(
always
)
]
fn
encode_modrm
(
m0d
:
u8
enc_reg_g
:
u8
rm_e
:
u8
)
-
>
u8
{
debug_assert
!
(
m0d
<
4
)
;
debug_assert
!
(
enc_reg_g
<
8
)
;
debug_assert
!
(
rm_e
<
8
)
;
(
(
m0d
&
3
)
<
<
6
)
|
(
(
enc_reg_g
&
7
)
<
<
3
)
|
(
rm_e
&
7
)
}
#
[
inline
(
always
)
]
fn
encode_sib
(
shift
:
u8
enc_index
:
u8
enc_base
:
u8
)
-
>
u8
{
debug_assert
!
(
shift
<
4
)
;
debug_assert
!
(
enc_index
<
8
)
;
debug_assert
!
(
enc_base
<
8
)
;
(
(
shift
&
3
)
<
<
6
)
|
(
(
enc_index
&
7
)
<
<
3
)
|
(
enc_base
&
7
)
}
#
[
inline
(
always
)
]
fn
int_reg_enc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
debug_assert_eq
!
(
reg
.
get_class
(
)
RegClass
:
:
I64
)
;
reg
.
get_hw_encoding
(
)
}
#
[
inline
(
always
)
]
fn
reg_enc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
reg
.
get_hw_encoding
(
)
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Copy
)
]
struct
RexFlags
(
u8
)
;
impl
RexFlags
{
#
[
inline
(
always
)
]
fn
set_w
(
)
-
>
Self
{
Self
(
0
)
}
#
[
inline
(
always
)
]
fn
clear_w
(
)
-
>
Self
{
Self
(
1
)
}
#
[
inline
(
always
)
]
fn
always_emit
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
0
=
self
.
0
|
2
;
self
}
#
[
inline
(
always
)
]
fn
must_clear_w
(
&
self
)
-
>
bool
{
(
self
.
0
&
1
)
!
=
0
}
#
[
inline
(
always
)
]
fn
must_always_emit
(
&
self
)
-
>
bool
{
(
self
.
0
&
2
)
!
=
0
}
#
[
inline
(
always
)
]
fn
emit_two_op
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
enc_g
:
u8
enc_e
:
u8
)
{
let
w
=
if
self
.
must_clear_w
(
)
{
0
}
else
{
1
}
;
let
r
=
(
enc_g
>
>
3
)
&
1
;
let
x
=
0
;
let
b
=
(
enc_e
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
self
.
must_always_emit
(
)
{
sink
.
put1
(
rex
)
;
}
}
#
[
inline
(
always
)
]
fn
emit_three_op
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
enc_g
:
u8
enc_index
:
u8
enc_base
:
u8
)
{
let
w
=
if
self
.
must_clear_w
(
)
{
0
}
else
{
1
}
;
let
r
=
(
enc_g
>
>
3
)
&
1
;
let
x
=
(
enc_index
>
>
3
)
&
1
;
let
b
=
(
enc_base
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
self
.
must_always_emit
(
)
{
sink
.
put1
(
rex
)
;
}
}
}
enum
LegacyPrefix
{
None
_66
_F2
_F3
}
impl
LegacyPrefix
{
#
[
inline
(
always
)
]
fn
emit
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
)
{
match
self
{
LegacyPrefix
:
:
_66
=
>
sink
.
put1
(
0x66
)
LegacyPrefix
:
:
_F2
=
>
sink
.
put1
(
0xF2
)
LegacyPrefix
:
:
_F3
=
>
sink
.
put1
(
0xF3
)
LegacyPrefix
:
:
None
=
>
(
)
}
}
}
fn
emit_std_enc_mem
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
mut
num_opcodes
:
usize
enc_g
:
u8
mem_e
:
&
Amode
rex
:
RexFlags
)
{
prefix
.
emit
(
sink
)
;
match
mem_e
{
Amode
:
:
ImmReg
{
simm32
base
}
=
>
{
let
enc_e
=
int_reg_enc
(
*
base
)
;
rex
.
emit_two_op
(
sink
enc_g
enc_e
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
*
simm32
=
=
0
&
&
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_RBP
&
&
enc_e
!
=
regs
:
:
ENC_R12
&
&
enc_e
!
=
regs
:
:
ENC_R13
{
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
enc_e
&
7
)
)
;
}
else
if
*
simm32
=
=
0
&
&
(
enc_e
=
=
regs
:
:
ENC_RSP
|
|
enc_e
=
=
regs
:
:
ENC_R12
)
{
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
}
else
if
low8_will_sign_extend_to_32
(
*
simm32
)
&
&
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
enc_e
&
7
)
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
enc_e
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
if
(
enc_e
=
=
regs
:
:
ENC_RSP
|
|
enc_e
=
=
regs
:
:
ENC_R12
)
&
&
low8_will_sign_extend_to_32
(
*
simm32
)
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
enc_e
=
=
regs
:
:
ENC_R12
|
|
enc_e
=
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
unreachable
!
(
"
ImmReg
"
)
;
}
}
Amode
:
:
ImmRegRegShift
{
simm32
base
:
reg_base
index
:
reg_index
shift
}
=
>
{
let
enc_base
=
int_reg_enc
(
*
reg_base
)
;
let
enc_index
=
int_reg_enc
(
*
reg_index
)
;
rex
.
emit_three_op
(
sink
enc_g
enc_index
enc_base
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
low8_will_sign_extend_to_32
(
*
simm32
)
&
&
enc_index
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
4
)
)
;
sink
.
put1
(
encode_sib
(
*
shift
enc_index
&
7
enc_base
&
7
)
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
if
enc_index
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
4
)
)
;
sink
.
put1
(
encode_sib
(
*
shift
enc_index
&
7
enc_base
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
panic
!
(
"
ImmRegRegShift
"
)
;
}
}
}
}
fn
emit_std_enc_enc
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
mut
num_opcodes
:
usize
enc_g
:
u8
enc_e
:
u8
rex
:
RexFlags
)
{
prefix
.
emit
(
sink
)
;
rex
.
emit_two_op
(
sink
enc_g
enc_e
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
sink
.
put1
(
encode_modrm
(
3
enc_g
&
7
enc_e
&
7
)
)
;
}
fn
emit_std_reg_mem
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
num_opcodes
:
usize
reg_g
:
Reg
mem_e
:
&
Amode
rex
:
RexFlags
)
{
let
enc_g
=
reg_enc
(
reg_g
)
;
emit_std_enc_mem
(
sink
prefix
opcodes
num_opcodes
enc_g
mem_e
rex
)
;
}
fn
emit_std_reg_reg
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefix
:
LegacyPrefix
opcodes
:
u32
num_opcodes
:
usize
reg_g
:
Reg
reg_e
:
Reg
rex
:
RexFlags
)
{
let
enc_g
=
reg_enc
(
reg_g
)
;
let
enc_e
=
reg_enc
(
reg_e
)
;
emit_std_enc_enc
(
sink
prefix
opcodes
num_opcodes
enc_g
enc_e
rex
)
;
}
fn
emit_simm
(
sink
:
&
mut
MachBuffer
<
Inst
>
size
:
u8
simm32
:
u32
)
{
match
size
{
8
|
4
=
>
sink
.
put4
(
simm32
)
2
=
>
sink
.
put2
(
simm32
as
u16
)
1
=
>
sink
.
put1
(
simm32
as
u8
)
_
=
>
unreachable
!
(
)
}
}
pub
(
crate
)
fn
emit
(
inst
:
&
Inst
sink
:
&
mut
MachBuffer
<
Inst
>
_flags
:
&
settings
:
:
Flags
state
:
&
mut
EmitState
)
{
match
inst
{
Inst
:
:
Alu_RMI_R
{
is_64
op
src
dst
:
reg_g
}
=
>
{
let
rex
=
if
*
is_64
{
RexFlags
:
:
set_w
(
)
}
else
{
RexFlags
:
:
clear_w
(
)
}
;
if
*
op
=
=
AluRmiROpcode
:
:
Mul
{
match
src
{
RegMemImm
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
0x0FAF
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x0FAF
2
reg_g
.
to_reg
(
)
&
addr
.
finalize
(
state
)
rex
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
let
useImm8
=
low8_will_sign_extend_to_32
(
*
simm32
)
;
let
opcode
=
if
useImm8
{
0x6B
}
else
{
0x69
}
;
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcode
1
reg_g
.
to_reg
(
)
reg_g
.
to_reg
(
)
rex
)
;
emit_simm
(
sink
if
useImm8
{
1
}
else
{
4
}
*
simm32
)
;
}
}
}
else
{
let
(
opcode_r
opcode_m
subopcode_i
)
=
match
op
{
AluRmiROpcode
:
:
Add
=
>
(
0x01
0x03
0
)
AluRmiROpcode
:
:
Sub
=
>
(
0x29
0x2B
5
)
AluRmiROpcode
:
:
And
=
>
(
0x21
0x23
4
)
AluRmiROpcode
:
:
Or
=
>
(
0x09
0x0B
1
)
AluRmiROpcode
:
:
Xor
=
>
(
0x31
0x33
6
)
AluRmiROpcode
:
:
Mul
=
>
panic
!
(
"
unreachable
"
)
}
;
match
src
{
RegMemImm
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcode_r
1
*
reg_e
reg_g
.
to_reg
(
)
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
opcode_m
1
reg_g
.
to_reg
(
)
&
addr
.
finalize
(
state
)
rex
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
let
use_imm8
=
low8_will_sign_extend_to_32
(
*
simm32
)
;
let
opcode
=
if
use_imm8
{
0x83
}
else
{
0x81
}
;
let
enc_g
=
int_reg_enc
(
reg_g
.
to_reg
(
)
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
opcode
1
subopcode_i
enc_g
rex
)
;
emit_simm
(
sink
if
use_imm8
{
1
}
else
{
4
}
*
simm32
)
;
}
}
}
}
Inst
:
:
Imm_R
{
dst_is_64
simm64
dst
}
=
>
{
let
enc_dst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
if
*
dst_is_64
{
sink
.
put1
(
0x48
|
(
(
enc_dst
>
>
3
)
&
1
)
)
;
sink
.
put1
(
0xB8
|
(
enc_dst
&
7
)
)
;
sink
.
put8
(
*
simm64
)
;
}
else
{
if
(
(
enc_dst
>
>
3
)
&
1
)
=
=
1
{
sink
.
put1
(
0x41
)
;
}
sink
.
put1
(
0xB8
|
(
enc_dst
&
7
)
)
;
sink
.
put4
(
*
simm64
as
u32
)
;
}
}
Inst
:
:
Mov_R_R
{
is_64
src
dst
}
=
>
{
let
rex
=
if
*
is_64
{
RexFlags
:
:
set_w
(
)
}
else
{
RexFlags
:
:
clear_w
(
)
}
;
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
0x89
1
*
src
dst
.
to_reg
(
)
rex
)
;
}
Inst
:
:
MovZX_RM_R
{
ext_mode
src
dst
}
=
>
{
let
(
opcodes
num_opcodes
rex_flags
)
=
match
ext_mode
{
ExtMode
:
:
BL
=
>
{
(
0x0FB6
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
BQ
=
>
{
(
0x0FB6
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
WL
=
>
{
(
0x0FB7
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
WQ
=
>
{
(
0x0FB7
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
LQ
=
>
{
(
0x8B
1
RexFlags
:
:
clear_w
(
)
)
}
}
;
match
src
{
RegMem
:
:
Reg
{
reg
:
src
}
=
>
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
*
src
rex_flags
)
RegMem
:
:
Mem
{
addr
:
src
}
=
>
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
&
src
.
finalize
(
state
)
rex_flags
)
}
}
Inst
:
:
Mov64_M_R
{
src
dst
}
=
>
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x8B
1
dst
.
to_reg
(
)
&
src
.
finalize
(
state
)
RexFlags
:
:
set_w
(
)
)
Inst
:
:
LoadEffectiveAddress
{
addr
dst
}
=
>
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x8D
1
dst
.
to_reg
(
)
&
addr
.
finalize
(
state
)
RexFlags
:
:
set_w
(
)
)
Inst
:
:
MovSX_RM_R
{
ext_mode
src
dst
}
=
>
{
let
(
opcodes
num_opcodes
rex_flags
)
=
match
ext_mode
{
ExtMode
:
:
BL
=
>
{
(
0x0FBE
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
BQ
=
>
{
(
0x0FBE
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
WL
=
>
{
(
0x0FBF
2
RexFlags
:
:
clear_w
(
)
)
}
ExtMode
:
:
WQ
=
>
{
(
0x0FBF
2
RexFlags
:
:
set_w
(
)
)
}
ExtMode
:
:
LQ
=
>
{
(
0x63
1
RexFlags
:
:
set_w
(
)
)
}
}
;
match
src
{
RegMem
:
:
Reg
{
reg
:
src
}
=
>
emit_std_reg_reg
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
*
src
rex_flags
)
RegMem
:
:
Mem
{
addr
:
src
}
=
>
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
opcodes
num_opcodes
dst
.
to_reg
(
)
&
src
.
finalize
(
state
)
rex_flags
)
}
}
Inst
:
:
Mov_R_M
{
size
src
dst
}
=
>
{
let
dst
=
&
dst
.
finalize
(
state
)
;
match
size
{
1
=
>
{
let
mut
rex
=
RexFlags
:
:
clear_w
(
)
;
let
enc_src
=
int_reg_enc
(
*
src
)
;
if
enc_src
>
=
4
&
&
enc_src
<
=
7
{
rex
.
always_emit
(
)
;
}
;
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x88
1
*
src
dst
rex
)
}
2
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
_66
0x89
1
*
src
dst
RexFlags
:
:
clear_w
(
)
)
}
4
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x89
1
*
src
dst
RexFlags
:
:
clear_w
(
)
)
}
8
=
>
{
emit_std_reg_mem
(
sink
LegacyPrefix
:
:
None
0x89
1
*
src
dst
RexFlags
:
:
set_w
(
)
)
}
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
Mov_R_M
:
:
emit
:
unreachable
"
)
}
}
Inst
:
:
Shift_R
{
is_64
kind
num_bits
dst
}
=
>
{
let
enc_dst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
let
subopcode
=
match
kind
{
ShiftKind
:
:
Left
=
>
4
ShiftKind
:
:
RightZ
=
>
5
ShiftKind
:
:
RightS
=
>
7
}
;
let
rex
=
if
*
is_64
{
RexFlags
:
:
set_w
(
)
}
else
{
RexFlags
:
:
clear_w
(
)
}
;
match
num_bits
{
None
=
>
{
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xD3
1
subopcode
enc_dst
rex
)
;
}
Some
(
num_bits
)
=
>
{
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xC1
1
subopcode
enc_dst
rex
)
;
sink
.
put1
(
*
num_bits
)
;
}
}
}
Inst
:
:
Cmp_RMI_R
{
size
src
:
src_e
dst
:
reg_g
}
=
>
{
let
mut
prefix
=
LegacyPrefix
:
:
None
;
if
*
size
=
=
2
{
prefix
=
LegacyPrefix
:
:
_66
;
}
let
mut
rex
=
match
size
{
8
=
>
RexFlags
:
:
set_w
(
)
4
|
2
=
>
RexFlags
:
:
clear_w
(
)
1
=
>
{
let
mut
rex
=
RexFlags
:
:
clear_w
(
)
;
let
enc_g
=
int_reg_enc
(
*
reg_g
)
;
if
enc_g
>
=
4
&
&
enc_g
<
=
7
{
rex
.
always_emit
(
)
;
}
rex
}
_
=
>
panic
!
(
"
x64
:
:
Inst
:
:
Cmp_RMI_R
:
:
emit
:
unreachable
"
)
}
;
match
src_e
{
RegMemImm
:
:
Reg
{
reg
:
reg_e
}
=
>
{
if
*
size
=
=
1
{
let
enc_e
=
int_reg_enc
(
*
reg_e
)
;
if
enc_e
>
=
4
&
&
enc_e
<
=
7
{
rex
.
always_emit
(
)
;
}
}
let
opcode
=
if
*
size
=
=
1
{
0x38
}
else
{
0x39
}
;
emit_std_reg_reg
(
sink
prefix
opcode
1
*
reg_e
*
reg_g
rex
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
let
opcode
=
if
*
size
=
=
1
{
0x3A
}
else
{
0x3B
}
;
emit_std_reg_mem
(
sink
prefix
opcode
1
*
reg_g
addr
rex
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
let
use_imm8
=
low8_will_sign_extend_to_32
(
*
simm32
)
;
let
opcode
=
if
*
size
=
=
1
{
0x80
}
else
if
use_imm8
{
0x83
}
else
{
0x81
}
;
let
enc_g
=
int_reg_enc
(
*
reg_g
)
;
emit_std_enc_enc
(
sink
prefix
opcode
1
7
enc_g
rex
)
;
emit_simm
(
sink
if
use_imm8
{
1
}
else
{
*
size
}
*
simm32
)
;
}
}
}
Inst
:
:
Setcc
{
cc
dst
}
=
>
{
let
opcode
=
0x0f90
+
cc
.
get_enc
(
)
as
u32
;
let
mut
rex_flags
=
RexFlags
:
:
clear_w
(
)
;
rex_flags
.
always_emit
(
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
opcode
2
0
reg_enc
(
dst
.
to_reg
(
)
)
rex_flags
)
;
}
Inst
:
:
Push64
{
src
}
=
>
{
match
src
{
RegMemImm
:
:
Reg
{
reg
}
=
>
{
let
enc_reg
=
int_reg_enc
(
*
reg
)
;
let
rex
=
0x40
|
(
(
enc_reg
>
>
3
)
&
1
)
;
if
rex
!
=
0x40
{
sink
.
put1
(
rex
)
;
}
sink
.
put1
(
0x50
|
(
enc_reg
&
7
)
)
;
}
RegMemImm
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_enc_mem
(
sink
LegacyPrefix
:
:
None
0xFF
1
6
addr
RexFlags
:
:
clear_w
(
)
)
;
}
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
if
low8_will_sign_extend_to_64
(
*
simm32
)
{
sink
.
put1
(
0x6A
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
{
sink
.
put1
(
0x68
)
;
sink
.
put4
(
*
simm32
)
;
}
}
}
}
Inst
:
:
Pop64
{
dst
}
=
>
{
let
encDst
=
int_reg_enc
(
dst
.
to_reg
(
)
)
;
if
encDst
>
=
8
{
sink
.
put1
(
0x41
)
;
}
sink
.
put1
(
0x58
+
(
encDst
&
7
)
)
;
}
Inst
:
:
CallKnown
{
dest
loc
opcode
.
.
}
=
>
{
sink
.
put1
(
0xE8
)
;
sink
.
add_reloc
(
*
loc
Reloc
:
:
X86CallPCRel4
&
dest
-
4
)
;
sink
.
put4
(
0
)
;
if
opcode
.
is_call
(
)
{
sink
.
add_call_site
(
*
loc
*
opcode
)
;
}
}
Inst
:
:
CallUnknown
{
dest
opcode
loc
.
.
}
=
>
{
match
dest
{
RegMem
:
:
Reg
{
reg
}
=
>
{
let
reg_enc
=
int_reg_enc
(
*
reg
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xFF
1
2
reg_enc
RexFlags
:
:
clear_w
(
)
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_enc_mem
(
sink
LegacyPrefix
:
:
None
0xFF
1
2
addr
RexFlags
:
:
clear_w
(
)
)
;
}
}
if
opcode
.
is_call
(
)
{
sink
.
add_call_site
(
*
loc
*
opcode
)
;
}
}
Inst
:
:
Ret
{
}
=
>
sink
.
put1
(
0xC3
)
Inst
:
:
JmpKnown
{
dst
}
=
>
{
let
br_start
=
sink
.
cur_offset
(
)
;
let
br_disp_off
=
br_start
+
1
;
let
br_end
=
br_start
+
5
;
if
let
Some
(
l
)
=
dst
.
as_label
(
)
{
sink
.
use_label_at_offset
(
br_disp_off
l
LabelUse
:
:
JmpRel32
)
;
sink
.
add_uncond_branch
(
br_start
br_end
l
)
;
}
let
disp
=
dst
.
as_offset32_or_zero
(
)
;
let
disp
=
disp
as
u32
;
sink
.
put1
(
0xE9
)
;
sink
.
put4
(
disp
)
;
}
Inst
:
:
JmpCond
{
cc
taken
not_taken
}
=
>
{
let
cond_start
=
sink
.
cur_offset
(
)
;
let
cond_disp_off
=
cond_start
+
2
;
let
cond_end
=
cond_start
+
6
;
if
let
Some
(
l
)
=
taken
.
as_label
(
)
{
sink
.
use_label_at_offset
(
cond_disp_off
l
LabelUse
:
:
JmpRel32
)
;
let
inverted
:
[
u8
;
6
]
=
[
0x0F
0x80
+
(
cc
.
invert
(
)
.
get_enc
(
)
)
0x00
0x00
0x00
0x00
]
;
sink
.
add_cond_branch
(
cond_start
cond_end
l
&
inverted
[
.
.
]
)
;
}
let
taken_disp
=
taken
.
as_offset32_or_zero
(
)
;
let
taken_disp
=
taken_disp
as
u32
;
sink
.
put1
(
0x0F
)
;
sink
.
put1
(
0x80
+
cc
.
get_enc
(
)
)
;
sink
.
put4
(
taken_disp
)
;
let
uncond_start
=
sink
.
cur_offset
(
)
;
let
uncond_disp_off
=
uncond_start
+
1
;
let
uncond_end
=
uncond_start
+
5
;
if
let
Some
(
l
)
=
not_taken
.
as_label
(
)
{
sink
.
use_label_at_offset
(
uncond_disp_off
l
LabelUse
:
:
JmpRel32
)
;
sink
.
add_uncond_branch
(
uncond_start
uncond_end
l
)
;
}
let
nt_disp
=
not_taken
.
as_offset32_or_zero
(
)
;
let
nt_disp
=
nt_disp
as
u32
;
sink
.
put1
(
0xE9
)
;
sink
.
put4
(
nt_disp
)
;
}
Inst
:
:
JmpUnknown
{
target
}
=
>
{
match
target
{
RegMem
:
:
Reg
{
reg
}
=
>
{
let
reg_enc
=
int_reg_enc
(
*
reg
)
;
emit_std_enc_enc
(
sink
LegacyPrefix
:
:
None
0xFF
1
4
reg_enc
RexFlags
:
:
clear_w
(
)
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_enc_mem
(
sink
LegacyPrefix
:
:
None
0xFF
1
4
addr
RexFlags
:
:
clear_w
(
)
)
;
}
}
}
Inst
:
:
XMM_Mov_RM_R
{
op
src
:
src_e
dst
:
reg_g
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Movaps
=
>
(
LegacyPrefix
:
:
None
0x0F28
)
SseOpcode
:
:
Movd
=
>
(
LegacyPrefix
:
:
_66
0x0F6E
)
SseOpcode
:
:
Movsd
=
>
(
LegacyPrefix
:
:
_F2
0x0F10
)
SseOpcode
:
:
Movss
=
>
(
LegacyPrefix
:
:
_F3
0x0F10
)
_
=
>
unimplemented
!
(
"
Opcode
{
:
?
}
not
implemented
"
op
)
}
;
match
src_e
{
RegMem
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
addr
rex
)
;
}
}
}
Inst
:
:
XMM_RM_R
{
op
src
:
src_e
dst
:
reg_g
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Addss
=
>
(
LegacyPrefix
:
:
_F3
0x0F58
)
SseOpcode
:
:
Andps
=
>
(
LegacyPrefix
:
:
None
0x0F54
)
SseOpcode
:
:
Andnps
=
>
(
LegacyPrefix
:
:
None
0x0F55
)
SseOpcode
:
:
Divss
=
>
(
LegacyPrefix
:
:
_F3
0x0F5E
)
SseOpcode
:
:
Mulss
=
>
(
LegacyPrefix
:
:
_F3
0x0F59
)
SseOpcode
:
:
Orps
=
>
(
LegacyPrefix
:
:
None
0x0F56
)
SseOpcode
:
:
Subss
=
>
(
LegacyPrefix
:
:
_F3
0x0F5C
)
SseOpcode
:
:
Sqrtss
=
>
(
LegacyPrefix
:
:
_F3
0x0F51
)
_
=
>
unimplemented
!
(
"
Opcode
{
:
?
}
not
implemented
"
op
)
}
;
match
src_e
{
RegMem
:
:
Reg
{
reg
:
reg_e
}
=
>
{
emit_std_reg_reg
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
*
reg_e
rex
)
;
}
RegMem
:
:
Mem
{
addr
}
=
>
{
let
addr
=
&
addr
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
reg_g
.
to_reg
(
)
addr
rex
)
;
}
}
}
Inst
:
:
XMM_Mov_R_M
{
op
src
dst
}
=
>
{
let
rex
=
RexFlags
:
:
clear_w
(
)
;
let
(
prefix
opcode
)
=
match
op
{
SseOpcode
:
:
Movd
=
>
(
LegacyPrefix
:
:
_66
0x0F7E
)
SseOpcode
:
:
Movss
=
>
(
LegacyPrefix
:
:
_F3
0x0F11
)
_
=
>
unimplemented
!
(
"
Emit
xmm
mov
r
m
"
)
}
;
let
dst
=
&
dst
.
finalize
(
state
)
;
emit_std_reg_mem
(
sink
prefix
opcode
2
*
src
dst
rex
)
;
}
Inst
:
:
Hlt
=
>
{
sink
.
put1
(
0xcc
)
;
}
Inst
:
:
Ud2
{
trap_info
}
=
>
{
sink
.
add_trap
(
trap_info
.
0
trap_info
.
1
)
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
0x0b
)
;
}
Inst
:
:
VirtualSPOffsetAdj
{
offset
}
=
>
{
debug
!
(
"
virtual
sp
offset
adjusted
by
{
}
-
>
{
}
"
offset
state
.
virtual_sp_offset
+
offset
)
;
state
.
virtual_sp_offset
+
=
offset
;
}
Inst
:
:
Nop
{
.
.
}
|
Inst
:
:
EpiloguePlaceholder
=
>
{
}
}
}
