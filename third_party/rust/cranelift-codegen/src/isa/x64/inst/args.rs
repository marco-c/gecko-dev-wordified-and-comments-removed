use
super
:
:
regs
:
:
{
self
show_ireg_sized
}
;
use
super
:
:
EmitState
;
use
crate
:
:
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
crate
:
:
machinst
:
:
*
;
use
core
:
:
fmt
:
:
Debug
;
use
regalloc
:
:
{
RealRegUniverse
Reg
RegClass
RegUsageCollector
RegUsageMapper
}
;
use
std
:
:
fmt
;
use
std
:
:
string
:
:
{
String
ToString
}
;
#
[
derive
(
Clone
)
]
pub
enum
Amode
{
ImmReg
{
simm32
:
u32
base
:
Reg
}
ImmRegRegShift
{
simm32
:
u32
base
:
Reg
index
:
Reg
shift
:
u8
}
RipRelative
{
target
:
BranchTarget
}
}
impl
Amode
{
pub
(
crate
)
fn
imm_reg
(
simm32
:
u32
base
:
Reg
)
-
>
Self
{
debug_assert
!
(
base
.
get_class
(
)
=
=
RegClass
:
:
I64
)
;
Self
:
:
ImmReg
{
simm32
base
}
}
pub
(
crate
)
fn
imm_reg_reg_shift
(
simm32
:
u32
base
:
Reg
index
:
Reg
shift
:
u8
)
-
>
Self
{
debug_assert
!
(
base
.
get_class
(
)
=
=
RegClass
:
:
I64
)
;
debug_assert
!
(
index
.
get_class
(
)
=
=
RegClass
:
:
I64
)
;
debug_assert
!
(
shift
<
=
3
)
;
Self
:
:
ImmRegRegShift
{
simm32
base
index
shift
}
}
pub
(
crate
)
fn
rip_relative
(
target
:
BranchTarget
)
-
>
Self
{
Self
:
:
RipRelative
{
target
}
}
pub
(
crate
)
fn
get_regs_as_uses
(
&
self
collector
:
&
mut
RegUsageCollector
)
{
match
self
{
Amode
:
:
ImmReg
{
base
.
.
}
=
>
{
collector
.
add_use
(
*
base
)
;
}
Amode
:
:
ImmRegRegShift
{
base
index
.
.
}
=
>
{
collector
.
add_use
(
*
base
)
;
collector
.
add_use
(
*
index
)
;
}
Amode
:
:
RipRelative
{
.
.
}
=
>
{
}
}
}
}
impl
ShowWithRRU
for
Amode
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
Amode
:
:
ImmReg
{
simm32
base
}
=
>
{
format
!
(
"
{
}
(
{
}
)
"
*
simm32
as
i32
base
.
show_rru
(
mb_rru
)
)
}
Amode
:
:
ImmRegRegShift
{
simm32
base
index
shift
}
=
>
format
!
(
"
{
}
(
{
}
{
}
{
}
)
"
*
simm32
as
i32
base
.
show_rru
(
mb_rru
)
index
.
show_rru
(
mb_rru
)
1
<
<
shift
)
Amode
:
:
RipRelative
{
ref
target
}
=
>
format
!
(
"
{
}
(
%
rip
)
"
match
target
{
BranchTarget
:
:
Label
(
label
)
=
>
format
!
(
"
label
{
}
"
label
.
get
(
)
)
BranchTarget
:
:
ResolvedOffset
(
offset
)
=
>
offset
.
to_string
(
)
}
)
}
}
}
#
[
derive
(
Clone
)
]
pub
enum
SyntheticAmode
{
Real
(
Amode
)
NominalSPOffset
{
simm32
:
u32
}
}
impl
SyntheticAmode
{
pub
(
crate
)
fn
nominal_sp_offset
(
simm32
:
u32
)
-
>
Self
{
SyntheticAmode
:
:
NominalSPOffset
{
simm32
}
}
pub
(
crate
)
fn
get_regs_as_uses
(
&
self
collector
:
&
mut
RegUsageCollector
)
{
match
self
{
SyntheticAmode
:
:
Real
(
addr
)
=
>
addr
.
get_regs_as_uses
(
collector
)
SyntheticAmode
:
:
NominalSPOffset
{
.
.
}
=
>
{
}
}
}
pub
(
crate
)
fn
map_uses
<
RUM
:
RegUsageMapper
>
(
&
mut
self
map
:
&
RUM
)
{
match
self
{
SyntheticAmode
:
:
Real
(
addr
)
=
>
addr
.
map_uses
(
map
)
SyntheticAmode
:
:
NominalSPOffset
{
.
.
}
=
>
{
}
}
}
pub
(
crate
)
fn
finalize
(
&
self
state
:
&
mut
EmitState
)
-
>
Amode
{
match
self
{
SyntheticAmode
:
:
Real
(
addr
)
=
>
addr
.
clone
(
)
SyntheticAmode
:
:
NominalSPOffset
{
simm32
}
=
>
{
let
off
=
*
simm32
as
i64
+
state
.
virtual_sp_offset
;
assert
!
(
off
<
=
u32
:
:
max_value
(
)
as
i64
"
amode
finalize
:
add
sequence
NYI
"
)
;
Amode
:
:
imm_reg
(
off
as
u32
regs
:
:
rsp
(
)
)
}
}
}
}
impl
Into
<
SyntheticAmode
>
for
Amode
{
fn
into
(
self
)
-
>
SyntheticAmode
{
SyntheticAmode
:
:
Real
(
self
)
}
}
impl
ShowWithRRU
for
SyntheticAmode
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
SyntheticAmode
:
:
Real
(
addr
)
=
>
addr
.
show_rru
(
mb_rru
)
SyntheticAmode
:
:
NominalSPOffset
{
simm32
}
=
>
{
format
!
(
"
rsp
(
{
}
+
virtual
offset
)
"
*
simm32
as
i32
)
}
}
}
}
#
[
derive
(
Clone
)
]
pub
enum
RegMemImm
{
Reg
{
reg
:
Reg
}
Mem
{
addr
:
SyntheticAmode
}
Imm
{
simm32
:
u32
}
}
impl
RegMemImm
{
pub
(
crate
)
fn
reg
(
reg
:
Reg
)
-
>
Self
{
debug_assert
!
(
reg
.
get_class
(
)
=
=
RegClass
:
:
I64
|
|
reg
.
get_class
(
)
=
=
RegClass
:
:
V128
)
;
Self
:
:
Reg
{
reg
}
}
pub
(
crate
)
fn
mem
(
addr
:
impl
Into
<
SyntheticAmode
>
)
-
>
Self
{
Self
:
:
Mem
{
addr
:
addr
.
into
(
)
}
}
pub
(
crate
)
fn
imm
(
simm32
:
u32
)
-
>
Self
{
Self
:
:
Imm
{
simm32
}
}
pub
(
crate
)
fn
assert_regclass_is
(
&
self
expected_reg_class
:
RegClass
)
{
if
let
Self
:
:
Reg
{
reg
}
=
self
{
debug_assert_eq
!
(
reg
.
get_class
(
)
expected_reg_class
)
;
}
}
pub
(
crate
)
fn
get_regs_as_uses
(
&
self
collector
:
&
mut
RegUsageCollector
)
{
match
self
{
Self
:
:
Reg
{
reg
}
=
>
collector
.
add_use
(
*
reg
)
Self
:
:
Mem
{
addr
}
=
>
addr
.
get_regs_as_uses
(
collector
)
Self
:
:
Imm
{
.
.
}
=
>
{
}
}
}
pub
(
crate
)
fn
to_reg
(
&
self
)
-
>
Option
<
Reg
>
{
match
self
{
Self
:
:
Reg
{
reg
}
=
>
Some
(
*
reg
)
_
=
>
None
}
}
}
impl
ShowWithRRU
for
RegMemImm
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
self
.
show_rru_sized
(
mb_rru
8
)
}
fn
show_rru_sized
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
size
:
u8
)
-
>
String
{
match
self
{
Self
:
:
Reg
{
reg
}
=
>
show_ireg_sized
(
*
reg
mb_rru
size
)
Self
:
:
Mem
{
addr
}
=
>
addr
.
show_rru
(
mb_rru
)
Self
:
:
Imm
{
simm32
}
=
>
format
!
(
"
{
}
"
*
simm32
as
i32
)
}
}
}
#
[
derive
(
Clone
)
]
pub
enum
RegMem
{
Reg
{
reg
:
Reg
}
Mem
{
addr
:
SyntheticAmode
}
}
impl
RegMem
{
pub
(
crate
)
fn
reg
(
reg
:
Reg
)
-
>
Self
{
debug_assert
!
(
reg
.
get_class
(
)
=
=
RegClass
:
:
I64
|
|
reg
.
get_class
(
)
=
=
RegClass
:
:
V128
)
;
Self
:
:
Reg
{
reg
}
}
pub
(
crate
)
fn
mem
(
addr
:
impl
Into
<
SyntheticAmode
>
)
-
>
Self
{
Self
:
:
Mem
{
addr
:
addr
.
into
(
)
}
}
pub
(
crate
)
fn
assert_regclass_is
(
&
self
expected_reg_class
:
RegClass
)
{
if
let
Self
:
:
Reg
{
reg
}
=
self
{
debug_assert_eq
!
(
reg
.
get_class
(
)
expected_reg_class
)
;
}
}
pub
(
crate
)
fn
get_regs_as_uses
(
&
self
collector
:
&
mut
RegUsageCollector
)
{
match
self
{
RegMem
:
:
Reg
{
reg
}
=
>
collector
.
add_use
(
*
reg
)
RegMem
:
:
Mem
{
addr
.
.
}
=
>
addr
.
get_regs_as_uses
(
collector
)
}
}
pub
(
crate
)
fn
to_reg
(
&
self
)
-
>
Option
<
Reg
>
{
match
self
{
RegMem
:
:
Reg
{
reg
}
=
>
Some
(
*
reg
)
_
=
>
None
}
}
}
impl
ShowWithRRU
for
RegMem
{
fn
show_rru
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
self
.
show_rru_sized
(
mb_rru
8
)
}
fn
show_rru_sized
(
&
self
mb_rru
:
Option
<
&
RealRegUniverse
>
size
:
u8
)
-
>
String
{
match
self
{
RegMem
:
:
Reg
{
reg
}
=
>
show_ireg_sized
(
*
reg
mb_rru
size
)
RegMem
:
:
Mem
{
addr
.
.
}
=
>
addr
.
show_rru
(
mb_rru
)
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
pub
enum
AluRmiROpcode
{
Add
Sub
And
Or
Xor
Mul
}
impl
fmt
:
:
Debug
for
AluRmiROpcode
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
name
=
match
self
{
AluRmiROpcode
:
:
Add
=
>
"
add
"
AluRmiROpcode
:
:
Sub
=
>
"
sub
"
AluRmiROpcode
:
:
And
=
>
"
and
"
AluRmiROpcode
:
:
Or
=
>
"
or
"
AluRmiROpcode
:
:
Xor
=
>
"
xor
"
AluRmiROpcode
:
:
Mul
=
>
"
imul
"
}
;
write
!
(
fmt
"
{
}
"
name
)
}
}
impl
fmt
:
:
Display
for
AluRmiROpcode
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
UnaryRmROpcode
{
Bsr
Bsf
}
impl
fmt
:
:
Debug
for
UnaryRmROpcode
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
UnaryRmROpcode
:
:
Bsr
=
>
write
!
(
fmt
"
bsr
"
)
UnaryRmROpcode
:
:
Bsf
=
>
write
!
(
fmt
"
bsf
"
)
}
}
}
impl
fmt
:
:
Display
for
UnaryRmROpcode
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
pub
(
crate
)
enum
InstructionSet
{
SSE
SSE2
SSE41
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
SseOpcode
{
Addps
Addpd
Addss
Addsd
Andps
Andpd
Andnps
Andnpd
Comiss
Comisd
Cmpps
Cmppd
Cmpss
Cmpsd
Cvtsd2ss
Cvtsd2si
Cvtsi2ss
Cvtsi2sd
Cvtss2si
Cvtss2sd
Cvttss2si
Cvttsd2si
Divps
Divpd
Divss
Divsd
Insertps
Maxps
Maxpd
Maxss
Maxsd
Minps
Minpd
Minss
Minsd
Movaps
Movapd
Movd
Movq
Movss
Movsd
Movups
Movupd
Mulps
Mulpd
Mulss
Mulsd
Orps
Orpd
Psllw
Pslld
Psllq
Psraw
Psrad
Psrlw
Psrld
Psrlq
Rcpss
Roundss
Roundsd
Rsqrtss
Sqrtps
Sqrtpd
Sqrtss
Sqrtsd
Subps
Subpd
Subss
Subsd
Ucomiss
Ucomisd
Xorps
Xorpd
}
impl
SseOpcode
{
pub
(
crate
)
fn
available_from
(
&
self
)
-
>
InstructionSet
{
use
InstructionSet
:
:
*
;
match
self
{
SseOpcode
:
:
Addps
|
SseOpcode
:
:
Addss
|
SseOpcode
:
:
Andps
|
SseOpcode
:
:
Andnps
|
SseOpcode
:
:
Comiss
|
SseOpcode
:
:
Cmpps
|
SseOpcode
:
:
Cmpss
|
SseOpcode
:
:
Cvtsi2ss
|
SseOpcode
:
:
Cvtss2si
|
SseOpcode
:
:
Cvttss2si
|
SseOpcode
:
:
Divps
|
SseOpcode
:
:
Divss
|
SseOpcode
:
:
Maxps
|
SseOpcode
:
:
Maxss
|
SseOpcode
:
:
Minps
|
SseOpcode
:
:
Minss
|
SseOpcode
:
:
Movaps
|
SseOpcode
:
:
Movss
|
SseOpcode
:
:
Movups
|
SseOpcode
:
:
Mulps
|
SseOpcode
:
:
Mulss
|
SseOpcode
:
:
Orps
|
SseOpcode
:
:
Rcpss
|
SseOpcode
:
:
Rsqrtss
|
SseOpcode
:
:
Sqrtps
|
SseOpcode
:
:
Sqrtss
|
SseOpcode
:
:
Subps
|
SseOpcode
:
:
Subss
|
SseOpcode
:
:
Ucomiss
|
SseOpcode
:
:
Xorps
=
>
SSE
SseOpcode
:
:
Addpd
|
SseOpcode
:
:
Addsd
|
SseOpcode
:
:
Andpd
|
SseOpcode
:
:
Andnpd
|
SseOpcode
:
:
Cmppd
|
SseOpcode
:
:
Cmpsd
|
SseOpcode
:
:
Comisd
|
SseOpcode
:
:
Cvtsd2ss
|
SseOpcode
:
:
Cvtsd2si
|
SseOpcode
:
:
Cvtsi2sd
|
SseOpcode
:
:
Cvtss2sd
|
SseOpcode
:
:
Cvttsd2si
|
SseOpcode
:
:
Divpd
|
SseOpcode
:
:
Divsd
|
SseOpcode
:
:
Maxpd
|
SseOpcode
:
:
Maxsd
|
SseOpcode
:
:
Minpd
|
SseOpcode
:
:
Minsd
|
SseOpcode
:
:
Movapd
|
SseOpcode
:
:
Movd
|
SseOpcode
:
:
Movq
|
SseOpcode
:
:
Movsd
|
SseOpcode
:
:
Movupd
|
SseOpcode
:
:
Mulpd
|
SseOpcode
:
:
Mulsd
|
SseOpcode
:
:
Orpd
|
SseOpcode
:
:
Psllw
|
SseOpcode
:
:
Pslld
|
SseOpcode
:
:
Psllq
|
SseOpcode
:
:
Psraw
|
SseOpcode
:
:
Psrad
|
SseOpcode
:
:
Psrlw
|
SseOpcode
:
:
Psrld
|
SseOpcode
:
:
Psrlq
|
SseOpcode
:
:
Sqrtpd
|
SseOpcode
:
:
Sqrtsd
|
SseOpcode
:
:
Subpd
|
SseOpcode
:
:
Subsd
|
SseOpcode
:
:
Ucomisd
|
SseOpcode
:
:
Xorpd
=
>
SSE2
SseOpcode
:
:
Insertps
|
SseOpcode
:
:
Roundss
|
SseOpcode
:
:
Roundsd
=
>
SSE41
}
}
pub
(
crate
)
fn
src_size
(
&
self
)
-
>
u8
{
match
self
{
SseOpcode
:
:
Movd
=
>
4
_
=
>
8
}
}
}
impl
fmt
:
:
Debug
for
SseOpcode
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
name
=
match
self
{
SseOpcode
:
:
Addps
=
>
"
addps
"
SseOpcode
:
:
Addpd
=
>
"
addpd
"
SseOpcode
:
:
Addss
=
>
"
addss
"
SseOpcode
:
:
Addsd
=
>
"
addsd
"
SseOpcode
:
:
Andpd
=
>
"
andpd
"
SseOpcode
:
:
Andps
=
>
"
andps
"
SseOpcode
:
:
Andnps
=
>
"
andnps
"
SseOpcode
:
:
Andnpd
=
>
"
andnpd
"
SseOpcode
:
:
Cmpps
=
>
"
cmpps
"
SseOpcode
:
:
Cmppd
=
>
"
cmppd
"
SseOpcode
:
:
Cmpss
=
>
"
cmpss
"
SseOpcode
:
:
Cmpsd
=
>
"
cmpsd
"
SseOpcode
:
:
Comiss
=
>
"
comiss
"
SseOpcode
:
:
Comisd
=
>
"
comisd
"
SseOpcode
:
:
Cvtsd2ss
=
>
"
cvtsd2ss
"
SseOpcode
:
:
Cvtsd2si
=
>
"
cvtsd2si
"
SseOpcode
:
:
Cvtsi2ss
=
>
"
cvtsi2ss
"
SseOpcode
:
:
Cvtsi2sd
=
>
"
cvtsi2sd
"
SseOpcode
:
:
Cvtss2si
=
>
"
cvtss2si
"
SseOpcode
:
:
Cvtss2sd
=
>
"
cvtss2sd
"
SseOpcode
:
:
Cvttss2si
=
>
"
cvttss2si
"
SseOpcode
:
:
Cvttsd2si
=
>
"
cvttsd2si
"
SseOpcode
:
:
Divps
=
>
"
divps
"
SseOpcode
:
:
Divpd
=
>
"
divpd
"
SseOpcode
:
:
Divss
=
>
"
divss
"
SseOpcode
:
:
Divsd
=
>
"
divsd
"
SseOpcode
:
:
Insertps
=
>
"
insertps
"
SseOpcode
:
:
Maxps
=
>
"
maxps
"
SseOpcode
:
:
Maxpd
=
>
"
maxpd
"
SseOpcode
:
:
Maxss
=
>
"
maxss
"
SseOpcode
:
:
Maxsd
=
>
"
maxsd
"
SseOpcode
:
:
Minps
=
>
"
minps
"
SseOpcode
:
:
Minpd
=
>
"
minpd
"
SseOpcode
:
:
Minss
=
>
"
minss
"
SseOpcode
:
:
Minsd
=
>
"
minsd
"
SseOpcode
:
:
Movaps
=
>
"
movaps
"
SseOpcode
:
:
Movapd
=
>
"
movapd
"
SseOpcode
:
:
Movd
=
>
"
movd
"
SseOpcode
:
:
Movq
=
>
"
movq
"
SseOpcode
:
:
Movss
=
>
"
movss
"
SseOpcode
:
:
Movsd
=
>
"
movsd
"
SseOpcode
:
:
Movups
=
>
"
movups
"
SseOpcode
:
:
Movupd
=
>
"
movupd
"
SseOpcode
:
:
Mulps
=
>
"
mulps
"
SseOpcode
:
:
Mulpd
=
>
"
mulpd
"
SseOpcode
:
:
Mulss
=
>
"
mulss
"
SseOpcode
:
:
Mulsd
=
>
"
mulsd
"
SseOpcode
:
:
Orpd
=
>
"
orpd
"
SseOpcode
:
:
Orps
=
>
"
orps
"
SseOpcode
:
:
Psllw
=
>
"
psllw
"
SseOpcode
:
:
Pslld
=
>
"
pslld
"
SseOpcode
:
:
Psllq
=
>
"
psllq
"
SseOpcode
:
:
Psraw
=
>
"
psraw
"
SseOpcode
:
:
Psrad
=
>
"
psrad
"
SseOpcode
:
:
Psrlw
=
>
"
psrlw
"
SseOpcode
:
:
Psrld
=
>
"
psrld
"
SseOpcode
:
:
Psrlq
=
>
"
psrlq
"
SseOpcode
:
:
Rcpss
=
>
"
rcpss
"
SseOpcode
:
:
Roundss
=
>
"
roundss
"
SseOpcode
:
:
Roundsd
=
>
"
roundsd
"
SseOpcode
:
:
Rsqrtss
=
>
"
rsqrtss
"
SseOpcode
:
:
Sqrtps
=
>
"
sqrtps
"
SseOpcode
:
:
Sqrtpd
=
>
"
sqrtpd
"
SseOpcode
:
:
Sqrtss
=
>
"
sqrtss
"
SseOpcode
:
:
Sqrtsd
=
>
"
sqrtsd
"
SseOpcode
:
:
Subps
=
>
"
subps
"
SseOpcode
:
:
Subpd
=
>
"
subpd
"
SseOpcode
:
:
Subss
=
>
"
subss
"
SseOpcode
:
:
Subsd
=
>
"
subsd
"
SseOpcode
:
:
Ucomiss
=
>
"
ucomiss
"
SseOpcode
:
:
Ucomisd
=
>
"
ucomisd
"
SseOpcode
:
:
Xorps
=
>
"
xorps
"
SseOpcode
:
:
Xorpd
=
>
"
xorpd
"
}
;
write
!
(
fmt
"
{
}
"
name
)
}
}
impl
fmt
:
:
Display
for
SseOpcode
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Clone
PartialEq
)
]
pub
enum
ExtMode
{
BL
BQ
WL
WQ
LQ
}
impl
ExtMode
{
pub
(
crate
)
fn
src_size
(
&
self
)
-
>
u8
{
match
self
{
ExtMode
:
:
BL
|
ExtMode
:
:
BQ
=
>
1
ExtMode
:
:
WL
|
ExtMode
:
:
WQ
=
>
2
ExtMode
:
:
LQ
=
>
4
}
}
pub
(
crate
)
fn
dst_size
(
&
self
)
-
>
u8
{
match
self
{
ExtMode
:
:
BL
|
ExtMode
:
:
WL
=
>
4
ExtMode
:
:
BQ
|
ExtMode
:
:
WQ
|
ExtMode
:
:
LQ
=
>
8
}
}
}
impl
fmt
:
:
Debug
for
ExtMode
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
name
=
match
self
{
ExtMode
:
:
BL
=
>
"
bl
"
ExtMode
:
:
BQ
=
>
"
bq
"
ExtMode
:
:
WL
=
>
"
wl
"
ExtMode
:
:
WQ
=
>
"
wq
"
ExtMode
:
:
LQ
=
>
"
lq
"
}
;
write
!
(
fmt
"
{
}
"
name
)
}
}
impl
fmt
:
:
Display
for
ExtMode
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Clone
)
]
pub
enum
ShiftKind
{
ShiftLeft
ShiftRightLogical
ShiftRightArithmetic
RotateLeft
RotateRight
}
impl
fmt
:
:
Debug
for
ShiftKind
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
name
=
match
self
{
ShiftKind
:
:
ShiftLeft
=
>
"
shl
"
ShiftKind
:
:
ShiftRightLogical
=
>
"
shr
"
ShiftKind
:
:
ShiftRightArithmetic
=
>
"
sar
"
ShiftKind
:
:
RotateLeft
=
>
"
rol
"
ShiftKind
:
:
RotateRight
=
>
"
ror
"
}
;
write
!
(
fmt
"
{
}
"
name
)
}
}
impl
fmt
:
:
Display
for
ShiftKind
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Clone
)
]
pub
enum
DivOrRemKind
{
SignedDiv
UnsignedDiv
SignedRem
UnsignedRem
}
impl
DivOrRemKind
{
pub
(
crate
)
fn
is_signed
(
&
self
)
-
>
bool
{
match
self
{
DivOrRemKind
:
:
SignedDiv
|
DivOrRemKind
:
:
SignedRem
=
>
true
_
=
>
false
}
}
pub
(
crate
)
fn
is_div
(
&
self
)
-
>
bool
{
match
self
{
DivOrRemKind
:
:
SignedDiv
|
DivOrRemKind
:
:
UnsignedDiv
=
>
true
_
=
>
false
}
}
}
#
[
derive
(
Copy
Clone
)
]
#
[
repr
(
u8
)
]
pub
enum
CC
{
O
=
0
NO
=
1
B
=
2
NB
=
3
Z
=
4
NZ
=
5
BE
=
6
NBE
=
7
S
=
8
NS
=
9
L
=
12
NL
=
13
LE
=
14
NLE
=
15
P
=
10
NP
=
11
}
impl
CC
{
pub
(
crate
)
fn
from_intcc
(
intcc
:
IntCC
)
-
>
Self
{
match
intcc
{
IntCC
:
:
Equal
=
>
CC
:
:
Z
IntCC
:
:
NotEqual
=
>
CC
:
:
NZ
IntCC
:
:
SignedGreaterThanOrEqual
=
>
CC
:
:
NL
IntCC
:
:
SignedGreaterThan
=
>
CC
:
:
NLE
IntCC
:
:
SignedLessThanOrEqual
=
>
CC
:
:
LE
IntCC
:
:
SignedLessThan
=
>
CC
:
:
L
IntCC
:
:
UnsignedGreaterThanOrEqual
=
>
CC
:
:
NB
IntCC
:
:
UnsignedGreaterThan
=
>
CC
:
:
NBE
IntCC
:
:
UnsignedLessThanOrEqual
=
>
CC
:
:
BE
IntCC
:
:
UnsignedLessThan
=
>
CC
:
:
B
IntCC
:
:
Overflow
=
>
CC
:
:
O
IntCC
:
:
NotOverflow
=
>
CC
:
:
NO
}
}
pub
(
crate
)
fn
invert
(
&
self
)
-
>
Self
{
match
self
{
CC
:
:
O
=
>
CC
:
:
NO
CC
:
:
NO
=
>
CC
:
:
O
CC
:
:
B
=
>
CC
:
:
NB
CC
:
:
NB
=
>
CC
:
:
B
CC
:
:
Z
=
>
CC
:
:
NZ
CC
:
:
NZ
=
>
CC
:
:
Z
CC
:
:
BE
=
>
CC
:
:
NBE
CC
:
:
NBE
=
>
CC
:
:
BE
CC
:
:
S
=
>
CC
:
:
NS
CC
:
:
NS
=
>
CC
:
:
S
CC
:
:
L
=
>
CC
:
:
NL
CC
:
:
NL
=
>
CC
:
:
L
CC
:
:
LE
=
>
CC
:
:
NLE
CC
:
:
NLE
=
>
CC
:
:
LE
CC
:
:
P
=
>
CC
:
:
NP
CC
:
:
NP
=
>
CC
:
:
P
}
}
pub
(
crate
)
fn
from_floatcc
(
floatcc
:
FloatCC
)
-
>
Self
{
match
floatcc
{
FloatCC
:
:
Ordered
=
>
CC
:
:
NP
FloatCC
:
:
Unordered
=
>
CC
:
:
P
FloatCC
:
:
NotEqual
|
FloatCC
:
:
OrderedNotEqual
=
>
CC
:
:
NZ
FloatCC
:
:
UnorderedOrEqual
=
>
CC
:
:
Z
FloatCC
:
:
GreaterThan
=
>
CC
:
:
NBE
FloatCC
:
:
GreaterThanOrEqual
=
>
CC
:
:
NB
FloatCC
:
:
UnorderedOrLessThan
=
>
CC
:
:
B
FloatCC
:
:
UnorderedOrLessThanOrEqual
=
>
CC
:
:
BE
FloatCC
:
:
Equal
|
FloatCC
:
:
LessThan
|
FloatCC
:
:
LessThanOrEqual
|
FloatCC
:
:
UnorderedOrGreaterThan
|
FloatCC
:
:
UnorderedOrGreaterThanOrEqual
=
>
{
panic
!
(
"
No
single
condition
code
to
guarantee
ordered
.
Treat
as
special
case
.
"
)
}
}
}
pub
(
crate
)
fn
get_enc
(
self
)
-
>
u8
{
self
as
u8
}
}
impl
fmt
:
:
Debug
for
CC
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
name
=
match
self
{
CC
:
:
O
=
>
"
o
"
CC
:
:
NO
=
>
"
no
"
CC
:
:
B
=
>
"
b
"
CC
:
:
NB
=
>
"
nb
"
CC
:
:
Z
=
>
"
z
"
CC
:
:
NZ
=
>
"
nz
"
CC
:
:
BE
=
>
"
be
"
CC
:
:
NBE
=
>
"
nbe
"
CC
:
:
S
=
>
"
s
"
CC
:
:
NS
=
>
"
ns
"
CC
:
:
L
=
>
"
l
"
CC
:
:
NL
=
>
"
nl
"
CC
:
:
LE
=
>
"
le
"
CC
:
:
NLE
=
>
"
nle
"
CC
:
:
P
=
>
"
p
"
CC
:
:
NP
=
>
"
np
"
}
;
write
!
(
fmt
"
{
}
"
name
)
}
}
impl
fmt
:
:
Display
for
CC
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
f
)
}
}
pub
(
crate
)
enum
FcmpImm
{
Equal
=
0x00
LessThan
=
0x01
LessThanOrEqual
=
0x02
Unordered
=
0x03
NotEqual
=
0x04
UnorderedOrGreaterThanOrEqual
=
0x05
UnorderedOrGreaterThan
=
0x06
Ordered
=
0x07
}
impl
FcmpImm
{
pub
(
crate
)
fn
encode
(
self
)
-
>
u8
{
self
as
u8
}
}
impl
From
<
FloatCC
>
for
FcmpImm
{
fn
from
(
cond
:
FloatCC
)
-
>
Self
{
match
cond
{
FloatCC
:
:
Equal
=
>
FcmpImm
:
:
Equal
FloatCC
:
:
LessThan
=
>
FcmpImm
:
:
LessThan
FloatCC
:
:
LessThanOrEqual
=
>
FcmpImm
:
:
LessThanOrEqual
FloatCC
:
:
Unordered
=
>
FcmpImm
:
:
Unordered
FloatCC
:
:
NotEqual
=
>
FcmpImm
:
:
NotEqual
FloatCC
:
:
UnorderedOrGreaterThanOrEqual
=
>
FcmpImm
:
:
UnorderedOrGreaterThanOrEqual
FloatCC
:
:
UnorderedOrGreaterThan
=
>
FcmpImm
:
:
UnorderedOrGreaterThan
FloatCC
:
:
Ordered
=
>
FcmpImm
:
:
Ordered
_
=
>
panic
!
(
"
unable
to
create
comparison
predicate
for
{
}
"
cond
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
BranchTarget
{
Label
(
MachLabel
)
ResolvedOffset
(
isize
)
}
impl
ShowWithRRU
for
BranchTarget
{
fn
show_rru
(
&
self
_mb_rru
:
Option
<
&
RealRegUniverse
>
)
-
>
String
{
match
self
{
BranchTarget
:
:
Label
(
l
)
=
>
format
!
(
"
{
:
?
}
"
l
)
BranchTarget
:
:
ResolvedOffset
(
offs
)
=
>
format
!
(
"
(
offset
{
}
)
"
offs
)
}
}
}
impl
BranchTarget
{
pub
fn
as_label
(
&
self
)
-
>
Option
<
MachLabel
>
{
match
self
{
&
BranchTarget
:
:
Label
(
l
)
=
>
Some
(
l
)
_
=
>
None
}
}
pub
fn
as_offset32_or_zero
(
&
self
)
-
>
i32
{
match
self
{
&
BranchTarget
:
:
ResolvedOffset
(
off
)
=
>
{
assert
!
(
off
>
=
-
0x7FFF_FF00
&
&
off
<
=
0x7FFF_FF00
)
;
off
as
i32
}
_
=
>
0
}
}
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
enum
OperandSize
{
Size32
Size64
}
impl
OperandSize
{
pub
(
crate
)
fn
to_bytes
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
Size32
=
>
4
Self
:
:
Size64
=
>
8
}
}
pub
(
crate
)
fn
to_bits
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
Size32
=
>
32
Self
:
:
Size64
=
>
64
}
}
}
