use
crate
:
:
data_value
:
:
DataValue
;
use
crate
:
:
ir
:
:
{
condcodes
:
:
FloatCC
condcodes
:
:
IntCC
types
AbiParam
ArgumentPurpose
ExternalName
Inst
as
IRInst
InstructionData
LibCall
Opcode
Signature
Type
}
;
use
crate
:
:
isa
:
:
x64
:
:
abi
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
args
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
*
;
use
crate
:
:
isa
:
:
{
x64
:
:
settings
as
x64_settings
x64
:
:
X64Backend
CallConv
}
;
use
crate
:
:
machinst
:
:
lower
:
:
*
;
use
crate
:
:
machinst
:
:
*
;
use
crate
:
:
result
:
:
CodegenResult
;
use
crate
:
:
settings
:
:
{
Flags
TlsModel
}
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
vec
:
:
Vec
;
use
cranelift_codegen_shared
:
:
condcodes
:
:
CondCode
;
use
log
:
:
trace
;
use
regalloc
:
:
{
Reg
RegClass
Writable
}
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
use
std
:
:
convert
:
:
TryFrom
;
use
target_lexicon
:
:
Triple
;
fn
is_int_or_ref_ty
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
I8
|
types
:
:
I16
|
types
:
:
I32
|
types
:
:
I64
|
types
:
:
R64
=
>
true
types
:
:
B1
|
types
:
:
B8
|
types
:
:
B16
|
types
:
:
B32
|
types
:
:
B64
=
>
true
types
:
:
R32
=
>
panic
!
(
"
shouldn
'
t
have
32
-
bits
refs
on
x64
"
)
_
=
>
false
}
}
fn
is_bool_ty
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
B1
|
types
:
:
B8
|
types
:
:
B16
|
types
:
:
B32
|
types
:
:
B64
=
>
true
types
:
:
R32
=
>
panic
!
(
"
shouldn
'
t
have
32
-
bits
refs
on
x64
"
)
_
=
>
false
}
}
fn
is_valid_atomic_transaction_ty
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
I8
|
types
:
:
I16
|
types
:
:
I32
|
types
:
:
I64
=
>
true
_
=
>
false
}
}
fn
matches_input
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
input
:
InsnInput
op
:
Opcode
)
-
>
Option
<
IRInst
>
{
let
inputs
=
ctx
.
get_input_as_source_or_const
(
input
.
insn
input
.
input
)
;
inputs
.
inst
.
and_then
(
|
(
src_inst
_
)
|
{
let
data
=
ctx
.
data
(
src_inst
)
;
if
data
.
opcode
(
)
=
=
op
{
return
Some
(
src_inst
)
;
}
None
}
)
}
fn
matches_input_any
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
input
:
InsnInput
ops
:
&
[
Opcode
]
)
-
>
Option
<
IRInst
>
{
let
inputs
=
ctx
.
get_input_as_source_or_const
(
input
.
insn
input
.
input
)
;
inputs
.
inst
.
and_then
(
|
(
src_inst
_
)
|
{
let
data
=
ctx
.
data
(
src_inst
)
;
for
&
op
in
ops
{
if
data
.
opcode
(
)
=
=
op
{
return
Some
(
src_inst
)
;
}
}
None
}
)
}
fn
generate_constant
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
ty
:
Type
c
:
u64
)
-
>
ValueRegs
<
Reg
>
{
let
from_bits
=
ty_bits
(
ty
)
;
let
masked
=
if
from_bits
<
64
{
c
&
(
(
1u64
<
<
from_bits
)
-
1
)
}
else
{
c
}
;
let
cst_copy
=
ctx
.
alloc_tmp
(
ty
)
;
for
inst
in
Inst
:
:
gen_constant
(
cst_copy
masked
as
u128
ty
|
ty
|
{
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
}
)
.
into_iter
(
)
{
ctx
.
emit
(
inst
)
;
}
non_writable_value_regs
(
cst_copy
)
}
fn
put_input_in_regs
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
)
-
>
ValueRegs
<
Reg
>
{
let
ty
=
ctx
.
input_ty
(
spec
.
insn
spec
.
input
)
;
let
input
=
ctx
.
get_input_as_source_or_const
(
spec
.
insn
spec
.
input
)
;
if
let
Some
(
c
)
=
input
.
constant
{
generate_constant
(
ctx
ty
c
)
}
else
{
ctx
.
put_input_in_regs
(
spec
.
insn
spec
.
input
)
}
}
fn
put_input_in_reg
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
)
-
>
Reg
{
put_input_in_regs
(
ctx
spec
)
.
only_reg
(
)
.
expect
(
"
Multi
-
register
value
not
expected
"
)
}
fn
is_mergeable_load
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
src_insn
:
IRInst
)
-
>
Option
<
(
InsnInput
i32
)
>
{
let
insn_data
=
ctx
.
data
(
src_insn
)
;
let
inputs
=
ctx
.
num_inputs
(
src_insn
)
;
if
inputs
!
=
1
{
return
None
;
}
let
load_ty
=
ctx
.
output_ty
(
src_insn
0
)
;
if
ty_bits
(
load_ty
)
<
32
{
return
None
;
}
if
insn_data
.
opcode
(
)
=
=
Opcode
:
:
Load
{
let
offset
=
insn_data
.
load_store_offset
(
)
.
expect
(
"
load
should
have
offset
"
)
;
Some
(
(
InsnInput
{
insn
:
src_insn
input
:
0
}
offset
)
)
}
else
{
None
}
}
fn
input_to_reg_mem
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
)
-
>
RegMem
{
let
inputs
=
ctx
.
get_input_as_source_or_const
(
spec
.
insn
spec
.
input
)
;
if
let
Some
(
c
)
=
inputs
.
constant
{
let
ty
=
ctx
.
input_ty
(
spec
.
insn
spec
.
input
)
;
return
RegMem
:
:
reg
(
generate_constant
(
ctx
ty
c
)
.
only_reg
(
)
.
unwrap
(
)
)
;
}
if
let
Some
(
(
src_insn
0
)
)
=
inputs
.
inst
{
if
let
Some
(
(
addr_input
offset
)
)
=
is_mergeable_load
(
ctx
src_insn
)
{
ctx
.
sink_inst
(
src_insn
)
;
let
amode
=
lower_to_amode
(
ctx
addr_input
offset
)
;
return
RegMem
:
:
mem
(
amode
)
;
}
}
RegMem
:
:
reg
(
ctx
.
put_input_in_regs
(
spec
.
insn
spec
.
input
)
.
only_reg
(
)
.
unwrap
(
)
)
}
#
[
derive
(
Clone
Copy
)
]
enum
ExtSpec
{
ZeroExtendTo32
ZeroExtendTo64
SignExtendTo32
#
[
allow
(
dead_code
)
]
SignExtendTo64
}
fn
extend_input_to_reg
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
ext_spec
:
ExtSpec
)
-
>
Reg
{
let
requested_size
=
match
ext_spec
{
ExtSpec
:
:
ZeroExtendTo32
|
ExtSpec
:
:
SignExtendTo32
=
>
32
ExtSpec
:
:
ZeroExtendTo64
|
ExtSpec
:
:
SignExtendTo64
=
>
64
}
;
let
input_size
=
ctx
.
input_ty
(
spec
.
insn
spec
.
input
)
.
bits
(
)
;
let
requested_ty
=
if
requested_size
=
=
32
{
types
:
:
I32
}
else
{
types
:
:
I64
}
;
let
ext_mode
=
match
(
input_size
requested_size
)
{
(
a
b
)
if
a
=
=
b
=
>
return
put_input_in_reg
(
ctx
spec
)
(
1
8
)
=
>
return
put_input_in_reg
(
ctx
spec
)
(
a
b
)
=
>
ExtMode
:
:
new
(
a
b
)
.
expect
(
&
format
!
(
"
invalid
extension
:
{
}
-
>
{
}
"
a
b
)
)
}
;
let
src
=
input_to_reg_mem
(
ctx
spec
)
;
let
dst
=
ctx
.
alloc_tmp
(
requested_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
match
ext_spec
{
ExtSpec
:
:
ZeroExtendTo32
|
ExtSpec
:
:
ZeroExtendTo64
=
>
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
src
dst
)
)
}
ExtSpec
:
:
SignExtendTo32
|
ExtSpec
:
:
SignExtendTo64
=
>
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
src
dst
)
)
}
}
dst
.
to_reg
(
)
}
fn
non_reg_input_to_sext_imm
(
input
:
NonRegInput
input_ty
:
Type
)
-
>
Option
<
u32
>
{
input
.
constant
.
and_then
(
|
x
|
{
if
input_ty
.
bytes
(
)
!
=
8
|
|
low32_will_sign_extend_to_64
(
x
)
{
Some
(
x
as
u32
)
}
else
{
None
}
}
)
}
fn
input_to_imm
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
)
-
>
Option
<
u64
>
{
ctx
.
get_input_as_source_or_const
(
spec
.
insn
spec
.
input
)
.
constant
}
fn
input_to_reg_mem_imm
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
)
-
>
RegMemImm
{
let
input
=
ctx
.
get_input_as_source_or_const
(
spec
.
insn
spec
.
input
)
;
let
input_ty
=
ctx
.
input_ty
(
spec
.
insn
spec
.
input
)
;
match
non_reg_input_to_sext_imm
(
input
input_ty
)
{
Some
(
x
)
=
>
RegMemImm
:
:
imm
(
x
)
None
=
>
match
input_to_reg_mem
(
ctx
spec
)
{
RegMem
:
:
Reg
{
reg
}
=
>
RegMemImm
:
:
reg
(
reg
)
RegMem
:
:
Mem
{
addr
}
=
>
RegMemImm
:
:
mem
(
addr
)
}
}
}
fn
emit_insert_lane
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
src
:
RegMem
dst
:
Writable
<
Reg
>
lane
:
u8
ty
:
Type
)
{
if
!
ty
.
is_float
(
)
{
let
(
sse_op
size
)
=
match
ty
.
lane_bits
(
)
{
8
=
>
(
SseOpcode
:
:
Pinsrb
OperandSize
:
:
Size32
)
16
=
>
(
SseOpcode
:
:
Pinsrw
OperandSize
:
:
Size32
)
32
=
>
(
SseOpcode
:
:
Pinsrd
OperandSize
:
:
Size32
)
64
=
>
(
SseOpcode
:
:
Pinsrd
OperandSize
:
:
Size64
)
_
=
>
panic
!
(
"
Unable
to
insertlane
for
lane
size
:
{
}
"
ty
.
lane_bits
(
)
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
sse_op
src
dst
lane
size
)
)
;
}
else
if
ty
=
=
types
:
:
F32
{
let
sse_op
=
SseOpcode
:
:
Insertps
;
let
lane
=
0b00_00_00_00
|
lane
<
<
4
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
sse_op
src
dst
lane
OperandSize
:
:
Size32
)
)
;
}
else
if
ty
=
=
types
:
:
F64
{
let
sse_op
=
match
lane
{
0
=
>
SseOpcode
:
:
Movsd
1
=
>
SseOpcode
:
:
Movlhps
_
=
>
unreachable
!
(
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
src
dst
)
)
;
}
else
{
panic
!
(
"
unable
to
emit
insertlane
for
type
:
{
}
"
ty
)
}
}
fn
emit_extract_lane
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
src
:
Reg
dst
:
Writable
<
Reg
>
lane
:
u8
ty
:
Type
)
{
if
!
ty
.
is_float
(
)
{
let
(
sse_op
size
)
=
match
ty
.
lane_bits
(
)
{
8
=
>
(
SseOpcode
:
:
Pextrb
OperandSize
:
:
Size32
)
16
=
>
(
SseOpcode
:
:
Pextrw
OperandSize
:
:
Size32
)
32
=
>
(
SseOpcode
:
:
Pextrd
OperandSize
:
:
Size32
)
64
=
>
(
SseOpcode
:
:
Pextrd
OperandSize
:
:
Size64
)
_
=
>
panic
!
(
"
Unable
to
extractlane
for
lane
size
:
{
}
"
ty
.
lane_bits
(
)
)
}
;
let
src
=
RegMem
:
:
reg
(
src
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
sse_op
src
dst
lane
size
)
)
;
}
else
if
ty
=
=
types
:
:
F32
|
|
ty
=
=
types
:
:
F64
{
if
lane
=
=
0
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
}
else
{
let
sse_op
=
SseOpcode
:
:
Pshufd
;
let
mask
=
match
ty
{
types
:
:
F32
=
>
{
assert
!
(
lane
>
0
&
&
lane
<
4
)
;
0b00_00_00_00
|
lane
}
types
:
:
F64
=
>
{
assert
!
(
lane
=
=
1
)
;
0b11_10_11_10
}
_
=
>
unreachable
!
(
)
}
;
let
src
=
RegMem
:
:
reg
(
src
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
sse_op
src
dst
mask
OperandSize
:
:
Size32
)
)
;
}
}
else
{
panic
!
(
"
unable
to
emit
extractlane
for
type
:
{
}
"
ty
)
}
}
fn
emit_cmp
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
insn
:
IRInst
cc
:
IntCC
)
-
>
IntCC
{
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
let
inputs
=
[
InsnInput
{
insn
input
:
0
}
InsnInput
{
insn
input
:
1
}
]
;
if
ty
=
=
types
:
:
I128
{
let
cmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
cmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
lhs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
lhs_lo
=
lhs
.
regs
(
)
[
0
]
;
let
lhs_hi
=
lhs
.
regs
(
)
[
1
]
;
let
rhs
=
put_input_in_regs
(
ctx
inputs
[
1
]
)
;
let
rhs_lo
=
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
0
]
)
;
let
rhs_hi
=
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
1
]
)
;
match
cc
{
IntCC
:
:
Equal
=
>
{
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
rhs_hi
lhs_hi
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
Z
cmp1
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
rhs_lo
lhs_lo
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
Z
cmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cmp1
.
to_reg
(
)
)
cmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
1
)
cmp2
)
)
;
IntCC
:
:
NotEqual
}
IntCC
:
:
NotEqual
=
>
{
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
rhs_hi
lhs_hi
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
NZ
cmp1
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
rhs_lo
lhs_lo
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
NZ
cmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
cmp1
.
to_reg
(
)
)
cmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
1
)
cmp2
)
)
;
IntCC
:
:
NotEqual
}
IntCC
:
:
SignedLessThan
|
IntCC
:
:
SignedLessThanOrEqual
|
IntCC
:
:
SignedGreaterThan
|
IntCC
:
:
SignedGreaterThanOrEqual
|
IntCC
:
:
UnsignedLessThan
|
IntCC
:
:
UnsignedLessThanOrEqual
|
IntCC
:
:
UnsignedGreaterThan
|
IntCC
:
:
UnsignedGreaterThanOrEqual
=
>
{
let
cmp3
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
rhs_hi
lhs_hi
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
from_intcc
(
cc
.
without_equal
(
)
)
cmp1
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
Z
cmp2
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
rhs_lo
lhs_lo
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
from_intcc
(
cc
.
unsigned
(
)
)
cmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cmp2
.
to_reg
(
)
)
cmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
cmp1
.
to_reg
(
)
)
cmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
1
)
cmp3
)
)
;
IntCC
:
:
NotEqual
}
_
=
>
panic
!
(
"
Unhandled
IntCC
in
I128
comparison
:
{
:
?
}
"
cc
)
}
}
else
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
from_ty
(
ty
)
RegMemImm
:
:
reg
(
rhs
)
lhs
)
)
;
cc
}
}
enum
FcmpSpec
{
Normal
InvertEqual
}
enum
FcmpCondResult
{
Condition
(
CC
)
AndConditions
(
CC
CC
)
OrConditions
(
CC
CC
)
InvertedEqualOrConditions
(
CC
CC
)
}
fn
emit_fcmp
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
insn
:
IRInst
mut
cond_code
:
FloatCC
spec
:
FcmpSpec
)
-
>
FcmpCondResult
{
let
(
flip_operands
inverted_equal
)
=
match
cond_code
{
FloatCC
:
:
LessThan
|
FloatCC
:
:
LessThanOrEqual
|
FloatCC
:
:
UnorderedOrGreaterThan
|
FloatCC
:
:
UnorderedOrGreaterThanOrEqual
=
>
{
cond_code
=
cond_code
.
reverse
(
)
;
(
true
false
)
}
FloatCC
:
:
Equal
=
>
{
let
inverted_equal
=
match
spec
{
FcmpSpec
:
:
Normal
=
>
false
FcmpSpec
:
:
InvertEqual
=
>
{
cond_code
=
FloatCC
:
:
NotEqual
;
true
}
}
;
(
false
inverted_equal
)
}
_
=
>
(
false
false
)
}
;
let
op
=
match
ctx
.
input_ty
(
insn
0
)
{
types
:
:
F32
=
>
SseOpcode
:
:
Ucomiss
types
:
:
F64
=
>
SseOpcode
:
:
Ucomisd
_
=
>
panic
!
(
"
Bad
input
type
to
Fcmp
"
)
}
;
let
inputs
=
&
[
InsnInput
{
insn
input
:
0
}
InsnInput
{
insn
input
:
1
}
]
;
let
(
lhs_input
rhs_input
)
=
if
flip_operands
{
(
inputs
[
1
]
inputs
[
0
]
)
}
else
{
(
inputs
[
0
]
inputs
[
1
]
)
}
;
let
lhs
=
put_input_in_reg
(
ctx
lhs_input
)
;
let
rhs
=
put_input_in_reg
(
ctx
rhs_input
)
;
ctx
.
emit
(
Inst
:
:
xmm_cmp_rm_r
(
op
RegMem
:
:
reg
(
rhs
)
lhs
)
)
;
let
cond_result
=
match
cond_code
{
FloatCC
:
:
Equal
=
>
FcmpCondResult
:
:
AndConditions
(
CC
:
:
NP
CC
:
:
Z
)
FloatCC
:
:
NotEqual
if
inverted_equal
=
>
{
FcmpCondResult
:
:
InvertedEqualOrConditions
(
CC
:
:
P
CC
:
:
NZ
)
}
FloatCC
:
:
NotEqual
if
!
inverted_equal
=
>
FcmpCondResult
:
:
OrConditions
(
CC
:
:
P
CC
:
:
NZ
)
_
=
>
FcmpCondResult
:
:
Condition
(
CC
:
:
from_floatcc
(
cond_code
)
)
}
;
cond_result
}
fn
emit_bitrev
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
src
:
Reg
dst
:
Writable
<
Reg
>
ty
:
Type
)
{
let
bits
=
ty
.
bits
(
)
;
let
const_mask
=
if
bits
=
=
64
{
0xffff_ffff_ffff_ffff
}
else
{
(
1u64
<
<
bits
)
-
1
}
;
let
tmp0
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x5555_5555_5555_5555
&
const_mask
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp0
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
1
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
tmp2
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp0
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x3333_3333_3333_3333
&
const_mask
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
2
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp0
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
2
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
tmp2
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp0
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x0f0f_0f0f_0f0f_0f0f
&
const_mask
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
4
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp0
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
4
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
tmp2
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp0
)
)
;
if
bits
>
8
{
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x00ff_00ff_00ff_00ff
&
const_mask
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
8
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp0
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
8
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
tmp2
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp0
)
)
;
}
if
bits
>
16
{
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x0000_ffff_0000_ffff
&
const_mask
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
16
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp0
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
16
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
tmp2
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp0
)
)
;
}
if
bits
>
32
{
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x0000_0000_ffff_ffff
&
const_mask
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
32
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp0
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
32
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
tmp2
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp0
)
)
;
}
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
tmp0
.
to_reg
(
)
types
:
:
I64
)
)
;
}
fn
emit_shl_i128
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
src
:
ValueRegs
<
Reg
>
dst
:
ValueRegs
<
Writable
<
Reg
>
>
amt_src
:
Reg
)
{
let
src_lo
=
src
.
regs
(
)
[
0
]
;
let
src_hi
=
src
.
regs
(
)
[
1
]
;
let
dst_lo
=
dst
.
regs
(
)
[
0
]
;
let
dst_hi
=
dst
.
regs
(
)
[
1
]
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp3
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
amt
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
src_lo
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
amt_src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
None
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp2
src_hi
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
amt_src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
None
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
64
amt
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
amt_src
)
amt
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp3
src_lo
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
amt
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
None
tmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst_lo
.
to_reg
(
)
)
dst_lo
)
)
;
ctx
.
emit
(
Inst
:
:
test_rmi_r
(
OperandSize
:
:
Size64
RegMemImm
:
:
imm
(
127
)
amt_src
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
dst_lo
.
to_reg
(
)
)
tmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst_hi
.
to_reg
(
)
)
dst_hi
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
amt
amt_src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
64
)
amt
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
tmp3
.
to_reg
(
)
)
dst_hi
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
dst_lo
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
NZ
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
dst_hi
)
)
;
}
fn
emit_shr_i128
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
src
:
ValueRegs
<
Reg
>
dst
:
ValueRegs
<
Writable
<
Reg
>
>
amt_src
:
Reg
is_signed
:
bool
)
{
let
src_lo
=
src
.
regs
(
)
[
0
]
;
let
src_hi
=
src
.
regs
(
)
[
1
]
;
let
dst_lo
=
dst
.
regs
(
)
[
0
]
;
let
dst_hi
=
dst
.
regs
(
)
[
1
]
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp3
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
amt
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
shift_kind
=
if
is_signed
{
ShiftKind
:
:
ShiftRightArithmetic
}
else
{
ShiftKind
:
:
ShiftRightLogical
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
src_hi
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
amt_src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
shift_kind
None
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp2
src_lo
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
amt_src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
None
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
64
amt
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
amt_src
)
amt
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp3
src_hi
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
amt
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
None
tmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst_lo
.
to_reg
(
)
)
dst_lo
)
)
;
ctx
.
emit
(
Inst
:
:
test_rmi_r
(
OperandSize
:
:
Size64
RegMemImm
:
:
imm
(
127
)
amt_src
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
dst_lo
.
to_reg
(
)
)
tmp3
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
tmp3
)
)
;
if
is_signed
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst_hi
src_hi
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightArithmetic
Some
(
63
)
dst_hi
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst_hi
.
to_reg
(
)
)
dst_hi
)
)
;
}
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst_lo
.
to_reg
(
)
)
dst_lo
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
amt
amt_src
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
64
)
amt
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
dst_hi
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
tmp3
.
to_reg
(
)
)
dst_lo
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
NZ
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
dst_lo
)
)
;
}
fn
make_libcall_sig
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
insn
:
IRInst
call_conv
:
CallConv
ptr_ty
:
Type
)
-
>
Signature
{
let
mut
sig
=
Signature
:
:
new
(
call_conv
)
;
for
i
in
0
.
.
ctx
.
num_inputs
(
insn
)
{
sig
.
params
.
push
(
AbiParam
:
:
new
(
ctx
.
input_ty
(
insn
i
)
)
)
;
}
for
i
in
0
.
.
ctx
.
num_outputs
(
insn
)
{
sig
.
returns
.
push
(
AbiParam
:
:
new
(
ctx
.
output_ty
(
insn
i
)
)
)
;
}
if
call_conv
.
extends_baldrdash
(
)
{
sig
.
params
.
push
(
AbiParam
:
:
special
(
ptr_ty
ArgumentPurpose
:
:
VMContext
)
)
;
}
sig
}
fn
emit_vm_call
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
flags
:
&
Flags
triple
:
&
Triple
libcall
:
LibCall
insn
:
IRInst
inputs
:
SmallVec
<
[
InsnInput
;
4
]
>
outputs
:
SmallVec
<
[
InsnOutput
;
2
]
>
)
-
>
CodegenResult
<
(
)
>
{
let
extname
=
ExternalName
:
:
LibCall
(
libcall
)
;
let
dist
=
if
flags
.
use_colocated_libcalls
(
)
{
RelocDistance
:
:
Near
}
else
{
RelocDistance
:
:
Far
}
;
let
call_conv
=
CallConv
:
:
for_libcall
(
flags
CallConv
:
:
triple_default
(
triple
)
)
;
let
sig
=
make_libcall_sig
(
ctx
insn
call_conv
types
:
:
I64
)
;
let
caller_conv
=
ctx
.
abi
(
)
.
call_conv
(
)
;
let
mut
abi
=
X64ABICaller
:
:
from_func
(
&
sig
&
extname
dist
caller_conv
flags
)
?
;
abi
.
emit_stack_pre_adjust
(
ctx
)
;
let
vm_context
=
if
call_conv
.
extends_baldrdash
(
)
{
1
}
else
{
0
}
;
assert_eq
!
(
inputs
.
len
(
)
+
vm_context
abi
.
num_args
(
)
)
;
for
(
i
input
)
in
inputs
.
iter
(
)
.
enumerate
(
)
{
let
arg_reg
=
put_input_in_reg
(
ctx
*
input
)
;
abi
.
emit_copy_regs_to_arg
(
ctx
i
ValueRegs
:
:
one
(
arg_reg
)
)
;
}
if
call_conv
.
extends_baldrdash
(
)
{
let
vm_context_vreg
=
ctx
.
get_vm_context
(
)
.
expect
(
"
should
have
a
VMContext
to
pass
to
libcall
funcs
"
)
;
abi
.
emit_copy_regs_to_arg
(
ctx
inputs
.
len
(
)
ValueRegs
:
:
one
(
vm_context_vreg
)
)
;
}
abi
.
emit_call
(
ctx
)
;
for
(
i
output
)
in
outputs
.
iter
(
)
.
enumerate
(
)
{
let
retval_reg
=
get_output_reg
(
ctx
*
output
)
.
only_reg
(
)
.
unwrap
(
)
;
abi
.
emit_copy_retval_to_regs
(
ctx
i
ValueRegs
:
:
one
(
retval_reg
)
)
;
}
abi
.
emit_stack_post_adjust
(
ctx
)
;
Ok
(
(
)
)
}
fn
matches_small_constant_shift
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
)
-
>
Option
<
(
InsnInput
u8
)
>
{
matches_input
(
ctx
spec
Opcode
:
:
Ishl
)
.
and_then
(
|
shift
|
{
match
input_to_imm
(
ctx
InsnInput
{
insn
:
shift
input
:
1
}
)
{
Some
(
shift_amt
)
if
shift_amt
<
=
3
=
>
Some
(
(
InsnInput
{
insn
:
shift
input
:
0
}
shift_amt
as
u8
)
)
_
=
>
None
}
}
)
}
fn
lower_to_amode
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
spec
:
InsnInput
offset
:
i32
)
-
>
Amode
{
let
flags
=
ctx
.
memflags
(
spec
.
insn
)
.
expect
(
"
Instruction
with
amode
should
have
memflags
"
)
;
if
let
Some
(
add
)
=
matches_input
(
ctx
spec
Opcode
:
:
Iadd
)
{
debug_assert_eq
!
(
ctx
.
output_ty
(
add
0
)
types
:
:
I64
)
;
let
add_inputs
=
&
[
InsnInput
{
insn
:
add
input
:
0
}
InsnInput
{
insn
:
add
input
:
1
}
]
;
let
(
base
index
shift
)
=
if
let
Some
(
(
shift_input
shift_amt
)
)
=
matches_small_constant_shift
(
ctx
add_inputs
[
0
]
)
{
(
put_input_in_reg
(
ctx
add_inputs
[
1
]
)
put_input_in_reg
(
ctx
shift_input
)
shift_amt
)
}
else
if
let
Some
(
(
shift_input
shift_amt
)
)
=
matches_small_constant_shift
(
ctx
add_inputs
[
1
]
)
{
(
put_input_in_reg
(
ctx
add_inputs
[
0
]
)
put_input_in_reg
(
ctx
shift_input
)
shift_amt
)
}
else
{
for
i
in
0
.
.
=
1
{
if
let
Some
(
uextend
)
=
matches_input
(
ctx
InsnInput
{
insn
:
add
input
:
i
}
Opcode
:
:
Uextend
)
{
if
let
Some
(
cst
)
=
ctx
.
get_input_as_source_or_const
(
uextend
0
)
.
constant
{
let
input_size
=
ctx
.
input_ty
(
uextend
0
)
.
bits
(
)
as
u64
;
let
shift
:
u64
=
64
-
input_size
;
let
uext_cst
:
u64
=
(
cst
<
<
shift
)
>
>
shift
;
let
final_offset
=
(
offset
as
i64
)
.
wrapping_add
(
uext_cst
as
i64
)
;
if
low32_will_sign_extend_to_64
(
final_offset
as
u64
)
{
let
base
=
put_input_in_reg
(
ctx
add_inputs
[
1
-
i
]
)
;
return
Amode
:
:
imm_reg
(
final_offset
as
u32
base
)
.
with_flags
(
flags
)
;
}
}
}
if
let
Some
(
cst
)
=
ctx
.
get_input_as_source_or_const
(
add
i
)
.
constant
{
let
final_offset
=
(
offset
as
i64
)
.
wrapping_add
(
cst
as
i64
)
;
if
low32_will_sign_extend_to_64
(
final_offset
as
u64
)
{
let
base
=
put_input_in_reg
(
ctx
add_inputs
[
1
-
i
]
)
;
return
Amode
:
:
imm_reg
(
final_offset
as
u32
base
)
.
with_flags
(
flags
)
;
}
}
}
(
put_input_in_reg
(
ctx
add_inputs
[
0
]
)
put_input_in_reg
(
ctx
add_inputs
[
1
]
)
0
)
}
;
return
Amode
:
:
imm_reg_reg_shift
(
offset
as
u32
base
index
shift
)
.
with_flags
(
flags
)
;
}
let
input
=
put_input_in_reg
(
ctx
spec
)
;
Amode
:
:
imm_reg
(
offset
as
u32
input
)
.
with_flags
(
flags
)
}
fn
emit_moves
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
dst
:
ValueRegs
<
Writable
<
Reg
>
>
src
:
ValueRegs
<
Reg
>
ty
:
Type
)
{
let
(
_
tys
)
=
Inst
:
:
rc_for_type
(
ty
)
.
unwrap
(
)
;
for
(
(
dst
src
)
ty
)
in
dst
.
regs
(
)
.
iter
(
)
.
zip
(
src
.
regs
(
)
.
iter
(
)
)
.
zip
(
tys
.
iter
(
)
)
{
ctx
.
emit
(
Inst
:
:
gen_move
(
*
dst
*
src
*
ty
)
)
;
}
}
fn
emit_cmoves
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
size
:
u8
cc
:
CC
src
:
ValueRegs
<
Reg
>
dst
:
ValueRegs
<
Writable
<
Reg
>
>
)
{
let
size
=
size
/
src
.
len
(
)
as
u8
;
let
size
=
u8
:
:
max
(
size
4
)
;
for
(
dst
src
)
in
dst
.
regs
(
)
.
iter
(
)
.
zip
(
src
.
regs
(
)
.
iter
(
)
)
{
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
from_bytes
(
size
.
into
(
)
)
cc
RegMem
:
:
reg
(
*
src
)
*
dst
)
)
;
}
}
fn
emit_clz
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
orig_ty
:
Type
ty
:
Type
src
:
Reg
dst
:
Writable
<
Reg
>
)
{
let
src
=
RegMem
:
:
reg
(
src
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
from_ty
(
ty
)
u64
:
:
max_value
(
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
from_ty
(
ty
)
UnaryRmROpcode
:
:
Bsr
src
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
from_ty
(
ty
)
CC
:
:
Z
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
from_ty
(
ty
)
orig_ty
.
bits
(
)
as
u64
-
1
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
if
ty
=
=
types
:
:
I64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
fn
emit_ctz
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
orig_ty
:
Type
ty
:
Type
src
:
Reg
dst
:
Writable
<
Reg
>
)
{
let
src
=
RegMem
:
:
reg
(
src
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size32
orig_ty
.
bits
(
)
as
u64
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
from_ty
(
ty
)
UnaryRmROpcode
:
:
Bsf
src
dst
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
from_ty
(
ty
)
CC
:
:
Z
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
fn
lower_insn_to_regs
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
insn
:
IRInst
flags
:
&
Flags
isa_flags
:
&
x64_settings
:
:
Flags
triple
:
&
Triple
)
-
>
CodegenResult
<
(
)
>
{
let
op
=
ctx
.
data
(
insn
)
.
opcode
(
)
;
let
inputs
:
SmallVec
<
[
InsnInput
;
4
]
>
=
(
0
.
.
ctx
.
num_inputs
(
insn
)
)
.
map
(
|
i
|
InsnInput
{
insn
input
:
i
}
)
.
collect
(
)
;
let
outputs
:
SmallVec
<
[
InsnOutput
;
2
]
>
=
(
0
.
.
ctx
.
num_outputs
(
insn
)
)
.
map
(
|
i
|
InsnOutput
{
insn
output
:
i
}
)
.
collect
(
)
;
let
ty
=
if
outputs
.
len
(
)
>
0
{
Some
(
ctx
.
output_ty
(
insn
0
)
)
}
else
{
None
}
;
match
op
{
Opcode
:
:
Iconst
|
Opcode
:
:
Bconst
|
Opcode
:
:
Null
=
>
{
let
value
=
ctx
.
get_constant
(
insn
)
.
expect
(
"
constant
value
for
iconst
et
al
"
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
for
inst
in
Inst
:
:
gen_constant
(
dst
value
as
u128
ty
.
unwrap
(
)
|
ty
|
{
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
}
)
{
ctx
.
emit
(
inst
)
;
}
}
Opcode
:
:
Iadd
|
Opcode
:
:
IaddIfcout
|
Opcode
:
:
SaddSat
|
Opcode
:
:
UaddSat
|
Opcode
:
:
Isub
|
Opcode
:
:
SsubSat
|
Opcode
:
:
UsubSat
|
Opcode
:
:
Imul
|
Opcode
:
:
AvgRound
|
Opcode
:
:
Band
|
Opcode
:
:
Bor
|
Opcode
:
:
Bxor
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
if
ty
.
lane_count
(
)
>
1
{
let
sse_op
=
match
op
{
Opcode
:
:
Iadd
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Paddb
types
:
:
I16X8
=
>
SseOpcode
:
:
Paddw
types
:
:
I32X4
=
>
SseOpcode
:
:
Paddd
types
:
:
I64X2
=
>
SseOpcode
:
:
Paddq
_
=
>
panic
!
(
"
Unsupported
type
for
packed
iadd
instruction
:
{
}
"
ty
)
}
Opcode
:
:
SaddSat
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Paddsb
types
:
:
I16X8
=
>
SseOpcode
:
:
Paddsw
_
=
>
panic
!
(
"
Unsupported
type
for
packed
sadd_sat
instruction
:
{
}
"
ty
)
}
Opcode
:
:
UaddSat
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Paddusb
types
:
:
I16X8
=
>
SseOpcode
:
:
Paddusw
_
=
>
panic
!
(
"
Unsupported
type
for
packed
uadd_sat
instruction
:
{
}
"
ty
)
}
Opcode
:
:
Isub
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Psubb
types
:
:
I16X8
=
>
SseOpcode
:
:
Psubw
types
:
:
I32X4
=
>
SseOpcode
:
:
Psubd
types
:
:
I64X2
=
>
SseOpcode
:
:
Psubq
_
=
>
panic
!
(
"
Unsupported
type
for
packed
isub
instruction
:
{
}
"
ty
)
}
Opcode
:
:
SsubSat
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Psubsb
types
:
:
I16X8
=
>
SseOpcode
:
:
Psubsw
_
=
>
panic
!
(
"
Unsupported
type
for
packed
ssub_sat
instruction
:
{
}
"
ty
)
}
Opcode
:
:
UsubSat
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Psubusb
types
:
:
I16X8
=
>
SseOpcode
:
:
Psubusw
_
=
>
panic
!
(
"
Unsupported
type
for
packed
usub_sat
instruction
:
{
}
"
ty
)
}
Opcode
:
:
Imul
=
>
match
ty
{
types
:
:
I16X8
=
>
SseOpcode
:
:
Pmullw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pmulld
types
:
:
I64X2
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
rhs_1
=
ctx
.
alloc_tmp
(
types
:
:
I64X2
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
rhs_1
rhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psrlq
RegMemImm
:
:
imm
(
32
)
rhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pmuludq
RegMem
:
:
reg
(
lhs
.
clone
(
)
)
rhs_1
)
)
;
let
lhs_1
=
ctx
.
alloc_tmp
(
types
:
:
I64X2
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
lhs_1
lhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psrlq
RegMemImm
:
:
imm
(
32
)
lhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pmuludq
RegMem
:
:
reg
(
rhs
)
lhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Paddq
RegMem
:
:
reg
(
rhs_1
.
to_reg
(
)
)
lhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psllq
RegMemImm
:
:
imm
(
32
)
lhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
rhs_1
rhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pmuludq
RegMem
:
:
reg
(
lhs
.
clone
(
)
)
rhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Paddq
RegMem
:
:
reg
(
lhs_1
.
to_reg
(
)
)
rhs_1
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs_1
.
to_reg
(
)
ty
)
)
;
return
Ok
(
(
)
)
;
}
_
=
>
panic
!
(
"
Unsupported
type
for
packed
imul
instruction
:
{
}
"
ty
)
}
Opcode
:
:
AvgRound
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pavgb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pavgw
_
=
>
panic
!
(
"
Unsupported
type
for
packed
avg_round
instruction
:
{
}
"
ty
)
}
Opcode
:
:
Band
=
>
match
ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Andps
types
:
:
F64X2
=
>
SseOpcode
:
:
Andpd
_
=
>
SseOpcode
:
:
Pand
}
Opcode
:
:
Bor
=
>
match
ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Orps
types
:
:
F64X2
=
>
SseOpcode
:
:
Orpd
_
=
>
SseOpcode
:
:
Por
}
Opcode
:
:
Bxor
=
>
match
ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Xorps
types
:
:
F64X2
=
>
SseOpcode
:
:
Xorpd
_
=
>
SseOpcode
:
:
Pxor
}
_
=
>
panic
!
(
"
Unsupported
packed
instruction
:
{
}
"
op
)
}
;
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
rhs
dst
)
)
;
}
else
if
ty
=
=
types
:
:
I128
|
|
ty
=
=
types
:
:
B128
{
let
alu_ops
=
match
op
{
Opcode
:
:
Iadd
=
>
(
AluRmiROpcode
:
:
Add
AluRmiROpcode
:
:
Adc
)
Opcode
:
:
Isub
=
>
(
AluRmiROpcode
:
:
Sub
AluRmiROpcode
:
:
Sbb
)
Opcode
:
:
Imul
=
>
(
AluRmiROpcode
:
:
Mul
AluRmiROpcode
:
:
Mul
)
Opcode
:
:
Band
=
>
(
AluRmiROpcode
:
:
And
AluRmiROpcode
:
:
And
)
Opcode
:
:
Bor
=
>
(
AluRmiROpcode
:
:
Or
AluRmiROpcode
:
:
Or
)
Opcode
:
:
Bxor
=
>
(
AluRmiROpcode
:
:
Xor
AluRmiROpcode
:
:
Xor
)
_
=
>
panic
!
(
"
Unsupported
opcode
with
128
-
bit
integers
:
{
:
?
}
"
op
)
}
;
let
lhs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_regs
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
assert_eq
!
(
lhs
.
len
(
)
2
)
;
assert_eq
!
(
rhs
.
len
(
)
2
)
;
assert_eq
!
(
dst
.
len
(
)
2
)
;
if
op
!
=
Opcode
:
:
Imul
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
0
]
lhs
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
1
]
lhs
.
regs
(
)
[
1
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
alu_ops
.
0
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
0
]
)
dst
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
alu_ops
.
1
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
1
]
)
dst
.
regs
(
)
[
1
]
)
)
;
}
else
{
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
0
]
lhs
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
0
]
)
dst
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
1
]
lhs
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
1
]
)
dst
.
regs
(
)
[
1
]
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp
lhs
.
regs
(
)
[
1
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
reg
(
rhs
.
regs
(
)
[
0
]
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
.
regs
(
)
[
1
]
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
lhs
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
mul_hi
(
OperandSize
:
:
Size64
false
RegMem
:
:
reg
(
rhs
.
regs
(
)
[
0
]
)
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
regs
:
:
rdx
(
)
)
dst
.
regs
(
)
[
1
]
)
)
;
}
}
else
{
let
size
=
if
ty
=
=
types
:
:
I64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
;
let
alu_op
=
match
op
{
Opcode
:
:
Iadd
|
Opcode
:
:
IaddIfcout
=
>
AluRmiROpcode
:
:
Add
Opcode
:
:
Isub
=
>
AluRmiROpcode
:
:
Sub
Opcode
:
:
Imul
=
>
AluRmiROpcode
:
:
Mul
Opcode
:
:
Band
=
>
AluRmiROpcode
:
:
And
Opcode
:
:
Bor
=
>
AluRmiROpcode
:
:
Or
Opcode
:
:
Bxor
=
>
AluRmiROpcode
:
:
Xor
_
=
>
unreachable
!
(
)
}
;
let
(
lhs
rhs
)
=
match
op
{
Opcode
:
:
Iadd
|
Opcode
:
:
IaddIfcout
|
Opcode
:
:
Imul
|
Opcode
:
:
Band
|
Opcode
:
:
Bor
|
Opcode
:
:
Bxor
=
>
{
let
lhs
=
input_to_reg_mem_imm
(
ctx
inputs
[
0
]
)
;
if
let
RegMemImm
:
:
Reg
{
reg
:
lhs_reg
}
=
lhs
{
let
rhs
=
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
;
(
lhs_reg
rhs
)
}
else
{
let
rhs_reg
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
(
rhs_reg
lhs
)
}
}
Opcode
:
:
Isub
=
>
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
)
_
=
>
unreachable
!
(
)
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
mov_r_r
(
OperandSize
:
:
Size64
lhs
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
size
alu_op
rhs
dst
)
)
;
}
}
Opcode
:
:
BandNot
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
debug_assert
!
(
ty
.
is_vector
(
)
&
&
ty
.
bytes
(
)
=
=
16
)
;
let
lhs
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
sse_op
=
match
ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Andnps
types
:
:
F64X2
=
>
SseOpcode
:
:
Andnpd
_
=
>
SseOpcode
:
:
Pandn
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
lhs
dst
)
)
;
}
Opcode
:
:
Iabs
=
>
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
if
ty
=
=
types
:
:
I64X2
{
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Psubq
src
.
clone
(
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
tmp
.
to_reg
(
)
ty
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
xmm0
(
)
)
tmp
.
to_reg
(
)
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Blendvpd
src
dst
)
)
;
}
else
if
ty
.
is_vector
(
)
{
let
opcode
=
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pabsb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pabsw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pabsd
_
=
>
panic
!
(
"
Unsupported
type
for
packed
iabs
instruction
:
{
}
"
ty
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
opcode
src
dst
)
)
;
}
else
{
unimplemented
!
(
"
iabs
is
unimplemented
for
non
-
vector
type
:
{
}
"
ty
)
;
}
}
Opcode
:
:
Imax
|
Opcode
:
:
Umax
|
Opcode
:
:
Imin
|
Opcode
:
:
Umin
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
if
ty
.
is_vector
(
)
{
let
sse_op
=
match
op
{
Opcode
:
:
Imax
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pmaxsb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pmaxsw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pmaxsd
_
=
>
panic
!
(
"
Unsupported
type
for
packed
{
}
instruction
:
{
}
"
op
ty
)
}
Opcode
:
:
Umax
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pmaxub
types
:
:
I16X8
=
>
SseOpcode
:
:
Pmaxuw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pmaxud
_
=
>
panic
!
(
"
Unsupported
type
for
packed
{
}
instruction
:
{
}
"
op
ty
)
}
Opcode
:
:
Imin
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pminsb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pminsw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pminsd
_
=
>
panic
!
(
"
Unsupported
type
for
packed
{
}
instruction
:
{
}
"
op
ty
)
}
Opcode
:
:
Umin
=
>
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pminub
types
:
:
I16X8
=
>
SseOpcode
:
:
Pminuw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pminud
_
=
>
panic
!
(
"
Unsupported
type
for
packed
{
}
instruction
:
{
}
"
op
ty
)
}
_
=
>
unreachable
!
(
"
This
is
a
bug
:
the
external
and
internal
match
op
should
be
over
the
same
opcodes
.
"
)
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
rhs
dst
)
)
;
}
else
{
panic
!
(
"
Unsupported
type
for
{
}
instruction
:
{
}
"
op
ty
)
;
}
}
Opcode
:
:
Bnot
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
if
ty
.
is_vector
(
)
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
equals
(
ty
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xor
(
ty
RegMem
:
:
from
(
tmp
)
dst
)
)
;
}
else
if
ty
=
=
types
:
:
I128
|
|
ty
=
=
types
:
:
B128
{
let
src
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
0
]
src
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
not
(
OperandSize
:
:
Size64
dst
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
1
]
src
.
regs
(
)
[
1
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
not
(
OperandSize
:
:
Size64
dst
.
regs
(
)
[
1
]
)
)
;
}
else
if
ty
.
is_bool
(
)
{
unimplemented
!
(
"
bool
bnot
"
)
}
else
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
ctx
.
emit
(
Inst
:
:
not
(
OperandSize
:
:
from_ty
(
ty
)
dst
)
)
;
}
}
Opcode
:
:
Bitselect
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
let
condition
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
if_true
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
if_false
=
input_to_reg_mem
(
ctx
inputs
[
2
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
if
ty
.
is_vector
(
)
{
let
tmp1
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp1
if_true
ty
)
)
;
ctx
.
emit
(
Inst
:
:
and
(
ty
RegMem
:
:
reg
(
condition
.
clone
(
)
)
tmp1
)
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp2
condition
ty
)
)
;
ctx
.
emit
(
Inst
:
:
and_not
(
ty
if_false
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
tmp2
.
to_reg
(
)
ty
)
)
;
ctx
.
emit
(
Inst
:
:
or
(
ty
RegMem
:
:
from
(
tmp1
)
dst
)
)
;
}
else
{
unimplemented
!
(
"
scalar
bitselect
"
)
}
}
Opcode
:
:
Ishl
|
Opcode
:
:
Ushr
|
Opcode
:
:
Sshr
|
Opcode
:
:
Rotl
|
Opcode
:
:
Rotr
=
>
{
let
dst_ty
=
ctx
.
output_ty
(
insn
0
)
;
debug_assert_eq
!
(
ctx
.
input_ty
(
insn
0
)
dst_ty
)
;
if
!
dst_ty
.
is_vector
(
)
&
&
dst_ty
.
bits
(
)
<
=
64
{
let
(
size
lhs
)
=
match
dst_ty
{
types
:
:
I8
|
types
:
:
I16
=
>
match
op
{
Opcode
:
:
Ishl
=
>
(
OperandSize
:
:
Size32
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
Opcode
:
:
Ushr
=
>
(
OperandSize
:
:
Size32
extend_input_to_reg
(
ctx
inputs
[
0
]
ExtSpec
:
:
ZeroExtendTo32
)
)
Opcode
:
:
Sshr
=
>
(
OperandSize
:
:
Size32
extend_input_to_reg
(
ctx
inputs
[
0
]
ExtSpec
:
:
SignExtendTo32
)
)
Opcode
:
:
Rotl
|
Opcode
:
:
Rotr
=
>
(
OperandSize
:
:
from_ty
(
dst_ty
)
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
_
=
>
unreachable
!
(
)
}
types
:
:
I32
|
types
:
:
I64
=
>
(
OperandSize
:
:
from_ty
(
dst_ty
)
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
_
=
>
unreachable
!
(
"
unhandled
output
type
for
shift
/
rotates
:
{
}
"
dst_ty
)
}
;
let
(
count
rhs
)
=
if
let
Some
(
cst
)
=
ctx
.
get_input_as_source_or_const
(
insn
1
)
.
constant
{
let
cst
=
(
cst
as
u8
)
&
(
dst_ty
.
bits
(
)
as
u8
-
1
)
;
(
Some
(
cst
)
None
)
}
else
{
(
None
Some
(
put_input_in_regs
(
ctx
inputs
[
1
]
)
.
regs
(
)
[
0
]
)
)
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
shift_kind
=
match
op
{
Opcode
:
:
Ishl
=
>
ShiftKind
:
:
ShiftLeft
Opcode
:
:
Ushr
=
>
ShiftKind
:
:
ShiftRightLogical
Opcode
:
:
Sshr
=
>
ShiftKind
:
:
ShiftRightArithmetic
Opcode
:
:
Rotl
=
>
ShiftKind
:
:
RotateLeft
Opcode
:
:
Rotr
=
>
ShiftKind
:
:
RotateRight
_
=
>
unreachable
!
(
)
}
;
let
w_rcx
=
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
;
ctx
.
emit
(
Inst
:
:
mov_r_r
(
OperandSize
:
:
Size64
lhs
dst
)
)
;
if
count
.
is_none
(
)
{
ctx
.
emit
(
Inst
:
:
mov_r_r
(
OperandSize
:
:
Size64
rhs
.
unwrap
(
)
w_rcx
)
)
;
}
ctx
.
emit
(
Inst
:
:
shift_r
(
size
shift_kind
count
dst
)
)
;
}
else
if
dst_ty
=
=
types
:
:
I128
{
let
amt_src
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
src
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
match
op
{
Opcode
:
:
Ishl
=
>
{
emit_shl_i128
(
ctx
src
dst
amt_src
)
;
}
Opcode
:
:
Ushr
=
>
{
emit_shr_i128
(
ctx
src
dst
amt_src
false
)
;
}
Opcode
:
:
Sshr
=
>
{
emit_shr_i128
(
ctx
src
dst
amt_src
true
)
;
}
Opcode
:
:
Rotl
=
>
{
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I128
)
;
emit_shl_i128
(
ctx
src
tmp
amt_src
)
;
let
inv_amt
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
128
inv_amt
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
amt_src
)
inv_amt
)
)
;
emit_shr_i128
(
ctx
src
dst
inv_amt
.
to_reg
(
)
false
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp
.
regs
(
)
[
0
]
.
to_reg
(
)
)
dst
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp
.
regs
(
)
[
1
]
.
to_reg
(
)
)
dst
.
regs
(
)
[
1
]
)
)
;
}
Opcode
:
:
Rotr
=
>
{
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I128
)
;
emit_shr_i128
(
ctx
src
tmp
amt_src
false
)
;
let
inv_amt
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
128
inv_amt
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
amt_src
)
inv_amt
)
)
;
emit_shl_i128
(
ctx
src
dst
inv_amt
.
to_reg
(
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp
.
regs
(
)
[
0
]
.
to_reg
(
)
)
dst
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp
.
regs
(
)
[
1
]
.
to_reg
(
)
)
dst
.
regs
(
)
[
1
]
)
)
;
}
_
=
>
unreachable
!
(
)
}
}
else
if
dst_ty
=
=
types
:
:
I8X16
&
&
(
op
=
=
Opcode
:
:
Ishl
|
|
op
=
=
Opcode
:
:
Ushr
)
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
shift_by
=
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
shift_by_moved
=
match
&
shift_by
{
RegMemImm
:
:
Imm
{
.
.
}
=
>
shift_by
.
clone
(
)
RegMemImm
:
:
Reg
{
reg
}
=
>
{
let
tmp_shift_by
=
ctx
.
alloc_tmp
(
dst_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
SseOpcode
:
:
Movd
RegMem
:
:
reg
(
*
reg
)
OperandSize
:
:
Size32
tmp_shift_by
)
)
;
RegMemImm
:
:
reg
(
tmp_shift_by
.
to_reg
(
)
)
}
RegMemImm
:
:
Mem
{
.
.
}
=
>
unimplemented
!
(
"
load
shift
amount
to
XMM
register
"
)
}
;
let
shift_opcode
=
match
op
{
Opcode
:
:
Ishl
=
>
SseOpcode
:
:
Psllw
Opcode
:
:
Ushr
=
>
SseOpcode
:
:
Psrlw
_
=
>
unimplemented
!
(
"
{
}
is
not
implemented
for
type
{
}
"
op
dst_ty
)
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
dst_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
shift_opcode
shift_by_moved
dst
)
)
;
const
USHR_MASKS
:
[
u8
;
128
]
=
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
]
;
const
SHL_MASKS
:
[
u8
;
128
]
=
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
]
;
let
mask
=
match
op
{
Opcode
:
:
Ishl
=
>
&
SHL_MASKS
Opcode
:
:
Ushr
=
>
&
USHR_MASKS
_
=
>
unimplemented
!
(
"
{
}
is
not
implemented
for
type
{
}
"
op
dst_ty
)
}
;
let
mask_address
=
match
shift_by
{
RegMemImm
:
:
Imm
{
simm32
}
=
>
{
debug_assert
!
(
simm32
<
8
)
;
let
mask_offset
=
simm32
as
usize
*
16
;
let
mask_constant
=
ctx
.
use_constant
(
VCodeConstantData
:
:
WellKnown
(
&
mask
[
mask_offset
.
.
mask_offset
+
16
]
)
)
;
SyntheticAmode
:
:
ConstantOffset
(
mask_constant
)
}
RegMemImm
:
:
Reg
{
reg
}
=
>
{
let
base_mask_address
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
mask_offset
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
mask_constant
=
ctx
.
use_constant
(
VCodeConstantData
:
:
WellKnown
(
mask
)
)
;
ctx
.
emit
(
Inst
:
:
lea
(
SyntheticAmode
:
:
ConstantOffset
(
mask_constant
)
base_mask_address
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
mask_offset
reg
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftLeft
Some
(
4
)
mask_offset
)
)
;
Amode
:
:
imm_reg_reg_shift
(
0
base_mask_address
.
to_reg
(
)
mask_offset
.
to_reg
(
)
0
)
.
into
(
)
}
RegMemImm
:
:
Mem
{
addr
:
_
}
=
>
unimplemented
!
(
"
load
mask
address
"
)
}
;
let
mask_value
=
ctx
.
alloc_tmp
(
dst_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
load
(
dst_ty
mask_address
mask_value
ExtKind
:
:
None
)
)
;
let
sse_op
=
match
dst_ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Andps
types
:
:
F64X2
=
>
SseOpcode
:
:
Andpd
_
=
>
SseOpcode
:
:
Pand
}
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
RegMem
:
:
from
(
mask_value
)
dst
)
)
;
}
else
if
dst_ty
=
=
types
:
:
I8X16
&
&
op
=
=
Opcode
:
:
Sshr
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
shift_by
=
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
;
let
shift_by_ty
=
ctx
.
input_ty
(
insn
1
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
bigger_shift_by
=
match
shift_by
{
RegMemImm
:
:
Imm
{
simm32
}
=
>
RegMemImm
:
:
imm
(
simm32
+
8
)
RegMemImm
:
:
Reg
{
reg
}
=
>
{
let
bigger_shift_by_gpr
=
ctx
.
alloc_tmp
(
shift_by_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
mov_r_r
(
OperandSize
:
:
Size64
reg
bigger_shift_by_gpr
)
)
;
let
size
=
if
shift_by_ty
=
=
types
:
:
I64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
;
let
imm
=
RegMemImm
:
:
imm
(
8
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
size
AluRmiROpcode
:
:
Add
imm
bigger_shift_by_gpr
)
)
;
let
bigger_shift_by_xmm
=
ctx
.
alloc_tmp
(
dst_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
SseOpcode
:
:
Movd
RegMem
:
:
from
(
bigger_shift_by_gpr
)
OperandSize
:
:
Size32
bigger_shift_by_xmm
)
)
;
RegMemImm
:
:
reg
(
bigger_shift_by_xmm
.
to_reg
(
)
)
}
RegMemImm
:
:
Mem
{
.
.
}
=
>
unimplemented
!
(
"
load
shift
amount
to
XMM
register
"
)
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
dst_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Punpcklbw
RegMem
:
:
from
(
dst
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psraw
bigger_shift_by
.
clone
(
)
dst
)
)
;
let
upper_lanes
=
ctx
.
alloc_tmp
(
dst_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
upper_lanes
src
dst_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Punpckhbw
RegMem
:
:
from
(
upper_lanes
)
upper_lanes
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psraw
bigger_shift_by
upper_lanes
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Packsswb
RegMem
:
:
from
(
upper_lanes
)
dst
)
)
;
}
else
if
dst_ty
=
=
types
:
:
I64X2
&
&
op
=
=
Opcode
:
:
Sshr
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
dst_ty
)
)
;
let
lower_lane
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
emit_extract_lane
(
ctx
src
lower_lane
0
types
:
:
I64
)
;
let
upper_lane
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
emit_extract_lane
(
ctx
src
upper_lane
1
types
:
:
I64
)
;
let
mut
shift
=
|
reg
:
Writable
<
Reg
>
|
{
let
kind
=
ShiftKind
:
:
ShiftRightArithmetic
;
if
let
Some
(
shift_by
)
=
ctx
.
get_input_as_source_or_const
(
insn
1
)
.
constant
{
let
shift_by
=
(
shift_by
as
u8
)
&
(
types
:
:
I64
.
bits
(
)
as
u8
-
1
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
kind
Some
(
shift_by
)
reg
)
)
;
}
else
{
let
dynamic_shift_by
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
w_rcx
=
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
;
ctx
.
emit
(
Inst
:
:
mov_r_r
(
OperandSize
:
:
Size64
dynamic_shift_by
w_rcx
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
kind
None
reg
)
)
;
}
;
}
;
shift
(
lower_lane
)
;
shift
(
upper_lane
)
;
emit_insert_lane
(
ctx
RegMem
:
:
from
(
lower_lane
)
dst
0
types
:
:
I64
)
;
emit_insert_lane
(
ctx
RegMem
:
:
from
(
upper_lane
)
dst
1
types
:
:
I64
)
;
}
else
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
shift_by
=
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
sse_op
=
match
dst_ty
{
types
:
:
I16X8
=
>
match
op
{
Opcode
:
:
Ishl
=
>
SseOpcode
:
:
Psllw
Opcode
:
:
Ushr
=
>
SseOpcode
:
:
Psrlw
Opcode
:
:
Sshr
=
>
SseOpcode
:
:
Psraw
_
=
>
unimplemented
!
(
"
{
}
is
not
implemented
for
type
{
}
"
op
dst_ty
)
}
types
:
:
I32X4
=
>
match
op
{
Opcode
:
:
Ishl
=
>
SseOpcode
:
:
Pslld
Opcode
:
:
Ushr
=
>
SseOpcode
:
:
Psrld
Opcode
:
:
Sshr
=
>
SseOpcode
:
:
Psrad
_
=
>
unimplemented
!
(
"
{
}
is
not
implemented
for
type
{
}
"
op
dst_ty
)
}
types
:
:
I64X2
=
>
match
op
{
Opcode
:
:
Ishl
=
>
SseOpcode
:
:
Psllq
Opcode
:
:
Ushr
=
>
SseOpcode
:
:
Psrlq
_
=
>
unimplemented
!
(
"
{
}
is
not
implemented
for
type
{
}
"
op
dst_ty
)
}
_
=
>
unreachable
!
(
)
}
;
let
shift_by
=
match
shift_by
{
RegMemImm
:
:
Imm
{
.
.
}
=
>
shift_by
RegMemImm
:
:
Reg
{
reg
}
=
>
{
let
tmp_shift_by
=
ctx
.
alloc_tmp
(
dst_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
SseOpcode
:
:
Movd
RegMem
:
:
reg
(
reg
)
OperandSize
:
:
Size32
tmp_shift_by
)
)
;
RegMemImm
:
:
reg
(
tmp_shift_by
.
to_reg
(
)
)
}
RegMemImm
:
:
Mem
{
.
.
}
=
>
unimplemented
!
(
"
load
shift
amount
to
XMM
register
"
)
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
dst_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
sse_op
shift_by
dst
)
)
;
}
}
Opcode
:
:
Ineg
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
if
ty
.
is_vector
(
)
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I32X4
)
.
only_reg
(
)
.
unwrap
(
)
;
let
subtract_opcode
=
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Psubb
types
:
:
I16X8
=
>
SseOpcode
:
:
Psubw
types
:
:
I32X4
=
>
SseOpcode
:
:
Psubd
types
:
:
I64X2
=
>
SseOpcode
:
:
Psubq
_
=
>
panic
!
(
"
Unsupported
type
for
Ineg
instruction
found
{
}
"
ty
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
subtract_opcode
src
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
SseOpcode
:
:
Movapd
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
else
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
ctx
.
emit
(
Inst
:
:
neg
(
OperandSize
:
:
from_ty
(
ty
)
dst
)
)
;
}
}
Opcode
:
:
Clz
=
>
{
let
orig_ty
=
ty
.
unwrap
(
)
;
if
isa_flags
.
use_lzcnt
(
)
&
&
(
orig_ty
=
=
types
:
:
I32
|
|
orig_ty
=
=
types
:
:
I64
)
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
from_ty
(
orig_ty
)
UnaryRmROpcode
:
:
Lzcnt
src
dst
)
)
;
return
Ok
(
(
)
)
;
}
if
orig_ty
=
=
types
:
:
I128
{
let
dsts
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
let
dst
=
dsts
.
regs
(
)
[
0
]
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
srcs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
src_lo
=
srcs
.
regs
(
)
[
0
]
;
let
src_hi
=
srcs
.
regs
(
)
[
1
]
;
emit_clz
(
ctx
types
:
:
I64
types
:
:
I64
src_hi
tmp1
)
;
emit_clz
(
ctx
types
:
:
I64
types
:
:
I64
src_lo
dst
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
imm
(
64
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
RegMemImm
:
:
imm
(
64
)
tmp1
.
to_reg
(
)
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
NZ
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dsts
.
regs
(
)
[
1
]
.
to_reg
(
)
)
dsts
.
regs
(
)
[
1
]
)
)
;
}
else
{
let
(
ext_spec
ty
)
=
match
orig_ty
{
types
:
:
I8
|
types
:
:
I16
=
>
(
Some
(
ExtSpec
:
:
ZeroExtendTo32
)
types
:
:
I32
)
a
if
a
=
=
types
:
:
I32
|
|
a
=
=
types
:
:
I64
=
>
(
None
a
)
_
=
>
unreachable
!
(
)
}
;
let
src
=
if
let
Some
(
ext_spec
)
=
ext_spec
{
extend_input_to_reg
(
ctx
inputs
[
0
]
ext_spec
)
}
else
{
put_input_in_reg
(
ctx
inputs
[
0
]
)
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
emit_clz
(
ctx
orig_ty
ty
src
dst
)
;
}
}
Opcode
:
:
Ctz
=
>
{
let
orig_ty
=
ctx
.
input_ty
(
insn
0
)
;
if
isa_flags
.
use_bmi1
(
)
&
&
(
orig_ty
=
=
types
:
:
I32
|
|
orig_ty
=
=
types
:
:
I64
)
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
from_ty
(
orig_ty
)
UnaryRmROpcode
:
:
Tzcnt
src
dst
)
)
;
return
Ok
(
(
)
)
;
}
if
orig_ty
=
=
types
:
:
I128
{
let
dsts
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
let
dst
=
dsts
.
regs
(
)
[
0
]
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
srcs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
src_lo
=
srcs
.
regs
(
)
[
0
]
;
let
src_hi
=
srcs
.
regs
(
)
[
1
]
;
emit_ctz
(
ctx
types
:
:
I64
types
:
:
I64
src_lo
dst
)
;
emit_ctz
(
ctx
types
:
:
I64
types
:
:
I64
src_hi
tmp1
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
imm
(
64
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
RegMemImm
:
:
imm
(
64
)
dst
.
to_reg
(
)
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
OperandSize
:
:
Size64
CC
:
:
Z
RegMem
:
:
reg
(
tmp1
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dsts
.
regs
(
)
[
1
]
.
to_reg
(
)
)
dsts
.
regs
(
)
[
1
]
)
)
;
}
else
{
let
ty
=
if
orig_ty
.
bits
(
)
<
32
{
types
:
:
I32
}
else
{
orig_ty
}
;
debug_assert
!
(
ty
=
=
types
:
:
I32
|
|
ty
=
=
types
:
:
I64
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
emit_ctz
(
ctx
orig_ty
ty
src
dst
)
;
}
}
Opcode
:
:
Popcnt
=
>
{
let
(
ext_spec
ty
)
=
match
ctx
.
input_ty
(
insn
0
)
{
types
:
:
I8
|
types
:
:
I16
=
>
(
Some
(
ExtSpec
:
:
ZeroExtendTo32
)
types
:
:
I32
)
a
if
a
=
=
types
:
:
I32
|
|
a
=
=
types
:
:
I64
|
|
a
=
=
types
:
:
I128
=
>
(
None
a
)
_
=
>
unreachable
!
(
)
}
;
if
isa_flags
.
use_popcnt
(
)
{
match
ty
{
types
:
:
I32
|
types
:
:
I64
=
>
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
from_ty
(
ty
)
UnaryRmROpcode
:
:
Popcnt
src
dst
)
)
;
return
Ok
(
(
)
)
;
}
types
:
:
I128
=
>
{
let
dsts
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
let
dst
=
dsts
.
regs
(
)
[
0
]
;
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
srcs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
src_lo
=
srcs
.
regs
(
)
[
0
]
;
let
src_hi
=
srcs
.
regs
(
)
[
1
]
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
Size64
UnaryRmROpcode
:
:
Popcnt
RegMem
:
:
reg
(
src_lo
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
OperandSize
:
:
Size64
UnaryRmROpcode
:
:
Popcnt
RegMem
:
:
reg
(
src_hi
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dsts
.
regs
(
)
[
1
]
.
to_reg
(
)
)
dsts
.
regs
(
)
[
1
]
)
)
;
return
Ok
(
(
)
)
;
}
_
=
>
{
}
}
}
let
(
srcs
ty
)
:
(
SmallVec
<
[
RegMem
;
2
]
>
Type
)
=
if
let
Some
(
ext_spec
)
=
ext_spec
{
(
smallvec
!
[
RegMem
:
:
reg
(
extend_input_to_reg
(
ctx
inputs
[
0
]
ext_spec
)
)
]
ty
)
}
else
if
ty
=
=
types
:
:
I128
{
let
regs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
(
smallvec
!
[
RegMem
:
:
reg
(
regs
.
regs
(
)
[
0
]
)
RegMem
:
:
reg
(
regs
.
regs
(
)
[
1
]
)
]
types
:
:
I64
)
}
else
{
(
smallvec
!
[
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
]
ty
)
}
;
let
mut
dsts
:
SmallVec
<
[
Reg
;
2
]
>
=
smallvec
!
[
]
;
for
src
in
srcs
{
let
dst
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
dsts
.
push
(
dst
.
to_reg
(
)
)
;
if
ty
=
=
types
:
:
I64
{
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
cst
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
.
clone
(
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x7777777777777777
cst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
RegMem
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
4
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x0F0F0F0F0F0F0F0F
cst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0x0101010101010101
cst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
56
)
dst
)
)
;
}
else
{
assert_eq
!
(
ty
types
:
:
I32
)
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
.
clone
(
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size32
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x77777777
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size32
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x77777777
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size32
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x77777777
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
RegMem
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size32
ShiftKind
:
:
ShiftRightLogical
Some
(
4
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x0F0F0F0F
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
imm
(
0x01010101
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size32
ShiftKind
:
:
ShiftRightLogical
Some
(
24
)
dst
)
)
;
}
}
if
dsts
.
len
(
)
=
=
1
{
let
final_dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
final_dst
dsts
[
0
]
types
:
:
I64
)
)
;
}
else
{
assert
!
(
dsts
.
len
(
)
=
=
2
)
;
let
final_dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
final_dst
.
regs
(
)
[
0
]
dsts
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
dsts
[
1
]
)
final_dst
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
final_dst
.
regs
(
)
[
1
]
.
to_reg
(
)
)
final_dst
.
regs
(
)
[
1
]
)
)
;
}
}
Opcode
:
:
Bitrev
=
>
{
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
assert
!
(
ty
=
=
types
:
:
I8
|
|
ty
=
=
types
:
:
I16
|
|
ty
=
=
types
:
:
I32
|
|
ty
=
=
types
:
:
I64
|
|
ty
=
=
types
:
:
I128
)
;
if
ty
=
=
types
:
:
I128
{
let
src
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
emit_bitrev
(
ctx
src
.
regs
(
)
[
0
]
dst
.
regs
(
)
[
1
]
types
:
:
I64
)
;
emit_bitrev
(
ctx
src
.
regs
(
)
[
1
]
dst
.
regs
(
)
[
0
]
types
:
:
I64
)
;
}
else
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
emit_bitrev
(
ctx
src
dst
ty
)
;
}
}
Opcode
:
:
IsNull
|
Opcode
:
:
IsInvalid
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
let
imm
=
match
op
{
Opcode
:
:
IsNull
=
>
{
0
}
Opcode
:
:
IsInvalid
=
>
{
0xffffffff
}
_
=
>
unreachable
!
(
)
}
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
from_ty
(
ty
)
RegMemImm
:
:
imm
(
imm
)
src
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
Z
dst
)
)
;
}
Opcode
:
:
Uextend
|
Opcode
:
:
Sextend
|
Opcode
:
:
Bint
|
Opcode
:
:
Breduce
|
Opcode
:
:
Bextend
|
Opcode
:
:
Ireduce
=
>
{
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
dst_ty
=
ctx
.
output_ty
(
insn
0
)
;
if
src_ty
=
=
types
:
:
I128
{
assert
!
(
dst_ty
.
bits
(
)
<
=
64
)
;
assert
!
(
op
=
=
Opcode
:
:
Ireduce
)
;
let
src
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
}
else
if
dst_ty
=
=
types
:
:
I128
{
assert
!
(
src_ty
.
bits
(
)
<
=
64
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
assert
!
(
op
=
=
Opcode
:
:
Uextend
|
|
op
=
=
Opcode
:
:
Sextend
|
|
op
=
=
Opcode
:
:
Bint
)
;
let
ext_mode
=
ExtMode
:
:
new
(
src_ty
.
bits
(
)
64
)
;
if
let
Some
(
ext_mode
)
=
ext_mode
{
if
op
=
=
Opcode
:
:
Sextend
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
RegMem
:
:
reg
(
src
)
dst
.
regs
(
)
[
0
]
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
RegMem
:
:
reg
(
src
)
dst
.
regs
(
)
[
0
]
)
)
;
}
}
else
{
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
RegMem
:
:
reg
(
src
)
dst
.
regs
(
)
[
0
]
)
)
;
}
if
op
=
=
Opcode
:
:
Sextend
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
1
]
dst
.
regs
(
)
[
0
]
.
to_reg
(
)
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightArithmetic
Some
(
63
)
dst
.
regs
(
)
[
1
]
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size64
AluRmiROpcode
:
:
Xor
RegMemImm
:
:
reg
(
dst
.
regs
(
)
[
1
]
.
to_reg
(
)
)
dst
.
regs
(
)
[
1
]
)
)
;
}
}
else
{
if
src_ty
=
=
types
:
:
I32
&
&
dst_ty
=
=
types
:
:
I64
&
&
op
!
=
Opcode
:
:
Sextend
{
if
let
Some
(
_
)
=
matches_input_any
(
ctx
inputs
[
0
]
&
[
Opcode
:
:
Iadd
Opcode
:
:
IaddIfcout
Opcode
:
:
Isub
Opcode
:
:
Imul
Opcode
:
:
Band
Opcode
:
:
Bor
Opcode
:
:
Bxor
]
)
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
types
:
:
I64
)
)
;
return
Ok
(
(
)
)
;
}
}
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ext_mode
=
ExtMode
:
:
new
(
src_ty
.
bits
(
)
dst_ty
.
bits
(
)
)
;
assert_eq
!
(
src_ty
.
bits
(
)
<
dst_ty
.
bits
(
)
ext_mode
.
is_some
(
)
"
unexpected
extension
:
{
}
-
>
{
}
"
src_ty
dst_ty
)
;
if
let
Some
(
ext_mode
)
=
ext_mode
{
if
op
=
=
Opcode
:
:
Sextend
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
src
dst
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
src
dst
)
)
;
}
}
else
{
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
dst
)
)
;
}
}
}
Opcode
:
:
Icmp
=
>
{
let
condcode
=
ctx
.
data
(
insn
)
.
cond_code
(
)
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
if
!
ty
.
is_vector
(
)
{
let
condcode
=
emit_cmp
(
ctx
insn
condcode
)
;
let
cc
=
CC
:
:
from_intcc
(
condcode
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc
dst
)
)
;
}
else
{
assert_eq
!
(
ty
.
bits
(
)
128
)
;
let
eq
=
|
ty
|
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pcmpeqb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pcmpeqw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pcmpeqd
types
:
:
I64X2
=
>
SseOpcode
:
:
Pcmpeqq
_
=
>
panic
!
(
"
Unable
to
find
an
instruction
for
{
}
for
type
:
{
}
"
condcode
ty
)
}
;
let
gt
=
|
ty
|
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pcmpgtb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pcmpgtw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pcmpgtd
types
:
:
I64X2
=
>
SseOpcode
:
:
Pcmpgtq
_
=
>
panic
!
(
"
Unable
to
find
an
instruction
for
{
}
for
type
:
{
}
"
condcode
ty
)
}
;
let
maxu
=
|
ty
|
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pmaxub
types
:
:
I16X8
=
>
SseOpcode
:
:
Pmaxuw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pmaxud
_
=
>
panic
!
(
"
Unable
to
find
an
instruction
for
{
}
for
type
:
{
}
"
condcode
ty
)
}
;
let
mins
=
|
ty
|
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pminsb
types
:
:
I16X8
=
>
SseOpcode
:
:
Pminsw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pminsd
_
=
>
panic
!
(
"
Unable
to
find
an
instruction
for
{
}
for
type
:
{
}
"
condcode
ty
)
}
;
let
minu
=
|
ty
|
match
ty
{
types
:
:
I8X16
=
>
SseOpcode
:
:
Pminub
types
:
:
I16X8
=
>
SseOpcode
:
:
Pminuw
types
:
:
I32X4
=
>
SseOpcode
:
:
Pminud
_
=
>
panic
!
(
"
Unable
to
find
an
instruction
for
{
}
for
type
:
{
}
"
condcode
ty
)
}
;
let
input
=
match
condcode
{
IntCC
:
:
SignedLessThanOrEqual
if
ty
=
=
types
:
:
I64X2
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
ty
)
)
;
rhs
}
IntCC
:
:
SignedGreaterThanOrEqual
if
ty
=
=
types
:
:
I64X2
=
>
{
let
lhs
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
ty
)
)
;
lhs
}
IntCC
:
:
SignedLessThan
|
IntCC
:
:
SignedLessThanOrEqual
|
IntCC
:
:
UnsignedLessThan
|
IntCC
:
:
UnsignedLessThanOrEqual
=
>
{
let
lhs
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
ty
)
)
;
lhs
}
_
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
ty
)
)
;
rhs
}
}
;
match
condcode
{
IntCC
:
:
Equal
=
>
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
input
dst
)
)
IntCC
:
:
NotEqual
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
input
dst
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp
)
dst
)
)
;
}
IntCC
:
:
SignedGreaterThan
|
IntCC
:
:
SignedLessThan
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
gt
(
ty
)
input
dst
)
)
}
IntCC
:
:
SignedGreaterThanOrEqual
|
IntCC
:
:
SignedLessThanOrEqual
if
ty
!
=
types
:
:
I64X2
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
mins
(
ty
)
input
.
clone
(
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
input
dst
)
)
}
IntCC
:
:
SignedGreaterThanOrEqual
|
IntCC
:
:
SignedLessThanOrEqual
if
ty
=
=
types
:
:
I64X2
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
gt
(
ty
)
input
dst
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp
)
dst
)
)
;
}
IntCC
:
:
UnsignedGreaterThan
|
IntCC
:
:
UnsignedLessThan
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
maxu
(
ty
)
input
.
clone
(
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
input
dst
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp
)
dst
)
)
;
}
IntCC
:
:
UnsignedGreaterThanOrEqual
|
IntCC
:
:
UnsignedLessThanOrEqual
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
minu
(
ty
)
input
.
clone
(
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
ty
)
input
dst
)
)
}
_
=
>
unimplemented
!
(
"
Unimplemented
comparison
code
for
icmp
:
{
}
"
condcode
)
}
}
}
Opcode
:
:
Fcmp
=
>
{
let
cond_code
=
ctx
.
data
(
insn
)
.
fp_cond_code
(
)
.
unwrap
(
)
;
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
if
!
input_ty
.
is_vector
(
)
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
match
emit_fcmp
(
ctx
insn
cond_code
FcmpSpec
:
:
Normal
)
{
FcmpCondResult
:
:
Condition
(
cc
)
=
>
{
ctx
.
emit
(
Inst
:
:
setcc
(
cc
dst
)
)
;
}
FcmpCondResult
:
:
AndConditions
(
cc1
cc2
)
=
>
{
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I32
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc1
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc2
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
FcmpCondResult
:
:
OrConditions
(
cc1
cc2
)
=
>
{
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I32
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc1
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc2
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
Or
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
FcmpCondResult
:
:
InvertedEqualOrConditions
(
_
_
)
=
>
unreachable
!
(
)
}
}
else
{
let
op
=
match
input_ty
{
types
:
:
F32X4
=
>
SseOpcode
:
:
Cmpps
types
:
:
F64X2
=
>
SseOpcode
:
:
Cmppd
_
=
>
panic
!
(
"
Bad
input
type
to
fcmp
:
{
}
"
input_ty
)
}
;
let
(
imm
flip
)
=
match
cond_code
{
FloatCC
:
:
GreaterThan
=
>
(
FcmpImm
:
:
LessThan
true
)
FloatCC
:
:
GreaterThanOrEqual
=
>
(
FcmpImm
:
:
LessThanOrEqual
true
)
FloatCC
:
:
UnorderedOrLessThan
=
>
(
FcmpImm
:
:
UnorderedOrGreaterThan
true
)
FloatCC
:
:
UnorderedOrLessThanOrEqual
=
>
{
(
FcmpImm
:
:
UnorderedOrGreaterThanOrEqual
true
)
}
FloatCC
:
:
OrderedNotEqual
|
FloatCC
:
:
UnorderedOrEqual
=
>
{
panic
!
(
"
unsupported
float
condition
code
:
{
}
"
cond_code
)
}
_
=
>
(
FcmpImm
:
:
from
(
cond_code
)
false
)
}
;
let
(
lhs
rhs
)
=
if
flip
{
(
put_input_in_reg
(
ctx
inputs
[
1
]
)
input_to_reg_mem
(
ctx
inputs
[
0
]
)
)
}
else
{
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
input_to_reg_mem
(
ctx
inputs
[
1
]
)
)
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
input_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
op
rhs
dst
imm
.
encode
(
)
OperandSize
:
:
Size32
)
)
;
}
}
Opcode
:
:
FallthroughReturn
|
Opcode
:
:
Return
=
>
{
for
i
in
0
.
.
ctx
.
num_inputs
(
insn
)
{
let
src_reg
=
put_input_in_regs
(
ctx
inputs
[
i
]
)
;
let
retval_reg
=
ctx
.
retval
(
i
)
;
let
ty
=
ctx
.
input_ty
(
insn
i
)
;
assert
!
(
src_reg
.
len
(
)
=
=
retval_reg
.
len
(
)
)
;
let
(
_
tys
)
=
Inst
:
:
rc_for_type
(
ty
)
?
;
for
(
(
&
src
&
dst
)
&
ty
)
in
src_reg
.
regs
(
)
.
iter
(
)
.
zip
(
retval_reg
.
regs
(
)
.
iter
(
)
)
.
zip
(
tys
.
iter
(
)
)
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
}
}
}
Opcode
:
:
Call
|
Opcode
:
:
CallIndirect
=
>
{
let
caller_conv
=
ctx
.
abi
(
)
.
call_conv
(
)
;
let
(
mut
abi
inputs
)
=
match
op
{
Opcode
:
:
Call
=
>
{
let
(
extname
dist
)
=
ctx
.
call_target
(
insn
)
.
unwrap
(
)
;
let
sig
=
ctx
.
call_sig
(
insn
)
.
unwrap
(
)
;
assert_eq
!
(
inputs
.
len
(
)
sig
.
params
.
len
(
)
)
;
assert_eq
!
(
outputs
.
len
(
)
sig
.
returns
.
len
(
)
)
;
(
X64ABICaller
:
:
from_func
(
sig
&
extname
dist
caller_conv
flags
)
?
&
inputs
[
.
.
]
)
}
Opcode
:
:
CallIndirect
=
>
{
let
ptr
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
sig
=
ctx
.
call_sig
(
insn
)
.
unwrap
(
)
;
assert_eq
!
(
inputs
.
len
(
)
-
1
sig
.
params
.
len
(
)
)
;
assert_eq
!
(
outputs
.
len
(
)
sig
.
returns
.
len
(
)
)
;
(
X64ABICaller
:
:
from_ptr
(
sig
ptr
op
caller_conv
flags
)
?
&
inputs
[
1
.
.
]
)
}
_
=
>
unreachable
!
(
)
}
;
abi
.
emit_stack_pre_adjust
(
ctx
)
;
assert_eq
!
(
inputs
.
len
(
)
abi
.
num_args
(
)
)
;
for
i
in
abi
.
get_copy_to_arg_order
(
)
{
let
input
=
inputs
[
i
]
;
let
arg_regs
=
put_input_in_regs
(
ctx
input
)
;
abi
.
emit_copy_regs_to_arg
(
ctx
i
arg_regs
)
;
}
abi
.
emit_call
(
ctx
)
;
for
(
i
output
)
in
outputs
.
iter
(
)
.
enumerate
(
)
{
let
retval_regs
=
get_output_reg
(
ctx
*
output
)
;
abi
.
emit_copy_retval_to_regs
(
ctx
i
retval_regs
)
;
}
abi
.
emit_stack_post_adjust
(
ctx
)
;
}
Opcode
:
:
Debugtrap
=
>
{
ctx
.
emit
(
Inst
:
:
Hlt
)
;
}
Opcode
:
:
Trap
|
Opcode
:
:
ResumableTrap
=
>
{
let
trap_code
=
ctx
.
data
(
insn
)
.
trap_code
(
)
.
unwrap
(
)
;
ctx
.
emit_safepoint
(
Inst
:
:
Ud2
{
trap_code
}
)
;
}
Opcode
:
:
Trapif
|
Opcode
:
:
Trapff
=
>
{
let
trap_code
=
ctx
.
data
(
insn
)
.
trap_code
(
)
.
unwrap
(
)
;
if
matches_input
(
ctx
inputs
[
0
]
Opcode
:
:
IaddIfcout
)
.
is_some
(
)
{
let
cond_code
=
ctx
.
data
(
insn
)
.
cond_code
(
)
.
unwrap
(
)
;
let
cc
=
CC
:
:
from_intcc
(
cond_code
)
;
ctx
.
emit_safepoint
(
Inst
:
:
TrapIf
{
trap_code
cc
}
)
;
}
else
if
op
=
=
Opcode
:
:
Trapif
{
let
cond_code
=
ctx
.
data
(
insn
)
.
cond_code
(
)
.
unwrap
(
)
;
let
ifcmp
=
matches_input
(
ctx
inputs
[
0
]
Opcode
:
:
Ifcmp
)
.
unwrap
(
)
;
let
cond_code
=
emit_cmp
(
ctx
ifcmp
cond_code
)
;
let
cc
=
CC
:
:
from_intcc
(
cond_code
)
;
ctx
.
emit_safepoint
(
Inst
:
:
TrapIf
{
trap_code
cc
}
)
;
}
else
{
let
cond_code
=
ctx
.
data
(
insn
)
.
fp_cond_code
(
)
.
unwrap
(
)
;
let
ffcmp
=
matches_input
(
ctx
inputs
[
0
]
Opcode
:
:
Ffcmp
)
.
unwrap
(
)
;
match
emit_fcmp
(
ctx
ffcmp
cond_code
FcmpSpec
:
:
Normal
)
{
FcmpCondResult
:
:
Condition
(
cc
)
=
>
{
ctx
.
emit_safepoint
(
Inst
:
:
TrapIf
{
trap_code
cc
}
)
}
FcmpCondResult
:
:
AndConditions
(
cc1
cc2
)
=
>
{
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I32
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I32
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc1
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc2
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit_safepoint
(
Inst
:
:
TrapIf
{
trap_code
cc
:
CC
:
:
NZ
}
)
;
}
FcmpCondResult
:
:
OrConditions
(
cc1
cc2
)
=
>
{
ctx
.
emit_safepoint
(
Inst
:
:
TrapIf
{
trap_code
cc
:
cc1
}
)
;
ctx
.
emit_safepoint
(
Inst
:
:
TrapIf
{
trap_code
cc
:
cc2
}
)
;
}
FcmpCondResult
:
:
InvertedEqualOrConditions
(
_
_
)
=
>
unreachable
!
(
)
}
;
}
;
}
Opcode
:
:
F64const
=
>
{
let
value
=
ctx
.
get_constant
(
insn
)
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
for
inst
in
Inst
:
:
gen_constant
(
dst
value
as
u128
types
:
:
F64
|
ty
|
{
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
}
)
{
ctx
.
emit
(
inst
)
;
}
}
Opcode
:
:
F32const
=
>
{
let
value
=
ctx
.
get_constant
(
insn
)
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
for
inst
in
Inst
:
:
gen_constant
(
dst
value
as
u128
types
:
:
F32
|
ty
|
{
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
}
)
{
ctx
.
emit
(
inst
)
;
}
}
Opcode
:
:
WideningPairwiseDotProductS
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
ty
)
)
;
if
ty
=
=
types
:
:
I32X4
{
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pmaddwd
rhs
dst
)
)
;
}
else
{
panic
!
(
"
Opcode
:
:
WideningPairwiseDotProductS
:
unsupported
laneage
:
{
:
?
}
"
ty
)
;
}
}
Opcode
:
:
Fadd
|
Opcode
:
:
Fsub
|
Opcode
:
:
Fmul
|
Opcode
:
:
Fdiv
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
1
]
)
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
lhs
ty
)
)
;
let
sse_op
=
match
ty
{
types
:
:
F32
=
>
match
op
{
Opcode
:
:
Fadd
=
>
SseOpcode
:
:
Addss
Opcode
:
:
Fsub
=
>
SseOpcode
:
:
Subss
Opcode
:
:
Fmul
=
>
SseOpcode
:
:
Mulss
Opcode
:
:
Fdiv
=
>
SseOpcode
:
:
Divss
_
=
>
unreachable
!
(
)
}
types
:
:
F64
=
>
match
op
{
Opcode
:
:
Fadd
=
>
SseOpcode
:
:
Addsd
Opcode
:
:
Fsub
=
>
SseOpcode
:
:
Subsd
Opcode
:
:
Fmul
=
>
SseOpcode
:
:
Mulsd
Opcode
:
:
Fdiv
=
>
SseOpcode
:
:
Divsd
_
=
>
unreachable
!
(
)
}
types
:
:
F32X4
=
>
match
op
{
Opcode
:
:
Fadd
=
>
SseOpcode
:
:
Addps
Opcode
:
:
Fsub
=
>
SseOpcode
:
:
Subps
Opcode
:
:
Fmul
=
>
SseOpcode
:
:
Mulps
Opcode
:
:
Fdiv
=
>
SseOpcode
:
:
Divps
_
=
>
unreachable
!
(
)
}
types
:
:
F64X2
=
>
match
op
{
Opcode
:
:
Fadd
=
>
SseOpcode
:
:
Addpd
Opcode
:
:
Fsub
=
>
SseOpcode
:
:
Subpd
Opcode
:
:
Fmul
=
>
SseOpcode
:
:
Mulpd
Opcode
:
:
Fdiv
=
>
SseOpcode
:
:
Divpd
_
=
>
unreachable
!
(
)
}
_
=
>
panic
!
(
"
invalid
type
:
expected
one
of
[
F32
F64
F32X4
F64X2
]
found
{
}
"
ty
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
rhs
dst
)
)
;
}
Opcode
:
:
Fmin
|
Opcode
:
:
Fmax
=
>
{
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
is_min
=
op
=
=
Opcode
:
:
Fmin
;
let
output_ty
=
ty
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
output_ty
)
)
;
if
!
output_ty
.
is_vector
(
)
{
let
op_size
=
match
output_ty
{
types
:
:
F32
=
>
OperandSize
:
:
Size32
types
:
:
F64
=
>
OperandSize
:
:
Size64
_
=
>
panic
!
(
"
unexpected
type
{
:
?
}
for
fmin
/
fmax
"
output_ty
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_min_max_seq
(
op_size
is_min
lhs
dst
)
)
;
}
else
{
if
is_min
{
let
(
mov_op
min_op
or_op
cmp_op
shift_op
shift_by
andn_op
)
=
match
output_ty
{
types
:
:
F32X4
=
>
(
SseOpcode
:
:
Movaps
SseOpcode
:
:
Minps
SseOpcode
:
:
Orps
SseOpcode
:
:
Cmpps
SseOpcode
:
:
Psrld
10
SseOpcode
:
:
Andnps
)
types
:
:
F64X2
=
>
(
SseOpcode
:
:
Movapd
SseOpcode
:
:
Minpd
SseOpcode
:
:
Orpd
SseOpcode
:
:
Cmppd
SseOpcode
:
:
Psrlq
13
SseOpcode
:
:
Andnpd
)
_
=
>
unimplemented
!
(
"
unsupported
op
type
{
:
?
}
"
output_ty
)
}
;
let
tmp_xmm1
=
ctx
.
alloc_tmp
(
output_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
mov_op
RegMem
:
:
reg
(
lhs
)
tmp_xmm1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
min_op
RegMem
:
:
from
(
dst
)
tmp_xmm1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
min_op
RegMem
:
:
reg
(
lhs
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
or_op
RegMem
:
:
from
(
dst
)
tmp_xmm1
)
)
;
let
cond
=
FcmpImm
:
:
from
(
FloatCC
:
:
Unordered
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
cmp_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
cond
.
encode
(
)
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
or_op
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp_xmm1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
shift_op
RegMemImm
:
:
imm
(
shift_by
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
andn_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
)
)
;
}
else
{
let
(
mov_op
max_op
xor_op
or_op
sub_op
cmp_op
shift_op
shift_by
andn_op
)
=
match
output_ty
{
types
:
:
F32X4
=
>
(
SseOpcode
:
:
Movaps
SseOpcode
:
:
Maxps
SseOpcode
:
:
Xorps
SseOpcode
:
:
Orps
SseOpcode
:
:
Subps
SseOpcode
:
:
Cmpps
SseOpcode
:
:
Psrld
10
SseOpcode
:
:
Andnps
)
types
:
:
F64X2
=
>
(
SseOpcode
:
:
Movapd
SseOpcode
:
:
Maxpd
SseOpcode
:
:
Xorpd
SseOpcode
:
:
Orpd
SseOpcode
:
:
Subpd
SseOpcode
:
:
Cmppd
SseOpcode
:
:
Psrlq
13
SseOpcode
:
:
Andnpd
)
_
=
>
unimplemented
!
(
"
unsupported
op
type
{
:
?
}
"
output_ty
)
}
;
let
tmp_xmm1
=
ctx
.
alloc_tmp
(
types
:
:
F32
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
mov_op
RegMem
:
:
reg
(
lhs
)
tmp_xmm1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
max_op
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp_xmm1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
max_op
RegMem
:
:
reg
(
lhs
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
xor_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
or_op
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp_xmm1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sub_op
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp_xmm1
)
)
;
let
cond
=
FcmpImm
:
:
from
(
FloatCC
:
:
Unordered
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
cmp_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
cond
.
encode
(
)
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
shift_op
RegMemImm
:
:
imm
(
shift_by
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
andn_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
)
)
;
}
}
}
Opcode
:
:
FminPseudo
|
Opcode
:
:
FmaxPseudo
=
>
{
let
lhs
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
ty
)
)
;
let
sse_opcode
=
match
(
ty
op
)
{
(
types
:
:
F32X4
Opcode
:
:
FminPseudo
)
=
>
SseOpcode
:
:
Minps
(
types
:
:
F32X4
Opcode
:
:
FmaxPseudo
)
=
>
SseOpcode
:
:
Maxps
(
types
:
:
F64X2
Opcode
:
:
FminPseudo
)
=
>
SseOpcode
:
:
Minpd
(
types
:
:
F64X2
Opcode
:
:
FmaxPseudo
)
=
>
SseOpcode
:
:
Maxpd
_
=
>
unimplemented
!
(
"
unsupported
type
{
}
for
{
}
"
ty
op
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_opcode
lhs
dst
)
)
;
}
Opcode
:
:
Sqrt
=
>
{
let
src
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
let
sse_op
=
match
ty
{
types
:
:
F32
=
>
SseOpcode
:
:
Sqrtss
types
:
:
F64
=
>
SseOpcode
:
:
Sqrtsd
types
:
:
F32X4
=
>
SseOpcode
:
:
Sqrtps
types
:
:
F64X2
=
>
SseOpcode
:
:
Sqrtpd
_
=
>
panic
!
(
"
invalid
type
:
expected
one
of
[
F32
F64
F32X4
F64X2
]
found
{
}
"
ty
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
sse_op
src
dst
)
)
;
}
Opcode
:
:
Fpromote
=
>
{
let
src
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
SseOpcode
:
:
Cvtss2sd
src
dst
)
)
;
}
Opcode
:
:
Fdemote
=
>
{
let
src
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
SseOpcode
:
:
Cvtsd2ss
src
dst
)
)
;
}
Opcode
:
:
FcvtFromSint
=
>
{
let
output_ty
=
ty
.
unwrap
(
)
;
if
!
output_ty
.
is_vector
(
)
{
let
(
ext_spec
src_size
)
=
match
ctx
.
input_ty
(
insn
0
)
{
types
:
:
I8
|
types
:
:
I16
=
>
(
Some
(
ExtSpec
:
:
SignExtendTo32
)
OperandSize
:
:
Size32
)
types
:
:
I32
=
>
(
None
OperandSize
:
:
Size32
)
types
:
:
I64
=
>
(
None
OperandSize
:
:
Size64
)
_
=
>
unreachable
!
(
)
}
;
let
src
=
match
ext_spec
{
Some
(
ext_spec
)
=
>
RegMem
:
:
reg
(
extend_input_to_reg
(
ctx
inputs
[
0
]
ext_spec
)
)
None
=
>
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
}
;
let
opcode
=
if
output_ty
=
=
types
:
:
F32
{
SseOpcode
:
:
Cvtsi2ss
}
else
{
assert_eq
!
(
output_ty
types
:
:
F64
)
;
SseOpcode
:
:
Cvtsi2sd
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
opcode
src
src_size
dst
)
)
;
}
else
{
let
ty
=
ty
.
unwrap
(
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
opcode
=
match
ctx
.
input_ty
(
insn
0
)
{
types
:
:
I32X4
=
>
SseOpcode
:
:
Cvtdq2ps
_
=
>
{
unimplemented
!
(
"
unable
to
use
type
{
}
for
op
{
}
"
ctx
.
input_ty
(
insn
0
)
op
)
}
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
opcode
RegMem
:
:
from
(
dst
)
dst
)
)
;
}
}
Opcode
:
:
FcvtLowFromSint
=
>
{
let
src
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
SseOpcode
:
:
Cvtdq2pd
RegMem
:
:
from
(
src
)
dst
)
)
;
}
Opcode
:
:
FcvtFromUint
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
if
!
ty
.
is_vector
(
)
{
match
input_ty
{
types
:
:
I8
|
types
:
:
I16
|
types
:
:
I32
=
>
{
let
opcode
=
if
ty
=
=
types
:
:
F32
{
SseOpcode
:
:
Cvtsi2ss
}
else
{
assert_eq
!
(
ty
types
:
:
F64
)
;
SseOpcode
:
:
Cvtsi2sd
}
;
let
src
=
RegMem
:
:
reg
(
extend_input_to_reg
(
ctx
inputs
[
0
]
ExtSpec
:
:
ZeroExtendTo64
)
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
opcode
src
OperandSize
:
:
Size64
dst
)
)
;
}
types
:
:
I64
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
src_copy
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
src_copy
src
types
:
:
I64
)
)
;
let
tmp_gpr1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp_gpr2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
cvt_u64_to_float_seq
(
if
ty
=
=
types
:
:
F64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
src_copy
tmp_gpr1
tmp_gpr2
dst
)
)
;
}
_
=
>
panic
!
(
"
unexpected
input
type
for
FcvtFromUint
:
{
:
?
}
"
input_ty
)
}
;
}
else
{
assert_eq
!
(
ctx
.
input_ty
(
insn
0
)
types
:
:
I32X4
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I32X4
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
SseOpcode
:
:
Movapd
RegMem
:
:
reg
(
src
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Pslld
RegMemImm
:
:
imm
(
16
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psrld
RegMemImm
:
:
imm
(
16
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Psubd
RegMem
:
:
from
(
tmp
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Cvtdq2ps
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psrld
RegMemImm
:
:
imm
(
1
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Cvtdq2ps
RegMem
:
:
from
(
dst
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Addps
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Addps
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
}
Opcode
:
:
FcvtToUint
|
Opcode
:
:
FcvtToUintSat
|
Opcode
:
:
FcvtToSint
|
Opcode
:
:
FcvtToSintSat
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
if
!
input_ty
.
is_vector
(
)
{
let
src_size
=
if
input_ty
=
=
types
:
:
F32
{
OperandSize
:
:
Size32
}
else
{
assert_eq
!
(
input_ty
types
:
:
F64
)
;
OperandSize
:
:
Size64
}
;
let
output_ty
=
ty
.
unwrap
(
)
;
let
dst_size
=
if
output_ty
=
=
types
:
:
I32
{
OperandSize
:
:
Size32
}
else
{
assert_eq
!
(
output_ty
types
:
:
I64
)
;
OperandSize
:
:
Size64
}
;
let
to_signed
=
op
=
=
Opcode
:
:
FcvtToSint
|
|
op
=
=
Opcode
:
:
FcvtToSintSat
;
let
is_sat
=
op
=
=
Opcode
:
:
FcvtToUintSat
|
|
op
=
=
Opcode
:
:
FcvtToSintSat
;
let
src_copy
=
ctx
.
alloc_tmp
(
input_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
src_copy
src
input_ty
)
)
;
let
tmp_xmm
=
ctx
.
alloc_tmp
(
input_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp_gpr
=
ctx
.
alloc_tmp
(
output_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
if
to_signed
{
ctx
.
emit
(
Inst
:
:
cvt_float_to_sint_seq
(
src_size
dst_size
is_sat
src_copy
dst
tmp_gpr
tmp_xmm
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
cvt_float_to_uint_seq
(
src_size
dst_size
is_sat
src_copy
dst
tmp_gpr
tmp_xmm
)
)
;
}
}
else
{
if
op
=
=
Opcode
:
:
FcvtToSintSat
{
assert_eq
!
(
types
:
:
F32X4
ctx
.
input_ty
(
insn
0
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I32X4
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_unary_rm_r
(
SseOpcode
:
:
Movapd
RegMem
:
:
reg
(
src
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
input_ty
)
)
;
let
cond
=
FcmpImm
:
:
from
(
FloatCC
:
:
Equal
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Cmpps
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
tmp
cond
.
encode
(
)
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Andps
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Cvttps2dq
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pand
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psrad
RegMemImm
:
:
imm
(
31
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
else
if
op
=
=
Opcode
:
:
FcvtToUintSat
{
assert_eq
!
(
types
:
:
F32X4
ctx
.
input_ty
(
insn
0
)
)
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I32X4
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I32X4
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp2
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
input_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Maxps
RegMem
:
:
from
(
tmp2
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pcmpeqd
RegMem
:
:
from
(
tmp2
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rmi_reg
(
SseOpcode
:
:
Psrld
RegMemImm
:
:
imm
(
1
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Cvtdq2ps
RegMem
:
:
from
(
tmp2
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Movaps
RegMem
:
:
from
(
dst
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Cvttps2dq
RegMem
:
:
from
(
dst
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Subps
RegMem
:
:
from
(
tmp2
)
tmp1
)
)
;
let
cond
=
FcmpImm
:
:
from
(
FloatCC
:
:
LessThanOrEqual
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Cmpps
RegMem
:
:
from
(
tmp1
)
tmp2
cond
.
encode
(
)
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Cvttps2dq
RegMem
:
:
from
(
tmp1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp2
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp2
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pmaxsd
RegMem
:
:
from
(
tmp2
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Paddd
RegMem
:
:
from
(
tmp1
)
dst
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
Opcode
:
:
UwidenHigh
|
Opcode
:
:
UwidenLow
|
Opcode
:
:
SwidenHigh
|
Opcode
:
:
SwidenLow
=
>
{
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
output_ty
=
ctx
.
output_ty
(
insn
0
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
if
output_ty
.
is_vector
(
)
{
match
op
{
Opcode
:
:
SwidenLow
=
>
match
(
input_ty
output_ty
)
{
(
types
:
:
I8X16
types
:
:
I16X8
)
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxbw
RegMem
:
:
reg
(
src
)
dst
)
)
;
}
(
types
:
:
I16X8
types
:
:
I32X4
)
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxwd
RegMem
:
:
reg
(
src
)
dst
)
)
;
}
_
=
>
unreachable
!
(
)
}
Opcode
:
:
SwidenHigh
=
>
match
(
input_ty
output_ty
)
{
(
types
:
:
I8X16
types
:
:
I16X8
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
output_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Palignr
RegMem
:
:
reg
(
src
)
dst
8
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxbw
RegMem
:
:
from
(
dst
)
dst
)
)
;
}
(
types
:
:
I16X8
types
:
:
I32X4
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
output_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Palignr
RegMem
:
:
reg
(
src
)
dst
8
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxwd
RegMem
:
:
from
(
dst
)
dst
)
)
;
}
_
=
>
unreachable
!
(
)
}
Opcode
:
:
UwidenLow
=
>
match
(
input_ty
output_ty
)
{
(
types
:
:
I8X16
types
:
:
I16X8
)
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxbw
RegMem
:
:
reg
(
src
)
dst
)
)
;
}
(
types
:
:
I16X8
types
:
:
I32X4
)
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxwd
RegMem
:
:
reg
(
src
)
dst
)
)
;
}
_
=
>
unreachable
!
(
)
}
Opcode
:
:
UwidenHigh
=
>
match
(
input_ty
output_ty
)
{
(
types
:
:
I8X16
types
:
:
I16X8
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
output_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Palignr
RegMem
:
:
reg
(
src
)
dst
8
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxbw
RegMem
:
:
from
(
dst
)
dst
)
)
;
}
(
types
:
:
I16X8
types
:
:
I32X4
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
output_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Palignr
RegMem
:
:
reg
(
src
)
dst
8
OperandSize
:
:
Size32
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxwd
RegMem
:
:
from
(
dst
)
dst
)
)
;
}
_
=
>
unreachable
!
(
)
}
_
=
>
unreachable
!
(
)
}
}
else
{
panic
!
(
"
Unsupported
non
-
vector
type
for
widen
instruction
{
:
?
}
"
ty
)
;
}
}
Opcode
:
:
Snarrow
|
Opcode
:
:
Unarrow
=
>
{
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
output_ty
=
ctx
.
output_ty
(
insn
0
)
;
let
src1
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
src2
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
if
output_ty
.
is_vector
(
)
{
match
op
{
Opcode
:
:
Snarrow
=
>
match
(
input_ty
output_ty
)
{
(
types
:
:
I16X8
types
:
:
I8X16
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src1
input_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Packsswb
RegMem
:
:
reg
(
src2
)
dst
)
)
;
}
(
types
:
:
I32X4
types
:
:
I16X8
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src1
input_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Packssdw
RegMem
:
:
reg
(
src2
)
dst
)
)
;
}
_
=
>
unreachable
!
(
)
}
Opcode
:
:
Unarrow
=
>
match
(
input_ty
output_ty
)
{
(
types
:
:
I16X8
types
:
:
I8X16
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src1
input_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Packuswb
RegMem
:
:
reg
(
src2
)
dst
)
)
;
}
(
types
:
:
I32X4
types
:
:
I16X8
)
=
>
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src1
input_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Packusdw
RegMem
:
:
reg
(
src2
)
dst
)
)
;
}
_
=
>
unreachable
!
(
)
}
_
=
>
unreachable
!
(
)
}
}
else
{
panic
!
(
"
Unsupported
non
-
vector
type
for
widen
instruction
{
:
?
}
"
ty
)
;
}
}
Opcode
:
:
Bitcast
=
>
{
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
output_ty
=
ctx
.
output_ty
(
insn
0
)
;
match
(
input_ty
output_ty
)
{
(
types
:
:
F32
types
:
:
I32
)
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_to_gpr
(
SseOpcode
:
:
Movd
src
dst
OperandSize
:
:
Size32
)
)
;
}
(
types
:
:
I32
types
:
:
F32
)
=
>
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
SseOpcode
:
:
Movd
src
OperandSize
:
:
Size32
dst
)
)
;
}
(
types
:
:
F64
types
:
:
I64
)
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_to_gpr
(
SseOpcode
:
:
Movq
src
dst
OperandSize
:
:
Size64
)
)
;
}
(
types
:
:
I64
types
:
:
F64
)
=
>
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
SseOpcode
:
:
Movq
src
OperandSize
:
:
Size64
dst
)
)
;
}
_
=
>
unreachable
!
(
"
invalid
bitcast
from
{
:
?
}
to
{
:
?
}
"
input_ty
output_ty
)
}
}
Opcode
:
:
Fabs
|
Opcode
:
:
Fneg
=
>
{
let
src
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
0
]
)
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
output_ty
=
ty
.
unwrap
(
)
;
if
!
output_ty
.
is_vector
(
)
{
let
(
val
opcode
)
:
(
u64
_
)
=
match
output_ty
{
types
:
:
F32
=
>
match
op
{
Opcode
:
:
Fabs
=
>
(
0x7fffffff
SseOpcode
:
:
Andps
)
Opcode
:
:
Fneg
=
>
(
0x80000000
SseOpcode
:
:
Xorps
)
_
=
>
unreachable
!
(
)
}
types
:
:
F64
=
>
match
op
{
Opcode
:
:
Fabs
=
>
(
0x7fffffffffffffff
SseOpcode
:
:
Andpd
)
Opcode
:
:
Fneg
=
>
(
0x8000000000000000
SseOpcode
:
:
Xorpd
)
_
=
>
unreachable
!
(
)
}
_
=
>
panic
!
(
"
unexpected
type
{
:
?
}
for
Fabs
"
output_ty
)
}
;
for
inst
in
Inst
:
:
gen_constant
(
ValueRegs
:
:
one
(
dst
)
val
as
u128
output_ty
|
ty
|
{
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
}
)
{
ctx
.
emit
(
inst
)
;
}
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
opcode
src
dst
)
)
;
}
else
{
if
output_ty
.
bits
(
)
=
=
128
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
output_ty
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
output_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Xorps
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
let
cond
=
FcmpImm
:
:
from
(
FloatCC
:
:
Equal
)
;
let
cmpps
=
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Cmpps
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
tmp
cond
.
encode
(
)
OperandSize
:
:
Size32
)
;
ctx
.
emit
(
cmpps
)
;
let
lane_bits
=
output_ty
.
lane_bits
(
)
;
let
(
shift_opcode
opcode
shift_by
)
=
match
(
op
lane_bits
)
{
(
Opcode
:
:
Fabs
32
)
=
>
(
SseOpcode
:
:
Psrld
SseOpcode
:
:
Andps
1
)
(
Opcode
:
:
Fabs
64
)
=
>
(
SseOpcode
:
:
Psrlq
SseOpcode
:
:
Andpd
1
)
(
Opcode
:
:
Fneg
32
)
=
>
(
SseOpcode
:
:
Pslld
SseOpcode
:
:
Xorps
31
)
(
Opcode
:
:
Fneg
64
)
=
>
(
SseOpcode
:
:
Psllq
SseOpcode
:
:
Xorpd
63
)
_
=
>
unreachable
!
(
"
unexpected
opcode
and
lane
size
:
{
:
?
}
{
}
bits
"
op
lane_bits
)
}
;
let
shift
=
Inst
:
:
xmm_rmi_reg
(
shift_opcode
RegMemImm
:
:
imm
(
shift_by
)
tmp
)
;
ctx
.
emit
(
shift
)
;
let
mask
=
Inst
:
:
xmm_rm_r
(
opcode
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
;
ctx
.
emit
(
mask
)
;
}
else
{
panic
!
(
"
unexpected
type
{
:
?
}
for
Fabs
"
output_ty
)
;
}
}
}
Opcode
:
:
Fcopysign
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
ty
=
ty
.
unwrap
(
)
;
let
tmp_xmm1
=
ctx
.
alloc_tmp
(
types
:
:
F32
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp_xmm2
=
ctx
.
alloc_tmp
(
types
:
:
F32
)
.
only_reg
(
)
.
unwrap
(
)
;
let
(
sign_bit_cst
mov_op
and_not_op
and_op
or_op
)
=
match
ty
{
types
:
:
F32
=
>
(
0x8000_0000
SseOpcode
:
:
Movaps
SseOpcode
:
:
Andnps
SseOpcode
:
:
Andps
SseOpcode
:
:
Orps
)
types
:
:
F64
=
>
(
0x8000_0000_0000_0000
SseOpcode
:
:
Movapd
SseOpcode
:
:
Andnpd
SseOpcode
:
:
Andpd
SseOpcode
:
:
Orpd
)
_
=
>
{
panic
!
(
"
unexpected
type
{
:
?
}
for
copysign
"
ty
)
;
}
}
;
for
inst
in
Inst
:
:
gen_constant
(
ValueRegs
:
:
one
(
tmp_xmm1
)
sign_bit_cst
ty
|
ty
|
{
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
}
)
{
ctx
.
emit
(
inst
)
;
}
ctx
.
emit
(
Inst
:
:
xmm_mov
(
mov_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
and_not_op
RegMem
:
:
reg
(
lhs
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
mov_op
RegMem
:
:
reg
(
rhs
)
tmp_xmm2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
and_op
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
tmp_xmm2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
or_op
RegMem
:
:
reg
(
tmp_xmm2
.
to_reg
(
)
)
dst
)
)
;
}
Opcode
:
:
Ceil
|
Opcode
:
:
Floor
|
Opcode
:
:
Nearest
|
Opcode
:
:
Trunc
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
if
isa_flags
.
use_sse41
(
)
{
let
mode
=
match
op
{
Opcode
:
:
Ceil
=
>
RoundImm
:
:
RoundUp
Opcode
:
:
Floor
=
>
RoundImm
:
:
RoundDown
Opcode
:
:
Nearest
=
>
RoundImm
:
:
RoundNearest
Opcode
:
:
Trunc
=
>
RoundImm
:
:
RoundZero
_
=
>
panic
!
(
"
unexpected
opcode
{
:
?
}
in
Ceil
/
Floor
/
Nearest
/
Trunc
"
op
)
}
;
let
op
=
match
ty
{
types
:
:
F32
=
>
SseOpcode
:
:
Roundss
types
:
:
F64
=
>
SseOpcode
:
:
Roundsd
types
:
:
F32X4
=
>
SseOpcode
:
:
Roundps
types
:
:
F64X2
=
>
SseOpcode
:
:
Roundpd
_
=
>
panic
!
(
"
unexpected
type
{
:
?
}
in
Ceil
/
Floor
/
Nearest
/
Trunc
"
ty
)
}
;
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
op
src
dst
mode
.
encode
(
)
OperandSize
:
:
Size32
)
)
;
}
else
{
let
libcall
=
match
(
op
ty
)
{
(
Opcode
:
:
Ceil
types
:
:
F32
)
=
>
LibCall
:
:
CeilF32
(
Opcode
:
:
Ceil
types
:
:
F64
)
=
>
LibCall
:
:
CeilF64
(
Opcode
:
:
Floor
types
:
:
F32
)
=
>
LibCall
:
:
FloorF32
(
Opcode
:
:
Floor
types
:
:
F64
)
=
>
LibCall
:
:
FloorF64
(
Opcode
:
:
Nearest
types
:
:
F32
)
=
>
LibCall
:
:
NearestF32
(
Opcode
:
:
Nearest
types
:
:
F64
)
=
>
LibCall
:
:
NearestF64
(
Opcode
:
:
Trunc
types
:
:
F32
)
=
>
LibCall
:
:
TruncF32
(
Opcode
:
:
Trunc
types
:
:
F64
)
=
>
LibCall
:
:
TruncF64
_
=
>
panic
!
(
"
unexpected
type
/
opcode
{
:
?
}
/
{
:
?
}
in
Ceil
/
Floor
/
Nearest
/
Trunc
"
ty
op
)
}
;
emit_vm_call
(
ctx
flags
triple
libcall
insn
inputs
outputs
)
?
;
}
}
Opcode
:
:
Load
|
Opcode
:
:
Uload8
|
Opcode
:
:
Sload8
|
Opcode
:
:
Uload16
|
Opcode
:
:
Sload16
|
Opcode
:
:
Uload32
|
Opcode
:
:
Sload32
|
Opcode
:
:
LoadComplex
|
Opcode
:
:
Uload8Complex
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Uload16Complex
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Uload32Complex
|
Opcode
:
:
Sload32Complex
|
Opcode
:
:
Sload8x8
|
Opcode
:
:
Uload8x8
|
Opcode
:
:
Sload16x4
|
Opcode
:
:
Uload16x4
|
Opcode
:
:
Sload32x2
|
Opcode
:
:
Uload32x2
=
>
{
let
offset
=
ctx
.
data
(
insn
)
.
load_store_offset
(
)
.
unwrap
(
)
;
let
elem_ty
=
match
op
{
Opcode
:
:
Sload8
|
Opcode
:
:
Uload8
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Uload8Complex
=
>
{
types
:
:
I8
}
Opcode
:
:
Sload16
|
Opcode
:
:
Uload16
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Uload16Complex
=
>
types
:
:
I16
Opcode
:
:
Sload32
|
Opcode
:
:
Uload32
|
Opcode
:
:
Sload32Complex
|
Opcode
:
:
Uload32Complex
=
>
types
:
:
I32
Opcode
:
:
Sload8x8
|
Opcode
:
:
Uload8x8
|
Opcode
:
:
Sload8x8Complex
|
Opcode
:
:
Uload8x8Complex
=
>
types
:
:
I8X8
Opcode
:
:
Sload16x4
|
Opcode
:
:
Uload16x4
|
Opcode
:
:
Sload16x4Complex
|
Opcode
:
:
Uload16x4Complex
=
>
types
:
:
I16X4
Opcode
:
:
Sload32x2
|
Opcode
:
:
Uload32x2
|
Opcode
:
:
Sload32x2Complex
|
Opcode
:
:
Uload32x2Complex
=
>
types
:
:
I32X2
Opcode
:
:
Load
|
Opcode
:
:
LoadComplex
=
>
ctx
.
output_ty
(
insn
0
)
_
=
>
unimplemented
!
(
)
}
;
let
ext_mode
=
ExtMode
:
:
new
(
elem_ty
.
bits
(
)
64
)
;
let
sign_extend
=
match
op
{
Opcode
:
:
Sload8
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Sload16
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Sload32
|
Opcode
:
:
Sload32Complex
|
Opcode
:
:
Sload8x8
|
Opcode
:
:
Sload8x8Complex
|
Opcode
:
:
Sload16x4
|
Opcode
:
:
Sload16x4Complex
|
Opcode
:
:
Sload32x2
|
Opcode
:
:
Sload32x2Complex
=
>
true
_
=
>
false
}
;
let
amode
=
match
op
{
Opcode
:
:
Load
|
Opcode
:
:
Uload8
|
Opcode
:
:
Sload8
|
Opcode
:
:
Uload16
|
Opcode
:
:
Sload16
|
Opcode
:
:
Uload32
|
Opcode
:
:
Sload32
|
Opcode
:
:
Sload8x8
|
Opcode
:
:
Uload8x8
|
Opcode
:
:
Sload16x4
|
Opcode
:
:
Uload16x4
|
Opcode
:
:
Sload32x2
|
Opcode
:
:
Uload32x2
=
>
{
assert_eq
!
(
inputs
.
len
(
)
1
"
only
one
input
for
load
operands
"
)
;
lower_to_amode
(
ctx
inputs
[
0
]
offset
)
}
Opcode
:
:
LoadComplex
|
Opcode
:
:
Uload8Complex
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Uload16Complex
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Uload32Complex
|
Opcode
:
:
Sload32Complex
|
Opcode
:
:
Sload8x8Complex
|
Opcode
:
:
Uload8x8Complex
|
Opcode
:
:
Sload16x4Complex
|
Opcode
:
:
Uload16x4Complex
|
Opcode
:
:
Sload32x2Complex
|
Opcode
:
:
Uload32x2Complex
=
>
{
assert_eq
!
(
inputs
.
len
(
)
2
"
can
'
t
handle
more
than
two
inputs
in
complex
load
"
)
;
let
base
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
index
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
shift
=
0
;
let
flags
=
ctx
.
memflags
(
insn
)
.
expect
(
"
load
should
have
memflags
"
)
;
Amode
:
:
imm_reg_reg_shift
(
offset
as
u32
base
index
shift
)
.
with_flags
(
flags
)
}
_
=
>
unreachable
!
(
)
}
;
if
elem_ty
=
=
types
:
:
I128
{
let
dsts
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
mov64_m_r
(
amode
.
clone
(
)
dsts
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_m_r
(
amode
.
offset
(
8
)
dsts
.
regs
(
)
[
1
]
)
)
;
}
else
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
is_xmm
=
elem_ty
.
is_float
(
)
|
|
elem_ty
.
is_vector
(
)
;
match
(
sign_extend
is_xmm
)
{
(
true
false
)
=
>
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
.
unwrap
(
)
RegMem
:
:
mem
(
amode
)
dst
)
)
;
}
(
false
false
)
=
>
{
if
elem_ty
.
bytes
(
)
=
=
8
{
ctx
.
emit
(
Inst
:
:
mov64_m_r
(
amode
dst
)
)
}
else
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
.
unwrap
(
)
RegMem
:
:
mem
(
amode
)
dst
)
)
}
}
(
_
true
)
=
>
{
ctx
.
emit
(
match
elem_ty
{
types
:
:
F32
=
>
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Movss
RegMem
:
:
mem
(
amode
)
dst
)
types
:
:
F64
=
>
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Movsd
RegMem
:
:
mem
(
amode
)
dst
)
types
:
:
I8X8
=
>
{
if
sign_extend
=
=
true
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxbw
RegMem
:
:
mem
(
amode
)
dst
)
}
else
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxbw
RegMem
:
:
mem
(
amode
)
dst
)
}
}
types
:
:
I16X4
=
>
{
if
sign_extend
=
=
true
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxwd
RegMem
:
:
mem
(
amode
)
dst
)
}
else
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxwd
RegMem
:
:
mem
(
amode
)
dst
)
}
}
types
:
:
I32X2
=
>
{
if
sign_extend
=
=
true
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovsxdq
RegMem
:
:
mem
(
amode
)
dst
)
}
else
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Pmovzxdq
RegMem
:
:
mem
(
amode
)
dst
)
}
}
_
if
elem_ty
.
is_vector
(
)
&
&
elem_ty
.
bits
(
)
=
=
128
=
>
{
Inst
:
:
xmm_mov
(
SseOpcode
:
:
Movups
RegMem
:
:
mem
(
amode
)
dst
)
}
_
=
>
unreachable
!
(
"
unexpected
type
for
load
:
{
:
?
}
-
{
:
?
}
"
elem_ty
elem_ty
.
bits
(
)
)
}
)
;
}
}
}
}
Opcode
:
:
Store
|
Opcode
:
:
Istore8
|
Opcode
:
:
Istore16
|
Opcode
:
:
Istore32
|
Opcode
:
:
StoreComplex
|
Opcode
:
:
Istore8Complex
|
Opcode
:
:
Istore16Complex
|
Opcode
:
:
Istore32Complex
=
>
{
let
offset
=
ctx
.
data
(
insn
)
.
load_store_offset
(
)
.
unwrap
(
)
;
let
elem_ty
=
match
op
{
Opcode
:
:
Istore8
|
Opcode
:
:
Istore8Complex
=
>
types
:
:
I8
Opcode
:
:
Istore16
|
Opcode
:
:
Istore16Complex
=
>
types
:
:
I16
Opcode
:
:
Istore32
|
Opcode
:
:
Istore32Complex
=
>
types
:
:
I32
Opcode
:
:
Store
|
Opcode
:
:
StoreComplex
=
>
ctx
.
input_ty
(
insn
0
)
_
=
>
unreachable
!
(
)
}
;
let
addr
=
match
op
{
Opcode
:
:
Store
|
Opcode
:
:
Istore8
|
Opcode
:
:
Istore16
|
Opcode
:
:
Istore32
=
>
{
assert_eq
!
(
inputs
.
len
(
)
2
"
only
one
input
for
store
memory
operands
"
)
;
lower_to_amode
(
ctx
inputs
[
1
]
offset
)
}
Opcode
:
:
StoreComplex
|
Opcode
:
:
Istore8Complex
|
Opcode
:
:
Istore16Complex
|
Opcode
:
:
Istore32Complex
=
>
{
assert_eq
!
(
inputs
.
len
(
)
3
"
can
'
t
handle
more
than
two
inputs
in
complex
store
"
)
;
let
base
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
index
=
put_input_in_reg
(
ctx
inputs
[
2
]
)
;
let
shift
=
0
;
let
flags
=
ctx
.
memflags
(
insn
)
.
expect
(
"
store
should
have
memflags
"
)
;
Amode
:
:
imm_reg_reg_shift
(
offset
as
u32
base
index
shift
)
.
with_flags
(
flags
)
}
_
=
>
unreachable
!
(
)
}
;
if
elem_ty
=
=
types
:
:
I128
{
let
srcs
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
mov_r_m
(
OperandSize
:
:
Size64
srcs
.
regs
(
)
[
0
]
addr
.
clone
(
)
)
)
;
ctx
.
emit
(
Inst
:
:
mov_r_m
(
OperandSize
:
:
Size64
srcs
.
regs
(
)
[
1
]
addr
.
offset
(
8
)
)
)
;
}
else
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
match
elem_ty
{
types
:
:
F32
=
>
Inst
:
:
xmm_mov_r_m
(
SseOpcode
:
:
Movss
src
addr
)
types
:
:
F64
=
>
Inst
:
:
xmm_mov_r_m
(
SseOpcode
:
:
Movsd
src
addr
)
_
if
elem_ty
.
is_vector
(
)
&
&
elem_ty
.
bits
(
)
=
=
128
=
>
{
Inst
:
:
xmm_mov_r_m
(
SseOpcode
:
:
Movups
src
addr
)
}
_
=
>
Inst
:
:
mov_r_m
(
OperandSize
:
:
from_ty
(
elem_ty
)
src
addr
)
}
)
;
}
}
Opcode
:
:
AtomicRmw
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
mut
addr
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
mut
arg2
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
ty_access
=
ty
.
unwrap
(
)
;
assert
!
(
is_valid_atomic_transaction_ty
(
ty_access
)
)
;
addr
=
ctx
.
ensure_in_vreg
(
addr
types
:
:
I64
)
;
arg2
=
ctx
.
ensure_in_vreg
(
arg2
types
:
:
I64
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
r9
(
)
)
addr
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
r10
(
)
)
arg2
types
:
:
I64
)
)
;
let
op
=
inst_common
:
:
AtomicRmwOp
:
:
from
(
ctx
.
data
(
insn
)
.
atomic_rmw_op
(
)
.
unwrap
(
)
)
;
ctx
.
emit
(
Inst
:
:
AtomicRmwSeq
{
ty
:
ty_access
op
}
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
types
:
:
I64
)
)
;
}
Opcode
:
:
AtomicCas
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
addr
=
lower_to_amode
(
ctx
inputs
[
0
]
0
)
;
let
expected
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
replacement
=
put_input_in_reg
(
ctx
inputs
[
2
]
)
;
let
ty_access
=
ty
.
unwrap
(
)
;
assert
!
(
is_valid_atomic_transaction_ty
(
ty_access
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
expected
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
LockCmpxchg
{
ty
:
ty_access
src
:
replacement
dst
:
addr
.
into
(
)
}
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
types
:
:
I64
)
)
;
}
Opcode
:
:
AtomicLoad
=
>
{
let
data
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
addr
=
lower_to_amode
(
ctx
inputs
[
0
]
0
)
;
let
ty_access
=
ty
.
unwrap
(
)
;
assert
!
(
is_valid_atomic_transaction_ty
(
ty_access
)
)
;
let
rm
=
RegMem
:
:
mem
(
addr
)
;
if
ty_access
=
=
types
:
:
I64
{
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
rm
data
)
)
;
}
else
{
let
ext_mode
=
ExtMode
:
:
new
(
ty_access
.
bits
(
)
64
)
.
expect
(
&
format
!
(
"
invalid
extension
during
AtomicLoad
:
{
}
-
>
{
}
"
ty_access
.
bits
(
)
64
)
)
;
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
rm
data
)
)
;
}
}
Opcode
:
:
AtomicStore
=
>
{
let
data
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
addr
=
lower_to_amode
(
ctx
inputs
[
1
]
0
)
;
let
ty_access
=
ctx
.
input_ty
(
insn
0
)
;
assert
!
(
is_valid_atomic_transaction_ty
(
ty_access
)
)
;
ctx
.
emit
(
Inst
:
:
mov_r_m
(
OperandSize
:
:
from_ty
(
ty_access
)
data
addr
)
)
;
ctx
.
emit
(
Inst
:
:
Fence
{
kind
:
FenceKind
:
:
MFence
}
)
;
}
Opcode
:
:
Fence
=
>
{
ctx
.
emit
(
Inst
:
:
Fence
{
kind
:
FenceKind
:
:
MFence
}
)
;
}
Opcode
:
:
FuncAddr
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
(
extname
_
)
=
ctx
.
call_target
(
insn
)
.
unwrap
(
)
;
let
extname
=
extname
.
clone
(
)
;
ctx
.
emit
(
Inst
:
:
LoadExtName
{
dst
name
:
Box
:
:
new
(
extname
)
offset
:
0
}
)
;
}
Opcode
:
:
SymbolValue
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
(
extname
_
offset
)
=
ctx
.
symbol_value
(
insn
)
.
unwrap
(
)
;
let
extname
=
extname
.
clone
(
)
;
ctx
.
emit
(
Inst
:
:
LoadExtName
{
dst
name
:
Box
:
:
new
(
extname
)
offset
}
)
;
}
Opcode
:
:
StackAddr
=
>
{
let
(
stack_slot
offset
)
=
match
*
ctx
.
data
(
insn
)
{
InstructionData
:
:
StackLoad
{
opcode
:
Opcode
:
:
StackAddr
stack_slot
offset
}
=
>
(
stack_slot
offset
)
_
=
>
unreachable
!
(
)
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
offset
:
i32
=
offset
.
into
(
)
;
let
inst
=
ctx
.
abi
(
)
.
stackslot_addr
(
stack_slot
u32
:
:
try_from
(
offset
)
.
unwrap
(
)
dst
)
;
ctx
.
emit
(
inst
)
;
}
Opcode
:
:
Select
=
>
{
let
flag_input
=
inputs
[
0
]
;
if
let
Some
(
fcmp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
Fcmp
)
{
let
cond_code
=
ctx
.
data
(
fcmp
)
.
fp_cond_code
(
)
.
unwrap
(
)
;
let
(
lhs_input
rhs_input
)
=
match
cond_code
{
FloatCC
:
:
Equal
=
>
(
inputs
[
2
]
inputs
[
1
]
)
_
=
>
(
inputs
[
1
]
inputs
[
2
]
)
}
;
let
ty
=
ctx
.
output_ty
(
insn
0
)
;
let
rhs
=
put_input_in_regs
(
ctx
rhs_input
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
let
lhs
=
put_input_in_regs
(
ctx
lhs_input
)
;
let
fcmp_results
=
emit_fcmp
(
ctx
fcmp
cond_code
FcmpSpec
:
:
InvertEqual
)
;
if
let
FcmpCondResult
:
:
InvertedEqualOrConditions
(
_
_
)
=
&
fcmp_results
{
assert_eq
!
(
cond_code
FloatCC
:
:
Equal
)
;
}
emit_moves
(
ctx
dst
rhs
ty
)
;
let
operand_size
=
if
ty
=
=
types
:
:
F64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
;
match
fcmp_results
{
FcmpCondResult
:
:
Condition
(
cc
)
=
>
{
if
is_int_or_ref_ty
(
ty
)
|
|
ty
=
=
types
:
:
I128
|
|
ty
=
=
types
:
:
B128
{
let
size
=
ty
.
bytes
(
)
as
u8
;
emit_cmoves
(
ctx
size
cc
lhs
dst
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
xmm_cmove
(
operand_size
cc
RegMem
:
:
reg
(
lhs
.
only_reg
(
)
.
unwrap
(
)
)
dst
.
only_reg
(
)
.
unwrap
(
)
)
)
;
}
}
FcmpCondResult
:
:
AndConditions
(
_
_
)
=
>
{
unreachable
!
(
"
can
'
t
AND
with
select
;
see
above
comment
about
inverting
equal
"
)
;
}
FcmpCondResult
:
:
InvertedEqualOrConditions
(
cc1
cc2
)
|
FcmpCondResult
:
:
OrConditions
(
cc1
cc2
)
=
>
{
if
is_int_or_ref_ty
(
ty
)
|
|
ty
=
=
types
:
:
I128
{
let
size
=
ty
.
bytes
(
)
as
u8
;
emit_cmoves
(
ctx
size
cc1
lhs
.
clone
(
)
dst
)
;
emit_cmoves
(
ctx
size
cc2
lhs
dst
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
xmm_cmove
(
operand_size
cc1
RegMem
:
:
reg
(
lhs
.
only_reg
(
)
.
unwrap
(
)
)
dst
.
only_reg
(
)
.
unwrap
(
)
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_cmove
(
operand_size
cc2
RegMem
:
:
reg
(
lhs
.
only_reg
(
)
.
unwrap
(
)
)
dst
.
only_reg
(
)
.
unwrap
(
)
)
)
;
}
}
}
}
else
{
let
ty
=
ty
.
unwrap
(
)
;
let
size
=
ty
.
bytes
(
)
as
u8
;
let
lhs
=
put_input_in_regs
(
ctx
inputs
[
1
]
)
;
let
rhs
=
put_input_in_regs
(
ctx
inputs
[
2
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
let
cc
=
if
let
Some
(
icmp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
Icmp
)
{
let
cond_code
=
ctx
.
data
(
icmp
)
.
cond_code
(
)
.
unwrap
(
)
;
let
cond_code
=
emit_cmp
(
ctx
icmp
cond_code
)
;
CC
:
:
from_intcc
(
cond_code
)
}
else
{
let
sel_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
size
=
OperandSize
:
:
from_ty
(
ctx
.
input_ty
(
insn
0
)
)
;
let
test
=
put_input_in_reg
(
ctx
flag_input
)
;
let
test_input
=
if
sel_ty
=
=
types
:
:
B1
{
RegMemImm
:
:
imm
(
1
)
}
else
{
assert
!
(
!
is_bool_ty
(
sel_ty
)
)
;
RegMemImm
:
:
reg
(
test
)
}
;
ctx
.
emit
(
Inst
:
:
test_rmi_r
(
size
test_input
test
)
)
;
CC
:
:
NZ
}
;
emit_moves
(
ctx
dst
rhs
ty
)
;
if
is_int_or_ref_ty
(
ty
)
|
|
ty
=
=
types
:
:
I128
{
emit_cmoves
(
ctx
size
cc
lhs
dst
)
;
}
else
{
debug_assert
!
(
ty
=
=
types
:
:
F32
|
|
ty
=
=
types
:
:
F64
)
;
ctx
.
emit
(
Inst
:
:
xmm_cmove
(
if
ty
=
=
types
:
:
F64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
cc
RegMem
:
:
reg
(
lhs
.
only_reg
(
)
.
unwrap
(
)
)
dst
.
only_reg
(
)
.
unwrap
(
)
)
)
;
}
}
}
Opcode
:
:
Selectif
|
Opcode
:
:
SelectifSpectreGuard
=
>
{
let
lhs
=
put_input_in_regs
(
ctx
inputs
[
1
]
)
;
let
rhs
=
put_input_in_regs
(
ctx
inputs
[
2
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
let
ty
=
ctx
.
output_ty
(
insn
0
)
;
let
cmp_insn
=
ctx
.
get_input_as_source_or_const
(
inputs
[
0
]
.
insn
inputs
[
0
]
.
input
)
.
inst
.
unwrap
(
)
.
0
;
debug_assert_eq
!
(
ctx
.
data
(
cmp_insn
)
.
opcode
(
)
Opcode
:
:
Ifcmp
)
;
let
cond_code
=
ctx
.
data
(
insn
)
.
cond_code
(
)
.
unwrap
(
)
;
let
cond_code
=
emit_cmp
(
ctx
cmp_insn
cond_code
)
;
let
cc
=
CC
:
:
from_intcc
(
cond_code
)
;
if
is_int_or_ref_ty
(
ty
)
|
|
ty
=
=
types
:
:
I128
{
let
size
=
ty
.
bytes
(
)
as
u8
;
emit_moves
(
ctx
dst
rhs
ty
)
;
emit_cmoves
(
ctx
size
cc
lhs
dst
)
;
}
else
{
debug_assert
!
(
ty
=
=
types
:
:
F32
|
|
ty
=
=
types
:
:
F64
)
;
emit_moves
(
ctx
dst
rhs
ty
)
;
ctx
.
emit
(
Inst
:
:
xmm_cmove
(
if
ty
=
=
types
:
:
F64
{
OperandSize
:
:
Size64
}
else
{
OperandSize
:
:
Size32
}
cc
RegMem
:
:
reg
(
lhs
.
only_reg
(
)
.
unwrap
(
)
)
dst
.
only_reg
(
)
.
unwrap
(
)
)
)
;
}
}
Opcode
:
:
Udiv
|
Opcode
:
:
Urem
|
Opcode
:
:
Sdiv
|
Opcode
:
:
Srem
=
>
{
let
kind
=
match
op
{
Opcode
:
:
Udiv
=
>
DivOrRemKind
:
:
UnsignedDiv
Opcode
:
:
Sdiv
=
>
DivOrRemKind
:
:
SignedDiv
Opcode
:
:
Urem
=
>
DivOrRemKind
:
:
UnsignedRem
Opcode
:
:
Srem
=
>
DivOrRemKind
:
:
SignedRem
_
=
>
unreachable
!
(
)
}
;
let
is_div
=
kind
.
is_div
(
)
;
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
size
=
OperandSize
:
:
from_ty
(
input_ty
)
;
let
dividend
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
dividend
input_ty
)
)
;
if
flags
.
avoid_div_traps
(
)
|
|
op
=
=
Opcode
:
:
Srem
{
let
divisor
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
divisor_copy
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
divisor_copy
divisor
types
:
:
I64
)
)
;
let
tmp
=
if
op
=
=
Opcode
:
:
Sdiv
&
&
size
=
=
OperandSize
:
:
Size64
{
Some
(
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
)
}
else
{
None
}
;
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size32
0
Writable
:
:
from_reg
(
regs
:
:
rdx
(
)
)
)
)
;
ctx
.
emit
(
Inst
:
:
checked_div_or_rem_seq
(
kind
size
divisor_copy
tmp
)
)
;
}
else
{
let
divisor
=
RegMem
:
:
reg
(
put_input_in_reg
(
ctx
inputs
[
1
]
)
)
;
if
kind
.
is_signed
(
)
{
ctx
.
emit
(
Inst
:
:
sign_extend_data
(
size
)
)
;
}
else
if
input_ty
=
=
types
:
:
I8
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ExtMode
:
:
BL
RegMem
:
:
reg
(
regs
:
:
rax
(
)
)
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
imm
(
OperandSize
:
:
Size64
0
Writable
:
:
from_reg
(
regs
:
:
rdx
(
)
)
)
)
;
}
ctx
.
emit
(
Inst
:
:
div
(
size
kind
.
is_signed
(
)
divisor
)
)
;
}
if
is_div
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
input_ty
)
)
;
}
else
{
if
size
=
=
OperandSize
:
:
Size8
{
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
8
)
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
input_ty
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rdx
(
)
input_ty
)
)
;
}
}
}
Opcode
:
:
Umulhi
|
Opcode
:
:
Smulhi
=
>
{
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
lhs
input_ty
)
)
;
let
signed
=
op
=
=
Opcode
:
:
Smulhi
;
ctx
.
emit
(
Inst
:
:
mul_hi
(
OperandSize
:
:
from_ty
(
input_ty
)
signed
rhs
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rdx
(
)
input_ty
)
)
;
}
Opcode
:
:
GetPinnedReg
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
pinned_reg
(
)
types
:
:
I64
)
)
;
}
Opcode
:
:
SetPinnedReg
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
pinned_reg
(
)
)
src
types
:
:
I64
)
)
;
}
Opcode
:
:
Vconst
=
>
{
let
used_constant
=
if
let
&
InstructionData
:
:
UnaryConst
{
constant_handle
.
.
}
=
ctx
.
data
(
insn
)
{
ctx
.
use_constant
(
VCodeConstantData
:
:
Pool
(
constant_handle
ctx
.
get_constant_data
(
constant_handle
)
.
clone
(
)
)
)
}
else
{
unreachable
!
(
"
vconst
should
always
have
unary_const
format
"
)
}
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_load_const
(
used_constant
dst
ty
)
)
;
}
Opcode
:
:
RawBitcast
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
ty
=
ty
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
}
Opcode
:
:
Shuffle
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
lhs_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
lhs
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
mask
=
match
ctx
.
get_immediate
(
insn
)
{
Some
(
DataValue
:
:
V128
(
bytes
)
)
=
>
bytes
.
to_vec
(
)
_
=
>
unreachable
!
(
"
shuffle
should
always
have
a
16
-
byte
immediate
"
)
}
;
let
zero_unknown_lane_index
=
|
b
:
u8
|
if
b
>
15
{
0b10000000
}
else
{
b
}
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
ty
)
)
;
if
rhs
=
=
lhs
{
let
constructed_mask
=
mask
.
iter
(
)
.
map
(
|
&
b
|
if
b
>
15
{
b
.
wrapping_sub
(
16
)
}
else
{
b
}
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
constant
=
ctx
.
use_constant
(
VCodeConstantData
:
:
Generated
(
constructed_mask
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
types
:
:
I8X16
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_load_const
(
constant
tmp
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pshufb
RegMem
:
:
from
(
tmp
)
dst
)
)
;
}
else
{
let
tmp0
=
ctx
.
alloc_tmp
(
lhs_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp0
lhs
lhs_ty
)
)
;
let
constructed_mask
=
mask
.
iter
(
)
.
cloned
(
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
constant
=
ctx
.
use_constant
(
VCodeConstantData
:
:
Generated
(
constructed_mask
)
)
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I8X16
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_load_const
(
constant
tmp1
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pshufb
RegMem
:
:
from
(
tmp1
)
tmp0
)
)
;
let
constructed_mask
=
mask
.
iter
(
)
.
map
(
|
b
|
b
.
wrapping_sub
(
16
)
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
constant
=
ctx
.
use_constant
(
VCodeConstantData
:
:
Generated
(
constructed_mask
)
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I8X16
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_load_const
(
constant
tmp2
ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pshufb
RegMem
:
:
from
(
tmp2
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Orps
RegMem
:
:
from
(
tmp0
)
dst
)
)
;
}
}
Opcode
:
:
Swizzle
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
swizzle_mask
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
src
ty
)
)
;
let
zero_mask
=
ctx
.
alloc_tmp
(
types
:
:
I8X16
)
.
only_reg
(
)
.
unwrap
(
)
;
static
ZERO_MASK_VALUE
:
[
u8
;
16
]
=
[
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
0x70
]
;
let
constant
=
ctx
.
use_constant
(
VCodeConstantData
:
:
WellKnown
(
&
ZERO_MASK_VALUE
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_load_const
(
constant
zero_mask
ty
)
)
;
let
swizzle_mask
=
Writable
:
:
from_reg
(
swizzle_mask
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Paddusb
RegMem
:
:
from
(
zero_mask
)
swizzle_mask
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pshufb
RegMem
:
:
from
(
swizzle_mask
)
dst
)
)
;
}
Opcode
:
:
Insertlane
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
in_vec
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
1
)
;
debug_assert
!
(
!
src_ty
.
is_vector
(
)
)
;
let
src
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
lane
=
if
let
InstructionData
:
:
TernaryImm8
{
imm
.
.
}
=
ctx
.
data
(
insn
)
{
*
imm
}
else
{
unreachable
!
(
)
;
}
;
debug_assert
!
(
lane
<
ty
.
lane_count
(
)
as
u8
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
in_vec
ty
)
)
;
emit_insert_lane
(
ctx
src
dst
lane
ty
.
lane_type
(
)
)
;
}
Opcode
:
:
Extractlane
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
assert_eq
!
(
src_ty
.
bits
(
)
128
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
lane
=
if
let
InstructionData
:
:
BinaryImm8
{
imm
.
.
}
=
ctx
.
data
(
insn
)
{
*
imm
}
else
{
unreachable
!
(
)
;
}
;
debug_assert
!
(
lane
<
src_ty
.
lane_count
(
)
as
u8
)
;
emit_extract_lane
(
ctx
src
dst
lane
ty
)
;
}
Opcode
:
:
ScalarToVector
=
>
{
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
dst_ty
=
ty
.
unwrap
(
)
;
assert
!
(
src_ty
=
=
dst_ty
.
lane_type
(
)
&
&
dst_ty
.
bits
(
)
=
=
128
)
;
match
src
{
RegMem
:
:
Reg
{
reg
}
=
>
{
if
src_ty
.
is_float
(
)
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
reg
dst_ty
)
)
;
}
else
{
let
src_size
=
match
src_ty
.
bits
(
)
{
32
=
>
OperandSize
:
:
Size32
64
=
>
OperandSize
:
:
Size64
_
=
>
unimplemented
!
(
"
invalid
source
size
for
type
:
{
}
"
src_ty
)
}
;
ctx
.
emit
(
Inst
:
:
gpr_to_xmm
(
SseOpcode
:
:
Movd
src
src_size
dst
)
)
;
}
}
RegMem
:
:
Mem
{
.
.
}
=
>
{
let
opcode
=
match
src_ty
.
bits
(
)
{
32
=
>
SseOpcode
:
:
Movss
64
=
>
SseOpcode
:
:
Movsd
_
=
>
unimplemented
!
(
"
unable
to
move
scalar
to
vector
for
type
:
{
}
"
src_ty
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_mov
(
opcode
src
dst
)
)
;
}
}
}
Opcode
:
:
Splat
=
>
{
let
ty
=
ty
.
unwrap
(
)
;
assert_eq
!
(
ty
.
bits
(
)
128
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
assert
!
(
src_ty
.
bits
(
)
<
128
)
;
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_uninit_value
(
dst
)
)
;
match
ty
.
lane_bits
(
)
{
8
=
>
{
emit_insert_lane
(
ctx
src
dst
0
ty
.
lane_type
(
)
)
;
let
tmp
=
ctx
.
alloc_tmp
(
ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pshufb
RegMem
:
:
from
(
tmp
)
dst
)
)
}
16
=
>
{
emit_insert_lane
(
ctx
src
.
clone
(
)
dst
0
ty
.
lane_type
(
)
)
;
emit_insert_lane
(
ctx
src
dst
1
ty
.
lane_type
(
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Pshufd
RegMem
:
:
from
(
dst
)
dst
0
OperandSize
:
:
Size32
)
)
}
32
=
>
{
emit_insert_lane
(
ctx
src
dst
0
ty
.
lane_type
(
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r_imm
(
SseOpcode
:
:
Pshufd
RegMem
:
:
from
(
dst
)
dst
0
OperandSize
:
:
Size32
)
)
}
64
=
>
{
emit_insert_lane
(
ctx
src
.
clone
(
)
dst
0
ty
.
lane_type
(
)
)
;
emit_insert_lane
(
ctx
src
dst
1
ty
.
lane_type
(
)
)
;
}
_
=
>
panic
!
(
"
Invalid
type
to
splat
:
{
}
"
ty
)
}
}
Opcode
:
:
VanyTrue
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
assert_eq
!
(
src_ty
.
bits
(
)
128
)
;
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
xmm_cmp_rm_r
(
SseOpcode
:
:
Ptest
RegMem
:
:
reg
(
src
)
src
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
NZ
dst
)
)
;
}
Opcode
:
:
VallTrue
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
assert_eq
!
(
src_ty
.
bits
(
)
128
)
;
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
eq
=
|
ty
:
Type
|
match
ty
.
lane_bits
(
)
{
8
=
>
SseOpcode
:
:
Pcmpeqb
16
=
>
SseOpcode
:
:
Pcmpeqw
32
=
>
SseOpcode
:
:
Pcmpeqd
64
=
>
SseOpcode
:
:
Pcmpeqq
_
=
>
panic
!
(
"
Unable
to
find
an
instruction
for
{
}
for
type
:
{
}
"
op
ty
)
}
;
let
tmp
=
ctx
.
alloc_tmp
(
src_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Pxor
RegMem
:
:
from
(
tmp
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
eq
(
src_ty
)
src
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_cmp_rm_r
(
SseOpcode
:
:
Ptest
RegMem
:
:
from
(
tmp
)
tmp
.
to_reg
(
)
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
CC
:
:
Z
dst
)
)
;
}
Opcode
:
:
VhighBits
=
>
{
let
src
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
debug_assert
!
(
src_ty
.
is_vector
(
)
&
&
src_ty
.
bits
(
)
=
=
128
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
debug_assert
!
(
dst
.
to_reg
(
)
.
get_class
(
)
=
=
RegClass
:
:
I64
)
;
let
size
=
OperandSize
:
:
Size32
;
match
src_ty
{
types
:
:
I8X16
|
types
:
:
B8X16
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_to_gpr
(
SseOpcode
:
:
Pmovmskb
src
dst
size
)
)
}
types
:
:
I32X4
|
types
:
:
B32X4
|
types
:
:
F32X4
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_to_gpr
(
SseOpcode
:
:
Movmskps
src
dst
size
)
)
}
types
:
:
I64X2
|
types
:
:
B64X2
|
types
:
:
F64X2
=
>
{
ctx
.
emit
(
Inst
:
:
xmm_to_gpr
(
SseOpcode
:
:
Movmskpd
src
dst
size
)
)
}
types
:
:
I16X8
|
types
:
:
B16X8
=
>
{
let
tmp
=
ctx
.
alloc_tmp
(
src_ty
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
tmp
src
src_ty
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Packsswb
RegMem
:
:
reg
(
src
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_to_gpr
(
SseOpcode
:
:
Pmovmskb
tmp
.
to_reg
(
)
dst
size
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
OperandSize
:
:
Size64
ShiftKind
:
:
ShiftRightLogical
Some
(
8
)
dst
)
)
;
}
_
=
>
unimplemented
!
(
"
unknown
input
type
{
}
for
{
}
"
src_ty
op
)
}
}
Opcode
:
:
Iconcat
=
>
{
let
ty
=
ctx
.
output_ty
(
insn
0
)
;
assert_eq
!
(
ty
types
:
:
I128
"
Iconcat
not
expected
to
be
used
for
non
-
128
-
bit
type
"
)
;
assert_eq
!
(
ctx
.
input_ty
(
insn
0
)
types
:
:
I64
)
;
assert_eq
!
(
ctx
.
input_ty
(
insn
1
)
types
:
:
I64
)
;
let
lo
=
put_input_in_reg
(
ctx
inputs
[
0
]
)
;
let
hi
=
put_input_in_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
0
]
lo
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
.
regs
(
)
[
1
]
hi
types
:
:
I64
)
)
;
}
Opcode
:
:
Isplit
=
>
{
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
assert_eq
!
(
ty
types
:
:
I128
"
Iconcat
not
expected
to
be
used
for
non
-
128
-
bit
type
"
)
;
assert_eq
!
(
ctx
.
output_ty
(
insn
0
)
types
:
:
I64
)
;
assert_eq
!
(
ctx
.
output_ty
(
insn
1
)
types
:
:
I64
)
;
let
src
=
put_input_in_regs
(
ctx
inputs
[
0
]
)
;
let
dst_lo
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
dst_hi
=
get_output_reg
(
ctx
outputs
[
1
]
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst_lo
src
.
regs
(
)
[
0
]
types
:
:
I64
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst_hi
src
.
regs
(
)
[
1
]
types
:
:
I64
)
)
;
}
Opcode
:
:
TlsValue
=
>
match
flags
.
tls_model
(
)
{
TlsModel
:
:
ElfGd
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
(
name
_
_
)
=
ctx
.
symbol_value
(
insn
)
.
unwrap
(
)
;
let
symbol
=
name
.
clone
(
)
;
ctx
.
emit
(
Inst
:
:
ElfTlsGetAddr
{
symbol
}
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
types
:
:
I64
)
)
;
}
TlsModel
:
:
Macho
=
>
{
let
dst
=
get_output_reg
(
ctx
outputs
[
0
]
)
.
only_reg
(
)
.
unwrap
(
)
;
let
(
name
_
_
)
=
ctx
.
symbol_value
(
insn
)
.
unwrap
(
)
;
let
symbol
=
name
.
clone
(
)
;
ctx
.
emit
(
Inst
:
:
MachOTlsGetAddr
{
symbol
}
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
types
:
:
I64
)
)
;
}
_
=
>
{
todo
!
(
"
Unimplemented
TLS
model
in
x64
backend
:
{
:
?
}
"
flags
.
tls_model
(
)
)
;
}
}
Opcode
:
:
IaddImm
|
Opcode
:
:
ImulImm
|
Opcode
:
:
UdivImm
|
Opcode
:
:
SdivImm
|
Opcode
:
:
UremImm
|
Opcode
:
:
SremImm
|
Opcode
:
:
IrsubImm
|
Opcode
:
:
IaddCin
|
Opcode
:
:
IaddIfcin
|
Opcode
:
:
IaddCout
|
Opcode
:
:
IaddCarry
|
Opcode
:
:
IaddIfcarry
|
Opcode
:
:
IsubBin
|
Opcode
:
:
IsubIfbin
|
Opcode
:
:
IsubBout
|
Opcode
:
:
IsubIfbout
|
Opcode
:
:
IsubBorrow
|
Opcode
:
:
IsubIfborrow
|
Opcode
:
:
BandImm
|
Opcode
:
:
BorImm
|
Opcode
:
:
BxorImm
|
Opcode
:
:
RotlImm
|
Opcode
:
:
RotrImm
|
Opcode
:
:
IshlImm
|
Opcode
:
:
UshrImm
|
Opcode
:
:
SshrImm
=
>
{
panic
!
(
"
ALU
+
imm
and
ALU
+
carry
ops
should
not
appear
here
!
"
)
;
}
_
=
>
unimplemented
!
(
"
unimplemented
lowering
for
opcode
{
:
?
}
"
op
)
}
Ok
(
(
)
)
}
impl
LowerBackend
for
X64Backend
{
type
MInst
=
Inst
;
fn
lower
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
&
self
ctx
:
&
mut
C
ir_inst
:
IRInst
)
-
>
CodegenResult
<
(
)
>
{
lower_insn_to_regs
(
ctx
ir_inst
&
self
.
flags
&
self
.
x64_flags
&
self
.
triple
)
}
fn
lower_branch_group
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
&
self
ctx
:
&
mut
C
branches
:
&
[
IRInst
]
targets
:
&
[
MachLabel
]
)
-
>
CodegenResult
<
(
)
>
{
assert
!
(
branches
.
len
(
)
<
=
2
)
;
if
branches
.
len
(
)
=
=
2
{
let
op0
=
ctx
.
data
(
branches
[
0
]
)
.
opcode
(
)
;
let
op1
=
ctx
.
data
(
branches
[
1
]
)
.
opcode
(
)
;
trace
!
(
"
lowering
two
-
branch
group
:
opcodes
are
{
:
?
}
and
{
:
?
}
"
op0
op1
)
;
assert
!
(
op1
=
=
Opcode
:
:
Jump
|
|
op1
=
=
Opcode
:
:
Fallthrough
)
;
let
taken
=
targets
[
0
]
;
let
not_taken
=
targets
[
1
]
;
match
op0
{
Opcode
:
:
Brz
|
Opcode
:
:
Brnz
=
>
{
let
flag_input
=
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
;
let
src_ty
=
ctx
.
input_ty
(
branches
[
0
]
0
)
;
if
let
Some
(
icmp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
Icmp
)
{
let
cond_code
=
ctx
.
data
(
icmp
)
.
cond_code
(
)
.
unwrap
(
)
;
let
cond_code
=
emit_cmp
(
ctx
icmp
cond_code
)
;
let
cond_code
=
if
op0
=
=
Opcode
:
:
Brz
{
cond_code
.
inverse
(
)
}
else
{
cond_code
}
;
let
cc
=
CC
:
:
from_intcc
(
cond_code
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
if
let
Some
(
fcmp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
Fcmp
)
{
let
cond_code
=
ctx
.
data
(
fcmp
)
.
fp_cond_code
(
)
.
unwrap
(
)
;
let
cond_code
=
if
op0
=
=
Opcode
:
:
Brz
{
cond_code
.
inverse
(
)
}
else
{
cond_code
}
;
match
emit_fcmp
(
ctx
fcmp
cond_code
FcmpSpec
:
:
Normal
)
{
FcmpCondResult
:
:
Condition
(
cc
)
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
FcmpCondResult
:
:
AndConditions
(
cc1
cc2
)
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_if
(
cc1
.
invert
(
)
not_taken
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc2
.
invert
(
)
not_taken
taken
)
)
;
}
FcmpCondResult
:
:
OrConditions
(
cc1
cc2
)
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_if
(
cc1
taken
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc2
taken
not_taken
)
)
;
}
FcmpCondResult
:
:
InvertedEqualOrConditions
(
_
_
)
=
>
unreachable
!
(
)
}
}
else
if
src_ty
=
=
types
:
:
I128
{
let
src
=
put_input_in_regs
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
)
;
let
(
half_cc
comb_op
)
=
match
op0
{
Opcode
:
:
Brz
=
>
(
CC
:
:
Z
AluRmiROpcode
:
:
And8
)
Opcode
:
:
Brnz
=
>
(
CC
:
:
NZ
AluRmiROpcode
:
:
Or8
)
_
=
>
unreachable
!
(
)
}
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
RegMemImm
:
:
imm
(
0
)
src
.
regs
(
)
[
0
]
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
half_cc
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size64
RegMemImm
:
:
imm
(
0
)
src
.
regs
(
)
[
1
]
)
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
half_cc
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
OperandSize
:
:
Size32
comb_op
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
CC
:
:
NZ
taken
not_taken
)
)
;
}
else
if
is_int_or_ref_ty
(
src_ty
)
|
|
is_bool_ty
(
src_ty
)
{
let
src
=
put_input_in_reg
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
)
;
let
cc
=
match
op0
{
Opcode
:
:
Brz
=
>
CC
:
:
Z
Opcode
:
:
Brnz
=
>
CC
:
:
NZ
_
=
>
unreachable
!
(
)
}
;
let
test_input
=
if
src_ty
=
=
types
:
:
B1
{
RegMemImm
:
:
imm
(
1
)
}
else
{
assert
!
(
!
is_bool_ty
(
src_ty
)
)
;
RegMemImm
:
:
reg
(
src
)
}
;
ctx
.
emit
(
Inst
:
:
test_rmi_r
(
OperandSize
:
:
from_ty
(
src_ty
)
test_input
src
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
{
unimplemented
!
(
"
brz
/
brnz
with
non
-
int
type
{
:
?
}
"
src_ty
)
;
}
}
Opcode
:
:
BrIcmp
=
>
{
let
src_ty
=
ctx
.
input_ty
(
branches
[
0
]
0
)
;
if
is_int_or_ref_ty
(
src_ty
)
|
|
is_bool_ty
(
src_ty
)
{
let
lhs
=
put_input_in_reg
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
)
;
let
rhs
=
input_to_reg_mem_imm
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
1
}
)
;
let
cc
=
CC
:
:
from_intcc
(
ctx
.
data
(
branches
[
0
]
)
.
cond_code
(
)
.
unwrap
(
)
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
from_ty
(
src_ty
)
rhs
lhs
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
{
unimplemented
!
(
"
bricmp
with
non
-
int
type
{
:
?
}
"
src_ty
)
;
}
}
Opcode
:
:
Brif
=
>
{
let
flag_input
=
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
;
if
let
Some
(
ifcmp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
Ifcmp
)
{
let
cond_code
=
ctx
.
data
(
branches
[
0
]
)
.
cond_code
(
)
.
unwrap
(
)
;
let
cond_code
=
emit_cmp
(
ctx
ifcmp
cond_code
)
;
let
cc
=
CC
:
:
from_intcc
(
cond_code
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
if
let
Some
(
ifcmp_sp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
IfcmpSp
)
{
let
operand
=
put_input_in_reg
(
ctx
InsnInput
{
insn
:
ifcmp_sp
input
:
0
}
)
;
let
ty
=
ctx
.
input_ty
(
ifcmp_sp
0
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
from_ty
(
ty
)
RegMemImm
:
:
reg
(
regs
:
:
rsp
(
)
)
operand
)
)
;
let
cond_code
=
ctx
.
data
(
branches
[
0
]
)
.
cond_code
(
)
.
unwrap
(
)
;
let
cc
=
CC
:
:
from_intcc
(
cond_code
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
{
unimplemented
!
(
"
Brif
with
non
-
ifcmp
input
"
)
;
}
}
Opcode
:
:
Brff
=
>
{
let
flag_input
=
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
;
if
let
Some
(
ffcmp
)
=
matches_input
(
ctx
flag_input
Opcode
:
:
Ffcmp
)
{
let
cond_code
=
ctx
.
data
(
branches
[
0
]
)
.
fp_cond_code
(
)
.
unwrap
(
)
;
match
emit_fcmp
(
ctx
ffcmp
cond_code
FcmpSpec
:
:
Normal
)
{
FcmpCondResult
:
:
Condition
(
cc
)
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
FcmpCondResult
:
:
AndConditions
(
cc1
cc2
)
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_if
(
cc1
.
invert
(
)
not_taken
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc2
.
invert
(
)
not_taken
taken
)
)
;
}
FcmpCondResult
:
:
OrConditions
(
cc1
cc2
)
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_if
(
cc1
taken
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc2
taken
not_taken
)
)
;
}
FcmpCondResult
:
:
InvertedEqualOrConditions
(
_
_
)
=
>
unreachable
!
(
)
}
}
else
{
unimplemented
!
(
"
Brff
with
input
not
from
ffcmp
"
)
;
}
}
_
=
>
panic
!
(
"
unexpected
branch
opcode
:
{
:
?
}
"
op0
)
}
}
else
{
assert_eq
!
(
branches
.
len
(
)
1
)
;
let
op
=
ctx
.
data
(
branches
[
0
]
)
.
opcode
(
)
;
match
op
{
Opcode
:
:
Jump
|
Opcode
:
:
Fallthrough
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_known
(
targets
[
0
]
)
)
;
}
Opcode
:
:
BrTable
=
>
{
let
jt_size
=
targets
.
len
(
)
-
1
;
assert
!
(
jt_size
<
=
u32
:
:
max_value
(
)
as
usize
)
;
let
jt_size
=
jt_size
as
u32
;
let
idx
=
extend_input_to_reg
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
ExtSpec
:
:
ZeroExtendTo32
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
OperandSize
:
:
Size32
RegMemImm
:
:
imm
(
jt_size
)
idx
)
)
;
let
tmp1
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
types
:
:
I64
)
.
only_reg
(
)
.
unwrap
(
)
;
let
targets_for_term
:
Vec
<
MachLabel
>
=
targets
.
to_vec
(
)
;
let
default_target
=
targets
[
0
]
;
let
jt_targets
:
Vec
<
MachLabel
>
=
targets
.
iter
(
)
.
skip
(
1
)
.
cloned
(
)
.
collect
(
)
;
ctx
.
emit
(
Inst
:
:
JmpTableSeq
{
idx
tmp1
tmp2
default_target
targets
:
jt_targets
targets_for_term
}
)
;
}
_
=
>
panic
!
(
"
Unknown
branch
type
{
:
?
}
"
op
)
}
}
Ok
(
(
)
)
}
fn
maybe_pinned_reg
(
&
self
)
-
>
Option
<
Reg
>
{
Some
(
regs
:
:
pinned_reg
(
)
)
}
}
