#
!
[
allow
(
non_snake_case
)
]
use
log
:
:
trace
;
use
regalloc
:
:
{
Reg
RegClass
Writable
}
;
use
smallvec
:
:
SmallVec
;
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
vec
:
:
Vec
;
use
std
:
:
convert
:
:
TryFrom
;
use
crate
:
:
ir
:
:
types
;
use
crate
:
:
ir
:
:
types
:
:
*
;
use
crate
:
:
ir
:
:
Inst
as
IRInst
;
use
crate
:
:
ir
:
:
{
condcodes
:
:
IntCC
InstructionData
Opcode
TrapCode
Type
}
;
use
crate
:
:
machinst
:
:
lower
:
:
*
;
use
crate
:
:
machinst
:
:
*
;
use
crate
:
:
result
:
:
CodegenResult
;
use
crate
:
:
settings
:
:
Flags
;
use
crate
:
:
isa
:
:
x64
:
:
abi
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
args
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
X64Backend
;
type
Ctx
<
'
a
>
=
&
'
a
mut
dyn
LowerCtx
<
I
=
Inst
>
;
fn
is_int_ty
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
I8
|
types
:
:
I16
|
types
:
:
I32
|
types
:
:
I64
=
>
true
_
=
>
false
}
}
fn
is_bool_ty
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
B1
|
types
:
:
B8
|
types
:
:
B16
|
types
:
:
B32
|
types
:
:
B64
=
>
true
_
=
>
false
}
}
fn
is_float_ty
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
F32
|
types
:
:
F64
=
>
true
_
=
>
false
}
}
fn
int_ty_is_64
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
I8
|
types
:
:
I16
|
types
:
:
I32
=
>
false
types
:
:
I64
=
>
true
_
=
>
panic
!
(
"
type
{
}
is
none
of
I8
I16
I32
or
I64
"
ty
)
}
}
fn
flt_ty_is_64
(
ty
:
Type
)
-
>
bool
{
match
ty
{
types
:
:
F32
=
>
false
types
:
:
F64
=
>
true
_
=
>
panic
!
(
"
type
{
}
is
none
of
F32
F64
"
ty
)
}
}
fn
iri_to_u64_imm
(
ctx
:
Ctx
inst
:
IRInst
)
-
>
Option
<
u64
>
{
ctx
.
get_constant
(
inst
)
}
fn
inst_trapcode
(
data
:
&
InstructionData
)
-
>
Option
<
TrapCode
>
{
match
data
{
&
InstructionData
:
:
Trap
{
code
.
.
}
|
&
InstructionData
:
:
CondTrap
{
code
.
.
}
|
&
InstructionData
:
:
IntCondTrap
{
code
.
.
}
|
&
InstructionData
:
:
FloatCondTrap
{
code
.
.
}
=
>
Some
(
code
)
_
=
>
None
}
}
fn
inst_condcode
(
data
:
&
InstructionData
)
-
>
IntCC
{
match
data
{
&
InstructionData
:
:
IntCond
{
cond
.
.
}
|
&
InstructionData
:
:
BranchIcmp
{
cond
.
.
}
|
&
InstructionData
:
:
IntCompare
{
cond
.
.
}
|
&
InstructionData
:
:
IntCondTrap
{
cond
.
.
}
|
&
InstructionData
:
:
BranchInt
{
cond
.
.
}
|
&
InstructionData
:
:
IntSelect
{
cond
.
.
}
|
&
InstructionData
:
:
IntCompareImm
{
cond
.
.
}
=
>
cond
_
=
>
panic
!
(
"
inst_condcode
(
x64
)
:
unhandled
:
{
:
?
}
"
data
)
}
}
fn
ldst_offset
(
data
:
&
InstructionData
)
-
>
Option
<
i32
>
{
match
data
{
&
InstructionData
:
:
Load
{
offset
.
.
}
|
&
InstructionData
:
:
StackLoad
{
offset
.
.
}
|
&
InstructionData
:
:
LoadComplex
{
offset
.
.
}
|
&
InstructionData
:
:
Store
{
offset
.
.
}
|
&
InstructionData
:
:
StackStore
{
offset
.
.
}
|
&
InstructionData
:
:
StoreComplex
{
offset
.
.
}
=
>
Some
(
offset
.
into
(
)
)
_
=
>
None
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
struct
InsnInput
{
insn
:
IRInst
input
:
usize
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
struct
InsnOutput
{
insn
:
IRInst
output
:
usize
}
fn
input_to_reg
(
ctx
:
Ctx
spec
:
InsnInput
)
-
>
Reg
{
let
inputs
=
ctx
.
get_input
(
spec
.
insn
spec
.
input
)
;
ctx
.
use_input_reg
(
inputs
)
;
inputs
.
reg
}
enum
ExtSpec
{
ZeroExtendTo32
ZeroExtendTo64
SignExtendTo32
SignExtendTo64
}
fn
extend_input_to_reg
(
ctx
:
Ctx
spec
:
InsnInput
ext_spec
:
ExtSpec
)
-
>
Reg
{
let
requested_size
=
match
ext_spec
{
ExtSpec
:
:
ZeroExtendTo32
|
ExtSpec
:
:
SignExtendTo32
=
>
32
ExtSpec
:
:
ZeroExtendTo64
|
ExtSpec
:
:
SignExtendTo64
=
>
64
}
;
let
input_size
=
ctx
.
input_ty
(
spec
.
insn
spec
.
input
)
.
bits
(
)
;
let
ext_mode
=
match
(
input_size
requested_size
)
{
(
a
b
)
if
a
=
=
b
=
>
return
input_to_reg
(
ctx
spec
)
(
a
32
)
if
a
=
=
1
|
|
a
=
=
8
=
>
ExtMode
:
:
BL
(
a
64
)
if
a
=
=
1
|
|
a
=
=
8
=
>
ExtMode
:
:
BQ
(
16
32
)
=
>
ExtMode
:
:
WL
(
16
64
)
=
>
ExtMode
:
:
WQ
(
32
64
)
=
>
ExtMode
:
:
LQ
_
=
>
unreachable
!
(
)
}
;
let
requested_ty
=
if
requested_size
=
=
32
{
I32
}
else
{
I64
}
;
let
src
=
input_to_reg_mem
(
ctx
spec
)
;
let
dst
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
requested_ty
)
;
match
ext_spec
{
ExtSpec
:
:
ZeroExtendTo32
|
ExtSpec
:
:
ZeroExtendTo64
=
>
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
src
dst
None
)
)
}
ExtSpec
:
:
SignExtendTo32
|
ExtSpec
:
:
SignExtendTo64
=
>
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
src
dst
None
)
)
}
}
dst
.
to_reg
(
)
}
fn
input_to_reg_mem
(
ctx
:
Ctx
spec
:
InsnInput
)
-
>
RegMem
{
RegMem
:
:
reg
(
input_to_reg
(
ctx
spec
)
)
}
fn
input_to_reg_mem_imm
(
ctx
:
Ctx
spec
:
InsnInput
)
-
>
RegMemImm
{
let
imm
=
ctx
.
get_input
(
spec
.
insn
spec
.
input
)
.
constant
.
and_then
(
|
x
|
{
if
ctx
.
input_ty
(
spec
.
insn
spec
.
input
)
.
bytes
(
)
!
=
8
|
|
low32_will_sign_extend_to_64
(
x
)
{
Some
(
x
as
u32
)
}
else
{
None
}
}
)
;
match
imm
{
Some
(
x
)
=
>
RegMemImm
:
:
imm
(
x
)
None
=
>
RegMemImm
:
:
reg
(
input_to_reg
(
ctx
spec
)
)
}
}
fn
output_to_reg
(
ctx
:
Ctx
spec
:
InsnOutput
)
-
>
Writable
<
Reg
>
{
ctx
.
get_output
(
spec
.
insn
spec
.
output
)
}
fn
emit_cmp
(
ctx
:
Ctx
insn
:
IRInst
)
{
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
let
inputs
=
[
InsnInput
{
insn
input
:
0
}
InsnInput
{
insn
input
:
1
}
]
;
let
lhs
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
ty
.
bytes
(
)
as
u8
rhs
lhs
)
)
;
}
fn
lower_insn_to_regs
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
ctx
:
&
mut
C
insn
:
IRInst
flags
:
&
Flags
)
-
>
CodegenResult
<
(
)
>
{
let
op
=
ctx
.
data
(
insn
)
.
opcode
(
)
;
let
inputs
:
SmallVec
<
[
InsnInput
;
4
]
>
=
(
0
.
.
ctx
.
num_inputs
(
insn
)
)
.
map
(
|
i
|
InsnInput
{
insn
input
:
i
}
)
.
collect
(
)
;
let
outputs
:
SmallVec
<
[
InsnOutput
;
2
]
>
=
(
0
.
.
ctx
.
num_outputs
(
insn
)
)
.
map
(
|
i
|
InsnOutput
{
insn
output
:
i
}
)
.
collect
(
)
;
let
ty
=
if
outputs
.
len
(
)
>
0
{
Some
(
ctx
.
output_ty
(
insn
0
)
)
}
else
{
None
}
;
match
op
{
Opcode
:
:
Iconst
=
>
{
if
let
Some
(
w64
)
=
iri_to_u64_imm
(
ctx
insn
)
{
let
dst_is_64
=
w64
>
0x7fffffff
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
dst_is_64
w64
dst
)
)
;
}
else
{
unimplemented
!
(
)
;
}
}
Opcode
:
:
Iadd
|
Opcode
:
:
Isub
|
Opcode
:
:
Imul
|
Opcode
:
:
Band
|
Opcode
:
:
Bor
|
Opcode
:
:
Bxor
=
>
{
let
lhs
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem_imm
(
ctx
inputs
[
1
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
is_64
=
int_ty_is_64
(
ty
.
unwrap
(
)
)
;
let
alu_op
=
match
op
{
Opcode
:
:
Iadd
=
>
AluRmiROpcode
:
:
Add
Opcode
:
:
Isub
=
>
AluRmiROpcode
:
:
Sub
Opcode
:
:
Imul
=
>
AluRmiROpcode
:
:
Mul
Opcode
:
:
Band
=
>
AluRmiROpcode
:
:
And
Opcode
:
:
Bor
=
>
AluRmiROpcode
:
:
Or
Opcode
:
:
Bxor
=
>
AluRmiROpcode
:
:
Xor
_
=
>
unreachable
!
(
)
}
;
ctx
.
emit
(
Inst
:
:
mov_r_r
(
true
lhs
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
alu_op
rhs
dst
)
)
;
}
Opcode
:
:
Ishl
|
Opcode
:
:
Ushr
|
Opcode
:
:
Sshr
|
Opcode
:
:
Rotl
|
Opcode
:
:
Rotr
=
>
{
let
dst_ty
=
ctx
.
output_ty
(
insn
0
)
;
debug_assert_eq
!
(
ctx
.
input_ty
(
insn
0
)
dst_ty
)
;
debug_assert
!
(
dst_ty
=
=
types
:
:
I32
|
|
dst_ty
=
=
types
:
:
I64
)
;
let
lhs
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
(
count
rhs
)
=
if
let
Some
(
cst
)
=
ctx
.
get_constant
(
inputs
[
1
]
.
insn
)
{
let
cst
=
if
op
=
=
Opcode
:
:
Rotl
|
|
op
=
=
Opcode
:
:
Rotr
{
(
cst
as
u8
)
&
(
dst_ty
.
bits
(
)
as
u8
-
1
)
}
else
{
cst
as
u8
}
;
(
Some
(
cst
)
None
)
}
else
{
(
None
Some
(
input_to_reg
(
ctx
inputs
[
1
]
)
)
)
}
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
shift_kind
=
match
op
{
Opcode
:
:
Ishl
=
>
ShiftKind
:
:
ShiftLeft
Opcode
:
:
Ushr
=
>
ShiftKind
:
:
ShiftRightLogical
Opcode
:
:
Sshr
=
>
ShiftKind
:
:
ShiftRightArithmetic
Opcode
:
:
Rotl
=
>
ShiftKind
:
:
RotateLeft
Opcode
:
:
Rotr
=
>
ShiftKind
:
:
RotateRight
_
=
>
unreachable
!
(
)
}
;
let
is_64
=
dst_ty
=
=
types
:
:
I64
;
let
w_rcx
=
Writable
:
:
from_reg
(
regs
:
:
rcx
(
)
)
;
ctx
.
emit
(
Inst
:
:
mov_r_r
(
true
lhs
dst
)
)
;
if
count
.
is_none
(
)
{
ctx
.
emit
(
Inst
:
:
mov_r_r
(
true
rhs
.
unwrap
(
)
w_rcx
)
)
;
}
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
shift_kind
count
dst
)
)
;
}
Opcode
:
:
Clz
=
>
{
let
(
ext_spec
ty
)
=
match
ctx
.
input_ty
(
insn
0
)
{
I8
|
I16
=
>
(
Some
(
ExtSpec
:
:
ZeroExtendTo32
)
I32
)
a
if
a
=
=
I32
|
|
a
=
=
I64
=
>
(
None
a
)
_
=
>
unreachable
!
(
)
}
;
let
src
=
if
let
Some
(
ext_spec
)
=
ext_spec
{
RegMem
:
:
reg
(
extend_input_to_reg
(
ctx
inputs
[
0
]
ext_spec
)
)
}
else
{
input_to_reg_mem
(
ctx
inputs
[
0
]
)
}
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
tmp
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
ty
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
ty
=
=
I64
u64
:
:
max_value
(
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
ty
.
bytes
(
)
as
u8
UnaryRmROpcode
:
:
Bsr
src
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
ty
.
bytes
(
)
as
u8
CC
:
:
Z
RegMem
:
:
reg
(
dst
.
to_reg
(
)
)
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
ty
=
=
I64
ty
.
bits
(
)
as
u64
-
1
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
ty
=
=
I64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
Opcode
:
:
Ctz
=
>
{
let
ty
=
ctx
.
input_ty
(
insn
0
)
;
let
ty
=
if
ty
.
bits
(
)
<
32
{
I32
}
else
{
ty
}
;
debug_assert
!
(
ty
=
=
I32
|
|
ty
=
=
I64
)
;
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
tmp
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
ty
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
false
ty
.
bits
(
)
as
u64
tmp
)
)
;
ctx
.
emit
(
Inst
:
:
unary_rm_r
(
ty
.
bytes
(
)
as
u8
UnaryRmROpcode
:
:
Bsf
src
dst
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
ty
.
bytes
(
)
as
u8
CC
:
:
Z
RegMem
:
:
reg
(
tmp
.
to_reg
(
)
)
dst
)
)
;
}
Opcode
:
:
Popcnt
=
>
{
let
(
ext_spec
ty
)
=
match
ctx
.
input_ty
(
insn
0
)
{
I8
|
I16
=
>
(
Some
(
ExtSpec
:
:
ZeroExtendTo32
)
I32
)
a
if
a
=
=
I32
|
|
a
=
=
I64
=
>
(
None
a
)
_
=
>
unreachable
!
(
)
}
;
let
src
=
if
let
Some
(
ext_spec
)
=
ext_spec
{
RegMem
:
:
reg
(
extend_input_to_reg
(
ctx
inputs
[
0
]
ext_spec
)
)
}
else
{
input_to_reg_mem
(
ctx
inputs
[
0
]
)
}
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
if
ty
=
=
I64
{
let
is_64
=
true
;
let
tmp1
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I64
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I64
)
;
let
cst
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I64
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
.
clone
(
)
tmp1
None
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
is_64
0x7777777777777777
cst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
tmp2
None
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
RegMem
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
None
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
4
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
is_64
0x0F0F0F0F0F0F0F0F
cst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
is_64
0x0101010101010101
cst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
reg
(
cst
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
56
)
dst
)
)
;
}
else
{
assert_eq
!
(
ty
I32
)
;
let
is_64
=
false
;
let
tmp1
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I64
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I64
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
.
clone
(
)
tmp1
None
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x77777777
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
tmp2
None
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x77777777
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
1
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x77777777
)
tmp1
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Sub
RegMemImm
:
:
reg
(
tmp1
.
to_reg
(
)
)
tmp2
)
)
;
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
RegMem
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
None
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
4
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Add
RegMemImm
:
:
reg
(
tmp2
.
to_reg
(
)
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
And
RegMemImm
:
:
imm
(
0x0F0F0F0F
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
alu_rmi_r
(
is_64
AluRmiROpcode
:
:
Mul
RegMemImm
:
:
imm
(
0x01010101
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
shift_r
(
is_64
ShiftKind
:
:
ShiftRightLogical
Some
(
24
)
dst
)
)
;
}
}
Opcode
:
:
Uextend
|
Opcode
:
:
Sextend
|
Opcode
:
:
Bint
|
Opcode
:
:
Breduce
|
Opcode
:
:
Bextend
|
Opcode
:
:
Ireduce
=
>
{
let
src_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
dst_ty
=
ctx
.
output_ty
(
insn
0
)
;
let
src
=
input_to_reg_mem
(
ctx
inputs
[
0
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
ext_mode
=
match
(
src_ty
.
bits
(
)
dst_ty
.
bits
(
)
)
{
(
1
32
)
|
(
8
32
)
=
>
Some
(
ExtMode
:
:
BL
)
(
1
64
)
|
(
8
64
)
=
>
Some
(
ExtMode
:
:
BQ
)
(
16
32
)
=
>
Some
(
ExtMode
:
:
WL
)
(
16
64
)
=
>
Some
(
ExtMode
:
:
WQ
)
(
32
64
)
=
>
Some
(
ExtMode
:
:
LQ
)
(
x
y
)
if
x
>
=
y
=
>
None
_
=
>
unreachable
!
(
"
unexpected
extension
kind
from
{
:
?
}
to
{
:
?
}
"
src_ty
dst_ty
)
}
;
if
let
Some
(
ext_mode
)
=
ext_mode
{
if
op
=
=
Opcode
:
:
Sextend
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
src
dst
None
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
src
dst
None
)
)
;
}
}
else
{
ctx
.
emit
(
Inst
:
:
mov64_rm_r
(
src
dst
None
)
)
;
}
}
Opcode
:
:
Icmp
=
>
{
emit_cmp
(
ctx
insn
)
;
let
condcode
=
inst_condcode
(
ctx
.
data
(
insn
)
)
;
let
cc
=
CC
:
:
from_intcc
(
condcode
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
setcc
(
cc
dst
)
)
;
}
Opcode
:
:
FallthroughReturn
|
Opcode
:
:
Return
=
>
{
for
i
in
0
.
.
ctx
.
num_inputs
(
insn
)
{
let
src_reg
=
input_to_reg
(
ctx
inputs
[
i
]
)
;
let
retval_reg
=
ctx
.
retval
(
i
)
;
let
ty
=
ctx
.
input_ty
(
insn
i
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
retval_reg
src_reg
ty
)
)
;
}
}
Opcode
:
:
Call
|
Opcode
:
:
CallIndirect
=
>
{
let
loc
=
ctx
.
srcloc
(
insn
)
;
let
(
mut
abi
inputs
)
=
match
op
{
Opcode
:
:
Call
=
>
{
let
(
extname
dist
)
=
ctx
.
call_target
(
insn
)
.
unwrap
(
)
;
let
sig
=
ctx
.
call_sig
(
insn
)
.
unwrap
(
)
;
assert
!
(
inputs
.
len
(
)
=
=
sig
.
params
.
len
(
)
)
;
assert
!
(
outputs
.
len
(
)
=
=
sig
.
returns
.
len
(
)
)
;
(
X64ABICall
:
:
from_func
(
sig
&
extname
dist
loc
)
?
&
inputs
[
.
.
]
)
}
Opcode
:
:
CallIndirect
=
>
{
let
ptr
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
sig
=
ctx
.
call_sig
(
insn
)
.
unwrap
(
)
;
assert
!
(
inputs
.
len
(
)
-
1
=
=
sig
.
params
.
len
(
)
)
;
assert
!
(
outputs
.
len
(
)
=
=
sig
.
returns
.
len
(
)
)
;
(
X64ABICall
:
:
from_ptr
(
sig
ptr
loc
op
)
?
&
inputs
[
1
.
.
]
)
}
_
=
>
unreachable
!
(
)
}
;
abi
.
emit_stack_pre_adjust
(
ctx
)
;
assert
!
(
inputs
.
len
(
)
=
=
abi
.
num_args
(
)
)
;
for
(
i
input
)
in
inputs
.
iter
(
)
.
enumerate
(
)
{
let
arg_reg
=
input_to_reg
(
ctx
*
input
)
;
abi
.
emit_copy_reg_to_arg
(
ctx
i
arg_reg
)
;
}
abi
.
emit_call
(
ctx
)
;
for
(
i
output
)
in
outputs
.
iter
(
)
.
enumerate
(
)
{
let
retval_reg
=
output_to_reg
(
ctx
*
output
)
;
abi
.
emit_copy_retval_to_reg
(
ctx
i
retval_reg
)
;
}
abi
.
emit_stack_post_adjust
(
ctx
)
;
}
Opcode
:
:
Debugtrap
=
>
{
ctx
.
emit
(
Inst
:
:
Hlt
)
;
}
Opcode
:
:
Trap
|
Opcode
:
:
ResumableTrap
=
>
{
let
trap_info
=
(
ctx
.
srcloc
(
insn
)
inst_trapcode
(
ctx
.
data
(
insn
)
)
.
unwrap
(
)
)
;
ctx
.
emit
(
Inst
:
:
Ud2
{
trap_info
}
)
}
Opcode
:
:
Fadd
|
Opcode
:
:
Fsub
|
Opcode
:
:
Fmul
|
Opcode
:
:
Fdiv
=
>
{
let
lhs
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg
(
ctx
inputs
[
1
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
is_64
=
flt_ty_is_64
(
ty
.
unwrap
(
)
)
;
if
!
is_64
{
let
sse_op
=
match
op
{
Opcode
:
:
Fadd
=
>
SseOpcode
:
:
Addss
Opcode
:
:
Fsub
=
>
SseOpcode
:
:
Subss
Opcode
:
:
Fmul
=
>
SseOpcode
:
:
Mulss
Opcode
:
:
Fdiv
=
>
SseOpcode
:
:
Divss
_
=
>
unimplemented
!
(
)
}
;
ctx
.
emit
(
Inst
:
:
xmm_mov_rm_r
(
SseOpcode
:
:
Movss
RegMem
:
:
reg
(
lhs
)
dst
None
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
sse_op
RegMem
:
:
reg
(
rhs
)
dst
)
)
;
}
else
{
unimplemented
!
(
"
unimplemented
lowering
for
opcode
{
:
?
}
"
op
)
;
}
}
Opcode
:
:
Fcopysign
=
>
{
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
lhs
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg
(
ctx
inputs
[
1
]
)
;
if
!
flt_ty_is_64
(
ty
.
unwrap
(
)
)
{
let
tmp_gpr1
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I32
)
;
let
tmp_xmm1
=
ctx
.
alloc_tmp
(
RegClass
:
:
V128
F32
)
;
let
tmp_xmm2
=
ctx
.
alloc_tmp
(
RegClass
:
:
V128
F32
)
;
ctx
.
emit
(
Inst
:
:
imm_r
(
true
0x8000_0000
tmp_gpr1
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov_rm_r
(
SseOpcode
:
:
Movd
RegMem
:
:
reg
(
tmp_gpr1
.
to_reg
(
)
)
tmp_xmm1
None
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov_rm_r
(
SseOpcode
:
:
Movaps
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
dst
None
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Andnps
RegMem
:
:
reg
(
lhs
)
dst
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_mov_rm_r
(
SseOpcode
:
:
Movss
RegMem
:
:
reg
(
rhs
)
tmp_xmm2
None
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Andps
RegMem
:
:
reg
(
tmp_xmm1
.
to_reg
(
)
)
tmp_xmm2
)
)
;
ctx
.
emit
(
Inst
:
:
xmm_rm_r
(
SseOpcode
:
:
Orps
RegMem
:
:
reg
(
tmp_xmm2
.
to_reg
(
)
)
dst
)
)
;
}
else
{
unimplemented
!
(
"
{
:
?
}
for
non
32
-
bit
destination
is
not
supported
"
op
)
;
}
}
Opcode
:
:
Load
|
Opcode
:
:
Uload8
|
Opcode
:
:
Sload8
|
Opcode
:
:
Uload16
|
Opcode
:
:
Sload16
|
Opcode
:
:
Uload32
|
Opcode
:
:
Sload32
|
Opcode
:
:
LoadComplex
|
Opcode
:
:
Uload8Complex
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Uload16Complex
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Uload32Complex
|
Opcode
:
:
Sload32Complex
=
>
{
let
offset
=
ldst_offset
(
ctx
.
data
(
insn
)
)
.
unwrap
(
)
;
let
elem_ty
=
match
op
{
Opcode
:
:
Sload8
|
Opcode
:
:
Uload8
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Uload8Complex
=
>
{
types
:
:
I8
}
Opcode
:
:
Sload16
|
Opcode
:
:
Uload16
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Uload16Complex
=
>
types
:
:
I16
Opcode
:
:
Sload32
|
Opcode
:
:
Uload32
|
Opcode
:
:
Sload32Complex
|
Opcode
:
:
Uload32Complex
=
>
types
:
:
I32
Opcode
:
:
Load
|
Opcode
:
:
LoadComplex
=
>
ctx
.
output_ty
(
insn
0
)
_
=
>
unimplemented
!
(
)
}
;
let
ext_mode
=
match
elem_ty
.
bytes
(
)
{
1
=
>
Some
(
ExtMode
:
:
BQ
)
2
=
>
Some
(
ExtMode
:
:
WQ
)
4
=
>
Some
(
ExtMode
:
:
LQ
)
_
=
>
None
}
;
let
sign_extend
=
match
op
{
Opcode
:
:
Sload8
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Sload16
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Sload32
|
Opcode
:
:
Sload32Complex
=
>
true
_
=
>
false
}
;
let
is_float
=
is_float_ty
(
elem_ty
)
;
let
addr
=
match
op
{
Opcode
:
:
Load
|
Opcode
:
:
Uload8
|
Opcode
:
:
Sload8
|
Opcode
:
:
Uload16
|
Opcode
:
:
Sload16
|
Opcode
:
:
Uload32
|
Opcode
:
:
Sload32
=
>
{
assert
!
(
inputs
.
len
(
)
=
=
1
"
only
one
input
for
load
operands
"
)
;
let
base
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
Amode
:
:
imm_reg
(
offset
as
u32
base
)
}
Opcode
:
:
LoadComplex
|
Opcode
:
:
Uload8Complex
|
Opcode
:
:
Sload8Complex
|
Opcode
:
:
Uload16Complex
|
Opcode
:
:
Sload16Complex
|
Opcode
:
:
Uload32Complex
|
Opcode
:
:
Sload32Complex
=
>
{
assert
!
(
inputs
.
len
(
)
=
=
2
"
can
'
t
handle
more
than
two
inputs
in
complex
load
"
)
;
let
base
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
index
=
input_to_reg
(
ctx
inputs
[
1
]
)
;
let
shift
=
0
;
Amode
:
:
imm_reg_reg_shift
(
offset
as
u32
base
index
shift
)
}
_
=
>
unreachable
!
(
)
}
;
let
srcloc
=
Some
(
ctx
.
srcloc
(
insn
)
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
match
(
sign_extend
is_float
)
{
(
true
false
)
=
>
{
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ext_mode
.
unwrap
(
)
RegMem
:
:
mem
(
addr
)
dst
srcloc
)
)
;
}
(
false
false
)
=
>
{
if
elem_ty
.
bytes
(
)
=
=
8
{
ctx
.
emit
(
Inst
:
:
mov64_m_r
(
addr
dst
srcloc
)
)
}
else
{
ctx
.
emit
(
Inst
:
:
movzx_rm_r
(
ext_mode
.
unwrap
(
)
RegMem
:
:
mem
(
addr
)
dst
srcloc
)
)
}
}
(
_
true
)
=
>
{
ctx
.
emit
(
match
elem_ty
{
F32
=
>
Inst
:
:
xmm_mov_rm_r
(
SseOpcode
:
:
Movss
RegMem
:
:
mem
(
addr
)
dst
srcloc
)
_
=
>
unimplemented
!
(
"
FP
load
not
32
-
bit
"
)
}
)
;
}
}
}
Opcode
:
:
Store
|
Opcode
:
:
Istore8
|
Opcode
:
:
Istore16
|
Opcode
:
:
Istore32
|
Opcode
:
:
StoreComplex
|
Opcode
:
:
Istore8Complex
|
Opcode
:
:
Istore16Complex
|
Opcode
:
:
Istore32Complex
=
>
{
let
offset
=
ldst_offset
(
ctx
.
data
(
insn
)
)
.
unwrap
(
)
;
let
elem_ty
=
match
op
{
Opcode
:
:
Istore8
|
Opcode
:
:
Istore8Complex
=
>
types
:
:
I8
Opcode
:
:
Istore16
|
Opcode
:
:
Istore16Complex
=
>
types
:
:
I16
Opcode
:
:
Istore32
|
Opcode
:
:
Istore32Complex
=
>
types
:
:
I32
Opcode
:
:
Store
|
Opcode
:
:
StoreComplex
=
>
ctx
.
input_ty
(
insn
0
)
_
=
>
unreachable
!
(
)
}
;
let
is_float
=
is_float_ty
(
elem_ty
)
;
let
addr
=
match
op
{
Opcode
:
:
Store
|
Opcode
:
:
Istore8
|
Opcode
:
:
Istore16
|
Opcode
:
:
Istore32
=
>
{
assert
!
(
inputs
.
len
(
)
=
=
2
"
only
one
input
for
store
memory
operands
"
)
;
let
base
=
input_to_reg
(
ctx
inputs
[
1
]
)
;
Amode
:
:
imm_reg
(
offset
as
u32
base
)
}
Opcode
:
:
StoreComplex
|
Opcode
:
:
Istore8Complex
|
Opcode
:
:
Istore16Complex
|
Opcode
:
:
Istore32Complex
=
>
{
assert
!
(
inputs
.
len
(
)
=
=
3
"
can
'
t
handle
more
than
two
inputs
in
complex
load
"
)
;
let
base
=
input_to_reg
(
ctx
inputs
[
1
]
)
;
let
index
=
input_to_reg
(
ctx
inputs
[
2
]
)
;
let
shift
=
0
;
Amode
:
:
imm_reg_reg_shift
(
offset
as
u32
base
index
shift
)
}
_
=
>
unreachable
!
(
)
}
;
let
src
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
srcloc
=
Some
(
ctx
.
srcloc
(
insn
)
)
;
if
is_float
{
ctx
.
emit
(
match
elem_ty
{
F32
=
>
Inst
:
:
xmm_mov_r_m
(
SseOpcode
:
:
Movss
src
addr
srcloc
)
_
=
>
unimplemented
!
(
"
FP
store
not
32
-
bit
"
)
}
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
mov_r_m
(
elem_ty
.
bytes
(
)
as
u8
src
addr
srcloc
)
)
;
}
}
Opcode
:
:
FuncAddr
=
>
{
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
(
extname
_
)
=
ctx
.
call_target
(
insn
)
.
unwrap
(
)
;
let
extname
=
extname
.
clone
(
)
;
let
loc
=
ctx
.
srcloc
(
insn
)
;
ctx
.
emit
(
Inst
:
:
LoadExtName
{
dst
name
:
Box
:
:
new
(
extname
)
srcloc
:
loc
offset
:
0
}
)
;
}
Opcode
:
:
SymbolValue
=
>
{
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
(
extname
_
offset
)
=
ctx
.
symbol_value
(
insn
)
.
unwrap
(
)
;
let
extname
=
extname
.
clone
(
)
;
let
loc
=
ctx
.
srcloc
(
insn
)
;
ctx
.
emit
(
Inst
:
:
LoadExtName
{
dst
name
:
Box
:
:
new
(
extname
)
srcloc
:
loc
offset
}
)
;
}
Opcode
:
:
StackAddr
=
>
{
let
(
stack_slot
offset
)
=
match
*
ctx
.
data
(
insn
)
{
InstructionData
:
:
StackLoad
{
opcode
:
Opcode
:
:
StackAddr
stack_slot
offset
}
=
>
(
stack_slot
offset
)
_
=
>
unreachable
!
(
)
}
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
offset
:
i32
=
offset
.
into
(
)
;
let
inst
=
ctx
.
abi
(
)
.
stackslot_addr
(
stack_slot
u32
:
:
try_from
(
offset
)
.
unwrap
(
)
dst
)
;
ctx
.
emit
(
inst
)
;
}
Opcode
:
:
Select
|
Opcode
:
:
Selectif
|
Opcode
:
:
SelectifSpectreGuard
=
>
{
let
cc
=
if
op
=
=
Opcode
:
:
Select
{
let
size
=
ctx
.
input_ty
(
insn
0
)
.
bytes
(
)
as
u8
;
let
test
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
size
RegMemImm
:
:
imm
(
0
)
test
)
)
;
CC
:
:
NZ
}
else
{
let
cmp_insn
=
ctx
.
get_input
(
inputs
[
0
]
.
insn
inputs
[
0
]
.
input
)
.
inst
.
unwrap
(
)
.
0
;
debug_assert_eq
!
(
ctx
.
data
(
cmp_insn
)
.
opcode
(
)
Opcode
:
:
Ifcmp
)
;
emit_cmp
(
ctx
cmp_insn
)
;
CC
:
:
from_intcc
(
inst_condcode
(
ctx
.
data
(
insn
)
)
)
}
;
let
lhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
rhs
=
input_to_reg
(
ctx
inputs
[
2
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
ty
=
ctx
.
output_ty
(
insn
0
)
;
assert
!
(
is_int_ty
(
ty
)
"
float
cmov
NYI
"
)
;
let
size
=
ty
.
bytes
(
)
as
u8
;
if
size
=
=
1
{
let
lhs_se
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I32
)
;
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ExtMode
:
:
BL
lhs
lhs_se
None
)
)
;
ctx
.
emit
(
Inst
:
:
movsx_rm_r
(
ExtMode
:
:
BL
RegMem
:
:
reg
(
rhs
)
dst
None
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
4
cc
RegMem
:
:
reg
(
lhs_se
.
to_reg
(
)
)
dst
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
rhs
ty
)
)
;
ctx
.
emit
(
Inst
:
:
cmove
(
size
cc
lhs
dst
)
)
;
}
}
Opcode
:
:
Udiv
|
Opcode
:
:
Urem
|
Opcode
:
:
Sdiv
|
Opcode
:
:
Srem
=
>
{
let
kind
=
match
op
{
Opcode
:
:
Udiv
=
>
DivOrRemKind
:
:
UnsignedDiv
Opcode
:
:
Sdiv
=
>
DivOrRemKind
:
:
SignedDiv
Opcode
:
:
Urem
=
>
DivOrRemKind
:
:
UnsignedRem
Opcode
:
:
Srem
=
>
DivOrRemKind
:
:
SignedRem
_
=
>
unreachable
!
(
)
}
;
let
is_div
=
kind
.
is_div
(
)
;
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
size
=
input_ty
.
bytes
(
)
as
u8
;
let
dividend
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
let
srcloc
=
ctx
.
srcloc
(
insn
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
dividend
input_ty
)
)
;
if
flags
.
avoid_div_traps
(
)
{
let
divisor
=
input_to_reg
(
ctx
inputs
[
1
]
)
;
let
tmp
=
if
op
=
=
Opcode
:
:
Sdiv
&
&
size
=
=
8
{
Some
(
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I64
)
)
}
else
{
None
}
;
ctx
.
emit
(
Inst
:
:
imm_r
(
true
0
Writable
:
:
from_reg
(
regs
:
:
rdx
(
)
)
)
)
;
ctx
.
emit
(
Inst
:
:
CheckedDivOrRemSeq
{
kind
size
divisor
tmp
loc
:
srcloc
}
)
;
}
else
{
let
divisor
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
if
kind
.
is_signed
(
)
{
ctx
.
emit
(
Inst
:
:
sign_extend_rax_to_rdx
(
size
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
imm_r
(
true
0
Writable
:
:
from_reg
(
regs
:
:
rdx
(
)
)
)
)
;
}
ctx
.
emit
(
Inst
:
:
div
(
size
kind
.
is_signed
(
)
divisor
ctx
.
srcloc
(
insn
)
)
)
;
}
if
is_div
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rax
(
)
input_ty
)
)
;
}
else
{
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rdx
(
)
input_ty
)
)
;
}
}
Opcode
:
:
Umulhi
|
Opcode
:
:
Smulhi
=
>
{
let
input_ty
=
ctx
.
input_ty
(
insn
0
)
;
let
size
=
input_ty
.
bytes
(
)
as
u8
;
let
lhs
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
let
rhs
=
input_to_reg_mem
(
ctx
inputs
[
1
]
)
;
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
rax
(
)
)
lhs
input_ty
)
)
;
let
signed
=
op
=
=
Opcode
:
:
Smulhi
;
ctx
.
emit
(
Inst
:
:
mul_hi
(
size
signed
rhs
)
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
rdx
(
)
input_ty
)
)
;
}
Opcode
:
:
GetPinnedReg
=
>
{
let
dst
=
output_to_reg
(
ctx
outputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
dst
regs
:
:
pinned_reg
(
)
I64
)
)
;
}
Opcode
:
:
SetPinnedReg
=
>
{
let
src
=
input_to_reg
(
ctx
inputs
[
0
]
)
;
ctx
.
emit
(
Inst
:
:
gen_move
(
Writable
:
:
from_reg
(
regs
:
:
pinned_reg
(
)
)
src
I64
)
)
;
}
Opcode
:
:
IaddImm
|
Opcode
:
:
ImulImm
|
Opcode
:
:
UdivImm
|
Opcode
:
:
SdivImm
|
Opcode
:
:
UremImm
|
Opcode
:
:
SremImm
|
Opcode
:
:
IrsubImm
|
Opcode
:
:
IaddCin
|
Opcode
:
:
IaddIfcin
|
Opcode
:
:
IaddCout
|
Opcode
:
:
IaddIfcout
|
Opcode
:
:
IaddCarry
|
Opcode
:
:
IaddIfcarry
|
Opcode
:
:
IsubBin
|
Opcode
:
:
IsubIfbin
|
Opcode
:
:
IsubBout
|
Opcode
:
:
IsubIfbout
|
Opcode
:
:
IsubBorrow
|
Opcode
:
:
IsubIfborrow
|
Opcode
:
:
BandImm
|
Opcode
:
:
BorImm
|
Opcode
:
:
BxorImm
|
Opcode
:
:
RotlImm
|
Opcode
:
:
RotrImm
|
Opcode
:
:
IshlImm
|
Opcode
:
:
UshrImm
|
Opcode
:
:
SshrImm
=
>
{
panic
!
(
"
ALU
+
imm
and
ALU
+
carry
ops
should
not
appear
here
!
"
)
;
}
_
=
>
unimplemented
!
(
"
unimplemented
lowering
for
opcode
{
:
?
}
"
op
)
}
Ok
(
(
)
)
}
impl
LowerBackend
for
X64Backend
{
type
MInst
=
Inst
;
fn
lower
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
&
self
ctx
:
&
mut
C
ir_inst
:
IRInst
)
-
>
CodegenResult
<
(
)
>
{
lower_insn_to_regs
(
ctx
ir_inst
&
self
.
flags
)
}
fn
lower_branch_group
<
C
:
LowerCtx
<
I
=
Inst
>
>
(
&
self
ctx
:
&
mut
C
branches
:
&
[
IRInst
]
targets
:
&
[
MachLabel
]
fallthrough
:
Option
<
MachLabel
>
)
-
>
CodegenResult
<
(
)
>
{
assert
!
(
branches
.
len
(
)
<
=
2
)
;
if
branches
.
len
(
)
=
=
2
{
let
op0
=
ctx
.
data
(
branches
[
0
]
)
.
opcode
(
)
;
let
op1
=
ctx
.
data
(
branches
[
1
]
)
.
opcode
(
)
;
trace
!
(
"
lowering
two
-
branch
group
:
opcodes
are
{
:
?
}
and
{
:
?
}
"
op0
op1
)
;
assert
!
(
op1
=
=
Opcode
:
:
Jump
|
|
op1
=
=
Opcode
:
:
Fallthrough
)
;
let
taken
=
BranchTarget
:
:
Label
(
targets
[
0
]
)
;
let
not_taken
=
match
op1
{
Opcode
:
:
Jump
=
>
BranchTarget
:
:
Label
(
targets
[
1
]
)
Opcode
:
:
Fallthrough
=
>
BranchTarget
:
:
Label
(
fallthrough
.
unwrap
(
)
)
_
=
>
unreachable
!
(
)
}
;
match
op0
{
Opcode
:
:
Brz
|
Opcode
:
:
Brnz
=
>
{
let
src_ty
=
ctx
.
input_ty
(
branches
[
0
]
0
)
;
if
is_int_ty
(
src_ty
)
|
|
is_bool_ty
(
src_ty
)
{
let
src
=
input_to_reg
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
)
;
let
cc
=
match
op0
{
Opcode
:
:
Brz
=
>
CC
:
:
Z
Opcode
:
:
Brnz
=
>
CC
:
:
NZ
_
=
>
unreachable
!
(
)
}
;
let
size_bytes
=
src_ty
.
bytes
(
)
as
u8
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
size_bytes
RegMemImm
:
:
imm
(
0
)
src
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
{
unimplemented
!
(
"
brz
/
brnz
with
non
-
int
type
{
:
?
}
"
src_ty
)
;
}
}
Opcode
:
:
BrIcmp
=
>
{
let
src_ty
=
ctx
.
input_ty
(
branches
[
0
]
0
)
;
if
is_int_ty
(
src_ty
)
|
|
is_bool_ty
(
src_ty
)
{
let
lhs
=
input_to_reg
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
)
;
let
rhs
=
input_to_reg_mem_imm
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
1
}
)
;
let
cc
=
CC
:
:
from_intcc
(
inst_condcode
(
ctx
.
data
(
branches
[
0
]
)
)
)
;
let
byte_size
=
src_ty
.
bytes
(
)
as
u8
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
byte_size
rhs
lhs
)
)
;
ctx
.
emit
(
Inst
:
:
jmp_cond
(
cc
taken
not_taken
)
)
;
}
else
{
unimplemented
!
(
"
bricmp
with
non
-
int
type
{
:
?
}
"
src_ty
)
;
}
}
_
=
>
unimplemented
!
(
"
branch
opcode
"
)
}
}
else
{
assert
!
(
branches
.
len
(
)
=
=
1
)
;
let
op
=
ctx
.
data
(
branches
[
0
]
)
.
opcode
(
)
;
match
op
{
Opcode
:
:
Jump
|
Opcode
:
:
Fallthrough
=
>
{
ctx
.
emit
(
Inst
:
:
jmp_known
(
BranchTarget
:
:
Label
(
targets
[
0
]
)
)
)
;
}
Opcode
:
:
BrTable
=
>
{
let
jt_size
=
targets
.
len
(
)
-
1
;
assert
!
(
jt_size
<
=
u32
:
:
max_value
(
)
as
usize
)
;
let
jt_size
=
jt_size
as
u32
;
let
idx
=
extend_input_to_reg
(
ctx
InsnInput
{
insn
:
branches
[
0
]
input
:
0
}
ExtSpec
:
:
ZeroExtendTo32
)
;
ctx
.
emit
(
Inst
:
:
cmp_rmi_r
(
4
RegMemImm
:
:
imm
(
jt_size
)
idx
)
)
;
let
tmp1
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I32
)
;
let
tmp2
=
ctx
.
alloc_tmp
(
RegClass
:
:
I64
I32
)
;
let
targets_for_term
:
Vec
<
MachLabel
>
=
targets
.
to_vec
(
)
;
let
default_target
=
BranchTarget
:
:
Label
(
targets
[
0
]
)
;
let
jt_targets
:
Vec
<
BranchTarget
>
=
targets
.
iter
(
)
.
skip
(
1
)
.
map
(
|
bix
|
BranchTarget
:
:
Label
(
*
bix
)
)
.
collect
(
)
;
ctx
.
emit
(
Inst
:
:
JmpTableSeq
{
idx
tmp1
tmp2
default_target
targets
:
jt_targets
targets_for_term
}
)
;
}
_
=
>
panic
!
(
"
Unknown
branch
type
{
:
?
}
"
op
)
}
}
Ok
(
(
)
)
}
fn
maybe_pinned_reg
(
&
self
)
-
>
Option
<
Reg
>
{
Some
(
regs
:
:
pinned_reg
(
)
)
}
}
