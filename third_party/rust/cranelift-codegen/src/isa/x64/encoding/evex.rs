use
super
:
:
rex
:
:
{
encode_modrm
LegacyPrefixes
OpcodeMap
}
;
use
super
:
:
ByteSink
;
use
core
:
:
ops
:
:
RangeInclusive
;
pub
struct
EvexInstruction
{
bits
:
u32
opcode
:
u8
reg
:
Register
rm
:
Register
}
impl
Default
for
EvexInstruction
{
fn
default
(
)
-
>
Self
{
Self
{
bits
:
0x08_7C_F0_62
opcode
:
0
reg
:
Register
:
:
default
(
)
rm
:
Register
:
:
default
(
)
}
}
}
#
[
allow
(
non_upper_case_globals
)
]
impl
EvexInstruction
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
inline
(
always
)
]
pub
fn
length
(
mut
self
length
:
EvexVectorLength
)
-
>
Self
{
self
.
write
(
Self
:
:
LL
EvexContext
:
:
Other
{
length
}
.
bits
(
)
as
u32
)
;
self
}
#
[
inline
(
always
)
]
pub
fn
prefix
(
mut
self
prefix
:
LegacyPrefixes
)
-
>
Self
{
self
.
write
(
Self
:
:
pp
prefix
.
bits
(
)
as
u32
)
;
self
}
#
[
inline
(
always
)
]
pub
fn
map
(
mut
self
map
:
OpcodeMap
)
-
>
Self
{
self
.
write
(
Self
:
:
mm
map
.
bits
(
)
as
u32
)
;
self
}
#
[
inline
(
always
)
]
pub
fn
w
(
mut
self
w
:
bool
)
-
>
Self
{
self
.
write
(
Self
:
:
W
w
as
u32
)
;
self
}
#
[
inline
(
always
)
]
pub
fn
opcode
(
mut
self
opcode
:
u8
)
-
>
Self
{
self
.
opcode
=
opcode
;
self
}
#
[
inline
(
always
)
]
pub
fn
reg
(
mut
self
reg
:
impl
Into
<
Register
>
)
-
>
Self
{
self
.
reg
=
reg
.
into
(
)
;
let
r
=
!
(
self
.
reg
.
0
>
>
3
)
&
1
;
let
r_
=
!
(
self
.
reg
.
0
>
>
4
)
&
1
;
self
.
write
(
Self
:
:
R
r
as
u32
)
;
self
.
write
(
Self
:
:
R_
r_
as
u32
)
;
self
}
#
[
allow
(
dead_code
)
]
#
[
inline
(
always
)
]
pub
fn
mask
(
mut
self
mask
:
EvexMasking
)
-
>
Self
{
self
.
write
(
Self
:
:
aaa
mask
.
aaa_bits
(
)
as
u32
)
;
self
.
write
(
Self
:
:
z
mask
.
z_bit
(
)
as
u32
)
;
self
}
#
[
allow
(
dead_code
)
]
#
[
inline
(
always
)
]
pub
fn
vvvvv
(
mut
self
reg
:
impl
Into
<
Register
>
)
-
>
Self
{
let
reg
=
reg
.
into
(
)
;
self
.
write
(
Self
:
:
vvvv
!
(
reg
.
0
as
u32
)
&
0b1111
)
;
self
.
write
(
Self
:
:
V_
!
(
reg
.
0
as
u32
>
>
4
)
&
0b1
)
;
self
}
#
[
inline
(
always
)
]
pub
fn
rm
(
mut
self
reg
:
impl
Into
<
Register
>
)
-
>
Self
{
self
.
rm
=
reg
.
into
(
)
;
let
b
=
!
(
self
.
rm
.
0
>
>
3
)
&
1
;
let
x
=
!
(
self
.
rm
.
0
>
>
4
)
&
1
;
self
.
write
(
Self
:
:
X
x
as
u32
)
;
self
.
write
(
Self
:
:
B
b
as
u32
)
;
self
}
pub
fn
encode
<
CS
:
ByteSink
+
?
Sized
>
(
&
self
sink
:
&
mut
CS
)
{
sink
.
put4
(
self
.
bits
)
;
sink
.
put1
(
self
.
opcode
)
;
sink
.
put1
(
encode_modrm
(
3
self
.
reg
.
0
&
7
self
.
rm
.
0
&
7
)
)
;
}
const
mm
:
RangeInclusive
<
u8
>
=
8
.
.
=
9
;
const
R_
:
RangeInclusive
<
u8
>
=
12
.
.
=
12
;
const
B
:
RangeInclusive
<
u8
>
=
13
.
.
=
13
;
const
X
:
RangeInclusive
<
u8
>
=
14
.
.
=
14
;
const
R
:
RangeInclusive
<
u8
>
=
15
.
.
=
15
;
const
pp
:
RangeInclusive
<
u8
>
=
16
.
.
=
17
;
const
vvvv
:
RangeInclusive
<
u8
>
=
19
.
.
=
22
;
const
W
:
RangeInclusive
<
u8
>
=
23
.
.
=
23
;
const
aaa
:
RangeInclusive
<
u8
>
=
24
.
.
=
26
;
const
V_
:
RangeInclusive
<
u8
>
=
27
.
.
=
27
;
#
[
allow
(
dead_code
)
]
const
b
:
RangeInclusive
<
u8
>
=
28
.
.
=
28
;
const
LL
:
RangeInclusive
<
u8
>
=
29
.
.
=
30
;
const
z
:
RangeInclusive
<
u8
>
=
31
.
.
=
31
;
#
[
inline
]
fn
write
(
&
mut
self
range
:
RangeInclusive
<
u8
>
value
:
u32
)
{
assert
!
(
ExactSizeIterator
:
:
len
(
&
range
)
>
0
)
;
let
size
=
range
.
end
(
)
-
range
.
start
(
)
+
1
;
let
mask
:
u32
=
(
1
<
<
size
)
-
1
;
debug_assert
!
(
value
<
=
mask
"
The
written
value
should
have
fewer
than
{
}
bits
.
"
size
)
;
let
mask_complement
=
!
(
mask
<
<
*
range
.
start
(
)
)
;
self
.
bits
&
=
mask_complement
;
let
value
=
value
<
<
*
range
.
start
(
)
;
self
.
bits
|
=
value
;
}
}
#
[
derive
(
Copy
Clone
Default
)
]
pub
struct
Register
(
u8
)
;
impl
From
<
u8
>
for
Register
{
fn
from
(
reg
:
u8
)
-
>
Self
{
debug_assert
!
(
reg
<
16
)
;
Self
(
reg
)
}
}
impl
Into
<
u8
>
for
Register
{
fn
into
(
self
)
-
>
u8
{
self
.
0
}
}
#
[
allow
(
dead_code
missing_docs
)
]
pub
enum
EvexContext
{
RoundingRegToRegFP
{
rc
:
EvexRoundingControl
}
NoRoundingFP
{
sae
:
bool
length
:
EvexVectorLength
}
MemoryOp
{
broadcast
:
bool
length
:
EvexVectorLength
}
Other
{
length
:
EvexVectorLength
}
}
impl
Default
for
EvexContext
{
fn
default
(
)
-
>
Self
{
Self
:
:
Other
{
length
:
EvexVectorLength
:
:
default
(
)
}
}
}
impl
EvexContext
{
pub
fn
bits
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
RoundingRegToRegFP
{
rc
}
=
>
0b001
|
rc
.
bits
(
)
<
<
1
Self
:
:
NoRoundingFP
{
sae
length
}
=
>
(
*
sae
as
u8
)
|
length
.
bits
(
)
<
<
1
Self
:
:
MemoryOp
{
broadcast
length
}
=
>
(
*
broadcast
as
u8
)
|
length
.
bits
(
)
<
<
1
Self
:
:
Other
{
length
}
=
>
length
.
bits
(
)
<
<
1
}
}
}
#
[
allow
(
dead_code
missing_docs
)
]
pub
enum
EvexVectorLength
{
V128
V256
V512
}
impl
EvexVectorLength
{
fn
bits
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
V128
=
>
0b00
Self
:
:
V256
=
>
0b01
Self
:
:
V512
=
>
0b10
}
}
}
impl
Default
for
EvexVectorLength
{
fn
default
(
)
-
>
Self
{
Self
:
:
V128
}
}
#
[
allow
(
dead_code
missing_docs
)
]
pub
enum
EvexRoundingControl
{
RNE
RD
RU
RZ
}
impl
EvexRoundingControl
{
fn
bits
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
RNE
=
>
0b00
Self
:
:
RD
=
>
0b01
Self
:
:
RU
=
>
0b10
Self
:
:
RZ
=
>
0b11
}
}
}
#
[
allow
(
dead_code
missing_docs
)
]
pub
enum
EvexMasking
{
None
Merging
{
k
:
u8
}
Zeroing
{
k
:
u8
}
}
impl
Default
for
EvexMasking
{
fn
default
(
)
-
>
Self
{
EvexMasking
:
:
None
}
}
impl
EvexMasking
{
pub
fn
z_bit
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
None
|
Self
:
:
Merging
{
.
.
}
=
>
0
Self
:
:
Zeroing
{
.
.
}
=
>
1
}
}
pub
fn
aaa_bits
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
None
=
>
0b000
Self
:
:
Merging
{
k
}
|
Self
:
:
Zeroing
{
k
}
=
>
{
debug_assert
!
(
*
k
<
=
7
)
;
*
k
}
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
isa
:
:
x64
:
:
inst
:
:
regs
;
use
std
:
:
vec
:
:
Vec
;
#
[
test
]
fn
vpabsq
(
)
{
let
dst
=
regs
:
:
xmm0
(
)
;
let
src
=
regs
:
:
xmm1
(
)
;
let
mut
sink0
=
Vec
:
:
new
(
)
;
EvexInstruction
:
:
new
(
)
.
prefix
(
LegacyPrefixes
:
:
_66
)
.
map
(
OpcodeMap
:
:
_0F38
)
.
w
(
true
)
.
opcode
(
0x1F
)
.
reg
(
dst
.
get_hw_encoding
(
)
)
.
rm
(
src
.
get_hw_encoding
(
)
)
.
length
(
EvexVectorLength
:
:
V128
)
.
encode
(
&
mut
sink0
)
;
assert_eq
!
(
sink0
vec
!
[
0x62
0xf2
0xfd
0x08
0x1f
0xc1
]
)
;
}
#
[
test
]
fn
default_emission
(
)
{
let
mut
sink0
=
Vec
:
:
new
(
)
;
EvexInstruction
:
:
new
(
)
.
encode
(
&
mut
sink0
)
;
let
mut
sink1
=
Vec
:
:
new
(
)
;
EvexInstruction
:
:
new
(
)
.
length
(
EvexVectorLength
:
:
V128
)
.
prefix
(
LegacyPrefixes
:
:
None
)
.
map
(
OpcodeMap
:
:
None
)
.
w
(
false
)
.
opcode
(
0x00
)
.
reg
(
regs
:
:
rax
(
)
.
get_hw_encoding
(
)
)
.
rm
(
regs
:
:
rax
(
)
.
get_hw_encoding
(
)
)
.
mask
(
EvexMasking
:
:
None
)
.
encode
(
&
mut
sink1
)
;
assert_eq
!
(
sink0
sink1
)
;
}
}
