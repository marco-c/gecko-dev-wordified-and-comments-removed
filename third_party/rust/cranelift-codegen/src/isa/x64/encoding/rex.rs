use
crate
:
:
{
ir
:
:
TrapCode
isa
:
:
x64
:
:
inst
:
:
{
args
:
:
{
Amode
OperandSize
}
regs
EmitInfo
EmitState
Inst
LabelUse
}
machinst
:
:
{
MachBuffer
MachInstEmitInfo
}
}
;
use
regalloc
:
:
{
Reg
RegClass
}
;
pub
(
crate
)
fn
low8_will_sign_extend_to_64
(
x
:
u32
)
-
>
bool
{
let
xs
=
(
x
as
i32
)
as
i64
;
xs
=
=
(
(
xs
<
<
56
)
>
>
56
)
}
pub
(
crate
)
fn
low8_will_sign_extend_to_32
(
x
:
u32
)
-
>
bool
{
let
xs
=
x
as
i32
;
xs
=
=
(
(
xs
<
<
24
)
>
>
24
)
}
#
[
inline
(
always
)
]
pub
fn
encode_modrm
(
m0d
:
u8
enc_reg_g
:
u8
rm_e
:
u8
)
-
>
u8
{
debug_assert
!
(
m0d
<
4
)
;
debug_assert
!
(
enc_reg_g
<
8
)
;
debug_assert
!
(
rm_e
<
8
)
;
(
(
m0d
&
3
)
<
<
6
)
|
(
(
enc_reg_g
&
7
)
<
<
3
)
|
(
rm_e
&
7
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
encode_sib
(
shift
:
u8
enc_index
:
u8
enc_base
:
u8
)
-
>
u8
{
debug_assert
!
(
shift
<
4
)
;
debug_assert
!
(
enc_index
<
8
)
;
debug_assert
!
(
enc_base
<
8
)
;
(
(
shift
&
3
)
<
<
6
)
|
(
(
enc_index
&
7
)
<
<
3
)
|
(
enc_base
&
7
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
int_reg_enc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
debug_assert_eq
!
(
reg
.
get_class
(
)
RegClass
:
:
I64
)
;
reg
.
get_hw_encoding
(
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
reg_enc
(
reg
:
Reg
)
-
>
u8
{
debug_assert
!
(
reg
.
is_real
(
)
)
;
reg
.
get_hw_encoding
(
)
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Copy
)
]
pub
(
crate
)
struct
RexFlags
(
u8
)
;
impl
RexFlags
{
#
[
inline
(
always
)
]
pub
(
crate
)
fn
set_w
(
)
-
>
Self
{
Self
(
0
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
clear_w
(
)
-
>
Self
{
Self
(
1
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
always_emit
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
0
=
self
.
0
|
2
;
self
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
always_emit_if_8bit_needed
(
&
mut
self
reg
:
Reg
)
-
>
&
mut
Self
{
let
enc_reg
=
int_reg_enc
(
reg
)
;
if
enc_reg
>
=
4
&
&
enc_reg
<
=
7
{
self
.
always_emit
(
)
;
}
self
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
must_clear_w
(
&
self
)
-
>
bool
{
(
self
.
0
&
1
)
!
=
0
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
must_always_emit
(
&
self
)
-
>
bool
{
(
self
.
0
&
2
)
!
=
0
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
emit_two_op
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
enc_g
:
u8
enc_e
:
u8
)
{
let
w
=
if
self
.
must_clear_w
(
)
{
0
}
else
{
1
}
;
let
r
=
(
enc_g
>
>
3
)
&
1
;
let
x
=
0
;
let
b
=
(
enc_e
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
self
.
must_always_emit
(
)
{
sink
.
put1
(
rex
)
;
}
}
#
[
inline
(
always
)
]
pub
fn
emit_three_op
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
enc_g
:
u8
enc_index
:
u8
enc_base
:
u8
)
{
let
w
=
if
self
.
must_clear_w
(
)
{
0
}
else
{
1
}
;
let
r
=
(
enc_g
>
>
3
)
&
1
;
let
x
=
(
enc_index
>
>
3
)
&
1
;
let
b
=
(
enc_base
>
>
3
)
&
1
;
let
rex
=
0x40
|
(
w
<
<
3
)
|
(
r
<
<
2
)
|
(
x
<
<
1
)
|
b
;
if
rex
!
=
0x40
|
|
self
.
must_always_emit
(
)
{
sink
.
put1
(
rex
)
;
}
}
}
impl
From
<
OperandSize
>
for
RexFlags
{
fn
from
(
size
:
OperandSize
)
-
>
Self
{
match
size
{
OperandSize
:
:
Size64
=
>
RexFlags
:
:
set_w
(
)
_
=
>
RexFlags
:
:
clear_w
(
)
}
}
}
impl
From
<
(
OperandSize
Reg
)
>
for
RexFlags
{
fn
from
(
(
size
reg
)
:
(
OperandSize
Reg
)
)
-
>
Self
{
let
mut
rex
=
RexFlags
:
:
from
(
size
)
;
if
size
=
=
OperandSize
:
:
Size8
{
rex
.
always_emit_if_8bit_needed
(
reg
)
;
}
rex
}
}
#
[
allow
(
missing_docs
)
]
pub
enum
OpcodeMap
{
None
_0F
_0F38
_0F3A
}
impl
OpcodeMap
{
pub
(
crate
)
fn
bits
(
&
self
)
-
>
u8
{
match
self
{
OpcodeMap
:
:
None
=
>
0b00
OpcodeMap
:
:
_0F
=
>
0b01
OpcodeMap
:
:
_0F38
=
>
0b10
OpcodeMap
:
:
_0F3A
=
>
0b11
}
}
}
impl
Default
for
OpcodeMap
{
fn
default
(
)
-
>
Self
{
Self
:
:
None
}
}
pub
enum
LegacyPrefixes
{
None
_66
_F0
_66F0
_F2
_F3
_66F3
}
impl
LegacyPrefixes
{
#
[
inline
(
always
)
]
pub
(
crate
)
fn
emit
(
&
self
sink
:
&
mut
MachBuffer
<
Inst
>
)
{
match
self
{
Self
:
:
_66
=
>
sink
.
put1
(
0x66
)
Self
:
:
_F0
=
>
sink
.
put1
(
0xF0
)
Self
:
:
_66F0
=
>
{
sink
.
put1
(
0x66
)
;
sink
.
put1
(
0xF0
)
;
}
Self
:
:
_F2
=
>
sink
.
put1
(
0xF2
)
Self
:
:
_F3
=
>
sink
.
put1
(
0xF3
)
Self
:
:
_66F3
=
>
{
sink
.
put1
(
0x66
)
;
sink
.
put1
(
0xF3
)
;
}
Self
:
:
None
=
>
(
)
}
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
bits
(
&
self
)
-
>
u8
{
match
self
{
Self
:
:
None
=
>
0b00
Self
:
:
_66
=
>
0b01
Self
:
:
_F3
=
>
0b10
Self
:
:
_F2
=
>
0b11
_
=
>
panic
!
(
"
VEX
and
EVEX
bits
can
only
be
extracted
from
single
prefixes
:
None
66
F3
F2
"
)
}
}
}
impl
Default
for
LegacyPrefixes
{
fn
default
(
)
-
>
Self
{
Self
:
:
None
}
}
pub
(
crate
)
fn
emit_std_enc_mem
(
sink
:
&
mut
MachBuffer
<
Inst
>
state
:
&
EmitState
info
:
&
EmitInfo
prefixes
:
LegacyPrefixes
opcodes
:
u32
mut
num_opcodes
:
usize
enc_g
:
u8
mem_e
:
&
Amode
rex
:
RexFlags
)
{
let
srcloc
=
state
.
cur_srcloc
(
)
;
let
can_trap
=
mem_e
.
can_trap
(
)
;
if
can_trap
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
HeapOutOfBounds
)
;
}
prefixes
.
emit
(
sink
)
;
match
mem_e
{
Amode
:
:
ImmReg
{
simm32
base
.
.
}
=
>
{
if
*
base
=
=
regs
:
:
rsp
(
)
&
&
!
can_trap
&
&
info
.
flags
(
)
.
enable_probestack
(
)
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
StackOverflow
)
;
}
let
enc_e
=
int_reg_enc
(
*
base
)
;
rex
.
emit_two_op
(
sink
enc_g
enc_e
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
*
simm32
=
=
0
&
&
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_RBP
&
&
enc_e
!
=
regs
:
:
ENC_R12
&
&
enc_e
!
=
regs
:
:
ENC_R13
{
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
enc_e
&
7
)
)
;
}
else
if
*
simm32
=
=
0
&
&
(
enc_e
=
=
regs
:
:
ENC_RSP
|
|
enc_e
=
=
regs
:
:
ENC_R12
)
{
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
}
else
if
low8_will_sign_extend_to_32
(
*
simm32
)
&
&
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
enc_e
&
7
)
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
enc_e
!
=
regs
:
:
ENC_RSP
&
&
enc_e
!
=
regs
:
:
ENC_R12
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
enc_e
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
if
(
enc_e
=
=
regs
:
:
ENC_RSP
|
|
enc_e
=
=
regs
:
:
ENC_R12
)
&
&
low8_will_sign_extend_to_32
(
*
simm32
)
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put1
(
(
simm32
&
0xFF
)
as
u8
)
;
}
else
if
enc_e
=
=
regs
:
:
ENC_R12
|
|
enc_e
=
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
4
)
)
;
sink
.
put1
(
0x24
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
unreachable
!
(
"
ImmReg
"
)
;
}
}
Amode
:
:
ImmRegRegShift
{
simm32
base
:
reg_base
index
:
reg_index
shift
.
.
}
=
>
{
if
*
reg_base
=
=
regs
:
:
rsp
(
)
&
&
!
can_trap
&
&
info
.
flags
(
)
.
enable_probestack
(
)
{
sink
.
add_trap
(
srcloc
TrapCode
:
:
StackOverflow
)
;
}
let
enc_base
=
int_reg_enc
(
*
reg_base
)
;
let
enc_index
=
int_reg_enc
(
*
reg_index
)
;
rex
.
emit_three_op
(
sink
enc_g
enc_index
enc_base
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
if
low8_will_sign_extend_to_32
(
*
simm32
)
&
&
enc_index
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
1
enc_g
&
7
4
)
)
;
sink
.
put1
(
encode_sib
(
*
shift
enc_index
&
7
enc_base
&
7
)
)
;
sink
.
put1
(
*
simm32
as
u8
)
;
}
else
if
enc_index
!
=
regs
:
:
ENC_RSP
{
sink
.
put1
(
encode_modrm
(
2
enc_g
&
7
4
)
)
;
sink
.
put1
(
encode_sib
(
*
shift
enc_index
&
7
enc_base
&
7
)
)
;
sink
.
put4
(
*
simm32
)
;
}
else
{
panic
!
(
"
ImmRegRegShift
"
)
;
}
}
Amode
:
:
RipRelative
{
ref
target
}
=
>
{
rex
.
emit_two_op
(
sink
enc_g
0
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
sink
.
put1
(
encode_modrm
(
0
enc_g
&
7
0b101
)
)
;
let
offset
=
sink
.
cur_offset
(
)
;
sink
.
use_label_at_offset
(
offset
*
target
LabelUse
:
:
JmpRel32
)
;
sink
.
put4
(
0
)
;
}
}
}
pub
(
crate
)
fn
emit_std_enc_enc
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefixes
:
LegacyPrefixes
opcodes
:
u32
mut
num_opcodes
:
usize
enc_g
:
u8
enc_e
:
u8
rex
:
RexFlags
)
{
prefixes
.
emit
(
sink
)
;
rex
.
emit_two_op
(
sink
enc_g
enc_e
)
;
while
num_opcodes
>
0
{
num_opcodes
-
=
1
;
sink
.
put1
(
(
(
opcodes
>
>
(
num_opcodes
<
<
3
)
)
&
0xFF
)
as
u8
)
;
}
sink
.
put1
(
encode_modrm
(
3
enc_g
&
7
enc_e
&
7
)
)
;
}
pub
(
crate
)
fn
emit_std_reg_mem
(
sink
:
&
mut
MachBuffer
<
Inst
>
state
:
&
EmitState
info
:
&
EmitInfo
prefixes
:
LegacyPrefixes
opcodes
:
u32
num_opcodes
:
usize
reg_g
:
Reg
mem_e
:
&
Amode
rex
:
RexFlags
)
{
let
enc_g
=
reg_enc
(
reg_g
)
;
emit_std_enc_mem
(
sink
state
info
prefixes
opcodes
num_opcodes
enc_g
mem_e
rex
)
;
}
pub
(
crate
)
fn
emit_std_reg_reg
(
sink
:
&
mut
MachBuffer
<
Inst
>
prefixes
:
LegacyPrefixes
opcodes
:
u32
num_opcodes
:
usize
reg_g
:
Reg
reg_e
:
Reg
rex
:
RexFlags
)
{
let
enc_g
=
reg_enc
(
reg_g
)
;
let
enc_e
=
reg_enc
(
reg_e
)
;
emit_std_enc_enc
(
sink
prefixes
opcodes
num_opcodes
enc_g
enc_e
rex
)
;
}
pub
(
crate
)
fn
emit_simm
(
sink
:
&
mut
MachBuffer
<
Inst
>
size
:
u8
simm32
:
u32
)
{
match
size
{
8
|
4
=
>
sink
.
put4
(
simm32
)
2
=
>
sink
.
put2
(
simm32
as
u16
)
1
=
>
sink
.
put1
(
simm32
as
u8
)
_
=
>
unreachable
!
(
)
}
}
