use
super
:
:
registers
:
:
*
;
use
crate
:
:
bitset
:
:
BitSet
;
use
crate
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
crate
:
:
flowgraph
:
:
ControlFlowGraph
;
use
crate
:
:
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
crate
:
:
ir
:
:
types
:
:
*
;
use
crate
:
:
ir
:
:
{
self
Function
Inst
InstBuilder
}
;
use
crate
:
:
isa
:
:
constraints
:
:
*
;
use
crate
:
:
isa
:
:
enc_tables
:
:
*
;
use
crate
:
:
isa
:
:
encoding
:
:
base_size
;
use
crate
:
:
isa
:
:
encoding
:
:
RecipeSizing
;
use
crate
:
:
isa
:
:
RegUnit
;
use
crate
:
:
isa
:
:
{
self
TargetIsa
}
;
use
crate
:
:
predicates
;
use
crate
:
:
regalloc
:
:
RegDiversions
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
encoding
-
x86
.
rs
"
)
)
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
legalize
-
x86
.
rs
"
)
)
;
pub
fn
needs_sib_byte
(
reg
:
RegUnit
)
-
>
bool
{
reg
=
=
RU
:
:
r12
as
RegUnit
|
|
reg
=
=
RU
:
:
rsp
as
RegUnit
}
pub
fn
needs_offset
(
reg
:
RegUnit
)
-
>
bool
{
reg
=
=
RU
:
:
r13
as
RegUnit
|
|
reg
=
=
RU
:
:
rbp
as
RegUnit
}
pub
fn
needs_sib_byte_or_offset
(
reg
:
RegUnit
)
-
>
bool
{
needs_sib_byte
(
reg
)
|
|
needs_offset
(
reg
)
}
fn
additional_size_if
(
op_index
:
usize
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
condition_func
:
fn
(
RegUnit
)
-
>
bool
)
-
>
u8
{
let
addr_reg
=
divert
.
reg
(
func
.
dfg
.
inst_args
(
inst
)
[
op_index
]
&
func
.
locations
)
;
if
condition_func
(
addr_reg
)
{
1
}
else
{
0
}
}
fn
size_plus_maybe_offset_for_in_reg_0
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
0
inst
divert
func
needs_offset
)
}
fn
size_plus_maybe_offset_for_in_reg_1
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
1
inst
divert
func
needs_offset
)
}
fn
size_plus_maybe_sib_for_in_reg_0
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
0
inst
divert
func
needs_sib_byte
)
}
fn
size_plus_maybe_sib_for_in_reg_1
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
1
inst
divert
func
needs_sib_byte
)
}
fn
size_plus_maybe_sib_or_offset_for_in_reg_0
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
0
inst
divert
func
needs_sib_byte_or_offset
)
}
fn
size_plus_maybe_sib_or_offset_for_in_reg_1
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
1
inst
divert
func
needs_sib_byte_or_offset
)
}
fn
maybe_iconst_imm
(
pos
:
&
FuncCursor
value
:
ir
:
:
Value
)
-
>
Option
<
i64
>
{
if
let
ir
:
:
ValueDef
:
:
Result
(
inst
_
)
=
&
pos
.
func
.
dfg
.
value_def
(
value
)
{
if
let
ir
:
:
InstructionData
:
:
UnaryImm
{
opcode
:
ir
:
:
Opcode
:
:
Iconst
imm
}
=
&
pos
.
func
.
dfg
[
*
inst
]
{
let
value
:
i64
=
(
*
imm
)
.
into
(
)
;
Some
(
value
)
}
else
{
None
}
}
else
{
None
}
}
fn
expand_sdivrem
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
let
(
x
y
is_srem
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Sdiv
args
}
=
>
(
args
[
0
]
args
[
1
]
false
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Srem
args
}
=
>
(
args
[
0
]
args
[
1
]
true
)
_
=
>
panic
!
(
"
Need
sdiv
/
srem
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
let
avoid_div_traps
=
isa
.
flags
(
)
.
avoid_div_traps
(
)
;
if
!
avoid_div_traps
&
&
!
is_srem
{
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
pos
.
ins
(
)
.
with_result
(
result
)
.
x86_sdivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
return
;
}
let
(
could_be_zero
could_be_minus_one
)
=
if
let
Some
(
imm
)
=
maybe_iconst_imm
(
&
pos
y
)
{
(
imm
=
=
0
imm
=
=
-
1
)
}
else
{
(
true
true
)
}
;
if
avoid_div_traps
&
&
could_be_zero
{
pos
.
ins
(
)
.
trapz
(
y
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
)
;
}
if
!
could_be_minus_one
{
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
let
reuse
=
if
is_srem
{
[
None
Some
(
result
)
]
}
else
{
[
Some
(
result
)
None
]
}
;
pos
.
ins
(
)
.
with_results
(
reuse
)
.
x86_sdivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
return
;
}
let
nominal
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
let
minus_one
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
let
done
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
pos
.
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
is_m1
=
pos
.
ins
(
)
.
ifcmp_imm
(
y
-
1
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
Equal
is_m1
minus_one
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
nominal
&
[
]
)
;
pos
.
insert_ebb
(
nominal
)
;
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
let
(
quot
rem
)
=
pos
.
ins
(
)
.
x86_sdivmodx
(
x
xhi
y
)
;
let
divres
=
if
is_srem
{
rem
}
else
{
quot
}
;
pos
.
ins
(
)
.
jump
(
done
&
[
divres
]
)
;
pos
.
insert_ebb
(
minus_one
)
;
let
m1_result
=
if
is_srem
{
pos
.
ins
(
)
.
iconst
(
ty
0
)
}
else
{
debug_assert
!
(
avoid_div_traps
"
Native
trapping
divide
handled
above
"
)
;
let
f
=
pos
.
ins
(
)
.
ifcmp_imm
(
x
-
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
trapif
(
IntCC
:
:
Equal
f
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
ins
(
)
.
irsub_imm
(
x
0
)
}
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
m1_result
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
nominal
)
;
cfg
.
recompute_ebb
(
pos
.
func
minus_one
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_udivrem
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
let
(
x
y
is_urem
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Udiv
args
}
=
>
(
args
[
0
]
args
[
1
]
false
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Urem
args
}
=
>
(
args
[
0
]
args
[
1
]
true
)
_
=
>
panic
!
(
"
Need
udiv
/
urem
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
avoid_div_traps
=
isa
.
flags
(
)
.
avoid_div_traps
(
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
if
avoid_div_traps
{
let
zero_check
=
if
let
Some
(
imm
)
=
maybe_iconst_imm
(
&
pos
y
)
{
imm
=
=
0
}
else
{
true
}
;
if
zero_check
{
pos
.
ins
(
)
.
trapz
(
y
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
)
;
}
}
let
xhi
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
reuse
=
if
is_urem
{
[
None
Some
(
result
)
]
}
else
{
[
Some
(
result
)
None
]
}
;
pos
.
ins
(
)
.
with_results
(
reuse
)
.
x86_udivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
}
fn
expand_minmax
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
(
x
y
x86_opc
bitwise_opc
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Fmin
args
}
=
>
(
args
[
0
]
args
[
1
]
ir
:
:
Opcode
:
:
X86Fmin
ir
:
:
Opcode
:
:
Bor
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Fmax
args
}
=
>
(
args
[
0
]
args
[
1
]
ir
:
:
Opcode
:
:
X86Fmax
ir
:
:
Opcode
:
:
Band
)
_
=
>
panic
!
(
"
Expected
fmin
/
fmax
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
one_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
uno_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
ueq_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
eq_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
cmp_ueq
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
UnorderedOrEqual
x
y
)
;
pos
.
ins
(
)
.
brnz
(
cmp_ueq
ueq_ebb
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
one_ebb
&
[
]
)
;
pos
.
insert_ebb
(
one_ebb
)
;
let
one_inst
=
pos
.
ins
(
)
.
Binary
(
x86_opc
ty
x
y
)
.
0
;
let
one_result
=
pos
.
func
.
dfg
.
first_result
(
one_inst
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
one_result
]
)
;
pos
.
insert_ebb
(
uno_ebb
)
;
let
uno_result
=
pos
.
ins
(
)
.
fadd
(
x
y
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
uno_result
]
)
;
pos
.
insert_ebb
(
ueq_ebb
)
;
let
cmp_uno
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
y
)
;
pos
.
ins
(
)
.
brnz
(
cmp_uno
uno_ebb
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
eq_ebb
&
[
]
)
;
pos
.
insert_ebb
(
eq_ebb
)
;
let
bw_inst
=
pos
.
ins
(
)
.
Binary
(
bitwise_opc
ty
x
y
)
.
0
;
let
bw_result
=
pos
.
func
.
dfg
.
first_result
(
bw_inst
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
bw_result
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
one_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
uno_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
ueq_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
eq_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_from_uint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
x
;
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtFromUint
arg
}
=
>
x
=
arg
_
=
>
panic
!
(
"
Need
fcvt_from_uint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
match
xty
{
ir
:
:
types
:
:
I8
|
ir
:
:
types
:
:
I16
|
ir
:
:
types
:
:
I32
=
>
{
let
wide
=
pos
.
ins
(
)
.
uextend
(
ir
:
:
types
:
:
I64
x
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
fcvt_from_sint
(
ty
wide
)
;
return
;
}
ir
:
:
types
:
:
I64
=
>
{
}
_
=
>
unimplemented
!
(
)
}
let
old_ebb
=
pos
.
func
.
layout
.
pp_ebb
(
inst
)
;
let
poszero_ebb
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
let
neg_ebb
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
let
done
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
pos
.
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
is_neg
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
SignedLessThan
x
0
)
;
pos
.
ins
(
)
.
brnz
(
is_neg
neg_ebb
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
poszero_ebb
&
[
]
)
;
pos
.
insert_ebb
(
poszero_ebb
)
;
let
posres
=
pos
.
ins
(
)
.
fcvt_from_sint
(
ty
x
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
posres
]
)
;
pos
.
insert_ebb
(
neg_ebb
)
;
let
ihalf
=
pos
.
ins
(
)
.
ushr_imm
(
x
1
)
;
let
lsb
=
pos
.
ins
(
)
.
band_imm
(
x
1
)
;
let
ifinal
=
pos
.
ins
(
)
.
bor
(
ihalf
lsb
)
;
let
fhalf
=
pos
.
ins
(
)
.
fcvt_from_sint
(
ty
ifinal
)
;
let
negres
=
pos
.
ins
(
)
.
fadd
(
fhalf
fhalf
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
negres
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
poszero_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
neg_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_sint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToSint
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_sint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
let
maybe_trap_ebb
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
replace
(
inst
)
.
x86_cvtt2si
(
ty
x
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
after_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
is_done
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
NotEqual
result
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
brnz
(
is_done
done
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
maybe_trap_ebb
&
[
]
)
;
pos
.
insert_ebb
(
maybe_trap_ebb
)
;
let
is_nan
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
x
)
;
pos
.
ins
(
)
.
trapnz
(
is_nan
ir
:
:
TrapCode
:
:
BadConversionToInteger
)
;
let
mut
overflow_cc
=
FloatCC
:
:
LessThan
;
let
output_bits
=
ty
.
lane_bits
(
)
;
let
flimit
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
{
pos
.
ins
(
)
.
f32const
(
if
output_bits
<
32
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee32
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
ir
:
:
types
:
:
F64
=
>
{
pos
.
ins
(
)
.
f64const
(
if
output_bits
<
64
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
overflow_cc
x
flimit
)
;
pos
.
ins
(
)
.
trapnz
(
overflow
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
let
fzero
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
GreaterThanOrEqual
x
fzero
)
;
pos
.
ins
(
)
.
trapnz
(
overflow
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
]
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
maybe_trap_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_sint_sat
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToSintSat
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_sint_sat
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
done_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
intmin_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
minsat_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
maxsat_ebb
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done_ebb
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
cvtt2si
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_done
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
NotEqual
cvtt2si
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
brnz
(
is_done
done_ebb
&
[
cvtt2si
]
)
;
pos
.
ins
(
)
.
jump
(
intmin_ebb
&
[
]
)
;
pos
.
insert_ebb
(
intmin_ebb
)
;
let
zero
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
is_nan
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
x
)
;
pos
.
ins
(
)
.
brnz
(
is_nan
done_ebb
&
[
zero
]
)
;
pos
.
ins
(
)
.
jump
(
minsat_ebb
&
[
]
)
;
pos
.
insert_ebb
(
minsat_ebb
)
;
let
mut
overflow_cc
=
FloatCC
:
:
LessThan
;
let
output_bits
=
ty
.
lane_bits
(
)
;
let
flimit
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
{
pos
.
ins
(
)
.
f32const
(
if
output_bits
<
32
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee32
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
ir
:
:
types
:
:
F64
=
>
{
pos
.
ins
(
)
.
f64const
(
if
output_bits
<
64
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
overflow_cc
x
flimit
)
;
let
min_imm
=
match
ty
{
ir
:
:
types
:
:
I32
=
>
i32
:
:
min_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
i64
:
:
min_value
(
)
_
=
>
panic
!
(
"
Don
'
t
know
the
min
value
for
{
}
"
ty
)
}
;
let
min_value
=
pos
.
ins
(
)
.
iconst
(
ty
min_imm
)
;
pos
.
ins
(
)
.
brnz
(
overflow
done_ebb
&
[
min_value
]
)
;
pos
.
ins
(
)
.
jump
(
maxsat_ebb
&
[
]
)
;
pos
.
insert_ebb
(
maxsat_ebb
)
;
let
fzero
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
max_imm
=
match
ty
{
ir
:
:
types
:
:
I32
=
>
i32
:
:
max_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
i64
:
:
max_value
(
)
_
=
>
panic
!
(
"
Don
'
t
know
the
max
value
for
{
}
"
ty
)
}
;
let
max_value
=
pos
.
ins
(
)
.
iconst
(
ty
max_imm
)
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
GreaterThanOrEqual
x
fzero
)
;
pos
.
ins
(
)
.
brnz
(
overflow
done_ebb
&
[
max_value
]
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done_ebb
&
[
cvtt2si
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
intmin_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
minsat_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
maxsat_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done_ebb
)
;
}
fn
expand_fcvt_to_uint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToUint
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_uint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
below_uint_max_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
below_zero_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
large
=
func
.
dfg
.
make_ebb
(
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
pow2nm1
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
is_large
=
pos
.
ins
(
)
.
ffcmp
(
x
pow2nm1
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
GreaterThanOrEqual
is_large
large
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
below_uint_max_ebb
&
[
]
)
;
pos
.
insert_ebb
(
below_uint_max_ebb
)
;
pos
.
ins
(
)
.
trapff
(
FloatCC
:
:
Unordered
is_large
ir
:
:
TrapCode
:
:
BadConversionToInteger
)
;
let
sres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
sres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedGreaterThanOrEqual
is_neg
done
&
[
sres
]
)
;
pos
.
ins
(
)
.
jump
(
below_zero_ebb
&
[
]
)
;
pos
.
insert_ebb
(
below_zero_ebb
)
;
pos
.
ins
(
)
.
trap
(
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
insert_ebb
(
large
)
;
let
adjx
=
pos
.
ins
(
)
.
fsub
(
x
pow2nm1
)
;
let
lres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
adjx
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
lres
0
)
;
pos
.
ins
(
)
.
trapif
(
IntCC
:
:
SignedLessThan
is_neg
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
let
lfinal
=
pos
.
ins
(
)
.
iadd_imm
(
lres
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
lfinal
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
below_uint_max_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
below_zero_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
large
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_uint_sat
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToUintSat
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_uint_sat
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
below_pow2nm1_or_nan_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
below_pow2nm1_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
large
=
func
.
dfg
.
make_ebb
(
)
;
let
uint_large_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
pow2nm1
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
zero
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
is_large
=
pos
.
ins
(
)
.
ffcmp
(
x
pow2nm1
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
GreaterThanOrEqual
is_large
large
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
below_pow2nm1_or_nan_ebb
&
[
]
)
;
pos
.
insert_ebb
(
below_pow2nm1_or_nan_ebb
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
Unordered
is_large
done
&
[
zero
]
)
;
pos
.
ins
(
)
.
jump
(
below_pow2nm1_ebb
&
[
]
)
;
pos
.
insert_ebb
(
below_pow2nm1_ebb
)
;
let
sres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
sres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedGreaterThanOrEqual
is_neg
done
&
[
sres
]
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
zero
]
)
;
pos
.
insert_ebb
(
large
)
;
let
adjx
=
pos
.
ins
(
)
.
fsub
(
x
pow2nm1
)
;
let
lres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
adjx
)
;
let
max_value
=
pos
.
ins
(
)
.
iconst
(
ty
match
ty
{
ir
:
:
types
:
:
I32
=
>
u32
:
:
max_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
u64
:
:
max_value
(
)
as
i64
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
ty
)
}
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
lres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedLessThan
is_neg
done
&
[
max_value
]
)
;
pos
.
ins
(
)
.
jump
(
uint_large_ebb
&
[
]
)
;
pos
.
insert_ebb
(
uint_large_ebb
)
;
let
lfinal
=
pos
.
ins
(
)
.
iadd_imm
(
lres
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
lfinal
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
below_pow2nm1_or_nan_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
below_pow2nm1_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
large
)
;
cfg
.
recompute_ebb
(
pos
.
func
uint_large_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
convert_shuffle
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
Shuffle
{
args
mask
.
.
}
=
pos
.
func
.
dfg
[
inst
]
{
let
zero_unknown_lane_index
=
|
b
:
u8
|
if
b
>
15
{
0b10000000
}
else
{
b
}
;
let
a
=
pos
.
func
.
dfg
.
resolve_aliases
(
args
[
0
]
)
;
let
b
=
pos
.
func
.
dfg
.
resolve_aliases
(
args
[
1
]
)
;
let
mask
=
pos
.
func
.
dfg
.
immediates
.
get
(
mask
)
.
expect
(
"
The
shuffle
immediate
should
have
been
recorded
before
this
point
"
)
.
clone
(
)
;
if
a
=
=
b
{
let
constructed_mask
=
mask
.
iter
(
)
.
map
(
|
&
b
|
if
b
>
15
{
b
.
wrapping_sub
(
16
)
}
else
{
b
}
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
handle
=
pos
.
func
.
dfg
.
constants
.
insert
(
constructed_mask
)
;
let
a_type
=
pos
.
func
.
dfg
.
value_type
(
a
)
;
let
mask_value
=
pos
.
ins
(
)
.
vconst
(
a_type
handle
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_pshufb
(
a
mask_value
)
;
}
else
{
let
constructed_mask
=
mask
.
iter
(
)
.
cloned
(
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
handle
=
pos
.
func
.
dfg
.
constants
.
insert
(
constructed_mask
)
;
let
a_type
=
pos
.
func
.
dfg
.
value_type
(
a
)
;
let
mask_value
=
pos
.
ins
(
)
.
vconst
(
a_type
handle
)
;
let
shuffled_first_arg
=
pos
.
ins
(
)
.
x86_pshufb
(
a
mask_value
)
;
let
constructed_mask
=
mask
.
iter
(
)
.
map
(
|
b
|
b
.
wrapping_sub
(
16
)
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
handle
=
pos
.
func
.
dfg
.
constants
.
insert
(
constructed_mask
)
;
let
b_type
=
pos
.
func
.
dfg
.
value_type
(
b
)
;
let
mask_value
=
pos
.
ins
(
)
.
vconst
(
b_type
handle
)
;
let
shuffled_second_arg
=
pos
.
ins
(
)
.
x86_pshufb
(
b
mask_value
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
bor
(
shuffled_first_arg
shuffled_second_arg
)
;
}
;
}
}
fn
convert_extractlane
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
ExtractLane
{
opcode
:
ir
:
:
Opcode
:
:
Extractlane
arg
lane
}
=
pos
.
func
.
dfg
[
inst
]
{
let
value_type
=
pos
.
func
.
dfg
.
value_type
(
arg
)
;
if
value_type
.
lane_type
(
)
.
is_float
(
)
{
let
shuffled
=
if
lane
!
=
0
{
match
value_type
{
F32X4
=
>
{
let
shuffle_mask
:
u8
=
0b00_00_00_00
|
lane
;
pos
.
ins
(
)
.
x86_pshufd
(
arg
shuffle_mask
)
}
F64X2
=
>
{
assert_eq
!
(
lane
1
)
;
let
shuffle_mask
=
0b11_10_11_10
;
let
bitcast
=
pos
.
ins
(
)
.
raw_bitcast
(
F32X4
arg
)
;
pos
.
ins
(
)
.
x86_pshufd
(
bitcast
shuffle_mask
)
}
_
=
>
unreachable
!
(
)
}
}
else
{
arg
}
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
raw_bitcast
(
value_type
.
lane_type
(
)
shuffled
)
;
}
else
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_pextr
(
arg
lane
)
;
}
}
}
fn
convert_insertlane
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
InsertLane
{
opcode
:
ir
:
:
Opcode
:
:
Insertlane
args
:
[
vector
replacement
]
lane
}
=
pos
.
func
.
dfg
[
inst
]
{
let
value_type
=
pos
.
func
.
dfg
.
value_type
(
vector
)
;
if
value_type
.
lane_type
(
)
.
is_float
(
)
{
match
value_type
{
F32X4
=
>
{
assert
!
(
lane
>
0
&
&
lane
<
=
3
)
;
let
immediate
=
0b00_00_00_00
|
lane
<
<
4
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_insertps
(
vector
immediate
replacement
)
}
F64X2
=
>
{
let
replacement_as_vector
=
pos
.
ins
(
)
.
raw_bitcast
(
F64X2
replacement
)
;
if
lane
=
=
0
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_movsd
(
vector
replacement_as_vector
)
}
else
{
assert_eq
!
(
lane
1
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_movlhps
(
vector
replacement_as_vector
)
}
}
_
=
>
unreachable
!
(
)
}
;
}
else
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_pinsr
(
vector
lane
replacement
)
;
}
}
}
fn
convert_ineg
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
Ineg
arg
}
=
pos
.
func
.
dfg
[
inst
]
{
let
value_type
=
pos
.
func
.
dfg
.
value_type
(
arg
)
;
if
value_type
.
is_vector
(
)
&
&
value_type
.
lane_type
(
)
.
is_int
(
)
{
let
zero_immediate
=
pos
.
func
.
dfg
.
constants
.
insert
(
vec
!
[
0
;
16
]
.
into
(
)
)
;
let
zero_value
=
pos
.
ins
(
)
.
vconst
(
value_type
zero_immediate
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
isub
(
zero_value
arg
)
;
}
}
}
