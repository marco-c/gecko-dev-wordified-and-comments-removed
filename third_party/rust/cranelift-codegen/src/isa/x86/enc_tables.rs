use
super
:
:
registers
:
:
*
;
use
bitset
:
:
BitSet
;
use
cursor
:
:
{
Cursor
FuncCursor
}
;
use
flowgraph
:
:
ControlFlowGraph
;
use
ir
:
:
condcodes
:
:
IntCC
;
use
ir
:
:
{
self
Function
Inst
InstBuilder
}
;
use
isa
;
use
isa
:
:
constraints
:
:
*
;
use
isa
:
:
enc_tables
:
:
*
;
use
isa
:
:
encoding
:
:
base_size
;
use
isa
:
:
encoding
:
:
RecipeSizing
;
use
isa
:
:
RegUnit
;
use
regalloc
:
:
RegDiversions
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
encoding
-
x86
.
rs
"
)
)
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
legalize
-
x86
.
rs
"
)
)
;
pub
fn
needs_sib_byte
(
reg
:
RegUnit
)
-
>
bool
{
reg
=
=
RU
:
:
r12
as
RegUnit
|
|
reg
=
=
RU
:
:
rsp
as
RegUnit
}
pub
fn
needs_offset
(
reg
:
RegUnit
)
-
>
bool
{
reg
=
=
RU
:
:
r13
as
RegUnit
|
|
reg
=
=
RU
:
:
rbp
as
RegUnit
}
pub
fn
needs_sib_byte_or_offset
(
reg
:
RegUnit
)
-
>
bool
{
needs_sib_byte
(
reg
)
|
|
needs_offset
(
reg
)
}
fn
additional_size_if
(
op_index
:
usize
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
condition_func
:
fn
(
RegUnit
)
-
>
bool
)
-
>
u8
{
let
addr_reg
=
divert
.
reg
(
func
.
dfg
.
inst_args
(
inst
)
[
op_index
]
&
func
.
locations
)
;
if
condition_func
(
addr_reg
)
{
1
}
else
{
0
}
}
fn
size_plus_maybe_offset_for_in_reg_0
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
0
inst
divert
func
needs_offset
)
}
fn
size_plus_maybe_offset_for_in_reg_1
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
1
inst
divert
func
needs_offset
)
}
fn
size_plus_maybe_sib_for_in_reg_0
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
0
inst
divert
func
needs_sib_byte
)
}
fn
size_plus_maybe_sib_for_in_reg_1
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
1
inst
divert
func
needs_sib_byte
)
}
fn
size_plus_maybe_sib_or_offset_for_in_reg_0
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
0
inst
divert
func
needs_sib_byte_or_offset
)
}
fn
size_plus_maybe_sib_or_offset_for_in_reg_1
(
sizing
:
&
RecipeSizing
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
sizing
.
base_size
+
additional_size_if
(
1
inst
divert
func
needs_sib_byte_or_offset
)
}
fn
expand_sdivrem
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
isa
:
&
isa
:
:
TargetIsa
)
{
let
(
x
y
is_srem
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Sdiv
args
}
=
>
(
args
[
0
]
args
[
1
]
false
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Srem
args
}
=
>
(
args
[
0
]
args
[
1
]
true
)
_
=
>
panic
!
(
"
Need
sdiv
/
srem
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
avoid_div_traps
=
isa
.
flags
(
)
.
avoid_div_traps
(
)
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
if
!
avoid_div_traps
&
&
!
is_srem
{
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
pos
.
ins
(
)
.
with_result
(
result
)
.
x86_sdivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
return
;
}
let
minus_one
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
let
done
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
pos
.
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
is_m1
=
pos
.
ins
(
)
.
ifcmp_imm
(
y
-
1
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
Equal
is_m1
minus_one
&
[
]
)
;
if
avoid_div_traps
{
pos
.
ins
(
)
.
trapz
(
y
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
)
;
}
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
let
(
quot
rem
)
=
pos
.
ins
(
)
.
x86_sdivmodx
(
x
xhi
y
)
;
let
divres
=
if
is_srem
{
rem
}
else
{
quot
}
;
pos
.
ins
(
)
.
jump
(
done
&
[
divres
]
)
;
pos
.
insert_ebb
(
minus_one
)
;
let
m1_result
=
if
is_srem
{
pos
.
ins
(
)
.
iconst
(
ty
0
)
}
else
{
debug_assert
!
(
avoid_div_traps
"
Native
trapping
divide
handled
above
"
)
;
let
f
=
pos
.
ins
(
)
.
ifcmp_imm
(
x
-
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
trapif
(
IntCC
:
:
Equal
f
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
ins
(
)
.
irsub_imm
(
x
0
)
}
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
m1_result
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
minus_one
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_udivrem
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
isa
:
:
TargetIsa
)
{
let
(
x
y
is_urem
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Udiv
args
}
=
>
(
args
[
0
]
args
[
1
]
false
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Urem
args
}
=
>
(
args
[
0
]
args
[
1
]
true
)
_
=
>
panic
!
(
"
Need
udiv
/
urem
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
avoid_div_traps
=
isa
.
flags
(
)
.
avoid_div_traps
(
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
if
avoid_div_traps
{
pos
.
ins
(
)
.
trapz
(
y
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
)
;
}
let
xhi
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
reuse
=
if
is_urem
{
[
None
Some
(
result
)
]
}
else
{
[
Some
(
result
)
None
]
}
;
pos
.
ins
(
)
.
with_results
(
reuse
)
.
x86_udivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
}
fn
expand_minmax
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
isa
:
:
TargetIsa
)
{
use
ir
:
:
condcodes
:
:
FloatCC
;
let
(
x
y
x86_opc
bitwise_opc
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Fmin
args
}
=
>
(
args
[
0
]
args
[
1
]
ir
:
:
Opcode
:
:
X86Fmin
ir
:
:
Opcode
:
:
Bor
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Fmax
args
}
=
>
(
args
[
0
]
args
[
1
]
ir
:
:
Opcode
:
:
X86Fmax
ir
:
:
Opcode
:
:
Band
)
_
=
>
panic
!
(
"
Expected
fmin
/
fmax
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
uno_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
ueq_ebb
=
func
.
dfg
.
make_ebb
(
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
cmp_ueq
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
UnorderedOrEqual
x
y
)
;
pos
.
ins
(
)
.
brnz
(
cmp_ueq
ueq_ebb
&
[
]
)
;
let
one_inst
=
pos
.
ins
(
)
.
Binary
(
x86_opc
ty
x
y
)
.
0
;
let
one_result
=
pos
.
func
.
dfg
.
first_result
(
one_inst
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
one_result
]
)
;
pos
.
insert_ebb
(
uno_ebb
)
;
let
uno_result
=
pos
.
ins
(
)
.
fadd
(
x
y
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
uno_result
]
)
;
pos
.
insert_ebb
(
ueq_ebb
)
;
let
cmp_uno
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
y
)
;
pos
.
ins
(
)
.
brnz
(
cmp_uno
uno_ebb
&
[
]
)
;
let
bw_inst
=
pos
.
ins
(
)
.
Binary
(
bitwise_opc
ty
x
y
)
.
0
;
let
bw_result
=
pos
.
func
.
dfg
.
first_result
(
bw_inst
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
bw_result
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
ueq_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
uno_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_from_uint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
isa
:
:
TargetIsa
)
{
use
ir
:
:
condcodes
:
:
IntCC
;
let
x
;
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtFromUint
arg
}
=
>
x
=
arg
_
=
>
panic
!
(
"
Need
fcvt_from_uint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
xty
=
=
ir
:
:
types
:
:
I32
{
let
wide
=
pos
.
ins
(
)
.
uextend
(
ir
:
:
types
:
:
I64
x
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
fcvt_from_sint
(
ty
wide
)
;
return
;
}
let
old_ebb
=
pos
.
func
.
layout
.
pp_ebb
(
inst
)
;
let
neg_ebb
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
let
done
=
pos
.
func
.
dfg
.
make_ebb
(
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
pos
.
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
is_neg
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
SignedLessThan
x
0
)
;
pos
.
ins
(
)
.
brnz
(
is_neg
neg_ebb
&
[
]
)
;
let
posres
=
pos
.
ins
(
)
.
fcvt_from_sint
(
ty
x
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
posres
]
)
;
pos
.
insert_ebb
(
neg_ebb
)
;
let
ihalf
=
pos
.
ins
(
)
.
ushr_imm
(
x
1
)
;
let
lsb
=
pos
.
ins
(
)
.
band_imm
(
x
1
)
;
let
ifinal
=
pos
.
ins
(
)
.
bor
(
ihalf
lsb
)
;
let
fhalf
=
pos
.
ins
(
)
.
fcvt_from_sint
(
ty
ifinal
)
;
let
negres
=
pos
.
ins
(
)
.
fadd
(
fhalf
fhalf
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
negres
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
neg_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_sint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
isa
:
:
TargetIsa
)
{
use
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToSint
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_sint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
replace
(
inst
)
.
x86_cvtt2si
(
ty
x
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
after_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
is_done
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
NotEqual
result
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
brnz
(
is_done
done
&
[
]
)
;
let
is_nan
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
x
)
;
pos
.
ins
(
)
.
trapnz
(
is_nan
ir
:
:
TrapCode
:
:
BadConversionToInteger
)
;
let
mut
overflow_cc
=
FloatCC
:
:
LessThan
;
let
output_bits
=
ty
.
lane_bits
(
)
;
let
flimit
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
{
pos
.
ins
(
)
.
f32const
(
if
output_bits
<
32
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee32
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
ir
:
:
types
:
:
F64
=
>
{
pos
.
ins
(
)
.
f64const
(
if
output_bits
<
64
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
overflow_cc
x
flimit
)
;
pos
.
ins
(
)
.
trapnz
(
overflow
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
let
fzero
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
GreaterThanOrEqual
x
fzero
)
;
pos
.
ins
(
)
.
trapnz
(
overflow
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
]
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_sint_sat
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
isa
:
:
TargetIsa
)
{
use
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToSintSat
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_sint_sat
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
done_ebb
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done_ebb
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
cvtt2si
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_done
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
NotEqual
cvtt2si
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
brnz
(
is_done
done_ebb
&
[
cvtt2si
]
)
;
let
zero
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
is_nan
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
x
)
;
pos
.
ins
(
)
.
brnz
(
is_nan
done_ebb
&
[
zero
]
)
;
let
mut
overflow_cc
=
FloatCC
:
:
LessThan
;
let
output_bits
=
ty
.
lane_bits
(
)
;
let
flimit
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
{
pos
.
ins
(
)
.
f32const
(
if
output_bits
<
32
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee32
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
ir
:
:
types
:
:
F64
=
>
{
pos
.
ins
(
)
.
f64const
(
if
output_bits
<
64
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
overflow_cc
x
flimit
)
;
let
min_imm
=
match
ty
{
ir
:
:
types
:
:
I32
=
>
i32
:
:
min_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
i64
:
:
min_value
(
)
_
=
>
panic
!
(
"
Don
'
t
know
the
min
value
for
{
}
"
ty
)
}
;
let
min_value
=
pos
.
ins
(
)
.
iconst
(
ty
min_imm
)
;
pos
.
ins
(
)
.
brnz
(
overflow
done_ebb
&
[
min_value
]
)
;
let
fzero
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
max_imm
=
match
ty
{
ir
:
:
types
:
:
I32
=
>
i32
:
:
max_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
i64
:
:
max_value
(
)
_
=
>
panic
!
(
"
Don
'
t
know
the
max
value
for
{
}
"
ty
)
}
;
let
max_value
=
pos
.
ins
(
)
.
iconst
(
ty
max_imm
)
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
GreaterThanOrEqual
x
fzero
)
;
pos
.
ins
(
)
.
brnz
(
overflow
done_ebb
&
[
max_value
]
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done_ebb
&
[
cvtt2si
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
done_ebb
)
;
}
fn
expand_fcvt_to_uint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
isa
:
:
TargetIsa
)
{
use
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToUint
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_uint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
large
=
func
.
dfg
.
make_ebb
(
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
pow2nm1
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
is_large
=
pos
.
ins
(
)
.
ffcmp
(
x
pow2nm1
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
GreaterThanOrEqual
is_large
large
&
[
]
)
;
pos
.
ins
(
)
.
trapff
(
FloatCC
:
:
Unordered
is_large
ir
:
:
TrapCode
:
:
BadConversionToInteger
)
;
let
sres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
sres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedGreaterThanOrEqual
is_neg
done
&
[
sres
]
)
;
pos
.
ins
(
)
.
trap
(
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
insert_ebb
(
large
)
;
let
adjx
=
pos
.
ins
(
)
.
fsub
(
x
pow2nm1
)
;
let
lres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
adjx
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
lres
0
)
;
pos
.
ins
(
)
.
trapif
(
IntCC
:
:
SignedLessThan
is_neg
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
let
lfinal
=
pos
.
ins
(
)
.
iadd_imm
(
lres
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
lfinal
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
large
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_uint_sat
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
isa
:
:
TargetIsa
)
{
use
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToUintSat
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_uint_sat
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_ebb
=
func
.
layout
.
pp_ebb
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
large
=
func
.
dfg
.
make_ebb
(
)
;
let
done
=
func
.
dfg
.
make_ebb
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_ebb_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
pow2nm1
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
zero
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
is_large
=
pos
.
ins
(
)
.
ffcmp
(
x
pow2nm1
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
GreaterThanOrEqual
is_large
large
&
[
]
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
Unordered
is_large
done
&
[
zero
]
)
;
let
sres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
sres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedGreaterThanOrEqual
is_neg
done
&
[
sres
]
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
zero
]
)
;
pos
.
insert_ebb
(
large
)
;
let
adjx
=
pos
.
ins
(
)
.
fsub
(
x
pow2nm1
)
;
let
lres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
adjx
)
;
let
max_value
=
pos
.
ins
(
)
.
iconst
(
ty
match
ty
{
ir
:
:
types
:
:
I32
=
>
u32
:
:
max_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
u64
:
:
max_value
(
)
as
i64
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
ty
)
}
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
lres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedLessThan
is_neg
done
&
[
max_value
]
)
;
let
lfinal
=
pos
.
ins
(
)
.
iadd_imm
(
lres
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
lfinal
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_ebb
(
done
)
;
cfg
.
recompute_ebb
(
pos
.
func
old_ebb
)
;
cfg
.
recompute_ebb
(
pos
.
func
large
)
;
cfg
.
recompute_ebb
(
pos
.
func
done
)
;
}
