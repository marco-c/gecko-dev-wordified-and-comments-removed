use
super
:
:
registers
:
:
*
;
use
crate
:
:
bitset
:
:
BitSet
;
use
crate
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
crate
:
:
flowgraph
:
:
ControlFlowGraph
;
use
crate
:
:
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
crate
:
:
ir
:
:
types
:
:
*
;
use
crate
:
:
ir
:
:
{
self
Function
Inst
InstBuilder
MemFlags
}
;
use
crate
:
:
isa
:
:
constraints
:
:
*
;
use
crate
:
:
isa
:
:
enc_tables
:
:
*
;
use
crate
:
:
isa
:
:
encoding
:
:
base_size
;
use
crate
:
:
isa
:
:
encoding
:
:
{
Encoding
RecipeSizing
}
;
use
crate
:
:
isa
:
:
RegUnit
;
use
crate
:
:
isa
:
:
{
self
TargetIsa
}
;
use
crate
:
:
predicates
;
use
crate
:
:
regalloc
:
:
RegDiversions
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
encoding
-
x86
.
rs
"
)
)
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
legalize
-
x86
.
rs
"
)
)
;
pub
fn
is_extended_reg
(
reg
:
RegUnit
)
-
>
bool
{
reg
as
u8
&
0b1000
!
=
0
}
pub
fn
needs_sib_byte
(
reg
:
RegUnit
)
-
>
bool
{
reg
=
=
RU
:
:
r12
as
RegUnit
|
|
reg
=
=
RU
:
:
rsp
as
RegUnit
}
pub
fn
needs_offset
(
reg
:
RegUnit
)
-
>
bool
{
reg
=
=
RU
:
:
r13
as
RegUnit
|
|
reg
=
=
RU
:
:
rbp
as
RegUnit
}
pub
fn
needs_sib_byte_or_offset
(
reg
:
RegUnit
)
-
>
bool
{
needs_sib_byte
(
reg
)
|
|
needs_offset
(
reg
)
}
fn
test_input
(
op_index
:
usize
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
condition_func
:
fn
(
RegUnit
)
-
>
bool
)
-
>
bool
{
let
in_reg
=
divert
.
reg
(
func
.
dfg
.
inst_args
(
inst
)
[
op_index
]
&
func
.
locations
)
;
condition_func
(
in_reg
)
}
fn
test_result
(
result_index
:
usize
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
condition_func
:
fn
(
RegUnit
)
-
>
bool
)
-
>
bool
{
let
out_reg
=
divert
.
reg
(
func
.
dfg
.
inst_results
(
inst
)
[
result_index
]
&
func
.
locations
)
;
condition_func
(
out_reg
)
}
fn
size_plus_maybe_offset_for_inreg_0
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_offset
=
test_input
(
0
inst
divert
func
needs_offset
)
;
sizing
.
base_size
+
if
needs_offset
{
1
}
else
{
0
}
}
fn
size_plus_maybe_offset_for_inreg_1
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_offset
=
test_input
(
1
inst
divert
func
needs_offset
)
;
sizing
.
base_size
+
if
needs_offset
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_for_inreg_0
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_sib
=
test_input
(
0
inst
divert
func
needs_sib_byte
)
;
sizing
.
base_size
+
if
needs_sib
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_for_inreg_1
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_sib
=
test_input
(
1
inst
divert
func
needs_sib_byte
)
;
sizing
.
base_size
+
if
needs_sib
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_or_offset_for_inreg_0
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_sib_or_offset
=
test_input
(
0
inst
divert
func
needs_sib_byte_or_offset
)
;
sizing
.
base_size
+
if
needs_sib_or_offset
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_or_offset_for_inreg_1
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_sib_or_offset
=
test_input
(
1
inst
divert
func
needs_sib_byte_or_offset
)
;
sizing
.
base_size
+
if
needs_sib_or_offset
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_or_offset_inreg1_plus_rex_prefix_for_inreg0_inreg1
(
sizing
:
&
RecipeSizing
enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
|
|
test_input
(
1
inst
divert
func
is_extended_reg
)
;
size_plus_maybe_sib_or_offset_for_inreg_1
(
sizing
enc
inst
divert
func
)
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_inreg1_plus_rex_prefix_for_inreg0_inreg1
(
sizing
:
&
RecipeSizing
enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
|
|
test_input
(
1
inst
divert
func
is_extended_reg
)
;
size_plus_maybe_sib_for_inreg_1
(
sizing
enc
inst
divert
func
)
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_or_offset_for_inreg_0_plus_rex_prefix_for_inreg0_outreg0
(
sizing
:
&
RecipeSizing
enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
|
|
test_result
(
0
inst
divert
func
is_extended_reg
)
;
size_plus_maybe_sib_or_offset_for_inreg_0
(
sizing
enc
inst
divert
func
)
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_plus_maybe_sib_for_inreg_0_plus_rex_prefix_for_inreg0_outreg0
(
sizing
:
&
RecipeSizing
enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
|
|
test_result
(
0
inst
divert
func
is_extended_reg
)
;
size_plus_maybe_sib_for_inreg_0
(
sizing
enc
inst
divert
func
)
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_inreg0
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_inreg1
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
1
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_inreg2
(
sizing
:
&
RecipeSizing
_
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
2
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_inreg0_inreg1
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
|
|
test_input
(
1
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_inreg0_outreg0
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
0
inst
divert
func
is_extended_reg
)
|
|
test_result
(
0
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_outreg0
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_result
(
0
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
size_with_inferred_rex_for_cmov
(
sizing
:
&
RecipeSizing
_enc
:
Encoding
inst
:
Inst
divert
:
&
RegDiversions
func
:
&
Function
)
-
>
u8
{
let
needs_rex
=
test_input
(
1
inst
divert
func
is_extended_reg
)
|
|
test_input
(
2
inst
divert
func
is_extended_reg
)
;
sizing
.
base_size
+
if
needs_rex
{
1
}
else
{
0
}
}
fn
maybe_iconst_imm
(
pos
:
&
FuncCursor
value
:
ir
:
:
Value
)
-
>
Option
<
i64
>
{
if
let
ir
:
:
ValueDef
:
:
Result
(
inst
_
)
=
&
pos
.
func
.
dfg
.
value_def
(
value
)
{
if
let
ir
:
:
InstructionData
:
:
UnaryImm
{
opcode
:
ir
:
:
Opcode
:
:
Iconst
imm
}
=
&
pos
.
func
.
dfg
[
*
inst
]
{
let
value
:
i64
=
(
*
imm
)
.
into
(
)
;
Some
(
value
)
}
else
{
None
}
}
else
{
None
}
}
fn
expand_sdivrem
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
let
(
x
y
is_srem
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Sdiv
args
}
=
>
(
args
[
0
]
args
[
1
]
false
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Srem
args
}
=
>
(
args
[
0
]
args
[
1
]
true
)
_
=
>
panic
!
(
"
Need
sdiv
/
srem
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_block
=
func
.
layout
.
pp_block
(
inst
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
let
avoid_div_traps
=
isa
.
flags
(
)
.
avoid_div_traps
(
)
;
if
!
avoid_div_traps
&
&
!
is_srem
{
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
pos
.
ins
(
)
.
with_result
(
result
)
.
x86_sdivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
return
;
}
let
(
could_be_zero
could_be_minus_one
)
=
if
let
Some
(
imm
)
=
maybe_iconst_imm
(
&
pos
y
)
{
(
imm
=
=
0
imm
=
=
-
1
)
}
else
{
(
true
true
)
}
;
if
avoid_div_traps
&
&
could_be_zero
{
pos
.
ins
(
)
.
trapz
(
y
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
)
;
}
if
!
could_be_minus_one
{
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
let
reuse
=
if
is_srem
{
[
None
Some
(
result
)
]
}
else
{
[
Some
(
result
)
None
]
}
;
pos
.
ins
(
)
.
with_results
(
reuse
)
.
x86_sdivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
return
;
}
let
nominal
=
pos
.
func
.
dfg
.
make_block
(
)
;
let
minus_one
=
pos
.
func
.
dfg
.
make_block
(
)
;
let
done
=
pos
.
func
.
dfg
.
make_block
(
)
;
pos
.
func
.
dfg
.
attach_block_param
(
done
result
)
;
let
is_m1
=
pos
.
ins
(
)
.
ifcmp_imm
(
y
-
1
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
Equal
is_m1
minus_one
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
nominal
&
[
]
)
;
pos
.
insert_block
(
nominal
)
;
let
xhi
=
pos
.
ins
(
)
.
sshr_imm
(
x
i64
:
:
from
(
ty
.
lane_bits
(
)
)
-
1
)
;
let
(
quot
rem
)
=
pos
.
ins
(
)
.
x86_sdivmodx
(
x
xhi
y
)
;
let
divres
=
if
is_srem
{
rem
}
else
{
quot
}
;
pos
.
ins
(
)
.
jump
(
done
&
[
divres
]
)
;
pos
.
insert_block
(
minus_one
)
;
let
m1_result
=
if
is_srem
{
pos
.
ins
(
)
.
iconst
(
ty
0
)
}
else
{
debug_assert
!
(
avoid_div_traps
"
Native
trapping
divide
handled
above
"
)
;
let
f
=
pos
.
ins
(
)
.
ifcmp_imm
(
x
-
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
trapif
(
IntCC
:
:
Equal
f
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
ins
(
)
.
irsub_imm
(
x
0
)
}
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
m1_result
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_block
(
done
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
nominal
)
;
cfg
.
recompute_block
(
pos
.
func
minus_one
)
;
cfg
.
recompute_block
(
pos
.
func
done
)
;
}
fn
expand_udivrem
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
let
(
x
y
is_urem
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Udiv
args
}
=
>
(
args
[
0
]
args
[
1
]
false
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Urem
args
}
=
>
(
args
[
0
]
args
[
1
]
true
)
_
=
>
panic
!
(
"
Need
udiv
/
urem
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
avoid_div_traps
=
isa
.
flags
(
)
.
avoid_div_traps
(
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
if
avoid_div_traps
{
let
zero_check
=
if
let
Some
(
imm
)
=
maybe_iconst_imm
(
&
pos
y
)
{
imm
=
=
0
}
else
{
true
}
;
if
zero_check
{
pos
.
ins
(
)
.
trapz
(
y
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
)
;
}
}
let
xhi
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
reuse
=
if
is_urem
{
[
None
Some
(
result
)
]
}
else
{
[
Some
(
result
)
None
]
}
;
pos
.
ins
(
)
.
with_results
(
reuse
)
.
x86_udivmodx
(
x
xhi
y
)
;
pos
.
remove_inst
(
)
;
}
fn
expand_minmax
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
(
x
y
x86_opc
bitwise_opc
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Fmin
args
}
=
>
(
args
[
0
]
args
[
1
]
ir
:
:
Opcode
:
:
X86Fmin
ir
:
:
Opcode
:
:
Bor
)
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Fmax
args
}
=
>
(
args
[
0
]
args
[
1
]
ir
:
:
Opcode
:
:
X86Fmax
ir
:
:
Opcode
:
:
Band
)
_
=
>
panic
!
(
"
Expected
fmin
/
fmax
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_block
=
func
.
layout
.
pp_block
(
inst
)
;
let
one_block
=
func
.
dfg
.
make_block
(
)
;
let
uno_block
=
func
.
dfg
.
make_block
(
)
;
let
ueq_block
=
func
.
dfg
.
make_block
(
)
;
let
eq_block
=
func
.
dfg
.
make_block
(
)
;
let
done
=
func
.
dfg
.
make_block
(
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_block_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
cmp_ueq
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
UnorderedOrEqual
x
y
)
;
pos
.
ins
(
)
.
brnz
(
cmp_ueq
ueq_block
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
one_block
&
[
]
)
;
pos
.
insert_block
(
one_block
)
;
let
one_inst
=
pos
.
ins
(
)
.
Binary
(
x86_opc
ty
x
y
)
.
0
;
let
one_result
=
pos
.
func
.
dfg
.
first_result
(
one_inst
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
one_result
]
)
;
pos
.
insert_block
(
uno_block
)
;
let
uno_result
=
pos
.
ins
(
)
.
fadd
(
x
y
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
uno_result
]
)
;
pos
.
insert_block
(
ueq_block
)
;
let
cmp_uno
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
y
)
;
pos
.
ins
(
)
.
brnz
(
cmp_uno
uno_block
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
eq_block
&
[
]
)
;
pos
.
insert_block
(
eq_block
)
;
let
bw_inst
=
pos
.
ins
(
)
.
Binary
(
bitwise_opc
ty
x
y
)
.
0
;
let
bw_result
=
pos
.
func
.
dfg
.
first_result
(
bw_inst
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
bw_result
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_block
(
done
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
one_block
)
;
cfg
.
recompute_block
(
pos
.
func
uno_block
)
;
cfg
.
recompute_block
(
pos
.
func
ueq_block
)
;
cfg
.
recompute_block
(
pos
.
func
eq_block
)
;
cfg
.
recompute_block
(
pos
.
func
done
)
;
}
fn
expand_fcvt_from_uint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
x
;
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtFromUint
arg
}
=
>
x
=
arg
_
=
>
panic
!
(
"
Need
fcvt_from_uint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
match
xty
{
ir
:
:
types
:
:
I8
|
ir
:
:
types
:
:
I16
|
ir
:
:
types
:
:
I32
=
>
{
let
wide
=
pos
.
ins
(
)
.
uextend
(
ir
:
:
types
:
:
I64
x
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
fcvt_from_sint
(
ty
wide
)
;
return
;
}
ir
:
:
types
:
:
I64
=
>
{
}
_
=
>
unimplemented
!
(
)
}
let
old_block
=
pos
.
func
.
layout
.
pp_block
(
inst
)
;
let
poszero_block
=
pos
.
func
.
dfg
.
make_block
(
)
;
let
neg_block
=
pos
.
func
.
dfg
.
make_block
(
)
;
let
done
=
pos
.
func
.
dfg
.
make_block
(
)
;
pos
.
func
.
dfg
.
clear_results
(
inst
)
;
pos
.
func
.
dfg
.
attach_block_param
(
done
result
)
;
let
is_neg
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
SignedLessThan
x
0
)
;
pos
.
ins
(
)
.
brnz
(
is_neg
neg_block
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
poszero_block
&
[
]
)
;
pos
.
insert_block
(
poszero_block
)
;
let
posres
=
pos
.
ins
(
)
.
fcvt_from_sint
(
ty
x
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
posres
]
)
;
pos
.
insert_block
(
neg_block
)
;
let
ihalf
=
pos
.
ins
(
)
.
ushr_imm
(
x
1
)
;
let
lsb
=
pos
.
ins
(
)
.
band_imm
(
x
1
)
;
let
ifinal
=
pos
.
ins
(
)
.
bor
(
ihalf
lsb
)
;
let
fhalf
=
pos
.
ins
(
)
.
fcvt_from_sint
(
ty
ifinal
)
;
let
negres
=
pos
.
ins
(
)
.
fadd
(
fhalf
fhalf
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
negres
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_block
(
done
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
poszero_block
)
;
cfg
.
recompute_block
(
pos
.
func
neg_block
)
;
cfg
.
recompute_block
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_sint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToSint
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_sint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_block
=
func
.
layout
.
pp_block
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
done
=
func
.
dfg
.
make_block
(
)
;
let
maybe_trap_block
=
func
.
dfg
.
make_block
(
)
;
func
.
dfg
.
replace
(
inst
)
.
x86_cvtt2si
(
ty
x
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
after_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
is_done
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
NotEqual
result
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
brnz
(
is_done
done
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
maybe_trap_block
&
[
]
)
;
pos
.
insert_block
(
maybe_trap_block
)
;
let
is_nan
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
x
)
;
pos
.
ins
(
)
.
trapnz
(
is_nan
ir
:
:
TrapCode
:
:
BadConversionToInteger
)
;
let
mut
overflow_cc
=
FloatCC
:
:
LessThan
;
let
output_bits
=
ty
.
lane_bits
(
)
;
let
flimit
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
{
pos
.
ins
(
)
.
f32const
(
if
output_bits
<
32
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee32
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
ir
:
:
types
:
:
F64
=
>
{
pos
.
ins
(
)
.
f64const
(
if
output_bits
<
64
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
overflow_cc
x
flimit
)
;
pos
.
ins
(
)
.
trapnz
(
overflow
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
let
fzero
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
GreaterThanOrEqual
x
fzero
)
;
pos
.
ins
(
)
.
trapnz
(
overflow
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
]
)
;
pos
.
insert_block
(
done
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
maybe_trap_block
)
;
cfg
.
recompute_block
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_sint_sat
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToSintSat
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_sint_sat
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_block
=
func
.
layout
.
pp_block
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
done_block
=
func
.
dfg
.
make_block
(
)
;
let
intmin_block
=
func
.
dfg
.
make_block
(
)
;
let
minsat_block
=
func
.
dfg
.
make_block
(
)
;
let
maxsat_block
=
func
.
dfg
.
make_block
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_block_param
(
done_block
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
cvtt2si
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_done
=
pos
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
NotEqual
cvtt2si
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
ins
(
)
.
brnz
(
is_done
done_block
&
[
cvtt2si
]
)
;
pos
.
ins
(
)
.
jump
(
intmin_block
&
[
]
)
;
pos
.
insert_block
(
intmin_block
)
;
let
zero
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
is_nan
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
Unordered
x
x
)
;
pos
.
ins
(
)
.
brnz
(
is_nan
done_block
&
[
zero
]
)
;
pos
.
ins
(
)
.
jump
(
minsat_block
&
[
]
)
;
pos
.
insert_block
(
minsat_block
)
;
let
mut
overflow_cc
=
FloatCC
:
:
LessThan
;
let
output_bits
=
ty
.
lane_bits
(
)
;
let
flimit
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
{
pos
.
ins
(
)
.
f32const
(
if
output_bits
<
32
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee32
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee32
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
ir
:
:
types
:
:
F64
=
>
{
pos
.
ins
(
)
.
f64const
(
if
output_bits
<
64
{
overflow_cc
=
FloatCC
:
:
LessThanOrEqual
;
Ieee64
:
:
fcvt_to_sint_negative_overflow
(
output_bits
)
}
else
{
Ieee64
:
:
pow2
(
output_bits
-
1
)
.
neg
(
)
}
)
}
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
overflow_cc
x
flimit
)
;
let
min_imm
=
match
ty
{
ir
:
:
types
:
:
I32
=
>
i32
:
:
min_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
i64
:
:
min_value
(
)
_
=
>
panic
!
(
"
Don
'
t
know
the
min
value
for
{
}
"
ty
)
}
;
let
min_value
=
pos
.
ins
(
)
.
iconst
(
ty
min_imm
)
;
pos
.
ins
(
)
.
brnz
(
overflow
done_block
&
[
min_value
]
)
;
pos
.
ins
(
)
.
jump
(
maxsat_block
&
[
]
)
;
pos
.
insert_block
(
maxsat_block
)
;
let
fzero
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
with_bits
(
0
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
with_bits
(
0
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
max_imm
=
match
ty
{
ir
:
:
types
:
:
I32
=
>
i32
:
:
max_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
i64
:
:
max_value
(
)
_
=
>
panic
!
(
"
Don
'
t
know
the
max
value
for
{
}
"
ty
)
}
;
let
max_value
=
pos
.
ins
(
)
.
iconst
(
ty
max_imm
)
;
let
overflow
=
pos
.
ins
(
)
.
fcmp
(
FloatCC
:
:
GreaterThanOrEqual
x
fzero
)
;
pos
.
ins
(
)
.
brnz
(
overflow
done_block
&
[
max_value
]
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done_block
&
[
cvtt2si
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_block
(
done_block
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
intmin_block
)
;
cfg
.
recompute_block
(
pos
.
func
minsat_block
)
;
cfg
.
recompute_block
(
pos
.
func
maxsat_block
)
;
cfg
.
recompute_block
(
pos
.
func
done_block
)
;
}
fn
expand_fcvt_to_uint
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToUint
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_uint
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_block
=
func
.
layout
.
pp_block
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
below_uint_max_block
=
func
.
dfg
.
make_block
(
)
;
let
below_zero_block
=
func
.
dfg
.
make_block
(
)
;
let
large
=
func
.
dfg
.
make_block
(
)
;
let
done
=
func
.
dfg
.
make_block
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_block_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
pow2nm1
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
is_large
=
pos
.
ins
(
)
.
ffcmp
(
x
pow2nm1
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
GreaterThanOrEqual
is_large
large
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
below_uint_max_block
&
[
]
)
;
pos
.
insert_block
(
below_uint_max_block
)
;
pos
.
ins
(
)
.
trapff
(
FloatCC
:
:
Unordered
is_large
ir
:
:
TrapCode
:
:
BadConversionToInteger
)
;
let
sres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
sres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedGreaterThanOrEqual
is_neg
done
&
[
sres
]
)
;
pos
.
ins
(
)
.
jump
(
below_zero_block
&
[
]
)
;
pos
.
insert_block
(
below_zero_block
)
;
pos
.
ins
(
)
.
trap
(
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
pos
.
insert_block
(
large
)
;
let
adjx
=
pos
.
ins
(
)
.
fsub
(
x
pow2nm1
)
;
let
lres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
adjx
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
lres
0
)
;
pos
.
ins
(
)
.
trapif
(
IntCC
:
:
SignedLessThan
is_neg
ir
:
:
TrapCode
:
:
IntegerOverflow
)
;
let
lfinal
=
pos
.
ins
(
)
.
iadd_imm
(
lres
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
lfinal
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_block
(
done
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
below_uint_max_block
)
;
cfg
.
recompute_block
(
pos
.
func
below_zero_block
)
;
cfg
.
recompute_block
(
pos
.
func
large
)
;
cfg
.
recompute_block
(
pos
.
func
done
)
;
}
fn
expand_fcvt_to_uint_sat
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
ir
:
:
immediates
:
:
{
Ieee32
Ieee64
}
;
let
x
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
FcvtToUintSat
arg
}
=
>
arg
_
=
>
panic
!
(
"
Need
fcvt_to_uint_sat
:
{
}
"
func
.
dfg
.
display_inst
(
inst
None
)
)
}
;
let
old_block
=
func
.
layout
.
pp_block
(
inst
)
;
let
xty
=
func
.
dfg
.
value_type
(
x
)
;
let
result
=
func
.
dfg
.
first_result
(
inst
)
;
let
ty
=
func
.
dfg
.
value_type
(
result
)
;
let
below_pow2nm1_or_nan_block
=
func
.
dfg
.
make_block
(
)
;
let
below_pow2nm1_block
=
func
.
dfg
.
make_block
(
)
;
let
large
=
func
.
dfg
.
make_block
(
)
;
let
uint_large_block
=
func
.
dfg
.
make_block
(
)
;
let
done
=
func
.
dfg
.
make_block
(
)
;
func
.
dfg
.
clear_results
(
inst
)
;
func
.
dfg
.
attach_block_param
(
done
result
)
;
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
let
pow2nm1
=
match
xty
{
ir
:
:
types
:
:
F32
=
>
pos
.
ins
(
)
.
f32const
(
Ieee32
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
ir
:
:
types
:
:
F64
=
>
pos
.
ins
(
)
.
f64const
(
Ieee64
:
:
pow2
(
ty
.
lane_bits
(
)
-
1
)
)
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
xty
)
}
;
let
zero
=
pos
.
ins
(
)
.
iconst
(
ty
0
)
;
let
is_large
=
pos
.
ins
(
)
.
ffcmp
(
x
pow2nm1
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
GreaterThanOrEqual
is_large
large
&
[
]
)
;
pos
.
ins
(
)
.
jump
(
below_pow2nm1_or_nan_block
&
[
]
)
;
pos
.
insert_block
(
below_pow2nm1_or_nan_block
)
;
pos
.
ins
(
)
.
brff
(
FloatCC
:
:
Unordered
is_large
done
&
[
zero
]
)
;
pos
.
ins
(
)
.
jump
(
below_pow2nm1_block
&
[
]
)
;
pos
.
insert_block
(
below_pow2nm1_block
)
;
let
sres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
x
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
sres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedGreaterThanOrEqual
is_neg
done
&
[
sres
]
)
;
pos
.
ins
(
)
.
jump
(
done
&
[
zero
]
)
;
pos
.
insert_block
(
large
)
;
let
adjx
=
pos
.
ins
(
)
.
fsub
(
x
pow2nm1
)
;
let
lres
=
pos
.
ins
(
)
.
x86_cvtt2si
(
ty
adjx
)
;
let
max_value
=
pos
.
ins
(
)
.
iconst
(
ty
match
ty
{
ir
:
:
types
:
:
I32
=
>
u32
:
:
max_value
(
)
as
i64
ir
:
:
types
:
:
I64
=
>
u64
:
:
max_value
(
)
as
i64
_
=
>
panic
!
(
"
Can
'
t
convert
{
}
"
ty
)
}
)
;
let
is_neg
=
pos
.
ins
(
)
.
ifcmp_imm
(
lres
0
)
;
pos
.
ins
(
)
.
brif
(
IntCC
:
:
SignedLessThan
is_neg
done
&
[
max_value
]
)
;
pos
.
ins
(
)
.
jump
(
uint_large_block
&
[
]
)
;
pos
.
insert_block
(
uint_large_block
)
;
let
lfinal
=
pos
.
ins
(
)
.
iadd_imm
(
lres
1
<
<
(
ty
.
lane_bits
(
)
-
1
)
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
jump
(
done
&
[
lfinal
]
)
;
pos
.
next_inst
(
)
;
pos
.
insert_block
(
done
)
;
cfg
.
recompute_block
(
pos
.
func
old_block
)
;
cfg
.
recompute_block
(
pos
.
func
below_pow2nm1_or_nan_block
)
;
cfg
.
recompute_block
(
pos
.
func
below_pow2nm1_block
)
;
cfg
.
recompute_block
(
pos
.
func
large
)
;
cfg
.
recompute_block
(
pos
.
func
uint_large_block
)
;
cfg
.
recompute_block
(
pos
.
func
done
)
;
}
fn
convert_shuffle
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
Shuffle
{
args
mask
.
.
}
=
pos
.
func
.
dfg
[
inst
]
{
let
zero_unknown_lane_index
=
|
b
:
u8
|
if
b
>
15
{
0b10000000
}
else
{
b
}
;
let
a
=
pos
.
func
.
dfg
.
resolve_aliases
(
args
[
0
]
)
;
let
b
=
pos
.
func
.
dfg
.
resolve_aliases
(
args
[
1
]
)
;
let
mask
=
pos
.
func
.
dfg
.
immediates
.
get
(
mask
)
.
expect
(
"
The
shuffle
immediate
should
have
been
recorded
before
this
point
"
)
.
clone
(
)
;
if
a
=
=
b
{
let
constructed_mask
=
mask
.
iter
(
)
.
map
(
|
&
b
|
if
b
>
15
{
b
.
wrapping_sub
(
16
)
}
else
{
b
}
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
handle
=
pos
.
func
.
dfg
.
constants
.
insert
(
constructed_mask
)
;
let
a_type
=
pos
.
func
.
dfg
.
value_type
(
a
)
;
let
mask_value
=
pos
.
ins
(
)
.
vconst
(
a_type
handle
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_pshufb
(
a
mask_value
)
;
}
else
{
let
constructed_mask
=
mask
.
iter
(
)
.
cloned
(
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
handle
=
pos
.
func
.
dfg
.
constants
.
insert
(
constructed_mask
)
;
let
a_type
=
pos
.
func
.
dfg
.
value_type
(
a
)
;
let
mask_value
=
pos
.
ins
(
)
.
vconst
(
a_type
handle
)
;
let
shuffled_first_arg
=
pos
.
ins
(
)
.
x86_pshufb
(
a
mask_value
)
;
let
constructed_mask
=
mask
.
iter
(
)
.
map
(
|
b
|
b
.
wrapping_sub
(
16
)
)
.
map
(
zero_unknown_lane_index
)
.
collect
(
)
;
let
handle
=
pos
.
func
.
dfg
.
constants
.
insert
(
constructed_mask
)
;
let
b_type
=
pos
.
func
.
dfg
.
value_type
(
b
)
;
let
mask_value
=
pos
.
ins
(
)
.
vconst
(
b_type
handle
)
;
let
shuffled_second_arg
=
pos
.
ins
(
)
.
x86_pshufb
(
b
mask_value
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
bor
(
shuffled_first_arg
shuffled_second_arg
)
;
}
;
}
}
fn
convert_extractlane
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
ExtractLane
{
opcode
:
ir
:
:
Opcode
:
:
Extractlane
arg
lane
}
=
pos
.
func
.
dfg
[
inst
]
{
let
value_type
=
pos
.
func
.
dfg
.
value_type
(
arg
)
;
if
value_type
.
lane_type
(
)
.
is_float
(
)
{
let
shuffled
=
if
lane
!
=
0
{
match
value_type
{
F32X4
=
>
{
let
shuffle_mask
:
u8
=
0b00_00_00_00
|
lane
;
pos
.
ins
(
)
.
x86_pshufd
(
arg
shuffle_mask
)
}
F64X2
=
>
{
assert_eq
!
(
lane
1
)
;
let
shuffle_mask
=
0b11_10_11_10
;
let
bitcast
=
pos
.
ins
(
)
.
raw_bitcast
(
F32X4
arg
)
;
pos
.
ins
(
)
.
x86_pshufd
(
bitcast
shuffle_mask
)
}
_
=
>
unreachable
!
(
)
}
}
else
{
arg
}
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
raw_bitcast
(
value_type
.
lane_type
(
)
shuffled
)
;
}
else
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_pextr
(
arg
lane
)
;
}
}
}
fn
convert_insertlane
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
InsertLane
{
opcode
:
ir
:
:
Opcode
:
:
Insertlane
args
:
[
vector
replacement
]
lane
}
=
pos
.
func
.
dfg
[
inst
]
{
let
value_type
=
pos
.
func
.
dfg
.
value_type
(
vector
)
;
if
value_type
.
lane_type
(
)
.
is_float
(
)
{
match
value_type
{
F32X4
=
>
{
assert
!
(
lane
<
=
3
)
;
let
immediate
=
0b00_00_00_00
|
lane
<
<
4
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_insertps
(
vector
immediate
replacement
)
}
F64X2
=
>
{
let
replacement_as_vector
=
pos
.
ins
(
)
.
raw_bitcast
(
F64X2
replacement
)
;
if
lane
=
=
0
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_movsd
(
vector
replacement_as_vector
)
}
else
{
assert_eq
!
(
lane
1
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_movlhps
(
vector
replacement_as_vector
)
}
}
_
=
>
unreachable
!
(
)
}
;
}
else
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_pinsr
(
vector
lane
replacement
)
;
}
}
}
fn
convert_ineg
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
_isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
Unary
{
opcode
:
ir
:
:
Opcode
:
:
Ineg
arg
}
=
pos
.
func
.
dfg
[
inst
]
{
let
value_type
=
pos
.
func
.
dfg
.
value_type
(
arg
)
;
let
zero_value
=
if
value_type
.
is_vector
(
)
&
&
value_type
.
lane_type
(
)
.
is_int
(
)
{
let
zero_immediate
=
pos
.
func
.
dfg
.
constants
.
insert
(
vec
!
[
0
;
16
]
.
into
(
)
)
;
pos
.
ins
(
)
.
vconst
(
value_type
zero_immediate
)
}
else
if
value_type
.
is_int
(
)
{
pos
.
ins
(
)
.
iconst
(
value_type
0
)
}
else
{
panic
!
(
"
Can
'
t
convert
ineg
of
type
{
}
"
value_type
)
}
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
isub
(
zero_value
arg
)
;
}
else
{
unreachable
!
(
)
}
}
static
USHR_MASKS
:
[
u8
;
128
]
=
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x7f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x3f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x1f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
]
;
fn
convert_ushr
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Ushr
args
:
[
arg0
arg1
]
}
=
pos
.
func
.
dfg
[
inst
]
{
let
arg0_type
=
pos
.
func
.
dfg
.
value_type
(
arg0
)
;
let
arg1_type
=
pos
.
func
.
dfg
.
value_type
(
arg1
)
;
assert
!
(
!
arg1_type
.
is_vector
(
)
&
&
arg1_type
.
is_int
(
)
)
;
let
shift_index
=
pos
.
ins
(
)
.
bitcast
(
I64X2
arg1
)
;
if
arg0_type
=
=
I8X16
{
let
bitcasted
=
pos
.
ins
(
)
.
raw_bitcast
(
I16X8
arg0
)
;
let
shifted
=
pos
.
ins
(
)
.
x86_psrl
(
bitcasted
shift_index
)
;
let
shifted
=
pos
.
ins
(
)
.
raw_bitcast
(
I8X16
shifted
)
;
let
masks
=
pos
.
func
.
dfg
.
constants
.
insert
(
USHR_MASKS
.
as_ref
(
)
.
into
(
)
)
;
let
mask_address
=
pos
.
ins
(
)
.
const_addr
(
isa
.
pointer_type
(
)
masks
)
;
let
mask_offset
=
pos
.
ins
(
)
.
ishl_imm
(
arg1
4
)
;
let
mask
=
pos
.
ins
(
)
.
load_complex
(
arg0_type
MemFlags
:
:
new
(
)
&
[
mask_address
mask_offset
]
0
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
band
(
shifted
mask
)
;
}
else
if
arg0_type
.
is_vector
(
)
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_psrl
(
arg0
shift_index
)
;
}
else
{
unreachable
!
(
)
}
}
}
static
SHL_MASKS
:
[
u8
;
128
]
=
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfe
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xfc
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf8
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xf0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xe0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0xc0
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
]
;
fn
convert_ishl
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
.
at_inst
(
inst
)
;
pos
.
use_srcloc
(
inst
)
;
if
let
ir
:
:
InstructionData
:
:
Binary
{
opcode
:
ir
:
:
Opcode
:
:
Ishl
args
:
[
arg0
arg1
]
}
=
pos
.
func
.
dfg
[
inst
]
{
let
arg0_type
=
pos
.
func
.
dfg
.
value_type
(
arg0
)
;
let
arg1_type
=
pos
.
func
.
dfg
.
value_type
(
arg1
)
;
assert
!
(
!
arg1_type
.
is_vector
(
)
&
&
arg1_type
.
is_int
(
)
)
;
let
shift_index
=
pos
.
ins
(
)
.
bitcast
(
I64X2
arg1
)
;
if
arg0_type
=
=
I8X16
{
let
bitcasted
=
pos
.
ins
(
)
.
raw_bitcast
(
I16X8
arg0
)
;
let
shifted
=
pos
.
ins
(
)
.
x86_psll
(
bitcasted
shift_index
)
;
let
shifted
=
pos
.
ins
(
)
.
raw_bitcast
(
I8X16
shifted
)
;
let
masks
=
pos
.
func
.
dfg
.
constants
.
insert
(
SHL_MASKS
.
as_ref
(
)
.
into
(
)
)
;
let
mask_address
=
pos
.
ins
(
)
.
const_addr
(
isa
.
pointer_type
(
)
masks
)
;
let
mask_offset
=
pos
.
ins
(
)
.
ishl_imm
(
arg1
4
)
;
let
mask
=
pos
.
ins
(
)
.
load_complex
(
arg0_type
MemFlags
:
:
new
(
)
&
[
mask_address
mask_offset
]
0
)
;
pos
.
func
.
dfg
.
replace
(
inst
)
.
band
(
shifted
mask
)
;
}
else
if
arg0_type
.
is_vector
(
)
{
pos
.
func
.
dfg
.
replace
(
inst
)
.
x86_psll
(
arg0
shift_index
)
;
}
else
{
unreachable
!
(
)
}
}
}
fn
expand_tls_value
(
inst
:
ir
:
:
Inst
func
:
&
mut
ir
:
:
Function
_cfg
:
&
mut
ControlFlowGraph
isa
:
&
dyn
TargetIsa
)
{
use
crate
:
:
settings
:
:
TlsModel
;
assert
!
(
isa
.
triple
(
)
.
architecture
=
=
target_lexicon
:
:
Architecture
:
:
X86_64
"
Not
yet
implemented
for
{
:
?
}
"
isa
.
triple
(
)
)
;
if
let
ir
:
:
InstructionData
:
:
UnaryGlobalValue
{
opcode
:
ir
:
:
Opcode
:
:
TlsValue
global_value
}
=
func
.
dfg
[
inst
]
{
let
ctrl_typevar
=
func
.
dfg
.
ctrl_typevar
(
inst
)
;
assert_eq
!
(
ctrl_typevar
ir
:
:
types
:
:
I64
)
;
match
isa
.
flags
(
)
.
tls_model
(
)
{
TlsModel
:
:
None
=
>
panic
!
(
"
tls_model
flag
is
not
set
.
"
)
TlsModel
:
:
ElfGd
=
>
{
func
.
dfg
.
replace
(
inst
)
.
x86_elf_tls_get_addr
(
global_value
)
;
}
TlsModel
:
:
Macho
=
>
{
func
.
dfg
.
replace
(
inst
)
.
x86_macho_tls_get_addr
(
global_value
)
;
}
model
=
>
unimplemented
!
(
"
tls_value
for
tls
model
{
:
?
}
"
model
)
}
}
else
{
unreachable
!
(
)
;
}
}
