use
super
:
:
enc_tables
:
:
{
needs_offset
needs_sib_byte
}
;
use
super
:
:
registers
:
:
RU
;
use
crate
:
:
binemit
:
:
{
bad_encoding
CodeSink
Reloc
}
;
use
crate
:
:
ir
:
:
condcodes
:
:
{
CondCode
FloatCC
IntCC
}
;
use
crate
:
:
ir
:
:
{
Ebb
Function
Inst
InstructionData
JumpTable
Opcode
TrapCode
}
;
use
crate
:
:
isa
:
:
{
RegUnit
StackBase
StackBaseMask
StackRef
}
;
use
crate
:
:
regalloc
:
:
RegDiversions
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
binemit
-
x86
.
rs
"
)
)
;
fn
stk_base
(
base
:
StackBase
)
-
>
RegUnit
{
let
ru
=
match
base
{
StackBase
:
:
SP
=
>
RU
:
:
rsp
StackBase
:
:
FP
=
>
RU
:
:
rbp
StackBase
:
:
Zone
=
>
unimplemented
!
(
)
}
;
ru
as
RegUnit
}
const
PREFIX
:
[
u8
;
3
]
=
[
0x66
0xf3
0xf2
]
;
const
OP3_BYTE2
:
[
u8
;
2
]
=
[
0x38
0x3a
]
;
const
BASE_REX
:
u8
=
0b0100_0000
;
fn
rex1
(
reg_b
:
RegUnit
)
-
>
u8
{
let
b
=
(
(
reg_b
>
>
3
)
&
1
)
as
u8
;
BASE_REX
|
b
}
fn
rex2
(
rm
:
RegUnit
reg
:
RegUnit
)
-
>
u8
{
let
b
=
(
(
rm
>
>
3
)
&
1
)
as
u8
;
let
r
=
(
(
reg
>
>
3
)
&
1
)
as
u8
;
BASE_REX
|
b
|
(
r
<
<
2
)
}
fn
rex3
(
rm
:
RegUnit
reg
:
RegUnit
index
:
RegUnit
)
-
>
u8
{
let
b
=
(
(
rm
>
>
3
)
&
1
)
as
u8
;
let
r
=
(
(
reg
>
>
3
)
&
1
)
as
u8
;
let
x
=
(
(
index
>
>
3
)
&
1
)
as
u8
;
BASE_REX
|
b
|
(
x
<
<
1
)
|
(
r
<
<
2
)
}
fn
rex_prefix
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
rex
&
0xf8
BASE_REX
)
;
let
w
=
(
(
bits
>
>
15
)
&
1
)
as
u8
;
sink
.
put1
(
rex
|
(
w
<
<
3
)
)
;
}
fn
put_op1
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x8f00
0
"
Invalid
encoding
bits
for
Op1
*
"
)
;
debug_assert_eq
!
(
rex
BASE_REX
"
Invalid
registers
for
REX
-
less
Op1
encoding
"
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_rexop1
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x0f00
0
"
Invalid
encoding
bits
for
Op1
*
"
)
;
rex_prefix
(
bits
rex
sink
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_op2
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x8f00
0x0400
"
Invalid
encoding
bits
for
Op2
*
"
)
;
debug_assert_eq
!
(
rex
BASE_REX
"
Invalid
registers
for
REX
-
less
Op2
encoding
"
)
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_rexop2
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x0f00
0x0400
"
Invalid
encoding
bits
for
RexOp2
*
"
)
;
rex_prefix
(
bits
rex
sink
)
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_mp1
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x8c00
0
"
Invalid
encoding
bits
for
Mp1
*
"
)
;
let
pp
=
(
bits
>
>
8
)
&
3
;
sink
.
put1
(
PREFIX
[
(
pp
-
1
)
as
usize
]
)
;
debug_assert_eq
!
(
rex
BASE_REX
"
Invalid
registers
for
REX
-
less
Mp1
encoding
"
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_rexmp1
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x0c00
0
"
Invalid
encoding
bits
for
Mp1
*
"
)
;
let
pp
=
(
bits
>
>
8
)
&
3
;
sink
.
put1
(
PREFIX
[
(
pp
-
1
)
as
usize
]
)
;
rex_prefix
(
bits
rex
sink
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_mp2
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x8c00
0x0400
"
Invalid
encoding
bits
for
Mp2
*
"
)
;
let
pp
=
(
bits
>
>
8
)
&
3
;
sink
.
put1
(
PREFIX
[
(
pp
-
1
)
as
usize
]
)
;
debug_assert_eq
!
(
rex
BASE_REX
"
Invalid
registers
for
REX
-
less
Mp2
encoding
"
)
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_rexmp2
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x0c00
0x0400
"
Invalid
encoding
bits
for
Mp2
*
"
)
;
let
pp
=
(
bits
>
>
8
)
&
3
;
sink
.
put1
(
PREFIX
[
(
pp
-
1
)
as
usize
]
)
;
rex_prefix
(
bits
rex
sink
)
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_mp3
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x8800
0x0800
"
Invalid
encoding
bits
for
Mp3
*
"
)
;
let
pp
=
(
bits
>
>
8
)
&
3
;
sink
.
put1
(
PREFIX
[
(
pp
-
1
)
as
usize
]
)
;
debug_assert_eq
!
(
rex
BASE_REX
"
Invalid
registers
for
REX
-
less
Mp3
encoding
"
)
;
let
mm
=
(
bits
>
>
10
)
&
3
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
OP3_BYTE2
[
(
mm
-
2
)
as
usize
]
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
put_rexmp3
<
CS
:
CodeSink
+
?
Sized
>
(
bits
:
u16
rex
:
u8
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
bits
&
0x0800
0x0800
"
Invalid
encoding
bits
for
Mp3
*
"
)
;
let
pp
=
(
bits
>
>
8
)
&
3
;
sink
.
put1
(
PREFIX
[
(
pp
-
1
)
as
usize
]
)
;
rex_prefix
(
bits
rex
sink
)
;
let
mm
=
(
bits
>
>
10
)
&
3
;
sink
.
put1
(
0x0f
)
;
sink
.
put1
(
OP3_BYTE2
[
(
mm
-
2
)
as
usize
]
)
;
sink
.
put1
(
bits
as
u8
)
;
}
fn
modrm_rr
<
CS
:
CodeSink
+
?
Sized
>
(
rm
:
RegUnit
reg
:
RegUnit
sink
:
&
mut
CS
)
{
let
reg
=
reg
as
u8
&
7
;
let
rm
=
rm
as
u8
&
7
;
let
mut
b
=
0b11000000
;
b
|
=
reg
<
<
3
;
b
|
=
rm
;
sink
.
put1
(
b
)
;
}
fn
modrm_r_bits
<
CS
:
CodeSink
+
?
Sized
>
(
rm
:
RegUnit
bits
:
u16
sink
:
&
mut
CS
)
{
let
reg
=
(
bits
>
>
12
)
as
u8
&
7
;
let
rm
=
rm
as
u8
&
7
;
let
mut
b
=
0b11000000
;
b
|
=
reg
<
<
3
;
b
|
=
rm
;
sink
.
put1
(
b
)
;
}
fn
modrm_rm
<
CS
:
CodeSink
+
?
Sized
>
(
rm
:
RegUnit
reg
:
RegUnit
sink
:
&
mut
CS
)
{
let
reg
=
reg
as
u8
&
7
;
let
rm
=
rm
as
u8
&
7
;
let
mut
b
=
0b00000000
;
b
|
=
reg
<
<
3
;
b
|
=
rm
;
sink
.
put1
(
b
)
;
}
fn
modrm_riprel
<
CS
:
CodeSink
+
?
Sized
>
(
reg
:
RegUnit
sink
:
&
mut
CS
)
{
modrm_rm
(
0b101
reg
sink
)
}
fn
modrm_disp8
<
CS
:
CodeSink
+
?
Sized
>
(
rm
:
RegUnit
reg
:
RegUnit
sink
:
&
mut
CS
)
{
let
reg
=
reg
as
u8
&
7
;
let
rm
=
rm
as
u8
&
7
;
let
mut
b
=
0b01000000
;
b
|
=
reg
<
<
3
;
b
|
=
rm
;
sink
.
put1
(
b
)
;
}
fn
modrm_disp32
<
CS
:
CodeSink
+
?
Sized
>
(
rm
:
RegUnit
reg
:
RegUnit
sink
:
&
mut
CS
)
{
let
reg
=
reg
as
u8
&
7
;
let
rm
=
rm
as
u8
&
7
;
let
mut
b
=
0b10000000
;
b
|
=
reg
<
<
3
;
b
|
=
rm
;
sink
.
put1
(
b
)
;
}
fn
modrm_sib
<
CS
:
CodeSink
+
?
Sized
>
(
reg
:
RegUnit
sink
:
&
mut
CS
)
{
modrm_rm
(
0b100
reg
sink
)
;
}
fn
modrm_sib_disp8
<
CS
:
CodeSink
+
?
Sized
>
(
reg
:
RegUnit
sink
:
&
mut
CS
)
{
modrm_disp8
(
0b100
reg
sink
)
;
}
fn
modrm_sib_disp32
<
CS
:
CodeSink
+
?
Sized
>
(
reg
:
RegUnit
sink
:
&
mut
CS
)
{
modrm_disp32
(
0b100
reg
sink
)
;
}
fn
sib_noindex
<
CS
:
CodeSink
+
?
Sized
>
(
base
:
RegUnit
sink
:
&
mut
CS
)
{
let
base
=
base
as
u8
&
7
;
let
mut
b
=
0b00_100_000
;
b
|
=
base
;
sink
.
put1
(
b
)
;
}
fn
sib
<
CS
:
CodeSink
+
?
Sized
>
(
scale
:
u8
index
:
RegUnit
base
:
RegUnit
sink
:
&
mut
CS
)
{
debug_assert_eq
!
(
scale
&
!
0x03
0
"
Scale
out
of
range
"
)
;
let
scale
=
scale
&
3
;
let
index
=
index
as
u8
&
7
;
let
base
=
base
as
u8
&
7
;
let
b
:
u8
=
(
scale
<
<
6
)
|
(
index
<
<
3
)
|
base
;
sink
.
put1
(
b
)
;
}
fn
icc2opc
(
cond
:
IntCC
)
-
>
u16
{
use
crate
:
:
ir
:
:
condcodes
:
:
IntCC
:
:
*
;
match
cond
{
UnsignedLessThan
=
>
0x2
UnsignedGreaterThanOrEqual
=
>
0x3
Equal
=
>
0x4
NotEqual
=
>
0x5
UnsignedLessThanOrEqual
=
>
0x6
UnsignedGreaterThan
=
>
0x7
SignedLessThan
=
>
0xc
SignedGreaterThanOrEqual
=
>
0xd
SignedLessThanOrEqual
=
>
0xe
SignedGreaterThan
=
>
0xf
}
}
fn
fcc2opc
(
cond
:
FloatCC
)
-
>
u16
{
use
crate
:
:
ir
:
:
condcodes
:
:
FloatCC
:
:
*
;
match
cond
{
Ordered
=
>
0xb
Unordered
=
>
0xa
OrderedNotEqual
=
>
0x5
UnorderedOrEqual
=
>
0x4
GreaterThan
=
>
0x7
GreaterThanOrEqual
=
>
0x3
UnorderedOrLessThan
=
>
0x2
UnorderedOrLessThanOrEqual
=
>
0x6
Equal
|
NotEqual
|
LessThan
|
LessThanOrEqual
|
UnorderedOrGreaterThan
|
UnorderedOrGreaterThanOrEqual
=
>
panic
!
(
"
{
}
not
supported
"
cond
)
}
}
fn
disp1
<
CS
:
CodeSink
+
?
Sized
>
(
destination
:
Ebb
func
:
&
Function
sink
:
&
mut
CS
)
{
let
delta
=
func
.
offsets
[
destination
]
.
wrapping_sub
(
sink
.
offset
(
)
+
1
)
;
sink
.
put1
(
delta
as
u8
)
;
}
fn
disp4
<
CS
:
CodeSink
+
?
Sized
>
(
destination
:
Ebb
func
:
&
Function
sink
:
&
mut
CS
)
{
let
delta
=
func
.
offsets
[
destination
]
.
wrapping_sub
(
sink
.
offset
(
)
+
4
)
;
sink
.
put4
(
delta
)
;
}
fn
jt_disp4
<
CS
:
CodeSink
+
?
Sized
>
(
jt
:
JumpTable
func
:
&
Function
sink
:
&
mut
CS
)
{
let
delta
=
func
.
jt_offsets
[
jt
]
.
wrapping_sub
(
sink
.
offset
(
)
+
4
)
;
sink
.
put4
(
delta
)
;
}
