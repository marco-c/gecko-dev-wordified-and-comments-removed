use
crate
:
:
ffi_utils
:
:
buffer
:
:
{
tzname_buf
MAX_LEN
}
;
pub
(
crate
)
fn
get_timezone_inner
(
)
-
>
Result
<
String
crate
:
:
GetTimezoneError
>
{
get_timezone
(
)
.
ok_or
(
crate
:
:
GetTimezoneError
:
:
OsError
)
}
#
[
inline
]
fn
get_timezone
(
)
-
>
Option
<
String
>
{
let
mut
buf
=
tzname_buf
(
)
;
let
tz
=
system_time_zone
:
:
SystemTimeZone
:
:
new
(
)
?
;
let
name
=
tz
.
name
(
)
?
;
let
name
=
if
let
Some
(
name
)
=
name
.
as_utf8
(
)
{
name
}
else
{
name
.
to_utf8
(
&
mut
buf
)
?
}
;
if
name
.
is_empty
(
)
|
|
name
.
len
(
)
>
MAX_LEN
{
None
}
else
{
Some
(
name
.
to_owned
(
)
)
}
}
mod
system_time_zone
{
use
core_foundation_sys
:
:
base
:
:
{
CFRelease
CFTypeRef
}
;
use
core_foundation_sys
:
:
timezone
:
:
{
CFTimeZoneCopySystem
CFTimeZoneGetName
CFTimeZoneRef
CFTimeZoneResetSystem
}
;
pub
(
crate
)
struct
SystemTimeZone
(
CFTimeZoneRef
)
;
impl
Drop
for
SystemTimeZone
{
fn
drop
(
&
mut
self
)
{
unsafe
{
CFRelease
(
self
.
0
as
CFTypeRef
)
}
;
}
}
impl
SystemTimeZone
{
pub
(
crate
)
fn
new
(
)
-
>
Option
<
Self
>
{
let
v
:
CFTimeZoneRef
=
unsafe
{
CFTimeZoneResetSystem
(
)
;
CFTimeZoneCopySystem
(
)
}
;
if
v
.
is_null
(
)
{
None
}
else
{
Some
(
SystemTimeZone
(
v
)
)
}
}
pub
(
crate
)
fn
name
(
&
self
)
-
>
Option
<
super
:
:
string_ref
:
:
StringRef
<
'
_
Self
>
>
{
let
string
=
unsafe
{
CFTimeZoneGetName
(
self
.
0
)
}
;
if
string
.
is_null
(
)
{
None
}
else
{
Some
(
unsafe
{
super
:
:
string_ref
:
:
StringRef
:
:
new
(
string
self
)
}
)
}
}
}
}
mod
string_ref
{
use
core
:
:
convert
:
:
TryInto
;
use
core_foundation_sys
:
:
base
:
:
{
Boolean
CFRange
}
;
use
core_foundation_sys
:
:
string
:
:
{
kCFStringEncodingUTF8
CFStringGetBytes
CFStringGetCStringPtr
CFStringGetLength
CFStringRef
}
;
pub
(
crate
)
struct
StringRef
<
'
a
T
>
{
string
:
CFStringRef
_parent
:
&
'
a
T
}
impl
<
'
a
T
>
StringRef
<
'
a
T
>
{
pub
(
crate
)
unsafe
fn
new
(
string
:
CFStringRef
_parent
:
&
'
a
T
)
-
>
Self
{
Self
{
string
_parent
}
}
pub
(
crate
)
fn
as_utf8
(
&
self
)
-
>
Option
<
&
'
a
str
>
{
let
v
=
unsafe
{
CFStringGetCStringPtr
(
self
.
string
kCFStringEncodingUTF8
)
}
;
if
!
v
.
is_null
(
)
{
let
v
=
unsafe
{
std
:
:
ffi
:
:
CStr
:
:
from_ptr
(
v
)
}
;
if
let
Ok
(
v
)
=
v
.
to_str
(
)
{
return
Some
(
v
)
;
}
}
None
}
pub
(
crate
)
fn
to_utf8
<
'
b
>
(
&
self
buf
:
&
'
b
mut
[
u8
]
)
-
>
Option
<
&
'
b
str
>
{
let
length
=
unsafe
{
CFStringGetLength
(
self
.
string
)
}
;
let
mut
buf_bytes
=
0
;
let
range
=
CFRange
{
location
:
0
length
}
;
let
converted_bytes
=
unsafe
{
CFStringGetBytes
(
self
.
string
range
kCFStringEncodingUTF8
b
'
\
0
'
false
as
Boolean
buf
.
as_mut_ptr
(
)
buf
.
len
(
)
as
isize
&
mut
buf_bytes
)
}
;
if
converted_bytes
!
=
length
{
return
None
;
}
let
len
=
buf_bytes
.
try_into
(
)
.
ok
(
)
?
;
let
s
=
buf
.
get
(
.
.
len
)
?
;
std
:
:
str
:
:
from_utf8
(
s
)
.
ok
(
)
}
}
}
