#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
tokio
-
current
-
thread
/
0
.
1
.
7
"
)
]
#
!
[
deny
(
missing_docs
missing_debug_implementations
)
]
extern
crate
futures
;
extern
crate
tokio_executor
;
mod
scheduler
;
use
self
:
:
scheduler
:
:
Scheduler
;
use
tokio_executor
:
:
park
:
:
{
Park
ParkThread
Unpark
}
;
use
tokio_executor
:
:
{
Enter
SpawnError
}
;
use
futures
:
:
future
:
:
{
ExecuteError
ExecuteErrorKind
Executor
}
;
use
futures
:
:
{
executor
Async
Future
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
{
atomic
mpsc
Arc
}
;
use
std
:
:
thread
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
pub
struct
CurrentThread
<
P
:
Park
=
ParkThread
>
{
scheduler
:
Scheduler
<
P
:
:
Unpark
>
num_futures
:
Arc
<
atomic
:
:
AtomicUsize
>
park
:
P
spawn_handle
:
Handle
spawn_receiver
:
mpsc
:
:
Receiver
<
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
>
>
id
:
u64
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TaskExecutor
{
_p
:
:
:
std
:
:
marker
:
:
PhantomData
<
Rc
<
(
)
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
Turn
{
polled
:
bool
}
impl
Turn
{
pub
fn
has_polled
(
&
self
)
-
>
bool
{
self
.
polled
}
}
pub
struct
Entered
<
'
a
P
:
Park
+
'
a
>
{
executor
:
&
'
a
mut
CurrentThread
<
P
>
enter
:
&
'
a
mut
Enter
}
#
[
derive
(
Debug
)
]
pub
struct
RunError
{
_p
:
(
)
}
impl
fmt
:
:
Display
for
RunError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
self
.
description
(
)
)
}
}
impl
Error
for
RunError
{
fn
description
(
&
self
)
-
>
&
str
{
"
Run
error
"
}
}
#
[
derive
(
Debug
)
]
pub
struct
RunTimeoutError
{
timeout
:
bool
}
impl
fmt
:
:
Display
for
RunTimeoutError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
self
.
description
(
)
)
}
}
impl
Error
for
RunTimeoutError
{
fn
description
(
&
self
)
-
>
&
str
{
if
self
.
timeout
{
"
Run
timeout
error
(
timeout
)
"
}
else
{
"
Run
timeout
error
(
not
timeout
)
"
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
TurnError
{
_p
:
(
)
}
impl
fmt
:
:
Display
for
TurnError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
self
.
description
(
)
)
}
}
impl
Error
for
TurnError
{
fn
description
(
&
self
)
-
>
&
str
{
"
Turn
error
"
}
}
#
[
derive
(
Debug
)
]
pub
struct
BlockError
<
T
>
{
inner
:
Option
<
T
>
}
impl
<
T
>
fmt
:
:
Display
for
BlockError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
Block
error
"
)
}
}
impl
<
T
:
fmt
:
:
Debug
>
Error
for
BlockError
<
T
>
{
fn
description
(
&
self
)
-
>
&
str
{
"
Block
error
"
}
}
struct
Borrow
<
'
a
U
:
'
a
>
{
id
:
u64
scheduler
:
&
'
a
mut
Scheduler
<
U
>
num_futures
:
&
'
a
atomic
:
:
AtomicUsize
}
trait
SpawnLocal
{
fn
spawn_local
(
&
mut
self
future
:
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
>
already_counted
:
bool
)
;
}
struct
CurrentRunner
{
spawn
:
Cell
<
Option
<
*
mut
dyn
SpawnLocal
>
>
id
:
Cell
<
Option
<
u64
>
>
}
thread_local
!
{
/
/
/
Current
thread
'
s
task
runner
.
This
is
set
in
TaskRunner
:
:
with
static
CURRENT
:
CurrentRunner
=
CurrentRunner
{
spawn
:
Cell
:
:
new
(
None
)
id
:
Cell
:
:
new
(
None
)
}
}
thread_local
!
{
/
/
/
Unique
ID
to
assign
to
each
new
executor
launched
on
this
thread
.
/
/
/
/
/
/
The
unique
ID
is
used
to
determine
if
the
currently
running
executor
matches
the
one
/
/
/
referred
to
by
a
Handle
so
that
direct
task
dispatch
can
be
used
.
static
EXECUTOR_ID
:
Cell
<
u64
>
=
Cell
:
:
new
(
0
)
}
pub
fn
block_on_all
<
F
>
(
future
:
F
)
-
>
Result
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
{
let
mut
current_thread
=
CurrentThread
:
:
new
(
)
;
let
ret
=
current_thread
.
block_on
(
future
)
;
current_thread
.
run
(
)
.
unwrap
(
)
;
ret
.
map_err
(
|
e
|
e
.
into_inner
(
)
.
expect
(
"
unexpected
execution
error
"
)
)
}
pub
fn
spawn
<
F
>
(
future
:
F
)
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
TaskExecutor
:
:
current
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
)
.
unwrap
(
)
;
}
impl
CurrentThread
<
ParkThread
>
{
pub
fn
new
(
)
-
>
Self
{
CurrentThread
:
:
new_with_park
(
ParkThread
:
:
new
(
)
)
}
}
impl
<
P
:
Park
>
CurrentThread
<
P
>
{
pub
fn
new_with_park
(
park
:
P
)
-
>
Self
{
let
unpark
=
park
.
unpark
(
)
;
let
(
spawn_sender
spawn_receiver
)
=
mpsc
:
:
channel
(
)
;
let
thread
=
thread
:
:
current
(
)
.
id
(
)
;
let
id
=
EXECUTOR_ID
.
with
(
|
idc
|
{
let
id
=
idc
.
get
(
)
;
idc
.
set
(
id
+
1
)
;
id
}
)
;
let
scheduler
=
Scheduler
:
:
new
(
unpark
)
;
let
notify
=
scheduler
.
notify
(
)
;
let
num_futures
=
Arc
:
:
new
(
atomic
:
:
AtomicUsize
:
:
new
(
0
)
)
;
CurrentThread
{
scheduler
:
scheduler
num_futures
:
num_futures
.
clone
(
)
park
id
spawn_handle
:
Handle
{
sender
:
spawn_sender
num_futures
:
num_futures
notify
:
notify
shut_down
:
Cell
:
:
new
(
false
)
thread
:
thread
id
}
spawn_receiver
:
spawn_receiver
}
}
pub
fn
is_idle
(
&
self
)
-
>
bool
{
self
.
num_futures
.
load
(
atomic
:
:
Ordering
:
:
SeqCst
)
<
=
1
}
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
self
.
borrow
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
false
)
;
self
}
pub
fn
block_on
<
F
>
(
&
mut
self
future
:
F
)
-
>
Result
<
F
:
:
Item
BlockError
<
F
:
:
Error
>
>
where
F
:
Future
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
failed
to
start
current_thread
:
:
Runtime
"
)
;
self
.
enter
(
&
mut
enter
)
.
block_on
(
future
)
}
pub
fn
run
(
&
mut
self
)
-
>
Result
<
(
)
RunError
>
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
failed
to
start
current_thread
:
:
Runtime
"
)
;
self
.
enter
(
&
mut
enter
)
.
run
(
)
}
pub
fn
run_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
RunTimeoutError
>
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
failed
to
start
current_thread
:
:
Runtime
"
)
;
self
.
enter
(
&
mut
enter
)
.
run_timeout
(
duration
)
}
pub
fn
turn
(
&
mut
self
duration
:
Option
<
Duration
>
)
-
>
Result
<
Turn
TurnError
>
{
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
failed
to
start
current_thread
:
:
Runtime
"
)
;
self
.
enter
(
&
mut
enter
)
.
turn
(
duration
)
}
pub
fn
enter
<
'
a
>
(
&
'
a
mut
self
enter
:
&
'
a
mut
Enter
)
-
>
Entered
<
'
a
P
>
{
Entered
{
executor
:
self
enter
}
}
pub
fn
get_park
(
&
self
)
-
>
&
P
{
&
self
.
park
}
pub
fn
get_park_mut
(
&
mut
self
)
-
>
&
mut
P
{
&
mut
self
.
park
}
fn
borrow
(
&
mut
self
)
-
>
Borrow
<
P
:
:
Unpark
>
{
Borrow
{
id
:
self
.
id
scheduler
:
&
mut
self
.
scheduler
num_futures
:
&
*
self
.
num_futures
}
}
pub
fn
handle
(
&
self
)
-
>
Handle
{
self
.
spawn_handle
.
clone
(
)
}
}
impl
<
P
:
Park
>
Drop
for
CurrentThread
<
P
>
{
fn
drop
(
&
mut
self
)
{
let
pending
=
self
.
num_futures
.
fetch_add
(
1
atomic
:
:
Ordering
:
:
SeqCst
)
;
let
_
=
pending
;
}
}
impl
tokio_executor
:
:
Executor
for
CurrentThread
{
fn
spawn
(
&
mut
self
future
:
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
SpawnError
>
{
self
.
borrow
(
)
.
spawn_local
(
future
false
)
;
Ok
(
(
)
)
}
}
impl
<
T
>
tokio_executor
:
:
TypedExecutor
<
T
>
for
CurrentThread
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
fn
spawn
(
&
mut
self
future
:
T
)
-
>
Result
<
(
)
SpawnError
>
{
self
.
borrow
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
false
)
;
Ok
(
(
)
)
}
}
impl
<
P
:
Park
>
fmt
:
:
Debug
for
CurrentThread
<
P
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
CurrentThread
"
)
.
field
(
"
scheduler
"
&
self
.
scheduler
)
.
field
(
"
num_futures
"
&
self
.
num_futures
.
load
(
atomic
:
:
Ordering
:
:
SeqCst
)
)
.
finish
(
)
}
}
impl
<
'
a
P
:
Park
>
Entered
<
'
a
P
>
{
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
self
.
executor
.
borrow
(
)
.
spawn_local
(
Box
:
:
new
(
future
)
false
)
;
self
}
pub
fn
block_on
<
F
>
(
&
mut
self
future
:
F
)
-
>
Result
<
F
:
:
Item
BlockError
<
F
:
:
Error
>
>
where
F
:
Future
{
let
mut
future
=
executor
:
:
spawn
(
future
)
;
let
notify
=
self
.
executor
.
scheduler
.
notify
(
)
;
loop
{
let
res
=
self
.
executor
.
borrow
(
)
.
enter
(
self
.
enter
|
|
future
.
poll_future_notify
(
&
notify
0
)
)
;
match
res
{
Ok
(
Async
:
:
Ready
(
e
)
)
=
>
return
Ok
(
e
)
Err
(
e
)
=
>
return
Err
(
BlockError
{
inner
:
Some
(
e
)
}
)
Ok
(
Async
:
:
NotReady
)
=
>
{
}
}
self
.
tick
(
)
;
if
let
Err
(
_
)
=
self
.
executor
.
park
.
park
(
)
{
return
Err
(
BlockError
{
inner
:
None
}
)
;
}
}
}
pub
fn
run
(
&
mut
self
)
-
>
Result
<
(
)
RunError
>
{
self
.
run_timeout2
(
None
)
.
map_err
(
|
_
|
RunError
{
_p
:
(
)
}
)
}
pub
fn
run_timeout
(
&
mut
self
duration
:
Duration
)
-
>
Result
<
(
)
RunTimeoutError
>
{
self
.
run_timeout2
(
Some
(
duration
)
)
}
pub
fn
turn
(
&
mut
self
duration
:
Option
<
Duration
>
)
-
>
Result
<
Turn
TurnError
>
{
let
res
=
if
self
.
executor
.
scheduler
.
has_pending_futures
(
)
{
self
.
executor
.
park
.
park_timeout
(
Duration
:
:
from_millis
(
0
)
)
}
else
{
match
duration
{
Some
(
duration
)
=
>
self
.
executor
.
park
.
park_timeout
(
duration
)
None
=
>
self
.
executor
.
park
.
park
(
)
}
}
;
if
res
.
is_err
(
)
{
return
Err
(
TurnError
{
_p
:
(
)
}
)
;
}
let
polled
=
self
.
tick
(
)
;
Ok
(
Turn
{
polled
}
)
}
pub
fn
get_park
(
&
self
)
-
>
&
P
{
&
self
.
executor
.
park
}
pub
fn
get_park_mut
(
&
mut
self
)
-
>
&
mut
P
{
&
mut
self
.
executor
.
park
}
fn
run_timeout2
(
&
mut
self
dur
:
Option
<
Duration
>
)
-
>
Result
<
(
)
RunTimeoutError
>
{
if
self
.
executor
.
is_idle
(
)
{
return
Ok
(
(
)
)
;
}
let
mut
time
=
dur
.
map
(
|
dur
|
(
Instant
:
:
now
(
)
+
dur
dur
)
)
;
loop
{
self
.
tick
(
)
;
if
self
.
executor
.
is_idle
(
)
{
return
Ok
(
(
)
)
;
}
match
time
{
Some
(
(
until
rem
)
)
=
>
{
if
let
Err
(
_
)
=
self
.
executor
.
park
.
park_timeout
(
rem
)
{
return
Err
(
RunTimeoutError
:
:
new
(
false
)
)
;
}
let
now
=
Instant
:
:
now
(
)
;
if
now
>
=
until
{
return
Err
(
RunTimeoutError
:
:
new
(
true
)
)
;
}
time
=
Some
(
(
until
until
-
now
)
)
;
}
None
=
>
{
if
let
Err
(
_
)
=
self
.
executor
.
park
.
park
(
)
{
return
Err
(
RunTimeoutError
:
:
new
(
false
)
)
;
}
}
}
}
}
fn
tick
(
&
mut
self
)
-
>
bool
{
let
(
mut
borrow
spawn_receiver
)
=
(
Borrow
{
id
:
self
.
executor
.
id
scheduler
:
&
mut
self
.
executor
.
scheduler
num_futures
:
&
*
self
.
executor
.
num_futures
}
&
mut
self
.
executor
.
spawn_receiver
)
;
while
let
Ok
(
future
)
=
spawn_receiver
.
try_recv
(
)
{
borrow
.
spawn_local
(
future
true
)
;
}
borrow
.
scheduler
.
tick
(
borrow
.
id
&
mut
*
self
.
enter
borrow
.
num_futures
)
}
}
impl
<
'
a
P
:
Park
>
fmt
:
:
Debug
for
Entered
<
'
a
P
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Entered
"
)
.
field
(
"
executor
"
&
self
.
executor
)
.
field
(
"
enter
"
&
self
.
enter
)
.
finish
(
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Handle
{
sender
:
mpsc
:
:
Sender
<
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
>
>
num_futures
:
Arc
<
atomic
:
:
AtomicUsize
>
shut_down
:
Cell
<
bool
>
notify
:
executor
:
:
NotifyHandle
thread
:
thread
:
:
ThreadId
id
:
u64
}
impl
fmt
:
:
Debug
for
Handle
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Handle
"
)
.
field
(
"
shut_down
"
&
self
.
shut_down
.
get
(
)
)
.
finish
(
)
}
}
impl
Handle
{
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
Result
<
(
)
SpawnError
>
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
if
thread
:
:
current
(
)
.
id
(
)
=
=
self
.
thread
{
let
mut
e
=
TaskExecutor
:
:
current
(
)
;
if
e
.
id
(
)
=
=
Some
(
self
.
id
)
{
return
e
.
spawn_local
(
Box
:
:
new
(
future
)
)
;
}
}
if
self
.
shut_down
.
get
(
)
{
return
Err
(
SpawnError
:
:
shutdown
(
)
)
;
}
let
pending
=
self
.
num_futures
.
fetch_add
(
2
atomic
:
:
Ordering
:
:
SeqCst
)
;
if
pending
%
2
=
=
1
{
self
.
num_futures
.
fetch_sub
(
2
atomic
:
:
Ordering
:
:
SeqCst
)
;
self
.
shut_down
.
set
(
true
)
;
return
Err
(
SpawnError
:
:
shutdown
(
)
)
;
}
self
.
sender
.
send
(
Box
:
:
new
(
future
)
)
.
expect
(
"
CurrentThread
does
not
exist
anymore
"
)
;
self
.
notify
.
notify
(
0
)
;
Ok
(
(
)
)
}
pub
fn
status
(
&
self
)
-
>
Result
<
(
)
SpawnError
>
{
if
self
.
shut_down
.
get
(
)
{
return
Err
(
SpawnError
:
:
shutdown
(
)
)
;
}
Ok
(
(
)
)
}
}
impl
TaskExecutor
{
pub
fn
current
(
)
-
>
TaskExecutor
{
TaskExecutor
{
_p
:
:
:
std
:
:
marker
:
:
PhantomData
}
}
fn
id
(
&
self
)
-
>
Option
<
u64
>
{
CURRENT
.
with
(
|
current
|
current
.
id
.
get
(
)
)
}
pub
fn
spawn_local
(
&
mut
self
future
:
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
>
)
-
>
Result
<
(
)
SpawnError
>
{
CURRENT
.
with
(
|
current
|
match
current
.
spawn
.
get
(
)
{
Some
(
spawn
)
=
>
{
unsafe
{
(
*
spawn
)
.
spawn_local
(
future
false
)
}
;
Ok
(
(
)
)
}
None
=
>
Err
(
SpawnError
:
:
shutdown
(
)
)
}
)
}
}
impl
tokio_executor
:
:
Executor
for
TaskExecutor
{
fn
spawn
(
&
mut
self
future
:
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
>
)
-
>
Result
<
(
)
SpawnError
>
{
self
.
spawn_local
(
future
)
}
}
impl
<
F
>
tokio_executor
:
:
TypedExecutor
<
F
>
for
TaskExecutor
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
fn
spawn
(
&
mut
self
future
:
F
)
-
>
Result
<
(
)
SpawnError
>
{
self
.
spawn_local
(
Box
:
:
new
(
future
)
)
}
}
impl
<
F
>
Executor
<
F
>
for
TaskExecutor
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
fn
execute
(
&
self
future
:
F
)
-
>
Result
<
(
)
ExecuteError
<
F
>
>
{
CURRENT
.
with
(
|
current
|
match
current
.
spawn
.
get
(
)
{
Some
(
spawn
)
=
>
{
unsafe
{
(
*
spawn
)
.
spawn_local
(
Box
:
:
new
(
future
)
false
)
}
;
Ok
(
(
)
)
}
None
=
>
Err
(
ExecuteError
:
:
new
(
ExecuteErrorKind
:
:
Shutdown
future
)
)
}
)
}
}
impl
<
'
a
U
:
Unpark
>
Borrow
<
'
a
U
>
{
fn
enter
<
F
R
>
(
&
mut
self
_
:
&
mut
Enter
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
CURRENT
.
with
(
|
current
|
{
current
.
id
.
set
(
Some
(
self
.
id
)
)
;
current
.
set_spawn
(
self
|
|
f
(
)
)
}
)
}
}
impl
<
'
a
U
:
Unpark
>
SpawnLocal
for
Borrow
<
'
a
U
>
{
fn
spawn_local
(
&
mut
self
future
:
Box
<
dyn
Future
<
Item
=
(
)
Error
=
(
)
>
>
already_counted
:
bool
)
{
if
!
already_counted
{
self
.
num_futures
.
fetch_add
(
2
atomic
:
:
Ordering
:
:
SeqCst
)
;
}
self
.
scheduler
.
schedule
(
future
)
;
}
}
impl
CurrentRunner
{
fn
set_spawn
<
F
R
>
(
&
self
spawn
:
&
mut
dyn
SpawnLocal
f
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
struct
Reset
<
'
a
>
(
&
'
a
CurrentRunner
)
;
impl
<
'
a
>
Drop
for
Reset
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
spawn
.
set
(
None
)
;
self
.
0
.
id
.
set
(
None
)
;
}
}
let
_reset
=
Reset
(
self
)
;
let
spawn
=
unsafe
{
hide_lt
(
spawn
as
*
mut
dyn
SpawnLocal
)
}
;
self
.
spawn
.
set
(
Some
(
spawn
)
)
;
f
(
)
}
}
unsafe
fn
hide_lt
<
'
a
>
(
p
:
*
mut
(
dyn
SpawnLocal
+
'
a
)
)
-
>
*
mut
(
dyn
SpawnLocal
+
'
static
)
{
use
std
:
:
mem
;
mem
:
:
transmute
(
p
)
}
impl
RunTimeoutError
{
fn
new
(
timeout
:
bool
)
-
>
Self
{
RunTimeoutError
{
timeout
}
}
pub
fn
is_timeout
(
&
self
)
-
>
bool
{
self
.
timeout
}
}
impl
From
<
tokio_executor
:
:
EnterError
>
for
RunTimeoutError
{
fn
from
(
_
:
tokio_executor
:
:
EnterError
)
-
>
Self
{
RunTimeoutError
:
:
new
(
false
)
}
}
impl
<
T
>
BlockError
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
Option
<
T
>
{
self
.
inner
}
}
impl
<
T
>
From
<
tokio_executor
:
:
EnterError
>
for
BlockError
<
T
>
{
fn
from
(
_
:
tokio_executor
:
:
EnterError
)
-
>
Self
{
BlockError
{
inner
:
None
}
}
}
