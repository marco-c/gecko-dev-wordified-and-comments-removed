pub
mod
CFloatFPU
{
const
sc_uBinaryFloatSmallMax
:
u32
=
0x497ffff0
;
fn
LargeRound
(
x
:
f32
)
-
>
i32
{
#
[
cfg
(
target_feature
=
"
sse2
"
)
]
unsafe
{
#
[
cfg
(
target_arch
=
"
x86
"
)
]
use
std
:
:
arch
:
:
x86
:
:
{
__m128
_mm_set_ss
_mm_cvtss_si32
_mm_cvtsi32_ss
_mm_sub_ss
_mm_cmple_ss
_mm_store_ss
_mm_setzero_ps
}
;
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
use
std
:
:
arch
:
:
x86_64
:
:
{
__m128
_mm_set_ss
_mm_cvtss_si32
_mm_cvtsi32_ss
_mm_sub_ss
_mm_cmple_ss
_mm_store_ss
_mm_setzero_ps
}
;
let
given
:
__m128
=
_mm_set_ss
(
x
)
;
let
result
=
_mm_cvtss_si32
(
given
)
;
let
rounded
:
__m128
=
_mm_setzero_ps
(
)
;
let
rounded
=
_mm_cvtsi32_ss
(
rounded
result
)
;
let
diff
=
_mm_sub_ss
(
rounded
given
)
;
let
negHalf
=
_mm_set_ss
(
-
0
.
5
)
;
let
mask
=
_mm_cmple_ss
(
diff
negHalf
)
;
let
mut
correction
:
i32
=
0
;
_mm_store_ss
(
(
&
mut
correction
)
as
*
mut
_
as
*
mut
_
mask
)
;
return
result
-
correction
;
}
#
[
cfg
(
not
(
target_feature
=
"
sse2
"
)
)
]
return
(
x
+
0
.
5
)
.
floor
(
)
as
i32
;
}
fn
SmallRound
(
x
:
f32
)
-
>
i32
{
debug_assert
!
(
-
(
0x100000
as
f64
-
0
.
5
)
<
x
as
f64
&
&
(
x
as
f64
)
<
(
0x100000
as
f64
-
0
.
5
)
)
;
let
fi
=
(
x
as
f64
+
(
0x00600000
as
f64
+
0
.
25
)
)
as
f32
;
let
result
=
(
(
fi
.
to_bits
(
)
as
i32
)
<
<
10
)
>
>
11
;
debug_assert
!
(
x
<
(
result
as
f32
)
+
0
.
5
&
&
x
>
=
(
result
as
f32
)
-
0
.
5
)
;
return
result
;
}
pub
fn
Round
(
x
:
f32
)
-
>
i32
{
let
xAbs
:
u32
=
x
.
to_bits
(
)
&
0x7FFFFFFF
;
return
if
xAbs
<
=
sc_uBinaryFloatSmallMax
{
SmallRound
(
x
)
}
else
{
LargeRound
(
x
)
}
;
}
}
macro_rules
!
TOREAL
{
(
e
:
expr
)
=
>
{
e
as
REAL
}
}
