const
FORCE_TRIANGLES
:
bool
=
true
;
const
FLOAT_ZERO
:
f32
=
0
.
;
const
FLOAT_ONE
:
f32
=
1
.
;
use
std
:
:
rc
:
:
Rc
;
use
crate
:
:
{
types
:
:
*
geometry_sink
:
:
IGeometrySink
aacoverage
:
:
c_nShiftSizeSquared
OutputVertex
nullable_ref
:
:
Ref
}
;
impl
CHwVertexBufferBuilder
{
pub
fn
FlushTryGetVertexBuffer
(
&
mut
self
ppVertexBuffer
:
Option
<
&
mut
CHwVertexBuffer
>
)
-
>
HRESULT
{
return
self
.
FlushInternal
(
ppVertexBuffer
)
;
}
}
#
[
derive
(
Default
)
]
pub
struct
CD3DVertexXYZDUV2
{
x
:
f32
y
:
f32
coverage
:
f32
}
pub
type
CHwVertexBuffer
=
CHwTVertexBuffer
<
OutputVertex
>
;
#
[
derive
(
Default
)
]
pub
struct
CHwTVertexBuffer
<
TVertex
>
{
m_rgVerticesTriList
:
DynArray
<
TVertex
>
#
[
cfg
(
debug_assertions
)
]
m_fDbgNonLineSegmentTriangleStrip
:
bool
}
#
[
derive
(
Default
)
]
struct
CHwTVertexMappings
<
TVertex
>
{
m_vStatic
:
TVertex
}
impl
<
TVertex
>
CHwTVertexBuffer
<
TVertex
>
{
pub
fn
Reset
(
&
mut
self
)
{
#
[
cfg
(
debug_assertions
)
]
{
self
.
m_fDbgNonLineSegmentTriangleStrip
=
false
;
}
self
.
m_rgVerticesTriList
.
SetCount
(
0
)
;
}
fn
IsEmpty
(
&
self
)
-
>
bool
{
return
true
&
&
(
self
.
m_rgVerticesTriList
.
GetCount
(
)
=
=
0
)
}
}
pub
struct
CHwTVertexBufferBuilder
<
TVertex
>
{
m_pDeviceNoRef
:
Rc
<
CD3DDeviceLevel1
>
m_mvfIn
:
MilVertexFormat
#
[
cfg
(
debug_assertions
)
]
m_mvfDbgOut
:
MilVertexFormat
m_mvfGenerated
:
MilVertexFormat
m_mvfaAntiAliasScaleLocation
:
MilVertexFormatAttribute
m_pVB
:
Box
<
CHwTVertexBuffer
<
TVertex
>
>
m_fHasFlushed
:
bool
m_fNeedOutsideGeometry
:
bool
m_fNeedInsideGeometry
:
bool
m_rcOutsideBounds
:
CMILSurfaceRect
m_rCurStratumTop
:
f32
m_rCurStratumBottom
:
f32
m_rLastTrapezoidRight
:
f32
m_rLastTrapezoidTopRight
:
f32
m_rLastTrapezoidBottomRight
:
f32
}
impl
CHwVertexBuffer
{
fn
AddLine
(
&
mut
self
v0
:
&
PointXYA
v1
:
&
PointXYA
)
-
>
HRESULT
{
type
TVertex
=
CD3DVertexXYZDUV2
;
let
hr
=
S_OK
;
let
pVertices
:
&
mut
[
TVertex
]
;
let
mut
rgScratchVertices
:
[
TVertex
;
2
]
=
Default
:
:
default
(
)
;
assert
!
(
!
(
v0
.
y
!
=
v1
.
y
)
)
;
let
fUseTriangles
=
FORCE_TRIANGLES
;
pVertices
=
&
mut
rgScratchVertices
;
pVertices
[
0
]
.
x
=
v0
.
x
;
pVertices
[
0
]
.
y
=
v0
.
y
;
pVertices
[
0
]
.
coverage
=
v0
.
a
;
pVertices
[
1
]
.
x
=
v1
.
x
;
pVertices
[
1
]
.
y
=
v1
.
y
;
pVertices
[
1
]
.
coverage
=
v1
.
a
;
if
(
fUseTriangles
)
{
IFC
!
(
self
.
AddLineAsTriangleList
(
&
pVertices
[
0
]
&
pVertices
[
1
]
)
)
;
}
RRETURN
!
(
hr
)
;
}
}
impl
<
TVertex
:
Default
>
CHwTVertexBuffer
<
TVertex
>
{
fn
AddTriListVertices
(
&
mut
self
uCount
:
UINT
)
-
>
&
mut
[
TVertex
]
{
#
[
cfg
(
debug_assertions
)
]
if
(
uCount
!
=
6
)
{
self
.
m_fDbgNonLineSegmentTriangleStrip
=
true
;
}
let
Count
=
(
self
.
m_rgVerticesTriList
.
GetCount
(
)
as
UINT
)
;
let
newCount
=
Count
+
uCount
;
self
.
m_rgVerticesTriList
.
resize_with
(
newCount
as
usize
Default
:
:
default
)
;
return
&
mut
self
.
m_rgVerticesTriList
[
Count
as
usize
.
.
]
;
}
}
pub
type
CHwVertexBufferBuilder
=
CHwTVertexBufferBuilder
<
OutputVertex
>
;
impl
CHwVertexBufferBuilder
{
pub
fn
Create
(
vfIn
:
MilVertexFormat
vfOut
:
MilVertexFormat
mvfaAntiAliasScaleLocation
:
MilVertexFormatAttribute
pDevice
:
Rc
<
CD3DDeviceLevel1
>
)
-
>
CHwVertexBufferBuilder
{
CHwVertexBufferBuilder
:
:
CreateTemplate
(
pDevice
.
GetVB_XYZDUV2
(
)
vfIn
vfOut
mvfaAntiAliasScaleLocation
pDevice
)
}
fn
OutsideLeft
(
&
self
)
-
>
f32
{
return
self
.
m_rcOutsideBounds
.
left
as
f32
;
}
fn
OutsideRight
(
&
self
)
-
>
f32
{
return
self
.
m_rcOutsideBounds
.
right
as
f32
;
}
fn
OutsideTop
(
&
self
)
-
>
f32
{
return
self
.
m_rcOutsideBounds
.
top
as
f32
;
}
fn
OutsideBottom
(
&
self
)
-
>
f32
{
return
self
.
m_rcOutsideBounds
.
bottom
as
f32
;
}
}
impl
<
TVertex
:
Default
>
CHwTVertexBufferBuilder
<
TVertex
>
{
fn
CreateTemplate
(
pVertexBuffer
:
Box
<
CHwTVertexBuffer
<
TVertex
>
>
mvfIn
:
MilVertexFormat
mvfOut
:
MilVertexFormat
mvfaAntiAliasScaleLocation
:
MilVertexFormatAttribute
pDevice
:
Rc
<
CD3DDeviceLevel1
>
)
-
>
Self
{
let
mut
pVertexBufferBuilder
=
CHwTVertexBufferBuilder
:
:
<
TVertex
>
:
:
new
(
pVertexBuffer
pDevice
)
;
IFC
!
(
pVertexBufferBuilder
.
SetupConverter
(
mvfIn
mvfOut
mvfaAntiAliasScaleLocation
)
)
;
return
pVertexBufferBuilder
;
}
fn
new
(
pVertexBuffer
:
Box
<
CHwTVertexBuffer
<
TVertex
>
>
device
:
Rc
<
CD3DDeviceLevel1
>
)
-
>
Self
{
Self
{
m_pVB
:
pVertexBuffer
m_rCurStratumTop
:
f32
:
:
MAX
m_rCurStratumBottom
:
-
f32
:
:
MAX
m_fNeedOutsideGeometry
:
false
m_fNeedInsideGeometry
:
true
m_rLastTrapezoidRight
:
-
f32
:
:
MAX
m_rLastTrapezoidTopRight
:
-
f32
:
:
MAX
m_rLastTrapezoidBottomRight
:
-
f32
:
:
MAX
m_fHasFlushed
:
false
m_rcOutsideBounds
:
Default
:
:
default
(
)
m_pDeviceNoRef
:
device
#
[
cfg
(
debug_assertions
)
]
m_mvfDbgOut
:
MilVertexFormatAttribute
:
:
MILVFAttrNone
as
MilVertexFormat
m_mvfIn
:
MilVertexFormatAttribute
:
:
MILVFAttrNone
as
MilVertexFormat
m_mvfGenerated
:
MilVertexFormatAttribute
:
:
MILVFAttrNone
as
MilVertexFormat
m_mvfaAntiAliasScaleLocation
:
MilVertexFormatAttribute
:
:
MILVFAttrNone
}
}
fn
SetupConverter
(
&
mut
self
mvfIn
:
MilVertexFormat
mvfOut
:
MilVertexFormat
mvfaAntiAliasScaleLocation
:
MilVertexFormatAttribute
)
-
>
HRESULT
{
let
hr
=
S_OK
;
self
.
m_mvfIn
=
mvfIn
;
#
[
cfg
(
debug_assertions
)
]
{
self
.
m_mvfDbgOut
=
mvfOut
;
}
self
.
m_mvfGenerated
=
mvfOut
&
!
self
.
m_mvfIn
;
self
.
m_mvfaAntiAliasScaleLocation
=
mvfaAntiAliasScaleLocation
;
assert
!
(
(
self
.
m_mvfGenerated
&
MilVertexFormatAttribute
:
:
MILVFAttrXY
as
MilVertexFormat
)
=
=
0
)
;
RRETURN
!
(
hr
)
;
}
}
impl
<
TVertex
>
CHwTVertexBufferBuilder
<
TVertex
>
{
pub
fn
SetOutsideBounds
(
&
mut
self
prcOutsideBounds
:
Option
<
&
CMILSurfaceRect
>
fNeedInside
:
bool
)
{
if
let
Some
(
prcOutsideBounds
)
=
prcOutsideBounds
{
self
.
m_rcOutsideBounds
=
prcOutsideBounds
.
clone
(
)
;
self
.
m_fNeedOutsideGeometry
=
true
;
self
.
m_fNeedInsideGeometry
=
fNeedInside
;
}
else
{
self
.
m_fNeedOutsideGeometry
=
false
;
self
.
m_fNeedInsideGeometry
=
true
;
}
}
pub
fn
BeginBuilding
(
&
mut
self
)
-
>
HRESULT
{
let
hr
:
HRESULT
=
S_OK
;
self
.
m_fHasFlushed
=
false
;
self
.
m_pVB
.
Reset
(
)
;
RRETURN
!
(
hr
)
;
}
}
impl
IGeometrySink
for
CHwVertexBufferBuilder
{
fn
AddTrapezoid
(
&
mut
self
rPixelYTop
:
f32
rPixelXTopLeft
:
f32
rPixelXTopRight
:
f32
rPixelYBottom
:
f32
rPixelXBottomLeft
:
f32
rPixelXBottomRight
:
f32
rPixelXLeftDelta
:
f32
rPixelXRightDelta
:
f32
)
-
>
HRESULT
{
let
hr
=
S_OK
;
if
(
false
)
{
}
else
{
IFC
!
(
self
.
AddTrapezoidStandard
(
rPixelYTop
rPixelXTopLeft
rPixelXTopRight
rPixelYBottom
rPixelXBottomLeft
rPixelXBottomRight
rPixelXLeftDelta
rPixelXRightDelta
)
)
;
}
RRETURN
!
(
hr
)
;
}
fn
IsEmpty
(
&
self
)
-
>
bool
{
self
.
m_pVB
.
IsEmpty
(
)
}
fn
AddComplexScan
(
&
mut
self
nPixelY
:
INT
mut
pIntervalSpanStart
:
Ref
<
crate
:
:
aacoverage
:
:
CCoverageInterval
>
)
-
>
HRESULT
{
let
hr
:
HRESULT
=
S_OK
;
IFC
!
(
self
.
PrepareStratum
(
(
nPixelY
)
as
f32
(
nPixelY
+
1
)
as
f32
false
/
*
Not
a
trapezoid
.
*
/
0
.
0
.
0
.
0
.
0
.
0
.
)
)
;
let
rPixelY
:
f32
;
rPixelY
=
(
nPixelY
)
as
f32
+
0
.
5
;
let
mut
pLineSink
=
None
;
if
(
FORCE_TRIANGLES
)
{
pLineSink
=
Some
(
&
mut
self
.
m_pVB
)
;
}
if
(
pLineSink
.
is_none
(
)
)
{
}
while
(
(
*
pIntervalSpanStart
)
.
m_nPixelX
.
get
(
)
!
=
INT
:
:
MAX
)
{
assert
!
(
!
(
*
pIntervalSpanStart
)
.
m_pNext
.
get
(
)
.
is_null
(
)
)
;
if
(
self
.
NeedCoverageGeometry
(
(
*
pIntervalSpanStart
)
.
m_nCoverage
.
get
(
)
)
)
{
let
rCoverage
:
f32
=
(
(
*
pIntervalSpanStart
)
.
m_nCoverage
.
get
(
)
as
f32
)
/
(
c_nShiftSizeSquared
as
f32
)
;
let
mut
iBegin
:
LONG
=
(
*
pIntervalSpanStart
)
.
m_nPixelX
.
get
(
)
;
let
mut
iEnd
:
LONG
=
(
*
(
*
pIntervalSpanStart
)
.
m_pNext
.
get
(
)
)
.
m_nPixelX
.
get
(
)
;
if
(
self
.
NeedOutsideGeometry
(
)
)
{
iBegin
=
iBegin
.
max
(
iEnd
.
min
(
self
.
m_rcOutsideBounds
.
left
)
)
;
iEnd
=
iEnd
.
min
(
iBegin
.
max
(
self
.
m_rcOutsideBounds
.
right
)
)
;
}
let
rPixelXBegin
:
f32
=
(
iBegin
as
f32
)
+
0
.
5
;
let
rPixelXEnd
:
f32
=
(
iEnd
as
f32
)
+
0
.
5
;
{
let
mut
v0
:
PointXYA
=
Default
:
:
default
(
)
;
let
mut
v1
:
PointXYA
=
Default
:
:
default
(
)
;
v0
.
x
=
rPixelXBegin
;
v0
.
y
=
rPixelY
;
v0
.
a
=
rCoverage
;
v1
.
x
=
rPixelXEnd
;
v1
.
y
=
rPixelY
;
v1
.
a
=
rCoverage
;
IFC
!
(
self
.
m_pVB
.
AddLine
(
&
v0
&
v1
)
)
;
}
{
}
}
pIntervalSpanStart
=
(
*
pIntervalSpanStart
)
.
m_pNext
.
get
(
)
;
}
RRETURN
!
(
hr
)
;
}
}
impl
CHwVertexBuffer
{
fn
AddLineAsTriangleList
(
&
mut
self
pBegin
:
&
CD3DVertexXYZDUV2
pEnd
:
&
CD3DVertexXYZDUV2
)
-
>
HRESULT
{
let
hr
=
S_OK
;
debug_assert
!
(
pBegin
.
y
=
=
pEnd
.
y
)
;
debug_assert
!
(
pBegin
.
coverage
=
=
pEnd
.
coverage
)
;
let
x0
=
pBegin
.
x
-
0
.
5
;
let
x1
=
pEnd
.
x
-
0
.
5
;
let
y
=
pBegin
.
y
;
let
dwDiffuse
=
pBegin
.
coverage
;
let
pVertex
=
self
.
AddTriListVertices
(
3
)
;
pVertex
[
0
]
.
x
=
x0
;
pVertex
[
0
]
.
y
=
y
-
0
.
5
;
pVertex
[
0
]
.
coverage
=
dwDiffuse
;
pVertex
[
1
]
.
x
=
x0
;
pVertex
[
1
]
.
y
=
y
+
0
.
5
;
pVertex
[
1
]
.
coverage
=
dwDiffuse
;
pVertex
[
2
]
.
x
=
x1
;
pVertex
[
2
]
.
y
=
y
;
pVertex
[
2
]
.
coverage
=
dwDiffuse
;
RRETURN
!
(
hr
)
;
}
fn
DrawPrimitive
(
&
mut
self
pDevice
:
&
CD3DDeviceLevel1
)
-
>
HRESULT
{
pDevice
.
output
.
replace
(
std
:
:
mem
:
:
replace
(
&
mut
self
.
m_rgVerticesTriList
Vec
:
:
new
(
)
)
)
;
return
S_OK
;
}
}
impl
CHwVertexBufferBuilder
{
fn
AddTrapezoidStandard
(
&
mut
self
rPixelYTop
:
f32
rPixelXTopLeft
:
f32
rPixelXTopRight
:
f32
rPixelYBottom
:
f32
rPixelXBottomLeft
:
f32
rPixelXBottomRight
:
f32
rPixelXLeftDelta
:
f32
rPixelXRightDelta
:
f32
)
-
>
HRESULT
{
type
TVertex
=
CD3DVertexXYZDUV2
;
let
hr
=
S_OK
;
IFC
!
(
self
.
PrepareStratum
(
rPixelYTop
rPixelYBottom
true
/
*
Trapezoid
*
/
rPixelXTopLeft
.
min
(
rPixelXBottomLeft
)
rPixelXTopRight
.
max
(
rPixelXBottomRight
)
rPixelXTopLeft
-
rPixelXLeftDelta
rPixelXBottomLeft
-
rPixelXLeftDelta
rPixelXTopRight
+
rPixelXRightDelta
rPixelXBottomRight
+
rPixelXRightDelta
)
)
;
let
fNeedOutsideGeometry
:
bool
;
let
fNeedInsideGeometry
:
bool
;
fNeedOutsideGeometry
=
self
.
NeedOutsideGeometry
(
)
;
fNeedInsideGeometry
=
self
.
NeedInsideGeometry
(
)
;
let
pVertex
=
self
.
m_pVB
.
AddTriListVertices
(
18
)
;
let
mut
i
=
0
;
pVertex
[
i
]
.
x
=
rPixelXTopLeft
-
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ZERO
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomLeft
-
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ZERO
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXTopLeft
+
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomLeft
-
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ZERO
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXTopLeft
+
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomLeft
+
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
if
(
fNeedInsideGeometry
)
{
pVertex
[
i
]
.
x
=
rPixelXTopLeft
+
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomLeft
+
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXTopRight
-
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomLeft
+
rPixelXLeftDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXTopRight
-
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomRight
-
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
}
pVertex
[
i
]
.
x
=
rPixelXTopRight
-
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomRight
-
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXTopRight
+
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ZERO
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomRight
-
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ONE
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXTopRight
+
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYTop
;
pVertex
[
i
]
.
coverage
=
FLOAT_ZERO
;
i
+
=
1
;
pVertex
[
i
]
.
x
=
rPixelXBottomRight
+
rPixelXRightDelta
;
pVertex
[
i
]
.
y
=
rPixelYBottom
;
pVertex
[
i
]
.
coverage
=
FLOAT_ZERO
;
if
(
!
fNeedOutsideGeometry
)
{
}
RRETURN
!
(
hr
)
;
}
}
impl
CHwVertexBufferBuilder
{
fn
NeedCoverageGeometry
(
&
self
nCoverage
:
INT
)
-
>
bool
{
return
(
self
.
NeedInsideGeometry
(
)
|
|
nCoverage
!
=
c_nShiftSizeSquared
)
&
&
(
self
.
NeedOutsideGeometry
(
)
|
|
nCoverage
!
=
0
)
;
}
fn
NeedOutsideGeometry
(
&
self
)
-
>
bool
{
return
self
.
m_fNeedOutsideGeometry
;
}
fn
NeedInsideGeometry
(
&
self
)
-
>
bool
{
assert
!
(
self
.
m_fNeedOutsideGeometry
|
|
self
.
m_fNeedInsideGeometry
)
;
return
self
.
m_fNeedInsideGeometry
;
}
fn
PrepareStratum
(
&
mut
self
rStratumTop
:
f32
rStratumBottom
:
f32
fTrapezoid
:
bool
rTrapezoidLeft
:
f32
rTrapezoidRight
:
f32
rTrapezoidTopLeft
:
f32
rTrapezoidBottomLeft
:
f32
rTrapezoidTopRight
:
f32
rTrapezoidBottomRight
:
f32
)
-
>
HRESULT
{
return
if
self
.
NeedOutsideGeometry
(
)
{
self
.
PrepareStratumSlow
(
rStratumTop
rStratumBottom
fTrapezoid
rTrapezoidLeft
rTrapezoidRight
rTrapezoidTopLeft
rTrapezoidBottomLeft
rTrapezoidTopRight
rTrapezoidBottomRight
)
}
else
{
S_OK
}
;
}
fn
PrepareStratumSlow
(
&
mut
self
rStratumTop
:
f32
rStratumBottom
:
f32
fTrapezoid
:
bool
rTrapezoidLeft
:
f32
rTrapezoidRight
:
f32
rTrapezoidTopLeft
:
f32
rTrapezoidBottomLeft
:
f32
rTrapezoidTopRight
:
f32
rTrapezoidBottomRight
:
f32
)
-
>
HRESULT
{
type
TVertex
=
OutputVertex
;
let
hr
:
HRESULT
=
S_OK
;
assert
!
(
!
(
rStratumTop
>
rStratumBottom
)
)
;
assert
!
(
self
.
NeedOutsideGeometry
(
)
)
;
let
fEndBuildingOutside
:
f32
=
(
rStratumBottom
=
=
self
.
OutsideBottom
(
)
&
&
rStratumTop
=
=
self
.
OutsideBottom
(
)
)
as
i32
as
f32
;
if
(
fEndBuildingOutside
=
=
1
.
)
{
assert
!
(
!
fTrapezoid
)
;
}
else
{
assert
!
(
!
(
rStratumBottom
<
self
.
m_rCurStratumBottom
)
)
;
}
if
(
fEndBuildingOutside
=
=
1
.
|
|
rStratumBottom
!
=
self
.
m_rCurStratumBottom
)
{
if
(
self
.
m_rCurStratumTop
!
=
f32
:
:
MAX
)
{
let
rOutsideRight
:
f32
=
self
.
OutsideRight
(
)
.
max
(
self
.
m_rLastTrapezoidRight
)
;
let
pVertex
:
&
mut
[
OutputVertex
]
=
self
.
m_pVB
.
AddTriListVertices
(
6
)
;
pVertex
[
0
]
.
x
=
self
.
m_rLastTrapezoidTopRight
;
pVertex
[
0
]
.
y
=
self
.
m_rCurStratumTop
;
pVertex
[
0
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
1
]
.
x
=
self
.
m_rLastTrapezoidBottomRight
;
pVertex
[
1
]
.
y
=
self
.
m_rCurStratumBottom
;
pVertex
[
1
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
2
]
.
x
=
rOutsideRight
;
pVertex
[
2
]
.
y
=
self
.
m_rCurStratumTop
;
pVertex
[
2
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
3
]
.
x
=
self
.
m_rLastTrapezoidBottomRight
;
pVertex
[
3
]
.
y
=
self
.
m_rCurStratumBottom
;
pVertex
[
3
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
4
]
.
x
=
rOutsideRight
;
pVertex
[
4
]
.
y
=
self
.
m_rCurStratumTop
;
pVertex
[
4
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
5
]
.
x
=
rOutsideRight
;
pVertex
[
5
]
.
y
=
self
.
m_rCurStratumBottom
;
pVertex
[
5
]
.
coverage
=
FLOAT_ZERO
;
}
let
flGap
:
f32
=
rStratumTop
-
self
.
m_rCurStratumBottom
;
if
(
flGap
>
0
.
)
{
let
flRectTop
:
f32
=
if
self
.
m_rCurStratumBottom
=
=
-
f32
:
:
MAX
{
self
.
OutsideTop
(
)
}
else
{
self
.
m_rCurStratumBottom
}
;
let
flRectBot
:
f32
=
(
rStratumTop
as
f32
)
;
assert
!
(
self
.
m_rCurStratumBottom
!
=
-
f32
:
:
MAX
|
|
self
.
m_rCurStratumTop
=
=
f32
:
:
MAX
)
;
let
outside_left
=
self
.
OutsideLeft
(
)
;
let
outside_right
=
self
.
OutsideRight
(
)
;
let
pVertex
=
self
.
m_pVB
.
AddTriListVertices
(
6
)
;
pVertex
[
0
]
.
x
=
outside_left
;
pVertex
[
0
]
.
y
=
flRectTop
;
pVertex
[
0
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
1
]
.
x
=
outside_left
;
pVertex
[
1
]
.
y
=
flRectBot
;
pVertex
[
1
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
2
]
.
x
=
outside_right
;
pVertex
[
2
]
.
y
=
flRectTop
;
pVertex
[
2
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
3
]
.
x
=
outside_left
;
pVertex
[
3
]
.
y
=
flRectBot
;
pVertex
[
3
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
4
]
.
x
=
outside_right
;
pVertex
[
4
]
.
y
=
flRectTop
;
pVertex
[
4
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
5
]
.
x
=
outside_right
;
pVertex
[
5
]
.
y
=
flRectBot
;
pVertex
[
5
]
.
coverage
=
FLOAT_ZERO
;
}
if
(
fTrapezoid
)
{
let
rOutsideLeft
:
f32
=
self
.
OutsideLeft
(
)
.
min
(
rTrapezoidLeft
)
;
let
mut
pVertex
:
&
mut
[
TVertex
]
=
self
.
m_pVB
.
AddTriListVertices
(
6
)
;
pVertex
[
0
]
.
x
=
rOutsideLeft
;
pVertex
[
0
]
.
y
=
rStratumTop
;
pVertex
[
0
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
1
]
.
x
=
rOutsideLeft
;
pVertex
[
1
]
.
y
=
rStratumBottom
;
pVertex
[
1
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
2
]
.
x
=
rTrapezoidTopLeft
;
pVertex
[
2
]
.
y
=
rStratumTop
;
pVertex
[
2
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
3
]
.
x
=
rOutsideLeft
;
pVertex
[
3
]
.
y
=
rStratumBottom
;
pVertex
[
3
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
4
]
.
x
=
rTrapezoidTopLeft
;
pVertex
[
4
]
.
y
=
rStratumTop
;
pVertex
[
4
]
.
coverage
=
FLOAT_ZERO
;
pVertex
[
5
]
.
x
=
rTrapezoidBottomLeft
;
pVertex
[
5
]
.
y
=
rStratumBottom
;
pVertex
[
5
]
.
coverage
=
FLOAT_ZERO
;
}
}
if
(
fTrapezoid
)
{
self
.
m_rLastTrapezoidTopRight
=
rTrapezoidTopRight
;
self
.
m_rLastTrapezoidBottomRight
=
rTrapezoidBottomRight
;
self
.
m_rLastTrapezoidRight
=
rTrapezoidRight
;
}
self
.
m_rCurStratumTop
=
if
fTrapezoid
{
rStratumTop
}
else
{
f32
:
:
MAX
}
;
self
.
m_rCurStratumBottom
=
rStratumBottom
;
RRETURN
!
(
hr
)
;
}
fn
EndBuildingOutside
(
&
mut
self
)
-
>
HRESULT
{
return
self
.
PrepareStratum
(
self
.
OutsideBottom
(
)
self
.
OutsideBottom
(
)
false
0
.
0
.
0
.
0
.
0
.
0
.
)
;
}
fn
EndBuilding
(
&
mut
self
ppVertexBuffer
:
*
const
*
const
CHwVertexBuffer
)
-
>
HRESULT
{
let
hr
=
S_OK
;
IFC
!
(
self
.
EndBuildingOutside
(
)
)
;
if
(
ppVertexBuffer
!
=
NULL
(
)
)
{
todo
!
(
)
;
}
RRETURN
!
(
hr
)
;
}
fn
FlushInternal
(
&
mut
self
ppVertexBuffer
:
Option
<
&
mut
CHwVertexBuffer
>
)
-
>
HRESULT
{
let
hr
:
HRESULT
=
S_OK
;
IFC
!
(
self
.
EndBuilding
(
NULL
(
)
)
)
;
if
(
false
)
{
panic
!
(
)
;
}
else
{
IFC
!
(
self
.
m_pVB
.
DrawPrimitive
(
&
self
.
m_pDeviceNoRef
)
)
;
}
if
let
Some
(
_ppVertexBuffer
)
=
(
ppVertexBuffer
)
{
if
(
!
self
.
m_fHasFlushed
)
{
todo
!
(
)
;
}
}
else
{
self
.
m_fHasFlushed
=
true
;
self
.
m_pVB
.
Reset
(
)
;
}
RRETURN
!
(
hr
)
;
}
}
