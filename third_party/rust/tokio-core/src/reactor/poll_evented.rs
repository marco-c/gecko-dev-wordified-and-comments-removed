use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
;
use
futures
:
:
{
task
Async
Poll
}
;
use
mio
:
:
event
:
:
Evented
;
use
mio
:
:
Ready
;
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
tokio
:
:
reactor
:
:
{
Registration
}
;
use
reactor
:
:
{
Handle
Remote
}
;
pub
struct
PollEvented
<
E
>
{
io
:
E
inner
:
Inner
remote
:
Remote
}
struct
Inner
{
registration
:
Registration
read_readiness
:
AtomicUsize
write_readiness
:
AtomicUsize
}
impl
<
E
:
Evented
>
PollEvented
<
E
>
{
pub
fn
new
(
io
:
E
handle
:
&
Handle
)
-
>
io
:
:
Result
<
PollEvented
<
E
>
>
{
let
registration
=
Registration
:
:
new
(
)
;
registration
.
register_with
(
&
io
handle
.
new_tokio_handle
(
)
)
?
;
Ok
(
PollEvented
{
io
:
io
inner
:
Inner
{
registration
read_readiness
:
AtomicUsize
:
:
new
(
0
)
write_readiness
:
AtomicUsize
:
:
new
(
0
)
}
remote
:
handle
.
remote
(
)
.
clone
(
)
}
)
}
pub
fn
deregister
(
self
_
:
&
Handle
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
<
E
>
PollEvented
<
E
>
{
pub
fn
poll_read
(
&
self
)
-
>
Async
<
(
)
>
{
if
self
.
poll_read2
(
)
.
is_ready
(
)
{
return
(
)
.
into
(
)
;
}
Async
:
:
NotReady
}
fn
poll_read2
(
&
self
)
-
>
Async
<
Ready
>
{
match
self
.
inner
.
read_readiness
.
load
(
Relaxed
)
{
0
=
>
{
}
mut
n
=
>
{
if
let
Some
(
ready
)
=
self
.
inner
.
registration
.
take_read_ready
(
)
.
unwrap
(
)
{
n
|
=
super
:
:
ready2usize
(
ready
)
;
self
.
inner
.
read_readiness
.
store
(
n
Relaxed
)
;
}
return
super
:
:
usize2ready
(
n
)
.
into
(
)
;
}
}
let
ready
=
match
self
.
inner
.
registration
.
poll_read_ready
(
)
.
unwrap
(
)
{
Async
:
:
Ready
(
r
)
=
>
r
_
=
>
return
Async
:
:
NotReady
}
;
self
.
inner
.
read_readiness
.
store
(
super
:
:
ready2usize
(
ready
)
Relaxed
)
;
ready
.
into
(
)
}
pub
fn
poll_write
(
&
self
)
-
>
Async
<
(
)
>
{
match
self
.
inner
.
write_readiness
.
load
(
Relaxed
)
{
0
=
>
{
}
mut
n
=
>
{
if
let
Some
(
ready
)
=
self
.
inner
.
registration
.
take_write_ready
(
)
.
unwrap
(
)
{
n
|
=
super
:
:
ready2usize
(
ready
)
;
self
.
inner
.
write_readiness
.
store
(
n
Relaxed
)
;
}
return
(
)
.
into
(
)
;
}
}
let
ready
=
match
self
.
inner
.
registration
.
poll_write_ready
(
)
.
unwrap
(
)
{
Async
:
:
Ready
(
r
)
=
>
r
_
=
>
return
Async
:
:
NotReady
}
;
self
.
inner
.
write_readiness
.
store
(
super
:
:
ready2usize
(
ready
)
Relaxed
)
;
(
)
.
into
(
)
}
pub
fn
poll_ready
(
&
self
mask
:
Ready
)
-
>
Async
<
Ready
>
{
let
mut
ret
=
Ready
:
:
empty
(
)
;
if
mask
.
is_empty
(
)
{
return
ret
.
into
(
)
;
}
if
mask
.
is_writable
(
)
{
if
self
.
poll_write
(
)
.
is_ready
(
)
{
ret
=
Ready
:
:
writable
(
)
;
}
}
let
mask
=
mask
-
Ready
:
:
writable
(
)
;
if
!
mask
.
is_empty
(
)
{
if
let
Async
:
:
Ready
(
v
)
=
self
.
poll_read2
(
)
{
ret
|
=
v
&
mask
;
}
}
if
ret
.
is_empty
(
)
{
if
mask
.
is_writable
(
)
{
self
.
need_write
(
)
;
}
if
mask
.
is_readable
(
)
{
self
.
need_read
(
)
;
}
Async
:
:
NotReady
}
else
{
ret
.
into
(
)
}
}
pub
fn
need_read
(
&
self
)
{
self
.
inner
.
read_readiness
.
store
(
0
Relaxed
)
;
if
self
.
poll_read
(
)
.
is_ready
(
)
{
task
:
:
current
(
)
.
notify
(
)
;
}
}
pub
fn
need_write
(
&
self
)
{
self
.
inner
.
write_readiness
.
store
(
0
Relaxed
)
;
if
self
.
poll_write
(
)
.
is_ready
(
)
{
task
:
:
current
(
)
.
notify
(
)
;
}
}
pub
fn
remote
(
&
self
)
-
>
&
Remote
{
&
self
.
remote
}
pub
fn
get_ref
(
&
self
)
-
>
&
E
{
&
self
.
io
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
E
{
&
mut
self
.
io
}
}
impl
<
E
:
Read
>
Read
for
PollEvented
<
E
>
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
PollEvented
:
:
poll_read
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
get_mut
(
)
.
read
(
buf
)
;
if
is_wouldblock
(
&
r
)
{
self
.
need_read
(
)
;
}
r
}
}
impl
<
E
:
Write
>
Write
for
PollEvented
<
E
>
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
PollEvented
:
:
poll_write
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
get_mut
(
)
.
write
(
buf
)
;
if
is_wouldblock
(
&
r
)
{
self
.
need_write
(
)
;
}
r
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
let
Async
:
:
NotReady
=
PollEvented
:
:
poll_write
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
get_mut
(
)
.
flush
(
)
;
if
is_wouldblock
(
&
r
)
{
self
.
need_write
(
)
;
}
r
}
}
impl
<
E
:
Read
>
AsyncRead
for
PollEvented
<
E
>
{
}
impl
<
E
:
Write
>
AsyncWrite
for
PollEvented
<
E
>
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
Ok
(
(
)
.
into
(
)
)
}
}
#
[
allow
(
deprecated
)
]
impl
<
E
:
Read
+
Write
>
:
:
io
:
:
Io
for
PollEvented
<
E
>
{
fn
poll_read
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
PollEvented
<
E
>
>
:
:
poll_read
(
self
)
}
fn
poll_write
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
PollEvented
<
E
>
>
:
:
poll_write
(
self
)
}
}
impl
<
'
a
E
>
Read
for
&
'
a
PollEvented
<
E
>
where
&
'
a
E
:
Read
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
PollEvented
:
:
poll_read
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
get_ref
(
)
.
read
(
buf
)
;
if
is_wouldblock
(
&
r
)
{
self
.
need_read
(
)
;
}
r
}
}
impl
<
'
a
E
>
Write
for
&
'
a
PollEvented
<
E
>
where
&
'
a
E
:
Write
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
PollEvented
:
:
poll_write
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
get_ref
(
)
.
write
(
buf
)
;
if
is_wouldblock
(
&
r
)
{
self
.
need_write
(
)
;
}
r
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
if
let
Async
:
:
NotReady
=
PollEvented
:
:
poll_write
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
get_ref
(
)
.
flush
(
)
;
if
is_wouldblock
(
&
r
)
{
self
.
need_write
(
)
;
}
r
}
}
impl
<
'
a
E
>
AsyncRead
for
&
'
a
PollEvented
<
E
>
where
&
'
a
E
:
Read
{
}
impl
<
'
a
E
>
AsyncWrite
for
&
'
a
PollEvented
<
E
>
where
&
'
a
E
:
Write
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
Ok
(
(
)
.
into
(
)
)
}
}
#
[
allow
(
deprecated
)
]
impl
<
'
a
E
>
:
:
io
:
:
Io
for
&
'
a
PollEvented
<
E
>
where
&
'
a
E
:
Read
+
Write
{
fn
poll_read
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
PollEvented
<
E
>
>
:
:
poll_read
(
self
)
}
fn
poll_write
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
PollEvented
<
E
>
>
:
:
poll_write
(
self
)
}
}
fn
is_wouldblock
<
T
>
(
r
:
&
io
:
:
Result
<
T
>
)
-
>
bool
{
match
*
r
{
Ok
(
_
)
=
>
false
Err
(
ref
e
)
=
>
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
}
}
impl
<
E
:
Evented
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
PollEvented
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
PollEvented
"
)
.
field
(
"
io
"
&
self
.
io
)
.
finish
(
)
}
}
