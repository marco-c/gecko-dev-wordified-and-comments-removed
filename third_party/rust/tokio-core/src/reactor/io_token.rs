use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
io
;
use
futures
:
:
task
;
use
mio
:
:
event
:
:
Evented
;
use
reactor
:
:
{
Message
Remote
Handle
Direction
}
;
pub
struct
IoToken
{
token
:
usize
readiness
:
Arc
<
AtomicUsize
>
}
impl
IoToken
{
pub
fn
new
(
source
:
&
Evented
handle
:
&
Handle
)
-
>
io
:
:
Result
<
IoToken
>
{
match
handle
.
inner
.
upgrade
(
)
{
Some
(
inner
)
=
>
{
let
(
ready
token
)
=
try
!
(
inner
.
borrow_mut
(
)
.
add_source
(
source
)
)
;
Ok
(
IoToken
{
token
:
token
readiness
:
ready
}
)
}
None
=
>
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
event
loop
gone
"
)
)
}
}
pub
fn
take_readiness
(
&
self
)
-
>
usize
{
self
.
readiness
.
swap
(
0
Ordering
:
:
SeqCst
)
}
pub
fn
schedule_read
(
&
self
handle
:
&
Remote
)
{
handle
.
send
(
Message
:
:
Schedule
(
self
.
token
task
:
:
current
(
)
Direction
:
:
Read
)
)
;
}
pub
fn
schedule_write
(
&
self
handle
:
&
Remote
)
{
handle
.
send
(
Message
:
:
Schedule
(
self
.
token
task
:
:
current
(
)
Direction
:
:
Write
)
)
;
}
pub
fn
drop_source
(
&
self
handle
:
&
Remote
)
{
handle
.
send
(
Message
:
:
DropSource
(
self
.
token
)
)
;
}
}
