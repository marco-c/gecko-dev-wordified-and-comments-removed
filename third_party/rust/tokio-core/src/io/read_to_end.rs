use
std
:
:
io
:
:
{
self
Read
}
;
use
std
:
:
mem
;
use
futures
:
:
{
Poll
Future
}
;
pub
struct
ReadToEnd
<
A
>
{
state
:
State
<
A
>
}
enum
State
<
A
>
{
Reading
{
a
:
A
buf
:
Vec
<
u8
>
}
Empty
}
pub
fn
read_to_end
<
A
>
(
a
:
A
buf
:
Vec
<
u8
>
)
-
>
ReadToEnd
<
A
>
where
A
:
Read
{
ReadToEnd
{
state
:
State
:
:
Reading
{
a
:
a
buf
:
buf
}
}
}
impl
<
A
>
Future
for
ReadToEnd
<
A
>
where
A
:
Read
{
type
Item
=
(
A
Vec
<
u8
>
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
A
Vec
<
u8
>
)
io
:
:
Error
>
{
match
self
.
state
{
State
:
:
Reading
{
ref
mut
a
ref
mut
buf
}
=
>
{
try_nb
!
(
a
.
read_to_end
(
buf
)
)
;
}
State
:
:
Empty
=
>
panic
!
(
"
poll
ReadToEnd
after
it
'
s
done
"
)
}
match
mem
:
:
replace
(
&
mut
self
.
state
State
:
:
Empty
)
{
State
:
:
Reading
{
a
buf
}
=
>
Ok
(
(
a
buf
)
.
into
(
)
)
State
:
:
Empty
=
>
unreachable
!
(
)
}
}
}
