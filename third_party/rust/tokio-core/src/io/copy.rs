use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
futures
:
:
{
Future
Poll
}
;
pub
struct
Copy
<
R
W
>
{
reader
:
R
read_done
:
bool
writer
:
W
pos
:
usize
cap
:
usize
amt
:
u64
buf
:
Box
<
[
u8
]
>
}
pub
fn
copy
<
R
W
>
(
reader
:
R
writer
:
W
)
-
>
Copy
<
R
W
>
where
R
:
Read
W
:
Write
{
Copy
{
reader
:
reader
read_done
:
false
writer
:
writer
amt
:
0
pos
:
0
cap
:
0
buf
:
Box
:
:
new
(
[
0
;
2048
]
)
}
}
impl
<
R
W
>
Future
for
Copy
<
R
W
>
where
R
:
Read
W
:
Write
{
type
Item
=
u64
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
u64
io
:
:
Error
>
{
loop
{
if
self
.
pos
=
=
self
.
cap
&
&
!
self
.
read_done
{
let
n
=
try_nb
!
(
self
.
reader
.
read
(
&
mut
self
.
buf
)
)
;
if
n
=
=
0
{
self
.
read_done
=
true
;
}
else
{
self
.
pos
=
0
;
self
.
cap
=
n
;
}
}
while
self
.
pos
<
self
.
cap
{
let
i
=
try_nb
!
(
self
.
writer
.
write
(
&
self
.
buf
[
self
.
pos
.
.
self
.
cap
]
)
)
;
self
.
pos
+
=
i
;
self
.
amt
+
=
i
as
u64
;
}
if
self
.
pos
=
=
self
.
cap
&
&
self
.
read_done
{
try_nb
!
(
self
.
writer
.
flush
(
)
)
;
return
Ok
(
self
.
amt
.
into
(
)
)
}
}
}
}
