use
std
:
:
mem
;
use
futures
:
:
{
Future
Poll
}
;
enum
State
<
R
T
>
{
Pending
{
rd
:
R
buf
:
T
}
Empty
}
pub
fn
read
<
R
T
>
(
rd
:
R
buf
:
T
)
-
>
Read
<
R
T
>
where
R
:
:
:
std
:
:
io
:
:
Read
T
:
AsMut
<
[
u8
]
>
{
Read
{
state
:
State
:
:
Pending
{
rd
:
rd
buf
:
buf
}
}
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
Read
<
R
T
>
{
state
:
State
<
R
T
>
}
impl
<
R
T
>
Future
for
Read
<
R
T
>
where
R
:
:
:
std
:
:
io
:
:
Read
T
:
AsMut
<
[
u8
]
>
{
type
Item
=
(
R
T
usize
)
;
type
Error
=
:
:
std
:
:
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
R
T
usize
)
:
:
std
:
:
io
:
:
Error
>
{
let
nread
=
match
self
.
state
{
State
:
:
Pending
{
ref
mut
rd
ref
mut
buf
}
=
>
try_nb
!
(
rd
.
read
(
&
mut
buf
.
as_mut
(
)
[
.
.
]
)
)
State
:
:
Empty
=
>
panic
!
(
"
poll
a
Read
after
it
'
s
done
"
)
}
;
match
mem
:
:
replace
(
&
mut
self
.
state
State
:
:
Empty
)
{
State
:
:
Pending
{
rd
buf
}
=
>
Ok
(
(
rd
buf
nread
)
.
into
(
)
)
State
:
:
Empty
=
>
panic
!
(
"
invalid
internal
state
"
)
}
}
}
