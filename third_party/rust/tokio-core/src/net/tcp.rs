use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
self
Read
Write
}
;
use
std
:
:
mem
;
use
std
:
:
net
:
:
{
self
SocketAddr
Shutdown
}
;
use
std
:
:
time
:
:
Duration
;
use
bytes
:
:
{
Buf
BufMut
}
;
use
futures
:
:
stream
:
:
Stream
;
use
futures
:
:
{
Future
Poll
Async
}
;
use
iovec
:
:
IoVec
;
use
mio
;
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
reactor
:
:
{
Handle
PollEvented2
}
;
pub
struct
TcpListener
{
io
:
PollEvented2
<
mio
:
:
net
:
:
TcpListener
>
}
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
pub
struct
Incoming
{
inner
:
TcpListener
}
impl
TcpListener
{
pub
fn
bind
(
addr
:
&
SocketAddr
handle
:
&
Handle
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
l
=
try
!
(
mio
:
:
net
:
:
TcpListener
:
:
bind
(
addr
)
)
;
TcpListener
:
:
new
(
l
handle
)
}
pub
fn
bind2
(
addr
:
&
SocketAddr
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
l
=
try
!
(
mio
:
:
net
:
:
TcpListener
:
:
bind
(
addr
)
)
;
TcpListener
:
:
new2
(
l
)
}
pub
fn
accept
(
&
mut
self
)
-
>
io
:
:
Result
<
(
TcpStream
SocketAddr
)
>
{
let
(
io
addr
)
=
self
.
accept_std
(
)
?
;
let
io
=
mio
:
:
net
:
:
TcpStream
:
:
from_stream
(
io
)
?
;
let
io
=
PollEvented2
:
:
new
(
io
)
;
let
io
=
TcpStream
{
io
}
;
Ok
(
(
io
addr
)
)
}
pub
fn
accept_std
(
&
mut
self
)
-
>
io
:
:
Result
<
(
net
:
:
TcpStream
SocketAddr
)
>
{
if
let
Async
:
:
NotReady
=
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
WouldBlock
"
not
ready
"
)
)
}
match
self
.
io
.
get_ref
(
)
.
accept_std
(
)
{
Err
(
e
)
=
>
{
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
}
Err
(
e
)
}
Ok
(
(
sock
addr
)
)
=
>
Ok
(
(
sock
addr
)
)
}
}
pub
fn
from_listener
(
listener
:
net
:
:
TcpListener
_addr
:
&
SocketAddr
handle
:
&
Handle
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
l
=
try
!
(
mio
:
:
net
:
:
TcpListener
:
:
from_std
(
listener
)
)
;
TcpListener
:
:
new
(
l
handle
)
}
fn
new
(
listener
:
mio
:
:
net
:
:
TcpListener
handle
:
&
Handle
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
io
=
try
!
(
PollEvented2
:
:
new_with_handle
(
listener
handle
.
new_tokio_handle
(
)
)
)
;
Ok
(
TcpListener
{
io
:
io
}
)
}
fn
new2
(
listener
:
mio
:
:
net
:
:
TcpListener
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
io
=
PollEvented2
:
:
new
(
listener
)
;
Ok
(
TcpListener
{
io
:
io
}
)
}
pub
fn
poll_read
(
&
self
)
-
>
Async
<
(
)
>
{
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
.
map
(
|
r
|
{
if
r
.
is_ready
(
)
{
Async
:
:
Ready
(
(
)
)
}
else
{
Async
:
:
NotReady
}
}
)
.
unwrap_or
(
(
)
.
into
(
)
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
local_addr
(
)
}
pub
fn
incoming
(
self
)
-
>
Incoming
{
Incoming
{
inner
:
self
}
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_ttl
(
ttl
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
get_ref
(
)
.
ttl
(
)
}
pub
fn
set_only_v6
(
&
self
only_v6
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_only_v6
(
only_v6
)
}
pub
fn
only_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
only_v6
(
)
}
}
impl
fmt
:
:
Debug
for
TcpListener
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
io
.
get_ref
(
)
.
fmt
(
f
)
}
}
impl
Stream
for
Incoming
{
type
Item
=
(
TcpStream
SocketAddr
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
io
:
:
Error
>
{
Ok
(
Async
:
:
Ready
(
Some
(
try_nb
!
(
self
.
inner
.
accept
(
)
)
)
)
)
}
}
pub
struct
TcpStream
{
io
:
PollEvented2
<
mio
:
:
net
:
:
TcpStream
>
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
TcpStreamNew
{
inner
:
TcpStreamNewState
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
enum
TcpStreamNewState
{
Waiting
(
TcpStream
)
Error
(
io
:
:
Error
)
Empty
}
impl
TcpStream
{
pub
fn
connect
(
addr
:
&
SocketAddr
handle
:
&
Handle
)
-
>
TcpStreamNew
{
let
inner
=
match
mio
:
:
net
:
:
TcpStream
:
:
connect
(
addr
)
{
Ok
(
tcp
)
=
>
TcpStream
:
:
new
(
tcp
handle
)
Err
(
e
)
=
>
TcpStreamNewState
:
:
Error
(
e
)
}
;
TcpStreamNew
{
inner
:
inner
}
}
pub
fn
connect2
(
addr
:
&
SocketAddr
)
-
>
TcpStreamNew
{
let
inner
=
match
mio
:
:
net
:
:
TcpStream
:
:
connect
(
addr
)
{
Ok
(
tcp
)
=
>
TcpStream
:
:
new2
(
tcp
)
Err
(
e
)
=
>
TcpStreamNewState
:
:
Error
(
e
)
}
;
TcpStreamNew
{
inner
:
inner
}
}
fn
new
(
connected_stream
:
mio
:
:
net
:
:
TcpStream
handle
:
&
Handle
)
-
>
TcpStreamNewState
{
match
PollEvented2
:
:
new_with_handle
(
connected_stream
handle
.
new_tokio_handle
(
)
)
{
Ok
(
io
)
=
>
TcpStreamNewState
:
:
Waiting
(
TcpStream
{
io
:
io
}
)
Err
(
e
)
=
>
TcpStreamNewState
:
:
Error
(
e
)
}
}
fn
new2
(
connected_stream
:
mio
:
:
net
:
:
TcpStream
)
-
>
TcpStreamNewState
{
let
io
=
PollEvented2
:
:
new
(
connected_stream
)
;
TcpStreamNewState
:
:
Waiting
(
TcpStream
{
io
:
io
}
)
}
pub
fn
from_stream
(
stream
:
net
:
:
TcpStream
handle
:
&
Handle
)
-
>
io
:
:
Result
<
TcpStream
>
{
let
inner
=
try
!
(
mio
:
:
net
:
:
TcpStream
:
:
from_stream
(
stream
)
)
;
Ok
(
TcpStream
{
io
:
try
!
(
PollEvented2
:
:
new_with_handle
(
inner
handle
.
new_tokio_handle
(
)
)
)
}
)
}
pub
fn
connect_stream
(
stream
:
net
:
:
TcpStream
addr
:
&
SocketAddr
handle
:
&
Handle
)
-
>
Box
<
Future
<
Item
=
TcpStream
Error
=
io
:
:
Error
>
+
Send
>
{
let
state
=
match
mio
:
:
net
:
:
TcpStream
:
:
connect_stream
(
stream
addr
)
{
Ok
(
tcp
)
=
>
TcpStream
:
:
new
(
tcp
handle
)
Err
(
e
)
=
>
TcpStreamNewState
:
:
Error
(
e
)
}
;
Box
:
:
new
(
state
)
}
pub
fn
poll_read
(
&
self
)
-
>
Async
<
(
)
>
{
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
.
map
(
|
r
|
{
if
r
.
is_ready
(
)
{
Async
:
:
Ready
(
(
)
)
}
else
{
Async
:
:
NotReady
}
}
)
.
unwrap_or
(
(
)
.
into
(
)
)
}
pub
fn
poll_write
(
&
self
)
-
>
Async
<
(
)
>
{
self
.
io
.
poll_write_ready
(
)
.
map
(
|
r
|
{
if
r
.
is_ready
(
)
{
Async
:
:
Ready
(
(
)
)
}
else
{
Async
:
:
NotReady
}
}
)
.
unwrap_or
(
(
)
.
into
(
)
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
local_addr
(
)
}
pub
fn
peer_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
peer_addr
(
)
}
pub
fn
peek
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
self
.
poll_read
(
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
io
.
get_ref
(
)
.
peek
(
buf
)
;
if
is_wouldblock
(
&
r
)
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
}
return
r
}
pub
fn
shutdown
(
&
self
how
:
Shutdown
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
shutdown
(
how
)
}
pub
fn
set_nodelay
(
&
self
nodelay
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_nodelay
(
nodelay
)
}
pub
fn
nodelay
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
nodelay
(
)
}
pub
fn
set_recv_buffer_size
(
&
self
size
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_recv_buffer_size
(
size
)
}
pub
fn
recv_buffer_size
(
&
self
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
get_ref
(
)
.
recv_buffer_size
(
)
}
pub
fn
set_send_buffer_size
(
&
self
size
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_send_buffer_size
(
size
)
}
pub
fn
send_buffer_size
(
&
self
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
get_ref
(
)
.
send_buffer_size
(
)
}
pub
fn
set_keepalive
(
&
self
keepalive
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_keepalive
(
keepalive
)
}
pub
fn
keepalive
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Duration
>
>
{
self
.
io
.
get_ref
(
)
.
keepalive
(
)
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_ttl
(
ttl
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
get_ref
(
)
.
ttl
(
)
}
pub
fn
set_only_v6
(
&
self
only_v6
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_only_v6
(
only_v6
)
}
pub
fn
only_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
only_v6
(
)
}
pub
fn
set_linger
(
&
self
dur
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_linger
(
dur
)
}
pub
fn
linger
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Duration
>
>
{
self
.
io
.
get_ref
(
)
.
linger
(
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
8
"
note
=
"
use
set_keepalive
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
set_keepalive_ms
(
&
self
keepalive
:
Option
<
u32
>
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
allow
(
deprecated
)
]
self
.
io
.
get_ref
(
)
.
set_keepalive_ms
(
keepalive
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
8
"
note
=
"
use
keepalive
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
keepalive_ms
(
&
self
)
-
>
io
:
:
Result
<
Option
<
u32
>
>
{
#
[
allow
(
deprecated
)
]
self
.
io
.
get_ref
(
)
.
keepalive_ms
(
)
}
}
impl
Read
for
TcpStream
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
read
(
buf
)
}
}
impl
Write
for
TcpStream
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
write
(
buf
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
AsyncRead
for
TcpStream
{
unsafe
fn
prepare_uninitialized_buffer
(
&
self
_
:
&
mut
[
u8
]
)
-
>
bool
{
false
}
fn
read_buf
<
B
:
BufMut
>
(
&
mut
self
buf
:
&
mut
B
)
-
>
Poll
<
usize
io
:
:
Error
>
{
<
&
TcpStream
>
:
:
read_buf
(
&
mut
&
*
self
buf
)
}
}
impl
AsyncWrite
for
TcpStream
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
<
&
TcpStream
>
:
:
shutdown
(
&
mut
&
*
self
)
}
fn
write_buf
<
B
:
Buf
>
(
&
mut
self
buf
:
&
mut
B
)
-
>
Poll
<
usize
io
:
:
Error
>
{
<
&
TcpStream
>
:
:
write_buf
(
&
mut
&
*
self
buf
)
}
}
#
[
allow
(
deprecated
)
]
impl
:
:
io
:
:
Io
for
TcpStream
{
fn
poll_read
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
TcpStream
>
:
:
poll_read
(
self
)
}
fn
poll_write
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
TcpStream
>
:
:
poll_write
(
self
)
}
fn
read_vec
(
&
mut
self
bufs
:
&
mut
[
&
mut
IoVec
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
<
TcpStream
>
:
:
poll_read
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
io
.
get_ref
(
)
.
read_bufs
(
bufs
)
;
if
is_wouldblock
(
&
r
)
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
}
return
r
}
fn
write_vec
(
&
mut
self
bufs
:
&
[
&
IoVec
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
<
TcpStream
>
:
:
poll_write
(
self
)
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
let
r
=
self
.
io
.
get_ref
(
)
.
write_bufs
(
bufs
)
;
if
is_wouldblock
(
&
r
)
{
self
.
io
.
clear_write_ready
(
)
?
;
}
return
r
}
}
fn
is_wouldblock
<
T
>
(
r
:
&
io
:
:
Result
<
T
>
)
-
>
bool
{
match
*
r
{
Ok
(
_
)
=
>
false
Err
(
ref
e
)
=
>
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
}
}
impl
<
'
a
>
Read
for
&
'
a
TcpStream
{
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
(
&
self
.
io
)
.
read
(
buf
)
}
}
impl
<
'
a
>
Write
for
&
'
a
TcpStream
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
(
&
self
.
io
)
.
write
(
buf
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
(
&
self
.
io
)
.
flush
(
)
}
}
impl
<
'
a
>
AsyncRead
for
&
'
a
TcpStream
{
unsafe
fn
prepare_uninitialized_buffer
(
&
self
_
:
&
mut
[
u8
]
)
-
>
bool
{
false
}
fn
read_buf
<
B
:
BufMut
>
(
&
mut
self
buf
:
&
mut
B
)
-
>
Poll
<
usize
io
:
:
Error
>
{
if
let
Async
:
:
NotReady
=
<
TcpStream
>
:
:
poll_read
(
self
)
{
return
Ok
(
Async
:
:
NotReady
)
}
let
r
=
unsafe
{
let
b1
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b2
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b3
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b4
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b5
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b6
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b7
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b8
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b9
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b10
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b11
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b12
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b13
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b14
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b15
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
b16
:
&
mut
[
u8
]
=
&
mut
[
0
]
;
let
mut
bufs
:
[
&
mut
IoVec
;
16
]
=
[
b1
.
into
(
)
b2
.
into
(
)
b3
.
into
(
)
b4
.
into
(
)
b5
.
into
(
)
b6
.
into
(
)
b7
.
into
(
)
b8
.
into
(
)
b9
.
into
(
)
b10
.
into
(
)
b11
.
into
(
)
b12
.
into
(
)
b13
.
into
(
)
b14
.
into
(
)
b15
.
into
(
)
b16
.
into
(
)
]
;
let
n
=
buf
.
bytes_vec_mut
(
&
mut
bufs
)
;
self
.
io
.
get_ref
(
)
.
read_bufs
(
&
mut
bufs
[
.
.
n
]
)
}
;
match
r
{
Ok
(
n
)
=
>
{
unsafe
{
buf
.
advance_mut
(
n
)
;
}
Ok
(
Async
:
:
Ready
(
n
)
)
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
}
impl
<
'
a
>
AsyncWrite
for
&
'
a
TcpStream
{
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
Ok
(
(
)
.
into
(
)
)
}
fn
write_buf
<
B
:
Buf
>
(
&
mut
self
buf
:
&
mut
B
)
-
>
Poll
<
usize
io
:
:
Error
>
{
if
let
Async
:
:
NotReady
=
<
TcpStream
>
:
:
poll_write
(
self
)
{
return
Ok
(
Async
:
:
NotReady
)
}
let
r
=
{
static
DUMMY
:
&
[
u8
]
=
&
[
0
]
;
let
iovec
=
<
&
IoVec
>
:
:
from
(
DUMMY
)
;
let
mut
bufs
=
[
iovec
;
64
]
;
let
n
=
buf
.
bytes_vec
(
&
mut
bufs
)
;
self
.
io
.
get_ref
(
)
.
write_bufs
(
&
bufs
[
.
.
n
]
)
}
;
match
r
{
Ok
(
n
)
=
>
{
buf
.
advance
(
n
)
;
Ok
(
Async
:
:
Ready
(
n
)
)
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_write_ready
(
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
}
#
[
allow
(
deprecated
)
]
impl
<
'
a
>
:
:
io
:
:
Io
for
&
'
a
TcpStream
{
fn
poll_read
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
TcpStream
>
:
:
poll_read
(
self
)
}
fn
poll_write
(
&
mut
self
)
-
>
Async
<
(
)
>
{
<
TcpStream
>
:
:
poll_write
(
self
)
}
}
impl
fmt
:
:
Debug
for
TcpStream
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
io
.
get_ref
(
)
.
fmt
(
f
)
}
}
impl
Future
for
TcpStreamNew
{
type
Item
=
TcpStream
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
TcpStream
io
:
:
Error
>
{
self
.
inner
.
poll
(
)
}
}
impl
Future
for
TcpStreamNewState
{
type
Item
=
TcpStream
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
TcpStream
io
:
:
Error
>
{
{
let
stream
=
match
*
self
{
TcpStreamNewState
:
:
Waiting
(
ref
s
)
=
>
s
TcpStreamNewState
:
:
Error
(
_
)
=
>
{
let
e
=
match
mem
:
:
replace
(
self
TcpStreamNewState
:
:
Empty
)
{
TcpStreamNewState
:
:
Error
(
e
)
=
>
e
_
=
>
panic
!
(
)
}
;
return
Err
(
e
)
}
TcpStreamNewState
:
:
Empty
=
>
panic
!
(
"
can
'
t
poll
TCP
stream
twice
"
)
}
;
if
let
Async
:
:
NotReady
=
stream
.
io
.
poll_write_ready
(
)
?
{
return
Ok
(
Async
:
:
NotReady
)
}
if
let
Some
(
e
)
=
try
!
(
stream
.
io
.
get_ref
(
)
.
take_error
(
)
)
{
return
Err
(
e
)
}
}
match
mem
:
:
replace
(
self
TcpStreamNewState
:
:
Empty
)
{
TcpStreamNewState
:
:
Waiting
(
stream
)
=
>
Ok
(
Async
:
:
Ready
(
stream
)
)
_
=
>
panic
!
(
)
}
}
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
mod
sys
{
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
super
:
:
{
TcpStream
TcpListener
}
;
impl
AsRawFd
for
TcpStream
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
get_ref
(
)
.
as_raw_fd
(
)
}
}
impl
AsRawFd
for
TcpListener
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
get_ref
(
)
.
as_raw_fd
(
)
}
}
}
#
[
cfg
(
windows
)
]
mod
sys
{
}
