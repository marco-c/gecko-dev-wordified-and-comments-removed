use
std
:
:
io
;
use
std
:
:
net
:
:
{
self
SocketAddr
Ipv4Addr
Ipv6Addr
}
;
use
std
:
:
fmt
;
use
futures
:
:
{
Async
Future
Poll
}
;
use
mio
;
use
reactor
:
:
{
Handle
PollEvented2
}
;
pub
struct
UdpSocket
{
io
:
PollEvented2
<
mio
:
:
net
:
:
UdpSocket
>
}
mod
frame
;
pub
use
self
:
:
frame
:
:
{
UdpFramed
UdpCodec
}
;
impl
UdpSocket
{
pub
fn
bind
(
addr
:
&
SocketAddr
handle
:
&
Handle
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
udp
=
try
!
(
mio
:
:
net
:
:
UdpSocket
:
:
bind
(
addr
)
)
;
UdpSocket
:
:
new
(
udp
handle
)
}
fn
new
(
socket
:
mio
:
:
net
:
:
UdpSocket
handle
:
&
Handle
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
io
=
try
!
(
PollEvented2
:
:
new_with_handle
(
socket
handle
.
new_tokio_handle
(
)
)
)
;
Ok
(
UdpSocket
{
io
:
io
}
)
}
pub
fn
from_socket
(
socket
:
net
:
:
UdpSocket
handle
:
&
Handle
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
udp
=
try
!
(
mio
:
:
net
:
:
UdpSocket
:
:
from_socket
(
socket
)
)
;
UdpSocket
:
:
new
(
udp
handle
)
}
pub
fn
framed
<
C
:
UdpCodec
>
(
self
codec
:
C
)
-
>
UdpFramed
<
C
>
{
frame
:
:
new
(
self
codec
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
local_addr
(
)
}
pub
fn
connect
(
&
self
addr
:
&
SocketAddr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
connect
(
*
addr
)
}
pub
fn
send
(
&
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
self
.
io
.
poll_write_ready
(
)
?
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
match
self
.
io
.
get_ref
(
)
.
send
(
buf
)
{
Ok
(
n
)
=
>
Ok
(
n
)
Err
(
e
)
=
>
{
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
{
self
.
io
.
clear_write_ready
(
)
?
;
}
Err
(
e
)
}
}
}
pub
fn
recv
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
match
self
.
io
.
get_ref
(
)
.
recv
(
buf
)
{
Ok
(
n
)
=
>
Ok
(
n
)
Err
(
e
)
=
>
{
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
}
Err
(
e
)
}
}
}
pub
fn
poll_read
(
&
self
)
-
>
Async
<
(
)
>
{
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
.
map
(
|
r
|
{
if
r
.
is_ready
(
)
{
Async
:
:
Ready
(
(
)
)
}
else
{
Async
:
:
NotReady
}
}
)
.
unwrap_or
(
(
)
.
into
(
)
)
}
pub
fn
poll_write
(
&
self
)
-
>
Async
<
(
)
>
{
self
.
io
.
poll_write_ready
(
)
.
map
(
|
r
|
{
if
r
.
is_ready
(
)
{
Async
:
:
Ready
(
(
)
)
}
else
{
Async
:
:
NotReady
}
}
)
.
unwrap_or
(
(
)
.
into
(
)
)
}
pub
fn
send_to
(
&
self
buf
:
&
[
u8
]
target
:
&
SocketAddr
)
-
>
io
:
:
Result
<
usize
>
{
if
let
Async
:
:
NotReady
=
self
.
io
.
poll_write_ready
(
)
?
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
match
self
.
io
.
get_ref
(
)
.
send_to
(
buf
target
)
{
Ok
(
n
)
=
>
Ok
(
n
)
Err
(
e
)
=
>
{
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
{
self
.
io
.
clear_write_ready
(
)
?
;
}
Err
(
e
)
}
}
}
pub
fn
send_dgram
<
T
>
(
self
buf
:
T
addr
:
SocketAddr
)
-
>
SendDgram
<
T
>
where
T
:
AsRef
<
[
u8
]
>
{
SendDgram
(
Some
(
(
self
buf
addr
)
)
)
}
pub
fn
recv_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
if
let
Async
:
:
NotReady
=
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
{
return
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
match
self
.
io
.
get_ref
(
)
.
recv_from
(
buf
)
{
Ok
(
n
)
=
>
Ok
(
n
)
Err
(
e
)
=
>
{
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
}
Err
(
e
)
}
}
}
pub
fn
recv_dgram
<
T
>
(
self
buf
:
T
)
-
>
RecvDgram
<
T
>
where
T
:
AsMut
<
[
u8
]
>
{
RecvDgram
(
Some
(
(
self
buf
)
)
)
}
pub
fn
broadcast
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
broadcast
(
)
}
pub
fn
set_broadcast
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_broadcast
(
on
)
}
pub
fn
multicast_loop_v4
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
multicast_loop_v4
(
)
}
pub
fn
set_multicast_loop_v4
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_multicast_loop_v4
(
on
)
}
pub
fn
multicast_ttl_v4
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
get_ref
(
)
.
multicast_ttl_v4
(
)
}
pub
fn
set_multicast_ttl_v4
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_multicast_ttl_v4
(
ttl
)
}
pub
fn
multicast_loop_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
multicast_loop_v6
(
)
}
pub
fn
set_multicast_loop_v6
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_multicast_loop_v6
(
on
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
get_ref
(
)
.
ttl
(
)
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_ttl
(
ttl
)
}
pub
fn
join_multicast_v4
(
&
self
multiaddr
:
&
Ipv4Addr
interface
:
&
Ipv4Addr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
join_multicast_v4
(
multiaddr
interface
)
}
pub
fn
join_multicast_v6
(
&
self
multiaddr
:
&
Ipv6Addr
interface
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
join_multicast_v6
(
multiaddr
interface
)
}
pub
fn
leave_multicast_v4
(
&
self
multiaddr
:
&
Ipv4Addr
interface
:
&
Ipv4Addr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
leave_multicast_v4
(
multiaddr
interface
)
}
pub
fn
leave_multicast_v6
(
&
self
multiaddr
:
&
Ipv6Addr
interface
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
leave_multicast_v6
(
multiaddr
interface
)
}
pub
fn
set_only_v6
(
&
self
only_v6
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_only_v6
(
only_v6
)
}
pub
fn
only_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
io
.
get_ref
(
)
.
only_v6
(
)
}
}
impl
fmt
:
:
Debug
for
UdpSocket
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
io
.
get_ref
(
)
.
fmt
(
f
)
}
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
SendDgram
<
T
>
(
Option
<
(
UdpSocket
T
SocketAddr
)
>
)
;
fn
incomplete_write
(
reason
:
&
str
)
-
>
io
:
:
Error
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
reason
)
}
impl
<
T
>
Future
for
SendDgram
<
T
>
where
T
:
AsRef
<
[
u8
]
>
{
type
Item
=
(
UdpSocket
T
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
(
UdpSocket
T
)
io
:
:
Error
>
{
{
let
(
ref
sock
ref
buf
ref
addr
)
=
*
self
.
0
.
as_ref
(
)
.
expect
(
"
SendDgram
polled
after
completion
"
)
;
let
n
=
try_nb
!
(
sock
.
send_to
(
buf
.
as_ref
(
)
addr
)
)
;
if
n
!
=
buf
.
as_ref
(
)
.
len
(
)
{
return
Err
(
incomplete_write
(
"
failed
to
send
entire
message
\
in
datagram
"
)
)
}
}
let
(
sock
buf
_addr
)
=
self
.
0
.
take
(
)
.
unwrap
(
)
;
Ok
(
Async
:
:
Ready
(
(
sock
buf
)
)
)
}
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
RecvDgram
<
T
>
(
Option
<
(
UdpSocket
T
)
>
)
;
impl
<
T
>
Future
for
RecvDgram
<
T
>
where
T
:
AsMut
<
[
u8
]
>
{
type
Item
=
(
UdpSocket
T
usize
SocketAddr
)
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Self
:
:
Item
io
:
:
Error
>
{
let
(
n
addr
)
=
{
let
(
ref
socket
ref
mut
buf
)
=
*
self
.
0
.
as_mut
(
)
.
expect
(
"
RecvDgram
polled
after
completion
"
)
;
try_nb
!
(
socket
.
recv_from
(
buf
.
as_mut
(
)
)
)
}
;
let
(
socket
buf
)
=
self
.
0
.
take
(
)
.
unwrap
(
)
;
Ok
(
Async
:
:
Ready
(
(
socket
buf
n
addr
)
)
)
}
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
mod
sys
{
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
super
:
:
UdpSocket
;
impl
AsRawFd
for
UdpSocket
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
get_ref
(
)
.
as_raw_fd
(
)
}
}
}
#
[
cfg
(
windows
)
]
mod
sys
{
}
