#
!
[
warn
(
unreachable_pub
)
]
#
!
[
warn
(
clippy
:
:
use_self
)
]
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
AsFd
;
#
[
cfg
(
windows
)
]
use
std
:
:
os
:
:
windows
:
:
io
:
:
AsSocket
;
use
std
:
:
{
net
:
:
{
IpAddr
Ipv6Addr
SocketAddr
}
sync
:
:
Mutex
time
:
:
{
Duration
Instant
}
}
;
#
[
cfg
(
all
(
feature
=
"
direct
-
log
"
not
(
feature
=
"
tracing
"
)
)
)
]
use
log
:
:
warn
;
#
[
cfg
(
feature
=
"
tracing
"
)
]
use
tracing
:
:
warn
;
#
[
cfg
(
any
(
unix
windows
)
)
]
mod
cmsg
;
#
[
cfg
(
unix
)
]
#
[
path
=
"
unix
.
rs
"
]
mod
imp
;
#
[
cfg
(
windows
)
]
#
[
path
=
"
windows
.
rs
"
]
mod
imp
;
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
#
[
path
=
"
fallback
.
rs
"
]
mod
imp
;
pub
use
imp
:
:
UdpSocketState
;
pub
const
BATCH_SIZE
:
usize
=
imp
:
:
BATCH_SIZE
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
RecvMeta
{
pub
addr
:
SocketAddr
pub
len
:
usize
pub
stride
:
usize
pub
ecn
:
Option
<
EcnCodepoint
>
pub
dst_ip
:
Option
<
IpAddr
>
}
impl
Default
for
RecvMeta
{
fn
default
(
)
-
>
Self
{
Self
{
addr
:
SocketAddr
:
:
new
(
Ipv6Addr
:
:
UNSPECIFIED
.
into
(
)
0
)
len
:
0
stride
:
0
ecn
:
None
dst_ip
:
None
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Transmit
<
'
a
>
{
pub
destination
:
SocketAddr
pub
ecn
:
Option
<
EcnCodepoint
>
pub
contents
:
&
'
a
[
u8
]
pub
segment_size
:
Option
<
usize
>
pub
src_ip
:
Option
<
IpAddr
>
}
const
IO_ERROR_LOG_INTERVAL
:
Duration
=
std
:
:
time
:
:
Duration
:
:
from_secs
(
60
)
;
#
[
cfg
(
any
(
feature
=
"
tracing
"
feature
=
"
direct
-
log
"
)
)
]
fn
log_sendmsg_error
(
last_send_error
:
&
Mutex
<
Instant
>
err
:
impl
core
:
:
fmt
:
:
Debug
transmit
:
&
Transmit
)
{
let
now
=
Instant
:
:
now
(
)
;
let
last_send_error
=
&
mut
*
last_send_error
.
lock
(
)
.
expect
(
"
poisend
lock
"
)
;
if
now
.
saturating_duration_since
(
*
last_send_error
)
>
IO_ERROR_LOG_INTERVAL
{
*
last_send_error
=
now
;
warn
!
(
"
sendmsg
error
:
{
:
?
}
Transmit
:
{
{
destination
:
{
:
?
}
src_ip
:
{
:
?
}
enc
:
{
:
?
}
len
:
{
:
?
}
segment_size
:
{
:
?
}
}
}
"
err
transmit
.
destination
transmit
.
src_ip
transmit
.
ecn
transmit
.
contents
.
len
(
)
transmit
.
segment_size
)
;
}
}
#
[
cfg
(
not
(
any
(
feature
=
"
tracing
"
feature
=
"
direct
-
log
"
)
)
)
]
fn
log_sendmsg_error
(
_
:
&
Mutex
<
Instant
>
_
:
impl
core
:
:
fmt
:
:
Debug
_
:
&
Transmit
)
{
}
pub
struct
UdpSockRef
<
'
a
>
(
socket2
:
:
SockRef
<
'
a
>
)
;
#
[
cfg
(
unix
)
]
impl
<
'
s
S
>
From
<
&
'
s
S
>
for
UdpSockRef
<
'
s
>
where
S
:
AsFd
{
fn
from
(
socket
:
&
'
s
S
)
-
>
Self
{
Self
(
socket
.
into
(
)
)
}
}
#
[
cfg
(
windows
)
]
impl
<
'
s
S
>
From
<
&
'
s
S
>
for
UdpSockRef
<
'
s
>
where
S
:
AsSocket
{
fn
from
(
socket
:
&
'
s
S
)
-
>
Self
{
Self
(
socket
.
into
(
)
)
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
pub
enum
EcnCodepoint
{
#
[
doc
(
hidden
)
]
Ect0
=
0b10
#
[
doc
(
hidden
)
]
Ect1
=
0b01
#
[
doc
(
hidden
)
]
Ce
=
0b11
}
impl
EcnCodepoint
{
pub
fn
from_bits
(
x
:
u8
)
-
>
Option
<
Self
>
{
use
self
:
:
EcnCodepoint
:
:
*
;
Some
(
match
x
&
0b11
{
0b10
=
>
Ect0
0b01
=
>
Ect1
0b11
=
>
Ce
_
=
>
{
return
None
;
}
}
)
}
}
