use
std
:
:
{
io
net
:
:
SocketAddr
}
;
use
neqo_common
:
:
Datagram
;
use
neqo_udp
:
:
{
DatagramIter
RecvBuf
}
;
pub
struct
Socket
{
state
:
quinn_udp
:
:
UdpSocketState
inner
:
tokio
:
:
net
:
:
UdpSocket
}
impl
Socket
{
pub
fn
bind
<
A
:
std
:
:
net
:
:
ToSocketAddrs
>
(
addr
:
A
)
-
>
Result
<
Self
io
:
:
Error
>
{
let
socket
=
std
:
:
net
:
:
UdpSocket
:
:
bind
(
addr
)
?
;
Ok
(
Self
{
state
:
quinn_udp
:
:
UdpSocketState
:
:
new
(
(
&
socket
)
.
into
(
)
)
?
inner
:
tokio
:
:
net
:
:
UdpSocket
:
:
from_std
(
socket
)
?
}
)
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
inner
.
local_addr
(
)
}
pub
async
fn
writable
(
&
self
)
-
>
Result
<
(
)
io
:
:
Error
>
{
self
.
inner
.
writable
(
)
.
await
}
pub
async
fn
readable
(
&
self
)
-
>
Result
<
(
)
io
:
:
Error
>
{
self
.
inner
.
readable
(
)
.
await
}
pub
fn
send
(
&
self
d
:
&
Datagram
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
inner
.
try_io
(
tokio
:
:
io
:
:
Interest
:
:
WRITABLE
|
|
{
neqo_udp
:
:
send_inner
(
&
self
.
state
(
&
self
.
inner
)
.
into
(
)
d
)
}
)
}
pub
fn
recv
<
'
a
>
(
&
self
local_address
:
SocketAddr
recv_buf
:
&
'
a
mut
RecvBuf
)
-
>
Result
<
Option
<
DatagramIter
<
'
a
>
>
io
:
:
Error
>
{
self
.
inner
.
try_io
(
tokio
:
:
io
:
:
Interest
:
:
READABLE
|
|
{
neqo_udp
:
:
recv_inner
(
local_address
&
self
.
state
&
self
.
inner
recv_buf
)
}
)
.
map
(
Some
)
.
or_else
(
|
e
|
{
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
{
Ok
(
None
)
}
else
{
Err
(
e
)
}
}
)
}
}
