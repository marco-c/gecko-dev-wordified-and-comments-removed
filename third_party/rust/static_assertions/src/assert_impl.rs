#
[
macro_export
]
macro_rules
!
assert_impl_one
{
(
x
:
ty
:
(
t
:
path
)
+
(
)
?
)
=
>
{
const
_
:
fn
(
)
=
|
|
{
/
/
Generic
trait
that
must
be
implemented
for
x
exactly
once
.
trait
AmbiguousIfMoreThanOne
<
A
>
{
/
/
Required
for
actually
being
able
to
reference
the
trait
.
fn
some_item
(
)
{
}
}
/
/
Creates
multiple
scoped
Token
types
for
each
trait
t
over
/
/
which
a
specialized
AmbiguousIfMoreThanOne
<
Token
>
is
/
/
implemented
for
every
type
that
implements
t
.
(
{
#
[
allow
(
dead_code
)
]
struct
Token
;
impl
<
T
:
?
Sized
+
t
>
AmbiguousIfMoreThanOne
<
Token
>
for
T
{
}
}
)
+
/
/
If
there
is
only
one
specialized
trait
impl
type
inference
with
/
/
_
can
be
resolved
and
this
can
compile
.
Fails
to
compile
if
/
/
x
implements
more
than
one
AmbiguousIfMoreThanOne
<
Token
>
or
/
/
does
not
implement
any
at
all
.
let
_
=
<
x
as
AmbiguousIfMoreThanOne
<
_
>
>
:
:
some_item
;
}
;
}
;
}
#
[
macro_export
]
macro_rules
!
assert_impl_all
{
(
type
:
ty
:
(
trait
:
path
)
+
(
)
?
)
=
>
{
const
_
:
fn
(
)
=
|
|
{
/
/
Only
callable
when
type
implements
all
traits
in
(
trait
)
+
.
fn
assert_impl_all
<
T
:
?
Sized
(
+
trait
)
+
>
(
)
{
}
assert_impl_all
:
:
<
type
>
(
)
;
}
;
}
;
}
#
[
macro_export
]
macro_rules
!
assert_impl_any
{
(
x
:
ty
:
(
t
:
path
)
+
(
)
?
)
=
>
{
const
_
:
fn
(
)
=
|
|
{
use
crate
:
:
_core
:
:
marker
:
:
PhantomData
;
use
crate
:
:
_core
:
:
ops
:
:
Deref
;
/
/
Fallback
to
use
as
the
first
iterative
assignment
to
previous
.
let
previous
=
AssertImplAnyFallback
;
struct
AssertImplAnyFallback
;
/
/
Ensures
that
blanket
traits
can
'
t
impersonate
the
method
.
This
/
/
prevents
a
false
positive
attack
where
-
-
-
if
a
blanket
trait
is
in
/
/
scope
that
has
_static_assertions_impl_any
-
-
-
the
macro
will
/
/
compile
when
it
shouldn
'
t
.
/
/
/
/
See
https
:
/
/
github
.
com
/
nvzqz
/
static
-
assertions
-
rs
/
issues
/
19
for
/
/
more
info
.
struct
ActualAssertImplAnyToken
;
trait
AssertImplAnyToken
{
}
impl
AssertImplAnyToken
for
ActualAssertImplAnyToken
{
}
fn
assert_impl_any_token
<
T
:
AssertImplAnyToken
>
(
_
:
T
)
{
}
(
let
previous
=
{
struct
Wrapper
<
T
N
>
(
PhantomData
<
T
>
N
)
;
/
/
If
the
method
for
this
wrapper
can
'
t
be
called
then
the
/
/
compiler
will
insert
a
deref
and
try
again
.
This
forwards
the
/
/
compiler
'
s
next
attempt
to
the
previous
wrapper
.
impl
<
T
N
>
Deref
for
Wrapper
<
T
N
>
{
type
Target
=
N
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
1
}
}
/
/
This
impl
is
bounded
on
the
t
trait
so
the
method
can
/
/
only
be
called
if
x
implements
t
.
This
is
why
a
new
/
/
Wrapper
is
defined
for
each
previous
.
impl
<
T
:
t
N
>
Wrapper
<
T
N
>
{
fn
_static_assertions_impl_any
(
&
self
)
-
>
ActualAssertImplAnyToken
{
ActualAssertImplAnyToken
}
}
Wrapper
:
:
<
x
_
>
(
PhantomData
previous
)
}
;
)
+
/
/
Attempt
to
find
the
method
that
can
actually
be
called
.
The
found
/
/
method
must
return
a
type
that
implements
the
sealed
Token
/
/
trait
this
ensures
that
blanket
trait
methods
can
'
t
cause
this
/
/
macro
to
compile
.
assert_impl_any_token
(
previous
.
_static_assertions_impl_any
(
)
)
;
}
;
}
;
}
#
[
macro_export
]
macro_rules
!
assert_not_impl_all
{
(
x
:
ty
:
(
t
:
path
)
+
(
)
?
)
=
>
{
const
_
:
fn
(
)
=
|
|
{
/
/
Generic
trait
with
a
blanket
impl
over
(
)
for
all
types
.
trait
AmbiguousIfImpl
<
A
>
{
/
/
Required
for
actually
being
able
to
reference
the
trait
.
fn
some_item
(
)
{
}
}
impl
<
T
:
?
Sized
>
AmbiguousIfImpl
<
(
)
>
for
T
{
}
/
/
Used
for
the
specialized
impl
when
*
all
*
traits
in
/
/
(
t
)
+
are
implemented
.
#
[
allow
(
dead_code
)
]
struct
Invalid
;
impl
<
T
:
?
Sized
(
+
t
)
+
>
AmbiguousIfImpl
<
Invalid
>
for
T
{
}
/
/
If
there
is
only
one
specialized
trait
impl
type
inference
with
/
/
_
can
be
resolved
and
this
can
compile
.
Fails
to
compile
if
/
/
x
implements
AmbiguousIfImpl
<
Invalid
>
.
let
_
=
<
x
as
AmbiguousIfImpl
<
_
>
>
:
:
some_item
;
}
;
}
;
}
#
[
macro_export
]
macro_rules
!
assert_not_impl_any
{
(
x
:
ty
:
(
t
:
path
)
+
(
)
?
)
=
>
{
const
_
:
fn
(
)
=
|
|
{
/
/
Generic
trait
with
a
blanket
impl
over
(
)
for
all
types
.
trait
AmbiguousIfImpl
<
A
>
{
/
/
Required
for
actually
being
able
to
reference
the
trait
.
fn
some_item
(
)
{
}
}
impl
<
T
:
?
Sized
>
AmbiguousIfImpl
<
(
)
>
for
T
{
}
/
/
Creates
multiple
scoped
Invalid
types
for
each
trait
t
over
/
/
which
a
specialized
AmbiguousIfImpl
<
Invalid
>
is
implemented
for
/
/
every
type
that
implements
t
.
(
{
#
[
allow
(
dead_code
)
]
struct
Invalid
;
impl
<
T
:
?
Sized
+
t
>
AmbiguousIfImpl
<
Invalid
>
for
T
{
}
}
)
+
/
/
If
there
is
only
one
specialized
trait
impl
type
inference
with
/
/
_
can
be
resolved
and
this
can
compile
.
Fails
to
compile
if
/
/
x
implements
any
AmbiguousIfImpl
<
Invalid
>
.
let
_
=
<
x
as
AmbiguousIfImpl
<
_
>
>
:
:
some_item
;
}
;
}
;
}
