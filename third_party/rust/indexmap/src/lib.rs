#
!
[
deny
(
unsafe_code
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
indexmap
/
1
/
"
)
]
#
!
[
cfg_attr
(
not
(
has_std
)
no_std
)
]
#
[
cfg
(
not
(
has_std
)
)
]
#
[
macro_use
(
vec
)
]
extern
crate
alloc
;
#
[
cfg
(
not
(
has_std
)
)
]
pub
(
crate
)
mod
std
{
pub
use
core
:
:
*
;
pub
mod
alloc
{
pub
use
alloc
:
:
*
;
}
pub
mod
collections
{
pub
use
alloc
:
:
collections
:
:
*
;
}
pub
use
alloc
:
:
vec
;
}
#
[
cfg
(
not
(
has_std
)
)
]
use
std
:
:
vec
:
:
Vec
;
#
[
macro_use
]
mod
macros
;
mod
equivalent
;
mod
mutable_keys
;
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
mod
serde
;
mod
util
;
pub
mod
map
;
pub
mod
set
;
#
[
cfg
(
feature
=
"
rayon
"
)
]
mod
rayon
;
pub
use
equivalent
:
:
Equivalent
;
pub
use
map
:
:
IndexMap
;
pub
use
set
:
:
IndexSet
;
#
[
derive
(
Copy
Debug
)
]
struct
HashValue
(
usize
)
;
impl
HashValue
{
#
[
inline
(
always
)
]
fn
get
(
self
)
-
>
usize
{
self
.
0
}
}
impl
Clone
for
HashValue
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
PartialEq
for
HashValue
{
#
[
inline
]
fn
eq
(
&
self
rhs
:
&
Self
)
-
>
bool
{
self
.
0
=
=
rhs
.
0
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
struct
Bucket
<
K
V
>
{
hash
:
HashValue
key
:
K
value
:
V
}
impl
<
K
V
>
Bucket
<
K
V
>
{
fn
key_ref
(
&
self
)
-
>
&
K
{
&
self
.
key
}
fn
value_ref
(
&
self
)
-
>
&
V
{
&
self
.
value
}
fn
value_mut
(
&
mut
self
)
-
>
&
mut
V
{
&
mut
self
.
value
}
fn
key
(
self
)
-
>
K
{
self
.
key
}
fn
key_value
(
self
)
-
>
(
K
V
)
{
(
self
.
key
self
.
value
)
}
fn
refs
(
&
self
)
-
>
(
&
K
&
V
)
{
(
&
self
.
key
&
self
.
value
)
}
fn
ref_mut
(
&
mut
self
)
-
>
(
&
K
&
mut
V
)
{
(
&
self
.
key
&
mut
self
.
value
)
}
fn
muts
(
&
mut
self
)
-
>
(
&
mut
K
&
mut
V
)
{
(
&
mut
self
.
key
&
mut
self
.
value
)
}
}
trait
Entries
{
type
Entry
;
fn
into_entries
(
self
)
-
>
Vec
<
Self
:
:
Entry
>
;
fn
as_entries
(
&
self
)
-
>
&
[
Self
:
:
Entry
]
;
fn
as_entries_mut
(
&
mut
self
)
-
>
&
mut
[
Self
:
:
Entry
]
;
fn
with_entries
<
F
>
(
&
mut
self
f
:
F
)
where
F
:
FnOnce
(
&
mut
[
Self
:
:
Entry
]
)
;
}
