#
!
[
deny
(
unsafe_code
)
]
#
!
[
warn
(
rust_2018_idioms
)
]
#
!
[
no_std
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
)
)
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
macro_use
]
extern
crate
std
;
use
alloc
:
:
vec
:
:
{
self
Vec
}
;
mod
arbitrary
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
feature
=
"
borsh
"
)
]
mod
borsh
;
#
[
cfg
(
feature
=
"
serde
"
)
]
mod
serde
;
mod
util
;
pub
mod
map
;
pub
mod
set
;
#
[
cfg
(
feature
=
"
rayon
"
)
]
mod
rayon
;
pub
use
crate
:
:
map
:
:
IndexMap
;
pub
use
crate
:
:
set
:
:
IndexSet
;
pub
use
equivalent
:
:
Equivalent
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
struct
HashValue
(
usize
)
;
impl
HashValue
{
#
[
inline
(
always
)
]
fn
get
(
self
)
-
>
u64
{
self
.
0
as
u64
}
}
#
[
derive
(
Copy
Debug
)
]
struct
Bucket
<
K
V
>
{
hash
:
HashValue
key
:
K
value
:
V
}
impl
<
K
V
>
Clone
for
Bucket
<
K
V
>
where
K
:
Clone
V
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
Bucket
{
hash
:
self
.
hash
key
:
self
.
key
.
clone
(
)
value
:
self
.
value
.
clone
(
)
}
}
fn
clone_from
(
&
mut
self
other
:
&
Self
)
{
self
.
hash
=
other
.
hash
;
self
.
key
.
clone_from
(
&
other
.
key
)
;
self
.
value
.
clone_from
(
&
other
.
value
)
;
}
}
impl
<
K
V
>
Bucket
<
K
V
>
{
fn
key_ref
(
&
self
)
-
>
&
K
{
&
self
.
key
}
fn
value_ref
(
&
self
)
-
>
&
V
{
&
self
.
value
}
fn
value_mut
(
&
mut
self
)
-
>
&
mut
V
{
&
mut
self
.
value
}
fn
key
(
self
)
-
>
K
{
self
.
key
}
fn
value
(
self
)
-
>
V
{
self
.
value
}
fn
key_value
(
self
)
-
>
(
K
V
)
{
(
self
.
key
self
.
value
)
}
fn
refs
(
&
self
)
-
>
(
&
K
&
V
)
{
(
&
self
.
key
&
self
.
value
)
}
fn
ref_mut
(
&
mut
self
)
-
>
(
&
K
&
mut
V
)
{
(
&
self
.
key
&
mut
self
.
value
)
}
fn
muts
(
&
mut
self
)
-
>
(
&
mut
K
&
mut
V
)
{
(
&
mut
self
.
key
&
mut
self
.
value
)
}
}
trait
Entries
{
type
Entry
;
fn
into_entries
(
self
)
-
>
Vec
<
Self
:
:
Entry
>
;
fn
as_entries
(
&
self
)
-
>
&
[
Self
:
:
Entry
]
;
fn
as_entries_mut
(
&
mut
self
)
-
>
&
mut
[
Self
:
:
Entry
]
;
fn
with_entries
<
F
>
(
&
mut
self
f
:
F
)
where
F
:
FnOnce
(
&
mut
[
Self
:
:
Entry
]
)
;
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
struct
TryReserveError
{
kind
:
TryReserveErrorKind
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
enum
TryReserveErrorKind
{
Std
(
alloc
:
:
collections
:
:
TryReserveError
)
CapacityOverflow
AllocError
{
layout
:
alloc
:
:
alloc
:
:
Layout
}
}
impl
TryReserveError
{
fn
from_alloc
(
error
:
alloc
:
:
collections
:
:
TryReserveError
)
-
>
Self
{
Self
{
kind
:
TryReserveErrorKind
:
:
Std
(
error
)
}
}
fn
from_hashbrown
(
error
:
hashbrown
:
:
TryReserveError
)
-
>
Self
{
Self
{
kind
:
match
error
{
hashbrown
:
:
TryReserveError
:
:
CapacityOverflow
=
>
{
TryReserveErrorKind
:
:
CapacityOverflow
}
hashbrown
:
:
TryReserveError
:
:
AllocError
{
layout
}
=
>
{
TryReserveErrorKind
:
:
AllocError
{
layout
}
}
}
}
}
}
impl
core
:
:
fmt
:
:
Display
for
TryReserveError
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
let
reason
=
match
&
self
.
kind
{
TryReserveErrorKind
:
:
Std
(
e
)
=
>
return
core
:
:
fmt
:
:
Display
:
:
fmt
(
e
f
)
TryReserveErrorKind
:
:
CapacityOverflow
=
>
{
"
because
the
computed
capacity
exceeded
the
collection
'
s
maximum
"
}
TryReserveErrorKind
:
:
AllocError
{
.
.
}
=
>
{
"
because
the
memory
allocator
returned
an
error
"
}
}
;
f
.
write_str
(
"
memory
allocation
failed
"
)
?
;
f
.
write_str
(
reason
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
std
:
:
error
:
:
Error
for
TryReserveError
{
}
