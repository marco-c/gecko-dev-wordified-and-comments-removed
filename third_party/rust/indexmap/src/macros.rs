#
[
macro_export
]
macro_rules
!
indexmap
{
(
single
(
x
:
tt
)
*
)
=
>
(
(
)
)
;
(
count
(
rest
:
expr
)
*
)
=
>
(
<
[
(
)
]
>
:
:
len
(
&
[
(
indexmap
!
(
single
rest
)
)
*
]
)
)
;
(
(
key
:
expr
=
>
value
:
expr
)
+
)
=
>
{
indexmap
!
(
(
key
=
>
value
)
+
)
}
;
(
(
key
:
expr
=
>
value
:
expr
)
*
)
=
>
{
{
let
_cap
=
indexmap
!
(
count
(
key
)
*
)
;
let
mut
_map
=
crate
:
:
IndexMap
:
:
with_capacity
(
_cap
)
;
(
_map
.
insert
(
key
value
)
;
)
*
_map
}
}
;
}
#
[
macro_export
]
macro_rules
!
indexset
{
(
single
(
x
:
tt
)
*
)
=
>
(
(
)
)
;
(
count
(
rest
:
expr
)
*
)
=
>
(
<
[
(
)
]
>
:
:
len
(
&
[
(
indexset
!
(
single
rest
)
)
*
]
)
)
;
(
(
value
:
expr
)
+
)
=
>
{
indexset
!
(
(
value
)
+
)
}
;
(
(
value
:
expr
)
*
)
=
>
{
{
let
_cap
=
indexset
!
(
count
(
value
)
*
)
;
let
mut
_set
=
crate
:
:
IndexSet
:
:
with_capacity
(
_cap
)
;
(
_set
.
insert
(
value
)
;
)
*
_set
}
}
;
}
macro_rules
!
iterator_methods
{
(
map_elt
:
expr
)
=
>
{
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
.
map
(
map_elt
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
fn
count
(
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
fn
nth
(
&
mut
self
n
:
usize
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
nth
(
n
)
.
map
(
map_elt
)
}
fn
last
(
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
next_back
(
)
}
fn
collect
<
C
>
(
self
)
-
>
C
where
C
:
FromIterator
<
Self
:
:
Item
>
{
/
/
NB
:
forwarding
this
directly
to
standard
iterators
will
/
/
allow
it
to
leverage
unstable
traits
like
TrustedLen
.
self
.
iter
.
map
(
map_elt
)
.
collect
(
)
}
}
}
macro_rules
!
double_ended_iterator_methods
{
(
map_elt
:
expr
)
=
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next_back
(
)
.
map
(
map_elt
)
}
}
}
