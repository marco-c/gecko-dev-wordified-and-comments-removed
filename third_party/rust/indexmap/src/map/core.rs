mod
raw
;
use
hashbrown
:
:
raw
:
:
RawTable
;
use
crate
:
:
vec
:
:
{
Drain
Vec
}
;
use
core
:
:
cmp
;
use
core
:
:
fmt
;
use
core
:
:
mem
:
:
replace
;
use
core
:
:
ops
:
:
RangeBounds
;
use
crate
:
:
equivalent
:
:
Equivalent
;
use
crate
:
:
util
:
:
simplify_range
;
use
crate
:
:
{
Bucket
Entries
HashValue
}
;
pub
(
crate
)
struct
IndexMapCore
<
K
V
>
{
indices
:
RawTable
<
usize
>
entries
:
Vec
<
Bucket
<
K
V
>
>
}
#
[
inline
(
always
)
]
fn
get_hash
<
K
V
>
(
entries
:
&
[
Bucket
<
K
V
>
]
)
-
>
impl
Fn
(
&
usize
)
-
>
u64
+
'
_
{
move
|
&
i
|
entries
[
i
]
.
hash
.
get
(
)
}
#
[
inline
]
fn
equivalent
<
'
a
K
V
Q
:
?
Sized
+
Equivalent
<
K
>
>
(
key
:
&
'
a
Q
entries
:
&
'
a
[
Bucket
<
K
V
>
]
)
-
>
impl
Fn
(
&
usize
)
-
>
bool
+
'
a
{
move
|
&
i
|
Q
:
:
equivalent
(
key
&
entries
[
i
]
.
key
)
}
#
[
inline
]
fn
erase_index
(
table
:
&
mut
RawTable
<
usize
>
hash
:
HashValue
index
:
usize
)
{
let
erased
=
table
.
erase_entry
(
hash
.
get
(
)
move
|
&
i
|
i
=
=
index
)
;
debug_assert
!
(
erased
)
;
}
#
[
inline
]
fn
update_index
(
table
:
&
mut
RawTable
<
usize
>
hash
:
HashValue
old
:
usize
new
:
usize
)
{
let
index
=
table
.
get_mut
(
hash
.
get
(
)
move
|
&
i
|
i
=
=
old
)
.
expect
(
"
index
not
found
"
)
;
*
index
=
new
;
}
impl
<
K
V
>
Clone
for
IndexMapCore
<
K
V
>
where
K
:
Clone
V
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
let
indices
=
self
.
indices
.
clone
(
)
;
let
mut
entries
=
Vec
:
:
with_capacity
(
indices
.
capacity
(
)
)
;
entries
.
clone_from
(
&
self
.
entries
)
;
IndexMapCore
{
indices
entries
}
}
fn
clone_from
(
&
mut
self
other
:
&
Self
)
{
let
hasher
=
get_hash
(
&
other
.
entries
)
;
self
.
indices
.
clone_from_with_hasher
(
&
other
.
indices
hasher
)
;
if
self
.
entries
.
capacity
(
)
<
other
.
entries
.
len
(
)
{
self
.
reserve_entries
(
)
;
}
self
.
entries
.
clone_from
(
&
other
.
entries
)
;
}
}
impl
<
K
V
>
fmt
:
:
Debug
for
IndexMapCore
<
K
V
>
where
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
IndexMapCore
"
)
.
field
(
"
indices
"
&
raw
:
:
DebugIndices
(
&
self
.
indices
)
)
.
field
(
"
entries
"
&
self
.
entries
)
.
finish
(
)
}
}
impl
<
K
V
>
Entries
for
IndexMapCore
<
K
V
>
{
type
Entry
=
Bucket
<
K
V
>
;
#
[
inline
]
fn
into_entries
(
self
)
-
>
Vec
<
Self
:
:
Entry
>
{
self
.
entries
}
#
[
inline
]
fn
as_entries
(
&
self
)
-
>
&
[
Self
:
:
Entry
]
{
&
self
.
entries
}
#
[
inline
]
fn
as_entries_mut
(
&
mut
self
)
-
>
&
mut
[
Self
:
:
Entry
]
{
&
mut
self
.
entries
}
fn
with_entries
<
F
>
(
&
mut
self
f
:
F
)
where
F
:
FnOnce
(
&
mut
[
Self
:
:
Entry
]
)
{
f
(
&
mut
self
.
entries
)
;
self
.
rebuild_hash_table
(
)
;
}
}
impl
<
K
V
>
IndexMapCore
<
K
V
>
{
#
[
inline
]
pub
(
crate
)
const
fn
new
(
)
-
>
Self
{
IndexMapCore
{
indices
:
RawTable
:
:
new
(
)
entries
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
(
crate
)
fn
with_capacity
(
n
:
usize
)
-
>
Self
{
IndexMapCore
{
indices
:
RawTable
:
:
with_capacity
(
n
)
entries
:
Vec
:
:
with_capacity
(
n
)
}
}
#
[
inline
]
pub
(
crate
)
fn
len
(
&
self
)
-
>
usize
{
self
.
indices
.
len
(
)
}
#
[
inline
]
pub
(
crate
)
fn
capacity
(
&
self
)
-
>
usize
{
cmp
:
:
min
(
self
.
indices
.
capacity
(
)
self
.
entries
.
capacity
(
)
)
}
pub
(
crate
)
fn
clear
(
&
mut
self
)
{
self
.
indices
.
clear
(
)
;
self
.
entries
.
clear
(
)
;
}
pub
(
crate
)
fn
truncate
(
&
mut
self
len
:
usize
)
{
if
len
<
self
.
len
(
)
{
self
.
erase_indices
(
len
self
.
entries
.
len
(
)
)
;
self
.
entries
.
truncate
(
len
)
;
}
}
pub
(
crate
)
fn
drain
<
R
>
(
&
mut
self
range
:
R
)
-
>
Drain
<
'
_
Bucket
<
K
V
>
>
where
R
:
RangeBounds
<
usize
>
{
let
range
=
simplify_range
(
range
self
.
entries
.
len
(
)
)
;
self
.
erase_indices
(
range
.
start
range
.
end
)
;
self
.
entries
.
drain
(
range
)
}
#
[
cfg
(
feature
=
"
rayon
"
)
]
pub
(
crate
)
fn
par_drain
<
R
>
(
&
mut
self
range
:
R
)
-
>
rayon
:
:
vec
:
:
Drain
<
'
_
Bucket
<
K
V
>
>
where
K
:
Send
V
:
Send
R
:
RangeBounds
<
usize
>
{
use
rayon
:
:
iter
:
:
ParallelDrainRange
;
let
range
=
simplify_range
(
range
self
.
entries
.
len
(
)
)
;
self
.
erase_indices
(
range
.
start
range
.
end
)
;
self
.
entries
.
par_drain
(
range
)
}
pub
(
crate
)
fn
split_off
(
&
mut
self
at
:
usize
)
-
>
Self
{
assert
!
(
at
<
=
self
.
entries
.
len
(
)
)
;
self
.
erase_indices
(
at
self
.
entries
.
len
(
)
)
;
let
entries
=
self
.
entries
.
split_off
(
at
)
;
let
mut
indices
=
RawTable
:
:
with_capacity
(
entries
.
len
(
)
)
;
raw
:
:
insert_bulk_no_grow
(
&
mut
indices
&
entries
)
;
Self
{
indices
entries
}
}
pub
(
crate
)
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
indices
.
reserve
(
additional
get_hash
(
&
self
.
entries
)
)
;
self
.
reserve_entries
(
)
;
}
fn
reserve_entries
(
&
mut
self
)
{
let
additional
=
self
.
indices
.
capacity
(
)
-
self
.
entries
.
len
(
)
;
self
.
entries
.
reserve_exact
(
additional
)
;
}
pub
(
crate
)
fn
shrink_to
(
&
mut
self
min_capacity
:
usize
)
{
self
.
indices
.
shrink_to
(
min_capacity
get_hash
(
&
self
.
entries
)
)
;
self
.
entries
.
shrink_to
(
min_capacity
)
;
}
pub
(
crate
)
fn
pop
(
&
mut
self
)
-
>
Option
<
(
K
V
)
>
{
if
let
Some
(
entry
)
=
self
.
entries
.
pop
(
)
{
let
last
=
self
.
entries
.
len
(
)
;
erase_index
(
&
mut
self
.
indices
entry
.
hash
last
)
;
Some
(
(
entry
.
key
entry
.
value
)
)
}
else
{
None
}
}
fn
push
(
&
mut
self
hash
:
HashValue
key
:
K
value
:
V
)
-
>
usize
{
let
i
=
self
.
entries
.
len
(
)
;
self
.
indices
.
insert
(
hash
.
get
(
)
i
get_hash
(
&
self
.
entries
)
)
;
if
i
=
=
self
.
entries
.
capacity
(
)
{
self
.
reserve_entries
(
)
;
}
self
.
entries
.
push
(
Bucket
{
hash
key
value
}
)
;
i
}
pub
(
crate
)
fn
get_index_of
<
Q
>
(
&
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
usize
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
let
eq
=
equivalent
(
key
&
self
.
entries
)
;
self
.
indices
.
get
(
hash
.
get
(
)
eq
)
.
copied
(
)
}
pub
(
crate
)
fn
insert_full
(
&
mut
self
hash
:
HashValue
key
:
K
value
:
V
)
-
>
(
usize
Option
<
V
>
)
where
K
:
Eq
{
match
self
.
get_index_of
(
hash
&
key
)
{
Some
(
i
)
=
>
(
i
Some
(
replace
(
&
mut
self
.
entries
[
i
]
.
value
value
)
)
)
None
=
>
(
self
.
push
(
hash
key
value
)
None
)
}
}
pub
(
crate
)
fn
shift_remove_full
<
Q
>
(
&
mut
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
(
usize
K
V
)
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
let
eq
=
equivalent
(
key
&
self
.
entries
)
;
match
self
.
indices
.
remove_entry
(
hash
.
get
(
)
eq
)
{
Some
(
index
)
=
>
{
let
(
key
value
)
=
self
.
shift_remove_finish
(
index
)
;
Some
(
(
index
key
value
)
)
}
None
=
>
None
}
}
pub
(
crate
)
fn
shift_remove_index
(
&
mut
self
index
:
usize
)
-
>
Option
<
(
K
V
)
>
{
match
self
.
entries
.
get
(
index
)
{
Some
(
entry
)
=
>
{
erase_index
(
&
mut
self
.
indices
entry
.
hash
index
)
;
Some
(
self
.
shift_remove_finish
(
index
)
)
}
None
=
>
None
}
}
fn
shift_remove_finish
(
&
mut
self
index
:
usize
)
-
>
(
K
V
)
{
self
.
decrement_indices
(
index
+
1
self
.
entries
.
len
(
)
)
;
let
entry
=
self
.
entries
.
remove
(
index
)
;
(
entry
.
key
entry
.
value
)
}
fn
decrement_indices
(
&
mut
self
start
:
usize
end
:
usize
)
{
let
shifted_entries
=
&
self
.
entries
[
start
.
.
end
]
;
if
shifted_entries
.
len
(
)
>
self
.
indices
.
buckets
(
)
/
2
{
for
i
in
self
.
indices_mut
(
)
{
if
start
<
=
*
i
&
&
*
i
<
end
{
*
i
-
=
1
;
}
}
}
else
{
for
(
i
entry
)
in
(
start
.
.
end
)
.
zip
(
shifted_entries
)
{
update_index
(
&
mut
self
.
indices
entry
.
hash
i
i
-
1
)
;
}
}
}
fn
increment_indices
(
&
mut
self
start
:
usize
end
:
usize
)
{
let
shifted_entries
=
&
self
.
entries
[
start
.
.
end
]
;
if
shifted_entries
.
len
(
)
>
self
.
indices
.
buckets
(
)
/
2
{
for
i
in
self
.
indices_mut
(
)
{
if
start
<
=
*
i
&
&
*
i
<
end
{
*
i
+
=
1
;
}
}
}
else
{
for
(
i
entry
)
in
(
start
.
.
end
)
.
zip
(
shifted_entries
)
.
rev
(
)
{
update_index
(
&
mut
self
.
indices
entry
.
hash
i
i
+
1
)
;
}
}
}
pub
(
super
)
fn
move_index
(
&
mut
self
from
:
usize
to
:
usize
)
{
let
from_hash
=
self
.
entries
[
from
]
.
hash
;
if
from
!
=
to
{
update_index
(
&
mut
self
.
indices
from_hash
from
usize
:
:
MAX
)
;
if
from
<
to
{
self
.
decrement_indices
(
from
+
1
to
+
1
)
;
self
.
entries
[
from
.
.
=
to
]
.
rotate_left
(
1
)
;
}
else
if
to
<
from
{
self
.
increment_indices
(
to
from
)
;
self
.
entries
[
to
.
.
=
from
]
.
rotate_right
(
1
)
;
}
update_index
(
&
mut
self
.
indices
from_hash
usize
:
:
MAX
to
)
;
}
}
pub
(
crate
)
fn
swap_remove_full
<
Q
>
(
&
mut
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
(
usize
K
V
)
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
let
eq
=
equivalent
(
key
&
self
.
entries
)
;
match
self
.
indices
.
remove_entry
(
hash
.
get
(
)
eq
)
{
Some
(
index
)
=
>
{
let
(
key
value
)
=
self
.
swap_remove_finish
(
index
)
;
Some
(
(
index
key
value
)
)
}
None
=
>
None
}
}
pub
(
crate
)
fn
swap_remove_index
(
&
mut
self
index
:
usize
)
-
>
Option
<
(
K
V
)
>
{
match
self
.
entries
.
get
(
index
)
{
Some
(
entry
)
=
>
{
erase_index
(
&
mut
self
.
indices
entry
.
hash
index
)
;
Some
(
self
.
swap_remove_finish
(
index
)
)
}
None
=
>
None
}
}
fn
swap_remove_finish
(
&
mut
self
index
:
usize
)
-
>
(
K
V
)
{
let
entry
=
self
.
entries
.
swap_remove
(
index
)
;
if
let
Some
(
entry
)
=
self
.
entries
.
get
(
index
)
{
let
last
=
self
.
entries
.
len
(
)
;
update_index
(
&
mut
self
.
indices
entry
.
hash
last
index
)
;
}
(
entry
.
key
entry
.
value
)
}
fn
erase_indices
(
&
mut
self
start
:
usize
end
:
usize
)
{
let
(
init
shifted_entries
)
=
self
.
entries
.
split_at
(
end
)
;
let
(
start_entries
erased_entries
)
=
init
.
split_at
(
start
)
;
let
erased
=
erased_entries
.
len
(
)
;
let
shifted
=
shifted_entries
.
len
(
)
;
let
half_capacity
=
self
.
indices
.
buckets
(
)
/
2
;
if
erased
=
=
0
{
}
else
if
start
+
shifted
<
half_capacity
&
&
start
<
erased
{
self
.
indices
.
clear
(
)
;
raw
:
:
insert_bulk_no_grow
(
&
mut
self
.
indices
start_entries
)
;
raw
:
:
insert_bulk_no_grow
(
&
mut
self
.
indices
shifted_entries
)
;
}
else
if
erased
+
shifted
<
half_capacity
{
for
(
i
entry
)
in
(
start
.
.
)
.
zip
(
erased_entries
)
{
erase_index
(
&
mut
self
.
indices
entry
.
hash
i
)
;
}
for
(
(
new
old
)
entry
)
in
(
start
.
.
)
.
zip
(
end
.
.
)
.
zip
(
shifted_entries
)
{
update_index
(
&
mut
self
.
indices
entry
.
hash
old
new
)
;
}
}
else
{
self
.
erase_indices_sweep
(
start
end
)
;
}
debug_assert_eq
!
(
self
.
indices
.
len
(
)
start
+
shifted
)
;
}
pub
(
crate
)
fn
retain_in_order
<
F
>
(
&
mut
self
mut
keep
:
F
)
where
F
:
FnMut
(
&
mut
K
&
mut
V
)
-
>
bool
{
let
len
=
self
.
entries
.
len
(
)
;
let
mut
n_deleted
=
0
;
for
i
in
0
.
.
len
{
let
will_keep
=
{
let
entry
=
&
mut
self
.
entries
[
i
]
;
keep
(
&
mut
entry
.
key
&
mut
entry
.
value
)
}
;
if
!
will_keep
{
n_deleted
+
=
1
;
}
else
if
n_deleted
>
0
{
self
.
entries
.
swap
(
i
-
n_deleted
i
)
;
}
}
if
n_deleted
>
0
{
self
.
entries
.
truncate
(
len
-
n_deleted
)
;
self
.
rebuild_hash_table
(
)
;
}
}
fn
rebuild_hash_table
(
&
mut
self
)
{
self
.
indices
.
clear
(
)
;
raw
:
:
insert_bulk_no_grow
(
&
mut
self
.
indices
&
self
.
entries
)
;
}
pub
(
crate
)
fn
reverse
(
&
mut
self
)
{
self
.
entries
.
reverse
(
)
;
let
len
=
self
.
entries
.
len
(
)
;
for
i
in
self
.
indices_mut
(
)
{
*
i
=
len
-
*
i
-
1
;
}
}
}
pub
enum
Entry
<
'
a
K
V
>
{
Occupied
(
OccupiedEntry
<
'
a
K
V
>
)
Vacant
(
VacantEntry
<
'
a
K
V
>
)
}
impl
<
'
a
K
V
>
Entry
<
'
a
K
V
>
{
pub
fn
or_insert
(
self
default
:
V
)
-
>
&
'
a
mut
V
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
default
)
}
}
pub
fn
or_insert_with
<
F
>
(
self
call
:
F
)
-
>
&
'
a
mut
V
where
F
:
FnOnce
(
)
-
>
V
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
call
(
)
)
}
}
pub
fn
or_insert_with_key
<
F
>
(
self
call
:
F
)
-
>
&
'
a
mut
V
where
F
:
FnOnce
(
&
K
)
-
>
V
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
{
let
value
=
call
(
&
entry
.
key
)
;
entry
.
insert
(
value
)
}
}
}
pub
fn
key
(
&
self
)
-
>
&
K
{
match
*
self
{
Entry
:
:
Occupied
(
ref
entry
)
=
>
entry
.
key
(
)
Entry
:
:
Vacant
(
ref
entry
)
=
>
entry
.
key
(
)
}
}
pub
fn
index
(
&
self
)
-
>
usize
{
match
*
self
{
Entry
:
:
Occupied
(
ref
entry
)
=
>
entry
.
index
(
)
Entry
:
:
Vacant
(
ref
entry
)
=
>
entry
.
index
(
)
}
}
pub
fn
and_modify
<
F
>
(
self
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
&
mut
V
)
{
match
self
{
Entry
:
:
Occupied
(
mut
o
)
=
>
{
f
(
o
.
get_mut
(
)
)
;
Entry
:
:
Occupied
(
o
)
}
x
=
>
x
}
}
pub
fn
or_default
(
self
)
-
>
&
'
a
mut
V
where
V
:
Default
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
V
:
:
default
(
)
)
}
}
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Entry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Entry
:
:
Vacant
(
ref
v
)
=
>
f
.
debug_tuple
(
stringify
!
(
Entry
)
)
.
field
(
v
)
.
finish
(
)
Entry
:
:
Occupied
(
ref
o
)
=
>
f
.
debug_tuple
(
stringify
!
(
Entry
)
)
.
field
(
o
)
.
finish
(
)
}
}
}
pub
use
self
:
:
raw
:
:
OccupiedEntry
;
impl
<
K
V
>
OccupiedEntry
<
'
_
K
V
>
{
pub
fn
insert
(
&
mut
self
value
:
V
)
-
>
V
{
replace
(
self
.
get_mut
(
)
value
)
}
pub
fn
remove
(
self
)
-
>
V
{
self
.
swap_remove
(
)
}
pub
fn
swap_remove
(
self
)
-
>
V
{
self
.
swap_remove_entry
(
)
.
1
}
pub
fn
shift_remove
(
self
)
-
>
V
{
self
.
shift_remove_entry
(
)
.
1
}
pub
fn
remove_entry
(
self
)
-
>
(
K
V
)
{
self
.
swap_remove_entry
(
)
}
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
OccupiedEntry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
stringify
!
(
OccupiedEntry
)
)
.
field
(
"
key
"
self
.
key
(
)
)
.
field
(
"
value
"
self
.
get
(
)
)
.
finish
(
)
}
}
pub
struct
VacantEntry
<
'
a
K
V
>
{
map
:
&
'
a
mut
IndexMapCore
<
K
V
>
hash
:
HashValue
key
:
K
}
impl
<
'
a
K
V
>
VacantEntry
<
'
a
K
V
>
{
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
key
}
pub
fn
into_key
(
self
)
-
>
K
{
self
.
key
}
pub
fn
index
(
&
self
)
-
>
usize
{
self
.
map
.
len
(
)
}
pub
fn
insert
(
self
value
:
V
)
-
>
&
'
a
mut
V
{
let
i
=
self
.
map
.
push
(
self
.
hash
self
.
key
value
)
;
&
mut
self
.
map
.
entries
[
i
]
.
value
}
}
impl
<
K
:
fmt
:
:
Debug
V
>
fmt
:
:
Debug
for
VacantEntry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
stringify
!
(
VacantEntry
)
)
.
field
(
self
.
key
(
)
)
.
finish
(
)
}
}
#
[
test
]
fn
assert_send_sync
(
)
{
fn
assert_send_sync
<
T
:
Send
+
Sync
>
(
)
{
}
assert_send_sync
:
:
<
IndexMapCore
<
i32
i32
>
>
(
)
;
assert_send_sync
:
:
<
Entry
<
'
_
i32
i32
>
>
(
)
;
}
