#
!
[
allow
(
unsafe_code
)
]
use
super
:
:
{
Entry
Equivalent
HashValue
IndexMapCore
VacantEntry
}
;
use
crate
:
:
util
:
:
enumerate
;
use
core
:
:
fmt
;
use
core
:
:
mem
:
:
replace
;
use
hashbrown
:
:
raw
:
:
RawTable
;
type
RawBucket
=
hashbrown
:
:
raw
:
:
Bucket
<
usize
>
;
pub
(
super
)
struct
DebugIndices
<
'
a
>
(
pub
&
'
a
RawTable
<
usize
>
)
;
impl
fmt
:
:
Debug
for
DebugIndices
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
indices
=
unsafe
{
self
.
0
.
iter
(
)
.
map
(
|
raw_bucket
|
raw_bucket
.
read
(
)
)
}
;
f
.
debug_list
(
)
.
entries
(
indices
)
.
finish
(
)
}
}
impl
<
K
V
>
IndexMapCore
<
K
V
>
{
fn
find_equivalent
<
Q
>
(
&
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
RawBucket
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
self
.
indices
.
find
(
hash
.
get
(
)
{
move
|
&
i
|
Q
:
:
equivalent
(
key
&
self
.
entries
[
i
]
.
key
)
}
)
}
fn
find_index
(
&
self
hash
:
HashValue
index
:
usize
)
-
>
Option
<
RawBucket
>
{
self
.
indices
.
find
(
hash
.
get
(
)
move
|
&
i
|
i
=
=
index
)
}
pub
(
crate
)
fn
get_index_of
<
Q
>
(
&
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
usize
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
match
self
.
find_equivalent
(
hash
key
)
{
Some
(
raw_bucket
)
=
>
Some
(
unsafe
{
raw_bucket
.
read
(
)
}
)
None
=
>
None
}
}
pub
(
super
)
fn
erase_index
(
&
mut
self
hash
:
HashValue
index
:
usize
)
{
debug_assert_eq
!
(
index
self
.
indices
.
len
(
)
-
1
)
;
let
raw_bucket
=
self
.
find_index
(
hash
index
)
.
unwrap
(
)
;
unsafe
{
self
.
indices
.
erase
(
raw_bucket
)
}
;
}
pub
(
super
)
fn
erase_indices
(
&
mut
self
start
:
usize
end
:
usize
)
{
let
(
init
shifted_entries
)
=
self
.
entries
.
split_at
(
end
)
;
let
(
start_entries
erased_entries
)
=
init
.
split_at
(
start
)
;
let
erased
=
erased_entries
.
len
(
)
;
let
shifted
=
shifted_entries
.
len
(
)
;
let
half_capacity
=
self
.
indices
.
buckets
(
)
/
2
;
if
erased
=
=
0
{
}
else
if
start
+
shifted
<
half_capacity
&
&
start
<
erased
{
self
.
indices
.
clear
(
)
;
for
(
i
entry
)
in
enumerate
(
start_entries
)
{
self
.
indices
.
insert_no_grow
(
entry
.
hash
.
get
(
)
i
)
;
}
for
(
i
entry
)
in
(
start
.
.
)
.
zip
(
shifted_entries
)
{
self
.
indices
.
insert_no_grow
(
entry
.
hash
.
get
(
)
i
)
;
}
}
else
if
erased
+
shifted
<
half_capacity
{
for
(
i
entry
)
in
(
start
.
.
)
.
zip
(
erased_entries
)
{
let
bucket
=
self
.
find_index
(
entry
.
hash
i
)
.
unwrap
(
)
;
unsafe
{
self
.
indices
.
erase
(
bucket
)
}
;
}
for
(
(
new
old
)
entry
)
in
(
start
.
.
)
.
zip
(
end
.
.
)
.
zip
(
shifted_entries
)
{
let
bucket
=
self
.
find_index
(
entry
.
hash
old
)
.
unwrap
(
)
;
unsafe
{
bucket
.
write
(
new
)
}
;
}
}
else
{
unsafe
{
for
bucket
in
self
.
indices
.
iter
(
)
{
let
i
=
bucket
.
read
(
)
;
if
i
>
=
end
{
bucket
.
write
(
i
-
erased
)
;
}
else
if
i
>
=
start
{
self
.
indices
.
erase
(
bucket
)
;
}
}
}
}
debug_assert_eq
!
(
self
.
indices
.
len
(
)
start
+
shifted
)
;
}
pub
(
crate
)
fn
entry
(
&
mut
self
hash
:
HashValue
key
:
K
)
-
>
Entry
<
'
_
K
V
>
where
K
:
Eq
{
match
self
.
find_equivalent
(
hash
&
key
)
{
Some
(
raw_bucket
)
=
>
Entry
:
:
Occupied
(
OccupiedEntry
{
map
:
self
raw_bucket
key
}
)
None
=
>
Entry
:
:
Vacant
(
VacantEntry
{
map
:
self
hash
key
}
)
}
}
pub
(
crate
)
fn
shift_remove_full
<
Q
>
(
&
mut
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
(
usize
K
V
)
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
match
self
.
find_equivalent
(
hash
key
)
{
Some
(
raw_bucket
)
=
>
unsafe
{
Some
(
self
.
shift_remove_bucket
(
raw_bucket
)
)
}
None
=
>
None
}
}
pub
(
crate
)
fn
shift_remove_index
(
&
mut
self
index
:
usize
)
-
>
Option
<
(
K
V
)
>
{
let
raw_bucket
=
match
self
.
entries
.
get
(
index
)
{
Some
(
entry
)
=
>
self
.
find_index
(
entry
.
hash
index
)
.
unwrap
(
)
None
=
>
return
None
}
;
unsafe
{
let
(
_
key
value
)
=
self
.
shift_remove_bucket
(
raw_bucket
)
;
Some
(
(
key
value
)
)
}
}
#
[
allow
(
unused_unsafe
)
]
unsafe
fn
shift_remove_bucket
(
&
mut
self
raw_bucket
:
RawBucket
)
-
>
(
usize
K
V
)
{
let
index
=
unsafe
{
self
.
indices
.
remove
(
raw_bucket
)
}
;
let
entry
=
self
.
entries
.
remove
(
index
)
;
let
raw_capacity
=
self
.
indices
.
buckets
(
)
;
let
shifted_entries
=
&
self
.
entries
[
index
.
.
]
;
if
shifted_entries
.
len
(
)
>
raw_capacity
/
2
{
unsafe
{
for
bucket
in
self
.
indices
.
iter
(
)
{
let
i
=
bucket
.
read
(
)
;
if
i
>
index
{
bucket
.
write
(
i
-
1
)
;
}
}
}
}
else
{
for
(
i
entry
)
in
(
index
+
1
.
.
)
.
zip
(
shifted_entries
)
{
let
shifted_bucket
=
self
.
find_index
(
entry
.
hash
i
)
.
unwrap
(
)
;
unsafe
{
shifted_bucket
.
write
(
i
-
1
)
}
;
}
}
(
index
entry
.
key
entry
.
value
)
}
pub
(
crate
)
fn
swap_remove_full
<
Q
>
(
&
mut
self
hash
:
HashValue
key
:
&
Q
)
-
>
Option
<
(
usize
K
V
)
>
where
Q
:
?
Sized
+
Equivalent
<
K
>
{
match
self
.
find_equivalent
(
hash
key
)
{
Some
(
raw_bucket
)
=
>
unsafe
{
Some
(
self
.
swap_remove_bucket
(
raw_bucket
)
)
}
None
=
>
None
}
}
pub
(
crate
)
fn
swap_remove_index
(
&
mut
self
index
:
usize
)
-
>
Option
<
(
K
V
)
>
{
let
raw_bucket
=
match
self
.
entries
.
get
(
index
)
{
Some
(
entry
)
=
>
self
.
find_index
(
entry
.
hash
index
)
.
unwrap
(
)
None
=
>
return
None
}
;
unsafe
{
let
(
_
key
value
)
=
self
.
swap_remove_bucket
(
raw_bucket
)
;
Some
(
(
key
value
)
)
}
}
#
[
allow
(
unused_unsafe
)
]
unsafe
fn
swap_remove_bucket
(
&
mut
self
raw_bucket
:
RawBucket
)
-
>
(
usize
K
V
)
{
let
index
=
unsafe
{
self
.
indices
.
remove
(
raw_bucket
)
}
;
let
entry
=
self
.
entries
.
swap_remove
(
index
)
;
if
let
Some
(
entry
)
=
self
.
entries
.
get
(
index
)
{
let
last
=
self
.
entries
.
len
(
)
;
let
swapped_bucket
=
self
.
find_index
(
entry
.
hash
last
)
.
unwrap
(
)
;
unsafe
{
swapped_bucket
.
write
(
index
)
}
;
}
(
index
entry
.
key
entry
.
value
)
}
pub
(
crate
)
fn
reverse
(
&
mut
self
)
{
self
.
entries
.
reverse
(
)
;
let
len
=
self
.
entries
.
len
(
)
;
unsafe
{
for
raw_bucket
in
self
.
indices
.
iter
(
)
{
let
i
=
raw_bucket
.
read
(
)
;
raw_bucket
.
write
(
len
-
i
-
1
)
;
}
}
}
}
pub
struct
OccupiedEntry
<
'
a
K
V
>
{
map
:
&
'
a
mut
IndexMapCore
<
K
V
>
raw_bucket
:
RawBucket
key
:
K
}
unsafe
impl
<
K
:
Sync
V
:
Sync
>
Sync
for
OccupiedEntry
<
'
_
K
V
>
{
}
impl
<
'
a
K
V
>
OccupiedEntry
<
'
a
K
V
>
{
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
key
}
pub
fn
get
(
&
self
)
-
>
&
V
{
&
self
.
map
.
entries
[
self
.
index
(
)
]
.
value
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
V
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
map
.
entries
[
index
]
.
value
}
pub
(
crate
)
fn
replace_key
(
self
)
-
>
K
{
let
index
=
self
.
index
(
)
;
let
old_key
=
&
mut
self
.
map
.
entries
[
index
]
.
key
;
replace
(
old_key
self
.
key
)
}
#
[
inline
]
pub
fn
index
(
&
self
)
-
>
usize
{
unsafe
{
self
.
raw_bucket
.
read
(
)
}
}
pub
fn
into_mut
(
self
)
-
>
&
'
a
mut
V
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
map
.
entries
[
index
]
.
value
}
pub
fn
swap_remove_entry
(
self
)
-
>
(
K
V
)
{
unsafe
{
let
(
_
key
value
)
=
self
.
map
.
swap_remove_bucket
(
self
.
raw_bucket
)
;
(
key
value
)
}
}
pub
fn
shift_remove_entry
(
self
)
-
>
(
K
V
)
{
unsafe
{
let
(
_
key
value
)
=
self
.
map
.
shift_remove_bucket
(
self
.
raw_bucket
)
;
(
key
value
)
}
}
}
