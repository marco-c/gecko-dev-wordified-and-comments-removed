#
!
[
allow
(
unsafe_code
)
]
use
super
:
:
{
equivalent
get_hash
Bucket
HashValue
IndexMapCore
}
;
use
hashbrown
:
:
raw
:
:
RawTable
;
type
RawBucket
=
hashbrown
:
:
raw
:
:
Bucket
<
usize
>
;
pub
(
super
)
fn
insert_bulk_no_grow
<
K
V
>
(
indices
:
&
mut
RawTable
<
usize
>
entries
:
&
[
Bucket
<
K
V
>
]
)
{
assert
!
(
indices
.
capacity
(
)
-
indices
.
len
(
)
>
=
entries
.
len
(
)
)
;
for
entry
in
entries
{
unsafe
{
indices
.
insert_no_grow
(
entry
.
hash
.
get
(
)
indices
.
len
(
)
)
;
}
}
}
#
[
cfg
(
feature
=
"
test_debug
"
)
]
pub
(
super
)
struct
DebugIndices
<
'
a
>
(
pub
&
'
a
RawTable
<
usize
>
)
;
#
[
cfg
(
feature
=
"
test_debug
"
)
]
impl
core
:
:
fmt
:
:
Debug
for
DebugIndices
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
let
indices
=
unsafe
{
self
.
0
.
iter
(
)
.
map
(
|
raw_bucket
|
*
raw_bucket
.
as_ref
(
)
)
}
;
f
.
debug_list
(
)
.
entries
(
indices
)
.
finish
(
)
}
}
impl
<
K
V
>
IndexMapCore
<
K
V
>
{
pub
(
super
)
fn
erase_indices_sweep
(
&
mut
self
start
:
usize
end
:
usize
)
{
unsafe
{
let
offset
=
end
-
start
;
for
bucket
in
self
.
indices
.
iter
(
)
{
let
i
=
bucket
.
as_mut
(
)
;
if
*
i
>
=
end
{
*
i
-
=
offset
;
}
else
if
*
i
>
=
start
{
self
.
indices
.
erase
(
bucket
)
;
}
}
}
}
pub
(
crate
)
fn
find_or_insert
(
&
mut
self
hash
:
HashValue
key
:
&
K
)
-
>
Result
<
usize
usize
>
where
K
:
Eq
{
let
hash
=
hash
.
get
(
)
;
let
eq
=
equivalent
(
key
&
self
.
entries
)
;
let
hasher
=
get_hash
(
&
self
.
entries
)
;
unsafe
{
match
self
.
indices
.
find_or_find_insert_slot
(
hash
eq
hasher
)
{
Ok
(
raw_bucket
)
=
>
Ok
(
*
raw_bucket
.
as_ref
(
)
)
Err
(
slot
)
=
>
{
let
index
=
self
.
indices
.
len
(
)
;
self
.
indices
.
insert_in_slot
(
hash
slot
index
)
;
Err
(
index
)
}
}
}
}
pub
(
super
)
fn
raw_entry
(
&
mut
self
hash
:
HashValue
mut
is_match
:
impl
FnMut
(
&
K
)
-
>
bool
)
-
>
Result
<
RawTableEntry
<
'
_
K
V
>
&
mut
Self
>
{
let
entries
=
&
*
self
.
entries
;
let
eq
=
move
|
&
i
:
&
usize
|
is_match
(
&
entries
[
i
]
.
key
)
;
match
self
.
indices
.
find
(
hash
.
get
(
)
eq
)
{
Some
(
raw_bucket
)
=
>
Ok
(
unsafe
{
RawTableEntry
:
:
new
(
self
raw_bucket
)
}
)
None
=
>
Err
(
self
)
}
}
pub
(
super
)
fn
index_raw_entry
(
&
mut
self
index
:
usize
)
-
>
Option
<
RawTableEntry
<
'
_
K
V
>
>
{
let
hash
=
self
.
entries
.
get
(
index
)
?
.
hash
;
let
raw_bucket
=
self
.
indices
.
find
(
hash
.
get
(
)
move
|
&
i
|
i
=
=
index
)
?
;
Some
(
unsafe
{
RawTableEntry
:
:
new
(
self
raw_bucket
)
}
)
}
pub
(
super
)
fn
indices_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
usize
>
{
unsafe
{
self
.
indices
.
iter
(
)
.
map
(
|
bucket
|
bucket
.
as_mut
(
)
)
}
}
}
pub
(
super
)
struct
RawTableEntry
<
'
a
K
V
>
{
map
:
&
'
a
mut
IndexMapCore
<
K
V
>
raw_bucket
:
RawBucket
}
unsafe
impl
<
K
:
Sync
V
:
Sync
>
Sync
for
RawTableEntry
<
'
_
K
V
>
{
}
impl
<
'
a
K
V
>
RawTableEntry
<
'
a
K
V
>
{
#
[
inline
]
unsafe
fn
new
(
map
:
&
'
a
mut
IndexMapCore
<
K
V
>
raw_bucket
:
RawBucket
)
-
>
Self
{
Self
{
map
raw_bucket
}
}
#
[
inline
]
pub
(
super
)
fn
index
(
&
self
)
-
>
usize
{
unsafe
{
*
self
.
raw_bucket
.
as_ref
(
)
}
}
#
[
inline
]
pub
(
super
)
fn
bucket
(
&
self
)
-
>
&
Bucket
<
K
V
>
{
&
self
.
map
.
entries
[
self
.
index
(
)
]
}
#
[
inline
]
pub
(
super
)
fn
bucket_mut
(
&
mut
self
)
-
>
&
mut
Bucket
<
K
V
>
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
map
.
entries
[
index
]
}
#
[
inline
]
pub
(
super
)
fn
into_bucket
(
self
)
-
>
&
'
a
mut
Bucket
<
K
V
>
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
map
.
entries
[
index
]
}
pub
(
super
)
fn
remove_index
(
self
)
-
>
(
&
'
a
mut
IndexMapCore
<
K
V
>
usize
)
{
let
(
index
_slot
)
=
unsafe
{
self
.
map
.
indices
.
remove
(
self
.
raw_bucket
)
}
;
(
self
.
map
index
)
}
#
[
inline
]
pub
(
super
)
fn
into_inner
(
self
)
-
>
(
&
'
a
mut
IndexMapCore
<
K
V
>
usize
)
{
let
index
=
self
.
index
(
)
;
(
self
.
map
index
)
}
}
