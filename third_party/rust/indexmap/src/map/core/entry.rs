use
super
:
:
{
equivalent
Entries
IndexMapCore
RefMut
}
;
use
crate
:
:
HashValue
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
{
fmt
mem
}
;
use
hashbrown
:
:
hash_table
;
impl
<
K
V
>
IndexMapCore
<
K
V
>
{
pub
(
crate
)
fn
entry
(
&
mut
self
hash
:
HashValue
key
:
K
)
-
>
Entry
<
'
_
K
V
>
where
K
:
Eq
{
let
entries
=
&
mut
self
.
entries
;
let
eq
=
equivalent
(
&
key
entries
)
;
match
self
.
indices
.
find_entry
(
hash
.
get
(
)
eq
)
{
Ok
(
index
)
=
>
Entry
:
:
Occupied
(
OccupiedEntry
{
entries
index
}
)
Err
(
absent
)
=
>
Entry
:
:
Vacant
(
VacantEntry
{
map
:
RefMut
:
:
new
(
absent
.
into_table
(
)
entries
)
hash
key
}
)
}
}
}
pub
enum
Entry
<
'
a
K
V
>
{
Occupied
(
OccupiedEntry
<
'
a
K
V
>
)
Vacant
(
VacantEntry
<
'
a
K
V
>
)
}
impl
<
'
a
K
V
>
Entry
<
'
a
K
V
>
{
pub
fn
index
(
&
self
)
-
>
usize
{
match
*
self
{
Entry
:
:
Occupied
(
ref
entry
)
=
>
entry
.
index
(
)
Entry
:
:
Vacant
(
ref
entry
)
=
>
entry
.
index
(
)
}
}
pub
fn
insert_entry
(
self
value
:
V
)
-
>
OccupiedEntry
<
'
a
K
V
>
{
match
self
{
Entry
:
:
Occupied
(
mut
entry
)
=
>
{
entry
.
insert
(
value
)
;
entry
}
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert_entry
(
value
)
}
}
pub
fn
or_insert
(
self
default
:
V
)
-
>
&
'
a
mut
V
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
default
)
}
}
pub
fn
or_insert_with
<
F
>
(
self
call
:
F
)
-
>
&
'
a
mut
V
where
F
:
FnOnce
(
)
-
>
V
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
call
(
)
)
}
}
pub
fn
or_insert_with_key
<
F
>
(
self
call
:
F
)
-
>
&
'
a
mut
V
where
F
:
FnOnce
(
&
K
)
-
>
V
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
{
let
value
=
call
(
&
entry
.
key
)
;
entry
.
insert
(
value
)
}
}
}
pub
fn
key
(
&
self
)
-
>
&
K
{
match
*
self
{
Entry
:
:
Occupied
(
ref
entry
)
=
>
entry
.
key
(
)
Entry
:
:
Vacant
(
ref
entry
)
=
>
entry
.
key
(
)
}
}
pub
fn
and_modify
<
F
>
(
mut
self
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
&
mut
V
)
{
if
let
Entry
:
:
Occupied
(
entry
)
=
&
mut
self
{
f
(
entry
.
get_mut
(
)
)
;
}
self
}
pub
fn
or_default
(
self
)
-
>
&
'
a
mut
V
where
V
:
Default
{
match
self
{
Entry
:
:
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Entry
:
:
Vacant
(
entry
)
=
>
entry
.
insert
(
V
:
:
default
(
)
)
}
}
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Entry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
tuple
=
f
.
debug_tuple
(
"
Entry
"
)
;
match
self
{
Entry
:
:
Vacant
(
v
)
=
>
tuple
.
field
(
v
)
Entry
:
:
Occupied
(
o
)
=
>
tuple
.
field
(
o
)
}
;
tuple
.
finish
(
)
}
}
pub
struct
OccupiedEntry
<
'
a
K
V
>
{
entries
:
&
'
a
mut
Entries
<
K
V
>
index
:
hash_table
:
:
OccupiedEntry
<
'
a
usize
>
}
impl
<
'
a
K
V
>
OccupiedEntry
<
'
a
K
V
>
{
pub
(
crate
)
fn
new
(
entries
:
&
'
a
mut
Entries
<
K
V
>
index
:
hash_table
:
:
OccupiedEntry
<
'
a
usize
>
)
-
>
Self
{
Self
{
entries
index
}
}
#
[
inline
]
pub
fn
index
(
&
self
)
-
>
usize
{
*
self
.
index
.
get
(
)
}
#
[
inline
]
fn
into_ref_mut
(
self
)
-
>
RefMut
<
'
a
K
V
>
{
RefMut
:
:
new
(
self
.
index
.
into_table
(
)
self
.
entries
)
}
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
entries
[
self
.
index
(
)
]
.
key
}
pub
(
crate
)
fn
key_mut
(
&
mut
self
)
-
>
&
mut
K
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
entries
[
index
]
.
key
}
pub
fn
get
(
&
self
)
-
>
&
V
{
&
self
.
entries
[
self
.
index
(
)
]
.
value
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
V
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
entries
[
index
]
.
value
}
pub
fn
into_mut
(
self
)
-
>
&
'
a
mut
V
{
let
index
=
self
.
index
(
)
;
&
mut
self
.
entries
[
index
]
.
value
}
pub
(
super
)
fn
into_muts
(
self
)
-
>
(
&
'
a
mut
K
&
'
a
mut
V
)
{
let
index
=
self
.
index
(
)
;
self
.
entries
[
index
]
.
muts
(
)
}
pub
fn
insert
(
&
mut
self
value
:
V
)
-
>
V
{
mem
:
:
replace
(
self
.
get_mut
(
)
value
)
}
#
[
deprecated
(
note
=
"
remove
disrupts
the
map
order
-
-
\
use
swap_remove
or
shift_remove
for
explicit
behavior
.
"
)
]
pub
fn
remove
(
self
)
-
>
V
{
self
.
swap_remove
(
)
}
pub
fn
swap_remove
(
self
)
-
>
V
{
self
.
swap_remove_entry
(
)
.
1
}
pub
fn
shift_remove
(
self
)
-
>
V
{
self
.
shift_remove_entry
(
)
.
1
}
#
[
deprecated
(
note
=
"
remove_entry
disrupts
the
map
order
-
-
\
use
swap_remove_entry
or
shift_remove_entry
for
explicit
behavior
.
"
)
]
pub
fn
remove_entry
(
self
)
-
>
(
K
V
)
{
self
.
swap_remove_entry
(
)
}
pub
fn
swap_remove_entry
(
self
)
-
>
(
K
V
)
{
let
(
index
entry
)
=
self
.
index
.
remove
(
)
;
RefMut
:
:
new
(
entry
.
into_table
(
)
self
.
entries
)
.
swap_remove_finish
(
index
)
}
pub
fn
shift_remove_entry
(
self
)
-
>
(
K
V
)
{
let
(
index
entry
)
=
self
.
index
.
remove
(
)
;
RefMut
:
:
new
(
entry
.
into_table
(
)
self
.
entries
)
.
shift_remove_finish
(
index
)
}
#
[
track_caller
]
pub
fn
move_index
(
self
to
:
usize
)
{
let
index
=
self
.
index
(
)
;
self
.
into_ref_mut
(
)
.
move_index
(
index
to
)
;
}
#
[
track_caller
]
pub
fn
swap_indices
(
self
other
:
usize
)
{
let
index
=
self
.
index
(
)
;
self
.
into_ref_mut
(
)
.
swap_indices
(
index
other
)
;
}
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
OccupiedEntry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
OccupiedEntry
"
)
.
field
(
"
key
"
self
.
key
(
)
)
.
field
(
"
value
"
self
.
get
(
)
)
.
finish
(
)
}
}
impl
<
'
a
K
V
>
From
<
IndexedEntry
<
'
a
K
V
>
>
for
OccupiedEntry
<
'
a
K
V
>
{
fn
from
(
other
:
IndexedEntry
<
'
a
K
V
>
)
-
>
Self
{
let
IndexedEntry
{
map
:
RefMut
{
indices
entries
}
index
}
=
other
;
let
hash
=
entries
[
index
]
.
hash
;
Self
{
entries
index
:
indices
.
find_entry
(
hash
.
get
(
)
move
|
&
i
|
i
=
=
index
)
.
expect
(
"
index
not
found
"
)
}
}
}
pub
struct
VacantEntry
<
'
a
K
V
>
{
map
:
RefMut
<
'
a
K
V
>
hash
:
HashValue
key
:
K
}
impl
<
'
a
K
V
>
VacantEntry
<
'
a
K
V
>
{
pub
fn
index
(
&
self
)
-
>
usize
{
self
.
map
.
indices
.
len
(
)
}
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
key
}
pub
(
crate
)
fn
key_mut
(
&
mut
self
)
-
>
&
mut
K
{
&
mut
self
.
key
}
pub
fn
into_key
(
self
)
-
>
K
{
self
.
key
}
pub
fn
insert
(
self
value
:
V
)
-
>
&
'
a
mut
V
{
self
.
insert_entry
(
value
)
.
into_mut
(
)
}
pub
fn
insert_entry
(
self
value
:
V
)
-
>
OccupiedEntry
<
'
a
K
V
>
{
let
Self
{
map
hash
key
}
=
self
;
map
.
insert_unique
(
hash
key
value
)
}
pub
fn
insert_sorted
(
self
value
:
V
)
-
>
(
usize
&
'
a
mut
V
)
where
K
:
Ord
{
let
slice
=
crate
:
:
map
:
:
Slice
:
:
from_slice
(
self
.
map
.
entries
)
;
let
i
=
slice
.
binary_search_keys
(
&
self
.
key
)
.
unwrap_err
(
)
;
(
i
self
.
shift_insert
(
i
value
)
)
}
pub
fn
insert_sorted_by
<
F
>
(
self
value
:
V
mut
cmp
:
F
)
-
>
(
usize
&
'
a
mut
V
)
where
F
:
FnMut
(
&
K
&
V
&
K
&
V
)
-
>
Ordering
{
let
slice
=
crate
:
:
map
:
:
Slice
:
:
from_slice
(
self
.
map
.
entries
)
;
let
(
Ok
(
i
)
|
Err
(
i
)
)
=
slice
.
binary_search_by
(
|
k
v
|
cmp
(
k
v
&
self
.
key
&
value
)
)
;
(
i
self
.
shift_insert
(
i
value
)
)
}
pub
fn
insert_sorted_by_key
<
B
F
>
(
self
value
:
V
mut
sort_key
:
F
)
-
>
(
usize
&
'
a
mut
V
)
where
B
:
Ord
F
:
FnMut
(
&
K
&
V
)
-
>
B
{
let
search_key
=
sort_key
(
&
self
.
key
&
value
)
;
let
slice
=
crate
:
:
map
:
:
Slice
:
:
from_slice
(
self
.
map
.
entries
)
;
let
(
Ok
(
i
)
|
Err
(
i
)
)
=
slice
.
binary_search_by_key
(
&
search_key
sort_key
)
;
(
i
self
.
shift_insert
(
i
value
)
)
}
#
[
track_caller
]
pub
fn
shift_insert
(
mut
self
index
:
usize
value
:
V
)
-
>
&
'
a
mut
V
{
self
.
map
.
shift_insert_unique
(
index
self
.
hash
self
.
key
value
)
;
&
mut
self
.
map
.
entries
[
index
]
.
value
}
#
[
track_caller
]
pub
fn
replace_index
(
self
index
:
usize
)
-
>
(
K
OccupiedEntry
<
'
a
K
V
>
)
{
self
.
map
.
replace_index_unique
(
index
self
.
hash
self
.
key
)
}
}
impl
<
K
:
fmt
:
:
Debug
V
>
fmt
:
:
Debug
for
VacantEntry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
VacantEntry
"
)
.
field
(
self
.
key
(
)
)
.
finish
(
)
}
}
pub
struct
IndexedEntry
<
'
a
K
V
>
{
map
:
RefMut
<
'
a
K
V
>
index
:
usize
}
impl
<
'
a
K
V
>
IndexedEntry
<
'
a
K
V
>
{
pub
(
crate
)
fn
new
(
map
:
&
'
a
mut
IndexMapCore
<
K
V
>
index
:
usize
)
-
>
Self
{
Self
{
map
:
map
.
borrow_mut
(
)
index
}
}
#
[
inline
]
pub
fn
index
(
&
self
)
-
>
usize
{
self
.
index
}
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
map
.
entries
[
self
.
index
]
.
key
}
pub
(
crate
)
fn
key_mut
(
&
mut
self
)
-
>
&
mut
K
{
&
mut
self
.
map
.
entries
[
self
.
index
]
.
key
}
pub
fn
get
(
&
self
)
-
>
&
V
{
&
self
.
map
.
entries
[
self
.
index
]
.
value
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
V
{
&
mut
self
.
map
.
entries
[
self
.
index
]
.
value
}
pub
fn
insert
(
&
mut
self
value
:
V
)
-
>
V
{
mem
:
:
replace
(
self
.
get_mut
(
)
value
)
}
pub
fn
into_mut
(
self
)
-
>
&
'
a
mut
V
{
&
mut
self
.
map
.
entries
[
self
.
index
]
.
value
}
pub
fn
swap_remove_entry
(
mut
self
)
-
>
(
K
V
)
{
self
.
map
.
swap_remove_index
(
self
.
index
)
.
unwrap
(
)
}
pub
fn
shift_remove_entry
(
mut
self
)
-
>
(
K
V
)
{
self
.
map
.
shift_remove_index
(
self
.
index
)
.
unwrap
(
)
}
pub
fn
swap_remove
(
self
)
-
>
V
{
self
.
swap_remove_entry
(
)
.
1
}
pub
fn
shift_remove
(
self
)
-
>
V
{
self
.
shift_remove_entry
(
)
.
1
}
#
[
track_caller
]
pub
fn
move_index
(
mut
self
to
:
usize
)
{
self
.
map
.
move_index
(
self
.
index
to
)
;
}
#
[
track_caller
]
pub
fn
swap_indices
(
mut
self
other
:
usize
)
{
self
.
map
.
swap_indices
(
self
.
index
other
)
;
}
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
IndexedEntry
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
IndexedEntry
"
)
.
field
(
"
index
"
&
self
.
index
)
.
field
(
"
key
"
self
.
key
(
)
)
.
field
(
"
value
"
self
.
get
(
)
)
.
finish
(
)
}
}
impl
<
'
a
K
V
>
From
<
OccupiedEntry
<
'
a
K
V
>
>
for
IndexedEntry
<
'
a
K
V
>
{
fn
from
(
other
:
OccupiedEntry
<
'
a
K
V
>
)
-
>
Self
{
Self
{
index
:
other
.
index
(
)
map
:
other
.
into_ref_mut
(
)
}
}
}
