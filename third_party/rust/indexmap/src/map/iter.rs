use
super
:
:
core
:
:
IndexMapCore
;
use
super
:
:
{
Bucket
Entries
IndexMap
Slice
}
;
use
alloc
:
:
vec
:
:
{
self
Vec
}
;
use
core
:
:
fmt
;
use
core
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
core
:
:
iter
:
:
FusedIterator
;
use
core
:
:
ops
:
:
{
Index
RangeBounds
}
;
use
core
:
:
slice
;
impl
<
'
a
K
V
S
>
IntoIterator
for
&
'
a
IndexMap
<
K
V
S
>
{
type
Item
=
(
&
'
a
K
&
'
a
V
)
;
type
IntoIter
=
Iter
<
'
a
K
V
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter
(
)
}
}
impl
<
'
a
K
V
S
>
IntoIterator
for
&
'
a
mut
IndexMap
<
K
V
S
>
{
type
Item
=
(
&
'
a
K
&
'
a
mut
V
)
;
type
IntoIter
=
IterMut
<
'
a
K
V
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter_mut
(
)
}
}
impl
<
K
V
S
>
IntoIterator
for
IndexMap
<
K
V
S
>
{
type
Item
=
(
K
V
)
;
type
IntoIter
=
IntoIter
<
K
V
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
IntoIter
:
:
new
(
self
.
into_entries
(
)
)
}
}
pub
struct
Iter
<
'
a
K
V
>
{
iter
:
slice
:
:
Iter
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
Iter
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
&
'
a
[
Bucket
<
K
V
>
]
)
-
>
Self
{
Self
{
iter
:
entries
.
iter
(
)
}
}
pub
fn
as_slice
(
&
self
)
-
>
&
'
a
Slice
<
K
V
>
{
Slice
:
:
from_slice
(
self
.
iter
.
as_slice
(
)
)
}
}
impl
<
'
a
K
V
>
Iterator
for
Iter
<
'
a
K
V
>
{
type
Item
=
(
&
'
a
K
&
'
a
V
)
;
iterator_methods
!
(
Bucket
:
:
refs
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
Iter
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
refs
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
Iter
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
Iter
<
'
_
K
V
>
{
}
impl
<
K
V
>
Clone
for
Iter
<
'
_
K
V
>
{
fn
clone
(
&
self
)
-
>
Self
{
Iter
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Iter
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
Iter
<
'
_
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter
(
)
}
}
}
pub
struct
IterMut
<
'
a
K
V
>
{
iter
:
slice
:
:
IterMut
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
IterMut
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
&
'
a
mut
[
Bucket
<
K
V
>
]
)
-
>
Self
{
Self
{
iter
:
entries
.
iter_mut
(
)
}
}
pub
fn
as_slice
(
&
self
)
-
>
&
Slice
<
K
V
>
{
Slice
:
:
from_slice
(
self
.
iter
.
as_slice
(
)
)
}
pub
fn
into_slice
(
self
)
-
>
&
'
a
mut
Slice
<
K
V
>
{
Slice
:
:
from_mut_slice
(
self
.
iter
.
into_slice
(
)
)
}
}
impl
<
'
a
K
V
>
Iterator
for
IterMut
<
'
a
K
V
>
{
type
Item
=
(
&
'
a
K
&
'
a
mut
V
)
;
iterator_methods
!
(
Bucket
:
:
ref_mut
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
IterMut
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
ref_mut
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
IterMut
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
IterMut
<
'
_
K
V
>
{
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
IterMut
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
refs
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
IterMut
<
'
_
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter_mut
(
)
}
}
}
pub
struct
IterMut2
<
'
a
K
V
>
{
iter
:
slice
:
:
IterMut
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
IterMut2
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
&
'
a
mut
[
Bucket
<
K
V
>
]
)
-
>
Self
{
Self
{
iter
:
entries
.
iter_mut
(
)
}
}
pub
fn
as_slice
(
&
self
)
-
>
&
Slice
<
K
V
>
{
Slice
:
:
from_slice
(
self
.
iter
.
as_slice
(
)
)
}
pub
fn
into_slice
(
self
)
-
>
&
'
a
mut
Slice
<
K
V
>
{
Slice
:
:
from_mut_slice
(
self
.
iter
.
into_slice
(
)
)
}
}
impl
<
'
a
K
V
>
Iterator
for
IterMut2
<
'
a
K
V
>
{
type
Item
=
(
&
'
a
mut
K
&
'
a
mut
V
)
;
iterator_methods
!
(
Bucket
:
:
muts
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
IterMut2
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
muts
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
IterMut2
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
IterMut2
<
'
_
K
V
>
{
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
IterMut2
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
refs
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
IterMut2
<
'
_
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter_mut
(
)
}
}
}
pub
struct
IntoIter
<
K
V
>
{
iter
:
vec
:
:
IntoIter
<
Bucket
<
K
V
>
>
}
impl
<
K
V
>
IntoIter
<
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
Vec
<
Bucket
<
K
V
>
>
)
-
>
Self
{
Self
{
iter
:
entries
.
into_iter
(
)
}
}
pub
fn
as_slice
(
&
self
)
-
>
&
Slice
<
K
V
>
{
Slice
:
:
from_slice
(
self
.
iter
.
as_slice
(
)
)
}
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
Slice
<
K
V
>
{
Slice
:
:
from_mut_slice
(
self
.
iter
.
as_mut_slice
(
)
)
}
}
impl
<
K
V
>
Iterator
for
IntoIter
<
K
V
>
{
type
Item
=
(
K
V
)
;
iterator_methods
!
(
Bucket
:
:
key_value
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
IntoIter
<
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
key_value
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
IntoIter
<
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
IntoIter
<
K
V
>
{
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
IntoIter
<
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
refs
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
IntoIter
<
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
Vec
:
:
new
(
)
.
into_iter
(
)
}
}
}
pub
struct
Drain
<
'
a
K
V
>
{
iter
:
vec
:
:
Drain
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
Drain
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
iter
:
vec
:
:
Drain
<
'
a
Bucket
<
K
V
>
>
)
-
>
Self
{
Self
{
iter
}
}
pub
fn
as_slice
(
&
self
)
-
>
&
Slice
<
K
V
>
{
Slice
:
:
from_slice
(
self
.
iter
.
as_slice
(
)
)
}
}
impl
<
K
V
>
Iterator
for
Drain
<
'
_
K
V
>
{
type
Item
=
(
K
V
)
;
iterator_methods
!
(
Bucket
:
:
key_value
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
Drain
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
key_value
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
Drain
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
Drain
<
'
_
K
V
>
{
}
impl
<
K
:
fmt
:
:
Debug
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Drain
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
refs
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
pub
struct
Keys
<
'
a
K
V
>
{
iter
:
slice
:
:
Iter
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
Keys
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
&
'
a
[
Bucket
<
K
V
>
]
)
-
>
Self
{
Self
{
iter
:
entries
.
iter
(
)
}
}
}
impl
<
'
a
K
V
>
Iterator
for
Keys
<
'
a
K
V
>
{
type
Item
=
&
'
a
K
;
iterator_methods
!
(
Bucket
:
:
key_ref
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
Keys
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
key_ref
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
Keys
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
Keys
<
'
_
K
V
>
{
}
impl
<
K
V
>
Clone
for
Keys
<
'
_
K
V
>
{
fn
clone
(
&
self
)
-
>
Self
{
Keys
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
K
:
fmt
:
:
Debug
V
>
fmt
:
:
Debug
for
Keys
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
Keys
<
'
_
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter
(
)
}
}
}
impl
<
'
a
K
V
>
Index
<
usize
>
for
Keys
<
'
a
K
V
>
{
type
Output
=
K
;
fn
index
(
&
self
index
:
usize
)
-
>
&
K
{
&
self
.
iter
.
as_slice
(
)
[
index
]
.
key
}
}
pub
struct
IntoKeys
<
K
V
>
{
iter
:
vec
:
:
IntoIter
<
Bucket
<
K
V
>
>
}
impl
<
K
V
>
IntoKeys
<
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
Vec
<
Bucket
<
K
V
>
>
)
-
>
Self
{
Self
{
iter
:
entries
.
into_iter
(
)
}
}
}
impl
<
K
V
>
Iterator
for
IntoKeys
<
K
V
>
{
type
Item
=
K
;
iterator_methods
!
(
Bucket
:
:
key
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
IntoKeys
<
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
key
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
IntoKeys
<
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
IntoKeys
<
K
V
>
{
}
impl
<
K
:
fmt
:
:
Debug
V
>
fmt
:
:
Debug
for
IntoKeys
<
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
key_ref
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
IntoKeys
<
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
Vec
:
:
new
(
)
.
into_iter
(
)
}
}
}
pub
struct
Values
<
'
a
K
V
>
{
iter
:
slice
:
:
Iter
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
Values
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
&
'
a
[
Bucket
<
K
V
>
]
)
-
>
Self
{
Self
{
iter
:
entries
.
iter
(
)
}
}
}
impl
<
'
a
K
V
>
Iterator
for
Values
<
'
a
K
V
>
{
type
Item
=
&
'
a
V
;
iterator_methods
!
(
Bucket
:
:
value_ref
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
Values
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
value_ref
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
Values
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
Values
<
'
_
K
V
>
{
}
impl
<
K
V
>
Clone
for
Values
<
'
_
K
V
>
{
fn
clone
(
&
self
)
-
>
Self
{
Values
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
impl
<
K
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Values
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
self
.
clone
(
)
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
Values
<
'
_
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter
(
)
}
}
}
pub
struct
ValuesMut
<
'
a
K
V
>
{
iter
:
slice
:
:
IterMut
<
'
a
Bucket
<
K
V
>
>
}
impl
<
'
a
K
V
>
ValuesMut
<
'
a
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
&
'
a
mut
[
Bucket
<
K
V
>
]
)
-
>
Self
{
Self
{
iter
:
entries
.
iter_mut
(
)
}
}
}
impl
<
'
a
K
V
>
Iterator
for
ValuesMut
<
'
a
K
V
>
{
type
Item
=
&
'
a
mut
V
;
iterator_methods
!
(
Bucket
:
:
value_mut
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
ValuesMut
<
'
_
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
value_mut
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
ValuesMut
<
'
_
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
ValuesMut
<
'
_
K
V
>
{
}
impl
<
K
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
ValuesMut
<
'
_
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
value_ref
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
ValuesMut
<
'
_
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
[
]
.
iter_mut
(
)
}
}
}
pub
struct
IntoValues
<
K
V
>
{
iter
:
vec
:
:
IntoIter
<
Bucket
<
K
V
>
>
}
impl
<
K
V
>
IntoValues
<
K
V
>
{
pub
(
super
)
fn
new
(
entries
:
Vec
<
Bucket
<
K
V
>
>
)
-
>
Self
{
Self
{
iter
:
entries
.
into_iter
(
)
}
}
}
impl
<
K
V
>
Iterator
for
IntoValues
<
K
V
>
{
type
Item
=
V
;
iterator_methods
!
(
Bucket
:
:
value
)
;
}
impl
<
K
V
>
DoubleEndedIterator
for
IntoValues
<
K
V
>
{
double_ended_iterator_methods
!
(
Bucket
:
:
value
)
;
}
impl
<
K
V
>
ExactSizeIterator
for
IntoValues
<
K
V
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
.
len
(
)
}
}
impl
<
K
V
>
FusedIterator
for
IntoValues
<
K
V
>
{
}
impl
<
K
V
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
IntoValues
<
K
V
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
iter
=
self
.
iter
.
as_slice
(
)
.
iter
(
)
.
map
(
Bucket
:
:
value_ref
)
;
f
.
debug_list
(
)
.
entries
(
iter
)
.
finish
(
)
}
}
impl
<
K
V
>
Default
for
IntoValues
<
K
V
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
Vec
:
:
new
(
)
.
into_iter
(
)
}
}
}
pub
struct
Splice
<
'
a
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
map
:
&
'
a
mut
IndexMap
<
K
V
S
>
tail
:
IndexMapCore
<
K
V
>
drain
:
vec
:
:
IntoIter
<
Bucket
<
K
V
>
>
replace_with
:
I
}
impl
<
'
a
I
K
V
S
>
Splice
<
'
a
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
pub
(
super
)
fn
new
<
R
>
(
map
:
&
'
a
mut
IndexMap
<
K
V
S
>
range
:
R
replace_with
:
I
)
-
>
Self
where
R
:
RangeBounds
<
usize
>
{
let
(
tail
drain
)
=
map
.
core
.
split_splice
(
range
)
;
Self
{
map
tail
drain
replace_with
}
}
}
impl
<
I
K
V
S
>
Drop
for
Splice
<
'
_
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
drain
.
nth
(
usize
:
:
MAX
)
;
while
let
Some
(
(
key
value
)
)
=
self
.
replace_with
.
next
(
)
{
let
hash
=
self
.
map
.
hash
(
&
key
)
;
if
let
Some
(
i
)
=
self
.
tail
.
get_index_of
(
hash
&
key
)
{
self
.
tail
.
as_entries_mut
(
)
[
i
]
.
value
=
value
;
}
else
{
self
.
map
.
core
.
insert_full
(
hash
key
value
)
;
}
}
self
.
map
.
core
.
append_unchecked
(
&
mut
self
.
tail
)
;
}
}
impl
<
I
K
V
S
>
Iterator
for
Splice
<
'
_
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
type
Item
=
(
K
V
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
drain
.
next
(
)
.
map
(
Bucket
:
:
key_value
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
drain
.
size_hint
(
)
}
}
impl
<
I
K
V
S
>
DoubleEndedIterator
for
Splice
<
'
_
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
drain
.
next_back
(
)
.
map
(
Bucket
:
:
key_value
)
}
}
impl
<
I
K
V
S
>
ExactSizeIterator
for
Splice
<
'
_
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
fn
len
(
&
self
)
-
>
usize
{
self
.
drain
.
len
(
)
}
}
impl
<
I
K
V
S
>
FusedIterator
for
Splice
<
'
_
I
K
V
S
>
where
I
:
Iterator
<
Item
=
(
K
V
)
>
K
:
Hash
+
Eq
S
:
BuildHasher
{
}
impl
<
'
a
I
K
V
S
>
fmt
:
:
Debug
for
Splice
<
'
a
I
K
V
S
>
where
I
:
fmt
:
:
Debug
+
Iterator
<
Item
=
(
K
V
)
>
K
:
fmt
:
:
Debug
+
Hash
+
Eq
V
:
fmt
:
:
Debug
S
:
BuildHasher
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Splice
"
)
.
field
(
"
drain
"
&
self
.
drain
)
.
field
(
"
replace_with
"
&
self
.
replace_with
)
.
finish
(
)
}
}
