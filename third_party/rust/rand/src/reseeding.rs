use
std
:
:
default
:
:
Default
;
use
{
Rng
SeedableRng
}
;
const
DEFAULT_GENERATION_THRESHOLD
:
u64
=
32
*
1024
;
#
[
derive
(
Debug
)
]
pub
struct
ReseedingRng
<
R
Rsdr
>
{
rng
:
R
generation_threshold
:
u64
bytes_generated
:
u64
pub
reseeder
:
Rsdr
}
impl
<
R
:
Rng
Rsdr
:
Reseeder
<
R
>
>
ReseedingRng
<
R
Rsdr
>
{
pub
fn
new
(
rng
:
R
generation_threshold
:
u64
reseeder
:
Rsdr
)
-
>
ReseedingRng
<
R
Rsdr
>
{
ReseedingRng
{
rng
:
rng
generation_threshold
:
generation_threshold
bytes_generated
:
0
reseeder
:
reseeder
}
}
pub
fn
reseed_if_necessary
(
&
mut
self
)
{
if
self
.
bytes_generated
>
=
self
.
generation_threshold
{
self
.
reseeder
.
reseed
(
&
mut
self
.
rng
)
;
self
.
bytes_generated
=
0
;
}
}
}
impl
<
R
:
Rng
Rsdr
:
Reseeder
<
R
>
>
Rng
for
ReseedingRng
<
R
Rsdr
>
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
reseed_if_necessary
(
)
;
self
.
bytes_generated
+
=
4
;
self
.
rng
.
next_u32
(
)
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
reseed_if_necessary
(
)
;
self
.
bytes_generated
+
=
8
;
self
.
rng
.
next_u64
(
)
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
self
.
reseed_if_necessary
(
)
;
self
.
bytes_generated
+
=
dest
.
len
(
)
as
u64
;
self
.
rng
.
fill_bytes
(
dest
)
}
}
impl
<
S
R
:
SeedableRng
<
S
>
Rsdr
:
Reseeder
<
R
>
+
Default
>
SeedableRng
<
(
Rsdr
S
)
>
for
ReseedingRng
<
R
Rsdr
>
{
fn
reseed
(
&
mut
self
(
rsdr
seed
)
:
(
Rsdr
S
)
)
{
self
.
rng
.
reseed
(
seed
)
;
self
.
reseeder
=
rsdr
;
self
.
bytes_generated
=
0
;
}
fn
from_seed
(
(
rsdr
seed
)
:
(
Rsdr
S
)
)
-
>
ReseedingRng
<
R
Rsdr
>
{
ReseedingRng
{
rng
:
SeedableRng
:
:
from_seed
(
seed
)
generation_threshold
:
DEFAULT_GENERATION_THRESHOLD
bytes_generated
:
0
reseeder
:
rsdr
}
}
}
pub
trait
Reseeder
<
R
>
{
fn
reseed
(
&
mut
self
rng
:
&
mut
R
)
;
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
ReseedWithDefault
;
impl
<
R
:
Rng
+
Default
>
Reseeder
<
R
>
for
ReseedWithDefault
{
fn
reseed
(
&
mut
self
rng
:
&
mut
R
)
{
*
rng
=
Default
:
:
default
(
)
;
}
}
impl
Default
for
ReseedWithDefault
{
fn
default
(
)
-
>
ReseedWithDefault
{
ReseedWithDefault
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
std
:
:
default
:
:
Default
;
use
std
:
:
iter
:
:
repeat
;
use
super
:
:
{
ReseedingRng
ReseedWithDefault
}
;
use
{
SeedableRng
Rng
}
;
struct
Counter
{
i
:
u32
}
impl
Rng
for
Counter
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
i
+
=
1
;
self
.
i
-
1
}
}
impl
Default
for
Counter
{
fn
default
(
)
-
>
Counter
{
Counter
{
i
:
0
}
}
}
impl
SeedableRng
<
u32
>
for
Counter
{
fn
reseed
(
&
mut
self
seed
:
u32
)
{
self
.
i
=
seed
;
}
fn
from_seed
(
seed
:
u32
)
-
>
Counter
{
Counter
{
i
:
seed
}
}
}
type
MyRng
=
ReseedingRng
<
Counter
ReseedWithDefault
>
;
#
[
test
]
fn
test_reseeding
(
)
{
let
mut
rs
=
ReseedingRng
:
:
new
(
Counter
{
i
:
0
}
400
ReseedWithDefault
)
;
let
mut
i
=
0
;
for
_
in
0
.
.
1000
{
assert_eq
!
(
rs
.
next_u32
(
)
i
%
100
)
;
i
+
=
1
;
}
}
#
[
test
]
fn
test_rng_seeded
(
)
{
let
mut
ra
:
MyRng
=
SeedableRng
:
:
from_seed
(
(
ReseedWithDefault
2
)
)
;
let
mut
rb
:
MyRng
=
SeedableRng
:
:
from_seed
(
(
ReseedWithDefault
2
)
)
;
assert
!
(
:
:
test
:
:
iter_eq
(
ra
.
gen_ascii_chars
(
)
.
take
(
100
)
rb
.
gen_ascii_chars
(
)
.
take
(
100
)
)
)
;
}
#
[
test
]
fn
test_rng_reseed
(
)
{
let
mut
r
:
MyRng
=
SeedableRng
:
:
from_seed
(
(
ReseedWithDefault
3
)
)
;
let
string1
:
String
=
r
.
gen_ascii_chars
(
)
.
take
(
100
)
.
collect
(
)
;
r
.
reseed
(
(
ReseedWithDefault
3
)
)
;
let
string2
:
String
=
r
.
gen_ascii_chars
(
)
.
take
(
100
)
.
collect
(
)
;
assert_eq
!
(
string1
string2
)
;
}
const
FILL_BYTES_V_LEN
:
usize
=
13579
;
#
[
test
]
fn
test_rng_fill_bytes
(
)
{
let
mut
v
=
repeat
(
0u8
)
.
take
(
FILL_BYTES_V_LEN
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
:
:
test
:
:
rng
(
)
.
fill_bytes
(
&
mut
v
)
;
assert_eq
!
(
v
.
len
(
)
FILL_BYTES_V_LEN
)
;
let
mut
sum
=
0
.
0
;
for
&
x
in
v
.
iter
(
)
{
sum
+
=
x
as
f64
;
}
assert
!
(
sum
/
v
.
len
(
)
as
f64
!
=
0
.
0
)
;
}
}
