use
core
:
:
iter
;
use
crate
:
:
Rng
;
pub
use
self
:
:
other
:
:
Alphanumeric
;
#
[
doc
(
inline
)
]
pub
use
self
:
:
uniform
:
:
Uniform
;
pub
use
self
:
:
float
:
:
{
OpenClosed01
Open01
}
;
pub
use
self
:
:
bernoulli
:
:
{
Bernoulli
BernoulliError
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
use
self
:
:
weighted
:
:
{
WeightedIndex
WeightedError
}
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
unit_sphere
:
:
UnitSphereSurface
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
unit_circle
:
:
UnitCircle
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
gamma
:
:
{
Gamma
ChiSquared
FisherF
StudentT
Beta
}
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
normal
:
:
{
Normal
LogNormal
StandardNormal
}
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
exponential
:
:
{
Exp
Exp1
}
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
pareto
:
:
Pareto
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
poisson
:
:
Poisson
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
binomial
:
:
Binomial
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
cauchy
:
:
Cauchy
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
dirichlet
:
:
Dirichlet
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
triangular
:
:
Triangular
;
#
[
allow
(
deprecated
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
pub
use
self
:
:
weibull
:
:
Weibull
;
pub
mod
uniform
;
mod
bernoulli
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
mod
weighted
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
unit_sphere
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
unit_circle
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
gamma
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
normal
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
exponential
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
pareto
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
poisson
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
binomial
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
cauchy
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
dirichlet
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
triangular
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
weibull
;
mod
float
;
#
[
doc
(
hidden
)
]
pub
mod
hidden_export
{
pub
use
super
:
:
float
:
:
IntoFloat
;
}
mod
integer
;
mod
other
;
mod
utils
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
ziggurat_tables
;
pub
trait
Distribution
<
T
>
{
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
T
;
fn
sample_iter
<
R
>
(
self
rng
:
R
)
-
>
DistIter
<
Self
R
T
>
where
R
:
Rng
Self
:
Sized
{
DistIter
{
distr
:
self
rng
phantom
:
:
:
core
:
:
marker
:
:
PhantomData
}
}
}
impl
<
'
a
T
D
:
Distribution
<
T
>
>
Distribution
<
T
>
for
&
'
a
D
{
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
T
{
(
*
self
)
.
sample
(
rng
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
DistIter
<
D
R
T
>
{
distr
:
D
rng
:
R
phantom
:
:
:
core
:
:
marker
:
:
PhantomData
<
T
>
}
impl
<
D
R
T
>
Iterator
for
DistIter
<
D
R
T
>
where
D
:
Distribution
<
T
>
R
:
Rng
{
type
Item
=
T
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
Some
(
self
.
distr
.
sample
(
&
mut
self
.
rng
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
usize
:
:
max_value
(
)
None
)
}
}
impl
<
D
R
T
>
iter
:
:
FusedIterator
for
DistIter
<
D
R
T
>
where
D
:
Distribution
<
T
>
R
:
Rng
{
}
#
[
cfg
(
features
=
"
nightly
"
)
]
impl
<
D
R
T
>
iter
:
:
TrustedLen
for
DistIter
<
D
R
T
>
where
D
:
Distribution
<
T
>
R
:
Rng
{
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Standard
;
#
[
cfg
(
all
(
test
feature
=
"
std
"
)
)
]
mod
tests
{
use
crate
:
:
Rng
;
use
super
:
:
{
Distribution
Uniform
}
;
#
[
test
]
fn
test_distributions_iter
(
)
{
use
crate
:
:
distributions
:
:
Open01
;
let
mut
rng
=
crate
:
:
test
:
:
rng
(
210
)
;
let
distr
=
Open01
;
let
results
:
Vec
<
f32
>
=
distr
.
sample_iter
(
&
mut
rng
)
.
take
(
100
)
.
collect
(
)
;
println
!
(
"
{
:
?
}
"
results
)
;
}
#
[
test
]
fn
test_make_an_iter
(
)
{
fn
ten_dice_rolls_other_than_five
<
'
a
R
:
Rng
>
(
rng
:
&
'
a
mut
R
)
-
>
impl
Iterator
<
Item
=
i32
>
+
'
a
{
Uniform
:
:
new_inclusive
(
1
6
)
.
sample_iter
(
rng
)
.
filter
(
|
x
|
*
x
!
=
5
)
.
take
(
10
)
}
let
mut
rng
=
crate
:
:
test
:
:
rng
(
211
)
;
let
mut
count
=
0
;
for
val
in
ten_dice_rolls_other_than_five
(
&
mut
rng
)
{
assert
!
(
val
>
=
1
&
&
val
<
=
6
&
&
val
!
=
5
)
;
count
+
=
1
;
}
assert_eq
!
(
count
10
)
;
}
}
