#
!
[
allow
(
deprecated
)
]
use
crate
:
:
distributions
:
:
utils
:
:
log_gamma
;
use
crate
:
:
distributions
:
:
{
Cauchy
Distribution
}
;
use
crate
:
:
Rng
;
#
[
deprecated
(
since
=
"
0
.
7
.
0
"
note
=
"
moved
to
rand_distr
crate
"
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Poisson
{
lambda
:
f64
exp_lambda
:
f64
log_lambda
:
f64
sqrt_2lambda
:
f64
magic_val
:
f64
}
impl
Poisson
{
pub
fn
new
(
lambda
:
f64
)
-
>
Poisson
{
assert
!
(
lambda
>
0
.
0
"
Poisson
:
:
new
called
with
lambda
<
=
0
"
)
;
let
log_lambda
=
lambda
.
ln
(
)
;
Poisson
{
lambda
exp_lambda
:
(
-
lambda
)
.
exp
(
)
log_lambda
sqrt_2lambda
:
(
2
.
0
*
lambda
)
.
sqrt
(
)
magic_val
:
lambda
*
log_lambda
-
log_gamma
(
1
.
0
+
lambda
)
}
}
}
impl
Distribution
<
u64
>
for
Poisson
{
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
u64
{
if
self
.
lambda
<
12
.
0
{
let
mut
result
=
0
;
let
mut
p
=
1
.
0
;
while
p
>
self
.
exp_lambda
{
p
*
=
rng
.
gen
:
:
<
f64
>
(
)
;
result
+
=
1
;
}
result
-
1
}
else
{
let
mut
int_result
:
u64
;
let
cauchy
=
Cauchy
:
:
new
(
0
.
0
1
.
0
)
;
loop
{
let
mut
result
;
let
mut
comp_dev
;
loop
{
comp_dev
=
rng
.
sample
(
cauchy
)
;
result
=
self
.
sqrt_2lambda
*
comp_dev
+
self
.
lambda
;
if
result
>
=
0
.
0
{
break
;
}
}
result
=
result
.
floor
(
)
;
int_result
=
result
as
u64
;
let
check
=
0
.
9
*
(
1
.
0
+
comp_dev
*
comp_dev
)
*
(
result
*
self
.
log_lambda
-
log_gamma
(
1
.
0
+
result
)
-
self
.
magic_val
)
.
exp
(
)
;
if
rng
.
gen
:
:
<
f64
>
(
)
<
=
check
{
break
;
}
}
int_result
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
Poisson
;
use
crate
:
:
distributions
:
:
Distribution
;
#
[
test
]
#
[
cfg_attr
(
miri
ignore
)
]
fn
test_poisson_10
(
)
{
let
poisson
=
Poisson
:
:
new
(
10
.
0
)
;
let
mut
rng
=
crate
:
:
test
:
:
rng
(
123
)
;
let
mut
sum
=
0
;
for
_
in
0
.
.
1000
{
sum
+
=
poisson
.
sample
(
&
mut
rng
)
;
}
let
avg
=
(
sum
as
f64
)
/
1000
.
0
;
println
!
(
"
Poisson
average
:
{
}
"
avg
)
;
assert
!
(
(
avg
-
10
.
0
)
.
abs
(
)
<
0
.
5
)
;
}
#
[
test
]
fn
test_poisson_15
(
)
{
let
poisson
=
Poisson
:
:
new
(
15
.
0
)
;
let
mut
rng
=
crate
:
:
test
:
:
rng
(
123
)
;
let
mut
sum
=
0
;
for
_
in
0
.
.
1000
{
sum
+
=
poisson
.
sample
(
&
mut
rng
)
;
}
let
avg
=
(
sum
as
f64
)
/
1000
.
0
;
println
!
(
"
Poisson
average
:
{
}
"
avg
)
;
assert
!
(
(
avg
-
15
.
0
)
.
abs
(
)
<
0
.
5
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_poisson_invalid_lambda_zero
(
)
{
Poisson
:
:
new
(
0
.
0
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_poisson_invalid_lambda_neg
(
)
{
Poisson
:
:
new
(
-
10
.
0
)
;
}
}
