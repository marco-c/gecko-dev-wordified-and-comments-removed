use
{
Rng
Rand
Open01
}
;
use
distributions
:
:
{
ziggurat
ziggurat_tables
Sample
IndependentSample
}
;
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
StandardNormal
(
pub
f64
)
;
impl
Rand
for
StandardNormal
{
fn
rand
<
R
:
Rng
>
(
rng
:
&
mut
R
)
-
>
StandardNormal
{
#
[
inline
]
fn
pdf
(
x
:
f64
)
-
>
f64
{
(
-
x
*
x
/
2
.
0
)
.
exp
(
)
}
#
[
inline
]
fn
zero_case
<
R
:
Rng
>
(
rng
:
&
mut
R
u
:
f64
)
-
>
f64
{
let
mut
x
=
1
.
0f64
;
let
mut
y
=
0
.
0f64
;
while
-
2
.
0
*
y
<
x
*
x
{
let
Open01
(
x_
)
=
rng
.
gen
:
:
<
Open01
<
f64
>
>
(
)
;
let
Open01
(
y_
)
=
rng
.
gen
:
:
<
Open01
<
f64
>
>
(
)
;
x
=
x_
.
ln
(
)
/
ziggurat_tables
:
:
ZIG_NORM_R
;
y
=
y_
.
ln
(
)
;
}
if
u
<
0
.
0
{
x
-
ziggurat_tables
:
:
ZIG_NORM_R
}
else
{
ziggurat_tables
:
:
ZIG_NORM_R
-
x
}
}
StandardNormal
(
ziggurat
(
rng
true
&
ziggurat_tables
:
:
ZIG_NORM_X
&
ziggurat_tables
:
:
ZIG_NORM_F
pdf
zero_case
)
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Normal
{
mean
:
f64
std_dev
:
f64
}
impl
Normal
{
#
[
inline
]
pub
fn
new
(
mean
:
f64
std_dev
:
f64
)
-
>
Normal
{
assert
!
(
std_dev
>
=
0
.
0
"
Normal
:
:
new
called
with
std_dev
<
0
"
)
;
Normal
{
mean
:
mean
std_dev
:
std_dev
}
}
}
impl
Sample
<
f64
>
for
Normal
{
fn
sample
<
R
:
Rng
>
(
&
mut
self
rng
:
&
mut
R
)
-
>
f64
{
self
.
ind_sample
(
rng
)
}
}
impl
IndependentSample
<
f64
>
for
Normal
{
fn
ind_sample
<
R
:
Rng
>
(
&
self
rng
:
&
mut
R
)
-
>
f64
{
let
StandardNormal
(
n
)
=
rng
.
gen
:
:
<
StandardNormal
>
(
)
;
self
.
mean
+
self
.
std_dev
*
n
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
LogNormal
{
norm
:
Normal
}
impl
LogNormal
{
#
[
inline
]
pub
fn
new
(
mean
:
f64
std_dev
:
f64
)
-
>
LogNormal
{
assert
!
(
std_dev
>
=
0
.
0
"
LogNormal
:
:
new
called
with
std_dev
<
0
"
)
;
LogNormal
{
norm
:
Normal
:
:
new
(
mean
std_dev
)
}
}
}
impl
Sample
<
f64
>
for
LogNormal
{
fn
sample
<
R
:
Rng
>
(
&
mut
self
rng
:
&
mut
R
)
-
>
f64
{
self
.
ind_sample
(
rng
)
}
}
impl
IndependentSample
<
f64
>
for
LogNormal
{
fn
ind_sample
<
R
:
Rng
>
(
&
self
rng
:
&
mut
R
)
-
>
f64
{
self
.
norm
.
ind_sample
(
rng
)
.
exp
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
distributions
:
:
{
Sample
IndependentSample
}
;
use
super
:
:
{
Normal
LogNormal
}
;
#
[
test
]
fn
test_normal
(
)
{
let
mut
norm
=
Normal
:
:
new
(
10
.
0
10
.
0
)
;
let
mut
rng
=
:
:
test
:
:
rng
(
)
;
for
_
in
0
.
.
1000
{
norm
.
sample
(
&
mut
rng
)
;
norm
.
ind_sample
(
&
mut
rng
)
;
}
}
#
[
test
]
#
[
should_panic
]
fn
test_normal_invalid_sd
(
)
{
Normal
:
:
new
(
10
.
0
-
1
.
0
)
;
}
#
[
test
]
fn
test_log_normal
(
)
{
let
mut
lnorm
=
LogNormal
:
:
new
(
10
.
0
10
.
0
)
;
let
mut
rng
=
:
:
test
:
:
rng
(
)
;
for
_
in
0
.
.
1000
{
lnorm
.
sample
(
&
mut
rng
)
;
lnorm
.
ind_sample
(
&
mut
rng
)
;
}
}
#
[
test
]
#
[
should_panic
]
fn
test_log_normal_invalid_sd
(
)
{
LogNormal
:
:
new
(
10
.
0
-
1
.
0
)
;
}
}
