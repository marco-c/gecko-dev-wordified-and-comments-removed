#
!
[
allow
(
deprecated
)
]
use
crate
:
:
{
Rng
}
;
use
crate
:
:
distributions
:
:
{
ziggurat_tables
Distribution
}
;
use
crate
:
:
distributions
:
:
utils
:
:
ziggurat
;
#
[
deprecated
(
since
=
"
0
.
7
.
0
"
note
=
"
moved
to
rand_distr
crate
"
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Exp1
;
impl
Distribution
<
f64
>
for
Exp1
{
#
[
inline
]
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
f64
{
#
[
inline
]
fn
pdf
(
x
:
f64
)
-
>
f64
{
(
-
x
)
.
exp
(
)
}
#
[
inline
]
fn
zero_case
<
R
:
Rng
+
?
Sized
>
(
rng
:
&
mut
R
_u
:
f64
)
-
>
f64
{
ziggurat_tables
:
:
ZIG_EXP_R
-
rng
.
gen
:
:
<
f64
>
(
)
.
ln
(
)
}
ziggurat
(
rng
false
&
ziggurat_tables
:
:
ZIG_EXP_X
&
ziggurat_tables
:
:
ZIG_EXP_F
pdf
zero_case
)
}
}
#
[
deprecated
(
since
=
"
0
.
7
.
0
"
note
=
"
moved
to
rand_distr
crate
"
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Exp
{
lambda_inverse
:
f64
}
impl
Exp
{
#
[
inline
]
pub
fn
new
(
lambda
:
f64
)
-
>
Exp
{
assert
!
(
lambda
>
0
.
0
"
Exp
:
:
new
called
with
lambda
<
=
0
"
)
;
Exp
{
lambda_inverse
:
1
.
0
/
lambda
}
}
}
impl
Distribution
<
f64
>
for
Exp
{
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
f64
{
let
n
:
f64
=
rng
.
sample
(
Exp1
)
;
n
*
self
.
lambda_inverse
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
distributions
:
:
Distribution
;
use
super
:
:
Exp
;
#
[
test
]
fn
test_exp
(
)
{
let
exp
=
Exp
:
:
new
(
10
.
0
)
;
let
mut
rng
=
crate
:
:
test
:
:
rng
(
221
)
;
for
_
in
0
.
.
1000
{
assert
!
(
exp
.
sample
(
&
mut
rng
)
>
=
0
.
0
)
;
}
}
#
[
test
]
#
[
should_panic
]
fn
test_exp_invalid_lambda_zero
(
)
{
Exp
:
:
new
(
0
.
0
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_exp_invalid_lambda_neg
(
)
{
Exp
:
:
new
(
-
10
.
0
)
;
}
}
