use
{
Rng
Rand
}
;
use
distributions
:
:
{
ziggurat
ziggurat_tables
Sample
IndependentSample
}
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
Exp1
(
pub
f64
)
;
impl
Rand
for
Exp1
{
#
[
inline
]
fn
rand
<
R
:
Rng
>
(
rng
:
&
mut
R
)
-
>
Exp1
{
#
[
inline
]
fn
pdf
(
x
:
f64
)
-
>
f64
{
(
-
x
)
.
exp
(
)
}
#
[
inline
]
fn
zero_case
<
R
:
Rng
>
(
rng
:
&
mut
R
_u
:
f64
)
-
>
f64
{
ziggurat_tables
:
:
ZIG_EXP_R
-
rng
.
gen
:
:
<
f64
>
(
)
.
ln
(
)
}
Exp1
(
ziggurat
(
rng
false
&
ziggurat_tables
:
:
ZIG_EXP_X
&
ziggurat_tables
:
:
ZIG_EXP_F
pdf
zero_case
)
)
}
}
#
[
derive
(
Clone
Copy
)
]
pub
struct
Exp
{
lambda_inverse
:
f64
}
impl
Exp
{
#
[
inline
]
pub
fn
new
(
lambda
:
f64
)
-
>
Exp
{
assert
!
(
lambda
>
0
.
0
"
Exp
:
:
new
called
with
lambda
<
=
0
"
)
;
Exp
{
lambda_inverse
:
1
.
0
/
lambda
}
}
}
impl
Sample
<
f64
>
for
Exp
{
fn
sample
<
R
:
Rng
>
(
&
mut
self
rng
:
&
mut
R
)
-
>
f64
{
self
.
ind_sample
(
rng
)
}
}
impl
IndependentSample
<
f64
>
for
Exp
{
fn
ind_sample
<
R
:
Rng
>
(
&
self
rng
:
&
mut
R
)
-
>
f64
{
let
Exp1
(
n
)
=
rng
.
gen
:
:
<
Exp1
>
(
)
;
n
*
self
.
lambda_inverse
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
distributions
:
:
{
Sample
IndependentSample
}
;
use
super
:
:
Exp
;
#
[
test
]
fn
test_exp
(
)
{
let
mut
exp
=
Exp
:
:
new
(
10
.
0
)
;
let
mut
rng
=
:
:
test
:
:
rng
(
)
;
for
_
in
0
.
.
1000
{
assert
!
(
exp
.
sample
(
&
mut
rng
)
>
=
0
.
0
)
;
assert
!
(
exp
.
ind_sample
(
&
mut
rng
)
>
=
0
.
0
)
;
}
}
#
[
test
]
#
[
should_panic
]
fn
test_exp_invalid_lambda_zero
(
)
{
Exp
:
:
new
(
0
.
0
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_exp_invalid_lambda_neg
(
)
{
Exp
:
:
new
(
-
10
.
0
)
;
}
}
