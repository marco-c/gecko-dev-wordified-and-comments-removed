use
std
:
:
cell
:
:
UnsafeCell
;
use
{
RngCore
CryptoRng
SeedableRng
Error
}
;
use
rngs
:
:
adapter
:
:
ReseedingRng
;
use
rngs
:
:
EntropyRng
;
use
rand_hc
:
:
Hc128Core
;
const
THREAD_RNG_RESEED_THRESHOLD
:
u64
=
32
*
1024
*
1024
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
ThreadRng
{
rng
:
*
mut
ReseedingRng
<
Hc128Core
EntropyRng
>
}
thread_local
!
(
static
THREAD_RNG_KEY
:
UnsafeCell
<
ReseedingRng
<
Hc128Core
EntropyRng
>
>
=
{
let
mut
entropy_source
=
EntropyRng
:
:
new
(
)
;
let
r
=
Hc128Core
:
:
from_rng
(
&
mut
entropy_source
)
.
unwrap_or_else
(
|
err
|
panic
!
(
"
could
not
initialize
thread_rng
:
{
}
"
err
)
)
;
let
rng
=
ReseedingRng
:
:
new
(
r
THREAD_RNG_RESEED_THRESHOLD
entropy_source
)
;
UnsafeCell
:
:
new
(
rng
)
}
)
;
pub
fn
thread_rng
(
)
-
>
ThreadRng
{
ThreadRng
{
rng
:
THREAD_RNG_KEY
.
with
(
|
t
|
t
.
get
(
)
)
}
}
impl
Default
for
ThreadRng
{
fn
default
(
)
-
>
ThreadRng
{
:
:
prelude
:
:
thread_rng
(
)
}
}
impl
RngCore
for
ThreadRng
{
#
[
inline
(
always
)
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
unsafe
{
(
*
self
.
rng
)
.
next_u32
(
)
}
}
#
[
inline
(
always
)
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
unsafe
{
(
*
self
.
rng
)
.
next_u64
(
)
}
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
unsafe
{
(
*
self
.
rng
)
.
fill_bytes
(
dest
)
}
}
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
unsafe
{
(
*
self
.
rng
)
.
try_fill_bytes
(
dest
)
}
}
}
impl
CryptoRng
for
ThreadRng
{
}
#
[
cfg
(
test
)
]
mod
test
{
#
[
test
]
fn
test_thread_rng
(
)
{
use
Rng
;
let
mut
r
=
:
:
thread_rng
(
)
;
r
.
gen
:
:
<
i32
>
(
)
;
assert_eq
!
(
r
.
gen_range
(
0
1
)
0
)
;
}
}
