use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
ptr
:
:
NonNull
;
use
super
:
:
std
:
:
Core
;
use
crate
:
:
rngs
:
:
adapter
:
:
ReseedingRng
;
use
crate
:
:
rngs
:
:
OsRng
;
use
crate
:
:
{
CryptoRng
Error
RngCore
SeedableRng
}
;
const
THREAD_RNG_RESEED_THRESHOLD
:
u64
=
1024
*
64
;
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
ThreadRng
{
rng
:
NonNull
<
ReseedingRng
<
Core
OsRng
>
>
}
thread_local
!
(
static
THREAD_RNG_KEY
:
UnsafeCell
<
ReseedingRng
<
Core
OsRng
>
>
=
{
let
r
=
Core
:
:
from_rng
(
OsRng
)
.
unwrap_or_else
(
|
err
|
panic
!
(
"
could
not
initialize
thread_rng
:
{
}
"
err
)
)
;
let
rng
=
ReseedingRng
:
:
new
(
r
THREAD_RNG_RESEED_THRESHOLD
OsRng
)
;
UnsafeCell
:
:
new
(
rng
)
}
)
;
pub
fn
thread_rng
(
)
-
>
ThreadRng
{
let
raw
=
THREAD_RNG_KEY
.
with
(
|
t
|
t
.
get
(
)
)
;
let
nn
=
NonNull
:
:
new
(
raw
)
.
unwrap
(
)
;
ThreadRng
{
rng
:
nn
}
}
impl
Default
for
ThreadRng
{
fn
default
(
)
-
>
ThreadRng
{
crate
:
:
prelude
:
:
thread_rng
(
)
}
}
impl
RngCore
for
ThreadRng
{
#
[
inline
(
always
)
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
unsafe
{
self
.
rng
.
as_mut
(
)
.
next_u32
(
)
}
}
#
[
inline
(
always
)
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
unsafe
{
self
.
rng
.
as_mut
(
)
.
next_u64
(
)
}
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
unsafe
{
self
.
rng
.
as_mut
(
)
.
fill_bytes
(
dest
)
}
}
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
unsafe
{
self
.
rng
.
as_mut
(
)
.
try_fill_bytes
(
dest
)
}
}
}
impl
CryptoRng
for
ThreadRng
{
}
#
[
cfg
(
test
)
]
mod
test
{
#
[
test
]
fn
test_thread_rng
(
)
{
use
crate
:
:
Rng
;
let
mut
r
=
crate
:
:
thread_rng
(
)
;
r
.
gen
:
:
<
i32
>
(
)
;
assert_eq
!
(
r
.
gen_range
(
0
1
)
0
)
;
}
}
