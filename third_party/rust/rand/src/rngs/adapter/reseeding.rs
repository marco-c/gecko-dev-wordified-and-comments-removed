use
core
:
:
mem
:
:
size_of
;
use
rand_core
:
:
{
RngCore
CryptoRng
SeedableRng
Error
ErrorKind
}
;
use
rand_core
:
:
block
:
:
{
BlockRngCore
BlockRng
}
;
#
[
derive
(
Debug
)
]
pub
struct
ReseedingRng
<
R
Rsdr
>
(
BlockRng
<
ReseedingCore
<
R
Rsdr
>
>
)
where
R
:
BlockRngCore
+
SeedableRng
Rsdr
:
RngCore
;
impl
<
R
Rsdr
>
ReseedingRng
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
Rsdr
:
RngCore
{
pub
fn
new
(
rng
:
R
threshold
:
u64
reseeder
:
Rsdr
)
-
>
Self
{
ReseedingRng
(
BlockRng
:
:
new
(
ReseedingCore
:
:
new
(
rng
threshold
reseeder
)
)
)
}
pub
fn
reseed
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
self
.
0
.
core
.
reseed
(
)
}
}
impl
<
R
Rsdr
:
RngCore
>
RngCore
for
ReseedingRng
<
R
Rsdr
>
where
R
:
BlockRngCore
<
Item
=
u32
>
+
SeedableRng
<
R
as
BlockRngCore
>
:
:
Results
:
AsRef
<
[
u32
]
>
+
AsMut
<
[
u32
]
>
{
#
[
inline
(
always
)
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
0
.
next_u32
(
)
}
#
[
inline
(
always
)
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
0
.
next_u64
(
)
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
self
.
0
.
fill_bytes
(
dest
)
}
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
self
.
0
.
try_fill_bytes
(
dest
)
}
}
impl
<
R
Rsdr
>
Clone
for
ReseedingRng
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
+
Clone
Rsdr
:
RngCore
+
Clone
{
fn
clone
(
&
self
)
-
>
ReseedingRng
<
R
Rsdr
>
{
ReseedingRng
(
BlockRng
:
:
new
(
self
.
0
.
core
.
clone
(
)
)
)
}
}
impl
<
R
Rsdr
>
CryptoRng
for
ReseedingRng
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
+
CryptoRng
Rsdr
:
RngCore
+
CryptoRng
{
}
#
[
derive
(
Debug
)
]
struct
ReseedingCore
<
R
Rsdr
>
{
inner
:
R
reseeder
:
Rsdr
threshold
:
i64
bytes_until_reseed
:
i64
fork_counter
:
usize
}
impl
<
R
Rsdr
>
BlockRngCore
for
ReseedingCore
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
Rsdr
:
RngCore
{
type
Item
=
<
R
as
BlockRngCore
>
:
:
Item
;
type
Results
=
<
R
as
BlockRngCore
>
:
:
Results
;
fn
generate
(
&
mut
self
results
:
&
mut
Self
:
:
Results
)
{
let
global_fork_counter
=
fork
:
:
get_fork_counter
(
)
;
if
self
.
bytes_until_reseed
<
=
0
|
|
self
.
is_forked
(
global_fork_counter
)
{
return
self
.
reseed_and_generate
(
results
global_fork_counter
)
;
}
let
num_bytes
=
results
.
as_ref
(
)
.
len
(
)
*
size_of
:
:
<
Self
:
:
Item
>
(
)
;
self
.
bytes_until_reseed
-
=
num_bytes
as
i64
;
self
.
inner
.
generate
(
results
)
;
}
}
impl
<
R
Rsdr
>
ReseedingCore
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
Rsdr
:
RngCore
{
fn
new
(
rng
:
R
threshold
:
u64
reseeder
:
Rsdr
)
-
>
Self
{
use
:
:
core
:
:
i64
:
:
MAX
;
fork
:
:
register_fork_handler
(
)
;
let
threshold
=
if
threshold
=
=
0
{
MAX
}
else
if
threshold
<
=
MAX
as
u64
{
threshold
as
i64
}
else
{
MAX
}
;
ReseedingCore
{
inner
:
rng
reseeder
threshold
:
threshold
as
i64
bytes_until_reseed
:
threshold
as
i64
fork_counter
:
0
}
}
fn
reseed
(
&
mut
self
)
-
>
Result
<
(
)
Error
>
{
R
:
:
from_rng
(
&
mut
self
.
reseeder
)
.
map
(
|
result
|
{
self
.
bytes_until_reseed
=
self
.
threshold
;
self
.
inner
=
result
}
)
}
fn
is_forked
(
&
self
global_fork_counter
:
usize
)
-
>
bool
{
(
self
.
fork_counter
.
wrapping_sub
(
global_fork_counter
)
as
isize
)
<
0
}
#
[
inline
(
never
)
]
fn
reseed_and_generate
(
&
mut
self
results
:
&
mut
<
Self
as
BlockRngCore
>
:
:
Results
global_fork_counter
:
usize
)
{
if
self
.
is_forked
(
global_fork_counter
)
{
info
!
(
"
Fork
detected
reseeding
RNG
"
)
;
}
else
{
trace
!
(
"
Reseeding
RNG
(
periodic
reseed
)
"
)
;
}
let
num_bytes
=
results
.
as_ref
(
)
.
len
(
)
*
size_of
:
:
<
<
R
as
BlockRngCore
>
:
:
Item
>
(
)
;
let
threshold
=
if
let
Err
(
e
)
=
self
.
reseed
(
)
{
let
delay
=
match
e
.
kind
{
ErrorKind
:
:
Transient
=
>
num_bytes
as
i64
kind
_
if
kind
.
should_retry
(
)
=
>
self
.
threshold
>
>
8
_
=
>
self
.
threshold
}
;
warn
!
(
"
Reseeding
RNG
delayed
reseeding
by
{
}
bytes
due
to
\
error
from
source
:
{
}
"
delay
e
)
;
delay
}
else
{
self
.
fork_counter
=
global_fork_counter
;
self
.
threshold
}
;
self
.
bytes_until_reseed
=
threshold
-
num_bytes
as
i64
;
self
.
inner
.
generate
(
results
)
;
}
}
impl
<
R
Rsdr
>
Clone
for
ReseedingCore
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
+
Clone
Rsdr
:
RngCore
+
Clone
{
fn
clone
(
&
self
)
-
>
ReseedingCore
<
R
Rsdr
>
{
ReseedingCore
{
inner
:
self
.
inner
.
clone
(
)
reseeder
:
self
.
reseeder
.
clone
(
)
threshold
:
self
.
threshold
bytes_until_reseed
:
0
fork_counter
:
self
.
fork_counter
}
}
}
impl
<
R
Rsdr
>
CryptoRng
for
ReseedingCore
<
R
Rsdr
>
where
R
:
BlockRngCore
+
SeedableRng
+
CryptoRng
Rsdr
:
RngCore
+
CryptoRng
{
}
#
[
cfg
(
all
(
feature
=
"
std
"
unix
not
(
target_os
=
"
emscripten
"
)
)
)
]
mod
fork
{
extern
crate
libc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
ATOMIC_USIZE_INIT
Ordering
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
ATOMIC_BOOL_INIT
}
;
static
RESEEDING_RNG_FORK_COUNTER
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
pub
fn
get_fork_counter
(
)
-
>
usize
{
RESEEDING_RNG_FORK_COUNTER
.
load
(
Ordering
:
:
Relaxed
)
}
static
FORK_HANDLER_REGISTERED
:
AtomicBool
=
ATOMIC_BOOL_INIT
;
extern
fn
fork_handler
(
)
{
RESEEDING_RNG_FORK_COUNTER
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
pub
fn
register_fork_handler
(
)
{
if
FORK_HANDLER_REGISTERED
.
load
(
Ordering
:
:
Relaxed
)
=
=
false
{
unsafe
{
libc
:
:
pthread_atfork
(
None
None
Some
(
fork_handler
)
)
}
;
FORK_HANDLER_REGISTERED
.
store
(
true
Ordering
:
:
Relaxed
)
;
}
}
}
#
[
cfg
(
not
(
all
(
feature
=
"
std
"
unix
not
(
target_os
=
"
emscripten
"
)
)
)
)
]
mod
fork
{
pub
fn
get_fork_counter
(
)
-
>
usize
{
0
}
pub
fn
register_fork_handler
(
)
{
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
{
Rng
SeedableRng
}
;
use
rand_chacha
:
:
ChaChaCore
;
use
rngs
:
:
mock
:
:
StepRng
;
use
super
:
:
ReseedingRng
;
#
[
test
]
fn
test_reseeding
(
)
{
let
mut
zero
=
StepRng
:
:
new
(
0
0
)
;
let
rng
=
ChaChaCore
:
:
from_rng
(
&
mut
zero
)
.
unwrap
(
)
;
let
mut
reseeding
=
ReseedingRng
:
:
new
(
rng
32
*
4
zero
)
;
let
mut
buf
=
[
0u32
;
32
]
;
reseeding
.
fill
(
&
mut
buf
)
;
let
seq
=
buf
;
for
_
in
0
.
.
10
{
reseeding
.
fill
(
&
mut
buf
)
;
assert_eq
!
(
buf
seq
)
;
}
}
#
[
test
]
fn
test_clone_reseeding
(
)
{
let
mut
zero
=
StepRng
:
:
new
(
0
0
)
;
let
rng
=
ChaChaCore
:
:
from_rng
(
&
mut
zero
)
.
unwrap
(
)
;
let
mut
rng1
=
ReseedingRng
:
:
new
(
rng
32
*
4
zero
)
;
let
first
:
u32
=
rng1
.
gen
(
)
;
for
_
in
0
.
.
10
{
let
_
=
rng1
.
gen
:
:
<
u32
>
(
)
;
}
let
mut
rng2
=
rng1
.
clone
(
)
;
assert_eq
!
(
first
rng2
.
gen
:
:
<
u32
>
(
)
)
;
}
}
