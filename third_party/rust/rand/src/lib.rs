#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
rand
/
"
)
]
#
[
cfg
(
test
)
]
#
[
macro_use
]
extern
crate
log
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
marker
;
use
std
:
:
mem
;
use
std
:
:
io
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
num
:
:
Wrapping
as
w
;
pub
use
os
:
:
OsRng
;
pub
use
isaac
:
:
{
IsaacRng
Isaac64Rng
}
;
pub
use
chacha
:
:
ChaChaRng
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
use
IsaacRng
as
IsaacWordRng
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
use
Isaac64Rng
as
IsaacWordRng
;
use
distributions
:
:
{
Range
IndependentSample
}
;
use
distributions
:
:
range
:
:
SampleRange
;
pub
mod
distributions
;
pub
mod
isaac
;
pub
mod
chacha
;
pub
mod
reseeding
;
mod
rand_impls
;
pub
mod
os
;
pub
mod
read
;
#
[
allow
(
bad_style
)
]
type
w64
=
w
<
u64
>
;
#
[
allow
(
bad_style
)
]
type
w32
=
w
<
u32
>
;
pub
trait
Rand
:
Sized
{
fn
rand
<
R
:
Rng
>
(
rng
:
&
mut
R
)
-
>
Self
;
}
pub
trait
Rng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
;
fn
next_u64
(
&
mut
self
)
-
>
u64
{
(
(
self
.
next_u32
(
)
as
u64
)
<
<
32
)
|
(
self
.
next_u32
(
)
as
u64
)
}
fn
next_f32
(
&
mut
self
)
-
>
f32
{
const
UPPER_MASK
:
u32
=
0x3F800000
;
const
LOWER_MASK
:
u32
=
0x7FFFFF
;
let
tmp
=
UPPER_MASK
|
(
self
.
next_u32
(
)
&
LOWER_MASK
)
;
let
result
:
f32
=
unsafe
{
mem
:
:
transmute
(
tmp
)
}
;
result
-
1
.
0
}
fn
next_f64
(
&
mut
self
)
-
>
f64
{
const
UPPER_MASK
:
u64
=
0x3FF0000000000000
;
const
LOWER_MASK
:
u64
=
0xFFFFFFFFFFFFF
;
let
tmp
=
UPPER_MASK
|
(
self
.
next_u64
(
)
&
LOWER_MASK
)
;
let
result
:
f64
=
unsafe
{
mem
:
:
transmute
(
tmp
)
}
;
result
-
1
.
0
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
let
mut
count
=
0
;
let
mut
num
=
0
;
for
byte
in
dest
.
iter_mut
(
)
{
if
count
=
=
0
{
num
=
self
.
next_u64
(
)
;
count
=
8
;
}
*
byte
=
(
num
&
0xff
)
as
u8
;
num
>
>
=
8
;
count
-
=
1
;
}
}
#
[
inline
(
always
)
]
fn
gen
<
T
:
Rand
>
(
&
mut
self
)
-
>
T
where
Self
:
Sized
{
Rand
:
:
rand
(
self
)
}
fn
gen_iter
<
'
a
T
:
Rand
>
(
&
'
a
mut
self
)
-
>
Generator
<
'
a
T
Self
>
where
Self
:
Sized
{
Generator
{
rng
:
self
_marker
:
marker
:
:
PhantomData
}
}
fn
gen_range
<
T
:
PartialOrd
+
SampleRange
>
(
&
mut
self
low
:
T
high
:
T
)
-
>
T
where
Self
:
Sized
{
assert
!
(
low
<
high
"
Rng
.
gen_range
called
with
low
>
=
high
"
)
;
Range
:
:
new
(
low
high
)
.
ind_sample
(
self
)
}
fn
gen_weighted_bool
(
&
mut
self
n
:
u32
)
-
>
bool
where
Self
:
Sized
{
n
<
=
1
|
|
self
.
gen_range
(
0
n
)
=
=
0
}
fn
gen_ascii_chars
<
'
a
>
(
&
'
a
mut
self
)
-
>
AsciiGenerator
<
'
a
Self
>
where
Self
:
Sized
{
AsciiGenerator
{
rng
:
self
}
}
fn
choose
<
'
a
T
>
(
&
mut
self
values
:
&
'
a
[
T
]
)
-
>
Option
<
&
'
a
T
>
where
Self
:
Sized
{
if
values
.
is_empty
(
)
{
None
}
else
{
Some
(
&
values
[
self
.
gen_range
(
0
values
.
len
(
)
)
]
)
}
}
fn
shuffle
<
T
>
(
&
mut
self
values
:
&
mut
[
T
]
)
where
Self
:
Sized
{
let
mut
i
=
values
.
len
(
)
;
while
i
>
=
2
{
i
-
=
1
;
values
.
swap
(
i
self
.
gen_range
(
0
i
+
1
)
)
;
}
}
}
impl
<
'
a
R
:
?
Sized
>
Rng
for
&
'
a
mut
R
where
R
:
Rng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
(
*
*
self
)
.
next_u32
(
)
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
(
*
*
self
)
.
next_u64
(
)
}
fn
next_f32
(
&
mut
self
)
-
>
f32
{
(
*
*
self
)
.
next_f32
(
)
}
fn
next_f64
(
&
mut
self
)
-
>
f64
{
(
*
*
self
)
.
next_f64
(
)
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
(
*
*
self
)
.
fill_bytes
(
dest
)
}
}
impl
<
R
:
?
Sized
>
Rng
for
Box
<
R
>
where
R
:
Rng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
(
*
*
self
)
.
next_u32
(
)
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
(
*
*
self
)
.
next_u64
(
)
}
fn
next_f32
(
&
mut
self
)
-
>
f32
{
(
*
*
self
)
.
next_f32
(
)
}
fn
next_f64
(
&
mut
self
)
-
>
f64
{
(
*
*
self
)
.
next_f64
(
)
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
(
*
*
self
)
.
fill_bytes
(
dest
)
}
}
pub
struct
Generator
<
'
a
T
R
:
'
a
>
{
rng
:
&
'
a
mut
R
_marker
:
marker
:
:
PhantomData
<
fn
(
)
-
>
T
>
}
impl
<
'
a
T
:
Rand
R
:
Rng
>
Iterator
for
Generator
<
'
a
T
R
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
Some
(
self
.
rng
.
gen
(
)
)
}
}
pub
struct
AsciiGenerator
<
'
a
R
:
'
a
>
{
rng
:
&
'
a
mut
R
}
impl
<
'
a
R
:
Rng
>
Iterator
for
AsciiGenerator
<
'
a
R
>
{
type
Item
=
char
;
fn
next
(
&
mut
self
)
-
>
Option
<
char
>
{
const
GEN_ASCII_STR_CHARSET
:
&
'
static
[
u8
]
=
b
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ
\
abcdefghijklmnopqrstuvwxyz
\
0123456789
"
;
Some
(
*
self
.
rng
.
choose
(
GEN_ASCII_STR_CHARSET
)
.
unwrap
(
)
as
char
)
}
}
pub
trait
SeedableRng
<
Seed
>
:
Rng
{
fn
reseed
(
&
mut
self
Seed
)
;
fn
from_seed
(
seed
:
Seed
)
-
>
Self
;
}
#
[
allow
(
missing_copy_implementations
)
]
#
[
derive
(
Clone
)
]
pub
struct
XorShiftRng
{
x
:
w32
y
:
w32
z
:
w32
w
:
w32
}
impl
XorShiftRng
{
pub
fn
new_unseeded
(
)
-
>
XorShiftRng
{
XorShiftRng
{
x
:
w
(
0x193a6754
)
y
:
w
(
0xa8a7d469
)
z
:
w
(
0x97830e05
)
w
:
w
(
0x113ba7bb
)
}
}
}
impl
Rng
for
XorShiftRng
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
let
x
=
self
.
x
;
let
t
=
x
^
(
x
<
<
11
)
;
self
.
x
=
self
.
y
;
self
.
y
=
self
.
z
;
self
.
z
=
self
.
w
;
let
w_
=
self
.
w
;
self
.
w
=
w_
^
(
w_
>
>
19
)
^
(
t
^
(
t
>
>
8
)
)
;
self
.
w
.
0
}
}
impl
SeedableRng
<
[
u32
;
4
]
>
for
XorShiftRng
{
fn
reseed
(
&
mut
self
seed
:
[
u32
;
4
]
)
{
assert
!
(
!
seed
.
iter
(
)
.
all
(
|
&
x
|
x
=
=
0
)
"
XorShiftRng
.
reseed
called
with
an
all
zero
seed
.
"
)
;
self
.
x
=
w
(
seed
[
0
]
)
;
self
.
y
=
w
(
seed
[
1
]
)
;
self
.
z
=
w
(
seed
[
2
]
)
;
self
.
w
=
w
(
seed
[
3
]
)
;
}
fn
from_seed
(
seed
:
[
u32
;
4
]
)
-
>
XorShiftRng
{
assert
!
(
!
seed
.
iter
(
)
.
all
(
|
&
x
|
x
=
=
0
)
"
XorShiftRng
:
:
from_seed
called
with
an
all
zero
seed
.
"
)
;
XorShiftRng
{
x
:
w
(
seed
[
0
]
)
y
:
w
(
seed
[
1
]
)
z
:
w
(
seed
[
2
]
)
w
:
w
(
seed
[
3
]
)
}
}
}
impl
Rand
for
XorShiftRng
{
fn
rand
<
R
:
Rng
>
(
rng
:
&
mut
R
)
-
>
XorShiftRng
{
let
mut
tuple
:
(
u32
u32
u32
u32
)
=
rng
.
gen
(
)
;
while
tuple
=
=
(
0
0
0
0
)
{
tuple
=
rng
.
gen
(
)
;
}
let
(
x
y
z
w_
)
=
tuple
;
XorShiftRng
{
x
:
w
(
x
)
y
:
w
(
y
)
z
:
w
(
z
)
w
:
w
(
w_
)
}
}
}
pub
struct
Open01
<
F
>
(
pub
F
)
;
pub
struct
Closed01
<
F
>
(
pub
F
)
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
StdRng
{
rng
:
IsaacWordRng
}
impl
StdRng
{
pub
fn
new
(
)
-
>
io
:
:
Result
<
StdRng
>
{
OsRng
:
:
new
(
)
.
map
(
|
mut
r
|
StdRng
{
rng
:
r
.
gen
(
)
}
)
}
}
impl
Rng
for
StdRng
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
rng
.
next_u32
(
)
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
rng
.
next_u64
(
)
}
}
impl
<
'
a
>
SeedableRng
<
&
'
a
[
usize
]
>
for
StdRng
{
fn
reseed
(
&
mut
self
seed
:
&
'
a
[
usize
]
)
{
self
.
rng
.
reseed
(
unsafe
{
mem
:
:
transmute
(
seed
)
}
)
}
fn
from_seed
(
seed
:
&
'
a
[
usize
]
)
-
>
StdRng
{
StdRng
{
rng
:
SeedableRng
:
:
from_seed
(
unsafe
{
mem
:
:
transmute
(
seed
)
}
)
}
}
}
pub
fn
weak_rng
(
)
-
>
XorShiftRng
{
match
OsRng
:
:
new
(
)
{
Ok
(
mut
r
)
=
>
r
.
gen
(
)
Err
(
e
)
=
>
panic
!
(
"
weak_rng
:
failed
to
create
seeded
RNG
:
{
:
?
}
"
e
)
}
}
struct
ThreadRngReseeder
;
impl
reseeding
:
:
Reseeder
<
StdRng
>
for
ThreadRngReseeder
{
fn
reseed
(
&
mut
self
rng
:
&
mut
StdRng
)
{
*
rng
=
match
StdRng
:
:
new
(
)
{
Ok
(
r
)
=
>
r
Err
(
e
)
=
>
panic
!
(
"
could
not
reseed
thread_rng
:
{
}
"
e
)
}
}
}
const
THREAD_RNG_RESEED_THRESHOLD
:
u64
=
32_768
;
type
ThreadRngInner
=
reseeding
:
:
ReseedingRng
<
StdRng
ThreadRngReseeder
>
;
#
[
derive
(
Clone
)
]
pub
struct
ThreadRng
{
rng
:
Rc
<
RefCell
<
ThreadRngInner
>
>
}
pub
fn
thread_rng
(
)
-
>
ThreadRng
{
thread_local
!
(
static
THREAD_RNG_KEY
:
Rc
<
RefCell
<
ThreadRngInner
>
>
=
{
let
r
=
match
StdRng
:
:
new
(
)
{
Ok
(
r
)
=
>
r
Err
(
e
)
=
>
panic
!
(
"
could
not
initialize
thread_rng
:
{
}
"
e
)
}
;
let
rng
=
reseeding
:
:
ReseedingRng
:
:
new
(
r
THREAD_RNG_RESEED_THRESHOLD
ThreadRngReseeder
)
;
Rc
:
:
new
(
RefCell
:
:
new
(
rng
)
)
}
)
;
ThreadRng
{
rng
:
THREAD_RNG_KEY
.
with
(
|
t
|
t
.
clone
(
)
)
}
}
impl
Rng
for
ThreadRng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
rng
.
borrow_mut
(
)
.
next_u32
(
)
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
rng
.
borrow_mut
(
)
.
next_u64
(
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
bytes
:
&
mut
[
u8
]
)
{
self
.
rng
.
borrow_mut
(
)
.
fill_bytes
(
bytes
)
}
}
#
[
inline
]
pub
fn
random
<
T
:
Rand
>
(
)
-
>
T
{
thread_rng
(
)
.
gen
(
)
}
pub
fn
sample
<
T
I
R
>
(
rng
:
&
mut
R
iterable
:
I
amount
:
usize
)
-
>
Vec
<
T
>
where
I
:
IntoIterator
<
Item
=
T
>
R
:
Rng
{
let
mut
iter
=
iterable
.
into_iter
(
)
;
let
mut
reservoir
:
Vec
<
T
>
=
iter
.
by_ref
(
)
.
take
(
amount
)
.
collect
(
)
;
if
reservoir
.
len
(
)
=
=
amount
{
for
(
i
elem
)
in
iter
.
enumerate
(
)
{
let
k
=
rng
.
gen_range
(
0
i
+
1
+
amount
)
;
if
let
Some
(
spot
)
=
reservoir
.
get_mut
(
k
)
{
*
spot
=
elem
;
}
}
}
reservoir
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
{
Rng
thread_rng
random
SeedableRng
StdRng
sample
}
;
use
std
:
:
iter
:
:
repeat
;
pub
struct
MyRng
<
R
>
{
inner
:
R
}
impl
<
R
:
Rng
>
Rng
for
MyRng
<
R
>
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
fn
next
<
T
:
Rng
>
(
t
:
&
mut
T
)
-
>
u32
{
t
.
next_u32
(
)
}
next
(
&
mut
self
.
inner
)
}
}
pub
fn
rng
(
)
-
>
MyRng
<
:
:
ThreadRng
>
{
MyRng
{
inner
:
:
:
thread_rng
(
)
}
}
struct
ConstRng
{
i
:
u64
}
impl
Rng
for
ConstRng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
i
as
u32
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
i
}
}
pub
fn
iter_eq
<
I
J
>
(
i
:
I
j
:
J
)
-
>
bool
where
I
:
IntoIterator
J
:
IntoIterator
<
Item
=
I
:
:
Item
>
I
:
:
Item
:
Eq
{
let
mut
i
=
i
.
into_iter
(
)
;
let
mut
j
=
j
.
into_iter
(
)
;
loop
{
match
(
i
.
next
(
)
j
.
next
(
)
)
{
(
Some
(
ref
ei
)
Some
(
ref
ej
)
)
if
ei
=
=
ej
=
>
{
}
(
None
None
)
=
>
return
true
_
=
>
return
false
}
}
}
#
[
test
]
fn
test_fill_bytes_default
(
)
{
let
mut
r
=
ConstRng
{
i
:
0x11_22_33_44_55_66_77_88
}
;
let
lengths
=
[
0
1
2
3
4
5
6
7
80
81
82
83
84
85
86
87
]
;
for
&
n
in
lengths
.
iter
(
)
{
let
mut
v
=
repeat
(
0u8
)
.
take
(
n
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
r
.
fill_bytes
(
&
mut
v
)
;
for
(
i
&
byte
)
in
v
.
iter
(
)
.
enumerate
(
)
{
if
byte
=
=
0
{
panic
!
(
"
byte
{
}
of
{
}
is
zero
"
i
n
)
}
}
}
}
#
[
test
]
fn
test_gen_range
(
)
{
let
mut
r
=
thread_rng
(
)
;
for
_
in
0
.
.
1000
{
let
a
=
r
.
gen_range
(
-
3
42
)
;
assert
!
(
a
>
=
-
3
&
&
a
<
42
)
;
assert_eq
!
(
r
.
gen_range
(
0
1
)
0
)
;
assert_eq
!
(
r
.
gen_range
(
-
12
-
11
)
-
12
)
;
}
for
_
in
0
.
.
1000
{
let
a
=
r
.
gen_range
(
10
42
)
;
assert
!
(
a
>
=
10
&
&
a
<
42
)
;
assert_eq
!
(
r
.
gen_range
(
0
1
)
0
)
;
assert_eq
!
(
r
.
gen_range
(
3_000_000
3_000_001
)
3_000_000
)
;
}
}
#
[
test
]
#
[
should_panic
]
#
[
cfg_attr
(
target_env
=
"
msvc
"
ignore
)
]
fn
test_gen_range_panic_int
(
)
{
let
mut
r
=
thread_rng
(
)
;
r
.
gen_range
(
5
-
2
)
;
}
#
[
test
]
#
[
should_panic
]
#
[
cfg_attr
(
target_env
=
"
msvc
"
ignore
)
]
fn
test_gen_range_panic_usize
(
)
{
let
mut
r
=
thread_rng
(
)
;
r
.
gen_range
(
5
2
)
;
}
#
[
test
]
fn
test_gen_f64
(
)
{
let
mut
r
=
thread_rng
(
)
;
let
a
=
r
.
gen
:
:
<
f64
>
(
)
;
let
b
=
r
.
gen
:
:
<
f64
>
(
)
;
debug
!
(
"
{
:
?
}
"
(
a
b
)
)
;
}
#
[
test
]
fn
test_gen_weighted_bool
(
)
{
let
mut
r
=
thread_rng
(
)
;
assert_eq
!
(
r
.
gen_weighted_bool
(
0
)
true
)
;
assert_eq
!
(
r
.
gen_weighted_bool
(
1
)
true
)
;
}
#
[
test
]
fn
test_gen_ascii_str
(
)
{
let
mut
r
=
thread_rng
(
)
;
assert_eq
!
(
r
.
gen_ascii_chars
(
)
.
take
(
0
)
.
count
(
)
0
)
;
assert_eq
!
(
r
.
gen_ascii_chars
(
)
.
take
(
10
)
.
count
(
)
10
)
;
assert_eq
!
(
r
.
gen_ascii_chars
(
)
.
take
(
16
)
.
count
(
)
16
)
;
}
#
[
test
]
fn
test_gen_vec
(
)
{
let
mut
r
=
thread_rng
(
)
;
assert_eq
!
(
r
.
gen_iter
:
:
<
u8
>
(
)
.
take
(
0
)
.
count
(
)
0
)
;
assert_eq
!
(
r
.
gen_iter
:
:
<
u8
>
(
)
.
take
(
10
)
.
count
(
)
10
)
;
assert_eq
!
(
r
.
gen_iter
:
:
<
f64
>
(
)
.
take
(
16
)
.
count
(
)
16
)
;
}
#
[
test
]
fn
test_choose
(
)
{
let
mut
r
=
thread_rng
(
)
;
assert_eq
!
(
r
.
choose
(
&
[
1
1
1
]
)
.
map
(
|
&
x
|
x
)
Some
(
1
)
)
;
let
v
:
&
[
isize
]
=
&
[
]
;
assert_eq
!
(
r
.
choose
(
v
)
None
)
;
}
#
[
test
]
fn
test_shuffle
(
)
{
let
mut
r
=
thread_rng
(
)
;
let
empty
:
&
mut
[
isize
]
=
&
mut
[
]
;
r
.
shuffle
(
empty
)
;
let
mut
one
=
[
1
]
;
r
.
shuffle
(
&
mut
one
)
;
let
b
:
&
[
_
]
=
&
[
1
]
;
assert_eq
!
(
one
b
)
;
let
mut
two
=
[
1
2
]
;
r
.
shuffle
(
&
mut
two
)
;
assert
!
(
two
=
=
[
1
2
]
|
|
two
=
=
[
2
1
]
)
;
let
mut
x
=
[
1
1
1
]
;
r
.
shuffle
(
&
mut
x
)
;
let
b
:
&
[
_
]
=
&
[
1
1
1
]
;
assert_eq
!
(
x
b
)
;
}
#
[
test
]
fn
test_thread_rng
(
)
{
let
mut
r
=
thread_rng
(
)
;
r
.
gen
:
:
<
i32
>
(
)
;
let
mut
v
=
[
1
1
1
]
;
r
.
shuffle
(
&
mut
v
)
;
let
b
:
&
[
_
]
=
&
[
1
1
1
]
;
assert_eq
!
(
v
b
)
;
assert_eq
!
(
r
.
gen_range
(
0
1
)
0
)
;
}
#
[
test
]
fn
test_rng_trait_object
(
)
{
let
mut
rng
=
thread_rng
(
)
;
{
let
mut
r
=
&
mut
rng
as
&
mut
Rng
;
r
.
next_u32
(
)
;
(
&
mut
r
)
.
gen
:
:
<
i32
>
(
)
;
let
mut
v
=
[
1
1
1
]
;
(
&
mut
r
)
.
shuffle
(
&
mut
v
)
;
let
b
:
&
[
_
]
=
&
[
1
1
1
]
;
assert_eq
!
(
v
b
)
;
assert_eq
!
(
(
&
mut
r
)
.
gen_range
(
0
1
)
0
)
;
}
{
let
mut
r
=
Box
:
:
new
(
rng
)
as
Box
<
Rng
>
;
r
.
next_u32
(
)
;
r
.
gen
:
:
<
i32
>
(
)
;
let
mut
v
=
[
1
1
1
]
;
r
.
shuffle
(
&
mut
v
)
;
let
b
:
&
[
_
]
=
&
[
1
1
1
]
;
assert_eq
!
(
v
b
)
;
assert_eq
!
(
r
.
gen_range
(
0
1
)
0
)
;
}
}
#
[
test
]
fn
test_random
(
)
{
let
_n
:
usize
=
random
(
)
;
let
_f
:
f32
=
random
(
)
;
let
_o
:
Option
<
Option
<
i8
>
>
=
random
(
)
;
let
_many
:
(
(
)
(
usize
isize
Option
<
(
u32
(
bool
)
)
>
)
(
u8
i8
u16
i16
u32
i32
u64
i64
)
(
f32
(
f64
(
f64
)
)
)
)
=
random
(
)
;
}
#
[
test
]
fn
test_sample
(
)
{
let
min_val
=
1
;
let
max_val
=
100
;
let
mut
r
=
thread_rng
(
)
;
let
vals
=
(
min_val
.
.
max_val
)
.
collect
:
:
<
Vec
<
i32
>
>
(
)
;
let
small_sample
=
sample
(
&
mut
r
vals
.
iter
(
)
5
)
;
let
large_sample
=
sample
(
&
mut
r
vals
.
iter
(
)
vals
.
len
(
)
+
5
)
;
assert_eq
!
(
small_sample
.
len
(
)
5
)
;
assert_eq
!
(
large_sample
.
len
(
)
vals
.
len
(
)
)
;
assert
!
(
small_sample
.
iter
(
)
.
all
(
|
e
|
{
*
*
e
>
=
min_val
&
&
*
*
e
<
=
max_val
}
)
)
;
}
#
[
test
]
fn
test_std_rng_seeded
(
)
{
let
s
=
thread_rng
(
)
.
gen_iter
:
:
<
usize
>
(
)
.
take
(
256
)
.
collect
:
:
<
Vec
<
usize
>
>
(
)
;
let
mut
ra
:
StdRng
=
SeedableRng
:
:
from_seed
(
&
s
[
.
.
]
)
;
let
mut
rb
:
StdRng
=
SeedableRng
:
:
from_seed
(
&
s
[
.
.
]
)
;
assert
!
(
iter_eq
(
ra
.
gen_ascii_chars
(
)
.
take
(
100
)
rb
.
gen_ascii_chars
(
)
.
take
(
100
)
)
)
;
}
#
[
test
]
fn
test_std_rng_reseed
(
)
{
let
s
=
thread_rng
(
)
.
gen_iter
:
:
<
usize
>
(
)
.
take
(
256
)
.
collect
:
:
<
Vec
<
usize
>
>
(
)
;
let
mut
r
:
StdRng
=
SeedableRng
:
:
from_seed
(
&
s
[
.
.
]
)
;
let
string1
=
r
.
gen_ascii_chars
(
)
.
take
(
100
)
.
collect
:
:
<
String
>
(
)
;
r
.
reseed
(
&
s
)
;
let
string2
=
r
.
gen_ascii_chars
(
)
.
take
(
100
)
.
collect
:
:
<
String
>
(
)
;
assert_eq
!
(
string1
string2
)
;
}
}
