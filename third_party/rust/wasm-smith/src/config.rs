use
arbitrary
:
:
{
Arbitrary
Result
Unstructured
}
;
pub
trait
Config
:
'
static
+
std
:
:
fmt
:
:
Debug
{
fn
min_types
(
&
self
)
-
>
usize
{
0
}
fn
max_types
(
&
self
)
-
>
usize
{
100
}
fn
min_imports
(
&
self
)
-
>
usize
{
0
}
fn
max_imports
(
&
self
)
-
>
usize
{
100
}
fn
min_tags
(
&
self
)
-
>
usize
{
0
}
fn
max_tags
(
&
self
)
-
>
usize
{
100
}
fn
min_funcs
(
&
self
)
-
>
usize
{
0
}
fn
max_funcs
(
&
self
)
-
>
usize
{
100
}
fn
min_globals
(
&
self
)
-
>
usize
{
0
}
fn
max_globals
(
&
self
)
-
>
usize
{
100
}
fn
min_exports
(
&
self
)
-
>
usize
{
0
}
fn
max_exports
(
&
self
)
-
>
usize
{
100
}
fn
min_element_segments
(
&
self
)
-
>
usize
{
0
}
fn
max_element_segments
(
&
self
)
-
>
usize
{
100
}
fn
min_elements
(
&
self
)
-
>
usize
{
0
}
fn
max_elements
(
&
self
)
-
>
usize
{
100
}
fn
min_data_segments
(
&
self
)
-
>
usize
{
0
}
fn
max_data_segments
(
&
self
)
-
>
usize
{
100
}
fn
max_instructions
(
&
self
)
-
>
usize
{
100
}
fn
min_memories
(
&
self
)
-
>
u32
{
0
}
fn
max_memories
(
&
self
)
-
>
usize
{
1
}
fn
min_tables
(
&
self
)
-
>
u32
{
0
}
fn
max_tables
(
&
self
)
-
>
usize
{
1
}
fn
max_memory_pages
(
&
self
is_64
:
bool
)
-
>
u64
{
if
is_64
{
1
<
<
48
}
else
{
1
<
<
16
}
}
fn
memory_max_size_required
(
&
self
)
-
>
bool
{
false
}
fn
max_instances
(
&
self
)
-
>
usize
{
10
}
fn
max_modules
(
&
self
)
-
>
usize
{
10
}
fn
memory_offset_choices
(
&
self
)
-
>
(
u32
u32
u32
)
{
(
75
24
1
)
}
fn
min_uleb_size
(
&
self
)
-
>
u8
{
1
}
fn
bulk_memory_enabled
(
&
self
)
-
>
bool
{
false
}
fn
reference_types_enabled
(
&
self
)
-
>
bool
{
false
}
fn
simd_enabled
(
&
self
)
-
>
bool
{
false
}
fn
exceptions_enabled
(
&
self
)
-
>
bool
{
false
}
fn
module_linking_enabled
(
&
self
)
-
>
bool
{
false
}
fn
allow_start_export
(
&
self
)
-
>
bool
{
true
}
fn
max_aliases
(
&
self
)
-
>
usize
{
1_000
}
fn
max_nesting_depth
(
&
self
)
-
>
usize
{
10
}
fn
max_type_size
(
&
self
)
-
>
u32
{
1_000
}
fn
memory64_enabled
(
&
self
)
-
>
bool
{
false
}
fn
canonicalize_nans
(
&
self
)
-
>
bool
{
false
}
}
#
[
derive
(
Arbitrary
Debug
Default
Copy
Clone
)
]
pub
struct
DefaultConfig
;
impl
Config
for
DefaultConfig
{
}
#
[
derive
(
Clone
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
SwarmConfig
{
pub
max_types
:
usize
pub
max_imports
:
usize
pub
max_tags
:
usize
pub
max_funcs
:
usize
pub
max_globals
:
usize
pub
max_exports
:
usize
pub
max_element_segments
:
usize
pub
max_elements
:
usize
pub
max_data_segments
:
usize
pub
max_instructions
:
usize
pub
max_memories
:
usize
pub
min_uleb_size
:
u8
pub
max_tables
:
usize
pub
max_memory_pages
:
u64
pub
bulk_memory_enabled
:
bool
pub
reference_types_enabled
:
bool
pub
module_linking_enabled
:
bool
pub
max_aliases
:
usize
pub
max_nesting_depth
:
usize
pub
memory64_enabled
:
bool
pub
min_types
:
usize
pub
min_imports
:
usize
pub
min_tags
:
usize
pub
min_funcs
:
usize
pub
min_globals
:
usize
pub
min_exports
:
usize
pub
min_data_segments
:
usize
pub
min_element_segments
:
usize
pub
min_elements
:
usize
pub
min_memories
:
u32
pub
min_tables
:
u32
pub
max_instances
:
usize
pub
max_modules
:
usize
pub
memory_offset_choices
:
(
u32
u32
u32
)
pub
memory_max_size_required
:
bool
pub
simd_enabled
:
bool
pub
exceptions_enabled
:
bool
pub
allow_start_export
:
bool
pub
max_type_size
:
u32
pub
canonicalize_nans
:
bool
}
impl
<
'
a
>
Arbitrary
<
'
a
>
for
SwarmConfig
{
fn
arbitrary
(
u
:
&
mut
Unstructured
<
'
a
>
)
-
>
Result
<
Self
>
{
const
MAX_MAXIMUM
:
usize
=
1000
;
let
reference_types_enabled
:
bool
=
u
.
arbitrary
(
)
?
;
let
max_tables
=
if
reference_types_enabled
{
100
}
else
{
1
}
;
Ok
(
SwarmConfig
{
max_types
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_imports
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_tags
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_funcs
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_globals
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_exports
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_element_segments
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_elements
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_data_segments
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_instructions
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_memories
:
u
.
int_in_range
(
0
.
.
=
100
)
?
max_tables
max_memory_pages
:
u
.
arbitrary
(
)
?
min_uleb_size
:
u
.
int_in_range
(
0
.
.
=
5
)
?
bulk_memory_enabled
:
u
.
arbitrary
(
)
?
reference_types_enabled
max_aliases
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_nesting_depth
:
u
.
int_in_range
(
0
.
.
=
10
)
?
min_types
:
0
min_imports
:
0
min_tags
:
0
min_funcs
:
0
min_globals
:
0
min_exports
:
0
min_element_segments
:
0
min_elements
:
0
min_data_segments
:
0
min_memories
:
0
min_tables
:
0
memory_max_size_required
:
false
max_instances
:
0
max_modules
:
0
memory_offset_choices
:
(
75
24
1
)
allow_start_export
:
true
simd_enabled
:
false
exceptions_enabled
:
false
memory64_enabled
:
false
max_type_size
:
1000
module_linking_enabled
:
false
canonicalize_nans
:
false
}
)
}
}
impl
Config
for
SwarmConfig
{
fn
min_types
(
&
self
)
-
>
usize
{
self
.
min_types
}
fn
max_types
(
&
self
)
-
>
usize
{
self
.
max_types
}
fn
min_imports
(
&
self
)
-
>
usize
{
self
.
min_imports
}
fn
max_imports
(
&
self
)
-
>
usize
{
self
.
max_imports
}
fn
min_funcs
(
&
self
)
-
>
usize
{
self
.
min_funcs
}
fn
max_funcs
(
&
self
)
-
>
usize
{
self
.
max_funcs
}
fn
min_globals
(
&
self
)
-
>
usize
{
self
.
min_globals
}
fn
max_globals
(
&
self
)
-
>
usize
{
self
.
max_globals
}
fn
min_exports
(
&
self
)
-
>
usize
{
self
.
min_exports
}
fn
max_exports
(
&
self
)
-
>
usize
{
self
.
max_exports
}
fn
min_element_segments
(
&
self
)
-
>
usize
{
self
.
min_element_segments
}
fn
max_element_segments
(
&
self
)
-
>
usize
{
self
.
max_element_segments
}
fn
min_elements
(
&
self
)
-
>
usize
{
self
.
min_elements
}
fn
max_elements
(
&
self
)
-
>
usize
{
self
.
max_elements
}
fn
min_data_segments
(
&
self
)
-
>
usize
{
self
.
min_data_segments
}
fn
max_data_segments
(
&
self
)
-
>
usize
{
self
.
max_data_segments
}
fn
max_instructions
(
&
self
)
-
>
usize
{
self
.
max_instructions
}
fn
min_memories
(
&
self
)
-
>
u32
{
self
.
min_memories
}
fn
max_memories
(
&
self
)
-
>
usize
{
self
.
max_memories
}
fn
min_tables
(
&
self
)
-
>
u32
{
self
.
min_tables
}
fn
max_tables
(
&
self
)
-
>
usize
{
self
.
max_tables
}
fn
max_memory_pages
(
&
self
is_64
:
bool
)
-
>
u64
{
if
is_64
{
self
.
max_memory_pages
.
min
(
1
<
<
48
)
}
else
{
self
.
max_memory_pages
.
min
(
1
<
<
16
)
}
}
fn
memory_max_size_required
(
&
self
)
-
>
bool
{
self
.
memory_max_size_required
}
fn
max_instances
(
&
self
)
-
>
usize
{
self
.
max_instances
}
fn
max_modules
(
&
self
)
-
>
usize
{
self
.
max_modules
}
fn
memory_offset_choices
(
&
self
)
-
>
(
u32
u32
u32
)
{
self
.
memory_offset_choices
}
fn
min_uleb_size
(
&
self
)
-
>
u8
{
self
.
min_uleb_size
}
fn
bulk_memory_enabled
(
&
self
)
-
>
bool
{
self
.
bulk_memory_enabled
}
fn
reference_types_enabled
(
&
self
)
-
>
bool
{
self
.
reference_types_enabled
}
fn
module_linking_enabled
(
&
self
)
-
>
bool
{
self
.
module_linking_enabled
}
fn
simd_enabled
(
&
self
)
-
>
bool
{
self
.
simd_enabled
}
fn
exceptions_enabled
(
&
self
)
-
>
bool
{
self
.
exceptions_enabled
}
fn
allow_start_export
(
&
self
)
-
>
bool
{
self
.
allow_start_export
}
fn
max_aliases
(
&
self
)
-
>
usize
{
self
.
max_aliases
}
fn
max_nesting_depth
(
&
self
)
-
>
usize
{
self
.
max_nesting_depth
}
fn
memory64_enabled
(
&
self
)
-
>
bool
{
self
.
memory64_enabled
}
fn
canonicalize_nans
(
&
self
)
-
>
bool
{
self
.
canonicalize_nans
}
}
