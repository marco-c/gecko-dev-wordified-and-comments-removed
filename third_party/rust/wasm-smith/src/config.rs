use
crate
:
:
InstructionKinds
;
use
arbitrary
:
:
{
Arbitrary
Result
Unstructured
}
;
use
std
:
:
borrow
:
:
Cow
;
pub
trait
Config
:
'
static
+
std
:
:
fmt
:
:
Debug
{
fn
min_types
(
&
self
)
-
>
usize
{
0
}
fn
max_types
(
&
self
)
-
>
usize
{
100
}
fn
min_imports
(
&
self
)
-
>
usize
{
0
}
fn
max_imports
(
&
self
)
-
>
usize
{
100
}
fn
min_tags
(
&
self
)
-
>
usize
{
0
}
fn
max_tags
(
&
self
)
-
>
usize
{
100
}
fn
available_imports
(
&
self
)
-
>
Option
<
Cow
<
'
_
[
u8
]
>
>
{
None
}
fn
min_funcs
(
&
self
)
-
>
usize
{
0
}
fn
max_funcs
(
&
self
)
-
>
usize
{
100
}
fn
min_globals
(
&
self
)
-
>
usize
{
0
}
fn
max_globals
(
&
self
)
-
>
usize
{
100
}
fn
min_exports
(
&
self
)
-
>
usize
{
0
}
fn
max_exports
(
&
self
)
-
>
usize
{
100
}
fn
export_everything
(
&
self
)
-
>
bool
{
false
}
fn
min_element_segments
(
&
self
)
-
>
usize
{
0
}
fn
max_element_segments
(
&
self
)
-
>
usize
{
100
}
fn
min_elements
(
&
self
)
-
>
usize
{
0
}
fn
max_elements
(
&
self
)
-
>
usize
{
100
}
fn
min_data_segments
(
&
self
)
-
>
usize
{
0
}
fn
max_data_segments
(
&
self
)
-
>
usize
{
100
}
fn
max_instructions
(
&
self
)
-
>
usize
{
100
}
fn
min_memories
(
&
self
)
-
>
u32
{
0
}
fn
max_memories
(
&
self
)
-
>
usize
{
1
}
fn
min_tables
(
&
self
)
-
>
u32
{
0
}
fn
max_tables
(
&
self
)
-
>
usize
{
1
}
fn
max_memory_pages
(
&
self
is_64
:
bool
)
-
>
u64
{
if
is_64
{
1
<
<
48
}
else
{
1
<
<
16
}
}
fn
memory_max_size_required
(
&
self
)
-
>
bool
{
false
}
fn
max_table_elements
(
&
self
)
-
>
u32
{
1_000_000
}
fn
table_max_size_required
(
&
self
)
-
>
bool
{
false
}
fn
max_instances
(
&
self
)
-
>
usize
{
10
}
fn
max_modules
(
&
self
)
-
>
usize
{
10
}
fn
max_components
(
&
self
)
-
>
usize
{
10
}
fn
max_values
(
&
self
)
-
>
usize
{
10
}
fn
memory_offset_choices
(
&
self
)
-
>
(
u32
u32
u32
)
{
(
75
24
1
)
}
fn
min_uleb_size
(
&
self
)
-
>
u8
{
1
}
fn
bulk_memory_enabled
(
&
self
)
-
>
bool
{
false
}
fn
reference_types_enabled
(
&
self
)
-
>
bool
{
false
}
fn
simd_enabled
(
&
self
)
-
>
bool
{
false
}
fn
relaxed_simd_enabled
(
&
self
)
-
>
bool
{
false
}
fn
exceptions_enabled
(
&
self
)
-
>
bool
{
false
}
fn
multi_value_enabled
(
&
self
)
-
>
bool
{
true
}
fn
saturating_float_to_int_enabled
(
&
self
)
-
>
bool
{
true
}
fn
sign_extension_ops_enabled
(
&
self
)
-
>
bool
{
true
}
fn
allow_start_export
(
&
self
)
-
>
bool
{
true
}
fn
max_aliases
(
&
self
)
-
>
usize
{
1_000
}
fn
max_nesting_depth
(
&
self
)
-
>
usize
{
10
}
fn
max_type_size
(
&
self
)
-
>
u32
{
1_000
}
fn
memory64_enabled
(
&
self
)
-
>
bool
{
false
}
fn
canonicalize_nans
(
&
self
)
-
>
bool
{
false
}
fn
allowed_instructions
(
&
self
)
-
>
InstructionKinds
{
InstructionKinds
:
:
all
(
)
}
fn
generate_custom_sections
(
&
self
)
-
>
bool
{
false
}
fn
threads_enabled
(
&
self
)
-
>
bool
{
false
}
fn
disallow_traps
(
&
self
)
-
>
bool
{
false
}
}
#
[
derive
(
Arbitrary
Debug
Default
Copy
Clone
)
]
pub
struct
DefaultConfig
;
impl
Config
for
DefaultConfig
{
}
#
[
derive
(
Clone
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
SwarmConfig
{
pub
allow_start_export
:
bool
pub
available_imports
:
Option
<
Vec
<
u8
>
>
pub
bulk_memory_enabled
:
bool
pub
canonicalize_nans
:
bool
pub
disallow_traps
:
bool
pub
exceptions_enabled
:
bool
pub
export_everything
:
bool
pub
max_aliases
:
usize
pub
max_components
:
usize
pub
max_data_segments
:
usize
pub
max_element_segments
:
usize
pub
max_elements
:
usize
pub
max_exports
:
usize
pub
max_funcs
:
usize
pub
max_globals
:
usize
pub
max_imports
:
usize
pub
max_instances
:
usize
pub
max_instructions
:
usize
pub
max_memories
:
usize
pub
max_memory_pages
:
u64
pub
max_modules
:
usize
pub
max_nesting_depth
:
usize
pub
max_tables
:
usize
pub
max_tags
:
usize
pub
max_type_size
:
u32
pub
max_types
:
usize
pub
max_values
:
usize
pub
memory64_enabled
:
bool
pub
memory_max_size_required
:
bool
pub
memory_offset_choices
:
(
u32
u32
u32
)
pub
min_data_segments
:
usize
pub
min_element_segments
:
usize
pub
min_elements
:
usize
pub
min_exports
:
usize
pub
min_funcs
:
usize
pub
min_globals
:
usize
pub
min_imports
:
usize
pub
min_memories
:
u32
pub
min_tables
:
u32
pub
min_tags
:
usize
pub
min_types
:
usize
pub
min_uleb_size
:
u8
pub
multi_value_enabled
:
bool
pub
reference_types_enabled
:
bool
pub
relaxed_simd_enabled
:
bool
pub
saturating_float_to_int_enabled
:
bool
pub
sign_extension_enabled
:
bool
pub
simd_enabled
:
bool
pub
threads_enabled
:
bool
pub
allowed_instructions
:
InstructionKinds
pub
max_table_elements
:
u32
pub
table_max_size_required
:
bool
}
impl
<
'
a
>
Arbitrary
<
'
a
>
for
SwarmConfig
{
fn
arbitrary
(
u
:
&
mut
Unstructured
<
'
a
>
)
-
>
Result
<
Self
>
{
const
MAX_MAXIMUM
:
usize
=
1000
;
let
reference_types_enabled
:
bool
=
u
.
arbitrary
(
)
?
;
let
max_tables
=
if
reference_types_enabled
{
100
}
else
{
1
}
;
Ok
(
SwarmConfig
{
max_types
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_imports
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_tags
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_funcs
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_globals
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_exports
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_element_segments
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_elements
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_data_segments
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_instructions
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_memories
:
u
.
int_in_range
(
0
.
.
=
100
)
?
max_tables
max_memory_pages
:
u
.
arbitrary
(
)
?
min_uleb_size
:
u
.
int_in_range
(
0
.
.
=
5
)
?
bulk_memory_enabled
:
reference_types_enabled
|
|
u
.
arbitrary
(
)
?
reference_types_enabled
simd_enabled
:
u
.
arbitrary
(
)
?
multi_value_enabled
:
u
.
arbitrary
(
)
?
max_aliases
:
u
.
int_in_range
(
0
.
.
=
MAX_MAXIMUM
)
?
max_nesting_depth
:
u
.
int_in_range
(
0
.
.
=
10
)
?
saturating_float_to_int_enabled
:
u
.
arbitrary
(
)
?
sign_extension_enabled
:
u
.
arbitrary
(
)
?
allowed_instructions
:
{
use
flagset
:
:
Flags
;
let
mut
allowed
=
Vec
:
:
new
(
)
;
for
kind
in
crate
:
:
core
:
:
InstructionKind
:
:
LIST
{
if
u
.
arbitrary
(
)
?
{
allowed
.
push
(
*
kind
)
;
}
}
InstructionKinds
:
:
new
(
&
allowed
)
}
table_max_size_required
:
u
.
arbitrary
(
)
?
max_table_elements
:
u
.
int_in_range
(
0
.
.
=
1_000_000
)
?
min_types
:
0
min_imports
:
0
min_tags
:
0
min_funcs
:
0
min_globals
:
0
min_exports
:
0
min_element_segments
:
0
min_elements
:
0
min_data_segments
:
0
min_memories
:
0
min_tables
:
0
memory_max_size_required
:
false
max_instances
:
0
max_modules
:
0
max_components
:
0
max_values
:
0
memory_offset_choices
:
(
75
24
1
)
allow_start_export
:
true
relaxed_simd_enabled
:
false
exceptions_enabled
:
false
memory64_enabled
:
false
max_type_size
:
1000
canonicalize_nans
:
false
available_imports
:
None
threads_enabled
:
false
export_everything
:
false
disallow_traps
:
false
}
)
}
}
impl
Config
for
SwarmConfig
{
fn
min_types
(
&
self
)
-
>
usize
{
self
.
min_types
}
fn
max_types
(
&
self
)
-
>
usize
{
self
.
max_types
}
fn
min_imports
(
&
self
)
-
>
usize
{
self
.
min_imports
}
fn
max_imports
(
&
self
)
-
>
usize
{
self
.
max_imports
}
fn
available_imports
(
&
self
)
-
>
Option
<
Cow
<
'
_
[
u8
]
>
>
{
self
.
available_imports
.
as_ref
(
)
.
map
(
|
is
|
Cow
:
:
Borrowed
(
&
is
[
.
.
]
)
)
}
fn
min_funcs
(
&
self
)
-
>
usize
{
self
.
min_funcs
}
fn
max_funcs
(
&
self
)
-
>
usize
{
self
.
max_funcs
}
fn
min_globals
(
&
self
)
-
>
usize
{
self
.
min_globals
}
fn
max_globals
(
&
self
)
-
>
usize
{
self
.
max_globals
}
fn
min_exports
(
&
self
)
-
>
usize
{
self
.
min_exports
}
fn
max_exports
(
&
self
)
-
>
usize
{
self
.
max_exports
}
fn
export_everything
(
&
self
)
-
>
bool
{
self
.
export_everything
}
fn
min_element_segments
(
&
self
)
-
>
usize
{
self
.
min_element_segments
}
fn
max_element_segments
(
&
self
)
-
>
usize
{
self
.
max_element_segments
}
fn
min_elements
(
&
self
)
-
>
usize
{
self
.
min_elements
}
fn
max_elements
(
&
self
)
-
>
usize
{
self
.
max_elements
}
fn
min_data_segments
(
&
self
)
-
>
usize
{
self
.
min_data_segments
}
fn
max_data_segments
(
&
self
)
-
>
usize
{
self
.
max_data_segments
}
fn
max_instructions
(
&
self
)
-
>
usize
{
self
.
max_instructions
}
fn
min_memories
(
&
self
)
-
>
u32
{
self
.
min_memories
}
fn
max_memories
(
&
self
)
-
>
usize
{
self
.
max_memories
}
fn
min_tables
(
&
self
)
-
>
u32
{
self
.
min_tables
}
fn
max_tables
(
&
self
)
-
>
usize
{
self
.
max_tables
}
fn
max_memory_pages
(
&
self
is_64
:
bool
)
-
>
u64
{
if
is_64
{
self
.
max_memory_pages
.
min
(
1
<
<
48
)
}
else
{
self
.
max_memory_pages
.
min
(
1
<
<
16
)
}
}
fn
memory_max_size_required
(
&
self
)
-
>
bool
{
self
.
memory_max_size_required
}
fn
max_instances
(
&
self
)
-
>
usize
{
self
.
max_instances
}
fn
max_modules
(
&
self
)
-
>
usize
{
self
.
max_modules
}
fn
memory_offset_choices
(
&
self
)
-
>
(
u32
u32
u32
)
{
self
.
memory_offset_choices
}
fn
min_uleb_size
(
&
self
)
-
>
u8
{
self
.
min_uleb_size
}
fn
bulk_memory_enabled
(
&
self
)
-
>
bool
{
self
.
bulk_memory_enabled
}
fn
reference_types_enabled
(
&
self
)
-
>
bool
{
self
.
reference_types_enabled
}
fn
simd_enabled
(
&
self
)
-
>
bool
{
self
.
simd_enabled
}
fn
relaxed_simd_enabled
(
&
self
)
-
>
bool
{
self
.
relaxed_simd_enabled
}
fn
exceptions_enabled
(
&
self
)
-
>
bool
{
self
.
exceptions_enabled
}
fn
multi_value_enabled
(
&
self
)
-
>
bool
{
self
.
multi_value_enabled
}
fn
saturating_float_to_int_enabled
(
&
self
)
-
>
bool
{
self
.
saturating_float_to_int_enabled
}
fn
sign_extension_ops_enabled
(
&
self
)
-
>
bool
{
self
.
sign_extension_enabled
}
fn
allow_start_export
(
&
self
)
-
>
bool
{
self
.
allow_start_export
}
fn
max_aliases
(
&
self
)
-
>
usize
{
self
.
max_aliases
}
fn
max_nesting_depth
(
&
self
)
-
>
usize
{
self
.
max_nesting_depth
}
fn
max_type_size
(
&
self
)
-
>
u32
{
self
.
max_type_size
}
fn
memory64_enabled
(
&
self
)
-
>
bool
{
self
.
memory64_enabled
}
fn
canonicalize_nans
(
&
self
)
-
>
bool
{
self
.
canonicalize_nans
}
fn
threads_enabled
(
&
self
)
-
>
bool
{
self
.
threads_enabled
}
fn
allowed_instructions
(
&
self
)
-
>
InstructionKinds
{
self
.
allowed_instructions
}
fn
max_table_elements
(
&
self
)
-
>
u32
{
self
.
max_table_elements
}
fn
table_max_size_required
(
&
self
)
-
>
bool
{
self
.
table_max_size_required
}
fn
disallow_traps
(
&
self
)
-
>
bool
{
self
.
disallow_traps
}
}
