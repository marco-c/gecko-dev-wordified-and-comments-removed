use
ffi
;
use
std
:
:
str
;
use
util
:
:
opt_bytes
;
#
[
derive
(
PartialEq
Eq
Clone
Debug
Copy
)
]
pub
enum
DeviceState
{
Disabled
Unplugged
Enabled
}
bitflags
!
{
/
/
/
Architecture
specific
sample
type
.
pub
struct
DeviceFormat
:
ffi
:
:
cubeb_device_fmt
{
const
S16LE
=
ffi
:
:
CUBEB_DEVICE_FMT_S16LE
;
const
S16BE
=
ffi
:
:
CUBEB_DEVICE_FMT_S16BE
;
const
F32LE
=
ffi
:
:
CUBEB_DEVICE_FMT_F32LE
;
const
F32BE
=
ffi
:
:
CUBEB_DEVICE_FMT_F32BE
;
}
}
bitflags
!
{
/
/
/
Channel
type
for
a
cubeb_stream
.
Depending
on
the
backend
and
platform
/
/
/
used
this
can
control
inter
-
stream
interruption
ducking
and
volume
/
/
/
control
.
pub
struct
DevicePref
:
ffi
:
:
cubeb_device_pref
{
const
NONE
=
ffi
:
:
CUBEB_DEVICE_PREF_NONE
;
const
MULTIMEDIA
=
ffi
:
:
CUBEB_DEVICE_PREF_MULTIMEDIA
;
const
VOICE
=
ffi
:
:
CUBEB_DEVICE_PREF_VOICE
;
const
NOTIFICATION
=
ffi
:
:
CUBEB_DEVICE_PREF_NOTIFICATION
;
const
ALL
=
ffi
:
:
CUBEB_DEVICE_PREF_ALL
;
}
}
bitflags
!
{
/
/
/
Whether
a
particular
device
is
an
input
device
(
e
.
g
.
a
microphone
)
or
an
/
/
/
output
device
(
e
.
g
.
headphones
)
.
pub
struct
DeviceType
:
ffi
:
:
cubeb_device_type
{
const
UNKNOWN
=
ffi
:
:
CUBEB_DEVICE_TYPE_UNKNOWN
as
_
;
const
INPUT
=
ffi
:
:
CUBEB_DEVICE_TYPE_INPUT
as
_
;
const
OUTPUT
=
ffi
:
:
CUBEB_DEVICE_TYPE_OUTPUT
as
_
;
}
}
pub
type
DeviceId
=
ffi
:
:
cubeb_devid
;
ffi_type_heap
!
{
/
/
/
Audio
device
description
type
CType
=
ffi
:
:
cubeb_device
;
#
[
derive
(
Debug
)
]
pub
struct
Device
;
pub
struct
DeviceRef
;
}
impl
DeviceRef
{
fn
get_ref
(
&
self
)
-
>
&
ffi
:
:
cubeb_device
{
unsafe
{
&
*
self
.
as_ptr
(
)
}
}
pub
fn
output_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
output_name_bytes
(
)
.
map
(
|
b
|
str
:
:
from_utf8
(
b
)
.
unwrap
(
)
)
}
pub
fn
output_name_bytes
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
unsafe
{
opt_bytes
(
self
.
get_ref
(
)
.
output_name
)
}
}
pub
fn
input_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
input_name_bytes
(
)
.
map
(
|
b
|
str
:
:
from_utf8
(
b
)
.
unwrap
(
)
)
}
pub
fn
input_name_bytes
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
unsafe
{
opt_bytes
(
self
.
get_ref
(
)
.
input_name
)
}
}
}
ffi_type_stack
!
{
/
/
/
This
structure
holds
the
characteristics
of
an
input
or
output
/
/
/
audio
device
.
It
is
obtained
using
enumerate_devices
which
/
/
/
returns
these
structures
via
device_collection
and
must
be
/
/
/
destroyed
via
device_collection_destroy
.
type
CType
=
ffi
:
:
cubeb_device_info
;
pub
struct
DeviceInfo
;
pub
struct
DeviceInfoRef
;
}
impl
DeviceInfoRef
{
fn
get_ref
(
&
self
)
-
>
&
ffi
:
:
cubeb_device_info
{
unsafe
{
&
*
self
.
as_ptr
(
)
}
}
pub
fn
devid
(
&
self
)
-
>
DeviceId
{
self
.
get_ref
(
)
.
devid
}
pub
fn
device_id
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
device_id_bytes
(
)
.
map
(
|
b
|
str
:
:
from_utf8
(
b
)
.
unwrap
(
)
)
}
pub
fn
device_id_bytes
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
unsafe
{
opt_bytes
(
self
.
get_ref
(
)
.
device_id
)
}
}
pub
fn
friendly_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
friendly_name_bytes
(
)
.
map
(
|
b
|
str
:
:
from_utf8
(
b
)
.
unwrap
(
)
)
}
pub
fn
friendly_name_bytes
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
unsafe
{
opt_bytes
(
self
.
get_ref
(
)
.
friendly_name
)
}
}
pub
fn
group_id
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
group_id_bytes
(
)
.
map
(
|
b
|
str
:
:
from_utf8
(
b
)
.
unwrap
(
)
)
}
pub
fn
group_id_bytes
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
unsafe
{
opt_bytes
(
self
.
get_ref
(
)
.
group_id
)
}
}
pub
fn
vendor_name
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
vendor_name_bytes
(
)
.
map
(
|
b
|
str
:
:
from_utf8
(
b
)
.
unwrap
(
)
)
}
pub
fn
vendor_name_bytes
(
&
self
)
-
>
Option
<
&
[
u8
]
>
{
unsafe
{
opt_bytes
(
self
.
get_ref
(
)
.
vendor_name
)
}
}
pub
fn
device_type
(
&
self
)
-
>
DeviceType
{
DeviceType
:
:
from_bits_truncate
(
self
.
get_ref
(
)
.
device_type
)
}
pub
fn
state
(
&
self
)
-
>
DeviceState
{
let
state
=
self
.
get_ref
(
)
.
state
;
macro_rules
!
check
(
(
(
raw
:
ident
=
>
real
:
ident
)
*
)
=
>
(
(
if
state
=
=
ffi
:
:
raw
{
DeviceState
:
:
real
}
)
else
*
else
{
panic
!
(
"
unknown
device
state
:
{
}
"
state
)
}
)
)
;
check
!
(
CUBEB_DEVICE_STATE_DISABLED
=
>
Disabled
CUBEB_DEVICE_STATE_UNPLUGGED
=
>
Unplugged
CUBEB_DEVICE_STATE_ENABLED
=
>
Enabled
)
}
pub
fn
preferred
(
&
self
)
-
>
DevicePref
{
DevicePref
:
:
from_bits
(
self
.
get_ref
(
)
.
preferred
)
.
unwrap
(
)
}
pub
fn
format
(
&
self
)
-
>
DeviceFormat
{
DeviceFormat
:
:
from_bits
(
self
.
get_ref
(
)
.
format
)
.
unwrap
(
)
}
pub
fn
default_format
(
&
self
)
-
>
DeviceFormat
{
DeviceFormat
:
:
from_bits
(
self
.
get_ref
(
)
.
default_format
)
.
unwrap
(
)
}
pub
fn
max_channels
(
&
self
)
-
>
u32
{
self
.
get_ref
(
)
.
max_channels
}
pub
fn
default_rate
(
&
self
)
-
>
u32
{
self
.
get_ref
(
)
.
default_rate
}
pub
fn
max_rate
(
&
self
)
-
>
u32
{
self
.
get_ref
(
)
.
max_rate
}
pub
fn
min_rate
(
&
self
)
-
>
u32
{
self
.
get_ref
(
)
.
min_rate
}
pub
fn
latency_lo
(
&
self
)
-
>
u32
{
self
.
get_ref
(
)
.
latency_lo
}
pub
fn
latency_hi
(
&
self
)
-
>
u32
{
self
.
get_ref
(
)
.
latency_hi
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
ffi
:
:
cubeb_device
;
use
Device
;
#
[
test
]
fn
device_device_ref_same_ptr
(
)
{
let
ptr
:
*
mut
cubeb_device
=
0xDEAD_BEEF
as
*
mut
_
;
let
device
=
unsafe
{
Device
:
:
from_ptr
(
ptr
)
}
;
assert_eq
!
(
device
.
as_ptr
(
)
ptr
)
;
assert_eq
!
(
device
.
as_ptr
(
)
device
.
as_ref
(
)
.
as_ptr
(
)
)
;
}
}
