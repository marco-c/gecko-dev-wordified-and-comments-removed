use
crate
:
:
{
access
:
:
BitAccess
devel
as
dvl
domain
:
:
{
BitDomain
BitDomainMut
Domain
DomainMut
}
index
:
:
{
BitIdx
BitMask
BitRegister
}
mem
:
:
BitMemory
order
:
:
{
BitOrder
Lsb0
}
pointer
:
:
BitPtr
store
:
:
BitStore
}
;
use
core
:
:
{
cmp
marker
:
:
PhantomData
ops
:
:
RangeBounds
ptr
slice
}
;
use
funty
:
:
IsInteger
;
use
radium
:
:
Radium
;
use
tap
:
:
pipe
:
:
Pipe
;
#
[
repr
(
transparent
)
]
pub
struct
BitSlice
<
O
=
Lsb0
T
=
usize
>
where
O
:
BitOrder
T
:
BitStore
{
_ord
:
PhantomData
<
O
>
_typ
:
PhantomData
<
[
T
]
>
_mem
:
[
(
)
]
}
impl
<
O
T
>
BitSlice
<
O
T
>
where
O
:
BitOrder
T
:
BitStore
+
BitRegister
{
#
[
inline
]
pub
fn
from_element
(
elem
:
&
T
)
-
>
&
Self
{
unsafe
{
BitPtr
:
:
new_unchecked
(
elem
BitIdx
:
:
ZERO
T
:
:
Mem
:
:
BITS
as
usize
)
}
.
to_bitslice_ref
(
)
}
#
[
inline
]
pub
fn
from_element_mut
(
elem
:
&
mut
T
)
-
>
&
mut
Self
{
unsafe
{
BitPtr
:
:
new_unchecked
(
elem
BitIdx
:
:
ZERO
T
:
:
Mem
:
:
BITS
as
usize
)
}
.
to_bitslice_mut
(
)
}
#
[
inline
]
pub
fn
from_slice
(
slice
:
&
[
T
]
)
-
>
Option
<
&
Self
>
{
let
elts
=
slice
.
len
(
)
;
if
elts
>
=
Self
:
:
MAX_ELTS
{
return
None
;
}
Some
(
unsafe
{
Self
:
:
from_slice_unchecked
(
slice
)
}
)
}
#
[
inline
]
pub
unsafe
fn
from_slice_unchecked
(
slice
:
&
[
T
]
)
-
>
&
Self
{
let
bits
=
cmp
:
:
min
(
slice
.
len
(
)
*
T
:
:
Mem
:
:
BITS
as
usize
Self
:
:
MAX_BITS
)
;
BitPtr
:
:
new_unchecked
(
slice
.
as_ptr
(
)
BitIdx
:
:
ZERO
bits
)
.
to_bitslice_ref
(
)
}
#
[
inline
]
pub
fn
from_slice_mut
(
slice
:
&
mut
[
T
]
)
-
>
Option
<
&
mut
Self
>
{
let
elts
=
slice
.
len
(
)
;
if
elts
>
=
Self
:
:
MAX_ELTS
{
return
None
;
}
Some
(
unsafe
{
Self
:
:
from_slice_unchecked_mut
(
slice
)
}
)
}
#
[
inline
]
pub
unsafe
fn
from_slice_unchecked_mut
(
slice
:
&
mut
[
T
]
)
-
>
&
mut
Self
{
let
bits
=
cmp
:
:
min
(
slice
.
len
(
)
*
T
:
:
Mem
:
:
BITS
as
usize
Self
:
:
MAX_BITS
)
;
BitPtr
:
:
new_unchecked
(
slice
.
as_ptr
(
)
BitIdx
:
:
ZERO
bits
)
.
to_bitslice_mut
(
)
}
}
impl
<
O
T
>
BitSlice
<
O
T
>
where
O
:
BitOrder
T
:
BitStore
{
#
[
inline
]
pub
fn
empty
<
'
a
>
(
)
-
>
&
'
a
Self
{
BitPtr
:
:
EMPTY
.
to_bitslice_ref
(
)
}
#
[
inline
]
pub
fn
empty_mut
<
'
a
>
(
)
-
>
&
'
a
mut
Self
{
BitPtr
:
:
EMPTY
.
to_bitslice_mut
(
)
}
#
[
inline
]
pub
fn
set
(
&
mut
self
index
:
usize
value
:
bool
)
{
let
len
=
self
.
len
(
)
;
assert
!
(
index
<
len
"
Index
out
of
range
:
{
}
>
=
{
}
"
index
len
)
;
unsafe
{
self
.
set_unchecked
(
index
value
)
;
}
}
#
[
inline
]
pub
unsafe
fn
set_unchecked
(
&
mut
self
index
:
usize
value
:
bool
)
{
self
.
bitptr
(
)
.
write
:
:
<
O
>
(
index
value
)
;
}
#
[
inline
]
pub
fn
all
(
&
self
)
-
>
bool
{
match
self
.
domain
(
)
{
Domain
:
:
Enclave
{
head
elem
tail
}
=
>
{
!
O
:
:
mask
(
head
tail
)
|
elem
.
load_value
(
)
=
=
BitMask
:
:
ALL
}
Domain
:
:
Region
{
head
body
tail
}
=
>
{
head
.
map_or
(
true
|
(
head
elem
)
|
{
!
O
:
:
mask
(
head
None
)
|
elem
.
load_value
(
)
=
=
BitMask
:
:
ALL
}
)
&
&
body
.
iter
(
)
.
copied
(
)
.
all
(
|
e
|
e
=
=
T
:
:
Mem
:
:
ALL
)
&
&
tail
.
map_or
(
true
|
(
elem
tail
)
|
{
!
O
:
:
mask
(
None
tail
)
|
elem
.
load_value
(
)
=
=
BitMask
:
:
ALL
}
)
}
}
}
#
[
inline
]
pub
fn
any
(
&
self
)
-
>
bool
{
match
self
.
domain
(
)
{
Domain
:
:
Enclave
{
head
elem
tail
}
=
>
{
O
:
:
mask
(
head
tail
)
&
elem
.
load_value
(
)
!
=
BitMask
:
:
ZERO
}
Domain
:
:
Region
{
head
body
tail
}
=
>
{
head
.
map_or
(
false
|
(
head
elem
)
|
{
O
:
:
mask
(
head
None
)
&
elem
.
load_value
(
)
!
=
BitMask
:
:
ZERO
}
)
|
|
body
.
iter
(
)
.
copied
(
)
.
any
(
|
e
|
e
!
=
T
:
:
Mem
:
:
ZERO
)
|
|
tail
.
map_or
(
false
|
(
elem
tail
)
|
{
O
:
:
mask
(
None
tail
)
&
elem
.
load_value
(
)
!
=
BitMask
:
:
ZERO
}
)
}
}
}
#
[
inline
]
pub
fn
not_all
(
&
self
)
-
>
bool
{
!
self
.
all
(
)
}
#
[
inline
]
pub
fn
not_any
(
&
self
)
-
>
bool
{
!
self
.
any
(
)
}
#
[
inline
]
pub
fn
some
(
&
self
)
-
>
bool
{
self
.
any
(
)
&
&
self
.
not_all
(
)
}
#
[
inline
]
pub
fn
count_ones
(
&
self
)
-
>
usize
{
match
self
.
domain
(
)
{
Domain
:
:
Enclave
{
head
elem
tail
}
=
>
(
O
:
:
mask
(
head
tail
)
&
elem
.
load_value
(
)
)
.
value
(
)
.
count_ones
(
)
as
usize
Domain
:
:
Region
{
head
body
tail
}
=
>
{
head
.
map_or
(
0
|
(
head
elem
)
|
{
(
O
:
:
mask
(
head
None
)
&
elem
.
load_value
(
)
)
.
value
(
)
.
count_ones
(
)
as
usize
}
)
+
body
.
iter
(
)
.
copied
(
)
.
map
(
|
e
|
e
.
count_ones
(
)
as
usize
)
.
sum
:
:
<
usize
>
(
)
+
tail
.
map_or
(
0
|
(
elem
tail
)
|
{
(
O
:
:
mask
(
None
tail
)
&
elem
.
load_value
(
)
)
.
value
(
)
.
count_ones
(
)
as
usize
}
)
}
}
}
#
[
inline
]
pub
fn
count_zeros
(
&
self
)
-
>
usize
{
match
self
.
domain
(
)
{
Domain
:
:
Enclave
{
head
elem
tail
}
=
>
(
!
O
:
:
mask
(
head
tail
)
|
elem
.
load_value
(
)
)
.
value
(
)
.
count_zeros
(
)
as
usize
Domain
:
:
Region
{
head
body
tail
}
=
>
{
head
.
map_or
(
0
|
(
head
elem
)
|
{
(
!
O
:
:
mask
(
head
None
)
|
elem
.
load_value
(
)
)
.
value
(
)
.
count_zeros
(
)
as
usize
}
)
+
body
.
iter
(
)
.
copied
(
)
.
map
(
|
e
|
e
.
count_zeros
(
)
as
usize
)
.
sum
:
:
<
usize
>
(
)
+
tail
.
map_or
(
0
|
(
elem
tail
)
|
{
(
!
O
:
:
mask
(
None
tail
)
|
elem
.
load_value
(
)
)
.
value
(
)
.
count_zeros
(
)
as
usize
}
)
}
}
}
#
[
inline
]
pub
fn
set_all
(
&
mut
self
value
:
bool
)
{
let
setter
=
<
<
T
:
:
Alias
as
BitStore
>
:
:
Access
>
:
:
get_writers
(
value
)
;
match
self
.
domain_mut
(
)
{
DomainMut
:
:
Enclave
{
head
elem
tail
}
=
>
{
setter
(
dvl
:
:
accessor
(
elem
)
O
:
:
mask
(
head
tail
)
.
pipe
(
dvl
:
:
alias_mask
:
:
<
T
>
)
)
;
}
DomainMut
:
:
Region
{
head
body
tail
}
=
>
{
if
let
Some
(
(
head
elem
)
)
=
head
{
setter
(
dvl
:
:
accessor
(
elem
)
O
:
:
mask
(
head
None
)
.
pipe
(
dvl
:
:
alias_mask
:
:
<
T
>
)
)
;
}
unsafe
{
ptr
:
:
write_bytes
(
body
.
as_mut_ptr
(
)
[
0
!
0
]
[
value
as
usize
]
body
.
len
(
)
)
;
}
if
let
Some
(
(
elem
tail
)
)
=
tail
{
setter
(
dvl
:
:
accessor
(
elem
)
O
:
:
mask
(
None
tail
)
.
pipe
(
dvl
:
:
alias_mask
:
:
<
T
>
)
)
;
}
}
}
}
#
[
inline
]
pub
fn
for_each
<
F
>
(
&
mut
self
mut
func
:
F
)
where
F
:
FnMut
(
usize
bool
)
-
>
bool
{
for
idx
in
0
.
.
self
.
len
(
)
{
unsafe
{
let
tmp
=
*
self
.
get_unchecked
(
idx
)
;
let
new
=
func
(
idx
tmp
)
;
self
.
set_unchecked
(
idx
new
)
;
}
}
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
T
]
{
let
bitptr
=
self
.
bitptr
(
)
;
let
(
base
elts
)
=
(
bitptr
.
pointer
(
)
.
to_const
(
)
bitptr
.
elements
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts
(
base
elts
)
}
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_raw_slice
(
&
self
)
-
>
&
[
T
:
:
Mem
]
{
self
.
domain
(
)
.
region
(
)
.
map_or
(
&
[
]
|
(
_
b
_
)
|
b
)
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_raw_slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
:
:
Mem
]
{
self
.
domain_mut
(
)
.
region
(
)
.
map_or
(
&
mut
[
]
|
(
_
b
_
)
|
b
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
bit_domain
(
&
self
)
-
>
BitDomain
<
O
T
>
{
BitDomain
:
:
new
(
self
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
bit_domain_mut
(
&
mut
self
)
-
>
BitDomainMut
<
O
T
>
{
BitDomainMut
:
:
new
(
self
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
domain
(
&
self
)
-
>
Domain
<
T
>
{
Domain
:
:
new
(
self
)
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
domain_mut
(
&
mut
self
)
-
>
DomainMut
<
T
>
{
DomainMut
:
:
new
(
self
)
}
#
[
inline
]
pub
unsafe
fn
split_at_unchecked
(
&
self
mid
:
usize
)
-
>
(
&
Self
&
Self
)
{
(
self
.
get_unchecked
(
.
.
mid
)
self
.
get_unchecked
(
mid
.
.
)
)
}
#
[
inline
]
#
[
allow
(
clippy
:
:
type_complexity
)
]
pub
unsafe
fn
split_at_unchecked_mut
(
&
mut
self
mid
:
usize
)
-
>
(
&
mut
BitSlice
<
O
T
:
:
Alias
>
&
mut
BitSlice
<
O
T
:
:
Alias
>
)
{
let
bp
=
self
.
alias_mut
(
)
.
bitptr
(
)
;
(
bp
.
to_bitslice_mut
(
)
.
get_unchecked_mut
(
.
.
mid
)
bp
.
to_bitslice_mut
(
)
.
get_unchecked_mut
(
mid
.
.
)
)
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
split_at_unchecked_mut_noalias
(
&
mut
self
mid
:
usize
)
-
>
(
&
mut
Self
&
mut
Self
)
{
let
(
head
tail
)
=
self
.
split_at_unchecked_mut
(
mid
)
;
(
Self
:
:
unalias_mut
(
head
)
Self
:
:
unalias_mut
(
tail
)
)
}
#
[
inline
]
pub
unsafe
fn
swap_unchecked
(
&
mut
self
a
:
usize
b
:
usize
)
{
let
bit_a
=
*
self
.
get_unchecked
(
a
)
;
let
bit_b
=
*
self
.
get_unchecked
(
b
)
;
self
.
set_unchecked
(
a
bit_b
)
;
self
.
set_unchecked
(
b
bit_a
)
;
}
#
[
inline
]
pub
unsafe
fn
copy_unchecked
(
&
mut
self
from
:
usize
to
:
usize
)
{
let
tmp
=
*
self
.
get_unchecked
(
from
)
;
self
.
set_unchecked
(
to
tmp
)
;
}
#
[
inline
]
pub
unsafe
fn
copy_within_unchecked
<
R
>
(
&
mut
self
src
:
R
dest
:
usize
)
where
R
:
RangeBounds
<
usize
>
{
let
len
=
self
.
len
(
)
;
let
rev
=
src
.
contains
(
&
dest
)
;
let
source
=
dvl
:
:
normalize_range
(
src
len
)
;
let
iter
=
source
.
zip
(
dest
.
.
len
)
;
if
rev
{
for
(
from
to
)
in
iter
.
rev
(
)
{
self
.
copy_unchecked
(
from
to
)
;
}
}
else
{
for
(
from
to
)
in
iter
{
self
.
copy_unchecked
(
from
to
)
;
}
}
}
pub
fn
offset_from
(
&
self
other
:
&
Self
)
-
>
isize
{
let
(
elts
bits
)
=
unsafe
{
self
.
bitptr
(
)
.
ptr_diff
(
other
.
bitptr
(
)
)
}
;
elts
.
saturating_mul
(
T
:
:
Mem
:
:
BITS
as
isize
)
.
saturating_add
(
bits
as
isize
)
}
pub
fn
electrical_distance
(
&
self
other
:
&
Self
)
-
>
isize
{
let
this
=
self
.
bitptr
(
)
;
let
that
=
other
.
bitptr
(
)
;
let
(
elts
bits
)
=
unsafe
{
let
this
=
BitPtr
:
:
new_unchecked
(
this
.
pointer
(
)
BitIdx
:
:
new_unchecked
(
this
.
head
(
)
.
position
:
:
<
O
>
(
)
.
value
(
)
)
1
)
;
let
that
=
BitPtr
:
:
new_unchecked
(
that
.
pointer
(
)
BitIdx
:
:
new_unchecked
(
that
.
head
(
)
.
position
:
:
<
O
>
(
)
.
value
(
)
)
1
)
;
this
.
ptr_diff
(
that
)
}
;
elts
.
saturating_mul
(
T
:
:
Mem
:
:
BITS
as
isize
)
.
saturating_add
(
bits
as
isize
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
(
crate
)
fn
alias
(
&
self
)
-
>
&
BitSlice
<
O
T
:
:
Alias
>
{
unsafe
{
&
*
(
self
.
as_ptr
(
)
as
*
const
BitSlice
<
O
T
:
:
Alias
>
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
(
crate
)
fn
alias_mut
(
&
mut
self
)
-
>
&
mut
BitSlice
<
O
T
:
:
Alias
>
{
unsafe
{
&
mut
*
(
self
as
*
mut
Self
as
*
mut
BitSlice
<
O
T
:
:
Alias
>
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
(
crate
)
unsafe
fn
unalias_mut
(
this
:
&
mut
BitSlice
<
O
T
:
:
Alias
>
)
-
>
&
mut
Self
{
&
mut
*
(
this
as
*
mut
BitSlice
<
O
T
:
:
Alias
>
as
*
mut
Self
)
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
(
crate
)
fn
bitptr
(
&
self
)
-
>
BitPtr
<
T
>
{
BitPtr
:
:
from_bitslice_ptr
(
self
.
as_ptr
(
)
)
}
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
(
crate
)
unsafe
fn
from_aliased_slice_unchecked
(
slice
:
&
[
T
:
:
Alias
]
)
-
>
&
BitSlice
<
O
T
:
:
Alias
>
{
BitPtr
:
:
new_unchecked
(
slice
.
as_ptr
(
)
BitIdx
:
:
ZERO
slice
.
len
(
)
*
T
:
:
Mem
:
:
BITS
as
usize
)
.
to_bitslice_ref
(
)
}
}
impl
<
O
T
>
BitSlice
<
O
T
>
where
O
:
BitOrder
T
:
BitStore
+
Radium
<
Item
=
<
T
as
BitStore
>
:
:
Mem
>
{
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
split_at_aliased_mut
(
&
mut
self
mid
:
usize
)
-
>
(
&
mut
Self
&
mut
Self
)
{
let
(
head
tail
)
=
self
.
split_at_mut
(
mid
)
;
unsafe
{
(
Self
:
:
unalias_mut
(
head
)
Self
:
:
unalias_mut
(
tail
)
)
}
}
}
impl
<
O
T
>
BitSlice
<
O
T
>
where
O
:
BitOrder
T
:
BitStore
{
pub
const
MAX_BITS
:
usize
=
BitPtr
:
:
<
T
>
:
:
REGION_MAX_BITS
;
pub
const
MAX_ELTS
:
usize
=
BitPtr
:
:
<
T
>
:
:
REGION_MAX_ELTS
;
}
#
[
inline
]
pub
unsafe
fn
bits_from_raw_parts
<
'
a
O
T
>
(
addr
:
*
const
T
head
:
u8
bits
:
usize
)
-
>
Option
<
&
'
a
BitSlice
<
O
T
>
>
where
O
:
BitOrder
T
:
'
a
+
BitStore
+
BitMemory
{
let
head
=
crate
:
:
index
:
:
BitIdx
:
:
new
(
head
)
?
;
BitPtr
:
:
new
(
addr
head
bits
)
.
map
(
BitPtr
:
:
to_bitslice_ref
)
}
#
[
inline
]
pub
unsafe
fn
bits_from_raw_parts_mut
<
'
a
O
T
>
(
addr
:
*
mut
T
head
:
u8
bits
:
usize
)
-
>
Option
<
&
'
a
mut
BitSlice
<
O
T
>
>
where
O
:
BitOrder
T
:
'
a
+
BitStore
+
BitMemory
{
let
head
=
crate
:
:
index
:
:
BitIdx
:
:
new
(
head
)
?
;
BitPtr
:
:
new
(
addr
head
bits
)
.
map
(
BitPtr
:
:
to_bitslice_mut
)
}
mod
api
;
mod
iter
;
mod
ops
;
mod
proxy
;
mod
traits
;
pub
use
self
:
:
{
api
:
:
{
from_mut
from_raw_parts
from_raw_parts_mut
from_ref
BitSliceIndex
}
iter
:
:
{
Chunks
ChunksExact
ChunksExactMut
ChunksMut
Iter
IterMut
RChunks
RChunksExact
RChunksExactMut
RChunksMut
RSplit
RSplitMut
RSplitN
RSplitNMut
Split
SplitMut
SplitN
SplitNMut
Windows
}
proxy
:
:
BitMut
}
;
#
[
cfg
(
test
)
]
mod
tests
;
