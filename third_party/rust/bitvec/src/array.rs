use
crate
:
:
{
order
:
:
{
BitOrder
Lsb0
}
slice
:
:
BitSlice
view
:
:
BitView
}
;
use
core
:
:
{
marker
:
:
PhantomData
mem
:
:
MaybeUninit
slice
}
;
#
[
repr
(
transparent
)
]
#
[
derive
(
Clone
Copy
)
]
pub
struct
BitArray
<
O
=
Lsb0
V
=
usize
>
where
O
:
BitOrder
V
:
BitView
+
Sized
{
_ord
:
PhantomData
<
O
>
data
:
V
}
impl
<
O
V
>
BitArray
<
O
V
>
where
O
:
BitOrder
V
:
BitView
+
Sized
{
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
zeroed
(
)
-
>
Self
{
Self
{
_ord
:
PhantomData
data
:
unsafe
{
MaybeUninit
:
:
zeroed
(
)
.
assume_init
(
)
}
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
new
(
data
:
V
)
-
>
Self
{
Self
{
_ord
:
PhantomData
data
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
unwrap
(
self
)
-
>
V
{
self
.
data
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_bitslice
(
&
self
)
-
>
&
BitSlice
<
O
V
:
:
Store
>
{
self
.
data
.
view_bits
:
:
<
O
>
(
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_mut_bitslice
(
&
mut
self
)
-
>
&
mut
BitSlice
<
O
V
:
:
Store
>
{
self
.
data
.
view_bits_mut
:
:
<
O
>
(
)
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
V
:
:
Store
]
{
unsafe
{
slice
:
:
from_raw_parts
(
&
self
.
data
as
*
const
V
as
*
const
V
:
:
Store
V
:
:
const_elts
(
)
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
V
:
:
Store
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
&
mut
self
.
data
as
*
mut
V
as
*
mut
V
:
:
Store
V
:
:
const_elts
(
)
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_raw_slice
(
&
self
)
-
>
&
[
V
:
:
Mem
]
{
unsafe
{
slice
:
:
from_raw_parts
(
&
self
.
data
as
*
const
V
as
*
const
V
:
:
Mem
V
:
:
const_elts
(
)
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_raw_mut_slice
(
&
mut
self
)
-
>
&
mut
[
V
:
:
Mem
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
&
mut
self
.
data
as
*
mut
V
as
*
mut
V
:
:
Mem
V
:
:
const_elts
(
)
)
}
}
}
mod
ops
;
mod
traits
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
prelude
:
:
*
;
#
[
test
]
fn
create_arrays
(
)
{
macro_rules
!
make
{
(
(
elts
:
literal
)
+
(
)
?
)
=
>
{
(
let
_
=
BitArray
:
:
<
LocalBits
[
u8
;
elts
]
>
:
:
zeroed
(
)
;
let
_
=
BitArray
:
:
<
LocalBits
[
u16
;
elts
]
>
:
:
zeroed
(
)
;
let
_
=
BitArray
:
:
<
LocalBits
[
u32
;
elts
]
>
:
:
zeroed
(
)
;
let
_
=
BitArray
:
:
<
LocalBits
[
usize
;
elts
]
>
:
:
zeroed
(
)
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
let
_
=
BitArray
:
:
<
LocalBits
[
u64
;
elts
]
>
:
:
zeroed
(
)
;
}
)
+
}
;
}
make
!
(
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
)
;
}
#
[
test
]
fn
wrap_unwrap
(
)
{
let
data
:
[
u8
;
15
]
=
*
b
"
Saluton
mondo
!
"
;
let
bits
=
BitArray
:
:
<
LocalBits
_
>
:
:
new
(
data
)
;
assert_eq
!
(
bits
.
unwrap
(
)
data
)
;
}
}
