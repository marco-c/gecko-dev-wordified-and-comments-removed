use
crate
:
:
{
bits
:
:
{
BitIdx
Bits
}
cursor
:
:
Cursor
domain
:
:
*
slice
:
:
BitSlice
}
;
use
core
:
:
{
convert
:
:
{
AsMut
AsRef
From
}
default
:
:
Default
fmt
:
:
{
self
Debug
Formatter
}
marker
:
:
PhantomData
mem
ptr
:
:
NonNull
slice
}
;
const
PTR_BITS
:
usize
=
mem
:
:
size_of
:
:
<
*
const
u8
>
(
)
*
8
;
const
USZ_BITS
:
usize
=
mem
:
:
size_of
:
:
<
usize
>
(
)
*
8
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Eq
Hash
PartialEq
PartialOrd
Ord
)
]
pub
struct
BitPtr
<
T
>
where
T
:
Bits
{
_ty
:
PhantomData
<
T
>
ptr
:
NonNull
<
u8
>
len
:
usize
}
impl
<
T
>
BitPtr
<
T
>
where
T
:
Bits
{
pub
const
PTR_DATA_BITS
:
usize
=
PTR_BITS
-
Self
:
:
PTR_HEAD_BITS
;
pub
const
PTR_DATA_MASK
:
usize
=
!
Self
:
:
PTR_HEAD_MASK
;
pub
const
PTR_HEAD_BITS
:
usize
=
T
:
:
BITS
as
usize
-
Self
:
:
LEN_HEAD_BITS
;
pub
const
PTR_HEAD_MASK
:
usize
=
T
:
:
MASK
as
usize
>
>
Self
:
:
LEN_HEAD_BITS
;
pub
const
LEN_HEAD_BITS
:
usize
=
0b0011
;
pub
const
LEN_HEAD_MASK
:
usize
=
0b0111
;
pub
const
LEN_TAIL_BITS
:
usize
=
T
:
:
BITS
as
usize
;
pub
const
LEN_TAIL_MASK
:
usize
=
(
T
:
:
MASK
as
usize
)
<
<
Self
:
:
LEN_HEAD_BITS
;
pub
const
LEN_DATA_BITS
:
usize
=
USZ_BITS
-
Self
:
:
LEN_INDX_BITS
;
pub
const
LEN_DATA_MASK
:
usize
=
!
Self
:
:
LEN_INDX_MASK
;
pub
const
LEN_INDX_BITS
:
usize
=
Self
:
:
LEN_TAIL_BITS
+
Self
:
:
LEN_HEAD_BITS
;
pub
const
LEN_INDX_MASK
:
usize
=
Self
:
:
LEN_TAIL_MASK
|
Self
:
:
LEN_HEAD_MASK
;
pub
const
MAX_ELTS
:
usize
=
1
<
<
Self
:
:
LEN_DATA_BITS
;
pub
const
MAX_BITS
:
usize
=
!
0
>
>
Self
:
:
LEN_HEAD_BITS
;
pub
fn
empty
(
)
-
>
Self
{
Self
{
_ty
:
PhantomData
ptr
:
NonNull
:
:
dangling
(
)
len
:
0
}
}
pub
fn
uninhabited
(
ptr
:
*
const
T
)
-
>
Self
{
assert
!
(
(
ptr
as
usize
)
.
trailing_zeros
(
)
as
usize
>
=
Self
:
:
PTR_HEAD_BITS
"
BitPtr
domain
pointers
must
be
well
aligned
"
)
;
Self
{
_ty
:
PhantomData
ptr
:
NonNull
:
:
new
(
ptr
as
*
mut
u8
)
.
unwrap_or_else
(
NonNull
:
:
dangling
)
len
:
0
}
}
pub
fn
new
<
Head
:
Into
<
BitIdx
>
Tail
:
Into
<
BitIdx
>
>
(
data
:
*
const
T
elts
:
usize
head
:
Head
tail
:
Tail
)
-
>
Self
{
assert
!
(
elts
<
=
isize
:
:
max_value
(
)
as
usize
"
elts
cannot
exceed
isize
:
:
max_value
(
)
"
)
;
let
(
head
tail
)
=
(
head
.
into
(
)
tail
.
into
(
)
)
;
if
data
.
is_null
(
)
|
|
elts
=
=
0
|
|
(
elts
=
=
1
&
&
head
=
=
tail
)
{
return
Self
:
:
uninhabited
(
data
)
;
}
assert
!
(
(
data
as
usize
)
.
trailing_zeros
(
)
as
usize
>
=
Self
:
:
PTR_HEAD_BITS
"
BitPtr
domain
pointers
must
be
well
aligned
"
)
;
assert
!
(
elts
<
Self
:
:
MAX_ELTS
"
BitPtr
domain
regions
must
have
at
most
{
}
elements
"
Self
:
:
MAX_ELTS
-
1
)
;
if
data
.
wrapping_add
(
elts
)
<
data
{
panic
!
(
"
BitPtr
slices
MUST
NOT
wrap
around
the
address
space
"
)
;
}
assert
!
(
head
.
is_valid
:
:
<
T
>
(
)
"
BitPtr
head
cursors
must
be
in
the
domain
0
.
.
{
}
"
T
:
:
SIZE
)
;
assert
!
(
tail
.
is_valid_tail
:
:
<
T
>
(
)
"
BitPtr
tail
cursors
must
be
in
the
domain
1
.
.
=
{
}
"
T
:
:
SIZE
)
;
if
elts
=
=
1
{
assert
!
(
tail
>
head
"
BitPtr
domains
with
one
element
must
have
the
tail
cursor
\
beyond
the
head
cursor
"
)
;
}
else
if
elts
=
=
Self
:
:
MAX_ELTS
-
1
{
assert
!
(
tail
.
is_valid
:
:
<
T
>
(
)
"
BitPtr
domains
with
maximum
elements
must
have
the
tail
\
cursor
in
1
.
.
{
}
"
T
:
:
SIZE
)
;
}
let
ptr_data
=
data
as
usize
&
Self
:
:
PTR_DATA_MASK
;
let
ptr_head
=
*
head
as
usize
>
>
Self
:
:
LEN_HEAD_BITS
;
let
len_elts
=
elts
<
<
Self
:
:
LEN_INDX_BITS
;
let
len_tail
=
(
(
*
tail
as
usize
)
<
<
Self
:
:
LEN_HEAD_BITS
)
&
Self
:
:
LEN_TAIL_MASK
;
let
len_head
=
*
head
as
usize
&
Self
:
:
LEN_HEAD_MASK
;
Self
{
_ty
:
PhantomData
ptr
:
unsafe
{
NonNull
:
:
new_unchecked
(
(
ptr_data
|
ptr_head
)
as
*
mut
u8
)
}
len
:
len_elts
|
len_tail
|
len_head
}
}
pub
fn
pointer
(
&
self
)
-
>
*
const
T
{
(
self
.
ptr
.
as_ptr
(
)
as
usize
&
Self
:
:
PTR_DATA_MASK
)
as
*
const
T
}
pub
fn
elements
(
&
self
)
-
>
usize
{
self
.
len
>
>
Self
:
:
LEN_INDX_BITS
}
pub
fn
head
(
&
self
)
-
>
BitIdx
{
(
(
(
(
self
.
ptr
.
as_ptr
(
)
as
usize
&
Self
:
:
PTR_HEAD_MASK
)
<
<
3
)
|
(
self
.
len
&
Self
:
:
LEN_HEAD_MASK
)
)
as
u8
)
.
into
(
)
}
pub
fn
tail
(
&
self
)
-
>
BitIdx
{
let
bits
=
(
self
.
len
&
Self
:
:
LEN_TAIL_MASK
)
>
>
Self
:
:
LEN_HEAD_BITS
;
if
bits
=
=
0
{
T
:
:
SIZE
}
else
{
bits
as
u8
}
.
into
(
)
}
pub
fn
raw_parts
(
&
self
)
-
>
(
*
const
T
usize
BitIdx
BitIdx
)
{
(
self
.
pointer
(
)
self
.
elements
(
)
self
.
head
(
)
self
.
tail
(
)
)
}
pub
(
crate
)
unsafe
fn
bare_parts
(
&
self
)
-
>
(
*
const
(
)
usize
)
{
(
self
.
ptr
.
as_ptr
(
)
as
*
const
(
)
self
.
len
)
}
pub
fn
region_data
(
&
self
)
-
>
(
usize
BitIdx
BitIdx
)
{
(
self
.
elements
(
)
self
.
head
(
)
self
.
tail
(
)
)
}
pub
fn
cursors
(
&
self
)
-
>
(
BitIdx
BitIdx
)
{
(
self
.
head
(
)
self
.
tail
(
)
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
>
>
Self
:
:
LEN_INDX_BITS
=
=
0
}
pub
fn
is_full
(
&
self
)
-
>
bool
{
!
self
.
is_empty
(
)
&
&
(
(
self
.
len
|
Self
:
:
LEN_HEAD_MASK
)
=
=
!
0
)
}
pub
fn
bits
(
&
self
)
-
>
usize
{
if
self
.
is_empty
(
)
{
return
0
;
}
let
(
_
elts
head
tail
)
=
self
.
raw_parts
(
)
;
if
elts
=
=
1
{
return
*
tail
as
usize
-
*
head
as
usize
;
}
(
(
elts
-
1
)
<
<
T
:
:
BITS
)
.
saturating_add
(
*
tail
as
usize
)
.
saturating_sub
(
*
head
as
usize
)
}
pub
fn
head_elt
(
&
self
)
-
>
Option
<
&
T
>
{
if
!
self
.
is_empty
(
)
&
&
*
self
.
head
(
)
>
0
{
return
Some
(
&
self
.
as_ref
(
)
[
0
]
)
;
}
None
}
pub
fn
body_elts
(
&
self
)
-
>
&
[
T
]
{
let
w
=
T
:
:
SIZE
;
let
(
_
e
h
t
)
=
self
.
raw_parts
(
)
;
match
(
e
*
h
*
t
)
{
(
0
_
_
)
=
>
&
[
]
(
1
0
t
)
if
t
=
=
w
=
>
&
self
.
as_ref
(
)
[
0
.
.
e
]
(
1
_
_
)
=
>
&
[
]
(
_
0
t
)
if
t
=
=
w
=
>
&
self
.
as_ref
(
)
[
0
.
.
e
]
(
_
0
_
)
=
>
&
self
.
as_ref
(
)
[
0
.
.
e
-
1
]
(
_
_
t
)
if
t
=
=
w
=
>
&
self
.
as_ref
(
)
[
1
.
.
e
]
(
_
_
_
)
=
>
&
self
.
as_ref
(
)
[
1
.
.
e
-
1
]
}
}
pub
fn
tail_elt
(
&
self
)
-
>
Option
<
&
T
>
{
if
!
self
.
is_empty
(
)
&
&
*
self
.
tail
(
)
<
T
:
:
SIZE
{
return
Some
(
&
self
.
as_ref
(
)
[
self
.
elements
(
)
-
1
]
)
;
}
None
}
pub
fn
as_slice
<
'
a
>
(
&
self
)
-
>
&
'
a
[
T
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
pointer
(
)
self
.
elements
(
)
)
}
}
pub
fn
as_mut_slice
<
'
a
>
(
&
self
)
-
>
&
'
a
mut
[
T
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
pointer
(
)
as
*
mut
T
self
.
elements
(
)
)
}
}
pub
fn
domain_kind
(
&
self
)
-
>
BitDomainKind
{
(
*
self
)
.
into
(
)
}
pub
fn
domain
(
&
self
)
-
>
BitDomain
<
T
>
{
(
*
self
)
.
into
(
)
}
pub
fn
domain_mut
(
&
self
)
-
>
BitDomainMut
<
T
>
{
(
*
self
)
.
into
(
)
}
pub
fn
set_head
<
Head
:
Into
<
BitIdx
>
>
(
&
mut
self
head
:
Head
)
{
if
self
.
is_empty
(
)
{
return
;
}
let
head
=
head
.
into
(
)
;
assert
!
(
head
.
is_valid
:
:
<
T
>
(
)
"
Head
indices
must
be
in
the
domain
0
.
.
{
}
"
T
:
:
SIZE
)
;
if
self
.
elements
(
)
=
=
1
{
assert
!
(
head
<
=
self
.
tail
(
)
"
Single
-
element
slices
must
have
head
below
tail
"
)
;
}
self
.
ptr
=
unsafe
{
let
ptr
=
self
.
ptr
.
as_ptr
(
)
as
usize
;
NonNull
:
:
new_unchecked
(
(
(
ptr
&
!
Self
:
:
PTR_HEAD_MASK
)
|
(
(
*
head
as
usize
>
>
Self
:
:
LEN_HEAD_BITS
)
&
Self
:
:
PTR_HEAD_MASK
)
)
as
*
mut
u8
)
}
;
self
.
len
&
=
!
Self
:
:
LEN_HEAD_MASK
;
self
.
len
|
=
*
head
as
usize
&
Self
:
:
LEN_HEAD_MASK
;
}
pub
unsafe
fn
incr_head
(
&
mut
self
)
{
let
(
data
elts
head
tail
)
=
self
.
raw_parts
(
)
;
let
(
h
wrap
)
=
head
.
incr
:
:
<
T
>
(
)
;
if
wrap
{
*
self
=
Self
:
:
new
(
data
.
offset
(
1
)
elts
.
saturating_sub
(
1
)
h
tail
)
;
}
else
{
*
self
=
Self
:
:
new
(
data
elts
h
tail
)
;
}
}
pub
unsafe
fn
decr_head
(
&
mut
self
)
{
let
(
data
elts
head
tail
)
=
self
.
raw_parts
(
)
;
let
(
h
wrap
)
=
head
.
decr
:
:
<
T
>
(
)
;
if
wrap
{
*
self
=
Self
:
:
new
(
data
.
offset
(
-
1
)
elts
.
saturating_add
(
1
)
h
tail
)
;
}
else
{
*
self
=
Self
:
:
new
(
data
elts
h
tail
)
;
}
}
pub
fn
set_tail
<
Tail
:
Into
<
BitIdx
>
>
(
&
mut
self
tail
:
Tail
)
{
if
self
.
is_empty
(
)
{
return
;
}
let
tail
=
tail
.
into
(
)
;
assert
!
(
tail
.
is_valid_tail
:
:
<
T
>
(
)
"
Tail
indices
must
be
in
the
domain
1
.
.
=
{
}
"
T
:
:
SIZE
)
;
if
self
.
elements
(
)
=
=
1
{
assert
!
(
tail
>
=
self
.
head
(
)
"
Single
-
element
slices
must
have
tail
above
head
"
)
;
}
self
.
len
&
=
!
Self
:
:
LEN_TAIL_MASK
;
self
.
len
|
=
*
tail
as
usize
}
pub
unsafe
fn
incr_tail
(
&
mut
self
)
{
let
(
data
elts
head
tail
)
=
self
.
raw_parts
(
)
;
let
decr
=
BitIdx
:
:
from
(
*
tail
-
1
)
;
let
(
mut
new_tail
wrap
)
=
decr
.
incr
:
:
<
T
>
(
)
;
new_tail
=
BitIdx
:
:
from
(
*
new_tail
+
1
)
;
*
self
=
Self
:
:
new
(
data
elts
+
wrap
as
usize
head
new_tail
)
;
}
pub
unsafe
fn
decr_tail
(
&
mut
self
)
{
let
(
data
elts
head
tail
)
=
self
.
raw_parts
(
)
;
let
decr
=
BitIdx
:
:
from
(
*
tail
-
1
)
;
let
(
mut
new_tail
wrap
)
=
decr
.
decr
:
:
<
T
>
(
)
;
new_tail
=
BitIdx
:
:
from
(
*
new_tail
+
1
)
;
*
self
=
Self
:
:
new
(
data
elts
-
wrap
as
usize
head
new_tail
)
;
}
}
impl
<
T
>
AsMut
<
[
T
]
>
for
BitPtr
<
T
>
where
T
:
Bits
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
self
.
as_mut_slice
(
)
}
}
impl
<
T
>
AsRef
<
[
T
]
>
for
BitPtr
<
T
>
where
T
:
Bits
{
fn
as_ref
(
&
self
)
-
>
&
[
T
]
{
self
.
as_slice
(
)
}
}
impl
<
'
a
C
T
>
From
<
&
'
a
BitSlice
<
C
T
>
>
for
BitPtr
<
T
>
where
C
:
Cursor
T
:
'
a
+
Bits
{
fn
from
(
src
:
&
'
a
BitSlice
<
C
T
>
)
-
>
Self
{
let
src
=
unsafe
{
&
*
(
src
as
*
const
BitSlice
<
C
T
>
as
*
const
[
(
)
]
)
}
;
let
(
ptr
len
)
=
match
(
src
.
as_ptr
(
)
src
.
len
(
)
)
{
(
_
0
)
=
>
(
NonNull
:
:
dangling
(
)
0
)
(
p
_
)
if
p
.
is_null
(
)
=
>
unreachable
!
(
"
Slices
cannot
have
a
length
when
they
begin
at
address
0
"
)
(
p
l
)
=
>
(
unsafe
{
NonNull
:
:
new_unchecked
(
p
as
*
mut
u8
)
}
l
)
}
;
Self
{
ptr
len
_ty
:
PhantomData
}
}
}
impl
<
'
a
C
T
>
From
<
&
'
a
mut
BitSlice
<
C
T
>
>
for
BitPtr
<
T
>
where
C
:
Cursor
T
:
'
a
+
Bits
{
fn
from
(
src
:
&
'
a
mut
BitSlice
<
C
T
>
)
-
>
Self
{
let
src
=
unsafe
{
&
*
(
src
as
*
const
BitSlice
<
C
T
>
as
*
const
[
(
)
]
)
}
;
let
(
ptr
len
)
=
match
(
src
.
as_ptr
(
)
src
.
len
(
)
)
{
(
_
0
)
=
>
(
NonNull
:
:
dangling
(
)
0
)
(
p
_
)
if
p
.
is_null
(
)
=
>
unreachable
!
(
"
Slices
cannot
have
a
length
when
they
begin
at
address
0
"
)
(
p
l
)
=
>
(
unsafe
{
NonNull
:
:
new_unchecked
(
p
as
*
mut
u8
)
}
l
)
}
;
Self
{
ptr
len
_ty
:
PhantomData
}
}
}
impl
<
T
>
Default
for
BitPtr
<
T
>
where
T
:
Bits
{
fn
default
(
)
-
>
Self
{
Self
:
:
empty
(
)
}
}
impl
<
T
>
Debug
for
BitPtr
<
T
>
where
T
:
Bits
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
struct
HexPtr
<
T
:
Bits
>
(
*
const
T
)
;
impl
<
T
:
Bits
>
Debug
for
HexPtr
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_fmt
(
format_args
!
(
"
0x
{
:
0
>
1
X
}
"
self
.
0
as
usize
PTR_BITS
>
>
2
)
)
}
}
struct
HexAddr
(
usize
)
;
impl
Debug
for
HexAddr
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_fmt
(
format_args
!
(
"
{
:
#
X
}
"
self
.
0
)
)
}
}
struct
BinAddr
<
T
:
Bits
>
(
BitIdx
PhantomData
<
T
>
)
;
impl
<
T
:
Bits
>
Debug
for
BinAddr
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_fmt
(
format_args
!
(
"
0b
{
:
0
>
1
b
}
"
*
self
.
0
T
:
:
BITS
as
usize
)
)
}
}
write
!
(
f
"
BitPtr
<
{
}
>
"
T
:
:
TYPENAME
)
?
;
f
.
debug_struct
(
"
"
)
.
field
(
"
data
"
&
HexPtr
:
:
<
T
>
(
self
.
pointer
(
)
)
)
.
field
(
"
elts
"
&
HexAddr
(
self
.
elements
(
)
)
)
.
field
(
"
head
"
&
BinAddr
:
:
<
T
>
(
self
.
head
(
)
PhantomData
)
)
.
field
(
"
tail
"
&
BinAddr
:
:
<
T
>
(
self
.
tail
(
)
PhantomData
)
)
.
finish
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
associated_consts_u8
(
)
{
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
PTR_DATA_BITS
PTR_BITS
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
PTR_HEAD_BITS
0
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
LEN_DATA_BITS
USZ_BITS
-
6
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
LEN_TAIL_BITS
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
PTR_DATA_MASK
!
0
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
PTR_HEAD_MASK
0
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
LEN_DATA_MASK
!
0
<
<
6
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
LEN_TAIL_MASK
7
<
<
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u8
>
:
:
LEN_INDX_MASK
63
)
;
}
#
[
test
]
fn
associated_consts_u16
(
)
{
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
PTR_DATA_BITS
PTR_BITS
-
1
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
PTR_HEAD_BITS
1
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
LEN_DATA_BITS
USZ_BITS
-
7
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
LEN_TAIL_BITS
4
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
PTR_DATA_MASK
!
0
<
<
1
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
PTR_HEAD_MASK
1
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
LEN_DATA_MASK
!
0
<
<
7
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
LEN_TAIL_MASK
15
<
<
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u16
>
:
:
LEN_INDX_MASK
127
)
;
}
#
[
test
]
fn
associated_consts_u32
(
)
{
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
PTR_DATA_BITS
PTR_BITS
-
2
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
PTR_HEAD_BITS
2
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
LEN_DATA_BITS
USZ_BITS
-
8
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
LEN_TAIL_BITS
5
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
PTR_DATA_MASK
!
0
<
<
2
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
PTR_HEAD_MASK
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
LEN_DATA_MASK
!
0
<
<
8
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
LEN_TAIL_MASK
31
<
<
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u32
>
:
:
LEN_INDX_MASK
255
)
;
}
#
[
test
]
fn
associated_consts_u64
(
)
{
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
PTR_DATA_BITS
PTR_BITS
-
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
PTR_HEAD_BITS
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
LEN_DATA_BITS
USZ_BITS
-
9
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
LEN_TAIL_BITS
6
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
PTR_DATA_MASK
!
0
<
<
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
PTR_HEAD_MASK
7
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
LEN_DATA_MASK
!
0
<
<
9
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
LEN_TAIL_MASK
63
<
<
3
)
;
assert_eq
!
(
BitPtr
:
:
<
u64
>
:
:
LEN_INDX_MASK
511
)
;
}
#
[
test
]
fn
ctors
(
)
{
let
data
:
[
u32
;
4
]
=
[
0x756c6153
0x2c6e6f74
0x6e6f6d20
0x00216f64
]
;
let
bp
=
BitPtr
:
:
<
u32
>
:
:
new
(
&
data
as
*
const
u32
4
0
32
)
;
assert_eq
!
(
bp
.
pointer
(
)
&
data
as
*
const
u32
)
;
assert_eq
!
(
bp
.
elements
(
)
4
)
;
assert_eq
!
(
*
bp
.
head
(
)
0
)
;
assert_eq
!
(
*
bp
.
tail
(
)
32
)
;
}
#
[
test
]
fn
empty
(
)
{
let
data
=
[
0u8
;
4
]
;
assert
!
(
BitPtr
:
:
<
u8
>
:
:
new
(
&
data
as
*
const
u8
0
2
4
)
.
is_empty
(
)
)
;
}
#
[
test
]
fn
full
(
)
{
let
elt_ct
=
BitPtr
:
:
<
u64
>
:
:
MAX_ELTS
-
1
;
let
bp
=
BitPtr
:
:
<
u64
>
:
:
new
(
8
as
*
const
u64
elt_ct
0
63
)
;
assert
!
(
bp
.
is_full
(
)
)
;
let
bp
=
BitPtr
:
:
<
u64
>
:
:
new
(
8
as
*
const
u64
elt_ct
0
62
)
;
assert
!
(
!
bp
.
is_full
(
)
)
;
assert_eq
!
(
*
bp
.
tail
(
)
62
.
into
(
)
)
;
let
bp
=
BitPtr
:
:
<
u64
>
:
:
new
(
8
as
*
const
u64
elt_ct
-
1
0
64
)
;
assert
!
(
!
bp
.
is_full
(
)
)
;
}
#
[
test
]
#
[
should_panic
]
fn
overfull
(
)
{
BitPtr
:
:
<
u64
>
:
:
new
(
8
as
*
const
u64
BitPtr
:
:
<
u64
>
:
:
MAX_ELTS
-
1
0
64
)
;
}
}
