#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
macro_export
]
macro_rules
!
bitvec
{
(
endian
:
path
bits
:
ty
;
(
element
:
expr
)
*
)
=
>
{
bitvec
!
[
__bv_impl__
endian
bits
;
(
element
)
*
]
}
;
(
endian
:
path
bits
:
ty
;
(
element
:
expr
)
*
)
=
>
{
bitvec
!
[
__bv_impl__
endian
bits
;
(
element
)
*
]
}
;
(
endian
:
path
;
(
element
:
expr
)
*
)
=
>
{
bitvec
!
[
__bv_impl__
endian
u8
;
(
element
)
*
]
}
;
(
endian
:
path
;
(
element
:
expr
)
*
)
=
>
{
bitvec
!
[
__bv_impl__
endian
u8
;
(
element
)
*
]
}
;
(
(
element
:
expr
)
*
)
=
>
{
bitvec
!
[
__bv_impl__
crate
:
:
prelude
:
:
BigEndian
u8
;
(
element
)
*
]
}
;
(
(
element
:
expr
)
*
)
=
>
{
bitvec
!
[
__bv_impl__
crate
:
:
prelude
:
:
BigEndian
u8
;
(
element
)
*
]
}
;
(
endian
:
path
bits
:
ty
;
element
:
expr
;
rep
:
expr
)
=
>
{
bitvec
!
[
__bv_impl__
endian
bits
;
element
;
rep
]
}
;
(
endian
:
path
;
element
:
expr
;
rep
:
expr
)
=
>
{
bitvec
!
[
__bv_impl__
endian
u8
;
element
;
rep
]
}
;
(
element
:
expr
;
rep
:
expr
)
=
>
{
bitvec
!
[
__bv_impl__
crate
:
:
prelude
:
:
BigEndian
u8
;
element
;
rep
]
}
;
(
__bv_impl__
endian
:
path
bits
:
ty
;
(
element
:
expr
)
*
)
=
>
{
{
let
init
:
&
[
bool
]
=
&
[
(
element
!
=
0
)
*
]
;
crate
:
:
vec
:
:
BitVec
:
:
<
endian
bits
>
:
:
from
(
init
)
}
}
;
(
__bv_impl__
endian
:
path
bits
:
ty
;
element
:
expr
;
rep
:
expr
)
=
>
{
{
core
:
:
iter
:
:
repeat
(
element
!
=
0
)
.
take
(
rep
)
.
collect
:
:
<
crate
:
:
vec
:
:
BitVec
<
endian
bits
>
>
(
)
}
}
;
}
#
[
doc
(
hidden
)
]
macro_rules
!
__bitslice_shift
{
(
(
t
:
ty
)
+
)
=
>
{
(
#
[
doc
(
hidden
)
]
impl
<
C
T
>
core
:
:
ops
:
:
ShlAssign
<
t
>
for
crate
:
:
prelude
:
:
BitSlice
<
C
T
>
where
C
:
crate
:
:
cursor
:
:
Cursor
T
:
crate
:
:
bits
:
:
Bits
{
fn
shl_assign
(
&
mut
self
shamt
:
t
)
{
core
:
:
ops
:
:
ShlAssign
:
:
<
usize
>
:
:
shl_assign
(
self
shamt
as
usize
)
;
}
}
#
[
doc
(
hidden
)
]
impl
<
C
T
>
core
:
:
ops
:
:
ShrAssign
<
t
>
for
crate
:
:
prelude
:
:
BitSlice
<
C
T
>
where
C
:
crate
:
:
cursor
:
:
Cursor
T
:
crate
:
:
bits
:
:
Bits
{
fn
shr_assign
(
&
mut
self
shamt
:
t
)
{
core
:
:
ops
:
:
ShrAssign
:
:
<
usize
>
:
:
shr_assign
(
self
shamt
as
usize
)
;
}
}
)
+
}
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
__bitvec_shift
{
(
(
t
:
ty
)
+
)
=
>
{
(
#
[
doc
(
hidden
)
]
impl
<
C
T
>
core
:
:
ops
:
:
Shl
<
t
>
for
crate
:
:
vec
:
:
BitVec
<
C
T
>
where
C
:
crate
:
:
cursor
:
:
Cursor
T
:
crate
:
:
bits
:
:
Bits
{
type
Output
=
<
Self
as
core
:
:
ops
:
:
Shl
<
usize
>
>
:
:
Output
;
fn
shl
(
self
shamt
:
t
)
-
>
Self
:
:
Output
{
core
:
:
ops
:
:
Shl
:
:
<
usize
>
:
:
shl
(
self
shamt
as
usize
)
}
}
#
[
doc
(
hidden
)
]
impl
<
C
T
>
core
:
:
ops
:
:
ShlAssign
<
t
>
for
crate
:
:
vec
:
:
BitVec
<
C
T
>
where
C
:
crate
:
:
cursor
:
:
Cursor
T
:
crate
:
:
bits
:
:
Bits
{
fn
shl_assign
(
&
mut
self
shamt
:
t
)
{
core
:
:
ops
:
:
ShlAssign
:
:
<
usize
>
:
:
shl_assign
(
self
shamt
as
usize
)
}
}
#
[
doc
(
hidden
)
]
impl
<
C
T
>
core
:
:
ops
:
:
Shr
<
t
>
for
crate
:
:
vec
:
:
BitVec
<
C
T
>
where
C
:
crate
:
:
cursor
:
:
Cursor
T
:
crate
:
:
bits
:
:
Bits
{
type
Output
=
<
Self
as
core
:
:
ops
:
:
Shr
<
usize
>
>
:
:
Output
;
fn
shr
(
self
shamt
:
t
)
-
>
Self
:
:
Output
{
core
:
:
ops
:
:
Shr
:
:
<
usize
>
:
:
shr
(
self
shamt
as
usize
)
}
}
#
[
doc
(
hidden
)
]
impl
<
C
T
>
core
:
:
ops
:
:
ShrAssign
<
t
>
for
crate
:
:
vec
:
:
BitVec
<
C
T
>
where
C
:
crate
:
:
cursor
:
:
Cursor
T
:
crate
:
:
bits
:
:
Bits
{
fn
shr_assign
(
&
mut
self
shamt
:
t
)
{
core
:
:
ops
:
:
ShrAssign
:
:
<
usize
>
:
:
shr_assign
(
self
shamt
as
usize
)
}
}
)
+
}
;
}
#
[
cfg
(
all
(
test
feature
=
"
alloc
"
)
)
]
mod
tests
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
cursor
:
:
{
BigEndian
LittleEndian
}
;
#
[
test
]
fn
compile_macros
(
)
{
bitvec
!
[
0
1
]
;
bitvec
!
[
BigEndian
;
0
1
]
;
bitvec
!
[
LittleEndian
;
0
1
]
;
bitvec
!
[
BigEndian
u8
;
0
1
]
;
bitvec
!
[
LittleEndian
u8
;
0
1
]
;
bitvec
!
[
BigEndian
u16
;
0
1
]
;
bitvec
!
[
LittleEndian
u16
;
0
1
]
;
bitvec
!
[
BigEndian
u32
;
0
1
]
;
bitvec
!
[
LittleEndian
u32
;
0
1
]
;
bitvec
!
[
BigEndian
u64
;
0
1
]
;
bitvec
!
[
LittleEndian
u64
;
0
1
]
;
bitvec
!
[
1
;
70
]
;
bitvec
!
[
BigEndian
;
0
;
70
]
;
bitvec
!
[
LittleEndian
;
1
;
70
]
;
bitvec
!
[
BigEndian
u8
;
0
;
70
]
;
bitvec
!
[
LittleEndian
u8
;
1
;
70
]
;
bitvec
!
[
BigEndian
u16
;
0
;
70
]
;
bitvec
!
[
LittleEndian
u16
;
1
;
70
]
;
bitvec
!
[
BigEndian
u32
;
0
;
70
]
;
bitvec
!
[
LittleEndian
u32
;
1
;
70
]
;
bitvec
!
[
BigEndian
u64
;
0
;
70
]
;
bitvec
!
[
LittleEndian
u64
;
1
;
70
]
;
}
}
