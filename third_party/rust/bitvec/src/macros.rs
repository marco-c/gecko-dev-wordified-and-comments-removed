#
[
macro_use
]
#
[
doc
(
hidden
)
]
pub
mod
internal
;
#
[
macro_export
]
macro_rules
!
bits
{
(
mut
order
:
ident
store
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
{
&
mut
crate
:
:
bitarr
!
[
order
store
;
(
val
)
*
]
[
.
.
crate
:
:
__count
!
(
(
val
)
*
)
]
}
}
;
(
mut
order
:
path
store
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
{
&
mut
crate
:
:
bitarr
!
[
order
store
;
(
val
)
*
]
[
.
.
crate
:
:
__count
!
(
(
val
)
*
)
]
}
}
;
(
mut
order
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
unsafe
{
crate
:
:
bits
!
(
mut
order
usize
;
(
val
)
*
)
}
}
;
(
mut
order
:
path
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
unsafe
{
crate
:
:
bits
!
(
mut
order
usize
;
(
val
)
*
)
}
}
;
(
mut
(
val
:
expr
)
*
(
)
?
)
=
>
{
unsafe
{
crate
:
:
bits
!
(
mut
Lsb0
usize
;
(
val
)
*
)
}
}
;
(
mut
order
:
ident
store
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
{
&
mut
crate
:
:
bitarr
!
[
order
store
;
val
;
len
]
[
.
.
len
]
}
}
;
(
mut
order
:
path
store
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
{
&
mut
crate
:
:
bitarr
!
[
order
store
;
val
;
len
]
[
.
.
len
]
}
}
;
(
mut
order
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bits
!
(
mut
order
usize
;
val
;
len
)
}
;
(
mut
order
:
path
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bits
!
(
mut
order
usize
;
val
;
len
)
}
;
(
mut
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bits
!
(
mut
Lsb0
usize
;
val
;
len
)
}
;
(
order
:
ident
store
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
{
&
crate
:
:
bitarr
!
[
order
store
;
(
val
)
*
]
[
.
.
crate
:
:
__count
!
(
(
val
)
*
)
]
}
}
;
(
order
:
path
store
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
{
&
crate
:
:
bitarr
!
[
order
store
;
(
val
)
*
]
[
.
.
crate
:
:
__count
!
(
(
val
)
*
)
]
}
}
;
(
order
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
bits
!
(
order
usize
;
(
val
)
*
)
}
;
(
order
:
path
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
bits
!
(
order
usize
;
(
val
)
*
)
}
;
(
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
bits
!
(
Lsb0
usize
;
(
val
)
*
)
}
;
(
order
:
ident
store
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
{
&
crate
:
:
bitarr
!
[
order
store
;
val
;
len
]
[
.
.
len
]
}
}
;
(
order
:
path
store
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
{
&
crate
:
:
bitarr
!
[
order
store
;
val
;
len
]
[
.
.
len
]
}
}
;
(
order
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bits
!
(
order
usize
;
val
;
len
)
}
;
(
order
:
path
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bits
!
(
order
usize
;
val
;
len
)
}
;
(
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bits
!
(
Lsb0
usize
;
val
;
len
)
}
;
}
#
[
macro_export
]
macro_rules
!
bitarr
{
(
for
len
:
literal
in
order
:
path
store
:
ident
)
=
>
{
crate
:
:
array
:
:
BitArray
:
:
<
order
[
store
;
crate
:
:
mem
:
:
elts
:
:
<
store
>
(
len
)
]
>
}
;
(
for
len
:
literal
in
store
:
ident
)
=
>
{
crate
:
:
bitarr
!
(
for
len
in
crate
:
:
order
:
:
Lsb0
usize
)
}
;
(
for
len
:
literal
)
=
>
{
crate
:
:
bitarr
!
(
for
len
in
usize
)
}
;
(
order
:
ident
store
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
array
:
:
BitArray
:
:
<
order
[
store
;
crate
:
:
__count_elts
!
(
store
;
(
val
)
*
)
]
>
:
:
new
(
crate
:
:
__bits_store_array
!
(
order
store
;
(
val
)
*
)
)
}
;
(
order
:
path
store
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
array
:
:
BitArray
:
:
<
order
[
store
;
crate
:
:
__count_elts
!
(
store
;
(
val
)
*
)
]
>
:
:
new
(
crate
:
:
__bits_store_array
!
(
order
store
;
(
val
)
*
)
)
}
;
(
order
:
ident
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
bitarr
!
(
order
usize
;
(
val
)
*
)
}
;
(
order
:
path
;
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
bitarr
!
(
order
usize
;
(
val
)
*
)
}
;
(
(
val
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
bitarr
!
(
Lsb0
usize
;
(
val
)
*
)
}
;
(
order
:
ident
store
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
array
:
:
BitArray
:
:
<
order
[
store
;
crate
:
:
mem
:
:
elts
:
:
<
store
>
(
len
)
]
>
:
:
new
(
[
crate
:
:
__extend_bool
!
(
val
store
)
;
crate
:
:
mem
:
:
elts
:
:
<
store
>
(
len
)
]
)
}
;
(
order
:
path
store
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
array
:
:
BitArray
:
:
<
order
[
store
;
crate
:
:
mem
:
:
elts
:
:
<
store
>
(
len
)
]
>
:
:
new
(
[
crate
:
:
__extend_bool
!
(
val
store
)
;
crate
:
:
mem
:
:
elts
:
:
<
store
>
(
len
)
]
)
}
;
(
order
:
ident
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bitarr
!
(
order
usize
;
val
;
len
)
}
;
(
order
:
path
;
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bitarr
!
(
order
usize
;
val
;
len
)
}
;
(
val
:
expr
;
len
:
expr
)
=
>
{
crate
:
:
bitarr
!
(
Lsb0
usize
;
val
;
len
)
}
;
}
#
[
macro_export
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
macro_rules
!
bitvec
{
(
order
:
ty
store
:
ident
;
val
:
expr
;
rep
:
expr
)
=
>
{
crate
:
:
vec
:
:
BitVec
:
:
<
order
store
>
:
:
repeat
(
val
!
=
0
rep
)
}
;
(
order
:
ty
;
val
:
expr
;
rep
:
expr
)
=
>
{
crate
:
:
vec
:
:
BitVec
:
:
<
order
usize
>
:
:
repeat
(
val
!
=
0
rep
)
}
;
(
val
:
expr
;
rep
:
expr
)
=
>
{
crate
:
:
vec
:
:
BitVec
:
:
<
crate
:
:
order
:
:
Lsb0
usize
>
:
:
repeat
(
val
!
=
0
rep
)
}
;
(
(
arg
:
tt
)
*
)
=
>
{
{
crate
:
:
vec
:
:
BitVec
:
:
from_bitslice
(
crate
:
:
bits
!
(
(
arg
)
*
)
)
}
}
;
}
#
[
macro_export
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
macro_rules
!
bitbox
{
(
(
arg
:
tt
)
*
)
=
>
{
crate
:
:
bitvec
!
(
(
arg
)
*
)
.
into_boxed_bitslice
(
)
}
;
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
order
:
:
{
Lsb0
Msb0
}
;
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
compile_bits_macros
(
)
{
bits
!
[
0
1
]
;
bits
!
[
Msb0
;
0
1
]
;
bits
!
[
Lsb0
;
0
1
]
;
bits
!
[
Msb0
u8
;
0
1
]
;
bits
!
[
Lsb0
u8
;
0
1
]
;
bits
!
[
Msb0
u16
;
0
1
]
;
bits
!
[
Lsb0
u16
;
0
1
]
;
bits
!
[
Msb0
u32
;
0
1
]
;
bits
!
[
Lsb0
u32
;
0
1
]
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
bits
!
[
Msb0
u64
;
0
1
]
;
bits
!
[
Lsb0
u64
;
0
1
]
;
}
bits
!
[
1
;
70
]
;
bits
!
[
Msb0
;
0
;
70
]
;
bits
!
[
Lsb0
;
1
;
70
]
;
bits
!
[
Msb0
u8
;
0
;
70
]
;
bits
!
[
Lsb0
u8
;
1
;
70
]
;
bits
!
[
Msb0
u16
;
0
;
70
]
;
bits
!
[
Lsb0
u16
;
1
;
70
]
;
bits
!
[
Msb0
u32
;
0
;
70
]
;
bits
!
[
Lsb0
u32
;
1
;
70
]
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
bits
!
[
Msb0
u64
;
0
;
70
]
;
bits
!
[
Lsb0
u64
;
1
;
70
]
;
}
}
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
compile_bitvec_macros
(
)
{
bitvec
!
[
0
1
]
;
bitvec
!
[
Msb0
;
0
1
]
;
bitvec
!
[
Lsb0
;
0
1
]
;
bitvec
!
[
Msb0
u8
;
0
1
]
;
bitvec
!
[
Lsb0
u8
;
0
1
]
;
bitvec
!
[
Msb0
u16
;
0
1
]
;
bitvec
!
[
Lsb0
u16
;
0
1
]
;
bitvec
!
[
Msb0
u32
;
0
1
]
;
bitvec
!
[
Lsb0
u32
;
0
1
]
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
bitvec
!
[
Msb0
u64
;
0
1
]
;
bitvec
!
[
Lsb0
u64
;
0
1
]
;
}
bitvec
!
[
1
;
70
]
;
bitvec
!
[
Msb0
;
0
;
70
]
;
bitvec
!
[
Lsb0
;
1
;
70
]
;
bitvec
!
[
Msb0
u8
;
0
;
70
]
;
bitvec
!
[
Lsb0
u8
;
1
;
70
]
;
bitvec
!
[
Msb0
u16
;
0
;
70
]
;
bitvec
!
[
Lsb0
u16
;
1
;
70
]
;
bitvec
!
[
Msb0
u32
;
0
;
70
]
;
bitvec
!
[
Lsb0
u32
;
1
;
70
]
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
bitvec
!
[
Msb0
u64
;
0
;
70
]
;
bitvec
!
[
Lsb0
u64
;
1
;
70
]
;
}
}
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
compile_bitbox_macros
(
)
{
bitbox
!
[
0
1
]
;
bitbox
!
[
Msb0
;
0
1
]
;
bitbox
!
[
Lsb0
;
0
1
]
;
bitbox
!
[
Msb0
u8
;
0
1
]
;
bitbox
!
[
Lsb0
u8
;
0
1
]
;
bitbox
!
[
Msb0
u16
;
0
1
]
;
bitbox
!
[
Lsb0
u16
;
0
1
]
;
bitbox
!
[
Msb0
u32
;
0
1
]
;
bitbox
!
[
Lsb0
u32
;
0
1
]
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
bitbox
!
[
Msb0
u64
;
0
1
]
;
bitbox
!
[
Lsb0
u64
;
0
1
]
;
}
bitbox
!
[
1
;
70
]
;
bitbox
!
[
Msb0
;
0
;
70
]
;
bitbox
!
[
Lsb0
;
1
;
70
]
;
bitbox
!
[
Msb0
u8
;
0
;
70
]
;
bitbox
!
[
Lsb0
u8
;
1
;
70
]
;
bitbox
!
[
Msb0
u16
;
0
;
70
]
;
bitbox
!
[
Lsb0
u16
;
1
;
70
]
;
bitbox
!
[
Msb0
u32
;
0
;
70
]
;
bitbox
!
[
Lsb0
u32
;
1
;
70
]
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
{
bitbox
!
[
Msb0
u64
;
0
;
70
]
;
bitbox
!
[
Lsb0
u64
;
1
;
70
]
;
}
}
}
