#
!
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
{
index
:
:
BitIdx
mem
:
:
BitMemory
order
:
:
{
BitOrder
Lsb0
}
pointer
:
:
BitPtr
slice
:
:
BitSlice
store
:
:
BitStore
}
;
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
{
mem
:
:
ManuallyDrop
ptr
:
:
NonNull
slice
}
;
use
tap
:
:
pipe
:
:
Pipe
;
#
[
repr
(
transparent
)
]
pub
struct
BitBox
<
O
=
Lsb0
T
=
usize
>
where
O
:
BitOrder
T
:
BitStore
{
pointer
:
NonNull
<
BitSlice
<
O
T
>
>
}
impl
<
O
T
>
BitBox
<
O
T
>
where
O
:
BitOrder
T
:
BitStore
{
#
[
inline
]
pub
fn
from_bitslice
(
slice
:
&
BitSlice
<
O
T
>
)
-
>
Self
{
slice
.
to_bitvec
(
)
.
into_boxed_bitslice
(
)
}
#
[
inline
]
pub
fn
from_boxed_slice
(
boxed
:
Box
<
[
T
]
>
)
-
>
Self
{
Self
:
:
try_from_boxed_slice
(
boxed
)
.
expect
(
"
Slice
was
too
long
to
be
converted
into
a
BitBox
"
)
}
#
[
inline
]
pub
fn
try_from_boxed_slice
(
boxed
:
Box
<
[
T
]
>
)
-
>
Result
<
Self
Box
<
[
T
]
>
>
{
let
len
=
boxed
.
len
(
)
;
if
len
>
BitSlice
:
:
<
O
T
>
:
:
MAX_ELTS
{
return
Err
(
boxed
)
;
}
let
boxed
=
ManuallyDrop
:
:
new
(
boxed
)
;
let
base
=
boxed
.
as_ptr
(
)
;
Ok
(
Self
{
pointer
:
unsafe
{
BitPtr
:
:
new_unchecked
(
base
BitIdx
:
:
ZERO
len
*
T
:
:
Mem
:
:
BITS
as
usize
)
}
.
to_nonnull
(
)
}
)
}
#
[
inline
]
pub
fn
into_boxed_slice
(
self
)
-
>
Box
<
[
T
]
>
{
let
mut
this
=
ManuallyDrop
:
:
new
(
self
)
;
unsafe
{
Box
:
:
from_raw
(
this
.
as_mut_slice
(
)
)
}
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_bitslice
(
&
self
)
-
>
&
BitSlice
<
O
T
>
{
self
.
bitptr
(
)
.
to_bitslice_ref
(
)
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_mut_bitslice
(
&
mut
self
)
-
>
&
mut
BitSlice
<
O
T
>
{
self
.
bitptr
(
)
.
to_bitslice_mut
(
)
}
#
[
inline
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
T
]
{
let
bitptr
=
self
.
bitptr
(
)
;
let
(
base
elts
)
=
(
bitptr
.
pointer
(
)
.
to_const
(
)
bitptr
.
elements
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts
(
base
elts
)
}
}
#
[
inline
]
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
T
]
{
let
bitptr
=
self
.
bitptr
(
)
;
let
(
base
elts
)
=
(
bitptr
.
pointer
(
)
.
to_mut
(
)
bitptr
.
elements
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts_mut
(
base
elts
)
}
}
#
[
inline
]
pub
fn
set_uninitialized
(
&
mut
self
value
:
bool
)
{
let
head
=
self
.
bitptr
(
)
.
head
(
)
.
value
(
)
as
usize
;
let
tail
=
head
+
self
.
len
(
)
;
let
elts
=
self
.
bitptr
(
)
.
elements
(
)
*
T
:
:
Mem
:
:
BITS
as
usize
;
let
mut
bp
=
self
.
bitptr
(
)
;
unsafe
{
bp
.
set_head
(
BitIdx
:
:
ZERO
)
;
bp
.
set_len
(
elts
)
;
let
bits
=
bp
.
to_bitslice_mut
:
:
<
O
>
(
)
;
bits
.
get_unchecked_mut
(
.
.
head
)
.
set_all
(
value
)
;
bits
.
get_unchecked_mut
(
tail
.
.
)
.
set_all
(
value
)
;
}
}
#
[
inline
]
pub
(
crate
)
fn
bitptr
(
&
self
)
-
>
BitPtr
<
T
>
{
self
.
pointer
.
as_ptr
(
)
.
pipe
(
BitPtr
:
:
from_bitslice_ptr_mut
)
}
fn
with_box
<
F
R
>
(
&
mut
self
func
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
ManuallyDrop
<
Box
<
[
T
:
:
Mem
]
>
>
)
-
>
R
{
self
.
as_mut_slice
(
)
.
pipe
(
|
s
|
s
as
*
mut
[
T
]
as
*
mut
[
T
:
:
Mem
]
)
.
pipe
(
|
raw
|
unsafe
{
Box
:
:
from_raw
(
raw
)
}
)
.
pipe
(
ManuallyDrop
:
:
new
)
.
pipe_ref_mut
(
func
)
}
}
mod
api
;
mod
ops
;
mod
traits
;
#
[
cfg
(
test
)
]
mod
tests
;
