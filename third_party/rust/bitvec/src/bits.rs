use
crate
:
:
Cursor
;
use
core
:
:
{
cmp
:
:
Eq
convert
:
:
From
fmt
:
:
{
self
Binary
Debug
Display
Formatter
LowerHex
UpperHex
}
mem
:
:
size_of
ops
:
:
{
BitAnd
BitAndAssign
BitOrAssign
Deref
DerefMut
Not
Shl
ShlAssign
Shr
ShrAssign
}
}
;
pub
trait
Bits
:
Sealed
+
Binary
+
BitAnd
<
Self
Output
=
Self
>
+
BitAndAssign
<
Self
>
+
BitOrAssign
<
Self
>
+
Copy
+
Debug
+
Display
+
Eq
+
From
<
u8
>
+
Into
<
u64
>
+
LowerHex
+
Not
<
Output
=
Self
>
+
Shl
<
u8
Output
=
Self
>
+
ShlAssign
<
u8
>
+
Shr
<
u8
Output
=
Self
>
+
ShrAssign
<
u8
>
+
Sized
+
UpperHex
{
const
SIZE
:
u8
=
size_of
:
:
<
Self
>
(
)
as
u8
*
8
;
const
BITS
:
u8
;
const
MASK
:
u8
=
Self
:
:
SIZE
-
1
;
const
TYPENAME
:
&
'
static
str
;
fn
set
<
C
:
Cursor
>
(
&
mut
self
place
:
BitIdx
value
:
bool
)
{
let
place
:
BitPos
=
C
:
:
at
:
:
<
Self
>
(
place
)
;
assert
!
(
*
place
<
Self
:
:
SIZE
"
Index
out
of
range
:
{
}
overflows
{
}
"
*
place
Self
:
:
SIZE
)
;
*
self
&
=
!
(
Self
:
:
from
(
1u8
)
<
<
*
place
)
;
*
self
|
=
Self
:
:
from
(
value
as
u8
)
<
<
*
place
;
}
fn
get
<
C
:
Cursor
>
(
&
self
place
:
BitIdx
)
-
>
bool
{
let
place
:
BitPos
=
C
:
:
at
:
:
<
Self
>
(
place
)
;
assert
!
(
*
place
<
Self
:
:
SIZE
"
Index
out
of
range
:
{
}
overflows
{
}
"
*
place
Self
:
:
SIZE
)
;
(
*
self
>
>
*
place
)
&
Self
:
:
from
(
1
)
=
=
Self
:
:
from
(
1
)
}
#
[
inline
(
always
)
]
fn
count_ones
(
&
self
)
-
>
usize
{
u64
:
:
count_ones
(
(
*
self
)
.
into
(
)
)
as
usize
}
#
[
inline
(
always
)
]
fn
count_zeros
(
&
self
)
-
>
usize
{
u64
:
:
count_ones
(
(
!
*
self
)
.
into
(
)
)
as
usize
}
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
struct
BitIdx
(
pub
(
crate
)
u8
)
;
impl
BitIdx
{
pub
fn
is_valid
<
T
:
Bits
>
(
self
)
-
>
bool
{
*
self
<
T
:
:
SIZE
}
pub
fn
incr
<
T
:
Bits
>
(
self
)
-
>
(
Self
bool
)
{
assert
!
(
*
self
<
T
:
:
SIZE
"
Index
out
of
range
:
{
}
overflows
{
}
"
*
self
T
:
:
SIZE
)
;
let
next
=
(
*
self
)
.
wrapping_add
(
1
)
&
T
:
:
MASK
;
(
next
.
into
(
)
next
=
=
0
)
}
pub
fn
decr
<
T
:
Bits
>
(
self
)
-
>
(
Self
bool
)
{
assert
!
(
*
self
<
T
:
:
SIZE
"
Index
out
of
range
:
{
}
overflows
{
}
"
*
self
T
:
:
SIZE
)
;
let
(
prev
wrap
)
=
(
*
self
)
.
overflowing_sub
(
1
)
;
(
(
prev
&
T
:
:
MASK
)
.
into
(
)
wrap
)
}
pub
fn
offset
<
T
:
Bits
>
(
self
by
:
isize
)
-
>
(
isize
Self
)
{
assert
!
(
*
self
<
T
:
:
SIZE
"
Index
out
of
range
:
{
}
overflows
{
}
"
*
self
T
:
:
SIZE
)
;
if
let
(
far
false
)
=
by
.
overflowing_add
(
*
self
as
isize
)
{
if
far
>
=
0
&
&
far
<
T
:
:
SIZE
as
isize
{
(
0
(
far
as
u8
)
.
into
(
)
)
}
else
{
(
far
>
>
T
:
:
BITS
(
(
far
&
(
T
:
:
MASK
as
isize
)
)
as
u8
)
.
into
(
)
)
}
}
else
{
let
far
=
*
self
as
usize
+
by
as
usize
;
(
(
far
>
>
T
:
:
BITS
)
as
isize
(
(
far
&
(
T
:
:
MASK
as
usize
)
)
as
u8
)
.
into
(
)
)
}
}
pub
fn
span
<
T
:
Bits
>
(
self
len
:
usize
)
-
>
(
usize
BitIdx
)
{
let
bits_in_head
=
(
T
:
:
SIZE
-
*
self
)
as
usize
;
if
len
<
=
bits_in_head
{
(
1
(
*
self
+
len
as
u8
)
.
into
(
)
)
}
else
{
let
bits_after_head
=
len
-
bits_in_head
;
let
whole_elts
=
bits_after_head
>
>
T
:
:
BITS
;
let
tail_bits
=
bits_after_head
as
u8
&
T
:
:
MASK
;
if
tail_bits
=
=
0
{
(
whole_elts
+
1
T
:
:
SIZE
.
into
(
)
)
}
else
{
(
whole_elts
+
2
tail_bits
.
into
(
)
)
}
}
}
}
impl
From
<
u8
>
for
BitIdx
{
fn
from
(
src
:
u8
)
-
>
Self
{
BitIdx
(
src
)
}
}
impl
Into
<
u8
>
for
BitIdx
{
fn
into
(
self
)
-
>
u8
{
self
.
0
}
}
impl
Display
for
BitIdx
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
BitIdx
(
{
}
)
"
self
.
0
)
}
}
impl
Deref
for
BitIdx
{
type
Target
=
u8
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
BitIdx
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
struct
BitPos
(
u8
)
;
impl
BitPos
{
pub
fn
is_valid
<
T
:
Bits
>
(
self
)
-
>
bool
{
*
self
<
T
:
:
SIZE
}
}
impl
From
<
u8
>
for
BitPos
{
fn
from
(
src
:
u8
)
-
>
Self
{
BitPos
(
src
)
}
}
impl
Into
<
u8
>
for
BitPos
{
fn
into
(
self
)
-
>
u8
{
self
.
0
}
}
impl
Display
for
BitPos
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
BitPos
(
{
}
)
"
self
.
0
)
}
}
impl
Deref
for
BitPos
{
type
Target
=
u8
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
DerefMut
for
BitPos
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
0
}
}
impl
Bits
for
u8
{
const
BITS
:
u8
=
3
;
const
TYPENAME
:
&
'
static
str
=
"
u8
"
;
}
impl
Bits
for
u16
{
const
BITS
:
u8
=
4
;
const
TYPENAME
:
&
'
static
str
=
"
u16
"
;
}
impl
Bits
for
u32
{
const
BITS
:
u8
=
5
;
const
TYPENAME
:
&
'
static
str
=
"
u32
"
;
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
impl
Bits
for
u64
{
const
BITS
:
u8
=
6
;
const
TYPENAME
:
&
'
static
str
=
"
u64
"
;
}
#
[
doc
(
hidden
)
]
pub
trait
Sealed
{
}
impl
Sealed
for
u8
{
}
impl
Sealed
for
u16
{
}
impl
Sealed
for
u32
{
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
impl
Sealed
for
u64
{
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
jump_far_up
(
)
{
for
n
in
1
.
.
8
{
let
(
elt
bit
)
=
BitIdx
:
:
from
(
n
)
.
offset
:
:
<
u8
>
(
isize
:
:
max_value
(
)
)
;
assert_eq
!
(
elt
(
isize
:
:
max_value
(
)
>
>
u8
:
:
BITS
)
+
1
)
;
assert_eq
!
(
*
bit
n
-
1
)
;
}
let
(
elt
bit
)
=
BitIdx
:
:
from
(
0
)
.
offset
:
:
<
u8
>
(
isize
:
:
max_value
(
)
)
;
assert_eq
!
(
elt
isize
:
:
max_value
(
)
>
>
u8
:
:
BITS
)
;
assert_eq
!
(
*
bit
7
)
;
}
#
[
test
]
fn
jump_far_down
(
)
{
for
n
in
0
.
.
8
{
let
(
elt
bit
)
=
BitIdx
:
:
from
(
n
)
.
offset
:
:
<
u8
>
(
isize
:
:
min_value
(
)
)
;
assert_eq
!
(
elt
isize
:
:
min_value
(
)
>
>
u8
:
:
BITS
)
;
assert_eq
!
(
*
bit
n
)
;
}
}
#
[
test
]
#
[
should_panic
]
fn
offset_out_of_bound
(
)
{
BitIdx
:
:
from
(
64
)
.
offset
:
:
<
u64
>
(
isize
:
:
max_value
(
)
)
;
}
}
