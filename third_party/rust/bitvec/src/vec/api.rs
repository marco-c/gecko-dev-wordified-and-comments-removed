use
crate
:
:
{
mem
:
:
BitMemory
order
:
:
BitOrder
pointer
:
:
BitPtr
slice
:
:
BitSlice
store
:
:
BitStore
vec
:
:
{
iter
:
:
{
Drain
Splice
}
BitVec
}
}
;
use
alloc
:
:
{
borrow
:
:
ToOwned
boxed
:
:
Box
vec
:
:
Vec
}
;
use
core
:
:
{
mem
ops
:
:
RangeBounds
slice
}
;
use
funty
:
:
IsInteger
;
use
tap
:
:
{
pipe
:
:
Pipe
tap
:
:
Tap
}
;
impl
<
O
T
>
BitVec
<
O
T
>
where
O
:
BitOrder
T
:
BitStore
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
{
pointer
:
BitPtr
:
:
<
T
>
:
:
EMPTY
.
to_nonnull
(
)
capacity
:
0
}
}
#
[
inline
]
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
assert
!
(
capacity
<
=
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
"
Vector
capacity
exceeded
:
{
}
>
{
}
"
capacity
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
)
;
let
vec
=
capacity
.
pipe
(
crate
:
:
mem
:
:
elts
:
:
<
T
>
)
.
pipe
(
Vec
:
:
<
T
>
:
:
with_capacity
)
;
let
(
ptr
capacity
)
=
(
vec
.
as_ptr
(
)
vec
.
capacity
(
)
)
;
mem
:
:
forget
(
vec
)
;
ptr
.
pipe
(
BitPtr
:
:
uninhabited
)
.
pipe
(
BitPtr
:
:
to_nonnull
)
.
pipe
(
|
pointer
|
Self
{
pointer
capacity
}
)
}
#
[
inline
]
pub
unsafe
fn
from_raw_parts
(
pointer
:
*
mut
BitSlice
<
O
T
>
capacity
:
usize
)
-
>
Self
{
if
(
pointer
as
*
mut
[
(
)
]
)
.
is_null
(
)
{
panic
!
(
"
Attempted
to
reconstruct
a
BitVec
from
a
null
pointer
"
)
;
}
pointer
.
pipe
(
BitPtr
:
:
from_bitslice_ptr_mut
)
.
to_nonnull
(
)
.
pipe
(
|
pointer
|
Self
{
pointer
capacity
}
)
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
capacity
.
checked_mul
(
T
:
:
Mem
:
:
BITS
as
usize
)
.
expect
(
"
Vector
capacity
exceeded
"
)
.
saturating_sub
(
self
.
bitptr
(
)
.
head
(
)
.
value
(
)
as
usize
)
}
#
[
inline
]
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
let
len
=
self
.
len
(
)
;
let
new_len
=
len
.
checked_add
(
additional
)
.
expect
(
"
Vector
capacity
exceeded
"
)
;
assert
!
(
new_len
<
=
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
"
Vector
capacity
exceeded
:
{
}
>
{
}
"
new_len
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
)
;
let
bitptr
=
self
.
bitptr
(
)
;
let
head
=
bitptr
.
head
(
)
;
let
elts
=
bitptr
.
elements
(
)
;
if
let
Some
(
extra
)
=
head
.
span
(
new_len
)
.
0
.
checked_sub
(
elts
)
{
self
.
with_vec
(
|
v
|
v
.
reserve
(
extra
)
)
;
let
capa
=
self
.
capacity
(
)
;
unsafe
{
self
.
get_unchecked_mut
(
len
.
.
capa
)
}
.
set_all
(
false
)
;
}
}
#
[
inline
]
pub
fn
reserve_exact
(
&
mut
self
additional
:
usize
)
{
let
new_len
=
self
.
len
(
)
.
checked_add
(
additional
)
.
expect
(
"
Vector
capacity
exceeded
"
)
;
assert
!
(
new_len
<
=
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
"
Vector
capacity
exceeded
:
{
}
>
{
}
"
new_len
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
)
;
let
bitptr
=
self
.
bitptr
(
)
;
let
head
=
bitptr
.
head
(
)
;
let
elts
=
bitptr
.
elements
(
)
;
if
let
Some
(
extra
)
=
head
.
span
(
new_len
)
.
0
.
checked_sub
(
elts
)
{
self
.
with_vec
(
|
v
|
v
.
reserve_exact
(
extra
)
)
;
}
}
#
[
inline
]
pub
fn
shrink_to_fit
(
&
mut
self
)
{
self
.
with_vec
(
|
v
|
v
.
shrink_to_fit
(
)
)
;
}
#
[
inline
]
pub
fn
into_boxed_slice
(
self
)
-
>
Box
<
[
T
]
>
{
self
.
into_vec
(
)
.
into_boxed_slice
(
)
}
#
[
inline
]
pub
fn
truncate
(
&
mut
self
len
:
usize
)
{
if
len
<
self
.
len
(
)
{
unsafe
{
self
.
set_len
(
len
)
}
}
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
T
]
{
let
bitptr
=
self
.
bitptr
(
)
;
let
(
base
elts
)
=
(
bitptr
.
pointer
(
)
.
to_const
(
)
bitptr
.
elements
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts
(
base
elts
)
}
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
T
]
{
let
bitptr
=
self
.
bitptr
(
)
;
let
(
base
elts
)
=
(
bitptr
.
pointer
(
)
.
to_mut
(
)
bitptr
.
elements
(
)
)
;
unsafe
{
slice
:
:
from_raw_parts_mut
(
base
elts
)
}
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_ptr
(
&
self
)
-
>
*
const
T
{
self
.
bitptr
(
)
.
pointer
(
)
.
to_const
(
)
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
as_mut_ptr
(
&
mut
self
)
-
>
*
mut
T
{
self
.
bitptr
(
)
.
pointer
(
)
.
to_mut
(
)
}
#
[
inline
]
pub
unsafe
fn
set_len
(
&
mut
self
new_len
:
usize
)
{
assert
!
(
new_len
<
=
BitPtr
:
:
<
T
>
:
:
REGION_MAX_BITS
"
Capacity
exceeded
:
{
}
exceeds
maximum
length
{
}
"
new_len
BitPtr
:
:
<
T
>
:
:
REGION_MAX_BITS
)
;
let
cap
=
self
.
capacity
(
)
;
assert
!
(
new_len
<
=
cap
"
Capacity
exceeded
:
{
}
exceeds
allocation
size
{
}
"
new_len
cap
)
;
self
.
pointer
=
self
.
pointer
.
as_ptr
(
)
.
pipe
(
BitPtr
:
:
from_bitslice_ptr_mut
)
.
tap_mut
(
|
bp
|
bp
.
set_len
(
new_len
)
)
.
to_nonnull
(
)
}
#
[
inline
]
pub
fn
swap_remove
(
&
mut
self
index
:
usize
)
-
>
bool
{
let
len
=
self
.
len
(
)
;
assert
!
(
index
<
len
"
Index
{
}
out
of
bounds
:
{
}
"
index
len
)
;
let
last
=
len
-
1
;
unsafe
{
self
.
swap_unchecked
(
index
last
)
;
self
.
set_len
(
last
)
;
*
self
.
get_unchecked
(
last
)
}
}
#
[
inline
]
pub
fn
insert
(
&
mut
self
index
:
usize
value
:
bool
)
{
let
len
=
self
.
len
(
)
;
assert
!
(
index
<
=
len
"
Index
{
}
out
of
bounds
:
{
}
"
index
len
)
;
self
.
push
(
value
)
;
unsafe
{
self
.
get_unchecked_mut
(
index
.
.
)
}
.
rotate_right
(
1
)
;
}
#
[
inline
]
pub
fn
remove
(
&
mut
self
index
:
usize
)
-
>
bool
{
let
len
=
self
.
len
(
)
;
assert
!
(
index
<
len
"
Index
{
}
out
of
bounds
:
{
}
"
index
len
)
;
let
last
=
len
-
1
;
unsafe
{
self
.
get_unchecked_mut
(
index
.
.
)
.
rotate_left
(
1
)
;
self
.
set_len
(
last
)
;
*
self
.
get_unchecked
(
last
)
}
}
#
[
inline
]
pub
fn
retain
<
F
>
(
&
mut
self
mut
func
:
F
)
where
F
:
FnMut
(
usize
&
bool
)
-
>
bool
{
for
n
in
(
0
.
.
self
.
len
(
)
)
.
rev
(
)
{
if
!
func
(
n
unsafe
{
self
.
get_unchecked
(
n
)
}
)
{
self
.
remove
(
n
)
;
}
}
}
#
[
inline
]
pub
fn
push
(
&
mut
self
value
:
bool
)
{
let
len
=
self
.
len
(
)
;
assert
!
(
len
<
=
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
"
Exceeded
capacity
:
{
}
>
=
{
}
"
len
BitSlice
:
:
<
O
T
>
:
:
MAX_BITS
)
;
if
self
.
is_empty
(
)
|
|
self
.
bitptr
(
)
.
tail
(
)
.
value
(
)
=
=
T
:
:
Mem
:
:
BITS
{
self
.
with_vec
(
|
v
|
v
.
push
(
T
:
:
Mem
:
:
ZERO
)
)
;
}
unsafe
{
self
.
pointer
=
self
.
pointer
.
as_ptr
(
)
.
pipe
(
BitPtr
:
:
from_bitslice_ptr_mut
)
.
tap_mut
(
|
bp
|
bp
.
set_len
(
len
+
1
)
)
.
to_nonnull
(
)
;
self
.
set_unchecked
(
len
value
)
;
}
}
#
[
inline
]
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
bool
>
{
match
self
.
len
(
)
{
0
=
>
None
n
=
>
unsafe
{
let
m
=
n
-
1
;
(
*
self
.
get_unchecked
(
m
)
)
.
tap
(
|
_
|
self
.
set_len
(
m
)
)
.
pipe
(
Some
)
}
}
}
#
[
inline
]
pub
fn
append
<
O2
T2
>
(
&
mut
self
other
:
&
mut
BitVec
<
O2
T2
>
)
where
O2
:
BitOrder
T2
:
BitStore
{
self
.
extend
(
other
.
iter
(
)
.
copied
(
)
)
;
other
.
clear
(
)
;
}
#
[
inline
(
always
)
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
drain
<
R
>
(
&
mut
self
range
:
R
)
-
>
Drain
<
O
T
>
where
R
:
RangeBounds
<
usize
>
{
Drain
:
:
new
(
self
range
)
}
#
[
cfg_attr
(
not
(
tarpaulin
)
inline
(
always
)
)
]
pub
fn
clear
(
&
mut
self
)
{
unsafe
{
self
.
set_len
(
0
)
;
}
}
#
[
inline
]
pub
fn
split_off
(
&
mut
self
at
:
usize
)
-
>
Self
{
let
len
=
self
.
len
(
)
;
assert
!
(
at
<
=
len
"
Index
{
}
out
of
bounds
:
{
}
"
at
len
)
;
match
at
{
0
=
>
mem
:
:
replace
(
self
Self
:
:
with_capacity
(
self
.
capacity
(
)
)
)
n
if
n
=
=
len
=
>
Self
:
:
new
(
)
_
=
>
unsafe
{
self
.
set_len
(
at
)
;
self
.
get_unchecked
(
at
.
.
len
)
.
to_owned
(
)
}
}
}
#
[
inline
]
pub
fn
resize_with
<
F
>
(
&
mut
self
new_len
:
usize
mut
func
:
F
)
where
F
:
FnMut
(
)
-
>
bool
{
let
len
=
self
.
len
(
)
;
if
new_len
>
len
{
let
ext
=
new_len
-
len
;
self
.
reserve
(
ext
)
;
unsafe
{
self
.
get_unchecked_mut
(
len
.
.
new_len
)
.
for_each
(
|
_
_
|
func
(
)
)
;
}
}
unsafe
{
self
.
set_len
(
new_len
)
;
}
}
#
[
inline
]
pub
fn
resize
(
&
mut
self
new_len
:
usize
value
:
bool
)
{
let
len
=
self
.
len
(
)
;
if
new_len
>
len
{
let
ext
=
new_len
-
len
;
self
.
reserve
(
ext
)
;
let
capa
=
self
.
capacity
(
)
;
unsafe
{
self
.
get_unchecked_mut
(
len
.
.
capa
)
.
set_all
(
value
)
;
}
}
unsafe
{
self
.
set_len
(
new_len
)
;
}
}
#
[
cfg_attr
(
not
(
tarpaulin
)
inline
(
always
)
)
]
pub
fn
extend_from_slice
(
&
mut
self
other
:
&
[
bool
]
)
{
self
.
extend
(
other
)
}
#
[
inline
]
#
[
cfg
(
not
(
tarpaulin_include
)
)
]
pub
fn
splice
<
R
I
>
(
&
mut
self
range
:
R
replace_with
:
I
)
-
>
Splice
<
O
T
I
:
:
IntoIter
>
where
R
:
RangeBounds
<
usize
>
I
:
IntoIterator
<
Item
=
bool
>
{
Splice
:
:
new
(
self
.
drain
(
range
)
replace_with
)
}
}
