use
core
:
:
mem
;
use
funty
:
:
IsUnsigned
;
pub
trait
BitMemory
:
IsUnsigned
+
seal
:
:
Sealed
{
const
BITS
:
u8
=
mem
:
:
size_of
:
:
<
Self
>
(
)
as
u8
*
8
;
const
INDX
:
u8
=
Self
:
:
BITS
.
trailing_zeros
(
)
as
u8
;
const
MASK
:
u8
=
Self
:
:
BITS
-
1
;
const
ONE
:
Self
;
const
ALL
:
Self
;
}
macro_rules
!
memory
{
(
(
t
:
ty
)
+
(
)
?
)
=
>
{
(
impl
BitMemory
for
t
{
const
ONE
:
Self
=
1
;
const
ALL
:
Self
=
!
0
;
}
impl
seal
:
:
Sealed
for
t
{
}
)
+
}
;
}
memory
!
(
u8
u16
u32
u64
u128
usize
)
;
#
[
doc
(
hidden
)
]
pub
const
fn
elts
<
T
>
(
bits
:
usize
)
-
>
usize
{
let
width
=
mem
:
:
size_of
:
:
<
T
>
(
)
*
8
;
bits
/
width
+
(
bits
%
width
!
=
0
)
as
usize
}
#
[
doc
(
hidden
)
]
pub
(
crate
)
const
fn
aligned_to_size
<
T
>
(
)
-
>
usize
{
(
mem
:
:
align_of
:
:
<
T
>
(
)
!
=
mem
:
:
size_of
:
:
<
T
>
(
)
)
as
usize
}
#
[
doc
(
hidden
)
]
pub
(
crate
)
const
fn
cmp_layout
<
A
B
>
(
)
-
>
usize
{
(
mem
:
:
align_of
:
:
<
A
>
(
)
!
=
mem
:
:
align_of
:
:
<
B
>
(
)
)
as
usize
+
(
mem
:
:
size_of
:
:
<
A
>
(
)
!
=
mem
:
:
size_of
:
:
<
B
>
(
)
)
as
usize
}
#
[
doc
(
hidden
)
]
mod
seal
{
#
[
doc
(
hidden
)
]
pub
trait
Sealed
{
}
}
