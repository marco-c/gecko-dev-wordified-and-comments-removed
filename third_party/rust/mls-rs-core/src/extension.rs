use
core
:
:
{
fmt
:
:
{
self
Debug
}
ops
:
:
Deref
}
;
use
crate
:
:
error
:
:
{
AnyError
IntoAnyError
}
;
use
alloc
:
:
vec
:
:
Vec
;
use
mls_rs_codec
:
:
{
MlsDecode
MlsEncode
MlsSize
}
;
mod
list
;
pub
use
list
:
:
*
;
#
[
derive
(
Debug
PartialEq
Eq
Hash
Clone
Copy
PartialOrd
Ord
MlsSize
MlsEncode
MlsDecode
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
arbitrary
:
:
Arbitrary
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
repr
(
transparent
)
]
pub
struct
ExtensionType
(
u16
)
;
impl
ExtensionType
{
pub
const
APPLICATION_ID
:
ExtensionType
=
ExtensionType
(
1
)
;
pub
const
RATCHET_TREE
:
ExtensionType
=
ExtensionType
(
2
)
;
pub
const
REQUIRED_CAPABILITIES
:
ExtensionType
=
ExtensionType
(
3
)
;
pub
const
EXTERNAL_PUB
:
ExtensionType
=
ExtensionType
(
4
)
;
pub
const
EXTERNAL_SENDERS
:
ExtensionType
=
ExtensionType
(
5
)
;
#
[
cfg
(
feature
=
"
last_resort_key_package_ext
"
)
]
pub
const
LAST_RESORT_KEY_PACKAGE
:
ExtensionType
=
ExtensionType
(
0x000A
)
;
pub
const
DEFAULT
:
&
'
static
[
ExtensionType
]
=
&
[
ExtensionType
:
:
APPLICATION_ID
ExtensionType
:
:
RATCHET_TREE
ExtensionType
:
:
REQUIRED_CAPABILITIES
ExtensionType
:
:
EXTERNAL_PUB
ExtensionType
:
:
EXTERNAL_SENDERS
]
;
pub
const
fn
new
(
raw_value
:
u16
)
-
>
Self
{
ExtensionType
(
raw_value
)
}
pub
const
fn
raw_value
(
&
self
)
-
>
u16
{
self
.
0
}
pub
const
fn
is_default
(
&
self
)
-
>
bool
{
self
.
0
<
=
5
}
}
impl
From
<
u16
>
for
ExtensionType
{
fn
from
(
value
:
u16
)
-
>
Self
{
ExtensionType
(
value
)
}
}
impl
Deref
for
ExtensionType
{
type
Target
=
u16
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
std
"
derive
(
thiserror
:
:
Error
)
)
]
pub
enum
ExtensionError
{
#
[
cfg_attr
(
feature
=
"
std
"
error
(
transparent
)
)
]
SerializationError
(
AnyError
)
#
[
cfg_attr
(
feature
=
"
std
"
error
(
transparent
)
)
]
DeserializationError
(
AnyError
)
#
[
cfg_attr
(
feature
=
"
std
"
error
(
"
incorrect
extension
type
:
{
0
:
?
}
"
)
)
]
IncorrectType
(
ExtensionType
)
}
impl
IntoAnyError
for
ExtensionError
{
#
[
cfg
(
feature
=
"
std
"
)
]
fn
into_dyn_error
(
self
)
-
>
Result
<
Box
<
dyn
std
:
:
error
:
:
Error
+
Send
+
Sync
>
Self
>
{
Ok
(
self
.
into
(
)
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
MlsSize
MlsEncode
MlsDecode
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
arbitrary
:
:
Arbitrary
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
struct
Extension
{
pub
extension_type
:
ExtensionType
#
[
mls_codec
(
with
=
"
mls_rs_codec
:
:
byte_vec
"
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
with
=
"
crate
:
:
vec_serde
"
)
)
]
pub
extension_data
:
Vec
<
u8
>
}
impl
Debug
for
Extension
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Extension
"
)
.
field
(
"
extension_type
"
&
self
.
extension_type
)
.
field
(
"
extension_data
"
&
crate
:
:
debug
:
:
pretty_bytes
(
&
self
.
extension_data
)
)
.
finish
(
)
}
}
impl
Extension
{
pub
fn
new
(
extension_type
:
ExtensionType
extension_data
:
Vec
<
u8
>
)
-
>
Extension
{
Extension
{
extension_type
extension_data
}
}
#
[
cfg
(
feature
=
"
ffi
"
)
]
pub
fn
extension_type
(
&
self
)
-
>
ExtensionType
{
self
.
extension_type
}
#
[
cfg
(
feature
=
"
ffi
"
)
]
pub
fn
extension_data
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
extension_data
}
}
pub
trait
MlsExtension
:
Sized
{
type
SerializationError
:
IntoAnyError
;
type
DeserializationError
:
IntoAnyError
;
fn
extension_type
(
)
-
>
ExtensionType
;
fn
to_bytes
(
&
self
)
-
>
Result
<
Vec
<
u8
>
Self
:
:
SerializationError
>
;
fn
from_bytes
(
data
:
&
[
u8
]
)
-
>
Result
<
Self
Self
:
:
DeserializationError
>
;
fn
into_extension
(
self
)
-
>
Result
<
Extension
ExtensionError
>
{
Ok
(
Extension
:
:
new
(
Self
:
:
extension_type
(
)
self
.
to_bytes
(
)
.
map_err
(
|
e
|
ExtensionError
:
:
SerializationError
(
e
.
into_any_error
(
)
)
)
?
)
)
}
fn
from_extension
(
ext
:
&
Extension
)
-
>
Result
<
Self
ExtensionError
>
{
if
ext
.
extension_type
!
=
Self
:
:
extension_type
(
)
{
return
Err
(
ExtensionError
:
:
IncorrectType
(
ext
.
extension_type
)
)
;
}
Self
:
:
from_bytes
(
&
ext
.
extension_data
)
.
map_err
(
|
e
|
ExtensionError
:
:
DeserializationError
(
e
.
into_any_error
(
)
)
)
}
}
pub
trait
MlsCodecExtension
:
MlsSize
+
MlsEncode
+
MlsDecode
{
fn
extension_type
(
)
-
>
ExtensionType
;
}
impl
<
T
>
MlsExtension
for
T
where
T
:
MlsCodecExtension
{
type
SerializationError
=
mls_rs_codec
:
:
Error
;
type
DeserializationError
=
mls_rs_codec
:
:
Error
;
fn
extension_type
(
)
-
>
ExtensionType
{
<
Self
as
MlsCodecExtension
>
:
:
extension_type
(
)
}
fn
to_bytes
(
&
self
)
-
>
Result
<
Vec
<
u8
>
Self
:
:
SerializationError
>
{
self
.
mls_encode_to_vec
(
)
}
fn
from_bytes
(
data
:
&
[
u8
]
)
-
>
Result
<
Self
Self
:
:
DeserializationError
>
{
Self
:
:
mls_decode
(
&
mut
&
*
data
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
core
:
:
convert
:
:
Infallible
;
use
alloc
:
:
vec
;
use
alloc
:
:
vec
:
:
Vec
;
use
assert_matches
:
:
assert_matches
;
use
mls_rs_codec
:
:
{
MlsDecode
MlsEncode
MlsSize
}
;
use
super
:
:
{
Extension
ExtensionError
ExtensionType
MlsCodecExtension
MlsExtension
}
;
struct
TestExtension
;
#
[
derive
(
Debug
MlsSize
MlsEncode
MlsDecode
)
]
struct
AnotherTestExtension
;
impl
MlsExtension
for
TestExtension
{
type
SerializationError
=
Infallible
;
type
DeserializationError
=
Infallible
;
fn
extension_type
(
)
-
>
super
:
:
ExtensionType
{
ExtensionType
(
42
)
}
fn
to_bytes
(
&
self
)
-
>
Result
<
Vec
<
u8
>
Self
:
:
SerializationError
>
{
Ok
(
vec
!
[
0
]
)
}
fn
from_bytes
(
_data
:
&
[
u8
]
)
-
>
Result
<
Self
Self
:
:
DeserializationError
>
{
Ok
(
TestExtension
)
}
}
impl
MlsCodecExtension
for
AnotherTestExtension
{
fn
extension_type
(
)
-
>
ExtensionType
{
ExtensionType
(
43
)
}
}
#
[
test
]
fn
into_extension
(
)
{
assert_eq
!
(
TestExtension
.
into_extension
(
)
.
unwrap
(
)
Extension
:
:
new
(
42
.
into
(
)
vec
!
[
0
]
)
)
}
#
[
test
]
fn
incorrect_type_is_discovered
(
)
{
let
ext
=
Extension
:
:
new
(
42
.
into
(
)
vec
!
[
0
]
)
;
assert_matches
!
(
AnotherTestExtension
:
:
from_extension
(
&
ext
)
Err
(
ExtensionError
:
:
IncorrectType
(
found
)
)
if
found
=
=
42
.
into
(
)
)
;
}
}
