use
std
:
:
{
cmp
fmt
str
}
;
use
std
:
:
str
:
:
FromStr
;
use
bytes
:
:
Bytes
;
use
byte_str
:
:
ByteStr
;
use
super
:
:
{
ErrorKind
InvalidUri
InvalidUriBytes
URI_CHARS
}
;
#
[
derive
(
Clone
)
]
pub
struct
PathAndQuery
{
pub
(
super
)
data
:
ByteStr
pub
(
super
)
query
:
u16
}
const
NONE
:
u16
=
:
:
std
:
:
u16
:
:
MAX
;
impl
PathAndQuery
{
pub
fn
from_shared
(
mut
src
:
Bytes
)
-
>
Result
<
Self
InvalidUriBytes
>
{
let
mut
query
=
NONE
;
let
mut
i
=
0
;
while
i
<
src
.
len
(
)
{
let
b
=
src
[
i
]
;
match
URI_CHARS
[
b
as
usize
]
{
0
=
>
{
if
b
=
=
b
'
%
'
{
if
i
+
2
<
=
src
.
len
(
)
&
&
b
'
%
'
=
=
src
[
i
+
1
]
{
break
;
}
let
perc_encoded
=
i
+
3
<
=
src
.
len
(
)
&
&
HEX_DIGIT
[
src
[
i
+
1
]
as
usize
]
!
=
0
&
&
HEX_DIGIT
[
src
[
i
+
2
]
as
usize
]
!
=
0
;
if
!
perc_encoded
{
return
Err
(
ErrorKind
:
:
InvalidUriChar
.
into
(
)
)
;
}
i
+
=
3
;
continue
;
}
else
{
return
Err
(
ErrorKind
:
:
InvalidUriChar
.
into
(
)
)
;
}
}
b
'
?
'
=
>
{
if
query
=
=
NONE
{
query
=
i
as
u16
;
}
}
b
'
#
'
=
>
{
src
.
split_off
(
i
)
;
break
;
}
_
=
>
{
}
}
i
+
=
1
;
}
Ok
(
PathAndQuery
{
data
:
unsafe
{
ByteStr
:
:
from_utf8_unchecked
(
src
)
}
query
:
query
}
)
}
#
[
inline
]
pub
fn
from_static
(
src
:
&
'
static
str
)
-
>
Self
{
let
src
=
Bytes
:
:
from_static
(
src
.
as_bytes
(
)
)
;
PathAndQuery
:
:
from_shared
(
src
)
.
unwrap
(
)
}
pub
(
super
)
fn
empty
(
)
-
>
Self
{
PathAndQuery
{
data
:
ByteStr
:
:
new
(
)
query
:
NONE
}
}
pub
(
super
)
fn
slash
(
)
-
>
Self
{
PathAndQuery
{
data
:
ByteStr
:
:
from_static
(
"
/
"
)
query
:
NONE
}
}
pub
(
super
)
fn
star
(
)
-
>
Self
{
PathAndQuery
{
data
:
ByteStr
:
:
from_static
(
"
*
"
)
query
:
NONE
}
}
#
[
inline
]
pub
fn
path
(
&
self
)
-
>
&
str
{
let
ret
=
if
self
.
query
=
=
NONE
{
&
self
.
data
[
.
.
]
}
else
{
&
self
.
data
[
.
.
self
.
query
as
usize
]
}
;
if
ret
.
is_empty
(
)
{
return
"
/
"
;
}
ret
}
#
[
inline
]
pub
fn
query
(
&
self
)
-
>
Option
<
&
str
>
{
if
self
.
query
=
=
NONE
{
None
}
else
{
let
i
=
self
.
query
+
1
;
Some
(
&
self
.
data
[
i
as
usize
.
.
]
)
}
}
#
[
inline
]
pub
fn
as_str
(
&
self
)
-
>
&
str
{
let
ret
=
&
self
.
data
[
.
.
]
;
if
ret
.
is_empty
(
)
{
return
"
/
"
;
}
ret
}
#
[
inline
]
pub
fn
into_bytes
(
self
)
-
>
Bytes
{
self
.
into
(
)
}
}
impl
FromStr
for
PathAndQuery
{
type
Err
=
InvalidUri
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
InvalidUri
>
{
PathAndQuery
:
:
from_shared
(
s
.
into
(
)
)
.
map_err
(
|
e
|
e
.
0
)
}
}
impl
From
<
PathAndQuery
>
for
Bytes
{
fn
from
(
src
:
PathAndQuery
)
-
>
Bytes
{
src
.
data
.
into
(
)
}
}
impl
fmt
:
:
Debug
for
PathAndQuery
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
PathAndQuery
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
!
self
.
data
.
is_empty
(
)
{
match
self
.
data
.
as_bytes
(
)
[
0
]
{
b
'
/
'
|
b
'
*
'
=
>
write
!
(
fmt
"
{
}
"
&
self
.
data
[
.
.
]
)
_
=
>
write
!
(
fmt
"
/
{
}
"
&
self
.
data
[
.
.
]
)
}
}
else
{
write
!
(
fmt
"
/
"
)
}
}
}
impl
PartialEq
for
PathAndQuery
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
PathAndQuery
)
-
>
bool
{
self
.
data
=
=
other
.
data
}
}
impl
Eq
for
PathAndQuery
{
}
impl
PartialEq
<
str
>
for
PathAndQuery
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
self
.
as_str
(
)
=
=
other
}
}
impl
<
'
a
>
PartialEq
<
PathAndQuery
>
for
&
'
a
str
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
PathAndQuery
)
-
>
bool
{
self
=
=
&
other
.
as_str
(
)
}
}
impl
<
'
a
>
PartialEq
<
&
'
a
str
>
for
PathAndQuery
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
&
'
a
str
)
-
>
bool
{
self
.
as_str
(
)
=
=
*
other
}
}
impl
PartialEq
<
PathAndQuery
>
for
str
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
PathAndQuery
)
-
>
bool
{
self
=
=
other
.
as_str
(
)
}
}
impl
PartialEq
<
String
>
for
PathAndQuery
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
String
)
-
>
bool
{
self
.
as_str
(
)
=
=
other
.
as_str
(
)
}
}
impl
PartialEq
<
PathAndQuery
>
for
String
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
PathAndQuery
)
-
>
bool
{
self
.
as_str
(
)
=
=
other
.
as_str
(
)
}
}
impl
PartialOrd
for
PathAndQuery
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
PathAndQuery
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
as_str
(
)
.
partial_cmp
(
other
.
as_str
(
)
)
}
}
impl
PartialOrd
<
str
>
for
PathAndQuery
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
str
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
as_str
(
)
.
partial_cmp
(
other
)
}
}
impl
PartialOrd
<
PathAndQuery
>
for
str
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
PathAndQuery
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
partial_cmp
(
other
.
as_str
(
)
)
}
}
impl
<
'
a
>
PartialOrd
<
&
'
a
str
>
for
PathAndQuery
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
&
'
a
str
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
as_str
(
)
.
partial_cmp
(
*
other
)
}
}
impl
<
'
a
>
PartialOrd
<
PathAndQuery
>
for
&
'
a
str
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
PathAndQuery
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
partial_cmp
(
&
other
.
as_str
(
)
)
}
}
impl
PartialOrd
<
String
>
for
PathAndQuery
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
String
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
as_str
(
)
.
partial_cmp
(
other
.
as_str
(
)
)
}
}
impl
PartialOrd
<
PathAndQuery
>
for
String
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
PathAndQuery
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
as_str
(
)
.
partial_cmp
(
other
.
as_str
(
)
)
}
}
const
HEX_DIGIT
:
[
u8
;
256
]
=
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
b
'
0
'
b
'
1
'
b
'
2
'
b
'
3
'
b
'
4
'
b
'
5
'
b
'
6
'
b
'
7
'
b
'
8
'
b
'
9
'
0
0
0
0
0
0
0
b
'
A
'
b
'
B
'
b
'
C
'
b
'
D
'
b
'
E
'
b
'
F
'
b
'
G
'
b
'
H
'
b
'
I
'
b
'
J
'
b
'
K
'
b
'
L
'
b
'
M
'
b
'
N
'
b
'
O
'
b
'
P
'
b
'
Q
'
b
'
R
'
b
'
S
'
b
'
T
'
b
'
U
'
b
'
V
'
b
'
W
'
b
'
X
'
b
'
Y
'
b
'
Z
'
0
0
0
0
0
0
b
'
a
'
b
'
b
'
b
'
c
'
b
'
d
'
b
'
e
'
b
'
f
'
b
'
g
'
b
'
h
'
b
'
i
'
b
'
j
'
b
'
k
'
b
'
l
'
b
'
m
'
b
'
n
'
b
'
o
'
b
'
p
'
b
'
q
'
b
'
r
'
b
'
s
'
b
'
t
'
b
'
u
'
b
'
v
'
b
'
w
'
b
'
x
'
b
'
y
'
b
'
z
'
0
0
0
b
'
~
'
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
equal_to_self_of_same_path
(
)
{
let
p1
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
let
p2
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert_eq
!
(
p1
p2
)
;
assert_eq
!
(
p2
p1
)
;
}
#
[
test
]
fn
not_equal_to_self_of_different_path
(
)
{
let
p1
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
let
p2
:
PathAndQuery
=
"
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert_ne
!
(
p1
p2
)
;
assert_ne
!
(
p2
p1
)
;
}
#
[
test
]
fn
equates_with_a_str
(
)
{
let
path_and_query
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert_eq
!
(
&
path_and_query
"
/
hello
/
world
&
foo
=
bar
"
)
;
assert_eq
!
(
"
/
hello
/
world
&
foo
=
bar
"
&
path_and_query
)
;
assert_eq
!
(
path_and_query
"
/
hello
/
world
&
foo
=
bar
"
)
;
assert_eq
!
(
"
/
hello
/
world
&
foo
=
bar
"
path_and_query
)
;
}
#
[
test
]
fn
not_equal_with_a_str_of_a_different_path
(
)
{
let
path_and_query
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert_ne
!
(
&
path_and_query
"
/
hello
&
foo
=
bar
"
)
;
assert_ne
!
(
"
/
hello
&
foo
=
bar
"
&
path_and_query
)
;
assert_ne
!
(
path_and_query
"
/
hello
&
foo
=
bar
"
)
;
assert_ne
!
(
"
/
hello
&
foo
=
bar
"
path_and_query
)
;
}
#
[
test
]
fn
equates_with_a_string
(
)
{
let
path_and_query
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert_eq
!
(
path_and_query
"
/
hello
/
world
&
foo
=
bar
"
.
to_string
(
)
)
;
assert_eq
!
(
"
/
hello
/
world
&
foo
=
bar
"
.
to_string
(
)
path_and_query
)
;
}
#
[
test
]
fn
not_equal_with_a_string_of_a_different_path
(
)
{
let
path_and_query
:
PathAndQuery
=
"
/
hello
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert_ne
!
(
path_and_query
"
/
hello
&
foo
=
bar
"
.
to_string
(
)
)
;
assert_ne
!
(
"
/
hello
&
foo
=
bar
"
.
to_string
(
)
path_and_query
)
;
}
#
[
test
]
fn
compares_to_self
(
)
{
let
p1
:
PathAndQuery
=
"
/
a
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
let
p2
:
PathAndQuery
=
"
/
b
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert
!
(
p1
<
p2
)
;
assert
!
(
p2
>
p1
)
;
}
#
[
test
]
fn
compares_with_a_str
(
)
{
let
path_and_query
:
PathAndQuery
=
"
/
b
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert
!
(
&
path_and_query
<
"
/
c
/
world
&
foo
=
bar
"
)
;
assert
!
(
"
/
c
/
world
&
foo
=
bar
"
>
&
path_and_query
)
;
assert
!
(
&
path_and_query
>
"
/
a
/
world
&
foo
=
bar
"
)
;
assert
!
(
"
/
a
/
world
&
foo
=
bar
"
<
&
path_and_query
)
;
assert
!
(
path_and_query
<
"
/
c
/
world
&
foo
=
bar
"
)
;
assert
!
(
"
/
c
/
world
&
foo
=
bar
"
>
path_and_query
)
;
assert
!
(
path_and_query
>
"
/
a
/
world
&
foo
=
bar
"
)
;
assert
!
(
"
/
a
/
world
&
foo
=
bar
"
<
path_and_query
)
;
}
#
[
test
]
fn
compares_with_a_string
(
)
{
let
path_and_query
:
PathAndQuery
=
"
/
b
/
world
&
foo
=
bar
"
.
parse
(
)
.
unwrap
(
)
;
assert
!
(
path_and_query
<
"
/
c
/
world
&
foo
=
bar
"
.
to_string
(
)
)
;
assert
!
(
"
/
c
/
world
&
foo
=
bar
"
.
to_string
(
)
>
path_and_query
)
;
assert
!
(
path_and_query
>
"
/
a
/
world
&
foo
=
bar
"
.
to_string
(
)
)
;
assert
!
(
"
/
a
/
world
&
foo
=
bar
"
.
to_string
(
)
<
path_and_query
)
;
}
#
[
test
]
fn
double_percent_path
(
)
{
let
double_percent_path
=
"
/
your
.
js
?
bn
=
%
%
val
"
;
assert
!
(
double_percent_path
.
parse
:
:
<
PathAndQuery
>
(
)
.
is_ok
(
)
)
;
let
path
:
PathAndQuery
=
double_percent_path
.
parse
(
)
.
unwrap
(
)
;
assert_eq
!
(
path
double_percent_path
)
;
let
double_percent_path
=
"
/
path
%
%
"
;
assert
!
(
double_percent_path
.
parse
:
:
<
PathAndQuery
>
(
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
path_ends_with_question_mark
(
)
{
let
path
=
"
/
path
?
%
"
;
assert
!
(
path
.
parse
:
:
<
PathAndQuery
>
(
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
path_ends_with_fragment_percent
(
)
{
let
path
=
"
/
path
#
%
"
;
assert
!
(
path
.
parse
:
:
<
PathAndQuery
>
(
)
.
is_ok
(
)
)
;
}
}
