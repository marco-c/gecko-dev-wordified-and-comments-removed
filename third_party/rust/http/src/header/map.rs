use
super
:
:
HeaderValue
;
use
super
:
:
name
:
:
{
HeaderName
HdrName
InvalidHeaderName
}
;
use
std
:
:
{
fmt
mem
ops
ptr
vec
}
;
use
std
:
:
collections
:
:
hash_map
:
:
RandomState
;
use
std
:
:
hash
:
:
{
BuildHasher
Hasher
Hash
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
marker
:
:
PhantomData
;
pub
use
self
:
:
as_header_name
:
:
AsHeaderName
;
pub
use
self
:
:
into_header_name
:
:
IntoHeaderName
;
#
[
derive
(
Clone
)
]
pub
struct
HeaderMap
<
T
=
HeaderValue
>
{
mask
:
Size
indices
:
Box
<
[
Pos
]
>
entries
:
Vec
<
Bucket
<
T
>
>
extra_values
:
Vec
<
ExtraValue
<
T
>
>
danger
:
Danger
}
#
[
derive
(
Debug
)
]
pub
struct
Iter
<
'
a
T
:
'
a
>
{
inner
:
IterMut
<
'
a
T
>
}
#
[
derive
(
Debug
)
]
pub
struct
IterMut
<
'
a
T
:
'
a
>
{
map
:
*
mut
HeaderMap
<
T
>
entry
:
usize
cursor
:
Option
<
Cursor
>
lt
:
PhantomData
<
&
'
a
mut
HeaderMap
<
T
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
IntoIter
<
T
>
{
next
:
Option
<
usize
>
entries
:
vec
:
:
IntoIter
<
Bucket
<
T
>
>
extra_values
:
Vec
<
ExtraValue
<
T
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
Keys
<
'
a
T
:
'
a
>
{
inner
:
:
:
std
:
:
slice
:
:
Iter
<
'
a
Bucket
<
T
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
Values
<
'
a
T
:
'
a
>
{
inner
:
Iter
<
'
a
T
>
}
#
[
derive
(
Debug
)
]
pub
struct
ValuesMut
<
'
a
T
:
'
a
>
{
inner
:
IterMut
<
'
a
T
>
}
#
[
derive
(
Debug
)
]
pub
struct
Drain
<
'
a
T
:
'
a
>
{
idx
:
usize
map
:
*
mut
HeaderMap
<
T
>
lt
:
PhantomData
<
&
'
a
mut
HeaderMap
<
T
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
GetAll
<
'
a
T
:
'
a
>
{
map
:
&
'
a
HeaderMap
<
T
>
index
:
Option
<
usize
>
}
#
[
derive
(
Debug
)
]
pub
enum
Entry
<
'
a
T
:
'
a
>
{
Occupied
(
OccupiedEntry
<
'
a
T
>
)
Vacant
(
VacantEntry
<
'
a
T
>
)
}
#
[
derive
(
Debug
)
]
pub
struct
VacantEntry
<
'
a
T
:
'
a
>
{
map
:
&
'
a
mut
HeaderMap
<
T
>
key
:
HeaderName
hash
:
HashValue
probe
:
usize
danger
:
bool
}
#
[
derive
(
Debug
)
]
pub
struct
OccupiedEntry
<
'
a
T
:
'
a
>
{
map
:
&
'
a
mut
HeaderMap
<
T
>
probe
:
usize
index
:
usize
}
#
[
derive
(
Debug
)
]
pub
struct
ValueIter
<
'
a
T
:
'
a
>
{
map
:
&
'
a
HeaderMap
<
T
>
index
:
usize
front
:
Option
<
Cursor
>
back
:
Option
<
Cursor
>
}
#
[
derive
(
Debug
)
]
pub
struct
ValueIterMut
<
'
a
T
:
'
a
>
{
map
:
*
mut
HeaderMap
<
T
>
index
:
usize
front
:
Option
<
Cursor
>
back
:
Option
<
Cursor
>
lt
:
PhantomData
<
&
'
a
mut
HeaderMap
<
T
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
ValueDrain
<
'
a
T
:
'
a
>
{
map
:
*
mut
HeaderMap
<
T
>
first
:
Option
<
T
>
next
:
Option
<
usize
>
lt
:
PhantomData
<
&
'
a
mut
HeaderMap
<
T
>
>
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
enum
Cursor
{
Head
Values
(
usize
)
}
type
Size
=
usize
;
const
MAX_SIZE
:
usize
=
(
1
<
<
15
)
;
#
[
derive
(
Copy
Clone
)
]
struct
Pos
{
index
:
Size
hash
:
HashValue
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
struct
HashValue
(
usize
)
;
#
[
derive
(
Debug
Clone
)
]
struct
Bucket
<
T
>
{
hash
:
HashValue
key
:
HeaderName
value
:
T
links
:
Option
<
Links
>
}
#
[
derive
(
Debug
Copy
Clone
)
]
struct
Links
{
next
:
usize
tail
:
usize
}
#
[
derive
(
Debug
Clone
)
]
struct
ExtraValue
<
T
>
{
value
:
T
prev
:
Link
next
:
Link
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
enum
Link
{
Entry
(
usize
)
Extra
(
usize
)
}
#
[
derive
(
Clone
)
]
enum
Danger
{
Green
Yellow
Red
(
RandomState
)
}
const
DISPLACEMENT_THRESHOLD
:
usize
=
128
;
const
FORWARD_SHIFT_THRESHOLD
:
usize
=
512
;
const
LOAD_FACTOR_THRESHOLD
:
f32
=
0
.
2
;
macro_rules
!
probe_loop
{
(
label
:
tt
:
probe_var
:
ident
<
len
:
expr
body
:
expr
)
=
>
{
debug_assert
!
(
len
>
0
)
;
label
:
loop
{
if
probe_var
<
len
{
body
probe_var
+
=
1
;
}
else
{
probe_var
=
0
;
}
}
}
;
(
probe_var
:
ident
<
len
:
expr
body
:
expr
)
=
>
{
debug_assert
!
(
len
>
0
)
;
loop
{
if
probe_var
<
len
{
body
probe_var
+
=
1
;
}
else
{
probe_var
=
0
;
}
}
}
;
}
macro_rules
!
insert_phase_one
{
(
map
:
ident
key
:
expr
probe
:
ident
pos
:
ident
hash
:
ident
danger
:
ident
vacant
:
expr
occupied
:
expr
robinhood
:
expr
)
=
>
{
{
let
hash
=
hash_elem_using
(
&
map
.
danger
&
key
)
;
let
mut
probe
=
desired_pos
(
map
.
mask
hash
)
;
let
mut
dist
=
0
;
let
ret
;
/
/
Start
at
the
ideal
position
checking
all
slots
probe_loop
!
(
'
probe
:
probe
<
map
.
indices
.
len
(
)
{
if
let
Some
(
(
pos
entry_hash
)
)
=
map
.
indices
[
probe
]
.
resolve
(
)
{
/
/
The
slot
is
already
occupied
but
check
if
it
has
a
lower
/
/
displacement
.
let
their_dist
=
probe_distance
(
map
.
mask
entry_hash
probe
)
;
if
their_dist
<
dist
{
/
/
The
new
key
'
s
distance
is
larger
so
claim
this
spot
and
/
/
displace
the
current
entry
.
/
/
/
/
Check
if
this
insertion
is
above
the
danger
threshold
.
let
danger
=
dist
>
=
FORWARD_SHIFT_THRESHOLD
&
&
!
map
.
danger
.
is_red
(
)
;
ret
=
robinhood
;
break
'
probe
;
}
else
if
entry_hash
=
=
hash
&
&
map
.
entries
[
pos
]
.
key
=
=
key
{
/
/
There
already
is
an
entry
with
the
same
key
.
ret
=
occupied
;
break
'
probe
;
}
}
else
{
/
/
The
entry
is
vacant
use
it
for
this
key
.
let
danger
=
dist
>
=
FORWARD_SHIFT_THRESHOLD
&
&
!
map
.
danger
.
is_red
(
)
;
ret
=
vacant
;
break
'
probe
;
}
dist
+
=
1
;
}
)
;
ret
}
}
}
impl
HeaderMap
{
pub
fn
new
(
)
-
>
Self
{
HeaderMap
:
:
with_capacity
(
0
)
}
}
impl
<
T
>
HeaderMap
<
T
>
{
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
HeaderMap
<
T
>
{
assert
!
(
capacity
<
=
MAX_SIZE
"
requested
capacity
too
large
"
)
;
if
capacity
=
=
0
{
HeaderMap
{
mask
:
0
indices
:
Box
:
:
new
(
[
]
)
entries
:
Vec
:
:
new
(
)
extra_values
:
Vec
:
:
new
(
)
danger
:
Danger
:
:
Green
}
}
else
{
let
raw_cap
=
to_raw_capacity
(
capacity
)
.
next_power_of_two
(
)
;
debug_assert
!
(
raw_cap
>
0
)
;
HeaderMap
{
mask
:
(
raw_cap
-
1
)
as
Size
indices
:
vec
!
[
Pos
:
:
none
(
)
;
raw_cap
]
.
into_boxed_slice
(
)
entries
:
Vec
:
:
with_capacity
(
raw_cap
)
extra_values
:
Vec
:
:
new
(
)
danger
:
Danger
:
:
Green
}
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
+
self
.
extra_values
.
len
(
)
}
pub
fn
keys_len
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
entries
.
len
(
)
=
=
0
}
pub
fn
clear
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
self
.
extra_values
.
clear
(
)
;
self
.
danger
=
Danger
:
:
Green
;
for
e
in
self
.
indices
.
iter_mut
(
)
{
*
e
=
Pos
:
:
none
(
)
;
}
}
pub
fn
capacity
(
&
self
)
-
>
usize
{
usable_capacity
(
self
.
indices
.
len
(
)
)
}
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
let
cap
=
self
.
entries
.
len
(
)
.
checked_add
(
additional
)
.
expect
(
"
reserve
overflow
"
)
;
if
cap
>
self
.
indices
.
len
(
)
{
let
cap
=
cap
.
next_power_of_two
(
)
;
if
self
.
entries
.
len
(
)
=
=
0
{
self
.
mask
=
cap
-
1
;
self
.
indices
=
vec
!
[
Pos
:
:
none
(
)
;
cap
]
.
into_boxed_slice
(
)
;
self
.
entries
=
Vec
:
:
with_capacity
(
usable_capacity
(
cap
)
)
;
}
else
{
self
.
grow
(
cap
)
;
}
}
}
pub
fn
get
<
K
>
(
&
self
key
:
K
)
-
>
Option
<
&
T
>
where
K
:
AsHeaderName
{
self
.
get2
(
&
key
)
}
fn
get2
<
K
>
(
&
self
key
:
&
K
)
-
>
Option
<
&
T
>
where
K
:
AsHeaderName
{
match
key
.
find
(
self
)
{
Some
(
(
_
found
)
)
=
>
{
let
entry
=
&
self
.
entries
[
found
]
;
Some
(
&
entry
.
value
)
}
None
=
>
None
}
}
pub
fn
get_mut
<
K
>
(
&
mut
self
key
:
K
)
-
>
Option
<
&
mut
T
>
where
K
:
AsHeaderName
{
match
key
.
find
(
self
)
{
Some
(
(
_
found
)
)
=
>
{
let
entry
=
&
mut
self
.
entries
[
found
]
;
Some
(
&
mut
entry
.
value
)
}
None
=
>
None
}
}
pub
fn
get_all
<
K
>
(
&
self
key
:
K
)
-
>
GetAll
<
T
>
where
K
:
AsHeaderName
{
GetAll
{
map
:
self
index
:
key
.
find
(
self
)
.
map
(
|
(
_
i
)
|
i
)
}
}
pub
fn
contains_key
<
K
>
(
&
self
key
:
K
)
-
>
bool
where
K
:
AsHeaderName
{
key
.
find
(
self
)
.
is_some
(
)
}
pub
fn
iter
(
&
self
)
-
>
Iter
<
T
>
{
Iter
{
inner
:
IterMut
{
map
:
self
as
*
const
_
as
*
mut
_
entry
:
0
cursor
:
self
.
entries
.
first
(
)
.
map
(
|
_
|
Cursor
:
:
Head
)
lt
:
PhantomData
}
}
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
IterMut
<
T
>
{
IterMut
{
map
:
self
as
*
mut
_
entry
:
0
cursor
:
self
.
entries
.
first
(
)
.
map
(
|
_
|
Cursor
:
:
Head
)
lt
:
PhantomData
}
}
pub
fn
keys
(
&
self
)
-
>
Keys
<
T
>
{
Keys
{
inner
:
self
.
entries
.
iter
(
)
}
}
pub
fn
values
(
&
self
)
-
>
Values
<
T
>
{
Values
{
inner
:
self
.
iter
(
)
}
}
pub
fn
values_mut
(
&
mut
self
)
-
>
ValuesMut
<
T
>
{
ValuesMut
{
inner
:
self
.
iter_mut
(
)
}
}
pub
fn
drain
(
&
mut
self
)
-
>
Drain
<
T
>
{
for
i
in
self
.
indices
.
iter_mut
(
)
{
*
i
=
Pos
:
:
none
(
)
;
}
Drain
{
idx
:
0
map
:
self
as
*
mut
_
lt
:
PhantomData
}
}
fn
value_iter
(
&
self
idx
:
Option
<
usize
>
)
-
>
ValueIter
<
T
>
{
use
self
:
:
Cursor
:
:
*
;
if
let
Some
(
idx
)
=
idx
{
let
back
=
{
let
entry
=
&
self
.
entries
[
idx
]
;
entry
.
links
.
map
(
|
l
|
Values
(
l
.
tail
)
)
.
unwrap_or
(
Head
)
}
;
ValueIter
{
map
:
self
index
:
idx
front
:
Some
(
Head
)
back
:
Some
(
back
)
}
}
else
{
ValueIter
{
map
:
self
index
:
:
:
std
:
:
usize
:
:
MAX
front
:
None
back
:
None
}
}
}
fn
value_iter_mut
(
&
mut
self
idx
:
usize
)
-
>
ValueIterMut
<
T
>
{
use
self
:
:
Cursor
:
:
*
;
let
back
=
{
let
entry
=
&
self
.
entries
[
idx
]
;
entry
.
links
.
map
(
|
l
|
Values
(
l
.
tail
)
)
.
unwrap_or
(
Head
)
}
;
ValueIterMut
{
map
:
self
as
*
mut
_
index
:
idx
front
:
Some
(
Head
)
back
:
Some
(
back
)
lt
:
PhantomData
}
}
pub
fn
entry
<
K
>
(
&
mut
self
key
:
K
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
where
K
:
AsHeaderName
{
key
.
entry
(
self
)
}
fn
entry2
<
K
>
(
&
mut
self
key
:
K
)
-
>
Entry
<
T
>
where
K
:
Hash
+
Into
<
HeaderName
>
HeaderName
:
PartialEq
<
K
>
{
self
.
reserve_one
(
)
;
insert_phase_one
!
(
self
key
probe
pos
hash
danger
Entry
:
:
Vacant
(
VacantEntry
{
map
:
self
hash
:
hash
key
:
key
.
into
(
)
probe
:
probe
danger
:
danger
}
)
Entry
:
:
Occupied
(
OccupiedEntry
{
map
:
self
index
:
pos
probe
:
probe
}
)
Entry
:
:
Vacant
(
VacantEntry
{
map
:
self
hash
:
hash
key
:
key
.
into
(
)
probe
:
probe
danger
:
danger
}
)
)
}
pub
fn
insert
<
K
>
(
&
mut
self
key
:
K
val
:
T
)
-
>
Option
<
T
>
where
K
:
IntoHeaderName
{
key
.
insert
(
self
val
)
}
#
[
inline
]
fn
insert2
<
K
>
(
&
mut
self
key
:
K
value
:
T
)
-
>
Option
<
T
>
where
K
:
Hash
+
Into
<
HeaderName
>
HeaderName
:
PartialEq
<
K
>
{
self
.
reserve_one
(
)
;
insert_phase_one
!
(
self
key
probe
pos
hash
danger
/
/
Vacant
{
drop
(
danger
)
;
/
/
Make
lint
happy
let
index
=
self
.
entries
.
len
(
)
;
self
.
insert_entry
(
hash
key
.
into
(
)
value
)
;
self
.
indices
[
probe
]
=
Pos
:
:
new
(
index
hash
)
;
None
}
/
/
Occupied
Some
(
self
.
insert_occupied
(
pos
value
)
)
/
/
Robinhood
{
self
.
insert_phase_two
(
key
.
into
(
)
value
hash
probe
danger
)
;
None
}
)
}
#
[
inline
]
fn
insert_occupied
(
&
mut
self
index
:
usize
value
:
T
)
-
>
T
{
if
let
Some
(
links
)
=
self
.
entries
[
index
]
.
links
{
self
.
remove_all_extra_values
(
links
.
next
)
;
}
let
entry
=
&
mut
self
.
entries
[
index
]
;
mem
:
:
replace
(
&
mut
entry
.
value
value
)
}
fn
insert_occupied_mult
(
&
mut
self
index
:
usize
value
:
T
)
-
>
ValueDrain
<
T
>
{
let
old
;
let
links
;
{
let
entry
=
&
mut
self
.
entries
[
index
]
;
old
=
mem
:
:
replace
(
&
mut
entry
.
value
value
)
;
links
=
entry
.
links
.
take
(
)
;
}
ValueDrain
{
map
:
self
as
*
mut
_
first
:
Some
(
old
)
next
:
links
.
map
(
|
l
|
l
.
next
)
lt
:
PhantomData
}
}
pub
fn
append
<
K
>
(
&
mut
self
key
:
K
value
:
T
)
-
>
bool
where
K
:
IntoHeaderName
{
key
.
append
(
self
value
)
}
#
[
inline
]
fn
append2
<
K
>
(
&
mut
self
key
:
K
value
:
T
)
-
>
bool
where
K
:
Hash
+
Into
<
HeaderName
>
HeaderName
:
PartialEq
<
K
>
{
self
.
reserve_one
(
)
;
insert_phase_one
!
(
self
key
probe
pos
hash
danger
/
/
Vacant
{
drop
(
danger
)
;
let
index
=
self
.
entries
.
len
(
)
;
self
.
insert_entry
(
hash
key
.
into
(
)
value
)
;
self
.
indices
[
probe
]
=
Pos
:
:
new
(
index
hash
)
;
false
}
/
/
Occupied
{
append_value
(
pos
&
mut
self
.
entries
[
pos
]
&
mut
self
.
extra_values
value
)
;
true
}
/
/
Robinhood
{
self
.
insert_phase_two
(
key
.
into
(
)
value
hash
probe
danger
)
;
false
}
)
}
#
[
inline
]
fn
find
<
K
:
?
Sized
>
(
&
self
key
:
&
K
)
-
>
Option
<
(
usize
usize
)
>
where
K
:
Hash
+
Into
<
HeaderName
>
HeaderName
:
PartialEq
<
K
>
{
if
self
.
entries
.
is_empty
(
)
{
return
None
;
}
let
hash
=
hash_elem_using
(
&
self
.
danger
key
)
;
let
mask
=
self
.
mask
;
let
mut
probe
=
desired_pos
(
mask
hash
)
;
let
mut
dist
=
0
;
probe_loop
!
(
probe
<
self
.
indices
.
len
(
)
{
if
let
Some
(
(
i
entry_hash
)
)
=
self
.
indices
[
probe
]
.
resolve
(
)
{
if
dist
>
probe_distance
(
mask
entry_hash
probe
)
{
/
/
give
up
when
probe
distance
is
too
long
return
None
;
}
else
if
entry_hash
=
=
hash
&
&
self
.
entries
[
i
]
.
key
=
=
*
key
{
return
Some
(
(
probe
i
)
)
;
}
}
else
{
return
None
;
}
dist
+
=
1
;
}
)
;
}
#
[
inline
]
fn
insert_phase_two
(
&
mut
self
key
:
HeaderName
value
:
T
hash
:
HashValue
probe
:
usize
danger
:
bool
)
-
>
usize
{
let
index
=
self
.
entries
.
len
(
)
;
self
.
insert_entry
(
hash
key
value
)
;
let
num_displaced
=
do_insert_phase_two
(
&
mut
self
.
indices
probe
Pos
:
:
new
(
index
hash
)
)
;
if
danger
|
|
num_displaced
>
=
DISPLACEMENT_THRESHOLD
{
self
.
danger
.
to_yellow
(
)
;
}
index
}
pub
fn
remove
<
K
>
(
&
mut
self
key
:
K
)
-
>
Option
<
T
>
where
K
:
AsHeaderName
{
match
key
.
find
(
self
)
{
Some
(
(
probe
idx
)
)
=
>
{
if
let
Some
(
links
)
=
self
.
entries
[
idx
]
.
links
{
self
.
remove_all_extra_values
(
links
.
next
)
;
}
let
entry
=
self
.
remove_found
(
probe
idx
)
;
Some
(
entry
.
value
)
}
None
=
>
None
}
}
#
[
inline
]
fn
remove_found
(
&
mut
self
probe
:
usize
found
:
usize
)
-
>
Bucket
<
T
>
{
self
.
indices
[
probe
]
=
Pos
:
:
none
(
)
;
let
entry
=
self
.
entries
.
swap_remove
(
found
)
;
if
let
Some
(
entry
)
=
self
.
entries
.
get
(
found
)
{
let
mut
probe
=
desired_pos
(
self
.
mask
entry
.
hash
)
;
probe_loop
!
(
probe
<
self
.
indices
.
len
(
)
{
if
let
Some
(
(
i
_
)
)
=
self
.
indices
[
probe
]
.
resolve
(
)
{
if
i
>
=
self
.
entries
.
len
(
)
{
/
/
found
it
self
.
indices
[
probe
]
=
Pos
:
:
new
(
found
entry
.
hash
)
;
break
;
}
}
}
)
;
if
let
Some
(
links
)
=
entry
.
links
{
self
.
extra_values
[
links
.
next
]
.
prev
=
Link
:
:
Entry
(
found
)
;
self
.
extra_values
[
links
.
tail
]
.
next
=
Link
:
:
Entry
(
found
)
;
}
}
if
self
.
entries
.
len
(
)
>
0
{
let
mut
last_probe
=
probe
;
let
mut
probe
=
probe
+
1
;
probe_loop
!
(
probe
<
self
.
indices
.
len
(
)
{
if
let
Some
(
(
_
entry_hash
)
)
=
self
.
indices
[
probe
]
.
resolve
(
)
{
if
probe_distance
(
self
.
mask
entry_hash
probe
)
>
0
{
self
.
indices
[
last_probe
]
=
self
.
indices
[
probe
]
;
self
.
indices
[
probe
]
=
Pos
:
:
none
(
)
;
}
else
{
break
;
}
}
else
{
break
;
}
last_probe
=
probe
;
}
)
;
}
entry
}
#
[
inline
]
fn
remove_extra_value
(
&
mut
self
idx
:
usize
)
-
>
ExtraValue
<
T
>
{
let
prev
;
let
next
;
{
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
idx
)
;
let
extra
=
&
self
.
extra_values
[
idx
]
;
prev
=
extra
.
prev
;
next
=
extra
.
next
;
}
match
(
prev
next
)
{
(
Link
:
:
Entry
(
prev
)
Link
:
:
Entry
(
next
)
)
=
>
{
debug_assert_eq
!
(
prev
next
)
;
debug_assert
!
(
self
.
entries
.
len
(
)
>
prev
)
;
self
.
entries
[
prev
]
.
links
=
None
;
}
(
Link
:
:
Entry
(
prev
)
Link
:
:
Extra
(
next
)
)
=
>
{
debug_assert
!
(
self
.
entries
.
len
(
)
>
prev
)
;
debug_assert
!
(
self
.
entries
[
prev
]
.
links
.
is_some
(
)
)
;
self
.
entries
[
prev
]
.
links
.
as_mut
(
)
.
unwrap
(
)
.
next
=
next
;
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
next
)
;
self
.
extra_values
[
next
]
.
prev
=
Link
:
:
Entry
(
prev
)
;
}
(
Link
:
:
Extra
(
prev
)
Link
:
:
Entry
(
next
)
)
=
>
{
debug_assert
!
(
self
.
entries
.
len
(
)
>
next
)
;
debug_assert
!
(
self
.
entries
[
next
]
.
links
.
is_some
(
)
)
;
self
.
entries
[
next
]
.
links
.
as_mut
(
)
.
unwrap
(
)
.
tail
=
prev
;
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
prev
)
;
self
.
extra_values
[
prev
]
.
next
=
Link
:
:
Entry
(
next
)
;
}
(
Link
:
:
Extra
(
prev
)
Link
:
:
Extra
(
next
)
)
=
>
{
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
next
)
;
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
prev
)
;
self
.
extra_values
[
prev
]
.
next
=
Link
:
:
Extra
(
next
)
;
self
.
extra_values
[
next
]
.
prev
=
Link
:
:
Extra
(
prev
)
;
}
}
let
mut
extra
=
self
.
extra_values
.
swap_remove
(
idx
)
;
let
old_idx
=
self
.
extra_values
.
len
(
)
;
if
extra
.
prev
=
=
Link
:
:
Extra
(
old_idx
)
{
extra
.
prev
=
Link
:
:
Extra
(
idx
)
;
}
if
extra
.
next
=
=
Link
:
:
Extra
(
old_idx
)
{
extra
.
next
=
Link
:
:
Extra
(
idx
)
;
}
if
idx
!
=
old_idx
{
let
next
;
let
prev
;
{
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
idx
)
;
let
moved
=
&
self
.
extra_values
[
idx
]
;
next
=
moved
.
next
;
prev
=
moved
.
prev
;
}
match
prev
{
Link
:
:
Entry
(
entry_idx
)
=
>
{
debug_assert
!
(
self
.
entries
.
len
(
)
>
entry_idx
)
;
debug_assert
!
(
self
.
entries
[
entry_idx
]
.
links
.
is_some
(
)
)
;
let
links
=
self
.
entries
[
entry_idx
]
.
links
.
as_mut
(
)
.
unwrap
(
)
;
links
.
next
=
idx
;
}
Link
:
:
Extra
(
extra_idx
)
=
>
{
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
extra_idx
)
;
self
.
extra_values
[
extra_idx
]
.
next
=
Link
:
:
Extra
(
idx
)
;
}
}
match
next
{
Link
:
:
Entry
(
entry_idx
)
=
>
{
debug_assert
!
(
self
.
entries
.
len
(
)
>
entry_idx
)
;
debug_assert
!
(
self
.
entries
[
entry_idx
]
.
links
.
is_some
(
)
)
;
let
links
=
self
.
entries
[
entry_idx
]
.
links
.
as_mut
(
)
.
unwrap
(
)
;
links
.
tail
=
idx
;
}
Link
:
:
Extra
(
extra_idx
)
=
>
{
debug_assert
!
(
self
.
extra_values
.
len
(
)
>
extra_idx
)
;
self
.
extra_values
[
extra_idx
]
.
prev
=
Link
:
:
Extra
(
idx
)
;
}
}
}
debug_assert
!
(
{
for
v
in
&
self
.
extra_values
{
assert
!
(
v
.
next
!
=
Link
:
:
Extra
(
old_idx
)
)
;
assert
!
(
v
.
prev
!
=
Link
:
:
Extra
(
old_idx
)
)
;
}
true
}
)
;
extra
}
fn
remove_all_extra_values
(
&
mut
self
mut
head
:
usize
)
{
loop
{
let
extra
=
self
.
remove_extra_value
(
head
)
;
if
let
Link
:
:
Extra
(
idx
)
=
extra
.
next
{
head
=
idx
;
}
else
{
break
;
}
}
}
#
[
inline
]
fn
insert_entry
(
&
mut
self
hash
:
HashValue
key
:
HeaderName
value
:
T
)
{
assert
!
(
self
.
entries
.
len
(
)
<
MAX_SIZE
"
header
map
at
capacity
"
)
;
self
.
entries
.
push
(
Bucket
{
hash
:
hash
key
:
key
value
:
value
links
:
None
}
)
;
}
fn
rebuild
(
&
mut
self
)
{
'
outer
:
for
(
index
entry
)
in
self
.
entries
.
iter_mut
(
)
.
enumerate
(
)
{
let
hash
=
hash_elem_using
(
&
self
.
danger
&
entry
.
key
)
;
let
mut
probe
=
desired_pos
(
self
.
mask
hash
)
;
let
mut
dist
=
0
;
entry
.
hash
=
hash
;
probe_loop
!
(
probe
<
self
.
indices
.
len
(
)
{
if
let
Some
(
(
_
entry_hash
)
)
=
self
.
indices
[
probe
]
.
resolve
(
)
{
/
/
if
existing
element
probed
less
than
us
swap
let
their_dist
=
probe_distance
(
self
.
mask
entry_hash
probe
)
;
if
their_dist
<
dist
{
/
/
Robinhood
break
;
}
}
else
{
/
/
Vacant
slot
self
.
indices
[
probe
]
=
Pos
:
:
new
(
index
hash
)
;
continue
'
outer
;
}
dist
+
=
1
;
}
)
;
do_insert_phase_two
(
&
mut
self
.
indices
probe
Pos
:
:
new
(
index
hash
)
)
;
}
}
fn
reinsert_entry_in_order
(
&
mut
self
pos
:
Pos
)
{
if
let
Some
(
(
_
entry_hash
)
)
=
pos
.
resolve
(
)
{
let
mut
probe
=
desired_pos
(
self
.
mask
entry_hash
)
;
probe_loop
!
(
probe
<
self
.
indices
.
len
(
)
{
if
self
.
indices
[
probe
]
.
resolve
(
)
.
is_none
(
)
{
/
/
empty
bucket
insert
here
self
.
indices
[
probe
]
=
pos
;
return
;
}
}
)
;
}
}
fn
reserve_one
(
&
mut
self
)
{
let
len
=
self
.
entries
.
len
(
)
;
if
self
.
danger
.
is_yellow
(
)
{
let
load_factor
=
self
.
entries
.
len
(
)
as
f32
/
self
.
indices
.
len
(
)
as
f32
;
if
load_factor
>
=
LOAD_FACTOR_THRESHOLD
{
self
.
danger
.
to_green
(
)
;
let
new_cap
=
self
.
indices
.
len
(
)
*
2
;
self
.
grow
(
new_cap
)
;
}
else
{
self
.
danger
.
to_red
(
)
;
for
index
in
self
.
indices
.
iter_mut
(
)
{
*
index
=
Pos
:
:
none
(
)
;
}
self
.
rebuild
(
)
;
}
}
else
if
len
=
=
self
.
capacity
(
)
{
if
len
=
=
0
{
let
new_raw_cap
=
8
;
self
.
mask
=
8
-
1
;
self
.
indices
=
vec
!
[
Pos
:
:
none
(
)
;
new_raw_cap
]
.
into_boxed_slice
(
)
;
self
.
entries
=
Vec
:
:
with_capacity
(
usable_capacity
(
new_raw_cap
)
)
;
}
else
{
let
raw_cap
=
self
.
indices
.
len
(
)
;
self
.
grow
(
raw_cap
<
<
1
)
;
}
}
}
#
[
inline
]
fn
grow
(
&
mut
self
new_raw_cap
:
usize
)
{
let
mut
first_ideal
=
0
;
for
(
i
pos
)
in
self
.
indices
.
iter
(
)
.
enumerate
(
)
{
if
let
Some
(
(
_
entry_hash
)
)
=
pos
.
resolve
(
)
{
if
0
=
=
probe_distance
(
self
.
mask
entry_hash
i
)
{
first_ideal
=
i
;
break
;
}
}
}
let
old_indices
=
mem
:
:
replace
(
&
mut
self
.
indices
vec
!
[
Pos
:
:
none
(
)
;
new_raw_cap
]
.
into_boxed_slice
(
)
)
;
self
.
mask
=
new_raw_cap
.
wrapping_sub
(
1
)
as
Size
;
for
&
pos
in
&
old_indices
[
first_ideal
.
.
]
{
self
.
reinsert_entry_in_order
(
pos
)
;
}
for
&
pos
in
&
old_indices
[
.
.
first_ideal
]
{
self
.
reinsert_entry_in_order
(
pos
)
;
}
let
more
=
self
.
capacity
(
)
-
self
.
entries
.
len
(
)
;
self
.
entries
.
reserve_exact
(
more
)
;
}
}
impl
<
'
a
T
>
IntoIterator
for
&
'
a
HeaderMap
<
T
>
{
type
Item
=
(
&
'
a
HeaderName
&
'
a
T
)
;
type
IntoIter
=
Iter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
T
>
{
self
.
iter
(
)
}
}
impl
<
'
a
T
>
IntoIterator
for
&
'
a
mut
HeaderMap
<
T
>
{
type
Item
=
(
&
'
a
HeaderName
&
'
a
mut
T
)
;
type
IntoIter
=
IterMut
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
IterMut
<
'
a
T
>
{
self
.
iter_mut
(
)
}
}
impl
<
T
>
IntoIterator
for
HeaderMap
<
T
>
{
type
Item
=
(
Option
<
HeaderName
>
T
)
;
type
IntoIter
=
IntoIter
<
T
>
;
fn
into_iter
(
self
)
-
>
IntoIter
<
T
>
{
IntoIter
{
next
:
None
entries
:
self
.
entries
.
into_iter
(
)
extra_values
:
self
.
extra_values
}
}
}
impl
<
T
>
FromIterator
<
(
HeaderName
T
)
>
for
HeaderMap
<
T
>
{
fn
from_iter
<
I
>
(
iter
:
I
)
-
>
Self
where
I
:
IntoIterator
<
Item
=
(
HeaderName
T
)
>
{
let
mut
map
=
HeaderMap
:
:
default
(
)
;
map
.
extend
(
iter
)
;
map
}
}
impl
<
T
>
Extend
<
(
Option
<
HeaderName
>
T
)
>
for
HeaderMap
<
T
>
{
fn
extend
<
I
:
IntoIterator
<
Item
=
(
Option
<
HeaderName
>
T
)
>
>
(
&
mut
self
iter
:
I
)
{
let
mut
iter
=
iter
.
into_iter
(
)
;
let
(
mut
key
mut
val
)
=
match
iter
.
next
(
)
{
Some
(
(
Some
(
key
)
val
)
)
=
>
(
key
val
)
Some
(
(
None
_
)
)
=
>
panic
!
(
"
expected
a
header
name
but
got
None
"
)
None
=
>
return
}
;
'
outer
:
loop
{
let
mut
entry
=
match
self
.
entry2
(
key
)
{
Entry
:
:
Occupied
(
mut
e
)
=
>
{
e
.
insert
(
val
)
;
e
}
Entry
:
:
Vacant
(
e
)
=
>
{
e
.
insert_entry
(
val
)
}
}
;
'
inner
:
loop
{
match
iter
.
next
(
)
{
Some
(
(
Some
(
k
)
v
)
)
=
>
{
key
=
k
;
val
=
v
;
continue
'
outer
;
}
Some
(
(
None
v
)
)
=
>
{
entry
.
append
(
v
)
;
}
None
=
>
{
return
;
}
}
}
}
}
}
impl
<
T
>
Extend
<
(
HeaderName
T
)
>
for
HeaderMap
<
T
>
{
fn
extend
<
I
:
IntoIterator
<
Item
=
(
HeaderName
T
)
>
>
(
&
mut
self
iter
:
I
)
{
let
iter
=
iter
.
into_iter
(
)
;
let
reserve
=
if
self
.
is_empty
(
)
{
iter
.
size_hint
(
)
.
0
}
else
{
(
iter
.
size_hint
(
)
.
0
+
1
)
/
2
}
;
self
.
reserve
(
reserve
)
;
for
(
k
v
)
in
iter
{
self
.
append
(
k
v
)
;
}
}
}
impl
<
T
:
PartialEq
>
PartialEq
for
HeaderMap
<
T
>
{
fn
eq
(
&
self
other
:
&
HeaderMap
<
T
>
)
-
>
bool
{
if
self
.
len
(
)
!
=
other
.
len
(
)
{
return
false
;
}
self
.
keys
(
)
.
all
(
|
key
|
{
self
.
get_all
(
key
)
=
=
other
.
get_all
(
key
)
}
)
}
}
impl
<
T
:
Eq
>
Eq
for
HeaderMap
<
T
>
{
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
HeaderMap
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_map
(
)
.
entries
(
self
.
iter
(
)
)
.
finish
(
)
}
}
impl
<
T
>
Default
for
HeaderMap
<
T
>
{
fn
default
(
)
-
>
Self
{
HeaderMap
:
:
with_capacity
(
0
)
}
}
impl
<
'
a
K
T
>
ops
:
:
Index
<
K
>
for
HeaderMap
<
T
>
where
K
:
AsHeaderName
{
type
Output
=
T
;
#
[
inline
]
fn
index
(
&
self
index
:
K
)
-
>
&
T
{
match
self
.
get2
(
&
index
)
{
Some
(
val
)
=
>
val
None
=
>
panic
!
(
"
no
entry
found
for
key
{
:
?
}
"
index
.
as_str
(
)
)
}
}
}
#
[
inline
]
fn
do_insert_phase_two
(
indices
:
&
mut
[
Pos
]
mut
probe
:
usize
mut
old_pos
:
Pos
)
-
>
usize
{
let
mut
num_displaced
=
0
;
probe_loop
!
(
probe
<
indices
.
len
(
)
{
let
pos
=
&
mut
indices
[
probe
]
;
if
pos
.
is_none
(
)
{
*
pos
=
old_pos
;
break
;
}
else
{
num_displaced
+
=
1
;
old_pos
=
mem
:
:
replace
(
pos
old_pos
)
;
}
}
)
;
num_displaced
}
#
[
inline
]
fn
append_value
<
T
>
(
entry_idx
:
usize
entry
:
&
mut
Bucket
<
T
>
extra
:
&
mut
Vec
<
ExtraValue
<
T
>
>
value
:
T
)
{
match
entry
.
links
{
Some
(
links
)
=
>
{
let
idx
=
extra
.
len
(
)
;
extra
.
push
(
ExtraValue
{
value
:
value
prev
:
Link
:
:
Extra
(
links
.
tail
)
next
:
Link
:
:
Entry
(
entry_idx
)
}
)
;
extra
[
links
.
tail
]
.
next
=
Link
:
:
Extra
(
idx
)
;
entry
.
links
=
Some
(
Links
{
tail
:
idx
.
.
links
}
)
;
}
None
=
>
{
let
idx
=
extra
.
len
(
)
;
extra
.
push
(
ExtraValue
{
value
:
value
prev
:
Link
:
:
Entry
(
entry_idx
)
next
:
Link
:
:
Entry
(
entry_idx
)
}
)
;
entry
.
links
=
Some
(
Links
{
next
:
idx
tail
:
idx
}
)
;
}
}
}
impl
<
'
a
T
>
Iterator
for
Iter
<
'
a
T
>
{
type
Item
=
(
&
'
a
HeaderName
&
'
a
T
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
next_unsafe
(
)
.
map
(
|
(
key
ptr
)
|
{
(
key
unsafe
{
&
*
ptr
}
)
}
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
unsafe
impl
<
'
a
T
:
Sync
>
Sync
for
Iter
<
'
a
T
>
{
}
unsafe
impl
<
'
a
T
:
Sync
>
Send
for
Iter
<
'
a
T
>
{
}
impl
<
'
a
T
>
IterMut
<
'
a
T
>
{
fn
next_unsafe
(
&
mut
self
)
-
>
Option
<
(
&
'
a
HeaderName
*
mut
T
)
>
{
use
self
:
:
Cursor
:
:
*
;
if
self
.
cursor
.
is_none
(
)
{
if
(
self
.
entry
+
1
)
>
=
unsafe
{
&
*
self
.
map
}
.
entries
.
len
(
)
{
return
None
;
}
self
.
entry
+
=
1
;
self
.
cursor
=
Some
(
Cursor
:
:
Head
)
;
}
let
entry
=
unsafe
{
&
(
*
self
.
map
)
.
entries
[
self
.
entry
]
}
;
match
self
.
cursor
.
unwrap
(
)
{
Head
=
>
{
self
.
cursor
=
entry
.
links
.
map
(
|
l
|
Values
(
l
.
next
)
)
;
Some
(
(
&
entry
.
key
&
entry
.
value
as
*
const
_
as
*
mut
_
)
)
}
Values
(
idx
)
=
>
{
let
extra
=
unsafe
{
&
(
*
self
.
map
)
.
extra_values
[
idx
]
}
;
match
extra
.
next
{
Link
:
:
Entry
(
_
)
=
>
self
.
cursor
=
None
Link
:
:
Extra
(
i
)
=
>
self
.
cursor
=
Some
(
Values
(
i
)
)
}
Some
(
(
&
entry
.
key
&
extra
.
value
as
*
const
_
as
*
mut
_
)
)
}
}
}
}
impl
<
'
a
T
>
Iterator
for
IterMut
<
'
a
T
>
{
type
Item
=
(
&
'
a
HeaderName
&
'
a
mut
T
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
next_unsafe
(
)
.
map
(
|
(
key
ptr
)
|
{
(
key
unsafe
{
&
mut
*
ptr
}
)
}
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
map
=
unsafe
{
&
*
self
.
map
}
;
debug_assert
!
(
map
.
entries
.
len
(
)
>
=
self
.
entry
)
;
let
lower
=
map
.
entries
.
len
(
)
-
self
.
entry
;
(
lower
None
)
}
}
unsafe
impl
<
'
a
T
:
Sync
>
Sync
for
IterMut
<
'
a
T
>
{
}
unsafe
impl
<
'
a
T
:
Send
>
Send
for
IterMut
<
'
a
T
>
{
}
impl
<
'
a
T
>
Iterator
for
Keys
<
'
a
T
>
{
type
Item
=
&
'
a
HeaderName
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
next
(
)
.
map
(
|
b
|
&
b
.
key
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
T
>
ExactSizeIterator
for
Keys
<
'
a
T
>
{
}
impl
<
'
a
T
>
Iterator
for
Values
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
_
v
)
|
v
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
T
>
Iterator
for
ValuesMut
<
'
a
T
>
{
type
Item
=
&
'
a
mut
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
inner
.
next
(
)
.
map
(
|
(
_
v
)
|
v
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
inner
.
size_hint
(
)
}
}
impl
<
'
a
T
>
Iterator
for
Drain
<
'
a
T
>
{
type
Item
=
(
HeaderName
ValueDrain
<
'
a
T
>
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
idx
=
self
.
idx
;
if
idx
=
=
unsafe
{
(
*
self
.
map
)
.
entries
.
len
(
)
}
{
return
None
;
}
self
.
idx
+
=
1
;
let
key
;
let
value
;
let
next
;
unsafe
{
let
entry
=
&
(
*
self
.
map
)
.
entries
[
idx
]
;
key
=
ptr
:
:
read
(
&
entry
.
key
as
*
const
_
)
;
value
=
ptr
:
:
read
(
&
entry
.
value
as
*
const
_
)
;
next
=
entry
.
links
.
map
(
|
l
|
l
.
next
)
;
}
;
let
values
=
ValueDrain
{
map
:
self
.
map
first
:
Some
(
value
)
next
:
next
lt
:
PhantomData
}
;
Some
(
(
key
values
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
lower
=
unsafe
{
(
*
self
.
map
)
.
entries
.
len
(
)
}
-
self
.
idx
;
(
lower
Some
(
lower
)
)
}
}
impl
<
'
a
T
>
Drop
for
Drain
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
map
=
&
mut
*
self
.
map
;
debug_assert
!
(
map
.
extra_values
.
is_empty
(
)
)
;
map
.
entries
.
set_len
(
0
)
;
}
}
}
unsafe
impl
<
'
a
T
:
Sync
>
Sync
for
Drain
<
'
a
T
>
{
}
unsafe
impl
<
'
a
T
:
Send
>
Send
for
Drain
<
'
a
T
>
{
}
impl
<
'
a
T
>
Entry
<
'
a
T
>
{
pub
fn
or_insert
(
self
default
:
T
)
-
>
&
'
a
mut
T
{
use
self
:
:
Entry
:
:
*
;
match
self
{
Occupied
(
e
)
=
>
e
.
into_mut
(
)
Vacant
(
e
)
=
>
e
.
insert
(
default
)
}
}
pub
fn
or_insert_with
<
F
:
FnOnce
(
)
-
>
T
>
(
self
default
:
F
)
-
>
&
'
a
mut
T
{
use
self
:
:
Entry
:
:
*
;
match
self
{
Occupied
(
e
)
=
>
e
.
into_mut
(
)
Vacant
(
e
)
=
>
e
.
insert
(
default
(
)
)
}
}
pub
fn
key
(
&
self
)
-
>
&
HeaderName
{
use
self
:
:
Entry
:
:
*
;
match
*
self
{
Vacant
(
ref
e
)
=
>
e
.
key
(
)
Occupied
(
ref
e
)
=
>
e
.
key
(
)
}
}
}
impl
<
'
a
T
>
VacantEntry
<
'
a
T
>
{
pub
fn
key
(
&
self
)
-
>
&
HeaderName
{
&
self
.
key
}
pub
fn
into_key
(
self
)
-
>
HeaderName
{
self
.
key
}
pub
fn
insert
(
self
value
:
T
)
-
>
&
'
a
mut
T
{
let
index
=
self
.
map
.
insert_phase_two
(
self
.
key
value
.
into
(
)
self
.
hash
self
.
probe
self
.
danger
)
;
&
mut
self
.
map
.
entries
[
index
]
.
value
}
pub
fn
insert_entry
(
self
value
:
T
)
-
>
OccupiedEntry
<
'
a
T
>
{
let
index
=
self
.
map
.
insert_phase_two
(
self
.
key
value
.
into
(
)
self
.
hash
self
.
probe
self
.
danger
)
;
OccupiedEntry
{
map
:
self
.
map
index
:
index
probe
:
self
.
probe
}
}
}
impl
<
'
a
T
:
'
a
>
GetAll
<
'
a
T
>
{
pub
fn
iter
(
&
self
)
-
>
ValueIter
<
'
a
T
>
{
GetAll
{
map
:
self
.
map
index
:
self
.
index
}
.
into_iter
(
)
}
}
impl
<
'
a
T
:
PartialEq
>
PartialEq
for
GetAll
<
'
a
T
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
iter
(
)
.
eq
(
other
.
iter
(
)
)
}
}
impl
<
'
a
T
>
IntoIterator
for
GetAll
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
ValueIter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
ValueIter
<
'
a
T
>
{
self
.
map
.
value_iter
(
self
.
index
)
}
}
impl
<
'
a
'
b
:
'
a
T
>
IntoIterator
for
&
'
b
GetAll
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
ValueIter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
ValueIter
<
'
a
T
>
{
self
.
map
.
value_iter
(
self
.
index
)
}
}
impl
<
'
a
T
:
'
a
>
Iterator
for
ValueIter
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
use
self
:
:
Cursor
:
:
*
;
match
self
.
front
{
Some
(
Head
)
=
>
{
let
entry
=
&
self
.
map
.
entries
[
self
.
index
]
;
if
self
.
back
=
=
Some
(
Head
)
{
self
.
front
=
None
;
self
.
back
=
None
;
}
else
{
match
entry
.
links
{
Some
(
links
)
=
>
{
self
.
front
=
Some
(
Values
(
links
.
next
)
)
;
}
None
=
>
unreachable
!
(
)
}
}
Some
(
&
entry
.
value
)
}
Some
(
Values
(
idx
)
)
=
>
{
let
extra
=
&
self
.
map
.
extra_values
[
idx
]
;
if
self
.
front
=
=
self
.
back
{
self
.
front
=
None
;
self
.
back
=
None
;
}
else
{
match
extra
.
next
{
Link
:
:
Entry
(
_
)
=
>
self
.
front
=
None
Link
:
:
Extra
(
i
)
=
>
self
.
front
=
Some
(
Values
(
i
)
)
}
}
Some
(
&
extra
.
value
)
}
None
=
>
None
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
match
(
self
.
front
self
.
back
)
{
(
Some
(
Cursor
:
:
Head
)
Some
(
Cursor
:
:
Head
)
)
=
>
(
1
Some
(
1
)
)
(
Some
(
_
)
_
)
=
>
(
1
None
)
(
None
_
)
=
>
(
0
Some
(
0
)
)
}
}
}
impl
<
'
a
T
:
'
a
>
DoubleEndedIterator
for
ValueIter
<
'
a
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
use
self
:
:
Cursor
:
:
*
;
match
self
.
back
{
Some
(
Head
)
=
>
{
self
.
front
=
None
;
self
.
back
=
None
;
Some
(
&
self
.
map
.
entries
[
self
.
index
]
.
value
)
}
Some
(
Values
(
idx
)
)
=
>
{
let
extra
=
&
self
.
map
.
extra_values
[
idx
]
;
if
self
.
front
=
=
self
.
back
{
self
.
front
=
None
;
self
.
back
=
None
;
}
else
{
match
extra
.
prev
{
Link
:
:
Entry
(
_
)
=
>
self
.
back
=
Some
(
Head
)
Link
:
:
Extra
(
idx
)
=
>
self
.
back
=
Some
(
Values
(
idx
)
)
}
}
Some
(
&
extra
.
value
)
}
None
=
>
None
}
}
}
impl
<
'
a
T
:
'
a
>
Iterator
for
ValueIterMut
<
'
a
T
>
{
type
Item
=
&
'
a
mut
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
use
self
:
:
Cursor
:
:
*
;
let
entry
=
unsafe
{
&
mut
(
*
self
.
map
)
.
entries
[
self
.
index
]
}
;
match
self
.
front
{
Some
(
Head
)
=
>
{
if
self
.
back
=
=
Some
(
Head
)
{
self
.
front
=
None
;
self
.
back
=
None
;
}
else
{
match
entry
.
links
{
Some
(
links
)
=
>
{
self
.
front
=
Some
(
Values
(
links
.
next
)
)
;
}
None
=
>
unreachable
!
(
)
}
}
Some
(
&
mut
entry
.
value
)
}
Some
(
Values
(
idx
)
)
=
>
{
let
extra
=
unsafe
{
&
mut
(
*
self
.
map
)
.
extra_values
[
idx
]
}
;
if
self
.
front
=
=
self
.
back
{
self
.
front
=
None
;
self
.
back
=
None
;
}
else
{
match
extra
.
next
{
Link
:
:
Entry
(
_
)
=
>
self
.
front
=
None
Link
:
:
Extra
(
i
)
=
>
self
.
front
=
Some
(
Values
(
i
)
)
}
}
Some
(
&
mut
extra
.
value
)
}
None
=
>
None
}
}
}
impl
<
'
a
T
:
'
a
>
DoubleEndedIterator
for
ValueIterMut
<
'
a
T
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
use
self
:
:
Cursor
:
:
*
;
let
entry
=
unsafe
{
&
mut
(
*
self
.
map
)
.
entries
[
self
.
index
]
}
;
match
self
.
back
{
Some
(
Head
)
=
>
{
self
.
front
=
None
;
self
.
back
=
None
;
Some
(
&
mut
entry
.
value
)
}
Some
(
Values
(
idx
)
)
=
>
{
let
extra
=
unsafe
{
&
mut
(
*
self
.
map
)
.
extra_values
[
idx
]
}
;
if
self
.
front
=
=
self
.
back
{
self
.
front
=
None
;
self
.
back
=
None
;
}
else
{
match
extra
.
prev
{
Link
:
:
Entry
(
_
)
=
>
self
.
back
=
Some
(
Head
)
Link
:
:
Extra
(
idx
)
=
>
self
.
back
=
Some
(
Values
(
idx
)
)
}
}
Some
(
&
mut
extra
.
value
)
}
None
=
>
None
}
}
}
unsafe
impl
<
'
a
T
:
Sync
>
Sync
for
ValueIterMut
<
'
a
T
>
{
}
unsafe
impl
<
'
a
T
:
Send
>
Send
for
ValueIterMut
<
'
a
T
>
{
}
impl
<
T
>
Iterator
for
IntoIter
<
T
>
{
type
Item
=
(
Option
<
HeaderName
>
T
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
next
)
=
self
.
next
{
self
.
next
=
match
self
.
extra_values
[
next
]
.
next
{
Link
:
:
Entry
(
_
)
=
>
None
Link
:
:
Extra
(
v
)
=
>
Some
(
v
)
}
;
let
value
=
unsafe
{
ptr
:
:
read
(
&
self
.
extra_values
[
next
]
.
value
)
}
;
return
Some
(
(
None
value
)
)
;
}
if
let
Some
(
bucket
)
=
self
.
entries
.
next
(
)
{
self
.
next
=
bucket
.
links
.
map
(
|
l
|
l
.
next
)
;
let
name
=
Some
(
bucket
.
key
)
;
let
value
=
bucket
.
value
;
return
Some
(
(
name
value
)
)
;
}
None
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
lower
_
)
=
self
.
entries
.
size_hint
(
)
;
(
lower
None
)
}
}
impl
<
T
>
Drop
for
IntoIter
<
T
>
{
fn
drop
(
&
mut
self
)
{
for
_
in
self
.
by_ref
(
)
{
}
unsafe
{
self
.
extra_values
.
set_len
(
0
)
;
}
}
}
impl
<
'
a
T
>
OccupiedEntry
<
'
a
T
>
{
pub
fn
key
(
&
self
)
-
>
&
HeaderName
{
&
self
.
map
.
entries
[
self
.
index
]
.
key
}
pub
fn
get
(
&
self
)
-
>
&
T
{
&
self
.
map
.
entries
[
self
.
index
]
.
value
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
map
.
entries
[
self
.
index
]
.
value
}
pub
fn
into_mut
(
self
)
-
>
&
'
a
mut
T
{
&
mut
self
.
map
.
entries
[
self
.
index
]
.
value
}
pub
fn
insert
(
&
mut
self
value
:
T
)
-
>
T
{
self
.
map
.
insert_occupied
(
self
.
index
value
.
into
(
)
)
}
pub
fn
insert_mult
(
&
mut
self
value
:
T
)
-
>
ValueDrain
<
T
>
{
self
.
map
.
insert_occupied_mult
(
self
.
index
value
.
into
(
)
)
}
pub
fn
append
(
&
mut
self
value
:
T
)
{
let
idx
=
self
.
index
;
let
entry
=
&
mut
self
.
map
.
entries
[
idx
]
;
append_value
(
idx
entry
&
mut
self
.
map
.
extra_values
value
.
into
(
)
)
;
}
pub
fn
remove
(
self
)
-
>
T
{
self
.
remove_entry
(
)
.
1
}
pub
fn
remove_entry
(
self
)
-
>
(
HeaderName
T
)
{
let
entry
=
self
.
map
.
remove_found
(
self
.
probe
self
.
index
)
;
if
let
Some
(
links
)
=
entry
.
links
{
self
.
map
.
remove_all_extra_values
(
links
.
next
)
;
}
(
entry
.
key
entry
.
value
)
}
pub
fn
remove_entry_mult
(
self
)
-
>
(
HeaderName
ValueDrain
<
'
a
T
>
)
{
let
entry
=
self
.
map
.
remove_found
(
self
.
probe
self
.
index
)
;
let
drain
=
ValueDrain
{
map
:
self
.
map
as
*
mut
_
first
:
Some
(
entry
.
value
)
next
:
entry
.
links
.
map
(
|
l
|
l
.
next
)
lt
:
PhantomData
}
;
(
entry
.
key
drain
)
}
pub
fn
iter
(
&
self
)
-
>
ValueIter
<
T
>
{
self
.
map
.
value_iter
(
Some
(
self
.
index
)
)
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
ValueIterMut
<
T
>
{
self
.
map
.
value_iter_mut
(
self
.
index
)
}
}
impl
<
'
a
T
>
IntoIterator
for
OccupiedEntry
<
'
a
T
>
{
type
Item
=
&
'
a
mut
T
;
type
IntoIter
=
ValueIterMut
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
ValueIterMut
<
'
a
T
>
{
self
.
map
.
value_iter_mut
(
self
.
index
)
}
}
impl
<
'
a
'
b
:
'
a
T
>
IntoIterator
for
&
'
b
OccupiedEntry
<
'
a
T
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
ValueIter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
ValueIter
<
'
a
T
>
{
self
.
iter
(
)
}
}
impl
<
'
a
'
b
:
'
a
T
>
IntoIterator
for
&
'
b
mut
OccupiedEntry
<
'
a
T
>
{
type
Item
=
&
'
a
mut
T
;
type
IntoIter
=
ValueIterMut
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
ValueIterMut
<
'
a
T
>
{
self
.
iter_mut
(
)
}
}
impl
<
'
a
T
>
Iterator
for
ValueDrain
<
'
a
T
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
if
self
.
first
.
is_some
(
)
{
self
.
first
.
take
(
)
}
else
if
let
Some
(
next
)
=
self
.
next
{
let
extra
=
unsafe
{
&
mut
(
*
self
.
map
)
}
.
remove_extra_value
(
next
)
;
match
extra
.
next
{
Link
:
:
Extra
(
idx
)
=
>
self
.
next
=
Some
(
idx
)
Link
:
:
Entry
(
_
)
=
>
self
.
next
=
None
}
Some
(
extra
.
value
)
}
else
{
None
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
match
(
&
self
.
first
self
.
next
)
{
(
&
Some
(
_
)
None
)
=
>
(
1
Some
(
1
)
)
(
&
_
Some
(
_
)
)
=
>
(
1
None
)
(
&
None
None
)
=
>
(
0
Some
(
0
)
)
}
}
}
impl
<
'
a
T
>
Drop
for
ValueDrain
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
while
let
Some
(
_
)
=
self
.
next
(
)
{
}
}
}
unsafe
impl
<
'
a
T
:
Sync
>
Sync
for
ValueDrain
<
'
a
T
>
{
}
unsafe
impl
<
'
a
T
:
Send
>
Send
for
ValueDrain
<
'
a
T
>
{
}
impl
Pos
{
#
[
inline
]
fn
new
(
index
:
usize
hash
:
HashValue
)
-
>
Self
{
Pos
{
index
:
index
as
Size
hash
:
hash
}
}
#
[
inline
]
fn
none
(
)
-
>
Self
{
Pos
{
index
:
!
0
hash
:
HashValue
(
0
)
}
}
#
[
inline
]
fn
is_some
(
&
self
)
-
>
bool
{
!
self
.
is_none
(
)
}
#
[
inline
]
fn
is_none
(
&
self
)
-
>
bool
{
self
.
index
=
=
!
0
}
#
[
inline
]
fn
resolve
(
&
self
)
-
>
Option
<
(
usize
HashValue
)
>
{
if
self
.
is_some
(
)
{
Some
(
(
self
.
index
self
.
hash
)
)
}
else
{
None
}
}
}
impl
Danger
{
fn
is_red
(
&
self
)
-
>
bool
{
match
*
self
{
Danger
:
:
Red
(
_
)
=
>
true
_
=
>
false
}
}
fn
to_red
(
&
mut
self
)
{
debug_assert
!
(
self
.
is_yellow
(
)
)
;
*
self
=
Danger
:
:
Red
(
RandomState
:
:
new
(
)
)
;
}
fn
is_yellow
(
&
self
)
-
>
bool
{
match
*
self
{
Danger
:
:
Yellow
=
>
true
_
=
>
false
}
}
fn
to_yellow
(
&
mut
self
)
{
match
*
self
{
Danger
:
:
Green
=
>
{
*
self
=
Danger
:
:
Yellow
;
}
_
=
>
{
}
}
}
fn
to_green
(
&
mut
self
)
{
debug_assert
!
(
self
.
is_yellow
(
)
)
;
*
self
=
Danger
:
:
Green
;
}
}
#
[
inline
]
fn
usable_capacity
(
cap
:
usize
)
-
>
usize
{
cap
-
cap
/
4
}
#
[
inline
]
fn
to_raw_capacity
(
n
:
usize
)
-
>
usize
{
n
+
n
/
3
}
#
[
inline
]
fn
desired_pos
(
mask
:
Size
hash
:
HashValue
)
-
>
usize
{
(
hash
.
0
&
mask
)
}
#
[
inline
]
fn
probe_distance
(
mask
:
Size
hash
:
HashValue
current
:
usize
)
-
>
usize
{
current
.
wrapping_sub
(
desired_pos
(
mask
hash
)
)
&
mask
}
fn
hash_elem_using
<
K
:
?
Sized
>
(
danger
:
&
Danger
k
:
&
K
)
-
>
HashValue
where
K
:
Hash
{
use
fnv
:
:
FnvHasher
;
const
MASK
:
u64
=
(
MAX_SIZE
as
u64
)
-
1
;
let
hash
=
match
*
danger
{
Danger
:
:
Red
(
ref
hasher
)
=
>
{
let
mut
h
=
hasher
.
build_hasher
(
)
;
k
.
hash
(
&
mut
h
)
;
h
.
finish
(
)
}
_
=
>
{
let
mut
h
=
FnvHasher
:
:
default
(
)
;
k
.
hash
(
&
mut
h
)
;
h
.
finish
(
)
}
}
;
HashValue
(
(
hash
&
MASK
)
as
usize
)
}
mod
into_header_name
{
use
super
:
:
{
HdrName
HeaderMap
HeaderName
}
;
pub
trait
IntoHeaderName
:
Sealed
{
}
pub
trait
Sealed
{
#
[
doc
(
hidden
)
]
fn
insert
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
Option
<
T
>
;
#
[
doc
(
hidden
)
]
fn
append
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
bool
;
}
impl
Sealed
for
HeaderName
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
insert
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
Option
<
T
>
{
map
.
insert2
(
self
val
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
append
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
bool
{
map
.
append2
(
self
val
)
}
}
impl
IntoHeaderName
for
HeaderName
{
}
impl
<
'
a
>
Sealed
for
&
'
a
HeaderName
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
insert
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
Option
<
T
>
{
map
.
insert2
(
self
val
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
append
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
bool
{
map
.
append2
(
self
val
)
}
}
impl
<
'
a
>
IntoHeaderName
for
&
'
a
HeaderName
{
}
impl
Sealed
for
&
'
static
str
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
insert
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
Option
<
T
>
{
HdrName
:
:
from_static
(
self
move
|
hdr
|
map
.
insert2
(
hdr
val
)
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
append
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
val
:
T
)
-
>
bool
{
HdrName
:
:
from_static
(
self
move
|
hdr
|
map
.
append2
(
hdr
val
)
)
}
}
impl
IntoHeaderName
for
&
'
static
str
{
}
}
mod
as_header_name
{
use
super
:
:
{
Entry
HdrName
HeaderMap
HeaderName
InvalidHeaderName
}
;
pub
trait
AsHeaderName
:
Sealed
{
}
pub
trait
Sealed
{
#
[
doc
(
hidden
)
]
fn
entry
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
;
#
[
doc
(
hidden
)
]
fn
find
<
T
>
(
&
self
map
:
&
HeaderMap
<
T
>
)
-
>
Option
<
(
usize
usize
)
>
;
#
[
doc
(
hidden
)
]
fn
as_str
(
&
self
)
-
>
&
str
;
}
impl
Sealed
for
HeaderName
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
entry
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
{
Ok
(
map
.
entry2
(
self
)
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
find
<
T
>
(
&
self
map
:
&
HeaderMap
<
T
>
)
-
>
Option
<
(
usize
usize
)
>
{
map
.
find
(
self
)
}
#
[
doc
(
hidden
)
]
fn
as_str
(
&
self
)
-
>
&
str
{
<
HeaderName
>
:
:
as_str
(
self
)
}
}
impl
AsHeaderName
for
HeaderName
{
}
impl
<
'
a
>
Sealed
for
&
'
a
HeaderName
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
entry
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
{
Ok
(
map
.
entry2
(
self
)
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
find
<
T
>
(
&
self
map
:
&
HeaderMap
<
T
>
)
-
>
Option
<
(
usize
usize
)
>
{
map
.
find
(
*
self
)
}
#
[
doc
(
hidden
)
]
fn
as_str
(
&
self
)
-
>
&
str
{
<
HeaderName
>
:
:
as_str
(
*
self
)
}
}
impl
<
'
a
>
AsHeaderName
for
&
'
a
HeaderName
{
}
impl
<
'
a
>
Sealed
for
&
'
a
str
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
entry
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
{
HdrName
:
:
from_bytes
(
self
.
as_bytes
(
)
move
|
hdr
|
map
.
entry2
(
hdr
)
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
find
<
T
>
(
&
self
map
:
&
HeaderMap
<
T
>
)
-
>
Option
<
(
usize
usize
)
>
{
HdrName
:
:
from_bytes
(
self
.
as_bytes
(
)
move
|
hdr
|
map
.
find
(
&
hdr
)
)
.
unwrap_or
(
None
)
}
#
[
doc
(
hidden
)
]
fn
as_str
(
&
self
)
-
>
&
str
{
self
}
}
impl
<
'
a
>
AsHeaderName
for
&
'
a
str
{
}
impl
Sealed
for
String
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
entry
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
{
self
.
as_str
(
)
.
entry
(
map
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
find
<
T
>
(
&
self
map
:
&
HeaderMap
<
T
>
)
-
>
Option
<
(
usize
usize
)
>
{
Sealed
:
:
find
(
&
self
.
as_str
(
)
map
)
}
#
[
doc
(
hidden
)
]
fn
as_str
(
&
self
)
-
>
&
str
{
self
}
}
impl
AsHeaderName
for
String
{
}
impl
<
'
a
>
Sealed
for
&
'
a
String
{
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
entry
<
T
>
(
self
map
:
&
mut
HeaderMap
<
T
>
)
-
>
Result
<
Entry
<
T
>
InvalidHeaderName
>
{
self
.
as_str
(
)
.
entry
(
map
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
fn
find
<
T
>
(
&
self
map
:
&
HeaderMap
<
T
>
)
-
>
Option
<
(
usize
usize
)
>
{
Sealed
:
:
find
(
*
self
map
)
}
#
[
doc
(
hidden
)
]
fn
as_str
(
&
self
)
-
>
&
str
{
*
self
}
}
impl
<
'
a
>
AsHeaderName
for
&
'
a
String
{
}
}
#
[
test
]
fn
test_bounds
(
)
{
fn
check_bounds
<
T
:
Send
+
Send
>
(
)
{
}
check_bounds
:
:
<
HeaderMap
<
(
)
>
>
(
)
;
check_bounds
:
:
<
Iter
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
IterMut
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
Keys
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
Values
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
ValuesMut
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
Drain
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
GetAll
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
Entry
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
VacantEntry
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
OccupiedEntry
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
ValueIter
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
ValueIterMut
<
'
static
(
)
>
>
(
)
;
check_bounds
:
:
<
ValueDrain
<
'
static
(
)
>
>
(
)
;
}
#
[
test
]
fn
skip_duplicates_during_key_iteration
(
)
{
let
mut
map
=
HeaderMap
:
:
new
(
)
;
map
.
append
(
"
a
"
HeaderValue
:
:
from_static
(
"
a
"
)
)
;
map
.
append
(
"
a
"
HeaderValue
:
:
from_static
(
"
b
"
)
)
;
assert_eq
!
(
map
.
keys
(
)
.
count
(
)
map
.
keys_len
(
)
)
;
}
