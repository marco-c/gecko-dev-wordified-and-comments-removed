use
std
:
:
any
:
:
{
Any
TypeId
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
{
BuildHasherDefault
Hasher
}
;
type
AnyMap
=
HashMap
<
TypeId
Box
<
dyn
Any
+
Send
+
Sync
>
BuildHasherDefault
<
IdHasher
>
>
;
#
[
derive
(
Default
)
]
struct
IdHasher
(
u64
)
;
impl
Hasher
for
IdHasher
{
fn
write
(
&
mut
self
_
:
&
[
u8
]
)
{
unreachable
!
(
"
TypeId
calls
write_u64
"
)
;
}
#
[
inline
]
fn
write_u64
(
&
mut
self
id
:
u64
)
{
self
.
0
=
id
;
}
#
[
inline
]
fn
finish
(
&
self
)
-
>
u64
{
self
.
0
}
}
#
[
derive
(
Default
)
]
pub
struct
Extensions
{
map
:
Option
<
Box
<
AnyMap
>
>
}
impl
Extensions
{
#
[
inline
]
pub
fn
new
(
)
-
>
Extensions
{
Extensions
{
map
:
None
}
}
pub
fn
insert
<
T
:
Send
+
Sync
+
'
static
>
(
&
mut
self
val
:
T
)
-
>
Option
<
T
>
{
self
.
map
.
get_or_insert_with
(
|
|
Box
:
:
new
(
HashMap
:
:
default
(
)
)
)
.
insert
(
TypeId
:
:
of
:
:
<
T
>
(
)
Box
:
:
new
(
val
)
)
.
and_then
(
|
boxed
|
{
(
boxed
as
Box
<
dyn
Any
+
'
static
>
)
.
downcast
(
)
.
ok
(
)
.
map
(
|
boxed
|
*
boxed
)
}
)
}
pub
fn
get
<
T
:
Send
+
Sync
+
'
static
>
(
&
self
)
-
>
Option
<
&
T
>
{
self
.
map
.
as_ref
(
)
.
and_then
(
|
map
|
map
.
get
(
&
TypeId
:
:
of
:
:
<
T
>
(
)
)
)
.
and_then
(
|
boxed
|
(
&
*
*
boxed
as
&
(
dyn
Any
+
'
static
)
)
.
downcast_ref
(
)
)
}
pub
fn
get_mut
<
T
:
Send
+
Sync
+
'
static
>
(
&
mut
self
)
-
>
Option
<
&
mut
T
>
{
self
.
map
.
as_mut
(
)
.
and_then
(
|
map
|
map
.
get_mut
(
&
TypeId
:
:
of
:
:
<
T
>
(
)
)
)
.
and_then
(
|
boxed
|
(
&
mut
*
*
boxed
as
&
mut
(
dyn
Any
+
'
static
)
)
.
downcast_mut
(
)
)
}
pub
fn
remove
<
T
:
Send
+
Sync
+
'
static
>
(
&
mut
self
)
-
>
Option
<
T
>
{
self
.
map
.
as_mut
(
)
.
and_then
(
|
map
|
map
.
remove
(
&
TypeId
:
:
of
:
:
<
T
>
(
)
)
)
.
and_then
(
|
boxed
|
{
(
boxed
as
Box
<
dyn
Any
+
'
static
>
)
.
downcast
(
)
.
ok
(
)
.
map
(
|
boxed
|
*
boxed
)
}
)
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
if
let
Some
(
ref
mut
map
)
=
self
.
map
{
map
.
clear
(
)
;
}
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
map
.
as_ref
(
)
.
map_or
(
true
|
map
|
map
.
is_empty
(
)
)
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
map
.
as_ref
(
)
.
map_or
(
0
|
map
|
map
.
len
(
)
)
}
}
impl
fmt
:
:
Debug
for
Extensions
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Extensions
"
)
.
finish
(
)
}
}
#
[
test
]
fn
test_extensions
(
)
{
#
[
derive
(
Debug
PartialEq
)
]
struct
MyType
(
i32
)
;
let
mut
extensions
=
Extensions
:
:
new
(
)
;
extensions
.
insert
(
5i32
)
;
extensions
.
insert
(
MyType
(
10
)
)
;
assert_eq
!
(
extensions
.
get
(
)
Some
(
&
5i32
)
)
;
assert_eq
!
(
extensions
.
get_mut
(
)
Some
(
&
mut
5i32
)
)
;
assert_eq
!
(
extensions
.
remove
:
:
<
i32
>
(
)
Some
(
5i32
)
)
;
assert
!
(
extensions
.
get
:
:
<
i32
>
(
)
.
is_none
(
)
)
;
assert_eq
!
(
extensions
.
get
:
:
<
bool
>
(
)
None
)
;
assert_eq
!
(
extensions
.
get
(
)
Some
(
&
MyType
(
10
)
)
)
;
}
