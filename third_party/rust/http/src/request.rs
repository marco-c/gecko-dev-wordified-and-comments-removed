use
std
:
:
any
:
:
Any
;
use
std
:
:
fmt
;
use
{
Uri
Error
Result
HttpTryFrom
Extensions
}
;
use
header
:
:
{
HeaderMap
HeaderName
HeaderValue
}
;
use
method
:
:
Method
;
use
version
:
:
Version
;
pub
struct
Request
<
T
>
{
head
:
Parts
body
:
T
}
pub
struct
Parts
{
pub
method
:
Method
pub
uri
:
Uri
pub
version
:
Version
pub
headers
:
HeaderMap
<
HeaderValue
>
pub
extensions
:
Extensions
_priv
:
(
)
}
#
[
derive
(
Debug
)
]
pub
struct
Builder
{
head
:
Option
<
Parts
>
err
:
Option
<
Error
>
}
impl
Request
<
(
)
>
{
#
[
inline
]
pub
fn
builder
(
)
-
>
Builder
{
Builder
:
:
new
(
)
}
pub
fn
get
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
GET
)
.
uri
(
uri
)
;
b
}
pub
fn
put
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
PUT
)
.
uri
(
uri
)
;
b
}
pub
fn
post
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
POST
)
.
uri
(
uri
)
;
b
}
pub
fn
delete
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
DELETE
)
.
uri
(
uri
)
;
b
}
pub
fn
options
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
OPTIONS
)
.
uri
(
uri
)
;
b
}
pub
fn
head
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
HEAD
)
.
uri
(
uri
)
;
b
}
pub
fn
connect
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
CONNECT
)
.
uri
(
uri
)
;
b
}
pub
fn
patch
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
PATCH
)
.
uri
(
uri
)
;
b
}
pub
fn
trace
<
T
>
(
uri
:
T
)
-
>
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
let
mut
b
=
Builder
:
:
new
(
)
;
b
.
method
(
Method
:
:
TRACE
)
.
uri
(
uri
)
;
b
}
}
impl
<
T
>
Request
<
T
>
{
#
[
inline
]
pub
fn
new
(
body
:
T
)
-
>
Request
<
T
>
{
Request
{
head
:
Parts
:
:
new
(
)
body
:
body
}
}
#
[
inline
]
pub
fn
from_parts
(
parts
:
Parts
body
:
T
)
-
>
Request
<
T
>
{
Request
{
head
:
parts
body
:
body
}
}
#
[
inline
]
pub
fn
method
(
&
self
)
-
>
&
Method
{
&
self
.
head
.
method
}
#
[
inline
]
pub
fn
method_mut
(
&
mut
self
)
-
>
&
mut
Method
{
&
mut
self
.
head
.
method
}
#
[
inline
]
pub
fn
uri
(
&
self
)
-
>
&
Uri
{
&
self
.
head
.
uri
}
#
[
inline
]
pub
fn
uri_mut
(
&
mut
self
)
-
>
&
mut
Uri
{
&
mut
self
.
head
.
uri
}
#
[
inline
]
pub
fn
version
(
&
self
)
-
>
Version
{
self
.
head
.
version
}
#
[
inline
]
pub
fn
version_mut
(
&
mut
self
)
-
>
&
mut
Version
{
&
mut
self
.
head
.
version
}
#
[
inline
]
pub
fn
headers
(
&
self
)
-
>
&
HeaderMap
<
HeaderValue
>
{
&
self
.
head
.
headers
}
#
[
inline
]
pub
fn
headers_mut
(
&
mut
self
)
-
>
&
mut
HeaderMap
<
HeaderValue
>
{
&
mut
self
.
head
.
headers
}
#
[
inline
]
pub
fn
extensions
(
&
self
)
-
>
&
Extensions
{
&
self
.
head
.
extensions
}
#
[
inline
]
pub
fn
extensions_mut
(
&
mut
self
)
-
>
&
mut
Extensions
{
&
mut
self
.
head
.
extensions
}
#
[
inline
]
pub
fn
body
(
&
self
)
-
>
&
T
{
&
self
.
body
}
#
[
inline
]
pub
fn
body_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
body
}
#
[
inline
]
pub
fn
into_body
(
self
)
-
>
T
{
self
.
body
}
#
[
inline
]
pub
fn
into_parts
(
self
)
-
>
(
Parts
T
)
{
(
self
.
head
self
.
body
)
}
#
[
inline
]
pub
fn
map
<
F
U
>
(
self
f
:
F
)
-
>
Request
<
U
>
where
F
:
FnOnce
(
T
)
-
>
U
{
Request
{
body
:
f
(
self
.
body
)
head
:
self
.
head
}
}
}
impl
<
T
:
Default
>
Default
for
Request
<
T
>
{
fn
default
(
)
-
>
Request
<
T
>
{
Request
:
:
new
(
T
:
:
default
(
)
)
}
}
impl
<
T
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Request
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Request
"
)
.
field
(
"
method
"
self
.
method
(
)
)
.
field
(
"
uri
"
self
.
uri
(
)
)
.
field
(
"
version
"
&
self
.
version
(
)
)
.
field
(
"
headers
"
self
.
headers
(
)
)
.
field
(
"
body
"
self
.
body
(
)
)
.
finish
(
)
}
}
impl
Parts
{
fn
new
(
)
-
>
Parts
{
Parts
{
method
:
Method
:
:
default
(
)
uri
:
Uri
:
:
default
(
)
version
:
Version
:
:
default
(
)
headers
:
HeaderMap
:
:
default
(
)
extensions
:
Extensions
:
:
default
(
)
_priv
:
(
)
}
}
}
impl
fmt
:
:
Debug
for
Parts
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Parts
"
)
.
field
(
"
method
"
&
self
.
method
)
.
field
(
"
uri
"
&
self
.
uri
)
.
field
(
"
version
"
&
self
.
version
)
.
field
(
"
headers
"
&
self
.
headers
)
.
finish
(
)
}
}
impl
Builder
{
#
[
inline
]
pub
fn
new
(
)
-
>
Builder
{
Builder
:
:
default
(
)
}
pub
fn
method
<
T
>
(
&
mut
self
method
:
T
)
-
>
&
mut
Builder
where
Method
:
HttpTryFrom
<
T
>
{
if
let
Some
(
head
)
=
head
(
&
mut
self
.
head
&
self
.
err
)
{
match
HttpTryFrom
:
:
try_from
(
method
)
{
Ok
(
s
)
=
>
head
.
method
=
s
Err
(
e
)
=
>
self
.
err
=
Some
(
e
.
into
(
)
)
}
}
self
}
pub
fn
uri
<
T
>
(
&
mut
self
uri
:
T
)
-
>
&
mut
Builder
where
Uri
:
HttpTryFrom
<
T
>
{
if
let
Some
(
head
)
=
head
(
&
mut
self
.
head
&
self
.
err
)
{
match
HttpTryFrom
:
:
try_from
(
uri
)
{
Ok
(
s
)
=
>
head
.
uri
=
s
Err
(
e
)
=
>
self
.
err
=
Some
(
e
.
into
(
)
)
}
}
self
}
pub
fn
version
(
&
mut
self
version
:
Version
)
-
>
&
mut
Builder
{
if
let
Some
(
head
)
=
head
(
&
mut
self
.
head
&
self
.
err
)
{
head
.
version
=
version
;
}
self
}
pub
fn
header
<
K
V
>
(
&
mut
self
key
:
K
value
:
V
)
-
>
&
mut
Builder
where
HeaderName
:
HttpTryFrom
<
K
>
HeaderValue
:
HttpTryFrom
<
V
>
{
if
let
Some
(
head
)
=
head
(
&
mut
self
.
head
&
self
.
err
)
{
match
<
HeaderName
as
HttpTryFrom
<
K
>
>
:
:
try_from
(
key
)
{
Ok
(
key
)
=
>
{
match
<
HeaderValue
as
HttpTryFrom
<
V
>
>
:
:
try_from
(
value
)
{
Ok
(
value
)
=
>
{
head
.
headers
.
append
(
key
value
)
;
}
Err
(
e
)
=
>
self
.
err
=
Some
(
e
.
into
(
)
)
}
}
Err
(
e
)
=
>
self
.
err
=
Some
(
e
.
into
(
)
)
}
;
}
self
}
pub
fn
extension
<
T
>
(
&
mut
self
extension
:
T
)
-
>
&
mut
Builder
where
T
:
Any
+
Send
+
Sync
+
'
static
{
if
let
Some
(
head
)
=
head
(
&
mut
self
.
head
&
self
.
err
)
{
head
.
extensions
.
insert
(
extension
)
;
}
self
}
fn
take_parts
(
&
mut
self
)
-
>
Result
<
Parts
>
{
let
ret
=
self
.
head
.
take
(
)
.
expect
(
"
cannot
reuse
request
builder
"
)
;
if
let
Some
(
e
)
=
self
.
err
.
take
(
)
{
return
Err
(
e
)
}
Ok
(
ret
)
}
pub
fn
body
<
T
>
(
&
mut
self
body
:
T
)
-
>
Result
<
Request
<
T
>
>
{
Ok
(
Request
{
head
:
self
.
take_parts
(
)
?
body
:
body
}
)
}
}
fn
head
<
'
a
>
(
head
:
&
'
a
mut
Option
<
Parts
>
err
:
&
Option
<
Error
>
)
-
>
Option
<
&
'
a
mut
Parts
>
{
if
err
.
is_some
(
)
{
return
None
}
head
.
as_mut
(
)
}
impl
Default
for
Builder
{
#
[
inline
]
fn
default
(
)
-
>
Builder
{
Builder
{
head
:
Some
(
Parts
:
:
new
(
)
)
err
:
None
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
it_can_map_a_body_from_one_type_to_another
(
)
{
let
request
=
Request
:
:
builder
(
)
.
body
(
"
some
string
"
)
.
unwrap
(
)
;
let
mapped_request
=
request
.
map
(
|
s
|
{
assert_eq
!
(
s
"
some
string
"
)
;
123u32
}
)
;
assert_eq
!
(
mapped_request
.
body
(
)
&
123u32
)
;
}
}
