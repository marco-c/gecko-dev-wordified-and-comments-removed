use
crate
:
:
{
dispatcher
:
:
{
self
Dispatch
}
span
:
:
Span
}
;
use
core
:
:
{
future
:
:
Future
marker
:
:
Sized
mem
:
:
ManuallyDrop
pin
:
:
Pin
task
:
:
{
Context
Poll
}
}
;
use
pin_project_lite
:
:
pin_project
;
pub
trait
Instrument
:
Sized
{
fn
instrument
(
self
span
:
Span
)
-
>
Instrumented
<
Self
>
{
Instrumented
{
inner
:
ManuallyDrop
:
:
new
(
self
)
span
}
}
#
[
inline
]
fn
in_current_span
(
self
)
-
>
Instrumented
<
Self
>
{
self
.
instrument
(
Span
:
:
current
(
)
)
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
pub
trait
WithSubscriber
:
Sized
{
fn
with_subscriber
<
S
>
(
self
subscriber
:
S
)
-
>
WithDispatch
<
Self
>
where
S
:
Into
<
Dispatch
>
{
WithDispatch
{
inner
:
self
dispatcher
:
subscriber
.
into
(
)
}
}
#
[
inline
]
fn
with_current_subscriber
(
self
)
-
>
WithDispatch
<
Self
>
{
WithDispatch
{
inner
:
self
dispatcher
:
crate
:
:
dispatcher
:
:
get_default
(
|
default
|
default
.
clone
(
)
)
}
}
}
pin_project
!
{
/
/
/
A
[
Future
]
that
has
been
instrumented
with
a
tracing
[
Subscriber
]
.
/
/
/
/
/
/
This
type
is
returned
by
the
[
WithSubscriber
]
extension
trait
.
See
that
/
/
/
trait
'
s
documentation
for
details
.
/
/
/
/
/
/
[
Future
]
:
std
:
:
future
:
:
Future
/
/
/
[
Subscriber
]
:
crate
:
:
Subscriber
#
[
derive
(
Clone
Debug
)
]
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
pub
struct
WithDispatch
<
T
>
{
#
[
pin
]
inner
:
T
dispatcher
:
Dispatch
}
}
pin_project
!
{
/
/
/
A
[
Future
]
that
has
been
instrumented
with
a
tracing
[
Span
]
.
/
/
/
/
/
/
This
type
is
returned
by
the
[
Instrument
]
extension
trait
.
See
that
/
/
/
trait
'
s
documentation
for
details
.
/
/
/
/
/
/
[
Future
]
:
std
:
:
future
:
:
Future
/
/
/
[
Span
]
:
crate
:
:
Span
#
[
project
=
InstrumentedProj
]
#
[
project_ref
=
InstrumentedProjRef
]
#
[
derive
(
Debug
Clone
)
]
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
pub
struct
Instrumented
<
T
>
{
/
/
ManuallyDrop
is
used
here
to
to
enter
instrument
Drop
by
entering
/
/
Span
and
executing
ManuallyDrop
:
:
drop
.
#
[
pin
]
inner
:
ManuallyDrop
<
T
>
span
:
Span
}
impl
<
T
>
PinnedDrop
for
Instrumented
<
T
>
{
fn
drop
(
this
:
Pin
<
&
mut
Self
>
)
{
let
this
=
this
.
project
(
)
;
let
_enter
=
this
.
span
.
enter
(
)
;
/
/
SAFETY
:
1
.
Pin
:
:
get_unchecked_mut
(
)
is
safe
because
this
isn
'
t
/
/
different
from
wrapping
T
in
Option
and
calling
/
/
Pin
:
:
set
(
&
mut
this
.
inner
None
)
except
avoiding
/
/
additional
memory
overhead
.
/
/
2
.
ManuallyDrop
:
:
drop
(
)
is
safe
because
/
/
PinnedDrop
:
:
drop
(
)
is
guaranteed
to
be
called
only
/
/
once
.
unsafe
{
ManuallyDrop
:
:
drop
(
this
.
inner
.
get_unchecked_mut
(
)
)
}
}
}
}
impl
<
'
a
T
>
InstrumentedProj
<
'
a
T
>
{
fn
span_and_inner_pin_mut
(
self
)
-
>
(
&
'
a
mut
Span
Pin
<
&
'
a
mut
T
>
)
{
let
inner
=
unsafe
{
self
.
inner
.
map_unchecked_mut
(
|
v
|
&
mut
*
*
v
)
}
;
(
self
.
span
inner
)
}
}
impl
<
'
a
T
>
InstrumentedProjRef
<
'
a
T
>
{
fn
span_and_inner_pin_ref
(
self
)
-
>
(
&
'
a
Span
Pin
<
&
'
a
T
>
)
{
let
inner
=
unsafe
{
self
.
inner
.
map_unchecked
(
|
v
|
&
*
*
v
)
}
;
(
self
.
span
inner
)
}
}
impl
<
T
:
Future
>
Future
for
Instrumented
<
T
>
{
type
Output
=
T
:
:
Output
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
(
span
inner
)
=
self
.
project
(
)
.
span_and_inner_pin_mut
(
)
;
let
_enter
=
span
.
enter
(
)
;
inner
.
poll
(
cx
)
}
}
impl
<
T
:
Sized
>
Instrument
for
T
{
}
impl
<
T
>
Instrumented
<
T
>
{
pub
fn
span
(
&
self
)
-
>
&
Span
{
&
self
.
span
}
pub
fn
span_mut
(
&
mut
self
)
-
>
&
mut
Span
{
&
mut
self
.
span
}
pub
fn
inner
(
&
self
)
-
>
&
T
{
&
self
.
inner
}
pub
fn
inner_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
inner
}
pub
fn
inner_pin_ref
(
self
:
Pin
<
&
Self
>
)
-
>
Pin
<
&
T
>
{
self
.
project_ref
(
)
.
span_and_inner_pin_ref
(
)
.
1
}
pub
fn
inner_pin_mut
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Pin
<
&
mut
T
>
{
self
.
project
(
)
.
span_and_inner_pin_mut
(
)
.
1
}
pub
fn
into_inner
(
self
)
-
>
T
{
let
this
=
ManuallyDrop
:
:
new
(
self
)
;
let
span
:
*
const
Span
=
&
this
.
span
;
let
inner
:
*
const
ManuallyDrop
<
T
>
=
&
this
.
inner
;
let
_span
=
unsafe
{
span
.
read
(
)
}
;
let
inner
=
unsafe
{
inner
.
read
(
)
}
;
ManuallyDrop
:
:
into_inner
(
inner
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
<
T
:
Future
>
Future
for
WithDispatch
<
T
>
{
type
Output
=
T
:
:
Output
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
this
=
self
.
project
(
)
;
let
dispatcher
=
this
.
dispatcher
;
let
future
=
this
.
inner
;
let
_default
=
dispatcher
:
:
set_default
(
dispatcher
)
;
future
.
poll
(
cx
)
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
<
T
:
Sized
>
WithSubscriber
for
T
{
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
<
T
>
WithDispatch
<
T
>
{
pub
fn
dispatcher
(
&
self
)
-
>
&
Dispatch
{
&
self
.
dispatcher
}
pub
fn
inner
(
&
self
)
-
>
&
T
{
&
self
.
inner
}
pub
fn
inner_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
inner
}
pub
fn
inner_pin_ref
(
self
:
Pin
<
&
Self
>
)
-
>
Pin
<
&
T
>
{
self
.
project_ref
(
)
.
inner
}
pub
fn
inner_pin_mut
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Pin
<
&
mut
T
>
{
self
.
project
(
)
.
inner
}
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
inner
}
}
