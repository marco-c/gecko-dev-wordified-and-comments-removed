#
!
[
no_std
]
#
!
[
warn
(
unused_results
missing_docs
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
std
"
)
]
extern
crate
std
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
borrow
:
:
{
Cow
ToOwned
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
:
:
Vec
;
macro_rules
!
check
{
(
e
:
expr
c
:
expr
)
=
>
{
if
!
c
{
return
Err
(
e
)
;
}
}
;
}
trait
Static
<
T
:
Copy
>
:
Copy
{
fn
val
(
self
)
-
>
T
;
}
macro_rules
!
define
{
(
name
:
ident
:
type
:
ty
=
val
:
expr
)
=
>
{
#
[
derive
(
Copy
Clone
)
]
struct
name
;
impl
Static
<
type
>
for
name
{
fn
val
(
self
)
-
>
type
{
val
}
}
}
;
}
define
!
(
Bf
:
bool
=
false
)
;
define
!
(
Bt
:
bool
=
true
)
;
define
!
(
N1
:
usize
=
1
)
;
define
!
(
N2
:
usize
=
2
)
;
define
!
(
N3
:
usize
=
3
)
;
define
!
(
N4
:
usize
=
4
)
;
define
!
(
N5
:
usize
=
5
)
;
define
!
(
N6
:
usize
=
6
)
;
#
[
derive
(
Copy
Clone
)
]
struct
On
;
impl
<
T
:
Copy
>
Static
<
Option
<
T
>
>
for
On
{
fn
val
(
self
)
-
>
Option
<
T
>
{
None
}
}
#
[
derive
(
Copy
Clone
)
]
struct
Os
<
T
>
(
T
)
;
impl
<
T
:
Copy
>
Static
<
Option
<
T
>
>
for
Os
<
T
>
{
fn
val
(
self
)
-
>
Option
<
T
>
{
Some
(
self
.
0
)
}
}
macro_rules
!
dispatch
{
(
let
var
:
ident
:
bool
=
val
:
expr
;
(
body
:
tt
)
*
)
=
>
{
if
val
{
let
var
=
Bt
;
dispatch
!
(
(
body
)
*
)
}
else
{
let
var
=
Bf
;
dispatch
!
(
(
body
)
*
)
}
}
;
(
let
var
:
ident
:
usize
=
val
:
expr
;
(
body
:
tt
)
*
)
=
>
{
match
val
{
1
=
>
{
let
var
=
N1
;
dispatch
!
(
(
body
)
*
)
}
2
=
>
{
let
var
=
N2
;
dispatch
!
(
(
body
)
*
)
}
3
=
>
{
let
var
=
N3
;
dispatch
!
(
(
body
)
*
)
}
4
=
>
{
let
var
=
N4
;
dispatch
!
(
(
body
)
*
)
}
5
=
>
{
let
var
=
N5
;
dispatch
!
(
(
body
)
*
)
}
6
=
>
{
let
var
=
N6
;
dispatch
!
(
(
body
)
*
)
}
_
=
>
panic
!
(
)
}
}
;
(
let
var
:
ident
:
Option
<
type
:
ty
>
=
val
:
expr
;
(
body
:
tt
)
*
)
=
>
{
match
val
{
None
=
>
{
let
var
=
On
;
dispatch
!
(
(
body
)
*
)
}
Some
(
x
)
=
>
{
let
var
=
Os
(
x
)
;
dispatch
!
(
(
body
)
*
)
}
}
}
;
(
body
:
expr
)
=
>
{
body
}
;
}
unsafe
fn
chunk_unchecked
(
x
:
&
[
u8
]
n
:
usize
i
:
usize
)
-
>
&
[
u8
]
{
debug_assert
!
(
(
i
+
1
)
*
n
<
=
x
.
len
(
)
)
;
let
ptr
=
x
.
as_ptr
(
)
.
add
(
n
*
i
)
;
core
:
:
slice
:
:
from_raw_parts
(
ptr
n
)
}
unsafe
fn
chunk_mut_unchecked
(
x
:
&
mut
[
u8
]
n
:
usize
i
:
usize
)
-
>
&
mut
[
u8
]
{
debug_assert
!
(
(
i
+
1
)
*
n
<
=
x
.
len
(
)
)
;
let
ptr
=
x
.
as_mut_ptr
(
)
.
add
(
n
*
i
)
;
core
:
:
slice
:
:
from_raw_parts_mut
(
ptr
n
)
}
unsafe
fn
as_array
(
x
:
&
[
u8
]
)
-
>
&
[
u8
;
256
]
{
debug_assert_eq
!
(
x
.
len
(
)
256
)
;
&
*
(
x
.
as_ptr
(
)
as
*
const
[
u8
;
256
]
)
}
fn
div_ceil
(
x
:
usize
m
:
usize
)
-
>
usize
{
(
x
+
m
-
1
)
/
m
}
fn
floor
(
x
:
usize
m
:
usize
)
-
>
usize
{
x
/
m
*
m
}
fn
vectorize
<
F
:
FnMut
(
usize
)
>
(
n
:
usize
bs
:
usize
mut
f
:
F
)
{
for
k
in
0
.
.
n
/
bs
{
for
i
in
k
*
bs
.
.
(
k
+
1
)
*
bs
{
f
(
i
)
;
}
}
for
i
in
floor
(
n
bs
)
.
.
n
{
f
(
i
)
;
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
pub
enum
DecodeKind
{
Length
Symbol
Trailing
Padding
}
impl
core
:
:
fmt
:
:
Display
for
DecodeKind
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
let
description
=
match
self
{
DecodeKind
:
:
Length
=
>
"
invalid
length
"
DecodeKind
:
:
Symbol
=
>
"
invalid
symbol
"
DecodeKind
:
:
Trailing
=
>
"
non
-
zero
trailing
bits
"
DecodeKind
:
:
Padding
=
>
"
invalid
padding
length
"
}
;
write
!
(
f
"
{
}
"
description
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
pub
struct
DecodeError
{
pub
position
:
usize
pub
kind
:
DecodeKind
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
DecodeError
{
}
impl
core
:
:
fmt
:
:
Display
for
DecodeError
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
at
{
}
"
self
.
kind
self
.
position
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
pub
struct
DecodePartial
{
pub
read
:
usize
pub
written
:
usize
pub
error
:
DecodeError
}
const
INVALID
:
u8
=
128
;
const
IGNORE
:
u8
=
129
;
const
PADDING
:
u8
=
130
;
fn
order
(
msb
:
bool
n
:
usize
i
:
usize
)
-
>
usize
{
if
msb
{
n
-
1
-
i
}
else
{
i
}
}
fn
enc
(
bit
:
usize
)
-
>
usize
{
debug_assert
!
(
1
<
=
bit
&
&
bit
<
=
6
)
;
match
bit
{
1
|
2
|
4
=
>
1
3
|
6
=
>
3
5
=
>
5
_
=
>
unreachable
!
(
)
}
}
fn
dec
(
bit
:
usize
)
-
>
usize
{
enc
(
bit
)
*
8
/
bit
}
fn
encode_len
<
B
:
Static
<
usize
>
>
(
bit
:
B
len
:
usize
)
-
>
usize
{
div_ceil
(
8
*
len
bit
.
val
(
)
)
}
fn
encode_block
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
symbols
:
&
[
u8
;
256
]
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
{
debug_assert
!
(
input
.
len
(
)
<
=
enc
(
bit
.
val
(
)
)
)
;
debug_assert_eq
!
(
output
.
len
(
)
encode_len
(
bit
input
.
len
(
)
)
)
;
let
bit
=
bit
.
val
(
)
;
let
msb
=
msb
.
val
(
)
;
let
mut
x
=
0u64
;
for
(
i
input
)
in
input
.
iter
(
)
.
enumerate
(
)
{
x
|
=
u64
:
:
from
(
*
input
)
<
<
(
8
*
order
(
msb
enc
(
bit
)
i
)
)
;
}
for
(
i
output
)
in
output
.
iter_mut
(
)
.
enumerate
(
)
{
let
y
=
x
>
>
(
bit
*
order
(
msb
dec
(
bit
)
i
)
)
;
*
output
=
symbols
[
y
as
usize
%
256
]
;
}
}
fn
encode_mut
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
symbols
:
&
[
u8
;
256
]
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
{
debug_assert_eq
!
(
output
.
len
(
)
encode_len
(
bit
input
.
len
(
)
)
)
;
let
enc
=
enc
(
bit
.
val
(
)
)
;
let
dec
=
dec
(
bit
.
val
(
)
)
;
let
n
=
input
.
len
(
)
/
enc
;
let
bs
=
match
bit
.
val
(
)
{
5
=
>
2
6
=
>
4
_
=
>
1
}
;
vectorize
(
n
bs
|
i
|
{
let
input
=
unsafe
{
chunk_unchecked
(
input
enc
i
)
}
;
let
output
=
unsafe
{
chunk_mut_unchecked
(
output
dec
i
)
}
;
encode_block
(
bit
msb
symbols
input
output
)
;
}
)
;
encode_block
(
bit
msb
symbols
&
input
[
enc
*
n
.
.
]
&
mut
output
[
dec
*
n
.
.
]
)
;
}
fn
decode_block
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
values
:
&
[
u8
;
256
]
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
usize
>
{
debug_assert
!
(
output
.
len
(
)
<
=
enc
(
bit
.
val
(
)
)
)
;
debug_assert_eq
!
(
input
.
len
(
)
encode_len
(
bit
output
.
len
(
)
)
)
;
let
bit
=
bit
.
val
(
)
;
let
msb
=
msb
.
val
(
)
;
let
mut
x
=
0u64
;
for
j
in
0
.
.
input
.
len
(
)
{
let
y
=
values
[
input
[
j
]
as
usize
]
;
check
!
(
j
y
<
1
<
<
bit
)
;
x
|
=
u64
:
:
from
(
y
)
<
<
(
bit
*
order
(
msb
dec
(
bit
)
j
)
)
;
}
for
(
j
output
)
in
output
.
iter_mut
(
)
.
enumerate
(
)
{
*
output
=
(
x
>
>
(
8
*
order
(
msb
enc
(
bit
)
j
)
)
)
as
u8
;
}
Ok
(
(
)
)
}
fn
decode_mut
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
values
:
&
[
u8
;
256
]
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
usize
>
{
debug_assert_eq
!
(
input
.
len
(
)
encode_len
(
bit
output
.
len
(
)
)
)
;
let
enc
=
enc
(
bit
.
val
(
)
)
;
let
dec
=
dec
(
bit
.
val
(
)
)
;
let
n
=
input
.
len
(
)
/
dec
;
for
i
in
0
.
.
n
{
let
input
=
unsafe
{
chunk_unchecked
(
input
dec
i
)
}
;
let
output
=
unsafe
{
chunk_mut_unchecked
(
output
enc
i
)
}
;
decode_block
(
bit
msb
values
input
output
)
.
map_err
(
|
e
|
dec
*
i
+
e
)
?
;
}
decode_block
(
bit
msb
values
&
input
[
dec
*
n
.
.
]
&
mut
output
[
enc
*
n
.
.
]
)
.
map_err
(
|
e
|
dec
*
n
+
e
)
}
fn
check_trail
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
ctb
:
bool
values
:
&
[
u8
;
256
]
input
:
&
[
u8
]
)
-
>
Result
<
(
)
(
)
>
{
if
8
%
bit
.
val
(
)
=
=
0
|
|
!
ctb
{
return
Ok
(
(
)
)
;
}
let
trail
=
bit
.
val
(
)
*
input
.
len
(
)
%
8
;
if
trail
=
=
0
{
return
Ok
(
(
)
)
;
}
let
mut
mask
=
(
1
<
<
trail
)
-
1
;
if
!
msb
.
val
(
)
{
mask
<
<
=
bit
.
val
(
)
-
trail
;
}
check
!
(
(
)
values
[
input
[
input
.
len
(
)
-
1
]
as
usize
]
&
mask
=
=
0
)
;
Ok
(
(
)
)
}
fn
check_pad
<
B
:
Static
<
usize
>
>
(
bit
:
B
values
:
&
[
u8
;
256
]
input
:
&
[
u8
]
)
-
>
Result
<
usize
usize
>
{
let
bit
=
bit
.
val
(
)
;
debug_assert_eq
!
(
input
.
len
(
)
dec
(
bit
)
)
;
let
is_pad
=
|
x
:
&
&
u8
|
values
[
*
*
x
as
usize
]
=
=
PADDING
;
let
count
=
input
.
iter
(
)
.
rev
(
)
.
take_while
(
is_pad
)
.
count
(
)
;
let
len
=
input
.
len
(
)
-
count
;
check
!
(
len
len
>
0
&
&
bit
*
len
%
8
<
bit
)
;
Ok
(
len
)
}
fn
encode_base_len
<
B
:
Static
<
usize
>
>
(
bit
:
B
len
:
usize
)
-
>
usize
{
encode_len
(
bit
len
)
}
fn
encode_base
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
symbols
:
&
[
u8
;
256
]
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
{
debug_assert_eq
!
(
output
.
len
(
)
encode_base_len
(
bit
input
.
len
(
)
)
)
;
encode_mut
(
bit
msb
symbols
input
output
)
;
}
fn
encode_pad_len
<
B
:
Static
<
usize
>
P
:
Static
<
Option
<
u8
>
>
>
(
bit
:
B
pad
:
P
len
:
usize
)
-
>
usize
{
match
pad
.
val
(
)
{
None
=
>
encode_base_len
(
bit
len
)
Some
(
_
)
=
>
div_ceil
(
len
enc
(
bit
.
val
(
)
)
)
*
dec
(
bit
.
val
(
)
)
}
}
fn
encode_pad
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
P
:
Static
<
Option
<
u8
>
>
>
(
bit
:
B
msb
:
M
symbols
:
&
[
u8
;
256
]
spad
:
P
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
{
let
pad
=
match
spad
.
val
(
)
{
None
=
>
return
encode_base
(
bit
msb
symbols
input
output
)
Some
(
pad
)
=
>
pad
}
;
debug_assert_eq
!
(
output
.
len
(
)
encode_pad_len
(
bit
spad
input
.
len
(
)
)
)
;
let
olen
=
encode_base_len
(
bit
input
.
len
(
)
)
;
encode_base
(
bit
msb
symbols
input
&
mut
output
[
.
.
olen
]
)
;
for
output
in
output
.
iter_mut
(
)
.
skip
(
olen
)
{
*
output
=
pad
;
}
}
fn
encode_wrap_len
<
'
a
B
:
Static
<
usize
>
P
:
Static
<
Option
<
u8
>
>
W
:
Static
<
Option
<
(
usize
&
'
a
[
u8
]
)
>
>
>
(
bit
:
B
pad
:
P
wrap
:
W
ilen
:
usize
)
-
>
usize
{
let
olen
=
encode_pad_len
(
bit
pad
ilen
)
;
match
wrap
.
val
(
)
{
None
=
>
olen
Some
(
(
col
end
)
)
=
>
olen
+
end
.
len
(
)
*
div_ceil
(
olen
col
)
}
}
fn
encode_wrap_mut
<
'
a
B
:
Static
<
usize
>
M
:
Static
<
bool
>
P
:
Static
<
Option
<
u8
>
>
W
:
Static
<
Option
<
(
usize
&
'
a
[
u8
]
)
>
>
>
(
bit
:
B
msb
:
M
symbols
:
&
[
u8
;
256
]
pad
:
P
wrap
:
W
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
{
let
(
col
end
)
=
match
wrap
.
val
(
)
{
None
=
>
return
encode_pad
(
bit
msb
symbols
pad
input
output
)
Some
(
(
col
end
)
)
=
>
(
col
end
)
}
;
debug_assert_eq
!
(
output
.
len
(
)
encode_wrap_len
(
bit
pad
wrap
input
.
len
(
)
)
)
;
debug_assert_eq
!
(
col
%
dec
(
bit
.
val
(
)
)
0
)
;
let
col
=
col
/
dec
(
bit
.
val
(
)
)
;
let
enc
=
col
*
enc
(
bit
.
val
(
)
)
;
let
dec
=
col
*
dec
(
bit
.
val
(
)
)
+
end
.
len
(
)
;
let
olen
=
dec
-
end
.
len
(
)
;
let
n
=
input
.
len
(
)
/
enc
;
for
i
in
0
.
.
n
{
let
input
=
unsafe
{
chunk_unchecked
(
input
enc
i
)
}
;
let
output
=
unsafe
{
chunk_mut_unchecked
(
output
dec
i
)
}
;
encode_base
(
bit
msb
symbols
input
&
mut
output
[
.
.
olen
]
)
;
output
[
olen
.
.
]
.
copy_from_slice
(
end
)
;
}
if
input
.
len
(
)
>
enc
*
n
{
let
olen
=
dec
*
n
+
encode_pad_len
(
bit
pad
input
.
len
(
)
-
enc
*
n
)
;
encode_pad
(
bit
msb
symbols
pad
&
input
[
enc
*
n
.
.
]
&
mut
output
[
dec
*
n
.
.
olen
]
)
;
output
[
olen
.
.
]
.
copy_from_slice
(
end
)
;
}
}
fn
decode_wrap_len
<
B
:
Static
<
usize
>
P
:
Static
<
bool
>
>
(
bit
:
B
pad
:
P
len
:
usize
)
-
>
(
usize
usize
)
{
let
bit
=
bit
.
val
(
)
;
if
pad
.
val
(
)
{
(
floor
(
len
dec
(
bit
)
)
len
/
dec
(
bit
)
*
enc
(
bit
)
)
}
else
{
let
trail
=
bit
*
len
%
8
;
(
len
-
trail
/
bit
bit
*
len
/
8
)
}
}
fn
decode_pad_len
<
B
:
Static
<
usize
>
P
:
Static
<
bool
>
>
(
bit
:
B
pad
:
P
len
:
usize
)
-
>
Result
<
usize
DecodeError
>
{
let
(
ilen
olen
)
=
decode_wrap_len
(
bit
pad
len
)
;
check
!
(
DecodeError
{
position
:
ilen
kind
:
DecodeKind
:
:
Length
}
ilen
=
=
len
)
;
Ok
(
olen
)
}
fn
decode_base_len
<
B
:
Static
<
usize
>
>
(
bit
:
B
len
:
usize
)
-
>
Result
<
usize
DecodeError
>
{
decode_pad_len
(
bit
Bf
len
)
}
fn
decode_base_mut
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
ctb
:
bool
values
:
&
[
u8
;
256
]
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
usize
DecodePartial
>
{
debug_assert_eq
!
(
Ok
(
output
.
len
(
)
)
decode_base_len
(
bit
input
.
len
(
)
)
)
;
let
fail
=
|
pos
kind
|
DecodePartial
{
read
:
pos
/
dec
(
bit
.
val
(
)
)
*
dec
(
bit
.
val
(
)
)
written
:
pos
/
dec
(
bit
.
val
(
)
)
*
enc
(
bit
.
val
(
)
)
error
:
DecodeError
{
position
:
pos
kind
}
}
;
decode_mut
(
bit
msb
values
input
output
)
.
map_err
(
|
pos
|
fail
(
pos
DecodeKind
:
:
Symbol
)
)
?
;
check_trail
(
bit
msb
ctb
values
input
)
.
map_err
(
|
(
)
|
fail
(
input
.
len
(
)
-
1
DecodeKind
:
:
Trailing
)
)
?
;
Ok
(
output
.
len
(
)
)
}
fn
decode_pad_mut
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
P
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
ctb
:
bool
values
:
&
[
u8
;
256
]
pad
:
P
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
usize
DecodePartial
>
{
if
!
pad
.
val
(
)
{
return
decode_base_mut
(
bit
msb
ctb
values
input
output
)
;
}
debug_assert_eq
!
(
Ok
(
output
.
len
(
)
)
decode_pad_len
(
bit
pad
input
.
len
(
)
)
)
;
let
enc
=
enc
(
bit
.
val
(
)
)
;
let
dec
=
dec
(
bit
.
val
(
)
)
;
let
mut
inpos
=
0
;
let
mut
outpos
=
0
;
let
mut
outend
=
output
.
len
(
)
;
while
inpos
<
input
.
len
(
)
{
match
decode_base_mut
(
bit
msb
ctb
values
&
input
[
inpos
.
.
]
&
mut
output
[
outpos
.
.
outend
]
)
{
Ok
(
written
)
=
>
{
if
cfg
!
(
debug_assertions
)
{
inpos
=
input
.
len
(
)
;
}
outpos
+
=
written
;
break
;
}
Err
(
partial
)
=
>
{
inpos
+
=
partial
.
read
;
outpos
+
=
partial
.
written
;
}
}
let
inlen
=
check_pad
(
bit
values
&
input
[
inpos
.
.
inpos
+
dec
]
)
.
map_err
(
|
pos
|
DecodePartial
{
read
:
inpos
written
:
outpos
error
:
DecodeError
{
position
:
inpos
+
pos
kind
:
DecodeKind
:
:
Padding
}
}
)
?
;
let
outlen
=
decode_base_len
(
bit
inlen
)
.
unwrap
(
)
;
let
written
=
decode_base_mut
(
bit
msb
ctb
values
&
input
[
inpos
.
.
inpos
+
inlen
]
&
mut
output
[
outpos
.
.
outpos
+
outlen
]
)
.
map_err
(
|
partial
|
{
debug_assert_eq
!
(
partial
.
read
0
)
;
debug_assert_eq
!
(
partial
.
written
0
)
;
DecodePartial
{
read
:
inpos
written
:
outpos
error
:
DecodeError
{
position
:
inpos
+
partial
.
error
.
position
kind
:
partial
.
error
.
kind
}
}
}
)
?
;
debug_assert_eq
!
(
written
outlen
)
;
inpos
+
=
dec
;
outpos
+
=
outlen
;
outend
-
=
enc
-
outlen
;
}
debug_assert_eq
!
(
inpos
input
.
len
(
)
)
;
debug_assert_eq
!
(
outpos
outend
)
;
Ok
(
outend
)
}
fn
skip_ignore
(
values
:
&
[
u8
;
256
]
input
:
&
[
u8
]
mut
inpos
:
usize
)
-
>
usize
{
while
inpos
<
input
.
len
(
)
&
&
values
[
input
[
inpos
]
as
usize
]
=
=
IGNORE
{
inpos
+
=
1
;
}
inpos
}
fn
decode_wrap_block
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
P
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
ctb
:
bool
values
:
&
[
u8
;
256
]
pad
:
P
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
usize
usize
)
DecodeError
>
{
let
dec
=
dec
(
bit
.
val
(
)
)
;
let
mut
buf
=
[
0u8
;
8
]
;
let
mut
shift
=
[
0usize
;
8
]
;
let
mut
bufpos
=
0
;
let
mut
inpos
=
0
;
while
bufpos
<
dec
{
inpos
=
skip_ignore
(
values
input
inpos
)
;
if
inpos
=
=
input
.
len
(
)
{
break
;
}
shift
[
bufpos
]
=
inpos
;
buf
[
bufpos
]
=
input
[
inpos
]
;
bufpos
+
=
1
;
inpos
+
=
1
;
}
let
olen
=
decode_pad_len
(
bit
pad
bufpos
)
.
map_err
(
|
mut
e
|
{
e
.
position
=
shift
[
e
.
position
]
;
e
}
)
?
;
let
written
=
decode_pad_mut
(
bit
msb
ctb
values
pad
&
buf
[
.
.
bufpos
]
&
mut
output
[
.
.
olen
]
)
.
map_err
(
|
partial
|
{
debug_assert_eq
!
(
partial
.
read
0
)
;
debug_assert_eq
!
(
partial
.
written
0
)
;
DecodeError
{
position
:
shift
[
partial
.
error
.
position
]
kind
:
partial
.
error
.
kind
}
}
)
?
;
Ok
(
(
inpos
written
)
)
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
decode_wrap_mut
<
B
:
Static
<
usize
>
M
:
Static
<
bool
>
P
:
Static
<
bool
>
I
:
Static
<
bool
>
>
(
bit
:
B
msb
:
M
ctb
:
bool
values
:
&
[
u8
;
256
]
pad
:
P
has_ignore
:
I
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
usize
DecodePartial
>
{
if
!
has_ignore
.
val
(
)
{
return
decode_pad_mut
(
bit
msb
ctb
values
pad
input
output
)
;
}
debug_assert_eq
!
(
output
.
len
(
)
decode_wrap_len
(
bit
pad
input
.
len
(
)
)
.
1
)
;
let
mut
inpos
=
0
;
let
mut
outpos
=
0
;
while
inpos
<
input
.
len
(
)
{
let
(
inlen
outlen
)
=
decode_wrap_len
(
bit
pad
input
.
len
(
)
-
inpos
)
;
match
decode_pad_mut
(
bit
msb
ctb
values
pad
&
input
[
inpos
.
.
inpos
+
inlen
]
&
mut
output
[
outpos
.
.
outpos
+
outlen
]
)
{
Ok
(
written
)
=
>
{
inpos
+
=
inlen
;
outpos
+
=
written
;
break
;
}
Err
(
partial
)
=
>
{
inpos
+
=
partial
.
read
;
outpos
+
=
partial
.
written
;
}
}
let
(
ipos
opos
)
=
decode_wrap_block
(
bit
msb
ctb
values
pad
&
input
[
inpos
.
.
]
&
mut
output
[
outpos
.
.
]
)
.
map_err
(
|
mut
error
|
{
error
.
position
+
=
inpos
;
DecodePartial
{
read
:
inpos
written
:
outpos
error
}
}
)
?
;
inpos
+
=
ipos
;
outpos
+
=
opos
;
}
let
inpos
=
skip_ignore
(
values
input
inpos
)
;
if
inpos
=
=
input
.
len
(
)
{
Ok
(
outpos
)
}
else
{
Err
(
DecodePartial
{
read
:
inpos
written
:
outpos
error
:
DecodeError
{
position
:
inpos
kind
:
DecodeKind
:
:
Length
}
}
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
enum
BitOrder
{
MostSignificantFirst
LeastSignificantFirst
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
BitOrder
:
:
*
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
type
InternalEncoding
=
Cow
<
'
static
[
u8
]
>
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
not
(
feature
=
"
alloc
"
)
)
]
pub
type
InternalEncoding
=
&
'
static
[
u8
]
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
Encoding
(
pub
InternalEncoding
)
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
Translate
{
pub
from
:
String
pub
to
:
String
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
Wrap
{
pub
width
:
usize
pub
separator
:
String
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
Specification
{
pub
symbols
:
String
pub
bit_order
:
BitOrder
pub
check_trailing_bits
:
bool
pub
padding
:
Option
<
char
>
pub
ignore
:
String
pub
wrap
:
Wrap
pub
translate
:
Translate
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Default
for
Specification
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
Encoding
{
fn
sym
(
&
self
)
-
>
&
[
u8
;
256
]
{
unsafe
{
as_array
(
&
self
.
0
[
0
.
.
256
]
)
}
}
fn
val
(
&
self
)
-
>
&
[
u8
;
256
]
{
unsafe
{
as_array
(
&
self
.
0
[
256
.
.
512
]
)
}
}
fn
pad
(
&
self
)
-
>
Option
<
u8
>
{
if
self
.
0
[
512
]
<
128
{
Some
(
self
.
0
[
512
]
)
}
else
{
None
}
}
fn
ctb
(
&
self
)
-
>
bool
{
self
.
0
[
513
]
&
0x10
!
=
0
}
fn
msb
(
&
self
)
-
>
bool
{
self
.
0
[
513
]
&
0x8
!
=
0
}
fn
bit
(
&
self
)
-
>
usize
{
(
self
.
0
[
513
]
&
0x7
)
as
usize
}
fn
wrap
(
&
self
)
-
>
Option
<
(
usize
&
[
u8
]
)
>
{
if
self
.
0
.
len
(
)
<
=
515
{
return
None
;
}
Some
(
(
self
.
0
[
514
]
as
usize
&
self
.
0
[
515
.
.
]
)
)
}
fn
has_ignore
(
&
self
)
-
>
bool
{
self
.
0
.
len
(
)
>
=
515
}
pub
fn
encode_len
(
&
self
len
:
usize
)
-
>
usize
{
dispatch
!
{
let
bit
:
usize
=
self
.
bit
(
)
;
let
pad
:
Option
<
u8
>
=
self
.
pad
(
)
;
let
wrap
:
Option
<
(
usize
&
[
u8
]
)
>
=
self
.
wrap
(
)
;
encode_wrap_len
(
bit
pad
wrap
len
)
}
}
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
pub
fn
encode_mut
(
&
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
{
assert_eq
!
(
output
.
len
(
)
self
.
encode_len
(
input
.
len
(
)
)
)
;
dispatch
!
{
let
bit
:
usize
=
self
.
bit
(
)
;
let
msb
:
bool
=
self
.
msb
(
)
;
let
pad
:
Option
<
u8
>
=
self
.
pad
(
)
;
let
wrap
:
Option
<
(
usize
&
[
u8
]
)
>
=
self
.
wrap
(
)
;
encode_wrap_mut
(
bit
msb
self
.
sym
(
)
pad
wrap
input
output
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
encode_append
(
&
self
input
:
&
[
u8
]
output
:
&
mut
String
)
{
let
output
=
unsafe
{
output
.
as_mut_vec
(
)
}
;
let
output_len
=
output
.
len
(
)
;
output
.
resize
(
output_len
+
self
.
encode_len
(
input
.
len
(
)
)
0u8
)
;
self
.
encode_mut
(
input
&
mut
output
[
output_len
.
.
]
)
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
encode
(
&
self
input
:
&
[
u8
]
)
-
>
String
{
let
mut
output
=
vec
!
[
0u8
;
self
.
encode_len
(
input
.
len
(
)
)
]
;
self
.
encode_mut
(
input
&
mut
output
)
;
unsafe
{
String
:
:
from_utf8_unchecked
(
output
)
}
}
pub
fn
decode_len
(
&
self
len
:
usize
)
-
>
Result
<
usize
DecodeError
>
{
let
(
ilen
olen
)
=
dispatch
!
{
let
bit
:
usize
=
self
.
bit
(
)
;
let
pad
:
bool
=
self
.
pad
(
)
.
is_some
(
)
;
decode_wrap_len
(
bit
pad
len
)
}
;
check
!
(
DecodeError
{
position
:
ilen
kind
:
DecodeKind
:
:
Length
}
self
.
has_ignore
(
)
|
|
len
=
=
ilen
)
;
Ok
(
olen
)
}
#
[
allow
(
clippy
:
:
cognitive_complexity
)
]
pub
fn
decode_mut
(
&
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
usize
DecodePartial
>
{
assert_eq
!
(
Ok
(
output
.
len
(
)
)
self
.
decode_len
(
input
.
len
(
)
)
)
;
dispatch
!
{
let
bit
:
usize
=
self
.
bit
(
)
;
let
msb
:
bool
=
self
.
msb
(
)
;
let
pad
:
bool
=
self
.
pad
(
)
.
is_some
(
)
;
let
has_ignore
:
bool
=
self
.
has_ignore
(
)
;
decode_wrap_mut
(
bit
msb
self
.
ctb
(
)
self
.
val
(
)
pad
has_ignore
input
output
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
decode
(
&
self
input
:
&
[
u8
]
)
-
>
Result
<
Vec
<
u8
>
DecodeError
>
{
let
mut
output
=
vec
!
[
0u8
;
self
.
decode_len
(
input
.
len
(
)
)
?
]
;
let
len
=
self
.
decode_mut
(
input
&
mut
output
)
.
map_err
(
|
partial
|
partial
.
error
)
?
;
output
.
truncate
(
len
)
;
Ok
(
output
)
}
pub
fn
bit_width
(
&
self
)
-
>
usize
{
self
.
bit
(
)
}
pub
fn
is_canonical
(
&
self
)
-
>
bool
{
if
!
self
.
ctb
(
)
{
return
false
;
}
let
bit
=
self
.
bit
(
)
;
let
sym
=
self
.
sym
(
)
;
let
val
=
self
.
val
(
)
;
for
i
in
0
.
.
256
{
if
val
[
i
]
=
=
INVALID
{
continue
;
}
if
val
[
i
]
>
=
1
<
<
bit
{
return
false
;
}
if
sym
[
val
[
i
]
as
usize
]
!
=
i
as
u8
{
return
false
;
}
}
true
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
specification
(
&
self
)
-
>
Specification
{
let
mut
specification
=
Specification
:
:
new
(
)
;
specification
.
symbols
.
push_str
(
core
:
:
str
:
:
from_utf8
(
&
self
.
sym
(
)
[
0
.
.
1
<
<
self
.
bit
(
)
]
)
.
unwrap
(
)
)
;
specification
.
bit_order
=
if
self
.
msb
(
)
{
MostSignificantFirst
}
else
{
LeastSignificantFirst
}
;
specification
.
check_trailing_bits
=
self
.
ctb
(
)
;
if
let
Some
(
pad
)
=
self
.
pad
(
)
{
specification
.
padding
=
Some
(
pad
as
char
)
;
}
for
i
in
0
.
.
128u8
{
if
self
.
val
(
)
[
i
as
usize
]
!
=
IGNORE
{
continue
;
}
specification
.
ignore
.
push
(
i
as
char
)
;
}
if
let
Some
(
(
col
end
)
)
=
self
.
wrap
(
)
{
specification
.
wrap
.
width
=
col
;
specification
.
wrap
.
separator
=
core
:
:
str
:
:
from_utf8
(
end
)
.
unwrap
(
)
.
to_owned
(
)
;
}
for
i
in
0
.
.
128u8
{
let
canonical
=
if
self
.
val
(
)
[
i
as
usize
]
<
1
<
<
self
.
bit
(
)
{
self
.
sym
(
)
[
self
.
val
(
)
[
i
as
usize
]
as
usize
]
}
else
if
self
.
val
(
)
[
i
as
usize
]
=
=
PADDING
{
self
.
pad
(
)
.
unwrap
(
)
}
else
{
continue
;
}
;
if
i
=
=
canonical
{
continue
;
}
specification
.
translate
.
from
.
push
(
i
as
char
)
;
specification
.
translate
.
to
.
push
(
canonical
as
char
)
;
}
specification
}
#
[
doc
(
hidden
)
]
pub
const
fn
internal_new
(
implementation
:
&
'
static
[
u8
]
)
-
>
Encoding
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
let
encoding
=
Encoding
(
Cow
:
:
Borrowed
(
implementation
)
)
;
#
[
cfg
(
not
(
feature
=
"
alloc
"
)
)
]
let
encoding
=
Encoding
(
implementation
)
;
encoding
}
#
[
doc
(
hidden
)
]
pub
fn
internal_implementation
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
enum
SpecificationErrorImpl
{
BadSize
NotAscii
Duplicate
(
u8
)
ExtraPadding
WrapLength
WrapWidth
(
u8
)
FromTo
Undefined
(
u8
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
SpecificationErrorImpl
:
:
*
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
SpecificationError
(
SpecificationErrorImpl
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
core
:
:
fmt
:
:
Display
for
SpecificationError
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
match
self
.
0
{
BadSize
=
>
write
!
(
f
"
invalid
number
of
symbols
"
)
NotAscii
=
>
write
!
(
f
"
non
-
ascii
character
"
)
Duplicate
(
c
)
=
>
write
!
(
f
"
{
:
?
}
has
conflicting
definitions
"
c
as
char
)
ExtraPadding
=
>
write
!
(
f
"
unnecessary
padding
"
)
WrapLength
=
>
write
!
(
f
"
invalid
wrap
width
or
separator
length
"
)
WrapWidth
(
x
)
=
>
write
!
(
f
"
wrap
width
not
a
multiple
of
{
}
"
x
)
FromTo
=
>
write
!
(
f
"
translate
from
/
to
length
mismatch
"
)
Undefined
(
c
)
=
>
write
!
(
f
"
{
:
?
}
is
undefined
"
c
as
char
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
std
:
:
error
:
:
Error
for
SpecificationError
{
fn
description
(
&
self
)
-
>
&
str
{
match
self
.
0
{
BadSize
=
>
"
invalid
number
of
symbols
"
NotAscii
=
>
"
non
-
ascii
character
"
Duplicate
(
_
)
=
>
"
conflicting
definitions
"
ExtraPadding
=
>
"
unnecessary
padding
"
WrapLength
=
>
"
invalid
wrap
width
or
separator
length
"
WrapWidth
(
_
)
=
>
"
wrap
width
not
a
multiple
"
FromTo
=
>
"
translate
from
/
to
length
mismatch
"
Undefined
(
_
)
=
>
"
undefined
character
"
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Specification
{
pub
fn
new
(
)
-
>
Specification
{
Specification
{
symbols
:
String
:
:
new
(
)
bit_order
:
MostSignificantFirst
check_trailing_bits
:
true
padding
:
None
ignore
:
String
:
:
new
(
)
wrap
:
Wrap
{
width
:
0
separator
:
String
:
:
new
(
)
}
translate
:
Translate
{
from
:
String
:
:
new
(
)
to
:
String
:
:
new
(
)
}
}
}
pub
fn
encoding
(
&
self
)
-
>
Result
<
Encoding
SpecificationError
>
{
let
symbols
=
self
.
symbols
.
as_bytes
(
)
;
let
bit
:
usize
=
match
symbols
.
len
(
)
{
2
=
>
1
4
=
>
2
8
=
>
3
16
=
>
4
32
=
>
5
64
=
>
6
_
=
>
return
Err
(
SpecificationError
(
BadSize
)
)
}
;
let
mut
values
=
[
INVALID
;
128
]
;
let
set
=
|
v
:
&
mut
[
u8
;
128
]
i
:
u8
x
:
u8
|
{
check
!
(
SpecificationError
(
NotAscii
)
i
<
128
)
;
if
v
[
i
as
usize
]
=
=
x
{
return
Ok
(
(
)
)
;
}
check
!
(
SpecificationError
(
Duplicate
(
i
)
)
v
[
i
as
usize
]
=
=
INVALID
)
;
v
[
i
as
usize
]
=
x
;
Ok
(
(
)
)
}
;
for
(
v
symbols
)
in
symbols
.
iter
(
)
.
enumerate
(
)
{
set
(
&
mut
values
*
symbols
v
as
u8
)
?
;
}
let
msb
=
self
.
bit_order
=
=
MostSignificantFirst
;
let
ctb
=
self
.
check_trailing_bits
|
|
8
%
bit
=
=
0
;
let
pad
=
match
self
.
padding
{
None
=
>
None
Some
(
pad
)
=
>
{
check
!
(
SpecificationError
(
ExtraPadding
)
8
%
bit
!
=
0
)
;
check
!
(
SpecificationError
(
NotAscii
)
pad
.
len_utf8
(
)
=
=
1
)
;
set
(
&
mut
values
pad
as
u8
PADDING
)
?
;
Some
(
pad
as
u8
)
}
}
;
for
i
in
self
.
ignore
.
bytes
(
)
{
set
(
&
mut
values
i
IGNORE
)
?
;
}
let
wrap
=
if
self
.
wrap
.
separator
.
is_empty
(
)
|
|
self
.
wrap
.
width
=
=
0
{
None
}
else
{
Some
(
(
self
.
wrap
.
width
self
.
wrap
.
separator
.
as_bytes
(
)
)
)
}
;
if
let
Some
(
(
col
end
)
)
=
wrap
{
check
!
(
SpecificationError
(
WrapLength
)
col
<
256
&
&
end
.
len
(
)
<
256
)
;
check
!
(
SpecificationError
(
WrapWidth
(
dec
(
bit
)
as
u8
)
)
col
%
dec
(
bit
)
=
=
0
)
;
for
i
in
end
.
iter
(
)
{
set
(
&
mut
values
*
i
IGNORE
)
?
;
}
}
let
from
=
self
.
translate
.
from
.
as_bytes
(
)
;
let
to
=
self
.
translate
.
to
.
as_bytes
(
)
;
check
!
(
SpecificationError
(
FromTo
)
from
.
len
(
)
=
=
to
.
len
(
)
)
;
for
i
in
0
.
.
from
.
len
(
)
{
check
!
(
SpecificationError
(
NotAscii
)
to
[
i
]
<
128
)
;
let
v
=
values
[
to
[
i
]
as
usize
]
;
check
!
(
SpecificationError
(
Undefined
(
to
[
i
]
)
)
v
!
=
INVALID
)
;
set
(
&
mut
values
from
[
i
]
v
)
?
;
}
let
mut
encoding
=
Vec
:
:
new
(
)
;
for
_
in
0
.
.
256
/
symbols
.
len
(
)
{
encoding
.
extend_from_slice
(
symbols
)
;
}
encoding
.
extend_from_slice
(
&
values
)
;
encoding
.
extend_from_slice
(
&
[
INVALID
;
128
]
)
;
match
pad
{
None
=
>
encoding
.
push
(
INVALID
)
Some
(
pad
)
=
>
encoding
.
push
(
pad
)
}
encoding
.
push
(
bit
as
u8
)
;
if
msb
{
encoding
[
513
]
|
=
0x08
;
}
if
ctb
{
encoding
[
513
]
|
=
0x10
;
}
if
let
Some
(
(
col
end
)
)
=
wrap
{
encoding
.
push
(
col
as
u8
)
;
encoding
.
extend_from_slice
(
end
)
;
}
else
if
values
.
contains
(
&
IGNORE
)
{
encoding
.
push
(
0
)
;
}
Ok
(
Encoding
(
Cow
:
:
Owned
(
encoding
)
)
)
}
}
pub
const
HEXLOWER
:
Encoding
=
Encoding
:
:
internal_new
(
HEXLOWER_IMPL
)
;
const
HEXLOWER_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
10
11
12
13
14
15
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
28
]
;
pub
const
HEXLOWER_PERMISSIVE
:
Encoding
=
Encoding
:
:
internal_new
(
HEXLOWER_PERMISSIVE_IMPL
)
;
const
HEXLOWER_PERMISSIVE_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
10
11
12
13
14
15
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
10
11
12
13
14
15
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
28
]
;
pub
const
HEXUPPER
:
Encoding
=
Encoding
:
:
internal_new
(
HEXUPPER_IMPL
)
;
const
HEXUPPER_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
10
11
12
13
14
15
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
28
]
;
pub
const
HEXUPPER_PERMISSIVE
:
Encoding
=
Encoding
:
:
internal_new
(
HEXUPPER_PERMISSIVE_IMPL
)
;
const
HEXUPPER_PERMISSIVE_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
10
11
12
13
14
15
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
10
11
12
13
14
15
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
28
]
;
pub
const
BASE32
:
Encoding
=
Encoding
:
:
internal_new
(
BASE32_IMPL
)
;
const
BASE32_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
26
27
28
29
30
31
128
128
128
128
128
130
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
61
29
]
;
pub
const
BASE32_NOPAD
:
Encoding
=
Encoding
:
:
internal_new
(
BASE32_NOPAD_IMPL
)
;
const
BASE32_NOPAD_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
50
51
52
53
54
55
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
26
27
28
29
30
31
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
29
]
;
pub
const
BASE32HEX
:
Encoding
=
Encoding
:
:
internal_new
(
BASE32HEX_IMPL
)
;
const
BASE32HEX_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
130
128
128
128
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
61
29
]
;
pub
const
BASE32HEX_NOPAD
:
Encoding
=
Encoding
:
:
internal_new
(
BASE32HEX_NOPAD_IMPL
)
;
const
BASE32HEX_NOPAD_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
48
49
50
51
52
53
54
55
56
57
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
29
]
;
pub
const
BASE32_DNSSEC
:
Encoding
=
Encoding
:
:
internal_new
(
BASE32_DNSSEC_IMPL
)
;
const
BASE32_DNSSEC_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
48
49
50
51
52
53
54
55
56
57
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
128
128
128
128
128
128
128
128
128
128
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
29
]
;
pub
const
BASE32_DNSCURVE
:
Encoding
=
Encoding
:
:
internal_new
(
BASE32_DNSCURVE_IMPL
)
;
const
BASE32_DNSCURVE_IMPL
:
&
[
u8
]
=
&
[
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
98
99
100
102
103
104
106
107
108
109
110
112
113
114
115
116
117
118
119
120
121
122
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
128
128
128
128
128
128
128
128
10
11
12
128
13
14
15
128
16
17
18
19
20
128
21
22
23
24
25
26
27
28
29
30
31
128
128
128
128
128
128
128
10
11
12
128
13
14
15
128
16
17
18
19
20
128
21
22
23
24
25
26
27
28
29
30
31
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
21
]
;
pub
const
BASE64
:
Encoding
=
Encoding
:
:
internal_new
(
BASE64_IMPL
)
;
const
BASE64_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
62
128
128
128
63
52
53
54
55
56
57
58
59
60
61
128
128
128
130
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
128
128
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
61
30
]
;
pub
const
BASE64_NOPAD
:
Encoding
=
Encoding
:
:
internal_new
(
BASE64_NOPAD_IMPL
)
;
const
BASE64_NOPAD_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
62
128
128
128
63
52
53
54
55
56
57
58
59
60
61
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
128
128
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
30
]
;
pub
const
BASE64_MIME
:
Encoding
=
Encoding
:
:
internal_new
(
BASE64_MIME_IMPL
)
;
const
BASE64_MIME_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
43
47
128
128
128
128
128
128
128
128
128
128
129
128
128
129
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
62
128
128
128
63
52
53
54
55
56
57
58
59
60
61
128
128
128
130
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
128
128
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
61
30
76
13
10
]
;
pub
const
BASE64URL
:
Encoding
=
Encoding
:
:
internal_new
(
BASE64URL_IMPL
)
;
const
BASE64URL_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
62
128
128
52
53
54
55
56
57
58
59
60
61
128
128
128
130
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
63
128
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
61
30
]
;
pub
const
BASE64URL_NOPAD
:
Encoding
=
Encoding
:
:
internal_new
(
BASE64URL_NOPAD_IMPL
)
;
const
BASE64URL_NOPAD_IMPL
:
&
[
u8
]
=
&
[
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
48
49
50
51
52
53
54
55
56
57
45
95
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
62
128
128
52
53
54
55
56
57
58
59
60
61
128
128
128
128
128
128
128
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
128
128
128
128
63
128
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
128
30
]
;
