#
!
[
deny
(
rust_2018_idioms
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_cfg
)
)
]
#
!
[
cfg_attr
(
docsrs
feature
(
doc_auto_cfg
)
)
]
#
[
cfg
(
not
(
oneshot_loom
)
)
]
extern
crate
alloc
;
use
core
:
:
{
marker
:
:
PhantomData
mem
:
:
{
self
MaybeUninit
}
ptr
:
:
{
self
NonNull
}
}
;
#
[
cfg
(
not
(
oneshot_loom
)
)
]
use
core
:
:
{
cell
:
:
UnsafeCell
sync
:
:
atomic
:
:
{
fence
AtomicU8
Ordering
:
:
*
}
}
;
#
[
cfg
(
oneshot_loom
)
]
use
loom
:
:
{
cell
:
:
UnsafeCell
sync
:
:
atomic
:
:
{
fence
AtomicU8
Ordering
:
:
*
}
}
;
#
[
cfg
(
all
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
not
(
oneshot_loom
)
)
)
]
use
core
:
:
hint
;
#
[
cfg
(
all
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
oneshot_loom
)
)
]
use
loom
:
:
hint
;
#
[
cfg
(
feature
=
"
async
"
)
]
use
core
:
:
{
pin
:
:
Pin
task
:
:
{
self
Poll
}
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
thread
{
#
[
cfg
(
not
(
oneshot_loom
)
)
]
pub
use
std
:
:
thread
:
:
{
current
park
park_timeout
Thread
}
;
#
[
cfg
(
oneshot_loom
)
]
pub
use
loom
:
:
thread
:
:
{
current
park
Thread
}
;
#
[
cfg
(
oneshot_loom
)
]
pub
fn
park_timeout
(
_timeout
:
std
:
:
time
:
:
Duration
)
{
loom
:
:
thread
:
:
yield_now
(
)
}
}
#
[
cfg
(
oneshot_loom
)
]
mod
loombox
;
#
[
cfg
(
not
(
oneshot_loom
)
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
cfg
(
oneshot_loom
)
]
use
loombox
:
:
Box
;
mod
errors
;
pub
use
errors
:
:
*
;
pub
fn
channel
<
T
>
(
)
-
>
(
Sender
<
T
>
Receiver
<
T
>
)
{
let
channel_ptr
=
NonNull
:
:
from
(
Box
:
:
leak
(
Box
:
:
new
(
Channel
:
:
new
(
)
)
)
)
;
(
Sender
{
channel_ptr
_invariant
:
PhantomData
}
Receiver
{
channel_ptr
}
)
}
#
[
derive
(
Debug
)
]
pub
struct
Sender
<
T
>
{
channel_ptr
:
NonNull
<
Channel
<
T
>
>
_invariant
:
PhantomData
<
fn
(
T
)
-
>
T
>
}
#
[
derive
(
Debug
)
]
pub
struct
Receiver
<
T
>
{
channel_ptr
:
NonNull
<
Channel
<
T
>
>
}
unsafe
impl
<
T
:
Send
>
Send
for
Sender
<
T
>
{
}
unsafe
impl
<
T
:
Sync
>
Sync
for
Sender
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Send
for
Receiver
<
T
>
{
}
impl
<
T
>
Unpin
for
Receiver
<
T
>
{
}
impl
<
T
>
Sender
<
T
>
{
pub
fn
send
(
self
message
:
T
)
-
>
Result
<
(
)
SendError
<
T
>
>
{
let
channel_ptr
=
self
.
channel_ptr
;
mem
:
:
forget
(
self
)
;
let
channel
=
unsafe
{
channel_ptr
.
as_ref
(
)
}
;
unsafe
{
channel
.
write_message
(
message
)
}
;
match
channel
.
state
.
fetch_add
(
1
Release
)
{
EMPTY
=
>
Ok
(
(
)
)
RECEIVING
=
>
{
fence
(
Acquire
)
;
let
waker
=
unsafe
{
channel
.
take_waker
(
)
}
;
channel
.
state
.
swap
(
MESSAGE
AcqRel
)
;
waker
.
unpark
(
)
;
Ok
(
(
)
)
}
DISCONNECTED
=
>
Err
(
unsafe
{
SendError
:
:
new
(
channel_ptr
)
}
)
_
=
>
unreachable
!
(
)
}
}
pub
fn
is_closed
(
&
self
)
-
>
bool
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
channel
.
state
.
load
(
Relaxed
)
=
=
DISCONNECTED
}
pub
fn
into_raw
(
self
)
-
>
*
mut
(
)
{
let
raw
=
self
.
channel_ptr
.
as_ptr
(
)
as
*
mut
(
)
;
mem
:
:
forget
(
self
)
;
raw
}
pub
unsafe
fn
from_raw
(
raw
:
*
mut
(
)
)
-
>
Self
{
Self
{
channel_ptr
:
NonNull
:
:
new_unchecked
(
raw
as
*
mut
Channel
<
T
>
)
_invariant
:
PhantomData
}
}
}
impl
<
T
>
Drop
for
Sender
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
match
channel
.
state
.
fetch_xor
(
0b001
Relaxed
)
{
EMPTY
=
>
(
)
RECEIVING
=
>
{
fence
(
Acquire
)
;
let
waker
=
unsafe
{
channel
.
take_waker
(
)
}
;
channel
.
state
.
swap
(
DISCONNECTED
AcqRel
)
;
waker
.
unpark
(
)
;
}
DISCONNECTED
=
>
{
unsafe
{
dealloc
(
self
.
channel_ptr
)
}
;
}
_
=
>
unreachable
!
(
)
}
}
}
impl
<
T
>
Receiver
<
T
>
{
pub
fn
try_recv
(
&
self
)
-
>
Result
<
T
TryRecvError
>
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
match
channel
.
state
.
load
(
Acquire
)
{
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
}
EMPTY
=
>
Err
(
TryRecvError
:
:
Empty
)
DISCONNECTED
=
>
Err
(
TryRecvError
:
:
Disconnected
)
#
[
cfg
(
feature
=
"
async
"
)
]
RECEIVING
|
UNPARKING
=
>
Err
(
TryRecvError
:
:
Empty
)
_
=
>
unreachable
!
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
recv
(
self
)
-
>
Result
<
T
RecvError
>
{
let
channel_ptr
=
self
.
channel_ptr
;
mem
:
:
forget
(
self
)
;
let
channel
=
unsafe
{
channel_ptr
.
as_ref
(
)
}
;
match
channel
.
state
.
load
(
Acquire
)
{
EMPTY
=
>
{
#
[
cfg
(
all
(
oneshot_test_delay
not
(
oneshot_loom
)
)
)
]
std
:
:
thread
:
:
sleep
(
std
:
:
time
:
:
Duration
:
:
from_millis
(
10
)
)
;
unsafe
{
channel
.
write_waker
(
ReceiverWaker
:
:
current_thread
(
)
)
}
;
match
channel
.
state
.
swap
(
RECEIVING
Release
)
{
EMPTY
=
>
loop
{
thread
:
:
park
(
)
;
match
channel
.
state
.
load
(
Acquire
)
{
MESSAGE
=
>
{
let
message
=
unsafe
{
channel
.
take_message
(
)
}
;
unsafe
{
dealloc
(
channel_ptr
)
}
;
break
Ok
(
message
)
;
}
DISCONNECTED
=
>
{
unsafe
{
dealloc
(
channel_ptr
)
}
;
break
Err
(
RecvError
)
;
}
RECEIVING
|
UNPARKING
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
MESSAGE
=
>
{
fence
(
Acquire
)
;
unsafe
{
channel
.
drop_waker
(
)
}
;
let
message
=
unsafe
{
channel
.
take_message
(
)
}
;
unsafe
{
dealloc
(
channel_ptr
)
}
;
Ok
(
message
)
}
DISCONNECTED
=
>
{
unsafe
{
channel
.
drop_waker
(
)
}
;
unsafe
{
dealloc
(
channel_ptr
)
}
;
Err
(
RecvError
)
}
_
=
>
unreachable
!
(
)
}
}
MESSAGE
=
>
{
let
message
=
unsafe
{
channel
.
take_message
(
)
}
;
unsafe
{
dealloc
(
channel_ptr
)
}
;
Ok
(
message
)
}
DISCONNECTED
=
>
{
unsafe
{
dealloc
(
channel_ptr
)
}
;
Err
(
RecvError
)
}
#
[
cfg
(
feature
=
"
async
"
)
]
RECEIVING
|
UNPARKING
=
>
panic
!
(
"
{
}
"
RECEIVER_USED_SYNC_AND_ASYNC_ERROR
)
_
=
>
unreachable
!
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
recv_ref
(
&
self
)
-
>
Result
<
T
RecvError
>
{
self
.
start_recv_ref
(
RecvError
|
channel
|
{
loop
{
thread
:
:
park
(
)
;
match
channel
.
state
.
load
(
Acquire
)
{
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
break
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
;
}
DISCONNECTED
=
>
break
Err
(
RecvError
)
RECEIVING
|
UNPARKING
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
}
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
recv_timeout
(
&
self
timeout
:
Duration
)
-
>
Result
<
T
RecvTimeoutError
>
{
match
Instant
:
:
now
(
)
.
checked_add
(
timeout
)
{
Some
(
deadline
)
=
>
self
.
recv_deadline
(
deadline
)
None
=
>
self
.
recv_ref
(
)
.
map_err
(
|
_
|
RecvTimeoutError
:
:
Disconnected
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
recv_deadline
(
&
self
deadline
:
Instant
)
-
>
Result
<
T
RecvTimeoutError
>
{
#
[
cold
]
unsafe
fn
wait_for_unpark
<
T
>
(
channel
:
&
Channel
<
T
>
)
-
>
Result
<
T
RecvTimeoutError
>
{
loop
{
thread
:
:
park
(
)
;
match
channel
.
state
.
load
(
Relaxed
)
{
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
break
Ok
(
channel
.
take_message
(
)
)
;
}
DISCONNECTED
=
>
break
Err
(
RecvTimeoutError
:
:
Disconnected
)
EMPTY
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
}
self
.
start_recv_ref
(
RecvTimeoutError
:
:
Disconnected
|
channel
|
{
loop
{
match
deadline
.
checked_duration_since
(
Instant
:
:
now
(
)
)
{
Some
(
timeout
)
=
>
{
thread
:
:
park_timeout
(
timeout
)
;
match
channel
.
state
.
load
(
Acquire
)
{
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
break
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
;
}
DISCONNECTED
=
>
break
Err
(
RecvTimeoutError
:
:
Disconnected
)
RECEIVING
|
UNPARKING
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
None
=
>
{
match
channel
.
state
.
swap
(
EMPTY
Acquire
)
{
RECEIVING
=
>
{
unsafe
{
channel
.
drop_waker
(
)
}
;
break
Err
(
RecvTimeoutError
:
:
Timeout
)
;
}
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
break
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
;
}
DISCONNECTED
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
break
Err
(
RecvTimeoutError
:
:
Disconnected
)
;
}
UNPARKING
=
>
{
break
unsafe
{
wait_for_unpark
(
channel
)
}
;
}
_
=
>
unreachable
!
(
)
}
}
}
}
}
)
}
pub
fn
is_closed
(
&
self
)
-
>
bool
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
channel
.
state
.
load
(
Relaxed
)
=
=
DISCONNECTED
}
pub
fn
has_message
(
&
self
)
-
>
bool
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
channel
.
state
.
load
(
Acquire
)
=
=
MESSAGE
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
inline
]
fn
start_recv_ref
<
E
>
(
&
self
disconnected_error
:
E
finish
:
impl
FnOnce
(
&
Channel
<
T
>
)
-
>
Result
<
T
E
>
)
-
>
Result
<
T
E
>
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
match
channel
.
state
.
load
(
Acquire
)
{
EMPTY
=
>
{
#
[
cfg
(
all
(
oneshot_test_delay
not
(
oneshot_loom
)
)
)
]
std
:
:
thread
:
:
sleep
(
std
:
:
time
:
:
Duration
:
:
from_millis
(
10
)
)
;
unsafe
{
channel
.
write_waker
(
ReceiverWaker
:
:
current_thread
(
)
)
}
;
match
channel
.
state
.
compare_exchange
(
EMPTY
RECEIVING
Release
Relaxed
)
{
Ok
(
_
)
=
>
finish
(
channel
)
Err
(
MESSAGE
)
=
>
{
fence
(
Acquire
)
;
unsafe
{
channel
.
drop_waker
(
)
}
;
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
}
Err
(
DISCONNECTED
)
=
>
{
unsafe
{
channel
.
drop_waker
(
)
}
;
Err
(
disconnected_error
)
}
_
=
>
unreachable
!
(
)
}
}
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
}
DISCONNECTED
=
>
Err
(
disconnected_error
)
#
[
cfg
(
feature
=
"
async
"
)
]
RECEIVING
|
UNPARKING
=
>
panic
!
(
"
{
}
"
RECEIVER_USED_SYNC_AND_ASYNC_ERROR
)
_
=
>
unreachable
!
(
)
}
}
pub
fn
into_raw
(
self
)
-
>
*
mut
(
)
{
let
raw
=
self
.
channel_ptr
.
as_ptr
(
)
as
*
mut
(
)
;
mem
:
:
forget
(
self
)
;
raw
}
pub
unsafe
fn
from_raw
(
raw
:
*
mut
(
)
)
-
>
Self
{
Self
{
channel_ptr
:
NonNull
:
:
new_unchecked
(
raw
as
*
mut
Channel
<
T
>
)
}
}
}
#
[
cfg
(
feature
=
"
async
"
)
]
impl
<
T
>
core
:
:
future
:
:
Future
for
Receiver
<
T
>
{
type
Output
=
Result
<
T
RecvError
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
match
channel
.
state
.
load
(
Acquire
)
{
EMPTY
=
>
{
unsafe
{
channel
.
write_async_waker
(
cx
)
}
}
RECEIVING
=
>
{
match
channel
.
state
.
compare_exchange
(
RECEIVING
EMPTY
Relaxed
Relaxed
)
{
Ok
(
_
)
=
>
{
unsafe
{
channel
.
drop_waker
(
)
}
;
unsafe
{
channel
.
write_async_waker
(
cx
)
}
}
Err
(
MESSAGE
)
=
>
{
channel
.
state
.
swap
(
DISCONNECTED
Acquire
)
;
Poll
:
:
Ready
(
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
)
}
Err
(
DISCONNECTED
)
=
>
Poll
:
:
Ready
(
Err
(
RecvError
)
)
Err
(
UNPARKING
)
=
>
{
cx
.
waker
(
)
.
wake_by_ref
(
)
;
Poll
:
:
Pending
}
_
=
>
unreachable
!
(
)
}
}
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
Poll
:
:
Ready
(
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
)
}
DISCONNECTED
=
>
Poll
:
:
Ready
(
Err
(
RecvError
)
)
UNPARKING
=
>
loop
{
hint
:
:
spin_loop
(
)
;
match
channel
.
state
.
load
(
Relaxed
)
{
MESSAGE
=
>
{
channel
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
break
Poll
:
:
Ready
(
Ok
(
unsafe
{
channel
.
take_message
(
)
}
)
)
;
}
DISCONNECTED
=
>
break
Poll
:
:
Ready
(
Err
(
RecvError
)
)
UNPARKING
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
_
=
>
unreachable
!
(
)
}
}
}
impl
<
T
>
Drop
for
Receiver
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
channel
=
unsafe
{
self
.
channel_ptr
.
as_ref
(
)
}
;
match
channel
.
state
.
swap
(
DISCONNECTED
Acquire
)
{
EMPTY
=
>
(
)
MESSAGE
=
>
{
unsafe
{
channel
.
drop_message
(
)
}
;
unsafe
{
dealloc
(
self
.
channel_ptr
)
}
;
}
#
[
cfg
(
feature
=
"
async
"
)
]
RECEIVING
=
>
{
unsafe
{
channel
.
drop_waker
(
)
}
;
}
DISCONNECTED
=
>
{
unsafe
{
dealloc
(
self
.
channel_ptr
)
}
;
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
)
]
UNPARKING
=
>
{
loop
{
hint
:
:
spin_loop
(
)
;
match
channel
.
state
.
load
(
Relaxed
)
{
MESSAGE
=
>
{
unsafe
{
channel
.
drop_message
(
)
}
;
break
;
}
DISCONNECTED
=
>
break
UNPARKING
=
>
(
)
_
=
>
unreachable
!
(
)
}
}
unsafe
{
dealloc
(
self
.
channel_ptr
)
}
;
}
_
=
>
unreachable
!
(
)
}
}
}
mod
states
{
pub
const
EMPTY
:
u8
=
0b011
;
pub
const
MESSAGE
:
u8
=
0b100
;
pub
const
RECEIVING
:
u8
=
0b000
;
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
)
]
pub
const
UNPARKING
:
u8
=
0b001
;
pub
const
DISCONNECTED
:
u8
=
0b010
;
}
use
states
:
:
*
;
struct
Channel
<
T
>
{
state
:
AtomicU8
message
:
UnsafeCell
<
MaybeUninit
<
T
>
>
waker
:
UnsafeCell
<
MaybeUninit
<
ReceiverWaker
>
>
}
impl
<
T
>
Channel
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
state
:
AtomicU8
:
:
new
(
EMPTY
)
message
:
UnsafeCell
:
:
new
(
MaybeUninit
:
:
uninit
(
)
)
waker
:
UnsafeCell
:
:
new
(
MaybeUninit
:
:
uninit
(
)
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
message
(
&
self
)
-
>
&
MaybeUninit
<
T
>
{
#
[
cfg
(
oneshot_loom
)
]
{
self
.
message
.
with
(
|
ptr
|
&
*
ptr
)
}
#
[
cfg
(
not
(
oneshot_loom
)
)
]
{
&
*
self
.
message
.
get
(
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
with_message_mut
<
F
>
(
&
self
op
:
F
)
where
F
:
FnOnce
(
&
mut
MaybeUninit
<
T
>
)
{
#
[
cfg
(
oneshot_loom
)
]
{
self
.
message
.
with_mut
(
|
ptr
|
op
(
&
mut
*
ptr
)
)
}
#
[
cfg
(
not
(
oneshot_loom
)
)
]
{
op
(
&
mut
*
self
.
message
.
get
(
)
)
}
}
#
[
inline
(
always
)
]
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
)
]
unsafe
fn
with_waker_mut
<
F
>
(
&
self
op
:
F
)
where
F
:
FnOnce
(
&
mut
MaybeUninit
<
ReceiverWaker
>
)
{
#
[
cfg
(
oneshot_loom
)
]
{
self
.
waker
.
with_mut
(
|
ptr
|
op
(
&
mut
*
ptr
)
)
}
#
[
cfg
(
not
(
oneshot_loom
)
)
]
{
op
(
&
mut
*
self
.
waker
.
get
(
)
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
write_message
(
&
self
message
:
T
)
{
self
.
with_message_mut
(
|
slot
|
slot
.
as_mut_ptr
(
)
.
write
(
message
)
)
;
}
#
[
inline
(
always
)
]
unsafe
fn
take_message
(
&
self
)
-
>
T
{
#
[
cfg
(
oneshot_loom
)
]
{
self
.
message
.
with
(
|
ptr
|
ptr
:
:
read
(
ptr
)
)
.
assume_init
(
)
}
#
[
cfg
(
not
(
oneshot_loom
)
)
]
{
ptr
:
:
read
(
self
.
message
.
get
(
)
)
.
assume_init
(
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
drop_message
(
&
self
)
{
self
.
with_message_mut
(
|
slot
|
slot
.
assume_init_drop
(
)
)
;
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
)
]
#
[
inline
(
always
)
]
unsafe
fn
write_waker
(
&
self
waker
:
ReceiverWaker
)
{
self
.
with_waker_mut
(
|
slot
|
slot
.
as_mut_ptr
(
)
.
write
(
waker
)
)
;
}
#
[
inline
(
always
)
]
unsafe
fn
take_waker
(
&
self
)
-
>
ReceiverWaker
{
#
[
cfg
(
oneshot_loom
)
]
{
self
.
waker
.
with
(
|
ptr
|
ptr
:
:
read
(
ptr
)
)
.
assume_init
(
)
}
#
[
cfg
(
not
(
oneshot_loom
)
)
]
{
ptr
:
:
read
(
self
.
waker
.
get
(
)
)
.
assume_init
(
)
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
async
"
)
)
]
#
[
inline
(
always
)
]
unsafe
fn
drop_waker
(
&
self
)
{
self
.
with_waker_mut
(
|
slot
|
slot
.
assume_init_drop
(
)
)
;
}
#
[
cfg
(
feature
=
"
async
"
)
]
unsafe
fn
write_async_waker
(
&
self
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Result
<
T
RecvError
>
>
{
self
.
write_waker
(
ReceiverWaker
:
:
task_waker
(
cx
)
)
;
match
self
.
state
.
compare_exchange
(
EMPTY
RECEIVING
Release
Relaxed
)
{
Ok
(
_
)
=
>
Poll
:
:
Pending
Err
(
MESSAGE
)
=
>
{
fence
(
Acquire
)
;
self
.
drop_waker
(
)
;
self
.
state
.
store
(
DISCONNECTED
Relaxed
)
;
Poll
:
:
Ready
(
Ok
(
self
.
take_message
(
)
)
)
}
Err
(
DISCONNECTED
)
=
>
{
self
.
drop_waker
(
)
;
Poll
:
:
Ready
(
Err
(
RecvError
)
)
}
_
=
>
unreachable
!
(
)
}
}
}
enum
ReceiverWaker
{
#
[
cfg
(
feature
=
"
std
"
)
]
Thread
(
thread
:
:
Thread
)
#
[
cfg
(
feature
=
"
async
"
)
]
Task
(
task
:
:
Waker
)
#
[
cfg
(
not
(
any
(
feature
=
"
async
"
feature
=
"
std
"
)
)
)
]
_Uninhabited
}
impl
ReceiverWaker
{
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
current_thread
(
)
-
>
Self
{
Self
:
:
Thread
(
thread
:
:
current
(
)
)
}
#
[
cfg
(
feature
=
"
async
"
)
]
pub
fn
task_waker
(
cx
:
&
task
:
:
Context
<
'
_
>
)
-
>
Self
{
Self
:
:
Task
(
cx
.
waker
(
)
.
clone
(
)
)
}
pub
fn
unpark
(
self
)
{
match
self
{
#
[
cfg
(
feature
=
"
std
"
)
]
ReceiverWaker
:
:
Thread
(
thread
)
=
>
thread
.
unpark
(
)
#
[
cfg
(
feature
=
"
async
"
)
]
ReceiverWaker
:
:
Task
(
waker
)
=
>
waker
.
wake
(
)
#
[
cfg
(
not
(
any
(
feature
=
"
async
"
feature
=
"
std
"
)
)
)
]
ReceiverWaker
:
:
_Uninhabited
=
>
unreachable
!
(
)
}
}
}
#
[
cfg
(
not
(
oneshot_loom
)
)
]
#
[
test
]
#
[
ignore
=
"
Unstable
test
.
Different
Rust
versions
have
different
sizes
for
Thread
"
]
fn
receiver_waker_size
(
)
{
let
expected
:
usize
=
match
(
cfg
!
(
feature
=
"
std
"
)
cfg
!
(
feature
=
"
async
"
)
)
{
(
false
false
)
=
>
0
(
false
true
)
=
>
16
(
true
false
)
=
>
16
(
true
true
)
=
>
24
}
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
ReceiverWaker
>
(
)
expected
)
;
}
#
[
cfg
(
all
(
feature
=
"
std
"
feature
=
"
async
"
)
)
]
const
RECEIVER_USED_SYNC_AND_ASYNC_ERROR
:
&
str
=
"
Invalid
to
call
a
blocking
receive
method
on
oneshot
:
:
Receiver
after
it
has
been
polled
"
;
#
[
inline
]
pub
(
crate
)
unsafe
fn
dealloc
<
T
>
(
channel
:
NonNull
<
Channel
<
T
>
>
)
{
drop
(
Box
:
:
from_raw
(
channel
.
as_ptr
(
)
)
)
}
