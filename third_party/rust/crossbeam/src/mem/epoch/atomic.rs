use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
self
Ordering
}
;
use
super
:
:
{
Owned
Shared
Guard
}
;
#
[
derive
(
Debug
)
]
pub
struct
Atomic
<
T
>
{
ptr
:
atomic
:
:
AtomicPtr
<
T
>
_marker
:
PhantomData
<
*
const
(
)
>
}
unsafe
impl
<
T
:
Sync
>
Send
for
Atomic
<
T
>
{
}
unsafe
impl
<
T
:
Sync
>
Sync
for
Atomic
<
T
>
{
}
fn
opt_shared_into_raw
<
T
>
(
val
:
Option
<
Shared
<
T
>
>
)
-
>
*
mut
T
{
val
.
map
(
|
p
|
p
.
as_raw
(
)
)
.
unwrap_or
(
ptr
:
:
null_mut
(
)
)
}
fn
opt_owned_as_raw
<
T
>
(
val
:
&
Option
<
Owned
<
T
>
>
)
-
>
*
mut
T
{
val
.
as_ref
(
)
.
map
(
Owned
:
:
as_raw
)
.
unwrap_or
(
ptr
:
:
null_mut
(
)
)
}
fn
opt_owned_into_raw
<
T
>
(
val
:
Option
<
Owned
<
T
>
>
)
-
>
*
mut
T
{
let
ptr
=
val
.
as_ref
(
)
.
map
(
Owned
:
:
as_raw
)
.
unwrap_or
(
ptr
:
:
null_mut
(
)
)
;
mem
:
:
forget
(
val
)
;
ptr
}
impl
<
T
>
Atomic
<
T
>
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
pub
const
fn
null
(
)
-
>
Atomic
<
T
>
{
Atomic
{
ptr
:
atomic
:
:
AtomicPtr
:
:
new
(
0
as
*
mut
_
)
_marker
:
PhantomData
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
pub
fn
null
(
)
-
>
Atomic
<
T
>
{
Atomic
{
ptr
:
atomic
:
:
AtomicPtr
:
:
new
(
0
as
*
mut
_
)
_marker
:
PhantomData
}
}
pub
fn
new
(
data
:
T
)
-
>
Atomic
<
T
>
{
Atomic
{
ptr
:
atomic
:
:
AtomicPtr
:
:
new
(
Box
:
:
into_raw
(
Box
:
:
new
(
data
)
)
)
_marker
:
PhantomData
}
}
pub
fn
load
<
'
a
>
(
&
self
ord
:
Ordering
_
:
&
'
a
Guard
)
-
>
Option
<
Shared
<
'
a
T
>
>
{
unsafe
{
Shared
:
:
from_raw
(
self
.
ptr
.
load
(
ord
)
)
}
}
pub
fn
store
(
&
self
val
:
Option
<
Owned
<
T
>
>
ord
:
Ordering
)
{
self
.
ptr
.
store
(
opt_owned_into_raw
(
val
)
ord
)
}
pub
fn
store_and_ref
<
'
a
>
(
&
self
val
:
Owned
<
T
>
ord
:
Ordering
_
:
&
'
a
Guard
)
-
>
Shared
<
'
a
T
>
{
unsafe
{
let
shared
=
Shared
:
:
from_owned
(
val
)
;
self
.
store_shared
(
Some
(
shared
)
ord
)
;
shared
}
}
pub
fn
store_shared
(
&
self
val
:
Option
<
Shared
<
T
>
>
ord
:
Ordering
)
{
self
.
ptr
.
store
(
opt_shared_into_raw
(
val
)
ord
)
}
pub
fn
cas
(
&
self
old
:
Option
<
Shared
<
T
>
>
new
:
Option
<
Owned
<
T
>
>
ord
:
Ordering
)
-
>
Result
<
(
)
Option
<
Owned
<
T
>
>
>
{
if
self
.
ptr
.
compare_and_swap
(
opt_shared_into_raw
(
old
)
opt_owned_as_raw
(
&
new
)
ord
)
=
=
opt_shared_into_raw
(
old
)
{
mem
:
:
forget
(
new
)
;
Ok
(
(
)
)
}
else
{
Err
(
new
)
}
}
pub
fn
cas_and_ref
<
'
a
>
(
&
self
old
:
Option
<
Shared
<
T
>
>
new
:
Owned
<
T
>
ord
:
Ordering
_
:
&
'
a
Guard
)
-
>
Result
<
Shared
<
'
a
T
>
Owned
<
T
>
>
{
if
self
.
ptr
.
compare_and_swap
(
opt_shared_into_raw
(
old
)
new
.
as_raw
(
)
ord
)
=
=
opt_shared_into_raw
(
old
)
{
Ok
(
unsafe
{
Shared
:
:
from_owned
(
new
)
}
)
}
else
{
Err
(
new
)
}
}
pub
fn
cas_shared
(
&
self
old
:
Option
<
Shared
<
T
>
>
new
:
Option
<
Shared
<
T
>
>
ord
:
Ordering
)
-
>
bool
{
self
.
ptr
.
compare_and_swap
(
opt_shared_into_raw
(
old
)
opt_shared_into_raw
(
new
)
ord
)
=
=
opt_shared_into_raw
(
old
)
}
pub
fn
swap
<
'
a
>
(
&
self
new
:
Option
<
Owned
<
T
>
>
ord
:
Ordering
_
:
&
'
a
Guard
)
-
>
Option
<
Shared
<
'
a
T
>
>
{
unsafe
{
Shared
:
:
from_raw
(
self
.
ptr
.
swap
(
opt_owned_into_raw
(
new
)
ord
)
)
}
}
pub
fn
swap_shared
<
'
a
>
(
&
self
new
:
Option
<
Shared
<
T
>
>
ord
:
Ordering
_
:
&
'
a
Guard
)
-
>
Option
<
Shared
<
'
a
T
>
>
{
unsafe
{
Shared
:
:
from_raw
(
self
.
ptr
.
swap
(
opt_shared_into_raw
(
new
)
ord
)
)
}
}
}
