mod
atomic
;
mod
garbage
;
mod
global
;
mod
guard
;
mod
local
;
mod
participant
;
mod
participants
;
pub
use
self
:
:
atomic
:
:
Atomic
;
pub
use
self
:
:
guard
:
:
{
pin
Guard
}
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
ptr
;
use
std
:
:
mem
;
#
[
derive
(
Debug
)
]
pub
struct
Owned
<
T
>
{
data
:
Box
<
T
>
}
impl
<
T
>
Owned
<
T
>
{
pub
fn
new
(
t
:
T
)
-
>
Owned
<
T
>
{
Owned
{
data
:
Box
:
:
new
(
t
)
}
}
fn
as_raw
(
&
self
)
-
>
*
mut
T
{
self
.
deref
(
)
as
*
const
_
as
*
mut
_
}
pub
fn
into_inner
(
self
)
-
>
T
{
*
self
.
data
}
}
impl
<
T
>
Deref
for
Owned
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
&
self
.
data
}
}
impl
<
T
>
DerefMut
for
Owned
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
data
}
}
#
[
derive
(
PartialEq
Eq
)
]
#
[
derive
(
Debug
)
]
pub
struct
Shared
<
'
a
T
:
'
a
>
{
data
:
&
'
a
T
}
impl
<
'
a
T
>
Copy
for
Shared
<
'
a
T
>
{
}
impl
<
'
a
T
>
Clone
for
Shared
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
Shared
<
'
a
T
>
{
Shared
{
data
:
self
.
data
}
}
}
impl
<
'
a
T
>
Deref
for
Shared
<
'
a
T
>
{
type
Target
=
&
'
a
T
;
fn
deref
(
&
self
)
-
>
&
&
'
a
T
{
&
self
.
data
}
}
impl
<
'
a
T
>
Shared
<
'
a
T
>
{
unsafe
fn
from_raw
(
raw
:
*
mut
T
)
-
>
Option
<
Shared
<
'
a
T
>
>
{
if
raw
=
=
ptr
:
:
null_mut
(
)
{
None
}
else
{
Some
(
Shared
{
data
:
mem
:
:
transmute
:
:
<
*
mut
T
&
T
>
(
raw
)
}
)
}
}
unsafe
fn
from_ref
(
r
:
&
T
)
-
>
Shared
<
'
a
T
>
{
Shared
{
data
:
mem
:
:
transmute
(
r
)
}
}
unsafe
fn
from_owned
(
owned
:
Owned
<
T
>
)
-
>
Shared
<
'
a
T
>
{
let
ret
=
Shared
:
:
from_ref
(
owned
.
deref
(
)
)
;
mem
:
:
forget
(
owned
)
;
ret
}
pub
fn
as_raw
(
&
self
)
-
>
*
mut
T
{
self
.
data
as
*
const
_
as
*
mut
_
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
super
:
:
*
;
use
mem
:
:
epoch
;
#
[
test
]
fn
test_no_drop
(
)
{
static
mut
DROPS
:
i32
=
0
;
struct
Test
;
impl
Drop
for
Test
{
fn
drop
(
&
mut
self
)
{
unsafe
{
DROPS
+
=
1
;
}
}
}
let
g
=
pin
(
)
;
let
x
=
Atomic
:
:
null
(
)
;
x
.
store
(
Some
(
Owned
:
:
new
(
Test
)
)
Ordering
:
:
Relaxed
)
;
x
.
store_and_ref
(
Owned
:
:
new
(
Test
)
Ordering
:
:
Relaxed
&
g
)
;
let
y
=
x
.
load
(
Ordering
:
:
Relaxed
&
g
)
;
let
z
=
x
.
cas_and_ref
(
y
Owned
:
:
new
(
Test
)
Ordering
:
:
Relaxed
&
g
)
.
ok
(
)
;
let
_
=
x
.
cas
(
z
Some
(
Owned
:
:
new
(
Test
)
)
Ordering
:
:
Relaxed
)
;
x
.
swap
(
Some
(
Owned
:
:
new
(
Test
)
)
Ordering
:
:
Relaxed
&
g
)
;
unsafe
{
assert_eq
!
(
DROPS
0
)
;
}
}
#
[
test
]
fn
test_new
(
)
{
let
guard
=
epoch
:
:
pin
(
)
;
let
my_atomic
=
Atomic
:
:
new
(
42
)
;
assert_eq
!
(
*
*
my_atomic
.
load
(
Ordering
:
:
Relaxed
&
guard
)
.
unwrap
(
)
42
)
;
}
}
