use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
Acquire
Release
Relaxed
}
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicBool
;
use
std
:
:
{
ptr
mem
}
;
use
std
:
:
thread
:
:
{
self
Thread
}
;
use
mem
:
:
epoch
:
:
{
self
Atomic
Owned
Shared
}
;
use
mem
:
:
CachePadded
;
#
[
derive
(
Debug
)
]
pub
struct
MsQueue
<
T
>
{
head
:
CachePadded
<
Atomic
<
Node
<
T
>
>
>
tail
:
CachePadded
<
Atomic
<
Node
<
T
>
>
>
}
#
[
derive
(
Debug
)
]
struct
Node
<
T
>
{
payload
:
Payload
<
T
>
next
:
Atomic
<
Node
<
T
>
>
}
#
[
derive
(
Debug
)
]
enum
Payload
<
T
>
{
Data
(
T
)
Blocked
(
*
mut
Signal
<
T
>
)
}
#
[
derive
(
Debug
)
]
struct
Signal
<
T
>
{
thread
:
Thread
data
:
Option
<
T
>
ready
:
AtomicBool
}
impl
<
T
>
Node
<
T
>
{
fn
is_data
(
&
self
)
-
>
bool
{
if
let
Payload
:
:
Data
(
_
)
=
self
.
payload
{
true
}
else
{
false
}
}
}
unsafe
impl
<
T
:
Send
>
Sync
for
MsQueue
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Send
for
MsQueue
<
T
>
{
}
impl
<
T
>
MsQueue
<
T
>
{
pub
fn
new
(
)
-
>
MsQueue
<
T
>
{
let
q
=
MsQueue
{
head
:
CachePadded
:
:
new
(
Atomic
:
:
null
(
)
)
tail
:
CachePadded
:
:
new
(
Atomic
:
:
null
(
)
)
}
;
let
sentinel
=
Owned
:
:
new
(
Node
{
payload
:
Payload
:
:
Data
(
unsafe
{
mem
:
:
uninitialized
(
)
}
)
next
:
Atomic
:
:
null
(
)
}
)
;
let
guard
=
epoch
:
:
pin
(
)
;
let
sentinel
=
q
.
head
.
store_and_ref
(
sentinel
Relaxed
&
guard
)
;
q
.
tail
.
store_shared
(
Some
(
sentinel
)
Relaxed
)
;
q
}
#
[
inline
(
always
)
]
fn
push_internal
(
&
self
guard
:
&
epoch
:
:
Guard
onto
:
Shared
<
Node
<
T
>
>
n
:
Owned
<
Node
<
T
>
>
)
-
>
Result
<
(
)
Owned
<
Node
<
T
>
>
>
{
if
let
Some
(
next
)
=
onto
.
next
.
load
(
Acquire
guard
)
{
self
.
tail
.
cas_shared
(
Some
(
onto
)
Some
(
next
)
Release
)
;
Err
(
n
)
}
else
{
onto
.
next
.
cas_and_ref
(
None
n
Release
guard
)
.
map
(
|
shared
|
{
self
.
tail
.
cas_shared
(
Some
(
onto
)
Some
(
shared
)
Release
)
;
}
)
}
}
pub
fn
push
(
&
self
t
:
T
)
{
enum
Cache
<
T
>
{
Data
(
T
)
Node
(
Owned
<
Node
<
T
>
>
)
}
impl
<
T
>
Cache
<
T
>
{
fn
into_node
(
self
)
-
>
Owned
<
Node
<
T
>
>
{
match
self
{
Cache
:
:
Data
(
t
)
=
>
{
Owned
:
:
new
(
Node
{
payload
:
Payload
:
:
Data
(
t
)
next
:
Atomic
:
:
null
(
)
}
)
}
Cache
:
:
Node
(
n
)
=
>
n
}
}
fn
into_data
(
self
)
-
>
T
{
match
self
{
Cache
:
:
Data
(
t
)
=
>
t
Cache
:
:
Node
(
node
)
=
>
{
match
node
.
into_inner
(
)
.
payload
{
Payload
:
:
Data
(
t
)
=
>
t
_
=
>
unreachable
!
(
)
}
}
}
}
}
let
mut
cache
=
Cache
:
:
Data
(
t
)
;
let
guard
=
epoch
:
:
pin
(
)
;
loop
{
let
tail
=
self
.
tail
.
load
(
Acquire
&
guard
)
.
unwrap
(
)
;
if
tail
.
is_data
(
)
|
|
self
.
head
.
load
(
Relaxed
&
guard
)
.
unwrap
(
)
.
as_raw
(
)
=
=
tail
.
as_raw
(
)
{
match
self
.
push_internal
(
&
guard
tail
cache
.
into_node
(
)
)
{
Ok
(
_
)
=
>
return
Err
(
n
)
=
>
{
cache
=
Cache
:
:
Node
(
n
)
}
}
}
else
{
let
head
=
self
.
head
.
load
(
Acquire
&
guard
)
.
unwrap
(
)
;
let
request
=
head
.
next
.
load
(
Acquire
&
guard
)
.
and_then
(
|
next
|
{
match
next
.
payload
{
Payload
:
:
Blocked
(
signal
)
=
>
Some
(
(
next
signal
)
)
Payload
:
:
Data
(
_
)
=
>
None
}
}
)
;
if
let
Some
(
(
blocked_node
signal
)
)
=
request
{
if
self
.
head
.
cas_shared
(
Some
(
head
)
Some
(
blocked_node
)
Release
)
{
unsafe
{
(
*
signal
)
.
data
=
Some
(
cache
.
into_data
(
)
)
;
(
*
signal
)
.
ready
.
store
(
true
Relaxed
)
;
(
*
signal
)
.
thread
.
unpark
(
)
;
guard
.
unlinked
(
head
)
;
return
;
}
}
}
}
}
}
#
[
inline
(
always
)
]
fn
pop_internal
(
&
self
guard
:
&
epoch
:
:
Guard
)
-
>
Result
<
Option
<
T
>
(
)
>
{
let
head
=
self
.
head
.
load
(
Acquire
guard
)
.
unwrap
(
)
;
if
let
Some
(
next
)
=
head
.
next
.
load
(
Acquire
guard
)
{
if
let
Payload
:
:
Data
(
ref
t
)
=
next
.
payload
{
unsafe
{
if
self
.
head
.
cas_shared
(
Some
(
head
)
Some
(
next
)
Release
)
{
guard
.
unlinked
(
head
)
;
Ok
(
Some
(
ptr
:
:
read
(
t
)
)
)
}
else
{
Err
(
(
)
)
}
}
}
else
{
Ok
(
None
)
}
}
else
{
Ok
(
None
)
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
let
guard
=
epoch
:
:
pin
(
)
;
let
head
=
self
.
head
.
load
(
Acquire
&
guard
)
.
unwrap
(
)
;
if
let
Some
(
next
)
=
head
.
next
.
load
(
Acquire
&
guard
)
{
if
let
Payload
:
:
Data
(
_
)
=
next
.
payload
{
false
}
else
{
true
}
}
else
{
true
}
}
pub
fn
try_pop
(
&
self
)
-
>
Option
<
T
>
{
let
guard
=
epoch
:
:
pin
(
)
;
loop
{
if
let
Ok
(
r
)
=
self
.
pop_internal
(
&
guard
)
{
return
r
;
}
}
}
pub
fn
pop
(
&
self
)
-
>
T
{
let
guard
=
epoch
:
:
pin
(
)
;
loop
{
match
self
.
pop_internal
(
&
guard
)
{
Ok
(
Some
(
r
)
)
=
>
{
return
r
;
}
Ok
(
None
)
=
>
{
break
;
}
Err
(
(
)
)
=
>
{
}
}
}
let
mut
signal
=
Signal
{
thread
:
thread
:
:
current
(
)
data
:
None
ready
:
AtomicBool
:
:
new
(
false
)
}
;
let
mut
node
=
Owned
:
:
new
(
Node
{
payload
:
Payload
:
:
Blocked
(
&
mut
signal
)
next
:
Atomic
:
:
null
(
)
}
)
;
loop
{
if
let
Ok
(
Some
(
r
)
)
=
self
.
pop_internal
(
&
guard
)
{
return
r
;
}
let
tail
=
self
.
tail
.
load
(
Relaxed
&
guard
)
.
unwrap
(
)
;
if
tail
.
is_data
(
)
{
let
head
=
self
.
head
.
load
(
Relaxed
&
guard
)
.
unwrap
(
)
;
if
tail
.
is_data
(
)
&
&
tail
.
as_raw
(
)
!
=
head
.
as_raw
(
)
{
continue
;
}
}
match
self
.
push_internal
(
&
guard
tail
node
)
{
Ok
(
(
)
)
=
>
{
while
!
signal
.
ready
.
load
(
Relaxed
)
{
thread
:
:
park
(
)
;
}
return
signal
.
data
.
unwrap
(
)
;
}
Err
(
n
)
=
>
{
node
=
n
;
}
}
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
const
CONC_COUNT
:
i64
=
1000000
;
use
scope
;
use
super
:
:
*
;
#
[
test
]
fn
push_try_pop_1
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
q
.
push
(
37
)
;
assert
!
(
!
q
.
is_empty
(
)
)
;
assert_eq
!
(
q
.
try_pop
(
)
Some
(
37
)
)
;
assert
!
(
q
.
is_empty
(
)
)
;
}
#
[
test
]
fn
push_try_pop_2
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
q
.
push
(
37
)
;
q
.
push
(
48
)
;
assert_eq
!
(
q
.
try_pop
(
)
Some
(
37
)
)
;
assert
!
(
!
q
.
is_empty
(
)
)
;
assert_eq
!
(
q
.
try_pop
(
)
Some
(
48
)
)
;
assert
!
(
q
.
is_empty
(
)
)
;
}
#
[
test
]
fn
push_try_pop_many_seq
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
for
i
in
0
.
.
200
{
q
.
push
(
i
)
}
assert
!
(
!
q
.
is_empty
(
)
)
;
for
i
in
0
.
.
200
{
assert_eq
!
(
q
.
try_pop
(
)
Some
(
i
)
)
;
}
assert
!
(
q
.
is_empty
(
)
)
;
}
#
[
test
]
fn
push_pop_1
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
q
.
push
(
37
)
;
assert
!
(
!
q
.
is_empty
(
)
)
;
assert_eq
!
(
q
.
pop
(
)
37
)
;
assert
!
(
q
.
is_empty
(
)
)
;
}
#
[
test
]
fn
push_pop_2
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
q
.
push
(
37
)
;
q
.
push
(
48
)
;
assert_eq
!
(
q
.
pop
(
)
37
)
;
assert_eq
!
(
q
.
pop
(
)
48
)
;
}
#
[
test
]
fn
push_pop_many_seq
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
for
i
in
0
.
.
200
{
q
.
push
(
i
)
}
assert
!
(
!
q
.
is_empty
(
)
)
;
for
i
in
0
.
.
200
{
assert_eq
!
(
q
.
pop
(
)
i
)
;
}
assert
!
(
q
.
is_empty
(
)
)
;
}
#
[
test
]
fn
push_try_pop_many_spsc
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
scope
(
|
scope
|
{
scope
.
spawn
(
|
|
{
let
mut
next
=
0
;
while
next
<
CONC_COUNT
{
if
let
Some
(
elem
)
=
q
.
try_pop
(
)
{
assert_eq
!
(
elem
next
)
;
next
+
=
1
;
}
}
}
)
;
for
i
in
0
.
.
CONC_COUNT
{
q
.
push
(
i
)
}
}
)
;
}
#
[
test
]
fn
push_try_pop_many_spmc
(
)
{
fn
recv
(
_t
:
i32
q
:
&
MsQueue
<
i64
>
)
{
let
mut
cur
=
-
1
;
for
_i
in
0
.
.
CONC_COUNT
{
if
let
Some
(
elem
)
=
q
.
try_pop
(
)
{
assert
!
(
elem
>
cur
)
;
cur
=
elem
;
if
cur
=
=
CONC_COUNT
-
1
{
break
}
}
}
}
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
let
qr
=
&
q
;
scope
(
|
scope
|
{
for
i
in
0
.
.
3
{
scope
.
spawn
(
move
|
|
recv
(
i
qr
)
)
;
}
scope
.
spawn
(
|
|
{
for
i
in
0
.
.
CONC_COUNT
{
q
.
push
(
i
)
;
}
}
)
}
)
;
}
#
[
test
]
fn
push_try_pop_many_mpmc
(
)
{
enum
LR
{
Left
(
i64
)
Right
(
i64
)
}
let
q
:
MsQueue
<
LR
>
=
MsQueue
:
:
new
(
)
;
assert
!
(
q
.
is_empty
(
)
)
;
scope
(
|
scope
|
{
for
_t
in
0
.
.
2
{
scope
.
spawn
(
|
|
{
for
i
in
CONC_COUNT
-
1
.
.
CONC_COUNT
{
q
.
push
(
LR
:
:
Left
(
i
)
)
}
}
)
;
scope
.
spawn
(
|
|
{
for
i
in
CONC_COUNT
-
1
.
.
CONC_COUNT
{
q
.
push
(
LR
:
:
Right
(
i
)
)
}
}
)
;
scope
.
spawn
(
|
|
{
let
mut
vl
=
vec
!
[
]
;
let
mut
vr
=
vec
!
[
]
;
for
_i
in
0
.
.
CONC_COUNT
{
match
q
.
try_pop
(
)
{
Some
(
LR
:
:
Left
(
x
)
)
=
>
vl
.
push
(
x
)
Some
(
LR
:
:
Right
(
x
)
)
=
>
vr
.
push
(
x
)
_
=
>
{
}
}
}
let
mut
vl2
=
vl
.
clone
(
)
;
let
mut
vr2
=
vr
.
clone
(
)
;
vl2
.
sort
(
)
;
vr2
.
sort
(
)
;
assert_eq
!
(
vl
vl2
)
;
assert_eq
!
(
vr
vr2
)
;
}
)
;
}
}
)
;
}
#
[
test
]
fn
push_pop_many_spsc
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
scope
(
|
scope
|
{
scope
.
spawn
(
|
|
{
let
mut
next
=
0
;
while
next
<
CONC_COUNT
{
assert_eq
!
(
q
.
pop
(
)
next
)
;
next
+
=
1
;
}
}
)
;
for
i
in
0
.
.
CONC_COUNT
{
q
.
push
(
i
)
}
}
)
;
assert
!
(
q
.
is_empty
(
)
)
;
}
#
[
test
]
fn
is_empty_dont_pop
(
)
{
let
q
:
MsQueue
<
i64
>
=
MsQueue
:
:
new
(
)
;
q
.
push
(
20
)
;
q
.
push
(
20
)
;
assert
!
(
!
q
.
is_empty
(
)
)
;
assert
!
(
!
q
.
is_empty
(
)
)
;
assert
!
(
q
.
try_pop
(
)
.
is_some
(
)
)
;
}
}
