pub
use
self
:
:
PopResult
:
:
*
;
use
std
:
:
fmt
;
use
std
:
:
ptr
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
#
[
derive
(
Debug
)
]
pub
enum
PopResult
<
T
>
{
Data
(
T
)
Empty
Inconsistent
}
#
[
derive
(
Debug
)
]
struct
Node
<
T
>
{
next
:
AtomicPtr
<
Node
<
T
>
>
value
:
Option
<
T
>
}
pub
struct
Queue
<
T
>
{
head
:
AtomicPtr
<
Node
<
T
>
>
tail
:
UnsafeCell
<
*
mut
Node
<
T
>
>
}
impl
<
T
>
fmt
:
:
Debug
for
Queue
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Queue
{
{
.
.
.
}
}
"
)
}
}
unsafe
impl
<
T
:
Send
>
Send
for
Queue
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Queue
<
T
>
{
}
impl
<
T
>
Node
<
T
>
{
unsafe
fn
new
(
v
:
Option
<
T
>
)
-
>
*
mut
Node
<
T
>
{
Box
:
:
into_raw
(
Box
:
:
new
(
Node
{
next
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
value
:
v
}
)
)
}
}
impl
<
T
>
Queue
<
T
>
{
pub
fn
new
(
)
-
>
Queue
<
T
>
{
let
stub
=
unsafe
{
Node
:
:
new
(
None
)
}
;
Queue
{
head
:
AtomicPtr
:
:
new
(
stub
)
tail
:
UnsafeCell
:
:
new
(
stub
)
}
}
pub
fn
push
(
&
self
t
:
T
)
{
unsafe
{
let
n
=
Node
:
:
new
(
Some
(
t
)
)
;
let
prev
=
self
.
head
.
swap
(
n
Ordering
:
:
AcqRel
)
;
(
*
prev
)
.
next
.
store
(
n
Ordering
:
:
Release
)
;
}
}
pub
fn
pop
(
&
self
)
-
>
PopResult
<
T
>
{
unsafe
{
let
tail
=
*
self
.
tail
.
get
(
)
;
let
next
=
(
*
tail
)
.
next
.
load
(
Ordering
:
:
Acquire
)
;
if
!
next
.
is_null
(
)
{
*
self
.
tail
.
get
(
)
=
next
;
assert
!
(
(
*
tail
)
.
value
.
is_none
(
)
)
;
assert
!
(
(
*
next
)
.
value
.
is_some
(
)
)
;
let
ret
=
(
*
next
)
.
value
.
take
(
)
.
unwrap
(
)
;
let
_
=
Box
:
:
from_raw
(
tail
)
;
return
Data
(
ret
)
;
}
if
self
.
head
.
load
(
Ordering
:
:
Acquire
)
=
=
tail
{
Empty
}
else
{
Inconsistent
}
}
}
}
impl
<
T
>
Drop
for
Queue
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
mut
cur
=
*
self
.
tail
.
get
(
)
;
while
!
cur
.
is_null
(
)
{
let
next
=
(
*
cur
)
.
next
.
load
(
Ordering
:
:
Relaxed
)
;
let
_
=
Box
:
:
from_raw
(
cur
)
;
cur
=
next
;
}
}
}
}
