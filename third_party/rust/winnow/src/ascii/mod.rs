#
[
cfg
(
test
)
]
mod
tests
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
{
Add
Shl
}
;
use
crate
:
:
combinator
:
:
alt
;
use
crate
:
:
combinator
:
:
dispatch
;
use
crate
:
:
combinator
:
:
empty
;
use
crate
:
:
combinator
:
:
fail
;
use
crate
:
:
combinator
:
:
opt
;
use
crate
:
:
combinator
:
:
peek
;
use
crate
:
:
combinator
:
:
trace
;
use
crate
:
:
error
:
:
Needed
;
use
crate
:
:
error
:
:
ParserError
;
use
crate
:
:
stream
:
:
FindSlice
;
use
crate
:
:
stream
:
:
{
AsBStr
AsChar
ParseSlice
Stream
StreamIsPartial
}
;
use
crate
:
:
stream
:
:
{
Compare
CompareResult
}
;
use
crate
:
:
token
:
:
any
;
use
crate
:
:
token
:
:
one_of
;
use
crate
:
:
token
:
:
take_until
;
use
crate
:
:
token
:
:
take_while
;
use
crate
:
:
Parser
;
use
crate
:
:
Result
;
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Caseless
<
T
>
(
pub
T
)
;
impl
Caseless
<
&
str
>
{
#
[
inline
(
always
)
]
pub
fn
as_bytes
(
&
self
)
-
>
Caseless
<
&
[
u8
]
>
{
Caseless
(
self
.
0
.
as_bytes
(
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
crlf
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
&
'
static
str
>
Error
:
ParserError
<
Input
>
{
trace
(
"
crlf
"
"
\
r
\
n
"
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
till_line_ending
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
&
'
static
str
>
+
FindSlice
<
(
char
char
)
>
<
Input
as
Stream
>
:
:
Token
:
AsChar
+
Clone
Error
:
ParserError
<
Input
>
{
trace
(
"
till_line_ending
"
move
|
input
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
till_line_ending_
:
:
<
_
_
true
>
(
input
)
}
else
{
till_line_ending_
:
:
<
_
_
false
>
(
input
)
}
}
)
.
parse_next
(
input
)
}
fn
till_line_ending_
<
I
E
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
E
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
&
'
static
str
>
I
:
FindSlice
<
(
char
char
)
>
<
I
as
Stream
>
:
:
Token
:
AsChar
+
Clone
{
let
res
=
match
take_until
(
0
.
.
(
'
\
r
'
'
\
n
'
)
)
.
parse_next
(
input
)
.
map_err
(
|
e
:
E
|
e
)
{
Ok
(
slice
)
=
>
slice
Err
(
err
)
if
err
.
is_backtrack
(
)
=
>
input
.
finish
(
)
Err
(
err
)
=
>
{
return
Err
(
err
)
;
}
}
;
if
matches
!
(
input
.
compare
(
"
\
r
"
)
CompareResult
:
:
Ok
(
_
)
)
{
let
comp
=
input
.
compare
(
"
\
r
\
n
"
)
;
match
comp
{
CompareResult
:
:
Ok
(
_
)
=
>
{
}
CompareResult
:
:
Incomplete
if
PARTIAL
&
&
input
.
is_partial
(
)
=
>
{
return
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
Unknown
)
)
;
}
CompareResult
:
:
Incomplete
|
CompareResult
:
:
Error
=
>
{
return
Err
(
ParserError
:
:
from_input
(
input
)
)
;
}
}
}
Ok
(
res
)
}
#
[
inline
(
always
)
]
pub
fn
line_ending
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
&
'
static
str
>
Error
:
ParserError
<
Input
>
{
trace
(
"
line_ending
"
alt
(
(
"
\
n
"
"
\
r
\
n
"
)
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
newline
<
I
Error
:
ParserError
<
I
>
>
(
input
:
&
mut
I
)
-
>
Result
<
char
Error
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
char
>
{
trace
(
"
newline
"
'
\
n
'
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
tab
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
char
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
char
>
Error
:
ParserError
<
Input
>
{
trace
(
"
tab
"
'
\
t
'
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
alpha0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
alpha0
"
take_while
(
0
.
.
AsChar
:
:
is_alpha
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
alpha1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
alpha1
"
take_while
(
1
.
.
AsChar
:
:
is_alpha
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
digit0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
digit0
"
take_while
(
0
.
.
AsChar
:
:
is_dec_digit
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
digit1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
digit1
"
take_while
(
1
.
.
AsChar
:
:
is_dec_digit
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
hex_digit0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
hex_digit0
"
take_while
(
0
.
.
AsChar
:
:
is_hex_digit
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
hex_digit1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
hex_digit1
"
take_while
(
1
.
.
AsChar
:
:
is_hex_digit
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
oct_digit0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
Input
:
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
oct_digit0
"
take_while
(
0
.
.
AsChar
:
:
is_oct_digit
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
oct_digit1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
oct_digit0
"
take_while
(
1
.
.
AsChar
:
:
is_oct_digit
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
alphanumeric0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
alphanumeric0
"
take_while
(
0
.
.
AsChar
:
:
is_alphanum
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
alphanumeric1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
alphanumeric1
"
take_while
(
1
.
.
AsChar
:
:
is_alphanum
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
space0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
space0
"
take_while
(
0
.
.
AsChar
:
:
is_space
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
space1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
Error
:
ParserError
<
Input
>
{
trace
(
"
space1
"
take_while
(
1
.
.
AsChar
:
:
is_space
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
multispace0
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
+
Clone
Error
:
ParserError
<
Input
>
{
trace
(
"
multispace0
"
take_while
(
0
.
.
(
'
'
'
\
t
'
'
\
r
'
'
\
n
'
)
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
multispace1
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
+
Clone
Error
:
ParserError
<
Input
>
{
trace
(
"
multispace1
"
take_while
(
1
.
.
(
'
'
'
\
t
'
'
\
r
'
'
\
n
'
)
)
)
.
parse_next
(
input
)
}
#
[
doc
(
alias
=
"
u8
"
)
]
#
[
doc
(
alias
=
"
u16
"
)
]
#
[
doc
(
alias
=
"
u32
"
)
]
#
[
doc
(
alias
=
"
u64
"
)
]
#
[
doc
(
alias
=
"
u128
"
)
]
pub
fn
dec_uint
<
Input
Output
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Slice
:
AsBStr
<
Input
as
Stream
>
:
:
Token
:
AsChar
+
Clone
Output
:
Uint
Error
:
ParserError
<
Input
>
{
trace
(
"
dec_uint
"
move
|
input
:
&
mut
Input
|
{
alt
(
(
(
one_of
(
'
1
'
.
.
=
'
9
'
)
digit0
)
.
void
(
)
one_of
(
'
0
'
)
.
void
(
)
)
)
.
take
(
)
.
verify_map
(
|
s
:
<
Input
as
Stream
>
:
:
Slice
|
{
let
s
=
s
.
as_bstr
(
)
;
let
s
=
unsafe
{
crate
:
:
lib
:
:
std
:
:
str
:
:
from_utf8_unchecked
(
s
)
}
;
Output
:
:
try_from_dec_uint
(
s
)
}
)
.
parse_next
(
input
)
}
)
.
parse_next
(
input
)
}
pub
trait
Uint
:
Sized
{
#
[
doc
(
hidden
)
]
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
;
}
impl
Uint
for
u8
{
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Uint
for
u16
{
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Uint
for
u32
{
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Uint
for
u64
{
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Uint
for
u128
{
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Uint
for
usize
{
fn
try_from_dec_uint
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
#
[
doc
(
alias
=
"
i8
"
)
]
#
[
doc
(
alias
=
"
i16
"
)
]
#
[
doc
(
alias
=
"
i32
"
)
]
#
[
doc
(
alias
=
"
i64
"
)
]
#
[
doc
(
alias
=
"
i128
"
)
]
pub
fn
dec_int
<
Input
Output
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Slice
:
AsBStr
<
Input
as
Stream
>
:
:
Token
:
AsChar
+
Clone
Output
:
Int
Error
:
ParserError
<
Input
>
{
trace
(
"
dec_int
"
move
|
input
:
&
mut
Input
|
{
let
sign
=
opt
(
dispatch
!
{
any
.
map
(
AsChar
:
:
as_char
)
;
'
+
'
=
>
empty
.
value
(
true
)
'
-
'
=
>
empty
.
value
(
false
)
_
=
>
fail
}
)
;
alt
(
(
(
sign
one_of
(
'
1
'
.
.
=
'
9
'
)
digit0
)
.
void
(
)
one_of
(
'
0
'
)
.
void
(
)
)
)
.
take
(
)
.
verify_map
(
|
s
:
<
Input
as
Stream
>
:
:
Slice
|
{
let
s
=
s
.
as_bstr
(
)
;
let
s
=
unsafe
{
crate
:
:
lib
:
:
std
:
:
str
:
:
from_utf8_unchecked
(
s
)
}
;
Output
:
:
try_from_dec_int
(
s
)
}
)
.
parse_next
(
input
)
}
)
.
parse_next
(
input
)
}
pub
trait
Int
:
Sized
{
#
[
doc
(
hidden
)
]
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
;
}
impl
Int
for
i8
{
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Int
for
i16
{
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Int
for
i32
{
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Int
for
i64
{
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Int
for
i128
{
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
impl
Int
for
isize
{
fn
try_from_dec_int
(
slice
:
&
str
)
-
>
Option
<
Self
>
{
slice
.
parse
(
)
.
ok
(
)
}
}
#
[
inline
]
pub
fn
hex_uint
<
Input
Output
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
AsChar
<
Input
as
Stream
>
:
:
Slice
:
AsBStr
Output
:
HexUint
Error
:
ParserError
<
Input
>
{
trace
(
"
hex_uint
"
move
|
input
:
&
mut
Input
|
{
let
invalid_offset
=
input
.
offset_for
(
|
c
|
{
let
c
=
c
.
as_char
(
)
;
!
"
0123456789abcdefABCDEF
"
.
contains
(
c
)
}
)
.
unwrap_or_else
(
|
|
input
.
eof_offset
(
)
)
;
let
max_nibbles
=
Output
:
:
max_nibbles
(
sealed
:
:
SealedMarker
)
;
let
max_offset
=
input
.
offset_at
(
max_nibbles
)
;
let
offset
=
match
max_offset
{
Ok
(
max_offset
)
=
>
{
if
max_offset
<
invalid_offset
{
return
Err
(
ParserError
:
:
from_input
(
input
)
)
;
}
else
{
invalid_offset
}
}
Err
(
_
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
&
&
input
.
is_partial
(
)
&
&
invalid_offset
=
=
input
.
eof_offset
(
)
{
return
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
new
(
1
)
)
)
;
}
else
{
invalid_offset
}
}
}
;
if
offset
=
=
0
{
return
Err
(
ParserError
:
:
from_input
(
input
)
)
;
}
let
parsed
=
input
.
next_slice
(
offset
)
;
let
mut
res
=
Output
:
:
default
(
)
;
for
c
in
parsed
.
as_bstr
(
)
{
let
nibble
=
*
c
as
char
;
let
nibble
=
nibble
.
to_digit
(
16
)
.
unwrap_or
(
0
)
as
u8
;
let
nibble
=
Output
:
:
from
(
nibble
)
;
res
=
(
res
<
<
Output
:
:
from
(
4
)
)
+
nibble
;
}
Ok
(
res
)
}
)
.
parse_next
(
input
)
}
pub
trait
HexUint
:
Default
+
Shl
<
Self
Output
=
Self
>
+
Add
<
Self
Output
=
Self
>
+
From
<
u8
>
{
#
[
doc
(
hidden
)
]
fn
max_nibbles
(
_
:
sealed
:
:
SealedMarker
)
-
>
usize
;
}
impl
HexUint
for
u8
{
#
[
inline
(
always
)
]
fn
max_nibbles
(
_
:
sealed
:
:
SealedMarker
)
-
>
usize
{
2
}
}
impl
HexUint
for
u16
{
#
[
inline
(
always
)
]
fn
max_nibbles
(
_
:
sealed
:
:
SealedMarker
)
-
>
usize
{
4
}
}
impl
HexUint
for
u32
{
#
[
inline
(
always
)
]
fn
max_nibbles
(
_
:
sealed
:
:
SealedMarker
)
-
>
usize
{
8
}
}
impl
HexUint
for
u64
{
#
[
inline
(
always
)
]
fn
max_nibbles
(
_
:
sealed
:
:
SealedMarker
)
-
>
usize
{
16
}
}
impl
HexUint
for
u128
{
#
[
inline
(
always
)
]
fn
max_nibbles
(
_
:
sealed
:
:
SealedMarker
)
-
>
usize
{
32
}
}
#
[
inline
(
always
)
]
#
[
doc
(
alias
=
"
f32
"
)
]
#
[
doc
(
alias
=
"
double
"
)
]
#
[
allow
(
clippy
:
:
trait_duplication_in_bounds
)
]
pub
fn
float
<
Input
Output
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
Caseless
<
&
'
static
str
>
>
+
Compare
<
char
>
+
AsBStr
<
Input
as
Stream
>
:
:
Slice
:
ParseSlice
<
Output
>
<
Input
as
Stream
>
:
:
Token
:
AsChar
+
Clone
<
Input
as
Stream
>
:
:
IterOffsets
:
Clone
Error
:
ParserError
<
Input
>
{
trace
(
"
float
"
move
|
input
:
&
mut
Input
|
{
let
s
=
take_float_or_exceptions
(
input
)
?
;
s
.
parse_slice
(
)
.
ok_or_else
(
|
|
ParserError
:
:
from_input
(
input
)
)
}
)
.
parse_next
(
input
)
}
#
[
allow
(
clippy
:
:
trait_duplication_in_bounds
)
]
fn
take_float_or_exceptions
<
I
E
:
ParserError
<
I
>
>
(
input
:
&
mut
I
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
E
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
Caseless
<
&
'
static
str
>
>
I
:
Compare
<
char
>
<
I
as
Stream
>
:
:
Token
:
AsChar
+
Clone
<
I
as
Stream
>
:
:
IterOffsets
:
Clone
I
:
AsBStr
{
dispatch
!
{
opt
(
peek
(
any
)
.
map
(
AsChar
:
:
as_char
)
)
;
Some
(
'
N
'
)
|
Some
(
'
n
'
)
=
>
Caseless
(
"
nan
"
)
.
void
(
)
Some
(
'
+
'
)
|
Some
(
'
-
'
)
=
>
(
any
take_unsigned_float_or_exceptions
)
.
void
(
)
_
=
>
take_unsigned_float_or_exceptions
}
.
take
(
)
.
parse_next
(
input
)
}
#
[
allow
(
clippy
:
:
trait_duplication_in_bounds
)
]
fn
take_unsigned_float_or_exceptions
<
I
E
:
ParserError
<
I
>
>
(
input
:
&
mut
I
)
-
>
Result
<
(
)
E
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
Caseless
<
&
'
static
str
>
>
I
:
Compare
<
char
>
<
I
as
Stream
>
:
:
Token
:
AsChar
+
Clone
<
I
as
Stream
>
:
:
IterOffsets
:
Clone
I
:
AsBStr
{
dispatch
!
{
opt
(
peek
(
any
)
.
map
(
AsChar
:
:
as_char
)
)
;
Some
(
'
I
'
)
|
Some
(
'
i
'
)
=
>
(
Caseless
(
"
inf
"
)
opt
(
Caseless
(
"
inity
"
)
)
)
.
void
(
)
Some
(
'
.
'
)
=
>
(
'
.
'
digit1
take_exp
)
.
void
(
)
_
=
>
(
digit1
opt
(
(
'
.
'
opt
(
digit1
)
)
)
take_exp
)
.
void
(
)
}
.
parse_next
(
input
)
}
#
[
allow
(
clippy
:
:
trait_duplication_in_bounds
)
]
fn
take_exp
<
I
E
:
ParserError
<
I
>
>
(
input
:
&
mut
I
)
-
>
Result
<
(
)
E
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
char
>
<
I
as
Stream
>
:
:
Token
:
AsChar
+
Clone
<
I
as
Stream
>
:
:
IterOffsets
:
Clone
I
:
AsBStr
{
dispatch
!
{
opt
(
peek
(
any
)
.
map
(
AsChar
:
:
as_char
)
)
;
Some
(
'
E
'
)
|
Some
(
'
e
'
)
=
>
(
one_of
(
[
'
e
'
'
E
'
]
)
opt
(
one_of
(
[
'
+
'
'
-
'
]
)
)
digit1
)
.
void
(
)
_
=
>
empty
}
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
take_escaped
<
Input
Error
Normal
Escapable
NormalOutput
EscapableOutput
>
(
mut
normal
:
Normal
control_char
:
char
mut
escapable
:
Escapable
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
char
>
Normal
:
Parser
<
Input
NormalOutput
Error
>
Escapable
:
Parser
<
Input
EscapableOutput
Error
>
Error
:
ParserError
<
Input
>
{
trace
(
"
take_escaped
"
move
|
input
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
&
&
input
.
is_partial
(
)
{
escaped_internal
:
:
<
_
_
_
_
_
_
true
>
(
input
&
mut
normal
control_char
&
mut
escapable
)
}
else
{
escaped_internal
:
:
<
_
_
_
_
_
_
false
>
(
input
&
mut
normal
control_char
&
mut
escapable
)
}
}
)
}
fn
escaped_internal
<
I
Error
F
G
O1
O2
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
normal
:
&
mut
F
control_char
:
char
escapable
:
&
mut
G
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
char
>
F
:
Parser
<
I
O1
Error
>
G
:
Parser
<
I
O2
Error
>
Error
:
ParserError
<
I
>
{
let
start
=
input
.
checkpoint
(
)
;
while
input
.
eof_offset
(
)
>
0
{
let
current_len
=
input
.
eof_offset
(
)
;
match
opt
(
normal
.
by_ref
(
)
)
.
parse_next
(
input
)
?
{
Some
(
_
)
=
>
{
if
input
.
eof_offset
(
)
=
=
current_len
{
return
Err
(
ParserError
:
:
assert
(
input
"
take_escaped
parsers
must
always
consume
"
)
)
;
}
}
None
=
>
{
if
opt
(
control_char
)
.
parse_next
(
input
)
?
.
is_some
(
)
{
let
_
=
escapable
.
parse_next
(
input
)
?
;
}
else
{
let
offset
=
input
.
offset_from
(
&
start
)
;
input
.
reset
(
&
start
)
;
return
Ok
(
input
.
next_slice
(
offset
)
)
;
}
}
}
}
if
PARTIAL
&
&
input
.
is_partial
(
)
{
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
Unknown
)
)
}
else
{
input
.
reset
(
&
start
)
;
Ok
(
input
.
finish
(
)
)
}
}
#
[
inline
(
always
)
]
#
[
deprecated
(
since
=
"
7
.
0
.
0
"
note
=
"
replaced
with
escaped
"
)
]
pub
fn
escaped_transform
<
Input
Error
Normal
NormalOutput
Escape
EscapeOutput
Output
>
(
normal
:
Normal
control_char
:
char
escape
:
Escape
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
char
>
Normal
:
Parser
<
Input
NormalOutput
Error
>
Escape
:
Parser
<
Input
EscapeOutput
Error
>
Output
:
crate
:
:
stream
:
:
Accumulate
<
NormalOutput
>
Output
:
crate
:
:
stream
:
:
Accumulate
<
EscapeOutput
>
Error
:
ParserError
<
Input
>
{
escaped
(
normal
control_char
escape
)
}
#
[
inline
(
always
)
]
pub
fn
escaped
<
Input
Error
Normal
NormalOutput
Escape
EscapeOutput
Output
>
(
mut
normal
:
Normal
control_char
:
char
mut
escape
:
Escape
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
char
>
Normal
:
Parser
<
Input
NormalOutput
Error
>
Escape
:
Parser
<
Input
EscapeOutput
Error
>
Output
:
crate
:
:
stream
:
:
Accumulate
<
NormalOutput
>
Output
:
crate
:
:
stream
:
:
Accumulate
<
EscapeOutput
>
Error
:
ParserError
<
Input
>
{
trace
(
"
escaped
"
move
|
input
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
&
&
input
.
is_partial
(
)
{
escaped_transform_internal
:
:
<
_
_
_
_
_
_
_
true
>
(
input
&
mut
normal
control_char
&
mut
escape
)
}
else
{
escaped_transform_internal
:
:
<
_
_
_
_
_
_
_
false
>
(
input
&
mut
normal
control_char
&
mut
escape
)
}
}
)
}
fn
escaped_transform_internal
<
I
Error
F
NormalOutput
G
EscapeOutput
Output
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
normal
:
&
mut
F
control_char
:
char
transform
:
&
mut
G
)
-
>
Result
<
Output
Error
>
where
I
:
StreamIsPartial
I
:
Stream
I
:
Compare
<
char
>
Output
:
crate
:
:
stream
:
:
Accumulate
<
NormalOutput
>
Output
:
crate
:
:
stream
:
:
Accumulate
<
EscapeOutput
>
F
:
Parser
<
I
NormalOutput
Error
>
G
:
Parser
<
I
EscapeOutput
Error
>
Error
:
ParserError
<
I
>
{
let
mut
res
=
<
Output
as
crate
:
:
stream
:
:
Accumulate
<
NormalOutput
>
>
:
:
initial
(
Some
(
input
.
eof_offset
(
)
)
)
;
while
input
.
eof_offset
(
)
>
0
{
let
current_len
=
input
.
eof_offset
(
)
;
match
opt
(
normal
.
by_ref
(
)
)
.
parse_next
(
input
)
?
{
Some
(
o
)
=
>
{
res
.
accumulate
(
o
)
;
if
input
.
eof_offset
(
)
=
=
current_len
{
return
Err
(
ParserError
:
:
assert
(
input
"
escaped_transform
parsers
must
always
consume
"
)
)
;
}
}
None
=
>
{
if
opt
(
control_char
)
.
parse_next
(
input
)
?
.
is_some
(
)
{
let
o
=
transform
.
parse_next
(
input
)
?
;
res
.
accumulate
(
o
)
;
}
else
{
return
Ok
(
res
)
;
}
}
}
}
if
PARTIAL
&
&
input
.
is_partial
(
)
{
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
Unknown
)
)
}
else
{
Ok
(
res
)
}
}
mod
sealed
{
#
[
allow
(
unnameable_types
)
]
pub
struct
SealedMarker
;
}
