#
[
cfg
(
test
)
]
mod
tests
;
use
crate
:
:
combinator
:
:
trace
;
use
crate
:
:
combinator
:
:
DisplayDebug
;
use
crate
:
:
error
:
:
Needed
;
use
crate
:
:
error
:
:
ParserError
;
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
Ok
;
use
crate
:
:
stream
:
:
Range
;
use
crate
:
:
stream
:
:
{
Compare
CompareResult
ContainsToken
FindSlice
Stream
}
;
use
crate
:
:
stream
:
:
{
StreamIsPartial
ToUsize
}
;
use
crate
:
:
Parser
;
use
crate
:
:
Result
;
#
[
inline
(
always
)
]
#
[
doc
(
alias
=
"
token
"
)
]
pub
fn
any
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Token
Error
>
where
Input
:
StreamIsPartial
+
Stream
Error
:
ParserError
<
Input
>
{
trace
(
"
any
"
move
|
input
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
any_
:
:
<
_
_
true
>
(
input
)
}
else
{
any_
:
:
<
_
_
false
>
(
input
)
}
}
)
.
parse_next
(
input
)
}
fn
any_
<
I
E
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
)
-
>
Result
<
<
I
as
Stream
>
:
:
Token
E
>
where
I
:
StreamIsPartial
I
:
Stream
{
input
.
next_token
(
)
.
ok_or_else
(
|
|
{
if
PARTIAL
&
&
input
.
is_partial
(
)
{
ParserError
:
:
incomplete
(
input
Needed
:
:
new
(
1
)
)
}
else
{
ParserError
:
:
from_input
(
input
)
}
}
)
}
#
[
inline
(
always
)
]
#
[
doc
(
alias
=
"
tag
"
)
]
#
[
doc
(
alias
=
"
bytes
"
)
]
#
[
doc
(
alias
=
"
just
"
)
]
pub
fn
literal
<
Literal
Input
Error
>
(
literal
:
Literal
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
Compare
<
Literal
>
Literal
:
Clone
+
crate
:
:
lib
:
:
std
:
:
fmt
:
:
Debug
Error
:
ParserError
<
Input
>
{
trace
(
DisplayDebug
(
literal
.
clone
(
)
)
move
|
i
:
&
mut
Input
|
{
let
t
=
literal
.
clone
(
)
;
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
literal_
:
:
<
_
_
_
true
>
(
i
t
)
}
else
{
literal_
:
:
<
_
_
_
false
>
(
i
t
)
}
}
)
}
fn
literal_
<
T
I
Error
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
i
:
&
mut
I
t
:
T
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
+
Compare
<
T
>
T
:
crate
:
:
lib
:
:
std
:
:
fmt
:
:
Debug
{
match
i
.
compare
(
t
)
{
CompareResult
:
:
Ok
(
len
)
=
>
Ok
(
i
.
next_slice
(
len
)
)
CompareResult
:
:
Incomplete
if
PARTIAL
&
&
i
.
is_partial
(
)
=
>
{
Err
(
ParserError
:
:
incomplete
(
i
Needed
:
:
Unknown
)
)
}
CompareResult
:
:
Incomplete
|
CompareResult
:
:
Error
=
>
Err
(
ParserError
:
:
from_input
(
i
)
)
}
}
#
[
inline
(
always
)
]
#
[
doc
(
alias
=
"
char
"
)
]
#
[
doc
(
alias
=
"
token
"
)
]
#
[
doc
(
alias
=
"
satisfy
"
)
]
pub
fn
one_of
<
Input
Set
Error
>
(
set
:
Set
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Token
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
Clone
Set
:
ContainsToken
<
<
Input
as
Stream
>
:
:
Token
>
Error
:
ParserError
<
Input
>
{
trace
(
"
one_of
"
any
.
verify
(
move
|
t
:
&
<
Input
as
Stream
>
:
:
Token
|
set
.
contains_token
(
t
.
clone
(
)
)
)
)
}
#
[
inline
(
always
)
]
pub
fn
none_of
<
Input
Set
Error
>
(
set
:
Set
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Token
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Input
as
Stream
>
:
:
Token
:
Clone
Set
:
ContainsToken
<
<
Input
as
Stream
>
:
:
Token
>
Error
:
ParserError
<
Input
>
{
trace
(
"
none_of
"
any
.
verify
(
move
|
t
:
&
<
Input
as
Stream
>
:
:
Token
|
!
set
.
contains_token
(
t
.
clone
(
)
)
)
)
}
#
[
inline
(
always
)
]
#
[
doc
(
alias
=
"
is_a
"
)
]
#
[
doc
(
alias
=
"
take_while0
"
)
]
#
[
doc
(
alias
=
"
take_while1
"
)
]
pub
fn
take_while
<
Set
Input
Error
>
(
occurrences
:
impl
Into
<
Range
>
set
:
Set
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
Set
:
ContainsToken
<
<
Input
as
Stream
>
:
:
Token
>
Error
:
ParserError
<
Input
>
{
let
Range
{
start_inclusive
end_inclusive
}
=
occurrences
.
into
(
)
;
trace
(
"
take_while
"
move
|
i
:
&
mut
Input
|
{
match
(
start_inclusive
end_inclusive
)
{
(
0
None
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_till0
:
:
<
_
_
_
true
>
(
i
|
c
|
!
set
.
contains_token
(
c
)
)
}
else
{
take_till0
:
:
<
_
_
_
false
>
(
i
|
c
|
!
set
.
contains_token
(
c
)
)
}
}
(
1
None
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_till1
:
:
<
_
_
_
true
>
(
i
|
c
|
!
set
.
contains_token
(
c
)
)
}
else
{
take_till1
:
:
<
_
_
_
false
>
(
i
|
c
|
!
set
.
contains_token
(
c
)
)
}
}
(
start
end
)
=
>
{
let
end
=
end
.
unwrap_or
(
usize
:
:
MAX
)
;
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_till_m_n
:
:
<
_
_
_
true
>
(
i
start
end
|
c
|
!
set
.
contains_token
(
c
)
)
}
else
{
take_till_m_n
:
:
<
_
_
_
false
>
(
i
start
end
|
c
|
!
set
.
contains_token
(
c
)
)
}
}
}
}
)
}
fn
take_till0
<
P
I
:
StreamIsPartial
+
Stream
E
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
predicate
:
P
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
E
>
where
P
:
Fn
(
I
:
:
Token
)
-
>
bool
{
let
offset
=
match
input
.
offset_for
(
predicate
)
{
Some
(
offset
)
=
>
offset
None
if
PARTIAL
&
&
input
.
is_partial
(
)
=
>
{
return
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
new
(
1
)
)
)
;
}
None
=
>
input
.
eof_offset
(
)
}
;
Ok
(
input
.
next_slice
(
offset
)
)
}
fn
take_till1
<
P
I
:
StreamIsPartial
+
Stream
E
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
predicate
:
P
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
E
>
where
P
:
Fn
(
I
:
:
Token
)
-
>
bool
{
let
offset
=
match
input
.
offset_for
(
predicate
)
{
Some
(
offset
)
=
>
offset
None
if
PARTIAL
&
&
input
.
is_partial
(
)
=
>
{
return
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
new
(
1
)
)
)
;
}
None
=
>
input
.
eof_offset
(
)
}
;
if
offset
=
=
0
{
Err
(
ParserError
:
:
from_input
(
input
)
)
}
else
{
Ok
(
input
.
next_slice
(
offset
)
)
}
}
fn
take_till_m_n
<
P
I
Error
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
input
:
&
mut
I
m
:
usize
n
:
usize
predicate
:
P
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
P
:
Fn
(
I
:
:
Token
)
-
>
bool
{
if
n
<
m
{
return
Err
(
ParserError
:
:
assert
(
input
"
occurrences
should
be
ascending
rather
than
descending
"
)
)
;
}
let
mut
final_count
=
0
;
for
(
processed
(
offset
token
)
)
in
input
.
iter_offsets
(
)
.
enumerate
(
)
{
if
predicate
(
token
)
{
if
processed
<
m
{
return
Err
(
ParserError
:
:
from_input
(
input
)
)
;
}
else
{
return
Ok
(
input
.
next_slice
(
offset
)
)
;
}
}
else
{
if
processed
=
=
n
{
return
Ok
(
input
.
next_slice
(
offset
)
)
;
}
final_count
=
processed
+
1
;
}
}
if
PARTIAL
&
&
input
.
is_partial
(
)
{
if
final_count
=
=
n
{
Ok
(
input
.
finish
(
)
)
}
else
{
let
needed
=
if
m
>
input
.
eof_offset
(
)
{
m
-
input
.
eof_offset
(
)
}
else
{
1
}
;
Err
(
ParserError
:
:
incomplete
(
input
Needed
:
:
new
(
needed
)
)
)
}
}
else
{
if
m
<
=
final_count
{
Ok
(
input
.
finish
(
)
)
}
else
{
Err
(
ParserError
:
:
from_input
(
input
)
)
}
}
}
#
[
inline
(
always
)
]
#
[
doc
(
alias
=
"
is_not
"
)
]
pub
fn
take_till
<
Set
Input
Error
>
(
occurrences
:
impl
Into
<
Range
>
set
:
Set
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
Set
:
ContainsToken
<
<
Input
as
Stream
>
:
:
Token
>
Error
:
ParserError
<
Input
>
{
let
Range
{
start_inclusive
end_inclusive
}
=
occurrences
.
into
(
)
;
trace
(
"
take_till
"
move
|
i
:
&
mut
Input
|
{
match
(
start_inclusive
end_inclusive
)
{
(
0
None
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_till0
:
:
<
_
_
_
true
>
(
i
|
c
|
set
.
contains_token
(
c
)
)
}
else
{
take_till0
:
:
<
_
_
_
false
>
(
i
|
c
|
set
.
contains_token
(
c
)
)
}
}
(
1
None
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_till1
:
:
<
_
_
_
true
>
(
i
|
c
|
set
.
contains_token
(
c
)
)
}
else
{
take_till1
:
:
<
_
_
_
false
>
(
i
|
c
|
set
.
contains_token
(
c
)
)
}
}
(
start
end
)
=
>
{
let
end
=
end
.
unwrap_or
(
usize
:
:
MAX
)
;
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_till_m_n
:
:
<
_
_
_
true
>
(
i
start
end
|
c
|
set
.
contains_token
(
c
)
)
}
else
{
take_till_m_n
:
:
<
_
_
_
false
>
(
i
start
end
|
c
|
set
.
contains_token
(
c
)
)
}
}
}
}
)
}
#
[
inline
(
always
)
]
pub
fn
take
<
UsizeLike
Input
Error
>
(
token_count
:
UsizeLike
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
UsizeLike
:
ToUsize
Error
:
ParserError
<
Input
>
{
let
c
=
token_count
.
to_usize
(
)
;
trace
(
"
take
"
move
|
i
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_
:
:
<
_
_
true
>
(
i
c
)
}
else
{
take_
:
:
<
_
_
false
>
(
i
c
)
}
}
)
}
fn
take_
<
I
Error
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
i
:
&
mut
I
c
:
usize
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
{
match
i
.
offset_at
(
c
)
{
Ok
(
offset
)
=
>
Ok
(
i
.
next_slice
(
offset
)
)
Err
(
e
)
if
PARTIAL
&
&
i
.
is_partial
(
)
=
>
Err
(
ParserError
:
:
incomplete
(
i
e
)
)
Err
(
_needed
)
=
>
Err
(
ParserError
:
:
from_input
(
i
)
)
}
}
#
[
inline
(
always
)
]
pub
fn
take_until
<
Literal
Input
Error
>
(
occurrences
:
impl
Into
<
Range
>
literal
:
Literal
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
FindSlice
<
Literal
>
Literal
:
Clone
Error
:
ParserError
<
Input
>
{
let
Range
{
start_inclusive
end_inclusive
}
=
occurrences
.
into
(
)
;
trace
(
"
take_until
"
move
|
i
:
&
mut
Input
|
{
match
(
start_inclusive
end_inclusive
)
{
(
0
None
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_until0_
:
:
<
_
_
_
true
>
(
i
literal
.
clone
(
)
)
}
else
{
take_until0_
:
:
<
_
_
_
false
>
(
i
literal
.
clone
(
)
)
}
}
(
1
None
)
=
>
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_until1_
:
:
<
_
_
_
true
>
(
i
literal
.
clone
(
)
)
}
else
{
take_until1_
:
:
<
_
_
_
false
>
(
i
literal
.
clone
(
)
)
}
}
(
start
end
)
=
>
{
let
end
=
end
.
unwrap_or
(
usize
:
:
MAX
)
;
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
take_until_m_n_
:
:
<
_
_
_
true
>
(
i
start
end
literal
.
clone
(
)
)
}
else
{
take_until_m_n_
:
:
<
_
_
_
false
>
(
i
start
end
literal
.
clone
(
)
)
}
}
}
}
)
}
fn
take_until0_
<
T
I
Error
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
i
:
&
mut
I
t
:
T
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
+
FindSlice
<
T
>
{
match
i
.
find_slice
(
t
)
{
Some
(
range
)
=
>
Ok
(
i
.
next_slice
(
range
.
start
)
)
None
if
PARTIAL
&
&
i
.
is_partial
(
)
=
>
Err
(
ParserError
:
:
incomplete
(
i
Needed
:
:
Unknown
)
)
None
=
>
Err
(
ParserError
:
:
from_input
(
i
)
)
}
}
fn
take_until1_
<
T
I
Error
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
i
:
&
mut
I
t
:
T
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
+
FindSlice
<
T
>
{
match
i
.
find_slice
(
t
)
{
None
if
PARTIAL
&
&
i
.
is_partial
(
)
=
>
Err
(
ParserError
:
:
incomplete
(
i
Needed
:
:
Unknown
)
)
None
=
>
Err
(
ParserError
:
:
from_input
(
i
)
)
Some
(
range
)
=
>
{
if
range
.
start
=
=
0
{
Err
(
ParserError
:
:
from_input
(
i
)
)
}
else
{
Ok
(
i
.
next_slice
(
range
.
start
)
)
}
}
}
}
fn
take_until_m_n_
<
T
I
Error
:
ParserError
<
I
>
const
PARTIAL
:
bool
>
(
i
:
&
mut
I
start
:
usize
end
:
usize
t
:
T
)
-
>
Result
<
<
I
as
Stream
>
:
:
Slice
Error
>
where
I
:
StreamIsPartial
I
:
Stream
+
FindSlice
<
T
>
{
if
end
<
start
{
return
Err
(
ParserError
:
:
assert
(
i
"
occurrences
should
be
ascending
rather
than
descending
"
)
)
;
}
match
i
.
find_slice
(
t
)
{
Some
(
range
)
=
>
{
let
start_offset
=
i
.
offset_at
(
start
)
;
let
end_offset
=
i
.
offset_at
(
end
)
.
unwrap_or_else
(
|
_err
|
i
.
eof_offset
(
)
)
;
if
start_offset
.
map
(
|
s
|
range
.
start
<
s
)
.
unwrap_or
(
true
)
{
if
PARTIAL
&
&
i
.
is_partial
(
)
{
return
Err
(
ParserError
:
:
incomplete
(
i
Needed
:
:
Unknown
)
)
;
}
else
{
return
Err
(
ParserError
:
:
from_input
(
i
)
)
;
}
}
if
end_offset
<
range
.
start
{
return
Err
(
ParserError
:
:
from_input
(
i
)
)
;
}
Ok
(
i
.
next_slice
(
range
.
start
)
)
}
None
if
PARTIAL
&
&
i
.
is_partial
(
)
=
>
Err
(
ParserError
:
:
incomplete
(
i
Needed
:
:
Unknown
)
)
None
=
>
Err
(
ParserError
:
:
from_input
(
i
)
)
}
}
#
[
inline
]
pub
fn
rest
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
{
trace
(
"
rest
"
move
|
input
:
&
mut
Input
|
Ok
(
input
.
finish
(
)
)
)
.
parse_next
(
input
)
}
#
[
inline
]
pub
fn
rest_len
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
usize
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
{
trace
(
"
rest_len
"
move
|
input
:
&
mut
Input
|
{
let
len
=
input
.
eof_offset
(
)
;
Ok
(
len
)
}
)
.
parse_next
(
input
)
}
