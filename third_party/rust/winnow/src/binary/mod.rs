#
!
[
allow
(
clippy
:
:
match_same_arms
)
]
pub
mod
bits
;
#
[
cfg
(
test
)
]
mod
tests
;
use
crate
:
:
combinator
:
:
repeat
;
use
crate
:
:
combinator
:
:
trace
;
use
crate
:
:
error
:
:
Needed
;
use
crate
:
:
error
:
:
ParserError
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
{
Add
Shl
}
;
use
crate
:
:
stream
:
:
Accumulate
;
use
crate
:
:
stream
:
:
{
Stream
StreamIsPartial
}
;
use
crate
:
:
stream
:
:
{
ToUsize
UpdateSlice
}
;
use
crate
:
:
Parser
;
use
crate
:
:
Result
;
#
[
derive
(
Debug
PartialEq
Eq
Clone
Copy
)
]
pub
enum
Endianness
{
Big
Little
Native
}
#
[
inline
(
always
)
]
pub
fn
be_u8
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
u8
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_u16
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u16
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_u16
"
move
|
input
:
&
mut
Input
|
be_uint
(
input
2
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_u24
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_u23
"
move
|
input
:
&
mut
Input
|
be_uint
(
input
3
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_u32
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_u32
"
move
|
input
:
&
mut
Input
|
be_uint
(
input
4
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_u64
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_u64
"
move
|
input
:
&
mut
Input
|
be_uint
(
input
8
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_u128
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u128
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_u128
"
move
|
input
:
&
mut
Input
|
be_uint
(
input
16
)
)
.
parse_next
(
input
)
}
#
[
inline
]
fn
be_uint
<
Input
Uint
Error
>
(
input
:
&
mut
Input
bound
:
usize
)
-
>
Result
<
Uint
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Uint
:
Default
+
Shl
<
u8
Output
=
Uint
>
+
Add
<
Uint
Output
=
Uint
>
+
From
<
u8
>
Error
:
ParserError
<
Input
>
{
debug_assert_ne
!
(
bound
1
"
to_be_uint
needs
extra
work
to
avoid
overflow
"
)
;
match
input
.
offset_at
(
bound
)
{
Ok
(
offset
)
=
>
{
let
res
=
to_be_uint
(
input
offset
)
;
input
.
next_slice
(
offset
)
;
Ok
(
res
)
}
Err
(
e
)
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
&
&
input
.
is_partial
(
)
=
>
{
Err
(
ParserError
:
:
incomplete
(
input
e
)
)
}
Err
(
_needed
)
=
>
Err
(
ParserError
:
:
from_input
(
input
)
)
}
}
#
[
inline
]
fn
to_be_uint
<
Input
Uint
>
(
number
:
&
Input
offset
:
usize
)
-
>
Uint
where
Input
:
Stream
Uint
:
Default
+
Shl
<
u8
Output
=
Uint
>
+
Add
<
Uint
Output
=
Uint
>
+
From
<
<
Input
as
Stream
>
:
:
Token
>
{
let
mut
res
=
Uint
:
:
default
(
)
;
for
(
_
byte
)
in
number
.
iter_offsets
(
)
.
take
(
offset
)
{
res
=
(
res
<
<
8
)
+
byte
.
into
(
)
;
}
res
}
#
[
inline
(
always
)
]
pub
fn
be_i8
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
i8
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_i16
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i16
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_i16
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u16
_
>
(
input
2
)
.
map
(
|
n
|
n
as
i16
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_i24
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_i24
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u32
_
>
(
input
3
)
.
map
(
|
n
|
{
let
n
=
if
n
&
0x80_00_00
!
=
0
{
(
n
|
0xff_00_00_00
)
as
i32
}
else
{
n
as
i32
}
;
n
}
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_i32
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_i32
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u32
_
>
(
input
4
)
.
map
(
|
n
|
n
as
i32
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_i64
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_i64
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u64
_
>
(
input
8
)
.
map
(
|
n
|
n
as
i64
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_i128
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i128
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_i128
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u128
_
>
(
input
16
)
.
map
(
|
n
|
n
as
i128
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_u8
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
u8
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_u16
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u16
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_u16
"
move
|
input
:
&
mut
Input
|
le_uint
(
input
2
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_u24
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_u24
"
move
|
input
:
&
mut
Input
|
le_uint
(
input
3
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_u32
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_u32
"
move
|
input
:
&
mut
Input
|
le_uint
(
input
4
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_u64
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_u64
"
move
|
input
:
&
mut
Input
|
le_uint
(
input
8
)
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_u128
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u128
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_u128
"
move
|
input
:
&
mut
Input
|
le_uint
(
input
16
)
)
.
parse_next
(
input
)
}
#
[
inline
]
fn
le_uint
<
Input
Uint
Error
>
(
input
:
&
mut
Input
bound
:
usize
)
-
>
Result
<
Uint
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Uint
:
Default
+
Shl
<
u8
Output
=
Uint
>
+
Add
<
Uint
Output
=
Uint
>
+
From
<
u8
>
Error
:
ParserError
<
Input
>
{
match
input
.
offset_at
(
bound
)
{
Ok
(
offset
)
=
>
{
let
res
=
to_le_uint
(
input
offset
)
;
input
.
next_slice
(
offset
)
;
Ok
(
res
)
}
Err
(
e
)
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
&
&
input
.
is_partial
(
)
=
>
{
Err
(
ParserError
:
:
incomplete
(
input
e
)
)
}
Err
(
_needed
)
=
>
Err
(
ParserError
:
:
from_input
(
input
)
)
}
}
#
[
inline
]
fn
to_le_uint
<
Input
Uint
>
(
number
:
&
Input
offset
:
usize
)
-
>
Uint
where
Input
:
Stream
Uint
:
Default
+
Shl
<
u8
Output
=
Uint
>
+
Add
<
Uint
Output
=
Uint
>
+
From
<
<
Input
as
Stream
>
:
:
Token
>
{
let
mut
res
=
Uint
:
:
default
(
)
;
for
(
index
byte
)
in
number
.
iter_offsets
(
)
.
take
(
offset
)
{
res
=
res
+
(
Uint
:
:
from
(
byte
)
<
<
(
8
*
index
as
u8
)
)
;
}
res
}
#
[
inline
(
always
)
]
pub
fn
le_i8
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
i8
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_i16
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i16
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_i16
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u16
_
>
(
input
2
)
.
map
(
|
n
|
n
as
i16
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_i24
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_i24
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u32
_
>
(
input
3
)
.
map
(
|
n
|
{
let
n
=
if
n
&
0x80_00_00
!
=
0
{
(
n
|
0xff_00_00_00
)
as
i32
}
else
{
n
as
i32
}
;
n
}
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_i32
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_i32
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u32
_
>
(
input
4
)
.
map
(
|
n
|
n
as
i32
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_i64
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_i64
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u64
_
>
(
input
8
)
.
map
(
|
n
|
n
as
i64
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_i128
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i128
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_i128
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u128
_
>
(
input
16
)
.
map
(
|
n
|
n
as
i128
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
u8
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
u8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
u8
"
move
|
input
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
u8_
:
:
<
_
_
true
>
(
input
)
}
else
{
u8_
:
:
<
_
_
false
>
(
input
)
}
}
)
.
parse_next
(
input
)
}
fn
u8_
<
Input
Error
const
PARTIAL
:
bool
>
(
input
:
&
mut
Input
)
-
>
Result
<
u8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
input
.
next_token
(
)
.
ok_or_else
(
|
|
{
if
PARTIAL
&
&
input
.
is_partial
(
)
{
ParserError
:
:
incomplete
(
input
Needed
:
:
new
(
1
)
)
}
else
{
ParserError
:
:
from_input
(
input
)
}
}
)
}
#
[
inline
(
always
)
]
pub
fn
u16
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
u16
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_u16
Endianness
:
:
Little
=
>
le_u16
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_u16
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_u16
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
u24
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
u32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_u24
Endianness
:
:
Little
=
>
le_u24
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_u24
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_u24
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
u32
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
u32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_u32
Endianness
:
:
Little
=
>
le_u32
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_u32
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_u32
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
u64
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
u64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_u64
Endianness
:
:
Little
=
>
le_u64
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_u64
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_u64
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
u128
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
u128
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_u128
Endianness
:
:
Little
=
>
le_u128
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_u128
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_u128
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
i8
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
i8
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
i8
"
move
|
input
:
&
mut
Input
|
{
if
<
Input
as
StreamIsPartial
>
:
:
is_partial_supported
(
)
{
u8_
:
:
<
_
_
true
>
(
input
)
}
else
{
u8_
:
:
<
_
_
false
>
(
input
)
}
.
map
(
|
n
|
n
as
i8
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
i16
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
i16
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_i16
Endianness
:
:
Little
=
>
le_i16
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_i16
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_i16
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
i24
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
i32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_i24
Endianness
:
:
Little
=
>
le_i24
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_i24
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_i24
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
i32
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
i32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_i32
Endianness
:
:
Little
=
>
le_i32
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_i32
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_i32
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
i64
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
i64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_i64
Endianness
:
:
Little
=
>
le_i64
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_i64
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_i64
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
i128
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
i128
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_i128
Endianness
:
:
Little
=
>
le_i128
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_i128
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_i128
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_f32
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
f32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_f32
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u32
_
>
(
input
4
)
.
map
(
f32
:
:
from_bits
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
be_f64
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
f64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_f64
"
move
|
input
:
&
mut
Input
|
{
be_uint
:
:
<
_
u64
_
>
(
input
8
)
.
map
(
f64
:
:
from_bits
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_f32
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
f32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
le_f32
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u32
_
>
(
input
4
)
.
map
(
f32
:
:
from_bits
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
le_f64
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
f64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
trace
(
"
be_f64
"
move
|
input
:
&
mut
Input
|
{
le_uint
:
:
<
_
u64
_
>
(
input
8
)
.
map
(
f64
:
:
from_bits
)
}
)
.
parse_next
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
f32
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
f32
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_f32
Endianness
:
:
Little
=
>
le_f32
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_f32
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_f32
}
}
(
input
)
}
#
[
inline
(
always
)
]
pub
fn
f64
<
Input
Error
>
(
endian
:
Endianness
)
-
>
impl
Parser
<
Input
f64
Error
>
where
Input
:
StreamIsPartial
+
Stream
<
Token
=
u8
>
Error
:
ParserError
<
Input
>
{
move
|
input
:
&
mut
Input
|
{
match
endian
{
Endianness
:
:
Big
=
>
be_f64
Endianness
:
:
Little
=
>
le_f64
#
[
cfg
(
target_endian
=
"
big
"
)
]
Endianness
:
:
Native
=
>
be_f64
#
[
cfg
(
target_endian
=
"
little
"
)
]
Endianness
:
:
Native
=
>
le_f64
}
}
(
input
)
}
pub
fn
length_take
<
Input
Count
Error
CountParser
>
(
mut
count
:
CountParser
)
-
>
impl
Parser
<
Input
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
StreamIsPartial
+
Stream
Count
:
ToUsize
CountParser
:
Parser
<
Input
Count
Error
>
Error
:
ParserError
<
Input
>
{
trace
(
"
length_take
"
move
|
i
:
&
mut
Input
|
{
let
length
=
count
.
parse_next
(
i
)
?
;
crate
:
:
token
:
:
take
(
length
)
.
parse_next
(
i
)
}
)
}
pub
fn
length_and_then
<
Input
Output
Count
Error
CountParser
ParseNext
>
(
mut
count
:
CountParser
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
StreamIsPartial
+
Stream
+
UpdateSlice
+
Clone
Count
:
ToUsize
CountParser
:
Parser
<
Input
Count
Error
>
ParseNext
:
Parser
<
Input
Output
Error
>
Error
:
ParserError
<
Input
>
{
trace
(
"
length_and_then
"
move
|
i
:
&
mut
Input
|
{
let
data
=
length_take
(
count
.
by_ref
(
)
)
.
parse_next
(
i
)
?
;
let
mut
data
=
Input
:
:
update_slice
(
i
.
clone
(
)
data
)
;
let
_
=
data
.
complete
(
)
;
let
o
=
parser
.
by_ref
(
)
.
complete_err
(
)
.
parse_next
(
&
mut
data
)
?
;
Ok
(
o
)
}
)
}
pub
fn
length_repeat
<
Input
Output
Accumulator
Count
Error
CountParser
ParseNext
>
(
mut
count
:
CountParser
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Accumulator
Error
>
where
Input
:
Stream
Count
:
ToUsize
Accumulator
:
Accumulate
<
Output
>
CountParser
:
Parser
<
Input
Count
Error
>
ParseNext
:
Parser
<
Input
Output
Error
>
Error
:
ParserError
<
Input
>
{
trace
(
"
length_repeat
"
move
|
i
:
&
mut
Input
|
{
let
n
=
count
.
parse_next
(
i
)
?
;
let
n
=
n
.
to_usize
(
)
;
repeat
(
n
parser
.
by_ref
(
)
)
.
parse_next
(
i
)
}
)
}
