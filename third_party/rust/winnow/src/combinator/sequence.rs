use
crate
:
:
combinator
:
:
trace
;
use
crate
:
:
error
:
:
ParserError
;
use
crate
:
:
stream
:
:
Stream
;
use
crate
:
:
*
;
#
[
doc
(
inline
)
]
pub
use
crate
:
:
seq
;
#
[
doc
(
alias
=
"
ignore_then
"
)
]
pub
fn
preceded
<
Input
Ignored
Output
Error
IgnoredParser
ParseNext
>
(
mut
ignored
:
IgnoredParser
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
IgnoredParser
:
Parser
<
Input
Ignored
Error
>
ParseNext
:
Parser
<
Input
Output
Error
>
{
trace
(
"
preceded
"
move
|
input
:
&
mut
Input
|
{
let
_
=
ignored
.
parse_next
(
input
)
?
;
parser
.
parse_next
(
input
)
}
)
}
#
[
doc
(
alias
=
"
then_ignore
"
)
]
pub
fn
terminated
<
Input
Output
Ignored
Error
ParseNext
IgnoredParser
>
(
mut
parser
:
ParseNext
mut
ignored
:
IgnoredParser
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
ParseNext
:
Parser
<
Input
Output
Error
>
IgnoredParser
:
Parser
<
Input
Ignored
Error
>
{
trace
(
"
terminated
"
move
|
input
:
&
mut
Input
|
{
let
o
=
parser
.
parse_next
(
input
)
?
;
ignored
.
parse_next
(
input
)
.
map
(
|
_
|
o
)
}
)
}
pub
fn
separated_pair
<
Input
O1
Sep
O2
Error
P1
SepParser
P2
>
(
mut
first
:
P1
mut
sep
:
SepParser
mut
second
:
P2
)
-
>
impl
Parser
<
Input
(
O1
O2
)
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
P1
:
Parser
<
Input
O1
Error
>
SepParser
:
Parser
<
Input
Sep
Error
>
P2
:
Parser
<
Input
O2
Error
>
{
trace
(
"
separated_pair
"
move
|
input
:
&
mut
Input
|
{
let
o1
=
first
.
parse_next
(
input
)
?
;
let
_
=
sep
.
parse_next
(
input
)
?
;
second
.
parse_next
(
input
)
.
map
(
|
o2
|
(
o1
o2
)
)
}
)
}
#
[
doc
(
alias
=
"
between
"
)
]
#
[
doc
(
alias
=
"
padded
"
)
]
pub
fn
delimited
<
Input
Ignored1
Output
Ignored2
Error
IgnoredParser1
ParseNext
IgnoredParser2
>
(
mut
ignored1
:
IgnoredParser1
mut
parser
:
ParseNext
mut
ignored2
:
IgnoredParser2
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
IgnoredParser1
:
Parser
<
Input
Ignored1
Error
>
ParseNext
:
Parser
<
Input
Output
Error
>
IgnoredParser2
:
Parser
<
Input
Ignored2
Error
>
{
trace
(
"
delimited
"
move
|
input
:
&
mut
Input
|
{
let
_
=
ignored1
.
parse_next
(
input
)
?
;
let
o2
=
parser
.
parse_next
(
input
)
?
;
ignored2
.
parse_next
(
input
)
.
map
(
|
_
|
o2
)
}
)
}
