use
crate
:
:
combinator
:
:
trace
;
use
crate
:
:
error
:
:
{
ModalError
ParserError
}
;
use
crate
:
:
stream
:
:
Stream
;
use
crate
:
:
*
;
pub
fn
opt
<
Input
:
Stream
Output
Error
ParseNext
>
(
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Option
<
Output
>
Error
>
where
ParseNext
:
Parser
<
Input
Output
Error
>
Error
:
ParserError
<
Input
>
{
trace
(
"
opt
"
move
|
input
:
&
mut
Input
|
{
let
start
=
input
.
checkpoint
(
)
;
match
parser
.
parse_next
(
input
)
{
Ok
(
o
)
=
>
Ok
(
Some
(
o
)
)
Err
(
e
)
if
e
.
is_backtrack
(
)
=
>
{
input
.
reset
(
&
start
)
;
Ok
(
None
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
}
pub
fn
cond
<
Input
Output
Error
ParseNext
>
(
cond
:
bool
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Option
<
Output
>
Error
>
where
Input
:
Stream
ParseNext
:
Parser
<
Input
Output
Error
>
Error
:
ParserError
<
Input
>
{
trace
(
"
cond
"
move
|
input
:
&
mut
Input
|
{
if
cond
{
parser
.
parse_next
(
input
)
.
map
(
Some
)
}
else
{
Ok
(
None
)
}
}
)
}
#
[
doc
(
alias
=
"
look_ahead
"
)
]
#
[
doc
(
alias
=
"
rewind
"
)
]
pub
fn
peek
<
Input
Output
Error
ParseNext
>
(
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
ParseNext
:
Parser
<
Input
Output
Error
>
{
trace
(
"
peek
"
move
|
input
:
&
mut
Input
|
{
let
start
=
input
.
checkpoint
(
)
;
let
res
=
parser
.
parse_next
(
input
)
;
input
.
reset
(
&
start
)
;
res
}
)
}
#
[
doc
(
alias
=
"
end
"
)
]
#
[
doc
(
alias
=
"
eoi
"
)
]
pub
fn
eof
<
Input
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
<
Input
as
Stream
>
:
:
Slice
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
{
trace
(
"
eof
"
move
|
input
:
&
mut
Input
|
{
if
input
.
eof_offset
(
)
=
=
0
{
Ok
(
input
.
next_slice
(
0
)
)
}
else
{
Err
(
ParserError
:
:
from_input
(
input
)
)
}
}
)
.
parse_next
(
input
)
}
pub
fn
not
<
Input
Output
Error
ParseNext
>
(
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
(
)
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
ParseNext
:
Parser
<
Input
Output
Error
>
{
trace
(
"
not
"
move
|
input
:
&
mut
Input
|
{
let
start
=
input
.
checkpoint
(
)
;
let
res
=
parser
.
parse_next
(
input
)
;
input
.
reset
(
&
start
)
;
match
res
{
Ok
(
_
)
=
>
Err
(
ParserError
:
:
from_input
(
input
)
)
Err
(
e
)
if
e
.
is_backtrack
(
)
=
>
Ok
(
(
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
)
}
pub
fn
cut_err
<
Input
Output
Error
ParseNext
>
(
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
+
ModalError
ParseNext
:
Parser
<
Input
Output
Error
>
{
trace
(
"
cut_err
"
move
|
input
:
&
mut
Input
|
{
parser
.
parse_next
(
input
)
.
map_err
(
|
e
|
e
.
cut
(
)
)
}
)
}
pub
fn
backtrack_err
<
Input
Output
Error
ParseNext
>
(
mut
parser
:
ParseNext
)
-
>
impl
Parser
<
Input
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
+
ModalError
ParseNext
:
Parser
<
Input
Output
Error
>
{
trace
(
"
backtrack_err
"
move
|
input
:
&
mut
Input
|
{
parser
.
parse_next
(
input
)
.
map_err
(
|
e
|
e
.
backtrack
(
)
)
}
)
}
#
[
track_caller
]
pub
fn
todo
<
Input
Output
Error
>
(
input
:
&
mut
Input
)
-
>
Result
<
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
{
#
!
[
allow
(
clippy
:
:
todo
)
]
trace
(
"
todo
"
move
|
_input
:
&
mut
Input
|
{
todo
!
(
"
unimplemented
parse
"
)
}
)
.
parse_next
(
input
)
}
pub
fn
iterator
<
Input
Output
Error
ParseNext
>
(
input
:
Input
parser
:
ParseNext
)
-
>
ParserIterator
<
ParseNext
Input
Output
Error
>
where
ParseNext
:
Parser
<
Input
Output
Error
>
Input
:
Stream
Error
:
ParserError
<
Input
>
{
ParserIterator
{
parser
input
state
:
State
:
:
Running
o
:
Default
:
:
default
(
)
}
}
pub
struct
ParserIterator
<
F
I
O
E
>
where
F
:
Parser
<
I
O
E
>
I
:
Stream
{
parser
:
F
input
:
I
state
:
State
<
E
>
o
:
core
:
:
marker
:
:
PhantomData
<
O
>
}
impl
<
F
I
O
E
>
ParserIterator
<
F
I
O
E
>
where
F
:
Parser
<
I
O
E
>
I
:
Stream
E
:
ParserError
<
I
>
{
pub
fn
finish
(
self
)
-
>
Result
<
(
I
(
)
)
E
>
{
match
self
.
state
{
State
:
:
Running
|
State
:
:
Done
=
>
Ok
(
(
self
.
input
(
)
)
)
State
:
:
Cut
(
e
)
=
>
Err
(
e
)
}
}
}
impl
<
F
I
O
E
>
core
:
:
iter
:
:
Iterator
for
&
mut
ParserIterator
<
F
I
O
E
>
where
F
:
Parser
<
I
O
E
>
I
:
Stream
E
:
ParserError
<
I
>
{
type
Item
=
O
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
matches
!
(
self
.
state
State
:
:
Running
)
{
let
start
=
self
.
input
.
checkpoint
(
)
;
match
self
.
parser
.
parse_next
(
&
mut
self
.
input
)
{
Ok
(
o
)
=
>
{
self
.
state
=
State
:
:
Running
;
Some
(
o
)
}
Err
(
e
)
if
e
.
is_backtrack
(
)
=
>
{
self
.
input
.
reset
(
&
start
)
;
self
.
state
=
State
:
:
Done
;
None
}
Err
(
e
)
=
>
{
self
.
state
=
State
:
:
Cut
(
e
)
;
None
}
}
}
else
{
None
}
}
}
enum
State
<
E
>
{
Running
Done
Cut
(
E
)
}
#
[
doc
(
alias
=
"
value
"
)
]
#
[
doc
(
alias
=
"
success
"
)
]
#
[
inline
]
pub
fn
empty
<
Input
Error
>
(
_input
:
&
mut
Input
)
-
>
Result
<
(
)
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
{
Ok
(
(
)
)
}
#
[
doc
(
alias
=
"
unexpected
"
)
]
#
[
inline
]
pub
fn
fail
<
Input
Output
Error
>
(
i
:
&
mut
Input
)
-
>
Result
<
Output
Error
>
where
Input
:
Stream
Error
:
ParserError
<
Input
>
{
trace
(
"
fail
"
|
i
:
&
mut
Input
|
Err
(
ParserError
:
:
from_input
(
i
)
)
)
.
parse_next
(
i
)
}
