#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
lazy_static
/
1
.
4
.
0
"
)
]
#
!
[
no_std
]
#
[
cfg
(
not
(
feature
=
"
spin_no_std
"
)
)
]
#
[
path
=
"
inline_lazy
.
rs
"
]
#
[
doc
(
hidden
)
]
pub
mod
lazy
;
#
[
cfg
(
test
)
]
#
[
macro_use
]
extern
crate
doc_comment
;
#
[
cfg
(
test
)
]
doctest
!
(
"
.
.
/
README
.
md
"
)
;
#
[
cfg
(
feature
=
"
spin_no_std
"
)
]
#
[
path
=
"
core_lazy
.
rs
"
]
#
[
doc
(
hidden
)
]
pub
mod
lazy
;
#
[
doc
(
hidden
)
]
pub
use
core
:
:
ops
:
:
Deref
as
__Deref
;
#
[
macro_export
(
local_inner_macros
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
__lazy_static_internal
{
(
(
#
[
attr
:
meta
]
)
*
(
(
vis
:
tt
)
*
)
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
MAKE
TY
(
#
[
attr
]
)
*
(
(
vis
)
*
)
N
)
;
__lazy_static_internal
!
(
TAIL
N
:
T
=
e
)
;
lazy_static
!
(
(
t
)
*
)
;
}
;
(
TAIL
N
:
ident
:
T
:
ty
=
e
:
expr
)
=
>
{
impl
crate
:
:
__Deref
for
N
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
#
[
inline
(
always
)
]
fn
__static_ref_initialize
(
)
-
>
T
{
e
}
#
[
inline
(
always
)
]
fn
__stability
(
)
-
>
&
'
static
T
{
__lazy_static_create
!
(
LAZY
T
)
;
LAZY
.
get
(
__static_ref_initialize
)
}
__stability
(
)
}
}
impl
crate
:
:
LazyStatic
for
N
{
fn
initialize
(
lazy
:
&
Self
)
{
let
_
=
&
*
*
lazy
;
}
}
}
;
(
MAKE
TY
(
#
[
attr
:
meta
]
)
*
(
(
vis
:
tt
)
*
)
N
:
ident
)
=
>
{
#
[
allow
(
missing_copy_implementations
)
]
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
dead_code
)
]
(
#
[
attr
]
)
*
(
vis
)
*
struct
N
{
__private_field
:
(
)
}
#
[
doc
(
hidden
)
]
(
vis
)
*
static
N
:
N
=
N
{
__private_field
:
(
)
}
;
}
;
(
)
=
>
(
)
}
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
lazy_static
{
(
(
#
[
attr
:
meta
]
)
*
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
/
/
use
(
)
to
explicitly
forward
the
information
about
private
items
__lazy_static_internal
!
(
(
#
[
attr
]
)
*
(
)
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
pub
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
(
#
[
attr
]
)
*
(
pub
)
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
(
vis
:
tt
)
+
)
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
(
#
[
attr
]
)
*
(
pub
(
(
vis
)
+
)
)
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
)
=
>
(
)
}
pub
trait
LazyStatic
{
#
[
doc
(
hidden
)
]
fn
initialize
(
lazy
:
&
Self
)
;
}
pub
fn
initialize
<
T
:
LazyStatic
>
(
lazy
:
&
T
)
{
LazyStatic
:
:
initialize
(
lazy
)
;
}
