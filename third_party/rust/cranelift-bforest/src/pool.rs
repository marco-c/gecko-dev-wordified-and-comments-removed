#
[
cfg
(
test
)
]
use
super
:
:
Comparator
;
use
super
:
:
{
Forest
Node
NodeData
}
;
use
entity
:
:
PrimaryMap
;
#
[
cfg
(
test
)
]
use
std
:
:
fmt
;
use
std
:
:
ops
:
:
{
Index
IndexMut
}
;
pub
(
super
)
struct
NodePool
<
F
:
Forest
>
{
nodes
:
PrimaryMap
<
Node
NodeData
<
F
>
>
freelist
:
Option
<
Node
>
}
impl
<
F
:
Forest
>
NodePool
<
F
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
nodes
:
PrimaryMap
:
:
new
(
)
freelist
:
None
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
nodes
.
clear
(
)
;
self
.
freelist
=
None
;
}
pub
fn
alloc_node
(
&
mut
self
data
:
NodeData
<
F
>
)
-
>
Node
{
debug_assert
!
(
!
data
.
is_free
(
)
"
can
'
t
allocate
free
node
"
)
;
match
self
.
freelist
{
Some
(
node
)
=
>
{
match
self
.
nodes
[
node
]
{
NodeData
:
:
Free
{
next
}
=
>
self
.
freelist
=
next
_
=
>
panic
!
(
"
Invalid
{
}
on
free
list
"
node
)
}
self
.
nodes
[
node
]
=
data
;
node
}
None
=
>
{
self
.
nodes
.
push
(
data
)
}
}
}
pub
fn
free_node
(
&
mut
self
node
:
Node
)
{
debug_assert
!
(
!
self
.
nodes
[
node
]
.
is_free
(
)
"
{
}
is
already
free
"
node
)
;
self
.
nodes
[
node
]
=
NodeData
:
:
Free
{
next
:
self
.
freelist
}
;
self
.
freelist
=
Some
(
node
)
;
}
pub
fn
free_tree
(
&
mut
self
node
:
Node
)
{
if
let
NodeData
:
:
Inner
{
size
tree
.
.
}
=
self
[
node
]
{
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
needless_range_loop
)
)
]
for
i
in
0
.
.
usize
:
:
from
(
size
+
1
)
{
self
.
free_tree
(
tree
[
i
]
)
;
}
}
self
.
free_node
(
node
)
;
}
}
#
[
cfg
(
test
)
]
impl
<
F
:
Forest
>
NodePool
<
F
>
{
pub
fn
verify_tree
<
C
:
Comparator
<
F
:
:
Key
>
>
(
&
self
node
:
Node
comp
:
&
C
)
where
NodeData
<
F
>
:
fmt
:
:
Display
F
:
:
Key
:
fmt
:
:
Display
{
use
entity
:
:
SparseSet
;
use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
vec
:
:
Vec
;
if
let
NodeData
:
:
Inner
{
size
.
.
}
=
self
[
node
]
{
assert
!
(
size
>
0
"
Root
must
have
more
than
one
sub
-
tree
"
)
;
}
let
mut
done
=
SparseSet
:
:
new
(
)
;
let
mut
todo
=
Vec
:
:
new
(
)
;
todo
.
push
(
(
None
node
None
)
)
;
while
let
Some
(
(
lkey
node
rkey
)
)
=
todo
.
pop
(
)
{
assert_eq
!
(
done
.
insert
(
node
)
None
"
Node
appears
more
than
once
in
tree
"
)
;
let
mut
lower
=
lkey
;
match
self
[
node
]
{
NodeData
:
:
Inner
{
size
keys
tree
}
=
>
{
let
size
=
size
as
usize
;
let
capacity
=
tree
.
len
(
)
;
let
keys
=
&
keys
[
0
.
.
size
]
;
assert
!
(
rkey
.
is_none
(
)
|
|
(
size
+
1
)
*
2
>
=
capacity
"
Only
{
}
/
{
}
entries
in
{
}
:
{
}
upper
=
{
}
"
size
+
1
capacity
node
self
[
node
]
rkey
.
unwrap
(
)
)
;
for
i
in
0
.
.
size
+
1
{
let
upper
=
keys
.
get
(
i
)
.
cloned
(
)
.
or
(
rkey
)
;
if
let
(
Some
(
a
)
Some
(
b
)
)
=
(
lower
upper
)
{
assert_eq
!
(
comp
.
cmp
(
a
b
)
Ordering
:
:
Less
"
Key
order
{
}
<
{
}
failed
in
{
}
:
{
}
"
a
b
node
self
[
node
]
)
;
}
todo
.
push
(
(
lower
tree
[
i
]
upper
)
)
;
lower
=
upper
;
}
}
NodeData
:
:
Leaf
{
size
keys
.
.
}
=
>
{
let
size
=
size
as
usize
;
let
capacity
=
keys
.
borrow
(
)
.
len
(
)
;
let
keys
=
&
keys
.
borrow
(
)
[
0
.
.
size
]
;
assert
!
(
size
>
0
"
Leaf
{
}
is
empty
"
node
)
;
assert
!
(
rkey
.
is_none
(
)
|
|
size
*
2
>
=
capacity
"
Only
{
}
/
{
}
entries
in
{
}
:
{
}
upper
=
{
}
"
size
capacity
node
self
[
node
]
rkey
.
unwrap
(
)
)
;
for
i
in
0
.
.
size
+
1
{
let
upper
=
keys
.
get
(
i
)
.
cloned
(
)
.
or
(
rkey
)
;
if
let
(
Some
(
a
)
Some
(
b
)
)
=
(
lower
upper
)
{
let
wanted
=
if
i
=
=
0
{
Ordering
:
:
Equal
}
else
{
Ordering
:
:
Less
}
;
assert_eq
!
(
comp
.
cmp
(
a
b
)
wanted
"
Key
order
for
{
}
-
{
}
failed
in
{
}
:
{
}
"
a
b
node
self
[
node
]
)
;
}
lower
=
upper
;
}
}
NodeData
:
:
Free
{
.
.
}
=
>
panic
!
(
"
Free
{
}
reached
"
node
)
}
}
}
}
impl
<
F
:
Forest
>
Index
<
Node
>
for
NodePool
<
F
>
{
type
Output
=
NodeData
<
F
>
;
fn
index
(
&
self
index
:
Node
)
-
>
&
Self
:
:
Output
{
self
.
nodes
.
index
(
index
)
}
}
impl
<
F
:
Forest
>
IndexMut
<
Node
>
for
NodePool
<
F
>
{
fn
index_mut
(
&
mut
self
index
:
Node
)
-
>
&
mut
Self
:
:
Output
{
self
.
nodes
.
index_mut
(
index
)
}
}
