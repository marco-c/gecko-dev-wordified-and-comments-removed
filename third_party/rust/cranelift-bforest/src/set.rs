use
super
:
:
{
Comparator
Forest
Node
NodeData
NodePool
Path
SetValue
INNER_SIZE
}
;
use
crate
:
:
packed_option
:
:
PackedOption
;
#
[
cfg
(
test
)
]
use
core
:
:
fmt
;
use
core
:
:
marker
:
:
PhantomData
;
#
[
cfg
(
test
)
]
use
std
:
:
string
:
:
String
;
struct
SetTypes
<
K
>
(
PhantomData
<
K
>
)
;
impl
<
K
>
Forest
for
SetTypes
<
K
>
where
K
:
Copy
{
type
Key
=
K
;
type
Value
=
SetValue
;
type
LeafKeys
=
[
K
;
2
*
INNER_SIZE
-
1
]
;
type
LeafValues
=
[
SetValue
;
2
*
INNER_SIZE
-
1
]
;
fn
splat_key
(
key
:
Self
:
:
Key
)
-
>
Self
:
:
LeafKeys
{
[
key
;
2
*
INNER_SIZE
-
1
]
}
fn
splat_value
(
value
:
Self
:
:
Value
)
-
>
Self
:
:
LeafValues
{
[
value
;
2
*
INNER_SIZE
-
1
]
}
}
pub
struct
SetForest
<
K
>
where
K
:
Copy
{
nodes
:
NodePool
<
SetTypes
<
K
>
>
}
impl
<
K
>
SetForest
<
K
>
where
K
:
Copy
{
pub
fn
new
(
)
-
>
Self
{
Self
{
nodes
:
NodePool
:
:
new
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
nodes
.
clear
(
)
;
}
}
#
[
derive
(
Clone
)
]
pub
struct
Set
<
K
>
where
K
:
Copy
{
root
:
PackedOption
<
Node
>
unused
:
PhantomData
<
K
>
}
impl
<
K
>
Set
<
K
>
where
K
:
Copy
{
pub
fn
new
(
)
-
>
Self
{
Self
{
root
:
None
.
into
(
)
unused
:
PhantomData
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
root
.
is_none
(
)
}
pub
fn
contains
<
C
:
Comparator
<
K
>
>
(
&
self
key
:
K
forest
:
&
SetForest
<
K
>
comp
:
&
C
)
-
>
bool
{
self
.
root
.
expand
(
)
.
and_then
(
|
root
|
Path
:
:
default
(
)
.
find
(
key
root
&
forest
.
nodes
comp
)
)
.
is_some
(
)
}
pub
fn
insert
<
C
:
Comparator
<
K
>
>
(
&
mut
self
key
:
K
forest
:
&
mut
SetForest
<
K
>
comp
:
&
C
)
-
>
bool
{
self
.
cursor
(
forest
comp
)
.
insert
(
key
)
}
pub
fn
remove
<
C
:
Comparator
<
K
>
>
(
&
mut
self
key
:
K
forest
:
&
mut
SetForest
<
K
>
comp
:
&
C
)
-
>
bool
{
let
mut
c
=
self
.
cursor
(
forest
comp
)
;
if
c
.
goto
(
key
)
{
c
.
remove
(
)
;
true
}
else
{
false
}
}
pub
fn
clear
(
&
mut
self
forest
:
&
mut
SetForest
<
K
>
)
{
if
let
Some
(
root
)
=
self
.
root
.
take
(
)
{
forest
.
nodes
.
free_tree
(
root
)
;
}
}
pub
fn
retain
<
F
>
(
&
mut
self
forest
:
&
mut
SetForest
<
K
>
mut
predicate
:
F
)
where
F
:
FnMut
(
K
)
-
>
bool
{
let
mut
path
=
Path
:
:
default
(
)
;
if
let
Some
(
root
)
=
self
.
root
.
expand
(
)
{
path
.
first
(
root
&
forest
.
nodes
)
;
}
while
let
Some
(
(
node
entry
)
)
=
path
.
leaf_pos
(
)
{
if
predicate
(
forest
.
nodes
[
node
]
.
unwrap_leaf
(
)
.
0
[
entry
]
)
{
path
.
next
(
&
forest
.
nodes
)
;
}
else
{
self
.
root
=
path
.
remove
(
&
mut
forest
.
nodes
)
.
into
(
)
;
}
}
}
pub
fn
cursor
<
'
a
C
:
Comparator
<
K
>
>
(
&
'
a
mut
self
forest
:
&
'
a
mut
SetForest
<
K
>
comp
:
&
'
a
C
)
-
>
SetCursor
<
'
a
K
C
>
{
SetCursor
:
:
new
(
self
forest
comp
)
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
forest
:
&
'
a
SetForest
<
K
>
)
-
>
SetIter
<
'
a
K
>
{
SetIter
{
root
:
self
.
root
pool
:
&
forest
.
nodes
path
:
Path
:
:
default
(
)
}
}
}
impl
<
K
>
Default
for
Set
<
K
>
where
K
:
Copy
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
pub
struct
SetCursor
<
'
a
K
C
>
where
K
:
'
a
+
Copy
C
:
'
a
+
Comparator
<
K
>
{
root
:
&
'
a
mut
PackedOption
<
Node
>
pool
:
&
'
a
mut
NodePool
<
SetTypes
<
K
>
>
comp
:
&
'
a
C
path
:
Path
<
SetTypes
<
K
>
>
}
impl
<
'
a
K
C
>
SetCursor
<
'
a
K
C
>
where
K
:
Copy
C
:
Comparator
<
K
>
{
fn
new
(
container
:
&
'
a
mut
Set
<
K
>
forest
:
&
'
a
mut
SetForest
<
K
>
comp
:
&
'
a
C
)
-
>
Self
{
Self
{
root
:
&
mut
container
.
root
pool
:
&
mut
forest
.
nodes
comp
path
:
Path
:
:
default
(
)
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
root
.
is_none
(
)
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
should_implement_trait
)
)
]
pub
fn
next
(
&
mut
self
)
-
>
Option
<
K
>
{
self
.
path
.
next
(
self
.
pool
)
.
map
(
|
(
k
_
)
|
k
)
}
pub
fn
prev
(
&
mut
self
)
-
>
Option
<
K
>
{
self
.
root
.
expand
(
)
.
and_then
(
|
root
|
self
.
path
.
prev
(
root
self
.
pool
)
.
map
(
|
(
k
_
)
|
k
)
)
}
pub
fn
elem
(
&
self
)
-
>
Option
<
K
>
{
self
.
path
.
leaf_pos
(
)
.
and_then
(
|
(
node
entry
)
|
self
.
pool
[
node
]
.
unwrap_leaf
(
)
.
0
.
get
(
entry
)
.
cloned
(
)
)
}
pub
fn
goto
(
&
mut
self
elem
:
K
)
-
>
bool
{
match
self
.
root
.
expand
(
)
{
None
=
>
false
Some
(
root
)
=
>
{
if
self
.
path
.
find
(
elem
root
self
.
pool
self
.
comp
)
.
is_some
(
)
{
true
}
else
{
self
.
path
.
normalize
(
self
.
pool
)
;
false
}
}
}
}
pub
fn
goto_first
(
&
mut
self
)
-
>
Option
<
K
>
{
self
.
root
.
map
(
|
root
|
self
.
path
.
first
(
root
self
.
pool
)
.
0
)
}
pub
fn
insert
(
&
mut
self
elem
:
K
)
-
>
bool
{
match
self
.
root
.
expand
(
)
{
None
=
>
{
let
root
=
self
.
pool
.
alloc_node
(
NodeData
:
:
leaf
(
elem
SetValue
(
)
)
)
;
*
self
.
root
=
root
.
into
(
)
;
self
.
path
.
set_root_node
(
root
)
;
true
}
Some
(
root
)
=
>
{
if
self
.
path
.
find
(
elem
root
self
.
pool
self
.
comp
)
.
is_none
(
)
{
*
self
.
root
=
self
.
path
.
insert
(
elem
SetValue
(
)
self
.
pool
)
.
into
(
)
;
true
}
else
{
false
}
}
}
}
pub
fn
remove
(
&
mut
self
)
-
>
Option
<
K
>
{
let
elem
=
self
.
elem
(
)
;
if
elem
.
is_some
(
)
{
*
self
.
root
=
self
.
path
.
remove
(
self
.
pool
)
.
into
(
)
;
}
elem
}
}
#
[
cfg
(
test
)
]
impl
<
'
a
K
C
>
SetCursor
<
'
a
K
C
>
where
K
:
Copy
+
fmt
:
:
Display
C
:
Comparator
<
K
>
{
fn
verify
(
&
self
)
{
self
.
path
.
verify
(
self
.
pool
)
;
self
.
root
.
map
(
|
root
|
self
.
pool
.
verify_tree
(
root
self
.
comp
)
)
;
}
fn
tpath
(
&
self
)
-
>
String
{
use
std
:
:
string
:
:
ToString
;
self
.
path
.
to_string
(
)
}
}
pub
struct
SetIter
<
'
a
K
>
where
K
:
'
a
+
Copy
{
root
:
PackedOption
<
Node
>
pool
:
&
'
a
NodePool
<
SetTypes
<
K
>
>
path
:
Path
<
SetTypes
<
K
>
>
}
impl
<
'
a
K
>
Iterator
for
SetIter
<
'
a
K
>
where
K
:
'
a
+
Copy
{
type
Item
=
K
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
match
self
.
root
.
take
(
)
{
Some
(
root
)
=
>
Some
(
self
.
path
.
first
(
root
self
.
pool
)
.
0
)
None
=
>
self
.
path
.
next
(
self
.
pool
)
.
map
(
|
(
k
_
)
|
k
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
super
:
:
NodeData
;
use
super
:
:
*
;
use
core
:
:
mem
;
use
std
:
:
vec
:
:
Vec
;
#
[
test
]
fn
node_size
(
)
{
type
F
=
SetTypes
<
u32
>
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
NodeData
<
F
>
>
(
)
64
)
;
}
#
[
test
]
fn
empty
(
)
{
let
mut
f
=
SetForest
:
:
<
u32
>
:
:
new
(
)
;
f
.
clear
(
)
;
let
mut
s
=
Set
:
:
<
u32
>
:
:
new
(
)
;
assert
!
(
s
.
is_empty
(
)
)
;
s
.
clear
(
&
mut
f
)
;
assert
!
(
!
s
.
contains
(
7
&
f
&
(
)
)
)
;
assert_eq
!
(
s
.
iter
(
&
f
)
.
next
(
)
None
)
;
s
.
retain
(
&
mut
f
|
_
|
unreachable
!
(
)
)
;
let
mut
c
=
SetCursor
:
:
new
(
&
mut
s
&
mut
f
&
(
)
)
;
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
None
)
;
assert_eq
!
(
c
.
goto_first
(
)
None
)
;
assert_eq
!
(
c
.
tpath
(
)
"
<
empty
path
>
"
)
;
}
#
[
test
]
fn
simple_cursor
(
)
{
let
mut
f
=
SetForest
:
:
<
u32
>
:
:
new
(
)
;
let
mut
s
=
Set
:
:
<
u32
>
:
:
new
(
)
;
let
mut
c
=
SetCursor
:
:
new
(
&
mut
s
&
mut
f
&
(
)
)
;
assert
!
(
c
.
insert
(
50
)
)
;
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
50
)
)
;
assert
!
(
c
.
insert
(
100
)
)
;
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
100
)
)
;
assert
!
(
c
.
insert
(
10
)
)
;
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
10
)
)
;
assert_eq
!
(
c
.
next
(
)
Some
(
50
)
)
;
assert_eq
!
(
c
.
next
(
)
Some
(
100
)
)
;
assert_eq
!
(
c
.
next
(
)
None
)
;
assert_eq
!
(
c
.
next
(
)
None
)
;
assert_eq
!
(
c
.
prev
(
)
Some
(
100
)
)
;
assert_eq
!
(
c
.
prev
(
)
Some
(
50
)
)
;
assert_eq
!
(
c
.
prev
(
)
Some
(
10
)
)
;
assert_eq
!
(
c
.
prev
(
)
None
)
;
assert_eq
!
(
c
.
prev
(
)
None
)
;
assert
!
(
c
.
goto
(
50
)
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
50
)
)
;
assert_eq
!
(
c
.
remove
(
)
Some
(
50
)
)
;
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
100
)
)
;
assert_eq
!
(
c
.
remove
(
)
Some
(
100
)
)
;
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
None
)
;
assert_eq
!
(
c
.
remove
(
)
None
)
;
c
.
verify
(
)
;
}
#
[
test
]
fn
two_level_sparse_tree
(
)
{
let
mut
f
=
SetForest
:
:
<
u32
>
:
:
new
(
)
;
let
mut
s
=
Set
:
:
<
u32
>
:
:
new
(
)
;
let
mut
c
=
SetCursor
:
:
new
(
&
mut
s
&
mut
f
&
(
)
)
;
assert
!
(
c
.
is_empty
(
)
)
;
for
i
in
0
.
.
50
{
assert
!
(
c
.
insert
(
i
)
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
i
)
)
;
}
assert
!
(
!
c
.
is_empty
(
)
)
;
assert_eq
!
(
c
.
goto_first
(
)
Some
(
0
)
)
;
assert_eq
!
(
c
.
tpath
(
)
"
node2
[
0
]
-
-
node0
[
0
]
"
)
;
assert_eq
!
(
c
.
prev
(
)
None
)
;
for
i
in
1
.
.
50
{
assert_eq
!
(
c
.
next
(
)
Some
(
i
)
)
;
}
assert_eq
!
(
c
.
next
(
)
None
)
;
for
i
in
(
0
.
.
50
)
.
rev
(
)
{
assert_eq
!
(
c
.
prev
(
)
Some
(
i
)
)
;
}
assert_eq
!
(
c
.
prev
(
)
None
)
;
assert
!
(
c
.
goto
(
25
)
)
;
for
i
in
25
.
.
50
{
assert_eq
!
(
c
.
remove
(
)
Some
(
i
)
)
;
assert
!
(
!
c
.
is_empty
(
)
)
;
c
.
verify
(
)
;
}
for
i
in
(
0
.
.
25
)
.
rev
(
)
{
assert
!
(
!
c
.
is_empty
(
)
)
;
assert_eq
!
(
c
.
elem
(
)
None
)
;
assert_eq
!
(
c
.
prev
(
)
Some
(
i
)
)
;
assert_eq
!
(
c
.
remove
(
)
Some
(
i
)
)
;
c
.
verify
(
)
;
}
assert_eq
!
(
c
.
elem
(
)
None
)
;
assert
!
(
c
.
is_empty
(
)
)
;
}
#
[
test
]
fn
three_level_sparse_tree
(
)
{
let
mut
f
=
SetForest
:
:
<
u32
>
:
:
new
(
)
;
let
mut
s
=
Set
:
:
<
u32
>
:
:
new
(
)
;
let
mut
c
=
SetCursor
:
:
new
(
&
mut
s
&
mut
f
&
(
)
)
;
assert
!
(
c
.
is_empty
(
)
)
;
for
i
in
0
.
.
150
{
assert
!
(
c
.
insert
(
i
)
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
i
)
)
;
}
assert
!
(
!
c
.
is_empty
(
)
)
;
assert
!
(
c
.
goto
(
0
)
)
;
assert_eq
!
(
c
.
tpath
(
)
"
node11
[
0
]
-
-
node2
[
0
]
-
-
node0
[
0
]
"
)
;
assert_eq
!
(
c
.
prev
(
)
None
)
;
for
i
in
1
.
.
150
{
assert_eq
!
(
c
.
next
(
)
Some
(
i
)
)
;
}
assert_eq
!
(
c
.
next
(
)
None
)
;
for
i
in
(
0
.
.
150
)
.
rev
(
)
{
assert_eq
!
(
c
.
prev
(
)
Some
(
i
)
)
;
}
assert_eq
!
(
c
.
prev
(
)
None
)
;
assert
!
(
c
.
goto
(
125
)
)
;
for
i
in
125
.
.
150
{
assert_eq
!
(
c
.
remove
(
)
Some
(
i
)
)
;
assert
!
(
!
c
.
is_empty
(
)
)
;
c
.
verify
(
)
;
}
for
i
in
(
0
.
.
125
)
.
rev
(
)
{
assert
!
(
!
c
.
is_empty
(
)
)
;
assert_eq
!
(
c
.
elem
(
)
None
)
;
assert_eq
!
(
c
.
prev
(
)
Some
(
i
)
)
;
assert_eq
!
(
c
.
remove
(
)
Some
(
i
)
)
;
c
.
verify
(
)
;
}
assert_eq
!
(
c
.
elem
(
)
None
)
;
assert
!
(
c
.
is_empty
(
)
)
;
}
fn
dense4l
(
f
:
&
mut
SetForest
<
i32
>
)
-
>
Set
<
i32
>
{
f
.
clear
(
)
;
let
mut
s
=
Set
:
:
new
(
)
;
for
n
in
0
.
.
4000
{
assert
!
(
s
.
insert
(
(
n
*
7
)
%
4000
f
&
(
)
)
)
;
}
s
}
#
[
test
]
fn
four_level
(
)
{
let
mut
f
=
SetForest
:
:
<
i32
>
:
:
new
(
)
;
let
mut
s
=
dense4l
(
&
mut
f
)
;
assert_eq
!
(
s
.
iter
(
&
f
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
[
0
.
.
10
]
[
0
1
2
3
4
5
6
7
8
9
]
)
;
let
mut
c
=
s
.
cursor
(
&
mut
f
&
(
)
)
;
c
.
verify
(
)
;
assert
!
(
c
.
goto
(
900
)
)
;
assert_eq
!
(
c
.
tpath
(
)
"
node48
[
1
]
-
-
node47
[
0
]
-
-
node26
[
0
]
-
-
node20
[
4
]
"
)
;
assert
!
(
c
.
goto
(
0
)
)
;
for
i
in
0
.
.
900
{
assert
!
(
!
c
.
is_empty
(
)
)
;
assert_eq
!
(
c
.
remove
(
)
Some
(
i
)
)
;
}
c
.
verify
(
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
900
)
)
;
assert
!
(
c
.
goto
(
3000
)
)
;
for
i
in
(
2000
.
.
3000
)
.
rev
(
)
{
assert_eq
!
(
c
.
prev
(
)
Some
(
i
)
)
;
assert_eq
!
(
c
.
remove
(
)
Some
(
i
)
)
;
assert_eq
!
(
c
.
elem
(
)
Some
(
3000
)
)
;
}
c
.
verify
(
)
;
for
i
in
0
.
.
4000
{
if
c
.
goto
(
(
i
*
7
)
%
4000
)
{
c
.
remove
(
)
;
}
}
assert
!
(
c
.
is_empty
(
)
)
;
}
#
[
test
]
fn
four_level_clear
(
)
{
let
mut
f
=
SetForest
:
:
<
i32
>
:
:
new
(
)
;
let
mut
s
=
dense4l
(
&
mut
f
)
;
s
.
clear
(
&
mut
f
)
;
}
}
