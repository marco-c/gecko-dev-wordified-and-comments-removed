pub
mod
extensions
;
mod
locale
;
pub
use
locale
:
:
*
;
pub
trait
PreferenceKey
:
Sized
{
fn
try_from_key_value
(
_key
:
&
crate
:
:
extensions
:
:
unicode
:
:
Key
_value
:
&
crate
:
:
extensions
:
:
unicode
:
:
Value
)
-
>
Result
<
Option
<
Self
>
crate
:
:
preferences
:
:
extensions
:
:
unicode
:
:
errors
:
:
PreferencesParseError
>
{
Ok
(
None
)
}
fn
unicode_extension_key
(
)
-
>
Option
<
crate
:
:
extensions
:
:
unicode
:
:
Key
>
{
None
}
fn
unicode_extension_value
(
&
self
)
-
>
Option
<
crate
:
:
extensions
:
:
unicode
:
:
Value
>
{
None
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__define_preferences
{
(
(
#
[
doc
:
meta
]
)
*
(
[
derive_attrs
:
ty
]
)
?
name
:
ident
{
(
(
#
[
key_doc
:
meta
]
)
*
key
:
ident
:
pref
:
ty
)
*
}
)
=
>
(
(
#
[
doc
]
)
*
#
[
derive
(
Default
Debug
Clone
PartialEq
Eq
Hash
)
]
(
#
[
derive
(
derive_attrs
)
]
)
?
#
[
non_exhaustive
]
pub
struct
name
{
/
/
/
Locale
Preferences
for
the
Preferences
structure
.
pub
locale_preferences
:
crate
:
:
preferences
:
:
LocalePreferences
(
(
#
[
key_doc
]
)
*
pub
key
:
Option
<
pref
>
)
*
}
impl
From
<
crate
:
:
Locale
>
for
name
{
fn
from
(
loc
:
crate
:
:
Locale
)
-
>
Self
{
name
:
:
from
(
&
loc
)
}
}
impl
From
<
&
crate
:
:
Locale
>
for
name
{
fn
from
(
loc
:
&
crate
:
:
Locale
)
-
>
Self
{
use
crate
:
:
preferences
:
:
PreferenceKey
;
(
let
mut
key
=
None
;
)
*
for
(
k
v
)
in
loc
.
extensions
.
unicode
.
keywords
.
iter
(
)
{
(
if
let
Ok
(
Some
(
r
)
)
=
<
pref
>
:
:
try_from_key_value
(
k
v
)
{
key
=
Some
(
r
)
;
continue
;
}
)
*
}
Self
{
locale_preferences
:
loc
.
into
(
)
(
key
)
*
}
}
}
impl
From
<
crate
:
:
LanguageIdentifier
>
for
name
{
fn
from
(
lid
:
crate
:
:
LanguageIdentifier
)
-
>
Self
{
name
:
:
from
(
&
lid
)
}
}
impl
From
<
&
crate
:
:
LanguageIdentifier
>
for
name
{
fn
from
(
lid
:
&
crate
:
:
LanguageIdentifier
)
-
>
Self
{
Self
{
locale_preferences
:
lid
.
into
(
)
(
key
:
None
)
*
}
}
}
/
/
impl
From
<
name
>
for
crate
:
:
Locale
{
/
/
fn
from
(
other
:
name
)
-
>
Self
{
/
/
use
crate
:
:
preferences
:
:
PreferenceKey
;
/
/
let
mut
result
=
Self
:
:
from
(
other
.
locale_preferences
)
;
/
/
(
/
/
if
let
Some
(
value
)
=
other
.
key
{
/
/
if
let
Some
(
ue
)
=
<
pref
>
:
:
unicode_extension_key
(
)
{
/
/
let
val
=
value
.
unicode_extension_value
(
)
.
unwrap
(
)
;
/
/
result
.
extensions
.
unicode
.
keywords
.
set
(
ue
val
)
;
/
/
}
/
/
}
/
/
)
*
/
/
result
/
/
}
/
/
}
impl
name
{
/
/
/
Extends
the
preferences
with
the
values
from
another
set
of
preferences
.
pub
fn
extend
(
&
mut
self
other
:
name
)
{
self
.
locale_preferences
.
extend
(
other
.
locale_preferences
)
;
(
if
let
Some
(
value
)
=
other
.
key
{
self
.
key
=
Some
(
value
)
;
}
)
*
}
}
)
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__prefs_convert
{
(
name1
:
ident
name2
:
ident
)
=
>
{
impl
From
<
&
name1
>
for
name2
{
fn
from
(
other
:
&
name1
)
-
>
Self
{
let
mut
result
=
Self
:
:
default
(
)
;
result
.
locale_preferences
=
other
.
locale_preferences
;
result
}
}
}
;
(
name1
:
ident
name2
:
ident
{
(
key
:
ident
)
*
}
)
=
>
{
impl
From
<
&
name1
>
for
name2
{
fn
from
(
other
:
&
name1
)
-
>
Self
{
let
mut
result
=
Self
:
:
default
(
)
;
result
.
locale_preferences
=
other
.
locale_preferences
;
(
result
.
key
=
other
.
key
;
)
*
result
}
}
}
;
}
#
[
doc
(
inline
)
]
pub
use
__define_preferences
as
define_preferences
;
#
[
doc
(
inline
)
]
pub
use
__prefs_convert
as
prefs_convert
;
