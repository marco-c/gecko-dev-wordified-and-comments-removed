use
crate
:
:
{
ParseError
ParserResult
}
;
#
[
cfg
(
feature
=
"
duration
"
)
]
use
records
:
:
DurationParseRecord
;
use
records
:
:
{
IxdtfParseRecord
UtcOffsetRecord
}
;
use
self
:
:
records
:
:
Annotation
;
pub
mod
records
;
mod
annotations
;
pub
(
crate
)
mod
datetime
;
#
[
cfg
(
feature
=
"
duration
"
)
]
pub
(
crate
)
mod
duration
;
mod
grammar
;
mod
time
;
pub
(
crate
)
mod
timezone
;
#
[
cfg
(
test
)
]
mod
tests
;
#
[
macro_export
]
macro_rules
!
assert_syntax
{
(
cond
:
expr
err
:
ident
(
)
?
)
=
>
{
if
!
cond
{
return
Err
(
ParseError
:
:
err
)
;
}
}
;
}
#
[
derive
(
Debug
)
]
pub
struct
IxdtfParser
<
'
a
>
{
cursor
:
Cursor
<
'
a
>
}
impl
<
'
a
>
IxdtfParser
<
'
a
>
{
#
[
inline
]
#
[
must_use
]
pub
fn
from_utf8
(
source
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
{
cursor
:
Cursor
:
:
new
(
source
)
}
}
#
[
inline
]
#
[
must_use
]
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
from_str
(
source
:
&
'
a
str
)
-
>
Self
{
Self
:
:
from_utf8
(
source
.
as_bytes
(
)
)
}
pub
fn
parse
(
&
mut
self
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
self
.
parse_with_annotation_handler
(
Some
)
}
pub
fn
parse_with_annotation_handler
(
&
mut
self
handler
:
impl
FnMut
(
Annotation
<
'
a
>
)
-
>
Option
<
Annotation
<
'
a
>
>
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
datetime
:
:
parse_annotated_date_time
(
&
mut
self
.
cursor
handler
)
}
pub
fn
parse_year_month
(
&
mut
self
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
self
.
parse_year_month_with_annotation_handler
(
Some
)
}
pub
fn
parse_year_month_with_annotation_handler
(
&
mut
self
handler
:
impl
FnMut
(
Annotation
<
'
a
>
)
-
>
Option
<
Annotation
<
'
a
>
>
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
datetime
:
:
parse_annotated_year_month
(
&
mut
self
.
cursor
handler
)
}
pub
fn
parse_month_day
(
&
mut
self
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
self
.
parse_month_day_with_annotation_handler
(
Some
)
}
pub
fn
parse_month_day_with_annotation_handler
(
&
mut
self
handler
:
impl
FnMut
(
Annotation
<
'
a
>
)
-
>
Option
<
Annotation
<
'
a
>
>
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
datetime
:
:
parse_annotated_month_day
(
&
mut
self
.
cursor
handler
)
}
pub
fn
parse_time
(
&
mut
self
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
self
.
parse_time_with_annotation_handler
(
Some
)
}
pub
fn
parse_time_with_annotation_handler
(
&
mut
self
handler
:
impl
FnMut
(
Annotation
<
'
a
>
)
-
>
Option
<
Annotation
<
'
a
>
>
)
-
>
ParserResult
<
IxdtfParseRecord
<
'
a
>
>
{
time
:
:
parse_annotated_time_record
(
&
mut
self
.
cursor
handler
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
TimeZoneParser
<
'
a
>
{
cursor
:
Cursor
<
'
a
>
}
impl
<
'
a
>
TimeZoneParser
<
'
a
>
{
#
[
inline
]
#
[
must_use
]
pub
fn
from_utf8
(
source
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
{
cursor
:
Cursor
:
:
new
(
source
)
}
}
#
[
inline
]
#
[
must_use
]
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
from_str
(
source
:
&
'
a
str
)
-
>
Self
{
Self
:
:
from_utf8
(
source
.
as_bytes
(
)
)
}
#
[
inline
]
pub
fn
parse_offset
(
&
mut
self
)
-
>
ParserResult
<
UtcOffsetRecord
>
{
let
result
=
timezone
:
:
parse_utc_offset
(
&
mut
self
.
cursor
)
?
;
self
.
cursor
.
close
(
)
?
;
Ok
(
result
)
}
#
[
inline
]
pub
fn
parse_iana_identifier
(
&
mut
self
)
-
>
ParserResult
<
&
'
a
[
u8
]
>
{
let
result
=
timezone
:
:
parse_tz_iana_name
(
&
mut
self
.
cursor
)
?
;
self
.
cursor
.
close
(
)
?
;
Ok
(
result
)
}
}
#
[
cfg
(
feature
=
"
duration
"
)
]
#
[
derive
(
Debug
)
]
pub
struct
IsoDurationParser
<
'
a
>
{
cursor
:
Cursor
<
'
a
>
}
#
[
cfg
(
feature
=
"
duration
"
)
]
impl
<
'
a
>
IsoDurationParser
<
'
a
>
{
#
[
inline
]
#
[
must_use
]
pub
fn
from_utf8
(
source
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
{
cursor
:
Cursor
:
:
new
(
source
)
}
}
#
[
inline
]
#
[
must_use
]
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
pub
fn
from_str
(
source
:
&
'
a
str
)
-
>
Self
{
Self
:
:
from_utf8
(
source
.
as_bytes
(
)
)
}
pub
fn
parse
(
&
mut
self
)
-
>
ParserResult
<
DurationParseRecord
>
{
duration
:
:
parse_duration
(
&
mut
self
.
cursor
)
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Cursor
<
'
a
>
{
pos
:
usize
source
:
&
'
a
[
u8
]
}
impl
<
'
a
>
Cursor
<
'
a
>
{
#
[
must_use
]
pub
fn
new
(
source
:
&
'
a
[
u8
]
)
-
>
Self
{
Self
{
pos
:
0
source
}
}
fn
slice
(
&
self
start
:
usize
end
:
usize
)
-
>
Option
<
&
'
a
[
u8
]
>
{
self
.
source
.
get
(
start
.
.
end
)
}
const
fn
pos
(
&
self
)
-
>
usize
{
self
.
pos
}
fn
peek
(
&
self
)
-
>
Option
<
u8
>
{
self
.
peek_n
(
1
)
}
fn
current
(
&
self
)
-
>
Option
<
u8
>
{
self
.
peek_n
(
0
)
}
fn
peek_n
(
&
self
n
:
usize
)
-
>
Option
<
u8
>
{
self
.
source
.
get
(
self
.
pos
+
n
)
.
copied
(
)
}
fn
check
<
F
>
(
&
self
f
:
F
)
-
>
Option
<
bool
>
where
F
:
FnOnce
(
u8
)
-
>
bool
{
self
.
current
(
)
.
map
(
f
)
}
fn
check_or
<
F
>
(
&
self
default
:
bool
f
:
F
)
-
>
bool
where
F
:
FnOnce
(
u8
)
-
>
bool
{
self
.
current
(
)
.
map_or
(
default
f
)
}
fn
next
(
&
mut
self
)
-
>
Option
<
u8
>
{
let
result
=
self
.
current
(
)
;
self
.
advance_n
(
1
)
;
result
}
fn
next_digit
(
&
mut
self
)
-
>
ParserResult
<
Option
<
u8
>
>
{
let
ascii_char
=
self
.
next_or
(
ParseError
:
:
AbruptEnd
{
location
:
"
digit
"
}
)
?
;
if
ascii_char
.
is_ascii_digit
(
)
{
Ok
(
Some
(
ascii_char
-
48
)
)
}
else
{
Ok
(
None
)
}
}
fn
next_or
(
&
mut
self
err
:
ParseError
)
-
>
ParserResult
<
u8
>
{
self
.
next
(
)
.
ok_or
(
err
)
}
fn
advance_n
(
&
mut
self
n
:
usize
)
{
self
.
pos
+
=
n
;
}
fn
advance
(
&
mut
self
)
{
self
.
advance_n
(
1
)
}
fn
advance_if
(
&
mut
self
condition
:
bool
)
{
if
condition
{
self
.
advance
(
)
;
}
}
fn
close
(
&
mut
self
)
-
>
ParserResult
<
(
)
>
{
if
self
.
pos
<
self
.
source
.
len
(
)
{
return
Err
(
ParseError
:
:
InvalidEnd
)
;
}
Ok
(
(
)
)
}
}
