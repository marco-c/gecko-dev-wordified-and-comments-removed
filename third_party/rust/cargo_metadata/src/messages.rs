use
super
:
:
{
Diagnostic
PackageId
Target
}
;
use
camino
:
:
Utf8PathBuf
;
#
[
cfg
(
feature
=
"
builder
"
)
]
use
derive_builder
:
:
Builder
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
self
BufRead
Read
}
;
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
ArtifactProfile
{
pub
opt_level
:
String
pub
debuginfo
:
Option
<
u32
>
pub
debug_assertions
:
bool
pub
overflow_checks
:
bool
pub
test
:
bool
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Artifact
{
pub
package_id
:
PackageId
#
[
serde
(
default
)
]
pub
manifest_path
:
Utf8PathBuf
pub
target
:
Target
pub
profile
:
ArtifactProfile
pub
features
:
Vec
<
String
>
pub
filenames
:
Vec
<
Utf8PathBuf
>
pub
executable
:
Option
<
Utf8PathBuf
>
pub
fresh
:
bool
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
CompilerMessage
{
pub
package_id
:
PackageId
pub
target
:
Target
pub
message
:
Diagnostic
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
BuildScript
{
pub
package_id
:
PackageId
pub
linked_libs
:
Vec
<
Utf8PathBuf
>
pub
linked_paths
:
Vec
<
Utf8PathBuf
>
pub
cfgs
:
Vec
<
String
>
pub
env
:
Vec
<
(
String
String
)
>
#
[
serde
(
default
)
]
pub
out_dir
:
Utf8PathBuf
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
BuildFinished
{
pub
success
:
bool
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
non_exhaustive
]
#
[
serde
(
tag
=
"
reason
"
rename_all
=
"
kebab
-
case
"
)
]
pub
enum
Message
{
CompilerArtifact
(
Artifact
)
CompilerMessage
(
CompilerMessage
)
BuildScriptExecuted
(
BuildScript
)
BuildFinished
(
BuildFinished
)
#
[
serde
(
skip
)
]
TextLine
(
String
)
}
impl
Message
{
pub
fn
parse_stream
<
R
:
Read
>
(
input
:
R
)
-
>
MessageIter
<
R
>
{
MessageIter
{
input
}
}
}
impl
fmt
:
:
Display
for
CompilerMessage
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
message
)
}
}
pub
struct
MessageIter
<
R
>
{
input
:
R
}
impl
<
R
:
BufRead
>
Iterator
for
MessageIter
<
R
>
{
type
Item
=
io
:
:
Result
<
Message
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
mut
line
=
String
:
:
new
(
)
;
self
.
input
.
read_line
(
&
mut
line
)
.
map
(
|
n
|
{
if
n
=
=
0
{
None
}
else
{
if
line
.
ends_with
(
'
\
n
'
)
{
line
.
truncate
(
line
.
len
(
)
-
1
)
;
}
let
mut
deserializer
=
serde_json
:
:
Deserializer
:
:
from_str
(
&
line
)
;
deserializer
.
disable_recursion_limit
(
)
;
Some
(
Message
:
:
deserialize
(
&
mut
deserializer
)
.
unwrap_or
(
Message
:
:
TextLine
(
line
)
)
)
}
}
)
.
transpose
(
)
}
}
type
MessageIterator
<
R
>
=
serde_json
:
:
StreamDeserializer
<
'
static
serde_json
:
:
de
:
:
IoRead
<
R
>
Message
>
;
#
[
deprecated
(
note
=
"
Use
Message
:
:
parse_stream
instead
"
)
]
pub
fn
parse_messages
<
R
:
Read
>
(
input
:
R
)
-
>
MessageIterator
<
R
>
{
serde_json
:
:
Deserializer
:
:
from_reader
(
input
)
.
into_iter
:
:
<
Message
>
(
)
}
