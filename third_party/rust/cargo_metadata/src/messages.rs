use
super
:
:
{
Diagnostic
PackageId
Target
}
;
use
camino
:
:
Utf8PathBuf
;
#
[
cfg
(
feature
=
"
builder
"
)
]
use
derive_builder
:
:
Builder
;
use
serde
:
:
{
de
ser
Deserialize
Serialize
}
;
use
std
:
:
fmt
:
:
{
self
Write
}
;
use
std
:
:
io
:
:
{
self
BufRead
Read
}
;
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
ArtifactProfile
{
pub
opt_level
:
String
#
[
serde
(
default
)
]
pub
debuginfo
:
ArtifactDebuginfo
pub
debug_assertions
:
bool
pub
overflow_checks
:
bool
pub
test
:
bool
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
Default
)
]
#
[
non_exhaustive
]
pub
enum
ArtifactDebuginfo
{
#
[
default
]
None
LineDirectivesOnly
LineTablesOnly
Limited
Full
UnknownInt
(
i64
)
UnknownString
(
String
)
}
impl
ser
:
:
Serialize
for
ArtifactDebuginfo
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
ser
:
:
Serializer
{
match
self
{
Self
:
:
None
=
>
0
.
serialize
(
serializer
)
Self
:
:
LineDirectivesOnly
=
>
"
line
-
directives
-
only
"
.
serialize
(
serializer
)
Self
:
:
LineTablesOnly
=
>
"
line
-
tables
-
only
"
.
serialize
(
serializer
)
Self
:
:
Limited
=
>
1
.
serialize
(
serializer
)
Self
:
:
Full
=
>
2
.
serialize
(
serializer
)
Self
:
:
UnknownInt
(
n
)
=
>
n
.
serialize
(
serializer
)
Self
:
:
UnknownString
(
s
)
=
>
s
.
serialize
(
serializer
)
}
}
}
impl
<
'
de
>
de
:
:
Deserialize
<
'
de
>
for
ArtifactDebuginfo
{
fn
deserialize
<
D
>
(
d
:
D
)
-
>
Result
<
ArtifactDebuginfo
D
:
:
Error
>
where
D
:
de
:
:
Deserializer
<
'
de
>
{
struct
Visitor
;
impl
de
:
:
Visitor
<
'
_
>
for
Visitor
{
type
Value
=
ArtifactDebuginfo
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
an
integer
or
string
"
)
}
fn
visit_i64
<
E
>
(
self
value
:
i64
)
-
>
Result
<
ArtifactDebuginfo
E
>
where
E
:
de
:
:
Error
{
let
debuginfo
=
match
value
{
0
=
>
ArtifactDebuginfo
:
:
None
1
=
>
ArtifactDebuginfo
:
:
Limited
2
=
>
ArtifactDebuginfo
:
:
Full
n
=
>
ArtifactDebuginfo
:
:
UnknownInt
(
n
)
}
;
Ok
(
debuginfo
)
}
fn
visit_u64
<
E
>
(
self
value
:
u64
)
-
>
Result
<
ArtifactDebuginfo
E
>
where
E
:
de
:
:
Error
{
self
.
visit_i64
(
value
as
i64
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
ArtifactDebuginfo
E
>
where
E
:
de
:
:
Error
{
let
debuginfo
=
match
value
{
"
none
"
=
>
ArtifactDebuginfo
:
:
None
"
limited
"
=
>
ArtifactDebuginfo
:
:
Limited
"
full
"
=
>
ArtifactDebuginfo
:
:
Full
"
line
-
directives
-
only
"
=
>
ArtifactDebuginfo
:
:
LineDirectivesOnly
"
line
-
tables
-
only
"
=
>
ArtifactDebuginfo
:
:
LineTablesOnly
s
=
>
ArtifactDebuginfo
:
:
UnknownString
(
s
.
to_string
(
)
)
}
;
Ok
(
debuginfo
)
}
fn
visit_unit
<
E
>
(
self
)
-
>
Result
<
ArtifactDebuginfo
E
>
where
E
:
de
:
:
Error
{
Ok
(
ArtifactDebuginfo
:
:
None
)
}
}
d
.
deserialize_any
(
Visitor
)
}
}
impl
fmt
:
:
Display
for
ArtifactDebuginfo
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
ArtifactDebuginfo
:
:
None
=
>
f
.
write_char
(
'
0
'
)
ArtifactDebuginfo
:
:
Limited
=
>
f
.
write_char
(
'
1
'
)
ArtifactDebuginfo
:
:
Full
=
>
f
.
write_char
(
'
2
'
)
ArtifactDebuginfo
:
:
LineDirectivesOnly
=
>
f
.
write_str
(
"
line
-
directives
-
only
"
)
ArtifactDebuginfo
:
:
LineTablesOnly
=
>
f
.
write_str
(
"
line
-
tables
-
only
"
)
ArtifactDebuginfo
:
:
UnknownInt
(
n
)
=
>
write
!
(
f
"
{
}
"
n
)
ArtifactDebuginfo
:
:
UnknownString
(
s
)
=
>
f
.
write_str
(
s
)
}
}
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Artifact
{
pub
package_id
:
PackageId
#
[
serde
(
default
)
]
pub
manifest_path
:
Utf8PathBuf
pub
target
:
Target
pub
profile
:
ArtifactProfile
pub
features
:
Vec
<
String
>
pub
filenames
:
Vec
<
Utf8PathBuf
>
pub
executable
:
Option
<
Utf8PathBuf
>
pub
fresh
:
bool
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
CompilerMessage
{
pub
package_id
:
PackageId
pub
target
:
Target
pub
message
:
Diagnostic
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
BuildScript
{
pub
package_id
:
PackageId
pub
linked_libs
:
Vec
<
Utf8PathBuf
>
pub
linked_paths
:
Vec
<
Utf8PathBuf
>
pub
cfgs
:
Vec
<
String
>
pub
env
:
Vec
<
(
String
String
)
>
#
[
serde
(
default
)
]
pub
out_dir
:
Utf8PathBuf
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
BuildFinished
{
pub
success
:
bool
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
Hash
)
]
#
[
non_exhaustive
]
#
[
serde
(
tag
=
"
reason
"
rename_all
=
"
kebab
-
case
"
)
]
pub
enum
Message
{
CompilerArtifact
(
Artifact
)
CompilerMessage
(
CompilerMessage
)
BuildScriptExecuted
(
BuildScript
)
BuildFinished
(
BuildFinished
)
#
[
serde
(
skip
)
]
TextLine
(
String
)
}
impl
Message
{
pub
fn
parse_stream
<
R
:
Read
>
(
input
:
R
)
-
>
MessageIter
<
R
>
{
MessageIter
{
input
}
}
}
impl
fmt
:
:
Display
for
CompilerMessage
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
message
)
}
}
pub
struct
MessageIter
<
R
>
{
input
:
R
}
impl
<
R
:
BufRead
>
Iterator
for
MessageIter
<
R
>
{
type
Item
=
io
:
:
Result
<
Message
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
mut
line
=
String
:
:
new
(
)
;
self
.
input
.
read_line
(
&
mut
line
)
.
map
(
|
n
|
{
if
n
=
=
0
{
None
}
else
{
if
line
.
ends_with
(
'
\
n
'
)
{
line
.
truncate
(
line
.
len
(
)
-
1
)
;
}
let
mut
deserializer
=
serde_json
:
:
Deserializer
:
:
from_str
(
&
line
)
;
deserializer
.
disable_recursion_limit
(
)
;
Some
(
Message
:
:
deserialize
(
&
mut
deserializer
)
.
unwrap_or
(
Message
:
:
TextLine
(
line
)
)
)
}
}
)
.
transpose
(
)
}
}
type
MessageIterator
<
R
>
=
serde_json
:
:
StreamDeserializer
<
'
static
serde_json
:
:
de
:
:
IoRead
<
R
>
Message
>
;
#
[
deprecated
(
note
=
"
Use
Message
:
:
parse_stream
instead
"
)
]
pub
fn
parse_messages
<
R
:
Read
>
(
input
:
R
)
-
>
MessageIterator
<
R
>
{
serde_json
:
:
Deserializer
:
:
from_reader
(
input
)
.
into_iter
:
:
<
Message
>
(
)
}
