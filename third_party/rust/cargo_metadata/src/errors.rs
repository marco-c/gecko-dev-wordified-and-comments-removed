use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
str
:
:
Utf8Error
;
use
std
:
:
string
:
:
FromUtf8Error
;
pub
type
Result
<
T
>
=
:
:
std
:
:
result
:
:
Result
<
T
Error
>
;
#
[
derive
(
Debug
)
]
pub
enum
Error
{
CargoMetadata
{
stderr
:
String
}
Io
(
io
:
:
Error
)
Utf8
(
Utf8Error
)
ErrUtf8
(
FromUtf8Error
)
Json
(
:
:
serde_json
:
:
Error
)
NoJson
}
impl
From
<
io
:
:
Error
>
for
Error
{
fn
from
(
v
:
io
:
:
Error
)
-
>
Self
{
Error
:
:
Io
(
v
)
}
}
impl
From
<
Utf8Error
>
for
Error
{
fn
from
(
v
:
Utf8Error
)
-
>
Self
{
Error
:
:
Utf8
(
v
)
}
}
impl
From
<
FromUtf8Error
>
for
Error
{
fn
from
(
v
:
FromUtf8Error
)
-
>
Self
{
Error
:
:
ErrUtf8
(
v
)
}
}
impl
From
<
:
:
serde_json
:
:
Error
>
for
Error
{
fn
from
(
v
:
:
:
serde_json
:
:
Error
)
-
>
Self
{
Error
:
:
Json
(
v
)
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Error
:
:
CargoMetadata
{
stderr
}
=
>
{
write
!
(
f
"
cargo
metadata
exited
with
an
error
:
{
}
"
stderr
.
trim_end
(
)
)
}
Error
:
:
Io
(
err
)
=
>
write
!
(
f
"
failed
to
start
cargo
metadata
:
{
}
"
err
)
Error
:
:
Utf8
(
err
)
=
>
write
!
(
f
"
cannot
convert
the
stdout
of
cargo
metadata
:
{
}
"
err
)
Error
:
:
ErrUtf8
(
err
)
=
>
{
write
!
(
f
"
cannot
convert
the
stderr
of
cargo
metadata
:
{
}
"
err
)
}
Error
:
:
Json
(
err
)
=
>
write
!
(
f
"
failed
to
interpret
cargo
metadata
'
s
json
:
{
}
"
err
)
Error
:
:
NoJson
=
>
write
!
(
f
"
could
not
find
any
json
in
the
output
of
cargo
metadata
"
)
}
}
}
impl
:
:
std
:
:
error
:
:
Error
for
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
std
:
:
error
:
:
Error
+
'
static
)
>
{
match
self
{
Error
:
:
CargoMetadata
{
.
.
}
=
>
None
Error
:
:
Io
(
err
)
=
>
Some
(
err
)
Error
:
:
Utf8
(
err
)
=
>
Some
(
err
)
Error
:
:
ErrUtf8
(
err
)
=
>
Some
(
err
)
Error
:
:
Json
(
err
)
=
>
Some
(
err
)
Error
:
:
NoJson
=
>
None
}
}
}
