#
!
[
deny
(
missing_docs
)
]
use
camino
:
:
Utf8PathBuf
;
#
[
cfg
(
feature
=
"
builder
"
)
]
use
derive_builder
:
:
Builder
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
env
;
use
std
:
:
fmt
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
process
:
:
Command
;
use
std
:
:
str
:
:
from_utf8
;
pub
use
camino
;
pub
use
semver
:
:
{
Version
VersionReq
}
;
pub
use
dependency
:
:
{
Dependency
DependencyKind
}
;
use
diagnostic
:
:
Diagnostic
;
pub
use
errors
:
:
{
Error
Result
}
;
#
[
allow
(
deprecated
)
]
pub
use
messages
:
:
parse_messages
;
pub
use
messages
:
:
{
Artifact
ArtifactProfile
BuildFinished
BuildScript
CompilerMessage
Message
MessageIter
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
mod
dependency
;
pub
mod
diagnostic
;
mod
errors
;
mod
messages
;
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
serde
(
transparent
)
]
pub
struct
PackageId
{
pub
repr
:
String
}
impl
std
:
:
fmt
:
:
Display
for
PackageId
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
repr
f
)
}
}
fn
is_null
(
value
:
&
serde_json
:
:
Value
)
-
>
bool
{
match
value
{
serde_json
:
:
Value
:
:
Null
=
>
true
_
=
>
false
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Metadata
{
pub
packages
:
Vec
<
Package
>
pub
workspace_members
:
Vec
<
PackageId
>
pub
resolve
:
Option
<
Resolve
>
pub
workspace_root
:
Utf8PathBuf
pub
target_directory
:
Utf8PathBuf
#
[
serde
(
rename
=
"
metadata
"
default
skip_serializing_if
=
"
is_null
"
)
]
pub
workspace_metadata
:
serde_json
:
:
Value
version
:
usize
}
impl
Metadata
{
pub
fn
root_package
(
&
self
)
-
>
Option
<
&
Package
>
{
let
root
=
self
.
resolve
.
as_ref
(
)
?
.
root
.
as_ref
(
)
?
;
self
.
packages
.
iter
(
)
.
find
(
|
pkg
|
&
pkg
.
id
=
=
root
)
}
}
impl
<
'
a
>
std
:
:
ops
:
:
Index
<
&
'
a
PackageId
>
for
Metadata
{
type
Output
=
Package
;
fn
index
(
&
self
idx
:
&
'
a
PackageId
)
-
>
&
Package
{
self
.
packages
.
iter
(
)
.
find
(
|
p
|
p
.
id
=
=
*
idx
)
.
unwrap_or_else
(
|
|
panic
!
(
"
no
package
with
this
id
:
{
:
?
}
"
idx
)
)
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Resolve
{
pub
nodes
:
Vec
<
Node
>
pub
root
:
Option
<
PackageId
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Node
{
pub
id
:
PackageId
#
[
serde
(
default
)
]
pub
deps
:
Vec
<
NodeDep
>
pub
dependencies
:
Vec
<
PackageId
>
#
[
serde
(
default
)
]
pub
features
:
Vec
<
String
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
NodeDep
{
pub
name
:
String
pub
pkg
:
PackageId
#
[
serde
(
default
)
]
pub
dep_kinds
:
Vec
<
DepKindInfo
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
DepKindInfo
{
#
[
serde
(
deserialize_with
=
"
dependency
:
:
parse_dependency_kind
"
)
]
pub
kind
:
DependencyKind
pub
target
:
Option
<
dependency
:
:
Platform
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Package
{
pub
name
:
String
pub
version
:
Version
#
[
serde
(
default
)
]
pub
authors
:
Vec
<
String
>
pub
id
:
PackageId
pub
source
:
Option
<
Source
>
pub
description
:
Option
<
String
>
pub
dependencies
:
Vec
<
Dependency
>
pub
license
:
Option
<
String
>
pub
license_file
:
Option
<
Utf8PathBuf
>
pub
targets
:
Vec
<
Target
>
pub
features
:
HashMap
<
String
Vec
<
String
>
>
pub
manifest_path
:
Utf8PathBuf
#
[
serde
(
default
)
]
pub
categories
:
Vec
<
String
>
#
[
serde
(
default
)
]
pub
keywords
:
Vec
<
String
>
pub
readme
:
Option
<
Utf8PathBuf
>
pub
repository
:
Option
<
String
>
pub
homepage
:
Option
<
String
>
pub
documentation
:
Option
<
String
>
#
[
serde
(
default
=
"
edition_default
"
)
]
pub
edition
:
String
#
[
serde
(
default
skip_serializing_if
=
"
is_null
"
)
]
pub
metadata
:
serde_json
:
:
Value
pub
links
:
Option
<
String
>
pub
publish
:
Option
<
Vec
<
String
>
>
pub
default_run
:
Option
<
String
>
pub
rust_version
:
Option
<
VersionReq
>
}
impl
Package
{
pub
fn
license_file
(
&
self
)
-
>
Option
<
Utf8PathBuf
>
{
self
.
license_file
.
as_ref
(
)
.
map
(
|
file
|
{
self
.
manifest_path
.
parent
(
)
.
unwrap_or
(
&
self
.
manifest_path
)
.
join
(
file
)
}
)
}
pub
fn
readme
(
&
self
)
-
>
Option
<
Utf8PathBuf
>
{
self
.
readme
.
as_ref
(
)
.
map
(
|
file
|
self
.
manifest_path
.
join
(
file
)
)
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
)
]
#
[
serde
(
transparent
)
]
pub
struct
Source
{
pub
repr
:
String
}
impl
Source
{
pub
fn
is_crates_io
(
&
self
)
-
>
bool
{
self
.
repr
=
=
"
registry
+
https
:
/
/
github
.
com
/
rust
-
lang
/
crates
.
io
-
index
"
}
}
impl
std
:
:
fmt
:
:
Display
for
Source
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
repr
f
)
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
#
[
non_exhaustive
]
pub
struct
Target
{
pub
name
:
String
pub
kind
:
Vec
<
String
>
#
[
serde
(
default
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
)
)
]
pub
crate_types
:
Vec
<
String
>
#
[
serde
(
default
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
)
)
]
#
[
serde
(
rename
=
"
required
-
features
"
)
]
pub
required_features
:
Vec
<
String
>
pub
src_path
:
Utf8PathBuf
#
[
serde
(
default
=
"
edition_default
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
edition_default
(
)
"
)
)
]
pub
edition
:
String
#
[
serde
(
default
=
"
default_true
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
true
"
)
)
]
pub
doctest
:
bool
#
[
serde
(
default
=
"
default_true
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
true
"
)
)
]
pub
test
:
bool
#
[
serde
(
default
=
"
default_true
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
true
"
)
)
]
pub
doc
:
bool
}
fn
default_true
(
)
-
>
bool
{
true
}
fn
edition_default
(
)
-
>
String
{
"
2015
"
.
to_string
(
)
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
CargoOpt
{
AllFeatures
NoDefaultFeatures
SomeFeatures
(
Vec
<
String
>
)
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
MetadataCommand
{
cargo_path
:
Option
<
PathBuf
>
manifest_path
:
Option
<
PathBuf
>
current_dir
:
Option
<
PathBuf
>
no_deps
:
bool
features
:
Vec
<
String
>
all_features
:
bool
no_default_features
:
bool
other_options
:
Vec
<
String
>
}
impl
MetadataCommand
{
pub
fn
new
(
)
-
>
MetadataCommand
{
MetadataCommand
:
:
default
(
)
}
pub
fn
cargo_path
(
&
mut
self
path
:
impl
Into
<
PathBuf
>
)
-
>
&
mut
MetadataCommand
{
self
.
cargo_path
=
Some
(
path
.
into
(
)
)
;
self
}
pub
fn
manifest_path
(
&
mut
self
path
:
impl
Into
<
PathBuf
>
)
-
>
&
mut
MetadataCommand
{
self
.
manifest_path
=
Some
(
path
.
into
(
)
)
;
self
}
pub
fn
current_dir
(
&
mut
self
path
:
impl
Into
<
PathBuf
>
)
-
>
&
mut
MetadataCommand
{
self
.
current_dir
=
Some
(
path
.
into
(
)
)
;
self
}
pub
fn
no_deps
(
&
mut
self
)
-
>
&
mut
MetadataCommand
{
self
.
no_deps
=
true
;
self
}
pub
fn
features
(
&
mut
self
features
:
CargoOpt
)
-
>
&
mut
MetadataCommand
{
match
features
{
CargoOpt
:
:
SomeFeatures
(
features
)
=
>
self
.
features
.
extend
(
features
)
CargoOpt
:
:
NoDefaultFeatures
=
>
{
assert
!
(
!
self
.
no_default_features
"
Do
not
supply
CargoOpt
:
:
NoDefaultFeatures
more
than
once
!
"
)
;
self
.
no_default_features
=
true
;
}
CargoOpt
:
:
AllFeatures
=
>
{
assert
!
(
!
self
.
all_features
"
Do
not
supply
CargoOpt
:
:
AllFeatures
more
than
once
!
"
)
;
self
.
all_features
=
true
;
}
}
self
}
pub
fn
other_options
(
&
mut
self
options
:
impl
Into
<
Vec
<
String
>
>
)
-
>
&
mut
MetadataCommand
{
self
.
other_options
=
options
.
into
(
)
;
self
}
pub
fn
cargo_command
(
&
self
)
-
>
Command
{
let
cargo
=
self
.
cargo_path
.
clone
(
)
.
or_else
(
|
|
env
:
:
var
(
"
CARGO
"
)
.
map
(
PathBuf
:
:
from
)
.
ok
(
)
)
.
unwrap_or_else
(
|
|
PathBuf
:
:
from
(
"
cargo
"
)
)
;
let
mut
cmd
=
Command
:
:
new
(
cargo
)
;
cmd
.
args
(
&
[
"
metadata
"
"
-
-
format
-
version
"
"
1
"
]
)
;
if
self
.
no_deps
{
cmd
.
arg
(
"
-
-
no
-
deps
"
)
;
}
if
let
Some
(
path
)
=
self
.
current_dir
.
as_ref
(
)
{
cmd
.
current_dir
(
path
)
;
}
if
!
self
.
features
.
is_empty
(
)
{
cmd
.
arg
(
"
-
-
features
"
)
.
arg
(
self
.
features
.
join
(
"
"
)
)
;
}
if
self
.
all_features
{
cmd
.
arg
(
"
-
-
all
-
features
"
)
;
}
if
self
.
no_default_features
{
cmd
.
arg
(
"
-
-
no
-
default
-
features
"
)
;
}
if
let
Some
(
manifest_path
)
=
&
self
.
manifest_path
{
cmd
.
arg
(
"
-
-
manifest
-
path
"
)
.
arg
(
manifest_path
.
as_os_str
(
)
)
;
}
cmd
.
args
(
&
self
.
other_options
)
;
cmd
}
pub
fn
parse
<
T
:
AsRef
<
str
>
>
(
data
:
T
)
-
>
Result
<
Metadata
>
{
let
meta
=
serde_json
:
:
from_str
(
data
.
as_ref
(
)
)
?
;
Ok
(
meta
)
}
pub
fn
exec
(
&
self
)
-
>
Result
<
Metadata
>
{
let
output
=
self
.
cargo_command
(
)
.
output
(
)
?
;
if
!
output
.
status
.
success
(
)
{
return
Err
(
Error
:
:
CargoMetadata
{
stderr
:
String
:
:
from_utf8
(
output
.
stderr
)
?
}
)
;
}
let
stdout
=
from_utf8
(
&
output
.
stdout
)
?
.
lines
(
)
.
find
(
|
line
|
line
.
starts_with
(
'
{
'
)
)
.
ok_or_else
(
|
|
Error
:
:
NoJson
)
?
;
Self
:
:
parse
(
stdout
)
}
}
