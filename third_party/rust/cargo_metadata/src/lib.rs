#
!
[
deny
(
missing_docs
)
]
use
camino
:
:
Utf8PathBuf
;
#
[
cfg
(
feature
=
"
builder
"
)
]
use
derive_builder
:
:
Builder
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
env
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fmt
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
process
:
:
{
Command
Stdio
}
;
use
std
:
:
str
:
:
from_utf8
;
pub
use
camino
;
pub
use
semver
;
use
semver
:
:
{
Version
VersionReq
}
;
pub
use
dependency
:
:
{
Dependency
DependencyKind
}
;
use
diagnostic
:
:
Diagnostic
;
pub
use
errors
:
:
{
Error
Result
}
;
#
[
allow
(
deprecated
)
]
pub
use
messages
:
:
parse_messages
;
pub
use
messages
:
:
{
Artifact
ArtifactProfile
BuildFinished
BuildScript
CompilerMessage
Message
MessageIter
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
mod
dependency
;
pub
mod
diagnostic
;
mod
errors
;
mod
messages
;
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
serde
(
transparent
)
]
pub
struct
PackageId
{
pub
repr
:
String
}
impl
std
:
:
fmt
:
:
Display
for
PackageId
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
repr
f
)
}
}
fn
is_null
(
value
:
&
serde_json
:
:
Value
)
-
>
bool
{
matches
!
(
value
serde_json
:
:
Value
:
:
Null
)
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Metadata
{
pub
packages
:
Vec
<
Package
>
pub
workspace_members
:
Vec
<
PackageId
>
pub
resolve
:
Option
<
Resolve
>
pub
workspace_root
:
Utf8PathBuf
pub
target_directory
:
Utf8PathBuf
#
[
serde
(
rename
=
"
metadata
"
default
skip_serializing_if
=
"
is_null
"
)
]
pub
workspace_metadata
:
serde_json
:
:
Value
version
:
usize
}
impl
Metadata
{
pub
fn
root_package
(
&
self
)
-
>
Option
<
&
Package
>
{
match
&
self
.
resolve
{
Some
(
resolve
)
=
>
{
let
root
=
resolve
.
root
.
as_ref
(
)
?
;
self
.
packages
.
iter
(
)
.
find
(
|
pkg
|
&
pkg
.
id
=
=
root
)
}
None
=
>
{
let
root_manifest_path
=
self
.
workspace_root
.
join
(
"
Cargo
.
toml
"
)
;
self
.
packages
.
iter
(
)
.
find
(
|
pkg
|
pkg
.
manifest_path
=
=
root_manifest_path
)
}
}
}
pub
fn
workspace_packages
(
&
self
)
-
>
Vec
<
&
Package
>
{
self
.
packages
.
iter
(
)
.
filter
(
|
&
p
|
self
.
workspace_members
.
contains
(
&
p
.
id
)
)
.
collect
(
)
}
}
impl
<
'
a
>
std
:
:
ops
:
:
Index
<
&
'
a
PackageId
>
for
Metadata
{
type
Output
=
Package
;
fn
index
(
&
self
idx
:
&
'
a
PackageId
)
-
>
&
Package
{
self
.
packages
.
iter
(
)
.
find
(
|
p
|
p
.
id
=
=
*
idx
)
.
unwrap_or_else
(
|
|
panic
!
(
"
no
package
with
this
id
:
{
:
?
}
"
idx
)
)
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Resolve
{
pub
nodes
:
Vec
<
Node
>
pub
root
:
Option
<
PackageId
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Node
{
pub
id
:
PackageId
#
[
serde
(
default
)
]
pub
deps
:
Vec
<
NodeDep
>
pub
dependencies
:
Vec
<
PackageId
>
#
[
serde
(
default
)
]
pub
features
:
Vec
<
String
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
NodeDep
{
pub
name
:
String
pub
pkg
:
PackageId
#
[
serde
(
default
)
]
pub
dep_kinds
:
Vec
<
DepKindInfo
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
DepKindInfo
{
#
[
serde
(
deserialize_with
=
"
dependency
:
:
parse_dependency_kind
"
)
]
pub
kind
:
DependencyKind
pub
target
:
Option
<
dependency
:
:
Platform
>
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
non_exhaustive
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
pub
struct
Package
{
pub
name
:
String
pub
version
:
Version
#
[
serde
(
default
)
]
pub
authors
:
Vec
<
String
>
pub
id
:
PackageId
pub
source
:
Option
<
Source
>
pub
description
:
Option
<
String
>
pub
dependencies
:
Vec
<
Dependency
>
pub
license
:
Option
<
String
>
pub
license_file
:
Option
<
Utf8PathBuf
>
pub
targets
:
Vec
<
Target
>
pub
features
:
HashMap
<
String
Vec
<
String
>
>
pub
manifest_path
:
Utf8PathBuf
#
[
serde
(
default
)
]
pub
categories
:
Vec
<
String
>
#
[
serde
(
default
)
]
pub
keywords
:
Vec
<
String
>
pub
readme
:
Option
<
Utf8PathBuf
>
pub
repository
:
Option
<
String
>
pub
homepage
:
Option
<
String
>
pub
documentation
:
Option
<
String
>
#
[
serde
(
default
)
]
pub
edition
:
Edition
#
[
serde
(
default
skip_serializing_if
=
"
is_null
"
)
]
pub
metadata
:
serde_json
:
:
Value
pub
links
:
Option
<
String
>
pub
publish
:
Option
<
Vec
<
String
>
>
pub
default_run
:
Option
<
String
>
pub
rust_version
:
Option
<
VersionReq
>
}
impl
Package
{
pub
fn
license_file
(
&
self
)
-
>
Option
<
Utf8PathBuf
>
{
self
.
license_file
.
as_ref
(
)
.
map
(
|
file
|
{
self
.
manifest_path
.
parent
(
)
.
unwrap_or
(
&
self
.
manifest_path
)
.
join
(
file
)
}
)
}
pub
fn
readme
(
&
self
)
-
>
Option
<
Utf8PathBuf
>
{
self
.
readme
.
as_ref
(
)
.
map
(
|
file
|
{
self
.
manifest_path
.
parent
(
)
.
unwrap_or
(
&
self
.
manifest_path
)
.
join
(
file
)
}
)
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
)
]
#
[
serde
(
transparent
)
]
pub
struct
Source
{
pub
repr
:
String
}
impl
Source
{
pub
fn
is_crates_io
(
&
self
)
-
>
bool
{
self
.
repr
=
=
"
registry
+
https
:
/
/
github
.
com
/
rust
-
lang
/
crates
.
io
-
index
"
}
}
impl
std
:
:
fmt
:
:
Display
for
Source
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
repr
f
)
}
}
#
[
derive
(
Clone
Serialize
Deserialize
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
derive
(
Builder
)
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
pattern
=
"
owned
"
setter
(
into
)
)
)
]
#
[
non_exhaustive
]
pub
struct
Target
{
pub
name
:
String
pub
kind
:
Vec
<
String
>
#
[
serde
(
default
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
)
)
]
pub
crate_types
:
Vec
<
String
>
#
[
serde
(
default
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
)
)
]
#
[
serde
(
rename
=
"
required
-
features
"
)
]
pub
required_features
:
Vec
<
String
>
pub
src_path
:
Utf8PathBuf
#
[
serde
(
default
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
)
)
]
pub
edition
:
Edition
#
[
serde
(
default
=
"
default_true
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
true
"
)
)
]
pub
doctest
:
bool
#
[
serde
(
default
=
"
default_true
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
true
"
)
)
]
pub
test
:
bool
#
[
serde
(
default
=
"
default_true
"
)
]
#
[
cfg_attr
(
feature
=
"
builder
"
builder
(
default
=
"
true
"
)
)
]
pub
doc
:
bool
}
impl
Target
{
fn
is_kind
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
kind
.
iter
(
)
.
any
(
|
kind
|
kind
=
=
name
)
}
pub
fn
is_lib
(
&
self
)
-
>
bool
{
self
.
is_kind
(
"
lib
"
)
}
pub
fn
is_bin
(
&
self
)
-
>
bool
{
self
.
is_kind
(
"
bin
"
)
}
pub
fn
is_example
(
&
self
)
-
>
bool
{
self
.
is_kind
(
"
example
"
)
}
pub
fn
is_test
(
&
self
)
-
>
bool
{
self
.
is_kind
(
"
test
"
)
}
pub
fn
is_bench
(
&
self
)
-
>
bool
{
self
.
is_kind
(
"
bench
"
)
}
pub
fn
is_custom_build
(
&
self
)
-
>
bool
{
self
.
is_kind
(
"
custom
-
build
"
)
}
}
#
[
derive
(
Debug
Clone
Serialize
Deserialize
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
non_exhaustive
]
pub
enum
Edition
{
#
[
serde
(
rename
=
"
2015
"
)
]
E2015
#
[
serde
(
rename
=
"
2018
"
)
]
E2018
#
[
serde
(
rename
=
"
2021
"
)
]
E2021
#
[
doc
(
hidden
)
]
#
[
serde
(
rename
=
"
2024
"
)
]
_E2024
#
[
doc
(
hidden
)
]
#
[
serde
(
rename
=
"
2027
"
)
]
_E2027
#
[
doc
(
hidden
)
]
#
[
serde
(
rename
=
"
2030
"
)
]
_E2030
}
impl
Edition
{
pub
fn
as_str
(
&
self
)
-
>
&
'
static
str
{
use
Edition
:
:
*
;
match
self
{
E2015
=
>
"
2015
"
E2018
=
>
"
2018
"
E2021
=
>
"
2021
"
_E2024
=
>
"
2024
"
_E2027
=
>
"
2027
"
_E2030
=
>
"
2030
"
}
}
}
impl
fmt
:
:
Display
for
Edition
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
self
.
as_str
(
)
)
}
}
impl
Default
for
Edition
{
fn
default
(
)
-
>
Self
{
Self
:
:
E2015
}
}
fn
default_true
(
)
-
>
bool
{
true
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
CargoOpt
{
AllFeatures
NoDefaultFeatures
SomeFeatures
(
Vec
<
String
>
)
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
MetadataCommand
{
cargo_path
:
Option
<
PathBuf
>
manifest_path
:
Option
<
PathBuf
>
current_dir
:
Option
<
PathBuf
>
no_deps
:
bool
features
:
Vec
<
String
>
all_features
:
bool
no_default_features
:
bool
other_options
:
Vec
<
String
>
env
:
HashMap
<
OsString
OsString
>
verbose
:
bool
}
impl
MetadataCommand
{
pub
fn
new
(
)
-
>
MetadataCommand
{
MetadataCommand
:
:
default
(
)
}
pub
fn
cargo_path
(
&
mut
self
path
:
impl
Into
<
PathBuf
>
)
-
>
&
mut
MetadataCommand
{
self
.
cargo_path
=
Some
(
path
.
into
(
)
)
;
self
}
pub
fn
manifest_path
(
&
mut
self
path
:
impl
Into
<
PathBuf
>
)
-
>
&
mut
MetadataCommand
{
self
.
manifest_path
=
Some
(
path
.
into
(
)
)
;
self
}
pub
fn
current_dir
(
&
mut
self
path
:
impl
Into
<
PathBuf
>
)
-
>
&
mut
MetadataCommand
{
self
.
current_dir
=
Some
(
path
.
into
(
)
)
;
self
}
pub
fn
no_deps
(
&
mut
self
)
-
>
&
mut
MetadataCommand
{
self
.
no_deps
=
true
;
self
}
pub
fn
features
(
&
mut
self
features
:
CargoOpt
)
-
>
&
mut
MetadataCommand
{
match
features
{
CargoOpt
:
:
SomeFeatures
(
features
)
=
>
self
.
features
.
extend
(
features
)
CargoOpt
:
:
NoDefaultFeatures
=
>
{
assert
!
(
!
self
.
no_default_features
"
Do
not
supply
CargoOpt
:
:
NoDefaultFeatures
more
than
once
!
"
)
;
self
.
no_default_features
=
true
;
}
CargoOpt
:
:
AllFeatures
=
>
{
assert
!
(
!
self
.
all_features
"
Do
not
supply
CargoOpt
:
:
AllFeatures
more
than
once
!
"
)
;
self
.
all_features
=
true
;
}
}
self
}
pub
fn
other_options
(
&
mut
self
options
:
impl
Into
<
Vec
<
String
>
>
)
-
>
&
mut
MetadataCommand
{
self
.
other_options
=
options
.
into
(
)
;
self
}
pub
fn
env
<
K
:
Into
<
OsString
>
V
:
Into
<
OsString
>
>
(
&
mut
self
key
:
K
val
:
V
)
-
>
&
mut
MetadataCommand
{
self
.
env
.
insert
(
key
.
into
(
)
val
.
into
(
)
)
;
self
}
pub
fn
verbose
(
&
mut
self
verbose
:
bool
)
-
>
&
mut
MetadataCommand
{
self
.
verbose
=
verbose
;
self
}
pub
fn
cargo_command
(
&
self
)
-
>
Command
{
let
cargo
=
self
.
cargo_path
.
clone
(
)
.
or_else
(
|
|
env
:
:
var
(
"
CARGO
"
)
.
map
(
PathBuf
:
:
from
)
.
ok
(
)
)
.
unwrap_or_else
(
|
|
PathBuf
:
:
from
(
"
cargo
"
)
)
;
let
mut
cmd
=
Command
:
:
new
(
cargo
)
;
cmd
.
args
(
&
[
"
metadata
"
"
-
-
format
-
version
"
"
1
"
]
)
;
if
self
.
no_deps
{
cmd
.
arg
(
"
-
-
no
-
deps
"
)
;
}
if
let
Some
(
path
)
=
self
.
current_dir
.
as_ref
(
)
{
cmd
.
current_dir
(
path
)
;
}
if
!
self
.
features
.
is_empty
(
)
{
cmd
.
arg
(
"
-
-
features
"
)
.
arg
(
self
.
features
.
join
(
"
"
)
)
;
}
if
self
.
all_features
{
cmd
.
arg
(
"
-
-
all
-
features
"
)
;
}
if
self
.
no_default_features
{
cmd
.
arg
(
"
-
-
no
-
default
-
features
"
)
;
}
if
let
Some
(
manifest_path
)
=
&
self
.
manifest_path
{
cmd
.
arg
(
"
-
-
manifest
-
path
"
)
.
arg
(
manifest_path
.
as_os_str
(
)
)
;
}
cmd
.
args
(
&
self
.
other_options
)
;
cmd
.
envs
(
&
self
.
env
)
;
cmd
}
pub
fn
parse
<
T
:
AsRef
<
str
>
>
(
data
:
T
)
-
>
Result
<
Metadata
>
{
let
meta
=
serde_json
:
:
from_str
(
data
.
as_ref
(
)
)
?
;
Ok
(
meta
)
}
pub
fn
exec
(
&
self
)
-
>
Result
<
Metadata
>
{
let
mut
command
=
self
.
cargo_command
(
)
;
if
self
.
verbose
{
command
.
stderr
(
Stdio
:
:
inherit
(
)
)
;
}
let
output
=
command
.
output
(
)
?
;
if
!
output
.
status
.
success
(
)
{
return
Err
(
Error
:
:
CargoMetadata
{
stderr
:
String
:
:
from_utf8
(
output
.
stderr
)
?
}
)
;
}
let
stdout
=
from_utf8
(
&
output
.
stdout
)
?
.
lines
(
)
.
find
(
|
line
|
line
.
starts_with
(
'
{
'
)
)
.
ok_or
(
Error
:
:
NoJson
)
?
;
Self
:
:
parse
(
stdout
)
}
}
