#
!
[
no_std
]
#
[
inline
(
never
)
]
fn
constant_time_ne
(
a
:
&
[
u8
]
b
:
&
[
u8
]
)
-
>
u8
{
assert
!
(
a
.
len
(
)
=
=
b
.
len
(
)
)
;
let
len
=
a
.
len
(
)
;
let
a
=
&
a
[
.
.
len
]
;
let
b
=
&
b
[
.
.
len
]
;
let
mut
tmp
=
0
;
for
i
in
0
.
.
len
{
tmp
|
=
a
[
i
]
^
b
[
i
]
;
}
tmp
}
#
[
inline
]
pub
fn
constant_time_eq
(
a
:
&
[
u8
]
b
:
&
[
u8
]
)
-
>
bool
{
a
.
len
(
)
=
=
b
.
len
(
)
&
&
constant_time_ne
(
a
b
)
=
=
0
}
macro_rules
!
constant_time_ne_n
{
(
ne
:
ident
n
:
expr
)
=
>
{
/
/
This
function
is
non
-
inline
to
prevent
the
optimizer
from
looking
inside
it
.
#
[
inline
(
never
)
]
fn
ne
(
a
:
&
[
u8
;
n
]
b
:
&
[
u8
;
n
]
)
-
>
u8
{
let
mut
tmp
=
0
;
for
i
in
0
.
.
n
{
tmp
|
=
a
[
i
]
^
b
[
i
]
;
}
tmp
/
/
The
compare
with
0
must
happen
outside
this
function
.
}
}
;
}
constant_time_ne_n
!
(
constant_time_ne_16
16
)
;
constant_time_ne_n
!
(
constant_time_ne_32
32
)
;
constant_time_ne_n
!
(
constant_time_ne_64
64
)
;
#
[
inline
]
pub
fn
constant_time_eq_16
(
a
:
&
[
u8
;
16
]
b
:
&
[
u8
;
16
]
)
-
>
bool
{
constant_time_ne_16
(
a
b
)
=
=
0
}
#
[
inline
]
pub
fn
constant_time_eq_32
(
a
:
&
[
u8
;
32
]
b
:
&
[
u8
;
32
]
)
-
>
bool
{
constant_time_ne_32
(
a
b
)
=
=
0
}
#
[
inline
]
pub
fn
constant_time_eq_64
(
a
:
&
[
u8
;
64
]
b
:
&
[
u8
;
64
]
)
-
>
bool
{
constant_time_ne_64
(
a
b
)
=
=
0
}
