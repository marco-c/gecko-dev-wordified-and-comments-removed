mod
parser
;
mod
ref_serializer
;
mod
serializer
;
mod
utils
;
#
[
cfg
(
test
)
]
mod
test_parser
;
#
[
cfg
(
test
)
]
mod
test_serializer
;
use
indexmap
:
:
IndexMap
;
pub
use
rust_decimal
:
:
{
prelude
:
:
{
FromPrimitive
FromStr
}
Decimal
}
;
pub
use
parser
:
:
{
ParseMore
ParseValue
Parser
}
;
pub
use
ref_serializer
:
:
{
RefDictSerializer
RefItemSerializer
RefListSerializer
}
;
pub
use
serializer
:
:
SerializeValue
;
type
SFVResult
<
T
>
=
std
:
:
result
:
:
Result
<
T
&
'
static
str
>
;
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
struct
Item
{
pub
bare_item
:
BareItem
pub
params
:
Parameters
}
impl
Item
{
pub
fn
new
(
bare_item
:
BareItem
)
-
>
Item
{
Item
{
bare_item
params
:
Parameters
:
:
new
(
)
}
}
pub
fn
with_params
(
bare_item
:
BareItem
params
:
Parameters
)
-
>
Item
{
Item
{
bare_item
params
}
}
}
pub
type
Dictionary
=
IndexMap
<
String
ListEntry
>
;
pub
type
List
=
Vec
<
ListEntry
>
;
pub
type
Parameters
=
IndexMap
<
String
BareItem
>
;
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
enum
ListEntry
{
Item
(
Item
)
InnerList
(
InnerList
)
}
impl
From
<
Item
>
for
ListEntry
{
fn
from
(
item
:
Item
)
-
>
Self
{
ListEntry
:
:
Item
(
item
)
}
}
impl
From
<
InnerList
>
for
ListEntry
{
fn
from
(
item
:
InnerList
)
-
>
Self
{
ListEntry
:
:
InnerList
(
item
)
}
}
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
struct
InnerList
{
pub
items
:
Vec
<
Item
>
pub
params
:
Parameters
}
impl
InnerList
{
pub
fn
new
(
items
:
Vec
<
Item
>
)
-
>
InnerList
{
InnerList
{
items
params
:
Parameters
:
:
new
(
)
}
}
pub
fn
with_params
(
items
:
Vec
<
Item
>
params
:
Parameters
)
-
>
InnerList
{
InnerList
{
items
params
}
}
}
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
enum
BareItem
{
Decimal
(
Decimal
)
Integer
(
i64
)
String
(
String
)
ByteSeq
(
Vec
<
u8
>
)
Boolean
(
bool
)
Token
(
String
)
}
impl
BareItem
{
pub
fn
as_decimal
(
&
self
)
-
>
Option
<
Decimal
>
{
match
*
self
{
BareItem
:
:
Decimal
(
val
)
=
>
Some
(
val
)
_
=
>
None
}
}
pub
fn
as_int
(
&
self
)
-
>
Option
<
i64
>
{
match
*
self
{
BareItem
:
:
Integer
(
val
)
=
>
Some
(
val
)
_
=
>
None
}
}
pub
fn
as_str
(
&
self
)
-
>
Option
<
&
str
>
{
match
*
self
{
BareItem
:
:
String
(
ref
val
)
=
>
Some
(
val
)
_
=
>
None
}
}
pub
fn
as_byte_seq
(
&
self
)
-
>
Option
<
&
Vec
<
u8
>
>
{
match
*
self
{
BareItem
:
:
ByteSeq
(
ref
val
)
=
>
Some
(
val
)
_
=
>
None
}
}
pub
fn
as_bool
(
&
self
)
-
>
Option
<
bool
>
{
match
*
self
{
BareItem
:
:
Boolean
(
val
)
=
>
Some
(
val
)
_
=
>
None
}
}
pub
fn
as_token
(
&
self
)
-
>
Option
<
&
str
>
{
match
*
self
{
BareItem
:
:
Token
(
ref
val
)
=
>
Some
(
val
)
_
=
>
None
}
}
}
impl
From
<
i64
>
for
BareItem
{
fn
from
(
item
:
i64
)
-
>
Self
{
BareItem
:
:
Integer
(
item
)
}
}
impl
From
<
Decimal
>
for
BareItem
{
fn
from
(
item
:
Decimal
)
-
>
Self
{
BareItem
:
:
Decimal
(
item
)
}
}
#
[
derive
(
Debug
PartialEq
)
]
pub
(
crate
)
enum
Num
{
Decimal
(
Decimal
)
Integer
(
i64
)
}
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
enum
RefBareItem
<
'
a
>
{
Integer
(
i64
)
Decimal
(
Decimal
)
String
(
&
'
a
str
)
ByteSeq
(
&
'
a
[
u8
]
)
Boolean
(
bool
)
Token
(
&
'
a
str
)
}
impl
BareItem
{
fn
to_ref_bare_item
(
&
self
)
-
>
RefBareItem
{
match
self
{
BareItem
:
:
Integer
(
val
)
=
>
RefBareItem
:
:
Integer
(
*
val
)
BareItem
:
:
Decimal
(
val
)
=
>
RefBareItem
:
:
Decimal
(
*
val
)
BareItem
:
:
String
(
val
)
=
>
RefBareItem
:
:
String
(
val
)
BareItem
:
:
ByteSeq
(
val
)
=
>
RefBareItem
:
:
ByteSeq
(
val
.
as_slice
(
)
)
BareItem
:
:
Boolean
(
val
)
=
>
RefBareItem
:
:
Boolean
(
*
val
)
BareItem
:
:
Token
(
val
)
=
>
RefBareItem
:
:
Token
(
val
)
}
}
}
