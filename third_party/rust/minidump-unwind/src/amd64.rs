use
super
:
:
impl_prelude
:
:
*
;
use
minidump
:
:
format
:
:
CONTEXT_AMD64
;
use
minidump
:
:
system_info
:
:
Os
;
use
minidump
:
:
{
MinidumpContext
MinidumpContextValidity
MinidumpModuleList
MinidumpRawContext
UnifiedMemory
}
;
use
std
:
:
collections
:
:
HashSet
;
use
tracing
:
:
trace
;
type
Pointer
=
u64
;
const
POINTER_WIDTH
:
Pointer
=
8
;
const
INSTRUCTION_REGISTER
:
&
str
=
"
rip
"
;
const
STACK_POINTER_REGISTER
:
&
str
=
"
rsp
"
;
const
FRAME_POINTER_REGISTER
:
&
str
=
"
rbp
"
;
const
CALLEE_SAVED_REGS
:
&
[
&
str
]
=
&
[
"
rbx
"
"
rbp
"
"
r12
"
"
r13
"
"
r14
"
"
r15
"
]
;
async
fn
get_caller_by_cfi
<
P
>
(
ctx
:
&
CONTEXT_AMD64
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
cfi
"
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
args
.
valid
(
)
{
if
!
which
.
contains
(
STACK_POINTER_REGISTER
)
{
return
None
;
}
}
let
mut
stack_walker
=
CfiStackWalker
:
:
from_ctx_and_args
(
ctx
args
callee_forwarded_regs
)
?
;
args
.
symbol_provider
.
walk_frame
(
stack_walker
.
module
&
mut
stack_walker
)
.
await
?
;
let
caller_ip
=
stack_walker
.
caller_ctx
.
rip
;
let
caller_sp
=
stack_walker
.
caller_ctx
.
rsp
;
trace
!
(
"
cfi
evaluation
was
successful
-
-
caller_ip
:
0x
{
:
016x
}
caller_sp
:
0x
{
:
016x
}
"
caller_ip
caller_sp
)
;
trace
!
(
"
cfi
result
seems
valid
"
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Amd64
(
stack_walker
.
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
stack_walker
.
caller_validity
)
}
;
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
CallFrameInfo
)
)
}
fn
callee_forwarded_regs
(
valid
:
&
MinidumpContextValidity
)
-
>
HashSet
<
&
'
static
str
>
{
match
valid
{
MinidumpContextValidity
:
:
All
=
>
CALLEE_SAVED_REGS
.
iter
(
)
.
copied
(
)
.
collect
(
)
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
>
CALLEE_SAVED_REGS
.
iter
(
)
.
filter
(
|
&
reg
|
which
.
contains
(
reg
)
)
.
copied
(
)
.
collect
(
)
}
}
fn
get_caller_by_frame_pointer
<
P
>
(
ctx
:
&
CONTEXT_AMD64
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
let
stack_memory
=
args
.
stack_memory
;
if
args
.
system_info
.
os
=
=
Os
:
:
Windows
{
return
None
;
}
trace
!
(
"
trying
frame
pointer
"
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
args
.
valid
(
)
{
if
!
which
.
contains
(
FRAME_POINTER_REGISTER
)
{
return
None
;
}
if
!
which
.
contains
(
STACK_POINTER_REGISTER
)
{
return
None
;
}
}
let
last_bp
=
ctx
.
rbp
;
let
last_sp
=
ctx
.
rsp
;
if
last_bp
>
=
u64
:
:
MAX
-
POINTER_WIDTH
*
2
{
return
None
;
}
let
caller_ip
=
stack_memory
.
get_memory_at_address
(
last_bp
+
POINTER_WIDTH
)
?
;
let
caller_bp
=
stack_memory
.
get_memory_at_address
(
last_bp
)
?
;
let
caller_sp
=
last_bp
+
POINTER_WIDTH
*
2
;
if
caller_sp
<
=
last_bp
|
|
caller_bp
<
caller_sp
{
trace
!
(
"
rejecting
frame
pointer
result
for
unreasonable
frame
pointer
"
)
;
return
None
;
}
let
_unused
:
Pointer
=
stack_memory
.
get_memory_at_address
(
caller_bp
)
?
;
if
is_non_canonical
(
caller_ip
)
{
trace
!
(
"
rejecting
frame
pointer
result
for
unreasonable
instruction
pointer
"
)
;
return
None
;
}
if
!
stack_seems_valid
(
caller_sp
last_sp
stack_memory
)
{
trace
!
(
"
rejecting
frame
pointer
result
for
unreasonable
stack
pointer
"
)
;
return
None
;
}
trace
!
(
"
frame
pointer
seems
valid
-
-
caller_ip
:
0x
{
:
016x
}
caller_sp
:
0x
{
:
016x
}
"
caller_ip
caller_sp
)
;
let
caller_ctx
=
CONTEXT_AMD64
{
rip
:
caller_ip
rsp
:
caller_sp
rbp
:
caller_bp
.
.
CONTEXT_AMD64
:
:
default
(
)
}
;
let
mut
valid
=
HashSet
:
:
new
(
)
;
valid
.
insert
(
INSTRUCTION_REGISTER
)
;
valid
.
insert
(
STACK_POINTER_REGISTER
)
;
valid
.
insert
(
FRAME_POINTER_REGISTER
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Amd64
(
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
valid
)
}
;
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
FramePointer
)
)
}
async
fn
get_caller_by_scan
<
P
>
(
ctx
:
&
CONTEXT_AMD64
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
scan
"
)
;
let
stack_memory
=
args
.
stack_memory
;
let
last_bp
=
match
args
.
valid
(
)
{
MinidumpContextValidity
:
:
All
=
>
Some
(
ctx
.
rbp
)
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
>
{
if
!
which
.
contains
(
STACK_POINTER_REGISTER
)
{
trace
!
(
"
cannot
scan
without
stack
pointer
"
)
;
return
None
;
}
if
which
.
contains
(
FRAME_POINTER_REGISTER
)
{
Some
(
ctx
.
rbp
)
}
else
{
None
}
}
}
;
let
last_sp
=
ctx
.
rsp
;
let
default_scan_range
=
40
;
let
extended_scan_range
=
default_scan_range
*
4
;
let
scan_range
=
if
let
FrameTrust
:
:
Context
=
args
.
callee_frame
.
trust
{
extended_scan_range
}
else
{
default_scan_range
}
;
for
i
in
0
.
.
scan_range
{
let
address_of_ip
=
last_sp
.
checked_add
(
i
*
POINTER_WIDTH
)
?
;
let
caller_ip
=
stack_memory
.
get_memory_at_address
(
address_of_ip
)
?
;
if
instruction_seems_valid
(
caller_ip
args
.
modules
args
.
symbol_provider
)
.
await
{
let
caller_sp
=
address_of_ip
.
checked_add
(
POINTER_WIDTH
)
?
;
let
mut
caller_bp
=
None
;
const
MAX_REASONABLE_GAP_BETWEEN_FRAMES
:
Pointer
=
128
*
1024
;
if
let
Some
(
last_bp
)
=
last_bp
{
if
i
>
0
{
let
address_of_bp
=
address_of_ip
-
POINTER_WIDTH
;
let
bp
=
stack_memory
.
get_memory_at_address
(
address_of_bp
)
?
;
if
last_bp
=
=
address_of_bp
&
&
bp
>
address_of_ip
&
&
bp
-
address_of_bp
<
=
MAX_REASONABLE_GAP_BETWEEN_FRAMES
{
if
stack_memory
.
get_memory_at_address
:
:
<
Pointer
>
(
bp
)
.
is_some
(
)
{
caller_bp
=
Some
(
bp
)
;
}
}
else
if
last_bp
>
=
caller_sp
{
caller_bp
=
Some
(
last_bp
)
;
}
}
}
trace
!
(
"
scan
seems
valid
-
-
caller_ip
:
0x
{
:
08x
}
caller_sp
:
0x
{
:
08x
}
"
caller_ip
caller_sp
)
;
let
caller_ctx
=
CONTEXT_AMD64
{
rip
:
caller_ip
rsp
:
caller_sp
rbp
:
caller_bp
.
unwrap_or
(
0
)
.
.
CONTEXT_AMD64
:
:
default
(
)
}
;
let
mut
valid
=
HashSet
:
:
new
(
)
;
valid
.
insert
(
INSTRUCTION_REGISTER
)
;
valid
.
insert
(
STACK_POINTER_REGISTER
)
;
if
caller_bp
.
is_some
(
)
{
valid
.
insert
(
FRAME_POINTER_REGISTER
)
;
}
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Amd64
(
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
valid
)
}
;
return
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
Scan
)
)
;
}
}
None
}
async
fn
instruction_seems_valid
<
P
>
(
instruction
:
Pointer
modules
:
&
MinidumpModuleList
symbol_provider
:
&
P
)
-
>
bool
where
P
:
SymbolProvider
+
Sync
{
if
is_non_canonical
(
instruction
)
|
|
instruction
=
=
0
{
return
false
;
}
super
:
:
instruction_seems_valid_by_symbols
(
instruction
modules
symbol_provider
)
.
await
}
fn
stack_seems_valid
(
caller_sp
:
Pointer
callee_sp
:
Pointer
stack_memory
:
UnifiedMemory
<
'
_
'
_
>
)
-
>
bool
{
if
caller_sp
<
=
callee_sp
{
return
false
;
}
stack_memory
.
get_memory_at_address
:
:
<
Pointer
>
(
caller_sp
)
.
is_some
(
)
}
fn
is_non_canonical
(
ptr
:
Pointer
)
-
>
bool
{
ptr
>
0x7FFFFFFFFFFF
&
&
ptr
<
0xFFFF800000000000
}
pub
async
fn
get_caller_frame
<
P
>
(
ctx
:
&
CONTEXT_AMD64
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
let
mut
frame
=
None
;
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_cfi
(
ctx
args
)
.
await
;
}
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_frame_pointer
(
ctx
args
)
;
}
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_scan
(
ctx
args
)
.
await
;
}
let
mut
frame
=
frame
?
;
if
frame
.
context
.
get_instruction_pointer
(
)
<
4096
{
trace
!
(
"
instruction
pointer
was
nullish
assuming
unwind
complete
"
)
;
return
None
;
}
if
frame
.
context
.
get_stack_pointer
(
)
<
=
ctx
.
rsp
{
trace
!
(
"
stack
pointer
went
backwards
assuming
unwind
complete
"
)
;
return
None
;
}
let
ip
=
frame
.
context
.
get_instruction_pointer
(
)
;
frame
.
instruction
=
ip
-
1
;
Some
(
frame
)
}
