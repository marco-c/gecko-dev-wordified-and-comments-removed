use
crate
:
:
*
;
use
minidump
:
:
format
:
:
CONTEXT_AMD64
;
use
minidump
:
:
system_info
:
:
{
Cpu
Os
}
;
use
std
:
:
collections
:
:
HashMap
;
use
test_assembler
:
:
*
;
struct
TestFixture
{
pub
raw
:
CONTEXT_AMD64
pub
modules
:
MinidumpModuleList
pub
system_info
:
SystemInfo
pub
symbols
:
HashMap
<
String
String
>
}
impl
TestFixture
{
pub
fn
new
(
)
-
>
TestFixture
{
TestFixture
{
raw
:
CONTEXT_AMD64
:
:
default
(
)
modules
:
MinidumpModuleList
:
:
from_modules
(
vec
!
[
MinidumpModule
:
:
new
(
0x00007400c0000000
0x10000
"
module1
"
)
MinidumpModule
:
:
new
(
0x00007500b0000000
0x10000
"
module2
"
)
]
)
system_info
:
SystemInfo
{
os
:
Os
:
:
Linux
os_version
:
None
os_build
:
None
cpu
:
Cpu
:
:
X86_64
cpu_info
:
None
cpu_microcode_version
:
None
cpu_count
:
1
}
symbols
:
HashMap
:
:
new
(
)
}
}
pub
async
fn
walk_stack
(
&
self
stack
:
Section
)
-
>
CallStack
{
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Amd64
(
self
.
raw
.
clone
(
)
)
valid
:
MinidumpContextValidity
:
:
All
}
;
let
base
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
let
size
=
stack
.
size
(
)
;
let
stack
=
stack
.
get_contents
(
)
.
unwrap
(
)
;
let
stack_memory
=
&
MinidumpMemory
{
desc
:
Default
:
:
default
(
)
base_address
:
base
size
bytes
:
&
stack
endian
:
scroll
:
:
LE
}
;
let
symbolizer
=
Symbolizer
:
:
new
(
string_symbol_supplier
(
self
.
symbols
.
clone
(
)
)
)
;
let
mut
stack
=
CallStack
:
:
with_context
(
context
)
;
walk_stack
(
0
(
)
&
mut
stack
Some
(
UnifiedMemory
:
:
Memory
(
stack_memory
)
)
&
self
.
modules
&
self
.
system_info
&
symbolizer
)
.
await
;
stack
}
pub
fn
add_symbols
(
&
mut
self
name
:
String
symbols
:
String
)
{
self
.
symbols
.
insert
(
name
symbols
)
;
}
}
#
[
tokio
:
:
test
]
async
fn
test_simple
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
stack
=
Section
:
:
new
(
)
;
stack
.
start
(
)
.
set_const
(
0x80000000
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
0x8000000080000000
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
1
)
;
let
f
=
&
s
.
frames
[
0
]
;
let
m
=
f
.
module
.
as_ref
(
)
.
unwrap
(
)
;
assert_eq
!
(
m
.
code_file
(
)
"
module1
"
)
;
}
#
[
tokio
:
:
test
]
async
fn
test_caller_pushed_rbp
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
mut
stack
=
Section
:
:
new
(
)
;
let
stack_start
=
0x8000000080000000
;
let
return_address
=
0x00007500b0000110
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
let
frame0_rbp
=
Label
:
:
new
(
)
;
let
frame1_sp
=
Label
:
:
new
(
)
;
let
frame1_rbp
=
Label
:
:
new
(
)
;
stack
=
stack
.
append_repeated
(
0
16
)
.
D64
(
0x00007400b0000000
)
.
D64
(
0x00007500b0000000
)
.
D64
(
0x00007400c0001000
)
.
D64
(
0x00007500b000aaaa
)
.
mark
(
&
frame0_rbp
)
.
D64
(
&
frame1_rbp
)
.
D64
(
return_address
)
.
mark
(
&
frame1_sp
)
.
append_repeated
(
0
32
)
.
mark
(
&
frame1_rbp
)
.
D64
(
0
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
frame0_rbp
.
value
(
)
.
unwrap
(
)
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
2
)
;
{
let
f0
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
f0
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
f0
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f0
.
context
.
raw
{
assert_eq
!
(
ctx
.
rbp
frame0_rbp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
{
let
f1
=
&
s
.
frames
[
1
]
;
assert_eq
!
(
f1
.
trust
FrameTrust
:
:
FramePointer
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
f1
.
context
.
valid
{
assert
!
(
which
.
contains
(
"
rip
"
)
)
;
assert
!
(
which
.
contains
(
"
rsp
"
)
)
;
assert
!
(
which
.
contains
(
"
rbp
"
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f1
.
context
.
raw
{
assert_eq
!
(
ctx
.
rip
return_address
)
;
assert_eq
!
(
ctx
.
rsp
frame1_sp
.
value
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
ctx
.
rbp
frame1_rbp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
#
[
tokio
:
:
test
]
async
fn
test_windows_rbp_scan
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
f
.
system_info
.
os
=
Os
:
:
Windows
;
let
mut
stack
=
Section
:
:
new
(
)
;
let
stack_start
=
0x8000000080000000
;
let
return_address
=
0x00007500b0000110
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
let
frame0_rbp
=
Label
:
:
new
(
)
;
let
frame1_sp
=
Label
:
:
new
(
)
;
let
frame1_rbp
=
Label
:
:
new
(
)
;
stack
=
stack
.
append_repeated
(
0
16
)
.
D64
(
0x00000000b0000000
)
.
D64
(
0x00000000b0000000
)
.
mark
(
&
frame0_rbp
)
.
D64
(
0x00000000c0001000
)
.
D64
(
0x00000000b000aaaa
)
.
D64
(
&
frame1_rbp
)
.
D64
(
return_address
)
.
mark
(
&
frame1_sp
)
.
append_repeated
(
0
32
)
.
mark
(
&
frame1_rbp
)
.
D64
(
0
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
frame0_rbp
.
value
(
)
.
unwrap
(
)
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
2
)
;
{
let
f0
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
f0
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
f0
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f0
.
context
.
raw
{
assert_eq
!
(
ctx
.
rbp
frame0_rbp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
{
let
f1
=
&
s
.
frames
[
1
]
;
assert_eq
!
(
f1
.
trust
FrameTrust
:
:
Scan
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
f1
.
context
.
valid
{
assert
!
(
which
.
contains
(
"
rip
"
)
)
;
assert
!
(
which
.
contains
(
"
rsp
"
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f1
.
context
.
raw
{
assert_eq
!
(
ctx
.
rip
return_address
)
;
assert_eq
!
(
ctx
.
rsp
frame1_sp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
#
[
tokio
:
:
test
]
async
fn
test_scan_without_symbols
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
mut
stack
=
Section
:
:
new
(
)
;
let
stack_start
=
0x8000000080000000
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
let
return_address1
=
0x00007500b0000100
;
let
return_address2
=
0x00007500b0000900
;
let
frame1_sp
=
Label
:
:
new
(
)
;
let
frame2_sp
=
Label
:
:
new
(
)
;
let
frame1_rbp
=
Label
:
:
new
(
)
;
stack
=
stack
.
append_repeated
(
0
16
)
.
D64
(
0x00007400b0000000
)
.
D64
(
0x00007500d0000000
)
.
D64
(
return_address1
)
.
mark
(
&
frame1_sp
)
.
append_repeated
(
0
16
)
.
D64
(
0x00007400b0000000
)
.
D64
(
0x00007500d0000000
)
.
mark
(
&
frame1_rbp
)
.
D64
(
stack_start
)
.
D64
(
return_address2
)
.
mark
(
&
frame2_sp
)
.
append_repeated
(
0
32
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
frame1_rbp
.
value
(
)
.
unwrap
(
)
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
3
)
;
{
let
f0
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
f0
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
f0
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
}
{
let
f1
=
&
s
.
frames
[
1
]
;
assert_eq
!
(
f1
.
trust
FrameTrust
:
:
Scan
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
f1
.
context
.
valid
{
assert
!
(
which
.
contains
(
"
rip
"
)
)
;
assert
!
(
which
.
contains
(
"
rsp
"
)
)
;
assert
!
(
which
.
contains
(
"
rbp
"
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f1
.
context
.
raw
{
assert_eq
!
(
ctx
.
rip
return_address1
)
;
assert_eq
!
(
ctx
.
rsp
frame1_sp
.
value
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
ctx
.
rbp
frame1_rbp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
{
let
f2
=
&
s
.
frames
[
2
]
;
assert_eq
!
(
f2
.
trust
FrameTrust
:
:
Scan
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
f2
.
context
.
valid
{
assert
!
(
which
.
contains
(
"
rip
"
)
)
;
assert
!
(
which
.
contains
(
"
rsp
"
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f2
.
context
.
raw
{
assert_eq
!
(
ctx
.
rip
return_address2
)
;
assert_eq
!
(
ctx
.
rsp
frame2_sp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
#
[
tokio
:
:
test
]
async
fn
test_scan_with_symbols
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
mut
stack
=
Section
:
:
new
(
)
;
let
stack_start
=
0x8000000080000000u64
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
let
return_address
=
0x00007500b0000110u64
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
let
frame1_rbp
=
Label
:
:
new
(
)
;
stack
=
stack
.
append_repeated
(
0
16
)
.
D64
(
0x00007400b0000000u64
)
.
D64
(
0x00007500b0000000u64
)
.
D64
(
0x00007400c0001000u64
)
.
D64
(
0x00007500b000aaaau64
)
.
D64
(
return_address
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
32
)
.
mark
(
&
frame1_rbp
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
frame1_rbp
.
value
(
)
.
unwrap
(
)
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
f
.
add_symbols
(
String
:
:
from
(
"
module1
"
)
String
:
:
from
(
"
FUNC
100
400
10
monotreme
\
n
"
)
)
;
f
.
add_symbols
(
String
:
:
from
(
"
module2
"
)
String
:
:
from
(
"
FUNC
100
400
10
marsupial
\
n
"
)
)
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
2
)
;
{
let
frame
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
frame
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
frame
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
}
{
let
frame
=
&
s
.
frames
[
1
]
;
let
valid
=
&
frame
.
context
.
valid
;
assert_eq
!
(
frame
.
trust
FrameTrust
:
:
Scan
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
valid
{
assert_eq
!
(
which
.
len
(
)
3
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
frame
.
context
.
raw
{
assert_eq
!
(
ctx
.
get_register
(
"
rip
"
valid
)
.
unwrap
(
)
return_address
)
;
assert_eq
!
(
ctx
.
get_register
(
"
rsp
"
valid
)
.
unwrap
(
)
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
ctx
.
get_register
(
"
rbp
"
valid
)
.
unwrap
(
)
frame1_rbp
.
value
(
)
.
unwrap
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
const
CALLEE_SAVE_REGS
:
&
[
&
str
]
=
&
[
"
rip
"
"
rbx
"
"
rbp
"
"
rsp
"
"
r12
"
"
r13
"
"
r14
"
"
r15
"
]
;
fn
init_cfi_state
(
)
-
>
(
TestFixture
Section
CONTEXT_AMD64
MinidumpContextValidity
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
symbols
=
[
"
FUNC
4000
1000
10
enchiridion
\
n
"
"
STACK
CFI
INIT
4000
100
.
cfa
:
rsp
8
+
.
ra
:
.
cfa
8
-
^
\
n
"
"
STACK
CFI
4001
.
cfa
:
rsp
16
+
rbx
:
.
cfa
16
-
^
\
n
"
"
STACK
CFI
4002
r12
:
rbx
\
n
"
"
STACK
CFI
4003
.
cfa
:
rsp
40
+
r13
:
.
cfa
32
-
^
\
n
"
"
STACK
CFI
4005
.
ra
:
r13
\
n
"
"
STACK
CFI
4006
.
cfa
:
rbp
16
+
rbp
:
.
cfa
24
-
^
\
n
"
"
FUNC
5000
1000
10
epictetus
\
n
"
"
STACK
CFI
INIT
5000
1000
.
cfa
:
rsp
.
ra
0
\
n
"
]
;
f
.
add_symbols
(
String
:
:
from
(
"
module1
"
)
symbols
.
concat
(
)
)
;
f
.
raw
.
set_register
(
"
rsp
"
0x8000000080000000
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0005510
)
;
f
.
raw
.
set_register
(
"
rbp
"
0x68995b1de4700266
)
;
f
.
raw
.
set_register
(
"
rbx
"
0x5a5beeb38de23be8
)
;
f
.
raw
.
set_register
(
"
r12
"
0xed1b02e8cc0fc79c
)
;
f
.
raw
.
set_register
(
"
r13
"
0x1d20ad8acacbe930
)
;
f
.
raw
.
set_register
(
"
r14
"
0xe94cffc2f7adaa28
)
;
f
.
raw
.
set_register
(
"
r15
"
0xb638d17d8da413b5
)
;
let
raw_valid
=
MinidumpContextValidity
:
:
All
;
let
expected
=
f
.
raw
.
clone
(
)
;
let
expected_regs
=
CALLEE_SAVE_REGS
;
let
expected_valid
=
MinidumpContextValidity
:
:
Some
(
expected_regs
.
iter
(
)
.
copied
(
)
.
collect
(
)
)
;
let
stack
=
Section
:
:
new
(
)
;
stack
.
start
(
)
.
set_const
(
f
.
raw
.
get_register
(
"
rsp
"
&
raw_valid
)
.
unwrap
(
)
)
;
(
f
stack
expected
expected_valid
)
}
async
fn
check_cfi
(
f
:
TestFixture
stack
:
Section
expected
:
CONTEXT_AMD64
expected_valid
:
MinidumpContextValidity
)
{
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
2
)
;
{
let
frame
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
frame
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
frame
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
}
{
if
let
MinidumpContextValidity
:
:
Some
(
ref
expected_regs
)
=
expected_valid
{
let
frame
=
&
s
.
frames
[
1
]
;
let
valid
=
&
frame
.
context
.
valid
;
assert_eq
!
(
frame
.
trust
FrameTrust
:
:
CallFrameInfo
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
valid
{
assert_eq
!
(
which
.
len
(
)
expected_regs
.
len
(
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
frame
.
context
.
raw
{
for
reg
in
expected_regs
{
assert_eq
!
(
ctx
.
get_register
(
reg
valid
)
expected
.
get_register
(
reg
&
expected_valid
)
"
{
reg
}
registers
didn
'
t
match
!
"
)
;
}
return
;
}
}
}
unreachable
!
(
)
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4000
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x00007400c0005510
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004000
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4001
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x5a5beeb38de23be8
)
.
D64
(
0x00007400c0005510
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004001
)
;
f
.
raw
.
set_register
(
"
rbx
"
0xbe0487d2f9eafe29
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4002
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x5a5beeb38de23be8
)
.
D64
(
0x00007400c0005510
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004002
)
;
f
.
raw
.
set_register
(
"
rbx
"
0xed1b02e8cc0fc79c
)
;
f
.
raw
.
set_register
(
"
r12
"
0xb0118de918a4bcea
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4003
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x0e023828dffd4d81
)
.
D64
(
0x1d20ad8acacbe930
)
.
D64
(
0x319e68b49e3ace0f
)
.
D64
(
0x5a5beeb38de23be8
)
.
D64
(
0x00007400c0005510
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004003
)
;
f
.
raw
.
set_register
(
"
rbx
"
0xed1b02e8cc0fc79c
)
;
f
.
raw
.
set_register
(
"
r12
"
0x89d04fa804c87a43
)
;
f
.
raw
.
set_register
(
"
r13
"
0x5118e02cbdb24b03
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4004
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x0e023828dffd4d81
)
.
D64
(
0x1d20ad8acacbe930
)
.
D64
(
0x319e68b49e3ace0f
)
.
D64
(
0x5a5beeb38de23be8
)
.
D64
(
0x00007400c0005510
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004004
)
;
f
.
raw
.
set_register
(
"
rbx
"
0xed1b02e8cc0fc79c
)
;
f
.
raw
.
set_register
(
"
r12
"
0x46b1b8868891b34a
)
;
f
.
raw
.
set_register
(
"
r13
"
0x5118e02cbdb24b03
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4005
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x4b516dd035745953
)
.
D64
(
0x1d20ad8acacbe930
)
.
D64
(
0xa6d445e16ae3d872
)
.
D64
(
0x5a5beeb38de23be8
)
.
D64
(
0xaa95fa054aedfbae
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004005
)
;
f
.
raw
.
set_register
(
"
rbx
"
0xed1b02e8cc0fc79c
)
;
f
.
raw
.
set_register
(
"
r12
"
0x46b1b8868891b34a
)
;
f
.
raw
.
set_register
(
"
r13
"
0x00007400c0005510
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_cfi_at_4006
(
)
{
let
(
mut
f
mut
stack
mut
expected
expected_valid
)
=
init_cfi_state
(
)
;
let
frame0_rbp
=
Label
:
:
new
(
)
;
let
frame1_rsp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
0x043c6dfceb91aa34
)
.
D64
(
0x1d20ad8acacbe930
)
.
D64
(
0x68995b1de4700266
)
.
mark
(
&
frame0_rbp
)
.
D64
(
0x5a5beeb38de23be8
)
.
D64
(
0xf015ee516ad89eab
)
.
mark
(
&
frame1_rsp
)
.
append_repeated
(
0
1000
)
;
expected
.
set_register
(
"
rsp
"
frame1_rsp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rip
"
0x00007400c0004006
)
;
f
.
raw
.
set_register
(
"
rbp
"
frame0_rbp
.
value
(
)
.
unwrap
(
)
)
;
f
.
raw
.
set_register
(
"
rbx
"
0xed1b02e8cc0fc79c
)
;
f
.
raw
.
set_register
(
"
r12
"
0x26e007b341acfebd
)
;
f
.
raw
.
set_register
(
"
r13
"
0x00007400c0005510
)
;
check_cfi
(
f
stack
expected
expected_valid
)
.
await
;
}
#
[
tokio
:
:
test
]
async
fn
test_frame_pointer_overflow
(
)
{
type
Pointer
=
u64
;
let
stack_max
:
Pointer
=
Pointer
:
:
MAX
;
let
stack_size
:
Pointer
=
1000
;
let
bad_frame_ptr
:
Pointer
=
stack_max
;
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
mut
stack
=
Section
:
:
new
(
)
;
let
stack_start
:
Pointer
=
stack_max
-
stack_size
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
stack
=
stack
.
append_repeated
(
0
stack_size
as
usize
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
bad_frame_ptr
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
as
Pointer
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
1
)
;
}
#
[
tokio
:
:
test
]
async
fn
test_frame_pointer_barely_no_overflow
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
mut
stack
=
Section
:
:
new
(
)
;
type
Pointer
=
u64
;
let
stack_max
:
Pointer
=
Pointer
:
:
MAX
;
let
pointer_size
:
Pointer
=
std
:
:
mem
:
:
size_of
:
:
<
Pointer
>
(
)
as
Pointer
;
let
stack_size
:
Pointer
=
pointer_size
*
3
;
let
stack_start
:
Pointer
=
stack_max
-
stack_size
;
let
return_address
:
Pointer
=
0x00007500b0000110
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
let
frame0_fp
=
Label
:
:
new
(
)
;
let
frame1_sp
=
Label
:
:
new
(
)
;
let
frame1_fp
=
Label
:
:
new
(
)
;
stack
=
stack
.
mark
(
&
frame0_fp
)
.
D64
(
&
frame1_fp
)
.
D64
(
return_address
)
.
mark
(
&
frame1_sp
)
.
mark
(
&
frame1_fp
)
.
D64
(
0
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
frame0_fp
.
value
(
)
.
unwrap
(
)
as
Pointer
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
2
)
;
{
let
f0
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
f0
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
f0
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f0
.
context
.
raw
{
assert_eq
!
(
ctx
.
rbp
frame0_fp
.
value
(
)
.
unwrap
(
)
as
Pointer
)
;
}
else
{
unreachable
!
(
)
;
}
}
{
let
f1
=
&
s
.
frames
[
1
]
;
assert_eq
!
(
f1
.
trust
FrameTrust
:
:
FramePointer
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
f1
.
context
.
valid
{
assert
!
(
which
.
contains
(
"
rip
"
)
)
;
assert
!
(
which
.
contains
(
"
rsp
"
)
)
;
assert
!
(
which
.
contains
(
"
rbp
"
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f1
.
context
.
raw
{
assert_eq
!
(
ctx
.
rip
return_address
)
;
assert_eq
!
(
ctx
.
rsp
frame1_sp
.
value
(
)
.
unwrap
(
)
as
Pointer
)
;
assert_eq
!
(
ctx
.
rbp
frame1_fp
.
value
(
)
.
unwrap
(
)
as
Pointer
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
#
[
tokio
:
:
test
]
async
fn
test_scan_walk_overflow
(
)
{
let
mut
f
=
TestFixture
:
:
new
(
)
;
let
mut
stack
=
Section
:
:
new
(
)
;
let
stack_start
=
0
;
stack
.
start
(
)
.
set_const
(
stack_start
)
;
let
return_address1
=
0x00007500b0000100_u64
;
let
frame1_sp
=
Label
:
:
new
(
)
;
let
frame1_rbp
=
Label
:
:
new
(
)
;
stack
=
stack
.
D64
(
return_address1
)
.
mark
(
&
frame1_sp
)
.
append_repeated
(
0
16
)
.
D64
(
0x00007400b0000000
)
.
D64
(
0x00007500d0000000
)
.
mark
(
&
frame1_rbp
)
;
f
.
raw
.
rip
=
0x00007400c0000200
;
f
.
raw
.
rbp
=
frame1_rbp
.
value
(
)
.
unwrap
(
)
;
f
.
raw
.
rsp
=
stack
.
start
(
)
.
value
(
)
.
unwrap
(
)
;
let
s
=
f
.
walk_stack
(
stack
)
.
await
;
assert_eq
!
(
s
.
frames
.
len
(
)
2
)
;
{
let
f0
=
&
s
.
frames
[
0
]
;
assert_eq
!
(
f0
.
trust
FrameTrust
:
:
Context
)
;
assert_eq
!
(
f0
.
context
.
valid
MinidumpContextValidity
:
:
All
)
;
}
{
let
f1
=
&
s
.
frames
[
1
]
;
assert_eq
!
(
f1
.
trust
FrameTrust
:
:
Scan
)
;
if
let
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
f1
.
context
.
valid
{
assert
!
(
which
.
contains
(
"
rip
"
)
)
;
assert
!
(
which
.
contains
(
"
rsp
"
)
)
;
}
else
{
unreachable
!
(
)
;
}
if
let
MinidumpRawContext
:
:
Amd64
(
ctx
)
=
&
f1
.
context
.
raw
{
assert_eq
!
(
ctx
.
rip
return_address1
)
;
assert_eq
!
(
ctx
.
rsp
frame1_sp
.
value
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
ctx
.
rbp
0
)
;
}
else
{
unreachable
!
(
)
;
}
}
}
