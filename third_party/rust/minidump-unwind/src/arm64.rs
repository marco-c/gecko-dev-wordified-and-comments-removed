use
super
:
:
impl_prelude
:
:
*
;
use
minidump
:
:
{
CpuContext
MinidumpContext
MinidumpContextValidity
MinidumpModuleList
MinidumpRawContext
Module
}
;
use
std
:
:
collections
:
:
HashSet
;
use
tracing
:
:
trace
;
type
ArmContext
=
minidump
:
:
format
:
:
CONTEXT_ARM64
;
type
Pointer
=
<
ArmContext
as
CpuContext
>
:
:
Register
;
type
Registers
=
minidump
:
:
format
:
:
Arm64RegisterNumbers
;
const
POINTER_WIDTH
:
Pointer
=
std
:
:
mem
:
:
size_of
:
:
<
Pointer
>
(
)
as
Pointer
;
const
FRAME_POINTER
:
&
str
=
Registers
:
:
FramePointer
.
name
(
)
;
const
LINK_REGISTER
:
&
str
=
Registers
:
:
LinkRegister
.
name
(
)
;
const
STACK_POINTER
:
&
str
=
"
sp
"
;
const
PROGRAM_COUNTER
:
&
str
=
"
pc
"
;
const
CALLEE_SAVED_REGS
:
&
[
&
str
]
=
&
[
"
x19
"
"
x20
"
"
x21
"
"
x22
"
"
x23
"
"
x24
"
"
x25
"
"
x26
"
"
x27
"
"
x28
"
"
fp
"
]
;
async
fn
get_caller_by_cfi
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
cfi
"
)
;
let
_last_sp
=
ctx
.
get_register
(
STACK_POINTER
args
.
valid
(
)
)
?
;
let
mut
stack_walker
=
CfiStackWalker
:
:
from_ctx_and_args
(
ctx
args
callee_forwarded_regs
)
?
;
args
.
symbol_provider
.
walk_frame
(
stack_walker
.
module
&
mut
stack_walker
)
.
await
?
;
let
caller_pc
=
stack_walker
.
caller_ctx
.
get_register_always
(
PROGRAM_COUNTER
)
;
let
caller_sp
=
stack_walker
.
caller_ctx
.
get_register_always
(
STACK_POINTER
)
;
let
new_valid
=
MinidumpContextValidity
:
:
Some
(
stack_walker
.
caller_validity
)
;
let
caller_pc
=
ptr_auth_strip
(
args
.
modules
caller_pc
)
;
stack_walker
.
caller_ctx
.
set_register
(
PROGRAM_COUNTER
caller_pc
)
;
if
let
Some
(
lr
)
=
stack_walker
.
caller_ctx
.
get_register
(
LINK_REGISTER
&
new_valid
)
{
stack_walker
.
caller_ctx
.
set_register
(
LINK_REGISTER
ptr_auth_strip
(
args
.
modules
lr
)
)
;
}
if
let
Some
(
fp
)
=
stack_walker
.
caller_ctx
.
get_register
(
FRAME_POINTER
&
new_valid
)
{
stack_walker
.
caller_ctx
.
set_register
(
FRAME_POINTER
ptr_auth_strip
(
args
.
modules
fp
)
)
;
}
trace
!
(
"
cfi
evaluation
was
successful
-
-
caller_pc
:
0x
{
:
016x
}
caller_sp
:
0x
{
:
016x
}
"
caller_pc
caller_sp
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Arm64
(
stack_walker
.
caller_ctx
)
valid
:
new_valid
}
;
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
CallFrameInfo
)
)
}
fn
callee_forwarded_regs
(
valid
:
&
MinidumpContextValidity
)
-
>
HashSet
<
&
'
static
str
>
{
match
valid
{
MinidumpContextValidity
:
:
All
=
>
CALLEE_SAVED_REGS
.
iter
(
)
.
copied
(
)
.
collect
(
)
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
>
CALLEE_SAVED_REGS
.
iter
(
)
.
filter
(
|
&
reg
|
which
.
contains
(
reg
)
)
.
copied
(
)
.
collect
(
)
}
}
fn
get_caller_by_frame_pointer
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
frame
pointer
"
)
;
let
last_fp
=
ctx
.
get_register
(
FRAME_POINTER
args
.
valid
(
)
)
?
;
let
last_sp
=
ctx
.
get_register
(
STACK_POINTER
args
.
valid
(
)
)
?
;
if
last_fp
>
=
u64
:
:
MAX
-
POINTER_WIDTH
*
2
{
return
None
;
}
let
(
caller_fp
caller_pc
caller_sp
)
=
if
last_fp
=
=
0
{
(
0
0
last_sp
)
}
else
{
(
args
.
stack_memory
.
get_memory_at_address
(
last_fp
)
?
args
.
stack_memory
.
get_memory_at_address
(
last_fp
+
POINTER_WIDTH
)
?
last_fp
+
POINTER_WIDTH
*
2
)
}
;
let
caller_fp
=
ptr_auth_strip
(
args
.
modules
caller_fp
)
;
let
caller_pc
=
ptr_auth_strip
(
args
.
modules
caller_pc
)
;
if
is_non_canonical
(
caller_pc
)
{
trace
!
(
"
rejecting
frame
pointer
result
for
unreasonable
instruction
pointer
"
)
;
return
None
;
}
trace
!
(
"
frame
pointer
seems
valid
-
-
caller_pc
:
0x
{
:
016x
}
caller_sp
:
0x
{
:
016x
}
"
caller_pc
caller_sp
)
;
let
mut
caller_ctx
=
ArmContext
:
:
default
(
)
;
caller_ctx
.
set_register
(
PROGRAM_COUNTER
caller_pc
)
;
caller_ctx
.
set_register
(
FRAME_POINTER
caller_fp
)
;
caller_ctx
.
set_register
(
STACK_POINTER
caller_sp
)
;
let
mut
valid
=
HashSet
:
:
new
(
)
;
valid
.
insert
(
PROGRAM_COUNTER
)
;
valid
.
insert
(
FRAME_POINTER
)
;
valid
.
insert
(
STACK_POINTER
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Arm64
(
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
valid
)
}
;
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
FramePointer
)
)
}
fn
ptr_auth_strip
(
modules
:
&
MinidumpModuleList
ptr
:
Pointer
)
-
>
Pointer
{
let
apple_default_max_addr
=
(
1
<
<
47
)
-
1
;
let
max_module_addr
=
modules
.
by_addr
(
)
.
next_back
(
)
.
map
(
|
last_module
|
{
last_module
.
base_address
(
)
.
saturating_add
(
last_module
.
size
(
)
)
}
)
.
unwrap_or
(
0
)
;
let
max_addr
=
u64
:
:
max
(
apple_default_max_addr
max_module_addr
)
;
let
mask
=
max_addr
.
checked_next_power_of_two
(
)
.
map
(
|
high_bit
|
high_bit
-
1
)
.
unwrap_or
(
!
0
)
;
ptr
&
mask
}
async
fn
get_caller_by_scan
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
scan
"
)
;
let
last_sp
=
ctx
.
get_register
(
STACK_POINTER
args
.
valid
(
)
)
?
;
let
default_scan_range
=
40
;
let
extended_scan_range
=
default_scan_range
*
4
;
let
scan_range
=
if
let
FrameTrust
:
:
Context
=
args
.
callee_frame
.
trust
{
extended_scan_range
}
else
{
default_scan_range
}
;
for
i
in
0
.
.
scan_range
{
let
address_of_pc
=
last_sp
.
checked_add
(
i
*
POINTER_WIDTH
)
?
;
let
caller_pc
=
args
.
stack_memory
.
get_memory_at_address
(
address_of_pc
)
?
;
if
instruction_seems_valid
(
caller_pc
args
.
modules
args
.
symbol_provider
)
.
await
{
let
caller_sp
=
address_of_pc
.
checked_add
(
POINTER_WIDTH
)
?
;
trace
!
(
"
scan
seems
valid
-
-
caller_pc
:
0x
{
:
08x
}
caller_sp
:
0x
{
:
08x
}
"
caller_pc
caller_sp
)
;
let
mut
caller_ctx
=
ArmContext
:
:
default
(
)
;
caller_ctx
.
set_register
(
PROGRAM_COUNTER
caller_pc
)
;
caller_ctx
.
set_register
(
STACK_POINTER
caller_sp
)
;
let
mut
valid
=
HashSet
:
:
new
(
)
;
valid
.
insert
(
PROGRAM_COUNTER
)
;
valid
.
insert
(
STACK_POINTER
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Arm64
(
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
valid
)
}
;
return
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
Scan
)
)
;
}
}
None
}
async
fn
instruction_seems_valid
<
P
>
(
instruction
:
Pointer
modules
:
&
MinidumpModuleList
symbol_provider
:
&
P
)
-
>
bool
where
P
:
SymbolProvider
+
Sync
{
if
is_non_canonical
(
instruction
)
|
|
instruction
=
=
0
{
return
false
;
}
super
:
:
instruction_seems_valid_by_symbols
(
instruction
modules
symbol_provider
)
.
await
}
fn
is_non_canonical
(
instruction
:
Pointer
)
-
>
bool
{
!
(
0x1000
.
.
=
0x000fffffffffffff
)
.
contains
(
&
instruction
)
}
pub
async
fn
get_caller_frame
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
let
mut
frame
=
None
;
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_cfi
(
ctx
args
)
.
await
;
}
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_frame_pointer
(
ctx
args
)
;
}
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_scan
(
ctx
args
)
.
await
;
}
let
mut
frame
=
frame
?
;
if
frame
.
context
.
get_instruction_pointer
(
)
<
4096
{
trace
!
(
"
instruction
pointer
was
nullish
assuming
unwind
complete
"
)
;
return
None
;
}
let
sp
=
frame
.
context
.
get_stack_pointer
(
)
;
let
last_sp
=
ctx
.
get_register_always
(
"
sp
"
)
;
if
sp
<
=
last_sp
{
let
is_leaf
=
args
.
callee_frame
.
trust
=
=
FrameTrust
:
:
Context
&
&
sp
=
=
last_sp
;
if
!
is_leaf
{
trace
!
(
"
stack
pointer
went
backwards
assuming
unwind
complete
"
)
;
return
None
;
}
}
let
ip
=
frame
.
context
.
get_instruction_pointer
(
)
;
frame
.
instruction
=
ip
-
4
;
Some
(
frame
)
}
