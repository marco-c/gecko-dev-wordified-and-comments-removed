#
[
cfg
(
all
(
doctest
feature
=
"
http
"
)
)
]
doc_comment
:
:
doctest
!
(
"
.
.
/
README
.
md
"
)
;
mod
amd64
;
mod
arm
;
mod
arm64
;
mod
arm64_old
;
mod
mips
;
pub
mod
symbols
;
pub
mod
system_info
;
mod
x86
;
use
minidump
:
:
*
;
use
minidump_common
:
:
utils
:
:
basename
;
use
scroll
:
:
ctx
:
:
{
SizeWith
TryFromCtx
}
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
collections
:
:
{
BTreeMap
BTreeSet
HashSet
}
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
tracing
:
:
trace
;
pub
use
crate
:
:
symbols
:
:
*
;
pub
use
crate
:
:
system_info
:
:
*
;
#
[
derive
(
Clone
Copy
)
]
struct
GetCallerFrameArgs
<
'
a
P
>
{
callee_frame
:
&
'
a
StackFrame
grand_callee_frame
:
Option
<
&
'
a
StackFrame
>
stack_memory
:
UnifiedMemory
<
'
a
'
a
>
modules
:
&
'
a
MinidumpModuleList
system_info
:
&
'
a
SystemInfo
symbol_provider
:
&
'
a
P
}
impl
<
P
>
GetCallerFrameArgs
<
'
_
P
>
{
fn
valid
(
&
self
)
-
>
&
MinidumpContextValidity
{
&
self
.
callee_frame
.
context
.
valid
}
}
mod
impl_prelude
{
pub
(
crate
)
use
super
:
:
{
CfiStackWalker
FrameTrust
GetCallerFrameArgs
StackFrame
SymbolProvider
}
;
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
pub
enum
FrameTrust
{
None
Scan
CfiScan
FramePointer
CallFrameInfo
PreWalked
Context
}
impl
FrameTrust
{
pub
fn
description
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
FrameTrust
:
:
Context
=
>
"
given
as
instruction
pointer
in
context
"
FrameTrust
:
:
PreWalked
=
>
"
recovered
by
external
stack
walker
"
FrameTrust
:
:
CallFrameInfo
=
>
"
call
frame
info
"
FrameTrust
:
:
CfiScan
=
>
"
call
frame
info
with
scanning
"
FrameTrust
:
:
FramePointer
=
>
"
previous
frame
'
s
frame
pointer
"
FrameTrust
:
:
Scan
=
>
"
stack
scanning
"
FrameTrust
:
:
None
=
>
"
unknown
"
}
}
pub
fn
as_str
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
FrameTrust
:
:
Context
=
>
"
context
"
FrameTrust
:
:
PreWalked
=
>
"
prewalked
"
FrameTrust
:
:
CallFrameInfo
=
>
"
cfi
"
FrameTrust
:
:
CfiScan
=
>
"
cfi_scan
"
FrameTrust
:
:
FramePointer
=
>
"
frame_pointer
"
FrameTrust
:
:
Scan
=
>
"
scan
"
FrameTrust
:
:
None
=
>
"
non
"
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
CallingConvention
{
Cdecl
WindowsThisCall
OtherThisCall
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FunctionArgs
{
pub
calling_convention
:
CallingConvention
pub
args
:
Vec
<
FunctionArg
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
FunctionArg
{
pub
name
:
String
pub
value
:
Option
<
u64
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
InlineFrame
{
pub
function_name
:
String
pub
source_file_name
:
Option
<
String
>
pub
source_line
:
Option
<
u32
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
StackFrame
{
pub
instruction
:
u64
pub
resume_address
:
u64
pub
module
:
Option
<
MinidumpModule
>
pub
unloaded_modules
:
BTreeMap
<
String
BTreeSet
<
u64
>
>
pub
function_name
:
Option
<
String
>
pub
function_base
:
Option
<
u64
>
pub
parameter_size
:
Option
<
u32
>
pub
source_file_name
:
Option
<
String
>
pub
source_line
:
Option
<
u32
>
pub
source_line_base
:
Option
<
u64
>
pub
inlines
:
Vec
<
InlineFrame
>
pub
trust
:
FrameTrust
pub
context
:
MinidumpContext
pub
arguments
:
Option
<
FunctionArgs
>
}
impl
StackFrame
{
pub
fn
from_context
(
context
:
MinidumpContext
trust
:
FrameTrust
)
-
>
StackFrame
{
StackFrame
{
instruction
:
context
.
get_instruction_pointer
(
)
resume_address
:
context
.
get_instruction_pointer
(
)
module
:
None
unloaded_modules
:
BTreeMap
:
:
new
(
)
function_name
:
None
function_base
:
None
parameter_size
:
None
source_file_name
:
None
source_line
:
None
source_line_base
:
None
inlines
:
Vec
:
:
new
(
)
arguments
:
None
trust
context
}
}
}
impl
FrameSymbolizer
for
StackFrame
{
fn
get_instruction
(
&
self
)
-
>
u64
{
self
.
instruction
}
fn
set_function
(
&
mut
self
name
:
&
str
base
:
u64
parameter_size
:
u32
)
{
self
.
function_name
=
Some
(
String
:
:
from
(
name
)
)
;
self
.
function_base
=
Some
(
base
)
;
self
.
parameter_size
=
Some
(
parameter_size
)
;
}
fn
set_source_file
(
&
mut
self
file
:
&
str
line
:
u32
base
:
u64
)
{
self
.
source_file_name
=
Some
(
String
:
:
from
(
file
)
)
;
self
.
source_line
=
Some
(
line
)
;
self
.
source_line_base
=
Some
(
base
)
;
}
fn
add_inline_frame
(
&
mut
self
name
:
&
str
file
:
Option
<
&
str
>
line
:
Option
<
u32
>
)
{
self
.
inlines
.
push
(
InlineFrame
{
function_name
:
name
.
to_string
(
)
source_file_name
:
file
.
map
(
ToString
:
:
to_string
)
source_line
:
line
}
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
enum
CallStackInfo
{
Ok
MissingContext
MissingMemory
UnsupportedCpu
DumpThreadSkipped
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
CallStack
{
pub
frames
:
Vec
<
StackFrame
>
pub
info
:
CallStackInfo
pub
thread_id
:
u32
pub
thread_name
:
Option
<
String
>
pub
last_error_value
:
Option
<
CrashReason
>
}
impl
CallStack
{
pub
fn
with_context
(
context
:
MinidumpContext
)
-
>
Self
{
Self
{
frames
:
vec
!
[
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
Context
)
]
info
:
CallStackInfo
:
:
Ok
thread_id
:
0
thread_name
:
None
last_error_value
:
None
}
}
pub
fn
with_info
(
id
:
u32
info
:
CallStackInfo
)
-
>
CallStack
{
CallStack
{
info
frames
:
vec
!
[
]
thread_id
:
id
thread_name
:
None
last_error_value
:
None
}
}
pub
fn
print
<
T
:
Write
>
(
&
self
f
:
&
mut
T
)
-
>
io
:
:
Result
<
(
)
>
{
fn
print_registers
<
T
:
Write
>
(
f
:
&
mut
T
ctx
:
&
MinidumpContext
)
-
>
io
:
:
Result
<
(
)
>
{
let
registers
:
Cow
<
HashSet
<
&
str
>
>
=
match
ctx
.
valid
{
MinidumpContextValidity
:
:
All
=
>
{
let
gpr
=
ctx
.
general_purpose_registers
(
)
;
let
set
:
HashSet
<
&
str
>
=
gpr
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
Cow
:
:
Owned
(
set
)
}
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
>
Cow
:
:
Borrowed
(
which
)
}
;
let
mut
output
=
String
:
:
new
(
)
;
for
reg
in
ctx
.
general_purpose_registers
(
)
{
if
registers
.
contains
(
reg
)
{
let
reg_val
=
ctx
.
format_register
(
reg
)
;
let
next
=
format
!
(
"
{
reg
:
>
6
}
=
{
reg_val
}
"
)
;
if
output
.
chars
(
)
.
count
(
)
+
next
.
chars
(
)
.
count
(
)
>
80
{
writeln
!
(
f
"
{
output
}
"
)
?
;
output
.
truncate
(
0
)
;
}
output
.
push_str
(
&
next
)
;
}
}
if
!
output
.
is_empty
(
)
{
writeln
!
(
f
"
{
output
}
"
)
?
;
}
Ok
(
(
)
)
}
if
self
.
frames
.
is_empty
(
)
{
writeln
!
(
f
"
<
no
frames
>
"
)
?
;
}
let
mut
frame_count
=
0
;
for
frame
in
&
self
.
frames
{
for
inline
in
&
frame
.
inlines
{
let
frame_idx
=
frame_count
;
frame_count
+
=
1
;
write
!
(
f
"
{
frame_idx
:
2
}
"
)
?
;
if
let
Some
(
ref
module
)
=
frame
.
module
{
write
!
(
f
"
{
}
"
basename
(
&
module
.
code_file
(
)
)
)
?
;
}
write
!
(
f
"
!
{
}
"
inline
.
function_name
)
?
;
if
let
(
Some
(
source_file
)
Some
(
source_line
)
)
=
(
&
inline
.
source_file_name
&
inline
.
source_line
)
{
write
!
(
f
"
[
{
}
:
{
}
]
"
basename
(
source_file
)
source_line
)
?
;
}
writeln
!
(
f
)
?
;
writeln
!
(
f
"
Found
by
:
inlining
"
)
?
;
}
let
frame_idx
=
frame_count
;
frame_count
+
=
1
;
let
addr
=
frame
.
instruction
;
write
!
(
f
"
{
frame_idx
:
2
}
"
)
?
;
if
let
Some
(
module
)
=
&
frame
.
module
{
write
!
(
f
"
{
}
"
basename
(
&
module
.
code_file
(
)
)
)
?
;
if
let
(
Some
(
func_name
)
Some
(
func_base
)
)
=
(
&
frame
.
function_name
&
frame
.
function_base
)
{
write
!
(
f
"
!
{
func_name
}
"
)
?
;
if
let
(
Some
(
src_file
)
Some
(
src_line
)
Some
(
src_base
)
)
=
(
&
frame
.
source_file_name
&
frame
.
source_line
&
frame
.
source_line_base
)
{
write
!
(
f
"
[
{
}
:
{
}
+
{
:
#
x
}
]
"
basename
(
src_file
)
src_line
addr
-
src_base
)
?
;
}
else
{
write
!
(
f
"
+
{
:
#
x
}
"
addr
-
func_base
)
?
;
}
}
else
{
write
!
(
f
"
+
{
:
#
x
}
"
addr
-
module
.
base_address
(
)
)
?
;
}
}
else
{
write
!
(
f
"
{
addr
:
#
x
}
"
)
?
;
for
(
name
offsets
)
in
&
frame
.
unloaded_modules
{
write
!
(
f
"
(
unloaded
{
name
}
"
)
?
;
let
mut
first
=
true
;
for
offset
in
offsets
{
if
first
{
write
!
(
f
"
{
offset
:
#
x
}
"
)
?
;
}
else
{
write
!
(
f
"
|
{
offset
:
#
x
}
"
)
?
;
}
first
=
false
;
}
write
!
(
f
"
)
"
)
?
;
}
}
writeln
!
(
f
)
?
;
print_registers
(
f
&
frame
.
context
)
?
;
writeln
!
(
f
"
Found
by
:
{
}
"
frame
.
trust
.
description
(
)
)
?
;
if
let
Some
(
args
)
=
&
frame
.
arguments
{
use
MinidumpRawContext
:
:
*
;
let
pointer_width
=
match
&
frame
.
context
.
raw
{
X86
(
_
)
|
Ppc
(
_
)
|
Sparc
(
_
)
|
Arm
(
_
)
|
Mips
(
_
)
=
>
4
Ppc64
(
_
)
|
Amd64
(
_
)
|
Arm64
(
_
)
|
OldArm64
(
_
)
=
>
8
}
;
let
cc_summary
=
match
args
.
calling_convention
{
CallingConvention
:
:
Cdecl
=
>
"
cdecl
[
static
function
]
"
CallingConvention
:
:
WindowsThisCall
=
>
"
windows
thiscall
[
C
+
+
member
function
]
"
CallingConvention
:
:
OtherThisCall
=
>
{
"
non
-
windows
thiscall
[
C
+
+
member
function
]
"
}
}
;
writeln
!
(
f
"
Arguments
(
assuming
{
cc_summary
}
)
"
)
?
;
for
(
idx
arg
)
in
args
.
args
.
iter
(
)
.
enumerate
(
)
{
if
let
Some
(
val
)
=
arg
.
value
{
if
pointer_width
=
=
4
{
writeln
!
(
f
"
arg
{
}
(
{
}
)
=
0x
{
:
08x
}
"
idx
arg
.
name
val
)
?
;
}
else
{
writeln
!
(
f
"
arg
{
}
(
{
}
)
=
0x
{
:
016x
}
"
idx
arg
.
name
val
)
?
;
}
}
else
{
writeln
!
(
f
"
arg
{
}
(
{
}
)
=
<
unknown
>
"
idx
arg
.
name
)
?
;
}
}
writeln
!
(
f
)
?
;
}
}
Ok
(
(
)
)
}
}
struct
CfiStackWalker
<
'
a
C
:
CpuContext
>
{
instruction
:
u64
has_grand_callee
:
bool
grand_callee_parameter_size
:
u32
callee_ctx
:
&
'
a
C
callee_validity
:
&
'
a
MinidumpContextValidity
caller_ctx
:
C
caller_validity
:
HashSet
<
&
'
static
str
>
module
:
&
'
a
MinidumpModule
stack_memory
:
UnifiedMemory
<
'
a
'
a
>
}
impl
<
'
a
C
>
CfiStackWalker
<
'
a
C
>
where
C
:
CpuContext
+
Clone
{
fn
from_ctx_and_args
<
P
R
>
(
ctx
:
&
'
a
C
args
:
&
'
a
GetCallerFrameArgs
<
'
a
P
>
callee_forwarded_regs
:
R
)
-
>
Option
<
Self
>
where
R
:
Fn
(
&
MinidumpContextValidity
)
-
>
HashSet
<
&
'
static
str
>
{
let
module
=
args
.
modules
.
module_at_address
(
args
.
callee_frame
.
instruction
)
?
;
let
grand_callee
=
args
.
grand_callee_frame
;
Some
(
Self
{
instruction
:
args
.
callee_frame
.
instruction
has_grand_callee
:
grand_callee
.
is_some
(
)
grand_callee_parameter_size
:
grand_callee
.
and_then
(
|
f
|
f
.
parameter_size
)
.
unwrap_or
(
0
)
callee_ctx
:
ctx
callee_validity
:
args
.
valid
(
)
caller_ctx
:
ctx
.
clone
(
)
caller_validity
:
callee_forwarded_regs
(
args
.
valid
(
)
)
module
stack_memory
:
args
.
stack_memory
}
)
}
}
impl
<
'
a
C
>
FrameWalker
for
CfiStackWalker
<
'
a
C
>
where
C
:
CpuContext
C
:
:
Register
:
TryFrom
<
u64
>
u64
:
TryFrom
<
C
:
:
Register
>
C
:
:
Register
:
TryFromCtx
<
'
a
Endian
[
u8
]
Error
=
scroll
:
:
Error
>
+
SizeWith
<
Endian
>
{
fn
get_instruction
(
&
self
)
-
>
u64
{
self
.
instruction
}
fn
has_grand_callee
(
&
self
)
-
>
bool
{
self
.
has_grand_callee
}
fn
get_grand_callee_parameter_size
(
&
self
)
-
>
u32
{
self
.
grand_callee_parameter_size
}
fn
get_register_at_address
(
&
self
address
:
u64
)
-
>
Option
<
u64
>
{
let
result
:
Option
<
C
:
:
Register
>
=
self
.
stack_memory
.
get_memory_at_address
(
address
)
;
result
.
and_then
(
|
val
|
u64
:
:
try_from
(
val
)
.
ok
(
)
)
}
fn
get_callee_register
(
&
self
name
:
&
str
)
-
>
Option
<
u64
>
{
self
.
callee_ctx
.
get_register
(
name
self
.
callee_validity
)
.
and_then
(
|
val
|
u64
:
:
try_from
(
val
)
.
ok
(
)
)
}
fn
set_caller_register
(
&
mut
self
name
:
&
str
val
:
u64
)
-
>
Option
<
(
)
>
{
let
memoized
=
self
.
caller_ctx
.
memoize_register
(
name
)
?
;
let
val
=
C
:
:
Register
:
:
try_from
(
val
)
.
ok
(
)
?
;
self
.
caller_validity
.
insert
(
memoized
)
;
self
.
caller_ctx
.
set_register
(
name
val
)
}
fn
clear_caller_register
(
&
mut
self
name
:
&
str
)
{
self
.
caller_validity
.
remove
(
name
)
;
}
fn
set_cfa
(
&
mut
self
val
:
u64
)
-
>
Option
<
(
)
>
{
let
stack_pointer_reg
=
self
.
caller_ctx
.
stack_pointer_register_name
(
)
;
let
val
=
C
:
:
Register
:
:
try_from
(
val
)
.
ok
(
)
?
;
self
.
caller_validity
.
insert
(
stack_pointer_reg
)
;
self
.
caller_ctx
.
set_register
(
stack_pointer_reg
val
)
}
fn
set_ra
(
&
mut
self
val
:
u64
)
-
>
Option
<
(
)
>
{
let
instruction_pointer_reg
=
self
.
caller_ctx
.
instruction_pointer_register_name
(
)
;
let
val
=
C
:
:
Register
:
:
try_from
(
val
)
.
ok
(
)
?
;
self
.
caller_validity
.
insert
(
instruction_pointer_reg
)
;
self
.
caller_ctx
.
set_register
(
instruction_pointer_reg
val
)
}
}
#
[
tracing
:
:
instrument
(
name
=
"
unwind_frame
"
level
=
"
trace
"
skip_all
fields
(
idx
=
_frame_idx
fname
=
args
.
callee_frame
.
function_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
)
)
]
async
fn
get_caller_frame
<
P
>
(
_frame_idx
:
usize
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
match
args
.
callee_frame
.
context
.
raw
{
MinidumpRawContext
:
:
Arm
(
ref
ctx
)
=
>
arm
:
:
get_caller_frame
(
ctx
args
)
.
await
MinidumpRawContext
:
:
Arm64
(
ref
ctx
)
=
>
arm64
:
:
get_caller_frame
(
ctx
args
)
.
await
MinidumpRawContext
:
:
OldArm64
(
ref
ctx
)
=
>
arm64_old
:
:
get_caller_frame
(
ctx
args
)
.
await
MinidumpRawContext
:
:
Amd64
(
ref
ctx
)
=
>
amd64
:
:
get_caller_frame
(
ctx
args
)
.
await
MinidumpRawContext
:
:
X86
(
ref
ctx
)
=
>
x86
:
:
get_caller_frame
(
ctx
args
)
.
await
MinidumpRawContext
:
:
Mips
(
ref
ctx
)
=
>
mips
:
:
get_caller_frame
(
ctx
args
)
.
await
_
=
>
None
}
}
async
fn
fill_source_line_info
<
P
>
(
frame
:
&
mut
StackFrame
modules
:
&
MinidumpModuleList
symbol_provider
:
&
P
)
where
P
:
SymbolProvider
+
Sync
{
if
let
Some
(
module
)
=
modules
.
module_at_address
(
frame
.
instruction
)
{
frame
.
module
=
Some
(
module
.
clone
(
)
)
;
let
_
=
symbol_provider
.
fill_symbol
(
module
frame
)
.
await
;
frame
.
inlines
.
reverse
(
)
;
}
}
pub
enum
OnWalkedFrame
<
'
a
>
{
None
#
[
allow
(
clippy
:
:
type_complexity
)
]
Some
(
Box
<
dyn
FnMut
(
usize
&
StackFrame
)
+
Send
+
'
a
>
)
}
impl
From
<
(
)
>
for
OnWalkedFrame
<
'
_
>
{
fn
from
(
_
:
(
)
)
-
>
Self
{
Self
:
:
None
}
}
impl
<
'
a
F
:
FnMut
(
usize
&
StackFrame
)
+
Send
+
'
a
>
From
<
F
>
for
OnWalkedFrame
<
'
a
>
{
fn
from
(
f
:
F
)
-
>
Self
{
Self
:
:
Some
(
Box
:
:
new
(
f
)
)
}
}
#
[
tracing
:
:
instrument
(
name
=
"
unwind_thread
"
level
=
"
trace
"
skip_all
fields
(
idx
=
_thread_idx
tid
=
stack
.
thread_id
tname
=
stack
.
thread_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
)
)
]
pub
async
fn
walk_stack
<
P
>
(
_thread_idx
:
usize
on_walked_frame
:
impl
Into
<
OnWalkedFrame
<
'
_
>
>
stack
:
&
mut
CallStack
stack_memory
:
Option
<
UnifiedMemory
<
'
_
'
_
>
>
modules
:
&
MinidumpModuleList
system_info
:
&
SystemInfo
symbol_provider
:
&
P
)
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
starting
stack
unwind
of
thread
{
}
{
}
"
stack
.
thread_id
stack
.
thread_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
)
;
let
stack_memory
=
stack_memory
.
and_then
(
|
stack_memory
|
stack_memory
.
memory_range
(
)
.
map
(
|
_
|
stack_memory
)
)
;
let
mut
has_new_frame
=
!
stack
.
frames
.
is_empty
(
)
;
let
mut
on_walked_frame
=
on_walked_frame
.
into
(
)
;
while
has_new_frame
{
let
frame_idx
=
stack
.
frames
.
len
(
)
-
1
;
let
frame
=
stack
.
frames
.
last_mut
(
)
.
unwrap
(
)
;
fill_source_line_info
(
frame
modules
symbol_provider
)
.
await
;
if
let
OnWalkedFrame
:
:
Some
(
on_walked_frame
)
=
&
mut
on_walked_frame
{
on_walked_frame
(
frame_idx
frame
)
;
}
let
Some
(
stack_memory
)
=
stack_memory
else
{
break
;
}
;
let
callee_frame
=
&
stack
.
frames
.
last
(
)
.
unwrap
(
)
;
let
grand_callee_frame
=
stack
.
frames
.
len
(
)
.
checked_sub
(
2
)
.
and_then
(
|
idx
|
stack
.
frames
.
get
(
idx
)
)
;
match
callee_frame
.
function_name
.
as_ref
(
)
{
Some
(
name
)
=
>
trace
!
(
"
unwinding
{
}
"
name
)
None
=
>
trace
!
(
"
unwinding
0x
{
:
016x
}
"
callee_frame
.
instruction
)
}
let
new_frame
=
get_caller_frame
(
frame_idx
&
GetCallerFrameArgs
{
callee_frame
grand_callee_frame
stack_memory
modules
system_info
symbol_provider
}
)
.
await
;
if
let
Some
(
new_frame
)
=
new_frame
{
stack
.
frames
.
push
(
new_frame
)
;
}
else
{
has_new_frame
=
false
;
}
}
trace
!
(
"
finished
stack
unwind
of
thread
{
}
{
}
\
n
"
stack
.
thread_id
stack
.
thread_name
.
as_deref
(
)
.
unwrap_or
(
"
"
)
)
;
}
async
fn
instruction_seems_valid_by_symbols
<
P
>
(
instruction
:
u64
modules
:
&
MinidumpModuleList
symbol_provider
:
&
P
)
-
>
bool
where
P
:
SymbolProvider
+
Sync
{
let
instruction
=
instruction
.
saturating_sub
(
1
)
;
if
instruction
=
=
0
{
return
false
;
}
if
let
Some
(
module
)
=
modules
.
module_at_address
(
instruction
)
{
struct
DummyFrame
{
instruction
:
u64
has_name
:
bool
}
impl
FrameSymbolizer
for
DummyFrame
{
fn
get_instruction
(
&
self
)
-
>
u64
{
self
.
instruction
}
fn
set_function
(
&
mut
self
name
:
&
str
_base
:
u64
_parameter_size
:
u32
)
{
self
.
has_name
=
!
name
.
is_empty
(
)
;
}
fn
set_source_file
(
&
mut
self
_file
:
&
str
_line
:
u32
_base
:
u64
)
{
}
}
let
mut
frame
=
DummyFrame
{
instruction
has_name
:
false
}
;
if
symbol_provider
.
fill_symbol
(
module
&
mut
frame
)
.
await
.
is_ok
(
)
{
frame
.
has_name
}
else
{
true
}
}
else
{
false
}
}
#
[
cfg
(
test
)
]
mod
amd64_unittest
;
#
[
cfg
(
test
)
]
mod
arm64_unittest
;
#
[
cfg
(
test
)
]
mod
arm_unittest
;
#
[
cfg
(
test
)
]
mod
x86_unittest
;
