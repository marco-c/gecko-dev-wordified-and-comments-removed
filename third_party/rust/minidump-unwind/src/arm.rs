use
super
:
:
impl_prelude
:
:
*
;
use
minidump
:
:
system_info
:
:
Os
;
use
minidump
:
:
{
CpuContext
MinidumpContext
MinidumpContextValidity
MinidumpModuleList
MinidumpRawContext
}
;
use
std
:
:
collections
:
:
HashSet
;
use
tracing
:
:
trace
;
type
ArmContext
=
minidump
:
:
format
:
:
CONTEXT_ARM
;
type
Pointer
=
<
ArmContext
as
CpuContext
>
:
:
Register
;
type
Registers
=
minidump
:
:
format
:
:
ArmRegisterNumbers
;
const
POINTER_WIDTH
:
Pointer
=
std
:
:
mem
:
:
size_of
:
:
<
Pointer
>
(
)
as
Pointer
;
const
FRAME_POINTER
:
&
str
=
Registers
:
:
FramePointer
.
name
(
)
;
const
STACK_POINTER
:
&
str
=
Registers
:
:
StackPointer
.
name
(
)
;
const
PROGRAM_COUNTER
:
&
str
=
Registers
:
:
ProgramCounter
.
name
(
)
;
const
_LINK_REGISTER
:
&
str
=
Registers
:
:
LinkRegister
.
name
(
)
;
const
CALLEE_SAVED_REGS
:
&
[
&
str
]
=
&
[
"
r4
"
"
r5
"
"
r6
"
"
r7
"
"
r8
"
"
r9
"
"
r10
"
"
fp
"
]
;
async
fn
get_caller_by_cfi
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
cfi
"
)
;
let
_last_sp
=
ctx
.
get_register
(
STACK_POINTER
args
.
valid
(
)
)
?
;
let
mut
stack_walker
=
CfiStackWalker
:
:
from_ctx_and_args
(
ctx
args
callee_forwarded_regs
)
?
;
args
.
symbol_provider
.
walk_frame
(
stack_walker
.
module
&
mut
stack_walker
)
.
await
?
;
let
caller_pc
=
stack_walker
.
caller_ctx
.
get_register_always
(
PROGRAM_COUNTER
)
;
let
caller_sp
=
stack_walker
.
caller_ctx
.
get_register_always
(
STACK_POINTER
)
;
trace
!
(
"
cfi
evaluation
was
successful
-
-
caller_pc
:
0x
{
:
016x
}
caller_sp
:
0x
{
:
016x
}
"
caller_pc
caller_sp
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Arm
(
stack_walker
.
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
stack_walker
.
caller_validity
)
}
;
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
CallFrameInfo
)
)
}
fn
callee_forwarded_regs
(
valid
:
&
MinidumpContextValidity
)
-
>
HashSet
<
&
'
static
str
>
{
match
valid
{
MinidumpContextValidity
:
:
All
=
>
CALLEE_SAVED_REGS
.
iter
(
)
.
copied
(
)
.
collect
(
)
MinidumpContextValidity
:
:
Some
(
ref
which
)
=
>
CALLEE_SAVED_REGS
.
iter
(
)
.
filter
(
|
&
reg
|
which
.
contains
(
reg
)
)
.
copied
(
)
.
collect
(
)
}
}
fn
get_caller_by_frame_pointer
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
if
args
.
system_info
.
os
!
=
Os
:
:
Ios
{
return
None
;
}
trace
!
(
"
trying
frame
pointer
"
)
;
let
last_fp
=
ctx
.
get_register
(
FRAME_POINTER
args
.
valid
(
)
)
?
;
let
last_sp
=
ctx
.
get_register
(
STACK_POINTER
args
.
valid
(
)
)
?
;
if
last_fp
>
=
u32
:
:
MAX
-
POINTER_WIDTH
*
2
{
return
None
;
}
let
(
caller_fp
caller_pc
caller_sp
)
=
if
last_fp
=
=
0
{
(
0
0
last_sp
)
}
else
{
(
args
.
stack_memory
.
get_memory_at_address
(
last_fp
as
u64
)
?
args
.
stack_memory
.
get_memory_at_address
(
last_fp
as
u64
+
POINTER_WIDTH
as
u64
)
?
last_fp
+
POINTER_WIDTH
*
2
)
}
;
trace
!
(
"
frame
pointer
seems
valid
-
-
caller_pc
:
0x
{
:
016x
}
caller_sp
:
0x
{
:
016x
}
"
caller_pc
caller_sp
)
;
let
mut
caller_ctx
=
ArmContext
:
:
default
(
)
;
caller_ctx
.
set_register
(
PROGRAM_COUNTER
caller_pc
)
;
caller_ctx
.
set_register
(
FRAME_POINTER
caller_fp
)
;
caller_ctx
.
set_register
(
STACK_POINTER
caller_sp
)
;
let
mut
valid
=
HashSet
:
:
new
(
)
;
valid
.
insert
(
PROGRAM_COUNTER
)
;
valid
.
insert
(
FRAME_POINTER
)
;
valid
.
insert
(
STACK_POINTER
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Arm
(
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
valid
)
}
;
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
FramePointer
)
)
}
async
fn
get_caller_by_scan
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
trace
!
(
"
trying
scan
"
)
;
let
last_sp
=
ctx
.
get_register
(
STACK_POINTER
args
.
valid
(
)
)
?
;
let
default_scan_range
=
40
;
let
extended_scan_range
=
default_scan_range
*
4
;
let
scan_range
=
if
let
FrameTrust
:
:
Context
=
args
.
callee_frame
.
trust
{
extended_scan_range
}
else
{
default_scan_range
}
;
for
i
in
0
.
.
scan_range
{
let
address_of_pc
=
last_sp
.
checked_add
(
i
*
POINTER_WIDTH
)
?
;
let
caller_pc
=
args
.
stack_memory
.
get_memory_at_address
(
address_of_pc
as
u64
)
?
;
if
instruction_seems_valid
(
caller_pc
args
.
modules
args
.
symbol_provider
)
.
await
{
let
caller_sp
=
address_of_pc
.
checked_add
(
POINTER_WIDTH
)
?
;
trace
!
(
"
scan
seems
valid
-
-
caller_pc
:
0x
{
:
08x
}
caller_sp
:
0x
{
:
08x
}
"
caller_pc
caller_sp
)
;
let
mut
caller_ctx
=
ArmContext
:
:
default
(
)
;
caller_ctx
.
set_register
(
PROGRAM_COUNTER
caller_pc
)
;
caller_ctx
.
set_register
(
STACK_POINTER
caller_sp
)
;
let
mut
valid
=
HashSet
:
:
new
(
)
;
valid
.
insert
(
PROGRAM_COUNTER
)
;
valid
.
insert
(
STACK_POINTER
)
;
let
context
=
MinidumpContext
{
raw
:
MinidumpRawContext
:
:
Arm
(
caller_ctx
)
valid
:
MinidumpContextValidity
:
:
Some
(
valid
)
}
;
return
Some
(
StackFrame
:
:
from_context
(
context
FrameTrust
:
:
Scan
)
)
;
}
}
None
}
async
fn
instruction_seems_valid
<
P
>
(
instruction
:
Pointer
modules
:
&
MinidumpModuleList
symbol_provider
:
&
P
)
-
>
bool
where
P
:
SymbolProvider
+
Sync
{
super
:
:
instruction_seems_valid_by_symbols
(
instruction
as
u64
modules
symbol_provider
)
.
await
}
pub
async
fn
get_caller_frame
<
P
>
(
ctx
:
&
ArmContext
args
:
&
GetCallerFrameArgs
<
'
_
P
>
)
-
>
Option
<
StackFrame
>
where
P
:
SymbolProvider
+
Sync
{
let
mut
frame
=
None
;
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_cfi
(
ctx
args
)
.
await
;
}
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_frame_pointer
(
ctx
args
)
;
}
if
frame
.
is_none
(
)
{
frame
=
get_caller_by_scan
(
ctx
args
)
.
await
;
}
let
mut
frame
=
frame
?
;
if
frame
.
context
.
get_instruction_pointer
(
)
<
4096
{
trace
!
(
"
instruction
pointer
was
nullish
assuming
unwind
complete
"
)
;
return
None
;
}
let
sp
=
frame
.
context
.
get_stack_pointer
(
)
;
let
last_sp
=
ctx
.
get_register_always
(
"
sp
"
)
as
u64
;
if
sp
<
=
last_sp
{
let
is_leaf
=
args
.
callee_frame
.
trust
=
=
FrameTrust
:
:
Context
&
&
sp
=
=
last_sp
;
if
!
is_leaf
{
trace
!
(
"
stack
pointer
went
backwards
assuming
unwind
complete
"
)
;
return
None
;
}
}
let
ip
=
frame
.
context
.
get_instruction_pointer
(
)
;
frame
.
instruction
=
ip
-
2
;
Some
(
frame
)
}
