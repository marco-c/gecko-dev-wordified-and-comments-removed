#
!
[
allow
(
dead_code
)
]
use
expect_test
:
:
expect
;
use
serde_with_macros
:
:
apply
;
use
std
:
:
collections
:
:
BTreeMap
;
#
[
test
]
fn
test_apply_fully_specified
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
Option
<
String
>
=
>
#
[
serde
(
skip
)
]
BTreeMap
<
String
String
>
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
b
"
:
null
"
d
"
:
{
}
"
e
"
:
{
}
"
f
"
:
"
"
"
g
"
:
"
"
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_apply_all
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
_
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_apply_partial_no_generic
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
Option
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
c
"
:
{
}
"
d
"
:
{
}
"
e
"
:
{
}
"
f
"
:
"
"
"
g
"
:
"
"
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_apply_partial_generic
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
BTreeMap
<
String
_
>
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
a
"
:
null
"
b
"
:
null
"
e
"
:
{
}
"
f
"
:
"
"
"
g
"
:
"
"
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_apply_no_lifetime
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
&
str
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
a
"
:
null
"
b
"
:
null
"
c
"
:
{
}
"
d
"
:
{
}
"
e
"
:
{
}
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_apply_lifetime
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
&
'
a
mut
str
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
a
"
:
null
"
b
"
:
null
"
c
"
:
{
}
"
d
"
:
{
}
"
e
"
:
{
}
"
g
"
:
"
"
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
test_apply_mismatched_lifetime
(
)
{
#
[
apply
(
crate
=
"
serde_with_macros
"
&
'
b
str
=
>
#
[
serde
(
skip
)
]
)
]
#
[
derive
(
Default
serde
:
:
Serialize
)
]
struct
FooBar
<
'
a
>
{
a
:
Option
<
String
>
b
:
Option
<
i32
>
c
:
BTreeMap
<
String
String
>
d
:
BTreeMap
<
String
i32
>
e
:
BTreeMap
<
i32
String
>
f
:
&
'
a
str
g
:
&
'
static
str
#
[
serde_with
(
skip_apply
)
]
skip
:
Option
<
String
>
}
expect
!
[
[
r
#
"
{
"
a
"
:
null
"
b
"
:
null
"
c
"
:
{
}
"
d
"
:
{
}
"
e
"
:
{
}
"
f
"
:
"
"
"
g
"
:
"
"
"
skip
"
:
null
}
"
#
]
]
.
assert_eq
(
&
serde_json
:
:
to_string_pretty
(
&
FooBar
:
:
<
'
static
>
:
:
default
(
)
)
.
unwrap
(
)
)
;
}
