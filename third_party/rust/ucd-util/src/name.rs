pub
fn
character_name_normalize
(
string
:
&
mut
String
)
{
let
bytes
=
unsafe
{
string
.
as_mut_vec
(
)
}
;
let
len
=
character_name_normalize_bytes
(
bytes
)
.
len
(
)
;
bytes
.
truncate
(
len
)
;
}
fn
character_name_normalize_bytes
(
slice
:
&
mut
[
u8
]
)
-
>
&
mut
[
u8
]
{
let
mut
next_write
=
0
;
let
mut
prev_space
=
true
;
for
i
in
0
.
.
slice
.
len
(
)
{
let
b
=
slice
[
i
]
;
if
b
=
=
b
'
'
{
prev_space
=
true
;
continue
;
}
else
if
b
=
=
b
'
_
'
{
}
else
if
b
=
=
b
'
-
'
{
let
mut
keep_hyphen
=
prev_space
|
|
slice
.
get
(
i
+
1
)
=
=
Some
(
&
b
'
'
)
;
let
rest_e
=
slice
[
i
+
1
.
.
]
=
=
b
"
E
"
[
.
.
]
|
|
slice
[
i
+
1
.
.
]
=
=
b
"
e
"
[
.
.
]
;
if
!
keep_hyphen
&
&
rest_e
{
keep_hyphen
=
slice
[
.
.
next_write
]
=
=
b
"
hanguljungseongo
"
[
.
.
]
;
}
if
keep_hyphen
{
slice
[
next_write
]
=
b
;
next_write
+
=
1
;
}
}
else
if
b
'
A
'
<
=
b
&
&
b
<
=
b
'
Z
'
{
slice
[
next_write
]
=
b
+
(
b
'
a
'
-
b
'
A
'
)
;
next_write
+
=
1
;
}
else
if
b
<
=
0x7F
{
slice
[
next_write
]
=
b
;
next_write
+
=
1
;
}
prev_space
=
false
;
}
&
mut
slice
[
.
.
next_write
]
}
pub
fn
symbolic_name_normalize
(
string
:
&
mut
String
)
{
let
bytes
=
unsafe
{
string
.
as_mut_vec
(
)
}
;
let
len
=
symbolic_name_normalize_bytes
(
bytes
)
.
len
(
)
;
bytes
.
truncate
(
len
)
;
}
fn
symbolic_name_normalize_bytes
(
slice
:
&
mut
[
u8
]
)
-
>
&
mut
[
u8
]
{
let
mut
start
=
0
;
if
slice
.
len
(
)
>
=
2
{
let
starts_with_is
=
slice
[
0
.
.
2
]
=
=
b
"
is
"
[
.
.
]
|
|
slice
[
0
.
.
2
]
=
=
b
"
IS
"
[
.
.
]
|
|
slice
[
0
.
.
2
]
=
=
b
"
iS
"
[
.
.
]
|
|
slice
[
0
.
.
2
]
=
=
b
"
Is
"
[
.
.
]
;
if
starts_with_is
{
start
=
2
;
}
}
let
mut
next_write
=
0
;
for
i
in
start
.
.
slice
.
len
(
)
{
let
b
=
slice
[
i
]
;
if
b
=
=
b
'
'
|
|
b
=
=
b
'
_
'
|
|
b
=
=
b
'
-
'
{
continue
;
}
else
if
b
'
A
'
<
=
b
&
&
b
<
=
b
'
Z
'
{
slice
[
next_write
]
=
b
+
(
b
'
a
'
-
b
'
A
'
)
;
next_write
+
=
1
;
}
else
if
b
<
=
0x7F
{
slice
[
next_write
]
=
b
;
next_write
+
=
1
;
}
}
&
mut
slice
[
.
.
next_write
]
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
character_name_normalize
character_name_normalize_bytes
symbolic_name_normalize
symbolic_name_normalize_bytes
}
;
fn
char_norm
(
s
:
&
str
)
-
>
String
{
let
mut
s
=
s
.
to_string
(
)
;
character_name_normalize
(
&
mut
s
)
;
s
}
fn
sym_norm
(
s
:
&
str
)
-
>
String
{
let
mut
s
=
s
.
to_string
(
)
;
symbolic_name_normalize
(
&
mut
s
)
;
s
}
#
[
test
]
fn
char_normalize
(
)
{
assert_eq
!
(
char_norm
(
"
HANGUL
JUNGSEONG
O
-
E
"
)
"
hanguljungseongo
-
e
"
)
;
assert_eq
!
(
char_norm
(
"
zero
-
width
space
"
)
"
zerowidthspace
"
)
;
assert_eq
!
(
char_norm
(
"
zerowidthspace
"
)
"
zerowidthspace
"
)
;
assert_eq
!
(
char_norm
(
"
ZERO
WIDTH
SPACE
"
)
"
zerowidthspace
"
)
;
assert_eq
!
(
char_norm
(
"
TIBETAN
MARK
TSA
-
PHRU
"
)
"
tibetanmarktsa
-
phru
"
)
;
}
#
[
test
]
fn
sym_normalize
(
)
{
assert_eq
!
(
sym_norm
(
"
Line_Break
"
)
"
linebreak
"
)
;
assert_eq
!
(
sym_norm
(
"
Line
-
break
"
)
"
linebreak
"
)
;
assert_eq
!
(
sym_norm
(
"
linebreak
"
)
"
linebreak
"
)
;
assert_eq
!
(
sym_norm
(
"
BA
"
)
"
ba
"
)
;
assert_eq
!
(
sym_norm
(
"
ba
"
)
"
ba
"
)
;
assert_eq
!
(
sym_norm
(
"
Greek
"
)
"
greek
"
)
;
assert_eq
!
(
sym_norm
(
"
isGreek
"
)
"
greek
"
)
;
assert_eq
!
(
sym_norm
(
"
IS_Greek
"
)
"
greek
"
)
;
}
#
[
test
]
fn
valid_utf8_character
(
)
{
let
mut
x
=
b
"
abc
\
xFFxyz
"
.
to_vec
(
)
;
let
y
=
character_name_normalize_bytes
(
&
mut
x
)
;
assert_eq
!
(
y
b
"
abcxyz
"
)
;
}
#
[
test
]
fn
valid_utf8_symbolic
(
)
{
let
mut
x
=
b
"
abc
\
xFFxyz
"
.
to_vec
(
)
;
let
y
=
symbolic_name_normalize_bytes
(
&
mut
x
)
;
assert_eq
!
(
y
b
"
abcxyz
"
)
;
}
}
