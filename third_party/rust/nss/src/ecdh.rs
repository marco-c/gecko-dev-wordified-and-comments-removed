use
crate
:
:
{
ec
:
:
{
PrivateKey
PublicKey
}
error
:
:
*
pk11
:
:
types
:
:
SymKey
util
:
:
{
ensure_nss_initialized
map_nss_secstatus
sec_item_as_slice
ScopedPtr
}
}
;
pub
fn
ecdh_agreement
(
priv_key
:
&
PrivateKey
pub_key
:
&
PublicKey
)
-
>
Result
<
Vec
<
u8
>
>
{
ensure_nss_initialized
(
)
;
if
priv_key
.
curve
(
)
!
=
pub_key
.
curve
(
)
{
return
Err
(
ErrorKind
:
:
InternalError
.
into
(
)
)
;
}
let
sym_key
=
unsafe
{
SymKey
:
:
from_ptr
(
nss_sys
:
:
PK11_PubDeriveWithKDF
(
priv_key
.
as_mut_ptr
(
)
pub_key
.
as_mut_ptr
(
)
nss_sys
:
:
PR_FALSE
std
:
:
ptr
:
:
null_mut
(
)
std
:
:
ptr
:
:
null_mut
(
)
nss_sys
:
:
CKM_ECDH1_DERIVE
.
into
(
)
nss_sys
:
:
CKM_SHA512_HMAC
.
into
(
)
nss_sys
:
:
CKA_SIGN
.
into
(
)
0
nss_sys
:
:
CKD_NULL
.
into
(
)
std
:
:
ptr
:
:
null_mut
(
)
std
:
:
ptr
:
:
null_mut
(
)
)
)
?
}
;
map_nss_secstatus
(
|
|
unsafe
{
nss_sys
:
:
PK11_ExtractKeyValue
(
sym_key
.
as_mut_ptr
(
)
)
}
)
?
;
let
mut
key_data
=
unsafe
{
*
nss_sys
:
:
PK11_GetKeyData
(
sym_key
.
as_mut_ptr
(
)
)
}
;
let
buf
=
unsafe
{
sec_item_as_slice
(
&
mut
key_data
)
?
}
;
Ok
(
buf
.
to_vec
(
)
)
}
