use
std
:
:
io
:
:
Write
;
use
std
:
:
io
;
use
deflate_state
:
:
DeflateState
;
use
encoder_state
:
:
EncoderState
;
use
lzvalue
:
:
LZValue
;
use
lz77
:
:
{
lz77_compress_block
LZ77Status
}
;
use
huffman_lengths
:
:
{
gen_huffman_lengths
write_huffman_lengths
BlockType
}
;
use
bitstream
:
:
LsbWriter
;
use
stored_block
:
:
{
compress_block_stored
write_stored_header
MAX_STORED_BLOCK_LENGTH
}
;
const
LARGEST_OUTPUT_BUF_SIZE
:
usize
=
1024
*
32
;
#
[
derive
(
Eq
PartialEq
Debug
Copy
Clone
)
]
pub
enum
Flush
{
None
Sync
_Partial
_Block
_Full
Finish
}
pub
fn
flush_to_bitstream
(
buffer
:
&
[
LZValue
]
state
:
&
mut
EncoderState
)
{
for
&
b
in
buffer
{
state
.
write_lzvalue
(
b
.
value
(
)
)
;
}
state
.
write_end_of_block
(
)
}
#
[
cfg
(
test
)
]
pub
fn
compress_data_fixed
(
input
:
&
[
u8
]
)
-
>
Vec
<
u8
>
{
use
lz77
:
:
lz77_compress
;
let
mut
state
=
EncoderState
:
:
fixed
(
Vec
:
:
new
(
)
)
;
let
compressed
=
lz77_compress
(
input
)
.
unwrap
(
)
;
state
.
write_start_of_block
(
true
true
)
;
flush_to_bitstream
(
&
compressed
&
mut
state
)
;
state
.
flush
(
)
;
state
.
reset
(
Vec
:
:
new
(
)
)
}
fn
write_stored_block
(
input
:
&
[
u8
]
mut
writer
:
&
mut
LsbWriter
final_block
:
bool
)
{
if
!
input
.
is_empty
(
)
{
let
mut
i
=
input
.
chunks
(
MAX_STORED_BLOCK_LENGTH
)
.
peekable
(
)
;
while
let
Some
(
chunk
)
=
i
.
next
(
)
{
let
last_chunk
=
i
.
peek
(
)
.
is_none
(
)
;
write_stored_header
(
writer
final_block
&
&
last_chunk
)
;
compress_block_stored
(
chunk
&
mut
writer
)
.
expect
(
"
Write
error
"
)
;
}
}
else
{
write_stored_header
(
writer
final_block
)
;
compress_block_stored
(
&
[
]
&
mut
writer
)
.
expect
(
"
Write
error
"
)
;
}
}
pub
fn
compress_data_dynamic_n
<
W
:
Write
>
(
input
:
&
[
u8
]
deflate_state
:
&
mut
DeflateState
<
W
>
flush
:
Flush
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
bytes_written
=
0
;
let
mut
slice
=
input
;
loop
{
let
output_buf_len
=
deflate_state
.
output_buf
(
)
.
len
(
)
;
let
output_buf_pos
=
deflate_state
.
output_buf_pos
;
if
output_buf_len
>
LARGEST_OUTPUT_BUF_SIZE
{
let
written
=
deflate_state
.
inner
.
as_mut
(
)
.
expect
(
"
Missing
writer
!
"
)
.
write
(
&
deflate_state
.
encoder_state
.
inner_vec
(
)
[
output_buf_pos
.
.
]
)
?
;
if
written
<
output_buf_len
.
checked_sub
(
output_buf_pos
)
.
unwrap
(
)
{
deflate_state
.
output_buf_pos
+
=
written
;
}
else
{
deflate_state
.
output_buf_pos
=
0
;
deflate_state
.
output_buf
(
)
.
clear
(
)
;
}
if
bytes_written
=
=
0
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Interrupted
"
Internal
buffer
full
.
"
)
)
;
}
else
{
return
Ok
(
bytes_written
)
;
}
}
if
deflate_state
.
lz77_state
.
is_last_block
(
)
{
break
;
}
let
(
written
status
position
)
=
lz77_compress_block
(
slice
&
mut
deflate_state
.
lz77_state
&
mut
deflate_state
.
input_buffer
&
mut
deflate_state
.
lz77_writer
flush
)
;
bytes_written
+
=
written
;
deflate_state
.
bytes_written
+
=
written
as
u64
;
if
status
=
=
LZ77Status
:
:
NeedInput
{
return
Ok
(
bytes_written
)
;
}
slice
=
&
slice
[
written
.
.
]
;
let
last_block
=
deflate_state
.
lz77_state
.
is_last_block
(
)
;
let
current_block_input_bytes
=
deflate_state
.
lz77_state
.
current_block_input_bytes
(
)
;
if
cfg
!
(
debug_assertions
)
{
deflate_state
.
bytes_written_control
.
add
(
current_block_input_bytes
)
;
}
let
partial_bits
=
deflate_state
.
encoder_state
.
writer
.
pending_bits
(
)
;
let
res
=
{
let
(
l_freqs
d_freqs
)
=
deflate_state
.
lz77_writer
.
get_frequencies
(
)
;
let
(
l_lengths
d_lengths
)
=
deflate_state
.
encoder_state
.
huffman_table
.
get_lengths_mut
(
)
;
gen_huffman_lengths
(
l_freqs
d_freqs
current_block_input_bytes
partial_bits
l_lengths
d_lengths
&
mut
deflate_state
.
length_buffers
)
}
;
match
res
{
BlockType
:
:
Dynamic
(
header
)
=
>
{
deflate_state
.
encoder_state
.
write_start_of_block
(
false
last_block
)
;
write_huffman_lengths
(
&
header
&
deflate_state
.
encoder_state
.
huffman_table
&
mut
deflate_state
.
length_buffers
.
length_buf
&
mut
deflate_state
.
encoder_state
.
writer
)
;
deflate_state
.
encoder_state
.
huffman_table
.
update_from_lengths
(
)
;
flush_to_bitstream
(
deflate_state
.
lz77_writer
.
get_buffer
(
)
&
mut
deflate_state
.
encoder_state
)
;
}
BlockType
:
:
Fixed
=
>
{
deflate_state
.
encoder_state
.
write_start_of_block
(
true
last_block
)
;
deflate_state
.
encoder_state
.
set_huffman_to_fixed
(
)
;
flush_to_bitstream
(
deflate_state
.
lz77_writer
.
get_buffer
(
)
&
mut
deflate_state
.
encoder_state
)
;
}
BlockType
:
:
Stored
=
>
{
let
start_pos
=
position
.
saturating_sub
(
current_block_input_bytes
as
usize
)
;
assert
!
(
position
>
=
current_block_input_bytes
as
usize
"
Error
!
Trying
to
output
a
stored
block
with
forgotten
data
!
\
if
you
encounter
this
error
please
file
an
issue
!
"
)
;
write_stored_block
(
&
deflate_state
.
input_buffer
.
get_buffer
(
)
[
start_pos
.
.
position
]
&
mut
deflate_state
.
encoder_state
.
writer
flush
=
=
Flush
:
:
Finish
&
&
last_block
)
;
}
}
;
deflate_state
.
lz77_writer
.
clear
(
)
;
deflate_state
.
lz77_state
.
reset_input_bytes
(
)
;
if
status
=
=
LZ77Status
:
:
Finished
{
if
flush
=
=
Flush
:
:
Sync
{
write_stored_block
(
&
[
]
&
mut
deflate_state
.
encoder_state
.
writer
false
)
;
}
else
if
!
deflate_state
.
lz77_state
.
is_last_block
(
)
{
let
es
=
&
mut
deflate_state
.
encoder_state
;
es
.
set_huffman_to_fixed
(
)
;
es
.
write_start_of_block
(
true
true
)
;
es
.
write_end_of_block
(
)
;
}
break
;
}
}
deflate_state
.
encoder_state
.
flush
(
)
;
let
output_buf_pos
=
deflate_state
.
output_buf_pos
;
let
written_to_writer
=
deflate_state
.
inner
.
as_mut
(
)
.
expect
(
"
Missing
writer
!
"
)
.
write
(
&
deflate_state
.
encoder_state
.
inner_vec
(
)
[
output_buf_pos
.
.
]
)
?
;
if
written_to_writer
<
deflate_state
.
output_buf
(
)
.
len
(
)
.
checked_sub
(
output_buf_pos
)
.
unwrap
(
)
{
deflate_state
.
output_buf_pos
+
=
written_to_writer
;
}
else
{
deflate_state
.
output_buf_pos
=
0
;
deflate_state
.
output_buf
(
)
.
clear
(
)
;
}
Ok
(
bytes_written
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
test_utils
:
:
{
get_test_data
decompress_to_end
}
;
#
[
test
]
fn
fixed_string_mem
(
)
{
let
test_data
=
String
:
:
from
(
"
GNU
GENERAL
PUBLIC
LICENSE
"
)
.
into_bytes
(
)
;
let
compressed
=
compress_data_fixed
(
&
test_data
)
;
let
result
=
decompress_to_end
(
&
compressed
)
;
assert_eq
!
(
test_data
result
)
;
}
#
[
test
]
fn
fixed_data
(
)
{
let
data
=
vec
!
[
190u8
;
400
]
;
let
compressed
=
compress_data_fixed
(
&
data
)
;
let
result
=
decompress_to_end
(
&
compressed
)
;
assert_eq
!
(
data
result
)
;
}
#
[
test
]
fn
fixed_example
(
)
{
let
test_data
=
b
"
Deflate
late
"
;
let
check
=
[
0x73
0x49
0x4d
0xcb
0x49
0x2c
0x49
0x55
0x00
0x11
0x00
]
;
let
compressed
=
compress_data_fixed
(
test_data
)
;
assert_eq
!
(
&
compressed
&
check
)
;
let
decompressed
=
decompress_to_end
(
&
compressed
)
;
assert_eq
!
(
&
decompressed
test_data
)
}
#
[
test
]
fn
fixed_string_file
(
)
{
let
input
=
get_test_data
(
)
;
let
compressed
=
compress_data_fixed
(
&
input
)
;
println
!
(
"
Fixed
codes
compressed
len
:
{
}
"
compressed
.
len
(
)
)
;
let
result
=
decompress_to_end
(
&
compressed
)
;
assert_eq
!
(
input
.
len
(
)
result
.
len
(
)
)
;
assert
!
(
input
=
=
result
)
;
}
}
