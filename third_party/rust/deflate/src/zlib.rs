use
std
:
:
io
:
:
{
Write
Result
}
;
const
DEFAULT_CM
:
u8
=
8
;
const
DEFAULT_CINFO
:
u8
=
7
<
<
4
;
const
DEFAULT_CMF
:
u8
=
DEFAULT_CM
|
DEFAULT_CINFO
;
#
[
cfg
(
test
)
]
const
DEFAULT_FDICT
:
u8
=
0
;
const
_DEFAULT_FLEVEL
:
u8
=
0
<
<
7
;
const
FCHECK_DIVISOR
:
u8
=
31
;
#
[
allow
(
dead_code
)
]
#
[
repr
(
u8
)
]
pub
enum
CompressionLevel
{
Fastest
=
0
<
<
6
Fast
=
1
<
<
6
Default
=
2
<
<
6
Maximum
=
3
<
<
6
}
fn
add_fcheck
(
cmf
:
u8
flg
:
u8
)
-
>
u8
{
let
rem
=
(
(
usize
:
:
from
(
cmf
)
*
256
)
+
usize
:
:
from
(
flg
)
)
%
usize
:
:
from
(
FCHECK_DIVISOR
)
;
let
flg
=
flg
&
0b11100000
;
flg
+
(
FCHECK_DIVISOR
-
rem
as
u8
)
}
pub
fn
write_zlib_header
<
W
:
Write
>
(
writer
:
&
mut
W
level
:
CompressionLevel
)
-
>
Result
<
(
)
>
{
writer
.
write_all
(
&
get_zlib_header
(
level
)
)
}
pub
fn
get_zlib_header
(
level
:
CompressionLevel
)
-
>
[
u8
;
2
]
{
let
cmf
=
DEFAULT_CMF
;
[
cmf
add_fcheck
(
cmf
level
as
u8
)
]
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
DEFAULT_CMF
;
use
super
:
:
*
;
#
[
test
]
fn
test_gen_fcheck
(
)
{
let
cmf
=
DEFAULT_CMF
;
let
flg
=
super
:
:
add_fcheck
(
DEFAULT_CMF
CompressionLevel
:
:
Default
as
u8
|
super
:
:
DEFAULT_FDICT
)
;
assert_eq
!
(
(
(
usize
:
:
from
(
cmf
)
*
256
)
+
usize
:
:
from
(
flg
)
)
%
31
0
)
;
}
#
[
test
]
fn
test_header
(
)
{
let
header
=
get_zlib_header
(
CompressionLevel
:
:
Fastest
)
;
assert_eq
!
(
(
(
usize
:
:
from
(
header
[
0
]
)
*
256
)
+
usize
:
:
from
(
header
[
1
]
)
)
%
31
0
)
;
}
}
