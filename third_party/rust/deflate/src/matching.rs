use
std
:
:
cmp
;
use
chained_hash_table
:
:
{
ChainedHashTable
WINDOW_SIZE
}
;
use
huffman_table
;
const
MAX_MATCH
:
usize
=
huffman_table
:
:
MAX_MATCH
as
usize
;
#
[
cfg
(
test
)
]
const
MIN_MATCH
:
usize
=
huffman_table
:
:
MIN_MATCH
as
usize
;
#
[
inline
]
pub
fn
get_match_length
(
data
:
&
[
u8
]
current_pos
:
usize
pos_to_check
:
usize
)
-
>
usize
{
data
[
current_pos
.
.
]
.
iter
(
)
.
zip
(
data
[
pos_to_check
.
.
]
.
iter
(
)
)
.
take
(
MAX_MATCH
)
.
take_while
(
|
&
(
&
a
&
b
)
|
a
=
=
b
)
.
count
(
)
}
pub
fn
longest_match
(
data
:
&
[
u8
]
hash_table
:
&
ChainedHashTable
position
:
usize
prev_length
:
usize
max_hash_checks
:
u16
)
-
>
(
usize
usize
)
{
if
prev_length
>
=
MAX_MATCH
|
|
position
+
prev_length
>
=
data
.
len
(
)
{
return
(
0
0
)
;
}
let
limit
=
if
position
>
WINDOW_SIZE
{
position
-
WINDOW_SIZE
}
else
{
0
}
;
let
prev_length
=
cmp
:
:
max
(
prev_length
1
)
;
let
max_length
=
cmp
:
:
min
(
data
.
len
(
)
-
position
MAX_MATCH
)
;
let
mut
current_head
=
position
;
let
mut
best_length
=
prev_length
;
let
mut
best_distance
=
0
;
let
mut
prev_head
;
for
_
in
0
.
.
max_hash_checks
{
prev_head
=
current_head
;
current_head
=
hash_table
.
get_prev
(
current_head
)
as
usize
;
if
current_head
>
=
prev_head
|
|
current_head
<
limit
{
break
;
}
if
data
[
position
+
best_length
-
1
.
.
position
+
best_length
+
1
]
=
=
data
[
current_head
+
best_length
-
1
.
.
current_head
+
best_length
+
1
]
{
let
length
=
get_match_length
(
data
position
current_head
)
;
if
length
>
best_length
{
best_length
=
length
;
best_distance
=
position
-
current_head
;
if
length
=
=
max_length
{
break
;
}
}
}
}
if
best_length
>
prev_length
{
(
best_length
best_distance
)
}
else
{
(
0
0
)
}
}
#
[
cfg
(
test
)
]
pub
fn
longest_match_fast
(
data
:
&
[
u8
]
hash_table
:
&
ChainedHashTable
position
:
usize
prev_length
:
usize
max_hash_checks
:
u16
)
-
>
(
usize
usize
)
{
if
prev_length
>
=
MAX_MATCH
|
|
position
+
prev_length
>
=
data
.
len
(
)
{
return
(
0
0
)
;
}
let
limit
=
if
position
>
WINDOW_SIZE
{
position
-
WINDOW_SIZE
}
else
{
0
}
;
let
prev_length
=
cmp
:
:
max
(
prev_length
1
)
;
let
max_length
=
cmp
:
:
min
(
(
data
.
len
(
)
-
position
)
MAX_MATCH
)
;
let
mut
current_head
=
position
;
let
mut
best_length
=
prev_length
;
let
mut
best_distance
=
0
;
let
mut
offset
=
0
;
let
mut
prev_head
;
for
_
in
0
.
.
max_hash_checks
{
prev_head
=
current_head
;
current_head
=
hash_table
.
get_prev
(
current_head
)
as
usize
;
if
current_head
>
=
prev_head
|
|
current_head
<
limit
+
offset
{
break
;
}
let
offset_head
=
current_head
-
offset
;
if
data
[
position
+
best_length
-
1
.
.
position
+
best_length
+
1
]
=
=
data
[
offset_head
+
best_length
-
1
.
.
offset_head
+
best_length
+
1
]
{
let
length
=
get_match_length
(
data
position
offset_head
)
;
if
length
>
best_length
{
best_length
=
length
;
best_distance
=
position
-
offset_head
;
if
length
=
=
max_length
{
break
;
}
if
best_distance
>
best_length
{
offset
=
hash_table
.
farthest_next
(
offset_head
length
)
;
current_head
=
offset_head
+
offset
;
}
}
}
}
if
best_length
>
prev_length
{
(
best_length
best_distance
)
}
else
{
(
0
0
)
}
}
#
[
inline
]
#
[
cfg
(
test
)
]
pub
fn
longest_match_current
(
data
:
&
[
u8
]
hash_table
:
&
ChainedHashTable
)
-
>
(
usize
usize
)
{
use
compression_options
:
:
MAX_HASH_CHECKS
;
longest_match
(
data
hash_table
hash_table
.
current_head
(
)
as
usize
MIN_MATCH
as
usize
-
1
MAX_HASH_CHECKS
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
chained_hash_table
:
:
{
filled_hash_table
HASH_BYTES
ChainedHashTable
}
;
use
super
:
:
{
get_match_length
longest_match
longest_match_fast
}
;
#
[
test
]
fn
match_length
(
)
{
let
test_arr
=
[
5u8
5
5
5
5
9
9
2
3
5
5
5
5
5
]
;
let
l
=
get_match_length
(
&
test_arr
9
0
)
;
assert_eq
!
(
l
5
)
;
let
l2
=
get_match_length
(
&
test_arr
9
7
)
;
assert_eq
!
(
l2
0
)
;
let
l3
=
get_match_length
(
&
test_arr
10
0
)
;
assert_eq
!
(
l3
4
)
;
}
#
[
test
]
fn
get_longest_match
(
)
{
let
test_data
=
b
"
xTest
data
Test_data
zTest
data
"
;
let
hash_table
=
filled_hash_table
(
&
test_data
[
.
.
23
+
1
+
HASH_BYTES
-
1
]
)
;
let
(
length
distance
)
=
super
:
:
longest_match_current
(
test_data
&
hash_table
)
;
assert_eq
!
(
distance
22
)
;
assert_eq
!
(
length
9
)
;
let
test_arr2
=
[
10u8
10
10
10
10
10
10
10
2
3
5
10
10
10
10
10
]
;
let
hash_table
=
filled_hash_table
(
&
test_arr2
[
.
.
HASH_BYTES
+
1
+
1
+
2
]
)
;
let
(
length
distance
)
=
super
:
:
longest_match_current
(
&
test_arr2
&
hash_table
)
;
assert_eq
!
(
distance
1
)
;
assert_eq
!
(
length
4
)
;
}
#
[
test
]
fn
match_index_zero
(
)
{
let
test_data
=
b
"
AAAAAAA
"
;
let
mut
hash_table
=
ChainedHashTable
:
:
from_starting_values
(
test_data
[
0
]
test_data
[
1
]
)
;
for
(
n
&
b
)
in
test_data
[
2
.
.
5
]
.
iter
(
)
.
enumerate
(
)
{
hash_table
.
add_hash_value
(
n
b
)
;
}
let
(
match_length
match_dist
)
=
longest_match
(
test_data
&
hash_table
1
0
4096
)
;
assert_eq
!
(
match_dist
1
)
;
assert
!
(
match_length
=
=
6
)
;
}
#
[
ignore
]
#
[
test
]
fn
fast_match_at_least_equal
(
)
{
use
test_utils
:
:
get_test_data
;
for
start_pos
in
10000
.
.
50000
{
const
NUM_CHECKS
:
u16
=
400
;
let
data
=
get_test_data
(
)
;
let
hash_table
=
filled_hash_table
(
&
data
[
.
.
start_pos
+
1
]
)
;
let
pos
=
hash_table
.
current_head
(
)
as
usize
;
let
naive_match
=
longest_match
(
&
data
[
.
.
]
&
hash_table
pos
0
NUM_CHECKS
)
;
let
fast_match
=
longest_match_fast
(
&
data
[
.
.
]
&
hash_table
pos
0
NUM_CHECKS
)
;
if
fast_match
.
0
>
naive_match
.
0
{
println
!
(
"
Fast
match
found
better
match
!
"
)
;
}
assert
!
(
fast_match
.
0
>
=
naive_match
.
0
"
naive
match
had
better
length
!
start_pos
:
{
}
naive
:
{
:
?
}
fast
{
:
?
}
"
start_pos
naive_match
fast_match
)
;
assert
!
(
fast_match
.
1
>
=
naive_match
.
1
"
naive
match
had
better
dist
!
start_pos
:
{
}
naive
{
:
?
}
fast
{
:
?
}
"
start_pos
naive_match
fast_match
)
;
}
}
}
#
[
cfg
(
all
(
test
feature
=
"
benchmarks
"
)
)
]
mod
bench
{
use
test_std
:
:
Bencher
;
use
test_utils
:
:
get_test_data
;
use
chained_hash_table
:
:
filled_hash_table
;
use
super
:
:
{
longest_match
longest_match_fast
}
;
#
[
bench
]
fn
matching
(
b
:
&
mut
Bencher
)
{
const
POS
:
usize
=
29000
;
let
data
=
get_test_data
(
)
;
let
hash_table
=
filled_hash_table
(
&
data
[
.
.
POS
+
1
]
)
;
let
pos
=
hash_table
.
current_head
(
)
as
usize
;
println
!
(
"
M
:
{
:
?
}
"
longest_match
(
&
data
[
.
.
]
&
hash_table
pos
0
4096
)
)
;
b
.
iter
(
|
|
longest_match
(
&
data
[
.
.
]
&
hash_table
pos
0
4096
)
)
;
}
#
[
bench
]
fn
fast_matching
(
b
:
&
mut
Bencher
)
{
const
POS
:
usize
=
29000
;
let
data
=
get_test_data
(
)
;
let
hash_table
=
filled_hash_table
(
&
data
[
.
.
POS
+
1
]
)
;
let
pos
=
hash_table
.
current_head
(
)
as
usize
;
println
!
(
"
M
:
{
:
?
}
"
longest_match_fast
(
&
data
[
.
.
]
&
hash_table
pos
0
4096
)
)
;
b
.
iter
(
|
|
longest_match_fast
(
&
data
[
.
.
]
&
hash_table
pos
0
4096
)
)
;
}
}
