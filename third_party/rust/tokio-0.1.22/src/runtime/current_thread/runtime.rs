use
tokio_current_thread
:
:
{
self
as
current_thread
CurrentThread
}
;
use
tokio_current_thread
:
:
Handle
as
ExecutorHandle
;
use
runtime
:
:
current_thread
:
:
Builder
;
use
tokio_reactor
:
:
{
self
Reactor
}
;
use
tokio_timer
:
:
clock
:
:
{
self
Clock
}
;
use
tokio_timer
:
:
timer
:
:
{
self
Timer
}
;
use
tokio_executor
;
use
futures
:
:
{
future
Future
}
;
use
std
:
:
fmt
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
io
;
#
[
derive
(
Debug
)
]
pub
struct
Runtime
{
reactor_handle
:
tokio_reactor
:
:
Handle
timer_handle
:
timer
:
:
Handle
clock
:
Clock
executor
:
CurrentThread
<
Timer
<
Reactor
>
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Handle
(
ExecutorHandle
)
;
impl
Handle
{
pub
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
Result
<
(
)
tokio_executor
:
:
SpawnError
>
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
self
.
0
.
spawn
(
future
)
}
pub
fn
status
(
&
self
)
-
>
Result
<
(
)
tokio_executor
:
:
SpawnError
>
{
self
.
0
.
status
(
)
}
}
impl
<
T
>
future
:
:
Executor
<
T
>
for
Handle
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
execute
(
&
self
future
:
T
)
-
>
Result
<
(
)
future
:
:
ExecuteError
<
T
>
>
{
if
let
Err
(
e
)
=
self
.
status
(
)
{
let
kind
=
if
e
.
is_at_capacity
(
)
{
future
:
:
ExecuteErrorKind
:
:
NoCapacity
}
else
{
future
:
:
ExecuteErrorKind
:
:
Shutdown
}
;
return
Err
(
future
:
:
ExecuteError
:
:
new
(
kind
future
)
)
;
}
let
_
=
self
.
spawn
(
future
)
;
Ok
(
(
)
)
}
}
impl
<
T
>
:
:
executor
:
:
TypedExecutor
<
T
>
for
Handle
where
T
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
Send
+
'
static
{
fn
spawn
(
&
mut
self
future
:
T
)
-
>
Result
<
(
)
:
:
executor
:
:
SpawnError
>
{
Handle
:
:
spawn
(
self
future
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
RunError
{
inner
:
current_thread
:
:
RunError
}
impl
fmt
:
:
Display
for
RunError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
self
.
inner
)
}
}
impl
Error
for
RunError
{
fn
description
(
&
self
)
-
>
&
str
{
self
.
inner
.
description
(
)
}
#
[
allow
(
deprecated
)
]
fn
cause
(
&
self
)
-
>
Option
<
&
Error
>
{
self
.
inner
.
cause
(
)
}
}
impl
Runtime
{
pub
fn
new
(
)
-
>
io
:
:
Result
<
Runtime
>
{
Builder
:
:
new
(
)
.
build
(
)
}
pub
(
super
)
fn
new2
(
reactor_handle
:
tokio_reactor
:
:
Handle
timer_handle
:
timer
:
:
Handle
clock
:
Clock
executor
:
CurrentThread
<
Timer
<
Reactor
>
>
)
-
>
Runtime
{
Runtime
{
reactor_handle
timer_handle
clock
executor
}
}
pub
fn
handle
(
&
self
)
-
>
Handle
{
Handle
(
self
.
executor
.
handle
(
)
.
clone
(
)
)
}
pub
fn
spawn
<
F
>
(
&
mut
self
future
:
F
)
-
>
&
mut
Self
where
F
:
Future
<
Item
=
(
)
Error
=
(
)
>
+
'
static
{
self
.
executor
.
spawn
(
future
)
;
self
}
pub
fn
block_on
<
F
>
(
&
mut
self
f
:
F
)
-
>
Result
<
F
:
:
Item
F
:
:
Error
>
where
F
:
Future
{
self
.
enter
(
|
executor
|
{
let
ret
=
executor
.
block_on
(
f
)
;
ret
.
map_err
(
|
e
|
e
.
into_inner
(
)
.
expect
(
"
unexpected
execution
error
"
)
)
}
)
}
pub
fn
run
(
&
mut
self
)
-
>
Result
<
(
)
RunError
>
{
self
.
enter
(
|
executor
|
executor
.
run
(
)
)
.
map_err
(
|
e
|
RunError
{
inner
:
e
}
)
}
fn
enter
<
F
R
>
(
&
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
current_thread
:
:
Entered
<
Timer
<
Reactor
>
>
)
-
>
R
{
let
Runtime
{
ref
reactor_handle
ref
timer_handle
ref
clock
ref
mut
executor
.
.
}
=
*
self
;
let
mut
enter
=
tokio_executor
:
:
enter
(
)
.
expect
(
"
Multiple
executors
at
once
"
)
;
tokio_reactor
:
:
with_default
(
&
reactor_handle
&
mut
enter
|
enter
|
{
clock
:
:
with_default
(
clock
enter
|
enter
|
{
timer
:
:
with_default
(
&
timer_handle
enter
|
enter
|
{
let
mut
default_executor
=
current_thread
:
:
TaskExecutor
:
:
current
(
)
;
tokio_executor
:
:
with_default
(
&
mut
default_executor
enter
|
enter
|
{
let
mut
executor
=
executor
.
enter
(
enter
)
;
f
(
&
mut
executor
)
}
)
}
)
}
)
}
)
}
}
