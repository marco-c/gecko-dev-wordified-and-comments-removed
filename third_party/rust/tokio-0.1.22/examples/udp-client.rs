extern
crate
futures
;
extern
crate
tokio
;
use
std
:
:
env
;
use
std
:
:
io
:
:
stdin
;
use
std
:
:
net
:
:
SocketAddr
;
use
tokio
:
:
net
:
:
UdpSocket
;
use
tokio
:
:
prelude
:
:
*
;
fn
get_stdin_data
(
)
-
>
Result
<
Vec
<
u8
>
Box
<
std
:
:
error
:
:
Error
>
>
{
let
mut
buf
=
Vec
:
:
new
(
)
;
stdin
(
)
.
read_to_end
(
&
mut
buf
)
?
;
Ok
(
buf
)
}
fn
main
(
)
-
>
Result
<
(
)
Box
<
std
:
:
error
:
:
Error
>
>
{
let
remote_addr
:
SocketAddr
=
env
:
:
args
(
)
.
nth
(
1
)
.
unwrap_or
(
"
127
.
0
.
0
.
1
:
8080
"
.
into
(
)
)
.
parse
(
)
?
;
let
local_addr
:
SocketAddr
=
if
remote_addr
.
is_ipv4
(
)
{
"
0
.
0
.
0
.
0
:
0
"
}
else
{
"
[
:
:
]
:
0
"
}
.
parse
(
)
?
;
let
socket
=
UdpSocket
:
:
bind
(
&
local_addr
)
?
;
const
MAX_DATAGRAM_SIZE
:
usize
=
65_507
;
socket
.
send_dgram
(
get_stdin_data
(
)
?
&
remote_addr
)
.
and_then
(
|
(
socket
_
)
|
socket
.
recv_dgram
(
vec
!
[
0u8
;
MAX_DATAGRAM_SIZE
]
)
)
.
map
(
|
(
_
data
len
_
)
|
{
println
!
(
"
Received
{
}
bytes
:
\
n
{
}
"
len
String
:
:
from_utf8_lossy
(
&
data
[
.
.
len
]
)
)
}
)
.
wait
(
)
?
;
Ok
(
(
)
)
}
