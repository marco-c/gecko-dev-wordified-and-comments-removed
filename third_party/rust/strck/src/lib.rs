use
core
:
:
{
borrow
cmp
fmt
hash
marker
ops
str
}
;
mod
partial_eq
;
#
[
cfg
(
feature
=
"
serde
"
)
]
mod
serde
;
#
[
derive
(
Clone
)
]
#
[
repr
(
transparent
)
]
pub
struct
Check
<
I
:
Invariant
B
:
AsRef
<
str
>
+
'
static
=
String
>
{
_marker
:
marker
:
:
PhantomData
<
I
>
buf
:
B
}
#
[
repr
(
transparent
)
]
pub
struct
Ck
<
I
:
Invariant
>
{
_marker
:
marker
:
:
PhantomData
<
I
>
slice
:
str
}
pub
trait
Invariant
:
Sized
{
type
Error
:
fmt
:
:
Display
;
fn
check
(
slice
:
&
str
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
}
pub
trait
IntoCk
:
Sized
+
AsRef
<
str
>
{
fn
ck
<
I
:
Invariant
>
(
&
self
)
-
>
Result
<
&
Ck
<
I
>
I
:
:
Error
>
;
}
impl
<
T
:
AsRef
<
str
>
>
IntoCk
for
T
{
fn
ck
<
I
:
Invariant
>
(
&
self
)
-
>
Result
<
&
Ck
<
I
>
I
:
:
Error
>
{
Ck
:
:
from_slice
(
self
.
as_ref
(
)
)
}
}
pub
trait
IntoCheck
:
Sized
+
AsRef
<
str
>
+
'
static
{
fn
check
<
I
:
Invariant
>
(
self
)
-
>
Result
<
Check
<
I
Self
>
I
:
:
Error
>
;
}
impl
<
T
:
AsRef
<
str
>
+
'
static
>
IntoCheck
for
T
{
fn
check
<
I
:
Invariant
>
(
self
)
-
>
Result
<
Check
<
I
Self
>
I
:
:
Error
>
{
Check
:
:
from_buf
(
self
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
Check
<
I
B
>
{
pub
fn
from_buf
(
buf
:
B
)
-
>
Result
<
Self
I
:
:
Error
>
{
I
:
:
check
(
buf
.
as_ref
(
)
)
?
;
unsafe
{
Ok
(
Self
:
:
from_buf_unchecked
(
buf
)
)
}
}
pub
unsafe
fn
from_buf_unchecked
(
buf
:
B
)
-
>
Self
{
Check
{
_marker
:
marker
:
:
PhantomData
buf
}
}
pub
fn
as_ck
(
&
self
)
-
>
&
Ck
<
I
>
{
unsafe
{
Ck
:
:
from_str_unchecked
(
self
.
buf
.
as_ref
(
)
)
}
}
pub
fn
into_inner
(
self
)
-
>
B
{
self
.
buf
}
}
impl
<
I
B
>
fmt
:
:
Debug
for
Check
<
I
B
>
where
I
:
Invariant
B
:
AsRef
<
str
>
+
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
buf
f
)
}
}
impl
<
I
B1
B2
>
PartialEq
<
Check
<
I
B2
>
>
for
Check
<
I
B1
>
where
I
:
Invariant
B1
:
AsRef
<
str
>
B2
:
AsRef
<
str
>
{
fn
eq
(
&
self
other
:
&
Check
<
I
B2
>
)
-
>
bool
{
self
=
=
other
}
}
impl
<
I
B1
B2
>
PartialOrd
<
Check
<
I
B2
>
>
for
Check
<
I
B1
>
where
I
:
Invariant
B1
:
AsRef
<
str
>
B2
:
AsRef
<
str
>
{
fn
partial_cmp
(
&
self
other
:
&
Check
<
I
B2
>
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
as_ck
(
)
.
partial_cmp
(
other
.
as_ck
(
)
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
Eq
for
Check
<
I
B
>
{
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
Ord
for
Check
<
I
B
>
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
self
.
as_ck
(
)
.
cmp
(
other
.
as_ck
(
)
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
hash
:
:
Hash
for
Check
<
I
B
>
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
as_str
(
)
.
hash
(
state
)
;
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
ops
:
:
Deref
for
Check
<
I
B
>
{
type
Target
=
Ck
<
I
>
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
self
.
as_ck
(
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
AsRef
<
Ck
<
I
>
>
for
Check
<
I
B
>
{
fn
as_ref
(
&
self
)
-
>
&
Ck
<
I
>
{
self
.
as_ck
(
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
AsRef
<
str
>
for
Check
<
I
B
>
{
fn
as_ref
(
&
self
)
-
>
&
str
{
self
.
as_str
(
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
borrow
:
:
Borrow
<
Ck
<
I
>
>
for
Check
<
I
B
>
{
fn
borrow
(
&
self
)
-
>
&
Ck
<
I
>
{
self
.
as_ck
(
)
}
}
impl
<
I
:
Invariant
B
:
AsRef
<
str
>
>
fmt
:
:
Display
for
Check
<
I
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
.
as_str
(
)
f
)
}
}
impl
<
'
a
I
B
>
From
<
&
'
a
Ck
<
I
>
>
for
Check
<
I
B
>
where
I
:
Invariant
B
:
AsRef
<
str
>
+
From
<
&
'
a
str
>
{
fn
from
(
check
:
&
'
a
Ck
<
I
>
)
-
>
Self
{
check
.
to_check
(
)
}
}
impl
<
I
B
>
str
:
:
FromStr
for
Check
<
I
B
>
where
I
:
Invariant
for
<
'
a
>
B
:
AsRef
<
str
>
+
From
<
&
'
a
str
>
{
type
Err
=
I
:
:
Error
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Ok
(
s
.
ck
(
)
?
.
to_check
(
)
)
}
}
impl
<
I
:
Invariant
>
Ck
<
I
>
{
pub
fn
from_slice
(
slice
:
&
str
)
-
>
Result
<
&
Self
I
:
:
Error
>
{
I
:
:
check
(
slice
)
?
;
unsafe
{
Ok
(
Self
:
:
from_str_unchecked
(
slice
)
)
}
}
pub
unsafe
fn
from_str_unchecked
(
slice
:
&
str
)
-
>
&
Self
{
core
:
:
mem
:
:
transmute
(
slice
)
}
pub
fn
to_check
<
'
a
B
>
(
&
'
a
self
)
-
>
Check
<
I
B
>
where
B
:
AsRef
<
str
>
+
From
<
&
'
a
str
>
{
unsafe
{
Check
:
:
from_buf_unchecked
(
self
.
as_str
(
)
.
into
(
)
)
}
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
&
self
.
slice
}
}
impl
<
I
:
Invariant
>
fmt
:
:
Debug
for
Ck
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
slice
f
)
}
}
impl
<
I
:
Invariant
>
PartialEq
for
Ck
<
I
>
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
as_str
(
)
=
=
other
.
as_str
(
)
}
}
impl
<
I
:
Invariant
>
PartialOrd
for
Ck
<
I
>
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
slice
.
partial_cmp
(
&
other
.
slice
)
}
}
impl
<
I
:
Invariant
>
Eq
for
Ck
<
I
>
{
}
impl
<
I
:
Invariant
>
Ord
for
Ck
<
I
>
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
self
.
as_str
(
)
.
cmp
(
other
.
as_str
(
)
)
}
}
impl
<
I
:
Invariant
>
hash
:
:
Hash
for
Ck
<
I
>
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
as_str
(
)
.
hash
(
state
)
;
}
}
impl
<
I
:
Invariant
>
AsRef
<
str
>
for
Ck
<
I
>
{
fn
as_ref
(
&
self
)
-
>
&
str
{
self
.
as_str
(
)
}
}
impl
<
I
:
Invariant
>
borrow
:
:
Borrow
<
str
>
for
Ck
<
I
>
{
fn
borrow
(
&
self
)
-
>
&
str
{
self
.
as_str
(
)
}
}
impl
<
I
:
Invariant
>
ToOwned
for
Ck
<
I
>
{
type
Owned
=
Check
<
I
>
;
fn
to_owned
(
&
self
)
-
>
Self
:
:
Owned
{
self
.
to_check
(
)
}
}
impl
<
I
:
Invariant
>
fmt
:
:
Display
for
Ck
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
.
as_str
(
)
f
)
}
}
impl
<
'
a
I
:
Invariant
B
:
AsRef
<
str
>
>
From
<
&
'
a
Check
<
I
B
>
>
for
&
'
a
Ck
<
I
>
{
fn
from
(
check
:
&
'
a
Check
<
I
B
>
)
-
>
Self
{
check
.
as_ck
(
)
}
}
impl
<
'
a
I
:
Invariant
>
TryFrom
<
&
'
a
str
>
for
&
'
a
Ck
<
I
>
{
type
Error
=
I
:
:
Error
;
fn
try_from
(
slice
:
&
'
a
str
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Ck
:
:
from_slice
(
slice
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
struct
NoInvariant
;
impl
Invariant
for
NoInvariant
{
type
Error
=
core
:
:
convert
:
:
Infallible
;
fn
check
(
_slice
:
&
str
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Ok
(
(
)
)
}
}
#
[
test
]
fn
test_debug_impl
(
)
{
let
this
=
"
this
"
.
ck
:
:
<
NoInvariant
>
(
)
.
unwrap
(
)
;
let
fmt_debug
=
format
!
(
"
{
:
?
}
"
this
)
;
assert_eq
!
(
fmt_debug
"
\
"
this
\
"
"
)
;
}
}
