use
crate
:
:
{
Check
Ck
Invariant
}
;
use
core
:
:
fmt
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
UnicodeIdent
;
pub
type
Ident
=
Ck
<
UnicodeIdent
>
;
pub
type
IdentBuf
<
B
=
String
>
=
Check
<
UnicodeIdent
B
>
;
#
[
derive
(
Debug
Copy
Clone
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
Error
{
Empty
Start
(
char
)
Continue
(
char
)
}
impl
std
:
:
error
:
:
Error
for
Error
{
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
Error
:
:
Empty
=
>
f
.
pad
(
"
empty
"
)
Error
:
:
Start
(
ch
)
=
>
write
!
(
f
"
invalid
start
'
{
ch
}
'
"
)
Error
:
:
Continue
(
ch
)
=
>
write
!
(
f
"
invalid
continue
'
{
ch
}
'
"
)
}
}
}
impl
Invariant
for
UnicodeIdent
{
type
Error
=
Error
;
fn
check
(
slice
:
&
str
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
let
mut
chars
=
slice
.
chars
(
)
;
let
start
=
chars
.
next
(
)
.
ok_or
(
Error
:
:
Empty
)
?
;
if
!
unicode_ident
:
:
is_xid_start
(
start
)
{
return
Err
(
Error
:
:
Start
(
start
)
)
;
}
for
ch
in
chars
{
if
!
unicode_ident
:
:
is_xid_continue
(
ch
)
{
return
Err
(
Error
:
:
Continue
(
ch
)
)
;
}
}
Ok
(
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
Error
UnicodeIdent
}
;
use
crate
:
:
IntoCk
;
#
[
test
]
fn
test_invalid
(
)
{
assert_eq
!
(
"
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Empty
)
;
assert_eq
!
(
"
12345
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Start
(
'
1
'
)
)
;
assert_eq
!
(
"
_foo
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Start
(
'
'
)
)
;
assert_eq
!
(
"
foo_
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Continue
(
'
'
)
)
;
assert_eq
!
(
"
hello
.
there
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Continue
(
'
.
'
)
)
;
assert_eq
!
(
"
\
\
as2mkf
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Start
(
'
\
\
'
)
)
;
assert_eq
!
(
"
the
book
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Continue
(
'
'
)
)
;
assert_eq
!
(
"
book
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Start
(
'
'
)
)
;
assert_eq
!
(
"
\
n
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Start
(
'
\
n
'
)
)
;
assert_eq
!
(
"
_underscore
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Start
(
'
_
'
)
)
;
assert_eq
!
(
"
r
#
try
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
unwrap_err
(
)
Error
:
:
Continue
(
'
#
'
)
)
;
}
#
[
test
]
fn
test_valid
(
)
{
assert
!
(
"
a2345
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
foo
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
snake_case
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
impl
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
is_ok
(
)
)
;
assert
!
(
"
"
.
ck
:
:
<
UnicodeIdent
>
(
)
.
is_ok
(
)
)
;
}
}
