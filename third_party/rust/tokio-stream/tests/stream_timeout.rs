#
!
[
cfg
(
all
(
feature
=
"
time
"
feature
=
"
sync
"
feature
=
"
io
-
util
"
)
)
]
use
tokio
:
:
time
:
:
{
self
sleep
Duration
}
;
use
tokio_stream
:
:
{
self
StreamExt
}
;
use
tokio_test
:
:
*
;
use
futures
:
:
stream
;
async
fn
maybe_sleep
(
idx
:
i32
)
-
>
i32
{
if
idx
%
2
=
=
0
{
sleep
(
ms
(
200
)
)
.
await
;
}
idx
}
fn
ms
(
n
:
u64
)
-
>
Duration
{
Duration
:
:
from_millis
(
n
)
}
#
[
tokio
:
:
test
]
async
fn
basic_usage
(
)
{
time
:
:
pause
(
)
;
let
stream
=
stream
:
:
iter
(
1
.
.
=
4
)
.
then
(
maybe_sleep
)
.
timeout
(
ms
(
100
)
)
;
let
mut
stream
=
task
:
:
spawn
(
stream
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
1
)
)
)
;
assert_pending
!
(
stream
.
poll_next
(
)
)
;
time
:
:
advance
(
ms
(
150
)
)
.
await
;
let
v
=
assert_ready
!
(
stream
.
poll_next
(
)
)
;
assert
!
(
v
.
unwrap
(
)
.
is_err
(
)
)
;
assert_pending
!
(
stream
.
poll_next
(
)
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
2
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
3
)
)
)
;
assert_pending
!
(
stream
.
poll_next
(
)
)
;
time
:
:
advance
(
ms
(
60
)
)
.
await
;
assert_pending
!
(
stream
.
poll_next
(
)
)
;
time
:
:
advance
(
ms
(
60
)
)
.
await
;
let
v
=
assert_ready
!
(
stream
.
poll_next
(
)
)
;
assert
!
(
v
.
unwrap
(
)
.
is_err
(
)
)
;
time
:
:
advance
(
ms
(
120
)
)
.
await
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
4
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
None
)
;
}
#
[
tokio
:
:
test
]
async
fn
return_elapsed_errors_only_once
(
)
{
time
:
:
pause
(
)
;
let
stream
=
stream
:
:
iter
(
1
.
.
=
3
)
.
then
(
maybe_sleep
)
.
timeout
(
ms
(
50
)
)
;
let
mut
stream
=
task
:
:
spawn
(
stream
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
1
)
)
)
;
assert_pending
!
(
stream
.
poll_next
(
)
)
;
time
:
:
advance
(
ms
(
51
)
)
.
await
;
let
v
=
assert_ready
!
(
stream
.
poll_next
(
)
)
;
assert
!
(
v
.
unwrap
(
)
.
is_err
(
)
)
;
time
:
:
advance
(
ms
(
50
)
)
.
await
;
assert_pending
!
(
stream
.
poll_next
(
)
)
;
time
:
:
advance
(
ms
(
100
)
)
.
await
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
2
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
3
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
None
)
;
}
#
[
tokio
:
:
test
]
async
fn
no_timeouts
(
)
{
let
stream
=
stream
:
:
iter
(
vec
!
[
1
3
5
]
)
.
then
(
maybe_sleep
)
.
timeout
(
ms
(
100
)
)
;
let
mut
stream
=
task
:
:
spawn
(
stream
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
1
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
3
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
Some
(
Ok
(
5
)
)
)
;
assert_ready_eq
!
(
stream
.
poll_next
(
)
None
)
;
}
