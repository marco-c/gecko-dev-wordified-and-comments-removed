use
crate
:
:
Decimal
;
use
rand
:
:
{
distributions
:
:
{
uniform
:
:
{
SampleBorrow
SampleUniform
UniformInt
UniformSampler
}
Distribution
Standard
}
Rng
}
;
impl
Distribution
<
Decimal
>
for
Standard
{
fn
sample
<
R
>
(
&
self
rng
:
&
mut
R
)
-
>
Decimal
where
R
:
Rng
+
?
Sized
{
Decimal
:
:
from_parts
(
rng
.
next_u32
(
)
rng
.
next_u32
(
)
rng
.
next_u32
(
)
rng
.
gen
(
)
rng
.
next_u32
(
)
)
}
}
impl
SampleUniform
for
Decimal
{
type
Sampler
=
DecimalSampler
;
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
struct
DecimalSampler
{
mantissa_sampler
:
UniformInt
<
i128
>
scale
:
u32
}
impl
UniformSampler
for
DecimalSampler
{
type
X
=
Decimal
;
#
[
inline
]
fn
new
<
B1
B2
>
(
low
:
B1
high
:
B2
)
-
>
Self
where
B1
:
SampleBorrow
<
Self
:
:
X
>
+
Sized
B2
:
SampleBorrow
<
Self
:
:
X
>
+
Sized
{
let
(
low
high
)
=
sync_scales
(
*
low
.
borrow
(
)
*
high
.
borrow
(
)
)
;
let
high
=
Decimal
:
:
from_i128_with_scale
(
high
.
mantissa
(
)
-
1
high
.
scale
(
)
)
;
UniformSampler
:
:
new_inclusive
(
low
high
)
}
#
[
inline
]
fn
new_inclusive
<
B1
B2
>
(
low
:
B1
high
:
B2
)
-
>
Self
where
B1
:
SampleBorrow
<
Self
:
:
X
>
+
Sized
B2
:
SampleBorrow
<
Self
:
:
X
>
+
Sized
{
let
(
low
high
)
=
sync_scales
(
*
low
.
borrow
(
)
*
high
.
borrow
(
)
)
;
Self
{
mantissa_sampler
:
UniformInt
:
:
new_inclusive
(
low
.
mantissa
(
)
high
.
mantissa
(
)
)
scale
:
low
.
scale
(
)
}
}
#
[
inline
]
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
Self
:
:
X
{
let
mantissa
=
self
.
mantissa_sampler
.
sample
(
rng
)
;
Decimal
:
:
from_i128_with_scale
(
mantissa
self
.
scale
)
}
}
#
[
inline
]
fn
sync_scales
(
mut
a
:
Decimal
mut
b
:
Decimal
)
-
>
(
Decimal
Decimal
)
{
if
a
.
scale
(
)
=
=
b
.
scale
(
)
{
return
(
a
b
)
;
}
a
.
rescale
(
a
.
scale
(
)
.
max
(
b
.
scale
(
)
)
)
;
b
.
rescale
(
a
.
scale
(
)
.
max
(
b
.
scale
(
)
)
)
;
if
a
.
scale
(
)
!
=
b
.
scale
(
)
{
a
.
rescale
(
a
.
scale
(
)
.
min
(
b
.
scale
(
)
)
)
;
b
.
rescale
(
a
.
scale
(
)
.
min
(
b
.
scale
(
)
)
)
;
}
(
a
b
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
collections
:
:
HashSet
;
use
super
:
:
*
;
macro_rules
!
dec
{
(
e
:
expr
)
=
>
{
Decimal
:
:
from_str_exact
(
stringify
!
(
e
)
)
.
unwrap
(
)
}
;
}
#
[
test
]
fn
has_random_decimal_instances
(
)
{
let
mut
rng
=
rand
:
:
rngs
:
:
OsRng
;
let
random
:
[
Decimal
;
32
]
=
rng
.
gen
(
)
;
assert
!
(
random
.
windows
(
2
)
.
any
(
|
slice
|
{
slice
[
0
]
!
=
slice
[
1
]
}
)
)
;
}
#
[
test
]
fn
generates_within_range
(
)
{
let
mut
rng
=
rand
:
:
rngs
:
:
OsRng
;
for
_
in
0
.
.
128
{
let
random
=
rng
.
gen_range
(
dec
!
(
1
.
00
)
.
.
dec
!
(
1
.
05
)
)
;
assert
!
(
random
<
dec
!
(
1
.
05
)
)
;
assert
!
(
random
>
=
dec
!
(
1
.
00
)
)
;
}
}
#
[
test
]
fn
generates_within_inclusive_range
(
)
{
let
mut
rng
=
rand
:
:
rngs
:
:
OsRng
;
let
mut
values
:
HashSet
<
Decimal
>
=
HashSet
:
:
new
(
)
;
for
_
in
0
.
.
256
{
let
random
=
rng
.
gen_range
(
dec
!
(
1
.
00
)
.
.
=
dec
!
(
1
.
01
)
)
;
assert
!
(
random
=
=
dec
!
(
1
.
00
)
|
|
random
=
=
dec
!
(
1
.
01
)
)
;
values
.
insert
(
random
)
;
}
assert_eq
!
(
values
.
len
(
)
2
)
;
}
#
[
test
]
fn
test_edge_case_scales_match
(
)
{
let
(
low
high
)
=
sync_scales
(
dec
!
(
1
.
000_000_000_000_000_000_01
)
dec
!
(
100_000_000_000_000_000_001
)
)
;
assert_eq
!
(
low
.
scale
(
)
high
.
scale
(
)
)
;
}
}
