use
crate
:
:
{
constants
:
:
{
MAX_PRECISION
POWERS_10
U32_MASK
}
decimal
:
:
{
CalculationResult
Decimal
}
ops
:
:
array
:
:
{
add_by_internal
cmp_internal
div_by_u32
is_all_zero
mul_by_u32
mul_part
rescale_internal
shl1_internal
}
}
;
use
core
:
:
cmp
:
:
Ordering
;
use
num_traits
:
:
Zero
;
pub
(
crate
)
fn
add_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
CalculationResult
{
let
mut
my
=
d1
.
mantissa_array3
(
)
;
let
mut
my_scale
=
d1
.
scale
(
)
;
let
mut
ot
=
d2
.
mantissa_array3
(
)
;
let
mut
other_scale
=
d2
.
scale
(
)
;
rescale_to_maximum_scale
(
&
mut
my
&
mut
my_scale
&
mut
ot
&
mut
other_scale
)
;
let
mut
final_scale
=
my_scale
.
max
(
other_scale
)
;
let
my_negative
=
d1
.
is_sign_negative
(
)
;
let
other_negative
=
d2
.
is_sign_negative
(
)
;
let
mut
negative
=
false
;
let
carry
;
if
!
(
my_negative
^
other_negative
)
{
negative
=
my_negative
;
carry
=
add_by_internal3
(
&
mut
my
&
ot
)
;
}
else
{
let
cmp
=
cmp_internal
(
&
my
&
ot
)
;
match
cmp
{
Ordering
:
:
Less
=
>
{
negative
=
other_negative
;
sub_by_internal3
(
&
mut
ot
&
my
)
;
my
[
0
]
=
ot
[
0
]
;
my
[
1
]
=
ot
[
1
]
;
my
[
2
]
=
ot
[
2
]
;
}
Ordering
:
:
Greater
=
>
{
negative
=
my_negative
;
sub_by_internal3
(
&
mut
my
&
ot
)
;
}
Ordering
:
:
Equal
=
>
{
my
[
0
]
=
0
;
my
[
1
]
=
0
;
my
[
2
]
=
0
;
}
}
carry
=
0
;
}
if
carry
>
0
{
if
final_scale
=
=
0
{
return
CalculationResult
:
:
Overflow
;
}
let
mut
temp
=
[
my
[
0
]
my
[
1
]
my
[
2
]
carry
]
;
while
final_scale
>
0
&
&
temp
[
3
]
!
=
0
{
div_by_u32
(
&
mut
temp
10
)
;
final_scale
-
=
1
;
}
if
temp
[
3
]
>
0
{
return
CalculationResult
:
:
Overflow
;
}
my
[
0
]
=
temp
[
0
]
;
my
[
1
]
=
temp
[
1
]
;
my
[
2
]
=
temp
[
2
]
;
}
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
my
[
0
]
my
[
1
]
my
[
2
]
negative
final_scale
)
)
}
pub
(
crate
)
fn
sub_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
CalculationResult
{
add_impl
(
d1
&
(
-
*
d2
)
)
}
pub
(
crate
)
fn
div_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
CalculationResult
{
if
d2
.
is_zero
(
)
{
return
CalculationResult
:
:
DivByZero
;
}
if
d1
.
is_zero
(
)
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
zero
(
)
)
;
}
let
dividend
=
d1
.
mantissa_array3
(
)
;
let
divisor
=
d2
.
mantissa_array3
(
)
;
let
mut
quotient
=
[
0u32
0u32
0u32
]
;
let
mut
quotient_scale
:
i32
=
d1
.
scale
(
)
as
i32
-
d2
.
scale
(
)
as
i32
;
let
mut
working_quotient
=
[
dividend
[
0
]
dividend
[
1
]
dividend
[
2
]
0u32
]
;
let
mut
working_remainder
=
[
0u32
0u32
0u32
0u32
]
;
let
mut
working_scale
=
quotient_scale
;
let
mut
remainder_scale
=
quotient_scale
;
let
mut
underflow
;
loop
{
div_internal
(
&
mut
working_quotient
&
mut
working_remainder
&
divisor
)
;
underflow
=
add_with_scale_internal
(
&
mut
quotient
&
mut
quotient_scale
&
mut
working_quotient
&
mut
working_scale
)
;
let
mut
overflow
=
0
;
for
part
in
working_remainder
.
iter_mut
(
)
{
let
(
lo
hi
)
=
mul_part
(
*
part
10
overflow
)
;
*
part
=
lo
;
overflow
=
hi
;
}
working_quotient
.
copy_from_slice
(
&
working_remainder
)
;
remainder_scale
+
=
1
;
working_scale
=
remainder_scale
;
if
underflow
|
|
is_all_zero
(
&
working_remainder
)
{
break
;
}
}
while
quotient_scale
<
0
{
copy_array_diff_lengths
(
&
mut
working_quotient
&
quotient
)
;
working_quotient
[
3
]
=
0
;
working_remainder
.
iter_mut
(
)
.
for_each
(
|
x
|
*
x
=
0
)
;
let
mut
overflow
=
0
;
for
part
in
&
mut
working_quotient
{
let
(
lo
hi
)
=
mul_part
(
*
part
10
overflow
)
;
*
part
=
lo
;
overflow
=
hi
;
}
for
part
in
&
mut
working_remainder
{
let
(
lo
hi
)
=
mul_part
(
*
part
10
overflow
)
;
*
part
=
lo
;
overflow
=
hi
;
}
if
working_quotient
[
3
]
=
=
0
&
&
is_all_zero
(
&
working_remainder
)
{
quotient_scale
+
=
1
;
quotient
[
0
]
=
working_quotient
[
0
]
;
quotient
[
1
]
=
working_quotient
[
1
]
;
quotient
[
2
]
=
working_quotient
[
2
]
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
}
if
quotient_scale
>
255
{
quotient
[
0
]
=
0
;
quotient
[
1
]
=
0
;
quotient
[
2
]
=
0
;
quotient_scale
=
0
;
}
let
mut
quotient_negative
=
d1
.
is_sign_negative
(
)
^
d2
.
is_sign_negative
(
)
;
let
mut
final_scale
:
u32
=
quotient_scale
as
u32
;
if
final_scale
>
MAX_PRECISION
{
let
mut
remainder
=
0
;
while
final_scale
>
MAX_PRECISION
&
&
!
is_all_zero
(
&
quotient
)
{
remainder
=
div_by_u32
(
&
mut
quotient
10
)
;
final_scale
-
=
1
;
}
if
final_scale
>
MAX_PRECISION
{
final_scale
=
0
;
quotient_negative
=
false
;
}
else
if
remainder
>
=
5
{
for
part
in
&
mut
quotient
{
if
remainder
=
=
0
{
break
;
}
let
digit
:
u64
=
u64
:
:
from
(
*
part
)
+
1
;
remainder
=
if
digit
>
0xFFFF_FFFF
{
1
}
else
{
0
}
;
*
part
=
(
digit
&
0xFFFF_FFFF
)
as
u32
;
}
}
}
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
quotient
[
0
]
quotient
[
1
]
quotient
[
2
]
quotient_negative
final_scale
)
)
}
pub
(
crate
)
fn
mul_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
CalculationResult
{
if
d1
.
is_zero
(
)
|
|
d2
.
is_zero
(
)
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
zero
(
)
)
;
}
let
negative
=
d1
.
is_sign_negative
(
)
^
d2
.
is_sign_negative
(
)
;
let
mut
final_scale
=
d1
.
scale
(
)
+
d2
.
scale
(
)
;
let
my
=
d1
.
mantissa_array3
(
)
;
let
ot
=
d2
.
mantissa_array3
(
)
;
if
my
[
1
]
=
=
0
&
&
my
[
2
]
=
=
0
&
&
ot
[
1
]
=
=
0
&
&
ot
[
2
]
=
=
0
{
let
mut
u64_result
=
u64_to_array
(
u64
:
:
from
(
my
[
0
]
)
*
u64
:
:
from
(
ot
[
0
]
)
)
;
if
final_scale
>
MAX_PRECISION
{
final_scale
-
=
MAX_PRECISION
;
if
final_scale
>
19
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
zero
(
)
)
;
}
let
mut
rem_lo
=
0
;
let
mut
power
;
if
final_scale
>
9
{
rem_lo
=
div_by_u32
(
&
mut
u64_result
2_500_000_000
)
;
power
=
POWERS_10
[
final_scale
as
usize
-
10
]
<
<
2
;
}
else
{
power
=
POWERS_10
[
final_scale
as
usize
]
;
}
let
rem_hi
=
div_by_u32
(
&
mut
u64_result
power
)
;
power
>
>
=
1
;
if
rem_hi
>
=
power
&
&
(
rem_hi
>
power
|
|
(
rem_lo
|
(
u64_result
[
0
]
&
0x1
)
)
!
=
0
)
{
u64_result
[
0
]
+
=
1
;
}
final_scale
=
MAX_PRECISION
;
}
return
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
u64_result
[
0
]
u64_result
[
1
]
0
negative
final_scale
)
)
;
}
let
mut
product
=
[
0u32
0u32
0u32
0u32
0u32
0u32
]
;
let
to
=
if
my
[
2
]
=
=
0
&
&
ot
[
2
]
=
=
0
{
2
}
else
{
3
}
;
for
(
my_index
my_item
)
in
my
.
iter
(
)
.
enumerate
(
)
.
take
(
to
)
{
for
(
ot_index
ot_item
)
in
ot
.
iter
(
)
.
enumerate
(
)
.
take
(
to
)
{
let
(
mut
rlo
mut
rhi
)
=
mul_part
(
*
my_item
*
ot_item
0
)
;
for
prod
in
product
.
iter_mut
(
)
.
skip
(
my_index
+
ot_index
)
{
let
(
res
overflow
)
=
add_part
(
rlo
*
prod
)
;
*
prod
=
res
;
if
rhi
>
0
{
if
overflow
>
0
{
let
(
nlo
nhi
)
=
add_part
(
rhi
overflow
)
;
rlo
=
nlo
;
rhi
=
nhi
;
}
else
{
rlo
=
rhi
;
rhi
=
0
;
}
}
else
if
overflow
>
0
{
rlo
=
overflow
;
rhi
=
0
;
}
else
{
break
;
}
if
rlo
=
=
0
{
break
;
}
}
}
}
let
mut
remainder
=
0
;
while
final_scale
>
0
&
&
(
product
[
3
]
!
=
0
|
|
product
[
4
]
!
=
0
|
|
product
[
5
]
!
=
0
)
{
remainder
=
div_by_u32
(
&
mut
product
10u32
)
;
final_scale
-
=
1
;
}
if
remainder
>
=
5
{
for
part
in
product
.
iter_mut
(
)
{
if
remainder
=
=
0
{
break
;
}
let
digit
:
u64
=
u64
:
:
from
(
*
part
)
+
1
;
remainder
=
if
digit
>
0xFFFF_FFFF
{
1
}
else
{
0
}
;
*
part
=
(
digit
&
0xFFFF_FFFF
)
as
u32
;
}
}
if
final_scale
>
MAX_PRECISION
{
while
final_scale
>
MAX_PRECISION
&
&
!
is_all_zero
(
&
product
)
{
div_by_u32
(
&
mut
product
10
)
;
final_scale
-
=
1
;
}
if
final_scale
>
MAX_PRECISION
{
final_scale
=
0
;
}
}
else
if
!
(
product
[
3
]
=
=
0
&
&
product
[
4
]
=
=
0
&
&
product
[
5
]
=
=
0
)
{
return
CalculationResult
:
:
Overflow
;
}
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
product
[
0
]
product
[
1
]
product
[
2
]
negative
final_scale
)
)
}
pub
(
crate
)
fn
rem_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
CalculationResult
{
if
d2
.
is_zero
(
)
{
return
CalculationResult
:
:
DivByZero
;
}
if
d1
.
is_zero
(
)
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
zero
(
)
)
;
}
let
initial_scale
=
d1
.
scale
(
)
;
let
mut
quotient
=
d1
.
mantissa_array3
(
)
;
let
mut
quotient_scale
=
initial_scale
;
let
mut
divisor
=
d2
.
mantissa_array3
(
)
;
let
mut
divisor_scale
=
d2
.
scale
(
)
;
rescale_to_maximum_scale
(
&
mut
quotient
&
mut
quotient_scale
&
mut
divisor
&
mut
divisor_scale
)
;
let
mut
working_quotient
=
[
quotient
[
0
]
quotient
[
1
]
quotient
[
2
]
0u32
]
;
let
mut
working_remainder
=
[
0u32
0u32
0u32
0u32
]
;
div_internal
(
&
mut
working_quotient
&
mut
working_remainder
&
divisor
)
;
if
quotient_scale
>
initial_scale
{
let
mut
working
=
[
working_remainder
[
0
]
working_remainder
[
1
]
working_remainder
[
2
]
working_remainder
[
3
]
]
;
while
quotient_scale
>
initial_scale
{
if
div_by_u32
(
&
mut
working
10
)
>
0
{
break
;
}
quotient_scale
-
=
1
;
working_remainder
.
copy_from_slice
(
&
working
)
;
}
}
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
working_remainder
[
0
]
working_remainder
[
1
]
working_remainder
[
2
]
d1
.
is_sign_negative
(
)
quotient_scale
)
)
}
pub
(
crate
)
fn
cmp_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
Ordering
{
if
d1
.
is_zero
(
)
&
&
d2
.
is_zero
(
)
{
return
Ordering
:
:
Equal
;
}
let
self_negative
=
d1
.
is_sign_negative
(
)
;
let
other_negative
=
d2
.
is_sign_negative
(
)
;
if
self_negative
&
&
!
other_negative
{
return
Ordering
:
:
Less
;
}
else
if
!
self_negative
&
&
other_negative
{
return
Ordering
:
:
Greater
;
}
let
left
:
&
Decimal
;
let
right
:
&
Decimal
;
if
self_negative
&
&
other_negative
{
left
=
d2
;
right
=
d1
;
}
else
{
left
=
d1
;
right
=
d2
;
}
let
mut
left_scale
=
left
.
scale
(
)
;
let
mut
right_scale
=
right
.
scale
(
)
;
let
mut
left_raw
=
left
.
mantissa_array3
(
)
;
let
mut
right_raw
=
right
.
mantissa_array3
(
)
;
if
left_scale
=
=
right_scale
{
if
left_raw
[
2
]
!
=
right_raw
[
2
]
{
return
left_raw
[
2
]
.
cmp
(
&
right_raw
[
2
]
)
;
}
if
left_raw
[
1
]
!
=
right_raw
[
1
]
{
return
left_raw
[
1
]
.
cmp
(
&
right_raw
[
1
]
)
;
}
return
left_raw
[
0
]
.
cmp
(
&
right_raw
[
0
]
)
;
}
rescale_to_maximum_scale
(
&
mut
left_raw
&
mut
left_scale
&
mut
right_raw
&
mut
right_scale
)
;
cmp_internal
(
&
left_raw
&
right_raw
)
}
#
[
inline
]
fn
add_part
(
left
:
u32
right
:
u32
)
-
>
(
u32
u32
)
{
let
added
=
u64
:
:
from
(
left
)
+
u64
:
:
from
(
right
)
;
(
(
added
&
U32_MASK
)
as
u32
(
added
>
>
32
&
U32_MASK
)
as
u32
)
}
#
[
inline
(
always
)
]
fn
sub_by_internal3
(
value
:
&
mut
[
u32
;
3
]
by
:
&
[
u32
;
3
]
)
{
let
mut
overflow
=
0
;
let
vl
=
value
.
len
(
)
;
for
i
in
0
.
.
vl
{
let
part
=
(
0x1_0000_0000u64
+
u64
:
:
from
(
value
[
i
]
)
)
-
(
u64
:
:
from
(
by
[
i
]
)
+
overflow
)
;
value
[
i
]
=
part
as
u32
;
overflow
=
1
-
(
part
>
>
32
)
;
}
}
fn
div_internal
(
quotient
:
&
mut
[
u32
;
4
]
remainder
:
&
mut
[
u32
;
4
]
divisor
:
&
[
u32
;
3
]
)
{
let
mut
complement
=
[
divisor
[
0
]
^
0xFFFF_FFFF
divisor
[
1
]
^
0xFFFF_FFFF
divisor
[
2
]
^
0xFFFF_FFFF
0xFFFF_FFFF
]
;
add_one_internal4
(
&
mut
complement
)
;
remainder
.
iter_mut
(
)
.
for_each
(
|
x
|
*
x
=
0
)
;
let
mut
blocks_to_process
=
0
;
while
blocks_to_process
<
4
&
&
quotient
[
3
]
=
=
0
{
quotient
[
3
]
=
quotient
[
2
]
;
quotient
[
2
]
=
quotient
[
1
]
;
quotient
[
1
]
=
quotient
[
0
]
;
quotient
[
0
]
=
0
;
blocks_to_process
+
=
1
;
}
let
mut
block
=
blocks_to_process
<
<
5
;
let
mut
working
=
[
0u32
0u32
0u32
0u32
]
;
while
block
<
128
{
let
carry
=
shl1_internal
(
quotient
0
)
;
shl1_internal
(
remainder
carry
)
;
working
.
copy_from_slice
(
remainder
)
;
add_by_internal
(
&
mut
working
&
complement
)
;
if
(
working
[
3
]
&
0x8000_0000
)
=
=
0
{
remainder
.
copy_from_slice
(
&
working
)
;
quotient
[
0
]
|
=
1
;
}
block
+
=
1
;
}
}
#
[
inline
]
fn
copy_array_diff_lengths
(
into
:
&
mut
[
u32
]
from
:
&
[
u32
]
)
{
for
i
in
0
.
.
into
.
len
(
)
{
if
i
>
=
from
.
len
(
)
{
break
;
}
into
[
i
]
=
from
[
i
]
;
}
}
#
[
inline
]
fn
add_one_internal4
(
value
:
&
mut
[
u32
;
4
]
)
-
>
u32
{
let
mut
carry
:
u64
=
1
;
let
mut
sum
:
u64
;
for
i
in
value
.
iter_mut
(
)
{
sum
=
(
*
i
as
u64
)
+
carry
;
*
i
=
(
sum
&
U32_MASK
)
as
u32
;
carry
=
sum
>
>
32
;
}
carry
as
u32
}
#
[
inline
]
fn
add_by_internal3
(
value
:
&
mut
[
u32
;
3
]
by
:
&
[
u32
;
3
]
)
-
>
u32
{
let
mut
carry
:
u32
=
0
;
let
bl
=
by
.
len
(
)
;
for
i
in
0
.
.
bl
{
let
res1
=
value
[
i
]
.
overflowing_add
(
by
[
i
]
)
;
let
res2
=
res1
.
0
.
overflowing_add
(
carry
)
;
value
[
i
]
=
res2
.
0
;
carry
=
(
res1
.
1
|
res2
.
1
)
as
u32
;
}
carry
}
#
[
inline
]
const
fn
u64_to_array
(
value
:
u64
)
-
>
[
u32
;
2
]
{
[
(
value
&
U32_MASK
)
as
u32
(
value
>
>
32
&
U32_MASK
)
as
u32
]
}
fn
add_with_scale_internal
(
quotient
:
&
mut
[
u32
;
3
]
quotient_scale
:
&
mut
i32
working_quotient
:
&
mut
[
u32
;
4
]
working_scale
:
&
mut
i32
)
-
>
bool
{
if
is_all_zero
(
quotient
)
{
while
working_quotient
[
3
]
!
=
0
{
div_by_u32
(
working_quotient
10
)
;
*
working_scale
-
=
1
;
}
copy_array_diff_lengths
(
quotient
working_quotient
)
;
*
quotient_scale
=
*
working_scale
;
return
false
;
}
if
is_all_zero
(
working_quotient
)
{
return
false
;
}
let
mut
temp3
=
[
0u32
0u32
0u32
]
;
let
mut
temp4
=
[
0u32
0u32
0u32
0u32
]
;
if
*
quotient_scale
!
=
*
working_scale
{
fn
div_by_10
(
target
:
&
mut
[
u32
]
temp
:
&
mut
[
u32
]
scale
:
&
mut
i32
target_scale
:
i32
)
{
temp
.
copy_from_slice
(
target
)
;
while
*
scale
>
target_scale
{
let
remainder
=
div_by_u32
(
temp
10
)
;
if
remainder
=
=
0
{
*
scale
-
=
1
;
target
.
copy_from_slice
(
&
temp
)
;
}
else
{
break
;
}
}
}
if
*
quotient_scale
<
*
working_scale
{
div_by_10
(
working_quotient
&
mut
temp4
working_scale
*
quotient_scale
)
;
}
else
{
div_by_10
(
quotient
&
mut
temp3
quotient_scale
*
working_scale
)
;
}
}
if
*
quotient_scale
!
=
*
working_scale
{
fn
mul_by_10
(
target
:
&
mut
[
u32
]
temp
:
&
mut
[
u32
]
scale
:
&
mut
i32
target_scale
:
i32
)
{
temp
.
copy_from_slice
(
target
)
;
let
mut
overflow
=
0
;
while
*
scale
<
target_scale
&
&
overflow
=
=
0
{
overflow
=
mul_by_u32
(
temp
10
)
;
if
overflow
=
=
0
{
*
scale
+
=
1
;
target
.
copy_from_slice
(
&
temp
)
;
}
}
}
if
*
quotient_scale
>
*
working_scale
{
mul_by_10
(
working_quotient
&
mut
temp4
working_scale
*
quotient_scale
)
;
}
else
{
mul_by_10
(
quotient
&
mut
temp3
quotient_scale
*
working_scale
)
;
}
}
if
*
quotient_scale
!
=
*
working_scale
{
fn
div_by_10_lossy
(
target
:
&
mut
[
u32
]
temp
:
&
mut
[
u32
]
scale
:
&
mut
i32
target_scale
:
i32
)
{
temp
.
copy_from_slice
(
target
)
;
while
*
scale
>
target_scale
{
div_by_u32
(
temp
10
)
;
*
scale
-
=
1
;
target
.
copy_from_slice
(
&
temp
)
;
}
}
if
*
quotient_scale
<
*
working_scale
{
div_by_10_lossy
(
working_quotient
&
mut
temp4
working_scale
*
quotient_scale
)
;
}
else
{
div_by_10_lossy
(
quotient
&
mut
temp3
quotient_scale
*
working_scale
)
;
}
}
if
is_all_zero
(
quotient
)
|
|
is_all_zero
(
working_quotient
)
{
return
true
;
}
else
{
let
mut
underflow
=
false
;
let
mut
temp
=
[
0u32
0u32
0u32
]
;
while
!
underflow
{
temp
.
copy_from_slice
(
quotient
)
;
let
overflow
=
add_by_internal
(
&
mut
temp
working_quotient
)
;
if
overflow
=
=
0
{
quotient
.
copy_from_slice
(
&
temp
)
;
break
;
}
else
{
div_by_u32
(
quotient
10
)
;
*
quotient_scale
-
=
1
;
div_by_u32
(
working_quotient
10
)
;
*
working_scale
-
=
1
;
underflow
=
is_all_zero
(
quotient
)
|
|
is_all_zero
(
working_quotient
)
;
}
}
if
underflow
{
return
true
;
}
}
false
}
#
[
inline
(
always
)
]
fn
rescale_to_maximum_scale
(
left
:
&
mut
[
u32
;
3
]
left_scale
:
&
mut
u32
right
:
&
mut
[
u32
;
3
]
right_scale
:
&
mut
u32
)
{
if
left_scale
=
=
right_scale
{
return
;
}
if
is_all_zero
(
left
)
{
*
left_scale
=
*
right_scale
;
return
;
}
else
if
is_all_zero
(
right
)
{
*
right_scale
=
*
left_scale
;
return
;
}
if
left_scale
>
right_scale
{
rescale_internal
(
right
right_scale
*
left_scale
)
;
if
right_scale
!
=
left_scale
{
rescale_internal
(
left
left_scale
*
right_scale
)
;
}
}
else
{
rescale_internal
(
left
left_scale
*
right_scale
)
;
if
right_scale
!
=
left_scale
{
rescale_internal
(
right
right_scale
*
left_scale
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
prelude
:
:
*
;
#
[
test
]
fn
it_can_rescale_to_maximum_scale
(
)
{
fn
extract
(
value
:
&
str
)
-
>
(
[
u32
;
3
]
u32
)
{
let
v
=
Decimal
:
:
from_str
(
value
)
.
unwrap
(
)
;
(
v
.
mantissa_array3
(
)
v
.
scale
(
)
)
}
let
tests
=
&
[
(
"
1
"
"
1
"
"
1
"
"
1
"
)
(
"
1
"
"
1
.
0
"
"
1
.
0
"
"
1
.
0
"
)
(
"
1
"
"
1
.
00000
"
"
1
.
00000
"
"
1
.
00000
"
)
(
"
1
"
"
1
.
0000000000
"
"
1
.
0000000000
"
"
1
.
0000000000
"
)
(
"
1
"
"
1
.
00000000000000000000
"
"
1
.
00000000000000000000
"
"
1
.
00000000000000000000
"
)
(
"
1
.
1
"
"
1
.
1
"
"
1
.
1
"
"
1
.
1
"
)
(
"
1
.
1
"
"
1
.
10000
"
"
1
.
10000
"
"
1
.
10000
"
)
(
"
1
.
1
"
"
1
.
1000000000
"
"
1
.
1000000000
"
"
1
.
1000000000
"
)
(
"
1
.
1
"
"
1
.
10000000000000000000
"
"
1
.
10000000000000000000
"
"
1
.
10000000000000000000
"
)
(
"
0
.
6386554621848739495798319328
"
"
11
.
815126050420168067226890757
"
"
0
.
638655462184873949579831933
"
"
11
.
815126050420168067226890757
"
)
(
"
0
.
0872727272727272727272727272
"
"
843
.
65000000
"
"
0
.
0872727272727272727272727
"
"
843
.
6500000000000000000000000
"
)
]
;
for
&
(
left_raw
right_raw
expected_left
expected_right
)
in
tests
{
let
(
expected_left
expected_lscale
)
=
extract
(
expected_left
)
;
let
(
expected_right
expected_rscale
)
=
extract
(
expected_right
)
;
let
(
mut
left
mut
left_scale
)
=
extract
(
left_raw
)
;
let
(
mut
right
mut
right_scale
)
=
extract
(
right_raw
)
;
rescale_to_maximum_scale
(
&
mut
left
&
mut
left_scale
&
mut
right
&
mut
right_scale
)
;
assert_eq
!
(
left
expected_left
)
;
assert_eq
!
(
left_scale
expected_lscale
)
;
assert_eq
!
(
right
expected_right
)
;
assert_eq
!
(
right_scale
expected_rscale
)
;
let
(
mut
left
mut
left_scale
)
=
extract
(
left_raw
)
;
let
(
mut
right
mut
right_scale
)
=
extract
(
right_raw
)
;
rescale_to_maximum_scale
(
&
mut
right
&
mut
right_scale
&
mut
left
&
mut
left_scale
)
;
assert_eq
!
(
left
expected_left
)
;
assert_eq
!
(
left_scale
expected_lscale
)
;
assert_eq
!
(
right
expected_right
)
;
assert_eq
!
(
right_scale
expected_rscale
)
;
}
}
}
