use
crate
:
:
constants
:
:
{
BIG_POWERS_10
MAX_I64_SCALE
MAX_PRECISION
U32_MAX
}
;
use
crate
:
:
decimal
:
:
{
CalculationResult
Decimal
}
;
use
crate
:
:
ops
:
:
common
:
:
Buf24
;
pub
(
crate
)
fn
mul_impl
(
d1
:
&
Decimal
d2
:
&
Decimal
)
-
>
CalculationResult
{
if
d1
.
is_zero
(
)
|
|
d2
.
is_zero
(
)
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
ZERO
)
;
}
let
mut
scale
=
d1
.
scale
(
)
+
d2
.
scale
(
)
;
let
negative
=
d1
.
is_sign_negative
(
)
^
d2
.
is_sign_negative
(
)
;
let
mut
product
=
Buf24
:
:
zero
(
)
;
if
d1
.
hi
(
)
|
d1
.
mid
(
)
=
=
0
{
if
d2
.
hi
(
)
|
d2
.
mid
(
)
=
=
0
{
let
mut
low64
=
d1
.
lo
(
)
as
u64
*
d2
.
lo
(
)
as
u64
;
if
scale
>
MAX_PRECISION
{
if
scale
>
MAX_PRECISION
+
MAX_I64_SCALE
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
ZERO
)
;
}
scale
-
=
MAX_PRECISION
+
1
;
let
mut
power
=
BIG_POWERS_10
[
scale
as
usize
]
;
let
tmp
=
low64
/
power
;
let
remainder
=
low64
-
tmp
*
power
;
low64
=
tmp
;
power
>
>
=
1
;
if
remainder
>
=
power
&
&
(
remainder
>
power
|
|
(
low64
as
u32
&
1
)
>
0
)
{
low64
+
=
1
;
}
scale
=
MAX_PRECISION
;
}
return
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
low64
as
u32
(
low64
>
>
32
)
as
u32
0
negative
scale
)
)
;
}
mul_by_32bit_lhs
(
d1
.
lo
(
)
as
u64
&
d2
&
mut
product
)
;
}
else
if
d2
.
mid
(
)
|
d2
.
hi
(
)
=
=
0
{
mul_by_32bit_lhs
(
d2
.
lo
(
)
as
u64
&
d1
&
mut
product
)
;
}
else
{
let
mut
tmp
=
d1
.
lo
(
)
as
u64
*
d2
.
lo
(
)
as
u64
;
product
.
data
[
0
]
=
tmp
as
u32
;
let
mut
tmp2
=
(
d1
.
lo
(
)
as
u64
*
d2
.
mid
(
)
as
u64
)
.
wrapping_add
(
tmp
>
>
32
)
;
tmp
=
d1
.
mid
(
)
as
u64
*
d2
.
lo
(
)
as
u64
;
tmp
=
tmp
.
wrapping_add
(
tmp2
)
;
product
.
data
[
1
]
=
tmp
as
u32
;
if
tmp
<
tmp2
{
tmp2
=
(
tmp
>
>
32
)
|
(
1u64
<
<
32
)
;
}
else
{
tmp2
=
tmp
>
>
32
;
}
tmp
=
(
d1
.
mid
(
)
as
u64
*
d2
.
mid
(
)
as
u64
)
+
tmp2
;
if
(
d1
.
hi
(
)
|
d2
.
hi
(
)
)
>
0
{
tmp2
=
d1
.
lo
(
)
as
u64
*
d2
.
hi
(
)
as
u64
;
tmp
=
tmp
.
wrapping_add
(
tmp2
)
;
let
mut
tmp3
=
if
tmp
<
tmp2
{
1
}
else
{
0
}
;
tmp2
=
d1
.
hi
(
)
as
u64
*
d2
.
lo
(
)
as
u64
;
tmp
=
tmp
.
wrapping_add
(
tmp2
)
;
product
.
data
[
2
]
=
tmp
as
u32
;
if
tmp
<
tmp2
{
tmp3
+
=
1
;
}
tmp2
=
(
tmp3
<
<
32
)
|
(
tmp
>
>
32
)
;
tmp
=
d1
.
mid
(
)
as
u64
*
d2
.
hi
(
)
as
u64
;
tmp
=
tmp
.
wrapping_add
(
tmp2
)
;
tmp3
=
if
tmp
<
tmp2
{
1
}
else
{
0
}
;
tmp2
=
d1
.
hi
(
)
as
u64
*
d2
.
mid
(
)
as
u64
;
tmp
=
tmp
.
wrapping_add
(
tmp2
)
;
product
.
data
[
3
]
=
tmp
as
u32
;
if
tmp
<
tmp2
{
tmp3
+
=
1
;
}
tmp
=
(
tmp3
<
<
32
)
|
(
tmp
>
>
32
)
;
product
.
set_high64
(
d1
.
hi
(
)
as
u64
*
d2
.
hi
(
)
as
u64
+
tmp
)
;
}
else
{
product
.
set_mid64
(
tmp
)
;
}
}
let
upper_word
=
product
.
upper_word
(
)
;
if
upper_word
>
2
|
|
scale
>
MAX_PRECISION
{
scale
=
if
let
Some
(
new_scale
)
=
product
.
rescale
(
upper_word
scale
)
{
new_scale
}
else
{
return
CalculationResult
:
:
Overflow
;
}
}
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
product
.
data
[
0
]
product
.
data
[
1
]
product
.
data
[
2
]
negative
scale
)
)
}
#
[
inline
(
always
)
]
fn
mul_by_32bit_lhs
(
d1
:
u64
d2
:
&
Decimal
product
:
&
mut
Buf24
)
{
let
mut
tmp
=
d1
*
d2
.
lo
(
)
as
u64
;
product
.
data
[
0
]
=
tmp
as
u32
;
tmp
=
(
d1
*
d2
.
mid
(
)
as
u64
)
.
wrapping_add
(
tmp
>
>
32
)
;
product
.
data
[
1
]
=
tmp
as
u32
;
tmp
>
>
=
32
;
if
d2
.
hi
(
)
>
0
{
tmp
=
tmp
.
wrapping_add
(
d1
*
d2
.
hi
(
)
as
u64
)
;
if
tmp
>
U32_MAX
{
product
.
set_mid64
(
tmp
)
;
}
else
{
product
.
data
[
2
]
=
tmp
as
u32
;
}
}
else
{
product
.
data
[
2
]
=
tmp
as
u32
;
}
}
