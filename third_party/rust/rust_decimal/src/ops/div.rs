use
crate
:
:
constants
:
:
{
MAX_PRECISION_I32
POWERS_10
}
;
use
crate
:
:
decimal
:
:
{
CalculationResult
Decimal
}
;
use
crate
:
:
ops
:
:
common
:
:
{
Buf12
Buf16
Dec64
}
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
ops
:
:
BitXor
;
impl
Buf12
{
fn
add32
(
&
mut
self
value
:
u32
)
-
>
Result
<
(
)
DivError
>
{
let
value
=
value
as
u64
;
let
new
=
self
.
low64
(
)
.
wrapping_add
(
value
)
;
self
.
set_low64
(
new
)
;
if
new
<
value
{
self
.
data
[
2
]
=
self
.
data
[
2
]
.
wrapping_add
(
1
)
;
if
self
.
data
[
2
]
=
=
0
{
return
Err
(
DivError
:
:
Overflow
)
;
}
}
Ok
(
(
)
)
}
fn
div32
(
&
mut
self
divisor
:
u32
)
-
>
u32
{
let
divisor64
=
divisor
as
u64
;
if
self
.
data
[
2
]
!
=
0
{
let
mut
temp
=
self
.
high64
(
)
;
let
q64
=
temp
/
divisor64
;
self
.
set_high64
(
q64
)
;
temp
=
(
(
temp
-
q64
*
divisor64
)
<
<
32
)
|
(
self
.
data
[
0
]
as
u64
)
;
if
temp
=
=
0
{
return
0
;
}
let
q32
=
(
temp
/
divisor64
)
as
u32
;
self
.
data
[
0
]
=
q32
;
(
(
temp
as
u32
)
.
wrapping_sub
(
q32
.
wrapping_mul
(
divisor
)
)
)
as
u32
}
else
{
let
low64
=
self
.
low64
(
)
;
if
low64
=
=
0
{
return
0
;
}
let
quotient
=
low64
/
divisor64
;
self
.
set_low64
(
quotient
)
;
(
low64
.
wrapping_sub
(
quotient
.
wrapping_mul
(
divisor64
)
)
)
as
u32
}
}
fn
div32_const
(
&
mut
self
pow
:
u32
)
-
>
bool
{
let
pow64
=
pow
as
u64
;
let
high64
=
self
.
high64
(
)
;
let
lo
=
self
.
data
[
0
]
as
u64
;
let
div64
:
u64
=
high64
/
pow64
;
let
div
=
(
(
(
(
high64
-
div64
*
pow64
)
<
<
32
)
+
lo
)
/
pow64
)
as
u32
;
if
self
.
data
[
0
]
=
=
div
.
wrapping_mul
(
pow
)
{
self
.
set_high64
(
div64
)
;
self
.
data
[
0
]
=
div
;
true
}
else
{
false
}
}
}
impl
Buf16
{
pub
(
super
)
fn
partial_divide_64
(
&
mut
self
divisor
:
u64
)
-
>
u32
{
debug_assert
!
(
divisor
>
self
.
mid64
(
)
)
;
if
self
.
data
[
2
]
=
=
0
{
let
low64
=
self
.
low64
(
)
;
if
low64
<
divisor
{
return
0
;
}
let
quotient
=
low64
/
divisor
;
self
.
set_low64
(
low64
-
(
quotient
*
divisor
)
)
;
return
quotient
as
u32
;
}
let
divisor_hi32
=
(
divisor
>
>
32
)
as
u32
;
if
self
.
data
[
2
]
>
=
divisor_hi32
{
let
mut
low64
=
self
.
low64
(
)
;
low64
=
low64
.
wrapping_sub
(
divisor
<
<
32
)
.
wrapping_add
(
divisor
)
;
let
mut
quotient
=
u32
:
:
MAX
;
loop
{
if
low64
<
divisor
{
break
;
}
quotient
=
quotient
.
wrapping_sub
(
1
)
;
low64
=
low64
.
wrapping_add
(
divisor
)
;
}
self
.
set_low64
(
low64
)
;
return
quotient
;
}
let
mid64
=
self
.
mid64
(
)
;
let
divisor_hi32_64
=
divisor_hi32
as
u64
;
if
mid64
<
divisor_hi32_64
as
u64
{
return
0
;
}
let
mut
quotient
=
mid64
/
divisor_hi32_64
;
let
mut
remainder
=
self
.
data
[
0
]
as
u64
|
(
(
mid64
-
quotient
*
divisor_hi32_64
)
<
<
32
)
;
let
product
=
quotient
*
(
divisor
&
0xFFFF_FFFF
)
;
remainder
=
remainder
.
wrapping_sub
(
product
)
;
if
remainder
>
product
.
bitxor
(
u64
:
:
MAX
)
{
loop
{
quotient
=
quotient
.
wrapping_sub
(
1
)
;
remainder
=
remainder
.
wrapping_add
(
divisor
)
;
if
remainder
<
divisor
{
break
;
}
}
}
self
.
set_low64
(
remainder
)
;
quotient
as
u32
}
pub
(
super
)
fn
partial_divide_96
(
&
mut
self
divisor
:
&
Buf12
)
-
>
u32
{
let
dividend
=
self
.
high64
(
)
;
let
divisor_hi
=
divisor
.
data
[
2
]
;
if
dividend
<
divisor_hi
as
u64
{
return
0
;
}
let
mut
quo
=
(
dividend
/
divisor_hi
as
u64
)
as
u32
;
let
mut
remainder
=
(
dividend
as
u32
)
.
wrapping_sub
(
quo
.
wrapping_mul
(
divisor_hi
)
)
;
let
mut
prod1
=
quo
as
u64
*
divisor
.
data
[
0
]
as
u64
;
let
mut
prod2
=
quo
as
u64
*
divisor
.
data
[
1
]
as
u64
;
prod2
+
=
prod1
>
>
32
;
prod1
=
(
prod1
&
0xFFFF_FFFF
)
|
(
prod2
<
<
32
)
;
prod2
>
>
=
32
;
let
mut
num
=
self
.
low64
(
)
;
num
=
num
.
wrapping_sub
(
prod1
)
;
remainder
=
remainder
.
wrapping_sub
(
prod2
as
u32
)
;
if
num
>
prod1
.
bitxor
(
u64
:
:
MAX
)
{
remainder
=
remainder
.
wrapping_sub
(
1
)
;
if
remainder
<
(
prod2
as
u32
)
.
bitxor
(
u32
:
:
MAX
)
{
self
.
set_low64
(
num
)
;
self
.
data
[
2
]
=
remainder
;
return
quo
;
}
}
else
if
remainder
<
=
(
prod2
as
u32
)
.
bitxor
(
u32
:
:
MAX
)
{
self
.
set_low64
(
num
)
;
self
.
data
[
2
]
=
remainder
;
return
quo
;
}
prod1
=
divisor
.
low64
(
)
;
loop
{
quo
=
quo
.
wrapping_sub
(
1
)
;
num
=
num
.
wrapping_add
(
prod1
)
;
remainder
=
remainder
.
wrapping_add
(
divisor_hi
)
;
if
num
<
prod1
{
let
tmp
=
remainder
;
remainder
=
remainder
.
wrapping_add
(
1
)
;
if
tmp
<
divisor_hi
{
break
;
}
}
if
remainder
<
divisor_hi
{
break
;
}
}
self
.
set_low64
(
num
)
;
self
.
data
[
2
]
=
remainder
;
quo
}
}
enum
DivError
{
Overflow
}
pub
(
crate
)
fn
div_impl
(
dividend
:
&
Decimal
divisor
:
&
Decimal
)
-
>
CalculationResult
{
if
divisor
.
is_zero
(
)
{
return
CalculationResult
:
:
DivByZero
;
}
if
dividend
.
is_zero
(
)
{
return
CalculationResult
:
:
Ok
(
Decimal
:
:
ZERO
)
;
}
let
dividend
=
Dec64
:
:
new
(
dividend
)
;
let
divisor
=
Dec64
:
:
new
(
divisor
)
;
let
mut
scale
=
(
dividend
.
scale
as
i32
)
-
(
divisor
.
scale
as
i32
)
;
let
sign_negative
=
dividend
.
negative
^
divisor
.
negative
;
let
mut
require_unscale
=
false
;
let
mut
quotient
=
Buf12
:
:
from_dec64
(
&
dividend
)
;
let
divisor
=
Buf12
:
:
from_dec64
(
&
divisor
)
;
if
divisor
.
data
[
2
]
|
divisor
.
data
[
1
]
=
=
0
{
let
divisor32
=
divisor
.
data
[
0
]
;
let
mut
remainder
=
quotient
.
div32
(
divisor32
)
;
let
mut
power_scale
=
0
;
loop
{
if
remainder
=
=
0
{
if
scale
>
=
0
{
break
;
}
power_scale
=
9usize
.
min
(
(
-
scale
)
as
usize
)
;
}
else
{
require_unscale
=
true
;
let
will_overflow
=
if
scale
=
=
MAX_PRECISION_I32
{
true
}
else
{
if
let
Some
(
s
)
=
quotient
.
find_scale
(
scale
)
{
power_scale
=
s
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
power_scale
=
=
0
}
;
if
will_overflow
{
let
tmp
=
remainder
<
<
1
;
let
round
=
if
tmp
<
remainder
{
true
}
else
if
tmp
>
=
divisor32
{
tmp
>
divisor32
|
|
(
quotient
.
data
[
0
]
&
0x1
)
>
0
}
else
{
false
}
;
if
round
{
if
let
Ok
(
new_scale
)
=
round_up
(
&
mut
quotient
scale
)
{
scale
=
new_scale
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
}
break
;
}
}
let
power
=
POWERS_10
[
power_scale
]
;
scale
+
=
power_scale
as
i32
;
let
overflow
=
increase_scale
(
&
mut
quotient
power
as
u64
)
;
if
overflow
>
0
{
return
CalculationResult
:
:
Overflow
;
}
let
remainder_scaled
=
(
remainder
as
u64
)
*
(
power
as
u64
)
;
let
remainder_quotient
=
(
remainder_scaled
/
(
divisor32
as
u64
)
)
as
u32
;
remainder
=
(
remainder_scaled
-
remainder_quotient
as
u64
*
divisor32
as
u64
)
as
u32
;
if
let
Err
(
DivError
:
:
Overflow
)
=
quotient
.
add32
(
remainder_quotient
)
{
if
let
Ok
(
adj
)
=
unscale_from_overflow
(
&
mut
quotient
scale
remainder
!
=
0
)
{
scale
=
adj
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
break
;
}
}
}
else
{
let
mut
power_scale
=
if
divisor
.
data
[
2
]
=
=
0
{
divisor
.
data
[
1
]
.
leading_zeros
(
)
}
else
{
divisor
.
data
[
2
]
.
leading_zeros
(
)
}
as
usize
;
let
mut
remainder
=
Buf16
:
:
zero
(
)
;
remainder
.
set_low64
(
quotient
.
low64
(
)
<
<
power_scale
)
;
let
tmp_high
=
(
(
quotient
.
data
[
1
]
as
u64
)
+
(
(
quotient
.
data
[
2
]
as
u64
)
<
<
32
)
)
>
>
(
32
-
power_scale
)
;
remainder
.
set_high64
(
tmp_high
)
;
let
divisor64
=
divisor
.
low64
(
)
<
<
power_scale
;
if
divisor
.
data
[
2
]
=
=
0
{
quotient
.
data
[
2
]
=
0
;
let
rem_lo
=
remainder
.
data
[
0
]
;
remainder
.
data
[
0
]
=
remainder
.
data
[
1
]
;
remainder
.
data
[
1
]
=
remainder
.
data
[
2
]
;
remainder
.
data
[
2
]
=
remainder
.
data
[
3
]
;
quotient
.
data
[
1
]
=
remainder
.
partial_divide_64
(
divisor64
)
;
remainder
.
data
[
2
]
=
remainder
.
data
[
1
]
;
remainder
.
data
[
1
]
=
remainder
.
data
[
0
]
;
remainder
.
data
[
0
]
=
rem_lo
;
quotient
.
data
[
0
]
=
remainder
.
partial_divide_64
(
divisor64
)
;
loop
{
let
rem_low64
=
remainder
.
low64
(
)
;
if
rem_low64
=
=
0
{
if
scale
>
=
0
{
break
;
}
power_scale
=
9usize
.
min
(
(
-
scale
)
as
usize
)
;
}
else
{
require_unscale
=
true
;
let
will_overflow
=
if
scale
=
=
MAX_PRECISION_I32
{
true
}
else
{
if
let
Some
(
s
)
=
quotient
.
find_scale
(
scale
)
{
power_scale
=
s
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
power_scale
=
=
0
}
;
if
will_overflow
{
let
mut
tmp
=
remainder
.
low64
(
)
;
let
round
=
if
(
tmp
as
i64
)
<
0
{
true
}
else
{
tmp
<
<
=
1
;
if
tmp
>
divisor64
{
true
}
else
{
tmp
=
=
divisor64
&
&
quotient
.
data
[
0
]
&
0x1
!
=
0
}
}
;
if
round
{
if
let
Ok
(
new_scale
)
=
round_up
(
&
mut
quotient
scale
)
{
scale
=
new_scale
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
}
break
;
}
}
let
power
=
POWERS_10
[
power_scale
]
;
scale
+
=
power_scale
as
i32
;
let
overflow
=
increase_scale
(
&
mut
quotient
power
as
u64
)
;
if
overflow
>
0
{
return
CalculationResult
:
:
Overflow
;
}
increase_scale64
(
&
mut
remainder
power
as
u64
)
;
let
tmp
=
remainder
.
partial_divide_64
(
divisor64
)
;
if
let
Err
(
DivError
:
:
Overflow
)
=
quotient
.
add32
(
tmp
)
{
if
let
Ok
(
adj
)
=
unscale_from_overflow
(
&
mut
quotient
scale
remainder
.
low64
(
)
!
=
0
)
{
scale
=
adj
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
break
;
}
}
}
else
{
let
divisor_mid
=
divisor
.
data
[
1
]
;
let
divisor_hi
=
divisor
.
data
[
2
]
;
let
mut
divisor
=
divisor
;
divisor
.
set_low64
(
divisor64
)
;
divisor
.
data
[
2
]
=
(
(
divisor_mid
as
u64
+
(
(
divisor_hi
as
u64
)
<
<
32
)
)
>
>
(
32
-
power_scale
)
)
as
u32
;
let
quo
=
remainder
.
partial_divide_96
(
&
divisor
)
;
quotient
.
set_low64
(
quo
as
u64
)
;
quotient
.
data
[
2
]
=
0
;
loop
{
let
mut
rem_low64
=
remainder
.
low64
(
)
;
if
rem_low64
=
=
0
&
&
remainder
.
data
[
2
]
=
=
0
{
if
scale
>
=
0
{
break
;
}
power_scale
=
9usize
.
min
(
(
-
scale
)
as
usize
)
;
}
else
{
require_unscale
=
true
;
let
will_overflow
=
if
scale
=
=
MAX_PRECISION_I32
{
true
}
else
{
if
let
Some
(
s
)
=
quotient
.
find_scale
(
scale
)
{
power_scale
=
s
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
power_scale
=
=
0
}
;
if
will_overflow
{
let
round
=
if
(
remainder
.
data
[
2
]
as
i32
)
<
0
{
true
}
else
{
let
tmp
=
remainder
.
data
[
1
]
>
>
31
;
rem_low64
<
<
=
1
;
remainder
.
set_low64
(
rem_low64
)
;
remainder
.
data
[
2
]
=
(
&
remainder
.
data
[
2
]
<
<
1
)
+
tmp
;
match
remainder
.
data
[
2
]
.
cmp
(
&
divisor
.
data
[
2
]
)
{
Ordering
:
:
Less
=
>
false
Ordering
:
:
Equal
=
>
{
let
divisor_low64
=
divisor
.
low64
(
)
;
if
rem_low64
>
divisor_low64
{
true
}
else
{
rem_low64
=
=
divisor_low64
&
&
(
quotient
.
data
[
0
]
&
1
)
!
=
0
}
}
Ordering
:
:
Greater
=
>
true
}
}
;
if
round
{
if
let
Ok
(
new_scale
)
=
round_up
(
&
mut
quotient
scale
)
{
scale
=
new_scale
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
}
break
;
}
}
let
power
=
POWERS_10
[
power_scale
]
;
scale
+
=
power_scale
as
i32
;
let
overflow
=
increase_scale
(
&
mut
quotient
power
as
u64
)
;
if
overflow
>
0
{
return
CalculationResult
:
:
Overflow
;
}
let
mut
tmp_remainder
=
Buf12
{
data
:
[
remainder
.
data
[
0
]
remainder
.
data
[
1
]
remainder
.
data
[
2
]
]
}
;
let
overflow
=
increase_scale
(
&
mut
tmp_remainder
power
as
u64
)
;
remainder
.
data
[
0
]
=
tmp_remainder
.
data
[
0
]
;
remainder
.
data
[
1
]
=
tmp_remainder
.
data
[
1
]
;
remainder
.
data
[
2
]
=
tmp_remainder
.
data
[
2
]
;
remainder
.
data
[
3
]
=
overflow
;
let
tmp
=
remainder
.
partial_divide_96
(
&
divisor
)
;
if
let
Err
(
DivError
:
:
Overflow
)
=
quotient
.
add32
(
tmp
)
{
if
let
Ok
(
adj
)
=
unscale_from_overflow
(
&
mut
quotient
scale
(
remainder
.
low64
(
)
|
remainder
.
high64
(
)
)
!
=
0
)
{
scale
=
adj
;
}
else
{
return
CalculationResult
:
:
Overflow
;
}
break
;
}
}
}
}
if
require_unscale
{
scale
=
unscale
(
&
mut
quotient
scale
)
;
}
CalculationResult
:
:
Ok
(
Decimal
:
:
from_parts
(
quotient
.
data
[
0
]
quotient
.
data
[
1
]
quotient
.
data
[
2
]
sign_negative
scale
as
u32
)
)
}
fn
increase_scale
(
num
:
&
mut
Buf12
power
:
u64
)
-
>
u32
{
let
mut
tmp
=
(
num
.
data
[
0
]
as
u64
)
*
power
;
num
.
data
[
0
]
=
tmp
as
u32
;
tmp
>
>
=
32
;
tmp
+
=
(
num
.
data
[
1
]
as
u64
)
*
power
;
num
.
data
[
1
]
=
tmp
as
u32
;
tmp
>
>
=
32
;
tmp
+
=
(
num
.
data
[
2
]
as
u64
)
*
power
;
num
.
data
[
2
]
=
tmp
as
u32
;
(
tmp
>
>
32
)
as
u32
}
fn
increase_scale64
(
num
:
&
mut
Buf16
power
:
u64
)
{
let
mut
tmp
=
(
num
.
data
[
0
]
as
u64
)
*
power
;
num
.
data
[
0
]
=
tmp
as
u32
;
tmp
>
>
=
32
;
tmp
+
=
(
num
.
data
[
1
]
as
u64
)
*
power
;
num
.
set_mid64
(
tmp
)
}
fn
unscale_from_overflow
(
num
:
&
mut
Buf12
scale
:
i32
sticky
:
bool
)
-
>
Result
<
i32
DivError
>
{
let
scale
=
scale
-
1
;
if
scale
<
0
{
return
Err
(
DivError
:
:
Overflow
)
;
}
const
HIGH_BIT
:
u64
=
0x1_0000_0000
;
num
.
data
[
2
]
=
(
HIGH_BIT
/
10
)
as
u32
;
let
mut
tmp
=
(
(
HIGH_BIT
%
10
)
<
<
32
)
+
(
num
.
data
[
1
]
as
u64
)
;
let
mut
val
=
(
tmp
/
10
)
as
u32
;
num
.
data
[
1
]
=
val
;
tmp
=
(
(
tmp
-
(
val
as
u64
)
*
10
)
<
<
32
)
+
(
num
.
data
[
0
]
as
u64
)
;
val
=
(
tmp
/
10
)
as
u32
;
num
.
data
[
0
]
=
val
;
let
remainder
=
(
tmp
-
(
val
as
u64
)
*
10
)
as
u32
;
if
remainder
>
5
|
|
(
remainder
=
=
5
&
&
(
sticky
|
|
num
.
data
[
0
]
&
0x1
>
0
)
)
{
let
_
=
num
.
add32
(
1
)
;
}
Ok
(
scale
)
}
#
[
inline
]
fn
round_up
(
num
:
&
mut
Buf12
scale
:
i32
)
-
>
Result
<
i32
DivError
>
{
let
low64
=
num
.
low64
(
)
.
wrapping_add
(
1
)
;
num
.
set_low64
(
low64
)
;
if
low64
!
=
0
{
return
Ok
(
scale
)
;
}
let
hi
=
num
.
data
[
2
]
.
wrapping_add
(
1
)
;
num
.
data
[
2
]
=
hi
;
if
hi
!
=
0
{
return
Ok
(
scale
)
;
}
unscale_from_overflow
(
num
scale
true
)
}
fn
unscale
(
num
:
&
mut
Buf12
scale
:
i32
)
-
>
i32
{
let
mut
scale
=
scale
;
while
num
.
data
[
0
]
=
=
0
&
&
scale
>
=
8
&
&
num
.
div32_const
(
100000000
)
{
scale
-
=
8
;
}
if
(
num
.
data
[
0
]
&
0xF
)
=
=
0
&
&
scale
>
=
4
&
&
num
.
div32_const
(
10000
)
{
scale
-
=
4
;
}
if
(
num
.
data
[
0
]
&
0x3
)
=
=
0
&
&
scale
>
=
2
&
&
num
.
div32_const
(
100
)
{
scale
-
=
2
;
}
if
(
num
.
data
[
0
]
&
0x1
)
=
=
0
&
&
scale
>
=
1
&
&
num
.
div32_const
(
10
)
{
scale
-
=
1
;
}
scale
}
