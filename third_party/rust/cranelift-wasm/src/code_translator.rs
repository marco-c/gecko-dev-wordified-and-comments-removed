use
cranelift_codegen
:
:
ir
:
:
condcodes
:
:
{
FloatCC
IntCC
}
;
use
cranelift_codegen
:
:
ir
:
:
types
:
:
*
;
use
cranelift_codegen
:
:
ir
:
:
{
self
InstBuilder
JumpTableData
MemFlags
}
;
use
cranelift_codegen
:
:
packed_option
:
:
ReservedValue
;
use
cranelift_entity
:
:
EntityRef
;
use
cranelift_frontend
:
:
{
FunctionBuilder
Variable
}
;
use
environ
:
:
{
FuncEnvironment
GlobalVariable
WasmError
WasmResult
}
;
use
state
:
:
{
ControlStackFrame
TranslationState
}
;
use
std
:
:
collections
:
:
{
hash_map
HashMap
}
;
use
std
:
:
vec
:
:
Vec
;
use
std
:
:
{
i32
u32
}
;
use
translation_utils
:
:
{
f32_translation
f64_translation
num_return_values
type_to_type
}
;
use
translation_utils
:
:
{
FuncIndex
MemoryIndex
SignatureIndex
TableIndex
}
;
use
wasmparser
:
:
{
MemoryImmediate
Operator
}
;
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
unneeded_field_pattern
)
)
]
pub
fn
translate_operator
<
FE
:
FuncEnvironment
+
?
Sized
>
(
op
:
Operator
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
environ
:
&
mut
FE
)
-
>
WasmResult
<
(
)
>
{
if
!
state
.
reachable
{
translate_unreachable_operator
(
&
op
builder
state
)
;
return
Ok
(
(
)
)
;
}
match
op
{
Operator
:
:
GetLocal
{
local_index
}
=
>
{
state
.
push1
(
builder
.
use_var
(
Variable
:
:
with_u32
(
local_index
)
)
)
}
Operator
:
:
SetLocal
{
local_index
}
=
>
{
let
val
=
state
.
pop1
(
)
;
builder
.
def_var
(
Variable
:
:
with_u32
(
local_index
)
val
)
;
}
Operator
:
:
TeeLocal
{
local_index
}
=
>
{
let
val
=
state
.
peek1
(
)
;
builder
.
def_var
(
Variable
:
:
with_u32
(
local_index
)
val
)
;
}
Operator
:
:
GetGlobal
{
global_index
}
=
>
{
let
val
=
match
state
.
get_global
(
builder
.
func
global_index
environ
)
{
GlobalVariable
:
:
Const
(
val
)
=
>
val
GlobalVariable
:
:
Memory
{
gv
ty
}
=
>
{
let
addr
=
builder
.
ins
(
)
.
global_value
(
environ
.
pointer_type
(
)
gv
)
;
let
mut
flags
=
ir
:
:
MemFlags
:
:
new
(
)
;
flags
.
set_notrap
(
)
;
flags
.
set_aligned
(
)
;
builder
.
ins
(
)
.
load
(
ty
flags
addr
0
)
}
}
;
state
.
push1
(
val
)
;
}
Operator
:
:
SetGlobal
{
global_index
}
=
>
{
match
state
.
get_global
(
builder
.
func
global_index
environ
)
{
GlobalVariable
:
:
Const
(
_
)
=
>
panic
!
(
"
global
#
{
}
is
a
constant
"
global_index
)
GlobalVariable
:
:
Memory
{
gv
.
.
}
=
>
{
let
addr
=
builder
.
ins
(
)
.
global_value
(
environ
.
pointer_type
(
)
gv
)
;
let
mut
flags
=
ir
:
:
MemFlags
:
:
new
(
)
;
flags
.
set_notrap
(
)
;
flags
.
set_aligned
(
)
;
let
val
=
state
.
pop1
(
)
;
builder
.
ins
(
)
.
store
(
flags
val
addr
0
)
;
}
}
}
Operator
:
:
Drop
=
>
{
state
.
pop1
(
)
;
}
Operator
:
:
Select
=
>
{
let
(
arg1
arg2
cond
)
=
state
.
pop3
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
select
(
cond
arg1
arg2
)
)
;
}
Operator
:
:
Nop
=
>
{
}
Operator
:
:
Unreachable
=
>
{
builder
.
ins
(
)
.
trap
(
ir
:
:
TrapCode
:
:
User
(
0
)
)
;
state
.
reachable
=
false
;
}
Operator
:
:
Block
{
ty
}
=
>
{
let
next
=
builder
.
create_ebb
(
)
;
if
let
Ok
(
ty_cre
)
=
type_to_type
(
ty
)
{
builder
.
append_ebb_param
(
next
ty_cre
)
;
}
state
.
push_block
(
next
num_return_values
(
ty
)
)
;
}
Operator
:
:
Loop
{
ty
}
=
>
{
let
loop_body
=
builder
.
create_ebb
(
)
;
let
next
=
builder
.
create_ebb
(
)
;
if
let
Ok
(
ty_cre
)
=
type_to_type
(
ty
)
{
builder
.
append_ebb_param
(
next
ty_cre
)
;
}
builder
.
ins
(
)
.
jump
(
loop_body
&
[
]
)
;
state
.
push_loop
(
loop_body
next
num_return_values
(
ty
)
)
;
builder
.
switch_to_block
(
loop_body
)
;
environ
.
translate_loop_header
(
builder
.
cursor
(
)
)
;
}
Operator
:
:
If
{
ty
}
=
>
{
let
val
=
state
.
pop1
(
)
;
let
if_not
=
builder
.
create_ebb
(
)
;
let
jump_inst
=
builder
.
ins
(
)
.
brz
(
val
if_not
&
[
]
)
;
if
let
Ok
(
ty_cre
)
=
type_to_type
(
ty
)
{
builder
.
append_ebb_param
(
if_not
ty_cre
)
;
}
state
.
push_if
(
jump_inst
if_not
num_return_values
(
ty
)
)
;
}
Operator
:
:
Else
=
>
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
;
let
(
destination
return_count
branch_inst
ref
mut
reachable_from_top
)
=
match
state
.
control_stack
[
i
]
{
ControlStackFrame
:
:
If
{
destination
num_return_values
branch_inst
reachable_from_top
.
.
}
=
>
(
destination
num_return_values
branch_inst
reachable_from_top
)
_
=
>
panic
!
(
"
should
not
happen
"
)
}
;
*
reachable_from_top
=
false
;
builder
.
ins
(
)
.
jump
(
destination
state
.
peekn
(
return_count
)
)
;
state
.
popn
(
return_count
)
;
let
else_ebb
=
builder
.
create_ebb
(
)
;
builder
.
change_jump_destination
(
branch_inst
else_ebb
)
;
builder
.
seal_block
(
else_ebb
)
;
builder
.
switch_to_block
(
else_ebb
)
;
}
Operator
:
:
End
=
>
{
let
frame
=
state
.
control_stack
.
pop
(
)
.
unwrap
(
)
;
if
!
builder
.
is_unreachable
(
)
|
|
!
builder
.
is_pristine
(
)
{
let
return_count
=
frame
.
num_return_values
(
)
;
builder
.
ins
(
)
.
jump
(
frame
.
following_code
(
)
state
.
peekn
(
return_count
)
)
;
}
builder
.
switch_to_block
(
frame
.
following_code
(
)
)
;
builder
.
seal_block
(
frame
.
following_code
(
)
)
;
if
let
ControlStackFrame
:
:
Loop
{
header
.
.
}
=
frame
{
builder
.
seal_block
(
header
)
}
state
.
stack
.
truncate
(
frame
.
original_stack_size
(
)
)
;
state
.
stack
.
extend_from_slice
(
builder
.
ebb_params
(
frame
.
following_code
(
)
)
)
;
}
Operator
:
:
Br
{
relative_depth
}
=
>
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
(
relative_depth
as
usize
)
;
let
(
return_count
br_destination
)
=
{
let
frame
=
&
mut
state
.
control_stack
[
i
]
;
frame
.
set_branched_to_exit
(
)
;
let
return_count
=
if
frame
.
is_loop
(
)
{
0
}
else
{
frame
.
num_return_values
(
)
}
;
(
return_count
frame
.
br_destination
(
)
)
}
;
builder
.
ins
(
)
.
jump
(
br_destination
state
.
peekn
(
return_count
)
)
;
state
.
popn
(
return_count
)
;
state
.
reachable
=
false
;
}
Operator
:
:
BrIf
{
relative_depth
}
=
>
translate_br_if
(
relative_depth
builder
state
)
Operator
:
:
BrTable
{
table
}
=
>
{
let
(
depths
default
)
=
table
.
read_table
(
)
;
let
mut
min_depth
=
default
;
for
depth
in
&
depths
{
if
*
depth
<
min_depth
{
min_depth
=
*
depth
;
}
}
let
jump_args_count
=
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
(
min_depth
as
usize
)
;
let
min_depth_frame
=
&
state
.
control_stack
[
i
]
;
if
min_depth_frame
.
is_loop
(
)
{
0
}
else
{
min_depth_frame
.
num_return_values
(
)
}
}
;
let
val
=
state
.
pop1
(
)
;
let
mut
data
=
JumpTableData
:
:
with_capacity
(
depths
.
len
(
)
)
;
if
jump_args_count
=
=
0
{
for
depth
in
depths
{
let
ebb
=
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
(
depth
as
usize
)
;
let
frame
=
&
mut
state
.
control_stack
[
i
]
;
frame
.
set_branched_to_exit
(
)
;
frame
.
br_destination
(
)
}
;
data
.
push_entry
(
ebb
)
;
}
let
jt
=
builder
.
create_jump_table
(
data
)
;
builder
.
ins
(
)
.
br_table
(
val
jt
)
;
let
ebb
=
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
(
default
as
usize
)
;
let
frame
=
&
mut
state
.
control_stack
[
i
]
;
frame
.
set_branched_to_exit
(
)
;
frame
.
br_destination
(
)
}
;
builder
.
ins
(
)
.
jump
(
ebb
&
[
]
)
;
}
else
{
let
return_count
=
jump_args_count
;
let
mut
dest_ebb_sequence
=
Vec
:
:
new
(
)
;
let
mut
dest_ebb_map
=
HashMap
:
:
new
(
)
;
for
depth
in
depths
{
let
branch_ebb
=
match
dest_ebb_map
.
entry
(
depth
as
usize
)
{
hash_map
:
:
Entry
:
:
Occupied
(
entry
)
=
>
*
entry
.
get
(
)
hash_map
:
:
Entry
:
:
Vacant
(
entry
)
=
>
{
let
ebb
=
builder
.
create_ebb
(
)
;
dest_ebb_sequence
.
push
(
(
depth
as
usize
ebb
)
)
;
*
entry
.
insert
(
ebb
)
}
}
;
data
.
push_entry
(
branch_ebb
)
;
}
let
jt
=
builder
.
create_jump_table
(
data
)
;
builder
.
ins
(
)
.
br_table
(
val
jt
)
;
let
default_ebb
=
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
(
default
as
usize
)
;
let
frame
=
&
mut
state
.
control_stack
[
i
]
;
frame
.
set_branched_to_exit
(
)
;
frame
.
br_destination
(
)
}
;
builder
.
ins
(
)
.
jump
(
default_ebb
state
.
peekn
(
return_count
)
)
;
for
(
depth
dest_ebb
)
in
dest_ebb_sequence
{
builder
.
switch_to_block
(
dest_ebb
)
;
builder
.
seal_block
(
dest_ebb
)
;
let
real_dest_ebb
=
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
depth
;
let
frame
=
&
mut
state
.
control_stack
[
i
]
;
frame
.
set_branched_to_exit
(
)
;
frame
.
br_destination
(
)
}
;
builder
.
ins
(
)
.
jump
(
real_dest_ebb
state
.
peekn
(
return_count
)
)
;
}
state
.
popn
(
return_count
)
;
}
state
.
reachable
=
false
;
}
Operator
:
:
Return
=
>
{
let
(
return_count
br_destination
)
=
{
let
frame
=
&
mut
state
.
control_stack
[
0
]
;
frame
.
set_branched_to_exit
(
)
;
let
return_count
=
frame
.
num_return_values
(
)
;
(
return_count
frame
.
br_destination
(
)
)
}
;
{
let
args
=
state
.
peekn
(
return_count
)
;
if
environ
.
flags
(
)
.
return_at_end
(
)
{
builder
.
ins
(
)
.
jump
(
br_destination
args
)
;
}
else
{
builder
.
ins
(
)
.
return_
(
args
)
;
}
}
state
.
popn
(
return_count
)
;
state
.
reachable
=
false
;
}
Operator
:
:
Call
{
function_index
}
=
>
{
let
(
fref
num_args
)
=
state
.
get_direct_func
(
builder
.
func
function_index
environ
)
;
let
call
=
environ
.
translate_call
(
builder
.
cursor
(
)
FuncIndex
:
:
new
(
function_index
as
usize
)
fref
state
.
peekn
(
num_args
)
)
?
;
let
inst_results
=
builder
.
inst_results
(
call
)
;
debug_assert_eq
!
(
inst_results
.
len
(
)
builder
.
func
.
dfg
.
signatures
[
builder
.
func
.
dfg
.
ext_funcs
[
fref
]
.
signature
]
.
returns
.
len
(
)
"
translate_call
results
should
match
the
call
signature
"
)
;
state
.
popn
(
num_args
)
;
state
.
pushn
(
inst_results
)
;
}
Operator
:
:
CallIndirect
{
index
table_index
}
=
>
{
let
(
sigref
num_args
)
=
state
.
get_indirect_sig
(
builder
.
func
index
environ
)
;
let
table
=
state
.
get_table
(
builder
.
func
table_index
environ
)
;
let
callee
=
state
.
pop1
(
)
;
let
call
=
environ
.
translate_call_indirect
(
builder
.
cursor
(
)
table_index
as
TableIndex
table
index
as
SignatureIndex
sigref
callee
state
.
peekn
(
num_args
)
)
?
;
let
inst_results
=
builder
.
inst_results
(
call
)
;
debug_assert_eq
!
(
inst_results
.
len
(
)
builder
.
func
.
dfg
.
signatures
[
sigref
]
.
returns
.
len
(
)
"
translate_call_indirect
results
should
match
the
call
signature
"
)
;
state
.
popn
(
num_args
)
;
state
.
pushn
(
inst_results
)
;
}
Operator
:
:
MemoryGrow
{
reserved
}
=
>
{
let
heap_index
=
reserved
as
MemoryIndex
;
let
heap
=
state
.
get_heap
(
builder
.
func
reserved
environ
)
;
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
environ
.
translate_memory_grow
(
builder
.
cursor
(
)
heap_index
heap
val
)
?
)
}
Operator
:
:
MemorySize
{
reserved
}
=
>
{
let
heap_index
=
reserved
as
MemoryIndex
;
let
heap
=
state
.
get_heap
(
builder
.
func
reserved
environ
)
;
state
.
push1
(
environ
.
translate_memory_size
(
builder
.
cursor
(
)
heap_index
heap
)
?
)
;
}
Operator
:
:
I32Load8U
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Uload8
I32
builder
state
environ
)
;
}
Operator
:
:
I32Load16U
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Uload16
I32
builder
state
environ
)
;
}
Operator
:
:
I32Load8S
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Sload8
I32
builder
state
environ
)
;
}
Operator
:
:
I32Load16S
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Sload16
I32
builder
state
environ
)
;
}
Operator
:
:
I64Load8U
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Uload8
I64
builder
state
environ
)
;
}
Operator
:
:
I64Load16U
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Uload16
I64
builder
state
environ
)
;
}
Operator
:
:
I64Load8S
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Sload8
I64
builder
state
environ
)
;
}
Operator
:
:
I64Load16S
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Sload16
I64
builder
state
environ
)
;
}
Operator
:
:
I64Load32S
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Sload32
I64
builder
state
environ
)
;
}
Operator
:
:
I64Load32U
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Uload32
I64
builder
state
environ
)
;
}
Operator
:
:
I32Load
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Load
I32
builder
state
environ
)
;
}
Operator
:
:
F32Load
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Load
F32
builder
state
environ
)
;
}
Operator
:
:
I64Load
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Load
I64
builder
state
environ
)
;
}
Operator
:
:
F64Load
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_load
(
offset
ir
:
:
Opcode
:
:
Load
F64
builder
state
environ
)
;
}
Operator
:
:
I32Store
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
|
Operator
:
:
I64Store
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
|
Operator
:
:
F32Store
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
|
Operator
:
:
F64Store
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_store
(
offset
ir
:
:
Opcode
:
:
Store
builder
state
environ
)
;
}
Operator
:
:
I32Store8
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
|
Operator
:
:
I64Store8
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_store
(
offset
ir
:
:
Opcode
:
:
Istore8
builder
state
environ
)
;
}
Operator
:
:
I32Store16
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
|
Operator
:
:
I64Store16
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_store
(
offset
ir
:
:
Opcode
:
:
Istore16
builder
state
environ
)
;
}
Operator
:
:
I64Store32
{
memarg
:
MemoryImmediate
{
flags
:
_
offset
}
}
=
>
{
translate_store
(
offset
ir
:
:
Opcode
:
:
Istore32
builder
state
environ
)
;
}
Operator
:
:
I32Const
{
value
}
=
>
state
.
push1
(
builder
.
ins
(
)
.
iconst
(
I32
i64
:
:
from
(
value
)
)
)
Operator
:
:
I64Const
{
value
}
=
>
state
.
push1
(
builder
.
ins
(
)
.
iconst
(
I64
value
)
)
Operator
:
:
F32Const
{
value
}
=
>
{
state
.
push1
(
builder
.
ins
(
)
.
f32const
(
f32_translation
(
value
)
)
)
;
}
Operator
:
:
F64Const
{
value
}
=
>
{
state
.
push1
(
builder
.
ins
(
)
.
f64const
(
f64_translation
(
value
)
)
)
;
}
Operator
:
:
I32Clz
|
Operator
:
:
I64Clz
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
clz
(
arg
)
)
;
}
Operator
:
:
I32Ctz
|
Operator
:
:
I64Ctz
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ctz
(
arg
)
)
;
}
Operator
:
:
I32Popcnt
|
Operator
:
:
I64Popcnt
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
popcnt
(
arg
)
)
;
}
Operator
:
:
I64ExtendSI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sextend
(
I64
val
)
)
;
}
Operator
:
:
I64ExtendUI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
uextend
(
I64
val
)
)
;
}
Operator
:
:
I32WrapI64
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ireduce
(
I32
val
)
)
;
}
Operator
:
:
F32Sqrt
|
Operator
:
:
F64Sqrt
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sqrt
(
arg
)
)
;
}
Operator
:
:
F32Ceil
|
Operator
:
:
F64Ceil
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ceil
(
arg
)
)
;
}
Operator
:
:
F32Floor
|
Operator
:
:
F64Floor
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
floor
(
arg
)
)
;
}
Operator
:
:
F32Trunc
|
Operator
:
:
F64Trunc
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
trunc
(
arg
)
)
;
}
Operator
:
:
F32Nearest
|
Operator
:
:
F64Nearest
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
nearest
(
arg
)
)
;
}
Operator
:
:
F32Abs
|
Operator
:
:
F64Abs
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fabs
(
val
)
)
;
}
Operator
:
:
F32Neg
|
Operator
:
:
F64Neg
=
>
{
let
arg
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fneg
(
arg
)
)
;
}
Operator
:
:
F64ConvertUI64
|
Operator
:
:
F64ConvertUI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_from_uint
(
F64
val
)
)
;
}
Operator
:
:
F64ConvertSI64
|
Operator
:
:
F64ConvertSI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_from_sint
(
F64
val
)
)
;
}
Operator
:
:
F32ConvertSI64
|
Operator
:
:
F32ConvertSI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_from_sint
(
F32
val
)
)
;
}
Operator
:
:
F32ConvertUI64
|
Operator
:
:
F32ConvertUI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_from_uint
(
F32
val
)
)
;
}
Operator
:
:
F64PromoteF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fpromote
(
F64
val
)
)
;
}
Operator
:
:
F32DemoteF64
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fdemote
(
F32
val
)
)
;
}
Operator
:
:
I64TruncSF64
|
Operator
:
:
I64TruncSF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_sint
(
I64
val
)
)
;
}
Operator
:
:
I32TruncSF64
|
Operator
:
:
I32TruncSF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_sint
(
I32
val
)
)
;
}
Operator
:
:
I64TruncUF64
|
Operator
:
:
I64TruncUF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_uint
(
I64
val
)
)
;
}
Operator
:
:
I32TruncUF64
|
Operator
:
:
I32TruncUF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_uint
(
I32
val
)
)
;
}
Operator
:
:
I64TruncSSatF64
|
Operator
:
:
I64TruncSSatF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_sint_sat
(
I64
val
)
)
;
}
Operator
:
:
I32TruncSSatF64
|
Operator
:
:
I32TruncSSatF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_sint_sat
(
I32
val
)
)
;
}
Operator
:
:
I64TruncUSatF64
|
Operator
:
:
I64TruncUSatF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_uint_sat
(
I64
val
)
)
;
}
Operator
:
:
I32TruncUSatF64
|
Operator
:
:
I32TruncUSatF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcvt_to_uint_sat
(
I32
val
)
)
;
}
Operator
:
:
F32ReinterpretI32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
bitcast
(
F32
val
)
)
;
}
Operator
:
:
F64ReinterpretI64
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
bitcast
(
F64
val
)
)
;
}
Operator
:
:
I32ReinterpretF32
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
bitcast
(
I32
val
)
)
;
}
Operator
:
:
I64ReinterpretF64
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
bitcast
(
I64
val
)
)
;
}
Operator
:
:
I32Extend8S
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ireduce
(
I8
val
)
)
;
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sextend
(
I32
val
)
)
;
}
Operator
:
:
I32Extend16S
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ireduce
(
I16
val
)
)
;
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sextend
(
I32
val
)
)
;
}
Operator
:
:
I64Extend8S
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ireduce
(
I8
val
)
)
;
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sextend
(
I64
val
)
)
;
}
Operator
:
:
I64Extend16S
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ireduce
(
I16
val
)
)
;
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sextend
(
I64
val
)
)
;
}
Operator
:
:
I64Extend32S
=
>
{
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ireduce
(
I32
val
)
)
;
let
val
=
state
.
pop1
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sextend
(
I64
val
)
)
;
}
Operator
:
:
I32Add
|
Operator
:
:
I64Add
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
iadd
(
arg1
arg2
)
)
;
}
Operator
:
:
I32And
|
Operator
:
:
I64And
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
band
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Or
|
Operator
:
:
I64Or
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
bor
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Xor
|
Operator
:
:
I64Xor
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
bxor
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Shl
|
Operator
:
:
I64Shl
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ishl
(
arg1
arg2
)
)
;
}
Operator
:
:
I32ShrS
|
Operator
:
:
I64ShrS
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sshr
(
arg1
arg2
)
)
;
}
Operator
:
:
I32ShrU
|
Operator
:
:
I64ShrU
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
ushr
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Rotl
|
Operator
:
:
I64Rotl
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
rotl
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Rotr
|
Operator
:
:
I64Rotr
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
rotr
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Add
|
Operator
:
:
F64Add
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fadd
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Sub
|
Operator
:
:
I64Sub
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
isub
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Sub
|
Operator
:
:
F64Sub
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fsub
(
arg1
arg2
)
)
;
}
Operator
:
:
I32Mul
|
Operator
:
:
I64Mul
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
imul
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Mul
|
Operator
:
:
F64Mul
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fmul
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Div
|
Operator
:
:
F64Div
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fdiv
(
arg1
arg2
)
)
;
}
Operator
:
:
I32DivS
|
Operator
:
:
I64DivS
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
sdiv
(
arg1
arg2
)
)
;
}
Operator
:
:
I32DivU
|
Operator
:
:
I64DivU
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
udiv
(
arg1
arg2
)
)
;
}
Operator
:
:
I32RemS
|
Operator
:
:
I64RemS
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
srem
(
arg1
arg2
)
)
;
}
Operator
:
:
I32RemU
|
Operator
:
:
I64RemU
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
urem
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Min
|
Operator
:
:
F64Min
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fmin
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Max
|
Operator
:
:
F64Max
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fmax
(
arg1
arg2
)
)
;
}
Operator
:
:
F32Copysign
|
Operator
:
:
F64Copysign
=
>
{
let
(
arg1
arg2
)
=
state
.
pop2
(
)
;
state
.
push1
(
builder
.
ins
(
)
.
fcopysign
(
arg1
arg2
)
)
;
}
Operator
:
:
I32LtS
|
Operator
:
:
I64LtS
=
>
{
translate_icmp
(
IntCC
:
:
SignedLessThan
builder
state
)
}
Operator
:
:
I32LtU
|
Operator
:
:
I64LtU
=
>
{
translate_icmp
(
IntCC
:
:
UnsignedLessThan
builder
state
)
}
Operator
:
:
I32LeS
|
Operator
:
:
I64LeS
=
>
{
translate_icmp
(
IntCC
:
:
SignedLessThanOrEqual
builder
state
)
}
Operator
:
:
I32LeU
|
Operator
:
:
I64LeU
=
>
{
translate_icmp
(
IntCC
:
:
UnsignedLessThanOrEqual
builder
state
)
}
Operator
:
:
I32GtS
|
Operator
:
:
I64GtS
=
>
{
translate_icmp
(
IntCC
:
:
SignedGreaterThan
builder
state
)
}
Operator
:
:
I32GtU
|
Operator
:
:
I64GtU
=
>
{
translate_icmp
(
IntCC
:
:
UnsignedGreaterThan
builder
state
)
}
Operator
:
:
I32GeS
|
Operator
:
:
I64GeS
=
>
{
translate_icmp
(
IntCC
:
:
SignedGreaterThanOrEqual
builder
state
)
}
Operator
:
:
I32GeU
|
Operator
:
:
I64GeU
=
>
{
translate_icmp
(
IntCC
:
:
UnsignedGreaterThanOrEqual
builder
state
)
}
Operator
:
:
I32Eqz
|
Operator
:
:
I64Eqz
=
>
{
let
arg
=
state
.
pop1
(
)
;
let
val
=
builder
.
ins
(
)
.
icmp_imm
(
IntCC
:
:
Equal
arg
0
)
;
state
.
push1
(
builder
.
ins
(
)
.
bint
(
I32
val
)
)
;
}
Operator
:
:
I32Eq
|
Operator
:
:
I64Eq
=
>
translate_icmp
(
IntCC
:
:
Equal
builder
state
)
Operator
:
:
F32Eq
|
Operator
:
:
F64Eq
=
>
translate_fcmp
(
FloatCC
:
:
Equal
builder
state
)
Operator
:
:
I32Ne
|
Operator
:
:
I64Ne
=
>
translate_icmp
(
IntCC
:
:
NotEqual
builder
state
)
Operator
:
:
F32Ne
|
Operator
:
:
F64Ne
=
>
translate_fcmp
(
FloatCC
:
:
NotEqual
builder
state
)
Operator
:
:
F32Gt
|
Operator
:
:
F64Gt
=
>
translate_fcmp
(
FloatCC
:
:
GreaterThan
builder
state
)
Operator
:
:
F32Ge
|
Operator
:
:
F64Ge
=
>
{
translate_fcmp
(
FloatCC
:
:
GreaterThanOrEqual
builder
state
)
}
Operator
:
:
F32Lt
|
Operator
:
:
F64Lt
=
>
translate_fcmp
(
FloatCC
:
:
LessThan
builder
state
)
Operator
:
:
F32Le
|
Operator
:
:
F64Le
=
>
{
translate_fcmp
(
FloatCC
:
:
LessThanOrEqual
builder
state
)
}
Operator
:
:
Wake
{
.
.
}
|
Operator
:
:
I32Wait
{
.
.
}
|
Operator
:
:
I64Wait
{
.
.
}
|
Operator
:
:
I32AtomicLoad
{
.
.
}
|
Operator
:
:
I64AtomicLoad
{
.
.
}
|
Operator
:
:
I32AtomicLoad8U
{
.
.
}
|
Operator
:
:
I32AtomicLoad16U
{
.
.
}
|
Operator
:
:
I64AtomicLoad8U
{
.
.
}
|
Operator
:
:
I64AtomicLoad16U
{
.
.
}
|
Operator
:
:
I64AtomicLoad32U
{
.
.
}
|
Operator
:
:
I32AtomicStore
{
.
.
}
|
Operator
:
:
I64AtomicStore
{
.
.
}
|
Operator
:
:
I32AtomicStore8
{
.
.
}
|
Operator
:
:
I32AtomicStore16
{
.
.
}
|
Operator
:
:
I64AtomicStore8
{
.
.
}
|
Operator
:
:
I64AtomicStore16
{
.
.
}
|
Operator
:
:
I64AtomicStore32
{
.
.
}
|
Operator
:
:
I32AtomicRmwAdd
{
.
.
}
|
Operator
:
:
I64AtomicRmwAdd
{
.
.
}
|
Operator
:
:
I32AtomicRmw8UAdd
{
.
.
}
|
Operator
:
:
I32AtomicRmw16UAdd
{
.
.
}
|
Operator
:
:
I64AtomicRmw8UAdd
{
.
.
}
|
Operator
:
:
I64AtomicRmw16UAdd
{
.
.
}
|
Operator
:
:
I64AtomicRmw32UAdd
{
.
.
}
|
Operator
:
:
I32AtomicRmwSub
{
.
.
}
|
Operator
:
:
I64AtomicRmwSub
{
.
.
}
|
Operator
:
:
I32AtomicRmw8USub
{
.
.
}
|
Operator
:
:
I32AtomicRmw16USub
{
.
.
}
|
Operator
:
:
I64AtomicRmw8USub
{
.
.
}
|
Operator
:
:
I64AtomicRmw16USub
{
.
.
}
|
Operator
:
:
I64AtomicRmw32USub
{
.
.
}
|
Operator
:
:
I32AtomicRmwAnd
{
.
.
}
|
Operator
:
:
I64AtomicRmwAnd
{
.
.
}
|
Operator
:
:
I32AtomicRmw8UAnd
{
.
.
}
|
Operator
:
:
I32AtomicRmw16UAnd
{
.
.
}
|
Operator
:
:
I64AtomicRmw8UAnd
{
.
.
}
|
Operator
:
:
I64AtomicRmw16UAnd
{
.
.
}
|
Operator
:
:
I64AtomicRmw32UAnd
{
.
.
}
|
Operator
:
:
I32AtomicRmwOr
{
.
.
}
|
Operator
:
:
I64AtomicRmwOr
{
.
.
}
|
Operator
:
:
I32AtomicRmw8UOr
{
.
.
}
|
Operator
:
:
I32AtomicRmw16UOr
{
.
.
}
|
Operator
:
:
I64AtomicRmw8UOr
{
.
.
}
|
Operator
:
:
I64AtomicRmw16UOr
{
.
.
}
|
Operator
:
:
I64AtomicRmw32UOr
{
.
.
}
|
Operator
:
:
I32AtomicRmwXor
{
.
.
}
|
Operator
:
:
I64AtomicRmwXor
{
.
.
}
|
Operator
:
:
I32AtomicRmw8UXor
{
.
.
}
|
Operator
:
:
I32AtomicRmw16UXor
{
.
.
}
|
Operator
:
:
I64AtomicRmw8UXor
{
.
.
}
|
Operator
:
:
I64AtomicRmw16UXor
{
.
.
}
|
Operator
:
:
I64AtomicRmw32UXor
{
.
.
}
|
Operator
:
:
I32AtomicRmwXchg
{
.
.
}
|
Operator
:
:
I64AtomicRmwXchg
{
.
.
}
|
Operator
:
:
I32AtomicRmw8UXchg
{
.
.
}
|
Operator
:
:
I32AtomicRmw16UXchg
{
.
.
}
|
Operator
:
:
I64AtomicRmw8UXchg
{
.
.
}
|
Operator
:
:
I64AtomicRmw16UXchg
{
.
.
}
|
Operator
:
:
I64AtomicRmw32UXchg
{
.
.
}
|
Operator
:
:
I32AtomicRmwCmpxchg
{
.
.
}
|
Operator
:
:
I64AtomicRmwCmpxchg
{
.
.
}
|
Operator
:
:
I32AtomicRmw8UCmpxchg
{
.
.
}
|
Operator
:
:
I32AtomicRmw16UCmpxchg
{
.
.
}
|
Operator
:
:
I64AtomicRmw8UCmpxchg
{
.
.
}
|
Operator
:
:
I64AtomicRmw16UCmpxchg
{
.
.
}
|
Operator
:
:
I64AtomicRmw32UCmpxchg
{
.
.
}
=
>
{
return
Err
(
WasmError
:
:
Unsupported
(
"
proposed
thread
operators
"
)
)
;
}
}
;
Ok
(
(
)
)
}
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
unneeded_field_pattern
)
)
]
fn
translate_unreachable_operator
(
op
:
&
Operator
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
)
{
match
*
op
{
Operator
:
:
If
{
ty
:
_
}
=
>
{
state
.
push_if
(
ir
:
:
Inst
:
:
reserved_value
(
)
ir
:
:
Ebb
:
:
reserved_value
(
)
0
)
;
}
Operator
:
:
Loop
{
ty
:
_
}
|
Operator
:
:
Block
{
ty
:
_
}
=
>
{
state
.
push_block
(
ir
:
:
Ebb
:
:
reserved_value
(
)
0
)
;
}
Operator
:
:
Else
=
>
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
;
if
let
ControlStackFrame
:
:
If
{
branch_inst
ref
mut
reachable_from_top
.
.
}
=
state
.
control_stack
[
i
]
{
if
*
reachable_from_top
{
state
.
reachable
=
true
;
*
reachable_from_top
=
false
;
let
else_ebb
=
builder
.
create_ebb
(
)
;
builder
.
change_jump_destination
(
branch_inst
else_ebb
)
;
builder
.
seal_block
(
else_ebb
)
;
builder
.
switch_to_block
(
else_ebb
)
;
}
}
}
Operator
:
:
End
=
>
{
let
stack
=
&
mut
state
.
stack
;
let
control_stack
=
&
mut
state
.
control_stack
;
let
frame
=
control_stack
.
pop
(
)
.
unwrap
(
)
;
stack
.
truncate
(
frame
.
original_stack_size
(
)
)
;
let
reachable_anyway
=
match
frame
{
ControlStackFrame
:
:
Loop
{
header
.
.
}
=
>
{
builder
.
seal_block
(
header
)
;
false
}
ControlStackFrame
:
:
If
{
reachable_from_top
.
.
}
=
>
{
reachable_from_top
}
_
=
>
false
}
;
if
frame
.
exit_is_branched_to
(
)
|
|
reachable_anyway
{
builder
.
switch_to_block
(
frame
.
following_code
(
)
)
;
builder
.
seal_block
(
frame
.
following_code
(
)
)
;
stack
.
extend_from_slice
(
builder
.
ebb_params
(
frame
.
following_code
(
)
)
)
;
state
.
reachable
=
true
;
}
}
_
=
>
{
}
}
}
fn
get_heap_addr
(
heap
:
ir
:
:
Heap
addr32
:
ir
:
:
Value
offset
:
u32
addr_ty
:
Type
builder
:
&
mut
FunctionBuilder
)
-
>
(
ir
:
:
Value
i32
)
{
use
std
:
:
cmp
:
:
min
;
let
guard_size
:
i64
=
builder
.
func
.
heaps
[
heap
]
.
guard_size
.
into
(
)
;
debug_assert
!
(
guard_size
>
0
"
Heap
guard
pages
currently
required
"
)
;
let
check_size
=
min
(
i64
:
:
from
(
u32
:
:
MAX
)
1
+
(
i64
:
:
from
(
offset
)
/
guard_size
)
*
guard_size
)
as
u32
;
let
base
=
builder
.
ins
(
)
.
heap_addr
(
addr_ty
heap
addr32
check_size
)
;
if
offset
>
i32
:
:
MAX
as
u32
{
let
adj
=
builder
.
ins
(
)
.
iadd_imm
(
base
i64
:
:
from
(
i32
:
:
MAX
)
+
1
)
;
(
adj
(
offset
-
(
i32
:
:
MAX
as
u32
+
1
)
)
as
i32
)
}
else
{
(
base
offset
as
i32
)
}
}
fn
translate_load
<
FE
:
FuncEnvironment
+
?
Sized
>
(
offset
:
u32
opcode
:
ir
:
:
Opcode
result_ty
:
Type
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
environ
:
&
mut
FE
)
{
let
addr32
=
state
.
pop1
(
)
;
let
heap
=
state
.
get_heap
(
builder
.
func
0
environ
)
;
let
(
base
offset
)
=
get_heap_addr
(
heap
addr32
offset
environ
.
pointer_type
(
)
builder
)
;
let
flags
=
MemFlags
:
:
new
(
)
;
let
(
load
dfg
)
=
builder
.
ins
(
)
.
Load
(
opcode
result_ty
flags
offset
.
into
(
)
base
)
;
state
.
push1
(
dfg
.
first_result
(
load
)
)
;
}
fn
translate_store
<
FE
:
FuncEnvironment
+
?
Sized
>
(
offset
:
u32
opcode
:
ir
:
:
Opcode
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
environ
:
&
mut
FE
)
{
let
(
addr32
val
)
=
state
.
pop2
(
)
;
let
val_ty
=
builder
.
func
.
dfg
.
value_type
(
val
)
;
let
heap
=
state
.
get_heap
(
builder
.
func
0
environ
)
;
let
(
base
offset
)
=
get_heap_addr
(
heap
addr32
offset
environ
.
pointer_type
(
)
builder
)
;
let
flags
=
MemFlags
:
:
new
(
)
;
builder
.
ins
(
)
.
Store
(
opcode
val_ty
flags
offset
.
into
(
)
val
base
)
;
}
fn
translate_icmp
(
cc
:
IntCC
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
)
{
let
(
arg0
arg1
)
=
state
.
pop2
(
)
;
let
val
=
builder
.
ins
(
)
.
icmp
(
cc
arg0
arg1
)
;
state
.
push1
(
builder
.
ins
(
)
.
bint
(
I32
val
)
)
;
}
fn
translate_fcmp
(
cc
:
FloatCC
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
)
{
let
(
arg0
arg1
)
=
state
.
pop2
(
)
;
let
val
=
builder
.
ins
(
)
.
fcmp
(
cc
arg0
arg1
)
;
state
.
push1
(
builder
.
ins
(
)
.
bint
(
I32
val
)
)
;
}
fn
translate_br_if
(
relative_depth
:
u32
builder
:
&
mut
FunctionBuilder
state
:
&
mut
TranslationState
)
{
let
val
=
state
.
pop1
(
)
;
let
(
br_destination
inputs
)
=
translate_br_if_args
(
relative_depth
state
)
;
builder
.
ins
(
)
.
brnz
(
val
br_destination
inputs
)
;
}
fn
translate_br_if_args
(
relative_depth
:
u32
state
:
&
mut
TranslationState
)
-
>
(
ir
:
:
Ebb
&
[
ir
:
:
Value
]
)
{
let
i
=
state
.
control_stack
.
len
(
)
-
1
-
(
relative_depth
as
usize
)
;
let
(
return_count
br_destination
)
=
{
let
frame
=
&
mut
state
.
control_stack
[
i
]
;
frame
.
set_branched_to_exit
(
)
;
let
return_count
=
if
frame
.
is_loop
(
)
{
0
}
else
{
frame
.
num_return_values
(
)
}
;
(
return_count
frame
.
br_destination
(
)
)
}
;
let
inputs
=
state
.
peekn
(
return_count
)
;
(
br_destination
inputs
)
}
