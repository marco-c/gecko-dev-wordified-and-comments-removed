use
crate
:
:
environ
:
:
{
WasmError
WasmResult
}
;
use
crate
:
:
translation_utils
:
:
SignatureIndex
;
use
cranelift_codegen
:
:
ir
:
:
{
types
Type
}
;
use
cranelift_entity
:
:
PrimaryMap
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
vec
:
:
Vec
;
pub
(
crate
)
type
WasmTypes
=
PrimaryMap
<
SignatureIndex
(
Box
<
[
wasmparser
:
:
Type
]
>
Box
<
[
wasmparser
:
:
Type
]
>
)
>
;
#
[
derive
(
Debug
)
]
pub
struct
ModuleTranslationState
{
pub
(
crate
)
wasm_types
:
WasmTypes
}
fn
cranelift_to_wasmparser_type
(
ty
:
Type
)
-
>
WasmResult
<
wasmparser
:
:
Type
>
{
Ok
(
match
ty
{
types
:
:
I32
=
>
wasmparser
:
:
Type
:
:
I32
types
:
:
I64
=
>
wasmparser
:
:
Type
:
:
I64
types
:
:
F32
=
>
wasmparser
:
:
Type
:
:
F32
types
:
:
F64
=
>
wasmparser
:
:
Type
:
:
F64
types
:
:
R32
|
types
:
:
R64
=
>
wasmparser
:
:
Type
:
:
ExternRef
_
=
>
{
return
Err
(
WasmError
:
:
Unsupported
(
format
!
(
"
Cannot
convert
Cranelift
type
to
Wasm
signature
:
{
:
?
}
"
ty
)
)
)
;
}
}
)
}
impl
ModuleTranslationState
{
pub
fn
new
(
)
-
>
Self
{
Self
{
wasm_types
:
PrimaryMap
:
:
new
(
)
}
}
pub
fn
from_func_sigs
(
sigs
:
&
[
(
&
[
Type
]
&
[
Type
]
)
]
)
-
>
WasmResult
<
Self
>
{
let
mut
wasm_types
=
PrimaryMap
:
:
with_capacity
(
sigs
.
len
(
)
)
;
for
&
(
ref
args
ref
results
)
in
sigs
{
let
args
:
Vec
<
wasmparser
:
:
Type
>
=
args
.
iter
(
)
.
map
(
|
&
ty
|
cranelift_to_wasmparser_type
(
ty
)
)
.
collect
:
:
<
Result
<
_
_
>
>
(
)
?
;
let
results
:
Vec
<
wasmparser
:
:
Type
>
=
results
.
iter
(
)
.
map
(
|
&
ty
|
cranelift_to_wasmparser_type
(
ty
)
)
.
collect
:
:
<
Result
<
_
_
>
>
(
)
?
;
wasm_types
.
push
(
(
args
.
into_boxed_slice
(
)
results
.
into_boxed_slice
(
)
)
)
;
}
Ok
(
Self
{
wasm_types
}
)
}
}
