use
crate
:
:
environ
:
:
{
FuncEnvironment
GlobalVariable
WasmResult
}
;
use
crate
:
:
translation_utils
:
:
{
FuncIndex
GlobalIndex
MemoryIndex
TableIndex
TypeIndex
}
;
use
crate
:
:
{
HashMap
Occupied
Vacant
}
;
use
cranelift_codegen
:
:
ir
:
:
{
self
Block
Inst
Value
}
;
use
std
:
:
vec
:
:
Vec
;
#
[
derive
(
Debug
)
]
pub
enum
ElseData
{
NoElse
{
branch_inst
:
Inst
}
WithElse
{
else_block
:
Block
}
}
#
[
derive
(
Debug
)
]
pub
enum
ControlStackFrame
{
If
{
destination
:
Block
else_data
:
ElseData
num_param_values
:
usize
num_return_values
:
usize
original_stack_size
:
usize
exit_is_branched_to
:
bool
blocktype
:
wasmparser
:
:
TypeOrFuncType
head_is_reachable
:
bool
consequent_ends_reachable
:
Option
<
bool
>
}
Block
{
destination
:
Block
num_param_values
:
usize
num_return_values
:
usize
original_stack_size
:
usize
exit_is_branched_to
:
bool
}
Loop
{
destination
:
Block
header
:
Block
num_param_values
:
usize
num_return_values
:
usize
original_stack_size
:
usize
}
}
impl
ControlStackFrame
{
pub
fn
num_return_values
(
&
self
)
-
>
usize
{
match
*
self
{
Self
:
:
If
{
num_return_values
.
.
}
|
Self
:
:
Block
{
num_return_values
.
.
}
|
Self
:
:
Loop
{
num_return_values
.
.
}
=
>
num_return_values
}
}
pub
fn
num_param_values
(
&
self
)
-
>
usize
{
match
*
self
{
Self
:
:
If
{
num_param_values
.
.
}
|
Self
:
:
Block
{
num_param_values
.
.
}
|
Self
:
:
Loop
{
num_param_values
.
.
}
=
>
num_param_values
}
}
pub
fn
following_code
(
&
self
)
-
>
Block
{
match
*
self
{
Self
:
:
If
{
destination
.
.
}
|
Self
:
:
Block
{
destination
.
.
}
|
Self
:
:
Loop
{
destination
.
.
}
=
>
destination
}
}
pub
fn
br_destination
(
&
self
)
-
>
Block
{
match
*
self
{
Self
:
:
If
{
destination
.
.
}
|
Self
:
:
Block
{
destination
.
.
}
=
>
destination
Self
:
:
Loop
{
header
.
.
}
=
>
header
}
}
fn
original_stack_size
(
&
self
)
-
>
usize
{
match
*
self
{
Self
:
:
If
{
original_stack_size
.
.
}
|
Self
:
:
Block
{
original_stack_size
.
.
}
|
Self
:
:
Loop
{
original_stack_size
.
.
}
=
>
original_stack_size
}
}
pub
fn
is_loop
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
If
{
.
.
}
|
Self
:
:
Block
{
.
.
}
=
>
false
Self
:
:
Loop
{
.
.
}
=
>
true
}
}
pub
fn
exit_is_branched_to
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
If
{
exit_is_branched_to
.
.
}
|
Self
:
:
Block
{
exit_is_branched_to
.
.
}
=
>
exit_is_branched_to
Self
:
:
Loop
{
.
.
}
=
>
false
}
}
pub
fn
set_branched_to_exit
(
&
mut
self
)
{
match
*
self
{
Self
:
:
If
{
ref
mut
exit_is_branched_to
.
.
}
|
Self
:
:
Block
{
ref
mut
exit_is_branched_to
.
.
}
=
>
*
exit_is_branched_to
=
true
Self
:
:
Loop
{
.
.
}
=
>
{
}
}
}
pub
fn
truncate_value_stack_to_else_params
(
&
self
stack
:
&
mut
Vec
<
Value
>
)
{
debug_assert
!
(
matches
!
(
self
&
ControlStackFrame
:
:
If
{
.
.
}
)
)
;
stack
.
truncate
(
self
.
original_stack_size
(
)
)
;
}
pub
fn
truncate_value_stack_to_original_size
(
&
self
stack
:
&
mut
Vec
<
Value
>
)
{
let
num_duplicated_params
=
match
self
{
&
ControlStackFrame
:
:
If
{
num_param_values
.
.
}
=
>
{
debug_assert
!
(
num_param_values
<
=
self
.
original_stack_size
(
)
)
;
num_param_values
}
_
=
>
0
}
;
stack
.
truncate
(
self
.
original_stack_size
(
)
-
num_duplicated_params
)
;
}
}
pub
struct
FuncTranslationState
{
pub
(
crate
)
stack
:
Vec
<
Value
>
pub
(
crate
)
control_stack
:
Vec
<
ControlStackFrame
>
pub
(
crate
)
reachable
:
bool
globals
:
HashMap
<
GlobalIndex
GlobalVariable
>
heaps
:
HashMap
<
MemoryIndex
ir
:
:
Heap
>
pub
(
crate
)
tables
:
HashMap
<
TableIndex
ir
:
:
Table
>
signatures
:
HashMap
<
TypeIndex
(
ir
:
:
SigRef
usize
)
>
functions
:
HashMap
<
FuncIndex
(
ir
:
:
FuncRef
usize
)
>
}
impl
FuncTranslationState
{
#
[
inline
]
pub
fn
reachable
(
&
self
)
-
>
bool
{
self
.
reachable
}
}
impl
FuncTranslationState
{
pub
(
crate
)
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
control_stack
:
Vec
:
:
new
(
)
reachable
:
true
globals
:
HashMap
:
:
new
(
)
heaps
:
HashMap
:
:
new
(
)
tables
:
HashMap
:
:
new
(
)
signatures
:
HashMap
:
:
new
(
)
functions
:
HashMap
:
:
new
(
)
}
}
fn
clear
(
&
mut
self
)
{
debug_assert
!
(
self
.
stack
.
is_empty
(
)
)
;
debug_assert
!
(
self
.
control_stack
.
is_empty
(
)
)
;
self
.
reachable
=
true
;
self
.
globals
.
clear
(
)
;
self
.
heaps
.
clear
(
)
;
self
.
tables
.
clear
(
)
;
self
.
signatures
.
clear
(
)
;
self
.
functions
.
clear
(
)
;
}
pub
(
crate
)
fn
initialize
(
&
mut
self
sig
:
&
ir
:
:
Signature
exit_block
:
Block
)
{
self
.
clear
(
)
;
self
.
push_block
(
exit_block
0
sig
.
returns
.
iter
(
)
.
filter
(
|
arg
|
arg
.
purpose
=
=
ir
:
:
ArgumentPurpose
:
:
Normal
)
.
count
(
)
)
;
}
pub
(
crate
)
fn
push1
(
&
mut
self
val
:
Value
)
{
self
.
stack
.
push
(
val
)
;
}
pub
(
crate
)
fn
pushn
(
&
mut
self
vals
:
&
[
Value
]
)
{
self
.
stack
.
extend_from_slice
(
vals
)
;
}
pub
(
crate
)
fn
pop1
(
&
mut
self
)
-
>
Value
{
self
.
stack
.
pop
(
)
.
expect
(
"
attempted
to
pop
a
value
from
an
empty
stack
"
)
}
pub
(
crate
)
fn
peek1
(
&
self
)
-
>
Value
{
*
self
.
stack
.
last
(
)
.
expect
(
"
attempted
to
peek
at
a
value
on
an
empty
stack
"
)
}
pub
(
crate
)
fn
pop2
(
&
mut
self
)
-
>
(
Value
Value
)
{
let
v2
=
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
let
v1
=
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
(
v1
v2
)
}
pub
(
crate
)
fn
pop3
(
&
mut
self
)
-
>
(
Value
Value
Value
)
{
let
v3
=
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
let
v2
=
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
let
v1
=
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
(
v1
v2
v3
)
}
#
[
inline
]
fn
ensure_length_is_at_least
(
&
self
n
:
usize
)
{
debug_assert
!
(
n
<
=
self
.
stack
.
len
(
)
"
attempted
to
access
{
}
values
but
stack
only
has
{
}
values
"
n
self
.
stack
.
len
(
)
)
}
pub
(
crate
)
fn
popn
(
&
mut
self
n
:
usize
)
{
self
.
ensure_length_is_at_least
(
n
)
;
let
new_len
=
self
.
stack
.
len
(
)
-
n
;
self
.
stack
.
truncate
(
new_len
)
;
}
pub
(
crate
)
fn
peekn
(
&
self
n
:
usize
)
-
>
&
[
Value
]
{
self
.
ensure_length_is_at_least
(
n
)
;
&
self
.
stack
[
self
.
stack
.
len
(
)
-
n
.
.
]
}
pub
(
crate
)
fn
peekn_mut
(
&
mut
self
n
:
usize
)
-
>
&
mut
[
Value
]
{
self
.
ensure_length_is_at_least
(
n
)
;
let
len
=
self
.
stack
.
len
(
)
;
&
mut
self
.
stack
[
len
-
n
.
.
]
}
pub
(
crate
)
fn
push_block
(
&
mut
self
following_code
:
Block
num_param_types
:
usize
num_result_types
:
usize
)
{
debug_assert
!
(
num_param_types
<
=
self
.
stack
.
len
(
)
)
;
self
.
control_stack
.
push
(
ControlStackFrame
:
:
Block
{
destination
:
following_code
original_stack_size
:
self
.
stack
.
len
(
)
-
num_param_types
num_param_values
:
num_param_types
num_return_values
:
num_result_types
exit_is_branched_to
:
false
}
)
;
}
pub
(
crate
)
fn
push_loop
(
&
mut
self
header
:
Block
following_code
:
Block
num_param_types
:
usize
num_result_types
:
usize
)
{
debug_assert
!
(
num_param_types
<
=
self
.
stack
.
len
(
)
)
;
self
.
control_stack
.
push
(
ControlStackFrame
:
:
Loop
{
header
destination
:
following_code
original_stack_size
:
self
.
stack
.
len
(
)
-
num_param_types
num_param_values
:
num_param_types
num_return_values
:
num_result_types
}
)
;
}
pub
(
crate
)
fn
push_if
(
&
mut
self
destination
:
Block
else_data
:
ElseData
num_param_types
:
usize
num_result_types
:
usize
blocktype
:
wasmparser
:
:
TypeOrFuncType
)
{
debug_assert
!
(
num_param_types
<
=
self
.
stack
.
len
(
)
)
;
self
.
stack
.
reserve
(
num_param_types
)
;
for
i
in
(
self
.
stack
.
len
(
)
-
num_param_types
)
.
.
self
.
stack
.
len
(
)
{
let
val
=
self
.
stack
[
i
]
;
self
.
stack
.
push
(
val
)
;
}
self
.
control_stack
.
push
(
ControlStackFrame
:
:
If
{
destination
else_data
original_stack_size
:
self
.
stack
.
len
(
)
-
num_param_types
num_param_values
:
num_param_types
num_return_values
:
num_result_types
exit_is_branched_to
:
false
head_is_reachable
:
self
.
reachable
consequent_ends_reachable
:
None
blocktype
}
)
;
}
}
impl
FuncTranslationState
{
pub
(
crate
)
fn
get_global
<
FE
:
FuncEnvironment
+
?
Sized
>
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
u32
environ
:
&
mut
FE
)
-
>
WasmResult
<
GlobalVariable
>
{
let
index
=
GlobalIndex
:
:
from_u32
(
index
)
;
match
self
.
globals
.
entry
(
index
)
{
Occupied
(
entry
)
=
>
Ok
(
*
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
Ok
(
*
entry
.
insert
(
environ
.
make_global
(
func
index
)
?
)
)
}
}
pub
(
crate
)
fn
get_heap
<
FE
:
FuncEnvironment
+
?
Sized
>
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
u32
environ
:
&
mut
FE
)
-
>
WasmResult
<
ir
:
:
Heap
>
{
let
index
=
MemoryIndex
:
:
from_u32
(
index
)
;
match
self
.
heaps
.
entry
(
index
)
{
Occupied
(
entry
)
=
>
Ok
(
*
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
Ok
(
*
entry
.
insert
(
environ
.
make_heap
(
func
index
)
?
)
)
}
}
pub
(
crate
)
fn
get_or_create_table
<
FE
:
FuncEnvironment
+
?
Sized
>
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
u32
environ
:
&
mut
FE
)
-
>
WasmResult
<
ir
:
:
Table
>
{
let
index
=
TableIndex
:
:
from_u32
(
index
)
;
match
self
.
tables
.
entry
(
index
)
{
Occupied
(
entry
)
=
>
Ok
(
*
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
Ok
(
*
entry
.
insert
(
environ
.
make_table
(
func
index
)
?
)
)
}
}
pub
(
crate
)
fn
get_indirect_sig
<
FE
:
FuncEnvironment
+
?
Sized
>
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
u32
environ
:
&
mut
FE
)
-
>
WasmResult
<
(
ir
:
:
SigRef
usize
)
>
{
let
index
=
TypeIndex
:
:
from_u32
(
index
)
;
match
self
.
signatures
.
entry
(
index
)
{
Occupied
(
entry
)
=
>
Ok
(
*
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
{
let
sig
=
environ
.
make_indirect_sig
(
func
index
)
?
;
Ok
(
*
entry
.
insert
(
(
sig
num_wasm_parameters
(
environ
&
func
.
dfg
.
signatures
[
sig
]
)
)
)
)
}
}
}
pub
(
crate
)
fn
get_direct_func
<
FE
:
FuncEnvironment
+
?
Sized
>
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
u32
environ
:
&
mut
FE
)
-
>
WasmResult
<
(
ir
:
:
FuncRef
usize
)
>
{
let
index
=
FuncIndex
:
:
from_u32
(
index
)
;
match
self
.
functions
.
entry
(
index
)
{
Occupied
(
entry
)
=
>
Ok
(
*
entry
.
get
(
)
)
Vacant
(
entry
)
=
>
{
let
fref
=
environ
.
make_direct_func
(
func
index
)
?
;
let
sig
=
func
.
dfg
.
ext_funcs
[
fref
]
.
signature
;
Ok
(
*
entry
.
insert
(
(
fref
num_wasm_parameters
(
environ
&
func
.
dfg
.
signatures
[
sig
]
)
)
)
)
}
}
}
}
fn
num_wasm_parameters
<
FE
:
FuncEnvironment
+
?
Sized
>
(
environ
:
&
FE
signature
:
&
ir
:
:
Signature
)
-
>
usize
{
(
0
.
.
signature
.
params
.
len
(
)
)
.
filter
(
|
index
|
environ
.
is_wasm_parameter
(
signature
*
index
)
)
.
count
(
)
}
