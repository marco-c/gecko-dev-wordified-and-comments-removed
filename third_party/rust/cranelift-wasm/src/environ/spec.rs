use
crate
:
:
state
:
:
FuncTranslationState
;
use
crate
:
:
translation_utils
:
:
{
DataIndex
ElemIndex
EntityType
FuncIndex
Global
GlobalIndex
Memory
MemoryIndex
Table
TableIndex
TypeIndex
}
;
use
core
:
:
convert
:
:
From
;
use
core
:
:
convert
:
:
TryFrom
;
use
cranelift_codegen
:
:
cursor
:
:
FuncCursor
;
use
cranelift_codegen
:
:
ir
:
:
immediates
:
:
Offset32
;
use
cranelift_codegen
:
:
ir
:
:
{
self
InstBuilder
}
;
use
cranelift_codegen
:
:
isa
:
:
TargetFrontendConfig
;
use
cranelift_frontend
:
:
FunctionBuilder
;
#
[
cfg
(
feature
=
"
enable
-
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
string
:
:
ToString
;
use
thiserror
:
:
Error
;
use
wasmparser
:
:
ValidatorResources
;
use
wasmparser
:
:
{
BinaryReaderError
FuncValidator
FunctionBody
Operator
WasmFeatures
}
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
enum
WasmType
{
I32
I64
F32
F64
V128
FuncRef
ExternRef
}
impl
TryFrom
<
wasmparser
:
:
Type
>
for
WasmType
{
type
Error
=
WasmError
;
fn
try_from
(
ty
:
wasmparser
:
:
Type
)
-
>
Result
<
Self
Self
:
:
Error
>
{
use
wasmparser
:
:
Type
:
:
*
;
match
ty
{
I32
=
>
Ok
(
WasmType
:
:
I32
)
I64
=
>
Ok
(
WasmType
:
:
I64
)
F32
=
>
Ok
(
WasmType
:
:
F32
)
F64
=
>
Ok
(
WasmType
:
:
F64
)
V128
=
>
Ok
(
WasmType
:
:
V128
)
FuncRef
=
>
Ok
(
WasmType
:
:
FuncRef
)
ExternRef
=
>
Ok
(
WasmType
:
:
ExternRef
)
EmptyBlockType
|
Func
=
>
Err
(
WasmError
:
:
InvalidWebAssembly
{
message
:
"
unexpected
value
type
"
.
to_string
(
)
offset
:
0
}
)
}
}
}
impl
From
<
WasmType
>
for
wasmparser
:
:
Type
{
fn
from
(
ty
:
WasmType
)
-
>
wasmparser
:
:
Type
{
match
ty
{
WasmType
:
:
I32
=
>
wasmparser
:
:
Type
:
:
I32
WasmType
:
:
I64
=
>
wasmparser
:
:
Type
:
:
I64
WasmType
:
:
F32
=
>
wasmparser
:
:
Type
:
:
F32
WasmType
:
:
F64
=
>
wasmparser
:
:
Type
:
:
F64
WasmType
:
:
V128
=
>
wasmparser
:
:
Type
:
:
V128
WasmType
:
:
FuncRef
=
>
wasmparser
:
:
Type
:
:
FuncRef
WasmType
:
:
ExternRef
=
>
wasmparser
:
:
Type
:
:
ExternRef
}
}
}
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
enable
-
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
WasmFuncType
{
pub
params
:
Box
<
[
WasmType
]
>
pub
returns
:
Box
<
[
WasmType
]
>
}
impl
TryFrom
<
wasmparser
:
:
FuncType
>
for
WasmFuncType
{
type
Error
=
WasmError
;
fn
try_from
(
ty
:
wasmparser
:
:
FuncType
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Ok
(
Self
{
params
:
ty
.
params
.
into_vec
(
)
.
into_iter
(
)
.
map
(
WasmType
:
:
try_from
)
.
collect
:
:
<
Result
<
_
Self
:
:
Error
>
>
(
)
?
returns
:
ty
.
returns
.
into_vec
(
)
.
into_iter
(
)
.
map
(
WasmType
:
:
try_from
)
.
collect
:
:
<
Result
<
_
Self
:
:
Error
>
>
(
)
?
}
)
}
}
#
[
derive
(
Clone
Copy
)
]
pub
enum
GlobalVariable
{
Const
(
ir
:
:
Value
)
Memory
{
gv
:
ir
:
:
GlobalValue
offset
:
Offset32
ty
:
ir
:
:
Type
}
Custom
}
#
[
derive
(
Error
Debug
)
]
pub
enum
WasmError
{
#
[
error
(
"
Invalid
input
WebAssembly
code
at
offset
{
offset
}
:
{
message
}
"
)
]
InvalidWebAssembly
{
message
:
std
:
:
string
:
:
String
offset
:
usize
}
#
[
error
(
"
Unsupported
feature
:
{
0
}
"
)
]
Unsupported
(
std
:
:
string
:
:
String
)
#
[
error
(
"
Implementation
limit
exceeded
"
)
]
ImplLimitExceeded
#
[
error
(
"
User
error
:
{
0
}
"
)
]
User
(
std
:
:
string
:
:
String
)
}
#
[
macro_export
]
macro_rules
!
wasm_unsupported
{
(
(
arg
:
tt
)
*
)
=
>
{
crate
:
:
environ
:
:
WasmError
:
:
Unsupported
(
format
!
(
(
arg
)
*
)
)
}
}
impl
From
<
BinaryReaderError
>
for
WasmError
{
fn
from
(
e
:
BinaryReaderError
)
-
>
Self
{
Self
:
:
InvalidWebAssembly
{
message
:
e
.
message
(
)
.
into
(
)
offset
:
e
.
offset
(
)
}
}
}
pub
type
WasmResult
<
T
>
=
Result
<
T
WasmError
>
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Debug
)
]
pub
enum
ReturnMode
{
NormalReturns
FallthroughReturn
}
pub
trait
TargetEnvironment
{
fn
target_config
(
&
self
)
-
>
TargetFrontendConfig
;
fn
pointer_type
(
&
self
)
-
>
ir
:
:
Type
{
ir
:
:
Type
:
:
int
(
u16
:
:
from
(
self
.
target_config
(
)
.
pointer_bits
(
)
)
)
.
unwrap
(
)
}
fn
pointer_bytes
(
&
self
)
-
>
u8
{
self
.
target_config
(
)
.
pointer_bytes
(
)
}
fn
reference_type
(
&
self
ty
:
WasmType
)
-
>
ir
:
:
Type
{
let
_
=
ty
;
match
self
.
pointer_type
(
)
{
ir
:
:
types
:
:
I32
=
>
ir
:
:
types
:
:
R32
ir
:
:
types
:
:
I64
=
>
ir
:
:
types
:
:
R64
_
=
>
panic
!
(
"
unsupported
pointer
type
"
)
}
}
}
pub
trait
FuncEnvironment
:
TargetEnvironment
{
fn
is_wasm_parameter
(
&
self
signature
:
&
ir
:
:
Signature
index
:
usize
)
-
>
bool
{
signature
.
params
[
index
]
.
purpose
=
=
ir
:
:
ArgumentPurpose
:
:
Normal
}
fn
is_wasm_return
(
&
self
signature
:
&
ir
:
:
Signature
index
:
usize
)
-
>
bool
{
signature
.
returns
[
index
]
.
purpose
=
=
ir
:
:
ArgumentPurpose
:
:
Normal
}
fn
return_mode
(
&
self
)
-
>
ReturnMode
{
ReturnMode
:
:
NormalReturns
}
fn
make_global
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
GlobalIndex
)
-
>
WasmResult
<
GlobalVariable
>
;
fn
make_heap
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
MemoryIndex
)
-
>
WasmResult
<
ir
:
:
Heap
>
;
fn
make_table
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
TableIndex
)
-
>
WasmResult
<
ir
:
:
Table
>
;
fn
make_indirect_sig
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
TypeIndex
)
-
>
WasmResult
<
ir
:
:
SigRef
>
;
fn
make_direct_func
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
FuncIndex
)
-
>
WasmResult
<
ir
:
:
FuncRef
>
;
#
[
cfg_attr
(
feature
=
"
cargo
-
clippy
"
allow
(
clippy
:
:
too_many_arguments
)
)
]
fn
translate_call_indirect
(
&
mut
self
pos
:
FuncCursor
table_index
:
TableIndex
table
:
ir
:
:
Table
sig_index
:
TypeIndex
sig_ref
:
ir
:
:
SigRef
callee
:
ir
:
:
Value
call_args
:
&
[
ir
:
:
Value
]
)
-
>
WasmResult
<
ir
:
:
Inst
>
;
fn
translate_call
(
&
mut
self
mut
pos
:
FuncCursor
_callee_index
:
FuncIndex
callee
:
ir
:
:
FuncRef
call_args
:
&
[
ir
:
:
Value
]
)
-
>
WasmResult
<
ir
:
:
Inst
>
{
Ok
(
pos
.
ins
(
)
.
call
(
callee
call_args
)
)
}
fn
translate_memory_grow
(
&
mut
self
pos
:
FuncCursor
index
:
MemoryIndex
heap
:
ir
:
:
Heap
val
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_memory_size
(
&
mut
self
pos
:
FuncCursor
index
:
MemoryIndex
heap
:
ir
:
:
Heap
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_memory_copy
(
&
mut
self
pos
:
FuncCursor
src_index
:
MemoryIndex
src_heap
:
ir
:
:
Heap
dst_index
:
MemoryIndex
dst_heap
:
ir
:
:
Heap
dst
:
ir
:
:
Value
src
:
ir
:
:
Value
len
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
fn
translate_memory_fill
(
&
mut
self
pos
:
FuncCursor
index
:
MemoryIndex
heap
:
ir
:
:
Heap
dst
:
ir
:
:
Value
val
:
ir
:
:
Value
len
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
translate_memory_init
(
&
mut
self
pos
:
FuncCursor
index
:
MemoryIndex
heap
:
ir
:
:
Heap
seg_index
:
u32
dst
:
ir
:
:
Value
src
:
ir
:
:
Value
len
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
fn
translate_data_drop
(
&
mut
self
pos
:
FuncCursor
seg_index
:
u32
)
-
>
WasmResult
<
(
)
>
;
fn
translate_table_size
(
&
mut
self
pos
:
FuncCursor
index
:
TableIndex
table
:
ir
:
:
Table
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_table_grow
(
&
mut
self
pos
:
FuncCursor
table_index
:
TableIndex
table
:
ir
:
:
Table
delta
:
ir
:
:
Value
init_value
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_table_get
(
&
mut
self
builder
:
&
mut
FunctionBuilder
table_index
:
TableIndex
table
:
ir
:
:
Table
index
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_table_set
(
&
mut
self
builder
:
&
mut
FunctionBuilder
table_index
:
TableIndex
table
:
ir
:
:
Table
value
:
ir
:
:
Value
index
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
translate_table_copy
(
&
mut
self
pos
:
FuncCursor
dst_table_index
:
TableIndex
dst_table
:
ir
:
:
Table
src_table_index
:
TableIndex
src_table
:
ir
:
:
Table
dst
:
ir
:
:
Value
src
:
ir
:
:
Value
len
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
fn
translate_table_fill
(
&
mut
self
pos
:
FuncCursor
table_index
:
TableIndex
dst
:
ir
:
:
Value
val
:
ir
:
:
Value
len
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
translate_table_init
(
&
mut
self
pos
:
FuncCursor
seg_index
:
u32
table_index
:
TableIndex
table
:
ir
:
:
Table
dst
:
ir
:
:
Value
src
:
ir
:
:
Value
len
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
fn
translate_elem_drop
(
&
mut
self
pos
:
FuncCursor
seg_index
:
u32
)
-
>
WasmResult
<
(
)
>
;
fn
translate_ref_null
(
&
mut
self
mut
pos
:
FuncCursor
ty
:
WasmType
)
-
>
WasmResult
<
ir
:
:
Value
>
{
let
_
=
ty
;
Ok
(
pos
.
ins
(
)
.
null
(
self
.
reference_type
(
ty
)
)
)
}
fn
translate_ref_is_null
(
&
mut
self
mut
pos
:
FuncCursor
value
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
{
let
is_null
=
pos
.
ins
(
)
.
is_null
(
value
)
;
Ok
(
pos
.
ins
(
)
.
bint
(
ir
:
:
types
:
:
I32
is_null
)
)
}
fn
translate_ref_func
(
&
mut
self
pos
:
FuncCursor
func_index
:
FuncIndex
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_custom_global_get
(
&
mut
self
pos
:
FuncCursor
global_index
:
GlobalIndex
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_custom_global_set
(
&
mut
self
pos
:
FuncCursor
global_index
:
GlobalIndex
val
:
ir
:
:
Value
)
-
>
WasmResult
<
(
)
>
;
fn
translate_atomic_wait
(
&
mut
self
pos
:
FuncCursor
index
:
MemoryIndex
heap
:
ir
:
:
Heap
addr
:
ir
:
:
Value
expected
:
ir
:
:
Value
timeout
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_atomic_notify
(
&
mut
self
pos
:
FuncCursor
index
:
MemoryIndex
heap
:
ir
:
:
Heap
addr
:
ir
:
:
Value
count
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
;
fn
translate_loop_header
(
&
mut
self
_pos
:
FuncCursor
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
before_translate_operator
(
&
mut
self
_op
:
&
Operator
_builder
:
&
mut
FunctionBuilder
_state
:
&
FuncTranslationState
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
after_translate_operator
(
&
mut
self
_op
:
&
Operator
_builder
:
&
mut
FunctionBuilder
_state
:
&
FuncTranslationState
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
}
pub
trait
ModuleEnvironment
<
'
data
>
:
TargetEnvironment
{
fn
reserve_types
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_type_func
(
&
mut
self
wasm_func_type
:
WasmFuncType
sig
:
ir
:
:
Signature
)
-
>
WasmResult
<
(
)
>
;
fn
declare_type_module
(
&
mut
self
imports
:
&
[
(
&
'
data
str
Option
<
&
'
data
str
>
EntityType
)
]
exports
:
&
[
(
&
'
data
str
EntityType
)
]
)
-
>
WasmResult
<
(
)
>
{
drop
(
(
imports
exports
)
)
;
Err
(
WasmError
:
:
Unsupported
(
"
module
linking
"
.
to_string
(
)
)
)
}
fn
declare_type_instance
(
&
mut
self
exports
:
&
[
(
&
'
data
str
EntityType
)
]
)
-
>
WasmResult
<
(
)
>
{
drop
(
exports
)
;
Err
(
WasmError
:
:
Unsupported
(
"
module
linking
"
.
to_string
(
)
)
)
}
fn
reserve_imports
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_func_import
(
&
mut
self
index
:
TypeIndex
module
:
&
'
data
str
field
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_table_import
(
&
mut
self
table
:
Table
module
:
&
'
data
str
field
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_memory_import
(
&
mut
self
memory
:
Memory
module
:
&
'
data
str
field
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_global_import
(
&
mut
self
global
:
Global
module
:
&
'
data
str
field
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_module_import
(
&
mut
self
ty_index
:
TypeIndex
module
:
&
'
data
str
field
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
{
drop
(
(
ty_index
module
field
)
)
;
Err
(
WasmError
:
:
Unsupported
(
"
module
linking
"
.
to_string
(
)
)
)
}
fn
declare_instance_import
(
&
mut
self
ty_index
:
TypeIndex
module
:
&
'
data
str
field
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
{
drop
(
(
ty_index
module
field
)
)
;
Err
(
WasmError
:
:
Unsupported
(
"
module
linking
"
.
to_string
(
)
)
)
}
fn
finish_imports
(
&
mut
self
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
reserve_func_types
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_func_type
(
&
mut
self
index
:
TypeIndex
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_tables
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_table
(
&
mut
self
table
:
Table
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_memories
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_memory
(
&
mut
self
memory
:
Memory
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_globals
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_global
(
&
mut
self
global
:
Global
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_exports
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_func_export
(
&
mut
self
func_index
:
FuncIndex
name
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_table_export
(
&
mut
self
table_index
:
TableIndex
name
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_memory_export
(
&
mut
self
memory_index
:
MemoryIndex
name
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
declare_global_export
(
&
mut
self
global_index
:
GlobalIndex
name
:
&
'
data
str
)
-
>
WasmResult
<
(
)
>
;
fn
finish_exports
(
&
mut
self
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_start_func
(
&
mut
self
index
:
FuncIndex
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_table_elements
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_table_elements
(
&
mut
self
table_index
:
TableIndex
base
:
Option
<
GlobalIndex
>
offset
:
usize
elements
:
Box
<
[
FuncIndex
]
>
)
-
>
WasmResult
<
(
)
>
;
fn
declare_passive_element
(
&
mut
self
index
:
ElemIndex
elements
:
Box
<
[
FuncIndex
]
>
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_passive_data
(
&
mut
self
count
:
u32
)
-
>
WasmResult
<
(
)
>
{
let
_
=
count
;
Ok
(
(
)
)
}
fn
declare_passive_data
(
&
mut
self
data_index
:
DataIndex
data
:
&
'
data
[
u8
]
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_function_bodies
(
&
mut
self
bodies
:
u32
code_section_offset
:
u64
)
{
drop
(
(
bodies
code_section_offset
)
)
;
}
fn
define_function_body
(
&
mut
self
validator
:
FuncValidator
<
ValidatorResources
>
body
:
FunctionBody
<
'
data
>
)
-
>
WasmResult
<
(
)
>
;
fn
reserve_data_initializers
(
&
mut
self
_num
:
u32
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
declare_data_initialization
(
&
mut
self
memory_index
:
MemoryIndex
base
:
Option
<
GlobalIndex
>
offset
:
usize
data
:
&
'
data
[
u8
]
)
-
>
WasmResult
<
(
)
>
;
fn
declare_module_name
(
&
mut
self
_name
:
&
'
data
str
)
{
}
fn
declare_func_name
(
&
mut
self
_func_index
:
FuncIndex
_name
:
&
'
data
str
)
{
}
fn
declare_local_name
(
&
mut
self
_func_index
:
FuncIndex
_local_index
:
u32
_name
:
&
'
data
str
)
{
}
fn
custom_section
(
&
mut
self
_name
:
&
'
data
str
_data
:
&
'
data
[
u8
]
)
-
>
WasmResult
<
(
)
>
{
Ok
(
(
)
)
}
fn
wasm_features
(
&
self
)
-
>
WasmFeatures
{
WasmFeatures
:
:
default
(
)
}
fn
reserve_modules
(
&
mut
self
amount
:
u32
)
{
drop
(
amount
)
;
}
fn
module_start
(
&
mut
self
index
:
usize
)
{
drop
(
index
)
;
}
fn
module_end
(
&
mut
self
index
:
usize
)
{
drop
(
index
)
;
}
}
