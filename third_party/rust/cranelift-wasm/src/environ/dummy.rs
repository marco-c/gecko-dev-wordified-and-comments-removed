use
crate
:
:
environ
:
:
{
FuncEnvironment
GlobalVariable
ModuleEnvironment
ReturnMode
WasmResult
}
;
use
crate
:
:
func_translator
:
:
FuncTranslator
;
use
crate
:
:
translation_utils
:
:
{
DefinedFuncIndex
FuncIndex
Global
GlobalIndex
Memory
MemoryIndex
SignatureIndex
Table
TableIndex
}
;
use
cast
;
use
cranelift_codegen
:
:
cursor
:
:
FuncCursor
;
use
cranelift_codegen
:
:
ir
:
:
immediates
:
:
{
Offset32
Uimm64
}
;
use
cranelift_codegen
:
:
ir
:
:
types
:
:
*
;
use
cranelift_codegen
:
:
ir
:
:
{
self
InstBuilder
}
;
use
cranelift_codegen
:
:
isa
:
:
TargetFrontendConfig
;
use
cranelift_entity
:
:
{
EntityRef
PrimaryMap
}
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
string
:
:
String
;
use
std
:
:
vec
:
:
Vec
;
fn
get_func_name
(
func_index
:
FuncIndex
)
-
>
ir
:
:
ExternalName
{
ir
:
:
ExternalName
:
:
user
(
0
func_index
.
as_u32
(
)
)
}
pub
struct
Exportable
<
T
>
{
pub
entity
:
T
pub
export_names
:
Vec
<
String
>
}
impl
<
T
>
Exportable
<
T
>
{
pub
fn
new
(
entity
:
T
)
-
>
Self
{
Self
{
entity
export_names
:
Vec
:
:
new
(
)
}
}
}
pub
struct
DummyModuleInfo
{
config
:
TargetFrontendConfig
pub
signatures
:
PrimaryMap
<
SignatureIndex
ir
:
:
Signature
>
pub
imported_funcs
:
Vec
<
(
String
String
)
>
pub
imported_globals
:
Vec
<
(
String
String
)
>
pub
imported_tables
:
Vec
<
(
String
String
)
>
pub
imported_memories
:
Vec
<
(
String
String
)
>
pub
functions
:
PrimaryMap
<
FuncIndex
Exportable
<
SignatureIndex
>
>
pub
function_bodies
:
PrimaryMap
<
DefinedFuncIndex
ir
:
:
Function
>
pub
tables
:
PrimaryMap
<
TableIndex
Exportable
<
Table
>
>
pub
memories
:
PrimaryMap
<
MemoryIndex
Exportable
<
Memory
>
>
pub
globals
:
PrimaryMap
<
GlobalIndex
Exportable
<
Global
>
>
pub
start_func
:
Option
<
FuncIndex
>
}
impl
DummyModuleInfo
{
pub
fn
new
(
config
:
TargetFrontendConfig
)
-
>
Self
{
Self
{
config
signatures
:
PrimaryMap
:
:
new
(
)
imported_funcs
:
Vec
:
:
new
(
)
imported_globals
:
Vec
:
:
new
(
)
imported_tables
:
Vec
:
:
new
(
)
imported_memories
:
Vec
:
:
new
(
)
functions
:
PrimaryMap
:
:
new
(
)
function_bodies
:
PrimaryMap
:
:
new
(
)
tables
:
PrimaryMap
:
:
new
(
)
memories
:
PrimaryMap
:
:
new
(
)
globals
:
PrimaryMap
:
:
new
(
)
start_func
:
None
}
}
}
pub
struct
DummyEnvironment
{
pub
info
:
DummyModuleInfo
trans
:
FuncTranslator
pub
func_bytecode_sizes
:
Vec
<
usize
>
return_mode
:
ReturnMode
}
impl
DummyEnvironment
{
pub
fn
new
(
config
:
TargetFrontendConfig
return_mode
:
ReturnMode
)
-
>
Self
{
Self
{
info
:
DummyModuleInfo
:
:
new
(
config
)
trans
:
FuncTranslator
:
:
new
(
)
func_bytecode_sizes
:
Vec
:
:
new
(
)
return_mode
}
}
pub
fn
func_env
(
&
self
)
-
>
DummyFuncEnvironment
{
DummyFuncEnvironment
:
:
new
(
&
self
.
info
self
.
return_mode
)
}
fn
get_func_type
(
&
self
func_index
:
FuncIndex
)
-
>
SignatureIndex
{
self
.
info
.
functions
[
func_index
]
.
entity
}
pub
fn
get_num_func_imports
(
&
self
)
-
>
usize
{
self
.
info
.
imported_funcs
.
len
(
)
}
}
pub
struct
DummyFuncEnvironment
<
'
dummy_environment
>
{
pub
mod_info
:
&
'
dummy_environment
DummyModuleInfo
return_mode
:
ReturnMode
}
impl
<
'
dummy_environment
>
DummyFuncEnvironment
<
'
dummy_environment
>
{
pub
fn
new
(
mod_info
:
&
'
dummy_environment
DummyModuleInfo
return_mode
:
ReturnMode
)
-
>
Self
{
Self
{
mod_info
return_mode
}
}
fn
vmctx_sig
(
&
self
sigidx
:
SignatureIndex
)
-
>
ir
:
:
Signature
{
let
mut
sig
=
self
.
mod_info
.
signatures
[
sigidx
]
.
clone
(
)
;
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
special
(
self
.
pointer_type
(
)
ir
:
:
ArgumentPurpose
:
:
VMContext
)
)
;
sig
}
}
impl
<
'
dummy_environment
>
FuncEnvironment
for
DummyFuncEnvironment
<
'
dummy_environment
>
{
fn
target_config
(
&
self
)
-
>
TargetFrontendConfig
{
self
.
mod_info
.
config
}
fn
make_global
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
GlobalIndex
)
-
>
GlobalVariable
{
let
offset
=
cast
:
:
i32
(
(
index
.
index
(
)
*
8
)
+
8
)
.
unwrap
(
)
.
into
(
)
;
let
vmctx
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
VMContext
{
}
)
;
GlobalVariable
:
:
Memory
{
gv
:
vmctx
offset
ty
:
self
.
mod_info
.
globals
[
index
]
.
entity
.
ty
}
}
fn
make_heap
(
&
mut
self
func
:
&
mut
ir
:
:
Function
_index
:
MemoryIndex
)
-
>
ir
:
:
Heap
{
let
addr
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
VMContext
)
;
let
gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
addr
offset
:
Offset32
:
:
new
(
0
)
global_type
:
self
.
pointer_type
(
)
readonly
:
true
}
)
;
func
.
create_heap
(
ir
:
:
HeapData
{
base
:
gv
min_size
:
0
.
into
(
)
offset_guard_size
:
0x8000_0000
.
into
(
)
style
:
ir
:
:
HeapStyle
:
:
Static
{
bound
:
0x1_0000_0000
.
into
(
)
}
index_type
:
I32
}
)
}
fn
make_table
(
&
mut
self
func
:
&
mut
ir
:
:
Function
_index
:
TableIndex
)
-
>
ir
:
:
Table
{
let
vmctx
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
VMContext
)
;
let
base_gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
vmctx
offset
:
Offset32
:
:
new
(
0
)
global_type
:
self
.
pointer_type
(
)
readonly
:
true
}
)
;
let
bound_gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
vmctx
offset
:
Offset32
:
:
new
(
0
)
global_type
:
I32
readonly
:
true
}
)
;
func
.
create_table
(
ir
:
:
TableData
{
base_gv
min_size
:
Uimm64
:
:
new
(
0
)
bound_gv
element_size
:
Uimm64
:
:
from
(
u64
:
:
from
(
self
.
pointer_bytes
(
)
)
*
2
)
index_type
:
I32
}
)
}
fn
make_indirect_sig
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
SignatureIndex
)
-
>
ir
:
:
SigRef
{
func
.
import_signature
(
self
.
vmctx_sig
(
index
)
)
}
fn
make_direct_func
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
FuncIndex
)
-
>
ir
:
:
FuncRef
{
let
sigidx
=
self
.
mod_info
.
functions
[
index
]
.
entity
;
let
signature
=
func
.
import_signature
(
self
.
vmctx_sig
(
sigidx
)
)
;
let
name
=
get_func_name
(
index
)
;
func
.
import_function
(
ir
:
:
ExtFuncData
{
name
signature
colocated
:
false
}
)
}
fn
translate_call_indirect
(
&
mut
self
mut
pos
:
FuncCursor
_table_index
:
TableIndex
_table
:
ir
:
:
Table
_sig_index
:
SignatureIndex
sig_ref
:
ir
:
:
SigRef
callee
:
ir
:
:
Value
call_args
:
&
[
ir
:
:
Value
]
)
-
>
WasmResult
<
ir
:
:
Inst
>
{
let
vmctx
=
pos
.
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
parameter
"
)
;
let
ptr
=
self
.
pointer_type
(
)
;
let
callee_offset
=
if
ptr
=
=
I32
{
pos
.
ins
(
)
.
imul_imm
(
callee
4
)
}
else
{
let
ext
=
pos
.
ins
(
)
.
uextend
(
I64
callee
)
;
pos
.
ins
(
)
.
imul_imm
(
ext
4
)
}
;
let
mflags
=
ir
:
:
MemFlags
:
:
trusted
(
)
;
let
func_ptr
=
pos
.
ins
(
)
.
load
(
ptr
mflags
callee_offset
0
)
;
let
mut
args
=
ir
:
:
ValueList
:
:
default
(
)
;
args
.
push
(
func_ptr
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
args
.
extend
(
call_args
.
iter
(
)
.
cloned
(
)
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
args
.
push
(
vmctx
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
Ok
(
pos
.
ins
(
)
.
CallIndirect
(
ir
:
:
Opcode
:
:
CallIndirect
INVALID
sig_ref
args
)
.
0
)
}
fn
translate_call
(
&
mut
self
mut
pos
:
FuncCursor
_callee_index
:
FuncIndex
callee
:
ir
:
:
FuncRef
call_args
:
&
[
ir
:
:
Value
]
)
-
>
WasmResult
<
ir
:
:
Inst
>
{
let
vmctx
=
pos
.
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
parameter
"
)
;
let
mut
args
=
ir
:
:
ValueList
:
:
default
(
)
;
args
.
extend
(
call_args
.
iter
(
)
.
cloned
(
)
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
args
.
push
(
vmctx
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
Ok
(
pos
.
ins
(
)
.
Call
(
ir
:
:
Opcode
:
:
Call
INVALID
callee
args
)
.
0
)
}
fn
translate_memory_grow
(
&
mut
self
mut
pos
:
FuncCursor
_index
:
MemoryIndex
_heap
:
ir
:
:
Heap
_val
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
{
Ok
(
pos
.
ins
(
)
.
iconst
(
I32
-
1
)
)
}
fn
translate_memory_size
(
&
mut
self
mut
pos
:
FuncCursor
_index
:
MemoryIndex
_heap
:
ir
:
:
Heap
)
-
>
WasmResult
<
ir
:
:
Value
>
{
Ok
(
pos
.
ins
(
)
.
iconst
(
I32
-
1
)
)
}
fn
return_mode
(
&
self
)
-
>
ReturnMode
{
self
.
return_mode
}
}
impl
<
'
data
>
ModuleEnvironment
<
'
data
>
for
DummyEnvironment
{
fn
target_config
(
&
self
)
-
>
TargetFrontendConfig
{
self
.
info
.
config
}
fn
declare_signature
(
&
mut
self
sig
:
ir
:
:
Signature
)
{
self
.
info
.
signatures
.
push
(
sig
)
;
}
fn
declare_func_import
(
&
mut
self
sig_index
:
SignatureIndex
module
:
&
'
data
str
field
:
&
'
data
str
)
{
assert_eq
!
(
self
.
info
.
functions
.
len
(
)
self
.
info
.
imported_funcs
.
len
(
)
"
Imported
functions
must
be
declared
first
"
)
;
self
.
info
.
functions
.
push
(
Exportable
:
:
new
(
sig_index
)
)
;
self
.
info
.
imported_funcs
.
push
(
(
String
:
:
from
(
module
)
String
:
:
from
(
field
)
)
)
;
}
fn
declare_func_type
(
&
mut
self
sig_index
:
SignatureIndex
)
{
self
.
info
.
functions
.
push
(
Exportable
:
:
new
(
sig_index
)
)
;
}
fn
declare_global
(
&
mut
self
global
:
Global
)
{
self
.
info
.
globals
.
push
(
Exportable
:
:
new
(
global
)
)
;
}
fn
declare_global_import
(
&
mut
self
global
:
Global
module
:
&
'
data
str
field
:
&
'
data
str
)
{
self
.
info
.
globals
.
push
(
Exportable
:
:
new
(
global
)
)
;
self
.
info
.
imported_globals
.
push
(
(
String
:
:
from
(
module
)
String
:
:
from
(
field
)
)
)
;
}
fn
declare_table
(
&
mut
self
table
:
Table
)
{
self
.
info
.
tables
.
push
(
Exportable
:
:
new
(
table
)
)
;
}
fn
declare_table_import
(
&
mut
self
table
:
Table
module
:
&
'
data
str
field
:
&
'
data
str
)
{
self
.
info
.
tables
.
push
(
Exportable
:
:
new
(
table
)
)
;
self
.
info
.
imported_tables
.
push
(
(
String
:
:
from
(
module
)
String
:
:
from
(
field
)
)
)
;
}
fn
declare_table_elements
(
&
mut
self
_table_index
:
TableIndex
_base
:
Option
<
GlobalIndex
>
_offset
:
usize
_elements
:
Box
<
[
FuncIndex
]
>
)
{
}
fn
declare_memory
(
&
mut
self
memory
:
Memory
)
{
self
.
info
.
memories
.
push
(
Exportable
:
:
new
(
memory
)
)
;
}
fn
declare_memory_import
(
&
mut
self
memory
:
Memory
module
:
&
'
data
str
field
:
&
'
data
str
)
{
self
.
info
.
memories
.
push
(
Exportable
:
:
new
(
memory
)
)
;
self
.
info
.
imported_memories
.
push
(
(
String
:
:
from
(
module
)
String
:
:
from
(
field
)
)
)
;
}
fn
declare_data_initialization
(
&
mut
self
_memory_index
:
MemoryIndex
_base
:
Option
<
GlobalIndex
>
_offset
:
usize
_data
:
&
'
data
[
u8
]
)
{
}
fn
declare_func_export
(
&
mut
self
func_index
:
FuncIndex
name
:
&
'
data
str
)
{
self
.
info
.
functions
[
func_index
]
.
export_names
.
push
(
String
:
:
from
(
name
)
)
;
}
fn
declare_table_export
(
&
mut
self
table_index
:
TableIndex
name
:
&
'
data
str
)
{
self
.
info
.
tables
[
table_index
]
.
export_names
.
push
(
String
:
:
from
(
name
)
)
;
}
fn
declare_memory_export
(
&
mut
self
memory_index
:
MemoryIndex
name
:
&
'
data
str
)
{
self
.
info
.
memories
[
memory_index
]
.
export_names
.
push
(
String
:
:
from
(
name
)
)
;
}
fn
declare_global_export
(
&
mut
self
global_index
:
GlobalIndex
name
:
&
'
data
str
)
{
self
.
info
.
globals
[
global_index
]
.
export_names
.
push
(
String
:
:
from
(
name
)
)
;
}
fn
declare_start_func
(
&
mut
self
func_index
:
FuncIndex
)
{
debug_assert
!
(
self
.
info
.
start_func
.
is_none
(
)
)
;
self
.
info
.
start_func
=
Some
(
func_index
)
;
}
fn
define_function_body
(
&
mut
self
body_bytes
:
&
'
data
[
u8
]
)
-
>
WasmResult
<
(
)
>
{
let
func
=
{
let
mut
func_environ
=
DummyFuncEnvironment
:
:
new
(
&
self
.
info
self
.
return_mode
)
;
let
func_index
=
FuncIndex
:
:
new
(
self
.
get_num_func_imports
(
)
+
self
.
info
.
function_bodies
.
len
(
)
)
;
let
name
=
get_func_name
(
func_index
)
;
let
sig
=
func_environ
.
vmctx_sig
(
self
.
get_func_type
(
func_index
)
)
;
let
mut
func
=
ir
:
:
Function
:
:
with_name_signature
(
name
sig
)
;
self
.
trans
.
translate
(
body_bytes
&
mut
func
&
mut
func_environ
)
?
;
func
}
;
self
.
func_bytecode_sizes
.
push
(
body_bytes
.
len
(
)
)
;
self
.
info
.
function_bodies
.
push
(
func
)
;
Ok
(
(
)
)
}
}
