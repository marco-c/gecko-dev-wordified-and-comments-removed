use
core_foundation_sys
:
:
base
:
:
{
kCFAllocatorDefault
CFRelease
CFTypeRef
}
;
pub
use
core_foundation_sys
:
:
set
:
:
*
;
use
crate
:
:
base
:
:
{
CFIndexConvertible
TCFType
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
pub
struct
CFSet
<
T
=
*
const
c_void
>
(
CFSetRef
PhantomData
<
T
>
)
;
impl
<
T
>
Drop
for
CFSet
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
CFRelease
(
self
.
as_CFTypeRef
(
)
)
}
}
}
impl_TCFType
!
(
CFSet
<
T
>
CFSetRef
CFSetGetTypeID
)
;
impl_CFTypeDescription
!
(
CFSet
)
;
impl
CFSet
{
pub
fn
from_slice
<
T
>
(
elems
:
&
[
T
]
)
-
>
CFSet
<
T
>
where
T
:
TCFType
{
unsafe
{
let
elems
:
Vec
<
CFTypeRef
>
=
elems
.
iter
(
)
.
map
(
|
elem
|
elem
.
as_CFTypeRef
(
)
)
.
collect
(
)
;
let
set_ref
=
CFSetCreate
(
kCFAllocatorDefault
elems
.
as_ptr
(
)
elems
.
len
(
)
.
to_CFIndex
(
)
&
kCFTypeSetCallBacks
)
;
TCFType
:
:
wrap_under_create_rule
(
set_ref
)
}
}
}
impl
<
T
>
CFSet
<
T
>
{
pub
fn
len
(
&
self
)
-
>
usize
{
unsafe
{
CFSetGetCount
(
self
.
0
)
as
usize
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
}
