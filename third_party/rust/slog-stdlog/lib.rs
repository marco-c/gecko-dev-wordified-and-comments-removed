#
!
[
warn
(
missing_docs
)
]
#
[
macro_use
]
extern
crate
slog
;
extern
crate
slog_term
;
extern
crate
log
;
#
[
macro_use
]
extern
crate
lazy_static
;
extern
crate
crossbeam
;
use
slog
:
:
{
DrainExt
ser
}
;
use
log
:
:
LogMetadata
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
{
io
fmt
}
;
use
std
:
:
io
:
:
Write
;
use
slog
:
:
Level
;
use
crossbeam
:
:
sync
:
:
ArcCell
;
thread_local
!
{
static
TL_SCOPES
:
RefCell
<
Vec
<
slog
:
:
Logger
>
>
=
RefCell
:
:
new
(
Vec
:
:
with_capacity
(
8
)
)
}
lazy_static
!
{
static
ref
GLOBAL_LOGGER
:
ArcCell
<
slog
:
:
Logger
>
=
ArcCell
:
:
new
(
Arc
:
:
new
(
slog
:
:
Logger
:
:
root
(
slog
:
:
Discard
o
!
(
)
)
)
)
;
}
fn
set_global_logger
(
l
:
slog
:
:
Logger
)
{
let
_
=
GLOBAL_LOGGER
.
set
(
Arc
:
:
new
(
l
)
)
;
}
struct
Logger
;
fn
log_to_slog_level
(
level
:
log
:
:
LogLevel
)
-
>
Level
{
match
level
{
log
:
:
LogLevel
:
:
Trace
=
>
Level
:
:
Trace
log
:
:
LogLevel
:
:
Debug
=
>
Level
:
:
Debug
log
:
:
LogLevel
:
:
Info
=
>
Level
:
:
Info
log
:
:
LogLevel
:
:
Warn
=
>
Level
:
:
Warning
log
:
:
LogLevel
:
:
Error
=
>
Level
:
:
Error
}
}
impl
log
:
:
Log
for
Logger
{
fn
enabled
(
&
self
_
:
&
LogMetadata
)
-
>
bool
{
true
}
fn
log
(
&
self
r
:
&
log
:
:
LogRecord
)
{
let
level
=
log_to_slog_level
(
r
.
metadata
(
)
.
level
(
)
)
;
let
args
=
r
.
args
(
)
;
let
target
=
r
.
target
(
)
;
let
module
=
r
.
location
(
)
.
__module_path
;
let
file
=
r
.
location
(
)
.
__file
;
let
line
=
r
.
location
(
)
.
line
(
)
;
with_current_logger
(
|
l
|
{
let
s
=
slog
:
:
RecordStatic
{
level
:
level
file
:
file
line
:
line
column
:
0
function
:
"
"
module
:
module
target
:
target
}
;
l
.
log
(
&
slog
:
:
Record
:
:
new
(
&
s
*
args
&
[
]
)
)
}
)
}
}
pub
fn
set_logger
(
logger
:
slog
:
:
Logger
)
-
>
Result
<
(
)
log
:
:
SetLoggerError
>
{
log
:
:
set_logger
(
|
max_log_level
|
{
max_log_level
.
set
(
log
:
:
LogLevelFilter
:
:
max
(
)
)
;
set_global_logger
(
logger
)
;
Box
:
:
new
(
Logger
)
}
)
}
pub
fn
set_logger_level
(
logger
:
slog
:
:
Logger
log_level_filter
:
log
:
:
LogLevelFilter
)
-
>
Result
<
(
)
log
:
:
SetLoggerError
>
{
log
:
:
set_logger
(
|
max_log_level
|
{
max_log_level
.
set
(
log_level_filter
)
;
set_global_logger
(
logger
)
;
Box
:
:
new
(
Logger
)
}
)
}
pub
fn
init
(
)
-
>
Result
<
(
)
log
:
:
SetLoggerError
>
{
let
drain
=
slog
:
:
level_filter
(
Level
:
:
Info
slog_term
:
:
streamer
(
)
.
compact
(
)
.
build
(
)
)
;
set_logger
(
slog
:
:
Logger
:
:
root
(
drain
.
fuse
(
)
o
!
(
)
)
)
}
struct
ScopeGuard
;
impl
ScopeGuard
{
fn
new
(
logger
:
slog
:
:
Logger
)
-
>
Self
{
TL_SCOPES
.
with
(
|
s
|
{
s
.
borrow_mut
(
)
.
push
(
logger
)
;
}
)
;
ScopeGuard
}
}
impl
Drop
for
ScopeGuard
{
fn
drop
(
&
mut
self
)
{
TL_SCOPES
.
with
(
|
s
|
{
s
.
borrow_mut
(
)
.
pop
(
)
.
expect
(
"
TL_SCOPES
should
contain
a
logger
"
)
;
}
)
}
}
pub
fn
with_current_logger
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
slog
:
:
Logger
)
-
>
R
{
TL_SCOPES
.
with
(
|
s
|
{
let
s
=
s
.
borrow
(
)
;
if
s
.
is_empty
(
)
{
f
(
&
GLOBAL_LOGGER
.
get
(
)
)
}
else
{
f
(
&
s
[
s
.
len
(
)
-
1
]
)
}
}
)
}
pub
fn
logger
(
)
-
>
slog
:
:
Logger
{
TL_SCOPES
.
with
(
|
s
|
{
let
s
=
s
.
borrow
(
)
;
if
s
.
is_empty
(
)
{
(
*
GLOBAL_LOGGER
.
get
(
)
)
.
clone
(
)
}
else
{
s
[
s
.
len
(
)
-
1
]
.
clone
(
)
}
}
)
}
pub
fn
scope
<
SF
R
>
(
logger
:
slog
:
:
Logger
f
:
SF
)
-
>
R
where
SF
:
FnOnce
(
)
-
>
R
{
let
_guard
=
ScopeGuard
:
:
new
(
logger
)
;
f
(
)
}
pub
struct
StdLog
;
struct
LazyLogString
<
'
a
>
{
info
:
&
'
a
slog
:
:
Record
<
'
a
>
logger_values
:
&
'
a
slog
:
:
OwnedKeyValueList
}
impl
<
'
a
>
LazyLogString
<
'
a
>
{
fn
new
(
info
:
&
'
a
slog
:
:
Record
logger_values
:
&
'
a
slog
:
:
OwnedKeyValueList
)
-
>
Self
{
LazyLogString
{
info
:
info
logger_values
:
logger_values
}
}
}
impl
<
'
a
>
fmt
:
:
Display
for
LazyLogString
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
try
!
(
write
!
(
f
"
{
}
"
self
.
info
.
msg
(
)
)
)
;
let
io
=
io
:
:
Cursor
:
:
new
(
Vec
:
:
new
(
)
)
;
let
mut
ser
=
KSV
:
:
new
(
io
"
:
"
.
into
(
)
)
;
let
res
=
{
|
|
-
>
io
:
:
Result
<
(
)
>
{
for
(
ref
k
ref
v
)
in
self
.
logger_values
.
iter
(
)
{
try
!
(
ser
.
io
(
)
.
write_all
(
"
"
.
as_bytes
(
)
)
)
;
try
!
(
v
.
serialize
(
self
.
info
k
&
mut
ser
)
)
;
}
for
&
(
ref
k
ref
v
)
in
self
.
info
.
values
(
)
.
iter
(
)
{
try
!
(
ser
.
io
(
)
.
write_all
(
"
"
.
as_bytes
(
)
)
)
;
try
!
(
v
.
serialize
(
self
.
info
k
&
mut
ser
)
)
;
}
Ok
(
(
)
)
}
}
(
)
.
map_err
(
|
_
|
fmt
:
:
Error
)
;
try
!
(
res
)
;
let
values
=
ser
.
into_inner
(
)
.
into_inner
(
)
;
write
!
(
f
"
{
}
"
String
:
:
from_utf8_lossy
(
&
values
)
)
}
}
impl
slog
:
:
Drain
for
StdLog
{
type
Error
=
io
:
:
Error
;
fn
log
(
&
self
info
:
&
slog
:
:
Record
logger_values
:
&
slog
:
:
OwnedKeyValueList
)
-
>
io
:
:
Result
<
(
)
>
{
let
level
=
match
info
.
level
(
)
{
slog
:
:
Level
:
:
Critical
=
>
log
:
:
LogLevel
:
:
Error
slog
:
:
Level
:
:
Error
=
>
log
:
:
LogLevel
:
:
Error
slog
:
:
Level
:
:
Warning
=
>
log
:
:
LogLevel
:
:
Warn
slog
:
:
Level
:
:
Info
=
>
log
:
:
LogLevel
:
:
Info
slog
:
:
Level
:
:
Debug
=
>
log
:
:
LogLevel
:
:
Debug
slog
:
:
Level
:
:
Trace
=
>
log
:
:
LogLevel
:
:
Trace
}
;
let
target
=
info
.
target
(
)
;
let
location
=
log
:
:
LogLocation
{
__module_path
:
info
.
module
(
)
__file
:
info
.
file
(
)
__line
:
info
.
line
(
)
}
;
let
lazy
=
LazyLogString
:
:
new
(
info
logger_values
)
;
log
:
:
__log
(
level
target
&
location
format_args
!
(
"
{
}
"
lazy
)
)
;
Ok
(
(
)
)
}
}
struct
KSV
<
W
:
io
:
:
Write
>
{
separator
:
String
io
:
W
}
impl
<
W
:
io
:
:
Write
>
KSV
<
W
>
{
fn
new
(
io
:
W
separator
:
String
)
-
>
Self
{
KSV
{
io
:
io
separator
:
separator
}
}
fn
io
(
&
mut
self
)
-
>
&
mut
W
{
&
mut
self
.
io
}
fn
into_inner
(
self
)
-
>
W
{
self
.
io
}
}
impl
<
W
:
io
:
:
Write
>
ser
:
:
Serializer
for
KSV
<
W
>
{
fn
emit_none
(
&
mut
self
key
:
&
str
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
"
None
"
)
)
;
Ok
(
(
)
)
}
fn
emit_unit
(
&
mut
self
key
:
&
str
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
"
key
)
)
;
Ok
(
(
)
)
}
fn
emit_bool
(
&
mut
self
key
:
&
str
val
:
bool
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_char
(
&
mut
self
key
:
&
str
val
:
char
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_usize
(
&
mut
self
key
:
&
str
val
:
usize
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_isize
(
&
mut
self
key
:
&
str
val
:
isize
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_u8
(
&
mut
self
key
:
&
str
val
:
u8
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_i8
(
&
mut
self
key
:
&
str
val
:
i8
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_u16
(
&
mut
self
key
:
&
str
val
:
u16
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_i16
(
&
mut
self
key
:
&
str
val
:
i16
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_u32
(
&
mut
self
key
:
&
str
val
:
u32
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_i32
(
&
mut
self
key
:
&
str
val
:
i32
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_f32
(
&
mut
self
key
:
&
str
val
:
f32
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_u64
(
&
mut
self
key
:
&
str
val
:
u64
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_i64
(
&
mut
self
key
:
&
str
val
:
i64
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_f64
(
&
mut
self
key
:
&
str
val
:
f64
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_str
(
&
mut
self
key
:
&
str
val
:
&
str
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
fn
emit_arguments
(
&
mut
self
key
:
&
str
val
:
&
fmt
:
:
Arguments
)
-
>
ser
:
:
Result
{
try
!
(
write
!
(
self
.
io
"
{
}
{
}
{
}
"
key
self
.
separator
val
)
)
;
Ok
(
(
)
)
}
}
