use
crate
:
:
alloc
:
:
borrow
:
:
Cow
;
use
crate
:
:
{
Relocation
SectionIndex
SectionKind
Symbol
SymbolIndex
SymbolMap
}
;
use
target_lexicon
:
:
{
Architecture
Endianness
}
;
use
uuid
:
:
Uuid
;
pub
trait
Object
<
'
data
'
file
>
{
type
Segment
:
ObjectSegment
<
'
data
>
;
type
SegmentIterator
:
Iterator
<
Item
=
Self
:
:
Segment
>
;
type
Section
:
ObjectSection
<
'
data
>
;
type
SectionIterator
:
Iterator
<
Item
=
Self
:
:
Section
>
;
type
SymbolIterator
:
Iterator
<
Item
=
(
SymbolIndex
Symbol
<
'
data
>
)
>
;
fn
architecture
(
&
self
)
-
>
Architecture
;
#
[
inline
]
fn
endianness
(
&
self
)
-
>
Endianness
{
if
self
.
is_little_endian
(
)
{
Endianness
:
:
Little
}
else
{
Endianness
:
:
Big
}
}
fn
is_little_endian
(
&
self
)
-
>
bool
;
fn
is_64
(
&
self
)
-
>
bool
;
fn
segments
(
&
'
file
self
)
-
>
Self
:
:
SegmentIterator
;
fn
entry
(
&
'
file
self
)
-
>
u64
;
fn
section_by_name
(
&
'
file
self
section_name
:
&
str
)
-
>
Option
<
Self
:
:
Section
>
;
fn
section_by_index
(
&
'
file
self
index
:
SectionIndex
)
-
>
Option
<
Self
:
:
Section
>
;
fn
section_data_by_name
(
&
'
file
self
section_name
:
&
str
)
-
>
Option
<
Cow
<
'
data
[
u8
]
>
>
{
self
.
section_by_name
(
section_name
)
.
map
(
|
section
|
section
.
uncompressed_data
(
)
)
}
fn
sections
(
&
'
file
self
)
-
>
Self
:
:
SectionIterator
;
fn
symbol_by_index
(
&
self
index
:
SymbolIndex
)
-
>
Option
<
Symbol
<
'
data
>
>
;
fn
symbols
(
&
'
file
self
)
-
>
Self
:
:
SymbolIterator
;
fn
symbol_data
(
&
'
file
self
symbol
:
&
Symbol
<
'
data
>
)
-
>
Option
<
&
'
data
[
u8
]
>
{
if
symbol
.
is_undefined
(
)
{
return
None
;
}
let
address
=
symbol
.
address
(
)
;
let
size
=
symbol
.
size
(
)
;
if
let
Some
(
index
)
=
symbol
.
section_index
(
)
{
self
.
section_by_index
(
index
)
.
and_then
(
|
section
|
section
.
data_range
(
address
size
)
)
}
else
{
self
.
segments
(
)
.
find_map
(
|
segment
|
segment
.
data_range
(
address
size
)
)
}
}
fn
dynamic_symbols
(
&
'
file
self
)
-
>
Self
:
:
SymbolIterator
;
fn
symbol_map
(
&
self
)
-
>
SymbolMap
<
'
data
>
;
fn
has_debug_symbols
(
&
self
)
-
>
bool
;
#
[
inline
]
fn
mach_uuid
(
&
self
)
-
>
Option
<
Uuid
>
{
None
}
#
[
inline
]
fn
build_id
(
&
self
)
-
>
Option
<
&
'
data
[
u8
]
>
{
None
}
#
[
inline
]
fn
gnu_debuglink
(
&
self
)
-
>
Option
<
(
&
'
data
[
u8
]
u32
)
>
{
None
}
}
pub
trait
ObjectSegment
<
'
data
>
{
fn
address
(
&
self
)
-
>
u64
;
fn
size
(
&
self
)
-
>
u64
;
fn
align
(
&
self
)
-
>
u64
;
fn
file_range
(
&
self
)
-
>
(
u64
u64
)
;
fn
data
(
&
self
)
-
>
&
'
data
[
u8
]
;
fn
data_range
(
&
self
address
:
u64
size
:
u64
)
-
>
Option
<
&
'
data
[
u8
]
>
;
fn
name
(
&
self
)
-
>
Option
<
&
str
>
;
}
pub
trait
ObjectSection
<
'
data
>
{
type
RelocationIterator
:
Iterator
<
Item
=
(
u64
Relocation
)
>
;
fn
index
(
&
self
)
-
>
SectionIndex
;
fn
address
(
&
self
)
-
>
u64
;
fn
size
(
&
self
)
-
>
u64
;
fn
align
(
&
self
)
-
>
u64
;
fn
file_range
(
&
self
)
-
>
Option
<
(
u64
u64
)
>
;
fn
data
(
&
self
)
-
>
Cow
<
'
data
[
u8
]
>
;
fn
data_range
(
&
self
address
:
u64
size
:
u64
)
-
>
Option
<
&
'
data
[
u8
]
>
;
fn
uncompressed_data
(
&
self
)
-
>
Cow
<
'
data
[
u8
]
>
;
fn
name
(
&
self
)
-
>
Option
<
&
str
>
;
fn
segment_name
(
&
self
)
-
>
Option
<
&
str
>
;
fn
kind
(
&
self
)
-
>
SectionKind
;
fn
relocations
(
&
self
)
-
>
Self
:
:
RelocationIterator
;
}
