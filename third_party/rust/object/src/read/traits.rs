use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
vec
:
:
Vec
;
use
crate
:
:
endian
:
:
Endianness
;
use
crate
:
:
read
:
:
{
self
Architecture
CodeView
ComdatKind
CompressedData
CompressedFileRange
Export
FileFlags
Import
ObjectKind
ObjectMap
Relocation
RelocationMap
Result
SectionFlags
SectionIndex
SectionKind
SegmentFlags
SubArchitecture
SymbolFlags
SymbolIndex
SymbolKind
SymbolMap
SymbolMapName
SymbolScope
SymbolSection
}
;
pub
trait
Object
<
'
data
>
:
read
:
:
private
:
:
Sealed
{
type
Segment
<
'
file
>
:
ObjectSegment
<
'
data
>
where
Self
:
'
file
'
data
:
'
file
;
type
SegmentIterator
<
'
file
>
:
Iterator
<
Item
=
Self
:
:
Segment
<
'
file
>
>
where
Self
:
'
file
'
data
:
'
file
;
type
Section
<
'
file
>
:
ObjectSection
<
'
data
>
where
Self
:
'
file
'
data
:
'
file
;
type
SectionIterator
<
'
file
>
:
Iterator
<
Item
=
Self
:
:
Section
<
'
file
>
>
where
Self
:
'
file
'
data
:
'
file
;
type
Comdat
<
'
file
>
:
ObjectComdat
<
'
data
>
where
Self
:
'
file
'
data
:
'
file
;
type
ComdatIterator
<
'
file
>
:
Iterator
<
Item
=
Self
:
:
Comdat
<
'
file
>
>
where
Self
:
'
file
'
data
:
'
file
;
type
Symbol
<
'
file
>
:
ObjectSymbol
<
'
data
>
where
Self
:
'
file
'
data
:
'
file
;
type
SymbolIterator
<
'
file
>
:
Iterator
<
Item
=
Self
:
:
Symbol
<
'
file
>
>
where
Self
:
'
file
'
data
:
'
file
;
type
SymbolTable
<
'
file
>
:
ObjectSymbolTable
<
'
data
Symbol
=
Self
:
:
Symbol
<
'
file
>
SymbolIterator
=
Self
:
:
SymbolIterator
<
'
file
>
>
where
Self
:
'
file
'
data
:
'
file
;
type
DynamicRelocationIterator
<
'
file
>
:
Iterator
<
Item
=
(
u64
Relocation
)
>
where
Self
:
'
file
'
data
:
'
file
;
fn
architecture
(
&
self
)
-
>
Architecture
;
fn
sub_architecture
(
&
self
)
-
>
Option
<
SubArchitecture
>
{
None
}
#
[
inline
]
fn
endianness
(
&
self
)
-
>
Endianness
{
if
self
.
is_little_endian
(
)
{
Endianness
:
:
Little
}
else
{
Endianness
:
:
Big
}
}
fn
is_little_endian
(
&
self
)
-
>
bool
;
fn
is_64
(
&
self
)
-
>
bool
;
fn
kind
(
&
self
)
-
>
ObjectKind
;
fn
segments
(
&
self
)
-
>
Self
:
:
SegmentIterator
<
'
_
>
;
fn
section_by_name
(
&
self
section_name
:
&
str
)
-
>
Option
<
Self
:
:
Section
<
'
_
>
>
{
self
.
section_by_name_bytes
(
section_name
.
as_bytes
(
)
)
}
fn
section_by_name_bytes
<
'
file
>
(
&
'
file
self
section_name
:
&
[
u8
]
)
-
>
Option
<
Self
:
:
Section
<
'
file
>
>
;
fn
section_by_index
(
&
self
index
:
SectionIndex
)
-
>
Result
<
Self
:
:
Section
<
'
_
>
>
;
fn
sections
(
&
self
)
-
>
Self
:
:
SectionIterator
<
'
_
>
;
fn
comdats
(
&
self
)
-
>
Self
:
:
ComdatIterator
<
'
_
>
;
fn
symbol_table
(
&
self
)
-
>
Option
<
Self
:
:
SymbolTable
<
'
_
>
>
;
fn
symbol_by_index
(
&
self
index
:
SymbolIndex
)
-
>
Result
<
Self
:
:
Symbol
<
'
_
>
>
;
fn
symbols
(
&
self
)
-
>
Self
:
:
SymbolIterator
<
'
_
>
;
fn
symbol_by_name
<
'
file
>
(
&
'
file
self
symbol_name
:
&
str
)
-
>
Option
<
Self
:
:
Symbol
<
'
file
>
>
{
self
.
symbol_by_name_bytes
(
symbol_name
.
as_bytes
(
)
)
}
fn
symbol_by_name_bytes
<
'
file
>
(
&
'
file
self
symbol_name
:
&
[
u8
]
)
-
>
Option
<
Self
:
:
Symbol
<
'
file
>
>
{
self
.
symbols
(
)
.
find
(
|
sym
|
sym
.
name_bytes
(
)
=
=
Ok
(
symbol_name
)
)
}
fn
dynamic_symbol_table
(
&
self
)
-
>
Option
<
Self
:
:
SymbolTable
<
'
_
>
>
;
fn
dynamic_symbols
(
&
self
)
-
>
Self
:
:
SymbolIterator
<
'
_
>
;
fn
dynamic_relocations
(
&
self
)
-
>
Option
<
Self
:
:
DynamicRelocationIterator
<
'
_
>
>
;
fn
symbol_map
(
&
self
)
-
>
SymbolMap
<
SymbolMapName
<
'
data
>
>
{
let
mut
symbols
=
Vec
:
:
new
(
)
;
if
let
Some
(
table
)
=
self
.
symbol_table
(
)
.
or_else
(
|
|
self
.
dynamic_symbol_table
(
)
)
{
let
mut
all_symbols
=
Vec
:
:
new
(
)
;
for
symbol
in
table
.
symbols
(
)
{
if
!
symbol
.
is_definition
(
)
{
continue
;
}
let
name
=
match
symbol
.
name
(
)
{
Ok
(
name
)
=
>
name
_
=
>
continue
}
;
if
name
.
is_empty
(
)
{
continue
;
}
let
mut
priority
=
0u32
;
match
symbol
.
kind
(
)
{
SymbolKind
:
:
Text
|
SymbolKind
:
:
Data
=
>
{
}
SymbolKind
:
:
Unknown
=
>
priority
+
=
1
_
=
>
continue
}
priority
*
=
2
;
priority
+
=
match
symbol
.
scope
(
)
{
SymbolScope
:
:
Unknown
=
>
3
SymbolScope
:
:
Compilation
=
>
2
SymbolScope
:
:
Linkage
=
>
1
SymbolScope
:
:
Dynamic
=
>
0
}
;
priority
*
=
4
;
let
index
=
!
0
-
symbol
.
index
(
)
.
0
;
all_symbols
.
push
(
(
symbol
.
address
(
)
priority
index
name
)
)
;
}
all_symbols
.
sort_unstable
(
)
;
let
mut
previous_address
=
!
0
;
for
(
address
_priority
_index
name
)
in
all_symbols
{
if
address
!
=
previous_address
{
symbols
.
push
(
SymbolMapName
:
:
new
(
address
name
)
)
;
previous_address
=
address
;
}
}
}
SymbolMap
:
:
new
(
symbols
)
}
fn
object_map
(
&
self
)
-
>
ObjectMap
<
'
data
>
{
ObjectMap
:
:
default
(
)
}
fn
imports
(
&
self
)
-
>
Result
<
Vec
<
Import
<
'
data
>
>
>
;
fn
exports
(
&
self
)
-
>
Result
<
Vec
<
Export
<
'
data
>
>
>
;
fn
has_debug_symbols
(
&
self
)
-
>
bool
;
#
[
inline
]
fn
mach_uuid
(
&
self
)
-
>
Result
<
Option
<
[
u8
;
16
]
>
>
{
Ok
(
None
)
}
#
[
inline
]
fn
build_id
(
&
self
)
-
>
Result
<
Option
<
&
'
data
[
u8
]
>
>
{
Ok
(
None
)
}
#
[
inline
]
fn
gnu_debuglink
(
&
self
)
-
>
Result
<
Option
<
(
&
'
data
[
u8
]
u32
)
>
>
{
Ok
(
None
)
}
#
[
inline
]
fn
gnu_debugaltlink
(
&
self
)
-
>
Result
<
Option
<
(
&
'
data
[
u8
]
&
'
data
[
u8
]
)
>
>
{
Ok
(
None
)
}
#
[
inline
]
fn
pdb_info
(
&
self
)
-
>
Result
<
Option
<
CodeView
<
'
_
>
>
>
{
Ok
(
None
)
}
fn
relative_address_base
(
&
self
)
-
>
u64
;
fn
entry
(
&
self
)
-
>
u64
;
fn
flags
(
&
self
)
-
>
FileFlags
;
}
pub
trait
ObjectSegment
<
'
data
>
:
read
:
:
private
:
:
Sealed
{
fn
address
(
&
self
)
-
>
u64
;
fn
size
(
&
self
)
-
>
u64
;
fn
align
(
&
self
)
-
>
u64
;
fn
file_range
(
&
self
)
-
>
(
u64
u64
)
;
fn
data
(
&
self
)
-
>
Result
<
&
'
data
[
u8
]
>
;
fn
data_range
(
&
self
address
:
u64
size
:
u64
)
-
>
Result
<
Option
<
&
'
data
[
u8
]
>
>
;
fn
name_bytes
(
&
self
)
-
>
Result
<
Option
<
&
[
u8
]
>
>
;
fn
name
(
&
self
)
-
>
Result
<
Option
<
&
str
>
>
;
fn
flags
(
&
self
)
-
>
SegmentFlags
;
}
pub
trait
ObjectSection
<
'
data
>
:
read
:
:
private
:
:
Sealed
{
type
RelocationIterator
:
Iterator
<
Item
=
(
u64
Relocation
)
>
;
fn
index
(
&
self
)
-
>
SectionIndex
;
fn
address
(
&
self
)
-
>
u64
;
fn
size
(
&
self
)
-
>
u64
;
fn
align
(
&
self
)
-
>
u64
;
fn
file_range
(
&
self
)
-
>
Option
<
(
u64
u64
)
>
;
fn
data
(
&
self
)
-
>
Result
<
&
'
data
[
u8
]
>
;
fn
data_range
(
&
self
address
:
u64
size
:
u64
)
-
>
Result
<
Option
<
&
'
data
[
u8
]
>
>
;
fn
compressed_file_range
(
&
self
)
-
>
Result
<
CompressedFileRange
>
;
fn
compressed_data
(
&
self
)
-
>
Result
<
CompressedData
<
'
data
>
>
;
fn
uncompressed_data
(
&
self
)
-
>
Result
<
Cow
<
'
data
[
u8
]
>
>
{
self
.
compressed_data
(
)
?
.
decompress
(
)
}
fn
name_bytes
(
&
self
)
-
>
Result
<
&
'
data
[
u8
]
>
;
fn
name
(
&
self
)
-
>
Result
<
&
'
data
str
>
;
fn
segment_name_bytes
(
&
self
)
-
>
Result
<
Option
<
&
[
u8
]
>
>
;
fn
segment_name
(
&
self
)
-
>
Result
<
Option
<
&
str
>
>
;
fn
kind
(
&
self
)
-
>
SectionKind
;
fn
relocations
(
&
self
)
-
>
Self
:
:
RelocationIterator
;
fn
relocation_map
(
&
self
)
-
>
Result
<
RelocationMap
>
;
fn
flags
(
&
self
)
-
>
SectionFlags
;
}
pub
trait
ObjectComdat
<
'
data
>
:
read
:
:
private
:
:
Sealed
{
type
SectionIterator
:
Iterator
<
Item
=
SectionIndex
>
;
fn
kind
(
&
self
)
-
>
ComdatKind
;
fn
symbol
(
&
self
)
-
>
SymbolIndex
;
fn
name_bytes
(
&
self
)
-
>
Result
<
&
'
data
[
u8
]
>
;
fn
name
(
&
self
)
-
>
Result
<
&
'
data
str
>
;
fn
sections
(
&
self
)
-
>
Self
:
:
SectionIterator
;
}
pub
trait
ObjectSymbolTable
<
'
data
>
:
read
:
:
private
:
:
Sealed
{
type
Symbol
:
ObjectSymbol
<
'
data
>
;
type
SymbolIterator
:
Iterator
<
Item
=
Self
:
:
Symbol
>
;
fn
symbols
(
&
self
)
-
>
Self
:
:
SymbolIterator
;
fn
symbol_by_index
(
&
self
index
:
SymbolIndex
)
-
>
Result
<
Self
:
:
Symbol
>
;
}
pub
trait
ObjectSymbol
<
'
data
>
:
read
:
:
private
:
:
Sealed
{
fn
index
(
&
self
)
-
>
SymbolIndex
;
fn
name_bytes
(
&
self
)
-
>
Result
<
&
'
data
[
u8
]
>
;
fn
name
(
&
self
)
-
>
Result
<
&
'
data
str
>
;
fn
address
(
&
self
)
-
>
u64
;
fn
size
(
&
self
)
-
>
u64
;
fn
kind
(
&
self
)
-
>
SymbolKind
;
fn
section
(
&
self
)
-
>
SymbolSection
;
fn
section_index
(
&
self
)
-
>
Option
<
SectionIndex
>
{
self
.
section
(
)
.
index
(
)
}
fn
is_undefined
(
&
self
)
-
>
bool
;
fn
is_definition
(
&
self
)
-
>
bool
;
fn
is_common
(
&
self
)
-
>
bool
;
fn
is_weak
(
&
self
)
-
>
bool
;
fn
scope
(
&
self
)
-
>
SymbolScope
;
fn
is_global
(
&
self
)
-
>
bool
;
fn
is_local
(
&
self
)
-
>
bool
;
fn
flags
(
&
self
)
-
>
SymbolFlags
<
SectionIndex
SymbolIndex
>
;
}
#
[
derive
(
Debug
)
]
pub
struct
NoDynamicRelocationIterator
;
impl
Iterator
for
NoDynamicRelocationIterator
{
type
Item
=
(
u64
Relocation
)
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
None
}
}
