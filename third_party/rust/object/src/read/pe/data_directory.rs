use
core
:
:
slice
;
use
crate
:
:
endian
:
:
LittleEndian
as
LE
;
use
crate
:
:
pe
;
use
crate
:
:
read
:
:
{
Error
ReadError
ReadRef
Result
}
;
use
super
:
:
{
DelayLoadImportTable
ExportTable
ImportTable
RelocationBlockIterator
ResourceDirectory
SectionTable
}
;
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
DataDirectories
<
'
data
>
{
entries
:
&
'
data
[
pe
:
:
ImageDataDirectory
]
}
impl
<
'
data
>
DataDirectories
<
'
data
>
{
pub
fn
parse
(
data
:
&
'
data
[
u8
]
number
:
u32
)
-
>
Result
<
Self
>
{
let
entries
=
data
.
read_slice_at
(
0
number
as
usize
)
.
read_error
(
"
Invalid
PE
number
of
RVA
and
sizes
"
)
?
;
Ok
(
DataDirectories
{
entries
}
)
}
#
[
allow
(
clippy
:
:
len_without_is_empty
)
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
entries
.
len
(
)
}
pub
fn
iter
(
&
self
)
-
>
slice
:
:
Iter
<
'
data
pe
:
:
ImageDataDirectory
>
{
self
.
entries
.
iter
(
)
}
pub
fn
enumerate
(
&
self
)
-
>
core
:
:
iter
:
:
Enumerate
<
slice
:
:
Iter
<
'
data
pe
:
:
ImageDataDirectory
>
>
{
self
.
entries
.
iter
(
)
.
enumerate
(
)
}
pub
fn
get
(
&
self
index
:
usize
)
-
>
Option
<
&
'
data
pe
:
:
ImageDataDirectory
>
{
self
.
entries
.
get
(
index
)
.
filter
(
|
d
|
d
.
virtual_address
.
get
(
LE
)
!
=
0
)
}
pub
fn
export_directory
<
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
Option
<
&
'
data
pe
:
:
ImageExportDirectory
>
>
{
let
data_dir
=
match
self
.
get
(
pe
:
:
IMAGE_DIRECTORY_ENTRY_EXPORT
)
{
Some
(
data_dir
)
=
>
data_dir
None
=
>
return
Ok
(
None
)
}
;
let
export_data
=
data_dir
.
data
(
data
sections
)
?
;
ExportTable
:
:
parse_directory
(
export_data
)
.
map
(
Some
)
}
pub
fn
export_table
<
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
Option
<
ExportTable
<
'
data
>
>
>
{
let
data_dir
=
match
self
.
get
(
pe
:
:
IMAGE_DIRECTORY_ENTRY_EXPORT
)
{
Some
(
data_dir
)
=
>
data_dir
None
=
>
return
Ok
(
None
)
}
;
let
export_va
=
data_dir
.
virtual_address
.
get
(
LE
)
;
let
export_data
=
data_dir
.
data
(
data
sections
)
?
;
ExportTable
:
:
parse
(
export_data
export_va
)
.
map
(
Some
)
}
pub
fn
import_table
<
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
Option
<
ImportTable
<
'
data
>
>
>
{
let
data_dir
=
match
self
.
get
(
pe
:
:
IMAGE_DIRECTORY_ENTRY_IMPORT
)
{
Some
(
data_dir
)
=
>
data_dir
None
=
>
return
Ok
(
None
)
}
;
let
import_va
=
data_dir
.
virtual_address
.
get
(
LE
)
;
let
(
section_data
section_va
)
=
sections
.
pe_data_containing
(
data
import_va
)
.
read_error
(
"
Invalid
import
data
dir
virtual
address
"
)
?
;
Ok
(
Some
(
ImportTable
:
:
new
(
section_data
section_va
import_va
)
)
)
}
pub
fn
delay_load_import_table
<
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
Option
<
DelayLoadImportTable
<
'
data
>
>
>
{
let
data_dir
=
match
self
.
get
(
pe
:
:
IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT
)
{
Some
(
data_dir
)
=
>
data_dir
None
=
>
return
Ok
(
None
)
}
;
let
import_va
=
data_dir
.
virtual_address
.
get
(
LE
)
;
let
(
section_data
section_va
)
=
sections
.
pe_data_containing
(
data
import_va
)
.
read_error
(
"
Invalid
import
data
dir
virtual
address
"
)
?
;
Ok
(
Some
(
DelayLoadImportTable
:
:
new
(
section_data
section_va
import_va
)
)
)
}
pub
fn
relocation_blocks
<
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
Option
<
RelocationBlockIterator
<
'
data
>
>
>
{
let
data_dir
=
match
self
.
get
(
pe
:
:
IMAGE_DIRECTORY_ENTRY_BASERELOC
)
{
Some
(
data_dir
)
=
>
data_dir
None
=
>
return
Ok
(
None
)
}
;
let
reloc_data
=
data_dir
.
data
(
data
sections
)
?
;
Ok
(
Some
(
RelocationBlockIterator
:
:
new
(
reloc_data
)
)
)
}
pub
fn
resource_directory
<
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
Option
<
ResourceDirectory
<
'
data
>
>
>
{
let
data_dir
=
match
self
.
get
(
pe
:
:
IMAGE_DIRECTORY_ENTRY_RESOURCE
)
{
Some
(
data_dir
)
=
>
data_dir
None
=
>
return
Ok
(
None
)
}
;
let
rsrc_data
=
data_dir
.
data
(
data
sections
)
?
;
Ok
(
Some
(
ResourceDirectory
:
:
new
(
rsrc_data
)
)
)
}
}
impl
pe
:
:
ImageDataDirectory
{
pub
fn
address_range
(
&
self
)
-
>
(
u32
u32
)
{
(
self
.
virtual_address
.
get
(
LE
)
self
.
size
.
get
(
LE
)
)
}
pub
fn
file_range
(
&
self
sections
:
&
SectionTable
<
'
_
>
)
-
>
Result
<
(
u32
u32
)
>
{
let
(
offset
section_size
)
=
sections
.
pe_file_range_at
(
self
.
virtual_address
.
get
(
LE
)
)
.
read_error
(
"
Invalid
data
dir
virtual
address
"
)
?
;
let
size
=
self
.
size
.
get
(
LE
)
;
if
size
>
section_size
{
return
Err
(
Error
(
"
Invalid
data
dir
size
"
)
)
;
}
Ok
(
(
offset
size
)
)
}
pub
fn
data
<
'
data
R
:
ReadRef
<
'
data
>
>
(
&
self
data
:
R
sections
:
&
SectionTable
<
'
data
>
)
-
>
Result
<
&
'
data
[
u8
]
>
{
sections
.
pe_data_at
(
data
self
.
virtual_address
.
get
(
LE
)
)
.
read_error
(
"
Invalid
data
dir
virtual
address
"
)
?
.
get
(
.
.
self
.
size
.
get
(
LE
)
as
usize
)
.
read_error
(
"
Invalid
data
dir
size
"
)
}
}
