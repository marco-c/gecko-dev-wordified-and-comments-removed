#
!
[
allow
(
clippy
:
:
len_without_is_empty
)
]
use
core
:
:
convert
:
:
TryInto
;
use
core
:
:
ops
:
:
Range
;
use
core
:
:
{
mem
result
}
;
use
crate
:
:
pod
:
:
{
from_bytes
slice_from_bytes
Pod
}
;
type
Result
<
T
>
=
result
:
:
Result
<
T
(
)
>
;
pub
trait
ReadRef
<
'
a
>
:
Clone
+
Copy
{
fn
len
(
self
)
-
>
Result
<
u64
>
;
fn
read_bytes_at
(
self
offset
:
u64
size
:
u64
)
-
>
Result
<
&
'
a
[
u8
]
>
;
fn
read_bytes_at_until
(
self
range
:
Range
<
u64
>
delimiter
:
u8
)
-
>
Result
<
&
'
a
[
u8
]
>
;
fn
read_bytes
(
self
offset
:
&
mut
u64
size
:
u64
)
-
>
Result
<
&
'
a
[
u8
]
>
{
let
bytes
=
self
.
read_bytes_at
(
*
offset
size
)
?
;
*
offset
=
offset
.
wrapping_add
(
size
)
;
Ok
(
bytes
)
}
fn
read
<
T
:
Pod
>
(
self
offset
:
&
mut
u64
)
-
>
Result
<
&
'
a
T
>
{
let
size
=
mem
:
:
size_of
:
:
<
T
>
(
)
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
?
;
let
bytes
=
self
.
read_bytes
(
offset
size
)
?
;
let
(
t
_
)
=
from_bytes
(
bytes
)
?
;
Ok
(
t
)
}
fn
read_at
<
T
:
Pod
>
(
self
mut
offset
:
u64
)
-
>
Result
<
&
'
a
T
>
{
self
.
read
(
&
mut
offset
)
}
fn
read_slice
<
T
:
Pod
>
(
self
offset
:
&
mut
u64
count
:
usize
)
-
>
Result
<
&
'
a
[
T
]
>
{
let
size
=
count
.
checked_mul
(
mem
:
:
size_of
:
:
<
T
>
(
)
)
.
ok_or
(
(
)
)
?
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
?
;
let
bytes
=
self
.
read_bytes
(
offset
size
)
?
;
let
(
t
_
)
=
slice_from_bytes
(
bytes
count
)
?
;
Ok
(
t
)
}
fn
read_slice_at
<
T
:
Pod
>
(
self
mut
offset
:
u64
count
:
usize
)
-
>
Result
<
&
'
a
[
T
]
>
{
self
.
read_slice
(
&
mut
offset
count
)
}
}
impl
<
'
a
>
ReadRef
<
'
a
>
for
&
'
a
[
u8
]
{
fn
len
(
self
)
-
>
Result
<
u64
>
{
self
.
len
(
)
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
}
fn
read_bytes_at
(
self
offset
:
u64
size
:
u64
)
-
>
Result
<
&
'
a
[
u8
]
>
{
let
offset
:
usize
=
offset
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
?
;
let
size
:
usize
=
size
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
?
;
self
.
get
(
offset
.
.
)
.
ok_or
(
(
)
)
?
.
get
(
.
.
size
)
.
ok_or
(
(
)
)
}
fn
read_bytes_at_until
(
self
range
:
Range
<
u64
>
delimiter
:
u8
)
-
>
Result
<
&
'
a
[
u8
]
>
{
let
start
:
usize
=
range
.
start
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
?
;
let
end
:
usize
=
range
.
end
.
try_into
(
)
.
map_err
(
|
_
|
(
)
)
?
;
let
bytes
=
self
.
get
(
start
.
.
end
)
.
ok_or
(
(
)
)
?
;
match
memchr
:
:
memchr
(
delimiter
bytes
)
{
Some
(
len
)
=
>
{
bytes
.
get
(
.
.
len
)
.
ok_or
(
(
)
)
}
None
=
>
Err
(
(
)
)
}
}
}
