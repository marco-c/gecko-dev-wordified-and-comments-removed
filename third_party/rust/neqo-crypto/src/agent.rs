#
!
[
expect
(
clippy
:
:
unwrap_used
reason
=
"
Let
'
s
assume
the
use
of
unwrap
was
checked
when
the
use
of
unsafe
was
reviewed
.
"
)
]
use
std
:
:
{
cell
:
:
RefCell
ffi
:
:
{
CStr
CString
}
fmt
:
:
{
self
Debug
Display
Formatter
}
mem
:
:
MaybeUninit
ops
:
:
{
Deref
DerefMut
}
os
:
:
raw
:
:
{
c_uint
c_void
}
pin
:
:
Pin
ptr
:
:
{
null
null_mut
NonNull
}
rc
:
:
Rc
slice
time
:
:
Instant
}
;
use
neqo_common
:
:
{
hex_snip_middle
hex_with_len
qdebug
qtrace
qwarn
}
;
pub
use
crate
:
:
{
agentio
:
:
{
as_c_void
Record
RecordList
}
cert
:
:
CertificateInfo
}
;
use
crate
:
:
{
agentio
:
:
{
AgentIo
METHODS
}
assert_initialized
auth
:
:
AuthenticationStatus
constants
:
:
{
Alert
Cipher
Epoch
Extension
Group
SignatureScheme
Version
TLS_VERSION_1_3
}
ech
err
:
:
{
is_blocked
secstatus_to_res
Error
PRErrorCode
Res
}
ext
:
:
{
ExtensionHandler
ExtensionTracker
SSL_CallExtensionWriterOnEchInner
}
null_safe_slice
p11
:
:
{
self
PrivateKey
PublicKey
}
prio
replay
:
:
AntiReplay
secrets
:
:
SecretHolder
ssl
:
:
{
self
PRBool
}
time
:
:
{
Time
TimeHolder
}
}
;
trait
UnsafeCertCompression
{
extern
"
C
"
fn
decode_callback
(
input
:
*
const
ssl
:
:
SECItem
output
:
*
mut
:
:
std
:
:
os
:
:
raw
:
:
c_uchar
output_len
:
usize
used_len
:
*
mut
usize
)
-
>
ssl
:
:
SECStatus
;
extern
"
C
"
fn
encode_callback
(
input
:
*
const
ssl
:
:
SECItem
output
:
*
mut
ssl
:
:
SECItem
)
-
>
ssl
:
:
SECStatus
;
}
pub
trait
CertificateCompressor
{
const
ID
:
u16
;
const
NAME
:
&
CStr
;
const
ENABLE_ENCODING
:
bool
=
false
;
fn
encode
(
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Res
<
usize
>
{
let
len
=
std
:
:
cmp
:
:
min
(
input
.
len
(
)
output
.
len
(
)
)
;
output
[
.
.
len
]
.
copy_from_slice
(
&
input
[
.
.
len
]
)
;
Ok
(
len
)
}
fn
decode
(
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
Res
<
(
)
>
;
}
impl
<
T
:
CertificateCompressor
>
UnsafeCertCompression
for
T
{
extern
"
C
"
fn
decode_callback
(
input
:
*
const
ssl
:
:
SECItem
output
:
*
mut
:
:
std
:
:
os
:
:
raw
:
:
c_uchar
output_len
:
usize
used_len
:
*
mut
usize
)
-
>
ssl
:
:
SECStatus
{
let
Some
(
input
)
=
NonNull
:
:
new
(
input
.
cast_mut
(
)
)
else
{
return
ssl
:
:
SECFailure
;
}
;
if
unsafe
{
input
.
as_ref
(
)
.
data
.
is_null
(
)
|
|
input
.
as_ref
(
)
.
len
=
=
0
}
{
return
ssl
:
:
SECFailure
;
}
let
input_slice
=
unsafe
{
null_safe_slice
(
input
.
as_ref
(
)
.
data
input
.
as_ref
(
)
.
len
)
}
;
let
output_slice
=
unsafe
{
slice
:
:
from_raw_parts_mut
(
output
output_len
)
}
;
if
T
:
:
decode
(
input_slice
output_slice
)
.
is_err
(
)
{
return
ssl
:
:
SECFailure
;
}
unsafe
{
*
used_len
=
output_len
;
}
ssl
:
:
SECSuccess
}
extern
"
C
"
fn
encode_callback
(
input
:
*
const
ssl
:
:
SECItem
output
:
*
mut
ssl
:
:
SECItem
)
-
>
ssl
:
:
SECStatus
{
let
Some
(
input
)
=
NonNull
:
:
new
(
input
.
cast_mut
(
)
)
else
{
return
ssl
:
:
SECFailure
;
}
;
let
(
input_data
input_len
)
=
unsafe
{
let
input_ref
=
input
.
as_ref
(
)
;
(
input_ref
.
data
input_ref
.
len
)
}
;
if
input_data
.
is_null
(
)
|
|
input_len
=
=
0
{
return
ssl
:
:
SECFailure
;
}
let
input_slice
=
unsafe
{
null_safe_slice
(
input_data
input_len
)
}
;
unsafe
{
p11
:
:
SECITEM_AllocItem
(
null_mut
(
)
output
.
cast
:
:
<
p11
:
:
SECItemStr
>
(
)
input_len
+
1
)
;
}
if
unsafe
{
(
*
output
)
.
data
.
is_null
(
)
}
{
return
ssl
:
:
SECFailure
;
}
let
Ok
(
output_len
)
=
(
unsafe
{
(
*
output
)
.
len
.
try_into
(
)
}
)
else
{
return
ssl
:
:
SECFailure
;
}
;
let
output_slice
=
unsafe
{
slice
:
:
from_raw_parts_mut
(
(
*
output
)
.
data
output_len
)
}
;
let
Ok
(
encoded_len
)
=
T
:
:
encode
(
input_slice
output_slice
)
else
{
return
ssl
:
:
SECFailure
;
}
;
if
encoded_len
=
=
0
|
|
encoded_len
>
output_len
{
return
ssl
:
:
SECFailure
;
}
let
Ok
(
encoded_len
)
=
encoded_len
.
try_into
(
)
else
{
return
ssl
:
:
SECFailure
;
}
;
unsafe
{
(
*
output
)
.
len
=
encoded_len
;
}
ssl
:
:
SECSuccess
}
}
const
MAX_TICKETS
:
usize
=
4
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
HandshakeState
{
New
InProgress
AuthenticationPending
EchFallbackAuthenticationPending
(
String
)
Authenticated
(
PRErrorCode
)
Complete
(
SecretAgentInfo
)
Failed
(
Error
)
}
impl
HandshakeState
{
#
[
must_use
]
pub
const
fn
is_connected
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Complete
(
_
)
)
}
#
[
must_use
]
pub
const
fn
is_final
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Complete
(
_
)
|
Self
:
:
Failed
(
_
)
)
}
#
[
must_use
]
pub
const
fn
authentication_needed
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
AuthenticationPending
|
Self
:
:
EchFallbackAuthenticationPending
(
_
)
)
}
}
fn
get_alpn
(
fd
:
*
mut
ssl
:
:
PRFileDesc
pre
:
bool
)
-
>
Res
<
Option
<
String
>
>
{
let
mut
alpn_state
=
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_NO_SUPPORT
;
let
mut
chosen
=
vec
!
[
0_u8
;
255
]
;
let
mut
chosen_len
:
c_uint
=
0
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_GetNextProto
(
fd
&
mut
alpn_state
chosen
.
as_mut_ptr
(
)
&
mut
chosen_len
c_uint
:
:
try_from
(
chosen
.
len
(
)
)
?
)
}
)
?
;
let
alpn
=
match
(
pre
alpn_state
)
{
(
true
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_EARLY_VALUE
)
|
(
false
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_NEGOTIATED
|
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_SELECTED
)
=
>
{
chosen
.
truncate
(
usize
:
:
try_from
(
chosen_len
)
?
)
;
Some
(
match
String
:
:
from_utf8
(
chosen
)
{
Ok
(
a
)
=
>
a
Err
(
_
)
=
>
return
Err
(
Error
:
:
Internal
)
}
)
}
_
=
>
None
}
;
qtrace
!
(
"
[
{
fd
:
p
}
]
got
ALPN
{
alpn
:
?
}
"
)
;
Ok
(
alpn
)
}
pub
struct
SecretAgentPreInfo
{
info
:
ssl
:
:
SSLPreliminaryChannelInfo
alpn
:
Option
<
String
>
}
macro_rules
!
preinfo_arg
{
(
v
:
ident
m
:
ident
f
:
ident
:
t
:
ty
(
)
?
)
=
>
{
#
[
must_use
]
pub
fn
v
(
&
self
)
-
>
Option
<
t
>
{
match
self
.
info
.
valuesSet
&
ssl
:
:
m
{
0
=
>
None
_
=
>
Some
(
<
t
>
:
:
try_from
(
self
.
info
.
f
)
.
inspect_err
(
|
e
|
qdebug
!
(
"
Invalid
value
in
preinfo
:
{
e
:
?
}
"
)
)
.
ok
(
)
?
)
}
}
}
;
}
impl
SecretAgentPreInfo
{
fn
new
(
fd
:
*
mut
ssl
:
:
PRFileDesc
)
-
>
Res
<
Self
>
{
let
mut
info
:
MaybeUninit
<
ssl
:
:
SSLPreliminaryChannelInfo
>
=
MaybeUninit
:
:
uninit
(
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_GetPreliminaryChannelInfo
(
fd
info
.
as_mut_ptr
(
)
c_uint
:
:
try_from
(
size_of
:
:
<
ssl
:
:
SSLPreliminaryChannelInfo
>
(
)
)
?
)
}
)
?
;
Ok
(
Self
{
info
:
unsafe
{
info
.
assume_init
(
)
}
alpn
:
get_alpn
(
fd
true
)
?
}
)
}
preinfo_arg
!
(
version
ssl_preinfo_version
protocolVersion
:
Version
)
;
preinfo_arg
!
(
cipher_suite
ssl_preinfo_cipher_suite
cipherSuite
:
Cipher
)
;
preinfo_arg
!
(
early_data_cipher
ssl_preinfo_0rtt_cipher_suite
zeroRttCipherSuite
:
Cipher
)
;
#
[
must_use
]
pub
const
fn
early_data
(
&
self
)
-
>
bool
{
self
.
info
.
canSendEarlyData
!
=
0
}
pub
fn
max_early_data
(
&
self
)
-
>
Res
<
usize
>
{
Ok
(
usize
:
:
try_from
(
self
.
info
.
maxEarlyDataSize
)
?
)
}
#
[
must_use
]
pub
const
fn
ech_accepted
(
&
self
)
-
>
Option
<
bool
>
{
if
self
.
info
.
valuesSet
&
ssl
:
:
ssl_preinfo_ech
=
=
0
{
None
}
else
{
Some
(
self
.
info
.
echAccepted
!
=
0
)
}
}
pub
fn
ech_public_name
(
&
self
)
-
>
Res
<
Option
<
&
str
>
>
{
if
self
.
info
.
valuesSet
&
ssl
:
:
ssl_preinfo_ech
=
=
0
|
|
self
.
info
.
echPublicName
.
is_null
(
)
{
Ok
(
None
)
}
else
{
let
n
=
unsafe
{
CStr
:
:
from_ptr
(
self
.
info
.
echPublicName
)
}
;
Ok
(
Some
(
n
.
to_str
(
)
?
)
)
}
}
#
[
must_use
]
pub
const
fn
alpn
(
&
self
)
-
>
Option
<
&
String
>
{
self
.
alpn
.
as_ref
(
)
}
}
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
)
]
pub
struct
SecretAgentInfo
{
version
:
Version
cipher
:
Cipher
group
:
Group
resumed
:
bool
early_data
:
bool
ech_accepted
:
bool
alpn
:
Option
<
String
>
signature_scheme
:
SignatureScheme
}
impl
SecretAgentInfo
{
fn
new
(
fd
:
*
mut
ssl
:
:
PRFileDesc
)
-
>
Res
<
Self
>
{
let
mut
info
:
MaybeUninit
<
ssl
:
:
SSLChannelInfo
>
=
MaybeUninit
:
:
uninit
(
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_GetChannelInfo
(
fd
info
.
as_mut_ptr
(
)
c_uint
:
:
try_from
(
size_of
:
:
<
ssl
:
:
SSLChannelInfo
>
(
)
)
?
)
}
)
?
;
let
info
=
unsafe
{
info
.
assume_init
(
)
}
;
Ok
(
Self
{
version
:
info
.
protocolVersion
cipher
:
info
.
cipherSuite
group
:
Group
:
:
try_from
(
info
.
keaGroup
)
?
resumed
:
info
.
resumed
!
=
0
early_data
:
info
.
earlyDataAccepted
!
=
0
ech_accepted
:
info
.
echAccepted
!
=
0
alpn
:
get_alpn
(
fd
false
)
?
signature_scheme
:
SignatureScheme
:
:
try_from
(
info
.
signatureScheme
)
?
}
)
}
#
[
must_use
]
pub
const
fn
version
(
&
self
)
-
>
Version
{
self
.
version
}
#
[
must_use
]
pub
const
fn
cipher_suite
(
&
self
)
-
>
Cipher
{
self
.
cipher
}
#
[
must_use
]
pub
const
fn
key_exchange
(
&
self
)
-
>
Group
{
self
.
group
}
#
[
must_use
]
pub
const
fn
resumed
(
&
self
)
-
>
bool
{
self
.
resumed
}
#
[
must_use
]
pub
const
fn
early_data_accepted
(
&
self
)
-
>
bool
{
self
.
early_data
}
#
[
must_use
]
pub
const
fn
ech_accepted
(
&
self
)
-
>
bool
{
self
.
ech_accepted
}
#
[
must_use
]
pub
const
fn
alpn
(
&
self
)
-
>
Option
<
&
String
>
{
self
.
alpn
.
as_ref
(
)
}
#
[
must_use
]
pub
const
fn
signature_scheme
(
&
self
)
-
>
SignatureScheme
{
self
.
signature_scheme
}
}
#
[
derive
(
Debug
)
]
#
[
expect
(
clippy
:
:
module_name_repetitions
reason
=
"
This
is
OK
.
"
)
]
pub
struct
SecretAgent
{
fd
:
*
mut
ssl
:
:
PRFileDesc
secrets
:
SecretHolder
raw
:
Option
<
bool
>
io
:
Pin
<
Box
<
AgentIo
>
>
state
:
HandshakeState
auth_required
:
Pin
<
Box
<
bool
>
>
alert
:
Pin
<
Box
<
Option
<
Alert
>
>
>
now
:
TimeHolder
extension_handlers
:
Vec
<
ExtensionTracker
>
ech_config
:
Vec
<
u8
>
}
impl
SecretAgent
{
fn
new
(
)
-
>
Res
<
Self
>
{
let
mut
io
=
Box
:
:
pin
(
AgentIo
:
:
new
(
)
)
;
let
fd
=
Self
:
:
create_fd
(
&
mut
io
)
?
;
Ok
(
Self
{
fd
secrets
:
SecretHolder
:
:
default
(
)
raw
:
None
io
state
:
HandshakeState
:
:
New
auth_required
:
Box
:
:
pin
(
false
)
alert
:
Box
:
:
pin
(
None
)
now
:
TimeHolder
:
:
default
(
)
extension_handlers
:
Vec
:
:
new
(
)
ech_config
:
Vec
:
:
new
(
)
}
)
}
fn
create_fd
(
io
:
&
mut
Pin
<
Box
<
AgentIo
>
>
)
-
>
Res
<
*
mut
ssl
:
:
PRFileDesc
>
{
assert_initialized
(
)
;
let
label
=
CString
:
:
new
(
"
sslwrapper
"
)
?
;
let
id
=
unsafe
{
prio
:
:
PR_GetUniqueIdentity
(
label
.
as_ptr
(
)
)
}
;
let
base_fd
=
unsafe
{
prio
:
:
PR_CreateIOLayerStub
(
id
METHODS
)
}
;
if
base_fd
.
is_null
(
)
{
return
Err
(
Error
:
:
CreateSslSocket
)
;
}
let
fd
=
unsafe
{
(
*
base_fd
)
.
secret
=
as_c_void
(
io
)
.
cast
(
)
;
ssl
:
:
SSL_ImportFD
(
null_mut
(
)
base_fd
.
cast
(
)
)
}
;
if
fd
.
is_null
(
)
{
unsafe
{
prio
:
:
PR_Close
(
base_fd
)
;
}
return
Err
(
Error
:
:
CreateSslSocket
)
;
}
Ok
(
fd
)
}
unsafe
extern
"
C
"
fn
auth_complete_hook
(
arg
:
*
mut
c_void
_fd
:
*
mut
ssl
:
:
PRFileDesc
_check_sig
:
PRBool
_is_server
:
PRBool
)
-
>
ssl
:
:
SECStatus
{
let
auth_required_ptr
=
arg
.
cast
:
:
<
bool
>
(
)
;
*
auth_required_ptr
=
true
;
ssl
:
:
_SECStatus_SECWouldBlock
}
unsafe
extern
"
C
"
fn
alert_sent_cb
(
fd
:
*
const
ssl
:
:
PRFileDesc
arg
:
*
mut
c_void
alert
:
*
const
ssl
:
:
SSLAlert
)
{
let
alert
=
alert
.
as_ref
(
)
.
unwrap
(
)
;
if
alert
.
level
=
=
2
{
let
st
=
arg
.
cast
:
:
<
Option
<
Alert
>
>
(
)
.
as_mut
(
)
.
unwrap
(
)
;
if
st
.
is_none
(
)
{
*
st
=
Some
(
alert
.
description
)
;
}
else
{
qwarn
!
(
"
[
{
fd
:
p
}
]
duplicate
alert
{
}
"
alert
.
description
)
;
}
}
}
fn
ready
(
&
mut
self
is_server
:
bool
grease
:
bool
)
-
>
Res
<
(
)
>
{
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_AuthCertificateHook
(
self
.
fd
Some
(
Self
:
:
auth_complete_hook
)
as_c_void
(
&
mut
self
.
auth_required
)
)
}
)
?
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_AlertSentCallback
(
self
.
fd
Some
(
Self
:
:
alert_sent_cb
)
as_c_void
(
&
mut
self
.
alert
)
)
}
)
?
;
self
.
now
.
bind
(
self
.
fd
)
?
;
self
.
configure
(
grease
)
?
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_ResetHandshake
(
self
.
fd
PRBool
:
:
from
(
is_server
)
)
}
)
}
fn
configure
(
&
mut
self
grease
:
bool
)
-
>
Res
<
(
)
>
{
self
.
set_version_range
(
TLS_VERSION_1_3
TLS_VERSION_1_3
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
Locking
false
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
Tickets
false
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
OcspStapling
true
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
Grease
grease
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
EnableChExtensionPermutation
true
)
?
;
Ok
(
(
)
)
}
pub
fn
set_version_range
(
&
mut
self
min
:
Version
max
:
Version
)
-
>
Res
<
(
)
>
{
let
range
=
ssl
:
:
SSLVersionRange
{
min
max
}
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_VersionRangeSet
(
self
.
fd
&
range
)
}
)
}
pub
fn
set_ciphers
(
&
mut
self
ciphers
:
&
[
Cipher
]
)
-
>
Res
<
(
)
>
{
if
self
.
state
!
=
HandshakeState
:
:
New
{
qwarn
!
(
"
[
{
self
}
]
Cannot
enable
ciphers
in
state
{
:
?
}
"
self
.
state
)
;
return
Err
(
Error
:
:
Internal
)
;
}
let
all_ciphers
=
unsafe
{
ssl
:
:
SSL_GetImplementedCiphers
(
)
}
;
let
cipher_count
=
usize
:
:
from
(
unsafe
{
ssl
:
:
SSL_GetNumImplementedCiphers
(
)
}
)
;
for
i
in
0
.
.
cipher_count
{
let
p
=
all_ciphers
.
wrapping_add
(
i
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_CipherPrefSet
(
self
.
fd
i32
:
:
from
(
*
p
)
PRBool
:
:
from
(
false
)
)
}
)
?
;
}
for
c
in
ciphers
{
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_CipherPrefSet
(
self
.
fd
i32
:
:
from
(
*
c
)
PRBool
:
:
from
(
true
)
)
}
)
?
;
}
Ok
(
(
)
)
}
pub
fn
set_groups
(
&
mut
self
groups
:
&
[
Group
]
)
-
>
Res
<
(
)
>
{
let
group_vec
:
Vec
<
_
>
=
groups
.
iter
(
)
.
map
(
|
&
g
|
ssl
:
:
SSLNamedGroup
:
:
Type
:
:
from
(
g
)
)
.
collect
(
)
;
let
ptr
=
group_vec
.
as_slice
(
)
.
as_ptr
(
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_NamedGroupConfig
(
self
.
fd
ptr
c_uint
:
:
try_from
(
group_vec
.
len
(
)
)
?
)
}
)
}
pub
fn
send_additional_key_shares
(
&
mut
self
count
:
usize
)
-
>
Res
<
(
)
>
{
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_SendAdditionalKeyShares
(
self
.
fd
c_uint
:
:
try_from
(
count
)
?
)
}
)
}
pub
fn
set_option
(
&
self
opt
:
ssl
:
:
Opt
value
:
bool
)
-
>
Res
<
(
)
>
{
opt
.
set
(
self
.
fd
value
)
}
pub
fn
enable_0rtt
(
&
self
)
-
>
Res
<
(
)
>
{
self
.
set_option
(
ssl
:
:
Opt
:
:
EarlyData
true
)
}
pub
fn
disable_end_of_early_data
(
&
self
)
-
>
Res
<
(
)
>
{
self
.
set_option
(
ssl
:
:
Opt
:
:
SuppressEndOfEarlyData
true
)
}
pub
fn
set_alpn
<
A
:
AsRef
<
str
>
>
(
&
mut
self
protocols
:
&
[
A
]
)
-
>
Res
<
(
)
>
{
let
mut
encoded_len
=
protocols
.
len
(
)
;
for
v
in
protocols
{
assert
!
(
v
.
as_ref
(
)
.
len
(
)
<
256
)
;
assert
!
(
!
v
.
as_ref
(
)
.
is_empty
(
)
)
;
encoded_len
+
=
v
.
as_ref
(
)
.
len
(
)
;
}
let
mut
encoded
=
Vec
:
:
with_capacity
(
encoded_len
)
;
let
mut
add
=
|
v
:
&
str
|
{
if
let
Ok
(
s
)
=
u8
:
:
try_from
(
v
.
len
(
)
)
{
encoded
.
push
(
s
)
;
encoded
.
extend_from_slice
(
v
.
as_bytes
(
)
)
;
}
}
;
let
(
first
rest
)
=
protocols
.
split_first
(
)
.
ok_or
(
Error
:
:
Internal
)
?
;
for
v
in
rest
{
add
(
v
.
as_ref
(
)
)
;
}
add
(
first
.
as_ref
(
)
)
;
assert_eq
!
(
encoded_len
encoded
.
len
(
)
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_SetNextProtoNego
(
self
.
fd
encoded
.
as_slice
(
)
.
as_ptr
(
)
c_uint
:
:
try_from
(
encoded
.
len
(
)
)
?
)
}
)
}
pub
fn
set_certificate_compression
<
T
:
CertificateCompressor
>
(
&
mut
self
)
-
>
Res
<
(
)
>
{
if
T
:
:
ID
=
=
0
{
return
Err
(
Error
:
:
InvalidCertificateCompressionID
)
;
}
let
compressor
:
ssl
:
:
SSLCertificateCompressionAlgorithm
=
ssl
:
:
SSLCertificateCompressionAlgorithm
{
id
:
T
:
:
ID
name
:
T
:
:
NAME
.
as_ptr
(
)
encode
:
T
:
:
ENABLE_ENCODING
.
then_some
(
<
T
as
UnsafeCertCompression
>
:
:
encode_callback
)
decode
:
Some
(
<
T
as
UnsafeCertCompression
>
:
:
decode_callback
)
}
;
unsafe
{
ssl
:
:
SSL_SetCertificateCompressionAlgorithm
(
self
.
fd
compressor
)
}
}
pub
fn
extension_handler
(
&
mut
self
ext
:
Extension
handler
:
Rc
<
RefCell
<
dyn
ExtensionHandler
>
>
)
-
>
Res
<
(
)
>
{
let
tracker
=
unsafe
{
ExtensionTracker
:
:
new
(
self
.
fd
ext
handler
)
?
}
;
self
.
extension_handlers
.
push
(
tracker
)
;
Ok
(
(
)
)
}
fn
set_raw
(
&
mut
self
r
:
bool
)
-
>
Res
<
(
)
>
{
if
let
Some
(
raw
)
=
self
.
raw
{
if
raw
=
=
r
{
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
MixedHandshakeMethod
)
}
}
else
{
self
.
secrets
.
register
(
self
.
fd
)
?
;
self
.
raw
=
Some
(
r
)
;
Ok
(
(
)
)
}
}
#
[
must_use
]
pub
const
fn
info
(
&
self
)
-
>
Option
<
&
SecretAgentInfo
>
{
match
&
self
.
state
{
HandshakeState
:
:
Complete
(
info
)
=
>
Some
(
info
)
_
=
>
None
}
}
pub
fn
preinfo
(
&
self
)
-
>
Res
<
SecretAgentPreInfo
>
{
SecretAgentPreInfo
:
:
new
(
self
.
fd
)
}
#
[
must_use
]
pub
fn
peer_certificate
(
&
self
)
-
>
Option
<
CertificateInfo
>
{
CertificateInfo
:
:
new
(
self
.
fd
)
}
#
[
must_use
]
pub
fn
alert
(
&
self
)
-
>
Option
<
Alert
>
{
*
self
.
alert
}
pub
fn
authenticated
(
&
mut
self
status
:
AuthenticationStatus
)
{
assert
!
(
self
.
state
.
authentication_needed
(
)
)
;
*
self
.
auth_required
=
false
;
self
.
state
=
HandshakeState
:
:
Authenticated
(
status
.
into
(
)
)
;
}
fn
capture_error
<
T
>
(
&
mut
self
res
:
Res
<
T
>
)
-
>
Res
<
T
>
{
if
let
Err
(
e
)
=
res
{
let
e
=
ech
:
:
convert_ech_error
(
self
.
fd
e
)
;
qwarn
!
(
"
[
{
self
}
]
error
:
{
e
:
?
}
"
)
;
self
.
state
=
HandshakeState
:
:
Failed
(
e
.
clone
(
)
)
;
Err
(
e
)
}
else
{
res
}
}
fn
update_state
(
&
mut
self
res
:
Res
<
(
)
>
)
-
>
Res
<
(
)
>
{
self
.
state
=
if
is_blocked
(
&
res
)
{
if
*
self
.
auth_required
{
self
.
preinfo
(
)
?
.
ech_public_name
(
)
?
.
map_or
(
HandshakeState
:
:
AuthenticationPending
|
public_name
|
{
HandshakeState
:
:
EchFallbackAuthenticationPending
(
public_name
.
to_owned
(
)
)
}
)
}
else
{
HandshakeState
:
:
InProgress
}
}
else
{
self
.
capture_error
(
res
)
?
;
let
info
=
self
.
capture_error
(
SecretAgentInfo
:
:
new
(
self
.
fd
)
)
?
;
HandshakeState
:
:
Complete
(
info
)
}
;
qdebug
!
(
"
[
{
self
}
]
state
-
>
{
:
?
}
"
self
.
state
)
;
Ok
(
(
)
)
}
pub
fn
handshake
(
&
mut
self
now
:
Instant
input
:
&
[
u8
]
)
-
>
Res
<
Vec
<
u8
>
>
{
self
.
now
.
set
(
now
)
?
;
self
.
set_raw
(
false
)
?
;
let
rv
=
{
let
_h
=
self
.
io
.
wrap
(
input
)
;
match
self
.
state
{
HandshakeState
:
:
Authenticated
(
err
)
=
>
unsafe
{
ssl
:
:
SSL_AuthCertificateComplete
(
self
.
fd
err
)
}
_
=
>
unsafe
{
ssl
:
:
SSL_ForceHandshake
(
self
.
fd
)
}
}
}
;
let
output
=
self
.
io
.
take_output
(
)
;
self
.
update_state
(
secstatus_to_res
(
rv
)
)
?
;
Ok
(
output
)
}
fn
setup_raw
(
&
mut
self
)
-
>
Res
<
Pin
<
Box
<
RecordList
>
>
>
{
self
.
set_raw
(
true
)
?
;
self
.
capture_error
(
RecordList
:
:
setup
(
self
.
fd
)
)
}
pub
fn
handshake_raw
(
&
mut
self
now
:
Instant
input
:
Option
<
Record
>
)
-
>
Res
<
RecordList
>
{
self
.
now
.
set
(
now
)
?
;
let
records
=
self
.
setup_raw
(
)
?
;
if
let
HandshakeState
:
:
Authenticated
(
err
)
=
self
.
state
{
let
result
=
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_AuthCertificateComplete
(
self
.
fd
err
)
}
)
;
qdebug
!
(
"
[
{
self
}
]
SSL_AuthCertificateComplete
:
{
result
:
?
}
"
)
;
self
.
capture_error
(
result
)
?
;
}
if
let
Some
(
rec
)
=
input
{
self
.
capture_error
(
rec
.
write
(
self
.
fd
)
)
?
;
}
let
rv
=
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_ForceHandshake
(
self
.
fd
)
}
)
;
self
.
update_state
(
rv
)
?
;
Ok
(
*
Pin
:
:
into_inner
(
records
)
)
}
pub
fn
close
(
&
mut
self
)
{
if
self
.
fd
.
is_null
(
)
{
return
;
}
#
[
expect
(
clippy
:
:
branches_sharing_code
reason
=
"
The
PR_Close
calls
cannot
be
run
after
dropping
the
returned
values
.
"
)
]
if
self
.
raw
=
=
Some
(
true
)
{
let
_records
=
self
.
setup_raw
(
)
.
expect
(
"
Can
only
close
"
)
;
unsafe
{
prio
:
:
PR_Close
(
self
.
fd
.
cast
(
)
)
;
}
}
else
{
let
_io
=
self
.
io
.
wrap
(
&
[
]
)
;
unsafe
{
prio
:
:
PR_Close
(
self
.
fd
.
cast
(
)
)
;
}
}
let
_output
=
self
.
io
.
take_output
(
)
;
self
.
fd
=
null_mut
(
)
;
}
#
[
must_use
]
pub
const
fn
state
(
&
self
)
-
>
&
HandshakeState
{
&
self
.
state
}
#
[
must_use
]
pub
fn
read_secret
(
&
mut
self
epoch
:
Epoch
)
-
>
Option
<
p11
:
:
SymKey
>
{
self
.
secrets
.
take_read
(
epoch
)
}
#
[
must_use
]
pub
fn
write_secret
(
&
mut
self
epoch
:
Epoch
)
-
>
Option
<
p11
:
:
SymKey
>
{
self
.
secrets
.
take_write
(
epoch
)
}
#
[
must_use
]
pub
fn
ech_config
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
ech_config
}
}
impl
Drop
for
SecretAgent
{
fn
drop
(
&
mut
self
)
{
self
.
close
(
)
;
}
}
impl
Display
for
SecretAgent
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Agent
{
:
p
}
"
self
.
fd
)
}
}
#
[
derive
(
Debug
PartialOrd
Ord
PartialEq
Eq
Clone
)
]
pub
struct
ResumptionToken
{
token
:
Vec
<
u8
>
expiration_time
:
Instant
}
impl
AsRef
<
[
u8
]
>
for
ResumptionToken
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
token
}
}
impl
ResumptionToken
{
#
[
must_use
]
pub
const
fn
new
(
token
:
Vec
<
u8
>
expiration_time
:
Instant
)
-
>
Self
{
Self
{
token
expiration_time
}
}
#
[
must_use
]
pub
const
fn
expiration_time
(
&
self
)
-
>
Instant
{
self
.
expiration_time
}
}
#
[
derive
(
Debug
)
]
pub
struct
Client
{
agent
:
SecretAgent
server_name
:
String
#
[
expect
(
clippy
:
:
box_collection
reason
=
"
We
need
the
Box
.
"
)
]
resumption
:
Pin
<
Box
<
Vec
<
ResumptionToken
>
>
>
}
impl
Client
{
pub
fn
new
<
I
:
Into
<
String
>
>
(
server_name
:
I
grease
:
bool
)
-
>
Res
<
Self
>
{
let
server_name
=
server_name
.
into
(
)
;
let
mut
agent
=
SecretAgent
:
:
new
(
)
?
;
let
url
=
CString
:
:
new
(
server_name
.
as_bytes
(
)
)
?
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_SetURL
(
agent
.
fd
url
.
as_ptr
(
)
)
}
)
?
;
agent
.
ready
(
false
grease
)
?
;
let
mut
client
=
Self
{
agent
server_name
resumption
:
Box
:
:
pin
(
Vec
:
:
new
(
)
)
}
;
client
.
ready
(
)
?
;
Ok
(
client
)
}
unsafe
extern
"
C
"
fn
resumption_token_cb
(
fd
:
*
mut
ssl
:
:
PRFileDesc
token
:
*
const
u8
len
:
c_uint
arg
:
*
mut
c_void
)
-
>
ssl
:
:
SECStatus
{
let
mut
info
:
MaybeUninit
<
ssl
:
:
SSLResumptionTokenInfo
>
=
MaybeUninit
:
:
uninit
(
)
;
let
Ok
(
info_len
)
=
c_uint
:
:
try_from
(
size_of
:
:
<
ssl
:
:
SSLResumptionTokenInfo
>
(
)
)
else
{
return
ssl
:
:
SECFailure
;
}
;
let
info_res
=
&
ssl
:
:
SSL_GetResumptionTokenInfo
(
token
len
info
.
as_mut_ptr
(
)
info_len
)
;
if
info_res
.
is_err
(
)
{
return
ssl
:
:
SECSuccess
;
}
let
expiration_time
=
info
.
assume_init
(
)
.
expirationTime
;
if
ssl
:
:
SSL_DestroyResumptionTokenInfo
(
info
.
as_mut_ptr
(
)
)
.
is_err
(
)
{
return
ssl
:
:
SECSuccess
;
}
let
Some
(
resumption
)
=
arg
.
cast
:
:
<
Vec
<
ResumptionToken
>
>
(
)
.
as_mut
(
)
else
{
return
ssl
:
:
SECFailure
;
}
;
let
Ok
(
len
)
=
usize
:
:
try_from
(
len
)
else
{
return
ssl
:
:
SECFailure
;
}
;
let
mut
v
=
Vec
:
:
with_capacity
(
len
)
;
v
.
extend_from_slice
(
null_safe_slice
(
token
len
)
)
;
qdebug
!
(
"
[
{
fd
:
p
}
]
Got
resumption
token
{
}
"
hex_snip_middle
(
&
v
)
)
;
if
resumption
.
len
(
)
>
=
MAX_TICKETS
{
resumption
.
remove
(
0
)
;
}
if
let
Ok
(
t
)
=
Time
:
:
try_from
(
expiration_time
)
{
resumption
.
push
(
ResumptionToken
:
:
new
(
v
*
t
)
)
;
}
ssl
:
:
SECSuccess
}
#
[
must_use
]
pub
fn
server_name
(
&
self
)
-
>
&
str
{
&
self
.
server_name
}
fn
ready
(
&
mut
self
)
-
>
Res
<
(
)
>
{
let
fd
=
self
.
fd
;
unsafe
{
ssl
:
:
SSL_SetResumptionTokenCallback
(
fd
Some
(
Self
:
:
resumption_token_cb
)
as_c_void
(
&
mut
self
.
resumption
)
)
}
}
#
[
must_use
]
pub
fn
resumption_token
(
&
mut
self
)
-
>
Option
<
ResumptionToken
>
{
(
*
self
.
resumption
)
.
pop
(
)
}
#
[
must_use
]
pub
fn
has_resumption_token
(
&
self
)
-
>
bool
{
!
(
*
self
.
resumption
)
.
is_empty
(
)
}
pub
fn
enable_resumption
<
A
:
AsRef
<
[
u8
]
>
>
(
&
mut
self
token
:
A
)
-
>
Res
<
(
)
>
{
unsafe
{
ssl
:
:
SSL_SetResumptionToken
(
self
.
agent
.
fd
token
.
as_ref
(
)
.
as_ptr
(
)
c_uint
:
:
try_from
(
token
.
as_ref
(
)
.
len
(
)
)
?
)
}
}
pub
fn
enable_ech
<
A
:
AsRef
<
[
u8
]
>
>
(
&
mut
self
ech_config_list
:
A
)
-
>
Res
<
(
)
>
{
let
config
=
ech_config_list
.
as_ref
(
)
;
qdebug
!
(
"
[
{
self
}
]
Enable
ECH
for
a
server
:
{
}
"
hex_with_len
(
config
)
)
;
self
.
ech_config
=
Vec
:
:
from
(
config
)
;
if
config
.
is_empty
(
)
{
unsafe
{
ech
:
:
SSL_EnableTls13GreaseEch
(
self
.
agent
.
fd
PRBool
:
:
from
(
true
)
)
}
}
else
{
unsafe
{
ech
:
:
SSL_SetClientEchConfigs
(
self
.
agent
.
fd
config
.
as_ptr
(
)
c_uint
:
:
try_from
(
config
.
len
(
)
)
?
)
?
;
SSL_CallExtensionWriterOnEchInner
(
self
.
fd
PRBool
:
:
from
(
true
)
)
}
}
}
}
impl
Deref
for
Client
{
type
Target
=
SecretAgent
;
fn
deref
(
&
self
)
-
>
&
SecretAgent
{
&
self
.
agent
}
}
impl
DerefMut
for
Client
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
SecretAgent
{
&
mut
self
.
agent
}
}
impl
Display
for
Client
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Client
{
:
p
}
"
self
.
agent
.
fd
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
enum
ZeroRttCheckResult
{
Accept
Reject
HelloRetryRequest
(
Vec
<
u8
>
)
Fail
}
pub
trait
ZeroRttChecker
:
Debug
+
Unpin
{
fn
check
(
&
self
token
:
&
[
u8
]
)
-
>
ZeroRttCheckResult
;
}
#
[
derive
(
Debug
)
]
pub
struct
AllowZeroRtt
{
}
impl
ZeroRttChecker
for
AllowZeroRtt
{
fn
check
(
&
self
_token
:
&
[
u8
]
)
-
>
ZeroRttCheckResult
{
qwarn
!
(
"
AllowZeroRtt
accepting
0
-
RTT
"
)
;
ZeroRttCheckResult
:
:
Accept
}
}
#
[
derive
(
Debug
)
]
struct
ZeroRttCheckState
{
checker
:
Pin
<
Box
<
dyn
ZeroRttChecker
>
>
}
impl
ZeroRttCheckState
{
pub
fn
new
(
checker
:
Box
<
dyn
ZeroRttChecker
>
)
-
>
Self
{
Self
{
checker
:
Pin
:
:
new
(
checker
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Server
{
agent
:
SecretAgent
zero_rtt_check
:
Option
<
Pin
<
Box
<
ZeroRttCheckState
>
>
>
}
impl
Server
{
pub
fn
new
<
A
:
AsRef
<
str
>
>
(
certificates
:
&
[
A
]
)
-
>
Res
<
Self
>
{
let
mut
agent
=
SecretAgent
:
:
new
(
)
?
;
for
n
in
certificates
{
let
c
=
CString
:
:
new
(
n
.
as_ref
(
)
)
?
;
let
cert_ptr
=
unsafe
{
p11
:
:
PK11_FindCertFromNickname
(
c
.
as_ptr
(
)
null_mut
(
)
)
}
;
let
Ok
(
cert
)
=
p11
:
:
Certificate
:
:
from_ptr
(
cert_ptr
)
else
{
return
Err
(
Error
:
:
CertificateLoading
)
;
}
;
let
key_ptr
=
unsafe
{
p11
:
:
PK11_FindKeyByAnyCert
(
*
cert
null_mut
(
)
)
}
;
let
Ok
(
key
)
=
PrivateKey
:
:
from_ptr
(
key_ptr
)
else
{
return
Err
(
Error
:
:
CertificateLoading
)
;
}
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_ConfigServerCert
(
agent
.
fd
*
cert
*
key
null
(
)
0
)
}
)
?
;
}
agent
.
ready
(
true
true
)
?
;
Ok
(
Self
{
agent
zero_rtt_check
:
None
}
)
}
unsafe
extern
"
C
"
fn
hello_retry_cb
(
first_hello
:
PRBool
client_token
:
*
const
u8
client_token_len
:
c_uint
retry_token
:
*
mut
u8
retry_token_len
:
*
mut
c_uint
retry_token_max
:
c_uint
arg
:
*
mut
c_void
)
-
>
ssl
:
:
SSLHelloRetryRequestAction
:
:
Type
{
if
first_hello
=
=
0
{
return
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_accept
;
}
let
check_state
=
arg
.
cast
:
:
<
ZeroRttCheckState
>
(
)
.
as_mut
(
)
.
unwrap
(
)
;
let
token
=
null_safe_slice
(
client_token
usize
:
:
try_from
(
client_token_len
)
.
unwrap
(
)
)
;
match
check_state
.
checker
.
check
(
token
)
{
ZeroRttCheckResult
:
:
Accept
=
>
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_accept
ZeroRttCheckResult
:
:
Fail
=
>
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_fail
ZeroRttCheckResult
:
:
Reject
=
>
{
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_reject_0rtt
}
ZeroRttCheckResult
:
:
HelloRetryRequest
(
tok
)
=
>
{
assert
!
(
tok
.
len
(
)
<
=
usize
:
:
try_from
(
retry_token_max
)
.
unwrap
(
)
)
;
let
slc
=
slice
:
:
from_raw_parts_mut
(
retry_token
tok
.
len
(
)
)
;
slc
.
copy_from_slice
(
&
tok
)
;
*
retry_token_len
=
c_uint
:
:
try_from
(
tok
.
len
(
)
)
.
unwrap
(
)
;
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_request
}
}
}
pub
fn
enable_0rtt
(
&
mut
self
anti_replay
:
&
AntiReplay
max_early_data
:
u32
checker
:
Box
<
dyn
ZeroRttChecker
>
)
-
>
Res
<
(
)
>
{
let
mut
check_state
=
Box
:
:
pin
(
ZeroRttCheckState
:
:
new
(
checker
)
)
;
unsafe
{
ssl
:
:
SSL_HelloRetryRequestCallback
(
self
.
agent
.
fd
Some
(
Self
:
:
hello_retry_cb
)
as_c_void
(
&
mut
check_state
)
)
}
?
;
unsafe
{
ssl
:
:
SSL_SetMaxEarlyDataSize
(
self
.
agent
.
fd
max_early_data
)
}
?
;
self
.
zero_rtt_check
=
Some
(
check_state
)
;
self
.
agent
.
enable_0rtt
(
)
?
;
anti_replay
.
config_socket
(
self
.
fd
)
?
;
Ok
(
(
)
)
}
pub
fn
send_ticket
(
&
mut
self
now
:
Instant
extra
:
&
[
u8
]
)
-
>
Res
<
RecordList
>
{
self
.
agent
.
now
.
set
(
now
)
?
;
let
records
=
self
.
setup_raw
(
)
?
;
unsafe
{
ssl
:
:
SSL_SendSessionTicket
(
self
.
fd
extra
.
as_ptr
(
)
c_uint
:
:
try_from
(
extra
.
len
(
)
)
?
)
}
?
;
Ok
(
*
Pin
:
:
into_inner
(
records
)
)
}
pub
fn
enable_ech
(
&
mut
self
config
:
u8
public_name
:
&
str
sk
:
&
PrivateKey
pk
:
&
PublicKey
)
-
>
Res
<
(
)
>
{
let
cfg
=
ech
:
:
encode_config
(
config
public_name
pk
)
?
;
qdebug
!
(
"
[
{
self
}
]
Enable
ECH
for
a
server
:
{
}
"
hex_with_len
(
&
cfg
)
)
;
unsafe
{
ech
:
:
SSL_SetServerEchConfigs
(
self
.
agent
.
fd
*
*
pk
*
*
sk
cfg
.
as_ptr
(
)
c_uint
:
:
try_from
(
cfg
.
len
(
)
)
?
)
?
;
}
;
self
.
ech_config
=
cfg
;
Ok
(
(
)
)
}
}
impl
Deref
for
Server
{
type
Target
=
SecretAgent
;
fn
deref
(
&
self
)
-
>
&
SecretAgent
{
&
self
.
agent
}
}
impl
DerefMut
for
Server
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
SecretAgent
{
&
mut
self
.
agent
}
}
impl
Display
for
Server
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Server
{
:
p
}
"
self
.
agent
.
fd
)
}
}
#
[
derive
(
Debug
)
]
pub
enum
Agent
{
Client
(
Client
)
Server
(
Server
)
}
impl
Deref
for
Agent
{
type
Target
=
SecretAgent
;
fn
deref
(
&
self
)
-
>
&
SecretAgent
{
match
self
{
Self
:
:
Client
(
c
)
=
>
c
Self
:
:
Server
(
s
)
=
>
s
}
}
}
impl
DerefMut
for
Agent
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
SecretAgent
{
match
self
{
Self
:
:
Client
(
c
)
=
>
c
Self
:
:
Server
(
s
)
=
>
s
}
}
}
impl
From
<
Client
>
for
Agent
{
fn
from
(
c
:
Client
)
-
>
Self
{
Self
:
:
Client
(
c
)
}
}
impl
From
<
Server
>
for
Agent
{
fn
from
(
s
:
Server
)
-
>
Self
{
Self
:
:
Server
(
s
)
}
}
