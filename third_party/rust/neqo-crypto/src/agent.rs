pub
use
crate
:
:
agentio
:
:
{
as_c_void
Record
RecordList
}
;
use
crate
:
:
agentio
:
:
{
AgentIo
METHODS
}
;
use
crate
:
:
assert_initialized
;
use
crate
:
:
auth
:
:
AuthenticationStatus
;
pub
use
crate
:
:
cert
:
:
CertificateInfo
;
use
crate
:
:
constants
:
:
{
Alert
Cipher
Epoch
Extension
Group
SignatureScheme
Version
TLS_VERSION_1_3
}
;
use
crate
:
:
err
:
:
{
is_blocked
secstatus_to_res
Error
PRErrorCode
Res
}
;
use
crate
:
:
ext
:
:
{
ExtensionHandler
ExtensionTracker
}
;
use
crate
:
:
p11
;
use
crate
:
:
prio
;
use
crate
:
:
replay
:
:
AntiReplay
;
use
crate
:
:
secrets
:
:
SecretHolder
;
use
crate
:
:
ssl
:
:
{
self
PRBool
}
;
use
crate
:
:
time
:
:
{
Time
TimeHolder
}
;
use
neqo_common
:
:
{
hex_snip_middle
qdebug
qinfo
qtrace
qwarn
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
mem
:
:
{
self
MaybeUninit
}
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
os
:
:
raw
:
:
{
c_uint
c_void
}
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
ptr
:
:
{
null
null_mut
NonNull
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
time
:
:
Instant
;
const
MAX_TICKETS
:
usize
=
4
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
HandshakeState
{
New
InProgress
AuthenticationPending
Authenticated
(
PRErrorCode
)
Complete
(
SecretAgentInfo
)
Failed
(
Error
)
}
impl
HandshakeState
{
#
[
must_use
]
pub
fn
is_connected
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Complete
(
_
)
)
}
#
[
must_use
]
pub
fn
is_final
(
&
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
Complete
(
_
)
|
Self
:
:
Failed
(
_
)
)
}
}
fn
get_alpn
(
fd
:
*
mut
ssl
:
:
PRFileDesc
pre
:
bool
)
-
>
Res
<
Option
<
String
>
>
{
let
mut
alpn_state
=
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_NO_SUPPORT
;
let
mut
chosen
=
vec
!
[
0_u8
;
255
]
;
let
mut
chosen_len
:
c_uint
=
0
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_GetNextProto
(
fd
&
mut
alpn_state
chosen
.
as_mut_ptr
(
)
&
mut
chosen_len
c_uint
:
:
try_from
(
chosen
.
len
(
)
)
?
)
}
)
?
;
let
alpn
=
match
(
pre
alpn_state
)
{
(
true
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_EARLY_VALUE
)
|
(
false
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_NEGOTIATED
)
|
(
false
ssl
:
:
SSLNextProtoState
:
:
SSL_NEXT_PROTO_SELECTED
)
=
>
{
chosen
.
truncate
(
usize
:
:
try_from
(
chosen_len
)
?
)
;
Some
(
match
String
:
:
from_utf8
(
chosen
)
{
Ok
(
a
)
=
>
a
Err
(
_
)
=
>
return
Err
(
Error
:
:
InternalError
)
}
)
}
_
=
>
None
}
;
qtrace
!
(
[
format
!
(
"
{
:
p
}
"
fd
)
]
"
got
ALPN
{
:
?
}
"
alpn
)
;
Ok
(
alpn
)
}
pub
struct
SecretAgentPreInfo
{
info
:
ssl
:
:
SSLPreliminaryChannelInfo
alpn
:
Option
<
String
>
}
macro_rules
!
preinfo_arg
{
(
v
:
ident
m
:
ident
f
:
ident
:
t
:
ident
(
)
?
)
=
>
{
#
[
must_use
]
pub
fn
v
(
&
self
)
-
>
Option
<
t
>
{
match
self
.
info
.
valuesSet
&
ssl
:
:
m
{
0
=
>
None
_
=
>
Some
(
t
:
:
from
(
self
.
info
.
f
)
)
}
}
}
;
}
impl
SecretAgentPreInfo
{
fn
new
(
fd
:
*
mut
ssl
:
:
PRFileDesc
)
-
>
Res
<
Self
>
{
let
mut
info
:
MaybeUninit
<
ssl
:
:
SSLPreliminaryChannelInfo
>
=
MaybeUninit
:
:
uninit
(
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_GetPreliminaryChannelInfo
(
fd
info
.
as_mut_ptr
(
)
c_uint
:
:
try_from
(
mem
:
:
size_of
:
:
<
ssl
:
:
SSLPreliminaryChannelInfo
>
(
)
)
?
)
}
)
?
;
Ok
(
Self
{
info
:
unsafe
{
info
.
assume_init
(
)
}
alpn
:
get_alpn
(
fd
true
)
?
}
)
}
preinfo_arg
!
(
version
ssl_preinfo_version
protocolVersion
:
Version
)
;
preinfo_arg
!
(
cipher_suite
ssl_preinfo_cipher_suite
cipherSuite
:
Cipher
)
;
#
[
must_use
]
pub
fn
early_data
(
&
self
)
-
>
bool
{
self
.
info
.
canSendEarlyData
!
=
0
}
#
[
must_use
]
pub
fn
max_early_data
(
&
self
)
-
>
usize
{
usize
:
:
try_from
(
self
.
info
.
maxEarlyDataSize
)
.
unwrap
(
)
}
#
[
must_use
]
pub
fn
alpn
(
&
self
)
-
>
Option
<
&
String
>
{
self
.
alpn
.
as_ref
(
)
}
preinfo_arg
!
(
early_data_cipher
ssl_preinfo_0rtt_cipher_suite
zeroRttCipherSuite
:
Cipher
)
;
}
#
[
derive
(
Clone
Debug
Default
PartialEq
)
]
pub
struct
SecretAgentInfo
{
version
:
Version
cipher
:
Cipher
group
:
Group
resumed
:
bool
early_data
:
bool
alpn
:
Option
<
String
>
signature_scheme
:
SignatureScheme
}
impl
SecretAgentInfo
{
fn
new
(
fd
:
*
mut
ssl
:
:
PRFileDesc
)
-
>
Res
<
Self
>
{
let
mut
info
:
MaybeUninit
<
ssl
:
:
SSLChannelInfo
>
=
MaybeUninit
:
:
uninit
(
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_GetChannelInfo
(
fd
info
.
as_mut_ptr
(
)
c_uint
:
:
try_from
(
mem
:
:
size_of
:
:
<
ssl
:
:
SSLChannelInfo
>
(
)
)
?
)
}
)
?
;
let
info
=
unsafe
{
info
.
assume_init
(
)
}
;
Ok
(
Self
{
version
:
info
.
protocolVersion
cipher
:
info
.
cipherSuite
group
:
Group
:
:
try_from
(
info
.
keaGroup
)
?
resumed
:
info
.
resumed
!
=
0
early_data
:
info
.
earlyDataAccepted
!
=
0
alpn
:
get_alpn
(
fd
false
)
?
signature_scheme
:
SignatureScheme
:
:
try_from
(
info
.
signatureScheme
)
?
}
)
}
#
[
must_use
]
pub
fn
version
(
&
self
)
-
>
Version
{
self
.
version
}
#
[
must_use
]
pub
fn
cipher_suite
(
&
self
)
-
>
Cipher
{
self
.
cipher
}
#
[
must_use
]
pub
fn
key_exchange
(
&
self
)
-
>
Group
{
self
.
group
}
#
[
must_use
]
pub
fn
resumed
(
&
self
)
-
>
bool
{
self
.
resumed
}
#
[
must_use
]
pub
fn
early_data_accepted
(
&
self
)
-
>
bool
{
self
.
early_data
}
#
[
must_use
]
pub
fn
alpn
(
&
self
)
-
>
Option
<
&
String
>
{
self
.
alpn
.
as_ref
(
)
}
#
[
must_use
]
pub
fn
signature_scheme
(
&
self
)
-
>
SignatureScheme
{
self
.
signature_scheme
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
clippy
:
:
module_name_repetitions
)
]
pub
struct
SecretAgent
{
fd
:
*
mut
ssl
:
:
PRFileDesc
secrets
:
SecretHolder
raw
:
Option
<
bool
>
io
:
Pin
<
Box
<
AgentIo
>
>
state
:
HandshakeState
auth_required
:
Pin
<
Box
<
bool
>
>
alert
:
Pin
<
Box
<
Option
<
Alert
>
>
>
now
:
TimeHolder
extension_handlers
:
Vec
<
ExtensionTracker
>
inf
:
Option
<
SecretAgentInfo
>
}
impl
SecretAgent
{
fn
new
(
)
-
>
Res
<
Self
>
{
let
mut
io
=
Box
:
:
pin
(
AgentIo
:
:
new
(
)
)
;
let
fd
=
Self
:
:
create_fd
(
&
mut
io
)
?
;
Ok
(
Self
{
fd
secrets
:
SecretHolder
:
:
default
(
)
raw
:
None
io
state
:
HandshakeState
:
:
New
auth_required
:
Box
:
:
pin
(
false
)
alert
:
Box
:
:
pin
(
None
)
now
:
TimeHolder
:
:
default
(
)
extension_handlers
:
Vec
:
:
new
(
)
inf
:
None
}
)
}
fn
create_fd
(
io
:
&
mut
Pin
<
Box
<
AgentIo
>
>
)
-
>
Res
<
*
mut
ssl
:
:
PRFileDesc
>
{
assert_initialized
(
)
;
let
label
=
CString
:
:
new
(
"
sslwrapper
"
)
?
;
let
id
=
unsafe
{
prio
:
:
PR_GetUniqueIdentity
(
label
.
as_ptr
(
)
)
}
;
let
base_fd
=
unsafe
{
prio
:
:
PR_CreateIOLayerStub
(
id
METHODS
)
}
;
if
base_fd
.
is_null
(
)
{
return
Err
(
Error
:
:
CreateSslSocket
)
;
}
let
fd
=
unsafe
{
(
*
base_fd
)
.
secret
=
as_c_void
(
io
)
as
*
mut
_
;
ssl
:
:
SSL_ImportFD
(
null_mut
(
)
base_fd
as
*
mut
ssl
:
:
PRFileDesc
)
}
;
if
fd
.
is_null
(
)
{
unsafe
{
prio
:
:
PR_Close
(
base_fd
)
}
;
return
Err
(
Error
:
:
CreateSslSocket
)
;
}
Ok
(
fd
)
}
unsafe
extern
"
C
"
fn
auth_complete_hook
(
arg
:
*
mut
c_void
_fd
:
*
mut
ssl
:
:
PRFileDesc
_check_sig
:
ssl
:
:
PRBool
_is_server
:
ssl
:
:
PRBool
)
-
>
ssl
:
:
SECStatus
{
let
auth_required_ptr
=
arg
as
*
mut
bool
;
*
auth_required_ptr
=
true
;
ssl
:
:
_SECStatus_SECWouldBlock
}
unsafe
extern
"
C
"
fn
alert_sent_cb
(
fd
:
*
const
ssl
:
:
PRFileDesc
arg
:
*
mut
c_void
alert
:
*
const
ssl
:
:
SSLAlert
)
{
let
alert
=
alert
.
as_ref
(
)
.
unwrap
(
)
;
if
alert
.
level
=
=
2
{
let
p
=
arg
as
*
mut
Option
<
Alert
>
;
let
st
=
p
.
as_mut
(
)
.
unwrap
(
)
;
if
st
.
is_none
(
)
{
*
st
=
Some
(
alert
.
description
)
;
}
else
{
qwarn
!
(
[
format
!
(
"
{
:
p
}
"
fd
)
]
"
duplicate
alert
{
}
"
alert
.
description
)
;
}
}
}
fn
ready
(
&
mut
self
is_server
:
bool
)
-
>
Res
<
(
)
>
{
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_AuthCertificateHook
(
self
.
fd
Some
(
Self
:
:
auth_complete_hook
)
as_c_void
(
&
mut
self
.
auth_required
)
)
}
)
?
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_AlertSentCallback
(
self
.
fd
Some
(
Self
:
:
alert_sent_cb
)
as_c_void
(
&
mut
self
.
alert
)
)
}
)
?
;
self
.
now
.
bind
(
self
.
fd
)
?
;
self
.
configure
(
)
?
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_ResetHandshake
(
self
.
fd
ssl
:
:
PRBool
:
:
from
(
is_server
)
)
}
)
}
fn
configure
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
set_version_range
(
TLS_VERSION_1_3
TLS_VERSION_1_3
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
Locking
false
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
Tickets
false
)
?
;
self
.
set_option
(
ssl
:
:
Opt
:
:
OcspStapling
true
)
?
;
Ok
(
(
)
)
}
pub
fn
set_version_range
(
&
mut
self
min
:
Version
max
:
Version
)
-
>
Res
<
(
)
>
{
let
range
=
ssl
:
:
SSLVersionRange
{
min
max
}
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_VersionRangeSet
(
self
.
fd
&
range
)
}
)
}
pub
fn
set_ciphers
(
&
mut
self
ciphers
:
&
[
Cipher
]
)
-
>
Res
<
(
)
>
{
if
self
.
state
!
=
HandshakeState
:
:
New
{
qwarn
!
(
[
self
]
"
Cannot
enable
ciphers
in
state
{
:
?
}
"
self
.
state
)
;
return
Err
(
Error
:
:
InternalError
)
;
}
let
all_ciphers
=
unsafe
{
ssl
:
:
SSL_GetImplementedCiphers
(
)
}
;
let
cipher_count
=
usize
:
:
from
(
unsafe
{
ssl
:
:
SSL_GetNumImplementedCiphers
(
)
}
)
;
for
i
in
0
.
.
cipher_count
{
let
p
=
all_ciphers
.
wrapping_add
(
i
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_CipherPrefSet
(
self
.
fd
i32
:
:
from
(
*
p
)
ssl
:
:
PRBool
:
:
from
(
false
)
)
}
)
?
;
}
for
c
in
ciphers
{
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_CipherPrefSet
(
self
.
fd
i32
:
:
from
(
*
c
)
ssl
:
:
PRBool
:
:
from
(
true
)
)
}
)
?
;
}
Ok
(
(
)
)
}
pub
fn
set_groups
(
&
mut
self
groups
:
&
[
Group
]
)
-
>
Res
<
(
)
>
{
let
group_vec
:
Vec
<
_
>
=
groups
.
iter
(
)
.
map
(
|
&
g
|
ssl
:
:
SSLNamedGroup
:
:
Type
:
:
from
(
g
)
)
.
collect
(
)
;
let
ptr
=
group_vec
.
as_slice
(
)
.
as_ptr
(
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_NamedGroupConfig
(
self
.
fd
ptr
c_uint
:
:
try_from
(
group_vec
.
len
(
)
)
?
)
}
)
}
pub
fn
set_option
(
&
mut
self
opt
:
ssl
:
:
Opt
value
:
bool
)
-
>
Res
<
(
)
>
{
opt
.
set
(
self
.
fd
value
)
}
pub
fn
enable_0rtt
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
set_option
(
ssl
:
:
Opt
:
:
EarlyData
true
)
}
pub
fn
disable_end_of_early_data
(
&
mut
self
)
-
>
Res
<
(
)
>
{
self
.
set_option
(
ssl
:
:
Opt
:
:
SuppressEndOfEarlyData
true
)
}
pub
fn
set_alpn
(
&
mut
self
protocols
:
&
[
impl
AsRef
<
str
>
]
)
-
>
Res
<
(
)
>
{
let
mut
encoded_len
=
protocols
.
len
(
)
;
for
v
in
protocols
{
assert
!
(
v
.
as_ref
(
)
.
len
(
)
<
256
)
;
encoded_len
+
=
v
.
as_ref
(
)
.
len
(
)
;
}
let
mut
encoded
=
Vec
:
:
with_capacity
(
encoded_len
)
;
let
mut
add
=
|
v
:
&
str
|
{
if
let
Ok
(
s
)
=
u8
:
:
try_from
(
v
.
len
(
)
)
{
encoded
.
push
(
s
)
;
encoded
.
extend_from_slice
(
v
.
as_bytes
(
)
)
;
}
}
;
let
(
first
rest
)
=
protocols
.
split_first
(
)
.
expect
(
"
at
least
one
ALPN
value
needed
"
)
;
for
v
in
rest
{
add
(
v
.
as_ref
(
)
)
;
}
add
(
first
.
as_ref
(
)
)
;
assert_eq
!
(
encoded_len
encoded
.
len
(
)
)
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_SetNextProtoNego
(
self
.
fd
encoded
.
as_slice
(
)
.
as_ptr
(
)
c_uint
:
:
try_from
(
encoded
.
len
(
)
)
?
)
}
)
}
pub
fn
extension_handler
(
&
mut
self
ext
:
Extension
handler
:
Rc
<
RefCell
<
dyn
ExtensionHandler
>
>
)
-
>
Res
<
(
)
>
{
let
tracker
=
unsafe
{
ExtensionTracker
:
:
new
(
self
.
fd
ext
handler
)
}
?
;
self
.
extension_handlers
.
push
(
tracker
)
;
Ok
(
(
)
)
}
fn
set_raw
(
&
mut
self
r
:
bool
)
-
>
Res
<
(
)
>
{
if
self
.
raw
.
is_none
(
)
{
self
.
secrets
.
register
(
self
.
fd
)
?
;
self
.
raw
=
Some
(
r
)
;
Ok
(
(
)
)
}
else
if
self
.
raw
.
unwrap
(
)
=
=
r
{
Ok
(
(
)
)
}
else
{
Err
(
Error
:
:
MixedHandshakeMethod
)
}
}
#
[
must_use
]
pub
fn
info
(
&
self
)
-
>
Option
<
&
SecretAgentInfo
>
{
match
self
.
state
{
HandshakeState
:
:
Complete
(
ref
info
)
=
>
Some
(
info
)
_
=
>
None
}
}
pub
fn
preinfo
(
&
self
)
-
>
Res
<
SecretAgentPreInfo
>
{
SecretAgentPreInfo
:
:
new
(
self
.
fd
)
}
#
[
must_use
]
pub
fn
peer_certificate
(
&
self
)
-
>
Option
<
CertificateInfo
>
{
CertificateInfo
:
:
new
(
self
.
fd
)
}
#
[
must_use
]
pub
fn
alert
(
&
self
)
-
>
Option
<
&
Alert
>
{
(
&
*
self
.
alert
)
.
as_ref
(
)
}
pub
fn
authenticated
(
&
mut
self
status
:
AuthenticationStatus
)
{
assert_eq
!
(
self
.
state
HandshakeState
:
:
AuthenticationPending
)
;
*
self
.
auth_required
=
false
;
self
.
state
=
HandshakeState
:
:
Authenticated
(
status
.
into
(
)
)
;
}
fn
capture_error
<
T
>
(
&
mut
self
res
:
Res
<
T
>
)
-
>
Res
<
T
>
{
if
let
Err
(
e
)
=
&
res
{
qwarn
!
(
[
self
]
"
error
:
{
:
?
}
"
e
)
;
self
.
state
=
HandshakeState
:
:
Failed
(
e
.
clone
(
)
)
;
}
res
}
fn
update_state
(
&
mut
self
res
:
Res
<
(
)
>
)
-
>
Res
<
(
)
>
{
self
.
state
=
if
is_blocked
(
&
res
)
{
if
*
self
.
auth_required
{
HandshakeState
:
:
AuthenticationPending
}
else
{
HandshakeState
:
:
InProgress
}
}
else
{
self
.
capture_error
(
res
)
?
;
let
info
=
self
.
capture_error
(
SecretAgentInfo
:
:
new
(
self
.
fd
)
)
?
;
HandshakeState
:
:
Complete
(
info
)
}
;
qinfo
!
(
[
self
]
"
state
-
>
{
:
?
}
"
self
.
state
)
;
Ok
(
(
)
)
}
pub
fn
handshake
(
&
mut
self
now
:
Instant
input
:
&
[
u8
]
)
-
>
Res
<
Vec
<
u8
>
>
{
self
.
now
.
set
(
now
)
?
;
self
.
set_raw
(
false
)
?
;
let
rv
=
{
let
_h
=
self
.
io
.
wrap
(
input
)
;
match
self
.
state
{
HandshakeState
:
:
Authenticated
(
ref
err
)
=
>
unsafe
{
ssl
:
:
SSL_AuthCertificateComplete
(
self
.
fd
*
err
)
}
_
=
>
unsafe
{
ssl
:
:
SSL_ForceHandshake
(
self
.
fd
)
}
}
}
;
let
output
=
self
.
io
.
take_output
(
)
;
self
.
update_state
(
secstatus_to_res
(
rv
)
)
?
;
Ok
(
output
)
}
fn
setup_raw
(
&
mut
self
)
-
>
Res
<
Pin
<
Box
<
RecordList
>
>
>
{
self
.
set_raw
(
true
)
?
;
self
.
capture_error
(
RecordList
:
:
setup
(
self
.
fd
)
)
}
pub
fn
handshake_raw
(
&
mut
self
now
:
Instant
input
:
Option
<
Record
>
)
-
>
Res
<
RecordList
>
{
self
.
now
.
set
(
now
)
?
;
let
records
=
self
.
setup_raw
(
)
?
;
if
let
HandshakeState
:
:
Authenticated
(
ref
err
)
=
self
.
state
{
let
result
=
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_AuthCertificateComplete
(
self
.
fd
*
err
)
}
)
;
qdebug
!
(
[
self
]
"
SSL_AuthCertificateComplete
:
{
:
?
}
"
result
)
;
self
.
capture_error
(
result
)
?
;
}
if
let
Some
(
rec
)
=
input
{
self
.
capture_error
(
rec
.
write
(
self
.
fd
)
)
?
;
}
let
rv
=
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_ForceHandshake
(
self
.
fd
)
}
)
;
self
.
update_state
(
rv
)
?
;
Ok
(
*
Pin
:
:
into_inner
(
records
)
)
}
pub
fn
close
(
&
mut
self
)
{
if
self
.
fd
.
is_null
(
)
{
return
;
}
if
let
Some
(
true
)
=
self
.
raw
{
let
_records
=
self
.
setup_raw
(
)
.
expect
(
"
Can
only
close
"
)
;
unsafe
{
prio
:
:
PR_Close
(
self
.
fd
as
*
mut
prio
:
:
PRFileDesc
)
}
;
}
else
{
let
_io
=
self
.
io
.
wrap
(
&
[
]
)
;
unsafe
{
prio
:
:
PR_Close
(
self
.
fd
as
*
mut
prio
:
:
PRFileDesc
)
}
;
}
;
let
_output
=
self
.
io
.
take_output
(
)
;
self
.
fd
=
null_mut
(
)
;
}
#
[
must_use
]
pub
fn
state
(
&
self
)
-
>
&
HandshakeState
{
&
self
.
state
}
#
[
must_use
]
pub
fn
read_secret
(
&
mut
self
epoch
:
Epoch
)
-
>
Option
<
p11
:
:
SymKey
>
{
self
.
secrets
.
take_read
(
epoch
)
}
#
[
must_use
]
pub
fn
write_secret
(
&
mut
self
epoch
:
Epoch
)
-
>
Option
<
p11
:
:
SymKey
>
{
self
.
secrets
.
take_write
(
epoch
)
}
}
impl
Drop
for
SecretAgent
{
fn
drop
(
&
mut
self
)
{
self
.
close
(
)
;
}
}
impl
:
:
std
:
:
fmt
:
:
Display
for
SecretAgent
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Agent
{
:
p
}
"
self
.
fd
)
}
}
#
[
derive
(
Debug
PartialOrd
Ord
PartialEq
Eq
Clone
)
]
pub
struct
ResumptionToken
{
token
:
Vec
<
u8
>
expiration_time
:
Instant
}
impl
AsRef
<
[
u8
]
>
for
ResumptionToken
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
token
}
}
impl
ResumptionToken
{
#
[
must_use
]
pub
fn
new
(
token
:
Vec
<
u8
>
expiration_time
:
Instant
)
-
>
Self
{
Self
{
token
expiration_time
}
}
#
[
must_use
]
pub
fn
expiration_time
(
&
self
)
-
>
Instant
{
self
.
expiration_time
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
clippy
:
:
box_vec
)
]
pub
struct
Client
{
agent
:
SecretAgent
resumption
:
Pin
<
Box
<
Vec
<
ResumptionToken
>
>
>
}
impl
Client
{
pub
fn
new
(
server_name
:
&
str
)
-
>
Res
<
Self
>
{
let
mut
agent
=
SecretAgent
:
:
new
(
)
?
;
let
url
=
CString
:
:
new
(
server_name
)
?
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_SetURL
(
agent
.
fd
url
.
as_ptr
(
)
)
}
)
?
;
agent
.
ready
(
false
)
?
;
let
mut
client
=
Self
{
agent
resumption
:
Box
:
:
pin
(
Vec
:
:
new
(
)
)
}
;
client
.
ready
(
)
?
;
Ok
(
client
)
}
unsafe
extern
"
C
"
fn
resumption_token_cb
(
fd
:
*
mut
ssl
:
:
PRFileDesc
token
:
*
const
u8
len
:
c_uint
arg
:
*
mut
c_void
)
-
>
ssl
:
:
SECStatus
{
let
mut
info
:
MaybeUninit
<
ssl
:
:
SSLResumptionTokenInfo
>
=
MaybeUninit
:
:
uninit
(
)
;
if
ssl
:
:
SSL_GetResumptionTokenInfo
(
token
len
info
.
as_mut_ptr
(
)
c_uint
:
:
try_from
(
mem
:
:
size_of
:
:
<
ssl
:
:
SSLResumptionTokenInfo
>
(
)
)
.
unwrap
(
)
)
.
is_err
(
)
{
return
ssl
:
:
SECSuccess
;
}
let
expiration_time
=
info
.
assume_init
(
)
.
expirationTime
;
if
ssl
:
:
SSL_DestroyResumptionTokenInfo
(
info
.
as_mut_ptr
(
)
)
.
is_err
(
)
{
return
ssl
:
:
SECSuccess
;
}
let
resumption_ptr
=
arg
as
*
mut
Vec
<
ResumptionToken
>
;
let
resumption
=
resumption_ptr
.
as_mut
(
)
.
unwrap
(
)
;
let
len
=
usize
:
:
try_from
(
len
)
.
unwrap
(
)
;
let
mut
v
=
Vec
:
:
with_capacity
(
len
)
;
v
.
extend_from_slice
(
std
:
:
slice
:
:
from_raw_parts
(
token
len
)
)
;
qinfo
!
(
[
format
!
(
"
{
:
p
}
"
fd
)
]
"
Got
resumption
token
{
}
"
hex_snip_middle
(
&
v
)
)
;
if
resumption
.
len
(
)
>
=
MAX_TICKETS
{
resumption
.
remove
(
0
)
;
}
if
let
Ok
(
t
)
=
Time
:
:
try_from
(
expiration_time
)
{
resumption
.
push
(
ResumptionToken
:
:
new
(
v
*
t
)
)
;
}
ssl
:
:
SECSuccess
}
fn
ready
(
&
mut
self
)
-
>
Res
<
(
)
>
{
let
fd
=
self
.
fd
;
unsafe
{
ssl
:
:
SSL_SetResumptionTokenCallback
(
fd
Some
(
Self
:
:
resumption_token_cb
)
as_c_void
(
&
mut
self
.
resumption
)
)
}
}
#
[
must_use
]
pub
fn
resumption_token
(
&
mut
self
)
-
>
Option
<
ResumptionToken
>
{
(
*
self
.
resumption
)
.
pop
(
)
}
#
[
must_use
]
pub
fn
has_resumption_token
(
&
self
)
-
>
bool
{
!
(
*
self
.
resumption
)
.
is_empty
(
)
}
pub
fn
enable_resumption
(
&
mut
self
token
:
impl
AsRef
<
[
u8
]
>
)
-
>
Res
<
(
)
>
{
unsafe
{
ssl
:
:
SSL_SetResumptionToken
(
self
.
agent
.
fd
token
.
as_ref
(
)
.
as_ptr
(
)
c_uint
:
:
try_from
(
token
.
as_ref
(
)
.
len
(
)
)
?
)
}
}
}
impl
Deref
for
Client
{
type
Target
=
SecretAgent
;
#
[
must_use
]
fn
deref
(
&
self
)
-
>
&
SecretAgent
{
&
self
.
agent
}
}
impl
DerefMut
for
Client
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
SecretAgent
{
&
mut
self
.
agent
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
ZeroRttCheckResult
{
Accept
Reject
HelloRetryRequest
(
Vec
<
u8
>
)
Fail
}
pub
trait
ZeroRttChecker
:
std
:
:
fmt
:
:
Debug
+
std
:
:
marker
:
:
Unpin
{
fn
check
(
&
self
token
:
&
[
u8
]
)
-
>
ZeroRttCheckResult
;
}
#
[
derive
(
Debug
)
]
pub
struct
AllowZeroRtt
{
}
impl
ZeroRttChecker
for
AllowZeroRtt
{
fn
check
(
&
self
_token
:
&
[
u8
]
)
-
>
ZeroRttCheckResult
{
qwarn
!
(
"
AllowZeroRtt
accepting
0
-
RTT
"
)
;
ZeroRttCheckResult
:
:
Accept
}
}
#
[
derive
(
Debug
)
]
struct
ZeroRttCheckState
{
fd
:
*
mut
ssl
:
:
PRFileDesc
checker
:
Pin
<
Box
<
dyn
ZeroRttChecker
>
>
}
impl
ZeroRttCheckState
{
pub
fn
new
(
fd
:
*
mut
ssl
:
:
PRFileDesc
checker
:
Box
<
dyn
ZeroRttChecker
>
)
-
>
Self
{
Self
{
fd
checker
:
Pin
:
:
new
(
checker
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Server
{
agent
:
SecretAgent
zero_rtt_check
:
Option
<
Pin
<
Box
<
ZeroRttCheckState
>
>
>
}
impl
Server
{
pub
fn
new
(
certificates
:
&
[
impl
AsRef
<
str
>
]
)
-
>
Res
<
Self
>
{
let
mut
agent
=
SecretAgent
:
:
new
(
)
?
;
for
n
in
certificates
{
let
c
=
CString
:
:
new
(
n
.
as_ref
(
)
)
?
;
let
cert
=
match
NonNull
:
:
new
(
unsafe
{
p11
:
:
PK11_FindCertFromNickname
(
c
.
as_ptr
(
)
null_mut
(
)
)
}
)
{
None
=
>
return
Err
(
Error
:
:
CertificateLoading
)
Some
(
ptr
)
=
>
p11
:
:
Certificate
:
:
new
(
ptr
)
}
;
let
key
=
match
NonNull
:
:
new
(
unsafe
{
p11
:
:
PK11_FindKeyByAnyCert
(
*
cert
.
deref
(
)
null_mut
(
)
)
}
)
{
None
=
>
return
Err
(
Error
:
:
CertificateLoading
)
Some
(
ptr
)
=
>
p11
:
:
PrivateKey
:
:
new
(
ptr
)
}
;
secstatus_to_res
(
unsafe
{
ssl
:
:
SSL_ConfigServerCert
(
agent
.
fd
*
cert
.
deref
(
)
*
key
.
deref
(
)
null
(
)
0
)
}
)
?
;
}
agent
.
ready
(
true
)
?
;
Ok
(
Self
{
agent
zero_rtt_check
:
None
}
)
}
unsafe
extern
"
C
"
fn
hello_retry_cb
(
first_hello
:
PRBool
client_token
:
*
const
u8
client_token_len
:
c_uint
retry_token
:
*
mut
u8
retry_token_len
:
*
mut
c_uint
retry_token_max
:
c_uint
arg
:
*
mut
c_void
)
-
>
ssl
:
:
SSLHelloRetryRequestAction
:
:
Type
{
if
first_hello
=
=
0
{
return
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_accept
;
}
let
p
=
arg
as
*
mut
ZeroRttCheckState
;
let
check_state
=
p
.
as_mut
(
)
.
unwrap
(
)
;
let
token
=
if
client_token
.
is_null
(
)
{
&
[
]
}
else
{
std
:
:
slice
:
:
from_raw_parts
(
client_token
usize
:
:
try_from
(
client_token_len
)
.
unwrap
(
)
)
}
;
match
check_state
.
checker
.
check
(
token
)
{
ZeroRttCheckResult
:
:
Accept
=
>
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_accept
ZeroRttCheckResult
:
:
Fail
=
>
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_fail
ZeroRttCheckResult
:
:
Reject
=
>
{
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_reject_0rtt
}
ZeroRttCheckResult
:
:
HelloRetryRequest
(
tok
)
=
>
{
assert
!
(
tok
.
len
(
)
<
=
usize
:
:
try_from
(
retry_token_max
)
.
unwrap
(
)
)
;
let
slc
=
std
:
:
slice
:
:
from_raw_parts_mut
(
retry_token
tok
.
len
(
)
)
;
slc
.
copy_from_slice
(
&
tok
)
;
*
retry_token_len
=
c_uint
:
:
try_from
(
tok
.
len
(
)
)
.
unwrap
(
)
;
ssl
:
:
SSLHelloRetryRequestAction
:
:
ssl_hello_retry_request
}
}
}
pub
fn
enable_0rtt
(
&
mut
self
anti_replay
:
&
AntiReplay
max_early_data
:
u32
checker
:
Box
<
dyn
ZeroRttChecker
>
)
-
>
Res
<
(
)
>
{
let
mut
check_state
=
Box
:
:
pin
(
ZeroRttCheckState
:
:
new
(
self
.
agent
.
fd
checker
)
)
;
unsafe
{
ssl
:
:
SSL_HelloRetryRequestCallback
(
self
.
agent
.
fd
Some
(
Self
:
:
hello_retry_cb
)
as_c_void
(
&
mut
check_state
)
)
}
?
;
unsafe
{
ssl
:
:
SSL_SetMaxEarlyDataSize
(
self
.
agent
.
fd
max_early_data
)
}
?
;
self
.
zero_rtt_check
=
Some
(
check_state
)
;
self
.
agent
.
enable_0rtt
(
)
?
;
anti_replay
.
config_socket
(
self
.
fd
)
?
;
Ok
(
(
)
)
}
pub
fn
send_ticket
(
&
mut
self
now
:
Instant
extra
:
&
[
u8
]
)
-
>
Res
<
RecordList
>
{
self
.
agent
.
now
.
set
(
now
)
?
;
let
records
=
self
.
setup_raw
(
)
?
;
unsafe
{
ssl
:
:
SSL_SendSessionTicket
(
self
.
fd
extra
.
as_ptr
(
)
c_uint
:
:
try_from
(
extra
.
len
(
)
)
?
)
}
?
;
Ok
(
*
Pin
:
:
into_inner
(
records
)
)
}
}
impl
Deref
for
Server
{
type
Target
=
SecretAgent
;
#
[
must_use
]
fn
deref
(
&
self
)
-
>
&
SecretAgent
{
&
self
.
agent
}
}
impl
DerefMut
for
Server
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
SecretAgent
{
&
mut
self
.
agent
}
}
#
[
derive
(
Debug
)
]
pub
enum
Agent
{
Client
(
crate
:
:
agent
:
:
Client
)
Server
(
crate
:
:
agent
:
:
Server
)
}
impl
Deref
for
Agent
{
type
Target
=
SecretAgent
;
#
[
must_use
]
fn
deref
(
&
self
)
-
>
&
SecretAgent
{
match
self
{
Self
:
:
Client
(
c
)
=
>
&
*
c
Self
:
:
Server
(
s
)
=
>
&
*
s
}
}
}
impl
DerefMut
for
Agent
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
SecretAgent
{
match
self
{
Self
:
:
Client
(
c
)
=
>
&
mut
*
c
Self
:
:
Server
(
s
)
=
>
&
mut
*
s
}
}
}
impl
From
<
Client
>
for
Agent
{
#
[
must_use
]
fn
from
(
c
:
Client
)
-
>
Self
{
Self
:
:
Client
(
c
)
}
}
impl
From
<
Server
>
for
Agent
{
#
[
must_use
]
fn
from
(
s
:
Server
)
-
>
Self
{
Self
:
:
Server
(
s
)
}
}
