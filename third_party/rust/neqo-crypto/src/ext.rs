use
crate
:
:
{
agentio
:
:
as_c_void
constants
:
:
{
Extension
HandshakeMessage
TLS_HS_CLIENT_HELLO
TLS_HS_ENCRYPTED_EXTENSIONS
}
err
:
:
Res
ssl
:
:
{
PRBool
PRFileDesc
SECFailure
SECStatus
SECSuccess
SSLAlertDescription
SSLExtensionHandler
SSLExtensionWriter
SSLHandshakeType
}
}
;
use
std
:
:
{
cell
:
:
RefCell
convert
:
:
TryFrom
os
:
:
raw
:
:
{
c_uint
c_void
}
pin
:
:
Pin
rc
:
:
Rc
}
;
experimental_api
!
(
SSL_InstallExtensionHooks
(
fd
:
*
mut
PRFileDesc
extension
:
u16
writer
:
SSLExtensionWriter
writer_arg
:
*
mut
c_void
handler
:
SSLExtensionHandler
handler_arg
:
*
mut
c_void
)
)
;
pub
enum
ExtensionWriterResult
{
Write
(
usize
)
Skip
}
pub
enum
ExtensionHandlerResult
{
Ok
Alert
(
crate
:
:
constants
:
:
Alert
)
}
pub
trait
ExtensionHandler
{
fn
write
(
&
mut
self
msg
:
HandshakeMessage
_d
:
&
mut
[
u8
]
)
-
>
ExtensionWriterResult
{
match
msg
{
TLS_HS_CLIENT_HELLO
|
TLS_HS_ENCRYPTED_EXTENSIONS
=
>
ExtensionWriterResult
:
:
Write
(
0
)
_
=
>
ExtensionWriterResult
:
:
Skip
}
}
fn
handle
(
&
mut
self
msg
:
HandshakeMessage
_d
:
&
[
u8
]
)
-
>
ExtensionHandlerResult
{
match
msg
{
TLS_HS_CLIENT_HELLO
|
TLS_HS_ENCRYPTED_EXTENSIONS
=
>
ExtensionHandlerResult
:
:
Ok
_
=
>
ExtensionHandlerResult
:
:
Alert
(
110
)
}
}
}
type
BoxedExtensionHandler
=
Box
<
Rc
<
RefCell
<
dyn
ExtensionHandler
>
>
>
;
pub
struct
ExtensionTracker
{
extension
:
Extension
handler
:
Pin
<
Box
<
BoxedExtensionHandler
>
>
}
impl
ExtensionTracker
{
unsafe
fn
wrap_handler_call
<
F
T
>
(
arg
:
*
mut
c_void
f
:
F
)
-
>
T
where
F
:
FnOnce
(
&
mut
dyn
ExtensionHandler
)
-
>
T
{
let
rc
=
arg
.
cast
:
:
<
BoxedExtensionHandler
>
(
)
.
as_mut
(
)
.
unwrap
(
)
;
f
(
&
mut
*
rc
.
borrow_mut
(
)
)
}
#
[
allow
(
clippy
:
:
cast_possible_truncation
)
]
unsafe
extern
"
C
"
fn
extension_writer
(
_fd
:
*
mut
PRFileDesc
message
:
SSLHandshakeType
:
:
Type
data
:
*
mut
u8
len
:
*
mut
c_uint
max_len
:
c_uint
arg
:
*
mut
c_void
)
-
>
PRBool
{
let
d
=
std
:
:
slice
:
:
from_raw_parts_mut
(
data
max_len
as
usize
)
;
Self
:
:
wrap_handler_call
(
arg
|
handler
|
{
match
handler
.
write
(
message
as
HandshakeMessage
d
)
{
ExtensionWriterResult
:
:
Write
(
sz
)
=
>
{
*
len
=
c_uint
:
:
try_from
(
sz
)
.
expect
(
"
integer
overflow
from
extension
writer
"
)
;
1
}
ExtensionWriterResult
:
:
Skip
=
>
0
}
}
)
}
unsafe
extern
"
C
"
fn
extension_handler
(
_fd
:
*
mut
PRFileDesc
message
:
SSLHandshakeType
:
:
Type
data
:
*
const
u8
len
:
c_uint
alert
:
*
mut
SSLAlertDescription
arg
:
*
mut
c_void
)
-
>
SECStatus
{
let
d
=
std
:
:
slice
:
:
from_raw_parts
(
data
len
as
usize
)
;
#
[
allow
(
clippy
:
:
cast_possible_truncation
)
]
Self
:
:
wrap_handler_call
(
arg
|
handler
|
{
match
handler
.
handle
(
message
as
HandshakeMessage
d
)
{
ExtensionHandlerResult
:
:
Ok
=
>
SECSuccess
ExtensionHandlerResult
:
:
Alert
(
a
)
=
>
{
*
alert
=
a
;
SECFailure
}
}
}
)
}
pub
unsafe
fn
new
(
fd
:
*
mut
PRFileDesc
extension
:
Extension
handler
:
Rc
<
RefCell
<
dyn
ExtensionHandler
>
>
)
-
>
Res
<
Self
>
{
let
mut
tracker
=
Self
{
extension
handler
:
Box
:
:
pin
(
Box
:
:
new
(
handler
)
)
}
;
SSL_InstallExtensionHooks
(
fd
extension
Some
(
Self
:
:
extension_writer
)
as_c_void
(
&
mut
tracker
.
handler
)
Some
(
Self
:
:
extension_handler
)
as_c_void
(
&
mut
tracker
.
handler
)
)
?
;
Ok
(
tracker
)
}
}
impl
std
:
:
fmt
:
:
Debug
for
ExtensionTracker
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
ExtensionTracker
:
{
:
?
}
"
self
.
extension
)
}
}
