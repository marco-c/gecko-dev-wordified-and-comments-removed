use
neqo_crypto
:
:
{
assert_initialized
init_db
}
;
#
[
allow
(
dead_code
non_upper_case_globals
)
]
mod
nss
{
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
nss_init
.
rs
"
)
)
;
}
#
[
cfg
(
nss_nodb
)
]
#
[
test
]
fn
init_nodb
(
)
{
neqo_crypto
:
:
init
(
)
.
unwrap
(
)
;
assert_initialized
(
)
;
unsafe
{
assert_ne
!
(
nss
:
:
NSS_IsInitialized
(
)
0
)
;
}
}
#
[
cfg
(
nss_nodb
)
]
#
[
test
]
fn
init_twice_nodb
(
)
{
unsafe
{
nss
:
:
NSS_NoDB_Init
(
std
:
:
ptr
:
:
null
(
)
)
;
assert_ne
!
(
nss
:
:
NSS_IsInitialized
(
)
0
)
;
}
init_nodb
(
)
;
}
#
[
cfg
(
not
(
nss_nodb
)
)
]
#
[
test
]
fn
init_withdb
(
)
{
init_db
(
:
:
test_fixture
:
:
NSS_DB_PATH
)
.
unwrap
(
)
;
assert_initialized
(
)
;
unsafe
{
assert_ne
!
(
nss
:
:
NSS_IsInitialized
(
)
0
)
;
}
}
#
[
cfg
(
not
(
nss_nodb
)
)
]
#
[
test
]
fn
init_twice_withdb
(
)
{
use
std
:
:
{
ffi
:
:
CString
path
:
:
PathBuf
}
;
let
empty
=
CString
:
:
new
(
"
"
)
.
unwrap
(
)
;
let
path
:
PathBuf
=
:
:
test_fixture
:
:
NSS_DB_PATH
.
into
(
)
;
assert
!
(
path
.
is_dir
(
)
)
;
let
pathstr
=
path
.
to_str
(
)
.
unwrap
(
)
;
let
dircstr
=
CString
:
:
new
(
pathstr
)
.
unwrap
(
)
;
unsafe
{
nss
:
:
NSS_Initialize
(
dircstr
.
as_ptr
(
)
empty
.
as_ptr
(
)
empty
.
as_ptr
(
)
nss
:
:
SECMOD_DB
.
as_ptr
(
)
.
cast
(
)
nss
:
:
NSS_INIT_READONLY
)
;
assert_ne
!
(
nss
:
:
NSS_IsInitialized
(
)
0
)
;
}
init_withdb
(
)
;
}
