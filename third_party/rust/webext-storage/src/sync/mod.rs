mod
bridge
;
mod
incoming
;
mod
outgoing
;
#
[
cfg
(
test
)
]
mod
sync_tests
;
use
serde_derive
:
:
*
;
use
sync_guid
:
:
Guid
as
SyncGuid
;
pub
use
bridge
:
:
BridgedEngine
;
use
incoming
:
:
IncomingAction
;
type
JsonMap
=
serde_json
:
:
Map
<
String
serde_json
:
:
Value
>
;
pub
const
STORAGE_VERSION
:
usize
=
1
;
#
[
inline
]
pub
fn
is_default
<
T
:
PartialEq
+
Default
>
(
v
:
&
T
)
-
>
bool
{
*
v
=
=
T
:
:
default
(
)
}
#
[
derive
(
Debug
Serialize
Deserialize
)
]
#
[
serde
(
rename_all
=
"
camelCase
"
)
]
pub
struct
Record
{
#
[
serde
(
rename
=
"
id
"
)
]
guid
:
SyncGuid
ext_id
:
String
#
[
serde
(
default
skip_serializing_if
=
"
is_default
"
)
]
data
:
Option
<
String
>
}
fn
merge
(
mut
other
:
JsonMap
mut
ours
:
JsonMap
parent
:
Option
<
JsonMap
>
)
-
>
IncomingAction
{
if
other
=
=
ours
{
return
IncomingAction
:
:
Same
;
}
let
old_incoming
=
other
.
clone
(
)
;
if
let
Some
(
parent
)
=
parent
{
for
(
key
parent_value
)
in
parent
.
into_iter
(
)
{
if
let
Some
(
incoming_value
)
=
other
.
remove
(
&
key
)
{
if
incoming_value
!
=
parent_value
{
log
:
:
trace
!
(
"
merge
:
key
{
}
was
updated
in
incoming
-
copying
value
locally
"
key
)
;
ours
.
insert
(
key
incoming_value
)
;
}
}
else
{
log
:
:
trace
!
(
"
merge
:
key
{
}
no
longer
present
in
incoming
-
removing
it
locally
"
key
)
;
ours
.
remove
(
&
key
)
;
}
}
for
(
key
incoming_value
)
in
other
.
into_iter
(
)
{
log
:
:
trace
!
(
"
merge
:
key
{
}
doesn
'
t
occur
in
parent
-
copying
from
incoming
"
key
)
;
ours
.
insert
(
key
incoming_value
)
;
}
}
else
{
log
:
:
trace
!
(
"
merge
:
no
parent
-
copying
all
keys
from
incoming
"
)
;
for
(
key
incoming_value
)
in
other
.
into_iter
(
)
{
ours
.
insert
(
key
incoming_value
)
;
}
}
if
ours
=
=
old_incoming
{
IncomingAction
:
:
TakeRemote
{
data
:
old_incoming
}
}
else
{
IncomingAction
:
:
Merge
{
data
:
ours
}
}
}
fn
remove_matching_keys
(
mut
ours
:
JsonMap
blacklist
:
&
JsonMap
)
-
>
JsonMap
{
for
key
in
blacklist
.
keys
(
)
{
ours
.
remove
(
key
)
;
}
ours
}
#
[
cfg
(
test
)
]
pub
mod
test
{
use
crate
:
:
db
:
:
{
test
:
:
new_mem_db
StorageDb
}
;
use
crate
:
:
schema
:
:
create_empty_sync_temp_tables
;
pub
fn
new_syncable_mem_db
(
)
-
>
StorageDb
{
let
_
=
env_logger
:
:
try_init
(
)
;
let
db
=
new_mem_db
(
)
;
create_empty_sync_temp_tables
(
&
db
)
.
expect
(
"
should
work
"
)
;
db
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
error
:
:
*
;
use
serde_json
:
:
json
;
macro_rules
!
map
{
(
(
map
:
tt
)
+
)
=
>
{
json
!
(
(
map
)
+
)
.
as_object
(
)
.
unwrap
(
)
.
clone
(
)
}
;
}
#
[
test
]
fn
test_3way_merging
(
)
-
>
Result
<
(
)
>
{
assert_eq
!
(
merge
(
map
!
(
{
"
one
"
:
"
one
"
"
two
"
:
"
two
"
}
)
map
!
(
{
"
two
"
:
"
two
"
"
one
"
:
"
one
"
}
)
Some
(
map
!
(
{
"
parent_only
"
:
"
parent
"
}
)
)
)
IncomingAction
:
:
Same
)
;
assert_eq
!
(
merge
(
map
!
(
{
"
other_only
"
:
"
other
"
"
common
"
:
"
common
"
}
)
map
!
(
{
"
ours_only
"
:
"
ours
"
"
common
"
:
"
common
"
}
)
Some
(
map
!
(
{
"
parent_only
"
:
"
parent
"
"
common
"
:
"
old_common
"
}
)
)
)
IncomingAction
:
:
Merge
{
data
:
map
!
(
{
"
other_only
"
:
"
other
"
"
ours_only
"
:
"
ours
"
"
common
"
:
"
common
"
}
)
}
)
;
assert_eq
!
(
merge
(
map
!
(
{
"
other_only
"
:
"
other
"
"
common
"
:
"
incoming
"
}
)
map
!
(
{
"
ours_only
"
:
"
ours
"
"
common
"
:
"
local
"
}
)
Some
(
map
!
(
{
"
parent_only
"
:
"
parent
"
"
common
"
:
"
parent
"
}
)
)
)
IncomingAction
:
:
Merge
{
data
:
map
!
(
{
"
other_only
"
:
"
other
"
"
ours_only
"
:
"
ours
"
"
common
"
:
"
incoming
"
}
)
}
)
;
assert_eq
!
(
merge
(
map
!
(
{
"
other_only
"
:
"
other
"
"
common
"
:
"
old_value
"
}
)
map
!
(
{
"
ours_only
"
:
"
ours
"
"
common
"
:
"
new_value
"
}
)
Some
(
map
!
(
{
"
parent_only
"
:
"
parent
"
"
common
"
:
"
old_value
"
}
)
)
)
IncomingAction
:
:
Merge
{
data
:
map
!
(
{
"
other_only
"
:
"
other
"
"
ours_only
"
:
"
ours
"
"
common
"
:
"
new_value
"
}
)
}
)
;
assert_eq
!
(
merge
(
map
!
(
{
"
other_only
"
:
"
other
"
}
)
map
!
(
{
"
common
"
:
"
old_value
"
}
)
Some
(
map
!
(
{
"
common
"
:
"
old_value
"
}
)
)
)
IncomingAction
:
:
TakeRemote
{
data
:
map
!
(
{
"
other_only
"
:
"
other
"
}
)
}
)
;
assert_eq
!
(
merge
(
map
!
(
{
"
other_only
"
:
"
other
"
}
)
map
!
(
{
"
common
"
:
"
old_value
"
"
new_key
"
:
"
new_value
"
}
)
Some
(
map
!
(
{
"
common
"
:
"
old_value
"
}
)
)
)
IncomingAction
:
:
Merge
{
data
:
map
!
(
{
"
other_only
"
:
"
other
"
"
new_key
"
:
"
new_value
"
}
)
}
)
;
assert_eq
!
(
merge
(
map
!
(
{
}
)
map
!
(
{
"
new_key
"
:
"
new_value
"
}
)
Some
(
map
!
(
{
"
common
"
:
"
old_value
"
}
)
)
)
IncomingAction
:
:
Merge
{
data
:
map
!
(
{
"
new_key
"
:
"
new_value
"
}
)
}
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_remove_matching_keys
(
)
-
>
Result
<
(
)
>
{
assert_eq
!
(
remove_matching_keys
(
map
!
(
{
"
key1
"
:
"
value1
"
"
key2
"
:
"
value2
"
}
)
&
map
!
(
{
"
key1
"
:
"
ignored
"
"
key3
"
:
"
ignored
"
}
)
)
map
!
(
{
"
key2
"
:
"
value2
"
}
)
)
;
Ok
(
(
)
)
}
}
