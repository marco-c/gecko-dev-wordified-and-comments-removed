use
crate
:
:
error
:
:
*
;
use
crate
:
:
schema
;
use
interrupt_support
:
:
{
SqlInterruptHandle
SqlInterruptScope
}
;
use
parking_lot
:
:
Mutex
;
use
rusqlite
:
:
types
:
:
{
FromSql
ToSql
}
;
use
rusqlite
:
:
Connection
;
use
rusqlite
:
:
OpenFlags
;
use
sql_support
:
:
open_database
:
:
open_database_with_flags
;
use
sql_support
:
:
ConnExt
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
sync
:
:
Arc
;
use
url
:
:
Url
;
pub
struct
StorageDb
{
writer
:
Connection
interrupt_handle
:
Arc
<
SqlInterruptHandle
>
}
impl
StorageDb
{
pub
fn
new
(
db_path
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Self
>
{
let
db_path
=
normalize_path
(
db_path
)
?
;
Self
:
:
new_named
(
db_path
)
}
#
[
cfg
(
test
)
]
pub
fn
new_memory
(
db_path
:
&
str
)
-
>
Result
<
Self
>
{
let
name
=
PathBuf
:
:
from
(
format
!
(
"
file
:
{
}
?
mode
=
memory
&
cache
=
shared
"
db_path
)
)
;
Self
:
:
new_named
(
name
)
}
fn
new_named
(
db_path
:
PathBuf
)
-
>
Result
<
Self
>
{
let
flags
=
OpenFlags
:
:
SQLITE_OPEN_NO_MUTEX
|
OpenFlags
:
:
SQLITE_OPEN_URI
|
OpenFlags
:
:
SQLITE_OPEN_CREATE
|
OpenFlags
:
:
SQLITE_OPEN_READ_WRITE
;
let
conn
=
open_database_with_flags
(
db_path
flags
&
schema
:
:
WebExtMigrationLogin
)
?
;
Ok
(
Self
{
interrupt_handle
:
Arc
:
:
new
(
SqlInterruptHandle
:
:
new
(
&
conn
)
)
writer
:
conn
}
)
}
pub
fn
interrupt_handle
(
&
self
)
-
>
Arc
<
SqlInterruptHandle
>
{
Arc
:
:
clone
(
&
self
.
interrupt_handle
)
}
#
[
allow
(
dead_code
)
]
pub
fn
begin_interrupt_scope
(
&
self
)
-
>
Result
<
SqlInterruptScope
>
{
Ok
(
self
.
interrupt_handle
.
begin_interrupt_scope
(
)
?
)
}
pub
fn
close
(
self
)
-
>
Result
<
(
)
>
{
self
.
writer
.
close
(
)
.
map_err
(
|
(
writer
err
)
|
{
std
:
:
mem
:
:
forget
(
writer
)
;
err
.
into
(
)
}
)
}
}
impl
Deref
for
StorageDb
{
type
Target
=
Connection
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
writer
}
}
impl
DerefMut
for
StorageDb
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
writer
}
}
pub
struct
ThreadSafeStorageDb
{
db
:
Mutex
<
StorageDb
>
interrupt_handle
:
Arc
<
SqlInterruptHandle
>
}
impl
ThreadSafeStorageDb
{
pub
fn
new
(
db
:
StorageDb
)
-
>
Self
{
Self
{
interrupt_handle
:
db
.
interrupt_handle
(
)
db
:
Mutex
:
:
new
(
db
)
}
}
pub
fn
interrupt_handle
(
&
self
)
-
>
Arc
<
SqlInterruptHandle
>
{
Arc
:
:
clone
(
&
self
.
interrupt_handle
)
}
pub
fn
begin_interrupt_scope
(
&
self
)
-
>
Result
<
SqlInterruptScope
>
{
Ok
(
self
.
interrupt_handle
.
begin_interrupt_scope
(
)
?
)
}
pub
fn
into_inner
(
self
)
-
>
StorageDb
{
self
.
db
.
into_inner
(
)
}
}
impl
Deref
for
ThreadSafeStorageDb
{
type
Target
=
Mutex
<
StorageDb
>
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Mutex
<
StorageDb
>
{
&
self
.
db
}
}
impl
AsRef
<
SqlInterruptHandle
>
for
ThreadSafeStorageDb
{
fn
as_ref
(
&
self
)
-
>
&
SqlInterruptHandle
{
&
self
.
interrupt_handle
}
}
pub
(
crate
)
mod
sql_fns
{
use
rusqlite
:
:
{
functions
:
:
Context
Result
}
;
use
sync_guid
:
:
Guid
as
SyncGuid
;
#
[
inline
(
never
)
]
pub
fn
generate_guid
(
_ctx
:
&
Context
<
'
_
>
)
-
>
Result
<
SyncGuid
>
{
Ok
(
SyncGuid
:
:
random
(
)
)
}
}
pub
fn
put_meta
(
db
:
&
Connection
key
:
&
str
value
:
&
dyn
ToSql
)
-
>
Result
<
(
)
>
{
db
.
conn
(
)
.
execute_cached
(
"
REPLACE
INTO
meta
(
key
value
)
VALUES
(
:
key
:
value
)
"
rusqlite
:
:
named_params
!
{
"
:
key
"
:
key
"
:
value
"
:
value
}
)
?
;
Ok
(
(
)
)
}
pub
fn
get_meta
<
T
:
FromSql
>
(
db
:
&
Connection
key
:
&
str
)
-
>
Result
<
Option
<
T
>
>
{
let
res
=
db
.
conn
(
)
.
try_query_one
(
"
SELECT
value
FROM
meta
WHERE
key
=
:
key
"
&
[
(
"
:
key
"
&
key
)
]
true
)
?
;
Ok
(
res
)
}
pub
fn
delete_meta
(
db
:
&
Connection
key
:
&
str
)
-
>
Result
<
(
)
>
{
db
.
conn
(
)
.
execute_cached
(
"
DELETE
FROM
meta
WHERE
key
=
:
key
"
&
[
(
"
:
key
"
&
key
)
]
)
?
;
Ok
(
(
)
)
}
fn
unurl_path
(
p
:
impl
AsRef
<
Path
>
)
-
>
PathBuf
{
p
.
as_ref
(
)
.
to_str
(
)
.
and_then
(
|
s
|
Url
:
:
parse
(
s
)
.
ok
(
)
)
.
and_then
(
|
u
|
{
if
u
.
scheme
(
)
=
=
"
file
"
{
u
.
to_file_path
(
)
.
ok
(
)
}
else
{
None
}
}
)
.
unwrap_or_else
(
|
|
p
.
as_ref
(
)
.
to_owned
(
)
)
}
#
[
allow
(
dead_code
)
]
pub
fn
ensure_url_path
(
p
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Url
>
{
if
let
Some
(
u
)
=
p
.
as_ref
(
)
.
to_str
(
)
.
and_then
(
|
s
|
Url
:
:
parse
(
s
)
.
ok
(
)
)
{
if
u
.
scheme
(
)
=
=
"
file
"
{
Ok
(
u
)
}
else
{
Err
(
Error
:
:
IllegalDatabasePath
(
p
.
as_ref
(
)
.
to_owned
(
)
)
)
}
}
else
{
let
p
=
p
.
as_ref
(
)
;
let
u
=
Url
:
:
from_file_path
(
p
)
.
map_err
(
|
_
|
Error
:
:
IllegalDatabasePath
(
p
.
to_owned
(
)
)
)
?
;
Ok
(
u
)
}
}
fn
normalize_path
(
p
:
impl
AsRef
<
Path
>
)
-
>
Result
<
PathBuf
>
{
let
path
=
unurl_path
(
p
)
;
if
let
Ok
(
canonical
)
=
path
.
canonicalize
(
)
{
return
Ok
(
canonical
)
;
}
let
file_name
=
path
.
file_name
(
)
.
ok_or_else
(
|
|
Error
:
:
IllegalDatabasePath
(
path
.
clone
(
)
)
)
?
;
let
parent
=
path
.
parent
(
)
.
ok_or_else
(
|
|
Error
:
:
IllegalDatabasePath
(
path
.
clone
(
)
)
)
?
;
let
mut
canonical
=
parent
.
canonicalize
(
)
?
;
canonical
.
push
(
file_name
)
;
Ok
(
canonical
)
}
#
[
cfg
(
test
)
]
pub
mod
test
{
use
super
:
:
*
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
static
ATOMIC_COUNTER
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
pub
fn
new_mem_db
(
)
-
>
StorageDb
{
let
_
=
env_logger
:
:
try_init
(
)
;
let
counter
=
ATOMIC_COUNTER
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
StorageDb
:
:
new_memory
(
&
format
!
(
"
test
-
api
-
{
}
"
counter
)
)
.
expect
(
"
should
get
an
API
"
)
}
pub
fn
new_mem_thread_safe_storage_db
(
)
-
>
Arc
<
ThreadSafeStorageDb
>
{
Arc
:
:
new
(
ThreadSafeStorageDb
:
:
new
(
new_mem_db
(
)
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
test
:
:
*
;
use
super
:
:
*
;
#
[
test
]
fn
test_open
(
)
{
new_mem_db
(
)
;
}
#
[
test
]
fn
test_meta
(
)
-
>
Result
<
(
)
>
{
let
writer
=
new_mem_db
(
)
;
assert_eq
!
(
get_meta
:
:
<
String
>
(
&
writer
"
foo
"
)
?
None
)
;
put_meta
(
&
writer
"
foo
"
&
"
bar
"
.
to_string
(
)
)
?
;
assert_eq
!
(
get_meta
(
&
writer
"
foo
"
)
?
Some
(
"
bar
"
.
to_string
(
)
)
)
;
delete_meta
(
&
writer
"
foo
"
)
?
;
assert_eq
!
(
get_meta
:
:
<
String
>
(
&
writer
"
foo
"
)
?
None
)
;
Ok
(
(
)
)
}
}
