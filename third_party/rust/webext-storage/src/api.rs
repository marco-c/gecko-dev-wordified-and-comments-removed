use
crate
:
:
error
:
:
*
;
use
rusqlite
:
:
{
Connection
Transaction
}
;
use
serde
:
:
{
ser
:
:
SerializeMap
Serialize
Serializer
}
;
use
serde_json
:
:
{
Map
Value
as
JsonValue
}
;
use
sql_support
:
:
{
self
ConnExt
}
;
const
QUOTA_BYTES
:
usize
=
102_400
;
const
QUOTA_BYTES_PER_ITEM
:
usize
=
8_192
;
const
MAX_ITEMS
:
usize
=
512
;
type
JsonMap
=
Map
<
String
JsonValue
>
;
fn
get_from_db
(
conn
:
&
Connection
ext_id
:
&
str
)
-
>
Result
<
Option
<
JsonMap
>
>
{
Ok
(
match
conn
.
try_query_one
:
:
<
String
>
(
"
SELECT
data
FROM
storage_sync_data
WHERE
ext_id
=
:
ext_id
"
&
[
(
"
:
ext_id
"
&
ext_id
)
]
true
)
?
{
Some
(
s
)
=
>
match
serde_json
:
:
from_str
(
&
s
)
?
{
JsonValue
:
:
Object
(
m
)
=
>
Some
(
m
)
_
=
>
None
}
None
=
>
None
}
)
}
fn
save_to_db
(
tx
:
&
Transaction
<
'
_
>
ext_id
:
&
str
val
:
&
JsonValue
)
-
>
Result
<
(
)
>
{
let
is_delete
=
match
val
{
JsonValue
:
:
Null
=
>
true
JsonValue
:
:
Object
(
m
)
=
>
m
.
is_empty
(
)
_
=
>
false
}
;
if
is_delete
{
let
in_mirror
=
tx
.
try_query_one
(
"
SELECT
EXISTS
(
SELECT
1
FROM
storage_sync_mirror
WHERE
ext_id
=
:
ext_id
)
;
"
rusqlite
:
:
named_params
!
{
"
:
ext_id
"
:
ext_id
}
true
)
?
.
unwrap_or_default
(
)
;
if
in_mirror
{
log
:
:
trace
!
(
"
saving
data
for
'
{
}
'
:
leaving
a
tombstone
"
ext_id
)
;
tx
.
execute_named_cached
(
"
INSERT
INTO
storage_sync_data
(
ext_id
data
sync_change_counter
)
VALUES
(
:
ext_id
NULL
1
)
ON
CONFLICT
(
ext_id
)
DO
UPDATE
SET
data
=
NULL
sync_change_counter
=
sync_change_counter
+
1
"
rusqlite
:
:
named_params
!
{
"
:
ext_id
"
:
ext_id
}
)
?
;
}
else
{
log
:
:
trace
!
(
"
saving
data
for
'
{
}
'
:
removing
the
row
"
ext_id
)
;
tx
.
execute_named_cached
(
"
DELETE
FROM
storage_sync_data
WHERE
ext_id
=
:
ext_id
"
rusqlite
:
:
named_params
!
{
"
:
ext_id
"
:
ext_id
}
)
?
;
}
}
else
{
let
sval
=
val
.
to_string
(
)
;
if
sval
.
len
(
)
>
QUOTA_BYTES
{
return
Err
(
ErrorKind
:
:
QuotaError
(
QuotaReason
:
:
TotalBytes
)
.
into
(
)
)
;
}
log
:
:
trace
!
(
"
saving
data
for
'
{
}
'
:
writing
"
ext_id
)
;
tx
.
execute_named_cached
(
"
INSERT
INTO
storage_sync_data
(
ext_id
data
sync_change_counter
)
VALUES
(
:
ext_id
:
data
1
)
ON
CONFLICT
(
ext_id
)
DO
UPDATE
set
data
=
:
data
sync_change_counter
=
sync_change_counter
+
1
"
rusqlite
:
:
named_params
!
{
"
:
ext_id
"
:
ext_id
"
:
data
"
:
&
sval
}
)
?
;
}
Ok
(
(
)
)
}
fn
remove_from_db
(
tx
:
&
Transaction
<
'
_
>
ext_id
:
&
str
)
-
>
Result
<
(
)
>
{
save_to_db
(
tx
ext_id
&
JsonValue
:
:
Null
)
}
#
[
derive
(
Debug
Clone
PartialEq
Serialize
)
]
#
[
serde
(
rename_all
=
"
camelCase
"
)
]
pub
struct
StorageValueChange
{
#
[
serde
(
skip_serializing
)
]
key
:
String
#
[
serde
(
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
old_value
:
Option
<
JsonValue
>
#
[
serde
(
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
new_value
:
Option
<
JsonValue
>
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
StorageChanges
{
changes
:
Vec
<
StorageValueChange
>
}
impl
StorageChanges
{
fn
new
(
)
-
>
Self
{
Self
{
changes
:
Vec
:
:
new
(
)
}
}
fn
with_capacity
(
n
:
usize
)
-
>
Self
{
Self
{
changes
:
Vec
:
:
with_capacity
(
n
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
changes
.
is_empty
(
)
}
fn
push
(
&
mut
self
change
:
StorageValueChange
)
{
self
.
changes
.
push
(
change
)
}
}
impl
Serialize
for
StorageChanges
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
let
mut
map
=
serializer
.
serialize_map
(
Some
(
self
.
changes
.
len
(
)
)
)
?
;
for
change
in
&
self
.
changes
{
map
.
serialize_entry
(
&
change
.
key
change
)
?
;
}
map
.
end
(
)
}
}
pub
fn
set
(
tx
:
&
Transaction
<
'
_
>
ext_id
:
&
str
val
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
val_map
=
match
val
{
JsonValue
:
:
Object
(
m
)
=
>
m
_
=
>
Map
:
:
new
(
)
}
;
let
mut
current
=
get_from_db
(
tx
ext_id
)
?
.
unwrap_or_default
(
)
;
let
mut
changes
=
StorageChanges
:
:
with_capacity
(
val_map
.
len
(
)
)
;
for
(
k
v
)
in
val_map
.
into_iter
(
)
{
let
old_value
=
current
.
remove
(
&
k
)
;
if
current
.
len
(
)
>
=
MAX_ITEMS
{
return
Err
(
ErrorKind
:
:
QuotaError
(
QuotaReason
:
:
MaxItems
)
.
into
(
)
)
;
}
if
k
.
len
(
)
+
v
.
to_string
(
)
.
len
(
)
>
=
QUOTA_BYTES_PER_ITEM
{
return
Err
(
ErrorKind
:
:
QuotaError
(
QuotaReason
:
:
ItemBytes
)
.
into
(
)
)
;
}
let
change
=
StorageValueChange
{
key
:
k
.
clone
(
)
old_value
new_value
:
Some
(
v
.
clone
(
)
)
}
;
changes
.
push
(
change
)
;
current
.
insert
(
k
v
)
;
}
save_to_db
(
tx
ext_id
&
JsonValue
:
:
Object
(
current
)
)
?
;
Ok
(
changes
)
}
fn
get_keys
(
keys
:
JsonValue
)
-
>
Vec
<
(
String
Option
<
JsonValue
>
)
>
{
match
keys
{
JsonValue
:
:
String
(
s
)
=
>
vec
!
[
(
s
None
)
]
JsonValue
:
:
Array
(
keys
)
=
>
{
keys
.
iter
(
)
.
filter_map
(
|
v
|
v
.
as_str
(
)
.
map
(
|
s
|
(
s
.
to_string
(
)
None
)
)
)
.
collect
(
)
}
JsonValue
:
:
Object
(
m
)
=
>
m
.
into_iter
(
)
.
map
(
|
(
k
d
)
|
(
k
Some
(
d
)
)
)
.
collect
(
)
_
=
>
vec
!
[
]
}
}
pub
fn
get
(
conn
:
&
Connection
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
JsonValue
>
{
let
maybe_existing
=
get_from_db
(
conn
ext_id
)
?
;
let
mut
existing
=
match
maybe_existing
{
None
=
>
return
Ok
(
JsonValue
:
:
Object
(
Map
:
:
new
(
)
)
)
Some
(
v
)
=
>
v
}
;
if
keys
.
is_null
(
)
{
return
Ok
(
JsonValue
:
:
Object
(
existing
)
)
;
}
let
keys_and_defaults
=
get_keys
(
keys
)
;
let
mut
result
=
Map
:
:
with_capacity
(
keys_and_defaults
.
len
(
)
)
;
for
(
key
maybe_default
)
in
keys_and_defaults
{
if
let
Some
(
v
)
=
existing
.
remove
(
&
key
)
{
result
.
insert
(
key
v
)
;
}
else
if
let
Some
(
def
)
=
maybe_default
{
result
.
insert
(
key
def
)
;
}
}
Ok
(
JsonValue
:
:
Object
(
result
)
)
}
pub
fn
remove
(
tx
:
&
Transaction
<
'
_
>
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
mut
existing
=
match
get_from_db
(
tx
ext_id
)
?
{
None
=
>
return
Ok
(
StorageChanges
:
:
new
(
)
)
Some
(
v
)
=
>
v
}
;
let
keys_and_defs
=
get_keys
(
keys
)
;
let
mut
result
=
StorageChanges
:
:
with_capacity
(
keys_and_defs
.
len
(
)
)
;
for
(
key
_
)
in
keys_and_defs
{
if
let
Some
(
v
)
=
existing
.
remove
(
&
key
)
{
result
.
push
(
StorageValueChange
{
key
old_value
:
Some
(
v
)
new_value
:
None
}
)
;
}
}
if
!
result
.
is_empty
(
)
{
save_to_db
(
tx
ext_id
&
JsonValue
:
:
Object
(
existing
)
)
?
;
}
Ok
(
result
)
}
pub
fn
clear
(
tx
:
&
Transaction
<
'
_
>
ext_id
:
&
str
)
-
>
Result
<
StorageChanges
>
{
let
existing
=
match
get_from_db
(
tx
ext_id
)
?
{
None
=
>
return
Ok
(
StorageChanges
:
:
new
(
)
)
Some
(
v
)
=
>
v
}
;
let
mut
result
=
StorageChanges
:
:
with_capacity
(
existing
.
len
(
)
)
;
for
(
key
val
)
in
existing
.
into_iter
(
)
{
result
.
push
(
StorageValueChange
{
key
:
key
.
to_string
(
)
new_value
:
None
old_value
:
Some
(
val
)
}
)
;
}
remove_from_db
(
tx
ext_id
)
?
;
Ok
(
result
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
db
:
:
test
:
:
new_mem_db
;
use
serde_json
:
:
json
;
#
[
test
]
fn
test_serialize_storage_changes
(
)
-
>
Result
<
(
)
>
{
let
c
=
StorageChanges
{
changes
:
vec
!
[
StorageValueChange
{
key
:
"
key
"
.
to_string
(
)
old_value
:
Some
(
json
!
(
"
old
"
)
)
new_value
:
None
}
]
}
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
c
)
?
r
#
"
{
"
key
"
:
{
"
oldValue
"
:
"
old
"
}
}
"
#
)
;
let
c
=
StorageChanges
{
changes
:
vec
!
[
StorageValueChange
{
key
:
"
key
"
.
to_string
(
)
old_value
:
None
new_value
:
Some
(
json
!
(
{
"
foo
"
:
"
bar
"
}
)
)
}
]
}
;
assert_eq
!
(
serde_json
:
:
to_string
(
&
c
)
?
r
#
"
{
"
key
"
:
{
"
newValue
"
:
{
"
foo
"
:
"
bar
"
}
}
}
"
#
)
;
Ok
(
(
)
)
}
fn
make_changes
(
changes
:
&
[
(
&
str
Option
<
JsonValue
>
Option
<
JsonValue
>
)
]
)
-
>
StorageChanges
{
let
mut
r
=
StorageChanges
:
:
with_capacity
(
changes
.
len
(
)
)
;
for
(
name
old_value
new_value
)
in
changes
{
r
.
push
(
StorageValueChange
{
key
:
(
*
name
)
.
to_string
(
)
old_value
:
old_value
.
clone
(
)
new_value
:
new_value
.
clone
(
)
}
)
;
}
r
}
#
[
test
]
fn
test_simple
(
)
-
>
Result
<
(
)
>
{
let
ext_id
=
"
x
"
;
let
mut
db
=
new_mem_db
(
)
;
let
tx
=
db
.
transaction
(
)
?
;
for
q
in
vec
!
[
JsonValue
:
:
Null
json
!
(
"
foo
"
)
json
!
(
[
"
foo
"
]
)
json
!
(
{
"
foo
"
:
null
}
)
json
!
(
{
"
foo
"
:
"
default
"
}
)
]
.
into_iter
(
)
{
assert_eq
!
(
get
(
&
tx
&
ext_id
q
)
?
json
!
(
{
}
)
)
;
}
set
(
&
tx
&
ext_id
json
!
(
{
"
foo
"
:
"
bar
"
}
)
)
?
;
for
q
in
vec
!
[
JsonValue
:
:
Null
json
!
(
"
foo
"
)
json
!
(
[
"
foo
"
]
)
json
!
(
{
"
foo
"
:
null
}
)
json
!
(
{
"
foo
"
:
"
default
"
}
)
]
.
into_iter
(
)
{
assert_eq
!
(
get
(
&
tx
&
ext_id
q
)
?
json
!
(
{
"
foo
"
:
"
bar
"
}
)
)
;
}
assert_eq
!
(
set
(
&
tx
&
ext_id
json
!
(
{
"
foo
"
:
"
new
"
"
other
"
:
"
also
new
"
}
)
)
?
make_changes
(
&
[
(
"
foo
"
Some
(
json
!
(
"
bar
"
)
)
Some
(
json
!
(
"
new
"
)
)
)
(
"
other
"
None
Some
(
json
!
(
"
also
new
"
)
)
)
]
)
)
;
assert_eq
!
(
get
(
&
tx
&
ext_id
JsonValue
:
:
Null
)
?
json
!
(
{
"
foo
"
:
"
new
"
"
other
"
:
"
also
new
"
}
)
)
;
assert_eq
!
(
get
(
&
tx
&
ext_id
json
!
(
"
foo
"
)
)
?
json
!
(
{
"
foo
"
:
"
new
"
}
)
)
;
assert_eq
!
(
get
(
&
tx
&
ext_id
json
!
(
[
"
foo
"
"
other
"
]
)
)
?
json
!
(
{
"
foo
"
:
"
new
"
"
other
"
:
"
also
new
"
}
)
)
;
assert_eq
!
(
get
(
&
tx
&
ext_id
json
!
(
{
"
foo
"
:
null
"
default
"
:
"
yo
"
}
)
)
?
json
!
(
{
"
foo
"
:
"
new
"
"
default
"
:
"
yo
"
}
)
)
;
assert_eq
!
(
remove
(
&
tx
&
ext_id
json
!
(
"
foo
"
)
)
?
make_changes
(
&
[
(
"
foo
"
Some
(
json
!
(
"
new
"
)
)
None
)
]
)
)
;
assert_eq
!
(
set
(
&
tx
&
ext_id
json
!
(
{
"
foo
"
:
{
"
sub
-
object
"
:
"
sub
-
value
"
}
}
)
)
?
make_changes
(
&
[
(
"
foo
"
None
Some
(
json
!
(
{
"
sub
-
object
"
:
"
sub
-
value
"
}
)
)
)
]
)
)
;
assert_eq
!
(
clear
(
&
tx
&
ext_id
)
?
make_changes
(
&
[
(
"
foo
"
Some
(
json
!
(
{
"
sub
-
object
"
:
"
sub
-
value
"
}
)
)
None
)
(
"
other
"
Some
(
json
!
(
"
also
new
"
)
)
None
)
]
)
)
;
assert_eq
!
(
get
(
&
tx
&
ext_id
JsonValue
:
:
Null
)
?
json
!
(
{
}
)
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_check_get_impl
(
)
-
>
Result
<
(
)
>
{
let
ext_id
=
"
x
"
;
let
mut
db
=
new_mem_db
(
)
;
let
tx
=
db
.
transaction
(
)
?
;
let
prop
=
"
test
-
prop
"
;
let
value
=
"
test
-
value
"
;
set
(
&
tx
ext_id
json
!
(
{
prop
:
value
}
)
)
?
;
let
mut
data
=
get
(
&
tx
&
ext_id
json
!
(
null
)
)
?
;
assert_eq
!
(
value
json
!
(
data
[
prop
]
)
"
null
getter
worked
for
{
}
"
prop
)
;
data
=
get
(
&
tx
&
ext_id
json
!
(
prop
)
)
?
;
assert_eq
!
(
value
json
!
(
data
[
prop
]
)
"
string
getter
worked
for
{
}
"
prop
)
;
assert_eq
!
(
data
.
as_object
(
)
.
unwrap
(
)
.
len
(
)
1
"
string
getter
should
return
an
object
with
a
single
property
"
)
;
data
=
get
(
&
tx
&
ext_id
json
!
(
[
prop
]
)
)
?
;
assert_eq
!
(
value
json
!
(
data
[
prop
]
)
"
array
getter
worked
for
{
}
"
prop
)
;
assert_eq
!
(
data
.
as_object
(
)
.
unwrap
(
)
.
len
(
)
1
"
array
getter
with
a
single
key
should
return
an
object
with
a
single
property
"
)
;
data
=
get
(
&
tx
&
ext_id
json
!
(
{
prop
:
null
}
)
)
?
;
assert_eq
!
(
value
json
!
(
data
[
prop
]
)
"
object
getter
worked
for
{
}
"
prop
)
;
assert_eq
!
(
data
.
as_object
(
)
.
unwrap
(
)
.
len
(
)
1
"
object
getter
with
a
single
key
should
return
an
object
with
a
single
property
"
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_bug_1621162
(
)
-
>
Result
<
(
)
>
{
let
mut
db
=
new_mem_db
(
)
;
let
tx
=
db
.
transaction
(
)
?
;
let
ext_id
=
"
xyz
"
;
set
(
&
tx
&
ext_id
json
!
(
{
"
foo
"
:
"
bar
"
}
)
)
?
;
assert_eq
!
(
set
(
&
tx
&
ext_id
json
!
(
{
"
foo
"
:
"
bar
"
}
)
)
?
make_changes
(
&
[
(
"
foo
"
Some
(
json
!
(
"
bar
"
)
)
Some
(
json
!
(
"
bar
"
)
)
)
]
)
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_quota_maxitems
(
)
-
>
Result
<
(
)
>
{
let
mut
db
=
new_mem_db
(
)
;
let
tx
=
db
.
transaction
(
)
?
;
let
ext_id
=
"
xyz
"
;
for
i
in
1
.
.
MAX_ITEMS
+
1
{
set
(
&
tx
&
ext_id
json
!
(
{
format
!
(
"
key
-
{
}
"
i
)
:
format
!
(
"
value
-
{
}
"
i
)
}
)
)
?
;
}
let
e
=
set
(
&
tx
&
ext_id
json
!
(
{
"
another
"
:
"
another
"
}
)
)
.
unwrap_err
(
)
;
match
e
.
kind
(
)
{
ErrorKind
:
:
QuotaError
(
QuotaReason
:
:
MaxItems
)
=
>
{
}
_
=
>
panic
!
(
"
unexpected
error
type
"
)
}
;
Ok
(
(
)
)
}
#
[
test
]
fn
test_quota_bytesperitem
(
)
-
>
Result
<
(
)
>
{
let
mut
db
=
new_mem_db
(
)
;
let
tx
=
db
.
transaction
(
)
?
;
let
ext_id
=
"
xyz
"
;
let
val
=
"
x
"
.
repeat
(
QUOTA_BYTES_PER_ITEM
-
5
)
;
set
(
&
tx
&
ext_id
json
!
(
{
"
x
"
:
val
}
)
)
?
;
let
e
=
set
(
&
tx
&
ext_id
json
!
(
{
"
xxxx
"
:
val
}
)
)
.
unwrap_err
(
)
;
match
e
.
kind
(
)
{
ErrorKind
:
:
QuotaError
(
QuotaReason
:
:
ItemBytes
)
=
>
{
}
_
=
>
panic
!
(
"
unexpected
error
type
"
)
}
;
Ok
(
(
)
)
}
}
