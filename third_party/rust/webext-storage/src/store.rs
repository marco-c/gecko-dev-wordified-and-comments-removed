use
crate
:
:
api
:
:
{
self
StorageChanges
}
;
use
crate
:
:
db
:
:
StorageDb
;
use
crate
:
:
error
:
:
*
;
use
crate
:
:
migration
:
:
{
migrate
MigrationInfo
}
;
use
crate
:
:
sync
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
result
;
use
serde_json
:
:
Value
as
JsonValue
;
use
sql_support
:
:
SqlInterruptHandle
;
pub
struct
Store
{
db
:
StorageDb
}
impl
Store
{
pub
fn
new
(
db_path
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
db
:
StorageDb
:
:
new
(
db_path
)
?
}
)
}
#
[
cfg
(
test
)
]
pub
fn
new_memory
(
db_path
:
&
str
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
db
:
StorageDb
:
:
new_memory
(
db_path
)
?
}
)
}
pub
fn
interrupt_handle
(
&
self
)
-
>
SqlInterruptHandle
{
self
.
db
.
interrupt_handle
(
)
}
pub
fn
set
(
&
self
ext_id
:
&
str
val
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
set
(
&
tx
ext_id
val
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
usage
(
&
self
)
-
>
Result
<
Vec
<
crate
:
:
UsageInfo
>
>
{
api
:
:
usage
(
&
self
.
db
)
}
pub
fn
get
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
JsonValue
>
{
api
:
:
get
(
&
self
.
db
ext_id
keys
)
}
pub
fn
remove
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
remove
(
&
tx
ext_id
keys
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
clear
(
&
self
ext_id
:
&
str
)
-
>
Result
<
StorageChanges
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
clear
(
&
tx
ext_id
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
get_bytes_in_use
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
usize
>
{
api
:
:
get_bytes_in_use
(
&
self
.
db
ext_id
keys
)
}
pub
fn
bridged_engine
(
&
self
)
-
>
sync
:
:
BridgedEngine
<
'
_
>
{
sync
:
:
BridgedEngine
:
:
new
(
&
self
.
db
)
}
pub
fn
close
(
self
)
-
>
result
:
:
Result
<
(
)
(
Store
Error
)
>
{
self
.
db
.
close
(
)
.
map_err
(
|
(
db
err
)
|
(
Store
{
db
}
err
)
)
}
pub
fn
get_synced_changes
(
&
self
)
-
>
Result
<
Vec
<
sync
:
:
SyncedExtensionChange
>
>
{
sync
:
:
get_synced_changes
(
&
self
.
db
)
}
pub
fn
migrate
(
&
self
filename
:
impl
AsRef
<
Path
>
)
-
>
Result
<
(
)
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
migrate
(
&
tx
filename
.
as_ref
(
)
)
?
;
tx
.
commit
(
)
?
;
if
let
Err
(
e
)
=
result
.
store
(
&
self
.
db
)
{
debug_assert
!
(
false
"
Migration
error
:
{
:
?
}
"
e
)
;
log
:
:
warn
!
(
"
Failed
to
record
migration
telmetry
:
{
}
"
e
)
;
}
Ok
(
(
)
)
}
pub
fn
take_migration_info
(
&
self
)
-
>
Result
<
Option
<
MigrationInfo
>
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
MigrationInfo
:
:
take
(
&
tx
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
}
#
[
cfg
(
test
)
]
pub
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_send
(
)
{
fn
ensure_send
<
T
:
Send
>
(
)
{
}
ensure_send
:
:
<
Store
>
(
)
;
}
pub
fn
new_mem_store
(
)
-
>
Store
{
Store
{
db
:
crate
:
:
db
:
:
test
:
:
new_mem_db
(
)
}
}
}
