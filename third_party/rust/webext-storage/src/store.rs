use
crate
:
:
api
:
:
{
self
StorageChanges
}
;
use
crate
:
:
db
:
:
{
StorageDb
ThreadSafeStorageDb
}
;
use
crate
:
:
error
:
:
*
;
use
crate
:
:
migration
:
:
{
migrate
MigrationInfo
}
;
use
crate
:
:
sync
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
sync
:
:
Arc
;
use
interrupt_support
:
:
SqlInterruptHandle
;
use
serde_json
:
:
Value
as
JsonValue
;
pub
struct
WebExtStorageStore
{
pub
(
crate
)
db
:
Arc
<
ThreadSafeStorageDb
>
}
impl
WebExtStorageStore
{
pub
fn
new
(
db_path
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Self
>
{
let
db
=
StorageDb
:
:
new
(
db_path
)
?
;
Ok
(
Self
{
db
:
Arc
:
:
new
(
ThreadSafeStorageDb
:
:
new
(
db
)
)
}
)
}
#
[
cfg
(
test
)
]
pub
fn
new_memory
(
db_path
:
&
str
)
-
>
Result
<
Self
>
{
let
db
=
StorageDb
:
:
new_memory
(
db_path
)
?
;
Ok
(
Self
{
db
:
Arc
:
:
new
(
ThreadSafeStorageDb
:
:
new
(
db
)
)
}
)
}
pub
fn
interrupt_handle
(
&
self
)
-
>
Arc
<
SqlInterruptHandle
>
{
self
.
db
.
interrupt_handle
(
)
}
pub
fn
set
(
&
self
ext_id
:
&
str
val
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
db
=
self
.
db
.
lock
(
)
;
let
tx
=
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
set
(
&
tx
ext_id
val
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
usage
(
&
self
)
-
>
Result
<
Vec
<
crate
:
:
UsageInfo
>
>
{
let
db
=
self
.
db
.
lock
(
)
;
api
:
:
usage
(
&
db
)
}
pub
fn
get
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
JsonValue
>
{
let
db
=
self
.
db
.
lock
(
)
;
api
:
:
get
(
&
db
ext_id
keys
)
}
pub
fn
remove
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
db
=
self
.
db
.
lock
(
)
;
let
tx
=
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
remove
(
&
tx
ext_id
keys
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
clear
(
&
self
ext_id
:
&
str
)
-
>
Result
<
StorageChanges
>
{
let
db
=
self
.
db
.
lock
(
)
;
let
tx
=
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
clear
(
&
tx
ext_id
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
get_bytes_in_use
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
u64
>
{
let
db
=
self
.
db
.
lock
(
)
;
Ok
(
api
:
:
get_bytes_in_use
(
&
db
ext_id
keys
)
?
as
u64
)
}
pub
fn
close
(
self
)
-
>
Result
<
(
)
>
{
let
shared
:
ThreadSafeStorageDb
=
match
Arc
:
:
try_unwrap
(
self
.
db
)
{
Ok
(
shared
)
=
>
shared
_
=
>
{
log
:
:
warn
!
(
"
Attempting
to
close
a
store
while
other
DB
references
exist
.
"
)
;
return
Err
(
Error
:
:
OtherConnectionReferencesExist
)
;
}
}
;
let
db
=
shared
.
into_inner
(
)
;
db
.
close
(
)
}
pub
fn
get_synced_changes
(
&
self
)
-
>
Result
<
Vec
<
sync
:
:
SyncedExtensionChange
>
>
{
let
db
=
self
.
db
.
lock
(
)
;
sync
:
:
get_synced_changes
(
&
db
)
}
pub
fn
migrate
(
&
self
filename
:
impl
AsRef
<
Path
>
)
-
>
Result
<
(
)
>
{
let
db
=
self
.
db
.
lock
(
)
;
let
tx
=
db
.
unchecked_transaction
(
)
?
;
let
result
=
migrate
(
&
tx
filename
.
as_ref
(
)
)
?
;
tx
.
commit
(
)
?
;
if
let
Err
(
e
)
=
result
.
store
(
&
db
)
{
debug_assert
!
(
false
"
Migration
error
:
{
:
?
}
"
e
)
;
log
:
:
warn
!
(
"
Failed
to
record
migration
telmetry
:
{
}
"
e
)
;
}
Ok
(
(
)
)
}
pub
fn
take_migration_info
(
&
self
)
-
>
Result
<
Option
<
MigrationInfo
>
>
{
let
db
=
self
.
db
.
lock
(
)
;
let
tx
=
db
.
unchecked_transaction
(
)
?
;
let
result
=
MigrationInfo
:
:
take
(
&
tx
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
}
#
[
cfg
(
test
)
]
pub
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_send
(
)
{
fn
ensure_send
<
T
:
Send
>
(
)
{
}
ensure_send
:
:
<
WebExtStorageStore
>
(
)
;
}
pub
fn
new_mem_store
(
)
-
>
WebExtStorageStore
{
WebExtStorageStore
{
db
:
Arc
:
:
new
(
ThreadSafeStorageDb
:
:
new
(
crate
:
:
db
:
:
test
:
:
new_mem_db
(
)
)
)
}
}
}
