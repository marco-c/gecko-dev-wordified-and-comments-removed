use
crate
:
:
api
:
:
{
self
StorageChanges
}
;
use
crate
:
:
db
:
:
StorageDb
;
use
crate
:
:
error
:
:
*
;
use
crate
:
:
sync
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
result
;
use
serde_json
:
:
Value
as
JsonValue
;
use
sql_support
:
:
SqlInterruptHandle
;
pub
struct
Store
{
db
:
StorageDb
}
impl
Store
{
pub
fn
new
(
db_path
:
impl
AsRef
<
Path
>
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
db
:
StorageDb
:
:
new
(
db_path
)
?
}
)
}
#
[
cfg
(
test
)
]
pub
fn
new_memory
(
db_path
:
&
str
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
db
:
StorageDb
:
:
new_memory
(
db_path
)
?
}
)
}
pub
fn
interrupt_handle
(
&
self
)
-
>
SqlInterruptHandle
{
self
.
db
.
interrupt_handle
(
)
}
pub
fn
set
(
&
self
ext_id
:
&
str
val
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
set
(
&
tx
ext_id
val
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
get
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
JsonValue
>
{
api
:
:
get
(
&
self
.
db
ext_id
keys
)
}
pub
fn
remove
(
&
self
ext_id
:
&
str
keys
:
JsonValue
)
-
>
Result
<
StorageChanges
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
remove
(
&
tx
ext_id
keys
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
clear
(
&
self
ext_id
:
&
str
)
-
>
Result
<
StorageChanges
>
{
let
tx
=
self
.
db
.
unchecked_transaction
(
)
?
;
let
result
=
api
:
:
clear
(
&
tx
ext_id
)
?
;
tx
.
commit
(
)
?
;
Ok
(
result
)
}
pub
fn
bridged_engine
(
&
self
)
-
>
sync
:
:
BridgedEngine
<
'
_
>
{
sync
:
:
BridgedEngine
:
:
new
(
&
self
.
db
)
}
pub
fn
close
(
self
)
-
>
result
:
:
Result
<
(
)
(
Store
Error
)
>
{
self
.
db
.
close
(
)
.
map_err
(
|
(
db
err
)
|
(
Store
{
db
}
err
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_send
(
)
{
fn
ensure_send
<
T
:
Send
>
(
)
{
}
ensure_send
:
:
<
Store
>
(
)
;
}
}
