use
registry
:
:
Registry
;
use
std
:
:
io
;
#
[
allow
(
missing_copy_implementations
)
]
pub
struct
StaticGenerator
;
impl
super
:
:
Generator
for
StaticGenerator
{
fn
write
<
W
>
(
&
self
registry
:
&
Registry
dest
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
try
!
(
write_header
(
dest
)
)
;
try
!
(
write_type_aliases
(
registry
dest
)
)
;
try
!
(
write_enums
(
registry
dest
)
)
;
try
!
(
write_fns
(
registry
dest
)
)
;
Ok
(
(
)
)
}
}
fn
write_header
<
W
>
(
dest
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
writeln
!
(
dest
r
#
"
mod
__gl_imports
{
{
pub
use
std
:
:
mem
;
pub
use
std
:
:
os
:
:
raw
;
}
}
"
#
)
}
fn
write_type_aliases
<
W
>
(
registry
:
&
Registry
dest
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
try
!
(
writeln
!
(
dest
r
#
"
pub
mod
types
{
{
#
!
[
allow
(
non_camel_case_types
non_snake_case
dead_code
missing_copy_implementations
)
]
"
#
)
)
;
try
!
(
super
:
:
gen_types
(
registry
.
api
dest
)
)
;
writeln
!
(
dest
"
}
}
"
)
}
fn
write_enums
<
W
>
(
registry
:
&
Registry
dest
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
for
enm
in
&
registry
.
enums
{
try
!
(
super
:
:
gen_enum_item
(
enm
"
types
:
:
"
dest
)
)
;
}
Ok
(
(
)
)
}
fn
write_fns
<
W
>
(
registry
:
&
Registry
dest
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
where
W
:
io
:
:
Write
{
try
!
(
writeln
!
(
dest
"
#
[
allow
(
non_snake_case
unused_variables
dead_code
)
]
extern
\
"
system
\
"
{
{
"
)
)
;
for
cmd
in
&
registry
.
cmds
{
try
!
(
writeln
!
(
dest
"
#
[
link_name
=
\
"
{
symbol
}
\
"
]
pub
fn
{
name
}
(
{
params
}
)
-
>
{
return_suffix
}
;
"
symbol
=
super
:
:
gen_symbol_name
(
registry
.
api
&
cmd
.
proto
.
ident
)
name
=
cmd
.
proto
.
ident
params
=
super
:
:
gen_parameters
(
cmd
true
true
)
.
join
(
"
"
)
return_suffix
=
cmd
.
proto
.
ty
)
)
;
}
writeln
!
(
dest
"
}
}
"
)
}
