#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
arrayvec
/
0
.
4
/
"
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
cfg_attr
(
has_union_feature
feature
(
untagged_unions
)
)
]
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
extern
crate
serde
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
extern
crate
core
as
std
;
#
[
cfg
(
not
(
has_manually_drop_in_union
)
)
]
extern
crate
nodrop
;
use
std
:
:
cmp
;
use
std
:
:
iter
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
std
:
:
slice
;
use
std
:
:
borrow
:
:
{
Borrow
BorrowMut
}
;
use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
io
;
#
[
cfg
(
has_stable_maybe_uninit
)
]
#
[
path
=
"
maybe_uninit_stable
.
rs
"
]
mod
maybe_uninit
;
#
[
cfg
(
all
(
not
(
has_stable_maybe_uninit
)
has_manually_drop_in_union
)
)
]
mod
maybe_uninit
;
#
[
cfg
(
all
(
not
(
has_stable_maybe_uninit
)
not
(
has_manually_drop_in_union
)
)
)
]
#
[
path
=
"
maybe_uninit_nodrop
.
rs
"
]
mod
maybe_uninit
;
use
maybe_uninit
:
:
MaybeUninit
;
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
use
serde
:
:
{
Serialize
Deserialize
Serializer
Deserializer
}
;
mod
array
;
mod
array_string
;
mod
char
;
mod
range
;
mod
errors
;
pub
use
array
:
:
Array
;
pub
use
range
:
:
RangeArgument
;
use
array
:
:
Index
;
pub
use
array_string
:
:
ArrayString
;
pub
use
errors
:
:
CapacityError
;
pub
struct
ArrayVec
<
A
:
Array
>
{
xs
:
MaybeUninit
<
A
>
len
:
A
:
:
Index
}
impl
<
A
:
Array
>
Drop
for
ArrayVec
<
A
>
{
fn
drop
(
&
mut
self
)
{
self
.
clear
(
)
;
}
}
macro_rules
!
panic_oob
{
(
method_name
:
expr
index
:
expr
len
:
expr
)
=
>
{
panic
!
(
concat
!
(
"
ArrayVec
:
:
"
method_name
"
:
index
{
}
is
out
of
bounds
in
vector
of
length
{
}
"
)
index
len
)
}
}
impl
<
A
:
Array
>
ArrayVec
<
A
>
{
pub
fn
new
(
)
-
>
ArrayVec
<
A
>
{
unsafe
{
ArrayVec
{
xs
:
MaybeUninit
:
:
uninitialized
(
)
len
:
Index
:
:
from
(
0
)
}
}
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
.
to_usize
(
)
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
A
:
:
capacity
(
)
}
pub
fn
is_full
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
self
.
capacity
(
)
}
pub
fn
push
(
&
mut
self
element
:
A
:
:
Item
)
{
self
.
try_push
(
element
)
.
unwrap
(
)
}
pub
fn
try_push
(
&
mut
self
element
:
A
:
:
Item
)
-
>
Result
<
(
)
CapacityError
<
A
:
:
Item
>
>
{
if
self
.
len
(
)
<
A
:
:
capacity
(
)
{
unsafe
{
self
.
push_unchecked
(
element
)
;
}
Ok
(
(
)
)
}
else
{
Err
(
CapacityError
:
:
new
(
element
)
)
}
}
#
[
inline
]
pub
unsafe
fn
push_unchecked
(
&
mut
self
element
:
A
:
:
Item
)
{
let
len
=
self
.
len
(
)
;
debug_assert
!
(
len
<
A
:
:
capacity
(
)
)
;
ptr
:
:
write
(
self
.
get_unchecked_mut
(
len
)
element
)
;
self
.
set_len
(
len
+
1
)
;
}
pub
fn
insert
(
&
mut
self
index
:
usize
element
:
A
:
:
Item
)
{
self
.
try_insert
(
index
element
)
.
unwrap
(
)
}
pub
fn
try_insert
(
&
mut
self
index
:
usize
element
:
A
:
:
Item
)
-
>
Result
<
(
)
CapacityError
<
A
:
:
Item
>
>
{
if
index
>
self
.
len
(
)
{
panic_oob
!
(
"
try_insert
"
index
self
.
len
(
)
)
}
if
self
.
len
(
)
=
=
self
.
capacity
(
)
{
return
Err
(
CapacityError
:
:
new
(
element
)
)
;
}
let
len
=
self
.
len
(
)
;
unsafe
{
{
let
p
:
*
mut
_
=
self
.
get_unchecked_mut
(
index
)
;
ptr
:
:
copy
(
p
p
.
offset
(
1
)
len
-
index
)
;
ptr
:
:
write
(
p
element
)
;
}
self
.
set_len
(
len
+
1
)
;
}
Ok
(
(
)
)
}
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
A
:
:
Item
>
{
if
self
.
len
(
)
=
=
0
{
return
None
}
unsafe
{
let
new_len
=
self
.
len
(
)
-
1
;
self
.
set_len
(
new_len
)
;
Some
(
ptr
:
:
read
(
self
.
get_unchecked_mut
(
new_len
)
)
)
}
}
pub
fn
swap_remove
(
&
mut
self
index
:
usize
)
-
>
A
:
:
Item
{
self
.
swap_pop
(
index
)
.
unwrap_or_else
(
|
|
{
panic_oob
!
(
"
swap_remove
"
index
self
.
len
(
)
)
}
)
}
pub
fn
swap_pop
(
&
mut
self
index
:
usize
)
-
>
Option
<
A
:
:
Item
>
{
let
len
=
self
.
len
(
)
;
if
index
>
=
len
{
return
None
;
}
self
.
swap
(
index
len
-
1
)
;
self
.
pop
(
)
}
pub
fn
remove
(
&
mut
self
index
:
usize
)
-
>
A
:
:
Item
{
self
.
pop_at
(
index
)
.
unwrap_or_else
(
|
|
{
panic_oob
!
(
"
remove
"
index
self
.
len
(
)
)
}
)
}
pub
fn
pop_at
(
&
mut
self
index
:
usize
)
-
>
Option
<
A
:
:
Item
>
{
if
index
>
=
self
.
len
(
)
{
None
}
else
{
self
.
drain
(
index
.
.
index
+
1
)
.
next
(
)
}
}
pub
fn
truncate
(
&
mut
self
len
:
usize
)
{
while
self
.
len
(
)
>
len
{
self
.
pop
(
)
;
}
}
pub
fn
clear
(
&
mut
self
)
{
while
let
Some
(
_
)
=
self
.
pop
(
)
{
}
}
pub
fn
retain
<
F
>
(
&
mut
self
mut
f
:
F
)
where
F
:
FnMut
(
&
mut
A
:
:
Item
)
-
>
bool
{
let
len
=
self
.
len
(
)
;
let
mut
del
=
0
;
{
let
v
=
&
mut
*
*
self
;
for
i
in
0
.
.
len
{
if
!
f
(
&
mut
v
[
i
]
)
{
del
+
=
1
;
}
else
if
del
>
0
{
v
.
swap
(
i
-
del
i
)
;
}
}
}
if
del
>
0
{
self
.
drain
(
len
-
del
.
.
)
;
}
}
#
[
inline
]
pub
unsafe
fn
set_len
(
&
mut
self
length
:
usize
)
{
debug_assert
!
(
length
<
=
self
.
capacity
(
)
)
;
self
.
len
=
Index
:
:
from
(
length
)
;
}
pub
fn
drain
<
R
:
RangeArgument
>
(
&
mut
self
range
:
R
)
-
>
Drain
<
A
>
{
let
len
=
self
.
len
(
)
;
let
start
=
range
.
start
(
)
.
unwrap_or
(
0
)
;
let
end
=
range
.
end
(
)
.
unwrap_or
(
len
)
;
let
range_slice
:
*
const
_
=
&
self
[
start
.
.
end
]
;
unsafe
{
self
.
set_len
(
start
)
;
Drain
{
tail_start
:
end
tail_len
:
len
-
end
iter
:
(
*
range_slice
)
.
iter
(
)
vec
:
self
as
*
mut
_
}
}
}
pub
fn
into_inner
(
self
)
-
>
Result
<
A
Self
>
{
if
self
.
len
(
)
<
self
.
capacity
(
)
{
Err
(
self
)
}
else
{
unsafe
{
let
array
=
ptr
:
:
read
(
self
.
xs
.
ptr
(
)
as
*
const
A
)
;
mem
:
:
forget
(
self
)
;
Ok
(
array
)
}
}
}
pub
fn
dispose
(
mut
self
)
{
self
.
clear
(
)
;
mem
:
:
forget
(
self
)
;
}
pub
fn
as_slice
(
&
self
)
-
>
&
[
A
:
:
Item
]
{
self
}
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
A
:
:
Item
]
{
self
}
}
impl
<
A
:
Array
>
Deref
for
ArrayVec
<
A
>
{
type
Target
=
[
A
:
:
Item
]
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
[
A
:
:
Item
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
xs
.
ptr
(
)
self
.
len
(
)
)
}
}
}
impl
<
A
:
Array
>
DerefMut
for
ArrayVec
<
A
>
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
A
:
:
Item
]
{
let
len
=
self
.
len
(
)
;
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
xs
.
ptr_mut
(
)
len
)
}
}
}
impl
<
A
:
Array
>
From
<
A
>
for
ArrayVec
<
A
>
{
fn
from
(
array
:
A
)
-
>
Self
{
ArrayVec
{
xs
:
MaybeUninit
:
:
from
(
array
)
len
:
Index
:
:
from
(
A
:
:
capacity
(
)
)
}
}
}
impl
<
'
a
A
:
Array
>
IntoIterator
for
&
'
a
ArrayVec
<
A
>
{
type
Item
=
&
'
a
A
:
:
Item
;
type
IntoIter
=
slice
:
:
Iter
<
'
a
A
:
:
Item
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter
(
)
}
}
impl
<
'
a
A
:
Array
>
IntoIterator
for
&
'
a
mut
ArrayVec
<
A
>
{
type
Item
=
&
'
a
mut
A
:
:
Item
;
type
IntoIter
=
slice
:
:
IterMut
<
'
a
A
:
:
Item
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter_mut
(
)
}
}
impl
<
A
:
Array
>
IntoIterator
for
ArrayVec
<
A
>
{
type
Item
=
A
:
:
Item
;
type
IntoIter
=
IntoIter
<
A
>
;
fn
into_iter
(
self
)
-
>
IntoIter
<
A
>
{
IntoIter
{
index
:
Index
:
:
from
(
0
)
v
:
self
}
}
}
pub
struct
IntoIter
<
A
:
Array
>
{
index
:
A
:
:
Index
v
:
ArrayVec
<
A
>
}
impl
<
A
:
Array
>
Iterator
for
IntoIter
<
A
>
{
type
Item
=
A
:
:
Item
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
A
:
:
Item
>
{
if
self
.
index
=
=
self
.
v
.
len
{
None
}
else
{
unsafe
{
let
index
=
self
.
index
.
to_usize
(
)
;
self
.
index
=
Index
:
:
from
(
index
+
1
)
;
Some
(
ptr
:
:
read
(
self
.
v
.
get_unchecked_mut
(
index
)
)
)
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
len
=
self
.
v
.
len
(
)
-
self
.
index
.
to_usize
(
)
;
(
len
Some
(
len
)
)
}
}
impl
<
A
:
Array
>
DoubleEndedIterator
for
IntoIter
<
A
>
{
#
[
inline
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
A
:
:
Item
>
{
if
self
.
index
=
=
self
.
v
.
len
{
None
}
else
{
unsafe
{
let
new_len
=
self
.
v
.
len
(
)
-
1
;
self
.
v
.
set_len
(
new_len
)
;
Some
(
ptr
:
:
read
(
self
.
v
.
get_unchecked_mut
(
new_len
)
)
)
}
}
}
}
impl
<
A
:
Array
>
ExactSizeIterator
for
IntoIter
<
A
>
{
}
impl
<
A
:
Array
>
Drop
for
IntoIter
<
A
>
{
fn
drop
(
&
mut
self
)
{
let
index
=
self
.
index
.
to_usize
(
)
;
let
len
=
self
.
v
.
len
(
)
;
unsafe
{
self
.
v
.
set_len
(
0
)
;
let
elements
=
slice
:
:
from_raw_parts_mut
(
self
.
v
.
get_unchecked_mut
(
index
)
len
-
index
)
;
ptr
:
:
drop_in_place
(
elements
)
;
}
}
}
impl
<
A
:
Array
>
Clone
for
IntoIter
<
A
>
where
A
:
:
Item
:
Clone
{
fn
clone
(
&
self
)
-
>
IntoIter
<
A
>
{
self
.
v
[
self
.
index
.
to_usize
(
)
.
.
]
.
iter
(
)
.
cloned
(
)
.
collect
:
:
<
ArrayVec
<
A
>
>
(
)
.
into_iter
(
)
}
}
impl
<
A
:
Array
>
fmt
:
:
Debug
for
IntoIter
<
A
>
where
A
:
:
Item
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_list
(
)
.
entries
(
&
self
.
v
[
self
.
index
.
to_usize
(
)
.
.
]
)
.
finish
(
)
}
}
pub
struct
Drain
<
'
a
A
>
where
A
:
Array
A
:
:
Item
:
'
a
{
tail_start
:
usize
tail_len
:
usize
iter
:
slice
:
:
Iter
<
'
a
A
:
:
Item
>
vec
:
*
mut
ArrayVec
<
A
>
}
unsafe
impl
<
'
a
A
:
Array
+
Sync
>
Sync
for
Drain
<
'
a
A
>
{
}
unsafe
impl
<
'
a
A
:
Array
+
Send
>
Send
for
Drain
<
'
a
A
>
{
}
impl
<
'
a
A
:
Array
>
Iterator
for
Drain
<
'
a
A
>
where
A
:
:
Item
:
'
a
{
type
Item
=
A
:
:
Item
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
.
map
(
|
elt
|
unsafe
{
ptr
:
:
read
(
elt
as
*
const
_
)
}
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
'
a
A
:
Array
>
DoubleEndedIterator
for
Drain
<
'
a
A
>
where
A
:
:
Item
:
'
a
{
#
[
inline
]
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next_back
(
)
.
map
(
|
elt
|
unsafe
{
ptr
:
:
read
(
elt
as
*
const
_
)
}
)
}
}
impl
<
'
a
A
:
Array
>
ExactSizeIterator
for
Drain
<
'
a
A
>
where
A
:
:
Item
:
'
a
{
}
impl
<
'
a
A
:
Array
>
Drop
for
Drain
<
'
a
A
>
where
A
:
:
Item
:
'
a
{
fn
drop
(
&
mut
self
)
{
while
let
Some
(
_
)
=
self
.
next
(
)
{
}
if
self
.
tail_len
>
0
{
unsafe
{
let
source_vec
=
&
mut
*
self
.
vec
;
let
start
=
source_vec
.
len
(
)
;
let
tail
=
self
.
tail_start
;
let
src
=
source_vec
.
as_ptr
(
)
.
offset
(
tail
as
isize
)
;
let
dst
=
source_vec
.
as_mut_ptr
(
)
.
offset
(
start
as
isize
)
;
ptr
:
:
copy
(
src
dst
self
.
tail_len
)
;
source_vec
.
set_len
(
start
+
self
.
tail_len
)
;
}
}
}
}
struct
ScopeExitGuard
<
T
Data
F
>
where
F
:
FnMut
(
&
Data
&
mut
T
)
{
value
:
T
data
:
Data
f
:
F
}
impl
<
T
Data
F
>
Drop
for
ScopeExitGuard
<
T
Data
F
>
where
F
:
FnMut
(
&
Data
&
mut
T
)
{
fn
drop
(
&
mut
self
)
{
(
self
.
f
)
(
&
self
.
data
&
mut
self
.
value
)
}
}
impl
<
A
:
Array
>
Extend
<
A
:
:
Item
>
for
ArrayVec
<
A
>
{
fn
extend
<
T
:
IntoIterator
<
Item
=
A
:
:
Item
>
>
(
&
mut
self
iter
:
T
)
{
let
take
=
self
.
capacity
(
)
-
self
.
len
(
)
;
unsafe
{
let
len
=
self
.
len
(
)
;
let
mut
ptr
=
self
.
as_mut_ptr
(
)
.
offset
(
len
as
isize
)
;
let
mut
guard
=
ScopeExitGuard
{
value
:
self
data
:
len
f
:
|
&
len
self_
|
{
self_
.
set_len
(
len
)
}
}
;
for
elt
in
iter
.
into_iter
(
)
.
take
(
take
)
{
ptr
:
:
write
(
ptr
elt
)
;
ptr
=
ptr
.
offset
(
1
)
;
guard
.
data
+
=
1
;
}
}
}
}
impl
<
A
:
Array
>
iter
:
:
FromIterator
<
A
:
:
Item
>
for
ArrayVec
<
A
>
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
A
:
:
Item
>
>
(
iter
:
T
)
-
>
Self
{
let
mut
array
=
ArrayVec
:
:
new
(
)
;
array
.
extend
(
iter
)
;
array
}
}
impl
<
A
:
Array
>
Clone
for
ArrayVec
<
A
>
where
A
:
:
Item
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
self
.
iter
(
)
.
cloned
(
)
.
collect
(
)
}
fn
clone_from
(
&
mut
self
rhs
:
&
Self
)
{
let
prefix
=
cmp
:
:
min
(
self
.
len
(
)
rhs
.
len
(
)
)
;
self
[
.
.
prefix
]
.
clone_from_slice
(
&
rhs
[
.
.
prefix
]
)
;
if
prefix
<
self
.
len
(
)
{
for
_
in
0
.
.
self
.
len
(
)
-
prefix
{
self
.
pop
(
)
;
}
}
else
{
let
rhs_elems
=
rhs
[
self
.
len
(
)
.
.
]
.
iter
(
)
.
cloned
(
)
;
self
.
extend
(
rhs_elems
)
;
}
}
}
impl
<
A
:
Array
>
Hash
for
ArrayVec
<
A
>
where
A
:
:
Item
:
Hash
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
Hash
:
:
hash
(
&
*
*
self
state
)
}
}
impl
<
A
:
Array
>
PartialEq
for
ArrayVec
<
A
>
where
A
:
:
Item
:
PartialEq
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
*
*
self
=
=
*
*
other
}
}
impl
<
A
:
Array
>
PartialEq
<
[
A
:
:
Item
]
>
for
ArrayVec
<
A
>
where
A
:
:
Item
:
PartialEq
{
fn
eq
(
&
self
other
:
&
[
A
:
:
Item
]
)
-
>
bool
{
*
*
self
=
=
*
other
}
}
impl
<
A
:
Array
>
Eq
for
ArrayVec
<
A
>
where
A
:
:
Item
:
Eq
{
}
impl
<
A
:
Array
>
Borrow
<
[
A
:
:
Item
]
>
for
ArrayVec
<
A
>
{
fn
borrow
(
&
self
)
-
>
&
[
A
:
:
Item
]
{
self
}
}
impl
<
A
:
Array
>
BorrowMut
<
[
A
:
:
Item
]
>
for
ArrayVec
<
A
>
{
fn
borrow_mut
(
&
mut
self
)
-
>
&
mut
[
A
:
:
Item
]
{
self
}
}
impl
<
A
:
Array
>
AsRef
<
[
A
:
:
Item
]
>
for
ArrayVec
<
A
>
{
fn
as_ref
(
&
self
)
-
>
&
[
A
:
:
Item
]
{
self
}
}
impl
<
A
:
Array
>
AsMut
<
[
A
:
:
Item
]
>
for
ArrayVec
<
A
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
[
A
:
:
Item
]
{
self
}
}
impl
<
A
:
Array
>
fmt
:
:
Debug
for
ArrayVec
<
A
>
where
A
:
:
Item
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
(
*
*
self
)
.
fmt
(
f
)
}
}
impl
<
A
:
Array
>
Default
for
ArrayVec
<
A
>
{
fn
default
(
)
-
>
ArrayVec
<
A
>
{
ArrayVec
:
:
new
(
)
}
}
impl
<
A
:
Array
>
PartialOrd
for
ArrayVec
<
A
>
where
A
:
:
Item
:
PartialOrd
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
ArrayVec
<
A
>
)
-
>
Option
<
cmp
:
:
Ordering
>
{
(
*
*
self
)
.
partial_cmp
(
other
)
}
#
[
inline
]
fn
lt
(
&
self
other
:
&
Self
)
-
>
bool
{
(
*
*
self
)
.
lt
(
other
)
}
#
[
inline
]
fn
le
(
&
self
other
:
&
Self
)
-
>
bool
{
(
*
*
self
)
.
le
(
other
)
}
#
[
inline
]
fn
ge
(
&
self
other
:
&
Self
)
-
>
bool
{
(
*
*
self
)
.
ge
(
other
)
}
#
[
inline
]
fn
gt
(
&
self
other
:
&
Self
)
-
>
bool
{
(
*
*
self
)
.
gt
(
other
)
}
}
impl
<
A
:
Array
>
Ord
for
ArrayVec
<
A
>
where
A
:
:
Item
:
Ord
{
fn
cmp
(
&
self
other
:
&
ArrayVec
<
A
>
)
-
>
cmp
:
:
Ordering
{
(
*
*
self
)
.
cmp
(
other
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
A
:
Array
<
Item
=
u8
>
>
io
:
:
Write
for
ArrayVec
<
A
>
{
fn
write
(
&
mut
self
data
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
unsafe
{
let
len
=
self
.
len
(
)
;
let
mut
tail
=
slice
:
:
from_raw_parts_mut
(
self
.
get_unchecked_mut
(
len
)
A
:
:
capacity
(
)
-
len
)
;
let
result
=
tail
.
write
(
data
)
;
if
let
Ok
(
written
)
=
result
{
self
.
set_len
(
len
+
written
)
;
}
result
}
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
impl
<
T
:
Serialize
A
:
Array
<
Item
=
T
>
>
Serialize
for
ArrayVec
<
A
>
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
collect_seq
(
self
)
}
}
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
impl
<
'
de
T
:
Deserialize
<
'
de
>
A
:
Array
<
Item
=
T
>
>
Deserialize
<
'
de
>
for
ArrayVec
<
A
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
use
serde
:
:
de
:
:
{
Visitor
SeqAccess
Error
}
;
use
std
:
:
marker
:
:
PhantomData
;
struct
ArrayVecVisitor
<
'
de
T
:
Deserialize
<
'
de
>
A
:
Array
<
Item
=
T
>
>
(
PhantomData
<
(
&
'
de
(
)
T
A
)
>
)
;
impl
<
'
de
T
:
Deserialize
<
'
de
>
A
:
Array
<
Item
=
T
>
>
Visitor
<
'
de
>
for
ArrayVecVisitor
<
'
de
T
A
>
{
type
Value
=
ArrayVec
<
A
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
an
array
with
no
more
than
{
}
items
"
A
:
:
capacity
(
)
)
}
fn
visit_seq
<
SA
>
(
self
mut
seq
:
SA
)
-
>
Result
<
Self
:
:
Value
SA
:
:
Error
>
where
SA
:
SeqAccess
<
'
de
>
{
let
mut
values
=
ArrayVec
:
:
<
A
>
:
:
new
(
)
;
while
let
Some
(
value
)
=
try
!
(
seq
.
next_element
(
)
)
{
if
let
Err
(
_
)
=
values
.
try_push
(
value
)
{
return
Err
(
SA
:
:
Error
:
:
invalid_length
(
A
:
:
capacity
(
)
+
1
&
self
)
)
;
}
}
Ok
(
values
)
}
}
deserializer
.
deserialize_seq
(
ArrayVecVisitor
:
:
<
T
A
>
(
PhantomData
)
)
}
}
