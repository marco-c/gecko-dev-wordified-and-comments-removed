#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
want
/
0
.
0
.
6
"
)
]
#
!
[
deny
(
warnings
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
deny
(
missing_debug_implementations
)
]
extern
crate
futures
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
try_lock
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
use
futures
:
:
{
Async
Poll
}
;
use
futures
:
:
task
:
:
{
self
Task
}
;
use
try_lock
:
:
TryLock
;
pub
fn
new
(
)
-
>
(
Giver
Taker
)
{
let
inner
=
Arc
:
:
new
(
Inner
{
state
:
AtomicUsize
:
:
new
(
State
:
:
Idle
.
into
(
)
)
task
:
TryLock
:
:
new
(
None
)
}
)
;
let
inner2
=
inner
.
clone
(
)
;
(
Giver
{
inner
:
inner
}
Taker
{
inner
:
inner2
}
)
}
pub
struct
Giver
{
inner
:
Arc
<
Inner
>
}
pub
struct
Taker
{
inner
:
Arc
<
Inner
>
}
#
[
derive
(
Clone
)
]
pub
struct
SharedGiver
{
inner
:
Arc
<
Inner
>
}
pub
struct
Closed
{
_inner
:
(
)
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
State
{
Idle
Want
Give
Closed
}
impl
From
<
State
>
for
usize
{
fn
from
(
s
:
State
)
-
>
usize
{
match
s
{
State
:
:
Idle
=
>
0
State
:
:
Want
=
>
1
State
:
:
Give
=
>
2
State
:
:
Closed
=
>
3
}
}
}
impl
From
<
usize
>
for
State
{
fn
from
(
num
:
usize
)
-
>
State
{
match
num
{
0
=
>
State
:
:
Idle
1
=
>
State
:
:
Want
2
=
>
State
:
:
Give
3
=
>
State
:
:
Closed
_
=
>
unreachable
!
(
"
unknown
state
:
{
}
"
num
)
}
}
}
struct
Inner
{
state
:
AtomicUsize
task
:
TryLock
<
Option
<
Task
>
>
}
impl
Giver
{
pub
fn
poll_want
(
&
mut
self
)
-
>
Poll
<
(
)
Closed
>
{
loop
{
let
state
=
self
.
inner
.
state
.
load
(
SeqCst
)
.
into
(
)
;
match
state
{
State
:
:
Want
=
>
{
trace
!
(
"
poll_want
:
taker
wants
!
"
)
;
return
Ok
(
Async
:
:
Ready
(
(
)
)
)
;
}
State
:
:
Closed
=
>
{
trace
!
(
"
poll_want
:
closed
"
)
;
return
Err
(
Closed
{
_inner
:
(
)
}
)
;
}
State
:
:
Idle
|
State
:
:
Give
=
>
{
if
let
Some
(
mut
locked
)
=
self
.
inner
.
task
.
try_lock_order
(
SeqCst
SeqCst
)
{
let
old
=
self
.
inner
.
state
.
compare_and_swap
(
state
.
into
(
)
State
:
:
Give
.
into
(
)
SeqCst
)
;
if
old
=
=
state
.
into
(
)
{
let
park
=
locked
.
as_ref
(
)
.
map
(
|
t
|
!
t
.
will_notify_current
(
)
)
.
unwrap_or
(
true
)
;
if
park
{
let
old
=
mem
:
:
replace
(
&
mut
*
locked
Some
(
task
:
:
current
(
)
)
)
;
drop
(
locked
)
;
old
.
map
(
|
prev_task
|
{
prev_task
.
notify
(
)
;
}
)
;
}
return
Ok
(
Async
:
:
NotReady
)
}
}
else
{
}
}
}
}
}
#
[
inline
]
pub
fn
give
(
&
self
)
-
>
bool
{
self
.
inner
.
state
.
compare_and_swap
(
State
:
:
Want
.
into
(
)
State
:
:
Idle
.
into
(
)
SeqCst
)
=
=
State
:
:
Want
.
into
(
)
}
#
[
inline
]
pub
fn
is_wanting
(
&
self
)
-
>
bool
{
self
.
inner
.
state
.
load
(
SeqCst
)
=
=
State
:
:
Want
.
into
(
)
}
#
[
inline
]
pub
fn
is_canceled
(
&
self
)
-
>
bool
{
self
.
inner
.
state
.
load
(
SeqCst
)
=
=
State
:
:
Closed
.
into
(
)
}
#
[
inline
]
pub
fn
shared
(
self
)
-
>
SharedGiver
{
SharedGiver
{
inner
:
self
.
inner
}
}
}
impl
fmt
:
:
Debug
for
Giver
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Giver
"
)
.
field
(
"
state
"
&
self
.
inner
.
state
(
)
)
.
finish
(
)
}
}
impl
SharedGiver
{
#
[
inline
]
pub
fn
is_wanting
(
&
self
)
-
>
bool
{
self
.
inner
.
state
.
load
(
SeqCst
)
=
=
State
:
:
Want
.
into
(
)
}
#
[
inline
]
pub
fn
is_canceled
(
&
self
)
-
>
bool
{
self
.
inner
.
state
.
load
(
SeqCst
)
=
=
State
:
:
Closed
.
into
(
)
}
}
impl
fmt
:
:
Debug
for
SharedGiver
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
SharedGiver
"
)
.
field
(
"
state
"
&
self
.
inner
.
state
(
)
)
.
finish
(
)
}
}
impl
Taker
{
#
[
inline
]
pub
fn
cancel
(
&
mut
self
)
{
trace
!
(
"
signal
:
{
:
?
}
"
State
:
:
Closed
)
;
self
.
signal
(
State
:
:
Closed
)
}
#
[
inline
]
pub
fn
want
(
&
mut
self
)
{
debug_assert
!
(
self
.
inner
.
state
.
load
(
SeqCst
)
!
=
State
:
:
Closed
.
into
(
)
"
want
called
after
cancel
"
)
;
trace
!
(
"
signal
:
{
:
?
}
"
State
:
:
Want
)
;
self
.
signal
(
State
:
:
Want
)
}
#
[
inline
]
fn
signal
(
&
mut
self
state
:
State
)
{
let
old_state
=
self
.
inner
.
state
.
swap
(
state
.
into
(
)
SeqCst
)
.
into
(
)
;
match
old_state
{
State
:
:
Idle
|
State
:
:
Want
|
State
:
:
Closed
=
>
(
)
State
:
:
Give
=
>
{
loop
{
if
let
Some
(
mut
locked
)
=
self
.
inner
.
task
.
try_lock_order
(
SeqCst
SeqCst
)
{
if
let
Some
(
task
)
=
locked
.
take
(
)
{
drop
(
locked
)
;
trace
!
(
"
signal
found
waiting
giver
notifying
"
)
;
task
.
notify
(
)
;
}
return
;
}
else
{
}
}
}
}
}
}
impl
Drop
for
Taker
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
self
.
signal
(
State
:
:
Closed
)
;
}
}
impl
fmt
:
:
Debug
for
Taker
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Taker
"
)
.
field
(
"
state
"
&
self
.
inner
.
state
(
)
)
.
finish
(
)
}
}
impl
fmt
:
:
Debug
for
Closed
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Closed
"
)
.
finish
(
)
}
}
impl
Inner
{
#
[
inline
]
fn
state
(
&
self
)
-
>
State
{
self
.
state
.
load
(
SeqCst
)
.
into
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
thread
;
use
futures
:
:
{
Async
Stream
}
;
use
futures
:
:
future
:
:
{
poll_fn
Future
}
;
use
futures
:
:
sync
:
:
{
mpsc
oneshot
}
;
use
super
:
:
*
;
#
[
test
]
fn
want_ready
(
)
{
let
(
mut
gv
mut
tk
)
=
new
(
)
;
tk
.
want
(
)
;
assert
!
(
gv
.
poll_want
(
)
.
unwrap
(
)
.
is_ready
(
)
)
;
}
#
[
test
]
fn
want_notify_0
(
)
{
let
(
mut
gv
mut
tk
)
=
new
(
)
;
let
(
tx
rx
)
=
oneshot
:
:
channel
(
)
;
thread
:
:
spawn
(
move
|
|
{
tk
.
want
(
)
;
rx
.
wait
(
)
.
expect
(
"
rx
"
)
;
}
)
;
poll_fn
(
|
|
{
gv
.
poll_want
(
)
}
)
.
wait
(
)
.
expect
(
"
wait
"
)
;
assert
!
(
gv
.
is_wanting
(
)
"
still
wanting
after
poll_want
success
"
)
;
assert
!
(
gv
.
give
(
)
"
give
is
true
when
wanting
"
)
;
assert
!
(
!
gv
.
is_wanting
(
)
"
no
longer
wanting
after
give
"
)
;
assert
!
(
!
gv
.
is_canceled
(
)
"
give
doesn
'
t
cancel
"
)
;
assert
!
(
!
gv
.
give
(
)
"
give
is
false
if
not
wanting
"
)
;
tx
.
send
(
(
)
)
.
expect
(
"
tx
"
)
;
}
#
[
test
]
fn
want_notify_moving_tasks
(
)
{
use
std
:
:
sync
:
:
Arc
;
use
futures
:
:
executor
:
:
{
spawn
Notify
NotifyHandle
}
;
struct
WantNotify
;
impl
Notify
for
WantNotify
{
fn
notify
(
&
self
_id
:
usize
)
{
}
}
fn
n
(
)
-
>
NotifyHandle
{
Arc
:
:
new
(
WantNotify
)
.
into
(
)
}
let
(
mut
gv
mut
tk
)
=
new
(
)
;
let
mut
s
=
spawn
(
poll_fn
(
move
|
|
{
gv
.
poll_want
(
)
}
)
)
;
let
t1
=
n
(
)
;
assert
!
(
s
.
poll_future_notify
(
&
t1
1
)
.
unwrap
(
)
.
is_not_ready
(
)
)
;
thread
:
:
spawn
(
move
|
|
{
thread
:
:
sleep
(
:
:
std
:
:
time
:
:
Duration
:
:
from_millis
(
100
)
)
;
tk
.
want
(
)
;
}
)
;
s
.
into_inner
(
)
.
wait
(
)
.
expect
(
"
poll_want
"
)
;
}
#
[
test
]
fn
cancel
(
)
{
let
(
mut
gv
mut
tk
)
=
new
(
)
;
assert
!
(
!
gv
.
is_canceled
(
)
)
;
tk
.
cancel
(
)
;
assert
!
(
gv
.
is_canceled
(
)
)
;
assert
!
(
gv
.
poll_want
(
)
.
is_err
(
)
)
;
let
(
mut
gv
tk
)
=
new
(
)
;
assert
!
(
!
gv
.
is_canceled
(
)
)
;
drop
(
tk
)
;
assert
!
(
gv
.
is_canceled
(
)
)
;
assert
!
(
gv
.
poll_want
(
)
.
is_err
(
)
)
;
let
(
mut
gv
tk
)
=
new
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
_tk
=
tk
;
}
)
;
poll_fn
(
move
|
|
{
gv
.
poll_want
(
)
}
)
.
wait
(
)
.
expect_err
(
"
wait
"
)
;
}
#
[
test
]
fn
stress
(
)
{
let
nthreads
=
5
;
let
nwants
=
100
;
for
_
in
0
.
.
nthreads
{
let
(
mut
gv
mut
tk
)
=
new
(
)
;
let
(
mut
tx
mut
rx
)
=
mpsc
:
:
channel
(
0
)
;
thread
:
:
spawn
(
move
|
|
{
let
mut
cnt
=
0
;
poll_fn
(
move
|
|
{
while
cnt
<
nwants
{
let
n
=
match
rx
.
poll
(
)
.
expect
(
"
rx
poll
"
)
{
Async
:
:
Ready
(
n
)
=
>
n
.
expect
(
"
rx
opt
"
)
Async
:
:
NotReady
=
>
{
tk
.
want
(
)
;
return
Ok
(
Async
:
:
NotReady
)
;
}
}
;
assert_eq
!
(
cnt
n
)
;
cnt
+
=
1
;
}
Ok
:
:
<
_
(
)
>
(
Async
:
:
Ready
(
(
)
)
)
}
)
.
wait
(
)
.
expect
(
"
rx
wait
"
)
;
}
)
;
thread
:
:
spawn
(
move
|
|
{
let
mut
cnt
=
0
;
let
nsent
=
poll_fn
(
move
|
|
{
loop
{
while
let
Ok
(
(
)
)
=
tx
.
try_send
(
cnt
)
{
cnt
+
=
1
;
}
match
gv
.
poll_want
(
)
{
Ok
(
Async
:
:
Ready
(
_
)
)
=
>
(
)
Ok
(
Async
:
:
NotReady
)
=
>
return
Ok
:
:
<
_
(
)
>
(
Async
:
:
NotReady
)
Err
(
_
)
=
>
return
Ok
(
Async
:
:
Ready
(
cnt
)
)
}
}
}
)
.
wait
(
)
.
expect
(
"
tx
wait
"
)
;
assert_eq
!
(
nsent
nwants
)
;
}
)
.
join
(
)
.
expect
(
"
thread
join
"
)
;
}
}
}
