#
!
[
deny
(
missing_debug_implementations
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
allow
(
unknown_lints
)
]
#
!
[
allow
(
bare_trait_objects
)
]
#
!
[
allow
(
ellipsis_inclusive_range_patterns
)
]
macro_rules
!
try
{
(
result
:
expr
)
=
>
{
match
result
{
Ok
(
value
)
=
>
value
Err
(
error
)
=
>
return
Err
(
error
)
}
}
;
}
use
std
:
:
env
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fs
;
use
std
:
:
io
:
:
{
stderr
Write
}
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
process
:
:
{
Command
Stdio
}
;
#
[
allow
(
deprecated
)
]
use
std
:
:
sync
:
:
atomic
:
:
ATOMIC_USIZE_INIT
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
mod
error
;
pub
use
error
:
:
Error
;
mod
version
;
use
version
:
:
Version
;
#
[
cfg
(
test
)
]
mod
tests
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
AutoCfg
{
out_dir
:
PathBuf
rustc
:
PathBuf
rustc_version
:
Version
target
:
Option
<
OsString
>
no_std
:
bool
rustflags
:
Vec
<
String
>
}
pub
fn
emit
(
cfg
:
&
str
)
{
println
!
(
"
cargo
:
rustc
-
cfg
=
{
}
"
cfg
)
;
}
pub
fn
rerun_path
(
path
:
&
str
)
{
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
{
}
"
path
)
;
}
pub
fn
rerun_env
(
var
:
&
str
)
{
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
{
}
"
var
)
;
}
pub
fn
new
(
)
-
>
AutoCfg
{
AutoCfg
:
:
new
(
)
.
unwrap
(
)
}
impl
AutoCfg
{
pub
fn
new
(
)
-
>
Result
<
Self
Error
>
{
match
env
:
:
var_os
(
"
OUT_DIR
"
)
{
Some
(
d
)
=
>
Self
:
:
with_dir
(
d
)
None
=
>
Err
(
error
:
:
from_str
(
"
no
OUT_DIR
specified
!
"
)
)
}
}
pub
fn
with_dir
<
T
:
Into
<
PathBuf
>
>
(
dir
:
T
)
-
>
Result
<
Self
Error
>
{
let
rustc
=
env
:
:
var_os
(
"
RUSTC
"
)
.
unwrap_or_else
(
|
|
"
rustc
"
.
into
(
)
)
;
let
rustc
:
PathBuf
=
rustc
.
into
(
)
;
let
rustc_version
=
try
!
(
Version
:
:
from_rustc
(
&
rustc
)
)
;
let
target
=
env
:
:
var_os
(
"
TARGET
"
)
;
let
dir
=
dir
.
into
(
)
;
let
meta
=
try
!
(
fs
:
:
metadata
(
&
dir
)
.
map_err
(
error
:
:
from_io
)
)
;
if
!
meta
.
is_dir
(
)
|
|
meta
.
permissions
(
)
.
readonly
(
)
{
return
Err
(
error
:
:
from_str
(
"
output
path
is
not
a
writable
directory
"
)
)
;
}
let
mut
ac
=
AutoCfg
{
rustflags
:
rustflags
(
&
target
&
dir
)
out_dir
:
dir
rustc
:
rustc
rustc_version
:
rustc_version
target
:
target
no_std
:
false
}
;
if
!
ac
.
probe
(
"
"
)
.
unwrap_or
(
false
)
{
ac
.
no_std
=
true
;
if
!
ac
.
probe
(
"
"
)
.
unwrap_or
(
false
)
{
ac
.
no_std
=
false
;
let
warning
=
b
"
warning
:
autocfg
could
not
probe
for
std
\
n
"
;
stderr
(
)
.
write_all
(
warning
)
.
ok
(
)
;
}
}
Ok
(
ac
)
}
pub
fn
probe_rustc_version
(
&
self
major
:
usize
minor
:
usize
)
-
>
bool
{
self
.
rustc_version
>
=
Version
:
:
new
(
major
minor
0
)
}
pub
fn
emit_rustc_version
(
&
self
major
:
usize
minor
:
usize
)
{
if
self
.
probe_rustc_version
(
major
minor
)
{
emit
(
&
format
!
(
"
rustc_
{
}
_
{
}
"
major
minor
)
)
;
}
}
fn
probe
<
T
:
AsRef
<
[
u8
]
>
>
(
&
self
code
:
T
)
-
>
Result
<
bool
Error
>
{
#
[
allow
(
deprecated
)
]
static
ID
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
let
id
=
ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
let
mut
command
=
Command
:
:
new
(
&
self
.
rustc
)
;
command
.
arg
(
"
-
-
crate
-
name
"
)
.
arg
(
format
!
(
"
probe
{
}
"
id
)
)
.
arg
(
"
-
-
crate
-
type
=
lib
"
)
.
arg
(
"
-
-
out
-
dir
"
)
.
arg
(
&
self
.
out_dir
)
.
arg
(
"
-
-
emit
=
llvm
-
ir
"
)
;
if
let
Some
(
target
)
=
self
.
target
.
as_ref
(
)
{
command
.
arg
(
"
-
-
target
"
)
.
arg
(
target
)
;
}
command
.
args
(
&
self
.
rustflags
)
;
command
.
arg
(
"
-
"
)
.
stdin
(
Stdio
:
:
piped
(
)
)
.
stderr
(
Stdio
:
:
null
(
)
)
;
let
mut
child
=
try
!
(
command
.
spawn
(
)
.
map_err
(
error
:
:
from_io
)
)
;
let
mut
stdin
=
child
.
stdin
.
take
(
)
.
expect
(
"
rustc
stdin
"
)
;
if
self
.
no_std
{
try
!
(
stdin
.
write_all
(
b
"
#
!
[
no_std
]
\
n
"
)
.
map_err
(
error
:
:
from_io
)
)
;
}
try
!
(
stdin
.
write_all
(
code
.
as_ref
(
)
)
.
map_err
(
error
:
:
from_io
)
)
;
drop
(
stdin
)
;
let
status
=
try
!
(
child
.
wait
(
)
.
map_err
(
error
:
:
from_io
)
)
;
Ok
(
status
.
success
(
)
)
}
pub
fn
probe_sysroot_crate
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
probe
(
format
!
(
"
extern
crate
{
}
as
probe
;
"
name
)
)
.
unwrap_or
(
false
)
}
pub
fn
emit_sysroot_crate
(
&
self
name
:
&
str
)
{
if
self
.
probe_sysroot_crate
(
name
)
{
emit
(
&
format
!
(
"
has_
{
}
"
mangle
(
name
)
)
)
;
}
}
pub
fn
probe_path
(
&
self
path
:
&
str
)
-
>
bool
{
self
.
probe
(
format
!
(
"
pub
use
{
}
;
"
path
)
)
.
unwrap_or
(
false
)
}
pub
fn
emit_has_path
(
&
self
path
:
&
str
)
{
if
self
.
probe_path
(
path
)
{
emit
(
&
format
!
(
"
has_
{
}
"
mangle
(
path
)
)
)
;
}
}
pub
fn
emit_path_cfg
(
&
self
path
:
&
str
cfg
:
&
str
)
{
if
self
.
probe_path
(
path
)
{
emit
(
cfg
)
;
}
}
pub
fn
probe_trait
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
probe
(
format
!
(
"
pub
trait
Probe
:
{
}
+
Sized
{
{
}
}
"
name
)
)
.
unwrap_or
(
false
)
}
pub
fn
emit_has_trait
(
&
self
name
:
&
str
)
{
if
self
.
probe_trait
(
name
)
{
emit
(
&
format
!
(
"
has_
{
}
"
mangle
(
name
)
)
)
;
}
}
pub
fn
emit_trait_cfg
(
&
self
name
:
&
str
cfg
:
&
str
)
{
if
self
.
probe_trait
(
name
)
{
emit
(
cfg
)
;
}
}
pub
fn
probe_type
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
probe
(
format
!
(
"
pub
type
Probe
=
{
}
;
"
name
)
)
.
unwrap_or
(
false
)
}
pub
fn
emit_has_type
(
&
self
name
:
&
str
)
{
if
self
.
probe_type
(
name
)
{
emit
(
&
format
!
(
"
has_
{
}
"
mangle
(
name
)
)
)
;
}
}
pub
fn
emit_type_cfg
(
&
self
name
:
&
str
cfg
:
&
str
)
{
if
self
.
probe_type
(
name
)
{
emit
(
cfg
)
;
}
}
pub
fn
probe_expression
(
&
self
expr
:
&
str
)
-
>
bool
{
self
.
probe
(
format
!
(
"
pub
fn
probe
(
)
{
{
let
_
=
{
}
;
}
}
"
expr
)
)
.
unwrap_or
(
false
)
}
pub
fn
emit_expression_cfg
(
&
self
expr
:
&
str
cfg
:
&
str
)
{
if
self
.
probe_expression
(
expr
)
{
emit
(
cfg
)
;
}
}
pub
fn
probe_constant
(
&
self
expr
:
&
str
)
-
>
bool
{
self
.
probe
(
format
!
(
"
pub
const
PROBE
:
(
)
=
(
(
)
{
}
)
.
0
;
"
expr
)
)
.
unwrap_or
(
false
)
}
pub
fn
emit_constant_cfg
(
&
self
expr
:
&
str
cfg
:
&
str
)
{
if
self
.
probe_constant
(
expr
)
{
emit
(
cfg
)
;
}
}
}
fn
mangle
(
s
:
&
str
)
-
>
String
{
s
.
chars
(
)
.
map
(
|
c
|
match
c
{
'
A
'
.
.
.
'
Z
'
|
'
a
'
.
.
.
'
z
'
|
'
0
'
.
.
.
'
9
'
=
>
c
_
=
>
'
_
'
}
)
.
collect
(
)
}
fn
dir_contains_target
(
target
:
&
Option
<
OsString
>
dir
:
&
Path
cargo_target_dir
:
Option
<
OsString
>
)
-
>
bool
{
target
.
as_ref
(
)
.
and_then
(
|
target
|
{
dir
.
to_str
(
)
.
and_then
(
|
dir
|
{
let
mut
cargo_target_dir
=
cargo_target_dir
.
map
(
PathBuf
:
:
from
)
.
unwrap_or_else
(
|
|
PathBuf
:
:
from
(
"
target
"
)
)
;
cargo_target_dir
.
push
(
target
)
;
cargo_target_dir
.
to_str
(
)
.
map
(
|
cargo_target_dir
|
dir
.
contains
(
&
cargo_target_dir
)
)
}
)
}
)
.
unwrap_or
(
false
)
}
fn
rustflags
(
target
:
&
Option
<
OsString
>
dir
:
&
Path
)
-
>
Vec
<
String
>
{
if
let
Ok
(
a
)
=
env
:
:
var
(
"
CARGO_ENCODED_RUSTFLAGS
"
)
{
return
if
a
.
is_empty
(
)
{
Vec
:
:
new
(
)
}
else
{
a
.
split
(
'
\
x1f
'
)
.
map
(
str
:
:
to_string
)
.
collect
(
)
}
;
}
if
*
target
!
=
env
:
:
var_os
(
"
HOST
"
)
|
|
dir_contains_target
(
target
dir
env
:
:
var_os
(
"
CARGO_TARGET_DIR
"
)
)
{
if
let
Ok
(
rustflags
)
=
env
:
:
var
(
"
RUSTFLAGS
"
)
{
return
rustflags
.
split
(
'
'
)
.
map
(
str
:
:
trim
)
.
filter
(
|
s
|
!
s
.
is_empty
(
)
)
.
map
(
str
:
:
to_string
)
.
collect
(
)
;
}
}
Vec
:
:
new
(
)
}
