use
core
:
:
ffi
:
:
c_void
;
use
core
:
:
mem
;
use
libc
:
:
c_int
;
#
[
derive
(
Clone
)
]
pub
struct
Frame
{
addr
:
usize
}
impl
Frame
{
pub
fn
ip
(
&
self
)
-
>
*
mut
c_void
{
self
.
addr
as
*
mut
c_void
}
pub
fn
symbol_address
(
&
self
)
-
>
*
mut
c_void
{
self
.
ip
(
)
}
}
extern
"
C
"
{
fn
backtrace
(
buf
:
*
mut
*
mut
c_void
sz
:
c_int
)
-
>
c_int
;
}
#
[
inline
(
always
)
]
pub
unsafe
fn
trace
(
cb
:
&
mut
FnMut
(
&
super
:
:
Frame
)
-
>
bool
)
{
const
SIZE
:
usize
=
100
;
let
mut
buf
:
[
*
mut
c_void
;
SIZE
]
;
let
cnt
;
buf
=
mem
:
:
zeroed
(
)
;
cnt
=
backtrace
(
buf
.
as_mut_ptr
(
)
SIZE
as
c_int
)
;
for
addr
in
buf
[
.
.
cnt
as
usize
]
.
iter
(
)
{
let
cx
=
super
:
:
Frame
{
inner
:
Frame
{
addr
:
*
addr
as
usize
}
}
;
if
!
cb
(
&
cx
)
{
return
;
}
}
}
