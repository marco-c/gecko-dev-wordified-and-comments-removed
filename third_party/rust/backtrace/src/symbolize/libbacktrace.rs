#
!
[
allow
(
bad_style
)
]
extern
crate
backtrace_sys
as
bt
;
use
libc
:
:
uintptr_t
;
use
std
:
:
ffi
:
:
{
CStr
OsStr
}
;
use
std
:
:
os
:
:
raw
:
:
{
c_void
c_char
c_int
}
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
{
ONCE_INIT
Once
}
;
use
SymbolName
;
pub
enum
Symbol
{
Syminfo
{
pc
:
uintptr_t
symname
:
*
const
c_char
}
Pcinfo
{
pc
:
uintptr_t
filename
:
*
const
c_char
lineno
:
c_int
function
:
*
const
c_char
}
}
impl
Symbol
{
pub
fn
name
(
&
self
)
-
>
Option
<
SymbolName
>
{
let
ptr
=
match
*
self
{
Symbol
:
:
Syminfo
{
symname
.
.
}
=
>
symname
Symbol
:
:
Pcinfo
{
function
.
.
}
=
>
function
}
;
if
ptr
.
is_null
(
)
{
None
}
else
{
Some
(
SymbolName
:
:
new
(
unsafe
{
CStr
:
:
from_ptr
(
ptr
)
.
to_bytes
(
)
}
)
)
}
}
pub
fn
addr
(
&
self
)
-
>
Option
<
*
mut
c_void
>
{
let
pc
=
match
*
self
{
Symbol
:
:
Syminfo
{
pc
.
.
}
=
>
pc
Symbol
:
:
Pcinfo
{
pc
.
.
}
=
>
pc
}
;
if
pc
=
=
0
{
None
}
else
{
Some
(
pc
as
*
mut
_
)
}
}
pub
fn
filename
(
&
self
)
-
>
Option
<
&
Path
>
{
match
*
self
{
Symbol
:
:
Syminfo
{
.
.
}
=
>
None
Symbol
:
:
Pcinfo
{
filename
.
.
}
=
>
{
Some
(
Path
:
:
new
(
OsStr
:
:
from_bytes
(
unsafe
{
CStr
:
:
from_ptr
(
filename
)
.
to_bytes
(
)
}
)
)
)
}
}
}
pub
fn
lineno
(
&
self
)
-
>
Option
<
u32
>
{
match
*
self
{
Symbol
:
:
Syminfo
{
.
.
}
=
>
None
Symbol
:
:
Pcinfo
{
lineno
.
.
}
=
>
Some
(
lineno
as
u32
)
}
}
}
extern
fn
error_cb
(
_data
:
*
mut
c_void
_msg
:
*
const
c_char
_errnum
:
c_int
)
{
}
extern
fn
syminfo_cb
(
data
:
*
mut
c_void
pc
:
uintptr_t
symname
:
*
const
c_char
_symval
:
uintptr_t
_symsize
:
uintptr_t
)
{
unsafe
{
call
(
data
&
super
:
:
Symbol
{
inner
:
Symbol
:
:
Syminfo
{
pc
:
pc
symname
:
symname
}
}
)
;
}
}
extern
fn
pcinfo_cb
(
data
:
*
mut
c_void
pc
:
uintptr_t
filename
:
*
const
c_char
lineno
:
c_int
function
:
*
const
c_char
)
-
>
c_int
{
unsafe
{
if
filename
.
is_null
(
)
|
|
function
.
is_null
(
)
{
return
-
1
}
call
(
data
&
super
:
:
Symbol
{
inner
:
Symbol
:
:
Pcinfo
{
pc
:
pc
filename
:
filename
lineno
:
lineno
function
:
function
}
}
)
;
return
0
}
}
unsafe
fn
call
(
data
:
*
mut
c_void
sym
:
&
super
:
:
Symbol
)
{
let
cb
=
data
as
*
mut
&
mut
FnMut
(
&
super
:
:
Symbol
)
;
let
mut
bomb
=
:
:
Bomb
{
enabled
:
true
}
;
(
*
cb
)
(
sym
)
;
bomb
.
enabled
=
false
;
}
unsafe
fn
init_state
(
)
-
>
*
mut
bt
:
:
backtrace_state
{
static
mut
STATE
:
*
mut
bt
:
:
backtrace_state
=
0
as
*
mut
_
;
static
INIT
:
Once
=
ONCE_INIT
;
INIT
.
call_once
(
|
|
{
STATE
=
bt
:
:
backtrace_create_state
(
ptr
:
:
null
(
)
0
error_cb
ptr
:
:
null_mut
(
)
)
;
}
)
;
STATE
}
pub
fn
resolve
(
symaddr
:
*
mut
c_void
mut
cb
:
&
mut
FnMut
(
&
super
:
:
Symbol
)
)
{
let
_guard
=
:
:
lock
:
:
lock
(
)
;
unsafe
{
let
state
=
init_state
(
)
;
if
state
.
is_null
(
)
{
return
}
let
ret
=
bt
:
:
backtrace_pcinfo
(
state
symaddr
as
uintptr_t
pcinfo_cb
error_cb
&
mut
cb
as
*
mut
_
as
*
mut
_
)
;
if
ret
!
=
0
{
bt
:
:
backtrace_syminfo
(
state
symaddr
as
uintptr_t
syminfo_cb
error_cb
&
mut
cb
as
*
mut
_
as
*
mut
_
)
;
}
}
}
