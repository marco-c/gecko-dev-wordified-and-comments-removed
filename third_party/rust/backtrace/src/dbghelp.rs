#
!
[
allow
(
non_snake_case
)
]
use
crate
:
:
windows
:
:
*
;
use
core
:
:
mem
;
use
core
:
:
ptr
;
#
[
cfg
(
feature
=
"
verify
-
winapi
"
)
]
mod
dbghelp
{
use
crate
:
:
windows
:
:
*
;
pub
use
winapi
:
:
um
:
:
dbghelp
:
:
{
StackWalk64
SymCleanup
SymFromAddrW
SymFunctionTableAccess64
SymGetLineFromAddrW64
SymGetModuleBase64
SymInitializeW
}
;
extern
"
system
"
{
pub
fn
SymGetOptions
(
)
-
>
u32
;
pub
fn
SymSetOptions
(
_
:
u32
)
;
pub
fn
StackWalkEx
(
MachineType
:
DWORD
hProcess
:
HANDLE
hThread
:
HANDLE
StackFrame
:
LPSTACKFRAME_EX
ContextRecord
:
PVOID
ReadMemoryRoutine
:
PREAD_PROCESS_MEMORY_ROUTINE64
FunctionTableAccessRoutine
:
PFUNCTION_TABLE_ACCESS_ROUTINE64
GetModuleBaseRoutine
:
PGET_MODULE_BASE_ROUTINE64
TranslateAddress
:
PTRANSLATE_ADDRESS_ROUTINE64
Flags
:
DWORD
)
-
>
BOOL
;
pub
fn
SymFromInlineContextW
(
hProcess
:
HANDLE
Address
:
DWORD64
InlineContext
:
ULONG
Displacement
:
PDWORD64
Symbol
:
PSYMBOL_INFOW
)
-
>
BOOL
;
pub
fn
SymGetLineFromInlineContextW
(
hProcess
:
HANDLE
dwAddr
:
DWORD64
InlineContext
:
ULONG
qwModuleBaseAddress
:
DWORD64
pdwDisplacement
:
PDWORD
Line
:
PIMAGEHLP_LINEW64
)
-
>
BOOL
;
}
pub
fn
assert_equal_types
<
T
>
(
a
:
T
_b
:
T
)
-
>
T
{
a
}
}
macro_rules
!
dbghelp
{
(
extern
"
system
"
{
(
fn
name
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
)
-
>
ret
:
ty
;
)
*
}
)
=
>
(
pub
struct
Dbghelp
{
/
/
/
The
loaded
DLL
for
dbghelp
.
dll
dll
:
HMODULE
/
/
Each
function
pointer
for
each
function
we
might
use
(
name
:
usize
)
*
}
static
mut
DBGHELP
:
Dbghelp
=
Dbghelp
{
/
/
Initially
we
haven
'
t
loaded
the
DLL
dll
:
0
as
*
mut
_
/
/
Initiall
all
functions
are
set
to
zero
to
say
they
need
to
be
/
/
dynamically
loaded
.
(
name
:
0
)
*
}
;
/
/
Convenience
typedef
for
each
function
type
.
(
pub
type
name
=
unsafe
extern
"
system
"
fn
(
(
argty
)
*
)
-
>
ret
;
)
*
impl
Dbghelp
{
/
/
/
Attempts
to
open
dbghelp
.
dll
.
Returns
success
if
it
works
or
/
/
/
error
if
LoadLibraryW
fails
.
/
/
/
/
/
/
Panics
if
library
is
already
loaded
.
fn
ensure_open
(
&
mut
self
)
-
>
Result
<
(
)
(
)
>
{
if
!
self
.
dll
.
is_null
(
)
{
return
Ok
(
(
)
)
}
let
lib
=
b
"
dbghelp
.
dll
\
0
"
;
unsafe
{
self
.
dll
=
LoadLibraryA
(
lib
.
as_ptr
(
)
as
*
const
i8
)
;
if
self
.
dll
.
is_null
(
)
{
Err
(
(
)
)
}
else
{
Ok
(
(
)
)
}
}
}
/
/
Function
for
each
method
we
'
d
like
to
use
.
When
called
it
will
/
/
either
read
the
cached
function
pointer
or
load
it
and
return
the
/
/
loaded
value
.
Loads
are
asserted
to
succeed
.
(
pub
fn
name
(
&
mut
self
)
-
>
Option
<
name
>
{
unsafe
{
if
self
.
name
=
=
0
{
let
name
=
concat
!
(
stringify
!
(
name
)
"
\
0
"
)
;
self
.
name
=
self
.
symbol
(
name
.
as_bytes
(
)
)
?
;
}
let
ret
=
mem
:
:
transmute
:
:
<
usize
name
>
(
self
.
name
)
;
#
[
cfg
(
feature
=
"
verify
-
winapi
"
)
]
dbghelp
:
:
assert_equal_types
(
ret
dbghelp
:
:
name
)
;
Some
(
ret
)
}
}
)
*
fn
symbol
(
&
self
symbol
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe
{
match
GetProcAddress
(
self
.
dll
symbol
.
as_ptr
(
)
as
*
const
_
)
as
usize
{
0
=
>
None
n
=
>
Some
(
n
)
}
}
}
}
/
/
Convenience
proxy
to
use
the
cleanup
locks
to
reference
dbghelp
/
/
functions
.
#
[
allow
(
dead_code
)
]
impl
Init
{
(
pub
fn
name
(
&
self
)
-
>
name
{
unsafe
{
DBGHELP
.
name
(
)
.
unwrap
(
)
}
}
)
*
pub
fn
dbghelp
(
&
self
)
-
>
*
mut
Dbghelp
{
unsafe
{
&
mut
DBGHELP
}
}
}
)
}
const
SYMOPT_DEFERRED_LOADS
:
DWORD
=
0x00000004
;
dbghelp
!
{
extern
"
system
"
{
fn
SymGetOptions
(
)
-
>
DWORD
;
fn
SymSetOptions
(
options
:
DWORD
)
-
>
(
)
;
fn
SymInitializeW
(
handle
:
HANDLE
path
:
PCWSTR
invade
:
BOOL
)
-
>
BOOL
;
fn
SymCleanup
(
handle
:
HANDLE
)
-
>
BOOL
;
fn
StackWalk64
(
MachineType
:
DWORD
hProcess
:
HANDLE
hThread
:
HANDLE
StackFrame
:
LPSTACKFRAME64
ContextRecord
:
PVOID
ReadMemoryRoutine
:
PREAD_PROCESS_MEMORY_ROUTINE64
FunctionTableAccessRoutine
:
PFUNCTION_TABLE_ACCESS_ROUTINE64
GetModuleBaseRoutine
:
PGET_MODULE_BASE_ROUTINE64
TranslateAddress
:
PTRANSLATE_ADDRESS_ROUTINE64
)
-
>
BOOL
;
fn
SymFunctionTableAccess64
(
hProcess
:
HANDLE
AddrBase
:
DWORD64
)
-
>
PVOID
;
fn
SymGetModuleBase64
(
hProcess
:
HANDLE
AddrBase
:
DWORD64
)
-
>
DWORD64
;
fn
SymFromAddrW
(
hProcess
:
HANDLE
Address
:
DWORD64
Displacement
:
PDWORD64
Symbol
:
PSYMBOL_INFOW
)
-
>
BOOL
;
fn
SymGetLineFromAddrW64
(
hProcess
:
HANDLE
dwAddr
:
DWORD64
pdwDisplacement
:
PDWORD
Line
:
PIMAGEHLP_LINEW64
)
-
>
BOOL
;
fn
StackWalkEx
(
MachineType
:
DWORD
hProcess
:
HANDLE
hThread
:
HANDLE
StackFrame
:
LPSTACKFRAME_EX
ContextRecord
:
PVOID
ReadMemoryRoutine
:
PREAD_PROCESS_MEMORY_ROUTINE64
FunctionTableAccessRoutine
:
PFUNCTION_TABLE_ACCESS_ROUTINE64
GetModuleBaseRoutine
:
PGET_MODULE_BASE_ROUTINE64
TranslateAddress
:
PTRANSLATE_ADDRESS_ROUTINE64
Flags
:
DWORD
)
-
>
BOOL
;
fn
SymFromInlineContextW
(
hProcess
:
HANDLE
Address
:
DWORD64
InlineContext
:
ULONG
Displacement
:
PDWORD64
Symbol
:
PSYMBOL_INFOW
)
-
>
BOOL
;
fn
SymGetLineFromInlineContextW
(
hProcess
:
HANDLE
dwAddr
:
DWORD64
InlineContext
:
ULONG
qwModuleBaseAddress
:
DWORD64
pdwDisplacement
:
PDWORD
Line
:
PIMAGEHLP_LINEW64
)
-
>
BOOL
;
}
}
pub
struct
Init
{
lock
:
HANDLE
}
#
[
cfg
(
all
(
windows
feature
=
"
dbghelp
"
)
)
]
pub
fn
init
(
)
-
>
Result
<
Init
(
)
>
{
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
:
:
SeqCst
}
;
unsafe
{
static
LOCK
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
let
mut
lock
=
LOCK
.
load
(
SeqCst
)
;
if
lock
=
=
0
{
lock
=
CreateMutexA
(
ptr
:
:
null_mut
(
)
0
"
Local
\
\
RustBacktraceMutex
\
0
"
.
as_ptr
(
)
as
_
)
as
usize
;
if
lock
=
=
0
{
return
Err
(
(
)
)
;
}
if
let
Err
(
other
)
=
LOCK
.
compare_exchange
(
0
lock
SeqCst
SeqCst
)
{
debug_assert
!
(
other
!
=
0
)
;
CloseHandle
(
lock
as
HANDLE
)
;
lock
=
other
;
}
}
debug_assert
!
(
lock
!
=
0
)
;
let
lock
=
lock
as
HANDLE
;
let
r
=
WaitForSingleObjectEx
(
lock
INFINITE
FALSE
)
;
debug_assert_eq
!
(
r
0
)
;
let
ret
=
Init
{
lock
}
;
DBGHELP
.
ensure_open
(
)
?
;
static
mut
INITIALIZED
:
bool
=
false
;
if
INITIALIZED
{
return
Ok
(
ret
)
;
}
let
orig
=
DBGHELP
.
SymGetOptions
(
)
.
unwrap
(
)
(
)
;
DBGHELP
.
SymSetOptions
(
)
.
unwrap
(
)
(
orig
|
SYMOPT_DEFERRED_LOADS
)
;
DBGHELP
.
SymInitializeW
(
)
.
unwrap
(
)
(
GetCurrentProcess
(
)
ptr
:
:
null_mut
(
)
TRUE
)
;
INITIALIZED
=
true
;
Ok
(
ret
)
}
}
impl
Drop
for
Init
{
fn
drop
(
&
mut
self
)
{
unsafe
{
let
r
=
ReleaseMutex
(
self
.
lock
)
;
debug_assert
!
(
r
!
=
0
)
;
}
}
}
