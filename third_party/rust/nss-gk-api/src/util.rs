use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
os
:
:
raw
:
:
c_uint
;
use
std
:
:
ptr
:
:
null_mut
;
use
crate
:
:
prtypes
:
:
*
;
use
crate
:
:
nss_prelude
:
:
*
;
macro_rules
!
scoped_ptr
{
(
name
:
ident
target
:
ty
dtor
:
path
)
=
>
{
pub
struct
name
{
ptr
:
*
mut
target
}
impl
name
{
/
/
/
Create
a
new
instance
of
name
from
a
pointer
.
/
/
/
/
/
/
#
Errors
/
/
/
When
passed
a
null
pointer
generates
an
error
.
pub
unsafe
fn
from_ptr
(
raw
:
*
mut
target
)
-
>
Result
<
Self
crate
:
:
err
:
:
Error
>
{
let
ptr
=
crate
:
:
err
:
:
into_result
(
raw
)
?
;
Ok
(
Self
{
ptr
}
)
}
}
impl
crate
:
:
err
:
:
IntoResult
for
*
mut
target
{
type
Ok
=
name
;
unsafe
fn
into_result
(
self
)
-
>
Result
<
Self
:
:
Ok
crate
:
:
err
:
:
Error
>
{
name
:
:
from_ptr
(
self
)
}
}
impl
std
:
:
ops
:
:
Deref
for
name
{
type
Target
=
*
mut
target
;
#
[
must_use
]
fn
deref
(
&
self
)
-
>
&
*
mut
target
{
&
self
.
ptr
}
}
/
/
Original
implements
DerefMut
but
is
that
really
a
good
idea
?
impl
Drop
for
name
{
fn
drop
(
&
mut
self
)
{
unsafe
{
dtor
(
self
.
ptr
)
}
;
}
}
}
}
macro_rules
!
impl_clone
{
(
name
:
ty
nss_fn
:
path
)
=
>
{
impl
Clone
for
name
{
#
[
must_use
]
fn
clone
(
&
self
)
-
>
Self
{
let
ptr
=
unsafe
{
nss_fn
(
self
.
ptr
)
}
;
assert
!
(
!
ptr
.
is_null
(
)
)
;
Self
{
ptr
}
}
}
}
}
impl
SECItem
{
pub
unsafe
fn
as_slice
<
'
a
>
(
&
self
)
-
>
&
'
a
[
u8
]
{
assert_eq
!
(
self
.
type_
SECItemType
:
:
siBuffer
)
;
if
self
.
len
!
=
0
{
std
:
:
slice
:
:
from_raw_parts
(
self
.
data
usize
:
:
try_from
(
self
.
len
)
.
unwrap
(
)
)
}
else
{
&
[
]
}
}
}
unsafe
fn
destroy_secitem
(
item
:
*
mut
SECItem
)
{
SECITEM_FreeItem
(
item
PRBool
:
:
from
(
true
)
)
;
}
scoped_ptr
!
(
ScopedSECItem
SECItem
destroy_secitem
)
;
impl
ScopedSECItem
{
pub
unsafe
fn
into_vec
(
self
)
-
>
Vec
<
u8
>
{
let
b
=
self
.
ptr
.
as_ref
(
)
.
unwrap
(
)
;
assert_eq
!
(
b
.
type_
SECItemType
:
:
siBuffer
)
;
let
slc
=
std
:
:
slice
:
:
from_raw_parts
(
b
.
data
usize
:
:
try_from
(
b
.
len
)
.
unwrap
(
)
)
;
Vec
:
:
from
(
slc
)
}
}
#
[
repr
(
transparent
)
]
pub
struct
SECItemMut
{
inner
:
SECItem
}
impl
<
'
a
>
Drop
for
SECItemMut
{
#
[
allow
(
unused_must_use
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
SECITEM_FreeItem
(
&
mut
self
.
inner
PRBool
:
:
from
(
false
)
)
}
;
}
}
impl
AsRef
<
SECItem
>
for
SECItemMut
{
fn
as_ref
(
&
self
)
-
>
&
SECItem
{
&
self
.
inner
}
}
impl
AsMut
<
SECItem
>
for
SECItemMut
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
SECItem
{
&
mut
self
.
inner
}
}
impl
SECItemMut
{
pub
fn
as_slice
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
self
.
inner
.
as_slice
(
)
}
}
pub
fn
make_empty
(
)
-
>
SECItemMut
{
SECItemMut
{
inner
:
SECItem
{
type_
:
SECItemType
:
:
siBuffer
data
:
null_mut
(
)
len
:
0
}
}
}
}
#
[
repr
(
transparent
)
]
pub
struct
SECItemBorrowed
<
'
a
>
{
inner
:
SECItem
phantom_data
:
PhantomData
<
&
'
a
u8
>
}
impl
<
'
a
>
AsRef
<
SECItem
>
for
SECItemBorrowed
<
'
a
>
{
fn
as_ref
(
&
self
)
-
>
&
SECItem
{
&
self
.
inner
}
}
impl
<
'
a
>
AsMut
<
SECItem
>
for
SECItemBorrowed
<
'
a
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
SECItem
{
&
mut
self
.
inner
}
}
impl
<
'
a
>
SECItemBorrowed
<
'
a
>
{
pub
fn
as_slice
(
&
self
)
-
>
&
'
a
[
u8
]
{
unsafe
{
self
.
inner
.
as_slice
(
)
}
}
pub
fn
make_empty
(
)
-
>
SECItemBorrowed
<
'
a
>
{
SECItemBorrowed
{
inner
:
SECItem
{
type_
:
SECItemType
:
:
siBuffer
data
:
null_mut
(
)
len
:
0
}
phantom_data
:
PhantomData
}
}
pub
fn
wrap
(
buf
:
&
'
a
[
u8
]
)
-
>
SECItemBorrowed
<
'
a
>
{
SECItemBorrowed
{
inner
:
SECItem
{
type_
:
SECItemType
:
:
siBuffer
data
:
buf
.
as_ptr
(
)
as
*
mut
u8
len
:
c_uint
:
:
try_from
(
buf
.
len
(
)
)
.
unwrap
(
)
}
phantom_data
:
PhantomData
}
}
pub
fn
wrap_struct
<
T
>
(
v
:
&
'
a
T
)
-
>
SECItemBorrowed
<
'
a
>
{
SECItemBorrowed
{
inner
:
SECItem
{
type_
:
SECItemType
:
:
siBuffer
data
:
(
v
as
*
const
T
as
*
mut
T
)
.
cast
(
)
len
:
c_uint
:
:
try_from
(
mem
:
:
size_of
:
:
<
T
>
(
)
)
.
unwrap
(
)
}
phantom_data
:
PhantomData
}
}
}
