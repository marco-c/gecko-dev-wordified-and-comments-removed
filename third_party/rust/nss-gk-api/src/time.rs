#
!
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
use
crate
:
:
nss_prelude
:
:
PRInt64
;
use
crate
:
:
err
:
:
{
Error
Res
}
;
use
once_cell
:
:
sync
:
:
OnceCell
;
use
std
:
:
convert
:
:
{
TryFrom
TryInto
}
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
nspr_time
.
rs
"
)
)
;
#
[
derive
(
Debug
)
]
struct
TimeZero
{
instant
:
Instant
prtime
:
PRTime
}
impl
TimeZero
{
pub
fn
baseline
(
t
:
Instant
)
-
>
Self
{
let
now
=
Instant
:
:
now
(
)
;
let
prnow
=
unsafe
{
PR_Now
(
)
}
;
if
now
<
=
t
{
Self
{
instant
:
now
prtime
:
prnow
}
}
else
{
let
elapsed
=
Interval
:
:
from
(
now
.
duration_since
(
now
)
)
;
let
prelapsed
:
PRTime
=
elapsed
.
try_into
(
)
.
unwrap
(
)
;
Self
{
instant
:
t
prtime
:
prnow
.
checked_sub
(
prelapsed
)
.
unwrap
(
)
}
}
}
}
static
BASE_TIME
:
OnceCell
<
TimeZero
>
=
OnceCell
:
:
new
(
)
;
fn
get_base
(
)
-
>
&
'
static
TimeZero
{
BASE_TIME
.
get_or_init
(
|
|
TimeZero
{
instant
:
Instant
:
:
now
(
)
prtime
:
unsafe
{
PR_Now
(
)
}
}
)
}
pub
fn
init
(
)
{
let
_
=
get_base
(
)
;
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
struct
Time
{
t
:
Instant
}
impl
Deref
for
Time
{
type
Target
=
Instant
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
t
}
}
impl
From
<
Instant
>
for
Time
{
fn
from
(
t
:
Instant
)
-
>
Self
{
BASE_TIME
.
get_or_init
(
|
|
TimeZero
:
:
baseline
(
t
)
)
;
Self
{
t
}
}
}
impl
TryFrom
<
PRTime
>
for
Time
{
type
Error
=
Error
;
fn
try_from
(
prtime
:
PRTime
)
-
>
Res
<
Self
>
{
let
base
=
get_base
(
)
;
if
let
Some
(
delta
)
=
prtime
.
checked_sub
(
base
.
prtime
)
{
let
d
=
Duration
:
:
from_micros
(
delta
.
try_into
(
)
?
)
;
base
.
instant
.
checked_add
(
d
)
.
map_or
(
Err
(
Error
:
:
TimeTravelError
)
|
t
|
Ok
(
Self
{
t
}
)
)
}
else
{
Err
(
Error
:
:
TimeTravelError
)
}
}
}
impl
TryInto
<
PRTime
>
for
Time
{
type
Error
=
Error
;
fn
try_into
(
self
)
-
>
Res
<
PRTime
>
{
let
base
=
get_base
(
)
;
let
delta
=
self
.
t
.
checked_duration_since
(
base
.
instant
)
.
ok_or
(
Error
:
:
TimeTravelError
)
?
;
if
let
Ok
(
d
)
=
PRTime
:
:
try_from
(
delta
.
as_micros
(
)
)
{
d
.
checked_add
(
base
.
prtime
)
.
ok_or
(
Error
:
:
TimeTravelError
)
}
else
{
Err
(
Error
:
:
TimeTravelError
)
}
}
}
impl
From
<
Time
>
for
Instant
{
#
[
must_use
]
fn
from
(
t
:
Time
)
-
>
Self
{
t
.
t
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
struct
Interval
{
d
:
Duration
}
impl
Deref
for
Interval
{
type
Target
=
Duration
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
d
}
}
impl
TryFrom
<
PRTime
>
for
Interval
{
type
Error
=
Error
;
fn
try_from
(
prtime
:
PRTime
)
-
>
Res
<
Self
>
{
Ok
(
Self
{
d
:
Duration
:
:
from_micros
(
u64
:
:
try_from
(
prtime
)
?
)
}
)
}
}
impl
From
<
Duration
>
for
Interval
{
fn
from
(
d
:
Duration
)
-
>
Self
{
Self
{
d
}
}
}
impl
TryInto
<
PRTime
>
for
Interval
{
type
Error
=
Error
;
fn
try_into
(
self
)
-
>
Res
<
PRTime
>
{
Ok
(
PRTime
:
:
try_from
(
self
.
d
.
as_micros
(
)
)
?
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
{
get_base
init
Interval
PRTime
Time
}
;
use
crate
:
:
err
:
:
Res
;
use
std
:
:
convert
:
:
{
TryFrom
TryInto
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
#
[
test
]
fn
convert_stable
(
)
{
init
(
)
;
let
now
=
Time
:
:
from
(
Instant
:
:
now
(
)
)
;
let
pr
:
PRTime
=
now
.
try_into
(
)
.
expect
(
"
convert
to
PRTime
with
truncation
"
)
;
let
t2
=
Time
:
:
try_from
(
pr
)
.
expect
(
"
convert
to
Instant
"
)
;
let
pr2
:
PRTime
=
t2
.
try_into
(
)
.
expect
(
"
convert
to
PRTime
again
"
)
;
assert_eq
!
(
pr
pr2
)
;
let
t3
=
Time
:
:
try_from
(
pr2
)
.
expect
(
"
convert
to
Instant
again
"
)
;
assert_eq
!
(
t2
t3
)
;
}
#
[
test
]
fn
past_time
(
)
{
init
(
)
;
let
base
=
get_base
(
)
;
assert
!
(
Time
:
:
try_from
(
base
.
prtime
-
1
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
negative_time
(
)
{
init
(
)
;
assert
!
(
Time
:
:
try_from
(
-
1
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
negative_interval
(
)
{
init
(
)
;
assert
!
(
Interval
:
:
try_from
(
-
1
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
overflow_interval
(
)
{
init
(
)
;
let
interval
=
Interval
:
:
from
(
Duration
:
:
from_micros
(
u64
:
:
max_value
(
)
)
)
;
let
res
:
Res
<
PRTime
>
=
interval
.
try_into
(
)
;
assert
!
(
res
.
is_err
(
)
)
;
}
}
