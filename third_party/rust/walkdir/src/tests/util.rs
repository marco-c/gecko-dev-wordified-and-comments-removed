use
std
:
:
env
;
use
std
:
:
error
;
use
std
:
:
fs
:
:
{
self
File
}
;
use
std
:
:
io
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
result
;
use
crate
:
:
{
DirEntry
Error
}
;
#
[
macro_export
]
macro_rules
!
err
{
(
(
tt
:
tt
)
*
)
=
>
{
Box
:
:
<
dyn
error
:
:
Error
+
Send
+
Sync
>
:
:
from
(
format
!
(
(
tt
)
*
)
)
}
}
pub
type
Result
<
T
>
=
result
:
:
Result
<
T
Box
<
dyn
error
:
:
Error
+
Send
+
Sync
>
>
;
#
[
derive
(
Debug
)
]
pub
struct
RecursiveResults
{
ents
:
Vec
<
DirEntry
>
errs
:
Vec
<
Error
>
}
impl
RecursiveResults
{
pub
fn
errs
(
&
self
)
-
>
&
[
Error
]
{
&
self
.
errs
}
pub
fn
assert_no_errors
(
&
self
)
{
assert
!
(
self
.
errs
.
is_empty
(
)
"
expected
to
find
no
errors
but
found
:
{
:
?
}
"
self
.
errs
)
;
}
pub
fn
ents
(
&
self
)
-
>
&
[
DirEntry
]
{
&
self
.
ents
}
pub
fn
paths
(
&
self
)
-
>
Vec
<
PathBuf
>
{
self
.
ents
.
iter
(
)
.
map
(
|
d
|
d
.
path
(
)
.
to_path_buf
(
)
)
.
collect
(
)
}
pub
fn
sorted_ents
(
&
self
)
-
>
Vec
<
DirEntry
>
{
let
mut
ents
=
self
.
ents
.
clone
(
)
;
ents
.
sort_by
(
|
e1
e2
|
e1
.
path
(
)
.
cmp
(
e2
.
path
(
)
)
)
;
ents
}
pub
fn
sorted_paths
(
&
self
)
-
>
Vec
<
PathBuf
>
{
self
.
sorted_ents
(
)
.
into_iter
(
)
.
map
(
|
d
|
d
.
into_path
(
)
)
.
collect
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Dir
{
dir
:
TempDir
}
impl
Dir
{
pub
fn
tmp
(
)
-
>
Dir
{
let
dir
=
TempDir
:
:
new
(
)
.
unwrap
(
)
;
Dir
{
dir
}
}
pub
fn
path
(
&
self
)
-
>
&
Path
{
self
.
dir
.
path
(
)
}
pub
fn
join
<
P
:
AsRef
<
Path
>
>
(
&
self
path
:
P
)
-
>
PathBuf
{
self
.
path
(
)
.
join
(
path
)
}
pub
fn
run_recursive
<
I
>
(
&
self
it
:
I
)
-
>
RecursiveResults
where
I
:
IntoIterator
<
Item
=
result
:
:
Result
<
DirEntry
Error
>
>
{
let
mut
results
=
RecursiveResults
{
ents
:
vec
!
[
]
errs
:
vec
!
[
]
}
;
for
result
in
it
{
match
result
{
Ok
(
ent
)
=
>
results
.
ents
.
push
(
ent
)
Err
(
err
)
=
>
results
.
errs
.
push
(
err
)
}
}
results
}
pub
fn
mkdirp
<
P
:
AsRef
<
Path
>
>
(
&
self
path
:
P
)
{
let
full
=
self
.
join
(
path
)
;
fs
:
:
create_dir_all
(
&
full
)
.
map_err
(
|
e
|
{
err
!
(
"
failed
to
create
directory
{
}
:
{
}
"
full
.
display
(
)
e
)
}
)
.
unwrap
(
)
;
}
pub
fn
touch
<
P
:
AsRef
<
Path
>
>
(
&
self
path
:
P
)
{
let
full
=
self
.
join
(
path
)
;
File
:
:
create
(
&
full
)
.
map_err
(
|
e
|
{
err
!
(
"
failed
to
create
file
{
}
:
{
}
"
full
.
display
(
)
e
)
}
)
.
unwrap
(
)
;
}
pub
fn
touch_all
<
P
:
AsRef
<
Path
>
>
(
&
self
paths
:
&
[
P
]
)
{
for
p
in
paths
{
self
.
touch
(
p
)
;
}
}
pub
fn
symlink_file
<
P1
:
AsRef
<
Path
>
P2
:
AsRef
<
Path
>
>
(
&
self
src
:
P1
link_name
:
P2
)
{
#
[
cfg
(
windows
)
]
fn
imp
(
src
:
&
Path
link_name
:
&
Path
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
windows
:
:
fs
:
:
symlink_file
;
symlink_file
(
src
link_name
)
}
#
[
cfg
(
unix
)
]
fn
imp
(
src
:
&
Path
link_name
:
&
Path
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
symlink
;
symlink
(
src
link_name
)
}
let
(
src
link_name
)
=
(
self
.
join
(
src
)
self
.
join
(
link_name
)
)
;
imp
(
&
src
&
link_name
)
.
map_err
(
|
e
|
{
err
!
(
"
failed
to
symlink
file
{
}
with
target
{
}
:
{
}
"
src
.
display
(
)
link_name
.
display
(
)
e
)
}
)
.
unwrap
(
)
}
pub
fn
symlink_dir
<
P1
:
AsRef
<
Path
>
P2
:
AsRef
<
Path
>
>
(
&
self
src
:
P1
link_name
:
P2
)
{
#
[
cfg
(
windows
)
]
fn
imp
(
src
:
&
Path
link_name
:
&
Path
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
windows
:
:
fs
:
:
symlink_dir
;
symlink_dir
(
src
link_name
)
}
#
[
cfg
(
unix
)
]
fn
imp
(
src
:
&
Path
link_name
:
&
Path
)
-
>
io
:
:
Result
<
(
)
>
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
symlink
;
symlink
(
src
link_name
)
}
let
(
src
link_name
)
=
(
self
.
join
(
src
)
self
.
join
(
link_name
)
)
;
imp
(
&
src
&
link_name
)
.
map_err
(
|
e
|
{
err
!
(
"
failed
to
symlink
directory
{
}
with
target
{
}
:
{
}
"
src
.
display
(
)
link_name
.
display
(
)
e
)
}
)
.
unwrap
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
TempDir
(
PathBuf
)
;
impl
Drop
for
TempDir
{
fn
drop
(
&
mut
self
)
{
fs
:
:
remove_dir_all
(
&
self
.
0
)
.
unwrap
(
)
;
}
}
impl
TempDir
{
pub
fn
new
(
)
-
>
Result
<
TempDir
>
{
#
[
allow
(
deprecated
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
ATOMIC_USIZE_INIT
}
;
static
TRIES
:
usize
=
100
;
#
[
allow
(
deprecated
)
]
static
COUNTER
:
AtomicUsize
=
ATOMIC_USIZE_INIT
;
let
tmpdir
=
env
:
:
temp_dir
(
)
;
for
_
in
0
.
.
TRIES
{
let
count
=
COUNTER
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
let
path
=
tmpdir
.
join
(
"
rust
-
walkdir
"
)
.
join
(
count
.
to_string
(
)
)
;
if
path
.
is_dir
(
)
{
continue
;
}
fs
:
:
create_dir_all
(
&
path
)
.
map_err
(
|
e
|
{
err
!
(
"
failed
to
create
{
}
:
{
}
"
path
.
display
(
)
e
)
}
)
?
;
return
Ok
(
TempDir
(
path
)
)
;
}
Err
(
err
!
(
"
failed
to
create
temp
dir
after
{
}
tries
"
TRIES
)
)
}
pub
fn
path
(
&
self
)
-
>
&
Path
{
&
self
.
0
}
}
