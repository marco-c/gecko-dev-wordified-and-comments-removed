use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
fmt
;
use
std
:
:
fs
:
:
{
self
FileType
}
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
crate
:
:
error
:
:
Error
;
use
crate
:
:
Result
;
pub
struct
DirEntry
{
path
:
PathBuf
ty
:
FileType
follow_link
:
bool
depth
:
usize
#
[
cfg
(
unix
)
]
ino
:
u64
#
[
cfg
(
windows
)
]
metadata
:
fs
:
:
Metadata
}
impl
DirEntry
{
pub
fn
path
(
&
self
)
-
>
&
Path
{
&
self
.
path
}
pub
fn
into_path
(
self
)
-
>
PathBuf
{
self
.
path
}
pub
fn
path_is_symlink
(
&
self
)
-
>
bool
{
self
.
ty
.
is_symlink
(
)
|
|
self
.
follow_link
}
pub
fn
metadata
(
&
self
)
-
>
Result
<
fs
:
:
Metadata
>
{
self
.
metadata_internal
(
)
}
#
[
cfg
(
windows
)
]
fn
metadata_internal
(
&
self
)
-
>
Result
<
fs
:
:
Metadata
>
{
if
self
.
follow_link
{
fs
:
:
metadata
(
&
self
.
path
)
}
else
{
Ok
(
self
.
metadata
.
clone
(
)
)
}
.
map_err
(
|
err
|
Error
:
:
from_entry
(
self
err
)
)
}
#
[
cfg
(
not
(
windows
)
)
]
fn
metadata_internal
(
&
self
)
-
>
Result
<
fs
:
:
Metadata
>
{
if
self
.
follow_link
{
fs
:
:
metadata
(
&
self
.
path
)
}
else
{
fs
:
:
symlink_metadata
(
&
self
.
path
)
}
.
map_err
(
|
err
|
Error
:
:
from_entry
(
self
err
)
)
}
pub
fn
file_type
(
&
self
)
-
>
fs
:
:
FileType
{
self
.
ty
}
pub
fn
file_name
(
&
self
)
-
>
&
OsStr
{
self
.
path
.
file_name
(
)
.
unwrap_or_else
(
|
|
self
.
path
.
as_os_str
(
)
)
}
pub
fn
depth
(
&
self
)
-
>
usize
{
self
.
depth
}
#
[
cfg
(
windows
)
]
pub
(
crate
)
fn
is_dir
(
&
self
)
-
>
bool
{
use
std
:
:
os
:
:
windows
:
:
fs
:
:
MetadataExt
;
use
winapi
:
:
um
:
:
winnt
:
:
FILE_ATTRIBUTE_DIRECTORY
;
self
.
metadata
.
file_attributes
(
)
&
FILE_ATTRIBUTE_DIRECTORY
!
=
0
}
#
[
cfg
(
not
(
windows
)
)
]
pub
(
crate
)
fn
is_dir
(
&
self
)
-
>
bool
{
self
.
ty
.
is_dir
(
)
}
#
[
cfg
(
windows
)
]
pub
(
crate
)
fn
from_entry
(
depth
:
usize
ent
:
&
fs
:
:
DirEntry
)
-
>
Result
<
DirEntry
>
{
let
path
=
ent
.
path
(
)
;
let
ty
=
ent
.
file_type
(
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
path
.
clone
(
)
err
)
)
?
;
let
md
=
ent
.
metadata
(
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
path
.
clone
(
)
err
)
)
?
;
Ok
(
DirEntry
{
path
:
path
ty
:
ty
follow_link
:
false
depth
:
depth
metadata
:
md
}
)
}
#
[
cfg
(
unix
)
]
pub
(
crate
)
fn
from_entry
(
depth
:
usize
ent
:
&
fs
:
:
DirEntry
)
-
>
Result
<
DirEntry
>
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
DirEntryExt
;
let
ty
=
ent
.
file_type
(
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
ent
.
path
(
)
err
)
)
?
;
Ok
(
DirEntry
{
path
:
ent
.
path
(
)
ty
:
ty
follow_link
:
false
depth
:
depth
ino
:
ent
.
ino
(
)
}
)
}
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
pub
(
crate
)
fn
from_entry
(
depth
:
usize
ent
:
&
fs
:
:
DirEntry
)
-
>
Result
<
DirEntry
>
{
let
ty
=
ent
.
file_type
(
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
ent
.
path
(
)
err
)
)
?
;
Ok
(
DirEntry
{
path
:
ent
.
path
(
)
ty
:
ty
follow_link
:
false
depth
:
depth
}
)
}
#
[
cfg
(
windows
)
]
pub
(
crate
)
fn
from_path
(
depth
:
usize
pb
:
PathBuf
follow
:
bool
)
-
>
Result
<
DirEntry
>
{
let
md
=
if
follow
{
fs
:
:
metadata
(
&
pb
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
pb
.
clone
(
)
err
)
)
?
}
else
{
fs
:
:
symlink_metadata
(
&
pb
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
pb
.
clone
(
)
err
)
)
?
}
;
Ok
(
DirEntry
{
path
:
pb
ty
:
md
.
file_type
(
)
follow_link
:
follow
depth
:
depth
metadata
:
md
}
)
}
#
[
cfg
(
unix
)
]
pub
(
crate
)
fn
from_path
(
depth
:
usize
pb
:
PathBuf
follow
:
bool
)
-
>
Result
<
DirEntry
>
{
use
std
:
:
os
:
:
unix
:
:
fs
:
:
MetadataExt
;
let
md
=
if
follow
{
fs
:
:
metadata
(
&
pb
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
pb
.
clone
(
)
err
)
)
?
}
else
{
fs
:
:
symlink_metadata
(
&
pb
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
pb
.
clone
(
)
err
)
)
?
}
;
Ok
(
DirEntry
{
path
:
pb
ty
:
md
.
file_type
(
)
follow_link
:
follow
depth
:
depth
ino
:
md
.
ino
(
)
}
)
}
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
pub
(
crate
)
fn
from_path
(
depth
:
usize
pb
:
PathBuf
follow
:
bool
)
-
>
Result
<
DirEntry
>
{
let
md
=
if
follow
{
fs
:
:
metadata
(
&
pb
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
pb
.
clone
(
)
err
)
)
?
}
else
{
fs
:
:
symlink_metadata
(
&
pb
)
.
map_err
(
|
err
|
Error
:
:
from_path
(
depth
pb
.
clone
(
)
err
)
)
?
}
;
Ok
(
DirEntry
{
path
:
pb
ty
:
md
.
file_type
(
)
follow_link
:
follow
depth
:
depth
}
)
}
}
impl
Clone
for
DirEntry
{
#
[
cfg
(
windows
)
]
fn
clone
(
&
self
)
-
>
DirEntry
{
DirEntry
{
path
:
self
.
path
.
clone
(
)
ty
:
self
.
ty
follow_link
:
self
.
follow_link
depth
:
self
.
depth
metadata
:
self
.
metadata
.
clone
(
)
}
}
#
[
cfg
(
unix
)
]
fn
clone
(
&
self
)
-
>
DirEntry
{
DirEntry
{
path
:
self
.
path
.
clone
(
)
ty
:
self
.
ty
follow_link
:
self
.
follow_link
depth
:
self
.
depth
ino
:
self
.
ino
}
}
#
[
cfg
(
not
(
any
(
unix
windows
)
)
)
]
fn
clone
(
&
self
)
-
>
DirEntry
{
DirEntry
{
path
:
self
.
path
.
clone
(
)
ty
:
self
.
ty
follow_link
:
self
.
follow_link
depth
:
self
.
depth
}
}
}
impl
fmt
:
:
Debug
for
DirEntry
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
DirEntry
(
{
:
?
}
)
"
self
.
path
)
}
}
#
[
cfg
(
unix
)
]
pub
trait
DirEntryExt
{
fn
ino
(
&
self
)
-
>
u64
;
}
#
[
cfg
(
unix
)
]
impl
DirEntryExt
for
DirEntry
{
fn
ino
(
&
self
)
-
>
u64
{
self
.
ino
}
}
