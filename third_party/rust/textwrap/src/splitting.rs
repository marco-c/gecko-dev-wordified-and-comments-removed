#
[
cfg
(
feature
=
"
hyphenation
"
)
]
use
hyphenation
:
:
{
Hyphenator
Standard
}
;
pub
trait
WordSplitter
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
;
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
NoHyphenation
;
impl
WordSplitter
for
NoHyphenation
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
{
vec
!
[
(
word
"
"
"
"
)
]
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
HyphenSplitter
;
impl
WordSplitter
for
HyphenSplitter
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
{
let
mut
triples
=
Vec
:
:
new
(
)
;
let
mut
char_indices
=
word
.
char_indices
(
)
;
let
mut
prev
=
match
char_indices
.
next
(
)
{
None
=
>
return
vec
!
[
(
word
"
"
"
"
)
]
Some
(
(
_
ch
)
)
=
>
ch
}
;
let
(
mut
idx
mut
cur
)
=
match
char_indices
.
next
(
)
{
None
=
>
return
vec
!
[
(
word
"
"
"
"
)
]
Some
(
(
idx
cur
)
)
=
>
(
idx
cur
)
}
;
for
(
i
next
)
in
char_indices
{
if
prev
.
is_alphanumeric
(
)
&
&
cur
=
=
'
-
'
&
&
next
.
is_alphanumeric
(
)
{
let
(
head
tail
)
=
word
.
split_at
(
idx
+
1
)
;
triples
.
push
(
(
head
"
"
tail
)
)
;
}
prev
=
cur
;
idx
=
i
;
cur
=
next
;
}
triples
.
push
(
(
word
"
"
"
"
)
)
;
triples
}
}
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
impl
WordSplitter
for
Standard
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
{
let
mut
triples
=
Vec
:
:
new
(
)
;
for
n
in
self
.
hyphenate
(
word
)
.
breaks
{
let
(
head
tail
)
=
word
.
split_at
(
n
)
;
let
hyphen
=
if
head
.
ends_with
(
'
-
'
)
{
"
"
}
else
{
"
-
"
}
;
triples
.
push
(
(
head
hyphen
tail
)
)
;
}
triples
.
push
(
(
word
"
"
"
"
)
)
;
triples
}
}
