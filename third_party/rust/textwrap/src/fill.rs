use
crate
:
:
{
wrap
wrap_algorithms
Options
WordSeparator
}
;
pub
fn
fill
<
'
a
Opt
>
(
text
:
&
str
width_or_options
:
Opt
)
-
>
String
where
Opt
:
Into
<
Options
<
'
a
>
>
{
let
options
=
width_or_options
.
into
(
)
;
if
text
.
len
(
)
<
options
.
width
&
&
!
text
.
contains
(
'
\
n
'
)
&
&
options
.
initial_indent
.
is_empty
(
)
{
String
:
:
from
(
text
.
trim_end_matches
(
'
'
)
)
}
else
{
fill_slow_path
(
text
options
)
}
}
pub
(
crate
)
fn
fill_slow_path
(
text
:
&
str
options
:
Options
<
'
_
>
)
-
>
String
{
let
mut
result
=
String
:
:
with_capacity
(
text
.
len
(
)
)
;
let
line_ending_str
=
options
.
line_ending
.
as_str
(
)
;
for
(
i
line
)
in
wrap
(
text
options
)
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
result
.
push_str
(
line_ending_str
)
;
}
result
.
push_str
(
line
)
;
}
result
}
pub
fn
fill_inplace
(
text
:
&
mut
String
width
:
usize
)
{
let
mut
indices
=
Vec
:
:
new
(
)
;
let
mut
offset
=
0
;
for
line
in
text
.
split
(
'
\
n
'
)
{
let
words
=
WordSeparator
:
:
AsciiSpace
.
find_words
(
line
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
let
wrapped_words
=
wrap_algorithms
:
:
wrap_first_fit
(
&
words
&
[
width
as
f64
]
)
;
let
mut
line_offset
=
offset
;
for
words
in
&
wrapped_words
[
.
.
wrapped_words
.
len
(
)
-
1
]
{
let
line_len
=
words
.
iter
(
)
.
map
(
|
word
|
word
.
len
(
)
+
word
.
whitespace
.
len
(
)
)
.
sum
:
:
<
usize
>
(
)
;
line_offset
+
=
line_len
;
indices
.
push
(
line_offset
-
1
)
;
}
offset
+
=
line
.
len
(
)
+
1
;
}
let
mut
bytes
=
std
:
:
mem
:
:
take
(
text
)
.
into_bytes
(
)
;
for
idx
in
indices
{
bytes
[
idx
]
=
b
'
\
n
'
;
}
*
text
=
String
:
:
from_utf8
(
bytes
)
.
unwrap
(
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
WrapAlgorithm
;
#
[
test
]
fn
fill_simple
(
)
{
assert_eq
!
(
fill
(
"
foo
bar
baz
"
10
)
"
foo
bar
\
nbaz
"
)
;
}
#
[
test
]
fn
fill_unicode_boundary
(
)
{
fill
(
"
\
u
{
1b
}
!
"
10
)
;
}
#
[
test
]
fn
non_breaking_space
(
)
{
let
options
=
Options
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
fill
(
"
foo
bar
baz
"
&
options
)
"
foo
bar
baz
"
)
;
}
#
[
test
]
fn
non_breaking_hyphen
(
)
{
let
options
=
Options
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
fill
(
"
foo
bar
baz
"
&
options
)
"
foo
bar
baz
"
)
;
}
#
[
test
]
fn
fill_preserves_line_breaks_trims_whitespace
(
)
{
assert_eq
!
(
fill
(
"
"
80
)
"
"
)
;
assert_eq
!
(
fill
(
"
\
n
"
80
)
"
\
n
"
)
;
assert_eq
!
(
fill
(
"
\
n
\
n
\
n
"
80
)
"
\
n
\
n
\
n
"
)
;
}
#
[
test
]
fn
preserve_line_breaks
(
)
{
assert_eq
!
(
fill
(
"
"
80
)
"
"
)
;
assert_eq
!
(
fill
(
"
\
n
"
80
)
"
\
n
"
)
;
assert_eq
!
(
fill
(
"
\
n
\
n
\
n
"
80
)
"
\
n
\
n
\
n
"
)
;
assert_eq
!
(
fill
(
"
test
\
n
"
80
)
"
test
\
n
"
)
;
assert_eq
!
(
fill
(
"
test
\
n
\
na
\
n
\
n
"
80
)
"
test
\
n
\
na
\
n
\
n
"
)
;
assert_eq
!
(
fill
(
"
1
3
5
7
\
n1
3
5
7
"
Options
:
:
new
(
7
)
.
wrap_algorithm
(
WrapAlgorithm
:
:
FirstFit
)
)
"
1
3
5
7
\
n1
3
5
7
"
)
;
assert_eq
!
(
fill
(
"
1
3
5
7
\
n1
3
5
7
"
Options
:
:
new
(
5
)
.
wrap_algorithm
(
WrapAlgorithm
:
:
FirstFit
)
)
"
1
3
5
\
n7
\
n1
3
5
\
n7
"
)
;
}
#
[
test
]
fn
break_words_line_breaks
(
)
{
assert_eq
!
(
fill
(
"
ab
\
ncdefghijkl
"
5
)
"
ab
\
ncdefg
\
nhijkl
"
)
;
assert_eq
!
(
fill
(
"
abcdefgh
\
nijkl
"
5
)
"
abcde
\
nfgh
\
nijkl
"
)
;
}
#
[
test
]
fn
break_words_empty_lines
(
)
{
assert_eq
!
(
fill
(
"
foo
\
nbar
"
&
Options
:
:
new
(
2
)
.
break_words
(
false
)
)
"
foo
\
nbar
"
)
;
}
#
[
test
]
fn
fill_inplace_empty
(
)
{
let
mut
text
=
String
:
:
from
(
"
"
)
;
fill_inplace
(
&
mut
text
80
)
;
assert_eq
!
(
text
"
"
)
;
}
#
[
test
]
fn
fill_inplace_simple
(
)
{
let
mut
text
=
String
:
:
from
(
"
foo
bar
baz
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
foo
bar
\
nbaz
"
)
;
}
#
[
test
]
fn
fill_inplace_multiple_lines
(
)
{
let
mut
text
=
String
:
:
from
(
"
Some
text
to
wrap
over
multiple
lines
"
)
;
fill_inplace
(
&
mut
text
12
)
;
assert_eq
!
(
text
"
Some
text
to
\
nwrap
over
\
nmultiple
\
nlines
"
)
;
}
#
[
test
]
fn
fill_inplace_long_word
(
)
{
let
mut
text
=
String
:
:
from
(
"
Internationalization
is
hard
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
Internationalization
\
nis
hard
"
)
;
}
#
[
test
]
fn
fill_inplace_no_hyphen_splitting
(
)
{
let
mut
text
=
String
:
:
from
(
"
A
well
-
chosen
example
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
A
\
nwell
-
chosen
\
nexample
"
)
;
}
#
[
test
]
fn
fill_inplace_newlines
(
)
{
let
mut
text
=
String
:
:
from
(
"
foo
bar
\
n
\
nbaz
\
n
\
n
\
n
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
foo
bar
\
n
\
nbaz
\
n
\
n
\
n
"
)
;
}
#
[
test
]
fn
fill_inplace_newlines_reset_line_width
(
)
{
let
mut
text
=
String
:
:
from
(
"
1
3
5
\
n1
3
5
7
9
\
n1
3
5
7
9
1
3
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
1
3
5
\
n1
3
5
7
9
\
n1
3
5
7
9
\
n1
3
"
)
;
}
#
[
test
]
fn
fill_inplace_leading_whitespace
(
)
{
let
mut
text
=
String
:
:
from
(
"
foo
bar
baz
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
foo
bar
\
nbaz
"
)
;
}
#
[
test
]
fn
fill_inplace_trailing_whitespace
(
)
{
let
mut
text
=
String
:
:
from
(
"
foo
bar
baz
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
foo
bar
\
nbaz
"
)
;
}
#
[
test
]
fn
fill_inplace_interior_whitespace
(
)
{
let
mut
text
=
String
:
:
from
(
"
foo
bar
baz
"
)
;
fill_inplace
(
&
mut
text
10
)
;
assert_eq
!
(
text
"
foo
bar
\
nbaz
"
)
;
}
}
