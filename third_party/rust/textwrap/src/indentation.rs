pub
fn
indent
(
s
:
&
str
prefix
:
&
str
)
-
>
String
{
let
mut
result
=
String
:
:
with_capacity
(
2
*
s
.
len
(
)
)
;
let
trimmed_prefix
=
prefix
.
trim_end
(
)
;
for
(
idx
line
)
in
s
.
split_terminator
(
'
\
n
'
)
.
enumerate
(
)
{
if
idx
>
0
{
result
.
push
(
'
\
n
'
)
;
}
if
line
.
trim
(
)
.
is_empty
(
)
{
result
.
push_str
(
trimmed_prefix
)
;
}
else
{
result
.
push_str
(
prefix
)
;
}
result
.
push_str
(
line
)
;
}
if
s
.
ends_with
(
'
\
n
'
)
{
result
.
push
(
'
\
n
'
)
;
}
result
}
pub
fn
dedent
(
s
:
&
str
)
-
>
String
{
let
mut
prefix
=
"
"
;
let
mut
lines
=
s
.
lines
(
)
;
for
line
in
&
mut
lines
{
let
mut
whitespace_idx
=
line
.
len
(
)
;
for
(
idx
ch
)
in
line
.
char_indices
(
)
{
if
!
ch
.
is_whitespace
(
)
{
whitespace_idx
=
idx
;
break
;
}
}
if
whitespace_idx
<
line
.
len
(
)
{
prefix
=
&
line
[
.
.
whitespace_idx
]
;
break
;
}
}
for
line
in
&
mut
lines
{
let
mut
whitespace_idx
=
line
.
len
(
)
;
for
(
(
idx
a
)
b
)
in
line
.
char_indices
(
)
.
zip
(
prefix
.
chars
(
)
)
{
if
a
!
=
b
{
whitespace_idx
=
idx
;
break
;
}
}
if
whitespace_idx
<
line
.
len
(
)
&
&
whitespace_idx
<
prefix
.
len
(
)
{
prefix
=
&
line
[
.
.
whitespace_idx
]
;
}
}
let
mut
result
=
String
:
:
new
(
)
;
for
line
in
s
.
lines
(
)
{
if
line
.
starts_with
(
prefix
)
&
&
line
.
chars
(
)
.
any
(
|
c
|
!
c
.
is_whitespace
(
)
)
{
let
(
_
tail
)
=
line
.
split_at
(
prefix
.
len
(
)
)
;
result
.
push_str
(
tail
)
;
}
result
.
push
(
'
\
n
'
)
;
}
if
result
.
ends_with
(
'
\
n
'
)
&
&
!
s
.
ends_with
(
'
\
n
'
)
{
let
new_len
=
result
.
len
(
)
-
1
;
result
.
truncate
(
new_len
)
;
}
result
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
indent_empty
(
)
{
assert_eq
!
(
indent
(
"
\
n
"
"
"
)
"
\
n
"
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
indent_nonempty
(
)
{
let
text
=
[
"
foo
\
n
"
"
bar
\
n
"
"
baz
\
n
"
]
.
join
(
"
"
)
;
let
expected
=
[
"
/
/
foo
\
n
"
"
/
/
bar
\
n
"
"
/
/
baz
\
n
"
]
.
join
(
"
"
)
;
assert_eq
!
(
indent
(
&
text
"
/
/
"
)
expected
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
indent_empty_line
(
)
{
let
text
=
[
"
foo
"
"
bar
"
"
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
let
expected
=
[
"
/
/
foo
"
"
/
/
bar
"
"
/
/
"
"
/
/
baz
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
indent
(
&
text
"
/
/
"
)
expected
)
;
}
#
[
test
]
fn
dedent_empty
(
)
{
assert_eq
!
(
dedent
(
"
"
)
"
"
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_multi_line
(
)
{
let
x
=
[
"
foo
"
"
bar
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
bar
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_empty_line
(
)
{
let
x
=
[
"
foo
"
"
bar
"
"
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
bar
"
"
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_blank_line
(
)
{
let
x
=
[
"
foo
"
"
"
"
bar
"
"
foo
"
"
bar
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
"
"
bar
"
"
foo
"
"
bar
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_whitespace_line
(
)
{
let
x
=
[
"
foo
"
"
"
"
bar
"
"
foo
"
"
bar
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
"
"
bar
"
"
foo
"
"
bar
"
"
baz
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_mixed_whitespace
(
)
{
let
x
=
[
"
\
tfoo
"
"
bar
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
\
tfoo
"
"
bar
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_tabbed_whitespace
(
)
{
let
x
=
[
"
\
t
\
tfoo
"
"
\
t
\
t
\
tbar
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
\
tbar
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_mixed_tabbed_whitespace
(
)
{
let
x
=
[
"
\
t
\
tfoo
"
"
\
t
\
t
\
tbar
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
\
tbar
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_mixed_tabbed_whitespace2
(
)
{
let
x
=
[
"
\
t
\
tfoo
"
"
\
t
\
tbar
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
\
tfoo
"
"
\
tbar
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
dedent_preserve_no_terminating_newline
(
)
{
let
x
=
[
"
foo
"
"
bar
"
]
.
join
(
"
\
n
"
)
;
let
y
=
[
"
foo
"
"
bar
"
]
.
join
(
"
\
n
"
)
;
assert_eq
!
(
dedent
(
&
x
)
y
)
;
}
}
