#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
textwrap
/
0
.
9
.
0
"
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
deny
(
missing_debug_implementations
)
]
extern
crate
unicode_width
;
#
[
cfg
(
feature
=
"
term_size
"
)
]
extern
crate
term_size
;
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
extern
crate
hyphenation
;
use
std
:
:
fmt
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
str
:
:
CharIndices
;
use
unicode_width
:
:
UnicodeWidthStr
;
use
unicode_width
:
:
UnicodeWidthChar
;
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
use
hyphenation
:
:
{
Hyphenation
Corpus
}
;
const
NBSP
:
char
=
'
\
u
{
a0
}
'
;
pub
trait
WordSplitter
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
;
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
NoHyphenation
;
impl
WordSplitter
for
NoHyphenation
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
{
vec
!
[
(
word
"
"
"
"
)
]
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
HyphenSplitter
;
impl
WordSplitter
for
HyphenSplitter
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
{
let
mut
triples
=
Vec
:
:
new
(
)
;
let
mut
char_indices
=
word
.
char_indices
(
)
;
let
mut
prev
=
match
char_indices
.
next
(
)
{
None
=
>
return
vec
!
[
(
word
"
"
"
"
)
]
Some
(
(
_
ch
)
)
=
>
ch
}
;
let
(
mut
idx
mut
cur
)
=
match
char_indices
.
next
(
)
{
None
=
>
return
vec
!
[
(
word
"
"
"
"
)
]
Some
(
(
idx
cur
)
)
=
>
(
idx
cur
)
}
;
for
(
i
next
)
in
char_indices
{
if
prev
.
is_alphanumeric
(
)
&
&
cur
=
=
'
-
'
&
&
next
.
is_alphanumeric
(
)
{
let
(
head
tail
)
=
word
.
split_at
(
idx
+
1
)
;
triples
.
push
(
(
head
"
"
tail
)
)
;
}
prev
=
cur
;
idx
=
i
;
cur
=
next
;
}
triples
.
push
(
(
word
"
"
"
"
)
)
;
triples
}
}
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
impl
WordSplitter
for
Corpus
{
fn
split
<
'
w
>
(
&
self
word
:
&
'
w
str
)
-
>
Vec
<
(
&
'
w
str
&
'
w
str
&
'
w
str
)
>
{
let
mut
triples
=
Vec
:
:
new
(
)
;
for
n
in
word
.
opportunities
(
self
)
{
let
(
head
tail
)
=
word
.
split_at
(
n
)
;
let
hyphen
=
if
head
.
ends_with
(
'
-
'
)
{
"
"
}
else
{
"
-
"
}
;
triples
.
push
(
(
head
hyphen
tail
)
)
;
}
triples
.
push
(
(
word
"
"
"
"
)
)
;
triples
}
}
fn
cow_add_assign
<
'
a
>
(
lhs
:
&
mut
Cow
<
'
a
str
>
rhs
:
&
'
a
str
)
{
if
lhs
.
is_empty
(
)
{
*
lhs
=
Cow
:
:
Borrowed
(
rhs
)
}
else
if
rhs
.
is_empty
(
)
{
return
;
}
else
{
if
let
Cow
:
:
Borrowed
(
inner
)
=
*
lhs
{
let
mut
s
=
String
:
:
with_capacity
(
lhs
.
len
(
)
+
rhs
.
len
(
)
)
;
s
.
push_str
(
inner
)
;
*
lhs
=
Cow
:
:
Owned
(
s
)
;
}
lhs
.
to_mut
(
)
.
push_str
(
rhs
)
;
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Wrapper
<
'
a
S
:
WordSplitter
>
{
pub
width
:
usize
pub
initial_indent
:
&
'
a
str
pub
subsequent_indent
:
&
'
a
str
pub
break_words
:
bool
pub
splitter
:
S
}
impl
<
'
a
>
Wrapper
<
'
a
HyphenSplitter
>
{
pub
fn
new
(
width
:
usize
)
-
>
Wrapper
<
'
a
HyphenSplitter
>
{
Wrapper
:
:
with_splitter
(
width
HyphenSplitter
)
}
#
[
cfg
(
feature
=
"
term_size
"
)
]
pub
fn
with_termwidth
(
)
-
>
Wrapper
<
'
a
HyphenSplitter
>
{
Wrapper
:
:
new
(
termwidth
(
)
)
}
}
impl
<
'
w
'
a
:
'
w
S
:
WordSplitter
>
Wrapper
<
'
a
S
>
{
pub
fn
with_splitter
(
width
:
usize
splitter
:
S
)
-
>
Wrapper
<
'
a
S
>
{
Wrapper
{
width
:
width
initial_indent
:
"
"
subsequent_indent
:
"
"
break_words
:
true
splitter
:
splitter
}
}
pub
fn
initial_indent
(
self
indent
:
&
'
a
str
)
-
>
Wrapper
<
'
a
S
>
{
Wrapper
{
initial_indent
:
indent
.
.
self
}
}
pub
fn
subsequent_indent
(
self
indent
:
&
'
a
str
)
-
>
Wrapper
<
'
a
S
>
{
Wrapper
{
subsequent_indent
:
indent
.
.
self
}
}
pub
fn
break_words
(
self
setting
:
bool
)
-
>
Wrapper
<
'
a
S
>
{
Wrapper
{
break_words
:
setting
.
.
self
}
}
pub
fn
fill
(
&
self
s
:
&
str
)
-
>
String
{
let
mut
result
=
String
:
:
with_capacity
(
s
.
len
(
)
)
;
for
(
i
line
)
in
self
.
wrap_iter
(
s
)
.
enumerate
(
)
{
if
i
>
0
{
result
.
push
(
'
\
n
'
)
;
}
result
.
push_str
(
&
line
)
;
}
result
}
pub
fn
wrap
(
&
self
s
:
&
'
a
str
)
-
>
Vec
<
Cow
<
'
a
str
>
>
{
self
.
wrap_iter
(
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
pub
fn
wrap_iter
(
&
'
w
self
s
:
&
'
a
str
)
-
>
WrapIter
<
'
w
'
a
S
>
{
WrapIter
{
wrapper
:
self
wrap_iter_impl
:
WrapIterImpl
:
:
new
(
self
s
)
}
}
pub
fn
into_wrap_iter
(
self
s
:
&
'
a
str
)
-
>
IntoWrapIter
<
'
a
S
>
{
let
wrap_iter_impl
=
WrapIterImpl
:
:
new
(
&
self
s
)
;
IntoWrapIter
{
wrapper
:
self
wrap_iter_impl
:
wrap_iter_impl
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
IntoWrapIter
<
'
a
S
:
WordSplitter
>
{
wrapper
:
Wrapper
<
'
a
S
>
wrap_iter_impl
:
WrapIterImpl
<
'
a
>
}
impl
<
'
a
S
:
WordSplitter
>
Iterator
for
IntoWrapIter
<
'
a
S
>
{
type
Item
=
Cow
<
'
a
str
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Cow
<
'
a
str
>
>
{
self
.
wrap_iter_impl
.
impl_next
(
&
self
.
wrapper
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
WrapIter
<
'
w
'
a
:
'
w
S
:
WordSplitter
+
'
w
>
{
wrapper
:
&
'
w
Wrapper
<
'
a
S
>
wrap_iter_impl
:
WrapIterImpl
<
'
a
>
}
impl
<
'
w
'
a
:
'
w
S
:
WordSplitter
>
Iterator
for
WrapIter
<
'
w
'
a
S
>
{
type
Item
=
Cow
<
'
a
str
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Cow
<
'
a
str
>
>
{
self
.
wrap_iter_impl
.
impl_next
(
self
.
wrapper
)
}
}
struct
WrapIterImpl
<
'
a
>
{
source
:
&
'
a
str
char_indices
:
CharIndices
<
'
a
>
is_next_first
:
bool
start
:
usize
split
:
usize
split_len
:
usize
line_width
:
usize
line_width_at_split
:
usize
in_whitespace
:
bool
finished
:
bool
}
impl
<
'
a
>
fmt
:
:
Debug
for
WrapIterImpl
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
WrapIterImpl
"
)
.
field
(
"
source
"
&
self
.
source
)
.
field
(
"
char_indices
"
&
"
CharIndices
{
.
.
.
}
"
)
.
field
(
"
is_next_first
"
&
self
.
is_next_first
)
.
field
(
"
start
"
&
self
.
start
)
.
field
(
"
split
"
&
self
.
split
)
.
field
(
"
split_len
"
&
self
.
split_len
)
.
field
(
"
line_width
"
&
self
.
line_width
)
.
field
(
"
line_width_at_split
"
&
self
.
line_width_at_split
)
.
field
(
"
in_whitespace
"
&
self
.
in_whitespace
)
.
field
(
"
finished
"
&
self
.
finished
)
.
finish
(
)
}
}
impl
<
'
a
>
WrapIterImpl
<
'
a
>
{
fn
new
<
S
:
WordSplitter
>
(
wrapper
:
&
Wrapper
<
'
a
S
>
s
:
&
'
a
str
)
-
>
WrapIterImpl
<
'
a
>
{
WrapIterImpl
{
source
:
s
char_indices
:
s
.
char_indices
(
)
is_next_first
:
true
start
:
0
split
:
0
split_len
:
0
line_width
:
wrapper
.
initial_indent
.
width
(
)
line_width_at_split
:
wrapper
.
initial_indent
.
width
(
)
in_whitespace
:
false
finished
:
false
}
}
fn
create_result_line
<
S
:
WordSplitter
>
(
&
mut
self
wrapper
:
&
Wrapper
<
'
a
S
>
)
-
>
Cow
<
'
a
str
>
{
if
self
.
is_next_first
{
self
.
is_next_first
=
false
;
Cow
:
:
from
(
wrapper
.
initial_indent
)
}
else
{
Cow
:
:
from
(
wrapper
.
subsequent_indent
)
}
}
fn
impl_next
<
S
:
WordSplitter
>
(
&
mut
self
wrapper
:
&
Wrapper
<
'
a
S
>
)
-
>
Option
<
Cow
<
'
a
str
>
>
{
if
self
.
finished
{
return
None
;
}
while
let
Some
(
(
idx
ch
)
)
=
self
.
char_indices
.
next
(
)
{
let
char_width
=
ch
.
width
(
)
.
unwrap_or
(
0
)
;
let
char_len
=
ch
.
len_utf8
(
)
;
if
ch
.
is_whitespace
(
)
&
&
ch
!
=
NBSP
{
if
self
.
in_whitespace
{
self
.
split_len
+
=
char_len
;
}
else
{
self
.
split
=
idx
;
self
.
split_len
=
char_len
;
}
self
.
line_width_at_split
=
self
.
line_width
+
char_width
;
self
.
in_whitespace
=
true
;
}
else
if
self
.
line_width
+
char_width
>
wrapper
.
width
{
let
remaining_text
=
&
self
.
source
[
self
.
split
+
self
.
split_len
.
.
]
;
let
final_word
=
match
remaining_text
.
find
(
|
ch
:
char
|
ch
.
is_whitespace
(
)
&
&
ch
!
=
NBSP
)
{
Some
(
i
)
=
>
&
remaining_text
[
.
.
i
]
None
=
>
remaining_text
}
;
let
mut
hyphen
=
"
"
;
let
splits
=
wrapper
.
splitter
.
split
(
final_word
)
;
for
&
(
head
hyp
_
)
in
splits
.
iter
(
)
.
rev
(
)
{
if
self
.
line_width_at_split
+
head
.
width
(
)
+
hyp
.
width
(
)
<
=
wrapper
.
width
{
self
.
split
+
=
head
.
len
(
)
;
self
.
split_len
=
0
;
hyphen
=
hyp
;
break
;
}
}
if
self
.
start
>
=
self
.
split
{
if
wrapper
.
break_words
{
self
.
split
=
idx
;
self
.
split_len
=
0
;
self
.
line_width_at_split
=
self
.
line_width
;
}
else
{
self
.
split
=
self
.
start
+
splits
[
0
]
.
0
.
len
(
)
;
self
.
split_len
=
0
;
self
.
line_width_at_split
=
self
.
line_width
;
}
}
if
self
.
start
<
self
.
split
{
let
mut
result_line
=
self
.
create_result_line
(
wrapper
)
;
cow_add_assign
(
&
mut
result_line
&
self
.
source
[
self
.
start
.
.
self
.
split
]
)
;
cow_add_assign
(
&
mut
result_line
hyphen
)
;
self
.
start
=
self
.
split
+
self
.
split_len
;
self
.
line_width
+
=
wrapper
.
subsequent_indent
.
width
(
)
;
self
.
line_width
-
=
self
.
line_width_at_split
;
self
.
line_width
+
=
char_width
;
return
Some
(
result_line
)
;
}
}
else
{
self
.
in_whitespace
=
false
;
}
self
.
line_width
+
=
char_width
;
}
let
final_line
=
if
self
.
start
<
self
.
source
.
len
(
)
{
let
mut
result_line
=
self
.
create_result_line
(
wrapper
)
;
cow_add_assign
(
&
mut
result_line
&
self
.
source
[
self
.
start
.
.
]
)
;
Some
(
result_line
)
}
else
{
None
}
;
self
.
finished
=
true
;
final_line
}
}
#
[
cfg
(
feature
=
"
term_size
"
)
]
pub
fn
termwidth
(
)
-
>
usize
{
term_size
:
:
dimensions_stdout
(
)
.
map_or
(
80
|
(
w
_
)
|
w
)
}
pub
fn
fill
(
s
:
&
str
width
:
usize
)
-
>
String
{
Wrapper
:
:
new
(
width
)
.
fill
(
s
)
}
pub
fn
wrap
(
s
:
&
str
width
:
usize
)
-
>
Vec
<
Cow
<
str
>
>
{
Wrapper
:
:
new
(
width
)
.
wrap
(
s
)
}
pub
fn
wrap_iter
(
s
:
&
str
width
:
usize
)
-
>
IntoWrapIter
<
HyphenSplitter
>
{
Wrapper
:
:
new
(
width
)
.
into_wrap_iter
(
s
)
}
pub
fn
indent
(
s
:
&
str
prefix
:
&
str
)
-
>
String
{
let
mut
result
=
String
:
:
new
(
)
;
for
line
in
s
.
lines
(
)
{
if
line
.
chars
(
)
.
any
(
|
c
|
!
c
.
is_whitespace
(
)
)
{
result
.
push_str
(
prefix
)
;
result
.
push_str
(
line
)
;
}
result
.
push
(
'
\
n
'
)
;
}
result
}
pub
fn
dedent
(
s
:
&
str
)
-
>
String
{
let
mut
prefix
=
String
:
:
new
(
)
;
let
mut
lines
=
s
.
lines
(
)
;
for
line
in
&
mut
lines
{
let
whitespace
=
line
.
chars
(
)
.
take_while
(
|
c
|
c
.
is_whitespace
(
)
)
.
collect
:
:
<
String
>
(
)
;
if
whitespace
.
len
(
)
<
line
.
len
(
)
{
prefix
=
whitespace
;
break
;
}
}
for
line
in
&
mut
lines
{
let
whitespace
=
line
.
chars
(
)
.
zip
(
prefix
.
chars
(
)
)
.
take_while
(
|
&
(
a
b
)
|
a
=
=
b
)
.
map
(
|
(
_
b
)
|
b
)
.
collect
:
:
<
String
>
(
)
;
if
whitespace
.
len
(
)
<
prefix
.
len
(
)
{
prefix
=
whitespace
;
}
}
let
mut
result
=
String
:
:
new
(
)
;
for
line
in
s
.
lines
(
)
{
if
line
.
starts_with
(
&
prefix
)
&
&
line
.
chars
(
)
.
any
(
|
c
|
!
c
.
is_whitespace
(
)
)
{
let
(
_
tail
)
=
line
.
split_at
(
prefix
.
len
(
)
)
;
result
.
push_str
(
tail
)
;
}
result
.
push
(
'
\
n
'
)
;
}
result
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
extern
crate
hyphenation
;
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
use
hyphenation
:
:
Language
;
use
super
:
:
*
;
fn
add_nl
(
lines
:
&
[
&
str
]
)
-
>
String
{
lines
.
join
(
"
\
n
"
)
+
"
\
n
"
}
#
[
test
]
fn
no_wrap
(
)
{
assert_eq
!
(
wrap
(
"
foo
"
10
)
vec
!
[
"
foo
"
]
)
;
}
#
[
test
]
fn
simple
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
baz
"
5
)
vec
!
[
"
foo
"
"
bar
"
"
baz
"
]
)
;
}
#
[
test
]
fn
multi_word_on_line
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
baz
"
10
)
vec
!
[
"
foo
bar
"
"
baz
"
]
)
;
}
#
[
test
]
fn
long_word
(
)
{
assert_eq
!
(
wrap
(
"
foo
"
0
)
vec
!
[
"
f
"
"
o
"
"
o
"
]
)
;
}
#
[
test
]
fn
long_words
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
"
0
)
vec
!
[
"
f
"
"
o
"
"
o
"
"
b
"
"
a
"
"
r
"
]
)
;
}
#
[
test
]
fn
max_width
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
"
usize
:
:
max_value
(
)
)
vec
!
[
"
foo
bar
"
]
)
;
}
#
[
test
]
fn
leading_whitespace
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
"
6
)
vec
!
[
"
foo
"
"
bar
"
]
)
;
}
#
[
test
]
fn
trailing_whitespace
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
"
6
)
vec
!
[
"
foo
"
"
bar
"
]
)
;
}
#
[
test
]
fn
interior_whitespace
(
)
{
assert_eq
!
(
wrap
(
"
foo
:
bar
baz
"
10
)
vec
!
[
"
foo
:
bar
"
"
baz
"
]
)
;
}
#
[
test
]
fn
extra_whitespace_start_of_line
(
)
{
assert_eq
!
(
wrap
(
"
foo
bar
"
5
)
vec
!
[
"
foo
"
"
bar
"
]
)
;
}
#
[
test
]
fn
wide_character_handling
(
)
{
assert_eq
!
(
wrap
(
"
Hello
World
!
"
15
)
vec
!
[
"
Hello
World
!
"
]
)
;
assert_eq
!
(
wrap
(
"
!
"
15
)
vec
!
[
"
"
"
!
"
]
)
;
}
#
[
test
]
fn
indent_empty
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
10
)
.
initial_indent
(
"
!
!
!
"
)
;
assert_eq
!
(
wrapper
.
fill
(
"
"
)
"
"
)
;
}
#
[
test
]
fn
indent_single_line
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
10
)
.
initial_indent
(
"
>
>
>
"
)
;
assert_eq
!
(
wrapper
.
fill
(
"
foo
"
)
"
>
>
>
foo
"
)
;
}
#
[
test
]
fn
indent_multiple_lines
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
6
)
.
initial_indent
(
"
*
"
)
.
subsequent_indent
(
"
"
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foo
bar
baz
"
)
vec
!
[
"
*
foo
"
"
bar
"
"
baz
"
]
)
;
}
#
[
test
]
fn
indent_break_words
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
initial_indent
(
"
*
"
)
.
subsequent_indent
(
"
"
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foobarbaz
"
)
vec
!
[
"
*
foo
"
"
bar
"
"
baz
"
]
)
;
}
#
[
test
]
fn
hyphens
(
)
{
assert_eq
!
(
wrap
(
"
foo
-
bar
"
5
)
vec
!
[
"
foo
-
"
"
bar
"
]
)
;
}
#
[
test
]
fn
trailing_hyphen
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foobar
-
"
)
vec
!
[
"
foobar
-
"
]
)
;
}
#
[
test
]
fn
multiple_hyphens
(
)
{
assert_eq
!
(
wrap
(
"
foo
-
bar
-
baz
"
5
)
vec
!
[
"
foo
-
"
"
bar
-
"
"
baz
"
]
)
;
}
#
[
test
]
fn
hyphens_flag
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
The
-
-
foo
-
bar
flag
.
"
)
vec
!
[
"
The
"
"
-
-
foo
-
"
"
bar
"
"
flag
.
"
]
)
;
}
#
[
test
]
fn
repeated_hyphens
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
4
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foo
-
-
bar
"
)
vec
!
[
"
foo
-
-
bar
"
]
)
;
}
#
[
test
]
fn
hyphens_alphanumeric
(
)
{
assert_eq
!
(
wrap
(
"
Na2
-
CH4
"
5
)
vec
!
[
"
Na2
-
"
"
CH4
"
]
)
;
}
#
[
test
]
fn
hyphens_non_alphanumeric
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foo
(
-
)
bar
"
)
vec
!
[
"
foo
(
-
)
bar
"
]
)
;
}
#
[
test
]
fn
multiple_splits
(
)
{
assert_eq
!
(
wrap
(
"
foo
-
bar
-
baz
"
9
)
vec
!
[
"
foo
-
bar
-
"
"
baz
"
]
)
;
}
#
[
test
]
fn
forced_split
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foobar
-
baz
"
)
vec
!
[
"
foobar
-
"
"
baz
"
]
)
;
}
#
[
test
]
fn
no_hyphenation
(
)
{
let
wrapper
=
Wrapper
:
:
with_splitter
(
8
NoHyphenation
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
foo
bar
-
baz
"
)
vec
!
[
"
foo
"
"
bar
-
baz
"
]
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
fn
auto_hyphenation
(
)
{
let
corpus
=
hyphenation
:
:
load
(
Language
:
:
English_US
)
.
unwrap
(
)
;
let
wrapper
=
Wrapper
:
:
new
(
10
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
Internationalization
"
)
vec
!
[
"
Internatio
"
"
nalization
"
]
)
;
let
wrapper
=
Wrapper
:
:
with_splitter
(
10
corpus
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
Internationalization
"
)
vec
!
[
"
Interna
-
"
"
tionaliza
-
"
"
tion
"
]
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
fn
borrowed_lines
(
)
{
use
std
:
:
borrow
:
:
Cow
:
:
{
Borrowed
Owned
}
;
let
corpus
=
hyphenation
:
:
load
(
Language
:
:
English_US
)
.
unwrap
(
)
;
let
wrapper
=
Wrapper
:
:
with_splitter
(
10
corpus
)
;
let
lines
=
wrapper
.
wrap
(
"
Internationalization
"
)
;
if
let
Borrowed
(
s
)
=
lines
[
0
]
{
assert
!
(
false
"
should
not
have
been
borrowed
:
{
:
?
}
"
s
)
;
}
if
let
Borrowed
(
s
)
=
lines
[
1
]
{
assert
!
(
false
"
should
not
have
been
borrowed
:
{
:
?
}
"
s
)
;
}
if
let
Owned
(
ref
s
)
=
lines
[
2
]
{
assert
!
(
false
"
should
not
have
been
owned
:
{
:
?
}
"
s
)
;
}
}
#
[
test
]
#
[
cfg
(
feature
=
"
hyphenation
"
)
]
fn
auto_hyphenation_with_hyphen
(
)
{
let
corpus
=
hyphenation
:
:
load
(
Language
:
:
English_US
)
.
unwrap
(
)
;
let
wrapper
=
Wrapper
:
:
new
(
8
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
over
-
caffinated
"
)
vec
!
[
"
over
-
"
"
caffinated
"
]
)
;
let
wrapper
=
Wrapper
:
:
with_splitter
(
8
corpus
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
wrap
(
"
over
-
caffinated
"
)
vec
!
[
"
over
-
"
"
caffi
-
"
"
nated
"
]
)
;
}
#
[
test
]
fn
break_words
(
)
{
assert_eq
!
(
wrap
(
"
foobarbaz
"
3
)
vec
!
[
"
foo
"
"
bar
"
"
baz
"
]
)
;
}
#
[
test
]
fn
break_words_wide_characters
(
)
{
assert_eq
!
(
wrap
(
"
"
5
)
vec
!
[
"
"
"
"
"
"
]
)
;
}
#
[
test
]
fn
break_words_zero_width
(
)
{
assert_eq
!
(
wrap
(
"
foobar
"
0
)
vec
!
[
"
f
"
"
o
"
"
o
"
"
b
"
"
a
"
"
r
"
]
)
;
}
#
[
test
]
fn
test_non_breaking_space
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
fill
(
"
foo
bar
baz
"
)
"
foo
bar
baz
"
)
;
}
#
[
test
]
fn
test_non_breaking_hyphen
(
)
{
let
wrapper
=
Wrapper
:
:
new
(
5
)
.
break_words
(
false
)
;
assert_eq
!
(
wrapper
.
fill
(
"
foo
bar
baz
"
)
"
foo
bar
baz
"
)
;
}
#
[
test
]
fn
test_fill
(
)
{
assert_eq
!
(
fill
(
"
foo
bar
baz
"
10
)
"
foo
bar
\
nbaz
"
)
;
}
#
[
test
]
fn
test_indent_empty
(
)
{
assert_eq
!
(
indent
(
"
\
n
"
"
"
)
"
\
n
"
)
;
}
#
[
test
]
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
fn
test_indent_nonempty
(
)
{
let
x
=
vec
!
[
"
foo
"
"
bar
"
"
baz
"
]
;
let
y
=
vec
!
[
"
/
/
foo
"
"
/
/
bar
"
"
/
/
baz
"
]
;
assert_eq
!
(
indent
(
&
add_nl
(
&
x
)
"
/
/
"
)
add_nl
(
&
y
)
)
;
}
#
[
test
]
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
fn
test_indent_empty_line
(
)
{
let
x
=
vec
!
[
"
foo
"
"
bar
"
"
"
"
baz
"
]
;
let
y
=
vec
!
[
"
/
/
foo
"
"
/
/
bar
"
"
"
"
/
/
baz
"
]
;
assert_eq
!
(
indent
(
&
add_nl
(
&
x
)
"
/
/
"
)
add_nl
(
&
y
)
)
;
}
#
[
test
]
fn
test_dedent_empty
(
)
{
assert_eq
!
(
dedent
(
"
"
)
"
"
)
;
}
#
[
test
]
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
fn
test_dedent_multi_line
(
)
{
let
x
=
vec
!
[
"
foo
"
"
bar
"
"
baz
"
]
;
let
y
=
vec
!
[
"
foo
"
"
bar
"
"
baz
"
]
;
assert_eq
!
(
dedent
(
&
add_nl
(
&
x
)
)
add_nl
(
&
y
)
)
;
}
#
[
test
]
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
fn
test_dedent_empty_line
(
)
{
let
x
=
vec
!
[
"
foo
"
"
bar
"
"
"
"
baz
"
]
;
let
y
=
vec
!
[
"
foo
"
"
bar
"
"
"
"
baz
"
]
;
assert_eq
!
(
dedent
(
&
add_nl
(
&
x
)
)
add_nl
(
&
y
)
)
;
}
#
[
test
]
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
fn
test_dedent_mixed_whitespace
(
)
{
let
x
=
vec
!
[
"
\
tfoo
"
"
bar
"
]
;
let
y
=
vec
!
[
"
\
tfoo
"
"
bar
"
]
;
assert_eq
!
(
dedent
(
&
add_nl
(
&
x
)
)
add_nl
(
&
y
)
)
;
}
}
