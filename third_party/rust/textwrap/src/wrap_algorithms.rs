#
[
cfg
(
feature
=
"
smawk
"
)
]
mod
optimal_fit
;
#
[
cfg
(
feature
=
"
smawk
"
)
]
pub
use
optimal_fit
:
:
{
wrap_optimal_fit
OptimalFit
}
;
use
crate
:
:
core
:
:
{
Fragment
Word
}
;
pub
trait
WrapAlgorithm
:
WrapAlgorithmClone
+
std
:
:
fmt
:
:
Debug
{
fn
wrap
<
'
a
'
b
>
(
&
self
words
:
&
'
b
[
Word
<
'
a
>
]
line_widths
:
&
'
b
[
usize
]
)
-
>
Vec
<
&
'
b
[
Word
<
'
a
>
]
>
;
}
#
[
doc
(
hidden
)
]
pub
trait
WrapAlgorithmClone
{
fn
clone_box
(
&
self
)
-
>
Box
<
dyn
WrapAlgorithm
>
;
}
impl
<
T
:
WrapAlgorithm
+
Clone
+
'
static
>
WrapAlgorithmClone
for
T
{
fn
clone_box
(
&
self
)
-
>
Box
<
dyn
WrapAlgorithm
>
{
Box
:
:
new
(
self
.
clone
(
)
)
}
}
impl
Clone
for
Box
<
dyn
WrapAlgorithm
>
{
fn
clone
(
&
self
)
-
>
Box
<
dyn
WrapAlgorithm
>
{
use
std
:
:
ops
:
:
Deref
;
self
.
deref
(
)
.
clone_box
(
)
}
}
impl
WrapAlgorithm
for
Box
<
dyn
WrapAlgorithm
>
{
fn
wrap
<
'
a
'
b
>
(
&
self
words
:
&
'
b
[
Word
<
'
a
>
]
line_widths
:
&
'
b
[
usize
]
)
-
>
Vec
<
&
'
b
[
Word
<
'
a
>
]
>
{
use
std
:
:
ops
:
:
Deref
;
self
.
deref
(
)
.
wrap
(
words
line_widths
)
}
}
#
[
derive
(
Clone
Copy
Debug
Default
)
]
pub
struct
FirstFit
;
impl
WrapAlgorithm
for
FirstFit
{
#
[
inline
]
fn
wrap
<
'
a
'
b
>
(
&
self
words
:
&
'
b
[
Word
<
'
a
>
]
line_widths
:
&
'
b
[
usize
]
)
-
>
Vec
<
&
'
b
[
Word
<
'
a
>
]
>
{
wrap_first_fit
(
words
line_widths
)
}
}
pub
fn
wrap_first_fit
<
'
a
'
b
T
:
Fragment
>
(
fragments
:
&
'
a
[
T
]
line_widths
:
&
'
b
[
usize
]
)
-
>
Vec
<
&
'
a
[
T
]
>
{
let
default_line_width
=
line_widths
.
last
(
)
.
copied
(
)
.
unwrap_or
(
0
)
;
let
mut
lines
=
Vec
:
:
new
(
)
;
let
mut
start
=
0
;
let
mut
width
=
0
;
for
(
idx
fragment
)
in
fragments
.
iter
(
)
.
enumerate
(
)
{
let
line_width
=
line_widths
.
get
(
lines
.
len
(
)
)
.
copied
(
)
.
unwrap_or
(
default_line_width
)
;
if
width
+
fragment
.
width
(
)
+
fragment
.
penalty_width
(
)
>
line_width
&
&
idx
>
start
{
lines
.
push
(
&
fragments
[
start
.
.
idx
]
)
;
start
=
idx
;
width
=
0
;
}
width
+
=
fragment
.
width
(
)
+
fragment
.
whitespace_width
(
)
;
}
lines
.
push
(
&
fragments
[
start
.
.
]
)
;
lines
}
