use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
tracing_subscriber
:
:
fmt
:
:
MakeWriter
;
#
[
derive
(
Debug
Clone
)
]
struct
TestWriter
{
buf
:
Arc
<
Mutex
<
Vec
<
u8
>
>
>
}
impl
TestWriter
{
fn
new
(
)
-
>
Self
{
Self
{
buf
:
Arc
:
:
new
(
Mutex
:
:
new
(
Vec
:
:
new
(
)
)
)
}
}
fn
get_output
(
&
self
)
-
>
String
{
let
buf
=
self
.
buf
.
lock
(
)
.
unwrap
(
)
;
String
:
:
from_utf8_lossy
(
&
buf
)
.
to_string
(
)
}
}
impl
std
:
:
io
:
:
Write
for
TestWriter
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
self
.
buf
.
lock
(
)
.
unwrap
(
)
.
extend_from_slice
(
buf
)
;
Ok
(
buf
.
len
(
)
)
}
fn
flush
(
&
mut
self
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
impl
<
'
a
>
MakeWriter
<
'
a
>
for
TestWriter
{
type
Writer
=
TestWriter
;
fn
make_writer
(
&
'
a
self
)
-
>
Self
:
:
Writer
{
self
.
clone
(
)
}
}
#
[
test
]
fn
test_error_ansi_escaping
(
)
{
use
std
:
:
fmt
;
#
[
derive
(
Debug
)
]
struct
MaliciousError
(
&
'
static
str
)
;
impl
fmt
:
:
Display
for
MaliciousError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
0
)
}
}
impl
std
:
:
error
:
:
Error
for
MaliciousError
{
}
let
writer
=
TestWriter
:
:
new
(
)
;
let
subscriber
=
tracing_subscriber
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
writer
.
clone
(
)
)
.
with_ansi
(
false
)
.
without_time
(
)
.
with_target
(
false
)
.
with_level
(
false
)
.
finish
(
)
;
tracing
:
:
subscriber
:
:
with_default
(
subscriber
|
|
{
let
malicious_error
=
MaliciousError
(
"
\
x1b
]
0
;
PWNED
\
x07
\
x1b
[
2J
\
x08
\
x0c
\
x7f
"
)
;
tracing
:
:
error
!
(
error
=
%
malicious_error
"
An
error
occurred
"
)
;
}
)
;
let
output
=
writer
.
get_output
(
)
;
assert
!
(
output
.
contains
(
"
An
error
occurred
"
)
"
Error
message
should
be
logged
"
)
;
}
#
[
test
]
fn
test_message_ansi_escaping
(
)
{
let
writer
=
TestWriter
:
:
new
(
)
;
let
subscriber
=
tracing_subscriber
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
writer
.
clone
(
)
)
.
with_ansi
(
false
)
.
without_time
(
)
.
with_target
(
false
)
.
with_level
(
false
)
.
finish
(
)
;
tracing
:
:
subscriber
:
:
with_default
(
subscriber
|
|
{
let
malicious_input
=
"
\
x1b
]
0
;
PWNED
\
x07
\
x1b
[
2J
\
x08
\
x0c
\
x7f
"
;
tracing
:
:
info
!
(
"
User
input
:
{
}
"
malicious_input
)
;
}
)
;
let
output
=
writer
.
get_output
(
)
;
assert
!
(
!
output
.
contains
(
'
\
x1b
'
)
"
Message
output
should
not
contain
raw
ESC
characters
"
)
;
assert
!
(
!
output
.
contains
(
'
\
x07
'
)
"
Message
output
should
not
contain
raw
BEL
characters
"
)
;
}
#
[
cfg
(
feature
=
"
json
"
)
]
#
[
test
]
fn
test_json_ansi_escaping
(
)
{
let
writer
=
TestWriter
:
:
new
(
)
;
let
subscriber
=
tracing_subscriber
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
json
(
)
.
with_writer
(
writer
.
clone
(
)
)
.
finish
(
)
;
tracing
:
:
subscriber
:
:
with_default
(
subscriber
|
|
{
let
malicious_input
=
"
\
x1b
]
0
;
PWNED
\
x07
\
x1b
[
2J
"
;
tracing
:
:
info
!
(
"
Testing
:
{
}
"
malicious_input
)
;
tracing
:
:
info
!
(
user_input
=
%
malicious_input
"
Field
test
"
)
;
}
)
;
let
output
=
writer
.
get_output
(
)
;
assert
!
(
!
output
.
contains
(
'
\
x1b
'
)
"
JSON
output
should
not
contain
raw
ESC
characters
"
)
;
assert
!
(
!
output
.
contains
(
'
\
x07
'
)
"
JSON
output
should
not
contain
raw
BEL
characters
"
)
;
}
#
[
cfg
(
feature
=
"
ansi
"
)
]
#
[
test
]
fn
test_pretty_ansi_escaping
(
)
{
let
writer
=
TestWriter
:
:
new
(
)
;
let
subscriber
=
tracing_subscriber
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
pretty
(
)
.
with_writer
(
writer
.
clone
(
)
)
.
with_ansi
(
false
)
.
without_time
(
)
.
with_target
(
false
)
.
finish
(
)
;
tracing
:
:
subscriber
:
:
with_default
(
subscriber
|
|
{
let
malicious_input
=
"
\
x1b
]
0
;
PWNED
\
x07
\
x1b
[
2J
"
;
tracing
:
:
info
!
(
"
Testing
:
{
}
"
malicious_input
)
;
}
)
;
let
output
=
writer
.
get_output
(
)
;
assert
!
(
!
output
.
contains
(
'
\
x1b
'
)
"
Pretty
output
should
not
contain
raw
ESC
characters
"
)
;
assert
!
(
!
output
.
contains
(
'
\
x07
'
)
"
Pretty
output
should
not
contain
raw
BEL
characters
"
)
;
}
#
[
test
]
fn
ansi_sanitization_prevents_injection
(
)
{
let
writer
=
TestWriter
:
:
new
(
)
;
let
subscriber
=
tracing_subscriber
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
writer
.
clone
(
)
)
.
with_ansi
(
false
)
.
without_time
(
)
.
with_target
(
false
)
.
with_level
(
false
)
.
finish
(
)
;
#
[
derive
(
Debug
)
]
struct
MaliciousError
{
content
:
String
}
impl
std
:
:
fmt
:
:
Display
for
MaliciousError
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Error
:
{
}
"
self
.
content
)
}
}
tracing
:
:
subscriber
:
:
with_default
(
subscriber
|
|
{
let
malicious_field_value
=
"
\
x1b
]
0
;
PWNED
\
x07
\
x1b
[
2J
"
;
tracing
:
:
error
!
(
malicious_field
=
malicious_field_value
"
Field
test
"
)
;
let
malicious_error
=
MaliciousError
{
content
:
"
\
x1b
]
0
;
PWNED
\
x07
\
x1b
[
2J
"
.
to_string
(
)
}
;
tracing
:
:
error
!
(
"
{
}
"
malicious_error
)
;
}
)
;
let
output
=
writer
.
get_output
(
)
;
assert
!
(
output
.
contains
(
"
\
\
u
{
1b
}
"
)
"
Field
values
should
be
escaped
by
Debug
formatting
"
)
;
assert
!
(
output
.
contains
(
"
\
\
x1b
"
)
"
Message
content
should
be
sanitized
"
)
;
assert
!
(
!
output
.
contains
(
"
\
x1b
]
0
;
PWNED
"
)
"
Message
content
should
not
contain
raw
ANSI
sequences
"
)
;
assert
!
(
!
output
.
contains
(
"
\
x07
"
)
"
Message
content
should
not
contain
raw
control
characters
"
)
;
}
#
[
test
]
fn
test_c1_control_characters_escaping
(
)
{
let
writer
=
TestWriter
:
:
new
(
)
;
let
subscriber
=
tracing_subscriber
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
writer
.
clone
(
)
)
.
with_ansi
(
false
)
.
without_time
(
)
.
with_target
(
false
)
.
with_level
(
false
)
.
finish
(
)
;
tracing
:
:
subscriber
:
:
with_default
(
subscriber
|
|
{
let
c1_controls
=
"
\
u
{
80
}
\
u
{
85
}
\
u
{
90
}
\
u
{
9b
}
\
u
{
9c
}
\
u
{
9d
}
\
u
{
9e
}
\
u
{
9f
}
"
;
tracing
:
:
info
!
(
"
C1
controls
:
{
}
"
c1_controls
)
;
}
)
;
let
output
=
writer
.
get_output
(
)
;
assert
!
(
!
output
.
contains
(
'
\
u
{
80
}
'
)
"
Output
should
not
contain
raw
C1
control
characters
"
)
;
assert
!
(
!
output
.
contains
(
'
\
u
{
9b
}
'
)
"
Output
should
not
contain
raw
CSI
character
"
)
;
assert
!
(
!
output
.
contains
(
'
\
u
{
9c
}
'
)
"
Output
should
not
contain
raw
ST
character
"
)
;
assert
!
(
output
.
contains
(
"
\
\
u
{
80
}
"
)
|
|
output
.
contains
(
"
\
\
u
{
8
"
)
"
Should
contain
escaped
C1
characters
"
)
;
}
