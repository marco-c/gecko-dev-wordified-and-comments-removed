use
std
:
:
sync
:
:
{
atomic
:
:
{
AtomicUsize
Ordering
}
Arc
}
;
use
tracing_mock
:
:
{
expect
layer
}
;
use
tracing_subscriber
:
:
{
filter
prelude
:
:
*
Layer
}
;
#
[
test
]
fn
none_interest_cache
(
)
{
let
(
layer_none
handle_none
)
=
layer
:
:
mock
(
)
.
event
(
expect
:
:
event
(
)
)
.
event
(
expect
:
:
event
(
)
)
.
only
(
)
.
run_with_handle
(
)
;
let
layer_none
=
layer_none
.
with_filter
(
None
:
:
<
filter
:
:
DynFilterFn
<
_
>
>
)
;
let
times_filtered
=
Arc
:
:
new
(
AtomicUsize
:
:
new
(
0
)
)
;
let
(
layer_filter_fn
handle_filter_fn
)
=
layer
:
:
mock
(
)
.
event
(
expect
:
:
event
(
)
)
.
event
(
expect
:
:
event
(
)
)
.
only
(
)
.
run_with_handle
(
)
;
let
layer_filter_fn
=
layer_filter_fn
.
with_filter
(
filter
:
:
filter_fn
(
{
let
times_filtered
=
Arc
:
:
clone
(
&
times_filtered
)
;
move
|
_
|
{
times_filtered
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
true
}
}
)
)
;
let
subscriber
=
tracing_subscriber
:
:
registry
(
)
.
with
(
layer_none
)
.
with
(
layer_filter_fn
)
;
let
_guard
=
subscriber
.
set_default
(
)
;
for
_
in
0
.
.
2
{
tracing
:
:
debug
!
(
target
:
"
always_interesting
"
x
=
"
bar
"
)
;
}
assert_eq
!
(
times_filtered
.
load
(
Ordering
:
:
Relaxed
)
1
)
;
handle_none
.
assert_finished
(
)
;
handle_filter_fn
.
assert_finished
(
)
;
}
