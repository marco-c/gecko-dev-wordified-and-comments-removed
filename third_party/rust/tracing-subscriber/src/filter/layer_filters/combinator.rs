use
crate
:
:
layer
:
:
{
Context
Filter
}
;
use
std
:
:
{
cmp
fmt
marker
:
:
PhantomData
}
;
use
tracing_core
:
:
{
span
:
:
{
Attributes
Id
Record
}
subscriber
:
:
Interest
LevelFilter
Metadata
}
;
pub
struct
And
<
A
B
S
>
{
a
:
A
b
:
B
_s
:
PhantomData
<
fn
(
S
)
>
}
pub
struct
Or
<
A
B
S
>
{
a
:
A
b
:
B
_s
:
PhantomData
<
fn
(
S
)
>
}
pub
struct
Not
<
A
S
>
{
a
:
A
_s
:
PhantomData
<
fn
(
S
)
>
}
impl
<
A
B
S
>
And
<
A
B
S
>
where
A
:
Filter
<
S
>
B
:
Filter
<
S
>
{
pub
(
crate
)
fn
new
(
a
:
A
b
:
B
)
-
>
Self
{
Self
{
a
b
_s
:
PhantomData
}
}
}
impl
<
A
B
S
>
Filter
<
S
>
for
And
<
A
B
S
>
where
A
:
Filter
<
S
>
B
:
Filter
<
S
>
{
#
[
inline
]
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
a
.
enabled
(
meta
cx
)
&
&
self
.
b
.
enabled
(
meta
cx
)
}
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
let
a
=
self
.
a
.
callsite_enabled
(
meta
)
;
if
a
.
is_never
(
)
{
return
a
;
}
let
b
=
self
.
b
.
callsite_enabled
(
meta
)
;
if
!
b
.
is_always
(
)
{
return
b
;
}
a
}
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
cmp
:
:
min
(
self
.
a
.
max_level_hint
(
)
self
.
b
.
max_level_hint
(
)
)
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
tracing_core
:
:
Event
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
a
.
event_enabled
(
event
cx
)
&
&
self
.
b
.
event_enabled
(
event
cx
)
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
Attributes
<
'
_
>
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_new_span
(
attrs
id
ctx
.
clone
(
)
)
;
self
.
b
.
on_new_span
(
attrs
id
ctx
)
}
#
[
inline
]
fn
on_record
(
&
self
id
:
&
Id
values
:
&
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_record
(
id
values
ctx
.
clone
(
)
)
;
self
.
b
.
on_record
(
id
values
ctx
)
;
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_enter
(
id
ctx
.
clone
(
)
)
;
self
.
b
.
on_enter
(
id
ctx
)
;
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_exit
(
id
ctx
.
clone
(
)
)
;
self
.
b
.
on_exit
(
id
ctx
)
;
}
#
[
inline
]
fn
on_close
(
&
self
id
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_close
(
id
.
clone
(
)
ctx
.
clone
(
)
)
;
self
.
b
.
on_close
(
id
ctx
)
;
}
}
impl
<
A
B
S
>
Clone
for
And
<
A
B
S
>
where
A
:
Clone
B
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
Self
{
a
:
self
.
a
.
clone
(
)
b
:
self
.
b
.
clone
(
)
_s
:
PhantomData
}
}
}
impl
<
A
B
S
>
fmt
:
:
Debug
for
And
<
A
B
S
>
where
A
:
fmt
:
:
Debug
B
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
And
"
)
.
field
(
"
a
"
&
self
.
a
)
.
field
(
"
b
"
&
self
.
b
)
.
finish
(
)
}
}
impl
<
A
B
S
>
Or
<
A
B
S
>
where
A
:
Filter
<
S
>
B
:
Filter
<
S
>
{
pub
(
crate
)
fn
new
(
a
:
A
b
:
B
)
-
>
Self
{
Self
{
a
b
_s
:
PhantomData
}
}
}
impl
<
A
B
S
>
Filter
<
S
>
for
Or
<
A
B
S
>
where
A
:
Filter
<
S
>
B
:
Filter
<
S
>
{
#
[
inline
]
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
a
.
enabled
(
meta
cx
)
|
|
self
.
b
.
enabled
(
meta
cx
)
}
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
let
a
=
self
.
a
.
callsite_enabled
(
meta
)
;
let
b
=
self
.
b
.
callsite_enabled
(
meta
)
;
if
a
.
is_always
(
)
|
|
b
.
is_always
(
)
{
return
Interest
:
:
always
(
)
;
}
if
a
.
is_sometimes
(
)
|
|
b
.
is_sometimes
(
)
{
return
Interest
:
:
sometimes
(
)
;
}
debug_assert
!
(
a
.
is_never
(
)
&
&
b
.
is_never
(
)
"
if
neither
filter
was
always
or
sometimes
both
must
be
never
(
a
=
{
:
?
}
;
b
=
{
:
?
}
)
"
a
b
)
;
Interest
:
:
never
(
)
}
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
Some
(
cmp
:
:
max
(
self
.
a
.
max_level_hint
(
)
?
self
.
b
.
max_level_hint
(
)
?
)
)
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
tracing_core
:
:
Event
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
a
.
event_enabled
(
event
cx
)
|
|
self
.
b
.
event_enabled
(
event
cx
)
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
Attributes
<
'
_
>
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_new_span
(
attrs
id
ctx
.
clone
(
)
)
;
self
.
b
.
on_new_span
(
attrs
id
ctx
)
}
#
[
inline
]
fn
on_record
(
&
self
id
:
&
Id
values
:
&
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_record
(
id
values
ctx
.
clone
(
)
)
;
self
.
b
.
on_record
(
id
values
ctx
)
;
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_enter
(
id
ctx
.
clone
(
)
)
;
self
.
b
.
on_enter
(
id
ctx
)
;
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_exit
(
id
ctx
.
clone
(
)
)
;
self
.
b
.
on_exit
(
id
ctx
)
;
}
#
[
inline
]
fn
on_close
(
&
self
id
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_close
(
id
.
clone
(
)
ctx
.
clone
(
)
)
;
self
.
b
.
on_close
(
id
ctx
)
;
}
}
impl
<
A
B
S
>
Clone
for
Or
<
A
B
S
>
where
A
:
Clone
B
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
Self
{
a
:
self
.
a
.
clone
(
)
b
:
self
.
b
.
clone
(
)
_s
:
PhantomData
}
}
}
impl
<
A
B
S
>
fmt
:
:
Debug
for
Or
<
A
B
S
>
where
A
:
fmt
:
:
Debug
B
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Or
"
)
.
field
(
"
a
"
&
self
.
a
)
.
field
(
"
b
"
&
self
.
b
)
.
finish
(
)
}
}
impl
<
A
S
>
Not
<
A
S
>
where
A
:
Filter
<
S
>
{
pub
(
crate
)
fn
new
(
a
:
A
)
-
>
Self
{
Self
{
a
_s
:
PhantomData
}
}
}
impl
<
A
S
>
Filter
<
S
>
for
Not
<
A
S
>
where
A
:
Filter
<
S
>
{
#
[
inline
]
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
!
self
.
a
.
enabled
(
meta
cx
)
}
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
match
self
.
a
.
callsite_enabled
(
meta
)
{
i
if
i
.
is_always
(
)
=
>
Interest
:
:
never
(
)
i
if
i
.
is_never
(
)
=
>
Interest
:
:
always
(
)
_
=
>
Interest
:
:
sometimes
(
)
}
}
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
None
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
tracing_core
:
:
Event
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
let
_
=
(
event
cx
)
;
true
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
Attributes
<
'
_
>
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_new_span
(
attrs
id
ctx
)
;
}
#
[
inline
]
fn
on_record
(
&
self
id
:
&
Id
values
:
&
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_record
(
id
values
ctx
.
clone
(
)
)
;
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_enter
(
id
ctx
)
;
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_exit
(
id
ctx
)
;
}
#
[
inline
]
fn
on_close
(
&
self
id
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
a
.
on_close
(
id
ctx
)
;
}
}
impl
<
A
S
>
Clone
for
Not
<
A
S
>
where
A
:
Clone
{
fn
clone
(
&
self
)
-
>
Self
{
Self
{
a
:
self
.
a
.
clone
(
)
_s
:
PhantomData
}
}
}
impl
<
A
S
>
fmt
:
:
Debug
for
Not
<
A
S
>
where
A
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
Not
"
)
.
field
(
&
self
.
a
)
.
finish
(
)
}
}
