use
crate
:
:
{
filter
:
:
LevelFilter
layer
:
:
{
self
Context
Layer
}
registry
}
;
use
std
:
:
{
any
:
:
TypeId
cell
:
:
{
Cell
RefCell
}
fmt
marker
:
:
PhantomData
ops
:
:
Deref
sync
:
:
Arc
thread_local
}
;
use
tracing_core
:
:
{
span
subscriber
:
:
{
Interest
Subscriber
}
Dispatch
Event
Metadata
}
;
pub
mod
combinator
;
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
registry
"
)
)
)
]
#
[
derive
(
Clone
)
]
pub
struct
Filtered
<
L
F
S
>
{
filter
:
F
layer
:
L
id
:
MagicPlfDowncastMarker
_s
:
PhantomData
<
fn
(
S
)
>
}
#
[
cfg
(
feature
=
"
registry
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
registry
"
)
)
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
FilterId
(
u64
)
;
#
[
derive
(
Copy
Clone
Eq
PartialEq
)
]
pub
(
crate
)
struct
FilterMap
{
bits
:
u64
}
impl
FilterMap
{
pub
(
crate
)
const
fn
new
(
)
-
>
Self
{
Self
{
bits
:
0
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
FilterState
{
enabled
:
Cell
<
FilterMap
>
interest
:
RefCell
<
Option
<
Interest
>
>
#
[
cfg
(
debug_assertions
)
]
counters
:
DebugCounters
}
#
[
cfg
(
debug_assertions
)
]
#
[
derive
(
Debug
)
]
struct
DebugCounters
{
in_filter_pass
:
Cell
<
usize
>
in_interest_pass
:
Cell
<
usize
>
}
#
[
cfg
(
debug_assertions
)
]
impl
DebugCounters
{
const
fn
new
(
)
-
>
Self
{
Self
{
in_filter_pass
:
Cell
:
:
new
(
0
)
in_interest_pass
:
Cell
:
:
new
(
0
)
}
}
}
thread_local
!
{
pub
(
crate
)
static
FILTERING
:
FilterState
=
const
{
FilterState
:
:
new
(
)
}
;
}
pub
trait
FilterExt
<
S
>
:
layer
:
:
Filter
<
S
>
{
fn
and
<
B
>
(
self
other
:
B
)
-
>
combinator
:
:
And
<
Self
B
S
>
where
Self
:
Sized
B
:
layer
:
:
Filter
<
S
>
{
combinator
:
:
And
:
:
new
(
self
other
)
}
fn
or
<
B
>
(
self
other
:
B
)
-
>
combinator
:
:
Or
<
Self
B
S
>
where
Self
:
Sized
B
:
layer
:
:
Filter
<
S
>
{
combinator
:
:
Or
:
:
new
(
self
other
)
}
fn
not
(
self
)
-
>
combinator
:
:
Not
<
Self
S
>
where
Self
:
Sized
{
combinator
:
:
Not
:
:
new
(
self
)
}
fn
boxed
(
self
)
-
>
Box
<
dyn
layer
:
:
Filter
<
S
>
+
Send
+
Sync
+
'
static
>
where
Self
:
Sized
+
Send
+
Sync
+
'
static
{
Box
:
:
new
(
self
)
}
}
#
[
cfg
(
feature
=
"
registry
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
registry
"
)
)
)
]
impl
<
S
>
layer
:
:
Filter
<
S
>
for
LevelFilter
{
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
_
:
&
Context
<
'
_
S
>
)
-
>
bool
{
meta
.
level
(
)
<
=
self
}
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
if
meta
.
level
(
)
<
=
self
{
Interest
:
:
always
(
)
}
else
{
Interest
:
:
never
(
)
}
}
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
Some
(
*
self
)
}
}
macro_rules
!
filter_impl_body
{
(
)
=
>
{
#
[
inline
]
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
deref
(
)
.
enabled
(
meta
cx
)
}
#
[
inline
]
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
self
.
deref
(
)
.
callsite_enabled
(
meta
)
}
#
[
inline
]
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
self
.
deref
(
)
.
max_level_hint
(
)
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
deref
(
)
.
event_enabled
(
event
cx
)
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_new_span
(
attrs
id
ctx
)
}
#
[
inline
]
fn
on_record
(
&
self
id
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_record
(
id
values
ctx
)
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_enter
(
id
ctx
)
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_exit
(
id
ctx
)
}
#
[
inline
]
fn
on_close
(
&
self
id
:
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_close
(
id
ctx
)
}
}
;
}
#
[
cfg
(
feature
=
"
registry
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
registry
"
)
)
)
]
impl
<
S
>
layer
:
:
Filter
<
S
>
for
Arc
<
dyn
layer
:
:
Filter
<
S
>
+
Send
+
Sync
+
'
static
>
{
filter_impl_body
!
(
)
;
}
#
[
cfg
(
feature
=
"
registry
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
registry
"
)
)
)
]
impl
<
S
>
layer
:
:
Filter
<
S
>
for
Box
<
dyn
layer
:
:
Filter
<
S
>
+
Send
+
Sync
+
'
static
>
{
filter_impl_body
!
(
)
;
}
#
[
cfg
(
feature
=
"
registry
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
registry
"
)
)
)
]
impl
<
F
S
>
layer
:
:
Filter
<
S
>
for
Option
<
F
>
where
F
:
layer
:
:
Filter
<
S
>
{
#
[
inline
]
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
ctx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
enabled
(
meta
ctx
)
)
.
unwrap_or
(
true
)
}
#
[
inline
]
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
callsite_enabled
(
meta
)
)
.
unwrap_or_else
(
Interest
:
:
always
)
}
#
[
inline
]
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
self
.
as_ref
(
)
.
and_then
(
|
inner
|
inner
.
max_level_hint
(
)
)
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
self
.
as_ref
(
)
.
map
(
|
inner
|
inner
.
event_enabled
(
event
ctx
)
)
.
unwrap_or
(
true
)
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
inner
)
=
self
{
inner
.
on_new_span
(
attrs
id
ctx
)
}
}
#
[
inline
]
fn
on_record
(
&
self
id
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
inner
)
=
self
{
inner
.
on_record
(
id
values
ctx
)
}
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
inner
)
=
self
{
inner
.
on_enter
(
id
ctx
)
}
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
inner
)
=
self
{
inner
.
on_exit
(
id
ctx
)
}
}
#
[
inline
]
fn
on_close
(
&
self
id
:
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
inner
)
=
self
{
inner
.
on_close
(
id
ctx
)
}
}
}
impl
<
L
F
S
>
Filtered
<
L
F
S
>
{
pub
fn
new
(
layer
:
L
filter
:
F
)
-
>
Self
{
Self
{
layer
filter
id
:
MagicPlfDowncastMarker
(
FilterId
:
:
disabled
(
)
)
_s
:
PhantomData
}
}
#
[
inline
(
always
)
]
fn
id
(
&
self
)
-
>
FilterId
{
debug_assert
!
(
!
self
.
id
.
0
.
is_disabled
(
)
"
a
Filtered
layer
was
used
but
it
had
no
FilterId
;
\
was
it
registered
with
the
subscriber
?
"
)
;
self
.
id
.
0
}
fn
did_enable
(
&
self
f
:
impl
FnOnce
(
)
)
{
FILTERING
.
with
(
|
filtering
|
filtering
.
did_enable
(
self
.
id
(
)
f
)
)
}
pub
fn
filter
(
&
self
)
-
>
&
F
{
&
self
.
filter
}
pub
fn
filter_mut
(
&
mut
self
)
-
>
&
mut
F
{
&
mut
self
.
filter
}
pub
fn
inner
(
&
self
)
-
>
&
L
{
&
self
.
layer
}
pub
fn
inner_mut
(
&
mut
self
)
-
>
&
mut
L
{
&
mut
self
.
layer
}
}
impl
<
S
L
F
>
Layer
<
S
>
for
Filtered
<
L
F
S
>
where
S
:
Subscriber
+
for
<
'
span
>
registry
:
:
LookupSpan
<
'
span
>
+
'
static
F
:
layer
:
:
Filter
<
S
>
+
'
static
L
:
Layer
<
S
>
{
fn
on_register_dispatch
(
&
self
subscriber
:
&
Dispatch
)
{
self
.
layer
.
on_register_dispatch
(
subscriber
)
;
}
fn
on_layer
(
&
mut
self
subscriber
:
&
mut
S
)
{
self
.
id
=
MagicPlfDowncastMarker
(
subscriber
.
register_filter
(
)
)
;
self
.
layer
.
on_layer
(
subscriber
)
;
}
fn
register_callsite
(
&
self
metadata
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
let
interest
=
self
.
filter
.
callsite_enabled
(
metadata
)
;
if
!
interest
.
is_never
(
)
{
self
.
layer
.
register_callsite
(
metadata
)
;
}
FILTERING
.
with
(
|
filtering
|
filtering
.
add_interest
(
interest
)
)
;
Interest
:
:
always
(
)
}
fn
enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
cx
:
Context
<
'
_
S
>
)
-
>
bool
{
let
cx
=
cx
.
with_filter
(
self
.
id
(
)
)
;
let
enabled
=
self
.
filter
.
enabled
(
metadata
&
cx
)
;
FILTERING
.
with
(
|
filtering
|
filtering
.
set
(
self
.
id
(
)
enabled
)
)
;
if
enabled
{
self
.
layer
.
enabled
(
metadata
cx
)
}
else
{
true
}
}
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
cx
:
Context
<
'
_
S
>
)
{
self
.
did_enable
(
|
|
{
let
cx
=
cx
.
with_filter
(
self
.
id
(
)
)
;
self
.
filter
.
on_new_span
(
attrs
id
cx
.
clone
(
)
)
;
self
.
layer
.
on_new_span
(
attrs
id
cx
)
;
}
)
}
#
[
doc
(
hidden
)
]
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
self
.
filter
.
max_level_hint
(
)
}
fn
on_record
(
&
self
span
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
cx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
cx
)
=
cx
.
if_enabled_for
(
span
self
.
id
(
)
)
{
self
.
filter
.
on_record
(
span
values
cx
.
clone
(
)
)
;
self
.
layer
.
on_record
(
span
values
cx
)
}
}
fn
on_follows_from
(
&
self
span
:
&
span
:
:
Id
follows
:
&
span
:
:
Id
cx
:
Context
<
'
_
S
>
)
{
if
cx
.
is_enabled_for
(
span
self
.
id
(
)
)
&
&
cx
.
is_enabled_for
(
follows
self
.
id
(
)
)
{
self
.
layer
.
on_follows_from
(
span
follows
cx
.
with_filter
(
self
.
id
(
)
)
)
}
}
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
cx
:
Context
<
'
_
S
>
)
-
>
bool
{
let
cx
=
cx
.
with_filter
(
self
.
id
(
)
)
;
let
enabled
=
FILTERING
.
with
(
|
filtering
|
filtering
.
and
(
self
.
id
(
)
|
|
self
.
filter
.
event_enabled
(
event
&
cx
)
)
)
;
if
enabled
{
self
.
layer
.
event_enabled
(
event
cx
)
}
else
{
true
}
}
fn
on_event
(
&
self
event
:
&
Event
<
'
_
>
cx
:
Context
<
'
_
S
>
)
{
self
.
did_enable
(
|
|
{
self
.
layer
.
on_event
(
event
cx
.
with_filter
(
self
.
id
(
)
)
)
;
}
)
}
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
cx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
cx
)
=
cx
.
if_enabled_for
(
id
self
.
id
(
)
)
{
self
.
filter
.
on_enter
(
id
cx
.
clone
(
)
)
;
self
.
layer
.
on_enter
(
id
cx
)
;
}
}
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
cx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
cx
)
=
cx
.
if_enabled_for
(
id
self
.
id
(
)
)
{
self
.
filter
.
on_exit
(
id
cx
.
clone
(
)
)
;
self
.
layer
.
on_exit
(
id
cx
)
;
}
}
fn
on_close
(
&
self
id
:
span
:
:
Id
cx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
cx
)
=
cx
.
if_enabled_for
(
&
id
self
.
id
(
)
)
{
self
.
filter
.
on_close
(
id
.
clone
(
)
cx
.
clone
(
)
)
;
self
.
layer
.
on_close
(
id
cx
)
;
}
}
fn
on_id_change
(
&
self
old
:
&
span
:
:
Id
new
:
&
span
:
:
Id
cx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
cx
)
=
cx
.
if_enabled_for
(
old
self
.
id
(
)
)
{
self
.
layer
.
on_id_change
(
old
new
cx
)
}
}
#
[
doc
(
hidden
)
]
#
[
inline
]
unsafe
fn
downcast_raw
(
&
self
id
:
TypeId
)
-
>
Option
<
*
const
(
)
>
{
match
id
{
id
if
id
=
=
TypeId
:
:
of
:
:
<
Self
>
(
)
=
>
Some
(
self
as
*
const
_
as
*
const
(
)
)
id
if
id
=
=
TypeId
:
:
of
:
:
<
L
>
(
)
=
>
Some
(
&
self
.
layer
as
*
const
_
as
*
const
(
)
)
id
if
id
=
=
TypeId
:
:
of
:
:
<
F
>
(
)
=
>
Some
(
&
self
.
filter
as
*
const
_
as
*
const
(
)
)
id
if
id
=
=
TypeId
:
:
of
:
:
<
MagicPlfDowncastMarker
>
(
)
=
>
{
Some
(
&
self
.
id
as
*
const
_
as
*
const
(
)
)
}
_
=
>
self
.
layer
.
downcast_raw
(
id
)
}
}
}
impl
<
F
L
S
>
fmt
:
:
Debug
for
Filtered
<
F
L
S
>
where
F
:
fmt
:
:
Debug
L
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Filtered
"
)
.
field
(
"
filter
"
&
self
.
filter
)
.
field
(
"
layer
"
&
self
.
layer
)
.
field
(
"
id
"
&
self
.
id
)
.
finish
(
)
}
}
impl
FilterId
{
const
fn
disabled
(
)
-
>
Self
{
Self
(
u64
:
:
MAX
)
}
pub
(
crate
)
const
fn
none
(
)
-
>
Self
{
Self
(
0
)
}
pub
(
crate
)
fn
new
(
id
:
u8
)
-
>
Self
{
assert
!
(
id
<
64
"
filter
IDs
may
not
be
greater
than
64
"
)
;
Self
(
1
<
<
id
as
usize
)
}
pub
(
crate
)
fn
and
(
self
FilterId
(
other
)
:
Self
)
-
>
Self
{
if
self
.
0
=
=
Self
:
:
disabled
(
)
.
0
{
return
Self
(
other
)
;
}
Self
(
self
.
0
|
other
)
}
fn
is_disabled
(
self
)
-
>
bool
{
self
.
0
=
=
Self
:
:
disabled
(
)
.
0
}
}
impl
fmt
:
:
Debug
for
FilterId
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
if
self
.
0
=
=
Self
:
:
disabled
(
)
.
0
{
return
f
.
debug_tuple
(
"
FilterId
"
)
.
field
(
&
format_args
!
(
"
DISABLED
"
)
)
.
finish
(
)
;
}
if
f
.
alternate
(
)
{
f
.
debug_struct
(
"
FilterId
"
)
.
field
(
"
ids
"
&
format_args
!
(
"
{
:
?
}
"
FmtBitset
(
self
.
0
)
)
)
.
field
(
"
bits
"
&
format_args
!
(
"
{
:
b
}
"
self
.
0
)
)
.
finish
(
)
}
else
{
f
.
debug_tuple
(
"
FilterId
"
)
.
field
(
&
FmtBitset
(
self
.
0
)
)
.
finish
(
)
}
}
}
impl
fmt
:
:
Binary
for
FilterId
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
FilterId
"
)
.
field
(
&
format_args
!
(
"
{
:
b
}
"
self
.
0
)
)
.
finish
(
)
}
}
impl
<
F
S
>
FilterExt
<
S
>
for
F
where
F
:
layer
:
:
Filter
<
S
>
{
}
impl
FilterMap
{
pub
(
crate
)
fn
set
(
self
FilterId
(
mask
)
:
FilterId
enabled
:
bool
)
-
>
Self
{
if
mask
=
=
u64
:
:
MAX
{
return
self
;
}
if
enabled
{
Self
{
bits
:
self
.
bits
&
(
!
mask
)
}
}
else
{
Self
{
bits
:
self
.
bits
|
mask
}
}
}
#
[
inline
]
pub
(
crate
)
fn
is_enabled
(
self
FilterId
(
mask
)
:
FilterId
)
-
>
bool
{
self
.
bits
&
mask
=
=
0
}
#
[
inline
]
pub
(
crate
)
fn
any_enabled
(
self
)
-
>
bool
{
self
.
bits
!
=
u64
:
:
MAX
}
}
impl
fmt
:
:
Debug
for
FilterMap
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
alt
=
f
.
alternate
(
)
;
let
mut
s
=
f
.
debug_struct
(
"
FilterMap
"
)
;
s
.
field
(
"
disabled_by
"
&
format_args
!
(
"
{
:
?
}
"
&
FmtBitset
(
self
.
bits
)
)
)
;
if
alt
{
s
.
field
(
"
bits
"
&
format_args
!
(
"
{
:
b
}
"
self
.
bits
)
)
;
}
s
.
finish
(
)
}
}
impl
fmt
:
:
Binary
for
FilterMap
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FilterMap
"
)
.
field
(
"
bits
"
&
format_args
!
(
"
{
:
b
}
"
self
.
bits
)
)
.
finish
(
)
}
}
impl
FilterState
{
const
fn
new
(
)
-
>
Self
{
Self
{
enabled
:
Cell
:
:
new
(
FilterMap
:
:
new
(
)
)
interest
:
RefCell
:
:
new
(
None
)
#
[
cfg
(
debug_assertions
)
]
counters
:
DebugCounters
:
:
new
(
)
}
}
fn
set
(
&
self
filter
:
FilterId
enabled
:
bool
)
{
#
[
cfg
(
debug_assertions
)
]
{
let
in_current_pass
=
self
.
counters
.
in_filter_pass
.
get
(
)
;
if
in_current_pass
=
=
0
{
debug_assert_eq
!
(
self
.
enabled
.
get
(
)
FilterMap
:
:
new
(
)
)
;
}
self
.
counters
.
in_filter_pass
.
set
(
in_current_pass
+
1
)
;
debug_assert_eq
!
(
self
.
counters
.
in_interest_pass
.
get
(
)
0
"
if
we
are
in
or
starting
a
filter
pass
we
must
not
be
in
an
interest
pass
.
"
)
}
self
.
enabled
.
set
(
self
.
enabled
.
get
(
)
.
set
(
filter
enabled
)
)
}
fn
add_interest
(
&
self
interest
:
Interest
)
{
let
mut
curr_interest
=
self
.
interest
.
borrow_mut
(
)
;
#
[
cfg
(
debug_assertions
)
]
{
let
in_current_pass
=
self
.
counters
.
in_interest_pass
.
get
(
)
;
if
in_current_pass
=
=
0
{
debug_assert
!
(
curr_interest
.
is_none
(
)
)
;
}
self
.
counters
.
in_interest_pass
.
set
(
in_current_pass
+
1
)
;
}
if
let
Some
(
curr_interest
)
=
curr_interest
.
as_mut
(
)
{
if
(
curr_interest
.
is_always
(
)
&
&
!
interest
.
is_always
(
)
)
|
|
(
curr_interest
.
is_never
(
)
&
&
!
interest
.
is_never
(
)
)
{
*
curr_interest
=
Interest
:
:
sometimes
(
)
;
}
}
else
{
*
curr_interest
=
Some
(
interest
)
;
}
}
pub
(
crate
)
fn
event_enabled
(
)
-
>
bool
{
FILTERING
.
try_with
(
|
this
|
{
let
enabled
=
this
.
enabled
.
get
(
)
.
any_enabled
(
)
;
#
[
cfg
(
debug_assertions
)
]
{
if
this
.
counters
.
in_filter_pass
.
get
(
)
=
=
0
{
debug_assert_eq
!
(
this
.
enabled
.
get
(
)
FilterMap
:
:
new
(
)
)
;
}
if
!
enabled
{
this
.
counters
.
in_filter_pass
.
set
(
0
)
;
}
}
enabled
}
)
.
unwrap_or
(
true
)
}
fn
did_enable
(
&
self
filter
:
FilterId
f
:
impl
FnOnce
(
)
)
{
let
map
=
self
.
enabled
.
get
(
)
;
if
map
.
is_enabled
(
filter
)
{
f
(
)
;
}
else
{
self
.
enabled
.
set
(
map
.
set
(
filter
true
)
)
;
}
#
[
cfg
(
debug_assertions
)
]
{
let
in_current_pass
=
self
.
counters
.
in_filter_pass
.
get
(
)
;
if
in_current_pass
<
=
1
{
debug_assert_eq
!
(
self
.
enabled
.
get
(
)
FilterMap
:
:
new
(
)
)
;
}
self
.
counters
.
in_filter_pass
.
set
(
in_current_pass
.
saturating_sub
(
1
)
)
;
debug_assert_eq
!
(
self
.
counters
.
in_interest_pass
.
get
(
)
0
"
if
we
are
in
a
filter
pass
we
must
not
be
in
an
interest
pass
.
"
)
}
}
fn
and
(
&
self
filter
:
FilterId
f
:
impl
FnOnce
(
)
-
>
bool
)
-
>
bool
{
let
map
=
self
.
enabled
.
get
(
)
;
let
enabled
=
map
.
is_enabled
(
filter
)
&
&
f
(
)
;
self
.
enabled
.
set
(
map
.
set
(
filter
enabled
)
)
;
enabled
}
pub
(
crate
)
fn
clear_enabled
(
)
{
let
_
=
FILTERING
.
try_with
(
|
filtering
|
{
filtering
.
enabled
.
set
(
FilterMap
:
:
new
(
)
)
;
#
[
cfg
(
debug_assertions
)
]
filtering
.
counters
.
in_filter_pass
.
set
(
0
)
;
}
)
;
}
pub
(
crate
)
fn
take_interest
(
)
-
>
Option
<
Interest
>
{
FILTERING
.
try_with
(
|
filtering
|
{
#
[
cfg
(
debug_assertions
)
]
{
if
filtering
.
counters
.
in_interest_pass
.
get
(
)
=
=
0
{
debug_assert
!
(
filtering
.
interest
.
try_borrow
(
)
.
ok
(
)
?
.
is_none
(
)
)
;
}
filtering
.
counters
.
in_interest_pass
.
set
(
0
)
;
}
filtering
.
interest
.
try_borrow_mut
(
)
.
ok
(
)
?
.
take
(
)
}
)
.
ok
(
)
?
}
pub
(
crate
)
fn
filter_map
(
&
self
)
-
>
FilterMap
{
let
map
=
self
.
enabled
.
get
(
)
;
#
[
cfg
(
debug_assertions
)
]
if
self
.
counters
.
in_filter_pass
.
get
(
)
=
=
0
{
debug_assert_eq
!
(
map
FilterMap
:
:
new
(
)
)
;
}
map
}
}
#
[
derive
(
Clone
Copy
)
]
#
[
repr
(
transparent
)
]
struct
MagicPlfDowncastMarker
(
FilterId
)
;
impl
fmt
:
:
Debug
for
MagicPlfDowncastMarker
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
0
f
)
}
}
pub
(
crate
)
fn
is_plf_downcast_marker
(
type_id
:
TypeId
)
-
>
bool
{
type_id
=
=
TypeId
:
:
of
:
:
<
MagicPlfDowncastMarker
>
(
)
}
pub
(
crate
)
fn
subscriber_has_plf
<
S
>
(
subscriber
:
&
S
)
-
>
bool
where
S
:
Subscriber
{
(
subscriber
as
&
dyn
Subscriber
)
.
is
:
:
<
MagicPlfDowncastMarker
>
(
)
}
pub
(
crate
)
fn
layer_has_plf
<
L
S
>
(
layer
:
&
L
)
-
>
bool
where
L
:
Layer
<
S
>
S
:
Subscriber
{
unsafe
{
layer
.
downcast_raw
(
TypeId
:
:
of
:
:
<
MagicPlfDowncastMarker
>
(
)
)
}
.
is_some
(
)
}
struct
FmtBitset
(
u64
)
;
impl
fmt
:
:
Debug
for
FmtBitset
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
set
=
f
.
debug_set
(
)
;
for
bit
in
0
.
.
64
{
if
self
.
0
&
(
1
<
<
bit
)
!
=
0
{
set
.
entry
(
&
bit
)
;
}
}
set
.
finish
(
)
}
}
