use
crate
:
:
{
field
:
:
RecordFields
fmt
:
:
{
format
FormatEvent
FormatFields
MakeWriter
TestWriter
}
layer
:
:
{
self
Context
}
registry
:
:
{
self
LookupSpan
SpanRef
}
}
;
use
format
:
:
{
FmtSpan
TimingDisplay
}
;
use
std
:
:
{
any
:
:
TypeId
cell
:
:
RefCell
env
fmt
io
marker
:
:
PhantomData
ops
:
:
Deref
time
:
:
Instant
}
;
use
tracing_core
:
:
{
field
span
:
:
{
Attributes
Current
Id
Record
}
Event
Metadata
Subscriber
}
;
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
fmt
"
feature
=
"
std
"
)
)
)
)
]
#
[
derive
(
Debug
)
]
pub
struct
Layer
<
S
N
=
format
:
:
DefaultFields
E
=
format
:
:
Format
<
format
:
:
Full
>
W
=
fn
(
)
-
>
io
:
:
Stdout
>
{
make_writer
:
W
fmt_fields
:
N
fmt_event
:
E
fmt_span
:
format
:
:
FmtSpanConfig
is_ansi
:
bool
log_internal_errors
:
bool
_inner
:
PhantomData
<
fn
(
S
)
>
}
impl
<
S
>
Layer
<
S
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
}
impl
<
S
N
E
W
>
Layer
<
S
N
E
W
>
where
S
:
Subscriber
+
for
<
'
a
>
LookupSpan
<
'
a
>
N
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
W
:
for
<
'
writer
>
MakeWriter
<
'
writer
>
+
'
static
{
pub
fn
event_format
<
E2
>
(
self
e
:
E2
)
-
>
Layer
<
S
N
E2
W
>
where
E2
:
FormatEvent
<
S
N
>
+
'
static
{
Layer
{
fmt_fields
:
self
.
fmt_fields
fmt_event
:
e
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
pub
fn
map_event_format
<
E2
>
(
self
f
:
impl
FnOnce
(
E
)
-
>
E2
)
-
>
Layer
<
S
N
E2
W
>
where
E2
:
FormatEvent
<
S
N
>
+
'
static
{
Layer
{
fmt_fields
:
self
.
fmt_fields
fmt_event
:
f
(
self
.
fmt_event
)
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
}
impl
<
S
N
E
W
>
Layer
<
S
N
E
W
>
{
pub
fn
with_writer
<
W2
>
(
self
make_writer
:
W2
)
-
>
Layer
<
S
N
E
W2
>
where
W2
:
for
<
'
writer
>
MakeWriter
<
'
writer
>
+
'
static
{
Layer
{
fmt_fields
:
self
.
fmt_fields
fmt_event
:
self
.
fmt_event
fmt_span
:
self
.
fmt_span
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
make_writer
_inner
:
self
.
_inner
}
}
pub
fn
writer
(
&
self
)
-
>
&
W
{
&
self
.
make_writer
}
pub
fn
writer_mut
(
&
mut
self
)
-
>
&
mut
W
{
&
mut
self
.
make_writer
}
#
[
cfg
(
feature
=
"
ansi
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
ansi
"
)
)
)
]
pub
fn
set_ansi
(
&
mut
self
ansi
:
bool
)
{
self
.
is_ansi
=
ansi
;
}
pub
fn
set_span_events
(
&
mut
self
kind
:
FmtSpan
)
{
self
.
fmt_span
=
format
:
:
FmtSpanConfig
{
kind
fmt_timing
:
self
.
fmt_span
.
fmt_timing
}
}
pub
fn
with_test_writer
(
self
)
-
>
Layer
<
S
N
E
TestWriter
>
{
Layer
{
fmt_fields
:
self
.
fmt_fields
fmt_event
:
self
.
fmt_event
fmt_span
:
self
.
fmt_span
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
make_writer
:
TestWriter
:
:
default
(
)
_inner
:
self
.
_inner
}
}
pub
fn
with_ansi
(
self
ansi
:
bool
)
-
>
Self
{
#
[
cfg
(
not
(
feature
=
"
ansi
"
)
)
]
if
ansi
{
const
ERROR
:
&
str
=
"
tracing
-
subscriber
:
the
ansi
crate
feature
is
required
to
enable
ANSI
terminal
colors
"
;
#
[
cfg
(
debug_assertions
)
]
panic
!
(
"
{
}
"
ERROR
)
;
#
[
cfg
(
not
(
debug_assertions
)
)
]
eprintln
!
(
"
{
}
"
ERROR
)
;
}
Self
{
is_ansi
:
ansi
.
.
self
}
}
pub
fn
log_internal_errors
(
self
log_internal_errors
:
bool
)
-
>
Self
{
Self
{
log_internal_errors
.
.
self
}
}
pub
fn
map_writer
<
W2
>
(
self
f
:
impl
FnOnce
(
W
)
-
>
W2
)
-
>
Layer
<
S
N
E
W2
>
where
W2
:
for
<
'
writer
>
MakeWriter
<
'
writer
>
+
'
static
{
Layer
{
fmt_fields
:
self
.
fmt_fields
fmt_event
:
self
.
fmt_event
fmt_span
:
self
.
fmt_span
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
make_writer
:
f
(
self
.
make_writer
)
_inner
:
self
.
_inner
}
}
}
impl
<
S
N
L
T
W
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
where
N
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
{
pub
fn
with_timer
<
T2
>
(
self
timer
:
T2
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T2
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_timer
(
timer
)
fmt_fields
:
self
.
fmt_fields
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
pub
fn
without_time
(
self
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
(
)
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
without_time
(
)
fmt_fields
:
self
.
fmt_fields
fmt_span
:
self
.
fmt_span
.
without_time
(
)
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
pub
fn
with_span_events
(
self
kind
:
FmtSpan
)
-
>
Self
{
Layer
{
fmt_span
:
self
.
fmt_span
.
with_kind
(
kind
)
.
.
self
}
}
pub
fn
with_target
(
self
display_target
:
bool
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_target
(
display_target
)
.
.
self
}
}
pub
fn
with_file
(
self
display_filename
:
bool
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_file
(
display_filename
)
.
.
self
}
}
pub
fn
with_line_number
(
self
display_line_number
:
bool
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_line_number
(
display_line_number
)
.
.
self
}
}
pub
fn
with_level
(
self
display_level
:
bool
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_level
(
display_level
)
.
.
self
}
}
pub
fn
with_thread_ids
(
self
display_thread_ids
:
bool
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_thread_ids
(
display_thread_ids
)
.
.
self
}
}
pub
fn
with_thread_names
(
self
display_thread_names
:
bool
)
-
>
Layer
<
S
N
format
:
:
Format
<
L
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_thread_names
(
display_thread_names
)
.
.
self
}
}
pub
fn
compact
(
self
)
-
>
Layer
<
S
N
format
:
:
Format
<
format
:
:
Compact
T
>
W
>
where
N
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
{
Layer
{
fmt_event
:
self
.
fmt_event
.
compact
(
)
fmt_fields
:
self
.
fmt_fields
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
#
[
cfg
(
feature
=
"
ansi
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
ansi
"
)
)
)
]
pub
fn
pretty
(
self
)
-
>
Layer
<
S
format
:
:
Pretty
format
:
:
Format
<
format
:
:
Pretty
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
pretty
(
)
fmt_fields
:
format
:
:
Pretty
:
:
default
(
)
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
#
[
cfg
(
feature
=
"
json
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
json
"
)
)
)
]
pub
fn
json
(
self
)
-
>
Layer
<
S
format
:
:
JsonFields
format
:
:
Format
<
format
:
:
Json
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
json
(
)
fmt_fields
:
format
:
:
JsonFields
:
:
new
(
)
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
false
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
}
#
[
cfg
(
feature
=
"
json
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
json
"
)
)
)
]
impl
<
S
T
W
>
Layer
<
S
format
:
:
JsonFields
format
:
:
Format
<
format
:
:
Json
T
>
W
>
{
pub
fn
flatten_event
(
self
flatten_event
:
bool
)
-
>
Layer
<
S
format
:
:
JsonFields
format
:
:
Format
<
format
:
:
Json
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
flatten_event
(
flatten_event
)
fmt_fields
:
format
:
:
JsonFields
:
:
new
(
)
.
.
self
}
}
pub
fn
with_current_span
(
self
display_current_span
:
bool
)
-
>
Layer
<
S
format
:
:
JsonFields
format
:
:
Format
<
format
:
:
Json
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_current_span
(
display_current_span
)
fmt_fields
:
format
:
:
JsonFields
:
:
new
(
)
.
.
self
}
}
pub
fn
with_span_list
(
self
display_span_list
:
bool
)
-
>
Layer
<
S
format
:
:
JsonFields
format
:
:
Format
<
format
:
:
Json
T
>
W
>
{
Layer
{
fmt_event
:
self
.
fmt_event
.
with_span_list
(
display_span_list
)
fmt_fields
:
format
:
:
JsonFields
:
:
new
(
)
.
.
self
}
}
}
impl
<
S
N
E
W
>
Layer
<
S
N
E
W
>
{
pub
fn
fmt_fields
<
N2
>
(
self
fmt_fields
:
N2
)
-
>
Layer
<
S
N2
E
W
>
where
N2
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
{
Layer
{
fmt_event
:
self
.
fmt_event
fmt_fields
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
pub
fn
map_fmt_fields
<
N2
>
(
self
f
:
impl
FnOnce
(
N
)
-
>
N2
)
-
>
Layer
<
S
N2
E
W
>
where
N2
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
{
Layer
{
fmt_event
:
self
.
fmt_event
fmt_fields
:
f
(
self
.
fmt_fields
)
fmt_span
:
self
.
fmt_span
make_writer
:
self
.
make_writer
is_ansi
:
self
.
is_ansi
log_internal_errors
:
self
.
log_internal_errors
_inner
:
self
.
_inner
}
}
}
impl
<
S
>
Default
for
Layer
<
S
>
{
fn
default
(
)
-
>
Self
{
let
ansi
=
cfg
!
(
feature
=
"
ansi
"
)
&
&
env
:
:
var
(
"
NO_COLOR
"
)
.
map_or
(
true
|
v
|
v
.
is_empty
(
)
)
;
Layer
{
fmt_fields
:
format
:
:
DefaultFields
:
:
default
(
)
fmt_event
:
format
:
:
Format
:
:
default
(
)
fmt_span
:
format
:
:
FmtSpanConfig
:
:
default
(
)
make_writer
:
io
:
:
stdout
is_ansi
:
ansi
log_internal_errors
:
false
_inner
:
PhantomData
}
}
}
impl
<
S
N
E
W
>
Layer
<
S
N
E
W
>
where
S
:
Subscriber
+
for
<
'
a
>
LookupSpan
<
'
a
>
N
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
E
:
FormatEvent
<
S
N
>
+
'
static
W
:
for
<
'
writer
>
MakeWriter
<
'
writer
>
+
'
static
{
#
[
inline
]
fn
make_ctx
<
'
a
>
(
&
'
a
self
ctx
:
Context
<
'
a
S
>
event
:
&
'
a
Event
<
'
a
>
)
-
>
FmtContext
<
'
a
S
N
>
{
FmtContext
{
ctx
fmt_fields
:
&
self
.
fmt_fields
event
}
}
}
#
[
derive
(
Default
)
]
pub
struct
FormattedFields
<
E
:
?
Sized
>
{
_format_fields
:
PhantomData
<
fn
(
E
)
>
was_ansi
:
bool
pub
fields
:
String
}
impl
<
E
:
?
Sized
>
FormattedFields
<
E
>
{
pub
fn
new
(
fields
:
String
)
-
>
Self
{
Self
{
fields
was_ansi
:
false
_format_fields
:
PhantomData
}
}
pub
fn
as_writer
(
&
mut
self
)
-
>
format
:
:
Writer
<
'
_
>
{
format
:
:
Writer
:
:
new
(
&
mut
self
.
fields
)
.
with_ansi
(
self
.
was_ansi
)
}
}
impl
<
E
:
?
Sized
>
fmt
:
:
Debug
for
FormattedFields
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FormattedFields
"
)
.
field
(
"
fields
"
&
self
.
fields
)
.
field
(
"
formatter
"
&
format_args
!
(
"
{
}
"
std
:
:
any
:
:
type_name
:
:
<
E
>
(
)
)
)
.
field
(
"
was_ansi
"
&
self
.
was_ansi
)
.
finish
(
)
}
}
impl
<
E
:
?
Sized
>
fmt
:
:
Display
for
FormattedFields
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
fields
f
)
}
}
impl
<
E
:
?
Sized
>
Deref
for
FormattedFields
<
E
>
{
type
Target
=
String
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
fields
}
}
macro_rules
!
with_event_from_span
{
(
id
:
ident
span
:
ident
(
field
:
literal
=
value
:
expr
)
*
|
event
:
ident
|
code
:
block
)
=
>
{
let
meta
=
span
.
metadata
(
)
;
let
cs
=
meta
.
callsite
(
)
;
let
fs
=
field
:
:
FieldSet
:
:
new
(
&
[
(
field
)
*
]
cs
)
;
#
[
allow
(
unused
)
]
let
mut
iter
=
fs
.
iter
(
)
;
let
v
=
[
(
(
&
iter
.
next
(
)
.
unwrap
(
)
:
:
core
:
:
option
:
:
Option
:
:
Some
(
&
value
as
&
dyn
field
:
:
Value
)
)
)
*
]
;
let
vs
=
fs
.
value_set
(
&
v
)
;
let
event
=
Event
:
:
new_child_of
(
id
meta
&
vs
)
;
code
}
;
}
impl
<
S
N
E
W
>
layer
:
:
Layer
<
S
>
for
Layer
<
S
N
E
W
>
where
S
:
Subscriber
+
for
<
'
a
>
LookupSpan
<
'
a
>
N
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
E
:
FormatEvent
<
S
N
>
+
'
static
W
:
for
<
'
writer
>
MakeWriter
<
'
writer
>
+
'
static
{
fn
on_new_span
(
&
self
attrs
:
&
Attributes
<
'
_
>
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
let
span
=
ctx
.
span
(
id
)
.
expect
(
"
Span
not
found
this
is
a
bug
"
)
;
let
mut
extensions
=
span
.
extensions_mut
(
)
;
if
extensions
.
get_mut
:
:
<
FormattedFields
<
N
>
>
(
)
.
is_none
(
)
{
let
mut
fields
=
FormattedFields
:
:
<
N
>
:
:
new
(
String
:
:
new
(
)
)
;
if
self
.
fmt_fields
.
format_fields
(
fields
.
as_writer
(
)
.
with_ansi
(
self
.
is_ansi
)
attrs
)
.
is_ok
(
)
{
fields
.
was_ansi
=
self
.
is_ansi
;
extensions
.
insert
(
fields
)
;
}
else
{
eprintln
!
(
"
[
tracing
-
subscriber
]
Unable
to
format
the
following
event
ignoring
:
{
:
?
}
"
attrs
)
;
}
}
if
self
.
fmt_span
.
fmt_timing
&
&
self
.
fmt_span
.
trace_close
(
)
&
&
extensions
.
get_mut
:
:
<
Timings
>
(
)
.
is_none
(
)
{
extensions
.
insert
(
Timings
:
:
new
(
)
)
;
}
if
self
.
fmt_span
.
trace_new
(
)
{
with_event_from_span
!
(
id
span
"
message
"
=
"
new
"
|
event
|
{
drop
(
extensions
)
;
drop
(
span
)
;
self
.
on_event
(
&
event
ctx
)
;
}
)
;
}
}
fn
on_record
(
&
self
id
:
&
Id
values
:
&
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
let
span
=
ctx
.
span
(
id
)
.
expect
(
"
Span
not
found
this
is
a
bug
"
)
;
let
mut
extensions
=
span
.
extensions_mut
(
)
;
if
let
Some
(
fields
)
=
extensions
.
get_mut
:
:
<
FormattedFields
<
N
>
>
(
)
{
let
_
=
self
.
fmt_fields
.
add_fields
(
fields
values
)
;
return
;
}
let
mut
fields
=
FormattedFields
:
:
<
N
>
:
:
new
(
String
:
:
new
(
)
)
;
if
self
.
fmt_fields
.
format_fields
(
fields
.
as_writer
(
)
.
with_ansi
(
self
.
is_ansi
)
values
)
.
is_ok
(
)
{
fields
.
was_ansi
=
self
.
is_ansi
;
extensions
.
insert
(
fields
)
;
}
}
fn
on_enter
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
if
self
.
fmt_span
.
trace_enter
(
)
|
|
self
.
fmt_span
.
trace_close
(
)
&
&
self
.
fmt_span
.
fmt_timing
{
let
span
=
ctx
.
span
(
id
)
.
expect
(
"
Span
not
found
this
is
a
bug
"
)
;
let
mut
extensions
=
span
.
extensions_mut
(
)
;
if
let
Some
(
timings
)
=
extensions
.
get_mut
:
:
<
Timings
>
(
)
{
let
now
=
Instant
:
:
now
(
)
;
timings
.
idle
+
=
(
now
-
timings
.
last
)
.
as_nanos
(
)
as
u64
;
timings
.
last
=
now
;
}
if
self
.
fmt_span
.
trace_enter
(
)
{
with_event_from_span
!
(
id
span
"
message
"
=
"
enter
"
|
event
|
{
drop
(
extensions
)
;
drop
(
span
)
;
self
.
on_event
(
&
event
ctx
)
;
}
)
;
}
}
}
fn
on_exit
(
&
self
id
:
&
Id
ctx
:
Context
<
'
_
S
>
)
{
if
self
.
fmt_span
.
trace_exit
(
)
|
|
self
.
fmt_span
.
trace_close
(
)
&
&
self
.
fmt_span
.
fmt_timing
{
let
span
=
ctx
.
span
(
id
)
.
expect
(
"
Span
not
found
this
is
a
bug
"
)
;
let
mut
extensions
=
span
.
extensions_mut
(
)
;
if
let
Some
(
timings
)
=
extensions
.
get_mut
:
:
<
Timings
>
(
)
{
let
now
=
Instant
:
:
now
(
)
;
timings
.
busy
+
=
(
now
-
timings
.
last
)
.
as_nanos
(
)
as
u64
;
timings
.
last
=
now
;
}
if
self
.
fmt_span
.
trace_exit
(
)
{
with_event_from_span
!
(
id
span
"
message
"
=
"
exit
"
|
event
|
{
drop
(
extensions
)
;
drop
(
span
)
;
self
.
on_event
(
&
event
ctx
)
;
}
)
;
}
}
}
fn
on_close
(
&
self
id
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
self
.
fmt_span
.
trace_close
(
)
{
let
span
=
ctx
.
span
(
&
id
)
.
expect
(
"
Span
not
found
this
is
a
bug
"
)
;
let
extensions
=
span
.
extensions
(
)
;
if
let
Some
(
timing
)
=
extensions
.
get
:
:
<
Timings
>
(
)
{
let
Timings
{
busy
mut
idle
last
}
=
*
timing
;
idle
+
=
(
Instant
:
:
now
(
)
-
last
)
.
as_nanos
(
)
as
u64
;
let
t_idle
=
field
:
:
display
(
TimingDisplay
(
idle
)
)
;
let
t_busy
=
field
:
:
display
(
TimingDisplay
(
busy
)
)
;
with_event_from_span
!
(
id
span
"
message
"
=
"
close
"
"
time
.
busy
"
=
t_busy
"
time
.
idle
"
=
t_idle
|
event
|
{
drop
(
extensions
)
;
drop
(
span
)
;
self
.
on_event
(
&
event
ctx
)
;
}
)
;
}
else
{
with_event_from_span
!
(
id
span
"
message
"
=
"
close
"
|
event
|
{
drop
(
extensions
)
;
drop
(
span
)
;
self
.
on_event
(
&
event
ctx
)
;
}
)
;
}
}
}
fn
on_event
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
thread_local
!
{
static
BUF
:
RefCell
<
String
>
=
const
{
RefCell
:
:
new
(
String
:
:
new
(
)
)
}
;
}
BUF
.
with
(
|
buf
|
{
let
borrow
=
buf
.
try_borrow_mut
(
)
;
let
mut
a
;
let
mut
b
;
let
mut
buf
=
match
borrow
{
Ok
(
buf
)
=
>
{
a
=
buf
;
&
mut
*
a
}
_
=
>
{
b
=
String
:
:
new
(
)
;
&
mut
b
}
}
;
let
ctx
=
self
.
make_ctx
(
ctx
event
)
;
if
self
.
fmt_event
.
format_event
(
&
ctx
format
:
:
Writer
:
:
new
(
&
mut
buf
)
.
with_ansi
(
self
.
is_ansi
)
event
)
.
is_ok
(
)
{
let
mut
writer
=
self
.
make_writer
.
make_writer_for
(
event
.
metadata
(
)
)
;
let
res
=
io
:
:
Write
:
:
write_all
(
&
mut
writer
buf
.
as_bytes
(
)
)
;
if
self
.
log_internal_errors
{
if
let
Err
(
e
)
=
res
{
eprintln
!
(
"
[
tracing
-
subscriber
]
Unable
to
write
an
event
to
the
Writer
for
this
Subscriber
!
Error
:
{
}
\
n
"
e
)
;
}
}
}
else
if
self
.
log_internal_errors
{
let
err_msg
=
format
!
(
"
Unable
to
format
the
following
event
.
Name
:
{
}
;
Fields
:
{
:
?
}
\
n
"
event
.
metadata
(
)
.
name
(
)
event
.
fields
(
)
)
;
let
mut
writer
=
self
.
make_writer
.
make_writer_for
(
event
.
metadata
(
)
)
;
let
res
=
io
:
:
Write
:
:
write_all
(
&
mut
writer
err_msg
.
as_bytes
(
)
)
;
if
let
Err
(
e
)
=
res
{
eprintln
!
(
"
[
tracing
-
subscriber
]
Unable
to
write
an
\
"
event
formatting
error
\
"
to
the
Writer
for
this
Subscriber
!
Error
:
{
}
\
n
"
e
)
;
}
}
buf
.
clear
(
)
;
}
)
;
}
unsafe
fn
downcast_raw
(
&
self
id
:
TypeId
)
-
>
Option
<
*
const
(
)
>
{
match
(
)
{
_
if
id
=
=
TypeId
:
:
of
:
:
<
Self
>
(
)
=
>
Some
(
self
as
*
const
Self
as
*
const
(
)
)
_
if
id
=
=
TypeId
:
:
of
:
:
<
E
>
(
)
=
>
Some
(
&
self
.
fmt_event
as
*
const
E
as
*
const
(
)
)
_
if
id
=
=
TypeId
:
:
of
:
:
<
N
>
(
)
=
>
Some
(
&
self
.
fmt_fields
as
*
const
N
as
*
const
(
)
)
_
if
id
=
=
TypeId
:
:
of
:
:
<
W
>
(
)
=
>
Some
(
&
self
.
make_writer
as
*
const
W
as
*
const
(
)
)
_
=
>
None
}
}
}
pub
struct
FmtContext
<
'
a
S
N
>
{
pub
(
crate
)
ctx
:
Context
<
'
a
S
>
pub
(
crate
)
fmt_fields
:
&
'
a
N
pub
(
crate
)
event
:
&
'
a
Event
<
'
a
>
}
impl
<
S
N
>
fmt
:
:
Debug
for
FmtContext
<
'
_
S
N
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FmtContext
"
)
.
finish
(
)
}
}
impl
<
'
writer
S
N
>
FormatFields
<
'
writer
>
for
FmtContext
<
'
_
S
N
>
where
S
:
Subscriber
+
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
N
:
FormatFields
<
'
writer
>
+
'
static
{
fn
format_fields
<
R
:
RecordFields
>
(
&
self
writer
:
format
:
:
Writer
<
'
writer
>
fields
:
R
)
-
>
fmt
:
:
Result
{
self
.
fmt_fields
.
format_fields
(
writer
fields
)
}
}
impl
<
S
N
>
FmtContext
<
'
_
S
N
>
where
S
:
Subscriber
+
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
N
:
for
<
'
writer
>
FormatFields
<
'
writer
>
+
'
static
{
pub
fn
visit_spans
<
E
F
>
(
&
self
mut
f
:
F
)
-
>
Result
<
(
)
E
>
where
F
:
FnMut
(
&
SpanRef
<
'
_
S
>
)
-
>
Result
<
(
)
E
>
{
if
let
Some
(
scope
)
=
self
.
event_scope
(
)
{
for
span
in
scope
.
from_root
(
)
{
f
(
&
span
)
?
;
}
}
Ok
(
(
)
)
}
#
[
inline
]
pub
fn
metadata
(
&
self
id
:
&
Id
)
-
>
Option
<
&
'
static
Metadata
<
'
static
>
>
where
S
:
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
{
self
.
ctx
.
metadata
(
id
)
}
#
[
inline
]
pub
fn
span
(
&
self
id
:
&
Id
)
-
>
Option
<
SpanRef
<
'
_
S
>
>
where
S
:
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
{
self
.
ctx
.
span
(
id
)
}
#
[
inline
]
pub
fn
exists
(
&
self
id
:
&
Id
)
-
>
bool
where
S
:
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
{
self
.
ctx
.
exists
(
id
)
}
#
[
inline
]
pub
fn
lookup_current
(
&
self
)
-
>
Option
<
SpanRef
<
'
_
S
>
>
where
S
:
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
{
self
.
ctx
.
lookup_current
(
)
}
pub
fn
current_span
(
&
self
)
-
>
Current
{
self
.
ctx
.
current_span
(
)
}
pub
fn
parent_span
(
&
self
)
-
>
Option
<
SpanRef
<
'
_
S
>
>
{
self
.
ctx
.
event_span
(
self
.
event
)
}
pub
fn
span_scope
(
&
self
id
:
&
Id
)
-
>
Option
<
registry
:
:
Scope
<
'
_
S
>
>
where
S
:
for
<
'
lookup
>
LookupSpan
<
'
lookup
>
{
self
.
ctx
.
span_scope
(
id
)
}
pub
fn
event_scope
(
&
self
)
-
>
Option
<
registry
:
:
Scope
<
'
_
S
>
>
where
S
:
for
<
'
lookup
>
registry
:
:
LookupSpan
<
'
lookup
>
{
self
.
ctx
.
event_scope
(
self
.
event
)
}
pub
fn
field_format
(
&
self
)
-
>
&
N
{
self
.
fmt_fields
}
}
struct
Timings
{
idle
:
u64
busy
:
u64
last
:
Instant
}
impl
Timings
{
fn
new
(
)
-
>
Self
{
Self
{
idle
:
0
busy
:
0
last
:
Instant
:
:
now
(
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
fmt
:
:
{
self
format
:
:
{
self
test
:
:
MockTime
Format
}
layer
:
:
Layer
as
_
test
:
:
{
MockMakeWriter
MockWriter
}
time
}
;
use
crate
:
:
Registry
;
use
format
:
:
FmtSpan
;
use
regex
:
:
Regex
;
use
tracing
:
:
subscriber
:
:
with_default
;
use
tracing_core
:
:
dispatcher
:
:
Dispatch
;
#
[
test
]
fn
impls
(
)
{
let
f
=
Format
:
:
default
(
)
.
with_timer
(
time
:
:
Uptime
:
:
default
(
)
)
;
let
fmt
=
fmt
:
:
Layer
:
:
default
(
)
.
event_format
(
f
)
;
let
subscriber
=
fmt
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
let
_dispatch
=
Dispatch
:
:
new
(
subscriber
)
;
let
f
=
format
:
:
Format
:
:
default
(
)
;
let
fmt
=
fmt
:
:
Layer
:
:
default
(
)
.
event_format
(
f
)
;
let
subscriber
=
fmt
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
let
_dispatch
=
Dispatch
:
:
new
(
subscriber
)
;
let
f
=
format
:
:
Format
:
:
default
(
)
.
compact
(
)
;
let
fmt
=
fmt
:
:
Layer
:
:
default
(
)
.
event_format
(
f
)
;
let
subscriber
=
fmt
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
let
_dispatch
=
Dispatch
:
:
new
(
subscriber
)
;
}
#
[
test
]
fn
fmt_layer_downcasts
(
)
{
let
f
=
format
:
:
Format
:
:
default
(
)
;
let
fmt
=
fmt
:
:
Layer
:
:
default
(
)
.
event_format
(
f
)
;
let
subscriber
=
fmt
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
let
dispatch
=
Dispatch
:
:
new
(
subscriber
)
;
assert
!
(
dispatch
.
downcast_ref
:
:
<
fmt
:
:
Layer
<
Registry
>
>
(
)
.
is_some
(
)
)
;
}
#
[
test
]
fn
fmt_layer_downcasts_to_parts
(
)
{
let
f
=
format
:
:
Format
:
:
default
(
)
;
let
fmt
=
fmt
:
:
Layer
:
:
default
(
)
.
event_format
(
f
)
;
let
subscriber
=
fmt
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
let
dispatch
=
Dispatch
:
:
new
(
subscriber
)
;
assert
!
(
dispatch
.
downcast_ref
:
:
<
format
:
:
DefaultFields
>
(
)
.
is_some
(
)
)
;
assert
!
(
dispatch
.
downcast_ref
:
:
<
format
:
:
Format
>
(
)
.
is_some
(
)
)
}
#
[
test
]
fn
is_lookup_span
(
)
{
fn
assert_lookup_span
<
T
:
for
<
'
a
>
crate
:
:
registry
:
:
LookupSpan
<
'
a
>
>
(
_
:
T
)
{
}
let
fmt
=
fmt
:
:
Layer
:
:
default
(
)
;
let
subscriber
=
fmt
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
assert_lookup_span
(
subscriber
)
}
fn
sanitize_timings
(
s
:
String
)
-
>
String
{
let
re
=
Regex
:
:
new
(
"
time
\
\
.
(
idle
|
busy
)
=
(
[
0
-
9
.
]
+
)
[
m
n
]
s
"
)
.
unwrap
(
)
;
re
.
replace_all
(
s
.
as_str
(
)
"
timing
"
)
.
to_string
(
)
}
#
[
test
]
fn
format_error_print_to_stderr
(
)
{
struct
AlwaysError
;
impl
std
:
:
fmt
:
:
Debug
for
AlwaysError
{
fn
fmt
(
&
self
_f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
Err
(
std
:
:
fmt
:
:
Error
)
}
}
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
tracing
:
:
info
!
(
?
AlwaysError
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
let
expected
=
concat
!
(
"
Unable
to
format
the
following
event
.
Name
:
event
"
file
!
(
)
"
:
"
)
;
assert
!
(
actual
.
as_str
(
)
.
starts_with
(
expected
)
"
\
nactual
=
{
}
\
nshould
start
with
expected
=
{
}
\
n
"
actual
expected
)
;
}
#
[
test
]
fn
format_error_ignore_if_log_internal_errors_is_false
(
)
{
struct
AlwaysError
;
impl
std
:
:
fmt
:
:
Debug
for
AlwaysError
{
fn
fmt
(
&
self
_f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
Err
(
std
:
:
fmt
:
:
Error
)
}
}
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
log_internal_errors
(
false
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
tracing
:
:
info
!
(
?
AlwaysError
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
"
actual
.
as_str
(
)
)
;
}
#
[
test
]
fn
synthesize_span_none
(
)
{
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
let
span1
=
tracing
:
:
info_span
!
(
"
span1
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
"
actual
.
as_str
(
)
)
;
}
#
[
test
]
fn
synthesize_span_active
(
)
{
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
with_span_events
(
FmtSpan
:
:
ACTIVE
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
let
span1
=
tracing
:
:
info_span
!
(
"
span1
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
enter
\
n
\
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
exit
\
n
"
actual
.
as_str
(
)
)
;
}
#
[
test
]
fn
synthesize_span_close
(
)
{
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
with_span_events
(
FmtSpan
:
:
CLOSE
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
let
span1
=
tracing
:
:
info_span
!
(
"
span1
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
close
timing
timing
\
n
"
actual
.
as_str
(
)
)
;
}
#
[
test
]
fn
synthesize_span_close_no_timing
(
)
{
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
without_time
(
)
.
with_span_events
(
FmtSpan
:
:
CLOSE
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
let
span1
=
tracing
:
:
info_span
!
(
"
span1
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
close
\
n
"
actual
.
as_str
(
)
)
;
}
#
[
test
]
fn
synthesize_span_full
(
)
{
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
with_span_events
(
FmtSpan
:
:
FULL
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
let
span1
=
tracing
:
:
info_span
!
(
"
span1
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
new
\
n
\
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
enter
\
n
\
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
exit
\
n
\
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
close
timing
timing
\
n
"
actual
.
as_str
(
)
)
;
}
#
[
test
]
fn
make_writer_based_on_meta
(
)
{
struct
MakeByTarget
{
make_writer1
:
MockMakeWriter
make_writer2
:
MockMakeWriter
}
impl
<
'
a
>
MakeWriter
<
'
a
>
for
MakeByTarget
{
type
Writer
=
MockWriter
;
fn
make_writer
(
&
'
a
self
)
-
>
Self
:
:
Writer
{
self
.
make_writer1
.
make_writer
(
)
}
fn
make_writer_for
(
&
'
a
self
meta
:
&
Metadata
<
'
_
>
)
-
>
Self
:
:
Writer
{
if
meta
.
target
(
)
=
=
"
writer2
"
{
return
self
.
make_writer2
.
make_writer
(
)
;
}
self
.
make_writer
(
)
}
}
let
make_writer1
=
MockMakeWriter
:
:
default
(
)
;
let
make_writer2
=
MockMakeWriter
:
:
default
(
)
;
let
make_writer
=
MakeByTarget
{
make_writer1
:
make_writer1
.
clone
(
)
make_writer2
:
make_writer2
.
clone
(
)
}
;
let
subscriber
=
crate
:
:
fmt
:
:
Subscriber
:
:
builder
(
)
.
with_writer
(
make_writer
)
.
with_level
(
false
)
.
with_target
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
with_span_events
(
FmtSpan
:
:
CLOSE
)
.
finish
(
)
;
with_default
(
subscriber
|
|
{
let
span1
=
tracing
:
:
info_span
!
(
"
writer1_span
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
tracing
:
:
info
!
(
target
:
"
writer2
"
"
hello
writer2
!
"
)
;
let
span2
=
tracing
:
:
info_span
!
(
target
:
"
writer2
"
"
writer2_span
"
)
;
let
_e
=
span2
.
enter
(
)
;
tracing
:
:
warn
!
(
target
:
"
writer1
"
"
hello
writer1
!
"
)
;
}
)
;
let
actual
=
sanitize_timings
(
make_writer1
.
get_string
(
)
)
;
assert_eq
!
(
"
fake
time
writer1_span
{
x
=
42
}
:
writer2_span
:
hello
writer1
!
\
n
\
fake
time
writer1_span
{
x
=
42
}
:
close
timing
timing
\
n
"
actual
.
as_str
(
)
)
;
let
actual
=
sanitize_timings
(
make_writer2
.
get_string
(
)
)
;
assert_eq
!
(
"
fake
time
writer1_span
{
x
=
42
}
:
hello
writer2
!
\
n
\
fake
time
writer1_span
{
x
=
42
}
:
writer2_span
:
close
timing
timing
\
n
"
actual
.
as_str
(
)
)
;
}
#
[
cfg
(
feature
=
"
ansi
"
)
]
#
[
test
]
fn
layer_no_color
(
)
{
const
NO_COLOR
:
&
str
=
"
NO_COLOR
"
;
struct
RestoreEnvVar
(
Result
<
String
env
:
:
VarError
>
)
;
impl
Drop
for
RestoreEnvVar
{
fn
drop
(
&
mut
self
)
{
match
self
.
0
{
Ok
(
ref
var
)
=
>
env
:
:
set_var
(
NO_COLOR
var
)
Err
(
_
)
=
>
env
:
:
remove_var
(
NO_COLOR
)
}
}
}
let
_saved_no_color
=
RestoreEnvVar
(
env
:
:
var
(
NO_COLOR
)
)
;
let
cases
:
Vec
<
(
Option
<
&
str
>
bool
)
>
=
vec
!
[
(
Some
(
"
0
"
)
false
)
/
/
any
non
-
empty
value
disables
ansi
(
Some
(
"
off
"
)
false
)
/
/
any
non
-
empty
value
disables
ansi
(
Some
(
"
1
"
)
false
)
(
Some
(
"
"
)
true
)
/
/
empty
value
does
not
disable
ansi
(
None
true
)
]
;
for
(
var
ansi
)
in
cases
{
if
let
Some
(
value
)
=
var
{
env
:
:
set_var
(
NO_COLOR
value
)
;
}
else
{
env
:
:
remove_var
(
NO_COLOR
)
;
}
let
layer
:
Layer
<
(
)
>
=
fmt
:
:
Layer
:
:
default
(
)
;
assert_eq
!
(
layer
.
is_ansi
ansi
"
NO_COLOR
=
{
:
?
}
;
Layer
:
:
default
(
)
.
is_ansi
should
be
{
}
"
var
ansi
)
;
let
layer
:
Layer
<
(
)
>
=
fmt
:
:
Layer
:
:
default
(
)
.
with_ansi
(
true
)
;
assert
!
(
layer
.
is_ansi
"
NO_COLOR
=
{
:
?
}
;
Layer
:
:
default
(
)
.
with_ansi
(
true
)
.
is_ansi
should
be
true
"
var
)
;
let
mut
layer
:
Layer
<
(
)
>
=
fmt
:
:
Layer
:
:
default
(
)
;
layer
.
set_ansi
(
true
)
;
assert
!
(
layer
.
is_ansi
"
NO_COLOR
=
{
:
?
}
;
layer
.
set_ansi
(
true
)
;
layer
.
is_ansi
should
be
true
"
var
)
;
}
}
#
[
test
]
fn
modify_span_events
(
)
{
let
make_writer
=
MockMakeWriter
:
:
default
(
)
;
let
inner_layer
=
fmt
:
:
Layer
:
:
default
(
)
.
with_writer
(
make_writer
.
clone
(
)
)
.
with_level
(
false
)
.
with_ansi
(
false
)
.
with_timer
(
MockTime
)
.
with_span_events
(
FmtSpan
:
:
ACTIVE
)
;
let
(
reloadable_layer
reload_handle
)
=
crate
:
:
reload
:
:
Layer
:
:
new
(
inner_layer
)
;
let
reload
=
reloadable_layer
.
with_subscriber
(
Registry
:
:
default
(
)
)
;
with_default
(
reload
|
|
{
{
let
span1
=
tracing
:
:
info_span
!
(
"
span1
"
x
=
42
)
;
let
_e
=
span1
.
enter
(
)
;
}
let
_
=
reload_handle
.
modify
(
|
s
|
s
.
set_span_events
(
FmtSpan
:
:
NONE
)
)
;
{
let
span2
=
tracing
:
:
info_span
!
(
"
span2
"
x
=
100
)
;
let
_e
=
span2
.
enter
(
)
;
}
{
let
span3
=
tracing
:
:
info_span
!
(
"
span3
"
x
=
42
)
;
let
_e
=
span3
.
enter
(
)
;
let
_
=
reload_handle
.
modify
(
|
s
|
s
.
set_span_events
(
FmtSpan
:
:
ACTIVE
)
)
;
}
}
)
;
let
actual
=
sanitize_timings
(
make_writer
.
get_string
(
)
)
;
assert_eq
!
(
"
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
enter
\
n
\
fake
time
span1
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
exit
\
n
\
fake
time
span3
{
x
=
42
}
:
tracing_subscriber
:
:
fmt
:
:
fmt_layer
:
:
test
:
exit
\
n
"
actual
.
as_str
(
)
)
;
}
}
