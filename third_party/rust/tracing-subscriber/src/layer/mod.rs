use
crate
:
:
filter
;
use
tracing_core
:
:
{
metadata
:
:
Metadata
span
subscriber
:
:
{
Interest
Subscriber
}
Dispatch
Event
LevelFilter
}
;
use
core
:
:
any
:
:
TypeId
;
feature
!
{
#
!
[
feature
=
"
alloc
"
]
use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
ops
:
:
{
Deref
DerefMut
}
;
}
mod
context
;
mod
layered
;
pub
use
self
:
:
{
context
:
:
*
layered
:
:
*
}
;
#
[
cfg
(
test
)
]
pub
(
crate
)
mod
tests
;
#
[
cfg_attr
(
docsrs
doc
(
notable_trait
)
)
]
pub
trait
Layer
<
S
>
where
S
:
Subscriber
Self
:
'
static
{
fn
on_register_dispatch
(
&
self
subscriber
:
&
Dispatch
)
{
let
_
=
subscriber
;
}
fn
on_layer
(
&
mut
self
subscriber
:
&
mut
S
)
{
let
_
=
subscriber
;
}
fn
register_callsite
(
&
self
metadata
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
if
self
.
enabled
(
metadata
Context
:
:
none
(
)
)
{
Interest
:
:
always
(
)
}
else
{
Interest
:
:
never
(
)
}
}
fn
enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
let
_
=
(
metadata
ctx
)
;
true
}
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
let
_
=
(
attrs
id
ctx
)
;
}
#
[
doc
(
hidden
)
]
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
None
}
fn
on_record
(
&
self
_span
:
&
span
:
:
Id
_values
:
&
span
:
:
Record
<
'
_
>
_ctx
:
Context
<
'
_
S
>
)
{
}
fn
on_follows_from
(
&
self
_span
:
&
span
:
:
Id
_follows
:
&
span
:
:
Id
_ctx
:
Context
<
'
_
S
>
)
{
}
#
[
inline
]
fn
event_enabled
(
&
self
_event
:
&
Event
<
'
_
>
_ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
true
}
fn
on_event
(
&
self
_event
:
&
Event
<
'
_
>
_ctx
:
Context
<
'
_
S
>
)
{
}
fn
on_enter
(
&
self
_id
:
&
span
:
:
Id
_ctx
:
Context
<
'
_
S
>
)
{
}
fn
on_exit
(
&
self
_id
:
&
span
:
:
Id
_ctx
:
Context
<
'
_
S
>
)
{
}
fn
on_close
(
&
self
_id
:
span
:
:
Id
_ctx
:
Context
<
'
_
S
>
)
{
}
fn
on_id_change
(
&
self
_old
:
&
span
:
:
Id
_new
:
&
span
:
:
Id
_ctx
:
Context
<
'
_
S
>
)
{
}
fn
and_then
<
L
>
(
self
layer
:
L
)
-
>
Layered
<
L
Self
S
>
where
L
:
Layer
<
S
>
Self
:
Sized
{
let
inner_has_layer_filter
=
filter
:
:
layer_has_plf
(
&
self
)
;
Layered
:
:
new
(
layer
self
inner_has_layer_filter
)
}
fn
with_subscriber
(
mut
self
mut
inner
:
S
)
-
>
Layered
<
Self
S
>
where
Self
:
Sized
{
let
inner_has_layer_filter
=
filter
:
:
subscriber_has_plf
(
&
inner
)
;
self
.
on_layer
(
&
mut
inner
)
;
Layered
:
:
new
(
self
inner
inner_has_layer_filter
)
}
#
[
cfg
(
all
(
feature
=
"
registry
"
feature
=
"
std
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
registry
"
feature
=
"
std
"
)
)
)
)
]
fn
with_filter
<
F
>
(
self
filter
:
F
)
-
>
filter
:
:
Filtered
<
Self
F
S
>
where
Self
:
Sized
F
:
Filter
<
S
>
{
filter
:
:
Filtered
:
:
new
(
self
filter
)
}
#
[
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
alloc
"
feature
=
"
std
"
)
)
)
)
]
fn
boxed
(
self
)
-
>
Box
<
dyn
Layer
<
S
>
+
Send
+
Sync
+
'
static
>
where
Self
:
Sized
Self
:
Layer
<
S
>
+
Send
+
Sync
+
'
static
S
:
Subscriber
{
Box
:
:
new
(
self
)
}
#
[
doc
(
hidden
)
]
unsafe
fn
downcast_raw
(
&
self
id
:
TypeId
)
-
>
Option
<
*
const
(
)
>
{
if
id
=
=
TypeId
:
:
of
:
:
<
Self
>
(
)
{
Some
(
self
as
*
const
_
as
*
const
(
)
)
}
else
{
None
}
}
}
feature
!
{
#
!
[
all
(
feature
=
"
registry
"
feature
=
"
std
"
)
]
/
/
/
A
per
-
[
Layer
]
filter
that
determines
whether
a
span
or
event
is
enabled
/
/
/
for
an
individual
layer
.
/
/
/
/
/
/
See
[
the
module
-
level
documentation
]
[
plf
]
for
details
on
using
[
Filter
]
s
.
/
/
/
/
/
/
[
plf
]
:
crate
:
:
layer
#
per
-
layer
-
filtering
#
[
cfg_attr
(
docsrs
doc
(
notable_trait
)
)
]
pub
trait
Filter
<
S
>
{
/
/
/
Returns
true
if
this
layer
is
interested
in
a
span
or
event
with
the
/
/
/
given
[
Metadata
]
in
the
current
[
Context
]
similarly
to
/
/
/
[
Subscriber
:
:
enabled
]
.
/
/
/
/
/
/
If
this
returns
false
the
span
or
event
will
be
disabled
_for
the
/
/
/
wrapped
[
Layer
]
_
.
Unlike
[
Layer
:
:
enabled
]
the
span
or
event
will
/
/
/
still
be
recorded
if
any
_other_
layers
choose
to
enable
it
.
However
/
/
/
the
layer
[
filtered
]
by
this
filter
will
skip
recording
that
span
or
/
/
/
event
.
/
/
/
/
/
/
If
all
layers
indicate
that
they
do
not
wish
to
see
this
span
or
event
/
/
/
it
will
be
disabled
.
/
/
/
/
/
/
[
metadata
]
:
tracing_core
:
:
Metadata
/
/
/
[
Subscriber
:
:
enabled
]
:
tracing_core
:
:
Subscriber
:
:
enabled
/
/
/
[
filtered
]
:
crate
:
:
filter
:
:
Filtered
fn
enabled
(
&
self
meta
:
&
Metadata
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
;
/
/
/
Returns
an
[
Interest
]
indicating
whether
this
layer
will
[
always
]
/
/
/
[
sometimes
]
or
[
never
]
be
interested
in
the
given
[
Metadata
]
.
/
/
/
/
/
/
When
a
given
callsite
will
[
always
]
or
[
never
]
be
enabled
the
results
/
/
/
of
evaluating
the
filter
may
be
cached
for
improved
performance
.
/
/
/
Therefore
if
a
filter
is
capable
of
determining
that
it
will
always
or
/
/
/
never
enable
a
particular
callsite
providing
an
implementation
of
this
/
/
/
function
is
recommended
.
/
/
/
/
/
/
<
pre
class
=
"
ignore
"
style
=
"
white
-
space
:
normal
;
font
:
inherit
;
"
>
/
/
/
<
strong
>
Note
<
/
strong
>
:
If
a
<
code
>
Filter
<
/
code
>
will
perform
/
/
/
<
em
>
dynamic
filtering
<
/
em
>
that
depends
on
the
current
context
in
which
/
/
/
a
span
or
event
was
observed
(
e
.
g
.
only
enabling
an
event
when
it
/
/
/
occurs
within
a
particular
span
)
it
<
strong
>
must
<
/
strong
>
return
/
/
/
<
code
>
Interest
:
:
sometimes
(
)
<
/
code
>
from
this
method
.
If
it
returns
/
/
/
<
code
>
Interest
:
:
always
(
)
<
/
code
>
or
<
code
>
Interest
:
:
never
(
)
<
/
code
>
the
/
/
/
<
code
>
enabled
<
/
code
>
method
may
not
be
called
when
a
particular
instance
/
/
/
of
that
span
or
event
is
recorded
.
/
/
/
<
/
pre
>
/
/
/
/
/
/
This
method
is
broadly
similar
to
[
Subscriber
:
:
register_callsite
]
;
/
/
/
however
since
the
returned
value
represents
only
the
interest
of
/
/
/
*
this
*
layer
the
resulting
behavior
is
somewhat
different
.
/
/
/
/
/
/
If
a
[
Subscriber
]
returns
[
Interest
:
:
always
(
)
]
[
always
]
or
/
/
/
[
Interest
:
:
never
(
)
]
[
never
]
for
a
given
[
Metadata
]
its
[
enabled
]
/
/
/
method
is
then
*
guaranteed
*
to
never
be
called
for
that
callsite
.
On
the
/
/
/
other
hand
when
a
Filter
returns
[
Interest
:
:
always
(
)
]
[
always
]
or
/
/
/
[
Interest
:
:
never
(
)
]
[
never
]
for
a
callsite
_other_
[
Layer
]
s
may
have
/
/
/
differing
interests
in
that
callsite
.
If
this
is
the
case
the
callsite
/
/
/
will
receive
[
Interest
:
:
sometimes
(
)
]
[
sometimes
]
and
the
[
enabled
]
/
/
/
method
will
still
be
called
for
that
callsite
when
it
records
a
span
or
/
/
/
event
.
/
/
/
/
/
/
Returning
[
Interest
:
:
always
(
)
]
[
always
]
or
[
Interest
:
:
never
(
)
]
[
never
]
from
/
/
/
Filter
:
:
callsite_enabled
will
permanently
enable
or
disable
a
/
/
/
callsite
(
without
requiring
subsequent
calls
to
[
enabled
]
)
if
and
only
/
/
/
if
the
following
is
true
:
/
/
/
/
/
/
-
all
[
Layer
]
s
that
comprise
the
subscriber
include
Filter
s
/
/
/
(
this
includes
a
tree
of
[
Layered
]
layers
that
share
the
same
/
/
/
Filter
)
/
/
/
-
all
those
Filter
s
return
the
same
[
Interest
]
.
/
/
/
/
/
/
For
example
if
a
[
Subscriber
]
consists
of
two
[
Filtered
]
layers
/
/
/
and
both
of
those
layers
return
[
Interest
:
:
never
(
)
]
[
never
]
that
/
/
/
callsite
*
will
*
never
be
enabled
and
the
[
enabled
]
methods
of
those
/
/
/
[
Filter
]
s
will
not
be
called
.
/
/
/
/
/
/
#
#
Default
Implementation
/
/
/
/
/
/
The
default
implementation
of
this
method
assumes
that
the
/
/
/
Filter
'
s
[
enabled
]
method
_may_
perform
dynamic
filtering
and
/
/
/
returns
[
Interest
:
:
sometimes
(
)
]
[
sometimes
]
to
ensure
that
[
enabled
]
/
/
/
is
called
to
determine
whether
a
particular
_instance_
of
the
callsite
/
/
/
is
enabled
in
the
current
context
.
If
this
is
*
not
*
the
case
and
the
/
/
/
Filter
'
s
[
enabled
]
method
will
always
return
the
same
result
/
/
/
for
a
particular
[
Metadata
]
this
method
can
be
overridden
as
/
/
/
follows
:
/
/
/
/
/
/
/
/
/
use
tracing_subscriber
:
:
layer
;
/
/
/
use
tracing_core
:
:
{
Metadata
subscriber
:
:
Interest
}
;
/
/
/
/
/
/
struct
MyFilter
{
/
/
/
/
/
.
.
.
/
/
/
}
/
/
/
/
/
/
impl
MyFilter
{
/
/
/
/
/
The
actual
logic
for
determining
whether
a
Metadata
is
enabled
/
/
/
/
/
must
be
factored
out
from
the
enabled
method
so
that
it
can
be
/
/
/
/
/
called
without
a
Context
(
which
is
not
provided
to
the
/
/
/
/
/
callsite_enabled
method
)
.
/
/
/
fn
is_enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
)
-
>
bool
{
/
/
/
/
/
.
.
.
/
/
/
#
drop
(
metadata
)
;
true
/
/
/
}
/
/
/
}
/
/
/
/
/
/
impl
<
S
>
layer
:
:
Filter
<
S
>
for
MyFilter
{
/
/
/
fn
enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
_
:
&
layer
:
:
Context
<
'
_
S
>
)
-
>
bool
{
/
/
/
/
/
Even
though
we
are
implementing
callsite_enabled
we
must
still
provide
a
/
/
/
/
/
working
implementation
of
enabled
as
returning
Interest
:
:
always
(
)
or
/
/
/
/
/
Interest
:
:
never
(
)
will
*
allow
*
caching
but
will
not
*
guarantee
*
it
.
/
/
/
/
/
Other
filters
may
still
return
Interest
:
:
sometimes
(
)
so
we
may
be
/
/
/
/
/
asked
again
in
enabled
.
/
/
/
self
.
is_enabled
(
metadata
)
/
/
/
}
/
/
/
/
/
/
fn
callsite_enabled
(
&
self
metadata
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
/
/
/
/
/
The
result
of
self
.
enabled
(
metadata
.
.
.
)
will
always
be
/
/
/
/
/
the
same
for
any
given
Metadata
so
we
can
convert
it
into
/
/
/
/
/
an
Interest
:
/
/
/
if
self
.
is_enabled
(
metadata
)
{
/
/
/
Interest
:
:
always
(
)
/
/
/
}
else
{
/
/
/
Interest
:
:
never
(
)
/
/
/
}
/
/
/
}
/
/
/
}
/
/
/
/
/
/
/
/
/
[
Metadata
]
:
tracing_core
:
:
Metadata
/
/
/
[
Interest
]
:
tracing_core
:
:
Interest
/
/
/
[
always
]
:
tracing_core
:
:
Interest
:
:
always
/
/
/
[
sometimes
]
:
tracing_core
:
:
Interest
:
:
sometimes
/
/
/
[
never
]
:
tracing_core
:
:
Interest
:
:
never
/
/
/
[
Subscriber
:
:
register_callsite
]
:
tracing_core
:
:
Subscriber
:
:
register_callsite
/
/
/
[
Subscriber
]
:
tracing_core
:
:
Subscriber
/
/
/
[
enabled
]
:
Filter
:
:
enabled
/
/
/
[
Filtered
]
:
crate
:
:
filter
:
:
Filtered
fn
callsite_enabled
(
&
self
meta
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
let
_
=
meta
;
Interest
:
:
sometimes
(
)
}
/
/
/
Called
before
the
filtered
[
Layer
]
'
s
[
on_event
]
to
determine
if
/
/
/
on_event
should
be
called
.
/
/
/
/
/
/
This
gives
a
chance
to
filter
events
based
on
their
fields
.
Note
/
/
/
however
that
this
*
does
not
*
override
[
enabled
]
and
is
not
even
/
/
/
called
if
[
enabled
]
returns
false
.
#
[
inline
]
/
/
collapse
this
to
a
constant
please
mrs
optimizer
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
cx
:
&
Context
<
'
_
S
>
)
-
>
bool
{
let
_
=
(
event
cx
)
;
true
}
/
/
/
Returns
an
optional
hint
of
the
highest
[
verbosity
level
]
[
level
]
that
/
/
/
this
Filter
will
enable
.
/
/
/
/
/
/
If
this
method
returns
a
[
LevelFilter
]
it
will
be
used
as
a
hint
to
/
/
/
determine
the
most
verbose
level
that
will
be
enabled
.
This
will
allow
/
/
/
spans
and
events
which
are
more
verbose
than
that
level
to
be
skipped
/
/
/
more
efficiently
.
An
implementation
of
this
method
is
optional
but
/
/
/
strongly
encouraged
.
/
/
/
/
/
/
If
the
maximum
level
the
Filter
will
enable
can
change
over
the
/
/
/
course
of
its
lifetime
it
is
free
to
return
a
different
value
from
/
/
/
multiple
invocations
of
this
method
.
However
note
that
changes
in
the
/
/
/
maximum
level
will
*
*
only
*
*
be
reflected
after
the
callsite
[
Interest
]
/
/
/
cache
is
rebuilt
by
calling
the
/
/
/
[
tracing_core
:
:
callsite
:
:
rebuild_interest_cache
]
[
rebuild
]
function
.
/
/
/
Therefore
if
the
Filter
will
change
the
value
returned
by
this
/
/
/
method
it
is
responsible
for
ensuring
that
/
/
/
[
rebuild_interest_cache
]
[
rebuild
]
is
called
after
the
value
of
the
max
/
/
/
level
changes
.
/
/
/
/
/
/
#
#
Default
Implementation
/
/
/
/
/
/
By
default
this
method
returns
None
indicating
that
the
maximum
/
/
/
level
is
unknown
.
/
/
/
/
/
/
[
level
]
:
tracing_core
:
:
metadata
:
:
Level
/
/
/
[
LevelFilter
]
:
crate
:
:
filter
:
:
LevelFilter
/
/
/
[
Interest
]
:
tracing_core
:
:
subscriber
:
:
Interest
/
/
/
[
rebuild
]
:
tracing_core
:
:
callsite
:
:
rebuild_interest_cache
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
None
}
/
/
/
Notifies
this
filter
that
a
new
span
was
constructed
with
the
given
/
/
/
Attributes
and
Id
.
/
/
/
/
/
/
By
default
this
method
does
nothing
.
Filter
implementations
that
/
/
/
need
to
be
notified
when
new
spans
are
created
can
override
this
/
/
/
method
.
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
let
_
=
(
attrs
id
ctx
)
;
}
/
/
/
Notifies
this
filter
that
a
span
with
the
given
Id
recorded
the
given
/
/
/
values
.
/
/
/
/
/
/
By
default
this
method
does
nothing
.
Filter
implementations
that
/
/
/
need
to
be
notified
when
new
spans
are
created
can
override
this
/
/
/
method
.
fn
on_record
(
&
self
id
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
let
_
=
(
id
values
ctx
)
;
}
/
/
/
Notifies
this
filter
that
a
span
with
the
given
ID
was
entered
.
/
/
/
/
/
/
By
default
this
method
does
nothing
.
Filter
implementations
that
/
/
/
need
to
be
notified
when
a
span
is
entered
can
override
this
method
.
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
let
_
=
(
id
ctx
)
;
}
/
/
/
Notifies
this
filter
that
a
span
with
the
given
ID
was
exited
.
/
/
/
/
/
/
By
default
this
method
does
nothing
.
Filter
implementations
that
/
/
/
need
to
be
notified
when
a
span
is
exited
can
override
this
method
.
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
let
_
=
(
id
ctx
)
;
}
/
/
/
Notifies
this
filter
that
a
span
with
the
given
ID
has
been
closed
.
/
/
/
/
/
/
By
default
this
method
does
nothing
.
Filter
implementations
that
/
/
/
need
to
be
notified
when
a
span
is
closed
can
override
this
method
.
fn
on_close
(
&
self
id
:
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
let
_
=
(
id
ctx
)
;
}
}
}
pub
trait
SubscriberExt
:
Subscriber
+
crate
:
:
sealed
:
:
Sealed
{
fn
with
<
L
>
(
self
layer
:
L
)
-
>
Layered
<
L
Self
>
where
L
:
Layer
<
Self
>
Self
:
Sized
{
layer
.
with_subscriber
(
self
)
}
}
#
[
derive
(
Clone
Debug
Default
)
]
pub
struct
Identity
{
_p
:
(
)
}
#
[
derive
(
Clone
Copy
)
]
pub
(
crate
)
struct
NoneLayerMarker
(
(
)
)
;
static
NONE_LAYER_MARKER
:
NoneLayerMarker
=
NoneLayerMarker
(
(
)
)
;
pub
(
crate
)
fn
layer_is_none
<
L
S
>
(
layer
:
&
L
)
-
>
bool
where
L
:
Layer
<
S
>
S
:
Subscriber
{
unsafe
{
layer
.
downcast_raw
(
TypeId
:
:
of
:
:
<
NoneLayerMarker
>
(
)
)
}
.
is_some
(
)
}
pub
(
crate
)
fn
subscriber_is_none
<
S
>
(
subscriber
:
&
S
)
-
>
bool
where
S
:
Subscriber
{
unsafe
{
subscriber
.
downcast_raw
(
TypeId
:
:
of
:
:
<
NoneLayerMarker
>
(
)
)
}
.
is_some
(
)
}
impl
<
L
S
>
Layer
<
S
>
for
Option
<
L
>
where
L
:
Layer
<
S
>
S
:
Subscriber
{
fn
on_layer
(
&
mut
self
subscriber
:
&
mut
S
)
{
if
let
Some
(
ref
mut
layer
)
=
self
{
layer
.
on_layer
(
subscriber
)
}
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_new_span
(
attrs
id
ctx
)
}
}
#
[
inline
]
fn
register_callsite
(
&
self
metadata
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
match
self
{
Some
(
ref
inner
)
=
>
inner
.
register_callsite
(
metadata
)
None
=
>
Interest
:
:
always
(
)
}
}
#
[
inline
]
fn
enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
match
self
{
Some
(
ref
inner
)
=
>
inner
.
enabled
(
metadata
ctx
)
None
=
>
true
}
}
#
[
inline
]
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
match
self
{
Some
(
ref
inner
)
=
>
inner
.
max_level_hint
(
)
None
=
>
{
Some
(
LevelFilter
:
:
OFF
)
}
}
}
#
[
inline
]
fn
on_record
(
&
self
span
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_record
(
span
values
ctx
)
;
}
}
#
[
inline
]
fn
on_follows_from
(
&
self
span
:
&
span
:
:
Id
follows
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_follows_from
(
span
follows
ctx
)
;
}
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
match
self
{
Some
(
ref
inner
)
=
>
inner
.
event_enabled
(
event
ctx
)
None
=
>
true
}
}
#
[
inline
]
fn
on_event
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_event
(
event
ctx
)
;
}
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_enter
(
id
ctx
)
;
}
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_exit
(
id
ctx
)
;
}
}
#
[
inline
]
fn
on_close
(
&
self
id
:
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_close
(
id
ctx
)
;
}
}
#
[
inline
]
fn
on_id_change
(
&
self
old
:
&
span
:
:
Id
new
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
if
let
Some
(
ref
inner
)
=
self
{
inner
.
on_id_change
(
old
new
ctx
)
}
}
#
[
doc
(
hidden
)
]
#
[
inline
]
unsafe
fn
downcast_raw
(
&
self
id
:
TypeId
)
-
>
Option
<
*
const
(
)
>
{
if
id
=
=
TypeId
:
:
of
:
:
<
Self
>
(
)
{
Some
(
self
as
*
const
_
as
*
const
(
)
)
}
else
if
id
=
=
TypeId
:
:
of
:
:
<
NoneLayerMarker
>
(
)
&
&
self
.
is_none
(
)
{
Some
(
&
NONE_LAYER_MARKER
as
*
const
_
as
*
const
(
)
)
}
else
{
self
.
as_ref
(
)
.
and_then
(
|
inner
|
inner
.
downcast_raw
(
id
)
)
}
}
}
feature
!
{
#
!
[
any
(
feature
=
"
std
"
feature
=
"
alloc
"
)
]
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
vec
:
:
Vec
;
macro_rules
!
layer_impl_body
{
(
)
=
>
{
#
[
inline
]
fn
on_register_dispatch
(
&
self
subscriber
:
&
Dispatch
)
{
self
.
deref
(
)
.
on_register_dispatch
(
subscriber
)
;
}
#
[
inline
]
fn
on_layer
(
&
mut
self
subscriber
:
&
mut
S
)
{
self
.
deref_mut
(
)
.
on_layer
(
subscriber
)
;
}
#
[
inline
]
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_new_span
(
attrs
id
ctx
)
}
#
[
inline
]
fn
register_callsite
(
&
self
metadata
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
self
.
deref
(
)
.
register_callsite
(
metadata
)
}
#
[
inline
]
fn
enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
self
.
deref
(
)
.
enabled
(
metadata
ctx
)
}
#
[
inline
]
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
self
.
deref
(
)
.
max_level_hint
(
)
}
#
[
inline
]
fn
on_record
(
&
self
span
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_record
(
span
values
ctx
)
}
#
[
inline
]
fn
on_follows_from
(
&
self
span
:
&
span
:
:
Id
follows
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_follows_from
(
span
follows
ctx
)
}
#
[
inline
]
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
self
.
deref
(
)
.
event_enabled
(
event
ctx
)
}
#
[
inline
]
fn
on_event
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_event
(
event
ctx
)
}
#
[
inline
]
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_enter
(
id
ctx
)
}
#
[
inline
]
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_exit
(
id
ctx
)
}
#
[
inline
]
fn
on_close
(
&
self
id
:
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_close
(
id
ctx
)
}
#
[
inline
]
fn
on_id_change
(
&
self
old
:
&
span
:
:
Id
new
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
self
.
deref
(
)
.
on_id_change
(
old
new
ctx
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
unsafe
fn
downcast_raw
(
&
self
id
:
TypeId
)
-
>
Option
<
*
const
(
)
>
{
self
.
deref
(
)
.
downcast_raw
(
id
)
}
}
;
}
impl
<
L
S
>
Layer
<
S
>
for
Box
<
L
>
where
L
:
Layer
<
S
>
S
:
Subscriber
{
layer_impl_body
!
{
}
}
impl
<
S
>
Layer
<
S
>
for
Box
<
dyn
Layer
<
S
>
+
Send
+
Sync
>
where
S
:
Subscriber
{
layer_impl_body
!
{
}
}
impl
<
S
L
>
Layer
<
S
>
for
Vec
<
L
>
where
L
:
Layer
<
S
>
S
:
Subscriber
{
fn
on_layer
(
&
mut
self
subscriber
:
&
mut
S
)
{
for
l
in
self
{
l
.
on_layer
(
subscriber
)
;
}
}
fn
register_callsite
(
&
self
metadata
:
&
'
static
Metadata
<
'
static
>
)
-
>
Interest
{
/
/
Return
highest
level
of
interest
.
let
mut
interest
=
Interest
:
:
never
(
)
;
for
l
in
self
{
let
new_interest
=
l
.
register_callsite
(
metadata
)
;
if
(
interest
.
is_sometimes
(
)
&
&
new_interest
.
is_always
(
)
)
|
|
(
interest
.
is_never
(
)
&
&
!
new_interest
.
is_never
(
)
)
{
interest
=
new_interest
;
}
}
interest
}
fn
enabled
(
&
self
metadata
:
&
Metadata
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
self
.
iter
(
)
.
all
(
|
l
|
l
.
enabled
(
metadata
ctx
.
clone
(
)
)
)
}
fn
event_enabled
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
-
>
bool
{
self
.
iter
(
)
.
all
(
|
l
|
l
.
event_enabled
(
event
ctx
.
clone
(
)
)
)
}
fn
on_new_span
(
&
self
attrs
:
&
span
:
:
Attributes
<
'
_
>
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_new_span
(
attrs
id
ctx
.
clone
(
)
)
;
}
}
fn
max_level_hint
(
&
self
)
-
>
Option
<
LevelFilter
>
{
/
/
Default
to
OFF
if
there
are
no
inner
layers
.
let
mut
max_level
=
LevelFilter
:
:
OFF
;
for
l
in
self
{
/
/
NOTE
(
eliza
)
:
this
is
slightly
subtle
:
if
*
any
*
layer
/
/
returns
None
we
have
to
return
None
assuming
there
is
/
/
no
max
level
hint
since
that
particular
layer
cannot
/
/
provide
a
hint
.
let
hint
=
l
.
max_level_hint
(
)
?
;
max_level
=
core
:
:
cmp
:
:
max
(
hint
max_level
)
;
}
Some
(
max_level
)
}
fn
on_record
(
&
self
span
:
&
span
:
:
Id
values
:
&
span
:
:
Record
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_record
(
span
values
ctx
.
clone
(
)
)
}
}
fn
on_follows_from
(
&
self
span
:
&
span
:
:
Id
follows
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_follows_from
(
span
follows
ctx
.
clone
(
)
)
;
}
}
fn
on_event
(
&
self
event
:
&
Event
<
'
_
>
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_event
(
event
ctx
.
clone
(
)
)
;
}
}
fn
on_enter
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_enter
(
id
ctx
.
clone
(
)
)
;
}
}
fn
on_exit
(
&
self
id
:
&
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_exit
(
id
ctx
.
clone
(
)
)
;
}
}
fn
on_close
(
&
self
id
:
span
:
:
Id
ctx
:
Context
<
'
_
S
>
)
{
for
l
in
self
{
l
.
on_close
(
id
.
clone
(
)
ctx
.
clone
(
)
)
;
}
}
#
[
doc
(
hidden
)
]
unsafe
fn
downcast_raw
(
&
self
id
:
TypeId
)
-
>
Option
<
*
const
(
)
>
{
/
/
If
downcasting
to
Self
return
a
pointer
to
self
.
if
id
=
=
TypeId
:
:
of
:
:
<
Self
>
(
)
{
return
Some
(
self
as
*
const
_
as
*
const
(
)
)
;
}
/
/
Someone
is
looking
for
per
-
layer
filters
.
But
this
Vec
/
/
might
contain
layers
with
per
-
layer
filters
*
and
*
/
/
layers
without
filters
.
It
should
only
be
treated
as
a
/
/
per
-
layer
-
filtered
layer
if
*
all
*
its
layers
have
/
/
per
-
layer
filters
.
/
/
XXX
(
eliza
)
:
it
'
s
a
bummer
we
have
to
do
this
linear
search
every
/
/
time
.
It
would
be
nice
if
this
could
be
cached
but
that
would
/
/
require
replacing
the
Vec
impl
with
an
impl
for
a
newtype
.
.
.
if
filter
:
:
is_plf_downcast_marker
(
id
)
&
&
self
.
iter
(
)
.
any
(
|
s
|
s
.
downcast_raw
(
id
)
.
is_none
(
)
)
{
return
None
;
}
/
/
Otherwise
return
the
first
child
of
self
that
downcaasts
to
/
/
the
selected
type
if
any
.
/
/
XXX
(
eliza
)
:
hope
this
is
reasonable
lol
self
.
iter
(
)
.
find_map
(
|
l
|
l
.
downcast_raw
(
id
)
)
}
}
}
impl
<
S
:
Subscriber
>
crate
:
:
sealed
:
:
Sealed
for
S
{
}
impl
<
S
:
Subscriber
>
SubscriberExt
for
S
{
}
impl
<
S
:
Subscriber
>
Layer
<
S
>
for
Identity
{
}
impl
Identity
{
pub
fn
new
(
)
-
>
Self
{
Self
{
_p
:
(
)
}
}
}
