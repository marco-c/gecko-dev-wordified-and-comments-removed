use
alloc
:
:
{
string
:
:
{
String
ToString
}
vec
vec
:
:
Vec
}
;
use
crate
:
:
ext
:
:
Byte
;
pub
(
crate
)
mod
naive
;
#
[
macro_use
]
pub
(
crate
)
mod
prop
;
const
SEEDS
:
&
'
static
[
Seed
]
=
&
[
Seed
{
haystack
:
"
a
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
0
]
}
Seed
{
haystack
:
"
aa
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
0
1
]
}
Seed
{
haystack
:
"
aaa
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
0
1
2
]
}
Seed
{
haystack
:
"
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
]
}
Seed
{
haystack
:
"
z
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
]
}
Seed
{
haystack
:
"
zz
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
]
}
Seed
{
haystack
:
"
zza
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
2
]
}
Seed
{
haystack
:
"
zaza
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
1
3
]
}
Seed
{
haystack
:
"
zzza
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
3
]
}
Seed
{
haystack
:
"
\
x00a
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
1
]
}
Seed
{
haystack
:
"
\
x00
"
needles
:
&
[
b
'
\
x00
'
]
positions
:
&
[
0
]
}
Seed
{
haystack
:
"
\
x00
\
x00
"
needles
:
&
[
b
'
\
x00
'
]
positions
:
&
[
0
1
]
}
Seed
{
haystack
:
"
\
x00a
\
x00
"
needles
:
&
[
b
'
\
x00
'
]
positions
:
&
[
0
2
]
}
Seed
{
haystack
:
"
zzzzzzzzzzzzzzzza
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
16
]
}
Seed
{
haystack
:
"
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzza
"
needles
:
&
[
b
'
a
'
]
positions
:
&
[
32
]
}
Seed
{
haystack
:
"
az
"
needles
:
&
[
b
'
a
'
b
'
z
'
]
positions
:
&
[
0
1
]
}
Seed
{
haystack
:
"
az
"
needles
:
&
[
b
'
a
'
b
'
z
'
]
positions
:
&
[
0
1
]
}
Seed
{
haystack
:
"
az
"
needles
:
&
[
b
'
x
'
b
'
y
'
]
positions
:
&
[
]
}
Seed
{
haystack
:
"
az
"
needles
:
&
[
b
'
a
'
b
'
y
'
]
positions
:
&
[
0
]
}
Seed
{
haystack
:
"
az
"
needles
:
&
[
b
'
x
'
b
'
z
'
]
positions
:
&
[
1
]
}
Seed
{
haystack
:
"
yyyyaz
"
needles
:
&
[
b
'
a
'
b
'
z
'
]
positions
:
&
[
4
5
]
}
Seed
{
haystack
:
"
yyyyaz
"
needles
:
&
[
b
'
z
'
b
'
a
'
]
positions
:
&
[
4
5
]
}
Seed
{
haystack
:
"
xyz
"
needles
:
&
[
b
'
x
'
b
'
y
'
b
'
z
'
]
positions
:
&
[
0
1
2
]
}
Seed
{
haystack
:
"
zxy
"
needles
:
&
[
b
'
x
'
b
'
y
'
b
'
z
'
]
positions
:
&
[
0
1
2
]
}
Seed
{
haystack
:
"
zxy
"
needles
:
&
[
b
'
x
'
b
'
a
'
b
'
z
'
]
positions
:
&
[
0
1
]
}
Seed
{
haystack
:
"
zxy
"
needles
:
&
[
b
'
t
'
b
'
a
'
b
'
z
'
]
positions
:
&
[
0
]
}
Seed
{
haystack
:
"
yxz
"
needles
:
&
[
b
'
t
'
b
'
a
'
b
'
z
'
]
positions
:
&
[
2
]
}
]
;
pub
(
crate
)
struct
Runner
{
needle_len
:
usize
}
impl
Runner
{
pub
(
crate
)
fn
new
(
needle_len
:
usize
)
-
>
Runner
{
assert
!
(
needle_len
>
=
1
"
needle_len
must
be
at
least
1
"
)
;
assert
!
(
needle_len
<
=
3
"
needle_len
must
be
at
most
3
"
)
;
Runner
{
needle_len
}
}
pub
(
crate
)
fn
forward_iter
<
F
>
(
self
mut
test
:
F
)
where
F
:
FnMut
(
&
[
u8
]
&
[
u8
]
)
-
>
Option
<
Vec
<
usize
>
>
+
'
static
{
for
seed
in
SEEDS
.
iter
(
)
{
if
seed
.
needles
.
len
(
)
>
self
.
needle_len
{
continue
;
}
for
t
in
seed
.
generate
(
)
{
let
results
=
match
test
(
t
.
haystack
.
as_bytes
(
)
&
t
.
needles
)
{
None
=
>
continue
Some
(
results
)
=
>
results
}
;
assert_eq
!
(
t
.
expected
results
"
needles
:
{
:
?
}
haystack
:
{
:
?
}
"
t
.
needles
.
iter
(
)
.
map
(
|
&
b
|
b
.
to_char
(
)
)
.
collect
:
:
<
Vec
<
char
>
>
(
)
t
.
haystack
)
;
}
}
}
pub
(
crate
)
fn
reverse_iter
<
F
>
(
self
mut
test
:
F
)
where
F
:
FnMut
(
&
[
u8
]
&
[
u8
]
)
-
>
Option
<
Vec
<
usize
>
>
+
'
static
{
for
seed
in
SEEDS
.
iter
(
)
{
if
seed
.
needles
.
len
(
)
>
self
.
needle_len
{
continue
;
}
for
t
in
seed
.
generate
(
)
{
let
mut
results
=
match
test
(
t
.
haystack
.
as_bytes
(
)
&
t
.
needles
)
{
None
=
>
continue
Some
(
results
)
=
>
results
}
;
results
.
reverse
(
)
;
assert_eq
!
(
t
.
expected
results
"
needles
:
{
:
?
}
haystack
:
{
:
?
}
"
t
.
needles
.
iter
(
)
.
map
(
|
&
b
|
b
.
to_char
(
)
)
.
collect
:
:
<
Vec
<
char
>
>
(
)
t
.
haystack
)
;
}
}
}
pub
(
crate
)
fn
count_iter
<
F
>
(
self
mut
test
:
F
)
where
F
:
FnMut
(
&
[
u8
]
&
[
u8
]
)
-
>
Option
<
usize
>
+
'
static
{
for
seed
in
SEEDS
.
iter
(
)
{
if
seed
.
needles
.
len
(
)
>
self
.
needle_len
{
continue
;
}
for
t
in
seed
.
generate
(
)
{
let
got
=
match
test
(
t
.
haystack
.
as_bytes
(
)
&
t
.
needles
)
{
None
=
>
continue
Some
(
got
)
=
>
got
}
;
assert_eq
!
(
t
.
expected
.
len
(
)
got
"
needles
:
{
:
?
}
haystack
:
{
:
?
}
"
t
.
needles
.
iter
(
)
.
map
(
|
&
b
|
b
.
to_char
(
)
)
.
collect
:
:
<
Vec
<
char
>
>
(
)
t
.
haystack
)
;
}
}
}
pub
(
crate
)
fn
forward_oneshot
<
F
>
(
self
mut
test
:
F
)
where
F
:
FnMut
(
&
[
u8
]
&
[
u8
]
)
-
>
Option
<
Option
<
usize
>
>
+
'
static
{
self
.
forward_iter
(
move
|
haystack
needles
|
{
let
mut
start
=
0
;
let
mut
results
=
vec
!
[
]
;
while
let
Some
(
i
)
=
test
(
&
haystack
[
start
.
.
]
needles
)
?
{
results
.
push
(
start
+
i
)
;
start
+
=
i
+
1
;
}
Some
(
results
)
}
)
}
pub
(
crate
)
fn
reverse_oneshot
<
F
>
(
self
mut
test
:
F
)
where
F
:
FnMut
(
&
[
u8
]
&
[
u8
]
)
-
>
Option
<
Option
<
usize
>
>
+
'
static
{
self
.
reverse_iter
(
move
|
haystack
needles
|
{
let
mut
end
=
haystack
.
len
(
)
;
let
mut
results
=
vec
!
[
]
;
while
let
Some
(
i
)
=
test
(
&
haystack
[
.
.
end
]
needles
)
?
{
results
.
push
(
i
)
;
end
=
i
;
}
Some
(
results
)
}
)
}
}
#
[
derive
(
Clone
Debug
)
]
struct
Test
{
haystack
:
String
needles
:
Vec
<
u8
>
expected
:
Vec
<
usize
>
}
impl
Test
{
fn
new
(
seed
:
&
Seed
)
-
>
Test
{
Test
{
haystack
:
seed
.
haystack
.
to_string
(
)
needles
:
seed
.
needles
.
to_vec
(
)
expected
:
seed
.
positions
.
to_vec
(
)
}
}
}
#
[
derive
(
Clone
Debug
)
]
struct
Seed
{
haystack
:
&
'
static
str
needles
:
&
'
static
[
u8
]
positions
:
&
'
static
[
usize
]
}
impl
Seed
{
const
EXPAND_LEN
:
usize
=
{
#
[
cfg
(
not
(
miri
)
)
]
{
515
}
#
[
cfg
(
miri
)
]
{
6
}
}
;
fn
generate
(
&
self
)
-
>
impl
Iterator
<
Item
=
Test
>
{
let
mut
more
=
vec
!
[
]
;
for
i
in
0
.
.
Seed
:
:
EXPAND_LEN
{
let
mut
t
=
Test
:
:
new
(
self
)
;
let
mut
new
:
String
=
core
:
:
iter
:
:
repeat
(
'
%
'
)
.
take
(
i
)
.
collect
(
)
;
new
.
push_str
(
&
t
.
haystack
)
;
t
.
haystack
=
new
;
t
.
expected
=
t
.
expected
.
into_iter
(
)
.
map
(
|
p
|
p
+
i
)
.
collect
(
)
;
more
.
push
(
t
)
;
}
for
i
in
1
.
.
Seed
:
:
EXPAND_LEN
{
let
mut
t
=
Test
:
:
new
(
self
)
;
let
padding
:
String
=
core
:
:
iter
:
:
repeat
(
'
%
'
)
.
take
(
i
)
.
collect
(
)
;
t
.
haystack
.
push_str
(
&
padding
)
;
more
.
push
(
t
)
;
}
more
.
into_iter
(
)
}
}
