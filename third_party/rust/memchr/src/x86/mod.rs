use
fallback
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
avx
;
mod
sse2
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
macro_rules
!
ifunc
{
(
fnty
:
ty
name
:
ident
haystack
:
ident
(
needle
:
ident
)
+
)
=
>
{
{
use
std
:
:
mem
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
type
FnRaw
=
*
mut
(
)
;
static
FN
:
AtomicPtr
<
(
)
>
=
AtomicPtr
:
:
new
(
detect
as
FnRaw
)
;
fn
detect
(
(
needle
:
u8
)
+
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
let
fun
=
if
cfg
!
(
memchr_runtime_avx
)
&
&
is_x86_feature_detected
!
(
"
avx2
"
)
{
avx
:
:
name
as
FnRaw
}
else
if
cfg
!
(
memchr_runtime_sse2
)
{
sse2
:
:
name
as
FnRaw
}
else
{
fallback
:
:
name
as
FnRaw
}
;
FN
.
store
(
fun
as
FnRaw
Ordering
:
:
Relaxed
)
;
unsafe
{
mem
:
:
transmute
:
:
<
FnRaw
fnty
>
(
fun
)
(
(
needle
)
+
haystack
)
}
}
unsafe
{
let
fun
=
FN
.
load
(
Ordering
:
:
Relaxed
)
;
mem
:
:
transmute
:
:
<
FnRaw
fnty
>
(
fun
)
(
(
needle
)
+
haystack
)
}
}
}
}
#
[
cfg
(
not
(
feature
=
"
use_std
"
)
)
]
macro_rules
!
ifunc
{
(
fnty
:
ty
name
:
ident
haystack
:
ident
(
needle
:
ident
)
+
)
=
>
{
{
if
cfg
!
(
memchr_runtime_sse2
)
{
unsafe
{
sse2
:
:
name
(
(
needle
)
+
haystack
)
}
}
else
{
fallback
:
:
name
(
(
needle
)
+
haystack
)
}
}
}
}
#
[
inline
(
always
)
]
pub
fn
memchr
(
n1
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
ifunc
!
(
fn
(
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memchr
haystack
n1
)
}
#
[
inline
(
always
)
]
pub
fn
memchr2
(
n1
:
u8
n2
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
ifunc
!
(
fn
(
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memchr2
haystack
n1
n2
)
}
#
[
inline
(
always
)
]
pub
fn
memchr3
(
n1
:
u8
n2
:
u8
n3
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
ifunc
!
(
fn
(
u8
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memchr3
haystack
n1
n2
n3
)
}
#
[
inline
(
always
)
]
pub
fn
memrchr
(
n1
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
ifunc
!
(
fn
(
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memrchr
haystack
n1
)
}
#
[
inline
(
always
)
]
pub
fn
memrchr2
(
n1
:
u8
n2
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
ifunc
!
(
fn
(
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memrchr2
haystack
n1
n2
)
}
#
[
inline
(
always
)
]
pub
fn
memrchr3
(
n1
:
u8
n2
:
u8
n3
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
ifunc
!
(
fn
(
u8
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memrchr3
haystack
n1
n2
n3
)
}
