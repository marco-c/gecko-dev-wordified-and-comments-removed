use
core
:
:
arch
:
:
x86_64
:
:
__m128i
;
use
crate
:
:
memmem
:
:
{
genericsimd
NeedleInfo
}
;
#
[
derive
(
Clone
Copy
Debug
)
]
pub
(
crate
)
struct
Forward
(
genericsimd
:
:
Forward
)
;
impl
Forward
{
pub
(
crate
)
fn
new
(
ninfo
:
&
NeedleInfo
needle
:
&
[
u8
]
)
-
>
Option
<
Forward
>
{
if
!
cfg
!
(
memchr_runtime_sse2
)
{
return
None
;
}
genericsimd
:
:
Forward
:
:
new
(
ninfo
needle
)
.
map
(
Forward
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
min_haystack_len
(
&
self
)
-
>
usize
{
self
.
0
.
min_haystack_len
:
:
<
__m128i
>
(
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
find
(
&
self
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe
{
self
.
find_impl
(
haystack
needle
)
}
}
#
[
target_feature
(
enable
=
"
sse2
"
)
]
unsafe
fn
find_impl
(
&
self
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
genericsimd
:
:
fwd_find
:
:
<
__m128i
>
(
&
self
.
0
haystack
needle
)
}
}
#
[
cfg
(
all
(
test
feature
=
"
std
"
not
(
miri
)
)
)
]
mod
tests
{
use
crate
:
:
memmem
:
:
{
prefilter
:
:
PrefilterState
NeedleInfo
}
;
fn
find
(
_
:
&
mut
PrefilterState
ninfo
:
&
NeedleInfo
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
super
:
:
Forward
:
:
new
(
ninfo
needle
)
.
unwrap
(
)
.
find
(
haystack
needle
)
}
#
[
test
]
fn
prefilter_permutations
(
)
{
use
crate
:
:
memmem
:
:
prefilter
:
:
tests
:
:
PrefilterTest
;
unsafe
{
PrefilterTest
:
:
run_all_tests_filter
(
find
|
t
|
{
let
fwd
=
match
super
:
:
Forward
:
:
new
(
&
t
.
ninfo
&
t
.
needle
)
{
None
=
>
return
false
Some
(
fwd
)
=
>
fwd
}
;
t
.
haystack
.
len
(
)
>
=
fwd
.
min_haystack_len
(
)
}
)
}
}
}
