use
crate
:
:
memmem
:
:
{
rarebytes
:
:
RareNeedleBytes
NeedleInfo
}
;
mod
fallback
;
#
[
cfg
(
memchr_runtime_simd
)
]
mod
genericsimd
;
#
[
cfg
(
all
(
not
(
miri
)
target_arch
=
"
wasm32
"
memchr_runtime_simd
)
)
]
mod
wasm
;
#
[
cfg
(
all
(
not
(
miri
)
target_arch
=
"
x86_64
"
memchr_runtime_simd
)
)
]
mod
x86
;
const
MAX_FALLBACK_RANK
:
usize
=
250
;
pub
(
crate
)
struct
Pre
<
'
a
>
{
pub
(
crate
)
state
:
&
'
a
mut
PrefilterState
pub
(
crate
)
prefn
:
PrefilterFn
pub
(
crate
)
ninfo
:
&
'
a
NeedleInfo
}
impl
<
'
a
>
Pre
<
'
a
>
{
#
[
inline
(
always
)
]
pub
(
crate
)
fn
call
(
&
mut
self
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
self
.
prefn
.
call
(
self
.
state
self
.
ninfo
haystack
needle
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
should_call
(
&
mut
self
)
-
>
bool
{
self
.
state
.
is_effective
(
)
}
}
#
[
derive
(
Clone
Copy
)
]
pub
(
crate
)
struct
PrefilterFn
(
PrefilterFnTy
)
;
pub
(
crate
)
type
PrefilterFnTy
=
unsafe
fn
(
prestate
:
&
mut
PrefilterState
ninfo
:
&
NeedleInfo
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
;
#
[
cfg
(
memchr_runtime_simd
)
]
fn
simple_memchr_fallback
(
_prestate
:
&
mut
PrefilterState
ninfo
:
&
NeedleInfo
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
let
(
rare
_
)
=
ninfo
.
rarebytes
.
as_rare_ordered_usize
(
)
;
crate
:
:
memchr
(
needle
[
rare
]
haystack
)
.
map
(
|
i
|
i
.
saturating_sub
(
rare
)
)
}
impl
PrefilterFn
{
pub
(
crate
)
unsafe
fn
new
(
prefn
:
PrefilterFnTy
)
-
>
PrefilterFn
{
PrefilterFn
(
prefn
)
}
pub
fn
call
(
self
prestate
:
&
mut
PrefilterState
ninfo
:
&
NeedleInfo
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe
{
(
self
.
0
)
(
prestate
ninfo
haystack
needle
)
}
}
}
impl
core
:
:
fmt
:
:
Debug
for
PrefilterFn
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
)
-
>
core
:
:
fmt
:
:
Result
{
"
<
prefilter
-
fn
(
.
.
.
)
>
"
.
fmt
(
f
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
non_exhaustive
]
pub
enum
Prefilter
{
None
Auto
}
impl
Default
for
Prefilter
{
fn
default
(
)
-
>
Prefilter
{
Prefilter
:
:
Auto
}
}
impl
Prefilter
{
pub
(
crate
)
fn
is_none
(
&
self
)
-
>
bool
{
match
*
self
{
Prefilter
:
:
None
=
>
true
_
=
>
false
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
struct
PrefilterState
{
skips
:
u32
skipped
:
u32
}
impl
PrefilterState
{
const
MIN_SKIPS
:
u32
=
50
;
const
MIN_SKIP_BYTES
:
u32
=
8
;
pub
(
crate
)
fn
new
(
)
-
>
PrefilterState
{
PrefilterState
{
skips
:
1
skipped
:
0
}
}
pub
(
crate
)
fn
inert
(
)
-
>
PrefilterState
{
PrefilterState
{
skips
:
0
skipped
:
0
}
}
#
[
inline
]
pub
(
crate
)
fn
update
(
&
mut
self
skipped
:
usize
)
{
self
.
skips
=
self
.
skips
.
saturating_add
(
1
)
;
if
skipped
>
core
:
:
u32
:
:
MAX
as
usize
{
self
.
skipped
=
core
:
:
u32
:
:
MAX
;
}
else
{
self
.
skipped
=
self
.
skipped
.
saturating_add
(
skipped
as
u32
)
;
}
}
#
[
inline
]
pub
(
crate
)
fn
is_effective
(
&
mut
self
)
-
>
bool
{
if
self
.
is_inert
(
)
{
return
false
;
}
if
self
.
skips
(
)
<
PrefilterState
:
:
MIN_SKIPS
{
return
true
;
}
if
self
.
skipped
>
=
PrefilterState
:
:
MIN_SKIP_BYTES
*
self
.
skips
(
)
{
return
true
;
}
self
.
skips
=
0
;
false
}
#
[
inline
]
fn
is_inert
(
&
self
)
-
>
bool
{
self
.
skips
=
=
0
}
#
[
inline
]
fn
skips
(
&
self
)
-
>
u32
{
self
.
skips
.
saturating_sub
(
1
)
}
}
#
[
inline
(
always
)
]
pub
(
crate
)
fn
forward
(
config
:
&
Prefilter
rare
:
&
RareNeedleBytes
needle
:
&
[
u8
]
)
-
>
Option
<
PrefilterFn
>
{
if
config
.
is_none
(
)
|
|
needle
.
len
(
)
<
=
1
{
return
None
;
}
#
[
cfg
(
all
(
not
(
miri
)
target_arch
=
"
x86_64
"
memchr_runtime_simd
)
)
]
{
#
[
cfg
(
feature
=
"
std
"
)
]
{
if
cfg
!
(
memchr_runtime_avx
)
{
if
is_x86_feature_detected
!
(
"
avx2
"
)
{
return
unsafe
{
Some
(
PrefilterFn
:
:
new
(
x86
:
:
avx
:
:
find
)
)
}
;
}
}
}
if
cfg
!
(
memchr_runtime_sse2
)
{
return
unsafe
{
Some
(
PrefilterFn
:
:
new
(
x86
:
:
sse
:
:
find
)
)
}
;
}
}
#
[
cfg
(
all
(
not
(
miri
)
target_arch
=
"
wasm32
"
memchr_runtime_simd
)
)
]
{
if
true
{
return
unsafe
{
Some
(
PrefilterFn
:
:
new
(
wasm
:
:
find
)
)
}
;
}
}
let
(
rare1_rank
_
)
=
rare
.
as_ranks
(
needle
)
;
if
rare1_rank
<
=
MAX_FALLBACK_RANK
{
return
unsafe
{
Some
(
PrefilterFn
:
:
new
(
fallback
:
:
find
)
)
}
;
}
None
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
fn
minimum_len
(
_haystack
:
&
[
u8
]
needle
:
&
[
u8
]
)
-
>
usize
{
const
PREFILTER_LENGTH_FACTOR
:
usize
=
2
;
const
VECTOR_MIN_LENGTH
:
usize
=
16
;
let
min
=
core
:
:
cmp
:
:
max
(
VECTOR_MIN_LENGTH
PREFILTER_LENGTH_FACTOR
*
needle
.
len
(
)
)
;
min
+
1
}
#
[
cfg
(
all
(
test
feature
=
"
std
"
not
(
miri
)
)
)
]
pub
(
crate
)
mod
tests
{
use
std
:
:
convert
:
:
{
TryFrom
TryInto
}
;
use
super
:
:
*
;
use
crate
:
:
memmem
:
:
{
prefilter
:
:
PrefilterFnTy
rabinkarp
rarebytes
:
:
RareNeedleBytes
}
;
pub
(
crate
)
struct
PrefilterTest
{
pub
(
crate
)
ninfo
:
NeedleInfo
pub
(
crate
)
haystack
:
Vec
<
u8
>
pub
(
crate
)
needle
:
Vec
<
u8
>
pub
(
crate
)
output
:
Option
<
usize
>
}
impl
PrefilterTest
{
pub
(
crate
)
unsafe
fn
run_all_tests
(
prefn
:
PrefilterFnTy
)
{
PrefilterTest
:
:
run_all_tests_filter
(
prefn
|
_
|
true
)
}
pub
(
crate
)
unsafe
fn
run_all_tests_filter
(
prefn
:
PrefilterFnTy
mut
predicate
:
impl
FnMut
(
&
PrefilterTest
)
-
>
bool
)
{
for
seed
in
PREFILTER_TEST_SEEDS
{
for
test
in
seed
.
generate
(
)
{
if
predicate
(
&
test
)
{
test
.
run
(
prefn
)
;
}
}
}
}
fn
new
(
seed
:
PrefilterTestSeed
rare1i
:
usize
rare2i
:
usize
haystack_len
:
usize
needle_len
:
usize
output
:
Option
<
usize
>
)
-
>
Option
<
PrefilterTest
>
{
let
mut
rare1i
:
u8
=
rare1i
.
try_into
(
)
.
unwrap
(
)
;
let
mut
rare2i
:
u8
=
rare2i
.
try_into
(
)
.
unwrap
(
)
;
let
mut
haystack
=
vec
!
[
b
'
'
;
haystack_len
]
;
let
mut
needle
=
vec
!
[
b
'
#
'
;
needle_len
]
;
needle
[
0
]
=
seed
.
first
;
needle
[
rare1i
as
usize
]
=
seed
.
rare1
;
needle
[
rare2i
as
usize
]
=
seed
.
rare2
;
if
let
Some
(
i
)
=
output
{
haystack
[
i
.
.
i
+
needle
.
len
(
)
]
.
copy_from_slice
(
&
needle
)
;
}
if
let
Some
(
i
)
=
crate
:
:
memchr
(
seed
.
rare1
&
needle
)
{
rare1i
=
u8
:
:
try_from
(
i
)
.
unwrap
(
)
;
}
if
let
Some
(
i
)
=
crate
:
:
memchr
(
seed
.
rare2
&
needle
)
{
rare2i
=
u8
:
:
try_from
(
i
)
.
unwrap
(
)
;
}
let
ninfo
=
NeedleInfo
{
rarebytes
:
RareNeedleBytes
:
:
new
(
rare1i
rare2i
)
nhash
:
rabinkarp
:
:
NeedleHash
:
:
forward
(
&
needle
)
}
;
Some
(
PrefilterTest
{
ninfo
haystack
needle
output
}
)
}
unsafe
fn
run
(
&
self
prefn
:
PrefilterFnTy
)
{
let
mut
prestate
=
PrefilterState
:
:
new
(
)
;
assert_eq
!
(
self
.
output
prefn
(
&
mut
prestate
&
self
.
ninfo
&
self
.
haystack
&
self
.
needle
)
"
ninfo
:
{
:
?
}
haystack
(
len
=
{
}
)
:
{
:
?
}
needle
(
len
=
{
}
)
:
{
:
?
}
"
self
.
ninfo
self
.
haystack
.
len
(
)
std
:
:
str
:
:
from_utf8
(
&
self
.
haystack
)
.
unwrap
(
)
self
.
needle
.
len
(
)
std
:
:
str
:
:
from_utf8
(
&
self
.
needle
)
.
unwrap
(
)
)
;
}
}
const
PREFILTER_TEST_SEEDS
:
&
[
PrefilterTestSeed
]
=
&
[
PrefilterTestSeed
{
first
:
b
'
x
'
rare1
:
b
'
y
'
rare2
:
b
'
z
'
}
PrefilterTestSeed
{
first
:
b
'
x
'
rare1
:
b
'
x
'
rare2
:
b
'
z
'
}
PrefilterTestSeed
{
first
:
b
'
x
'
rare1
:
b
'
y
'
rare2
:
b
'
x
'
}
PrefilterTestSeed
{
first
:
b
'
x
'
rare1
:
b
'
x
'
rare2
:
b
'
x
'
}
PrefilterTestSeed
{
first
:
b
'
x
'
rare1
:
b
'
y
'
rare2
:
b
'
y
'
}
]
;
#
[
derive
(
Clone
Copy
)
]
struct
PrefilterTestSeed
{
first
:
u8
rare1
:
u8
rare2
:
u8
}
impl
PrefilterTestSeed
{
fn
generate
(
self
)
-
>
impl
Iterator
<
Item
=
PrefilterTest
>
{
let
len_start
=
2
;
(
len_start
.
.
=
40
)
.
flat_map
(
move
|
needle_len
|
{
let
rare_start
=
len_start
-
1
;
(
rare_start
.
.
needle_len
)
.
flat_map
(
move
|
rare1i
|
{
(
rare1i
.
.
needle_len
)
.
flat_map
(
move
|
rare2i
|
{
(
needle_len
.
.
=
66
)
.
flat_map
(
move
|
haystack_len
|
{
PrefilterTest
:
:
new
(
self
rare1i
rare2i
haystack_len
needle_len
None
)
.
into_iter
(
)
.
chain
(
(
0
.
.
=
(
haystack_len
-
needle_len
)
)
.
flat_map
(
move
|
output
|
{
PrefilterTest
:
:
new
(
self
rare1i
rare2i
haystack_len
needle_len
Some
(
output
)
)
}
)
)
}
)
}
)
}
)
}
)
}
}
}
