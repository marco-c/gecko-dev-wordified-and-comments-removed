use
core
:
:
mem
:
:
size_of
;
use
crate
:
:
memmem
:
:
{
prefilter
:
:
{
PrefilterFnTy
PrefilterState
}
vector
:
:
Vector
NeedleInfo
}
;
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
find
<
V
:
Vector
>
(
prestate
:
&
mut
PrefilterState
ninfo
:
&
NeedleInfo
haystack
:
&
[
u8
]
needle
:
&
[
u8
]
fallback
:
PrefilterFnTy
)
-
>
Option
<
usize
>
{
assert
!
(
needle
.
len
(
)
>
=
2
"
needle
must
be
at
least
2
bytes
"
)
;
let
(
rare1i
rare2i
)
=
ninfo
.
rarebytes
.
as_rare_ordered_usize
(
)
;
let
min_haystack_len
=
rare2i
+
size_of
:
:
<
V
>
(
)
;
if
haystack
.
len
(
)
<
min_haystack_len
{
return
fallback
(
prestate
ninfo
haystack
needle
)
;
}
let
start_ptr
=
haystack
.
as_ptr
(
)
;
let
end_ptr
=
start_ptr
.
add
(
haystack
.
len
(
)
)
;
let
max_ptr
=
end_ptr
.
sub
(
min_haystack_len
)
;
let
mut
ptr
=
start_ptr
;
let
rare1chunk
=
V
:
:
splat
(
needle
[
rare1i
]
)
;
let
rare2chunk
=
V
:
:
splat
(
needle
[
rare2i
]
)
;
while
ptr
<
=
max_ptr
{
let
m
=
find_in_chunk2
(
ptr
rare1i
rare2i
rare1chunk
rare2chunk
)
;
if
let
Some
(
chunki
)
=
m
{
return
Some
(
matched
(
prestate
start_ptr
ptr
chunki
)
)
;
}
ptr
=
ptr
.
add
(
size_of
:
:
<
V
>
(
)
)
;
}
if
ptr
<
end_ptr
{
ptr
=
max_ptr
;
let
m
=
find_in_chunk2
(
ptr
rare1i
rare2i
rare1chunk
rare2chunk
)
;
if
let
Some
(
chunki
)
=
m
{
return
Some
(
matched
(
prestate
start_ptr
ptr
chunki
)
)
;
}
}
prestate
.
update
(
haystack
.
len
(
)
)
;
None
}
#
[
inline
(
always
)
]
unsafe
fn
find_in_chunk2
<
V
:
Vector
>
(
ptr
:
*
const
u8
rare1i
:
usize
rare2i
:
usize
rare1chunk
:
V
rare2chunk
:
V
)
-
>
Option
<
usize
>
{
let
chunk0
=
V
:
:
load_unaligned
(
ptr
.
add
(
rare1i
)
)
;
let
chunk1
=
V
:
:
load_unaligned
(
ptr
.
add
(
rare2i
)
)
;
let
eq0
=
chunk0
.
cmpeq
(
rare1chunk
)
;
let
eq1
=
chunk1
.
cmpeq
(
rare2chunk
)
;
let
match_offsets
=
eq0
.
and
(
eq1
)
.
movemask
(
)
;
if
match_offsets
=
=
0
{
return
None
;
}
Some
(
match_offsets
.
trailing_zeros
(
)
as
usize
)
}
#
[
allow
(
dead_code
)
]
#
[
inline
(
always
)
]
unsafe
fn
find_in_chunk3
<
V
:
Vector
>
(
ptr
:
*
const
u8
rare1i
:
usize
rare2i
:
usize
firstchunk
:
V
rare1chunk
:
V
rare2chunk
:
V
)
-
>
Option
<
usize
>
{
let
chunk0
=
V
:
:
load_unaligned
(
ptr
)
;
let
chunk1
=
V
:
:
load_unaligned
(
ptr
.
add
(
rare1i
)
)
;
let
chunk2
=
V
:
:
load_unaligned
(
ptr
.
add
(
rare2i
)
)
;
let
eq0
=
chunk0
.
cmpeq
(
firstchunk
)
;
let
eq1
=
chunk1
.
cmpeq
(
rare1chunk
)
;
let
eq2
=
chunk2
.
cmpeq
(
rare2chunk
)
;
let
match_offsets
=
eq0
.
and
(
eq1
)
.
and
(
eq2
)
.
movemask
(
)
;
if
match_offsets
=
=
0
{
return
None
;
}
Some
(
match_offsets
.
trailing_zeros
(
)
as
usize
)
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
matched
(
prestate
:
&
mut
PrefilterState
start_ptr
:
*
const
u8
ptr
:
*
const
u8
chunki
:
usize
)
-
>
usize
{
let
found
=
diff
(
ptr
start_ptr
)
+
chunki
;
prestate
.
update
(
found
)
;
found
}
fn
diff
(
a
:
*
const
u8
b
:
*
const
u8
)
-
>
usize
{
debug_assert
!
(
a
>
=
b
)
;
(
a
as
usize
)
-
(
b
as
usize
)
}
