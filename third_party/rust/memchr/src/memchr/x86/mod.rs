use
super
:
:
fallback
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
avx
;
mod
sse2
;
#
[
cfg
(
feature
=
"
std
"
)
]
macro_rules
!
unsafe_ifunc
{
(
fnty
:
ty
name
:
ident
haystack
:
ident
(
needle
:
ident
)
+
)
=
>
{
{
use
std
:
:
{
mem
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
}
;
type
FnRaw
=
*
mut
(
)
;
static
FN
:
AtomicPtr
<
(
)
>
=
AtomicPtr
:
:
new
(
detect
as
FnRaw
)
;
fn
detect
(
(
needle
:
u8
)
+
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
let
fun
=
if
cfg
!
(
memchr_runtime_avx
)
&
&
is_x86_feature_detected
!
(
"
avx2
"
)
{
avx
:
:
name
as
FnRaw
}
else
if
cfg
!
(
memchr_runtime_sse2
)
{
sse2
:
:
name
as
FnRaw
}
else
{
fallback
:
:
name
as
FnRaw
}
;
FN
.
store
(
fun
as
FnRaw
Ordering
:
:
Relaxed
)
;
/
/
SAFETY
:
By
virtue
of
the
caller
contract
fnty
is
a
function
/
/
pointer
which
is
always
safe
to
transmute
with
a
*
mut
(
)
.
/
/
Also
if
'
fun
is
the
AVX
routine
then
it
is
guaranteed
to
be
/
/
supported
since
we
checked
the
avx2
feature
.
unsafe
{
mem
:
:
transmute
:
:
<
FnRaw
fnty
>
(
fun
)
(
(
needle
)
+
haystack
)
}
}
/
/
SAFETY
:
By
virtue
of
the
caller
contract
fnty
is
a
function
/
/
pointer
which
is
always
safe
to
transmute
with
a
*
mut
(
)
.
Also
if
/
/
'
fun
is
the
AVX
routine
then
it
is
guaranteed
to
be
supported
since
/
/
we
checked
the
avx2
feature
.
unsafe
{
let
fun
=
FN
.
load
(
Ordering
:
:
Relaxed
)
;
mem
:
:
transmute
:
:
<
FnRaw
fnty
>
(
fun
)
(
(
needle
)
+
haystack
)
}
}
}
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
macro_rules
!
unsafe_ifunc
{
(
fnty
:
ty
name
:
ident
haystack
:
ident
(
needle
:
ident
)
+
)
=
>
{
{
if
cfg
!
(
memchr_runtime_sse2
)
{
unsafe
{
sse2
:
:
name
(
(
needle
)
+
haystack
)
}
}
else
{
fallback
:
:
name
(
(
needle
)
+
haystack
)
}
}
}
}
#
[
inline
(
always
)
]
pub
fn
memchr
(
n1
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe_ifunc
!
(
fn
(
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memchr
haystack
n1
)
}
#
[
inline
(
always
)
]
pub
fn
memchr2
(
n1
:
u8
n2
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe_ifunc
!
(
fn
(
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memchr2
haystack
n1
n2
)
}
#
[
inline
(
always
)
]
pub
fn
memchr3
(
n1
:
u8
n2
:
u8
n3
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe_ifunc
!
(
fn
(
u8
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memchr3
haystack
n1
n2
n3
)
}
#
[
inline
(
always
)
]
pub
fn
memrchr
(
n1
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe_ifunc
!
(
fn
(
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memrchr
haystack
n1
)
}
#
[
inline
(
always
)
]
pub
fn
memrchr2
(
n1
:
u8
n2
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe_ifunc
!
(
fn
(
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memrchr2
haystack
n1
n2
)
}
#
[
inline
(
always
)
]
pub
fn
memrchr3
(
n1
:
u8
n2
:
u8
n3
:
u8
haystack
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
unsafe_ifunc
!
(
fn
(
u8
u8
u8
&
[
u8
]
)
-
>
Option
<
usize
>
memrchr3
haystack
n1
n2
n3
)
}
