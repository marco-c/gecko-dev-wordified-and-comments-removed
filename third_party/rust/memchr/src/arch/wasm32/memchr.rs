macro_rules
!
defraw
{
(
ty
:
ident
find
:
ident
start
:
ident
end
:
ident
(
needles
:
ident
)
+
)
=
>
{
{
use
crate
:
:
arch
:
:
wasm32
:
:
simd128
:
:
memchr
:
:
ty
;
debug
!
(
"
chose
simd128
for
{
}
"
stringify
!
(
ty
)
)
;
debug_assert
!
(
ty
:
:
is_available
(
)
)
;
/
/
SAFETY
:
We
know
that
wasm
memchr
is
always
available
whenever
/
/
code
is
compiled
for
wasm32
with
the
simd128
target
feature
/
/
enabled
.
ty
:
:
new_unchecked
(
(
needles
)
+
)
.
find
(
start
end
)
}
}
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
memchr_raw
(
n1
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
Option
<
*
const
u8
>
{
defraw
!
(
One
find_raw
start
end
n1
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
memrchr_raw
(
n1
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
Option
<
*
const
u8
>
{
defraw
!
(
One
rfind_raw
start
end
n1
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
memchr2_raw
(
n1
:
u8
n2
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
Option
<
*
const
u8
>
{
defraw
!
(
Two
find_raw
start
end
n1
n2
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
memrchr2_raw
(
n1
:
u8
n2
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
Option
<
*
const
u8
>
{
defraw
!
(
Two
rfind_raw
start
end
n1
n2
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
memchr3_raw
(
n1
:
u8
n2
:
u8
n3
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
Option
<
*
const
u8
>
{
defraw
!
(
Three
find_raw
start
end
n1
n2
n3
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
memrchr3_raw
(
n1
:
u8
n2
:
u8
n3
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
Option
<
*
const
u8
>
{
defraw
!
(
Three
rfind_raw
start
end
n1
n2
n3
)
}
#
[
inline
(
always
)
]
pub
(
crate
)
unsafe
fn
count_raw
(
n1
:
u8
start
:
*
const
u8
end
:
*
const
u8
)
-
>
usize
{
defraw
!
(
One
count_raw
start
end
n1
)
}
