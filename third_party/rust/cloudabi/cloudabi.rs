#
!
[
no_std
]
#
!
[
allow
(
non_camel_case_types
)
]
#
[
cfg
(
feature
=
"
bitflags
"
)
]
use
bitflags
:
:
bitflags
;
#
[
cfg
(
not
(
feature
=
"
bitflags
"
)
)
]
macro_rules
!
bitflags
{
(
(
#
[
attr
:
meta
]
)
*
pub
struct
name
:
ident
:
type
:
ty
{
(
(
#
[
const_attr
:
meta
]
)
*
const
const
:
ident
=
val
:
expr
;
)
*
}
)
=
>
{
(
#
[
attr
]
)
*
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
name
{
bits
:
type
}
impl
name
{
(
(
#
[
const_attr
]
)
*
pub
const
const
:
name
=
name
{
bits
:
val
}
;
)
*
pub
const
fn
bits
(
&
self
)
-
>
type
{
self
.
bits
}
pub
const
unsafe
fn
from_bits_unchecked
(
bits
:
type
)
-
>
Self
{
name
{
bits
}
}
}
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
advice
{
DONTNEED
=
1
NOREUSE
=
2
NORMAL
=
3
RANDOM
=
4
SEQUENTIAL
=
5
WILLNEED
=
6
}
#
[
repr
(
u32
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
auxtype
{
ARGDATA
=
256
ARGDATALEN
=
257
BASE
=
7
CANARY
=
258
CANARYLEN
=
259
NCPUS
=
260
NULL
=
0
PAGESZ
=
6
PHDR
=
3
PHNUM
=
4
PID
=
263
SYSINFO_EHDR
=
262
TID
=
261
}
#
[
repr
(
u32
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
clockid
{
MONOTONIC
=
1
PROCESS_CPUTIME_ID
=
2
REALTIME
=
3
THREAD_CPUTIME_ID
=
4
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
condvar
(
pub
u32
)
;
pub
const
CONDVAR_HAS_NO_WAITERS
:
condvar
=
condvar
(
0
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
device
(
pub
u64
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
dircookie
(
pub
u64
)
;
pub
const
DIRCOOKIE_START
:
dircookie
=
dircookie
(
0
)
;
#
[
repr
(
u16
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
errno
{
SUCCESS
=
0
TOOBIG
=
1
ACCES
=
2
ADDRINUSE
=
3
ADDRNOTAVAIL
=
4
AFNOSUPPORT
=
5
AGAIN
=
6
ALREADY
=
7
BADF
=
8
BADMSG
=
9
BUSY
=
10
CANCELED
=
11
CHILD
=
12
CONNABORTED
=
13
CONNREFUSED
=
14
CONNRESET
=
15
DEADLK
=
16
DESTADDRREQ
=
17
DOM
=
18
DQUOT
=
19
EXIST
=
20
FAULT
=
21
FBIG
=
22
HOSTUNREACH
=
23
IDRM
=
24
ILSEQ
=
25
INPROGRESS
=
26
INTR
=
27
INVAL
=
28
IO
=
29
ISCONN
=
30
ISDIR
=
31
LOOP
=
32
MFILE
=
33
MLINK
=
34
MSGSIZE
=
35
MULTIHOP
=
36
NAMETOOLONG
=
37
NETDOWN
=
38
NETRESET
=
39
NETUNREACH
=
40
NFILE
=
41
NOBUFS
=
42
NODEV
=
43
NOENT
=
44
NOEXEC
=
45
NOLCK
=
46
NOLINK
=
47
NOMEM
=
48
NOMSG
=
49
NOPROTOOPT
=
50
NOSPC
=
51
NOSYS
=
52
NOTCONN
=
53
NOTDIR
=
54
NOTEMPTY
=
55
NOTRECOVERABLE
=
56
NOTSOCK
=
57
NOTSUP
=
58
NOTTY
=
59
NXIO
=
60
OVERFLOW
=
61
OWNERDEAD
=
62
PERM
=
63
PIPE
=
64
PROTO
=
65
PROTONOSUPPORT
=
66
PROTOTYPE
=
67
RANGE
=
68
ROFS
=
69
SPIPE
=
70
SRCH
=
71
STALE
=
72
TIMEDOUT
=
73
TXTBSY
=
74
XDEV
=
75
NOTCAPABLE
=
76
}
bitflags
!
{
/
/
/
The
state
of
the
file
descriptor
subscribed
to
with
/
/
/
[
FD_READ
]
(
enum
.
eventtype
.
html
#
variant
.
FD_READ
)
or
[
FD_WRITE
]
(
enum
.
eventtype
.
html
#
variant
.
FD_WRITE
)
.
#
[
repr
(
C
)
]
pub
struct
eventrwflags
:
u16
{
/
/
/
The
peer
of
this
socket
has
closed
or
disconnected
.
const
HANGUP
=
0x0001
;
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
eventtype
{
CLOCK
=
1
CONDVAR
=
2
FD_READ
=
3
FD_WRITE
=
4
LOCK_RDLOCK
=
5
LOCK_WRLOCK
=
6
PROC_TERMINATE
=
7
}
pub
type
exitcode
=
u32
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
fd
(
pub
u32
)
;
pub
const
PROCESS_CHILD
:
fd
=
fd
(
0xffffffff
)
;
pub
const
MAP_ANON_FD
:
fd
=
fd
(
0xffffffff
)
;
bitflags
!
{
/
/
/
File
descriptor
flags
.
#
[
repr
(
C
)
]
pub
struct
fdflags
:
u16
{
/
/
/
Append
mode
:
Data
written
to
the
file
is
always
/
/
/
appended
to
the
file
'
s
end
.
const
APPEND
=
0x0001
;
/
/
/
Write
according
to
synchronized
I
/
O
data
integrity
/
/
/
completion
.
Only
the
data
stored
in
the
file
is
/
/
/
synchronized
.
const
DSYNC
=
0x0002
;
/
/
/
Non
-
blocking
mode
.
const
NONBLOCK
=
0x0004
;
/
/
/
Synchronized
read
I
/
O
operations
.
const
RSYNC
=
0x0008
;
/
/
/
Write
according
to
synchronized
I
/
O
file
integrity
/
/
/
completion
.
In
addition
to
synchronizing
the
data
/
/
/
stored
in
the
file
the
system
may
also
synchronously
/
/
/
update
the
file
'
s
metadata
.
const
SYNC
=
0x0010
;
}
}
bitflags
!
{
/
/
/
Which
file
descriptor
attributes
to
adjust
.
#
[
repr
(
C
)
]
pub
struct
fdsflags
:
u16
{
/
/
/
Adjust
the
file
descriptor
flags
stored
in
/
/
/
[
fdstat
.
fs_flags
]
(
struct
.
fdstat
.
html
#
structfield
.
fs_flags
)
.
const
FLAGS
=
0x0001
;
/
/
/
Restrict
the
rights
of
the
file
descriptor
to
the
/
/
/
rights
stored
in
[
fdstat
.
fs_rights_base
]
(
struct
.
fdstat
.
html
#
structfield
.
fs_rights_base
)
and
/
/
/
[
fdstat
.
fs_rights_inheriting
]
(
struct
.
fdstat
.
html
#
structfield
.
fs_rights_inheriting
)
.
const
RIGHTS
=
0x0002
;
}
}
pub
type
filedelta
=
i64
;
pub
type
filesize
=
u64
;
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
filetype
{
UNKNOWN
=
0
BLOCK_DEVICE
=
16
CHARACTER_DEVICE
=
17
DIRECTORY
=
32
PROCESS
=
80
REGULAR_FILE
=
96
SHARED_MEMORY
=
112
SOCKET_DGRAM
=
128
SOCKET_STREAM
=
130
SYMBOLIC_LINK
=
144
}
bitflags
!
{
/
/
/
Which
file
attributes
to
adjust
.
#
[
repr
(
C
)
]
pub
struct
fsflags
:
u16
{
/
/
/
Adjust
the
last
data
access
timestamp
to
the
value
/
/
/
stored
in
[
filestat
.
st_atim
]
(
struct
.
filestat
.
html
#
structfield
.
st_atim
)
.
const
ATIM
=
0x0001
;
/
/
/
Adjust
the
last
data
access
timestamp
to
the
time
/
/
/
of
clock
[
REALTIME
]
(
enum
.
clockid
.
html
#
variant
.
REALTIME
)
.
const
ATIM_NOW
=
0x0002
;
/
/
/
Adjust
the
last
data
modification
timestamp
to
the
/
/
/
value
stored
in
[
filestat
.
st_mtim
]
(
struct
.
filestat
.
html
#
structfield
.
st_mtim
)
.
const
MTIM
=
0x0004
;
/
/
/
Adjust
the
last
data
modification
timestamp
to
the
/
/
/
time
of
clock
[
REALTIME
]
(
enum
.
clockid
.
html
#
variant
.
REALTIME
)
.
const
MTIM_NOW
=
0x0008
;
/
/
/
Truncate
or
extend
the
file
to
the
size
stored
in
/
/
/
[
filestat
.
st_size
]
(
struct
.
filestat
.
html
#
structfield
.
st_size
)
.
const
SIZE
=
0x0010
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
inode
(
pub
u64
)
;
pub
type
linkcount
=
u32
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
lock
(
pub
u32
)
;
pub
const
LOCK_UNLOCKED
:
lock
=
lock
(
0x00000000
)
;
pub
const
LOCK_WRLOCKED
:
lock
=
lock
(
0x40000000
)
;
pub
const
LOCK_KERNEL_MANAGED
:
lock
=
lock
(
0x80000000
)
;
pub
const
LOCK_BOGUS
:
lock
=
lock
(
0x80000000
)
;
bitflags
!
{
/
/
/
Flags
determining
the
method
of
how
paths
are
resolved
.
#
[
repr
(
C
)
]
pub
struct
lookupflags
:
u32
{
/
/
/
As
long
as
the
resolved
path
corresponds
to
a
symbolic
/
/
/
link
it
is
expanded
.
const
SYMLINK_FOLLOW
=
0x00000001
;
}
}
bitflags
!
{
/
/
/
Memory
mapping
flags
.
#
[
repr
(
C
)
]
pub
struct
mflags
:
u8
{
/
/
/
Instead
of
mapping
the
contents
of
the
file
provided
/
/
/
create
a
mapping
to
anonymous
memory
.
The
file
/
/
/
descriptor
argument
must
be
set
to
[
MAP_ANON_FD
]
(
constant
.
MAP_ANON_FD
.
html
)
/
/
/
and
the
offset
must
be
set
to
zero
.
const
ANON
=
0x01
;
/
/
/
Require
that
the
mapping
is
performed
at
the
base
/
/
/
address
provided
.
const
FIXED
=
0x02
;
/
/
/
Changes
are
private
.
const
PRIVATE
=
0x04
;
/
/
/
Changes
are
shared
.
const
SHARED
=
0x08
;
}
}
bitflags
!
{
/
/
/
Memory
page
protection
options
.
/
/
/
/
/
/
This
implementation
enforces
the
W
^
X
property
:
Pages
cannot
be
/
/
/
mapped
for
execution
while
also
mapped
for
writing
.
#
[
repr
(
C
)
]
pub
struct
mprot
:
u8
{
/
/
/
Page
can
be
executed
.
const
EXEC
=
0x01
;
/
/
/
Page
can
be
written
.
const
WRITE
=
0x02
;
/
/
/
Page
can
be
read
.
const
READ
=
0x04
;
}
}
bitflags
!
{
/
/
/
Methods
of
synchronizing
memory
with
physical
storage
.
#
[
repr
(
C
)
]
pub
struct
msflags
:
u8
{
/
/
/
Perform
asynchronous
writes
.
const
ASYNC
=
0x01
;
/
/
/
Invalidate
cached
data
.
const
INVALIDATE
=
0x02
;
/
/
/
Perform
synchronous
writes
.
const
SYNC
=
0x04
;
}
}
pub
type
nthreads
=
u32
;
bitflags
!
{
/
/
/
Open
flags
used
by
[
file_open
(
)
]
(
fn
.
file_open
.
html
)
.
#
[
repr
(
C
)
]
pub
struct
oflags
:
u16
{
/
/
/
Create
file
if
it
does
not
exist
.
const
CREAT
=
0x0001
;
/
/
/
Fail
if
not
a
directory
.
const
DIRECTORY
=
0x0002
;
/
/
/
Fail
if
file
already
exists
.
const
EXCL
=
0x0004
;
/
/
/
Truncate
file
to
size
0
.
const
TRUNC
=
0x0008
;
}
}
bitflags
!
{
/
/
/
Flags
provided
to
[
sock_recv
(
)
]
(
fn
.
sock_recv
.
html
)
.
#
[
repr
(
C
)
]
pub
struct
riflags
:
u16
{
/
/
/
Returns
the
message
without
removing
it
from
the
/
/
/
socket
'
s
receive
queue
.
const
PEEK
=
0x0004
;
/
/
/
On
byte
-
stream
sockets
block
until
the
full
amount
/
/
/
of
data
can
be
returned
.
const
WAITALL
=
0x0010
;
}
}
bitflags
!
{
/
/
/
File
descriptor
rights
determining
which
actions
may
be
/
/
/
performed
.
#
[
repr
(
C
)
]
pub
struct
rights
:
u64
{
/
/
/
The
right
to
invoke
[
fd_datasync
(
)
]
(
fn
.
fd_datasync
.
html
)
.
/
/
/
/
/
/
If
[
FILE_OPEN
]
(
struct
.
rights
.
html
#
associatedconstant
.
FILE_OPEN
)
is
set
includes
the
right
to
/
/
/
invoke
[
file_open
(
)
]
(
fn
.
file_open
.
html
)
with
[
DSYNC
]
(
struct
.
fdflags
.
html
#
associatedconstant
.
DSYNC
)
.
const
FD_DATASYNC
=
0x0000000000000001
;
/
/
/
The
right
to
invoke
[
fd_read
(
)
]
(
fn
.
fd_read
.
html
)
and
[
sock_recv
(
)
]
(
fn
.
sock_recv
.
html
)
.
/
/
/
/
/
/
If
[
MEM_MAP
]
(
struct
.
rights
.
html
#
associatedconstant
.
MEM_MAP
)
is
set
includes
the
right
to
/
/
/
invoke
[
mem_map
(
)
]
(
fn
.
mem_map
.
html
)
with
memory
protection
option
/
/
/
[
READ
]
(
struct
.
mprot
.
html
#
associatedconstant
.
READ
)
.
/
/
/
/
/
/
If
[
FD_SEEK
]
(
struct
.
rights
.
html
#
associatedconstant
.
FD_SEEK
)
is
set
includes
the
right
to
invoke
/
/
/
[
fd_pread
(
)
]
(
fn
.
fd_pread
.
html
)
.
const
FD_READ
=
0x0000000000000002
;
/
/
/
The
right
to
invoke
[
fd_seek
(
)
]
(
fn
.
fd_seek
.
html
)
.
This
flag
implies
/
/
/
[
FD_TELL
]
(
struct
.
rights
.
html
#
associatedconstant
.
FD_TELL
)
.
const
FD_SEEK
=
0x0000000000000004
;
/
/
/
The
right
to
invoke
[
fd_stat_put
(
)
]
(
fn
.
fd_stat_put
.
html
)
with
/
/
/
[
FLAGS
]
(
struct
.
fdsflags
.
html
#
associatedconstant
.
FLAGS
)
.
const
FD_STAT_PUT_FLAGS
=
0x0000000000000008
;
/
/
/
The
right
to
invoke
[
fd_sync
(
)
]
(
fn
.
fd_sync
.
html
)
.
/
/
/
/
/
/
If
[
FILE_OPEN
]
(
struct
.
rights
.
html
#
associatedconstant
.
FILE_OPEN
)
is
set
includes
the
right
to
/
/
/
invoke
[
file_open
(
)
]
(
fn
.
file_open
.
html
)
with
[
RSYNC
]
(
struct
.
fdflags
.
html
#
associatedconstant
.
RSYNC
)
and
/
/
/
[
DSYNC
]
(
struct
.
fdflags
.
html
#
associatedconstant
.
DSYNC
)
.
const
FD_SYNC
=
0x0000000000000010
;
/
/
/
The
right
to
invoke
[
fd_seek
(
)
]
(
fn
.
fd_seek
.
html
)
in
such
a
way
that
the
/
/
/
file
offset
remains
unaltered
(
i
.
e
.
[
CUR
]
(
enum
.
whence
.
html
#
variant
.
CUR
)
with
/
/
/
offset
zero
)
.
const
FD_TELL
=
0x0000000000000020
;
/
/
/
The
right
to
invoke
[
fd_write
(
)
]
(
fn
.
fd_write
.
html
)
and
[
sock_send
(
)
]
(
fn
.
sock_send
.
html
)
.
/
/
/
/
/
/
If
[
MEM_MAP
]
(
struct
.
rights
.
html
#
associatedconstant
.
MEM_MAP
)
is
set
includes
the
right
to
/
/
/
invoke
[
mem_map
(
)
]
(
fn
.
mem_map
.
html
)
with
memory
protection
option
/
/
/
[
WRITE
]
(
struct
.
mprot
.
html
#
associatedconstant
.
WRITE
)
.
/
/
/
/
/
/
If
[
FD_SEEK
]
(
struct
.
rights
.
html
#
associatedconstant
.
FD_SEEK
)
is
set
includes
the
right
to
/
/
/
invoke
[
fd_pwrite
(
)
]
(
fn
.
fd_pwrite
.
html
)
.
const
FD_WRITE
=
0x0000000000000040
;
/
/
/
The
right
to
invoke
[
file_advise
(
)
]
(
fn
.
file_advise
.
html
)
.
const
FILE_ADVISE
=
0x0000000000000080
;
/
/
/
The
right
to
invoke
[
file_allocate
(
)
]
(
fn
.
file_allocate
.
html
)
.
const
FILE_ALLOCATE
=
0x0000000000000100
;
/
/
/
The
right
to
invoke
[
file_create
(
)
]
(
fn
.
file_create
.
html
)
with
/
/
/
[
DIRECTORY
]
(
enum
.
filetype
.
html
#
variant
.
DIRECTORY
)
.
const
FILE_CREATE_DIRECTORY
=
0x0000000000000200
;
/
/
/
If
[
FILE_OPEN
]
(
struct
.
rights
.
html
#
associatedconstant
.
FILE_OPEN
)
is
set
the
right
to
invoke
/
/
/
[
file_open
(
)
]
(
fn
.
file_open
.
html
)
with
[
CREAT
]
(
struct
.
oflags
.
html
#
associatedconstant
.
CREAT
)
.
const
FILE_CREATE_FILE
=
0x0000000000000400
;
/
/
/
The
right
to
invoke
[
file_link
(
)
]
(
fn
.
file_link
.
html
)
with
the
file
/
/
/
descriptor
as
the
source
directory
.
const
FILE_LINK_SOURCE
=
0x0000000000001000
;
/
/
/
The
right
to
invoke
[
file_link
(
)
]
(
fn
.
file_link
.
html
)
with
the
file
/
/
/
descriptor
as
the
target
directory
.
const
FILE_LINK_TARGET
=
0x0000000000002000
;
/
/
/
The
right
to
invoke
[
file_open
(
)
]
(
fn
.
file_open
.
html
)
.
const
FILE_OPEN
=
0x0000000000004000
;
/
/
/
The
right
to
invoke
[
file_readdir
(
)
]
(
fn
.
file_readdir
.
html
)
.
const
FILE_READDIR
=
0x0000000000008000
;
/
/
/
The
right
to
invoke
[
file_readlink
(
)
]
(
fn
.
file_readlink
.
html
)
.
const
FILE_READLINK
=
0x0000000000010000
;
/
/
/
The
right
to
invoke
[
file_rename
(
)
]
(
fn
.
file_rename
.
html
)
with
the
file
/
/
/
descriptor
as
the
source
directory
.
const
FILE_RENAME_SOURCE
=
0x0000000000020000
;
/
/
/
The
right
to
invoke
[
file_rename
(
)
]
(
fn
.
file_rename
.
html
)
with
the
file
/
/
/
descriptor
as
the
target
directory
.
const
FILE_RENAME_TARGET
=
0x0000000000040000
;
/
/
/
The
right
to
invoke
[
file_stat_fget
(
)
]
(
fn
.
file_stat_fget
.
html
)
.
const
FILE_STAT_FGET
=
0x0000000000080000
;
/
/
/
The
right
to
invoke
[
file_stat_fput
(
)
]
(
fn
.
file_stat_fput
.
html
)
with
/
/
/
[
SIZE
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
SIZE
)
.
/
/
/
/
/
/
If
[
FILE_OPEN
]
(
struct
.
rights
.
html
#
associatedconstant
.
FILE_OPEN
)
is
set
includes
the
right
to
/
/
/
invoke
[
file_open
(
)
]
(
fn
.
file_open
.
html
)
with
[
TRUNC
]
(
struct
.
oflags
.
html
#
associatedconstant
.
TRUNC
)
.
const
FILE_STAT_FPUT_SIZE
=
0x0000000000100000
;
/
/
/
The
right
to
invoke
[
file_stat_fput
(
)
]
(
fn
.
file_stat_fput
.
html
)
with
/
/
/
[
ATIM
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
ATIM
)
[
ATIM_NOW
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
ATIM_NOW
)
[
MTIM
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
MTIM
)
/
/
/
and
[
MTIM_NOW
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
MTIM_NOW
)
.
const
FILE_STAT_FPUT_TIMES
=
0x0000000000200000
;
/
/
/
The
right
to
invoke
[
file_stat_get
(
)
]
(
fn
.
file_stat_get
.
html
)
.
const
FILE_STAT_GET
=
0x0000000000400000
;
/
/
/
The
right
to
invoke
[
file_stat_put
(
)
]
(
fn
.
file_stat_put
.
html
)
with
/
/
/
[
ATIM
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
ATIM
)
[
ATIM_NOW
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
ATIM_NOW
)
[
MTIM
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
MTIM
)
/
/
/
and
[
MTIM_NOW
]
(
struct
.
fsflags
.
html
#
associatedconstant
.
MTIM_NOW
)
.
const
FILE_STAT_PUT_TIMES
=
0x0000000000800000
;
/
/
/
The
right
to
invoke
[
file_symlink
(
)
]
(
fn
.
file_symlink
.
html
)
.
const
FILE_SYMLINK
=
0x0000000001000000
;
/
/
/
The
right
to
invoke
[
file_unlink
(
)
]
(
fn
.
file_unlink
.
html
)
.
const
FILE_UNLINK
=
0x0000000002000000
;
/
/
/
The
right
to
invoke
[
mem_map
(
)
]
(
fn
.
mem_map
.
html
)
with
[
mprot
]
(
struct
.
mprot
.
html
)
set
to
/
/
/
zero
.
const
MEM_MAP
=
0x0000000004000000
;
/
/
/
If
[
MEM_MAP
]
(
struct
.
rights
.
html
#
associatedconstant
.
MEM_MAP
)
is
set
the
right
to
invoke
/
/
/
[
mem_map
(
)
]
(
fn
.
mem_map
.
html
)
with
[
EXEC
]
(
struct
.
mprot
.
html
#
associatedconstant
.
EXEC
)
.
const
MEM_MAP_EXEC
=
0x0000000008000000
;
/
/
/
If
[
FD_READ
]
(
struct
.
rights
.
html
#
associatedconstant
.
FD_READ
)
is
set
includes
the
right
to
/
/
/
invoke
[
poll
(
)
]
(
fn
.
poll
.
html
)
to
subscribe
to
[
FD_READ
]
(
enum
.
eventtype
.
html
#
variant
.
FD_READ
)
.
/
/
/
/
/
/
If
[
FD_WRITE
]
(
struct
.
rights
.
html
#
associatedconstant
.
FD_WRITE
)
is
set
includes
the
right
to
/
/
/
invoke
[
poll
(
)
]
(
fn
.
poll
.
html
)
to
subscribe
to
[
FD_WRITE
]
(
enum
.
eventtype
.
html
#
variant
.
FD_WRITE
)
.
const
POLL_FD_READWRITE
=
0x0000000010000000
;
/
/
/
The
right
to
invoke
[
poll
(
)
]
(
fn
.
poll
.
html
)
to
subscribe
to
/
/
/
[
PROC_TERMINATE
]
(
enum
.
eventtype
.
html
#
variant
.
PROC_TERMINATE
)
.
const
POLL_PROC_TERMINATE
=
0x0000000040000000
;
/
/
/
The
right
to
invoke
[
proc_exec
(
)
]
(
fn
.
proc_exec
.
html
)
.
const
PROC_EXEC
=
0x0000000100000000
;
/
/
/
The
right
to
invoke
[
sock_shutdown
(
)
]
(
fn
.
sock_shutdown
.
html
)
.
const
SOCK_SHUTDOWN
=
0x0000008000000000
;
}
}
bitflags
!
{
/
/
/
Flags
returned
by
[
sock_recv
(
)
]
(
fn
.
sock_recv
.
html
)
.
#
[
repr
(
C
)
]
pub
struct
roflags
:
u16
{
/
/
/
Returned
by
[
sock_recv
(
)
]
(
fn
.
sock_recv
.
html
)
:
List
of
file
descriptors
/
/
/
has
been
truncated
.
const
FDS_TRUNCATED
=
0x0001
;
/
/
/
Returned
by
[
sock_recv
(
)
]
(
fn
.
sock_recv
.
html
)
:
Message
data
has
been
/
/
/
truncated
.
const
DATA_TRUNCATED
=
0x0008
;
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
scope
{
PRIVATE
=
4
SHARED
=
8
}
bitflags
!
{
/
/
/
Which
channels
on
a
socket
need
to
be
shut
down
.
#
[
repr
(
C
)
]
pub
struct
sdflags
:
u8
{
/
/
/
Disables
further
receive
operations
.
const
RD
=
0x01
;
/
/
/
Disables
further
send
operations
.
const
WR
=
0x02
;
}
}
bitflags
!
{
/
/
/
Flags
provided
to
[
sock_send
(
)
]
(
fn
.
sock_send
.
html
)
.
As
there
are
currently
no
flags
/
/
/
defined
it
must
be
set
to
zero
.
#
[
repr
(
C
)
]
pub
struct
siflags
:
u16
{
const
DEFAULT
=
0
;
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
signal
{
ABRT
=
1
ALRM
=
2
BUS
=
3
CHLD
=
4
CONT
=
5
FPE
=
6
HUP
=
7
ILL
=
8
INT
=
9
KILL
=
10
PIPE
=
11
QUIT
=
12
SEGV
=
13
STOP
=
14
SYS
=
15
TERM
=
16
TRAP
=
17
TSTP
=
18
TTIN
=
19
TTOU
=
20
URG
=
21
USR1
=
22
USR2
=
23
VTALRM
=
24
XCPU
=
25
XFSZ
=
26
}
bitflags
!
{
/
/
/
Flags
determining
how
the
timestamp
provided
in
/
/
/
[
subscription
.
union
.
clock
.
timeout
]
(
struct
.
subscription_clock
.
html
#
structfield
.
timeout
)
should
be
interpreted
.
#
[
repr
(
C
)
]
pub
struct
subclockflags
:
u16
{
/
/
/
If
set
treat
the
timestamp
provided
in
/
/
/
[
subscription
.
union
.
clock
.
timeout
]
(
struct
.
subscription_clock
.
html
#
structfield
.
timeout
)
as
an
absolute
timestamp
/
/
/
of
clock
[
subscription
.
union
.
clock
.
clock_id
]
(
struct
.
subscription_clock
.
html
#
structfield
.
clock_id
)
.
/
/
/
/
/
/
If
clear
treat
the
timestamp
provided
in
/
/
/
[
subscription
.
union
.
clock
.
timeout
]
(
struct
.
subscription_clock
.
html
#
structfield
.
timeout
)
relative
to
the
current
/
/
/
time
value
of
clock
[
subscription
.
union
.
clock
.
clock_id
]
(
struct
.
subscription_clock
.
html
#
structfield
.
clock_id
)
.
const
ABSTIME
=
0x0001
;
}
}
bitflags
!
{
/
/
/
Flags
influencing
the
method
of
polling
for
read
or
writing
on
/
/
/
a
file
descriptor
.
#
[
repr
(
C
)
]
pub
struct
subrwflags
:
u16
{
/
/
/
Deprecated
.
Must
be
set
by
callers
and
ignored
by
/
/
/
implementations
.
const
POLL
=
0x0001
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
pub
struct
tid
(
pub
u32
)
;
pub
type
timestamp
=
u64
;
bitflags
!
{
/
/
/
Specifies
whether
files
are
unlinked
or
directories
are
/
/
/
removed
.
#
[
repr
(
C
)
]
pub
struct
ulflags
:
u8
{
/
/
/
If
set
removes
a
directory
.
Otherwise
unlinks
any
/
/
/
non
-
directory
file
.
const
REMOVEDIR
=
0x01
;
}
}
pub
type
userdata
=
u64
;
#
[
repr
(
u8
)
]
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
non_exhaustive
]
pub
enum
whence
{
CUR
=
1
END
=
2
SET
=
3
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
auxv
{
pub
a_type
:
auxtype
pub
union
:
auxv_union
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
union
auxv_union
{
pub
a_val
:
usize
pub
a_ptr
:
*
mut
(
)
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
auxv_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
auxv
>
(
)
8
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
auxv
>
(
)
4
)
;
let
mut
obj
=
auxv
{
a_type
:
auxtype
:
:
ARGDATA
union
:
auxv_union
{
a_val
:
0
}
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
a_type
as
*
const
_
as
usize
-
base
0
)
;
obj
.
union
.
a_val
=
0
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
a_val
as
*
const
_
as
usize
-
base
4
)
;
}
obj
.
union
.
a_ptr
=
0
as
*
mut
(
)
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
a_ptr
as
*
const
_
as
usize
-
base
4
)
;
}
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
auxv_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
auxv
>
(
)
16
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
auxv
>
(
)
8
)
;
let
mut
obj
=
auxv
{
a_type
:
auxtype
:
:
ARGDATA
union
:
auxv_union
{
a_val
:
0
}
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
a_type
as
*
const
_
as
usize
-
base
0
)
;
obj
.
union
.
a_val
=
0
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
a_val
as
*
const
_
as
usize
-
base
8
)
;
}
obj
.
union
.
a_ptr
=
0
as
*
mut
(
)
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
a_ptr
as
*
const
_
as
usize
-
base
8
)
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
ciovec
{
pub
buf
:
(
*
const
(
)
usize
)
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
ciovec_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
ciovec
>
(
)
8
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
ciovec
>
(
)
4
)
;
let
obj
=
ciovec
{
buf
:
(
0
as
*
const
_
0
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
buf
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
buf
.
1
as
*
const
_
as
usize
-
base
4
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
ciovec_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
ciovec
>
(
)
16
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
ciovec
>
(
)
8
)
;
let
obj
=
ciovec
{
buf
:
(
0
as
*
const
_
0
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
buf
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
buf
.
1
as
*
const
_
as
usize
-
base
8
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
dirent
{
pub
d_next
:
dircookie
pub
d_ino
:
inode
pub
d_namlen
:
u32
pub
d_type
:
filetype
}
#
[
test
]
fn
dirent_layout_test
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
dirent
>
(
)
24
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
dirent
>
(
)
8
)
;
let
obj
=
dirent
{
d_next
:
dircookie
(
0
)
d_ino
:
inode
(
0
)
d_namlen
:
0
d_type
:
filetype
:
:
UNKNOWN
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
d_next
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
d_ino
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
d_namlen
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
d_type
as
*
const
_
as
usize
-
base
20
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
event
{
pub
userdata
:
userdata
pub
error
:
errno
pub
r
#
type
:
eventtype
pub
union
:
event_union
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
union
event_union
{
pub
fd_readwrite
:
event_fd_readwrite
pub
proc_terminate
:
event_proc_terminate
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
event_fd_readwrite
{
pub
nbytes
:
filesize
pub
unused
:
[
u8
;
4
]
pub
flags
:
eventrwflags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
event_proc_terminate
{
pub
unused
:
[
u8
;
4
]
pub
signal
:
signal
pub
exitcode
:
exitcode
}
#
[
test
]
fn
event_layout_test
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
event
>
(
)
32
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
event
>
(
)
8
)
;
let
mut
obj
=
event
{
userdata
:
0
error
:
errno
:
:
SUCCESS
r
#
type
:
eventtype
:
:
CLOCK
union
:
event_union
{
fd_readwrite
:
event_fd_readwrite
{
nbytes
:
0
unused
:
[
0
;
4
]
flags
:
eventrwflags
:
:
HANGUP
}
}
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
userdata
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
error
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
r
#
type
as
*
const
_
as
usize
-
base
10
)
;
obj
.
union
.
fd_readwrite
=
event_fd_readwrite
{
nbytes
:
0
unused
:
[
0
;
4
]
flags
:
eventrwflags
:
:
HANGUP
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
nbytes
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
unused
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
flags
as
*
const
_
as
usize
-
base
28
)
;
}
obj
.
union
.
proc_terminate
=
event_proc_terminate
{
unused
:
[
0
;
4
]
signal
:
signal
:
:
ABRT
exitcode
:
0
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
proc_terminate
.
unused
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
proc_terminate
.
signal
as
*
const
_
as
usize
-
base
20
)
;
assert_eq
!
(
&
obj
.
union
.
proc_terminate
.
exitcode
as
*
const
_
as
usize
-
base
24
)
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
fdstat
{
pub
fs_filetype
:
filetype
pub
fs_flags
:
fdflags
pub
fs_rights_base
:
rights
pub
fs_rights_inheriting
:
rights
}
#
[
test
]
fn
fdstat_layout_test
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
fdstat
>
(
)
24
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
fdstat
>
(
)
8
)
;
let
obj
=
fdstat
{
fs_filetype
:
filetype
:
:
UNKNOWN
fs_flags
:
fdflags
:
:
APPEND
fs_rights_base
:
rights
:
:
FD_DATASYNC
fs_rights_inheriting
:
rights
:
:
FD_DATASYNC
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
fs_filetype
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
fs_flags
as
*
const
_
as
usize
-
base
2
)
;
assert_eq
!
(
&
obj
.
fs_rights_base
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
fs_rights_inheriting
as
*
const
_
as
usize
-
base
16
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
filestat
{
pub
st_dev
:
device
pub
st_ino
:
inode
pub
st_filetype
:
filetype
pub
st_nlink
:
linkcount
pub
st_size
:
filesize
pub
st_atim
:
timestamp
pub
st_mtim
:
timestamp
pub
st_ctim
:
timestamp
}
#
[
test
]
fn
filestat_layout_test
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
filestat
>
(
)
56
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
filestat
>
(
)
8
)
;
let
obj
=
filestat
{
st_dev
:
device
(
0
)
st_ino
:
inode
(
0
)
st_filetype
:
filetype
:
:
UNKNOWN
st_nlink
:
0
st_size
:
0
st_atim
:
0
st_mtim
:
0
st_ctim
:
0
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
st_dev
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
st_ino
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
st_filetype
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
st_nlink
as
*
const
_
as
usize
-
base
20
)
;
assert_eq
!
(
&
obj
.
st_size
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
st_atim
as
*
const
_
as
usize
-
base
32
)
;
assert_eq
!
(
&
obj
.
st_mtim
as
*
const
_
as
usize
-
base
40
)
;
assert_eq
!
(
&
obj
.
st_ctim
as
*
const
_
as
usize
-
base
48
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
iovec
{
pub
buf
:
(
*
mut
(
)
usize
)
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
iovec_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
iovec
>
(
)
8
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
iovec
>
(
)
4
)
;
let
obj
=
iovec
{
buf
:
(
0
as
*
mut
_
0
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
buf
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
buf
.
1
as
*
const
_
as
usize
-
base
4
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
iovec_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
iovec
>
(
)
16
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
iovec
>
(
)
8
)
;
let
obj
=
iovec
{
buf
:
(
0
as
*
mut
_
0
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
buf
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
buf
.
1
as
*
const
_
as
usize
-
base
8
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
lookup
{
pub
fd
:
fd
pub
flags
:
lookupflags
}
#
[
test
]
fn
lookup_layout_test
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
lookup
>
(
)
8
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
lookup
>
(
)
4
)
;
let
obj
=
lookup
{
fd
:
fd
(
0
)
flags
:
lookupflags
:
:
SYMLINK_FOLLOW
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
fd
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
flags
as
*
const
_
as
usize
-
base
4
)
;
}
pub
type
processentry
=
unsafe
extern
"
C
"
fn
(
auxv
:
*
const
auxv
)
-
>
(
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
recv_in
{
pub
ri_data
:
(
*
const
iovec
usize
)
pub
ri_fds
:
(
*
mut
fd
usize
)
pub
ri_flags
:
riflags
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
recv_in_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
recv_in
>
(
)
20
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
recv_in
>
(
)
4
)
;
let
obj
=
recv_in
{
ri_data
:
(
0
as
*
const
_
0
)
ri_fds
:
(
0
as
*
mut
_
0
)
ri_flags
:
riflags
:
:
PEEK
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
ri_data
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
ri_data
.
1
as
*
const
_
as
usize
-
base
4
)
;
assert_eq
!
(
&
obj
.
ri_fds
.
0
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
ri_fds
.
1
as
*
const
_
as
usize
-
base
12
)
;
assert_eq
!
(
&
obj
.
ri_flags
as
*
const
_
as
usize
-
base
16
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
recv_in_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
recv_in
>
(
)
40
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
recv_in
>
(
)
8
)
;
let
obj
=
recv_in
{
ri_data
:
(
0
as
*
const
_
0
)
ri_fds
:
(
0
as
*
mut
_
0
)
ri_flags
:
riflags
:
:
PEEK
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
ri_data
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
ri_data
.
1
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
ri_fds
.
0
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
ri_fds
.
1
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
ri_flags
as
*
const
_
as
usize
-
base
32
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
recv_out
{
pub
ro_datalen
:
usize
pub
ro_fdslen
:
usize
pub
ro_unused
:
[
u8
;
40
]
pub
ro_flags
:
roflags
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
recv_out_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
recv_out
>
(
)
52
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
recv_out
>
(
)
4
)
;
let
obj
=
recv_out
{
ro_datalen
:
0
ro_fdslen
:
0
ro_unused
:
[
0
;
40
]
ro_flags
:
roflags
:
:
FDS_TRUNCATED
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
ro_datalen
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
ro_fdslen
as
*
const
_
as
usize
-
base
4
)
;
assert_eq
!
(
&
obj
.
ro_unused
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
ro_flags
as
*
const
_
as
usize
-
base
48
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
recv_out_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
recv_out
>
(
)
64
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
recv_out
>
(
)
8
)
;
let
obj
=
recv_out
{
ro_datalen
:
0
ro_fdslen
:
0
ro_unused
:
[
0
;
40
]
ro_flags
:
roflags
:
:
FDS_TRUNCATED
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
ro_datalen
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
ro_fdslen
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
ro_unused
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
ro_flags
as
*
const
_
as
usize
-
base
56
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
send_in
{
pub
si_data
:
(
*
const
ciovec
usize
)
pub
si_fds
:
(
*
const
fd
usize
)
pub
si_flags
:
siflags
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
send_in_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
send_in
>
(
)
20
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
send_in
>
(
)
4
)
;
let
obj
=
send_in
{
si_data
:
(
0
as
*
const
_
0
)
si_fds
:
(
0
as
*
const
_
0
)
si_flags
:
siflags
:
:
DEFAULT
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
si_data
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
si_data
.
1
as
*
const
_
as
usize
-
base
4
)
;
assert_eq
!
(
&
obj
.
si_fds
.
0
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
si_fds
.
1
as
*
const
_
as
usize
-
base
12
)
;
assert_eq
!
(
&
obj
.
si_flags
as
*
const
_
as
usize
-
base
16
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
send_in_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
send_in
>
(
)
40
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
send_in
>
(
)
8
)
;
let
obj
=
send_in
{
si_data
:
(
0
as
*
const
_
0
)
si_fds
:
(
0
as
*
const
_
0
)
si_flags
:
siflags
:
:
DEFAULT
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
si_data
.
0
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
si_data
.
1
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
si_fds
.
0
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
si_fds
.
1
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
si_flags
as
*
const
_
as
usize
-
base
32
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
send_out
{
pub
so_datalen
:
usize
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
send_out_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
send_out
>
(
)
4
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
send_out
>
(
)
4
)
;
let
obj
=
send_out
{
so_datalen
:
0
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
so_datalen
as
*
const
_
as
usize
-
base
0
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
send_out_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
send_out
>
(
)
8
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
send_out
>
(
)
8
)
;
let
obj
=
send_out
{
so_datalen
:
0
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
so_datalen
as
*
const
_
as
usize
-
base
0
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
subscription
{
pub
userdata
:
userdata
pub
unused
:
u16
pub
r
#
type
:
eventtype
pub
union
:
subscription_union
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
union
subscription_union
{
pub
clock
:
subscription_clock
pub
condvar
:
subscription_condvar
pub
fd_readwrite
:
subscription_fd_readwrite
pub
lock
:
subscription_lock
pub
proc_terminate
:
subscription_proc_terminate
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
subscription_clock
{
pub
identifier
:
userdata
pub
clock_id
:
clockid
pub
timeout
:
timestamp
pub
precision
:
timestamp
pub
flags
:
subclockflags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
subscription_condvar
{
pub
condvar
:
*
mut
condvar
pub
lock
:
*
mut
lock
pub
condvar_scope
:
scope
pub
lock_scope
:
scope
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
subscription_fd_readwrite
{
pub
fd
:
fd
pub
flags
:
subrwflags
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
subscription_lock
{
pub
lock
:
*
mut
lock
pub
lock_scope
:
scope
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
subscription_proc_terminate
{
pub
fd
:
fd
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
subscription_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
subscription
>
(
)
56
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
subscription
>
(
)
8
)
;
let
mut
obj
=
subscription
{
userdata
:
0
unused
:
0
r
#
type
:
eventtype
:
:
CLOCK
union
:
subscription_union
{
clock
:
subscription_clock
{
identifier
:
0
clock_id
:
clockid
:
:
MONOTONIC
timeout
:
0
precision
:
0
flags
:
subclockflags
:
:
ABSTIME
}
}
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
userdata
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
unused
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
r
#
type
as
*
const
_
as
usize
-
base
10
)
;
obj
.
union
.
clock
=
subscription_clock
{
identifier
:
0
clock_id
:
clockid
:
:
MONOTONIC
timeout
:
0
precision
:
0
flags
:
subclockflags
:
:
ABSTIME
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
clock
.
identifier
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
clock_id
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
timeout
as
*
const
_
as
usize
-
base
32
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
precision
as
*
const
_
as
usize
-
base
40
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
flags
as
*
const
_
as
usize
-
base
48
)
;
}
obj
.
union
.
condvar
=
subscription_condvar
{
condvar
:
0
as
*
mut
condvar
lock
:
0
as
*
mut
lock
condvar_scope
:
scope
:
:
PRIVATE
lock_scope
:
scope
:
:
PRIVATE
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
condvar
.
condvar
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
condvar
.
lock
as
*
const
_
as
usize
-
base
20
)
;
assert_eq
!
(
&
obj
.
union
.
condvar
.
condvar_scope
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
union
.
condvar
.
lock_scope
as
*
const
_
as
usize
-
base
25
)
;
}
obj
.
union
.
fd_readwrite
=
subscription_fd_readwrite
{
fd
:
fd
(
0
)
flags
:
subrwflags
:
:
POLL
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
fd
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
flags
as
*
const
_
as
usize
-
base
20
)
;
}
obj
.
union
.
lock
=
subscription_lock
{
lock
:
0
as
*
mut
lock
lock_scope
:
scope
:
:
PRIVATE
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
lock
.
lock
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
lock
.
lock_scope
as
*
const
_
as
usize
-
base
20
)
;
}
obj
.
union
.
proc_terminate
=
subscription_proc_terminate
{
fd
:
fd
(
0
)
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
proc_terminate
.
fd
as
*
const
_
as
usize
-
base
16
)
;
}
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
subscription_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
subscription
>
(
)
56
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
subscription
>
(
)
8
)
;
let
mut
obj
=
subscription
{
userdata
:
0
unused
:
0
r
#
type
:
eventtype
:
:
CLOCK
union
:
subscription_union
{
clock
:
subscription_clock
{
identifier
:
0
clock_id
:
clockid
:
:
MONOTONIC
timeout
:
0
precision
:
0
flags
:
subclockflags
:
:
ABSTIME
}
}
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
userdata
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
unused
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
r
#
type
as
*
const
_
as
usize
-
base
10
)
;
obj
.
union
.
clock
=
subscription_clock
{
identifier
:
0
clock_id
:
clockid
:
:
MONOTONIC
timeout
:
0
precision
:
0
flags
:
subclockflags
:
:
ABSTIME
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
clock
.
identifier
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
clock_id
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
timeout
as
*
const
_
as
usize
-
base
32
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
precision
as
*
const
_
as
usize
-
base
40
)
;
assert_eq
!
(
&
obj
.
union
.
clock
.
flags
as
*
const
_
as
usize
-
base
48
)
;
}
obj
.
union
.
condvar
=
subscription_condvar
{
condvar
:
0
as
*
mut
condvar
lock
:
0
as
*
mut
lock
condvar_scope
:
scope
:
:
PRIVATE
lock_scope
:
scope
:
:
PRIVATE
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
condvar
.
condvar
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
condvar
.
lock
as
*
const
_
as
usize
-
base
24
)
;
assert_eq
!
(
&
obj
.
union
.
condvar
.
condvar_scope
as
*
const
_
as
usize
-
base
32
)
;
assert_eq
!
(
&
obj
.
union
.
condvar
.
lock_scope
as
*
const
_
as
usize
-
base
33
)
;
}
obj
.
union
.
fd_readwrite
=
subscription_fd_readwrite
{
fd
:
fd
(
0
)
flags
:
subrwflags
:
:
POLL
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
fd
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
fd_readwrite
.
flags
as
*
const
_
as
usize
-
base
20
)
;
}
obj
.
union
.
lock
=
subscription_lock
{
lock
:
0
as
*
mut
lock
lock_scope
:
scope
:
:
PRIVATE
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
lock
.
lock
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
union
.
lock
.
lock_scope
as
*
const
_
as
usize
-
base
24
)
;
}
obj
.
union
.
proc_terminate
=
subscription_proc_terminate
{
fd
:
fd
(
0
)
}
;
unsafe
{
assert_eq
!
(
&
obj
.
union
.
proc_terminate
.
fd
as
*
const
_
as
usize
-
base
16
)
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
tcb
{
pub
parent
:
*
mut
(
)
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
tcb_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
tcb
>
(
)
4
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
tcb
>
(
)
4
)
;
let
obj
=
tcb
{
parent
:
0
as
*
mut
(
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
parent
as
*
const
_
as
usize
-
base
0
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
tcb_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
tcb
>
(
)
8
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
tcb
>
(
)
8
)
;
let
obj
=
tcb
{
parent
:
0
as
*
mut
(
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
parent
as
*
const
_
as
usize
-
base
0
)
;
}
pub
type
threadentry
=
unsafe
extern
"
C
"
fn
(
tid
:
tid
aux
:
*
mut
(
)
)
-
>
(
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
threadattr
{
pub
entry_point
:
threadentry
pub
stack
:
(
*
mut
(
)
usize
)
pub
argument
:
*
mut
(
)
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
threadattr_layout_test_32
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
threadattr
>
(
)
16
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
threadattr
>
(
)
4
)
;
let
obj
=
threadattr
{
entry_point
:
{
extern
"
C
"
fn
f
(
_
:
tid
_
:
*
mut
(
)
)
-
>
(
)
{
}
f
}
stack
:
(
0
as
*
mut
_
0
)
argument
:
0
as
*
mut
(
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
entry_point
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
stack
.
0
as
*
const
_
as
usize
-
base
4
)
;
assert_eq
!
(
&
obj
.
stack
.
1
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
argument
as
*
const
_
as
usize
-
base
12
)
;
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
threadattr_layout_test_64
(
)
{
assert_eq
!
(
core
:
:
mem
:
:
size_of
:
:
<
threadattr
>
(
)
32
)
;
assert_eq
!
(
core
:
:
mem
:
:
align_of
:
:
<
threadattr
>
(
)
8
)
;
let
obj
=
threadattr
{
entry_point
:
{
extern
"
C
"
fn
f
(
_
:
tid
_
:
*
mut
(
)
)
-
>
(
)
{
}
f
}
stack
:
(
0
as
*
mut
_
0
)
argument
:
0
as
*
mut
(
)
}
;
let
base
=
&
obj
as
*
const
_
as
usize
;
assert_eq
!
(
&
obj
.
entry_point
as
*
const
_
as
usize
-
base
0
)
;
assert_eq
!
(
&
obj
.
stack
.
0
as
*
const
_
as
usize
-
base
8
)
;
assert_eq
!
(
&
obj
.
stack
.
1
as
*
const
_
as
usize
-
base
16
)
;
assert_eq
!
(
&
obj
.
argument
as
*
const
_
as
usize
-
base
24
)
;
}
#
[
allow
(
improper_ctypes
)
]
extern
"
C
"
{
fn
cloudabi_sys_clock_res_get
(
_
:
clockid
_
:
*
mut
timestamp
)
-
>
errno
;
fn
cloudabi_sys_clock_time_get
(
_
:
clockid
_
:
timestamp
_
:
*
mut
timestamp
)
-
>
errno
;
fn
cloudabi_sys_condvar_signal
(
_
:
*
mut
condvar
_
:
scope
_
:
nthreads
)
-
>
errno
;
fn
cloudabi_sys_fd_close
(
_
:
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_create1
(
_
:
filetype
_
:
*
mut
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_create2
(
_
:
filetype
_
:
*
mut
fd
_
:
*
mut
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_datasync
(
_
:
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_dup
(
_
:
fd
_
:
*
mut
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_pread
(
_
:
fd
_
:
*
const
iovec
_
:
usize
_
:
filesize
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_fd_pwrite
(
_
:
fd
_
:
*
const
ciovec
_
:
usize
_
:
filesize
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_fd_read
(
_
:
fd
_
:
*
const
iovec
_
:
usize
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_fd_replace
(
_
:
fd
_
:
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_seek
(
_
:
fd
_
:
filedelta
_
:
whence
_
:
*
mut
filesize
)
-
>
errno
;
fn
cloudabi_sys_fd_stat_get
(
_
:
fd
_
:
*
mut
fdstat
)
-
>
errno
;
fn
cloudabi_sys_fd_stat_put
(
_
:
fd
_
:
*
const
fdstat
_
:
fdsflags
)
-
>
errno
;
fn
cloudabi_sys_fd_sync
(
_
:
fd
)
-
>
errno
;
fn
cloudabi_sys_fd_write
(
_
:
fd
_
:
*
const
ciovec
_
:
usize
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_file_advise
(
_
:
fd
_
:
filesize
_
:
filesize
_
:
advice
)
-
>
errno
;
fn
cloudabi_sys_file_allocate
(
_
:
fd
_
:
filesize
_
:
filesize
)
-
>
errno
;
fn
cloudabi_sys_file_create
(
_
:
fd
_
:
*
const
u8
_
:
usize
_
:
filetype
)
-
>
errno
;
fn
cloudabi_sys_file_link
(
_
:
lookup
_
:
*
const
u8
_
:
usize
_
:
fd
_
:
*
const
u8
_
:
usize
)
-
>
errno
;
fn
cloudabi_sys_file_open
(
_
:
lookup
_
:
*
const
u8
_
:
usize
_
:
oflags
_
:
*
const
fdstat
_
:
*
mut
fd
)
-
>
errno
;
fn
cloudabi_sys_file_readdir
(
_
:
fd
_
:
*
mut
(
)
_
:
usize
_
:
dircookie
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_file_readlink
(
_
:
fd
_
:
*
const
u8
_
:
usize
_
:
*
mut
u8
_
:
usize
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_file_rename
(
_
:
fd
_
:
*
const
u8
_
:
usize
_
:
fd
_
:
*
const
u8
_
:
usize
)
-
>
errno
;
fn
cloudabi_sys_file_stat_fget
(
_
:
fd
_
:
*
mut
filestat
)
-
>
errno
;
fn
cloudabi_sys_file_stat_fput
(
_
:
fd
_
:
*
const
filestat
_
:
fsflags
)
-
>
errno
;
fn
cloudabi_sys_file_stat_get
(
_
:
lookup
_
:
*
const
u8
_
:
usize
_
:
*
mut
filestat
)
-
>
errno
;
fn
cloudabi_sys_file_stat_put
(
_
:
lookup
_
:
*
const
u8
_
:
usize
_
:
*
const
filestat
_
:
fsflags
)
-
>
errno
;
fn
cloudabi_sys_file_symlink
(
_
:
*
const
u8
_
:
usize
_
:
fd
_
:
*
const
u8
_
:
usize
)
-
>
errno
;
fn
cloudabi_sys_file_unlink
(
_
:
fd
_
:
*
const
u8
_
:
usize
_
:
ulflags
)
-
>
errno
;
fn
cloudabi_sys_lock_unlock
(
_
:
*
mut
lock
_
:
scope
)
-
>
errno
;
fn
cloudabi_sys_mem_advise
(
_
:
*
mut
(
)
_
:
usize
_
:
advice
)
-
>
errno
;
fn
cloudabi_sys_mem_map
(
_
:
*
mut
(
)
_
:
usize
_
:
mprot
_
:
mflags
_
:
fd
_
:
filesize
_
:
*
mut
*
mut
(
)
)
-
>
errno
;
fn
cloudabi_sys_mem_protect
(
_
:
*
mut
(
)
_
:
usize
_
:
mprot
)
-
>
errno
;
fn
cloudabi_sys_mem_sync
(
_
:
*
mut
(
)
_
:
usize
_
:
msflags
)
-
>
errno
;
fn
cloudabi_sys_mem_unmap
(
_
:
*
mut
(
)
_
:
usize
)
-
>
errno
;
fn
cloudabi_sys_poll
(
_
:
*
const
subscription
_
:
*
mut
event
_
:
usize
_
:
*
mut
usize
)
-
>
errno
;
fn
cloudabi_sys_proc_exec
(
_
:
fd
_
:
*
const
(
)
_
:
usize
_
:
*
const
fd
_
:
usize
)
-
>
errno
;
fn
cloudabi_sys_proc_exit
(
_
:
exitcode
)
-
>
!
;
fn
cloudabi_sys_proc_fork
(
_
:
*
mut
fd
_
:
*
mut
tid
)
-
>
errno
;
fn
cloudabi_sys_proc_raise
(
_
:
signal
)
-
>
errno
;
fn
cloudabi_sys_random_get
(
_
:
*
mut
(
)
_
:
usize
)
-
>
errno
;
fn
cloudabi_sys_sock_recv
(
_
:
fd
_
:
*
const
recv_in
_
:
*
mut
recv_out
)
-
>
errno
;
fn
cloudabi_sys_sock_send
(
_
:
fd
_
:
*
const
send_in
_
:
*
mut
send_out
)
-
>
errno
;
fn
cloudabi_sys_sock_shutdown
(
_
:
fd
_
:
sdflags
)
-
>
errno
;
fn
cloudabi_sys_thread_create
(
_
:
*
mut
threadattr
_
:
*
mut
tid
)
-
>
errno
;
fn
cloudabi_sys_thread_exit
(
_
:
*
mut
lock
_
:
scope
)
-
>
!
;
fn
cloudabi_sys_thread_yield
(
)
-
>
errno
;
}
#
[
inline
]
pub
unsafe
fn
clock_res_get
(
clock_id_
:
clockid
resolution_
:
*
mut
timestamp
)
-
>
errno
{
cloudabi_sys_clock_res_get
(
clock_id_
resolution_
)
}
#
[
inline
]
pub
unsafe
fn
clock_time_get
(
clock_id_
:
clockid
precision_
:
timestamp
time_
:
*
mut
timestamp
)
-
>
errno
{
cloudabi_sys_clock_time_get
(
clock_id_
precision_
time_
)
}
#
[
inline
]
pub
unsafe
fn
condvar_signal
(
condvar_
:
*
mut
condvar
scope_
:
scope
nwaiters_
:
nthreads
)
-
>
errno
{
cloudabi_sys_condvar_signal
(
condvar_
scope_
nwaiters_
)
}
#
[
inline
]
pub
unsafe
fn
fd_close
(
fd_
:
fd
)
-
>
errno
{
cloudabi_sys_fd_close
(
fd_
)
}
#
[
inline
]
pub
unsafe
fn
fd_create1
(
type_
:
filetype
fd_
:
*
mut
fd
)
-
>
errno
{
cloudabi_sys_fd_create1
(
type_
fd_
)
}
#
[
inline
]
pub
unsafe
fn
fd_create2
(
type_
:
filetype
fd1_
:
*
mut
fd
fd2_
:
*
mut
fd
)
-
>
errno
{
cloudabi_sys_fd_create2
(
type_
fd1_
fd2_
)
}
#
[
inline
]
pub
unsafe
fn
fd_datasync
(
fd_
:
fd
)
-
>
errno
{
cloudabi_sys_fd_datasync
(
fd_
)
}
#
[
inline
]
pub
unsafe
fn
fd_dup
(
from_
:
fd
fd_
:
*
mut
fd
)
-
>
errno
{
cloudabi_sys_fd_dup
(
from_
fd_
)
}
#
[
inline
]
pub
unsafe
fn
fd_pread
(
fd_
:
fd
iovs_
:
&
[
iovec
]
offset_
:
filesize
nread_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_fd_pread
(
fd_
iovs_
.
as_ptr
(
)
iovs_
.
len
(
)
offset_
nread_
)
}
#
[
inline
]
pub
unsafe
fn
fd_pwrite
(
fd_
:
fd
iovs_
:
&
[
ciovec
]
offset_
:
filesize
nwritten_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_fd_pwrite
(
fd_
iovs_
.
as_ptr
(
)
iovs_
.
len
(
)
offset_
nwritten_
)
}
#
[
inline
]
pub
unsafe
fn
fd_read
(
fd_
:
fd
iovs_
:
&
[
iovec
]
nread_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_fd_read
(
fd_
iovs_
.
as_ptr
(
)
iovs_
.
len
(
)
nread_
)
}
#
[
inline
]
pub
unsafe
fn
fd_replace
(
from_
:
fd
to_
:
fd
)
-
>
errno
{
cloudabi_sys_fd_replace
(
from_
to_
)
}
#
[
inline
]
pub
unsafe
fn
fd_seek
(
fd_
:
fd
offset_
:
filedelta
whence_
:
whence
newoffset_
:
*
mut
filesize
)
-
>
errno
{
cloudabi_sys_fd_seek
(
fd_
offset_
whence_
newoffset_
)
}
#
[
inline
]
pub
unsafe
fn
fd_stat_get
(
fd_
:
fd
buf_
:
*
mut
fdstat
)
-
>
errno
{
cloudabi_sys_fd_stat_get
(
fd_
buf_
)
}
#
[
inline
]
pub
unsafe
fn
fd_stat_put
(
fd_
:
fd
buf_
:
*
const
fdstat
flags_
:
fdsflags
)
-
>
errno
{
cloudabi_sys_fd_stat_put
(
fd_
buf_
flags_
)
}
#
[
inline
]
pub
unsafe
fn
fd_sync
(
fd_
:
fd
)
-
>
errno
{
cloudabi_sys_fd_sync
(
fd_
)
}
#
[
inline
]
pub
unsafe
fn
fd_write
(
fd_
:
fd
iovs_
:
&
[
ciovec
]
nwritten_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_fd_write
(
fd_
iovs_
.
as_ptr
(
)
iovs_
.
len
(
)
nwritten_
)
}
#
[
inline
]
pub
unsafe
fn
file_advise
(
fd_
:
fd
offset_
:
filesize
len_
:
filesize
advice_
:
advice
)
-
>
errno
{
cloudabi_sys_file_advise
(
fd_
offset_
len_
advice_
)
}
#
[
inline
]
pub
unsafe
fn
file_allocate
(
fd_
:
fd
offset_
:
filesize
len_
:
filesize
)
-
>
errno
{
cloudabi_sys_file_allocate
(
fd_
offset_
len_
)
}
#
[
inline
]
pub
unsafe
fn
file_create
(
fd_
:
fd
path_
:
&
[
u8
]
type_
:
filetype
)
-
>
errno
{
cloudabi_sys_file_create
(
fd_
path_
.
as_ptr
(
)
path_
.
len
(
)
type_
)
}
#
[
inline
]
pub
unsafe
fn
file_link
(
fd1_
:
lookup
path1_
:
&
[
u8
]
fd2_
:
fd
path2_
:
&
[
u8
]
)
-
>
errno
{
cloudabi_sys_file_link
(
fd1_
path1_
.
as_ptr
(
)
path1_
.
len
(
)
fd2_
path2_
.
as_ptr
(
)
path2_
.
len
(
)
)
}
#
[
inline
]
pub
unsafe
fn
file_open
(
dirfd_
:
lookup
path_
:
&
[
u8
]
oflags_
:
oflags
fds_
:
*
const
fdstat
fd_
:
*
mut
fd
)
-
>
errno
{
cloudabi_sys_file_open
(
dirfd_
path_
.
as_ptr
(
)
path_
.
len
(
)
oflags_
fds_
fd_
)
}
#
[
inline
]
pub
unsafe
fn
file_readdir
(
fd_
:
fd
buf_
:
&
mut
[
u8
]
cookie_
:
dircookie
bufused_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_file_readdir
(
fd_
buf_
.
as_mut_ptr
(
)
as
*
mut
(
)
buf_
.
len
(
)
cookie_
bufused_
)
}
#
[
inline
]
pub
unsafe
fn
file_readlink
(
fd_
:
fd
path_
:
&
[
u8
]
buf_
:
&
mut
[
u8
]
bufused_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_file_readlink
(
fd_
path_
.
as_ptr
(
)
path_
.
len
(
)
buf_
.
as_mut_ptr
(
)
buf_
.
len
(
)
bufused_
)
}
#
[
inline
]
pub
unsafe
fn
file_rename
(
fd1_
:
fd
path1_
:
&
[
u8
]
fd2_
:
fd
path2_
:
&
[
u8
]
)
-
>
errno
{
cloudabi_sys_file_rename
(
fd1_
path1_
.
as_ptr
(
)
path1_
.
len
(
)
fd2_
path2_
.
as_ptr
(
)
path2_
.
len
(
)
)
}
#
[
inline
]
pub
unsafe
fn
file_stat_fget
(
fd_
:
fd
buf_
:
*
mut
filestat
)
-
>
errno
{
cloudabi_sys_file_stat_fget
(
fd_
buf_
)
}
#
[
inline
]
pub
unsafe
fn
file_stat_fput
(
fd_
:
fd
buf_
:
*
const
filestat
flags_
:
fsflags
)
-
>
errno
{
cloudabi_sys_file_stat_fput
(
fd_
buf_
flags_
)
}
#
[
inline
]
pub
unsafe
fn
file_stat_get
(
fd_
:
lookup
path_
:
&
[
u8
]
buf_
:
*
mut
filestat
)
-
>
errno
{
cloudabi_sys_file_stat_get
(
fd_
path_
.
as_ptr
(
)
path_
.
len
(
)
buf_
)
}
#
[
inline
]
pub
unsafe
fn
file_stat_put
(
fd_
:
lookup
path_
:
&
[
u8
]
buf_
:
*
const
filestat
flags_
:
fsflags
)
-
>
errno
{
cloudabi_sys_file_stat_put
(
fd_
path_
.
as_ptr
(
)
path_
.
len
(
)
buf_
flags_
)
}
#
[
inline
]
pub
unsafe
fn
file_symlink
(
path1_
:
&
[
u8
]
fd_
:
fd
path2_
:
&
[
u8
]
)
-
>
errno
{
cloudabi_sys_file_symlink
(
path1_
.
as_ptr
(
)
path1_
.
len
(
)
fd_
path2_
.
as_ptr
(
)
path2_
.
len
(
)
)
}
#
[
inline
]
pub
unsafe
fn
file_unlink
(
fd_
:
fd
path_
:
&
[
u8
]
flags_
:
ulflags
)
-
>
errno
{
cloudabi_sys_file_unlink
(
fd_
path_
.
as_ptr
(
)
path_
.
len
(
)
flags_
)
}
#
[
inline
]
pub
unsafe
fn
lock_unlock
(
lock_
:
*
mut
lock
scope_
:
scope
)
-
>
errno
{
cloudabi_sys_lock_unlock
(
lock_
scope_
)
}
#
[
inline
]
pub
unsafe
fn
mem_advise
(
mapping_
:
&
mut
[
u8
]
advice_
:
advice
)
-
>
errno
{
cloudabi_sys_mem_advise
(
mapping_
.
as_mut_ptr
(
)
as
*
mut
(
)
mapping_
.
len
(
)
advice_
)
}
#
[
inline
]
pub
unsafe
fn
mem_map
(
addr_
:
*
mut
(
)
len_
:
usize
prot_
:
mprot
flags_
:
mflags
fd_
:
fd
off_
:
filesize
mem_
:
*
mut
*
mut
(
)
)
-
>
errno
{
cloudabi_sys_mem_map
(
addr_
len_
prot_
flags_
fd_
off_
mem_
)
}
#
[
inline
]
pub
unsafe
fn
mem_protect
(
mapping_
:
&
mut
[
u8
]
prot_
:
mprot
)
-
>
errno
{
cloudabi_sys_mem_protect
(
mapping_
.
as_mut_ptr
(
)
as
*
mut
(
)
mapping_
.
len
(
)
prot_
)
}
#
[
inline
]
pub
unsafe
fn
mem_sync
(
mapping_
:
&
mut
[
u8
]
flags_
:
msflags
)
-
>
errno
{
cloudabi_sys_mem_sync
(
mapping_
.
as_mut_ptr
(
)
as
*
mut
(
)
mapping_
.
len
(
)
flags_
)
}
#
[
inline
]
pub
unsafe
fn
mem_unmap
(
mapping_
:
&
mut
[
u8
]
)
-
>
errno
{
cloudabi_sys_mem_unmap
(
mapping_
.
as_mut_ptr
(
)
as
*
mut
(
)
mapping_
.
len
(
)
)
}
#
[
inline
]
pub
unsafe
fn
poll
(
in_
:
*
const
subscription
out_
:
*
mut
event
nsubscriptions_
:
usize
nevents_
:
*
mut
usize
)
-
>
errno
{
cloudabi_sys_poll
(
in_
out_
nsubscriptions_
nevents_
)
}
#
[
inline
]
pub
unsafe
fn
proc_exec
(
fd_
:
fd
data_
:
&
[
u8
]
fds_
:
&
[
fd
]
)
-
>
errno
{
cloudabi_sys_proc_exec
(
fd_
data_
.
as_ptr
(
)
as
*
const
(
)
data_
.
len
(
)
fds_
.
as_ptr
(
)
fds_
.
len
(
)
)
}
#
[
inline
]
pub
unsafe
fn
proc_exit
(
rval_
:
exitcode
)
-
>
!
{
cloudabi_sys_proc_exit
(
rval_
)
}
#
[
inline
]
pub
unsafe
fn
proc_fork
(
fd_
:
*
mut
fd
tid_
:
*
mut
tid
)
-
>
errno
{
cloudabi_sys_proc_fork
(
fd_
tid_
)
}
#
[
inline
]
pub
unsafe
fn
proc_raise
(
sig_
:
signal
)
-
>
errno
{
cloudabi_sys_proc_raise
(
sig_
)
}
#
[
inline
]
pub
unsafe
fn
random_get
(
buf_
:
&
mut
[
u8
]
)
-
>
errno
{
cloudabi_sys_random_get
(
buf_
.
as_mut_ptr
(
)
as
*
mut
(
)
buf_
.
len
(
)
)
}
#
[
inline
]
pub
unsafe
fn
sock_recv
(
sock_
:
fd
in_
:
*
const
recv_in
out_
:
*
mut
recv_out
)
-
>
errno
{
cloudabi_sys_sock_recv
(
sock_
in_
out_
)
}
#
[
inline
]
pub
unsafe
fn
sock_send
(
sock_
:
fd
in_
:
*
const
send_in
out_
:
*
mut
send_out
)
-
>
errno
{
cloudabi_sys_sock_send
(
sock_
in_
out_
)
}
#
[
inline
]
pub
unsafe
fn
sock_shutdown
(
sock_
:
fd
how_
:
sdflags
)
-
>
errno
{
cloudabi_sys_sock_shutdown
(
sock_
how_
)
}
#
[
inline
]
pub
unsafe
fn
thread_create
(
attr_
:
*
mut
threadattr
tid_
:
*
mut
tid
)
-
>
errno
{
cloudabi_sys_thread_create
(
attr_
tid_
)
}
#
[
inline
]
pub
unsafe
fn
thread_exit
(
lock_
:
*
mut
lock
scope_
:
scope
)
-
>
!
{
cloudabi_sys_thread_exit
(
lock_
scope_
)
}
#
[
inline
]
pub
unsafe
fn
thread_yield
(
)
-
>
errno
{
cloudabi_sys_thread_yield
(
)
}
