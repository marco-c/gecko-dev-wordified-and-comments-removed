use
crate
:
:
codec
:
:
decoder
:
:
Decoder
;
use
crate
:
:
codec
:
:
encoder
:
:
Encoder
;
use
crate
:
:
codec
:
:
framed_read
:
:
{
framed_read2
framed_read2_with_buffer
FramedRead2
}
;
use
crate
:
:
codec
:
:
framed_write
:
:
{
framed_write2
framed_write2_with_buffer
FramedWrite2
}
;
use
tokio
:
:
{
io
:
:
{
AsyncBufRead
AsyncRead
AsyncWrite
}
stream
:
:
Stream
}
;
use
bytes
:
:
BytesMut
;
use
futures_sink
:
:
Sink
;
use
pin_project_lite
:
:
pin_project
;
use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
self
BufRead
Read
Write
}
;
use
std
:
:
mem
:
:
MaybeUninit
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
pin_project
!
{
/
/
/
A
unified
[
Stream
]
and
[
Sink
]
interface
to
an
underlying
I
/
O
object
using
/
/
/
the
Encoder
and
Decoder
traits
to
encode
and
decode
frames
.
/
/
/
/
/
/
You
can
create
a
Framed
instance
by
using
the
[
Decoder
:
:
framed
]
adapter
or
/
/
/
by
using
the
new
function
seen
below
.
/
/
/
/
/
/
[
Stream
]
:
tokio
:
:
stream
:
:
Stream
/
/
/
[
Sink
]
:
futures_sink
:
:
Sink
/
/
/
[
AsyncRead
]
:
tokio
:
:
io
:
:
AsyncRead
/
/
/
[
Decoder
:
:
framed
]
:
crate
:
:
codec
:
:
Decoder
:
:
framed
(
)
pub
struct
Framed
<
T
U
>
{
#
[
pin
]
inner
:
FramedRead2
<
FramedWrite2
<
Fuse
<
T
U
>
>
>
}
}
pin_project
!
{
pub
(
crate
)
struct
Fuse
<
T
U
>
{
#
[
pin
]
pub
(
crate
)
io
:
T
pub
(
crate
)
codec
:
U
}
}
pub
(
crate
)
trait
ProjectFuse
{
type
Io
;
type
Codec
;
fn
project
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Fuse
<
Pin
<
&
mut
Self
:
:
Io
>
&
mut
Self
:
:
Codec
>
;
}
impl
<
T
U
>
ProjectFuse
for
Fuse
<
T
U
>
{
type
Io
=
T
;
type
Codec
=
U
;
fn
project
(
self
:
Pin
<
&
mut
Self
>
)
-
>
Fuse
<
Pin
<
&
mut
Self
:
:
Io
>
&
mut
Self
:
:
Codec
>
{
let
self_
=
self
.
project
(
)
;
Fuse
{
io
:
self_
.
io
codec
:
self_
.
codec
}
}
}
impl
<
T
U
>
Framed
<
T
U
>
where
T
:
AsyncRead
+
AsyncWrite
{
pub
fn
new
(
inner
:
T
codec
:
U
)
-
>
Framed
<
T
U
>
{
Framed
{
inner
:
framed_read2
(
framed_write2
(
Fuse
{
io
:
inner
codec
}
)
)
}
}
pub
fn
with_capacity
(
inner
:
T
codec
:
U
capacity
:
usize
)
-
>
Framed
<
T
U
>
{
Framed
{
inner
:
framed_read2_with_buffer
(
framed_write2
(
Fuse
{
io
:
inner
codec
}
)
BytesMut
:
:
with_capacity
(
capacity
)
)
}
}
}
impl
<
T
U
>
Framed
<
T
U
>
{
pub
fn
from_parts
(
parts
:
FramedParts
<
T
U
>
)
-
>
Framed
<
T
U
>
{
Framed
{
inner
:
framed_read2_with_buffer
(
framed_write2_with_buffer
(
Fuse
{
io
:
parts
.
io
codec
:
parts
.
codec
}
parts
.
write_buf
)
parts
.
read_buf
)
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
T
{
&
self
.
inner
.
get_ref
(
)
.
get_ref
(
)
.
io
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
inner
.
get_mut
(
)
.
get_mut
(
)
.
io
}
pub
fn
codec
(
&
self
)
-
>
&
U
{
&
self
.
inner
.
get_ref
(
)
.
get_ref
(
)
.
codec
}
pub
fn
codec_mut
(
&
mut
self
)
-
>
&
mut
U
{
&
mut
self
.
inner
.
get_mut
(
)
.
get_mut
(
)
.
codec
}
pub
fn
read_buffer
(
&
self
)
-
>
&
BytesMut
{
self
.
inner
.
buffer
(
)
}
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
inner
.
into_inner
(
)
.
into_inner
(
)
.
io
}
pub
fn
into_parts
(
self
)
-
>
FramedParts
<
T
U
>
{
let
(
inner
read_buf
)
=
self
.
inner
.
into_parts
(
)
;
let
(
inner
write_buf
)
=
inner
.
into_parts
(
)
;
FramedParts
{
io
:
inner
.
io
codec
:
inner
.
codec
read_buf
write_buf
_priv
:
(
)
}
}
}
impl
<
T
U
>
Stream
for
Framed
<
T
U
>
where
T
:
AsyncRead
U
:
Decoder
{
type
Item
=
Result
<
U
:
:
Item
U
:
:
Error
>
;
fn
poll_next
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
{
self
.
project
(
)
.
inner
.
poll_next
(
cx
)
}
}
impl
<
T
I
U
>
Sink
<
I
>
for
Framed
<
T
U
>
where
T
:
AsyncWrite
U
:
Encoder
<
I
>
U
:
:
Error
:
From
<
io
:
:
Error
>
{
type
Error
=
U
:
:
Error
;
fn
poll_ready
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
self
.
project
(
)
.
inner
.
get_pin_mut
(
)
.
poll_ready
(
cx
)
}
fn
start_send
(
self
:
Pin
<
&
mut
Self
>
item
:
I
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
project
(
)
.
inner
.
get_pin_mut
(
)
.
start_send
(
item
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
self
.
project
(
)
.
inner
.
get_pin_mut
(
)
.
poll_flush
(
cx
)
}
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
self
.
project
(
)
.
inner
.
get_pin_mut
(
)
.
poll_close
(
cx
)
}
}
impl
<
T
U
>
fmt
:
:
Debug
for
Framed
<
T
U
>
where
T
:
fmt
:
:
Debug
U
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Framed
"
)
.
field
(
"
io
"
&
self
.
inner
.
get_ref
(
)
.
get_ref
(
)
.
io
)
.
field
(
"
codec
"
&
self
.
inner
.
get_ref
(
)
.
get_ref
(
)
.
codec
)
.
finish
(
)
}
}
impl
<
T
:
Read
U
>
Read
for
Fuse
<
T
U
>
{
fn
read
(
&
mut
self
dst
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
read
(
dst
)
}
}
impl
<
T
:
BufRead
U
>
BufRead
for
Fuse
<
T
U
>
{
fn
fill_buf
(
&
mut
self
)
-
>
io
:
:
Result
<
&
[
u8
]
>
{
self
.
io
.
fill_buf
(
)
}
fn
consume
(
&
mut
self
amt
:
usize
)
{
self
.
io
.
consume
(
amt
)
}
}
impl
<
T
:
AsyncRead
U
>
AsyncRead
for
Fuse
<
T
U
>
{
unsafe
fn
prepare_uninitialized_buffer
(
&
self
buf
:
&
mut
[
MaybeUninit
<
u8
>
]
)
-
>
bool
{
self
.
io
.
prepare_uninitialized_buffer
(
buf
)
}
fn
poll_read
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
Result
<
usize
io
:
:
Error
>
>
{
self
.
project
(
)
.
io
.
poll_read
(
cx
buf
)
}
}
impl
<
T
:
AsyncBufRead
U
>
AsyncBufRead
for
Fuse
<
T
U
>
{
fn
poll_fill_buf
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
&
[
u8
]
>
>
{
self
.
project
(
)
.
io
.
poll_fill_buf
(
cx
)
}
fn
consume
(
self
:
Pin
<
&
mut
Self
>
amt
:
usize
)
{
self
.
project
(
)
.
io
.
consume
(
amt
)
}
}
impl
<
T
:
Write
U
>
Write
for
Fuse
<
T
U
>
{
fn
write
(
&
mut
self
src
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
io
.
write
(
src
)
}
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
flush
(
)
}
}
impl
<
T
:
AsyncWrite
U
>
AsyncWrite
for
Fuse
<
T
U
>
{
fn
poll_write
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
buf
:
&
[
u8
]
)
-
>
Poll
<
Result
<
usize
io
:
:
Error
>
>
{
self
.
project
(
)
.
io
.
poll_write
(
cx
buf
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
self
.
project
(
)
.
io
.
poll_flush
(
cx
)
}
fn
poll_shutdown
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
io
:
:
Error
>
>
{
self
.
project
(
)
.
io
.
poll_shutdown
(
cx
)
}
}
impl
<
T
U
:
Decoder
>
Decoder
for
Fuse
<
T
U
>
{
type
Item
=
U
:
:
Item
;
type
Error
=
U
:
:
Error
;
fn
decode
(
&
mut
self
buffer
:
&
mut
BytesMut
)
-
>
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
self
.
codec
.
decode
(
buffer
)
}
fn
decode_eof
(
&
mut
self
buffer
:
&
mut
BytesMut
)
-
>
Result
<
Option
<
Self
:
:
Item
>
Self
:
:
Error
>
{
self
.
codec
.
decode_eof
(
buffer
)
}
}
impl
<
T
I
U
:
Encoder
<
I
>
>
Encoder
<
I
>
for
Fuse
<
T
U
>
{
type
Error
=
U
:
:
Error
;
fn
encode
(
&
mut
self
item
:
I
dst
:
&
mut
BytesMut
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
codec
.
encode
(
item
dst
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
FramedParts
<
T
U
>
{
pub
io
:
T
pub
codec
:
U
pub
read_buf
:
BytesMut
pub
write_buf
:
BytesMut
_priv
:
(
)
}
impl
<
T
U
>
FramedParts
<
T
U
>
{
pub
fn
new
<
I
>
(
io
:
T
codec
:
U
)
-
>
FramedParts
<
T
U
>
where
U
:
Encoder
<
I
>
{
FramedParts
{
io
codec
read_buf
:
BytesMut
:
:
new
(
)
write_buf
:
BytesMut
:
:
new
(
)
_priv
:
(
)
}
}
}
