use
std
:
:
alloc
:
:
Layout
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
panic
:
:
AssertUnwindSafe
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
ptr
:
:
{
self
NonNull
}
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
use
std
:
:
{
fmt
panic
}
;
pub
struct
ReusableBoxFuture
<
'
a
T
>
{
boxed
:
NonNull
<
dyn
Future
<
Output
=
T
>
+
Send
+
'
a
>
}
impl
<
'
a
T
>
ReusableBoxFuture
<
'
a
T
>
{
pub
fn
new
<
F
>
(
future
:
F
)
-
>
Self
where
F
:
Future
<
Output
=
T
>
+
Send
+
'
a
{
let
boxed
:
Box
<
dyn
Future
<
Output
=
T
>
+
Send
+
'
a
>
=
Box
:
:
new
(
future
)
;
let
boxed
=
NonNull
:
:
from
(
Box
:
:
leak
(
boxed
)
)
;
Self
{
boxed
}
}
pub
fn
set
<
F
>
(
&
mut
self
future
:
F
)
where
F
:
Future
<
Output
=
T
>
+
Send
+
'
a
{
if
let
Err
(
future
)
=
self
.
try_set
(
future
)
{
*
self
=
Self
:
:
new
(
future
)
;
}
}
pub
fn
try_set
<
F
>
(
&
mut
self
future
:
F
)
-
>
Result
<
(
)
F
>
where
F
:
Future
<
Output
=
T
>
+
Send
+
'
a
{
let
self_layout
=
{
let
dyn_future
:
&
(
dyn
Future
<
Output
=
T
>
+
Send
)
=
unsafe
{
self
.
boxed
.
as_ref
(
)
}
;
Layout
:
:
for_value
(
dyn_future
)
}
;
if
Layout
:
:
new
:
:
<
F
>
(
)
=
=
self_layout
{
unsafe
{
self
.
set_same_layout
(
future
)
;
}
Ok
(
(
)
)
}
else
{
Err
(
future
)
}
}
unsafe
fn
set_same_layout
<
F
>
(
&
mut
self
future
:
F
)
where
F
:
Future
<
Output
=
T
>
+
Send
+
'
a
{
let
result
=
panic
:
:
catch_unwind
(
AssertUnwindSafe
(
|
|
{
ptr
:
:
drop_in_place
(
self
.
boxed
.
as_ptr
(
)
)
;
}
)
)
;
let
self_ptr
:
*
mut
F
=
self
.
boxed
.
as_ptr
(
)
as
*
mut
F
;
ptr
:
:
write
(
self_ptr
future
)
;
self
.
boxed
=
NonNull
:
:
new_unchecked
(
self_ptr
)
;
match
result
{
Ok
(
(
)
)
=
>
{
}
Err
(
payload
)
=
>
{
panic
:
:
resume_unwind
(
payload
)
;
}
}
}
pub
fn
get_pin
(
&
mut
self
)
-
>
Pin
<
&
mut
(
dyn
Future
<
Output
=
T
>
+
Send
)
>
{
unsafe
{
Pin
:
:
new_unchecked
(
self
.
boxed
.
as_mut
(
)
)
}
}
pub
fn
poll
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
T
>
{
self
.
get_pin
(
)
.
poll
(
cx
)
}
}
impl
<
T
>
Future
for
ReusableBoxFuture
<
'
_
T
>
{
type
Output
=
T
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
T
>
{
Pin
:
:
into_inner
(
self
)
.
get_pin
(
)
.
poll
(
cx
)
}
}
unsafe
impl
<
T
>
Send
for
ReusableBoxFuture
<
'
_
T
>
{
}
unsafe
impl
<
T
>
Sync
for
ReusableBoxFuture
<
'
_
T
>
{
}
impl
<
T
>
Unpin
for
ReusableBoxFuture
<
'
_
T
>
{
}
impl
<
T
>
Drop
for
ReusableBoxFuture
<
'
_
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
drop
(
Box
:
:
from_raw
(
self
.
boxed
.
as_ptr
(
)
)
)
;
}
}
}
impl
<
T
>
fmt
:
:
Debug
for
ReusableBoxFuture
<
'
_
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
ReusableBoxFuture
"
)
.
finish
(
)
}
}
