pub
(
crate
)
mod
guard
;
mod
tree_node
;
use
crate
:
:
loom
:
:
sync
:
:
Arc
;
use
core
:
:
future
:
:
Future
;
use
core
:
:
pin
:
:
Pin
;
use
core
:
:
task
:
:
{
Context
Poll
}
;
use
guard
:
:
DropGuard
;
use
pin_project_lite
:
:
pin_project
;
pub
struct
CancellationToken
{
inner
:
Arc
<
tree_node
:
:
TreeNode
>
}
pin_project
!
{
/
/
/
A
Future
that
is
resolved
once
the
corresponding
[
CancellationToken
]
/
/
/
is
cancelled
.
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
WaitForCancellationFuture
<
'
a
>
{
cancellation_token
:
&
'
a
CancellationToken
#
[
pin
]
future
:
tokio
:
:
sync
:
:
futures
:
:
Notified
<
'
a
>
}
}
impl
core
:
:
fmt
:
:
Debug
for
CancellationToken
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
CancellationToken
"
)
.
field
(
"
is_cancelled
"
&
self
.
is_cancelled
(
)
)
.
finish
(
)
}
}
impl
Clone
for
CancellationToken
{
fn
clone
(
&
self
)
-
>
Self
{
tree_node
:
:
increase_handle_refcount
(
&
self
.
inner
)
;
CancellationToken
{
inner
:
self
.
inner
.
clone
(
)
}
}
}
impl
Drop
for
CancellationToken
{
fn
drop
(
&
mut
self
)
{
tree_node
:
:
decrease_handle_refcount
(
&
self
.
inner
)
;
}
}
impl
Default
for
CancellationToken
{
fn
default
(
)
-
>
CancellationToken
{
CancellationToken
:
:
new
(
)
}
}
impl
CancellationToken
{
pub
fn
new
(
)
-
>
CancellationToken
{
CancellationToken
{
inner
:
Arc
:
:
new
(
tree_node
:
:
TreeNode
:
:
new
(
)
)
}
}
pub
fn
child_token
(
&
self
)
-
>
CancellationToken
{
CancellationToken
{
inner
:
tree_node
:
:
child_node
(
&
self
.
inner
)
}
}
pub
fn
cancel
(
&
self
)
{
tree_node
:
:
cancel
(
&
self
.
inner
)
;
}
pub
fn
is_cancelled
(
&
self
)
-
>
bool
{
tree_node
:
:
is_cancelled
(
&
self
.
inner
)
}
pub
fn
cancelled
(
&
self
)
-
>
WaitForCancellationFuture
<
'
_
>
{
WaitForCancellationFuture
{
cancellation_token
:
self
future
:
self
.
inner
.
notified
(
)
}
}
pub
fn
drop_guard
(
self
)
-
>
DropGuard
{
DropGuard
{
inner
:
Some
(
self
)
}
}
}
impl
<
'
a
>
core
:
:
fmt
:
:
Debug
for
WaitForCancellationFuture
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
WaitForCancellationFuture
"
)
.
finish
(
)
}
}
impl
<
'
a
>
Future
for
WaitForCancellationFuture
<
'
a
>
{
type
Output
=
(
)
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
(
)
>
{
let
mut
this
=
self
.
project
(
)
;
loop
{
if
this
.
cancellation_token
.
is_cancelled
(
)
{
return
Poll
:
:
Ready
(
(
)
)
;
}
if
this
.
future
.
as_mut
(
)
.
poll
(
cx
)
.
is_pending
(
)
{
return
Poll
:
:
Pending
;
}
this
.
future
.
set
(
this
.
cancellation_token
.
inner
.
notified
(
)
)
;
}
}
}
