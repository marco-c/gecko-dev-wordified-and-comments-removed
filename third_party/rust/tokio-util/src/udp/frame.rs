use
crate
:
:
codec
:
:
{
Decoder
Encoder
}
;
use
futures_core
:
:
Stream
;
use
tokio
:
:
{
io
:
:
ReadBuf
net
:
:
UdpSocket
}
;
use
bytes
:
:
{
BufMut
BytesMut
}
;
use
futures_core
:
:
ready
;
use
futures_sink
:
:
Sink
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
use
std
:
:
{
borrow
:
:
Borrow
net
:
:
{
Ipv4Addr
SocketAddr
SocketAddrV4
}
}
;
use
std
:
:
{
io
mem
:
:
MaybeUninit
}
;
#
[
must_use
=
"
sinks
do
nothing
unless
polled
"
]
#
[
derive
(
Debug
)
]
pub
struct
UdpFramed
<
C
T
=
UdpSocket
>
{
socket
:
T
codec
:
C
rd
:
BytesMut
wr
:
BytesMut
out_addr
:
SocketAddr
flushed
:
bool
is_readable
:
bool
current_addr
:
Option
<
SocketAddr
>
}
const
INITIAL_RD_CAPACITY
:
usize
=
64
*
1024
;
const
INITIAL_WR_CAPACITY
:
usize
=
8
*
1024
;
impl
<
C
T
>
Unpin
for
UdpFramed
<
C
T
>
{
}
impl
<
C
T
>
Stream
for
UdpFramed
<
C
T
>
where
T
:
Borrow
<
UdpSocket
>
C
:
Decoder
{
type
Item
=
Result
<
(
C
:
:
Item
SocketAddr
)
C
:
:
Error
>
;
fn
poll_next
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
{
let
pin
=
self
.
get_mut
(
)
;
pin
.
rd
.
reserve
(
INITIAL_RD_CAPACITY
)
;
loop
{
if
pin
.
is_readable
{
if
let
Some
(
frame
)
=
pin
.
codec
.
decode_eof
(
&
mut
pin
.
rd
)
?
{
let
current_addr
=
pin
.
current_addr
.
expect
(
"
will
always
be
set
before
this
line
is
called
"
)
;
return
Poll
:
:
Ready
(
Some
(
Ok
(
(
frame
current_addr
)
)
)
)
;
}
pin
.
is_readable
=
false
;
pin
.
rd
.
clear
(
)
;
}
let
addr
=
unsafe
{
let
buf
=
&
mut
*
(
pin
.
rd
.
chunk_mut
(
)
as
*
mut
_
as
*
mut
[
MaybeUninit
<
u8
>
]
)
;
let
mut
read
=
ReadBuf
:
:
uninit
(
buf
)
;
let
ptr
=
read
.
filled
(
)
.
as_ptr
(
)
;
let
res
=
ready
!
(
pin
.
socket
.
borrow
(
)
.
poll_recv_from
(
cx
&
mut
read
)
)
;
assert_eq
!
(
ptr
read
.
filled
(
)
.
as_ptr
(
)
)
;
let
addr
=
res
?
;
pin
.
rd
.
advance_mut
(
read
.
filled
(
)
.
len
(
)
)
;
addr
}
;
pin
.
current_addr
=
Some
(
addr
)
;
pin
.
is_readable
=
true
;
}
}
}
impl
<
I
C
T
>
Sink
<
(
I
SocketAddr
)
>
for
UdpFramed
<
C
T
>
where
T
:
Borrow
<
UdpSocket
>
C
:
Encoder
<
I
>
{
type
Error
=
C
:
:
Error
;
fn
poll_ready
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
if
!
self
.
flushed
{
match
self
.
poll_flush
(
cx
)
?
{
Poll
:
:
Ready
(
(
)
)
=
>
{
}
Poll
:
:
Pending
=
>
return
Poll
:
:
Pending
}
}
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
fn
start_send
(
self
:
Pin
<
&
mut
Self
>
item
:
(
I
SocketAddr
)
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
let
(
frame
out_addr
)
=
item
;
let
pin
=
self
.
get_mut
(
)
;
pin
.
codec
.
encode
(
frame
&
mut
pin
.
wr
)
?
;
pin
.
out_addr
=
out_addr
;
pin
.
flushed
=
false
;
Ok
(
(
)
)
}
fn
poll_flush
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
if
self
.
flushed
{
return
Poll
:
:
Ready
(
Ok
(
(
)
)
)
;
}
let
Self
{
ref
socket
ref
mut
out_addr
ref
mut
wr
.
.
}
=
*
self
;
let
n
=
ready
!
(
socket
.
borrow
(
)
.
poll_send_to
(
cx
wr
*
out_addr
)
)
?
;
let
wrote_all
=
n
=
=
self
.
wr
.
len
(
)
;
self
.
wr
.
clear
(
)
;
self
.
flushed
=
true
;
let
res
=
if
wrote_all
{
Ok
(
(
)
)
}
else
{
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
failed
to
write
entire
datagram
to
socket
"
)
.
into
(
)
)
}
;
Poll
:
:
Ready
(
res
)
}
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
ready
!
(
self
.
poll_flush
(
cx
)
)
?
;
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
}
impl
<
C
T
>
UdpFramed
<
C
T
>
where
T
:
Borrow
<
UdpSocket
>
{
pub
fn
new
(
socket
:
T
codec
:
C
)
-
>
UdpFramed
<
C
T
>
{
Self
{
socket
codec
out_addr
:
SocketAddr
:
:
V4
(
SocketAddrV4
:
:
new
(
Ipv4Addr
:
:
new
(
0
0
0
0
)
0
)
)
rd
:
BytesMut
:
:
with_capacity
(
INITIAL_RD_CAPACITY
)
wr
:
BytesMut
:
:
with_capacity
(
INITIAL_WR_CAPACITY
)
flushed
:
true
is_readable
:
false
current_addr
:
None
}
}
pub
fn
get_ref
(
&
self
)
-
>
&
T
{
&
self
.
socket
}
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
socket
}
pub
fn
codec
(
&
self
)
-
>
&
C
{
&
self
.
codec
}
pub
fn
codec_mut
(
&
mut
self
)
-
>
&
mut
C
{
&
mut
self
.
codec
}
pub
fn
read_buffer
(
&
self
)
-
>
&
BytesMut
{
&
self
.
rd
}
pub
fn
read_buffer_mut
(
&
mut
self
)
-
>
&
mut
BytesMut
{
&
mut
self
.
rd
}
pub
fn
into_inner
(
self
)
-
>
T
{
self
.
socket
}
}
