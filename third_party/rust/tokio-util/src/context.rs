use
pin_project_lite
:
:
pin_project
;
use
std
:
:
{
future
:
:
Future
pin
:
:
Pin
task
:
:
{
Context
Poll
}
}
;
use
tokio
:
:
runtime
:
:
{
Handle
Runtime
}
;
pin_project
!
{
/
/
/
TokioContext
allows
running
futures
that
must
be
inside
Tokio
'
s
/
/
/
context
on
a
non
-
Tokio
runtime
.
/
/
/
/
/
/
It
contains
a
[
Handle
]
to
the
runtime
.
A
handle
to
the
runtime
can
be
/
/
/
obtain
by
calling
the
[
Runtime
:
:
handle
(
)
]
method
.
/
/
/
/
/
/
Note
that
the
TokioContext
wrapper
only
works
if
the
Runtime
it
is
/
/
/
connected
to
has
not
yet
been
destroyed
.
You
must
keep
the
Runtime
/
/
/
alive
until
the
future
has
finished
executing
.
/
/
/
/
/
/
*
*
Warning
:
*
*
If
TokioContext
is
used
together
with
a
[
current
thread
]
/
/
/
runtime
that
runtime
must
be
inside
a
call
to
block_on
for
the
/
/
/
wrapped
future
to
work
.
For
this
reason
it
is
recommended
to
use
a
/
/
/
[
multi
thread
]
runtime
even
if
you
configure
it
to
only
spawn
one
/
/
/
worker
thread
.
/
/
/
/
/
/
#
Examples
/
/
/
/
/
/
This
example
creates
two
runtimes
but
only
[
enables
time
]
on
one
of
/
/
/
them
.
It
then
uses
the
context
of
the
runtime
with
the
timer
enabled
to
/
/
/
execute
a
[
sleep
]
future
on
the
runtime
with
timing
disabled
.
/
/
/
/
/
/
use
tokio
:
:
time
:
:
{
sleep
Duration
}
;
/
/
/
use
tokio_util
:
:
context
:
:
RuntimeExt
;
/
/
/
/
/
/
/
/
This
runtime
has
timers
enabled
.
/
/
/
let
rt
=
tokio
:
:
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
enable_all
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
/
/
This
runtime
has
timers
disabled
.
/
/
/
let
rt2
=
tokio
:
:
runtime
:
:
Builder
:
:
new_multi_thread
(
)
/
/
/
.
build
(
)
/
/
/
.
unwrap
(
)
;
/
/
/
/
/
/
/
/
Wrap
the
sleep
future
in
the
context
of
rt
.
/
/
/
let
fut
=
rt
.
wrap
(
async
{
sleep
(
Duration
:
:
from_millis
(
2
)
)
.
await
}
)
;
/
/
/
/
/
/
/
/
Execute
the
future
on
rt2
.
/
/
/
rt2
.
block_on
(
fut
)
;
/
/
/
/
/
/
/
/
/
[
Handle
]
:
struct
tokio
:
:
runtime
:
:
Handle
/
/
/
[
Runtime
:
:
handle
(
)
]
:
fn
tokio
:
:
runtime
:
:
Runtime
:
:
handle
/
/
/
[
RuntimeExt
]
:
trait
crate
:
:
context
:
:
RuntimeExt
/
/
/
[
new_static
]
:
fn
Self
:
:
new_static
/
/
/
[
sleep
]
:
fn
tokio
:
:
time
:
:
sleep
/
/
/
[
current
thread
]
:
fn
tokio
:
:
runtime
:
:
Builder
:
:
new_current_thread
/
/
/
[
enables
time
]
:
fn
tokio
:
:
runtime
:
:
Builder
:
:
enable_time
/
/
/
[
multi
thread
]
:
fn
tokio
:
:
runtime
:
:
Builder
:
:
new_multi_thread
pub
struct
TokioContext
<
F
>
{
#
[
pin
]
inner
:
F
handle
:
Handle
}
}
impl
<
F
>
TokioContext
<
F
>
{
pub
fn
new
(
future
:
F
handle
:
Handle
)
-
>
TokioContext
<
F
>
{
TokioContext
{
inner
:
future
handle
}
}
pub
fn
handle
(
&
self
)
-
>
&
Handle
{
&
self
.
handle
}
pub
fn
into_inner
(
self
)
-
>
F
{
self
.
inner
}
}
impl
<
F
:
Future
>
Future
for
TokioContext
<
F
>
{
type
Output
=
F
:
:
Output
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
me
=
self
.
project
(
)
;
let
handle
=
me
.
handle
;
let
fut
=
me
.
inner
;
let
_enter
=
handle
.
enter
(
)
;
fut
.
poll
(
cx
)
}
}
pub
trait
RuntimeExt
{
fn
wrap
<
F
:
Future
>
(
&
self
fut
:
F
)
-
>
TokioContext
<
F
>
;
}
impl
RuntimeExt
for
Runtime
{
fn
wrap
<
F
:
Future
>
(
&
self
fut
:
F
)
-
>
TokioContext
<
F
>
{
TokioContext
{
inner
:
fut
handle
:
self
.
handle
(
)
.
clone
(
)
}
}
}
