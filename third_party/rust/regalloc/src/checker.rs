#
!
[
allow
(
dead_code
)
]
use
crate
:
:
analysis_data_flow
:
:
get_san_reg_sets_for_insn
;
use
crate
:
:
data_structures
:
:
{
BlockIx
InstIx
Map
RealReg
RealRegUniverse
Reg
RegSets
SpillSlot
VirtualReg
Writable
}
;
use
crate
:
:
inst_stream
:
:
{
ExtPoint
InstExtPoint
InstToInsertAndExtPoint
}
;
use
crate
:
:
{
Function
RegUsageMapper
}
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
result
:
:
Result
;
use
log
:
:
debug
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
CheckerErrors
{
errors
:
Vec
<
CheckerError
>
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
CheckerError
{
MissingAllocationForReg
{
reg
:
VirtualReg
inst
:
InstIx
}
UnknownValueInReg
{
real_reg
:
RealReg
inst
:
InstIx
}
IncorrectValueInReg
{
actual
:
Reg
expected
:
Reg
real_reg
:
RealReg
inst
:
InstIx
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
enum
CheckerValue
{
Unknown
Conflicted
Reg
(
Reg
)
}
impl
Default
for
CheckerValue
{
fn
default
(
)
-
>
CheckerValue
{
CheckerValue
:
:
Unknown
}
}
impl
CheckerValue
{
fn
meet
(
&
self
other
:
&
CheckerValue
)
-
>
CheckerValue
{
match
(
self
other
)
{
(
&
CheckerValue
:
:
Unknown
_
)
=
>
*
other
(
_
&
CheckerValue
:
:
Unknown
)
=
>
*
self
(
&
CheckerValue
:
:
Conflicted
_
)
=
>
*
self
(
_
&
CheckerValue
:
:
Conflicted
)
=
>
*
other
_
if
*
self
=
=
*
other
=
>
*
self
_
=
>
CheckerValue
:
:
Conflicted
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
struct
CheckerState
{
reg_values
:
Map
<
RealReg
CheckerValue
>
spill_slots
:
Map
<
SpillSlot
CheckerValue
>
}
impl
Default
for
CheckerState
{
fn
default
(
)
-
>
CheckerState
{
CheckerState
{
reg_values
:
Map
:
:
default
(
)
spill_slots
:
Map
:
:
default
(
)
}
}
}
fn
merge_map
<
K
:
Copy
+
Clone
+
PartialEq
+
Eq
+
Hash
>
(
into
:
&
mut
Map
<
K
CheckerValue
>
from
:
&
Map
<
K
CheckerValue
>
)
{
for
(
k
v
)
in
from
{
let
into_v
=
into
.
entry
(
*
k
)
.
or_insert
(
Default
:
:
default
(
)
)
;
let
merged
=
into_v
.
meet
(
v
)
;
*
into_v
=
merged
;
}
}
impl
CheckerState
{
fn
new
(
)
-
>
CheckerState
{
Default
:
:
default
(
)
}
fn
entry_state
(
ru
:
&
RealRegUniverse
)
-
>
CheckerState
{
let
mut
state
=
CheckerState
:
:
new
(
)
;
for
&
(
rreg
_
)
in
&
ru
.
regs
{
state
.
reg_values
.
insert
(
rreg
CheckerValue
:
:
Reg
(
rreg
.
to_reg
(
)
)
)
;
}
state
}
fn
meet_with
(
&
mut
self
other
:
&
CheckerState
)
{
merge_map
(
&
mut
self
.
reg_values
&
other
.
reg_values
)
;
merge_map
(
&
mut
self
.
spill_slots
&
other
.
spill_slots
)
;
}
fn
check
(
&
self
inst
:
&
Inst
)
-
>
Result
<
(
)
CheckerError
>
{
match
inst
{
&
Inst
:
:
Op
{
inst_ix
ref
uses_orig
ref
uses
.
.
}
=
>
{
assert
!
(
uses_orig
.
len
(
)
=
=
uses
.
len
(
)
)
;
for
(
orig
mapped
)
in
uses_orig
.
iter
(
)
.
cloned
(
)
.
zip
(
uses
.
iter
(
)
.
cloned
(
)
)
{
let
val
=
self
.
reg_values
.
get
(
&
mapped
)
.
cloned
(
)
.
unwrap_or
(
Default
:
:
default
(
)
)
;
debug
!
(
"
checker
:
inst
{
:
?
}
:
orig
{
:
?
}
mapped
{
:
?
}
checker
state
{
:
?
}
"
inst
orig
mapped
val
)
;
match
val
{
CheckerValue
:
:
Unknown
|
CheckerValue
:
:
Conflicted
=
>
{
return
Err
(
CheckerError
:
:
UnknownValueInReg
{
real_reg
:
mapped
inst
:
inst_ix
}
)
;
}
CheckerValue
:
:
Reg
(
r
)
if
r
!
=
orig
=
>
{
return
Err
(
CheckerError
:
:
IncorrectValueInReg
{
actual
:
r
expected
:
orig
real_reg
:
mapped
inst
:
inst_ix
}
)
;
}
_
=
>
{
}
}
}
}
_
=
>
{
}
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
update
(
&
mut
self
inst
:
&
Inst
)
{
match
inst
{
&
Inst
:
:
Op
{
ref
defs_orig
ref
defs
.
.
}
=
>
{
assert
!
(
defs_orig
.
len
(
)
=
=
defs
.
len
(
)
)
;
for
(
orig
mapped
)
in
defs_orig
.
iter
(
)
.
cloned
(
)
.
zip
(
defs
.
iter
(
)
.
cloned
(
)
)
{
self
.
reg_values
.
insert
(
mapped
CheckerValue
:
:
Reg
(
orig
)
)
;
}
}
&
Inst
:
:
Move
{
into
from
}
=
>
{
let
val
=
self
.
reg_values
.
get
(
&
from
)
.
cloned
(
)
.
unwrap_or
(
Default
:
:
default
(
)
)
;
self
.
reg_values
.
insert
(
into
.
to_reg
(
)
val
)
;
}
&
Inst
:
:
Spill
{
into
from
}
=
>
{
let
val
=
self
.
reg_values
.
get
(
&
from
)
.
cloned
(
)
.
unwrap_or
(
Default
:
:
default
(
)
)
;
self
.
spill_slots
.
insert
(
into
val
)
;
}
&
Inst
:
:
Reload
{
into
from
}
=
>
{
let
val
=
self
.
spill_slots
.
get
(
&
from
)
.
cloned
(
)
.
unwrap_or
(
Default
:
:
default
(
)
)
;
self
.
reg_values
.
insert
(
into
.
to_reg
(
)
val
)
;
}
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
enum
Inst
{
Spill
{
into
:
SpillSlot
from
:
RealReg
}
Reload
{
into
:
Writable
<
RealReg
>
from
:
SpillSlot
}
Move
{
into
:
Writable
<
RealReg
>
from
:
RealReg
}
Op
{
inst_ix
:
InstIx
defs_orig
:
Vec
<
Reg
>
uses_orig
:
Vec
<
Reg
>
defs
:
Vec
<
RealReg
>
uses
:
Vec
<
RealReg
>
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Checker
{
bb_entry
:
BlockIx
bb_in
:
Map
<
BlockIx
CheckerState
>
bb_succs
:
Map
<
BlockIx
Vec
<
BlockIx
>
>
bb_insts
:
Map
<
BlockIx
Vec
<
Inst
>
>
}
fn
map_regs
<
F
:
Fn
(
VirtualReg
)
-
>
Option
<
RealReg
>
>
(
inst
:
InstIx
regs
:
&
[
Reg
]
f
:
&
F
)
-
>
Result
<
Vec
<
RealReg
>
CheckerErrors
>
{
let
mut
errors
=
Vec
:
:
new
(
)
;
let
real_regs
=
regs
.
iter
(
)
.
map
(
|
r
|
{
if
r
.
is_virtual
(
)
{
f
(
r
.
to_virtual_reg
(
)
)
.
unwrap_or_else
(
|
|
{
errors
.
push
(
CheckerError
:
:
MissingAllocationForReg
{
reg
:
r
.
to_virtual_reg
(
)
inst
}
)
;
Reg
:
:
new_real
(
r
.
get_class
(
)
0x0
0
)
.
to_real_reg
(
)
}
)
}
else
{
r
.
to_real_reg
(
)
}
}
)
.
collect
(
)
;
if
errors
.
is_empty
(
)
{
Ok
(
real_regs
)
}
else
{
Err
(
CheckerErrors
{
errors
}
)
}
}
impl
Checker
{
pub
(
crate
)
fn
new
<
F
:
Function
>
(
f
:
&
F
ru
:
&
RealRegUniverse
)
-
>
Checker
{
let
mut
bb_in
=
Map
:
:
default
(
)
;
let
mut
bb_succs
=
Map
:
:
default
(
)
;
let
mut
bb_insts
=
Map
:
:
default
(
)
;
for
block
in
f
.
blocks
(
)
{
bb_in
.
insert
(
block
Default
:
:
default
(
)
)
;
bb_succs
.
insert
(
block
f
.
block_succs
(
block
)
.
to_vec
(
)
)
;
bb_insts
.
insert
(
block
vec
!
[
]
)
;
}
bb_in
.
insert
(
f
.
entry_block
(
)
CheckerState
:
:
entry_state
(
ru
)
)
;
Checker
{
bb_entry
:
f
.
entry_block
(
)
bb_in
bb_succs
bb_insts
}
}
pub
(
crate
)
fn
add_inst
(
&
mut
self
block
:
BlockIx
inst
:
Inst
)
{
let
insts
=
self
.
bb_insts
.
get_mut
(
&
block
)
.
unwrap
(
)
;
insts
.
push
(
inst
)
;
}
pub
(
crate
)
fn
add_op
<
RUM
:
RegUsageMapper
>
(
&
mut
self
block
:
BlockIx
inst_ix
:
InstIx
regsets
:
&
RegSets
mapper
:
&
RUM
)
-
>
Result
<
(
)
CheckerErrors
>
{
debug
!
(
"
add_op
:
block
{
}
inst
{
}
regsets
{
:
?
}
"
block
.
get
(
)
inst_ix
.
get
(
)
regsets
)
;
assert
!
(
regsets
.
is_sanitized
(
)
)
;
let
mut
uses_set
=
regsets
.
uses
.
clone
(
)
;
let
mut
defs_set
=
regsets
.
defs
.
clone
(
)
;
uses_set
.
union
(
&
regsets
.
mods
)
;
defs_set
.
union
(
&
regsets
.
mods
)
;
if
uses_set
.
is_empty
(
)
&
&
defs_set
.
is_empty
(
)
{
return
Ok
(
(
)
)
;
}
let
uses_orig
=
uses_set
.
to_vec
(
)
;
let
defs_orig
=
defs_set
.
to_vec
(
)
;
let
uses
=
map_regs
(
inst_ix
&
uses_orig
[
.
.
]
&
|
vreg
|
mapper
.
get_use
(
vreg
)
)
?
;
let
defs
=
map_regs
(
inst_ix
&
defs_orig
[
.
.
]
&
|
vreg
|
mapper
.
get_def
(
vreg
)
)
?
;
let
insts
=
self
.
bb_insts
.
get_mut
(
&
block
)
.
unwrap
(
)
;
let
op
=
Inst
:
:
Op
{
inst_ix
uses_orig
defs_orig
uses
defs
}
;
debug
!
(
"
add_op
:
adding
{
:
?
}
"
op
)
;
insts
.
push
(
op
)
;
Ok
(
(
)
)
}
fn
analyze
(
&
mut
self
)
{
let
mut
queue
=
VecDeque
:
:
new
(
)
;
queue
.
push_back
(
self
.
bb_entry
)
;
while
!
queue
.
is_empty
(
)
{
let
block
=
queue
.
pop_front
(
)
.
unwrap
(
)
;
let
mut
state
=
self
.
bb_in
.
get
(
&
block
)
.
cloned
(
)
.
unwrap
(
)
;
debug
!
(
"
analyze
:
block
{
}
has
state
{
:
?
}
"
block
.
get
(
)
state
)
;
for
inst
in
self
.
bb_insts
.
get
(
&
block
)
.
unwrap
(
)
{
state
.
update
(
inst
)
;
debug
!
(
"
analyze
:
inst
{
:
?
}
-
>
state
{
:
?
}
"
inst
state
)
;
}
for
succ
in
self
.
bb_succs
.
get
(
&
block
)
.
unwrap
(
)
{
let
cur_succ_in
=
self
.
bb_in
.
get
(
succ
)
.
unwrap
(
)
;
let
mut
new_state
=
state
.
clone
(
)
;
new_state
.
meet_with
(
cur_succ_in
)
;
let
changed
=
&
new_state
!
=
cur_succ_in
;
if
changed
{
debug
!
(
"
analyze
:
block
{
}
state
changed
from
{
:
?
}
to
{
:
?
}
;
pushing
onto
queue
"
succ
.
get
(
)
cur_succ_in
new_state
)
;
self
.
bb_in
.
insert
(
*
succ
new_state
)
;
queue
.
push_back
(
*
succ
)
;
}
}
}
}
fn
find_errors
(
&
self
)
-
>
Result
<
(
)
CheckerErrors
>
{
let
mut
errors
=
vec
!
[
]
;
for
(
block
input
)
in
&
self
.
bb_in
{
let
mut
state
=
input
.
clone
(
)
;
for
inst
in
self
.
bb_insts
.
get
(
block
)
.
unwrap
(
)
{
if
let
Err
(
e
)
=
state
.
check
(
inst
)
{
debug
!
(
"
Checker
error
:
{
:
?
}
"
e
)
;
errors
.
push
(
e
)
;
}
state
.
update
(
inst
)
;
}
}
if
errors
.
is_empty
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
CheckerErrors
{
errors
}
)
}
}
pub
(
crate
)
fn
run
(
mut
self
)
-
>
Result
<
(
)
CheckerErrors
>
{
self
.
analyze
(
)
;
self
.
find_errors
(
)
}
}
pub
(
crate
)
struct
CheckerContext
{
checker
:
Checker
checker_inst_map
:
Map
<
InstExtPoint
Vec
<
Inst
>
>
}
impl
CheckerContext
{
pub
(
crate
)
fn
new
<
F
:
Function
>
(
f
:
&
F
ru
:
&
RealRegUniverse
insts_to_add
:
&
Vec
<
InstToInsertAndExtPoint
>
)
-
>
CheckerContext
{
let
mut
checker_inst_map
:
Map
<
InstExtPoint
Vec
<
Inst
>
>
=
Map
:
:
default
(
)
;
for
&
InstToInsertAndExtPoint
{
ref
inst
ref
iep
}
in
insts_to_add
{
let
checker_insts
=
checker_inst_map
.
entry
(
iep
.
clone
(
)
)
.
or_insert_with
(
|
|
vec
!
[
]
)
;
checker_insts
.
push
(
inst
.
to_checker_inst
(
)
)
;
}
let
checker
=
Checker
:
:
new
(
f
ru
)
;
CheckerContext
{
checker
checker_inst_map
}
}
pub
(
crate
)
fn
handle_insn
<
F
:
Function
RUM
:
RegUsageMapper
>
(
&
mut
self
ru
:
&
RealRegUniverse
func
:
&
F
bix
:
BlockIx
iix
:
InstIx
mapper
:
&
RUM
)
-
>
Result
<
(
)
CheckerErrors
>
{
let
empty
=
vec
!
[
]
;
let
pre_point
=
InstExtPoint
:
:
new
(
iix
ExtPoint
:
:
Reload
)
;
let
post_point
=
InstExtPoint
:
:
new
(
iix
ExtPoint
:
:
Spill
)
;
for
checker_inst
in
self
.
checker_inst_map
.
get
(
&
pre_point
)
.
unwrap_or
(
&
empty
)
{
debug
!
(
"
at
inst
{
:
?
}
:
pre
checker_inst
:
{
:
?
}
"
iix
checker_inst
)
;
self
.
checker
.
add_inst
(
bix
checker_inst
.
clone
(
)
)
;
}
let
regsets
=
get_san_reg_sets_for_insn
:
:
<
F
>
(
func
.
get_insn
(
iix
)
ru
)
.
expect
(
"
only
existing
real
registers
at
this
point
"
)
;
assert
!
(
regsets
.
is_sanitized
(
)
)
;
debug
!
(
"
at
inst
{
:
?
}
:
regsets
{
:
?
}
mapper
{
:
?
}
"
iix
regsets
mapper
)
;
self
.
checker
.
add_op
(
bix
iix
&
regsets
mapper
)
?
;
for
checker_inst
in
self
.
checker_inst_map
.
get
(
&
post_point
)
.
unwrap_or
(
&
empty
)
{
debug
!
(
"
at
inst
{
:
?
}
:
post
checker_inst
:
{
:
?
}
"
iix
checker_inst
)
;
self
.
checker
.
add_inst
(
bix
checker_inst
.
clone
(
)
)
;
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
run
(
self
)
-
>
Result
<
(
)
CheckerErrors
>
{
self
.
checker
.
run
(
)
}
}
