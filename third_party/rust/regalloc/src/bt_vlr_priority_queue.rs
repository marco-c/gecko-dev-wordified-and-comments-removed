#
!
[
allow
(
non_snake_case
)
]
#
!
[
allow
(
non_camel_case_types
)
]
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
collections
:
:
BinaryHeap
;
use
crate
:
:
data_structures
:
:
{
TypedIxVec
VirtualRange
VirtualRangeIx
}
;
struct
VirtualRangeIxAndSize
{
vlrix
:
VirtualRangeIx
size
:
u16
tiebreaker
:
u32
}
impl
VirtualRangeIxAndSize
{
fn
new
(
vlrix
:
VirtualRangeIx
size
:
u16
tiebreaker
:
u32
)
-
>
Self
{
assert
!
(
size
>
0
)
;
Self
{
vlrix
size
tiebreaker
}
}
}
impl
PartialEq
for
VirtualRangeIxAndSize
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
size
=
=
other
.
size
&
&
self
.
tiebreaker
=
=
other
.
tiebreaker
}
}
impl
Eq
for
VirtualRangeIxAndSize
{
}
impl
PartialOrd
for
VirtualRangeIxAndSize
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
impl
Ord
for
VirtualRangeIxAndSize
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
match
self
.
size
.
cmp
(
&
other
.
size
)
{
Ordering
:
:
Less
=
>
Ordering
:
:
Less
Ordering
:
:
Greater
=
>
Ordering
:
:
Greater
Ordering
:
:
Equal
=
>
self
.
tiebreaker
.
cmp
(
&
other
.
tiebreaker
)
}
}
}
pub
struct
VirtualRangePrioQ
{
heap
:
BinaryHeap
<
VirtualRangeIxAndSize
>
tiebreaker_ctr
:
u32
}
impl
VirtualRangePrioQ
{
pub
fn
new
(
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
-
>
Self
{
let
mut
res
=
Self
{
heap
:
BinaryHeap
:
:
new
(
)
tiebreaker_ctr
:
0xFFFF_FFFFu32
}
;
for
vlrix
in
VirtualRangeIx
:
:
new
(
0
)
.
dotdot
(
VirtualRangeIx
:
:
new
(
vlr_env
.
len
(
)
)
)
{
let
to_add
=
VirtualRangeIxAndSize
:
:
new
(
vlrix
vlr_env
[
vlrix
]
.
size
res
.
tiebreaker_ctr
)
;
res
.
heap
.
push
(
to_add
)
;
res
.
tiebreaker_ctr
-
=
1
;
}
res
}
#
[
inline
(
never
)
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
heap
.
is_empty
(
)
}
#
[
inline
(
never
)
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
heap
.
len
(
)
}
#
[
inline
(
never
)
]
pub
fn
add_VirtualRange
(
&
mut
self
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
vlrix
:
VirtualRangeIx
)
{
let
to_add
=
VirtualRangeIxAndSize
:
:
new
(
vlrix
vlr_env
[
vlrix
]
.
size
self
.
tiebreaker_ctr
)
;
self
.
tiebreaker_ctr
-
=
1
;
self
.
heap
.
push
(
to_add
)
;
}
#
[
inline
(
never
)
]
pub
fn
get_longest_VirtualRange
(
&
mut
self
)
-
>
Option
<
VirtualRangeIx
>
{
match
self
.
heap
.
pop
(
)
{
None
=
>
None
Some
(
VirtualRangeIxAndSize
{
vlrix
.
.
}
)
=
>
Some
(
vlrix
)
}
}
#
[
inline
(
never
)
]
pub
fn
show_with_envs
(
&
self
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
-
>
Vec
<
String
>
{
let
mut
resV
=
vec
!
[
]
;
for
VirtualRangeIxAndSize
{
vlrix
.
.
}
in
self
.
heap
.
iter
(
)
{
let
mut
res
=
"
TODO
"
.
to_string
(
)
;
res
+
=
&
format
!
(
"
{
:
?
}
=
{
:
?
}
"
vlrix
&
vlr_env
[
*
vlrix
]
)
;
resV
.
push
(
res
)
;
}
resV
}
}
