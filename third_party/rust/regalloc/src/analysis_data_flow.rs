use
log
:
:
{
debug
info
log_enabled
Level
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
;
use
crate
:
:
analysis_control_flow
:
:
CFGInfo
;
use
crate
:
:
data_structures
:
:
{
BlockIx
InstIx
InstPoint
Map
Queue
RangeFrag
RangeFragIx
RangeFragKind
RealRange
RealRangeIx
RealReg
RealRegUniverse
Reg
RegSets
RegUsageCollector
RegVecBounds
RegVecs
RegVecsAndBounds
Set
SortedRangeFragIxs
SpillCost
TypedIxVec
VirtualRange
VirtualRangeIx
}
;
use
crate
:
:
sparse_set
:
:
SparseSet
;
use
crate
:
:
union_find
:
:
{
ToFromU32
UnionFind
}
;
use
crate
:
:
Function
;
const
CROSSCHECK_MERGE
:
bool
=
false
;
#
[
inline
(
never
)
]
fn
remove_dups_from_group
(
regs
:
&
mut
Vec
<
Reg
>
start
:
u32
len
:
&
mut
u8
)
{
regs
[
start
as
usize
.
.
start
as
usize
+
*
len
as
usize
]
.
sort_unstable
(
)
;
let
mut
wr
=
start
as
usize
;
for
rd
in
start
as
usize
.
.
start
as
usize
+
*
len
as
usize
{
let
reg
=
regs
[
rd
]
;
if
rd
=
=
start
as
usize
|
|
regs
[
rd
-
1
]
!
=
reg
{
if
wr
!
=
rd
{
regs
[
wr
]
=
reg
;
}
wr
+
=
1
;
}
}
let
new_len_usize
=
wr
-
start
as
usize
;
assert
!
(
new_len_usize
<
=
*
len
as
usize
)
;
*
len
=
new_len_usize
as
u8
;
}
#
[
inline
(
never
)
]
fn
remove_mods_from_group
(
group
:
&
mut
Vec
<
Reg
>
group_start
:
u32
group_len
:
&
mut
u8
mods
:
&
Vec
<
Reg
>
mods_start
:
u32
mods_len
:
u8
)
{
let
mut
wr
=
group_start
as
usize
;
for
rd
in
group_start
as
usize
.
.
group_start
as
usize
+
*
group_len
as
usize
{
let
reg
=
group
[
rd
]
;
let
mut
retain
=
true
;
for
i
in
mods_start
as
usize
.
.
mods_start
as
usize
+
mods_len
as
usize
{
if
reg
=
=
mods
[
i
]
{
retain
=
false
;
break
;
}
}
if
retain
{
if
wr
!
=
rd
{
group
[
wr
]
=
reg
;
}
wr
+
=
1
;
}
}
let
new_group_len_usize
=
wr
-
group_start
as
usize
;
assert
!
(
new_group_len_usize
<
=
*
group_len
as
usize
)
;
*
group_len
=
new_group_len_usize
as
u8
;
}
#
[
inline
(
never
)
]
pub
fn
add_raw_reg_vecs_for_insn
<
F
:
Function
>
(
inst
:
&
F
:
:
Inst
reg_vecs
:
&
mut
RegVecs
bounds
:
&
mut
RegVecBounds
)
{
bounds
.
uses_start
=
reg_vecs
.
uses
.
len
(
)
as
u32
;
bounds
.
defs_start
=
reg_vecs
.
defs
.
len
(
)
as
u32
;
bounds
.
mods_start
=
reg_vecs
.
mods
.
len
(
)
as
u32
;
let
mut
collector
=
RegUsageCollector
:
:
new
(
reg_vecs
)
;
F
:
:
get_regs
(
inst
&
mut
collector
)
;
let
uses_len
=
collector
.
reg_vecs
.
uses
.
len
(
)
as
u32
-
bounds
.
uses_start
;
let
defs_len
=
collector
.
reg_vecs
.
defs
.
len
(
)
as
u32
-
bounds
.
defs_start
;
let
mods_len
=
collector
.
reg_vecs
.
mods
.
len
(
)
as
u32
-
bounds
.
mods_start
;
assert
!
(
(
uses_len
|
defs_len
|
mods_len
)
<
256
)
;
bounds
.
uses_len
=
uses_len
as
u8
;
bounds
.
defs_len
=
defs_len
as
u8
;
bounds
.
mods_len
=
mods_len
as
u8
;
if
bounds
.
uses_len
>
0
{
remove_dups_from_group
(
&
mut
collector
.
reg_vecs
.
uses
bounds
.
uses_start
&
mut
bounds
.
uses_len
)
;
}
if
bounds
.
defs_len
>
0
{
remove_dups_from_group
(
&
mut
collector
.
reg_vecs
.
defs
bounds
.
defs_start
&
mut
bounds
.
defs_len
)
;
}
if
bounds
.
mods_len
>
0
{
remove_dups_from_group
(
&
mut
collector
.
reg_vecs
.
mods
bounds
.
mods_start
&
mut
bounds
.
mods_len
)
;
}
if
bounds
.
mods_len
>
0
{
if
bounds
.
uses_len
>
0
{
remove_mods_from_group
(
&
mut
collector
.
reg_vecs
.
uses
bounds
.
uses_start
&
mut
bounds
.
uses_len
&
collector
.
reg_vecs
.
mods
bounds
.
mods_start
bounds
.
mods_len
)
;
}
if
bounds
.
defs_len
>
0
{
remove_mods_from_group
(
&
mut
collector
.
reg_vecs
.
defs
bounds
.
defs_start
&
mut
bounds
.
defs_len
&
collector
.
reg_vecs
.
mods
bounds
.
mods_start
bounds
.
mods_len
)
;
}
}
}
#
[
inline
(
never
)
]
fn
sanitize_should_retain_reg
(
reg_universe
:
&
RealRegUniverse
reg
:
Reg
reg_is_defd
:
bool
)
-
>
Result
<
bool
RealReg
>
{
if
reg
.
is_virtual
(
)
{
return
Ok
(
true
)
;
}
let
rreg_ix
=
reg
.
get_index
(
)
;
if
rreg_ix
>
=
reg_universe
.
regs
.
len
(
)
{
return
Err
(
reg
.
as_real_reg
(
)
.
unwrap
(
)
)
;
}
if
rreg_ix
>
=
reg_universe
.
allocable
{
return
Ok
(
false
)
;
}
for
reg_info
in
&
reg_universe
.
allocable_by_class
{
if
let
Some
(
reg_info
)
=
reg_info
{
if
let
Some
(
scratch_idx
)
=
&
reg_info
.
suggested_scratch
{
let
scratch_reg
=
reg_universe
.
regs
[
*
scratch_idx
]
.
0
;
if
reg
.
to_real_reg
(
)
=
=
scratch_reg
{
if
!
reg_is_defd
{
return
Err
(
reg
.
as_real_reg
(
)
.
unwrap
(
)
)
;
}
}
}
}
}
Ok
(
true
)
}
#
[
inline
(
never
)
]
fn
sanitize_group
(
reg_universe
:
&
RealRegUniverse
regs
:
&
mut
Vec
<
Reg
>
start
:
u32
len
:
&
mut
u8
is_def_group
:
bool
)
-
>
Result
<
(
)
RealReg
>
{
let
mut
wr
=
start
as
usize
;
for
rd
in
start
as
usize
.
.
start
as
usize
+
*
len
as
usize
{
let
reg
=
regs
[
rd
]
;
if
sanitize_should_retain_reg
(
reg_universe
reg
is_def_group
)
?
{
if
wr
!
=
rd
{
regs
[
wr
]
=
reg
;
}
wr
+
=
1
;
}
}
let
new_len_usize
=
wr
-
start
as
usize
;
assert
!
(
new_len_usize
<
=
*
len
as
usize
)
;
*
len
=
new_len_usize
as
u8
;
Ok
(
(
)
)
}
#
[
inline
(
never
)
]
fn
add_san_reg_vecs_for_insn
<
F
:
Function
>
(
inst
:
&
F
:
:
Inst
reg_universe
:
&
RealRegUniverse
reg_vecs
:
&
mut
RegVecs
bounds
:
&
mut
RegVecBounds
)
-
>
Result
<
(
)
RealReg
>
{
add_raw_reg_vecs_for_insn
:
:
<
F
>
(
inst
reg_vecs
bounds
)
;
if
bounds
.
uses_len
>
0
{
sanitize_group
(
&
reg_universe
&
mut
reg_vecs
.
uses
bounds
.
uses_start
&
mut
bounds
.
uses_len
false
)
?
;
}
if
bounds
.
defs_len
>
0
{
sanitize_group
(
&
reg_universe
&
mut
reg_vecs
.
defs
bounds
.
defs_start
&
mut
bounds
.
defs_len
true
)
?
;
}
if
bounds
.
mods_len
>
0
{
sanitize_group
(
&
reg_universe
&
mut
reg_vecs
.
mods
bounds
.
mods_start
&
mut
bounds
.
mods_len
false
)
?
;
}
Ok
(
(
)
)
}
#
[
inline
(
never
)
]
pub
fn
get_sanitized_reg_uses_for_func
<
F
:
Function
>
(
func
:
&
F
reg_universe
:
&
RealRegUniverse
)
-
>
Result
<
RegVecsAndBounds
RealReg
>
{
let
num_insns
=
func
.
insns
(
)
.
len
(
)
;
let
mut
reg_vecs
=
RegVecs
:
:
new
(
false
)
;
let
mut
bounds_vec
=
TypedIxVec
:
:
<
InstIx
RegVecBounds
>
:
:
new
(
)
;
bounds_vec
.
reserve
(
num_insns
)
;
for
insn
in
func
.
insns
(
)
{
let
mut
bounds
=
RegVecBounds
:
:
new
(
)
;
add_san_reg_vecs_for_insn
:
:
<
F
>
(
insn
&
reg_universe
&
mut
reg_vecs
&
mut
bounds
)
?
;
bounds_vec
.
push
(
bounds
)
;
}
assert
!
(
!
reg_vecs
.
is_sanitized
(
)
)
;
reg_vecs
.
set_sanitized
(
true
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
let
show_reg
=
|
r
:
Reg
|
{
if
r
.
is_real
(
)
{
reg_universe
.
regs
[
r
.
get_index
(
)
]
.
1
.
clone
(
)
}
else
{
format
!
(
"
{
:
?
}
"
r
)
.
to_string
(
)
}
}
;
let
show_regs
=
|
r_vec
:
&
[
Reg
]
|
{
let
mut
s
=
"
"
.
to_string
(
)
;
for
r
in
r_vec
{
s
=
s
+
&
show_reg
(
*
r
)
+
&
"
"
.
to_string
(
)
;
}
s
}
;
for
i
in
0
.
.
bounds_vec
.
len
(
)
{
let
iix
=
InstIx
:
:
new
(
i
)
;
let
s_use
=
show_regs
(
&
reg_vecs
.
uses
[
bounds_vec
[
iix
]
.
uses_start
as
usize
.
.
bounds_vec
[
iix
]
.
uses_start
as
usize
+
bounds_vec
[
iix
]
.
uses_len
as
usize
]
)
;
let
s_mod
=
show_regs
(
&
reg_vecs
.
mods
[
bounds_vec
[
iix
]
.
mods_start
as
usize
.
.
bounds_vec
[
iix
]
.
mods_start
as
usize
+
bounds_vec
[
iix
]
.
mods_len
as
usize
]
)
;
let
s_def
=
show_regs
(
&
reg_vecs
.
defs
[
bounds_vec
[
iix
]
.
defs_start
as
usize
.
.
bounds_vec
[
iix
]
.
defs_start
as
usize
+
bounds_vec
[
iix
]
.
defs_len
as
usize
]
)
;
debug
!
(
"
{
:
?
}
SAN_RU
:
use
{
{
{
}
}
}
mod
{
{
{
}
}
}
def
{
{
{
}
}
}
"
iix
s_use
s_mod
s_def
)
;
}
}
Ok
(
RegVecsAndBounds
:
:
new
(
reg_vecs
bounds_vec
)
)
}
#
[
inline
(
never
)
]
pub
fn
does_inst_use_def_or_mod_reg
(
rvb
:
&
RegVecsAndBounds
iix
:
InstIx
reg
:
Reg
)
-
>
(
bool
bool
bool
)
{
let
bounds
=
&
rvb
.
bounds
[
iix
]
;
let
vecs
=
&
rvb
.
vecs
;
let
mut
uses
=
false
;
let
mut
defs
=
false
;
let
mut
mods
=
false
;
for
i
in
bounds
.
uses_start
as
usize
.
.
bounds
.
uses_start
as
usize
+
bounds
.
uses_len
as
usize
{
if
vecs
.
uses
[
i
]
=
=
reg
{
uses
=
true
;
break
;
}
}
for
i
in
bounds
.
defs_start
as
usize
.
.
bounds
.
defs_start
as
usize
+
bounds
.
defs_len
as
usize
{
if
vecs
.
defs
[
i
]
=
=
reg
{
defs
=
true
;
break
;
}
}
for
i
in
bounds
.
mods_start
as
usize
.
.
bounds
.
mods_start
as
usize
+
bounds
.
mods_len
as
usize
{
if
vecs
.
mods
[
i
]
=
=
reg
{
mods
=
true
;
break
;
}
}
(
uses
defs
mods
)
}
#
[
allow
(
dead_code
)
]
#
[
inline
(
never
)
]
pub
fn
get_raw_reg_sets_for_insn
<
F
:
Function
>
(
inst
:
&
F
:
:
Inst
)
-
>
RegSets
{
let
mut
reg_vecs
=
RegVecs
:
:
new
(
false
)
;
let
mut
bounds
=
RegVecBounds
:
:
new
(
)
;
add_raw_reg_vecs_for_insn
:
:
<
F
>
(
inst
&
mut
reg_vecs
&
mut
bounds
)
;
let
mut
single_insn_bounds
=
TypedIxVec
:
:
<
InstIx
RegVecBounds
>
:
:
new
(
)
;
single_insn_bounds
.
push
(
bounds
)
;
assert
!
(
!
reg_vecs
.
is_sanitized
(
)
)
;
let
single_insn_rvb
=
RegVecsAndBounds
:
:
new
(
reg_vecs
single_insn_bounds
)
;
single_insn_rvb
.
get_reg_sets_for_iix
(
InstIx
:
:
new
(
0
)
)
}
#
[
inline
(
never
)
]
pub
fn
get_san_reg_sets_for_insn
<
F
:
Function
>
(
inst
:
&
F
:
:
Inst
reg_universe
:
&
RealRegUniverse
)
-
>
Result
<
RegSets
RealReg
>
{
let
mut
reg_vecs
=
RegVecs
:
:
new
(
false
)
;
let
mut
bounds
=
RegVecBounds
:
:
new
(
)
;
add_san_reg_vecs_for_insn
:
:
<
F
>
(
inst
&
reg_universe
&
mut
reg_vecs
&
mut
bounds
)
?
;
let
mut
single_insn_bounds
=
TypedIxVec
:
:
<
InstIx
RegVecBounds
>
:
:
new
(
)
;
single_insn_bounds
.
push
(
bounds
)
;
assert
!
(
!
reg_vecs
.
is_sanitized
(
)
)
;
reg_vecs
.
set_sanitized
(
true
)
;
let
single_insn_rvb
=
RegVecsAndBounds
:
:
new
(
reg_vecs
single_insn_bounds
)
;
Ok
(
single_insn_rvb
.
get_reg_sets_for_iix
(
InstIx
:
:
new
(
0
)
)
)
}
#
[
inline
(
never
)
]
pub
fn
calc_def_and_use
<
F
:
Function
>
(
func
:
&
F
rvb
:
&
RegVecsAndBounds
univ
:
&
RealRegUniverse
)
-
>
(
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
)
{
info
!
(
"
calc_def_and_use
:
begin
"
)
;
assert
!
(
rvb
.
is_sanitized
(
)
)
;
let
mut
def_sets
=
TypedIxVec
:
:
new
(
)
;
let
mut
use_sets
=
TypedIxVec
:
:
new
(
)
;
for
b
in
func
.
blocks
(
)
{
let
mut
def
=
SparseSet
:
:
empty
(
)
;
let
mut
uce
=
SparseSet
:
:
empty
(
)
;
for
iix
in
func
.
block_insns
(
b
)
{
let
bounds_for_iix
=
&
rvb
.
bounds
[
iix
]
;
for
i
in
bounds_for_iix
.
uses_start
as
usize
.
.
bounds_for_iix
.
uses_start
as
usize
+
bounds_for_iix
.
uses_len
as
usize
{
let
u
=
rvb
.
vecs
.
uses
[
i
]
;
if
!
def
.
contains
(
u
)
{
uce
.
insert
(
u
)
;
}
}
for
i
in
bounds_for_iix
.
mods_start
as
usize
.
.
bounds_for_iix
.
mods_start
as
usize
+
bounds_for_iix
.
mods_len
as
usize
{
let
m
=
rvb
.
vecs
.
mods
[
i
]
;
if
!
def
.
contains
(
m
)
{
uce
.
insert
(
m
)
;
}
}
for
i
in
bounds_for_iix
.
defs_start
as
usize
.
.
bounds_for_iix
.
defs_start
as
usize
+
bounds_for_iix
.
defs_len
as
usize
{
let
d
=
rvb
.
vecs
.
defs
[
i
]
;
def
.
insert
(
d
)
;
}
for
i
in
bounds_for_iix
.
mods_start
as
usize
.
.
bounds_for_iix
.
mods_start
as
usize
+
bounds_for_iix
.
mods_len
as
usize
{
let
m
=
rvb
.
vecs
.
mods
[
i
]
;
def
.
insert
(
m
)
;
}
}
def_sets
.
push
(
def
)
;
use_sets
.
push
(
uce
)
;
}
assert
!
(
def_sets
.
len
(
)
=
=
use_sets
.
len
(
)
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
let
mut
n
=
0
;
debug
!
(
"
"
)
;
for
(
def_set
use_set
)
in
def_sets
.
iter
(
)
.
zip
(
use_sets
.
iter
(
)
)
{
let
mut
first
=
true
;
let
mut
defs_str
=
"
"
.
to_string
(
)
;
for
def
in
def_set
.
to_vec
(
)
{
if
!
first
{
defs_str
=
defs_str
+
&
"
"
.
to_string
(
)
;
}
first
=
false
;
defs_str
=
defs_str
+
&
def
.
show_with_rru
(
univ
)
;
}
first
=
true
;
let
mut
uses_str
=
"
"
.
to_string
(
)
;
for
uce
in
use_set
.
to_vec
(
)
{
if
!
first
{
uses_str
=
uses_str
+
&
"
"
.
to_string
(
)
;
}
first
=
false
;
uses_str
=
uses_str
+
&
uce
.
show_with_rru
(
univ
)
;
}
debug
!
(
"
{
:
<
3
?
}
def
{
{
{
}
}
}
use
{
{
{
}
}
}
"
BlockIx
:
:
new
(
n
)
defs_str
uses_str
)
;
n
+
=
1
;
}
}
info
!
(
"
calc_def_and_use
:
end
"
)
;
(
def_sets
use_sets
)
}
#
[
inline
(
never
)
]
pub
fn
calc_livein_and_liveout
<
F
:
Function
>
(
func
:
&
F
def_sets_per_block
:
&
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
use_sets_per_block
:
&
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
cfg_info
:
&
CFGInfo
univ
:
&
RealRegUniverse
)
-
>
(
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
)
{
info
!
(
"
calc_livein_and_liveout
:
begin
"
)
;
let
num_blocks
=
func
.
blocks
(
)
.
len
(
)
as
u32
;
let
empty
=
SparseSet
:
:
<
Reg
>
:
:
empty
(
)
;
let
mut
num_evals
=
0
;
let
mut
liveouts
=
TypedIxVec
:
:
<
BlockIx
SparseSet
<
Reg
>
>
:
:
new
(
)
;
liveouts
.
resize
(
num_blocks
empty
.
clone
(
)
)
;
let
mut
work_queue
=
Queue
:
:
<
BlockIx
>
:
:
new
(
)
;
for
i
in
0
.
.
num_blocks
{
let
block_ix
=
cfg_info
.
pre_ord
[
(
num_blocks
-
1
-
i
)
as
usize
]
;
work_queue
.
push_back
(
block_ix
)
;
}
let
mut
in_queue
=
Vec
:
:
<
bool
>
:
:
new
(
)
;
in_queue
.
resize
(
num_blocks
as
usize
true
)
;
while
let
Some
(
block_ix
)
=
work_queue
.
pop_front
(
)
{
let
i
=
block_ix
.
get
(
)
as
usize
;
assert
!
(
in_queue
[
i
]
)
;
in_queue
[
i
]
=
false
;
let
mut
set
=
SparseSet
:
:
<
Reg
>
:
:
empty
(
)
;
for
block_j_ix
in
cfg_info
.
succ_map
[
block_ix
]
.
iter
(
)
{
let
mut
live_in_j
=
liveouts
[
*
block_j_ix
]
.
clone
(
)
;
live_in_j
.
remove
(
&
def_sets_per_block
[
*
block_j_ix
]
)
;
live_in_j
.
union
(
&
use_sets_per_block
[
*
block_j_ix
]
)
;
set
.
union
(
&
live_in_j
)
;
}
num_evals
+
=
1
;
if
!
set
.
equals
(
&
liveouts
[
block_ix
]
)
{
liveouts
[
block_ix
]
=
set
;
for
block_j_ix
in
cfg_info
.
pred_map
[
block_ix
]
.
iter
(
)
{
let
j
=
block_j_ix
.
get
(
)
as
usize
;
if
!
in_queue
[
j
]
{
work_queue
.
push_back
(
*
block_j_ix
)
;
in_queue
[
j
]
=
true
;
}
}
}
}
let
mut
liveins
=
TypedIxVec
:
:
<
BlockIx
SparseSet
<
Reg
>
>
:
:
new
(
)
;
liveins
.
resize
(
num_blocks
empty
.
clone
(
)
)
;
for
block_ix
in
BlockIx
:
:
new
(
0
)
.
dotdot
(
BlockIx
:
:
new
(
num_blocks
)
)
{
let
mut
live_in
=
liveouts
[
block_ix
]
.
clone
(
)
;
live_in
.
remove
(
&
def_sets_per_block
[
block_ix
]
)
;
live_in
.
union
(
&
use_sets_per_block
[
block_ix
]
)
;
liveins
[
block_ix
]
=
live_in
;
}
if
false
{
let
mut
sum_card_live_in
=
0
;
let
mut
sum_card_live_out
=
0
;
for
bix
in
BlockIx
:
:
new
(
0
)
.
dotdot
(
BlockIx
:
:
new
(
num_blocks
)
)
{
sum_card_live_in
+
=
liveins
[
bix
]
.
card
(
)
;
sum_card_live_out
+
=
liveouts
[
bix
]
.
card
(
)
;
}
println
!
(
"
QQQQ
calc_LI
/
LO
:
num_evals
{
}
tot
LI
{
}
tot
LO
{
}
"
num_evals
sum_card_live_in
sum_card_live_out
)
;
}
let
ratio
:
f32
=
(
num_evals
as
f32
)
/
(
(
if
num_blocks
=
=
0
{
1
}
else
{
num_blocks
}
)
as
f32
)
;
info
!
(
"
calc_livein_and_liveout
:
{
}
blocks
{
}
evals
(
{
:
<
.
2
}
per
block
)
"
num_blocks
num_evals
ratio
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
let
mut
n
=
0
;
debug
!
(
"
"
)
;
for
(
livein
liveout
)
in
liveins
.
iter
(
)
.
zip
(
liveouts
.
iter
(
)
)
{
let
mut
first
=
true
;
let
mut
li_str
=
"
"
.
to_string
(
)
;
for
li
in
livein
.
to_vec
(
)
{
if
!
first
{
li_str
=
li_str
+
&
"
"
.
to_string
(
)
;
}
first
=
false
;
li_str
=
li_str
+
&
li
.
show_with_rru
(
univ
)
;
}
first
=
true
;
let
mut
lo_str
=
"
"
.
to_string
(
)
;
for
lo
in
liveout
.
to_vec
(
)
{
if
!
first
{
lo_str
=
lo_str
+
&
"
"
.
to_string
(
)
;
}
first
=
false
;
lo_str
=
lo_str
+
&
lo
.
show_with_rru
(
univ
)
;
}
debug
!
(
"
{
:
<
3
?
}
livein
{
{
{
}
}
}
liveout
{
{
{
}
}
}
"
BlockIx
:
:
new
(
n
)
li_str
lo_str
)
;
n
+
=
1
;
}
}
info
!
(
"
calc_livein_and_liveout
:
end
"
)
;
(
liveins
liveouts
)
}
#
[
inline
(
never
)
]
fn
get_range_frags_for_block
<
F
:
Function
>
(
func
:
&
F
bix
:
BlockIx
livein
:
&
SparseSet
<
Reg
>
liveout
:
&
SparseSet
<
Reg
>
rvb
:
&
RegVecsAndBounds
out_map
:
&
mut
Map
<
Reg
Vec
<
RangeFragIx
>
>
out_frags
:
&
mut
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
struct
ProtoRangeFrag
{
first
:
InstPoint
last
:
InstPoint
uses
:
u16
}
impl
fmt
:
:
Debug
for
ProtoRangeFrag
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
:
?
}
x
{
:
?
}
-
{
:
?
}
"
self
.
uses
self
.
first
self
.
last
)
}
}
fn
plus1
(
n
:
u16
)
-
>
u16
{
if
n
=
=
0xFFFFu16
{
n
}
else
{
n
+
1
}
}
debug_assert
!
(
func
.
block_insns
(
bix
)
.
len
(
)
>
=
1
)
;
let
first_iix_in_block
=
func
.
block_insns
(
bix
)
.
first
(
)
;
let
last_iix_in_block
=
func
.
block_insns
(
bix
)
.
last
(
)
;
let
first_pt_in_block
=
InstPoint
:
:
new_use
(
first_iix_in_block
)
;
let
last_pt_in_block
=
InstPoint
:
:
new_def
(
last_iix_in_block
)
;
let
mut
state
=
Map
:
:
<
Reg
ProtoRangeFrag
>
:
:
default
(
)
;
let
mut
tmp_result_vec
=
SmallVec
:
:
<
[
(
Reg
RangeFrag
)
;
32
]
>
:
:
new
(
)
;
for
r
in
livein
.
iter
(
)
{
state
.
insert
(
*
r
ProtoRangeFrag
{
uses
:
0
first
:
first_pt_in_block
last
:
first_pt_in_block
}
)
;
}
for
iix
in
func
.
block_insns
(
bix
)
{
let
bounds_for_iix
=
&
rvb
.
bounds
[
iix
]
;
for
i
in
bounds_for_iix
.
uses_start
as
usize
.
.
bounds_for_iix
.
uses_start
as
usize
+
bounds_for_iix
.
uses_len
as
usize
{
let
r
=
&
rvb
.
vecs
.
uses
[
i
]
;
let
new_pf
:
ProtoRangeFrag
;
match
state
.
get
(
r
)
{
None
=
>
{
panic
!
(
"
get_range_frags_for_block
:
fail
#
1
"
)
;
}
Some
(
ProtoRangeFrag
{
uses
first
last
}
)
=
>
{
let
new_last
=
InstPoint
:
:
new_use
(
iix
)
;
debug_assert
!
(
last
<
=
&
new_last
)
;
new_pf
=
ProtoRangeFrag
{
uses
:
plus1
(
*
uses
)
first
:
*
first
last
:
new_last
}
;
}
}
state
.
insert
(
*
r
new_pf
)
;
}
for
i
in
bounds_for_iix
.
mods_start
as
usize
.
.
bounds_for_iix
.
mods_start
as
usize
+
bounds_for_iix
.
mods_len
as
usize
{
let
r
=
&
rvb
.
vecs
.
mods
[
i
]
;
let
new_pf
:
ProtoRangeFrag
;
match
state
.
get
(
r
)
{
None
=
>
{
panic
!
(
"
get_range_frags_for_block
:
fail
#
2
"
)
;
}
Some
(
ProtoRangeFrag
{
uses
first
last
}
)
=
>
{
let
new_last
=
InstPoint
:
:
new_def
(
iix
)
;
debug_assert
!
(
last
<
=
&
new_last
)
;
new_pf
=
ProtoRangeFrag
{
uses
:
plus1
(
*
uses
)
first
:
*
first
last
:
new_last
}
;
}
}
state
.
insert
(
*
r
new_pf
)
;
}
for
i
in
bounds_for_iix
.
defs_start
as
usize
.
.
bounds_for_iix
.
defs_start
as
usize
+
bounds_for_iix
.
defs_len
as
usize
{
let
r
=
&
rvb
.
vecs
.
defs
[
i
]
;
let
new_pf
:
ProtoRangeFrag
;
match
state
.
get
(
r
)
{
None
=
>
{
let
new_pt
=
InstPoint
:
:
new_def
(
iix
)
;
new_pf
=
ProtoRangeFrag
{
uses
:
1
first
:
new_pt
last
:
new_pt
}
;
}
Some
(
ProtoRangeFrag
{
uses
first
last
}
)
=
>
{
if
first
=
=
last
{
debug_assert
!
(
*
uses
=
=
1
)
;
}
let
frag
=
RangeFrag
:
:
new
(
func
bix
*
first
*
last
*
uses
)
;
tmp_result_vec
.
push
(
(
*
r
frag
)
)
;
let
new_pt
=
InstPoint
:
:
new_def
(
iix
)
;
new_pf
=
ProtoRangeFrag
{
uses
:
1
first
:
new_pt
last
:
new_pt
}
;
}
}
state
.
insert
(
*
r
new_pf
)
;
}
}
for
r
in
liveout
.
iter
(
)
{
match
state
.
get
(
r
)
{
None
=
>
{
panic
!
(
"
get_range_frags_for_block
:
fail
#
3
"
)
;
}
Some
(
ProtoRangeFrag
{
uses
first
last
:
_
}
)
=
>
{
let
frag
=
RangeFrag
:
:
new
(
func
bix
*
first
last_pt_in_block
*
uses
)
;
tmp_result_vec
.
push
(
(
*
r
frag
)
)
;
}
}
state
.
remove
(
r
)
;
}
for
(
r
pf
)
in
state
.
iter
(
)
{
if
pf
.
first
=
=
pf
.
last
{
debug_assert
!
(
pf
.
uses
=
=
1
)
;
}
let
frag
=
RangeFrag
:
:
new
(
func
bix
pf
.
first
pf
.
last
pf
.
uses
)
;
tmp_result_vec
.
push
(
(
*
r
frag
)
)
;
}
for
(
r
frag
)
in
tmp_result_vec
{
let
num_out_frags
=
out_frags
.
len
(
)
;
let
new_fix
:
RangeFragIx
;
if
num_out_frags
>
=
2
{
let
back_0
=
RangeFragIx
:
:
new
(
num_out_frags
-
1
)
;
let
back_1
=
RangeFragIx
:
:
new
(
num_out_frags
-
2
)
;
if
out_frags
[
back_0
]
=
=
frag
{
new_fix
=
back_0
;
}
else
if
out_frags
[
back_1
]
=
=
frag
{
new_fix
=
back_1
;
}
else
{
out_frags
.
push
(
frag
)
;
new_fix
=
RangeFragIx
:
:
new
(
out_frags
.
len
(
)
as
u32
-
1
)
;
}
}
else
{
out_frags
.
push
(
frag
)
;
new_fix
=
RangeFragIx
:
:
new
(
out_frags
.
len
(
)
as
u32
-
1
)
;
}
match
out_map
.
get_mut
(
&
r
)
{
None
=
>
{
out_map
.
insert
(
r
vec
!
[
new_fix
]
)
;
}
Some
(
frag_vec
)
=
>
{
frag_vec
.
push
(
new_fix
)
;
}
}
}
}
#
[
inline
(
never
)
]
pub
fn
get_range_frags
<
F
:
Function
>
(
func
:
&
F
livein_sets_per_block
:
&
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
liveout_sets_per_block
:
&
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
rvb
:
&
RegVecsAndBounds
univ
:
&
RealRegUniverse
)
-
>
(
Map
<
Reg
Vec
<
RangeFragIx
>
>
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
info
!
(
"
get_range_frags
:
begin
"
)
;
assert
!
(
livein_sets_per_block
.
len
(
)
=
=
func
.
blocks
(
)
.
len
(
)
as
u32
)
;
assert
!
(
liveout_sets_per_block
.
len
(
)
=
=
func
.
blocks
(
)
.
len
(
)
as
u32
)
;
assert
!
(
rvb
.
is_sanitized
(
)
)
;
let
mut
result_map
=
Map
:
:
<
Reg
Vec
<
RangeFragIx
>
>
:
:
default
(
)
;
let
mut
result_frags
=
TypedIxVec
:
:
<
RangeFragIx
RangeFrag
>
:
:
new
(
)
;
for
bix
in
func
.
blocks
(
)
{
get_range_frags_for_block
(
func
bix
&
livein_sets_per_block
[
bix
]
&
liveout_sets_per_block
[
bix
]
&
rvb
&
mut
result_map
&
mut
result_frags
)
;
}
debug
!
(
"
"
)
;
let
mut
n
=
0
;
for
frag
in
result_frags
.
iter
(
)
{
debug
!
(
"
{
:
<
3
?
}
{
:
?
}
"
RangeFragIx
:
:
new
(
n
)
frag
)
;
n
+
=
1
;
}
debug
!
(
"
"
)
;
for
(
reg
frag_ixs
)
in
result_map
.
iter
(
)
{
debug
!
(
"
frags
for
{
}
{
:
?
}
"
reg
.
show_with_rru
(
univ
)
frag_ixs
)
;
}
info
!
(
"
get_range_frags
:
end
"
)
;
(
result_map
result_frags
)
}
#
[
inline
(
never
)
]
fn
merge_range_frags_slow
(
frag_ix_vec_per_reg
:
&
Map
<
Reg
Vec
<
RangeFragIx
>
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
cfg_info
:
&
CFGInfo
)
-
>
(
TypedIxVec
<
RealRangeIx
RealRange
>
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
let
mut
n_total_incoming_frags
=
0
;
for
(
_reg
all_frag_ixs_for_reg
)
in
frag_ix_vec_per_reg
.
iter
(
)
{
n_total_incoming_frags
+
=
all_frag_ixs_for_reg
.
len
(
)
;
}
info
!
(
"
merge_range_frags_slow
:
begin
"
)
;
info
!
(
"
in
:
{
}
in
frag_env
"
frag_env
.
len
(
)
)
;
info
!
(
"
in
:
{
}
regs
containing
in
total
{
}
frags
"
frag_ix_vec_per_reg
.
len
(
)
n_total_incoming_frags
)
;
let
mut
result_real
=
TypedIxVec
:
:
<
RealRangeIx
RealRange
>
:
:
new
(
)
;
let
mut
result_virtual
=
TypedIxVec
:
:
<
VirtualRangeIx
VirtualRange
>
:
:
new
(
)
;
for
(
reg
all_frag_ixs_for_reg
)
in
frag_ix_vec_per_reg
.
iter
(
)
{
let
n_for_this_reg
=
all_frag_ixs_for_reg
.
len
(
)
;
assert
!
(
n_for_this_reg
>
0
)
;
struct
MergeGroup
{
valid
:
bool
frag_ixs
:
Set
<
RangeFragIx
>
live_in_blocks
:
Set
<
BlockIx
>
succs_of_live_out_blocks
:
Set
<
BlockIx
>
}
let
mut
state
=
Vec
:
:
<
MergeGroup
>
:
:
new
(
)
;
for
fix
in
all_frag_ixs_for_reg
{
let
mut
live_in_blocks
=
Set
:
:
<
BlockIx
>
:
:
empty
(
)
;
let
mut
succs_of_live_out_blocks
=
Set
:
:
<
BlockIx
>
:
:
empty
(
)
;
let
frag
=
&
frag_env
[
*
fix
]
;
let
frag_bix
=
frag
.
bix
;
let
frag_succ_bixes
=
&
cfg_info
.
succ_map
[
frag_bix
]
;
match
frag
.
kind
{
RangeFragKind
:
:
Local
=
>
{
}
RangeFragKind
:
:
LiveIn
=
>
{
live_in_blocks
.
insert
(
frag_bix
)
;
}
RangeFragKind
:
:
LiveOut
=
>
{
for
bix
in
frag_succ_bixes
.
iter
(
)
{
succs_of_live_out_blocks
.
insert
(
*
bix
)
;
}
}
RangeFragKind
:
:
Thru
=
>
{
live_in_blocks
.
insert
(
frag_bix
)
;
for
bix
in
frag_succ_bixes
.
iter
(
)
{
succs_of_live_out_blocks
.
insert
(
*
bix
)
;
}
}
RangeFragKind
:
:
Multi
=
>
panic
!
(
"
merge_range_frags_slow
:
unexpected
Multi
"
)
}
let
valid
=
true
;
let
frag_ixs
=
Set
:
:
unit
(
*
fix
)
;
let
mg
=
MergeGroup
{
valid
frag_ixs
live_in_blocks
succs_of_live_out_blocks
}
;
state
.
push
(
mg
)
;
}
let
state_len
=
state
.
len
(
)
;
loop
{
let
mut
changed
=
false
;
for
i
in
0
.
.
state_len
{
if
!
state
[
i
]
.
valid
{
continue
;
}
for
j
in
i
+
1
.
.
state_len
{
if
!
state
[
j
]
.
valid
{
continue
;
}
let
do_merge
=
state
[
i
]
.
succs_of_live_out_blocks
.
intersects
(
&
state
[
j
]
.
live_in_blocks
)
|
|
state
[
j
]
.
succs_of_live_out_blocks
.
intersects
(
&
state
[
i
]
.
live_in_blocks
)
;
if
do_merge
{
let
mut
tmp_frag_ixs
=
state
[
i
]
.
frag_ixs
.
clone
(
)
;
state
[
j
]
.
frag_ixs
.
union
(
&
mut
tmp_frag_ixs
)
;
let
tmp_libs
=
state
[
i
]
.
live_in_blocks
.
clone
(
)
;
state
[
j
]
.
live_in_blocks
.
union
(
&
tmp_libs
)
;
let
tmp_solobs
=
state
[
i
]
.
succs_of_live_out_blocks
.
clone
(
)
;
state
[
j
]
.
succs_of_live_out_blocks
.
union
(
&
tmp_solobs
)
;
state
[
i
]
.
valid
=
false
;
changed
=
true
;
}
}
}
if
!
changed
{
break
;
}
}
for
MergeGroup
{
valid
frag_ixs
.
.
}
in
state
{
if
!
valid
{
continue
;
}
let
mut
frag_ixs_sv
=
SmallVec
:
:
<
[
RangeFragIx
;
4
]
>
:
:
new
(
)
;
for
fix
in
frag_ixs
.
iter
(
)
{
frag_ixs_sv
.
push
(
*
fix
)
;
}
let
sorted_frags
=
SortedRangeFragIxs
:
:
new
(
frag_ixs_sv
&
frag_env
)
;
let
size
=
0
;
let
total_cost
=
0
;
let
spill_cost
=
SpillCost
:
:
zero
(
)
;
if
reg
.
is_virtual
(
)
{
result_virtual
.
push
(
VirtualRange
{
vreg
:
reg
.
to_virtual_reg
(
)
rreg
:
None
sorted_frags
size
total_cost
spill_cost
}
)
;
}
else
{
result_real
.
push
(
RealRange
{
rreg
:
reg
.
to_real_reg
(
)
sorted_frags
}
)
;
}
}
}
info
!
(
"
out
:
{
}
VLRs
{
}
RLRs
"
result_virtual
.
len
(
)
result_real
.
len
(
)
)
;
info
!
(
"
merge_range_frags_slow
:
end
"
)
;
(
result_real
result_virtual
)
}
fn
create_and_add_range
(
result_real
:
&
mut
TypedIxVec
<
RealRangeIx
RealRange
>
result_virtual
:
&
mut
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
reg
:
Reg
sorted_frags
:
SortedRangeFragIxs
)
{
let
size
=
0
;
let
total_cost
=
0
;
let
spill_cost
=
SpillCost
:
:
zero
(
)
;
if
reg
.
is_virtual
(
)
{
result_virtual
.
push
(
VirtualRange
{
vreg
:
reg
.
to_virtual_reg
(
)
rreg
:
None
sorted_frags
size
total_cost
spill_cost
}
)
;
}
else
{
result_real
.
push
(
RealRange
{
rreg
:
reg
.
to_real_reg
(
)
sorted_frags
}
)
;
}
}
impl
ToFromU32
for
usize
{
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
to_u32
(
x
:
usize
)
-
>
u32
{
if
x
<
0x1_0000_0000usize
{
x
as
u32
}
else
{
panic
!
(
"
impl
ToFromU32
for
usize
:
to_u32
:
out
of
range
"
)
}
}
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
from_u32
(
x
:
u32
)
-
>
usize
{
x
as
usize
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
to_u32
(
x
:
usize
)
-
>
u32
{
x
as
u32
}
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
fn
from_u32
(
x
:
u32
)
-
>
usize
{
x
as
usize
}
}
#
[
inline
(
never
)
]
pub
fn
merge_range_frags
(
frag_ix_vec_per_reg
:
&
Map
<
Reg
Vec
<
RangeFragIx
>
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
cfg_info
:
&
CFGInfo
)
-
>
(
TypedIxVec
<
RealRangeIx
RealRange
>
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
let
mut
n_total_incoming_frags
=
0
;
for
(
_reg
all_frag_ixs_for_reg
)
in
frag_ix_vec_per_reg
.
iter
(
)
{
n_total_incoming_frags
+
=
all_frag_ixs_for_reg
.
len
(
)
;
}
info
!
(
"
merge_range_frags
:
begin
"
)
;
info
!
(
"
in
:
{
}
in
frag_env
"
frag_env
.
len
(
)
)
;
info
!
(
"
in
:
{
}
regs
containing
in
total
{
}
frags
"
frag_ix_vec_per_reg
.
len
(
)
n_total_incoming_frags
)
;
let
mut
n_single_grps
=
0
;
let
mut
n_local_frags
=
0
;
let
mut
n_multi_grps_small
=
0
;
let
mut
n_multi_grps_large
=
0
;
let
mut
sz_multi_grps_small
=
0
;
let
mut
sz_multi_grps_large
=
0
;
let
mut
result_real
=
TypedIxVec
:
:
<
RealRangeIx
RealRange
>
:
:
new
(
)
;
let
mut
result_virtual
=
TypedIxVec
:
:
<
VirtualRangeIx
VirtualRange
>
:
:
new
(
)
;
'
per_reg_loop
:
for
(
reg
all_frag_ixs_for_reg
)
in
frag_ix_vec_per_reg
.
iter
(
)
{
let
n_frags_for_this_reg
=
all_frag_ixs_for_reg
.
len
(
)
;
assert
!
(
n_frags_for_this_reg
>
0
)
;
if
n_frags_for_this_reg
=
=
1
{
create_and_add_range
(
&
mut
result_real
&
mut
result_virtual
*
reg
SortedRangeFragIxs
:
:
unit
(
all_frag_ixs_for_reg
[
0
]
frag_env
)
)
;
n_single_grps
+
=
1
;
continue
'
per_reg_loop
;
}
let
mut
triples
=
Vec
:
:
<
(
RangeFragIx
RangeFragKind
BlockIx
)
>
:
:
new
(
)
;
'
per_frag_loop
:
for
fix
in
all_frag_ixs_for_reg
{
let
frag
=
&
frag_env
[
*
fix
]
;
if
frag
.
kind
=
=
RangeFragKind
:
:
Local
{
create_and_add_range
(
&
mut
result_real
&
mut
result_virtual
*
reg
SortedRangeFragIxs
:
:
unit
(
*
fix
frag_env
)
)
;
n_local_frags
+
=
1
;
continue
'
per_frag_loop
;
}
assert
!
(
frag
.
kind
!
=
RangeFragKind
:
:
Local
)
;
triples
.
push
(
(
*
fix
frag
.
kind
frag
.
bix
)
)
;
}
let
triples_len
=
triples
.
len
(
)
;
let
mut
eclasses_uf
=
UnionFind
:
:
<
usize
>
:
:
new
(
triples_len
)
;
if
triples_len
<
=
250
{
for
(
(
_fix
kind
bix
)
ix
)
in
triples
.
iter
(
)
.
zip
(
0
.
.
)
{
if
*
kind
=
=
RangeFragKind
:
:
LiveOut
|
|
*
kind
=
=
RangeFragKind
:
:
Thru
{
for
b
in
cfg_info
.
succ_map
[
*
bix
]
.
iter
(
)
{
for
(
(
_fix2
kind2
bix2
)
ix2
)
in
triples
.
iter
(
)
.
zip
(
0
.
.
)
{
if
*
bix2
!
=
*
b
|
|
*
kind2
=
=
RangeFragKind
:
:
LiveOut
{
continue
;
}
if
ix
!
=
ix2
{
eclasses_uf
.
union
(
ix
ix2
)
;
}
}
}
}
}
n_multi_grps_small
+
=
1
;
sz_multi_grps_small
+
=
triples_len
;
}
else
{
triples
.
sort_unstable_by
(
|
(
_
_
bix1
)
(
_
_
bix2
)
|
bix1
.
partial_cmp
(
bix2
)
.
unwrap
(
)
)
;
for
(
(
_fix
kind
bix
)
ix
)
in
triples
.
iter
(
)
.
zip
(
0
.
.
)
{
if
*
kind
=
=
RangeFragKind
:
:
LiveOut
|
|
*
kind
=
=
RangeFragKind
:
:
Thru
{
for
b
in
cfg_info
.
succ_map
[
*
bix
]
.
iter
(
)
{
let
mut
ix_left
=
0
;
let
mut
ix_right
=
triples_len
;
while
ix_left
<
ix_right
{
let
m
=
(
ix_left
+
ix_right
)
>
>
1
;
if
triples
[
m
]
.
2
<
*
b
{
ix_left
=
m
+
1
;
}
else
{
ix_right
=
m
;
}
}
if
ix_left
<
triples_len
&
&
*
b
<
triples
[
ix_left
]
.
2
{
ix_left
=
triples_len
;
}
if
ix_left
<
triples_len
{
assert
!
(
ix_left
=
=
0
|
|
triples
[
ix_left
-
1
]
.
2
<
*
b
)
;
}
let
mut
ix2
=
ix_left
;
'
loop_over_entries_for_b
:
loop
{
if
ix2
>
=
triples_len
{
break
;
}
let
(
_fix2
kind2
bix2
)
=
triples
[
ix2
]
;
if
*
b
<
bix2
{
break
;
}
debug_assert
!
(
*
b
=
=
bix2
)
;
if
kind2
=
=
RangeFragKind
:
:
LiveOut
{
ix2
+
=
1
;
continue
'
loop_over_entries_for_b
;
}
if
ix
!
=
ix2
{
eclasses_uf
.
union
(
ix
ix2
)
;
}
ix2
+
=
1
;
}
if
ix2
+
1
<
triples_len
{
debug_assert
!
(
*
b
<
triples
[
ix2
+
1
]
.
2
)
;
}
}
}
}
n_multi_grps_large
+
=
1
;
sz_multi_grps_large
+
=
triples_len
;
}
let
eclasses
=
eclasses_uf
.
get_equiv_classes
(
)
;
for
leader_triple_ix
in
eclasses
.
equiv_class_leaders_iter
(
)
{
let
mut
frag_ixs
=
SmallVec
:
:
<
[
RangeFragIx
;
4
]
>
:
:
new
(
)
;
for
triple_ix
in
eclasses
.
equiv_class_elems_iter
(
leader_triple_ix
)
{
frag_ixs
.
push
(
triples
[
triple_ix
]
.
0
)
;
}
let
sorted_frags
=
SortedRangeFragIxs
:
:
new
(
frag_ixs
&
frag_env
)
;
create_and_add_range
(
&
mut
result_real
&
mut
result_virtual
*
reg
sorted_frags
)
;
}
}
info
!
(
"
in
:
{
}
single
groups
"
n_single_grps
)
;
info
!
(
"
in
:
{
}
local
frags
in
multi
groups
"
n_local_frags
)
;
info
!
(
"
in
:
{
}
small
multi
groups
{
}
small
multi
group
total
size
"
n_multi_grps_small
sz_multi_grps_small
)
;
info
!
(
"
in
:
{
}
large
multi
groups
{
}
large
multi
group
total
size
"
n_multi_grps_large
sz_multi_grps_large
)
;
info
!
(
"
out
:
{
}
VLRs
{
}
RLRs
"
result_virtual
.
len
(
)
result_real
.
len
(
)
)
;
info
!
(
"
merge_range_frags
:
end
"
)
;
if
CROSSCHECK_MERGE
{
info
!
(
"
merge_range_frags
:
crosscheck
:
begin
"
)
;
let
(
result_real_ref
result_virtual_ref
)
=
merge_range_frags_slow
(
frag_ix_vec_per_reg
frag_env
cfg_info
)
;
assert
!
(
result_real
.
len
(
)
=
=
result_real_ref
.
len
(
)
)
;
assert
!
(
result_virtual
.
len
(
)
=
=
result_virtual_ref
.
len
(
)
)
;
let
mut
result_real_clone
=
result_real
.
clone
(
)
;
let
mut
result_real_ref_clone
=
result_real_ref
.
clone
(
)
;
result_real_clone
.
sort_by
(
|
x
y
|
RealRange
:
:
cmp_debug_only
(
x
y
)
)
;
result_real_ref_clone
.
sort_by
(
|
x
y
|
RealRange
:
:
cmp_debug_only
(
x
y
)
)
;
for
i
in
0
.
.
result_real
.
len
(
)
{
let
rlrix
=
RealRangeIx
:
:
new
(
i
)
;
assert
!
(
result_real_clone
[
rlrix
]
.
rreg
=
=
result_real_ref_clone
[
rlrix
]
.
rreg
)
;
assert
!
(
result_real_clone
[
rlrix
]
.
sorted_frags
.
frag_ixs
=
=
result_real_ref_clone
[
rlrix
]
.
sorted_frags
.
frag_ixs
)
;
}
let
mut
result_virtual_clone
=
result_virtual
.
clone
(
)
;
let
mut
result_virtual_ref_clone
=
result_virtual_ref
.
clone
(
)
;
result_virtual_clone
.
sort_by
(
|
x
y
|
VirtualRange
:
:
cmp_debug_only
(
x
y
)
)
;
result_virtual_ref_clone
.
sort_by
(
|
x
y
|
VirtualRange
:
:
cmp_debug_only
(
x
y
)
)
;
for
i
in
0
.
.
result_virtual
.
len
(
)
{
let
vlrix
=
VirtualRangeIx
:
:
new
(
i
)
;
assert
!
(
result_virtual_clone
[
vlrix
]
.
vreg
=
=
result_virtual_ref_clone
[
vlrix
]
.
vreg
)
;
assert
!
(
result_virtual_clone
[
vlrix
]
.
rreg
=
=
result_virtual_ref_clone
[
vlrix
]
.
rreg
)
;
assert
!
(
result_virtual_clone
[
vlrix
]
.
sorted_frags
.
frag_ixs
=
=
result_virtual_ref_clone
[
vlrix
]
.
sorted_frags
.
frag_ixs
)
;
assert
!
(
result_virtual_clone
[
vlrix
]
.
size
=
=
result_virtual_ref_clone
[
vlrix
]
.
size
)
;
assert
!
(
result_virtual_clone
[
vlrix
]
.
spill_cost
.
is_zero
(
)
)
;
assert
!
(
result_virtual_ref_clone
[
vlrix
]
.
spill_cost
.
is_zero
(
)
)
;
}
info
!
(
"
merge_range_frags
:
crosscheck
:
end
"
)
;
}
(
result_real
result_virtual
)
}
#
[
inline
(
never
)
]
pub
fn
set_virtual_range_metrics
(
vlrs
:
&
mut
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
fenv
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
estimated_frequency
:
&
TypedIxVec
<
BlockIx
u32
>
)
{
info
!
(
"
set_virtual_range_metrics
:
begin
"
)
;
for
vlr
in
vlrs
.
iter_mut
(
)
{
debug_assert
!
(
vlr
.
size
=
=
0
&
&
vlr
.
total_cost
=
=
0
&
&
vlr
.
spill_cost
.
is_zero
(
)
)
;
debug_assert
!
(
vlr
.
rreg
.
is_none
(
)
)
;
let
mut
tot_size
:
u32
=
0
;
let
mut
tot_cost
:
u32
=
0
;
for
fix
in
&
vlr
.
sorted_frags
.
frag_ixs
{
let
frag
=
&
fenv
[
*
fix
]
;
let
mut
frag_size
:
u32
=
frag
.
last
.
iix
.
get
(
)
-
frag
.
first
.
iix
.
get
(
)
+
1
;
if
frag_size
>
0xFFFF
{
frag_size
=
0xFFFF
;
}
tot_size
+
=
frag_size
;
if
tot_size
>
0xFFFF
{
tot_size
=
0xFFFF
;
}
let
mut
new_tot_cost
:
u64
=
frag
.
count
as
u64
;
new_tot_cost
*
=
estimated_frequency
[
frag
.
bix
]
as
u64
;
new_tot_cost
+
=
tot_cost
as
u64
;
if
new_tot_cost
>
0xFFFF_FFFF
{
new_tot_cost
=
0xFFFF_FFFF
;
}
tot_cost
=
new_tot_cost
as
u32
;
}
debug_assert
!
(
tot_size
<
=
0xFFFF
)
;
vlr
.
size
=
tot_size
as
u16
;
vlr
.
total_cost
=
tot_cost
;
debug_assert
!
(
tot_size
>
=
1
)
;
vlr
.
spill_cost
=
SpillCost
:
:
finite
(
tot_cost
as
f32
/
tot_size
as
f32
)
;
}
info
!
(
"
set_virtual_range_metrics
:
end
"
)
;
}
