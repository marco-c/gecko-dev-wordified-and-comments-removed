#
!
[
allow
(
non_snake_case
)
]
#
!
[
allow
(
non_camel_case_types
)
]
use
log
:
:
{
debug
info
log_enabled
Level
}
;
use
smallvec
:
:
{
smallvec
SmallVec
}
;
use
crate
:
:
data_structures
:
:
{
BlockIx
InstIx
InstPoint
RangeFrag
RangeFragIx
RealRange
RealRangeIx
RealReg
RealRegUniverse
Reg
RegVecsAndBounds
SpillCost
TypedIxVec
VirtualRange
VirtualRangeIx
VirtualReg
}
;
use
crate
:
:
union_find
:
:
{
ToFromU32
UnionFind
UnionFindEquivClasses
}
;
use
crate
:
:
Function
;
#
[
derive
(
Clone
)
]
pub
enum
Hint
{
SameAs
(
VirtualRangeIx
u32
)
Exactly
(
RealReg
u32
)
}
fn
show_hint
(
h
:
&
Hint
univ
:
&
RealRegUniverse
)
-
>
String
{
match
h
{
Hint
:
:
SameAs
(
vlrix
weight
)
=
>
format
!
(
"
(
SameAs
{
:
?
}
weight
=
{
}
)
"
vlrix
weight
)
Hint
:
:
Exactly
(
rreg
weight
)
=
>
format
!
(
"
(
Exactly
{
}
weight
=
{
}
)
"
rreg
.
to_reg
(
)
.
show_with_rru
(
&
univ
)
weight
)
}
}
impl
Hint
{
fn
get_weight
(
&
self
)
-
>
u32
{
match
self
{
Hint
:
:
SameAs
(
_vlrix
weight
)
=
>
*
weight
Hint
:
:
Exactly
(
_rreg
weight
)
=
>
*
weight
}
}
}
impl
ToFromU32
for
VirtualRangeIx
{
fn
to_u32
(
x
:
VirtualRangeIx
)
-
>
u32
{
x
.
get
(
)
}
fn
from_u32
(
x
:
u32
)
-
>
VirtualRangeIx
{
VirtualRangeIx
:
:
new
(
x
)
}
}
#
[
inline
(
never
)
]
pub
fn
do_coalescing_analysis
<
F
:
Function
>
(
func
:
&
F
reg_vecs_and_bounds
:
&
RegVecsAndBounds
rlr_env
:
&
TypedIxVec
<
RealRangeIx
RealRange
>
vlr_env
:
&
mut
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
est_freqs
:
&
TypedIxVec
<
BlockIx
u32
>
univ
:
&
RealRegUniverse
)
-
>
(
TypedIxVec
<
VirtualRangeIx
SmallVec
<
[
Hint
;
8
]
>
>
UnionFindEquivClasses
<
VirtualRangeIx
>
TypedIxVec
<
InstIx
bool
>
Vec
<
SmallVec
<
[
VirtualRangeIx
;
3
]
>
>
)
{
info
!
(
"
"
)
;
info
!
(
"
do_coalescing_analysis
:
begin
"
)
;
let
mut
vreg_to_vlrs_map
=
Vec
:
:
<
SmallVec
<
[
VirtualRangeIx
;
3
]
>
>
:
:
new
(
)
;
for
(
vlr
n
)
in
vlr_env
.
iter
(
)
.
zip
(
0
.
.
)
{
let
vlrix
=
VirtualRangeIx
:
:
new
(
n
)
;
let
vreg
:
VirtualReg
=
vlr
.
vreg
;
let
vreg_ix
=
vreg
.
get_index
(
)
;
while
vreg_to_vlrs_map
.
len
(
)
<
=
vreg_ix
{
vreg_to_vlrs_map
.
push
(
smallvec
!
[
]
)
;
}
vreg_to_vlrs_map
[
vreg_ix
]
.
push
(
vlrix
)
;
}
let
mut
rreg_to_rlrs_map
=
Vec
:
:
<
Vec
<
RealRangeIx
>
>
:
:
new
(
)
;
for
(
rlr
n
)
in
rlr_env
.
iter
(
)
.
zip
(
0
.
.
)
{
let
rlrix
=
RealRangeIx
:
:
new
(
n
)
;
let
rreg
:
RealReg
=
rlr
.
rreg
;
let
rreg_ix
=
rreg
.
get_index
(
)
;
while
rreg_to_rlrs_map
.
len
(
)
<
=
rreg_ix
{
rreg_to_rlrs_map
.
push
(
vec
!
[
]
)
;
}
rreg_to_rlrs_map
[
rreg_ix
]
.
push
(
rlrix
)
;
}
let
doesVRegHaveXXat
=
|
xxIsLastUse
:
bool
vreg
:
VirtualReg
iix
:
InstIx
|
-
>
Option
<
VirtualRangeIx
>
{
let
vreg_no
=
vreg
.
get_index
(
)
;
let
vlrixs
=
&
vreg_to_vlrs_map
[
vreg_no
]
;
for
vlrix
in
vlrixs
{
for
frag
in
&
vlr_env
[
*
vlrix
]
.
sorted_frags
.
frags
{
if
xxIsLastUse
{
if
frag
.
last
=
=
InstPoint
:
:
new_use
(
iix
)
{
return
Some
(
*
vlrix
)
;
}
}
else
{
if
frag
.
first
=
=
InstPoint
:
:
new_def
(
iix
)
{
return
Some
(
*
vlrix
)
;
}
}
}
}
None
}
;
let
doesRRegHaveXXat
=
|
xxIsLastUse
:
bool
rreg
:
RealReg
iix
:
InstIx
|
-
>
Option
<
RealRangeIx
>
{
let
rreg_no
=
rreg
.
get_index
(
)
;
let
rlrixs
=
&
rreg_to_rlrs_map
[
rreg_no
]
;
for
rlrix
in
rlrixs
{
let
frags
=
&
rlr_env
[
*
rlrix
]
.
sorted_frags
;
for
fix
in
&
frags
.
frag_ixs
{
let
frag
=
&
frag_env
[
*
fix
]
;
if
xxIsLastUse
{
if
frag
.
last
=
=
InstPoint
:
:
new_use
(
iix
)
{
return
Some
(
*
rlrix
)
;
}
}
else
{
if
frag
.
first
=
=
InstPoint
:
:
new_def
(
iix
)
{
return
Some
(
*
rlrix
)
;
}
}
}
}
None
}
;
let
mut
connectedByMoves
=
Vec
:
:
<
(
Reg
Reg
InstIx
u32
)
>
:
:
new
(
)
;
for
b
in
func
.
blocks
(
)
{
let
block_eef
=
est_freqs
[
b
]
;
for
iix
in
func
.
block_insns
(
b
)
{
let
insn
=
&
func
.
get_insn
(
iix
)
;
let
im
=
func
.
is_move
(
insn
)
;
match
im
{
None
=
>
{
}
Some
(
(
wreg
reg
)
)
=
>
{
let
iix_bounds
=
&
reg_vecs_and_bounds
.
bounds
[
iix
]
;
assert
!
(
iix_bounds
.
uses_len
<
=
1
)
;
assert
!
(
iix_bounds
.
defs_len
<
=
1
)
;
assert
!
(
iix_bounds
.
mods_len
=
=
0
)
;
if
iix_bounds
.
uses_len
=
=
1
&
&
iix_bounds
.
defs_len
=
=
1
{
let
reg_vecs
=
&
reg_vecs_and_bounds
.
vecs
;
assert
!
(
reg_vecs
.
uses
[
iix_bounds
.
uses_start
as
usize
]
=
=
reg
)
;
assert
!
(
reg_vecs
.
defs
[
iix_bounds
.
defs_start
as
usize
]
=
=
wreg
.
to_reg
(
)
)
;
connectedByMoves
.
push
(
(
wreg
.
to_reg
(
)
reg
iix
block_eef
)
)
;
}
}
}
}
}
let
mut
hints
=
TypedIxVec
:
:
<
VirtualRangeIx
SmallVec
<
[
Hint
;
8
]
>
>
:
:
new
(
)
;
hints
.
resize
(
vlr_env
.
len
(
)
smallvec
!
[
]
)
;
let
mut
is_vv_boundary_move
=
TypedIxVec
:
:
<
InstIx
bool
>
:
:
new
(
)
;
is_vv_boundary_move
.
resize
(
func
.
insns
(
)
.
len
(
)
as
u32
false
)
;
let
mut
vlrEquivClassesUF
=
UnionFind
:
:
<
VirtualRangeIx
>
:
:
new
(
vlr_env
.
len
(
)
as
usize
)
;
let
mut
decVLRcosts
=
Vec
:
:
<
(
VirtualRangeIx
VirtualRangeIx
u32
)
>
:
:
new
(
)
;
for
(
rDst
rSrc
iix
block_eef
)
in
connectedByMoves
{
debug
!
(
"
QQQQ
connectedByMoves
{
:
?
}
{
:
?
}
<
-
{
:
?
}
(
block_eef
{
}
)
"
iix
rDst
rSrc
block_eef
)
;
match
(
rDst
.
is_virtual
(
)
rSrc
.
is_virtual
(
)
)
{
(
true
true
)
=
>
{
let
rSrcV
=
rSrc
.
to_virtual_reg
(
)
;
let
rDstV
=
rDst
.
to_virtual_reg
(
)
;
let
mb_vlrixSrc
=
doesVRegHaveXXat
(
true
rSrcV
iix
)
;
let
mb_vlrixDst
=
doesVRegHaveXXat
(
false
rDstV
iix
)
;
if
mb_vlrixSrc
.
is_some
(
)
&
&
mb_vlrixDst
.
is_some
(
)
{
let
vlrixSrc
=
mb_vlrixSrc
.
unwrap
(
)
;
let
vlrixDst
=
mb_vlrixDst
.
unwrap
(
)
;
if
!
vlr_env
[
vlrixSrc
]
.
overlaps
(
&
vlr_env
[
vlrixDst
]
)
{
hints
[
vlrixSrc
]
.
push
(
Hint
:
:
SameAs
(
vlrixDst
block_eef
)
)
;
hints
[
vlrixDst
]
.
push
(
Hint
:
:
SameAs
(
vlrixSrc
block_eef
)
)
;
vlrEquivClassesUF
.
union
(
vlrixDst
vlrixSrc
)
;
is_vv_boundary_move
[
iix
]
=
true
;
debug
!
(
"
QQQQ
reduce
cost
of
{
:
?
}
and
{
:
?
}
"
vlrixSrc
vlrixDst
)
;
decVLRcosts
.
push
(
(
vlrixSrc
vlrixDst
1
*
block_eef
)
)
;
}
}
}
(
true
false
)
=
>
{
let
rSrcR
=
rSrc
.
to_real_reg
(
)
;
let
rDstV
=
rDst
.
to_virtual_reg
(
)
;
let
mb_rlrSrc
=
doesRRegHaveXXat
(
true
rSrcR
iix
)
;
let
mb_vlrDst
=
doesVRegHaveXXat
(
false
rDstV
iix
)
;
if
mb_rlrSrc
.
is_some
(
)
&
&
mb_vlrDst
.
is_some
(
)
{
let
vlrDst
=
mb_vlrDst
.
unwrap
(
)
;
hints
[
vlrDst
]
.
push
(
Hint
:
:
Exactly
(
rSrcR
block_eef
)
)
;
}
}
(
false
true
)
=
>
{
let
rSrcV
=
rSrc
.
to_virtual_reg
(
)
;
let
rDstR
=
rDst
.
to_real_reg
(
)
;
let
mb_vlrSrc
=
doesVRegHaveXXat
(
true
rSrcV
iix
)
;
let
mb_rlrDst
=
doesRRegHaveXXat
(
false
rDstR
iix
)
;
if
mb_vlrSrc
.
is_some
(
)
&
&
mb_rlrDst
.
is_some
(
)
{
let
vlrSrc
=
mb_vlrSrc
.
unwrap
(
)
;
hints
[
vlrSrc
]
.
push
(
Hint
:
:
Exactly
(
rDstR
block_eef
)
)
;
}
}
(
false
false
)
=
>
{
}
}
}
fn
decrease_vlr_total_cost_by
(
vlr
:
&
mut
VirtualRange
decrease_total_cost_by
:
u32
)
{
if
vlr
.
total_cost
<
decrease_total_cost_by
{
vlr
.
total_cost
=
0
;
}
else
{
vlr
.
total_cost
-
=
decrease_total_cost_by
;
}
if
vlr
.
total_cost
=
=
0
{
vlr
.
spill_cost
=
SpillCost
:
:
finite
(
1
.
0e
-
6
)
;
}
else
{
assert
!
(
vlr
.
size
>
0
)
;
vlr
.
spill_cost
=
SpillCost
:
:
finite
(
vlr
.
total_cost
as
f32
/
vlr
.
size
as
f32
)
;
}
}
for
(
vlrix1
vlrix2
decrease_total_cost_by
)
in
decVLRcosts
{
decrease_vlr_total_cost_by
(
&
mut
vlr_env
[
vlrix1
]
decrease_total_cost_by
)
;
decrease_vlr_total_cost_by
(
&
mut
vlr_env
[
vlrix2
]
decrease_total_cost_by
)
;
}
for
hints_for_one_vlr
in
hints
.
iter_mut
(
)
{
hints_for_one_vlr
.
sort_by
(
|
h1
h2
|
h2
.
get_weight
(
)
.
partial_cmp
(
&
h1
.
get_weight
(
)
)
.
unwrap
(
)
)
;
}
let
vlrEquivClasses
:
UnionFindEquivClasses
<
VirtualRangeIx
>
=
vlrEquivClassesUF
.
get_equiv_classes
(
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
Revised
VLRs
:
"
)
;
let
mut
n
=
0
;
for
vlr
in
vlr_env
.
iter
(
)
{
debug
!
(
"
{
:
<
4
?
}
{
:
?
}
"
VirtualRangeIx
:
:
new
(
n
)
vlr
)
;
n
+
=
1
;
}
debug
!
(
"
Coalescing
hints
:
"
)
;
n
=
0
;
for
hints_for_one_vlr
in
hints
.
iter
(
)
{
let
mut
s
=
"
"
.
to_string
(
)
;
for
hint
in
hints_for_one_vlr
{
s
=
s
+
&
show_hint
(
hint
&
univ
)
+
&
"
"
.
to_string
(
)
;
}
debug
!
(
"
hintsfor
{
:
<
4
?
}
=
{
}
"
VirtualRangeIx
:
:
new
(
n
)
s
)
;
n
+
=
1
;
}
for
n
in
0
.
.
vlr_env
.
len
(
)
{
let
vlrix
=
VirtualRangeIx
:
:
new
(
n
)
;
let
mut
tmpvec
=
vec
!
[
]
;
for
elem
in
vlrEquivClasses
.
equiv_class_elems_iter
(
vlrix
)
{
tmpvec
.
reverse
(
)
;
tmpvec
.
push
(
elem
)
;
}
debug
!
(
"
eclassof
{
:
?
}
=
{
:
?
}
"
vlrix
tmpvec
)
;
}
for
(
b
i
)
in
is_vv_boundary_move
.
iter
(
)
.
zip
(
0
.
.
)
{
if
*
b
{
debug
!
(
"
vv_boundary_move
at
{
:
?
}
"
InstIx
:
:
new
(
i
)
)
;
}
}
}
info
!
(
"
do_coalescing_analysis
:
end
"
)
;
info
!
(
"
"
)
;
(
hints
vlrEquivClasses
is_vv_boundary_move
vreg_to_vlrs_map
)
}
