#
!
[
allow
(
non_snake_case
)
]
#
!
[
allow
(
non_camel_case_types
)
]
use
log
:
:
{
debug
info
log_enabled
Level
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
default
;
use
std
:
:
fmt
;
use
crate
:
:
analysis_data_flow
:
:
{
add_raw_reg_vecs_for_insn
does_inst_use_def_or_mod_reg
}
;
use
crate
:
:
analysis_main
:
:
{
run_analysis
AnalysisInfo
}
;
use
crate
:
:
avl_tree
:
:
{
AVLTree
AVL_NULL
}
;
use
crate
:
:
bt_coalescing_analysis
:
:
{
do_coalescing_analysis
Hint
}
;
use
crate
:
:
bt_commitment_map
:
:
{
CommitmentMap
RangeFragAndRangeId
}
;
use
crate
:
:
bt_spillslot_allocator
:
:
SpillSlotAllocator
;
use
crate
:
:
bt_vlr_priority_queue
:
:
VirtualRangePrioQ
;
use
crate
:
:
data_structures
:
:
{
BlockIx
InstIx
InstPoint
Map
Point
RangeFrag
RangeFragIx
RangeId
RealRange
RealRangeIx
RealReg
RealRegUniverse
Reg
RegClass
RegVecBounds
RegVecs
RegVecsAndBounds
Set
SortedRangeFrags
SpillCost
SpillSlot
TypedIxVec
VirtualRange
VirtualRangeIx
VirtualReg
Writable
}
;
use
crate
:
:
inst_stream
:
:
{
edit_inst_stream
ExtPoint
InstExtPoint
InstToInsert
InstToInsertAndExtPoint
}
;
use
crate
:
:
sparse_set
:
:
SparseSetU
;
use
crate
:
:
union_find
:
:
UnionFindEquivClasses
;
use
crate
:
:
{
AlgorithmWithDefaults
Function
RegAllocError
RegAllocResult
StackmapRequestInfo
}
;
#
[
derive
(
Clone
)
]
pub
struct
BacktrackingOptions
{
pub
request_block_annotations
:
bool
}
impl
default
:
:
Default
for
BacktrackingOptions
{
fn
default
(
)
-
>
Self
{
Self
{
request_block_annotations
:
false
}
}
}
impl
fmt
:
:
Debug
for
BacktrackingOptions
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
backtracking
(
block
annotations
:
{
}
)
"
self
.
request_block_annotations
)
}
}
struct
PerRealReg
{
committed
:
CommitmentMap
vlrixs_assigned
:
Set
<
VirtualRangeIx
>
}
impl
PerRealReg
{
fn
new
(
)
-
>
Self
{
Self
{
committed
:
CommitmentMap
:
:
new
(
)
vlrixs_assigned
:
Set
:
:
<
VirtualRangeIx
>
:
:
empty
(
)
}
}
#
[
inline
(
never
)
]
fn
add_RealRange
(
&
mut
self
to_add_rlrix
:
RealRangeIx
rlr_env
:
&
TypedIxVec
<
RealRangeIx
RealRange
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
let
to_add_rlr
=
&
rlr_env
[
to_add_rlrix
]
;
self
.
committed
.
add_indirect
(
&
to_add_rlr
.
sorted_frags
RangeId
:
:
new_real
(
to_add_rlrix
)
frag_env
)
;
}
#
[
inline
(
never
)
]
fn
add_VirtualRange
(
&
mut
self
to_add_vlrix
:
VirtualRangeIx
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
let
to_add_vlr
=
&
vlr_env
[
to_add_vlrix
]
;
self
.
committed
.
add
(
&
to_add_vlr
.
sorted_frags
RangeId
:
:
new_virtual
(
to_add_vlrix
)
)
;
assert
!
(
!
self
.
vlrixs_assigned
.
contains
(
to_add_vlrix
)
)
;
self
.
vlrixs_assigned
.
insert
(
to_add_vlrix
)
;
}
#
[
inline
(
never
)
]
fn
del_VirtualRange
(
&
mut
self
to_del_vlrix
:
VirtualRangeIx
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
if
self
.
vlrixs_assigned
.
contains
(
to_del_vlrix
)
{
self
.
vlrixs_assigned
.
delete
(
to_del_vlrix
)
;
}
else
{
panic
!
(
"
PerRealReg
:
del_VirtualRange
on
VR
not
in
vlrixs_assigned
"
)
;
}
let
to_del_vlr
=
&
vlr_env
[
to_del_vlrix
]
;
self
.
committed
.
del
(
&
to_del_vlr
.
sorted_frags
)
;
}
}
fn
search_commitment_tree
<
IsAllowedToEvict
>
(
running_set
:
&
mut
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
running_cost
:
&
mut
SpillCost
tree
:
&
AVLTree
<
RangeFragAndRangeId
>
pair_frag
:
&
RangeFrag
spill_cost_budget
:
&
SpillCost
allowed_to_evict
:
&
IsAllowedToEvict
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
-
>
bool
where
IsAllowedToEvict
:
Fn
(
VirtualRangeIx
)
-
>
bool
{
let
mut
stack
=
SmallVec
:
:
<
[
u32
;
32
]
>
:
:
new
(
)
;
assert
!
(
tree
.
root
!
=
AVL_NULL
)
;
stack
.
push
(
tree
.
root
)
;
while
let
Some
(
curr
)
=
stack
.
pop
(
)
{
let
curr_node
=
&
tree
.
pool
[
curr
as
usize
]
;
let
curr_node_item
=
&
curr_node
.
item
;
let
curr_frag
=
&
curr_node_item
.
frag
;
let
overlaps_curr
=
pair_frag
.
last
>
=
curr_frag
.
first
&
&
pair_frag
.
first
<
=
curr_frag
.
last
;
if
overlaps_curr
{
if
curr_node_item
.
id
.
is_real
(
)
{
return
false
;
}
let
vlrix_to_evict
=
curr_node_item
.
id
.
to_virtual
(
)
;
let
vlr_to_evict
=
&
vlr_env
[
vlrix_to_evict
]
;
if
vlr_to_evict
.
spill_cost
.
is_infinite
(
)
{
return
false
;
}
if
!
vlr_to_evict
.
spill_cost
.
is_less_than
(
spill_cost_budget
)
{
return
false
;
}
if
!
allowed_to_evict
(
vlrix_to_evict
)
{
return
false
;
}
if
!
running_set
.
contains
(
vlrix_to_evict
)
{
let
mut
tmp_cost
=
*
running_cost
;
tmp_cost
.
add
(
&
vlr_to_evict
.
spill_cost
)
;
if
!
tmp_cost
.
is_less_than
(
spill_cost_budget
)
{
return
false
;
}
*
running_cost
=
tmp_cost
;
running_set
.
insert
(
vlrix_to_evict
)
;
}
}
let
must_check_left
=
pair_frag
.
first
<
curr_frag
.
first
;
if
must_check_left
{
let
left_of_curr
=
tree
.
pool
[
curr
as
usize
]
.
left
;
if
left_of_curr
!
=
AVL_NULL
{
stack
.
push
(
left_of_curr
)
;
}
}
let
must_check_right
=
pair_frag
.
last
>
curr_frag
.
last
;
if
must_check_right
{
let
right_of_curr
=
tree
.
pool
[
curr
as
usize
]
.
right
;
if
right_of_curr
!
=
AVL_NULL
{
stack
.
push
(
right_of_curr
)
;
}
}
}
assert
!
(
running_cost
.
is_finite
(
)
)
;
assert
!
(
running_cost
.
is_less_than
(
spill_cost_budget
)
)
;
true
}
impl
PerRealReg
{
#
[
inline
(
never
)
]
fn
find_evict_set
<
IsAllowedToEvict
>
(
&
self
would_like_to_add
:
VirtualRangeIx
allowed_to_evict
:
&
IsAllowedToEvict
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
-
>
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
where
IsAllowedToEvict
:
Fn
(
VirtualRangeIx
)
-
>
bool
{
if
self
.
committed
.
tree
.
root
=
=
AVL_NULL
{
let
evict_set
=
SparseSetU
:
:
<
[
VirtualRangeIx
;
4
]
>
:
:
empty
(
)
;
let
evict_cost
=
SpillCost
:
:
zero
(
)
;
return
Some
(
(
evict_set
evict_cost
)
)
;
}
let
would_like_to_add_vlr
=
&
vlr_env
[
would_like_to_add
]
;
let
evict_cost_budget
=
would_like_to_add_vlr
.
spill_cost
;
let
mut
running_set
=
SparseSetU
:
:
<
[
VirtualRangeIx
;
4
]
>
:
:
empty
(
)
;
let
mut
running_cost
=
SpillCost
:
:
zero
(
)
;
for
wlta_frag
in
&
would_like_to_add_vlr
.
sorted_frags
.
frags
{
let
wlta_frag_ok
=
search_commitment_tree
(
&
mut
running_set
&
mut
running_cost
&
self
.
committed
.
tree
&
wlta_frag
&
evict_cost_budget
allowed_to_evict
vlr_env
)
;
if
!
wlta_frag_ok
{
return
None
;
}
}
assert
!
(
running_cost
.
is_finite
(
)
)
;
assert
!
(
running_cost
.
is_less_than
(
&
evict_cost_budget
)
)
;
Some
(
(
running_set
running_cost
)
)
}
#
[
allow
(
dead_code
)
]
#
[
inline
(
never
)
]
fn
show1_with_envs
(
&
self
_frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
String
{
"
(
show1_with_envs
:
FIXME
)
"
.
to_string
(
)
}
#
[
allow
(
dead_code
)
]
#
[
inline
(
never
)
]
fn
show2_with_envs
(
&
self
_frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
String
{
"
(
show2_with_envs
:
FIXME
)
"
.
to_string
(
)
}
}
#
[
inline
(
never
)
]
fn
print_RA_state
(
who
:
&
str
_universe
:
&
RealRegUniverse
prioQ
:
&
VirtualRangePrioQ
_perRealReg
:
&
Vec
<
PerRealReg
>
edit_list_move
:
&
Vec
<
EditListItem
>
edit_list_other
:
&
Vec
<
EditListItem
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
_frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
debug
!
(
"
<
<
<
<
=
=
=
=
-
-
-
-
RA
state
at
'
{
}
'
-
-
-
-
=
=
=
=
"
who
)
;
if
!
prioQ
.
is_empty
(
)
{
for
s
in
prioQ
.
show_with_envs
(
vlr_env
)
{
debug
!
(
"
{
}
"
s
)
;
}
}
for
eli
in
edit_list_move
{
debug
!
(
"
ELI
MOVE
:
{
:
?
}
"
eli
)
;
}
for
eli
in
edit_list_other
{
debug
!
(
"
ELI
other
:
{
:
?
}
"
eli
)
;
}
debug
!
(
"
>
>
>
>
"
)
;
}
fn
get_stackmap_artefacts_at
(
spill_slot_allocator
:
&
mut
SpillSlotAllocator
univ
:
&
RealRegUniverse
reftype_class
:
RegClass
reg_vecs_and_bounds
:
&
RegVecsAndBounds
per_real_reg
:
&
Vec
<
PerRealReg
>
rlr_env
:
&
TypedIxVec
<
RealRangeIx
RealRange
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
iix
:
InstIx
)
-
>
Result
<
(
Vec
<
InstToInsert
>
Vec
<
InstToInsert
>
Vec
<
SpillSlot
>
)
RegAllocError
>
{
let
pt
=
InstPoint
:
:
new_use
(
iix
)
;
let
mut
s_before
=
Set
:
:
<
RealReg
>
:
:
empty
(
)
;
let
rci
=
univ
.
allocable_by_class
[
reftype_class
.
rc_to_usize
(
)
]
;
if
rci
.
is_none
(
)
{
return
Err
(
RegAllocError
:
:
Other
(
"
stackmap
request
:
no
regs
in
specified
reftype
class
"
.
to_string
(
)
)
)
;
}
let
rci
=
rci
.
unwrap
(
)
;
debug
!
(
"
computing
stackmap
info
at
{
:
?
}
"
pt
)
;
for
rreg_no
in
rci
.
first
.
.
rci
.
last
+
1
{
let
mb_range_id
=
per_real_reg
[
rreg_no
]
.
committed
.
lookup_inst_point
(
pt
)
;
if
let
Some
(
range_id
)
=
mb_range_id
{
let
is_ref
=
if
range_id
.
is_real
(
)
{
debug
!
(
"
real
reg
{
:
?
}
is
real
-
range
{
:
?
}
"
rreg_no
rlr_env
[
range_id
.
to_real
(
)
]
)
;
rlr_env
[
range_id
.
to_real
(
)
]
.
is_ref
}
else
{
debug
!
(
"
real
reg
{
:
?
}
is
virtual
-
range
{
:
?
}
"
rreg_no
vlr_env
[
range_id
.
to_virtual
(
)
]
)
;
vlr_env
[
range_id
.
to_virtual
(
)
]
.
is_ref
}
;
if
is_ref
{
let
rreg
=
univ
.
regs
[
rreg_no
]
.
0
;
s_before
.
insert
(
rreg
)
;
}
}
}
debug
!
(
"
Sbefore
=
{
:
?
}
"
s_before
)
;
let
mut
s_after
=
s_before
.
clone
(
)
;
let
bounds
=
&
reg_vecs_and_bounds
.
bounds
[
iix
]
;
if
bounds
.
mods_len
!
=
0
{
return
Err
(
RegAllocError
:
:
Other
(
"
stackmap
request
:
safepoint
insn
modifies
a
reftyped
reg
"
.
to_string
(
)
)
)
;
}
for
i
in
bounds
.
defs_start
.
.
bounds
.
defs_start
+
bounds
.
defs_len
as
u32
{
let
r_defd
=
reg_vecs_and_bounds
.
vecs
.
defs
[
i
as
usize
]
;
if
r_defd
.
is_real
(
)
&
&
r_defd
.
get_class
(
)
=
=
reftype_class
{
s_after
.
delete
(
r_defd
.
to_real_reg
(
)
)
;
}
}
debug
!
(
"
Safter
=
{
:
?
}
"
s_before
)
;
let
frag
=
RangeFrag
:
:
new
(
InstPoint
:
:
new_reload
(
iix
)
InstPoint
:
:
new_spill
(
iix
)
)
;
let
mut
spill_insns
=
Vec
:
:
<
InstToInsert
>
:
:
new
(
)
;
let
mut
where_reg_got_spilled_to
=
Map
:
:
<
RealReg
SpillSlot
>
:
:
default
(
)
;
for
from_reg
in
s_before
.
iter
(
)
{
let
to_slot
=
spill_slot_allocator
.
alloc_reftyped_spillslot_for_frag
(
frag
.
clone
(
)
)
;
let
spill
=
InstToInsert
:
:
Spill
{
to_slot
from_reg
:
*
from_reg
for_vreg
:
None
}
;
spill_insns
.
push
(
spill
)
;
if
s_after
.
contains
(
*
from_reg
)
{
where_reg_got_spilled_to
.
insert
(
*
from_reg
to_slot
)
;
}
}
let
mut
reload_insns
=
Vec
:
:
<
InstToInsert
>
:
:
new
(
)
;
for
(
to_reg
from_slot
)
in
where_reg_got_spilled_to
.
iter
(
)
{
let
reload
=
InstToInsert
:
:
Reload
{
to_reg
:
Writable
:
:
from_reg
(
*
to_reg
)
from_slot
:
*
from_slot
for_vreg
:
None
}
;
reload_insns
.
push
(
reload
)
;
}
let
reftyped_spillslots
=
spill_slot_allocator
.
get_reftyped_spillslots_at_inst_point
(
pt
)
;
debug
!
(
"
reftyped_spillslots
=
{
:
?
}
"
reftyped_spillslots
)
;
Ok
(
(
spill_insns
reload_insns
reftyped_spillslots
)
)
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
(
crate
)
enum
BridgeKind
{
RtoU
RtoS
DtoS
}
impl
fmt
:
:
Debug
for
BridgeKind
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
BridgeKind
:
:
RtoU
=
>
write
!
(
fmt
"
R
-
>
U
"
)
BridgeKind
:
:
RtoS
=
>
write
!
(
fmt
"
R
-
>
S
"
)
BridgeKind
:
:
DtoS
=
>
write
!
(
fmt
"
D
-
>
S
"
)
}
}
}
#
[
derive
(
Clone
Copy
)
]
struct
EditListItem
{
slot
:
SpillSlot
vlrix
:
VirtualRangeIx
kind
:
BridgeKind
iix
:
InstIx
}
impl
fmt
:
:
Debug
for
EditListItem
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
(
ELI
:
at
{
:
?
}
for
{
:
?
}
add
{
:
?
}
slot
=
{
:
?
}
)
"
self
.
iix
self
.
vlrix
self
.
kind
self
.
slot
)
}
}
#
[
inline
(
never
)
]
pub
fn
alloc_main
<
F
:
Function
>
(
func
:
&
mut
F
reg_universe
:
&
RealRegUniverse
stackmap_request
:
Option
<
&
StackmapRequestInfo
>
use_checker
:
bool
opts
:
&
BacktrackingOptions
)
-
>
Result
<
RegAllocResult
<
F
>
RegAllocError
>
{
let
empty_vec_vregs
=
vec
!
[
]
;
let
empty_vec_iixs
=
vec
!
[
]
;
let
(
client_wants_stackmaps
reftype_class
reftyped_vregs
safepoint_insns
)
=
match
stackmap_request
{
Some
(
&
StackmapRequestInfo
{
reftype_class
ref
reftyped_vregs
ref
safepoint_insns
}
)
=
>
(
true
reftype_class
reftyped_vregs
safepoint_insns
)
None
=
>
(
false
RegClass
:
:
INVALID
&
empty_vec_vregs
&
empty_vec_iixs
)
}
;
let
AnalysisInfo
{
reg_vecs_and_bounds
real_ranges
:
rlr_env
virtual_ranges
:
mut
vlr_env
range_frags
:
frag_env
range_metrics
:
frag_metrics_env
estimated_frequencies
:
est_freqs
inst_to_block_map
reg_to_ranges_maps
:
mb_reg_to_ranges_maps
move_info
:
mb_move_info
}
=
run_analysis
(
func
reg_universe
AlgorithmWithDefaults
:
:
Backtracking
client_wants_stackmaps
reftype_class
reftyped_vregs
)
.
map_err
(
|
err
|
RegAllocError
:
:
Analysis
(
err
)
)
?
;
assert
!
(
reg_vecs_and_bounds
.
is_sanitized
(
)
)
;
assert
!
(
frag_env
.
len
(
)
=
=
frag_metrics_env
.
len
(
)
)
;
assert
!
(
mb_reg_to_ranges_maps
.
is_some
(
)
)
;
assert
!
(
mb_move_info
.
is_some
(
)
)
;
let
reg_to_ranges_maps
=
mb_reg_to_ranges_maps
.
unwrap
(
)
;
let
move_info
=
mb_move_info
.
unwrap
(
)
;
let
coalescing_info
=
do_coalescing_analysis
(
func
&
reg_universe
&
rlr_env
&
mut
vlr_env
&
frag_env
&
reg_to_ranges_maps
&
move_info
)
;
let
mut
hints
:
TypedIxVec
<
VirtualRangeIx
SmallVec
<
[
Hint
;
8
]
>
>
=
coalescing_info
.
0
;
let
vlrEquivClasses
:
UnionFindEquivClasses
<
VirtualRangeIx
>
=
coalescing_info
.
1
;
let
is_vv_boundary_move
:
TypedIxVec
<
InstIx
bool
>
=
coalescing_info
.
2
;
assert
!
(
hints
.
len
(
)
=
=
vlr_env
.
len
(
)
)
;
info
!
(
"
alloc_main
:
begin
"
)
;
info
!
(
"
alloc_main
:
in
:
{
}
insns
in
{
}
blocks
"
func
.
insns
(
)
.
len
(
)
func
.
blocks
(
)
.
len
(
)
)
;
let
num_vlrs_initial
=
vlr_env
.
len
(
)
;
info
!
(
"
alloc_main
:
in
:
{
}
VLRs
{
}
RLRs
"
num_vlrs_initial
rlr_env
.
len
(
)
)
;
let
mut
prioQ
=
VirtualRangePrioQ
:
:
new
(
&
vlr_env
)
;
let
mut
per_real_reg
=
Vec
:
:
<
PerRealReg
>
:
:
new
(
)
;
for
_
in
0
.
.
reg_universe
.
allocable
{
per_real_reg
.
push
(
PerRealReg
:
:
new
(
)
)
;
}
for
(
rlrix_no
rlr
)
in
rlr_env
.
iter
(
)
.
enumerate
(
)
{
let
rlrix
=
RealRangeIx
:
:
new
(
rlrix_no
as
u32
)
;
let
rregIndex
=
rlr
.
rreg
.
get_index
(
)
;
if
rregIndex
>
=
reg_universe
.
allocable
{
continue
;
}
per_real_reg
[
rregIndex
]
.
add_RealRange
(
rlrix
&
rlr_env
&
frag_env
)
;
}
let
mut
edit_list_move
=
Vec
:
:
<
EditListItem
>
:
:
new
(
)
;
let
mut
edit_list_other
=
Vec
:
:
<
EditListItem
>
:
:
new
(
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
"
)
;
print_RA_state
(
"
Initial
"
&
reg_universe
&
prioQ
&
per_real_reg
&
edit_list_move
&
edit_list_other
&
vlr_env
&
frag_env
)
;
}
let
mut
vlr_slot_env
=
TypedIxVec
:
:
<
VirtualRangeIx
Option
<
SpillSlot
>
>
:
:
new
(
)
;
vlr_slot_env
.
resize
(
num_vlrs_initial
None
)
;
let
mut
spill_slot_allocator
=
SpillSlotAllocator
:
:
new
(
)
;
debug
!
(
"
"
)
;
debug
!
(
"
-
-
MAIN
ALLOCATION
LOOP
(
DI
means
'
direct
'
CO
means
'
coalesced
'
)
:
"
)
;
info
!
(
"
alloc_main
:
main
allocation
loop
:
begin
"
)
;
let
mut
num_vlrs_processed
=
0
;
let
mut
num_vlrs_spilled
=
0
;
let
mut
num_vlrs_evicted
=
0
;
'
main_allocation_loop
:
loop
{
debug
!
(
"
-
-
still
TODO
{
}
"
prioQ
.
len
(
)
)
;
if
false
{
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
"
)
;
print_RA_state
(
"
Loop
Top
"
&
reg_universe
&
prioQ
&
per_real_reg
&
edit_list_move
&
edit_list_other
&
vlr_env
&
frag_env
)
;
debug
!
(
"
"
)
;
}
}
let
mb_curr_vlrix
=
prioQ
.
get_longest_VirtualRange
(
)
;
if
mb_curr_vlrix
.
is_none
(
)
{
break
'
main_allocation_loop
;
}
num_vlrs_processed
+
=
1
;
let
curr_vlrix
=
mb_curr_vlrix
.
unwrap
(
)
;
let
curr_vlr
=
&
vlr_env
[
curr_vlrix
]
;
debug
!
(
"
-
-
considering
{
:
?
}
:
{
:
?
}
"
curr_vlrix
curr_vlr
)
;
assert
!
(
curr_vlr
.
vreg
.
to_reg
(
)
.
is_virtual
(
)
)
;
assert
!
(
curr_vlr
.
rreg
.
is_none
(
)
)
;
let
curr_vlr_regclass
=
curr_vlr
.
vreg
.
get_class
(
)
;
let
curr_vlr_rc
=
curr_vlr_regclass
.
rc_to_usize
(
)
;
assert
!
(
hints
.
len
(
)
=
=
vlr_env
.
len
(
)
)
;
let
mut
hinted_regs
=
SmallVec
:
:
<
[
RealReg
;
8
]
>
:
:
new
(
)
;
if
curr_vlrix
.
get
(
)
<
hints
.
len
(
)
{
for
hint
in
&
hints
[
curr_vlrix
]
{
let
mb_cand
=
match
hint
{
Hint
:
:
SameAs
(
other_vlrix
_weight
)
=
>
{
vlr_env
[
*
other_vlrix
]
.
rreg
}
Hint
:
:
Exactly
(
rreg
_weight
)
=
>
Some
(
*
rreg
)
}
;
if
let
Some
(
rreg
)
=
mb_cand
{
if
!
hinted_regs
.
iter
(
)
.
any
(
|
r
|
*
r
=
=
rreg
)
{
hinted_regs
.
push
(
rreg
)
;
}
}
}
let
n_primary_cands
=
hinted_regs
.
len
(
)
;
if
curr_vlrix
.
get
(
)
<
num_vlrs_initial
{
for
vlrix
in
vlrEquivClasses
.
equiv_class_elems_iter
(
curr_vlrix
)
{
if
vlrix
!
=
curr_vlrix
{
if
let
Some
(
rreg
)
=
vlr_env
[
vlrix
]
.
rreg
{
if
!
hinted_regs
.
iter
(
)
.
any
(
|
r
|
*
r
=
=
rreg
)
{
hinted_regs
.
push
(
rreg
)
;
}
}
}
}
hinted_regs
[
n_primary_cands
.
.
]
.
sort_by
(
|
rreg1
rreg2
|
{
rreg1
.
get_index
(
)
.
partial_cmp
(
&
rreg2
.
get_index
(
)
)
.
unwrap
(
)
}
)
;
}
if
log_enabled
!
(
Level
:
:
Debug
)
{
if
!
hinted_regs
.
is_empty
(
)
{
let
mut
candStr
=
"
pri
{
"
.
to_string
(
)
;
for
(
rreg
n
)
in
hinted_regs
.
iter
(
)
.
zip
(
0
.
.
)
{
if
n
=
=
n_primary_cands
{
candStr
=
candStr
+
&
"
}
sec
{
"
.
to_string
(
)
;
}
candStr
=
candStr
+
&
"
"
.
to_string
(
)
+
&
reg_universe
.
regs
[
rreg
.
get_index
(
)
]
.
1
;
}
candStr
=
candStr
+
&
"
}
"
;
debug
!
(
"
-
-
CO
candidates
{
}
"
candStr
)
;
}
}
}
for
rreg
in
&
hinted_regs
{
let
rregNo
=
rreg
.
get_index
(
)
;
let
mb_evict_info
:
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
=
per_real_reg
[
rregNo
]
.
find_evict_set
(
curr_vlrix
&
|
vlrix_to_evict
|
{
vlrEquivClasses
.
in_same_equivalence_class
(
vlrix_to_evict
curr_vlrix
)
!
=
Some
(
true
)
}
&
vlr_env
)
;
if
let
Some
(
(
vlrixs_to_evict
total_evict_cost
)
)
=
mb_evict_info
{
assert
!
(
curr_vlr
.
rreg
.
is_none
(
)
)
;
assert
!
(
vlrixs_to_evict
.
is_empty
(
)
=
=
total_evict_cost
.
is_zero
(
)
)
;
assert
!
(
total_evict_cost
.
is_finite
(
)
)
;
assert
!
(
total_evict_cost
.
is_less_than
(
&
curr_vlr
.
spill_cost
)
)
;
for
vlrix_to_evict
in
vlrixs_to_evict
.
iter
(
)
{
assert
!
(
vlrEquivClasses
.
in_same_equivalence_class
(
*
vlrix_to_evict
curr_vlrix
)
!
=
Some
(
true
)
)
;
debug
!
(
"
-
-
CO
evict
{
:
?
}
:
{
:
?
}
"
*
vlrix_to_evict
&
vlr_env
[
*
vlrix_to_evict
]
)
;
per_real_reg
[
rregNo
]
.
del_VirtualRange
(
*
vlrix_to_evict
&
vlr_env
)
;
prioQ
.
add_VirtualRange
(
&
vlr_env
*
vlrix_to_evict
)
;
debug_assert
!
(
vlr_env
[
*
vlrix_to_evict
]
.
rreg
.
is_some
(
)
)
;
vlr_env
[
*
vlrix_to_evict
]
.
rreg
=
None
;
num_vlrs_evicted
+
=
1
;
}
debug
!
(
"
-
-
CO
alloc
to
{
}
"
reg_universe
.
regs
[
rregNo
]
.
1
)
;
per_real_reg
[
rregNo
]
.
add_VirtualRange
(
curr_vlrix
&
vlr_env
)
;
vlr_env
[
curr_vlrix
]
.
rreg
=
Some
(
*
rreg
)
;
continue
'
main_allocation_loop
;
}
}
let
(
first_in_rc
last_in_rc
)
=
match
&
reg_universe
.
allocable_by_class
[
curr_vlr_rc
]
{
&
None
=
>
{
return
Err
(
RegAllocError
:
:
OutOfRegisters
(
curr_vlr_regclass
)
)
;
}
&
Some
(
ref
info
)
=
>
(
info
.
first
info
.
last
)
}
;
let
mut
best_so_far
:
Option
<
(
usize
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
=
None
;
'
search_through_cand_rregs_loop
:
for
rregNo
in
first_in_rc
.
.
last_in_rc
+
1
{
let
mb_evict_info
:
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
=
per_real_reg
[
rregNo
]
.
find_evict_set
(
curr_vlrix
&
|
_vlrix_to_evict
|
true
&
vlr_env
)
;
if
let
Some
(
(
cand_vlrixs_to_evict
cand_total_evict_cost
)
)
=
mb_evict_info
{
assert
!
(
cand_vlrixs_to_evict
.
is_empty
(
)
=
=
cand_total_evict_cost
.
is_zero
(
)
)
;
assert
!
(
cand_total_evict_cost
.
is_finite
(
)
)
;
assert
!
(
cand_total_evict_cost
.
is_less_than
(
&
curr_vlr
.
spill_cost
)
)
;
let
mut
cand_is_better
=
cand_vlrixs_to_evict
.
is_empty
(
)
;
if
!
cand_is_better
{
if
let
Some
(
(
_
_
best_spill_cost
)
)
=
best_so_far
{
if
cand_total_evict_cost
.
is_less_than
(
&
best_spill_cost
)
{
cand_is_better
=
true
;
}
}
else
{
cand_is_better
=
true
;
}
}
let
cand_vlrixs_to_evict_is_empty
=
cand_vlrixs_to_evict
.
is_empty
(
)
;
if
cand_is_better
{
best_so_far
=
Some
(
(
rregNo
cand_vlrixs_to_evict
cand_total_evict_cost
)
)
;
}
if
cand_vlrixs_to_evict_is_empty
{
break
'
search_through_cand_rregs_loop
;
}
}
}
if
let
Some
(
(
rregNo
vlrixs_to_evict
total_spill_cost
)
)
=
best_so_far
{
debug_assert
!
(
curr_vlr
.
rreg
.
is_none
(
)
)
;
assert
!
(
total_spill_cost
.
is_finite
(
)
)
;
assert
!
(
total_spill_cost
.
is_less_than
(
&
curr_vlr
.
spill_cost
)
)
;
for
vlrix_to_evict
in
vlrixs_to_evict
.
iter
(
)
{
debug
!
(
"
-
-
DI
evict
{
:
?
}
:
{
:
?
}
"
*
vlrix_to_evict
&
vlr_env
[
*
vlrix_to_evict
]
)
;
per_real_reg
[
rregNo
]
.
del_VirtualRange
(
*
vlrix_to_evict
&
vlr_env
)
;
prioQ
.
add_VirtualRange
(
&
vlr_env
*
vlrix_to_evict
)
;
debug_assert
!
(
vlr_env
[
*
vlrix_to_evict
]
.
rreg
.
is_some
(
)
)
;
vlr_env
[
*
vlrix_to_evict
]
.
rreg
=
None
;
num_vlrs_evicted
+
=
1
;
}
debug
!
(
"
-
-
DI
alloc
to
{
}
"
reg_universe
.
regs
[
rregNo
]
.
1
)
;
per_real_reg
[
rregNo
]
.
add_VirtualRange
(
curr_vlrix
&
vlr_env
)
;
let
rreg
=
reg_universe
.
regs
[
rregNo
]
.
0
;
vlr_env
[
curr_vlrix
]
.
rreg
=
Some
(
rreg
)
;
continue
'
main_allocation_loop
;
}
debug
!
(
"
-
-
spill
"
)
;
if
curr_vlr
.
spill_cost
.
is_infinite
(
)
{
return
Err
(
RegAllocError
:
:
OutOfRegisters
(
curr_vlr_regclass
)
)
;
}
struct
SpillAndOrReloadInfo
{
bix
:
BlockIx
iix
:
InstIx
kind
:
BridgeKind
}
let
mut
sri_vec
=
SmallVec
:
:
<
[
SpillAndOrReloadInfo
;
32
]
>
:
:
new
(
)
;
let
curr_vlr_vreg
=
curr_vlr
.
vreg
;
let
curr_vlr_reg
=
curr_vlr_vreg
.
to_reg
(
)
;
let
curr_vlr_is_ref
=
curr_vlr
.
is_ref
;
for
frag
in
&
curr_vlr
.
sorted_frags
.
frags
{
for
iix
in
frag
.
first
.
iix
(
)
.
dotdot
(
frag
.
last
.
iix
(
)
.
plus
(
1
)
)
{
let
(
iix_uses_curr_vlr_reg
iix_defs_curr_vlr_reg
iix_mods_curr_vlr_reg
)
=
does_inst_use_def_or_mod_reg
(
&
reg_vecs_and_bounds
iix
curr_vlr_reg
)
;
if
!
iix_defs_curr_vlr_reg
&
&
!
iix_mods_curr_vlr_reg
&
&
!
iix_uses_curr_vlr_reg
{
continue
;
}
if
iix_uses_curr_vlr_reg
&
&
frag
.
contains
(
&
InstPoint
:
:
new_use
(
iix
)
)
{
debug_assert
!
(
!
iix_mods_curr_vlr_reg
)
;
let
bix
=
inst_to_block_map
.
map
(
iix
)
;
let
sri
=
SpillAndOrReloadInfo
{
bix
iix
kind
:
BridgeKind
:
:
RtoU
}
;
sri_vec
.
push
(
sri
)
;
}
if
iix_mods_curr_vlr_reg
&
&
frag
.
contains
(
&
InstPoint
:
:
new_use
(
iix
)
)
&
&
frag
.
contains
(
&
InstPoint
:
:
new_def
(
iix
)
)
{
debug_assert
!
(
!
iix_uses_curr_vlr_reg
)
;
debug_assert
!
(
!
iix_defs_curr_vlr_reg
)
;
let
bix
=
inst_to_block_map
.
map
(
iix
)
;
let
sri
=
SpillAndOrReloadInfo
{
bix
iix
kind
:
BridgeKind
:
:
RtoS
}
;
sri_vec
.
push
(
sri
)
;
}
if
iix_defs_curr_vlr_reg
&
&
frag
.
contains
(
&
InstPoint
:
:
new_def
(
iix
)
)
{
debug_assert
!
(
!
iix_mods_curr_vlr_reg
)
;
let
bix
=
inst_to_block_map
.
map
(
iix
)
;
let
sri
=
SpillAndOrReloadInfo
{
bix
iix
kind
:
BridgeKind
:
:
DtoS
}
;
sri_vec
.
push
(
sri
)
;
}
}
}
assert
!
(
vlr_slot_env
.
len
(
)
=
=
num_vlrs_initial
)
;
assert
!
(
curr_vlrix
<
VirtualRangeIx
:
:
new
(
num_vlrs_initial
)
)
;
if
vlr_slot_env
[
curr_vlrix
]
.
is_none
(
)
{
spill_slot_allocator
.
alloc_spill_slots
(
&
mut
vlr_slot_env
func
&
vlr_env
&
vlrEquivClasses
curr_vlrix
)
;
assert
!
(
vlr_slot_env
[
curr_vlrix
]
.
is_some
(
)
)
;
}
let
spill_slot_to_use
=
vlr_slot_env
[
curr_vlrix
]
.
unwrap
(
)
;
if
curr_vlr
.
is_ref
{
spill_slot_allocator
.
notify_spillage_of_reftyped_vlr
(
spill_slot_to_use
&
curr_vlr
.
sorted_frags
)
;
}
for
sri
in
sri_vec
{
let
(
new_vlr_first_pt
new_vlr_last_pt
)
=
match
sri
.
kind
{
BridgeKind
:
:
RtoU
=
>
(
Point
:
:
Reload
Point
:
:
Use
)
BridgeKind
:
:
RtoS
=
>
(
Point
:
:
Reload
Point
:
:
Spill
)
BridgeKind
:
:
DtoS
=
>
(
Point
:
:
Def
Point
:
:
Spill
)
}
;
let
new_vlr_frag
=
RangeFrag
{
first
:
InstPoint
:
:
new
(
sri
.
iix
new_vlr_first_pt
)
last
:
InstPoint
:
:
new
(
sri
.
iix
new_vlr_last_pt
)
}
;
debug
!
(
"
-
-
new
RangeFrag
{
:
?
}
"
&
new_vlr_frag
)
;
let
new_vlr_sfrags
=
SortedRangeFrags
:
:
unit
(
new_vlr_frag
)
;
let
new_vlr
=
VirtualRange
{
vreg
:
curr_vlr_vreg
rreg
:
None
sorted_frags
:
new_vlr_sfrags
is_ref
:
curr_vlr_is_ref
size
:
1
total_cost
:
0xFFFF_FFFFu32
spill_cost
:
SpillCost
:
:
infinite
(
)
}
;
let
new_vlrix
=
VirtualRangeIx
:
:
new
(
vlr_env
.
len
(
)
as
u32
)
;
debug
!
(
"
-
-
new
VirtRange
{
:
?
}
:
=
{
:
?
}
"
new_vlrix
&
new_vlr
)
;
vlr_env
.
push
(
new_vlr
)
;
prioQ
.
add_VirtualRange
(
&
vlr_env
new_vlrix
)
;
let
mut
new_vlr_hint
=
SmallVec
:
:
<
[
Hint
;
8
]
>
:
:
new
(
)
;
if
is_vv_boundary_move
[
sri
.
iix
]
{
let
im
=
func
.
is_move
(
&
func
.
get_insn
(
sri
.
iix
)
)
;
assert
!
(
im
.
is_some
(
)
)
;
let
(
wdst_reg
src_reg
)
:
(
Writable
<
Reg
>
Reg
)
=
im
.
unwrap
(
)
;
let
dst_reg
:
Reg
=
wdst_reg
.
to_reg
(
)
;
assert
!
(
src_reg
.
is_virtual
(
)
&
&
dst_reg
.
is_virtual
(
)
)
;
let
dst_vreg
:
VirtualReg
=
dst_reg
.
to_virtual_reg
(
)
;
let
src_vreg
:
VirtualReg
=
src_reg
.
to_virtual_reg
(
)
;
let
bridge_eef
=
est_freqs
[
sri
.
bix
]
;
match
sri
.
kind
{
BridgeKind
:
:
RtoU
=
>
{
for
vlrix
in
&
reg_to_ranges_maps
.
vreg_to_vlrs_map
[
dst_vreg
.
get_index
(
)
]
{
if
vlr_env
[
*
vlrix
]
.
vreg
=
=
dst_vreg
{
new_vlr_hint
.
push
(
Hint
:
:
SameAs
(
*
vlrix
bridge_eef
)
)
;
break
;
}
}
}
BridgeKind
:
:
DtoS
=
>
{
for
vlrix
in
&
reg_to_ranges_maps
.
vreg_to_vlrs_map
[
src_vreg
.
get_index
(
)
]
{
if
vlr_env
[
*
vlrix
]
.
vreg
=
=
src_vreg
{
new_vlr_hint
.
push
(
Hint
:
:
SameAs
(
*
vlrix
bridge_eef
)
)
;
break
;
}
}
}
BridgeKind
:
:
RtoS
=
>
{
panic
!
(
"
RtoS
bridge
for
v
-
v
boundary
move
"
)
;
}
}
}
hints
.
push
(
new_vlr_hint
)
;
let
new_eli
=
EditListItem
{
slot
:
spill_slot_to_use
vlrix
:
new_vlrix
kind
:
sri
.
kind
iix
:
sri
.
iix
}
;
if
is_vv_boundary_move
[
sri
.
iix
]
{
debug
!
(
"
-
-
new
ELI
MOVE
{
:
?
}
"
&
new_eli
)
;
edit_list_move
.
push
(
new_eli
)
;
}
else
{
debug
!
(
"
-
-
new
ELI
other
{
:
?
}
"
&
new_eli
)
;
edit_list_other
.
push
(
new_eli
)
;
}
}
num_vlrs_spilled
+
=
1
;
}
info
!
(
"
alloc_main
:
main
allocation
loop
:
end
"
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
"
)
;
print_RA_state
(
"
Final
"
&
reg_universe
&
prioQ
&
per_real_reg
&
edit_list_move
&
edit_list_other
&
vlr_env
&
frag_env
)
;
}
debug
!
(
"
"
)
;
info
!
(
"
alloc_main
:
create
spills_n_reloads
for
MOVE
insns
"
)
;
edit_list_move
.
sort_unstable_by
(
|
eli1
eli2
|
eli1
.
iix
.
cmp
(
&
eli2
.
iix
)
)
;
let
mut
iixs_to_nop_out
=
Vec
:
:
<
InstIx
>
:
:
new
(
)
;
let
mut
ghost_moves
=
vec
!
[
]
;
let
n_edit_list_move
=
edit_list_move
.
len
(
)
;
let
mut
n_edit_list_move_processed
=
0
;
let
mut
i_min
=
0
;
loop
{
if
i_min
>
=
n_edit_list_move
{
break
;
}
debug
!
(
"
editlist
entry
(
MOVE
)
:
min
:
{
:
?
}
"
&
edit_list_move
[
i_min
]
)
;
let
i_min_iix
=
edit_list_move
[
i_min
]
.
iix
;
let
mut
i_max
=
i_min
;
while
i_max
+
1
<
n_edit_list_move
&
&
edit_list_move
[
i_max
+
1
]
.
iix
=
=
i_min_iix
{
i_max
+
=
1
;
debug
!
(
"
editlist
entry
(
MOVE
)
:
max
:
{
:
?
}
"
&
edit_list_move
[
i_max
]
)
;
}
assert
!
(
i_max
-
i_min
<
=
1
)
;
if
i_max
-
i_min
=
=
1
{
assert
!
(
is_vv_boundary_move
[
i_min_iix
]
)
;
let
vlrix1
=
edit_list_move
[
i_min
]
.
vlrix
;
let
vlrix2
=
edit_list_move
[
i_max
]
.
vlrix
;
assert
!
(
vlrix1
!
=
vlrix2
)
;
let
vlr1
=
&
vlr_env
[
vlrix1
]
;
let
vlr2
=
&
vlr_env
[
vlrix2
]
;
let
frags1
=
&
vlr1
.
sorted_frags
;
let
frags2
=
&
vlr2
.
sorted_frags
;
assert
!
(
frags1
.
frags
.
len
(
)
=
=
1
)
;
assert
!
(
frags2
.
frags
.
len
(
)
=
=
1
)
;
let
frag1
=
&
frags1
.
frags
[
0
]
;
let
frag2
=
&
frags2
.
frags
[
0
]
;
assert
!
(
frag1
.
first
.
iix
(
)
=
=
i_min_iix
)
;
assert
!
(
frag1
.
last
.
iix
(
)
=
=
i_min_iix
)
;
assert
!
(
frag2
.
first
.
iix
(
)
=
=
i_min_iix
)
;
assert
!
(
frag2
.
last
.
iix
(
)
=
=
i_min_iix
)
;
match
(
frag1
.
first
.
pt
(
)
frag1
.
last
.
pt
(
)
frag2
.
first
.
pt
(
)
frag2
.
last
.
pt
(
)
)
{
(
Point
:
:
Reload
Point
:
:
Use
Point
:
:
Def
Point
:
:
Spill
)
|
(
Point
:
:
Def
Point
:
:
Spill
Point
:
:
Reload
Point
:
:
Use
)
=
>
{
let
slot1
=
edit_list_move
[
i_min
]
.
slot
;
let
slot2
=
edit_list_move
[
i_max
]
.
slot
;
if
slot1
=
=
slot2
{
debug
!
(
"
editlist
entry
(
MOVE
)
:
delete
{
:
?
}
"
i_min_iix
)
;
iixs_to_nop_out
.
push
(
i_min_iix
)
;
i_min
=
i_max
+
1
;
n_edit_list_move_processed
+
=
2
;
if
use_checker
{
let
(
from_reg
to_reg
)
=
if
frag1
.
last
.
pt
(
)
=
=
Point
:
:
Use
{
(
vlr1
.
vreg
.
to_reg
(
)
vlr2
.
vreg
.
to_reg
(
)
)
}
else
{
(
vlr2
.
vreg
.
to_reg
(
)
vlr1
.
vreg
.
to_reg
(
)
)
}
;
ghost_moves
.
push
(
InstToInsertAndExtPoint
:
:
new
(
InstToInsert
:
:
ChangeSpillSlotOwnership
{
inst_ix
:
i_min_iix
slot
:
slot1
from_reg
to_reg
}
InstExtPoint
:
:
new
(
i_min_iix
ExtPoint
:
:
Reload
)
)
)
;
}
continue
;
}
}
(
_
_
_
_
)
=
>
{
panic
!
(
"
spill
slot
coalescing
edit_list_move
:
unexpected
frags
"
)
;
}
}
}
for
i
in
i_min
.
.
=
i_max
{
edit_list_other
.
push
(
edit_list_move
[
i
]
)
;
n_edit_list_move_processed
+
=
1
;
}
i_min
=
i_max
+
1
;
}
assert
!
(
n_edit_list_move_processed
=
=
n_edit_list_move
)
;
debug
!
(
"
"
)
;
info
!
(
"
alloc_main
:
create
spills_n_reloads
for
other
insns
"
)
;
let
mut
spills_n_reloads
=
Vec
:
:
<
InstToInsertAndExtPoint
>
:
:
new
(
)
;
let
mut
num_spills
=
0
;
let
mut
num_reloads
=
0
;
for
eli
in
&
edit_list_other
{
debug
!
(
"
editlist
entry
(
other
)
:
{
:
?
}
"
eli
)
;
let
vlr
=
&
vlr_env
[
eli
.
vlrix
]
;
let
vlr_sfrags
=
&
vlr
.
sorted_frags
;
assert
!
(
vlr_sfrags
.
frags
.
len
(
)
=
=
1
)
;
let
vlr_frag
=
&
vlr_sfrags
.
frags
[
0
]
;
let
rreg
=
vlr
.
rreg
.
expect
(
"
Gen
of
spill
/
reload
:
reg
not
assigned
?
!
"
)
;
let
vreg
=
vlr
.
vreg
;
match
eli
.
kind
{
BridgeKind
:
:
RtoU
=
>
{
debug_assert
!
(
vlr_frag
.
first
.
pt
(
)
.
is_reload
(
)
)
;
debug_assert
!
(
vlr_frag
.
last
.
pt
(
)
.
is_use
(
)
)
;
debug_assert
!
(
vlr_frag
.
first
.
iix
(
)
=
=
vlr_frag
.
last
.
iix
(
)
)
;
let
insnR
=
InstToInsert
:
:
Reload
{
to_reg
:
Writable
:
:
from_reg
(
rreg
)
from_slot
:
eli
.
slot
for_vreg
:
Some
(
vreg
)
}
;
let
whereToR
=
InstExtPoint
:
:
from_inst_point
(
vlr_frag
.
first
)
;
spills_n_reloads
.
push
(
InstToInsertAndExtPoint
:
:
new
(
insnR
whereToR
)
)
;
num_reloads
+
=
1
;
}
BridgeKind
:
:
RtoS
=
>
{
debug_assert
!
(
vlr_frag
.
first
.
pt
(
)
.
is_reload
(
)
)
;
debug_assert
!
(
vlr_frag
.
last
.
pt
(
)
.
is_spill
(
)
)
;
debug_assert
!
(
vlr_frag
.
first
.
iix
(
)
=
=
vlr_frag
.
last
.
iix
(
)
)
;
let
insnR
=
InstToInsert
:
:
Reload
{
to_reg
:
Writable
:
:
from_reg
(
rreg
)
from_slot
:
eli
.
slot
for_vreg
:
Some
(
vreg
)
}
;
let
whereToR
=
InstExtPoint
:
:
from_inst_point
(
vlr_frag
.
first
)
;
let
insnS
=
InstToInsert
:
:
Spill
{
to_slot
:
eli
.
slot
from_reg
:
rreg
for_vreg
:
Some
(
vreg
)
}
;
let
whereToS
=
InstExtPoint
:
:
from_inst_point
(
vlr_frag
.
last
)
;
spills_n_reloads
.
push
(
InstToInsertAndExtPoint
:
:
new
(
insnR
whereToR
)
)
;
spills_n_reloads
.
push
(
InstToInsertAndExtPoint
:
:
new
(
insnS
whereToS
)
)
;
num_reloads
+
=
1
;
num_spills
+
=
1
;
}
BridgeKind
:
:
DtoS
=
>
{
debug_assert
!
(
vlr_frag
.
first
.
pt
(
)
.
is_def
(
)
)
;
debug_assert
!
(
vlr_frag
.
last
.
pt
(
)
.
is_spill
(
)
)
;
debug_assert
!
(
vlr_frag
.
first
.
iix
(
)
=
=
vlr_frag
.
last
.
iix
(
)
)
;
let
insnS
=
InstToInsert
:
:
Spill
{
to_slot
:
eli
.
slot
from_reg
:
rreg
for_vreg
:
Some
(
vreg
)
}
;
let
whereToS
=
InstExtPoint
:
:
from_inst_point
(
vlr_frag
.
last
)
;
spills_n_reloads
.
push
(
InstToInsertAndExtPoint
:
:
new
(
insnS
whereToS
)
)
;
num_spills
+
=
1
;
}
}
}
if
use_checker
{
spills_n_reloads
.
extend
(
ghost_moves
.
into_iter
(
)
)
;
spills_n_reloads
.
sort_by_key
(
|
inst_and_point
|
inst_and_point
.
iep
.
clone
(
)
)
;
}
info
!
(
"
alloc_main
:
create
frag_map
"
)
;
let
mut
frag_map
=
Vec
:
:
<
(
RangeFrag
VirtualReg
RealReg
)
>
:
:
new
(
)
;
for
i
in
0
.
.
reg_universe
.
allocable
{
let
rreg
=
reg_universe
.
regs
[
i
]
.
0
;
for
vlrix_assigned
in
per_real_reg
[
i
]
.
vlrixs_assigned
.
iter
(
)
{
let
VirtualRange
{
vreg
sorted_frags
.
.
}
=
&
vlr_env
[
*
vlrix_assigned
]
;
for
frag
in
&
sorted_frags
.
frags
{
frag_map
.
push
(
(
frag
.
clone
(
)
*
vreg
rreg
)
)
;
}
}
}
let
mut
stackmaps
=
Vec
:
:
<
Vec
<
SpillSlot
>
>
:
:
new
(
)
;
if
!
safepoint_insns
.
is_empty
(
)
{
info
!
(
"
alloc_main
:
create
safepoints
and
stackmaps
"
)
;
for
safepoint_iix
in
safepoint_insns
{
let
(
spills_before
reloads_after
reftyped_spillslots
)
=
get_stackmap_artefacts_at
(
&
mut
spill_slot_allocator
&
reg_universe
reftype_class
&
reg_vecs_and_bounds
&
per_real_reg
&
rlr_env
&
vlr_env
*
safepoint_iix
)
?
;
stackmaps
.
push
(
reftyped_spillslots
)
;
for
spill_before
in
spills_before
{
spills_n_reloads
.
push
(
InstToInsertAndExtPoint
:
:
new
(
spill_before
InstExtPoint
:
:
new
(
*
safepoint_iix
ExtPoint
:
:
SpillBefore
)
)
)
;
}
for
reload_after
in
reloads_after
{
spills_n_reloads
.
push
(
InstToInsertAndExtPoint
:
:
new
(
reload_after
InstExtPoint
:
:
new
(
*
safepoint_iix
ExtPoint
:
:
ReloadAfter
)
)
)
;
}
}
}
info
!
(
"
alloc_main
:
edit_inst_stream
"
)
;
let
final_insns_and_targetmap_and_new_safepoints__or_err
=
edit_inst_stream
(
func
&
safepoint_insns
spills_n_reloads
&
iixs_to_nop_out
frag_map
&
reg_universe
use_checker
&
stackmaps
[
.
.
]
&
reftyped_vregs
[
.
.
]
)
;
match
final_insns_and_targetmap_and_new_safepoints__or_err
{
Ok
(
(
ref
final_insns
.
.
)
)
=
>
{
info
!
(
"
alloc_main
:
out
:
VLRs
:
{
}
initially
{
}
processed
"
num_vlrs_initial
num_vlrs_processed
)
;
info
!
(
"
alloc_main
:
out
:
VLRs
:
{
}
evicted
{
}
spilled
"
num_vlrs_evicted
num_vlrs_spilled
)
;
info
!
(
"
alloc_main
:
out
:
insns
:
{
}
total
{
}
spills
{
}
reloads
{
}
nopzs
"
final_insns
.
len
(
)
num_spills
num_reloads
iixs_to_nop_out
.
len
(
)
)
;
info
!
(
"
alloc_main
:
out
:
spill
slots
:
{
}
used
"
spill_slot_allocator
.
num_slots_in_use
(
)
)
;
}
Err
(
_
)
=
>
{
info
!
(
"
alloc_main
:
allocation
failed
!
"
)
;
}
}
let
(
final_insns
target_map
new_to_old_insn_map
new_safepoint_insns
)
=
match
final_insns_and_targetmap_and_new_safepoints__or_err
{
Err
(
e
)
=
>
{
info
!
(
"
alloc_main
:
fail
"
)
;
return
Err
(
e
)
;
}
Ok
(
quad
)
=
>
{
info
!
(
"
alloc_main
:
creating
RegAllocResult
"
)
;
quad
}
}
;
let
mut
clobbered_registers
:
Set
<
RealReg
>
=
Set
:
:
empty
(
)
;
let
mut
reg_vecs
=
RegVecs
:
:
new
(
false
)
;
let
mut
dummy_bounds
=
RegVecBounds
:
:
new
(
)
;
for
insn
in
&
final_insns
{
if
func
.
is_included_in_clobbers
(
insn
)
{
add_raw_reg_vecs_for_insn
:
:
<
F
>
(
insn
&
mut
reg_vecs
&
mut
dummy_bounds
)
;
}
}
for
reg
in
reg_vecs
.
defs
.
iter
(
)
.
chain
(
reg_vecs
.
mods
.
iter
(
)
)
{
assert
!
(
reg
.
is_real
(
)
)
;
clobbered_registers
.
insert
(
reg
.
to_real_reg
(
)
)
;
}
clobbered_registers
.
filter_map
(
|
&
reg
|
{
if
reg
.
get_index
(
)
>
=
reg_universe
.
allocable
{
None
}
else
{
Some
(
reg
)
}
}
)
;
assert
!
(
est_freqs
.
len
(
)
as
usize
=
=
func
.
blocks
(
)
.
len
(
)
)
;
let
mut
block_annotations
=
None
;
if
opts
.
request_block_annotations
{
let
mut
anns
=
TypedIxVec
:
:
<
BlockIx
Vec
<
String
>
>
:
:
new
(
)
;
for
(
estFreq
i
)
in
est_freqs
.
iter
(
)
.
zip
(
0
.
.
)
{
let
bix
=
BlockIx
:
:
new
(
i
)
;
let
ef_str
=
format
!
(
"
RA
:
bix
{
:
?
}
estFreq
{
}
"
bix
estFreq
)
;
anns
.
push
(
vec
!
[
ef_str
]
)
;
}
block_annotations
=
Some
(
anns
)
;
}
assert
!
(
stackmaps
.
len
(
)
=
=
safepoint_insns
.
len
(
)
)
;
assert
!
(
new_safepoint_insns
.
len
(
)
=
=
safepoint_insns
.
len
(
)
)
;
let
ra_res
=
RegAllocResult
{
insns
:
final_insns
target_map
orig_insn_map
:
new_to_old_insn_map
clobbered_registers
num_spill_slots
:
spill_slot_allocator
.
num_slots_in_use
(
)
as
u32
block_annotations
stackmaps
new_safepoint_insns
}
;
info
!
(
"
alloc_main
:
end
"
)
;
Ok
(
ra_res
)
}
