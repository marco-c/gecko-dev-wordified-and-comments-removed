#
!
[
allow
(
non_snake_case
)
]
#
!
[
allow
(
non_camel_case_types
)
]
use
log
:
:
{
debug
info
log_enabled
Level
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
fmt
;
use
crate
:
:
analysis_control_flow
:
:
InstIxToBlockIxMap
;
use
crate
:
:
analysis_data_flow
:
:
{
add_raw_reg_vecs_for_insn
does_inst_use_def_or_mod_reg
}
;
use
crate
:
:
analysis_main
:
:
run_analysis
;
use
crate
:
:
avl_tree
:
:
{
AVLTag
AVLTree
AVL_NULL
}
;
use
crate
:
:
bt_coalescing_analysis
:
:
{
do_coalescing_analysis
Hint
}
;
use
crate
:
:
bt_commitment_map
:
:
{
CommitmentMap
CommitmentMapFAST
FIxAndVLRIx
CROSSCHECK_CM
}
;
use
crate
:
:
bt_spillslot_allocator
:
:
SpillSlotAllocator
;
use
crate
:
:
bt_vlr_priority_queue
:
:
VirtualRangePrioQ
;
use
crate
:
:
data_structures
:
:
{
BlockIx
InstIx
InstPoint
Point
RangeFrag
RangeFragIx
RangeFragKind
RealRange
RealRangeIx
RealReg
RealRegUniverse
Reg
RegVecBounds
RegVecs
RegVecsAndBounds
Set
SortedRangeFragIxs
SpillCost
SpillSlot
TypedIxVec
VirtualRange
VirtualRangeIx
VirtualReg
Writable
}
;
use
crate
:
:
inst_stream
:
:
{
edit_inst_stream
InstToInsert
InstToInsertAndPoint
}
;
use
crate
:
:
sparse_set
:
:
{
SparseSet
SparseSetU
}
;
use
crate
:
:
union_find
:
:
UnionFindEquivClasses
;
use
crate
:
:
{
Function
RegAllocError
RegAllocResult
}
;
struct
PerRealReg
{
committed
:
CommitmentMap
committedFAST
:
CommitmentMapFAST
vlrixs_assigned
:
Set
<
VirtualRangeIx
>
}
impl
PerRealReg
{
fn
new
(
)
-
>
Self
{
Self
{
committed
:
CommitmentMap
:
:
new
(
)
committedFAST
:
CommitmentMapFAST
:
:
new
(
)
vlrixs_assigned
:
Set
:
:
<
VirtualRangeIx
>
:
:
empty
(
)
}
}
#
[
inline
(
never
)
]
fn
add_RealRange
(
&
mut
self
to_add
:
&
RealRange
fenv
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
self
.
committedFAST
.
add
(
&
to_add
.
sorted_frags
None
fenv
vlr_env
)
;
if
CROSSCHECK_CM
{
self
.
committed
.
add
(
&
to_add
.
sorted_frags
None
fenv
vlr_env
)
;
}
}
#
[
inline
(
never
)
]
fn
add_VirtualRange
(
&
mut
self
to_add_vlrix
:
VirtualRangeIx
fenv
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
let
to_add_vlr
=
&
vlr_env
[
to_add_vlrix
]
;
self
.
committedFAST
.
add
(
&
to_add_vlr
.
sorted_frags
Some
(
to_add_vlrix
)
fenv
vlr_env
)
;
if
CROSSCHECK_CM
{
self
.
committed
.
add
(
&
to_add_vlr
.
sorted_frags
Some
(
to_add_vlrix
)
fenv
vlr_env
)
;
}
assert
!
(
!
self
.
vlrixs_assigned
.
contains
(
to_add_vlrix
)
)
;
self
.
vlrixs_assigned
.
insert
(
to_add_vlrix
)
;
}
#
[
inline
(
never
)
]
fn
del_VirtualRange
(
&
mut
self
to_del_vlrix
:
VirtualRangeIx
fenv
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
{
if
self
.
vlrixs_assigned
.
contains
(
to_del_vlrix
)
{
self
.
vlrixs_assigned
.
delete
(
to_del_vlrix
)
;
}
else
{
panic
!
(
"
PerRealReg
:
del_VirtualRange
on
VR
not
in
vlrixs_assigned
"
)
;
}
let
to_del_vlr
=
&
vlr_env
[
to_del_vlrix
]
;
self
.
committedFAST
.
del
(
&
to_del_vlr
.
sorted_frags
fenv
vlr_env
)
;
if
CROSSCHECK_CM
{
self
.
committed
.
del
(
&
to_del_vlr
.
sorted_frags
fenv
vlr_env
)
;
}
}
}
fn
handle_CM_entry
(
evict_set
:
&
mut
Set
<
VirtualRangeIx
>
evict_cost
:
&
mut
SpillCost
pairs
:
&
Vec
<
FIxAndVLRIx
>
pairs_ix
:
usize
spill_cost_budget
:
SpillCost
do_not_evict
:
&
SparseSetU
<
[
VirtualRangeIx
;
16
]
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
_who
:
&
'
static
str
)
-
>
bool
{
let
FIxAndVLRIx
{
fix
:
_fix_to_evict
mb_vlrix
:
mb_vlrix_to_evict
}
=
pairs
[
pairs_ix
]
;
if
mb_vlrix_to_evict
.
is_none
(
)
{
return
false
;
}
let
vlrix_to_evict
=
mb_vlrix_to_evict
.
unwrap
(
)
;
if
do_not_evict
.
contains
(
vlrix_to_evict
)
{
return
false
;
}
let
vlr_to_evict
=
&
vlr_env
[
vlrix_to_evict
]
;
if
vlr_to_evict
.
spill_cost
.
is_infinite
(
)
{
return
false
;
}
if
!
evict_set
.
contains
(
vlrix_to_evict
)
{
let
mut
new_evict_cost
=
*
evict_cost
;
new_evict_cost
.
add
(
&
vlr_to_evict
.
spill_cost
)
;
if
!
new_evict_cost
.
is_less_than
(
&
spill_cost_budget
)
{
return
false
;
}
evict_set
.
insert
(
vlrix_to_evict
)
;
*
evict_cost
=
new_evict_cost
;
}
true
}
fn
rec_helper
(
running_set
:
&
mut
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
running_cost
:
&
mut
SpillCost
root
:
u32
tree
:
&
AVLTree
<
FIxAndVLRIx
>
pair_frag
:
&
RangeFrag
spill_cost_budget
:
&
SpillCost
do_not_evict
:
&
SparseSetU
<
[
VirtualRangeIx
;
16
]
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
)
-
>
bool
{
let
root_node
=
&
tree
.
pool
[
root
as
usize
]
;
let
root_node_FnV
=
&
root_node
.
item
;
assert
!
(
root_node
.
tag
!
=
AVLTag
:
:
Free
)
;
let
root_frag
=
&
frag_env
[
root_node_FnV
.
fix
]
;
let
go_left
=
pair_frag
.
first
<
root_frag
.
first
;
let
go_right
=
pair_frag
.
last
>
root_frag
.
last
;
let
overlaps_root
=
pair_frag
.
last
>
=
root_frag
.
first
&
&
pair_frag
.
first
<
=
root_frag
.
last
;
if
overlaps_root
{
if
root_node_FnV
.
mb_vlrix
.
is_none
(
)
{
return
false
;
}
let
vlrix_to_evict
=
root_node_FnV
.
mb_vlrix
.
unwrap
(
)
;
let
vlr_to_evict
=
&
vlr_env
[
vlrix_to_evict
]
;
if
vlr_to_evict
.
spill_cost
.
is_infinite
(
)
{
return
false
;
}
if
!
vlr_to_evict
.
spill_cost
.
is_less_than
(
spill_cost_budget
)
{
return
false
;
}
if
do_not_evict
.
contains
(
vlrix_to_evict
)
{
return
false
;
}
if
!
running_set
.
contains
(
vlrix_to_evict
)
{
let
mut
tmp_cost
=
*
running_cost
;
tmp_cost
.
add
(
&
vlr_to_evict
.
spill_cost
)
;
if
!
tmp_cost
.
is_less_than
(
spill_cost_budget
)
{
return
false
;
}
*
running_cost
=
tmp_cost
;
running_set
.
insert
(
vlrix_to_evict
)
;
}
}
let
left_root
=
tree
.
pool
[
root
as
usize
]
.
left
;
if
go_left
&
&
left_root
!
=
AVL_NULL
{
let
ok_left
=
rec_helper
(
running_set
running_cost
left_root
tree
pair_frag
spill_cost_budget
do_not_evict
frag_env
vlr_env
)
;
if
!
ok_left
{
return
false
;
}
}
let
right_root
=
tree
.
pool
[
root
as
usize
]
.
right
;
if
go_right
&
&
right_root
!
=
AVL_NULL
{
let
ok_right
=
rec_helper
(
running_set
running_cost
right_root
tree
pair_frag
spill_cost_budget
do_not_evict
frag_env
vlr_env
)
;
if
!
ok_right
{
return
false
;
}
}
assert
!
(
running_cost
.
is_finite
(
)
)
;
assert
!
(
running_cost
.
is_less_than
(
spill_cost_budget
)
)
;
true
}
impl
PerRealReg
{
#
[
inline
(
never
)
]
fn
find_Evict_Set_FAST
(
&
self
would_like_to_add
:
VirtualRangeIx
do_not_evict
:
&
SparseSetU
<
[
VirtualRangeIx
;
16
]
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
{
if
self
.
committedFAST
.
tree
.
root
=
=
AVL_NULL
{
let
evict_set
=
SparseSetU
:
:
<
[
VirtualRangeIx
;
4
]
>
:
:
empty
(
)
;
let
evict_cost
=
SpillCost
:
:
zero
(
)
;
return
Some
(
(
evict_set
evict_cost
)
)
;
}
let
would_like_to_add_vlr
=
&
vlr_env
[
would_like_to_add
]
;
let
evict_cost_budget
=
would_like_to_add_vlr
.
spill_cost
;
let
mut
running_set
=
SparseSetU
:
:
<
[
VirtualRangeIx
;
4
]
>
:
:
empty
(
)
;
let
mut
running_cost
=
SpillCost
:
:
zero
(
)
;
for
wlta_fix
in
&
would_like_to_add_vlr
.
sorted_frags
.
frag_ixs
{
let
wlta_frag
=
&
frag_env
[
*
wlta_fix
]
;
let
wlta_frag_ok
=
rec_helper
(
&
mut
running_set
&
mut
running_cost
self
.
committedFAST
.
tree
.
root
&
self
.
committedFAST
.
tree
&
wlta_frag
&
evict_cost_budget
do_not_evict
frag_env
vlr_env
)
;
if
!
wlta_frag_ok
{
return
None
;
}
}
assert
!
(
running_cost
.
is_finite
(
)
)
;
assert
!
(
running_cost
.
is_less_than
(
&
evict_cost_budget
)
)
;
Some
(
(
running_set
running_cost
)
)
}
#
[
inline
(
never
)
]
fn
find_Evict_Set_CROSSCHECK
(
&
self
would_like_to_add
:
VirtualRangeIx
do_not_evict
:
&
SparseSetU
<
[
VirtualRangeIx
;
16
]
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
Option
<
(
Set
<
VirtualRangeIx
>
SpillCost
)
>
{
let
would_like_to_add_vlr
=
&
vlr_env
[
would_like_to_add
]
;
let
evict_cost_budget
=
would_like_to_add_vlr
.
spill_cost
;
let
vr_ip_first
=
frag_env
[
would_like_to_add_vlr
.
sorted_frags
.
frag_ixs
[
0
]
]
.
first
;
let
vr_ip_last
=
frag_env
[
would_like_to_add_vlr
.
sorted_frags
.
frag_ixs
[
would_like_to_add_vlr
.
sorted_frags
.
frag_ixs
.
len
(
)
-
1
]
]
.
last
;
for
fix
in
&
would_like_to_add_vlr
.
sorted_frags
.
frag_ixs
{
let
frag
=
&
frag_env
[
*
fix
]
;
assert
!
(
vr_ip_first
<
=
frag
.
first
&
&
frag
.
first
<
=
vr_ip_last
)
;
assert
!
(
vr_ip_first
<
=
frag
.
last
&
&
frag
.
last
<
=
vr_ip_last
)
;
}
let
mut
evict_set
=
Set
:
:
<
VirtualRangeIx
>
:
:
empty
(
)
;
let
mut
evict_cost
=
SpillCost
:
:
zero
(
)
;
if
self
.
committed
.
pairs
.
len
(
)
>
0
{
let
mut
vr_ip
=
vr_ip_first
;
loop
{
if
vr_ip
>
vr_ip_last
{
break
;
}
let
mut
found_in_vr
=
false
;
for
fix
in
&
would_like_to_add_vlr
.
sorted_frags
.
frag_ixs
{
let
frag
=
&
frag_env
[
*
fix
]
;
if
frag
.
first
<
=
vr_ip
&
&
vr_ip
<
=
frag
.
last
{
found_in_vr
=
true
;
break
;
}
}
if
!
found_in_vr
{
vr_ip
=
vr_ip
.
step
(
)
;
continue
;
}
let
mut
pair_ix
=
0
;
let
mut
found
=
false
;
for
pair
in
&
self
.
committed
.
pairs
{
let
FIxAndVLRIx
{
fix
mb_vlrix
:
_
}
=
pair
;
let
frag
=
&
frag_env
[
*
fix
]
;
if
frag
.
first
<
=
vr_ip
&
&
vr_ip
<
=
frag
.
last
{
found
=
true
;
break
;
}
pair_ix
+
=
1
;
}
if
found
{
let
evict_possible
=
handle_CM_entry
(
&
mut
evict_set
&
mut
evict_cost
&
self
.
committed
.
pairs
pair_ix
evict_cost_budget
&
do_not_evict
&
vlr_env
"
CX
"
)
;
if
!
evict_possible
{
return
None
;
}
}
vr_ip
=
vr_ip
.
step
(
)
;
}
}
assert
!
(
evict_cost
.
is_finite
(
)
)
;
assert
!
(
evict_cost
.
is_less_than
(
&
evict_cost_budget
)
)
;
Some
(
(
evict_set
evict_cost
)
)
}
#
[
inline
(
never
)
]
fn
find_Evict_Set
(
&
self
would_like_to_add
:
VirtualRangeIx
do_not_evict
:
&
SparseSetU
<
[
VirtualRangeIx
;
16
]
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
{
let
result_fast
=
self
.
find_Evict_Set_FAST
(
would_like_to_add
do_not_evict
vlr_env
frag_env
)
;
if
CROSSCHECK_CM
{
let
result_crosscheck
=
self
.
find_Evict_Set_CROSSCHECK
(
would_like_to_add
do_not_evict
vlr_env
frag_env
)
;
let
str_fast
:
String
=
format
!
(
"
{
:
?
}
"
result_fast
)
;
let
str_crosscheck
:
String
=
format
!
(
"
{
:
?
}
"
result_crosscheck
)
;
if
str_fast
!
=
str_crosscheck
{
println
!
(
"
QQQQ
find_Evict_Set
:
fast
{
}
crosscheck
{
}
"
str_fast
str_crosscheck
)
;
println
!
(
"
"
)
;
println
!
(
"
self
.
commitments
=
{
:
?
}
"
self
.
committed
)
;
println
!
(
"
"
)
;
println
!
(
"
wlta
=
{
:
?
}
"
vlr_env
[
would_like_to_add
]
)
;
println
!
(
"
"
)
;
println
!
(
"
"
)
;
panic
!
(
"
find_Evict_Set
:
crosscheck
failed
"
)
;
}
}
result_fast
}
#
[
inline
(
never
)
]
fn
show1_with_envs
(
&
self
fenv
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
String
{
"
in_use
:
"
.
to_string
(
)
+
&
self
.
committed
.
show_with_fenv
(
&
fenv
)
}
#
[
inline
(
never
)
]
fn
show2_with_envs
(
&
self
_fenv
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
-
>
String
{
"
assigned
:
"
.
to_string
(
)
+
&
format
!
(
"
{
:
?
}
"
&
self
.
vlrixs_assigned
)
}
}
#
[
inline
(
never
)
]
fn
print_RA_state
(
who
:
&
str
universe
:
&
RealRegUniverse
prioQ
:
&
VirtualRangePrioQ
perRealReg
:
&
Vec
<
PerRealReg
>
edit_list_move
:
&
Vec
<
EditListItem
>
edit_list_other
:
&
Vec
<
EditListItem
>
vlr_env
:
&
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
debug
!
(
"
<
<
<
<
=
=
=
=
-
-
-
-
RA
state
at
'
{
}
'
-
-
-
-
=
=
=
=
"
who
)
;
for
ix
in
0
.
.
perRealReg
.
len
(
)
{
if
!
&
perRealReg
[
ix
]
.
committed
.
pairs
.
is_empty
(
)
{
debug
!
(
"
{
:
<
5
}
{
}
"
universe
.
regs
[
ix
]
.
1
&
perRealReg
[
ix
]
.
show1_with_envs
(
&
frag_env
)
)
;
debug
!
(
"
{
}
"
&
perRealReg
[
ix
]
.
show2_with_envs
(
&
frag_env
)
)
;
debug
!
(
"
"
)
;
}
}
if
!
prioQ
.
is_empty
(
)
{
for
s
in
prioQ
.
show_with_envs
(
&
vlr_env
)
{
debug
!
(
"
{
}
"
s
)
;
}
}
for
eli
in
edit_list_move
{
debug
!
(
"
ELI
MOVE
:
{
:
?
}
"
eli
)
;
}
for
eli
in
edit_list_other
{
debug
!
(
"
ELI
other
:
{
:
?
}
"
eli
)
;
}
debug
!
(
"
>
>
>
>
"
)
;
}
fn
frags_are_mergeable
(
frag1
:
&
RangeFrag
frag2
:
&
RangeFrag
)
-
>
bool
{
assert
!
(
frag1
.
first
.
pt
.
is_use_or_def
(
)
)
;
assert
!
(
frag1
.
last
.
pt
.
is_use_or_def
(
)
)
;
assert
!
(
frag2
.
first
.
pt
.
is_use_or_def
(
)
)
;
assert
!
(
frag2
.
last
.
pt
.
is_use_or_def
(
)
)
;
if
frag1
.
bix
!
=
frag2
.
bix
&
&
frag1
.
last
.
iix
.
plus
(
1
)
=
=
frag2
.
first
.
iix
&
&
frag1
.
last
.
pt
=
=
Point
:
:
Def
&
&
frag2
.
first
.
pt
=
=
Point
:
:
Use
{
assert
!
(
frag1
.
kind
=
=
RangeFragKind
:
:
LiveOut
|
|
frag1
.
kind
=
=
RangeFragKind
:
:
Thru
)
;
assert
!
(
frag2
.
kind
=
=
RangeFragKind
:
:
LiveIn
|
|
frag2
.
kind
=
=
RangeFragKind
:
:
Thru
)
;
return
true
;
}
if
frag1
.
last
.
iix
=
=
frag2
.
first
.
iix
&
&
frag1
.
last
.
pt
=
=
Point
:
:
Use
&
&
frag2
.
first
.
pt
=
=
Point
:
:
Def
{
assert
!
(
frag1
.
kind
=
=
RangeFragKind
:
:
LiveIn
|
|
frag1
.
kind
=
=
RangeFragKind
:
:
Local
)
;
assert
!
(
frag2
.
kind
=
=
RangeFragKind
:
:
Local
|
|
frag2
.
kind
=
=
RangeFragKind
:
:
LiveOut
)
;
return
true
;
}
false
}
const
Z_INVALID_BLOCKIX
:
BlockIx
=
BlockIx
:
:
invalid_value
(
)
;
const
Z_INVALID_COUNT
:
u16
=
0xFFFF
;
#
[
inline
(
never
)
]
fn
do_vlr_frag_compression
(
vlr_env
:
&
mut
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
frag_env
:
&
mut
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
let
mut
fragsIN
=
0
;
let
mut
fragsOUT
=
0
;
for
vlr
in
vlr_env
.
iter_mut
(
)
{
let
frag_ixs
=
&
mut
vlr
.
sorted_frags
.
frag_ixs
;
let
num_frags
=
frag_ixs
.
len
(
)
;
fragsIN
+
=
num_frags
;
if
num_frags
=
=
1
{
fragsOUT
+
=
1
;
continue
;
}
assert
!
(
num_frags
>
1
)
;
let
mut
w
=
0
;
let
mut
s
=
0
;
let
mut
e
=
0
;
loop
{
if
s
>
=
num_frags
{
break
;
}
while
e
+
1
<
num_frags
&
&
frags_are_mergeable
(
&
frag_env
[
frag_ixs
[
e
]
]
&
frag_env
[
frag_ixs
[
e
+
1
]
]
)
{
e
+
=
1
;
}
if
s
=
=
e
{
frag_ixs
[
w
]
=
frag_ixs
[
s
]
;
}
else
{
let
zFrag
=
RangeFrag
{
bix
:
Z_INVALID_BLOCKIX
kind
:
RangeFragKind
:
:
Multi
first
:
frag_env
[
frag_ixs
[
s
]
]
.
first
last
:
frag_env
[
frag_ixs
[
e
]
]
.
last
count
:
Z_INVALID_COUNT
}
;
frag_env
.
push
(
zFrag
)
;
frag_ixs
[
w
]
=
RangeFragIx
:
:
new
(
frag_env
.
len
(
)
-
1
)
;
}
w
=
w
+
1
;
s
=
e
+
1
;
e
=
s
;
}
frag_ixs
.
truncate
(
w
)
;
fragsOUT
+
=
w
;
}
info
!
(
"
alloc_main
:
compress
frags
:
in
{
}
out
{
}
"
fragsIN
fragsOUT
)
;
}
#
[
derive
(
Clone
Copy
PartialEq
)
]
pub
(
crate
)
enum
BridgeKind
{
RtoU
RtoS
DtoS
}
impl
fmt
:
:
Debug
for
BridgeKind
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
BridgeKind
:
:
RtoU
=
>
write
!
(
fmt
"
R
-
>
U
"
)
BridgeKind
:
:
RtoS
=
>
write
!
(
fmt
"
R
-
>
S
"
)
BridgeKind
:
:
DtoS
=
>
write
!
(
fmt
"
D
-
>
S
"
)
}
}
}
#
[
derive
(
Clone
Copy
)
]
struct
EditListItem
{
slot
:
SpillSlot
vlrix
:
VirtualRangeIx
kind
:
BridgeKind
iix
:
InstIx
}
impl
fmt
:
:
Debug
for
EditListItem
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
(
ELI
:
at
{
:
?
}
for
{
:
?
}
add
{
:
?
}
slot
=
{
:
?
}
)
"
self
.
iix
self
.
vlrix
self
.
kind
self
.
slot
)
}
}
#
[
inline
(
never
)
]
pub
fn
alloc_main
<
F
:
Function
>
(
func
:
&
mut
F
reg_universe
:
&
RealRegUniverse
use_checker
:
bool
request_block_annotations
:
bool
)
-
>
Result
<
RegAllocResult
<
F
>
RegAllocError
>
{
let
analysis_info
=
run_analysis
(
func
reg_universe
)
.
map_err
(
|
err
|
RegAllocError
:
:
Analysis
(
err
)
)
?
;
let
reg_vecs_and_bounds
:
RegVecsAndBounds
=
analysis_info
.
0
;
let
rlr_env
:
TypedIxVec
<
RealRangeIx
RealRange
>
=
analysis_info
.
1
;
let
mut
vlr_env
:
TypedIxVec
<
VirtualRangeIx
VirtualRange
>
=
analysis_info
.
2
;
let
mut
frag_env
:
TypedIxVec
<
RangeFragIx
RangeFrag
>
=
analysis_info
.
3
;
let
_liveouts
:
TypedIxVec
<
BlockIx
SparseSet
<
Reg
>
>
=
analysis_info
.
4
;
let
est_freqs
:
TypedIxVec
<
BlockIx
u32
>
=
analysis_info
.
5
;
let
inst_to_block_map
:
InstIxToBlockIxMap
=
analysis_info
.
6
;
assert
!
(
reg_vecs_and_bounds
.
is_sanitized
(
)
)
;
let
coalescing_info
=
do_coalescing_analysis
(
func
&
reg_vecs_and_bounds
&
rlr_env
&
mut
vlr_env
&
frag_env
&
est_freqs
&
reg_universe
)
;
let
mut
hints
:
TypedIxVec
<
VirtualRangeIx
SmallVec
<
[
Hint
;
8
]
>
>
=
coalescing_info
.
0
;
let
vlrEquivClasses
:
UnionFindEquivClasses
<
VirtualRangeIx
>
=
coalescing_info
.
1
;
let
is_vv_boundary_move
:
TypedIxVec
<
InstIx
bool
>
=
coalescing_info
.
2
;
let
vreg_to_vlrs_map
:
Vec
<
SmallVec
<
[
VirtualRangeIx
;
3
]
>
>
=
coalescing_info
.
3
;
assert
!
(
hints
.
len
(
)
=
=
vlr_env
.
len
(
)
)
;
info
!
(
"
alloc_main
:
begin
"
)
;
info
!
(
"
alloc_main
:
in
:
{
}
insns
in
{
}
blocks
"
func
.
insns
(
)
.
len
(
)
func
.
blocks
(
)
.
len
(
)
)
;
let
num_vlrs_initial
=
vlr_env
.
len
(
)
;
info
!
(
"
alloc_main
:
in
:
{
}
VLRs
{
}
RLRs
"
num_vlrs_initial
rlr_env
.
len
(
)
)
;
let
mut
prioQ
=
VirtualRangePrioQ
:
:
new
(
&
vlr_env
)
;
let
mut
per_real_reg
=
Vec
:
:
<
PerRealReg
>
:
:
new
(
)
;
for
_
in
0
.
.
reg_universe
.
allocable
{
per_real_reg
.
push
(
PerRealReg
:
:
new
(
)
)
;
}
for
rlr
in
rlr_env
.
iter
(
)
{
let
rregIndex
=
rlr
.
rreg
.
get_index
(
)
;
if
rregIndex
>
=
reg_universe
.
allocable
{
continue
;
}
per_real_reg
[
rregIndex
]
.
add_RealRange
(
&
rlr
&
frag_env
&
vlr_env
)
;
}
do_vlr_frag_compression
(
&
mut
vlr_env
&
mut
frag_env
)
;
let
mut
edit_list_move
=
Vec
:
:
<
EditListItem
>
:
:
new
(
)
;
let
mut
edit_list_other
=
Vec
:
:
<
EditListItem
>
:
:
new
(
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
"
)
;
print_RA_state
(
"
Initial
"
&
reg_universe
&
prioQ
&
per_real_reg
&
edit_list_move
&
edit_list_other
&
vlr_env
&
frag_env
)
;
}
let
mut
vlr_slot_env
=
TypedIxVec
:
:
<
VirtualRangeIx
Option
<
SpillSlot
>
>
:
:
new
(
)
;
vlr_slot_env
.
resize
(
num_vlrs_initial
None
)
;
let
mut
spill_slot_allocator
=
SpillSlotAllocator
:
:
new
(
)
;
debug
!
(
"
"
)
;
debug
!
(
"
-
-
MAIN
ALLOCATION
LOOP
(
DI
means
'
direct
'
CO
means
'
coalesced
'
)
:
"
)
;
let
empty_Set_VirtualRangeIx
=
SparseSetU
:
:
<
[
VirtualRangeIx
;
16
]
>
:
:
empty
(
)
;
info
!
(
"
alloc_main
:
main
allocation
loop
:
begin
"
)
;
let
mut
num_vlrs_processed
=
0
;
let
mut
num_vlrs_spilled
=
0
;
let
mut
num_vlrs_evicted
=
0
;
'
main_allocation_loop
:
loop
{
debug
!
(
"
-
-
still
TODO
{
}
"
prioQ
.
len
(
)
)
;
if
false
{
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
"
)
;
print_RA_state
(
"
Loop
Top
"
&
reg_universe
&
prioQ
&
per_real_reg
&
edit_list_move
&
edit_list_other
&
vlr_env
&
frag_env
)
;
debug
!
(
"
"
)
;
}
}
let
mb_curr_vlrix
=
prioQ
.
get_longest_VirtualRange
(
)
;
if
mb_curr_vlrix
.
is_none
(
)
{
break
'
main_allocation_loop
;
}
num_vlrs_processed
+
=
1
;
let
curr_vlrix
=
mb_curr_vlrix
.
unwrap
(
)
;
let
curr_vlr
=
&
vlr_env
[
curr_vlrix
]
;
debug
!
(
"
-
-
considering
{
:
?
}
:
{
:
?
}
"
curr_vlrix
curr_vlr
)
;
assert
!
(
curr_vlr
.
vreg
.
to_reg
(
)
.
is_virtual
(
)
)
;
assert
!
(
curr_vlr
.
rreg
.
is_none
(
)
)
;
let
curr_vlr_regclass
=
curr_vlr
.
vreg
.
get_class
(
)
;
let
curr_vlr_rc
=
curr_vlr_regclass
.
rc_to_usize
(
)
;
assert
!
(
hints
.
len
(
)
=
=
vlr_env
.
len
(
)
)
;
let
mut
hinted_regs
=
SmallVec
:
:
<
[
RealReg
;
8
]
>
:
:
new
(
)
;
let
mut
mb_curr_vlr_eclass
:
Option
<
SparseSetU
<
[
VirtualRangeIx
;
16
]
>
>
=
None
;
if
curr_vlrix
.
get
(
)
<
hints
.
len
(
)
{
for
hint
in
&
hints
[
curr_vlrix
]
{
let
mb_cand
=
match
hint
{
Hint
:
:
SameAs
(
other_vlrix
_weight
)
=
>
{
vlr_env
[
*
other_vlrix
]
.
rreg
}
Hint
:
:
Exactly
(
rreg
_weight
)
=
>
Some
(
*
rreg
)
}
;
if
let
Some
(
rreg
)
=
mb_cand
{
if
!
hinted_regs
.
iter
(
)
.
any
(
|
r
|
*
r
=
=
rreg
)
{
hinted_regs
.
push
(
rreg
)
;
}
}
}
let
n_primary_cands
=
hinted_regs
.
len
(
)
;
if
curr_vlrix
.
get
(
)
<
num_vlrs_initial
{
let
mut
curr_vlr_eclass
=
SparseSetU
:
:
<
[
VirtualRangeIx
;
16
]
>
:
:
empty
(
)
;
for
vlrix
in
vlrEquivClasses
.
equiv_class_elems_iter
(
curr_vlrix
)
{
curr_vlr_eclass
.
insert
(
vlrix
)
;
}
assert
!
(
curr_vlr_eclass
.
contains
(
curr_vlrix
)
)
;
mb_curr_vlr_eclass
=
Some
(
curr_vlr_eclass
)
;
for
vlrix
in
vlrEquivClasses
.
equiv_class_elems_iter
(
curr_vlrix
)
{
if
vlrix
!
=
curr_vlrix
{
if
let
Some
(
rreg
)
=
vlr_env
[
vlrix
]
.
rreg
{
if
!
hinted_regs
.
iter
(
)
.
any
(
|
r
|
*
r
=
=
rreg
)
{
hinted_regs
.
push
(
rreg
)
;
}
}
}
}
hinted_regs
[
n_primary_cands
.
.
]
.
sort_by
(
|
rreg1
rreg2
|
{
rreg1
.
get_index
(
)
.
partial_cmp
(
&
rreg2
.
get_index
(
)
)
.
unwrap
(
)
}
)
;
}
if
log_enabled
!
(
Level
:
:
Debug
)
{
if
!
hinted_regs
.
is_empty
(
)
{
let
mut
candStr
=
"
pri
{
"
.
to_string
(
)
;
for
(
rreg
n
)
in
hinted_regs
.
iter
(
)
.
zip
(
0
.
.
)
{
if
n
=
=
n_primary_cands
{
candStr
=
candStr
+
&
"
}
sec
{
"
.
to_string
(
)
;
}
candStr
=
candStr
+
&
"
"
.
to_string
(
)
+
&
reg_universe
.
regs
[
rreg
.
get_index
(
)
]
.
1
;
}
candStr
=
candStr
+
&
"
}
"
;
debug
!
(
"
-
-
CO
candidates
{
}
"
candStr
)
;
}
}
}
for
rreg
in
&
hinted_regs
{
let
rregNo
=
rreg
.
get_index
(
)
;
let
do_not_evict
=
if
let
Some
(
ref
curr_vlr_eclass
)
=
mb_curr_vlr_eclass
{
curr_vlr_eclass
}
else
{
&
empty_Set_VirtualRangeIx
}
;
let
mb_evict_info
:
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
=
per_real_reg
[
rregNo
]
.
find_Evict_Set
(
curr_vlrix
do_not_evict
&
vlr_env
&
frag_env
)
;
if
let
Some
(
(
vlrixs_to_evict
total_evict_cost
)
)
=
mb_evict_info
{
assert
!
(
curr_vlr
.
rreg
.
is_none
(
)
)
;
assert
!
(
vlrixs_to_evict
.
is_empty
(
)
=
=
total_evict_cost
.
is_zero
(
)
)
;
assert
!
(
total_evict_cost
.
is_finite
(
)
)
;
assert
!
(
total_evict_cost
.
is_less_than
(
&
curr_vlr
.
spill_cost
)
)
;
for
vlrix_to_evict
in
vlrixs_to_evict
.
iter
(
)
{
assert
!
(
!
do_not_evict
.
contains
(
*
vlrix_to_evict
)
)
;
debug
!
(
"
-
-
CO
evict
{
:
?
}
:
{
:
?
}
"
*
vlrix_to_evict
&
vlr_env
[
*
vlrix_to_evict
]
)
;
per_real_reg
[
rregNo
]
.
del_VirtualRange
(
*
vlrix_to_evict
&
frag_env
&
vlr_env
)
;
prioQ
.
add_VirtualRange
(
&
vlr_env
*
vlrix_to_evict
)
;
debug_assert
!
(
vlr_env
[
*
vlrix_to_evict
]
.
rreg
.
is_some
(
)
)
;
vlr_env
[
*
vlrix_to_evict
]
.
rreg
=
None
;
num_vlrs_evicted
+
=
1
;
}
debug
!
(
"
-
-
CO
alloc
to
{
}
"
reg_universe
.
regs
[
rregNo
]
.
1
)
;
per_real_reg
[
rregNo
]
.
add_VirtualRange
(
curr_vlrix
&
frag_env
&
vlr_env
)
;
vlr_env
[
curr_vlrix
]
.
rreg
=
Some
(
*
rreg
)
;
continue
'
main_allocation_loop
;
}
}
let
(
first_in_rc
last_in_rc
)
=
match
&
reg_universe
.
allocable_by_class
[
curr_vlr_rc
]
{
&
None
=
>
{
return
Err
(
RegAllocError
:
:
OutOfRegisters
(
curr_vlr_regclass
)
)
;
}
&
Some
(
ref
info
)
=
>
(
info
.
first
info
.
last
)
}
;
let
mut
best_so_far
:
Option
<
(
usize
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
=
None
;
'
search_through_cand_rregs_loop
:
for
rregNo
in
first_in_rc
.
.
last_in_rc
+
1
{
let
mb_evict_info
:
Option
<
(
SparseSetU
<
[
VirtualRangeIx
;
4
]
>
SpillCost
)
>
=
per_real_reg
[
rregNo
]
.
find_Evict_Set
(
curr_vlrix
&
empty_Set_VirtualRangeIx
&
vlr_env
&
frag_env
)
;
if
let
Some
(
(
cand_vlrixs_to_evict
cand_total_evict_cost
)
)
=
mb_evict_info
{
assert
!
(
cand_vlrixs_to_evict
.
is_empty
(
)
=
=
cand_total_evict_cost
.
is_zero
(
)
)
;
assert
!
(
cand_total_evict_cost
.
is_finite
(
)
)
;
assert
!
(
cand_total_evict_cost
.
is_less_than
(
&
curr_vlr
.
spill_cost
)
)
;
let
mut
cand_is_better
=
cand_vlrixs_to_evict
.
is_empty
(
)
;
if
!
cand_is_better
{
if
let
Some
(
(
_
_
best_spill_cost
)
)
=
best_so_far
{
if
cand_total_evict_cost
.
is_less_than
(
&
best_spill_cost
)
{
cand_is_better
=
true
;
}
}
else
{
cand_is_better
=
true
;
}
}
let
cand_vlrixs_to_evict_is_empty
=
cand_vlrixs_to_evict
.
is_empty
(
)
;
if
cand_is_better
{
best_so_far
=
Some
(
(
rregNo
cand_vlrixs_to_evict
cand_total_evict_cost
)
)
;
}
if
cand_vlrixs_to_evict_is_empty
{
break
'
search_through_cand_rregs_loop
;
}
}
}
if
let
Some
(
(
rregNo
vlrixs_to_evict
total_spill_cost
)
)
=
best_so_far
{
debug_assert
!
(
curr_vlr
.
rreg
.
is_none
(
)
)
;
assert
!
(
total_spill_cost
.
is_finite
(
)
)
;
assert
!
(
total_spill_cost
.
is_less_than
(
&
curr_vlr
.
spill_cost
)
)
;
for
vlrix_to_evict
in
vlrixs_to_evict
.
iter
(
)
{
debug
!
(
"
-
-
DI
evict
{
:
?
}
:
{
:
?
}
"
*
vlrix_to_evict
&
vlr_env
[
*
vlrix_to_evict
]
)
;
per_real_reg
[
rregNo
]
.
del_VirtualRange
(
*
vlrix_to_evict
&
frag_env
&
vlr_env
)
;
prioQ
.
add_VirtualRange
(
&
vlr_env
*
vlrix_to_evict
)
;
debug_assert
!
(
vlr_env
[
*
vlrix_to_evict
]
.
rreg
.
is_some
(
)
)
;
vlr_env
[
*
vlrix_to_evict
]
.
rreg
=
None
;
num_vlrs_evicted
+
=
1
;
}
debug
!
(
"
-
-
DI
alloc
to
{
}
"
reg_universe
.
regs
[
rregNo
]
.
1
)
;
per_real_reg
[
rregNo
]
.
add_VirtualRange
(
curr_vlrix
&
frag_env
&
vlr_env
)
;
let
rreg
=
reg_universe
.
regs
[
rregNo
]
.
0
;
vlr_env
[
curr_vlrix
]
.
rreg
=
Some
(
rreg
)
;
continue
'
main_allocation_loop
;
}
debug
!
(
"
-
-
spill
"
)
;
if
curr_vlr
.
spill_cost
.
is_infinite
(
)
{
return
Err
(
RegAllocError
:
:
OutOfRegisters
(
curr_vlr_regclass
)
)
;
}
struct
SpillAndOrReloadInfo
{
bix
:
BlockIx
iix
:
InstIx
kind
:
BridgeKind
}
let
mut
sri_vec
=
Vec
:
:
<
SpillAndOrReloadInfo
>
:
:
new
(
)
;
let
curr_vlr_vreg
=
curr_vlr
.
vreg
;
let
curr_vlr_reg
=
curr_vlr_vreg
.
to_reg
(
)
;
for
fix
in
&
curr_vlr
.
sorted_frags
.
frag_ixs
{
let
frag
:
&
RangeFrag
=
&
frag_env
[
*
fix
]
;
for
iix
in
frag
.
first
.
iix
.
dotdot
(
frag
.
last
.
iix
.
plus
(
1
)
)
{
let
(
iix_uses_curr_vlr_reg
iix_defs_curr_vlr_reg
iix_mods_curr_vlr_reg
)
=
does_inst_use_def_or_mod_reg
(
&
reg_vecs_and_bounds
iix
curr_vlr_reg
)
;
if
!
iix_defs_curr_vlr_reg
&
&
!
iix_mods_curr_vlr_reg
&
&
!
iix_uses_curr_vlr_reg
{
continue
;
}
if
iix_uses_curr_vlr_reg
&
&
frag
.
contains
(
&
InstPoint
:
:
new_use
(
iix
)
)
{
debug_assert
!
(
!
iix_mods_curr_vlr_reg
)
;
let
bix
=
inst_to_block_map
.
map
(
iix
)
;
let
sri
=
SpillAndOrReloadInfo
{
bix
iix
kind
:
BridgeKind
:
:
RtoU
}
;
sri_vec
.
push
(
sri
)
;
}
if
iix_mods_curr_vlr_reg
&
&
frag
.
contains
(
&
InstPoint
:
:
new_use
(
iix
)
)
&
&
frag
.
contains
(
&
InstPoint
:
:
new_def
(
iix
)
)
{
debug_assert
!
(
!
iix_uses_curr_vlr_reg
)
;
debug_assert
!
(
!
iix_defs_curr_vlr_reg
)
;
let
bix
=
inst_to_block_map
.
map
(
iix
)
;
let
sri
=
SpillAndOrReloadInfo
{
bix
iix
kind
:
BridgeKind
:
:
RtoS
}
;
sri_vec
.
push
(
sri
)
;
}
if
iix_defs_curr_vlr_reg
&
&
frag
.
contains
(
&
InstPoint
:
:
new_def
(
iix
)
)
{
debug_assert
!
(
!
iix_mods_curr_vlr_reg
)
;
let
bix
=
inst_to_block_map
.
map
(
iix
)
;
let
sri
=
SpillAndOrReloadInfo
{
bix
iix
kind
:
BridgeKind
:
:
DtoS
}
;
sri_vec
.
push
(
sri
)
;
}
}
}
assert
!
(
vlr_slot_env
.
len
(
)
=
=
num_vlrs_initial
)
;
assert
!
(
curr_vlrix
<
VirtualRangeIx
:
:
new
(
num_vlrs_initial
)
)
;
if
vlr_slot_env
[
curr_vlrix
]
.
is_none
(
)
{
spill_slot_allocator
.
alloc_spill_slots
(
&
mut
vlr_slot_env
func
&
frag_env
&
vlr_env
&
vlrEquivClasses
curr_vlrix
)
;
assert
!
(
vlr_slot_env
[
curr_vlrix
]
.
is_some
(
)
)
;
}
let
spill_slot_to_use
=
vlr_slot_env
[
curr_vlrix
]
.
unwrap
(
)
;
for
sri
in
sri_vec
{
let
new_vlr_count
=
if
sri
.
kind
=
=
BridgeKind
:
:
RtoS
{
3
}
else
{
2
}
;
let
(
new_vlr_first_pt
new_vlr_last_pt
)
=
match
sri
.
kind
{
BridgeKind
:
:
RtoU
=
>
(
Point
:
:
Reload
Point
:
:
Use
)
BridgeKind
:
:
RtoS
=
>
(
Point
:
:
Reload
Point
:
:
Spill
)
BridgeKind
:
:
DtoS
=
>
(
Point
:
:
Def
Point
:
:
Spill
)
}
;
let
new_vlr_frag
=
RangeFrag
{
bix
:
sri
.
bix
kind
:
RangeFragKind
:
:
Local
first
:
InstPoint
:
:
new
(
sri
.
iix
new_vlr_first_pt
)
last
:
InstPoint
:
:
new
(
sri
.
iix
new_vlr_last_pt
)
count
:
new_vlr_count
}
;
let
new_vlr_fix
=
RangeFragIx
:
:
new
(
frag_env
.
len
(
)
as
u32
)
;
frag_env
.
push
(
new_vlr_frag
)
;
debug
!
(
"
-
-
new
RangeFrag
{
:
?
}
:
=
{
:
?
}
"
&
new_vlr_fix
&
new_vlr_frag
)
;
let
new_vlr_sfixs
=
SortedRangeFragIxs
:
:
unit
(
new_vlr_fix
&
frag_env
)
;
let
new_vlr
=
VirtualRange
{
vreg
:
curr_vlr_vreg
rreg
:
None
sorted_frags
:
new_vlr_sfixs
size
:
1
total_cost
:
0xFFFF_FFFFu32
spill_cost
:
SpillCost
:
:
infinite
(
)
}
;
let
new_vlrix
=
VirtualRangeIx
:
:
new
(
vlr_env
.
len
(
)
as
u32
)
;
debug
!
(
"
-
-
new
VirtRange
{
:
?
}
:
=
{
:
?
}
"
new_vlrix
&
new_vlr
)
;
vlr_env
.
push
(
new_vlr
)
;
prioQ
.
add_VirtualRange
(
&
vlr_env
new_vlrix
)
;
let
mut
new_vlr_hint
=
SmallVec
:
:
<
[
Hint
;
8
]
>
:
:
new
(
)
;
if
is_vv_boundary_move
[
sri
.
iix
]
{
let
im
=
func
.
is_move
(
&
func
.
get_insn
(
sri
.
iix
)
)
;
assert
!
(
im
.
is_some
(
)
)
;
let
(
wdst_reg
src_reg
)
:
(
Writable
<
Reg
>
Reg
)
=
im
.
unwrap
(
)
;
let
dst_reg
:
Reg
=
wdst_reg
.
to_reg
(
)
;
assert
!
(
src_reg
.
is_virtual
(
)
&
&
dst_reg
.
is_virtual
(
)
)
;
let
dst_vreg
:
VirtualReg
=
dst_reg
.
to_virtual_reg
(
)
;
let
src_vreg
:
VirtualReg
=
src_reg
.
to_virtual_reg
(
)
;
let
bridge_eef
=
est_freqs
[
sri
.
bix
]
;
match
sri
.
kind
{
BridgeKind
:
:
RtoU
=
>
{
for
vlrix
in
&
vreg_to_vlrs_map
[
dst_vreg
.
get_index
(
)
]
{
if
vlr_env
[
*
vlrix
]
.
vreg
=
=
dst_vreg
{
new_vlr_hint
.
push
(
Hint
:
:
SameAs
(
*
vlrix
bridge_eef
)
)
;
break
;
}
}
}
BridgeKind
:
:
DtoS
=
>
{
for
vlrix
in
&
vreg_to_vlrs_map
[
src_vreg
.
get_index
(
)
]
{
if
vlr_env
[
*
vlrix
]
.
vreg
=
=
src_vreg
{
new_vlr_hint
.
push
(
Hint
:
:
SameAs
(
*
vlrix
bridge_eef
)
)
;
break
;
}
}
}
BridgeKind
:
:
RtoS
=
>
{
panic
!
(
"
RtoS
bridge
for
v
-
v
boundary
move
"
)
;
}
}
}
hints
.
push
(
new_vlr_hint
)
;
let
new_eli
=
EditListItem
{
slot
:
spill_slot_to_use
vlrix
:
new_vlrix
kind
:
sri
.
kind
iix
:
sri
.
iix
}
;
if
is_vv_boundary_move
[
sri
.
iix
]
{
debug
!
(
"
-
-
new
ELI
MOVE
{
:
?
}
"
&
new_eli
)
;
edit_list_move
.
push
(
new_eli
)
;
}
else
{
debug
!
(
"
-
-
new
ELI
other
{
:
?
}
"
&
new_eli
)
;
edit_list_other
.
push
(
new_eli
)
;
}
}
num_vlrs_spilled
+
=
1
;
}
info
!
(
"
alloc_main
:
main
allocation
loop
:
end
"
)
;
if
log_enabled
!
(
Level
:
:
Debug
)
{
debug
!
(
"
"
)
;
print_RA_state
(
"
Final
"
&
reg_universe
&
prioQ
&
per_real_reg
&
edit_list_move
&
edit_list_other
&
vlr_env
&
frag_env
)
;
}
debug
!
(
"
"
)
;
info
!
(
"
alloc_main
:
create
spills_n_reloads
for
MOVE
insns
"
)
;
edit_list_move
.
sort_unstable_by
(
|
eli1
eli2
|
eli1
.
iix
.
cmp
(
&
eli2
.
iix
)
)
;
let
mut
iixs_to_nop_out
=
Vec
:
:
<
InstIx
>
:
:
new
(
)
;
let
n_edit_list_move
=
edit_list_move
.
len
(
)
;
let
mut
n_edit_list_move_processed
=
0
;
let
mut
i_min
=
0
;
loop
{
if
i_min
>
=
n_edit_list_move
{
break
;
}
debug
!
(
"
editlist
entry
(
MOVE
)
:
min
:
{
:
?
}
"
&
edit_list_move
[
i_min
]
)
;
let
i_min_iix
=
edit_list_move
[
i_min
]
.
iix
;
let
mut
i_max
=
i_min
;
while
i_max
+
1
<
n_edit_list_move
&
&
edit_list_move
[
i_max
+
1
]
.
iix
=
=
i_min_iix
{
i_max
+
=
1
;
debug
!
(
"
editlist
entry
(
MOVE
)
:
max
:
{
:
?
}
"
&
edit_list_move
[
i_max
]
)
;
}
assert
!
(
i_max
-
i_min
<
=
1
)
;
if
i_max
-
i_min
=
=
1
{
assert
!
(
is_vv_boundary_move
[
i_min_iix
]
)
;
let
vlrix1
=
edit_list_move
[
i_min
]
.
vlrix
;
let
vlrix2
=
edit_list_move
[
i_max
]
.
vlrix
;
assert
!
(
vlrix1
!
=
vlrix2
)
;
let
vlr1
=
&
vlr_env
[
vlrix1
]
;
let
vlr2
=
&
vlr_env
[
vlrix2
]
;
let
fixs1
=
&
vlr1
.
sorted_frags
;
let
fixs2
=
&
vlr2
.
sorted_frags
;
assert
!
(
fixs1
.
frag_ixs
.
len
(
)
=
=
1
)
;
assert
!
(
fixs2
.
frag_ixs
.
len
(
)
=
=
1
)
;
let
frag1
=
&
frag_env
[
fixs1
.
frag_ixs
[
0
]
]
;
let
frag2
=
&
frag_env
[
fixs2
.
frag_ixs
[
0
]
]
;
assert
!
(
frag1
.
first
.
iix
=
=
i_min_iix
)
;
assert
!
(
frag1
.
last
.
iix
=
=
i_min_iix
)
;
assert
!
(
frag2
.
first
.
iix
=
=
i_min_iix
)
;
assert
!
(
frag2
.
last
.
iix
=
=
i_min_iix
)
;
match
(
frag1
.
first
.
pt
frag1
.
last
.
pt
frag2
.
first
.
pt
frag2
.
last
.
pt
)
{
(
Point
:
:
Reload
Point
:
:
Use
Point
:
:
Def
Point
:
:
Spill
)
|
(
Point
:
:
Def
Point
:
:
Spill
Point
:
:
Reload
Point
:
:
Use
)
=
>
{
let
slot1
=
edit_list_move
[
i_min
]
.
slot
;
let
slot2
=
edit_list_move
[
i_max
]
.
slot
;
if
slot1
=
=
slot2
{
debug
!
(
"
editlist
entry
(
MOVE
)
:
delete
{
:
?
}
"
i_min_iix
)
;
iixs_to_nop_out
.
push
(
i_min_iix
)
;
i_min
=
i_max
+
1
;
n_edit_list_move_processed
+
=
2
;
continue
;
}
}
(
_
_
_
_
)
=
>
{
panic
!
(
"
spill
slot
coalescing
edit_list_move
:
unexpected
frags
"
)
;
}
}
}
for
i
in
i_min
.
.
=
i_max
{
edit_list_other
.
push
(
edit_list_move
[
i
]
)
;
n_edit_list_move_processed
+
=
1
;
}
i_min
=
i_max
+
1
;
}
assert
!
(
n_edit_list_move_processed
=
=
n_edit_list_move
)
;
debug
!
(
"
"
)
;
info
!
(
"
alloc_main
:
create
spills_n_reloads
for
other
insns
"
)
;
let
mut
spills_n_reloads
=
Vec
:
:
<
InstToInsertAndPoint
>
:
:
new
(
)
;
let
mut
num_spills
=
0
;
let
mut
num_reloads
=
0
;
for
eli
in
&
edit_list_other
{
debug
!
(
"
editlist
entry
(
other
)
:
{
:
?
}
"
eli
)
;
let
vlr
=
&
vlr_env
[
eli
.
vlrix
]
;
let
vlr_sfrags
=
&
vlr
.
sorted_frags
;
debug_assert
!
(
vlr
.
sorted_frags
.
frag_ixs
.
len
(
)
=
=
1
)
;
let
vlr_frag
=
frag_env
[
vlr_sfrags
.
frag_ixs
[
0
]
]
;
let
rreg
=
vlr
.
rreg
.
expect
(
"
Gen
of
spill
/
reload
:
reg
not
assigned
?
!
"
)
;
let
vreg
=
vlr
.
vreg
;
match
eli
.
kind
{
BridgeKind
:
:
RtoU
=
>
{
debug_assert
!
(
vlr_frag
.
first
.
pt
.
is_reload
(
)
)
;
debug_assert
!
(
vlr_frag
.
last
.
pt
.
is_use
(
)
)
;
debug_assert
!
(
vlr_frag
.
first
.
iix
=
=
vlr_frag
.
last
.
iix
)
;
let
insnR
=
InstToInsert
:
:
Reload
{
to_reg
:
Writable
:
:
from_reg
(
rreg
)
from_slot
:
eli
.
slot
for_vreg
:
vreg
}
;
let
whereToR
=
vlr_frag
.
first
;
spills_n_reloads
.
push
(
InstToInsertAndPoint
:
:
new
(
insnR
whereToR
)
)
;
num_reloads
+
=
1
;
}
BridgeKind
:
:
RtoS
=
>
{
debug_assert
!
(
vlr_frag
.
first
.
pt
.
is_reload
(
)
)
;
debug_assert
!
(
vlr_frag
.
last
.
pt
.
is_spill
(
)
)
;
debug_assert
!
(
vlr_frag
.
first
.
iix
=
=
vlr_frag
.
last
.
iix
)
;
let
insnR
=
InstToInsert
:
:
Reload
{
to_reg
:
Writable
:
:
from_reg
(
rreg
)
from_slot
:
eli
.
slot
for_vreg
:
vreg
}
;
let
whereToR
=
vlr_frag
.
first
;
let
insnS
=
InstToInsert
:
:
Spill
{
to_slot
:
eli
.
slot
from_reg
:
rreg
for_vreg
:
vreg
}
;
let
whereToS
=
vlr_frag
.
last
;
spills_n_reloads
.
push
(
InstToInsertAndPoint
:
:
new
(
insnR
whereToR
)
)
;
spills_n_reloads
.
push
(
InstToInsertAndPoint
:
:
new
(
insnS
whereToS
)
)
;
num_reloads
+
=
1
;
num_spills
+
=
1
;
}
BridgeKind
:
:
DtoS
=
>
{
debug_assert
!
(
vlr_frag
.
first
.
pt
.
is_def
(
)
)
;
debug_assert
!
(
vlr_frag
.
last
.
pt
.
is_spill
(
)
)
;
debug_assert
!
(
vlr_frag
.
first
.
iix
=
=
vlr_frag
.
last
.
iix
)
;
let
insnS
=
InstToInsert
:
:
Spill
{
to_slot
:
eli
.
slot
from_reg
:
rreg
for_vreg
:
vreg
}
;
let
whereToS
=
vlr_frag
.
last
;
spills_n_reloads
.
push
(
InstToInsertAndPoint
:
:
new
(
insnS
whereToS
)
)
;
num_spills
+
=
1
;
}
}
}
info
!
(
"
alloc_main
:
create
frag_map
"
)
;
let
mut
frag_map
=
Vec
:
:
<
(
RangeFragIx
VirtualReg
RealReg
)
>
:
:
new
(
)
;
for
i
in
0
.
.
reg_universe
.
allocable
{
let
rreg
=
reg_universe
.
regs
[
i
]
.
0
;
for
vlrix_assigned
in
per_real_reg
[
i
]
.
vlrixs_assigned
.
iter
(
)
{
let
VirtualRange
{
vreg
sorted_frags
.
.
}
=
&
vlr_env
[
*
vlrix_assigned
]
;
for
fix
in
&
sorted_frags
.
frag_ixs
{
frag_map
.
push
(
(
*
fix
*
vreg
rreg
)
)
;
}
}
}
info
!
(
"
alloc_main
:
edit_inst_stream
"
)
;
let
final_insns_and_targetmap__or_err
=
edit_inst_stream
(
func
spills_n_reloads
&
iixs_to_nop_out
frag_map
&
frag_env
&
reg_universe
use_checker
)
;
match
final_insns_and_targetmap__or_err
{
Ok
(
(
ref
final_insns
.
.
)
)
=
>
{
info
!
(
"
alloc_main
:
out
:
VLRs
:
{
}
initially
{
}
processed
"
num_vlrs_initial
num_vlrs_processed
)
;
info
!
(
"
alloc_main
:
out
:
VLRs
:
{
}
evicted
{
}
spilled
"
num_vlrs_evicted
num_vlrs_spilled
)
;
info
!
(
"
alloc_main
:
out
:
insns
:
{
}
total
{
}
spills
{
}
reloads
{
}
nopzs
"
final_insns
.
len
(
)
num_spills
num_reloads
iixs_to_nop_out
.
len
(
)
)
;
info
!
(
"
alloc_main
:
out
:
spill
slots
:
{
}
used
"
spill_slot_allocator
.
num_slots_in_use
(
)
)
;
}
Err
(
_
)
=
>
{
info
!
(
"
alloc_main
:
allocation
failed
!
"
)
;
}
}
let
(
final_insns
target_map
orig_insn_map
)
=
match
final_insns_and_targetmap__or_err
{
Err
(
e
)
=
>
{
info
!
(
"
alloc_main
:
fail
"
)
;
return
Err
(
e
)
;
}
Ok
(
pair
)
=
>
{
info
!
(
"
alloc_main
:
creating
RegAllocResult
"
)
;
pair
}
}
;
let
mut
clobbered_registers
:
Set
<
RealReg
>
=
Set
:
:
empty
(
)
;
let
mut
reg_vecs
=
RegVecs
:
:
new
(
false
)
;
let
mut
dummy_bounds
=
RegVecBounds
:
:
new
(
)
;
for
insn
in
&
final_insns
{
add_raw_reg_vecs_for_insn
:
:
<
F
>
(
insn
&
mut
reg_vecs
&
mut
dummy_bounds
)
;
}
for
reg
in
reg_vecs
.
defs
.
iter
(
)
.
chain
(
reg_vecs
.
mods
.
iter
(
)
)
{
assert
!
(
reg
.
is_real
(
)
)
;
clobbered_registers
.
insert
(
reg
.
to_real_reg
(
)
)
;
}
clobbered_registers
.
filter_map
(
|
&
reg
|
{
if
reg
.
get_index
(
)
>
=
reg_universe
.
allocable
{
None
}
else
{
Some
(
reg
)
}
}
)
;
assert
!
(
est_freqs
.
len
(
)
as
usize
=
=
func
.
blocks
(
)
.
len
(
)
)
;
let
mut
block_annotations
=
None
;
if
request_block_annotations
{
let
mut
anns
=
TypedIxVec
:
:
<
BlockIx
Vec
<
String
>
>
:
:
new
(
)
;
for
(
estFreq
i
)
in
est_freqs
.
iter
(
)
.
zip
(
0
.
.
)
{
let
bix
=
BlockIx
:
:
new
(
i
)
;
let
ef_str
=
format
!
(
"
RA
:
bix
{
:
?
}
estFreq
{
}
"
bix
estFreq
)
;
anns
.
push
(
vec
!
[
ef_str
]
)
;
}
block_annotations
=
Some
(
anns
)
;
}
let
ra_res
=
RegAllocResult
{
insns
:
final_insns
target_map
orig_insn_map
clobbered_registers
num_spill_slots
:
spill_slot_allocator
.
num_slots_in_use
(
)
as
u32
block_annotations
}
;
info
!
(
"
alloc_main
:
end
"
)
;
Ok
(
ra_res
)
}
