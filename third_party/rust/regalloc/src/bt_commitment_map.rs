#
!
[
allow
(
non_snake_case
)
]
#
!
[
allow
(
non_camel_case_types
)
]
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
fmt
;
use
crate
:
:
avl_tree
:
:
AVLTree
;
use
crate
:
:
data_structures
:
:
{
cmp_range_frags
RangeFrag
RangeFragIx
SortedRangeFragIxs
SortedRangeFrags
TypedIxVec
VirtualRangeIx
}
;
#
[
derive
(
Clone
)
]
pub
struct
RangeFragAndVLRIx
{
pub
frag
:
RangeFrag
pub
mb_vlrix
:
Option
<
VirtualRangeIx
>
}
impl
RangeFragAndVLRIx
{
fn
new
(
frag
:
RangeFrag
mb_vlrix
:
Option
<
VirtualRangeIx
>
)
-
>
Self
{
Self
{
frag
mb_vlrix
}
}
}
impl
PartialEq
for
RangeFragAndVLRIx
{
fn
eq
(
&
self
_other
:
&
Self
)
-
>
bool
{
panic
!
(
"
impl
PartialEq
for
RangeFragAndVLRIx
:
should
never
be
used
"
)
;
}
}
impl
PartialOrd
for
RangeFragAndVLRIx
{
fn
partial_cmp
(
&
self
_other
:
&
Self
)
-
>
Option
<
Ordering
>
{
panic
!
(
"
impl
PartialOrd
for
RangeFragAndVLRIx
:
should
never
be
used
"
)
;
}
}
impl
fmt
:
:
Debug
for
RangeFragAndVLRIx
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
vlrix_string
=
match
self
.
mb_vlrix
{
None
=
>
"
NONE
"
.
to_string
(
)
Some
(
vlrix
)
=
>
format
!
(
"
{
:
?
}
"
vlrix
)
}
;
write
!
(
fmt
"
(
FnV
{
:
?
}
{
}
)
"
self
.
frag
vlrix_string
)
}
}
pub
struct
CommitmentMap
{
pub
tree
:
AVLTree
<
RangeFragAndVLRIx
>
}
impl
fmt
:
:
Debug
for
CommitmentMap
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
as_vec
=
self
.
tree
.
to_vec
(
)
;
as_vec
.
fmt
(
fmt
)
}
}
impl
CommitmentMap
{
pub
fn
new
(
)
-
>
Self
{
let
dflt
=
RangeFragAndVLRIx
:
:
new
(
RangeFrag
:
:
invalid_value
(
)
Some
(
VirtualRangeIx
:
:
invalid_value
(
)
)
)
;
Self
{
tree
:
AVLTree
:
:
<
RangeFragAndVLRIx
>
:
:
new
(
dflt
)
}
}
pub
fn
add
(
&
mut
self
to_add_frags
:
&
SortedRangeFrags
to_add_mb_vlrix
:
Option
<
VirtualRangeIx
>
)
{
for
frag
in
&
to_add_frags
.
frags
{
let
to_add
=
RangeFragAndVLRIx
:
:
new
(
frag
.
clone
(
)
to_add_mb_vlrix
)
;
let
added
=
self
.
tree
.
insert
(
to_add
Some
(
&
|
pair1
:
RangeFragAndVLRIx
pair2
:
RangeFragAndVLRIx
|
{
cmp_range_frags
(
&
pair1
.
frag
&
pair2
.
frag
)
}
)
)
;
assert
!
(
added
)
;
}
}
pub
fn
add_indirect
(
&
mut
self
to_add_frags
:
&
SortedRangeFragIxs
to_add_mb_vlrix
:
Option
<
VirtualRangeIx
>
frag_env
:
&
TypedIxVec
<
RangeFragIx
RangeFrag
>
)
{
for
fix
in
&
to_add_frags
.
frag_ixs
{
let
to_add
=
RangeFragAndVLRIx
:
:
new
(
frag_env
[
*
fix
]
.
clone
(
)
to_add_mb_vlrix
)
;
let
added
=
self
.
tree
.
insert
(
to_add
Some
(
&
|
pair1
:
RangeFragAndVLRIx
pair2
:
RangeFragAndVLRIx
|
{
cmp_range_frags
(
&
pair1
.
frag
&
pair2
.
frag
)
}
)
)
;
assert
!
(
added
)
;
}
}
pub
fn
del
(
&
mut
self
to_del_frags
:
&
SortedRangeFrags
)
{
for
frag
in
&
to_del_frags
.
frags
{
let
to_del
=
RangeFragAndVLRIx
:
:
new
(
frag
.
clone
(
)
None
)
;
let
deleted
=
self
.
tree
.
delete
(
to_del
Some
(
&
|
pair1
:
RangeFragAndVLRIx
pair2
:
RangeFragAndVLRIx
|
{
cmp_range_frags
(
&
pair1
.
frag
&
pair2
.
frag
)
}
)
)
;
assert
!
(
deleted
)
;
}
}
}
