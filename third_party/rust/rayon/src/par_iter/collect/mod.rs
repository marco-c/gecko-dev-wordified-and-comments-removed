use
super
:
:
ExactParallelIterator
;
use
std
:
:
isize
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
mod
consumer
;
use
self
:
:
consumer
:
:
CollectConsumer
;
pub
fn
collect_into
<
PAR_ITER
T
>
(
mut
pi
:
PAR_ITER
v
:
&
mut
Vec
<
T
>
)
where
PAR_ITER
:
ExactParallelIterator
<
Item
=
T
>
PAR_ITER
:
ExactParallelIterator
T
:
Send
{
let
len
=
pi
.
len
(
)
;
assert
!
(
len
<
isize
:
:
MAX
as
usize
)
;
v
.
truncate
(
0
)
;
v
.
reserve
(
len
)
;
let
target
=
v
.
as_mut_ptr
(
)
;
let
writes
=
AtomicUsize
:
:
new
(
0
)
;
let
consumer
=
unsafe
{
CollectConsumer
:
:
new
(
&
writes
target
len
)
}
;
pi
.
drive
(
consumer
)
;
unsafe
{
let
actual_writes
=
writes
.
load
(
Ordering
:
:
Relaxed
)
;
assert
!
(
actual_writes
=
=
len
"
expected
{
}
total
writes
but
got
{
}
"
len
actual_writes
)
;
v
.
set_len
(
len
)
;
}
}
