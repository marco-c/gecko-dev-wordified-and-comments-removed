use
super
:
:
super
:
:
len
:
:
*
;
use
super
:
:
super
:
:
internal
:
:
*
;
use
super
:
:
super
:
:
noop
:
:
*
;
use
std
:
:
ptr
;
use
std
:
:
slice
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
pub
struct
CollectConsumer
<
'
c
ITEM
:
Send
+
'
c
>
{
writes
:
&
'
c
AtomicUsize
target
:
&
'
c
mut
[
ITEM
]
}
pub
struct
CollectFolder
<
'
c
ITEM
:
Send
+
'
c
>
{
global_writes
:
&
'
c
AtomicUsize
local_writes
:
usize
target
:
slice
:
:
IterMut
<
'
c
ITEM
>
}
impl
<
'
c
ITEM
:
Send
+
'
c
>
CollectConsumer
<
'
c
ITEM
>
{
pub
fn
new
(
writes
:
&
'
c
AtomicUsize
target
:
&
'
c
mut
[
ITEM
]
)
-
>
CollectConsumer
<
'
c
ITEM
>
{
CollectConsumer
{
writes
:
writes
target
:
target
}
}
}
impl
<
'
c
ITEM
:
Send
+
'
c
>
Consumer
<
ITEM
>
for
CollectConsumer
<
'
c
ITEM
>
{
type
Folder
=
CollectFolder
<
'
c
ITEM
>
;
type
Reducer
=
NoopReducer
;
type
Result
=
(
)
;
fn
cost
(
&
mut
self
cost
:
f64
)
-
>
f64
{
cost
*
FUNC_ADJUSTMENT
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
NoopReducer
)
{
let
CollectConsumer
{
writes
target
}
=
self
;
let
(
left
right
)
=
target
.
split_at_mut
(
index
)
;
(
CollectConsumer
:
:
new
(
writes
left
)
CollectConsumer
:
:
new
(
writes
right
)
NoopReducer
)
}
fn
into_folder
(
self
)
-
>
CollectFolder
<
'
c
ITEM
>
{
CollectFolder
{
global_writes
:
self
.
writes
local_writes
:
0
target
:
self
.
target
.
into_iter
(
)
}
}
}
impl
<
'
c
ITEM
:
Send
+
'
c
>
Folder
<
ITEM
>
for
CollectFolder
<
'
c
ITEM
>
{
type
Result
=
(
)
;
fn
consume
(
mut
self
item
:
ITEM
)
-
>
CollectFolder
<
'
c
ITEM
>
{
let
head
=
self
.
target
.
next
(
)
.
expect
(
"
too
many
values
pushed
to
consumer
"
)
;
unsafe
{
ptr
:
:
write
(
head
item
)
;
}
self
.
local_writes
+
=
1
;
self
}
fn
complete
(
self
)
{
assert
!
(
self
.
target
.
len
(
)
=
=
0
"
too
few
values
pushed
to
consumer
"
)
;
self
.
global_writes
.
fetch_add
(
self
.
local_writes
Ordering
:
:
Relaxed
)
;
}
}
impl
<
'
c
ITEM
:
Send
+
'
c
>
UnindexedConsumer
<
ITEM
>
for
CollectConsumer
<
'
c
ITEM
>
{
fn
split_off
(
&
self
)
-
>
Self
{
unreachable
!
(
"
CollectConsumer
must
be
indexed
!
"
)
}
fn
to_reducer
(
&
self
)
-
>
Self
:
:
Reducer
{
NoopReducer
}
}
