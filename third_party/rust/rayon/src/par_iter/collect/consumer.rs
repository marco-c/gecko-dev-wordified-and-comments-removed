use
super
:
:
super
:
:
len
:
:
*
;
use
super
:
:
super
:
:
internal
:
:
*
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
pub
struct
CollectConsumer
<
'
c
ITEM
:
Send
>
{
writes
:
&
'
c
AtomicUsize
target
:
*
mut
ITEM
len
:
usize
}
pub
struct
CollectFolder
<
'
c
ITEM
:
Send
>
{
consumer
:
CollectConsumer
<
'
c
ITEM
>
offset
:
usize
}
unsafe
impl
<
'
c
ITEM
:
Send
>
Send
for
CollectConsumer
<
'
c
ITEM
>
{
}
impl
<
'
c
ITEM
:
Send
>
CollectConsumer
<
'
c
ITEM
>
{
pub
unsafe
fn
new
(
writes
:
&
'
c
AtomicUsize
target
:
*
mut
ITEM
len
:
usize
)
-
>
CollectConsumer
<
ITEM
>
{
CollectConsumer
{
writes
:
writes
target
:
target
len
:
len
}
}
}
impl
<
'
c
ITEM
:
Send
>
Consumer
<
ITEM
>
for
CollectConsumer
<
'
c
ITEM
>
{
type
Folder
=
CollectFolder
<
'
c
ITEM
>
;
type
Reducer
=
NoopReducer
;
type
Result
=
(
)
;
fn
cost
(
&
mut
self
cost
:
f64
)
-
>
f64
{
cost
*
FUNC_ADJUSTMENT
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
NoopReducer
)
{
let
CollectConsumer
{
writes
target
len
}
=
self
;
assert
!
(
index
<
=
len
"
out
of
bounds
index
in
collect
"
)
;
unsafe
{
(
CollectConsumer
:
:
new
(
writes
target
index
)
CollectConsumer
:
:
new
(
writes
target
.
offset
(
index
as
isize
)
len
-
index
)
NoopReducer
)
}
}
fn
into_folder
(
self
)
-
>
CollectFolder
<
'
c
ITEM
>
{
CollectFolder
{
consumer
:
self
offset
:
0
}
}
}
impl
<
'
c
ITEM
:
Send
>
Folder
<
ITEM
>
for
CollectFolder
<
'
c
ITEM
>
{
type
Result
=
(
)
;
fn
consume
(
mut
self
item
:
ITEM
)
-
>
CollectFolder
<
'
c
ITEM
>
{
assert
!
(
self
.
offset
<
self
.
consumer
.
len
"
too
many
values
pushed
to
consumer
"
)
;
unsafe
{
let
target
=
self
.
consumer
.
target
.
offset
(
self
.
offset
as
isize
)
;
ptr
:
:
write
(
target
item
)
;
}
self
.
offset
+
=
1
;
self
}
fn
complete
(
self
)
{
assert
!
(
self
.
offset
=
=
self
.
consumer
.
len
"
too
few
values
pushed
to
consumer
"
)
;
self
.
consumer
.
writes
.
fetch_add
(
self
.
consumer
.
len
Ordering
:
:
SeqCst
)
;
}
}
