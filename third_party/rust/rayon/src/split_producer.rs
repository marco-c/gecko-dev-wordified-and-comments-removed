use
iter
:
:
plumbing
:
:
{
Folder
UnindexedProducer
}
;
pub
(
super
)
struct
SplitProducer
<
'
p
P
:
'
p
V
>
{
data
:
V
separator
:
&
'
p
P
tail
:
usize
}
pub
(
super
)
trait
Fissile
<
P
>
:
Sized
{
fn
length
(
&
self
)
-
>
usize
;
fn
midpoint
(
&
self
end
:
usize
)
-
>
usize
;
fn
find
(
&
self
separator
:
&
P
start
:
usize
end
:
usize
)
-
>
Option
<
usize
>
;
fn
rfind
(
&
self
separator
:
&
P
end
:
usize
)
-
>
Option
<
usize
>
;
fn
split_once
(
self
index
:
usize
)
-
>
(
Self
Self
)
;
fn
fold_splits
<
F
>
(
self
separator
:
&
P
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
Self
>
Self
:
Send
;
}
impl
<
'
p
P
V
>
SplitProducer
<
'
p
P
V
>
where
V
:
Fissile
<
P
>
+
Send
{
pub
(
super
)
fn
new
(
data
:
V
separator
:
&
'
p
P
)
-
>
Self
{
SplitProducer
{
tail
:
data
.
length
(
)
data
separator
}
}
pub
(
super
)
fn
fold_with
<
F
>
(
self
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
V
>
{
let
SplitProducer
{
data
separator
tail
}
=
self
;
if
tail
=
=
data
.
length
(
)
{
data
.
fold_splits
(
separator
folder
skip_last
)
}
else
if
let
Some
(
index
)
=
data
.
rfind
(
separator
tail
)
{
let
(
left
right
)
=
data
.
split_once
(
index
)
;
let
folder
=
left
.
fold_splits
(
separator
folder
false
)
;
if
skip_last
|
|
folder
.
full
(
)
{
folder
}
else
{
folder
.
consume
(
right
)
}
}
else
{
if
skip_last
{
folder
}
else
{
folder
.
consume
(
data
)
}
}
}
}
impl
<
'
p
P
V
>
UnindexedProducer
for
SplitProducer
<
'
p
P
V
>
where
V
:
Fissile
<
P
>
+
Send
P
:
Sync
{
type
Item
=
V
;
fn
split
(
self
)
-
>
(
Self
Option
<
Self
>
)
{
let
mid
=
self
.
data
.
midpoint
(
self
.
tail
)
;
let
index
=
self
.
data
.
find
(
self
.
separator
mid
self
.
tail
)
.
map
(
|
i
|
mid
+
i
)
.
or_else
(
|
|
self
.
data
.
rfind
(
self
.
separator
mid
)
)
;
if
let
Some
(
index
)
=
index
{
let
len
=
self
.
data
.
length
(
)
;
let
(
left
right
)
=
self
.
data
.
split_once
(
index
)
;
let
(
left_tail
right_tail
)
=
if
index
<
mid
{
(
index
0
)
}
else
{
let
right_index
=
len
-
right
.
length
(
)
;
(
mid
self
.
tail
-
right_index
)
}
;
let
left
=
SplitProducer
{
data
:
left
tail
:
left_tail
.
.
self
}
;
let
right
=
SplitProducer
{
data
:
right
tail
:
right_tail
.
.
self
}
;
(
left
Some
(
right
)
)
}
else
{
(
SplitProducer
{
tail
:
0
.
.
self
}
None
)
}
}
fn
fold_with
<
F
>
(
self
folder
:
F
)
-
>
F
where
F
:
Folder
<
Self
:
:
Item
>
{
self
.
fold_with
(
folder
false
)
}
}
