use
iter
:
:
*
;
use
iter
:
:
internal
:
:
*
;
use
std
:
:
cmp
:
:
min
;
fn
is_char_boundary
(
b
:
u8
)
-
>
bool
{
(
b
as
i8
)
>
=
-
0x40
}
fn
find_char_midpoint
(
chars
:
&
str
)
-
>
usize
{
let
mid
=
chars
.
len
(
)
/
2
;
let
(
left
right
)
=
chars
.
as_bytes
(
)
.
split_at
(
mid
)
;
right
.
iter
(
)
.
cloned
(
)
.
position
(
is_char_boundary
)
.
map
(
|
i
|
mid
+
i
)
.
or_else
(
|
|
left
.
iter
(
)
.
cloned
(
)
.
rposition
(
is_char_boundary
)
)
.
unwrap_or
(
0
)
}
pub
trait
ParallelString
{
private_decl
!
{
}
fn
par_chars
(
&
self
)
-
>
Chars
;
fn
par_split
<
P
:
Pattern
>
(
&
self
P
)
-
>
Split
<
P
>
;
fn
par_split_terminator
<
P
:
Pattern
>
(
&
self
P
)
-
>
SplitTerminator
<
P
>
;
fn
par_lines
(
&
self
)
-
>
Lines
;
fn
par_split_whitespace
(
&
self
)
-
>
SplitWhitespace
;
}
impl
ParallelString
for
str
{
private_impl
!
{
}
fn
par_chars
(
&
self
)
-
>
Chars
{
Chars
{
chars
:
self
}
}
fn
par_split
<
P
:
Pattern
>
(
&
self
separator
:
P
)
-
>
Split
<
P
>
{
Split
:
:
new
(
self
separator
)
}
fn
par_split_terminator
<
P
:
Pattern
>
(
&
self
terminator
:
P
)
-
>
SplitTerminator
<
P
>
{
SplitTerminator
:
:
new
(
self
terminator
)
}
fn
par_lines
(
&
self
)
-
>
Lines
{
Lines
(
self
)
}
fn
par_split_whitespace
(
&
self
)
-
>
SplitWhitespace
{
SplitWhitespace
(
self
)
}
}
pub
trait
Pattern
:
Sized
+
Sync
{
private_decl
!
{
}
fn
find_in
(
&
self
&
str
)
-
>
Option
<
usize
>
;
fn
rfind_in
(
&
self
&
str
)
-
>
Option
<
usize
>
;
fn
is_suffix_of
(
&
self
&
str
)
-
>
bool
;
fn
fold_with
<
'
ch
F
>
(
&
self
&
'
ch
str
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
&
'
ch
str
>
;
}
impl
Pattern
for
char
{
private_impl
!
{
}
fn
find_in
(
&
self
chars
:
&
str
)
-
>
Option
<
usize
>
{
chars
.
find
(
*
self
)
}
fn
rfind_in
(
&
self
chars
:
&
str
)
-
>
Option
<
usize
>
{
chars
.
rfind
(
*
self
)
}
fn
is_suffix_of
(
&
self
chars
:
&
str
)
-
>
bool
{
chars
.
ends_with
(
*
self
)
}
fn
fold_with
<
'
ch
F
>
(
&
self
chars
:
&
'
ch
str
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
&
'
ch
str
>
{
let
mut
split
=
chars
.
split
(
*
self
)
;
if
skip_last
{
split
.
next_back
(
)
;
}
folder
.
consume_iter
(
split
)
}
}
impl
<
FN
:
Sync
+
Fn
(
char
)
-
>
bool
>
Pattern
for
FN
{
private_impl
!
{
}
fn
find_in
(
&
self
chars
:
&
str
)
-
>
Option
<
usize
>
{
chars
.
find
(
self
)
}
fn
rfind_in
(
&
self
chars
:
&
str
)
-
>
Option
<
usize
>
{
chars
.
rfind
(
self
)
}
fn
is_suffix_of
(
&
self
chars
:
&
str
)
-
>
bool
{
chars
.
ends_with
(
self
)
}
fn
fold_with
<
'
ch
F
>
(
&
self
chars
:
&
'
ch
str
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
&
'
ch
str
>
{
let
mut
split
=
chars
.
split
(
self
)
;
if
skip_last
{
split
.
next_back
(
)
;
}
folder
.
consume_iter
(
split
)
}
}
pub
struct
Chars
<
'
ch
>
{
chars
:
&
'
ch
str
}
struct
CharsProducer
<
'
ch
>
{
chars
:
&
'
ch
str
}
impl
<
'
ch
>
ParallelIterator
for
Chars
<
'
ch
>
{
type
Item
=
char
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge_unindexed
(
CharsProducer
{
chars
:
self
.
chars
}
consumer
)
}
}
impl
<
'
ch
>
UnindexedProducer
for
CharsProducer
<
'
ch
>
{
type
Item
=
char
;
fn
split
(
mut
self
)
-
>
(
Self
Option
<
Self
>
)
{
let
index
=
find_char_midpoint
(
self
.
chars
)
;
if
index
>
0
{
let
(
left
right
)
=
self
.
chars
.
split_at
(
index
)
;
self
.
chars
=
left
;
(
self
Some
(
CharsProducer
{
chars
:
right
}
)
)
}
else
{
(
self
None
)
}
}
fn
fold_with
<
F
>
(
self
folder
:
F
)
-
>
F
where
F
:
Folder
<
Self
:
:
Item
>
{
folder
.
consume_iter
(
self
.
chars
.
chars
(
)
)
}
}
pub
struct
Split
<
'
ch
P
:
Pattern
>
{
chars
:
&
'
ch
str
separator
:
P
}
struct
SplitProducer
<
'
ch
'
sep
P
:
Pattern
+
'
sep
>
{
chars
:
&
'
ch
str
separator
:
&
'
sep
P
tail
:
usize
}
impl
<
'
ch
P
:
Pattern
>
Split
<
'
ch
P
>
{
fn
new
(
chars
:
&
'
ch
str
separator
:
P
)
-
>
Self
{
Split
{
chars
:
chars
separator
:
separator
}
}
}
impl
<
'
ch
'
sep
P
:
Pattern
+
'
sep
>
SplitProducer
<
'
ch
'
sep
P
>
{
fn
new
(
split
:
&
'
sep
Split
<
'
ch
P
>
)
-
>
Self
{
SplitProducer
{
chars
:
split
.
chars
separator
:
&
split
.
separator
tail
:
split
.
chars
.
len
(
)
}
}
fn
fold_with
<
F
>
(
self
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
<
Self
as
UnindexedProducer
>
:
:
Item
>
{
let
SplitProducer
{
chars
separator
tail
}
=
self
;
if
tail
=
=
chars
.
len
(
)
{
separator
.
fold_with
(
chars
folder
skip_last
)
}
else
if
let
Some
(
index
)
=
separator
.
rfind_in
(
&
chars
[
.
.
tail
]
)
{
let
(
left
right
)
=
chars
.
split_at
(
index
)
;
let
folder
=
separator
.
fold_with
(
left
folder
false
)
;
if
skip_last
|
|
folder
.
full
(
)
{
folder
}
else
{
let
mut
right_iter
=
right
.
chars
(
)
;
right_iter
.
next
(
)
;
folder
.
consume
(
right_iter
.
as_str
(
)
)
}
}
else
{
if
skip_last
{
folder
}
else
{
folder
.
consume
(
chars
)
}
}
}
}
impl
<
'
ch
P
:
Pattern
>
ParallelIterator
for
Split
<
'
ch
P
>
{
type
Item
=
&
'
ch
str
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
SplitProducer
:
:
new
(
&
self
)
;
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
ch
'
sep
P
:
Pattern
+
'
sep
>
UnindexedProducer
for
SplitProducer
<
'
ch
'
sep
P
>
{
type
Item
=
&
'
ch
str
;
fn
split
(
mut
self
)
-
>
(
Self
Option
<
Self
>
)
{
let
SplitProducer
{
chars
separator
tail
}
=
self
;
let
char_index
=
find_char_midpoint
(
&
chars
[
.
.
tail
]
)
;
let
index
=
separator
.
find_in
(
&
chars
[
char_index
.
.
tail
]
)
.
map
(
|
i
|
char_index
+
i
)
.
or_else
(
|
|
separator
.
rfind_in
(
&
chars
[
.
.
char_index
]
)
)
;
if
let
Some
(
index
)
=
index
{
let
(
left
right
)
=
chars
.
split_at
(
index
)
;
self
.
chars
=
left
;
self
.
tail
=
min
(
char_index
index
)
;
let
mut
right_iter
=
right
.
chars
(
)
;
right_iter
.
next
(
)
;
let
right_chars
=
right_iter
.
as_str
(
)
;
let
right_index
=
chars
.
len
(
)
-
right_chars
.
len
(
)
;
let
mut
right
=
SplitProducer
{
chars
:
right_chars
separator
:
separator
tail
:
tail
-
right_index
}
;
if
index
<
char_index
{
right
.
tail
=
0
;
}
(
self
Some
(
right
)
)
}
else
{
self
.
tail
=
0
;
(
self
None
)
}
}
fn
fold_with
<
F
>
(
self
folder
:
F
)
-
>
F
where
F
:
Folder
<
Self
:
:
Item
>
{
self
.
fold_with
(
folder
false
)
}
}
pub
struct
SplitTerminator
<
'
ch
P
:
Pattern
>
{
splitter
:
Split
<
'
ch
P
>
}
struct
SplitTerminatorProducer
<
'
ch
'
sep
P
:
Pattern
+
'
sep
>
{
splitter
:
SplitProducer
<
'
ch
'
sep
P
>
endpoint
:
bool
}
impl
<
'
ch
P
:
Pattern
>
SplitTerminator
<
'
ch
P
>
{
fn
new
(
chars
:
&
'
ch
str
terminator
:
P
)
-
>
Self
{
SplitTerminator
{
splitter
:
Split
:
:
new
(
chars
terminator
)
}
}
}
impl
<
'
ch
'
sep
P
:
Pattern
+
'
sep
>
SplitTerminatorProducer
<
'
ch
'
sep
P
>
{
fn
new
(
split
:
&
'
sep
SplitTerminator
<
'
ch
P
>
)
-
>
Self
{
SplitTerminatorProducer
{
splitter
:
SplitProducer
:
:
new
(
&
split
.
splitter
)
endpoint
:
true
}
}
}
impl
<
'
ch
P
:
Pattern
>
ParallelIterator
for
SplitTerminator
<
'
ch
P
>
{
type
Item
=
&
'
ch
str
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
SplitTerminatorProducer
:
:
new
(
&
self
)
;
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
ch
'
sep
P
:
Pattern
+
'
sep
>
UnindexedProducer
for
SplitTerminatorProducer
<
'
ch
'
sep
P
>
{
type
Item
=
&
'
ch
str
;
fn
split
(
mut
self
)
-
>
(
Self
Option
<
Self
>
)
{
let
(
left
right
)
=
self
.
splitter
.
split
(
)
;
self
.
splitter
=
left
;
let
right
=
right
.
map
(
|
right
|
{
let
endpoint
=
self
.
endpoint
;
self
.
endpoint
=
false
;
SplitTerminatorProducer
{
splitter
:
right
endpoint
:
endpoint
}
}
)
;
(
self
right
)
}
fn
fold_with
<
F
>
(
self
folder
:
F
)
-
>
F
where
F
:
Folder
<
Self
:
:
Item
>
{
let
skip_last
=
if
self
.
endpoint
{
let
chars
=
self
.
splitter
.
chars
;
let
terminator
=
self
.
splitter
.
separator
;
chars
.
is_empty
(
)
|
|
terminator
.
is_suffix_of
(
chars
)
}
else
{
false
}
;
self
.
splitter
.
fold_with
(
folder
skip_last
)
}
}
pub
struct
Lines
<
'
ch
>
(
&
'
ch
str
)
;
impl
<
'
ch
>
ParallelIterator
for
Lines
<
'
ch
>
{
type
Item
=
&
'
ch
str
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
self
.
0
.
par_split_terminator
(
'
\
n
'
)
.
map
(
|
line
|
if
line
.
ends_with
(
'
\
r
'
)
{
&
line
[
.
.
line
.
len
(
)
-
1
]
}
else
{
line
}
)
.
drive_unindexed
(
consumer
)
}
}
pub
struct
SplitWhitespace
<
'
ch
>
(
&
'
ch
str
)
;
impl
<
'
ch
>
ParallelIterator
for
SplitWhitespace
<
'
ch
>
{
type
Item
=
&
'
ch
str
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
self
.
0
.
par_split
(
char
:
:
is_whitespace
)
.
filter
(
|
string
|
!
string
.
is_empty
(
)
)
.
drive_unindexed
(
consumer
)
}
}
