mod
chunks
;
mod
mergesort
;
mod
quicksort
;
mod
rchunks
;
mod
test
;
use
self
:
:
mergesort
:
:
par_mergesort
;
use
self
:
:
quicksort
:
:
par_quicksort
;
use
crate
:
:
iter
:
:
plumbing
:
:
*
;
use
crate
:
:
iter
:
:
*
;
use
crate
:
:
split_producer
:
:
*
;
use
std
:
:
cmp
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
use
std
:
:
mem
;
pub
use
self
:
:
chunks
:
:
{
Chunks
ChunksExact
ChunksExactMut
ChunksMut
}
;
pub
use
self
:
:
rchunks
:
:
{
RChunks
RChunksExact
RChunksExactMut
RChunksMut
}
;
pub
trait
ParallelSlice
<
T
:
Sync
>
{
fn
as_parallel_slice
(
&
self
)
-
>
&
[
T
]
;
fn
par_split
<
P
>
(
&
self
separator
:
P
)
-
>
Split
<
'
_
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
{
Split
{
slice
:
self
.
as_parallel_slice
(
)
separator
}
}
fn
par_windows
(
&
self
window_size
:
usize
)
-
>
Windows
<
'
_
T
>
{
Windows
{
window_size
slice
:
self
.
as_parallel_slice
(
)
}
}
#
[
track_caller
]
fn
par_chunks
(
&
self
chunk_size
:
usize
)
-
>
Chunks
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
Chunks
:
:
new
(
chunk_size
self
.
as_parallel_slice
(
)
)
}
#
[
track_caller
]
fn
par_chunks_exact
(
&
self
chunk_size
:
usize
)
-
>
ChunksExact
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
ChunksExact
:
:
new
(
chunk_size
self
.
as_parallel_slice
(
)
)
}
#
[
track_caller
]
fn
par_rchunks
(
&
self
chunk_size
:
usize
)
-
>
RChunks
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
RChunks
:
:
new
(
chunk_size
self
.
as_parallel_slice
(
)
)
}
#
[
track_caller
]
fn
par_rchunks_exact
(
&
self
chunk_size
:
usize
)
-
>
RChunksExact
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
RChunksExact
:
:
new
(
chunk_size
self
.
as_parallel_slice
(
)
)
}
}
impl
<
T
:
Sync
>
ParallelSlice
<
T
>
for
[
T
]
{
#
[
inline
]
fn
as_parallel_slice
(
&
self
)
-
>
&
[
T
]
{
self
}
}
pub
trait
ParallelSliceMut
<
T
:
Send
>
{
fn
as_parallel_slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
;
fn
par_split_mut
<
P
>
(
&
mut
self
separator
:
P
)
-
>
SplitMut
<
'
_
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
{
SplitMut
{
slice
:
self
.
as_parallel_slice_mut
(
)
separator
}
}
#
[
track_caller
]
fn
par_chunks_mut
(
&
mut
self
chunk_size
:
usize
)
-
>
ChunksMut
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
ChunksMut
:
:
new
(
chunk_size
self
.
as_parallel_slice_mut
(
)
)
}
#
[
track_caller
]
fn
par_chunks_exact_mut
(
&
mut
self
chunk_size
:
usize
)
-
>
ChunksExactMut
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
ChunksExactMut
:
:
new
(
chunk_size
self
.
as_parallel_slice_mut
(
)
)
}
#
[
track_caller
]
fn
par_rchunks_mut
(
&
mut
self
chunk_size
:
usize
)
-
>
RChunksMut
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
RChunksMut
:
:
new
(
chunk_size
self
.
as_parallel_slice_mut
(
)
)
}
#
[
track_caller
]
fn
par_rchunks_exact_mut
(
&
mut
self
chunk_size
:
usize
)
-
>
RChunksExactMut
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
RChunksExactMut
:
:
new
(
chunk_size
self
.
as_parallel_slice_mut
(
)
)
}
fn
par_sort
(
&
mut
self
)
where
T
:
Ord
{
par_mergesort
(
self
.
as_parallel_slice_mut
(
)
T
:
:
lt
)
;
}
fn
par_sort_by
<
F
>
(
&
mut
self
compare
:
F
)
where
F
:
Fn
(
&
T
&
T
)
-
>
Ordering
+
Sync
{
par_mergesort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
{
compare
(
a
b
)
=
=
Ordering
:
:
Less
}
)
;
}
fn
par_sort_by_key
<
K
F
>
(
&
mut
self
f
:
F
)
where
K
:
Ord
F
:
Fn
(
&
T
)
-
>
K
+
Sync
{
par_mergesort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
f
(
a
)
.
lt
(
&
f
(
b
)
)
)
;
}
fn
par_sort_by_cached_key
<
K
F
>
(
&
mut
self
f
:
F
)
where
F
:
Fn
(
&
T
)
-
>
K
+
Sync
K
:
Ord
+
Send
{
let
slice
=
self
.
as_parallel_slice_mut
(
)
;
let
len
=
slice
.
len
(
)
;
if
len
<
2
{
return
;
}
macro_rules
!
sort_by_key
{
(
t
:
ty
)
=
>
{
{
let
mut
indices
:
Vec
<
_
>
=
slice
.
par_iter_mut
(
)
.
enumerate
(
)
.
map
(
|
(
i
x
)
|
(
f
(
&
*
x
)
i
as
t
)
)
.
collect
(
)
;
/
/
The
elements
of
indices
are
unique
as
they
are
indexed
so
any
sort
will
be
/
/
stable
with
respect
to
the
original
slice
.
We
use
sort_unstable
here
because
/
/
it
requires
less
memory
allocation
.
indices
.
par_sort_unstable
(
)
;
for
i
in
0
.
.
len
{
let
mut
index
=
indices
[
i
]
.
1
;
while
(
index
as
usize
)
<
i
{
index
=
indices
[
index
as
usize
]
.
1
;
}
indices
[
i
]
.
1
=
index
;
slice
.
swap
(
i
index
as
usize
)
;
}
}
}
;
}
let
sz_u8
=
mem
:
:
size_of
:
:
<
(
K
u8
)
>
(
)
;
let
sz_u16
=
mem
:
:
size_of
:
:
<
(
K
u16
)
>
(
)
;
let
sz_u32
=
mem
:
:
size_of
:
:
<
(
K
u32
)
>
(
)
;
let
sz_usize
=
mem
:
:
size_of
:
:
<
(
K
usize
)
>
(
)
;
if
sz_u8
<
sz_u16
&
&
len
<
=
(
std
:
:
u8
:
:
MAX
as
usize
)
{
return
sort_by_key
!
(
u8
)
;
}
if
sz_u16
<
sz_u32
&
&
len
<
=
(
std
:
:
u16
:
:
MAX
as
usize
)
{
return
sort_by_key
!
(
u16
)
;
}
if
sz_u32
<
sz_usize
&
&
len
<
=
(
std
:
:
u32
:
:
MAX
as
usize
)
{
return
sort_by_key
!
(
u32
)
;
}
sort_by_key
!
(
usize
)
}
fn
par_sort_unstable
(
&
mut
self
)
where
T
:
Ord
{
par_quicksort
(
self
.
as_parallel_slice_mut
(
)
T
:
:
lt
)
;
}
fn
par_sort_unstable_by
<
F
>
(
&
mut
self
compare
:
F
)
where
F
:
Fn
(
&
T
&
T
)
-
>
Ordering
+
Sync
{
par_quicksort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
{
compare
(
a
b
)
=
=
Ordering
:
:
Less
}
)
;
}
fn
par_sort_unstable_by_key
<
K
F
>
(
&
mut
self
f
:
F
)
where
K
:
Ord
F
:
Fn
(
&
T
)
-
>
K
+
Sync
{
par_quicksort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
f
(
a
)
.
lt
(
&
f
(
b
)
)
)
;
}
}
impl
<
T
:
Send
>
ParallelSliceMut
<
T
>
for
[
T
]
{
#
[
inline
]
fn
as_parallel_slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
self
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IntoParallelIterator
for
&
'
data
[
T
]
{
type
Item
=
&
'
data
T
;
type
Iter
=
Iter
<
'
data
T
>
;
fn
into_par_iter
(
self
)
-
>
Self
:
:
Iter
{
Iter
{
slice
:
self
}
}
}
impl
<
'
data
T
:
Send
+
'
data
>
IntoParallelIterator
for
&
'
data
mut
[
T
]
{
type
Item
=
&
'
data
mut
T
;
type
Iter
=
IterMut
<
'
data
T
>
;
fn
into_par_iter
(
self
)
-
>
Self
:
:
Iter
{
IterMut
{
slice
:
self
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Iter
<
'
data
T
:
Sync
>
{
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
Sync
>
Clone
for
Iter
<
'
data
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Iter
{
.
.
*
self
}
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
ParallelIterator
for
Iter
<
'
data
T
>
{
type
Item
=
&
'
data
T
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IndexedParallelIterator
for
Iter
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
self
.
slice
.
len
(
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
IterProducer
{
slice
:
self
.
slice
}
)
}
}
struct
IterProducer
<
'
data
T
:
Sync
>
{
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
'
data
+
Sync
>
Producer
for
IterProducer
<
'
data
T
>
{
type
Item
=
&
'
data
T
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
Iter
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
iter
(
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
slice
.
split_at
(
index
)
;
(
IterProducer
{
slice
:
left
}
IterProducer
{
slice
:
right
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Windows
<
'
data
T
:
Sync
>
{
window_size
:
usize
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
Sync
>
Clone
for
Windows
<
'
data
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Windows
{
.
.
*
self
}
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
ParallelIterator
for
Windows
<
'
data
T
>
{
type
Item
=
&
'
data
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IndexedParallelIterator
for
Windows
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
assert
!
(
self
.
window_size
>
=
1
)
;
self
.
slice
.
len
(
)
.
saturating_sub
(
self
.
window_size
-
1
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
WindowsProducer
{
window_size
:
self
.
window_size
slice
:
self
.
slice
}
)
}
}
struct
WindowsProducer
<
'
data
T
:
Sync
>
{
window_size
:
usize
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
'
data
+
Sync
>
Producer
for
WindowsProducer
<
'
data
T
>
{
type
Item
=
&
'
data
[
T
]
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
Windows
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
windows
(
self
.
window_size
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
left_index
=
cmp
:
:
min
(
self
.
slice
.
len
(
)
index
+
(
self
.
window_size
-
1
)
)
;
let
left
=
&
self
.
slice
[
.
.
left_index
]
;
let
right
=
&
self
.
slice
[
index
.
.
]
;
(
WindowsProducer
{
window_size
:
self
.
window_size
slice
:
left
}
WindowsProducer
{
window_size
:
self
.
window_size
slice
:
right
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
IterMut
<
'
data
T
:
Send
>
{
slice
:
&
'
data
mut
[
T
]
}
impl
<
'
data
T
:
Send
+
'
data
>
ParallelIterator
for
IterMut
<
'
data
T
>
{
type
Item
=
&
'
data
mut
T
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Send
+
'
data
>
IndexedParallelIterator
for
IterMut
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
self
.
slice
.
len
(
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
IterMutProducer
{
slice
:
self
.
slice
}
)
}
}
struct
IterMutProducer
<
'
data
T
:
Send
>
{
slice
:
&
'
data
mut
[
T
]
}
impl
<
'
data
T
:
'
data
+
Send
>
Producer
for
IterMutProducer
<
'
data
T
>
{
type
Item
=
&
'
data
mut
T
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
IterMut
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
iter_mut
(
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
slice
.
split_at_mut
(
index
)
;
(
IterMutProducer
{
slice
:
left
}
IterMutProducer
{
slice
:
right
}
)
}
}
pub
struct
Split
<
'
data
T
P
>
{
slice
:
&
'
data
[
T
]
separator
:
P
}
impl
<
'
data
T
P
:
Clone
>
Clone
for
Split
<
'
data
T
P
>
{
fn
clone
(
&
self
)
-
>
Self
{
Split
{
separator
:
self
.
separator
.
clone
(
)
.
.
*
self
}
}
}
impl
<
'
data
T
:
Debug
P
>
Debug
for
Split
<
'
data
T
P
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Split
"
)
.
field
(
"
slice
"
&
self
.
slice
)
.
finish
(
)
}
}
impl
<
'
data
T
P
>
ParallelIterator
for
Split
<
'
data
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
T
:
Sync
{
type
Item
=
&
'
data
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
SplitProducer
:
:
new
(
self
.
slice
&
self
.
separator
)
;
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
data
T
P
>
Fissile
<
P
>
for
&
'
data
[
T
]
where
P
:
Fn
(
&
T
)
-
>
bool
{
fn
length
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
midpoint
(
&
self
end
:
usize
)
-
>
usize
{
end
/
2
}
fn
find
(
&
self
separator
:
&
P
start
:
usize
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
start
.
.
end
]
.
iter
(
)
.
position
(
separator
)
}
fn
rfind
(
&
self
separator
:
&
P
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
.
.
end
]
.
iter
(
)
.
rposition
(
separator
)
}
fn
split_once
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
split_at
(
index
)
;
(
left
&
right
[
1
.
.
]
)
}
fn
fold_splits
<
F
>
(
self
separator
:
&
P
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
Self
>
Self
:
Send
{
let
mut
split
=
self
.
split
(
separator
)
;
if
skip_last
{
split
.
next_back
(
)
;
}
folder
.
consume_iter
(
split
)
}
}
pub
struct
SplitMut
<
'
data
T
P
>
{
slice
:
&
'
data
mut
[
T
]
separator
:
P
}
impl
<
'
data
T
:
Debug
P
>
Debug
for
SplitMut
<
'
data
T
P
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
SplitMut
"
)
.
field
(
"
slice
"
&
self
.
slice
)
.
finish
(
)
}
}
impl
<
'
data
T
P
>
ParallelIterator
for
SplitMut
<
'
data
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
T
:
Send
{
type
Item
=
&
'
data
mut
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
SplitProducer
:
:
new
(
self
.
slice
&
self
.
separator
)
;
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
data
T
P
>
Fissile
<
P
>
for
&
'
data
mut
[
T
]
where
P
:
Fn
(
&
T
)
-
>
bool
{
fn
length
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
midpoint
(
&
self
end
:
usize
)
-
>
usize
{
end
/
2
}
fn
find
(
&
self
separator
:
&
P
start
:
usize
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
start
.
.
end
]
.
iter
(
)
.
position
(
separator
)
}
fn
rfind
(
&
self
separator
:
&
P
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
.
.
end
]
.
iter
(
)
.
rposition
(
separator
)
}
fn
split_once
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
split_at_mut
(
index
)
;
(
left
&
mut
right
[
1
.
.
]
)
}
fn
fold_splits
<
F
>
(
self
separator
:
&
P
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
Self
>
Self
:
Send
{
let
mut
split
=
self
.
split_mut
(
separator
)
;
if
skip_last
{
split
.
next_back
(
)
;
}
folder
.
consume_iter
(
split
)
}
}
