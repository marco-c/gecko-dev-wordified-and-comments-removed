mod
mergesort
;
mod
quicksort
;
mod
test
;
use
self
:
:
mergesort
:
:
par_mergesort
;
use
self
:
:
quicksort
:
:
par_quicksort
;
use
iter
:
:
plumbing
:
:
*
;
use
iter
:
:
*
;
use
split_producer
:
:
*
;
use
std
:
:
cmp
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
use
super
:
:
math
:
:
div_round_up
;
pub
trait
ParallelSlice
<
T
:
Sync
>
{
fn
as_parallel_slice
(
&
self
)
-
>
&
[
T
]
;
fn
par_split
<
P
>
(
&
self
separator
:
P
)
-
>
Split
<
'
_
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
{
Split
{
slice
:
self
.
as_parallel_slice
(
)
separator
}
}
fn
par_windows
(
&
self
window_size
:
usize
)
-
>
Windows
<
'
_
T
>
{
Windows
{
window_size
slice
:
self
.
as_parallel_slice
(
)
}
}
fn
par_chunks
(
&
self
chunk_size
:
usize
)
-
>
Chunks
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
Chunks
{
chunk_size
slice
:
self
.
as_parallel_slice
(
)
}
}
}
impl
<
T
:
Sync
>
ParallelSlice
<
T
>
for
[
T
]
{
#
[
inline
]
fn
as_parallel_slice
(
&
self
)
-
>
&
[
T
]
{
self
}
}
pub
trait
ParallelSliceMut
<
T
:
Send
>
{
fn
as_parallel_slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
;
fn
par_split_mut
<
P
>
(
&
mut
self
separator
:
P
)
-
>
SplitMut
<
'
_
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
{
SplitMut
{
slice
:
self
.
as_parallel_slice_mut
(
)
separator
}
}
fn
par_chunks_mut
(
&
mut
self
chunk_size
:
usize
)
-
>
ChunksMut
<
'
_
T
>
{
assert
!
(
chunk_size
!
=
0
"
chunk_size
must
not
be
zero
"
)
;
ChunksMut
{
chunk_size
slice
:
self
.
as_parallel_slice_mut
(
)
}
}
fn
par_sort
(
&
mut
self
)
where
T
:
Ord
{
par_mergesort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
a
.
lt
(
b
)
)
;
}
fn
par_sort_by
<
F
>
(
&
mut
self
compare
:
F
)
where
F
:
Fn
(
&
T
&
T
)
-
>
Ordering
+
Sync
{
par_mergesort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
{
compare
(
a
b
)
=
=
Ordering
:
:
Less
}
)
;
}
fn
par_sort_by_key
<
B
F
>
(
&
mut
self
f
:
F
)
where
B
:
Ord
F
:
Fn
(
&
T
)
-
>
B
+
Sync
{
par_mergesort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
f
(
a
)
.
lt
(
&
f
(
b
)
)
)
;
}
fn
par_sort_unstable
(
&
mut
self
)
where
T
:
Ord
{
par_quicksort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
a
.
lt
(
b
)
)
;
}
fn
par_sort_unstable_by
<
F
>
(
&
mut
self
compare
:
F
)
where
F
:
Fn
(
&
T
&
T
)
-
>
Ordering
+
Sync
{
par_quicksort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
{
compare
(
a
b
)
=
=
Ordering
:
:
Less
}
)
;
}
fn
par_sort_unstable_by_key
<
B
F
>
(
&
mut
self
f
:
F
)
where
B
:
Ord
F
:
Fn
(
&
T
)
-
>
B
+
Sync
{
par_quicksort
(
self
.
as_parallel_slice_mut
(
)
|
a
b
|
f
(
a
)
.
lt
(
&
f
(
b
)
)
)
;
}
}
impl
<
T
:
Send
>
ParallelSliceMut
<
T
>
for
[
T
]
{
#
[
inline
]
fn
as_parallel_slice_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
self
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IntoParallelIterator
for
&
'
data
[
T
]
{
type
Item
=
&
'
data
T
;
type
Iter
=
Iter
<
'
data
T
>
;
fn
into_par_iter
(
self
)
-
>
Self
:
:
Iter
{
Iter
{
slice
:
self
}
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IntoParallelIterator
for
&
'
data
Vec
<
T
>
{
type
Item
=
&
'
data
T
;
type
Iter
=
Iter
<
'
data
T
>
;
fn
into_par_iter
(
self
)
-
>
Self
:
:
Iter
{
Iter
{
slice
:
self
}
}
}
impl
<
'
data
T
:
Send
+
'
data
>
IntoParallelIterator
for
&
'
data
mut
[
T
]
{
type
Item
=
&
'
data
mut
T
;
type
Iter
=
IterMut
<
'
data
T
>
;
fn
into_par_iter
(
self
)
-
>
Self
:
:
Iter
{
IterMut
{
slice
:
self
}
}
}
impl
<
'
data
T
:
Send
+
'
data
>
IntoParallelIterator
for
&
'
data
mut
Vec
<
T
>
{
type
Item
=
&
'
data
mut
T
;
type
Iter
=
IterMut
<
'
data
T
>
;
fn
into_par_iter
(
self
)
-
>
Self
:
:
Iter
{
IterMut
{
slice
:
self
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Iter
<
'
data
T
:
'
data
+
Sync
>
{
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
Sync
>
Clone
for
Iter
<
'
data
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Iter
{
.
.
*
self
}
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
ParallelIterator
for
Iter
<
'
data
T
>
{
type
Item
=
&
'
data
T
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IndexedParallelIterator
for
Iter
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
self
.
slice
.
len
(
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
IterProducer
{
slice
:
self
.
slice
}
)
}
}
struct
IterProducer
<
'
data
T
:
'
data
+
Sync
>
{
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
'
data
+
Sync
>
Producer
for
IterProducer
<
'
data
T
>
{
type
Item
=
&
'
data
T
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
Iter
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
iter
(
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
slice
.
split_at
(
index
)
;
(
IterProducer
{
slice
:
left
}
IterProducer
{
slice
:
right
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Chunks
<
'
data
T
:
'
data
+
Sync
>
{
chunk_size
:
usize
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
Sync
>
Clone
for
Chunks
<
'
data
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Chunks
{
.
.
*
self
}
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
ParallelIterator
for
Chunks
<
'
data
T
>
{
type
Item
=
&
'
data
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IndexedParallelIterator
for
Chunks
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
div_round_up
(
self
.
slice
.
len
(
)
self
.
chunk_size
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
ChunksProducer
{
chunk_size
:
self
.
chunk_size
slice
:
self
.
slice
}
)
}
}
struct
ChunksProducer
<
'
data
T
:
'
data
+
Sync
>
{
chunk_size
:
usize
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
'
data
+
Sync
>
Producer
for
ChunksProducer
<
'
data
T
>
{
type
Item
=
&
'
data
[
T
]
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
Chunks
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
chunks
(
self
.
chunk_size
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
elem_index
=
cmp
:
:
min
(
index
*
self
.
chunk_size
self
.
slice
.
len
(
)
)
;
let
(
left
right
)
=
self
.
slice
.
split_at
(
elem_index
)
;
(
ChunksProducer
{
chunk_size
:
self
.
chunk_size
slice
:
left
}
ChunksProducer
{
chunk_size
:
self
.
chunk_size
slice
:
right
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Windows
<
'
data
T
:
'
data
+
Sync
>
{
window_size
:
usize
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
Sync
>
Clone
for
Windows
<
'
data
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Windows
{
.
.
*
self
}
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
ParallelIterator
for
Windows
<
'
data
T
>
{
type
Item
=
&
'
data
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Sync
+
'
data
>
IndexedParallelIterator
for
Windows
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
assert
!
(
self
.
window_size
>
=
1
)
;
self
.
slice
.
len
(
)
.
saturating_sub
(
self
.
window_size
-
1
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
WindowsProducer
{
window_size
:
self
.
window_size
slice
:
self
.
slice
}
)
}
}
struct
WindowsProducer
<
'
data
T
:
'
data
+
Sync
>
{
window_size
:
usize
slice
:
&
'
data
[
T
]
}
impl
<
'
data
T
:
'
data
+
Sync
>
Producer
for
WindowsProducer
<
'
data
T
>
{
type
Item
=
&
'
data
[
T
]
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
Windows
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
windows
(
self
.
window_size
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
left_index
=
cmp
:
:
min
(
self
.
slice
.
len
(
)
index
+
(
self
.
window_size
-
1
)
)
;
let
left
=
&
self
.
slice
[
.
.
left_index
]
;
let
right
=
&
self
.
slice
[
index
.
.
]
;
(
WindowsProducer
{
window_size
:
self
.
window_size
slice
:
left
}
WindowsProducer
{
window_size
:
self
.
window_size
slice
:
right
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
IterMut
<
'
data
T
:
'
data
+
Send
>
{
slice
:
&
'
data
mut
[
T
]
}
impl
<
'
data
T
:
Send
+
'
data
>
ParallelIterator
for
IterMut
<
'
data
T
>
{
type
Item
=
&
'
data
mut
T
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Send
+
'
data
>
IndexedParallelIterator
for
IterMut
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
self
.
slice
.
len
(
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
IterMutProducer
{
slice
:
self
.
slice
}
)
}
}
struct
IterMutProducer
<
'
data
T
:
'
data
+
Send
>
{
slice
:
&
'
data
mut
[
T
]
}
impl
<
'
data
T
:
'
data
+
Send
>
Producer
for
IterMutProducer
<
'
data
T
>
{
type
Item
=
&
'
data
mut
T
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
IterMut
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
iter_mut
(
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
slice
.
split_at_mut
(
index
)
;
(
IterMutProducer
{
slice
:
left
}
IterMutProducer
{
slice
:
right
}
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ChunksMut
<
'
data
T
:
'
data
+
Send
>
{
chunk_size
:
usize
slice
:
&
'
data
mut
[
T
]
}
impl
<
'
data
T
:
Send
+
'
data
>
ParallelIterator
for
ChunksMut
<
'
data
T
>
{
type
Item
=
&
'
data
mut
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
self
.
len
(
)
)
}
}
impl
<
'
data
T
:
Send
+
'
data
>
IndexedParallelIterator
for
ChunksMut
<
'
data
T
>
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
bridge
(
self
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
div_round_up
(
self
.
slice
.
len
(
)
self
.
chunk_size
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
callback
.
callback
(
ChunksMutProducer
{
chunk_size
:
self
.
chunk_size
slice
:
self
.
slice
}
)
}
}
struct
ChunksMutProducer
<
'
data
T
:
'
data
+
Send
>
{
chunk_size
:
usize
slice
:
&
'
data
mut
[
T
]
}
impl
<
'
data
T
:
'
data
+
Send
>
Producer
for
ChunksMutProducer
<
'
data
T
>
{
type
Item
=
&
'
data
mut
[
T
]
;
type
IntoIter
=
:
:
std
:
:
slice
:
:
ChunksMut
<
'
data
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
slice
.
chunks_mut
(
self
.
chunk_size
)
}
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
elem_index
=
cmp
:
:
min
(
index
*
self
.
chunk_size
self
.
slice
.
len
(
)
)
;
let
(
left
right
)
=
self
.
slice
.
split_at_mut
(
elem_index
)
;
(
ChunksMutProducer
{
chunk_size
:
self
.
chunk_size
slice
:
left
}
ChunksMutProducer
{
chunk_size
:
self
.
chunk_size
slice
:
right
}
)
}
}
pub
struct
Split
<
'
data
T
:
'
data
P
>
{
slice
:
&
'
data
[
T
]
separator
:
P
}
impl
<
'
data
T
P
:
Clone
>
Clone
for
Split
<
'
data
T
P
>
{
fn
clone
(
&
self
)
-
>
Self
{
Split
{
separator
:
self
.
separator
.
clone
(
)
.
.
*
self
}
}
}
impl
<
'
data
T
:
Debug
P
>
Debug
for
Split
<
'
data
T
P
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Split
"
)
.
field
(
"
slice
"
&
self
.
slice
)
.
finish
(
)
}
}
impl
<
'
data
T
P
>
ParallelIterator
for
Split
<
'
data
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
T
:
Sync
{
type
Item
=
&
'
data
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
SplitProducer
:
:
new
(
self
.
slice
&
self
.
separator
)
;
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
data
T
P
>
Fissile
<
P
>
for
&
'
data
[
T
]
where
P
:
Fn
(
&
T
)
-
>
bool
{
fn
length
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
midpoint
(
&
self
end
:
usize
)
-
>
usize
{
end
/
2
}
fn
find
(
&
self
separator
:
&
P
start
:
usize
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
start
.
.
end
]
.
iter
(
)
.
position
(
separator
)
}
fn
rfind
(
&
self
separator
:
&
P
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
.
.
end
]
.
iter
(
)
.
rposition
(
separator
)
}
fn
split_once
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
split_at
(
index
)
;
(
left
&
right
[
1
.
.
]
)
}
fn
fold_splits
<
F
>
(
self
separator
:
&
P
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
Self
>
Self
:
Send
{
let
mut
split
=
self
.
split
(
separator
)
;
if
skip_last
{
split
.
next_back
(
)
;
}
folder
.
consume_iter
(
split
)
}
}
pub
struct
SplitMut
<
'
data
T
:
'
data
P
>
{
slice
:
&
'
data
mut
[
T
]
separator
:
P
}
impl
<
'
data
T
:
Debug
P
>
Debug
for
SplitMut
<
'
data
T
P
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
SplitMut
"
)
.
field
(
"
slice
"
&
self
.
slice
)
.
finish
(
)
}
}
impl
<
'
data
T
P
>
ParallelIterator
for
SplitMut
<
'
data
T
P
>
where
P
:
Fn
(
&
T
)
-
>
bool
+
Sync
+
Send
T
:
Send
{
type
Item
=
&
'
data
mut
[
T
]
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
SplitProducer
:
:
new
(
self
.
slice
&
self
.
separator
)
;
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
data
T
P
>
Fissile
<
P
>
for
&
'
data
mut
[
T
]
where
P
:
Fn
(
&
T
)
-
>
bool
{
fn
length
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
fn
midpoint
(
&
self
end
:
usize
)
-
>
usize
{
end
/
2
}
fn
find
(
&
self
separator
:
&
P
start
:
usize
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
start
.
.
end
]
.
iter
(
)
.
position
(
separator
)
}
fn
rfind
(
&
self
separator
:
&
P
end
:
usize
)
-
>
Option
<
usize
>
{
self
[
.
.
end
]
.
iter
(
)
.
rposition
(
separator
)
}
fn
split_once
(
self
index
:
usize
)
-
>
(
Self
Self
)
{
let
(
left
right
)
=
self
.
split_at_mut
(
index
)
;
(
left
&
mut
right
[
1
.
.
]
)
}
fn
fold_splits
<
F
>
(
self
separator
:
&
P
folder
:
F
skip_last
:
bool
)
-
>
F
where
F
:
Folder
<
Self
>
Self
:
Send
{
let
mut
split
=
self
.
split_mut
(
separator
)
;
if
skip_last
{
split
.
next_back
(
)
;
}
folder
.
consume_iter
(
split
)
}
}
