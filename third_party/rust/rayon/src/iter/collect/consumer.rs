use
super
:
:
super
:
:
plumbing
:
:
*
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
ptr
;
use
std
:
:
slice
;
pub
(
super
)
struct
CollectConsumer
<
'
c
T
:
Send
>
{
target
:
&
'
c
mut
[
T
]
}
pub
(
super
)
struct
CollectFolder
<
'
c
T
:
Send
>
{
final_len
:
usize
result
:
CollectResult
<
'
c
T
>
}
impl
<
'
c
T
:
Send
+
'
c
>
CollectConsumer
<
'
c
T
>
{
pub
(
super
)
fn
new
(
target
:
&
'
c
mut
[
T
]
)
-
>
Self
{
CollectConsumer
{
target
}
}
}
#
[
must_use
]
pub
(
super
)
struct
CollectResult
<
'
c
T
>
{
start
:
*
mut
T
len
:
usize
invariant_lifetime
:
PhantomData
<
&
'
c
mut
&
'
c
mut
[
T
]
>
}
unsafe
impl
<
'
c
T
>
Send
for
CollectResult
<
'
c
T
>
where
T
:
Send
{
}
impl
<
'
c
T
>
CollectResult
<
'
c
T
>
{
pub
(
super
)
fn
len
(
&
self
)
-
>
usize
{
self
.
len
}
pub
(
super
)
fn
release_ownership
(
mut
self
)
-
>
usize
{
let
ret
=
self
.
len
;
self
.
len
=
0
;
ret
}
}
impl
<
'
c
T
>
Drop
for
CollectResult
<
'
c
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ptr
:
:
drop_in_place
(
slice
:
:
from_raw_parts_mut
(
self
.
start
self
.
len
)
)
;
}
}
}
impl
<
'
c
T
:
Send
+
'
c
>
Consumer
<
T
>
for
CollectConsumer
<
'
c
T
>
{
type
Folder
=
CollectFolder
<
'
c
T
>
;
type
Reducer
=
CollectReducer
;
type
Result
=
CollectResult
<
'
c
T
>
;
fn
split_at
(
self
index
:
usize
)
-
>
(
Self
Self
CollectReducer
)
{
let
CollectConsumer
{
target
}
=
self
;
let
(
left
right
)
=
target
.
split_at_mut
(
index
)
;
(
CollectConsumer
:
:
new
(
left
)
CollectConsumer
:
:
new
(
right
)
CollectReducer
)
}
fn
into_folder
(
self
)
-
>
CollectFolder
<
'
c
T
>
{
CollectFolder
{
final_len
:
self
.
target
.
len
(
)
result
:
CollectResult
{
start
:
self
.
target
.
as_mut_ptr
(
)
len
:
0
invariant_lifetime
:
PhantomData
}
}
}
fn
full
(
&
self
)
-
>
bool
{
false
}
}
impl
<
'
c
T
:
Send
+
'
c
>
Folder
<
T
>
for
CollectFolder
<
'
c
T
>
{
type
Result
=
CollectResult
<
'
c
T
>
;
fn
consume
(
mut
self
item
:
T
)
-
>
CollectFolder
<
'
c
T
>
{
if
self
.
result
.
len
>
=
self
.
final_len
{
panic
!
(
"
too
many
values
pushed
to
consumer
"
)
;
}
unsafe
{
self
.
result
.
start
.
add
(
self
.
result
.
len
)
.
write
(
item
)
;
self
.
result
.
len
+
=
1
;
}
self
}
fn
complete
(
self
)
-
>
Self
:
:
Result
{
self
.
result
}
fn
full
(
&
self
)
-
>
bool
{
false
}
}
impl
<
'
c
T
:
Send
+
'
c
>
UnindexedConsumer
<
T
>
for
CollectConsumer
<
'
c
T
>
{
fn
split_off_left
(
&
self
)
-
>
Self
{
unreachable
!
(
"
CollectConsumer
must
be
indexed
!
"
)
}
fn
to_reducer
(
&
self
)
-
>
Self
:
:
Reducer
{
CollectReducer
}
}
pub
(
super
)
struct
CollectReducer
;
impl
<
'
c
T
>
Reducer
<
CollectResult
<
'
c
T
>
>
for
CollectReducer
{
fn
reduce
(
self
mut
left
:
CollectResult
<
'
c
T
>
right
:
CollectResult
<
'
c
T
>
)
-
>
CollectResult
<
'
c
T
>
{
if
left
.
start
.
wrapping_add
(
left
.
len
)
=
=
right
.
start
{
left
.
len
+
=
right
.
release_ownership
(
)
;
}
left
}
}
