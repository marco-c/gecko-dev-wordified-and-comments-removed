use
super
:
:
{
IndexedParallelIterator
ParallelIterator
}
;
mod
consumer
;
use
self
:
:
consumer
:
:
CollectConsumer
;
use
self
:
:
consumer
:
:
CollectResult
;
use
super
:
:
unzip
:
:
unzip_indexed
;
mod
test
;
pub
(
super
)
fn
collect_into_vec
<
I
T
>
(
pi
:
I
v
:
&
mut
Vec
<
T
>
)
where
I
:
IndexedParallelIterator
<
Item
=
T
>
T
:
Send
{
v
.
truncate
(
0
)
;
let
len
=
pi
.
len
(
)
;
collect_with_consumer
(
v
len
|
consumer
|
pi
.
drive
(
consumer
)
)
;
}
pub
(
super
)
fn
special_extend
<
I
T
>
(
pi
:
I
len
:
usize
v
:
&
mut
Vec
<
T
>
)
where
I
:
ParallelIterator
<
Item
=
T
>
T
:
Send
{
collect_with_consumer
(
v
len
|
consumer
|
pi
.
drive_unindexed
(
consumer
)
)
;
}
pub
(
super
)
fn
unzip_into_vecs
<
I
A
B
>
(
pi
:
I
left
:
&
mut
Vec
<
A
>
right
:
&
mut
Vec
<
B
>
)
where
I
:
IndexedParallelIterator
<
Item
=
(
A
B
)
>
A
:
Send
B
:
Send
{
left
.
truncate
(
0
)
;
right
.
truncate
(
0
)
;
let
len
=
pi
.
len
(
)
;
collect_with_consumer
(
right
len
|
right_consumer
|
{
let
mut
right_result
=
None
;
collect_with_consumer
(
left
len
|
left_consumer
|
{
let
(
left_r
right_r
)
=
unzip_indexed
(
pi
left_consumer
right_consumer
)
;
right_result
=
Some
(
right_r
)
;
left_r
}
)
;
right_result
.
unwrap
(
)
}
)
;
}
fn
collect_with_consumer
<
T
F
>
(
vec
:
&
mut
Vec
<
T
>
len
:
usize
scope_fn
:
F
)
where
T
:
Send
F
:
FnOnce
(
CollectConsumer
<
'
_
T
>
)
-
>
CollectResult
<
'
_
T
>
{
vec
.
reserve
(
len
)
;
let
result
=
scope_fn
(
CollectConsumer
:
:
appender
(
vec
len
)
)
;
let
actual_writes
=
result
.
len
(
)
;
assert
!
(
actual_writes
=
=
len
"
expected
{
}
total
writes
but
got
{
}
"
len
actual_writes
)
;
result
.
release_ownership
(
)
;
let
new_len
=
vec
.
len
(
)
+
len
;
unsafe
{
vec
.
set_len
(
new_len
)
;
}
}
