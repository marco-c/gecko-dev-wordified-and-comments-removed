use
super
:
:
{
ParallelIterator
ExactParallelIterator
IntoParallelIterator
FromParallelIterator
}
;
use
std
:
:
collections
:
:
LinkedList
;
use
std
:
:
slice
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
mod
consumer
;
use
self
:
:
consumer
:
:
CollectConsumer
;
mod
test
;
pub
fn
collect_into
<
I
T
>
(
mut
pi
:
I
v
:
&
mut
Vec
<
T
>
)
where
I
:
ExactParallelIterator
<
Item
=
T
>
T
:
Send
{
let
mut
collect
=
Collect
:
:
new
(
v
pi
.
len
(
)
)
;
pi
.
drive
(
collect
.
as_consumer
(
)
)
;
collect
.
complete
(
)
;
}
fn
special_collect_into
<
I
T
>
(
pi
:
I
len
:
usize
v
:
&
mut
Vec
<
T
>
)
where
I
:
ParallelIterator
<
Item
=
T
>
T
:
Send
{
let
mut
collect
=
Collect
:
:
new
(
v
len
)
;
pi
.
drive_unindexed
(
collect
.
as_consumer
(
)
)
;
collect
.
complete
(
)
;
}
struct
Collect
<
'
c
T
:
Send
+
'
c
>
{
writes
:
AtomicUsize
vec
:
&
'
c
mut
Vec
<
T
>
len
:
usize
}
impl
<
'
c
T
:
Send
+
'
c
>
Collect
<
'
c
T
>
{
fn
new
(
vec
:
&
'
c
mut
Vec
<
T
>
len
:
usize
)
-
>
Self
{
vec
.
truncate
(
0
)
;
vec
.
reserve
(
len
)
;
Collect
{
writes
:
AtomicUsize
:
:
new
(
0
)
vec
:
vec
len
:
len
}
}
fn
as_consumer
(
&
mut
self
)
-
>
CollectConsumer
<
T
>
{
let
mut
slice
=
self
.
vec
.
as_mut_slice
(
)
;
slice
=
unsafe
{
slice
:
:
from_raw_parts_mut
(
slice
.
as_mut_ptr
(
)
self
.
len
)
}
;
CollectConsumer
:
:
new
(
&
self
.
writes
slice
)
}
fn
complete
(
mut
self
)
{
unsafe
{
let
actual_writes
=
self
.
writes
.
load
(
Ordering
:
:
Relaxed
)
;
assert
!
(
actual_writes
=
=
self
.
len
"
expected
{
}
total
writes
but
got
{
}
"
self
.
len
actual_writes
)
;
self
.
vec
.
set_len
(
self
.
len
)
;
}
}
}
impl
<
T
>
FromParallelIterator
<
T
>
for
Vec
<
T
>
where
T
:
Send
{
fn
from_par_iter
<
I
>
(
par_iter
:
I
)
-
>
Self
where
I
:
IntoParallelIterator
<
Item
=
T
>
{
let
mut
par_iter
=
par_iter
.
into_par_iter
(
)
;
match
par_iter
.
opt_len
(
)
{
Some
(
len
)
=
>
{
let
mut
vec
=
vec
!
[
]
;
super
:
:
collect
:
:
special_collect_into
(
par_iter
len
&
mut
vec
)
;
vec
}
None
=
>
{
let
list
:
LinkedList
<
_
>
=
par_iter
.
fold
(
Vec
:
:
new
|
mut
vec
elem
|
{
vec
.
push
(
elem
)
;
vec
}
)
.
collect
(
)
;
let
len
=
list
.
iter
(
)
.
map
(
Vec
:
:
len
)
.
sum
(
)
;
let
start
=
Vec
:
:
with_capacity
(
len
)
;
list
.
into_iter
(
)
.
fold
(
start
|
mut
vec
mut
sub
|
{
vec
.
append
(
&
mut
sub
)
;
vec
}
)
}
}
}
}
