use
super
:
:
{
IndexedParallelIterator
IntoParallelIterator
ParallelExtend
ParallelIterator
}
;
use
std
:
:
mem
:
:
MaybeUninit
;
use
std
:
:
slice
;
mod
consumer
;
use
self
:
:
consumer
:
:
CollectConsumer
;
use
self
:
:
consumer
:
:
CollectResult
;
use
super
:
:
unzip
:
:
unzip_indexed
;
mod
test
;
pub
(
super
)
fn
collect_into_vec
<
I
T
>
(
pi
:
I
v
:
&
mut
Vec
<
T
>
)
where
I
:
IndexedParallelIterator
<
Item
=
T
>
T
:
Send
{
v
.
truncate
(
0
)
;
let
len
=
pi
.
len
(
)
;
Collect
:
:
new
(
v
len
)
.
with_consumer
(
|
consumer
|
pi
.
drive
(
consumer
)
)
;
}
fn
special_extend
<
I
T
>
(
pi
:
I
len
:
usize
v
:
&
mut
Vec
<
T
>
)
where
I
:
ParallelIterator
<
Item
=
T
>
T
:
Send
{
Collect
:
:
new
(
v
len
)
.
with_consumer
(
|
consumer
|
pi
.
drive_unindexed
(
consumer
)
)
;
}
pub
(
super
)
fn
unzip_into_vecs
<
I
A
B
>
(
pi
:
I
left
:
&
mut
Vec
<
A
>
right
:
&
mut
Vec
<
B
>
)
where
I
:
IndexedParallelIterator
<
Item
=
(
A
B
)
>
A
:
Send
B
:
Send
{
left
.
truncate
(
0
)
;
right
.
truncate
(
0
)
;
let
len
=
pi
.
len
(
)
;
Collect
:
:
new
(
right
len
)
.
with_consumer
(
|
right_consumer
|
{
let
mut
right_result
=
None
;
Collect
:
:
new
(
left
len
)
.
with_consumer
(
|
left_consumer
|
{
let
(
left_r
right_r
)
=
unzip_indexed
(
pi
left_consumer
right_consumer
)
;
right_result
=
Some
(
right_r
)
;
left_r
}
)
;
right_result
.
unwrap
(
)
}
)
;
}
struct
Collect
<
'
c
T
:
Send
>
{
vec
:
&
'
c
mut
Vec
<
T
>
len
:
usize
}
impl
<
'
c
T
:
Send
+
'
c
>
Collect
<
'
c
T
>
{
fn
new
(
vec
:
&
'
c
mut
Vec
<
T
>
len
:
usize
)
-
>
Self
{
Collect
{
vec
len
}
}
fn
with_consumer
<
F
>
(
mut
self
scope_fn
:
F
)
where
F
:
FnOnce
(
CollectConsumer
<
'
_
T
>
)
-
>
CollectResult
<
'
_
T
>
{
let
slice
=
Self
:
:
reserve_get_tail_slice
(
&
mut
self
.
vec
self
.
len
)
;
let
result
=
scope_fn
(
CollectConsumer
:
:
new
(
slice
)
)
;
let
actual_writes
=
result
.
len
(
)
;
assert
!
(
actual_writes
=
=
self
.
len
"
expected
{
}
total
writes
but
got
{
}
"
self
.
len
actual_writes
)
;
result
.
release_ownership
(
)
;
let
new_len
=
self
.
vec
.
len
(
)
+
self
.
len
;
unsafe
{
self
.
vec
.
set_len
(
new_len
)
;
}
}
fn
reserve_get_tail_slice
(
vec
:
&
mut
Vec
<
T
>
len
:
usize
)
-
>
&
mut
[
MaybeUninit
<
T
>
]
{
vec
.
reserve
(
len
)
;
let
start
=
vec
.
len
(
)
;
let
tail_ptr
=
vec
[
start
.
.
]
.
as_mut_ptr
(
)
as
*
mut
MaybeUninit
<
T
>
;
unsafe
{
slice
:
:
from_raw_parts_mut
(
tail_ptr
len
)
}
}
}
impl
<
T
>
ParallelExtend
<
T
>
for
Vec
<
T
>
where
T
:
Send
{
fn
par_extend
<
I
>
(
&
mut
self
par_iter
:
I
)
where
I
:
IntoParallelIterator
<
Item
=
T
>
{
let
par_iter
=
par_iter
.
into_par_iter
(
)
;
match
par_iter
.
opt_len
(
)
{
Some
(
len
)
=
>
{
special_extend
(
par_iter
len
self
)
;
}
None
=
>
{
let
list
=
super
:
:
extend
:
:
collect
(
par_iter
)
;
self
.
reserve
(
super
:
:
extend
:
:
len
(
&
list
)
)
;
for
mut
vec
in
list
{
self
.
append
(
&
mut
vec
)
;
}
}
}
}
}
