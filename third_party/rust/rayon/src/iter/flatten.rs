use
super
:
:
plumbing
:
:
*
;
use
super
:
:
*
;
#
[
must_use
=
"
iterator
adaptors
are
lazy
and
do
nothing
unless
consumed
"
]
#
[
derive
(
Debug
Clone
)
]
pub
struct
Flatten
<
I
:
ParallelIterator
>
{
base
:
I
}
impl
<
I
PI
>
Flatten
<
I
>
where
I
:
ParallelIterator
<
Item
=
PI
>
PI
:
IntoParallelIterator
+
Send
{
pub
(
super
)
fn
new
(
base
:
I
)
-
>
Self
{
Flatten
{
base
}
}
}
impl
<
I
PI
>
ParallelIterator
for
Flatten
<
I
>
where
I
:
ParallelIterator
<
Item
=
PI
>
PI
:
IntoParallelIterator
+
Send
{
type
Item
=
PI
:
:
Item
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
self
.
base
.
flat_map
(
|
x
|
x
)
.
drive_unindexed
(
consumer
)
}
}
