macro_rules
!
delegate_iterator
{
(
iter
:
ty
=
>
item
:
ty
impl
(
args
:
tt
)
*
)
=
>
{
impl
(
args
)
*
ParallelIterator
for
iter
{
type
Item
=
item
;
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
self
.
inner
.
drive_unindexed
(
consumer
)
}
fn
opt_len
(
&
self
)
-
>
Option
<
usize
>
{
self
.
inner
.
opt_len
(
)
}
}
}
}
macro_rules
!
delegate_indexed_iterator
{
(
iter
:
ty
=
>
item
:
ty
impl
(
args
:
tt
)
*
)
=
>
{
delegate_iterator
!
{
iter
=
>
item
impl
(
args
)
*
}
impl
(
args
)
*
IndexedParallelIterator
for
iter
{
fn
drive
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
Consumer
<
Self
:
:
Item
>
{
self
.
inner
.
drive
(
consumer
)
}
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
len
(
)
}
fn
with_producer
<
CB
>
(
self
callback
:
CB
)
-
>
CB
:
:
Output
where
CB
:
ProducerCallback
<
Self
:
:
Item
>
{
self
.
inner
.
with_producer
(
callback
)
}
}
}
}
