use
crate
:
:
arena
:
:
{
Arena
Handle
HandleSet
Range
}
;
type
Index
=
crate
:
:
non_max_u32
:
:
NonMaxU32
;
pub
struct
HandleMap
<
T
>
{
new_index
:
Vec
<
Option
<
Index
>
>
as_keys
:
std
:
:
marker
:
:
PhantomData
<
T
>
}
impl
<
T
:
'
static
>
HandleMap
<
T
>
{
pub
fn
from_set
(
set
:
HandleSet
<
T
>
)
-
>
Self
{
let
mut
next_index
=
Index
:
:
new
(
0
)
.
unwrap
(
)
;
Self
{
new_index
:
set
.
all_possible
(
)
.
map
(
|
handle
|
{
if
set
.
contains
(
handle
)
{
let
this
=
next_index
;
next_index
=
next_index
.
checked_add
(
1
)
.
unwrap
(
)
;
Some
(
this
)
}
else
{
None
}
}
)
.
collect
(
)
as_keys
:
std
:
:
marker
:
:
PhantomData
}
}
pub
fn
used
(
&
self
old
:
Handle
<
T
>
)
-
>
bool
{
self
.
new_index
[
old
.
index
(
)
]
.
is_some
(
)
}
pub
fn
try_adjust
(
&
self
old
:
Handle
<
T
>
)
-
>
Option
<
Handle
<
T
>
>
{
log
:
:
trace
!
(
"
adjusting
{
}
handle
[
{
}
]
-
>
[
{
:
?
}
]
"
std
:
:
any
:
:
type_name
:
:
<
T
>
(
)
old
.
index
(
)
self
.
new_index
[
old
.
index
(
)
]
)
;
self
.
new_index
[
old
.
index
(
)
]
.
map
(
Handle
:
:
new
)
}
pub
fn
adjust
(
&
self
handle
:
&
mut
Handle
<
T
>
)
{
*
handle
=
self
.
try_adjust
(
*
handle
)
.
unwrap
(
)
;
}
pub
fn
adjust_option
(
&
self
handle
:
&
mut
Option
<
Handle
<
T
>
>
)
{
if
let
Some
(
ref
mut
handle
)
=
*
handle
{
self
.
adjust
(
handle
)
;
}
}
pub
fn
adjust_range
(
&
self
range
:
&
mut
Range
<
T
>
compacted_arena
:
&
Arena
<
T
>
)
{
let
mut
index_range
=
range
.
index_range
(
)
;
let
compacted
;
if
let
Some
(
first
)
=
index_range
.
find_map
(
|
i
|
self
.
new_index
[
i
as
usize
]
)
{
if
let
Some
(
last
)
=
index_range
.
rev
(
)
.
find_map
(
|
i
|
self
.
new_index
[
i
as
usize
]
)
{
compacted
=
first
.
get
(
)
.
.
last
.
get
(
)
+
1
;
}
else
{
compacted
=
first
.
get
(
)
.
.
first
.
get
(
)
+
1
;
}
}
else
{
compacted
=
0
.
.
0
;
}
;
*
range
=
Range
:
:
from_index_range
(
compacted
compacted_arena
)
;
}
}
