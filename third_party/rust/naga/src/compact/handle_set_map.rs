use
alloc
:
:
vec
:
:
Vec
;
use
crate
:
:
arena
:
:
{
Arena
Handle
HandleSet
Range
}
;
type
Index
=
crate
:
:
non_max_u32
:
:
NonMaxU32
;
#
[
derive
(
Debug
)
]
pub
struct
HandleMap
<
T
U
=
Index
>
{
new_index
:
Vec
<
Option
<
U
>
>
as_keys
:
core
:
:
marker
:
:
PhantomData
<
T
>
}
impl
<
T
U
>
HandleMap
<
T
U
>
{
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
new_index
:
Vec
:
:
with_capacity
(
capacity
)
as_keys
:
core
:
:
marker
:
:
PhantomData
}
}
pub
fn
get
(
&
self
handle
:
Handle
<
T
>
)
-
>
Option
<
&
U
>
{
self
.
new_index
.
get
(
handle
.
index
(
)
)
.
unwrap_or
(
&
None
)
.
as_ref
(
)
}
pub
fn
insert
(
&
mut
self
handle
:
Handle
<
T
>
value
:
U
)
-
>
Option
<
U
>
{
if
self
.
new_index
.
len
(
)
<
=
handle
.
index
(
)
{
self
.
new_index
.
resize_with
(
handle
.
index
(
)
+
1
|
|
None
)
;
}
self
.
new_index
[
handle
.
index
(
)
]
.
replace
(
value
)
}
}
impl
<
T
:
'
static
>
HandleMap
<
T
>
{
pub
fn
from_set
(
set
:
HandleSet
<
T
>
)
-
>
Self
{
let
mut
next_index
=
Index
:
:
new
(
0
)
.
unwrap
(
)
;
Self
{
new_index
:
set
.
all_possible
(
)
.
map
(
|
handle
|
{
if
set
.
contains
(
handle
)
{
let
this
=
next_index
;
next_index
=
next_index
.
checked_add
(
1
)
.
unwrap
(
)
;
Some
(
this
)
}
else
{
None
}
}
)
.
collect
(
)
as_keys
:
core
:
:
marker
:
:
PhantomData
}
}
pub
fn
used
(
&
self
old
:
Handle
<
T
>
)
-
>
bool
{
self
.
new_index
[
old
.
index
(
)
]
.
is_some
(
)
}
pub
fn
try_adjust
(
&
self
old
:
Handle
<
T
>
)
-
>
Option
<
Handle
<
T
>
>
{
log
:
:
trace
!
(
"
adjusting
{
}
handle
[
{
}
]
-
>
[
{
:
?
}
]
"
core
:
:
any
:
:
type_name
:
:
<
T
>
(
)
old
.
index
(
)
self
.
new_index
[
old
.
index
(
)
]
)
;
self
.
new_index
[
old
.
index
(
)
]
.
map
(
Handle
:
:
new
)
}
pub
fn
adjust
(
&
self
handle
:
&
mut
Handle
<
T
>
)
{
*
handle
=
self
.
try_adjust
(
*
handle
)
.
unwrap
(
)
;
}
pub
fn
adjust_option
(
&
self
handle
:
&
mut
Option
<
Handle
<
T
>
>
)
{
if
let
Some
(
ref
mut
handle
)
=
*
handle
{
self
.
adjust
(
handle
)
;
}
}
pub
fn
adjust_range
(
&
self
range
:
&
mut
Range
<
T
>
compacted_arena
:
&
Arena
<
T
>
)
{
let
mut
index_range
=
range
.
index_range
(
)
;
let
compacted
;
if
let
Some
(
first
)
=
index_range
.
find_map
(
|
i
|
self
.
new_index
[
i
as
usize
]
)
{
if
let
Some
(
last
)
=
index_range
.
rev
(
)
.
find_map
(
|
i
|
self
.
new_index
[
i
as
usize
]
)
{
compacted
=
first
.
get
(
)
.
.
last
.
get
(
)
+
1
;
}
else
{
compacted
=
first
.
get
(
)
.
.
first
.
get
(
)
+
1
;
}
}
else
{
compacted
=
0
.
.
0
;
}
;
*
range
=
Range
:
:
from_index_range
(
compacted
compacted_arena
)
;
}
}
