mod
block
;
mod
helpers
;
mod
image
;
mod
index
;
mod
instructions
;
mod
layout
;
mod
ray
;
mod
recyclable
;
mod
selection
;
mod
writer
;
pub
use
spirv
:
:
Capability
;
use
crate
:
:
arena
:
:
Handle
;
use
crate
:
:
proc
:
:
{
BoundsCheckPolicies
TypeResolution
}
;
use
spirv
:
:
Word
;
use
std
:
:
ops
;
use
thiserror
:
:
Error
;
#
[
derive
(
Clone
)
]
struct
PhysicalLayout
{
magic_number
:
Word
version
:
Word
generator
:
Word
bound
:
Word
instruction_schema
:
Word
}
#
[
derive
(
Default
)
]
struct
LogicalLayout
{
capabilities
:
Vec
<
Word
>
extensions
:
Vec
<
Word
>
ext_inst_imports
:
Vec
<
Word
>
memory_model
:
Vec
<
Word
>
entry_points
:
Vec
<
Word
>
execution_modes
:
Vec
<
Word
>
debugs
:
Vec
<
Word
>
annotations
:
Vec
<
Word
>
declarations
:
Vec
<
Word
>
function_declarations
:
Vec
<
Word
>
function_definitions
:
Vec
<
Word
>
}
struct
Instruction
{
op
:
spirv
:
:
Op
wc
:
u32
type_id
:
Option
<
Word
>
result_id
:
Option
<
Word
>
operands
:
Vec
<
Word
>
}
const
BITS_PER_BYTE
:
crate
:
:
Bytes
=
8
;
#
[
derive
(
Clone
Debug
Error
)
]
pub
enum
Error
{
#
[
error
(
"
The
requested
entry
point
couldn
'
t
be
found
"
)
]
EntryPointNotFound
#
[
error
(
"
target
SPIRV
-
{
0
}
.
{
1
}
is
not
supported
"
)
]
UnsupportedVersion
(
u8
u8
)
#
[
error
(
"
using
{
0
}
requires
at
least
one
of
the
capabilities
{
1
:
?
}
but
none
are
available
"
)
]
MissingCapabilities
(
&
'
static
str
Vec
<
Capability
>
)
#
[
error
(
"
unimplemented
{
0
}
"
)
]
FeatureNotImplemented
(
&
'
static
str
)
#
[
error
(
"
module
is
not
validated
properly
:
{
0
}
"
)
]
Validation
(
&
'
static
str
)
}
#
[
derive
(
Default
)
]
struct
IdGenerator
(
Word
)
;
impl
IdGenerator
{
fn
next
(
&
mut
self
)
-
>
Word
{
self
.
0
+
=
1
;
self
.
0
}
}
struct
Block
{
label_id
:
Word
body
:
Vec
<
Instruction
>
}
struct
TerminatedBlock
{
label_id
:
Word
body
:
Vec
<
Instruction
>
}
impl
Block
{
const
fn
new
(
label_id
:
Word
)
-
>
Self
{
Block
{
label_id
body
:
Vec
:
:
new
(
)
}
}
}
struct
LocalVariable
{
id
:
Word
instruction
:
Instruction
}
struct
ResultMember
{
id
:
Word
type_id
:
Word
built_in
:
Option
<
crate
:
:
BuiltIn
>
}
struct
EntryPointContext
{
argument_ids
:
Vec
<
Word
>
results
:
Vec
<
ResultMember
>
}
#
[
derive
(
Default
)
]
struct
Function
{
signature
:
Option
<
Instruction
>
parameters
:
Vec
<
FunctionArgument
>
variables
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
LocalVariable
>
LocalVariable
>
blocks
:
Vec
<
TerminatedBlock
>
entry_point_context
:
Option
<
EntryPointContext
>
}
impl
Function
{
fn
consume
(
&
mut
self
mut
block
:
Block
termination
:
Instruction
)
{
block
.
body
.
push
(
termination
)
;
self
.
blocks
.
push
(
TerminatedBlock
{
label_id
:
block
.
label_id
body
:
block
.
body
}
)
}
fn
parameter_id
(
&
self
index
:
u32
)
-
>
Word
{
match
self
.
entry_point_context
{
Some
(
ref
context
)
=
>
context
.
argument_ids
[
index
as
usize
]
None
=
>
self
.
parameters
[
index
as
usize
]
.
instruction
.
result_id
.
unwrap
(
)
}
}
}
#
[
derive
(
Debug
PartialEq
Hash
Eq
Copy
Clone
)
]
struct
LocalImageType
{
sampled_type
:
crate
:
:
ScalarKind
dim
:
spirv
:
:
Dim
flags
:
ImageTypeFlags
image_format
:
spirv
:
:
ImageFormat
}
bitflags
:
:
bitflags
!
{
/
/
/
Flags
corresponding
to
the
boolean
(
-
ish
)
parameters
to
OpTypeImage
.
pub
struct
ImageTypeFlags
:
u8
{
const
DEPTH
=
0x1
;
const
ARRAYED
=
0x2
;
const
MULTISAMPLED
=
0x4
;
const
SAMPLED
=
0x8
;
}
}
impl
LocalImageType
{
fn
from_inner
(
dim
:
crate
:
:
ImageDimension
arrayed
:
bool
class
:
crate
:
:
ImageClass
)
-
>
Self
{
let
make_flags
=
|
multi
:
bool
other
:
ImageTypeFlags
|
-
>
ImageTypeFlags
{
let
mut
flags
=
other
;
flags
.
set
(
ImageTypeFlags
:
:
ARRAYED
arrayed
)
;
flags
.
set
(
ImageTypeFlags
:
:
MULTISAMPLED
multi
)
;
flags
}
;
let
dim
=
spirv
:
:
Dim
:
:
from
(
dim
)
;
match
class
{
crate
:
:
ImageClass
:
:
Sampled
{
kind
multi
}
=
>
LocalImageType
{
sampled_type
:
kind
dim
flags
:
make_flags
(
multi
ImageTypeFlags
:
:
SAMPLED
)
image_format
:
spirv
:
:
ImageFormat
:
:
Unknown
}
crate
:
:
ImageClass
:
:
Depth
{
multi
}
=
>
LocalImageType
{
sampled_type
:
crate
:
:
ScalarKind
:
:
Float
dim
flags
:
make_flags
(
multi
ImageTypeFlags
:
:
DEPTH
|
ImageTypeFlags
:
:
SAMPLED
)
image_format
:
spirv
:
:
ImageFormat
:
:
Unknown
}
crate
:
:
ImageClass
:
:
Storage
{
format
access
:
_
}
=
>
LocalImageType
{
sampled_type
:
crate
:
:
ScalarKind
:
:
from
(
format
)
dim
flags
:
make_flags
(
false
ImageTypeFlags
:
:
empty
(
)
)
image_format
:
format
.
into
(
)
}
}
}
}
#
[
derive
(
Debug
PartialEq
Hash
Eq
Copy
Clone
)
]
enum
LocalType
{
Value
{
vector_size
:
Option
<
crate
:
:
VectorSize
>
kind
:
crate
:
:
ScalarKind
width
:
crate
:
:
Bytes
pointer_space
:
Option
<
spirv
:
:
StorageClass
>
}
Matrix
{
columns
:
crate
:
:
VectorSize
rows
:
crate
:
:
VectorSize
width
:
crate
:
:
Bytes
}
Pointer
{
base
:
Handle
<
crate
:
:
Type
>
class
:
spirv
:
:
StorageClass
}
Image
(
LocalImageType
)
SampledImage
{
image_type_id
:
Word
}
Sampler
PointerToBindingArray
{
base
:
Handle
<
crate
:
:
Type
>
size
:
u64
}
BindingArray
{
base
:
Handle
<
crate
:
:
Type
>
size
:
u64
}
AccelerationStructure
RayQuery
}
#
[
derive
(
Debug
PartialEq
Hash
Eq
Copy
Clone
)
]
enum
LookupType
{
Handle
(
Handle
<
crate
:
:
Type
>
)
Local
(
LocalType
)
}
impl
From
<
LocalType
>
for
LookupType
{
fn
from
(
local
:
LocalType
)
-
>
Self
{
Self
:
:
Local
(
local
)
}
}
#
[
derive
(
Debug
PartialEq
Clone
Hash
Eq
)
]
struct
LookupFunctionType
{
parameter_type_ids
:
Vec
<
Word
>
return_type_id
:
Word
}
fn
make_local
(
inner
:
&
crate
:
:
TypeInner
)
-
>
Option
<
LocalType
>
{
Some
(
match
*
inner
{
crate
:
:
TypeInner
:
:
Scalar
{
kind
width
}
|
crate
:
:
TypeInner
:
:
Atomic
{
kind
width
}
=
>
{
LocalType
:
:
Value
{
vector_size
:
None
kind
width
pointer_space
:
None
}
}
crate
:
:
TypeInner
:
:
Vector
{
size
kind
width
}
=
>
LocalType
:
:
Value
{
vector_size
:
Some
(
size
)
kind
width
pointer_space
:
None
}
crate
:
:
TypeInner
:
:
Matrix
{
columns
rows
width
}
=
>
LocalType
:
:
Matrix
{
columns
rows
width
}
crate
:
:
TypeInner
:
:
Pointer
{
base
space
}
=
>
LocalType
:
:
Pointer
{
base
class
:
helpers
:
:
map_storage_class
(
space
)
}
crate
:
:
TypeInner
:
:
ValuePointer
{
size
kind
width
space
}
=
>
LocalType
:
:
Value
{
vector_size
:
size
kind
width
pointer_space
:
Some
(
helpers
:
:
map_storage_class
(
space
)
)
}
crate
:
:
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
LocalType
:
:
Image
(
LocalImageType
:
:
from_inner
(
dim
arrayed
class
)
)
crate
:
:
TypeInner
:
:
Sampler
{
comparison
:
_
}
=
>
LocalType
:
:
Sampler
crate
:
:
TypeInner
:
:
AccelerationStructure
=
>
LocalType
:
:
AccelerationStructure
crate
:
:
TypeInner
:
:
RayQuery
=
>
LocalType
:
:
RayQuery
crate
:
:
TypeInner
:
:
Array
{
.
.
}
|
crate
:
:
TypeInner
:
:
Struct
{
.
.
}
|
crate
:
:
TypeInner
:
:
BindingArray
{
.
.
}
=
>
return
None
}
)
}
#
[
derive
(
Debug
)
]
enum
Dimension
{
Scalar
Vector
Matrix
}
#
[
derive
(
Default
)
]
struct
CachedExpressions
{
ids
:
Vec
<
Word
>
}
impl
CachedExpressions
{
fn
reset
(
&
mut
self
length
:
usize
)
{
self
.
ids
.
clear
(
)
;
self
.
ids
.
resize
(
length
0
)
;
}
}
impl
ops
:
:
Index
<
Handle
<
crate
:
:
Expression
>
>
for
CachedExpressions
{
type
Output
=
Word
;
fn
index
(
&
self
h
:
Handle
<
crate
:
:
Expression
>
)
-
>
&
Word
{
let
id
=
&
self
.
ids
[
h
.
index
(
)
]
;
if
*
id
=
=
0
{
unreachable
!
(
"
Expression
{
:
?
}
is
not
cached
!
"
h
)
;
}
id
}
}
impl
ops
:
:
IndexMut
<
Handle
<
crate
:
:
Expression
>
>
for
CachedExpressions
{
fn
index_mut
(
&
mut
self
h
:
Handle
<
crate
:
:
Expression
>
)
-
>
&
mut
Word
{
let
id
=
&
mut
self
.
ids
[
h
.
index
(
)
]
;
if
*
id
!
=
0
{
unreachable
!
(
"
Expression
{
:
?
}
is
already
cached
!
"
h
)
;
}
id
}
}
impl
recyclable
:
:
Recyclable
for
CachedExpressions
{
fn
recycle
(
self
)
-
>
Self
{
CachedExpressions
{
ids
:
self
.
ids
.
recycle
(
)
}
}
}
#
[
derive
(
Eq
Hash
PartialEq
)
]
enum
CachedConstant
{
Scalar
{
value
:
crate
:
:
ScalarValue
width
:
crate
:
:
Bytes
}
Composite
{
ty
:
LookupType
constituent_ids
:
Vec
<
Word
>
}
}
#
[
derive
(
Clone
)
]
struct
GlobalVariable
{
var_id
:
Word
handle_id
:
Word
access_id
:
Word
}
impl
GlobalVariable
{
const
fn
dummy
(
)
-
>
Self
{
Self
{
var_id
:
0
handle_id
:
0
access_id
:
0
}
}
const
fn
new
(
id
:
Word
)
-
>
Self
{
Self
{
var_id
:
id
handle_id
:
0
access_id
:
0
}
}
fn
reset_for_function
(
&
mut
self
)
{
self
.
handle_id
=
0
;
self
.
access_id
=
0
;
}
}
struct
FunctionArgument
{
instruction
:
Instruction
handle_id
:
Word
}
struct
BlockContext
<
'
w
>
{
writer
:
&
'
w
mut
Writer
ir_module
:
&
'
w
crate
:
:
Module
ir_function
:
&
'
w
crate
:
:
Function
fun_info
:
&
'
w
crate
:
:
valid
:
:
FunctionInfo
function
:
&
'
w
mut
Function
cached
:
CachedExpressions
temp_list
:
Vec
<
Word
>
}
impl
BlockContext
<
'
_
>
{
fn
gen_id
(
&
mut
self
)
-
>
Word
{
self
.
writer
.
id_gen
.
next
(
)
}
fn
get_type_id
(
&
mut
self
lookup_type
:
LookupType
)
-
>
Word
{
self
.
writer
.
get_type_id
(
lookup_type
)
}
fn
get_expression_type_id
(
&
mut
self
tr
:
&
TypeResolution
)
-
>
Word
{
self
.
writer
.
get_expression_type_id
(
tr
)
}
fn
get_index_constant
(
&
mut
self
index
:
Word
)
-
>
Word
{
self
.
writer
.
get_constant_scalar
(
crate
:
:
ScalarValue
:
:
Uint
(
index
as
_
)
4
)
}
fn
get_scope_constant
(
&
mut
self
scope
:
Word
)
-
>
Word
{
self
.
writer
.
get_constant_scalar
(
crate
:
:
ScalarValue
:
:
Sint
(
scope
as
_
)
4
)
}
}
#
[
derive
(
Clone
Copy
Default
)
]
struct
LoopContext
{
continuing_id
:
Option
<
Word
>
break_id
:
Option
<
Word
>
}
pub
struct
Writer
{
physical_layout
:
PhysicalLayout
logical_layout
:
LogicalLayout
id_gen
:
IdGenerator
capabilities_available
:
Option
<
crate
:
:
FastHashSet
<
Capability
>
>
capabilities_used
:
crate
:
:
FastHashSet
<
Capability
>
extensions_used
:
crate
:
:
FastHashSet
<
&
'
static
str
>
debugs
:
Vec
<
Instruction
>
annotations
:
Vec
<
Instruction
>
flags
:
WriterFlags
bounds_check_policies
:
BoundsCheckPolicies
zero_initialize_workgroup_memory
:
ZeroInitializeWorkgroupMemoryMode
void_type
:
Word
lookup_type
:
crate
:
:
FastHashMap
<
LookupType
Word
>
lookup_function
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
Function
>
Word
>
lookup_function_type
:
crate
:
:
FastHashMap
<
LookupFunctionType
Word
>
constant_ids
:
Vec
<
Word
>
cached_constants
:
crate
:
:
FastHashMap
<
CachedConstant
Word
>
global_variables
:
Vec
<
GlobalVariable
>
binding_map
:
BindingMap
saved_cached
:
CachedExpressions
gl450_ext_inst_id
:
Word
temp_list
:
Vec
<
Word
>
}
bitflags
:
:
bitflags
!
{
pub
struct
WriterFlags
:
u32
{
/
/
/
Include
debug
labels
for
everything
.
const
DEBUG
=
0x1
;
/
/
/
Flip
Y
coordinate
of
BuiltIn
:
:
Position
output
.
const
ADJUST_COORDINATE_SPACE
=
0x2
;
/
/
/
Emit
OpName
for
input
/
output
locations
.
/
/
/
Contrary
to
spec
some
drivers
treat
it
as
semantic
not
allowing
/
/
/
any
conflicts
.
const
LABEL_VARYINGS
=
0x4
;
/
/
/
Emit
PointSize
output
builtin
to
vertex
shaders
which
is
/
/
/
required
for
drawing
with
PointList
topology
.
const
FORCE_POINT_SIZE
=
0x8
;
/
/
/
Clamp
BuiltIn
:
:
FragDepth
output
between
0
and
1
.
const
CLAMP_FRAG_DEPTH
=
0x10
;
}
}
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
BindingInfo
{
pub
binding_array_size
:
Option
<
u32
>
}
pub
type
BindingMap
=
std
:
:
collections
:
:
BTreeMap
<
crate
:
:
ResourceBinding
BindingInfo
>
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
ZeroInitializeWorkgroupMemoryMode
{
Native
Polyfill
None
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Options
{
pub
lang_version
:
(
u8
u8
)
pub
flags
:
WriterFlags
pub
binding_map
:
BindingMap
pub
capabilities
:
Option
<
crate
:
:
FastHashSet
<
Capability
>
>
pub
bounds_check_policies
:
BoundsCheckPolicies
pub
zero_initialize_workgroup_memory
:
ZeroInitializeWorkgroupMemoryMode
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
let
mut
flags
=
WriterFlags
:
:
ADJUST_COORDINATE_SPACE
|
WriterFlags
:
:
LABEL_VARYINGS
|
WriterFlags
:
:
CLAMP_FRAG_DEPTH
;
if
cfg
!
(
debug_assertions
)
{
flags
|
=
WriterFlags
:
:
DEBUG
;
}
Options
{
lang_version
:
(
1
0
)
flags
binding_map
:
BindingMap
:
:
default
(
)
capabilities
:
None
bounds_check_policies
:
crate
:
:
proc
:
:
BoundsCheckPolicies
:
:
default
(
)
zero_initialize_workgroup_memory
:
ZeroInitializeWorkgroupMemoryMode
:
:
Polyfill
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
PipelineOptions
{
pub
shader_stage
:
crate
:
:
ShaderStage
pub
entry_point
:
String
}
pub
fn
write_vec
(
module
:
&
crate
:
:
Module
info
:
&
crate
:
:
valid
:
:
ModuleInfo
options
:
&
Options
pipeline_options
:
Option
<
&
PipelineOptions
>
)
-
>
Result
<
Vec
<
u32
>
Error
>
{
let
mut
words
=
Vec
:
:
new
(
)
;
let
mut
w
=
Writer
:
:
new
(
options
)
?
;
w
.
write
(
module
info
pipeline_options
&
mut
words
)
?
;
Ok
(
words
)
}
