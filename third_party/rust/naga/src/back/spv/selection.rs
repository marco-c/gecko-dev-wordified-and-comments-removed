use
super
:
:
{
Block
BlockContext
Instruction
}
;
use
spirv
:
:
Word
;
pub
(
super
)
struct
Selection
<
'
b
M
:
MergeTuple
>
{
block
:
&
'
b
mut
Block
merge_label
:
Option
<
Word
>
values
:
Vec
<
(
M
Word
)
>
merge_types
:
M
}
impl
<
'
b
M
:
MergeTuple
>
Selection
<
'
b
M
>
{
pub
(
super
)
fn
start
(
block
:
&
'
b
mut
Block
merge_types
:
M
)
-
>
Self
{
Selection
{
block
merge_label
:
None
values
:
vec
!
[
]
merge_types
}
}
pub
(
super
)
fn
block
(
&
mut
self
)
-
>
&
mut
Block
{
self
.
block
}
pub
(
super
)
fn
if_true
(
&
mut
self
ctx
:
&
mut
BlockContext
cond
:
Word
values
:
M
)
{
self
.
values
.
push
(
(
values
self
.
block
.
label_id
)
)
;
let
merge_label
=
self
.
make_merge_label
(
ctx
)
;
let
next_label
=
ctx
.
gen_id
(
)
;
ctx
.
function
.
consume
(
std
:
:
mem
:
:
replace
(
self
.
block
Block
:
:
new
(
next_label
)
)
Instruction
:
:
branch_conditional
(
cond
next_label
merge_label
)
)
;
}
pub
(
super
)
fn
finish
(
self
ctx
:
&
mut
BlockContext
final_values
:
M
)
-
>
M
{
match
self
{
Selection
{
merge_label
:
None
.
.
}
=
>
{
final_values
}
Selection
{
block
merge_label
:
Some
(
merge_label
)
mut
values
merge_types
}
=
>
{
values
.
push
(
(
final_values
block
.
label_id
)
)
;
ctx
.
function
.
consume
(
std
:
:
mem
:
:
replace
(
block
Block
:
:
new
(
merge_label
)
)
Instruction
:
:
branch
(
merge_label
)
)
;
merge_types
.
write_phis
(
ctx
block
&
values
)
}
}
}
fn
make_merge_label
(
&
mut
self
ctx
:
&
mut
BlockContext
)
-
>
Word
{
match
self
.
merge_label
{
None
=
>
{
let
merge_label
=
ctx
.
gen_id
(
)
;
self
.
block
.
body
.
push
(
Instruction
:
:
selection_merge
(
merge_label
spirv
:
:
SelectionControl
:
:
NONE
)
)
;
self
.
merge_label
=
Some
(
merge_label
)
;
merge_label
}
Some
(
merge_label
)
=
>
merge_label
}
}
}
pub
(
super
)
trait
MergeTuple
:
Sized
{
fn
write_phis
(
self
ctx
:
&
mut
BlockContext
block
:
&
mut
Block
predecessors
:
&
[
(
Self
Word
)
]
)
-
>
Self
;
}
impl
MergeTuple
for
Word
{
fn
write_phis
(
self
ctx
:
&
mut
BlockContext
block
:
&
mut
Block
predecessors
:
&
[
(
Word
Word
)
]
)
-
>
Word
{
let
merged_value
=
ctx
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
phi
(
self
merged_value
predecessors
)
)
;
merged_value
}
}
impl
MergeTuple
for
(
)
{
fn
write_phis
(
self
_
:
&
mut
BlockContext
_
:
&
mut
Block
_
:
&
[
(
(
)
Word
)
]
)
{
}
}
