use
super
:
:
{
selection
:
:
Selection
Block
BlockContext
Error
IdGenerator
Instruction
Word
}
;
use
crate
:
:
{
arena
:
:
Handle
back
:
:
BoundsCheckPolicy
}
;
pub
(
super
)
enum
ExpressionPointer
{
Ready
{
pointer_id
:
Word
}
Conditional
{
condition
:
Word
access
:
Instruction
}
}
pub
(
super
)
enum
BoundsCheckResult
{
KnownInBounds
(
u32
)
Computed
(
Word
)
Conditional
(
Word
)
}
pub
(
super
)
enum
MaybeKnown
<
T
>
{
Known
(
T
)
Computed
(
Word
)
}
impl
<
'
w
>
BlockContext
<
'
w
>
{
pub
(
super
)
fn
write_runtime_array_length
(
&
mut
self
array
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
Word
Error
>
{
let
(
structure_id
last_member_index
)
=
match
self
.
ir_function
.
expressions
[
array
]
{
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
match
self
.
ir_function
.
expressions
[
base
]
{
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
(
self
.
writer
.
global_variables
[
handle
.
index
(
)
]
.
id
index
)
}
crate
:
:
Expression
:
:
FunctionArgument
(
index
)
=
>
{
let
parameter_id
=
self
.
function
.
parameter_id
(
index
)
;
(
parameter_id
index
)
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
"
)
)
}
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
"
)
)
}
;
let
length_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
array_length
(
self
.
writer
.
get_uint_type_id
(
)
length_id
structure_id
last_member_index
)
)
;
Ok
(
length_id
)
}
fn
write_sequence_length
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
MaybeKnown
<
u32
>
Error
>
{
let
sequence_ty
=
self
.
fun_info
[
sequence
]
.
ty
.
inner_with
(
&
self
.
ir_module
.
types
)
;
match
sequence_ty
.
indexable_length
(
self
.
ir_module
)
?
{
crate
:
:
proc
:
:
IndexableLength
:
:
Known
(
known_length
)
=
>
{
Ok
(
MaybeKnown
:
:
Known
(
known_length
)
)
}
crate
:
:
proc
:
:
IndexableLength
:
:
Dynamic
=
>
{
let
length_id
=
self
.
write_runtime_array_length
(
sequence
block
)
?
;
Ok
(
MaybeKnown
:
:
Computed
(
length_id
)
)
}
crate
:
:
proc
:
:
IndexableLength
:
:
Specializable
(
constant
)
=
>
{
let
length_id
=
self
.
writer
.
constant_ids
[
constant
.
index
(
)
]
;
Ok
(
MaybeKnown
:
:
Computed
(
length_id
)
)
}
}
}
fn
write_sequence_max_index
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
MaybeKnown
<
u32
>
Error
>
{
match
self
.
write_sequence_length
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_length
)
=
>
{
assert
!
(
known_length
>
0
)
;
Ok
(
MaybeKnown
:
:
Known
(
known_length
-
1
)
)
}
MaybeKnown
:
:
Computed
(
length_id
)
=
>
{
let
const_one_id
=
self
.
get_index_constant
(
1
)
;
let
max_index_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
binary
(
spirv
:
:
Op
:
:
ISub
self
.
writer
.
get_uint_type_id
(
)
max_index_id
length_id
const_one_id
)
)
;
Ok
(
MaybeKnown
:
:
Computed
(
max_index_id
)
)
}
}
}
pub
(
super
)
fn
write_restricted_index
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
index_id
=
self
.
cached
[
index
]
;
let
max_index_id
=
match
self
.
write_sequence_max_index
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_max_index
)
=
>
{
if
let
crate
:
:
Expression
:
:
Constant
(
index_k
)
=
self
.
ir_function
.
expressions
[
index
]
{
if
let
Some
(
known_index
)
=
self
.
ir_module
.
constants
[
index_k
]
.
to_array_length
(
)
{
let
restricted
=
std
:
:
cmp
:
:
min
(
known_index
known_max_index
)
;
return
Ok
(
BoundsCheckResult
:
:
KnownInBounds
(
restricted
)
)
;
}
}
self
.
get_index_constant
(
known_max_index
)
}
MaybeKnown
:
:
Computed
(
max_index_id
)
=
>
max_index_id
}
;
let
restricted_index_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
ext_inst
(
self
.
writer
.
gl450_ext_inst_id
spirv
:
:
GLOp
:
:
UMin
self
.
writer
.
get_uint_type_id
(
)
restricted_index_id
&
[
index_id
max_index_id
]
)
)
;
Ok
(
BoundsCheckResult
:
:
Computed
(
restricted_index_id
)
)
}
fn
write_index_comparison
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
index_id
=
self
.
cached
[
index
]
;
let
length_id
=
match
self
.
write_sequence_length
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_length
)
=
>
{
if
let
crate
:
:
Expression
:
:
Constant
(
index_k
)
=
self
.
ir_function
.
expressions
[
index
]
{
if
let
Some
(
known_index
)
=
self
.
ir_module
.
constants
[
index_k
]
.
to_array_length
(
)
{
if
known_index
<
known_length
{
return
Ok
(
BoundsCheckResult
:
:
KnownInBounds
(
known_index
)
)
;
}
}
}
self
.
get_index_constant
(
known_length
)
}
MaybeKnown
:
:
Computed
(
length_id
)
=
>
length_id
}
;
let
condition_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
binary
(
spirv
:
:
Op
:
:
ULessThan
self
.
writer
.
get_bool_type_id
(
)
condition_id
index_id
length_id
)
)
;
Ok
(
BoundsCheckResult
:
:
Conditional
(
condition_id
)
)
}
pub
(
super
)
fn
write_conditional_indexed_load
<
F
>
(
&
mut
self
result_type
:
Word
condition
:
Word
block
:
&
mut
Block
emit_load
:
F
)
-
>
Word
where
F
:
FnOnce
(
&
mut
IdGenerator
&
mut
Block
)
-
>
Word
{
let
null_id
=
self
.
writer
.
write_constant_null
(
result_type
)
;
let
mut
selection
=
Selection
:
:
start
(
block
result_type
)
;
selection
.
if_true
(
self
condition
null_id
)
;
let
loaded_value
=
emit_load
(
&
mut
self
.
writer
.
id_gen
selection
.
block
(
)
)
;
selection
.
finish
(
self
loaded_value
)
}
pub
(
super
)
fn
write_bounds_check
(
&
mut
self
base
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
is_buffer
=
match
*
self
.
fun_info
[
base
]
.
ty
.
inner_with
(
&
self
.
ir_module
.
types
)
{
crate
:
:
TypeInner
:
:
Pointer
{
class
.
.
}
|
crate
:
:
TypeInner
:
:
ValuePointer
{
class
.
.
}
=
>
match
class
{
crate
:
:
StorageClass
:
:
Storage
{
access
:
_
}
|
crate
:
:
StorageClass
:
:
Uniform
=
>
true
_
=
>
false
}
_
=
>
false
}
;
let
policy
=
if
is_buffer
{
self
.
writer
.
bounds_check_policies
.
buffer
}
else
{
self
.
writer
.
bounds_check_policies
.
index
}
;
Ok
(
match
policy
{
BoundsCheckPolicy
:
:
Restrict
=
>
self
.
write_restricted_index
(
base
index
block
)
?
BoundsCheckPolicy
:
:
ReadZeroSkipWrite
=
>
{
self
.
write_index_comparison
(
base
index
block
)
?
}
BoundsCheckPolicy
:
:
Unchecked
=
>
BoundsCheckResult
:
:
Computed
(
self
.
cached
[
index
]
)
}
)
}
pub
(
super
)
fn
write_vector_access
(
&
mut
self
expr_handle
:
Handle
<
crate
:
:
Expression
>
base
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
Word
Error
>
{
let
result_type_id
=
self
.
get_expression_type_id
(
&
self
.
fun_info
[
expr_handle
]
.
ty
)
;
let
base_id
=
self
.
cached
[
base
]
;
let
index_id
=
self
.
cached
[
index
]
;
let
result_id
=
match
self
.
write_bounds_check
(
base
index
block
)
?
{
BoundsCheckResult
:
:
KnownInBounds
(
known_index
)
=
>
{
let
result_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
composite_extract
(
result_type_id
result_id
base_id
&
[
known_index
]
)
)
;
result_id
}
BoundsCheckResult
:
:
Computed
(
computed_index_id
)
=
>
{
let
result_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
vector_extract_dynamic
(
result_type_id
result_id
base_id
computed_index_id
)
)
;
result_id
}
BoundsCheckResult
:
:
Conditional
(
comparison_id
)
=
>
{
self
.
write_conditional_indexed_load
(
result_type_id
comparison_id
block
|
id_gen
block
|
{
let
element_id
=
id_gen
.
next
(
)
;
block
.
body
.
push
(
Instruction
:
:
vector_extract_dynamic
(
result_type_id
element_id
base_id
index_id
)
)
;
element_id
}
)
}
}
;
Ok
(
result_id
)
}
}
