use
super
:
:
{
helpers
:
:
{
global_needs_wrapper
map_storage_class
}
selection
:
:
Selection
Block
BlockContext
Error
IdGenerator
Instruction
Word
}
;
use
crate
:
:
{
arena
:
:
Handle
proc
:
:
{
index
:
:
GuardedIndex
BoundsCheckPolicy
}
}
;
#
[
derive
(
Debug
)
]
pub
(
super
)
enum
BoundsCheckResult
{
KnownInBounds
(
u32
)
Computed
(
Word
)
Conditional
{
condition_id
:
Word
index_id
:
Word
}
}
#
[
derive
(
Copy
Clone
)
]
pub
(
super
)
enum
MaybeKnown
<
T
>
{
Known
(
T
)
Computed
(
Word
)
}
impl
BlockContext
<
'
_
>
{
pub
(
super
)
fn
write_runtime_array_length
(
&
mut
self
array
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
Word
Error
>
{
let
binding_array_index_id
:
Option
<
Word
>
;
let
global_handle
:
Handle
<
crate
:
:
GlobalVariable
>
;
let
opt_last_member_index
:
Option
<
u32
>
;
match
self
.
ir_function
.
expressions
[
array
]
{
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
match
self
.
ir_function
.
expressions
[
base
]
{
crate
:
:
Expression
:
:
AccessIndex
{
base
:
base_outer
index
:
index_outer
}
=
>
match
self
.
ir_function
.
expressions
[
base_outer
]
{
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
index_id
=
self
.
get_index_constant
(
index_outer
)
;
binding_array_index_id
=
Some
(
index_id
)
;
global_handle
=
handle
;
opt_last_member_index
=
Some
(
index
)
;
}
_
=
>
{
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
:
AccessIndex
(
AccessIndex
(
Global
)
)
"
)
)
}
}
crate
:
:
Expression
:
:
Access
{
base
:
base_outer
index
:
index_outer
}
=
>
match
self
.
ir_function
.
expressions
[
base_outer
]
{
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
index_id
=
self
.
cached
[
index_outer
]
;
binding_array_index_id
=
Some
(
index_id
)
;
global_handle
=
handle
;
opt_last_member_index
=
Some
(
index
)
;
}
_
=
>
{
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
:
AccessIndex
(
Access
(
Global
)
)
"
)
)
}
}
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
binding_array_index_id
=
None
;
global_handle
=
handle
;
opt_last_member_index
=
Some
(
index
)
;
}
_
=
>
{
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
:
AccessIndex
(
<
unexpected
>
)
"
)
)
}
}
}
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
binding_array_index_id
=
None
;
global_handle
=
handle
;
opt_last_member_index
=
None
;
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
4
"
)
)
}
;
let
global
=
&
self
.
ir_module
.
global_variables
[
global_handle
]
;
match
(
&
self
.
ir_module
.
types
[
global
.
ty
]
.
inner
binding_array_index_id
)
{
(
&
crate
:
:
TypeInner
:
:
BindingArray
{
.
.
}
Some
(
_
)
)
=
>
{
}
(
_
None
)
=
>
{
}
_
=
>
{
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
:
bad
binding
array
inference
"
)
)
}
}
let
gvar
=
self
.
writer
.
global_variables
[
global_handle
]
.
clone
(
)
;
let
global
=
&
self
.
ir_module
.
global_variables
[
global_handle
]
;
let
needs_wrapper
=
global_needs_wrapper
(
self
.
ir_module
global
)
;
let
(
last_member_index
gvar_id
)
=
match
(
opt_last_member_index
needs_wrapper
)
{
(
Some
(
index
)
false
)
=
>
{
(
index
gvar
.
access_id
)
}
(
None
true
)
=
>
{
(
0
gvar
.
var_id
)
}
_
=
>
{
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
:
bad
SPIR
-
V
wrapper
struct
inference
"
)
)
;
}
}
;
let
structure_id
=
match
binding_array_index_id
{
Some
(
index_id
)
=
>
{
let
element_type_id
=
match
self
.
ir_module
.
types
[
global
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
BindingArray
{
base
size
:
_
}
=
>
{
let
base_id
=
self
.
get_handle_type_id
(
base
)
;
let
class
=
map_storage_class
(
global
.
space
)
;
self
.
get_pointer_type_id
(
base_id
class
)
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
5
"
)
)
}
;
let
structure_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
access_chain
(
element_type_id
structure_id
gvar_id
&
[
index_id
]
)
)
;
structure_id
}
None
=
>
gvar_id
}
;
let
length_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
array_length
(
self
.
writer
.
get_u32_type_id
(
)
length_id
structure_id
last_member_index
)
)
;
Ok
(
length_id
)
}
fn
write_sequence_length
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
MaybeKnown
<
u32
>
Error
>
{
let
sequence_ty
=
self
.
fun_info
[
sequence
]
.
ty
.
inner_with
(
&
self
.
ir_module
.
types
)
;
match
sequence_ty
.
indexable_length_resolved
(
self
.
ir_module
)
{
Ok
(
crate
:
:
proc
:
:
IndexableLength
:
:
Known
(
known_length
)
)
=
>
{
Ok
(
MaybeKnown
:
:
Known
(
known_length
)
)
}
Ok
(
crate
:
:
proc
:
:
IndexableLength
:
:
Dynamic
)
=
>
{
let
length_id
=
self
.
write_runtime_array_length
(
sequence
block
)
?
;
Ok
(
MaybeKnown
:
:
Computed
(
length_id
)
)
}
Err
(
err
)
=
>
{
log
:
:
error
!
(
"
Sequence
length
for
{
sequence
:
?
}
failed
:
{
err
}
"
)
;
Err
(
Error
:
:
Validation
(
"
indexable
length
"
)
)
}
}
}
fn
write_sequence_max_index
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
MaybeKnown
<
u32
>
Error
>
{
match
self
.
write_sequence_length
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_length
)
=
>
{
assert
!
(
known_length
>
0
)
;
Ok
(
MaybeKnown
:
:
Known
(
known_length
-
1
)
)
}
MaybeKnown
:
:
Computed
(
length_id
)
=
>
{
let
const_one_id
=
self
.
get_index_constant
(
1
)
;
let
max_index_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
binary
(
spirv
:
:
Op
:
:
ISub
self
.
writer
.
get_u32_type_id
(
)
max_index_id
length_id
const_one_id
)
)
;
Ok
(
MaybeKnown
:
:
Computed
(
max_index_id
)
)
}
}
}
pub
(
super
)
fn
write_restricted_index
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
index
:
GuardedIndex
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
max_index
=
self
.
write_sequence_max_index
(
sequence
block
)
?
;
if
let
(
GuardedIndex
:
:
Known
(
index
)
MaybeKnown
:
:
Known
(
max_index
)
)
=
(
index
max_index
)
{
let
restricted
=
core
:
:
cmp
:
:
min
(
index
max_index
)
;
return
Ok
(
BoundsCheckResult
:
:
KnownInBounds
(
restricted
)
)
;
}
let
index_id
=
match
index
{
GuardedIndex
:
:
Known
(
value
)
=
>
self
.
get_index_constant
(
value
)
GuardedIndex
:
:
Expression
(
expr
)
=
>
self
.
cached
[
expr
]
}
;
let
max_index_id
=
match
max_index
{
MaybeKnown
:
:
Known
(
value
)
=
>
self
.
get_index_constant
(
value
)
MaybeKnown
:
:
Computed
(
id
)
=
>
id
}
;
let
restricted_index_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
ext_inst
(
self
.
writer
.
gl450_ext_inst_id
spirv
:
:
GLOp
:
:
UMin
self
.
writer
.
get_u32_type_id
(
)
restricted_index_id
&
[
index_id
max_index_id
]
)
)
;
Ok
(
BoundsCheckResult
:
:
Computed
(
restricted_index_id
)
)
}
fn
write_index_comparison
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
index
:
GuardedIndex
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
length
=
self
.
write_sequence_length
(
sequence
block
)
?
;
if
let
(
GuardedIndex
:
:
Known
(
index
)
MaybeKnown
:
:
Known
(
length
)
)
=
(
index
length
)
{
if
index
<
length
{
return
Ok
(
BoundsCheckResult
:
:
KnownInBounds
(
index
)
)
;
}
}
let
index_id
=
match
index
{
GuardedIndex
:
:
Known
(
value
)
=
>
self
.
get_index_constant
(
value
)
GuardedIndex
:
:
Expression
(
expr
)
=
>
self
.
cached
[
expr
]
}
;
let
length_id
=
match
length
{
MaybeKnown
:
:
Known
(
value
)
=
>
self
.
get_index_constant
(
value
)
MaybeKnown
:
:
Computed
(
id
)
=
>
id
}
;
let
condition_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
binary
(
spirv
:
:
Op
:
:
ULessThan
self
.
writer
.
get_bool_type_id
(
)
condition_id
index_id
length_id
)
)
;
Ok
(
BoundsCheckResult
:
:
Conditional
{
condition_id
index_id
}
)
}
pub
(
super
)
fn
write_conditional_indexed_load
<
F
>
(
&
mut
self
result_type
:
Word
condition
:
Word
block
:
&
mut
Block
emit_load
:
F
)
-
>
Word
where
F
:
FnOnce
(
&
mut
IdGenerator
&
mut
Block
)
-
>
Word
{
let
null_id
=
self
.
writer
.
get_constant_null
(
result_type
)
;
let
mut
selection
=
Selection
:
:
start
(
block
result_type
)
;
selection
.
if_true
(
self
condition
null_id
)
;
let
loaded_value
=
emit_load
(
&
mut
self
.
writer
.
id_gen
selection
.
block
(
)
)
;
selection
.
finish
(
self
loaded_value
)
}
pub
(
super
)
fn
write_bounds_check
(
&
mut
self
base
:
Handle
<
crate
:
:
Expression
>
mut
index
:
GuardedIndex
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
index
.
try_resolve_to_constant
(
&
self
.
ir_function
.
expressions
self
.
ir_module
)
;
let
policy
=
self
.
writer
.
bounds_check_policies
.
choose_policy
(
base
&
self
.
ir_module
.
types
self
.
fun_info
)
;
Ok
(
match
policy
{
BoundsCheckPolicy
:
:
Restrict
=
>
self
.
write_restricted_index
(
base
index
block
)
?
BoundsCheckPolicy
:
:
ReadZeroSkipWrite
=
>
{
self
.
write_index_comparison
(
base
index
block
)
?
}
BoundsCheckPolicy
:
:
Unchecked
=
>
match
index
{
GuardedIndex
:
:
Known
(
value
)
=
>
BoundsCheckResult
:
:
KnownInBounds
(
value
)
GuardedIndex
:
:
Expression
(
expr
)
=
>
BoundsCheckResult
:
:
Computed
(
self
.
cached
[
expr
]
)
}
}
)
}
pub
(
super
)
fn
write_vector_access
(
&
mut
self
expr_handle
:
Handle
<
crate
:
:
Expression
>
base
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
Word
Error
>
{
let
result_type_id
=
self
.
get_expression_type_id
(
&
self
.
fun_info
[
expr_handle
]
.
ty
)
;
let
base_id
=
self
.
cached
[
base
]
;
let
index
=
GuardedIndex
:
:
Expression
(
index
)
;
let
result_id
=
match
self
.
write_bounds_check
(
base
index
block
)
?
{
BoundsCheckResult
:
:
KnownInBounds
(
known_index
)
=
>
{
let
result_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
composite_extract
(
result_type_id
result_id
base_id
&
[
known_index
]
)
)
;
result_id
}
BoundsCheckResult
:
:
Computed
(
computed_index_id
)
=
>
{
let
result_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
vector_extract_dynamic
(
result_type_id
result_id
base_id
computed_index_id
)
)
;
result_id
}
BoundsCheckResult
:
:
Conditional
{
condition_id
index_id
}
=
>
{
self
.
write_conditional_indexed_load
(
result_type_id
condition_id
block
|
id_gen
block
|
{
let
element_id
=
id_gen
.
next
(
)
;
block
.
body
.
push
(
Instruction
:
:
vector_extract_dynamic
(
result_type_id
element_id
base_id
index_id
)
)
;
element_id
}
)
}
}
;
Ok
(
result_id
)
}
}
