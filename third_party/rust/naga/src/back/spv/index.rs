use
super
:
:
{
helpers
:
:
{
global_needs_wrapper
map_storage_class
}
selection
:
:
Selection
Block
BlockContext
Error
IdGenerator
Instruction
Word
}
;
use
crate
:
:
{
arena
:
:
Handle
proc
:
:
BoundsCheckPolicy
}
;
pub
(
super
)
enum
BoundsCheckResult
{
KnownInBounds
(
u32
)
Computed
(
Word
)
Conditional
(
Word
)
}
pub
(
super
)
enum
MaybeKnown
<
T
>
{
Known
(
T
)
Computed
(
Word
)
}
impl
<
'
w
>
BlockContext
<
'
w
>
{
pub
(
super
)
fn
write_runtime_array_length
(
&
mut
self
array
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
Word
Error
>
{
let
(
opt_array_index_id
global_handle
opt_last_member_index
)
=
match
self
.
ir_function
.
expressions
[
array
]
{
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
match
self
.
ir_function
.
expressions
[
base
]
{
crate
:
:
Expression
:
:
AccessIndex
{
base
:
base_outer
index
:
index_outer
}
=
>
match
self
.
ir_function
.
expressions
[
base_outer
]
{
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
index_id
=
self
.
get_index_constant
(
index_outer
)
;
(
Some
(
index_id
)
handle
Some
(
index
)
)
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
1a
"
)
)
}
crate
:
:
Expression
:
:
Access
{
base
:
base_outer
index
:
index_outer
}
=
>
match
self
.
ir_function
.
expressions
[
base_outer
]
{
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
index_id
=
self
.
cached
[
index_outer
]
;
(
Some
(
index_id
)
handle
Some
(
index
)
)
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
1b
"
)
)
}
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
global
=
&
self
.
ir_module
.
global_variables
[
handle
]
;
match
self
.
ir_module
.
types
[
global
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
BindingArray
{
.
.
}
=
>
(
Some
(
index
)
handle
None
)
_
=
>
(
None
handle
Some
(
index
)
)
}
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
1c
"
)
)
}
}
crate
:
:
Expression
:
:
Access
{
base
index
}
=
>
match
self
.
ir_function
.
expressions
[
base
]
{
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
index_id
=
self
.
cached
[
index
]
;
let
global
=
&
self
.
ir_module
.
global_variables
[
handle
]
;
match
self
.
ir_module
.
types
[
global
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
BindingArray
{
.
.
}
=
>
(
Some
(
index_id
)
handle
None
)
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
2a
"
)
)
}
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
2b
"
)
)
}
crate
:
:
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
global
=
&
self
.
ir_module
.
global_variables
[
handle
]
;
if
!
global_needs_wrapper
(
self
.
ir_module
global
)
{
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
3
"
)
)
;
}
(
None
handle
None
)
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
4
"
)
)
}
;
let
gvar
=
self
.
writer
.
global_variables
[
global_handle
]
.
clone
(
)
;
let
global
=
&
self
.
ir_module
.
global_variables
[
global_handle
]
;
let
(
last_member_index
gvar_id
)
=
match
opt_last_member_index
{
Some
(
index
)
=
>
(
index
gvar
.
access_id
)
None
=
>
{
if
!
global_needs_wrapper
(
self
.
ir_module
global
)
{
return
Err
(
Error
:
:
Validation
(
"
pointer
to
a
global
that
is
not
a
wrapped
array
"
)
)
;
}
(
0
gvar
.
var_id
)
}
}
;
let
structure_id
=
match
opt_array_index_id
{
Some
(
index_id
)
=
>
{
let
element_type_id
=
match
self
.
ir_module
.
types
[
global
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
BindingArray
{
base
size
:
_
}
=
>
{
let
class
=
map_storage_class
(
global
.
space
)
;
self
.
get_pointer_id
(
base
class
)
?
}
_
=
>
return
Err
(
Error
:
:
Validation
(
"
array
length
expression
case
-
5
"
)
)
}
;
let
structure_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
access_chain
(
element_type_id
structure_id
gvar_id
&
[
index_id
]
)
)
;
structure_id
}
None
=
>
gvar_id
}
;
let
length_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
array_length
(
self
.
writer
.
get_uint_type_id
(
)
length_id
structure_id
last_member_index
)
)
;
Ok
(
length_id
)
}
fn
write_sequence_length
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
MaybeKnown
<
u32
>
Error
>
{
let
sequence_ty
=
self
.
fun_info
[
sequence
]
.
ty
.
inner_with
(
&
self
.
ir_module
.
types
)
;
match
sequence_ty
.
indexable_length
(
self
.
ir_module
)
{
Ok
(
crate
:
:
proc
:
:
IndexableLength
:
:
Known
(
known_length
)
)
=
>
{
Ok
(
MaybeKnown
:
:
Known
(
known_length
)
)
}
Ok
(
crate
:
:
proc
:
:
IndexableLength
:
:
Dynamic
)
=
>
{
let
length_id
=
self
.
write_runtime_array_length
(
sequence
block
)
?
;
Ok
(
MaybeKnown
:
:
Computed
(
length_id
)
)
}
Err
(
err
)
=
>
{
log
:
:
error
!
(
"
Sequence
length
for
{
:
?
}
failed
:
{
}
"
sequence
err
)
;
Err
(
Error
:
:
Validation
(
"
indexable
length
"
)
)
}
}
}
fn
write_sequence_max_index
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
MaybeKnown
<
u32
>
Error
>
{
match
self
.
write_sequence_length
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_length
)
=
>
{
assert
!
(
known_length
>
0
)
;
Ok
(
MaybeKnown
:
:
Known
(
known_length
-
1
)
)
}
MaybeKnown
:
:
Computed
(
length_id
)
=
>
{
let
const_one_id
=
self
.
get_index_constant
(
1
)
;
let
max_index_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
binary
(
spirv
:
:
Op
:
:
ISub
self
.
writer
.
get_uint_type_id
(
)
max_index_id
length_id
const_one_id
)
)
;
Ok
(
MaybeKnown
:
:
Computed
(
max_index_id
)
)
}
}
}
pub
(
super
)
fn
write_restricted_index
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
index_id
=
self
.
cached
[
index
]
;
let
max_index_id
=
match
self
.
write_sequence_max_index
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_max_index
)
=
>
{
if
let
Ok
(
known_index
)
=
self
.
ir_module
.
to_ctx
(
)
.
eval_expr_to_u32_from
(
index
&
self
.
ir_function
.
expressions
)
{
let
restricted
=
std
:
:
cmp
:
:
min
(
known_index
known_max_index
)
;
return
Ok
(
BoundsCheckResult
:
:
KnownInBounds
(
restricted
)
)
;
}
self
.
get_index_constant
(
known_max_index
)
}
MaybeKnown
:
:
Computed
(
max_index_id
)
=
>
max_index_id
}
;
let
restricted_index_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
ext_inst
(
self
.
writer
.
gl450_ext_inst_id
spirv
:
:
GLOp
:
:
UMin
self
.
writer
.
get_uint_type_id
(
)
restricted_index_id
&
[
index_id
max_index_id
]
)
)
;
Ok
(
BoundsCheckResult
:
:
Computed
(
restricted_index_id
)
)
}
fn
write_index_comparison
(
&
mut
self
sequence
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
index_id
=
self
.
cached
[
index
]
;
let
length_id
=
match
self
.
write_sequence_length
(
sequence
block
)
?
{
MaybeKnown
:
:
Known
(
known_length
)
=
>
{
if
let
Ok
(
known_index
)
=
self
.
ir_module
.
to_ctx
(
)
.
eval_expr_to_u32_from
(
index
&
self
.
ir_function
.
expressions
)
{
if
known_index
<
known_length
{
return
Ok
(
BoundsCheckResult
:
:
KnownInBounds
(
known_index
)
)
;
}
}
self
.
get_index_constant
(
known_length
)
}
MaybeKnown
:
:
Computed
(
length_id
)
=
>
length_id
}
;
let
condition_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
binary
(
spirv
:
:
Op
:
:
ULessThan
self
.
writer
.
get_bool_type_id
(
)
condition_id
index_id
length_id
)
)
;
Ok
(
BoundsCheckResult
:
:
Conditional
(
condition_id
)
)
}
pub
(
super
)
fn
write_conditional_indexed_load
<
F
>
(
&
mut
self
result_type
:
Word
condition
:
Word
block
:
&
mut
Block
emit_load
:
F
)
-
>
Word
where
F
:
FnOnce
(
&
mut
IdGenerator
&
mut
Block
)
-
>
Word
{
let
null_id
=
self
.
writer
.
get_constant_null
(
result_type
)
;
let
mut
selection
=
Selection
:
:
start
(
block
result_type
)
;
selection
.
if_true
(
self
condition
null_id
)
;
let
loaded_value
=
emit_load
(
&
mut
self
.
writer
.
id_gen
selection
.
block
(
)
)
;
selection
.
finish
(
self
loaded_value
)
}
pub
(
super
)
fn
write_bounds_check
(
&
mut
self
base
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
BoundsCheckResult
Error
>
{
let
policy
=
self
.
writer
.
bounds_check_policies
.
choose_policy
(
base
&
self
.
ir_module
.
types
self
.
fun_info
)
;
Ok
(
match
policy
{
BoundsCheckPolicy
:
:
Restrict
=
>
self
.
write_restricted_index
(
base
index
block
)
?
BoundsCheckPolicy
:
:
ReadZeroSkipWrite
=
>
{
self
.
write_index_comparison
(
base
index
block
)
?
}
BoundsCheckPolicy
:
:
Unchecked
=
>
BoundsCheckResult
:
:
Computed
(
self
.
cached
[
index
]
)
}
)
}
pub
(
super
)
fn
write_vector_access
(
&
mut
self
expr_handle
:
Handle
<
crate
:
:
Expression
>
base
:
Handle
<
crate
:
:
Expression
>
index
:
Handle
<
crate
:
:
Expression
>
block
:
&
mut
Block
)
-
>
Result
<
Word
Error
>
{
let
result_type_id
=
self
.
get_expression_type_id
(
&
self
.
fun_info
[
expr_handle
]
.
ty
)
;
let
base_id
=
self
.
cached
[
base
]
;
let
index_id
=
self
.
cached
[
index
]
;
let
result_id
=
match
self
.
write_bounds_check
(
base
index
block
)
?
{
BoundsCheckResult
:
:
KnownInBounds
(
known_index
)
=
>
{
let
result_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
composite_extract
(
result_type_id
result_id
base_id
&
[
known_index
]
)
)
;
result_id
}
BoundsCheckResult
:
:
Computed
(
computed_index_id
)
=
>
{
let
result_id
=
self
.
gen_id
(
)
;
block
.
body
.
push
(
Instruction
:
:
vector_extract_dynamic
(
result_type_id
result_id
base_id
computed_index_id
)
)
;
result_id
}
BoundsCheckResult
:
:
Conditional
(
comparison_id
)
=
>
{
self
.
write_conditional_indexed_load
(
result_type_id
comparison_id
block
|
id_gen
block
|
{
let
element_id
=
id_gen
.
next
(
)
;
block
.
body
.
push
(
Instruction
:
:
vector_extract_dynamic
(
result_type_id
element_id
base_id
index_id
)
)
;
element_id
}
)
}
}
;
Ok
(
result_id
)
}
}
