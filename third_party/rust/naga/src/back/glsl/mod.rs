pub
use
features
:
:
Features
;
use
crate
:
:
{
proc
:
:
{
EntryPointIndex
NameKey
Namer
TypeResolution
}
valid
:
:
{
FunctionInfo
ModuleInfo
}
Arena
ArraySize
BinaryOperator
Binding
BuiltIn
Bytes
ConservativeDepth
Constant
ConstantInner
DerivativeAxis
Expression
FastHashMap
Function
GlobalVariable
Handle
ImageClass
Interpolation
LocalVariable
Module
RelationalFunction
ScalarKind
ScalarValue
ShaderStage
Statement
StorageAccess
StorageClass
StorageFormat
StructMember
Type
TypeInner
UnaryOperator
}
;
use
features
:
:
FeaturesManager
;
use
std
:
:
{
cmp
:
:
Ordering
fmt
io
:
:
{
Error
as
IoError
Write
}
}
;
use
thiserror
:
:
Error
;
mod
features
;
mod
keywords
;
pub
const
SUPPORTED_CORE_VERSIONS
:
&
[
u16
]
=
&
[
330
400
410
420
430
440
450
]
;
pub
const
SUPPORTED_ES_VERSIONS
:
&
[
u16
]
=
&
[
300
310
320
]
;
const
INDENT
:
&
str
=
"
"
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
Version
{
Desktop
(
u16
)
Embedded
(
u16
)
}
impl
Version
{
fn
is_es
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
_
)
=
>
false
Version
:
:
Embedded
(
_
)
=
>
true
}
}
fn
is_supported
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
v
)
=
>
SUPPORTED_CORE_VERSIONS
.
contains
(
&
v
)
Version
:
:
Embedded
(
v
)
=
>
SUPPORTED_ES_VERSIONS
.
contains
(
&
v
)
}
}
fn
supports_explicit_locations
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Embedded
(
310
)
|
|
*
self
>
=
Version
:
:
Desktop
(
410
)
}
}
impl
PartialOrd
for
Version
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
match
(
*
self
*
other
)
{
(
Version
:
:
Desktop
(
x
)
Version
:
:
Desktop
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
(
Version
:
:
Embedded
(
x
)
Version
:
:
Embedded
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
_
=
>
None
}
}
}
impl
fmt
:
:
Display
for
Version
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Version
:
:
Desktop
(
v
)
=
>
write
!
(
f
"
{
}
core
"
v
)
Version
:
:
Embedded
(
v
)
=
>
write
!
(
f
"
{
}
es
"
v
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Options
{
pub
version
:
Version
pub
shader_stage
:
ShaderStage
pub
entry_point
:
String
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
Options
{
version
:
Version
:
:
Embedded
(
320
)
shader_stage
:
ShaderStage
:
:
Compute
entry_point
:
"
main
"
.
to_string
(
)
}
}
}
pub
struct
ReflectionInfo
{
pub
texture_mapping
:
FastHashMap
<
String
TextureMapping
>
pub
uniforms
:
FastHashMap
<
Handle
<
GlobalVariable
>
String
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TextureMapping
{
pub
texture
:
Handle
<
GlobalVariable
>
pub
sampler
:
Option
<
Handle
<
GlobalVariable
>
>
}
enum
FunctionType
{
Function
(
Handle
<
Function
>
)
EntryPoint
(
EntryPointIndex
)
}
struct
FunctionCtx
<
'
a
>
{
func
:
FunctionType
info
:
&
'
a
FunctionInfo
expressions
:
&
'
a
Arena
<
Expression
>
}
impl
<
'
a
>
FunctionCtx
<
'
a
>
{
fn
name_key
(
&
self
local
:
Handle
<
LocalVariable
>
)
-
>
NameKey
{
match
self
.
func
{
FunctionType
:
:
Function
(
handle
)
=
>
NameKey
:
:
FunctionLocal
(
handle
local
)
FunctionType
:
:
EntryPoint
(
idx
)
=
>
NameKey
:
:
EntryPointLocal
(
idx
local
)
}
}
fn
argument_key
(
&
self
arg
:
u32
)
-
>
NameKey
{
match
self
.
func
{
FunctionType
:
:
Function
(
handle
)
=
>
NameKey
:
:
FunctionArgument
(
handle
arg
)
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
NameKey
:
:
EntryPointArgument
(
ep_index
arg
)
}
}
}
#
[
derive
(
Default
)
]
struct
IdGenerator
(
u32
)
;
impl
IdGenerator
{
fn
generate
(
&
mut
self
)
-
>
u32
{
let
ret
=
self
.
0
;
self
.
0
+
=
1
;
ret
}
}
struct
VaryingName
<
'
a
>
{
binding
:
&
'
a
Binding
stage
:
ShaderStage
output
:
bool
}
impl
fmt
:
:
Display
for
VaryingName
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
.
binding
{
Binding
:
:
Location
(
location
_
)
=
>
{
let
prefix
=
match
(
self
.
stage
self
.
output
)
{
(
ShaderStage
:
:
Compute
_
)
=
>
unreachable
!
(
)
(
ShaderStage
:
:
Vertex
false
)
=
>
"
p2vs
"
(
ShaderStage
:
:
Vertex
true
)
|
(
ShaderStage
:
:
Fragment
false
)
=
>
"
vs2fs
"
(
ShaderStage
:
:
Fragment
true
)
=
>
"
fs2p
"
}
;
write
!
(
f
"
_
{
}
_location
{
}
"
prefix
location
)
}
Binding
:
:
BuiltIn
(
built_in
)
=
>
{
write
!
(
f
"
{
}
"
glsl_built_in
(
built_in
self
.
output
)
)
}
}
}
}
type
BackendResult
=
Result
<
(
)
Error
>
;
#
[
derive
(
Debug
Error
)
]
pub
enum
Error
{
#
[
error
(
"
I
/
O
error
"
)
]
IoError
(
#
[
from
]
IoError
)
#
[
error
(
"
The
selected
version
doesn
'
t
support
{
0
:
?
}
"
)
]
MissingFeatures
(
Features
)
#
[
error
(
"
Push
constants
aren
'
t
supported
"
)
]
PushConstantNotSupported
#
[
error
(
"
The
specified
version
isn
'
t
supported
"
)
]
VersionNotSupported
#
[
error
(
"
The
requested
entry
point
couldn
'
t
be
found
"
)
]
EntryPointNotFound
#
[
error
(
"
A
call
was
made
to
an
unsupported
external
:
{
0
}
"
)
]
UnsupportedExternal
(
String
)
#
[
error
(
"
A
scalar
with
an
unsupported
width
was
requested
:
{
0
:
?
}
{
1
:
?
}
"
)
]
UnsupportedScalar
(
ScalarKind
Bytes
)
#
[
error
(
"
Patch
interpolation
isn
'
t
supported
"
)
]
PatchInterpolationNotSupported
#
[
error
(
"
A
image
was
used
with
multiple
samplers
"
)
]
ImageMultipleSamplers
#
[
error
(
"
{
0
}
"
)
]
Custom
(
String
)
}
pub
struct
Writer
<
'
a
W
>
{
module
:
&
'
a
Module
info
:
&
'
a
ModuleInfo
out
:
W
options
:
&
'
a
Options
features
:
FeaturesManager
names
:
FastHashMap
<
NameKey
String
>
reflection_names
:
FastHashMap
<
Handle
<
Type
>
String
>
entry_point
:
&
'
a
crate
:
:
EntryPoint
entry_point_idx
:
EntryPointIndex
block_id
:
IdGenerator
cached_expressions
:
FastHashMap
<
Handle
<
Expression
>
String
>
}
impl
<
'
a
W
:
Write
>
Writer
<
'
a
W
>
{
pub
fn
new
(
out
:
W
module
:
&
'
a
Module
info
:
&
'
a
ModuleInfo
options
:
&
'
a
Options
)
-
>
Result
<
Self
Error
>
{
if
!
options
.
version
.
is_supported
(
)
{
log
:
:
error
!
(
"
Version
{
}
"
options
.
version
)
;
return
Err
(
Error
:
:
VersionNotSupported
)
;
}
let
ep_idx
=
module
.
entry_points
.
iter
(
)
.
position
(
|
ep
|
options
.
shader_stage
=
=
ep
.
stage
&
&
options
.
entry_point
=
=
ep
.
name
)
.
ok_or
(
Error
:
:
EntryPointNotFound
)
?
;
let
mut
names
=
FastHashMap
:
:
default
(
)
;
Namer
:
:
default
(
)
.
reset
(
module
keywords
:
:
RESERVED_KEYWORDS
&
mut
names
)
;
let
mut
this
=
Self
{
module
info
out
options
features
:
FeaturesManager
:
:
new
(
)
names
reflection_names
:
FastHashMap
:
:
default
(
)
entry_point
:
&
module
.
entry_points
[
ep_idx
]
entry_point_idx
:
ep_idx
as
u16
block_id
:
IdGenerator
:
:
default
(
)
cached_expressions
:
FastHashMap
:
:
default
(
)
}
;
this
.
collect_required_features
(
)
?
;
Ok
(
this
)
}
pub
fn
write
(
&
mut
self
)
-
>
Result
<
ReflectionInfo
Error
>
{
let
es
=
self
.
options
.
version
.
is_es
(
)
;
writeln
!
(
self
.
out
"
#
version
{
}
"
self
.
options
.
version
)
?
;
self
.
features
.
write
(
self
.
options
.
version
&
mut
self
.
out
)
?
;
if
es
{
writeln
!
(
self
.
out
)
?
;
writeln
!
(
self
.
out
"
precision
highp
float
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
self
.
options
.
shader_stage
=
=
ShaderStage
:
:
Compute
{
let
workgroup_size
=
self
.
entry_point
.
workgroup_size
;
writeln
!
(
self
.
out
"
layout
(
local_size_x
=
{
}
local_size_y
=
{
}
local_size_z
=
{
}
)
in
;
"
workgroup_size
[
0
]
workgroup_size
[
1
]
workgroup_size
[
2
]
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
let
Some
(
depth_test
)
=
self
.
entry_point
.
early_depth_test
{
writeln
!
(
self
.
out
"
layout
(
early_fragment_tests
)
in
;
"
)
?
;
if
let
Some
(
conservative
)
=
depth_test
.
conservative
{
writeln
!
(
self
.
out
"
layout
(
depth_
{
}
)
out
float
gl_FragDepth
;
"
match
conservative
{
ConservativeDepth
:
:
GreaterEqual
=
>
"
greater
"
ConservativeDepth
:
:
LessEqual
=
>
"
less
"
ConservativeDepth
:
:
Unchanged
=
>
"
unchanged
"
}
)
?
;
}
writeln
!
(
self
.
out
)
?
;
}
for
(
handle
ty
)
in
self
.
module
.
types
.
iter
(
)
{
if
let
TypeInner
:
:
Struct
{
block
:
_
ref
members
}
=
ty
.
inner
{
let
is_global_struct
=
self
.
module
.
global_variables
.
iter
(
)
.
any
(
|
e
|
e
.
1
.
ty
=
=
handle
)
;
if
!
is_global_struct
{
self
.
write_struct
(
false
handle
members
)
?
}
}
}
let
ep_info
=
self
.
info
.
get_entry_point
(
self
.
entry_point_idx
as
usize
)
;
for
(
handle
global
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
ep_info
[
handle
]
.
is_empty
(
)
{
continue
;
}
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
if
let
TypeInner
:
:
Image
{
class
:
ImageClass
:
:
Storage
(
format
)
.
.
}
=
self
.
module
.
types
[
global
.
ty
]
.
inner
{
write
!
(
self
.
out
"
layout
(
{
}
)
"
glsl_storage_format
(
format
)
)
?
;
}
if
global
.
storage_access
=
=
StorageAccess
:
:
LOAD
{
write
!
(
self
.
out
"
readonly
"
)
?
;
}
else
if
global
.
storage_access
=
=
StorageAccess
:
:
STORE
{
write
!
(
self
.
out
"
writeonly
"
)
?
;
}
write
!
(
self
.
out
"
uniform
"
)
?
;
self
.
write_image_type
(
dim
arrayed
class
)
?
;
let
global_name
=
self
.
get_global_name
(
handle
global
)
;
writeln
!
(
self
.
out
"
{
}
;
"
global_name
)
?
;
writeln
!
(
self
.
out
)
?
;
self
.
reflection_names
.
insert
(
global
.
ty
global_name
)
;
}
TypeInner
:
:
Sampler
{
.
.
}
=
>
continue
_
=
>
self
.
write_global
(
handle
global
)
?
}
}
for
arg
in
self
.
entry_point
.
function
.
arguments
.
iter
(
)
{
self
.
write_varying
(
arg
.
binding
.
as_ref
(
)
arg
.
ty
false
)
?
;
}
if
let
Some
(
ref
result
)
=
self
.
entry_point
.
function
.
result
{
self
.
write_varying
(
result
.
binding
.
as_ref
(
)
result
.
ty
true
)
?
;
}
writeln
!
(
self
.
out
)
?
;
for
(
handle
function
)
in
self
.
module
.
functions
.
iter
(
)
{
if
!
ep_info
.
dominates_global_use
(
&
self
.
info
[
handle
]
)
{
continue
;
}
let
name
=
self
.
names
[
&
NameKey
:
:
Function
(
handle
)
]
.
clone
(
)
;
let
fun_info
=
&
self
.
info
[
handle
]
;
self
.
write_function
(
FunctionType
:
:
Function
(
handle
)
function
fun_info
&
name
)
?
;
writeln
!
(
self
.
out
)
?
;
}
self
.
write_function
(
FunctionType
:
:
EntryPoint
(
self
.
entry_point_idx
)
&
self
.
entry_point
.
function
ep_info
"
main
"
)
?
;
writeln
!
(
self
.
out
)
?
;
self
.
collect_reflection_info
(
)
}
fn
write_value_type
(
&
mut
self
inner
:
&
TypeInner
)
-
>
BackendResult
{
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
width
}
|
TypeInner
:
:
ValuePointer
{
size
:
None
kind
width
class
:
_
}
=
>
write
!
(
self
.
out
"
{
}
"
glsl_scalar
(
kind
width
)
?
.
full
)
?
TypeInner
:
:
Vector
{
size
kind
width
}
|
TypeInner
:
:
ValuePointer
{
size
:
Some
(
size
)
kind
width
class
:
_
}
=
>
write
!
(
self
.
out
"
{
}
vec
{
}
"
glsl_scalar
(
kind
width
)
?
.
prefix
size
as
u8
)
?
TypeInner
:
:
Matrix
{
columns
rows
width
}
=
>
write
!
(
self
.
out
"
{
}
mat
{
}
x
{
}
"
glsl_scalar
(
ScalarKind
:
:
Float
width
)
?
.
prefix
columns
as
u8
rows
as
u8
)
?
TypeInner
:
:
Array
{
base
:
_
size
.
.
}
=
>
{
write
!
(
self
.
out
"
[
"
)
?
;
match
size
{
ArraySize
:
:
Constant
(
const_handle
)
=
>
{
match
self
.
module
.
constants
[
const_handle
]
.
inner
{
ConstantInner
:
:
Scalar
{
width
:
_
value
:
ScalarValue
:
:
Uint
(
size
)
}
=
>
write
!
(
self
.
out
"
{
}
"
size
)
?
_
=
>
unreachable
!
(
)
}
}
ArraySize
:
:
Dynamic
=
>
(
)
}
write
!
(
self
.
out
"
]
"
)
?
}
TypeInner
:
:
Pointer
{
.
.
}
|
TypeInner
:
:
Struct
{
.
.
}
|
TypeInner
:
:
Image
{
.
.
}
|
TypeInner
:
:
Sampler
{
.
.
}
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_type
(
&
mut
self
ty
:
Handle
<
Type
>
)
-
>
BackendResult
{
match
self
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
self
.
write_type
(
base
)
TypeInner
:
:
Struct
{
block
:
true
ref
members
}
=
>
self
.
write_struct
(
true
ty
members
)
TypeInner
:
:
Struct
{
block
:
false
.
.
}
=
>
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
Ok
(
(
)
)
}
ref
other
=
>
self
.
write_value_type
(
other
)
}
}
fn
write_image_type
(
&
mut
self
dim
:
crate
:
:
ImageDimension
arrayed
:
bool
class
:
ImageClass
)
-
>
BackendResult
{
let
(
base
kind
ms
comparison
)
=
match
class
{
ImageClass
:
:
Sampled
{
kind
multi
:
true
}
=
>
(
"
sampler
"
kind
"
MS
"
"
"
)
ImageClass
:
:
Sampled
{
kind
multi
:
false
}
=
>
(
"
sampler
"
kind
"
"
"
"
)
ImageClass
:
:
Depth
=
>
(
"
sampler
"
crate
:
:
ScalarKind
:
:
Float
"
"
"
Shadow
"
)
ImageClass
:
:
Storage
(
format
)
=
>
(
"
image
"
format
.
into
(
)
"
"
"
"
)
}
;
write
!
(
self
.
out
"
highp
{
}
{
}
{
}
{
}
{
}
{
}
"
glsl_scalar
(
kind
4
)
?
.
prefix
base
glsl_dimension
(
dim
)
ms
if
arrayed
{
"
Array
"
}
else
{
"
"
}
comparison
)
?
;
Ok
(
(
)
)
}
fn
write_global
(
&
mut
self
handle
:
Handle
<
GlobalVariable
>
global
:
&
GlobalVariable
)
-
>
BackendResult
{
if
global
.
storage_access
=
=
StorageAccess
:
:
LOAD
{
write
!
(
self
.
out
"
readonly
"
)
?
;
}
else
if
global
.
storage_access
=
=
StorageAccess
:
:
STORE
{
write
!
(
self
.
out
"
writeonly
"
)
?
;
}
write
!
(
self
.
out
"
{
}
"
glsl_storage_class
(
global
.
class
)
)
?
;
self
.
write_type
(
global
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
self
.
get_global_name
(
handle
global
)
)
?
;
writeln
!
(
self
.
out
)
?
;
Ok
(
(
)
)
}
fn
get_global_name
(
&
self
handle
:
Handle
<
GlobalVariable
>
global
:
&
GlobalVariable
)
-
>
String
{
match
global
.
binding
{
Some
(
ref
br
)
=
>
{
format
!
(
"
_group_
{
}
_binding_
{
}
"
br
.
group
br
.
binding
)
}
None
=
>
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
.
clone
(
)
}
}
fn
write_varying
(
&
mut
self
binding
:
Option
<
&
Binding
>
ty
:
Handle
<
Type
>
output
:
bool
)
-
>
Result
<
(
)
Error
>
{
match
self
.
module
.
types
[
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
block
:
_
ref
members
}
=
>
{
for
member
in
members
{
self
.
write_varying
(
member
.
binding
.
as_ref
(
)
member
.
ty
output
)
?
;
}
}
_
=
>
{
let
(
location
interpolation
)
=
match
binding
{
Some
(
&
Binding
:
:
Location
(
location
interpolation
)
)
=
>
(
location
interpolation
)
_
=
>
return
Ok
(
(
)
)
}
;
if
let
Some
(
interp
)
=
interpolation
{
if
self
.
options
.
shader_stage
=
=
ShaderStage
:
:
Fragment
{
write
!
(
self
.
out
"
{
}
"
glsl_interpolation
(
interp
)
)
?
;
}
}
if
self
.
options
.
version
.
supports_explicit_locations
(
)
{
write
!
(
self
.
out
"
layout
(
location
=
{
}
)
{
}
"
location
if
output
{
"
out
"
}
else
{
"
in
"
}
)
?
;
}
else
{
write
!
(
self
.
out
"
{
}
"
if
output
{
"
out
"
}
else
{
"
in
"
}
)
?
;
}
self
.
write_type
(
ty
)
?
;
let
vname
=
VaryingName
{
binding
:
&
Binding
:
:
Location
(
location
None
)
stage
:
self
.
entry_point
.
stage
output
}
;
writeln
!
(
self
.
out
"
{
}
;
"
vname
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_function
(
&
mut
self
ty
:
FunctionType
func
:
&
Function
info
:
&
FunctionInfo
name
:
&
str
)
-
>
BackendResult
{
let
ctx
=
FunctionCtx
{
func
:
ty
info
expressions
:
&
func
.
expressions
}
;
self
.
cached_expressions
.
clear
(
)
;
if
let
FunctionType
:
:
EntryPoint
(
_
)
=
ctx
.
func
{
write
!
(
self
.
out
"
void
"
)
?
;
}
else
if
let
Some
(
ref
result
)
=
func
.
result
{
self
.
write_type
(
result
.
ty
)
?
;
}
else
{
write
!
(
self
.
out
"
void
"
)
?
;
}
write
!
(
self
.
out
"
{
}
(
"
name
)
?
;
let
arguments
=
match
ctx
.
func
{
FunctionType
:
:
EntryPoint
(
_
)
=
>
&
[
]
[
.
.
]
FunctionType
:
:
Function
(
_
)
=
>
&
func
.
arguments
}
;
self
.
write_slice
(
arguments
|
this
i
arg
|
{
this
.
write_type
(
arg
.
ty
)
?
;
write
!
(
this
.
out
"
{
}
"
&
this
.
names
[
&
ctx
.
argument_key
(
i
)
]
)
?
;
Ok
(
(
)
)
}
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
if
let
FunctionType
:
:
EntryPoint
(
ep_index
)
=
ctx
.
func
{
let
stage
=
self
.
module
.
entry_points
[
ep_index
as
usize
]
.
stage
;
for
(
index
arg
)
in
func
.
arguments
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
INDENT
)
?
;
self
.
write_type
(
arg
.
ty
)
?
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
EntryPointArgument
(
ep_index
index
as
u32
)
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
match
self
.
module
.
types
[
arg
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
block
:
_
ref
members
}
=
>
{
self
.
write_type
(
arg
.
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
let
varying_name
=
VaryingName
{
binding
:
member
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
output
:
false
}
;
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
write
!
(
self
.
out
"
{
}
"
varying_name
)
?
;
}
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
_
=
>
{
let
varying_name
=
VaryingName
{
binding
:
arg
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
output
:
false
}
;
writeln
!
(
self
.
out
"
{
}
;
"
varying_name
)
?
;
}
}
}
}
for
(
handle
local
)
in
func
.
local_variables
.
iter
(
)
{
write
!
(
self
.
out
"
{
}
"
INDENT
)
?
;
self
.
write_type
(
local
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
;
if
let
Some
(
init
)
=
local
.
init
{
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_constant
(
&
self
.
module
.
constants
[
init
]
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
}
for
sta
in
func
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
&
ctx
1
)
?
;
}
writeln
!
(
self
.
out
"
}
}
"
)
?
;
Ok
(
(
)
)
}
fn
write_slice
<
T
F
:
FnMut
(
&
mut
Self
u32
&
T
)
-
>
BackendResult
>
(
&
mut
self
data
:
&
[
T
]
mut
f
:
F
)
-
>
BackendResult
{
for
(
i
item
)
in
data
.
iter
(
)
.
enumerate
(
)
{
f
(
self
i
as
u32
item
)
?
;
if
i
!
=
data
.
len
(
)
.
saturating_sub
(
1
)
{
write
!
(
self
.
out
"
"
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_constant
(
&
mut
self
constant
:
&
Constant
)
-
>
BackendResult
{
match
constant
.
inner
{
ConstantInner
:
:
Scalar
{
width
:
_
ref
value
}
=
>
match
*
value
{
ScalarValue
:
:
Sint
(
int
)
=
>
write
!
(
self
.
out
"
{
}
"
int
)
?
ScalarValue
:
:
Uint
(
int
)
=
>
write
!
(
self
.
out
"
{
}
u
"
int
)
?
ScalarValue
:
:
Float
(
float
)
=
>
write
!
(
self
.
out
"
{
:
?
}
"
float
)
?
ScalarValue
:
:
Bool
(
boolean
)
=
>
write
!
(
self
.
out
"
{
}
"
boolean
)
?
}
ConstantInner
:
:
Composite
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_slice
(
components
|
this
_
arg
|
{
this
.
write_constant
(
&
this
.
module
.
constants
[
*
arg
]
)
}
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_struct
(
&
mut
self
block
:
bool
handle
:
Handle
<
Type
>
members
:
&
[
StructMember
]
)
-
>
BackendResult
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
handle
)
]
;
if
block
{
let
block_name
=
format
!
(
"
{
}
_block_
{
}
"
name
self
.
block_id
.
generate
(
)
)
;
writeln
!
(
self
.
out
"
{
}
{
{
"
block_name
)
?
;
self
.
reflection_names
.
insert
(
handle
block_name
)
;
}
else
{
writeln
!
(
self
.
out
"
struct
{
}
{
{
"
name
)
?
;
}
for
(
idx
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
INDENT
)
?
;
match
self
.
module
.
types
[
member
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
.
.
}
=
>
{
let
ty_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
base
)
]
;
write
!
(
self
.
out
"
{
}
"
ty_name
)
?
;
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
self
.
write_type
(
member
.
ty
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
_
=
>
{
self
.
write_type
(
member
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
}
}
}
write
!
(
self
.
out
"
}
}
"
)
?
;
if
!
block
{
writeln
!
(
self
.
out
"
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
Ok
(
(
)
)
}
fn
write_stmt
(
&
mut
self
sta
:
&
Statement
ctx
:
&
FunctionCtx
<
'
_
>
indent
:
usize
)
-
>
BackendResult
{
match
*
sta
{
Statement
:
:
Emit
(
ref
range
)
=
>
{
for
handle
in
range
.
clone
(
)
{
let
min_ref_count
=
ctx
.
expressions
[
handle
]
.
bake_ref_count
(
)
;
if
min_ref_count
<
=
ctx
.
info
[
handle
]
.
ref_count
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
match
ctx
.
info
[
handle
]
.
ty
{
TypeResolution
:
:
Handle
(
ty_handle
)
=
>
{
match
self
.
module
.
types
[
ty_handle
]
.
inner
{
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty_handle
)
]
;
write
!
(
self
.
out
"
{
}
"
ty_name
)
?
;
}
_
=
>
{
self
.
write_type
(
ty_handle
)
?
;
}
}
}
TypeResolution
:
:
Value
(
ref
inner
)
=
>
{
self
.
write_value_type
(
inner
)
?
;
}
}
let
name
=
format
!
(
"
_expr
{
}
"
handle
.
index
(
)
)
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
write_expr
(
handle
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
self
.
cached_expressions
.
insert
(
handle
name
)
;
}
}
}
Statement
:
:
Block
(
ref
block
)
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
sta
in
block
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
If
{
condition
ref
accept
ref
reject
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
write
!
(
self
.
out
"
if
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
sta
in
accept
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
;
}
if
!
reject
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
}
}
else
{
{
"
INDENT
.
repeat
(
indent
)
)
?
;
for
sta
in
reject
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
Switch
{
selector
ref
cases
ref
default
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
write
!
(
self
.
out
"
switch
(
"
)
?
;
self
.
write_expr
(
selector
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
case
in
cases
{
writeln
!
(
self
.
out
"
{
}
case
{
}
:
"
INDENT
.
repeat
(
indent
+
1
)
case
.
value
)
?
;
for
sta
in
case
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
indent
+
2
)
?
;
}
if
case
.
fall_through
{
writeln
!
(
self
.
out
"
{
}
break
;
"
INDENT
.
repeat
(
indent
+
2
)
)
?
;
}
}
if
!
default
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
default
:
"
INDENT
.
repeat
(
indent
+
1
)
)
?
;
for
sta
in
default
{
self
.
write_stmt
(
sta
ctx
indent
+
2
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
Loop
{
ref
body
ref
continuing
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
writeln
!
(
self
.
out
"
while
(
true
)
{
{
"
)
?
;
for
sta
in
body
.
iter
(
)
.
chain
(
continuing
.
iter
(
)
)
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
Break
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
writeln
!
(
self
.
out
"
break
;
"
)
?
}
Statement
:
:
Continue
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
writeln
!
(
self
.
out
"
continue
;
"
)
?
}
Statement
:
:
Return
{
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
match
ctx
.
func
{
FunctionType
:
:
Function
(
_
)
=
>
{
write
!
(
self
.
out
"
return
"
)
?
;
if
let
Some
(
expr
)
=
value
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
;
}
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
{
let
ep
=
&
self
.
module
.
entry_points
[
ep_index
as
usize
]
;
if
let
Some
(
ref
result
)
=
ep
.
function
.
result
{
let
value
=
value
.
unwrap
(
)
;
match
self
.
module
.
types
[
result
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
block
:
_
ref
members
}
=
>
{
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
let
varying_name
=
VaryingName
{
binding
:
member
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
:
ep
.
stage
output
:
true
}
;
write
!
(
self
.
out
"
{
}
=
"
varying_name
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
let
field_name
=
&
self
.
names
[
&
NameKey
:
:
StructMember
(
result
.
ty
index
as
u32
)
]
;
writeln
!
(
self
.
out
"
.
{
}
;
"
field_name
)
?
;
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
}
}
_
=
>
{
let
name
=
VaryingName
{
binding
:
result
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
:
ep
.
stage
output
:
true
}
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
}
}
}
writeln
!
(
self
.
out
"
return
;
"
)
?
;
}
}
}
Statement
:
:
Kill
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
writeln
!
(
self
.
out
"
discard
;
"
)
?
}
Statement
:
:
Store
{
pointer
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
self
.
write_expr
(
pointer
ctx
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
}
Statement
:
:
ImageStore
{
image
coordinate
array_index
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
let
dim
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
.
.
}
=
>
dim
_
=
>
unreachable
!
(
)
}
;
write
!
(
self
.
out
"
imageStore
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
coordinate
array_index
dim
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
Statement
:
:
Call
{
function
ref
arguments
result
}
=
>
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
if
let
Some
(
expr
)
=
result
{
let
name
=
format
!
(
"
_expr
{
}
"
expr
.
index
(
)
)
;
let
result
=
self
.
module
.
functions
[
function
]
.
result
.
as_ref
(
)
.
unwrap
(
)
;
self
.
write_type
(
result
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
cached_expressions
.
insert
(
expr
name
)
;
}
write
!
(
self
.
out
"
{
}
(
"
&
self
.
names
[
&
NameKey
:
:
Function
(
function
)
]
)
?
;
self
.
write_slice
(
arguments
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_expr
(
&
mut
self
expr
:
Handle
<
Expression
>
ctx
:
&
FunctionCtx
<
'
_
>
)
-
>
BackendResult
{
if
let
Some
(
name
)
=
self
.
cached_expressions
.
get
(
&
expr
)
{
write
!
(
self
.
out
"
{
}
"
name
)
?
;
return
Ok
(
(
)
)
;
}
match
ctx
.
expressions
[
expr
]
{
Expression
:
:
Access
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
self
.
write_expr
(
index
ctx
)
?
;
write
!
(
self
.
out
"
]
"
)
?
}
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
let
base_ty_res
=
&
ctx
.
info
[
base
]
.
ty
;
let
mut
resolved
=
base_ty_res
.
inner_with
(
&
self
.
module
.
types
)
;
let
base_ty_handle
=
match
*
resolved
{
TypeInner
:
:
Pointer
{
base
class
:
_
}
=
>
{
resolved
=
&
self
.
module
.
types
[
base
]
.
inner
;
Some
(
base
)
}
_
=
>
base_ty_res
.
handle
(
)
}
;
match
*
resolved
{
TypeInner
:
:
Vector
{
.
.
}
|
TypeInner
:
:
Matrix
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
|
TypeInner
:
:
ValuePointer
{
.
.
}
=
>
write
!
(
self
.
out
"
[
{
}
]
"
index
)
?
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty
=
base_ty_handle
.
unwrap
(
)
;
write
!
(
self
.
out
"
.
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
index
)
]
)
?
}
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
index
{
:
?
}
"
other
)
)
)
}
}
Expression
:
:
Constant
(
constant
)
=
>
{
self
.
write_constant
(
&
self
.
module
.
constants
[
constant
]
)
?
}
Expression
:
:
Compose
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_slice
(
components
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
FunctionArgument
(
pos
)
=
>
{
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
ctx
.
argument_key
(
pos
)
]
)
?
}
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
global
=
&
self
.
module
.
global_variables
[
handle
]
;
write
!
(
self
.
out
"
{
}
"
self
.
get_global_name
(
handle
global
)
)
?
}
Expression
:
:
LocalVariable
(
handle
)
=
>
{
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
}
Expression
:
:
Load
{
pointer
}
=
>
self
.
write_expr
(
pointer
ctx
)
?
Expression
:
:
ImageSample
{
image
sampler
:
_
coordinate
array_index
offset
:
_
level
depth_ref
}
=
>
{
let
workaround_lod_array_shadow_as_grad
=
array_index
.
is_some
(
)
&
&
depth_ref
.
is_some
(
)
;
let
fun_name
=
match
level
{
crate
:
:
SampleLevel
:
:
Auto
|
crate
:
:
SampleLevel
:
:
Bias
(
_
)
=
>
"
texture
"
crate
:
:
SampleLevel
:
:
Zero
|
crate
:
:
SampleLevel
:
:
Exact
(
_
)
=
>
{
if
workaround_lod_array_shadow_as_grad
{
"
textureGrad
"
}
else
{
"
textureLod
"
}
}
crate
:
:
SampleLevel
:
:
Gradient
{
.
.
}
=
>
"
textureGrad
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
let
size
=
match
*
ctx
.
info
[
coordinate
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
size
_
=
>
unreachable
!
(
)
}
;
let
mut
coord_dim
=
size
as
u8
;
if
array_index
.
is_some
(
)
{
coord_dim
+
=
1
;
}
if
depth_ref
.
is_some
(
)
{
coord_dim
+
=
1
;
}
write
!
(
self
.
out
"
vec
{
}
(
"
coord_dim
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
if
let
Some
(
expr
)
=
array_index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
if
let
Some
(
expr
)
=
depth_ref
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
match
level
{
crate
:
:
SampleLevel
:
:
Auto
=
>
(
)
crate
:
:
SampleLevel
:
:
Zero
=
>
{
if
workaround_lod_array_shadow_as_grad
{
write
!
(
self
.
out
"
vec2
(
0
0
)
vec2
(
0
0
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
0
"
)
?
;
}
}
crate
:
:
SampleLevel
:
:
Exact
(
expr
)
=
>
{
if
workaround_lod_array_shadow_as_grad
{
write
!
(
self
.
out
"
vec2
(
0
0
)
vec2
(
0
0
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
}
crate
:
:
SampleLevel
:
:
Bias
(
expr
)
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
crate
:
:
SampleLevel
:
:
Gradient
{
x
y
}
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
x
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
y
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
ImageLoad
{
image
coordinate
array_index
index
}
=
>
{
let
(
dim
class
)
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
=
>
"
texelFetch
"
ImageClass
:
:
Storage
(
_
)
=
>
"
imageLoad
"
ImageClass
:
:
Depth
=
>
todo
!
(
)
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
coordinate
array_index
dim
ctx
)
?
;
if
let
Some
(
index_expr
)
=
index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
index_expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
ImageQuery
{
image
query
}
=
>
{
let
(
dim
class
)
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
components
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
1
crate
:
:
ImageDimension
:
:
D2
=
>
2
crate
:
:
ImageDimension
:
:
D3
=
>
3
crate
:
:
ImageDimension
:
:
Cube
=
>
2
}
;
match
query
{
crate
:
:
ImageQuery
:
:
Size
{
level
}
=
>
{
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
=
>
{
write
!
(
self
.
out
"
textureSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
if
let
Some
(
expr
)
=
level
{
self
.
write_expr
(
expr
ctx
)
?
;
}
else
{
write
!
(
self
.
out
"
0
"
)
?
;
}
}
ImageClass
:
:
Storage
(
_
)
=
>
{
write
!
(
self
.
out
"
imageSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
.
{
}
"
&
"
xyz
"
[
.
.
components
]
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLevels
=
>
{
write
!
(
self
.
out
"
textureQueryLevels
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLayers
=
>
{
let
selector
=
[
'
x
'
'
y
'
'
z
'
'
w
'
]
;
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
=
>
"
textureSize
"
ImageClass
:
:
Storage
(
_
)
=
>
"
imageSize
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
0
)
.
{
}
"
selector
[
components
]
)
?
;
}
crate
:
:
ImageQuery
:
:
NumSamples
=
>
{
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
=
>
"
textureSamples
"
ImageClass
:
:
Storage
(
_
)
=
>
"
imageSamples
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
}
return
Err
(
Error
:
:
Custom
(
"
ImageQuery
not
implemented
"
.
to_string
(
)
)
)
;
}
Expression
:
:
Unary
{
op
expr
}
=
>
{
write
!
(
self
.
out
"
(
{
}
"
match
op
{
UnaryOperator
:
:
Negate
=
>
"
-
"
UnaryOperator
:
:
Not
=
>
match
*
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Sint
.
.
}
=
>
"
~
"
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Uint
.
.
}
=
>
"
~
"
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Bool
.
.
}
=
>
"
!
"
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
apply
not
to
type
{
:
?
}
"
other
)
)
)
}
}
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Binary
{
op
left
right
}
=
>
{
let
function
=
if
let
(
&
TypeInner
:
:
Vector
{
.
.
}
&
TypeInner
:
:
Vector
{
.
.
}
)
=
(
ctx
.
info
[
left
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
ctx
.
info
[
right
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
)
{
match
op
{
BinaryOperator
:
:
Less
=
>
Some
(
"
lessThan
"
)
BinaryOperator
:
:
LessEqual
=
>
Some
(
"
lessThanEqual
"
)
BinaryOperator
:
:
Greater
=
>
Some
(
"
greaterThan
"
)
BinaryOperator
:
:
GreaterEqual
=
>
Some
(
"
greaterThanEqual
"
)
BinaryOperator
:
:
Equal
=
>
Some
(
"
equal
"
)
BinaryOperator
:
:
NotEqual
=
>
Some
(
"
notEqual
"
)
_
=
>
None
}
}
else
{
None
}
;
write
!
(
self
.
out
"
{
}
(
"
function
.
unwrap_or
(
"
"
)
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
if
function
.
is_some
(
)
{
write
!
(
self
.
out
"
"
)
?
}
else
{
write
!
(
self
.
out
"
{
}
"
match
op
{
BinaryOperator
:
:
Add
=
>
"
+
"
BinaryOperator
:
:
Subtract
=
>
"
-
"
BinaryOperator
:
:
Multiply
=
>
"
*
"
BinaryOperator
:
:
Divide
=
>
"
/
"
BinaryOperator
:
:
Modulo
=
>
"
%
"
BinaryOperator
:
:
Equal
=
>
"
=
=
"
BinaryOperator
:
:
NotEqual
=
>
"
!
=
"
BinaryOperator
:
:
Less
=
>
"
<
"
BinaryOperator
:
:
LessEqual
=
>
"
<
=
"
BinaryOperator
:
:
Greater
=
>
"
>
"
BinaryOperator
:
:
GreaterEqual
=
>
"
>
=
"
BinaryOperator
:
:
And
=
>
"
&
"
BinaryOperator
:
:
ExclusiveOr
=
>
"
^
"
BinaryOperator
:
:
InclusiveOr
=
>
"
|
"
BinaryOperator
:
:
LogicalAnd
=
>
"
&
&
"
BinaryOperator
:
:
LogicalOr
=
>
"
|
|
"
BinaryOperator
:
:
ShiftLeft
=
>
"
<
<
"
BinaryOperator
:
:
ShiftRight
=
>
"
>
>
"
}
)
?
;
}
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Select
{
condition
accept
reject
}
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
write
!
(
self
.
out
"
?
"
)
?
;
self
.
write_expr
(
accept
ctx
)
?
;
write
!
(
self
.
out
"
:
"
)
?
;
self
.
write_expr
(
reject
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Derivative
{
axis
expr
}
=
>
{
write
!
(
self
.
out
"
{
}
(
"
match
axis
{
DerivativeAxis
:
:
X
=
>
"
dFdx
"
DerivativeAxis
:
:
Y
=
>
"
dFdy
"
DerivativeAxis
:
:
Width
=
>
"
fwidth
"
}
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Relational
{
fun
argument
}
=
>
{
let
fun_name
=
match
fun
{
RelationalFunction
:
:
IsFinite
=
>
"
!
isinf
"
RelationalFunction
:
:
IsInf
=
>
"
isinf
"
RelationalFunction
:
:
IsNan
=
>
"
isnan
"
RelationalFunction
:
:
IsNormal
=
>
"
!
isnan
"
RelationalFunction
:
:
All
=
>
"
all
"
RelationalFunction
:
:
Any
=
>
"
any
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
argument
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Math
{
fun
arg
arg1
arg2
}
=
>
{
use
crate
:
:
MathFunction
as
Mf
;
let
fun_name
=
match
fun
{
Mf
:
:
Abs
=
>
"
abs
"
Mf
:
:
Min
=
>
"
min
"
Mf
:
:
Max
=
>
"
max
"
Mf
:
:
Clamp
=
>
"
clamp
"
Mf
:
:
Cos
=
>
"
cos
"
Mf
:
:
Cosh
=
>
"
cosh
"
Mf
:
:
Sin
=
>
"
sin
"
Mf
:
:
Sinh
=
>
"
sinh
"
Mf
:
:
Tan
=
>
"
tan
"
Mf
:
:
Tanh
=
>
"
tanh
"
Mf
:
:
Acos
=
>
"
acos
"
Mf
:
:
Asin
=
>
"
asin
"
Mf
:
:
Atan
=
>
"
atan
"
Mf
:
:
Atan2
=
>
"
atan
"
Mf
:
:
Ceil
=
>
"
ceil
"
Mf
:
:
Floor
=
>
"
floor
"
Mf
:
:
Round
=
>
"
round
"
Mf
:
:
Fract
=
>
"
fract
"
Mf
:
:
Trunc
=
>
"
trunc
"
Mf
:
:
Modf
=
>
"
modf
"
Mf
:
:
Frexp
=
>
"
frexp
"
Mf
:
:
Ldexp
=
>
"
ldexp
"
Mf
:
:
Exp
=
>
"
exp
"
Mf
:
:
Exp2
=
>
"
exp2
"
Mf
:
:
Log
=
>
"
log
"
Mf
:
:
Log2
=
>
"
log2
"
Mf
:
:
Pow
=
>
"
pow
"
Mf
:
:
Dot
=
>
"
dot
"
Mf
:
:
Outer
=
>
"
outerProduct
"
Mf
:
:
Cross
=
>
"
cross
"
Mf
:
:
Distance
=
>
"
distance
"
Mf
:
:
Length
=
>
"
length
"
Mf
:
:
Normalize
=
>
"
normalize
"
Mf
:
:
FaceForward
=
>
"
faceforward
"
Mf
:
:
Reflect
=
>
"
reflect
"
Mf
:
:
Sign
=
>
"
sign
"
Mf
:
:
Fma
=
>
"
fma
"
Mf
:
:
Mix
=
>
"
mix
"
Mf
:
:
Step
=
>
"
step
"
Mf
:
:
SmoothStep
=
>
"
smoothstep
"
Mf
:
:
Sqrt
=
>
"
sqrt
"
Mf
:
:
InverseSqrt
=
>
"
inversesqrt
"
Mf
:
:
Inverse
=
>
"
inverse
"
Mf
:
:
Transpose
=
>
"
transpose
"
Mf
:
:
Determinant
=
>
"
determinant
"
Mf
:
:
CountOneBits
=
>
"
bitCount
"
Mf
:
:
ReverseBits
=
>
"
bitfieldReverse
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
if
let
Some
(
arg
)
=
arg1
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
}
if
let
Some
(
arg
)
=
arg2
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
As
{
expr
kind
:
target_kind
convert
}
=
>
{
let
inner
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
if
convert
{
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
:
_
width
}
=
>
{
write
!
(
self
.
out
"
{
}
"
glsl_scalar
(
target_kind
width
)
?
.
full
)
?
}
TypeInner
:
:
Vector
{
size
kind
:
_
width
}
=
>
write
!
(
self
.
out
"
{
}
vec
{
}
"
glsl_scalar
(
target_kind
width
)
?
.
prefix
size
as
u8
)
?
ref
other
=
>
unreachable
!
(
"
unexpected
cast
of
{
:
?
}
"
other
)
}
}
else
{
let
source_kind
=
inner
.
scalar_kind
(
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
{
}
"
match
(
source_kind
target_kind
)
{
(
ScalarKind
:
:
Float
ScalarKind
:
:
Sint
)
=
>
"
floatBitsToInt
"
(
ScalarKind
:
:
Float
ScalarKind
:
:
Uint
)
=
>
"
floatBitsToUInt
"
(
ScalarKind
:
:
Sint
ScalarKind
:
:
Float
)
=
>
"
intBitsToFloat
"
(
ScalarKind
:
:
Uint
ScalarKind
:
:
Float
)
=
>
"
uintBitsToFloat
"
/
/
There
is
no
way
to
bitcast
between
Uint
/
Sint
in
glsl
.
Use
constructor
conversion
(
ScalarKind
:
:
Uint
ScalarKind
:
:
Sint
)
=
>
"
int
"
(
ScalarKind
:
:
Sint
ScalarKind
:
:
Uint
)
=
>
"
uint
"
_
=
>
{
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
bitcast
{
:
?
}
to
{
:
?
}
"
source_kind
target_kind
)
)
)
;
}
}
)
?
;
}
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Call
(
_function
)
=
>
unreachable
!
(
)
Expression
:
:
ArrayLength
(
expr
)
=
>
{
write
!
(
self
.
out
"
uint
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
.
length
(
)
)
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_texture_coordinates
(
&
mut
self
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
dim
:
crate
:
:
ImageDimension
ctx
:
&
FunctionCtx
)
-
>
Result
<
(
)
Error
>
{
match
array_index
{
Some
(
layer_expr
)
=
>
{
let
tex_coord_type
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
"
ivec2
"
crate
:
:
ImageDimension
:
:
D2
=
>
"
ivec3
"
crate
:
:
ImageDimension
:
:
D3
=
>
"
ivec4
"
crate
:
:
ImageDimension
:
:
Cube
=
>
"
ivec4
"
}
;
write
!
(
self
.
out
"
{
}
(
"
tex_coord_type
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
layer_expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
None
=
>
{
self
.
write_expr
(
coordinate
ctx
)
?
;
}
}
Ok
(
(
)
)
}
fn
collect_reflection_info
(
&
self
)
-
>
Result
<
ReflectionInfo
Error
>
{
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
let
info
=
self
.
info
.
get_entry_point
(
self
.
entry_point_idx
as
usize
)
;
let
mut
mappings
=
FastHashMap
:
:
default
(
)
;
let
mut
uniforms
=
FastHashMap
:
:
default
(
)
;
for
sampling
in
info
.
sampling_set
.
iter
(
)
{
let
global
=
self
.
module
.
global_variables
[
sampling
.
image
]
.
clone
(
)
;
let
tex_name
=
self
.
reflection_names
[
&
global
.
ty
]
.
clone
(
)
;
match
mappings
.
entry
(
tex_name
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
v
.
insert
(
TextureMapping
{
texture
:
sampling
.
image
sampler
:
Some
(
sampling
.
sampler
)
}
)
;
}
Entry
:
:
Occupied
(
e
)
=
>
{
if
e
.
get
(
)
.
sampler
!
=
Some
(
sampling
.
sampler
)
{
log
:
:
error
!
(
"
Conflicting
samplers
for
{
}
"
e
.
key
(
)
)
;
return
Err
(
Error
:
:
ImageMultipleSamplers
)
;
}
}
}
}
for
(
handle
var
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
info
[
handle
]
.
is_empty
(
)
{
continue
;
}
match
self
.
module
.
types
[
var
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
.
.
}
=
>
match
var
.
class
{
StorageClass
:
:
Uniform
|
StorageClass
:
:
Storage
=
>
{
let
name
=
self
.
reflection_names
[
&
var
.
ty
]
.
clone
(
)
;
uniforms
.
insert
(
handle
name
)
;
}
_
=
>
(
)
}
_
=
>
continue
}
}
Ok
(
ReflectionInfo
{
texture_mapping
:
mappings
uniforms
}
)
}
}
struct
ScalarString
<
'
a
>
{
prefix
:
&
'
a
str
full
:
&
'
a
str
}
fn
glsl_scalar
(
kind
:
ScalarKind
width
:
Bytes
)
-
>
Result
<
ScalarString
<
'
static
>
Error
>
{
Ok
(
match
kind
{
ScalarKind
:
:
Sint
=
>
ScalarString
{
prefix
:
"
i
"
full
:
"
int
"
}
ScalarKind
:
:
Uint
=
>
ScalarString
{
prefix
:
"
u
"
full
:
"
uint
"
}
ScalarKind
:
:
Float
=
>
match
width
{
4
=
>
ScalarString
{
prefix
:
"
"
full
:
"
float
"
}
8
=
>
ScalarString
{
prefix
:
"
d
"
full
:
"
double
"
}
_
=
>
return
Err
(
Error
:
:
UnsupportedScalar
(
kind
width
)
)
}
ScalarKind
:
:
Bool
=
>
ScalarString
{
prefix
:
"
b
"
full
:
"
bool
"
}
}
)
}
fn
glsl_built_in
(
built_in
:
BuiltIn
output
:
bool
)
-
>
&
'
static
str
{
match
built_in
{
BuiltIn
:
:
Position
=
>
{
if
output
{
"
gl_Position
"
}
else
{
"
gl_FragCoord
"
}
}
BuiltIn
:
:
BaseInstance
=
>
"
uint
(
gl_BaseInstance
)
"
BuiltIn
:
:
BaseVertex
=
>
"
uint
(
gl_BaseVertex
)
"
BuiltIn
:
:
ClipDistance
=
>
"
gl_ClipDistance
"
BuiltIn
:
:
InstanceIndex
=
>
"
uint
(
gl_InstanceID
)
"
BuiltIn
:
:
PointSize
=
>
"
gl_PointSize
"
BuiltIn
:
:
VertexIndex
=
>
"
uint
(
gl_VertexID
)
"
BuiltIn
:
:
FragDepth
=
>
"
gl_FragDepth
"
BuiltIn
:
:
FrontFacing
=
>
"
gl_FrontFacing
"
BuiltIn
:
:
SampleIndex
=
>
"
gl_SampleID
"
BuiltIn
:
:
SampleMask
=
>
{
if
output
{
"
gl_SampleMask
"
}
else
{
"
gl_SampleMaskIn
"
}
}
BuiltIn
:
:
GlobalInvocationId
=
>
"
gl_GlobalInvocationID
"
BuiltIn
:
:
LocalInvocationId
=
>
"
gl_LocalInvocationID
"
BuiltIn
:
:
LocalInvocationIndex
=
>
"
gl_LocalInvocationIndex
"
BuiltIn
:
:
WorkGroupId
=
>
"
gl_WorkGroupID
"
BuiltIn
:
:
WorkGroupSize
=
>
"
gl_WorkGroupSize
"
}
}
fn
glsl_storage_class
(
class
:
StorageClass
)
-
>
&
'
static
str
{
match
class
{
StorageClass
:
:
Function
=
>
"
"
StorageClass
:
:
Private
=
>
"
"
StorageClass
:
:
Storage
=
>
"
buffer
"
StorageClass
:
:
Uniform
=
>
"
uniform
"
StorageClass
:
:
Handle
=
>
"
uniform
"
StorageClass
:
:
WorkGroup
=
>
"
shared
"
StorageClass
:
:
PushConstant
=
>
"
"
}
}
fn
glsl_interpolation
(
interpolation
:
Interpolation
)
-
>
&
'
static
str
{
match
interpolation
{
Interpolation
:
:
Perspective
=
>
"
smooth
"
Interpolation
:
:
Linear
=
>
"
noperspective
"
Interpolation
:
:
Flat
=
>
"
flat
"
Interpolation
:
:
Centroid
=
>
"
centroid
"
Interpolation
:
:
Sample
=
>
"
sample
"
}
}
fn
glsl_dimension
(
dim
:
crate
:
:
ImageDimension
)
-
>
&
'
static
str
{
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
"
1D
"
crate
:
:
ImageDimension
:
:
D2
=
>
"
2D
"
crate
:
:
ImageDimension
:
:
D3
=
>
"
3D
"
crate
:
:
ImageDimension
:
:
Cube
=
>
"
Cube
"
}
}
fn
glsl_storage_format
(
format
:
StorageFormat
)
-
>
&
'
static
str
{
match
format
{
StorageFormat
:
:
R8Unorm
=
>
"
r8
"
StorageFormat
:
:
R8Snorm
=
>
"
r8_snorm
"
StorageFormat
:
:
R8Uint
=
>
"
r8ui
"
StorageFormat
:
:
R8Sint
=
>
"
r8i
"
StorageFormat
:
:
R16Uint
=
>
"
r16ui
"
StorageFormat
:
:
R16Sint
=
>
"
r16i
"
StorageFormat
:
:
R16Float
=
>
"
r16f
"
StorageFormat
:
:
Rg8Unorm
=
>
"
rg8
"
StorageFormat
:
:
Rg8Snorm
=
>
"
rg8_snorm
"
StorageFormat
:
:
Rg8Uint
=
>
"
rg8ui
"
StorageFormat
:
:
Rg8Sint
=
>
"
rg8i
"
StorageFormat
:
:
R32Uint
=
>
"
r32ui
"
StorageFormat
:
:
R32Sint
=
>
"
r32i
"
StorageFormat
:
:
R32Float
=
>
"
r32f
"
StorageFormat
:
:
Rg16Uint
=
>
"
rg16ui
"
StorageFormat
:
:
Rg16Sint
=
>
"
rg16i
"
StorageFormat
:
:
Rg16Float
=
>
"
rg16f
"
StorageFormat
:
:
Rgba8Unorm
=
>
"
rgba8ui
"
StorageFormat
:
:
Rgba8Snorm
=
>
"
rgba8_snorm
"
StorageFormat
:
:
Rgba8Uint
=
>
"
rgba8ui
"
StorageFormat
:
:
Rgba8Sint
=
>
"
rgba8i
"
StorageFormat
:
:
Rgb10a2Unorm
=
>
"
rgb10_a2ui
"
StorageFormat
:
:
Rg11b10Float
=
>
"
r11f_g11f_b10f
"
StorageFormat
:
:
Rg32Uint
=
>
"
rg32ui
"
StorageFormat
:
:
Rg32Sint
=
>
"
rg32i
"
StorageFormat
:
:
Rg32Float
=
>
"
rg32f
"
StorageFormat
:
:
Rgba16Uint
=
>
"
rgba16ui
"
StorageFormat
:
:
Rgba16Sint
=
>
"
rgba16i
"
StorageFormat
:
:
Rgba16Float
=
>
"
rgba16f
"
StorageFormat
:
:
Rgba32Uint
=
>
"
rgba32ui
"
StorageFormat
:
:
Rgba32Sint
=
>
"
rgba32i
"
StorageFormat
:
:
Rgba32Float
=
>
"
rgba32f
"
}
}
