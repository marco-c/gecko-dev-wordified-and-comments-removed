pub
use
features
:
:
Features
;
use
crate
:
:
{
back
proc
:
:
{
self
NameKey
}
valid
Handle
ShaderStage
TypeInner
}
;
use
features
:
:
FeaturesManager
;
use
std
:
:
{
cmp
:
:
Ordering
fmt
fmt
:
:
{
Error
as
FmtError
Write
}
}
;
use
thiserror
:
:
Error
;
mod
features
;
mod
keywords
;
pub
const
SUPPORTED_CORE_VERSIONS
:
&
[
u16
]
=
&
[
330
400
410
420
430
440
450
]
;
pub
const
SUPPORTED_ES_VERSIONS
:
&
[
u16
]
=
&
[
300
310
320
]
;
pub
type
BindingMap
=
std
:
:
collections
:
:
BTreeMap
<
crate
:
:
ResourceBinding
u8
>
;
impl
crate
:
:
AtomicFunction
{
fn
to_glsl
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Add
|
Self
:
:
Subtract
=
>
"
Add
"
Self
:
:
And
=
>
"
And
"
Self
:
:
InclusiveOr
=
>
"
Or
"
Self
:
:
ExclusiveOr
=
>
"
Xor
"
Self
:
:
Min
=
>
"
Min
"
Self
:
:
Max
=
>
"
Max
"
Self
:
:
Exchange
{
compare
:
None
}
=
>
"
Exchange
"
Self
:
:
Exchange
{
compare
:
Some
(
_
)
}
=
>
"
"
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
Version
{
Desktop
(
u16
)
Embedded
(
u16
)
}
impl
Version
{
fn
is_es
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
_
)
=
>
false
Version
:
:
Embedded
(
_
)
=
>
true
}
}
fn
is_supported
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
v
)
=
>
SUPPORTED_CORE_VERSIONS
.
contains
(
&
v
)
Version
:
:
Embedded
(
v
)
=
>
SUPPORTED_ES_VERSIONS
.
contains
(
&
v
)
}
}
fn
supports_explicit_locations
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Embedded
(
310
)
|
|
*
self
>
=
Version
:
:
Desktop
(
410
)
}
fn
supports_early_depth_test
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
130
)
|
|
*
self
>
=
Version
:
:
Embedded
(
310
)
}
}
impl
PartialOrd
for
Version
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
match
(
*
self
*
other
)
{
(
Version
:
:
Desktop
(
x
)
Version
:
:
Desktop
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
(
Version
:
:
Embedded
(
x
)
Version
:
:
Embedded
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
_
=
>
None
}
}
}
impl
fmt
:
:
Display
for
Version
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Version
:
:
Desktop
(
v
)
=
>
write
!
(
f
"
{
}
core
"
v
)
Version
:
:
Embedded
(
v
)
=
>
write
!
(
f
"
{
}
es
"
v
)
}
}
}
bitflags
:
:
bitflags
!
{
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
WriterFlags
:
u32
{
/
/
/
Flip
output
Y
and
extend
Z
from
(
0
1
)
to
(
-
1
1
)
.
const
ADJUST_COORDINATE_SPACE
=
0x1
;
/
/
/
Supports
GL_EXT_texture_shadow_lod
on
the
host
which
provides
/
/
/
additional
functions
on
shadows
and
arrays
of
shadows
.
const
TEXTURE_SHADOW_LOD
=
0x2
;
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
Options
{
pub
version
:
Version
pub
writer_flags
:
WriterFlags
pub
binding_map
:
BindingMap
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
Options
{
version
:
Version
:
:
Embedded
(
310
)
writer_flags
:
WriterFlags
:
:
ADJUST_COORDINATE_SPACE
binding_map
:
BindingMap
:
:
default
(
)
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
PipelineOptions
{
pub
shader_stage
:
ShaderStage
pub
entry_point
:
String
}
pub
struct
ReflectionInfo
{
pub
texture_mapping
:
crate
:
:
FastHashMap
<
String
TextureMapping
>
pub
uniforms
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
GlobalVariable
>
String
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TextureMapping
{
pub
texture
:
Handle
<
crate
:
:
GlobalVariable
>
pub
sampler
:
Option
<
Handle
<
crate
:
:
GlobalVariable
>
>
}
#
[
derive
(
Default
)
]
struct
IdGenerator
(
u32
)
;
impl
IdGenerator
{
fn
generate
(
&
mut
self
)
-
>
u32
{
let
ret
=
self
.
0
;
self
.
0
+
=
1
;
ret
}
}
struct
VaryingName
<
'
a
>
{
binding
:
&
'
a
crate
:
:
Binding
stage
:
ShaderStage
output
:
bool
}
impl
fmt
:
:
Display
for
VaryingName
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
.
binding
{
crate
:
:
Binding
:
:
Location
{
location
.
.
}
=
>
{
let
prefix
=
match
(
self
.
stage
self
.
output
)
{
(
ShaderStage
:
:
Compute
_
)
=
>
unreachable
!
(
)
(
ShaderStage
:
:
Vertex
false
)
=
>
"
p2vs
"
(
ShaderStage
:
:
Vertex
true
)
|
(
ShaderStage
:
:
Fragment
false
)
=
>
"
vs2fs
"
(
ShaderStage
:
:
Fragment
true
)
=
>
"
fs2p
"
}
;
write
!
(
f
"
_
{
}
_location
{
}
"
prefix
location
)
}
crate
:
:
Binding
:
:
BuiltIn
(
built_in
)
=
>
{
write
!
(
f
"
{
}
"
glsl_built_in
(
built_in
self
.
output
)
)
}
}
}
}
type
BackendResult
<
T
=
(
)
>
=
Result
<
T
Error
>
;
#
[
derive
(
Debug
Error
)
]
pub
enum
Error
{
#
[
error
(
"
Format
error
"
)
]
FmtError
(
#
[
from
]
FmtError
)
#
[
error
(
"
The
selected
version
doesn
'
t
support
{
0
:
?
}
"
)
]
MissingFeatures
(
Features
)
#
[
error
(
"
Push
constants
aren
'
t
supported
"
)
]
PushConstantNotSupported
#
[
error
(
"
The
specified
version
isn
'
t
supported
"
)
]
VersionNotSupported
#
[
error
(
"
The
requested
entry
point
couldn
'
t
be
found
"
)
]
EntryPointNotFound
#
[
error
(
"
A
call
was
made
to
an
unsupported
external
:
{
0
}
"
)
]
UnsupportedExternal
(
String
)
#
[
error
(
"
A
scalar
with
an
unsupported
width
was
requested
:
{
0
:
?
}
{
1
:
?
}
"
)
]
UnsupportedScalar
(
crate
:
:
ScalarKind
crate
:
:
Bytes
)
#
[
error
(
"
A
image
was
used
with
multiple
samplers
"
)
]
ImageMultipleSamplers
#
[
error
(
"
{
0
}
"
)
]
Custom
(
String
)
}
pub
struct
Writer
<
'
a
W
>
{
module
:
&
'
a
crate
:
:
Module
info
:
&
'
a
valid
:
:
ModuleInfo
out
:
W
options
:
&
'
a
Options
features
:
FeaturesManager
namer
:
proc
:
:
Namer
names
:
crate
:
:
FastHashMap
<
NameKey
String
>
reflection_names_uniforms
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
Type
>
String
>
reflection_names_globals
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
GlobalVariable
>
String
>
entry_point
:
&
'
a
crate
:
:
EntryPoint
entry_point_idx
:
proc
:
:
EntryPointIndex
block_id
:
IdGenerator
named_expressions
:
crate
:
:
NamedExpressions
}
impl
<
'
a
W
:
Write
>
Writer
<
'
a
W
>
{
pub
fn
new
(
out
:
W
module
:
&
'
a
crate
:
:
Module
info
:
&
'
a
valid
:
:
ModuleInfo
options
:
&
'
a
Options
pipeline_options
:
&
'
a
PipelineOptions
)
-
>
Result
<
Self
Error
>
{
if
!
options
.
version
.
is_supported
(
)
{
log
:
:
error
!
(
"
Version
{
}
"
options
.
version
)
;
return
Err
(
Error
:
:
VersionNotSupported
)
;
}
let
ep_idx
=
module
.
entry_points
.
iter
(
)
.
position
(
|
ep
|
{
pipeline_options
.
shader_stage
=
=
ep
.
stage
&
&
pipeline_options
.
entry_point
=
=
ep
.
name
}
)
.
ok_or
(
Error
:
:
EntryPointNotFound
)
?
;
let
mut
names
=
crate
:
:
FastHashMap
:
:
default
(
)
;
let
mut
namer
=
proc
:
:
Namer
:
:
default
(
)
;
namer
.
reset
(
module
keywords
:
:
RESERVED_KEYWORDS
&
[
"
gl_
"
]
&
mut
names
)
;
let
mut
this
=
Self
{
module
info
out
options
namer
features
:
FeaturesManager
:
:
new
(
)
names
reflection_names_uniforms
:
crate
:
:
FastHashMap
:
:
default
(
)
reflection_names_globals
:
crate
:
:
FastHashMap
:
:
default
(
)
entry_point
:
&
module
.
entry_points
[
ep_idx
]
entry_point_idx
:
ep_idx
as
u16
block_id
:
IdGenerator
:
:
default
(
)
named_expressions
:
crate
:
:
NamedExpressions
:
:
default
(
)
}
;
this
.
collect_required_features
(
)
?
;
Ok
(
this
)
}
pub
fn
write
(
&
mut
self
)
-
>
Result
<
ReflectionInfo
Error
>
{
let
es
=
self
.
options
.
version
.
is_es
(
)
;
writeln
!
(
self
.
out
"
#
version
{
}
"
self
.
options
.
version
)
?
;
self
.
features
.
write
(
self
.
options
.
version
&
mut
self
.
out
)
?
;
if
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
TEXTURE_SHADOW_LOD
)
{
writeln
!
(
self
.
out
"
#
extension
GL_EXT_texture_shadow_lod
:
require
"
)
?
;
}
if
es
{
writeln
!
(
self
.
out
)
?
;
writeln
!
(
self
.
out
"
precision
highp
float
;
"
)
?
;
writeln
!
(
self
.
out
"
precision
highp
int
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
self
.
entry_point
.
stage
=
=
ShaderStage
:
:
Compute
{
let
workgroup_size
=
self
.
entry_point
.
workgroup_size
;
writeln
!
(
self
.
out
"
layout
(
local_size_x
=
{
}
local_size_y
=
{
}
local_size_z
=
{
}
)
in
;
"
workgroup_size
[
0
]
workgroup_size
[
1
]
workgroup_size
[
2
]
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
let
Some
(
depth_test
)
=
self
.
entry_point
.
early_depth_test
{
if
self
.
options
.
version
.
supports_early_depth_test
(
)
{
writeln
!
(
self
.
out
"
layout
(
early_fragment_tests
)
in
;
"
)
?
;
if
let
Some
(
conservative
)
=
depth_test
.
conservative
{
use
crate
:
:
ConservativeDepth
as
Cd
;
let
depth
=
match
conservative
{
Cd
:
:
GreaterEqual
=
>
"
greater
"
Cd
:
:
LessEqual
=
>
"
less
"
Cd
:
:
Unchanged
=
>
"
unchanged
"
}
;
writeln
!
(
self
.
out
"
layout
(
depth_
{
}
)
out
float
gl_FragDepth
;
"
depth
)
?
;
}
writeln
!
(
self
.
out
)
?
;
}
else
{
log
:
:
warn
!
(
"
Early
depth
testing
is
not
supported
for
this
version
of
GLSL
:
{
}
"
self
.
options
.
version
)
;
}
}
for
(
handle
ty
)
in
self
.
module
.
types
.
iter
(
)
{
if
let
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
ty
.
inner
{
let
is_global_struct
=
self
.
module
.
global_variables
.
iter
(
)
.
any
(
|
e
|
e
.
1
.
ty
=
=
handle
)
;
if
!
is_global_struct
{
self
.
write_struct
(
false
handle
members
)
?
}
}
}
let
ep_info
=
self
.
info
.
get_entry_point
(
self
.
entry_point_idx
as
usize
)
;
for
(
handle
global
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
ep_info
[
handle
]
.
is_empty
(
)
{
continue
;
}
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
let
storage_format_access
=
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
format
access
}
.
.
}
=
>
Some
(
(
format
access
)
)
_
=
>
None
}
;
let
layout_binding
=
if
self
.
options
.
version
.
supports_explicit_locations
(
)
{
let
br
=
global
.
binding
.
as_ref
(
)
.
unwrap
(
)
;
self
.
options
.
binding_map
.
get
(
br
)
.
cloned
(
)
}
else
{
None
}
;
if
layout_binding
.
is_some
(
)
|
|
storage_format_access
.
is_some
(
)
{
write
!
(
self
.
out
"
layout
(
"
)
?
;
if
let
Some
(
binding
)
=
layout_binding
{
write
!
(
self
.
out
"
binding
=
{
}
"
binding
)
?
;
}
if
let
Some
(
(
format
_
)
)
=
storage_format_access
{
let
format_str
=
glsl_storage_format
(
format
)
;
let
separator
=
match
layout_binding
{
Some
(
_
)
=
>
"
"
None
=
>
"
"
}
;
write
!
(
self
.
out
"
{
}
{
}
"
separator
format_str
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
if
let
Some
(
(
_
access
)
)
=
storage_format_access
{
self
.
write_storage_access
(
access
)
?
;
}
write
!
(
self
.
out
"
uniform
"
)
?
;
self
.
write_image_type
(
dim
arrayed
class
)
?
;
let
global_name
=
self
.
get_global_name
(
handle
global
)
;
writeln
!
(
self
.
out
"
{
}
;
"
global_name
)
?
;
writeln
!
(
self
.
out
)
?
;
self
.
reflection_names_globals
.
insert
(
handle
global_name
)
;
}
TypeInner
:
:
Sampler
{
.
.
}
=
>
continue
_
=
>
{
if
!
ep_info
[
handle
]
.
is_empty
(
)
{
self
.
write_global
(
handle
global
)
?
;
writeln
!
(
self
.
out
)
?
;
}
}
}
}
for
arg
in
self
.
entry_point
.
function
.
arguments
.
iter
(
)
{
self
.
write_varying
(
arg
.
binding
.
as_ref
(
)
arg
.
ty
false
)
?
;
}
if
let
Some
(
ref
result
)
=
self
.
entry_point
.
function
.
result
{
self
.
write_varying
(
result
.
binding
.
as_ref
(
)
result
.
ty
true
)
?
;
}
writeln
!
(
self
.
out
)
?
;
for
(
handle
function
)
in
self
.
module
.
functions
.
iter
(
)
{
if
!
ep_info
.
dominates_global_use
(
&
self
.
info
[
handle
]
)
{
continue
;
}
let
name
=
self
.
names
[
&
NameKey
:
:
Function
(
handle
)
]
.
clone
(
)
;
let
fun_info
=
&
self
.
info
[
handle
]
;
self
.
write_function
(
back
:
:
FunctionType
:
:
Function
(
handle
)
function
fun_info
&
name
)
?
;
writeln
!
(
self
.
out
)
?
;
}
self
.
write_function
(
back
:
:
FunctionType
:
:
EntryPoint
(
self
.
entry_point_idx
)
&
self
.
entry_point
.
function
ep_info
"
main
"
)
?
;
writeln
!
(
self
.
out
)
?
;
self
.
collect_reflection_info
(
)
}
fn
write_array_size
(
&
mut
self
size
:
crate
:
:
ArraySize
)
-
>
BackendResult
{
write
!
(
self
.
out
"
[
"
)
?
;
match
size
{
crate
:
:
ArraySize
:
:
Constant
(
const_handle
)
=
>
{
match
self
.
module
.
constants
[
const_handle
]
.
inner
{
crate
:
:
ConstantInner
:
:
Scalar
{
width
:
_
value
:
crate
:
:
ScalarValue
:
:
Uint
(
size
)
}
=
>
write
!
(
self
.
out
"
{
}
"
size
)
?
crate
:
:
ConstantInner
:
:
Scalar
{
width
:
_
value
:
crate
:
:
ScalarValue
:
:
Sint
(
size
)
}
=
>
write
!
(
self
.
out
"
{
}
"
size
)
?
_
=
>
unreachable
!
(
)
}
}
crate
:
:
ArraySize
:
:
Dynamic
=
>
(
)
}
write
!
(
self
.
out
"
]
"
)
?
;
Ok
(
(
)
)
}
fn
write_value_type
(
&
mut
self
inner
:
&
TypeInner
)
-
>
BackendResult
{
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
width
}
|
TypeInner
:
:
Atomic
{
kind
width
}
|
TypeInner
:
:
ValuePointer
{
size
:
None
kind
width
class
:
_
}
=
>
write
!
(
self
.
out
"
{
}
"
glsl_scalar
(
kind
width
)
?
.
full
)
?
TypeInner
:
:
Vector
{
size
kind
width
}
|
TypeInner
:
:
ValuePointer
{
size
:
Some
(
size
)
kind
width
class
:
_
}
=
>
write
!
(
self
.
out
"
{
}
vec
{
}
"
glsl_scalar
(
kind
width
)
?
.
prefix
size
as
u8
)
?
TypeInner
:
:
Matrix
{
columns
rows
width
}
=
>
write
!
(
self
.
out
"
{
}
mat
{
}
x
{
}
"
glsl_scalar
(
crate
:
:
ScalarKind
:
:
Float
width
)
?
.
prefix
columns
as
u8
rows
as
u8
)
?
TypeInner
:
:
Array
{
size
.
.
}
=
>
self
.
write_array_size
(
size
)
?
TypeInner
:
:
Pointer
{
.
.
}
|
TypeInner
:
:
Struct
{
.
.
}
|
TypeInner
:
:
Image
{
.
.
}
|
TypeInner
:
:
Sampler
{
.
.
}
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_type
(
&
mut
self
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
BackendResult
{
match
self
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
self
.
write_type
(
base
)
TypeInner
:
:
Struct
{
top_level
:
true
ref
members
span
:
_
}
=
>
self
.
write_struct
(
true
ty
members
)
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
Ok
(
(
)
)
}
TypeInner
:
:
Array
{
base
.
.
}
=
>
self
.
write_type
(
base
)
ref
other
=
>
self
.
write_value_type
(
other
)
}
}
fn
write_image_type
(
&
mut
self
dim
:
crate
:
:
ImageDimension
arrayed
:
bool
class
:
crate
:
:
ImageClass
)
-
>
BackendResult
{
use
crate
:
:
ImageClass
as
Ic
;
let
(
base
kind
ms
comparison
)
=
match
class
{
Ic
:
:
Sampled
{
kind
multi
:
true
}
=
>
(
"
sampler
"
kind
"
MS
"
"
"
)
Ic
:
:
Sampled
{
kind
multi
:
false
}
=
>
(
"
sampler
"
kind
"
"
"
"
)
Ic
:
:
Depth
{
multi
:
true
}
=
>
(
"
sampler
"
crate
:
:
ScalarKind
:
:
Float
"
MS
"
"
"
)
Ic
:
:
Depth
{
multi
:
false
}
=
>
(
"
sampler
"
crate
:
:
ScalarKind
:
:
Float
"
"
"
Shadow
"
)
Ic
:
:
Storage
{
format
.
.
}
=
>
(
"
image
"
format
.
into
(
)
"
"
"
"
)
}
;
write
!
(
self
.
out
"
highp
{
}
{
}
{
}
{
}
{
}
{
}
"
glsl_scalar
(
kind
4
)
?
.
prefix
base
glsl_dimension
(
dim
)
ms
if
arrayed
{
"
Array
"
}
else
{
"
"
}
comparison
)
?
;
Ok
(
(
)
)
}
fn
write_global
(
&
mut
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
BackendResult
{
if
self
.
options
.
version
.
supports_explicit_locations
(
)
{
if
let
Some
(
ref
br
)
=
global
.
binding
{
match
self
.
options
.
binding_map
.
get
(
br
)
{
Some
(
binding
)
=
>
write
!
(
self
.
out
"
layout
(
binding
=
{
}
)
"
binding
)
?
None
=
>
log
:
:
debug
!
(
"
unassigned
binding
for
{
:
?
}
"
global
.
name
)
}
}
}
if
let
crate
:
:
StorageClass
:
:
Storage
{
access
}
=
global
.
class
{
self
.
write_storage_access
(
access
)
?
;
}
if
let
Some
(
storage_class
)
=
glsl_storage_class
(
global
.
class
)
{
write
!
(
self
.
out
"
{
}
"
storage_class
)
?
;
}
else
if
let
TypeInner
:
:
Struct
{
top_level
:
true
.
.
}
=
self
.
module
.
types
[
global
.
ty
]
.
inner
{
write
!
(
self
.
out
"
struct
"
)
?
;
}
self
.
write_type
(
global
.
ty
)
?
;
let
global_name
=
self
.
get_global_name
(
handle
global
)
;
write
!
(
self
.
out
"
{
}
"
global_name
)
?
;
if
let
TypeInner
:
:
Array
{
size
.
.
}
=
self
.
module
.
types
[
global
.
ty
]
.
inner
{
self
.
write_array_size
(
size
)
?
;
}
if
is_value_init_supported
(
self
.
module
global
.
ty
)
{
write
!
(
self
.
out
"
=
"
)
?
;
if
let
Some
(
init
)
=
global
.
init
{
self
.
write_constant
(
init
)
?
;
}
else
{
self
.
write_zero_init_value
(
global
.
ty
)
?
;
}
}
writeln
!
(
self
.
out
"
;
"
)
?
;
Ok
(
(
)
)
}
fn
get_global_name
(
&
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
String
{
match
global
.
binding
{
Some
(
ref
br
)
=
>
{
format
!
(
"
_group_
{
}
_binding_
{
}
"
br
.
group
br
.
binding
)
}
None
=
>
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
.
clone
(
)
}
}
fn
write_varying
(
&
mut
self
binding
:
Option
<
&
crate
:
:
Binding
>
ty
:
Handle
<
crate
:
:
Type
>
output
:
bool
)
-
>
Result
<
(
)
Error
>
{
match
self
.
module
.
types
[
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
for
member
in
members
{
self
.
write_varying
(
member
.
binding
.
as_ref
(
)
member
.
ty
output
)
?
;
}
}
_
=
>
{
let
(
location
interpolation
sampling
)
=
match
binding
{
Some
(
&
crate
:
:
Binding
:
:
Location
{
location
interpolation
sampling
}
)
=
>
(
location
interpolation
sampling
)
_
=
>
return
Ok
(
(
)
)
}
;
let
emit_interpolation_and_auxiliary
=
match
self
.
entry_point
.
stage
{
ShaderStage
:
:
Vertex
=
>
output
ShaderStage
:
:
Fragment
=
>
!
output
_
=
>
false
}
;
if
self
.
options
.
version
.
supports_explicit_locations
(
)
|
|
!
emit_interpolation_and_auxiliary
{
write
!
(
self
.
out
"
layout
(
location
=
{
}
)
"
location
)
?
;
}
if
let
Some
(
interp
)
=
interpolation
{
if
emit_interpolation_and_auxiliary
{
write
!
(
self
.
out
"
{
}
"
glsl_interpolation
(
interp
)
)
?
;
}
}
if
let
Some
(
sampling
)
=
sampling
{
if
emit_interpolation_and_auxiliary
{
if
let
Some
(
qualifier
)
=
glsl_sampling
(
sampling
)
{
write
!
(
self
.
out
"
{
}
"
qualifier
)
?
;
}
}
}
write
!
(
self
.
out
"
{
}
"
if
output
{
"
out
"
}
else
{
"
in
"
}
)
?
;
self
.
write_type
(
ty
)
?
;
let
vname
=
VaryingName
{
binding
:
&
crate
:
:
Binding
:
:
Location
{
location
interpolation
:
None
sampling
:
None
}
stage
:
self
.
entry_point
.
stage
output
}
;
writeln
!
(
self
.
out
"
{
}
;
"
vname
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_function
(
&
mut
self
ty
:
back
:
:
FunctionType
func
:
&
crate
:
:
Function
info
:
&
valid
:
:
FunctionInfo
name
:
&
str
)
-
>
BackendResult
{
let
ctx
=
back
:
:
FunctionCtx
{
ty
info
expressions
:
&
func
.
expressions
named_expressions
:
&
func
.
named_expressions
}
;
self
.
named_expressions
.
clear
(
)
;
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
_
)
=
ctx
.
ty
{
write
!
(
self
.
out
"
void
"
)
?
;
}
else
if
let
Some
(
ref
result
)
=
func
.
result
{
self
.
write_type
(
result
.
ty
)
?
;
}
else
{
write
!
(
self
.
out
"
void
"
)
?
;
}
write
!
(
self
.
out
"
{
}
(
"
name
)
?
;
let
arguments
=
match
ctx
.
ty
{
back
:
:
FunctionType
:
:
EntryPoint
(
_
)
=
>
&
[
]
[
.
.
]
back
:
:
FunctionType
:
:
Function
(
_
)
=
>
&
func
.
arguments
}
;
let
arguments
:
Vec
<
_
>
=
arguments
.
iter
(
)
.
filter
(
|
arg
|
match
self
.
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Sampler
{
.
.
}
=
>
false
_
=
>
true
}
)
.
collect
(
)
;
self
.
write_slice
(
&
arguments
|
this
i
arg
|
{
match
this
.
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
if
let
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
format
.
.
}
.
.
}
=
this
.
module
.
types
[
arg
.
ty
]
.
inner
{
write
!
(
this
.
out
"
layout
(
{
}
)
"
glsl_storage_format
(
format
)
)
?
;
}
this
.
write_image_type
(
dim
arrayed
class
)
?
;
}
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
{
write
!
(
this
.
out
"
inout
"
)
?
;
this
.
write_type
(
base
)
?
;
}
_
=
>
{
this
.
write_type
(
arg
.
ty
)
?
;
}
}
write
!
(
this
.
out
"
{
}
"
&
this
.
names
[
&
ctx
.
argument_key
(
i
)
]
)
?
;
Ok
(
(
)
)
}
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
ep_index
)
=
ctx
.
ty
{
let
stage
=
self
.
module
.
entry_points
[
ep_index
as
usize
]
.
stage
;
for
(
index
arg
)
in
func
.
arguments
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
self
.
write_type
(
arg
.
ty
)
?
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
EntryPointArgument
(
ep_index
index
as
u32
)
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
match
self
.
module
.
types
[
arg
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
self
.
write_type
(
arg
.
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
let
varying_name
=
VaryingName
{
binding
:
member
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
output
:
false
}
;
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
write
!
(
self
.
out
"
{
}
"
varying_name
)
?
;
}
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
_
=
>
{
let
varying_name
=
VaryingName
{
binding
:
arg
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
output
:
false
}
;
writeln
!
(
self
.
out
"
{
}
;
"
varying_name
)
?
;
}
}
}
}
for
(
handle
local
)
in
func
.
local_variables
.
iter
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
self
.
write_type
(
local
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
;
if
let
TypeInner
:
:
Array
{
size
.
.
}
=
self
.
module
.
types
[
local
.
ty
]
.
inner
{
self
.
write_array_size
(
size
)
?
;
}
if
let
Some
(
init
)
=
local
.
init
{
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_constant
(
init
)
?
;
}
else
if
is_value_init_supported
(
self
.
module
local
.
ty
)
{
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_zero_init_value
(
local
.
ty
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
}
for
sta
in
func
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
&
ctx
back
:
:
Level
(
1
)
)
?
;
}
writeln
!
(
self
.
out
"
}
}
"
)
?
;
Ok
(
(
)
)
}
fn
write_slice
<
T
F
:
FnMut
(
&
mut
Self
u32
&
T
)
-
>
BackendResult
>
(
&
mut
self
data
:
&
[
T
]
mut
f
:
F
)
-
>
BackendResult
{
for
(
i
item
)
in
data
.
iter
(
)
.
enumerate
(
)
{
f
(
self
i
as
u32
item
)
?
;
if
i
!
=
data
.
len
(
)
.
saturating_sub
(
1
)
{
write
!
(
self
.
out
"
"
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_constant
(
&
mut
self
handle
:
Handle
<
crate
:
:
Constant
>
)
-
>
BackendResult
{
use
crate
:
:
ScalarValue
as
Sv
;
match
self
.
module
.
constants
[
handle
]
.
inner
{
crate
:
:
ConstantInner
:
:
Scalar
{
width
:
_
ref
value
}
=
>
match
*
value
{
Sv
:
:
Sint
(
int
)
=
>
write
!
(
self
.
out
"
{
}
"
int
)
?
Sv
:
:
Uint
(
int
)
=
>
write
!
(
self
.
out
"
{
}
u
"
int
)
?
Sv
:
:
Float
(
float
)
=
>
write
!
(
self
.
out
"
{
:
?
}
"
float
)
?
Sv
:
:
Bool
(
boolean
)
=
>
write
!
(
self
.
out
"
{
}
"
boolean
)
?
}
crate
:
:
ConstantInner
:
:
Composite
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_slice
(
components
|
this
_
arg
|
this
.
write_constant
(
*
arg
)
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_struct
(
&
mut
self
block
:
bool
handle
:
Handle
<
crate
:
:
Type
>
members
:
&
[
crate
:
:
StructMember
]
)
-
>
BackendResult
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
handle
)
]
;
if
block
{
let
stage_postfix
=
match
self
.
entry_point
.
stage
{
ShaderStage
:
:
Vertex
=
>
"
Vs
"
ShaderStage
:
:
Fragment
=
>
"
Fs
"
ShaderStage
:
:
Compute
=
>
"
Cs
"
}
;
let
block_name
=
format
!
(
"
{
}
_block_
{
}
{
}
"
name
self
.
block_id
.
generate
(
)
stage_postfix
)
;
writeln
!
(
self
.
out
"
{
}
{
{
"
block_name
)
?
;
self
.
reflection_names_uniforms
.
insert
(
handle
block_name
)
;
}
else
{
writeln
!
(
self
.
out
"
struct
{
}
{
{
"
name
)
?
;
}
for
(
idx
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
match
self
.
module
.
types
[
member
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
size
stride
:
_
}
=
>
{
self
.
write_type
(
base
)
?
;
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
self
.
write_array_size
(
size
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
_
=
>
{
self
.
write_type
(
member
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
}
}
}
write
!
(
self
.
out
"
}
}
"
)
?
;
if
!
block
{
writeln
!
(
self
.
out
"
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
Ok
(
(
)
)
}
fn
write_stmt
(
&
mut
self
sta
:
&
crate
:
:
Statement
ctx
:
&
back
:
:
FunctionCtx
level
:
back
:
:
Level
)
-
>
BackendResult
{
use
crate
:
:
Statement
;
match
*
sta
{
Statement
:
:
Emit
(
ref
range
)
=
>
{
for
handle
in
range
.
clone
(
)
{
let
expr_name
=
if
let
Some
(
name
)
=
ctx
.
named_expressions
.
get
(
&
handle
)
{
Some
(
self
.
namer
.
call_unique
(
name
)
)
}
else
{
let
min_ref_count
=
ctx
.
expressions
[
handle
]
.
bake_ref_count
(
)
;
if
min_ref_count
<
=
ctx
.
info
[
handle
]
.
ref_count
{
Some
(
format
!
(
"
{
}
{
}
"
super
:
:
BAKE_PREFIX
handle
.
index
(
)
)
)
}
else
{
None
}
}
;
if
let
Some
(
name
)
=
expr_name
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
self
.
write_named_expr
(
handle
name
ctx
)
?
;
}
}
}
Statement
:
:
Block
(
ref
block
)
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
sta
in
block
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
If
{
condition
ref
accept
ref
reject
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
write
!
(
self
.
out
"
if
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
sta
in
accept
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
if
!
reject
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
}
}
else
{
{
"
level
)
?
;
for
sta
in
reject
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
Switch
{
selector
ref
cases
ref
default
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
write
!
(
self
.
out
"
switch
(
"
)
?
;
self
.
write_expr
(
selector
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
let
l2
=
level
.
next
(
)
;
for
case
in
cases
{
writeln
!
(
self
.
out
"
{
}
case
{
}
:
"
l2
case
.
value
)
?
;
for
sta
in
case
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
l2
.
next
(
)
)
?
;
}
if
case
.
fall_through
{
writeln
!
(
self
.
out
"
{
}
/
*
fallthrough
*
/
"
l2
.
next
(
)
)
?
;
}
else
if
!
matches
!
(
case
.
body
.
last
(
)
Some
(
&
Statement
:
:
Break
)
|
Some
(
&
Statement
:
:
Continue
)
|
Some
(
&
Statement
:
:
Return
{
.
.
}
)
|
Some
(
&
Statement
:
:
Kill
)
)
{
writeln
!
(
self
.
out
"
{
}
break
;
"
l2
.
next
(
)
)
?
;
}
}
if
!
default
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
default
:
"
level
.
next
(
)
)
?
;
for
sta
in
default
{
self
.
write_stmt
(
sta
ctx
l2
.
next
(
)
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
Loop
{
ref
body
ref
continuing
}
=
>
{
if
!
continuing
.
is_empty
(
)
{
let
gate_name
=
self
.
namer
.
call
(
"
loop_init
"
)
;
writeln
!
(
self
.
out
"
{
}
bool
{
}
=
true
;
"
level
gate_name
)
?
;
writeln
!
(
self
.
out
"
{
}
while
(
true
)
{
{
"
level
)
?
;
writeln
!
(
self
.
out
"
{
}
if
(
!
{
}
)
{
{
"
level
.
next
(
)
gate_name
)
?
;
for
sta
in
continuing
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
.
next
(
)
)
?
;
writeln
!
(
self
.
out
"
{
}
{
}
=
false
;
"
level
.
next
(
)
gate_name
)
?
;
}
else
{
writeln
!
(
self
.
out
"
{
}
while
(
true
)
{
{
"
level
)
?
;
}
for
sta
in
body
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
Break
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
writeln
!
(
self
.
out
"
break
;
"
)
?
}
Statement
:
:
Continue
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
writeln
!
(
self
.
out
"
continue
;
"
)
?
}
Statement
:
:
Return
{
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
match
ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
_
)
=
>
{
write
!
(
self
.
out
"
return
"
)
?
;
if
let
Some
(
expr
)
=
value
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
;
}
back
:
:
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
{
let
ep
=
&
self
.
module
.
entry_points
[
ep_index
as
usize
]
;
if
let
Some
(
ref
result
)
=
ep
.
function
.
result
{
let
value
=
value
.
unwrap
(
)
;
match
self
.
module
.
types
[
result
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
let
temp_struct_name
=
match
ctx
.
expressions
[
value
]
{
crate
:
:
Expression
:
:
Compose
{
.
.
}
=
>
{
let
return_struct
=
"
_tmp_return
"
;
write
!
(
self
.
out
"
{
}
{
}
=
"
&
self
.
names
[
&
NameKey
:
:
Type
(
result
.
ty
)
]
return_struct
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
write
!
(
self
.
out
"
{
}
"
level
)
?
;
Some
(
return_struct
)
}
_
=
>
None
}
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
if
let
Some
(
crate
:
:
Binding
:
:
BuiltIn
(
builtin
)
)
=
member
.
binding
{
match
builtin
{
crate
:
:
BuiltIn
:
:
ClipDistance
|
crate
:
:
BuiltIn
:
:
CullDistance
|
crate
:
:
BuiltIn
:
:
PointSize
=
>
{
if
self
.
options
.
version
.
is_es
(
)
{
continue
;
}
}
_
=
>
{
}
}
}
let
varying_name
=
VaryingName
{
binding
:
member
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
:
ep
.
stage
output
:
true
}
;
let
field_name
=
self
.
names
[
&
NameKey
:
:
StructMember
(
result
.
ty
index
as
u32
)
]
.
clone
(
)
;
write
!
(
self
.
out
"
{
}
=
"
varying_name
)
?
;
if
let
Some
(
struct_name
)
=
temp_struct_name
{
write
!
(
self
.
out
"
{
}
"
struct_name
)
?
;
}
else
{
self
.
write_expr
(
value
ctx
)
?
;
}
writeln
!
(
self
.
out
"
.
{
}
;
"
field_name
)
?
;
write
!
(
self
.
out
"
{
}
"
level
)
?
;
}
}
_
=
>
{
let
name
=
VaryingName
{
binding
:
result
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
:
ep
.
stage
output
:
true
}
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
write
!
(
self
.
out
"
{
}
"
level
)
?
;
}
}
}
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
ep_index
)
=
ctx
.
ty
{
if
self
.
module
.
entry_points
[
ep_index
as
usize
]
.
stage
=
=
crate
:
:
ShaderStage
:
:
Vertex
&
&
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
ADJUST_COORDINATE_SPACE
)
{
writeln
!
(
self
.
out
"
gl_Position
.
yz
=
vec2
(
-
gl_Position
.
y
gl_Position
.
z
*
2
.
0
-
gl_Position
.
w
)
;
"
)
?
;
write
!
(
self
.
out
"
{
}
"
level
)
?
;
}
}
writeln
!
(
self
.
out
"
return
;
"
)
?
;
}
}
}
Statement
:
:
Kill
=
>
writeln
!
(
self
.
out
"
{
}
discard
;
"
level
)
?
Statement
:
:
Barrier
(
flags
)
=
>
{
if
flags
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
barrier
(
)
;
"
level
)
?
;
}
else
{
writeln
!
(
self
.
out
"
{
}
groupMemoryBarrier
(
)
;
"
level
)
?
;
}
}
Statement
:
:
Store
{
pointer
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
self
.
write_expr
(
pointer
ctx
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
}
Statement
:
:
ImageStore
{
image
coordinate
array_index
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
let
dim
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
.
.
}
=
>
dim
_
=
>
unreachable
!
(
)
}
;
write
!
(
self
.
out
"
imageStore
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
coordinate
array_index
dim
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
Statement
:
:
Call
{
function
ref
arguments
result
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
if
let
Some
(
expr
)
=
result
{
let
name
=
format
!
(
"
{
}
{
}
"
super
:
:
BAKE_PREFIX
expr
.
index
(
)
)
;
let
result
=
self
.
module
.
functions
[
function
]
.
result
.
as_ref
(
)
.
unwrap
(
)
;
self
.
write_type
(
result
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
named_expressions
.
insert
(
expr
name
)
;
}
write
!
(
self
.
out
"
{
}
(
"
&
self
.
names
[
&
NameKey
:
:
Function
(
function
)
]
)
?
;
let
arguments
:
Vec
<
_
>
=
arguments
.
iter
(
)
.
enumerate
(
)
.
filter_map
(
|
(
i
arg
)
|
{
let
arg_ty
=
self
.
module
.
functions
[
function
]
.
arguments
[
i
]
.
ty
;
match
self
.
module
.
types
[
arg_ty
]
.
inner
{
TypeInner
:
:
Sampler
{
.
.
}
=
>
None
_
=
>
Some
(
*
arg
)
}
}
)
.
collect
(
)
;
self
.
write_slice
(
&
arguments
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
}
Statement
:
:
Atomic
{
pointer
ref
fun
value
result
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
let
res_name
=
format
!
(
"
{
}
{
}
"
super
:
:
BAKE_PREFIX
result
.
index
(
)
)
;
let
res_ty
=
ctx
.
info
[
result
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
self
.
write_value_type
(
res_ty
)
?
;
write
!
(
self
.
out
"
{
}
=
"
res_name
)
?
;
self
.
named_expressions
.
insert
(
result
res_name
)
;
let
fun_str
=
fun
.
to_glsl
(
)
;
write
!
(
self
.
out
"
atomic
{
}
(
"
fun_str
)
?
;
self
.
write_expr
(
pointer
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
match
*
fun
{
crate
:
:
AtomicFunction
:
:
Subtract
=
>
{
write
!
(
self
.
out
"
-
"
)
?
;
}
crate
:
:
AtomicFunction
:
:
Exchange
{
compare
:
Some
(
_
)
}
=
>
{
return
Err
(
Error
:
:
Custom
(
"
atomic
CompareExchange
is
not
implemented
"
.
to_string
(
)
)
)
;
}
_
=
>
{
}
}
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_expr
(
&
mut
self
expr
:
Handle
<
crate
:
:
Expression
>
ctx
:
&
back
:
:
FunctionCtx
<
'
_
>
)
-
>
BackendResult
{
use
crate
:
:
Expression
;
if
let
Some
(
name
)
=
self
.
named_expressions
.
get
(
&
expr
)
{
write
!
(
self
.
out
"
{
}
"
name
)
?
;
return
Ok
(
(
)
)
;
}
match
ctx
.
expressions
[
expr
]
{
Expression
:
:
Access
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
self
.
write_expr
(
index
ctx
)
?
;
write
!
(
self
.
out
"
]
"
)
?
}
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
let
base_ty_res
=
&
ctx
.
info
[
base
]
.
ty
;
let
mut
resolved
=
base_ty_res
.
inner_with
(
&
self
.
module
.
types
)
;
let
base_ty_handle
=
match
*
resolved
{
TypeInner
:
:
Pointer
{
base
class
:
_
}
=
>
{
resolved
=
&
self
.
module
.
types
[
base
]
.
inner
;
Some
(
base
)
}
_
=
>
base_ty_res
.
handle
(
)
}
;
match
*
resolved
{
TypeInner
:
:
Vector
{
.
.
}
=
>
{
write
!
(
self
.
out
"
.
{
}
"
back
:
:
COMPONENTS
[
index
as
usize
]
)
?
}
TypeInner
:
:
Matrix
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
|
TypeInner
:
:
ValuePointer
{
.
.
}
=
>
write
!
(
self
.
out
"
[
{
}
]
"
index
)
?
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty
=
base_ty_handle
.
unwrap
(
)
;
write
!
(
self
.
out
"
.
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
index
)
]
)
?
}
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
index
{
:
?
}
"
other
)
)
)
}
}
Expression
:
:
Constant
(
constant
)
=
>
self
.
write_constant
(
constant
)
?
Expression
:
:
Splat
{
size
:
_
value
}
=
>
{
let
resolved
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
self
.
write_value_type
(
resolved
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Swizzle
{
size
vector
pattern
}
=
>
{
self
.
write_expr
(
vector
ctx
)
?
;
write
!
(
self
.
out
"
.
"
)
?
;
for
&
sc
in
pattern
[
.
.
size
as
usize
]
.
iter
(
)
{
self
.
out
.
write_char
(
back
:
:
COMPONENTS
[
sc
as
usize
]
)
?
;
}
}
Expression
:
:
Compose
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
let
resolved
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
if
let
TypeInner
:
:
Array
{
size
.
.
}
=
*
resolved
{
self
.
write_array_size
(
size
)
?
;
}
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_slice
(
components
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
FunctionArgument
(
pos
)
=
>
{
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
ctx
.
argument_key
(
pos
)
]
)
?
}
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
global
=
&
self
.
module
.
global_variables
[
handle
]
;
write
!
(
self
.
out
"
{
}
"
self
.
get_global_name
(
handle
global
)
)
?
}
Expression
:
:
LocalVariable
(
handle
)
=
>
{
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
}
Expression
:
:
Load
{
pointer
}
=
>
self
.
write_expr
(
pointer
ctx
)
?
Expression
:
:
ImageSample
{
image
sampler
:
_
coordinate
array_index
offset
level
depth_ref
}
=
>
{
let
dim
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
.
.
}
=
>
dim
_
=
>
unreachable
!
(
)
}
;
let
workaround_lod_array_shadow_as_grad
=
(
array_index
.
is_some
(
)
|
|
dim
=
=
crate
:
:
ImageDimension
:
:
Cube
)
&
&
depth_ref
.
is_some
(
)
&
&
!
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
TEXTURE_SHADOW_LOD
)
;
let
fun_name
=
match
level
{
crate
:
:
SampleLevel
:
:
Auto
|
crate
:
:
SampleLevel
:
:
Bias
(
_
)
=
>
"
texture
"
crate
:
:
SampleLevel
:
:
Zero
|
crate
:
:
SampleLevel
:
:
Exact
(
_
)
=
>
{
if
workaround_lod_array_shadow_as_grad
{
"
textureGrad
"
}
else
{
"
textureLod
"
}
}
crate
:
:
SampleLevel
:
:
Gradient
{
.
.
}
=
>
"
textureGrad
"
}
;
let
offset_name
=
match
offset
{
Some
(
_
)
=
>
"
Offset
"
None
=
>
"
"
}
;
write
!
(
self
.
out
"
{
}
{
}
(
"
fun_name
offset_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
let
size
=
match
*
ctx
.
info
[
coordinate
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
size
_
=
>
unreachable
!
(
)
}
;
let
mut
coord_dim
=
size
as
u8
;
if
array_index
.
is_some
(
)
{
coord_dim
+
=
1
;
}
if
depth_ref
.
is_some
(
)
{
coord_dim
+
=
1
;
}
write
!
(
self
.
out
"
vec
{
}
(
"
coord_dim
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
if
let
Some
(
expr
)
=
array_index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
if
let
Some
(
expr
)
=
depth_ref
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
match
level
{
crate
:
:
SampleLevel
:
:
Auto
=
>
(
)
crate
:
:
SampleLevel
:
:
Zero
=
>
{
if
workaround_lod_array_shadow_as_grad
{
write
!
(
self
.
out
"
vec2
(
0
0
)
vec2
(
0
0
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
0
.
0
"
)
?
;
}
}
crate
:
:
SampleLevel
:
:
Exact
(
expr
)
=
>
{
if
workaround_lod_array_shadow_as_grad
{
log
:
:
warn
!
(
"
Unable
to
textureLod
a
shadow
array
ignoring
the
LOD
"
)
;
write
!
(
self
.
out
"
vec2
(
0
0
)
vec2
(
0
0
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
}
crate
:
:
SampleLevel
:
:
Bias
(
expr
)
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
crate
:
:
SampleLevel
:
:
Gradient
{
x
y
}
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
x
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
y
ctx
)
?
;
}
}
if
let
Some
(
constant
)
=
offset
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_constant
(
constant
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
ImageLoad
{
image
coordinate
array_index
index
}
=
>
{
let
(
dim
class
)
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
fun_name
=
match
class
{
crate
:
:
ImageClass
:
:
Sampled
{
.
.
}
=
>
"
texelFetch
"
crate
:
:
ImageClass
:
:
Storage
{
.
.
}
=
>
"
imageLoad
"
crate
:
:
ImageClass
:
:
Depth
{
multi
:
_
}
=
>
{
return
Err
(
Error
:
:
Custom
(
"
TODO
:
depth
sample
loads
"
.
to_string
(
)
)
)
}
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
coordinate
array_index
dim
ctx
)
?
;
if
let
Some
(
index_expr
)
=
index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
index_expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
ImageQuery
{
image
query
}
=
>
{
use
crate
:
:
ImageClass
;
let
(
dim
class
)
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
components
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
1
crate
:
:
ImageDimension
:
:
D2
=
>
2
crate
:
:
ImageDimension
:
:
D3
=
>
3
crate
:
:
ImageDimension
:
:
Cube
=
>
2
}
;
match
query
{
crate
:
:
ImageQuery
:
:
Size
{
level
}
=
>
{
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
{
.
.
}
=
>
{
write
!
(
self
.
out
"
textureSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
if
let
Some
(
expr
)
=
level
{
self
.
write_expr
(
expr
ctx
)
?
;
}
else
{
write
!
(
self
.
out
"
0
"
)
?
;
}
}
ImageClass
:
:
Storage
{
.
.
}
=
>
{
write
!
(
self
.
out
"
imageSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
.
{
}
"
&
"
xyz
"
[
.
.
components
]
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLevels
=
>
{
write
!
(
self
.
out
"
textureQueryLevels
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLayers
=
>
{
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
{
.
.
}
=
>
"
textureSize
"
ImageClass
:
:
Storage
{
.
.
}
=
>
"
imageSize
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
0
)
.
{
}
"
back
:
:
COMPONENTS
[
components
]
)
?
;
}
crate
:
:
ImageQuery
:
:
NumSamples
=
>
{
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
{
.
.
}
=
>
{
"
textureSamples
"
}
ImageClass
:
:
Storage
{
.
.
}
=
>
"
imageSamples
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
}
}
Expression
:
:
Unary
{
op
expr
}
=
>
{
use
crate
:
:
{
ScalarKind
as
Sk
UnaryOperator
as
Uo
}
;
write
!
(
self
.
out
"
(
{
}
"
match
op
{
Uo
:
:
Negate
=
>
"
-
"
Uo
:
:
Not
=
>
match
*
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Scalar
{
kind
:
Sk
:
:
Sint
.
.
}
=
>
"
~
"
TypeInner
:
:
Scalar
{
kind
:
Sk
:
:
Uint
.
.
}
=
>
"
~
"
TypeInner
:
:
Scalar
{
kind
:
Sk
:
:
Bool
.
.
}
=
>
"
!
"
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
apply
not
to
type
{
:
?
}
"
other
)
)
)
}
}
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Binary
{
op
left
right
}
=
>
{
use
crate
:
:
{
BinaryOperator
as
Bo
ScalarKind
as
Sk
TypeInner
as
Ti
}
;
let
left_inner
=
ctx
.
info
[
left
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
let
right_inner
=
ctx
.
info
[
right
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
let
function
=
match
(
left_inner
right_inner
)
{
(
&
Ti
:
:
Vector
{
.
.
}
&
Ti
:
:
Vector
{
.
.
}
)
=
>
match
op
{
Bo
:
:
Less
=
>
Some
(
"
lessThan
"
)
Bo
:
:
LessEqual
=
>
Some
(
"
lessThanEqual
"
)
Bo
:
:
Greater
=
>
Some
(
"
greaterThan
"
)
Bo
:
:
GreaterEqual
=
>
Some
(
"
greaterThanEqual
"
)
Bo
:
:
Equal
=
>
Some
(
"
equal
"
)
Bo
:
:
NotEqual
=
>
Some
(
"
notEqual
"
)
_
=
>
None
}
_
=
>
match
(
left_inner
.
scalar_kind
(
)
right_inner
.
scalar_kind
(
)
)
{
(
Some
(
Sk
:
:
Float
)
_
)
|
(
_
Some
(
Sk
:
:
Float
)
)
=
>
match
op
{
Bo
:
:
Modulo
=
>
Some
(
"
mod
"
)
_
=
>
None
}
_
=
>
None
}
}
;
write
!
(
self
.
out
"
{
}
(
"
function
.
unwrap_or
(
"
"
)
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
if
function
.
is_some
(
)
{
write
!
(
self
.
out
"
"
)
?
}
else
{
write
!
(
self
.
out
"
{
}
"
super
:
:
binary_operation_str
(
op
)
)
?
;
}
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Select
{
condition
accept
reject
}
=
>
{
let
cond_ty
=
ctx
.
info
[
condition
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
let
vec_select
=
if
let
TypeInner
:
:
Vector
{
.
.
}
=
*
cond_ty
{
true
}
else
{
false
}
;
if
vec_select
{
write
!
(
self
.
out
"
mix
(
"
)
?
;
self
.
write_expr
(
reject
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
accept
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
}
else
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
write
!
(
self
.
out
"
?
"
)
?
;
self
.
write_expr
(
accept
ctx
)
?
;
write
!
(
self
.
out
"
:
"
)
?
;
self
.
write_expr
(
reject
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Derivative
{
axis
expr
}
=
>
{
use
crate
:
:
DerivativeAxis
as
Da
;
write
!
(
self
.
out
"
{
}
(
"
match
axis
{
Da
:
:
X
=
>
"
dFdx
"
Da
:
:
Y
=
>
"
dFdy
"
Da
:
:
Width
=
>
"
fwidth
"
}
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Relational
{
fun
argument
}
=
>
{
use
crate
:
:
RelationalFunction
as
Rf
;
let
fun_name
=
match
fun
{
Rf
:
:
IsFinite
=
>
"
!
isinf
"
Rf
:
:
IsInf
=
>
"
isinf
"
Rf
:
:
IsNan
=
>
"
isnan
"
Rf
:
:
IsNormal
=
>
"
!
isnan
"
Rf
:
:
All
=
>
"
all
"
Rf
:
:
Any
=
>
"
any
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
argument
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Math
{
fun
arg
arg1
arg2
}
=
>
{
use
crate
:
:
MathFunction
as
Mf
;
let
fun_name
=
match
fun
{
Mf
:
:
Abs
=
>
"
abs
"
Mf
:
:
Min
=
>
"
min
"
Mf
:
:
Max
=
>
"
max
"
Mf
:
:
Clamp
=
>
"
clamp
"
Mf
:
:
Cos
=
>
"
cos
"
Mf
:
:
Cosh
=
>
"
cosh
"
Mf
:
:
Sin
=
>
"
sin
"
Mf
:
:
Sinh
=
>
"
sinh
"
Mf
:
:
Tan
=
>
"
tan
"
Mf
:
:
Tanh
=
>
"
tanh
"
Mf
:
:
Acos
=
>
"
acos
"
Mf
:
:
Asin
=
>
"
asin
"
Mf
:
:
Atan
=
>
"
atan
"
Mf
:
:
Asinh
=
>
"
asinh
"
Mf
:
:
Acosh
=
>
"
acosh
"
Mf
:
:
Atanh
=
>
"
atanh
"
Mf
:
:
Atan2
=
>
"
atan
"
Mf
:
:
Ceil
=
>
"
ceil
"
Mf
:
:
Floor
=
>
"
floor
"
Mf
:
:
Round
=
>
"
roundEven
"
Mf
:
:
Fract
=
>
"
fract
"
Mf
:
:
Trunc
=
>
"
trunc
"
Mf
:
:
Modf
=
>
"
modf
"
Mf
:
:
Frexp
=
>
"
frexp
"
Mf
:
:
Ldexp
=
>
"
ldexp
"
Mf
:
:
Exp
=
>
"
exp
"
Mf
:
:
Exp2
=
>
"
exp2
"
Mf
:
:
Log
=
>
"
log
"
Mf
:
:
Log2
=
>
"
log2
"
Mf
:
:
Pow
=
>
"
pow
"
Mf
:
:
Dot
=
>
"
dot
"
Mf
:
:
Outer
=
>
"
outerProduct
"
Mf
:
:
Cross
=
>
"
cross
"
Mf
:
:
Distance
=
>
"
distance
"
Mf
:
:
Length
=
>
"
length
"
Mf
:
:
Normalize
=
>
"
normalize
"
Mf
:
:
FaceForward
=
>
"
faceforward
"
Mf
:
:
Reflect
=
>
"
reflect
"
Mf
:
:
Refract
=
>
"
refract
"
Mf
:
:
Sign
=
>
"
sign
"
Mf
:
:
Fma
=
>
"
fma
"
Mf
:
:
Mix
=
>
"
mix
"
Mf
:
:
Step
=
>
"
step
"
Mf
:
:
SmoothStep
=
>
"
smoothstep
"
Mf
:
:
Sqrt
=
>
"
sqrt
"
Mf
:
:
InverseSqrt
=
>
"
inversesqrt
"
Mf
:
:
Inverse
=
>
"
inverse
"
Mf
:
:
Transpose
=
>
"
transpose
"
Mf
:
:
Determinant
=
>
"
determinant
"
Mf
:
:
CountOneBits
=
>
"
bitCount
"
Mf
:
:
ReverseBits
=
>
"
bitfieldReverse
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
if
let
Some
(
arg
)
=
arg1
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
}
if
let
Some
(
arg
)
=
arg2
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
As
{
expr
kind
:
target_kind
convert
}
=
>
{
let
inner
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
match
convert
{
Some
(
width
)
=
>
{
let
scalar
=
glsl_scalar
(
target_kind
width
)
?
;
match
*
inner
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
{
write
!
(
self
.
out
"
{
}
vec
{
}
"
scalar
.
prefix
size
as
u8
)
?
}
_
=
>
write
!
(
self
.
out
"
{
}
"
scalar
.
full
)
?
}
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
None
=
>
{
use
crate
:
:
ScalarKind
as
Sk
;
let
source_kind
=
inner
.
scalar_kind
(
)
.
unwrap
(
)
;
let
conv_op
=
match
(
source_kind
target_kind
)
{
(
Sk
:
:
Float
Sk
:
:
Sint
)
=
>
"
floatBitsToInt
"
(
Sk
:
:
Float
Sk
:
:
Uint
)
=
>
"
floatBitsToUInt
"
(
Sk
:
:
Sint
Sk
:
:
Float
)
=
>
"
intBitsToFloat
"
(
Sk
:
:
Uint
Sk
:
:
Float
)
=
>
"
uintBitsToFloat
"
(
Sk
:
:
Uint
Sk
:
:
Sint
)
=
>
"
int
"
(
Sk
:
:
Sint
Sk
:
:
Uint
)
=
>
"
uint
"
(
Sk
:
:
Bool
Sk
:
:
Sint
)
=
>
"
int
"
(
Sk
:
:
Bool
Sk
:
:
Uint
)
=
>
"
uint
"
(
Sk
:
:
Bool
Sk
:
:
Float
)
=
>
"
float
"
(
Sk
:
:
Sint
Sk
:
:
Bool
)
=
>
"
bool
"
(
Sk
:
:
Uint
Sk
:
:
Bool
)
=
>
"
bool
"
(
Sk
:
:
Float
Sk
:
:
Bool
)
=
>
"
bool
"
(
Sk
:
:
Sint
Sk
:
:
Sint
)
=
>
"
"
(
Sk
:
:
Uint
Sk
:
:
Uint
)
=
>
"
"
(
Sk
:
:
Float
Sk
:
:
Float
)
=
>
"
"
(
Sk
:
:
Bool
Sk
:
:
Bool
)
=
>
"
"
}
;
write
!
(
self
.
out
"
{
}
"
conv_op
)
?
;
if
!
conv_op
.
is_empty
(
)
{
write
!
(
self
.
out
"
(
"
)
?
;
}
self
.
write_expr
(
expr
ctx
)
?
;
if
!
conv_op
.
is_empty
(
)
{
write
!
(
self
.
out
"
)
"
)
?
}
}
}
}
Expression
:
:
CallResult
(
_
)
|
Expression
:
:
AtomicResult
{
.
.
}
=
>
unreachable
!
(
)
Expression
:
:
ArrayLength
(
expr
)
=
>
{
write
!
(
self
.
out
"
uint
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
.
length
(
)
)
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_texture_coordinates
(
&
mut
self
coordinate
:
Handle
<
crate
:
:
Expression
>
array_index
:
Option
<
Handle
<
crate
:
:
Expression
>
>
dim
:
crate
:
:
ImageDimension
ctx
:
&
back
:
:
FunctionCtx
)
-
>
Result
<
(
)
Error
>
{
use
crate
:
:
ImageDimension
as
IDim
;
match
array_index
{
Some
(
layer_expr
)
=
>
{
let
tex_coord_type
=
match
dim
{
IDim
:
:
D1
=
>
"
ivec2
"
IDim
:
:
D2
=
>
"
ivec3
"
IDim
:
:
D3
=
>
"
ivec4
"
IDim
:
:
Cube
=
>
"
ivec4
"
}
;
write
!
(
self
.
out
"
{
}
(
"
tex_coord_type
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
layer_expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
None
=
>
{
self
.
write_expr
(
coordinate
ctx
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_named_expr
(
&
mut
self
handle
:
Handle
<
crate
:
:
Expression
>
name
:
String
ctx
:
&
back
:
:
FunctionCtx
)
-
>
BackendResult
{
match
ctx
.
info
[
handle
]
.
ty
{
proc
:
:
TypeResolution
:
:
Handle
(
ty_handle
)
=
>
match
self
.
module
.
types
[
ty_handle
]
.
inner
{
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty_handle
)
]
;
write
!
(
self
.
out
"
{
}
"
ty_name
)
?
;
}
_
=
>
{
self
.
write_type
(
ty_handle
)
?
;
}
}
proc
:
:
TypeResolution
:
:
Value
(
ref
inner
)
=
>
{
self
.
write_value_type
(
inner
)
?
;
}
}
let
base_ty_res
=
&
ctx
.
info
[
handle
]
.
ty
;
let
resolved
=
base_ty_res
.
inner_with
(
&
self
.
module
.
types
)
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
if
let
TypeInner
:
:
Array
{
size
.
.
}
=
*
resolved
{
self
.
write_array_size
(
size
)
?
;
}
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
handle
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
self
.
named_expressions
.
insert
(
handle
name
)
;
Ok
(
(
)
)
}
fn
write_zero_init_value
(
&
mut
self
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
BackendResult
{
let
inner
=
&
self
.
module
.
types
[
ty
]
.
inner
;
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
.
.
}
=
>
{
self
.
write_zero_init_scalar
(
kind
)
?
;
}
TypeInner
:
:
Vector
{
size
kind
.
.
}
=
>
{
self
.
write_value_type
(
inner
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
for
_
in
1
.
.
(
size
as
usize
)
{
self
.
write_zero_init_scalar
(
kind
)
?
;
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_zero_init_scalar
(
kind
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
TypeInner
:
:
Matrix
{
columns
rows
.
.
}
=
>
{
let
number_of_components
=
(
columns
as
usize
)
*
(
rows
as
usize
)
;
self
.
write_value_type
(
inner
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
for
_
in
1
.
.
number_of_components
{
self
.
write_zero_init_scalar
(
crate
:
:
ScalarKind
:
:
Float
)
?
;
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_zero_init_scalar
(
crate
:
:
ScalarKind
:
:
Float
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
_
=
>
{
}
}
Ok
(
(
)
)
}
fn
write_zero_init_scalar
(
&
mut
self
kind
:
crate
:
:
ScalarKind
)
-
>
BackendResult
{
match
kind
{
crate
:
:
ScalarKind
:
:
Bool
=
>
write
!
(
self
.
out
"
false
"
)
?
crate
:
:
ScalarKind
:
:
Uint
=
>
write
!
(
self
.
out
"
0u
"
)
?
crate
:
:
ScalarKind
:
:
Float
=
>
write
!
(
self
.
out
"
0
.
0
"
)
?
crate
:
:
ScalarKind
:
:
Sint
=
>
write
!
(
self
.
out
"
0
"
)
?
}
Ok
(
(
)
)
}
fn
write_storage_access
(
&
mut
self
storage_access
:
crate
:
:
StorageAccess
)
-
>
BackendResult
{
if
!
storage_access
.
contains
(
crate
:
:
StorageAccess
:
:
STORE
)
{
write
!
(
self
.
out
"
readonly
"
)
?
;
}
if
!
storage_access
.
contains
(
crate
:
:
StorageAccess
:
:
LOAD
)
{
write
!
(
self
.
out
"
writeonly
"
)
?
;
}
Ok
(
(
)
)
}
fn
collect_reflection_info
(
&
self
)
-
>
Result
<
ReflectionInfo
Error
>
{
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
let
info
=
self
.
info
.
get_entry_point
(
self
.
entry_point_idx
as
usize
)
;
let
mut
mappings
=
crate
:
:
FastHashMap
:
:
default
(
)
;
let
mut
uniforms
=
crate
:
:
FastHashMap
:
:
default
(
)
;
for
sampling
in
info
.
sampling_set
.
iter
(
)
{
let
tex_name
=
self
.
reflection_names_globals
[
&
sampling
.
image
]
.
clone
(
)
;
match
mappings
.
entry
(
tex_name
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
v
.
insert
(
TextureMapping
{
texture
:
sampling
.
image
sampler
:
Some
(
sampling
.
sampler
)
}
)
;
}
Entry
:
:
Occupied
(
e
)
=
>
{
if
e
.
get
(
)
.
sampler
!
=
Some
(
sampling
.
sampler
)
{
log
:
:
error
!
(
"
Conflicting
samplers
for
{
}
"
e
.
key
(
)
)
;
return
Err
(
Error
:
:
ImageMultipleSamplers
)
;
}
}
}
}
for
(
handle
var
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
info
[
handle
]
.
is_empty
(
)
{
continue
;
}
match
self
.
module
.
types
[
var
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
.
.
}
=
>
match
var
.
class
{
crate
:
:
StorageClass
:
:
Uniform
|
crate
:
:
StorageClass
:
:
Storage
{
.
.
}
=
>
{
let
name
=
self
.
reflection_names_uniforms
[
&
var
.
ty
]
.
clone
(
)
;
uniforms
.
insert
(
handle
name
)
;
}
_
=
>
(
)
}
_
=
>
continue
}
}
Ok
(
ReflectionInfo
{
texture_mapping
:
mappings
uniforms
}
)
}
}
struct
ScalarString
<
'
a
>
{
prefix
:
&
'
a
str
full
:
&
'
a
str
}
fn
glsl_scalar
(
kind
:
crate
:
:
ScalarKind
width
:
crate
:
:
Bytes
)
-
>
Result
<
ScalarString
<
'
static
>
Error
>
{
use
crate
:
:
ScalarKind
as
Sk
;
Ok
(
match
kind
{
Sk
:
:
Sint
=
>
ScalarString
{
prefix
:
"
i
"
full
:
"
int
"
}
Sk
:
:
Uint
=
>
ScalarString
{
prefix
:
"
u
"
full
:
"
uint
"
}
Sk
:
:
Float
=
>
match
width
{
4
=
>
ScalarString
{
prefix
:
"
"
full
:
"
float
"
}
8
=
>
ScalarString
{
prefix
:
"
d
"
full
:
"
double
"
}
_
=
>
return
Err
(
Error
:
:
UnsupportedScalar
(
kind
width
)
)
}
Sk
:
:
Bool
=
>
ScalarString
{
prefix
:
"
b
"
full
:
"
bool
"
}
}
)
}
fn
glsl_built_in
(
built_in
:
crate
:
:
BuiltIn
output
:
bool
)
-
>
&
'
static
str
{
use
crate
:
:
BuiltIn
as
Bi
;
match
built_in
{
Bi
:
:
Position
=
>
{
if
output
{
"
gl_Position
"
}
else
{
"
gl_FragCoord
"
}
}
Bi
:
:
BaseInstance
=
>
"
uint
(
gl_BaseInstance
)
"
Bi
:
:
BaseVertex
=
>
"
uint
(
gl_BaseVertex
)
"
Bi
:
:
ClipDistance
=
>
"
gl_ClipDistance
"
Bi
:
:
CullDistance
=
>
"
gl_CullDistance
"
Bi
:
:
InstanceIndex
=
>
"
uint
(
gl_InstanceID
)
"
Bi
:
:
PointSize
=
>
"
gl_PointSize
"
Bi
:
:
VertexIndex
=
>
"
uint
(
gl_VertexID
)
"
Bi
:
:
FragDepth
=
>
"
gl_FragDepth
"
Bi
:
:
FrontFacing
=
>
"
gl_FrontFacing
"
Bi
:
:
PrimitiveIndex
=
>
"
uint
(
gl_PrimitiveID
)
"
Bi
:
:
SampleIndex
=
>
"
gl_SampleID
"
Bi
:
:
SampleMask
=
>
{
if
output
{
"
gl_SampleMask
"
}
else
{
"
gl_SampleMaskIn
"
}
}
Bi
:
:
GlobalInvocationId
=
>
"
gl_GlobalInvocationID
"
Bi
:
:
LocalInvocationId
=
>
"
gl_LocalInvocationID
"
Bi
:
:
LocalInvocationIndex
=
>
"
gl_LocalInvocationIndex
"
Bi
:
:
WorkGroupId
=
>
"
gl_WorkGroupID
"
Bi
:
:
WorkGroupSize
=
>
"
gl_WorkGroupSize
"
Bi
:
:
NumWorkGroups
=
>
"
gl_NumWorkGroups
"
}
}
fn
glsl_storage_class
(
class
:
crate
:
:
StorageClass
)
-
>
Option
<
&
'
static
str
>
{
use
crate
:
:
StorageClass
as
Sc
;
match
class
{
Sc
:
:
Function
=
>
None
Sc
:
:
Private
=
>
None
Sc
:
:
Storage
{
.
.
}
=
>
Some
(
"
buffer
"
)
Sc
:
:
Uniform
=
>
Some
(
"
uniform
"
)
Sc
:
:
Handle
=
>
Some
(
"
uniform
"
)
Sc
:
:
WorkGroup
=
>
Some
(
"
shared
"
)
Sc
:
:
PushConstant
=
>
None
}
}
fn
glsl_interpolation
(
interpolation
:
crate
:
:
Interpolation
)
-
>
&
'
static
str
{
use
crate
:
:
Interpolation
as
I
;
match
interpolation
{
I
:
:
Perspective
=
>
"
smooth
"
I
:
:
Linear
=
>
"
noperspective
"
I
:
:
Flat
=
>
"
flat
"
}
}
fn
glsl_sampling
(
sampling
:
crate
:
:
Sampling
)
-
>
Option
<
&
'
static
str
>
{
use
crate
:
:
Sampling
as
S
;
match
sampling
{
S
:
:
Center
=
>
None
S
:
:
Centroid
=
>
Some
(
"
centroid
"
)
S
:
:
Sample
=
>
Some
(
"
sample
"
)
}
}
fn
glsl_dimension
(
dim
:
crate
:
:
ImageDimension
)
-
>
&
'
static
str
{
use
crate
:
:
ImageDimension
as
IDim
;
match
dim
{
IDim
:
:
D1
=
>
"
1D
"
IDim
:
:
D2
=
>
"
2D
"
IDim
:
:
D3
=
>
"
3D
"
IDim
:
:
Cube
=
>
"
Cube
"
}
}
fn
glsl_storage_format
(
format
:
crate
:
:
StorageFormat
)
-
>
&
'
static
str
{
use
crate
:
:
StorageFormat
as
Sf
;
match
format
{
Sf
:
:
R8Unorm
=
>
"
r8
"
Sf
:
:
R8Snorm
=
>
"
r8_snorm
"
Sf
:
:
R8Uint
=
>
"
r8ui
"
Sf
:
:
R8Sint
=
>
"
r8i
"
Sf
:
:
R16Uint
=
>
"
r16ui
"
Sf
:
:
R16Sint
=
>
"
r16i
"
Sf
:
:
R16Float
=
>
"
r16f
"
Sf
:
:
Rg8Unorm
=
>
"
rg8
"
Sf
:
:
Rg8Snorm
=
>
"
rg8_snorm
"
Sf
:
:
Rg8Uint
=
>
"
rg8ui
"
Sf
:
:
Rg8Sint
=
>
"
rg8i
"
Sf
:
:
R32Uint
=
>
"
r32ui
"
Sf
:
:
R32Sint
=
>
"
r32i
"
Sf
:
:
R32Float
=
>
"
r32f
"
Sf
:
:
Rg16Uint
=
>
"
rg16ui
"
Sf
:
:
Rg16Sint
=
>
"
rg16i
"
Sf
:
:
Rg16Float
=
>
"
rg16f
"
Sf
:
:
Rgba8Unorm
=
>
"
rgba8ui
"
Sf
:
:
Rgba8Snorm
=
>
"
rgba8_snorm
"
Sf
:
:
Rgba8Uint
=
>
"
rgba8ui
"
Sf
:
:
Rgba8Sint
=
>
"
rgba8i
"
Sf
:
:
Rgb10a2Unorm
=
>
"
rgb10_a2ui
"
Sf
:
:
Rg11b10Float
=
>
"
r11f_g11f_b10f
"
Sf
:
:
Rg32Uint
=
>
"
rg32ui
"
Sf
:
:
Rg32Sint
=
>
"
rg32i
"
Sf
:
:
Rg32Float
=
>
"
rg32f
"
Sf
:
:
Rgba16Uint
=
>
"
rgba16ui
"
Sf
:
:
Rgba16Sint
=
>
"
rgba16i
"
Sf
:
:
Rgba16Float
=
>
"
rgba16f
"
Sf
:
:
Rgba32Uint
=
>
"
rgba32ui
"
Sf
:
:
Rgba32Sint
=
>
"
rgba32i
"
Sf
:
:
Rgba32Float
=
>
"
rgba32f
"
}
}
fn
is_value_init_supported
(
module
:
&
crate
:
:
Module
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
bool
{
match
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Scalar
{
.
.
}
|
TypeInner
:
:
Vector
{
.
.
}
|
TypeInner
:
:
Matrix
{
.
.
}
=
>
true
_
=
>
false
}
}
