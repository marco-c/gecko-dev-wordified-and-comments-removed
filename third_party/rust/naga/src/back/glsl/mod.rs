pub
use
features
:
:
Features
;
use
crate
:
:
{
proc
:
:
{
analyzer
:
:
Analysis
NameKey
Namer
ResolveContext
Typifier
TypifyError
}
Arena
ArraySize
BinaryOperator
Binding
BuiltIn
Bytes
ConservativeDepth
Constant
ConstantInner
DerivativeAxis
Expression
FastHashMap
Function
GlobalVariable
Handle
ImageClass
Interpolation
LocalVariable
Module
RelationalFunction
ScalarKind
ScalarValue
ShaderStage
Statement
StorageAccess
StorageClass
StorageFormat
StructMember
Type
TypeInner
UnaryOperator
}
;
use
features
:
:
FeaturesManager
;
use
std
:
:
{
cmp
:
:
Ordering
fmt
io
:
:
{
Error
as
IoError
Write
}
}
;
use
thiserror
:
:
Error
;
mod
features
;
mod
keywords
;
pub
const
SUPPORTED_CORE_VERSIONS
:
&
[
u16
]
=
&
[
330
400
410
420
430
440
450
]
;
pub
const
SUPPORTED_ES_VERSIONS
:
&
[
u16
]
=
&
[
300
310
320
]
;
const
INDENT
:
&
str
=
"
"
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
Version
{
Desktop
(
u16
)
Embedded
(
u16
)
}
impl
Version
{
fn
is_es
(
&
self
)
-
>
bool
{
match
self
{
Version
:
:
Desktop
(
_
)
=
>
false
Version
:
:
Embedded
(
_
)
=
>
true
}
}
fn
is_supported
(
&
self
)
-
>
bool
{
match
self
{
Version
:
:
Desktop
(
v
)
=
>
SUPPORTED_CORE_VERSIONS
.
contains
(
v
)
Version
:
:
Embedded
(
v
)
=
>
SUPPORTED_ES_VERSIONS
.
contains
(
v
)
}
}
}
impl
PartialOrd
for
Version
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
match
(
*
self
*
other
)
{
(
Version
:
:
Desktop
(
x
)
Version
:
:
Desktop
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
(
Version
:
:
Embedded
(
x
)
Version
:
:
Embedded
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
_
=
>
None
}
}
}
impl
fmt
:
:
Display
for
Version
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Version
:
:
Desktop
(
v
)
=
>
write
!
(
f
"
{
}
core
"
v
)
Version
:
:
Embedded
(
v
)
=
>
write
!
(
f
"
{
}
es
"
v
)
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Options
{
pub
version
:
Version
pub
shader_stage
:
ShaderStage
pub
entry_point
:
String
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TextureMapping
{
pub
texture
:
Handle
<
GlobalVariable
>
pub
sampler
:
Option
<
Handle
<
GlobalVariable
>
>
}
enum
FunctionType
{
Function
(
Handle
<
Function
>
)
EntryPoint
(
crate
:
:
proc
:
:
EntryPointIndex
)
}
struct
FunctionCtx
<
'
a
'
b
>
{
func
:
FunctionType
expressions
:
&
'
a
Arena
<
Expression
>
typifier
:
&
'
b
Typifier
}
impl
<
'
a
'
b
>
FunctionCtx
<
'
a
'
b
>
{
fn
name_key
(
&
self
local
:
Handle
<
LocalVariable
>
)
-
>
NameKey
{
match
self
.
func
{
FunctionType
:
:
Function
(
handle
)
=
>
NameKey
:
:
FunctionLocal
(
handle
local
)
FunctionType
:
:
EntryPoint
(
idx
)
=
>
NameKey
:
:
EntryPointLocal
(
idx
local
)
}
}
fn
get_arg
<
'
c
>
(
&
self
arg
:
u32
names
:
&
'
c
FastHashMap
<
NameKey
String
>
)
-
>
&
'
c
str
{
match
self
.
func
{
FunctionType
:
:
Function
(
handle
)
=
>
&
names
[
&
NameKey
:
:
FunctionArgument
(
handle
arg
)
]
FunctionType
:
:
EntryPoint
(
_
)
=
>
unreachable
!
(
)
}
}
}
#
[
derive
(
Default
)
]
struct
IdGenerator
(
u32
)
;
impl
IdGenerator
{
fn
generate
(
&
mut
self
)
-
>
u32
{
let
ret
=
self
.
0
;
self
.
0
+
=
1
;
ret
}
}
type
BackendResult
=
Result
<
(
)
Error
>
;
#
[
derive
(
Debug
Error
)
]
pub
enum
Error
{
#
[
error
(
"
I
/
O
error
"
)
]
IoError
(
#
[
from
]
IoError
)
#
[
error
(
"
Type
error
"
)
]
Type
(
#
[
from
]
TypifyError
)
#
[
error
(
"
The
selected
version
doesn
'
t
support
{
0
:
?
}
"
)
]
MissingFeatures
(
Features
)
#
[
error
(
"
Push
constants
aren
'
t
supported
"
)
]
PushConstantNotSupported
#
[
error
(
"
The
specified
version
isn
'
t
supported
"
)
]
VersionNotSupported
#
[
error
(
"
The
requested
entry
point
couldn
'
t
be
found
"
)
]
EntryPointNotFound
#
[
error
(
"
A
call
was
made
to
an
unsupported
external
:
{
0
}
"
)
]
UnsupportedExternal
(
String
)
#
[
error
(
"
A
scalar
with
an
unsupported
width
was
requested
:
{
0
:
?
}
{
1
:
?
}
"
)
]
UnsupportedScalar
(
ScalarKind
Bytes
)
#
[
error
(
"
Patch
interpolation
isn
'
t
supported
"
)
]
PatchInterpolationNotSupported
#
[
error
(
"
A
image
was
used
with
multiple
samplers
"
)
]
ImageMultipleSamplers
#
[
error
(
"
{
0
}
"
)
]
Custom
(
String
)
}
pub
struct
Writer
<
'
a
W
>
{
module
:
&
'
a
Module
analysis
:
&
'
a
Analysis
out
:
W
options
:
&
'
a
Options
features
:
FeaturesManager
names
:
FastHashMap
<
NameKey
String
>
entry_point
:
&
'
a
crate
:
:
EntryPoint
entry_point_idx
:
crate
:
:
proc
:
:
EntryPointIndex
block_id
:
IdGenerator
}
impl
<
'
a
W
:
Write
>
Writer
<
'
a
W
>
{
pub
fn
new
(
out
:
W
module
:
&
'
a
Module
analysis
:
&
'
a
Analysis
options
:
&
'
a
Options
)
-
>
Result
<
Self
Error
>
{
if
!
options
.
version
.
is_supported
(
)
{
log
:
:
error
!
(
"
Version
{
}
"
options
.
version
)
;
return
Err
(
Error
:
:
VersionNotSupported
)
;
}
let
(
ep_idx
(
_
ep
)
)
=
module
.
entry_points
.
iter
(
)
.
enumerate
(
)
.
find
(
|
(
_
(
(
stage
name
)
_
)
)
|
{
options
.
shader_stage
=
=
*
stage
&
&
&
options
.
entry_point
=
=
name
}
)
.
ok_or
(
Error
:
:
EntryPointNotFound
)
?
;
let
mut
names
=
FastHashMap
:
:
default
(
)
;
Namer
:
:
default
(
)
.
reset
(
module
keywords
:
:
RESERVED_KEYWORDS
&
mut
names
)
;
let
mut
this
=
Self
{
module
analysis
out
options
features
:
FeaturesManager
:
:
new
(
)
names
entry_point
:
ep
entry_point_idx
:
ep_idx
as
u16
block_id
:
IdGenerator
:
:
default
(
)
}
;
this
.
collect_required_features
(
)
?
;
Ok
(
this
)
}
pub
fn
write
(
&
mut
self
)
-
>
Result
<
FastHashMap
<
String
TextureMapping
>
Error
>
{
let
es
=
self
.
options
.
version
.
is_es
(
)
;
writeln
!
(
self
.
out
"
#
version
{
}
"
self
.
options
.
version
)
?
;
self
.
features
.
write
(
self
.
options
.
version
&
mut
self
.
out
)
?
;
if
es
{
writeln
!
(
self
.
out
)
?
;
writeln
!
(
self
.
out
"
precision
highp
float
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
let
Some
(
depth_test
)
=
self
.
entry_point
.
early_depth_test
{
writeln
!
(
self
.
out
"
layout
(
early_fragment_tests
)
in
;
"
)
?
;
if
let
Some
(
conservative
)
=
depth_test
.
conservative
{
writeln
!
(
self
.
out
"
layout
(
depth_
{
}
)
out
float
gl_FragDepth
;
"
match
conservative
{
ConservativeDepth
:
:
GreaterEqual
=
>
"
greater
"
ConservativeDepth
:
:
LessEqual
=
>
"
less
"
ConservativeDepth
:
:
Unchanged
=
>
"
unchanged
"
}
)
?
;
}
writeln
!
(
self
.
out
)
?
;
}
for
(
handle
ty
)
in
self
.
module
.
types
.
iter
(
)
{
if
let
TypeInner
:
:
Struct
{
block
:
_
ref
members
}
=
ty
.
inner
{
self
.
write_struct
(
handle
members
)
?
}
}
let
ep_info
=
self
.
analysis
.
get_entry_point
(
self
.
options
.
shader_stage
&
self
.
options
.
entry_point
)
;
for
(
handle
global
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
ep_info
[
handle
]
.
is_empty
(
)
{
continue
;
}
if
let
Some
(
crate
:
:
Binding
:
:
BuiltIn
(
_
)
)
=
global
.
binding
{
continue
;
}
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
if
let
TypeInner
:
:
Image
{
class
:
ImageClass
:
:
Storage
(
format
)
.
.
}
=
self
.
module
.
types
[
global
.
ty
]
.
inner
{
write
!
(
self
.
out
"
layout
(
{
}
)
"
glsl_storage_format
(
format
)
)
?
;
}
if
global
.
storage_access
=
=
StorageAccess
:
:
LOAD
{
write
!
(
self
.
out
"
readonly
"
)
?
;
}
else
if
global
.
storage_access
=
=
StorageAccess
:
:
STORE
{
write
!
(
self
.
out
"
writeonly
"
)
?
;
}
write
!
(
self
.
out
"
uniform
"
)
?
;
self
.
write_image_type
(
dim
arrayed
class
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
self
.
get_global_name
(
handle
global
)
)
?
;
writeln
!
(
self
.
out
)
?
;
}
TypeInner
:
:
Sampler
{
.
.
}
=
>
continue
_
=
>
self
.
write_global
(
handle
global
)
?
}
}
for
(
handle
function
)
in
self
.
module
.
functions
.
iter
(
)
{
if
!
ep_info
.
dominates_global_use
(
&
self
.
analysis
[
handle
]
)
{
continue
;
}
let
name
=
self
.
names
[
&
NameKey
:
:
Function
(
handle
)
]
.
clone
(
)
;
self
.
write_function
(
FunctionType
:
:
Function
(
handle
)
function
name
)
?
;
writeln
!
(
self
.
out
)
?
;
}
self
.
write_function
(
FunctionType
:
:
EntryPoint
(
self
.
entry_point_idx
)
&
self
.
entry_point
.
function
"
main
"
)
?
;
self
.
collect_texture_mapping
(
)
}
fn
write_type
(
&
mut
self
ty
:
Handle
<
Type
>
)
-
>
BackendResult
{
match
self
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Scalar
{
kind
width
}
=
>
{
write
!
(
self
.
out
"
{
}
"
glsl_scalar
(
kind
width
)
?
.
full
)
?
}
TypeInner
:
:
Vector
{
size
kind
width
}
=
>
write
!
(
self
.
out
"
{
}
vec
{
}
"
glsl_scalar
(
kind
width
)
?
.
prefix
size
as
u8
)
?
TypeInner
:
:
Matrix
{
columns
rows
width
}
=
>
write
!
(
self
.
out
"
{
}
mat
{
}
x
{
}
"
glsl_scalar
(
ScalarKind
:
:
Float
width
)
?
.
prefix
columns
as
u8
rows
as
u8
)
?
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
self
.
write_type
(
base
)
?
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
{
self
.
write_type
(
base
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
match
size
{
ArraySize
:
:
Constant
(
const_handle
)
=
>
{
match
self
.
module
.
constants
[
const_handle
]
.
inner
{
ConstantInner
:
:
Scalar
{
width
:
_
value
:
ScalarValue
:
:
Uint
(
size
)
}
=
>
write
!
(
self
.
out
"
{
}
"
size
)
?
_
=
>
unreachable
!
(
)
}
}
ArraySize
:
:
Dynamic
=
>
(
)
}
write
!
(
self
.
out
"
]
"
)
?
}
TypeInner
:
:
Struct
{
block
ref
members
}
=
>
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
;
if
block
{
writeln
!
(
self
.
out
"
{
}
_block_
{
}
{
{
"
name
self
.
block_id
.
generate
(
)
)
?
;
for
(
idx
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
INDENT
)
?
;
self
.
write_type
(
member
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
idx
as
u32
)
]
)
?
;
}
write
!
(
self
.
out
"
}
}
"
)
?
}
else
{
write
!
(
self
.
out
"
{
}
"
name
)
?
}
}
TypeInner
:
:
Image
{
.
.
}
|
TypeInner
:
:
Sampler
{
.
.
}
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_image_type
(
&
mut
self
dim
:
crate
:
:
ImageDimension
arrayed
:
bool
class
:
ImageClass
)
-
>
BackendResult
{
let
(
base
kind
ms
comparison
)
=
match
class
{
ImageClass
:
:
Sampled
{
kind
multi
:
true
}
=
>
(
"
sampler
"
kind
"
MS
"
"
"
)
ImageClass
:
:
Sampled
{
kind
multi
:
false
}
=
>
(
"
sampler
"
kind
"
"
"
"
)
ImageClass
:
:
Depth
=
>
(
"
sampler
"
crate
:
:
ScalarKind
:
:
Float
"
"
"
Shadow
"
)
ImageClass
:
:
Storage
(
format
)
=
>
(
"
image
"
format
.
into
(
)
"
"
"
"
)
}
;
write
!
(
self
.
out
"
{
}
{
}
{
}
{
}
{
}
{
}
"
glsl_scalar
(
kind
4
)
?
.
prefix
base
glsl_dimension
(
dim
)
ms
if
arrayed
{
"
Array
"
}
else
{
"
"
}
comparison
)
?
;
Ok
(
(
)
)
}
fn
write_global
(
&
mut
self
handle
:
Handle
<
GlobalVariable
>
global
:
&
GlobalVariable
)
-
>
BackendResult
{
if
global
.
storage_access
=
=
StorageAccess
:
:
LOAD
{
write
!
(
self
.
out
"
readonly
"
)
?
;
}
else
if
global
.
storage_access
=
=
StorageAccess
:
:
STORE
{
write
!
(
self
.
out
"
writeonly
"
)
?
;
}
if
let
Some
(
interpolation
)
=
global
.
interpolation
{
match
(
self
.
options
.
shader_stage
global
.
class
)
{
(
ShaderStage
:
:
Fragment
StorageClass
:
:
Input
)
|
(
ShaderStage
:
:
Vertex
StorageClass
:
:
Output
)
=
>
{
write
!
(
self
.
out
"
{
}
"
glsl_interpolation
(
interpolation
)
?
)
?
;
}
_
=
>
(
)
}
;
}
write
!
(
self
.
out
"
{
}
"
glsl_storage_class
(
global
.
class
)
)
?
;
self
.
write_type
(
global
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
self
.
get_global_name
(
handle
global
)
)
?
;
writeln
!
(
self
.
out
)
?
;
Ok
(
(
)
)
}
fn
get_global_name
(
&
self
handle
:
Handle
<
GlobalVariable
>
global
:
&
GlobalVariable
)
-
>
String
{
match
global
.
binding
{
Some
(
Binding
:
:
Location
(
location
)
)
=
>
{
format
!
(
"
_location_
{
}
{
}
"
location
match
(
self
.
options
.
shader_stage
global
.
class
)
{
(
ShaderStage
:
:
Fragment
StorageClass
:
:
Input
)
=
>
"
_vs
"
(
ShaderStage
:
:
Vertex
StorageClass
:
:
Output
)
=
>
"
_vs
"
_
=
>
"
"
}
)
}
Some
(
Binding
:
:
Resource
{
group
binding
}
)
=
>
{
format
!
(
"
_group_
{
}
_binding_
{
}
"
group
binding
)
}
Some
(
Binding
:
:
BuiltIn
(
built_in
)
)
=
>
glsl_built_in
(
built_in
)
.
to_string
(
)
None
=
>
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
.
clone
(
)
}
}
fn
write_function
<
N
:
AsRef
<
str
>
>
(
&
mut
self
ty
:
FunctionType
func
:
&
Function
name
:
N
)
-
>
BackendResult
{
let
mut
typifier
=
Typifier
:
:
new
(
)
;
typifier
.
resolve_all
(
&
func
.
expressions
&
self
.
module
.
types
&
ResolveContext
{
constants
:
&
self
.
module
.
constants
global_vars
:
&
self
.
module
.
global_variables
local_vars
:
&
func
.
local_variables
functions
:
&
self
.
module
.
functions
arguments
:
&
func
.
arguments
}
)
?
;
let
ctx
=
FunctionCtx
{
func
:
ty
expressions
:
&
func
.
expressions
typifier
:
&
typifier
}
;
if
let
Some
(
ty
)
=
func
.
return_type
{
self
.
write_type
(
ty
)
?
;
}
else
{
write
!
(
self
.
out
"
void
"
)
?
;
}
write
!
(
self
.
out
"
{
}
(
"
name
.
as_ref
(
)
)
?
;
self
.
write_slice
(
&
func
.
arguments
|
this
i
arg
|
{
this
.
write_type
(
arg
.
ty
)
?
;
write
!
(
this
.
out
"
{
}
"
ctx
.
get_arg
(
i
&
this
.
names
)
)
?
;
Ok
(
(
)
)
}
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
(
handle
local
)
in
func
.
local_variables
.
iter
(
)
{
write
!
(
self
.
out
"
{
}
"
INDENT
)
?
;
self
.
write_type
(
local
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
;
if
let
Some
(
init
)
=
local
.
init
{
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_constant
(
&
self
.
module
.
constants
[
init
]
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
}
for
sta
in
func
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
&
ctx
1
)
?
;
}
writeln
!
(
self
.
out
"
}
}
"
)
?
;
Ok
(
(
)
)
}
fn
write_slice
<
T
F
:
FnMut
(
&
mut
Self
u32
&
T
)
-
>
BackendResult
>
(
&
mut
self
data
:
&
[
T
]
mut
f
:
F
)
-
>
BackendResult
{
for
(
i
item
)
in
data
.
iter
(
)
.
enumerate
(
)
{
f
(
self
i
as
u32
item
)
?
;
if
i
!
=
data
.
len
(
)
.
saturating_sub
(
1
)
{
write
!
(
self
.
out
"
"
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_constant
(
&
mut
self
constant
:
&
Constant
)
-
>
BackendResult
{
match
constant
.
inner
{
ConstantInner
:
:
Scalar
{
width
:
_
ref
value
}
=
>
match
*
value
{
ScalarValue
:
:
Sint
(
int
)
=
>
write
!
(
self
.
out
"
{
}
"
int
)
?
ScalarValue
:
:
Uint
(
int
)
=
>
write
!
(
self
.
out
"
{
}
u
"
int
)
?
ScalarValue
:
:
Float
(
float
)
=
>
write
!
(
self
.
out
"
{
:
?
}
"
float
)
?
ScalarValue
:
:
Bool
(
boolean
)
=
>
write
!
(
self
.
out
"
{
}
"
boolean
)
?
}
ConstantInner
:
:
Composite
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_slice
(
components
|
this
_
arg
|
{
this
.
write_constant
(
&
this
.
module
.
constants
[
*
arg
]
)
}
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_struct
(
&
mut
self
handle
:
Handle
<
Type
>
members
:
&
[
StructMember
]
)
-
>
BackendResult
{
writeln
!
(
self
.
out
"
struct
{
}
{
{
"
self
.
names
[
&
NameKey
:
:
Type
(
handle
)
]
)
?
;
for
(
idx
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
INDENT
)
?
;
self
.
write_type
(
member
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
}
writeln
!
(
self
.
out
"
}
}
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
Ok
(
(
)
)
}
fn
write_stmt
(
&
mut
self
sta
:
&
Statement
ctx
:
&
FunctionCtx
<
'
_
'
_
>
indent
:
usize
)
-
>
BackendResult
{
write
!
(
self
.
out
"
{
}
"
INDENT
.
repeat
(
indent
)
)
?
;
match
*
sta
{
Statement
:
:
Block
(
ref
block
)
=
>
{
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
sta
in
block
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
If
{
condition
ref
accept
ref
reject
}
=
>
{
write
!
(
self
.
out
"
if
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
sta
in
accept
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
;
}
if
!
reject
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
}
}
else
{
{
"
INDENT
.
repeat
(
indent
)
)
?
;
for
sta
in
reject
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
Switch
{
selector
ref
cases
ref
default
}
=
>
{
write
!
(
self
.
out
"
switch
(
"
)
?
;
self
.
write_expr
(
selector
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
case
in
cases
{
writeln
!
(
self
.
out
"
{
}
case
{
}
:
"
INDENT
.
repeat
(
indent
+
1
)
case
.
value
)
?
;
for
sta
in
case
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
indent
+
2
)
?
;
}
if
case
.
fall_through
{
writeln
!
(
self
.
out
"
{
}
break
;
"
INDENT
.
repeat
(
indent
+
2
)
)
?
;
}
}
if
!
default
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
default
:
"
INDENT
.
repeat
(
indent
+
1
)
)
?
;
for
sta
in
default
{
self
.
write_stmt
(
sta
ctx
indent
+
2
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
Loop
{
ref
body
ref
continuing
}
=
>
{
writeln
!
(
self
.
out
"
while
(
true
)
{
{
"
)
?
;
for
sta
in
body
.
iter
(
)
.
chain
(
continuing
.
iter
(
)
)
{
self
.
write_stmt
(
sta
ctx
indent
+
1
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
INDENT
.
repeat
(
indent
)
)
?
}
Statement
:
:
Break
=
>
writeln
!
(
self
.
out
"
break
;
"
)
?
Statement
:
:
Continue
=
>
writeln
!
(
self
.
out
"
continue
;
"
)
?
Statement
:
:
Return
{
value
}
=
>
{
write
!
(
self
.
out
"
return
"
)
?
;
if
let
Some
(
expr
)
=
value
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
;
}
Statement
:
:
Kill
=
>
writeln
!
(
self
.
out
"
discard
;
"
)
?
Statement
:
:
Store
{
pointer
value
}
=
>
{
self
.
write_expr
(
pointer
ctx
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
}
Statement
:
:
ImageStore
{
image
coordinate
array_index
value
}
=
>
{
let
dim
=
match
*
ctx
.
typifier
.
get
(
image
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
.
.
}
=
>
dim
_
=
>
unreachable
!
(
)
}
;
write
!
(
self
.
out
"
imageStore
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
coordinate
array_index
dim
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
Statement
:
:
Call
{
function
ref
arguments
}
=
>
{
write
!
(
self
.
out
"
{
}
(
"
&
self
.
names
[
&
NameKey
:
:
Function
(
function
)
]
)
?
;
self
.
write_slice
(
arguments
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_expr
(
&
mut
self
expr
:
Handle
<
Expression
>
ctx
:
&
FunctionCtx
<
'
_
'
_
>
)
-
>
BackendResult
{
match
ctx
.
expressions
[
expr
]
{
Expression
:
:
Access
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
self
.
write_expr
(
index
ctx
)
?
;
write
!
(
self
.
out
"
]
"
)
?
}
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
match
*
ctx
.
typifier
.
get
(
base
&
self
.
module
.
types
)
{
TypeInner
:
:
Vector
{
.
.
}
|
TypeInner
:
:
Matrix
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
=
>
write
!
(
self
.
out
"
[
{
}
]
"
index
)
?
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty
=
ctx
.
typifier
.
get_handle
(
base
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
.
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
index
)
]
)
?
}
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
index
{
:
?
}
"
other
)
)
)
}
}
Expression
:
:
Constant
(
constant
)
=
>
{
self
.
write_constant
(
&
self
.
module
.
constants
[
constant
]
)
?
}
Expression
:
:
Compose
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_slice
(
components
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
FunctionArgument
(
pos
)
=
>
{
write
!
(
self
.
out
"
{
}
"
ctx
.
get_arg
(
pos
&
self
.
names
)
)
?
}
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
global
=
&
self
.
module
.
global_variables
[
handle
]
;
write
!
(
self
.
out
"
{
}
"
self
.
get_global_name
(
handle
global
)
)
?
}
Expression
:
:
LocalVariable
(
handle
)
=
>
{
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
}
Expression
:
:
Load
{
pointer
}
=
>
self
.
write_expr
(
pointer
ctx
)
?
Expression
:
:
ImageSample
{
image
sampler
:
_
coordinate
array_index
offset
:
_
level
depth_ref
}
=
>
{
let
fun_name
=
match
level
{
crate
:
:
SampleLevel
:
:
Auto
|
crate
:
:
SampleLevel
:
:
Bias
(
_
)
=
>
"
texture
"
crate
:
:
SampleLevel
:
:
Zero
|
crate
:
:
SampleLevel
:
:
Exact
(
_
)
=
>
"
textureLod
"
crate
:
:
SampleLevel
:
:
Gradient
{
.
.
}
=
>
"
textureGrad
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
let
size
=
match
*
ctx
.
typifier
.
get
(
coordinate
&
self
.
module
.
types
)
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
size
_
=
>
unreachable
!
(
)
}
;
let
mut
coord_dim
=
size
as
u8
;
if
array_index
.
is_some
(
)
{
coord_dim
+
=
1
;
}
if
depth_ref
.
is_some
(
)
{
coord_dim
+
=
1
;
}
write
!
(
self
.
out
"
vec
{
}
(
"
coord_dim
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
if
let
Some
(
expr
)
=
array_index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
if
let
Some
(
expr
)
=
depth_ref
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
match
level
{
crate
:
:
SampleLevel
:
:
Auto
=
>
(
)
crate
:
:
SampleLevel
:
:
Zero
=
>
write
!
(
self
.
out
"
0
"
)
?
crate
:
:
SampleLevel
:
:
Exact
(
expr
)
|
crate
:
:
SampleLevel
:
:
Bias
(
expr
)
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
crate
:
:
SampleLevel
:
:
Gradient
{
x
y
}
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
x
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
y
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
ImageLoad
{
image
coordinate
array_index
index
}
=
>
{
let
(
dim
class
)
=
match
*
ctx
.
typifier
.
get
(
image
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
=
>
"
texelFetch
"
ImageClass
:
:
Storage
(
_
)
=
>
"
imageLoad
"
ImageClass
:
:
Depth
=
>
todo
!
(
)
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
coordinate
array_index
dim
ctx
)
?
;
if
let
Some
(
index_expr
)
=
index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
index_expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
ImageQuery
{
image
query
}
=
>
{
let
(
dim
class
)
=
match
*
ctx
.
typifier
.
get
(
image
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
components
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
1
crate
:
:
ImageDimension
:
:
D2
=
>
2
crate
:
:
ImageDimension
:
:
D3
=
>
3
crate
:
:
ImageDimension
:
:
Cube
=
>
2
}
;
match
query
{
crate
:
:
ImageQuery
:
:
Size
{
level
}
=
>
{
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
=
>
{
write
!
(
self
.
out
"
textureSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
if
let
Some
(
expr
)
=
level
{
self
.
write_expr
(
expr
ctx
)
?
;
}
else
{
write
!
(
self
.
out
"
0
"
)
?
;
}
}
ImageClass
:
:
Storage
(
_
)
=
>
{
write
!
(
self
.
out
"
imageSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
.
{
}
"
&
"
xyz
"
[
.
.
components
]
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLevels
=
>
{
write
!
(
self
.
out
"
textureQueryLevels
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLayers
=
>
{
let
selector
=
[
'
x
'
'
y
'
'
z
'
'
w
'
]
;
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
=
>
"
textureSize
"
ImageClass
:
:
Storage
(
_
)
=
>
"
imageSize
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
0
)
.
{
}
"
selector
[
components
]
)
?
;
}
crate
:
:
ImageQuery
:
:
NumSamples
=
>
{
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
=
>
"
textureSamples
"
ImageClass
:
:
Storage
(
_
)
=
>
"
imageSamples
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
}
return
Err
(
Error
:
:
Custom
(
"
ImageQuery
not
implemented
"
.
to_string
(
)
)
)
;
}
Expression
:
:
Unary
{
op
expr
}
=
>
{
write
!
(
self
.
out
"
(
{
}
"
match
op
{
UnaryOperator
:
:
Negate
=
>
"
-
"
UnaryOperator
:
:
Not
=
>
match
*
ctx
.
typifier
.
get
(
expr
&
self
.
module
.
types
)
{
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Sint
.
.
}
=
>
"
~
"
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Uint
.
.
}
=
>
"
~
"
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Bool
.
.
}
=
>
"
!
"
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
apply
not
to
type
{
:
?
}
"
other
)
)
)
}
}
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Binary
{
op
left
right
}
=
>
{
let
function
=
if
let
(
TypeInner
:
:
Vector
{
.
.
}
TypeInner
:
:
Vector
{
.
.
}
)
=
(
ctx
.
typifier
.
get
(
left
&
self
.
module
.
types
)
ctx
.
typifier
.
get
(
right
&
self
.
module
.
types
)
)
{
match
op
{
BinaryOperator
:
:
Less
=
>
Some
(
"
lessThan
"
)
BinaryOperator
:
:
LessEqual
=
>
Some
(
"
lessThanEqual
"
)
BinaryOperator
:
:
Greater
=
>
Some
(
"
greaterThan
"
)
BinaryOperator
:
:
GreaterEqual
=
>
Some
(
"
greaterThanEqual
"
)
BinaryOperator
:
:
Equal
=
>
Some
(
"
equal
"
)
BinaryOperator
:
:
NotEqual
=
>
Some
(
"
notEqual
"
)
_
=
>
None
}
}
else
{
None
}
;
write
!
(
self
.
out
"
{
}
(
"
function
.
unwrap_or
(
"
"
)
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
if
function
.
is_some
(
)
{
write
!
(
self
.
out
"
"
)
?
}
else
{
write
!
(
self
.
out
"
{
}
"
match
op
{
BinaryOperator
:
:
Add
=
>
"
+
"
BinaryOperator
:
:
Subtract
=
>
"
-
"
BinaryOperator
:
:
Multiply
=
>
"
*
"
BinaryOperator
:
:
Divide
=
>
"
/
"
BinaryOperator
:
:
Modulo
=
>
"
%
"
BinaryOperator
:
:
Equal
=
>
"
=
=
"
BinaryOperator
:
:
NotEqual
=
>
"
!
=
"
BinaryOperator
:
:
Less
=
>
"
<
"
BinaryOperator
:
:
LessEqual
=
>
"
<
=
"
BinaryOperator
:
:
Greater
=
>
"
>
"
BinaryOperator
:
:
GreaterEqual
=
>
"
>
=
"
BinaryOperator
:
:
And
=
>
"
&
"
BinaryOperator
:
:
ExclusiveOr
=
>
"
^
"
BinaryOperator
:
:
InclusiveOr
=
>
"
|
"
BinaryOperator
:
:
LogicalAnd
=
>
"
&
&
"
BinaryOperator
:
:
LogicalOr
=
>
"
|
|
"
BinaryOperator
:
:
ShiftLeft
=
>
"
<
<
"
BinaryOperator
:
:
ShiftRight
=
>
"
>
>
"
}
)
?
;
}
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Select
{
condition
accept
reject
}
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
write
!
(
self
.
out
"
?
"
)
?
;
self
.
write_expr
(
accept
ctx
)
?
;
write
!
(
self
.
out
"
:
"
)
?
;
self
.
write_expr
(
reject
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Derivative
{
axis
expr
}
=
>
{
write
!
(
self
.
out
"
{
}
(
"
match
axis
{
DerivativeAxis
:
:
X
=
>
"
dFdx
"
DerivativeAxis
:
:
Y
=
>
"
dFdy
"
DerivativeAxis
:
:
Width
=
>
"
fwidth
"
}
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Relational
{
fun
argument
}
=
>
{
let
fun_name
=
match
fun
{
RelationalFunction
:
:
IsFinite
=
>
"
!
isinf
"
RelationalFunction
:
:
IsInf
=
>
"
isinf
"
RelationalFunction
:
:
IsNan
=
>
"
isnan
"
RelationalFunction
:
:
IsNormal
=
>
"
!
isnan
"
RelationalFunction
:
:
All
=
>
"
all
"
RelationalFunction
:
:
Any
=
>
"
any
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
argument
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Math
{
fun
arg
arg1
arg2
}
=
>
{
use
crate
:
:
MathFunction
as
Mf
;
let
fun_name
=
match
fun
{
Mf
:
:
Abs
=
>
"
abs
"
Mf
:
:
Min
=
>
"
min
"
Mf
:
:
Max
=
>
"
max
"
Mf
:
:
Clamp
=
>
"
clamp
"
Mf
:
:
Cos
=
>
"
cos
"
Mf
:
:
Cosh
=
>
"
cosh
"
Mf
:
:
Sin
=
>
"
sin
"
Mf
:
:
Sinh
=
>
"
sinh
"
Mf
:
:
Tan
=
>
"
tan
"
Mf
:
:
Tanh
=
>
"
tanh
"
Mf
:
:
Acos
=
>
"
acos
"
Mf
:
:
Asin
=
>
"
asin
"
Mf
:
:
Atan
=
>
"
atan
"
Mf
:
:
Atan2
=
>
"
atan2
"
Mf
:
:
Ceil
=
>
"
ceil
"
Mf
:
:
Floor
=
>
"
floor
"
Mf
:
:
Round
=
>
"
round
"
Mf
:
:
Fract
=
>
"
fract
"
Mf
:
:
Trunc
=
>
"
trunc
"
Mf
:
:
Modf
=
>
"
modf
"
Mf
:
:
Frexp
=
>
"
frexp
"
Mf
:
:
Ldexp
=
>
"
ldexp
"
Mf
:
:
Exp
=
>
"
exp
"
Mf
:
:
Exp2
=
>
"
exp2
"
Mf
:
:
Log
=
>
"
log
"
Mf
:
:
Log2
=
>
"
log2
"
Mf
:
:
Pow
=
>
"
pow
"
Mf
:
:
Dot
=
>
"
dot
"
Mf
:
:
Outer
=
>
"
outerProduct
"
Mf
:
:
Cross
=
>
"
cross
"
Mf
:
:
Distance
=
>
"
distance
"
Mf
:
:
Length
=
>
"
length
"
Mf
:
:
Normalize
=
>
"
normalize
"
Mf
:
:
FaceForward
=
>
"
faceforward
"
Mf
:
:
Reflect
=
>
"
reflect
"
Mf
:
:
Sign
=
>
"
sign
"
Mf
:
:
Fma
=
>
"
fma
"
Mf
:
:
Mix
=
>
"
mix
"
Mf
:
:
Step
=
>
"
step
"
Mf
:
:
SmoothStep
=
>
"
smoothstep
"
Mf
:
:
Sqrt
=
>
"
sqrt
"
Mf
:
:
InverseSqrt
=
>
"
inversesqrt
"
Mf
:
:
Inverse
=
>
"
inverse
"
Mf
:
:
Transpose
=
>
"
transpose
"
Mf
:
:
Determinant
=
>
"
determinant
"
Mf
:
:
CountOneBits
=
>
"
bitCount
"
Mf
:
:
ReverseBits
=
>
"
bitfieldReverse
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
if
let
Some
(
arg
)
=
arg1
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
}
if
let
Some
(
arg
)
=
arg2
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
As
{
expr
kind
convert
}
=
>
{
let
inner
=
ctx
.
typifier
.
get
(
expr
&
self
.
module
.
types
)
;
if
convert
{
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
:
_
width
}
=
>
{
write
!
(
self
.
out
"
{
}
"
glsl_scalar
(
kind
width
)
?
.
full
)
?
}
TypeInner
:
:
Vector
{
size
kind
:
_
width
}
=
>
write
!
(
self
.
out
"
{
}
vec
{
}
"
glsl_scalar
(
kind
width
)
?
.
prefix
size
as
u8
)
?
ref
other
=
>
unreachable
!
(
"
unexpected
cast
of
{
:
?
}
"
other
)
}
}
else
{
let
source_kind
=
inner
.
scalar_kind
(
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
{
}
"
match
(
source_kind
kind
)
{
(
ScalarKind
:
:
Float
ScalarKind
:
:
Sint
)
=
>
"
floatBitsToInt
"
(
ScalarKind
:
:
Float
ScalarKind
:
:
Uint
)
=
>
"
floatBitsToUInt
"
(
ScalarKind
:
:
Sint
ScalarKind
:
:
Float
)
=
>
"
intBitsToFloat
"
(
ScalarKind
:
:
Uint
ScalarKind
:
:
Float
)
=
>
"
uintBitsToFloat
"
_
=
>
{
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
bitcast
{
:
?
}
to
{
:
?
}
"
source_kind
kind
)
)
)
;
}
}
)
?
;
}
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Call
{
function
ref
arguments
}
=
>
{
write
!
(
self
.
out
"
{
}
(
"
&
self
.
names
[
&
NameKey
:
:
Function
(
function
)
]
)
?
;
self
.
write_slice
(
arguments
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
ArrayLength
(
expr
)
=
>
{
write
!
(
self
.
out
"
uint
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
.
length
(
)
)
"
)
?
}
}
Ok
(
(
)
)
}
fn
write_texture_coordinates
(
&
mut
self
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
dim
:
crate
:
:
ImageDimension
ctx
:
&
FunctionCtx
)
-
>
Result
<
(
)
Error
>
{
match
array_index
{
Some
(
layer_expr
)
=
>
{
let
tex_coord_type
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
"
ivec2
"
crate
:
:
ImageDimension
:
:
D2
=
>
"
ivec3
"
crate
:
:
ImageDimension
:
:
D3
=
>
"
ivec4
"
crate
:
:
ImageDimension
:
:
Cube
=
>
"
ivec4
"
}
;
write
!
(
self
.
out
"
{
}
(
"
tex_coord_type
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
layer_expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
None
=
>
{
self
.
write_expr
(
coordinate
ctx
)
?
;
}
}
Ok
(
(
)
)
}
fn
collect_texture_mapping
(
&
self
)
-
>
Result
<
FastHashMap
<
String
TextureMapping
>
Error
>
{
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
let
info
=
self
.
analysis
.
get_entry_point
(
self
.
options
.
shader_stage
&
self
.
options
.
entry_point
)
;
let
mut
mappings
=
FastHashMap
:
:
default
(
)
;
for
sampling
in
info
.
sampling_set
.
iter
(
)
{
let
tex_name
=
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
sampling
.
image
)
]
.
clone
(
)
;
match
mappings
.
entry
(
tex_name
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
v
.
insert
(
TextureMapping
{
texture
:
sampling
.
image
sampler
:
Some
(
sampling
.
sampler
)
}
)
;
}
Entry
:
:
Occupied
(
e
)
=
>
{
if
e
.
get
(
)
.
sampler
!
=
Some
(
sampling
.
sampler
)
{
log
:
:
error
!
(
"
Conflicting
samplers
for
{
}
"
e
.
key
(
)
)
;
return
Err
(
Error
:
:
ImageMultipleSamplers
)
;
}
}
}
}
for
(
handle
var
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
info
[
handle
]
.
is_empty
(
)
{
continue
;
}
match
self
.
module
.
types
[
var
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Image
{
.
.
}
=
>
(
)
_
=
>
continue
}
let
tex_name
=
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
.
clone
(
)
;
if
let
Entry
:
:
Vacant
(
e
)
=
mappings
.
entry
(
tex_name
)
{
e
.
insert
(
TextureMapping
{
texture
:
handle
sampler
:
None
}
)
;
}
}
Ok
(
mappings
)
}
}
struct
ScalarString
<
'
a
>
{
prefix
:
&
'
a
str
full
:
&
'
a
str
}
fn
glsl_scalar
(
kind
:
ScalarKind
width
:
Bytes
)
-
>
Result
<
ScalarString
<
'
static
>
Error
>
{
Ok
(
match
kind
{
ScalarKind
:
:
Sint
=
>
ScalarString
{
prefix
:
"
i
"
full
:
"
int
"
}
ScalarKind
:
:
Uint
=
>
ScalarString
{
prefix
:
"
u
"
full
:
"
uint
"
}
ScalarKind
:
:
Float
=
>
match
width
{
4
=
>
ScalarString
{
prefix
:
"
"
full
:
"
float
"
}
8
=
>
ScalarString
{
prefix
:
"
d
"
full
:
"
double
"
}
_
=
>
return
Err
(
Error
:
:
UnsupportedScalar
(
kind
width
)
)
}
ScalarKind
:
:
Bool
=
>
ScalarString
{
prefix
:
"
b
"
full
:
"
bool
"
}
}
)
}
fn
glsl_built_in
(
built_in
:
BuiltIn
)
-
>
&
'
static
str
{
match
built_in
{
BuiltIn
:
:
Position
=
>
"
gl_Position
"
BuiltIn
:
:
BaseInstance
=
>
"
gl_BaseInstance
"
BuiltIn
:
:
BaseVertex
=
>
"
gl_BaseVertex
"
BuiltIn
:
:
ClipDistance
=
>
"
gl_ClipDistance
"
BuiltIn
:
:
InstanceIndex
=
>
"
gl_InstanceID
"
BuiltIn
:
:
PointSize
=
>
"
gl_PointSize
"
BuiltIn
:
:
VertexIndex
=
>
"
gl_VertexID
"
BuiltIn
:
:
FragCoord
=
>
"
gl_FragCoord
"
BuiltIn
:
:
FragDepth
=
>
"
gl_FragDepth
"
BuiltIn
:
:
FrontFacing
=
>
"
gl_FrontFacing
"
BuiltIn
:
:
SampleIndex
=
>
"
gl_SampleID
"
BuiltIn
:
:
SampleMaskIn
=
>
"
gl_SampleMaskIn
"
BuiltIn
:
:
SampleMaskOut
=
>
"
gl_SampleMask
"
BuiltIn
:
:
GlobalInvocationId
=
>
"
gl_GlobalInvocationID
"
BuiltIn
:
:
LocalInvocationId
=
>
"
gl_LocalInvocationID
"
BuiltIn
:
:
LocalInvocationIndex
=
>
"
gl_LocalInvocationIndex
"
BuiltIn
:
:
WorkGroupId
=
>
"
gl_WorkGroupID
"
BuiltIn
:
:
WorkGroupSize
=
>
"
gl_WorkGroupSize
"
}
}
fn
glsl_storage_class
(
class
:
StorageClass
)
-
>
&
'
static
str
{
match
class
{
StorageClass
:
:
Function
=
>
"
"
StorageClass
:
:
Input
=
>
"
in
"
StorageClass
:
:
Output
=
>
"
out
"
StorageClass
:
:
Private
=
>
"
"
StorageClass
:
:
Storage
=
>
"
buffer
"
StorageClass
:
:
Uniform
=
>
"
uniform
"
StorageClass
:
:
Handle
=
>
"
uniform
"
StorageClass
:
:
WorkGroup
=
>
"
shared
"
StorageClass
:
:
PushConstant
=
>
"
"
}
}
fn
glsl_interpolation
(
interpolation
:
Interpolation
)
-
>
Result
<
&
'
static
str
Error
>
{
Ok
(
match
interpolation
{
Interpolation
:
:
Perspective
=
>
"
smooth
"
Interpolation
:
:
Linear
=
>
"
noperspective
"
Interpolation
:
:
Flat
=
>
"
flat
"
Interpolation
:
:
Centroid
=
>
"
centroid
"
Interpolation
:
:
Sample
=
>
"
sample
"
Interpolation
:
:
Patch
=
>
return
Err
(
Error
:
:
PatchInterpolationNotSupported
)
}
)
}
fn
glsl_dimension
(
dim
:
crate
:
:
ImageDimension
)
-
>
&
'
static
str
{
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
"
1D
"
crate
:
:
ImageDimension
:
:
D2
=
>
"
2D
"
crate
:
:
ImageDimension
:
:
D3
=
>
"
3D
"
crate
:
:
ImageDimension
:
:
Cube
=
>
"
Cube
"
}
}
fn
glsl_storage_format
(
format
:
StorageFormat
)
-
>
&
'
static
str
{
match
format
{
StorageFormat
:
:
R8Unorm
=
>
"
r8
"
StorageFormat
:
:
R8Snorm
=
>
"
r8_snorm
"
StorageFormat
:
:
R8Uint
=
>
"
r8ui
"
StorageFormat
:
:
R8Sint
=
>
"
r8i
"
StorageFormat
:
:
R16Uint
=
>
"
r16ui
"
StorageFormat
:
:
R16Sint
=
>
"
r16i
"
StorageFormat
:
:
R16Float
=
>
"
r16f
"
StorageFormat
:
:
Rg8Unorm
=
>
"
rg8
"
StorageFormat
:
:
Rg8Snorm
=
>
"
rg8_snorm
"
StorageFormat
:
:
Rg8Uint
=
>
"
rg8ui
"
StorageFormat
:
:
Rg8Sint
=
>
"
rg8i
"
StorageFormat
:
:
R32Uint
=
>
"
r32ui
"
StorageFormat
:
:
R32Sint
=
>
"
r32i
"
StorageFormat
:
:
R32Float
=
>
"
r32f
"
StorageFormat
:
:
Rg16Uint
=
>
"
rg16ui
"
StorageFormat
:
:
Rg16Sint
=
>
"
rg16i
"
StorageFormat
:
:
Rg16Float
=
>
"
rg16f
"
StorageFormat
:
:
Rgba8Unorm
=
>
"
rgba8ui
"
StorageFormat
:
:
Rgba8Snorm
=
>
"
rgba8_snorm
"
StorageFormat
:
:
Rgba8Uint
=
>
"
rgba8ui
"
StorageFormat
:
:
Rgba8Sint
=
>
"
rgba8i
"
StorageFormat
:
:
Rgb10a2Unorm
=
>
"
rgb10_a2ui
"
StorageFormat
:
:
Rg11b10Float
=
>
"
r11f_g11f_b10f
"
StorageFormat
:
:
Rg32Uint
=
>
"
rg32ui
"
StorageFormat
:
:
Rg32Sint
=
>
"
rg32i
"
StorageFormat
:
:
Rg32Float
=
>
"
rg32f
"
StorageFormat
:
:
Rgba16Uint
=
>
"
rgba16ui
"
StorageFormat
:
:
Rgba16Sint
=
>
"
rgba16i
"
StorageFormat
:
:
Rgba16Float
=
>
"
rgba16f
"
StorageFormat
:
:
Rgba32Uint
=
>
"
rgba32ui
"
StorageFormat
:
:
Rgba32Sint
=
>
"
rgba32i
"
StorageFormat
:
:
Rgba32Float
=
>
"
rgba32f
"
}
}
