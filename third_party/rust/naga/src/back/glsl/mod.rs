pub
use
features
:
:
Features
;
use
crate
:
:
{
back
proc
:
:
{
self
NameKey
}
valid
Handle
ShaderStage
TypeInner
}
;
use
features
:
:
FeaturesManager
;
use
std
:
:
{
cmp
:
:
Ordering
fmt
fmt
:
:
{
Error
as
FmtError
Write
}
}
;
use
thiserror
:
:
Error
;
mod
features
;
mod
keywords
;
pub
const
SUPPORTED_CORE_VERSIONS
:
&
[
u16
]
=
&
[
330
400
410
420
430
440
450
]
;
pub
const
SUPPORTED_ES_VERSIONS
:
&
[
u16
]
=
&
[
300
310
320
]
;
const
CLAMPED_LOD_SUFFIX
:
&
str
=
"
_clamped_lod
"
;
pub
(
crate
)
const
MODF_FUNCTION
:
&
str
=
"
naga_modf
"
;
pub
(
crate
)
const
FREXP_FUNCTION
:
&
str
=
"
naga_frexp
"
;
pub
type
BindingMap
=
std
:
:
collections
:
:
BTreeMap
<
crate
:
:
ResourceBinding
u8
>
;
impl
crate
:
:
AtomicFunction
{
const
fn
to_glsl
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Add
|
Self
:
:
Subtract
=
>
"
Add
"
Self
:
:
And
=
>
"
And
"
Self
:
:
InclusiveOr
=
>
"
Or
"
Self
:
:
ExclusiveOr
=
>
"
Xor
"
Self
:
:
Min
=
>
"
Min
"
Self
:
:
Max
=
>
"
Max
"
Self
:
:
Exchange
{
compare
:
None
}
=
>
"
Exchange
"
Self
:
:
Exchange
{
compare
:
Some
(
_
)
}
=
>
"
"
}
}
}
impl
crate
:
:
AddressSpace
{
const
fn
is_buffer
(
&
self
)
-
>
bool
{
match
*
self
{
crate
:
:
AddressSpace
:
:
Uniform
|
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
=
>
true
_
=
>
false
}
}
const
fn
initializable
(
&
self
)
-
>
bool
{
match
*
self
{
crate
:
:
AddressSpace
:
:
Function
|
crate
:
:
AddressSpace
:
:
Private
=
>
true
crate
:
:
AddressSpace
:
:
WorkGroup
|
crate
:
:
AddressSpace
:
:
Uniform
|
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
|
crate
:
:
AddressSpace
:
:
Handle
|
crate
:
:
AddressSpace
:
:
PushConstant
=
>
false
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
Version
{
Desktop
(
u16
)
Embedded
{
version
:
u16
is_webgl
:
bool
}
}
impl
Version
{
pub
const
fn
new_gles
(
version
:
u16
)
-
>
Self
{
Self
:
:
Embedded
{
version
is_webgl
:
false
}
}
const
fn
is_es
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
_
)
=
>
false
Version
:
:
Embedded
{
.
.
}
=
>
true
}
}
const
fn
is_webgl
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
_
)
=
>
false
Version
:
:
Embedded
{
is_webgl
.
.
}
=
>
is_webgl
}
}
fn
is_supported
(
&
self
)
-
>
bool
{
match
*
self
{
Version
:
:
Desktop
(
v
)
=
>
SUPPORTED_CORE_VERSIONS
.
contains
(
&
v
)
Version
:
:
Embedded
{
version
:
v
.
.
}
=
>
SUPPORTED_ES_VERSIONS
.
contains
(
&
v
)
}
}
fn
supports_explicit_locations
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
410
)
|
|
*
self
>
=
Version
:
:
new_gles
(
310
)
}
fn
supports_early_depth_test
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
130
)
|
|
*
self
>
=
Version
:
:
new_gles
(
310
)
}
fn
supports_std430_layout
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
430
)
|
|
*
self
>
=
Version
:
:
new_gles
(
310
)
}
fn
supports_fma_function
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
400
)
|
|
*
self
>
=
Version
:
:
new_gles
(
320
)
}
fn
supports_integer_functions
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
400
)
|
|
*
self
>
=
Version
:
:
new_gles
(
310
)
}
fn
supports_derivative_control
(
&
self
)
-
>
bool
{
*
self
>
=
Version
:
:
Desktop
(
450
)
}
}
impl
PartialOrd
for
Version
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
match
(
*
self
*
other
)
{
(
Version
:
:
Desktop
(
x
)
Version
:
:
Desktop
(
y
)
)
=
>
Some
(
x
.
cmp
(
&
y
)
)
(
Version
:
:
Embedded
{
version
:
x
.
.
}
Version
:
:
Embedded
{
version
:
y
.
.
}
)
=
>
{
Some
(
x
.
cmp
(
&
y
)
)
}
_
=
>
None
}
}
}
impl
fmt
:
:
Display
for
Version
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Version
:
:
Desktop
(
v
)
=
>
write
!
(
f
"
{
v
}
core
"
)
Version
:
:
Embedded
{
version
:
v
.
.
}
=
>
write
!
(
f
"
{
v
}
es
"
)
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Configuration
flags
for
the
[
Writer
]
.
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
struct
WriterFlags
:
u32
{
/
/
/
Flip
output
Y
and
extend
Z
from
(
0
1
)
to
(
-
1
1
)
.
const
ADJUST_COORDINATE_SPACE
=
0x1
;
/
/
/
Supports
GL_EXT_texture_shadow_lod
on
the
host
which
provides
/
/
/
additional
functions
on
shadows
and
arrays
of
shadows
.
const
TEXTURE_SHADOW_LOD
=
0x2
;
/
/
/
Include
unused
global
variables
constants
and
functions
.
By
default
the
output
will
exclude
/
/
/
global
variables
that
are
not
used
in
the
specified
entrypoint
(
including
indirect
use
)
/
/
/
all
constant
declarations
and
functions
that
use
excluded
global
variables
.
const
INCLUDE_UNUSED_ITEMS
=
0x4
;
/
/
/
Emit
PointSize
output
builtin
to
vertex
shaders
which
is
/
/
/
required
for
drawing
with
PointList
topology
.
/
/
/
/
/
/
https
:
/
/
registry
.
khronos
.
org
/
OpenGL
/
specs
/
es
/
3
.
2
/
GLSL_ES_Specification_3
.
20
.
html
#
built
-
in
-
language
-
variables
/
/
/
The
variable
gl_PointSize
is
intended
for
a
shader
to
write
the
size
of
the
point
to
be
rasterized
.
It
is
measured
in
pixels
.
/
/
/
If
gl_PointSize
is
not
written
to
its
value
is
undefined
in
subsequent
pipe
stages
.
const
FORCE_POINT_SIZE
=
0x10
;
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
Options
{
pub
version
:
Version
pub
writer_flags
:
WriterFlags
pub
binding_map
:
BindingMap
pub
zero_initialize_workgroup_memory
:
bool
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
Options
{
version
:
Version
:
:
new_gles
(
310
)
writer_flags
:
WriterFlags
:
:
ADJUST_COORDINATE_SPACE
binding_map
:
BindingMap
:
:
default
(
)
zero_initialize_workgroup_memory
:
true
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
PipelineOptions
{
pub
shader_stage
:
ShaderStage
pub
entry_point
:
String
pub
multiview
:
Option
<
std
:
:
num
:
:
NonZeroU32
>
}
pub
struct
ReflectionInfo
{
pub
texture_mapping
:
crate
:
:
FastHashMap
<
String
TextureMapping
>
pub
uniforms
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
GlobalVariable
>
String
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
TextureMapping
{
pub
texture
:
Handle
<
crate
:
:
GlobalVariable
>
pub
sampler
:
Option
<
Handle
<
crate
:
:
GlobalVariable
>
>
}
#
[
derive
(
Default
)
]
struct
IdGenerator
(
u32
)
;
impl
IdGenerator
{
fn
generate
(
&
mut
self
)
-
>
u32
{
let
ret
=
self
.
0
;
self
.
0
+
=
1
;
ret
}
}
struct
VaryingName
<
'
a
>
{
binding
:
&
'
a
crate
:
:
Binding
stage
:
ShaderStage
output
:
bool
targetting_webgl
:
bool
}
impl
fmt
:
:
Display
for
VaryingName
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
.
binding
{
crate
:
:
Binding
:
:
Location
{
second_blend_source
:
true
.
.
}
=
>
{
write
!
(
f
"
_fs2p_location1
"
)
}
crate
:
:
Binding
:
:
Location
{
location
.
.
}
=
>
{
let
prefix
=
match
(
self
.
stage
self
.
output
)
{
(
ShaderStage
:
:
Compute
_
)
=
>
unreachable
!
(
)
(
ShaderStage
:
:
Vertex
false
)
=
>
"
p2vs
"
(
ShaderStage
:
:
Vertex
true
)
|
(
ShaderStage
:
:
Fragment
false
)
=
>
"
vs2fs
"
(
ShaderStage
:
:
Fragment
true
)
=
>
"
fs2p
"
}
;
write
!
(
f
"
_
{
prefix
}
_location
{
location
}
"
)
}
crate
:
:
Binding
:
:
BuiltIn
(
built_in
)
=
>
{
write
!
(
f
"
{
}
"
glsl_built_in
(
built_in
self
.
output
self
.
targetting_webgl
)
)
}
}
}
}
impl
ShaderStage
{
const
fn
to_str
(
self
)
-
>
&
'
static
str
{
match
self
{
ShaderStage
:
:
Compute
=
>
"
cs
"
ShaderStage
:
:
Fragment
=
>
"
fs
"
ShaderStage
:
:
Vertex
=
>
"
vs
"
}
}
}
type
BackendResult
<
T
=
(
)
>
=
Result
<
T
Error
>
;
#
[
derive
(
Debug
Error
)
]
pub
enum
Error
{
#
[
error
(
"
Format
error
"
)
]
FmtError
(
#
[
from
]
FmtError
)
#
[
error
(
"
The
selected
version
doesn
'
t
support
{
0
:
?
}
"
)
]
MissingFeatures
(
Features
)
#
[
error
(
"
Multiple
push
constants
aren
'
t
supported
"
)
]
MultiplePushConstants
#
[
error
(
"
The
specified
version
isn
'
t
supported
"
)
]
VersionNotSupported
#
[
error
(
"
The
requested
entry
point
couldn
'
t
be
found
"
)
]
EntryPointNotFound
#
[
error
(
"
A
call
was
made
to
an
unsupported
external
:
{
0
}
"
)
]
UnsupportedExternal
(
String
)
#
[
error
(
"
A
scalar
with
an
unsupported
width
was
requested
:
{
0
:
?
}
{
1
:
?
}
"
)
]
UnsupportedScalar
(
crate
:
:
ScalarKind
crate
:
:
Bytes
)
#
[
error
(
"
A
image
was
used
with
multiple
samplers
"
)
]
ImageMultipleSamplers
#
[
error
(
"
{
0
}
"
)
]
Custom
(
String
)
}
enum
BinaryOperation
{
VectorCompare
VectorComponentWise
Modulo
Other
}
pub
struct
Writer
<
'
a
W
>
{
module
:
&
'
a
crate
:
:
Module
info
:
&
'
a
valid
:
:
ModuleInfo
out
:
W
options
:
&
'
a
Options
policies
:
proc
:
:
BoundsCheckPolicies
features
:
FeaturesManager
namer
:
proc
:
:
Namer
names
:
crate
:
:
FastHashMap
<
NameKey
String
>
reflection_names_globals
:
crate
:
:
FastHashMap
<
Handle
<
crate
:
:
GlobalVariable
>
String
>
entry_point
:
&
'
a
crate
:
:
EntryPoint
entry_point_idx
:
proc
:
:
EntryPointIndex
block_id
:
IdGenerator
named_expressions
:
crate
:
:
NamedExpressions
need_bake_expressions
:
back
:
:
NeedBakeExpressions
multiview
:
Option
<
std
:
:
num
:
:
NonZeroU32
>
}
impl
<
'
a
W
:
Write
>
Writer
<
'
a
W
>
{
pub
fn
new
(
out
:
W
module
:
&
'
a
crate
:
:
Module
info
:
&
'
a
valid
:
:
ModuleInfo
options
:
&
'
a
Options
pipeline_options
:
&
'
a
PipelineOptions
policies
:
proc
:
:
BoundsCheckPolicies
)
-
>
Result
<
Self
Error
>
{
if
!
options
.
version
.
is_supported
(
)
{
log
:
:
error
!
(
"
Version
{
}
"
options
.
version
)
;
return
Err
(
Error
:
:
VersionNotSupported
)
;
}
let
ep_idx
=
module
.
entry_points
.
iter
(
)
.
position
(
|
ep
|
{
pipeline_options
.
shader_stage
=
=
ep
.
stage
&
&
pipeline_options
.
entry_point
=
=
ep
.
name
}
)
.
ok_or
(
Error
:
:
EntryPointNotFound
)
?
;
let
mut
names
=
crate
:
:
FastHashMap
:
:
default
(
)
;
let
mut
namer
=
proc
:
:
Namer
:
:
default
(
)
;
namer
.
reset
(
module
keywords
:
:
RESERVED_KEYWORDS
&
[
]
&
[
]
&
[
"
gl_
"
]
&
mut
names
)
;
let
mut
this
=
Self
{
module
info
out
options
policies
namer
features
:
FeaturesManager
:
:
new
(
)
names
reflection_names_globals
:
crate
:
:
FastHashMap
:
:
default
(
)
entry_point
:
&
module
.
entry_points
[
ep_idx
]
entry_point_idx
:
ep_idx
as
u16
multiview
:
pipeline_options
.
multiview
block_id
:
IdGenerator
:
:
default
(
)
named_expressions
:
Default
:
:
default
(
)
need_bake_expressions
:
Default
:
:
default
(
)
}
;
this
.
collect_required_features
(
)
?
;
Ok
(
this
)
}
pub
fn
write
(
&
mut
self
)
-
>
Result
<
ReflectionInfo
Error
>
{
let
es
=
self
.
options
.
version
.
is_es
(
)
;
writeln
!
(
self
.
out
"
#
version
{
}
"
self
.
options
.
version
)
?
;
self
.
features
.
write
(
self
.
options
.
version
&
mut
self
.
out
)
?
;
if
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
TEXTURE_SHADOW_LOD
)
{
writeln
!
(
self
.
out
"
#
extension
GL_EXT_texture_shadow_lod
:
require
"
)
?
;
}
if
es
{
writeln
!
(
self
.
out
)
?
;
writeln
!
(
self
.
out
"
precision
highp
float
;
"
)
?
;
writeln
!
(
self
.
out
"
precision
highp
int
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
self
.
entry_point
.
stage
=
=
ShaderStage
:
:
Compute
{
let
workgroup_size
=
self
.
entry_point
.
workgroup_size
;
writeln
!
(
self
.
out
"
layout
(
local_size_x
=
{
}
local_size_y
=
{
}
local_size_z
=
{
}
)
in
;
"
workgroup_size
[
0
]
workgroup_size
[
1
]
workgroup_size
[
2
]
)
?
;
writeln
!
(
self
.
out
)
?
;
}
if
let
Some
(
depth_test
)
=
self
.
entry_point
.
early_depth_test
{
if
self
.
options
.
version
.
supports_early_depth_test
(
)
{
writeln
!
(
self
.
out
"
layout
(
early_fragment_tests
)
in
;
"
)
?
;
if
let
Some
(
conservative
)
=
depth_test
.
conservative
{
use
crate
:
:
ConservativeDepth
as
Cd
;
let
depth
=
match
conservative
{
Cd
:
:
GreaterEqual
=
>
"
greater
"
Cd
:
:
LessEqual
=
>
"
less
"
Cd
:
:
Unchanged
=
>
"
unchanged
"
}
;
writeln
!
(
self
.
out
"
layout
(
depth_
{
depth
}
)
out
float
gl_FragDepth
;
"
)
?
;
}
writeln
!
(
self
.
out
)
?
;
}
else
{
log
:
:
warn
!
(
"
Early
depth
testing
is
not
supported
for
this
version
of
GLSL
:
{
}
"
self
.
options
.
version
)
;
}
}
if
self
.
entry_point
.
stage
=
=
ShaderStage
:
:
Vertex
&
&
self
.
options
.
version
.
is_webgl
(
)
{
if
let
Some
(
multiview
)
=
self
.
multiview
.
as_ref
(
)
{
writeln
!
(
self
.
out
"
layout
(
num_views
=
{
multiview
}
)
in
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
}
}
for
(
handle
ty
)
in
self
.
module
.
types
.
iter
(
)
{
if
let
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
ty
.
inner
{
if
!
self
.
module
.
types
[
members
.
last
(
)
.
unwrap
(
)
.
ty
]
.
inner
.
is_dynamically_sized
(
&
self
.
module
.
types
)
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
handle
)
]
;
write
!
(
self
.
out
"
struct
{
name
}
"
)
?
;
self
.
write_struct_body
(
handle
members
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
}
}
for
(
type_key
struct_ty
)
in
self
.
module
.
special_types
.
predeclared_types
.
iter
(
)
{
match
type_key
{
&
crate
:
:
PredeclaredType
:
:
ModfResult
{
size
width
}
|
&
crate
:
:
PredeclaredType
:
:
FrexpResult
{
size
width
}
=
>
{
let
arg_type_name_owner
;
let
arg_type_name
=
if
let
Some
(
size
)
=
size
{
arg_type_name_owner
=
format
!
(
"
{
}
vec
{
}
"
if
width
=
=
8
{
"
d
"
}
else
{
"
"
}
size
as
u8
)
;
&
arg_type_name_owner
}
else
if
width
=
=
8
{
"
double
"
}
else
{
"
float
"
}
;
let
other_type_name_owner
;
let
(
defined_func_name
called_func_name
other_type_name
)
=
if
matches
!
(
type_key
&
crate
:
:
PredeclaredType
:
:
ModfResult
{
.
.
}
)
{
(
MODF_FUNCTION
"
modf
"
arg_type_name
)
}
else
{
let
other_type_name
=
if
let
Some
(
size
)
=
size
{
other_type_name_owner
=
format
!
(
"
ivec
{
}
"
size
as
u8
)
;
&
other_type_name_owner
}
else
{
"
int
"
}
;
(
FREXP_FUNCTION
"
frexp
"
other_type_name
)
}
;
let
struct_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
*
struct_ty
)
]
;
writeln
!
(
self
.
out
)
?
;
writeln
!
(
self
.
out
"
{
}
{
defined_func_name
}
(
{
arg_type_name
}
arg
)
{
{
{
other_type_name
}
other
;
{
arg_type_name
}
fract
=
{
called_func_name
}
(
arg
other
)
;
return
{
}
(
fract
other
)
;
}
}
"
struct_name
struct_name
)
?
;
}
&
crate
:
:
PredeclaredType
:
:
AtomicCompareExchangeWeakResult
{
.
.
}
=
>
{
}
}
}
let
mut
constants
=
self
.
module
.
constants
.
iter
(
)
.
filter
(
|
&
(
_
c
)
|
c
.
name
.
is_some
(
)
)
.
peekable
(
)
;
while
let
Some
(
(
handle
_
)
)
=
constants
.
next
(
)
{
self
.
write_global_constant
(
handle
)
?
;
if
constants
.
peek
(
)
.
is_none
(
)
{
writeln
!
(
self
.
out
)
?
;
}
}
let
ep_info
=
self
.
info
.
get_entry_point
(
self
.
entry_point_idx
as
usize
)
;
let
include_unused
=
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
INCLUDE_UNUSED_ITEMS
)
;
for
(
handle
global
)
in
self
.
module
.
global_variables
.
iter
(
)
{
let
is_unused
=
ep_info
[
handle
]
.
is_empty
(
)
;
if
!
include_unused
&
&
is_unused
{
continue
;
}
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
mut
dim
arrayed
class
}
=
>
{
let
storage_format_access
=
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
format
access
}
.
.
}
=
>
Some
(
(
format
access
)
)
_
=
>
None
}
;
if
dim
=
=
crate
:
:
ImageDimension
:
:
D1
&
&
es
{
dim
=
crate
:
:
ImageDimension
:
:
D2
}
let
layout_binding
=
if
self
.
options
.
version
.
supports_explicit_locations
(
)
{
let
br
=
global
.
binding
.
as_ref
(
)
.
unwrap
(
)
;
self
.
options
.
binding_map
.
get
(
br
)
.
cloned
(
)
}
else
{
None
}
;
if
layout_binding
.
is_some
(
)
|
|
storage_format_access
.
is_some
(
)
{
write
!
(
self
.
out
"
layout
(
"
)
?
;
if
let
Some
(
binding
)
=
layout_binding
{
write
!
(
self
.
out
"
binding
=
{
binding
}
"
)
?
;
}
if
let
Some
(
(
format
_
)
)
=
storage_format_access
{
let
format_str
=
glsl_storage_format
(
format
)
;
let
separator
=
match
layout_binding
{
Some
(
_
)
=
>
"
"
None
=
>
"
"
}
;
write
!
(
self
.
out
"
{
separator
}
{
format_str
}
"
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
if
let
Some
(
(
_
access
)
)
=
storage_format_access
{
self
.
write_storage_access
(
access
)
?
;
}
write
!
(
self
.
out
"
uniform
"
)
?
;
self
.
write_image_type
(
dim
arrayed
class
)
?
;
let
global_name
=
self
.
get_global_name
(
handle
global
)
;
writeln
!
(
self
.
out
"
{
global_name
}
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
self
.
reflection_names_globals
.
insert
(
handle
global_name
)
;
}
TypeInner
:
:
Sampler
{
.
.
}
=
>
continue
_
=
>
{
self
.
write_global
(
handle
global
)
?
;
writeln
!
(
self
.
out
)
?
;
}
}
}
for
arg
in
self
.
entry_point
.
function
.
arguments
.
iter
(
)
{
self
.
write_varying
(
arg
.
binding
.
as_ref
(
)
arg
.
ty
false
)
?
;
}
if
let
Some
(
ref
result
)
=
self
.
entry_point
.
function
.
result
{
self
.
write_varying
(
result
.
binding
.
as_ref
(
)
result
.
ty
true
)
?
;
}
writeln
!
(
self
.
out
)
?
;
for
(
handle
function
)
in
self
.
module
.
functions
.
iter
(
)
{
if
!
include_unused
&
&
!
ep_info
.
dominates_global_use
(
&
self
.
info
[
handle
]
)
{
continue
;
}
let
fun_info
=
&
self
.
info
[
handle
]
;
self
.
write_function
(
back
:
:
FunctionType
:
:
Function
(
handle
)
function
fun_info
)
?
;
writeln
!
(
self
.
out
)
?
;
}
self
.
write_function
(
back
:
:
FunctionType
:
:
EntryPoint
(
self
.
entry_point_idx
)
&
self
.
entry_point
.
function
ep_info
)
?
;
writeln
!
(
self
.
out
)
?
;
self
.
collect_reflection_info
(
)
}
fn
write_array_size
(
&
mut
self
base
:
Handle
<
crate
:
:
Type
>
size
:
crate
:
:
ArraySize
)
-
>
BackendResult
{
write
!
(
self
.
out
"
[
"
)
?
;
match
size
{
crate
:
:
ArraySize
:
:
Constant
(
size
)
=
>
{
write
!
(
self
.
out
"
{
size
}
"
)
?
;
}
crate
:
:
ArraySize
:
:
Dynamic
=
>
(
)
}
write
!
(
self
.
out
"
]
"
)
?
;
if
let
TypeInner
:
:
Array
{
base
:
next_base
size
:
next_size
.
.
}
=
self
.
module
.
types
[
base
]
.
inner
{
self
.
write_array_size
(
next_base
next_size
)
?
;
}
Ok
(
(
)
)
}
fn
write_value_type
(
&
mut
self
inner
:
&
TypeInner
)
-
>
BackendResult
{
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
width
}
|
TypeInner
:
:
Atomic
{
kind
width
}
|
TypeInner
:
:
ValuePointer
{
size
:
None
kind
width
space
:
_
}
=
>
write
!
(
self
.
out
"
{
}
"
glsl_scalar
(
kind
width
)
?
.
full
)
?
TypeInner
:
:
Vector
{
size
kind
width
}
|
TypeInner
:
:
ValuePointer
{
size
:
Some
(
size
)
kind
width
space
:
_
}
=
>
write
!
(
self
.
out
"
{
}
vec
{
}
"
glsl_scalar
(
kind
width
)
?
.
prefix
size
as
u8
)
?
TypeInner
:
:
Matrix
{
columns
rows
width
}
=
>
write
!
(
self
.
out
"
{
}
mat
{
}
x
{
}
"
glsl_scalar
(
crate
:
:
ScalarKind
:
:
Float
width
)
?
.
prefix
columns
as
u8
rows
as
u8
)
?
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
self
.
write_array_size
(
base
size
)
?
TypeInner
:
:
Pointer
{
.
.
}
|
TypeInner
:
:
Struct
{
.
.
}
|
TypeInner
:
:
Image
{
.
.
}
|
TypeInner
:
:
Sampler
{
.
.
}
|
TypeInner
:
:
AccelerationStructure
|
TypeInner
:
:
RayQuery
|
TypeInner
:
:
BindingArray
{
.
.
}
=
>
{
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Unable
to
write
type
{
inner
:
?
}
"
)
)
)
}
}
Ok
(
(
)
)
}
fn
write_type
(
&
mut
self
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
BackendResult
{
match
self
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
self
.
write_type
(
base
)
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
;
write
!
(
self
.
out
"
{
name
}
"
)
?
;
Ok
(
(
)
)
}
TypeInner
:
:
Array
{
base
.
.
}
=
>
self
.
write_type
(
base
)
ref
other
=
>
self
.
write_value_type
(
other
)
}
}
fn
write_image_type
(
&
mut
self
dim
:
crate
:
:
ImageDimension
arrayed
:
bool
class
:
crate
:
:
ImageClass
)
-
>
BackendResult
{
use
crate
:
:
ImageClass
as
Ic
;
let
(
base
kind
ms
comparison
)
=
match
class
{
Ic
:
:
Sampled
{
kind
multi
:
true
}
=
>
(
"
sampler
"
kind
"
MS
"
"
"
)
Ic
:
:
Sampled
{
kind
multi
:
false
}
=
>
(
"
sampler
"
kind
"
"
"
"
)
Ic
:
:
Depth
{
multi
:
true
}
=
>
(
"
sampler
"
crate
:
:
ScalarKind
:
:
Float
"
MS
"
"
"
)
Ic
:
:
Depth
{
multi
:
false
}
=
>
(
"
sampler
"
crate
:
:
ScalarKind
:
:
Float
"
"
"
Shadow
"
)
Ic
:
:
Storage
{
format
.
.
}
=
>
(
"
image
"
format
.
into
(
)
"
"
"
"
)
}
;
write
!
(
self
.
out
"
highp
{
}
{
}
{
}
{
}
{
}
{
}
"
glsl_scalar
(
kind
4
)
?
.
prefix
base
glsl_dimension
(
dim
)
ms
if
arrayed
{
"
Array
"
}
else
{
"
"
}
comparison
)
?
;
Ok
(
(
)
)
}
fn
write_global
(
&
mut
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
BackendResult
{
if
self
.
options
.
version
.
supports_explicit_locations
(
)
{
if
let
Some
(
ref
br
)
=
global
.
binding
{
match
self
.
options
.
binding_map
.
get
(
br
)
{
Some
(
binding
)
=
>
{
let
layout
=
match
global
.
space
{
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
=
>
{
if
self
.
options
.
version
.
supports_std430_layout
(
)
{
"
std430
"
}
else
{
"
std140
"
}
}
crate
:
:
AddressSpace
:
:
Uniform
=
>
"
std140
"
_
=
>
"
"
}
;
write
!
(
self
.
out
"
layout
(
{
layout
}
binding
=
{
binding
}
)
"
)
?
}
None
=
>
{
log
:
:
debug
!
(
"
unassigned
binding
for
{
:
?
}
"
global
.
name
)
;
if
let
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
=
global
.
space
{
if
self
.
options
.
version
.
supports_std430_layout
(
)
{
write
!
(
self
.
out
"
layout
(
std430
)
"
)
?
}
}
}
}
}
}
if
let
crate
:
:
AddressSpace
:
:
Storage
{
access
}
=
global
.
space
{
self
.
write_storage_access
(
access
)
?
;
}
if
let
Some
(
storage_qualifier
)
=
glsl_storage_qualifier
(
global
.
space
)
{
write
!
(
self
.
out
"
{
storage_qualifier
}
"
)
?
;
}
match
global
.
space
{
crate
:
:
AddressSpace
:
:
Private
=
>
{
self
.
write_simple_global
(
handle
global
)
?
;
}
crate
:
:
AddressSpace
:
:
WorkGroup
=
>
{
self
.
write_simple_global
(
handle
global
)
?
;
}
crate
:
:
AddressSpace
:
:
PushConstant
=
>
{
self
.
write_simple_global
(
handle
global
)
?
;
}
crate
:
:
AddressSpace
:
:
Uniform
=
>
{
self
.
write_interface_block
(
handle
global
)
?
;
}
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
=
>
{
self
.
write_interface_block
(
handle
global
)
?
;
}
crate
:
:
AddressSpace
:
:
Function
=
>
unreachable
!
(
)
crate
:
:
AddressSpace
:
:
Handle
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_simple_global
(
&
mut
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
BackendResult
{
self
.
write_type
(
global
.
ty
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_global_name
(
handle
global
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
global
.
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
;
}
if
global
.
space
.
initializable
(
)
&
&
is_value_init_supported
(
self
.
module
global
.
ty
)
{
write
!
(
self
.
out
"
=
"
)
?
;
if
let
Some
(
init
)
=
global
.
init
{
self
.
write_const_expr
(
init
)
?
;
}
else
{
self
.
write_zero_init_value
(
global
.
ty
)
?
;
}
}
writeln
!
(
self
.
out
"
;
"
)
?
;
if
let
crate
:
:
AddressSpace
:
:
PushConstant
=
global
.
space
{
let
global_name
=
self
.
get_global_name
(
handle
global
)
;
self
.
reflection_names_globals
.
insert
(
handle
global_name
)
;
}
Ok
(
(
)
)
}
fn
write_interface_block
(
&
mut
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
BackendResult
{
let
ty_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
global
.
ty
)
]
;
let
block_name
=
format
!
(
"
{
}
_block_
{
}
{
:
?
}
"
ty_name
self
.
block_id
.
generate
(
)
self
.
entry_point
.
stage
)
;
write
!
(
self
.
out
"
{
block_name
}
"
)
?
;
self
.
reflection_names_globals
.
insert
(
handle
block_name
)
;
match
self
.
module
.
types
[
global
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
if
self
.
module
.
types
[
members
.
last
(
)
.
unwrap
(
)
.
ty
]
.
inner
.
is_dynamically_sized
(
&
self
.
module
.
types
)
=
>
{
self
.
write_struct_body
(
global
.
ty
members
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_global_name
(
handle
global
)
?
;
}
_
=
>
{
write
!
(
self
.
out
"
{
{
"
)
?
;
self
.
write_type
(
global
.
ty
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_global_name
(
handle
global
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
global
.
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
;
}
write
!
(
self
.
out
"
;
}
}
"
)
?
;
}
}
writeln
!
(
self
.
out
"
;
"
)
?
;
Ok
(
(
)
)
}
fn
update_expressions_to_bake
(
&
mut
self
func
:
&
crate
:
:
Function
info
:
&
valid
:
:
FunctionInfo
)
{
use
crate
:
:
Expression
;
self
.
need_bake_expressions
.
clear
(
)
;
for
(
fun_handle
expr
)
in
func
.
expressions
.
iter
(
)
{
let
expr_info
=
&
info
[
fun_handle
]
;
let
min_ref_count
=
func
.
expressions
[
fun_handle
]
.
bake_ref_count
(
)
;
if
min_ref_count
<
=
expr_info
.
ref_count
{
self
.
need_bake_expressions
.
insert
(
fun_handle
)
;
}
let
inner
=
expr_info
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
if
let
Expression
:
:
Math
{
fun
arg
arg1
.
.
}
=
*
expr
{
match
fun
{
crate
:
:
MathFunction
:
:
Dot
=
>
{
if
let
TypeInner
:
:
Scalar
{
kind
.
.
}
=
*
inner
{
match
kind
{
crate
:
:
ScalarKind
:
:
Sint
|
crate
:
:
ScalarKind
:
:
Uint
=
>
{
self
.
need_bake_expressions
.
insert
(
arg
)
;
self
.
need_bake_expressions
.
insert
(
arg1
.
unwrap
(
)
)
;
}
_
=
>
{
}
}
}
}
crate
:
:
MathFunction
:
:
CountLeadingZeros
=
>
{
if
let
Some
(
crate
:
:
ScalarKind
:
:
Sint
)
=
inner
.
scalar_kind
(
)
{
self
.
need_bake_expressions
.
insert
(
arg
)
;
}
}
_
=
>
{
}
}
}
}
}
fn
get_global_name
(
&
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
String
{
match
global
.
binding
{
Some
(
ref
br
)
=
>
{
format
!
(
"
_group_
{
}
_binding_
{
}
_
{
}
"
br
.
group
br
.
binding
self
.
entry_point
.
stage
.
to_str
(
)
)
}
None
=
>
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
.
clone
(
)
}
}
fn
write_global_name
(
&
mut
self
handle
:
Handle
<
crate
:
:
GlobalVariable
>
global
:
&
crate
:
:
GlobalVariable
)
-
>
BackendResult
{
match
global
.
binding
{
Some
(
ref
br
)
=
>
write
!
(
self
.
out
"
_group_
{
}
_binding_
{
}
_
{
}
"
br
.
group
br
.
binding
self
.
entry_point
.
stage
.
to_str
(
)
)
?
None
=
>
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
)
?
}
Ok
(
(
)
)
}
fn
write_varying
(
&
mut
self
binding
:
Option
<
&
crate
:
:
Binding
>
ty
:
Handle
<
crate
:
:
Type
>
output
:
bool
)
-
>
Result
<
(
)
Error
>
{
if
let
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
self
.
module
.
types
[
ty
]
.
inner
{
for
member
in
members
{
self
.
write_varying
(
member
.
binding
.
as_ref
(
)
member
.
ty
output
)
?
;
}
return
Ok
(
(
)
)
;
}
let
binding
=
match
binding
{
None
=
>
return
Ok
(
(
)
)
Some
(
binding
)
=
>
binding
}
;
let
(
location
interpolation
sampling
second_blend_source
)
=
match
*
binding
{
crate
:
:
Binding
:
:
Location
{
location
interpolation
sampling
second_blend_source
}
=
>
(
location
interpolation
sampling
second_blend_source
)
crate
:
:
Binding
:
:
BuiltIn
(
built_in
)
=
>
{
if
let
crate
:
:
BuiltIn
:
:
Position
{
invariant
:
true
}
=
built_in
{
match
(
self
.
options
.
version
self
.
entry_point
.
stage
)
{
(
Version
:
:
Embedded
{
version
:
300
is_webgl
:
true
}
ShaderStage
:
:
Fragment
)
=
>
{
}
_
=
>
{
writeln
!
(
self
.
out
"
invariant
{
}
;
"
glsl_built_in
(
built_in
output
self
.
options
.
version
.
is_webgl
(
)
)
)
?
;
}
}
}
return
Ok
(
(
)
)
;
}
}
;
let
emit_interpolation_and_auxiliary
=
match
self
.
entry_point
.
stage
{
ShaderStage
:
:
Vertex
=
>
output
ShaderStage
:
:
Fragment
=
>
!
output
ShaderStage
:
:
Compute
=
>
false
}
;
if
self
.
options
.
version
.
supports_explicit_locations
(
)
|
|
!
emit_interpolation_and_auxiliary
{
if
second_blend_source
{
write
!
(
self
.
out
"
layout
(
location
=
{
location
}
index
=
1
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
layout
(
location
=
{
location
}
)
"
)
?
;
}
}
if
let
Some
(
interp
)
=
interpolation
{
if
emit_interpolation_and_auxiliary
{
write
!
(
self
.
out
"
{
}
"
glsl_interpolation
(
interp
)
)
?
;
}
}
if
let
Some
(
sampling
)
=
sampling
{
if
emit_interpolation_and_auxiliary
{
if
let
Some
(
qualifier
)
=
glsl_sampling
(
sampling
)
{
write
!
(
self
.
out
"
{
qualifier
}
"
)
?
;
}
}
}
write
!
(
self
.
out
"
{
}
"
if
output
{
"
out
"
}
else
{
"
in
"
}
)
?
;
self
.
write_type
(
ty
)
?
;
let
vname
=
VaryingName
{
binding
:
&
crate
:
:
Binding
:
:
Location
{
location
interpolation
:
None
sampling
:
None
second_blend_source
}
stage
:
self
.
entry_point
.
stage
output
targetting_webgl
:
self
.
options
.
version
.
is_webgl
(
)
}
;
writeln
!
(
self
.
out
"
{
vname
}
;
"
)
?
;
Ok
(
(
)
)
}
fn
write_function
(
&
mut
self
ty
:
back
:
:
FunctionType
func
:
&
crate
:
:
Function
info
:
&
valid
:
:
FunctionInfo
)
-
>
BackendResult
{
let
ctx
=
back
:
:
FunctionCtx
{
ty
info
expressions
:
&
func
.
expressions
named_expressions
:
&
func
.
named_expressions
}
;
self
.
named_expressions
.
clear
(
)
;
self
.
update_expressions_to_bake
(
func
info
)
;
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
_
)
=
ctx
.
ty
{
write
!
(
self
.
out
"
void
"
)
?
;
}
else
if
let
Some
(
ref
result
)
=
func
.
result
{
self
.
write_type
(
result
.
ty
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
result
.
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
}
}
else
{
write
!
(
self
.
out
"
void
"
)
?
;
}
let
function_name
=
match
ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
handle
)
=
>
&
self
.
names
[
&
NameKey
:
:
Function
(
handle
)
]
back
:
:
FunctionType
:
:
EntryPoint
(
_
)
=
>
"
main
"
}
;
write
!
(
self
.
out
"
{
function_name
}
(
"
)
?
;
let
arguments
=
match
ctx
.
ty
{
back
:
:
FunctionType
:
:
EntryPoint
(
_
)
=
>
&
[
]
[
.
.
]
back
:
:
FunctionType
:
:
Function
(
_
)
=
>
&
func
.
arguments
}
;
let
arguments
:
Vec
<
_
>
=
arguments
.
iter
(
)
.
enumerate
(
)
.
filter
(
|
&
(
_
arg
)
|
match
self
.
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Sampler
{
.
.
}
=
>
false
_
=
>
true
}
)
.
collect
(
)
;
self
.
write_slice
(
&
arguments
|
this
_
&
(
i
arg
)
|
{
match
this
.
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
if
let
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
format
.
.
}
.
.
}
=
this
.
module
.
types
[
arg
.
ty
]
.
inner
{
write
!
(
this
.
out
"
layout
(
{
}
)
"
glsl_storage_format
(
format
)
)
?
;
}
this
.
write_image_type
(
dim
arrayed
class
)
?
;
}
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
{
write
!
(
this
.
out
"
inout
"
)
?
;
this
.
write_type
(
base
)
?
;
}
_
=
>
{
this
.
write_type
(
arg
.
ty
)
?
;
}
}
write
!
(
this
.
out
"
{
}
"
&
this
.
names
[
&
ctx
.
argument_key
(
i
as
u32
)
]
)
?
;
match
this
.
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
{
this
.
write_array_size
(
base
size
)
?
;
}
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
{
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
this
.
module
.
types
[
base
]
.
inner
{
this
.
write_array_size
(
base
size
)
?
;
}
}
_
=
>
{
}
}
Ok
(
(
)
)
}
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
if
self
.
options
.
zero_initialize_workgroup_memory
&
&
ctx
.
ty
.
is_compute_entry_point
(
self
.
module
)
{
self
.
write_workgroup_variables_initialization
(
&
ctx
)
?
;
}
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
ep_index
)
=
ctx
.
ty
{
let
stage
=
self
.
module
.
entry_points
[
ep_index
as
usize
]
.
stage
;
for
(
index
arg
)
in
func
.
arguments
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
self
.
write_type
(
arg
.
ty
)
?
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
EntryPointArgument
(
ep_index
index
as
u32
)
]
;
write
!
(
self
.
out
"
{
name
}
"
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
match
self
.
module
.
types
[
arg
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
self
.
write_type
(
arg
.
ty
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
let
varying_name
=
VaryingName
{
binding
:
member
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
output
:
false
targetting_webgl
:
self
.
options
.
version
.
is_webgl
(
)
}
;
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
write
!
(
self
.
out
"
{
varying_name
}
"
)
?
;
}
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
_
=
>
{
let
varying_name
=
VaryingName
{
binding
:
arg
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
output
:
false
targetting_webgl
:
self
.
options
.
version
.
is_webgl
(
)
}
;
writeln
!
(
self
.
out
"
{
varying_name
}
;
"
)
?
;
}
}
}
}
for
(
handle
local
)
in
func
.
local_variables
.
iter
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
self
.
write_type
(
local
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
local
.
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
;
}
if
let
Some
(
init
)
=
local
.
init
{
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_const_expr
(
init
)
?
;
}
else
if
is_value_init_supported
(
self
.
module
local
.
ty
)
{
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_zero_init_value
(
local
.
ty
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
}
for
sta
in
func
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
&
ctx
back
:
:
Level
(
1
)
)
?
;
}
writeln
!
(
self
.
out
"
}
}
"
)
?
;
Ok
(
(
)
)
}
fn
write_workgroup_variables_initialization
(
&
mut
self
ctx
:
&
back
:
:
FunctionCtx
)
-
>
BackendResult
{
let
mut
vars
=
self
.
module
.
global_variables
.
iter
(
)
.
filter
(
|
&
(
handle
var
)
|
{
!
ctx
.
info
[
handle
]
.
is_empty
(
)
&
&
var
.
space
=
=
crate
:
:
AddressSpace
:
:
WorkGroup
}
)
.
peekable
(
)
;
if
vars
.
peek
(
)
.
is_some
(
)
{
let
level
=
back
:
:
Level
(
1
)
;
writeln
!
(
self
.
out
"
{
level
}
if
(
gl_LocalInvocationID
=
=
uvec3
(
0u
)
)
{
{
"
)
?
;
for
(
handle
var
)
in
vars
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
;
write
!
(
self
.
out
"
{
}
{
}
=
"
level
.
next
(
)
name
)
?
;
self
.
write_zero_init_value
(
var
.
ty
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
writeln
!
(
self
.
out
"
{
level
}
}
}
"
)
?
;
self
.
write_barrier
(
crate
:
:
Barrier
:
:
WORK_GROUP
level
)
?
;
}
Ok
(
(
)
)
}
fn
write_slice
<
T
F
:
FnMut
(
&
mut
Self
u32
&
T
)
-
>
BackendResult
>
(
&
mut
self
data
:
&
[
T
]
mut
f
:
F
)
-
>
BackendResult
{
for
(
index
item
)
in
data
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
f
(
self
index
as
u32
item
)
?
;
}
Ok
(
(
)
)
}
fn
write_global_constant
(
&
mut
self
handle
:
Handle
<
crate
:
:
Constant
>
)
-
>
BackendResult
{
write
!
(
self
.
out
"
const
"
)
?
;
let
constant
=
&
self
.
module
.
constants
[
handle
]
;
self
.
write_type
(
constant
.
ty
)
?
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
Constant
(
handle
)
]
;
write
!
(
self
.
out
"
{
name
}
"
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
constant
.
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
;
}
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_const_expr
(
constant
.
init
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
Ok
(
(
)
)
}
fn
write_dot_product
(
&
mut
self
arg
:
Handle
<
crate
:
:
Expression
>
arg1
:
Handle
<
crate
:
:
Expression
>
size
:
usize
ctx
:
&
back
:
:
FunctionCtx
<
'
_
>
)
-
>
BackendResult
{
write
!
(
self
.
out
"
(
"
)
?
;
for
index
in
0
.
.
size
{
let
component
=
back
:
:
COMPONENTS
[
index
]
;
write
!
(
self
.
out
"
+
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
.
{
component
}
*
"
)
?
;
self
.
write_expr
(
arg1
ctx
)
?
;
write
!
(
self
.
out
"
.
{
component
}
"
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
Ok
(
(
)
)
}
fn
write_struct_body
(
&
mut
self
handle
:
Handle
<
crate
:
:
Type
>
members
:
&
[
crate
:
:
StructMember
]
)
-
>
BackendResult
{
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
(
idx
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
match
self
.
module
.
types
[
member
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
size
stride
:
_
}
=
>
{
self
.
write_type
(
base
)
?
;
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
self
.
write_array_size
(
base
size
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
_
=
>
{
self
.
write_type
(
member
.
ty
)
?
;
writeln
!
(
self
.
out
"
{
}
;
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
idx
as
u32
)
]
)
?
;
}
}
}
write
!
(
self
.
out
"
}
}
"
)
?
;
Ok
(
(
)
)
}
fn
write_stmt
(
&
mut
self
sta
:
&
crate
:
:
Statement
ctx
:
&
back
:
:
FunctionCtx
level
:
back
:
:
Level
)
-
>
BackendResult
{
use
crate
:
:
Statement
;
match
*
sta
{
Statement
:
:
Emit
(
ref
range
)
=
>
{
for
handle
in
range
.
clone
(
)
{
let
info
=
&
ctx
.
info
[
handle
]
;
let
ptr_class
=
info
.
ty
.
inner_with
(
&
self
.
module
.
types
)
.
pointer_space
(
)
;
let
expr_name
=
if
ptr_class
.
is_some
(
)
{
None
}
else
if
let
Some
(
name
)
=
ctx
.
named_expressions
.
get
(
&
handle
)
{
Some
(
self
.
namer
.
call
(
name
)
)
}
else
if
self
.
need_bake_expressions
.
contains
(
&
handle
)
{
Some
(
format
!
(
"
{
}
{
}
"
back
:
:
BAKE_PREFIX
handle
.
index
(
)
)
)
}
else
{
None
}
;
if
let
crate
:
:
Expression
:
:
ImageLoad
{
image
level
:
Some
(
level_expr
)
.
.
}
=
ctx
.
expressions
[
handle
]
{
if
let
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Sampled
{
.
.
}
.
.
}
=
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
if
let
proc
:
:
BoundsCheckPolicy
:
:
Restrict
=
self
.
policies
.
image_load
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
self
.
write_clamped_lod
(
ctx
handle
image
level_expr
)
?
}
}
}
if
let
Some
(
name
)
=
expr_name
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
self
.
write_named_expr
(
handle
name
handle
ctx
)
?
;
}
}
}
Statement
:
:
Block
(
ref
block
)
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
sta
in
block
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
}
writeln
!
(
self
.
out
"
{
level
}
}
}
"
)
?
}
Statement
:
:
If
{
condition
ref
accept
ref
reject
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
write
!
(
self
.
out
"
if
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
for
sta
in
accept
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
if
!
reject
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
level
}
}
}
else
{
{
"
)
?
;
for
sta
in
reject
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
}
writeln
!
(
self
.
out
"
{
level
}
}
}
"
)
?
}
Statement
:
:
Switch
{
selector
ref
cases
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
write
!
(
self
.
out
"
switch
(
"
)
?
;
self
.
write_expr
(
selector
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
let
l2
=
level
.
next
(
)
;
for
case
in
cases
{
match
case
.
value
{
crate
:
:
SwitchValue
:
:
I32
(
value
)
=
>
write
!
(
self
.
out
"
{
l2
}
case
{
value
}
:
"
)
?
crate
:
:
SwitchValue
:
:
U32
(
value
)
=
>
write
!
(
self
.
out
"
{
l2
}
case
{
value
}
u
:
"
)
?
crate
:
:
SwitchValue
:
:
Default
=
>
write
!
(
self
.
out
"
{
l2
}
default
:
"
)
?
}
let
write_block_braces
=
!
(
case
.
fall_through
&
&
case
.
body
.
is_empty
(
)
)
;
if
write_block_braces
{
writeln
!
(
self
.
out
"
{
{
"
)
?
;
}
else
{
writeln
!
(
self
.
out
)
?
;
}
for
sta
in
case
.
body
.
iter
(
)
{
self
.
write_stmt
(
sta
ctx
l2
.
next
(
)
)
?
;
}
if
!
case
.
fall_through
&
&
case
.
body
.
last
(
)
.
map_or
(
true
|
s
|
!
s
.
is_terminator
(
)
)
{
writeln
!
(
self
.
out
"
{
}
break
;
"
l2
.
next
(
)
)
?
;
}
if
write_block_braces
{
writeln
!
(
self
.
out
"
{
l2
}
}
}
"
)
?
;
}
}
writeln
!
(
self
.
out
"
{
level
}
}
}
"
)
?
}
Statement
:
:
Loop
{
ref
body
ref
continuing
break_if
}
=
>
{
if
!
continuing
.
is_empty
(
)
|
|
break_if
.
is_some
(
)
{
let
gate_name
=
self
.
namer
.
call
(
"
loop_init
"
)
;
writeln
!
(
self
.
out
"
{
level
}
bool
{
gate_name
}
=
true
;
"
)
?
;
writeln
!
(
self
.
out
"
{
level
}
while
(
true
)
{
{
"
)
?
;
let
l2
=
level
.
next
(
)
;
let
l3
=
l2
.
next
(
)
;
writeln
!
(
self
.
out
"
{
l2
}
if
(
!
{
gate_name
}
)
{
{
"
)
?
;
for
sta
in
continuing
{
self
.
write_stmt
(
sta
ctx
l3
)
?
;
}
if
let
Some
(
condition
)
=
break_if
{
write
!
(
self
.
out
"
{
l3
}
if
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
writeln
!
(
self
.
out
"
{
}
break
;
"
l3
.
next
(
)
)
?
;
writeln
!
(
self
.
out
"
{
l3
}
}
}
"
)
?
;
}
writeln
!
(
self
.
out
"
{
l2
}
}
}
"
)
?
;
writeln
!
(
self
.
out
"
{
}
{
}
=
false
;
"
level
.
next
(
)
gate_name
)
?
;
}
else
{
writeln
!
(
self
.
out
"
{
level
}
while
(
true
)
{
{
"
)
?
;
}
for
sta
in
body
{
self
.
write_stmt
(
sta
ctx
level
.
next
(
)
)
?
;
}
writeln
!
(
self
.
out
"
{
level
}
}
}
"
)
?
}
Statement
:
:
Break
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
writeln
!
(
self
.
out
"
break
;
"
)
?
}
Statement
:
:
Continue
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
writeln
!
(
self
.
out
"
continue
;
"
)
?
}
Statement
:
:
Return
{
value
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
match
ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
_
)
=
>
{
write
!
(
self
.
out
"
return
"
)
?
;
if
let
Some
(
expr
)
=
value
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
;
}
back
:
:
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
{
let
mut
has_point_size
=
false
;
let
ep
=
&
self
.
module
.
entry_points
[
ep_index
as
usize
]
;
if
let
Some
(
ref
result
)
=
ep
.
function
.
result
{
let
value
=
value
.
unwrap
(
)
;
match
self
.
module
.
types
[
result
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
let
temp_struct_name
=
match
ctx
.
expressions
[
value
]
{
crate
:
:
Expression
:
:
Compose
{
.
.
}
=
>
{
let
return_struct
=
"
_tmp_return
"
;
write
!
(
self
.
out
"
{
}
{
}
=
"
&
self
.
names
[
&
NameKey
:
:
Type
(
result
.
ty
)
]
return_struct
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
write
!
(
self
.
out
"
{
level
}
"
)
?
;
Some
(
return_struct
)
}
_
=
>
None
}
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
if
let
Some
(
crate
:
:
Binding
:
:
BuiltIn
(
crate
:
:
BuiltIn
:
:
PointSize
)
)
=
member
.
binding
{
has_point_size
=
true
;
}
let
varying_name
=
VaryingName
{
binding
:
member
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
:
ep
.
stage
output
:
true
targetting_webgl
:
self
.
options
.
version
.
is_webgl
(
)
}
;
write
!
(
self
.
out
"
{
varying_name
}
=
"
)
?
;
if
let
Some
(
struct_name
)
=
temp_struct_name
{
write
!
(
self
.
out
"
{
struct_name
}
"
)
?
;
}
else
{
self
.
write_expr
(
value
ctx
)
?
;
}
writeln
!
(
self
.
out
"
.
{
}
;
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
result
.
ty
index
as
u32
)
]
)
?
;
write
!
(
self
.
out
"
{
level
}
"
)
?
;
}
}
_
=
>
{
let
name
=
VaryingName
{
binding
:
result
.
binding
.
as_ref
(
)
.
unwrap
(
)
stage
:
ep
.
stage
output
:
true
targetting_webgl
:
self
.
options
.
version
.
is_webgl
(
)
}
;
write
!
(
self
.
out
"
{
name
}
=
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
write
!
(
self
.
out
"
{
level
}
"
)
?
;
}
}
}
let
is_vertex_stage
=
self
.
module
.
entry_points
[
ep_index
as
usize
]
.
stage
=
=
ShaderStage
:
:
Vertex
;
if
is_vertex_stage
&
&
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
ADJUST_COORDINATE_SPACE
)
{
writeln
!
(
self
.
out
"
gl_Position
.
yz
=
vec2
(
-
gl_Position
.
y
gl_Position
.
z
*
2
.
0
-
gl_Position
.
w
)
;
"
)
?
;
write
!
(
self
.
out
"
{
level
}
"
)
?
;
}
if
is_vertex_stage
&
&
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
FORCE_POINT_SIZE
)
&
&
!
has_point_size
{
writeln
!
(
self
.
out
"
gl_PointSize
=
1
.
0
;
"
)
?
;
write
!
(
self
.
out
"
{
level
}
"
)
?
;
}
writeln
!
(
self
.
out
"
return
;
"
)
?
;
}
}
}
Statement
:
:
Kill
=
>
writeln
!
(
self
.
out
"
{
level
}
discard
;
"
)
?
Statement
:
:
Barrier
(
flags
)
=
>
{
self
.
write_barrier
(
flags
level
)
?
;
}
Statement
:
:
Store
{
pointer
value
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
self
.
write_expr
(
pointer
ctx
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
}
Statement
:
:
WorkGroupUniformLoad
{
pointer
result
}
=
>
{
self
.
write_barrier
(
crate
:
:
Barrier
:
:
WORK_GROUP
level
)
?
;
let
result_name
=
format
!
(
"
{
}
{
}
"
back
:
:
BAKE_PREFIX
result
.
index
(
)
)
;
write
!
(
self
.
out
"
{
level
}
"
)
?
;
self
.
write_named_expr
(
pointer
result_name
result
ctx
)
?
;
self
.
write_barrier
(
crate
:
:
Barrier
:
:
WORK_GROUP
level
)
?
;
}
Statement
:
:
ImageStore
{
image
coordinate
array_index
value
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
self
.
write_image_store
(
ctx
image
coordinate
array_index
value
)
?
}
Statement
:
:
Call
{
function
ref
arguments
result
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
if
let
Some
(
expr
)
=
result
{
let
name
=
format
!
(
"
{
}
{
}
"
back
:
:
BAKE_PREFIX
expr
.
index
(
)
)
;
let
result
=
self
.
module
.
functions
[
function
]
.
result
.
as_ref
(
)
.
unwrap
(
)
;
self
.
write_type
(
result
.
ty
)
?
;
write
!
(
self
.
out
"
{
name
}
"
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
result
.
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
}
write
!
(
self
.
out
"
=
"
)
?
;
self
.
named_expressions
.
insert
(
expr
name
)
;
}
write
!
(
self
.
out
"
{
}
(
"
&
self
.
names
[
&
NameKey
:
:
Function
(
function
)
]
)
?
;
let
arguments
:
Vec
<
_
>
=
arguments
.
iter
(
)
.
enumerate
(
)
.
filter_map
(
|
(
i
arg
)
|
{
let
arg_ty
=
self
.
module
.
functions
[
function
]
.
arguments
[
i
]
.
ty
;
match
self
.
module
.
types
[
arg_ty
]
.
inner
{
TypeInner
:
:
Sampler
{
.
.
}
=
>
None
_
=
>
Some
(
*
arg
)
}
}
)
.
collect
(
)
;
self
.
write_slice
(
&
arguments
|
this
_
arg
|
this
.
write_expr
(
*
arg
ctx
)
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
}
Statement
:
:
Atomic
{
pointer
ref
fun
value
result
}
=
>
{
write
!
(
self
.
out
"
{
level
}
"
)
?
;
let
res_name
=
format
!
(
"
{
}
{
}
"
back
:
:
BAKE_PREFIX
result
.
index
(
)
)
;
let
res_ty
=
ctx
.
info
[
result
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
self
.
write_value_type
(
res_ty
)
?
;
write
!
(
self
.
out
"
{
res_name
}
=
"
)
?
;
self
.
named_expressions
.
insert
(
result
res_name
)
;
let
fun_str
=
fun
.
to_glsl
(
)
;
write
!
(
self
.
out
"
atomic
{
fun_str
}
(
"
)
?
;
self
.
write_expr
(
pointer
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
match
*
fun
{
crate
:
:
AtomicFunction
:
:
Subtract
=
>
{
write
!
(
self
.
out
"
-
"
)
?
;
}
crate
:
:
AtomicFunction
:
:
Exchange
{
compare
:
Some
(
_
)
}
=
>
{
return
Err
(
Error
:
:
Custom
(
"
atomic
CompareExchange
is
not
implemented
"
.
to_string
(
)
)
)
;
}
_
=
>
{
}
}
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
Statement
:
:
RayQuery
{
.
.
}
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_const_expr
(
&
mut
self
expr
:
Handle
<
crate
:
:
Expression
>
)
-
>
BackendResult
{
self
.
write_possibly_const_expr
(
expr
&
self
.
module
.
const_expressions
|
writer
expr
|
{
writer
.
write_const_expr
(
expr
)
}
)
}
fn
write_possibly_const_expr
<
E
>
(
&
mut
self
expr
:
Handle
<
crate
:
:
Expression
>
expressions
:
&
crate
:
:
Arena
<
crate
:
:
Expression
>
write_expression
:
E
)
-
>
BackendResult
where
E
:
Fn
(
&
mut
Self
Handle
<
crate
:
:
Expression
>
)
-
>
BackendResult
{
use
crate
:
:
Expression
;
match
expressions
[
expr
]
{
Expression
:
:
Literal
(
literal
)
=
>
{
match
literal
{
crate
:
:
Literal
:
:
F64
(
value
)
=
>
write
!
(
self
.
out
"
{
:
?
}
LF
"
value
)
?
crate
:
:
Literal
:
:
F32
(
value
)
=
>
write
!
(
self
.
out
"
{
:
?
}
"
value
)
?
crate
:
:
Literal
:
:
U32
(
value
)
=
>
write
!
(
self
.
out
"
{
}
u
"
value
)
?
crate
:
:
Literal
:
:
I32
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
crate
:
:
Literal
:
:
Bool
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
}
}
Expression
:
:
Constant
(
handle
)
=
>
{
let
constant
=
&
self
.
module
.
constants
[
handle
]
;
if
constant
.
name
.
is_some
(
)
{
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
NameKey
:
:
Constant
(
handle
)
]
)
?
;
}
else
{
self
.
write_const_expr
(
constant
.
init
)
?
;
}
}
Expression
:
:
ZeroValue
(
ty
)
=
>
{
self
.
write_zero_init_value
(
ty
)
?
;
}
Expression
:
:
Compose
{
ty
ref
components
}
=
>
{
self
.
write_type
(
ty
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
self
.
module
.
types
[
ty
]
.
inner
{
self
.
write_array_size
(
base
size
)
?
;
}
write
!
(
self
.
out
"
(
"
)
?
;
for
(
index
component
)
in
components
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
write_expression
(
self
*
component
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
_
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_expr
(
&
mut
self
expr
:
Handle
<
crate
:
:
Expression
>
ctx
:
&
back
:
:
FunctionCtx
<
'
_
>
)
-
>
BackendResult
{
use
crate
:
:
Expression
;
if
let
Some
(
name
)
=
self
.
named_expressions
.
get
(
&
expr
)
{
write
!
(
self
.
out
"
{
name
}
"
)
?
;
return
Ok
(
(
)
)
;
}
match
ctx
.
expressions
[
expr
]
{
Expression
:
:
Literal
(
_
)
|
Expression
:
:
Constant
(
_
)
|
Expression
:
:
ZeroValue
(
_
)
|
Expression
:
:
Compose
{
.
.
}
=
>
{
self
.
write_possibly_const_expr
(
expr
ctx
.
expressions
|
writer
expr
|
{
writer
.
write_expr
(
expr
ctx
)
}
)
?
;
}
Expression
:
:
Access
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
self
.
write_expr
(
index
ctx
)
?
;
write
!
(
self
.
out
"
]
"
)
?
}
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
self
.
write_expr
(
base
ctx
)
?
;
let
base_ty_res
=
&
ctx
.
info
[
base
]
.
ty
;
let
mut
resolved
=
base_ty_res
.
inner_with
(
&
self
.
module
.
types
)
;
let
base_ty_handle
=
match
*
resolved
{
TypeInner
:
:
Pointer
{
base
space
:
_
}
=
>
{
resolved
=
&
self
.
module
.
types
[
base
]
.
inner
;
Some
(
base
)
}
_
=
>
base_ty_res
.
handle
(
)
}
;
match
*
resolved
{
TypeInner
:
:
Vector
{
.
.
}
=
>
{
write
!
(
self
.
out
"
.
{
}
"
back
:
:
COMPONENTS
[
index
as
usize
]
)
?
}
TypeInner
:
:
Matrix
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
|
TypeInner
:
:
ValuePointer
{
.
.
}
=
>
write
!
(
self
.
out
"
[
{
index
}
]
"
)
?
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty
=
base_ty_handle
.
unwrap
(
)
;
write
!
(
self
.
out
"
.
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
index
)
]
)
?
}
ref
other
=
>
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
index
{
other
:
?
}
"
)
)
)
}
}
Expression
:
:
Splat
{
size
:
_
value
}
=
>
{
let
resolved
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
self
.
write_value_type
(
resolved
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Swizzle
{
size
vector
pattern
}
=
>
{
self
.
write_expr
(
vector
ctx
)
?
;
write
!
(
self
.
out
"
.
"
)
?
;
for
&
sc
in
pattern
[
.
.
size
as
usize
]
.
iter
(
)
{
self
.
out
.
write_char
(
back
:
:
COMPONENTS
[
sc
as
usize
]
)
?
;
}
}
Expression
:
:
FunctionArgument
(
pos
)
=
>
{
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
ctx
.
argument_key
(
pos
)
]
)
?
}
Expression
:
:
GlobalVariable
(
handle
)
=
>
{
let
global
=
&
self
.
module
.
global_variables
[
handle
]
;
self
.
write_global_name
(
handle
global
)
?
}
Expression
:
:
LocalVariable
(
handle
)
=
>
{
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
ctx
.
name_key
(
handle
)
]
)
?
}
Expression
:
:
Load
{
pointer
}
=
>
self
.
write_expr
(
pointer
ctx
)
?
Expression
:
:
ImageSample
{
image
sampler
:
_
gather
coordinate
array_index
offset
level
depth_ref
}
=
>
{
let
dim
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
.
.
}
=
>
dim
_
=
>
unreachable
!
(
)
}
;
if
dim
=
=
crate
:
:
ImageDimension
:
:
Cube
&
&
array_index
.
is_some
(
)
&
&
depth_ref
.
is_some
(
)
{
match
level
{
crate
:
:
SampleLevel
:
:
Zero
|
crate
:
:
SampleLevel
:
:
Exact
(
_
)
|
crate
:
:
SampleLevel
:
:
Gradient
{
.
.
}
|
crate
:
:
SampleLevel
:
:
Bias
(
_
)
=
>
{
return
Err
(
Error
:
:
Custom
(
String
:
:
from
(
"
gsamplerCubeArrayShadow
isn
'
t
supported
in
textureGrad
\
textureLod
or
texture
with
bias
"
)
)
)
}
crate
:
:
SampleLevel
:
:
Auto
=
>
{
}
}
}
let
workaround_lod_array_shadow_as_grad
=
(
array_index
.
is_some
(
)
|
|
dim
=
=
crate
:
:
ImageDimension
:
:
Cube
)
&
&
depth_ref
.
is_some
(
)
&
&
gather
.
is_none
(
)
&
&
!
self
.
options
.
writer_flags
.
contains
(
WriterFlags
:
:
TEXTURE_SHADOW_LOD
)
;
let
fun_name
=
match
level
{
crate
:
:
SampleLevel
:
:
Zero
if
gather
.
is_some
(
)
=
>
"
textureGather
"
crate
:
:
SampleLevel
:
:
Auto
|
crate
:
:
SampleLevel
:
:
Bias
(
_
)
=
>
"
texture
"
crate
:
:
SampleLevel
:
:
Zero
|
crate
:
:
SampleLevel
:
:
Exact
(
_
)
=
>
{
if
workaround_lod_array_shadow_as_grad
{
"
textureGrad
"
}
else
{
"
textureLod
"
}
}
crate
:
:
SampleLevel
:
:
Gradient
{
.
.
}
=
>
"
textureGrad
"
}
;
let
offset_name
=
match
offset
{
Some
(
_
)
=
>
"
Offset
"
None
=
>
"
"
}
;
write
!
(
self
.
out
"
{
fun_name
}
{
offset_name
}
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
let
mut
coord_dim
=
match
*
ctx
.
info
[
coordinate
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
size
as
u8
TypeInner
:
:
Scalar
{
.
.
}
=
>
1
_
=
>
unreachable
!
(
)
}
;
if
array_index
.
is_some
(
)
{
coord_dim
+
=
1
;
}
let
merge_depth_ref
=
depth_ref
.
is_some
(
)
&
&
gather
.
is_none
(
)
&
&
coord_dim
<
4
;
if
merge_depth_ref
{
coord_dim
+
=
1
;
}
let
tex_1d_hack
=
dim
=
=
crate
:
:
ImageDimension
:
:
D1
&
&
self
.
options
.
version
.
is_es
(
)
;
let
is_vec
=
tex_1d_hack
|
|
coord_dim
!
=
1
;
if
is_vec
{
write
!
(
self
.
out
"
vec
{
}
(
"
coord_dim
+
tex_1d_hack
as
u8
)
?
;
}
self
.
write_expr
(
coordinate
ctx
)
?
;
if
tex_1d_hack
{
write
!
(
self
.
out
"
0
.
0
"
)
?
;
}
if
let
Some
(
expr
)
=
array_index
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
if
merge_depth_ref
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
depth_ref
.
unwrap
(
)
ctx
)
?
;
}
if
is_vec
{
write
!
(
self
.
out
"
)
"
)
?
;
}
if
let
(
Some
(
expr
)
false
)
=
(
depth_ref
merge_depth_ref
)
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
match
level
{
crate
:
:
SampleLevel
:
:
Auto
=
>
(
)
crate
:
:
SampleLevel
:
:
Zero
=
>
{
if
workaround_lod_array_shadow_as_grad
{
let
vec_dim
=
match
dim
{
crate
:
:
ImageDimension
:
:
Cube
=
>
3
_
=
>
2
}
;
write
!
(
self
.
out
"
vec
{
vec_dim
}
(
0
.
0
)
vec
{
vec_dim
}
(
0
.
0
)
"
)
?
;
}
else
if
gather
.
is_none
(
)
{
write
!
(
self
.
out
"
0
.
0
"
)
?
;
}
}
crate
:
:
SampleLevel
:
:
Exact
(
expr
)
=
>
{
if
workaround_lod_array_shadow_as_grad
{
log
:
:
warn
!
(
"
Unable
to
textureLod
a
shadow
array
ignoring
the
LOD
"
)
;
write
!
(
self
.
out
"
vec2
(
0
0
)
vec2
(
0
0
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
}
crate
:
:
SampleLevel
:
:
Bias
(
_
)
=
>
{
}
crate
:
:
SampleLevel
:
:
Gradient
{
x
y
}
=
>
{
if
tex_1d_hack
{
write
!
(
self
.
out
"
vec2
(
"
)
?
;
self
.
write_expr
(
x
ctx
)
?
;
write
!
(
self
.
out
"
0
.
0
)
"
)
?
;
write
!
(
self
.
out
"
vec2
(
"
)
?
;
self
.
write_expr
(
y
ctx
)
?
;
write
!
(
self
.
out
"
0
.
0
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
x
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
y
ctx
)
?
;
}
}
}
if
let
Some
(
constant
)
=
offset
{
write
!
(
self
.
out
"
"
)
?
;
if
tex_1d_hack
{
write
!
(
self
.
out
"
ivec2
(
"
)
?
;
}
self
.
write_const_expr
(
constant
)
?
;
if
tex_1d_hack
{
write
!
(
self
.
out
"
0
)
"
)
?
;
}
}
if
let
crate
:
:
SampleLevel
:
:
Bias
(
expr
)
=
level
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
}
if
let
(
Some
(
component
)
None
)
=
(
gather
depth_ref
)
{
write
!
(
self
.
out
"
{
}
"
component
as
usize
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
ImageLoad
{
image
coordinate
array_index
sample
level
}
=
>
self
.
write_image_load
(
expr
ctx
image
coordinate
array_index
sample
level
)
?
Expression
:
:
ImageQuery
{
image
query
}
=
>
{
use
crate
:
:
ImageClass
;
let
(
dim
class
)
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
components
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
1
crate
:
:
ImageDimension
:
:
D2
=
>
2
crate
:
:
ImageDimension
:
:
D3
=
>
3
crate
:
:
ImageDimension
:
:
Cube
=
>
2
}
;
if
let
crate
:
:
ImageQuery
:
:
Size
{
.
.
}
=
query
{
match
components
{
1
=
>
write
!
(
self
.
out
"
uint
(
"
)
?
_
=
>
write
!
(
self
.
out
"
uvec
{
components
}
(
"
)
?
}
}
else
{
write
!
(
self
.
out
"
uint
(
"
)
?
;
}
match
query
{
crate
:
:
ImageQuery
:
:
Size
{
level
}
=
>
{
match
class
{
ImageClass
:
:
Sampled
{
multi
.
.
}
|
ImageClass
:
:
Depth
{
multi
}
=
>
{
write
!
(
self
.
out
"
textureSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
if
let
Some
(
expr
)
=
level
{
let
cast_to_int
=
matches
!
(
*
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
crate
:
:
TypeInner
:
:
Scalar
{
kind
:
crate
:
:
ScalarKind
:
:
Uint
.
.
}
)
;
write
!
(
self
.
out
"
"
)
?
;
if
cast_to_int
{
write
!
(
self
.
out
"
int
(
"
)
?
;
}
self
.
write_expr
(
expr
ctx
)
?
;
if
cast_to_int
{
write
!
(
self
.
out
"
)
"
)
?
;
}
}
else
if
!
multi
{
write
!
(
self
.
out
"
0
"
)
?
;
}
}
ImageClass
:
:
Storage
{
.
.
}
=
>
{
write
!
(
self
.
out
"
imageSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
"
)
?
;
if
components
!
=
1
|
|
self
.
options
.
version
.
is_es
(
)
{
write
!
(
self
.
out
"
.
{
}
"
&
"
xyz
"
[
.
.
components
]
)
?
;
}
}
crate
:
:
ImageQuery
:
:
NumLevels
=
>
{
write
!
(
self
.
out
"
textureQueryLevels
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
crate
:
:
ImageQuery
:
:
NumLayers
=
>
{
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
{
.
.
}
=
>
"
textureSize
"
ImageClass
:
:
Storage
{
.
.
}
=
>
"
imageSize
"
}
;
write
!
(
self
.
out
"
{
fun_name
}
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
if
class
.
is_multisampled
(
)
{
write
!
(
self
.
out
"
0
"
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
if
components
!
=
1
|
|
self
.
options
.
version
.
is_es
(
)
{
write
!
(
self
.
out
"
.
{
}
"
back
:
:
COMPONENTS
[
components
]
)
?
;
}
}
crate
:
:
ImageQuery
:
:
NumSamples
=
>
{
let
fun_name
=
match
class
{
ImageClass
:
:
Sampled
{
.
.
}
|
ImageClass
:
:
Depth
{
.
.
}
=
>
{
"
textureSamples
"
}
ImageClass
:
:
Storage
{
.
.
}
=
>
"
imageSamples
"
}
;
write
!
(
self
.
out
"
{
fun_name
}
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
}
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
Unary
{
op
expr
}
=
>
{
use
crate
:
:
{
ScalarKind
as
Sk
UnaryOperator
as
Uo
}
;
let
ty
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
match
*
ty
{
TypeInner
:
:
Vector
{
kind
:
Sk
:
:
Bool
.
.
}
=
>
{
write
!
(
self
.
out
"
not
(
"
)
?
;
}
_
=
>
{
let
operator
=
match
op
{
Uo
:
:
Negate
=
>
"
-
"
Uo
:
:
Not
=
>
match
ty
.
scalar_kind
(
)
{
Some
(
Sk
:
:
Sint
)
|
Some
(
Sk
:
:
Uint
)
=
>
"
~
"
Some
(
Sk
:
:
Bool
)
=
>
"
!
"
ref
other
=
>
{
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
apply
not
to
type
{
other
:
?
}
"
)
)
)
}
}
}
;
write
!
(
self
.
out
"
{
operator
}
(
"
)
?
;
}
}
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Binary
{
mut
op
left
right
}
=
>
{
use
crate
:
:
{
BinaryOperator
as
Bo
ScalarKind
as
Sk
TypeInner
as
Ti
}
;
let
left_inner
=
ctx
.
info
[
left
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
let
right_inner
=
ctx
.
info
[
right
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
let
function
=
match
(
left_inner
right_inner
)
{
(
&
Ti
:
:
Vector
{
kind
.
.
}
&
Ti
:
:
Vector
{
.
.
}
)
=
>
match
op
{
Bo
:
:
Less
|
Bo
:
:
LessEqual
|
Bo
:
:
Greater
|
Bo
:
:
GreaterEqual
|
Bo
:
:
Equal
|
Bo
:
:
NotEqual
=
>
BinaryOperation
:
:
VectorCompare
Bo
:
:
Modulo
if
kind
=
=
Sk
:
:
Float
=
>
BinaryOperation
:
:
Modulo
Bo
:
:
And
if
kind
=
=
Sk
:
:
Bool
=
>
{
op
=
crate
:
:
BinaryOperator
:
:
LogicalAnd
;
BinaryOperation
:
:
VectorComponentWise
}
Bo
:
:
InclusiveOr
if
kind
=
=
Sk
:
:
Bool
=
>
{
op
=
crate
:
:
BinaryOperator
:
:
LogicalOr
;
BinaryOperation
:
:
VectorComponentWise
}
_
=
>
BinaryOperation
:
:
Other
}
_
=
>
match
(
left_inner
.
scalar_kind
(
)
right_inner
.
scalar_kind
(
)
)
{
(
Some
(
Sk
:
:
Float
)
_
)
|
(
_
Some
(
Sk
:
:
Float
)
)
=
>
match
op
{
Bo
:
:
Modulo
=
>
BinaryOperation
:
:
Modulo
_
=
>
BinaryOperation
:
:
Other
}
(
Some
(
Sk
:
:
Bool
)
Some
(
Sk
:
:
Bool
)
)
=
>
match
op
{
Bo
:
:
InclusiveOr
=
>
{
op
=
crate
:
:
BinaryOperator
:
:
LogicalOr
;
BinaryOperation
:
:
Other
}
Bo
:
:
And
=
>
{
op
=
crate
:
:
BinaryOperator
:
:
LogicalAnd
;
BinaryOperation
:
:
Other
}
_
=
>
BinaryOperation
:
:
Other
}
_
=
>
BinaryOperation
:
:
Other
}
}
;
match
function
{
BinaryOperation
:
:
VectorCompare
=
>
{
let
op_str
=
match
op
{
Bo
:
:
Less
=
>
"
lessThan
(
"
Bo
:
:
LessEqual
=
>
"
lessThanEqual
(
"
Bo
:
:
Greater
=
>
"
greaterThan
(
"
Bo
:
:
GreaterEqual
=
>
"
greaterThanEqual
(
"
Bo
:
:
Equal
=
>
"
equal
(
"
Bo
:
:
NotEqual
=
>
"
notEqual
(
"
_
=
>
unreachable
!
(
)
}
;
write
!
(
self
.
out
"
{
op_str
}
"
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
BinaryOperation
:
:
VectorComponentWise
=
>
{
self
.
write_value_type
(
left_inner
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
let
size
=
match
*
left_inner
{
Ti
:
:
Vector
{
size
.
.
}
=
>
size
_
=
>
unreachable
!
(
)
}
;
for
i
in
0
.
.
size
as
usize
{
if
i
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_expr
(
left
ctx
)
?
;
write
!
(
self
.
out
"
.
{
}
"
back
:
:
COMPONENTS
[
i
]
)
?
;
write
!
(
self
.
out
"
{
}
"
back
:
:
binary_operation_str
(
op
)
)
?
;
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
.
{
}
"
back
:
:
COMPONENTS
[
i
]
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
BinaryOperation
:
:
Modulo
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
write
!
(
self
.
out
"
-
"
)
?
;
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
*
"
)
?
;
write
!
(
self
.
out
"
trunc
(
"
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
write
!
(
self
.
out
"
/
"
)
?
;
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
BinaryOperation
:
:
Other
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
left
ctx
)
?
;
write
!
(
self
.
out
"
{
}
"
back
:
:
binary_operation_str
(
op
)
)
?
;
self
.
write_expr
(
right
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
}
}
Expression
:
:
Select
{
condition
accept
reject
}
=
>
{
let
cond_ty
=
ctx
.
info
[
condition
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
let
vec_select
=
if
let
TypeInner
:
:
Vector
{
.
.
}
=
*
cond_ty
{
true
}
else
{
false
}
;
if
vec_select
{
write
!
(
self
.
out
"
mix
(
"
)
?
;
self
.
write_expr
(
reject
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
accept
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
}
else
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
condition
ctx
)
?
;
write
!
(
self
.
out
"
?
"
)
?
;
self
.
write_expr
(
accept
ctx
)
?
;
write
!
(
self
.
out
"
:
"
)
?
;
self
.
write_expr
(
reject
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Derivative
{
axis
ctrl
expr
}
=
>
{
use
crate
:
:
{
DerivativeAxis
as
Axis
DerivativeControl
as
Ctrl
}
;
let
fun_name
=
if
self
.
options
.
version
.
supports_derivative_control
(
)
{
match
(
axis
ctrl
)
{
(
Axis
:
:
X
Ctrl
:
:
Coarse
)
=
>
"
dFdxCoarse
"
(
Axis
:
:
X
Ctrl
:
:
Fine
)
=
>
"
dFdxFine
"
(
Axis
:
:
X
Ctrl
:
:
None
)
=
>
"
dFdx
"
(
Axis
:
:
Y
Ctrl
:
:
Coarse
)
=
>
"
dFdyCoarse
"
(
Axis
:
:
Y
Ctrl
:
:
Fine
)
=
>
"
dFdyFine
"
(
Axis
:
:
Y
Ctrl
:
:
None
)
=
>
"
dFdy
"
(
Axis
:
:
Width
Ctrl
:
:
Coarse
)
=
>
"
fwidthCoarse
"
(
Axis
:
:
Width
Ctrl
:
:
Fine
)
=
>
"
fwidthFine
"
(
Axis
:
:
Width
Ctrl
:
:
None
)
=
>
"
fwidth
"
}
}
else
{
match
axis
{
Axis
:
:
X
=
>
"
dFdx
"
Axis
:
:
Y
=
>
"
dFdy
"
Axis
:
:
Width
=
>
"
fwidth
"
}
}
;
write
!
(
self
.
out
"
{
fun_name
}
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Relational
{
fun
argument
}
=
>
{
use
crate
:
:
RelationalFunction
as
Rf
;
let
fun_name
=
match
fun
{
Rf
:
:
IsFinite
=
>
"
!
isinf
"
Rf
:
:
IsInf
=
>
"
isinf
"
Rf
:
:
IsNan
=
>
"
isnan
"
Rf
:
:
IsNormal
=
>
"
!
isnan
"
Rf
:
:
All
=
>
"
all
"
Rf
:
:
Any
=
>
"
any
"
}
;
write
!
(
self
.
out
"
{
fun_name
}
(
"
)
?
;
self
.
write_expr
(
argument
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Math
{
fun
arg
arg1
arg2
arg3
}
=
>
{
use
crate
:
:
MathFunction
as
Mf
;
let
fun_name
=
match
fun
{
Mf
:
:
Abs
=
>
"
abs
"
Mf
:
:
Min
=
>
"
min
"
Mf
:
:
Max
=
>
"
max
"
Mf
:
:
Clamp
=
>
"
clamp
"
Mf
:
:
Saturate
=
>
{
write
!
(
self
.
out
"
clamp
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
match
*
ctx
.
info
[
arg
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
crate
:
:
TypeInner
:
:
Vector
{
size
.
.
}
=
>
write
!
(
self
.
out
"
vec
{
}
(
0
.
0
)
vec
{
0
}
(
1
.
0
)
"
back
:
:
vector_size_str
(
size
)
)
?
_
=
>
write
!
(
self
.
out
"
0
.
0
1
.
0
"
)
?
}
write
!
(
self
.
out
"
)
"
)
?
;
return
Ok
(
(
)
)
;
}
Mf
:
:
Cos
=
>
"
cos
"
Mf
:
:
Cosh
=
>
"
cosh
"
Mf
:
:
Sin
=
>
"
sin
"
Mf
:
:
Sinh
=
>
"
sinh
"
Mf
:
:
Tan
=
>
"
tan
"
Mf
:
:
Tanh
=
>
"
tanh
"
Mf
:
:
Acos
=
>
"
acos
"
Mf
:
:
Asin
=
>
"
asin
"
Mf
:
:
Atan
=
>
"
atan
"
Mf
:
:
Asinh
=
>
"
asinh
"
Mf
:
:
Acosh
=
>
"
acosh
"
Mf
:
:
Atanh
=
>
"
atanh
"
Mf
:
:
Radians
=
>
"
radians
"
Mf
:
:
Degrees
=
>
"
degrees
"
Mf
:
:
Atan2
=
>
"
atan
"
Mf
:
:
Ceil
=
>
"
ceil
"
Mf
:
:
Floor
=
>
"
floor
"
Mf
:
:
Round
=
>
"
roundEven
"
Mf
:
:
Fract
=
>
"
fract
"
Mf
:
:
Trunc
=
>
"
trunc
"
Mf
:
:
Modf
=
>
MODF_FUNCTION
Mf
:
:
Frexp
=
>
FREXP_FUNCTION
Mf
:
:
Ldexp
=
>
"
ldexp
"
Mf
:
:
Exp
=
>
"
exp
"
Mf
:
:
Exp2
=
>
"
exp2
"
Mf
:
:
Log
=
>
"
log
"
Mf
:
:
Log2
=
>
"
log2
"
Mf
:
:
Pow
=
>
"
pow
"
Mf
:
:
Dot
=
>
match
*
ctx
.
info
[
arg
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
crate
:
:
TypeInner
:
:
Vector
{
kind
:
crate
:
:
ScalarKind
:
:
Float
.
.
}
=
>
"
dot
"
crate
:
:
TypeInner
:
:
Vector
{
size
.
.
}
=
>
{
return
self
.
write_dot_product
(
arg
arg1
.
unwrap
(
)
size
as
usize
ctx
)
}
_
=
>
unreachable
!
(
"
Correct
TypeInner
for
dot
product
should
be
already
validated
"
)
}
Mf
:
:
Outer
=
>
"
outerProduct
"
Mf
:
:
Cross
=
>
"
cross
"
Mf
:
:
Distance
=
>
"
distance
"
Mf
:
:
Length
=
>
"
length
"
Mf
:
:
Normalize
=
>
"
normalize
"
Mf
:
:
FaceForward
=
>
"
faceforward
"
Mf
:
:
Reflect
=
>
"
reflect
"
Mf
:
:
Refract
=
>
"
refract
"
Mf
:
:
Sign
=
>
"
sign
"
Mf
:
:
Fma
=
>
{
if
self
.
options
.
version
.
supports_fma_function
(
)
{
"
fma
"
}
else
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
*
"
)
?
;
let
arg1
=
arg1
.
ok_or_else
(
|
|
Error
:
:
Custom
(
"
Missing
fma
arg1
"
.
to_owned
(
)
)
)
?
;
self
.
write_expr
(
arg1
ctx
)
?
;
write
!
(
self
.
out
"
+
"
)
?
;
let
arg2
=
arg2
.
ok_or_else
(
|
|
Error
:
:
Custom
(
"
Missing
fma
arg2
"
.
to_owned
(
)
)
)
?
;
self
.
write_expr
(
arg2
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
return
Ok
(
(
)
)
;
}
}
Mf
:
:
Mix
=
>
"
mix
"
Mf
:
:
Step
=
>
"
step
"
Mf
:
:
SmoothStep
=
>
"
smoothstep
"
Mf
:
:
Sqrt
=
>
"
sqrt
"
Mf
:
:
InverseSqrt
=
>
"
inversesqrt
"
Mf
:
:
Inverse
=
>
"
inverse
"
Mf
:
:
Transpose
=
>
"
transpose
"
Mf
:
:
Determinant
=
>
"
determinant
"
Mf
:
:
CountTrailingZeros
=
>
{
match
*
ctx
.
info
[
arg
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
crate
:
:
TypeInner
:
:
Vector
{
size
kind
.
.
}
=
>
{
let
s
=
back
:
:
vector_size_str
(
size
)
;
if
let
crate
:
:
ScalarKind
:
:
Uint
=
kind
{
write
!
(
self
.
out
"
min
(
uvec
{
s
}
(
findLSB
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
)
uvec
{
s
}
(
32u
)
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
ivec
{
s
}
(
min
(
uvec
{
s
}
(
findLSB
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
)
uvec
{
s
}
(
32u
)
)
)
"
)
?
;
}
}
crate
:
:
TypeInner
:
:
Scalar
{
kind
.
.
}
=
>
{
if
let
crate
:
:
ScalarKind
:
:
Uint
=
kind
{
write
!
(
self
.
out
"
min
(
uint
(
findLSB
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
)
32u
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
int
(
min
(
uint
(
findLSB
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
)
32u
)
)
"
)
?
;
}
}
_
=
>
unreachable
!
(
)
}
;
return
Ok
(
(
)
)
;
}
Mf
:
:
CountLeadingZeros
=
>
{
if
self
.
options
.
version
.
supports_integer_functions
(
)
{
match
*
ctx
.
info
[
arg
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
crate
:
:
TypeInner
:
:
Vector
{
size
kind
.
.
}
=
>
{
let
s
=
back
:
:
vector_size_str
(
size
)
;
if
let
crate
:
:
ScalarKind
:
:
Uint
=
kind
{
write
!
(
self
.
out
"
uvec
{
s
}
(
ivec
{
s
}
(
31
)
-
findMSB
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
mix
(
ivec
{
s
}
(
31
)
-
findMSB
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
ivec
{
s
}
(
0
)
lessThan
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
ivec
{
s
}
(
0
)
)
)
"
)
?
;
}
}
crate
:
:
TypeInner
:
:
Scalar
{
kind
.
.
}
=
>
{
if
let
crate
:
:
ScalarKind
:
:
Uint
=
kind
{
write
!
(
self
.
out
"
uint
(
31
-
findMSB
(
"
)
?
;
}
else
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
<
0
?
0
:
31
-
findMSB
(
"
)
?
;
}
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
)
"
)
?
;
}
_
=
>
unreachable
!
(
)
}
;
}
else
{
match
*
ctx
.
info
[
arg
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
crate
:
:
TypeInner
:
:
Vector
{
size
kind
.
.
}
=
>
{
let
s
=
back
:
:
vector_size_str
(
size
)
;
if
let
crate
:
:
ScalarKind
:
:
Uint
=
kind
{
write
!
(
self
.
out
"
uvec
{
s
}
(
"
)
?
;
write
!
(
self
.
out
"
vec
{
s
}
(
31
.
0
)
-
floor
(
log2
(
vec
{
s
}
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
+
0
.
5
)
)
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
ivec
{
s
}
(
"
)
?
;
write
!
(
self
.
out
"
mix
(
vec
{
s
}
(
31
.
0
)
-
floor
(
log2
(
vec
{
s
}
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
+
0
.
5
)
)
"
)
?
;
write
!
(
self
.
out
"
vec
{
s
}
(
0
.
0
)
lessThan
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
ivec
{
s
}
(
0u
)
)
)
)
"
)
?
;
}
}
crate
:
:
TypeInner
:
:
Scalar
{
kind
.
.
}
=
>
{
if
let
crate
:
:
ScalarKind
:
:
Uint
=
kind
{
write
!
(
self
.
out
"
uint
(
31
.
0
-
floor
(
log2
(
float
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
+
0
.
5
)
)
)
"
)
?
;
}
else
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
<
0
?
0
:
int
(
"
)
?
;
write
!
(
self
.
out
"
31
.
0
-
floor
(
log2
(
float
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
+
0
.
5
)
)
)
)
"
)
?
;
}
}
_
=
>
unreachable
!
(
)
}
;
}
return
Ok
(
(
)
)
;
}
Mf
:
:
CountOneBits
=
>
"
bitCount
"
Mf
:
:
ReverseBits
=
>
"
bitfieldReverse
"
Mf
:
:
ExtractBits
=
>
"
bitfieldExtract
"
Mf
:
:
InsertBits
=
>
"
bitfieldInsert
"
Mf
:
:
FindLsb
=
>
"
findLSB
"
Mf
:
:
FindMsb
=
>
"
findMSB
"
Mf
:
:
Pack4x8snorm
=
>
"
packSnorm4x8
"
Mf
:
:
Pack4x8unorm
=
>
"
packUnorm4x8
"
Mf
:
:
Pack2x16snorm
=
>
"
packSnorm2x16
"
Mf
:
:
Pack2x16unorm
=
>
"
packUnorm2x16
"
Mf
:
:
Pack2x16float
=
>
"
packHalf2x16
"
Mf
:
:
Unpack4x8snorm
=
>
"
unpackSnorm4x8
"
Mf
:
:
Unpack4x8unorm
=
>
"
unpackUnorm4x8
"
Mf
:
:
Unpack2x16snorm
=
>
"
unpackSnorm2x16
"
Mf
:
:
Unpack2x16unorm
=
>
"
unpackUnorm2x16
"
Mf
:
:
Unpack2x16float
=
>
"
unpackHalf2x16
"
}
;
let
extract_bits
=
fun
=
=
Mf
:
:
ExtractBits
;
let
insert_bits
=
fun
=
=
Mf
:
:
InsertBits
;
let
ret_might_need_int_to_uint
=
matches
!
(
fun
Mf
:
:
FindLsb
|
Mf
:
:
FindMsb
|
Mf
:
:
CountOneBits
|
Mf
:
:
Abs
)
;
let
arg_might_need_uint_to_int
=
matches
!
(
fun
Mf
:
:
Abs
)
;
let
maybe_uint_size
=
match
*
ctx
.
info
[
arg
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
crate
:
:
TypeInner
:
:
Scalar
{
kind
:
crate
:
:
ScalarKind
:
:
Uint
.
.
}
=
>
Some
(
None
)
crate
:
:
TypeInner
:
:
Vector
{
kind
:
crate
:
:
ScalarKind
:
:
Uint
size
.
.
}
=
>
Some
(
Some
(
size
)
)
_
=
>
None
}
;
if
ret_might_need_int_to_uint
{
if
let
Some
(
maybe_size
)
=
maybe_uint_size
{
match
maybe_size
{
Some
(
size
)
=
>
write
!
(
self
.
out
"
uvec
{
}
(
"
size
as
u8
)
?
None
=
>
write
!
(
self
.
out
"
uint
(
"
)
?
}
}
}
write
!
(
self
.
out
"
{
fun_name
}
(
"
)
?
;
if
arg_might_need_uint_to_int
{
if
let
Some
(
maybe_size
)
=
maybe_uint_size
{
match
maybe_size
{
Some
(
size
)
=
>
write
!
(
self
.
out
"
ivec
{
}
(
"
size
as
u8
)
?
None
=
>
write
!
(
self
.
out
"
int
(
"
)
?
}
}
}
self
.
write_expr
(
arg
ctx
)
?
;
if
arg_might_need_uint_to_int
&
&
maybe_uint_size
.
is_some
(
)
{
write
!
(
self
.
out
"
)
"
)
?
}
if
let
Some
(
arg
)
=
arg1
{
write
!
(
self
.
out
"
"
)
?
;
if
extract_bits
{
write
!
(
self
.
out
"
int
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
else
{
self
.
write_expr
(
arg
ctx
)
?
;
}
}
if
let
Some
(
arg
)
=
arg2
{
write
!
(
self
.
out
"
"
)
?
;
if
extract_bits
|
|
insert_bits
{
write
!
(
self
.
out
"
int
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
else
{
self
.
write_expr
(
arg
ctx
)
?
;
}
}
if
let
Some
(
arg
)
=
arg3
{
write
!
(
self
.
out
"
"
)
?
;
if
insert_bits
{
write
!
(
self
.
out
"
int
(
"
)
?
;
self
.
write_expr
(
arg
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
else
{
self
.
write_expr
(
arg
ctx
)
?
;
}
}
write
!
(
self
.
out
"
)
"
)
?
;
if
ret_might_need_int_to_uint
&
&
maybe_uint_size
.
is_some
(
)
{
write
!
(
self
.
out
"
)
"
)
?
}
}
Expression
:
:
As
{
expr
kind
:
target_kind
convert
}
=
>
{
let
inner
=
ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
;
match
convert
{
Some
(
width
)
=
>
{
let
scalar
=
glsl_scalar
(
target_kind
width
)
?
;
match
*
inner
{
TypeInner
:
:
Matrix
{
columns
rows
.
.
}
=
>
write
!
(
self
.
out
"
{
}
mat
{
}
x
{
}
"
scalar
.
prefix
columns
as
u8
rows
as
u8
)
?
TypeInner
:
:
Vector
{
size
.
.
}
=
>
{
write
!
(
self
.
out
"
{
}
vec
{
}
"
scalar
.
prefix
size
as
u8
)
?
}
_
=
>
write
!
(
self
.
out
"
{
}
"
scalar
.
full
)
?
}
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
None
=
>
{
use
crate
:
:
ScalarKind
as
Sk
;
let
target_vector_type
=
match
*
inner
{
TypeInner
:
:
Vector
{
size
width
.
.
}
=
>
Some
(
TypeInner
:
:
Vector
{
size
width
kind
:
target_kind
}
)
_
=
>
None
}
;
let
source_kind
=
inner
.
scalar_kind
(
)
.
unwrap
(
)
;
match
(
source_kind
target_kind
target_vector_type
)
{
(
Sk
:
:
Sint
Sk
:
:
Sint
_
)
|
(
Sk
:
:
Uint
Sk
:
:
Uint
_
)
|
(
Sk
:
:
Float
Sk
:
:
Float
_
)
|
(
Sk
:
:
Bool
Sk
:
:
Bool
_
)
=
>
{
self
.
write_expr
(
expr
ctx
)
?
;
return
Ok
(
(
)
)
;
}
(
Sk
:
:
Float
Sk
:
:
Sint
_
)
=
>
write
!
(
self
.
out
"
floatBitsToInt
"
)
?
(
Sk
:
:
Float
Sk
:
:
Uint
_
)
=
>
write
!
(
self
.
out
"
floatBitsToUint
"
)
?
(
Sk
:
:
Sint
Sk
:
:
Float
_
)
=
>
write
!
(
self
.
out
"
intBitsToFloat
"
)
?
(
Sk
:
:
Uint
Sk
:
:
Float
_
)
=
>
write
!
(
self
.
out
"
uintBitsToFloat
"
)
?
(
_
_
Some
(
vector
)
)
=
>
{
self
.
write_value_type
(
&
vector
)
?
;
}
(
Sk
:
:
Uint
|
Sk
:
:
Bool
Sk
:
:
Sint
None
)
=
>
write
!
(
self
.
out
"
int
"
)
?
(
Sk
:
:
Sint
|
Sk
:
:
Bool
Sk
:
:
Uint
None
)
=
>
write
!
(
self
.
out
"
uint
"
)
?
(
Sk
:
:
Bool
Sk
:
:
Float
None
)
=
>
write
!
(
self
.
out
"
float
"
)
?
(
Sk
:
:
Sint
|
Sk
:
:
Uint
|
Sk
:
:
Float
Sk
:
:
Bool
None
)
=
>
{
write
!
(
self
.
out
"
bool
"
)
?
}
}
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
}
}
Expression
:
:
CallResult
(
_
)
|
Expression
:
:
AtomicResult
{
.
.
}
|
Expression
:
:
RayQueryProceedResult
|
Expression
:
:
WorkGroupUniformLoadResult
{
.
.
}
=
>
unreachable
!
(
)
Expression
:
:
ArrayLength
(
expr
)
=
>
{
write
!
(
self
.
out
"
uint
(
"
)
?
;
self
.
write_expr
(
expr
ctx
)
?
;
write
!
(
self
.
out
"
.
length
(
)
)
"
)
?
}
Expression
:
:
RayQueryGetIntersection
{
.
.
}
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_clamped_lod
(
&
mut
self
ctx
:
&
back
:
:
FunctionCtx
expr
:
Handle
<
crate
:
:
Expression
>
image
:
Handle
<
crate
:
:
Expression
>
level_expr
:
Handle
<
crate
:
:
Expression
>
)
-
>
Result
<
(
)
Error
>
{
write
!
(
self
.
out
"
int
{
}
{
}
{
}
=
clamp
(
"
back
:
:
BAKE_PREFIX
expr
.
index
(
)
CLAMPED_LOD_SUFFIX
)
?
;
self
.
write_expr
(
level_expr
ctx
)
?
;
write
!
(
self
.
out
"
0
textureQueryLevels
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
writeln
!
(
self
.
out
"
)
-
1
)
;
"
)
?
;
Ok
(
(
)
)
}
fn
get_coordinate_vector_size
(
&
self
dim
:
crate
:
:
ImageDimension
arrayed
:
bool
)
-
>
u8
{
let
tex_1d_hack
=
dim
=
=
crate
:
:
ImageDimension
:
:
D1
&
&
self
.
options
.
version
.
is_es
(
)
;
let
tex_coord_size
=
match
dim
{
crate
:
:
ImageDimension
:
:
D1
=
>
1
crate
:
:
ImageDimension
:
:
D2
=
>
2
crate
:
:
ImageDimension
:
:
D3
=
>
3
crate
:
:
ImageDimension
:
:
Cube
=
>
2
}
;
tex_coord_size
+
tex_1d_hack
as
u8
+
arrayed
as
u8
}
fn
write_texture_coord
(
&
mut
self
ctx
:
&
back
:
:
FunctionCtx
vector_size
:
u8
coordinate
:
Handle
<
crate
:
:
Expression
>
array_index
:
Option
<
Handle
<
crate
:
:
Expression
>
>
tex_1d_hack
:
bool
)
-
>
Result
<
(
)
Error
>
{
match
array_index
{
Some
(
layer_expr
)
=
>
{
write
!
(
self
.
out
"
ivec
{
vector_size
}
(
"
)
?
;
self
.
write_expr
(
coordinate
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
if
tex_1d_hack
{
write
!
(
self
.
out
"
0
"
)
?
;
}
self
.
write_expr
(
layer_expr
ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
None
=
>
{
let
uvec_size
=
match
*
ctx
.
info
[
coordinate
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Scalar
{
kind
:
crate
:
:
ScalarKind
:
:
Uint
.
.
}
=
>
Some
(
None
)
TypeInner
:
:
Vector
{
size
kind
:
crate
:
:
ScalarKind
:
:
Uint
.
.
}
=
>
Some
(
Some
(
size
as
u32
)
)
_
=
>
None
}
;
if
tex_1d_hack
{
write
!
(
self
.
out
"
ivec2
(
"
)
?
;
}
else
if
uvec_size
.
is_some
(
)
{
match
uvec_size
{
Some
(
None
)
=
>
write
!
(
self
.
out
"
int
(
"
)
?
Some
(
Some
(
size
)
)
=
>
write
!
(
self
.
out
"
ivec
{
size
}
(
"
)
?
_
=
>
{
}
}
}
self
.
write_expr
(
coordinate
ctx
)
?
;
if
tex_1d_hack
{
write
!
(
self
.
out
"
0
)
"
)
?
;
}
else
if
uvec_size
.
is_some
(
)
{
write
!
(
self
.
out
"
)
"
)
?
;
}
}
}
Ok
(
(
)
)
}
fn
write_image_store
(
&
mut
self
ctx
:
&
back
:
:
FunctionCtx
image
:
Handle
<
crate
:
:
Expression
>
coordinate
:
Handle
<
crate
:
:
Expression
>
array_index
:
Option
<
Handle
<
crate
:
:
Expression
>
>
value
:
Handle
<
crate
:
:
Expression
>
)
-
>
Result
<
(
)
Error
>
{
use
crate
:
:
ImageDimension
as
IDim
;
let
dim
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
.
.
}
=
>
dim
_
=
>
unreachable
!
(
)
}
;
write
!
(
self
.
out
"
imageStore
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
let
tex_1d_hack
=
dim
=
=
IDim
:
:
D1
&
&
self
.
options
.
version
.
is_es
(
)
;
self
.
write_texture_coord
(
ctx
self
.
get_coordinate_vector_size
(
dim
array_index
.
is_some
(
)
)
coordinate
array_index
tex_1d_hack
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
value
ctx
)
?
;
writeln
!
(
self
.
out
"
)
;
"
)
?
;
Ok
(
(
)
)
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
write_image_load
(
&
mut
self
handle
:
Handle
<
crate
:
:
Expression
>
ctx
:
&
back
:
:
FunctionCtx
image
:
Handle
<
crate
:
:
Expression
>
coordinate
:
Handle
<
crate
:
:
Expression
>
array_index
:
Option
<
Handle
<
crate
:
:
Expression
>
>
sample
:
Option
<
Handle
<
crate
:
:
Expression
>
>
level
:
Option
<
Handle
<
crate
:
:
Expression
>
>
)
-
>
Result
<
(
)
Error
>
{
use
crate
:
:
ImageDimension
as
IDim
;
let
(
dim
class
)
=
match
*
ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
self
.
module
.
types
)
{
TypeInner
:
:
Image
{
dim
arrayed
:
_
class
}
=
>
(
dim
class
)
_
=
>
unreachable
!
(
)
}
;
let
(
fun_name
policy
)
=
match
class
{
crate
:
:
ImageClass
:
:
Sampled
{
.
.
}
=
>
(
"
texelFetch
"
self
.
policies
.
image_load
)
crate
:
:
ImageClass
:
:
Storage
{
.
.
}
=
>
{
let
policy
=
if
self
.
options
.
version
.
is_es
(
)
{
self
.
policies
.
image_load
}
else
{
proc
:
:
BoundsCheckPolicy
:
:
Unchecked
}
;
(
"
imageLoad
"
policy
)
}
crate
:
:
ImageClass
:
:
Depth
{
multi
:
_
}
=
>
{
return
Err
(
Error
:
:
Custom
(
"
WGSL
textureLoad
from
depth
textures
is
not
supported
in
GLSL
"
.
to_string
(
)
)
)
}
}
;
let
tex_1d_hack
=
dim
=
=
IDim
:
:
D1
&
&
self
.
options
.
version
.
is_es
(
)
;
let
vector_size
=
self
.
get_coordinate_vector_size
(
dim
array_index
.
is_some
(
)
)
;
if
let
proc
:
:
BoundsCheckPolicy
:
:
ReadZeroSkipWrite
=
policy
{
write
!
(
self
.
out
"
(
"
)
?
;
if
let
Some
(
level_expr
)
=
level
{
self
.
write_expr
(
level_expr
ctx
)
?
;
write
!
(
self
.
out
"
<
textureQueryLevels
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
&
&
"
)
?
;
}
if
let
Some
(
sample_expr
)
=
sample
{
self
.
write_expr
(
sample_expr
ctx
)
?
;
write
!
(
self
.
out
"
<
textureSamples
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
)
&
&
"
)
?
;
}
if
vector_size
!
=
1
{
write
!
(
self
.
out
"
all
(
lessThan
(
"
)
?
;
}
self
.
write_texture_coord
(
ctx
vector_size
coordinate
array_index
tex_1d_hack
)
?
;
if
vector_size
!
=
1
{
write
!
(
self
.
out
"
"
)
?
;
}
else
{
write
!
(
self
.
out
"
<
"
)
?
;
}
write
!
(
self
.
out
"
textureSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
if
let
Some
(
level_expr
)
=
level
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
level_expr
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
if
vector_size
!
=
1
{
write
!
(
self
.
out
"
)
)
"
)
?
;
}
write
!
(
self
.
out
"
?
"
)
?
;
}
write
!
(
self
.
out
"
{
fun_name
}
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
if
let
proc
:
:
BoundsCheckPolicy
:
:
Restrict
=
policy
{
write
!
(
self
.
out
"
clamp
(
"
)
?
;
}
self
.
write_texture_coord
(
ctx
vector_size
coordinate
array_index
tex_1d_hack
)
?
;
if
let
proc
:
:
BoundsCheckPolicy
:
:
Restrict
=
policy
{
if
vector_size
=
=
1
{
write
!
(
self
.
out
"
0
"
)
?
;
}
else
{
write
!
(
self
.
out
"
ivec
{
vector_size
}
(
0
)
"
)
?
;
}
write
!
(
self
.
out
"
textureSize
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
if
class
.
is_mipmapped
(
)
{
write
!
(
self
.
out
"
{
}
{
}
{
}
"
back
:
:
BAKE_PREFIX
handle
.
index
(
)
CLAMPED_LOD_SUFFIX
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
if
vector_size
=
=
1
{
write
!
(
self
.
out
"
-
1
"
)
?
;
}
else
{
write
!
(
self
.
out
"
-
ivec
{
vector_size
}
(
1
)
"
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
if
level
.
is_some
(
)
{
write
!
(
self
.
out
"
{
}
{
}
{
}
"
back
:
:
BAKE_PREFIX
handle
.
index
(
)
CLAMPED_LOD_SUFFIX
)
?
;
}
if
let
Some
(
sample_expr
)
=
sample
{
write
!
(
self
.
out
"
clamp
(
"
)
?
;
self
.
write_expr
(
sample_expr
ctx
)
?
;
write
!
(
self
.
out
"
0
textureSamples
(
"
)
?
;
self
.
write_expr
(
image
ctx
)
?
;
writeln
!
(
self
.
out
"
)
-
1
)
"
)
?
;
}
}
else
if
let
Some
(
sample_or_level
)
=
sample
.
or
(
level
)
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
sample_or_level
ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
if
let
proc
:
:
BoundsCheckPolicy
:
:
ReadZeroSkipWrite
=
policy
{
let
kind
=
match
class
{
crate
:
:
ImageClass
:
:
Sampled
{
kind
.
.
}
=
>
kind
_
=
>
unreachable
!
(
)
}
;
write
!
(
self
.
out
"
:
"
)
?
;
write
!
(
self
.
out
"
{
}
vec4
(
"
glsl_scalar
(
kind
4
)
?
.
prefix
)
?
;
self
.
write_zero_init_scalar
(
kind
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
Ok
(
(
)
)
}
fn
write_named_expr
(
&
mut
self
handle
:
Handle
<
crate
:
:
Expression
>
name
:
String
named
:
Handle
<
crate
:
:
Expression
>
ctx
:
&
back
:
:
FunctionCtx
)
-
>
BackendResult
{
match
ctx
.
info
[
named
]
.
ty
{
proc
:
:
TypeResolution
:
:
Handle
(
ty_handle
)
=
>
match
self
.
module
.
types
[
ty_handle
]
.
inner
{
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty_handle
)
]
;
write
!
(
self
.
out
"
{
ty_name
}
"
)
?
;
}
_
=
>
{
self
.
write_type
(
ty_handle
)
?
;
}
}
proc
:
:
TypeResolution
:
:
Value
(
ref
inner
)
=
>
{
self
.
write_value_type
(
inner
)
?
;
}
}
let
base_ty_res
=
&
ctx
.
info
[
named
]
.
ty
;
let
resolved
=
base_ty_res
.
inner_with
(
&
self
.
module
.
types
)
;
write
!
(
self
.
out
"
{
name
}
"
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
*
resolved
{
self
.
write_array_size
(
base
size
)
?
;
}
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
handle
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
self
.
named_expressions
.
insert
(
named
name
)
;
Ok
(
(
)
)
}
fn
write_zero_init_value
(
&
mut
self
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
BackendResult
{
let
inner
=
&
self
.
module
.
types
[
ty
]
.
inner
;
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
.
.
}
|
TypeInner
:
:
Atomic
{
kind
.
.
}
=
>
{
self
.
write_zero_init_scalar
(
kind
)
?
;
}
TypeInner
:
:
Vector
{
kind
.
.
}
=
>
{
self
.
write_value_type
(
inner
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_zero_init_scalar
(
kind
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
TypeInner
:
:
Matrix
{
.
.
}
=
>
{
self
.
write_value_type
(
inner
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_zero_init_scalar
(
crate
:
:
ScalarKind
:
:
Float
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
{
let
count
=
match
size
.
to_indexable_length
(
self
.
module
)
.
expect
(
"
Bad
array
size
"
)
{
proc
:
:
IndexableLength
:
:
Known
(
count
)
=
>
count
proc
:
:
IndexableLength
:
:
Dynamic
=
>
return
Ok
(
(
)
)
}
;
self
.
write_type
(
base
)
?
;
self
.
write_array_size
(
base
size
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
for
_
in
1
.
.
count
{
self
.
write_zero_init_value
(
base
)
?
;
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_zero_init_value
(
base
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
;
write
!
(
self
.
out
"
{
name
}
(
"
)
?
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_zero_init_value
(
member
.
ty
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
_
=
>
unreachable
!
(
)
}
Ok
(
(
)
)
}
fn
write_zero_init_scalar
(
&
mut
self
kind
:
crate
:
:
ScalarKind
)
-
>
BackendResult
{
match
kind
{
crate
:
:
ScalarKind
:
:
Bool
=
>
write
!
(
self
.
out
"
false
"
)
?
crate
:
:
ScalarKind
:
:
Uint
=
>
write
!
(
self
.
out
"
0u
"
)
?
crate
:
:
ScalarKind
:
:
Float
=
>
write
!
(
self
.
out
"
0
.
0
"
)
?
crate
:
:
ScalarKind
:
:
Sint
=
>
write
!
(
self
.
out
"
0
"
)
?
}
Ok
(
(
)
)
}
fn
write_barrier
(
&
mut
self
flags
:
crate
:
:
Barrier
level
:
back
:
:
Level
)
-
>
BackendResult
{
if
flags
.
contains
(
crate
:
:
Barrier
:
:
STORAGE
)
{
writeln
!
(
self
.
out
"
{
level
}
memoryBarrierBuffer
(
)
;
"
)
?
;
}
if
flags
.
contains
(
crate
:
:
Barrier
:
:
WORK_GROUP
)
{
writeln
!
(
self
.
out
"
{
level
}
memoryBarrierShared
(
)
;
"
)
?
;
}
writeln
!
(
self
.
out
"
{
level
}
barrier
(
)
;
"
)
?
;
Ok
(
(
)
)
}
fn
write_storage_access
(
&
mut
self
storage_access
:
crate
:
:
StorageAccess
)
-
>
BackendResult
{
if
!
storage_access
.
contains
(
crate
:
:
StorageAccess
:
:
STORE
)
{
write
!
(
self
.
out
"
readonly
"
)
?
;
}
if
!
storage_access
.
contains
(
crate
:
:
StorageAccess
:
:
LOAD
)
{
write
!
(
self
.
out
"
writeonly
"
)
?
;
}
Ok
(
(
)
)
}
fn
collect_reflection_info
(
&
self
)
-
>
Result
<
ReflectionInfo
Error
>
{
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
let
info
=
self
.
info
.
get_entry_point
(
self
.
entry_point_idx
as
usize
)
;
let
mut
texture_mapping
=
crate
:
:
FastHashMap
:
:
default
(
)
;
let
mut
uniforms
=
crate
:
:
FastHashMap
:
:
default
(
)
;
for
sampling
in
info
.
sampling_set
.
iter
(
)
{
let
tex_name
=
self
.
reflection_names_globals
[
&
sampling
.
image
]
.
clone
(
)
;
match
texture_mapping
.
entry
(
tex_name
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
v
.
insert
(
TextureMapping
{
texture
:
sampling
.
image
sampler
:
Some
(
sampling
.
sampler
)
}
)
;
}
Entry
:
:
Occupied
(
e
)
=
>
{
if
e
.
get
(
)
.
sampler
!
=
Some
(
sampling
.
sampler
)
{
log
:
:
error
!
(
"
Conflicting
samplers
for
{
}
"
e
.
key
(
)
)
;
return
Err
(
Error
:
:
ImageMultipleSamplers
)
;
}
}
}
}
for
(
handle
var
)
in
self
.
module
.
global_variables
.
iter
(
)
{
if
info
[
handle
]
.
is_empty
(
)
{
continue
;
}
match
self
.
module
.
types
[
var
.
ty
]
.
inner
{
crate
:
:
TypeInner
:
:
Image
{
.
.
}
=
>
{
let
tex_name
=
self
.
reflection_names_globals
[
&
handle
]
.
clone
(
)
;
match
texture_mapping
.
entry
(
tex_name
)
{
Entry
:
:
Vacant
(
v
)
=
>
{
v
.
insert
(
TextureMapping
{
texture
:
handle
sampler
:
None
}
)
;
}
Entry
:
:
Occupied
(
_
)
=
>
{
}
}
}
_
=
>
match
var
.
space
{
crate
:
:
AddressSpace
:
:
Uniform
|
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
=
>
{
let
name
=
self
.
reflection_names_globals
[
&
handle
]
.
clone
(
)
;
uniforms
.
insert
(
handle
name
)
;
}
_
=
>
(
)
}
}
}
Ok
(
ReflectionInfo
{
texture_mapping
uniforms
}
)
}
}
struct
ScalarString
<
'
a
>
{
prefix
:
&
'
a
str
full
:
&
'
a
str
}
const
fn
glsl_scalar
(
kind
:
crate
:
:
ScalarKind
width
:
crate
:
:
Bytes
)
-
>
Result
<
ScalarString
<
'
static
>
Error
>
{
use
crate
:
:
ScalarKind
as
Sk
;
Ok
(
match
kind
{
Sk
:
:
Sint
=
>
ScalarString
{
prefix
:
"
i
"
full
:
"
int
"
}
Sk
:
:
Uint
=
>
ScalarString
{
prefix
:
"
u
"
full
:
"
uint
"
}
Sk
:
:
Float
=
>
match
width
{
4
=
>
ScalarString
{
prefix
:
"
"
full
:
"
float
"
}
8
=
>
ScalarString
{
prefix
:
"
d
"
full
:
"
double
"
}
_
=
>
return
Err
(
Error
:
:
UnsupportedScalar
(
kind
width
)
)
}
Sk
:
:
Bool
=
>
ScalarString
{
prefix
:
"
b
"
full
:
"
bool
"
}
}
)
}
const
fn
glsl_built_in
(
built_in
:
crate
:
:
BuiltIn
output
:
bool
targetting_webgl
:
bool
)
-
>
&
'
static
str
{
use
crate
:
:
BuiltIn
as
Bi
;
match
built_in
{
Bi
:
:
Position
{
.
.
}
=
>
{
if
output
{
"
gl_Position
"
}
else
{
"
gl_FragCoord
"
}
}
Bi
:
:
ViewIndex
if
targetting_webgl
=
>
"
int
(
gl_ViewID_OVR
)
"
Bi
:
:
ViewIndex
=
>
"
gl_ViewIndex
"
Bi
:
:
BaseInstance
=
>
"
uint
(
gl_BaseInstance
)
"
Bi
:
:
BaseVertex
=
>
"
uint
(
gl_BaseVertex
)
"
Bi
:
:
ClipDistance
=
>
"
gl_ClipDistance
"
Bi
:
:
CullDistance
=
>
"
gl_CullDistance
"
Bi
:
:
InstanceIndex
=
>
"
uint
(
gl_InstanceID
)
"
Bi
:
:
PointSize
=
>
"
gl_PointSize
"
Bi
:
:
VertexIndex
=
>
"
uint
(
gl_VertexID
)
"
Bi
:
:
FragDepth
=
>
"
gl_FragDepth
"
Bi
:
:
PointCoord
=
>
"
gl_PointCoord
"
Bi
:
:
FrontFacing
=
>
"
gl_FrontFacing
"
Bi
:
:
PrimitiveIndex
=
>
"
uint
(
gl_PrimitiveID
)
"
Bi
:
:
SampleIndex
=
>
"
gl_SampleID
"
Bi
:
:
SampleMask
=
>
{
if
output
{
"
gl_SampleMask
"
}
else
{
"
gl_SampleMaskIn
"
}
}
Bi
:
:
GlobalInvocationId
=
>
"
gl_GlobalInvocationID
"
Bi
:
:
LocalInvocationId
=
>
"
gl_LocalInvocationID
"
Bi
:
:
LocalInvocationIndex
=
>
"
gl_LocalInvocationIndex
"
Bi
:
:
WorkGroupId
=
>
"
gl_WorkGroupID
"
Bi
:
:
WorkGroupSize
=
>
"
gl_WorkGroupSize
"
Bi
:
:
NumWorkGroups
=
>
"
gl_NumWorkGroups
"
}
}
const
fn
glsl_storage_qualifier
(
space
:
crate
:
:
AddressSpace
)
-
>
Option
<
&
'
static
str
>
{
use
crate
:
:
AddressSpace
as
As
;
match
space
{
As
:
:
Function
=
>
None
As
:
:
Private
=
>
None
As
:
:
Storage
{
.
.
}
=
>
Some
(
"
buffer
"
)
As
:
:
Uniform
=
>
Some
(
"
uniform
"
)
As
:
:
Handle
=
>
Some
(
"
uniform
"
)
As
:
:
WorkGroup
=
>
Some
(
"
shared
"
)
As
:
:
PushConstant
=
>
Some
(
"
uniform
"
)
}
}
const
fn
glsl_interpolation
(
interpolation
:
crate
:
:
Interpolation
)
-
>
&
'
static
str
{
use
crate
:
:
Interpolation
as
I
;
match
interpolation
{
I
:
:
Perspective
=
>
"
smooth
"
I
:
:
Linear
=
>
"
noperspective
"
I
:
:
Flat
=
>
"
flat
"
}
}
const
fn
glsl_sampling
(
sampling
:
crate
:
:
Sampling
)
-
>
Option
<
&
'
static
str
>
{
use
crate
:
:
Sampling
as
S
;
match
sampling
{
S
:
:
Center
=
>
None
S
:
:
Centroid
=
>
Some
(
"
centroid
"
)
S
:
:
Sample
=
>
Some
(
"
sample
"
)
}
}
const
fn
glsl_dimension
(
dim
:
crate
:
:
ImageDimension
)
-
>
&
'
static
str
{
use
crate
:
:
ImageDimension
as
IDim
;
match
dim
{
IDim
:
:
D1
=
>
"
1D
"
IDim
:
:
D2
=
>
"
2D
"
IDim
:
:
D3
=
>
"
3D
"
IDim
:
:
Cube
=
>
"
Cube
"
}
}
const
fn
glsl_storage_format
(
format
:
crate
:
:
StorageFormat
)
-
>
&
'
static
str
{
use
crate
:
:
StorageFormat
as
Sf
;
match
format
{
Sf
:
:
R8Unorm
=
>
"
r8
"
Sf
:
:
R8Snorm
=
>
"
r8_snorm
"
Sf
:
:
R8Uint
=
>
"
r8ui
"
Sf
:
:
R8Sint
=
>
"
r8i
"
Sf
:
:
R16Uint
=
>
"
r16ui
"
Sf
:
:
R16Sint
=
>
"
r16i
"
Sf
:
:
R16Float
=
>
"
r16f
"
Sf
:
:
Rg8Unorm
=
>
"
rg8
"
Sf
:
:
Rg8Snorm
=
>
"
rg8_snorm
"
Sf
:
:
Rg8Uint
=
>
"
rg8ui
"
Sf
:
:
Rg8Sint
=
>
"
rg8i
"
Sf
:
:
R32Uint
=
>
"
r32ui
"
Sf
:
:
R32Sint
=
>
"
r32i
"
Sf
:
:
R32Float
=
>
"
r32f
"
Sf
:
:
Rg16Uint
=
>
"
rg16ui
"
Sf
:
:
Rg16Sint
=
>
"
rg16i
"
Sf
:
:
Rg16Float
=
>
"
rg16f
"
Sf
:
:
Rgba8Unorm
=
>
"
rgba8
"
Sf
:
:
Rgba8Snorm
=
>
"
rgba8_snorm
"
Sf
:
:
Rgba8Uint
=
>
"
rgba8ui
"
Sf
:
:
Rgba8Sint
=
>
"
rgba8i
"
Sf
:
:
Rgb10a2Unorm
=
>
"
rgb10_a2ui
"
Sf
:
:
Rg11b10Float
=
>
"
r11f_g11f_b10f
"
Sf
:
:
Rg32Uint
=
>
"
rg32ui
"
Sf
:
:
Rg32Sint
=
>
"
rg32i
"
Sf
:
:
Rg32Float
=
>
"
rg32f
"
Sf
:
:
Rgba16Uint
=
>
"
rgba16ui
"
Sf
:
:
Rgba16Sint
=
>
"
rgba16i
"
Sf
:
:
Rgba16Float
=
>
"
rgba16f
"
Sf
:
:
Rgba32Uint
=
>
"
rgba32ui
"
Sf
:
:
Rgba32Sint
=
>
"
rgba32i
"
Sf
:
:
Rgba32Float
=
>
"
rgba32f
"
Sf
:
:
R16Unorm
=
>
"
r16
"
Sf
:
:
R16Snorm
=
>
"
r16_snorm
"
Sf
:
:
Rg16Unorm
=
>
"
rg16
"
Sf
:
:
Rg16Snorm
=
>
"
rg16_snorm
"
Sf
:
:
Rgba16Unorm
=
>
"
rgba16
"
Sf
:
:
Rgba16Snorm
=
>
"
rgba16_snorm
"
}
}
fn
is_value_init_supported
(
module
:
&
crate
:
:
Module
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
bool
{
match
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Scalar
{
.
.
}
|
TypeInner
:
:
Vector
{
.
.
}
|
TypeInner
:
:
Matrix
{
.
.
}
=
>
true
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
{
size
!
=
crate
:
:
ArraySize
:
:
Dynamic
&
&
is_value_init_supported
(
module
base
)
}
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
members
.
iter
(
)
.
all
(
|
member
|
is_value_init_supported
(
module
member
.
ty
)
)
_
=
>
false
}
}
