use
crate
:
:
{
arena
:
:
Handle
valid
:
:
ModuleInfo
}
;
use
std
:
:
fmt
:
:
{
Error
as
FmtError
Write
}
;
mod
keywords
;
pub
mod
sampler
;
mod
writer
;
pub
use
writer
:
:
Writer
;
pub
type
Slot
=
u8
;
pub
type
InlineSamplerIndex
=
u8
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
BindSamplerTarget
{
Resource
(
Slot
)
Inline
(
InlineSamplerIndex
)
}
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
BindTarget
{
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
buffer
:
Option
<
Slot
>
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
texture
:
Option
<
Slot
>
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
sampler
:
Option
<
BindSamplerTarget
>
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
mutable
:
bool
}
#
[
derive
(
Clone
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
BindSource
{
pub
stage
:
crate
:
:
ShaderStage
pub
group
:
u32
pub
binding
:
u32
}
pub
type
BindingMap
=
std
:
:
collections
:
:
BTreeMap
<
BindSource
BindTarget
>
;
#
[
derive
(
Clone
Debug
Default
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
PushConstantsMap
{
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
vs_buffer
:
Option
<
Slot
>
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
fs_buffer
:
Option
<
Slot
>
#
[
cfg_attr
(
feature
=
"
deserialize
"
serde
(
default
)
)
]
pub
cs_buffer
:
Option
<
Slot
>
}
enum
ResolvedBinding
{
BuiltIn
(
crate
:
:
BuiltIn
)
Attribute
(
u32
)
Color
(
u32
)
User
{
prefix
:
&
'
static
str
index
:
u32
interpolation
:
ResolvedInterpolation
}
Resource
(
BindTarget
)
}
#
[
derive
(
Copy
Clone
)
]
enum
ResolvedInterpolation
{
CenterPerspective
CenterNoPerspective
CentroidPerspective
CentroidNoPerspective
SamplePerspective
SampleNoPerspective
Flat
}
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
pub
enum
Error
{
#
[
error
(
transparent
)
]
Format
(
#
[
from
]
FmtError
)
#
[
error
(
"
bind
target
{
0
:
?
}
is
empty
"
)
]
UnimplementedBindTarget
(
BindTarget
)
#
[
error
(
"
composing
of
{
0
:
?
}
is
not
implemented
yet
"
)
]
UnsupportedCompose
(
Handle
<
crate
:
:
Type
>
)
#
[
error
(
"
operation
{
0
:
?
}
is
not
implemented
yet
"
)
]
UnsupportedBinaryOp
(
crate
:
:
BinaryOperator
)
#
[
error
(
"
standard
function
'
{
0
}
'
is
not
implemented
yet
"
)
]
UnsupportedCall
(
String
)
#
[
error
(
"
feature
'
{
0
}
'
is
not
implemented
yet
"
)
]
FeatureNotImplemented
(
String
)
#
[
error
(
"
module
is
not
valid
"
)
]
Validation
}
#
[
derive
(
Clone
Debug
PartialEq
thiserror
:
:
Error
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
EntryPointError
{
#
[
error
(
"
mapping
of
{
0
:
?
}
is
missing
"
)
]
MissingBinding
(
BindSource
)
#
[
error
(
"
mapping
for
push
constants
at
stage
{
0
:
?
}
is
missing
"
)
]
MissingPushConstants
(
crate
:
:
ShaderStage
)
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
LocationMode
{
VertexInput
FragmentOutput
Intermediate
Uniform
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
Options
{
pub
lang_version
:
(
u8
u8
)
pub
binding_map
:
BindingMap
pub
push_constants_map
:
PushConstantsMap
pub
inline_samplers
:
Vec
<
sampler
:
:
InlineSampler
>
pub
spirv_cross_compatibility
:
bool
pub
fake_missing_bindings
:
bool
}
impl
Default
for
Options
{
fn
default
(
)
-
>
Self
{
Options
{
lang_version
:
(
1
0
)
binding_map
:
BindingMap
:
:
default
(
)
push_constants_map
:
PushConstantsMap
:
:
default
(
)
inline_samplers
:
Vec
:
:
new
(
)
spirv_cross_compatibility
:
false
fake_missing_bindings
:
true
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
PipelineOptions
{
pub
allow_point_size
:
bool
}
impl
Default
for
PipelineOptions
{
fn
default
(
)
-
>
Self
{
PipelineOptions
{
allow_point_size
:
true
}
}
}
impl
Options
{
fn
resolve_local_binding
(
&
self
binding
:
&
crate
:
:
Binding
mode
:
LocationMode
)
-
>
Result
<
ResolvedBinding
Error
>
{
match
*
binding
{
crate
:
:
Binding
:
:
BuiltIn
(
built_in
)
=
>
Ok
(
ResolvedBinding
:
:
BuiltIn
(
built_in
)
)
crate
:
:
Binding
:
:
Location
{
location
interpolation
sampling
}
=
>
match
mode
{
LocationMode
:
:
VertexInput
=
>
Ok
(
ResolvedBinding
:
:
Attribute
(
location
)
)
LocationMode
:
:
FragmentOutput
=
>
Ok
(
ResolvedBinding
:
:
Color
(
location
)
)
LocationMode
:
:
Intermediate
=
>
Ok
(
ResolvedBinding
:
:
User
{
prefix
:
if
self
.
spirv_cross_compatibility
{
"
locn
"
}
else
{
"
loc
"
}
index
:
location
interpolation
:
{
let
interpolation
=
interpolation
.
unwrap
(
)
;
let
sampling
=
sampling
.
unwrap_or
(
crate
:
:
Sampling
:
:
Center
)
;
ResolvedInterpolation
:
:
from_binding
(
interpolation
sampling
)
}
}
)
LocationMode
:
:
Uniform
=
>
{
log
:
:
error
!
(
"
Unexpected
Binding
:
:
Location
(
{
}
)
for
the
Uniform
mode
"
location
)
;
Err
(
Error
:
:
Validation
)
}
}
}
}
fn
resolve_resource_binding
(
&
self
stage
:
crate
:
:
ShaderStage
res_binding
:
&
crate
:
:
ResourceBinding
)
-
>
Result
<
ResolvedBinding
EntryPointError
>
{
let
source
=
BindSource
{
stage
group
:
res_binding
.
group
binding
:
res_binding
.
binding
}
;
match
self
.
binding_map
.
get
(
&
source
)
{
Some
(
target
)
=
>
Ok
(
ResolvedBinding
:
:
Resource
(
target
.
clone
(
)
)
)
None
if
self
.
fake_missing_bindings
=
>
Ok
(
ResolvedBinding
:
:
User
{
prefix
:
"
fake
"
index
:
0
interpolation
:
ResolvedInterpolation
:
:
CenterPerspective
}
)
None
=
>
Err
(
EntryPointError
:
:
MissingBinding
(
source
)
)
}
}
fn
resolve_push_constants
(
&
self
stage
:
crate
:
:
ShaderStage
)
-
>
Result
<
ResolvedBinding
EntryPointError
>
{
let
slot
=
match
stage
{
crate
:
:
ShaderStage
:
:
Vertex
=
>
self
.
push_constants_map
.
vs_buffer
crate
:
:
ShaderStage
:
:
Fragment
=
>
self
.
push_constants_map
.
fs_buffer
crate
:
:
ShaderStage
:
:
Compute
=
>
self
.
push_constants_map
.
cs_buffer
}
;
match
slot
{
Some
(
slot
)
=
>
Ok
(
ResolvedBinding
:
:
Resource
(
BindTarget
{
buffer
:
Some
(
slot
)
texture
:
None
sampler
:
None
mutable
:
false
}
)
)
None
if
self
.
fake_missing_bindings
=
>
Ok
(
ResolvedBinding
:
:
User
{
prefix
:
"
fake
"
index
:
0
interpolation
:
ResolvedInterpolation
:
:
CenterPerspective
}
)
None
=
>
Err
(
EntryPointError
:
:
MissingPushConstants
(
stage
)
)
}
}
}
impl
ResolvedBinding
{
fn
as_inline_sampler
<
'
a
>
(
&
self
options
:
&
'
a
Options
)
-
>
Option
<
&
'
a
sampler
:
:
InlineSampler
>
{
match
*
self
{
Self
:
:
Resource
(
BindTarget
{
sampler
:
Some
(
BindSamplerTarget
:
:
Inline
(
index
)
)
.
.
}
)
=
>
Some
(
&
options
.
inline_samplers
[
index
as
usize
]
)
_
=
>
None
}
}
fn
try_fmt
<
W
:
Write
>
(
&
self
out
:
&
mut
W
)
-
>
Result
<
(
)
Error
>
{
match
*
self
{
Self
:
:
BuiltIn
(
built_in
)
=
>
{
use
crate
:
:
BuiltIn
as
Bi
;
let
name
=
match
built_in
{
Bi
:
:
Position
=
>
"
position
"
Bi
:
:
BaseInstance
=
>
"
base_instance
"
Bi
:
:
BaseVertex
=
>
"
base_vertex
"
Bi
:
:
ClipDistance
=
>
"
clip_distance
"
Bi
:
:
InstanceIndex
=
>
"
instance_id
"
Bi
:
:
PointSize
=
>
"
point_size
"
Bi
:
:
VertexIndex
=
>
"
vertex_id
"
Bi
:
:
FragDepth
=
>
"
depth
(
any
)
"
Bi
:
:
FrontFacing
=
>
"
front_facing
"
Bi
:
:
SampleIndex
=
>
"
sample_id
"
Bi
:
:
SampleMask
=
>
"
sample_mask
"
Bi
:
:
GlobalInvocationId
=
>
"
thread_position_in_grid
"
Bi
:
:
LocalInvocationId
=
>
"
thread_position_in_threadgroup
"
Bi
:
:
LocalInvocationIndex
=
>
"
thread_index_in_threadgroup
"
Bi
:
:
WorkGroupId
=
>
"
threadgroup_position_in_grid
"
Bi
:
:
WorkGroupSize
=
>
"
dispatch_threads_per_threadgroup
"
}
;
write
!
(
out
"
{
}
"
name
)
?
;
}
Self
:
:
Attribute
(
index
)
=
>
write
!
(
out
"
attribute
(
{
}
)
"
index
)
?
Self
:
:
Color
(
index
)
=
>
write
!
(
out
"
color
(
{
}
)
"
index
)
?
Self
:
:
User
{
prefix
index
interpolation
}
=
>
{
write
!
(
out
"
user
(
{
}
{
}
)
"
prefix
index
)
?
;
interpolation
.
try_fmt
(
out
)
?
;
}
Self
:
:
Resource
(
ref
target
)
=
>
{
if
let
Some
(
id
)
=
target
.
buffer
{
write
!
(
out
"
buffer
(
{
}
)
"
id
)
?
;
}
else
if
let
Some
(
id
)
=
target
.
texture
{
write
!
(
out
"
texture
(
{
}
)
"
id
)
?
;
}
else
if
let
Some
(
BindSamplerTarget
:
:
Resource
(
id
)
)
=
target
.
sampler
{
write
!
(
out
"
sampler
(
{
}
)
"
id
)
?
;
}
else
{
return
Err
(
Error
:
:
UnimplementedBindTarget
(
target
.
clone
(
)
)
)
;
}
}
}
Ok
(
(
)
)
}
fn
try_fmt_decorated
<
W
:
Write
>
(
&
self
out
:
&
mut
W
terminator
:
&
str
)
-
>
Result
<
(
)
Error
>
{
write
!
(
out
"
[
[
"
)
?
;
self
.
try_fmt
(
out
)
?
;
write
!
(
out
"
]
]
"
)
?
;
write
!
(
out
"
{
}
"
terminator
)
?
;
Ok
(
(
)
)
}
}
impl
ResolvedInterpolation
{
fn
from_binding
(
interpolation
:
crate
:
:
Interpolation
sampling
:
crate
:
:
Sampling
)
-
>
Self
{
use
crate
:
:
Interpolation
as
I
;
use
crate
:
:
Sampling
as
S
;
match
(
interpolation
sampling
)
{
(
I
:
:
Perspective
S
:
:
Center
)
=
>
Self
:
:
CenterPerspective
(
I
:
:
Perspective
S
:
:
Centroid
)
=
>
Self
:
:
CentroidPerspective
(
I
:
:
Perspective
S
:
:
Sample
)
=
>
Self
:
:
SamplePerspective
(
I
:
:
Linear
S
:
:
Center
)
=
>
Self
:
:
CenterNoPerspective
(
I
:
:
Linear
S
:
:
Centroid
)
=
>
Self
:
:
CentroidNoPerspective
(
I
:
:
Linear
S
:
:
Sample
)
=
>
Self
:
:
SampleNoPerspective
(
I
:
:
Flat
_
)
=
>
Self
:
:
Flat
}
}
fn
try_fmt
<
W
:
Write
>
(
self
out
:
&
mut
W
)
-
>
Result
<
(
)
Error
>
{
let
identifier
=
match
self
{
Self
:
:
CenterPerspective
=
>
"
center_perspective
"
Self
:
:
CenterNoPerspective
=
>
"
center_no_perspective
"
Self
:
:
CentroidPerspective
=
>
"
centroid_perspective
"
Self
:
:
CentroidNoPerspective
=
>
"
centroid_no_perspective
"
Self
:
:
SamplePerspective
=
>
"
sample_perspective
"
Self
:
:
SampleNoPerspective
=
>
"
sample_no_perspective
"
Self
:
:
Flat
=
>
"
flat
"
}
;
out
.
write_str
(
identifier
)
?
;
Ok
(
(
)
)
}
}
pub
struct
TranslationInfo
{
pub
entry_point_names
:
Vec
<
Result
<
String
EntryPointError
>
>
}
pub
fn
write_string
(
module
:
&
crate
:
:
Module
info
:
&
ModuleInfo
options
:
&
Options
pipeline_options
:
&
PipelineOptions
)
-
>
Result
<
(
String
TranslationInfo
)
Error
>
{
let
mut
w
=
writer
:
:
Writer
:
:
new
(
String
:
:
new
(
)
)
;
let
info
=
w
.
write
(
module
info
options
pipeline_options
)
?
;
Ok
(
(
w
.
finish
(
)
info
)
)
}
#
[
test
]
fn
test_error_size
(
)
{
use
std
:
:
mem
:
:
size_of
;
assert_eq
!
(
size_of
:
:
<
Error
>
(
)
32
)
;
}
