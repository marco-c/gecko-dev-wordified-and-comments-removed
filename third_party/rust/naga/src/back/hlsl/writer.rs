use
super
:
:
{
help
:
:
{
WrappedArrayLength
WrappedConstructor
WrappedImageQuery
WrappedStructMatrixAccess
}
storage
:
:
StoreValue
BackendResult
Error
Options
}
;
use
crate
:
:
{
back
proc
:
:
{
self
NameKey
}
valid
Handle
Module
ShaderStage
TypeInner
}
;
use
std
:
:
{
fmt
mem
}
;
const
LOCATION_SEMANTIC
:
&
str
=
"
LOC
"
;
const
SPECIAL_CBUF_TYPE
:
&
str
=
"
NagaConstants
"
;
const
SPECIAL_CBUF_VAR
:
&
str
=
"
_NagaConstants
"
;
const
SPECIAL_BASE_VERTEX
:
&
str
=
"
base_vertex
"
;
const
SPECIAL_BASE_INSTANCE
:
&
str
=
"
base_instance
"
;
const
SPECIAL_OTHER
:
&
str
=
"
other
"
;
struct
EpStructMember
{
name
:
String
ty
:
Handle
<
crate
:
:
Type
>
binding
:
Option
<
crate
:
:
Binding
>
index
:
u32
}
struct
EntryPointBinding
{
arg_name
:
String
ty_name
:
String
members
:
Vec
<
EpStructMember
>
}
pub
(
super
)
struct
EntryPointInterface
{
input
:
Option
<
EntryPointBinding
>
output
:
Option
<
EntryPointBinding
>
}
#
[
derive
(
Clone
Eq
PartialEq
PartialOrd
Ord
)
]
enum
InterfaceKey
{
Location
(
u32
)
BuiltIn
(
crate
:
:
BuiltIn
)
Other
}
impl
InterfaceKey
{
const
fn
new
(
binding
:
Option
<
&
crate
:
:
Binding
>
)
-
>
Self
{
match
binding
{
Some
(
&
crate
:
:
Binding
:
:
Location
{
location
.
.
}
)
=
>
Self
:
:
Location
(
location
)
Some
(
&
crate
:
:
Binding
:
:
BuiltIn
(
built_in
)
)
=
>
Self
:
:
BuiltIn
(
built_in
)
None
=
>
Self
:
:
Other
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
enum
Io
{
Input
Output
}
impl
<
'
a
W
:
fmt
:
:
Write
>
super
:
:
Writer
<
'
a
W
>
{
pub
fn
new
(
out
:
W
options
:
&
'
a
Options
)
-
>
Self
{
Self
{
out
names
:
crate
:
:
FastHashMap
:
:
default
(
)
namer
:
proc
:
:
Namer
:
:
default
(
)
options
entry_point_io
:
Vec
:
:
new
(
)
named_expressions
:
crate
:
:
NamedExpressions
:
:
default
(
)
wrapped
:
super
:
:
Wrapped
:
:
default
(
)
temp_access_chain
:
Vec
:
:
new
(
)
}
}
fn
reset
(
&
mut
self
module
:
&
Module
)
{
self
.
names
.
clear
(
)
;
self
.
namer
.
reset
(
module
super
:
:
keywords
:
:
RESERVED
&
[
]
&
mut
self
.
names
)
;
self
.
entry_point_io
.
clear
(
)
;
self
.
named_expressions
.
clear
(
)
;
self
.
wrapped
.
clear
(
)
;
}
pub
fn
write
(
&
mut
self
module
:
&
Module
module_info
:
&
valid
:
:
ModuleInfo
)
-
>
Result
<
super
:
:
ReflectionInfo
Error
>
{
self
.
reset
(
module
)
;
if
let
Some
(
ref
bt
)
=
self
.
options
.
special_constants_binding
{
writeln
!
(
self
.
out
"
struct
{
}
{
{
"
SPECIAL_CBUF_TYPE
)
?
;
writeln
!
(
self
.
out
"
{
}
int
{
}
;
"
back
:
:
INDENT
SPECIAL_BASE_VERTEX
)
?
;
writeln
!
(
self
.
out
"
{
}
int
{
}
;
"
back
:
:
INDENT
SPECIAL_BASE_INSTANCE
)
?
;
writeln
!
(
self
.
out
"
{
}
uint
{
}
;
"
back
:
:
INDENT
SPECIAL_OTHER
)
?
;
writeln
!
(
self
.
out
"
}
}
;
"
)
?
;
write
!
(
self
.
out
"
ConstantBuffer
<
{
}
>
{
}
:
register
(
b
{
}
"
SPECIAL_CBUF_TYPE
SPECIAL_CBUF_VAR
bt
.
register
)
?
;
if
bt
.
space
!
=
0
{
write
!
(
self
.
out
"
space
{
}
"
bt
.
space
)
?
;
}
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
for
(
handle
constant
)
in
module
.
constants
.
iter
(
)
{
if
constant
.
name
.
is_some
(
)
{
self
.
write_global_constant
(
module
&
constant
.
inner
handle
)
?
;
}
}
writeln
!
(
self
.
out
)
?
;
let
ep_results
=
module
.
entry_points
.
iter
(
)
.
map
(
|
ep
|
(
ep
.
stage
ep
.
function
.
result
.
clone
(
)
)
)
.
collect
:
:
<
Vec
<
(
ShaderStage
Option
<
crate
:
:
FunctionResult
>
)
>
>
(
)
;
for
(
handle
ty
)
in
module
.
types
.
iter
(
)
{
if
let
TypeInner
:
:
Struct
{
ref
members
span
}
=
ty
.
inner
{
if
module
.
types
[
members
.
last
(
)
.
unwrap
(
)
.
ty
]
.
inner
.
is_dynamically_sized
(
&
module
.
types
)
{
continue
;
}
let
ep_result
=
ep_results
.
iter
(
)
.
find
(
|
e
|
{
if
let
Some
(
ref
result
)
=
e
.
1
{
result
.
ty
=
=
handle
}
else
{
false
}
}
)
;
self
.
write_struct
(
module
handle
members
span
ep_result
.
map
(
|
r
|
(
r
.
0
Io
:
:
Output
)
)
)
?
;
writeln
!
(
self
.
out
)
?
;
}
}
for
(
_
constant
)
in
module
.
constants
.
iter
(
)
{
self
.
write_wrapped_constructor_function_for_constant
(
module
constant
)
?
;
}
for
(
ty
_
)
in
module
.
global_variables
.
iter
(
)
{
self
.
write_global
(
module
ty
)
?
;
}
if
!
module
.
global_variables
.
is_empty
(
)
{
writeln
!
(
self
.
out
)
?
;
}
for
ep
in
module
.
entry_points
.
iter
(
)
{
let
ep_io
=
self
.
write_ep_interface
(
module
&
ep
.
function
ep
.
stage
&
ep
.
name
)
?
;
self
.
entry_point_io
.
push
(
ep_io
)
;
}
for
(
handle
function
)
in
module
.
functions
.
iter
(
)
{
let
info
=
&
module_info
[
handle
]
;
if
!
self
.
options
.
fake_missing_bindings
{
if
let
Some
(
(
var_handle
_
)
)
=
module
.
global_variables
.
iter
(
)
.
find
(
|
&
(
var_handle
var
)
|
match
var
.
binding
{
Some
(
ref
binding
)
if
!
info
[
var_handle
]
.
is_empty
(
)
=
>
{
self
.
options
.
resolve_resource_binding
(
binding
)
.
is_err
(
)
}
_
=
>
false
}
)
{
log
:
:
info
!
(
"
Skipping
function
{
:
?
}
(
name
{
:
?
}
)
because
global
{
:
?
}
is
inaccessible
"
handle
function
.
name
var_handle
)
;
continue
;
}
}
let
ctx
=
back
:
:
FunctionCtx
{
ty
:
back
:
:
FunctionType
:
:
Function
(
handle
)
info
expressions
:
&
function
.
expressions
named_expressions
:
&
function
.
named_expressions
}
;
let
name
=
self
.
names
[
&
NameKey
:
:
Function
(
handle
)
]
.
clone
(
)
;
self
.
write_wrapped_functions
(
module
&
ctx
)
?
;
self
.
write_function
(
module
name
.
as_str
(
)
function
&
ctx
)
?
;
writeln
!
(
self
.
out
)
?
;
}
let
mut
entry_point_names
=
Vec
:
:
with_capacity
(
module
.
entry_points
.
len
(
)
)
;
for
(
index
ep
)
in
module
.
entry_points
.
iter
(
)
.
enumerate
(
)
{
let
info
=
module_info
.
get_entry_point
(
index
)
;
if
!
self
.
options
.
fake_missing_bindings
{
let
mut
ep_error
=
None
;
for
(
var_handle
var
)
in
module
.
global_variables
.
iter
(
)
{
match
var
.
binding
{
Some
(
ref
binding
)
if
!
info
[
var_handle
]
.
is_empty
(
)
=
>
{
if
let
Err
(
err
)
=
self
.
options
.
resolve_resource_binding
(
binding
)
{
ep_error
=
Some
(
err
)
;
break
;
}
}
_
=
>
{
}
}
}
if
let
Some
(
err
)
=
ep_error
{
entry_point_names
.
push
(
Err
(
err
)
)
;
continue
;
}
}
let
ctx
=
back
:
:
FunctionCtx
{
ty
:
back
:
:
FunctionType
:
:
EntryPoint
(
index
as
u16
)
info
expressions
:
&
ep
.
function
.
expressions
named_expressions
:
&
ep
.
function
.
named_expressions
}
;
self
.
write_wrapped_functions
(
module
&
ctx
)
?
;
if
ep
.
stage
=
=
ShaderStage
:
:
Compute
{
let
num_threads
=
ep
.
workgroup_size
;
writeln
!
(
self
.
out
"
[
numthreads
(
{
}
{
}
{
}
)
]
"
num_threads
[
0
]
num_threads
[
1
]
num_threads
[
2
]
)
?
;
}
let
name
=
self
.
names
[
&
NameKey
:
:
EntryPoint
(
index
as
u16
)
]
.
clone
(
)
;
self
.
write_function
(
module
&
name
&
ep
.
function
&
ctx
)
?
;
if
index
<
module
.
entry_points
.
len
(
)
-
1
{
writeln
!
(
self
.
out
)
?
;
}
entry_point_names
.
push
(
Ok
(
name
)
)
;
}
Ok
(
super
:
:
ReflectionInfo
{
entry_point_names
}
)
}
fn
write_modifier
(
&
mut
self
binding
:
&
crate
:
:
Binding
)
-
>
BackendResult
{
match
*
binding
{
crate
:
:
Binding
:
:
BuiltIn
(
crate
:
:
BuiltIn
:
:
Position
{
invariant
:
true
}
)
=
>
{
write
!
(
self
.
out
"
precise
"
)
?
;
}
crate
:
:
Binding
:
:
Location
{
interpolation
sampling
.
.
}
=
>
{
if
let
Some
(
interpolation
)
=
interpolation
{
if
let
Some
(
string
)
=
interpolation
.
to_hlsl_str
(
)
{
write
!
(
self
.
out
"
{
}
"
string
)
?
}
}
if
let
Some
(
sampling
)
=
sampling
{
if
let
Some
(
string
)
=
sampling
.
to_hlsl_str
(
)
{
write
!
(
self
.
out
"
{
}
"
string
)
?
}
}
}
_
=
>
{
}
}
Ok
(
(
)
)
}
fn
write_semantic
(
&
mut
self
binding
:
&
crate
:
:
Binding
stage
:
Option
<
(
ShaderStage
Io
)
>
)
-
>
BackendResult
{
match
*
binding
{
crate
:
:
Binding
:
:
BuiltIn
(
builtin
)
=
>
{
let
builtin_str
=
builtin
.
to_hlsl_str
(
)
?
;
write
!
(
self
.
out
"
:
{
}
"
builtin_str
)
?
;
}
crate
:
:
Binding
:
:
Location
{
location
.
.
}
=
>
{
if
stage
=
=
Some
(
(
crate
:
:
ShaderStage
:
:
Fragment
Io
:
:
Output
)
)
{
write
!
(
self
.
out
"
:
SV_Target
{
}
"
location
)
?
;
}
else
{
write
!
(
self
.
out
"
:
{
}
{
}
"
LOCATION_SEMANTIC
location
)
?
;
}
}
}
Ok
(
(
)
)
}
fn
write_interface_struct
(
&
mut
self
module
:
&
Module
shader_stage
:
(
ShaderStage
Io
)
struct_name
:
String
mut
members
:
Vec
<
EpStructMember
>
)
-
>
Result
<
EntryPointBinding
Error
>
{
members
.
sort_by_key
(
|
m
|
InterfaceKey
:
:
new
(
m
.
binding
.
as_ref
(
)
)
)
;
write
!
(
self
.
out
"
struct
{
}
"
struct_name
)
?
;
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
m
in
members
.
iter
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
if
let
Some
(
ref
binding
)
=
m
.
binding
{
self
.
write_modifier
(
binding
)
?
;
}
self
.
write_type
(
module
m
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
&
m
.
name
)
?
;
if
let
Some
(
ref
binding
)
=
m
.
binding
{
self
.
write_semantic
(
binding
Some
(
shader_stage
)
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
;
}
writeln
!
(
self
.
out
"
}
}
;
"
)
?
;
writeln
!
(
self
.
out
)
?
;
match
shader_stage
.
1
{
Io
:
:
Input
=
>
{
members
.
sort_by_key
(
|
m
|
m
.
index
)
;
}
Io
:
:
Output
=
>
{
}
}
Ok
(
EntryPointBinding
{
arg_name
:
self
.
namer
.
call
(
struct_name
.
to_lowercase
(
)
.
as_str
(
)
)
ty_name
:
struct_name
members
}
)
}
fn
write_ep_input_struct
(
&
mut
self
module
:
&
Module
func
:
&
crate
:
:
Function
stage
:
ShaderStage
entry_point_name
:
&
str
)
-
>
Result
<
EntryPointBinding
Error
>
{
let
struct_name
=
format
!
(
"
{
:
?
}
Input_
{
}
"
stage
entry_point_name
)
;
let
mut
fake_members
=
Vec
:
:
new
(
)
;
for
arg
in
func
.
arguments
.
iter
(
)
{
match
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
for
member
in
members
.
iter
(
)
{
let
name
=
self
.
namer
.
call_or
(
&
member
.
name
"
member
"
)
;
let
index
=
fake_members
.
len
(
)
as
u32
;
fake_members
.
push
(
EpStructMember
{
name
ty
:
member
.
ty
binding
:
member
.
binding
.
clone
(
)
index
}
)
;
}
}
_
=
>
{
let
member_name
=
self
.
namer
.
call_or
(
&
arg
.
name
"
member
"
)
;
let
index
=
fake_members
.
len
(
)
as
u32
;
fake_members
.
push
(
EpStructMember
{
name
:
member_name
ty
:
arg
.
ty
binding
:
arg
.
binding
.
clone
(
)
index
}
)
;
}
}
}
self
.
write_interface_struct
(
module
(
stage
Io
:
:
Input
)
struct_name
fake_members
)
}
fn
write_ep_output_struct
(
&
mut
self
module
:
&
Module
result
:
&
crate
:
:
FunctionResult
stage
:
ShaderStage
entry_point_name
:
&
str
)
-
>
Result
<
EntryPointBinding
Error
>
{
let
struct_name
=
format
!
(
"
{
:
?
}
Output_
{
}
"
stage
entry_point_name
)
;
let
mut
fake_members
=
Vec
:
:
new
(
)
;
let
empty
=
[
]
;
let
members
=
match
module
.
types
[
result
.
ty
]
.
inner
{
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
members
ref
other
=
>
{
log
:
:
error
!
(
"
Unexpected
{
:
?
}
output
type
without
a
binding
"
other
)
;
&
empty
[
.
.
]
}
}
;
for
member
in
members
.
iter
(
)
{
let
member_name
=
self
.
namer
.
call_or
(
&
member
.
name
"
member
"
)
;
let
index
=
fake_members
.
len
(
)
as
u32
;
fake_members
.
push
(
EpStructMember
{
name
:
member_name
ty
:
member
.
ty
binding
:
member
.
binding
.
clone
(
)
index
}
)
;
}
self
.
write_interface_struct
(
module
(
stage
Io
:
:
Output
)
struct_name
fake_members
)
}
fn
write_ep_interface
(
&
mut
self
module
:
&
Module
func
:
&
crate
:
:
Function
stage
:
ShaderStage
ep_name
:
&
str
)
-
>
Result
<
EntryPointInterface
Error
>
{
Ok
(
EntryPointInterface
{
input
:
if
!
func
.
arguments
.
is_empty
(
)
&
&
stage
=
=
ShaderStage
:
:
Fragment
{
Some
(
self
.
write_ep_input_struct
(
module
func
stage
ep_name
)
?
)
}
else
{
None
}
output
:
match
func
.
result
{
Some
(
ref
fr
)
if
fr
.
binding
.
is_none
(
)
&
&
stage
=
=
ShaderStage
:
:
Vertex
=
>
{
Some
(
self
.
write_ep_output_struct
(
module
fr
stage
ep_name
)
?
)
}
_
=
>
None
}
}
)
}
fn
write_ep_arguments_initialization
(
&
mut
self
module
:
&
Module
func
:
&
crate
:
:
Function
ep_index
:
u16
)
-
>
BackendResult
{
let
ep_input
=
match
self
.
entry_point_io
[
ep_index
as
usize
]
.
input
.
take
(
)
{
Some
(
ep_input
)
=
>
ep_input
None
=
>
return
Ok
(
(
)
)
}
;
let
mut
fake_iter
=
ep_input
.
members
.
iter
(
)
;
for
(
arg_index
arg
)
in
func
.
arguments
.
iter
(
)
.
enumerate
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
self
.
write_type
(
module
arg
.
ty
)
?
;
let
arg_name
=
&
self
.
names
[
&
NameKey
:
:
EntryPointArgument
(
ep_index
arg_index
as
u32
)
]
;
write
!
(
self
.
out
"
{
}
"
arg_name
)
?
;
match
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
{
self
.
write_array_size
(
module
base
size
)
?
;
let
fake_member
=
fake_iter
.
next
(
)
.
unwrap
(
)
;
writeln
!
(
self
.
out
"
=
{
}
.
{
}
;
"
ep_input
.
arg_name
fake_member
.
name
)
?
;
}
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
write
!
(
self
.
out
"
=
{
{
"
)
?
;
for
index
in
0
.
.
members
.
len
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
let
fake_member
=
fake_iter
.
next
(
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
{
}
.
{
}
"
ep_input
.
arg_name
fake_member
.
name
)
?
;
}
writeln
!
(
self
.
out
"
}
}
;
"
)
?
;
}
_
=
>
{
let
fake_member
=
fake_iter
.
next
(
)
.
unwrap
(
)
;
writeln
!
(
self
.
out
"
=
{
}
.
{
}
;
"
ep_input
.
arg_name
fake_member
.
name
)
?
;
}
}
}
assert
!
(
fake_iter
.
next
(
)
.
is_none
(
)
)
;
Ok
(
(
)
)
}
fn
write_global
(
&
mut
self
module
:
&
Module
handle
:
Handle
<
crate
:
:
GlobalVariable
>
)
-
>
BackendResult
{
let
global
=
&
module
.
global_variables
[
handle
]
;
let
inner
=
&
module
.
types
[
global
.
ty
]
.
inner
;
if
let
Some
(
ref
binding
)
=
global
.
binding
{
if
let
Err
(
err
)
=
self
.
options
.
resolve_resource_binding
(
binding
)
{
log
:
:
info
!
(
"
Skipping
global
{
:
?
}
(
name
{
:
?
}
)
for
being
inaccessible
:
{
}
"
handle
global
.
name
err
)
;
return
Ok
(
(
)
)
;
}
}
let
register_ty
=
match
global
.
space
{
crate
:
:
AddressSpace
:
:
Function
=
>
unreachable
!
(
"
Function
address
space
"
)
crate
:
:
AddressSpace
:
:
Private
=
>
{
write
!
(
self
.
out
"
static
"
)
?
;
self
.
write_type
(
module
global
.
ty
)
?
;
"
"
}
crate
:
:
AddressSpace
:
:
WorkGroup
=
>
{
write
!
(
self
.
out
"
groupshared
"
)
?
;
self
.
write_type
(
module
global
.
ty
)
?
;
"
"
}
crate
:
:
AddressSpace
:
:
Uniform
=
>
{
write
!
(
self
.
out
"
cbuffer
"
)
?
;
"
b
"
}
crate
:
:
AddressSpace
:
:
Storage
{
access
}
=
>
{
let
(
prefix
register
)
=
if
access
.
contains
(
crate
:
:
StorageAccess
:
:
STORE
)
{
(
"
RW
"
"
u
"
)
}
else
{
(
"
"
"
t
"
)
}
;
write
!
(
self
.
out
"
{
}
ByteAddressBuffer
"
prefix
)
?
;
register
}
crate
:
:
AddressSpace
:
:
Handle
=
>
{
let
register
=
match
*
inner
{
TypeInner
:
:
Sampler
{
.
.
}
=
>
"
s
"
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
.
.
}
.
.
}
=
>
"
u
"
_
=
>
"
t
"
}
;
self
.
write_type
(
module
global
.
ty
)
?
;
register
}
crate
:
:
AddressSpace
:
:
PushConstant
=
>
unimplemented
!
(
"
Push
constants
"
)
}
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
if
let
Some
(
ref
binding
)
=
global
.
binding
{
let
bt
=
self
.
options
.
resolve_resource_binding
(
binding
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
:
register
(
{
}
{
}
"
register_ty
bt
.
register
)
?
;
if
bt
.
space
!
=
0
{
write
!
(
self
.
out
"
space
{
}
"
bt
.
space
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
else
{
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
module
.
types
[
global
.
ty
]
.
inner
{
self
.
write_array_size
(
module
base
size
)
?
;
}
if
global
.
space
=
=
crate
:
:
AddressSpace
:
:
Private
{
write
!
(
self
.
out
"
=
"
)
?
;
if
let
Some
(
init
)
=
global
.
init
{
self
.
write_constant
(
module
init
)
?
;
}
else
{
self
.
write_default_init
(
module
global
.
ty
)
?
;
}
}
}
if
global
.
space
=
=
crate
:
:
AddressSpace
:
:
Uniform
{
write
!
(
self
.
out
"
{
{
"
)
?
;
if
let
TypeInner
:
:
Matrix
{
.
.
}
=
module
.
types
[
global
.
ty
]
.
inner
{
write
!
(
self
.
out
"
row_major
"
)
?
;
}
self
.
write_type
(
module
global
.
ty
)
?
;
let
sub_name
=
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
;
write
!
(
self
.
out
"
{
}
"
sub_name
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
module
.
types
[
global
.
ty
]
.
inner
{
self
.
write_array_size
(
module
base
size
)
?
;
}
writeln
!
(
self
.
out
"
;
}
}
"
)
?
;
}
else
{
writeln
!
(
self
.
out
"
;
"
)
?
;
}
Ok
(
(
)
)
}
fn
write_global_constant
(
&
mut
self
module
:
&
Module
inner
:
&
crate
:
:
ConstantInner
handle
:
Handle
<
crate
:
:
Constant
>
)
-
>
BackendResult
{
write
!
(
self
.
out
"
static
const
"
)
?
;
match
*
inner
{
crate
:
:
ConstantInner
:
:
Scalar
{
width
:
_
ref
value
}
=
>
{
let
ty_str
=
match
*
value
{
crate
:
:
ScalarValue
:
:
Sint
(
_
)
=
>
"
int
"
crate
:
:
ScalarValue
:
:
Uint
(
_
)
=
>
"
uint
"
crate
:
:
ScalarValue
:
:
Float
(
_
)
=
>
"
float
"
crate
:
:
ScalarValue
:
:
Bool
(
_
)
=
>
"
bool
"
}
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
Constant
(
handle
)
]
;
write
!
(
self
.
out
"
{
}
{
}
=
"
ty_str
name
)
?
;
match
*
value
{
crate
:
:
ScalarValue
:
:
Sint
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
crate
:
:
ScalarValue
:
:
Uint
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
crate
:
:
ScalarValue
:
:
Float
(
value
)
=
>
{
write
!
(
self
.
out
"
{
:
?
}
"
value
)
?
}
crate
:
:
ScalarValue
:
:
Bool
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
}
;
}
crate
:
:
ConstantInner
:
:
Composite
{
ty
ref
components
}
=
>
{
self
.
write_type
(
module
ty
)
?
;
let
name
=
&
self
.
names
[
&
NameKey
:
:
Constant
(
handle
)
]
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
write_composite_constant
(
module
ty
components
)
?
;
}
}
writeln
!
(
self
.
out
"
;
"
)
?
;
Ok
(
(
)
)
}
pub
(
super
)
fn
write_array_size
(
&
mut
self
module
:
&
Module
base
:
Handle
<
crate
:
:
Type
>
size
:
crate
:
:
ArraySize
)
-
>
BackendResult
{
write
!
(
self
.
out
"
[
"
)
?
;
match
size
{
crate
:
:
ArraySize
:
:
Constant
(
const_handle
)
=
>
{
let
size
=
module
.
constants
[
const_handle
]
.
to_array_length
(
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
{
}
"
size
)
?
;
}
crate
:
:
ArraySize
:
:
Dynamic
=
>
unreachable
!
(
)
}
write
!
(
self
.
out
"
]
"
)
?
;
if
let
TypeInner
:
:
Array
{
base
:
next_base
size
:
next_size
.
.
}
=
module
.
types
[
base
]
.
inner
{
self
.
write_array_size
(
module
next_base
next_size
)
?
;
}
Ok
(
(
)
)
}
fn
write_struct
(
&
mut
self
module
:
&
Module
handle
:
Handle
<
crate
:
:
Type
>
members
:
&
[
crate
:
:
StructMember
]
span
:
u32
shader_stage
:
Option
<
(
ShaderStage
Io
)
>
)
-
>
BackendResult
{
let
struct_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
handle
)
]
;
writeln
!
(
self
.
out
"
struct
{
}
{
{
"
struct_name
)
?
;
let
mut
last_offset
=
0
;
for
(
index
member
)
in
members
.
iter
(
)
.
enumerate
(
)
{
if
member
.
binding
.
is_none
(
)
&
&
member
.
offset
>
last_offset
{
let
padding
=
(
member
.
offset
-
last_offset
)
/
4
;
for
i
in
0
.
.
padding
{
writeln
!
(
self
.
out
"
{
}
int
_pad
{
}
_
{
}
;
"
back
:
:
INDENT
index
i
)
?
;
}
}
let
ty_inner
=
&
module
.
types
[
member
.
ty
]
.
inner
;
last_offset
=
member
.
offset
+
ty_inner
.
try_size_hlsl
(
&
module
.
types
&
module
.
constants
)
.
unwrap
(
)
;
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
match
module
.
types
[
member
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
size
stride
:
_
}
=
>
{
if
let
TypeInner
:
:
Matrix
{
.
.
}
=
module
.
types
[
base
]
.
inner
{
write
!
(
self
.
out
"
row_major
"
)
?
;
}
self
.
write_type
(
module
base
)
?
;
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
index
as
u32
)
]
)
?
;
self
.
write_array_size
(
module
base
size
)
?
;
}
TypeInner
:
:
Matrix
{
rows
columns
width
}
if
member
.
binding
.
is_none
(
)
&
&
rows
=
=
crate
:
:
VectorSize
:
:
Bi
=
>
{
let
vec_ty
=
crate
:
:
TypeInner
:
:
Vector
{
size
:
rows
kind
:
crate
:
:
ScalarKind
:
:
Float
width
}
;
let
field_name_key
=
NameKey
:
:
StructMember
(
handle
index
as
u32
)
;
for
i
in
0
.
.
columns
as
u8
{
if
i
!
=
0
{
write
!
(
self
.
out
"
;
"
)
?
;
}
self
.
write_value_type
(
module
&
vec_ty
)
?
;
write
!
(
self
.
out
"
{
}
_
{
}
"
&
self
.
names
[
&
field_name_key
]
i
)
?
;
}
}
_
=
>
{
if
let
Some
(
ref
binding
)
=
member
.
binding
{
self
.
write_modifier
(
binding
)
?
;
}
if
let
TypeInner
:
:
Matrix
{
.
.
}
=
module
.
types
[
member
.
ty
]
.
inner
{
write
!
(
self
.
out
"
row_major
"
)
?
;
}
self
.
write_type
(
module
member
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
handle
index
as
u32
)
]
)
?
;
}
}
if
let
Some
(
ref
binding
)
=
member
.
binding
{
self
.
write_semantic
(
binding
shader_stage
)
?
;
}
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
if
members
.
last
(
)
.
unwrap
(
)
.
binding
.
is_none
(
)
&
&
span
>
last_offset
{
let
padding
=
(
span
-
last_offset
)
/
4
;
for
i
in
0
.
.
padding
{
writeln
!
(
self
.
out
"
{
}
int
_end_pad_
{
}
;
"
back
:
:
INDENT
i
)
?
;
}
}
writeln
!
(
self
.
out
"
}
}
;
"
)
?
;
Ok
(
(
)
)
}
pub
(
super
)
fn
write_type
(
&
mut
self
module
:
&
Module
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
BackendResult
{
let
inner
=
&
module
.
types
[
ty
]
.
inner
;
match
*
inner
{
TypeInner
:
:
Struct
{
.
.
}
=
>
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
)
?
TypeInner
:
:
Array
{
base
.
.
}
=
>
self
.
write_type
(
module
base
)
?
ref
other
=
>
self
.
write_value_type
(
module
other
)
?
}
Ok
(
(
)
)
}
pub
(
super
)
fn
write_value_type
(
&
mut
self
module
:
&
Module
inner
:
&
TypeInner
)
-
>
BackendResult
{
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
width
}
|
TypeInner
:
:
Atomic
{
kind
width
}
=
>
{
write
!
(
self
.
out
"
{
}
"
kind
.
to_hlsl_str
(
width
)
?
)
?
;
}
TypeInner
:
:
Vector
{
size
kind
width
}
=
>
{
write
!
(
self
.
out
"
{
}
{
}
"
kind
.
to_hlsl_str
(
width
)
?
back
:
:
vector_size_str
(
size
)
)
?
;
}
TypeInner
:
:
Matrix
{
columns
rows
width
}
=
>
{
write
!
(
self
.
out
"
{
}
{
}
x
{
}
"
crate
:
:
ScalarKind
:
:
Float
.
to_hlsl_str
(
width
)
?
back
:
:
vector_size_str
(
columns
)
back
:
:
vector_size_str
(
rows
)
)
?
;
}
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
self
.
write_image_type
(
dim
arrayed
class
)
?
;
}
TypeInner
:
:
Sampler
{
comparison
}
=
>
{
let
sampler
=
if
comparison
{
"
SamplerComparisonState
"
}
else
{
"
SamplerState
"
}
;
write
!
(
self
.
out
"
{
}
"
sampler
)
?
;
}
TypeInner
:
:
Array
{
base
size
.
.
}
=
>
{
self
.
write_array_size
(
module
base
size
)
?
;
}
_
=
>
{
return
Err
(
Error
:
:
Unimplemented
(
format
!
(
"
write_value_type
{
:
?
}
"
inner
)
)
)
}
}
Ok
(
(
)
)
}
fn
write_function
(
&
mut
self
module
:
&
Module
name
:
&
str
func
:
&
crate
:
:
Function
func_ctx
:
&
back
:
:
FunctionCtx
<
'
_
>
)
-
>
BackendResult
{
if
let
Some
(
crate
:
:
FunctionResult
{
binding
:
Some
(
ref
binding
crate
:
:
Binding
:
:
BuiltIn
(
crate
:
:
BuiltIn
:
:
Position
{
invariant
:
true
}
)
)
.
.
}
)
=
func
.
result
{
self
.
write_modifier
(
binding
)
?
;
}
if
let
Some
(
ref
result
)
=
func
.
result
{
match
func_ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
_
)
=
>
{
self
.
write_type
(
module
result
.
ty
)
?
;
}
back
:
:
FunctionType
:
:
EntryPoint
(
index
)
=
>
{
if
let
Some
(
ref
ep_output
)
=
self
.
entry_point_io
[
index
as
usize
]
.
output
{
write
!
(
self
.
out
"
{
}
"
ep_output
.
ty_name
)
?
;
}
else
{
self
.
write_type
(
module
result
.
ty
)
?
;
}
}
}
}
else
{
write
!
(
self
.
out
"
void
"
)
?
;
}
write
!
(
self
.
out
"
{
}
(
"
name
)
?
;
match
func_ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
handle
)
=
>
{
for
(
index
arg
)
in
func
.
arguments
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
let
arg_ty
=
match
module
.
types
[
arg
.
ty
]
.
inner
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
{
write
!
(
self
.
out
"
inout
"
)
?
;
base
}
_
=
>
arg
.
ty
}
;
self
.
write_type
(
module
arg_ty
)
?
;
let
argument_name
=
&
self
.
names
[
&
NameKey
:
:
FunctionArgument
(
handle
index
as
u32
)
]
;
write
!
(
self
.
out
"
{
}
"
argument_name
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
module
.
types
[
arg
.
ty
]
.
inner
{
self
.
write_array_size
(
module
base
size
)
?
;
}
}
}
back
:
:
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
{
if
let
Some
(
ref
ep_input
)
=
self
.
entry_point_io
[
ep_index
as
usize
]
.
input
{
write
!
(
self
.
out
"
{
}
{
}
"
ep_input
.
ty_name
ep_input
.
arg_name
)
?
;
}
else
{
let
stage
=
module
.
entry_points
[
ep_index
as
usize
]
.
stage
;
for
(
index
arg
)
in
func
.
arguments
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_type
(
module
arg
.
ty
)
?
;
let
argument_name
=
&
self
.
names
[
&
NameKey
:
:
EntryPointArgument
(
ep_index
index
as
u32
)
]
;
write
!
(
self
.
out
"
{
}
"
argument_name
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
module
.
types
[
arg
.
ty
]
.
inner
{
self
.
write_array_size
(
module
base
size
)
?
;
}
if
let
Some
(
ref
binding
)
=
arg
.
binding
{
self
.
write_semantic
(
binding
Some
(
(
stage
Io
:
:
Input
)
)
)
?
;
}
}
}
}
}
write
!
(
self
.
out
"
)
"
)
?
;
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
index
)
=
func_ctx
.
ty
{
let
stage
=
module
.
entry_points
[
index
as
usize
]
.
stage
;
if
let
Some
(
crate
:
:
FunctionResult
{
binding
:
Some
(
ref
binding
)
.
.
}
)
=
func
.
result
{
self
.
write_semantic
(
binding
Some
(
(
stage
Io
:
:
Output
)
)
)
?
;
}
}
writeln
!
(
self
.
out
)
?
;
writeln
!
(
self
.
out
"
{
{
"
)
?
;
if
let
back
:
:
FunctionType
:
:
EntryPoint
(
index
)
=
func_ctx
.
ty
{
self
.
write_ep_arguments_initialization
(
module
func
index
)
?
;
}
for
(
handle
local
)
in
func
.
local_variables
.
iter
(
)
{
write
!
(
self
.
out
"
{
}
"
back
:
:
INDENT
)
?
;
self
.
write_type
(
module
local
.
ty
)
?
;
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
func_ctx
.
name_key
(
handle
)
]
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
module
.
types
[
local
.
ty
]
.
inner
{
self
.
write_array_size
(
module
base
size
)
?
;
}
write
!
(
self
.
out
"
=
"
)
?
;
if
let
Some
(
init
)
=
local
.
init
{
self
.
write_constant
(
module
init
)
?
;
}
else
{
self
.
write_default_init
(
module
local
.
ty
)
?
;
}
writeln
!
(
self
.
out
"
;
"
)
?
}
if
!
func
.
local_variables
.
is_empty
(
)
{
writeln
!
(
self
.
out
)
?
;
}
for
sta
in
func
.
body
.
iter
(
)
{
self
.
write_stmt
(
module
sta
func_ctx
back
:
:
Level
(
1
)
)
?
;
}
writeln
!
(
self
.
out
"
}
}
"
)
?
;
self
.
named_expressions
.
clear
(
)
;
Ok
(
(
)
)
}
fn
write_stmt
(
&
mut
self
module
:
&
Module
stmt
:
&
crate
:
:
Statement
func_ctx
:
&
back
:
:
FunctionCtx
<
'
_
>
level
:
back
:
:
Level
)
-
>
BackendResult
{
use
crate
:
:
Statement
;
match
*
stmt
{
Statement
:
:
Emit
(
ref
range
)
=
>
{
for
handle
in
range
.
clone
(
)
{
let
info
=
&
func_ctx
.
info
[
handle
]
;
let
ptr_class
=
info
.
ty
.
inner_with
(
&
module
.
types
)
.
pointer_space
(
)
;
let
expr_name
=
if
ptr_class
.
is_some
(
)
{
None
}
else
if
let
Some
(
name
)
=
func_ctx
.
named_expressions
.
get
(
&
handle
)
{
Some
(
self
.
namer
.
call
(
name
)
)
}
else
{
let
min_ref_count
=
func_ctx
.
expressions
[
handle
]
.
bake_ref_count
(
)
;
if
min_ref_count
<
=
info
.
ref_count
{
Some
(
format
!
(
"
_expr
{
}
"
handle
.
index
(
)
)
)
}
else
{
None
}
}
;
if
let
Some
(
name
)
=
expr_name
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
self
.
write_named_expr
(
module
handle
name
func_ctx
)
?
;
}
}
}
Statement
:
:
Block
(
ref
block
)
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
writeln
!
(
self
.
out
"
{
{
"
)
?
;
for
sta
in
block
.
iter
(
)
{
self
.
write_stmt
(
module
sta
func_ctx
level
.
next
(
)
)
?
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
If
{
condition
ref
accept
ref
reject
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
write
!
(
self
.
out
"
if
(
"
)
?
;
self
.
write_expr
(
module
condition
func_ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
let
l2
=
level
.
next
(
)
;
for
sta
in
accept
{
self
.
write_stmt
(
module
sta
func_ctx
l2
)
?
;
}
if
!
reject
.
is_empty
(
)
{
writeln
!
(
self
.
out
"
{
}
}
}
else
{
{
"
level
)
?
;
for
sta
in
reject
{
self
.
write_stmt
(
module
sta
func_ctx
l2
)
?
;
}
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
Kill
=
>
writeln
!
(
self
.
out
"
{
}
discard
;
"
level
)
?
Statement
:
:
Return
{
value
:
None
}
=
>
{
writeln
!
(
self
.
out
"
{
}
return
;
"
level
)
?
;
}
Statement
:
:
Return
{
value
:
Some
(
expr
)
}
=
>
{
let
base_ty_res
=
&
func_ctx
.
info
[
expr
]
.
ty
;
let
mut
resolved
=
base_ty_res
.
inner_with
(
&
module
.
types
)
;
if
let
TypeInner
:
:
Pointer
{
base
space
:
_
}
=
*
resolved
{
resolved
=
&
module
.
types
[
base
]
.
inner
;
}
if
let
TypeInner
:
:
Struct
{
.
.
}
=
*
resolved
{
let
ty
=
base_ty_res
.
handle
(
)
.
unwrap
(
)
;
let
struct_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty
)
]
;
let
variable_name
=
self
.
namer
.
call
(
&
struct_name
.
to_lowercase
(
)
)
;
write
!
(
self
.
out
"
{
}
const
{
}
{
}
=
"
level
struct_name
variable_name
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
let
ep_output
=
match
func_ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
_
)
=
>
None
back
:
:
FunctionType
:
:
EntryPoint
(
index
)
=
>
{
self
.
entry_point_io
[
index
as
usize
]
.
output
.
as_ref
(
)
}
}
;
let
final_name
=
match
ep_output
{
Some
(
ep_output
)
=
>
{
let
final_name
=
self
.
namer
.
call
(
&
variable_name
)
;
write
!
(
self
.
out
"
{
}
const
{
}
{
}
=
{
{
"
level
ep_output
.
ty_name
final_name
)
?
;
for
(
index
m
)
in
ep_output
.
members
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
let
member_name
=
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
m
.
index
)
]
;
write
!
(
self
.
out
"
{
}
.
{
}
"
variable_name
member_name
)
?
;
}
writeln
!
(
self
.
out
"
}
}
;
"
)
?
;
final_name
}
None
=
>
variable_name
}
;
writeln
!
(
self
.
out
"
{
}
return
{
}
;
"
level
final_name
)
?
;
}
else
{
write
!
(
self
.
out
"
{
}
return
"
level
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
}
}
Statement
:
:
Store
{
pointer
value
}
=
>
{
let
ty_inner
=
func_ctx
.
info
[
pointer
]
.
ty
.
inner_with
(
&
module
.
types
)
;
let
array_info
=
match
*
ty_inner
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
match
module
.
types
[
base
]
.
inner
{
crate
:
:
TypeInner
:
:
Array
{
size
:
crate
:
:
ArraySize
:
:
Constant
(
ch
)
.
.
}
=
>
Some
(
(
ch
base
)
)
_
=
>
None
}
_
=
>
None
}
;
if
let
Some
(
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
)
=
ty_inner
.
pointer_space
(
)
{
let
var_handle
=
self
.
fill_access_chain
(
module
pointer
func_ctx
)
?
;
self
.
write_storage_store
(
module
var_handle
StoreValue
:
:
Expression
(
value
)
func_ctx
level
)
?
;
}
else
if
let
Some
(
(
const_handle
base_ty
)
)
=
array_info
{
let
size
=
module
.
constants
[
const_handle
]
.
to_array_length
(
)
.
unwrap
(
)
;
writeln
!
(
self
.
out
"
{
}
{
{
"
level
)
?
;
write
!
(
self
.
out
"
{
}
"
level
.
next
(
)
)
?
;
self
.
write_type
(
module
base_ty
)
?
;
write
!
(
self
.
out
"
_result
[
{
}
]
=
"
size
)
?
;
self
.
write_expr
(
module
value
func_ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
write
!
(
self
.
out
"
{
}
for
(
int
_i
=
0
;
_i
<
{
}
;
+
+
_i
)
"
level
.
next
(
)
size
)
?
;
self
.
write_expr
(
module
pointer
func_ctx
)
?
;
writeln
!
(
self
.
out
"
[
_i
]
=
_result
[
_i
]
;
"
)
?
;
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
;
}
else
{
struct
MatrixAccess
{
base
:
Handle
<
crate
:
:
Expression
>
index
:
u32
}
enum
Index
{
Expression
(
Handle
<
crate
:
:
Expression
>
)
Static
(
u32
)
}
let
get_members
=
|
expr
:
Handle
<
crate
:
:
Expression
>
|
{
let
base_ty_res
=
&
func_ctx
.
info
[
expr
]
.
ty
;
let
resolved
=
base_ty_res
.
inner_with
(
&
module
.
types
)
;
match
*
resolved
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
match
module
.
types
[
base
]
.
inner
{
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
Some
(
members
)
_
=
>
None
}
_
=
>
None
}
}
;
let
mut
matrix
=
None
;
let
mut
vector
=
None
;
let
mut
scalar
=
None
;
let
mut
current_expr
=
pointer
;
for
_
in
0
.
.
3
{
let
resolved
=
func_ctx
.
info
[
current_expr
]
.
ty
.
inner_with
(
&
module
.
types
)
;
match
(
resolved
&
func_ctx
.
expressions
[
current_expr
]
)
{
(
&
TypeInner
:
:
Pointer
{
base
:
ty
.
.
}
&
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
)
if
matches
!
(
module
.
types
[
ty
]
.
inner
TypeInner
:
:
Matrix
{
rows
:
crate
:
:
VectorSize
:
:
Bi
.
.
}
)
&
&
get_members
(
base
)
.
map
(
|
members
|
members
[
index
as
usize
]
.
binding
.
is_none
(
)
)
=
=
Some
(
true
)
=
>
{
matrix
=
Some
(
MatrixAccess
{
base
index
}
)
;
break
;
}
(
&
TypeInner
:
:
ValuePointer
{
size
:
Some
(
crate
:
:
VectorSize
:
:
Bi
)
.
.
}
&
crate
:
:
Expression
:
:
Access
{
base
index
}
)
=
>
{
vector
=
Some
(
Index
:
:
Expression
(
index
)
)
;
current_expr
=
base
;
}
(
&
TypeInner
:
:
ValuePointer
{
size
:
Some
(
crate
:
:
VectorSize
:
:
Bi
)
.
.
}
&
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
)
=
>
{
vector
=
Some
(
Index
:
:
Static
(
index
)
)
;
current_expr
=
base
;
}
(
&
TypeInner
:
:
ValuePointer
{
size
:
None
.
.
}
&
crate
:
:
Expression
:
:
Access
{
base
index
}
)
=
>
{
scalar
=
Some
(
Index
:
:
Expression
(
index
)
)
;
current_expr
=
base
;
}
(
&
TypeInner
:
:
ValuePointer
{
size
:
None
.
.
}
&
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
)
=
>
{
scalar
=
Some
(
Index
:
:
Static
(
index
)
)
;
current_expr
=
base
;
}
_
=
>
break
}
}
write
!
(
self
.
out
"
{
}
"
level
)
?
;
if
let
Some
(
MatrixAccess
{
index
base
}
)
=
matrix
{
let
base_ty_res
=
&
func_ctx
.
info
[
base
]
.
ty
;
let
resolved
=
base_ty_res
.
inner_with
(
&
module
.
types
)
;
let
ty
=
match
*
resolved
{
TypeInner
:
:
Pointer
{
base
.
.
}
=
>
base
_
=
>
base_ty_res
.
handle
(
)
.
unwrap
(
)
}
;
if
let
Some
(
Index
:
:
Static
(
vec_index
)
)
=
vector
{
self
.
write_expr
(
module
base
func_ctx
)
?
;
write
!
(
self
.
out
"
.
{
}
_
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
index
)
]
vec_index
)
?
;
if
let
Some
(
scalar_index
)
=
scalar
{
write
!
(
self
.
out
"
[
"
)
?
;
match
scalar_index
{
Index
:
:
Static
(
index
)
=
>
{
write
!
(
self
.
out
"
{
}
"
index
)
?
;
}
Index
:
:
Expression
(
index
)
=
>
{
self
.
write_expr
(
module
index
func_ctx
)
?
;
}
}
write
!
(
self
.
out
"
]
"
)
?
;
}
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
module
value
func_ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
else
{
let
access
=
WrappedStructMatrixAccess
{
ty
index
}
;
match
(
&
vector
&
scalar
)
{
(
&
Some
(
_
)
&
Some
(
_
)
)
=
>
{
self
.
write_wrapped_struct_matrix_set_scalar_function_name
(
access
)
?
;
}
(
&
Some
(
_
)
&
None
)
=
>
{
self
.
write_wrapped_struct_matrix_set_vec_function_name
(
access
)
?
;
}
(
&
None
_
)
=
>
{
self
.
write_wrapped_struct_matrix_set_function_name
(
access
)
?
;
}
}
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
module
base
func_ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
value
func_ctx
)
?
;
if
let
Some
(
Index
:
:
Expression
(
vec_index
)
)
=
vector
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
vec_index
func_ctx
)
?
;
if
let
Some
(
scalar_index
)
=
scalar
{
write
!
(
self
.
out
"
"
)
?
;
match
scalar_index
{
Index
:
:
Static
(
index
)
=
>
{
write
!
(
self
.
out
"
{
}
"
index
)
?
;
}
Index
:
:
Expression
(
index
)
=
>
{
self
.
write_expr
(
module
index
func_ctx
)
?
;
}
}
}
}
writeln
!
(
self
.
out
"
)
;
"
)
?
;
}
}
else
{
self
.
write_expr
(
module
pointer
func_ctx
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
module
value
func_ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
}
}
}
Statement
:
:
Loop
{
ref
body
ref
continuing
}
=
>
{
let
l2
=
level
.
next
(
)
;
if
!
continuing
.
is_empty
(
)
{
let
gate_name
=
self
.
namer
.
call
(
"
loop_init
"
)
;
writeln
!
(
self
.
out
"
{
}
bool
{
}
=
true
;
"
level
gate_name
)
?
;
writeln
!
(
self
.
out
"
{
}
while
(
true
)
{
{
"
level
)
?
;
writeln
!
(
self
.
out
"
{
}
if
(
!
{
}
)
{
{
"
l2
gate_name
)
?
;
for
sta
in
continuing
.
iter
(
)
{
self
.
write_stmt
(
module
sta
func_ctx
l2
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
.
next
(
)
)
?
;
writeln
!
(
self
.
out
"
{
}
{
}
=
false
;
"
level
.
next
(
)
gate_name
)
?
;
}
else
{
writeln
!
(
self
.
out
"
{
}
while
(
true
)
{
{
"
level
)
?
;
}
for
sta
in
body
.
iter
(
)
{
self
.
write_stmt
(
module
sta
func_ctx
l2
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
Statement
:
:
Break
=
>
writeln
!
(
self
.
out
"
{
}
break
;
"
level
)
?
Statement
:
:
Continue
=
>
writeln
!
(
self
.
out
"
{
}
continue
;
"
level
)
?
Statement
:
:
Barrier
(
barrier
)
=
>
{
if
barrier
.
contains
(
crate
:
:
Barrier
:
:
STORAGE
)
{
writeln
!
(
self
.
out
"
{
}
DeviceMemoryBarrierWithGroupSync
(
)
;
"
level
)
?
;
}
if
barrier
.
contains
(
crate
:
:
Barrier
:
:
WORK_GROUP
)
{
writeln
!
(
self
.
out
"
{
}
GroupMemoryBarrierWithGroupSync
(
)
;
"
level
)
?
;
}
}
Statement
:
:
ImageStore
{
image
coordinate
array_index
value
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
self
.
write_expr
(
module
image
func_ctx
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
if
let
Some
(
index
)
=
array_index
{
write
!
(
self
.
out
"
int3
(
"
)
?
;
self
.
write_expr
(
module
coordinate
func_ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
index
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
else
{
self
.
write_expr
(
module
coordinate
func_ctx
)
?
;
}
write
!
(
self
.
out
"
]
"
)
?
;
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
module
value
func_ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
}
Statement
:
:
Call
{
function
ref
arguments
result
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
if
let
Some
(
expr
)
=
result
{
write
!
(
self
.
out
"
const
"
)
?
;
let
name
=
format
!
(
"
{
}
{
}
"
back
:
:
BAKE_PREFIX
expr
.
index
(
)
)
;
let
expr_ty
=
&
func_ctx
.
info
[
expr
]
.
ty
;
match
*
expr_ty
{
proc
:
:
TypeResolution
:
:
Handle
(
handle
)
=
>
self
.
write_type
(
module
handle
)
?
proc
:
:
TypeResolution
:
:
Value
(
ref
value
)
=
>
{
self
.
write_value_type
(
module
value
)
?
}
}
;
write
!
(
self
.
out
"
{
}
=
"
name
)
?
;
self
.
named_expressions
.
insert
(
expr
name
)
;
}
let
func_name
=
&
self
.
names
[
&
NameKey
:
:
Function
(
function
)
]
;
write
!
(
self
.
out
"
{
}
(
"
func_name
)
?
;
for
(
index
argument
)
in
arguments
.
iter
(
)
.
enumerate
(
)
{
self
.
write_expr
(
module
*
argument
func_ctx
)
?
;
if
index
!
=
arguments
.
len
(
)
.
saturating_sub
(
1
)
{
write
!
(
self
.
out
"
"
)
?
;
}
}
writeln
!
(
self
.
out
"
)
;
"
)
?
}
Statement
:
:
Atomic
{
pointer
ref
fun
value
result
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
let
res_name
=
format
!
(
"
{
}
{
}
"
back
:
:
BAKE_PREFIX
result
.
index
(
)
)
;
match
func_ctx
.
info
[
result
]
.
ty
{
proc
:
:
TypeResolution
:
:
Handle
(
handle
)
=
>
self
.
write_type
(
module
handle
)
?
proc
:
:
TypeResolution
:
:
Value
(
ref
value
)
=
>
{
self
.
write_value_type
(
module
value
)
?
}
}
;
let
var_handle
=
self
.
fill_access_chain
(
module
pointer
func_ctx
)
?
;
let
chain
=
mem
:
:
take
(
&
mut
self
.
temp_access_chain
)
;
let
var_name
=
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
var_handle
)
]
;
let
fun_str
=
fun
.
to_hlsl_suffix
(
)
;
write
!
(
self
.
out
"
{
}
;
{
}
.
Interlocked
{
}
(
"
res_name
var_name
fun_str
)
?
;
self
.
write_storage_address
(
module
&
chain
func_ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
match
*
fun
{
crate
:
:
AtomicFunction
:
:
Subtract
=
>
{
write
!
(
self
.
out
"
-
"
)
?
;
}
crate
:
:
AtomicFunction
:
:
Exchange
{
compare
:
Some
(
_
)
}
=
>
{
return
Err
(
Error
:
:
Unimplemented
(
"
atomic
CompareExchange
"
.
to_string
(
)
)
)
;
}
_
=
>
{
}
}
self
.
write_expr
(
module
value
func_ctx
)
?
;
writeln
!
(
self
.
out
"
{
}
)
;
"
res_name
)
?
;
self
.
temp_access_chain
=
chain
;
self
.
named_expressions
.
insert
(
result
res_name
)
;
}
Statement
:
:
Switch
{
selector
ref
cases
}
=
>
{
write
!
(
self
.
out
"
{
}
"
level
)
?
;
write
!
(
self
.
out
"
switch
(
"
)
?
;
self
.
write_expr
(
module
selector
func_ctx
)
?
;
writeln
!
(
self
.
out
"
)
{
{
"
)
?
;
let
type_postfix
=
match
*
func_ctx
.
info
[
selector
]
.
ty
.
inner_with
(
&
module
.
types
)
{
crate
:
:
TypeInner
:
:
Scalar
{
kind
:
crate
:
:
ScalarKind
:
:
Uint
.
.
}
=
>
"
u
"
_
=
>
"
"
}
;
let
indent_level_1
=
level
.
next
(
)
;
let
indent_level_2
=
indent_level_1
.
next
(
)
;
for
case
in
cases
{
match
case
.
value
{
crate
:
:
SwitchValue
:
:
Integer
(
value
)
=
>
writeln
!
(
self
.
out
"
{
}
case
{
}
{
}
:
{
{
"
indent_level_1
value
type_postfix
)
?
crate
:
:
SwitchValue
:
:
Default
=
>
{
writeln
!
(
self
.
out
"
{
}
default
:
{
{
"
indent_level_1
)
?
}
}
if
case
.
fall_through
{
writeln
!
(
self
.
out
"
{
}
/
*
fallthrough
*
/
"
indent_level_2
)
?
;
writeln
!
(
self
.
out
"
{
}
{
{
"
indent_level_2
)
?
;
}
for
sta
in
case
.
body
.
iter
(
)
{
self
.
write_stmt
(
module
sta
func_ctx
back
:
:
Level
(
indent_level_2
.
0
+
usize
:
:
from
(
case
.
fall_through
)
)
)
?
;
}
if
case
.
fall_through
{
writeln
!
(
self
.
out
"
{
}
}
}
"
indent_level_2
)
?
;
}
else
if
case
.
body
.
last
(
)
.
map_or
(
true
|
s
|
!
s
.
is_terminator
(
)
)
{
writeln
!
(
self
.
out
"
{
}
break
;
"
indent_level_2
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
indent_level_1
)
?
;
}
writeln
!
(
self
.
out
"
{
}
}
}
"
level
)
?
}
}
Ok
(
(
)
)
}
pub
(
super
)
fn
write_expr
(
&
mut
self
module
:
&
Module
expr
:
Handle
<
crate
:
:
Expression
>
func_ctx
:
&
back
:
:
FunctionCtx
<
'
_
>
)
-
>
BackendResult
{
use
crate
:
:
Expression
;
let
ff_input
=
if
self
.
options
.
special_constants_binding
.
is_some
(
)
{
func_ctx
.
is_fixed_function_input
(
expr
module
)
}
else
{
None
}
;
let
closing_bracket
=
match
ff_input
{
Some
(
crate
:
:
BuiltIn
:
:
VertexIndex
)
=
>
{
write
!
(
self
.
out
"
(
{
}
.
{
}
+
"
SPECIAL_CBUF_VAR
SPECIAL_BASE_VERTEX
)
?
;
"
)
"
}
Some
(
crate
:
:
BuiltIn
:
:
InstanceIndex
)
=
>
{
write
!
(
self
.
out
"
(
{
}
.
{
}
+
"
SPECIAL_CBUF_VAR
SPECIAL_BASE_INSTANCE
)
?
;
"
)
"
}
Some
(
crate
:
:
BuiltIn
:
:
NumWorkGroups
)
=
>
{
write
!
(
self
.
out
"
uint3
(
{
}
.
{
}
{
}
.
{
}
{
}
.
{
}
)
"
SPECIAL_CBUF_VAR
SPECIAL_BASE_VERTEX
SPECIAL_CBUF_VAR
SPECIAL_BASE_INSTANCE
SPECIAL_CBUF_VAR
SPECIAL_OTHER
)
?
;
return
Ok
(
(
)
)
;
}
_
=
>
"
"
}
;
if
let
Some
(
name
)
=
self
.
named_expressions
.
get
(
&
expr
)
{
write
!
(
self
.
out
"
{
}
{
}
"
name
closing_bracket
)
?
;
return
Ok
(
(
)
)
;
}
let
expression
=
&
func_ctx
.
expressions
[
expr
]
;
match
*
expression
{
Expression
:
:
Constant
(
constant
)
=
>
self
.
write_constant
(
module
constant
)
?
Expression
:
:
Compose
{
ty
ref
components
}
=
>
{
match
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Struct
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
=
>
{
self
.
write_wrapped_constructor_function_name
(
module
WrappedConstructor
{
ty
}
)
?
;
}
_
=
>
{
self
.
write_type
(
module
ty
)
?
;
}
}
;
write
!
(
self
.
out
"
(
"
)
?
;
for
(
index
&
component
)
in
components
.
iter
(
)
.
enumerate
(
)
{
if
index
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_expr
(
module
component
func_ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
Binary
{
op
:
crate
:
:
BinaryOperator
:
:
Multiply
left
right
}
if
func_ctx
.
info
[
left
]
.
ty
.
inner_with
(
&
module
.
types
)
.
is_matrix
(
)
|
|
func_ctx
.
info
[
right
]
.
ty
.
inner_with
(
&
module
.
types
)
.
is_matrix
(
)
=
>
{
write
!
(
self
.
out
"
mul
(
"
)
?
;
self
.
write_expr
(
module
right
func_ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
left
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
Binary
{
op
left
right
}
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
module
left
func_ctx
)
?
;
write
!
(
self
.
out
"
{
}
"
crate
:
:
back
:
:
binary_operation_str
(
op
)
)
?
;
self
.
write_expr
(
module
right
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
Access
{
base
index
}
=
>
{
if
let
Some
(
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
)
=
func_ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
module
.
types
)
.
pointer_space
(
)
{
}
else
{
self
.
write_expr
(
module
base
func_ctx
)
?
;
write
!
(
self
.
out
"
[
"
)
?
;
self
.
write_expr
(
module
index
func_ctx
)
?
;
write
!
(
self
.
out
"
]
"
)
?
;
}
}
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
if
let
Some
(
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
)
=
func_ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
module
.
types
)
.
pointer_space
(
)
{
}
else
{
let
base_ty_res
=
&
func_ctx
.
info
[
base
]
.
ty
;
let
mut
resolved
=
base_ty_res
.
inner_with
(
&
module
.
types
)
;
let
base_ty_handle
=
match
*
resolved
{
TypeInner
:
:
Pointer
{
base
space
:
_
}
=
>
{
resolved
=
&
module
.
types
[
base
]
.
inner
;
Some
(
base
)
}
_
=
>
base_ty_res
.
handle
(
)
}
;
if
let
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
*
resolved
{
let
member
=
&
members
[
index
as
usize
]
;
match
module
.
types
[
member
.
ty
]
.
inner
{
TypeInner
:
:
Matrix
{
rows
:
crate
:
:
VectorSize
:
:
Bi
.
.
}
if
member
.
binding
.
is_none
(
)
=
>
{
let
ty
=
base_ty_handle
.
unwrap
(
)
;
self
.
write_wrapped_struct_matrix_get_function_name
(
WrappedStructMatrixAccess
{
ty
index
}
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
module
base
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
return
Ok
(
(
)
)
;
}
_
=
>
{
}
}
}
;
self
.
write_expr
(
module
base
func_ctx
)
?
;
match
*
resolved
{
TypeInner
:
:
Vector
{
.
.
}
=
>
{
write
!
(
self
.
out
"
.
{
}
"
back
:
:
COMPONENTS
[
index
as
usize
]
)
?
}
TypeInner
:
:
Matrix
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
|
TypeInner
:
:
ValuePointer
{
.
.
}
=
>
write
!
(
self
.
out
"
[
{
}
]
"
index
)
?
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty
=
base_ty_handle
.
unwrap
(
)
;
write
!
(
self
.
out
"
.
{
}
"
&
self
.
names
[
&
NameKey
:
:
StructMember
(
ty
index
)
]
)
?
}
ref
other
=
>
{
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
index
{
:
?
}
"
other
)
)
)
}
}
}
}
Expression
:
:
FunctionArgument
(
pos
)
=
>
{
let
key
=
match
func_ctx
.
ty
{
back
:
:
FunctionType
:
:
Function
(
handle
)
=
>
NameKey
:
:
FunctionArgument
(
handle
pos
)
back
:
:
FunctionType
:
:
EntryPoint
(
index
)
=
>
{
NameKey
:
:
EntryPointArgument
(
index
pos
)
}
}
;
let
name
=
&
self
.
names
[
&
key
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
}
Expression
:
:
ImageSample
{
image
sampler
gather
coordinate
array_index
offset
level
depth_ref
}
=
>
{
use
crate
:
:
SampleLevel
as
Sl
;
const
COMPONENTS
:
[
&
str
;
4
]
=
[
"
"
"
Green
"
"
Blue
"
"
Alpha
"
]
;
let
(
base_str
component_str
)
=
match
gather
{
Some
(
component
)
=
>
(
"
Gather
"
COMPONENTS
[
component
as
usize
]
)
None
=
>
(
"
Sample
"
"
"
)
}
;
let
cmp_str
=
match
depth_ref
{
Some
(
_
)
=
>
"
Cmp
"
None
=
>
"
"
}
;
let
level_str
=
match
level
{
Sl
:
:
Zero
if
gather
.
is_none
(
)
=
>
"
LevelZero
"
Sl
:
:
Auto
|
Sl
:
:
Zero
=
>
"
"
Sl
:
:
Exact
(
_
)
=
>
"
Level
"
Sl
:
:
Bias
(
_
)
=
>
"
Bias
"
Sl
:
:
Gradient
{
.
.
}
=
>
"
Grad
"
}
;
self
.
write_expr
(
module
image
func_ctx
)
?
;
write
!
(
self
.
out
"
.
{
}
{
}
{
}
{
}
(
"
base_str
cmp_str
component_str
level_str
)
?
;
self
.
write_expr
(
module
sampler
func_ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_texture_coordinates
(
"
float
"
coordinate
array_index
None
module
func_ctx
)
?
;
if
let
Some
(
depth_ref
)
=
depth_ref
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
depth_ref
func_ctx
)
?
;
}
match
level
{
Sl
:
:
Auto
|
Sl
:
:
Zero
=
>
{
}
Sl
:
:
Exact
(
expr
)
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
}
Sl
:
:
Bias
(
expr
)
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
}
Sl
:
:
Gradient
{
x
y
}
=
>
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
x
func_ctx
)
?
;
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
y
func_ctx
)
?
;
}
}
if
let
Some
(
offset
)
=
offset
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_constant
(
module
offset
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
ImageQuery
{
image
query
}
=
>
{
if
let
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
*
func_ctx
.
info
[
image
]
.
ty
.
inner_with
(
&
module
.
types
)
{
let
wrapped_image_query
=
WrappedImageQuery
{
dim
arrayed
class
query
:
query
.
into
(
)
}
;
self
.
write_wrapped_image_query_function_name
(
wrapped_image_query
)
?
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
module
image
func_ctx
)
?
;
if
let
crate
:
:
ImageQuery
:
:
Size
{
level
:
Some
(
level
)
}
=
query
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
level
func_ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
}
}
Expression
:
:
ImageLoad
{
image
coordinate
array_index
sample
level
}
=
>
{
self
.
write_expr
(
module
image
func_ctx
)
?
;
write
!
(
self
.
out
"
.
Load
(
"
)
?
;
self
.
write_texture_coordinates
(
"
int
"
coordinate
array_index
level
module
func_ctx
)
?
;
if
let
Some
(
sample
)
=
sample
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
sample
func_ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
;
if
let
TypeInner
:
:
Scalar
{
.
.
}
=
*
func_ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
module
.
types
)
{
write
!
(
self
.
out
"
.
x
"
)
?
;
}
}
Expression
:
:
GlobalVariable
(
handle
)
=
>
match
module
.
global_variables
[
handle
]
.
space
{
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
=
>
{
}
_
=
>
{
let
name
=
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
handle
)
]
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
}
}
Expression
:
:
LocalVariable
(
handle
)
=
>
{
write
!
(
self
.
out
"
{
}
"
self
.
names
[
&
func_ctx
.
name_key
(
handle
)
]
)
?
}
Expression
:
:
Load
{
pointer
}
=
>
{
match
func_ctx
.
info
[
pointer
]
.
ty
.
inner_with
(
&
module
.
types
)
.
pointer_space
(
)
{
Some
(
crate
:
:
AddressSpace
:
:
Storage
{
.
.
}
)
=
>
{
let
var_handle
=
self
.
fill_access_chain
(
module
pointer
func_ctx
)
?
;
let
result_ty
=
func_ctx
.
info
[
expr
]
.
ty
.
clone
(
)
;
self
.
write_storage_load
(
module
var_handle
result_ty
func_ctx
)
?
;
}
_
=
>
{
self
.
write_expr
(
module
pointer
func_ctx
)
?
;
}
}
}
Expression
:
:
Unary
{
op
expr
}
=
>
{
use
crate
:
:
{
ScalarKind
as
Sk
UnaryOperator
as
Uo
}
;
let
op_str
=
match
op
{
Uo
:
:
Negate
=
>
"
-
"
Uo
:
:
Not
=
>
match
func_ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
module
.
types
)
.
scalar_kind
(
)
{
Some
(
Sk
:
:
Sint
)
|
Some
(
Sk
:
:
Uint
)
=
>
"
~
"
Some
(
Sk
:
:
Bool
)
=
>
"
!
"
ref
other
=
>
{
return
Err
(
Error
:
:
Custom
(
format
!
(
"
Cannot
apply
not
to
type
{
:
?
}
"
other
)
)
)
}
}
}
;
write
!
(
self
.
out
"
{
}
"
op_str
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
}
Expression
:
:
As
{
expr
kind
convert
}
=
>
{
let
inner
=
func_ctx
.
info
[
expr
]
.
ty
.
inner_with
(
&
module
.
types
)
;
let
(
size_str
src_width
)
=
match
*
inner
{
TypeInner
:
:
Vector
{
size
width
.
.
}
=
>
(
back
:
:
vector_size_str
(
size
)
width
)
TypeInner
:
:
Scalar
{
width
.
.
}
=
>
(
"
"
width
)
_
=
>
{
return
Err
(
Error
:
:
Unimplemented
(
format
!
(
"
write_expr
expression
:
:
as
{
:
?
}
"
inner
)
)
)
;
}
}
;
let
kind_str
=
kind
.
to_hlsl_str
(
convert
.
unwrap_or
(
src_width
)
)
?
;
write
!
(
self
.
out
"
{
}
{
}
(
"
kind_str
size_str
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
;
}
Expression
:
:
Math
{
fun
arg
arg1
arg2
arg3
}
=
>
{
use
crate
:
:
MathFunction
as
Mf
;
enum
Function
{
Asincosh
{
is_sin
:
bool
}
Atanh
Regular
(
&
'
static
str
)
}
let
fun
=
match
fun
{
Mf
:
:
Abs
=
>
Function
:
:
Regular
(
"
abs
"
)
Mf
:
:
Min
=
>
Function
:
:
Regular
(
"
min
"
)
Mf
:
:
Max
=
>
Function
:
:
Regular
(
"
max
"
)
Mf
:
:
Clamp
=
>
Function
:
:
Regular
(
"
clamp
"
)
Mf
:
:
Cos
=
>
Function
:
:
Regular
(
"
cos
"
)
Mf
:
:
Cosh
=
>
Function
:
:
Regular
(
"
cosh
"
)
Mf
:
:
Sin
=
>
Function
:
:
Regular
(
"
sin
"
)
Mf
:
:
Sinh
=
>
Function
:
:
Regular
(
"
sinh
"
)
Mf
:
:
Tan
=
>
Function
:
:
Regular
(
"
tan
"
)
Mf
:
:
Tanh
=
>
Function
:
:
Regular
(
"
tanh
"
)
Mf
:
:
Acos
=
>
Function
:
:
Regular
(
"
acos
"
)
Mf
:
:
Asin
=
>
Function
:
:
Regular
(
"
asin
"
)
Mf
:
:
Atan
=
>
Function
:
:
Regular
(
"
atan
"
)
Mf
:
:
Atan2
=
>
Function
:
:
Regular
(
"
atan2
"
)
Mf
:
:
Asinh
=
>
Function
:
:
Asincosh
{
is_sin
:
true
}
Mf
:
:
Acosh
=
>
Function
:
:
Asincosh
{
is_sin
:
false
}
Mf
:
:
Atanh
=
>
Function
:
:
Atanh
Mf
:
:
Radians
=
>
Function
:
:
Regular
(
"
radians
"
)
Mf
:
:
Degrees
=
>
Function
:
:
Regular
(
"
degrees
"
)
Mf
:
:
Ceil
=
>
Function
:
:
Regular
(
"
ceil
"
)
Mf
:
:
Floor
=
>
Function
:
:
Regular
(
"
floor
"
)
Mf
:
:
Round
=
>
Function
:
:
Regular
(
"
round
"
)
Mf
:
:
Fract
=
>
Function
:
:
Regular
(
"
frac
"
)
Mf
:
:
Trunc
=
>
Function
:
:
Regular
(
"
trunc
"
)
Mf
:
:
Modf
=
>
Function
:
:
Regular
(
"
modf
"
)
Mf
:
:
Frexp
=
>
Function
:
:
Regular
(
"
frexp
"
)
Mf
:
:
Ldexp
=
>
Function
:
:
Regular
(
"
ldexp
"
)
Mf
:
:
Exp
=
>
Function
:
:
Regular
(
"
exp
"
)
Mf
:
:
Exp2
=
>
Function
:
:
Regular
(
"
exp2
"
)
Mf
:
:
Log
=
>
Function
:
:
Regular
(
"
log
"
)
Mf
:
:
Log2
=
>
Function
:
:
Regular
(
"
log2
"
)
Mf
:
:
Pow
=
>
Function
:
:
Regular
(
"
pow
"
)
Mf
:
:
Dot
=
>
Function
:
:
Regular
(
"
dot
"
)
Mf
:
:
Cross
=
>
Function
:
:
Regular
(
"
cross
"
)
Mf
:
:
Distance
=
>
Function
:
:
Regular
(
"
distance
"
)
Mf
:
:
Length
=
>
Function
:
:
Regular
(
"
length
"
)
Mf
:
:
Normalize
=
>
Function
:
:
Regular
(
"
normalize
"
)
Mf
:
:
FaceForward
=
>
Function
:
:
Regular
(
"
faceforward
"
)
Mf
:
:
Reflect
=
>
Function
:
:
Regular
(
"
reflect
"
)
Mf
:
:
Refract
=
>
Function
:
:
Regular
(
"
refract
"
)
Mf
:
:
Sign
=
>
Function
:
:
Regular
(
"
sign
"
)
Mf
:
:
Fma
=
>
Function
:
:
Regular
(
"
mad
"
)
Mf
:
:
Mix
=
>
Function
:
:
Regular
(
"
lerp
"
)
Mf
:
:
Step
=
>
Function
:
:
Regular
(
"
step
"
)
Mf
:
:
SmoothStep
=
>
Function
:
:
Regular
(
"
smoothstep
"
)
Mf
:
:
Sqrt
=
>
Function
:
:
Regular
(
"
sqrt
"
)
Mf
:
:
InverseSqrt
=
>
Function
:
:
Regular
(
"
rsqrt
"
)
Mf
:
:
Transpose
=
>
Function
:
:
Regular
(
"
transpose
"
)
Mf
:
:
Determinant
=
>
Function
:
:
Regular
(
"
determinant
"
)
Mf
:
:
CountOneBits
=
>
Function
:
:
Regular
(
"
countbits
"
)
Mf
:
:
ReverseBits
=
>
Function
:
:
Regular
(
"
reversebits
"
)
Mf
:
:
FindLsb
=
>
Function
:
:
Regular
(
"
firstbitlow
"
)
Mf
:
:
FindMsb
=
>
Function
:
:
Regular
(
"
firstbithigh
"
)
_
=
>
return
Err
(
Error
:
:
Unimplemented
(
format
!
(
"
write_expr_math
{
:
?
}
"
fun
)
)
)
}
;
match
fun
{
Function
:
:
Asincosh
{
is_sin
}
=
>
{
write
!
(
self
.
out
"
log
(
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
write
!
(
self
.
out
"
+
sqrt
(
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
write
!
(
self
.
out
"
*
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
match
is_sin
{
true
=
>
write
!
(
self
.
out
"
+
1
.
0
)
)
"
)
?
false
=
>
write
!
(
self
.
out
"
-
1
.
0
)
)
"
)
?
}
}
Function
:
:
Atanh
=
>
{
write
!
(
self
.
out
"
0
.
5
*
log
(
(
1
.
0
+
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
write
!
(
self
.
out
"
)
/
(
1
.
0
-
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
write
!
(
self
.
out
"
)
)
"
)
?
;
}
Function
:
:
Regular
(
fun_name
)
=
>
{
write
!
(
self
.
out
"
{
}
(
"
fun_name
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
if
let
Some
(
arg
)
=
arg1
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
}
if
let
Some
(
arg
)
=
arg2
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
}
if
let
Some
(
arg
)
=
arg3
{
write
!
(
self
.
out
"
"
)
?
;
self
.
write_expr
(
module
arg
func_ctx
)
?
;
}
write
!
(
self
.
out
"
)
"
)
?
}
}
}
Expression
:
:
Swizzle
{
size
vector
pattern
}
=
>
{
self
.
write_expr
(
module
vector
func_ctx
)
?
;
write
!
(
self
.
out
"
.
"
)
?
;
for
&
sc
in
pattern
[
.
.
size
as
usize
]
.
iter
(
)
{
self
.
out
.
write_char
(
back
:
:
COMPONENTS
[
sc
as
usize
]
)
?
;
}
}
Expression
:
:
ArrayLength
(
expr
)
=
>
{
let
var_handle
=
match
func_ctx
.
expressions
[
expr
]
{
Expression
:
:
AccessIndex
{
base
index
:
_
}
=
>
{
match
func_ctx
.
expressions
[
base
]
{
Expression
:
:
GlobalVariable
(
handle
)
=
>
handle
_
=
>
unreachable
!
(
)
}
}
Expression
:
:
GlobalVariable
(
handle
)
=
>
handle
_
=
>
unreachable
!
(
)
}
;
let
var
=
&
module
.
global_variables
[
var_handle
]
;
let
(
offset
stride
)
=
match
module
.
types
[
var
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
stride
.
.
}
=
>
(
0
stride
)
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
let
last
=
members
.
last
(
)
.
unwrap
(
)
;
let
stride
=
match
module
.
types
[
last
.
ty
]
.
inner
{
TypeInner
:
:
Array
{
stride
.
.
}
=
>
stride
_
=
>
unreachable
!
(
)
}
;
(
last
.
offset
stride
)
}
_
=
>
unreachable
!
(
)
}
;
let
storage_access
=
match
var
.
space
{
crate
:
:
AddressSpace
:
:
Storage
{
access
}
=
>
access
_
=
>
crate
:
:
StorageAccess
:
:
default
(
)
}
;
let
wrapped_array_length
=
WrappedArrayLength
{
writable
:
storage_access
.
contains
(
crate
:
:
StorageAccess
:
:
STORE
)
}
;
write
!
(
self
.
out
"
(
(
"
)
?
;
self
.
write_wrapped_array_length_function_name
(
wrapped_array_length
)
?
;
let
var_name
=
&
self
.
names
[
&
NameKey
:
:
GlobalVariable
(
var_handle
)
]
;
write
!
(
self
.
out
"
(
{
}
)
-
{
}
)
/
{
}
)
"
var_name
offset
stride
)
?
}
Expression
:
:
Derivative
{
axis
expr
}
=
>
{
use
crate
:
:
DerivativeAxis
as
Da
;
let
fun_str
=
match
axis
{
Da
:
:
X
=
>
"
ddx
"
Da
:
:
Y
=
>
"
ddy
"
Da
:
:
Width
=
>
"
fwidth
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_str
)
?
;
self
.
write_expr
(
module
expr
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Relational
{
fun
argument
}
=
>
{
use
crate
:
:
RelationalFunction
as
Rf
;
let
fun_str
=
match
fun
{
Rf
:
:
All
=
>
"
all
"
Rf
:
:
Any
=
>
"
any
"
Rf
:
:
IsNan
=
>
"
isnan
"
Rf
:
:
IsInf
=
>
"
isinf
"
Rf
:
:
IsFinite
=
>
"
isfinite
"
Rf
:
:
IsNormal
=
>
"
isnormal
"
}
;
write
!
(
self
.
out
"
{
}
(
"
fun_str
)
?
;
self
.
write_expr
(
module
argument
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
Splat
{
size
value
}
=
>
{
let
number_of_components
=
match
size
{
crate
:
:
VectorSize
:
:
Bi
=
>
"
xx
"
crate
:
:
VectorSize
:
:
Tri
=
>
"
xxx
"
crate
:
:
VectorSize
:
:
Quad
=
>
"
xxxx
"
}
;
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
module
value
func_ctx
)
?
;
write
!
(
self
.
out
"
)
.
{
}
"
number_of_components
)
?
}
Expression
:
:
Select
{
condition
accept
reject
}
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_expr
(
module
condition
func_ctx
)
?
;
write
!
(
self
.
out
"
?
"
)
?
;
self
.
write_expr
(
module
accept
func_ctx
)
?
;
write
!
(
self
.
out
"
:
"
)
?
;
self
.
write_expr
(
module
reject
func_ctx
)
?
;
write
!
(
self
.
out
"
)
"
)
?
}
Expression
:
:
CallResult
(
_
)
|
Expression
:
:
AtomicResult
{
.
.
}
=
>
{
}
}
if
!
closing_bracket
.
is_empty
(
)
{
write
!
(
self
.
out
"
{
}
"
closing_bracket
)
?
;
}
Ok
(
(
)
)
}
fn
write_constant
(
&
mut
self
module
:
&
Module
handle
:
Handle
<
crate
:
:
Constant
>
)
-
>
BackendResult
{
let
constant
=
&
module
.
constants
[
handle
]
;
match
constant
.
inner
{
crate
:
:
ConstantInner
:
:
Scalar
{
width
:
_
ref
value
}
=
>
{
if
constant
.
name
.
is_some
(
)
{
write
!
(
self
.
out
"
{
}
"
&
self
.
names
[
&
NameKey
:
:
Constant
(
handle
)
]
)
?
;
}
else
{
self
.
write_scalar_value
(
*
value
)
?
;
}
}
crate
:
:
ConstantInner
:
:
Composite
{
ty
ref
components
}
=
>
{
self
.
write_composite_constant
(
module
ty
components
)
?
;
}
}
Ok
(
(
)
)
}
fn
write_composite_constant
(
&
mut
self
module
:
&
Module
ty
:
Handle
<
crate
:
:
Type
>
components
:
&
[
Handle
<
crate
:
:
Constant
>
]
)
-
>
BackendResult
{
match
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Struct
{
.
.
}
|
TypeInner
:
:
Array
{
.
.
}
=
>
{
self
.
write_wrapped_constructor_function_name
(
module
WrappedConstructor
{
ty
}
)
?
;
}
_
=
>
{
self
.
write_type
(
module
ty
)
?
;
}
}
;
write
!
(
self
.
out
"
(
"
)
?
;
for
(
index
constant
)
in
components
.
iter
(
)
.
enumerate
(
)
{
self
.
write_constant
(
module
*
constant
)
?
;
if
index
!
=
components
.
len
(
)
.
saturating_sub
(
1
)
{
write
!
(
self
.
out
"
"
)
?
;
}
}
write
!
(
self
.
out
"
)
"
)
?
;
Ok
(
(
)
)
}
fn
write_scalar_value
(
&
mut
self
value
:
crate
:
:
ScalarValue
)
-
>
BackendResult
{
use
crate
:
:
ScalarValue
as
Sv
;
match
value
{
Sv
:
:
Sint
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
Sv
:
:
Uint
(
value
)
=
>
write
!
(
self
.
out
"
{
}
u
"
value
)
?
Sv
:
:
Float
(
value
)
=
>
write
!
(
self
.
out
"
{
:
?
}
"
value
)
?
Sv
:
:
Bool
(
value
)
=
>
write
!
(
self
.
out
"
{
}
"
value
)
?
}
Ok
(
(
)
)
}
fn
write_named_expr
(
&
mut
self
module
:
&
Module
handle
:
Handle
<
crate
:
:
Expression
>
name
:
String
ctx
:
&
back
:
:
FunctionCtx
)
-
>
BackendResult
{
match
ctx
.
info
[
handle
]
.
ty
{
proc
:
:
TypeResolution
:
:
Handle
(
ty_handle
)
=
>
match
module
.
types
[
ty_handle
]
.
inner
{
TypeInner
:
:
Struct
{
.
.
}
=
>
{
let
ty_name
=
&
self
.
names
[
&
NameKey
:
:
Type
(
ty_handle
)
]
;
write
!
(
self
.
out
"
{
}
"
ty_name
)
?
;
}
_
=
>
{
self
.
write_type
(
module
ty_handle
)
?
;
}
}
proc
:
:
TypeResolution
:
:
Value
(
ref
inner
)
=
>
{
self
.
write_value_type
(
module
inner
)
?
;
}
}
let
base_ty_res
=
&
ctx
.
info
[
handle
]
.
ty
;
let
resolved
=
base_ty_res
.
inner_with
(
&
module
.
types
)
;
write
!
(
self
.
out
"
{
}
"
name
)
?
;
if
let
TypeInner
:
:
Array
{
base
size
.
.
}
=
*
resolved
{
self
.
write_array_size
(
module
base
size
)
?
;
}
write
!
(
self
.
out
"
=
"
)
?
;
self
.
write_expr
(
module
handle
ctx
)
?
;
writeln
!
(
self
.
out
"
;
"
)
?
;
self
.
named_expressions
.
insert
(
handle
name
)
;
Ok
(
(
)
)
}
fn
write_default_init
(
&
mut
self
module
:
&
Module
ty
:
Handle
<
crate
:
:
Type
>
)
-
>
BackendResult
{
match
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Array
{
size
:
crate
:
:
ArraySize
:
:
Constant
(
const_handle
)
base
.
.
}
=
>
{
write
!
(
self
.
out
"
{
{
"
)
?
;
let
count
=
module
.
constants
[
const_handle
]
.
to_array_length
(
)
.
unwrap
(
)
;
for
i
in
0
.
.
count
{
if
i
!
=
0
{
write
!
(
self
.
out
"
"
)
?
;
}
self
.
write_default_init
(
module
base
)
?
;
}
write
!
(
self
.
out
"
}
}
"
)
?
;
}
_
=
>
{
write
!
(
self
.
out
"
(
"
)
?
;
self
.
write_type
(
module
ty
)
?
;
write
!
(
self
.
out
"
)
0
"
)
?
;
}
}
Ok
(
(
)
)
}
}
