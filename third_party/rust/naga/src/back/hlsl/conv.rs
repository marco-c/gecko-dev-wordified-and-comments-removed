use
super
:
:
Error
;
impl
crate
:
:
ScalarKind
{
pub
(
super
)
fn
to_hlsl_cast
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Float
=
>
"
asfloat
"
Self
:
:
Sint
=
>
"
asint
"
Self
:
:
Uint
=
>
"
asuint
"
Self
:
:
Bool
=
>
unreachable
!
(
)
}
}
pub
(
super
)
fn
to_hlsl_str
(
self
width
:
crate
:
:
Bytes
)
-
>
Result
<
&
'
static
str
Error
>
{
match
self
{
Self
:
:
Sint
=
>
Ok
(
"
int
"
)
Self
:
:
Uint
=
>
Ok
(
"
uint
"
)
Self
:
:
Float
=
>
match
width
{
2
=
>
Ok
(
"
half
"
)
4
=
>
Ok
(
"
float
"
)
8
=
>
Ok
(
"
double
"
)
_
=
>
Err
(
Error
:
:
UnsupportedScalar
(
self
width
)
)
}
Self
:
:
Bool
=
>
Ok
(
"
bool
"
)
}
}
}
impl
crate
:
:
TypeInner
{
pub
(
super
)
fn
is_matrix
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Matrix
{
.
.
}
=
>
true
_
=
>
false
}
}
}
impl
crate
:
:
StorageFormat
{
pub
(
super
)
fn
to_hlsl_str
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
R16Float
=
>
"
float
"
Self
:
:
R8Unorm
=
>
"
unorm
float
"
Self
:
:
R8Snorm
=
>
"
snorm
float
"
Self
:
:
R8Uint
|
Self
:
:
R16Uint
=
>
"
uint
"
Self
:
:
R8Sint
|
Self
:
:
R16Sint
=
>
"
int
"
Self
:
:
Rg16Float
=
>
"
float2
"
Self
:
:
Rg8Unorm
=
>
"
unorm
float2
"
Self
:
:
Rg8Snorm
=
>
"
snorm
float2
"
Self
:
:
Rg8Sint
|
Self
:
:
Rg16Sint
=
>
"
int2
"
Self
:
:
Rg8Uint
|
Self
:
:
Rg16Uint
=
>
"
uint2
"
Self
:
:
Rg11b10Float
=
>
"
float3
"
Self
:
:
Rgba16Float
|
Self
:
:
R32Float
|
Self
:
:
Rg32Float
|
Self
:
:
Rgba32Float
=
>
"
float4
"
Self
:
:
Rgba8Unorm
|
Self
:
:
Rgb10a2Unorm
=
>
"
unorm
float4
"
Self
:
:
Rgba8Snorm
=
>
"
snorm
float4
"
Self
:
:
Rgba8Uint
|
Self
:
:
Rgba16Uint
|
Self
:
:
R32Uint
|
Self
:
:
Rg32Uint
|
Self
:
:
Rgba32Uint
=
>
"
uint4
"
Self
:
:
Rgba8Sint
|
Self
:
:
Rgba16Sint
|
Self
:
:
R32Sint
|
Self
:
:
Rg32Sint
|
Self
:
:
Rgba32Sint
=
>
"
int4
"
}
}
}
impl
crate
:
:
BuiltIn
{
pub
(
super
)
fn
to_hlsl_str
(
self
)
-
>
Result
<
&
'
static
str
Error
>
{
Ok
(
match
self
{
Self
:
:
Position
=
>
"
SV_Position
"
Self
:
:
ClipDistance
=
>
"
SV_ClipDistance
"
Self
:
:
CullDistance
=
>
"
SV_CullDistance
"
Self
:
:
InstanceIndex
=
>
"
SV_InstanceID
"
Self
:
:
PointSize
=
>
"
PSIZE
"
Self
:
:
VertexIndex
=
>
"
SV_VertexID
"
Self
:
:
FragDepth
=
>
"
SV_Depth
"
Self
:
:
FrontFacing
=
>
"
SV_IsFrontFace
"
Self
:
:
PrimitiveIndex
=
>
"
SV_PrimitiveID
"
Self
:
:
SampleIndex
=
>
"
SV_SampleIndex
"
Self
:
:
SampleMask
=
>
"
SV_Coverage
"
Self
:
:
GlobalInvocationId
=
>
"
SV_DispatchThreadID
"
Self
:
:
LocalInvocationId
=
>
"
SV_GroupThreadID
"
Self
:
:
LocalInvocationIndex
=
>
"
SV_GroupIndex
"
Self
:
:
WorkGroupId
=
>
"
SV_GroupID
"
Self
:
:
NumWorkGroups
=
>
"
SV_GroupID
"
Self
:
:
BaseInstance
|
Self
:
:
BaseVertex
|
Self
:
:
WorkGroupSize
=
>
{
return
Err
(
Error
:
:
Unimplemented
(
format
!
(
"
builtin
{
:
?
}
"
self
)
)
)
}
}
)
}
}
impl
crate
:
:
Interpolation
{
pub
(
super
)
fn
to_hlsl_str
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Perspective
=
>
"
linear
"
Self
:
:
Linear
=
>
"
noperspective
"
Self
:
:
Flat
=
>
"
nointerpolation
"
}
}
}
impl
crate
:
:
Sampling
{
pub
(
super
)
fn
to_hlsl_str
(
self
)
-
>
Option
<
&
'
static
str
>
{
match
self
{
Self
:
:
Center
=
>
None
Self
:
:
Centroid
=
>
Some
(
"
centroid
"
)
Self
:
:
Sample
=
>
Some
(
"
sample
"
)
}
}
}
impl
crate
:
:
AtomicFunction
{
pub
(
super
)
fn
to_hlsl_suffix
(
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Add
|
Self
:
:
Subtract
=
>
"
Add
"
Self
:
:
And
=
>
"
And
"
Self
:
:
InclusiveOr
=
>
"
Or
"
Self
:
:
ExclusiveOr
=
>
"
Xor
"
Self
:
:
Min
=
>
"
Min
"
Self
:
:
Max
=
>
"
Max
"
Self
:
:
Exchange
{
compare
:
None
}
=
>
"
Exchange
"
Self
:
:
Exchange
{
.
.
}
=
>
"
"
}
}
}
