#
!
[
cfg_attr
(
not
(
any
(
dot_out
glsl_out
hlsl_out
msl_out
spv_out
wgsl_out
)
)
allow
(
dead_code
reason
=
"
shared
helpers
can
be
dead
if
none
of
the
enabled
backends
need
it
"
)
)
]
use
alloc
:
:
string
:
:
String
;
#
[
cfg
(
dot_out
)
]
pub
mod
dot
;
#
[
cfg
(
glsl_out
)
]
pub
mod
glsl
;
#
[
cfg
(
hlsl_out
)
]
pub
mod
hlsl
;
#
[
cfg
(
msl_out
)
]
pub
mod
msl
;
#
[
cfg
(
spv_out
)
]
pub
mod
spv
;
#
[
cfg
(
wgsl_out
)
]
pub
mod
wgsl
;
#
[
cfg
(
any
(
hlsl_out
msl_out
spv_out
glsl_out
)
)
]
pub
mod
pipeline_constants
;
#
[
cfg
(
any
(
hlsl_out
glsl_out
)
)
]
mod
continue_forward
;
pub
const
COMPONENTS
:
&
[
char
]
=
&
[
'
x
'
'
y
'
'
z
'
'
w
'
]
;
pub
const
INDENT
:
&
str
=
"
"
;
pub
type
NeedBakeExpressions
=
crate
:
:
FastHashSet
<
crate
:
:
Handle
<
crate
:
:
Expression
>
>
;
#
[
cfg_attr
(
not
(
any
(
glsl_out
hlsl_out
msl_out
wgsl_out
)
)
allow
(
dead_code
reason
=
"
shared
helpers
can
be
dead
if
none
of
the
enabled
backends
need
it
"
)
)
]
struct
Baked
(
crate
:
:
Handle
<
crate
:
:
Expression
>
)
;
impl
core
:
:
fmt
:
:
Display
for
Baked
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
self
.
0
.
write_prefixed
(
f
"
_e
"
)
}
}
pub
type
PipelineConstants
=
hashbrown
:
:
HashMap
<
String
f64
>
;
#
[
derive
(
Clone
Copy
)
]
pub
struct
Level
(
pub
usize
)
;
impl
Level
{
pub
const
fn
next
(
&
self
)
-
>
Self
{
Level
(
self
.
0
+
1
)
}
}
impl
core
:
:
fmt
:
:
Display
for
Level
{
fn
fmt
(
&
self
formatter
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
core
:
:
fmt
:
:
Error
>
{
(
0
.
.
self
.
0
)
.
try_for_each
(
|
_
|
formatter
.
write_str
(
INDENT
)
)
}
}
#
[
cfg
(
any
(
hlsl_out
msl_out
)
)
]
fn
get_entry_points
(
module
:
&
crate
:
:
ir
:
:
Module
entry_point
:
Option
<
&
(
crate
:
:
ir
:
:
ShaderStage
String
)
>
)
-
>
Result
<
core
:
:
ops
:
:
Range
<
usize
>
(
crate
:
:
ir
:
:
ShaderStage
String
)
>
{
use
alloc
:
:
borrow
:
:
ToOwned
;
if
let
Some
(
&
(
stage
ref
name
)
)
=
entry_point
{
let
Some
(
ep_index
)
=
module
.
entry_points
.
iter
(
)
.
position
(
|
ep
|
ep
.
stage
=
=
stage
&
&
ep
.
name
=
=
*
name
)
else
{
return
Err
(
(
stage
name
.
to_owned
(
)
)
)
;
}
;
Ok
(
ep_index
.
.
ep_index
+
1
)
}
else
{
Ok
(
0
.
.
module
.
entry_points
.
len
(
)
)
}
}
pub
enum
FunctionType
{
Function
(
crate
:
:
Handle
<
crate
:
:
Function
>
)
EntryPoint
(
crate
:
:
proc
:
:
EntryPointIndex
)
}
impl
FunctionType
{
pub
fn
is_compute_like_entry_point
(
&
self
module
:
&
crate
:
:
Module
)
-
>
bool
{
match
*
self
{
FunctionType
:
:
EntryPoint
(
index
)
=
>
{
module
.
entry_points
[
index
as
usize
]
.
stage
.
compute_like
(
)
}
FunctionType
:
:
Function
(
_
)
=
>
false
}
}
}
pub
struct
FunctionCtx
<
'
a
>
{
pub
ty
:
FunctionType
pub
info
:
&
'
a
crate
:
:
valid
:
:
FunctionInfo
pub
expressions
:
&
'
a
crate
:
:
Arena
<
crate
:
:
Expression
>
pub
named_expressions
:
&
'
a
crate
:
:
NamedExpressions
}
impl
FunctionCtx
<
'
_
>
{
pub
fn
resolve_type
<
'
a
>
(
&
'
a
self
handle
:
crate
:
:
Handle
<
crate
:
:
Expression
>
types
:
&
'
a
crate
:
:
UniqueArena
<
crate
:
:
Type
>
)
-
>
&
'
a
crate
:
:
TypeInner
{
self
.
info
[
handle
]
.
ty
.
inner_with
(
types
)
}
pub
const
fn
name_key
(
&
self
local
:
crate
:
:
Handle
<
crate
:
:
LocalVariable
>
)
-
>
crate
:
:
proc
:
:
NameKey
{
match
self
.
ty
{
FunctionType
:
:
Function
(
handle
)
=
>
crate
:
:
proc
:
:
NameKey
:
:
FunctionLocal
(
handle
local
)
FunctionType
:
:
EntryPoint
(
idx
)
=
>
crate
:
:
proc
:
:
NameKey
:
:
EntryPointLocal
(
idx
local
)
}
}
pub
const
fn
argument_key
(
&
self
arg
:
u32
)
-
>
crate
:
:
proc
:
:
NameKey
{
match
self
.
ty
{
FunctionType
:
:
Function
(
handle
)
=
>
crate
:
:
proc
:
:
NameKey
:
:
FunctionArgument
(
handle
arg
)
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
{
crate
:
:
proc
:
:
NameKey
:
:
EntryPointArgument
(
ep_index
arg
)
}
}
}
pub
const
fn
external_texture_argument_key
(
&
self
arg
:
u32
external_texture_key
:
crate
:
:
proc
:
:
ExternalTextureNameKey
)
-
>
crate
:
:
proc
:
:
NameKey
{
match
self
.
ty
{
FunctionType
:
:
Function
(
handle
)
=
>
{
crate
:
:
proc
:
:
NameKey
:
:
ExternalTextureFunctionArgument
(
handle
arg
external_texture_key
)
}
#
[
expect
(
clippy
:
:
allow_attributes
)
]
#
[
allow
(
clippy
:
:
panic
)
]
FunctionType
:
:
EntryPoint
(
_
)
=
>
{
panic
!
(
"
External
textures
cannot
be
used
as
arguments
to
entry
points
"
)
}
}
}
pub
fn
is_fixed_function_input
(
&
self
mut
expression
:
crate
:
:
Handle
<
crate
:
:
Expression
>
module
:
&
crate
:
:
Module
)
-
>
Option
<
crate
:
:
BuiltIn
>
{
let
ep_function
=
match
self
.
ty
{
FunctionType
:
:
Function
(
_
)
=
>
return
None
FunctionType
:
:
EntryPoint
(
ep_index
)
=
>
&
module
.
entry_points
[
ep_index
as
usize
]
.
function
}
;
let
mut
built_in
=
None
;
loop
{
match
self
.
expressions
[
expression
]
{
crate
:
:
Expression
:
:
FunctionArgument
(
arg_index
)
=
>
{
return
match
ep_function
.
arguments
[
arg_index
as
usize
]
.
binding
{
Some
(
crate
:
:
Binding
:
:
BuiltIn
(
bi
)
)
=
>
Some
(
bi
)
_
=
>
built_in
}
;
}
crate
:
:
Expression
:
:
AccessIndex
{
base
index
}
=
>
{
match
*
self
.
resolve_type
(
base
&
module
.
types
)
{
crate
:
:
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
if
let
Some
(
crate
:
:
Binding
:
:
BuiltIn
(
bi
)
)
=
members
[
index
as
usize
]
.
binding
{
built_in
=
Some
(
bi
)
;
}
}
_
=
>
return
None
}
expression
=
base
;
}
_
=
>
return
None
}
}
}
}
impl
crate
:
:
Expression
{
pub
const
fn
bake_ref_count
(
&
self
)
-
>
usize
{
match
*
self
{
crate
:
:
Expression
:
:
Access
{
.
.
}
|
crate
:
:
Expression
:
:
AccessIndex
{
.
.
}
=
>
usize
:
:
MAX
crate
:
:
Expression
:
:
ImageSample
{
.
.
}
|
crate
:
:
Expression
:
:
ImageLoad
{
.
.
}
=
>
1
crate
:
:
Expression
:
:
Derivative
{
.
.
}
=
>
1
crate
:
:
Expression
:
:
Load
{
.
.
}
=
>
1
_
=
>
2
}
}
}
pub
const
fn
binary_operation_str
(
op
:
crate
:
:
BinaryOperator
)
-
>
&
'
static
str
{
use
crate
:
:
BinaryOperator
as
Bo
;
match
op
{
Bo
:
:
Add
=
>
"
+
"
Bo
:
:
Subtract
=
>
"
-
"
Bo
:
:
Multiply
=
>
"
*
"
Bo
:
:
Divide
=
>
"
/
"
Bo
:
:
Modulo
=
>
"
%
"
Bo
:
:
Equal
=
>
"
=
=
"
Bo
:
:
NotEqual
=
>
"
!
=
"
Bo
:
:
Less
=
>
"
<
"
Bo
:
:
LessEqual
=
>
"
<
=
"
Bo
:
:
Greater
=
>
"
>
"
Bo
:
:
GreaterEqual
=
>
"
>
=
"
Bo
:
:
And
=
>
"
&
"
Bo
:
:
ExclusiveOr
=
>
"
^
"
Bo
:
:
InclusiveOr
=
>
"
|
"
Bo
:
:
LogicalAnd
=
>
"
&
&
"
Bo
:
:
LogicalOr
=
>
"
|
|
"
Bo
:
:
ShiftLeft
=
>
"
<
<
"
Bo
:
:
ShiftRight
=
>
"
>
>
"
}
}
impl
crate
:
:
TypeInner
{
pub
const
fn
is_handle
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
Image
{
.
.
}
|
Self
:
:
Sampler
{
.
.
}
|
Self
:
:
AccelerationStructure
{
.
.
}
=
>
true
_
=
>
false
}
}
}
impl
crate
:
:
Statement
{
pub
const
fn
is_terminator
(
&
self
)
-
>
bool
{
match
*
self
{
crate
:
:
Statement
:
:
Break
|
crate
:
:
Statement
:
:
Continue
|
crate
:
:
Statement
:
:
Return
{
.
.
}
|
crate
:
:
Statement
:
:
Kill
=
>
true
_
=
>
false
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Ray
flags
for
a
[
RayDesc
]
'
s
flags
field
.
/
/
/
/
/
/
Note
that
these
exactly
correspond
to
the
SPIR
-
V
"
Ray
Flags
"
mask
and
/
/
/
the
SPIR
-
V
backend
passes
them
directly
through
to
the
/
/
/
[
OpRayQueryInitializeKHR
]
[
op
]
instruction
.
(
We
have
to
choose
something
so
/
/
/
we
might
as
well
make
one
back
end
'
s
life
easier
.
)
/
/
/
/
/
/
[
RayDesc
]
:
crate
:
:
Module
:
:
generate_ray_desc_type
/
/
/
[
op
]
:
https
:
/
/
registry
.
khronos
.
org
/
SPIR
-
V
/
specs
/
unified1
/
SPIRV
.
html
#
OpRayQueryInitializeKHR
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
)
]
pub
struct
RayFlag
:
u32
{
const
OPAQUE
=
0x01
;
const
NO_OPAQUE
=
0x02
;
const
TERMINATE_ON_FIRST_HIT
=
0x04
;
const
SKIP_CLOSEST_HIT_SHADER
=
0x08
;
const
CULL_BACK_FACING
=
0x10
;
const
CULL_FRONT_FACING
=
0x20
;
const
CULL_OPAQUE
=
0x40
;
const
CULL_NO_OPAQUE
=
0x80
;
const
SKIP_TRIANGLES
=
0x100
;
const
SKIP_AABBS
=
0x200
;
}
}
#
[
repr
(
u32
)
]
pub
enum
RayIntersectionType
{
Triangle
=
1
BoundingBox
=
4
}
