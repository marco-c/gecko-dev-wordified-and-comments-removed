use
std
:
:
sync
:
:
{
atomic
:
:
AtomicUsize
Arc
}
;
use
crate
:
:
{
GlobalVariable
Handle
Module
Type
TypeInner
}
;
#
[
derive
(
Clone
Debug
thiserror
:
:
Error
)
]
pub
enum
Error
{
#
[
error
(
"
encountered
an
unsupported
expression
"
)
]
Unsupported
#
[
error
(
"
upgrading
structs
of
more
than
one
member
is
not
yet
implemented
"
)
]
MultiMemberStruct
#
[
error
(
"
encountered
unsupported
global
initializer
in
an
atomic
variable
"
)
]
GlobalInitUnsupported
#
[
error
(
"
expected
to
find
a
global
variable
"
)
]
GlobalVariableMissing
}
#
[
derive
(
Clone
Default
)
]
struct
Padding
(
Arc
<
AtomicUsize
>
)
;
impl
std
:
:
fmt
:
:
Display
for
Padding
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
for
_
in
0
.
.
self
.
0
.
load
(
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
)
{
f
.
write_str
(
"
"
)
?
;
}
Ok
(
(
)
)
}
}
impl
Drop
for
Padding
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
0
.
fetch_sub
(
1
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
)
;
}
}
impl
Padding
{
fn
trace
(
&
self
msg
:
impl
std
:
:
fmt
:
:
Display
t
:
impl
std
:
:
fmt
:
:
Debug
)
{
format
!
(
"
{
msg
}
{
t
:
#
?
}
"
)
.
split
(
'
\
n
'
)
.
for_each
(
|
ln
|
log
:
:
trace
!
(
"
{
self
}
{
ln
}
"
)
)
;
}
fn
debug
(
&
self
msg
:
impl
std
:
:
fmt
:
:
Display
t
:
impl
std
:
:
fmt
:
:
Debug
)
{
format
!
(
"
{
msg
}
{
t
:
#
?
}
"
)
.
split
(
'
\
n
'
)
.
for_each
(
|
ln
|
log
:
:
debug
!
(
"
{
self
}
{
ln
}
"
)
)
;
}
fn
inc_padding
(
&
self
)
-
>
Padding
{
let
_
=
self
.
0
.
fetch_add
(
1
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
)
;
self
.
clone
(
)
}
}
struct
UpgradeState
<
'
a
>
{
padding
:
Padding
module
:
&
'
a
mut
Module
}
impl
<
'
a
>
UpgradeState
<
'
a
>
{
fn
inc_padding
(
&
self
)
-
>
Padding
{
self
.
padding
.
inc_padding
(
)
}
fn
upgrade_type
(
&
mut
self
ty
:
Handle
<
Type
>
)
-
>
Result
<
Handle
<
Type
>
Error
>
{
let
padding
=
self
.
inc_padding
(
)
;
padding
.
trace
(
"
upgrading
type
:
"
ty
)
;
let
inner
=
match
self
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Scalar
(
scalar
)
=
>
{
log
:
:
trace
!
(
"
{
padding
}
hit
the
scalar
leaf
replacing
with
an
atomic
"
)
;
TypeInner
:
:
Atomic
(
scalar
)
}
TypeInner
:
:
Pointer
{
base
space
}
=
>
TypeInner
:
:
Pointer
{
base
:
self
.
upgrade_type
(
base
)
?
space
}
TypeInner
:
:
Array
{
base
size
stride
}
=
>
TypeInner
:
:
Array
{
base
:
self
.
upgrade_type
(
base
)
?
size
stride
}
TypeInner
:
:
Struct
{
ref
members
span
}
=
>
{
let
&
[
crate
:
:
StructMember
{
ref
name
ty
ref
binding
offset
}
]
=
&
members
[
.
.
]
else
{
return
Err
(
Error
:
:
MultiMemberStruct
)
;
}
;
let
name
=
name
.
clone
(
)
;
let
binding
=
binding
.
clone
(
)
;
let
upgraded_member_type
=
self
.
upgrade_type
(
ty
)
?
;
TypeInner
:
:
Struct
{
members
:
vec
!
[
crate
:
:
StructMember
{
name
ty
:
upgraded_member_type
binding
offset
}
]
span
}
}
TypeInner
:
:
BindingArray
{
base
size
}
=
>
TypeInner
:
:
BindingArray
{
base
:
self
.
upgrade_type
(
base
)
?
size
}
_
=
>
return
Ok
(
ty
)
}
;
let
r
#
type
=
&
self
.
module
.
types
[
ty
]
;
let
span
=
self
.
module
.
types
.
get_span
(
ty
)
;
let
new_type
=
Type
{
name
:
r
#
type
.
name
.
clone
(
)
inner
}
;
padding
.
debug
(
"
ty
:
"
ty
)
;
padding
.
debug
(
"
from
:
"
r
#
type
)
;
padding
.
debug
(
"
to
:
"
&
new_type
)
;
let
new_handle
=
self
.
module
.
types
.
insert
(
new_type
span
)
;
Ok
(
new_handle
)
}
fn
upgrade_global_variable
(
&
mut
self
handle
:
Handle
<
GlobalVariable
>
)
-
>
Result
<
(
)
Error
>
{
let
padding
=
self
.
inc_padding
(
)
;
padding
.
trace
(
"
upgrading
global
variable
:
"
handle
)
;
let
var
=
&
self
.
module
.
global_variables
[
handle
]
;
if
var
.
init
.
is_some
(
)
{
return
Err
(
Error
:
:
GlobalInitUnsupported
)
;
}
let
var_ty
=
var
.
ty
;
let
new_ty
=
self
.
upgrade_type
(
var
.
ty
)
?
;
if
new_ty
!
=
var_ty
{
padding
.
debug
(
"
upgrading
global
variable
:
"
handle
)
;
padding
.
debug
(
"
from
ty
:
"
var_ty
)
;
padding
.
debug
(
"
to
ty
:
"
new_ty
)
;
self
.
module
.
global_variables
[
handle
]
.
ty
=
new_ty
;
}
Ok
(
(
)
)
}
}
impl
Module
{
pub
(
crate
)
fn
upgrade_atomics
(
&
mut
self
global_var_handles
:
impl
IntoIterator
<
Item
=
Handle
<
GlobalVariable
>
>
)
-
>
Result
<
(
)
Error
>
{
let
mut
state
=
UpgradeState
{
padding
:
Default
:
:
default
(
)
module
:
self
}
;
for
handle
in
global_var_handles
{
state
.
upgrade_global_variable
(
handle
)
?
;
}
Ok
(
(
)
)
}
}
