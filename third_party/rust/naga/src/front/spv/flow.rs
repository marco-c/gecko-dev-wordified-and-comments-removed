#
!
[
allow
(
dead_code
)
]
use
super
:
:
error
:
:
Error
;
use
super
:
:
{
function
:
:
{
BlockId
MergeInstruction
Terminator
}
LookupExpression
PhiInstruction
}
;
use
crate
:
:
FastHashMap
;
use
petgraph
:
:
{
algo
:
:
has_path_connecting
graph
:
:
{
node_index
NodeIndex
}
visit
:
:
EdgeRef
Directed
Direction
}
;
use
std
:
:
fmt
:
:
Write
;
type
BlockNodeIndex
=
NodeIndex
<
u32
>
;
type
ControlFlowGraph
=
petgraph
:
:
Graph
<
ControlFlowNode
ControlFlowEdgeType
Directed
u32
>
;
pub
(
super
)
struct
FlowGraph
{
flow
:
ControlFlowGraph
block_to_node
:
FastHashMap
<
BlockId
BlockNodeIndex
>
}
impl
FlowGraph
{
pub
(
super
)
fn
new
(
)
-
>
Self
{
Self
{
flow
:
ControlFlowGraph
:
:
default
(
)
block_to_node
:
FastHashMap
:
:
default
(
)
}
}
pub
(
super
)
fn
add_node
(
&
mut
self
node
:
ControlFlowNode
)
{
let
block_id
=
node
.
id
;
let
node_index
=
self
.
flow
.
add_node
(
node
)
;
self
.
block_to_node
.
insert
(
block_id
node_index
)
;
}
pub
(
super
)
fn
classify
(
&
mut
self
)
{
let
block_to_node
=
&
mut
self
.
block_to_node
;
for
source_node_index
in
self
.
flow
.
node_indices
(
)
{
if
let
Some
(
merge
)
=
self
.
flow
[
source_node_index
]
.
merge
{
let
merge_block_index
=
block_to_node
[
&
merge
.
merge_block_id
]
;
self
.
flow
[
source_node_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Header
)
;
self
.
flow
[
merge_block_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Merge
)
;
self
.
flow
.
add_edge
(
source_node_index
merge_block_index
ControlFlowEdgeType
:
:
ForwardMerge
)
;
if
let
Some
(
continue_block_id
)
=
merge
.
continue_block_id
{
let
continue_block_index
=
block_to_node
[
&
continue_block_id
]
;
self
.
flow
[
source_node_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Loop
)
;
self
.
flow
.
add_edge
(
source_node_index
continue_block_index
ControlFlowEdgeType
:
:
ForwardContinue
)
;
}
}
let
terminator
=
self
.
flow
[
source_node_index
]
.
terminator
.
clone
(
)
;
match
terminator
{
Terminator
:
:
Branch
{
target_id
}
=
>
{
let
target_node_index
=
block_to_node
[
&
target_id
]
;
self
.
flow
.
add_edge
(
source_node_index
target_node_index
ControlFlowEdgeType
:
:
Forward
)
;
}
Terminator
:
:
BranchConditional
{
true_id
false_id
.
.
}
=
>
{
let
true_node_index
=
block_to_node
[
&
true_id
]
;
let
false_node_index
=
block_to_node
[
&
false_id
]
;
self
.
flow
.
add_edge
(
source_node_index
true_node_index
ControlFlowEdgeType
:
:
IfTrue
)
;
self
.
flow
.
add_edge
(
source_node_index
false_node_index
ControlFlowEdgeType
:
:
IfFalse
)
;
}
Terminator
:
:
Switch
{
selector
:
_
default
ref
targets
}
=
>
{
let
default_node_index
=
block_to_node
[
&
default
]
;
self
.
flow
.
add_edge
(
source_node_index
default_node_index
ControlFlowEdgeType
:
:
Forward
)
;
for
(
_
target_block_id
)
in
targets
.
iter
(
)
{
let
target_node_index
=
block_to_node
[
&
target_block_id
]
;
self
.
flow
.
add_edge
(
source_node_index
target_node_index
ControlFlowEdgeType
:
:
Forward
)
;
}
}
Terminator
:
:
Return
{
.
.
}
=
>
{
self
.
flow
[
source_node_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Return
)
}
Terminator
:
:
Kill
=
>
{
self
.
flow
[
source_node_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Kill
)
}
_
=
>
{
}
}
;
}
for
edge_index
in
self
.
flow
.
edge_indices
(
)
{
let
(
node_source_index
node_target_index
)
=
self
.
flow
.
edge_endpoints
(
edge_index
)
.
unwrap
(
)
;
if
self
.
flow
[
node_target_index
]
.
ty
=
=
Some
(
ControlFlowNodeType
:
:
Loop
)
&
&
self
.
flow
[
node_source_index
]
.
id
>
self
.
flow
[
node_target_index
]
.
id
{
self
.
flow
[
node_source_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Back
)
;
self
.
flow
[
edge_index
]
=
ControlFlowEdgeType
:
:
Back
;
}
let
mut
target_incoming_edges
=
self
.
flow
.
neighbors_directed
(
node_target_index
Direction
:
:
Incoming
)
.
detach
(
)
;
while
let
Some
(
(
incoming_edge
incoming_source
)
)
=
target_incoming_edges
.
next
(
&
self
.
flow
)
{
if
self
.
flow
[
incoming_edge
]
=
=
ControlFlowEdgeType
:
:
ForwardContinue
{
self
.
flow
[
node_source_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Continue
)
;
self
.
flow
[
edge_index
]
=
ControlFlowEdgeType
:
:
LoopContinue
;
}
if
self
.
flow
[
incoming_source
]
.
ty
=
=
Some
(
ControlFlowNodeType
:
:
Loop
)
&
&
self
.
flow
[
incoming_edge
]
=
=
ControlFlowEdgeType
:
:
ForwardMerge
{
self
.
flow
[
node_source_index
]
.
ty
=
Some
(
ControlFlowNodeType
:
:
Break
)
;
self
.
flow
[
edge_index
]
=
ControlFlowEdgeType
:
:
LoopBreak
;
}
}
}
}
pub
(
super
)
fn
remove_phi_instructions
(
&
mut
self
lookup_expression
:
&
FastHashMap
<
spirv
:
:
Word
LookupExpression
>
)
{
for
node_index
in
self
.
flow
.
node_indices
(
)
{
let
phis
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
flow
[
node_index
]
.
phis
Vec
:
:
new
(
)
)
;
for
phi
in
phis
.
iter
(
)
{
let
phi_var
=
&
lookup_expression
[
&
phi
.
id
]
;
for
(
variable_id
parent_id
)
in
phi
.
variables
.
iter
(
)
{
let
variable
=
&
lookup_expression
[
&
variable_id
]
;
let
parent_node
=
&
mut
self
.
flow
[
self
.
block_to_node
[
&
parent_id
]
]
;
parent_node
.
block
.
push
(
crate
:
:
Statement
:
:
Store
{
pointer
:
phi_var
.
handle
value
:
variable
.
handle
}
)
;
}
}
self
.
flow
[
node_index
]
.
phis
=
phis
;
}
}
pub
(
super
)
fn
to_naga
(
&
self
)
-
>
Result
<
crate
:
:
Block
Error
>
{
self
.
naga_traverse
(
node_index
(
0
)
None
)
}
fn
naga_traverse
(
&
self
node_index
:
BlockNodeIndex
stop_node_index
:
Option
<
BlockNodeIndex
>
)
-
>
Result
<
crate
:
:
Block
Error
>
{
if
let
Some
(
stop_node_index
)
=
stop_node_index
{
if
stop_node_index
=
=
node_index
{
return
Ok
(
vec
!
[
]
)
;
}
}
let
node
=
&
self
.
flow
[
node_index
]
;
match
node
.
ty
{
Some
(
ControlFlowNodeType
:
:
Header
)
=
>
match
node
.
terminator
{
Terminator
:
:
BranchConditional
{
condition
true_id
false_id
}
=
>
{
let
true_node_index
=
self
.
block_to_node
[
&
true_id
]
;
let
false_node_index
=
self
.
block_to_node
[
&
false_id
]
;
let
merge_node_index
=
self
.
block_to_node
[
&
node
.
merge
.
unwrap
(
)
.
merge_block_id
]
;
let
mut
result
=
node
.
block
.
clone
(
)
;
if
false_node_index
!
=
merge_node_index
{
result
.
push
(
crate
:
:
Statement
:
:
If
{
condition
accept
:
self
.
naga_traverse
(
true_node_index
Some
(
merge_node_index
)
)
?
reject
:
self
.
naga_traverse
(
false_node_index
Some
(
merge_node_index
)
)
?
}
)
;
result
.
extend
(
self
.
naga_traverse
(
merge_node_index
None
)
?
)
;
}
else
{
result
.
push
(
crate
:
:
Statement
:
:
If
{
condition
accept
:
self
.
naga_traverse
(
self
.
block_to_node
[
&
true_id
]
Some
(
merge_node_index
)
)
?
reject
:
self
.
naga_traverse
(
merge_node_index
None
)
?
}
)
;
}
Ok
(
result
)
}
Terminator
:
:
Switch
{
selector
default
ref
targets
}
=
>
{
let
merge_node_index
=
self
.
block_to_node
[
&
node
.
merge
.
unwrap
(
)
.
merge_block_id
]
;
let
mut
result
=
node
.
block
.
clone
(
)
;
let
mut
cases
=
FastHashMap
:
:
default
(
)
;
for
i
in
0
.
.
targets
.
len
(
)
{
let
left_target_node_index
=
self
.
block_to_node
[
&
targets
[
i
]
.
1
]
;
let
fallthrough
:
Option
<
crate
:
:
FallThrough
>
=
if
i
<
targets
.
len
(
)
-
1
{
let
right_target_node_index
=
self
.
block_to_node
[
&
targets
[
i
+
1
]
.
1
]
;
if
has_path_connecting
(
&
self
.
flow
left_target_node_index
right_target_node_index
None
)
{
Some
(
crate
:
:
FallThrough
{
}
)
}
else
{
None
}
}
else
{
None
}
;
cases
.
insert
(
targets
[
i
]
.
0
(
self
.
naga_traverse
(
left_target_node_index
Some
(
merge_node_index
)
)
?
fallthrough
)
)
;
}
result
.
push
(
crate
:
:
Statement
:
:
Switch
{
selector
cases
default
:
self
.
naga_traverse
(
self
.
block_to_node
[
&
default
]
Some
(
merge_node_index
)
)
?
}
)
;
result
.
extend
(
self
.
naga_traverse
(
merge_node_index
None
)
?
)
;
Ok
(
result
)
}
_
=
>
Err
(
Error
:
:
InvalidTerminator
)
}
Some
(
ControlFlowNodeType
:
:
Loop
)
=
>
{
let
merge_node_index
=
self
.
block_to_node
[
&
node
.
merge
.
unwrap
(
)
.
merge_block_id
]
;
let
continuing
:
crate
:
:
Block
=
{
let
continue_edge
=
self
.
flow
.
edges_directed
(
node_index
Direction
:
:
Outgoing
)
.
find
(
|
&
ty
|
*
ty
.
weight
(
)
=
=
ControlFlowEdgeType
:
:
ForwardContinue
)
.
unwrap
(
)
;
self
.
flow
[
continue_edge
.
target
(
)
]
.
block
.
clone
(
)
}
;
let
mut
body
:
crate
:
:
Block
=
node
.
block
.
clone
(
)
;
match
node
.
terminator
{
Terminator
:
:
BranchConditional
{
condition
true_id
false_id
}
=
>
body
.
push
(
crate
:
:
Statement
:
:
If
{
condition
accept
:
self
.
naga_traverse
(
self
.
block_to_node
[
&
true_id
]
Some
(
merge_node_index
)
)
?
reject
:
self
.
naga_traverse
(
self
.
block_to_node
[
&
false_id
]
Some
(
merge_node_index
)
)
?
}
)
Terminator
:
:
Branch
{
target_id
}
=
>
body
.
extend
(
self
.
naga_traverse
(
self
.
block_to_node
[
&
target_id
]
Some
(
merge_node_index
)
)
?
)
_
=
>
return
Err
(
Error
:
:
InvalidTerminator
)
}
;
Ok
(
vec
!
[
crate
:
:
Statement
:
:
Loop
{
body
continuing
}
]
)
}
Some
(
ControlFlowNodeType
:
:
Break
)
=
>
{
let
mut
result
=
node
.
block
.
clone
(
)
;
match
node
.
terminator
{
Terminator
:
:
BranchConditional
{
condition
true_id
false_id
}
=
>
result
.
push
(
crate
:
:
Statement
:
:
If
{
condition
accept
:
self
.
naga_traverse
(
self
.
block_to_node
[
&
true_id
]
stop_node_index
)
?
reject
:
self
.
naga_traverse
(
self
.
block_to_node
[
&
false_id
]
stop_node_index
)
?
}
)
_
=
>
return
Err
(
Error
:
:
InvalidTerminator
)
}
;
Ok
(
result
)
}
Some
(
ControlFlowNodeType
:
:
Continue
)
=
>
{
let
mut
result
=
node
.
block
.
clone
(
)
;
result
.
push
(
crate
:
:
Statement
:
:
Continue
)
;
Ok
(
result
)
}
Some
(
ControlFlowNodeType
:
:
Back
)
|
Some
(
ControlFlowNodeType
:
:
Merge
)
=
>
{
Ok
(
node
.
block
.
clone
(
)
)
}
Some
(
ControlFlowNodeType
:
:
Kill
)
=
>
{
let
mut
result
=
node
.
block
.
clone
(
)
;
result
.
push
(
crate
:
:
Statement
:
:
Kill
)
;
Ok
(
result
)
}
Some
(
ControlFlowNodeType
:
:
Return
)
=
>
{
let
value
=
match
node
.
terminator
{
Terminator
:
:
Return
{
value
}
=
>
value
_
=
>
return
Err
(
Error
:
:
InvalidTerminator
)
}
;
let
mut
result
=
node
.
block
.
clone
(
)
;
result
.
push
(
crate
:
:
Statement
:
:
Return
{
value
}
)
;
Ok
(
result
)
}
None
=
>
match
node
.
terminator
{
Terminator
:
:
Branch
{
target_id
}
=
>
{
let
mut
result
=
node
.
block
.
clone
(
)
;
result
.
extend
(
self
.
naga_traverse
(
self
.
block_to_node
[
&
target_id
]
stop_node_index
)
?
)
;
Ok
(
result
)
}
_
=
>
Ok
(
node
.
block
.
clone
(
)
)
}
}
}
pub
(
super
)
fn
to_graphviz
(
&
self
)
-
>
Result
<
String
std
:
:
fmt
:
:
Error
>
{
let
mut
output
=
String
:
:
new
(
)
;
output
+
=
"
digraph
ControlFlowGraph
{
"
;
for
node_index
in
self
.
flow
.
node_indices
(
)
{
let
node
=
&
self
.
flow
[
node_index
]
;
writeln
!
(
output
"
{
}
[
label
=
\
"
%
{
}
{
:
?
}
\
"
]
"
node_index
.
index
(
)
node
.
id
node
.
ty
)
?
;
}
for
edge
in
self
.
flow
.
raw_edges
(
)
{
let
source
=
edge
.
source
(
)
;
let
target
=
edge
.
target
(
)
;
let
style
=
match
edge
.
weight
{
ControlFlowEdgeType
:
:
IfTrue
=
>
"
color
=
blue
"
ControlFlowEdgeType
:
:
IfFalse
=
>
"
color
=
red
"
ControlFlowEdgeType
:
:
ForwardMerge
=
>
"
style
=
dotted
"
_
=
>
"
"
}
;
writeln
!
(
&
mut
output
"
{
}
-
>
{
}
[
{
}
]
"
source
.
index
(
)
target
.
index
(
)
style
)
?
;
}
output
+
=
"
}
\
n
"
;
Ok
(
output
)
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Debug
)
]
pub
(
super
)
enum
ControlFlowEdgeType
{
Forward
ForwardMerge
ForwardContinue
Back
LoopBreak
LoopContinue
IfTrue
IfFalse
SwitchBreak
CaseFallThrough
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
pub
(
super
)
enum
ControlFlowNodeType
{
Header
Loop
Merge
Break
Continue
Back
Kill
Return
}
pub
(
super
)
struct
ControlFlowNode
{
pub
id
:
BlockId
pub
ty
:
Option
<
ControlFlowNodeType
>
pub
phis
:
Vec
<
PhiInstruction
>
pub
block
:
crate
:
:
Block
pub
terminator
:
Terminator
pub
merge
:
Option
<
MergeInstruction
>
}
