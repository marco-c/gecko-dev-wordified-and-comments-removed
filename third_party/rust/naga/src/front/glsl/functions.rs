use
alloc
:
:
{
format
string
:
:
{
String
ToString
}
vec
vec
:
:
Vec
}
;
use
core
:
:
iter
;
use
super
:
:
{
ast
:
:
*
builtins
:
:
{
inject_builtin
sampled_to_depth
}
context
:
:
{
Context
ExprPos
StmtContext
}
error
:
:
{
Error
ErrorKind
}
types
:
:
scalar_components
Frontend
Result
}
;
use
crate
:
:
{
front
:
:
glsl
:
:
types
:
:
type_power
proc
:
:
ensure_block_returns
AddressSpace
Block
EntryPoint
Expression
Function
FunctionArgument
FunctionResult
Handle
Literal
LocalVariable
Scalar
ScalarKind
Span
Statement
StructMember
Type
TypeInner
}
;
struct
ProxyWrite
{
target
:
Handle
<
Expression
>
value
:
Handle
<
Expression
>
convert
:
Option
<
Scalar
>
}
impl
Frontend
{
pub
(
crate
)
fn
function_or_constructor_call
(
&
mut
self
ctx
:
&
mut
Context
stmt
:
&
StmtContext
fc
:
FunctionCallKind
raw_args
:
&
[
Handle
<
HirExpr
>
]
meta
:
Span
)
-
>
Result
<
Option
<
Handle
<
Expression
>
>
>
{
let
args
:
Vec
<
_
>
=
raw_args
.
iter
(
)
.
map
(
|
e
|
ctx
.
lower_expect_inner
(
stmt
self
*
e
ExprPos
:
:
Rhs
)
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
match
fc
{
FunctionCallKind
:
:
TypeConstructor
(
ty
)
=
>
{
if
args
.
len
(
)
=
=
1
{
self
.
constructor_single
(
ctx
ty
args
[
0
]
meta
)
.
map
(
Some
)
}
else
{
self
.
constructor_many
(
ctx
ty
args
meta
)
.
map
(
Some
)
}
}
FunctionCallKind
:
:
Function
(
name
)
=
>
{
self
.
function_call
(
ctx
stmt
name
args
raw_args
meta
)
}
}
}
fn
constructor_single
(
&
mut
self
ctx
:
&
mut
Context
ty
:
Handle
<
Type
>
(
mut
value
expr_meta
)
:
(
Handle
<
Expression
>
Span
)
meta
:
Span
)
-
>
Result
<
Handle
<
Expression
>
>
{
let
expr_type
=
ctx
.
resolve_type
(
value
expr_meta
)
?
;
let
vector_size
=
match
*
expr_type
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
Some
(
size
)
_
=
>
None
}
;
let
expr_is_bool
=
expr_type
.
scalar_kind
(
)
=
=
Some
(
ScalarKind
:
:
Bool
)
;
match
ctx
.
module
.
types
[
ty
]
.
inner
.
scalar
(
)
{
Some
(
result_scalar
)
if
expr_is_bool
&
&
result_scalar
.
kind
!
=
ScalarKind
:
:
Bool
=
>
{
let
result_scalar
=
Scalar
{
width
:
4
.
.
result_scalar
}
;
let
l0
=
Literal
:
:
zero
(
result_scalar
)
.
unwrap
(
)
;
let
l1
=
Literal
:
:
one
(
result_scalar
)
.
unwrap
(
)
;
let
mut
reject
=
ctx
.
add_expression
(
Expression
:
:
Literal
(
l0
)
expr_meta
)
?
;
let
mut
accept
=
ctx
.
add_expression
(
Expression
:
:
Literal
(
l1
)
expr_meta
)
?
;
ctx
.
implicit_splat
(
&
mut
reject
meta
vector_size
)
?
;
ctx
.
implicit_splat
(
&
mut
accept
meta
vector_size
)
?
;
let
h
=
ctx
.
add_expression
(
Expression
:
:
Select
{
accept
reject
condition
:
value
}
expr_meta
)
?
;
return
Ok
(
h
)
;
}
_
=
>
{
}
}
Ok
(
match
ctx
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Vector
{
size
scalar
}
if
vector_size
.
is_none
(
)
=
>
{
ctx
.
forced_conversion
(
&
mut
value
expr_meta
scalar
)
?
;
if
let
TypeInner
:
:
Scalar
{
.
.
}
=
*
ctx
.
resolve_type
(
value
expr_meta
)
?
{
ctx
.
add_expression
(
Expression
:
:
Splat
{
size
value
}
meta
)
?
}
else
{
self
.
vector_constructor
(
ctx
ty
size
scalar
&
[
(
value
expr_meta
)
]
meta
)
?
}
}
TypeInner
:
:
Scalar
(
scalar
)
=
>
{
let
mut
expr
=
value
;
if
let
TypeInner
:
:
Vector
{
.
.
}
|
TypeInner
:
:
Matrix
{
.
.
}
=
*
ctx
.
resolve_type
(
value
expr_meta
)
?
{
expr
=
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
expr
index
:
0
}
meta
)
?
;
}
if
let
TypeInner
:
:
Matrix
{
.
.
}
=
*
ctx
.
resolve_type
(
value
expr_meta
)
?
{
expr
=
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
expr
index
:
0
}
meta
)
?
;
}
ctx
.
add_expression
(
Expression
:
:
As
{
kind
:
scalar
.
kind
expr
convert
:
Some
(
scalar
.
width
)
}
meta
)
?
}
TypeInner
:
:
Vector
{
size
scalar
}
=
>
{
if
vector_size
!
=
Some
(
size
)
{
value
=
ctx
.
vector_resize
(
size
value
expr_meta
)
?
;
}
ctx
.
add_expression
(
Expression
:
:
As
{
kind
:
scalar
.
kind
expr
:
value
convert
:
Some
(
scalar
.
width
)
}
meta
)
?
}
TypeInner
:
:
Matrix
{
columns
rows
scalar
}
=
>
self
.
matrix_one_arg
(
ctx
ty
columns
rows
scalar
(
value
expr_meta
)
meta
)
?
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
let
scalar_components
=
members
.
first
(
)
.
and_then
(
|
member
|
scalar_components
(
&
ctx
.
module
.
types
[
member
.
ty
]
.
inner
)
)
;
if
let
Some
(
scalar
)
=
scalar_components
{
ctx
.
implicit_conversion
(
&
mut
value
expr_meta
scalar
)
?
;
}
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
:
vec
!
[
value
]
}
meta
)
?
}
TypeInner
:
:
Array
{
base
.
.
}
=
>
{
let
scalar_components
=
scalar_components
(
&
ctx
.
module
.
types
[
base
]
.
inner
)
;
if
let
Some
(
scalar
)
=
scalar_components
{
ctx
.
implicit_conversion
(
&
mut
value
expr_meta
scalar
)
?
;
}
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
:
vec
!
[
value
]
}
meta
)
?
}
_
=
>
{
self
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Bad
type
constructor
"
.
into
(
)
)
meta
}
)
;
value
}
}
)
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
matrix_one_arg
(
&
mut
self
ctx
:
&
mut
Context
ty
:
Handle
<
Type
>
columns
:
crate
:
:
VectorSize
rows
:
crate
:
:
VectorSize
element_scalar
:
Scalar
(
mut
value
expr_meta
)
:
(
Handle
<
Expression
>
Span
)
meta
:
Span
)
-
>
Result
<
Handle
<
Expression
>
>
{
let
mut
components
=
Vec
:
:
with_capacity
(
columns
as
usize
)
;
ctx
.
forced_conversion
(
&
mut
value
expr_meta
element_scalar
)
?
;
match
*
ctx
.
resolve_type
(
value
expr_meta
)
?
{
TypeInner
:
:
Scalar
(
_
)
=
>
{
let
vector_ty
=
ctx
.
module
.
types
.
insert
(
Type
{
name
:
None
inner
:
TypeInner
:
:
Vector
{
size
:
rows
scalar
:
element_scalar
}
}
meta
)
;
let
zero_literal
=
Literal
:
:
zero
(
element_scalar
)
.
unwrap
(
)
;
let
zero
=
ctx
.
add_expression
(
Expression
:
:
Literal
(
zero_literal
)
meta
)
?
;
for
i
in
0
.
.
columns
as
u32
{
components
.
push
(
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
:
vector_ty
components
:
(
0
.
.
rows
as
u32
)
.
map
(
|
r
|
match
r
=
=
i
{
true
=
>
value
false
=
>
zero
}
)
.
collect
(
)
}
meta
)
?
)
}
}
TypeInner
:
:
Matrix
{
rows
:
ori_rows
columns
:
ori_cols
.
.
}
=
>
{
let
zero_literal
=
Literal
:
:
zero
(
element_scalar
)
.
unwrap
(
)
;
let
one_literal
=
Literal
:
:
one
(
element_scalar
)
.
unwrap
(
)
;
let
zero
=
ctx
.
add_expression
(
Expression
:
:
Literal
(
zero_literal
)
meta
)
?
;
let
one
=
ctx
.
add_expression
(
Expression
:
:
Literal
(
one_literal
)
meta
)
?
;
let
vector_ty
=
ctx
.
module
.
types
.
insert
(
Type
{
name
:
None
inner
:
TypeInner
:
:
Vector
{
size
:
rows
scalar
:
element_scalar
}
}
meta
)
;
for
i
in
0
.
.
columns
as
u32
{
if
i
<
ori_cols
as
u32
{
use
core
:
:
cmp
:
:
Ordering
;
let
vector
=
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
value
index
:
i
}
meta
)
?
;
components
.
push
(
match
ori_rows
.
cmp
(
&
rows
)
{
Ordering
:
:
Less
=
>
{
let
components
=
(
0
.
.
rows
as
u32
)
.
map
(
|
r
|
{
if
r
<
ori_rows
as
u32
{
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
vector
index
:
r
}
meta
)
}
else
if
r
=
=
i
{
Ok
(
one
)
}
else
{
Ok
(
zero
)
}
}
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
:
vector_ty
components
}
meta
)
?
}
Ordering
:
:
Equal
=
>
vector
Ordering
:
:
Greater
=
>
ctx
.
vector_resize
(
rows
vector
meta
)
?
}
)
}
else
{
let
compose_expr
=
Expression
:
:
Compose
{
ty
:
vector_ty
components
:
(
0
.
.
rows
as
u32
)
.
map
(
|
r
|
match
r
=
=
i
{
true
=
>
one
false
=
>
zero
}
)
.
collect
(
)
}
;
let
vec
=
ctx
.
add_expression
(
compose_expr
meta
)
?
;
components
.
push
(
vec
)
}
}
}
_
=
>
{
components
=
iter
:
:
repeat_n
(
value
columns
as
usize
)
.
collect
(
)
;
}
}
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
}
meta
)
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
vector_constructor
(
&
mut
self
ctx
:
&
mut
Context
ty
:
Handle
<
Type
>
size
:
crate
:
:
VectorSize
scalar
:
Scalar
args
:
&
[
(
Handle
<
Expression
>
Span
)
]
meta
:
Span
)
-
>
Result
<
Handle
<
Expression
>
>
{
let
mut
components
=
Vec
:
:
with_capacity
(
size
as
usize
)
;
for
(
mut
arg
expr_meta
)
in
args
.
iter
(
)
.
copied
(
)
{
ctx
.
forced_conversion
(
&
mut
arg
expr_meta
scalar
)
?
;
if
components
.
len
(
)
>
=
size
as
usize
{
break
;
}
match
*
ctx
.
resolve_type
(
arg
expr_meta
)
?
{
TypeInner
:
:
Scalar
{
.
.
}
=
>
components
.
push
(
arg
)
TypeInner
:
:
Matrix
{
rows
columns
.
.
}
=
>
{
components
.
reserve
(
rows
as
usize
*
columns
as
usize
)
;
for
c
in
0
.
.
(
columns
as
u32
)
{
let
base
=
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
arg
index
:
c
}
expr_meta
)
?
;
for
r
in
0
.
.
(
rows
as
u32
)
{
components
.
push
(
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
index
:
r
}
expr_meta
)
?
)
}
}
}
TypeInner
:
:
Vector
{
size
:
ori_size
.
.
}
=
>
{
components
.
reserve
(
ori_size
as
usize
)
;
for
index
in
0
.
.
(
ori_size
as
u32
)
{
components
.
push
(
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
arg
index
}
expr_meta
)
?
)
}
}
_
=
>
components
.
push
(
arg
)
}
}
components
.
truncate
(
size
as
usize
)
;
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
}
meta
)
}
fn
constructor_many
(
&
mut
self
ctx
:
&
mut
Context
ty
:
Handle
<
Type
>
args
:
Vec
<
(
Handle
<
Expression
>
Span
)
>
meta
:
Span
)
-
>
Result
<
Handle
<
Expression
>
>
{
let
mut
components
=
Vec
:
:
with_capacity
(
args
.
len
(
)
)
;
let
struct_member_data
=
match
ctx
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Matrix
{
columns
rows
scalar
:
element_scalar
}
=
>
{
let
mut
flattened
=
Vec
:
:
with_capacity
(
columns
as
usize
*
rows
as
usize
)
;
for
(
mut
arg
meta
)
in
args
.
iter
(
)
.
copied
(
)
{
ctx
.
forced_conversion
(
&
mut
arg
meta
element_scalar
)
?
;
match
*
ctx
.
resolve_type
(
arg
meta
)
?
{
TypeInner
:
:
Vector
{
size
.
.
}
=
>
{
for
i
in
0
.
.
(
size
as
u32
)
{
flattened
.
push
(
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
arg
index
:
i
}
meta
)
?
)
}
}
_
=
>
flattened
.
push
(
arg
)
}
}
let
ty
=
ctx
.
module
.
types
.
insert
(
Type
{
name
:
None
inner
:
TypeInner
:
:
Vector
{
size
:
rows
scalar
:
element_scalar
}
}
meta
)
;
for
chunk
in
flattened
.
chunks
(
rows
as
usize
)
{
components
.
push
(
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
:
Vec
:
:
from
(
chunk
)
}
meta
)
?
)
}
None
}
TypeInner
:
:
Vector
{
size
scalar
}
=
>
{
return
self
.
vector_constructor
(
ctx
ty
size
scalar
&
args
meta
)
}
TypeInner
:
:
Array
{
base
.
.
}
=
>
{
for
(
mut
arg
meta
)
in
args
.
iter
(
)
.
copied
(
)
{
let
scalar_components
=
scalar_components
(
&
ctx
.
module
.
types
[
base
]
.
inner
)
;
if
let
Some
(
scalar
)
=
scalar_components
{
ctx
.
implicit_conversion
(
&
mut
arg
meta
scalar
)
?
;
}
components
.
push
(
arg
)
}
None
}
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
Some
(
members
.
iter
(
)
.
map
(
|
member
|
scalar_components
(
&
ctx
.
module
.
types
[
member
.
ty
]
.
inner
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
_
=
>
{
return
Err
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Constructor
:
Too
many
arguments
"
.
into
(
)
)
meta
}
)
}
}
;
if
let
Some
(
struct_member_data
)
=
struct_member_data
{
for
(
(
mut
arg
meta
)
scalar_components
)
in
args
.
iter
(
)
.
copied
(
)
.
zip
(
struct_member_data
.
iter
(
)
.
copied
(
)
)
{
if
let
Some
(
scalar
)
=
scalar_components
{
ctx
.
implicit_conversion
(
&
mut
arg
meta
scalar
)
?
;
}
components
.
push
(
arg
)
}
}
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
}
meta
)
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
function_call
(
&
mut
self
ctx
:
&
mut
Context
stmt
:
&
StmtContext
name
:
String
args
:
Vec
<
(
Handle
<
Expression
>
Span
)
>
raw_args
:
&
[
Handle
<
HirExpr
>
]
meta
:
Span
)
-
>
Result
<
Option
<
Handle
<
Expression
>
>
>
{
for
&
(
expr
span
)
in
args
.
iter
(
)
{
ctx
.
typifier_grow
(
expr
span
)
?
;
}
let
mut
variations
=
builtin_required_variations
(
args
.
iter
(
)
.
map
(
|
&
(
expr
_
)
|
ctx
.
get_type
(
expr
)
)
)
;
let
declaration
=
self
.
lookup_function
.
entry
(
name
.
clone
(
)
)
.
or_insert_with
(
|
|
{
variations
|
=
BuiltinVariations
:
:
STANDARD
;
Default
:
:
default
(
)
}
)
;
inject_builtin
(
declaration
ctx
.
module
&
name
variations
)
;
let
declaration
=
self
.
lookup_function
.
get
(
&
name
)
.
unwrap
(
)
;
let
mut
maybe_overload
=
None
;
let
mut
old_conversions
=
vec
!
[
Conversion
:
:
None
;
args
.
len
(
)
]
;
let
mut
ambiguous
=
false
;
'
outer
:
for
(
overload_idx
overload
)
in
declaration
.
overloads
.
iter
(
)
.
enumerate
(
)
{
if
args
.
len
(
)
!
=
overload
.
parameters
.
len
(
)
{
continue
;
}
log
:
:
trace
!
(
"
Testing
overload
{
overload_idx
}
"
)
;
let
mut
exact
=
true
;
let
mut
superior
=
None
;
let
mut
new_conversions
=
vec
!
[
Conversion
:
:
None
;
args
.
len
(
)
]
;
for
(
i
overload_parameter
)
in
overload
.
parameters
.
iter
(
)
.
enumerate
(
)
{
let
call_argument
=
&
args
[
i
]
;
let
parameter_info
=
&
overload
.
parameters_info
[
i
]
;
if
parameter_info
.
depth
{
sampled_to_depth
(
ctx
call_argument
.
0
call_argument
.
1
&
mut
self
.
errors
)
;
ctx
.
invalidate_expression
(
call_argument
.
0
call_argument
.
1
)
?
}
ctx
.
typifier_grow
(
call_argument
.
0
call_argument
.
1
)
?
;
let
overload_param_ty
=
&
ctx
.
module
.
types
[
*
overload_parameter
]
.
inner
;
let
call_arg_ty
=
ctx
.
get_type
(
call_argument
.
0
)
;
log
:
:
trace
!
(
"
Testing
parameter
{
i
}
\
n
\
tOverload
=
{
overload_param_ty
:
?
}
\
n
\
tCall
=
{
call_arg_ty
:
?
}
"
)
;
if
let
(
&
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
format
:
overload_format
access
:
overload_access
}
dim
:
overload_dim
arrayed
:
overload_arrayed
}
&
TypeInner
:
:
Image
{
class
:
crate
:
:
ImageClass
:
:
Storage
{
format
:
call_format
access
:
call_access
}
dim
:
call_dim
arrayed
:
call_arrayed
}
)
=
(
overload_param_ty
call_arg_ty
)
{
let
good_size
=
call_dim
=
=
overload_dim
&
&
call_arrayed
=
=
overload_arrayed
;
let
good_format
=
overload_format
=
=
call_format
|
|
(
overload
.
internal
&
&
Scalar
:
:
from
(
overload_format
)
=
=
Scalar
:
:
from
(
call_format
)
)
;
if
!
(
good_size
&
&
good_format
)
{
continue
'
outer
;
}
if
!
call_access
.
contains
(
overload_access
)
{
self
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
format
!
(
"
'
{
name
}
'
:
image
needs
{
overload_access
:
?
}
access
but
only
{
call_access
:
?
}
was
provided
"
)
.
into
(
)
)
meta
}
)
;
}
new_conversions
[
i
]
=
Conversion
:
:
Exact
;
continue
;
}
else
if
overload_param_ty
=
=
call_arg_ty
{
new_conversions
[
i
]
=
Conversion
:
:
Exact
;
continue
;
}
if
let
ParameterQualifier
:
:
InOut
=
parameter_info
.
qualifier
{
continue
'
outer
;
}
let
maybe_conversion
=
if
parameter_info
.
qualifier
.
is_lhs
(
)
{
conversion
(
call_arg_ty
overload_param_ty
)
}
else
{
conversion
(
overload_param_ty
call_arg_ty
)
}
;
let
conversion
=
match
maybe_conversion
{
Some
(
info
)
=
>
info
None
=
>
continue
'
outer
}
;
exact
=
false
;
let
best_arg
=
match
(
conversion
old_conversions
[
i
]
)
{
(
_
Conversion
:
:
Exact
)
=
>
false
(
_
Conversion
:
:
None
)
=
>
true
(
Conversion
:
:
FloatToDouble
_
)
=
>
true
(
_
Conversion
:
:
FloatToDouble
)
=
>
false
(
Conversion
:
:
IntToFloat
Conversion
:
:
IntToDouble
)
=
>
true
(
Conversion
:
:
IntToDouble
Conversion
:
:
IntToFloat
)
=
>
false
_
=
>
continue
}
;
match
best_arg
{
true
=
>
match
superior
{
Some
(
false
)
=
>
ambiguous
=
true
_
=
>
{
superior
=
Some
(
true
)
;
new_conversions
[
i
]
=
conversion
}
}
false
=
>
match
superior
{
Some
(
true
)
=
>
ambiguous
=
true
_
=
>
superior
=
Some
(
false
)
}
}
}
if
exact
{
maybe_overload
=
Some
(
overload
)
;
ambiguous
=
false
;
break
;
}
match
superior
{
Some
(
true
)
=
>
{
maybe_overload
=
Some
(
overload
)
;
old_conversions
=
new_conversions
;
}
Some
(
false
)
=
>
{
}
None
=
>
{
ambiguous
=
true
;
maybe_overload
=
Some
(
overload
)
;
}
}
}
if
ambiguous
{
self
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
format
!
(
"
Ambiguous
best
function
for
'
{
name
}
'
"
)
.
into
(
)
)
meta
}
)
}
let
overload
=
maybe_overload
.
ok_or_else
(
|
|
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
format
!
(
"
Unknown
function
'
{
name
}
'
"
)
.
into
(
)
)
meta
}
)
?
;
let
parameters_info
=
overload
.
parameters_info
.
clone
(
)
;
let
parameters
=
overload
.
parameters
.
clone
(
)
;
let
is_void
=
overload
.
void
;
let
kind
=
overload
.
kind
;
let
mut
arguments
=
Vec
:
:
with_capacity
(
args
.
len
(
)
)
;
let
mut
proxy_writes
=
Vec
:
:
new
(
)
;
for
(
(
(
parameter_info
call_argument
)
expr
)
parameter
)
in
parameters_info
.
iter
(
)
.
zip
(
&
args
)
.
zip
(
raw_args
)
.
zip
(
&
parameters
)
{
if
parameter_info
.
qualifier
.
is_lhs
(
)
{
let
(
handle
meta
)
=
ctx
.
lower_expect_inner
(
stmt
self
*
expr
ExprPos
:
:
Lhs
)
?
;
self
.
process_lhs_argument
(
ctx
meta
*
parameter
parameter_info
handle
call_argument
&
mut
proxy_writes
&
mut
arguments
)
?
;
continue
;
}
let
(
mut
handle
meta
)
=
*
call_argument
;
let
scalar_comps
=
scalar_components
(
&
ctx
.
module
.
types
[
*
parameter
]
.
inner
)
;
if
let
Some
(
scalar
)
=
scalar_comps
{
ctx
.
implicit_conversion
(
&
mut
handle
meta
scalar
)
?
;
}
arguments
.
push
(
handle
)
}
match
kind
{
FunctionKind
:
:
Call
(
function
)
=
>
{
ctx
.
emit_end
(
)
;
let
result
=
if
!
is_void
{
Some
(
ctx
.
add_expression
(
Expression
:
:
CallResult
(
function
)
meta
)
?
)
}
else
{
None
}
;
ctx
.
body
.
push
(
Statement
:
:
Call
{
function
arguments
result
}
meta
)
;
ctx
.
emit_start
(
)
;
for
proxy_write
in
proxy_writes
{
let
mut
value
=
ctx
.
add_expression
(
Expression
:
:
Load
{
pointer
:
proxy_write
.
value
}
meta
)
?
;
if
let
Some
(
scalar
)
=
proxy_write
.
convert
{
ctx
.
conversion
(
&
mut
value
meta
scalar
)
?
;
}
ctx
.
emit_restart
(
)
;
ctx
.
body
.
push
(
Statement
:
:
Store
{
pointer
:
proxy_write
.
target
value
}
meta
)
;
}
Ok
(
result
)
}
FunctionKind
:
:
Macro
(
builtin
)
=
>
builtin
.
call
(
self
ctx
arguments
.
as_mut_slice
(
)
meta
)
}
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
fn
process_lhs_argument
(
&
mut
self
ctx
:
&
mut
Context
meta
:
Span
parameter_ty
:
Handle
<
Type
>
parameter_info
:
&
ParameterInfo
original
:
Handle
<
Expression
>
call_argument
:
&
(
Handle
<
Expression
>
Span
)
proxy_writes
:
&
mut
Vec
<
ProxyWrite
>
arguments
:
&
mut
Vec
<
Handle
<
Expression
>
>
)
-
>
Result
<
(
)
>
{
let
original_ty
=
ctx
.
resolve_type
(
original
meta
)
?
;
let
original_pointer_space
=
original_ty
.
pointer_space
(
)
;
let
mut
maybe_ty
=
match
*
original_ty
{
TypeInner
:
:
Vector
{
size
scalar
}
=
>
Some
(
ctx
.
module
.
types
.
insert
(
Type
{
name
:
None
inner
:
TypeInner
:
:
Vector
{
size
scalar
}
}
Span
:
:
default
(
)
)
)
TypeInner
:
:
Pointer
{
base
space
}
if
space
!
=
AddressSpace
:
:
Function
=
>
Some
(
base
)
TypeInner
:
:
ValuePointer
{
size
scalar
space
}
if
space
!
=
AddressSpace
:
:
Function
=
>
{
let
inner
=
match
size
{
Some
(
size
)
=
>
TypeInner
:
:
Vector
{
size
scalar
}
None
=
>
TypeInner
:
:
Scalar
(
scalar
)
}
;
Some
(
ctx
.
module
.
types
.
insert
(
Type
{
name
:
None
inner
}
Span
:
:
default
(
)
)
)
}
_
=
>
None
}
;
let
value
=
if
original_pointer_space
.
is_some
(
)
{
ctx
.
add_expression
(
Expression
:
:
Load
{
pointer
:
original
}
Span
:
:
default
(
)
)
?
}
else
{
original
}
;
ctx
.
typifier_grow
(
call_argument
.
0
call_argument
.
1
)
?
;
let
overload_param_ty
=
&
ctx
.
module
.
types
[
parameter_ty
]
.
inner
;
let
call_arg_ty
=
ctx
.
get_type
(
call_argument
.
0
)
;
let
needs_conversion
=
call_arg_ty
!
=
overload_param_ty
;
let
arg_scalar_comps
=
scalar_components
(
call_arg_ty
)
;
if
needs_conversion
{
maybe_ty
=
Some
(
parameter_ty
)
;
}
if
let
Some
(
ty
)
=
maybe_ty
{
let
spill_var
=
ctx
.
locals
.
append
(
LocalVariable
{
name
:
None
ty
init
:
None
}
Span
:
:
default
(
)
)
;
let
spill_expr
=
ctx
.
add_expression
(
Expression
:
:
LocalVariable
(
spill_var
)
Span
:
:
default
(
)
)
?
;
if
let
ParameterQualifier
:
:
InOut
=
parameter_info
.
qualifier
{
ctx
.
body
.
push
(
Statement
:
:
Store
{
pointer
:
spill_expr
value
}
Span
:
:
default
(
)
)
;
}
arguments
.
push
(
spill_expr
)
;
let
convert
=
if
needs_conversion
{
arg_scalar_comps
}
else
{
None
}
;
if
let
Expression
:
:
Swizzle
{
size
mut
vector
pattern
}
=
ctx
.
expressions
[
original
]
{
if
let
Expression
:
:
Load
{
pointer
}
=
ctx
.
expressions
[
vector
]
{
vector
=
pointer
;
}
for
(
i
component
)
in
pattern
.
iter
(
)
.
take
(
size
as
usize
)
.
enumerate
(
)
{
let
original
=
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
vector
index
:
*
component
as
u32
}
Span
:
:
default
(
)
)
?
;
let
spill_component
=
ctx
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
spill_expr
index
:
i
as
u32
}
Span
:
:
default
(
)
)
?
;
proxy_writes
.
push
(
ProxyWrite
{
target
:
original
value
:
spill_component
convert
}
)
;
}
}
else
{
proxy_writes
.
push
(
ProxyWrite
{
target
:
original
value
:
spill_expr
convert
}
)
;
}
}
else
{
arguments
.
push
(
original
)
;
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
add_function
(
&
mut
self
mut
ctx
:
Context
name
:
String
result
:
Option
<
FunctionResult
>
meta
:
Span
)
{
ensure_block_returns
(
&
mut
ctx
.
body
)
;
let
void
=
result
.
is_none
(
)
;
let
mut
variations
=
builtin_required_variations
(
ctx
.
parameters
.
iter
(
)
.
map
(
|
&
arg
|
&
ctx
.
module
.
types
[
arg
]
.
inner
)
)
;
let
declaration
=
self
.
lookup_function
.
entry
(
name
.
clone
(
)
)
.
or_insert_with
(
|
|
{
variations
|
=
BuiltinVariations
:
:
STANDARD
;
Default
:
:
default
(
)
}
)
;
inject_builtin
(
declaration
ctx
.
module
&
name
variations
)
;
let
Context
{
expressions
locals
arguments
parameters
parameters_info
body
module
.
.
}
=
ctx
;
let
function
=
Function
{
name
:
Some
(
name
)
arguments
result
local_variables
:
locals
expressions
named_expressions
:
crate
:
:
NamedExpressions
:
:
default
(
)
body
diagnostic_filter_leaf
:
None
}
;
'
outer
:
for
decl
in
declaration
.
overloads
.
iter_mut
(
)
{
if
parameters
.
len
(
)
!
=
decl
.
parameters
.
len
(
)
{
continue
;
}
for
(
new_parameter
old_parameter
)
in
parameters
.
iter
(
)
.
zip
(
decl
.
parameters
.
iter
(
)
)
{
let
new_inner
=
&
module
.
types
[
*
new_parameter
]
.
inner
;
let
old_inner
=
&
module
.
types
[
*
old_parameter
]
.
inner
;
if
new_inner
!
=
old_inner
{
continue
'
outer
;
}
}
if
decl
.
defined
{
return
self
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Function
already
defined
"
.
into
(
)
)
meta
}
)
;
}
decl
.
defined
=
true
;
decl
.
parameters_info
=
parameters_info
;
match
decl
.
kind
{
FunctionKind
:
:
Call
(
handle
)
=
>
*
module
.
functions
.
get_mut
(
handle
)
=
function
FunctionKind
:
:
Macro
(
_
)
=
>
{
let
handle
=
module
.
functions
.
append
(
function
meta
)
;
decl
.
kind
=
FunctionKind
:
:
Call
(
handle
)
}
}
return
;
}
let
handle
=
module
.
functions
.
append
(
function
meta
)
;
declaration
.
overloads
.
push
(
Overload
{
parameters
parameters_info
kind
:
FunctionKind
:
:
Call
(
handle
)
defined
:
true
internal
:
false
void
}
)
;
}
pub
(
crate
)
fn
add_prototype
(
&
mut
self
ctx
:
Context
name
:
String
result
:
Option
<
FunctionResult
>
meta
:
Span
)
{
let
void
=
result
.
is_none
(
)
;
let
mut
variations
=
builtin_required_variations
(
ctx
.
parameters
.
iter
(
)
.
map
(
|
&
arg
|
&
ctx
.
module
.
types
[
arg
]
.
inner
)
)
;
let
declaration
=
self
.
lookup_function
.
entry
(
name
.
clone
(
)
)
.
or_insert_with
(
|
|
{
variations
|
=
BuiltinVariations
:
:
STANDARD
;
Default
:
:
default
(
)
}
)
;
inject_builtin
(
declaration
ctx
.
module
&
name
variations
)
;
let
Context
{
arguments
parameters
parameters_info
module
.
.
}
=
ctx
;
let
function
=
Function
{
name
:
Some
(
name
)
arguments
result
.
.
Default
:
:
default
(
)
}
;
'
outer
:
for
decl
in
declaration
.
overloads
.
iter
(
)
{
if
parameters
.
len
(
)
!
=
decl
.
parameters
.
len
(
)
{
continue
;
}
for
(
new_parameter
old_parameter
)
in
parameters
.
iter
(
)
.
zip
(
decl
.
parameters
.
iter
(
)
)
{
let
new_inner
=
&
module
.
types
[
*
new_parameter
]
.
inner
;
let
old_inner
=
&
module
.
types
[
*
old_parameter
]
.
inner
;
if
new_inner
!
=
old_inner
{
continue
'
outer
;
}
}
return
self
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Prototype
already
defined
"
.
into
(
)
)
meta
}
)
;
}
let
handle
=
module
.
functions
.
append
(
function
meta
)
;
declaration
.
overloads
.
push
(
Overload
{
parameters
parameters_info
kind
:
FunctionKind
:
:
Call
(
handle
)
defined
:
false
internal
:
false
void
}
)
;
}
pub
(
crate
)
fn
add_entry_point
(
&
mut
self
function
:
Handle
<
Function
>
mut
ctx
:
Context
)
-
>
Result
<
(
)
>
{
let
mut
arguments
=
Vec
:
:
new
(
)
;
let
body
=
Block
:
:
with_capacity
(
ctx
.
body
.
len
(
)
+
self
.
entry_args
.
len
(
)
*
2
+
3
)
;
let
global_init_body
=
core
:
:
mem
:
:
replace
(
&
mut
ctx
.
body
body
)
;
for
arg
in
self
.
entry_args
.
iter
(
)
{
if
arg
.
storage
!
=
StorageQualifier
:
:
Input
{
continue
;
}
let
pointer
=
ctx
.
expressions
.
append
(
Expression
:
:
GlobalVariable
(
arg
.
handle
)
Default
:
:
default
(
)
)
;
ctx
.
local_expression_kind_tracker
.
insert
(
pointer
crate
:
:
proc
:
:
ExpressionKind
:
:
Runtime
)
;
let
ty
=
ctx
.
module
.
global_variables
[
arg
.
handle
]
.
ty
;
ctx
.
arg_type_walker
(
arg
.
name
.
clone
(
)
arg
.
binding
.
clone
(
)
pointer
ty
&
mut
|
ctx
name
pointer
ty
binding
|
{
let
idx
=
arguments
.
len
(
)
as
u32
;
arguments
.
push
(
FunctionArgument
{
name
ty
binding
:
Some
(
binding
)
}
)
;
let
value
=
ctx
.
expressions
.
append
(
Expression
:
:
FunctionArgument
(
idx
)
Default
:
:
default
(
)
)
;
ctx
.
local_expression_kind_tracker
.
insert
(
value
crate
:
:
proc
:
:
ExpressionKind
:
:
Runtime
)
;
ctx
.
body
.
push
(
Statement
:
:
Store
{
pointer
value
}
Default
:
:
default
(
)
)
;
}
)
?
}
ctx
.
body
.
extend_block
(
global_init_body
)
;
ctx
.
body
.
push
(
Statement
:
:
Call
{
function
arguments
:
Vec
:
:
new
(
)
result
:
None
}
Default
:
:
default
(
)
)
;
let
mut
span
=
0
;
let
mut
members
=
Vec
:
:
new
(
)
;
let
mut
components
=
Vec
:
:
new
(
)
;
for
arg
in
self
.
entry_args
.
iter
(
)
{
if
arg
.
storage
!
=
StorageQualifier
:
:
Output
{
continue
;
}
let
pointer
=
ctx
.
expressions
.
append
(
Expression
:
:
GlobalVariable
(
arg
.
handle
)
Default
:
:
default
(
)
)
;
ctx
.
local_expression_kind_tracker
.
insert
(
pointer
crate
:
:
proc
:
:
ExpressionKind
:
:
Runtime
)
;
let
ty
=
ctx
.
module
.
global_variables
[
arg
.
handle
]
.
ty
;
ctx
.
arg_type_walker
(
arg
.
name
.
clone
(
)
arg
.
binding
.
clone
(
)
pointer
ty
&
mut
|
ctx
name
pointer
ty
binding
|
{
members
.
push
(
StructMember
{
name
ty
binding
:
Some
(
binding
)
offset
:
span
}
)
;
span
+
=
ctx
.
module
.
types
[
ty
]
.
inner
.
size
(
ctx
.
module
.
to_ctx
(
)
)
;
let
len
=
ctx
.
expressions
.
len
(
)
;
let
load
=
ctx
.
expressions
.
append
(
Expression
:
:
Load
{
pointer
}
Default
:
:
default
(
)
)
;
ctx
.
local_expression_kind_tracker
.
insert
(
load
crate
:
:
proc
:
:
ExpressionKind
:
:
Runtime
)
;
ctx
.
body
.
push
(
Statement
:
:
Emit
(
ctx
.
expressions
.
range_from
(
len
)
)
Default
:
:
default
(
)
)
;
components
.
push
(
load
)
}
)
?
}
let
(
ty
value
)
=
if
!
components
.
is_empty
(
)
{
let
ty
=
ctx
.
module
.
types
.
insert
(
Type
{
name
:
None
inner
:
TypeInner
:
:
Struct
{
members
span
}
}
Default
:
:
default
(
)
)
;
let
len
=
ctx
.
expressions
.
len
(
)
;
let
res
=
ctx
.
expressions
.
append
(
Expression
:
:
Compose
{
ty
components
}
Default
:
:
default
(
)
)
;
ctx
.
local_expression_kind_tracker
.
insert
(
res
crate
:
:
proc
:
:
ExpressionKind
:
:
Runtime
)
;
ctx
.
body
.
push
(
Statement
:
:
Emit
(
ctx
.
expressions
.
range_from
(
len
)
)
Default
:
:
default
(
)
)
;
(
Some
(
ty
)
Some
(
res
)
)
}
else
{
(
None
None
)
}
;
ctx
.
body
.
push
(
Statement
:
:
Return
{
value
}
Default
:
:
default
(
)
)
;
let
Context
{
body
expressions
.
.
}
=
ctx
;
ctx
.
module
.
entry_points
.
push
(
EntryPoint
{
name
:
"
main
"
.
to_string
(
)
stage
:
self
.
meta
.
stage
early_depth_test
:
Some
(
crate
:
:
EarlyDepthTest
:
:
Force
)
.
filter
(
|
_
|
self
.
meta
.
early_fragment_tests
)
workgroup_size
:
self
.
meta
.
workgroup_size
workgroup_size_overrides
:
None
function
:
Function
{
arguments
expressions
body
result
:
ty
.
map
(
|
ty
|
FunctionResult
{
ty
binding
:
None
}
)
.
.
Default
:
:
default
(
)
}
}
)
;
Ok
(
(
)
)
}
}
impl
Context
<
'
_
>
{
fn
arg_type_walker
(
&
mut
self
name
:
Option
<
String
>
binding
:
crate
:
:
Binding
pointer
:
Handle
<
Expression
>
ty
:
Handle
<
Type
>
f
:
&
mut
impl
FnMut
(
&
mut
Context
Option
<
String
>
Handle
<
Expression
>
Handle
<
Type
>
crate
:
:
Binding
)
)
-
>
Result
<
(
)
>
{
match
self
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Array
{
base
size
:
crate
:
:
ArraySize
:
:
Constant
(
size
)
.
.
}
=
>
{
let
mut
location
=
match
binding
{
crate
:
:
Binding
:
:
Location
{
location
.
.
}
=
>
location
crate
:
:
Binding
:
:
BuiltIn
(
_
)
=
>
return
Ok
(
(
)
)
}
;
let
interpolation
=
self
.
module
.
types
[
base
]
.
inner
.
scalar_kind
(
)
.
map
(
|
kind
|
match
kind
{
ScalarKind
:
:
Float
=
>
crate
:
:
Interpolation
:
:
Perspective
_
=
>
crate
:
:
Interpolation
:
:
Flat
}
)
;
for
index
in
0
.
.
size
.
get
(
)
{
let
member_pointer
=
self
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
pointer
index
}
Span
:
:
default
(
)
)
?
;
let
binding
=
crate
:
:
Binding
:
:
Location
{
location
interpolation
sampling
:
None
blend_src
:
None
}
;
location
+
=
1
;
self
.
arg_type_walker
(
name
.
clone
(
)
binding
member_pointer
base
f
)
?
}
}
TypeInner
:
:
Struct
{
ref
members
.
.
}
=
>
{
let
mut
location
=
match
binding
{
crate
:
:
Binding
:
:
Location
{
location
.
.
}
=
>
location
crate
:
:
Binding
:
:
BuiltIn
(
_
)
=
>
return
Ok
(
(
)
)
}
;
for
(
i
member
)
in
members
.
clone
(
)
.
into_iter
(
)
.
enumerate
(
)
{
let
member_pointer
=
self
.
add_expression
(
Expression
:
:
AccessIndex
{
base
:
pointer
index
:
i
as
u32
}
Span
:
:
default
(
)
)
?
;
let
binding
=
match
member
.
binding
{
Some
(
binding
)
=
>
binding
None
=
>
{
let
interpolation
=
self
.
module
.
types
[
member
.
ty
]
.
inner
.
scalar_kind
(
)
.
map
(
|
kind
|
match
kind
{
ScalarKind
:
:
Float
=
>
crate
:
:
Interpolation
:
:
Perspective
_
=
>
crate
:
:
Interpolation
:
:
Flat
}
)
;
let
binding
=
crate
:
:
Binding
:
:
Location
{
location
interpolation
sampling
:
None
blend_src
:
None
}
;
location
+
=
1
;
binding
}
}
;
self
.
arg_type_walker
(
member
.
name
binding
member_pointer
member
.
ty
f
)
?
}
}
_
=
>
f
(
self
name
pointer
ty
binding
)
}
Ok
(
(
)
)
}
}
#
[
derive
(
PartialEq
Eq
Clone
Copy
Debug
)
]
enum
Conversion
{
Exact
FloatToDouble
IntToFloat
IntToDouble
Other
None
}
fn
conversion
(
target
:
&
TypeInner
source
:
&
TypeInner
)
-
>
Option
<
Conversion
>
{
use
ScalarKind
:
:
*
;
let
(
target_scalar
source_scalar
)
=
match
(
target
source
)
{
(
&
TypeInner
:
:
Scalar
(
tgt_scalar
)
&
TypeInner
:
:
Scalar
(
src_scalar
)
)
=
>
{
(
tgt_scalar
src_scalar
)
}
(
&
TypeInner
:
:
Vector
{
size
:
tgt_size
scalar
:
tgt_scalar
}
&
TypeInner
:
:
Vector
{
size
:
src_size
scalar
:
src_scalar
}
)
if
tgt_size
=
=
src_size
=
>
(
tgt_scalar
src_scalar
)
(
&
TypeInner
:
:
Matrix
{
rows
:
tgt_rows
columns
:
tgt_cols
scalar
:
tgt_scalar
}
&
TypeInner
:
:
Matrix
{
rows
:
src_rows
columns
:
src_cols
scalar
:
src_scalar
}
)
if
tgt_cols
=
=
src_cols
&
&
tgt_rows
=
=
src_rows
=
>
(
tgt_scalar
src_scalar
)
_
=
>
return
None
}
;
let
target_power
=
type_power
(
target_scalar
)
;
let
source_power
=
type_power
(
source_scalar
)
;
if
target_power
<
source_power
{
return
None
;
}
Some
(
match
(
target_scalar
source_scalar
)
{
(
Scalar
:
:
F64
Scalar
:
:
F32
)
=
>
Conversion
:
:
FloatToDouble
(
Scalar
:
:
F32
Scalar
{
kind
:
Sint
|
Uint
width
:
_
}
)
=
>
Conversion
:
:
IntToFloat
(
Scalar
:
:
F64
Scalar
{
kind
:
Sint
|
Uint
width
:
_
}
)
=
>
Conversion
:
:
IntToDouble
_
=
>
Conversion
:
:
Other
}
)
}
fn
builtin_required_variations
<
'
a
>
(
args
:
impl
Iterator
<
Item
=
&
'
a
TypeInner
>
)
-
>
BuiltinVariations
{
let
mut
variations
=
BuiltinVariations
:
:
empty
(
)
;
for
ty
in
args
{
match
*
ty
{
TypeInner
:
:
ValuePointer
{
scalar
.
.
}
|
TypeInner
:
:
Scalar
(
scalar
)
|
TypeInner
:
:
Vector
{
scalar
.
.
}
|
TypeInner
:
:
Matrix
{
scalar
.
.
}
=
>
{
if
scalar
=
=
Scalar
:
:
F64
{
variations
|
=
BuiltinVariations
:
:
DOUBLE
}
}
TypeInner
:
:
Image
{
dim
arrayed
class
}
=
>
{
if
dim
=
=
crate
:
:
ImageDimension
:
:
Cube
&
&
arrayed
{
variations
|
=
BuiltinVariations
:
:
CUBE_TEXTURES_ARRAY
}
if
dim
=
=
crate
:
:
ImageDimension
:
:
D2
&
&
arrayed
&
&
class
.
is_multisampled
(
)
{
variations
|
=
BuiltinVariations
:
:
D2_MULTI_TEXTURES_ARRAY
}
}
_
=
>
{
}
}
}
variations
}
