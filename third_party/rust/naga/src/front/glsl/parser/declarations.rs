use
crate
:
:
{
front
:
:
glsl
:
:
{
ast
:
:
{
GlobalLookup
GlobalLookupKind
Precision
StorageQualifier
StructLayout
TypeQualifier
}
context
:
:
{
Context
ExprPos
}
error
:
:
ExpectedToken
offset
token
:
:
{
Token
TokenValue
}
types
:
:
scalar_components
variables
:
:
{
GlobalOrConstant
VarDeclaration
}
Error
ErrorKind
Parser
SourceMetadata
}
Block
Expression
FunctionResult
Handle
ScalarKind
Statement
StorageClass
StructMember
Type
TypeInner
}
;
use
super
:
:
{
DeclarationContext
ParsingContext
Result
}
;
impl
<
'
source
>
ParsingContext
<
'
source
>
{
pub
fn
parse_external_declaration
(
&
mut
self
parser
:
&
mut
Parser
global_ctx
:
&
mut
Context
global_body
:
&
mut
Block
)
-
>
Result
<
(
)
>
{
if
self
.
parse_declaration
(
parser
global_ctx
global_body
true
)
?
.
is_none
(
)
{
let
token
=
self
.
bump
(
parser
)
?
;
match
token
.
value
{
TokenValue
:
:
Semicolon
if
parser
.
meta
.
version
=
=
460
=
>
Ok
(
(
)
)
_
=
>
{
let
expected
=
match
parser
.
meta
.
version
{
460
=
>
vec
!
[
TokenValue
:
:
Semicolon
.
into
(
)
ExpectedToken
:
:
Eof
]
_
=
>
vec
!
[
ExpectedToken
:
:
Eof
]
}
;
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
expected
)
meta
:
token
.
meta
}
)
}
}
}
else
{
Ok
(
(
)
)
}
}
pub
fn
parse_initializer
(
&
mut
self
parser
:
&
mut
Parser
ty
:
Handle
<
Type
>
ctx
:
&
mut
Context
body
:
&
mut
Block
)
-
>
Result
<
(
Handle
<
Expression
>
SourceMetadata
)
>
{
if
let
Some
(
Token
{
mut
meta
.
.
}
)
=
self
.
bump_if
(
parser
TokenValue
:
:
LeftBrace
)
{
let
mut
components
=
Vec
:
:
new
(
)
;
loop
{
components
.
push
(
self
.
parse_initializer
(
parser
ty
ctx
body
)
?
.
0
)
;
let
token
=
self
.
bump
(
parser
)
?
;
match
token
.
value
{
TokenValue
:
:
Comma
=
>
{
if
let
Some
(
Token
{
meta
:
end_meta
.
.
}
)
=
self
.
bump_if
(
parser
TokenValue
:
:
RightBrace
)
{
meta
=
meta
.
union
(
&
end_meta
)
;
break
;
}
}
TokenValue
:
:
RightBrace
=
>
{
meta
=
meta
.
union
(
&
token
.
meta
)
;
break
;
}
_
=
>
{
return
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
TokenValue
:
:
Comma
.
into
(
)
TokenValue
:
:
RightBrace
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
}
}
Ok
(
(
ctx
.
add_expression
(
Expression
:
:
Compose
{
ty
components
}
meta
body
)
meta
)
)
}
else
{
let
mut
stmt
=
ctx
.
stmt_ctx
(
)
;
let
expr
=
self
.
parse_assignment
(
parser
ctx
&
mut
stmt
body
)
?
;
let
(
mut
init
init_meta
)
=
ctx
.
lower_expect
(
stmt
parser
expr
ExprPos
:
:
Rhs
body
)
?
;
let
scalar_components
=
scalar_components
(
&
parser
.
module
.
types
[
ty
]
.
inner
)
;
if
let
Some
(
(
kind
width
)
)
=
scalar_components
{
ctx
.
implicit_conversion
(
parser
&
mut
init
init_meta
kind
width
)
?
;
}
Ok
(
(
init
init_meta
)
)
}
}
pub
fn
parse_init_declarator_list
(
&
mut
self
parser
:
&
mut
Parser
ty
:
Handle
<
Type
>
mut
fallthrough
:
Option
<
Token
>
ctx
:
&
mut
DeclarationContext
)
-
>
Result
<
(
)
>
{
if
fallthrough
.
as_ref
(
)
.
or_else
(
|
|
self
.
peek
(
parser
)
)
.
filter
(
|
t
|
t
.
value
=
=
TokenValue
:
:
Comma
)
.
is_some
(
)
{
fallthrough
.
take
(
)
.
or_else
(
|
|
self
.
next
(
parser
)
)
;
}
loop
{
let
token
=
fallthrough
.
take
(
)
.
ok_or
(
ErrorKind
:
:
EndOfFile
)
.
or_else
(
|
_
|
self
.
bump
(
parser
)
)
?
;
let
name
=
match
token
.
value
{
TokenValue
:
:
Semicolon
=
>
break
TokenValue
:
:
Identifier
(
name
)
=
>
name
_
=
>
{
return
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
ExpectedToken
:
:
Identifier
TokenValue
:
:
Semicolon
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
}
;
let
mut
meta
=
token
.
meta
;
let
array_specifier
=
self
.
parse_array_specifier
(
parser
)
?
;
let
ty
=
parser
.
maybe_array
(
ty
meta
array_specifier
)
;
let
init
=
self
.
bump_if
(
parser
TokenValue
:
:
Assign
)
.
map
:
:
<
Result
<
_
>
_
>
(
|
_
|
{
let
(
mut
expr
init_meta
)
=
self
.
parse_initializer
(
parser
ty
ctx
.
ctx
ctx
.
body
)
?
;
let
scalar_components
=
scalar_components
(
&
parser
.
module
.
types
[
ty
]
.
inner
)
;
if
let
Some
(
(
kind
width
)
)
=
scalar_components
{
ctx
.
ctx
.
implicit_conversion
(
parser
&
mut
expr
init_meta
kind
width
)
?
;
}
meta
=
meta
.
union
(
&
init_meta
)
;
Ok
(
(
expr
init_meta
)
)
}
)
.
transpose
(
)
?
;
let
maybe_constant
=
init
.
and_then
(
|
(
root
meta
)
|
parser
.
solve_constant
(
ctx
.
ctx
root
meta
)
.
ok
(
)
)
;
let
pointer
=
ctx
.
add_var
(
parser
ty
name
maybe_constant
meta
)
?
;
if
let
Some
(
(
value
_
)
)
=
init
.
filter
(
|
_
|
maybe_constant
.
is_none
(
)
)
{
ctx
.
flush_expressions
(
)
;
ctx
.
body
.
push
(
Statement
:
:
Store
{
pointer
value
}
meta
.
as_span
(
)
)
;
}
let
token
=
self
.
bump
(
parser
)
?
;
match
token
.
value
{
TokenValue
:
:
Semicolon
=
>
break
TokenValue
:
:
Comma
=
>
{
}
_
=
>
{
return
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
TokenValue
:
:
Comma
.
into
(
)
TokenValue
:
:
Semicolon
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
}
}
Ok
(
(
)
)
}
pub
fn
parse_declaration
(
&
mut
self
parser
:
&
mut
Parser
ctx
:
&
mut
Context
body
:
&
mut
Block
external
:
bool
)
-
>
Result
<
Option
<
SourceMetadata
>
>
{
if
self
.
peek_type_qualifier
(
parser
)
|
|
self
.
peek_type_name
(
parser
)
{
let
qualifiers
=
self
.
parse_type_qualifiers
(
parser
)
?
;
if
self
.
peek_type_name
(
parser
)
{
let
(
ty
mut
meta
)
=
self
.
parse_type
(
parser
)
?
;
let
token
=
self
.
bump
(
parser
)
?
;
let
token_fallthrough
=
match
token
.
value
{
TokenValue
:
:
Identifier
(
name
)
=
>
match
self
.
expect_peek
(
parser
)
?
.
value
{
TokenValue
:
:
LeftParen
=
>
{
self
.
bump
(
parser
)
?
;
let
result
=
ty
.
map
(
|
ty
|
FunctionResult
{
ty
binding
:
None
}
)
;
let
mut
body
=
Block
:
:
new
(
)
;
let
mut
context
=
Context
:
:
new
(
parser
&
mut
body
)
;
self
.
parse_function_args
(
parser
&
mut
context
&
mut
body
)
?
;
let
end_meta
=
self
.
expect
(
parser
TokenValue
:
:
RightParen
)
?
.
meta
;
meta
=
meta
.
union
(
&
end_meta
)
;
let
token
=
self
.
bump
(
parser
)
?
;
return
match
token
.
value
{
TokenValue
:
:
Semicolon
=
>
{
parser
.
add_prototype
(
context
name
result
meta
)
;
Ok
(
Some
(
meta
)
)
}
TokenValue
:
:
LeftBrace
if
external
=
>
{
self
.
parse_compound_statement
(
token
.
meta
parser
&
mut
context
&
mut
body
)
?
;
parser
.
add_function
(
context
name
result
body
meta
)
;
Ok
(
Some
(
meta
)
)
}
_
if
external
=
>
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
TokenValue
:
:
LeftBrace
.
into
(
)
TokenValue
:
:
Semicolon
.
into
(
)
]
)
meta
:
token
.
meta
}
)
_
=
>
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
TokenValue
:
:
Semicolon
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
;
}
_
=
>
Token
{
value
:
TokenValue
:
:
Identifier
(
name
)
meta
:
token
.
meta
}
}
_
=
>
token
}
;
if
let
Some
(
ty
)
=
ty
{
let
mut
ctx
=
DeclarationContext
{
qualifiers
external
ctx
body
}
;
self
.
parse_init_declarator_list
(
parser
ty
Some
(
token_fallthrough
)
&
mut
ctx
)
?
;
}
else
{
parser
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Declaration
cannot
have
void
type
"
.
into
(
)
)
meta
}
)
}
Ok
(
Some
(
meta
)
)
}
else
{
let
token
=
self
.
bump
(
parser
)
?
;
match
token
.
value
{
TokenValue
:
:
Identifier
(
ty_name
)
=
>
{
if
self
.
bump_if
(
parser
TokenValue
:
:
LeftBrace
)
.
is_some
(
)
{
self
.
parse_block_declaration
(
parser
ctx
body
&
qualifiers
ty_name
token
.
meta
)
.
map
(
Some
)
}
else
{
Err
(
Error
{
kind
:
ErrorKind
:
:
NotImplemented
(
"
variable
qualifier
"
)
meta
:
token
.
meta
}
)
}
}
TokenValue
:
:
Semicolon
=
>
{
let
mut
meta_all
=
token
.
meta
;
for
&
(
ref
qualifier
meta
)
in
qualifiers
.
iter
(
)
{
meta_all
=
meta_all
.
union
(
&
meta
)
;
match
*
qualifier
{
TypeQualifier
:
:
WorkGroupSize
(
i
value
)
=
>
{
parser
.
meta
.
workgroup_size
[
i
]
=
value
}
TypeQualifier
:
:
EarlyFragmentTests
=
>
{
parser
.
meta
.
early_fragment_tests
=
true
;
}
TypeQualifier
:
:
StorageQualifier
(
_
)
=
>
{
}
_
=
>
{
parser
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Qualifier
not
supported
as
standalone
"
.
into
(
)
)
meta
}
)
;
}
}
}
Ok
(
Some
(
meta_all
)
)
}
_
=
>
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
ExpectedToken
:
:
Identifier
TokenValue
:
:
Semicolon
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
}
}
else
{
match
self
.
peek
(
parser
)
.
map
(
|
t
|
&
t
.
value
)
{
Some
(
&
TokenValue
:
:
Precision
)
=
>
{
self
.
bump
(
parser
)
?
;
let
token
=
self
.
bump
(
parser
)
?
;
let
_
=
match
token
.
value
{
TokenValue
:
:
PrecisionQualifier
(
p
)
=
>
p
_
=
>
{
return
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
TokenValue
:
:
PrecisionQualifier
(
Precision
:
:
High
)
.
into
(
)
TokenValue
:
:
PrecisionQualifier
(
Precision
:
:
Medium
)
.
into
(
)
TokenValue
:
:
PrecisionQualifier
(
Precision
:
:
Low
)
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
}
;
let
(
ty
meta
)
=
self
.
parse_type_non_void
(
parser
)
?
;
match
parser
.
module
.
types
[
ty
]
.
inner
{
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Float
.
.
}
|
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Sint
.
.
}
=
>
{
}
_
=
>
parser
.
errors
.
push
(
Error
{
kind
:
ErrorKind
:
:
SemanticError
(
"
Precision
statement
can
only
work
on
floats
and
ints
"
.
into
(
)
)
meta
}
)
}
self
.
expect
(
parser
TokenValue
:
:
Semicolon
)
?
;
Ok
(
Some
(
meta
)
)
}
_
=
>
Ok
(
None
)
}
}
}
pub
fn
parse_block_declaration
(
&
mut
self
parser
:
&
mut
Parser
ctx
:
&
mut
Context
body
:
&
mut
Block
qualifiers
:
&
[
(
TypeQualifier
SourceMetadata
)
]
ty_name
:
String
meta
:
SourceMetadata
)
-
>
Result
<
SourceMetadata
>
{
let
mut
storage
=
None
;
let
mut
layout
=
None
;
for
&
(
ref
qualifier
_
)
in
qualifiers
{
match
*
qualifier
{
TypeQualifier
:
:
StorageQualifier
(
StorageQualifier
:
:
StorageClass
(
c
)
)
=
>
{
storage
=
Some
(
c
)
}
TypeQualifier
:
:
Layout
(
l
)
=
>
layout
=
Some
(
l
)
_
=
>
continue
}
}
let
layout
=
match
(
layout
storage
)
{
(
Some
(
layout
)
_
)
=
>
layout
(
None
Some
(
StorageClass
:
:
Storage
{
.
.
}
)
)
=
>
StructLayout
:
:
Std430
_
=
>
StructLayout
:
:
Std140
}
;
let
mut
members
=
Vec
:
:
new
(
)
;
let
span
=
self
.
parse_struct_declaration_list
(
parser
&
mut
members
layout
)
?
;
self
.
expect
(
parser
TokenValue
:
:
RightBrace
)
?
;
let
mut
ty
=
parser
.
module
.
types
.
append
(
Type
{
name
:
Some
(
ty_name
)
inner
:
TypeInner
:
:
Struct
{
top_level
:
true
members
:
members
.
clone
(
)
span
}
}
Default
:
:
default
(
)
)
;
let
token
=
self
.
bump
(
parser
)
?
;
let
name
=
match
token
.
value
{
TokenValue
:
:
Semicolon
=
>
None
TokenValue
:
:
Identifier
(
name
)
=
>
{
let
array_specifier
=
self
.
parse_array_specifier
(
parser
)
?
;
ty
=
parser
.
maybe_array
(
ty
token
.
meta
array_specifier
)
;
self
.
expect
(
parser
TokenValue
:
:
Semicolon
)
?
;
Some
(
name
)
}
_
=
>
{
return
Err
(
Error
{
kind
:
ErrorKind
:
:
InvalidToken
(
token
.
value
vec
!
[
ExpectedToken
:
:
Identifier
TokenValue
:
:
Semicolon
.
into
(
)
]
)
meta
:
token
.
meta
}
)
}
}
;
let
global
=
parser
.
add_global_var
(
ctx
body
VarDeclaration
{
qualifiers
ty
name
init
:
None
meta
}
)
?
;
for
(
i
k
)
in
members
.
into_iter
(
)
.
enumerate
(
)
.
filter_map
(
|
(
i
m
)
|
m
.
name
.
map
(
|
s
|
(
i
as
u32
s
)
)
)
{
let
lookup
=
GlobalLookup
{
kind
:
match
global
{
GlobalOrConstant
:
:
Global
(
handle
)
=
>
GlobalLookupKind
:
:
BlockSelect
(
handle
i
)
GlobalOrConstant
:
:
Constant
(
handle
)
=
>
GlobalLookupKind
:
:
Constant
(
handle
)
}
entry_arg
:
None
mutable
:
true
}
;
ctx
.
add_global
(
parser
&
k
lookup
body
)
;
parser
.
global_variables
.
push
(
(
k
lookup
)
)
;
}
Ok
(
meta
)
}
pub
fn
parse_struct_declaration_list
(
&
mut
self
parser
:
&
mut
Parser
members
:
&
mut
Vec
<
StructMember
>
layout
:
StructLayout
)
-
>
Result
<
u32
>
{
let
mut
span
=
0
;
let
mut
align
=
0
;
loop
{
let
(
ty
mut
meta
)
=
self
.
parse_type_non_void
(
parser
)
?
;
let
(
name
end_meta
)
=
self
.
expect_ident
(
parser
)
?
;
meta
=
meta
.
union
(
&
end_meta
)
;
let
array_specifier
=
self
.
parse_array_specifier
(
parser
)
?
;
let
ty
=
parser
.
maybe_array
(
ty
meta
array_specifier
)
;
self
.
expect
(
parser
TokenValue
:
:
Semicolon
)
?
;
let
info
=
offset
:
:
calculate_offset
(
ty
meta
layout
&
mut
parser
.
module
.
types
&
parser
.
module
.
constants
&
mut
parser
.
errors
)
;
span
=
offset
:
:
align_up
(
span
info
.
align
)
;
align
=
align
.
max
(
info
.
align
)
;
members
.
push
(
StructMember
{
name
:
Some
(
name
)
ty
:
info
.
ty
binding
:
None
offset
:
span
}
)
;
span
+
=
info
.
span
;
if
let
TokenValue
:
:
RightBrace
=
self
.
expect_peek
(
parser
)
?
.
value
{
break
;
}
}
span
=
offset
:
:
align_up
(
span
align
)
;
Ok
(
span
)
}
}
