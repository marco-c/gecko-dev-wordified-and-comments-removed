use
super
:
:
ProcError
;
use
crate
:
:
valid
;
use
crate
:
:
{
Handle
UniqueArena
}
;
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
BoundsCheckPolicy
{
Restrict
ReadZeroSkipWrite
Unchecked
}
#
[
derive
(
Clone
Copy
Debug
Default
)
]
pub
struct
BoundsCheckPolicies
{
pub
index
:
BoundsCheckPolicy
pub
buffer
:
BoundsCheckPolicy
pub
image
:
BoundsCheckPolicy
}
impl
Default
for
BoundsCheckPolicy
{
fn
default
(
)
-
>
Self
{
BoundsCheckPolicy
:
:
Unchecked
}
}
impl
BoundsCheckPolicies
{
pub
fn
choose_policy
(
&
self
pointer
:
Handle
<
crate
:
:
Expression
>
types
:
&
UniqueArena
<
crate
:
:
Type
>
info
:
&
valid
:
:
FunctionInfo
)
-
>
BoundsCheckPolicy
{
let
is_buffer
=
match
info
[
pointer
]
.
ty
.
inner_with
(
types
)
.
pointer_class
(
)
{
Some
(
crate
:
:
StorageClass
:
:
Storage
{
access
:
_
}
)
|
Some
(
crate
:
:
StorageClass
:
:
Uniform
)
=
>
true
_
=
>
false
}
;
if
is_buffer
{
self
.
buffer
}
else
{
self
.
index
}
}
}
impl
crate
:
:
TypeInner
{
pub
fn
indexable_length
(
&
self
module
:
&
crate
:
:
Module
)
-
>
Result
<
IndexableLength
ProcError
>
{
use
crate
:
:
TypeInner
as
Ti
;
let
known_length
=
match
*
self
{
Ti
:
:
Vector
{
size
.
.
}
=
>
size
as
_
Ti
:
:
Matrix
{
columns
.
.
}
=
>
columns
as
_
Ti
:
:
Array
{
size
.
.
}
=
>
{
return
size
.
to_indexable_length
(
module
)
;
}
Ti
:
:
ValuePointer
{
size
:
Some
(
size
)
.
.
}
=
>
size
as
_
Ti
:
:
Pointer
{
base
.
.
}
=
>
{
let
base_inner
=
&
module
.
types
[
base
]
.
inner
;
match
*
base_inner
{
Ti
:
:
Vector
{
size
.
.
}
=
>
size
as
_
Ti
:
:
Matrix
{
columns
.
.
}
=
>
columns
as
_
Ti
:
:
Array
{
size
.
.
}
=
>
return
size
.
to_indexable_length
(
module
)
_
=
>
return
Err
(
ProcError
:
:
TypeNotIndexable
)
}
}
_
=
>
return
Err
(
ProcError
:
:
TypeNotIndexable
)
}
;
Ok
(
IndexableLength
:
:
Known
(
known_length
)
)
}
}
pub
enum
IndexableLength
{
Known
(
u32
)
Dynamic
}
impl
crate
:
:
ArraySize
{
pub
fn
to_indexable_length
(
self
module
:
&
crate
:
:
Module
)
-
>
Result
<
IndexableLength
ProcError
>
{
use
crate
:
:
Constant
as
K
;
Ok
(
match
self
{
Self
:
:
Constant
(
k
)
=
>
match
module
.
constants
[
k
]
{
K
{
specialization
:
Some
(
_
)
.
.
}
=
>
{
return
Err
(
ProcError
:
:
InvalidArraySizeConstant
(
k
)
)
;
}
ref
unspecialized
=
>
{
let
length
=
unspecialized
.
to_array_length
(
)
.
ok_or
(
ProcError
:
:
InvalidArraySizeConstant
(
k
)
)
?
;
IndexableLength
:
:
Known
(
length
)
}
}
Self
:
:
Dynamic
=
>
IndexableLength
:
:
Dynamic
}
)
}
}
