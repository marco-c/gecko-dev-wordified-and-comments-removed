pub
use
crate
:
:
{
Arena
Handle
}
;
impl
crate
:
:
Module
{
pub
fn
apply_common_default_interpolation
(
&
mut
self
)
{
use
crate
:
:
{
Binding
ScalarKind
Type
TypeInner
}
;
fn
default_binding_or_struct
(
binding
:
&
mut
Option
<
Binding
>
ty
:
Handle
<
Type
>
types
:
&
mut
Arena
<
Type
>
)
{
let
inner
=
&
mut
types
.
get_mut
(
ty
)
.
inner
;
if
let
TypeInner
:
:
Struct
{
members
:
ref
mut
m
.
.
}
=
*
inner
{
use
std
:
:
mem
;
let
mut
members
=
mem
:
:
take
(
m
)
;
for
member
in
&
mut
members
{
default_binding_or_struct
(
&
mut
member
.
binding
member
.
ty
types
)
;
}
match
types
.
get_mut
(
ty
)
.
inner
{
TypeInner
:
:
Struct
{
members
:
ref
mut
m
.
.
}
=
>
mem
:
:
replace
(
m
members
)
_
=
>
unreachable
!
(
"
ty
must
be
a
struct
"
)
}
;
return
;
}
let
binding
=
match
binding
.
as_mut
(
)
{
None
=
>
return
Some
(
binding
)
=
>
binding
}
;
match
*
inner
{
TypeInner
:
:
Scalar
{
kind
:
ScalarKind
:
:
Float
width
:
4
}
|
TypeInner
:
:
Vector
{
kind
:
ScalarKind
:
:
Float
width
:
4
.
.
}
=
>
{
if
let
Binding
:
:
Location
{
ref
mut
interpolation
ref
mut
sampling
.
.
}
=
*
binding
{
if
interpolation
.
is_none
(
)
{
*
interpolation
=
Some
(
crate
:
:
Interpolation
:
:
Perspective
)
;
}
if
sampling
.
is_none
(
)
&
&
*
interpolation
!
=
Some
(
crate
:
:
Interpolation
:
:
Flat
)
{
*
sampling
=
Some
(
crate
:
:
Sampling
:
:
Center
)
;
}
}
}
_
=
>
{
if
let
Binding
:
:
Location
{
ref
mut
interpolation
ref
mut
sampling
.
.
}
=
*
binding
{
*
interpolation
=
Some
(
crate
:
:
Interpolation
:
:
Flat
)
;
*
sampling
=
None
;
}
}
}
}
for
ep
in
&
mut
self
.
entry_points
{
let
function
=
&
mut
ep
.
function
;
match
ep
.
stage
{
crate
:
:
ShaderStage
:
:
Fragment
=
>
{
for
arg
in
&
mut
function
.
arguments
{
default_binding_or_struct
(
&
mut
arg
.
binding
arg
.
ty
&
mut
self
.
types
)
;
}
}
crate
:
:
ShaderStage
:
:
Vertex
=
>
{
if
let
Some
(
result
)
=
function
.
result
.
as_mut
(
)
{
default_binding_or_struct
(
&
mut
result
.
binding
result
.
ty
&
mut
self
.
types
)
;
}
}
_
=
>
(
)
}
}
}
}
