use
core
:
:
{
fmt
hash
}
;
use
crate
:
:
racy_lock
:
:
RacyLock
;
use
crate
:
:
FastHashSet
;
#
[
derive
(
Clone
Debug
Default
Eq
PartialEq
)
]
pub
struct
KeywordSet
(
FastHashSet
<
&
'
static
str
>
)
;
impl
KeywordSet
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
empty
(
)
-
>
&
'
static
Self
{
static
EMPTY
:
RacyLock
<
KeywordSet
>
=
RacyLock
:
:
new
(
Default
:
:
default
)
;
&
EMPTY
}
#
[
inline
]
pub
fn
contains
(
&
self
identifier
:
&
str
)
-
>
bool
{
self
.
0
.
contains
(
identifier
)
}
}
impl
Default
for
&
'
static
KeywordSet
{
fn
default
(
)
-
>
Self
{
KeywordSet
:
:
empty
(
)
}
}
impl
FromIterator
<
&
'
static
str
>
for
KeywordSet
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
&
'
static
str
>
>
(
iter
:
T
)
-
>
Self
{
Self
(
iter
.
into_iter
(
)
.
collect
(
)
)
}
}
impl
<
'
a
>
FromIterator
<
&
'
a
&
'
static
str
>
for
KeywordSet
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
&
'
a
&
'
static
str
>
>
(
iter
:
T
)
-
>
Self
{
Self
:
:
from_iter
(
iter
.
into_iter
(
)
.
copied
(
)
)
}
}
impl
Extend
<
&
'
static
str
>
for
KeywordSet
{
#
[
expect
(
clippy
:
:
useless_conversion
reason
=
"
doing
.
into_iter
(
)
sooner
reduces
distinct
monomorphizations
"
)
]
fn
extend
<
T
:
IntoIterator
<
Item
=
&
'
static
str
>
>
(
&
mut
self
iter
:
T
)
{
self
.
0
.
extend
(
iter
.
into_iter
(
)
)
}
}
impl
<
'
a
>
Extend
<
&
'
a
&
'
static
str
>
for
KeywordSet
{
fn
extend
<
T
:
IntoIterator
<
Item
=
&
'
a
&
'
static
str
>
>
(
&
mut
self
iter
:
T
)
{
self
.
extend
(
iter
.
into_iter
(
)
.
copied
(
)
)
}
}
#
[
derive
(
Clone
Debug
Default
Eq
PartialEq
)
]
pub
struct
CaseInsensitiveKeywordSet
(
FastHashSet
<
AsciiUniCase
<
&
'
static
str
>
>
)
;
impl
CaseInsensitiveKeywordSet
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
empty
(
)
-
>
&
'
static
Self
{
static
EMPTY
:
RacyLock
<
CaseInsensitiveKeywordSet
>
=
RacyLock
:
:
new
(
Default
:
:
default
)
;
&
EMPTY
}
#
[
inline
]
pub
fn
contains
(
&
self
identifier
:
&
str
)
-
>
bool
{
self
.
0
.
contains
(
&
AsciiUniCase
(
identifier
)
)
}
}
impl
Default
for
&
'
static
CaseInsensitiveKeywordSet
{
fn
default
(
)
-
>
Self
{
CaseInsensitiveKeywordSet
:
:
empty
(
)
}
}
impl
FromIterator
<
&
'
static
str
>
for
CaseInsensitiveKeywordSet
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
&
'
static
str
>
>
(
iter
:
T
)
-
>
Self
{
Self
(
iter
.
into_iter
(
)
.
inspect
(
debug_assert_ascii
)
.
map
(
AsciiUniCase
)
.
collect
(
)
)
}
}
impl
<
'
a
>
FromIterator
<
&
'
a
&
'
static
str
>
for
CaseInsensitiveKeywordSet
{
fn
from_iter
<
T
:
IntoIterator
<
Item
=
&
'
a
&
'
static
str
>
>
(
iter
:
T
)
-
>
Self
{
Self
:
:
from_iter
(
iter
.
into_iter
(
)
.
copied
(
)
)
}
}
impl
Extend
<
&
'
static
str
>
for
CaseInsensitiveKeywordSet
{
fn
extend
<
T
:
IntoIterator
<
Item
=
&
'
static
str
>
>
(
&
mut
self
iter
:
T
)
{
self
.
0
.
extend
(
iter
.
into_iter
(
)
.
inspect
(
debug_assert_ascii
)
.
map
(
AsciiUniCase
)
)
}
}
impl
<
'
a
>
Extend
<
&
'
a
&
'
static
str
>
for
CaseInsensitiveKeywordSet
{
fn
extend
<
T
:
IntoIterator
<
Item
=
&
'
a
&
'
static
str
>
>
(
&
mut
self
iter
:
T
)
{
self
.
extend
(
iter
.
into_iter
(
)
.
copied
(
)
)
}
}
#
[
derive
(
Clone
Copy
)
]
struct
AsciiUniCase
<
S
:
AsRef
<
str
>
+
?
Sized
>
(
S
)
;
impl
<
S
:
?
Sized
+
AsRef
<
str
>
>
fmt
:
:
Debug
for
AsciiUniCase
<
S
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
0
.
as_ref
(
)
.
fmt
(
f
)
}
}
impl
<
S
:
AsRef
<
str
>
>
PartialEq
<
Self
>
for
AsciiUniCase
<
S
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
0
.
as_ref
(
)
.
eq_ignore_ascii_case
(
other
.
0
.
as_ref
(
)
)
}
}
impl
<
S
:
AsRef
<
str
>
>
Eq
for
AsciiUniCase
<
S
>
{
}
impl
<
S
:
AsRef
<
str
>
>
hash
:
:
Hash
for
AsciiUniCase
<
S
>
{
#
[
inline
]
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
hasher
:
&
mut
H
)
{
for
byte
in
self
.
0
.
as_ref
(
)
.
as_bytes
(
)
.
iter
(
)
.
map
(
|
b
|
b
.
to_ascii_lowercase
(
)
)
{
hasher
.
write_u8
(
byte
)
;
}
}
}
fn
debug_assert_ascii
(
s
:
&
&
'
static
str
)
{
debug_assert
!
(
s
.
is_ascii
(
)
"
{
s
:
?
}
not
ASCII
"
)
}
