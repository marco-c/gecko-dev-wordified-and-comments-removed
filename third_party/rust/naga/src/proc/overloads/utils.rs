use
crate
:
:
ir
;
use
crate
:
:
proc
:
:
overloads
:
:
list
:
:
List
;
use
crate
:
:
proc
:
:
overloads
:
:
rule
:
:
{
Conclusion
Rule
}
;
use
crate
:
:
proc
:
:
TypeResolution
;
use
alloc
:
:
vec
:
:
Vec
;
pub
fn
vector_sizes
(
)
-
>
impl
Iterator
<
Item
=
ir
:
:
VectorSize
>
+
Clone
{
static
SIZES
:
[
ir
:
:
VectorSize
;
3
]
=
[
ir
:
:
VectorSize
:
:
Bi
ir
:
:
VectorSize
:
:
Tri
ir
:
:
VectorSize
:
:
Quad
]
;
SIZES
.
iter
(
)
.
cloned
(
)
}
pub
fn
float_scalars
(
)
-
>
impl
Iterator
<
Item
=
ir
:
:
Scalar
>
+
Clone
{
[
ir
:
:
Scalar
:
:
ABSTRACT_FLOAT
ir
:
:
Scalar
:
:
F32
ir
:
:
Scalar
:
:
F16
ir
:
:
Scalar
:
:
F64
]
.
into_iter
(
)
}
pub
fn
float_scalars_unimplemented_abstract
(
)
-
>
impl
Iterator
<
Item
=
ir
:
:
Scalar
>
+
Clone
{
[
ir
:
:
Scalar
:
:
F32
ir
:
:
Scalar
:
:
F16
ir
:
:
Scalar
:
:
F64
]
.
into_iter
(
)
}
pub
fn
concrete_int_scalars
(
)
-
>
impl
Iterator
<
Item
=
ir
:
:
Scalar
>
{
[
ir
:
:
Scalar
:
:
I32
ir
:
:
Scalar
:
:
U32
ir
:
:
Scalar
:
:
I64
ir
:
:
Scalar
:
:
U64
]
.
into_iter
(
)
}
pub
fn
scalar_or_vecn
(
scalar
:
ir
:
:
Scalar
)
-
>
impl
Iterator
<
Item
=
ir
:
:
TypeInner
>
{
[
ir
:
:
TypeInner
:
:
Scalar
(
scalar
)
ir
:
:
TypeInner
:
:
Vector
{
size
:
ir
:
:
VectorSize
:
:
Bi
scalar
}
ir
:
:
TypeInner
:
:
Vector
{
size
:
ir
:
:
VectorSize
:
:
Tri
scalar
}
ir
:
:
TypeInner
:
:
Vector
{
size
:
ir
:
:
VectorSize
:
:
Quad
scalar
}
]
.
into_iter
(
)
}
pub
fn
rule
<
const
N
:
usize
>
(
args
:
[
ir
:
:
TypeInner
;
N
]
ret
:
ir
:
:
TypeInner
)
-
>
Rule
{
Rule
{
arguments
:
Vec
:
:
from_iter
(
args
.
into_iter
(
)
.
map
(
TypeResolution
:
:
Value
)
)
conclusion
:
Conclusion
:
:
Value
(
ret
)
}
}
pub
fn
list
(
rules
:
impl
Iterator
<
Item
=
Rule
>
)
-
>
List
{
List
:
:
from_rules
(
rules
.
collect
(
)
)
}
pub
fn
pairs
<
T
:
Clone
U
>
(
left
:
impl
Iterator
<
Item
=
T
>
right
:
impl
Iterator
<
Item
=
U
>
+
Clone
)
-
>
impl
Iterator
<
Item
=
(
T
U
)
>
{
left
.
flat_map
(
move
|
t
|
right
.
clone
(
)
.
map
(
move
|
u
|
(
t
.
clone
(
)
u
)
)
)
}
pub
fn
triples
<
T
:
Clone
U
:
Clone
V
>
(
left
:
impl
Iterator
<
Item
=
T
>
middle
:
impl
Iterator
<
Item
=
U
>
+
Clone
right
:
impl
Iterator
<
Item
=
V
>
+
Clone
)
-
>
impl
Iterator
<
Item
=
(
T
U
V
)
>
{
left
.
flat_map
(
move
|
t
|
{
let
right
=
right
.
clone
(
)
;
middle
.
clone
(
)
.
flat_map
(
move
|
u
|
{
let
t
=
t
.
clone
(
)
;
right
.
clone
(
)
.
map
(
move
|
v
|
(
t
.
clone
(
)
u
.
clone
(
)
v
)
)
}
)
}
)
}
