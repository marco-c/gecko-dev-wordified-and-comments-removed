#
!
[
allow
(
clippy
:
:
new_without_default
clippy
:
:
unneeded_field_pattern
clippy
:
:
match_like_matches_macro
clippy
:
:
if_same_then_else
)
]
#
!
[
warn
(
trivial_casts
trivial_numeric_casts
unused_extern_crates
unused_qualifications
clippy
:
:
pattern_type_mismatch
clippy
:
:
missing_const_for_fn
)
]
#
!
[
deny
(
clippy
:
:
panic
)
]
mod
arena
;
pub
mod
back
;
mod
block
;
pub
mod
front
;
pub
mod
keywords
;
pub
mod
proc
;
mod
span
;
pub
mod
valid
;
pub
use
crate
:
:
arena
:
:
{
Arena
Handle
Range
UniqueArena
}
;
pub
use
crate
:
:
span
:
:
{
Span
SpanContext
WithSpan
}
;
#
[
cfg
(
feature
=
"
arbitrary
"
)
]
use
arbitrary
:
:
Arbitrary
;
#
[
cfg
(
feature
=
"
deserialize
"
)
]
use
serde
:
:
Deserialize
;
#
[
cfg
(
feature
=
"
serialize
"
)
]
use
serde
:
:
Serialize
;
pub
const
BOOL_WIDTH
:
Bytes
=
1
;
pub
type
FastHashMap
<
K
T
>
=
rustc_hash
:
:
FxHashMap
<
K
T
>
;
pub
type
FastHashSet
<
K
>
=
rustc_hash
:
:
FxHashSet
<
K
>
;
pub
(
crate
)
type
NamedExpressions
=
FastHashMap
<
Handle
<
Expression
>
String
>
;
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
EarlyDepthTest
{
conservative
:
Option
<
ConservativeDepth
>
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ConservativeDepth
{
GreaterEqual
LessEqual
Unchanged
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
ShaderStage
{
Vertex
Fragment
Compute
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
AddressSpace
{
Function
Private
WorkGroup
Uniform
Storage
{
access
:
StorageAccess
}
Handle
PushConstant
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
BuiltIn
{
Position
{
invariant
:
bool
}
ViewIndex
BaseInstance
BaseVertex
ClipDistance
CullDistance
InstanceIndex
PointSize
VertexIndex
FragDepth
FrontFacing
PrimitiveIndex
SampleIndex
SampleMask
GlobalInvocationId
LocalInvocationId
LocalInvocationIndex
WorkGroupId
WorkGroupSize
NumWorkGroups
}
pub
type
Bytes
=
u8
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
VectorSize
{
Bi
=
2
Tri
=
3
Quad
=
4
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ScalarKind
{
Sint
Uint
Float
Bool
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ArraySize
{
Constant
(
Handle
<
Constant
>
)
Dynamic
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Interpolation
{
Perspective
Linear
Flat
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Sampling
{
Center
Centroid
Sample
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
StructMember
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
binding
:
Option
<
Binding
>
pub
offset
:
u32
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ImageDimension
{
D1
D2
D3
Cube
}
bitflags
:
:
bitflags
!
{
/
/
/
Flags
describing
an
image
.
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
derive
(
Default
)
]
pub
struct
StorageAccess
:
u32
{
/
/
/
Storage
can
be
used
as
a
source
for
load
ops
.
const
LOAD
=
0x1
;
/
/
/
Storage
can
be
used
as
a
target
for
store
ops
.
const
STORE
=
0x2
;
}
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
StorageFormat
{
R8Unorm
R8Snorm
R8Uint
R8Sint
R16Uint
R16Sint
R16Float
Rg8Unorm
Rg8Snorm
Rg8Uint
Rg8Sint
R32Uint
R32Sint
R32Float
Rg16Uint
Rg16Sint
Rg16Float
Rgba8Unorm
Rgba8Snorm
Rgba8Uint
Rgba8Sint
Rgb10a2Unorm
Rg11b10Float
Rg32Uint
Rg32Sint
Rg32Float
Rgba16Uint
Rgba16Sint
Rgba16Float
Rgba32Uint
Rgba32Sint
Rgba32Float
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ImageClass
{
Sampled
{
kind
:
ScalarKind
multi
:
bool
}
Depth
{
multi
:
bool
}
Storage
{
format
:
StorageFormat
access
:
StorageAccess
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Type
{
pub
name
:
Option
<
String
>
pub
inner
:
TypeInner
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
TypeInner
{
Scalar
{
kind
:
ScalarKind
width
:
Bytes
}
Vector
{
size
:
VectorSize
kind
:
ScalarKind
width
:
Bytes
}
Matrix
{
columns
:
VectorSize
rows
:
VectorSize
width
:
Bytes
}
Atomic
{
kind
:
ScalarKind
width
:
Bytes
}
Pointer
{
base
:
Handle
<
Type
>
space
:
AddressSpace
}
ValuePointer
{
size
:
Option
<
VectorSize
>
kind
:
ScalarKind
width
:
Bytes
space
:
AddressSpace
}
Array
{
base
:
Handle
<
Type
>
size
:
ArraySize
stride
:
u32
}
Struct
{
members
:
Vec
<
StructMember
>
span
:
u32
}
Image
{
dim
:
ImageDimension
arrayed
:
bool
class
:
ImageClass
}
Sampler
{
comparison
:
bool
}
BindingArray
{
base
:
Handle
<
Type
>
size
:
ArraySize
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Constant
{
pub
name
:
Option
<
String
>
pub
specialization
:
Option
<
u32
>
pub
inner
:
ConstantInner
}
#
[
derive
(
Debug
Clone
Copy
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ScalarValue
{
Sint
(
i64
)
Uint
(
u64
)
Float
(
f64
)
Bool
(
bool
)
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ConstantInner
{
Scalar
{
width
:
Bytes
value
:
ScalarValue
}
Composite
{
ty
:
Handle
<
Type
>
components
:
Vec
<
Handle
<
Constant
>
>
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Binding
{
BuiltIn
(
BuiltIn
)
Location
{
location
:
u32
interpolation
:
Option
<
Interpolation
>
sampling
:
Option
<
Sampling
>
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
ResourceBinding
{
pub
group
:
u32
pub
binding
:
u32
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
GlobalVariable
{
pub
name
:
Option
<
String
>
pub
space
:
AddressSpace
pub
binding
:
Option
<
ResourceBinding
>
pub
ty
:
Handle
<
Type
>
pub
init
:
Option
<
Handle
<
Constant
>
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
LocalVariable
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
init
:
Option
<
Handle
<
Constant
>
>
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
UnaryOperator
{
Negate
Not
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
BinaryOperator
{
Add
Subtract
Multiply
Divide
Modulo
Equal
NotEqual
Less
LessEqual
Greater
GreaterEqual
And
ExclusiveOr
InclusiveOr
LogicalAnd
LogicalOr
ShiftLeft
ShiftRight
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
AtomicFunction
{
Add
Subtract
And
ExclusiveOr
InclusiveOr
Min
Max
Exchange
{
compare
:
Option
<
Handle
<
Expression
>
>
}
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
DerivativeAxis
{
X
Y
Width
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
RelationalFunction
{
All
Any
IsNan
IsInf
IsFinite
IsNormal
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
MathFunction
{
Abs
Min
Max
Clamp
Cos
Cosh
Sin
Sinh
Tan
Tanh
Acos
Asin
Atan
Atan2
Asinh
Acosh
Atanh
Radians
Degrees
Ceil
Floor
Round
Fract
Trunc
Modf
Frexp
Ldexp
Exp
Exp2
Log
Log2
Pow
Dot
Outer
Cross
Distance
Length
Normalize
FaceForward
Reflect
Refract
Sign
Fma
Mix
Step
SmoothStep
Sqrt
InverseSqrt
Inverse
Transpose
Determinant
CountOneBits
ReverseBits
ExtractBits
InsertBits
FindLsb
FindMsb
Pack4x8snorm
Pack4x8unorm
Pack2x16snorm
Pack2x16unorm
Pack2x16float
Unpack4x8snorm
Unpack4x8unorm
Unpack2x16snorm
Unpack2x16unorm
Unpack2x16float
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SampleLevel
{
Auto
Zero
Exact
(
Handle
<
Expression
>
)
Bias
(
Handle
<
Expression
>
)
Gradient
{
x
:
Handle
<
Expression
>
y
:
Handle
<
Expression
>
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ImageQuery
{
Size
{
level
:
Option
<
Handle
<
Expression
>
>
}
NumLevels
NumLayers
NumSamples
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SwizzleComponent
{
X
=
0
Y
=
1
Z
=
2
W
=
3
}
bitflags
:
:
bitflags
!
{
/
/
/
Memory
barrier
flags
.
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
derive
(
Default
)
]
pub
struct
Barrier
:
u32
{
/
/
/
Barrier
affects
all
AddressSpace
:
:
Storage
accesses
.
const
STORAGE
=
0x1
;
/
/
/
Barrier
affects
all
AddressSpace
:
:
WorkGroup
accesses
.
const
WORK_GROUP
=
0x2
;
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
test
derive
(
PartialEq
)
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Expression
{
Access
{
base
:
Handle
<
Expression
>
index
:
Handle
<
Expression
>
}
AccessIndex
{
base
:
Handle
<
Expression
>
index
:
u32
}
Constant
(
Handle
<
Constant
>
)
Splat
{
size
:
VectorSize
value
:
Handle
<
Expression
>
}
Swizzle
{
size
:
VectorSize
vector
:
Handle
<
Expression
>
pattern
:
[
SwizzleComponent
;
4
]
}
Compose
{
ty
:
Handle
<
Type
>
components
:
Vec
<
Handle
<
Expression
>
>
}
FunctionArgument
(
u32
)
GlobalVariable
(
Handle
<
GlobalVariable
>
)
LocalVariable
(
Handle
<
LocalVariable
>
)
Load
{
pointer
:
Handle
<
Expression
>
}
ImageSample
{
image
:
Handle
<
Expression
>
sampler
:
Handle
<
Expression
>
gather
:
Option
<
SwizzleComponent
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
offset
:
Option
<
Handle
<
Constant
>
>
level
:
SampleLevel
depth_ref
:
Option
<
Handle
<
Expression
>
>
}
ImageLoad
{
image
:
Handle
<
Expression
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
sample
:
Option
<
Handle
<
Expression
>
>
level
:
Option
<
Handle
<
Expression
>
>
}
ImageQuery
{
image
:
Handle
<
Expression
>
query
:
ImageQuery
}
Unary
{
op
:
UnaryOperator
expr
:
Handle
<
Expression
>
}
Binary
{
op
:
BinaryOperator
left
:
Handle
<
Expression
>
right
:
Handle
<
Expression
>
}
Select
{
condition
:
Handle
<
Expression
>
accept
:
Handle
<
Expression
>
reject
:
Handle
<
Expression
>
}
Derivative
{
axis
:
DerivativeAxis
expr
:
Handle
<
Expression
>
}
Relational
{
fun
:
RelationalFunction
argument
:
Handle
<
Expression
>
}
Math
{
fun
:
MathFunction
arg
:
Handle
<
Expression
>
arg1
:
Option
<
Handle
<
Expression
>
>
arg2
:
Option
<
Handle
<
Expression
>
>
arg3
:
Option
<
Handle
<
Expression
>
>
}
As
{
expr
:
Handle
<
Expression
>
kind
:
ScalarKind
convert
:
Option
<
Bytes
>
}
CallResult
(
Handle
<
Function
>
)
AtomicResult
{
kind
:
ScalarKind
width
:
Bytes
comparison
:
bool
}
ArrayLength
(
Handle
<
Expression
>
)
}
pub
use
block
:
:
Block
;
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SwitchValue
{
Integer
(
i32
)
Default
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
SwitchCase
{
pub
value
:
SwitchValue
pub
body
:
Block
pub
fall_through
:
bool
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Statement
{
Emit
(
Range
<
Expression
>
)
Block
(
Block
)
If
{
condition
:
Handle
<
Expression
>
accept
:
Block
reject
:
Block
}
Switch
{
selector
:
Handle
<
Expression
>
cases
:
Vec
<
SwitchCase
>
}
Loop
{
body
:
Block
continuing
:
Block
}
Break
Continue
Return
{
value
:
Option
<
Handle
<
Expression
>
>
}
Kill
Barrier
(
Barrier
)
Store
{
pointer
:
Handle
<
Expression
>
value
:
Handle
<
Expression
>
}
ImageStore
{
image
:
Handle
<
Expression
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
value
:
Handle
<
Expression
>
}
Atomic
{
pointer
:
Handle
<
Expression
>
fun
:
AtomicFunction
value
:
Handle
<
Expression
>
result
:
Handle
<
Expression
>
}
Call
{
function
:
Handle
<
Function
>
arguments
:
Vec
<
Handle
<
Expression
>
>
result
:
Option
<
Handle
<
Expression
>
>
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
FunctionArgument
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
binding
:
Option
<
Binding
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
FunctionResult
{
pub
ty
:
Handle
<
Type
>
pub
binding
:
Option
<
Binding
>
}
#
[
derive
(
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Function
{
pub
name
:
Option
<
String
>
pub
arguments
:
Vec
<
FunctionArgument
>
pub
result
:
Option
<
FunctionResult
>
pub
local_variables
:
Arena
<
LocalVariable
>
pub
expressions
:
Arena
<
Expression
>
pub
named_expressions
:
NamedExpressions
pub
body
:
Block
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
EntryPoint
{
pub
name
:
String
pub
stage
:
ShaderStage
pub
early_depth_test
:
Option
<
EarlyDepthTest
>
pub
workgroup_size
:
[
u32
;
3
]
pub
function
:
Function
}
#
[
derive
(
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Module
{
pub
types
:
UniqueArena
<
Type
>
pub
constants
:
Arena
<
Constant
>
pub
global_variables
:
Arena
<
GlobalVariable
>
pub
functions
:
Arena
<
Function
>
pub
entry_points
:
Vec
<
EntryPoint
>
}
