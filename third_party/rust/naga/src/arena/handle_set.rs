use
crate
:
:
arena
:
:
{
Arena
Handle
UniqueArena
}
;
#
[
derive
(
Debug
)
]
pub
struct
HandleSet
<
T
>
{
len
:
usize
members
:
bit_set
:
:
BitSet
as_keys
:
core
:
:
marker
:
:
PhantomData
<
T
>
}
impl
<
T
>
HandleSet
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
{
len
:
0
members
:
bit_set
:
:
BitSet
:
:
new
(
)
as_keys
:
core
:
:
marker
:
:
PhantomData
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
members
.
is_empty
(
)
}
pub
fn
for_arena
(
arena
:
&
impl
ArenaType
<
T
>
)
-
>
Self
{
let
len
=
arena
.
len
(
)
;
Self
{
len
members
:
bit_set
:
:
BitSet
:
:
with_capacity
(
len
)
as_keys
:
core
:
:
marker
:
:
PhantomData
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
members
.
clear
(
)
;
}
pub
fn
clear_for_arena
(
&
mut
self
arena
:
&
impl
ArenaType
<
T
>
)
{
self
.
members
.
clear
(
)
;
self
.
members
.
reserve_len
(
arena
.
len
(
)
)
;
}
pub
fn
all_possible
(
&
self
)
-
>
impl
Iterator
<
Item
=
Handle
<
T
>
>
{
super
:
:
Range
:
:
full_range_from_size
(
self
.
len
)
}
pub
fn
insert
(
&
mut
self
handle
:
Handle
<
T
>
)
-
>
bool
{
self
.
members
.
insert
(
handle
.
index
(
)
)
}
pub
fn
remove
(
&
mut
self
handle
:
Handle
<
T
>
)
-
>
bool
{
self
.
members
.
remove
(
handle
.
index
(
)
)
}
pub
fn
insert_iter
(
&
mut
self
iter
:
impl
IntoIterator
<
Item
=
Handle
<
T
>
>
)
{
for
handle
in
iter
{
self
.
insert
(
handle
)
;
}
}
pub
fn
add_all
(
&
mut
self
)
{
self
.
members
.
get_mut
(
)
.
set_all
(
)
;
}
pub
fn
contains
(
&
self
handle
:
Handle
<
T
>
)
-
>
bool
{
self
.
members
.
contains
(
handle
.
index
(
)
)
}
pub
fn
iter
(
&
self
)
-
>
impl
'
_
+
Iterator
<
Item
=
Handle
<
T
>
>
{
self
.
members
.
iter
(
)
.
map
(
Handle
:
:
from_usize
)
}
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
Handle
<
T
>
>
{
let
members
=
core
:
:
mem
:
:
take
(
&
mut
self
.
members
)
;
let
mut
vec
=
members
.
into_bit_vec
(
)
;
let
result
=
vec
.
iter_mut
(
)
.
enumerate
(
)
.
rev
(
)
.
find_map
(
|
(
i
mut
bit
)
|
{
if
*
bit
{
*
bit
=
false
;
Some
(
i
)
}
else
{
None
}
}
)
;
self
.
members
=
bit_set
:
:
BitSet
:
:
from_bit_vec
(
vec
)
;
result
.
map
(
Handle
:
:
from_usize
)
}
}
impl
<
T
>
Default
for
HandleSet
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
pub
trait
ArenaType
<
T
>
{
fn
len
(
&
self
)
-
>
usize
;
}
impl
<
T
>
ArenaType
<
T
>
for
Arena
<
T
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
}
impl
<
T
:
core
:
:
hash
:
:
Hash
+
Eq
>
ArenaType
<
T
>
for
UniqueArena
<
T
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
len
(
)
}
}
