use
crate
:
:
{
Arena
Handle
UniqueArena
}
;
use
std
:
:
{
error
:
:
Error
fmt
ops
:
:
Range
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
Default
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
arbitrary
:
:
Arbitrary
)
)
]
pub
struct
Span
{
start
:
u32
end
:
u32
}
impl
Span
{
pub
const
UNDEFINED
:
Self
=
Self
{
start
:
0
end
:
0
}
;
pub
const
fn
new
(
start
:
u32
end
:
u32
)
-
>
Self
{
Span
{
start
end
}
}
pub
fn
subsume
(
&
mut
self
other
:
Self
)
{
*
self
=
if
!
self
.
is_defined
(
)
{
other
}
else
if
!
other
.
is_defined
(
)
{
*
self
}
else
{
Span
{
start
:
self
.
start
.
min
(
other
.
start
)
end
:
self
.
end
.
max
(
other
.
end
)
}
}
}
pub
fn
total_span
<
T
:
Iterator
<
Item
=
Self
>
>
(
from
:
T
)
-
>
Self
{
let
mut
span
:
Self
=
Default
:
:
default
(
)
;
for
other
in
from
{
span
.
subsume
(
other
)
;
}
span
}
pub
fn
to_range
(
self
)
-
>
Option
<
Range
<
usize
>
>
{
if
self
.
is_defined
(
)
{
Some
(
self
.
start
as
usize
.
.
self
.
end
as
usize
)
}
else
{
None
}
}
pub
fn
is_defined
(
&
self
)
-
>
bool
{
*
self
!
=
Self
:
:
default
(
)
}
pub
fn
location
(
&
self
source
:
&
str
)
-
>
SourceLocation
{
let
prefix
=
&
source
[
.
.
self
.
start
as
usize
]
;
let
line_number
=
prefix
.
matches
(
'
\
n
'
)
.
count
(
)
as
u32
+
1
;
let
line_start
=
prefix
.
rfind
(
'
\
n
'
)
.
map
(
|
pos
|
pos
+
1
)
.
unwrap_or
(
0
)
;
let
line_position
=
source
[
line_start
.
.
self
.
start
as
usize
]
.
chars
(
)
.
count
(
)
as
u32
+
1
;
SourceLocation
{
line_number
line_position
offset
:
self
.
start
length
:
self
.
end
-
self
.
start
}
}
}
impl
From
<
Range
<
usize
>
>
for
Span
{
fn
from
(
range
:
Range
<
usize
>
)
-
>
Self
{
Span
{
start
:
range
.
start
as
u32
end
:
range
.
end
as
u32
}
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
pub
struct
SourceLocation
{
pub
line_number
:
u32
pub
line_position
:
u32
pub
offset
:
u32
pub
length
:
u32
}
pub
type
SpanContext
=
(
Span
String
)
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
WithSpan
<
E
>
{
inner
:
E
#
[
cfg
(
feature
=
"
span
"
)
]
spans
:
Vec
<
SpanContext
>
}
impl
<
E
>
fmt
:
:
Display
for
WithSpan
<
E
>
where
E
:
fmt
:
:
Display
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
self
.
inner
.
fmt
(
f
)
}
}
#
[
cfg
(
test
)
]
impl
<
E
>
PartialEq
for
WithSpan
<
E
>
where
E
:
PartialEq
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
inner
.
eq
(
&
other
.
inner
)
}
}
impl
<
E
>
Error
for
WithSpan
<
E
>
where
E
:
Error
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
Error
+
'
static
)
>
{
self
.
inner
.
source
(
)
}
}
impl
<
E
>
WithSpan
<
E
>
{
pub
const
fn
new
(
inner
:
E
)
-
>
Self
{
Self
{
inner
#
[
cfg
(
feature
=
"
span
"
)
]
spans
:
Vec
:
:
new
(
)
}
}
#
[
allow
(
clippy
:
:
missing_const_for_fn
)
]
pub
fn
into_inner
(
self
)
-
>
E
{
self
.
inner
}
pub
const
fn
as_inner
(
&
self
)
-
>
&
E
{
&
self
.
inner
}
pub
fn
spans
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
SpanContext
>
+
ExactSizeIterator
{
#
[
cfg
(
feature
=
"
span
"
)
]
return
self
.
spans
.
iter
(
)
;
#
[
cfg
(
not
(
feature
=
"
span
"
)
)
]
return
std
:
:
iter
:
:
empty
(
)
;
}
#
[
cfg_attr
(
not
(
feature
=
"
span
"
)
allow
(
unused_variables
unused_mut
)
)
]
pub
fn
with_span
<
S
>
(
mut
self
span
:
Span
description
:
S
)
-
>
Self
where
S
:
ToString
{
#
[
cfg
(
feature
=
"
span
"
)
]
if
span
.
is_defined
(
)
{
self
.
spans
.
push
(
(
span
description
.
to_string
(
)
)
)
;
}
self
}
pub
fn
with_context
(
self
span_context
:
SpanContext
)
-
>
Self
{
let
(
span
description
)
=
span_context
;
self
.
with_span
(
span
description
)
}
pub
(
crate
)
fn
with_handle
<
T
A
:
SpanProvider
<
T
>
>
(
self
handle
:
Handle
<
T
>
arena
:
&
A
)
-
>
Self
{
self
.
with_context
(
arena
.
get_span_context
(
handle
)
)
}
pub
fn
into_other
<
E2
>
(
self
)
-
>
WithSpan
<
E2
>
where
E2
:
From
<
E
>
{
WithSpan
{
inner
:
self
.
inner
.
into
(
)
#
[
cfg
(
feature
=
"
span
"
)
]
spans
:
self
.
spans
}
}
pub
fn
and_then
<
F
E2
>
(
self
func
:
F
)
-
>
WithSpan
<
E2
>
where
F
:
FnOnce
(
E
)
-
>
WithSpan
<
E2
>
{
#
[
cfg_attr
(
not
(
feature
=
"
span
"
)
allow
(
unused_mut
)
)
]
let
mut
res
=
func
(
self
.
inner
)
;
#
[
cfg
(
feature
=
"
span
"
)
]
res
.
spans
.
extend
(
self
.
spans
)
;
res
}
#
[
cfg
(
feature
=
"
span
"
)
]
pub
fn
location
(
&
self
source
:
&
str
)
-
>
Option
<
SourceLocation
>
{
if
self
.
spans
.
is_empty
(
)
{
return
None
;
}
Some
(
self
.
spans
[
0
]
.
0
.
location
(
source
)
)
}
#
[
cfg
(
not
(
feature
=
"
span
"
)
)
]
pub
fn
location
(
&
self
_source
:
&
str
)
-
>
Option
<
SourceLocation
>
{
None
}
}
pub
(
crate
)
trait
AddSpan
:
Sized
{
type
Output
;
fn
with_span
(
self
)
-
>
Self
:
:
Output
;
fn
with_span_static
(
self
span
:
Span
description
:
&
'
static
str
)
-
>
Self
:
:
Output
;
fn
with_span_context
(
self
span_context
:
SpanContext
)
-
>
Self
:
:
Output
;
fn
with_span_handle
<
T
A
:
SpanProvider
<
T
>
>
(
self
handle
:
Handle
<
T
>
arena
:
&
A
)
-
>
Self
:
:
Output
;
}
pub
(
crate
)
trait
SpanProvider
<
T
>
{
fn
get_span
(
&
self
handle
:
Handle
<
T
>
)
-
>
Span
;
fn
get_span_context
(
&
self
handle
:
Handle
<
T
>
)
-
>
SpanContext
{
match
self
.
get_span
(
handle
)
{
x
if
!
x
.
is_defined
(
)
=
>
(
Default
:
:
default
(
)
"
"
.
to_string
(
)
)
known
=
>
(
known
format
!
(
"
{
}
{
:
?
}
"
std
:
:
any
:
:
type_name
:
:
<
T
>
(
)
handle
)
)
}
}
}
impl
<
T
>
SpanProvider
<
T
>
for
Arena
<
T
>
{
fn
get_span
(
&
self
handle
:
Handle
<
T
>
)
-
>
Span
{
self
.
get_span
(
handle
)
}
}
impl
<
T
>
SpanProvider
<
T
>
for
UniqueArena
<
T
>
{
fn
get_span
(
&
self
handle
:
Handle
<
T
>
)
-
>
Span
{
self
.
get_span
(
handle
)
}
}
impl
<
E
>
AddSpan
for
E
where
E
:
Error
{
type
Output
=
WithSpan
<
Self
>
;
fn
with_span
(
self
)
-
>
WithSpan
<
Self
>
{
WithSpan
:
:
new
(
self
)
}
fn
with_span_static
(
self
span
:
Span
description
:
&
'
static
str
)
-
>
WithSpan
<
Self
>
{
WithSpan
:
:
new
(
self
)
.
with_span
(
span
description
)
}
fn
with_span_context
(
self
span_context
:
SpanContext
)
-
>
WithSpan
<
Self
>
{
WithSpan
:
:
new
(
self
)
.
with_context
(
span_context
)
}
fn
with_span_handle
<
T
A
:
SpanProvider
<
T
>
>
(
self
handle
:
Handle
<
T
>
arena
:
&
A
)
-
>
WithSpan
<
Self
>
{
WithSpan
:
:
new
(
self
)
.
with_handle
(
handle
arena
)
}
}
pub
trait
MapErrWithSpan
<
E
E2
>
:
Sized
{
type
Output
:
Sized
;
fn
map_err_inner
<
F
E3
>
(
self
func
:
F
)
-
>
Self
:
:
Output
where
F
:
FnOnce
(
E
)
-
>
WithSpan
<
E3
>
E2
:
From
<
E3
>
;
}
impl
<
T
E
E2
>
MapErrWithSpan
<
E
E2
>
for
Result
<
T
WithSpan
<
E
>
>
{
type
Output
=
Result
<
T
WithSpan
<
E2
>
>
;
fn
map_err_inner
<
F
E3
>
(
self
func
:
F
)
-
>
Result
<
T
WithSpan
<
E2
>
>
where
F
:
FnOnce
(
E
)
-
>
WithSpan
<
E3
>
E2
:
From
<
E3
>
{
self
.
map_err
(
|
e
|
e
.
and_then
(
func
)
.
into_other
:
:
<
E2
>
(
)
)
}
}
#
[
test
]
fn
span_location
(
)
{
let
source
=
"
12
\
n45
\
n
\
n89
\
n
"
;
assert_eq
!
(
Span
{
start
:
0
end
:
1
}
.
location
(
source
)
SourceLocation
{
line_number
:
1
line_position
:
1
offset
:
0
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
1
end
:
2
}
.
location
(
source
)
SourceLocation
{
line_number
:
1
line_position
:
2
offset
:
1
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
2
end
:
3
}
.
location
(
source
)
SourceLocation
{
line_number
:
1
line_position
:
3
offset
:
2
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
3
end
:
5
}
.
location
(
source
)
SourceLocation
{
line_number
:
2
line_position
:
1
offset
:
3
length
:
2
}
)
;
assert_eq
!
(
Span
{
start
:
4
end
:
6
}
.
location
(
source
)
SourceLocation
{
line_number
:
2
line_position
:
2
offset
:
4
length
:
2
}
)
;
assert_eq
!
(
Span
{
start
:
5
end
:
6
}
.
location
(
source
)
SourceLocation
{
line_number
:
2
line_position
:
3
offset
:
5
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
6
end
:
7
}
.
location
(
source
)
SourceLocation
{
line_number
:
3
line_position
:
1
offset
:
6
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
7
end
:
8
}
.
location
(
source
)
SourceLocation
{
line_number
:
4
line_position
:
1
offset
:
7
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
8
end
:
9
}
.
location
(
source
)
SourceLocation
{
line_number
:
4
line_position
:
2
offset
:
8
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
9
end
:
10
}
.
location
(
source
)
SourceLocation
{
line_number
:
4
line_position
:
3
offset
:
9
length
:
1
}
)
;
assert_eq
!
(
Span
{
start
:
10
end
:
11
}
.
location
(
source
)
SourceLocation
{
line_number
:
5
line_position
:
1
offset
:
10
length
:
1
}
)
;
}
