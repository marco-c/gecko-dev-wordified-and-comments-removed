mod
block
;
use
alloc
:
:
{
boxed
:
:
Box
string
:
:
String
vec
:
:
Vec
}
;
#
[
cfg
(
feature
=
"
arbitrary
"
)
]
use
arbitrary
:
:
Arbitrary
;
use
half
:
:
f16
;
#
[
cfg
(
feature
=
"
deserialize
"
)
]
use
serde
:
:
Deserialize
;
#
[
cfg
(
feature
=
"
serialize
"
)
]
use
serde
:
:
Serialize
;
use
crate
:
:
arena
:
:
{
Arena
Handle
Range
UniqueArena
}
;
use
crate
:
:
diagnostic_filter
:
:
DiagnosticFilterNode
;
use
crate
:
:
{
FastIndexMap
NamedExpressions
}
;
pub
use
block
:
:
Block
;
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
EarlyDepthTest
{
Force
Allow
{
conservative
:
ConservativeDepth
}
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ConservativeDepth
{
GreaterEqual
LessEqual
Unchanged
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
ShaderStage
{
Vertex
Fragment
Compute
Task
Mesh
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
AddressSpace
{
Function
Private
WorkGroup
Uniform
Storage
{
access
:
StorageAccess
}
Handle
PushConstant
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
BuiltIn
{
Position
{
invariant
:
bool
}
ViewIndex
BaseInstance
BaseVertex
ClipDistance
CullDistance
InstanceIndex
PointSize
VertexIndex
DrawID
FragDepth
PointCoord
FrontFacing
PrimitiveIndex
SampleIndex
SampleMask
GlobalInvocationId
LocalInvocationId
LocalInvocationIndex
WorkGroupId
WorkGroupSize
NumWorkGroups
NumSubgroups
SubgroupId
SubgroupSize
SubgroupInvocationId
}
pub
type
Bytes
=
u8
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
VectorSize
{
Bi
=
2
Tri
=
3
Quad
=
4
}
impl
VectorSize
{
pub
const
MAX
:
usize
=
Self
:
:
Quad
as
usize
;
}
impl
From
<
VectorSize
>
for
u8
{
fn
from
(
size
:
VectorSize
)
-
>
u8
{
size
as
u8
}
}
impl
From
<
VectorSize
>
for
u32
{
fn
from
(
size
:
VectorSize
)
-
>
u32
{
size
as
u32
}
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ScalarKind
{
Sint
Uint
Float
Bool
AbstractInt
AbstractFloat
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Scalar
{
pub
kind
:
ScalarKind
pub
width
:
Bytes
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ArraySize
{
Constant
(
core
:
:
num
:
:
NonZeroU32
)
Pending
(
Handle
<
Override
>
)
Dynamic
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Interpolation
{
Perspective
Linear
Flat
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Sampling
{
Center
Centroid
Sample
First
Either
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
StructMember
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
binding
:
Option
<
Binding
>
pub
offset
:
u32
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ImageDimension
{
D1
D2
D3
Cube
}
bitflags
:
:
bitflags
!
{
/
/
/
Flags
describing
an
image
.
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
struct
StorageAccess
:
u32
{
/
/
/
Storage
can
be
used
as
a
source
for
load
ops
.
const
LOAD
=
0x1
;
/
/
/
Storage
can
be
used
as
a
target
for
store
ops
.
const
STORE
=
0x2
;
/
/
/
Storage
can
be
used
as
a
target
for
atomic
ops
.
const
ATOMIC
=
0x4
;
}
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
StorageFormat
{
R8Unorm
R8Snorm
R8Uint
R8Sint
R16Uint
R16Sint
R16Float
Rg8Unorm
Rg8Snorm
Rg8Uint
Rg8Sint
R32Uint
R32Sint
R32Float
Rg16Uint
Rg16Sint
Rg16Float
Rgba8Unorm
Rgba8Snorm
Rgba8Uint
Rgba8Sint
Bgra8Unorm
Rgb10a2Uint
Rgb10a2Unorm
Rg11b10Ufloat
R64Uint
Rg32Uint
Rg32Sint
Rg32Float
Rgba16Uint
Rgba16Sint
Rgba16Float
Rgba32Uint
Rgba32Sint
Rgba32Float
R16Unorm
R16Snorm
Rg16Unorm
Rg16Snorm
Rgba16Unorm
Rgba16Snorm
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ImageClass
{
Sampled
{
kind
:
ScalarKind
multi
:
bool
}
Depth
{
multi
:
bool
}
External
Storage
{
format
:
StorageFormat
access
:
StorageAccess
}
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Type
{
pub
name
:
Option
<
String
>
pub
inner
:
TypeInner
}
#
[
derive
(
Clone
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
TypeInner
{
Scalar
(
Scalar
)
Vector
{
size
:
VectorSize
scalar
:
Scalar
}
Matrix
{
columns
:
VectorSize
rows
:
VectorSize
scalar
:
Scalar
}
Atomic
(
Scalar
)
Pointer
{
base
:
Handle
<
Type
>
space
:
AddressSpace
}
ValuePointer
{
size
:
Option
<
VectorSize
>
scalar
:
Scalar
space
:
AddressSpace
}
Array
{
base
:
Handle
<
Type
>
size
:
ArraySize
stride
:
u32
}
Struct
{
members
:
Vec
<
StructMember
>
span
:
u32
}
Image
{
dim
:
ImageDimension
arrayed
:
bool
class
:
ImageClass
}
Sampler
{
comparison
:
bool
}
AccelerationStructure
{
vertex_return
:
bool
}
RayQuery
{
vertex_return
:
bool
}
BindingArray
{
base
:
Handle
<
Type
>
size
:
ArraySize
}
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Literal
{
F64
(
f64
)
F32
(
f32
)
F16
(
f16
)
U32
(
u32
)
I32
(
i32
)
U64
(
u64
)
I64
(
i64
)
Bool
(
bool
)
AbstractInt
(
i64
)
AbstractFloat
(
f64
)
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Override
{
pub
name
:
Option
<
String
>
pub
id
:
Option
<
u16
>
pub
ty
:
Handle
<
Type
>
pub
init
:
Option
<
Handle
<
Expression
>
>
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Constant
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
init
:
Handle
<
Expression
>
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Binding
{
BuiltIn
(
BuiltIn
)
Location
{
location
:
u32
interpolation
:
Option
<
Interpolation
>
sampling
:
Option
<
Sampling
>
blend_src
:
Option
<
u32
>
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
ResourceBinding
{
pub
group
:
u32
pub
binding
:
u32
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
GlobalVariable
{
pub
name
:
Option
<
String
>
pub
space
:
AddressSpace
pub
binding
:
Option
<
ResourceBinding
>
pub
ty
:
Handle
<
Type
>
pub
init
:
Option
<
Handle
<
Expression
>
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
LocalVariable
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
init
:
Option
<
Handle
<
Expression
>
>
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
UnaryOperator
{
Negate
LogicalNot
BitwiseNot
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
BinaryOperator
{
Add
Subtract
Multiply
Divide
Modulo
Equal
NotEqual
Less
LessEqual
Greater
GreaterEqual
And
ExclusiveOr
InclusiveOr
LogicalAnd
LogicalOr
ShiftLeft
ShiftRight
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
AtomicFunction
{
Add
Subtract
And
ExclusiveOr
InclusiveOr
Min
Max
Exchange
{
compare
:
Option
<
Handle
<
Expression
>
>
}
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
DerivativeControl
{
Coarse
Fine
None
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
DerivativeAxis
{
X
Y
Width
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
RelationalFunction
{
All
Any
IsNan
IsInf
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
MathFunction
{
Abs
Min
Max
Clamp
Saturate
Cos
Cosh
Sin
Sinh
Tan
Tanh
Acos
Asin
Atan
Atan2
Asinh
Acosh
Atanh
Radians
Degrees
Ceil
Floor
Round
Fract
Trunc
Modf
Frexp
Ldexp
Exp
Exp2
Log
Log2
Pow
Dot
Dot4I8Packed
Dot4U8Packed
Outer
Cross
Distance
Length
Normalize
FaceForward
Reflect
Refract
Sign
Fma
Mix
Step
SmoothStep
Sqrt
InverseSqrt
Inverse
Transpose
Determinant
QuantizeToF16
CountTrailingZeros
CountLeadingZeros
CountOneBits
ReverseBits
ExtractBits
InsertBits
FirstTrailingBit
FirstLeadingBit
Pack4x8snorm
Pack4x8unorm
Pack2x16snorm
Pack2x16unorm
Pack2x16float
Pack4xI8
Pack4xU8
Pack4xI8Clamp
Pack4xU8Clamp
Unpack4x8snorm
Unpack4x8unorm
Unpack2x16snorm
Unpack2x16unorm
Unpack2x16float
Unpack4xI8
Unpack4xU8
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SampleLevel
{
Auto
Zero
Exact
(
Handle
<
Expression
>
)
Bias
(
Handle
<
Expression
>
)
Gradient
{
x
:
Handle
<
Expression
>
y
:
Handle
<
Expression
>
}
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
ImageQuery
{
Size
{
level
:
Option
<
Handle
<
Expression
>
>
}
NumLevels
NumLayers
NumSamples
}
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SwizzleComponent
{
X
=
0
Y
=
1
Z
=
2
W
=
3
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
GatherMode
{
BroadcastFirst
Broadcast
(
Handle
<
Expression
>
)
Shuffle
(
Handle
<
Expression
>
)
ShuffleDown
(
Handle
<
Expression
>
)
ShuffleUp
(
Handle
<
Expression
>
)
ShuffleXor
(
Handle
<
Expression
>
)
QuadBroadcast
(
Handle
<
Expression
>
)
QuadSwap
(
Direction
)
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Direction
{
X
=
0
Y
=
1
Diagonal
=
2
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SubgroupOperation
{
All
=
0
Any
=
1
Add
=
2
Mul
=
3
Min
=
4
Max
=
5
And
=
6
Or
=
7
Xor
=
8
}
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
CollectiveOperation
{
Reduce
=
0
InclusiveScan
=
1
ExclusiveScan
=
2
}
bitflags
:
:
bitflags
!
{
/
/
/
Memory
barrier
flags
.
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
derive
(
Clone
Copy
Debug
Default
Eq
PartialEq
)
]
pub
struct
Barrier
:
u32
{
/
/
/
Barrier
affects
all
[
AddressSpace
:
:
Storage
]
accesses
.
const
STORAGE
=
1
<
<
0
;
/
/
/
Barrier
affects
all
[
AddressSpace
:
:
WorkGroup
]
accesses
.
const
WORK_GROUP
=
1
<
<
1
;
/
/
/
Barrier
synchronizes
execution
across
all
invocations
within
a
subgroup
that
execute
this
instruction
.
const
SUB_GROUP
=
1
<
<
2
;
/
/
/
Barrier
synchronizes
texture
memory
accesses
in
a
workgroup
.
const
TEXTURE
=
1
<
<
3
;
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Expression
{
Literal
(
Literal
)
Constant
(
Handle
<
Constant
>
)
Override
(
Handle
<
Override
>
)
ZeroValue
(
Handle
<
Type
>
)
Compose
{
ty
:
Handle
<
Type
>
components
:
Vec
<
Handle
<
Expression
>
>
}
Access
{
base
:
Handle
<
Expression
>
index
:
Handle
<
Expression
>
}
AccessIndex
{
base
:
Handle
<
Expression
>
index
:
u32
}
Splat
{
size
:
VectorSize
value
:
Handle
<
Expression
>
}
Swizzle
{
size
:
VectorSize
vector
:
Handle
<
Expression
>
pattern
:
[
SwizzleComponent
;
4
]
}
FunctionArgument
(
u32
)
GlobalVariable
(
Handle
<
GlobalVariable
>
)
LocalVariable
(
Handle
<
LocalVariable
>
)
Load
{
pointer
:
Handle
<
Expression
>
}
ImageSample
{
image
:
Handle
<
Expression
>
sampler
:
Handle
<
Expression
>
gather
:
Option
<
SwizzleComponent
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
offset
:
Option
<
Handle
<
Expression
>
>
level
:
SampleLevel
depth_ref
:
Option
<
Handle
<
Expression
>
>
clamp_to_edge
:
bool
}
ImageLoad
{
image
:
Handle
<
Expression
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
sample
:
Option
<
Handle
<
Expression
>
>
level
:
Option
<
Handle
<
Expression
>
>
}
ImageQuery
{
image
:
Handle
<
Expression
>
query
:
ImageQuery
}
Unary
{
op
:
UnaryOperator
expr
:
Handle
<
Expression
>
}
Binary
{
op
:
BinaryOperator
left
:
Handle
<
Expression
>
right
:
Handle
<
Expression
>
}
Select
{
condition
:
Handle
<
Expression
>
accept
:
Handle
<
Expression
>
reject
:
Handle
<
Expression
>
}
Derivative
{
axis
:
DerivativeAxis
ctrl
:
DerivativeControl
expr
:
Handle
<
Expression
>
}
Relational
{
fun
:
RelationalFunction
argument
:
Handle
<
Expression
>
}
Math
{
fun
:
MathFunction
arg
:
Handle
<
Expression
>
arg1
:
Option
<
Handle
<
Expression
>
>
arg2
:
Option
<
Handle
<
Expression
>
>
arg3
:
Option
<
Handle
<
Expression
>
>
}
As
{
expr
:
Handle
<
Expression
>
kind
:
ScalarKind
convert
:
Option
<
Bytes
>
}
CallResult
(
Handle
<
Function
>
)
AtomicResult
{
ty
:
Handle
<
Type
>
comparison
:
bool
}
WorkGroupUniformLoadResult
{
ty
:
Handle
<
Type
>
}
ArrayLength
(
Handle
<
Expression
>
)
RayQueryVertexPositions
{
query
:
Handle
<
Expression
>
committed
:
bool
}
RayQueryProceedResult
RayQueryGetIntersection
{
query
:
Handle
<
Expression
>
committed
:
bool
}
SubgroupBallotResult
SubgroupOperationResult
{
ty
:
Handle
<
Type
>
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
SwitchValue
{
I32
(
i32
)
U32
(
u32
)
Default
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
SwitchCase
{
pub
value
:
SwitchValue
pub
body
:
Block
pub
fall_through
:
bool
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
RayQueryFunction
{
Initialize
{
acceleration_structure
:
Handle
<
Expression
>
#
[
allow
(
rustdoc
:
:
private_intra_doc_links
)
]
descriptor
:
Handle
<
Expression
>
}
Proceed
{
result
:
Handle
<
Expression
>
}
GenerateIntersection
{
hit_t
:
Handle
<
Expression
>
}
ConfirmIntersection
Terminate
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
Statement
{
Emit
(
Range
<
Expression
>
)
Block
(
Block
)
If
{
condition
:
Handle
<
Expression
>
accept
:
Block
reject
:
Block
}
Switch
{
selector
:
Handle
<
Expression
>
cases
:
Vec
<
SwitchCase
>
}
Loop
{
body
:
Block
continuing
:
Block
break_if
:
Option
<
Handle
<
Expression
>
>
}
Break
Continue
Return
{
value
:
Option
<
Handle
<
Expression
>
>
}
Kill
ControlBarrier
(
Barrier
)
MemoryBarrier
(
Barrier
)
Store
{
pointer
:
Handle
<
Expression
>
value
:
Handle
<
Expression
>
}
ImageStore
{
image
:
Handle
<
Expression
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
value
:
Handle
<
Expression
>
}
Atomic
{
pointer
:
Handle
<
Expression
>
fun
:
AtomicFunction
value
:
Handle
<
Expression
>
result
:
Option
<
Handle
<
Expression
>
>
}
ImageAtomic
{
image
:
Handle
<
Expression
>
coordinate
:
Handle
<
Expression
>
array_index
:
Option
<
Handle
<
Expression
>
>
fun
:
AtomicFunction
value
:
Handle
<
Expression
>
}
WorkGroupUniformLoad
{
pointer
:
Handle
<
Expression
>
result
:
Handle
<
Expression
>
}
Call
{
function
:
Handle
<
Function
>
arguments
:
Vec
<
Handle
<
Expression
>
>
result
:
Option
<
Handle
<
Expression
>
>
}
RayQuery
{
query
:
Handle
<
Expression
>
fun
:
RayQueryFunction
}
SubgroupBallot
{
result
:
Handle
<
Expression
>
predicate
:
Option
<
Handle
<
Expression
>
>
}
SubgroupGather
{
mode
:
GatherMode
argument
:
Handle
<
Expression
>
result
:
Handle
<
Expression
>
}
SubgroupCollectiveOperation
{
op
:
SubgroupOperation
collective_op
:
CollectiveOperation
argument
:
Handle
<
Expression
>
result
:
Handle
<
Expression
>
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
FunctionArgument
{
pub
name
:
Option
<
String
>
pub
ty
:
Handle
<
Type
>
pub
binding
:
Option
<
Binding
>
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
FunctionResult
{
pub
ty
:
Handle
<
Type
>
pub
binding
:
Option
<
Binding
>
}
#
[
derive
(
Debug
Default
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Function
{
pub
name
:
Option
<
String
>
pub
arguments
:
Vec
<
FunctionArgument
>
pub
result
:
Option
<
FunctionResult
>
pub
local_variables
:
Arena
<
LocalVariable
>
pub
expressions
:
Arena
<
Expression
>
pub
named_expressions
:
NamedExpressions
pub
body
:
Block
pub
diagnostic_filter_leaf
:
Option
<
Handle
<
DiagnosticFilterNode
>
>
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
EntryPoint
{
pub
name
:
String
pub
stage
:
ShaderStage
pub
early_depth_test
:
Option
<
EarlyDepthTest
>
pub
workgroup_size
:
[
u32
;
3
]
pub
workgroup_size_overrides
:
Option
<
[
Option
<
Handle
<
Expression
>
>
;
3
]
>
pub
function
:
Function
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
enum
PredeclaredType
{
AtomicCompareExchangeWeakResult
(
Scalar
)
ModfResult
{
size
:
Option
<
VectorSize
>
scalar
:
Scalar
}
FrexpResult
{
size
:
Option
<
VectorSize
>
scalar
:
Scalar
}
}
#
[
derive
(
Debug
Default
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
SpecialTypes
{
pub
ray_desc
:
Option
<
Handle
<
Type
>
>
pub
ray_intersection
:
Option
<
Handle
<
Type
>
>
pub
ray_vertex_return
:
Option
<
Handle
<
Type
>
>
pub
predeclared_types
:
FastIndexMap
<
PredeclaredType
Handle
<
Type
>
>
}
bitflags
:
:
bitflags
!
{
/
/
/
Ray
flags
used
when
casting
rays
.
/
/
/
Matching
vulkan
constants
can
be
found
in
/
/
/
https
:
/
/
github
.
com
/
KhronosGroup
/
SPIRV
-
Registry
/
blob
/
main
/
extensions
/
KHR
/
ray_common
/
ray_flags_section
.
txt
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
struct
RayFlag
:
u32
{
/
/
/
Force
all
intersections
to
be
treated
as
opaque
.
const
FORCE_OPAQUE
=
0x1
;
/
/
/
Force
all
intersections
to
be
treated
as
non
-
opaque
.
const
FORCE_NO_OPAQUE
=
0x2
;
/
/
/
Stop
traversal
after
the
first
hit
.
const
TERMINATE_ON_FIRST_HIT
=
0x4
;
/
/
/
Don
'
t
execute
the
closest
hit
shader
.
const
SKIP_CLOSEST_HIT_SHADER
=
0x8
;
/
/
/
Cull
back
facing
geometry
.
const
CULL_BACK_FACING
=
0x10
;
/
/
/
Cull
front
facing
geometry
.
const
CULL_FRONT_FACING
=
0x20
;
/
/
/
Cull
opaque
geometry
.
const
CULL_OPAQUE
=
0x40
;
/
/
/
Cull
non
-
opaque
geometry
.
const
CULL_NO_OPAQUE
=
0x80
;
/
/
/
Skip
triangular
geometry
.
const
SKIP_TRIANGLES
=
0x100
;
/
/
/
Skip
axis
-
aligned
bounding
boxes
.
const
SKIP_AABBS
=
0x200
;
}
}
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
#
[
derive
(
Clone
Copy
Debug
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
pub
enum
RayQueryIntersection
{
#
[
default
]
None
=
0
Triangle
=
1
Generated
=
2
Aabb
=
3
}
#
[
derive
(
Debug
Default
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
DocComments
{
pub
types
:
FastIndexMap
<
Handle
<
Type
>
Vec
<
String
>
>
pub
struct_members
:
FastIndexMap
<
(
Handle
<
Type
>
usize
)
Vec
<
String
>
>
pub
entry_points
:
FastIndexMap
<
usize
Vec
<
String
>
>
pub
functions
:
FastIndexMap
<
Handle
<
Function
>
Vec
<
String
>
>
pub
constants
:
FastIndexMap
<
Handle
<
Constant
>
Vec
<
String
>
>
pub
global_variables
:
FastIndexMap
<
Handle
<
GlobalVariable
>
Vec
<
String
>
>
pub
module
:
Vec
<
String
>
}
#
[
derive
(
Debug
Default
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serialize
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
deserialize
"
derive
(
Deserialize
)
)
]
#
[
cfg_attr
(
feature
=
"
arbitrary
"
derive
(
Arbitrary
)
)
]
pub
struct
Module
{
pub
types
:
UniqueArena
<
Type
>
pub
special_types
:
SpecialTypes
pub
constants
:
Arena
<
Constant
>
pub
overrides
:
Arena
<
Override
>
pub
global_variables
:
Arena
<
GlobalVariable
>
pub
global_expressions
:
Arena
<
Expression
>
pub
functions
:
Arena
<
Function
>
pub
entry_points
:
Vec
<
EntryPoint
>
pub
diagnostic_filters
:
Arena
<
DiagnosticFilterNode
>
pub
diagnostic_filter_leaf
:
Option
<
Handle
<
DiagnosticFilterNode
>
>
pub
doc_comments
:
Option
<
Box
<
DocComments
>
>
}
