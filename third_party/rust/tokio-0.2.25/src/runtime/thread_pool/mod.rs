mod
atomic_cell
;
use
atomic_cell
:
:
AtomicCell
;
mod
idle
;
use
self
:
:
idle
:
:
Idle
;
mod
worker
;
pub
(
crate
)
use
worker
:
:
Launch
;
cfg_blocking
!
{
pub
(
crate
)
use
worker
:
:
block_in_place
;
}
use
crate
:
:
loom
:
:
sync
:
:
Arc
;
use
crate
:
:
runtime
:
:
task
:
:
{
self
JoinHandle
}
;
use
crate
:
:
runtime
:
:
Parker
;
use
std
:
:
fmt
;
use
std
:
:
future
:
:
Future
;
pub
(
crate
)
struct
ThreadPool
{
spawner
:
Spawner
}
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
Spawner
{
shared
:
Arc
<
worker
:
:
Shared
>
}
impl
ThreadPool
{
pub
(
crate
)
fn
new
(
size
:
usize
parker
:
Parker
)
-
>
(
ThreadPool
Launch
)
{
let
(
shared
launch
)
=
worker
:
:
create
(
size
parker
)
;
let
spawner
=
Spawner
{
shared
}
;
let
thread_pool
=
ThreadPool
{
spawner
}
;
(
thread_pool
launch
)
}
pub
(
crate
)
fn
spawner
(
&
self
)
-
>
&
Spawner
{
&
self
.
spawner
}
pub
(
crate
)
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
self
.
spawner
.
spawn
(
future
)
}
pub
(
crate
)
fn
block_on
<
F
>
(
&
self
future
:
F
)
-
>
F
:
:
Output
where
F
:
Future
{
let
mut
enter
=
crate
:
:
runtime
:
:
enter
(
true
)
;
enter
.
block_on
(
future
)
.
expect
(
"
failed
to
park
thread
"
)
}
}
impl
fmt
:
:
Debug
for
ThreadPool
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
ThreadPool
"
)
.
finish
(
)
}
}
impl
Drop
for
ThreadPool
{
fn
drop
(
&
mut
self
)
{
self
.
spawner
.
shutdown
(
)
;
}
}
impl
Spawner
{
pub
(
crate
)
fn
spawn
<
F
>
(
&
self
future
:
F
)
-
>
JoinHandle
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
let
(
task
handle
)
=
task
:
:
joinable
(
future
)
;
self
.
shared
.
schedule
(
task
false
)
;
handle
}
pub
(
crate
)
fn
shutdown
(
&
mut
self
)
{
self
.
shared
.
close
(
)
;
}
}
impl
fmt
:
:
Debug
for
Spawner
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Spawner
"
)
.
finish
(
)
}
}
