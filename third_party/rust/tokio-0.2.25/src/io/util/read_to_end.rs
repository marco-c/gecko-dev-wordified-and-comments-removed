use
crate
:
:
io
:
:
AsyncRead
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
io
;
use
std
:
:
mem
:
:
{
self
MaybeUninit
}
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
futures
do
nothing
unless
you
.
await
or
poll
them
"
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
io
-
util
"
)
)
)
]
pub
struct
ReadToEnd
<
'
a
R
:
?
Sized
>
{
reader
:
&
'
a
mut
R
buf
:
&
'
a
mut
Vec
<
u8
>
read
:
usize
}
pub
(
crate
)
fn
read_to_end
<
'
a
R
>
(
reader
:
&
'
a
mut
R
buffer
:
&
'
a
mut
Vec
<
u8
>
)
-
>
ReadToEnd
<
'
a
R
>
where
R
:
AsyncRead
+
Unpin
+
?
Sized
{
prepare_buffer
(
buffer
reader
)
;
ReadToEnd
{
reader
buf
:
buffer
read
:
0
}
}
pub
(
super
)
unsafe
fn
read_to_end_internal
<
R
:
AsyncRead
+
?
Sized
>
(
buf
:
&
mut
Vec
<
u8
>
mut
reader
:
Pin
<
&
mut
R
>
num_read
:
&
mut
usize
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
loop
{
let
ret
=
ready
!
(
poll_read_to_end
(
buf
reader
.
as_mut
(
)
cx
)
)
;
match
ret
{
Err
(
err
)
=
>
return
Poll
:
:
Ready
(
Err
(
err
)
)
Ok
(
0
)
=
>
return
Poll
:
:
Ready
(
Ok
(
mem
:
:
replace
(
num_read
0
)
)
)
Ok
(
num
)
=
>
{
*
num_read
+
=
num
;
}
}
}
}
unsafe
fn
poll_read_to_end
<
R
:
AsyncRead
+
?
Sized
>
(
buf
:
&
mut
Vec
<
u8
>
read
:
Pin
<
&
mut
R
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
reserve
(
buf
&
*
read
32
)
;
let
unused_capacity
:
&
mut
[
MaybeUninit
<
u8
>
]
=
get_unused_capacity
(
buf
)
;
let
slice
:
&
mut
[
u8
]
=
&
mut
*
(
unused_capacity
as
*
mut
[
MaybeUninit
<
u8
>
]
as
*
mut
[
u8
]
)
;
let
res
=
ready
!
(
read
.
poll_read
(
cx
slice
)
)
;
if
let
Ok
(
num
)
=
res
{
let
new_len
=
buf
.
len
(
)
+
num
;
assert
!
(
new_len
<
=
buf
.
capacity
(
)
)
;
buf
.
set_len
(
new_len
)
;
}
Poll
:
:
Ready
(
res
)
}
pub
(
super
)
fn
prepare_buffer
<
R
:
AsyncRead
+
?
Sized
>
(
buf
:
&
mut
Vec
<
u8
>
read
:
&
R
)
{
let
buffer
=
get_unused_capacity
(
buf
)
;
unsafe
{
read
.
prepare_uninitialized_buffer
(
buffer
)
;
}
}
fn
reserve
<
R
:
AsyncRead
+
?
Sized
>
(
buf
:
&
mut
Vec
<
u8
>
read
:
&
R
bytes
:
usize
)
{
if
buf
.
capacity
(
)
-
buf
.
len
(
)
>
=
bytes
{
return
;
}
buf
.
reserve
(
bytes
)
;
prepare_buffer
(
buf
read
)
;
}
fn
get_unused_capacity
(
buf
:
&
mut
Vec
<
u8
>
)
-
>
&
mut
[
MaybeUninit
<
u8
>
]
{
bytes
:
:
BufMut
:
:
bytes_mut
(
buf
)
}
impl
<
A
>
Future
for
ReadToEnd
<
'
_
A
>
where
A
:
AsyncRead
+
?
Sized
+
Unpin
{
type
Output
=
io
:
:
Result
<
usize
>
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
Self
{
reader
buf
read
}
=
&
mut
*
self
;
unsafe
{
read_to_end_internal
(
buf
Pin
:
:
new
(
*
reader
)
read
cx
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
assert_unpin
(
)
{
use
std
:
:
marker
:
:
PhantomPinned
;
crate
:
:
is_unpin
:
:
<
ReadToEnd
<
'
_
PhantomPinned
>
>
(
)
;
}
}
