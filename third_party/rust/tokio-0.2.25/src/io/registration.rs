use
crate
:
:
io
:
:
driver
:
:
{
platform
Direction
Handle
}
;
use
crate
:
:
util
:
:
slab
:
:
Address
;
use
mio
:
:
{
self
Evented
}
;
use
std
:
:
io
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
cfg_io_driver
!
{
/
/
/
Associates
an
I
/
O
resource
with
the
reactor
instance
that
drives
it
.
/
/
/
/
/
/
A
registration
represents
an
I
/
O
resource
registered
with
a
Reactor
such
/
/
/
that
it
will
receive
task
notifications
on
readiness
.
This
is
the
lowest
/
/
/
level
API
for
integrating
with
a
reactor
.
/
/
/
/
/
/
The
association
between
an
I
/
O
resource
is
made
by
calling
[
new
]
.
Once
/
/
/
the
association
is
established
it
remains
established
until
the
/
/
/
registration
instance
is
dropped
.
/
/
/
/
/
/
A
registration
instance
represents
two
separate
readiness
streams
.
One
/
/
/
for
the
read
readiness
and
one
for
write
readiness
.
These
streams
are
/
/
/
independent
and
can
be
consumed
from
separate
tasks
.
/
/
/
/
/
/
*
*
Note
*
*
:
while
Registration
is
Sync
the
caller
must
ensure
that
/
/
/
there
are
at
most
two
tasks
that
use
a
registration
instance
/
/
/
concurrently
.
One
task
for
[
poll_read_ready
]
and
one
task
for
/
/
/
[
poll_write_ready
]
.
While
violating
this
requirement
is
"
safe
"
from
a
/
/
/
Rust
memory
safety
point
of
view
it
will
result
in
unexpected
behavior
/
/
/
in
the
form
of
lost
notifications
and
tasks
hanging
.
/
/
/
/
/
/
#
#
Platform
-
specific
events
/
/
/
/
/
/
Registration
also
allows
receiving
platform
-
specific
mio
:
:
Ready
#
[
derive
(
Debug
)
]
pub
struct
Registration
{
handle
:
Handle
address
:
Address
}
}
impl
Registration
{
pub
fn
new
<
T
>
(
io
:
&
T
)
-
>
io
:
:
Result
<
Registration
>
where
T
:
Evented
{
Registration
:
:
new_with_ready
(
io
mio
:
:
Ready
:
:
all
(
)
)
}
pub
fn
new_with_ready
<
T
>
(
io
:
&
T
ready
:
mio
:
:
Ready
)
-
>
io
:
:
Result
<
Registration
>
where
T
:
Evented
{
let
handle
=
Handle
:
:
current
(
)
;
let
address
=
if
let
Some
(
inner
)
=
handle
.
inner
(
)
{
inner
.
add_source
(
io
ready
)
?
}
else
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
failed
to
find
event
loop
"
)
)
;
}
;
Ok
(
Registration
{
handle
address
}
)
}
pub
fn
deregister
<
T
>
(
&
mut
self
io
:
&
T
)
-
>
io
:
:
Result
<
(
)
>
where
T
:
Evented
{
let
inner
=
match
self
.
handle
.
inner
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
reactor
gone
"
)
)
}
;
inner
.
deregister_source
(
io
)
}
pub
fn
poll_read_ready
(
&
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
mio
:
:
Ready
>
>
{
let
coop
=
ready
!
(
crate
:
:
coop
:
:
poll_proceed
(
cx
)
)
;
let
v
=
self
.
poll_ready
(
Direction
:
:
Read
Some
(
cx
)
)
.
map_err
(
|
e
|
{
coop
.
made_progress
(
)
;
e
}
)
?
;
match
v
{
Some
(
v
)
=
>
{
coop
.
made_progress
(
)
;
Poll
:
:
Ready
(
Ok
(
v
)
)
}
None
=
>
Poll
:
:
Pending
}
}
pub
fn
take_read_ready
(
&
self
)
-
>
io
:
:
Result
<
Option
<
mio
:
:
Ready
>
>
{
self
.
poll_ready
(
Direction
:
:
Read
None
)
}
pub
fn
poll_write_ready
(
&
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
mio
:
:
Ready
>
>
{
let
coop
=
ready
!
(
crate
:
:
coop
:
:
poll_proceed
(
cx
)
)
;
let
v
=
self
.
poll_ready
(
Direction
:
:
Write
Some
(
cx
)
)
.
map_err
(
|
e
|
{
coop
.
made_progress
(
)
;
e
}
)
?
;
match
v
{
Some
(
v
)
=
>
{
coop
.
made_progress
(
)
;
Poll
:
:
Ready
(
Ok
(
v
)
)
}
None
=
>
Poll
:
:
Pending
}
}
pub
fn
take_write_ready
(
&
self
)
-
>
io
:
:
Result
<
Option
<
mio
:
:
Ready
>
>
{
self
.
poll_ready
(
Direction
:
:
Write
None
)
}
fn
poll_ready
(
&
self
direction
:
Direction
cx
:
Option
<
&
mut
Context
<
'
_
>
>
)
-
>
io
:
:
Result
<
Option
<
mio
:
:
Ready
>
>
{
let
inner
=
match
self
.
handle
.
inner
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
reactor
gone
"
)
)
}
;
if
let
Some
(
ref
cx
)
=
cx
{
inner
.
register
(
self
.
address
direction
cx
.
waker
(
)
.
clone
(
)
)
}
let
mask
=
direction
.
mask
(
)
;
let
mask_no_hup
=
(
mask
-
platform
:
:
hup
(
)
-
platform
:
:
error
(
)
)
.
as_usize
(
)
;
let
sched
=
inner
.
io_dispatch
.
get
(
self
.
address
)
.
unwrap
(
)
;
let
curr_ready
=
sched
.
set_readiness
(
self
.
address
|
curr
|
curr
&
(
!
mask_no_hup
)
)
.
unwrap_or_else
(
|
_
|
panic
!
(
"
address
{
:
?
}
no
longer
valid
!
"
self
.
address
)
)
;
let
mut
ready
=
mask
&
mio
:
:
Ready
:
:
from_usize
(
curr_ready
)
;
if
ready
.
is_empty
(
)
{
if
let
Some
(
cx
)
=
cx
{
match
direction
{
Direction
:
:
Read
=
>
sched
.
reader
.
register_by_ref
(
cx
.
waker
(
)
)
Direction
:
:
Write
=
>
sched
.
writer
.
register_by_ref
(
cx
.
waker
(
)
)
}
let
curr_ready
=
sched
.
set_readiness
(
self
.
address
|
curr
|
curr
&
(
!
mask_no_hup
)
)
.
unwrap_or_else
(
|
_
|
panic
!
(
"
address
{
:
?
}
no
longer
valid
!
"
self
.
address
)
)
;
ready
=
mask
&
mio
:
:
Ready
:
:
from_usize
(
curr_ready
)
;
}
}
if
ready
.
is_empty
(
)
{
Ok
(
None
)
}
else
{
Ok
(
Some
(
ready
)
)
}
}
}
unsafe
impl
Send
for
Registration
{
}
unsafe
impl
Sync
for
Registration
{
}
impl
Drop
for
Registration
{
fn
drop
(
&
mut
self
)
{
let
inner
=
match
self
.
handle
.
inner
(
)
{
Some
(
inner
)
=
>
inner
None
=
>
return
}
;
inner
.
drop_source
(
self
.
address
)
;
}
}
