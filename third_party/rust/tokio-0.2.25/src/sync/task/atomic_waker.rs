#
!
[
cfg_attr
(
any
(
loom
not
(
feature
=
"
sync
"
)
)
allow
(
dead_code
unreachable_pub
)
)
]
use
crate
:
:
loom
:
:
cell
:
:
UnsafeCell
;
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
{
self
AtomicUsize
}
;
use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
AcqRel
Acquire
Release
}
;
use
std
:
:
task
:
:
Waker
;
pub
(
crate
)
struct
AtomicWaker
{
state
:
AtomicUsize
waker
:
UnsafeCell
<
Option
<
Waker
>
>
}
const
WAITING
:
usize
=
0
;
const
REGISTERING
:
usize
=
0b01
;
const
WAKING
:
usize
=
0b10
;
impl
AtomicWaker
{
pub
(
crate
)
fn
new
(
)
-
>
AtomicWaker
{
AtomicWaker
{
state
:
AtomicUsize
:
:
new
(
WAITING
)
waker
:
UnsafeCell
:
:
new
(
None
)
}
}
#
[
cfg
(
feature
=
"
io
-
driver
"
)
]
pub
(
crate
)
fn
register
(
&
self
waker
:
Waker
)
{
self
.
do_register
(
waker
)
;
}
pub
(
crate
)
fn
register_by_ref
(
&
self
waker
:
&
Waker
)
{
self
.
do_register
(
waker
)
;
}
fn
do_register
<
W
>
(
&
self
waker
:
W
)
where
W
:
WakerRef
{
match
self
.
state
.
compare_and_swap
(
WAITING
REGISTERING
Acquire
)
{
WAITING
=
>
{
unsafe
{
self
.
waker
.
with_mut
(
|
t
|
*
t
=
Some
(
waker
.
into_waker
(
)
)
)
;
let
res
=
self
.
state
.
compare_exchange
(
REGISTERING
WAITING
AcqRel
Acquire
)
;
match
res
{
Ok
(
_
)
=
>
{
}
Err
(
actual
)
=
>
{
debug_assert_eq
!
(
actual
REGISTERING
|
WAKING
)
;
let
waker
=
self
.
waker
.
with_mut
(
|
t
|
(
*
t
)
.
take
(
)
)
.
unwrap
(
)
;
self
.
state
.
swap
(
WAITING
AcqRel
)
;
waker
.
wake
(
)
;
}
}
}
}
WAKING
=
>
{
waker
.
wake
(
)
;
atomic
:
:
spin_loop_hint
(
)
;
}
state
=
>
{
debug_assert
!
(
state
=
=
REGISTERING
|
|
state
=
=
REGISTERING
|
WAKING
)
;
}
}
}
pub
(
crate
)
fn
wake
(
&
self
)
{
if
let
Some
(
waker
)
=
self
.
take_waker
(
)
{
waker
.
wake
(
)
;
}
}
pub
(
crate
)
fn
take_waker
(
&
self
)
-
>
Option
<
Waker
>
{
match
self
.
state
.
fetch_or
(
WAKING
AcqRel
)
{
WAITING
=
>
{
let
waker
=
unsafe
{
self
.
waker
.
with_mut
(
|
t
|
(
*
t
)
.
take
(
)
)
}
;
self
.
state
.
fetch_and
(
!
WAKING
Release
)
;
waker
}
state
=
>
{
debug_assert
!
(
state
=
=
REGISTERING
|
|
state
=
=
REGISTERING
|
WAKING
|
|
state
=
=
WAKING
)
;
None
}
}
}
}
impl
Default
for
AtomicWaker
{
fn
default
(
)
-
>
Self
{
AtomicWaker
:
:
new
(
)
}
}
impl
fmt
:
:
Debug
for
AtomicWaker
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
AtomicWaker
"
)
}
}
unsafe
impl
Send
for
AtomicWaker
{
}
unsafe
impl
Sync
for
AtomicWaker
{
}
trait
WakerRef
{
fn
wake
(
self
)
;
fn
into_waker
(
self
)
-
>
Waker
;
}
impl
WakerRef
for
Waker
{
fn
wake
(
self
)
{
self
.
wake
(
)
}
fn
into_waker
(
self
)
-
>
Waker
{
self
}
}
impl
WakerRef
for
&
Waker
{
fn
wake
(
self
)
{
self
.
wake_by_ref
(
)
}
fn
into_waker
(
self
)
-
>
Waker
{
self
.
clone
(
)
}
}
