use
crate
:
:
loom
:
:
{
sync
:
:
atomic
:
:
{
AtomicPtr
AtomicUsize
}
thread
}
;
use
crate
:
:
sync
:
:
mpsc
:
:
block
:
:
{
self
Block
}
;
use
std
:
:
fmt
;
use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
AcqRel
Acquire
Relaxed
Release
}
;
pub
(
crate
)
struct
Tx
<
T
>
{
block_tail
:
AtomicPtr
<
Block
<
T
>
>
tail_position
:
AtomicUsize
}
pub
(
crate
)
struct
Rx
<
T
>
{
head
:
NonNull
<
Block
<
T
>
>
index
:
usize
free_head
:
NonNull
<
Block
<
T
>
>
}
pub
(
crate
)
fn
channel
<
T
>
(
)
-
>
(
Tx
<
T
>
Rx
<
T
>
)
{
let
initial_block
=
Box
:
:
new
(
Block
:
:
new
(
0
)
)
;
let
initial_block_ptr
=
Box
:
:
into_raw
(
initial_block
)
;
let
tx
=
Tx
{
block_tail
:
AtomicPtr
:
:
new
(
initial_block_ptr
)
tail_position
:
AtomicUsize
:
:
new
(
0
)
}
;
let
head
=
NonNull
:
:
new
(
initial_block_ptr
)
.
unwrap
(
)
;
let
rx
=
Rx
{
head
index
:
0
free_head
:
head
}
;
(
tx
rx
)
}
impl
<
T
>
Tx
<
T
>
{
pub
(
crate
)
fn
push
(
&
self
value
:
T
)
{
let
slot_index
=
self
.
tail_position
.
fetch_add
(
1
Acquire
)
;
let
block
=
self
.
find_block
(
slot_index
)
;
unsafe
{
block
.
as_ref
(
)
.
write
(
slot_index
value
)
;
}
}
pub
(
crate
)
fn
close
(
&
self
)
{
let
slot_index
=
self
.
tail_position
.
fetch_add
(
1
Acquire
)
;
let
block
=
self
.
find_block
(
slot_index
)
;
unsafe
{
block
.
as_ref
(
)
.
tx_close
(
)
}
}
fn
find_block
(
&
self
slot_index
:
usize
)
-
>
NonNull
<
Block
<
T
>
>
{
let
start_index
=
block
:
:
start_index
(
slot_index
)
;
let
offset
=
block
:
:
offset
(
slot_index
)
;
let
mut
block_ptr
=
self
.
block_tail
.
load
(
Acquire
)
;
let
block
=
unsafe
{
&
*
block_ptr
}
;
let
distance
=
block
.
distance
(
start_index
)
;
let
mut
try_updating_tail
=
distance
>
offset
;
loop
{
let
block
=
unsafe
{
&
(
*
block_ptr
)
}
;
if
block
.
is_at_index
(
start_index
)
{
return
unsafe
{
NonNull
:
:
new_unchecked
(
block_ptr
)
}
;
}
let
next_block
=
block
.
load_next
(
Acquire
)
.
unwrap_or_else
(
|
|
block
.
grow
(
)
)
;
try_updating_tail
&
=
block
.
is_final
(
)
;
if
try_updating_tail
{
let
actual
=
self
.
block_tail
.
compare_and_swap
(
block_ptr
next_block
.
as_ptr
(
)
Release
)
;
if
actual
=
=
block_ptr
{
let
tail_position
=
self
.
tail_position
.
fetch_add
(
0
Release
)
;
unsafe
{
block
.
tx_release
(
tail_position
)
;
}
}
else
{
try_updating_tail
=
false
;
}
}
block_ptr
=
next_block
.
as_ptr
(
)
;
thread
:
:
yield_now
(
)
;
}
}
pub
(
crate
)
unsafe
fn
reclaim_block
(
&
self
mut
block
:
NonNull
<
Block
<
T
>
>
)
{
block
.
as_mut
(
)
.
reclaim
(
)
;
let
mut
reused
=
false
;
let
curr_ptr
=
self
.
block_tail
.
load
(
Acquire
)
;
debug_assert
!
(
!
curr_ptr
.
is_null
(
)
)
;
let
mut
curr
=
NonNull
:
:
new_unchecked
(
curr_ptr
)
;
for
_
in
0
.
.
3
{
match
curr
.
as_ref
(
)
.
try_push
(
&
mut
block
AcqRel
)
{
Ok
(
_
)
=
>
{
reused
=
true
;
break
;
}
Err
(
next
)
=
>
{
curr
=
next
;
}
}
}
if
!
reused
{
let
_
=
Box
:
:
from_raw
(
block
.
as_ptr
(
)
)
;
}
}
}
impl
<
T
>
fmt
:
:
Debug
for
Tx
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Tx
"
)
.
field
(
"
block_tail
"
&
self
.
block_tail
.
load
(
Relaxed
)
)
.
field
(
"
tail_position
"
&
self
.
tail_position
.
load
(
Relaxed
)
)
.
finish
(
)
}
}
impl
<
T
>
Rx
<
T
>
{
pub
(
crate
)
fn
pop
(
&
mut
self
tx
:
&
Tx
<
T
>
)
-
>
Option
<
block
:
:
Read
<
T
>
>
{
if
!
self
.
try_advancing_head
(
)
{
return
None
;
}
self
.
reclaim_blocks
(
tx
)
;
unsafe
{
let
block
=
self
.
head
.
as_ref
(
)
;
let
ret
=
block
.
read
(
self
.
index
)
;
if
let
Some
(
block
:
:
Read
:
:
Value
(
.
.
)
)
=
ret
{
self
.
index
=
self
.
index
.
wrapping_add
(
1
)
;
}
ret
}
}
fn
try_advancing_head
(
&
mut
self
)
-
>
bool
{
let
block_index
=
block
:
:
start_index
(
self
.
index
)
;
loop
{
let
next_block
=
{
let
block
=
unsafe
{
self
.
head
.
as_ref
(
)
}
;
if
block
.
is_at_index
(
block_index
)
{
return
true
;
}
block
.
load_next
(
Acquire
)
}
;
let
next_block
=
match
next_block
{
Some
(
next_block
)
=
>
next_block
None
=
>
{
return
false
;
}
}
;
self
.
head
=
next_block
;
thread
:
:
yield_now
(
)
;
}
}
fn
reclaim_blocks
(
&
mut
self
tx
:
&
Tx
<
T
>
)
{
while
self
.
free_head
!
=
self
.
head
{
unsafe
{
let
block
=
self
.
free_head
;
let
observed_tail_position
=
block
.
as_ref
(
)
.
observed_tail_position
(
)
;
let
required_index
=
match
observed_tail_position
{
Some
(
i
)
=
>
i
None
=
>
return
}
;
if
required_index
>
self
.
index
{
return
;
}
let
next_block
=
block
.
as_ref
(
)
.
load_next
(
Relaxed
)
;
self
.
free_head
=
next_block
.
unwrap
(
)
;
tx
.
reclaim_block
(
block
)
;
}
thread
:
:
yield_now
(
)
;
}
}
pub
(
super
)
unsafe
fn
free_blocks
(
&
mut
self
)
{
debug_assert_ne
!
(
self
.
free_head
NonNull
:
:
dangling
(
)
)
;
let
mut
cur
=
Some
(
self
.
free_head
)
;
#
[
cfg
(
debug_assertions
)
]
{
self
.
free_head
=
NonNull
:
:
dangling
(
)
;
self
.
head
=
NonNull
:
:
dangling
(
)
;
}
while
let
Some
(
block
)
=
cur
{
cur
=
block
.
as_ref
(
)
.
load_next
(
Relaxed
)
;
drop
(
Box
:
:
from_raw
(
block
.
as_ptr
(
)
)
)
;
}
}
}
impl
<
T
>
fmt
:
:
Debug
for
Rx
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
Rx
"
)
.
field
(
"
head
"
&
self
.
head
)
.
field
(
"
index
"
&
self
.
index
)
.
field
(
"
free_head
"
&
self
.
free_head
)
.
finish
(
)
}
}
