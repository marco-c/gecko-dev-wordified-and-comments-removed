use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
;
#
[
derive
(
Debug
)
]
pub
struct
SendError
<
T
>
(
pub
T
)
;
impl
<
T
>
fmt
:
:
Display
for
SendError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
channel
closed
"
)
}
}
impl
<
T
:
fmt
:
:
Debug
>
std
:
:
error
:
:
Error
for
SendError
<
T
>
{
}
#
[
derive
(
Debug
)
]
pub
enum
TrySendError
<
T
>
{
Full
(
T
)
Closed
(
T
)
}
impl
<
T
:
fmt
:
:
Debug
>
Error
for
TrySendError
<
T
>
{
}
impl
<
T
>
fmt
:
:
Display
for
TrySendError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
match
self
{
TrySendError
:
:
Full
(
.
.
)
=
>
"
no
available
capacity
"
TrySendError
:
:
Closed
(
.
.
)
=
>
"
channel
closed
"
}
)
}
}
impl
<
T
>
From
<
SendError
<
T
>
>
for
TrySendError
<
T
>
{
fn
from
(
src
:
SendError
<
T
>
)
-
>
TrySendError
<
T
>
{
TrySendError
:
:
Closed
(
src
.
0
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
RecvError
(
(
)
)
;
impl
fmt
:
:
Display
for
RecvError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
channel
closed
"
)
}
}
impl
Error
for
RecvError
{
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
TryRecvError
{
Empty
Closed
}
impl
fmt
:
:
Display
for
TryRecvError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
match
self
{
TryRecvError
:
:
Empty
=
>
"
channel
empty
"
TryRecvError
:
:
Closed
=
>
"
channel
closed
"
}
)
}
}
impl
Error
for
TryRecvError
{
}
#
[
derive
(
Debug
)
]
pub
struct
ClosedError
(
(
)
)
;
impl
ClosedError
{
pub
(
crate
)
fn
new
(
)
-
>
ClosedError
{
ClosedError
(
(
)
)
}
}
impl
fmt
:
:
Display
for
ClosedError
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
channel
closed
"
)
}
}
impl
Error
for
ClosedError
{
}
cfg_time
!
{
/
/
=
=
=
=
=
SendTimeoutError
=
=
=
=
=
#
[
derive
(
Debug
)
]
/
/
/
Error
returned
by
[
Sender
:
:
send_timeout
]
(
super
:
:
Sender
:
:
send_timeout
)
]
.
pub
enum
SendTimeoutError
<
T
>
{
/
/
/
The
data
could
not
be
sent
on
the
channel
because
the
channel
is
/
/
/
full
and
the
timeout
to
send
has
elapsed
.
Timeout
(
T
)
/
/
/
The
receive
half
of
the
channel
was
explicitly
closed
or
has
been
/
/
/
dropped
.
Closed
(
T
)
}
impl
<
T
:
fmt
:
:
Debug
>
Error
for
SendTimeoutError
<
T
>
{
}
impl
<
T
>
fmt
:
:
Display
for
SendTimeoutError
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
{
}
"
match
self
{
SendTimeoutError
:
:
Timeout
(
.
.
)
=
>
"
timed
out
waiting
on
send
operation
"
SendTimeoutError
:
:
Closed
(
.
.
)
=
>
"
channel
closed
"
}
)
}
}
}
