use
crate
:
:
loom
:
:
cell
:
:
UnsafeCell
;
use
crate
:
:
loom
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
crate
:
:
loom
:
:
sync
:
:
{
Arc
Mutex
RwLock
RwLockReadGuard
}
;
use
crate
:
:
util
:
:
linked_list
:
:
{
self
LinkedList
}
;
use
std
:
:
fmt
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
PhantomPinned
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
ptr
:
:
NonNull
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
use
std
:
:
task
:
:
{
Context
Poll
Waker
}
;
use
std
:
:
usize
;
pub
struct
Sender
<
T
>
{
shared
:
Arc
<
Shared
<
T
>
>
}
pub
struct
Receiver
<
T
>
{
shared
:
Arc
<
Shared
<
T
>
>
next
:
u64
waiter
:
Option
<
Pin
<
Box
<
UnsafeCell
<
Waiter
>
>
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
SendError
<
T
>
(
pub
T
)
;
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
RecvError
{
Closed
Lagged
(
u64
)
}
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
TryRecvError
{
Empty
Closed
Lagged
(
u64
)
}
struct
Shared
<
T
>
{
buffer
:
Box
<
[
RwLock
<
Slot
<
T
>
>
]
>
mask
:
usize
tail
:
Mutex
<
Tail
>
num_tx
:
AtomicUsize
}
struct
Tail
{
pos
:
u64
rx_cnt
:
usize
closed
:
bool
waiters
:
LinkedList
<
Waiter
>
}
struct
Slot
<
T
>
{
rem
:
AtomicUsize
pos
:
u64
closed
:
bool
val
:
UnsafeCell
<
Option
<
T
>
>
}
struct
Waiter
{
queued
:
bool
waker
:
Option
<
Waker
>
pointers
:
linked_list
:
:
Pointers
<
Waiter
>
_p
:
PhantomPinned
}
struct
RecvGuard
<
'
a
T
>
{
slot
:
RwLockReadGuard
<
'
a
Slot
<
T
>
>
}
struct
Recv
<
R
T
>
where
R
:
AsMut
<
Receiver
<
T
>
>
{
receiver
:
R
waiter
:
UnsafeCell
<
Waiter
>
_p
:
std
:
:
marker
:
:
PhantomData
<
T
>
}
struct
Borrow
<
T
>
(
T
)
;
impl
<
T
>
AsMut
<
Receiver
<
T
>
>
for
Borrow
<
Receiver
<
T
>
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
Receiver
<
T
>
{
&
mut
self
.
0
}
}
impl
<
'
a
T
>
AsMut
<
Receiver
<
T
>
>
for
Borrow
<
&
'
a
mut
Receiver
<
T
>
>
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
Receiver
<
T
>
{
&
mut
*
self
.
0
}
}
unsafe
impl
<
R
:
AsMut
<
Receiver
<
T
>
>
+
Send
T
:
Send
>
Send
for
Recv
<
R
T
>
{
}
unsafe
impl
<
R
:
AsMut
<
Receiver
<
T
>
>
+
Sync
T
:
Send
>
Sync
for
Recv
<
R
T
>
{
}
const
MAX_RECEIVERS
:
usize
=
usize
:
:
MAX
>
>
2
;
pub
fn
channel
<
T
>
(
mut
capacity
:
usize
)
-
>
(
Sender
<
T
>
Receiver
<
T
>
)
{
assert
!
(
capacity
>
0
"
capacity
is
empty
"
)
;
assert
!
(
capacity
<
=
usize
:
:
MAX
>
>
1
"
requested
capacity
too
large
"
)
;
capacity
=
capacity
.
next_power_of_two
(
)
;
let
mut
buffer
=
Vec
:
:
with_capacity
(
capacity
)
;
for
i
in
0
.
.
capacity
{
buffer
.
push
(
RwLock
:
:
new
(
Slot
{
rem
:
AtomicUsize
:
:
new
(
0
)
pos
:
(
i
as
u64
)
.
wrapping_sub
(
capacity
as
u64
)
closed
:
false
val
:
UnsafeCell
:
:
new
(
None
)
}
)
)
;
}
let
shared
=
Arc
:
:
new
(
Shared
{
buffer
:
buffer
.
into_boxed_slice
(
)
mask
:
capacity
-
1
tail
:
Mutex
:
:
new
(
Tail
{
pos
:
0
rx_cnt
:
1
closed
:
false
waiters
:
LinkedList
:
:
new
(
)
}
)
num_tx
:
AtomicUsize
:
:
new
(
1
)
}
)
;
let
rx
=
Receiver
{
shared
:
shared
.
clone
(
)
next
:
0
waiter
:
None
}
;
let
tx
=
Sender
{
shared
}
;
(
tx
rx
)
}
unsafe
impl
<
T
:
Send
>
Send
for
Sender
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Sender
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Send
for
Receiver
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Sync
for
Receiver
<
T
>
{
}
impl
<
T
>
Sender
<
T
>
{
pub
fn
send
(
&
self
value
:
T
)
-
>
Result
<
usize
SendError
<
T
>
>
{
self
.
send2
(
Some
(
value
)
)
.
map_err
(
|
SendError
(
maybe_v
)
|
SendError
(
maybe_v
.
unwrap
(
)
)
)
}
pub
fn
subscribe
(
&
self
)
-
>
Receiver
<
T
>
{
let
shared
=
self
.
shared
.
clone
(
)
;
let
mut
tail
=
shared
.
tail
.
lock
(
)
.
unwrap
(
)
;
if
tail
.
rx_cnt
=
=
MAX_RECEIVERS
{
panic
!
(
"
max
receivers
"
)
;
}
tail
.
rx_cnt
=
tail
.
rx_cnt
.
checked_add
(
1
)
.
expect
(
"
overflow
"
)
;
let
next
=
tail
.
pos
;
drop
(
tail
)
;
Receiver
{
shared
next
waiter
:
None
}
}
pub
fn
receiver_count
(
&
self
)
-
>
usize
{
let
tail
=
self
.
shared
.
tail
.
lock
(
)
.
unwrap
(
)
;
tail
.
rx_cnt
}
fn
send2
(
&
self
value
:
Option
<
T
>
)
-
>
Result
<
usize
SendError
<
Option
<
T
>
>
>
{
let
mut
tail
=
self
.
shared
.
tail
.
lock
(
)
.
unwrap
(
)
;
if
tail
.
rx_cnt
=
=
0
{
return
Err
(
SendError
(
value
)
)
;
}
let
pos
=
tail
.
pos
;
let
rem
=
tail
.
rx_cnt
;
let
idx
=
(
pos
&
self
.
shared
.
mask
as
u64
)
as
usize
;
tail
.
pos
=
tail
.
pos
.
wrapping_add
(
1
)
;
let
mut
slot
=
self
.
shared
.
buffer
[
idx
]
.
write
(
)
.
unwrap
(
)
;
slot
.
pos
=
pos
;
slot
.
rem
.
with_mut
(
|
v
|
*
v
=
rem
)
;
if
value
.
is_none
(
)
{
tail
.
closed
=
true
;
slot
.
closed
=
true
;
}
else
{
slot
.
val
.
with_mut
(
|
ptr
|
unsafe
{
*
ptr
=
value
}
)
;
}
drop
(
slot
)
;
tail
.
notify_rx
(
)
;
drop
(
tail
)
;
Ok
(
rem
)
}
}
impl
Tail
{
fn
notify_rx
(
&
mut
self
)
{
while
let
Some
(
mut
waiter
)
=
self
.
waiters
.
pop_back
(
)
{
let
waiter
=
unsafe
{
waiter
.
as_mut
(
)
}
;
assert
!
(
waiter
.
queued
)
;
waiter
.
queued
=
false
;
let
waker
=
waiter
.
waker
.
take
(
)
.
unwrap
(
)
;
waker
.
wake
(
)
;
}
}
}
impl
<
T
>
Clone
for
Sender
<
T
>
{
fn
clone
(
&
self
)
-
>
Sender
<
T
>
{
let
shared
=
self
.
shared
.
clone
(
)
;
shared
.
num_tx
.
fetch_add
(
1
SeqCst
)
;
Sender
{
shared
}
}
}
impl
<
T
>
Drop
for
Sender
<
T
>
{
fn
drop
(
&
mut
self
)
{
if
1
=
=
self
.
shared
.
num_tx
.
fetch_sub
(
1
SeqCst
)
{
let
_
=
self
.
send2
(
None
)
;
}
}
}
impl
<
T
>
Receiver
<
T
>
{
fn
recv_ref
(
&
mut
self
waiter
:
Option
<
(
&
UnsafeCell
<
Waiter
>
&
Waker
)
>
)
-
>
Result
<
RecvGuard
<
'
_
T
>
TryRecvError
>
{
let
idx
=
(
self
.
next
&
self
.
shared
.
mask
as
u64
)
as
usize
;
let
mut
slot
=
self
.
shared
.
buffer
[
idx
]
.
read
(
)
.
unwrap
(
)
;
if
slot
.
pos
!
=
self
.
next
{
let
next_pos
=
slot
.
pos
.
wrapping_add
(
self
.
shared
.
buffer
.
len
(
)
as
u64
)
;
if
waiter
.
is_none
(
)
&
&
next_pos
=
=
self
.
next
{
return
Err
(
TryRecvError
:
:
Empty
)
;
}
drop
(
slot
)
;
let
mut
tail
=
self
.
shared
.
tail
.
lock
(
)
.
unwrap
(
)
;
slot
=
self
.
shared
.
buffer
[
idx
]
.
read
(
)
.
unwrap
(
)
;
if
slot
.
pos
!
=
self
.
next
{
let
next_pos
=
slot
.
pos
.
wrapping_add
(
self
.
shared
.
buffer
.
len
(
)
as
u64
)
;
if
next_pos
=
=
self
.
next
{
if
let
Some
(
(
waiter
waker
)
)
=
waiter
{
unsafe
{
waiter
.
with_mut
(
|
ptr
|
{
match
(
*
ptr
)
.
waker
{
Some
(
ref
w
)
if
w
.
will_wake
(
waker
)
=
>
{
}
_
=
>
{
(
*
ptr
)
.
waker
=
Some
(
waker
.
clone
(
)
)
;
}
}
if
!
(
*
ptr
)
.
queued
{
(
*
ptr
)
.
queued
=
true
;
tail
.
waiters
.
push_front
(
NonNull
:
:
new_unchecked
(
&
mut
*
ptr
)
)
;
}
}
)
;
}
}
return
Err
(
TryRecvError
:
:
Empty
)
;
}
let
mut
adjust
=
0
;
if
tail
.
closed
{
adjust
=
1
}
let
next
=
tail
.
pos
.
wrapping_sub
(
self
.
shared
.
buffer
.
len
(
)
as
u64
+
adjust
)
;
let
missed
=
next
.
wrapping_sub
(
self
.
next
)
;
drop
(
tail
)
;
if
missed
=
=
0
{
self
.
next
=
self
.
next
.
wrapping_add
(
1
)
;
return
Ok
(
RecvGuard
{
slot
}
)
;
}
self
.
next
=
next
;
return
Err
(
TryRecvError
:
:
Lagged
(
missed
)
)
;
}
}
self
.
next
=
self
.
next
.
wrapping_add
(
1
)
;
if
slot
.
closed
{
return
Err
(
TryRecvError
:
:
Closed
)
;
}
Ok
(
RecvGuard
{
slot
}
)
}
}
impl
<
T
>
Receiver
<
T
>
where
T
:
Clone
{
pub
fn
try_recv
(
&
mut
self
)
-
>
Result
<
T
TryRecvError
>
{
let
guard
=
self
.
recv_ref
(
None
)
?
;
guard
.
clone_value
(
)
.
ok_or
(
TryRecvError
:
:
Closed
)
}
#
[
doc
(
hidden
)
]
#
[
deprecated
(
since
=
"
0
.
2
.
21
"
note
=
"
use
async
fn
recv
(
)
"
)
]
pub
fn
poll_recv
(
&
mut
self
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
T
RecvError
>
>
{
use
Poll
:
:
{
Pending
Ready
}
;
struct
Guard
<
'
a
T
>
{
waiter
:
Option
<
Pin
<
Box
<
UnsafeCell
<
Waiter
>
>
>
>
receiver
:
&
'
a
mut
Receiver
<
T
>
}
impl
<
'
a
T
>
Drop
for
Guard
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
receiver
.
waiter
=
self
.
waiter
.
take
(
)
;
}
}
let
waiter
=
self
.
waiter
.
take
(
)
.
or_else
(
|
|
{
Some
(
Box
:
:
pin
(
UnsafeCell
:
:
new
(
Waiter
{
queued
:
false
waker
:
None
pointers
:
linked_list
:
:
Pointers
:
:
new
(
)
_p
:
PhantomPinned
}
)
)
)
}
)
;
let
guard
=
Guard
{
waiter
receiver
:
self
}
;
let
res
=
guard
.
receiver
.
recv_ref
(
Some
(
(
&
guard
.
waiter
.
as_ref
(
)
.
unwrap
(
)
cx
.
waker
(
)
)
)
)
;
match
res
{
Ok
(
guard
)
=
>
Ready
(
guard
.
clone_value
(
)
.
ok_or
(
RecvError
:
:
Closed
)
)
Err
(
TryRecvError
:
:
Closed
)
=
>
Ready
(
Err
(
RecvError
:
:
Closed
)
)
Err
(
TryRecvError
:
:
Lagged
(
n
)
)
=
>
Ready
(
Err
(
RecvError
:
:
Lagged
(
n
)
)
)
Err
(
TryRecvError
:
:
Empty
)
=
>
Pending
}
}
pub
async
fn
recv
(
&
mut
self
)
-
>
Result
<
T
RecvError
>
{
let
fut
=
Recv
:
:
<
_
T
>
:
:
new
(
Borrow
(
self
)
)
;
fut
.
await
}
}
#
[
cfg
(
feature
=
"
stream
"
)
]
#
[
doc
(
hidden
)
]
impl
<
T
>
crate
:
:
stream
:
:
Stream
for
Receiver
<
T
>
where
T
:
Clone
{
type
Item
=
Result
<
T
RecvError
>
;
fn
poll_next
(
mut
self
:
std
:
:
pin
:
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Result
<
T
RecvError
>
>
>
{
#
[
allow
(
deprecated
)
]
self
.
poll_recv
(
cx
)
.
map
(
|
v
|
match
v
{
Ok
(
v
)
=
>
Some
(
Ok
(
v
)
)
lag
Err
(
RecvError
:
:
Lagged
(
_
)
)
=
>
Some
(
lag
)
Err
(
RecvError
:
:
Closed
)
=
>
None
}
)
}
}
impl
<
T
>
Drop
for
Receiver
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
mut
tail
=
self
.
shared
.
tail
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
waiter
)
=
&
self
.
waiter
{
let
queued
=
waiter
.
with
(
|
ptr
|
unsafe
{
(
*
ptr
)
.
queued
}
)
;
if
queued
{
unsafe
{
waiter
.
with_mut
(
|
ptr
|
{
tail
.
waiters
.
remove
(
(
&
mut
*
ptr
)
.
into
(
)
)
;
}
)
;
}
}
}
tail
.
rx_cnt
-
=
1
;
let
until
=
tail
.
pos
;
drop
(
tail
)
;
while
self
.
next
!
=
until
{
match
self
.
recv_ref
(
None
)
{
Ok
(
_
)
=
>
{
}
Err
(
TryRecvError
:
:
Closed
)
=
>
break
Err
(
TryRecvError
:
:
Lagged
(
.
.
)
)
=
>
{
}
Err
(
TryRecvError
:
:
Empty
)
=
>
panic
!
(
"
unexpected
empty
broadcast
channel
"
)
}
}
}
}
impl
<
R
T
>
Recv
<
R
T
>
where
R
:
AsMut
<
Receiver
<
T
>
>
{
fn
new
(
receiver
:
R
)
-
>
Recv
<
R
T
>
{
Recv
{
receiver
waiter
:
UnsafeCell
:
:
new
(
Waiter
{
queued
:
false
waker
:
None
pointers
:
linked_list
:
:
Pointers
:
:
new
(
)
_p
:
PhantomPinned
}
)
_p
:
std
:
:
marker
:
:
PhantomData
}
}
fn
project
(
self
:
Pin
<
&
mut
Self
>
)
-
>
(
&
mut
Receiver
<
T
>
&
UnsafeCell
<
Waiter
>
)
{
unsafe
{
is_unpin
:
:
<
&
mut
Receiver
<
T
>
>
(
)
;
let
me
=
self
.
get_unchecked_mut
(
)
;
(
me
.
receiver
.
as_mut
(
)
&
me
.
waiter
)
}
}
}
impl
<
R
T
>
Future
for
Recv
<
R
T
>
where
R
:
AsMut
<
Receiver
<
T
>
>
T
:
Clone
{
type
Output
=
Result
<
T
RecvError
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
T
RecvError
>
>
{
let
(
receiver
waiter
)
=
self
.
project
(
)
;
let
guard
=
match
receiver
.
recv_ref
(
Some
(
(
waiter
cx
.
waker
(
)
)
)
)
{
Ok
(
value
)
=
>
value
Err
(
TryRecvError
:
:
Empty
)
=
>
return
Poll
:
:
Pending
Err
(
TryRecvError
:
:
Lagged
(
n
)
)
=
>
return
Poll
:
:
Ready
(
Err
(
RecvError
:
:
Lagged
(
n
)
)
)
Err
(
TryRecvError
:
:
Closed
)
=
>
return
Poll
:
:
Ready
(
Err
(
RecvError
:
:
Closed
)
)
}
;
Poll
:
:
Ready
(
guard
.
clone_value
(
)
.
ok_or
(
RecvError
:
:
Closed
)
)
}
}
cfg_stream
!
{
use
futures_core
:
:
Stream
;
impl
<
T
:
Clone
>
Receiver
<
T
>
{
/
/
/
Convert
the
receiver
into
a
Stream
.
pub
fn
into_stream
(
self
)
-
>
impl
Stream
<
Item
=
Result
<
T
RecvError
>
>
{
Recv
:
:
new
(
Borrow
(
self
)
)
}
}
impl
<
R
T
:
Clone
>
Stream
for
Recv
<
R
T
>
where
R
:
AsMut
<
Receiver
<
T
>
>
T
:
Clone
{
type
Item
=
Result
<
T
RecvError
>
;
fn
poll_next
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Self
:
:
Item
>
>
{
let
(
receiver
waiter
)
=
self
.
project
(
)
;
let
guard
=
match
receiver
.
recv_ref
(
Some
(
(
waiter
cx
.
waker
(
)
)
)
)
{
Ok
(
value
)
=
>
value
Err
(
TryRecvError
:
:
Empty
)
=
>
return
Poll
:
:
Pending
Err
(
TryRecvError
:
:
Lagged
(
n
)
)
=
>
return
Poll
:
:
Ready
(
Some
(
Err
(
RecvError
:
:
Lagged
(
n
)
)
)
)
Err
(
TryRecvError
:
:
Closed
)
=
>
return
Poll
:
:
Ready
(
None
)
}
;
Poll
:
:
Ready
(
guard
.
clone_value
(
)
.
map
(
Ok
)
)
}
}
}
impl
<
R
T
>
Drop
for
Recv
<
R
T
>
where
R
:
AsMut
<
Receiver
<
T
>
>
{
fn
drop
(
&
mut
self
)
{
let
mut
tail
=
self
.
receiver
.
as_mut
(
)
.
shared
.
tail
.
lock
(
)
.
unwrap
(
)
;
let
queued
=
self
.
waiter
.
with
(
|
ptr
|
unsafe
{
(
*
ptr
)
.
queued
}
)
;
if
queued
{
unsafe
{
self
.
waiter
.
with_mut
(
|
ptr
|
{
tail
.
waiters
.
remove
(
(
&
mut
*
ptr
)
.
into
(
)
)
;
}
)
;
}
}
}
}
unsafe
impl
linked_list
:
:
Link
for
Waiter
{
type
Handle
=
NonNull
<
Waiter
>
;
type
Target
=
Waiter
;
fn
as_raw
(
handle
:
&
NonNull
<
Waiter
>
)
-
>
NonNull
<
Waiter
>
{
*
handle
}
unsafe
fn
from_raw
(
ptr
:
NonNull
<
Waiter
>
)
-
>
NonNull
<
Waiter
>
{
ptr
}
unsafe
fn
pointers
(
mut
target
:
NonNull
<
Waiter
>
)
-
>
NonNull
<
linked_list
:
:
Pointers
<
Waiter
>
>
{
NonNull
:
:
from
(
&
mut
target
.
as_mut
(
)
.
pointers
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Sender
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
broadcast
:
:
Sender
"
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Receiver
<
T
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
broadcast
:
:
Receiver
"
)
}
}
impl
<
'
a
T
>
RecvGuard
<
'
a
T
>
{
fn
clone_value
(
&
self
)
-
>
Option
<
T
>
where
T
:
Clone
{
self
.
slot
.
val
.
with
(
|
ptr
|
unsafe
{
(
*
ptr
)
.
clone
(
)
}
)
}
}
impl
<
'
a
T
>
Drop
for
RecvGuard
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
if
1
=
=
self
.
slot
.
rem
.
fetch_sub
(
1
SeqCst
)
{
self
.
slot
.
val
.
with_mut
(
|
ptr
|
unsafe
{
*
ptr
=
None
}
)
;
}
}
}
impl
fmt
:
:
Display
for
RecvError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
RecvError
:
:
Closed
=
>
write
!
(
f
"
channel
closed
"
)
RecvError
:
:
Lagged
(
amt
)
=
>
write
!
(
f
"
channel
lagged
by
{
}
"
amt
)
}
}
}
impl
std
:
:
error
:
:
Error
for
RecvError
{
}
impl
fmt
:
:
Display
for
TryRecvError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
TryRecvError
:
:
Empty
=
>
write
!
(
f
"
channel
empty
"
)
TryRecvError
:
:
Closed
=
>
write
!
(
f
"
channel
closed
"
)
TryRecvError
:
:
Lagged
(
amt
)
=
>
write
!
(
f
"
channel
lagged
by
{
}
"
amt
)
}
}
}
impl
std
:
:
error
:
:
Error
for
TryRecvError
{
}
fn
is_unpin
<
T
:
Unpin
>
(
)
{
}
