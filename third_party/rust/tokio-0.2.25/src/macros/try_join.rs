#
[
macro_export
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
macros
"
)
)
)
]
macro_rules
!
try_join
{
(
{
(
(
count
:
tt
)
*
)
(
(
(
skip
:
tt
)
*
)
e
:
expr
)
*
}
)
=
>
{
{
use
crate
:
:
macros
:
:
support
:
:
{
maybe_done
poll_fn
Future
Pin
}
;
use
crate
:
:
macros
:
:
support
:
:
Poll
:
:
{
Ready
Pending
}
;
/
/
Safety
:
nothing
must
be
moved
out
of
futures
.
This
is
to
satisfy
/
/
the
requirement
of
Pin
:
:
new_unchecked
called
below
.
let
mut
futures
=
(
(
maybe_done
(
e
)
)
*
)
;
poll_fn
(
move
|
cx
|
{
let
mut
is_pending
=
false
;
(
let
(
(
skip
)
*
fut
.
.
)
=
&
mut
futures
;
let
mut
fut
=
unsafe
{
Pin
:
:
new_unchecked
(
fut
)
}
;
if
fut
.
as_mut
(
)
.
poll
(
cx
)
.
is_pending
(
)
{
is_pending
=
true
;
}
else
if
fut
.
as_mut
(
)
.
output_mut
(
)
.
expect
(
"
expected
completed
future
"
)
.
is_err
(
)
{
return
Ready
(
Err
(
fut
.
take_output
(
)
.
expect
(
"
expected
completed
future
"
)
.
err
(
)
.
unwrap
(
)
)
)
}
)
*
if
is_pending
{
Pending
}
else
{
Ready
(
Ok
(
(
(
{
/
/
Extract
the
future
for
this
branch
from
the
tuple
.
let
(
(
skip
)
*
fut
.
.
)
=
&
mut
futures
;
/
/
Safety
:
future
is
stored
on
the
stack
above
/
/
and
never
moved
.
let
mut
fut
=
unsafe
{
Pin
:
:
new_unchecked
(
fut
)
}
;
fut
.
take_output
(
)
.
expect
(
"
expected
completed
future
"
)
.
ok
(
)
.
expect
(
"
expected
Ok
(
_
)
"
)
}
)
*
)
)
)
}
}
)
.
await
}
}
;
(
{
(
(
s
:
tt
)
*
)
(
t
:
tt
)
*
}
e
:
expr
(
r
:
tt
)
*
)
=
>
{
crate
:
:
try_join
!
(
{
(
(
s
)
*
_
)
(
t
)
*
(
(
s
)
*
)
e
}
(
r
)
*
)
}
;
(
(
e
:
expr
)
*
(
)
?
)
=
>
{
crate
:
:
try_join
!
(
{
(
)
}
(
e
)
*
)
}
;
}
