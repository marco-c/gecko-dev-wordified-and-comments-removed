use
crate
:
:
time
:
:
driver
:
:
Entry
;
use
crate
:
:
time
:
:
Error
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicPtr
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
SeqCst
;
use
std
:
:
sync
:
:
Arc
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
AtomicStack
{
head
:
AtomicPtr
<
Entry
>
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
AtomicStackEntries
{
ptr
:
*
mut
Entry
}
const
SHUTDOWN
:
*
mut
Entry
=
1
as
*
mut
_
;
impl
AtomicStack
{
pub
(
crate
)
fn
new
(
)
-
>
AtomicStack
{
AtomicStack
{
head
:
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
}
}
pub
(
crate
)
fn
push
(
&
self
entry
:
&
Arc
<
Entry
>
)
-
>
Result
<
bool
Error
>
{
let
queued
=
entry
.
queued
.
fetch_or
(
true
SeqCst
)
;
if
queued
{
return
Ok
(
false
)
;
}
let
ptr
=
Arc
:
:
into_raw
(
entry
.
clone
(
)
)
as
*
mut
_
;
let
mut
curr
=
self
.
head
.
load
(
SeqCst
)
;
loop
{
if
curr
=
=
SHUTDOWN
{
let
_
=
unsafe
{
Arc
:
:
from_raw
(
ptr
)
}
;
return
Err
(
Error
:
:
shutdown
(
)
)
;
}
unsafe
{
*
(
entry
.
next_atomic
.
get
(
)
)
=
curr
;
}
let
actual
=
self
.
head
.
compare_and_swap
(
curr
ptr
SeqCst
)
;
if
actual
=
=
curr
{
break
;
}
curr
=
actual
;
}
Ok
(
true
)
}
pub
(
crate
)
fn
take
(
&
self
)
-
>
AtomicStackEntries
{
let
ptr
=
self
.
head
.
swap
(
ptr
:
:
null_mut
(
)
SeqCst
)
;
AtomicStackEntries
{
ptr
}
}
pub
(
crate
)
fn
shutdown
(
&
self
)
{
let
ptr
=
self
.
head
.
swap
(
SHUTDOWN
SeqCst
)
;
drop
(
AtomicStackEntries
{
ptr
}
)
;
}
}
impl
Iterator
for
AtomicStackEntries
{
type
Item
=
Arc
<
Entry
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
ptr
.
is_null
(
)
|
|
self
.
ptr
=
=
SHUTDOWN
{
return
None
;
}
let
entry
=
unsafe
{
Arc
:
:
from_raw
(
self
.
ptr
)
}
;
self
.
ptr
=
unsafe
{
*
entry
.
next_atomic
.
get
(
)
}
;
let
res
=
entry
.
queued
.
fetch_and
(
false
SeqCst
)
;
debug_assert
!
(
res
)
;
Some
(
entry
)
}
}
impl
Drop
for
AtomicStackEntries
{
fn
drop
(
&
mut
self
)
{
for
entry
in
self
{
entry
.
error
(
Error
:
:
shutdown
(
)
)
;
}
}
}
