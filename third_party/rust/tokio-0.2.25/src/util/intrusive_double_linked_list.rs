#
!
[
allow
(
dead_code
unreachable_pub
)
]
use
core
:
:
{
marker
:
:
PhantomPinned
ops
:
:
{
Deref
DerefMut
}
ptr
:
:
NonNull
}
;
#
[
derive
(
Debug
)
]
pub
struct
ListNode
<
T
>
{
prev
:
Option
<
NonNull
<
ListNode
<
T
>
>
>
next
:
Option
<
NonNull
<
ListNode
<
T
>
>
>
data
:
T
_pin
:
PhantomPinned
}
impl
<
T
>
ListNode
<
T
>
{
pub
fn
new
(
data
:
T
)
-
>
ListNode
<
T
>
{
Self
{
prev
:
None
next
:
None
data
_pin
:
PhantomPinned
}
}
}
impl
<
T
>
Deref
for
ListNode
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
&
self
.
data
}
}
impl
<
T
>
DerefMut
for
ListNode
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
T
{
&
mut
self
.
data
}
}
#
[
derive
(
Debug
)
]
pub
struct
LinkedList
<
T
>
{
head
:
Option
<
NonNull
<
ListNode
<
T
>
>
>
tail
:
Option
<
NonNull
<
ListNode
<
T
>
>
>
}
impl
<
T
>
LinkedList
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
LinkedList
:
:
<
T
>
{
head
:
None
tail
:
None
}
}
pub
unsafe
fn
add_front
(
&
mut
self
node
:
&
mut
ListNode
<
T
>
)
{
node
.
next
=
self
.
head
;
node
.
prev
=
None
;
if
let
Some
(
mut
head
)
=
self
.
head
{
head
.
as_mut
(
)
.
prev
=
Some
(
node
.
into
(
)
)
}
;
self
.
head
=
Some
(
node
.
into
(
)
)
;
if
self
.
tail
.
is_none
(
)
{
self
.
tail
=
Some
(
node
.
into
(
)
)
;
}
}
pub
unsafe
fn
add_sorted
(
&
mut
self
node
:
&
mut
ListNode
<
T
>
)
where
T
:
PartialOrd
{
if
self
.
head
.
is_none
(
)
{
self
.
head
=
Some
(
node
.
into
(
)
)
;
self
.
tail
=
Some
(
node
.
into
(
)
)
;
return
;
}
let
mut
prev
:
Option
<
NonNull
<
ListNode
<
T
>
>
>
=
None
;
let
mut
current
=
self
.
head
;
while
let
Some
(
mut
current_node
)
=
current
{
if
node
.
data
<
current_node
.
as_ref
(
)
.
data
{
current_node
.
as_mut
(
)
.
prev
=
Some
(
node
.
into
(
)
)
;
match
prev
{
Some
(
mut
prev
)
=
>
{
prev
.
as_mut
(
)
.
next
=
Some
(
node
.
into
(
)
)
;
}
None
=
>
{
self
.
head
=
Some
(
node
.
into
(
)
)
;
}
}
node
.
next
=
current
;
node
.
prev
=
prev
;
return
;
}
prev
=
current
;
current
=
current_node
.
as_ref
(
)
.
next
;
}
node
.
prev
=
self
.
tail
;
node
.
next
=
None
;
self
.
tail
.
as_mut
(
)
.
unwrap
(
)
.
as_mut
(
)
.
next
=
Some
(
node
.
into
(
)
)
;
self
.
tail
=
Some
(
node
.
into
(
)
)
;
}
pub
fn
peek_first
(
&
self
)
-
>
Option
<
&
mut
ListNode
<
T
>
>
{
unsafe
{
self
.
head
.
map
(
|
mut
node
|
&
mut
*
(
node
.
as_mut
(
)
as
*
mut
ListNode
<
T
>
)
)
}
}
pub
fn
peek_last
(
&
self
)
-
>
Option
<
&
mut
ListNode
<
T
>
>
{
unsafe
{
self
.
tail
.
map
(
|
mut
node
|
&
mut
*
(
node
.
as_mut
(
)
as
*
mut
ListNode
<
T
>
)
)
}
}
pub
fn
remove_first
(
&
mut
self
)
-
>
Option
<
&
mut
ListNode
<
T
>
>
{
#
!
[
allow
(
clippy
:
:
debug_assert_with_mut_call
)
]
unsafe
{
let
mut
head
=
self
.
head
?
;
self
.
head
=
head
.
as_mut
(
)
.
next
;
let
first_ref
=
head
.
as_mut
(
)
;
match
first_ref
.
next
{
None
=
>
{
debug_assert_eq
!
(
Some
(
first_ref
.
into
(
)
)
self
.
tail
)
;
self
.
tail
=
None
;
}
Some
(
mut
next
)
=
>
{
next
.
as_mut
(
)
.
prev
=
None
;
}
}
first_ref
.
prev
=
None
;
first_ref
.
next
=
None
;
Some
(
&
mut
*
(
first_ref
as
*
mut
ListNode
<
T
>
)
)
}
}
pub
fn
remove_last
(
&
mut
self
)
-
>
Option
<
&
mut
ListNode
<
T
>
>
{
#
!
[
allow
(
clippy
:
:
debug_assert_with_mut_call
)
]
unsafe
{
let
mut
tail
=
self
.
tail
?
;
self
.
tail
=
tail
.
as_mut
(
)
.
prev
;
let
last_ref
=
tail
.
as_mut
(
)
;
match
last_ref
.
prev
{
None
=
>
{
debug_assert_eq
!
(
Some
(
last_ref
.
into
(
)
)
self
.
head
)
;
self
.
head
=
None
;
}
Some
(
mut
prev
)
=
>
{
prev
.
as_mut
(
)
.
next
=
None
;
}
}
last_ref
.
prev
=
None
;
last_ref
.
next
=
None
;
Some
(
&
mut
*
(
last_ref
as
*
mut
ListNode
<
T
>
)
)
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
if
self
.
head
.
is_some
(
)
{
return
false
;
}
debug_assert
!
(
self
.
tail
.
is_none
(
)
)
;
true
}
pub
unsafe
fn
remove
(
&
mut
self
node
:
&
mut
ListNode
<
T
>
)
-
>
bool
{
#
!
[
allow
(
clippy
:
:
debug_assert_with_mut_call
)
]
match
node
.
prev
{
None
=
>
{
if
self
.
head
!
=
Some
(
node
.
into
(
)
)
{
debug_assert
!
(
node
.
next
.
is_none
(
)
)
;
return
false
;
}
self
.
head
=
node
.
next
;
}
Some
(
mut
prev
)
=
>
{
debug_assert_eq
!
(
prev
.
as_ref
(
)
.
next
Some
(
node
.
into
(
)
)
)
;
prev
.
as_mut
(
)
.
next
=
node
.
next
;
}
}
match
node
.
next
{
None
=
>
{
debug_assert_eq
!
(
self
.
tail
Some
(
node
.
into
(
)
)
)
;
self
.
tail
=
node
.
prev
;
}
Some
(
mut
next
)
=
>
{
debug_assert_eq
!
(
next
.
as_mut
(
)
.
prev
Some
(
node
.
into
(
)
)
)
;
next
.
as_mut
(
)
.
prev
=
node
.
prev
;
}
}
node
.
next
=
None
;
node
.
prev
=
None
;
true
}
pub
fn
drain
<
F
>
(
&
mut
self
mut
func
:
F
)
where
F
:
FnMut
(
&
mut
ListNode
<
T
>
)
{
let
mut
current
=
self
.
head
;
self
.
head
=
None
;
self
.
tail
=
None
;
while
let
Some
(
mut
node
)
=
current
{
unsafe
{
let
node_ref
=
node
.
as_mut
(
)
;
current
=
node_ref
.
next
;
node_ref
.
next
=
None
;
node_ref
.
prev
=
None
;
func
(
node_ref
)
;
}
}
}
pub
fn
reverse_drain
<
F
>
(
&
mut
self
mut
func
:
F
)
where
F
:
FnMut
(
&
mut
ListNode
<
T
>
)
{
let
mut
current
=
self
.
tail
;
self
.
head
=
None
;
self
.
tail
=
None
;
while
let
Some
(
mut
node
)
=
current
{
unsafe
{
let
node_ref
=
node
.
as_mut
(
)
;
current
=
node_ref
.
prev
;
node_ref
.
next
=
None
;
node_ref
.
prev
=
None
;
func
(
node_ref
)
;
}
}
}
}
#
[
cfg
(
all
(
test
feature
=
"
std
"
)
)
]
mod
tests
{
use
super
:
:
*
;
fn
collect_list
<
T
:
Copy
>
(
mut
list
:
LinkedList
<
T
>
)
-
>
Vec
<
T
>
{
let
mut
result
=
Vec
:
:
new
(
)
;
list
.
drain
(
|
node
|
{
result
.
push
(
*
*
node
)
;
}
)
;
result
}
fn
collect_reverse_list
<
T
:
Copy
>
(
mut
list
:
LinkedList
<
T
>
)
-
>
Vec
<
T
>
{
let
mut
result
=
Vec
:
:
new
(
)
;
list
.
reverse_drain
(
|
node
|
{
result
.
push
(
*
*
node
)
;
}
)
;
result
}
unsafe
fn
add_nodes
(
list
:
&
mut
LinkedList
<
i32
>
nodes
:
&
mut
[
&
mut
ListNode
<
i32
>
]
)
{
for
node
in
nodes
.
iter_mut
(
)
{
list
.
add_front
(
node
)
;
}
}
unsafe
fn
assert_clean
<
T
>
(
node
:
&
mut
ListNode
<
T
>
)
{
assert
!
(
node
.
next
.
is_none
(
)
)
;
assert
!
(
node
.
prev
.
is_none
(
)
)
;
}
#
[
test
]
fn
insert_and_iterate
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
let
mut
setup
=
|
list
:
&
mut
LinkedList
<
i32
>
|
{
assert_eq
!
(
true
list
.
is_empty
(
)
)
;
list
.
add_front
(
&
mut
c
)
;
assert_eq
!
(
31
*
*
list
.
peek_first
(
)
.
unwrap
(
)
)
;
assert_eq
!
(
false
list
.
is_empty
(
)
)
;
list
.
add_front
(
&
mut
b
)
;
assert_eq
!
(
7
*
*
list
.
peek_first
(
)
.
unwrap
(
)
)
;
list
.
add_front
(
&
mut
a
)
;
assert_eq
!
(
5
*
*
list
.
peek_first
(
)
.
unwrap
(
)
)
;
}
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
setup
(
&
mut
list
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
31
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
setup
(
&
mut
list
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
31
7
5
]
.
to_vec
(
)
items
)
;
}
}
#
[
test
]
fn
add_sorted
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
let
mut
d
=
ListNode
:
:
new
(
99
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
list
.
add_sorted
(
&
mut
a
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
list
.
add_sorted
(
&
mut
a
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
d
&
mut
c
&
mut
b
]
)
;
list
.
add_sorted
(
&
mut
a
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
31
99
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
d
&
mut
c
&
mut
b
]
)
;
list
.
add_sorted
(
&
mut
a
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
99
31
7
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
d
&
mut
c
&
mut
a
]
)
;
list
.
add_sorted
(
&
mut
b
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
31
99
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
d
&
mut
c
&
mut
a
]
)
;
list
.
add_sorted
(
&
mut
b
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
99
31
7
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
d
&
mut
b
&
mut
a
]
)
;
list
.
add_sorted
(
&
mut
c
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
31
99
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
d
&
mut
b
&
mut
a
]
)
;
list
.
add_sorted
(
&
mut
c
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
99
31
7
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
list
.
add_sorted
(
&
mut
d
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
31
99
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
list
.
add_sorted
(
&
mut
d
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
99
31
7
5
]
.
to_vec
(
)
items
)
;
}
}
#
[
test
]
fn
drain_and_collect
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
let
taken_items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
31
]
.
to_vec
(
)
taken_items
)
;
}
}
#
[
test
]
fn
peek_last
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
let
last
=
list
.
peek_last
(
)
;
assert_eq
!
(
31
*
*
last
.
unwrap
(
)
)
;
list
.
remove_last
(
)
;
let
last
=
list
.
peek_last
(
)
;
assert_eq
!
(
7
*
*
last
.
unwrap
(
)
)
;
list
.
remove_last
(
)
;
let
last
=
list
.
peek_last
(
)
;
assert_eq
!
(
5
*
*
last
.
unwrap
(
)
)
;
list
.
remove_last
(
)
;
let
last
=
list
.
peek_last
(
)
;
assert
!
(
last
.
is_none
(
)
)
;
}
}
#
[
test
]
fn
remove_first
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_first
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
7
31
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_first
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
31
7
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_first
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
7
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_first
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
7
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
a
]
)
;
let
removed
=
list
.
remove_first
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert
!
(
items
.
is_empty
(
)
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
a
]
)
;
let
removed
=
list
.
remove_first
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert
!
(
items
.
is_empty
(
)
)
;
}
}
#
[
test
]
fn
remove_last
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_last
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_last
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
7
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_last
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
let
removed
=
list
.
remove_last
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
!
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
a
]
)
;
let
removed
=
list
.
remove_last
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert
!
(
items
.
is_empty
(
)
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
a
]
)
;
let
removed
=
list
.
remove_last
(
)
.
unwrap
(
)
;
assert_clean
(
removed
)
;
assert
!
(
list
.
is_empty
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert
!
(
items
.
is_empty
(
)
)
;
}
}
#
[
test
]
fn
remove_by_address
(
)
{
unsafe
{
let
mut
a
=
ListNode
:
:
new
(
5
)
;
let
mut
b
=
ListNode
:
:
new
(
7
)
;
let
mut
c
=
ListNode
:
:
new
(
31
)
;
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
a
)
)
;
assert_clean
(
(
&
mut
a
)
.
into
(
)
)
;
assert_eq
!
(
false
list
.
remove
(
&
mut
a
)
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
head
)
;
assert_eq
!
(
Some
(
(
&
mut
c
)
.
into
(
)
)
b
.
next
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
c
.
prev
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
7
31
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
a
)
)
;
assert_clean
(
(
&
mut
a
)
.
into
(
)
)
;
assert_eq
!
(
false
list
.
remove
(
&
mut
a
)
)
;
assert_eq
!
(
Some
(
(
&
mut
c
)
.
into
(
)
)
b
.
next
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
c
.
prev
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
31
7
]
.
to_vec
(
)
items
)
;
}
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
b
)
)
;
assert_clean
(
(
&
mut
b
)
.
into
(
)
)
;
assert_eq
!
(
Some
(
(
&
mut
c
)
.
into
(
)
)
a
.
next
)
;
assert_eq
!
(
Some
(
(
&
mut
a
)
.
into
(
)
)
c
.
prev
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
31
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
b
)
)
;
assert_clean
(
(
&
mut
b
)
.
into
(
)
)
;
assert_eq
!
(
Some
(
(
&
mut
c
)
.
into
(
)
)
a
.
next
)
;
assert_eq
!
(
Some
(
(
&
mut
a
)
.
into
(
)
)
c
.
prev
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
31
5
]
.
to_vec
(
)
items
)
;
}
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
c
)
)
;
assert_clean
(
(
&
mut
c
)
.
into
(
)
)
;
assert
!
(
b
.
next
.
is_none
(
)
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
tail
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
7
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
c
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
c
)
)
;
assert_clean
(
(
&
mut
c
)
.
into
(
)
)
;
assert
!
(
b
.
next
.
is_none
(
)
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
tail
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
7
5
]
.
to_vec
(
)
items
)
;
}
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
a
)
)
;
assert_clean
(
(
&
mut
a
)
.
into
(
)
)
;
assert_eq
!
(
false
list
.
remove
(
&
mut
a
)
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
head
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
tail
)
;
assert
!
(
b
.
next
.
is_none
(
)
)
;
assert
!
(
b
.
prev
.
is_none
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
7
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
a
)
)
;
assert_clean
(
(
&
mut
a
)
.
into
(
)
)
;
assert_eq
!
(
false
list
.
remove
(
&
mut
a
)
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
head
)
;
assert_eq
!
(
Some
(
(
&
mut
b
)
.
into
(
)
)
list
.
tail
)
;
assert
!
(
b
.
next
.
is_none
(
)
)
;
assert
!
(
b
.
prev
.
is_none
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
7
]
.
to_vec
(
)
items
)
;
}
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
b
)
)
;
assert_clean
(
(
&
mut
b
)
.
into
(
)
)
;
assert_eq
!
(
Some
(
(
&
mut
a
)
.
into
(
)
)
list
.
head
)
;
assert_eq
!
(
Some
(
(
&
mut
a
)
.
into
(
)
)
list
.
tail
)
;
assert
!
(
a
.
next
.
is_none
(
)
)
;
assert
!
(
a
.
prev
.
is_none
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert_eq
!
(
[
5
]
.
to_vec
(
)
items
)
;
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
b
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
b
)
)
;
assert_clean
(
(
&
mut
b
)
.
into
(
)
)
;
assert_eq
!
(
Some
(
(
&
mut
a
)
.
into
(
)
)
list
.
head
)
;
assert_eq
!
(
Some
(
(
&
mut
a
)
.
into
(
)
)
list
.
tail
)
;
assert
!
(
a
.
next
.
is_none
(
)
)
;
assert
!
(
a
.
prev
.
is_none
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_reverse_list
(
list
)
;
assert_eq
!
(
[
5
]
.
to_vec
(
)
items
)
;
}
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
add_nodes
(
&
mut
list
&
mut
[
&
mut
a
]
)
;
assert_eq
!
(
true
list
.
remove
(
&
mut
a
)
)
;
assert_clean
(
(
&
mut
a
)
.
into
(
)
)
;
assert
!
(
list
.
head
.
is_none
(
)
)
;
assert
!
(
list
.
tail
.
is_none
(
)
)
;
let
items
:
Vec
<
i32
>
=
collect_list
(
list
)
;
assert
!
(
items
.
is_empty
(
)
)
;
}
{
let
mut
list
=
LinkedList
:
:
new
(
)
;
list
.
add_front
(
&
mut
b
)
;
list
.
add_front
(
&
mut
a
)
;
assert_eq
!
(
false
list
.
remove
(
&
mut
c
)
)
;
}
}
}
}
