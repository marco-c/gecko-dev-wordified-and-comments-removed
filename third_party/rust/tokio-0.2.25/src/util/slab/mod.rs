mod
addr
;
pub
(
crate
)
use
addr
:
:
Address
;
mod
entry
;
pub
(
crate
)
use
entry
:
:
Entry
;
mod
generation
;
pub
(
crate
)
use
generation
:
:
Generation
;
mod
page
;
mod
shard
;
use
shard
:
:
Shard
;
mod
slot
;
use
slot
:
:
Slot
;
mod
stack
;
use
stack
:
:
TransferStack
;
#
[
cfg
(
all
(
loom
test
)
)
]
mod
tests
;
use
crate
:
:
loom
:
:
sync
:
:
Mutex
;
use
crate
:
:
util
:
:
bit
;
use
std
:
:
fmt
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
const
MAX_THREADS
:
usize
=
4096
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
const
MAX_THREADS
:
usize
=
2048
;
const
MAX_PAGES
:
usize
=
bit
:
:
pointer_width
(
)
as
usize
/
4
;
cfg_not_loom
!
{
/
/
/
Size
of
first
page
const
INITIAL_PAGE_SIZE
:
usize
=
32
;
}
cfg_loom
!
{
const
INITIAL_PAGE_SIZE
:
usize
=
2
;
}
pub
(
crate
)
struct
Slab
<
T
>
{
shard
:
Shard
<
T
>
local
:
Mutex
<
(
)
>
}
unsafe
impl
<
T
:
Send
>
Send
for
Slab
<
T
>
{
}
unsafe
impl
<
T
:
Sync
>
Sync
for
Slab
<
T
>
{
}
impl
<
T
:
Entry
>
Slab
<
T
>
{
pub
(
crate
)
fn
new
(
)
-
>
Slab
<
T
>
{
Slab
{
shard
:
Shard
:
:
new
(
)
local
:
Mutex
:
:
new
(
(
)
)
}
}
pub
(
crate
)
fn
alloc
(
&
self
)
-
>
Option
<
Address
>
{
let
_local
=
self
.
local
.
lock
(
)
.
unwrap
(
)
;
self
.
shard
.
alloc
(
)
}
pub
(
crate
)
fn
remove
(
&
self
idx
:
Address
)
{
let
lock
=
self
.
local
.
try_lock
(
)
;
if
lock
.
is_ok
(
)
{
self
.
shard
.
remove_local
(
idx
)
}
else
{
self
.
shard
.
remove_remote
(
idx
)
}
}
pub
(
crate
)
fn
get
(
&
self
token
:
Address
)
-
>
Option
<
&
T
>
{
self
.
shard
.
get
(
token
)
}
}
impl
<
T
>
fmt
:
:
Debug
for
Slab
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Slab
"
)
.
field
(
"
shard
"
&
self
.
shard
)
.
finish
(
)
}
}
