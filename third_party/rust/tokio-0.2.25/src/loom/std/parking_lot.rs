use
std
:
:
sync
:
:
{
LockResult
TryLockError
TryLockResult
}
;
use
std
:
:
time
:
:
Duration
;
pub
(
crate
)
use
parking_lot
:
:
{
MutexGuard
RwLockReadGuard
RwLockWriteGuard
WaitTimeoutResult
}
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Mutex
<
T
:
?
Sized
>
(
parking_lot
:
:
Mutex
<
T
>
)
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
RwLock
<
T
>
(
parking_lot
:
:
RwLock
<
T
>
)
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Condvar
(
parking_lot
:
:
Condvar
)
;
impl
<
T
>
Mutex
<
T
>
{
#
[
inline
]
pub
(
crate
)
fn
new
(
t
:
T
)
-
>
Mutex
<
T
>
{
Mutex
(
parking_lot
:
:
Mutex
:
:
new
(
t
)
)
}
#
[
inline
]
pub
(
crate
)
fn
lock
(
&
self
)
-
>
LockResult
<
MutexGuard
<
'
_
T
>
>
{
Ok
(
self
.
0
.
lock
(
)
)
}
#
[
inline
]
pub
(
crate
)
fn
try_lock
(
&
self
)
-
>
TryLockResult
<
MutexGuard
<
'
_
T
>
>
{
match
self
.
0
.
try_lock
(
)
{
Some
(
guard
)
=
>
Ok
(
guard
)
None
=
>
Err
(
TryLockError
:
:
WouldBlock
)
}
}
}
impl
<
T
>
RwLock
<
T
>
{
pub
(
crate
)
fn
new
(
t
:
T
)
-
>
RwLock
<
T
>
{
RwLock
(
parking_lot
:
:
RwLock
:
:
new
(
t
)
)
}
pub
(
crate
)
fn
read
(
&
self
)
-
>
LockResult
<
RwLockReadGuard
<
'
_
T
>
>
{
Ok
(
self
.
0
.
read
(
)
)
}
pub
(
crate
)
fn
write
(
&
self
)
-
>
LockResult
<
RwLockWriteGuard
<
'
_
T
>
>
{
Ok
(
self
.
0
.
write
(
)
)
}
}
impl
Condvar
{
#
[
inline
]
pub
(
crate
)
fn
new
(
)
-
>
Condvar
{
Condvar
(
parking_lot
:
:
Condvar
:
:
new
(
)
)
}
#
[
inline
]
pub
(
crate
)
fn
notify_one
(
&
self
)
{
self
.
0
.
notify_one
(
)
;
}
#
[
inline
]
pub
(
crate
)
fn
notify_all
(
&
self
)
{
self
.
0
.
notify_all
(
)
;
}
#
[
inline
]
pub
(
crate
)
fn
wait
<
'
a
T
>
(
&
self
mut
guard
:
MutexGuard
<
'
a
T
>
)
-
>
LockResult
<
MutexGuard
<
'
a
T
>
>
{
self
.
0
.
wait
(
&
mut
guard
)
;
Ok
(
guard
)
}
#
[
inline
]
pub
(
crate
)
fn
wait_timeout
<
'
a
T
>
(
&
self
mut
guard
:
MutexGuard
<
'
a
T
>
timeout
:
Duration
)
-
>
LockResult
<
(
MutexGuard
<
'
a
T
>
WaitTimeoutResult
)
>
{
let
wtr
=
self
.
0
.
wait_for
(
&
mut
guard
timeout
)
;
Ok
(
(
guard
wtr
)
)
}
}
