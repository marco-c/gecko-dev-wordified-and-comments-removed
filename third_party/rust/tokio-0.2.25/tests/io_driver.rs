#
!
[
warn
(
rust_2018_idioms
)
]
#
!
[
cfg
(
feature
=
"
full
"
)
]
use
tokio
:
:
net
:
:
TcpListener
;
use
tokio
:
:
runtime
;
use
tokio_test
:
:
{
assert_ok
assert_pending
}
;
use
futures
:
:
task
:
:
{
waker_ref
ArcWake
}
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
net
:
:
TcpStream
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
sync
:
:
{
mpsc
Arc
Mutex
}
;
use
std
:
:
task
:
:
Context
;
struct
Task
<
T
>
{
future
:
Mutex
<
Pin
<
Box
<
T
>
>
>
}
impl
<
T
:
Send
>
ArcWake
for
Task
<
T
>
{
fn
wake_by_ref
(
_
:
&
Arc
<
Self
>
)
{
}
}
impl
<
T
>
Task
<
T
>
{
fn
new
(
future
:
T
)
-
>
Task
<
T
>
{
Task
{
future
:
Mutex
:
:
new
(
Box
:
:
pin
(
future
)
)
}
}
}
#
[
test
]
fn
test_drop_on_notify
(
)
{
let
mut
rt
=
runtime
:
:
Builder
:
:
new
(
)
.
basic_scheduler
(
)
.
enable_all
(
)
.
build
(
)
.
unwrap
(
)
;
let
(
addr_tx
addr_rx
)
=
mpsc
:
:
channel
(
)
;
let
task
=
Arc
:
:
new
(
Task
:
:
new
(
async
move
{
let
mut
listener
=
assert_ok
!
(
TcpListener
:
:
bind
(
"
127
.
0
.
0
.
1
:
0
"
)
.
await
)
;
let
addr
=
listener
.
local_addr
(
)
.
unwrap
(
)
;
addr_tx
.
send
(
addr
)
.
unwrap
(
)
;
loop
{
let
_
=
listener
.
accept
(
)
.
await
;
}
}
)
)
;
{
rt
.
enter
(
|
|
{
let
waker
=
waker_ref
(
&
task
)
;
let
mut
cx
=
Context
:
:
from_waker
(
&
waker
)
;
assert_pending
!
(
task
.
future
.
lock
(
)
.
unwrap
(
)
.
as_mut
(
)
.
poll
(
&
mut
cx
)
)
;
}
)
;
}
let
addr
=
addr_rx
.
recv
(
)
.
unwrap
(
)
;
drop
(
task
)
;
let
_s
=
TcpStream
:
:
connect
(
&
addr
)
.
unwrap
(
)
;
rt
.
block_on
(
async
{
}
)
;
}
