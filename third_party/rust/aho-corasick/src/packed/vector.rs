use
core
:
:
{
fmt
:
:
Debug
panic
:
:
{
RefUnwindSafe
UnwindSafe
}
}
;
pub
(
crate
)
trait
Vector
:
Copy
+
Debug
+
Send
+
Sync
+
UnwindSafe
+
RefUnwindSafe
{
const
BITS
:
usize
;
const
BYTES
:
usize
;
unsafe
fn
splat
(
byte
:
u8
)
-
>
Self
;
unsafe
fn
load_unaligned
(
data
:
*
const
u8
)
-
>
Self
;
unsafe
fn
is_zero
(
self
)
-
>
bool
;
unsafe
fn
cmpeq
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
and
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
or
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
shift_8bit_lane_right
<
const
BITS
:
i32
>
(
self
)
-
>
Self
;
unsafe
fn
shift_in_one_byte
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
shift_in_two_bytes
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
shift_in_three_bytes
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
shuffle_bytes
(
self
indices
:
Self
)
-
>
Self
;
unsafe
fn
for_each_64bit_lane
<
T
>
(
self
f
:
impl
FnMut
(
usize
u64
)
-
>
Option
<
T
>
)
-
>
Option
<
T
>
;
}
pub
(
crate
)
trait
FatVector
:
Vector
{
type
Half
:
Vector
;
unsafe
fn
load_half_unaligned
(
data
:
*
const
u8
)
-
>
Self
;
unsafe
fn
half_shift_in_one_byte
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
half_shift_in_two_bytes
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
half_shift_in_three_bytes
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
swap_halves
(
self
)
-
>
Self
;
unsafe
fn
interleave_low_8bit_lanes
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
interleave_high_8bit_lanes
(
self
vector2
:
Self
)
-
>
Self
;
unsafe
fn
for_each_low_64bit_lane
<
T
>
(
self
vector2
:
Self
f
:
impl
FnMut
(
usize
u64
)
-
>
Option
<
T
>
)
-
>
Option
<
T
>
;
}
#
[
cfg
(
all
(
target_arch
=
"
x86_64
"
target_feature
=
"
sse2
"
)
)
]
mod
x86_64_ssse3
{
use
core
:
:
arch
:
:
x86_64
:
:
*
;
use
crate
:
:
util
:
:
int
:
:
{
I32
I64
I8
}
;
use
super
:
:
Vector
;
impl
Vector
for
__m128i
{
const
BITS
:
usize
=
128
;
const
BYTES
:
usize
=
16
;
#
[
inline
(
always
)
]
unsafe
fn
splat
(
byte
:
u8
)
-
>
__m128i
{
_mm_set1_epi8
(
i8
:
:
from_bits
(
byte
)
)
}
#
[
inline
(
always
)
]
unsafe
fn
load_unaligned
(
data
:
*
const
u8
)
-
>
__m128i
{
_mm_loadu_si128
(
data
.
cast
:
:
<
__m128i
>
(
)
)
}
#
[
inline
(
always
)
]
unsafe
fn
is_zero
(
self
)
-
>
bool
{
let
cmp
=
self
.
cmpeq
(
Self
:
:
splat
(
0
)
)
;
_mm_movemask_epi8
(
cmp
)
.
to_bits
(
)
=
=
0xFFFF
}
#
[
inline
(
always
)
]
unsafe
fn
cmpeq
(
self
vector2
:
Self
)
-
>
__m128i
{
_mm_cmpeq_epi8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
and
(
self
vector2
:
Self
)
-
>
__m128i
{
_mm_and_si128
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
or
(
self
vector2
:
Self
)
-
>
__m128i
{
_mm_or_si128
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_8bit_lane_right
<
const
BITS
:
i32
>
(
self
)
-
>
Self
{
let
lomask
=
Self
:
:
splat
(
0xF
)
;
_mm_srli_epi16
(
self
BITS
)
.
and
(
lomask
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_one_byte
(
self
vector2
:
Self
)
-
>
Self
{
_mm_alignr_epi8
(
self
vector2
15
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_two_bytes
(
self
vector2
:
Self
)
-
>
Self
{
_mm_alignr_epi8
(
self
vector2
14
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_three_bytes
(
self
vector2
:
Self
)
-
>
Self
{
_mm_alignr_epi8
(
self
vector2
13
)
}
#
[
inline
(
always
)
]
unsafe
fn
shuffle_bytes
(
self
indices
:
Self
)
-
>
Self
{
_mm_shuffle_epi8
(
self
indices
)
}
#
[
inline
(
always
)
]
unsafe
fn
for_each_64bit_lane
<
T
>
(
self
mut
f
:
impl
FnMut
(
usize
u64
)
-
>
Option
<
T
>
)
-
>
Option
<
T
>
{
let
lane
=
_mm_extract_epi64
(
self
0
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
0
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm_extract_epi64
(
self
1
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
1
lane
)
{
return
Some
(
t
)
;
}
None
}
}
}
#
[
cfg
(
all
(
target_arch
=
"
x86_64
"
target_feature
=
"
sse2
"
)
)
]
mod
x86_64_avx2
{
use
core
:
:
arch
:
:
x86_64
:
:
*
;
use
crate
:
:
util
:
:
int
:
:
{
I32
I64
I8
}
;
use
super
:
:
{
FatVector
Vector
}
;
impl
Vector
for
__m256i
{
const
BITS
:
usize
=
256
;
const
BYTES
:
usize
=
32
;
#
[
inline
(
always
)
]
unsafe
fn
splat
(
byte
:
u8
)
-
>
__m256i
{
_mm256_set1_epi8
(
i8
:
:
from_bits
(
byte
)
)
}
#
[
inline
(
always
)
]
unsafe
fn
load_unaligned
(
data
:
*
const
u8
)
-
>
__m256i
{
_mm256_loadu_si256
(
data
.
cast
:
:
<
__m256i
>
(
)
)
}
#
[
inline
(
always
)
]
unsafe
fn
is_zero
(
self
)
-
>
bool
{
let
cmp
=
self
.
cmpeq
(
Self
:
:
splat
(
0
)
)
;
_mm256_movemask_epi8
(
cmp
)
.
to_bits
(
)
=
=
0xFFFFFFFF
}
#
[
inline
(
always
)
]
unsafe
fn
cmpeq
(
self
vector2
:
Self
)
-
>
__m256i
{
_mm256_cmpeq_epi8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
and
(
self
vector2
:
Self
)
-
>
__m256i
{
_mm256_and_si256
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
or
(
self
vector2
:
Self
)
-
>
__m256i
{
_mm256_or_si256
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_8bit_lane_right
<
const
BITS
:
i32
>
(
self
)
-
>
Self
{
let
lomask
=
Self
:
:
splat
(
0xF
)
;
_mm256_srli_epi16
(
self
BITS
)
.
and
(
lomask
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_one_byte
(
self
vector2
:
Self
)
-
>
Self
{
let
v
=
_mm256_permute2x128_si256
(
vector2
self
0x21
)
;
_mm256_alignr_epi8
(
self
v
15
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_two_bytes
(
self
vector2
:
Self
)
-
>
Self
{
let
v
=
_mm256_permute2x128_si256
(
vector2
self
0x21
)
;
_mm256_alignr_epi8
(
self
v
14
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_three_bytes
(
self
vector2
:
Self
)
-
>
Self
{
let
v
=
_mm256_permute2x128_si256
(
vector2
self
0x21
)
;
_mm256_alignr_epi8
(
self
v
13
)
}
#
[
inline
(
always
)
]
unsafe
fn
shuffle_bytes
(
self
indices
:
Self
)
-
>
Self
{
_mm256_shuffle_epi8
(
self
indices
)
}
#
[
inline
(
always
)
]
unsafe
fn
for_each_64bit_lane
<
T
>
(
self
mut
f
:
impl
FnMut
(
usize
u64
)
-
>
Option
<
T
>
)
-
>
Option
<
T
>
{
let
lane
=
_mm256_extract_epi64
(
self
0
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
0
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm256_extract_epi64
(
self
1
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
1
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm256_extract_epi64
(
self
2
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
2
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm256_extract_epi64
(
self
3
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
3
lane
)
{
return
Some
(
t
)
;
}
None
}
}
impl
FatVector
for
__m256i
{
type
Half
=
__m128i
;
#
[
inline
(
always
)
]
unsafe
fn
load_half_unaligned
(
data
:
*
const
u8
)
-
>
Self
{
let
half
=
Self
:
:
Half
:
:
load_unaligned
(
data
)
;
_mm256_broadcastsi128_si256
(
half
)
}
#
[
inline
(
always
)
]
unsafe
fn
half_shift_in_one_byte
(
self
vector2
:
Self
)
-
>
Self
{
_mm256_alignr_epi8
(
self
vector2
15
)
}
#
[
inline
(
always
)
]
unsafe
fn
half_shift_in_two_bytes
(
self
vector2
:
Self
)
-
>
Self
{
_mm256_alignr_epi8
(
self
vector2
14
)
}
#
[
inline
(
always
)
]
unsafe
fn
half_shift_in_three_bytes
(
self
vector2
:
Self
)
-
>
Self
{
_mm256_alignr_epi8
(
self
vector2
13
)
}
#
[
inline
(
always
)
]
unsafe
fn
swap_halves
(
self
)
-
>
Self
{
_mm256_permute4x64_epi64
(
self
0x4E
)
}
#
[
inline
(
always
)
]
unsafe
fn
interleave_low_8bit_lanes
(
self
vector2
:
Self
)
-
>
Self
{
_mm256_unpacklo_epi8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
interleave_high_8bit_lanes
(
self
vector2
:
Self
)
-
>
Self
{
_mm256_unpackhi_epi8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
for_each_low_64bit_lane
<
T
>
(
self
vector2
:
Self
mut
f
:
impl
FnMut
(
usize
u64
)
-
>
Option
<
T
>
)
-
>
Option
<
T
>
{
let
lane
=
_mm256_extract_epi64
(
self
0
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
0
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm256_extract_epi64
(
self
1
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
1
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm256_extract_epi64
(
vector2
0
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
2
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
_mm256_extract_epi64
(
vector2
1
)
.
to_bits
(
)
;
if
let
Some
(
t
)
=
f
(
3
lane
)
{
return
Some
(
t
)
;
}
None
}
}
}
#
[
cfg
(
target_arch
=
"
aarch64
"
)
]
mod
aarch64_neon
{
use
core
:
:
arch
:
:
aarch64
:
:
*
;
use
super
:
:
Vector
;
impl
Vector
for
uint8x16_t
{
const
BITS
:
usize
=
128
;
const
BYTES
:
usize
=
16
;
#
[
inline
(
always
)
]
unsafe
fn
splat
(
byte
:
u8
)
-
>
uint8x16_t
{
vdupq_n_u8
(
byte
)
}
#
[
inline
(
always
)
]
unsafe
fn
load_unaligned
(
data
:
*
const
u8
)
-
>
uint8x16_t
{
vld1q_u8
(
data
)
}
#
[
inline
(
always
)
]
unsafe
fn
is_zero
(
self
)
-
>
bool
{
let
maxes
=
vreinterpretq_u64_u8
(
vpmaxq_u8
(
self
self
)
)
;
vgetq_lane_u64
(
maxes
0
)
=
=
0
}
#
[
inline
(
always
)
]
unsafe
fn
cmpeq
(
self
vector2
:
Self
)
-
>
uint8x16_t
{
vceqq_u8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
and
(
self
vector2
:
Self
)
-
>
uint8x16_t
{
vandq_u8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
or
(
self
vector2
:
Self
)
-
>
uint8x16_t
{
vorrq_u8
(
self
vector2
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_8bit_lane_right
<
const
BITS
:
i32
>
(
self
)
-
>
Self
{
debug_assert
!
(
BITS
<
=
7
)
;
vshrq_n_u8
(
self
BITS
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_one_byte
(
self
vector2
:
Self
)
-
>
Self
{
vextq_u8
(
vector2
self
15
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_two_bytes
(
self
vector2
:
Self
)
-
>
Self
{
vextq_u8
(
vector2
self
14
)
}
#
[
inline
(
always
)
]
unsafe
fn
shift_in_three_bytes
(
self
vector2
:
Self
)
-
>
Self
{
vextq_u8
(
vector2
self
13
)
}
#
[
inline
(
always
)
]
unsafe
fn
shuffle_bytes
(
self
indices
:
Self
)
-
>
Self
{
vqtbl1q_u8
(
self
indices
)
}
#
[
inline
(
always
)
]
unsafe
fn
for_each_64bit_lane
<
T
>
(
self
mut
f
:
impl
FnMut
(
usize
u64
)
-
>
Option
<
T
>
)
-
>
Option
<
T
>
{
let
this
=
vreinterpretq_u64_u8
(
self
)
;
let
lane
=
vgetq_lane_u64
(
this
0
)
;
if
let
Some
(
t
)
=
f
(
0
lane
)
{
return
Some
(
t
)
;
}
let
lane
=
vgetq_lane_u64
(
this
1
)
;
if
let
Some
(
t
)
=
f
(
1
lane
)
{
return
Some
(
t
)
;
}
None
}
}
}
#
[
cfg
(
all
(
test
target_arch
=
"
x86_64
"
target_feature
=
"
sse2
"
)
)
]
mod
tests_x86_64_ssse3
{
use
core
:
:
arch
:
:
x86_64
:
:
*
;
use
crate
:
:
util
:
:
int
:
:
{
I32
U32
}
;
use
super
:
:
*
;
fn
is_runnable
(
)
-
>
bool
{
std
:
:
is_x86_feature_detected
!
(
"
ssse3
"
)
}
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
load
(
lanes
:
[
u8
;
16
]
)
-
>
__m128i
{
__m128i
:
:
load_unaligned
(
&
lanes
as
*
const
u8
)
}
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
unload
(
v
:
__m128i
)
-
>
[
u8
;
16
]
{
[
_mm_extract_epi8
(
v
0
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
1
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
2
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
3
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
4
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
5
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
6
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
7
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
8
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
9
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
10
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
11
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
12
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
13
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
14
)
.
to_bits
(
)
.
low_u8
(
)
_mm_extract_epi8
(
v
15
)
.
to_bits
(
)
.
low_u8
(
)
]
}
#
[
test
]
fn
vector_splat
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v
=
__m128i
:
:
splat
(
0xAF
)
;
assert_eq
!
(
unload
(
v
)
[
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_is_zero
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
!
v
.
is_zero
(
)
)
;
let
v
=
load
(
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
v
.
is_zero
(
)
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_cmpeq
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
1
]
)
;
let
v2
=
load
(
[
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
]
)
;
assert_eq
!
(
unload
(
v1
.
cmpeq
(
v2
)
)
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0xFF
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_and
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0
0
0
0
0
0b1001
0
0
0
0
0
0
0
0
0
0
]
)
;
let
v2
=
load
(
[
0
0
0
0
0
0b1010
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v1
.
and
(
v2
)
)
[
0
0
0
0
0
0b1000
0
0
0
0
0
0
0
0
0
0
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_or
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0
0
0
0
0
0b1001
0
0
0
0
0
0
0
0
0
0
]
)
;
let
v2
=
load
(
[
0
0
0
0
0
0b1010
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v1
.
or
(
v2
)
)
[
0
0
0
0
0
0b1011
0
0
0
0
0
0
0
0
0
0
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_8bit_lane_right
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0
0
0
0
0b1011
0b0101
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v
.
shift_8bit_lane_right
:
:
<
2
>
(
)
)
[
0
0
0
0
0b0010
0b0001
0
0
0
0
0
0
0
0
0
0
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_one_byte
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_one_byte
(
v2
)
)
[
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_two_bytes
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_two_bytes
(
v2
)
)
[
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_three_bytes
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_three_bytes
(
v2
)
)
[
30
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shuffle_bytes
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
0
0
0
0
4
4
4
4
8
8
8
8
12
12
12
12
]
)
;
assert_eq
!
(
unload
(
v1
.
shuffle_bytes
(
v2
)
)
[
1
1
1
1
5
5
5
5
9
9
9
9
13
13
13
13
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_for_each_64bit_lane
(
)
{
#
[
target_feature
(
enable
=
"
ssse3
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
]
)
;
let
mut
lanes
=
[
0u64
;
2
]
;
v
.
for_each_64bit_lane
(
|
i
lane
|
{
lanes
[
i
]
=
lane
;
None
:
:
<
(
)
>
}
)
;
assert_eq
!
(
lanes
[
0x0807060504030201
0x100F0E0D0C0B0A09
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
}
#
[
cfg
(
all
(
test
target_arch
=
"
x86_64
"
target_feature
=
"
sse2
"
)
)
]
mod
tests_x86_64_avx2
{
use
core
:
:
arch
:
:
x86_64
:
:
*
;
use
crate
:
:
util
:
:
int
:
:
{
I32
U32
}
;
use
super
:
:
*
;
fn
is_runnable
(
)
-
>
bool
{
std
:
:
is_x86_feature_detected
!
(
"
avx2
"
)
}
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
load
(
lanes
:
[
u8
;
32
]
)
-
>
__m256i
{
__m256i
:
:
load_unaligned
(
&
lanes
as
*
const
u8
)
}
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
load_half
(
lanes
:
[
u8
;
16
]
)
-
>
__m256i
{
__m256i
:
:
load_half_unaligned
(
&
lanes
as
*
const
u8
)
}
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
unload
(
v
:
__m256i
)
-
>
[
u8
;
32
]
{
[
_mm256_extract_epi8
(
v
0
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
1
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
2
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
3
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
4
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
5
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
6
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
7
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
8
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
9
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
10
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
11
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
12
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
13
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
14
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
15
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
16
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
17
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
18
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
19
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
20
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
21
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
22
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
23
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
24
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
25
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
26
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
27
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
28
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
29
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
30
)
.
to_bits
(
)
.
low_u8
(
)
_mm256_extract_epi8
(
v
31
)
.
to_bits
(
)
.
low_u8
(
)
]
}
#
[
test
]
fn
vector_splat
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v
=
__m256i
:
:
splat
(
0xAF
)
;
assert_eq
!
(
unload
(
v
)
[
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_is_zero
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
!
v
.
is_zero
(
)
)
;
let
v
=
load
(
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
v
.
is_zero
(
)
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_cmpeq
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
1
]
)
;
let
v2
=
load
(
[
32
31
30
29
28
27
26
25
24
23
22
21
20
19
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
]
)
;
assert_eq
!
(
unload
(
v1
.
cmpeq
(
v2
)
)
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0xFF
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_and
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0
0
0
0
0
0b1001
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
let
v2
=
load
(
[
0
0
0
0
0
0b1010
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v1
.
and
(
v2
)
)
[
0
0
0
0
0
0b1000
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_or
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0
0
0
0
0
0b1001
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
let
v2
=
load
(
[
0
0
0
0
0
0b1010
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v1
.
or
(
v2
)
)
[
0
0
0
0
0
0b1011
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_8bit_lane_right
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0
0
0
0
0b1011
0b0101
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v
.
shift_8bit_lane_right
:
:
<
2
>
(
)
)
[
0
0
0
0
0b0010
0b0001
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_one_byte
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
v2
=
load
(
[
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_one_byte
(
v2
)
)
[
64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_two_bytes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
v2
=
load
(
[
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_two_bytes
(
v2
)
)
[
63
64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_three_bytes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
v2
=
load
(
[
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_three_bytes
(
v2
)
)
[
62
63
64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shuffle_bytes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
v2
=
load
(
[
0
0
0
0
4
4
4
4
8
8
8
8
12
12
12
12
16
16
16
16
20
20
20
20
24
24
24
24
28
28
28
28
]
)
;
assert_eq
!
(
unload
(
v1
.
shuffle_bytes
(
v2
)
)
[
1
1
1
1
5
5
5
5
9
9
9
9
13
13
13
13
17
17
17
17
21
21
21
21
25
25
25
25
29
29
29
29
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_for_each_64bit_lane
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x20
]
)
;
let
mut
lanes
=
[
0u64
;
4
]
;
v
.
for_each_64bit_lane
(
|
i
lane
|
{
lanes
[
i
]
=
lane
;
None
:
:
<
(
)
>
}
)
;
assert_eq
!
(
lanes
[
0x0807060504030201
0x100F0E0D0C0B0A09
0x1817161514131211
0x201F1E1D1C1B1A19
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_half_shift_in_one_byte
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load_half
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load_half
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
half_shift_in_one_byte
(
v2
)
)
[
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_half_shift_in_two_bytes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load_half
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load_half
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
half_shift_in_two_bytes
(
v2
)
)
[
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_half_shift_in_three_bytes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load_half
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load_half
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
half_shift_in_three_bytes
(
v2
)
)
[
30
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
30
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_swap_halves
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v
.
swap_halves
(
)
)
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_interleave_low_8bit_lanes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
v2
=
load
(
[
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
]
)
;
assert_eq
!
(
unload
(
v1
.
interleave_low_8bit_lanes
(
v2
)
)
[
1
33
2
34
3
35
4
36
5
37
6
38
7
39
8
40
17
49
18
50
19
51
20
52
21
53
22
54
23
55
24
56
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_interleave_high_8bit_lanes
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
v2
=
load
(
[
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
]
)
;
assert_eq
!
(
unload
(
v1
.
interleave_high_8bit_lanes
(
v2
)
)
[
9
41
10
42
11
43
12
44
13
45
14
46
15
47
16
48
25
57
26
58
27
59
28
60
29
61
30
62
31
63
32
64
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
fat_vector_for_each_low_64bit_lane
(
)
{
#
[
target_feature
(
enable
=
"
avx2
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x20
]
)
;
let
v2
=
load
(
[
0x21
0x22
0x23
0x24
0x25
0x26
0x27
0x28
0x29
0x2A
0x2B
0x2C
0x2D
0x2E
0x2F
0x30
0x31
0x32
0x33
0x34
0x35
0x36
0x37
0x38
0x39
0x3A
0x3B
0x3C
0x3D
0x3E
0x3F
0x40
]
)
;
let
mut
lanes
=
[
0u64
;
4
]
;
v1
.
for_each_low_64bit_lane
(
v2
|
i
lane
|
{
lanes
[
i
]
=
lane
;
None
:
:
<
(
)
>
}
)
;
assert_eq
!
(
lanes
[
0x0807060504030201
0x100F0E0D0C0B0A09
0x2827262524232221
0x302F2E2D2C2B2A29
]
)
;
}
if
!
is_runnable
(
)
{
return
;
}
unsafe
{
test
(
)
}
}
}
#
[
cfg
(
all
(
test
target_arch
=
"
aarch64
"
target_feature
=
"
neon
"
)
)
]
mod
tests_aarch64_neon
{
use
core
:
:
arch
:
:
aarch64
:
:
*
;
use
super
:
:
*
;
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
load
(
lanes
:
[
u8
;
16
]
)
-
>
uint8x16_t
{
uint8x16_t
:
:
load_unaligned
(
&
lanes
as
*
const
u8
)
}
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
unload
(
v
:
uint8x16_t
)
-
>
[
u8
;
16
]
{
[
vgetq_lane_u8
(
v
0
)
vgetq_lane_u8
(
v
1
)
vgetq_lane_u8
(
v
2
)
vgetq_lane_u8
(
v
3
)
vgetq_lane_u8
(
v
4
)
vgetq_lane_u8
(
v
5
)
vgetq_lane_u8
(
v
6
)
vgetq_lane_u8
(
v
7
)
vgetq_lane_u8
(
v
8
)
vgetq_lane_u8
(
v
9
)
vgetq_lane_u8
(
v
10
)
vgetq_lane_u8
(
v
11
)
vgetq_lane_u8
(
v
12
)
vgetq_lane_u8
(
v
13
)
vgetq_lane_u8
(
v
14
)
vgetq_lane_u8
(
v
15
)
]
}
#
[
test
]
fn
example_vmaxvq_u8_non_zero
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
example
(
)
{
let
v
=
load
(
[
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
vmaxvq_u8
(
v
)
1
)
;
}
unsafe
{
example
(
)
}
}
#
[
test
]
fn
example_vmaxvq_u8_zero
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
example
(
)
{
let
v
=
load
(
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
vmaxvq_u8
(
v
)
0
)
;
}
unsafe
{
example
(
)
}
}
#
[
test
]
fn
example_vpmaxq_u8_non_zero
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
example
(
)
{
let
v
=
load
(
[
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
]
)
;
let
r
=
vpmaxq_u8
(
v
v
)
;
assert_eq
!
(
unload
(
r
)
[
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
]
)
;
}
unsafe
{
example
(
)
}
}
#
[
test
]
fn
example_vpmaxq_u8_self
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
example
(
)
{
let
v
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
r
=
vpmaxq_u8
(
v
v
)
;
assert_eq
!
(
unload
(
r
)
[
2
4
6
8
10
12
14
16
2
4
6
8
10
12
14
16
]
)
;
}
unsafe
{
example
(
)
}
}
#
[
test
]
fn
example_vpmaxq_u8_other
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
example
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
let
r
=
vpmaxq_u8
(
v1
v2
)
;
assert_eq
!
(
unload
(
r
)
[
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
]
)
;
}
unsafe
{
example
(
)
}
}
#
[
test
]
fn
vector_splat
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v
=
uint8x16_t
:
:
splat
(
0xAF
)
;
assert_eq
!
(
unload
(
v
)
[
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
0xAF
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_is_zero
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
!
v
.
is_zero
(
)
)
;
let
v
=
load
(
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
)
;
assert
!
(
v
.
is_zero
(
)
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_cmpeq
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
1
]
)
;
let
v2
=
load
(
[
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
]
)
;
assert_eq
!
(
unload
(
v1
.
cmpeq
(
v2
)
)
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0xFF
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_and
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0
0
0
0
0
0b1001
0
0
0
0
0
0
0
0
0
0
]
)
;
let
v2
=
load
(
[
0
0
0
0
0
0b1010
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v1
.
and
(
v2
)
)
[
0
0
0
0
0
0b1000
0
0
0
0
0
0
0
0
0
0
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_or
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
0
0
0
0
0
0b1001
0
0
0
0
0
0
0
0
0
0
]
)
;
let
v2
=
load
(
[
0
0
0
0
0
0b1010
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v1
.
or
(
v2
)
)
[
0
0
0
0
0
0b1011
0
0
0
0
0
0
0
0
0
0
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_8bit_lane_right
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0
0
0
0
0b1011
0b0101
0
0
0
0
0
0
0
0
0
0
]
)
;
assert_eq
!
(
unload
(
v
.
shift_8bit_lane_right
:
:
<
2
>
(
)
)
[
0
0
0
0
0b0010
0b0001
0
0
0
0
0
0
0
0
0
0
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_one_byte
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_one_byte
(
v2
)
)
[
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_two_bytes
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_two_bytes
(
v2
)
)
[
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shift_in_three_bytes
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
]
)
;
assert_eq
!
(
unload
(
v1
.
shift_in_three_bytes
(
v2
)
)
[
30
31
32
1
2
3
4
5
6
7
8
9
10
11
12
13
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_shuffle_bytes
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v1
=
load
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
let
v2
=
load
(
[
0
0
0
0
4
4
4
4
8
8
8
8
12
12
12
12
]
)
;
assert_eq
!
(
unload
(
v1
.
shuffle_bytes
(
v2
)
)
[
1
1
1
1
5
5
5
5
9
9
9
9
13
13
13
13
]
)
;
}
unsafe
{
test
(
)
}
}
#
[
test
]
fn
vector_for_each_64bit_lane
(
)
{
#
[
target_feature
(
enable
=
"
neon
"
)
]
unsafe
fn
test
(
)
{
let
v
=
load
(
[
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
]
)
;
let
mut
lanes
=
[
0u64
;
2
]
;
v
.
for_each_64bit_lane
(
|
i
lane
|
{
lanes
[
i
]
=
lane
;
None
:
:
<
(
)
>
}
)
;
assert_eq
!
(
lanes
[
0x0807060504030201
0x100F0E0D0C0B0A09
]
)
;
}
unsafe
{
test
(
)
}
}
}
