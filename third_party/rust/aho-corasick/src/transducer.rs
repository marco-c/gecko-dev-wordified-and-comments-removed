use
crate
:
:
{
automaton
:
:
{
Automaton
StateID
}
Anchored
as
AcAnchored
Input
MatchError
}
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
Unanchored
<
A
>
(
A
)
;
impl
<
A
:
Automaton
>
Unanchored
<
A
>
{
pub
fn
new
(
aut
:
A
)
-
>
Result
<
Unanchored
<
A
>
MatchError
>
{
let
input
=
Input
:
:
new
(
"
"
)
.
anchored
(
AcAnchored
:
:
No
)
;
let
_
=
aut
.
start_state
(
&
input
)
?
;
Ok
(
Unanchored
(
aut
)
)
}
pub
fn
as_ref
(
&
self
)
-
>
&
A
{
&
self
.
0
}
pub
fn
into_inner
(
self
)
-
>
A
{
self
.
0
}
}
impl
<
A
:
Automaton
>
fst
:
:
Automaton
for
Unanchored
<
A
>
{
type
State
=
StateID
;
#
[
inline
]
fn
start
(
&
self
)
-
>
StateID
{
let
input
=
Input
:
:
new
(
"
"
)
.
anchored
(
AcAnchored
:
:
No
)
;
self
.
0
.
start_state
(
&
input
)
.
expect
(
"
support
for
unanchored
searches
"
)
}
#
[
inline
]
fn
is_match
(
&
self
state
:
&
StateID
)
-
>
bool
{
self
.
0
.
is_match
(
*
state
)
}
#
[
inline
]
fn
accept
(
&
self
state
:
&
StateID
byte
:
u8
)
-
>
StateID
{
if
fst
:
:
Automaton
:
:
is_match
(
self
state
)
{
return
*
state
;
}
self
.
0
.
next_state
(
AcAnchored
:
:
No
*
state
byte
)
}
#
[
inline
]
fn
can_match
(
&
self
state
:
&
StateID
)
-
>
bool
{
!
self
.
0
.
is_dead
(
*
state
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Anchored
<
A
>
(
A
)
;
impl
<
A
:
Automaton
>
Anchored
<
A
>
{
pub
fn
new
(
aut
:
A
)
-
>
Result
<
Anchored
<
A
>
MatchError
>
{
let
input
=
Input
:
:
new
(
"
"
)
.
anchored
(
AcAnchored
:
:
Yes
)
;
let
_
=
aut
.
start_state
(
&
input
)
?
;
Ok
(
Anchored
(
aut
)
)
}
pub
fn
as_ref
(
&
self
)
-
>
&
A
{
&
self
.
0
}
pub
fn
into_inner
(
self
)
-
>
A
{
self
.
0
}
}
impl
<
A
:
Automaton
>
fst
:
:
Automaton
for
Anchored
<
A
>
{
type
State
=
StateID
;
#
[
inline
]
fn
start
(
&
self
)
-
>
StateID
{
let
input
=
Input
:
:
new
(
"
"
)
.
anchored
(
AcAnchored
:
:
Yes
)
;
self
.
0
.
start_state
(
&
input
)
.
expect
(
"
support
for
unanchored
searches
"
)
}
#
[
inline
]
fn
is_match
(
&
self
state
:
&
StateID
)
-
>
bool
{
self
.
0
.
is_match
(
*
state
)
}
#
[
inline
]
fn
accept
(
&
self
state
:
&
StateID
byte
:
u8
)
-
>
StateID
{
if
fst
:
:
Automaton
:
:
is_match
(
self
state
)
{
return
*
state
;
}
self
.
0
.
next_state
(
AcAnchored
:
:
Yes
*
state
byte
)
}
#
[
inline
]
fn
can_match
(
&
self
state
:
&
StateID
)
-
>
bool
{
!
self
.
0
.
is_dead
(
*
state
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
alloc
:
:
{
string
:
:
String
vec
vec
:
:
Vec
}
;
use
fst
:
:
{
Automaton
IntoStreamer
Set
Streamer
}
;
use
crate
:
:
{
dfa
:
:
DFA
nfa
:
:
{
contiguous
noncontiguous
}
StartKind
}
;
use
super
:
:
*
;
fn
search
<
A
:
Automaton
D
:
AsRef
<
[
u8
]
>
>
(
set
:
&
Set
<
D
>
aut
:
A
)
-
>
Vec
<
String
>
{
let
mut
stream
=
set
.
search
(
aut
)
.
into_stream
(
)
;
let
mut
results
=
vec
!
[
]
;
while
let
Some
(
key
)
=
stream
.
next
(
)
{
results
.
push
(
String
:
:
from
(
core
:
:
str
:
:
from_utf8
(
key
)
.
unwrap
(
)
)
)
;
}
results
}
#
[
test
]
fn
unanchored
(
)
{
let
set
=
Set
:
:
from_iter
(
&
[
"
a
"
"
bar
"
"
baz
"
"
wat
"
"
xba
"
"
xbax
"
"
z
"
]
)
.
unwrap
(
)
;
let
patterns
=
vec
!
[
"
baz
"
"
bax
"
]
;
let
expected
=
vec
!
[
"
baz
"
"
xbax
"
]
;
let
aut
=
Unanchored
(
noncontiguous
:
:
NFA
:
:
new
(
&
patterns
)
.
unwrap
(
)
)
;
let
got
=
search
(
&
set
&
aut
)
;
assert_eq
!
(
got
expected
)
;
let
aut
=
Unanchored
(
contiguous
:
:
NFA
:
:
new
(
&
patterns
)
.
unwrap
(
)
)
;
let
got
=
search
(
&
set
&
aut
)
;
assert_eq
!
(
got
expected
)
;
let
aut
=
Unanchored
(
DFA
:
:
new
(
&
patterns
)
.
unwrap
(
)
)
;
let
got
=
search
(
&
set
&
aut
)
;
assert_eq
!
(
got
expected
)
;
}
#
[
test
]
fn
anchored
(
)
{
let
set
=
Set
:
:
from_iter
(
&
[
"
a
"
"
bar
"
"
baz
"
"
wat
"
"
xba
"
"
xbax
"
"
z
"
]
)
.
unwrap
(
)
;
let
patterns
=
vec
!
[
"
baz
"
"
bax
"
]
;
let
expected
=
vec
!
[
"
baz
"
]
;
let
aut
=
Anchored
(
noncontiguous
:
:
NFA
:
:
new
(
&
patterns
)
.
unwrap
(
)
)
;
let
got
=
search
(
&
set
&
aut
)
;
assert_eq
!
(
got
expected
)
;
let
aut
=
Anchored
(
contiguous
:
:
NFA
:
:
new
(
&
patterns
)
.
unwrap
(
)
)
;
let
got
=
search
(
&
set
&
aut
)
;
assert_eq
!
(
got
expected
)
;
let
aut
=
Anchored
(
DFA
:
:
builder
(
)
.
start_kind
(
StartKind
:
:
Anchored
)
.
build
(
&
patterns
)
.
unwrap
(
)
)
;
let
got
=
search
(
&
set
&
aut
)
;
assert_eq
!
(
got
expected
)
;
}
}
