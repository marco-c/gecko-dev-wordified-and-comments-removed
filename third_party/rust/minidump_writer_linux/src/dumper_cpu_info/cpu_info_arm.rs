use
crate
:
:
cpu_set
:
:
*
;
use
crate
:
:
errors
:
:
CpuInfoError
;
use
crate
:
:
minidump_format
:
:
*
;
use
crate
:
:
Result
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
use
std
:
:
path
;
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
CpuInfoError
>
;
struct
CpuInfoEntry
{
field
:
&
'
static
str
format
:
char
bit_lshift
:
u8
bit_length
:
u8
}
impl
CpuInfoEntry
{
fn
new
(
field
:
&
'
static
str
format
:
char
bit_lshift
:
u8
bit_length
:
u8
)
-
>
Self
{
CpuInfoEntry
{
field
format
bit_lshift
bit_length
}
}
}
struct
CpuFeaturesEntry
{
tag
:
&
'
static
str
hwcaps
:
u32
}
impl
CpuFeaturesEntry
{
fn
new
(
tag
:
&
'
static
str
hwcaps
:
u32
)
-
>
Self
{
CpuFeaturesEntry
{
tag
hwcaps
}
}
}
pub
fn
write_cpu_information
(
sys_info
:
&
mut
MDRawSystemInfo
)
-
>
Result
<
(
)
>
{
let
cpu_id_entries
=
[
CpuInfoEntry
:
:
new
(
"
CPU
implementer
"
'
x
'
24
8
)
CpuInfoEntry
:
:
new
(
"
CPU
variant
"
'
x
'
20
4
)
CpuInfoEntry
:
:
new
(
"
CPU
part
"
'
x
'
4
12
)
CpuInfoEntry
:
:
new
(
"
CPU
revision
"
'
d
'
0
4
)
]
;
let
cpu_features_entries
;
#
[
cfg
(
target_arch
=
"
arm
"
)
]
{
cpu_features_entries
=
[
CpuFeaturesEntry
:
:
new
(
"
swp
"
MDCPUInformationARMElfHwCaps
:
:
Swp
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
half
"
MDCPUInformationARMElfHwCaps
:
:
Half
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
thumb
"
MDCPUInformationARMElfHwCaps
:
:
Thumb
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
bit26
"
MDCPUInformationARMElfHwCaps
:
:
Bit26
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
fastmult
"
MDCPUInformationARMElfHwCaps
:
:
FastMult
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
fpa
"
MDCPUInformationARMElfHwCaps
:
:
Fpa
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
vfp
"
MDCPUInformationARMElfHwCaps
:
:
Vfp
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
edsp
"
MDCPUInformationARMElfHwCaps
:
:
Edsp
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
java
"
MDCPUInformationARMElfHwCaps
:
:
Java
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
iwmmxt
"
MDCPUInformationARMElfHwCaps
:
:
Iwmmxt
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
crunch
"
MDCPUInformationARMElfHwCaps
:
:
Crunch
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
thumbee
"
MDCPUInformationARMElfHwCaps
:
:
Thumbee
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
neon
"
MDCPUInformationARMElfHwCaps
:
:
Neon
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
vfpv3
"
MDCPUInformationARMElfHwCaps
:
:
Vfpv3
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
vfpv3d16
"
MDCPUInformationARMElfHwCaps
:
:
Vfpv3d16
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
tls
"
MDCPUInformationARMElfHwCaps
:
:
Tls
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
vfpv4
"
MDCPUInformationARMElfHwCaps
:
:
Vfpv4
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
idiva
"
MDCPUInformationARMElfHwCaps
:
:
Idiva
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
idivt
"
MDCPUInformationARMElfHwCaps
:
:
Idivt
as
u32
)
CpuFeaturesEntry
:
:
new
(
"
idiv
"
MDCPUInformationARMElfHwCaps
:
:
Idiva
as
u32
|
MDCPUInformationARMElfHwCaps
:
:
Idivt
as
u32
)
]
;
}
#
[
cfg
(
target_arch
=
"
aarch64
"
)
]
{
cpu_features_entries
=
[
]
;
}
if
cfg
!
(
target_arch
=
"
aarch64
"
)
{
sys_info
.
processor_architecture
=
MDCPUArchitecture
:
:
Arm64Old
as
u16
;
}
else
{
sys_info
.
processor_architecture
=
MDCPUArchitecture
:
:
Arm
as
u16
;
}
sys_info
.
number_of_processors
=
0
;
sys_info
.
processor_level
=
1
;
sys_info
.
processor_revision
=
42
;
sys_info
.
cpu
.
cpuid
=
0
;
sys_info
.
cpu
.
elf_hwcaps
=
0
;
let
mut
cpus_present
=
CpuSet
:
:
new
(
)
;
let
mut
cpus_possible
=
CpuSet
:
:
new
(
)
;
if
let
Ok
(
mut
present_file
)
=
File
:
:
open
(
"
/
sys
/
devices
/
system
/
cpu
/
present
"
)
{
let
_
=
cpus_present
.
parse_sys_file
(
&
mut
present_file
)
;
if
let
Ok
(
mut
possible_file
)
=
File
:
:
open
(
"
/
sys
/
devices
/
system
/
cpu
/
possible
"
)
{
let
_
=
cpus_possible
.
parse_sys_file
(
&
mut
possible_file
)
;
cpus_present
.
intersect_with
(
&
cpus_possible
)
;
let
cpu_count
=
std
:
:
cmp
:
:
min
(
255
cpus_present
.
get_count
(
)
)
as
u8
;
sys_info
.
number_of_processors
=
cpu_count
;
}
}
let
cpuinfo_file
=
match
File
:
:
open
(
path
:
:
PathBuf
:
:
from
(
"
/
proc
/
cpuinfo
"
)
)
{
Ok
(
x
)
=
>
x
Err
(
_
)
=
>
{
return
Ok
(
(
)
)
;
}
}
;
for
line
in
BufReader
:
:
new
(
cpuinfo_file
)
.
lines
(
)
{
let
line
=
line
?
;
if
line
.
trim
(
)
.
is_empty
(
)
{
continue
;
}
let
split
:
Vec
<
_
>
=
line
.
split
(
"
:
"
)
.
map
(
|
x
|
x
.
trim
(
)
)
.
collect
(
)
;
let
field
=
split
[
0
]
;
let
value
=
split
.
get
(
1
)
;
for
entry
in
&
cpu_id_entries
{
if
value
.
is_none
(
)
{
break
;
}
if
field
!
=
entry
.
field
{
continue
;
}
let
mut
result
;
let
val
=
value
.
unwrap
(
)
;
let
rr
=
if
val
.
starts_with
(
"
0x
"
)
|
|
entry
.
format
=
=
'
x
'
{
usize
:
:
from_str_radix
(
val
.
trim_start_matches
(
"
0x
"
)
16
)
}
else
{
usize
:
:
from_str_radix
(
val
10
)
}
;
result
=
match
rr
{
Ok
(
x
)
=
>
x
Err
(
_
)
=
>
{
continue
;
}
}
;
result
&
=
(
1
<
<
entry
.
bit_length
)
-
1
;
result
<
<
=
entry
.
bit_lshift
;
sys_info
.
cpu
.
cpuid
|
=
result
as
u32
;
}
if
cfg
!
(
target_arch
=
"
arm
"
)
{
if
field
=
=
"
Processor
"
{
if
let
Some
(
val
)
=
value
.
and_then
(
|
v
|
v
.
split_whitespace
(
)
.
last
(
)
)
{
sys_info
.
processor_level
=
val
[
2
.
.
val
.
len
(
)
-
2
]
.
parse
:
:
<
u16
>
(
)
.
unwrap_or
(
5
)
;
}
}
}
else
{
if
field
=
=
"
CPU
architecture
"
{
sys_info
.
processor_level
=
match
value
.
and_then
(
|
v
|
v
.
parse
:
:
<
u16
>
(
)
.
ok
(
)
)
{
Some
(
v
)
=
>
v
None
=
>
{
continue
;
}
}
;
}
}
if
field
=
=
"
Features
"
{
if
let
Some
(
val
)
=
value
{
for
tag
in
val
.
split_whitespace
(
)
{
for
entry
in
&
cpu_features_entries
{
if
entry
.
tag
=
=
tag
{
sys_info
.
cpu
.
elf_hwcaps
|
=
entry
.
hwcaps
;
break
;
}
}
}
}
}
}
Ok
(
(
)
)
}
