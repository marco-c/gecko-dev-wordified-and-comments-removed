#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
pkg
-
config
/
0
.
3
"
)
]
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
env
;
use
std
:
:
error
;
use
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
{
Bound
RangeBounds
}
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
process
:
:
{
Command
Output
}
;
use
std
:
:
str
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
Config
{
statik
:
Option
<
bool
>
min_version
:
Bound
<
String
>
max_version
:
Bound
<
String
>
extra_args
:
Vec
<
OsString
>
cargo_metadata
:
bool
env_metadata
:
bool
print_system_libs
:
bool
print_system_cflags
:
bool
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Library
{
pub
libs
:
Vec
<
String
>
pub
link_paths
:
Vec
<
PathBuf
>
pub
frameworks
:
Vec
<
String
>
pub
framework_paths
:
Vec
<
PathBuf
>
pub
include_paths
:
Vec
<
PathBuf
>
pub
defines
:
HashMap
<
String
Option
<
String
>
>
pub
version
:
String
_priv
:
(
)
}
#
[
derive
(
Debug
)
]
pub
enum
Error
{
EnvNoPkgConfig
(
String
)
CrossCompilation
Command
{
command
:
String
cause
:
io
:
:
Error
}
Failure
{
command
:
String
output
:
Output
}
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
impl
error
:
:
Error
for
Error
{
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
match
*
self
{
Error
:
:
EnvNoPkgConfig
(
ref
name
)
=
>
write
!
(
f
"
Aborted
because
{
}
is
set
"
name
)
Error
:
:
CrossCompilation
=
>
f
.
write_str
(
"
pkg
-
config
has
not
been
configured
to
support
cross
-
compilation
.
Install
a
sysroot
for
the
target
platform
and
configure
it
via
PKG_CONFIG_SYSROOT_DIR
and
PKG_CONFIG_PATH
or
install
a
cross
-
compiling
wrapper
for
pkg
-
config
and
set
it
via
PKG_CONFIG
environment
variable
.
"
)
Error
:
:
Command
{
ref
command
ref
cause
}
=
>
write
!
(
f
"
Failed
to
run
{
}
:
{
}
"
command
cause
)
Error
:
:
Failure
{
ref
command
ref
output
}
=
>
{
let
stdout
=
str
:
:
from_utf8
(
&
output
.
stdout
)
.
unwrap
(
)
;
let
stderr
=
str
:
:
from_utf8
(
&
output
.
stderr
)
.
unwrap
(
)
;
write
!
(
f
"
{
}
did
not
exit
successfully
:
{
}
"
command
output
.
status
)
?
;
if
!
stdout
.
is_empty
(
)
{
write
!
(
f
"
\
n
-
-
-
stdout
\
n
{
}
"
stdout
)
?
;
}
if
!
stderr
.
is_empty
(
)
{
write
!
(
f
"
\
n
-
-
-
stderr
\
n
{
}
"
stderr
)
?
;
}
Ok
(
(
)
)
}
Error
:
:
__Nonexhaustive
=
>
panic
!
(
)
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
find_library
(
name
:
&
str
)
-
>
Result
<
Library
String
>
{
probe_library
(
name
)
.
map_err
(
|
e
|
e
.
to_string
(
)
)
}
pub
fn
probe_library
(
name
:
&
str
)
-
>
Result
<
Library
Error
>
{
Config
:
:
new
(
)
.
probe
(
name
)
}
pub
fn
get_variable
(
package
:
&
str
variable
:
&
str
)
-
>
Result
<
String
Error
>
{
let
arg
=
format
!
(
"
-
-
variable
=
{
}
"
variable
)
;
let
cfg
=
Config
:
:
new
(
)
;
let
out
=
run
(
cfg
.
command
(
package
&
[
&
arg
]
)
)
?
;
Ok
(
str
:
:
from_utf8
(
&
out
)
.
unwrap
(
)
.
trim_end
(
)
.
to_owned
(
)
)
}
impl
Config
{
pub
fn
new
(
)
-
>
Config
{
Config
{
statik
:
None
min_version
:
Bound
:
:
Unbounded
max_version
:
Bound
:
:
Unbounded
extra_args
:
vec
!
[
]
print_system_cflags
:
true
print_system_libs
:
true
cargo_metadata
:
true
env_metadata
:
true
}
}
pub
fn
statik
(
&
mut
self
statik
:
bool
)
-
>
&
mut
Config
{
self
.
statik
=
Some
(
statik
)
;
self
}
pub
fn
atleast_version
(
&
mut
self
vers
:
&
str
)
-
>
&
mut
Config
{
self
.
min_version
=
Bound
:
:
Included
(
vers
.
to_string
(
)
)
;
self
.
max_version
=
Bound
:
:
Unbounded
;
self
}
pub
fn
exactly_version
(
&
mut
self
vers
:
&
str
)
-
>
&
mut
Config
{
self
.
min_version
=
Bound
:
:
Included
(
vers
.
to_string
(
)
)
;
self
.
max_version
=
Bound
:
:
Included
(
vers
.
to_string
(
)
)
;
self
}
pub
fn
range_version
<
'
a
R
>
(
&
mut
self
range
:
R
)
-
>
&
mut
Config
where
R
:
RangeBounds
<
&
'
a
str
>
{
self
.
min_version
=
match
range
.
start_bound
(
)
{
Bound
:
:
Included
(
vers
)
=
>
Bound
:
:
Included
(
vers
.
to_string
(
)
)
Bound
:
:
Excluded
(
vers
)
=
>
Bound
:
:
Excluded
(
vers
.
to_string
(
)
)
Bound
:
:
Unbounded
=
>
Bound
:
:
Unbounded
}
;
self
.
max_version
=
match
range
.
end_bound
(
)
{
Bound
:
:
Included
(
vers
)
=
>
Bound
:
:
Included
(
vers
.
to_string
(
)
)
Bound
:
:
Excluded
(
vers
)
=
>
Bound
:
:
Excluded
(
vers
.
to_string
(
)
)
Bound
:
:
Unbounded
=
>
Bound
:
:
Unbounded
}
;
self
}
pub
fn
arg
<
S
:
AsRef
<
OsStr
>
>
(
&
mut
self
arg
:
S
)
-
>
&
mut
Config
{
self
.
extra_args
.
push
(
arg
.
as_ref
(
)
.
to_os_string
(
)
)
;
self
}
pub
fn
cargo_metadata
(
&
mut
self
cargo_metadata
:
bool
)
-
>
&
mut
Config
{
self
.
cargo_metadata
=
cargo_metadata
;
self
}
pub
fn
env_metadata
(
&
mut
self
env_metadata
:
bool
)
-
>
&
mut
Config
{
self
.
env_metadata
=
env_metadata
;
self
}
pub
fn
print_system_libs
(
&
mut
self
print
:
bool
)
-
>
&
mut
Config
{
self
.
print_system_libs
=
print
;
self
}
pub
fn
print_system_cflags
(
&
mut
self
print
:
bool
)
-
>
&
mut
Config
{
self
.
print_system_cflags
=
print
;
self
}
#
[
doc
(
hidden
)
]
pub
fn
find
(
&
self
name
:
&
str
)
-
>
Result
<
Library
String
>
{
self
.
probe
(
name
)
.
map_err
(
|
e
|
e
.
to_string
(
)
)
}
pub
fn
probe
(
&
self
name
:
&
str
)
-
>
Result
<
Library
Error
>
{
let
abort_var_name
=
format
!
(
"
{
}
_NO_PKG_CONFIG
"
envify
(
name
)
)
;
if
self
.
env_var_os
(
&
abort_var_name
)
.
is_some
(
)
{
return
Err
(
Error
:
:
EnvNoPkgConfig
(
abort_var_name
)
)
;
}
else
if
!
self
.
target_supported
(
)
{
return
Err
(
Error
:
:
CrossCompilation
)
;
}
let
mut
library
=
Library
:
:
new
(
)
;
let
output
=
run
(
self
.
command
(
name
&
[
"
-
-
libs
"
"
-
-
cflags
"
]
)
)
?
;
library
.
parse_libs_cflags
(
name
&
output
self
)
;
let
output
=
run
(
self
.
command
(
name
&
[
"
-
-
modversion
"
]
)
)
?
;
library
.
parse_modversion
(
str
:
:
from_utf8
(
&
output
)
.
unwrap
(
)
)
;
Ok
(
library
)
}
pub
fn
target_supported
(
&
self
)
-
>
bool
{
let
target
=
env
:
:
var_os
(
"
TARGET
"
)
.
unwrap_or_default
(
)
;
let
host
=
env
:
:
var_os
(
"
HOST
"
)
.
unwrap_or_default
(
)
;
if
host
=
=
target
{
return
true
;
}
match
self
.
targetted_env_var
(
"
PKG_CONFIG_ALLOW_CROSS
"
)
{
Some
(
ref
val
)
if
val
=
=
"
0
"
=
>
false
Some
(
_
)
=
>
true
None
=
>
{
self
.
targetted_env_var
(
"
PKG_CONFIG
"
)
.
is_some
(
)
|
|
self
.
targetted_env_var
(
"
PKG_CONFIG_SYSROOT_DIR
"
)
.
is_some
(
)
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
get_variable
(
package
:
&
str
variable
:
&
str
)
-
>
Result
<
String
String
>
{
get_variable
(
package
variable
)
.
map_err
(
|
e
|
e
.
to_string
(
)
)
}
fn
targetted_env_var
(
&
self
var_base
:
&
str
)
-
>
Option
<
OsString
>
{
match
(
env
:
:
var
(
"
TARGET
"
)
env
:
:
var
(
"
HOST
"
)
)
{
(
Ok
(
target
)
Ok
(
host
)
)
=
>
{
let
kind
=
if
host
=
=
target
{
"
HOST
"
}
else
{
"
TARGET
"
}
;
let
target_u
=
target
.
replace
(
"
-
"
"
_
"
)
;
self
.
env_var_os
(
&
format
!
(
"
{
}
_
{
}
"
var_base
target
)
)
.
or_else
(
|
|
self
.
env_var_os
(
&
format
!
(
"
{
}
_
{
}
"
var_base
target_u
)
)
)
.
or_else
(
|
|
self
.
env_var_os
(
&
format
!
(
"
{
}
_
{
}
"
kind
var_base
)
)
)
.
or_else
(
|
|
self
.
env_var_os
(
var_base
)
)
}
(
Err
(
env
:
:
VarError
:
:
NotPresent
)
_
)
|
(
_
Err
(
env
:
:
VarError
:
:
NotPresent
)
)
=
>
{
self
.
env_var_os
(
var_base
)
}
(
Err
(
env
:
:
VarError
:
:
NotUnicode
(
s
)
)
_
)
|
(
_
Err
(
env
:
:
VarError
:
:
NotUnicode
(
s
)
)
)
=
>
{
panic
!
(
"
HOST
or
TARGET
environment
variable
is
not
valid
unicode
:
{
:
?
}
"
s
)
}
}
}
fn
env_var_os
(
&
self
name
:
&
str
)
-
>
Option
<
OsString
>
{
if
self
.
env_metadata
{
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
{
}
"
name
)
;
}
env
:
:
var_os
(
name
)
}
fn
is_static
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
statik
.
unwrap_or_else
(
|
|
self
.
infer_static
(
name
)
)
}
fn
command
(
&
self
name
:
&
str
args
:
&
[
&
str
]
)
-
>
Command
{
let
exe
=
self
.
env_var_os
(
"
PKG_CONFIG
"
)
.
unwrap_or_else
(
|
|
OsString
:
:
from
(
"
pkg
-
config
"
)
)
;
let
mut
cmd
=
Command
:
:
new
(
exe
)
;
if
self
.
is_static
(
name
)
{
cmd
.
arg
(
"
-
-
static
"
)
;
}
cmd
.
args
(
args
)
.
args
(
&
self
.
extra_args
)
;
if
let
Some
(
value
)
=
self
.
targetted_env_var
(
"
PKG_CONFIG_PATH
"
)
{
cmd
.
env
(
"
PKG_CONFIG_PATH
"
value
)
;
}
if
let
Some
(
value
)
=
self
.
targetted_env_var
(
"
PKG_CONFIG_LIBDIR
"
)
{
cmd
.
env
(
"
PKG_CONFIG_LIBDIR
"
value
)
;
}
if
let
Some
(
value
)
=
self
.
targetted_env_var
(
"
PKG_CONFIG_SYSROOT_DIR
"
)
{
cmd
.
env
(
"
PKG_CONFIG_SYSROOT_DIR
"
value
)
;
}
if
self
.
print_system_libs
{
cmd
.
env
(
"
PKG_CONFIG_ALLOW_SYSTEM_LIBS
"
"
1
"
)
;
}
if
self
.
print_system_cflags
{
cmd
.
env
(
"
PKG_CONFIG_ALLOW_SYSTEM_CFLAGS
"
"
1
"
)
;
}
cmd
.
arg
(
name
)
;
match
self
.
min_version
{
Bound
:
:
Included
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
>
=
{
}
"
name
version
)
)
;
}
Bound
:
:
Excluded
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
>
{
}
"
name
version
)
)
;
}
_
=
>
(
)
}
match
self
.
max_version
{
Bound
:
:
Included
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
<
=
{
}
"
name
version
)
)
;
}
Bound
:
:
Excluded
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
<
{
}
"
name
version
)
)
;
}
_
=
>
(
)
}
cmd
}
fn
print_metadata
(
&
self
s
:
&
str
)
{
if
self
.
cargo_metadata
{
println
!
(
"
cargo
:
{
}
"
s
)
;
}
}
fn
infer_static
(
&
self
name
:
&
str
)
-
>
bool
{
let
name
=
envify
(
name
)
;
if
self
.
env_var_os
(
&
format
!
(
"
{
}
_STATIC
"
name
)
)
.
is_some
(
)
{
true
}
else
if
self
.
env_var_os
(
&
format
!
(
"
{
}
_DYNAMIC
"
name
)
)
.
is_some
(
)
{
false
}
else
if
self
.
env_var_os
(
"
PKG_CONFIG_ALL_STATIC
"
)
.
is_some
(
)
{
true
}
else
if
self
.
env_var_os
(
"
PKG_CONFIG_ALL_DYNAMIC
"
)
.
is_some
(
)
{
false
}
else
{
false
}
}
}
impl
Default
for
Config
{
fn
default
(
)
-
>
Config
{
Config
{
statik
:
None
min_version
:
Bound
:
:
Unbounded
max_version
:
Bound
:
:
Unbounded
extra_args
:
vec
!
[
]
print_system_cflags
:
false
print_system_libs
:
false
cargo_metadata
:
false
env_metadata
:
false
}
}
}
impl
Library
{
fn
new
(
)
-
>
Library
{
Library
{
libs
:
Vec
:
:
new
(
)
link_paths
:
Vec
:
:
new
(
)
include_paths
:
Vec
:
:
new
(
)
frameworks
:
Vec
:
:
new
(
)
framework_paths
:
Vec
:
:
new
(
)
defines
:
HashMap
:
:
new
(
)
version
:
String
:
:
new
(
)
_priv
:
(
)
}
}
fn
parse_libs_cflags
(
&
mut
self
name
:
&
str
output
:
&
[
u8
]
config
:
&
Config
)
{
let
mut
is_msvc
=
false
;
if
let
Ok
(
target
)
=
env
:
:
var
(
"
TARGET
"
)
{
if
target
.
contains
(
"
msvc
"
)
{
is_msvc
=
true
;
}
}
let
system_roots
=
if
cfg
!
(
target_os
=
"
macos
"
)
{
vec
!
[
PathBuf
:
:
from
(
"
/
Library
"
)
PathBuf
:
:
from
(
"
/
System
"
)
]
}
else
{
let
sysroot
=
config
.
env_var_os
(
"
PKG_CONFIG_SYSROOT_DIR
"
)
.
or_else
(
|
|
config
.
env_var_os
(
"
SYSROOT
"
)
)
.
map
(
PathBuf
:
:
from
)
;
if
cfg
!
(
target_os
=
"
windows
"
)
{
if
let
Some
(
sysroot
)
=
sysroot
{
vec
!
[
sysroot
]
}
else
{
vec
!
[
]
}
}
else
{
vec
!
[
sysroot
.
unwrap_or_else
(
|
|
PathBuf
:
:
from
(
"
/
usr
"
)
)
]
}
}
;
let
mut
dirs
=
Vec
:
:
new
(
)
;
let
statik
=
config
.
is_static
(
name
)
;
let
words
=
split_flags
(
output
)
;
let
parts
=
words
.
iter
(
)
.
filter
(
|
l
|
l
.
len
(
)
>
2
)
.
map
(
|
arg
|
(
&
arg
[
0
.
.
2
]
&
arg
[
2
.
.
]
)
)
;
for
(
flag
val
)
in
parts
{
match
flag
{
"
-
L
"
=
>
{
let
meta
=
format
!
(
"
rustc
-
link
-
search
=
native
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
dirs
.
push
(
PathBuf
:
:
from
(
val
)
)
;
self
.
link_paths
.
push
(
PathBuf
:
:
from
(
val
)
)
;
}
"
-
F
"
=
>
{
let
meta
=
format
!
(
"
rustc
-
link
-
search
=
framework
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
self
.
framework_paths
.
push
(
PathBuf
:
:
from
(
val
)
)
;
}
"
-
I
"
=
>
{
self
.
include_paths
.
push
(
PathBuf
:
:
from
(
val
)
)
;
}
"
-
l
"
=
>
{
if
is_msvc
&
&
[
"
m
"
"
c
"
"
pthread
"
]
.
contains
(
&
val
)
{
continue
;
}
if
statik
&
&
is_static_available
(
val
&
system_roots
&
dirs
)
{
let
meta
=
format
!
(
"
rustc
-
link
-
lib
=
static
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
}
else
{
let
meta
=
format
!
(
"
rustc
-
link
-
lib
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
}
self
.
libs
.
push
(
val
.
to_string
(
)
)
;
}
"
-
D
"
=
>
{
let
mut
iter
=
val
.
split
(
'
=
'
)
;
self
.
defines
.
insert
(
iter
.
next
(
)
.
unwrap
(
)
.
to_owned
(
)
iter
.
next
(
)
.
map
(
|
s
|
s
.
to_owned
(
)
)
)
;
}
_
=
>
{
}
}
}
let
mut
iter
=
words
.
iter
(
)
.
flat_map
(
|
arg
|
{
if
arg
.
starts_with
(
"
-
Wl
"
)
{
arg
[
4
.
.
]
.
split
(
'
'
)
.
collect
(
)
}
else
{
vec
!
[
arg
.
as_ref
(
)
]
}
}
)
;
while
let
Some
(
part
)
=
iter
.
next
(
)
{
match
part
{
"
-
framework
"
=
>
{
if
let
Some
(
lib
)
=
iter
.
next
(
)
{
let
meta
=
format
!
(
"
rustc
-
link
-
lib
=
framework
=
{
}
"
lib
)
;
config
.
print_metadata
(
&
meta
)
;
self
.
frameworks
.
push
(
lib
.
to_string
(
)
)
;
}
}
"
-
isystem
"
|
"
-
iquote
"
|
"
-
idirafter
"
=
>
{
if
let
Some
(
inc
)
=
iter
.
next
(
)
{
self
.
include_paths
.
push
(
PathBuf
:
:
from
(
inc
)
)
;
}
}
_
=
>
(
)
}
}
}
fn
parse_modversion
(
&
mut
self
output
:
&
str
)
{
self
.
version
.
push_str
(
output
.
lines
(
)
.
nth
(
0
)
.
unwrap
(
)
.
trim
(
)
)
;
}
}
fn
envify
(
name
:
&
str
)
-
>
String
{
name
.
chars
(
)
.
map
(
|
c
|
c
.
to_ascii_uppercase
(
)
)
.
map
(
|
c
|
if
c
=
=
'
-
'
{
'
_
'
}
else
{
c
}
)
.
collect
(
)
}
fn
is_static_available
(
name
:
&
str
system_roots
:
&
[
PathBuf
]
dirs
:
&
[
PathBuf
]
)
-
>
bool
{
let
libname
=
format
!
(
"
lib
{
}
.
a
"
name
)
;
dirs
.
iter
(
)
.
any
(
|
dir
|
{
!
system_roots
.
iter
(
)
.
any
(
|
sys
|
dir
.
starts_with
(
sys
)
)
&
&
dir
.
join
(
&
libname
)
.
exists
(
)
}
)
}
fn
run
(
mut
cmd
:
Command
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
match
cmd
.
output
(
)
{
Ok
(
output
)
=
>
{
if
output
.
status
.
success
(
)
{
Ok
(
output
.
stdout
)
}
else
{
Err
(
Error
:
:
Failure
{
command
:
format
!
(
"
{
:
?
}
"
cmd
)
output
}
)
}
}
Err
(
cause
)
=
>
Err
(
Error
:
:
Command
{
command
:
format
!
(
"
{
:
?
}
"
cmd
)
cause
}
)
}
}
fn
split_flags
(
output
:
&
[
u8
]
)
-
>
Vec
<
String
>
{
let
mut
word
=
Vec
:
:
new
(
)
;
let
mut
words
=
Vec
:
:
new
(
)
;
let
mut
escaped
=
false
;
for
&
b
in
output
{
match
b
{
_
if
escaped
=
>
{
escaped
=
false
;
word
.
push
(
b
)
;
}
b
'
\
\
'
=
>
escaped
=
true
b
'
\
t
'
|
b
'
\
n
'
|
b
'
\
r
'
|
b
'
'
=
>
{
if
!
word
.
is_empty
(
)
{
words
.
push
(
String
:
:
from_utf8
(
word
)
.
unwrap
(
)
)
;
word
=
Vec
:
:
new
(
)
;
}
}
_
=
>
word
.
push
(
b
)
}
}
if
!
word
.
is_empty
(
)
{
words
.
push
(
String
:
:
from_utf8
(
word
)
.
unwrap
(
)
)
;
}
words
}
#
[
test
]
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
system_library_mac_test
(
)
{
let
system_roots
=
vec
!
[
PathBuf
:
:
from
(
"
/
Library
"
)
PathBuf
:
:
from
(
"
/
System
"
)
]
;
assert
!
(
!
is_static_available
(
"
PluginManager
"
system_roots
&
[
PathBuf
:
:
from
(
"
/
Library
/
Frameworks
"
)
]
)
)
;
assert
!
(
!
is_static_available
(
"
python2
.
7
"
system_roots
&
[
PathBuf
:
:
from
(
"
/
System
/
Library
/
Frameworks
/
Python
.
framework
/
Versions
/
2
.
7
/
lib
/
python2
.
7
/
config
"
)
]
)
)
;
assert
!
(
!
is_static_available
(
"
ffi_convenience
"
system_roots
&
[
PathBuf
:
:
from
(
"
/
Library
/
Ruby
/
Gems
/
2
.
0
.
0
/
gems
/
ffi
-
1
.
9
.
10
/
ext
/
ffi_c
/
libffi
-
x86_64
/
.
libs
"
)
]
)
)
;
if
Path
:
:
new
(
"
/
usr
/
local
/
lib
/
libpng16
.
a
"
)
.
exists
(
)
{
assert
!
(
is_static_available
(
"
png16
"
system_roots
&
[
PathBuf
:
:
from
(
"
/
usr
/
local
/
lib
"
)
]
)
)
;
let
libpng
=
Config
:
:
new
(
)
.
range_version
(
"
1
"
.
.
"
99
"
)
.
probe
(
"
libpng16
"
)
.
unwrap
(
)
;
assert
!
(
libpng
.
version
.
find
(
'
\
n
'
)
.
is_none
(
)
)
;
}
}
#
[
test
]
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
system_library_linux_test
(
)
{
assert
!
(
!
is_static_available
(
"
util
"
&
[
PathBuf
:
:
from
(
"
/
usr
"
)
]
&
[
PathBuf
:
:
from
(
"
/
usr
/
lib
/
x86_64
-
linux
-
gnu
"
)
]
)
)
;
assert
!
(
!
is_static_available
(
"
dialog
"
&
[
PathBuf
:
:
from
(
"
/
usr
"
)
]
&
[
PathBuf
:
:
from
(
"
/
usr
/
lib
"
)
]
)
)
;
}
