#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
pkg
-
config
/
0
.
3
"
)
]
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
env
;
use
std
:
:
error
;
use
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
{
Bound
RangeBounds
}
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
process
:
:
{
Command
Output
}
;
use
std
:
:
str
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
Config
{
statik
:
Option
<
bool
>
min_version
:
Bound
<
String
>
max_version
:
Bound
<
String
>
extra_args
:
Vec
<
OsString
>
cargo_metadata
:
bool
env_metadata
:
bool
print_system_libs
:
bool
print_system_cflags
:
bool
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Library
{
pub
libs
:
Vec
<
String
>
pub
link_paths
:
Vec
<
PathBuf
>
pub
link_files
:
Vec
<
PathBuf
>
pub
frameworks
:
Vec
<
String
>
pub
framework_paths
:
Vec
<
PathBuf
>
pub
include_paths
:
Vec
<
PathBuf
>
pub
ld_args
:
Vec
<
Vec
<
String
>
>
pub
defines
:
HashMap
<
String
Option
<
String
>
>
pub
version
:
String
_priv
:
(
)
}
pub
enum
Error
{
EnvNoPkgConfig
(
String
)
CrossCompilation
Command
{
command
:
String
cause
:
io
:
:
Error
}
Failure
{
command
:
String
output
:
Output
}
ProbeFailure
{
name
:
String
command
:
String
output
:
Output
}
#
[
doc
(
hidden
)
]
__Nonexhaustive
}
impl
error
:
:
Error
for
Error
{
}
impl
fmt
:
:
Debug
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
<
Error
as
fmt
:
:
Display
>
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
match
*
self
{
Error
:
:
EnvNoPkgConfig
(
ref
name
)
=
>
write
!
(
f
"
Aborted
because
{
}
is
set
"
name
)
Error
:
:
CrossCompilation
=
>
f
.
write_str
(
"
pkg
-
config
has
not
been
configured
to
support
cross
-
compilation
.
\
n
\
\
n
\
Install
a
sysroot
for
the
target
platform
and
configure
it
via
\
n
\
PKG_CONFIG_SYSROOT_DIR
and
PKG_CONFIG_PATH
or
install
a
\
n
\
cross
-
compiling
wrapper
for
pkg
-
config
and
set
it
via
\
n
\
PKG_CONFIG
environment
variable
.
"
)
Error
:
:
Command
{
ref
command
ref
cause
}
=
>
{
match
cause
.
kind
(
)
{
io
:
:
ErrorKind
:
:
NotFound
=
>
{
let
crate_name
=
std
:
:
env
:
:
var
(
"
CARGO_PKG_NAME
"
)
.
unwrap_or_else
(
|
_
|
"
sys
"
.
to_owned
(
)
)
;
let
instructions
=
if
cfg
!
(
target_os
=
"
macos
"
)
|
|
cfg
!
(
target_os
=
"
ios
"
)
{
"
Try
brew
install
pkg
-
config
if
you
have
Homebrew
.
\
n
"
}
else
if
cfg
!
(
unix
)
{
"
Try
apt
install
pkg
-
config
or
yum
install
pkg
-
config
\
n
\
or
pkg
install
pkg
-
config
or
apk
add
pkgconfig
\
depending
on
your
distribution
.
\
n
"
}
else
{
"
"
}
;
write
!
(
f
"
Could
not
run
{
command
}
\
n
\
The
pkg
-
config
command
could
not
be
found
.
\
n
\
\
n
\
Most
likely
you
need
to
install
a
pkg
-
config
package
for
your
OS
.
\
n
\
{
instructions
}
\
\
n
\
If
you
'
ve
already
installed
it
ensure
the
pkg
-
config
command
is
one
of
the
\
n
\
directories
in
the
PATH
environment
variable
.
\
n
\
\
n
\
If
you
did
not
expect
this
build
to
link
to
a
pre
-
installed
system
library
\
n
\
then
check
documentation
of
the
{
crate_name
}
crate
for
an
option
to
\
n
\
build
the
library
from
source
or
disable
features
or
dependencies
\
n
\
that
require
pkg
-
config
.
"
command
=
command
instructions
=
instructions
crate_name
=
crate_name
)
}
_
=
>
write
!
(
f
"
Failed
to
run
command
{
}
because
:
{
}
"
command
cause
)
}
}
Error
:
:
ProbeFailure
{
ref
name
ref
command
ref
output
}
=
>
{
write
!
(
f
"
{
}
did
not
exit
successfully
:
{
}
\
nerror
:
could
not
find
system
library
'
{
}
'
required
by
the
'
{
}
'
crate
\
n
"
command
output
.
status
name
env
:
:
var
(
"
CARGO_PKG_NAME
"
)
.
unwrap_or_default
(
)
)
?
;
format_output
(
output
f
)
}
Error
:
:
Failure
{
ref
command
ref
output
}
=
>
{
write
!
(
f
"
{
}
did
not
exit
successfully
:
{
}
"
command
output
.
status
)
?
;
format_output
(
output
f
)
}
Error
:
:
__Nonexhaustive
=
>
panic
!
(
)
}
}
}
fn
format_output
(
output
:
&
Output
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
stdout
=
String
:
:
from_utf8_lossy
(
&
output
.
stdout
)
;
if
!
stdout
.
is_empty
(
)
{
write
!
(
f
"
\
n
-
-
-
stdout
\
n
{
}
"
stdout
)
?
;
}
let
stderr
=
String
:
:
from_utf8_lossy
(
&
output
.
stderr
)
;
if
!
stderr
.
is_empty
(
)
{
write
!
(
f
"
\
n
-
-
-
stderr
\
n
{
}
"
stderr
)
?
;
}
Ok
(
(
)
)
}
#
[
doc
(
hidden
)
]
pub
fn
find_library
(
name
:
&
str
)
-
>
Result
<
Library
String
>
{
probe_library
(
name
)
.
map_err
(
|
e
|
e
.
to_string
(
)
)
}
pub
fn
probe_library
(
name
:
&
str
)
-
>
Result
<
Library
Error
>
{
Config
:
:
new
(
)
.
probe
(
name
)
}
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
use
config
.
target_supported
(
)
instance
method
instead
"
)
]
pub
fn
target_supported
(
)
-
>
bool
{
Config
:
:
new
(
)
.
target_supported
(
)
}
pub
fn
get_variable
(
package
:
&
str
variable
:
&
str
)
-
>
Result
<
String
Error
>
{
let
arg
=
format
!
(
"
-
-
variable
=
{
}
"
variable
)
;
let
cfg
=
Config
:
:
new
(
)
;
let
out
=
run
(
cfg
.
command
(
package
&
[
&
arg
]
)
)
?
;
Ok
(
str
:
:
from_utf8
(
&
out
)
.
unwrap
(
)
.
trim_end
(
)
.
to_owned
(
)
)
}
impl
Config
{
pub
fn
new
(
)
-
>
Config
{
Config
{
statik
:
None
min_version
:
Bound
:
:
Unbounded
max_version
:
Bound
:
:
Unbounded
extra_args
:
vec
!
[
]
print_system_cflags
:
true
print_system_libs
:
true
cargo_metadata
:
true
env_metadata
:
true
}
}
pub
fn
statik
(
&
mut
self
statik
:
bool
)
-
>
&
mut
Config
{
self
.
statik
=
Some
(
statik
)
;
self
}
pub
fn
atleast_version
(
&
mut
self
vers
:
&
str
)
-
>
&
mut
Config
{
self
.
min_version
=
Bound
:
:
Included
(
vers
.
to_string
(
)
)
;
self
.
max_version
=
Bound
:
:
Unbounded
;
self
}
pub
fn
exactly_version
(
&
mut
self
vers
:
&
str
)
-
>
&
mut
Config
{
self
.
min_version
=
Bound
:
:
Included
(
vers
.
to_string
(
)
)
;
self
.
max_version
=
Bound
:
:
Included
(
vers
.
to_string
(
)
)
;
self
}
pub
fn
range_version
<
'
a
R
>
(
&
mut
self
range
:
R
)
-
>
&
mut
Config
where
R
:
RangeBounds
<
&
'
a
str
>
{
self
.
min_version
=
match
range
.
start_bound
(
)
{
Bound
:
:
Included
(
vers
)
=
>
Bound
:
:
Included
(
vers
.
to_string
(
)
)
Bound
:
:
Excluded
(
vers
)
=
>
Bound
:
:
Excluded
(
vers
.
to_string
(
)
)
Bound
:
:
Unbounded
=
>
Bound
:
:
Unbounded
}
;
self
.
max_version
=
match
range
.
end_bound
(
)
{
Bound
:
:
Included
(
vers
)
=
>
Bound
:
:
Included
(
vers
.
to_string
(
)
)
Bound
:
:
Excluded
(
vers
)
=
>
Bound
:
:
Excluded
(
vers
.
to_string
(
)
)
Bound
:
:
Unbounded
=
>
Bound
:
:
Unbounded
}
;
self
}
pub
fn
arg
<
S
:
AsRef
<
OsStr
>
>
(
&
mut
self
arg
:
S
)
-
>
&
mut
Config
{
self
.
extra_args
.
push
(
arg
.
as_ref
(
)
.
to_os_string
(
)
)
;
self
}
pub
fn
cargo_metadata
(
&
mut
self
cargo_metadata
:
bool
)
-
>
&
mut
Config
{
self
.
cargo_metadata
=
cargo_metadata
;
self
}
pub
fn
env_metadata
(
&
mut
self
env_metadata
:
bool
)
-
>
&
mut
Config
{
self
.
env_metadata
=
env_metadata
;
self
}
pub
fn
print_system_libs
(
&
mut
self
print
:
bool
)
-
>
&
mut
Config
{
self
.
print_system_libs
=
print
;
self
}
pub
fn
print_system_cflags
(
&
mut
self
print
:
bool
)
-
>
&
mut
Config
{
self
.
print_system_cflags
=
print
;
self
}
#
[
doc
(
hidden
)
]
pub
fn
find
(
&
self
name
:
&
str
)
-
>
Result
<
Library
String
>
{
self
.
probe
(
name
)
.
map_err
(
|
e
|
e
.
to_string
(
)
)
}
pub
fn
probe
(
&
self
name
:
&
str
)
-
>
Result
<
Library
Error
>
{
let
abort_var_name
=
format
!
(
"
{
}
_NO_PKG_CONFIG
"
envify
(
name
)
)
;
if
self
.
env_var_os
(
&
abort_var_name
)
.
is_some
(
)
{
return
Err
(
Error
:
:
EnvNoPkgConfig
(
abort_var_name
)
)
;
}
else
if
!
self
.
target_supported
(
)
{
return
Err
(
Error
:
:
CrossCompilation
)
;
}
let
mut
library
=
Library
:
:
new
(
)
;
let
output
=
run
(
self
.
command
(
name
&
[
"
-
-
libs
"
"
-
-
cflags
"
]
)
)
.
map_err
(
|
e
|
match
e
{
Error
:
:
Failure
{
command
output
}
=
>
Error
:
:
ProbeFailure
{
name
:
name
.
to_owned
(
)
command
output
}
other
=
>
other
}
)
?
;
library
.
parse_libs_cflags
(
name
&
output
self
)
;
let
output
=
run
(
self
.
command
(
name
&
[
"
-
-
modversion
"
]
)
)
?
;
library
.
parse_modversion
(
str
:
:
from_utf8
(
&
output
)
.
unwrap
(
)
)
;
Ok
(
library
)
}
pub
fn
target_supported
(
&
self
)
-
>
bool
{
let
target
=
env
:
:
var_os
(
"
TARGET
"
)
.
unwrap_or_default
(
)
;
let
host
=
env
:
:
var_os
(
"
HOST
"
)
.
unwrap_or_default
(
)
;
if
host
=
=
target
{
return
true
;
}
match
self
.
targetted_env_var
(
"
PKG_CONFIG_ALLOW_CROSS
"
)
{
Some
(
ref
val
)
if
val
=
=
"
0
"
=
>
false
Some
(
_
)
=
>
true
None
=
>
{
self
.
targetted_env_var
(
"
PKG_CONFIG
"
)
.
is_some
(
)
|
|
self
.
targetted_env_var
(
"
PKG_CONFIG_SYSROOT_DIR
"
)
.
is_some
(
)
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
get_variable
(
package
:
&
str
variable
:
&
str
)
-
>
Result
<
String
String
>
{
get_variable
(
package
variable
)
.
map_err
(
|
e
|
e
.
to_string
(
)
)
}
fn
targetted_env_var
(
&
self
var_base
:
&
str
)
-
>
Option
<
OsString
>
{
match
(
env
:
:
var
(
"
TARGET
"
)
env
:
:
var
(
"
HOST
"
)
)
{
(
Ok
(
target
)
Ok
(
host
)
)
=
>
{
let
kind
=
if
host
=
=
target
{
"
HOST
"
}
else
{
"
TARGET
"
}
;
let
target_u
=
target
.
replace
(
"
-
"
"
_
"
)
;
self
.
env_var_os
(
&
format
!
(
"
{
}
_
{
}
"
var_base
target
)
)
.
or_else
(
|
|
self
.
env_var_os
(
&
format
!
(
"
{
}
_
{
}
"
var_base
target_u
)
)
)
.
or_else
(
|
|
self
.
env_var_os
(
&
format
!
(
"
{
}
_
{
}
"
kind
var_base
)
)
)
.
or_else
(
|
|
self
.
env_var_os
(
var_base
)
)
}
(
Err
(
env
:
:
VarError
:
:
NotPresent
)
_
)
|
(
_
Err
(
env
:
:
VarError
:
:
NotPresent
)
)
=
>
{
self
.
env_var_os
(
var_base
)
}
(
Err
(
env
:
:
VarError
:
:
NotUnicode
(
s
)
)
_
)
|
(
_
Err
(
env
:
:
VarError
:
:
NotUnicode
(
s
)
)
)
=
>
{
panic
!
(
"
HOST
or
TARGET
environment
variable
is
not
valid
unicode
:
{
:
?
}
"
s
)
}
}
}
fn
env_var_os
(
&
self
name
:
&
str
)
-
>
Option
<
OsString
>
{
if
self
.
env_metadata
{
println
!
(
"
cargo
:
rerun
-
if
-
env
-
changed
=
{
}
"
name
)
;
}
env
:
:
var_os
(
name
)
}
fn
is_static
(
&
self
name
:
&
str
)
-
>
bool
{
self
.
statik
.
unwrap_or_else
(
|
|
self
.
infer_static
(
name
)
)
}
fn
command
(
&
self
name
:
&
str
args
:
&
[
&
str
]
)
-
>
Command
{
let
exe
=
self
.
targetted_env_var
(
"
PKG_CONFIG
"
)
.
unwrap_or_else
(
|
|
OsString
:
:
from
(
"
pkg
-
config
"
)
)
;
let
mut
cmd
=
Command
:
:
new
(
exe
)
;
if
self
.
is_static
(
name
)
{
cmd
.
arg
(
"
-
-
static
"
)
;
}
cmd
.
args
(
args
)
.
args
(
&
self
.
extra_args
)
;
if
let
Some
(
value
)
=
self
.
targetted_env_var
(
"
PKG_CONFIG_PATH
"
)
{
cmd
.
env
(
"
PKG_CONFIG_PATH
"
value
)
;
}
if
let
Some
(
value
)
=
self
.
targetted_env_var
(
"
PKG_CONFIG_LIBDIR
"
)
{
cmd
.
env
(
"
PKG_CONFIG_LIBDIR
"
value
)
;
}
if
let
Some
(
value
)
=
self
.
targetted_env_var
(
"
PKG_CONFIG_SYSROOT_DIR
"
)
{
cmd
.
env
(
"
PKG_CONFIG_SYSROOT_DIR
"
value
)
;
}
if
self
.
print_system_libs
{
cmd
.
env
(
"
PKG_CONFIG_ALLOW_SYSTEM_LIBS
"
"
1
"
)
;
}
if
self
.
print_system_cflags
{
cmd
.
env
(
"
PKG_CONFIG_ALLOW_SYSTEM_CFLAGS
"
"
1
"
)
;
}
cmd
.
arg
(
name
)
;
match
self
.
min_version
{
Bound
:
:
Included
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
>
=
{
}
"
name
version
)
)
;
}
Bound
:
:
Excluded
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
>
{
}
"
name
version
)
)
;
}
_
=
>
(
)
}
match
self
.
max_version
{
Bound
:
:
Included
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
<
=
{
}
"
name
version
)
)
;
}
Bound
:
:
Excluded
(
ref
version
)
=
>
{
cmd
.
arg
(
&
format
!
(
"
{
}
<
{
}
"
name
version
)
)
;
}
_
=
>
(
)
}
cmd
}
fn
print_metadata
(
&
self
s
:
&
str
)
{
if
self
.
cargo_metadata
{
println
!
(
"
cargo
:
{
}
"
s
)
;
}
}
fn
infer_static
(
&
self
name
:
&
str
)
-
>
bool
{
let
name
=
envify
(
name
)
;
if
self
.
env_var_os
(
&
format
!
(
"
{
}
_STATIC
"
name
)
)
.
is_some
(
)
{
true
}
else
if
self
.
env_var_os
(
&
format
!
(
"
{
}
_DYNAMIC
"
name
)
)
.
is_some
(
)
{
false
}
else
if
self
.
env_var_os
(
"
PKG_CONFIG_ALL_STATIC
"
)
.
is_some
(
)
{
true
}
else
if
self
.
env_var_os
(
"
PKG_CONFIG_ALL_DYNAMIC
"
)
.
is_some
(
)
{
false
}
else
{
false
}
}
}
impl
Default
for
Config
{
fn
default
(
)
-
>
Config
{
Config
{
statik
:
None
min_version
:
Bound
:
:
Unbounded
max_version
:
Bound
:
:
Unbounded
extra_args
:
vec
!
[
]
print_system_cflags
:
false
print_system_libs
:
false
cargo_metadata
:
false
env_metadata
:
false
}
}
}
impl
Library
{
fn
new
(
)
-
>
Library
{
Library
{
libs
:
Vec
:
:
new
(
)
link_paths
:
Vec
:
:
new
(
)
link_files
:
Vec
:
:
new
(
)
include_paths
:
Vec
:
:
new
(
)
ld_args
:
Vec
:
:
new
(
)
frameworks
:
Vec
:
:
new
(
)
framework_paths
:
Vec
:
:
new
(
)
defines
:
HashMap
:
:
new
(
)
version
:
String
:
:
new
(
)
_priv
:
(
)
}
}
fn
extract_lib_from_filename
<
'
a
>
(
target
:
&
str
filename
:
&
'
a
str
)
-
>
Option
<
&
'
a
str
>
{
fn
test_suffixes
<
'
b
>
(
filename
:
&
'
b
str
suffixes
:
&
[
&
str
]
)
-
>
Option
<
&
'
b
str
>
{
for
suffix
in
suffixes
{
if
filename
.
ends_with
(
suffix
)
{
return
Some
(
&
filename
[
.
.
filename
.
len
(
)
-
suffix
.
len
(
)
]
)
;
}
}
None
}
let
prefix
=
"
lib
"
;
if
target
.
contains
(
"
msvc
"
)
{
return
test_suffixes
(
filename
&
[
"
.
lib
"
]
)
;
}
else
if
target
.
contains
(
"
windows
"
)
&
&
target
.
contains
(
"
gnu
"
)
{
if
filename
.
starts_with
(
prefix
)
{
let
filename
=
&
filename
[
prefix
.
len
(
)
.
.
]
;
return
test_suffixes
(
filename
&
[
"
.
dll
.
a
"
"
.
dll
"
"
.
lib
"
"
.
a
"
]
)
;
}
else
{
return
test_suffixes
(
filename
&
[
"
.
dll
.
a
"
"
.
dll
"
"
.
lib
"
]
)
;
}
}
else
if
target
.
contains
(
"
apple
"
)
{
if
filename
.
starts_with
(
prefix
)
{
let
filename
=
&
filename
[
prefix
.
len
(
)
.
.
]
;
return
test_suffixes
(
filename
&
[
"
.
a
"
"
.
so
"
"
.
dylib
"
]
)
;
}
return
None
;
}
else
{
if
filename
.
starts_with
(
prefix
)
{
let
filename
=
&
filename
[
prefix
.
len
(
)
.
.
]
;
return
test_suffixes
(
filename
&
[
"
.
a
"
"
.
so
"
]
)
;
}
return
None
;
}
}
fn
parse_libs_cflags
(
&
mut
self
name
:
&
str
output
:
&
[
u8
]
config
:
&
Config
)
{
let
mut
is_msvc
=
false
;
let
target
=
env
:
:
var
(
"
TARGET
"
)
;
if
let
Ok
(
target
)
=
&
target
{
if
target
.
contains
(
"
msvc
"
)
{
is_msvc
=
true
;
}
}
let
system_roots
=
if
cfg
!
(
target_os
=
"
macos
"
)
{
vec
!
[
PathBuf
:
:
from
(
"
/
Library
"
)
PathBuf
:
:
from
(
"
/
System
"
)
]
}
else
{
let
sysroot
=
config
.
env_var_os
(
"
PKG_CONFIG_SYSROOT_DIR
"
)
.
or_else
(
|
|
config
.
env_var_os
(
"
SYSROOT
"
)
)
.
map
(
PathBuf
:
:
from
)
;
if
cfg
!
(
target_os
=
"
windows
"
)
{
if
let
Some
(
sysroot
)
=
sysroot
{
vec
!
[
sysroot
]
}
else
{
vec
!
[
]
}
}
else
{
vec
!
[
sysroot
.
unwrap_or_else
(
|
|
PathBuf
:
:
from
(
"
/
usr
"
)
)
]
}
}
;
let
mut
dirs
=
Vec
:
:
new
(
)
;
let
statik
=
config
.
is_static
(
name
)
;
let
words
=
split_flags
(
output
)
;
let
parts
=
words
.
iter
(
)
.
filter
(
|
l
|
l
.
len
(
)
>
2
)
.
map
(
|
arg
|
(
&
arg
[
0
.
.
2
]
&
arg
[
2
.
.
]
)
)
;
for
(
flag
val
)
in
parts
{
match
flag
{
"
-
L
"
=
>
{
let
meta
=
format
!
(
"
rustc
-
link
-
search
=
native
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
dirs
.
push
(
PathBuf
:
:
from
(
val
)
)
;
self
.
link_paths
.
push
(
PathBuf
:
:
from
(
val
)
)
;
}
"
-
F
"
=
>
{
let
meta
=
format
!
(
"
rustc
-
link
-
search
=
framework
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
self
.
framework_paths
.
push
(
PathBuf
:
:
from
(
val
)
)
;
}
"
-
I
"
=
>
{
self
.
include_paths
.
push
(
PathBuf
:
:
from
(
val
)
)
;
}
"
-
l
"
=
>
{
if
is_msvc
&
&
[
"
m
"
"
c
"
"
pthread
"
]
.
contains
(
&
val
)
{
continue
;
}
if
statik
&
&
is_static_available
(
val
&
system_roots
&
dirs
)
{
let
meta
=
format
!
(
"
rustc
-
link
-
lib
=
static
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
}
else
{
let
meta
=
format
!
(
"
rustc
-
link
-
lib
=
{
}
"
val
)
;
config
.
print_metadata
(
&
meta
)
;
}
self
.
libs
.
push
(
val
.
to_string
(
)
)
;
}
"
-
D
"
=
>
{
let
mut
iter
=
val
.
split
(
'
=
'
)
;
self
.
defines
.
insert
(
iter
.
next
(
)
.
unwrap
(
)
.
to_owned
(
)
iter
.
next
(
)
.
map
(
|
s
|
s
.
to_owned
(
)
)
)
;
}
_
=
>
{
}
}
}
let
mut
iter
=
words
.
iter
(
)
.
flat_map
(
|
arg
|
{
if
arg
.
starts_with
(
"
-
Wl
"
)
{
arg
[
4
.
.
]
.
split
(
'
'
)
.
collect
(
)
}
else
{
vec
!
[
arg
.
as_ref
(
)
]
}
}
)
;
while
let
Some
(
part
)
=
iter
.
next
(
)
{
match
part
{
"
-
framework
"
=
>
{
if
let
Some
(
lib
)
=
iter
.
next
(
)
{
let
meta
=
format
!
(
"
rustc
-
link
-
lib
=
framework
=
{
}
"
lib
)
;
config
.
print_metadata
(
&
meta
)
;
self
.
frameworks
.
push
(
lib
.
to_string
(
)
)
;
}
}
"
-
isystem
"
|
"
-
iquote
"
|
"
-
idirafter
"
=
>
{
if
let
Some
(
inc
)
=
iter
.
next
(
)
{
self
.
include_paths
.
push
(
PathBuf
:
:
from
(
inc
)
)
;
}
}
_
=
>
{
let
path
=
std
:
:
path
:
:
Path
:
:
new
(
part
)
;
if
path
.
is_file
(
)
{
if
let
(
Some
(
dir
)
Some
(
file_name
)
Ok
(
target
)
)
=
(
path
.
parent
(
)
path
.
file_name
(
)
&
target
)
{
match
Self
:
:
extract_lib_from_filename
(
target
&
file_name
.
to_string_lossy
(
)
)
{
Some
(
lib_basename
)
=
>
{
let
link_search
=
format
!
(
"
rustc
-
link
-
search
=
{
}
"
dir
.
display
(
)
)
;
config
.
print_metadata
(
&
link_search
)
;
let
link_lib
=
format
!
(
"
rustc
-
link
-
lib
=
{
}
"
lib_basename
)
;
config
.
print_metadata
(
&
link_lib
)
;
self
.
link_files
.
push
(
PathBuf
:
:
from
(
path
)
)
;
}
None
=
>
{
println
!
(
"
cargo
:
warning
=
File
path
{
}
found
in
pkg
-
config
file
for
{
}
but
could
not
extract
library
base
name
to
pass
to
linker
command
line
"
path
.
display
(
)
name
)
;
}
}
}
}
}
}
}
let
mut
linker_options
=
words
.
iter
(
)
.
filter
(
|
arg
|
arg
.
starts_with
(
"
-
Wl
"
)
)
;
while
let
Some
(
option
)
=
linker_options
.
next
(
)
{
let
mut
pop
=
false
;
let
mut
ld_option
=
vec
!
[
]
;
for
subopt
in
option
[
4
.
.
]
.
split
(
'
'
)
{
if
pop
{
pop
=
false
;
continue
;
}
if
subopt
=
=
"
-
framework
"
{
pop
=
true
;
continue
;
}
ld_option
.
push
(
subopt
)
;
}
let
meta
=
format
!
(
"
rustc
-
link
-
arg
=
-
Wl
{
}
"
ld_option
.
join
(
"
"
)
)
;
config
.
print_metadata
(
&
meta
)
;
self
.
ld_args
.
push
(
ld_option
.
into_iter
(
)
.
map
(
String
:
:
from
)
.
collect
(
)
)
;
}
}
fn
parse_modversion
(
&
mut
self
output
:
&
str
)
{
self
.
version
.
push_str
(
output
.
lines
(
)
.
nth
(
0
)
.
unwrap
(
)
.
trim
(
)
)
;
}
}
fn
envify
(
name
:
&
str
)
-
>
String
{
name
.
chars
(
)
.
map
(
|
c
|
c
.
to_ascii_uppercase
(
)
)
.
map
(
|
c
|
if
c
=
=
'
-
'
{
'
_
'
}
else
{
c
}
)
.
collect
(
)
}
fn
is_static_available
(
name
:
&
str
system_roots
:
&
[
PathBuf
]
dirs
:
&
[
PathBuf
]
)
-
>
bool
{
let
libname
=
format
!
(
"
lib
{
}
.
a
"
name
)
;
dirs
.
iter
(
)
.
any
(
|
dir
|
{
!
system_roots
.
iter
(
)
.
any
(
|
sys
|
dir
.
starts_with
(
sys
)
)
&
&
dir
.
join
(
&
libname
)
.
exists
(
)
}
)
}
fn
run
(
mut
cmd
:
Command
)
-
>
Result
<
Vec
<
u8
>
Error
>
{
match
cmd
.
output
(
)
{
Ok
(
output
)
=
>
{
if
output
.
status
.
success
(
)
{
Ok
(
output
.
stdout
)
}
else
{
Err
(
Error
:
:
Failure
{
command
:
format
!
(
"
{
:
?
}
"
cmd
)
output
}
)
}
}
Err
(
cause
)
=
>
Err
(
Error
:
:
Command
{
command
:
format
!
(
"
{
:
?
}
"
cmd
)
cause
}
)
}
}
fn
split_flags
(
output
:
&
[
u8
]
)
-
>
Vec
<
String
>
{
let
mut
word
=
Vec
:
:
new
(
)
;
let
mut
words
=
Vec
:
:
new
(
)
;
let
mut
escaped
=
false
;
for
&
b
in
output
{
match
b
{
_
if
escaped
=
>
{
escaped
=
false
;
word
.
push
(
b
)
;
}
b
'
\
\
'
=
>
escaped
=
true
b
'
\
t
'
|
b
'
\
n
'
|
b
'
\
r
'
|
b
'
'
=
>
{
if
!
word
.
is_empty
(
)
{
words
.
push
(
String
:
:
from_utf8
(
word
)
.
unwrap
(
)
)
;
word
=
Vec
:
:
new
(
)
;
}
}
_
=
>
word
.
push
(
b
)
}
}
if
!
word
.
is_empty
(
)
{
words
.
push
(
String
:
:
from_utf8
(
word
)
.
unwrap
(
)
)
;
}
words
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
#
[
cfg
(
target_os
=
"
macos
"
)
]
fn
system_library_mac_test
(
)
{
use
std
:
:
path
:
:
Path
;
let
system_roots
=
vec
!
[
PathBuf
:
:
from
(
"
/
Library
"
)
PathBuf
:
:
from
(
"
/
System
"
)
]
;
assert
!
(
!
is_static_available
(
"
PluginManager
"
&
system_roots
&
[
PathBuf
:
:
from
(
"
/
Library
/
Frameworks
"
)
]
)
)
;
assert
!
(
!
is_static_available
(
"
python2
.
7
"
&
system_roots
&
[
PathBuf
:
:
from
(
"
/
System
/
Library
/
Frameworks
/
Python
.
framework
/
Versions
/
2
.
7
/
lib
/
python2
.
7
/
config
"
)
]
)
)
;
assert
!
(
!
is_static_available
(
"
ffi_convenience
"
&
system_roots
&
[
PathBuf
:
:
from
(
"
/
Library
/
Ruby
/
Gems
/
2
.
0
.
0
/
gems
/
ffi
-
1
.
9
.
10
/
ext
/
ffi_c
/
libffi
-
x86_64
/
.
libs
"
)
]
)
)
;
if
Path
:
:
new
(
"
/
usr
/
local
/
lib
/
libpng16
.
a
"
)
.
exists
(
)
{
assert
!
(
is_static_available
(
"
png16
"
&
system_roots
&
[
PathBuf
:
:
from
(
"
/
usr
/
local
/
lib
"
)
]
)
)
;
let
libpng
=
Config
:
:
new
(
)
.
range_version
(
"
1
"
.
.
"
99
"
)
.
probe
(
"
libpng16
"
)
.
unwrap
(
)
;
assert
!
(
libpng
.
version
.
find
(
'
\
n
'
)
.
is_none
(
)
)
;
}
}
#
[
test
]
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
system_library_linux_test
(
)
{
assert
!
(
!
is_static_available
(
"
util
"
&
[
PathBuf
:
:
from
(
"
/
usr
"
)
]
&
[
PathBuf
:
:
from
(
"
/
usr
/
lib
/
x86_64
-
linux
-
gnu
"
)
]
)
)
;
assert
!
(
!
is_static_available
(
"
dialog
"
&
[
PathBuf
:
:
from
(
"
/
usr
"
)
]
&
[
PathBuf
:
:
from
(
"
/
usr
/
lib
"
)
]
)
)
;
}
fn
test_library_filename
(
target
:
&
str
filename
:
&
str
)
{
assert_eq
!
(
Library
:
:
extract_lib_from_filename
(
target
filename
)
Some
(
"
foo
"
)
)
;
}
#
[
test
]
fn
link_filename_linux
(
)
{
let
target
=
"
x86_64
-
unknown
-
linux
-
gnu
"
;
test_library_filename
(
target
"
libfoo
.
a
"
)
;
test_library_filename
(
target
"
libfoo
.
so
"
)
;
}
#
[
test
]
fn
link_filename_apple
(
)
{
let
target
=
"
x86_64
-
apple
-
darwin
"
;
test_library_filename
(
target
"
libfoo
.
a
"
)
;
test_library_filename
(
target
"
libfoo
.
so
"
)
;
test_library_filename
(
target
"
libfoo
.
dylib
"
)
;
}
#
[
test
]
fn
link_filename_msvc
(
)
{
let
target
=
"
x86_64
-
pc
-
windows
-
msvc
"
;
test_library_filename
(
target
"
foo
.
lib
"
)
;
}
#
[
test
]
fn
link_filename_mingw
(
)
{
let
target
=
"
x86_64
-
pc
-
windows
-
gnu
"
;
test_library_filename
(
target
"
foo
.
lib
"
)
;
test_library_filename
(
target
"
libfoo
.
a
"
)
;
test_library_filename
(
target
"
foo
.
dll
"
)
;
test_library_filename
(
target
"
foo
.
dll
.
a
"
)
;
}
}
