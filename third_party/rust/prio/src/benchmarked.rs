#
!
[
doc
(
hidden
)
]
use
crate
:
:
fft
:
:
discrete_fourier_transform
;
use
crate
:
:
field
:
:
FftFriendlyFieldElement
;
use
crate
:
:
flp
:
:
gadgets
:
:
Mul
;
use
crate
:
:
flp
:
:
FlpError
;
use
crate
:
:
polynomial
:
:
{
poly_fft
PolyAuxMemory
}
;
pub
fn
benchmarked_iterative_fft
<
F
:
FftFriendlyFieldElement
>
(
outp
:
&
mut
[
F
]
inp
:
&
[
F
]
)
{
discrete_fourier_transform
(
outp
inp
inp
.
len
(
)
)
.
unwrap
(
)
;
}
pub
fn
benchmarked_recursive_fft
<
F
:
FftFriendlyFieldElement
>
(
outp
:
&
mut
[
F
]
inp
:
&
[
F
]
)
{
let
mut
mem
=
PolyAuxMemory
:
:
new
(
inp
.
len
(
)
/
2
)
;
poly_fft
(
outp
inp
&
mem
.
roots_2n
inp
.
len
(
)
false
&
mut
mem
.
fft_memory
)
}
pub
fn
benchmarked_gadget_mul_call_poly_fft
<
F
:
FftFriendlyFieldElement
>
(
g
:
&
mut
Mul
<
F
>
outp
:
&
mut
[
F
]
inp
:
&
[
Vec
<
F
>
]
)
-
>
Result
<
(
)
FlpError
>
{
g
.
call_poly_fft
(
outp
inp
)
}
pub
fn
benchmarked_gadget_mul_call_poly_direct
<
F
:
FftFriendlyFieldElement
>
(
g
:
&
mut
Mul
<
F
>
outp
:
&
mut
[
F
]
inp
:
&
[
Vec
<
F
>
]
)
-
>
Result
<
(
)
FlpError
>
{
g
.
call_poly_direct
(
outp
inp
)
}
