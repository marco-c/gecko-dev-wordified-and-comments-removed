use
crate
:
:
field
:
:
{
Field128
FieldElementWithInteger
}
;
use
fixed
:
:
types
:
:
extra
:
:
{
U15
U31
U63
}
;
use
fixed
:
:
{
FixedI16
FixedI32
FixedI64
}
;
pub
trait
CompatibleFloat
<
F
:
FieldElementWithInteger
>
{
fn
to_float
(
t
:
F
c
:
u128
)
-
>
f64
;
fn
to_field_integer
(
&
self
)
-
>
<
F
as
FieldElementWithInteger
>
:
:
Integer
;
}
impl
CompatibleFloat
<
Field128
>
for
FixedI16
<
U15
>
{
fn
to_float
(
d
:
Field128
c
:
u128
)
-
>
f64
{
to_float_bits
(
d
c
16
)
}
fn
to_field_integer
(
&
self
)
-
>
<
Field128
as
FieldElementWithInteger
>
:
:
Integer
{
let
i
:
i16
=
self
.
to_bits
(
)
;
let
u
=
i
as
u16
;
u128
:
:
from
(
u
^
(
1
<
<
15
)
)
}
}
impl
CompatibleFloat
<
Field128
>
for
FixedI32
<
U31
>
{
fn
to_float
(
d
:
Field128
c
:
u128
)
-
>
f64
{
to_float_bits
(
d
c
32
)
}
fn
to_field_integer
(
&
self
)
-
>
<
Field128
as
FieldElementWithInteger
>
:
:
Integer
{
let
i
:
i32
=
self
.
to_bits
(
)
;
let
u
=
i
as
u32
;
u128
:
:
from
(
u
^
(
1
<
<
31
)
)
}
}
impl
CompatibleFloat
<
Field128
>
for
FixedI64
<
U63
>
{
fn
to_float
(
d
:
Field128
c
:
u128
)
-
>
f64
{
to_float_bits
(
d
c
64
)
}
fn
to_field_integer
(
&
self
)
-
>
<
Field128
as
FieldElementWithInteger
>
:
:
Integer
{
let
i
:
i64
=
self
.
to_bits
(
)
;
let
u
=
i
as
u64
;
u128
:
:
from
(
u
^
(
1
<
<
63
)
)
}
}
fn
to_float_bits
(
s
:
Field128
c
:
u128
n
:
i32
)
-
>
f64
{
let
s_int
:
u128
=
<
Field128
as
FieldElementWithInteger
>
:
:
Integer
:
:
from
(
s
)
;
let
(
a
b
sign
)
=
match
(
s_int
c
<
<
(
n
-
1
)
)
{
(
x
y
)
if
x
<
y
=
>
(
y
x
-
1
.
0f64
)
(
x
y
)
=
>
(
x
y
1
.
0f64
)
}
;
(
(
a
-
b
)
as
f64
)
*
sign
*
f64
:
:
powi
(
2
.
0
1
-
n
)
}
