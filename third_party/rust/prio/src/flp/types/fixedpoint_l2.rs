pub
mod
compatible_float
;
use
crate
:
:
dp
:
:
{
distributions
:
:
ZCdpDiscreteGaussian
DifferentialPrivacyStrategy
DpError
}
;
use
crate
:
:
field
:
:
{
Field128
FieldElement
FieldElementWithInteger
FieldElementWithIntegerExt
Integer
}
;
use
crate
:
:
flp
:
:
gadgets
:
:
{
Mul
ParallelSumGadget
PolyEval
}
;
use
crate
:
:
flp
:
:
types
:
:
fixedpoint_l2
:
:
compatible_float
:
:
CompatibleFloat
;
use
crate
:
:
flp
:
:
types
:
:
parallel_sum_range_checks
;
use
crate
:
:
flp
:
:
{
FlpError
Gadget
Type
TypeWithNoise
}
;
use
crate
:
:
vdaf
:
:
xof
:
:
SeedStreamTurboShake128
;
use
fixed
:
:
traits
:
:
Fixed
;
use
num_bigint
:
:
{
BigInt
BigUint
TryFromBigIntError
}
;
use
num_integer
:
:
Integer
as
_
;
use
num_rational
:
:
Ratio
;
use
rand
:
:
{
distributions
:
:
Distribution
Rng
}
;
use
rand_core
:
:
SeedableRng
;
use
std
:
:
{
convert
:
:
TryFrom
convert
:
:
TryInto
fmt
:
:
Debug
marker
:
:
PhantomData
}
;
#
[
derive
(
Clone
PartialEq
Eq
)
]
pub
struct
FixedPointBoundedL2VecSum
<
T
:
Fixed
SPoly
:
ParallelSumGadget
<
Field128
PolyEval
<
Field128
>
>
+
Clone
SMul
:
ParallelSumGadget
<
Field128
Mul
<
Field128
>
>
+
Clone
>
{
bits_per_entry
:
usize
entries
:
usize
bits_for_norm
:
usize
norm_summand_poly
:
Vec
<
Field128
>
phantom
:
PhantomData
<
(
T
SPoly
SMul
)
>
range_norm_begin
:
usize
range_norm_end
:
usize
gadget0_calls
:
usize
gadget0_chunk_length
:
usize
gadget1_calls
:
usize
gadget1_chunk_length
:
usize
}
impl
<
T
SPoly
SMul
>
Debug
for
FixedPointBoundedL2VecSum
<
T
SPoly
SMul
>
where
T
:
Fixed
SPoly
:
ParallelSumGadget
<
Field128
PolyEval
<
Field128
>
>
+
Clone
SMul
:
ParallelSumGadget
<
Field128
Mul
<
Field128
>
>
+
Clone
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
FixedPointBoundedL2VecSum
"
)
.
field
(
"
bits_per_entry
"
&
self
.
bits_per_entry
)
.
field
(
"
entries
"
&
self
.
entries
)
.
finish
(
)
}
}
impl
<
T
SPoly
SMul
>
FixedPointBoundedL2VecSum
<
T
SPoly
SMul
>
where
T
:
Fixed
SPoly
:
ParallelSumGadget
<
Field128
PolyEval
<
Field128
>
>
+
Clone
SMul
:
ParallelSumGadget
<
Field128
Mul
<
Field128
>
>
+
Clone
{
pub
fn
new
(
entries
:
usize
)
-
>
Result
<
Self
FlpError
>
{
let
fi_one
=
<
Field128
as
FieldElementWithInteger
>
:
:
Integer
:
:
one
(
)
;
if
<
T
as
Fixed
>
:
:
INT_NBITS
!
=
1
{
return
Err
(
FlpError
:
:
Encode
(
format
!
(
"
Expected
fixed
point
type
with
one
integer
bit
but
got
{
}
.
"
<
T
as
Fixed
>
:
:
INT_NBITS
)
)
)
;
}
let
bits_per_entry
:
usize
=
(
<
T
as
Fixed
>
:
:
INT_NBITS
+
<
T
as
Fixed
>
:
:
FRAC_NBITS
)
.
try_into
(
)
.
map_err
(
|
_
|
FlpError
:
:
Encode
(
"
Could
not
convert
u32
into
usize
.
"
.
to_string
(
)
)
)
?
;
if
!
Field128
:
:
valid_integer_bitlength
(
bits_per_entry
)
{
return
Err
(
FlpError
:
:
Encode
(
format
!
(
"
fixed
point
type
bit
length
(
{
bits_per_entry
}
)
too
large
for
field
modulus
"
)
)
)
;
}
let
bits_for_norm
=
2
*
bits_per_entry
-
2
;
if
!
Field128
:
:
valid_integer_bitlength
(
bits_for_norm
)
{
return
Err
(
FlpError
:
:
Encode
(
format
!
(
"
maximal
norm
bit
length
(
{
bits_for_norm
}
)
too
large
for
field
modulus
"
)
)
)
;
}
let
err
=
Err
(
FlpError
:
:
Encode
(
format
!
(
"
number
of
entries
(
{
entries
}
)
not
compatible
with
field
size
"
)
)
)
;
if
let
Some
(
val
)
=
(
entries
as
u128
)
.
checked_mul
(
1
<
<
bits_for_norm
)
{
if
val
>
=
Field128
:
:
modulus
(
)
{
return
err
;
}
}
else
{
return
err
;
}
let
linear_part
=
fi_one
<
<
bits_per_entry
;
let
constant_part
=
fi_one
<
<
(
bits_per_entry
+
bits_per_entry
-
2
)
;
let
norm_summand_poly
=
vec
!
[
Field128
:
:
from
(
constant_part
)
-
Field128
:
:
from
(
linear_part
)
Field128
:
:
one
(
)
]
;
let
len0
=
bits_per_entry
*
entries
+
bits_for_norm
;
let
gadget0_chunk_length
=
std
:
:
cmp
:
:
max
(
1
(
len0
as
f64
)
.
sqrt
(
)
as
usize
)
;
let
gadget0_calls
=
(
len0
+
gadget0_chunk_length
-
1
)
/
gadget0_chunk_length
;
let
len1
=
entries
;
let
gadget1_chunk_length
=
std
:
:
cmp
:
:
max
(
1
(
len1
as
f64
)
.
sqrt
(
)
as
usize
)
;
let
gadget1_calls
=
(
len1
+
gadget1_chunk_length
-
1
)
/
gadget1_chunk_length
;
Ok
(
Self
{
bits_per_entry
entries
bits_for_norm
norm_summand_poly
phantom
:
PhantomData
range_norm_begin
:
entries
*
bits_per_entry
range_norm_end
:
entries
*
bits_per_entry
+
bits_for_norm
gadget0_calls
gadget0_chunk_length
gadget1_calls
gadget1_chunk_length
}
)
}
fn
add_noise
<
R
:
Rng
>
(
&
self
dp_strategy
:
&
ZCdpDiscreteGaussian
agg_result
:
&
mut
[
Field128
]
rng
:
&
mut
R
)
-
>
Result
<
(
)
FlpError
>
{
let
sensitivity
=
BigUint
:
:
from
(
2u128
)
.
pow
(
self
.
bits_per_entry
as
u32
)
;
let
modulus
=
BigInt
:
:
from
(
Field128
:
:
modulus
(
)
)
;
let
sampler
=
dp_strategy
.
create_distribution
(
Ratio
:
:
from_integer
(
sensitivity
)
)
?
;
for
entry
in
agg_result
.
iter_mut
(
)
{
let
noise
:
BigInt
=
sampler
.
sample
(
rng
)
;
let
noise
:
BigInt
=
noise
.
mod_floor
(
&
modulus
)
;
let
noise
:
u128
=
noise
.
try_into
(
)
.
map_err
(
|
e
:
TryFromBigIntError
<
BigInt
>
|
{
FlpError
:
:
DifferentialPrivacy
(
DpError
:
:
BigIntConversion
(
e
)
)
}
)
?
;
let
f_noise
=
Field128
:
:
from
(
Field128
:
:
valid_integer_try_from
:
:
<
u128
>
(
noise
)
?
)
;
*
entry
+
=
f_noise
;
}
Ok
(
(
)
)
}
}
impl
<
T
SPoly
SMul
>
Type
for
FixedPointBoundedL2VecSum
<
T
SPoly
SMul
>
where
T
:
Fixed
+
CompatibleFloat
SPoly
:
ParallelSumGadget
<
Field128
PolyEval
<
Field128
>
>
+
Eq
+
Clone
+
'
static
SMul
:
ParallelSumGadget
<
Field128
Mul
<
Field128
>
>
+
Eq
+
Clone
+
'
static
{
type
Measurement
=
Vec
<
T
>
;
type
AggregateResult
=
Vec
<
f64
>
;
type
Field
=
Field128
;
fn
encode_measurement
(
&
self
fp_entries
:
&
Vec
<
T
>
)
-
>
Result
<
Vec
<
Field128
>
FlpError
>
{
if
fp_entries
.
len
(
)
!
=
self
.
entries
{
return
Err
(
FlpError
:
:
Encode
(
"
unexpected
input
length
"
.
into
(
)
)
)
;
}
let
integer_entries
=
fp_entries
.
iter
(
)
.
map
(
|
x
|
x
.
to_field_integer
(
)
)
;
let
mut
encoded
:
Vec
<
Field128
>
=
Vec
:
:
with_capacity
(
self
.
bits_per_entry
*
self
.
entries
+
self
.
bits_for_norm
)
;
for
entry
in
integer_entries
.
clone
(
)
{
encoded
.
extend
(
Field128
:
:
encode_as_bitvector
(
entry
self
.
bits_per_entry
)
?
)
;
}
let
field_entries
=
integer_entries
.
map
(
Field128
:
:
from
)
;
let
norm
=
compute_norm_of_entries
(
field_entries
self
.
bits_per_entry
)
?
;
let
norm_int
=
u128
:
:
from
(
norm
)
;
encoded
.
extend
(
Field128
:
:
encode_as_bitvector
(
norm_int
self
.
bits_for_norm
)
?
)
;
Ok
(
encoded
)
}
fn
decode_result
(
&
self
data
:
&
[
Field128
]
num_measurements
:
usize
)
-
>
Result
<
Vec
<
f64
>
FlpError
>
{
if
data
.
len
(
)
!
=
self
.
entries
{
return
Err
(
FlpError
:
:
Decode
(
"
unexpected
input
length
"
.
into
(
)
)
)
;
}
let
num_measurements
=
match
u128
:
:
try_from
(
num_measurements
)
{
Ok
(
m
)
=
>
m
Err
(
_
)
=
>
{
return
Err
(
FlpError
:
:
Decode
(
"
number
of
clients
is
too
large
to
fit
into
u128
"
.
into
(
)
)
)
}
}
;
let
mut
res
=
Vec
:
:
with_capacity
(
data
.
len
(
)
)
;
for
d
in
data
{
let
decoded
=
<
T
as
CompatibleFloat
>
:
:
to_float
(
*
d
num_measurements
)
;
res
.
push
(
decoded
)
;
}
Ok
(
res
)
}
fn
gadget
(
&
self
)
-
>
Vec
<
Box
<
dyn
Gadget
<
Field128
>
>
>
{
let
gadget0
=
SMul
:
:
new
(
Mul
:
:
new
(
self
.
gadget0_calls
)
self
.
gadget0_chunk_length
)
;
let
gadget1
=
SPoly
:
:
new
(
PolyEval
:
:
new
(
self
.
norm_summand_poly
.
clone
(
)
self
.
gadget1_calls
)
self
.
gadget1_chunk_length
)
;
vec
!
[
Box
:
:
new
(
gadget0
)
Box
:
:
new
(
gadget1
)
]
}
fn
valid
(
&
self
g
:
&
mut
Vec
<
Box
<
dyn
Gadget
<
Field128
>
>
>
input
:
&
[
Field128
]
joint_rand
:
&
[
Field128
]
num_shares
:
usize
)
-
>
Result
<
Field128
FlpError
>
{
self
.
valid_call_check
(
input
joint_rand
)
?
;
let
f_num_shares
=
Field128
:
:
from
(
Field128
:
:
valid_integer_try_from
:
:
<
usize
>
(
num_shares
)
?
)
;
let
num_shares_inverse
=
Field128
:
:
one
(
)
/
f_num_shares
;
let
range_check
=
parallel_sum_range_checks
(
&
mut
g
[
0
]
&
input
[
.
.
self
.
range_norm_end
]
joint_rand
[
0
]
self
.
gadget0_chunk_length
num_shares
)
?
;
let
decoded_entries
:
Result
<
Vec
<
_
>
_
>
=
input
[
0
.
.
self
.
entries
*
self
.
bits_per_entry
]
.
chunks
(
self
.
bits_per_entry
)
.
map
(
Field128
:
:
decode_bitvector
)
.
collect
(
)
;
let
computed_norm
=
{
let
mut
outp
=
Field128
:
:
zero
(
)
;
let
fi_one
=
<
Field128
as
FieldElementWithInteger
>
:
:
Integer
:
:
one
(
)
;
let
zero_enc
=
Field128
:
:
from
(
fi_one
<
<
(
self
.
bits_per_entry
-
1
)
)
;
let
zero_enc_share
=
zero_enc
*
num_shares_inverse
;
for
chunk
in
decoded_entries
?
.
chunks
(
self
.
gadget1_chunk_length
)
{
let
d
=
chunk
.
len
(
)
;
if
d
=
=
self
.
gadget1_chunk_length
{
outp
+
=
g
[
1
]
.
call
(
chunk
)
?
;
}
else
{
let
mut
padded_chunk
:
Vec
<
_
>
=
chunk
.
to_owned
(
)
;
padded_chunk
.
resize
(
self
.
gadget1_chunk_length
zero_enc_share
)
;
outp
+
=
g
[
1
]
.
call
(
&
padded_chunk
)
?
;
}
}
outp
}
;
let
submitted_norm_enc
=
&
input
[
self
.
range_norm_begin
.
.
self
.
range_norm_end
]
;
let
submitted_norm
=
Field128
:
:
decode_bitvector
(
submitted_norm_enc
)
?
;
let
norm_check
=
computed_norm
-
submitted_norm
;
let
out
=
joint_rand
[
1
]
*
range_check
+
(
joint_rand
[
1
]
*
joint_rand
[
1
]
)
*
norm_check
;
Ok
(
out
)
}
fn
truncate
(
&
self
input
:
Vec
<
Field128
>
)
-
>
Result
<
Vec
<
Self
:
:
Field
>
FlpError
>
{
self
.
truncate_call_check
(
&
input
)
?
;
let
mut
decoded_vector
=
vec
!
[
]
;
for
i_entry
in
0
.
.
self
.
entries
{
let
start
=
i_entry
*
self
.
bits_per_entry
;
let
end
=
(
i_entry
+
1
)
*
self
.
bits_per_entry
;
let
decoded
=
Field128
:
:
decode_bitvector
(
&
input
[
start
.
.
end
]
)
?
;
decoded_vector
.
push
(
decoded
)
;
}
Ok
(
decoded_vector
)
}
fn
input_len
(
&
self
)
-
>
usize
{
self
.
bits_per_entry
*
self
.
entries
+
self
.
bits_for_norm
}
fn
proof_len
(
&
self
)
-
>
usize
{
let
proof_gadget_0
=
(
self
.
gadget0_chunk_length
*
2
)
+
2
*
(
(
1
+
self
.
gadget0_calls
)
.
next_power_of_two
(
)
-
1
)
+
1
;
let
proof_gadget_1
=
(
self
.
gadget1_chunk_length
)
+
2
*
(
(
1
+
self
.
gadget1_calls
)
.
next_power_of_two
(
)
-
1
)
+
1
;
proof_gadget_0
+
proof_gadget_1
}
fn
verifier_len
(
&
self
)
-
>
usize
{
self
.
gadget0_chunk_length
*
2
+
self
.
gadget1_chunk_length
+
3
}
fn
output_len
(
&
self
)
-
>
usize
{
self
.
entries
}
fn
joint_rand_len
(
&
self
)
-
>
usize
{
2
}
fn
prove_rand_len
(
&
self
)
-
>
usize
{
self
.
gadget0_chunk_length
*
2
+
self
.
gadget1_chunk_length
}
fn
query_rand_len
(
&
self
)
-
>
usize
{
2
}
}
impl
<
T
SPoly
SMul
>
TypeWithNoise
<
ZCdpDiscreteGaussian
>
for
FixedPointBoundedL2VecSum
<
T
SPoly
SMul
>
where
T
:
Fixed
+
CompatibleFloat
SPoly
:
ParallelSumGadget
<
Field128
PolyEval
<
Field128
>
>
+
Eq
+
Clone
+
'
static
SMul
:
ParallelSumGadget
<
Field128
Mul
<
Field128
>
>
+
Eq
+
Clone
+
'
static
{
fn
add_noise_to_result
(
&
self
dp_strategy
:
&
ZCdpDiscreteGaussian
agg_result
:
&
mut
[
Self
:
:
Field
]
_num_measurements
:
usize
)
-
>
Result
<
(
)
FlpError
>
{
self
.
add_noise
(
dp_strategy
agg_result
&
mut
SeedStreamTurboShake128
:
:
from_entropy
(
)
)
}
}
fn
compute_norm_of_entries
<
Fs
>
(
entries
:
Fs
bits_per_entry
:
usize
)
-
>
Result
<
Field128
FlpError
>
where
Fs
:
IntoIterator
<
Item
=
Field128
>
{
let
fi_one
=
u128
:
:
from
(
Field128
:
:
one
(
)
)
;
let
mut
norm_accumulator
=
Field128
:
:
zero
(
)
;
let
linear_part
=
fi_one
<
<
bits_per_entry
;
let
constant_part
=
fi_one
<
<
(
bits_per_entry
+
bits_per_entry
-
2
)
;
for
entry
in
entries
.
into_iter
(
)
{
let
summand
=
entry
*
entry
+
Field128
:
:
from
(
constant_part
)
-
Field128
:
:
from
(
linear_part
)
*
(
entry
)
;
norm_accumulator
+
=
summand
;
}
Ok
(
norm_accumulator
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
dp
:
:
{
Rational
ZCdpBudget
}
;
use
crate
:
:
field
:
:
{
random_vector
Field128
FieldElement
}
;
use
crate
:
:
flp
:
:
gadgets
:
:
ParallelSum
;
use
crate
:
:
flp
:
:
test_utils
:
:
FlpTest
;
use
crate
:
:
vdaf
:
:
xof
:
:
SeedStreamTurboShake128
;
use
fixed
:
:
types
:
:
extra
:
:
{
U127
U14
U63
}
;
use
fixed
:
:
{
FixedI128
FixedI16
FixedI64
}
;
use
fixed_macro
:
:
fixed
;
use
rand
:
:
SeedableRng
;
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_fp16
(
)
{
let
fp16_4_inv
=
fixed
!
(
0
.
25
:
I1F15
)
;
let
fp16_8_inv
=
fixed
!
(
0
.
125
:
I1F15
)
;
let
fp16_16_inv
=
fixed
!
(
0
.
0625
:
I1F15
)
;
let
fp16_vec
=
vec
!
[
fp16_4_inv
fp16_8_inv
fp16_16_inv
]
;
test_fixed
(
fp16_vec
vec
!
[
40960
36864
34816
]
)
;
}
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_fp32
(
)
{
let
fp32_4_inv
=
fixed
!
(
0
.
25
:
I1F31
)
;
let
fp32_8_inv
=
fixed
!
(
0
.
125
:
I1F31
)
;
let
fp32_16_inv
=
fixed
!
(
0
.
0625
:
I1F31
)
;
let
fp32_vec
=
vec
!
[
fp32_4_inv
fp32_8_inv
fp32_16_inv
]
;
test_fixed
(
fp32_vec
vec
!
[
2684354560
2415919104
2281701376
]
)
;
}
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_fp64
(
)
{
let
fp64_4_inv
=
fixed
!
(
0
.
25
:
I1F63
)
;
let
fp64_8_inv
=
fixed
!
(
0
.
125
:
I1F63
)
;
let
fp64_16_inv
=
fixed
!
(
0
.
0625
:
I1F63
)
;
let
fp64_vec
=
vec
!
[
fp64_4_inv
fp64_8_inv
fp64_16_inv
]
;
test_fixed
(
fp64_vec
vec
!
[
11529215046068469760
10376293541461622784
9799832789158199296
]
)
;
}
fn
test_fixed
<
F
:
Fixed
>
(
fp_vec
:
Vec
<
F
>
enc_vec
:
Vec
<
u128
>
)
where
F
:
CompatibleFloat
{
let
n
:
usize
=
(
F
:
:
INT_NBITS
+
F
:
:
FRAC_NBITS
)
.
try_into
(
)
.
unwrap
(
)
;
type
Ps
=
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
;
type
Psm
=
ParallelSum
<
Field128
Mul
<
Field128
>
>
;
let
vsum
:
FixedPointBoundedL2VecSum
<
F
Ps
Psm
>
=
FixedPointBoundedL2VecSum
:
:
new
(
3
)
.
unwrap
(
)
;
let
one
=
Field128
:
:
one
(
)
;
assert_eq
!
(
vsum
.
decode_result
(
&
vsum
.
truncate
(
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
)
.
unwrap
(
)
1
)
.
unwrap
(
)
vec
!
(
0
.
25
0
.
125
0
.
0625
)
)
;
let
mut
v
=
vsum
.
truncate
(
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
)
.
unwrap
(
)
;
let
strategy
=
ZCdpDiscreteGaussian
:
:
from_budget
(
ZCdpBudget
:
:
new
(
Rational
:
:
from_unsigned
(
100u8
3u8
)
.
unwrap
(
)
)
)
;
vsum
.
add_noise
(
&
strategy
&
mut
v
&
mut
SeedStreamTurboShake128
:
:
from_seed
(
[
0u8
;
16
]
)
)
.
unwrap
(
)
;
assert_eq
!
(
vsum
.
decode_result
(
&
v
1
)
.
unwrap
(
)
match
n
{
/
/
sensitivity
depends
on
encoding
so
the
noise
differs
16
=
>
vec
!
[
0
.
288970947265625
0
.
168853759765625
0
.
085662841796875
]
32
=
>
vec
!
[
0
.
257810294162482
0
.
10634658299386501
0
.
10149003705009818
]
64
=
>
vec
!
[
0
.
37697368351762867
-
0
.
02388947667663828
0
.
19813152630930916
]
_
=
>
panic
!
(
"
unsupported
bitsize
"
)
}
)
;
let
mut
input
:
Vec
<
Field128
>
=
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
;
assert_eq
!
(
input
[
0
]
Field128
:
:
zero
(
)
)
;
input
[
0
]
=
one
;
FlpTest
{
name
:
None
flp
:
&
vsum
input
:
&
input
expected_output
:
Some
(
&
[
Field128
:
:
from
(
enc_vec
[
0
]
+
1
)
Field128
:
:
from
(
enc_vec
[
1
]
)
Field128
:
:
from
(
enc_vec
[
2
]
)
]
)
expect_valid
:
false
}
.
run
:
:
<
3
>
(
)
;
let
mut
input2
:
Vec
<
Field128
>
=
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
;
input2
[
0
]
=
one
+
one
;
FlpTest
{
name
:
None
flp
:
&
vsum
input
:
&
input2
expected_output
:
Some
(
&
[
Field128
:
:
from
(
enc_vec
[
0
]
+
2
)
Field128
:
:
from
(
enc_vec
[
1
]
)
Field128
:
:
from
(
enc_vec
[
2
]
)
]
)
expect_valid
:
false
}
.
run
:
:
<
3
>
(
)
;
let
one_enc
=
Field128
:
:
from
(
(
(
2_u128
)
<
<
(
n
-
1
)
)
-
1
)
;
FlpTest
{
name
:
None
flp
:
&
vsum
input
:
&
vec
!
[
one
;
3
*
n
+
2
*
n
-
2
]
expected_output
:
Some
(
&
[
one_enc
;
3
]
)
expect_valid
:
false
}
.
run
:
:
<
3
>
(
)
;
let
joint_rand
=
random_vector
(
vsum
.
joint_rand_len
(
)
)
.
unwrap
(
)
;
vsum
.
valid
(
&
mut
vsum
.
gadget
(
)
&
vec
!
[
one
;
3
*
n
+
2
*
n
-
1
]
&
joint_rand
1
)
.
unwrap_err
(
)
;
let
zero_enc
=
Field128
:
:
from
(
(
2_u128
)
<
<
(
n
-
2
)
)
;
{
let
entries
=
vec
!
[
zero_enc
;
3
]
;
let
norm
=
compute_norm_of_entries
(
entries
vsum
.
bits_per_entry
)
.
unwrap
(
)
;
let
expected_norm
=
Field128
:
:
from
(
0
)
;
assert_eq
!
(
norm
expected_norm
)
;
}
{
let
entries
=
vec
!
[
one_enc
;
3
]
;
let
norm
=
compute_norm_of_entries
(
entries
vsum
.
bits_per_entry
)
.
unwrap
(
)
;
let
expected_norm
=
Field128
:
:
from
(
3
*
(
1
+
(
1
<
<
(
2
*
n
-
2
)
)
-
(
1
<
<
n
)
)
)
;
assert_eq
!
(
norm
expected_norm
)
;
let
entries
=
vec
!
[
Field128
:
:
from
(
0
)
Field128
:
:
from
(
0
)
Field128
:
:
from
(
0
)
]
;
let
norm
=
compute_norm_of_entries
(
entries
vsum
.
bits_per_entry
)
.
unwrap
(
)
;
let
expected_norm
=
Field128
:
:
from
(
3
*
(
1
<
<
(
2
*
n
-
2
)
)
)
;
assert_eq
!
(
norm
expected_norm
)
;
}
}
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_invalid_args
(
)
{
<
FixedPointBoundedL2VecSum
<
FixedI128
<
U127
>
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
ParallelSum
<
Field128
Mul
<
Field128
>
>
>
>
:
:
new
(
3
)
.
unwrap_err
(
)
;
<
FixedPointBoundedL2VecSum
<
FixedI64
<
U63
>
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
ParallelSum
<
Field128
Mul
<
Field128
>
>
>
>
:
:
new
(
3000000000
)
.
unwrap_err
(
)
;
<
FixedPointBoundedL2VecSum
<
FixedI16
<
U14
>
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
ParallelSum
<
Field128
Mul
<
Field128
>
>
>
>
:
:
new
(
3
)
.
unwrap_err
(
)
;
}
}
