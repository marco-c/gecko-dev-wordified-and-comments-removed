pub
mod
compatible_float
;
use
crate
:
:
field
:
:
{
FftFriendlyFieldElement
FieldElementExt
FieldElementWithInteger
}
;
use
crate
:
:
flp
:
:
gadgets
:
:
{
BlindPolyEval
ParallelSumGadget
PolyEval
}
;
use
crate
:
:
flp
:
:
types
:
:
fixedpoint_l2
:
:
compatible_float
:
:
CompatibleFloat
;
use
crate
:
:
flp
:
:
{
FlpError
Gadget
Type
}
;
use
crate
:
:
polynomial
:
:
poly_range_check
;
use
fixed
:
:
traits
:
:
Fixed
;
use
std
:
:
{
convert
:
:
TryFrom
convert
:
:
TryInto
fmt
:
:
Debug
marker
:
:
PhantomData
}
;
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
FixedPointBoundedL2VecSum
<
T
:
Fixed
F
:
FftFriendlyFieldElement
SPoly
:
ParallelSumGadget
<
F
PolyEval
<
F
>
>
+
Clone
SBlindPoly
:
ParallelSumGadget
<
F
BlindPolyEval
<
F
>
>
+
Clone
>
{
bits_per_entry
:
usize
entries
:
usize
bits_for_norm
:
usize
range_01_checker
:
Vec
<
F
>
norm_summand_poly
:
Vec
<
F
>
phantom
:
PhantomData
<
(
T
SPoly
SBlindPoly
)
>
range_norm_begin
:
usize
range_norm_end
:
usize
gadget0_calls
:
usize
gadget0_chunk_len
:
usize
gadget1_calls
:
usize
gadget1_chunk_len
:
usize
}
impl
<
T
F
SPoly
SBlindPoly
>
FixedPointBoundedL2VecSum
<
T
F
SPoly
SBlindPoly
>
where
T
:
Fixed
F
:
FftFriendlyFieldElement
SPoly
:
ParallelSumGadget
<
F
PolyEval
<
F
>
>
+
Clone
SBlindPoly
:
ParallelSumGadget
<
F
BlindPolyEval
<
F
>
>
+
Clone
u128
:
TryFrom
<
F
:
:
Integer
>
{
pub
fn
new
(
entries
:
usize
)
-
>
Result
<
Self
FlpError
>
{
let
fi_one
=
F
:
:
Integer
:
:
from
(
F
:
:
one
(
)
)
;
if
<
T
as
Fixed
>
:
:
INT_NBITS
!
=
1
{
return
Err
(
FlpError
:
:
Encode
(
format
!
(
"
Expected
fixed
point
type
with
one
integer
bit
but
got
{
}
.
"
<
T
as
Fixed
>
:
:
INT_NBITS
)
)
)
;
}
let
bits_per_entry
:
usize
=
(
<
T
as
Fixed
>
:
:
INT_NBITS
+
<
T
as
Fixed
>
:
:
FRAC_NBITS
)
.
try_into
(
)
.
map_err
(
|
_
|
FlpError
:
:
Encode
(
"
Could
not
convert
u32
into
usize
.
"
.
to_string
(
)
)
)
?
;
if
!
F
:
:
valid_integer_bitlength
(
bits_per_entry
)
{
return
Err
(
FlpError
:
:
Encode
(
format
!
(
"
fixed
point
type
bit
length
(
{
bits_per_entry
}
)
too
large
for
field
modulus
"
)
)
)
;
}
let
bits_for_norm
=
2
*
bits_per_entry
-
2
;
if
!
F
:
:
valid_integer_bitlength
(
bits_for_norm
)
{
return
Err
(
FlpError
:
:
Encode
(
format
!
(
"
maximal
norm
bit
length
(
{
bits_for_norm
}
)
too
large
for
field
modulus
"
)
)
)
;
}
let
err
=
Err
(
FlpError
:
:
Encode
(
format
!
(
"
number
of
entries
(
{
entries
}
)
not
compatible
with
field
size
"
)
)
)
;
if
let
Some
(
val
)
=
(
entries
as
u128
)
.
checked_mul
(
1
<
<
bits_for_norm
)
{
if
let
Ok
(
modulus
)
=
u128
:
:
try_from
(
F
:
:
modulus
(
)
)
{
if
val
>
=
modulus
{
return
err
;
}
}
else
{
return
err
;
}
}
else
{
return
err
;
}
let
linear_part
=
fi_one
<
<
bits_per_entry
;
let
constant_part
=
fi_one
<
<
(
bits_per_entry
+
bits_per_entry
-
2
)
;
let
norm_summand_poly
=
vec
!
[
F
:
:
from
(
constant_part
)
-
F
:
:
from
(
linear_part
)
F
:
:
one
(
)
]
;
let
len0
=
bits_per_entry
*
entries
+
bits_for_norm
;
let
gadget0_chunk_len
=
std
:
:
cmp
:
:
max
(
1
(
len0
as
f64
)
.
sqrt
(
)
as
usize
)
;
let
gadget0_calls
=
(
len0
+
gadget0_chunk_len
-
1
)
/
gadget0_chunk_len
;
let
len1
=
entries
;
let
gadget1_chunk_len
=
std
:
:
cmp
:
:
max
(
1
(
len1
as
f64
)
.
sqrt
(
)
as
usize
)
;
let
gadget1_calls
=
(
len1
+
gadget1_chunk_len
-
1
)
/
gadget1_chunk_len
;
Ok
(
Self
{
bits_per_entry
entries
bits_for_norm
range_01_checker
:
poly_range_check
(
0
2
)
norm_summand_poly
phantom
:
PhantomData
range_norm_begin
:
entries
*
bits_per_entry
range_norm_end
:
entries
*
bits_per_entry
+
bits_for_norm
gadget0_calls
gadget0_chunk_len
gadget1_calls
gadget1_chunk_len
}
)
}
}
impl
<
T
F
SPoly
SBlindPoly
>
Type
for
FixedPointBoundedL2VecSum
<
T
F
SPoly
SBlindPoly
>
where
T
:
Fixed
+
CompatibleFloat
<
F
>
F
:
FftFriendlyFieldElement
SPoly
:
ParallelSumGadget
<
F
PolyEval
<
F
>
>
+
Eq
+
Clone
+
'
static
SBlindPoly
:
ParallelSumGadget
<
F
BlindPolyEval
<
F
>
>
+
Eq
+
Clone
+
'
static
{
const
ID
:
u32
=
0xFFFF0000
;
type
Measurement
=
Vec
<
T
>
;
type
AggregateResult
=
Vec
<
f64
>
;
type
Field
=
F
;
fn
encode_measurement
(
&
self
fp_entries
:
&
Vec
<
T
>
)
-
>
Result
<
Vec
<
F
>
FlpError
>
{
let
integer_entries
=
fp_entries
.
iter
(
)
.
map
(
|
x
|
x
.
to_field_integer
(
)
)
;
let
mut
encoded
:
Vec
<
F
>
=
vec
!
[
F
:
:
zero
(
)
;
self
.
bits_per_entry
*
self
.
entries
+
self
.
bits_for_norm
]
;
for
(
l
entry
)
in
integer_entries
.
clone
(
)
.
enumerate
(
)
{
F
:
:
fill_with_bitvector_representation
(
&
entry
&
mut
encoded
[
l
*
self
.
bits_per_entry
.
.
(
l
+
1
)
*
self
.
bits_per_entry
]
)
?
;
}
let
field_entries
=
integer_entries
.
map
(
|
x
|
F
:
:
from
(
x
)
)
;
let
norm
=
compute_norm_of_entries
(
field_entries
self
.
bits_per_entry
)
?
;
let
norm_int
=
F
:
:
Integer
:
:
from
(
norm
)
;
F
:
:
fill_with_bitvector_representation
(
&
norm_int
&
mut
encoded
[
self
.
range_norm_begin
.
.
self
.
range_norm_end
]
)
?
;
Ok
(
encoded
)
}
fn
decode_result
(
&
self
data
:
&
[
F
]
num_measurements
:
usize
)
-
>
Result
<
Vec
<
f64
>
FlpError
>
{
if
data
.
len
(
)
!
=
self
.
entries
{
return
Err
(
FlpError
:
:
Decode
(
"
unexpected
input
length
"
.
into
(
)
)
)
;
}
let
num_measurements
=
match
u128
:
:
try_from
(
num_measurements
)
{
Ok
(
m
)
=
>
m
Err
(
_
)
=
>
{
return
Err
(
FlpError
:
:
Decode
(
"
number
of
clients
is
too
large
to
fit
into
u128
"
.
into
(
)
)
)
}
}
;
let
mut
res
=
Vec
:
:
with_capacity
(
data
.
len
(
)
)
;
for
d
in
data
{
let
decoded
=
<
T
as
CompatibleFloat
<
F
>
>
:
:
to_float
(
*
d
num_measurements
)
;
res
.
push
(
decoded
)
;
}
Ok
(
res
)
}
fn
gadget
(
&
self
)
-
>
Vec
<
Box
<
dyn
Gadget
<
F
>
>
>
{
let
gadget0
=
SBlindPoly
:
:
new
(
BlindPolyEval
:
:
new
(
self
.
range_01_checker
.
clone
(
)
self
.
gadget0_calls
)
self
.
gadget0_chunk_len
)
;
let
gadget1
=
SPoly
:
:
new
(
PolyEval
:
:
new
(
self
.
norm_summand_poly
.
clone
(
)
self
.
gadget1_calls
)
self
.
gadget1_chunk_len
)
;
vec
!
[
Box
:
:
new
(
gadget0
)
Box
:
:
new
(
gadget1
)
]
}
fn
valid
(
&
self
g
:
&
mut
Vec
<
Box
<
dyn
Gadget
<
F
>
>
>
input
:
&
[
F
]
joint_rand
:
&
[
F
]
num_shares
:
usize
)
-
>
Result
<
F
FlpError
>
{
self
.
valid_call_check
(
input
joint_rand
)
?
;
let
f_num_shares
=
F
:
:
from
(
F
:
:
valid_integer_try_from
(
num_shares
)
?
)
;
let
constant_part_multiplier
=
F
:
:
one
(
)
/
f_num_shares
;
let
range_check
=
{
let
mut
outp
=
F
:
:
zero
(
)
;
let
mut
r
=
joint_rand
[
0
]
;
let
mut
padded_chunk
=
vec
!
[
F
:
:
zero
(
)
;
2
*
self
.
gadget0_chunk_len
]
;
for
chunk
in
input
[
.
.
self
.
range_norm_end
]
.
chunks
(
self
.
gadget0_chunk_len
)
{
let
d
=
chunk
.
len
(
)
;
for
i
in
0
.
.
self
.
gadget0_chunk_len
{
if
i
<
d
{
padded_chunk
[
2
*
i
]
=
chunk
[
i
]
;
}
else
{
padded_chunk
[
2
*
i
]
=
chunk
[
d
-
1
]
;
}
padded_chunk
[
2
*
i
+
1
]
=
r
*
constant_part_multiplier
;
r
*
=
joint_rand
[
0
]
;
}
outp
+
=
g
[
0
]
.
call
(
&
padded_chunk
)
?
;
}
outp
}
;
let
decoded_entries
:
Result
<
Vec
<
_
>
_
>
=
input
[
0
.
.
self
.
entries
*
self
.
bits_per_entry
]
.
chunks
(
self
.
bits_per_entry
)
.
map
(
F
:
:
decode_from_bitvector_representation
)
.
collect
(
)
;
let
computed_norm
=
{
let
mut
outp
=
F
:
:
zero
(
)
;
let
fi_one
=
F
:
:
Integer
:
:
from
(
F
:
:
one
(
)
)
;
let
zero_enc
=
F
:
:
from
(
fi_one
<
<
(
self
.
bits_per_entry
-
1
)
)
;
let
zero_enc_share
=
zero_enc
*
constant_part_multiplier
;
for
chunk
in
decoded_entries
?
.
chunks
(
self
.
gadget1_chunk_len
)
{
let
d
=
chunk
.
len
(
)
;
if
d
=
=
self
.
gadget1_chunk_len
{
outp
+
=
g
[
1
]
.
call
(
chunk
)
?
;
}
else
{
let
mut
padded_chunk
:
Vec
<
_
>
=
chunk
.
to_owned
(
)
;
padded_chunk
.
resize
(
self
.
gadget1_chunk_len
zero_enc_share
)
;
outp
+
=
g
[
1
]
.
call
(
&
padded_chunk
)
?
;
}
}
outp
}
;
let
submitted_norm_enc
=
&
input
[
self
.
range_norm_begin
.
.
self
.
range_norm_end
]
;
let
submitted_norm
=
F
:
:
decode_from_bitvector_representation
(
submitted_norm_enc
)
?
;
let
norm_check
=
computed_norm
-
submitted_norm
;
let
out
=
joint_rand
[
1
]
*
range_check
+
(
joint_rand
[
1
]
*
joint_rand
[
1
]
)
*
norm_check
;
Ok
(
out
)
}
fn
truncate
(
&
self
input
:
Vec
<
F
>
)
-
>
Result
<
Vec
<
Self
:
:
Field
>
FlpError
>
{
self
.
truncate_call_check
(
&
input
)
?
;
let
mut
decoded_vector
=
vec
!
[
]
;
for
i_entry
in
0
.
.
self
.
entries
{
let
start
=
i_entry
*
self
.
bits_per_entry
;
let
end
=
(
i_entry
+
1
)
*
self
.
bits_per_entry
;
let
decoded
=
F
:
:
decode_from_bitvector_representation
(
&
input
[
start
.
.
end
]
)
?
;
decoded_vector
.
push
(
decoded
)
;
}
Ok
(
decoded_vector
)
}
fn
input_len
(
&
self
)
-
>
usize
{
self
.
bits_per_entry
*
self
.
entries
+
self
.
bits_for_norm
}
fn
proof_len
(
&
self
)
-
>
usize
{
let
proof_gadget_0
=
(
self
.
gadget0_chunk_len
*
2
)
+
3
*
(
(
1
+
self
.
gadget0_calls
)
.
next_power_of_two
(
)
-
1
)
+
1
;
let
proof_gadget_1
=
(
self
.
gadget1_chunk_len
)
+
2
*
(
(
1
+
self
.
gadget1_calls
)
.
next_power_of_two
(
)
-
1
)
+
1
;
proof_gadget_0
+
proof_gadget_1
}
fn
verifier_len
(
&
self
)
-
>
usize
{
self
.
gadget0_chunk_len
*
2
+
self
.
gadget1_chunk_len
+
3
}
fn
output_len
(
&
self
)
-
>
usize
{
self
.
entries
}
fn
joint_rand_len
(
&
self
)
-
>
usize
{
2
}
fn
prove_rand_len
(
&
self
)
-
>
usize
{
self
.
gadget0_chunk_len
*
2
+
self
.
gadget1_chunk_len
}
fn
query_rand_len
(
&
self
)
-
>
usize
{
2
}
}
fn
compute_norm_of_entries
<
F
Fs
>
(
entries
:
Fs
bits_per_entry
:
usize
)
-
>
Result
<
F
FlpError
>
where
F
:
FieldElementWithInteger
Fs
:
IntoIterator
<
Item
=
F
>
{
let
fi_one
=
F
:
:
Integer
:
:
from
(
F
:
:
one
(
)
)
;
let
mut
norm_accumulator
=
F
:
:
zero
(
)
;
let
linear_part
=
fi_one
<
<
bits_per_entry
;
let
constant_part
=
fi_one
<
<
(
bits_per_entry
+
bits_per_entry
-
2
)
;
for
entry
in
entries
.
into_iter
(
)
{
let
summand
=
entry
*
entry
+
F
:
:
from
(
constant_part
)
-
F
:
:
from
(
linear_part
)
*
(
entry
)
;
norm_accumulator
+
=
summand
;
}
Ok
(
norm_accumulator
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
field
:
:
{
random_vector
Field128
FieldElement
}
;
use
crate
:
:
flp
:
:
gadgets
:
:
ParallelSum
;
use
crate
:
:
flp
:
:
types
:
:
test_utils
:
:
{
flp_validity_test
ValidityTestCase
}
;
use
fixed
:
:
types
:
:
extra
:
:
{
U127
U14
U63
}
;
use
fixed
:
:
{
FixedI128
FixedI16
FixedI64
}
;
use
fixed_macro
:
:
fixed
;
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_fp16
(
)
{
let
fp16_4_inv
=
fixed
!
(
0
.
25
:
I1F15
)
;
let
fp16_8_inv
=
fixed
!
(
0
.
125
:
I1F15
)
;
let
fp16_16_inv
=
fixed
!
(
0
.
0625
:
I1F15
)
;
let
fp16_vec
=
vec
!
[
fp16_4_inv
fp16_8_inv
fp16_16_inv
]
;
test_fixed
(
fp16_vec
vec
!
[
40960
36864
34816
]
)
;
}
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_fp32
(
)
{
let
fp32_4_inv
=
fixed
!
(
0
.
25
:
I1F31
)
;
let
fp32_8_inv
=
fixed
!
(
0
.
125
:
I1F31
)
;
let
fp32_16_inv
=
fixed
!
(
0
.
0625
:
I1F31
)
;
let
fp32_vec
=
vec
!
[
fp32_4_inv
fp32_8_inv
fp32_16_inv
]
;
test_fixed
(
fp32_vec
vec
!
[
2684354560
2415919104
2281701376
]
)
;
}
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_fp64
(
)
{
let
fp64_4_inv
=
fixed
!
(
0
.
25
:
I1F63
)
;
let
fp64_8_inv
=
fixed
!
(
0
.
125
:
I1F63
)
;
let
fp64_16_inv
=
fixed
!
(
0
.
0625
:
I1F63
)
;
let
fp64_vec
=
vec
!
[
fp64_4_inv
fp64_8_inv
fp64_16_inv
]
;
test_fixed
(
fp64_vec
vec
!
[
11529215046068469760
10376293541461622784
9799832789158199296
]
)
;
}
fn
test_fixed
<
F
:
Fixed
>
(
fp_vec
:
Vec
<
F
>
enc_vec
:
Vec
<
u128
>
)
where
F
:
CompatibleFloat
<
Field128
>
{
let
n
:
usize
=
(
F
:
:
INT_NBITS
+
F
:
:
FRAC_NBITS
)
.
try_into
(
)
.
unwrap
(
)
;
type
Ps
=
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
;
type
Psb
=
ParallelSum
<
Field128
BlindPolyEval
<
Field128
>
>
;
let
vsum
:
FixedPointBoundedL2VecSum
<
F
Field128
Ps
Psb
>
=
FixedPointBoundedL2VecSum
:
:
new
(
3
)
.
unwrap
(
)
;
let
one
=
Field128
:
:
one
(
)
;
assert_eq
!
(
vsum
.
decode_result
(
&
vsum
.
truncate
(
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
)
.
unwrap
(
)
1
)
.
unwrap
(
)
vec
!
(
0
.
25
0
.
125
0
.
0625
)
)
;
let
mut
input
:
Vec
<
Field128
>
=
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
;
assert_eq
!
(
input
[
0
]
Field128
:
:
zero
(
)
)
;
input
[
0
]
=
one
;
flp_validity_test
(
&
vsum
&
input
&
ValidityTestCase
:
:
<
Field128
>
{
expect_valid
:
false
expected_output
:
Some
(
vec
!
[
Field128
:
:
from
(
enc_vec
[
0
]
+
1
)
/
/
=
enc
(
0
.
25
)
+
2
^
0
Field128
:
:
from
(
enc_vec
[
1
]
)
Field128
:
:
from
(
enc_vec
[
2
]
)
]
)
num_shares
:
3
}
)
.
unwrap
(
)
;
let
mut
input2
:
Vec
<
Field128
>
=
vsum
.
encode_measurement
(
&
fp_vec
)
.
unwrap
(
)
;
input2
[
0
]
=
one
+
one
;
flp_validity_test
(
&
vsum
&
input2
&
ValidityTestCase
:
:
<
Field128
>
{
expect_valid
:
false
expected_output
:
Some
(
vec
!
[
Field128
:
:
from
(
enc_vec
[
0
]
+
2
)
/
/
=
enc
(
0
.
25
)
+
2
*
2
^
0
Field128
:
:
from
(
enc_vec
[
1
]
)
Field128
:
:
from
(
enc_vec
[
2
]
)
]
)
num_shares
:
3
}
)
.
unwrap
(
)
;
let
one_enc
=
Field128
:
:
from
(
(
(
2_u128
)
<
<
(
n
-
1
)
)
-
1
)
;
flp_validity_test
(
&
vsum
&
vec
!
[
one
;
3
*
n
+
2
*
n
-
2
]
&
ValidityTestCase
:
:
<
Field128
>
{
expect_valid
:
false
expected_output
:
Some
(
vec
!
[
one_enc
;
3
]
)
num_shares
:
3
}
)
.
unwrap
(
)
;
let
joint_rand
=
random_vector
(
vsum
.
joint_rand_len
(
)
)
.
unwrap
(
)
;
vsum
.
valid
(
&
mut
vsum
.
gadget
(
)
&
vec
!
[
one
;
3
*
n
+
2
*
n
-
1
]
&
joint_rand
1
)
.
unwrap_err
(
)
;
let
zero_enc
=
Field128
:
:
from
(
(
2_u128
)
<
<
(
n
-
2
)
)
;
{
let
entries
=
vec
!
[
zero_enc
;
3
]
;
let
norm
=
compute_norm_of_entries
(
entries
vsum
.
bits_per_entry
)
.
unwrap
(
)
;
let
expected_norm
=
Field128
:
:
from
(
0
)
;
assert_eq
!
(
norm
expected_norm
)
;
}
{
let
entries
=
vec
!
[
one_enc
;
3
]
;
let
norm
=
compute_norm_of_entries
(
entries
vsum
.
bits_per_entry
)
.
unwrap
(
)
;
let
expected_norm
=
Field128
:
:
from
(
3
*
(
1
+
(
1
<
<
(
2
*
n
-
2
)
)
-
(
1
<
<
n
)
)
)
;
assert_eq
!
(
norm
expected_norm
)
;
let
entries
=
vec
!
[
Field128
:
:
from
(
0
)
Field128
:
:
from
(
0
)
Field128
:
:
from
(
0
)
]
;
let
norm
=
compute_norm_of_entries
(
entries
vsum
.
bits_per_entry
)
.
unwrap
(
)
;
let
expected_norm
=
Field128
:
:
from
(
3
*
(
1
<
<
(
2
*
n
-
2
)
)
)
;
assert_eq
!
(
norm
expected_norm
)
;
}
}
#
[
test
]
fn
test_bounded_fpvec_sum_parallel_invalid_args
(
)
{
<
FixedPointBoundedL2VecSum
<
FixedI128
<
U127
>
Field128
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
ParallelSum
<
Field128
BlindPolyEval
<
Field128
>
>
>
>
:
:
new
(
3
)
.
unwrap_err
(
)
;
<
FixedPointBoundedL2VecSum
<
FixedI64
<
U63
>
Field128
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
ParallelSum
<
Field128
BlindPolyEval
<
Field128
>
>
>
>
:
:
new
(
3000000000
)
.
unwrap_err
(
)
;
<
FixedPointBoundedL2VecSum
<
FixedI16
<
U14
>
Field128
ParallelSum
<
Field128
PolyEval
<
Field128
>
>
ParallelSum
<
Field128
BlindPolyEval
<
Field128
>
>
>
>
:
:
new
(
3
)
.
unwrap_err
(
)
;
}
}
