#
[
cfg
(
all
(
feature
=
"
crypto
-
dependencies
"
feature
=
"
experimental
"
)
)
]
use
crate
:
:
idpf
:
:
IdpfError
;
use
crate
:
:
{
codec
:
:
{
CodecError
Decode
Encode
ParameterizedDecode
}
field
:
:
{
encode_fieldvec
merge_vector
FieldElement
FieldError
}
flp
:
:
FlpError
prng
:
:
PrngError
vdaf
:
:
prg
:
:
Seed
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
{
fmt
:
:
Debug
io
:
:
Cursor
}
;
pub
(
crate
)
const
VERSION
:
u8
=
5
;
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
pub
enum
VdafError
{
#
[
error
(
"
vdaf
error
:
{
0
}
"
)
]
Uncategorized
(
String
)
#
[
error
(
"
field
error
:
{
0
}
"
)
]
Field
(
#
[
from
]
FieldError
)
#
[
error
(
"
io
error
:
{
0
}
"
)
]
IoError
(
#
[
from
]
std
:
:
io
:
:
Error
)
#
[
error
(
"
flp
error
:
{
0
}
"
)
]
Flp
(
#
[
from
]
FlpError
)
#
[
error
(
"
prng
error
:
{
0
}
"
)
]
Prng
(
#
[
from
]
PrngError
)
#
[
error
(
"
getrandom
:
{
0
}
"
)
]
GetRandom
(
#
[
from
]
getrandom
:
:
Error
)
#
[
cfg
(
all
(
feature
=
"
crypto
-
dependencies
"
feature
=
"
experimental
"
)
)
]
#
[
error
(
"
idpf
error
:
{
0
}
"
)
]
Idpf
(
#
[
from
]
IdpfError
)
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
enum
Share
<
F
const
SEED_SIZE
:
usize
>
{
Leader
(
Vec
<
F
>
)
Helper
(
Seed
<
SEED_SIZE
>
)
}
impl
<
F
:
Clone
const
SEED_SIZE
:
usize
>
Share
<
F
SEED_SIZE
>
{
#
[
cfg
(
feature
=
"
prio2
"
)
]
pub
(
crate
)
fn
truncated
(
&
self
len
:
usize
)
-
>
Self
{
match
self
{
Self
:
:
Leader
(
ref
data
)
=
>
Self
:
:
Leader
(
data
[
.
.
len
]
.
to_vec
(
)
)
Self
:
:
Helper
(
ref
seed
)
=
>
Self
:
:
Helper
(
seed
.
clone
(
)
)
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
(
crate
)
enum
ShareDecodingParameter
<
const
SEED_SIZE
:
usize
>
{
Leader
(
usize
)
Helper
}
impl
<
F
:
FieldElement
const
SEED_SIZE
:
usize
>
ParameterizedDecode
<
ShareDecodingParameter
<
SEED_SIZE
>
>
for
Share
<
F
SEED_SIZE
>
{
fn
decode_with_param
(
decoding_parameter
:
&
ShareDecodingParameter
<
SEED_SIZE
>
bytes
:
&
mut
Cursor
<
&
[
u8
]
>
)
-
>
Result
<
Self
CodecError
>
{
match
decoding_parameter
{
ShareDecodingParameter
:
:
Leader
(
share_length
)
=
>
{
let
mut
data
=
Vec
:
:
with_capacity
(
*
share_length
)
;
for
_
in
0
.
.
*
share_length
{
data
.
push
(
F
:
:
decode
(
bytes
)
?
)
}
Ok
(
Self
:
:
Leader
(
data
)
)
}
ShareDecodingParameter
:
:
Helper
=
>
{
let
seed
=
Seed
:
:
decode
(
bytes
)
?
;
Ok
(
Self
:
:
Helper
(
seed
)
)
}
}
}
}
impl
<
F
:
FieldElement
const
SEED_SIZE
:
usize
>
Encode
for
Share
<
F
SEED_SIZE
>
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
match
self
{
Share
:
:
Leader
(
share_data
)
=
>
{
for
x
in
share_data
{
x
.
encode
(
bytes
)
;
}
}
Share
:
:
Helper
(
share_seed
)
=
>
{
share_seed
.
encode
(
bytes
)
;
}
}
}
fn
encoded_len
(
&
self
)
-
>
Option
<
usize
>
{
match
self
{
Share
:
:
Leader
(
share_data
)
=
>
{
Some
(
share_data
.
len
(
)
*
F
:
:
ENCODED_SIZE
)
}
Share
:
:
Helper
(
share_seed
)
=
>
share_seed
.
encoded_len
(
)
}
}
}
pub
trait
Vdaf
:
Clone
+
Debug
{
const
ID
:
u32
;
type
Measurement
:
Clone
+
Debug
;
type
AggregateResult
:
Clone
+
Debug
;
type
AggregationParam
:
Clone
+
Debug
+
Decode
+
Encode
;
type
PublicShare
:
Clone
+
Debug
+
ParameterizedDecode
<
Self
>
+
Encode
;
type
InputShare
:
Clone
+
Debug
+
for
<
'
a
>
ParameterizedDecode
<
(
&
'
a
Self
usize
)
>
+
Encode
;
type
OutputShare
:
Clone
+
Debug
+
for
<
'
a
>
ParameterizedDecode
<
(
&
'
a
Self
&
'
a
Self
:
:
AggregationParam
)
>
+
Encode
;
type
AggregateShare
:
Aggregatable
<
OutputShare
=
Self
:
:
OutputShare
>
+
for
<
'
a
>
ParameterizedDecode
<
(
&
'
a
Self
&
'
a
Self
:
:
AggregationParam
)
>
+
Encode
;
fn
num_aggregators
(
&
self
)
-
>
usize
;
fn
custom
(
usage
:
u16
)
-
>
[
u8
;
8
]
{
let
mut
custom
=
[
0_u8
;
8
]
;
custom
[
0
]
=
VERSION
;
custom
[
1
]
=
0
;
custom
[
2
.
.
6
]
.
copy_from_slice
(
&
(
Self
:
:
ID
)
.
to_be_bytes
(
)
)
;
custom
[
6
.
.
8
]
.
copy_from_slice
(
&
usage
.
to_be_bytes
(
)
)
;
custom
}
}
pub
trait
Client
<
const
NONCE_SIZE
:
usize
>
:
Vdaf
{
fn
shard
(
&
self
measurement
:
&
Self
:
:
Measurement
nonce
:
&
[
u8
;
NONCE_SIZE
]
)
-
>
Result
<
(
Self
:
:
PublicShare
Vec
<
Self
:
:
InputShare
>
)
VdafError
>
;
}
pub
trait
Aggregator
<
const
VERIFY_KEY_SIZE
:
usize
const
NONCE_SIZE
:
usize
>
:
Vdaf
{
type
PrepareState
:
Clone
+
Debug
;
type
PrepareShare
:
Clone
+
Debug
+
ParameterizedDecode
<
Self
:
:
PrepareState
>
+
Encode
;
type
PrepareMessage
:
Clone
+
Debug
+
ParameterizedDecode
<
Self
:
:
PrepareState
>
+
Encode
;
fn
prepare_init
(
&
self
verify_key
:
&
[
u8
;
VERIFY_KEY_SIZE
]
agg_id
:
usize
agg_param
:
&
Self
:
:
AggregationParam
nonce
:
&
[
u8
;
NONCE_SIZE
]
public_share
:
&
Self
:
:
PublicShare
input_share
:
&
Self
:
:
InputShare
)
-
>
Result
<
(
Self
:
:
PrepareState
Self
:
:
PrepareShare
)
VdafError
>
;
fn
prepare_preprocess
<
M
:
IntoIterator
<
Item
=
Self
:
:
PrepareShare
>
>
(
&
self
inputs
:
M
)
-
>
Result
<
Self
:
:
PrepareMessage
VdafError
>
;
fn
prepare_step
(
&
self
state
:
Self
:
:
PrepareState
input
:
Self
:
:
PrepareMessage
)
-
>
Result
<
PrepareTransition
<
Self
VERIFY_KEY_SIZE
NONCE_SIZE
>
VdafError
>
;
fn
aggregate
<
M
:
IntoIterator
<
Item
=
Self
:
:
OutputShare
>
>
(
&
self
agg_param
:
&
Self
:
:
AggregationParam
output_shares
:
M
)
-
>
Result
<
Self
:
:
AggregateShare
VdafError
>
;
}
pub
trait
Collector
:
Vdaf
{
fn
unshard
<
M
:
IntoIterator
<
Item
=
Self
:
:
AggregateShare
>
>
(
&
self
agg_param
:
&
Self
:
:
AggregationParam
agg_shares
:
M
num_measurements
:
usize
)
-
>
Result
<
Self
:
:
AggregateResult
VdafError
>
;
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
PrepareTransition
<
V
:
Aggregator
<
VERIFY_KEY_SIZE
NONCE_SIZE
>
const
VERIFY_KEY_SIZE
:
usize
const
NONCE_SIZE
:
usize
>
{
Continue
(
V
:
:
PrepareState
V
:
:
PrepareShare
)
Finish
(
V
:
:
OutputShare
)
}
pub
trait
Aggregatable
:
Clone
+
Debug
+
From
<
Self
:
:
OutputShare
>
{
type
OutputShare
;
fn
merge
(
&
mut
self
agg_share
:
&
Self
)
-
>
Result
<
(
)
VdafError
>
;
fn
accumulate
(
&
mut
self
output_share
:
&
Self
:
:
OutputShare
)
-
>
Result
<
(
)
VdafError
>
;
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
pub
struct
OutputShare
<
F
>
(
Vec
<
F
>
)
;
impl
<
F
>
AsRef
<
[
F
]
>
for
OutputShare
<
F
>
{
fn
as_ref
(
&
self
)
-
>
&
[
F
]
{
&
self
.
0
}
}
impl
<
F
>
From
<
Vec
<
F
>
>
for
OutputShare
<
F
>
{
fn
from
(
other
:
Vec
<
F
>
)
-
>
Self
{
Self
(
other
)
}
}
impl
<
F
:
FieldElement
>
Encode
for
OutputShare
<
F
>
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
encode_fieldvec
(
&
self
.
0
bytes
)
}
fn
encoded_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
F
:
:
ENCODED_SIZE
*
self
.
0
.
len
(
)
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Serialize
Deserialize
)
]
pub
struct
AggregateShare
<
F
>
(
Vec
<
F
>
)
;
impl
<
F
:
FieldElement
>
AsRef
<
[
F
]
>
for
AggregateShare
<
F
>
{
fn
as_ref
(
&
self
)
-
>
&
[
F
]
{
&
self
.
0
}
}
impl
<
F
>
From
<
OutputShare
<
F
>
>
for
AggregateShare
<
F
>
{
fn
from
(
other
:
OutputShare
<
F
>
)
-
>
Self
{
Self
(
other
.
0
)
}
}
impl
<
F
:
FieldElement
>
Aggregatable
for
AggregateShare
<
F
>
{
type
OutputShare
=
OutputShare
<
F
>
;
fn
merge
(
&
mut
self
agg_share
:
&
Self
)
-
>
Result
<
(
)
VdafError
>
{
self
.
sum
(
agg_share
.
as_ref
(
)
)
}
fn
accumulate
(
&
mut
self
output_share
:
&
Self
:
:
OutputShare
)
-
>
Result
<
(
)
VdafError
>
{
self
.
sum
(
output_share
.
as_ref
(
)
)
}
}
impl
<
F
:
FieldElement
>
AggregateShare
<
F
>
{
fn
sum
(
&
mut
self
other
:
&
[
F
]
)
-
>
Result
<
(
)
VdafError
>
{
merge_vector
(
&
mut
self
.
0
other
)
.
map_err
(
Into
:
:
into
)
}
}
impl
<
F
:
FieldElement
>
Encode
for
AggregateShare
<
F
>
{
fn
encode
(
&
self
bytes
:
&
mut
Vec
<
u8
>
)
{
encode_fieldvec
(
&
self
.
0
bytes
)
}
fn
encoded_len
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
F
:
:
ENCODED_SIZE
*
self
.
0
.
len
(
)
)
}
}
#
[
cfg
(
test
)
]
pub
(
crate
)
fn
run_vdaf
<
V
M
const
SEED_SIZE
:
usize
>
(
vdaf
:
&
V
agg_param
:
&
V
:
:
AggregationParam
measurements
:
M
)
-
>
Result
<
V
:
:
AggregateResult
VdafError
>
where
V
:
Client
<
16
>
+
Aggregator
<
SEED_SIZE
16
>
+
Collector
M
:
IntoIterator
<
Item
=
V
:
:
Measurement
>
{
use
rand
:
:
prelude
:
:
*
;
let
mut
rng
=
thread_rng
(
)
;
let
mut
verify_key
=
[
0
;
SEED_SIZE
]
;
rng
.
fill
(
&
mut
verify_key
[
.
.
]
)
;
let
mut
agg_shares
:
Vec
<
Option
<
V
:
:
AggregateShare
>
>
=
vec
!
[
None
;
vdaf
.
num_aggregators
(
)
]
;
let
mut
num_measurements
:
usize
=
0
;
for
measurement
in
measurements
.
into_iter
(
)
{
num_measurements
+
=
1
;
let
nonce
=
rng
.
gen
(
)
;
let
(
public_share
input_shares
)
=
vdaf
.
shard
(
&
measurement
&
nonce
)
?
;
let
out_shares
=
run_vdaf_prepare
(
vdaf
&
verify_key
agg_param
&
nonce
public_share
input_shares
)
?
;
for
(
out_share
agg_share
)
in
out_shares
.
into_iter
(
)
.
zip
(
agg_shares
.
iter_mut
(
)
)
{
let
encoded_out_share
=
out_share
.
get_encoded
(
)
;
let
round_trip_out_share
=
V
:
:
OutputShare
:
:
get_decoded_with_param
(
&
(
vdaf
agg_param
)
&
encoded_out_share
)
.
unwrap
(
)
;
assert_eq
!
(
round_trip_out_share
.
get_encoded
(
)
encoded_out_share
)
;
let
this_agg_share
=
V
:
:
AggregateShare
:
:
from
(
out_share
)
;
if
let
Some
(
ref
mut
inner
)
=
agg_share
{
inner
.
merge
(
&
this_agg_share
)
?
;
}
else
{
*
agg_share
=
Some
(
this_agg_share
)
;
}
}
}
for
agg_share
in
agg_shares
.
iter
(
)
{
let
encoded_agg_share
=
agg_share
.
as_ref
(
)
.
unwrap
(
)
.
get_encoded
(
)
;
let
round_trip_agg_share
=
V
:
:
AggregateShare
:
:
get_decoded_with_param
(
&
(
vdaf
agg_param
)
&
encoded_agg_share
)
.
unwrap
(
)
;
assert_eq
!
(
round_trip_agg_share
.
get_encoded
(
)
encoded_agg_share
)
;
}
let
res
=
vdaf
.
unshard
(
agg_param
agg_shares
.
into_iter
(
)
.
map
(
|
option
|
option
.
unwrap
(
)
)
num_measurements
)
?
;
Ok
(
res
)
}
#
[
cfg
(
test
)
]
pub
(
crate
)
fn
run_vdaf_prepare
<
V
M
const
SEED_SIZE
:
usize
>
(
vdaf
:
&
V
verify_key
:
&
[
u8
;
SEED_SIZE
]
agg_param
:
&
V
:
:
AggregationParam
nonce
:
&
[
u8
;
16
]
public_share
:
V
:
:
PublicShare
input_shares
:
M
)
-
>
Result
<
Vec
<
V
:
:
OutputShare
>
VdafError
>
where
V
:
Client
<
16
>
+
Aggregator
<
SEED_SIZE
16
>
+
Collector
M
:
IntoIterator
<
Item
=
V
:
:
InputShare
>
{
let
input_shares
=
input_shares
.
into_iter
(
)
.
map
(
|
input_share
|
input_share
.
get_encoded
(
)
)
;
let
mut
states
=
Vec
:
:
new
(
)
;
let
mut
outbound
=
Vec
:
:
new
(
)
;
for
(
agg_id
input_share
)
in
input_shares
.
enumerate
(
)
{
let
(
state
msg
)
=
vdaf
.
prepare_init
(
verify_key
agg_id
agg_param
nonce
&
public_share
&
V
:
:
InputShare
:
:
get_decoded_with_param
(
&
(
vdaf
agg_id
)
&
input_share
)
.
expect
(
"
failed
to
decode
input
share
"
)
)
?
;
states
.
push
(
state
)
;
outbound
.
push
(
msg
.
get_encoded
(
)
)
;
}
let
mut
inbound
=
vdaf
.
prepare_preprocess
(
outbound
.
iter
(
)
.
map
(
|
encoded
|
{
V
:
:
PrepareShare
:
:
get_decoded_with_param
(
&
states
[
0
]
encoded
)
.
expect
(
"
failed
to
decode
prep
share
"
)
}
)
)
?
.
get_encoded
(
)
;
let
mut
out_shares
=
Vec
:
:
new
(
)
;
loop
{
let
mut
outbound
=
Vec
:
:
new
(
)
;
for
state
in
states
.
iter_mut
(
)
{
match
vdaf
.
prepare_step
(
state
.
clone
(
)
V
:
:
PrepareMessage
:
:
get_decoded_with_param
(
state
&
inbound
)
.
expect
(
"
failed
to
decode
prep
message
"
)
)
?
{
PrepareTransition
:
:
Continue
(
new_state
msg
)
=
>
{
outbound
.
push
(
msg
.
get_encoded
(
)
)
;
*
state
=
new_state
}
PrepareTransition
:
:
Finish
(
out_share
)
=
>
{
out_shares
.
push
(
out_share
)
;
}
}
}
if
outbound
.
len
(
)
=
=
vdaf
.
num_aggregators
(
)
{
inbound
=
vdaf
.
prepare_preprocess
(
outbound
.
iter
(
)
.
map
(
|
encoded
|
{
V
:
:
PrepareShare
:
:
get_decoded_with_param
(
&
states
[
0
]
encoded
)
.
expect
(
"
failed
to
decode
prep
share
"
)
}
)
)
?
.
get_encoded
(
)
;
}
else
if
outbound
.
is_empty
(
)
{
break
;
}
else
{
panic
!
(
"
Aggregators
did
not
finish
the
prepare
phase
at
the
same
time
"
)
;
}
}
Ok
(
out_shares
)
}
#
[
cfg
(
test
)
]
fn
fieldvec_roundtrip_test
<
F
V
T
>
(
vdaf
:
&
V
agg_param
:
&
V
:
:
AggregationParam
length
:
usize
)
where
F
:
FieldElement
V
:
Vdaf
T
:
Encode
for
<
'
a
>
T
:
ParameterizedDecode
<
(
&
'
a
V
&
'
a
V
:
:
AggregationParam
)
>
{
let
g
=
F
:
:
one
(
)
+
F
:
:
one
(
)
;
let
vec
:
Vec
<
F
>
=
itertools
:
:
iterate
(
F
:
:
one
(
)
|
&
v
|
g
*
v
)
.
take
(
length
)
.
collect
(
)
;
let
mut
bytes
=
Vec
:
:
with_capacity
(
vec
.
len
(
)
*
F
:
:
ENCODED_SIZE
)
;
encode_fieldvec
(
&
vec
&
mut
bytes
)
;
let
value
=
T
:
:
get_decoded_with_param
(
&
(
vdaf
agg_param
)
&
bytes
)
.
unwrap
(
)
;
let
encoded
=
value
.
get_encoded
(
)
;
assert_eq
!
(
encoded
bytes
)
;
}
#
[
cfg
(
all
(
feature
=
"
crypto
-
dependencies
"
feature
=
"
experimental
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
crypto
-
dependencies
"
feature
=
"
experimental
"
)
)
)
)
]
pub
mod
poplar1
;
pub
mod
prg
;
#
[
cfg
(
feature
=
"
prio2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
prio2
"
)
)
)
]
pub
mod
prio2
;
pub
mod
prio3
;
#
[
cfg
(
test
)
]
mod
prio3_test
;
