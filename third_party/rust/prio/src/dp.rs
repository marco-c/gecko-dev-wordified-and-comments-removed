use
num_bigint
:
:
{
BigInt
BigUint
TryFromBigIntError
}
;
use
num_rational
:
:
{
BigRational
Ratio
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
pub
enum
DpError
{
#
[
error
(
"
DP
error
:
input
value
was
not
a
valid
privacy
parameter
.
\
It
should
to
be
a
non
-
negative
finite
float
.
"
)
]
InvalidFloat
#
[
error
(
"
DP
error
:
input
denominator
was
zero
.
"
)
]
ZeroDenominator
#
[
error
(
"
DP
error
:
{
0
}
"
)
]
BigIntConversion
(
#
[
from
]
TryFromBigIntError
<
BigInt
>
)
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Rational
(
Ratio
<
BigUint
>
)
;
impl
Rational
{
pub
fn
from_unsigned
<
T
>
(
n
:
T
d
:
T
)
-
>
Result
<
Self
DpError
>
where
T
:
Into
<
u128
>
{
let
d
=
d
.
into
(
)
;
if
d
=
=
0
{
Err
(
DpError
:
:
ZeroDenominator
)
}
else
{
Ok
(
Rational
(
Ratio
:
:
<
BigUint
>
:
:
new
(
n
.
into
(
)
.
into
(
)
d
.
into
(
)
)
)
)
}
}
}
impl
TryFrom
<
f32
>
for
Rational
{
type
Error
=
DpError
;
fn
try_from
(
value
:
f32
)
-
>
Result
<
Self
DpError
>
{
match
BigRational
:
:
from_float
(
value
)
{
Some
(
y
)
=
>
Ok
(
Rational
(
Ratio
:
:
<
BigUint
>
:
:
new
(
y
.
numer
(
)
.
clone
(
)
.
try_into
(
)
?
y
.
denom
(
)
.
clone
(
)
.
try_into
(
)
?
)
)
)
None
=
>
Err
(
DpError
:
:
InvalidFloat
)
?
}
}
}
pub
trait
DifferentialPrivacyBudget
{
}
pub
trait
DifferentialPrivacyDistribution
{
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Serialize
Deserialize
Ord
PartialOrd
)
]
pub
struct
ZCdpBudget
{
epsilon
:
Ratio
<
BigUint
>
}
impl
ZCdpBudget
{
pub
fn
new
(
epsilon
:
Rational
)
-
>
Self
{
Self
{
epsilon
:
epsilon
.
0
}
}
}
impl
DifferentialPrivacyBudget
for
ZCdpBudget
{
}
pub
trait
DifferentialPrivacyStrategy
{
type
Budget
:
DifferentialPrivacyBudget
;
type
Distribution
:
DifferentialPrivacyDistribution
;
type
Sensitivity
;
fn
from_budget
(
b
:
Self
:
:
Budget
)
-
>
Self
;
fn
create_distribution
(
&
self
s
:
Self
:
:
Sensitivity
)
-
>
Result
<
Self
:
:
Distribution
DpError
>
;
}
pub
mod
distributions
;
