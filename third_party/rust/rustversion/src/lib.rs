#
!
[
allow
(
clippy
:
:
cast_lossless
clippy
:
:
cast_possible_truncation
clippy
:
:
derive_partial_eq_without_eq
clippy
:
:
doc_markdown
clippy
:
:
enum_glob_use
clippy
:
:
from_iter_instead_of_collect
clippy
:
:
iter_with_drain
clippy
:
:
module_name_repetitions
clippy
:
:
must_use_candidate
clippy
:
:
needless_doctest_main
clippy
:
:
needless_pass_by_value
clippy
:
:
redundant_else
clippy
:
:
toplevel_ref_arg
clippy
:
:
unreadable_literal
)
]
extern
crate
proc_macro
;
mod
attr
;
mod
bound
;
mod
constfn
;
mod
date
;
mod
error
;
mod
expand
;
mod
expr
;
mod
iter
;
mod
release
;
mod
time
;
mod
token
;
mod
version
;
use
crate
:
:
error
:
:
Error
;
use
crate
:
:
version
:
:
Version
;
use
proc_macro
:
:
TokenStream
;
const
RUSTVERSION
:
Version
=
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
version
.
expr
"
)
)
;
#
[
proc_macro_attribute
]
pub
fn
stable
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
stable
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
beta
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
beta
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
nightly
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
nightly
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
since
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
since
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
before
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
before
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
not
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
not
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
any
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
any
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
all
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
expand
:
:
cfg
(
"
all
"
args
input
)
}
#
[
proc_macro_attribute
]
pub
fn
attr
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
attr
:
:
parse
(
args
)
.
and_then
(
|
args
|
expand
:
:
try_attr
(
args
input
)
)
.
unwrap_or_else
(
Error
:
:
into_compile_error
)
}
#
[
cfg
(
not
(
cfg_macro_not_allowed
)
)
]
#
[
proc_macro
]
pub
fn
cfg
(
input
:
TokenStream
)
-
>
TokenStream
{
use
proc_macro
:
:
{
Ident
Span
TokenTree
}
;
(
|
|
{
let
ref
mut
args
=
iter
:
:
new
(
input
)
;
let
expr
=
expr
:
:
parse
(
args
)
?
;
token
:
:
parse_end
(
args
)
?
;
let
boolean
=
expr
.
eval
(
RUSTVERSION
)
;
let
ident
=
Ident
:
:
new
(
&
boolean
.
to_string
(
)
Span
:
:
call_site
(
)
)
;
Ok
(
TokenStream
:
:
from
(
TokenTree
:
:
Ident
(
ident
)
)
)
}
)
(
)
.
unwrap_or_else
(
Error
:
:
into_compile_error
)
}
