#
!
[
cfg_attr
(
feature
=
"
unstable
"
feature
(
alloc
heap_api
repr_simd
)
)
]
extern
crate
heapsize
;
use
heapsize
:
:
{
HeapSizeOf
heap_size_of
}
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
const
EMPTY
:
*
mut
(
)
=
0x1
as
*
mut
(
)
;
#
[
cfg
(
feature
=
"
flexible
-
tests
"
)
]
macro_rules
!
assert_size
{
(
actual
:
expr
expected
:
expr
)
=
>
{
{
let
actual
=
actual
;
let
expected
=
expected
;
assert
!
(
actual
>
=
expected
"
expected
{
:
?
}
>
=
{
:
?
}
"
actual
expected
)
}
}
}
#
[
cfg
(
not
(
feature
=
"
flexible
-
tests
"
)
)
]
macro_rules
!
assert_size
{
(
actual
:
expr
expected
:
expr
)
=
>
{
assert_eq
!
(
actual
expected
)
}
}
#
[
cfg
(
feature
=
"
unstable
"
)
]
mod
unstable
{
extern
crate
alloc
;
use
heapsize
:
:
heap_size_of
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
#
[
repr
(
C
simd
)
]
struct
OverAligned
(
u64
u64
u64
u64
)
;
#
[
test
]
fn
check_empty
(
)
{
assert_eq
!
(
:
:
EMPTY
alloc
:
:
heap
:
:
EMPTY
)
;
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
#
[
test
]
fn
test_alloc
(
)
{
unsafe
{
let
x
=
alloc
:
:
heap
:
:
allocate
(
64
0
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
64
)
;
alloc
:
:
heap
:
:
deallocate
(
x
64
0
)
;
let
x
=
alloc
:
:
heap
:
:
allocate
(
255
0
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
256
)
;
alloc
:
:
heap
:
:
deallocate
(
x
255
0
)
;
let
x
=
alloc
:
:
heap
:
:
allocate
(
1024
*
1024
0
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
1024
*
1024
)
;
alloc
:
:
heap
:
:
deallocate
(
x
1024
*
1024
0
)
;
let
x
=
alloc
:
:
heap
:
:
allocate
(
1024
*
1024
32
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
1024
*
1024
)
;
alloc
:
:
heap
:
:
deallocate
(
x
1024
*
1024
32
)
;
}
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
#
[
test
]
fn
test_alloc
(
)
{
unsafe
{
let
x
=
alloc
:
:
heap
:
:
allocate
(
64
0
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
64
)
;
alloc
:
:
heap
:
:
deallocate
(
x
64
0
)
;
let
x
=
alloc
:
:
heap
:
:
allocate
(
255
0
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
255
)
;
alloc
:
:
heap
:
:
deallocate
(
x
255
0
)
;
let
x
=
alloc
:
:
heap
:
:
allocate
(
1024
*
1024
0
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
1024
*
1024
)
;
alloc
:
:
heap
:
:
deallocate
(
x
1024
*
1024
0
)
;
let
x
=
alloc
:
:
heap
:
:
allocate
(
1024
*
1024
32
)
;
assert_size
!
(
heap_size_of
(
x
as
*
const
c_void
)
1024
*
1024
+
32
)
;
alloc
:
:
heap
:
:
deallocate
(
x
1024
*
1024
32
)
;
}
}
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
#
[
test
]
fn
test_simd
(
)
{
let
x
=
Box
:
:
new
(
OverAligned
(
0
0
0
0
)
)
;
assert_size
!
(
unsafe
{
heap_size_of
(
&
*
x
as
*
const
_
as
*
const
c_void
)
}
32
)
;
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
#
[
test
]
fn
test_simd
(
)
{
let
x
=
Box
:
:
new
(
OverAligned
(
0
0
0
0
)
)
;
assert_size
!
(
unsafe
{
heap_size_of
(
&
*
x
as
*
const
_
as
*
const
c_void
)
}
32
+
32
)
;
}
}
#
[
test
]
fn
test_boxed_str
(
)
{
let
x
=
"
raclette
"
.
to_owned
(
)
.
into_boxed_str
(
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
8
)
;
}
#
[
test
]
fn
test_heap_size
(
)
{
unsafe
{
assert_size
!
(
heap_size_of
(
EMPTY
as
*
const
c_void
)
0
)
;
}
let
x
=
0i64
;
assert_size
!
(
x
.
heap_size_of_children
(
)
0
)
;
let
x
=
Box
:
:
new
(
0i64
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
8
)
;
let
string
=
String
:
:
from
(
"
0123456789abcdef
"
)
;
assert_size
!
(
string
.
heap_size_of_children
(
)
16
)
;
let
string_ref
:
(
&
String
(
)
)
=
(
&
string
(
)
)
;
assert_size
!
(
string_ref
.
heap_size_of_children
(
)
0
)
;
let
slice
:
&
str
=
&
*
string
;
assert_size
!
(
slice
.
heap_size_of_children
(
)
0
)
;
let
x
:
Option
<
i32
>
=
None
;
assert_size
!
(
x
.
heap_size_of_children
(
)
0
)
;
let
x
=
Some
(
0i64
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
0
)
;
let
x
=
Some
(
Box
:
:
new
(
0i64
)
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
8
)
;
let
x
=
:
:
std
:
:
sync
:
:
Arc
:
:
new
(
0i64
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
0
)
;
let
x
=
:
:
std
:
:
sync
:
:
Arc
:
:
new
(
Box
:
:
new
(
0i64
)
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
8
)
;
let
x
:
Vec
<
i64
>
=
vec
!
[
]
;
assert_size
!
(
x
.
heap_size_of_children
(
)
0
)
;
let
x
=
vec
!
[
0i64
1i64
2i64
3i64
]
;
assert_size
!
(
x
.
heap_size_of_children
(
)
32
)
;
}
#
[
test
]
fn
test_boxed_slice
(
)
{
let
x
=
vec
!
[
1i64
2i64
]
.
into_boxed_slice
(
)
;
assert_size
!
(
x
.
heap_size_of_children
(
)
16
)
}
