#
[
cfg
(
feature
=
"
backtrace
"
)
]
pub
use
backtrace
;
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
pub
mod
backtrace
{
use
std
:
:
fmt
;
pub
struct
Backtrace
;
impl
fmt
:
:
Debug
for
Backtrace
{
#
[
cold
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Not
available
"
)
}
}
}
#
[
macro_export
]
macro_rules
!
define_error_wrapper
{
(
Kind
:
ty
)
=
>
{
pub
type
Result
<
T
E
=
Error
>
=
std
:
:
result
:
:
Result
<
T
E
>
;
struct
ErrorData
{
kind
:
Kind
backtrace
:
Option
<
std
:
:
sync
:
:
Mutex
<
crate
:
:
backtrace
:
:
Backtrace
>
>
}
impl
ErrorData
{
#
[
cold
]
fn
new
(
kind
:
Kind
)
-
>
Self
{
ErrorData
{
kind
#
[
cfg
(
feature
=
"
backtrace
"
)
]
backtrace
:
Some
(
std
:
:
sync
:
:
Mutex
:
:
new
(
crate
:
:
backtrace
:
:
Backtrace
:
:
new_unresolved
(
)
)
)
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
backtrace
:
None
}
}
#
[
cfg
(
feature
=
"
backtrace
"
)
]
#
[
cold
]
fn
get_backtrace
(
&
self
)
-
>
Option
<
&
std
:
:
sync
:
:
Mutex
<
crate
:
:
backtrace
:
:
Backtrace
>
>
{
self
.
backtrace
.
as_ref
(
)
.
map
(
|
mutex
|
{
mutex
.
lock
(
)
.
unwrap
(
)
.
resolve
(
)
;
mutex
}
)
}
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
#
[
cold
]
fn
get_backtrace
(
&
self
)
-
>
Option
<
&
std
:
:
sync
:
:
Mutex
<
crate
:
:
backtrace
:
:
Backtrace
>
>
{
None
}
}
impl
std
:
:
fmt
:
:
Debug
for
ErrorData
{
#
[
cfg
(
feature
=
"
backtrace
"
)
]
#
[
cold
]
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
let
mut
bt
=
self
.
backtrace
.
unwrap
(
)
.
lock
(
)
.
unwrap
(
)
;
bt
.
resolve
(
)
;
write
!
(
f
"
{
:
?
}
\
n
\
n
{
}
"
bt
self
.
kind
)
}
#
[
cfg
(
not
(
feature
=
"
backtrace
"
)
)
]
#
[
cold
]
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
kind
)
}
}
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
pub
struct
Error
(
Box
<
ErrorData
>
)
;
impl
Error
{
#
[
cold
]
pub
fn
kind
(
&
self
)
-
>
&
Kind
{
&
self
.
0
.
kind
}
#
[
cold
]
pub
fn
backtrace
(
&
self
)
-
>
Option
<
&
std
:
:
sync
:
:
Mutex
<
crate
:
:
backtrace
:
:
Backtrace
>
>
{
self
.
0
.
get_backtrace
(
)
}
}
impl
std
:
:
fmt
:
:
Display
for
Error
{
#
[
cold
]
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
std
:
:
fmt
:
:
Display
:
:
fmt
(
self
.
kind
(
)
f
)
}
}
impl
From
<
Kind
>
for
Error
{
/
/
Cold
to
optimize
in
favor
of
non
-
error
cases
.
#
[
cold
]
fn
from
(
ctx
:
Kind
)
-
>
Error
{
Error
(
Box
:
:
new
(
ErrorData
:
:
new
(
ctx
)
)
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
define_error_conversions
{
(
Kind
:
ident
{
(
(
variant
:
ident
type
:
ty
)
)
*
(
)
?
}
)
=
>
(
(
impl
From
<
type
>
for
Error
{
/
/
Cold
to
optimize
in
favor
of
non
-
error
cases
.
#
[
cold
]
fn
from
(
e
:
type
)
-
>
Self
{
Error
:
:
from
(
Kind
:
:
variant
(
e
)
)
}
}
)
*
)
;
}
#
[
macro_export
]
macro_rules
!
define_error
{
(
Kind
:
ident
{
(
(
variant
:
ident
type
:
ty
)
)
*
(
)
?
}
)
=
>
{
crate
:
:
define_error_wrapper
!
(
Kind
)
;
crate
:
:
define_error_conversions
!
{
Kind
{
(
(
variant
type
)
)
*
}
}
}
;
}
