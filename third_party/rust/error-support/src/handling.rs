#
[
derive
(
Debug
Default
)
]
pub
struct
ErrorReporting
{
log_level
:
Option
<
log
:
:
Level
>
report_class
:
Option
<
String
>
}
pub
struct
ErrorHandling
<
E
>
{
pub
err
:
E
pub
reporting
:
ErrorReporting
}
impl
<
E
>
ErrorHandling
<
E
>
{
pub
fn
convert
(
err
:
E
)
-
>
Self
{
Self
{
err
reporting
:
ErrorReporting
:
:
default
(
)
}
}
pub
fn
log
(
self
level
:
log
:
:
Level
)
-
>
Self
{
Self
{
err
:
self
.
err
reporting
:
ErrorReporting
{
log_level
:
Some
(
level
)
.
.
self
.
reporting
}
}
}
pub
fn
report
(
self
report_class
:
impl
Into
<
String
>
)
-
>
Self
{
Self
{
err
:
self
.
err
reporting
:
ErrorReporting
{
report_class
:
Some
(
report_class
.
into
(
)
)
.
.
self
.
reporting
}
}
}
pub
fn
log_warning
(
self
)
-
>
Self
{
self
.
log
(
log
:
:
Level
:
:
Warn
)
}
pub
fn
report_error
(
self
report_class
:
impl
Into
<
String
>
)
-
>
Self
{
Self
{
err
:
self
.
err
reporting
:
ErrorReporting
{
log_level
:
Some
(
log
:
:
Level
:
:
Error
)
report_class
:
Some
(
report_class
.
into
(
)
)
}
}
}
}
pub
trait
GetErrorHandling
{
type
ExternalError
;
fn
get_error_handling
(
&
self
)
-
>
ErrorHandling
<
Self
:
:
ExternalError
>
;
}
pub
fn
convert_log_report_error
<
IE
EE
>
(
e
:
IE
)
-
>
EE
where
IE
:
GetErrorHandling
<
ExternalError
=
EE
>
+
std
:
:
error
:
:
Error
EE
:
std
:
:
error
:
:
Error
{
let
handling
=
e
.
get_error_handling
(
)
;
let
reporting
=
handling
.
reporting
;
if
let
Some
(
level
)
=
reporting
.
log_level
{
log
:
:
log
!
(
level
"
{
}
"
e
.
to_string
(
)
)
;
}
if
let
Some
(
report_class
)
=
reporting
.
report_class
{
#
[
cfg
(
feature
=
"
reporting
"
)
]
crate
:
:
report_error
(
report_class
e
.
to_string
(
)
)
;
#
[
cfg
(
not
(
feature
=
"
reporting
"
)
)
]
let
_
=
report_class
;
}
handling
.
err
}
