#
!
[
cfg_attr
(
all
(
test
feature
=
"
nightly
"
)
feature
(
test
)
)
]
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
extern
crate
test
;
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
extern
crate
rand
;
extern
crate
bit_vec
;
use
bit_vec
:
:
{
BitVec
Blocks
BitBlock
}
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
std
:
:
hash
;
use
std
:
:
iter
:
:
{
self
Chain
Enumerate
FromIterator
Repeat
Skip
Take
}
;
type
MatchWords
<
'
a
B
>
=
Chain
<
Enumerate
<
Blocks
<
'
a
B
>
>
Skip
<
Take
<
Enumerate
<
Repeat
<
B
>
>
>
>
>
;
fn
blocks_for_bits
<
B
:
BitBlock
>
(
bits
:
usize
)
-
>
usize
{
if
bits
%
B
:
:
bits
(
)
=
=
0
{
bits
/
B
:
:
bits
(
)
}
else
{
bits
/
B
:
:
bits
(
)
+
1
}
}
fn
match_words
<
'
a
'
b
B
:
BitBlock
>
(
a
:
&
'
a
BitVec
<
B
>
b
:
&
'
b
BitVec
<
B
>
)
-
>
(
MatchWords
<
'
a
B
>
MatchWords
<
'
b
B
>
)
{
let
a_len
=
a
.
storage
(
)
.
len
(
)
;
let
b_len
=
b
.
storage
(
)
.
len
(
)
;
if
a_len
<
b_len
{
(
a
.
blocks
(
)
.
enumerate
(
)
.
chain
(
iter
:
:
repeat
(
B
:
:
zero
(
)
)
.
enumerate
(
)
.
take
(
b_len
)
.
skip
(
a_len
)
)
b
.
blocks
(
)
.
enumerate
(
)
.
chain
(
iter
:
:
repeat
(
B
:
:
zero
(
)
)
.
enumerate
(
)
.
take
(
0
)
.
skip
(
0
)
)
)
}
else
{
(
a
.
blocks
(
)
.
enumerate
(
)
.
chain
(
iter
:
:
repeat
(
B
:
:
zero
(
)
)
.
enumerate
(
)
.
take
(
0
)
.
skip
(
0
)
)
b
.
blocks
(
)
.
enumerate
(
)
.
chain
(
iter
:
:
repeat
(
B
:
:
zero
(
)
)
.
enumerate
(
)
.
take
(
a_len
)
.
skip
(
b_len
)
)
)
}
}
pub
struct
BitSet
<
B
=
u32
>
{
bit_vec
:
BitVec
<
B
>
}
impl
<
B
:
BitBlock
>
Clone
for
BitSet
<
B
>
{
fn
clone
(
&
self
)
-
>
Self
{
BitSet
{
bit_vec
:
self
.
bit_vec
.
clone
(
)
}
}
fn
clone_from
(
&
mut
self
other
:
&
Self
)
{
self
.
bit_vec
.
clone_from
(
&
other
.
bit_vec
)
;
}
}
impl
<
B
:
BitBlock
>
Default
for
BitSet
<
B
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
BitSet
{
bit_vec
:
Default
:
:
default
(
)
}
}
}
impl
<
B
:
BitBlock
>
FromIterator
<
usize
>
for
BitSet
<
B
>
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
usize
>
>
(
iter
:
I
)
-
>
Self
{
let
mut
ret
=
Self
:
:
default
(
)
;
ret
.
extend
(
iter
)
;
ret
}
}
impl
<
B
:
BitBlock
>
Extend
<
usize
>
for
BitSet
<
B
>
{
#
[
inline
]
fn
extend
<
I
:
IntoIterator
<
Item
=
usize
>
>
(
&
mut
self
iter
:
I
)
{
for
i
in
iter
{
self
.
insert
(
i
)
;
}
}
}
impl
<
B
:
BitBlock
>
PartialOrd
for
BitSet
<
B
>
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
self
.
iter
(
)
.
partial_cmp
(
other
)
}
}
impl
<
B
:
BitBlock
>
Ord
for
BitSet
<
B
>
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
self
.
iter
(
)
.
cmp
(
other
)
}
}
impl
<
B
:
BitBlock
>
PartialEq
for
BitSet
<
B
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
iter
(
)
.
eq
(
other
)
}
}
impl
<
B
:
BitBlock
>
Eq
for
BitSet
<
B
>
{
}
impl
BitSet
<
u32
>
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
inline
]
pub
fn
with_capacity
(
nbits
:
usize
)
-
>
Self
{
let
bit_vec
=
BitVec
:
:
from_elem
(
nbits
false
)
;
Self
:
:
from_bit_vec
(
bit_vec
)
}
#
[
inline
]
pub
fn
from_bit_vec
(
bit_vec
:
BitVec
)
-
>
Self
{
BitSet
{
bit_vec
:
bit_vec
}
}
pub
fn
from_bytes
(
bytes
:
&
[
u8
]
)
-
>
Self
{
BitSet
{
bit_vec
:
BitVec
:
:
from_bytes
(
bytes
)
}
}
}
impl
<
B
:
BitBlock
>
BitSet
<
B
>
{
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
bit_vec
.
capacity
(
)
}
pub
fn
reserve_len
(
&
mut
self
len
:
usize
)
{
let
cur_len
=
self
.
bit_vec
.
len
(
)
;
if
len
>
=
cur_len
{
self
.
bit_vec
.
reserve
(
len
-
cur_len
)
;
}
}
pub
fn
reserve_len_exact
(
&
mut
self
len
:
usize
)
{
let
cur_len
=
self
.
bit_vec
.
len
(
)
;
if
len
>
=
cur_len
{
self
.
bit_vec
.
reserve_exact
(
len
-
cur_len
)
;
}
}
#
[
inline
]
pub
fn
into_bit_vec
(
self
)
-
>
BitVec
<
B
>
{
self
.
bit_vec
}
#
[
inline
]
pub
fn
get_ref
(
&
self
)
-
>
&
BitVec
<
B
>
{
&
self
.
bit_vec
}
#
[
inline
]
fn
other_op
<
F
>
(
&
mut
self
other
:
&
Self
mut
f
:
F
)
where
F
:
FnMut
(
B
B
)
-
>
B
{
let
self_bit_vec
=
&
mut
self
.
bit_vec
;
let
other_bit_vec
=
&
other
.
bit_vec
;
let
self_len
=
self_bit_vec
.
len
(
)
;
let
other_len
=
other_bit_vec
.
len
(
)
;
if
self_len
<
other_len
{
self_bit_vec
.
grow
(
other_len
-
self_len
false
)
;
}
let
other_words
=
{
let
(
_
result
)
=
match_words
(
self_bit_vec
other_bit_vec
)
;
result
}
;
for
(
i
w
)
in
other_words
{
let
old
=
self_bit_vec
.
storage
(
)
[
i
]
;
let
new
=
f
(
old
w
)
;
unsafe
{
self_bit_vec
.
storage_mut
(
)
[
i
]
=
new
;
}
}
}
#
[
inline
]
pub
fn
shrink_to_fit
(
&
mut
self
)
{
let
bit_vec
=
&
mut
self
.
bit_vec
;
let
old_len
=
bit_vec
.
storage
(
)
.
len
(
)
;
let
n
=
bit_vec
.
storage
(
)
.
iter
(
)
.
rev
(
)
.
take_while
(
|
&
&
n
|
n
=
=
B
:
:
zero
(
)
)
.
count
(
)
;
let
trunc_len
=
cmp
:
:
max
(
old_len
-
n
1
)
;
unsafe
{
bit_vec
.
storage_mut
(
)
.
truncate
(
trunc_len
)
;
bit_vec
.
set_len
(
trunc_len
*
B
:
:
bits
(
)
)
;
}
}
#
[
inline
]
pub
fn
iter
(
&
self
)
-
>
Iter
<
B
>
{
Iter
(
BlockIter
:
:
from_blocks
(
self
.
bit_vec
.
blocks
(
)
)
)
}
#
[
inline
]
pub
fn
union
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
Union
<
'
a
B
>
{
fn
or
<
B
:
BitBlock
>
(
w1
:
B
w2
:
B
)
-
>
B
{
w1
|
w2
}
Union
(
BlockIter
:
:
from_blocks
(
TwoBitPositions
{
set
:
self
.
bit_vec
.
blocks
(
)
other
:
other
.
bit_vec
.
blocks
(
)
merge
:
or
}
)
)
}
#
[
inline
]
pub
fn
intersection
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
Intersection
<
'
a
B
>
{
fn
bitand
<
B
:
BitBlock
>
(
w1
:
B
w2
:
B
)
-
>
B
{
w1
&
w2
}
let
min
=
cmp
:
:
min
(
self
.
bit_vec
.
len
(
)
other
.
bit_vec
.
len
(
)
)
;
Intersection
(
BlockIter
:
:
from_blocks
(
TwoBitPositions
{
set
:
self
.
bit_vec
.
blocks
(
)
other
:
other
.
bit_vec
.
blocks
(
)
merge
:
bitand
}
)
.
take
(
min
)
)
}
#
[
inline
]
pub
fn
difference
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
Difference
<
'
a
B
>
{
fn
diff
<
B
:
BitBlock
>
(
w1
:
B
w2
:
B
)
-
>
B
{
w1
&
!
w2
}
Difference
(
BlockIter
:
:
from_blocks
(
TwoBitPositions
{
set
:
self
.
bit_vec
.
blocks
(
)
other
:
other
.
bit_vec
.
blocks
(
)
merge
:
diff
}
)
)
}
#
[
inline
]
pub
fn
symmetric_difference
<
'
a
>
(
&
'
a
self
other
:
&
'
a
Self
)
-
>
SymmetricDifference
<
'
a
B
>
{
fn
bitxor
<
B
:
BitBlock
>
(
w1
:
B
w2
:
B
)
-
>
B
{
w1
^
w2
}
SymmetricDifference
(
BlockIter
:
:
from_blocks
(
TwoBitPositions
{
set
:
self
.
bit_vec
.
blocks
(
)
other
:
other
.
bit_vec
.
blocks
(
)
merge
:
bitxor
}
)
)
}
#
[
inline
]
pub
fn
union_with
(
&
mut
self
other
:
&
Self
)
{
self
.
other_op
(
other
|
w1
w2
|
w1
|
w2
)
;
}
#
[
inline
]
pub
fn
intersect_with
(
&
mut
self
other
:
&
Self
)
{
self
.
other_op
(
other
|
w1
w2
|
w1
&
w2
)
;
}
#
[
inline
]
pub
fn
difference_with
(
&
mut
self
other
:
&
Self
)
{
self
.
other_op
(
other
|
w1
w2
|
w1
&
!
w2
)
;
}
#
[
inline
]
pub
fn
symmetric_difference_with
(
&
mut
self
other
:
&
Self
)
{
self
.
other_op
(
other
|
w1
w2
|
w1
^
w2
)
;
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
bit_vec
.
blocks
(
)
.
fold
(
0
|
acc
n
|
acc
+
n
.
count_ones
(
)
as
usize
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
bit_vec
.
none
(
)
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
self
.
bit_vec
.
clear
(
)
;
}
#
[
inline
]
pub
fn
contains
(
&
self
value
:
usize
)
-
>
bool
{
let
bit_vec
=
&
self
.
bit_vec
;
value
<
bit_vec
.
len
(
)
&
&
bit_vec
[
value
]
}
#
[
inline
]
pub
fn
is_disjoint
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
intersection
(
other
)
.
next
(
)
.
is_none
(
)
}
#
[
inline
]
pub
fn
is_subset
(
&
self
other
:
&
Self
)
-
>
bool
{
let
self_bit_vec
=
&
self
.
bit_vec
;
let
other_bit_vec
=
&
other
.
bit_vec
;
let
other_blocks
=
blocks_for_bits
:
:
<
B
>
(
other_bit_vec
.
len
(
)
)
;
self_bit_vec
.
blocks
(
)
.
zip
(
other_bit_vec
.
blocks
(
)
)
.
all
(
|
(
w1
w2
)
|
w1
&
w2
=
=
w1
)
&
&
self_bit_vec
.
blocks
(
)
.
skip
(
other_blocks
)
.
all
(
|
w
|
w
=
=
B
:
:
zero
(
)
)
}
#
[
inline
]
pub
fn
is_superset
(
&
self
other
:
&
Self
)
-
>
bool
{
other
.
is_subset
(
self
)
}
pub
fn
insert
(
&
mut
self
value
:
usize
)
-
>
bool
{
if
self
.
contains
(
value
)
{
return
false
;
}
let
len
=
self
.
bit_vec
.
len
(
)
;
if
value
>
=
len
{
self
.
bit_vec
.
grow
(
value
-
len
+
1
false
)
}
self
.
bit_vec
.
set
(
value
true
)
;
return
true
;
}
pub
fn
remove
(
&
mut
self
value
:
usize
)
-
>
bool
{
if
!
self
.
contains
(
value
)
{
return
false
;
}
self
.
bit_vec
.
set
(
value
false
)
;
return
true
;
}
}
impl
<
B
:
BitBlock
>
fmt
:
:
Debug
for
BitSet
<
B
>
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_set
(
)
.
entries
(
self
)
.
finish
(
)
}
}
impl
<
B
:
BitBlock
>
hash
:
:
Hash
for
BitSet
<
B
>
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
for
pos
in
self
{
pos
.
hash
(
state
)
;
}
}
}
#
[
derive
(
Clone
)
]
struct
BlockIter
<
T
B
>
{
head
:
B
head_offset
:
usize
tail
:
T
}
impl
<
T
B
:
BitBlock
>
BlockIter
<
T
B
>
where
T
:
Iterator
<
Item
=
B
>
{
fn
from_blocks
(
mut
blocks
:
T
)
-
>
BlockIter
<
T
B
>
{
let
h
=
blocks
.
next
(
)
.
unwrap_or
(
B
:
:
zero
(
)
)
;
BlockIter
{
tail
:
blocks
head
:
h
head_offset
:
0
}
}
}
#
[
derive
(
Clone
)
]
struct
TwoBitPositions
<
'
a
B
:
'
a
>
{
set
:
Blocks
<
'
a
B
>
other
:
Blocks
<
'
a
B
>
merge
:
fn
(
B
B
)
-
>
B
}
#
[
derive
(
Clone
)
]
pub
struct
Iter
<
'
a
B
:
'
a
>
(
BlockIter
<
Blocks
<
'
a
B
>
B
>
)
;
#
[
derive
(
Clone
)
]
pub
struct
Union
<
'
a
B
:
'
a
>
(
BlockIter
<
TwoBitPositions
<
'
a
B
>
B
>
)
;
#
[
derive
(
Clone
)
]
pub
struct
Intersection
<
'
a
B
:
'
a
>
(
Take
<
BlockIter
<
TwoBitPositions
<
'
a
B
>
B
>
>
)
;
#
[
derive
(
Clone
)
]
pub
struct
Difference
<
'
a
B
:
'
a
>
(
BlockIter
<
TwoBitPositions
<
'
a
B
>
B
>
)
;
#
[
derive
(
Clone
)
]
pub
struct
SymmetricDifference
<
'
a
B
:
'
a
>
(
BlockIter
<
TwoBitPositions
<
'
a
B
>
B
>
)
;
impl
<
'
a
T
B
:
BitBlock
>
Iterator
for
BlockIter
<
T
B
>
where
T
:
Iterator
<
Item
=
B
>
{
type
Item
=
usize
;
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
while
self
.
head
=
=
B
:
:
zero
(
)
{
match
self
.
tail
.
next
(
)
{
Some
(
w
)
=
>
self
.
head
=
w
None
=
>
return
None
}
self
.
head_offset
+
=
B
:
:
bits
(
)
;
}
let
k
=
(
self
.
head
&
(
!
self
.
head
+
B
:
:
one
(
)
)
)
-
B
:
:
one
(
)
;
self
.
head
=
self
.
head
&
(
self
.
head
-
B
:
:
one
(
)
)
;
Some
(
self
.
head_offset
+
(
B
:
:
count_ones
(
k
)
as
usize
)
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
match
self
.
tail
.
size_hint
(
)
{
(
_
Some
(
h
)
)
=
>
(
0
Some
(
1
+
h
*
B
:
:
bits
(
)
)
)
_
=
>
(
0
None
)
}
}
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
TwoBitPositions
<
'
a
B
>
{
type
Item
=
B
;
fn
next
(
&
mut
self
)
-
>
Option
<
B
>
{
match
(
self
.
set
.
next
(
)
self
.
other
.
next
(
)
)
{
(
Some
(
a
)
Some
(
b
)
)
=
>
Some
(
(
self
.
merge
)
(
a
b
)
)
(
Some
(
a
)
None
)
=
>
Some
(
(
self
.
merge
)
(
a
B
:
:
zero
(
)
)
)
(
None
Some
(
b
)
)
=
>
Some
(
(
self
.
merge
)
(
B
:
:
zero
(
)
b
)
)
_
=
>
return
None
}
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
a
au
)
=
self
.
set
.
size_hint
(
)
;
let
(
b
bu
)
=
self
.
other
.
size_hint
(
)
;
let
upper
=
match
(
au
bu
)
{
(
Some
(
au
)
Some
(
bu
)
)
=
>
Some
(
cmp
:
:
max
(
au
bu
)
)
_
=
>
None
}
;
(
cmp
:
:
max
(
a
b
)
upper
)
}
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
Iter
<
'
a
B
>
{
type
Item
=
usize
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
0
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
Union
<
'
a
B
>
{
type
Item
=
usize
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
0
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
Intersection
<
'
a
B
>
{
type
Item
=
usize
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
0
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
Difference
<
'
a
B
>
{
type
Item
=
usize
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
0
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
Iterator
for
SymmetricDifference
<
'
a
B
>
{
type
Item
=
usize
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next
(
)
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
0
.
size_hint
(
)
}
}
impl
<
'
a
B
:
BitBlock
>
IntoIterator
for
&
'
a
BitSet
<
B
>
{
type
Item
=
usize
;
type
IntoIter
=
Iter
<
'
a
B
>
;
fn
into_iter
(
self
)
-
>
Iter
<
'
a
B
>
{
self
.
iter
(
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
cmp
:
:
Ordering
:
:
{
Equal
Greater
Less
}
;
use
super
:
:
BitSet
;
use
bit_vec
:
:
BitVec
;
#
[
test
]
fn
test_bit_set_show
(
)
{
let
mut
s
=
BitSet
:
:
new
(
)
;
s
.
insert
(
1
)
;
s
.
insert
(
10
)
;
s
.
insert
(
50
)
;
s
.
insert
(
2
)
;
assert_eq
!
(
"
{
1
2
10
50
}
"
format
!
(
"
{
:
?
}
"
s
)
)
;
}
#
[
test
]
fn
test_bit_set_from_usizes
(
)
{
let
usizes
=
vec
!
[
0
2
2
3
]
;
let
a
:
BitSet
=
usizes
.
into_iter
(
)
.
collect
(
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
b
.
insert
(
0
)
;
b
.
insert
(
2
)
;
b
.
insert
(
3
)
;
assert_eq
!
(
a
b
)
;
}
#
[
test
]
fn
test_bit_set_iterator
(
)
{
let
usizes
=
vec
!
[
0
2
2
3
]
;
let
bit_vec
:
BitSet
=
usizes
.
into_iter
(
)
.
collect
(
)
;
let
idxs
:
Vec
<
_
>
=
bit_vec
.
iter
(
)
.
collect
(
)
;
assert_eq
!
(
idxs
[
0
2
3
]
)
;
let
long
:
BitSet
=
(
0
.
.
10000
)
.
filter
(
|
&
n
|
n
%
2
=
=
0
)
.
collect
(
)
;
let
real
:
Vec
<
_
>
=
(
0
.
.
10000
/
2
)
.
map
(
|
x
|
x
*
2
)
.
collect
(
)
;
let
idxs
:
Vec
<
_
>
=
long
.
iter
(
)
.
collect
(
)
;
assert_eq
!
(
idxs
real
)
;
}
#
[
test
]
fn
test_bit_set_frombit_vec_init
(
)
{
let
bools
=
[
true
false
]
;
let
lengths
=
[
10
64
100
]
;
for
&
b
in
&
bools
{
for
&
l
in
&
lengths
{
let
bitset
=
BitSet
:
:
from_bit_vec
(
BitVec
:
:
from_elem
(
l
b
)
)
;
assert_eq
!
(
bitset
.
contains
(
1
)
b
)
;
assert_eq
!
(
bitset
.
contains
(
(
l
-
1
)
)
b
)
;
assert
!
(
!
bitset
.
contains
(
l
)
)
;
}
}
}
#
[
test
]
fn
test_bit_vec_masking
(
)
{
let
b
=
BitVec
:
:
from_elem
(
140
true
)
;
let
mut
bs
=
BitSet
:
:
from_bit_vec
(
b
)
;
assert
!
(
bs
.
contains
(
139
)
)
;
assert
!
(
!
bs
.
contains
(
140
)
)
;
assert
!
(
bs
.
insert
(
150
)
)
;
assert
!
(
!
bs
.
contains
(
140
)
)
;
assert
!
(
!
bs
.
contains
(
149
)
)
;
assert
!
(
bs
.
contains
(
150
)
)
;
assert
!
(
!
bs
.
contains
(
151
)
)
;
}
#
[
test
]
fn
test_bit_set_basic
(
)
{
let
mut
b
=
BitSet
:
:
new
(
)
;
assert
!
(
b
.
insert
(
3
)
)
;
assert
!
(
!
b
.
insert
(
3
)
)
;
assert
!
(
b
.
contains
(
3
)
)
;
assert
!
(
b
.
insert
(
4
)
)
;
assert
!
(
!
b
.
insert
(
4
)
)
;
assert
!
(
b
.
contains
(
3
)
)
;
assert
!
(
b
.
insert
(
400
)
)
;
assert
!
(
!
b
.
insert
(
400
)
)
;
assert
!
(
b
.
contains
(
400
)
)
;
assert_eq
!
(
b
.
len
(
)
3
)
;
}
#
[
test
]
fn
test_bit_set_intersection
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
77
)
)
;
assert
!
(
a
.
insert
(
103
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
b
.
insert
(
2
)
)
;
assert
!
(
b
.
insert
(
11
)
)
;
assert
!
(
b
.
insert
(
77
)
)
;
assert
!
(
b
.
insert
(
5
)
)
;
assert
!
(
b
.
insert
(
3
)
)
;
let
expected
=
[
3
5
11
77
]
;
let
actual
:
Vec
<
_
>
=
a
.
intersection
(
&
b
)
.
collect
(
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_bit_set_difference
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
200
)
)
;
assert
!
(
a
.
insert
(
500
)
)
;
assert
!
(
b
.
insert
(
3
)
)
;
assert
!
(
b
.
insert
(
200
)
)
;
let
expected
=
[
1
5
500
]
;
let
actual
:
Vec
<
_
>
=
a
.
difference
(
&
b
)
.
collect
(
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_bit_set_symmetric_difference
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
9
)
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
b
.
insert
(
3
)
)
;
assert
!
(
b
.
insert
(
9
)
)
;
assert
!
(
b
.
insert
(
14
)
)
;
assert
!
(
b
.
insert
(
220
)
)
;
let
expected
=
[
1
5
11
14
220
]
;
let
actual
:
Vec
<
_
>
=
a
.
symmetric_difference
(
&
b
)
.
collect
(
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_bit_set_union
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
3
)
)
;
assert
!
(
a
.
insert
(
5
)
)
;
assert
!
(
a
.
insert
(
9
)
)
;
assert
!
(
a
.
insert
(
11
)
)
;
assert
!
(
a
.
insert
(
160
)
)
;
assert
!
(
a
.
insert
(
19
)
)
;
assert
!
(
a
.
insert
(
24
)
)
;
assert
!
(
a
.
insert
(
200
)
)
;
assert
!
(
b
.
insert
(
1
)
)
;
assert
!
(
b
.
insert
(
5
)
)
;
assert
!
(
b
.
insert
(
9
)
)
;
assert
!
(
b
.
insert
(
13
)
)
;
assert
!
(
b
.
insert
(
19
)
)
;
let
expected
=
[
1
3
5
9
11
13
19
24
160
200
]
;
let
actual
:
Vec
<
_
>
=
a
.
union
(
&
b
)
.
collect
(
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_bit_set_subset
(
)
{
let
mut
set1
=
BitSet
:
:
new
(
)
;
let
mut
set2
=
BitSet
:
:
new
(
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set2
.
insert
(
100
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set2
.
insert
(
200
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set1
.
insert
(
200
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set1
.
insert
(
300
)
;
assert
!
(
!
set1
.
is_subset
(
&
set2
)
)
;
set2
.
insert
(
300
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set2
.
insert
(
400
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set2
.
remove
(
100
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
set2
.
remove
(
300
)
;
assert
!
(
!
set1
.
is_subset
(
&
set2
)
)
;
set1
.
remove
(
300
)
;
assert
!
(
set1
.
is_subset
(
&
set2
)
)
;
}
#
[
test
]
fn
test_bit_set_is_disjoint
(
)
{
let
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
b
=
BitSet
:
:
from_bytes
(
&
[
0b01000000
]
)
;
let
c
=
BitSet
:
:
new
(
)
;
let
d
=
BitSet
:
:
from_bytes
(
&
[
0b00110000
]
)
;
assert
!
(
!
a
.
is_disjoint
(
&
d
)
)
;
assert
!
(
!
d
.
is_disjoint
(
&
a
)
)
;
assert
!
(
a
.
is_disjoint
(
&
b
)
)
;
assert
!
(
a
.
is_disjoint
(
&
c
)
)
;
assert
!
(
b
.
is_disjoint
(
&
a
)
)
;
assert
!
(
b
.
is_disjoint
(
&
c
)
)
;
assert
!
(
c
.
is_disjoint
(
&
a
)
)
;
assert
!
(
c
.
is_disjoint
(
&
b
)
)
;
}
#
[
test
]
fn
test_bit_set_union_with
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
a
.
insert
(
0
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
b
.
insert
(
5
)
;
let
expected
=
BitSet
:
:
from_bytes
(
&
[
0b10000100
]
)
;
a
.
union_with
(
&
b
)
;
assert_eq
!
(
a
expected
)
;
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
mut
b
=
BitSet
:
:
from_bytes
(
&
[
0b01100010
]
)
;
let
c
=
a
.
clone
(
)
;
a
.
union_with
(
&
b
)
;
b
.
union_with
(
&
c
)
;
assert_eq
!
(
a
.
len
(
)
4
)
;
assert_eq
!
(
b
.
len
(
)
4
)
;
}
#
[
test
]
fn
test_bit_set_intersect_with
(
)
{
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
mut
b
=
BitSet
:
:
from_bytes
(
&
[
0b00000000
]
)
;
let
c
=
a
.
clone
(
)
;
a
.
intersect_with
(
&
b
)
;
b
.
intersect_with
(
&
c
)
;
assert
!
(
a
.
is_empty
(
)
)
;
assert
!
(
b
.
is_empty
(
)
)
;
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
let
c
=
a
.
clone
(
)
;
a
.
intersect_with
(
&
b
)
;
b
.
intersect_with
(
&
c
)
;
assert
!
(
a
.
is_empty
(
)
)
;
assert
!
(
b
.
is_empty
(
)
)
;
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
mut
b
=
BitSet
:
:
from_bytes
(
&
[
0b01100010
]
)
;
let
c
=
a
.
clone
(
)
;
a
.
intersect_with
(
&
b
)
;
b
.
intersect_with
(
&
c
)
;
assert_eq
!
(
a
.
len
(
)
2
)
;
assert_eq
!
(
b
.
len
(
)
2
)
;
}
#
[
test
]
fn
test_bit_set_difference_with
(
)
{
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b00000000
]
)
;
let
b
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
a
.
difference_with
(
&
b
)
;
assert
!
(
a
.
is_empty
(
)
)
;
let
mut
a
=
BitSet
:
:
new
(
)
;
let
b
=
BitSet
:
:
from_bytes
(
&
[
0b11111111
]
)
;
a
.
difference_with
(
&
b
)
;
assert
!
(
a
.
is_empty
(
)
)
;
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
mut
b
=
BitSet
:
:
from_bytes
(
&
[
0b01100010
]
)
;
let
c
=
a
.
clone
(
)
;
a
.
difference_with
(
&
b
)
;
b
.
difference_with
(
&
c
)
;
assert_eq
!
(
a
.
len
(
)
1
)
;
assert_eq
!
(
b
.
len
(
)
1
)
;
}
#
[
test
]
fn
test_bit_set_symmetric_difference_with
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
a
.
insert
(
0
)
;
a
.
insert
(
1
)
;
let
mut
b
=
BitSet
:
:
new
(
)
;
b
.
insert
(
1
)
;
b
.
insert
(
5
)
;
let
expected
=
BitSet
:
:
from_bytes
(
&
[
0b10000100
]
)
;
a
.
symmetric_difference_with
(
&
b
)
;
assert_eq
!
(
a
expected
)
;
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
b
=
BitSet
:
:
new
(
)
;
let
c
=
a
.
clone
(
)
;
a
.
symmetric_difference_with
(
&
b
)
;
assert_eq
!
(
a
c
)
;
let
mut
a
=
BitSet
:
:
from_bytes
(
&
[
0b11100010
]
)
;
let
mut
b
=
BitSet
:
:
from_bytes
(
&
[
0b01101010
]
)
;
let
c
=
a
.
clone
(
)
;
a
.
symmetric_difference_with
(
&
b
)
;
b
.
symmetric_difference_with
(
&
c
)
;
assert_eq
!
(
a
.
len
(
)
2
)
;
assert_eq
!
(
b
.
len
(
)
2
)
;
}
#
[
test
]
fn
test_bit_set_eq
(
)
{
let
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
b
=
BitSet
:
:
from_bytes
(
&
[
0b00000000
]
)
;
let
c
=
BitSet
:
:
new
(
)
;
assert
!
(
a
=
=
a
)
;
assert
!
(
a
!
=
b
)
;
assert
!
(
a
!
=
c
)
;
assert
!
(
b
=
=
b
)
;
assert
!
(
b
=
=
c
)
;
assert
!
(
c
=
=
c
)
;
}
#
[
test
]
fn
test_bit_set_cmp
(
)
{
let
a
=
BitSet
:
:
from_bytes
(
&
[
0b10100010
]
)
;
let
b
=
BitSet
:
:
from_bytes
(
&
[
0b00000000
]
)
;
let
c
=
BitSet
:
:
new
(
)
;
assert_eq
!
(
a
.
cmp
(
&
b
)
Greater
)
;
assert_eq
!
(
a
.
cmp
(
&
c
)
Greater
)
;
assert_eq
!
(
b
.
cmp
(
&
a
)
Less
)
;
assert_eq
!
(
b
.
cmp
(
&
c
)
Equal
)
;
assert_eq
!
(
c
.
cmp
(
&
a
)
Less
)
;
assert_eq
!
(
c
.
cmp
(
&
b
)
Equal
)
;
}
#
[
test
]
fn
test_bit_vec_remove
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
remove
(
1
)
)
;
assert
!
(
a
.
insert
(
100
)
)
;
assert
!
(
a
.
remove
(
100
)
)
;
assert
!
(
a
.
insert
(
1000
)
)
;
assert
!
(
a
.
remove
(
1000
)
)
;
a
.
shrink_to_fit
(
)
;
}
#
[
test
]
fn
test_bit_vec_clone
(
)
{
let
mut
a
=
BitSet
:
:
new
(
)
;
assert
!
(
a
.
insert
(
1
)
)
;
assert
!
(
a
.
insert
(
100
)
)
;
assert
!
(
a
.
insert
(
1000
)
)
;
let
mut
b
=
a
.
clone
(
)
;
assert
!
(
a
=
=
b
)
;
assert
!
(
b
.
remove
(
1
)
)
;
assert
!
(
a
.
contains
(
1
)
)
;
assert
!
(
a
.
remove
(
1000
)
)
;
assert
!
(
b
.
contains
(
1000
)
)
;
}
}
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
mod
bench
{
use
super
:
:
BitSet
;
use
bit_vec
:
:
BitVec
;
use
rand
:
:
{
Rng
thread_rng
ThreadRng
}
;
use
test
:
:
{
Bencher
black_box
}
;
const
BENCH_BITS
:
usize
=
1
<
<
14
;
const
BITS
:
usize
=
32
;
fn
rng
(
)
-
>
ThreadRng
{
thread_rng
(
)
}
#
[
bench
]
fn
bench_bit_vecset_small
(
b
:
&
mut
Bencher
)
{
let
mut
r
=
rng
(
)
;
let
mut
bit_vec
=
BitSet
:
:
new
(
)
;
b
.
iter
(
|
|
{
for
_
in
0
.
.
100
{
bit_vec
.
insert
(
(
r
.
next_u32
(
)
as
usize
)
%
BITS
)
;
}
black_box
(
&
bit_vec
)
;
}
)
;
}
#
[
bench
]
fn
bench_bit_vecset_big
(
b
:
&
mut
Bencher
)
{
let
mut
r
=
rng
(
)
;
let
mut
bit_vec
=
BitSet
:
:
new
(
)
;
b
.
iter
(
|
|
{
for
_
in
0
.
.
100
{
bit_vec
.
insert
(
(
r
.
next_u32
(
)
as
usize
)
%
BENCH_BITS
)
;
}
black_box
(
&
bit_vec
)
;
}
)
;
}
#
[
bench
]
fn
bench_bit_vecset_iter
(
b
:
&
mut
Bencher
)
{
let
bit_vec
=
BitSet
:
:
from_bit_vec
(
BitVec
:
:
from_fn
(
BENCH_BITS
|
idx
|
{
idx
%
3
=
=
0
}
)
)
;
b
.
iter
(
|
|
{
let
mut
sum
=
0
;
for
idx
in
&
bit_vec
{
sum
+
=
idx
as
usize
;
}
sum
}
)
}
}
