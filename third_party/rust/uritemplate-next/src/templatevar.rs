use
std
:
:
collections
:
:
HashMap
;
#
[
derive
(
Clone
)
]
pub
enum
TemplateVar
{
Scalar
(
String
)
List
(
Vec
<
String
>
)
AssociativeArray
(
Vec
<
(
String
String
)
>
)
}
pub
trait
IntoTemplateVar
{
fn
into_template_var
(
self
)
-
>
TemplateVar
;
}
impl
IntoTemplateVar
for
TemplateVar
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
self
.
clone
(
)
}
}
impl
<
'
a
>
IntoTemplateVar
for
&
'
a
str
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
TemplateVar
:
:
Scalar
(
self
.
to_string
(
)
)
}
}
impl
IntoTemplateVar
for
String
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
TemplateVar
:
:
Scalar
(
self
)
}
}
impl
<
'
a
>
IntoTemplateVar
for
&
'
a
[
String
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
s
in
self
{
vec
.
push
(
s
.
clone
(
)
)
;
}
TemplateVar
:
:
List
(
vec
)
}
}
impl
IntoTemplateVar
for
Vec
<
String
>
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
TemplateVar
:
:
List
(
self
)
}
}
impl
<
'
a
'
b
>
IntoTemplateVar
for
&
'
a
[
&
'
b
str
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
s
in
self
{
vec
.
push
(
s
.
to_string
(
)
)
;
}
TemplateVar
:
:
List
(
vec
)
}
}
impl
<
'
a
>
IntoTemplateVar
for
&
'
a
[
(
String
String
)
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
s
in
self
{
vec
.
push
(
s
.
clone
(
)
)
;
}
TemplateVar
:
:
AssociativeArray
(
vec
)
}
}
impl
IntoTemplateVar
for
Vec
<
(
String
String
)
>
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
TemplateVar
:
:
AssociativeArray
(
self
)
}
}
impl
<
'
a
'
b
'
c
>
IntoTemplateVar
for
&
'
a
[
(
&
'
b
str
&
'
c
str
)
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
s
in
self
{
vec
.
push
(
(
s
.
0
.
to_string
(
)
s
.
1
.
to_string
(
)
)
)
;
}
TemplateVar
:
:
AssociativeArray
(
vec
)
}
}
impl
<
'
a
>
IntoTemplateVar
for
&
'
a
HashMap
<
String
String
>
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
(
k
v
)
in
self
{
vec
.
push
(
(
k
.
clone
(
)
v
.
clone
(
)
)
)
;
}
TemplateVar
:
:
AssociativeArray
(
vec
)
}
}
impl
<
'
a
'
b
'
c
>
IntoTemplateVar
for
&
'
a
HashMap
<
&
'
b
str
&
'
c
str
>
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
let
mut
vec
=
Vec
:
:
new
(
)
;
for
(
k
v
)
in
self
{
vec
.
push
(
(
k
.
to_string
(
)
v
.
to_string
(
)
)
)
;
}
TemplateVar
:
:
AssociativeArray
(
vec
)
}
}
macro_rules
!
array_impls
{
(
(
N
:
expr
)
+
)
=
>
{
(
impl
<
'
a
>
IntoTemplateVar
for
&
'
a
[
String
;
N
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
self
[
.
.
]
.
into_template_var
(
)
}
}
impl
<
'
a
'
b
>
IntoTemplateVar
for
&
'
a
[
&
'
b
str
;
N
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
self
[
.
.
]
.
into_template_var
(
)
}
}
impl
<
'
a
>
IntoTemplateVar
for
&
'
a
[
(
String
String
)
;
N
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
self
[
.
.
]
.
into_template_var
(
)
}
}
impl
<
'
a
'
b
'
c
>
IntoTemplateVar
for
&
'
a
[
(
&
'
b
str
&
'
c
str
)
;
N
]
{
fn
into_template_var
(
self
)
-
>
TemplateVar
{
self
[
.
.
]
.
into_template_var
(
)
}
}
)
+
}
}
array_impls
!
(
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
)
;
