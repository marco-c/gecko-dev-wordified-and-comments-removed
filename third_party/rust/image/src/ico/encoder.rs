use
byteorder
:
:
{
LittleEndian
WriteBytesExt
}
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
crate
:
:
color
:
:
ColorType
;
use
crate
:
:
error
:
:
ImageResult
;
use
crate
:
:
image
:
:
ImageEncoder
;
use
crate
:
:
png
:
:
PNGEncoder
;
const
ICO_IMAGE_TYPE
:
u16
=
1
;
const
ICO_ICONDIR_SIZE
:
u32
=
6
;
const
ICO_DIRENTRY_SIZE
:
u32
=
16
;
pub
struct
ICOEncoder
<
W
:
Write
>
{
w
:
W
}
impl
<
W
:
Write
>
ICOEncoder
<
W
>
{
pub
fn
new
(
w
:
W
)
-
>
ICOEncoder
<
W
>
{
ICOEncoder
{
w
}
}
pub
fn
encode
(
mut
self
data
:
&
[
u8
]
width
:
u32
height
:
u32
color
:
ColorType
)
-
>
ImageResult
<
(
)
>
{
let
mut
image_data
:
Vec
<
u8
>
=
Vec
:
:
new
(
)
;
PNGEncoder
:
:
new
(
&
mut
image_data
)
.
encode
(
data
width
height
color
)
?
;
write_icondir
(
&
mut
self
.
w
1
)
?
;
write_direntry
(
&
mut
self
.
w
width
height
color
ICO_ICONDIR_SIZE
+
ICO_DIRENTRY_SIZE
image_data
.
len
(
)
as
u32
)
?
;
self
.
w
.
write_all
(
&
image_data
)
?
;
Ok
(
(
)
)
}
}
impl
<
W
:
Write
>
ImageEncoder
for
ICOEncoder
<
W
>
{
fn
write_image
(
self
buf
:
&
[
u8
]
width
:
u32
height
:
u32
color_type
:
ColorType
)
-
>
ImageResult
<
(
)
>
{
self
.
encode
(
buf
width
height
color_type
)
}
}
fn
write_icondir
<
W
:
Write
>
(
w
:
&
mut
W
num_images
:
u16
)
-
>
io
:
:
Result
<
(
)
>
{
w
.
write_u16
:
:
<
LittleEndian
>
(
0
)
?
;
w
.
write_u16
:
:
<
LittleEndian
>
(
ICO_IMAGE_TYPE
)
?
;
w
.
write_u16
:
:
<
LittleEndian
>
(
num_images
)
?
;
Ok
(
(
)
)
}
fn
write_direntry
<
W
:
Write
>
(
w
:
&
mut
W
width
:
u32
height
:
u32
color
:
ColorType
data_start
:
u32
data_size
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
write_width_or_height
(
w
width
)
?
;
write_width_or_height
(
w
height
)
?
;
w
.
write_u8
(
0
)
?
;
w
.
write_u8
(
0
)
?
;
w
.
write_u16
:
:
<
LittleEndian
>
(
0
)
?
;
w
.
write_u16
:
:
<
LittleEndian
>
(
color
.
bits_per_pixel
(
)
)
?
;
w
.
write_u32
:
:
<
LittleEndian
>
(
data_size
)
?
;
w
.
write_u32
:
:
<
LittleEndian
>
(
data_start
)
?
;
Ok
(
(
)
)
}
fn
write_width_or_height
<
W
:
Write
>
(
w
:
&
mut
W
value
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
if
value
<
1
|
|
value
>
256
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
"
Invalid
ICO
dimensions
(
width
and
\
height
must
be
between
1
and
256
)
"
)
)
;
}
w
.
write_u8
(
if
value
<
256
{
value
as
u8
}
else
{
0
}
)
}
