use
byteorder
:
:
{
NativeEndian
ByteOrder
}
;
use
num_iter
:
:
range_step
;
use
std
:
:
mem
;
use
std
:
:
iter
:
:
repeat
;
#
[
inline
(
always
)
]
pub
(
crate
)
fn
expand_packed
<
F
>
(
buf
:
&
mut
[
u8
]
channels
:
usize
bit_depth
:
u8
mut
func
:
F
)
where
F
:
FnMut
(
u8
&
mut
[
u8
]
)
{
let
pixels
=
buf
.
len
(
)
/
channels
*
bit_depth
as
usize
;
let
extra
=
pixels
%
8
;
let
entries
=
pixels
/
8
+
match
extra
{
0
=
>
0
_
=
>
1
}
;
let
mask
=
(
(
1u16
<
<
bit_depth
)
-
1
)
as
u8
;
let
i
=
(
0
.
.
entries
)
.
rev
(
)
.
flat_map
(
|
idx
|
range_step
(
0
8
bit_depth
)
.
zip
(
repeat
(
idx
)
)
)
.
skip
(
extra
)
;
let
channels
=
channels
as
isize
;
let
j
=
range_step
(
buf
.
len
(
)
as
isize
-
channels
-
channels
-
channels
)
;
for
(
(
shift
i
)
j
)
in
i
.
zip
(
j
)
{
let
pixel
=
(
buf
[
i
]
&
(
mask
<
<
shift
)
)
>
>
shift
;
func
(
pixel
&
mut
buf
[
j
as
usize
.
.
(
j
+
channels
)
as
usize
]
)
}
}
pub
(
crate
)
fn
expand_bits
(
bit_depth
:
u8
row_size
:
u32
buf
:
&
[
u8
]
)
-
>
Vec
<
u8
>
{
let
mask
=
(
1u8
<
<
bit_depth
as
usize
)
-
1
;
let
scaling_factor
=
255
/
(
(
1
<
<
bit_depth
as
usize
)
-
1
)
;
let
bit_width
=
row_size
*
u32
:
:
from
(
bit_depth
)
;
let
skip
=
if
bit_width
%
8
=
=
0
{
0
}
else
{
(
8
-
bit_width
%
8
)
/
u32
:
:
from
(
bit_depth
)
}
;
let
row_len
=
row_size
+
skip
;
let
mut
p
=
Vec
:
:
new
(
)
;
let
mut
i
=
0
;
for
v
in
buf
{
for
shift
in
num_iter
:
:
range_step_inclusive
(
8i8
-
(
bit_depth
as
i8
)
0
-
(
bit_depth
as
i8
)
)
{
if
i
%
(
row_len
as
usize
)
<
(
row_size
as
usize
)
{
let
pixel
=
(
v
&
mask
<
<
shift
as
usize
)
>
>
shift
as
usize
;
p
.
push
(
pixel
*
scaling_factor
)
;
}
i
+
=
1
;
}
}
p
}
pub
(
crate
)
fn
vec_u16_into_u8
(
vec
:
Vec
<
u16
>
)
-
>
Vec
<
u8
>
{
vec_u16_copy_u8
(
&
vec
)
}
pub
(
crate
)
fn
vec_u16_copy_u8
(
vec
:
&
[
u16
]
)
-
>
Vec
<
u8
>
{
let
mut
new
=
vec
!
[
0
;
vec
.
len
(
)
*
mem
:
:
size_of
:
:
<
u16
>
(
)
]
;
NativeEndian
:
:
write_u16_into
(
&
vec
[
.
.
]
&
mut
new
[
.
.
]
)
;
new
}
#
[
derive
(
Clone
Copy
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
NonExhaustiveMarker
{
pub
(
crate
)
_private
:
Empty
}
#
[
derive
(
Clone
Copy
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
(
crate
)
enum
Empty
{
}
#
[
cfg
(
test
)
]
mod
test
{
#
[
test
]
fn
gray_to_luma8_skip
(
)
{
let
check
=
|
bit_depth
w
from
to
|
{
assert_eq
!
(
super
:
:
expand_bits
(
bit_depth
w
from
)
to
)
;
}
;
check
(
1
10
&
[
0b11110000
0b11000000
0b00001111
0b11000000
]
vec
!
[
255
255
255
255
0
0
0
0
255
255
0
0
0
0
255
255
255
255
255
255
]
)
;
check
(
2
5
&
[
0b11110000
0b11000000
0b00001111
0b11000000
]
vec
!
[
255
255
0
0
255
0
0
255
255
255
]
)
;
check
(
2
4
&
[
0b11110000
0b00001111
]
vec
!
[
255
255
0
0
0
0
255
255
]
)
;
check
(
4
1
&
[
0b11110011
0b00001100
]
vec
!
[
255
0
]
)
;
}
}
