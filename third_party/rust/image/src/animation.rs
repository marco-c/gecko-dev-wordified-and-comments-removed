use
std
:
:
iter
:
:
Iterator
;
use
std
:
:
time
:
:
Duration
;
use
num_rational
:
:
Ratio
;
use
crate
:
:
buffer
:
:
RgbaImage
;
use
crate
:
:
error
:
:
ImageResult
;
pub
struct
Frames
<
'
a
>
{
iterator
:
Box
<
dyn
Iterator
<
Item
=
ImageResult
<
Frame
>
>
+
'
a
>
}
impl
<
'
a
>
Frames
<
'
a
>
{
pub
fn
new
(
iterator
:
Box
<
dyn
Iterator
<
Item
=
ImageResult
<
Frame
>
>
+
'
a
>
)
-
>
Self
{
Frames
{
iterator
}
}
pub
fn
collect_frames
(
self
)
-
>
ImageResult
<
Vec
<
Frame
>
>
{
self
.
collect
(
)
}
}
impl
<
'
a
>
Iterator
for
Frames
<
'
a
>
{
type
Item
=
ImageResult
<
Frame
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
ImageResult
<
Frame
>
>
{
self
.
iterator
.
next
(
)
}
}
#
[
derive
(
Clone
)
]
pub
struct
Frame
{
delay
:
Delay
left
:
u32
top
:
u32
buffer
:
RgbaImage
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
PartialOrd
)
]
pub
struct
Delay
{
ratio
:
Ratio
<
u32
>
}
impl
Frame
{
pub
fn
new
(
buffer
:
RgbaImage
)
-
>
Frame
{
Frame
{
delay
:
Delay
:
:
from_ratio
(
Ratio
:
:
from_integer
(
0
)
)
left
:
0
top
:
0
buffer
}
}
pub
fn
from_parts
(
buffer
:
RgbaImage
left
:
u32
top
:
u32
delay
:
Delay
)
-
>
Frame
{
Frame
{
delay
left
top
buffer
}
}
pub
fn
delay
(
&
self
)
-
>
Delay
{
self
.
delay
}
pub
fn
buffer
(
&
self
)
-
>
&
RgbaImage
{
&
self
.
buffer
}
pub
fn
into_buffer
(
self
)
-
>
RgbaImage
{
self
.
buffer
}
pub
fn
left
(
&
self
)
-
>
u32
{
self
.
left
}
pub
fn
top
(
&
self
)
-
>
u32
{
self
.
top
}
}
impl
Delay
{
pub
fn
from_numer_denom_ms
(
numerator
:
u32
denominator
:
u32
)
-
>
Self
{
Delay
{
ratio
:
Ratio
:
:
new_raw
(
numerator
denominator
)
}
}
pub
fn
from_saturating_duration
(
duration
:
Duration
)
-
>
Self
{
const
MILLIS_BOUND
:
u128
=
u32
:
:
max_value
(
)
as
u128
;
let
millis
=
duration
.
as_millis
(
)
.
min
(
MILLIS_BOUND
)
;
let
submillis
=
(
duration
.
as_nanos
(
)
%
1_000_000
)
as
u32
;
let
max_b
=
if
millis
>
0
{
(
(
MILLIS_BOUND
+
1
)
/
(
millis
+
1
)
)
as
u32
}
else
{
MILLIS_BOUND
as
u32
}
;
let
millis
=
millis
as
u32
;
let
(
a
b
)
=
Self
:
:
closest_bounded_fraction
(
max_b
submillis
1_000_000
)
;
Self
:
:
from_numer_denom_ms
(
a
+
b
*
millis
b
)
}
pub
fn
numer_denom_ms
(
self
)
-
>
(
u32
u32
)
{
(
*
self
.
ratio
.
numer
(
)
*
self
.
ratio
.
denom
(
)
)
}
pub
(
crate
)
fn
from_ratio
(
ratio
:
Ratio
<
u32
>
)
-
>
Self
{
Delay
{
ratio
}
}
pub
(
crate
)
fn
into_ratio
(
self
)
-
>
Ratio
<
u32
>
{
self
.
ratio
}
fn
closest_bounded_fraction
(
denom_bound
:
u32
nom
:
u32
denom
:
u32
)
-
>
(
u32
u32
)
{
use
std
:
:
cmp
:
:
Ordering
:
:
{
self
*
}
;
assert
!
(
0
<
denom
)
;
assert
!
(
0
<
denom_bound
)
;
assert
!
(
nom
<
denom
)
;
fn
compare_fraction
(
(
an
ad
)
:
(
u64
u64
)
(
bn
bd
)
:
(
u64
u64
)
)
-
>
Ordering
{
(
an
*
bd
)
.
cmp
(
&
(
bn
*
ad
)
)
}
fn
abs_diff_nom
(
(
an
ad
)
:
(
u64
u64
)
(
bn
bd
)
:
(
u64
u64
)
)
-
>
u64
{
let
c0
=
an
*
bd
;
let
c1
=
ad
*
bn
;
let
d0
=
c0
.
max
(
c1
)
;
let
d1
=
c0
.
min
(
c1
)
;
d0
-
d1
}
let
exact
=
(
u64
:
:
from
(
nom
)
u64
:
:
from
(
denom
)
)
;
let
mut
lower
=
(
0u64
1u64
)
;
let
mut
upper
=
(
1u64
1u64
)
;
let
mut
guess
=
(
u64
:
:
from
(
nom
*
2
>
denom
)
1u64
)
;
loop
{
if
compare_fraction
(
guess
exact
)
=
=
Equal
{
break
;
}
if
u64
:
:
from
(
denom_bound
)
-
lower
.
1
<
upper
.
1
{
break
;
}
let
next
=
(
lower
.
0
+
upper
.
0
lower
.
1
+
upper
.
1
)
;
if
compare_fraction
(
exact
next
)
=
=
Less
{
upper
=
next
;
}
else
{
lower
=
next
;
}
let
g_diff_nom
=
abs_diff_nom
(
guess
exact
)
;
let
n_diff_nom
=
abs_diff_nom
(
next
exact
)
;
if
match
(
n_diff_nom
/
next
.
1
)
.
cmp
(
&
(
g_diff_nom
/
guess
.
1
)
)
{
Less
=
>
true
Greater
=
>
false
Equal
=
>
compare_fraction
(
(
n_diff_nom
%
next
.
1
next
.
1
)
(
g_diff_nom
%
guess
.
1
guess
.
1
)
)
=
=
Less
}
{
guess
=
next
;
}
}
(
guess
.
0
as
u32
guess
.
1
as
u32
)
}
}
impl
From
<
Delay
>
for
Duration
{
fn
from
(
delay
:
Delay
)
-
>
Self
{
let
ratio
=
delay
.
into_ratio
(
)
;
let
ms
=
ratio
.
to_integer
(
)
;
let
rest
=
ratio
.
numer
(
)
%
ratio
.
denom
(
)
;
let
nanos
=
(
u64
:
:
from
(
rest
)
*
1_000_000
)
/
u64
:
:
from
(
*
ratio
.
denom
(
)
)
;
Duration
:
:
from_millis
(
ms
.
into
(
)
)
+
Duration
:
:
from_nanos
(
nanos
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
Delay
Duration
Ratio
}
;
#
[
test
]
fn
simple
(
)
{
let
second
=
Delay
:
:
from_numer_denom_ms
(
1000
1
)
;
assert_eq
!
(
Duration
:
:
from
(
second
)
Duration
:
:
from_secs
(
1
)
)
;
}
#
[
test
]
fn
fps_30
(
)
{
let
thirtieth
=
Delay
:
:
from_numer_denom_ms
(
1000
30
)
;
let
duration
=
Duration
:
:
from
(
thirtieth
)
;
assert_eq
!
(
duration
.
as_secs
(
)
0
)
;
assert_eq
!
(
duration
.
subsec_millis
(
)
33
)
;
assert_eq
!
(
duration
.
subsec_nanos
(
)
33_333_333
)
;
}
#
[
test
]
fn
duration_outlier
(
)
{
let
oob
=
Duration
:
:
from_secs
(
0xFFFF_FFFF
)
;
let
delay
=
Delay
:
:
from_saturating_duration
(
oob
)
;
assert_eq
!
(
delay
.
numer_denom_ms
(
)
(
0xFFFF_FFFF
1
)
)
;
}
#
[
test
]
fn
duration_approx
(
)
{
let
oob
=
Duration
:
:
from_millis
(
0xFFFF_FFFF
)
+
Duration
:
:
from_micros
(
1
)
;
let
delay
=
Delay
:
:
from_saturating_duration
(
oob
)
;
assert_eq
!
(
delay
.
numer_denom_ms
(
)
(
0xFFFF_FFFF
1
)
)
;
let
inbounds
=
Duration
:
:
from_millis
(
0xFFFF_FFFF
)
-
Duration
:
:
from_micros
(
1
)
;
let
delay
=
Delay
:
:
from_saturating_duration
(
inbounds
)
;
assert_eq
!
(
delay
.
numer_denom_ms
(
)
(
0xFFFF_FFFF
1
)
)
;
let
fine
=
Duration
:
:
from_millis
(
0xFFFF_FFFF
/
1000
)
+
Duration
:
:
from_micros
(
0xFFFF_FFFF
%
1000
)
;
let
delay
=
Delay
:
:
from_saturating_duration
(
fine
)
;
assert_eq
!
(
delay
.
into_ratio
(
)
Ratio
:
:
new
(
0xFFFF_FFFF
1000
)
)
;
}
#
[
test
]
fn
precise
(
)
{
let
exceed
=
Duration
:
:
from_secs
(
333
)
+
Duration
:
:
from_nanos
(
333_333_333
)
;
let
delay
=
Delay
:
:
from_saturating_duration
(
exceed
)
;
assert_eq
!
(
Duration
:
:
from
(
delay
)
exceed
)
;
}
#
[
test
]
fn
small
(
)
{
let
delay
=
Delay
:
:
from_numer_denom_ms
(
1
<
<
16
(
1
<
<
16
)
+
1
)
;
let
duration
=
Duration
:
:
from
(
delay
)
;
assert_eq
!
(
duration
.
as_millis
(
)
0
)
;
let
delay
=
Delay
:
:
from_saturating_duration
(
duration
)
;
assert_eq
!
(
delay
.
into_ratio
(
)
.
to_integer
(
)
0
)
;
}
}
