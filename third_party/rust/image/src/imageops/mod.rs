use
std
:
:
cmp
;
use
crate
:
:
image
:
:
{
GenericImage
GenericImageView
SubImage
}
;
use
crate
:
:
buffer
:
:
Pixel
;
pub
use
self
:
:
sample
:
:
FilterType
;
pub
use
self
:
:
sample
:
:
FilterType
:
:
{
CatmullRom
Gaussian
Lanczos3
Nearest
Triangle
}
;
pub
use
self
:
:
affine
:
:
{
flip_horizontal
flip_horizontal_in_place
flip_vertical
flip_vertical_in_place
rotate180
rotate180_in_place
rotate270
rotate90
rotate180_in
rotate90_in
rotate270_in
flip_horizontal_in
flip_vertical_in
}
;
pub
use
self
:
:
sample
:
:
{
blur
filter3x3
resize
thumbnail
unsharpen
}
;
pub
use
self
:
:
colorops
:
:
{
brighten
contrast
dither
grayscale
huerotate
index_colors
invert
BiLevel
ColorMap
}
;
mod
affine
;
pub
mod
colorops
;
mod
sample
;
pub
fn
crop
<
I
:
GenericImageView
>
(
image
:
&
mut
I
x
:
u32
y
:
u32
width
:
u32
height
:
u32
)
-
>
SubImage
<
&
mut
I
>
{
let
(
iwidth
iheight
)
=
image
.
dimensions
(
)
;
let
x
=
cmp
:
:
min
(
x
iwidth
)
;
let
y
=
cmp
:
:
min
(
y
iheight
)
;
let
height
=
cmp
:
:
min
(
height
iheight
-
y
)
;
let
width
=
cmp
:
:
min
(
width
iwidth
-
x
)
;
SubImage
:
:
new
(
image
x
y
width
height
)
}
pub
fn
overlay_bounds
(
(
bottom_width
bottom_height
)
:
(
u32
u32
)
(
top_width
top_height
)
:
(
u32
u32
)
x
:
u32
y
:
u32
)
-
>
(
u32
u32
)
{
let
x_range
=
top_width
.
saturating_add
(
x
)
.
min
(
bottom_width
)
.
saturating_sub
(
x
)
;
let
y_range
=
top_height
.
saturating_add
(
y
)
.
min
(
bottom_height
)
.
saturating_sub
(
y
)
;
(
x_range
y_range
)
}
pub
fn
overlay
<
I
J
>
(
bottom
:
&
mut
I
top
:
&
J
x
:
u32
y
:
u32
)
where
I
:
GenericImage
J
:
GenericImageView
<
Pixel
=
I
:
:
Pixel
>
{
let
bottom_dims
=
bottom
.
dimensions
(
)
;
let
top_dims
=
top
.
dimensions
(
)
;
let
(
range_width
range_height
)
=
overlay_bounds
(
bottom_dims
top_dims
x
y
)
;
for
top_y
in
0
.
.
range_height
{
for
top_x
in
0
.
.
range_width
{
let
p
=
top
.
get_pixel
(
top_x
top_y
)
;
let
mut
bottom_pixel
=
bottom
.
get_pixel
(
x
+
top_x
y
+
top_y
)
;
bottom_pixel
.
blend
(
&
p
)
;
bottom
.
put_pixel
(
x
+
top_x
y
+
top_y
bottom_pixel
)
;
}
}
}
pub
fn
replace
<
I
J
>
(
bottom
:
&
mut
I
top
:
&
J
x
:
u32
y
:
u32
)
where
I
:
GenericImage
J
:
GenericImageView
<
Pixel
=
I
:
:
Pixel
>
{
let
bottom_dims
=
bottom
.
dimensions
(
)
;
let
top_dims
=
top
.
dimensions
(
)
;
let
(
range_width
range_height
)
=
overlay_bounds
(
bottom_dims
top_dims
x
y
)
;
for
top_y
in
0
.
.
range_height
{
for
top_x
in
0
.
.
range_width
{
let
p
=
top
.
get_pixel
(
top_x
top_y
)
;
bottom
.
put_pixel
(
x
+
top_x
y
+
top_y
p
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
overlay
;
use
crate
:
:
buffer
:
:
ImageBuffer
;
use
crate
:
:
color
:
:
Rgb
;
#
[
test
]
fn
test_image_in_image
(
)
{
let
mut
target
=
ImageBuffer
:
:
new
(
32
32
)
;
let
source
=
ImageBuffer
:
:
from_pixel
(
16
16
Rgb
(
[
255u8
0
0
]
)
)
;
overlay
(
&
mut
target
&
source
0
0
)
;
assert
!
(
*
target
.
get_pixel
(
0
0
)
=
=
Rgb
(
[
255u8
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
15
0
)
=
=
Rgb
(
[
255u8
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
16
0
)
=
=
Rgb
(
[
0u8
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
0
15
)
=
=
Rgb
(
[
255u8
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
0
16
)
=
=
Rgb
(
[
0u8
0
0
]
)
)
;
}
#
[
test
]
fn
test_image_in_image_outside_of_bounds
(
)
{
let
mut
target
=
ImageBuffer
:
:
new
(
32
32
)
;
let
source
=
ImageBuffer
:
:
from_pixel
(
32
32
Rgb
(
[
255u8
0
0
]
)
)
;
overlay
(
&
mut
target
&
source
1
1
)
;
assert
!
(
*
target
.
get_pixel
(
0
0
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
1
1
)
=
=
Rgb
(
[
255u8
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
31
31
)
=
=
Rgb
(
[
255u8
0
0
]
)
)
;
}
#
[
test
]
fn
test_image_outside_image_no_wrap_around
(
)
{
let
mut
target
=
ImageBuffer
:
:
new
(
32
32
)
;
let
source
=
ImageBuffer
:
:
from_pixel
(
32
32
Rgb
(
[
255u8
0
0
]
)
)
;
overlay
(
&
mut
target
&
source
33
33
)
;
assert
!
(
*
target
.
get_pixel
(
0
0
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
1
1
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
31
31
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
}
#
[
test
]
fn
test_image_coordinate_overflow
(
)
{
let
mut
target
=
ImageBuffer
:
:
new
(
16
16
)
;
let
source
=
ImageBuffer
:
:
from_pixel
(
32
32
Rgb
(
[
255u8
0
0
]
)
)
;
overlay
(
&
mut
target
&
source
u32
:
:
max_value
(
)
-
31
u32
:
:
max_value
(
)
-
31
)
;
assert
!
(
*
target
.
get_pixel
(
0
0
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
1
1
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
assert
!
(
*
target
.
get_pixel
(
15
15
)
=
=
Rgb
(
[
0
0
0
]
)
)
;
}
}
