#
!
[
warn
(
missing_docs
)
]
use
std
:
:
io
;
use
std
:
:
io
:
:
prelude
:
:
*
;
pub
enum
LittleEndian
{
}
pub
enum
BigEndian
{
}
pub
trait
Endianness
{
fn
int_to_target
<
T
:
EndianConvert
>
(
val
:
T
)
-
>
T
;
fn
int_from_target
<
T
:
EndianConvert
>
(
val
:
T
)
-
>
T
;
}
pub
trait
EndianConvert
{
fn
to_be
(
self
)
-
>
Self
;
fn
to_le
(
self
)
-
>
Self
;
fn
from_be
(
x
:
Self
)
-
>
Self
;
fn
from_le
(
x
:
Self
)
-
>
Self
;
}
pub
trait
WritePodExt
{
fn
write_u64
<
T
:
Endianness
>
(
&
mut
self
u64
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_u32
<
T
:
Endianness
>
(
&
mut
self
u32
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_u16
<
T
:
Endianness
>
(
&
mut
self
u16
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_u8
(
&
mut
self
u8
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_i64
<
T
:
Endianness
>
(
&
mut
self
i64
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_i32
<
T
:
Endianness
>
(
&
mut
self
i32
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_i16
<
T
:
Endianness
>
(
&
mut
self
i16
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_i8
(
&
mut
self
i8
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_f32
<
T
:
Endianness
>
(
&
mut
self
f32
)
-
>
io
:
:
Result
<
(
)
>
;
fn
write_f64
<
T
:
Endianness
>
(
&
mut
self
f64
)
-
>
io
:
:
Result
<
(
)
>
;
}
pub
trait
ReadPodExt
{
fn
read_u64
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
u64
>
;
fn
read_u32
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
u32
>
;
fn
read_u16
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
u16
>
;
fn
read_u8
(
&
mut
self
)
-
>
io
:
:
Result
<
u8
>
;
fn
read_i64
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
i64
>
;
fn
read_i32
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
i32
>
;
fn
read_i16
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
i16
>
;
fn
read_i8
(
&
mut
self
)
-
>
io
:
:
Result
<
i8
>
;
fn
read_f32
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
f32
>
;
fn
read_f64
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
f64
>
;
fn
read_exact
(
&
mut
self
usize
)
-
>
io
:
:
Result
<
Vec
<
u8
>
>
;
}
impl
Endianness
for
LittleEndian
{
#
[
inline
]
fn
int_to_target
<
T
:
EndianConvert
>
(
val
:
T
)
-
>
T
{
val
.
to_le
(
)
}
#
[
inline
]
fn
int_from_target
<
T
:
EndianConvert
>
(
val
:
T
)
-
>
T
{
<
T
as
EndianConvert
>
:
:
from_le
(
val
)
}
}
impl
Endianness
for
BigEndian
{
#
[
inline
]
fn
int_to_target
<
T
:
EndianConvert
>
(
val
:
T
)
-
>
T
{
val
.
to_be
(
)
}
#
[
inline
]
fn
int_from_target
<
T
:
EndianConvert
>
(
val
:
T
)
-
>
T
{
<
T
as
EndianConvert
>
:
:
from_be
(
val
)
}
}
macro_rules
!
impl_platform_convert
{
(
T
:
ty
)
=
>
{
impl
EndianConvert
for
T
{
#
[
inline
]
fn
to_be
(
self
)
-
>
T
{
self
.
to_be
(
)
}
#
[
inline
]
fn
to_le
(
self
)
-
>
T
{
self
.
to_le
(
)
}
#
[
inline
]
fn
from_be
(
x
:
T
)
-
>
T
{
if
cfg
!
(
target_endian
=
"
big
"
)
{
x
}
else
{
x
.
swap_bytes
(
)
}
}
#
[
inline
]
fn
from_le
(
x
:
T
)
-
>
T
{
if
cfg
!
(
target_endian
=
"
little
"
)
{
x
}
else
{
x
.
swap_bytes
(
)
}
}
}
}
;
}
impl_platform_convert
!
(
u8
)
;
impl_platform_convert
!
(
u16
)
;
impl_platform_convert
!
(
u32
)
;
impl_platform_convert
!
(
u64
)
;
#
[
cfg
(
target_endian
=
"
little
"
)
]
macro_rules
!
val_to_buf
{
(
val
:
ident
T
:
expr
)
=
>
{
{
let
mut
buf
=
[
0
;
T
]
;
for
i
in
0
.
.
buf
.
len
(
)
{
buf
[
i
]
=
(
val
>
>
(
i
*
8
)
)
as
u8
;
}
buf
}
}
;
}
#
[
cfg
(
target_endian
=
"
big
"
)
]
macro_rules
!
val_to_buf
{
(
val
:
ident
T
:
expr
)
=
>
{
{
let
mut
buf
=
[
0
;
T
]
;
for
i
in
0
.
.
buf
.
len
(
)
{
buf
[
buf
.
len
(
)
-
1
-
i
]
=
(
val
>
>
(
i
*
8
)
)
as
u8
;
}
buf
}
}
;
}
impl
<
W
:
Write
>
WritePodExt
for
W
{
fn
write_u64
<
T
:
Endianness
>
(
&
mut
self
val
:
u64
)
-
>
io
:
:
Result
<
(
)
>
{
let
tval
=
<
T
as
Endianness
>
:
:
int_to_target
(
val
)
;
let
buf
=
val_to_buf
!
(
tval
8
)
;
self
.
write_all
(
&
buf
)
}
fn
write_u32
<
T
:
Endianness
>
(
&
mut
self
val
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
let
tval
=
<
T
as
Endianness
>
:
:
int_to_target
(
val
)
;
let
buf
=
val_to_buf
!
(
tval
4
)
;
self
.
write_all
(
&
buf
)
}
fn
write_u16
<
T
:
Endianness
>
(
&
mut
self
val
:
u16
)
-
>
io
:
:
Result
<
(
)
>
{
let
tval
=
<
T
as
Endianness
>
:
:
int_to_target
(
val
)
;
let
buf
=
val_to_buf
!
(
tval
2
)
;
self
.
write_all
(
&
buf
)
}
fn
write_u8
(
&
mut
self
val
:
u8
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_all
(
&
[
val
]
)
}
fn
write_i64
<
T
:
Endianness
>
(
&
mut
self
val
:
i64
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_u64
:
:
<
T
>
(
val
as
u64
)
}
fn
write_i32
<
T
:
Endianness
>
(
&
mut
self
val
:
i32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_u32
:
:
<
T
>
(
val
as
u32
)
}
fn
write_i16
<
T
:
Endianness
>
(
&
mut
self
val
:
i16
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_u16
:
:
<
T
>
(
val
as
u16
)
}
fn
write_i8
(
&
mut
self
val
:
i8
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_u8
(
val
as
u8
)
}
fn
write_f32
<
T
:
Endianness
>
(
&
mut
self
val
:
f32
)
-
>
io
:
:
Result
<
(
)
>
{
let
tval
:
u32
=
val
.
to_bits
(
)
;
self
.
write_u32
:
:
<
T
>
(
tval
)
}
fn
write_f64
<
T
:
Endianness
>
(
&
mut
self
val
:
f64
)
-
>
io
:
:
Result
<
(
)
>
{
let
tval
:
u64
=
val
.
to_bits
(
)
;
self
.
write_u64
:
:
<
T
>
(
tval
)
}
}
#
[
inline
]
fn
fill_buf
<
R
:
Read
>
(
reader
:
&
mut
R
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
idx
=
0
;
while
idx
!
=
buf
.
len
(
)
{
match
reader
.
read
(
&
mut
buf
[
idx
.
.
]
)
{
Ok
(
0
)
=
>
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
Could
not
read
enough
bytes
"
)
)
Ok
(
v
)
=
>
{
idx
+
=
v
;
}
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
{
}
Err
(
e
)
=
>
return
Err
(
e
)
}
}
Ok
(
(
)
)
}
#
[
cfg
(
target_endian
=
"
little
"
)
]
macro_rules
!
buf_to_val
{
(
buf
:
ident
T
:
ty
)
=
>
{
{
let
mut
val
:
T
=
0
;
for
i
in
0
.
.
buf
.
len
(
)
{
val
|
=
(
buf
[
i
]
as
T
)
<
<
(
i
*
8
)
;
}
val
}
}
;
}
#
[
cfg
(
target_endian
=
"
big
"
)
]
macro_rules
!
buf_to_val
{
(
buf
:
ident
T
:
ty
)
=
>
{
{
let
mut
val
:
T
=
0
;
for
i
in
0
.
.
buf
.
len
(
)
{
val
|
=
(
buf
[
buf
.
len
(
)
-
1
-
i
]
as
T
)
<
<
(
i
*
8
)
;
}
val
}
}
;
}
impl
<
R
:
Read
>
ReadPodExt
for
R
{
fn
read_u64
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
u64
>
{
let
buf
=
&
mut
[
0u8
;
8
]
;
try
!
(
fill_buf
(
self
buf
)
)
;
let
tval
=
buf_to_val
!
(
buf
u64
)
;
Ok
(
<
T
as
Endianness
>
:
:
int_from_target
(
tval
)
)
}
fn
read_u32
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
u32
>
{
let
buf
=
&
mut
[
0u8
;
4
]
;
try
!
(
fill_buf
(
self
buf
)
)
;
let
tval
=
buf_to_val
!
(
buf
u32
)
;
Ok
(
<
T
as
Endianness
>
:
:
int_from_target
(
tval
)
)
}
fn
read_u16
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
u16
>
{
let
buf
=
&
mut
[
0u8
;
2
]
;
try
!
(
fill_buf
(
self
buf
)
)
;
let
tval
=
buf_to_val
!
(
buf
u16
)
;
Ok
(
<
T
as
Endianness
>
:
:
int_from_target
(
tval
)
)
}
fn
read_u8
(
&
mut
self
)
-
>
io
:
:
Result
<
u8
>
{
let
buf
=
&
mut
[
0u8
;
1
]
;
try
!
(
fill_buf
(
self
buf
)
)
;
Ok
(
buf
[
0
]
)
}
fn
read_i64
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
i64
>
{
self
.
read_u64
:
:
<
T
>
(
)
.
map
(
|
v
|
v
as
i64
)
}
fn
read_i32
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
i32
>
{
self
.
read_u32
:
:
<
T
>
(
)
.
map
(
|
v
|
v
as
i32
)
}
fn
read_i16
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
i16
>
{
self
.
read_u16
:
:
<
T
>
(
)
.
map
(
|
v
|
v
as
i16
)
}
fn
read_i8
(
&
mut
self
)
-
>
io
:
:
Result
<
i8
>
{
self
.
read_u8
(
)
.
map
(
|
v
|
v
as
i8
)
}
fn
read_f64
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
f64
>
{
self
.
read_u64
:
:
<
T
>
(
)
.
map
(
|
v
|
f64
:
:
from_bits
(
v
)
)
}
fn
read_f32
<
T
:
Endianness
>
(
&
mut
self
)
-
>
io
:
:
Result
<
f32
>
{
self
.
read_u32
:
:
<
T
>
(
)
.
map
(
|
v
|
f32
:
:
from_bits
(
v
)
)
}
fn
read_exact
(
&
mut
self
len
:
usize
)
-
>
io
:
:
Result
<
Vec
<
u8
>
>
{
let
mut
res
=
vec
!
[
0
;
len
]
;
try
!
(
fill_buf
(
self
&
mut
res
)
)
;
Ok
(
res
)
}
}
