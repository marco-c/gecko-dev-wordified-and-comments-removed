use
crate
:
:
data_model
:
:
CDataModel
;
use
crate
:
:
parse_error
:
:
ParseError
;
use
crate
:
:
targets
:
:
{
default_binary_format
Architecture
ArmArchitecture
BinaryFormat
Environment
OperatingSystem
Vendor
}
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
alloc
:
:
borrow
:
:
ToOwned
;
use
core
:
:
fmt
;
use
core
:
:
str
:
:
FromStr
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
Endianness
{
Little
Big
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
allow
(
missing_docs
)
]
pub
enum
PointerWidth
{
U16
U32
U64
}
impl
PointerWidth
{
pub
fn
bits
(
self
)
-
>
u8
{
match
self
{
PointerWidth
:
:
U16
=
>
16
PointerWidth
:
:
U32
=
>
32
PointerWidth
:
:
U64
=
>
64
}
}
pub
fn
bytes
(
self
)
-
>
u8
{
match
self
{
PointerWidth
:
:
U16
=
>
2
PointerWidth
:
:
U32
=
>
4
PointerWidth
:
:
U64
=
>
8
}
}
}
#
[
cfg_attr
(
feature
=
"
rust_1_40
"
non_exhaustive
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
enum
CallingConvention
{
SystemV
WasmBasicCAbi
WindowsFastcall
AppleAarch64
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
Triple
{
pub
architecture
:
Architecture
pub
vendor
:
Vendor
pub
operating_system
:
OperatingSystem
pub
environment
:
Environment
pub
binary_format
:
BinaryFormat
}
impl
Triple
{
pub
fn
endianness
(
&
self
)
-
>
Result
<
Endianness
(
)
>
{
self
.
architecture
.
endianness
(
)
}
pub
fn
pointer_width
(
&
self
)
-
>
Result
<
PointerWidth
(
)
>
{
self
.
architecture
.
pointer_width
(
)
}
pub
fn
default_calling_convention
(
&
self
)
-
>
Result
<
CallingConvention
(
)
>
{
Ok
(
match
self
.
operating_system
{
OperatingSystem
:
:
Darwin
|
OperatingSystem
:
:
Ios
|
OperatingSystem
:
:
Tvos
|
OperatingSystem
:
:
MacOSX
{
.
.
}
=
>
match
self
.
architecture
{
Architecture
:
:
Aarch64
(
_
)
=
>
CallingConvention
:
:
AppleAarch64
_
=
>
CallingConvention
:
:
SystemV
}
OperatingSystem
:
:
Bitrig
|
OperatingSystem
:
:
Cloudabi
|
OperatingSystem
:
:
Dragonfly
|
OperatingSystem
:
:
Freebsd
|
OperatingSystem
:
:
Fuchsia
|
OperatingSystem
:
:
Haiku
|
OperatingSystem
:
:
Hermit
|
OperatingSystem
:
:
L4re
|
OperatingSystem
:
:
Linux
|
OperatingSystem
:
:
Netbsd
|
OperatingSystem
:
:
Openbsd
|
OperatingSystem
:
:
Redox
|
OperatingSystem
:
:
Solaris
=
>
CallingConvention
:
:
SystemV
OperatingSystem
:
:
Windows
=
>
CallingConvention
:
:
WindowsFastcall
OperatingSystem
:
:
Nebulet
|
OperatingSystem
:
:
Emscripten
|
OperatingSystem
:
:
Wasi
|
OperatingSystem
:
:
Unknown
=
>
match
self
.
architecture
{
Architecture
:
:
Wasm32
=
>
CallingConvention
:
:
WasmBasicCAbi
_
=
>
return
Err
(
(
)
)
}
_
=
>
return
Err
(
(
)
)
}
)
}
pub
fn
data_model
(
&
self
)
-
>
Result
<
CDataModel
(
)
>
{
match
self
.
pointer_width
(
)
?
{
PointerWidth
:
:
U64
=
>
{
if
self
.
operating_system
=
=
OperatingSystem
:
:
Windows
{
Ok
(
CDataModel
:
:
LLP64
)
}
else
if
self
.
default_calling_convention
(
)
=
=
Ok
(
CallingConvention
:
:
SystemV
)
|
|
self
.
architecture
=
=
Architecture
:
:
Wasm64
{
Ok
(
CDataModel
:
:
LP64
)
}
else
{
Err
(
(
)
)
}
}
PointerWidth
:
:
U32
=
>
{
if
self
.
operating_system
=
=
OperatingSystem
:
:
Windows
|
|
self
.
default_calling_convention
(
)
=
=
Ok
(
CallingConvention
:
:
SystemV
)
|
|
self
.
architecture
=
=
Architecture
:
:
Wasm32
{
Ok
(
CDataModel
:
:
ILP32
)
}
else
{
Err
(
(
)
)
}
}
PointerWidth
:
:
U16
=
>
Err
(
(
)
)
}
}
pub
fn
unknown
(
)
-
>
Self
{
Self
{
architecture
:
Architecture
:
:
Unknown
vendor
:
Vendor
:
:
Unknown
operating_system
:
OperatingSystem
:
:
Unknown
environment
:
Environment
:
:
Unknown
binary_format
:
BinaryFormat
:
:
Unknown
}
}
}
impl
fmt
:
:
Display
for
Triple
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
implied_binary_format
=
default_binary_format
(
&
self
)
;
write
!
(
f
"
{
}
"
self
.
architecture
)
?
;
if
self
.
vendor
=
=
Vendor
:
:
Unknown
&
&
(
self
.
environment
!
=
Environment
:
:
HermitKernel
&
&
self
.
environment
!
=
Environment
:
:
LinuxKernel
)
&
&
(
(
self
.
operating_system
=
=
OperatingSystem
:
:
Linux
&
&
(
self
.
environment
=
=
Environment
:
:
Android
|
|
self
.
environment
=
=
Environment
:
:
Androideabi
|
|
self
.
environment
=
=
Environment
:
:
Kernel
)
)
|
|
self
.
operating_system
=
=
OperatingSystem
:
:
Fuchsia
|
|
self
.
operating_system
=
=
OperatingSystem
:
:
Wasi
|
|
(
self
.
operating_system
=
=
OperatingSystem
:
:
None_
&
&
(
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Armebv7r
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Armv7a
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Armv7r
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Thumbv4t
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Thumbv6m
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Thumbv7em
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Thumbv7m
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Thumbv8mBase
)
|
|
self
.
architecture
=
=
Architecture
:
:
Arm
(
ArmArchitecture
:
:
Thumbv8mMain
)
|
|
self
.
architecture
=
=
Architecture
:
:
Msp430
|
|
self
.
architecture
=
=
Architecture
:
:
X86_64
)
)
)
{
write
!
(
f
"
-
{
}
"
self
.
operating_system
)
?
;
}
else
{
write
!
(
f
"
-
{
}
-
{
}
"
self
.
vendor
self
.
operating_system
)
?
;
}
if
self
.
environment
!
=
Environment
:
:
Unknown
{
write
!
(
f
"
-
{
}
"
self
.
environment
)
?
;
}
if
self
.
binary_format
!
=
implied_binary_format
{
write
!
(
f
"
-
{
}
"
self
.
binary_format
)
?
;
}
Ok
(
(
)
)
}
}
impl
FromStr
for
Triple
{
type
Err
=
ParseError
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
let
mut
parts
=
s
.
split
(
'
-
'
)
;
let
mut
result
=
Self
:
:
unknown
(
)
;
let
mut
current_part
;
current_part
=
parts
.
next
(
)
;
if
let
Some
(
s
)
=
current_part
{
if
let
Ok
(
architecture
)
=
Architecture
:
:
from_str
(
s
)
{
result
.
architecture
=
architecture
;
current_part
=
parts
.
next
(
)
;
}
else
{
return
Err
(
ParseError
:
:
UnrecognizedArchitecture
(
s
.
to_owned
(
)
)
)
;
}
}
let
mut
has_vendor
=
false
;
let
mut
has_operating_system
=
false
;
if
let
Some
(
s
)
=
current_part
{
if
let
Ok
(
vendor
)
=
Vendor
:
:
from_str
(
s
)
{
has_vendor
=
true
;
result
.
vendor
=
vendor
;
current_part
=
parts
.
next
(
)
;
}
}
if
!
has_operating_system
{
if
let
Some
(
s
)
=
current_part
{
if
let
Ok
(
operating_system
)
=
OperatingSystem
:
:
from_str
(
s
)
{
has_operating_system
=
true
;
result
.
operating_system
=
operating_system
;
current_part
=
parts
.
next
(
)
;
}
}
}
let
mut
has_environment
=
false
;
if
let
Some
(
s
)
=
current_part
{
if
let
Ok
(
environment
)
=
Environment
:
:
from_str
(
s
)
{
has_environment
=
true
;
result
.
environment
=
environment
;
current_part
=
parts
.
next
(
)
;
}
}
let
mut
has_binary_format
=
false
;
if
let
Some
(
s
)
=
current_part
{
if
let
Ok
(
binary_format
)
=
BinaryFormat
:
:
from_str
(
s
)
{
has_binary_format
=
true
;
result
.
binary_format
=
binary_format
;
current_part
=
parts
.
next
(
)
;
}
}
if
!
has_binary_format
{
result
.
binary_format
=
default_binary_format
(
&
result
)
;
}
if
let
Some
(
s
)
=
current_part
{
Err
(
if
!
has_vendor
&
&
!
has_operating_system
&
&
!
has_environment
&
&
!
has_binary_format
{
ParseError
:
:
UnrecognizedVendor
(
s
.
to_owned
(
)
)
}
else
if
!
has_operating_system
&
&
!
has_environment
&
&
!
has_binary_format
{
ParseError
:
:
UnrecognizedOperatingSystem
(
s
.
to_owned
(
)
)
}
else
if
!
has_environment
&
&
!
has_binary_format
{
ParseError
:
:
UnrecognizedEnvironment
(
s
.
to_owned
(
)
)
}
else
if
!
has_binary_format
{
ParseError
:
:
UnrecognizedBinaryFormat
(
s
.
to_owned
(
)
)
}
else
{
ParseError
:
:
UnrecognizedField
(
s
.
to_owned
(
)
)
}
)
}
else
{
Ok
(
result
)
}
}
}
#
[
macro_export
]
macro_rules
!
triple
{
(
str
:
tt
)
=
>
{
target_lexicon
:
:
Triple
:
:
from_str
(
str
)
.
expect
(
"
invalid
triple
literal
"
)
}
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
parse_errors
(
)
{
assert_eq
!
(
Triple
:
:
from_str
(
"
"
)
Err
(
ParseError
:
:
UnrecognizedArchitecture
(
"
"
.
to_owned
(
)
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
foo
"
)
Err
(
ParseError
:
:
UnrecognizedArchitecture
(
"
foo
"
.
to_owned
(
)
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
foo
"
)
Err
(
ParseError
:
:
UnrecognizedOperatingSystem
(
"
foo
"
.
to_owned
(
)
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
unknown
-
foo
"
)
Err
(
ParseError
:
:
UnrecognizedEnvironment
(
"
foo
"
.
to_owned
(
)
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
unknown
-
unknown
-
foo
"
)
Err
(
ParseError
:
:
UnrecognizedBinaryFormat
(
"
foo
"
.
to_owned
(
)
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
unknown
-
unknown
-
unknown
-
foo
"
)
Err
(
ParseError
:
:
UnrecognizedField
(
"
foo
"
.
to_owned
(
)
)
)
)
;
}
#
[
test
]
fn
defaults
(
)
{
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
unknown
"
)
Ok
(
Triple
:
:
unknown
(
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
unknown
-
unknown
"
)
Ok
(
Triple
:
:
unknown
(
)
)
)
;
assert_eq
!
(
Triple
:
:
from_str
(
"
unknown
-
unknown
-
unknown
-
unknown
-
unknown
"
)
Ok
(
Triple
:
:
unknown
(
)
)
)
;
}
#
[
test
]
fn
unknown_properties
(
)
{
assert_eq
!
(
Triple
:
:
unknown
(
)
.
endianness
(
)
Err
(
(
)
)
)
;
assert_eq
!
(
Triple
:
:
unknown
(
)
.
pointer_width
(
)
Err
(
(
)
)
)
;
assert_eq
!
(
Triple
:
:
unknown
(
)
.
default_calling_convention
(
)
Err
(
(
)
)
)
;
}
#
[
test
]
fn
apple_calling_convention
(
)
{
for
triple
in
&
[
"
aarch64
-
apple
-
darwin
"
"
aarch64
-
apple
-
ios
"
"
aarch64
-
apple
-
ios
-
macabi
"
"
aarch64
-
apple
-
tvos
"
]
{
assert_eq
!
(
Triple
:
:
from_str
(
triple
)
.
unwrap
(
)
.
default_calling_convention
(
)
.
unwrap
(
)
CallingConvention
:
:
AppleAarch64
)
;
}
for
triple
in
&
[
"
aarch64
-
linux
-
android
"
"
x86_64
-
apple
-
ios
"
]
{
assert_eq
!
(
Triple
:
:
from_str
(
triple
)
.
unwrap
(
)
.
default_calling_convention
(
)
.
unwrap
(
)
CallingConvention
:
:
SystemV
)
;
}
}
}
