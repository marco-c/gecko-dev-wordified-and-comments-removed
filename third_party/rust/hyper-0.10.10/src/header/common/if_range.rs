use
std
:
:
fmt
:
:
{
self
Display
}
;
use
header
:
:
{
self
Header
HeaderFormat
EntityTag
HttpDate
}
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
IfRange
{
EntityTag
(
EntityTag
)
Date
(
HttpDate
)
}
impl
Header
for
IfRange
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
If
-
Range
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
:
:
Result
<
IfRange
>
{
let
etag
:
:
:
Result
<
EntityTag
>
=
header
:
:
parsing
:
:
from_one_raw_str
(
raw
)
;
if
etag
.
is_ok
(
)
{
return
Ok
(
IfRange
:
:
EntityTag
(
etag
.
unwrap
(
)
)
)
;
}
let
date
:
:
:
Result
<
HttpDate
>
=
header
:
:
parsing
:
:
from_one_raw_str
(
raw
)
;
if
date
.
is_ok
(
)
{
return
Ok
(
IfRange
:
:
Date
(
date
.
unwrap
(
)
)
)
;
}
Err
(
:
:
Error
:
:
Header
)
}
}
impl
HeaderFormat
for
IfRange
{
fn
fmt_header
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
match
*
self
{
IfRange
:
:
EntityTag
(
ref
x
)
=
>
Display
:
:
fmt
(
x
f
)
IfRange
:
:
Date
(
ref
x
)
=
>
Display
:
:
fmt
(
x
f
)
}
}
}
impl
Display
for
IfRange
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
fmt_header
(
f
)
}
}
#
[
cfg
(
test
)
]
mod
test_if_range
{
use
std
:
:
str
;
use
header
:
:
*
;
use
super
:
:
IfRange
as
HeaderField
;
test_header
!
(
test1
vec
!
[
b
"
Sat
29
Oct
1994
19
:
43
:
31
GMT
"
]
)
;
test_header
!
(
test2
vec
!
[
b
"
\
"
xyzzy
\
"
"
]
)
;
test_header
!
(
test3
vec
!
[
b
"
this
-
is
-
invalid
"
]
None
:
:
<
IfRange
>
)
;
}
