use
std
:
:
ptr
;
pub
struct
VecAllocation
<
'
a
T
:
'
a
>
{
vec
:
&
'
a
mut
Vec
<
T
>
index
:
usize
}
impl
<
'
a
T
>
VecAllocation
<
'
a
T
>
{
#
[
inline
(
always
)
]
pub
fn
init
(
self
value
:
T
)
-
>
usize
{
unsafe
{
ptr
:
:
write
(
self
.
vec
.
as_mut_ptr
(
)
.
add
(
self
.
index
)
value
)
;
self
.
vec
.
set_len
(
self
.
index
+
1
)
;
}
self
.
index
}
}
pub
enum
VecEntry
<
'
a
T
:
'
a
>
{
Vacant
(
VecAllocation
<
'
a
T
>
)
Occupied
(
&
'
a
mut
T
)
}
impl
<
'
a
T
>
VecEntry
<
'
a
T
>
{
#
[
inline
(
always
)
]
pub
fn
set
(
self
value
:
T
)
{
match
self
{
VecEntry
:
:
Vacant
(
alloc
)
=
>
{
alloc
.
init
(
value
)
;
}
VecEntry
:
:
Occupied
(
slot
)
=
>
{
*
slot
=
value
;
}
}
}
}
pub
trait
VecHelper
<
T
>
{
fn
alloc
(
&
mut
self
)
-
>
VecAllocation
<
T
>
;
fn
entry
(
&
mut
self
index
:
usize
)
-
>
VecEntry
<
T
>
;
}
impl
<
T
>
VecHelper
<
T
>
for
Vec
<
T
>
{
fn
alloc
(
&
mut
self
)
-
>
VecAllocation
<
T
>
{
let
index
=
self
.
len
(
)
;
if
self
.
capacity
(
)
=
=
index
{
self
.
reserve
(
1
)
;
}
VecAllocation
{
vec
:
self
index
}
}
fn
entry
(
&
mut
self
index
:
usize
)
-
>
VecEntry
<
T
>
{
if
index
<
self
.
len
(
)
{
VecEntry
:
:
Occupied
(
unsafe
{
self
.
get_unchecked_mut
(
index
)
}
)
}
else
{
assert_eq
!
(
index
self
.
len
(
)
)
;
VecEntry
:
:
Vacant
(
self
.
alloc
(
)
)
}
}
}
