#
!
[
allow
(
non_camel_case_types
)
]
#
!
[
allow
(
unused_unsafe
)
]
use
crate
:
:
ctx
:
:
WasiCtx
;
use
crate
:
:
host
;
use
lucet_runtime
:
:
vmctx
:
:
Vmctx
;
use
nix
:
:
libc
:
:
{
self
c_long
}
;
use
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
{
OsStrExt
OsStringExt
RawFd
}
;
#
[
cfg
(
target_os
=
"
linux
"
)
]
pub
const
O_RSYNC
:
nix
:
:
fcntl
:
:
OFlag
=
nix
:
:
fcntl
:
:
OFlag
:
:
O_RSYNC
;
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
pub
const
O_RSYNC
:
nix
:
:
fcntl
:
:
OFlag
=
nix
:
:
fcntl
:
:
OFlag
:
:
O_SYNC
;
pub
fn
path_get
<
P
:
AsRef
<
OsStr
>
>
(
vmctx
:
&
Vmctx
dirfd
:
host
:
:
__wasi_fd_t
dirflags
:
host
:
:
__wasi_lookupflags_t
path
:
P
needed_base
:
host
:
:
__wasi_rights_t
needed_inheriting
:
host
:
:
__wasi_rights_t
needs_final_component
:
bool
)
-
>
Result
<
(
RawFd
OsString
)
host
:
:
__wasi_errno_t
>
{
use
nix
:
:
errno
:
:
Errno
;
use
nix
:
:
fcntl
:
:
{
openat
readlinkat
OFlag
}
;
use
nix
:
:
sys
:
:
stat
:
:
Mode
;
const
MAX_SYMLINK_EXPANSIONS
:
usize
=
128
;
fn
ret_dir_success
(
dir_stack
:
&
mut
Vec
<
RawFd
>
)
-
>
RawFd
{
let
ret_dir
=
dir_stack
.
pop
(
)
.
expect
(
"
there
is
always
a
dirfd
to
return
"
)
;
if
let
Some
(
dirfds
)
=
dir_stack
.
get
(
1
.
.
)
{
for
dirfd
in
dirfds
{
nix
:
:
unistd
:
:
close
(
*
dirfd
)
.
unwrap_or_else
(
|
e
|
{
dbg
!
(
e
)
;
}
)
;
}
}
ret_dir
}
fn
ret_error
(
dir_stack
:
&
mut
Vec
<
RawFd
>
errno
:
host
:
:
__wasi_errno_t
)
-
>
Result
<
(
RawFd
OsString
)
host
:
:
__wasi_errno_t
>
{
if
let
Some
(
dirfds
)
=
dir_stack
.
get
(
1
.
.
)
{
for
dirfd
in
dirfds
{
nix
:
:
unistd
:
:
close
(
*
dirfd
)
.
unwrap_or_else
(
|
e
|
{
dbg
!
(
e
)
;
}
)
;
}
}
Err
(
errno
)
}
let
ctx
=
vmctx
.
get_embed_ctx
:
:
<
WasiCtx
>
(
)
;
let
dirfe
=
ctx
.
get_fd_entry
(
dirfd
needed_base
needed_inheriting
)
?
;
let
mut
dir_stack
=
vec
!
[
dirfe
.
fd_object
.
rawfd
]
;
let
mut
path_stack
=
vec
!
[
path
.
as_ref
(
)
.
to_owned
(
)
.
into_vec
(
)
]
;
let
mut
symlink_expansions
=
0
;
let
mut
readlink_buf
=
vec
!
[
0u8
;
libc
:
:
PATH_MAX
as
usize
+
1
]
;
loop
{
let
component
=
if
let
Some
(
cur_path
)
=
path_stack
.
pop
(
)
{
let
mut
split
=
cur_path
.
splitn
(
2
|
&
c
|
c
=
=
b
'
/
'
)
;
let
head
=
split
.
next
(
)
;
let
tail
=
split
.
next
(
)
;
match
(
head
tail
)
{
(
None
_
)
=
>
{
panic
!
(
"
unreachable
"
)
;
}
(
Some
(
[
]
)
None
)
=
>
{
return
ret_error
(
&
mut
dir_stack
host
:
:
__WASI_ENOENT
as
host
:
:
__wasi_errno_t
)
;
}
(
Some
(
[
]
)
Some
(
_
)
)
=
>
{
return
ret_error
(
&
mut
dir_stack
host
:
:
__WASI_ENOTCAPABLE
as
host
:
:
__wasi_errno_t
)
;
}
(
Some
(
component
)
None
)
=
>
component
.
to_vec
(
)
(
Some
(
component
)
Some
(
rest
)
)
=
>
{
if
rest
.
iter
(
)
.
all
(
|
&
c
|
c
=
=
b
'
/
'
)
{
let
mut
component
=
component
.
to_vec
(
)
;
component
.
push
(
'
/
'
as
u8
)
;
component
}
else
{
path_stack
.
push
(
rest
.
to_vec
(
)
)
;
component
.
to_vec
(
)
}
}
}
}
else
{
panic
!
(
"
unreachable
"
)
;
}
;
match
component
.
as_slice
(
)
{
b
"
.
"
=
>
{
}
b
"
.
.
"
=
>
{
let
dirfd
=
dir_stack
.
pop
(
)
.
expect
(
"
dir_stack
is
never
empty
"
)
;
if
dir_stack
.
is_empty
(
)
{
return
ret_error
(
&
mut
dir_stack
host
:
:
__WASI_ENOTCAPABLE
as
host
:
:
__wasi_errno_t
)
;
}
else
{
nix
:
:
unistd
:
:
close
(
dirfd
)
.
unwrap_or_else
(
|
e
|
{
dbg
!
(
e
)
;
}
)
;
}
}
component
if
!
path_stack
.
is_empty
(
)
|
|
(
component
.
ends_with
(
b
"
/
"
)
&
&
!
needs_final_component
)
=
>
{
match
openat
(
*
dir_stack
.
last
(
)
.
expect
(
"
dir_stack
is
never
empty
"
)
component
OFlag
:
:
O_RDONLY
|
OFlag
:
:
O_DIRECTORY
|
OFlag
:
:
O_NOFOLLOW
Mode
:
:
empty
(
)
)
{
Ok
(
new_dir
)
=
>
{
dir_stack
.
push
(
new_dir
)
;
continue
;
}
Err
(
e
)
if
e
.
as_errno
(
)
=
=
Some
(
Errno
:
:
ELOOP
)
|
|
e
.
as_errno
(
)
=
=
Some
(
Errno
:
:
EMLINK
)
|
|
e
.
as_errno
(
)
=
=
Some
(
Errno
:
:
ENOTDIR
)
=
>
{
match
readlinkat
(
*
dir_stack
.
last
(
)
.
expect
(
"
dir_stack
is
never
empty
"
)
component
readlink_buf
.
as_mut_slice
(
)
)
{
Ok
(
link_path
)
=
>
{
symlink_expansions
+
=
1
;
if
symlink_expansions
>
MAX_SYMLINK_EXPANSIONS
{
return
ret_error
(
&
mut
dir_stack
host
:
:
__WASI_ELOOP
as
host
:
:
__wasi_errno_t
)
;
}
let
mut
link_path
=
link_path
.
as_bytes
(
)
.
to_vec
(
)
;
if
component
.
ends_with
(
b
"
/
"
)
{
link_path
.
push
(
b
'
/
'
)
;
}
path_stack
.
push
(
link_path
)
;
continue
;
}
Err
(
e
)
=
>
{
return
ret_error
(
&
mut
dir_stack
host
:
:
errno_from_nix
(
e
.
as_errno
(
)
.
unwrap
(
)
)
)
;
}
}
}
Err
(
e
)
=
>
{
return
ret_error
(
&
mut
dir_stack
host
:
:
errno_from_nix
(
e
.
as_errno
(
)
.
unwrap
(
)
)
)
;
}
}
}
component
=
>
{
if
component
.
ends_with
(
b
"
/
"
)
|
|
(
dirflags
&
host
:
:
__WASI_LOOKUP_SYMLINK_FOLLOW
)
!
=
0
{
match
readlinkat
(
*
dir_stack
.
last
(
)
.
expect
(
"
dir_stack
is
never
empty
"
)
component
readlink_buf
.
as_mut_slice
(
)
)
{
Ok
(
link_path
)
=
>
{
symlink_expansions
+
=
1
;
if
symlink_expansions
>
MAX_SYMLINK_EXPANSIONS
{
return
ret_error
(
&
mut
dir_stack
host
:
:
__WASI_ELOOP
as
host
:
:
__wasi_errno_t
)
;
}
let
mut
link_path
=
link_path
.
as_bytes
(
)
.
to_vec
(
)
;
if
component
.
ends_with
(
b
"
/
"
)
{
link_path
.
push
(
b
'
/
'
)
;
}
path_stack
.
push
(
link_path
)
;
continue
;
}
Err
(
e
)
=
>
{
let
errno
=
e
.
as_errno
(
)
.
unwrap
(
)
;
if
errno
!
=
Errno
:
:
EINVAL
&
&
errno
!
=
Errno
:
:
ENOENT
{
return
ret_error
(
&
mut
dir_stack
host
:
:
errno_from_nix
(
errno
)
)
;
}
}
}
}
return
Ok
(
(
ret_dir_success
(
&
mut
dir_stack
)
OsStr
:
:
from_bytes
(
component
)
.
to_os_string
(
)
)
)
;
}
}
if
path_stack
.
is_empty
(
)
{
return
Ok
(
(
ret_dir_success
(
&
mut
dir_stack
)
OsStr
:
:
new
(
"
.
"
)
.
to_os_string
(
)
)
)
;
}
else
{
continue
;
}
}
}
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
pub
fn
utime_now
(
)
-
>
c_long
{
libc
:
:
UTIME_NOW
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
pub
fn
utime_now
(
)
-
>
c_long
{
-
1
}
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
pub
fn
utime_omit
(
)
-
>
c_long
{
libc
:
:
UTIME_OMIT
}
#
[
cfg
(
target_os
=
"
macos
"
)
]
pub
fn
utime_omit
(
)
-
>
c_long
{
-
2
}
