use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
ops
:
:
Deref
;
use
ansi
:
:
RESET
;
use
difference
:
:
Difference
;
use
style
:
:
{
Style
Colour
}
;
use
write
:
:
AnyWrite
;
#
[
derive
(
PartialEq
Debug
)
]
pub
struct
ANSIGenericString
<
'
a
S
:
'
a
+
ToOwned
+
?
Sized
>
where
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
{
style
:
Style
string
:
Cow
<
'
a
S
>
}
impl
<
'
a
S
:
'
a
+
ToOwned
+
?
Sized
>
Clone
for
ANSIGenericString
<
'
a
S
>
where
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
{
fn
clone
(
&
self
)
-
>
ANSIGenericString
<
'
a
S
>
{
ANSIGenericString
{
style
:
self
.
style
string
:
self
.
string
.
clone
(
)
}
}
}
pub
type
ANSIString
<
'
a
>
=
ANSIGenericString
<
'
a
str
>
;
pub
type
ANSIByteString
<
'
a
>
=
ANSIGenericString
<
'
a
[
u8
]
>
;
impl
<
'
a
I
S
:
'
a
+
ToOwned
+
?
Sized
>
From
<
I
>
for
ANSIGenericString
<
'
a
S
>
where
I
:
Into
<
Cow
<
'
a
S
>
>
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
{
fn
from
(
input
:
I
)
-
>
ANSIGenericString
<
'
a
S
>
{
ANSIGenericString
{
string
:
input
.
into
(
)
style
:
Style
:
:
default
(
)
}
}
}
impl
<
'
a
S
:
'
a
+
ToOwned
+
?
Sized
>
Deref
for
ANSIGenericString
<
'
a
S
>
where
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
{
type
Target
=
S
;
fn
deref
(
&
self
)
-
>
&
S
{
self
.
string
.
deref
(
)
}
}
pub
struct
ANSIGenericStrings
<
'
a
S
:
'
a
+
ToOwned
+
?
Sized
>
(
pub
&
'
a
[
ANSIGenericString
<
'
a
S
>
]
)
where
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
;
pub
type
ANSIStrings
<
'
a
>
=
ANSIGenericStrings
<
'
a
str
>
;
#
[
allow
(
non_snake_case
)
]
pub
fn
ANSIStrings
<
'
a
>
(
arg
:
&
'
a
[
ANSIString
<
'
a
>
]
)
-
>
ANSIStrings
<
'
a
>
{
ANSIGenericStrings
(
arg
)
}
pub
type
ANSIByteStrings
<
'
a
>
=
ANSIGenericStrings
<
'
a
[
u8
]
>
;
#
[
allow
(
non_snake_case
)
]
pub
fn
ANSIByteStrings
<
'
a
>
(
arg
:
&
'
a
[
ANSIByteString
<
'
a
>
]
)
-
>
ANSIByteStrings
<
'
a
>
{
ANSIGenericStrings
(
arg
)
}
impl
Style
{
pub
fn
paint
<
'
a
I
S
:
'
a
+
ToOwned
+
?
Sized
>
(
self
input
:
I
)
-
>
ANSIGenericString
<
'
a
S
>
where
I
:
Into
<
Cow
<
'
a
S
>
>
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
{
ANSIGenericString
{
string
:
input
.
into
(
)
style
:
self
}
}
}
impl
Colour
{
pub
fn
paint
<
'
a
I
S
:
'
a
+
ToOwned
+
?
Sized
>
(
self
input
:
I
)
-
>
ANSIGenericString
<
'
a
S
>
where
I
:
Into
<
Cow
<
'
a
S
>
>
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
{
ANSIGenericString
{
string
:
input
.
into
(
)
style
:
self
.
normal
(
)
}
}
}
impl
<
'
a
>
fmt
:
:
Display
for
ANSIString
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
w
:
&
mut
fmt
:
:
Write
=
f
;
self
.
write_to_any
(
w
)
}
}
impl
<
'
a
>
ANSIByteString
<
'
a
>
{
pub
fn
write_to
<
W
:
io
:
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
let
w
:
&
mut
io
:
:
Write
=
w
;
self
.
write_to_any
(
w
)
}
}
impl
<
'
a
S
:
'
a
+
ToOwned
+
?
Sized
>
ANSIGenericString
<
'
a
S
>
where
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
&
'
a
S
:
AsRef
<
[
u8
]
>
{
fn
write_to_any
<
W
:
AnyWrite
<
wstr
=
S
>
+
?
Sized
>
(
&
self
w
:
&
mut
W
)
-
>
Result
<
(
)
W
:
:
Error
>
{
write
!
(
w
"
{
}
"
self
.
style
.
prefix
(
)
)
?
;
w
.
write_str
(
self
.
string
.
as_ref
(
)
)
?
;
write
!
(
w
"
{
}
"
self
.
style
.
suffix
(
)
)
}
}
impl
<
'
a
>
fmt
:
:
Display
for
ANSIStrings
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
f
:
&
mut
fmt
:
:
Write
=
f
;
self
.
write_to_any
(
f
)
}
}
impl
<
'
a
>
ANSIByteStrings
<
'
a
>
{
pub
fn
write_to
<
W
:
io
:
:
Write
>
(
&
self
w
:
&
mut
W
)
-
>
io
:
:
Result
<
(
)
>
{
let
w
:
&
mut
io
:
:
Write
=
w
;
self
.
write_to_any
(
w
)
}
}
impl
<
'
a
S
:
'
a
+
ToOwned
+
?
Sized
>
ANSIGenericStrings
<
'
a
S
>
where
<
S
as
ToOwned
>
:
:
Owned
:
fmt
:
:
Debug
&
'
a
S
:
AsRef
<
[
u8
]
>
{
fn
write_to_any
<
W
:
AnyWrite
<
wstr
=
S
>
+
?
Sized
>
(
&
self
w
:
&
mut
W
)
-
>
Result
<
(
)
W
:
:
Error
>
{
use
self
:
:
Difference
:
:
*
;
let
first
=
match
self
.
0
.
first
(
)
{
None
=
>
return
Ok
(
(
)
)
Some
(
f
)
=
>
f
}
;
write
!
(
w
"
{
}
"
first
.
style
.
prefix
(
)
)
?
;
w
.
write_str
(
first
.
string
.
as_ref
(
)
)
?
;
for
window
in
self
.
0
.
windows
(
2
)
{
match
Difference
:
:
between
(
&
window
[
0
]
.
style
&
window
[
1
]
.
style
)
{
ExtraStyles
(
style
)
=
>
write
!
(
w
"
{
}
"
style
.
prefix
(
)
)
?
Reset
=
>
write
!
(
w
"
{
}
{
}
"
RESET
window
[
1
]
.
style
.
prefix
(
)
)
?
NoDifference
=
>
{
}
}
w
.
write_str
(
&
window
[
1
]
.
string
)
?
;
}
if
let
Some
(
last
)
=
self
.
0
.
last
(
)
{
if
!
last
.
style
.
is_plain
(
)
{
write
!
(
w
"
{
}
"
RESET
)
?
;
}
}
Ok
(
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
pub
use
super
:
:
super
:
:
ANSIStrings
;
pub
use
style
:
:
Style
;
pub
use
style
:
:
Colour
:
:
*
;
#
[
test
]
fn
no_control_codes_for_plain
(
)
{
let
one
=
Style
:
:
default
(
)
.
paint
(
"
one
"
)
;
let
two
=
Style
:
:
default
(
)
.
paint
(
"
two
"
)
;
let
output
=
format
!
(
"
{
}
"
ANSIStrings
(
&
[
one
two
]
)
)
;
assert_eq
!
(
&
*
output
"
onetwo
"
)
;
}
}
