#
!
[
forbid
(
unsafe_code
)
]
use
crate
:
:
{
deflate
:
:
{
fill_window
BlockState
DeflateStream
MIN_LOOKAHEAD
STD_MIN_MATCH
WANT_MIN_MATCH
}
flush_block
DeflateFlush
}
;
pub
fn
deflate_fast
(
stream
:
&
mut
DeflateStream
flush
:
DeflateFlush
)
-
>
BlockState
{
let
mut
bflush
;
let
mut
dist
;
let
mut
match_len
=
0
;
loop
{
if
stream
.
state
.
lookahead
<
MIN_LOOKAHEAD
{
fill_window
(
stream
)
;
if
stream
.
state
.
lookahead
<
MIN_LOOKAHEAD
&
&
flush
=
=
DeflateFlush
:
:
NoFlush
{
return
BlockState
:
:
NeedMore
;
}
if
stream
.
state
.
lookahead
=
=
0
{
break
;
}
}
let
state
=
&
mut
stream
.
state
;
if
state
.
lookahead
>
=
WANT_MIN_MATCH
{
let
hash_head
=
state
.
quick_insert_string
(
state
.
strstart
)
;
dist
=
state
.
strstart
as
isize
-
hash_head
as
isize
;
if
dist
<
=
state
.
max_dist
(
)
as
isize
&
&
dist
>
0
&
&
hash_head
!
=
0
{
(
match_len
state
.
match_start
)
=
crate
:
:
deflate
:
:
longest_match
:
:
longest_match
(
state
hash_head
)
;
}
}
if
match_len
>
=
WANT_MIN_MATCH
{
bflush
=
state
.
tally_dist
(
state
.
strstart
-
state
.
match_start
match_len
-
STD_MIN_MATCH
)
;
state
.
lookahead
-
=
match_len
;
if
match_len
<
=
state
.
max_insert_length
(
)
&
&
state
.
lookahead
>
=
WANT_MIN_MATCH
{
match_len
-
=
1
;
state
.
strstart
+
=
1
;
state
.
insert_string
(
state
.
strstart
match_len
)
;
state
.
strstart
+
=
match_len
;
}
else
{
state
.
strstart
+
=
match_len
;
state
.
quick_insert_string
(
state
.
strstart
+
2
-
STD_MIN_MATCH
)
;
}
match_len
=
0
;
}
else
{
let
lc
=
state
.
window
.
filled
(
)
[
state
.
strstart
]
;
bflush
=
state
.
tally_lit
(
lc
)
;
state
.
lookahead
-
=
1
;
state
.
strstart
+
=
1
;
}
if
bflush
{
flush_block
!
(
stream
false
)
;
}
}
stream
.
state
.
insert
=
if
stream
.
state
.
strstart
<
(
STD_MIN_MATCH
-
1
)
{
stream
.
state
.
strstart
}
else
{
STD_MIN_MATCH
-
1
}
;
if
flush
=
=
DeflateFlush
:
:
Finish
{
flush_block
!
(
stream
true
)
;
return
BlockState
:
:
FinishDone
;
}
if
!
stream
.
state
.
sym_buf
.
is_empty
(
)
{
flush_block
!
(
stream
false
)
;
}
BlockState
:
:
BlockDone
}
