#
ifndef
SPIRV_CROSS_HPP
#
define
SPIRV_CROSS_HPP
#
include
"
spirv
.
hpp
"
#
include
"
spirv_cfg
.
hpp
"
#
include
"
spirv_cross_parsed_ir
.
hpp
"
namespace
SPIRV_CROSS_NAMESPACE
{
struct
Resource
{
ID
id
;
TypeID
type_id
;
TypeID
base_type_id
;
std
:
:
string
name
;
}
;
struct
ShaderResources
{
SmallVector
<
Resource
>
uniform_buffers
;
SmallVector
<
Resource
>
storage_buffers
;
SmallVector
<
Resource
>
stage_inputs
;
SmallVector
<
Resource
>
stage_outputs
;
SmallVector
<
Resource
>
subpass_inputs
;
SmallVector
<
Resource
>
storage_images
;
SmallVector
<
Resource
>
sampled_images
;
SmallVector
<
Resource
>
atomic_counters
;
SmallVector
<
Resource
>
acceleration_structures
;
SmallVector
<
Resource
>
push_constant_buffers
;
SmallVector
<
Resource
>
separate_images
;
SmallVector
<
Resource
>
separate_samplers
;
}
;
struct
CombinedImageSampler
{
VariableID
combined_id
;
VariableID
image_id
;
VariableID
sampler_id
;
}
;
struct
SpecializationConstant
{
ConstantID
id
;
uint32_t
constant_id
;
}
;
struct
BufferRange
{
unsigned
index
;
size_t
offset
;
size_t
range
;
}
;
enum
BufferPackingStandard
{
BufferPackingStd140
BufferPackingStd430
BufferPackingStd140EnhancedLayout
BufferPackingStd430EnhancedLayout
BufferPackingHLSLCbuffer
BufferPackingHLSLCbufferPackOffset
BufferPackingScalar
BufferPackingScalarEnhancedLayout
}
;
struct
EntryPoint
{
std
:
:
string
name
;
spv
:
:
ExecutionModel
execution_model
;
}
;
class
Compiler
{
public
:
friend
class
CFG
;
friend
class
DominatorBuilder
;
explicit
Compiler
(
std
:
:
vector
<
uint32_t
>
ir
)
;
Compiler
(
const
uint32_t
*
ir
size_t
word_count
)
;
explicit
Compiler
(
const
ParsedIR
&
ir
)
;
explicit
Compiler
(
ParsedIR
&
&
ir
)
;
virtual
~
Compiler
(
)
=
default
;
virtual
std
:
:
string
compile
(
)
;
const
std
:
:
string
&
get_name
(
ID
id
)
const
;
void
set_decoration
(
ID
id
spv
:
:
Decoration
decoration
uint32_t
argument
=
0
)
;
void
set_decoration_string
(
ID
id
spv
:
:
Decoration
decoration
const
std
:
:
string
&
argument
)
;
void
set_name
(
ID
id
const
std
:
:
string
&
name
)
;
const
Bitset
&
get_decoration_bitset
(
ID
id
)
const
;
bool
has_decoration
(
ID
id
spv
:
:
Decoration
decoration
)
const
;
uint32_t
get_decoration
(
ID
id
spv
:
:
Decoration
decoration
)
const
;
const
std
:
:
string
&
get_decoration_string
(
ID
id
spv
:
:
Decoration
decoration
)
const
;
void
unset_decoration
(
ID
id
spv
:
:
Decoration
decoration
)
;
const
SPIRType
&
get_type
(
TypeID
id
)
const
;
const
SPIRType
&
get_type_from_variable
(
VariableID
id
)
const
;
spv
:
:
StorageClass
get_storage_class
(
VariableID
id
)
const
;
virtual
const
std
:
:
string
get_fallback_name
(
ID
id
)
const
;
virtual
const
std
:
:
string
get_block_fallback_name
(
VariableID
id
)
const
;
const
std
:
:
string
&
get_member_name
(
TypeID
id
uint32_t
index
)
const
;
uint32_t
get_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
const
;
const
std
:
:
string
&
get_member_decoration_string
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
const
;
void
set_member_name
(
TypeID
id
uint32_t
index
const
std
:
:
string
&
name
)
;
const
std
:
:
string
&
get_member_qualified_name
(
TypeID
type_id
uint32_t
index
)
const
;
const
Bitset
&
get_member_decoration_bitset
(
TypeID
id
uint32_t
index
)
const
;
bool
has_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
const
;
void
set_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
uint32_t
argument
=
0
)
;
void
set_member_decoration_string
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
const
std
:
:
string
&
argument
)
;
void
unset_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
;
virtual
const
std
:
:
string
get_fallback_member_name
(
uint32_t
index
)
const
{
return
join
(
"
_
"
index
)
;
}
SmallVector
<
BufferRange
>
get_active_buffer_ranges
(
VariableID
id
)
const
;
size_t
get_declared_struct_size
(
const
SPIRType
&
struct_type
)
const
;
size_t
get_declared_struct_size_runtime_array
(
const
SPIRType
&
struct_type
size_t
array_size
)
const
;
size_t
get_declared_struct_member_size
(
const
SPIRType
&
struct_type
uint32_t
index
)
const
;
std
:
:
unordered_set
<
VariableID
>
get_active_interface_variables
(
)
const
;
void
set_enabled_interface_variables
(
std
:
:
unordered_set
<
VariableID
>
active_variables
)
;
ShaderResources
get_shader_resources
(
)
const
;
ShaderResources
get_shader_resources
(
const
std
:
:
unordered_set
<
VariableID
>
&
active_variables
)
const
;
void
set_remapped_variable_state
(
VariableID
id
bool
remap_enable
)
;
bool
get_remapped_variable_state
(
VariableID
id
)
const
;
void
set_subpass_input_remapped_components
(
VariableID
id
uint32_t
components
)
;
uint32_t
get_subpass_input_remapped_components
(
VariableID
id
)
const
;
SmallVector
<
EntryPoint
>
get_entry_points_and_stages
(
)
const
;
void
set_entry_point
(
const
std
:
:
string
&
entry
spv
:
:
ExecutionModel
execution_model
)
;
void
rename_entry_point
(
const
std
:
:
string
&
old_name
const
std
:
:
string
&
new_name
spv
:
:
ExecutionModel
execution_model
)
;
const
SPIREntryPoint
&
get_entry_point
(
const
std
:
:
string
&
name
spv
:
:
ExecutionModel
execution_model
)
const
;
SPIREntryPoint
&
get_entry_point
(
const
std
:
:
string
&
name
spv
:
:
ExecutionModel
execution_model
)
;
const
std
:
:
string
&
get_cleansed_entry_point_name
(
const
std
:
:
string
&
name
spv
:
:
ExecutionModel
execution_model
)
const
;
const
Bitset
&
get_execution_mode_bitset
(
)
const
;
void
unset_execution_mode
(
spv
:
:
ExecutionMode
mode
)
;
void
set_execution_mode
(
spv
:
:
ExecutionMode
mode
uint32_t
arg0
=
0
uint32_t
arg1
=
0
uint32_t
arg2
=
0
)
;
uint32_t
get_execution_mode_argument
(
spv
:
:
ExecutionMode
mode
uint32_t
index
=
0
)
const
;
spv
:
:
ExecutionModel
get_execution_model
(
)
const
;
bool
is_tessellation_shader
(
)
const
;
uint32_t
get_work_group_size_specialization_constants
(
SpecializationConstant
&
x
SpecializationConstant
&
y
SpecializationConstant
&
z
)
const
;
VariableID
build_dummy_sampler_for_combined_images
(
)
;
void
build_combined_image_samplers
(
)
;
const
SmallVector
<
CombinedImageSampler
>
&
get_combined_image_samplers
(
)
const
{
return
combined_image_samplers
;
}
void
set_variable_type_remap_callback
(
VariableTypeRemapCallback
cb
)
{
variable_remap_callback
=
std
:
:
move
(
cb
)
;
}
SmallVector
<
SpecializationConstant
>
get_specialization_constants
(
)
const
;
SPIRConstant
&
get_constant
(
ConstantID
id
)
;
const
SPIRConstant
&
get_constant
(
ConstantID
id
)
const
;
uint32_t
get_current_id_bound
(
)
const
{
return
uint32_t
(
ir
.
ids
.
size
(
)
)
;
}
uint32_t
type_struct_member_offset
(
const
SPIRType
&
type
uint32_t
index
)
const
;
uint32_t
type_struct_member_array_stride
(
const
SPIRType
&
type
uint32_t
index
)
const
;
uint32_t
type_struct_member_matrix_stride
(
const
SPIRType
&
type
uint32_t
index
)
const
;
bool
get_binary_offset_for_decoration
(
VariableID
id
spv
:
:
Decoration
decoration
uint32_t
&
word_offset
)
const
;
bool
buffer_is_hlsl_counter_buffer
(
VariableID
id
)
const
;
bool
buffer_get_hlsl_counter_buffer
(
VariableID
id
uint32_t
&
counter_id
)
const
;
const
SmallVector
<
spv
:
:
Capability
>
&
get_declared_capabilities
(
)
const
;
const
SmallVector
<
std
:
:
string
>
&
get_declared_extensions
(
)
const
;
std
:
:
string
get_remapped_declared_block_name
(
VariableID
id
)
const
;
Bitset
get_buffer_block_flags
(
VariableID
id
)
const
;
protected
:
const
uint32_t
*
stream
(
const
Instruction
&
instr
)
const
{
if
(
!
instr
.
length
)
return
nullptr
;
if
(
instr
.
offset
+
instr
.
length
>
ir
.
spirv
.
size
(
)
)
SPIRV_CROSS_THROW
(
"
Compiler
:
:
stream
(
)
out
of
range
.
"
)
;
return
&
ir
.
spirv
[
instr
.
offset
]
;
}
ParsedIR
ir
;
SmallVector
<
uint32_t
>
global_variables
;
SmallVector
<
uint32_t
>
aliased_variables
;
SPIRFunction
*
current_function
=
nullptr
;
SPIRBlock
*
current_block
=
nullptr
;
std
:
:
unordered_set
<
VariableID
>
active_interface_variables
;
bool
check_active_interface_variables
=
false
;
template
<
typename
T
typename
.
.
.
P
>
T
&
set
(
uint32_t
id
P
&
&
.
.
.
args
)
{
ir
.
add_typed_id
(
static_cast
<
Types
>
(
T
:
:
type
)
id
)
;
auto
&
var
=
variant_set
<
T
>
(
ir
.
ids
[
id
]
std
:
:
forward
<
P
>
(
args
)
.
.
.
)
;
var
.
self
=
id
;
return
var
;
}
template
<
typename
T
>
T
&
get
(
uint32_t
id
)
{
return
variant_get
<
T
>
(
ir
.
ids
[
id
]
)
;
}
template
<
typename
T
>
T
*
maybe_get
(
uint32_t
id
)
{
if
(
id
>
=
ir
.
ids
.
size
(
)
)
return
nullptr
;
else
if
(
ir
.
ids
[
id
]
.
get_type
(
)
=
=
static_cast
<
Types
>
(
T
:
:
type
)
)
return
&
get
<
T
>
(
id
)
;
else
return
nullptr
;
}
template
<
typename
T
>
const
T
&
get
(
uint32_t
id
)
const
{
return
variant_get
<
T
>
(
ir
.
ids
[
id
]
)
;
}
template
<
typename
T
>
const
T
*
maybe_get
(
uint32_t
id
)
const
{
if
(
id
>
=
ir
.
ids
.
size
(
)
)
return
nullptr
;
else
if
(
ir
.
ids
[
id
]
.
get_type
(
)
=
=
static_cast
<
Types
>
(
T
:
:
type
)
)
return
&
get
<
T
>
(
id
)
;
else
return
nullptr
;
}
uint32_t
get_pointee_type_id
(
uint32_t
type_id
)
const
;
const
SPIRType
&
get_pointee_type
(
const
SPIRType
&
type
)
const
;
const
SPIRType
&
get_pointee_type
(
uint32_t
type_id
)
const
;
uint32_t
get_variable_data_type_id
(
const
SPIRVariable
&
var
)
const
;
SPIRType
&
get_variable_data_type
(
const
SPIRVariable
&
var
)
;
const
SPIRType
&
get_variable_data_type
(
const
SPIRVariable
&
var
)
const
;
SPIRType
&
get_variable_element_type
(
const
SPIRVariable
&
var
)
;
const
SPIRType
&
get_variable_element_type
(
const
SPIRVariable
&
var
)
const
;
void
set_member_qualified_name
(
uint32_t
type_id
uint32_t
index
const
std
:
:
string
&
name
)
;
void
set_qualified_name
(
uint32_t
id
const
std
:
:
string
&
name
)
;
bool
is_sampled_image_type
(
const
SPIRType
&
type
)
;
const
SPIREntryPoint
&
get_entry_point
(
)
const
;
SPIREntryPoint
&
get_entry_point
(
)
;
static
bool
is_tessellation_shader
(
spv
:
:
ExecutionModel
model
)
;
virtual
std
:
:
string
to_name
(
uint32_t
id
bool
allow_alias
=
true
)
const
;
bool
is_builtin_variable
(
const
SPIRVariable
&
var
)
const
;
bool
is_builtin_type
(
const
SPIRType
&
type
)
const
;
bool
is_hidden_variable
(
const
SPIRVariable
&
var
bool
include_builtins
=
false
)
const
;
bool
is_immutable
(
uint32_t
id
)
const
;
bool
is_member_builtin
(
const
SPIRType
&
type
uint32_t
index
spv
:
:
BuiltIn
*
builtin
)
const
;
bool
is_scalar
(
const
SPIRType
&
type
)
const
;
bool
is_vector
(
const
SPIRType
&
type
)
const
;
bool
is_matrix
(
const
SPIRType
&
type
)
const
;
bool
is_array
(
const
SPIRType
&
type
)
const
;
uint32_t
expression_type_id
(
uint32_t
id
)
const
;
const
SPIRType
&
expression_type
(
uint32_t
id
)
const
;
bool
expression_is_lvalue
(
uint32_t
id
)
const
;
bool
variable_storage_is_aliased
(
const
SPIRVariable
&
var
)
;
SPIRVariable
*
maybe_get_backing_variable
(
uint32_t
chain
)
;
spv
:
:
StorageClass
get_backing_variable_storage
(
uint32_t
ptr
)
;
void
register_read
(
uint32_t
expr
uint32_t
chain
bool
forwarded
)
;
void
register_write
(
uint32_t
chain
)
;
inline
bool
is_continue
(
uint32_t
next
)
const
{
return
(
ir
.
block_meta
[
next
]
&
ParsedIR
:
:
BLOCK_META_CONTINUE_BIT
)
!
=
0
;
}
inline
bool
is_single_block_loop
(
uint32_t
next
)
const
{
auto
&
block
=
get
<
SPIRBlock
>
(
next
)
;
return
block
.
merge
=
=
SPIRBlock
:
:
MergeLoop
&
&
block
.
continue_block
=
=
ID
(
next
)
;
}
inline
bool
is_break
(
uint32_t
next
)
const
{
return
(
ir
.
block_meta
[
next
]
&
(
ParsedIR
:
:
BLOCK_META_LOOP_MERGE_BIT
|
ParsedIR
:
:
BLOCK_META_MULTISELECT_MERGE_BIT
)
)
!
=
0
;
}
inline
bool
is_loop_break
(
uint32_t
next
)
const
{
return
(
ir
.
block_meta
[
next
]
&
ParsedIR
:
:
BLOCK_META_LOOP_MERGE_BIT
)
!
=
0
;
}
inline
bool
is_conditional
(
uint32_t
next
)
const
{
return
(
ir
.
block_meta
[
next
]
&
(
ParsedIR
:
:
BLOCK_META_SELECTION_MERGE_BIT
|
ParsedIR
:
:
BLOCK_META_MULTISELECT_MERGE_BIT
)
)
!
=
0
;
}
void
flush_dependees
(
SPIRVariable
&
var
)
;
void
flush_all_active_variables
(
)
;
void
flush_control_dependent_expressions
(
uint32_t
block
)
;
void
flush_all_atomic_capable_variables
(
)
;
void
flush_all_aliased_variables
(
)
;
void
register_global_read_dependencies
(
const
SPIRBlock
&
func
uint32_t
id
)
;
void
register_global_read_dependencies
(
const
SPIRFunction
&
func
uint32_t
id
)
;
std
:
:
unordered_set
<
uint32_t
>
invalid_expressions
;
void
update_name_cache
(
std
:
:
unordered_set
<
std
:
:
string
>
&
cache
std
:
:
string
&
name
)
;
void
update_name_cache
(
std
:
:
unordered_set
<
std
:
:
string
>
&
cache_primary
const
std
:
:
unordered_set
<
std
:
:
string
>
&
cache_secondary
std
:
:
string
&
name
)
;
bool
function_is_pure
(
const
SPIRFunction
&
func
)
;
bool
block_is_pure
(
const
SPIRBlock
&
block
)
;
bool
execution_is_branchless
(
const
SPIRBlock
&
from
const
SPIRBlock
&
to
)
const
;
bool
execution_is_direct_branch
(
const
SPIRBlock
&
from
const
SPIRBlock
&
to
)
const
;
bool
execution_is_noop
(
const
SPIRBlock
&
from
const
SPIRBlock
&
to
)
const
;
SPIRBlock
:
:
ContinueBlockType
continue_block_type
(
const
SPIRBlock
&
continue_block
)
const
;
void
force_recompile
(
)
;
void
clear_force_recompile
(
)
;
bool
is_forcing_recompilation
(
)
const
;
bool
is_force_recompile
=
false
;
bool
block_is_loop_candidate
(
const
SPIRBlock
&
block
SPIRBlock
:
:
Method
method
)
const
;
bool
types_are_logically_equivalent
(
const
SPIRType
&
a
const
SPIRType
&
b
)
const
;
void
inherit_expression_dependencies
(
uint32_t
dst
uint32_t
source
)
;
void
add_implied_read_expression
(
SPIRExpression
&
e
uint32_t
source
)
;
void
add_implied_read_expression
(
SPIRAccessChain
&
e
uint32_t
source
)
;
bool
interface_variable_exists_in_entry_point
(
uint32_t
id
)
const
;
SmallVector
<
CombinedImageSampler
>
combined_image_samplers
;
void
remap_variable_type_name
(
const
SPIRType
&
type
const
std
:
:
string
&
var_name
std
:
:
string
&
type_name
)
const
{
if
(
variable_remap_callback
)
variable_remap_callback
(
type
var_name
type_name
)
;
}
void
set_ir
(
const
ParsedIR
&
parsed
)
;
void
set_ir
(
ParsedIR
&
&
parsed
)
;
void
parse_fixup
(
)
;
struct
OpcodeHandler
{
virtual
~
OpcodeHandler
(
)
=
default
;
virtual
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
=
0
;
virtual
bool
follow_function_call
(
const
SPIRFunction
&
)
{
return
true
;
}
virtual
void
set_current_block
(
const
SPIRBlock
&
)
{
}
virtual
void
rearm_current_block
(
const
SPIRBlock
&
)
{
}
virtual
bool
begin_function_scope
(
const
uint32_t
*
uint32_t
)
{
return
true
;
}
virtual
bool
end_function_scope
(
const
uint32_t
*
uint32_t
)
{
return
true
;
}
}
;
struct
BufferAccessHandler
:
OpcodeHandler
{
BufferAccessHandler
(
const
Compiler
&
compiler_
SmallVector
<
BufferRange
>
&
ranges_
uint32_t
id_
)
:
compiler
(
compiler_
)
ranges
(
ranges_
)
id
(
id_
)
{
}
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
const
Compiler
&
compiler
;
SmallVector
<
BufferRange
>
&
ranges
;
uint32_t
id
;
std
:
:
unordered_set
<
uint32_t
>
seen
;
}
;
struct
InterfaceVariableAccessHandler
:
OpcodeHandler
{
InterfaceVariableAccessHandler
(
const
Compiler
&
compiler_
std
:
:
unordered_set
<
VariableID
>
&
variables_
)
:
compiler
(
compiler_
)
variables
(
variables_
)
{
}
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
const
Compiler
&
compiler
;
std
:
:
unordered_set
<
VariableID
>
&
variables
;
}
;
struct
CombinedImageSamplerHandler
:
OpcodeHandler
{
CombinedImageSamplerHandler
(
Compiler
&
compiler_
)
:
compiler
(
compiler_
)
{
}
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
begin_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
end_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
std
:
:
stack
<
std
:
:
unordered_map
<
uint32_t
uint32_t
>
>
parameter_remapping
;
std
:
:
stack
<
SPIRFunction
*
>
functions
;
uint32_t
remap_parameter
(
uint32_t
id
)
;
void
push_remap_parameters
(
const
SPIRFunction
&
func
const
uint32_t
*
args
uint32_t
length
)
;
void
pop_remap_parameters
(
)
;
void
register_combined_image_sampler
(
SPIRFunction
&
caller
VariableID
combined_id
VariableID
texture_id
VariableID
sampler_id
bool
depth
)
;
}
;
struct
DummySamplerForCombinedImageHandler
:
OpcodeHandler
{
DummySamplerForCombinedImageHandler
(
Compiler
&
compiler_
)
:
compiler
(
compiler_
)
{
}
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
bool
need_dummy_sampler
=
false
;
}
;
struct
ActiveBuiltinHandler
:
OpcodeHandler
{
ActiveBuiltinHandler
(
Compiler
&
compiler_
)
:
compiler
(
compiler_
)
{
}
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
void
handle_builtin
(
const
SPIRType
&
type
spv
:
:
BuiltIn
builtin
const
Bitset
&
decoration_flags
)
;
}
;
bool
traverse_all_reachable_opcodes
(
const
SPIRBlock
&
block
OpcodeHandler
&
handler
)
const
;
bool
traverse_all_reachable_opcodes
(
const
SPIRFunction
&
block
OpcodeHandler
&
handler
)
const
;
SmallVector
<
uint32_t
>
global_struct_cache
;
ShaderResources
get_shader_resources
(
const
std
:
:
unordered_set
<
VariableID
>
*
active_variables
)
const
;
VariableTypeRemapCallback
variable_remap_callback
;
bool
get_common_basic_type
(
const
SPIRType
&
type
SPIRType
:
:
BaseType
&
base_type
)
;
std
:
:
unordered_set
<
uint32_t
>
forced_temporaries
;
std
:
:
unordered_set
<
uint32_t
>
forwarded_temporaries
;
std
:
:
unordered_set
<
uint32_t
>
suppressed_usage_tracking
;
std
:
:
unordered_set
<
uint32_t
>
hoisted_temporaries
;
std
:
:
unordered_set
<
uint32_t
>
forced_invariant_temporaries
;
Bitset
active_input_builtins
;
Bitset
active_output_builtins
;
uint32_t
clip_distance_count
=
0
;
uint32_t
cull_distance_count
=
0
;
bool
position_invariant
=
false
;
void
update_active_builtins
(
)
;
bool
has_active_builtin
(
spv
:
:
BuiltIn
builtin
spv
:
:
StorageClass
storage
)
;
void
analyze_parameter_preservation
(
SPIRFunction
&
entry
const
CFG
&
cfg
const
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
&
variable_to_blocks
const
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
&
complete_write_blocks
)
;
std
:
:
unordered_set
<
uint32_t
>
comparison_ids
;
bool
need_subpass_input
=
false
;
uint32_t
dummy_sampler_id
=
0
;
void
analyze_image_and_sampler_usage
(
)
;
struct
CombinedImageSamplerDrefHandler
:
OpcodeHandler
{
CombinedImageSamplerDrefHandler
(
Compiler
&
compiler_
)
:
compiler
(
compiler_
)
{
}
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
std
:
:
unordered_set
<
uint32_t
>
dref_combined_samplers
;
}
;
struct
CombinedImageSamplerUsageHandler
:
OpcodeHandler
{
CombinedImageSamplerUsageHandler
(
Compiler
&
compiler_
const
std
:
:
unordered_set
<
uint32_t
>
&
dref_combined_samplers_
)
:
compiler
(
compiler_
)
dref_combined_samplers
(
dref_combined_samplers_
)
{
}
bool
begin_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
handle
(
spv
:
:
Op
opcode
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
const
std
:
:
unordered_set
<
uint32_t
>
&
dref_combined_samplers
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
dependency_hierarchy
;
std
:
:
unordered_set
<
uint32_t
>
comparison_ids
;
void
add_hierarchy_to_comparison_ids
(
uint32_t
ids
)
;
bool
need_subpass_input
=
false
;
void
add_dependency
(
uint32_t
dst
uint32_t
src
)
;
}
;
void
build_function_control_flow_graphs_and_analyze
(
)
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unique_ptr
<
CFG
>
>
function_cfgs
;
const
CFG
&
get_cfg_for_current_function
(
)
const
;
const
CFG
&
get_cfg_for_function
(
uint32_t
id
)
const
;
struct
CFGBuilder
:
OpcodeHandler
{
explicit
CFGBuilder
(
Compiler
&
compiler_
)
;
bool
follow_function_call
(
const
SPIRFunction
&
func
)
override
;
bool
handle
(
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unique_ptr
<
CFG
>
>
function_cfgs
;
}
;
struct
AnalyzeVariableScopeAccessHandler
:
OpcodeHandler
{
AnalyzeVariableScopeAccessHandler
(
Compiler
&
compiler_
SPIRFunction
&
entry_
)
;
bool
follow_function_call
(
const
SPIRFunction
&
)
override
;
void
set_current_block
(
const
SPIRBlock
&
block
)
override
;
void
notify_variable_access
(
uint32_t
id
uint32_t
block
)
;
bool
id_is_phi_variable
(
uint32_t
id
)
const
;
bool
id_is_potential_temporary
(
uint32_t
id
)
const
;
bool
handle
(
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
SPIRFunction
&
entry
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
accessed_variables_to_block
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
accessed_temporaries_to_block
;
std
:
:
unordered_map
<
uint32_t
uint32_t
>
result_id_to_type
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
complete_write_variables_to_block
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
partial_write_variables_to_block
;
std
:
:
unordered_set
<
uint32_t
>
access_chain_expressions
;
std
:
:
unordered_map
<
uint32_t
std
:
:
unordered_set
<
uint32_t
>
>
access_chain_children
;
const
SPIRBlock
*
current_block
=
nullptr
;
}
;
struct
StaticExpressionAccessHandler
:
OpcodeHandler
{
StaticExpressionAccessHandler
(
Compiler
&
compiler_
uint32_t
variable_id_
)
;
bool
follow_function_call
(
const
SPIRFunction
&
)
override
;
bool
handle
(
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
uint32_t
variable_id
;
uint32_t
static_expression
=
0
;
uint32_t
write_count
=
0
;
}
;
struct
PhysicalStorageBufferPointerHandler
:
OpcodeHandler
{
explicit
PhysicalStorageBufferPointerHandler
(
Compiler
&
compiler_
)
;
bool
handle
(
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
std
:
:
unordered_set
<
uint32_t
>
types
;
}
;
void
analyze_non_block_pointer_types
(
)
;
SmallVector
<
uint32_t
>
physical_storage_non_block_pointer_types
;
void
analyze_variable_scope
(
SPIRFunction
&
function
AnalyzeVariableScopeAccessHandler
&
handler
)
;
void
find_function_local_luts
(
SPIRFunction
&
function
const
AnalyzeVariableScopeAccessHandler
&
handler
bool
single_function
)
;
bool
may_read_undefined_variable_in_block
(
const
SPIRBlock
&
block
uint32_t
var
)
;
struct
InterlockedResourceAccessHandler
:
OpcodeHandler
{
InterlockedResourceAccessHandler
(
Compiler
&
compiler_
uint32_t
entry_point_id
)
:
compiler
(
compiler_
)
{
call_stack
.
push_back
(
entry_point_id
)
;
}
bool
handle
(
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
begin_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
end_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
bool
in_crit_sec
=
false
;
uint32_t
interlock_function_id
=
0
;
bool
split_function_case
=
false
;
bool
control_flow_interlock
=
false
;
bool
use_critical_section
=
false
;
bool
call_stack_is_interlocked
=
false
;
SmallVector
<
uint32_t
>
call_stack
;
void
access_potential_resource
(
uint32_t
id
)
;
}
;
struct
InterlockedResourceAccessPrepassHandler
:
OpcodeHandler
{
InterlockedResourceAccessPrepassHandler
(
Compiler
&
compiler_
uint32_t
entry_point_id
)
:
compiler
(
compiler_
)
{
call_stack
.
push_back
(
entry_point_id
)
;
}
void
rearm_current_block
(
const
SPIRBlock
&
block
)
override
;
bool
handle
(
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
begin_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
bool
end_function_scope
(
const
uint32_t
*
args
uint32_t
length
)
override
;
Compiler
&
compiler
;
uint32_t
interlock_function_id
=
0
;
uint32_t
current_block_id
=
0
;
bool
split_function_case
=
false
;
bool
control_flow_interlock
=
false
;
SmallVector
<
uint32_t
>
call_stack
;
}
;
void
analyze_interlocked_resource_usage
(
)
;
std
:
:
unordered_set
<
uint32_t
>
interlocked_resources
;
bool
interlocked_is_complex
=
false
;
void
make_constant_null
(
uint32_t
id
uint32_t
type
)
;
std
:
:
unordered_map
<
uint32_t
std
:
:
string
>
declared_block_names
;
bool
instruction_to_result_type
(
uint32_t
&
result_type
uint32_t
&
result_id
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
;
Bitset
combined_decoration_for_member
(
const
SPIRType
&
type
uint32_t
index
)
const
;
static
bool
is_desktop_only_format
(
spv
:
:
ImageFormat
format
)
;
bool
image_is_comparison
(
const
SPIRType
&
type
uint32_t
id
)
const
;
void
set_extended_decoration
(
uint32_t
id
ExtendedDecorations
decoration
uint32_t
value
=
0
)
;
uint32_t
get_extended_decoration
(
uint32_t
id
ExtendedDecorations
decoration
)
const
;
bool
has_extended_decoration
(
uint32_t
id
ExtendedDecorations
decoration
)
const
;
void
unset_extended_decoration
(
uint32_t
id
ExtendedDecorations
decoration
)
;
void
set_extended_member_decoration
(
uint32_t
type
uint32_t
index
ExtendedDecorations
decoration
uint32_t
value
=
0
)
;
uint32_t
get_extended_member_decoration
(
uint32_t
type
uint32_t
index
ExtendedDecorations
decoration
)
const
;
bool
has_extended_member_decoration
(
uint32_t
type
uint32_t
index
ExtendedDecorations
decoration
)
const
;
void
unset_extended_member_decoration
(
uint32_t
type
uint32_t
index
ExtendedDecorations
decoration
)
;
bool
type_is_array_of_pointers
(
const
SPIRType
&
type
)
const
;
bool
type_is_block_like
(
const
SPIRType
&
type
)
const
;
bool
type_is_opaque_value
(
const
SPIRType
&
type
)
const
;
bool
reflection_ssbo_instance_name_is_significant
(
)
const
;
std
:
:
string
get_remapped_declared_block_name
(
uint32_t
id
bool
fallback_prefer_instance_name
)
const
;
bool
flush_phi_required
(
BlockID
from
BlockID
to
)
const
;
private
:
const
SPIREntryPoint
&
get_first_entry_point
(
const
std
:
:
string
&
name
)
const
;
SPIREntryPoint
&
get_first_entry_point
(
const
std
:
:
string
&
name
)
;
}
;
}
#
endif
