#
ifndef
SPIRV_CROSS_COMMON_HPP
#
define
SPIRV_CROSS_COMMON_HPP
#
include
"
spirv
.
hpp
"
#
include
"
spirv_cross_containers
.
hpp
"
#
include
"
spirv_cross_error_handling
.
hpp
"
#
include
<
functional
>
#
ifdef
SPIRV_CROSS_NAMESPACE_OVERRIDE
#
define
SPIRV_CROSS_NAMESPACE
SPIRV_CROSS_NAMESPACE_OVERRIDE
#
else
#
define
SPIRV_CROSS_NAMESPACE
spirv_cross
#
endif
namespace
SPIRV_CROSS_NAMESPACE
{
namespace
inner
{
template
<
typename
T
>
void
join_helper
(
StringStream
<
>
&
stream
T
&
&
t
)
{
stream
<
<
std
:
:
forward
<
T
>
(
t
)
;
}
template
<
typename
T
typename
.
.
.
Ts
>
void
join_helper
(
StringStream
<
>
&
stream
T
&
&
t
Ts
&
&
.
.
.
ts
)
{
stream
<
<
std
:
:
forward
<
T
>
(
t
)
;
join_helper
(
stream
std
:
:
forward
<
Ts
>
(
ts
)
.
.
.
)
;
}
}
class
Bitset
{
public
:
Bitset
(
)
=
default
;
explicit
inline
Bitset
(
uint64_t
lower_
)
:
lower
(
lower_
)
{
}
inline
bool
get
(
uint32_t
bit
)
const
{
if
(
bit
<
64
)
return
(
lower
&
(
1ull
<
<
bit
)
)
!
=
0
;
else
return
higher
.
count
(
bit
)
!
=
0
;
}
inline
void
set
(
uint32_t
bit
)
{
if
(
bit
<
64
)
lower
|
=
1ull
<
<
bit
;
else
higher
.
insert
(
bit
)
;
}
inline
void
clear
(
uint32_t
bit
)
{
if
(
bit
<
64
)
lower
&
=
~
(
1ull
<
<
bit
)
;
else
higher
.
erase
(
bit
)
;
}
inline
uint64_t
get_lower
(
)
const
{
return
lower
;
}
inline
void
reset
(
)
{
lower
=
0
;
higher
.
clear
(
)
;
}
inline
void
merge_and
(
const
Bitset
&
other
)
{
lower
&
=
other
.
lower
;
std
:
:
unordered_set
<
uint32_t
>
tmp_set
;
for
(
auto
&
v
:
higher
)
if
(
other
.
higher
.
count
(
v
)
!
=
0
)
tmp_set
.
insert
(
v
)
;
higher
=
std
:
:
move
(
tmp_set
)
;
}
inline
void
merge_or
(
const
Bitset
&
other
)
{
lower
|
=
other
.
lower
;
for
(
auto
&
v
:
other
.
higher
)
higher
.
insert
(
v
)
;
}
inline
bool
operator
=
=
(
const
Bitset
&
other
)
const
{
if
(
lower
!
=
other
.
lower
)
return
false
;
if
(
higher
.
size
(
)
!
=
other
.
higher
.
size
(
)
)
return
false
;
for
(
auto
&
v
:
higher
)
if
(
other
.
higher
.
count
(
v
)
=
=
0
)
return
false
;
return
true
;
}
inline
bool
operator
!
=
(
const
Bitset
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
template
<
typename
Op
>
void
for_each_bit
(
const
Op
&
op
)
const
{
for
(
uint32_t
i
=
0
;
i
<
64
;
i
+
+
)
{
if
(
lower
&
(
1ull
<
<
i
)
)
op
(
i
)
;
}
if
(
higher
.
empty
(
)
)
return
;
SmallVector
<
uint32_t
>
bits
;
bits
.
reserve
(
higher
.
size
(
)
)
;
for
(
auto
&
v
:
higher
)
bits
.
push_back
(
v
)
;
std
:
:
sort
(
std
:
:
begin
(
bits
)
std
:
:
end
(
bits
)
)
;
for
(
auto
&
v
:
bits
)
op
(
v
)
;
}
inline
bool
empty
(
)
const
{
return
lower
=
=
0
&
&
higher
.
empty
(
)
;
}
private
:
uint64_t
lower
=
0
;
std
:
:
unordered_set
<
uint32_t
>
higher
;
}
;
template
<
typename
.
.
.
Ts
>
std
:
:
string
join
(
Ts
&
&
.
.
.
ts
)
{
StringStream
<
>
stream
;
inner
:
:
join_helper
(
stream
std
:
:
forward
<
Ts
>
(
ts
)
.
.
.
)
;
return
stream
.
str
(
)
;
}
inline
std
:
:
string
merge
(
const
SmallVector
<
std
:
:
string
>
&
list
const
char
*
between
=
"
"
)
{
StringStream
<
>
stream
;
for
(
auto
&
elem
:
list
)
{
stream
<
<
elem
;
if
(
&
elem
!
=
&
list
.
back
(
)
)
stream
<
<
between
;
}
return
stream
.
str
(
)
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
!
std
:
:
is_floating_point
<
T
>
:
:
value
int
>
:
:
type
=
0
>
inline
std
:
:
string
convert_to_string
(
const
T
&
t
)
{
return
std
:
:
to_string
(
t
)
;
}
#
ifndef
SPIRV_CROSS_FLT_FMT
#
define
SPIRV_CROSS_FLT_FMT
"
%
.
32g
"
#
endif
#
ifdef
_MSC_VER
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4996
)
#
endif
static
inline
void
fixup_radix_point
(
char
*
str
char
radix_point
)
{
if
(
radix_point
!
=
'
.
'
)
{
while
(
*
str
!
=
'
\
0
'
)
{
if
(
*
str
=
=
radix_point
)
*
str
=
'
.
'
;
str
+
+
;
}
}
}
inline
std
:
:
string
convert_to_string
(
float
t
char
locale_radix_point
)
{
char
buf
[
64
]
;
sprintf
(
buf
SPIRV_CROSS_FLT_FMT
t
)
;
fixup_radix_point
(
buf
locale_radix_point
)
;
if
(
!
strchr
(
buf
'
.
'
)
&
&
!
strchr
(
buf
'
e
'
)
)
strcat
(
buf
"
.
0
"
)
;
return
buf
;
}
inline
std
:
:
string
convert_to_string
(
double
t
char
locale_radix_point
)
{
char
buf
[
64
]
;
sprintf
(
buf
SPIRV_CROSS_FLT_FMT
t
)
;
fixup_radix_point
(
buf
locale_radix_point
)
;
if
(
!
strchr
(
buf
'
.
'
)
&
&
!
strchr
(
buf
'
e
'
)
)
strcat
(
buf
"
.
0
"
)
;
return
buf
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
pop
)
#
endif
struct
Instruction
{
uint16_t
op
=
0
;
uint16_t
count
=
0
;
uint32_t
offset
=
0
;
uint32_t
length
=
0
;
}
;
enum
Types
{
TypeNone
TypeType
TypeVariable
TypeConstant
TypeFunction
TypeFunctionPrototype
TypeBlock
TypeExtension
TypeExpression
TypeConstantOp
TypeCombinedImageSampler
TypeAccessChain
TypeUndef
TypeString
TypeCount
}
;
template
<
Types
type
>
class
TypedID
;
template
<
>
class
TypedID
<
TypeNone
>
{
public
:
TypedID
(
)
=
default
;
TypedID
(
uint32_t
id_
)
:
id
(
id_
)
{
}
template
<
Types
U
>
TypedID
(
const
TypedID
<
U
>
&
other
)
{
*
this
=
other
;
}
template
<
Types
U
>
TypedID
&
operator
=
(
const
TypedID
<
U
>
&
other
)
{
id
=
uint32_t
(
other
)
;
return
*
this
;
}
operator
uint32_t
(
)
const
{
return
id
;
}
template
<
Types
U
>
operator
TypedID
<
U
>
(
)
const
{
return
TypedID
<
U
>
(
*
this
)
;
}
bool
operator
=
=
(
const
TypedID
&
other
)
const
{
return
id
=
=
other
.
id
;
}
bool
operator
!
=
(
const
TypedID
&
other
)
const
{
return
id
!
=
other
.
id
;
}
template
<
Types
type
>
bool
operator
=
=
(
const
TypedID
<
type
>
&
other
)
const
{
return
id
=
=
uint32_t
(
other
)
;
}
template
<
Types
type
>
bool
operator
!
=
(
const
TypedID
<
type
>
&
other
)
const
{
return
id
!
=
uint32_t
(
other
)
;
}
private
:
uint32_t
id
=
0
;
}
;
template
<
Types
type
>
class
TypedID
{
public
:
TypedID
(
)
=
default
;
TypedID
(
uint32_t
id_
)
:
id
(
id_
)
{
}
explicit
TypedID
(
const
TypedID
<
TypeNone
>
&
other
)
:
id
(
uint32_t
(
other
)
)
{
}
operator
uint32_t
(
)
const
{
return
id
;
}
bool
operator
=
=
(
const
TypedID
&
other
)
const
{
return
id
=
=
other
.
id
;
}
bool
operator
!
=
(
const
TypedID
&
other
)
const
{
return
id
!
=
other
.
id
;
}
bool
operator
=
=
(
const
TypedID
<
TypeNone
>
&
other
)
const
{
return
id
=
=
uint32_t
(
other
)
;
}
bool
operator
!
=
(
const
TypedID
<
TypeNone
>
&
other
)
const
{
return
id
!
=
uint32_t
(
other
)
;
}
private
:
uint32_t
id
=
0
;
}
;
using
VariableID
=
TypedID
<
TypeVariable
>
;
using
TypeID
=
TypedID
<
TypeType
>
;
using
ConstantID
=
TypedID
<
TypeConstant
>
;
using
FunctionID
=
TypedID
<
TypeFunction
>
;
using
BlockID
=
TypedID
<
TypeBlock
>
;
using
ID
=
TypedID
<
TypeNone
>
;
struct
IVariant
{
virtual
~
IVariant
(
)
=
default
;
virtual
IVariant
*
clone
(
ObjectPoolBase
*
pool
)
=
0
;
ID
self
=
0
;
}
;
#
define
SPIRV_CROSS_DECLARE_CLONE
(
T
)
\
IVariant
*
clone
(
ObjectPoolBase
*
pool
)
override
\
{
\
return
static_cast
<
ObjectPool
<
T
>
*
>
(
pool
)
-
>
allocate
(
*
this
)
;
\
}
struct
SPIRUndef
:
IVariant
{
enum
{
type
=
TypeUndef
}
;
explicit
SPIRUndef
(
TypeID
basetype_
)
:
basetype
(
basetype_
)
{
}
TypeID
basetype
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRUndef
)
}
;
struct
SPIRString
:
IVariant
{
enum
{
type
=
TypeString
}
;
explicit
SPIRString
(
std
:
:
string
str_
)
:
str
(
std
:
:
move
(
str_
)
)
{
}
std
:
:
string
str
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRString
)
}
;
struct
SPIRCombinedImageSampler
:
IVariant
{
enum
{
type
=
TypeCombinedImageSampler
}
;
SPIRCombinedImageSampler
(
TypeID
type_
VariableID
image_
VariableID
sampler_
)
:
combined_type
(
type_
)
image
(
image_
)
sampler
(
sampler_
)
{
}
TypeID
combined_type
;
VariableID
image
;
VariableID
sampler
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRCombinedImageSampler
)
}
;
struct
SPIRConstantOp
:
IVariant
{
enum
{
type
=
TypeConstantOp
}
;
SPIRConstantOp
(
TypeID
result_type
spv
:
:
Op
op
const
uint32_t
*
args
uint32_t
length
)
:
opcode
(
op
)
basetype
(
result_type
)
{
arguments
.
reserve
(
length
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
arguments
.
push_back
(
args
[
i
]
)
;
}
spv
:
:
Op
opcode
;
SmallVector
<
uint32_t
>
arguments
;
TypeID
basetype
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRConstantOp
)
}
;
struct
SPIRType
:
IVariant
{
enum
{
type
=
TypeType
}
;
enum
BaseType
{
Unknown
Void
Boolean
SByte
UByte
Short
UShort
Int
UInt
Int64
UInt64
AtomicCounter
Half
Float
Double
Struct
Image
SampledImage
Sampler
AccelerationStructureNV
ControlPointArray
Char
}
;
BaseType
basetype
=
Unknown
;
uint32_t
width
=
0
;
uint32_t
vecsize
=
1
;
uint32_t
columns
=
1
;
SmallVector
<
uint32_t
>
array
;
SmallVector
<
bool
>
array_size_literal
;
uint32_t
pointer_depth
=
0
;
bool
pointer
=
false
;
spv
:
:
StorageClass
storage
=
spv
:
:
StorageClassGeneric
;
SmallVector
<
TypeID
>
member_types
;
struct
ImageType
{
TypeID
type
;
spv
:
:
Dim
dim
;
bool
depth
;
bool
arrayed
;
bool
ms
;
uint32_t
sampled
;
spv
:
:
ImageFormat
format
;
spv
:
:
AccessQualifier
access
;
}
image
;
TypeID
type_alias
=
0
;
TypeID
parent_type
=
0
;
std
:
:
unordered_set
<
std
:
:
string
>
member_name_cache
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRType
)
}
;
struct
SPIRExtension
:
IVariant
{
enum
{
type
=
TypeExtension
}
;
enum
Extension
{
Unsupported
GLSL
SPV_debug_info
SPV_AMD_shader_ballot
SPV_AMD_shader_explicit_vertex_parameter
SPV_AMD_shader_trinary_minmax
SPV_AMD_gcn_shader
}
;
explicit
SPIRExtension
(
Extension
ext_
)
:
ext
(
ext_
)
{
}
Extension
ext
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRExtension
)
}
;
struct
SPIREntryPoint
{
SPIREntryPoint
(
FunctionID
self_
spv
:
:
ExecutionModel
execution_model
const
std
:
:
string
&
entry_name
)
:
self
(
self_
)
name
(
entry_name
)
orig_name
(
entry_name
)
model
(
execution_model
)
{
}
SPIREntryPoint
(
)
=
default
;
FunctionID
self
=
0
;
std
:
:
string
name
;
std
:
:
string
orig_name
;
SmallVector
<
VariableID
>
interface_variables
;
Bitset
flags
;
struct
{
uint32_t
x
=
0
y
=
0
z
=
0
;
uint32_t
constant
=
0
;
}
workgroup_size
;
uint32_t
invocations
=
0
;
uint32_t
output_vertices
=
0
;
spv
:
:
ExecutionModel
model
=
spv
:
:
ExecutionModelMax
;
}
;
struct
SPIRExpression
:
IVariant
{
enum
{
type
=
TypeExpression
}
;
SPIRExpression
(
std
:
:
string
expr
TypeID
expression_type_
bool
immutable_
)
:
expression
(
move
(
expr
)
)
expression_type
(
expression_type_
)
immutable
(
immutable_
)
{
}
ID
base_expression
=
0
;
std
:
:
string
expression
;
TypeID
expression_type
=
0
;
ID
loaded_from
=
0
;
bool
immutable
=
false
;
bool
need_transpose
=
false
;
bool
access_chain
=
false
;
SmallVector
<
ID
>
expression_dependencies
;
SmallVector
<
ID
>
implied_read_expressions
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRExpression
)
}
;
struct
SPIRFunctionPrototype
:
IVariant
{
enum
{
type
=
TypeFunctionPrototype
}
;
explicit
SPIRFunctionPrototype
(
TypeID
return_type_
)
:
return_type
(
return_type_
)
{
}
TypeID
return_type
;
SmallVector
<
uint32_t
>
parameter_types
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRFunctionPrototype
)
}
;
struct
SPIRBlock
:
IVariant
{
enum
{
type
=
TypeBlock
}
;
enum
Terminator
{
Unknown
Direct
Select
MultiSelect
Return
Unreachable
Kill
}
;
enum
Merge
{
MergeNone
MergeLoop
MergeSelection
}
;
enum
Hints
{
HintNone
HintUnroll
HintDontUnroll
HintFlatten
HintDontFlatten
}
;
enum
Method
{
MergeToSelectForLoop
MergeToDirectForLoop
MergeToSelectContinueForLoop
}
;
enum
ContinueBlockType
{
ContinueNone
ForLoop
WhileLoop
DoWhileLoop
ComplexLoop
}
;
enum
{
NoDominator
=
0xffffffffu
}
;
Terminator
terminator
=
Unknown
;
Merge
merge
=
MergeNone
;
Hints
hint
=
HintNone
;
BlockID
next_block
=
0
;
BlockID
merge_block
=
0
;
BlockID
continue_block
=
0
;
ID
return_value
=
0
;
ID
condition
=
0
;
BlockID
true_block
=
0
;
BlockID
false_block
=
0
;
BlockID
default_block
=
0
;
SmallVector
<
Instruction
>
ops
;
struct
Phi
{
ID
local_variable
;
BlockID
parent
;
VariableID
function_variable
;
}
;
SmallVector
<
Phi
>
phi_variables
;
SmallVector
<
std
:
:
pair
<
TypeID
ID
>
>
declare_temporary
;
SmallVector
<
std
:
:
pair
<
TypeID
ID
>
>
potential_declare_temporary
;
struct
Case
{
uint32_t
value
;
BlockID
block
;
}
;
SmallVector
<
Case
>
cases
;
bool
disable_block_optimization
=
false
;
bool
complex_continue
=
false
;
bool
need_ladder_break
=
false
;
BlockID
ignore_phi_from_block
=
0
;
BlockID
loop_dominator
=
0
;
SmallVector
<
VariableID
>
dominated_variables
;
SmallVector
<
VariableID
>
loop_variables
;
SmallVector
<
ID
>
invalidate_expressions
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRBlock
)
}
;
struct
SPIRFunction
:
IVariant
{
enum
{
type
=
TypeFunction
}
;
SPIRFunction
(
TypeID
return_type_
TypeID
function_type_
)
:
return_type
(
return_type_
)
function_type
(
function_type_
)
{
}
struct
Parameter
{
TypeID
type
;
ID
id
;
uint32_t
read_count
;
uint32_t
write_count
;
bool
alias_global_variable
;
}
;
struct
CombinedImageSamplerParameter
{
VariableID
id
;
VariableID
image_id
;
VariableID
sampler_id
;
bool
global_image
;
bool
global_sampler
;
bool
depth
;
}
;
TypeID
return_type
;
TypeID
function_type
;
SmallVector
<
Parameter
>
arguments
;
SmallVector
<
Parameter
>
shadow_arguments
;
SmallVector
<
VariableID
>
local_variables
;
BlockID
entry_block
=
0
;
SmallVector
<
BlockID
>
blocks
;
SmallVector
<
CombinedImageSamplerParameter
>
combined_parameters
;
struct
EntryLine
{
uint32_t
file_id
=
0
;
uint32_t
line_literal
=
0
;
}
;
EntryLine
entry_line
;
void
add_local_variable
(
VariableID
id
)
{
local_variables
.
push_back
(
id
)
;
}
void
add_parameter
(
TypeID
parameter_type
ID
id
bool
alias_global_variable
=
false
)
{
arguments
.
push_back
(
{
parameter_type
id
0u
0u
alias_global_variable
}
)
;
}
Vector
<
std
:
:
function
<
void
(
)
>
>
fixup_hooks_out
;
Vector
<
std
:
:
function
<
void
(
)
>
>
fixup_hooks_in
;
bool
active
=
false
;
bool
flush_undeclared
=
true
;
bool
do_combined_parameters
=
true
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRFunction
)
}
;
struct
SPIRAccessChain
:
IVariant
{
enum
{
type
=
TypeAccessChain
}
;
SPIRAccessChain
(
TypeID
basetype_
spv
:
:
StorageClass
storage_
std
:
:
string
base_
std
:
:
string
dynamic_index_
int32_t
static_index_
)
:
basetype
(
basetype_
)
storage
(
storage_
)
base
(
std
:
:
move
(
base_
)
)
dynamic_index
(
std
:
:
move
(
dynamic_index_
)
)
static_index
(
static_index_
)
{
}
TypeID
basetype
;
spv
:
:
StorageClass
storage
;
std
:
:
string
base
;
std
:
:
string
dynamic_index
;
int32_t
static_index
;
VariableID
loaded_from
=
0
;
uint32_t
matrix_stride
=
0
;
bool
row_major_matrix
=
false
;
bool
immutable
=
false
;
SmallVector
<
ID
>
implied_read_expressions
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRAccessChain
)
}
;
struct
SPIRVariable
:
IVariant
{
enum
{
type
=
TypeVariable
}
;
SPIRVariable
(
)
=
default
;
SPIRVariable
(
TypeID
basetype_
spv
:
:
StorageClass
storage_
ID
initializer_
=
0
VariableID
basevariable_
=
0
)
:
basetype
(
basetype_
)
storage
(
storage_
)
initializer
(
initializer_
)
basevariable
(
basevariable_
)
{
}
TypeID
basetype
=
0
;
spv
:
:
StorageClass
storage
=
spv
:
:
StorageClassGeneric
;
uint32_t
decoration
=
0
;
ID
initializer
=
0
;
VariableID
basevariable
=
0
;
SmallVector
<
uint32_t
>
dereference_chain
;
bool
compat_builtin
=
false
;
bool
statically_assigned
=
false
;
ID
static_expression
=
0
;
SmallVector
<
ID
>
dependees
;
bool
forwardable
=
true
;
bool
deferred_declaration
=
false
;
bool
phi_variable
=
false
;
bool
allocate_temporary_copy
=
false
;
bool
remapped_variable
=
false
;
uint32_t
remapped_components
=
0
;
BlockID
dominator
=
0
;
bool
loop_variable
=
false
;
bool
loop_variable_enable
=
false
;
SPIRFunction
:
:
Parameter
*
parameter
=
nullptr
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRVariable
)
}
;
struct
SPIRConstant
:
IVariant
{
enum
{
type
=
TypeConstant
}
;
union
Constant
{
uint32_t
u32
;
int32_t
i32
;
float
f32
;
uint64_t
u64
;
int64_t
i64
;
double
f64
;
}
;
struct
ConstantVector
{
Constant
r
[
4
]
;
ID
id
[
4
]
;
uint32_t
vecsize
=
1
;
ConstantVector
(
)
{
memset
(
r
0
sizeof
(
r
)
)
;
}
}
;
struct
ConstantMatrix
{
ConstantVector
c
[
4
]
;
ID
id
[
4
]
;
uint32_t
columns
=
1
;
}
;
static
inline
float
f16_to_f32
(
uint16_t
u16_value
)
{
int
s
=
(
u16_value
>
>
15
)
&
0x1
;
int
e
=
(
u16_value
>
>
10
)
&
0x1f
;
int
m
=
(
u16_value
>
>
0
)
&
0x3ff
;
union
{
float
f32
;
uint32_t
u32
;
}
u
;
if
(
e
=
=
0
)
{
if
(
m
=
=
0
)
{
u
.
u32
=
uint32_t
(
s
)
<
<
31
;
return
u
.
f32
;
}
else
{
while
(
(
m
&
0x400
)
=
=
0
)
{
m
<
<
=
1
;
e
-
-
;
}
e
+
+
;
m
&
=
~
0x400
;
}
}
else
if
(
e
=
=
31
)
{
if
(
m
=
=
0
)
{
u
.
u32
=
(
uint32_t
(
s
)
<
<
31
)
|
0x7f800000u
;
return
u
.
f32
;
}
else
{
u
.
u32
=
(
uint32_t
(
s
)
<
<
31
)
|
0x7f800000u
|
(
m
<
<
13
)
;
return
u
.
f32
;
}
}
e
+
=
127
-
15
;
m
<
<
=
13
;
u
.
u32
=
(
uint32_t
(
s
)
<
<
31
)
|
(
e
<
<
23
)
|
m
;
return
u
.
f32
;
}
inline
uint32_t
specialization_constant_id
(
uint32_t
col
uint32_t
row
)
const
{
return
m
.
c
[
col
]
.
id
[
row
]
;
}
inline
uint32_t
specialization_constant_id
(
uint32_t
col
)
const
{
return
m
.
id
[
col
]
;
}
inline
uint32_t
scalar
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
m
.
c
[
col
]
.
r
[
row
]
.
u32
;
}
inline
int16_t
scalar_i16
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
int16_t
(
m
.
c
[
col
]
.
r
[
row
]
.
u32
&
0xffffu
)
;
}
inline
uint16_t
scalar_u16
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
uint16_t
(
m
.
c
[
col
]
.
r
[
row
]
.
u32
&
0xffffu
)
;
}
inline
int8_t
scalar_i8
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
int8_t
(
m
.
c
[
col
]
.
r
[
row
]
.
u32
&
0xffu
)
;
}
inline
uint8_t
scalar_u8
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
uint8_t
(
m
.
c
[
col
]
.
r
[
row
]
.
u32
&
0xffu
)
;
}
inline
float
scalar_f16
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
f16_to_f32
(
scalar_u16
(
col
row
)
)
;
}
inline
float
scalar_f32
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
m
.
c
[
col
]
.
r
[
row
]
.
f32
;
}
inline
int32_t
scalar_i32
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
m
.
c
[
col
]
.
r
[
row
]
.
i32
;
}
inline
double
scalar_f64
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
m
.
c
[
col
]
.
r
[
row
]
.
f64
;
}
inline
int64_t
scalar_i64
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
m
.
c
[
col
]
.
r
[
row
]
.
i64
;
}
inline
uint64_t
scalar_u64
(
uint32_t
col
=
0
uint32_t
row
=
0
)
const
{
return
m
.
c
[
col
]
.
r
[
row
]
.
u64
;
}
inline
const
ConstantVector
&
vector
(
)
const
{
return
m
.
c
[
0
]
;
}
inline
uint32_t
vector_size
(
)
const
{
return
m
.
c
[
0
]
.
vecsize
;
}
inline
uint32_t
columns
(
)
const
{
return
m
.
columns
;
}
inline
void
make_null
(
const
SPIRType
&
constant_type_
)
{
m
=
{
}
;
m
.
columns
=
constant_type_
.
columns
;
for
(
auto
&
c
:
m
.
c
)
c
.
vecsize
=
constant_type_
.
vecsize
;
}
inline
bool
constant_is_null
(
)
const
{
if
(
specialization
)
return
false
;
if
(
!
subconstants
.
empty
(
)
)
return
false
;
for
(
uint32_t
col
=
0
;
col
<
columns
(
)
;
col
+
+
)
for
(
uint32_t
row
=
0
;
row
<
vector_size
(
)
;
row
+
+
)
if
(
scalar_u64
(
col
row
)
!
=
0
)
return
false
;
return
true
;
}
explicit
SPIRConstant
(
uint32_t
constant_type_
)
:
constant_type
(
constant_type_
)
{
}
SPIRConstant
(
)
=
default
;
SPIRConstant
(
TypeID
constant_type_
const
uint32_t
*
elements
uint32_t
num_elements
bool
specialized
)
:
constant_type
(
constant_type_
)
specialization
(
specialized
)
{
subconstants
.
reserve
(
num_elements
)
;
for
(
uint32_t
i
=
0
;
i
<
num_elements
;
i
+
+
)
subconstants
.
push_back
(
elements
[
i
]
)
;
specialization
=
specialized
;
}
SPIRConstant
(
TypeID
constant_type_
uint32_t
v0
bool
specialized
)
:
constant_type
(
constant_type_
)
specialization
(
specialized
)
{
m
.
c
[
0
]
.
r
[
0
]
.
u32
=
v0
;
m
.
c
[
0
]
.
vecsize
=
1
;
m
.
columns
=
1
;
}
SPIRConstant
(
TypeID
constant_type_
uint64_t
v0
bool
specialized
)
:
constant_type
(
constant_type_
)
specialization
(
specialized
)
{
m
.
c
[
0
]
.
r
[
0
]
.
u64
=
v0
;
m
.
c
[
0
]
.
vecsize
=
1
;
m
.
columns
=
1
;
}
SPIRConstant
(
TypeID
constant_type_
const
SPIRConstant
*
const
*
vector_elements
uint32_t
num_elements
bool
specialized
)
:
constant_type
(
constant_type_
)
specialization
(
specialized
)
{
bool
matrix
=
vector_elements
[
0
]
-
>
m
.
c
[
0
]
.
vecsize
>
1
;
if
(
matrix
)
{
m
.
columns
=
num_elements
;
for
(
uint32_t
i
=
0
;
i
<
num_elements
;
i
+
+
)
{
m
.
c
[
i
]
=
vector_elements
[
i
]
-
>
m
.
c
[
0
]
;
if
(
vector_elements
[
i
]
-
>
specialization
)
m
.
id
[
i
]
=
vector_elements
[
i
]
-
>
self
;
}
}
else
{
m
.
c
[
0
]
.
vecsize
=
num_elements
;
m
.
columns
=
1
;
for
(
uint32_t
i
=
0
;
i
<
num_elements
;
i
+
+
)
{
m
.
c
[
0
]
.
r
[
i
]
=
vector_elements
[
i
]
-
>
m
.
c
[
0
]
.
r
[
0
]
;
if
(
vector_elements
[
i
]
-
>
specialization
)
m
.
c
[
0
]
.
id
[
i
]
=
vector_elements
[
i
]
-
>
self
;
}
}
}
TypeID
constant_type
=
0
;
ConstantMatrix
m
;
bool
specialization
=
false
;
bool
is_used_as_array_length
=
false
;
bool
is_used_as_lut
=
false
;
SmallVector
<
ConstantID
>
subconstants
;
std
:
:
string
specialization_constant_macro_name
;
SPIRV_CROSS_DECLARE_CLONE
(
SPIRConstant
)
}
;
struct
ObjectPoolGroup
{
std
:
:
unique_ptr
<
ObjectPoolBase
>
pools
[
TypeCount
]
;
}
;
class
Variant
{
public
:
explicit
Variant
(
ObjectPoolGroup
*
group_
)
:
group
(
group_
)
{
}
~
Variant
(
)
{
if
(
holder
)
group
-
>
pools
[
type
]
-
>
free_opaque
(
holder
)
;
}
Variant
(
Variant
&
&
other
)
SPIRV_CROSS_NOEXCEPT
{
*
this
=
std
:
:
move
(
other
)
;
}
Variant
(
const
Variant
&
variant
)
=
delete
;
Variant
&
operator
=
(
Variant
&
&
other
)
SPIRV_CROSS_NOEXCEPT
{
if
(
this
!
=
&
other
)
{
if
(
holder
)
group
-
>
pools
[
type
]
-
>
free_opaque
(
holder
)
;
holder
=
other
.
holder
;
group
=
other
.
group
;
type
=
other
.
type
;
allow_type_rewrite
=
other
.
allow_type_rewrite
;
other
.
holder
=
nullptr
;
other
.
type
=
TypeNone
;
}
return
*
this
;
}
Variant
&
operator
=
(
const
Variant
&
other
)
{
#
ifdef
SPIRV_CROSS_COPY_CONSTRUCTOR_SANITIZE
abort
(
)
;
#
endif
if
(
this
!
=
&
other
)
{
if
(
holder
)
group
-
>
pools
[
type
]
-
>
free_opaque
(
holder
)
;
if
(
other
.
holder
)
holder
=
other
.
holder
-
>
clone
(
group
-
>
pools
[
other
.
type
]
.
get
(
)
)
;
else
holder
=
nullptr
;
type
=
other
.
type
;
allow_type_rewrite
=
other
.
allow_type_rewrite
;
}
return
*
this
;
}
void
set
(
IVariant
*
val
Types
new_type
)
{
if
(
holder
)
group
-
>
pools
[
type
]
-
>
free_opaque
(
holder
)
;
holder
=
nullptr
;
if
(
!
allow_type_rewrite
&
&
type
!
=
TypeNone
&
&
type
!
=
new_type
)
{
if
(
val
)
group
-
>
pools
[
new_type
]
-
>
free_opaque
(
val
)
;
SPIRV_CROSS_THROW
(
"
Overwriting
a
variant
with
new
type
.
"
)
;
}
holder
=
val
;
type
=
new_type
;
allow_type_rewrite
=
false
;
}
template
<
typename
T
typename
.
.
.
Ts
>
T
*
allocate_and_set
(
Types
new_type
Ts
&
&
.
.
.
ts
)
{
T
*
val
=
static_cast
<
ObjectPool
<
T
>
&
>
(
*
group
-
>
pools
[
new_type
]
)
.
allocate
(
std
:
:
forward
<
Ts
>
(
ts
)
.
.
.
)
;
set
(
val
new_type
)
;
return
val
;
}
template
<
typename
T
>
T
&
get
(
)
{
if
(
!
holder
)
SPIRV_CROSS_THROW
(
"
nullptr
"
)
;
if
(
static_cast
<
Types
>
(
T
:
:
type
)
!
=
type
)
SPIRV_CROSS_THROW
(
"
Bad
cast
"
)
;
return
*
static_cast
<
T
*
>
(
holder
)
;
}
template
<
typename
T
>
const
T
&
get
(
)
const
{
if
(
!
holder
)
SPIRV_CROSS_THROW
(
"
nullptr
"
)
;
if
(
static_cast
<
Types
>
(
T
:
:
type
)
!
=
type
)
SPIRV_CROSS_THROW
(
"
Bad
cast
"
)
;
return
*
static_cast
<
const
T
*
>
(
holder
)
;
}
Types
get_type
(
)
const
{
return
type
;
}
ID
get_id
(
)
const
{
return
holder
?
holder
-
>
self
:
ID
(
0
)
;
}
bool
empty
(
)
const
{
return
!
holder
;
}
void
reset
(
)
{
if
(
holder
)
group
-
>
pools
[
type
]
-
>
free_opaque
(
holder
)
;
holder
=
nullptr
;
type
=
TypeNone
;
}
void
set_allow_type_rewrite
(
)
{
allow_type_rewrite
=
true
;
}
private
:
ObjectPoolGroup
*
group
=
nullptr
;
IVariant
*
holder
=
nullptr
;
Types
type
=
TypeNone
;
bool
allow_type_rewrite
=
false
;
}
;
template
<
typename
T
>
T
&
variant_get
(
Variant
&
var
)
{
return
var
.
get
<
T
>
(
)
;
}
template
<
typename
T
>
const
T
&
variant_get
(
const
Variant
&
var
)
{
return
var
.
get
<
T
>
(
)
;
}
template
<
typename
T
typename
.
.
.
P
>
T
&
variant_set
(
Variant
&
var
P
&
&
.
.
.
args
)
{
auto
*
ptr
=
var
.
allocate_and_set
<
T
>
(
static_cast
<
Types
>
(
T
:
:
type
)
std
:
:
forward
<
P
>
(
args
)
.
.
.
)
;
return
*
ptr
;
}
struct
AccessChainMeta
{
uint32_t
storage_physical_type
=
0
;
bool
need_transpose
=
false
;
bool
storage_is_packed
=
false
;
bool
storage_is_invariant
=
false
;
}
;
enum
ExtendedDecorations
{
SPIRVCrossDecorationBufferBlockRepacked
=
0
SPIRVCrossDecorationPhysicalTypeID
SPIRVCrossDecorationPhysicalTypePacked
SPIRVCrossDecorationPaddingTarget
SPIRVCrossDecorationInterfaceMemberIndex
SPIRVCrossDecorationInterfaceOrigID
SPIRVCrossDecorationResourceIndexPrimary
SPIRVCrossDecorationResourceIndexSecondary
SPIRVCrossDecorationResourceIndexTertiary
SPIRVCrossDecorationResourceIndexQuaternary
SPIRVCrossDecorationExplicitOffset
SPIRVCrossDecorationBuiltInDispatchBase
SPIRVCrossDecorationDynamicImageSampler
SPIRVCrossDecorationCount
}
;
struct
Meta
{
struct
Decoration
{
std
:
:
string
alias
;
std
:
:
string
qualified_alias
;
std
:
:
string
hlsl_semantic
;
Bitset
decoration_flags
;
spv
:
:
BuiltIn
builtin_type
=
spv
:
:
BuiltInMax
;
uint32_t
location
=
0
;
uint32_t
component
=
0
;
uint32_t
set
=
0
;
uint32_t
binding
=
0
;
uint32_t
offset
=
0
;
uint32_t
array_stride
=
0
;
uint32_t
matrix_stride
=
0
;
uint32_t
input_attachment
=
0
;
uint32_t
spec_id
=
0
;
uint32_t
index
=
0
;
spv
:
:
FPRoundingMode
fp_rounding_mode
=
spv
:
:
FPRoundingModeMax
;
bool
builtin
=
false
;
struct
Extended
{
Extended
(
)
{
for
(
auto
&
v
:
values
)
v
=
0
;
}
Bitset
flags
;
uint32_t
values
[
SPIRVCrossDecorationCount
]
;
}
extended
;
}
;
Decoration
decoration
;
Vector
<
Decoration
>
members
;
std
:
:
unordered_map
<
uint32_t
uint32_t
>
decoration_word_offset
;
bool
hlsl_is_magic_counter_buffer
=
false
;
uint32_t
hlsl_magic_counter_buffer
=
0
;
}
;
using
VariableTypeRemapCallback
=
std
:
:
function
<
void
(
const
SPIRType
&
type
const
std
:
:
string
&
var_name
std
:
:
string
&
name_of_type
)
>
;
class
Hasher
{
public
:
inline
void
u32
(
uint32_t
value
)
{
h
=
(
h
*
0x100000001b3ull
)
^
value
;
}
inline
uint64_t
get
(
)
const
{
return
h
;
}
private
:
uint64_t
h
=
0xcbf29ce484222325ull
;
}
;
static
inline
bool
type_is_floating_point
(
const
SPIRType
&
type
)
{
return
type
.
basetype
=
=
SPIRType
:
:
Half
|
|
type
.
basetype
=
=
SPIRType
:
:
Float
|
|
type
.
basetype
=
=
SPIRType
:
:
Double
;
}
static
inline
bool
type_is_integral
(
const
SPIRType
&
type
)
{
return
type
.
basetype
=
=
SPIRType
:
:
SByte
|
|
type
.
basetype
=
=
SPIRType
:
:
UByte
|
|
type
.
basetype
=
=
SPIRType
:
:
Short
|
|
type
.
basetype
=
=
SPIRType
:
:
UShort
|
|
type
.
basetype
=
=
SPIRType
:
:
Int
|
|
type
.
basetype
=
=
SPIRType
:
:
UInt
|
|
type
.
basetype
=
=
SPIRType
:
:
Int64
|
|
type
.
basetype
=
=
SPIRType
:
:
UInt64
;
}
static
inline
SPIRType
:
:
BaseType
to_signed_basetype
(
uint32_t
width
)
{
switch
(
width
)
{
case
8
:
return
SPIRType
:
:
SByte
;
case
16
:
return
SPIRType
:
:
Short
;
case
32
:
return
SPIRType
:
:
Int
;
case
64
:
return
SPIRType
:
:
Int64
;
default
:
SPIRV_CROSS_THROW
(
"
Invalid
bit
width
.
"
)
;
}
}
static
inline
SPIRType
:
:
BaseType
to_unsigned_basetype
(
uint32_t
width
)
{
switch
(
width
)
{
case
8
:
return
SPIRType
:
:
UByte
;
case
16
:
return
SPIRType
:
:
UShort
;
case
32
:
return
SPIRType
:
:
UInt
;
case
64
:
return
SPIRType
:
:
UInt64
;
default
:
SPIRV_CROSS_THROW
(
"
Invalid
bit
width
.
"
)
;
}
}
static
inline
bool
opcode_is_sign_invariant
(
spv
:
:
Op
opcode
)
{
switch
(
opcode
)
{
case
spv
:
:
OpIEqual
:
case
spv
:
:
OpINotEqual
:
case
spv
:
:
OpISub
:
case
spv
:
:
OpIAdd
:
case
spv
:
:
OpIMul
:
case
spv
:
:
OpShiftLeftLogical
:
case
spv
:
:
OpBitwiseOr
:
case
spv
:
:
OpBitwiseXor
:
case
spv
:
:
OpBitwiseAnd
:
return
true
;
default
:
return
false
;
}
}
}
namespace
std
{
template
<
SPIRV_CROSS_NAMESPACE
:
:
Types
type
>
struct
hash
<
SPIRV_CROSS_NAMESPACE
:
:
TypedID
<
type
>
>
{
size_t
operator
(
)
(
const
SPIRV_CROSS_NAMESPACE
:
:
TypedID
<
type
>
&
value
)
const
{
return
std
:
:
hash
<
uint32_t
>
(
)
(
value
)
;
}
}
;
}
#
endif
