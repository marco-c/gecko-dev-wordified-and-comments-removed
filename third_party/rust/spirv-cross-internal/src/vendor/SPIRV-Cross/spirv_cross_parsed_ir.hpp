#
ifndef
SPIRV_CROSS_PARSED_IR_HPP
#
define
SPIRV_CROSS_PARSED_IR_HPP
#
include
"
spirv_common
.
hpp
"
#
include
<
stdint
.
h
>
#
include
<
unordered_map
>
namespace
SPIRV_CROSS_NAMESPACE
{
class
ParsedIR
{
private
:
std
:
:
unique_ptr
<
ObjectPoolGroup
>
pool_group
;
public
:
ParsedIR
(
)
;
ParsedIR
(
const
ParsedIR
&
other
)
;
ParsedIR
&
operator
=
(
const
ParsedIR
&
other
)
;
ParsedIR
(
ParsedIR
&
&
other
)
SPIRV_CROSS_NOEXCEPT
;
ParsedIR
&
operator
=
(
ParsedIR
&
&
other
)
SPIRV_CROSS_NOEXCEPT
;
void
set_id_bounds
(
uint32_t
bounds
)
;
std
:
:
vector
<
uint32_t
>
spirv
;
SmallVector
<
Variant
>
ids
;
std
:
:
unordered_map
<
ID
Meta
>
meta
;
SmallVector
<
ID
>
ids_for_type
[
TypeCount
]
;
SmallVector
<
ID
>
ids_for_constant_or_type
;
SmallVector
<
ID
>
ids_for_constant_or_variable
;
SmallVector
<
spv
:
:
Capability
>
declared_capabilities
;
SmallVector
<
std
:
:
string
>
declared_extensions
;
enum
BlockMetaFlagBits
{
BLOCK_META_LOOP_HEADER_BIT
=
1
<
<
0
BLOCK_META_CONTINUE_BIT
=
1
<
<
1
BLOCK_META_LOOP_MERGE_BIT
=
1
<
<
2
BLOCK_META_SELECTION_MERGE_BIT
=
1
<
<
3
BLOCK_META_MULTISELECT_MERGE_BIT
=
1
<
<
4
}
;
using
BlockMetaFlags
=
uint8_t
;
SmallVector
<
BlockMetaFlags
>
block_meta
;
std
:
:
unordered_map
<
BlockID
BlockID
>
continue_block_to_loop_header
;
std
:
:
unordered_map
<
FunctionID
SPIREntryPoint
>
entry_points
;
FunctionID
default_entry_point
=
0
;
struct
Source
{
uint32_t
version
=
0
;
bool
es
=
false
;
bool
known
=
false
;
bool
hlsl
=
false
;
Source
(
)
=
default
;
}
;
Source
source
;
spv
:
:
AddressingModel
addressing_model
=
spv
:
:
AddressingModelMax
;
spv
:
:
MemoryModel
memory_model
=
spv
:
:
MemoryModelMax
;
void
set_name
(
ID
id
const
std
:
:
string
&
name
)
;
const
std
:
:
string
&
get_name
(
ID
id
)
const
;
void
set_decoration
(
ID
id
spv
:
:
Decoration
decoration
uint32_t
argument
=
0
)
;
void
set_decoration_string
(
ID
id
spv
:
:
Decoration
decoration
const
std
:
:
string
&
argument
)
;
bool
has_decoration
(
ID
id
spv
:
:
Decoration
decoration
)
const
;
uint32_t
get_decoration
(
ID
id
spv
:
:
Decoration
decoration
)
const
;
const
std
:
:
string
&
get_decoration_string
(
ID
id
spv
:
:
Decoration
decoration
)
const
;
const
Bitset
&
get_decoration_bitset
(
ID
id
)
const
;
void
unset_decoration
(
ID
id
spv
:
:
Decoration
decoration
)
;
void
set_member_name
(
TypeID
id
uint32_t
index
const
std
:
:
string
&
name
)
;
const
std
:
:
string
&
get_member_name
(
TypeID
id
uint32_t
index
)
const
;
void
set_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
uint32_t
argument
=
0
)
;
void
set_member_decoration_string
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
const
std
:
:
string
&
argument
)
;
uint32_t
get_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
const
;
const
std
:
:
string
&
get_member_decoration_string
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
const
;
bool
has_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
const
;
const
Bitset
&
get_member_decoration_bitset
(
TypeID
id
uint32_t
index
)
const
;
void
unset_member_decoration
(
TypeID
id
uint32_t
index
spv
:
:
Decoration
decoration
)
;
void
mark_used_as_array_length
(
ID
id
)
;
uint32_t
increase_bound_by
(
uint32_t
count
)
;
Bitset
get_buffer_block_flags
(
const
SPIRVariable
&
var
)
const
;
void
add_typed_id
(
Types
type
ID
id
)
;
void
remove_typed_id
(
Types
type
ID
id
)
;
class
LoopLock
{
public
:
explicit
LoopLock
(
uint32_t
*
counter
)
;
LoopLock
(
const
LoopLock
&
)
=
delete
;
void
operator
=
(
const
LoopLock
&
)
=
delete
;
LoopLock
(
LoopLock
&
&
other
)
SPIRV_CROSS_NOEXCEPT
;
LoopLock
&
operator
=
(
LoopLock
&
&
other
)
SPIRV_CROSS_NOEXCEPT
;
~
LoopLock
(
)
;
private
:
uint32_t
*
lock
;
}
;
LoopLock
create_loop_hard_lock
(
)
const
;
LoopLock
create_loop_soft_lock
(
)
const
;
template
<
typename
T
typename
Op
>
void
for_each_typed_id
(
const
Op
&
op
)
{
auto
loop_lock
=
create_loop_hard_lock
(
)
;
for
(
auto
&
id
:
ids_for_type
[
T
:
:
type
]
)
{
if
(
ids
[
id
]
.
get_type
(
)
=
=
static_cast
<
Types
>
(
T
:
:
type
)
)
op
(
id
get
<
T
>
(
id
)
)
;
}
}
template
<
typename
T
typename
Op
>
void
for_each_typed_id
(
const
Op
&
op
)
const
{
auto
loop_lock
=
create_loop_hard_lock
(
)
;
for
(
auto
&
id
:
ids_for_type
[
T
:
:
type
]
)
{
if
(
ids
[
id
]
.
get_type
(
)
=
=
static_cast
<
Types
>
(
T
:
:
type
)
)
op
(
id
get
<
T
>
(
id
)
)
;
}
}
template
<
typename
T
>
void
reset_all_of_type
(
)
{
reset_all_of_type
(
static_cast
<
Types
>
(
T
:
:
type
)
)
;
}
void
reset_all_of_type
(
Types
type
)
;
Meta
*
find_meta
(
ID
id
)
;
const
Meta
*
find_meta
(
ID
id
)
const
;
const
std
:
:
string
&
get_empty_string
(
)
const
{
return
empty_string
;
}
void
make_constant_null
(
uint32_t
id
uint32_t
type
bool
add_to_typed_id_set
)
;
void
fixup_reserved_names
(
)
;
static
void
sanitize_underscores
(
std
:
:
string
&
str
)
;
static
void
sanitize_identifier
(
std
:
:
string
&
str
bool
member
bool
allow_reserved_prefixes
)
;
static
bool
is_globally_reserved_identifier
(
std
:
:
string
&
str
bool
allow_reserved_prefixes
)
;
private
:
template
<
typename
T
>
T
&
get
(
uint32_t
id
)
{
return
variant_get
<
T
>
(
ids
[
id
]
)
;
}
template
<
typename
T
>
const
T
&
get
(
uint32_t
id
)
const
{
return
variant_get
<
T
>
(
ids
[
id
]
)
;
}
mutable
uint32_t
loop_iteration_depth_hard
=
0
;
mutable
uint32_t
loop_iteration_depth_soft
=
0
;
std
:
:
string
empty_string
;
Bitset
cleared_bitset
;
std
:
:
unordered_set
<
uint32_t
>
meta_needing_name_fixup
;
}
;
}
#
endif
