#
include
"
spirv_cfg
.
hpp
"
#
include
"
spirv_cross
.
hpp
"
#
include
<
algorithm
>
#
include
<
assert
.
h
>
using
namespace
std
;
namespace
SPIRV_CROSS_NAMESPACE
{
CFG
:
:
CFG
(
Compiler
&
compiler_
const
SPIRFunction
&
func_
)
:
compiler
(
compiler_
)
func
(
func_
)
{
build_post_order_visit_order
(
)
;
build_immediate_dominators
(
)
;
}
uint32_t
CFG
:
:
find_common_dominator
(
uint32_t
a
uint32_t
b
)
const
{
while
(
a
!
=
b
)
{
if
(
get_visit_order
(
a
)
<
get_visit_order
(
b
)
)
a
=
get_immediate_dominator
(
a
)
;
else
b
=
get_immediate_dominator
(
b
)
;
}
return
a
;
}
void
CFG
:
:
build_immediate_dominators
(
)
{
immediate_dominators
.
clear
(
)
;
immediate_dominators
[
func
.
entry_block
]
=
func
.
entry_block
;
for
(
auto
i
=
post_order
.
size
(
)
;
i
;
i
-
-
)
{
uint32_t
block
=
post_order
[
i
-
1
]
;
auto
&
pred
=
preceding_edges
[
block
]
;
if
(
pred
.
empty
(
)
)
continue
;
for
(
auto
&
edge
:
pred
)
{
if
(
immediate_dominators
[
block
]
)
{
assert
(
immediate_dominators
[
edge
]
)
;
immediate_dominators
[
block
]
=
find_common_dominator
(
immediate_dominators
[
block
]
edge
)
;
}
else
immediate_dominators
[
block
]
=
edge
;
}
}
}
bool
CFG
:
:
is_back_edge
(
uint32_t
to
)
const
{
auto
itr
=
visit_order
.
find
(
to
)
;
return
itr
!
=
end
(
visit_order
)
&
&
itr
-
>
second
.
get
(
)
=
=
0
;
}
bool
CFG
:
:
has_visited_forward_edge
(
uint32_t
to
)
const
{
auto
itr
=
visit_order
.
find
(
to
)
;
return
itr
!
=
end
(
visit_order
)
&
&
itr
-
>
second
.
get
(
)
>
0
;
}
bool
CFG
:
:
post_order_visit
(
uint32_t
block_id
)
{
if
(
has_visited_forward_edge
(
block_id
)
)
return
true
;
else
if
(
is_back_edge
(
block_id
)
)
return
false
;
visit_order
[
block_id
]
.
get
(
)
=
0
;
auto
&
block
=
compiler
.
get
<
SPIRBlock
>
(
block_id
)
;
if
(
block
.
merge
=
=
SPIRBlock
:
:
MergeLoop
&
&
post_order_visit
(
block
.
merge_block
)
)
add_branch
(
block_id
block
.
merge_block
)
;
switch
(
block
.
terminator
)
{
case
SPIRBlock
:
:
Direct
:
if
(
post_order_visit
(
block
.
next_block
)
)
add_branch
(
block_id
block
.
next_block
)
;
break
;
case
SPIRBlock
:
:
Select
:
if
(
post_order_visit
(
block
.
true_block
)
)
add_branch
(
block_id
block
.
true_block
)
;
if
(
post_order_visit
(
block
.
false_block
)
)
add_branch
(
block_id
block
.
false_block
)
;
break
;
case
SPIRBlock
:
:
MultiSelect
:
for
(
auto
&
target
:
block
.
cases
)
{
if
(
post_order_visit
(
target
.
block
)
)
add_branch
(
block_id
target
.
block
)
;
}
if
(
block
.
default_block
&
&
post_order_visit
(
block
.
default_block
)
)
add_branch
(
block_id
block
.
default_block
)
;
break
;
default
:
break
;
}
if
(
block
.
merge
=
=
SPIRBlock
:
:
MergeSelection
&
&
post_order_visit
(
block
.
next_block
)
)
{
auto
pred_itr
=
preceding_edges
.
find
(
block
.
next_block
)
;
if
(
pred_itr
!
=
end
(
preceding_edges
)
)
{
auto
&
pred
=
pred_itr
-
>
second
;
auto
succ_itr
=
succeeding_edges
.
find
(
block_id
)
;
size_t
num_succeeding_edges
=
0
;
if
(
succ_itr
!
=
end
(
succeeding_edges
)
)
num_succeeding_edges
=
succ_itr
-
>
second
.
size
(
)
;
if
(
block
.
terminator
=
=
SPIRBlock
:
:
MultiSelect
&
&
num_succeeding_edges
=
=
1
)
{
if
(
!
pred
.
empty
(
)
)
add_branch
(
block_id
block
.
next_block
)
;
}
else
{
if
(
pred
.
size
(
)
=
=
1
&
&
*
pred
.
begin
(
)
!
=
block_id
)
add_branch
(
block_id
block
.
next_block
)
;
}
}
else
{
add_branch
(
block_id
block
.
next_block
)
;
}
}
visit_order
[
block_id
]
.
get
(
)
=
+
+
visit_count
;
post_order
.
push_back
(
block_id
)
;
return
true
;
}
void
CFG
:
:
build_post_order_visit_order
(
)
{
uint32_t
block
=
func
.
entry_block
;
visit_count
=
0
;
visit_order
.
clear
(
)
;
post_order
.
clear
(
)
;
post_order_visit
(
block
)
;
}
void
CFG
:
:
add_branch
(
uint32_t
from
uint32_t
to
)
{
const
auto
add_unique
=
[
]
(
SmallVector
<
uint32_t
>
&
l
uint32_t
value
)
{
auto
itr
=
find
(
begin
(
l
)
end
(
l
)
value
)
;
if
(
itr
=
=
end
(
l
)
)
l
.
push_back
(
value
)
;
}
;
add_unique
(
preceding_edges
[
to
]
from
)
;
add_unique
(
succeeding_edges
[
from
]
to
)
;
}
uint32_t
CFG
:
:
find_loop_dominator
(
uint32_t
block_id
)
const
{
while
(
block_id
!
=
SPIRBlock
:
:
NoDominator
)
{
auto
itr
=
preceding_edges
.
find
(
block_id
)
;
if
(
itr
=
=
end
(
preceding_edges
)
)
return
SPIRBlock
:
:
NoDominator
;
if
(
itr
-
>
second
.
empty
(
)
)
return
SPIRBlock
:
:
NoDominator
;
uint32_t
pred_block_id
=
SPIRBlock
:
:
NoDominator
;
bool
ignore_loop_header
=
false
;
for
(
auto
&
pred
:
itr
-
>
second
)
{
auto
&
pred_block
=
compiler
.
get
<
SPIRBlock
>
(
pred
)
;
if
(
pred_block
.
merge
=
=
SPIRBlock
:
:
MergeLoop
&
&
pred_block
.
merge_block
=
=
ID
(
block_id
)
)
{
pred_block_id
=
pred
;
ignore_loop_header
=
true
;
break
;
}
else
if
(
pred_block
.
merge
=
=
SPIRBlock
:
:
MergeSelection
&
&
pred_block
.
next_block
=
=
ID
(
block_id
)
)
{
pred_block_id
=
pred
;
break
;
}
}
if
(
pred_block_id
=
=
SPIRBlock
:
:
NoDominator
)
pred_block_id
=
itr
-
>
second
.
front
(
)
;
block_id
=
pred_block_id
;
if
(
!
ignore_loop_header
&
&
block_id
)
{
auto
&
block
=
compiler
.
get
<
SPIRBlock
>
(
block_id
)
;
if
(
block
.
merge
=
=
SPIRBlock
:
:
MergeLoop
)
return
block_id
;
}
}
return
block_id
;
}
bool
CFG
:
:
node_terminates_control_flow_in_sub_graph
(
BlockID
from
BlockID
to
)
const
{
auto
&
from_block
=
compiler
.
get
<
SPIRBlock
>
(
from
)
;
BlockID
ignore_block_id
=
0
;
if
(
from_block
.
merge
=
=
SPIRBlock
:
:
MergeLoop
)
ignore_block_id
=
from_block
.
merge_block
;
while
(
to
!
=
from
)
{
auto
pred_itr
=
preceding_edges
.
find
(
to
)
;
if
(
pred_itr
=
=
end
(
preceding_edges
)
)
return
false
;
DominatorBuilder
builder
(
*
this
)
;
for
(
auto
&
edge
:
pred_itr
-
>
second
)
builder
.
add_block
(
edge
)
;
uint32_t
dominator
=
builder
.
get_dominator
(
)
;
if
(
dominator
=
=
0
)
return
false
;
auto
&
dom
=
compiler
.
get
<
SPIRBlock
>
(
dominator
)
;
bool
true_path_ignore
=
false
;
bool
false_path_ignore
=
false
;
if
(
ignore_block_id
&
&
dom
.
terminator
=
=
SPIRBlock
:
:
Select
)
{
auto
&
true_block
=
compiler
.
get
<
SPIRBlock
>
(
dom
.
true_block
)
;
auto
&
false_block
=
compiler
.
get
<
SPIRBlock
>
(
dom
.
false_block
)
;
auto
&
ignore_block
=
compiler
.
get
<
SPIRBlock
>
(
ignore_block_id
)
;
true_path_ignore
=
compiler
.
execution_is_branchless
(
true_block
ignore_block
)
;
false_path_ignore
=
compiler
.
execution_is_branchless
(
false_block
ignore_block
)
;
}
if
(
(
dom
.
merge
=
=
SPIRBlock
:
:
MergeSelection
&
&
dom
.
next_block
=
=
to
)
|
|
(
dom
.
merge
=
=
SPIRBlock
:
:
MergeLoop
&
&
dom
.
merge_block
=
=
to
)
|
|
(
dom
.
terminator
=
=
SPIRBlock
:
:
Direct
&
&
dom
.
next_block
=
=
to
)
|
|
(
dom
.
terminator
=
=
SPIRBlock
:
:
Select
&
&
dom
.
true_block
=
=
to
&
&
false_path_ignore
)
|
|
(
dom
.
terminator
=
=
SPIRBlock
:
:
Select
&
&
dom
.
false_block
=
=
to
&
&
true_path_ignore
)
)
{
to
=
dominator
;
}
else
return
false
;
}
return
true
;
}
DominatorBuilder
:
:
DominatorBuilder
(
const
CFG
&
cfg_
)
:
cfg
(
cfg_
)
{
}
void
DominatorBuilder
:
:
add_block
(
uint32_t
block
)
{
if
(
!
cfg
.
get_immediate_dominator
(
block
)
)
{
return
;
}
if
(
!
dominator
)
{
dominator
=
block
;
return
;
}
if
(
block
!
=
dominator
)
dominator
=
cfg
.
find_common_dominator
(
block
dominator
)
;
}
void
DominatorBuilder
:
:
lift_continue_block_dominator
(
)
{
if
(
!
dominator
)
return
;
auto
&
block
=
cfg
.
get_compiler
(
)
.
get
<
SPIRBlock
>
(
dominator
)
;
auto
post_order
=
cfg
.
get_visit_order
(
dominator
)
;
bool
back_edge_dominator
=
false
;
switch
(
block
.
terminator
)
{
case
SPIRBlock
:
:
Direct
:
if
(
cfg
.
get_visit_order
(
block
.
next_block
)
>
post_order
)
back_edge_dominator
=
true
;
break
;
case
SPIRBlock
:
:
Select
:
if
(
cfg
.
get_visit_order
(
block
.
true_block
)
>
post_order
)
back_edge_dominator
=
true
;
if
(
cfg
.
get_visit_order
(
block
.
false_block
)
>
post_order
)
back_edge_dominator
=
true
;
break
;
case
SPIRBlock
:
:
MultiSelect
:
for
(
auto
&
target
:
block
.
cases
)
{
if
(
cfg
.
get_visit_order
(
target
.
block
)
>
post_order
)
back_edge_dominator
=
true
;
}
if
(
block
.
default_block
&
&
cfg
.
get_visit_order
(
block
.
default_block
)
>
post_order
)
back_edge_dominator
=
true
;
break
;
default
:
break
;
}
if
(
back_edge_dominator
)
dominator
=
cfg
.
get_function
(
)
.
entry_block
;
}
}
