mod
slice_impl
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
vec_impl
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
iter
:
:
DoubleEndedIterator
;
use
core
:
:
iter
:
:
FromIterator
;
use
core
:
:
iter
:
:
Iterator
;
use
core
:
:
ops
:
:
Range
;
pub
trait
StoreConstEmpty
<
K
:
?
Sized
V
:
?
Sized
>
{
const
EMPTY
:
Self
;
}
pub
trait
Store
<
K
:
?
Sized
V
:
?
Sized
>
:
Sized
{
fn
lm_len
(
&
self
)
-
>
usize
;
fn
lm_is_empty
(
&
self
)
-
>
bool
{
self
.
lm_len
(
)
=
=
0
}
fn
lm_get
(
&
self
index
:
usize
)
-
>
Option
<
(
&
K
&
V
)
>
;
fn
lm_last
(
&
self
)
-
>
Option
<
(
&
K
&
V
)
>
{
let
len
=
self
.
lm_len
(
)
;
if
len
=
=
0
{
None
}
else
{
self
.
lm_get
(
len
-
1
)
}
}
fn
lm_binary_search_by
<
F
>
(
&
self
cmp
:
F
)
-
>
Result
<
usize
usize
>
where
F
:
FnMut
(
&
K
)
-
>
Ordering
;
}
pub
trait
StoreFromIterable
<
K
V
>
:
Store
<
K
V
>
{
fn
lm_sort_from_iter
<
I
:
IntoIterator
<
Item
=
(
K
V
)
>
>
(
iter
:
I
)
-
>
Self
;
}
pub
trait
StoreSlice
<
K
:
?
Sized
V
:
?
Sized
>
:
Store
<
K
V
>
{
type
Slice
:
?
Sized
;
fn
lm_get_range
(
&
self
range
:
Range
<
usize
>
)
-
>
Option
<
&
Self
:
:
Slice
>
;
}
pub
trait
StoreMut
<
K
V
>
:
Store
<
K
V
>
{
fn
lm_with_capacity
(
capacity
:
usize
)
-
>
Self
;
fn
lm_reserve
(
&
mut
self
additional
:
usize
)
;
fn
lm_get_mut
(
&
mut
self
index
:
usize
)
-
>
Option
<
(
&
K
&
mut
V
)
>
;
fn
lm_push
(
&
mut
self
key
:
K
value
:
V
)
;
fn
lm_insert
(
&
mut
self
index
:
usize
key
:
K
value
:
V
)
;
fn
lm_remove
(
&
mut
self
index
:
usize
)
-
>
(
K
V
)
;
fn
lm_clear
(
&
mut
self
)
;
fn
lm_retain
<
F
>
(
&
mut
self
mut
predicate
:
F
)
where
F
:
FnMut
(
&
K
&
V
)
-
>
bool
{
let
mut
i
=
0
;
while
i
<
self
.
lm_len
(
)
{
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
(
k
v
)
=
self
.
lm_get
(
i
)
.
unwrap
(
)
;
if
predicate
(
k
v
)
{
i
+
=
1
;
}
else
{
self
.
lm_remove
(
i
)
;
}
}
}
}
pub
trait
StoreIterable
<
'
a
K
:
'
a
+
?
Sized
V
:
'
a
+
?
Sized
>
:
Store
<
K
V
>
{
type
KeyValueIter
:
Iterator
<
Item
=
(
&
'
a
K
&
'
a
V
)
>
+
DoubleEndedIterator
+
'
a
;
fn
lm_iter
(
&
'
a
self
)
-
>
Self
:
:
KeyValueIter
;
}
pub
trait
StoreIterableMut
<
'
a
K
:
'
a
V
:
'
a
>
:
StoreMut
<
K
V
>
+
StoreIterable
<
'
a
K
V
>
{
type
KeyValueIterMut
:
Iterator
<
Item
=
(
&
'
a
K
&
'
a
mut
V
)
>
+
DoubleEndedIterator
+
'
a
;
fn
lm_iter_mut
(
&
'
a
mut
self
)
-
>
Self
:
:
KeyValueIterMut
;
}
pub
trait
StoreIntoIterator
<
K
V
>
:
StoreMut
<
K
V
>
{
type
KeyValueIntoIter
:
Iterator
<
Item
=
(
K
V
)
>
;
fn
lm_into_iter
(
self
)
-
>
Self
:
:
KeyValueIntoIter
;
fn
lm_extend_end
(
&
mut
self
other
:
Self
)
where
Self
:
Sized
{
for
item
in
other
.
lm_into_iter
(
)
{
self
.
lm_push
(
item
.
0
item
.
1
)
;
}
}
fn
lm_extend_start
(
&
mut
self
other
:
Self
)
where
Self
:
Sized
{
for
(
i
item
)
in
other
.
lm_into_iter
(
)
.
enumerate
(
)
{
self
.
lm_insert
(
i
item
.
0
item
.
1
)
;
}
}
}
pub
trait
StoreFromIterator
<
K
V
>
:
FromIterator
<
(
K
V
)
>
{
}
