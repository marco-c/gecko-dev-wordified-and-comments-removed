macro_rules
!
impl_cons_iter
(
(
_A
:
ident
_B
:
ident
)
=
>
(
)
;
(
A
:
ident
(
B
:
ident
)
*
)
=
>
(
impl_cons_iter
!
(
(
B
)
*
)
;
#
[
allow
(
non_snake_case
)
]
impl
<
X
Iter
(
B
)
*
>
Iterator
for
ConsTuples
<
Iter
(
(
(
B
)
*
)
X
)
>
where
Iter
:
Iterator
<
Item
=
(
(
(
B
)
*
)
X
)
>
{
type
Item
=
(
(
B
)
*
X
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
(
(
B
)
*
)
x
)
|
(
(
B
)
*
x
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
#
[
allow
(
non_snake_case
)
]
impl
<
X
Iter
(
B
)
*
>
DoubleEndedIterator
for
ConsTuples
<
Iter
(
(
(
B
)
*
)
X
)
>
where
Iter
:
DoubleEndedIterator
<
Item
=
(
(
(
B
)
*
)
X
)
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
next
(
)
.
map
(
|
(
(
(
B
)
*
)
x
)
|
(
(
B
)
*
x
)
)
}
}
)
;
)
;
impl_cons_iter
!
(
A
B
C
D
E
F
G
H
)
;
pub
struct
ConsTuples
<
I
J
>
where
I
:
Iterator
<
Item
=
J
>
{
iter
:
I
}
impl
<
I
J
>
Clone
for
ConsTuples
<
I
J
>
where
I
:
Clone
+
Iterator
<
Item
=
J
>
{
fn
clone
(
&
self
)
-
>
Self
{
ConsTuples
{
iter
:
self
.
iter
.
clone
(
)
}
}
}
pub
fn
cons_tuples
<
I
J
>
(
iterable
:
I
)
-
>
ConsTuples
<
I
J
>
where
I
:
Iterator
<
Item
=
J
>
{
ConsTuples
{
iter
:
iterable
.
into_iter
(
)
}
}
