use
std
:
:
fmt
;
use
std
:
:
iter
:
:
FusedIterator
;
use
super
:
:
lazy_buffer
:
:
LazyBuffer
;
use
alloc
:
:
vec
:
:
Vec
;
#
[
must_use
=
"
iterator
adaptors
are
lazy
and
do
nothing
unless
consumed
"
]
pub
struct
Combinations
<
I
:
Iterator
>
{
indices
:
Vec
<
usize
>
pool
:
LazyBuffer
<
I
>
first
:
bool
}
impl
<
I
>
Clone
for
Combinations
<
I
>
where
I
:
Clone
+
Iterator
I
:
:
Item
:
Clone
{
clone_fields
!
(
indices
pool
first
)
;
}
impl
<
I
>
fmt
:
:
Debug
for
Combinations
<
I
>
where
I
:
Iterator
+
fmt
:
:
Debug
I
:
:
Item
:
fmt
:
:
Debug
{
debug_fmt_fields
!
(
Combinations
indices
pool
first
)
;
}
pub
fn
combinations
<
I
>
(
iter
:
I
k
:
usize
)
-
>
Combinations
<
I
>
where
I
:
Iterator
{
let
mut
pool
=
LazyBuffer
:
:
new
(
iter
)
;
pool
.
prefill
(
k
)
;
Combinations
{
indices
:
(
0
.
.
k
)
.
collect
(
)
pool
first
:
true
}
}
impl
<
I
:
Iterator
>
Combinations
<
I
>
{
#
[
inline
]
pub
fn
k
(
&
self
)
-
>
usize
{
self
.
indices
.
len
(
)
}
#
[
inline
]
pub
fn
n
(
&
self
)
-
>
usize
{
self
.
pool
.
len
(
)
}
#
[
inline
]
pub
(
crate
)
fn
src
(
&
self
)
-
>
&
I
{
&
self
.
pool
.
it
}
pub
(
crate
)
fn
reset
(
&
mut
self
k
:
usize
)
{
self
.
first
=
true
;
if
k
<
self
.
indices
.
len
(
)
{
self
.
indices
.
truncate
(
k
)
;
for
i
in
0
.
.
k
{
self
.
indices
[
i
]
=
i
;
}
}
else
{
for
i
in
0
.
.
self
.
indices
.
len
(
)
{
self
.
indices
[
i
]
=
i
;
}
self
.
indices
.
extend
(
self
.
indices
.
len
(
)
.
.
k
)
;
self
.
pool
.
prefill
(
k
)
;
}
}
}
impl
<
I
>
Iterator
for
Combinations
<
I
>
where
I
:
Iterator
I
:
:
Item
:
Clone
{
type
Item
=
Vec
<
I
:
:
Item
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
first
{
if
self
.
k
(
)
>
self
.
n
(
)
{
return
None
;
}
self
.
first
=
false
;
}
else
if
self
.
indices
.
is_empty
(
)
{
return
None
;
}
else
{
let
mut
i
:
usize
=
self
.
indices
.
len
(
)
-
1
;
if
self
.
indices
[
i
]
=
=
self
.
pool
.
len
(
)
-
1
{
self
.
pool
.
get_next
(
)
;
}
while
self
.
indices
[
i
]
=
=
i
+
self
.
pool
.
len
(
)
-
self
.
indices
.
len
(
)
{
if
i
>
0
{
i
-
=
1
;
}
else
{
return
None
;
}
}
self
.
indices
[
i
]
+
=
1
;
for
j
in
i
+
1
.
.
self
.
indices
.
len
(
)
{
self
.
indices
[
j
]
=
self
.
indices
[
j
-
1
]
+
1
;
}
}
Some
(
self
.
indices
.
iter
(
)
.
map
(
|
i
|
self
.
pool
[
*
i
]
.
clone
(
)
)
.
collect
(
)
)
}
}
impl
<
I
>
FusedIterator
for
Combinations
<
I
>
where
I
:
Iterator
I
:
:
Item
:
Clone
{
}
