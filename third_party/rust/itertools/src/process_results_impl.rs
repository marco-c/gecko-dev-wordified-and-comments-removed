#
[
must_use
=
"
iterator
adaptors
are
lazy
and
do
nothing
unless
consumed
"
]
pub
struct
ProcessResults
<
'
a
I
E
:
'
a
>
{
error
:
&
'
a
mut
Result
<
(
)
E
>
iter
:
I
}
impl
<
'
a
I
T
E
>
Iterator
for
ProcessResults
<
'
a
I
E
>
where
I
:
Iterator
<
Item
=
Result
<
T
E
>
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
match
self
.
iter
.
next
(
)
{
Some
(
Ok
(
x
)
)
=
>
Some
(
x
)
Some
(
Err
(
e
)
)
=
>
{
*
self
.
error
=
Err
(
e
)
;
None
}
None
=
>
None
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
_
hi
)
=
self
.
iter
.
size_hint
(
)
;
(
0
hi
)
}
}
pub
fn
process_results
<
I
F
T
E
R
>
(
iterable
:
I
processor
:
F
)
-
>
Result
<
R
E
>
where
I
:
IntoIterator
<
Item
=
Result
<
T
E
>
>
F
:
FnOnce
(
ProcessResults
<
I
:
:
IntoIter
E
>
)
-
>
R
{
let
iter
=
iterable
.
into_iter
(
)
;
let
mut
error
=
Ok
(
(
)
)
;
let
result
=
processor
(
ProcessResults
{
error
:
&
mut
error
iter
:
iter
}
)
;
error
.
map
(
|
_
|
result
)
}
