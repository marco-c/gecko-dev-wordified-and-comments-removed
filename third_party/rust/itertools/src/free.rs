#
[
cfg
(
feature
=
"
use_alloc
"
)
]
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
iter
:
:
{
self
Zip
}
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
type
VecIntoIter
<
T
>
=
alloc
:
:
vec
:
:
IntoIter
<
T
>
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
use
alloc
:
:
{
string
:
:
String
}
;
use
crate
:
:
Itertools
;
use
crate
:
:
intersperse
:
:
{
Intersperse
IntersperseWith
}
;
pub
use
crate
:
:
adaptors
:
:
{
interleave
merge
put_back
}
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
use
crate
:
:
put_back_n_impl
:
:
put_back_n
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
use
crate
:
:
multipeek_impl
:
:
multipeek
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
use
crate
:
:
peek_nth
:
:
peek_nth
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
use
crate
:
:
kmerge_impl
:
:
kmerge
;
pub
use
crate
:
:
zip_eq_impl
:
:
zip_eq
;
pub
use
crate
:
:
merge_join
:
:
merge_join_by
;
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
use
crate
:
:
rciter_impl
:
:
rciter
;
pub
fn
intersperse
<
I
>
(
iterable
:
I
element
:
I
:
:
Item
)
-
>
Intersperse
<
I
:
:
IntoIter
>
where
I
:
IntoIterator
<
I
as
IntoIterator
>
:
:
Item
:
Clone
{
Itertools
:
:
intersperse
(
iterable
.
into_iter
(
)
element
)
}
pub
fn
intersperse_with
<
I
F
>
(
iterable
:
I
element
:
F
)
-
>
IntersperseWith
<
I
:
:
IntoIter
F
>
where
I
:
IntoIterator
F
:
FnMut
(
)
-
>
I
:
:
Item
{
Itertools
:
:
intersperse_with
(
iterable
.
into_iter
(
)
element
)
}
pub
fn
enumerate
<
I
>
(
iterable
:
I
)
-
>
iter
:
:
Enumerate
<
I
:
:
IntoIter
>
where
I
:
IntoIterator
{
iterable
.
into_iter
(
)
.
enumerate
(
)
}
pub
fn
rev
<
I
>
(
iterable
:
I
)
-
>
iter
:
:
Rev
<
I
:
:
IntoIter
>
where
I
:
IntoIterator
I
:
:
IntoIter
:
DoubleEndedIterator
{
iterable
.
into_iter
(
)
.
rev
(
)
}
pub
fn
zip
<
I
J
>
(
i
:
I
j
:
J
)
-
>
Zip
<
I
:
:
IntoIter
J
:
:
IntoIter
>
where
I
:
IntoIterator
J
:
IntoIterator
{
i
.
into_iter
(
)
.
zip
(
j
)
}
pub
fn
chain
<
I
J
>
(
i
:
I
j
:
J
)
-
>
iter
:
:
Chain
<
<
I
as
IntoIterator
>
:
:
IntoIter
<
J
as
IntoIterator
>
:
:
IntoIter
>
where
I
:
IntoIterator
J
:
IntoIterator
<
Item
=
I
:
:
Item
>
{
i
.
into_iter
(
)
.
chain
(
j
)
}
pub
fn
cloned
<
'
a
I
T
:
'
a
>
(
iterable
:
I
)
-
>
iter
:
:
Cloned
<
I
:
:
IntoIter
>
where
I
:
IntoIterator
<
Item
=
&
'
a
T
>
T
:
Clone
{
iterable
.
into_iter
(
)
.
cloned
(
)
}
pub
fn
fold
<
I
B
F
>
(
iterable
:
I
init
:
B
f
:
F
)
-
>
B
where
I
:
IntoIterator
F
:
FnMut
(
B
I
:
:
Item
)
-
>
B
{
iterable
.
into_iter
(
)
.
fold
(
init
f
)
}
pub
fn
all
<
I
F
>
(
iterable
:
I
f
:
F
)
-
>
bool
where
I
:
IntoIterator
F
:
FnMut
(
I
:
:
Item
)
-
>
bool
{
iterable
.
into_iter
(
)
.
all
(
f
)
}
pub
fn
any
<
I
F
>
(
iterable
:
I
f
:
F
)
-
>
bool
where
I
:
IntoIterator
F
:
FnMut
(
I
:
:
Item
)
-
>
bool
{
iterable
.
into_iter
(
)
.
any
(
f
)
}
pub
fn
max
<
I
>
(
iterable
:
I
)
-
>
Option
<
I
:
:
Item
>
where
I
:
IntoIterator
I
:
:
Item
:
Ord
{
iterable
.
into_iter
(
)
.
max
(
)
}
pub
fn
min
<
I
>
(
iterable
:
I
)
-
>
Option
<
I
:
:
Item
>
where
I
:
IntoIterator
I
:
:
Item
:
Ord
{
iterable
.
into_iter
(
)
.
min
(
)
}
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
fn
join
<
I
>
(
iterable
:
I
sep
:
&
str
)
-
>
String
where
I
:
IntoIterator
I
:
:
Item
:
Display
{
iterable
.
into_iter
(
)
.
join
(
sep
)
}
#
[
cfg
(
feature
=
"
use_alloc
"
)
]
pub
fn
sorted
<
I
>
(
iterable
:
I
)
-
>
VecIntoIter
<
I
:
:
Item
>
where
I
:
IntoIterator
I
:
:
Item
:
Ord
{
iterable
.
into_iter
(
)
.
sorted
(
)
}
