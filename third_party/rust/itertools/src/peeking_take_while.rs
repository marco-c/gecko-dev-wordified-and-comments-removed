use
std
:
:
iter
:
:
Peekable
;
use
PutBack
;
use
PutBackN
;
pub
trait
PeekingNext
:
Iterator
{
fn
peeking_next
<
F
>
(
&
mut
self
accept
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnOnce
(
&
Self
:
:
Item
)
-
>
bool
;
}
impl
<
I
>
PeekingNext
for
Peekable
<
I
>
where
I
:
Iterator
{
fn
peeking_next
<
F
>
(
&
mut
self
accept
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnOnce
(
&
Self
:
:
Item
)
-
>
bool
{
if
let
Some
(
r
)
=
self
.
peek
(
)
{
if
!
accept
(
r
)
{
return
None
;
}
}
self
.
next
(
)
}
}
impl
<
I
>
PeekingNext
for
PutBack
<
I
>
where
I
:
Iterator
{
fn
peeking_next
<
F
>
(
&
mut
self
accept
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnOnce
(
&
Self
:
:
Item
)
-
>
bool
{
if
let
Some
(
r
)
=
self
.
next
(
)
{
if
!
accept
(
&
r
)
{
self
.
put_back
(
r
)
;
return
None
;
}
Some
(
r
)
}
else
{
None
}
}
}
impl
<
I
>
PeekingNext
for
PutBackN
<
I
>
where
I
:
Iterator
{
fn
peeking_next
<
F
>
(
&
mut
self
accept
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnOnce
(
&
Self
:
:
Item
)
-
>
bool
{
if
let
Some
(
r
)
=
self
.
next
(
)
{
if
!
accept
(
&
r
)
{
self
.
put_back
(
r
)
;
return
None
;
}
Some
(
r
)
}
else
{
None
}
}
}
pub
struct
PeekingTakeWhile
<
'
a
I
:
'
a
F
>
where
I
:
Iterator
{
iter
:
&
'
a
mut
I
f
:
F
}
pub
fn
peeking_take_while
<
I
F
>
(
iter
:
&
mut
I
f
:
F
)
-
>
PeekingTakeWhile
<
I
F
>
where
I
:
Iterator
{
PeekingTakeWhile
{
iter
:
iter
f
:
f
}
}
impl
<
'
a
I
F
>
Iterator
for
PeekingTakeWhile
<
'
a
I
F
>
where
I
:
PeekingNext
F
:
FnMut
(
&
I
:
:
Item
)
-
>
bool
{
type
Item
=
I
:
:
Item
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
iter
.
peeking_next
(
&
mut
self
.
f
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
_
hi
)
=
self
.
iter
.
size_hint
(
)
;
(
0
hi
)
}
}
macro_rules
!
peeking_next_by_clone
{
(
as_item
x
:
item
)
=
>
(
x
)
;
(
[
(
typarm
:
tt
)
*
]
type_
:
ty
)
=
>
{
/
/
FIXME
:
Ast
coercion
is
dead
as
soon
as
we
can
dep
on
Rust
1
.
12
peeking_next_by_clone
!
{
as_item
impl
<
(
typarm
)
*
>
PeekingNext
for
type_
{
fn
peeking_next
<
F
>
(
&
mut
self
accept
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnOnce
(
&
Self
:
:
Item
)
-
>
bool
{
let
saved_state
=
self
.
clone
(
)
;
if
let
Some
(
r
)
=
self
.
next
(
)
{
if
!
accept
(
&
r
)
{
*
self
=
saved_state
;
}
else
{
return
Some
(
r
)
}
}
None
}
}
}
}
}
peeking_next_by_clone
!
{
[
'
a
T
]
:
:
std
:
:
slice
:
:
Iter
<
'
a
T
>
}
peeking_next_by_clone
!
{
[
'
a
]
:
:
std
:
:
str
:
:
Chars
<
'
a
>
}
peeking_next_by_clone
!
{
[
'
a
]
:
:
std
:
:
str
:
:
CharIndices
<
'
a
>
}
peeking_next_by_clone
!
{
[
'
a
]
:
:
std
:
:
str
:
:
Bytes
<
'
a
>
}
peeking_next_by_clone
!
{
[
'
a
T
]
:
:
std
:
:
option
:
:
Iter
<
'
a
T
>
}
peeking_next_by_clone
!
{
[
'
a
T
]
:
:
std
:
:
result
:
:
Iter
<
'
a
T
>
}
peeking_next_by_clone
!
{
[
T
]
:
:
std
:
:
iter
:
:
Empty
<
T
>
}
peeking_next_by_clone
!
{
[
'
a
T
]
:
:
std
:
:
collections
:
:
linked_list
:
:
Iter
<
'
a
T
>
}
peeking_next_by_clone
!
{
[
'
a
T
]
:
:
std
:
:
collections
:
:
vec_deque
:
:
Iter
<
'
a
T
>
}
peeking_next_by_clone
!
{
[
I
:
Clone
+
PeekingNext
+
DoubleEndedIterator
]
:
:
std
:
:
iter
:
:
Rev
<
I
>
}
