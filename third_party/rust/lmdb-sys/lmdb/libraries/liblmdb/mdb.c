#
ifndef
_GNU_SOURCE
#
define
_GNU_SOURCE
1
#
endif
#
if
defined
(
__WIN64__
)
#
define
_FILE_OFFSET_BITS
64
#
endif
#
ifdef
_WIN32
#
include
<
malloc
.
h
>
#
include
<
windows
.
h
>
#
include
<
wchar
.
h
>
#
define
MDB_PID_T
int
#
define
MDB_THR_T
DWORD
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
ifdef
__GNUC__
#
include
<
sys
/
param
.
h
>
#
else
#
define
LITTLE_ENDIAN
1234
#
define
BIG_ENDIAN
4321
#
define
BYTE_ORDER
LITTLE_ENDIAN
#
ifndef
SSIZE_MAX
#
define
SSIZE_MAX
INT_MAX
#
endif
#
endif
#
else
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
define
MDB_PID_T
pid_t
#
define
MDB_THR_T
pthread_t
#
include
<
sys
/
param
.
h
>
#
include
<
sys
/
uio
.
h
>
#
include
<
sys
/
mman
.
h
>
#
ifdef
HAVE_SYS_FILE_H
#
include
<
sys
/
file
.
h
>
#
endif
#
include
<
fcntl
.
h
>
#
endif
#
if
defined
(
__mips
)
&
&
defined
(
__linux
)
#
include
<
asm
/
cachectl
.
h
>
extern
int
cacheflush
(
char
*
addr
int
nbytes
int
cache
)
;
#
define
CACHEFLUSH
(
addr
bytes
cache
)
cacheflush
(
addr
bytes
cache
)
#
else
#
define
CACHEFLUSH
(
addr
bytes
cache
)
#
endif
#
if
defined
(
__linux
)
&
&
!
defined
(
MDB_FDATASYNC_WORKS
)
#
define
BROKEN_FDATASYNC
#
endif
#
include
<
errno
.
h
>
#
include
<
limits
.
h
>
#
include
<
stddef
.
h
>
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
time
.
h
>
#
ifdef
_MSC_VER
#
include
<
io
.
h
>
typedef
SSIZE_T
ssize_t
;
#
else
#
include
<
unistd
.
h
>
#
endif
#
if
defined
(
__sun
)
|
|
defined
(
__ANDROID__
)
#
define
HAVE_MEMALIGN
1
#
include
<
malloc
.
h
>
#
endif
#
if
!
(
defined
(
BYTE_ORDER
)
|
|
defined
(
__BYTE_ORDER
)
)
#
include
<
netinet
/
in
.
h
>
#
include
<
resolv
.
h
>
#
endif
#
if
defined
(
__APPLE__
)
|
|
defined
(
BSD
)
|
|
defined
(
__FreeBSD_kernel__
)
#
define
MDB_USE_POSIX_SEM
1
#
define
MDB_FDATASYNC
fsync
#
elif
defined
(
__ANDROID__
)
#
define
MDB_FDATASYNC
fsync
#
endif
#
ifndef
_WIN32
#
include
<
pthread
.
h
>
#
include
<
signal
.
h
>
#
ifdef
MDB_USE_POSIX_SEM
#
define
MDB_USE_HASH
1
#
include
<
semaphore
.
h
>
#
else
#
define
MDB_USE_POSIX_MUTEX
1
#
endif
#
endif
#
if
defined
(
_WIN32
)
+
defined
(
MDB_USE_POSIX_SEM
)
\
+
defined
(
MDB_USE_POSIX_MUTEX
)
!
=
1
#
error
"
Ambiguous
shared
-
lock
implementation
"
#
endif
#
ifdef
USE_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
define
VGMEMP_CREATE
(
h
r
z
)
VALGRIND_CREATE_MEMPOOL
(
h
r
z
)
#
define
VGMEMP_ALLOC
(
h
a
s
)
VALGRIND_MEMPOOL_ALLOC
(
h
a
s
)
#
define
VGMEMP_FREE
(
h
a
)
VALGRIND_MEMPOOL_FREE
(
h
a
)
#
define
VGMEMP_DESTROY
(
h
)
VALGRIND_DESTROY_MEMPOOL
(
h
)
#
define
VGMEMP_DEFINED
(
a
s
)
VALGRIND_MAKE_MEM_DEFINED
(
a
s
)
#
else
#
define
VGMEMP_CREATE
(
h
r
z
)
#
define
VGMEMP_ALLOC
(
h
a
s
)
#
define
VGMEMP_FREE
(
h
a
)
#
define
VGMEMP_DESTROY
(
h
)
#
define
VGMEMP_DEFINED
(
a
s
)
#
endif
#
ifndef
BYTE_ORDER
#
if
(
defined
(
_LITTLE_ENDIAN
)
|
|
defined
(
_BIG_ENDIAN
)
)
&
&
!
(
defined
(
_LITTLE_ENDIAN
)
&
&
defined
(
_BIG_ENDIAN
)
)
#
define
LITTLE_ENDIAN
1234
#
define
BIG_ENDIAN
4321
#
ifdef
_LITTLE_ENDIAN
#
define
BYTE_ORDER
LITTLE_ENDIAN
#
else
#
define
BYTE_ORDER
BIG_ENDIAN
#
endif
#
else
#
define
BYTE_ORDER
__BYTE_ORDER
#
endif
#
endif
#
ifndef
LITTLE_ENDIAN
#
define
LITTLE_ENDIAN
__LITTLE_ENDIAN
#
endif
#
ifndef
BIG_ENDIAN
#
define
BIG_ENDIAN
__BIG_ENDIAN
#
endif
#
if
defined
(
__i386
)
|
|
defined
(
__x86_64
)
|
|
defined
(
_M_IX86
)
#
define
MISALIGNED_OK
1
#
endif
#
include
"
lmdb
.
h
"
#
include
"
midl
.
h
"
#
if
(
BYTE_ORDER
=
=
LITTLE_ENDIAN
)
=
=
(
BYTE_ORDER
=
=
BIG_ENDIAN
)
#
error
"
Unknown
or
unsupported
endianness
(
BYTE_ORDER
)
"
#
elif
(
-
6
&
5
)
|
|
CHAR_BIT
!
=
8
|
|
UINT_MAX
<
0xffffffff
|
|
ULONG_MAX
%
0xFFFF
#
error
"
Two
'
s
complement
reasonably
sized
integer
types
please
"
#
endif
#
ifdef
__GNUC__
#
ifdef
__APPLE__
#
define
ESECT
__attribute__
(
(
section
(
"
__TEXT
text_env
"
)
)
)
#
else
#
define
ESECT
__attribute__
(
(
section
(
"
text_env
"
)
)
)
#
endif
#
else
#
define
ESECT
#
endif
#
ifdef
_WIN32
#
define
CALL_CONV
WINAPI
#
else
#
define
CALL_CONV
#
endif
#
ifndef
MDB_DEVEL
#
define
MDB_DEVEL
0
#
endif
#
if
__STDC_VERSION__
>
=
199901L
#
define
mdb_func_
__func__
#
elif
__GNUC__
>
=
2
|
|
_MSC_VER
>
=
1300
#
define
mdb_func_
__FUNCTION__
#
else
#
define
mdb_func_
"
<
mdb_unknown
>
"
#
endif
#
define
MDB_NO_ROOT
(
MDB_LAST_ERRCODE
+
10
)
#
ifdef
_WIN32
#
define
MDB_OWNERDEAD
(
(
int
)
WAIT_ABANDONED
)
#
elif
defined
(
MDB_USE_POSIX_MUTEX
)
&
&
defined
(
EOWNERDEAD
)
#
define
MDB_OWNERDEAD
EOWNERDEAD
/
*
*
<
#
LOCK_MUTEX0
(
)
result
if
dead
owner
*
/
#
endif
#
ifdef
__GLIBC__
#
define
GLIBC_VER
(
(
__GLIBC__
<
<
16
)
|
__GLIBC_MINOR__
)
#
endif
#
ifndef
MDB_USE_ROBUST
#
if
defined
(
MDB_USE_POSIX_MUTEX
)
&
&
(
defined
(
__ANDROID__
)
|
|
\
(
defined
(
__GLIBC__
)
&
&
GLIBC_VER
<
0x020004
)
)
#
define
MDB_USE_ROBUST
0
#
else
#
define
MDB_USE_ROBUST
1
#
endif
#
endif
#
if
defined
(
MDB_USE_POSIX_MUTEX
)
&
&
(
MDB_USE_ROBUST
)
#
if
(
defined
(
__GLIBC__
)
&
&
GLIBC_VER
<
0x02000c
)
|
|
\
(
defined
(
PTHREAD_MUTEX_ROBUST_NP
)
&
&
!
defined
(
PTHREAD_MUTEX_ROBUST
)
)
#
define
PTHREAD_MUTEX_ROBUST
PTHREAD_MUTEX_ROBUST_NP
#
define
pthread_mutexattr_setrobust
(
attr
flag
)
pthread_mutexattr_setrobust_np
(
attr
flag
)
#
define
pthread_mutex_consistent
(
mutex
)
pthread_mutex_consistent_np
(
mutex
)
#
endif
#
endif
#
if
defined
(
MDB_OWNERDEAD
)
&
&
(
MDB_USE_ROBUST
)
#
define
MDB_ROBUST_SUPPORTED
1
#
endif
#
ifdef
_WIN32
#
define
MDB_USE_HASH
1
#
define
MDB_PIDLOCK
0
#
define
THREAD_RET
DWORD
#
define
pthread_t
HANDLE
#
define
pthread_mutex_t
HANDLE
#
define
pthread_cond_t
HANDLE
typedef
HANDLE
mdb_mutex_t
mdb_mutexref_t
;
#
define
pthread_key_t
DWORD
#
define
pthread_self
(
)
GetCurrentThreadId
(
)
#
define
pthread_key_create
(
x
y
)
\
(
(
*
(
x
)
=
TlsAlloc
(
)
)
=
=
TLS_OUT_OF_INDEXES
?
ErrCode
(
)
:
0
)
#
define
pthread_key_delete
(
x
)
TlsFree
(
x
)
#
define
pthread_getspecific
(
x
)
TlsGetValue
(
x
)
#
define
pthread_setspecific
(
x
y
)
(
TlsSetValue
(
x
y
)
?
0
:
ErrCode
(
)
)
#
define
pthread_mutex_unlock
(
x
)
ReleaseMutex
(
*
x
)
#
define
pthread_mutex_lock
(
x
)
WaitForSingleObject
(
*
x
INFINITE
)
#
define
pthread_cond_signal
(
x
)
SetEvent
(
*
x
)
#
define
pthread_cond_wait
(
cond
mutex
)
do
{
SignalObjectAndWait
(
*
mutex
*
cond
INFINITE
FALSE
)
;
WaitForSingleObject
(
*
mutex
INFINITE
)
;
}
while
(
0
)
#
define
THREAD_CREATE
(
thr
start
arg
)
\
(
(
(
thr
)
=
CreateThread
(
NULL
0
start
arg
0
NULL
)
)
?
0
:
ErrCode
(
)
)
#
define
THREAD_FINISH
(
thr
)
\
(
WaitForSingleObject
(
thr
INFINITE
)
?
ErrCode
(
)
:
0
)
#
define
LOCK_MUTEX0
(
mutex
)
WaitForSingleObject
(
mutex
INFINITE
)
#
define
UNLOCK_MUTEX
(
mutex
)
ReleaseMutex
(
mutex
)
#
define
mdb_mutex_consistent
(
mutex
)
0
#
define
getpid
(
)
GetCurrentProcessId
(
)
#
define
MDB_FDATASYNC
(
fd
)
(
!
FlushFileBuffers
(
fd
)
)
#
define
MDB_MSYNC
(
addr
len
flags
)
(
!
FlushViewOfFile
(
addr
len
)
)
#
define
ErrCode
(
)
GetLastError
(
)
#
define
GET_PAGESIZE
(
x
)
{
SYSTEM_INFO
si
;
GetSystemInfo
(
&
si
)
;
(
x
)
=
si
.
dwPageSize
;
}
#
define
close
(
fd
)
(
CloseHandle
(
fd
)
?
0
:
-
1
)
#
define
munmap
(
ptr
len
)
UnmapViewOfFile
(
ptr
)
#
ifdef
PROCESS_QUERY_LIMITED_INFORMATION
#
define
MDB_PROCESS_QUERY_LIMITED_INFORMATION
PROCESS_QUERY_LIMITED_INFORMATION
#
else
#
define
MDB_PROCESS_QUERY_LIMITED_INFORMATION
0x1000
#
endif
#
define
Z
"
I
"
#
else
#
define
THREAD_RET
void
*
#
define
THREAD_CREATE
(
thr
start
arg
)
pthread_create
(
&
thr
NULL
start
arg
)
#
define
THREAD_FINISH
(
thr
)
pthread_join
(
thr
NULL
)
#
define
Z
"
z
"
/
*
*
<
printf
format
modifier
for
size_t
*
/
#
define
MDB_PIDLOCK
1
#
ifdef
MDB_USE_POSIX_SEM
typedef
sem_t
*
mdb_mutex_t
*
mdb_mutexref_t
;
#
define
LOCK_MUTEX0
(
mutex
)
mdb_sem_wait
(
mutex
)
#
define
UNLOCK_MUTEX
(
mutex
)
sem_post
(
mutex
)
static
int
mdb_sem_wait
(
sem_t
*
sem
)
{
int
rc
;
while
(
(
rc
=
sem_wait
(
sem
)
)
&
&
(
rc
=
errno
)
=
=
EINTR
)
;
return
rc
;
}
#
else
typedef
pthread_mutex_t
mdb_mutex_t
[
1
]
;
typedef
pthread_mutex_t
*
mdb_mutexref_t
;
#
define
LOCK_MUTEX0
(
mutex
)
pthread_mutex_lock
(
mutex
)
#
define
UNLOCK_MUTEX
(
mutex
)
pthread_mutex_unlock
(
mutex
)
#
define
mdb_mutex_consistent
(
mutex
)
pthread_mutex_consistent
(
mutex
)
#
endif
#
define
ErrCode
(
)
errno
#
define
HANDLE
int
#
define
INVALID_HANDLE_VALUE
(
-
1
)
#
define
GET_PAGESIZE
(
x
)
(
(
x
)
=
sysconf
(
_SC_PAGE_SIZE
)
)
#
endif
#
if
defined
(
_WIN32
)
|
|
defined
(
MDB_USE_POSIX_SEM
)
#
define
MNAME_LEN
32
#
else
#
define
MNAME_LEN
(
sizeof
(
pthread_mutex_t
)
)
#
endif
#
ifdef
MDB_ROBUST_SUPPORTED
#
define
LOCK_MUTEX
(
rc
env
mutex
)
\
(
(
(
rc
)
=
LOCK_MUTEX0
(
mutex
)
)
&
&
\
(
(
rc
)
=
mdb_mutex_failed
(
env
mutex
rc
)
)
)
static
int
mdb_mutex_failed
(
MDB_env
*
env
mdb_mutexref_t
mutex
int
rc
)
;
#
else
#
define
LOCK_MUTEX
(
rc
env
mutex
)
(
(
rc
)
=
LOCK_MUTEX0
(
mutex
)
)
#
define
mdb_mutex_failed
(
env
mutex
rc
)
(
rc
)
#
endif
#
ifndef
_WIN32
#
ifndef
MDB_DSYNC
#
ifdef
O_DSYNC
#
define
MDB_DSYNC
O_DSYNC
#
else
#
define
MDB_DSYNC
O_SYNC
#
endif
#
endif
#
endif
#
ifndef
MDB_FDATASYNC
#
define
MDB_FDATASYNC
fdatasync
#
endif
#
ifndef
MDB_MSYNC
#
define
MDB_MSYNC
(
addr
len
flags
)
msync
(
addr
len
flags
)
#
endif
#
ifndef
MS_SYNC
#
define
MS_SYNC
1
#
endif
#
ifndef
MS_ASYNC
#
define
MS_ASYNC
0
#
endif
typedef
MDB_ID
pgno_t
;
typedef
MDB_ID
txnid_t
;
#
ifndef
MDB_DEBUG
#
define
MDB_DEBUG
0
#
endif
#
if
MDB_DEBUG
static
int
mdb_debug
;
static
txnid_t
mdb_debug_start
;
#
define
DPRINTF
(
args
)
(
(
void
)
(
(
mdb_debug
)
&
&
DPRINTF0
args
)
)
#
define
DPRINTF0
(
fmt
.
.
.
)
\
fprintf
(
stderr
"
%
s
:
%
d
"
fmt
"
\
n
"
mdb_func_
__LINE__
__VA_ARGS__
)
#
else
#
define
DPRINTF
(
args
)
(
(
void
)
0
)
#
endif
#
define
DPUTS
(
arg
)
DPRINTF
(
(
"
%
s
"
arg
)
)
#
define
DDBI
(
mc
)
\
(
(
(
mc
)
-
>
mc_flags
&
C_SUB
)
?
-
(
int
)
(
mc
)
-
>
mc_dbi
:
(
int
)
(
mc
)
-
>
mc_dbi
)
#
define
MAX_PAGESIZE
(
PAGEBASE
?
0x10000
:
0x8000
)
#
define
MDB_MINKEYS
2
#
define
MDB_MAGIC
0xBEEFC0DE
#
define
MDB_DATA_VERSION
(
(
MDB_DEVEL
)
?
999
:
1
)
#
define
MDB_LOCK_VERSION
1
#
ifndef
MDB_MAXKEYSIZE
#
define
MDB_MAXKEYSIZE
(
(
MDB_DEVEL
)
?
0
:
511
)
#
endif
#
if
MDB_MAXKEYSIZE
#
define
ENV_MAXKEY
(
env
)
(
MDB_MAXKEYSIZE
)
#
else
#
define
ENV_MAXKEY
(
env
)
(
(
env
)
-
>
me_maxkey
)
#
endif
#
define
MAXDATASIZE
0xffffffffUL
#
if
MDB_DEBUG
#
define
DKBUF_MAXKEYSIZE
(
(
MDB_MAXKEYSIZE
)
>
0
?
(
MDB_MAXKEYSIZE
)
:
511
)
#
define
DKBUF
char
kbuf
[
DKBUF_MAXKEYSIZE
*
2
+
1
]
#
define
DKEY
(
x
)
mdb_dkey
(
x
kbuf
)
#
else
#
define
DKBUF
#
define
DKEY
(
x
)
0
#
endif
#
define
P_INVALID
(
~
(
pgno_t
)
0
)
#
define
F_ISSET
(
w
f
)
(
(
(
w
)
&
(
f
)
)
=
=
(
f
)
)
#
define
EVEN
(
n
)
(
(
(
n
)
+
1U
)
&
-
2
)
/
*
sign
-
extending
-
2
to
match
n
+
1U
*
/
typedef
uint16_t
indx_t
;
#
define
DEFAULT_MAPSIZE
1048576
#
define
DEFAULT_READERS
126
#
ifndef
CACHELINE
#
define
CACHELINE
64
#
endif
typedef
struct
MDB_rxbody
{
volatile
txnid_t
mrb_txnid
;
volatile
MDB_PID_T
mrb_pid
;
volatile
MDB_THR_T
mrb_tid
;
}
MDB_rxbody
;
typedef
struct
MDB_reader
{
union
{
MDB_rxbody
mrx
;
#
define
mr_txnid
mru
.
mrx
.
mrb_txnid
#
define
mr_pid
mru
.
mrx
.
mrb_pid
#
define
mr_tid
mru
.
mrx
.
mrb_tid
char
pad
[
(
sizeof
(
MDB_rxbody
)
+
CACHELINE
-
1
)
&
~
(
CACHELINE
-
1
)
]
;
}
mru
;
}
MDB_reader
;
typedef
struct
MDB_txbody
{
uint32_t
mtb_magic
;
uint32_t
mtb_format
;
#
if
defined
(
_WIN32
)
|
|
defined
(
MDB_USE_POSIX_SEM
)
char
mtb_rmname
[
MNAME_LEN
]
;
#
else
mdb_mutex_t
mtb_rmutex
;
#
endif
volatile
txnid_t
mtb_txnid
;
volatile
unsigned
mtb_numreaders
;
}
MDB_txbody
;
typedef
struct
MDB_txninfo
{
union
{
MDB_txbody
mtb
;
#
define
mti_magic
mt1
.
mtb
.
mtb_magic
#
define
mti_format
mt1
.
mtb
.
mtb_format
#
define
mti_rmutex
mt1
.
mtb
.
mtb_rmutex
#
define
mti_rmname
mt1
.
mtb
.
mtb_rmname
#
define
mti_txnid
mt1
.
mtb
.
mtb_txnid
#
define
mti_numreaders
mt1
.
mtb
.
mtb_numreaders
char
pad
[
(
sizeof
(
MDB_txbody
)
+
CACHELINE
-
1
)
&
~
(
CACHELINE
-
1
)
]
;
}
mt1
;
union
{
#
if
defined
(
_WIN32
)
|
|
defined
(
MDB_USE_POSIX_SEM
)
char
mt2_wmname
[
MNAME_LEN
]
;
#
define
mti_wmname
mt2
.
mt2_wmname
#
else
mdb_mutex_t
mt2_wmutex
;
#
define
mti_wmutex
mt2
.
mt2_wmutex
#
endif
char
pad
[
(
MNAME_LEN
+
CACHELINE
-
1
)
&
~
(
CACHELINE
-
1
)
]
;
}
mt2
;
MDB_reader
mti_readers
[
1
]
;
}
MDB_txninfo
;
#
define
MDB_LOCK_FORMAT
\
(
(
uint32_t
)
\
(
(
MDB_LOCK_VERSION
)
\
/
*
Flags
which
describe
functionality
*
/
\
+
(
(
(
MDB_PIDLOCK
)
!
=
0
)
<
<
16
)
)
)
typedef
struct
MDB_page
{
#
define
mp_pgno
mp_p
.
p_pgno
#
define
mp_next
mp_p
.
p_next
union
{
pgno_t
p_pgno
;
struct
MDB_page
*
p_next
;
}
mp_p
;
uint16_t
mp_pad
;
#
define
P_BRANCH
0x01
/
*
*
<
branch
page
*
/
#
define
P_LEAF
0x02
/
*
*
<
leaf
page
*
/
#
define
P_OVERFLOW
0x04
/
*
*
<
overflow
page
*
/
#
define
P_META
0x08
/
*
*
<
meta
page
*
/
#
define
P_DIRTY
0x10
/
*
*
<
dirty
page
also
set
for
#
P_SUBP
pages
*
/
#
define
P_LEAF2
0x20
/
*
*
<
for
#
MDB_DUPFIXED
records
*
/
#
define
P_SUBP
0x40
/
*
*
<
for
#
MDB_DUPSORT
sub
-
pages
*
/
#
define
P_LOOSE
0x4000
/
*
*
<
page
was
dirtied
then
freed
can
be
reused
*
/
#
define
P_KEEP
0x8000
/
*
*
<
leave
this
page
alone
during
spill
*
/
uint16_t
mp_flags
;
#
define
mp_lower
mp_pb
.
pb
.
pb_lower
#
define
mp_upper
mp_pb
.
pb
.
pb_upper
#
define
mp_pages
mp_pb
.
pb_pages
union
{
struct
{
indx_t
pb_lower
;
indx_t
pb_upper
;
}
pb
;
uint32_t
pb_pages
;
}
mp_pb
;
indx_t
mp_ptrs
[
1
]
;
}
MDB_page
;
#
define
PAGEHDRSZ
(
(
unsigned
)
offsetof
(
MDB_page
mp_ptrs
)
)
#
define
METADATA
(
p
)
(
(
void
*
)
(
(
char
*
)
(
p
)
+
PAGEHDRSZ
)
)
#
define
PAGEBASE
(
(
MDB_DEVEL
)
?
PAGEHDRSZ
:
0
)
#
define
NUMKEYS
(
p
)
(
(
(
p
)
-
>
mp_lower
-
(
PAGEHDRSZ
-
PAGEBASE
)
)
>
>
1
)
#
define
SIZELEFT
(
p
)
(
indx_t
)
(
(
p
)
-
>
mp_upper
-
(
p
)
-
>
mp_lower
)
#
define
PAGEFILL
(
env
p
)
(
1000L
*
(
(
env
)
-
>
me_psize
-
PAGEHDRSZ
-
SIZELEFT
(
p
)
)
/
\
(
(
env
)
-
>
me_psize
-
PAGEHDRSZ
)
)
#
define
FILL_THRESHOLD
250
#
define
IS_LEAF
(
p
)
F_ISSET
(
(
p
)
-
>
mp_flags
P_LEAF
)
#
define
IS_LEAF2
(
p
)
F_ISSET
(
(
p
)
-
>
mp_flags
P_LEAF2
)
#
define
IS_BRANCH
(
p
)
F_ISSET
(
(
p
)
-
>
mp_flags
P_BRANCH
)
#
define
IS_OVERFLOW
(
p
)
F_ISSET
(
(
p
)
-
>
mp_flags
P_OVERFLOW
)
#
define
IS_SUBP
(
p
)
F_ISSET
(
(
p
)
-
>
mp_flags
P_SUBP
)
#
define
OVPAGES
(
size
psize
)
(
(
PAGEHDRSZ
-
1
+
(
size
)
)
/
(
psize
)
+
1
)
#
define
NEXT_LOOSE_PAGE
(
p
)
(
*
(
MDB_page
*
*
)
(
(
p
)
+
2
)
)
typedef
struct
MDB_node
{
#
if
BYTE_ORDER
=
=
LITTLE_ENDIAN
unsigned
short
mn_lo
mn_hi
;
#
else
unsigned
short
mn_hi
mn_lo
;
#
endif
#
define
F_BIGDATA
0x01
/
*
*
<
data
put
on
overflow
page
*
/
#
define
F_SUBDATA
0x02
/
*
*
<
data
is
a
sub
-
database
*
/
#
define
F_DUPDATA
0x04
/
*
*
<
data
has
duplicates
*
/
#
define
NODE_ADD_FLAGS
(
F_DUPDATA
|
F_SUBDATA
|
MDB_RESERVE
|
MDB_APPEND
)
unsigned
short
mn_flags
;
unsigned
short
mn_ksize
;
char
mn_data
[
1
]
;
}
MDB_node
;
#
define
NODESIZE
offsetof
(
MDB_node
mn_data
)
#
define
PGNO_TOPWORD
(
(
pgno_t
)
-
1
>
0xffffffffu
?
32
:
0
)
#
define
INDXSIZE
(
k
)
(
NODESIZE
+
(
(
k
)
=
=
NULL
?
0
:
(
k
)
-
>
mv_size
)
)
#
define
LEAFSIZE
(
k
d
)
(
NODESIZE
+
(
k
)
-
>
mv_size
+
(
d
)
-
>
mv_size
)
#
define
NODEPTR
(
p
i
)
(
(
MDB_node
*
)
(
(
char
*
)
(
p
)
+
(
p
)
-
>
mp_ptrs
[
i
]
+
PAGEBASE
)
)
#
define
NODEKEY
(
node
)
(
void
*
)
(
(
node
)
-
>
mn_data
)
#
define
NODEDATA
(
node
)
(
void
*
)
(
(
char
*
)
(
node
)
-
>
mn_data
+
(
node
)
-
>
mn_ksize
)
#
define
NODEPGNO
(
node
)
\
(
(
node
)
-
>
mn_lo
|
(
(
pgno_t
)
(
node
)
-
>
mn_hi
<
<
16
)
|
\
(
PGNO_TOPWORD
?
(
(
pgno_t
)
(
node
)
-
>
mn_flags
<
<
PGNO_TOPWORD
)
:
0
)
)
#
define
SETPGNO
(
node
pgno
)
do
{
\
(
node
)
-
>
mn_lo
=
(
pgno
)
&
0xffff
;
(
node
)
-
>
mn_hi
=
(
pgno
)
>
>
16
;
\
if
(
PGNO_TOPWORD
)
(
node
)
-
>
mn_flags
=
(
pgno
)
>
>
PGNO_TOPWORD
;
}
while
(
0
)
#
define
NODEDSZ
(
node
)
(
(
node
)
-
>
mn_lo
|
(
(
unsigned
)
(
node
)
-
>
mn_hi
<
<
16
)
)
#
define
SETDSZ
(
node
size
)
do
{
\
(
node
)
-
>
mn_lo
=
(
size
)
&
0xffff
;
(
node
)
-
>
mn_hi
=
(
size
)
>
>
16
;
}
while
(
0
)
#
define
NODEKSZ
(
node
)
(
(
node
)
-
>
mn_ksize
)
#
ifdef
MISALIGNED_OK
#
define
COPY_PGNO
(
dst
src
)
dst
=
src
#
else
#
if
SIZE_MAX
>
4294967295UL
#
define
COPY_PGNO
(
dst
src
)
do
{
\
unsigned
short
*
s
*
d
;
\
s
=
(
unsigned
short
*
)
&
(
src
)
;
\
d
=
(
unsigned
short
*
)
&
(
dst
)
;
\
*
d
+
+
=
*
s
+
+
;
\
*
d
+
+
=
*
s
+
+
;
\
*
d
+
+
=
*
s
+
+
;
\
*
d
=
*
s
;
\
}
while
(
0
)
#
else
#
define
COPY_PGNO
(
dst
src
)
do
{
\
unsigned
short
*
s
*
d
;
\
s
=
(
unsigned
short
*
)
&
(
src
)
;
\
d
=
(
unsigned
short
*
)
&
(
dst
)
;
\
*
d
+
+
=
*
s
+
+
;
\
*
d
=
*
s
;
\
}
while
(
0
)
#
endif
#
endif
#
define
LEAF2KEY
(
p
i
ks
)
(
(
char
*
)
(
p
)
+
PAGEHDRSZ
+
(
(
i
)
*
(
ks
)
)
)
#
define
MDB_GET_KEY
(
node
keyptr
)
{
if
(
(
keyptr
)
!
=
NULL
)
{
\
(
keyptr
)
-
>
mv_size
=
NODEKSZ
(
node
)
;
(
keyptr
)
-
>
mv_data
=
NODEKEY
(
node
)
;
}
}
#
define
MDB_GET_KEY2
(
node
key
)
{
key
.
mv_size
=
NODEKSZ
(
node
)
;
key
.
mv_data
=
NODEKEY
(
node
)
;
}
typedef
struct
MDB_db
{
uint32_t
md_pad
;
uint16_t
md_flags
;
uint16_t
md_depth
;
pgno_t
md_branch_pages
;
pgno_t
md_leaf_pages
;
pgno_t
md_overflow_pages
;
size_t
md_entries
;
pgno_t
md_root
;
}
MDB_db
;
#
define
MDB_VALID
0x8000
/
*
*
<
DB
handle
is
valid
for
me_dbflags
*
/
#
define
PERSISTENT_FLAGS
(
0xffff
&
~
(
MDB_VALID
)
)
#
define
VALID_FLAGS
(
MDB_REVERSEKEY
|
MDB_DUPSORT
|
MDB_INTEGERKEY
|
MDB_DUPFIXED
|
\
MDB_INTEGERDUP
|
MDB_REVERSEDUP
|
MDB_CREATE
)
#
define
FREE_DBI
0
#
define
MAIN_DBI
1
#
define
CORE_DBS
2
#
define
NUM_METAS
2
typedef
struct
MDB_meta
{
uint32_t
mm_magic
;
uint32_t
mm_version
;
void
*
mm_address
;
size_t
mm_mapsize
;
MDB_db
mm_dbs
[
CORE_DBS
]
;
#
define
mm_psize
mm_dbs
[
FREE_DBI
]
.
md_pad
#
define
mm_flags
mm_dbs
[
FREE_DBI
]
.
md_flags
pgno_t
mm_last_pg
;
volatile
txnid_t
mm_txnid
;
}
MDB_meta
;
typedef
union
MDB_metabuf
{
MDB_page
mb_page
;
struct
{
char
mm_pad
[
PAGEHDRSZ
]
;
MDB_meta
mm_meta
;
}
mb_metabuf
;
}
MDB_metabuf
;
typedef
struct
MDB_dbx
{
MDB_val
md_name
;
MDB_cmp_func
*
md_cmp
;
MDB_cmp_func
*
md_dcmp
;
MDB_rel_func
*
md_rel
;
void
*
md_relctx
;
}
MDB_dbx
;
struct
MDB_txn
{
MDB_txn
*
mt_parent
;
MDB_txn
*
mt_child
;
pgno_t
mt_next_pgno
;
txnid_t
mt_txnid
;
MDB_env
*
mt_env
;
MDB_IDL
mt_free_pgs
;
MDB_page
*
mt_loose_pgs
;
int
mt_loose_count
;
MDB_IDL
mt_spill_pgs
;
union
{
MDB_ID2L
dirty_list
;
MDB_reader
*
reader
;
}
mt_u
;
MDB_dbx
*
mt_dbxs
;
MDB_db
*
mt_dbs
;
unsigned
int
*
mt_dbiseqs
;
#
define
DB_DIRTY
0x01
/
*
*
<
DB
was
written
in
this
txn
*
/
#
define
DB_STALE
0x02
/
*
*
<
Named
-
DB
record
is
older
than
txnID
*
/
#
define
DB_NEW
0x04
/
*
*
<
Named
-
DB
handle
opened
in
this
txn
*
/
#
define
DB_VALID
0x08
/
*
*
<
DB
handle
is
valid
see
also
#
MDB_VALID
*
/
#
define
DB_USRVALID
0x10
/
*
*
<
As
#
DB_VALID
but
not
set
for
#
FREE_DBI
*
/
#
define
DB_DUPDATA
0x20
/
*
*
<
DB
is
#
MDB_DUPSORT
data
*
/
MDB_cursor
*
*
mt_cursors
;
unsigned
char
*
mt_dbflags
;
MDB_dbi
mt_numdbs
;
#
define
MDB_TXN_BEGIN_FLAGS
MDB_RDONLY
#
define
MDB_TXN_RDONLY
MDB_RDONLY
/
*
*
<
read
-
only
transaction
*
/
#
define
MDB_TXN_WRITEMAP
MDB_WRITEMAP
/
*
*
<
copy
of
#
MDB_env
flag
in
writers
*
/
#
define
MDB_TXN_FINISHED
0x01
/
*
*
<
txn
is
finished
or
never
began
*
/
#
define
MDB_TXN_ERROR
0x02
/
*
*
<
txn
is
unusable
after
an
error
*
/
#
define
MDB_TXN_DIRTY
0x04
/
*
*
<
must
write
even
if
dirty
list
is
empty
*
/
#
define
MDB_TXN_SPILLS
0x08
/
*
*
<
txn
or
a
parent
has
spilled
pages
*
/
#
define
MDB_TXN_HAS_CHILD
0x10
/
*
*
<
txn
has
an
#
MDB_txn
.
%
mt_child
*
/
#
define
MDB_TXN_BLOCKED
(
MDB_TXN_FINISHED
|
MDB_TXN_ERROR
|
MDB_TXN_HAS_CHILD
)
unsigned
int
mt_flags
;
unsigned
int
mt_dirty_room
;
}
;
#
define
CURSOR_STACK
32
struct
MDB_xcursor
;
struct
MDB_cursor
{
MDB_cursor
*
mc_next
;
MDB_cursor
*
mc_backup
;
struct
MDB_xcursor
*
mc_xcursor
;
MDB_txn
*
mc_txn
;
MDB_dbi
mc_dbi
;
MDB_db
*
mc_db
;
MDB_dbx
*
mc_dbx
;
unsigned
char
*
mc_dbflag
;
unsigned
short
mc_snum
;
unsigned
short
mc_top
;
#
define
C_INITIALIZED
0x01
/
*
*
<
cursor
has
been
initialized
and
is
valid
*
/
#
define
C_EOF
0x02
/
*
*
<
No
more
data
*
/
#
define
C_SUB
0x04
/
*
*
<
Cursor
is
a
sub
-
cursor
*
/
#
define
C_DEL
0x08
/
*
*
<
last
op
was
a
cursor_del
*
/
#
define
C_UNTRACK
0x40
/
*
*
<
Un
-
track
cursor
when
closing
*
/
unsigned
int
mc_flags
;
MDB_page
*
mc_pg
[
CURSOR_STACK
]
;
indx_t
mc_ki
[
CURSOR_STACK
]
;
}
;
typedef
struct
MDB_xcursor
{
MDB_cursor
mx_cursor
;
MDB_db
mx_db
;
MDB_dbx
mx_dbx
;
unsigned
char
mx_dbflag
;
}
MDB_xcursor
;
#
define
XCURSOR_INITED
(
mc
)
\
(
(
mc
)
-
>
mc_xcursor
&
&
(
(
mc
)
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
)
#
define
XCURSOR_REFRESH
(
mc
mp
ki
)
do
{
\
MDB_page
*
xr_pg
=
(
mp
)
;
\
MDB_node
*
xr_node
=
NODEPTR
(
xr_pg
ki
)
;
\
if
(
(
xr_node
-
>
mn_flags
&
(
F_DUPDATA
|
F_SUBDATA
)
)
=
=
F_DUPDATA
)
\
(
mc
)
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
NODEDATA
(
xr_node
)
;
\
}
while
(
0
)
typedef
struct
MDB_pgstate
{
pgno_t
*
mf_pghead
;
txnid_t
mf_pglast
;
}
MDB_pgstate
;
struct
MDB_env
{
HANDLE
me_fd
;
HANDLE
me_lfd
;
HANDLE
me_mfd
;
#
define
MDB_FATAL_ERROR
0x80000000U
#
define
MDB_ENV_ACTIVE
0x20000000U
#
define
MDB_ENV_TXKEY
0x10000000U
#
define
MDB_FSYNCONLY
0x08000000U
uint32_t
me_flags
;
unsigned
int
me_psize
;
unsigned
int
me_os_psize
;
unsigned
int
me_maxreaders
;
volatile
int
me_close_readers
;
MDB_dbi
me_numdbs
;
MDB_dbi
me_maxdbs
;
MDB_PID_T
me_pid
;
char
*
me_path
;
char
*
me_map
;
MDB_txninfo
*
me_txns
;
MDB_meta
*
me_metas
[
NUM_METAS
]
;
void
*
me_pbuf
;
MDB_txn
*
me_txn
;
MDB_txn
*
me_txn0
;
size_t
me_mapsize
;
off_t
me_size
;
pgno_t
me_maxpg
;
MDB_dbx
*
me_dbxs
;
uint16_t
*
me_dbflags
;
unsigned
int
*
me_dbiseqs
;
pthread_key_t
me_txkey
;
txnid_t
me_pgoldest
;
MDB_pgstate
me_pgstate
;
#
define
me_pglast
me_pgstate
.
mf_pglast
#
define
me_pghead
me_pgstate
.
mf_pghead
MDB_page
*
me_dpages
;
MDB_IDL
me_free_pgs
;
MDB_ID2L
me_dirty_list
;
int
me_maxfree_1pg
;
unsigned
int
me_nodemax
;
#
if
!
(
MDB_MAXKEYSIZE
)
unsigned
int
me_maxkey
;
#
endif
int
me_live_reader
;
#
ifdef
_WIN32
int
me_pidquery
;
#
endif
#
ifdef
MDB_USE_POSIX_MUTEX
#
define
me_rmutex
me_txns
-
>
mti_rmutex
/
*
*
<
Shared
reader
lock
*
/
#
define
me_wmutex
me_txns
-
>
mti_wmutex
/
*
*
<
Shared
writer
lock
*
/
#
else
mdb_mutex_t
me_rmutex
;
mdb_mutex_t
me_wmutex
;
#
endif
void
*
me_userctx
;
MDB_assert_func
*
me_assert_func
;
}
;
typedef
struct
MDB_ntxn
{
MDB_txn
mnt_txn
;
MDB_pgstate
mnt_pgstate
;
}
MDB_ntxn
;
#
define
MDB_COMMIT_PAGES
64
#
if
defined
(
IOV_MAX
)
&
&
IOV_MAX
<
MDB_COMMIT_PAGES
#
undef
MDB_COMMIT_PAGES
#
define
MDB_COMMIT_PAGES
IOV_MAX
#
endif
#
define
MAX_WRITE
(
0x40000000U
>
>
(
sizeof
(
ssize_t
)
=
=
4
)
)
#
define
TXN_DBI_EXIST
(
txn
dbi
validity
)
\
(
(
txn
)
&
&
(
dbi
)
<
(
txn
)
-
>
mt_numdbs
&
&
(
(
txn
)
-
>
mt_dbflags
[
dbi
]
&
(
validity
)
)
)
#
define
TXN_DBI_CHANGED
(
txn
dbi
)
\
(
(
txn
)
-
>
mt_dbiseqs
[
dbi
]
!
=
(
txn
)
-
>
mt_env
-
>
me_dbiseqs
[
dbi
]
)
static
int
mdb_page_alloc
(
MDB_cursor
*
mc
int
num
MDB_page
*
*
mp
)
;
static
int
mdb_page_new
(
MDB_cursor
*
mc
uint32_t
flags
int
num
MDB_page
*
*
mp
)
;
static
int
mdb_page_touch
(
MDB_cursor
*
mc
)
;
#
define
MDB_END_NAMES
{
"
committed
"
"
empty
-
commit
"
"
abort
"
"
reset
"
\
"
reset
-
tmp
"
"
fail
-
begin
"
"
fail
-
beginchild
"
}
enum
{
MDB_END_COMMITTED
MDB_END_EMPTY_COMMIT
MDB_END_ABORT
MDB_END_RESET
MDB_END_RESET_TMP
MDB_END_FAIL_BEGIN
MDB_END_FAIL_BEGINCHILD
}
;
#
define
MDB_END_OPMASK
0x0F
/
*
*
<
mask
for
#
mdb_txn_end
(
)
operation
number
*
/
#
define
MDB_END_UPDATE
0x10
/
*
*
<
update
env
state
(
DBIs
)
*
/
#
define
MDB_END_FREE
0x20
/
*
*
<
free
txn
unless
it
is
#
MDB_env
.
%
me_txn0
*
/
#
define
MDB_END_SLOT
MDB_NOTLS
/
*
*
<
release
any
reader
slot
if
#
MDB_NOTLS
*
/
static
void
mdb_txn_end
(
MDB_txn
*
txn
unsigned
mode
)
;
static
int
mdb_page_get
(
MDB_cursor
*
mc
pgno_t
pgno
MDB_page
*
*
mp
int
*
lvl
)
;
static
int
mdb_page_search_root
(
MDB_cursor
*
mc
MDB_val
*
key
int
modify
)
;
#
define
MDB_PS_MODIFY
1
#
define
MDB_PS_ROOTONLY
2
#
define
MDB_PS_FIRST
4
#
define
MDB_PS_LAST
8
static
int
mdb_page_search
(
MDB_cursor
*
mc
MDB_val
*
key
int
flags
)
;
static
int
mdb_page_merge
(
MDB_cursor
*
csrc
MDB_cursor
*
cdst
)
;
#
define
MDB_SPLIT_REPLACE
MDB_APPENDDUP
/
*
*
<
newkey
is
not
new
*
/
static
int
mdb_page_split
(
MDB_cursor
*
mc
MDB_val
*
newkey
MDB_val
*
newdata
pgno_t
newpgno
unsigned
int
nflags
)
;
static
int
mdb_env_read_header
(
MDB_env
*
env
MDB_meta
*
meta
)
;
static
MDB_meta
*
mdb_env_pick_meta
(
const
MDB_env
*
env
)
;
static
int
mdb_env_write_meta
(
MDB_txn
*
txn
)
;
#
ifdef
MDB_USE_POSIX_MUTEX
#
define
mdb_env_close0
(
env
excl
)
mdb_env_close1
(
env
)
#
endif
static
void
mdb_env_close0
(
MDB_env
*
env
int
excl
)
;
static
MDB_node
*
mdb_node_search
(
MDB_cursor
*
mc
MDB_val
*
key
int
*
exactp
)
;
static
int
mdb_node_add
(
MDB_cursor
*
mc
indx_t
indx
MDB_val
*
key
MDB_val
*
data
pgno_t
pgno
unsigned
int
flags
)
;
static
void
mdb_node_del
(
MDB_cursor
*
mc
int
ksize
)
;
static
void
mdb_node_shrink
(
MDB_page
*
mp
indx_t
indx
)
;
static
int
mdb_node_move
(
MDB_cursor
*
csrc
MDB_cursor
*
cdst
int
fromleft
)
;
static
int
mdb_node_read
(
MDB_cursor
*
mc
MDB_node
*
leaf
MDB_val
*
data
)
;
static
size_t
mdb_leaf_size
(
MDB_env
*
env
MDB_val
*
key
MDB_val
*
data
)
;
static
size_t
mdb_branch_size
(
MDB_env
*
env
MDB_val
*
key
)
;
static
int
mdb_rebalance
(
MDB_cursor
*
mc
)
;
static
int
mdb_update_key
(
MDB_cursor
*
mc
MDB_val
*
key
)
;
static
void
mdb_cursor_pop
(
MDB_cursor
*
mc
)
;
static
int
mdb_cursor_push
(
MDB_cursor
*
mc
MDB_page
*
mp
)
;
static
int
mdb_cursor_del0
(
MDB_cursor
*
mc
)
;
static
int
mdb_del0
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_val
*
key
MDB_val
*
data
unsigned
flags
)
;
static
int
mdb_cursor_sibling
(
MDB_cursor
*
mc
int
move_right
)
;
static
int
mdb_cursor_next
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
)
;
static
int
mdb_cursor_prev
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
)
;
static
int
mdb_cursor_set
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
int
*
exactp
)
;
static
int
mdb_cursor_first
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
)
;
static
int
mdb_cursor_last
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
)
;
static
void
mdb_cursor_init
(
MDB_cursor
*
mc
MDB_txn
*
txn
MDB_dbi
dbi
MDB_xcursor
*
mx
)
;
static
void
mdb_xcursor_init0
(
MDB_cursor
*
mc
)
;
static
void
mdb_xcursor_init1
(
MDB_cursor
*
mc
MDB_node
*
node
)
;
static
void
mdb_xcursor_init2
(
MDB_cursor
*
mc
MDB_xcursor
*
src_mx
int
force
)
;
static
int
mdb_drop0
(
MDB_cursor
*
mc
int
subs
)
;
static
void
mdb_default_cmp
(
MDB_txn
*
txn
MDB_dbi
dbi
)
;
static
int
mdb_reader_check0
(
MDB_env
*
env
int
rlocked
int
*
dead
)
;
static
MDB_cmp_func
mdb_cmp_memn
mdb_cmp_memnr
mdb_cmp_int
mdb_cmp_cint
mdb_cmp_long
;
#
ifdef
MISALIGNED_OK
#
define
mdb_cmp_clong
mdb_cmp_long
#
else
#
define
mdb_cmp_clong
mdb_cmp_cint
#
endif
#
ifdef
_WIN32
static
SECURITY_DESCRIPTOR
mdb_null_sd
;
static
SECURITY_ATTRIBUTES
mdb_all_sa
;
static
int
mdb_sec_inited
;
struct
MDB_name
;
static
int
utf8_to_utf16
(
const
char
*
src
struct
MDB_name
*
dst
int
xtra
)
;
#
endif
char
*
ESECT
mdb_version
(
int
*
major
int
*
minor
int
*
patch
)
{
if
(
major
)
*
major
=
MDB_VERSION_MAJOR
;
if
(
minor
)
*
minor
=
MDB_VERSION_MINOR
;
if
(
patch
)
*
patch
=
MDB_VERSION_PATCH
;
return
MDB_VERSION_STRING
;
}
static
char
*
const
mdb_errstr
[
]
=
{
"
MDB_KEYEXIST
:
Key
/
data
pair
already
exists
"
"
MDB_NOTFOUND
:
No
matching
key
/
data
pair
found
"
"
MDB_PAGE_NOTFOUND
:
Requested
page
not
found
"
"
MDB_CORRUPTED
:
Located
page
was
wrong
type
"
"
MDB_PANIC
:
Update
of
meta
page
failed
or
environment
had
fatal
error
"
"
MDB_VERSION_MISMATCH
:
Database
environment
version
mismatch
"
"
MDB_INVALID
:
File
is
not
an
LMDB
file
"
"
MDB_MAP_FULL
:
Environment
mapsize
limit
reached
"
"
MDB_DBS_FULL
:
Environment
maxdbs
limit
reached
"
"
MDB_READERS_FULL
:
Environment
maxreaders
limit
reached
"
"
MDB_TLS_FULL
:
Thread
-
local
storage
keys
full
-
too
many
environments
open
"
"
MDB_TXN_FULL
:
Transaction
has
too
many
dirty
pages
-
transaction
too
big
"
"
MDB_CURSOR_FULL
:
Internal
error
-
cursor
stack
limit
reached
"
"
MDB_PAGE_FULL
:
Internal
error
-
page
has
no
more
space
"
"
MDB_MAP_RESIZED
:
Database
contents
grew
beyond
environment
mapsize
"
"
MDB_INCOMPATIBLE
:
Operation
and
DB
incompatible
or
DB
flags
changed
"
"
MDB_BAD_RSLOT
:
Invalid
reuse
of
reader
locktable
slot
"
"
MDB_BAD_TXN
:
Transaction
must
abort
has
a
child
or
is
invalid
"
"
MDB_BAD_VALSIZE
:
Unsupported
size
of
key
/
DB
name
/
data
or
wrong
DUPFIXED
size
"
"
MDB_BAD_DBI
:
The
specified
DBI
handle
was
closed
/
changed
unexpectedly
"
}
;
char
*
mdb_strerror
(
int
err
)
{
#
ifdef
_WIN32
#
define
MSGSIZE
1024
#
define
PADSIZE
4096
char
buf
[
MSGSIZE
+
PADSIZE
]
*
ptr
=
buf
;
#
endif
int
i
;
if
(
!
err
)
return
(
"
Successful
return
:
0
"
)
;
if
(
err
>
=
MDB_KEYEXIST
&
&
err
<
=
MDB_LAST_ERRCODE
)
{
i
=
err
-
MDB_KEYEXIST
;
return
mdb_errstr
[
i
]
;
}
#
ifdef
_WIN32
switch
(
err
)
{
case
ENOENT
:
case
EIO
:
case
ENOMEM
:
case
EACCES
:
case
EBUSY
:
case
EINVAL
:
case
ENOSPC
:
return
strerror
(
err
)
;
default
:
;
}
buf
[
0
]
=
0
;
FormatMessageA
(
FORMAT_MESSAGE_FROM_SYSTEM
|
FORMAT_MESSAGE_IGNORE_INSERTS
NULL
err
0
ptr
MSGSIZE
(
va_list
*
)
buf
+
MSGSIZE
)
;
return
ptr
;
#
else
return
strerror
(
err
)
;
#
endif
}
#
define
mdb_cassert
(
mc
expr
)
mdb_assert0
(
(
mc
)
-
>
mc_txn
-
>
mt_env
expr
#
expr
)
#
define
mdb_tassert
(
txn
expr
)
mdb_assert0
(
(
txn
)
-
>
mt_env
expr
#
expr
)
#
define
mdb_eassert
(
env
expr
)
mdb_assert0
(
env
expr
#
expr
)
#
ifndef
NDEBUG
#
define
mdb_assert0
(
env
expr
expr_txt
)
(
(
expr
)
?
(
void
)
0
:
\
mdb_assert_fail
(
env
expr_txt
mdb_func_
__FILE__
__LINE__
)
)
static
void
ESECT
mdb_assert_fail
(
MDB_env
*
env
const
char
*
expr_txt
const
char
*
func
const
char
*
file
int
line
)
{
char
buf
[
400
]
;
sprintf
(
buf
"
%
.
100s
:
%
d
:
Assertion
'
%
.
200s
'
failed
in
%
.
40s
(
)
"
file
line
expr_txt
func
)
;
if
(
env
-
>
me_assert_func
)
env
-
>
me_assert_func
(
env
buf
)
;
fprintf
(
stderr
"
%
s
\
n
"
buf
)
;
abort
(
)
;
}
#
else
#
define
mdb_assert0
(
env
expr
expr_txt
)
(
(
void
)
0
)
#
endif
#
if
MDB_DEBUG
static
pgno_t
mdb_dbg_pgno
(
MDB_page
*
mp
)
{
pgno_t
ret
;
COPY_PGNO
(
ret
mp
-
>
mp_pgno
)
;
return
ret
;
}
char
*
mdb_dkey
(
MDB_val
*
key
char
*
buf
)
{
char
*
ptr
=
buf
;
unsigned
char
*
c
=
key
-
>
mv_data
;
unsigned
int
i
;
if
(
!
key
)
return
"
"
;
if
(
key
-
>
mv_size
>
DKBUF_MAXKEYSIZE
)
return
"
MDB_MAXKEYSIZE
"
;
#
if
1
buf
[
0
]
=
'
\
0
'
;
for
(
i
=
0
;
i
<
key
-
>
mv_size
;
i
+
+
)
ptr
+
=
sprintf
(
ptr
"
%
02x
"
*
c
+
+
)
;
#
else
sprintf
(
buf
"
%
.
*
s
"
key
-
>
mv_size
key
-
>
mv_data
)
;
#
endif
return
buf
;
}
static
const
char
*
mdb_leafnode_type
(
MDB_node
*
n
)
{
static
char
*
const
tp
[
2
]
[
2
]
=
{
{
"
"
"
:
DB
"
}
{
"
:
sub
-
page
"
"
:
sub
-
DB
"
}
}
;
return
F_ISSET
(
n
-
>
mn_flags
F_BIGDATA
)
?
"
:
overflow
page
"
:
tp
[
F_ISSET
(
n
-
>
mn_flags
F_DUPDATA
)
]
[
F_ISSET
(
n
-
>
mn_flags
F_SUBDATA
)
]
;
}
void
mdb_page_list
(
MDB_page
*
mp
)
{
pgno_t
pgno
=
mdb_dbg_pgno
(
mp
)
;
const
char
*
type
*
state
=
(
mp
-
>
mp_flags
&
P_DIRTY
)
?
"
dirty
"
:
"
"
;
MDB_node
*
node
;
unsigned
int
i
nkeys
nsize
total
=
0
;
MDB_val
key
;
DKBUF
;
switch
(
mp
-
>
mp_flags
&
(
P_BRANCH
|
P_LEAF
|
P_LEAF2
|
P_META
|
P_OVERFLOW
|
P_SUBP
)
)
{
case
P_BRANCH
:
type
=
"
Branch
page
"
;
break
;
case
P_LEAF
:
type
=
"
Leaf
page
"
;
break
;
case
P_LEAF
|
P_SUBP
:
type
=
"
Sub
-
page
"
;
break
;
case
P_LEAF
|
P_LEAF2
:
type
=
"
LEAF2
page
"
;
break
;
case
P_LEAF
|
P_LEAF2
|
P_SUBP
:
type
=
"
LEAF2
sub
-
page
"
;
break
;
case
P_OVERFLOW
:
fprintf
(
stderr
"
Overflow
page
%
"
Z
"
u
pages
%
u
%
s
\
n
"
pgno
mp
-
>
mp_pages
state
)
;
return
;
case
P_META
:
fprintf
(
stderr
"
Meta
-
page
%
"
Z
"
u
txnid
%
"
Z
"
u
\
n
"
pgno
(
(
MDB_meta
*
)
METADATA
(
mp
)
)
-
>
mm_txnid
)
;
return
;
default
:
fprintf
(
stderr
"
Bad
page
%
"
Z
"
u
flags
0x
%
X
\
n
"
pgno
mp
-
>
mp_flags
)
;
return
;
}
nkeys
=
NUMKEYS
(
mp
)
;
fprintf
(
stderr
"
%
s
%
"
Z
"
u
numkeys
%
d
%
s
\
n
"
type
pgno
nkeys
state
)
;
for
(
i
=
0
;
i
<
nkeys
;
i
+
+
)
{
if
(
IS_LEAF2
(
mp
)
)
{
key
.
mv_size
=
nsize
=
mp
-
>
mp_pad
;
key
.
mv_data
=
LEAF2KEY
(
mp
i
nsize
)
;
total
+
=
nsize
;
fprintf
(
stderr
"
key
%
d
:
nsize
%
d
%
s
\
n
"
i
nsize
DKEY
(
&
key
)
)
;
continue
;
}
node
=
NODEPTR
(
mp
i
)
;
key
.
mv_size
=
node
-
>
mn_ksize
;
key
.
mv_data
=
node
-
>
mn_data
;
nsize
=
NODESIZE
+
key
.
mv_size
;
if
(
IS_BRANCH
(
mp
)
)
{
fprintf
(
stderr
"
key
%
d
:
page
%
"
Z
"
u
%
s
\
n
"
i
NODEPGNO
(
node
)
DKEY
(
&
key
)
)
;
total
+
=
nsize
;
}
else
{
if
(
F_ISSET
(
node
-
>
mn_flags
F_BIGDATA
)
)
nsize
+
=
sizeof
(
pgno_t
)
;
else
nsize
+
=
NODEDSZ
(
node
)
;
total
+
=
nsize
;
nsize
+
=
sizeof
(
indx_t
)
;
fprintf
(
stderr
"
key
%
d
:
nsize
%
d
%
s
%
s
\
n
"
i
nsize
DKEY
(
&
key
)
mdb_leafnode_type
(
node
)
)
;
}
total
=
EVEN
(
total
)
;
}
fprintf
(
stderr
"
Total
:
header
%
d
+
contents
%
d
+
unused
%
d
\
n
"
IS_LEAF2
(
mp
)
?
PAGEHDRSZ
:
PAGEBASE
+
mp
-
>
mp_lower
total
SIZELEFT
(
mp
)
)
;
}
void
mdb_cursor_chk
(
MDB_cursor
*
mc
)
{
unsigned
int
i
;
MDB_node
*
node
;
MDB_page
*
mp
;
if
(
!
mc
-
>
mc_snum
|
|
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
return
;
for
(
i
=
0
;
i
<
mc
-
>
mc_top
;
i
+
+
)
{
mp
=
mc
-
>
mc_pg
[
i
]
;
node
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
i
]
)
;
if
(
NODEPGNO
(
node
)
!
=
mc
-
>
mc_pg
[
i
+
1
]
-
>
mp_pgno
)
printf
(
"
oops
!
\
n
"
)
;
}
if
(
mc
-
>
mc_ki
[
i
]
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
i
]
)
)
printf
(
"
ack
!
\
n
"
)
;
if
(
XCURSOR_INITED
(
mc
)
)
{
node
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
(
(
node
-
>
mn_flags
&
(
F_DUPDATA
|
F_SUBDATA
)
)
=
=
F_DUPDATA
)
&
&
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
!
=
NODEDATA
(
node
)
)
{
printf
(
"
blah
!
\
n
"
)
;
}
}
}
#
endif
#
if
(
MDB_DEBUG
)
>
2
static
void
mdb_audit
(
MDB_txn
*
txn
)
{
MDB_cursor
mc
;
MDB_val
key
data
;
MDB_ID
freecount
count
;
MDB_dbi
i
;
int
rc
;
freecount
=
0
;
mdb_cursor_init
(
&
mc
txn
FREE_DBI
NULL
)
;
while
(
(
rc
=
mdb_cursor_get
(
&
mc
&
key
&
data
MDB_NEXT
)
)
=
=
0
)
freecount
+
=
*
(
MDB_ID
*
)
data
.
mv_data
;
mdb_tassert
(
txn
rc
=
=
MDB_NOTFOUND
)
;
count
=
0
;
for
(
i
=
0
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
{
MDB_xcursor
mx
;
if
(
!
(
txn
-
>
mt_dbflags
[
i
]
&
DB_VALID
)
)
continue
;
mdb_cursor_init
(
&
mc
txn
i
&
mx
)
;
if
(
txn
-
>
mt_dbs
[
i
]
.
md_root
=
=
P_INVALID
)
continue
;
count
+
=
txn
-
>
mt_dbs
[
i
]
.
md_branch_pages
+
txn
-
>
mt_dbs
[
i
]
.
md_leaf_pages
+
txn
-
>
mt_dbs
[
i
]
.
md_overflow_pages
;
if
(
txn
-
>
mt_dbs
[
i
]
.
md_flags
&
MDB_DUPSORT
)
{
rc
=
mdb_page_search
(
&
mc
NULL
MDB_PS_FIRST
)
;
for
(
;
rc
=
=
MDB_SUCCESS
;
rc
=
mdb_cursor_sibling
(
&
mc
1
)
)
{
unsigned
j
;
MDB_page
*
mp
;
mp
=
mc
.
mc_pg
[
mc
.
mc_top
]
;
for
(
j
=
0
;
j
<
NUMKEYS
(
mp
)
;
j
+
+
)
{
MDB_node
*
leaf
=
NODEPTR
(
mp
j
)
;
if
(
leaf
-
>
mn_flags
&
F_SUBDATA
)
{
MDB_db
db
;
memcpy
(
&
db
NODEDATA
(
leaf
)
sizeof
(
db
)
)
;
count
+
=
db
.
md_branch_pages
+
db
.
md_leaf_pages
+
db
.
md_overflow_pages
;
}
}
}
mdb_tassert
(
txn
rc
=
=
MDB_NOTFOUND
)
;
}
}
if
(
freecount
+
count
+
NUM_METAS
!
=
txn
-
>
mt_next_pgno
)
{
fprintf
(
stderr
"
audit
:
%
"
Z
"
u
freecount
:
%
"
Z
"
u
count
:
%
"
Z
"
u
total
:
%
"
Z
"
u
next_pgno
:
%
"
Z
"
u
\
n
"
txn
-
>
mt_txnid
freecount
count
+
NUM_METAS
freecount
+
count
+
NUM_METAS
txn
-
>
mt_next_pgno
)
;
}
}
#
endif
int
mdb_cmp
(
MDB_txn
*
txn
MDB_dbi
dbi
const
MDB_val
*
a
const
MDB_val
*
b
)
{
return
txn
-
>
mt_dbxs
[
dbi
]
.
md_cmp
(
a
b
)
;
}
int
mdb_dcmp
(
MDB_txn
*
txn
MDB_dbi
dbi
const
MDB_val
*
a
const
MDB_val
*
b
)
{
MDB_cmp_func
*
dcmp
=
txn
-
>
mt_dbxs
[
dbi
]
.
md_dcmp
;
#
if
UINT_MAX
<
SIZE_MAX
if
(
dcmp
=
=
mdb_cmp_int
&
&
a
-
>
mv_size
=
=
sizeof
(
size_t
)
)
dcmp
=
mdb_cmp_clong
;
#
endif
return
dcmp
(
a
b
)
;
}
static
MDB_page
*
mdb_page_malloc
(
MDB_txn
*
txn
unsigned
num
)
{
MDB_env
*
env
=
txn
-
>
mt_env
;
MDB_page
*
ret
=
env
-
>
me_dpages
;
size_t
psize
=
env
-
>
me_psize
sz
=
psize
off
;
if
(
num
=
=
1
)
{
if
(
ret
)
{
VGMEMP_ALLOC
(
env
ret
sz
)
;
VGMEMP_DEFINED
(
ret
sizeof
(
ret
-
>
mp_next
)
)
;
env
-
>
me_dpages
=
ret
-
>
mp_next
;
return
ret
;
}
psize
-
=
off
=
PAGEHDRSZ
;
}
else
{
sz
*
=
num
;
off
=
sz
-
psize
;
}
if
(
(
ret
=
malloc
(
sz
)
)
!
=
NULL
)
{
VGMEMP_ALLOC
(
env
ret
sz
)
;
if
(
!
(
env
-
>
me_flags
&
MDB_NOMEMINIT
)
)
{
memset
(
(
char
*
)
ret
+
off
0
psize
)
;
ret
-
>
mp_pad
=
0
;
}
}
else
{
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
}
return
ret
;
}
static
void
mdb_page_free
(
MDB_env
*
env
MDB_page
*
mp
)
{
mp
-
>
mp_next
=
env
-
>
me_dpages
;
VGMEMP_FREE
(
env
mp
)
;
env
-
>
me_dpages
=
mp
;
}
static
void
mdb_dpage_free
(
MDB_env
*
env
MDB_page
*
dp
)
{
if
(
!
IS_OVERFLOW
(
dp
)
|
|
dp
-
>
mp_pages
=
=
1
)
{
mdb_page_free
(
env
dp
)
;
}
else
{
VGMEMP_FREE
(
env
dp
)
;
free
(
dp
)
;
}
}
static
void
mdb_dlist_free
(
MDB_txn
*
txn
)
{
MDB_env
*
env
=
txn
-
>
mt_env
;
MDB_ID2L
dl
=
txn
-
>
mt_u
.
dirty_list
;
unsigned
i
n
=
dl
[
0
]
.
mid
;
for
(
i
=
1
;
i
<
=
n
;
i
+
+
)
{
mdb_dpage_free
(
env
dl
[
i
]
.
mptr
)
;
}
dl
[
0
]
.
mid
=
0
;
}
static
int
mdb_page_loose
(
MDB_cursor
*
mc
MDB_page
*
mp
)
{
int
loose
=
0
;
pgno_t
pgno
=
mp
-
>
mp_pgno
;
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
if
(
(
mp
-
>
mp_flags
&
P_DIRTY
)
&
&
mc
-
>
mc_dbi
!
=
FREE_DBI
)
{
if
(
txn
-
>
mt_parent
)
{
MDB_ID2
*
dl
=
txn
-
>
mt_u
.
dirty_list
;
if
(
dl
[
0
]
.
mid
)
{
unsigned
x
=
mdb_mid2l_search
(
dl
pgno
)
;
if
(
x
<
=
dl
[
0
]
.
mid
&
&
dl
[
x
]
.
mid
=
=
pgno
)
{
if
(
mp
!
=
dl
[
x
]
.
mptr
)
{
mc
-
>
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_CORRUPTED
;
}
loose
=
1
;
}
}
}
else
{
loose
=
1
;
}
}
if
(
loose
)
{
DPRINTF
(
(
"
loosen
db
%
d
page
%
"
Z
"
u
"
DDBI
(
mc
)
mp
-
>
mp_pgno
)
)
;
NEXT_LOOSE_PAGE
(
mp
)
=
txn
-
>
mt_loose_pgs
;
txn
-
>
mt_loose_pgs
=
mp
;
txn
-
>
mt_loose_count
+
+
;
mp
-
>
mp_flags
|
=
P_LOOSE
;
}
else
{
int
rc
=
mdb_midl_append
(
&
txn
-
>
mt_free_pgs
pgno
)
;
if
(
rc
)
return
rc
;
}
return
MDB_SUCCESS
;
}
static
int
mdb_pages_xkeep
(
MDB_cursor
*
mc
unsigned
pflags
int
all
)
{
enum
{
Mask
=
P_SUBP
|
P_DIRTY
|
P_LOOSE
|
P_KEEP
}
;
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
MDB_cursor
*
m3
*
m0
=
mc
;
MDB_xcursor
*
mx
;
MDB_page
*
dp
*
mp
;
MDB_node
*
leaf
;
unsigned
i
j
;
int
rc
=
MDB_SUCCESS
level
;
if
(
mc
-
>
mc_flags
&
C_UNTRACK
)
mc
=
NULL
;
for
(
i
=
txn
-
>
mt_numdbs
;
;
mc
=
txn
-
>
mt_cursors
[
-
-
i
]
)
{
for
(
;
mc
;
mc
=
mc
-
>
mc_next
)
{
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
for
(
m3
=
mc
;
;
m3
=
&
mx
-
>
mx_cursor
)
{
mp
=
NULL
;
for
(
j
=
0
;
j
<
m3
-
>
mc_snum
;
j
+
+
)
{
mp
=
m3
-
>
mc_pg
[
j
]
;
if
(
(
mp
-
>
mp_flags
&
Mask
)
=
=
pflags
)
mp
-
>
mp_flags
^
=
P_KEEP
;
}
mx
=
m3
-
>
mc_xcursor
;
if
(
!
(
mx
&
&
(
mx
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
)
)
break
;
if
(
!
(
mp
&
&
(
mp
-
>
mp_flags
&
P_LEAF
)
)
)
break
;
leaf
=
NODEPTR
(
mp
m3
-
>
mc_ki
[
j
-
1
]
)
;
if
(
!
(
leaf
-
>
mn_flags
&
F_SUBDATA
)
)
break
;
}
}
if
(
i
=
=
0
)
break
;
}
if
(
all
)
{
for
(
i
=
0
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
{
if
(
txn
-
>
mt_dbflags
[
i
]
&
DB_DIRTY
)
{
pgno_t
pgno
=
txn
-
>
mt_dbs
[
i
]
.
md_root
;
if
(
pgno
=
=
P_INVALID
)
continue
;
if
(
(
rc
=
mdb_page_get
(
m0
pgno
&
dp
&
level
)
)
!
=
MDB_SUCCESS
)
break
;
if
(
(
dp
-
>
mp_flags
&
Mask
)
=
=
pflags
&
&
level
<
=
1
)
dp
-
>
mp_flags
^
=
P_KEEP
;
}
}
}
return
rc
;
}
static
int
mdb_page_flush
(
MDB_txn
*
txn
int
keep
)
;
static
int
mdb_page_spill
(
MDB_cursor
*
m0
MDB_val
*
key
MDB_val
*
data
)
{
MDB_txn
*
txn
=
m0
-
>
mc_txn
;
MDB_page
*
dp
;
MDB_ID2L
dl
=
txn
-
>
mt_u
.
dirty_list
;
unsigned
int
i
j
need
;
int
rc
;
if
(
m0
-
>
mc_flags
&
C_SUB
)
return
MDB_SUCCESS
;
i
=
m0
-
>
mc_db
-
>
md_depth
;
if
(
m0
-
>
mc_dbi
>
=
CORE_DBS
)
i
+
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_depth
;
if
(
key
)
i
+
=
(
LEAFSIZE
(
key
data
)
+
txn
-
>
mt_env
-
>
me_psize
)
/
txn
-
>
mt_env
-
>
me_psize
;
i
+
=
i
;
need
=
i
;
if
(
txn
-
>
mt_dirty_room
>
i
)
return
MDB_SUCCESS
;
if
(
!
txn
-
>
mt_spill_pgs
)
{
txn
-
>
mt_spill_pgs
=
mdb_midl_alloc
(
MDB_IDL_UM_MAX
)
;
if
(
!
txn
-
>
mt_spill_pgs
)
return
ENOMEM
;
}
else
{
MDB_IDL
sl
=
txn
-
>
mt_spill_pgs
;
unsigned
int
num
=
sl
[
0
]
;
j
=
0
;
for
(
i
=
1
;
i
<
=
num
;
i
+
+
)
{
if
(
!
(
sl
[
i
]
&
1
)
)
sl
[
+
+
j
]
=
sl
[
i
]
;
}
sl
[
0
]
=
j
;
}
if
(
(
rc
=
mdb_pages_xkeep
(
m0
P_DIRTY
1
)
)
!
=
MDB_SUCCESS
)
goto
done
;
if
(
need
<
MDB_IDL_UM_MAX
/
8
)
need
=
MDB_IDL_UM_MAX
/
8
;
for
(
i
=
dl
[
0
]
.
mid
;
i
&
&
need
;
i
-
-
)
{
MDB_ID
pn
=
dl
[
i
]
.
mid
<
<
1
;
dp
=
dl
[
i
]
.
mptr
;
if
(
dp
-
>
mp_flags
&
(
P_LOOSE
|
P_KEEP
)
)
continue
;
if
(
txn
-
>
mt_parent
)
{
MDB_txn
*
tx2
;
for
(
tx2
=
txn
-
>
mt_parent
;
tx2
;
tx2
=
tx2
-
>
mt_parent
)
{
if
(
tx2
-
>
mt_spill_pgs
)
{
j
=
mdb_midl_search
(
tx2
-
>
mt_spill_pgs
pn
)
;
if
(
j
<
=
tx2
-
>
mt_spill_pgs
[
0
]
&
&
tx2
-
>
mt_spill_pgs
[
j
]
=
=
pn
)
{
dp
-
>
mp_flags
|
=
P_KEEP
;
break
;
}
}
}
if
(
tx2
)
continue
;
}
if
(
(
rc
=
mdb_midl_append
(
&
txn
-
>
mt_spill_pgs
pn
)
)
)
goto
done
;
need
-
-
;
}
mdb_midl_sort
(
txn
-
>
mt_spill_pgs
)
;
if
(
(
rc
=
mdb_page_flush
(
txn
i
)
)
!
=
MDB_SUCCESS
)
goto
done
;
rc
=
mdb_pages_xkeep
(
m0
P_DIRTY
|
P_KEEP
i
)
;
done
:
txn
-
>
mt_flags
|
=
rc
?
MDB_TXN_ERROR
:
MDB_TXN_SPILLS
;
return
rc
;
}
static
txnid_t
mdb_find_oldest
(
MDB_txn
*
txn
)
{
int
i
;
txnid_t
mr
oldest
=
txn
-
>
mt_txnid
-
1
;
if
(
txn
-
>
mt_env
-
>
me_txns
)
{
MDB_reader
*
r
=
txn
-
>
mt_env
-
>
me_txns
-
>
mti_readers
;
for
(
i
=
txn
-
>
mt_env
-
>
me_txns
-
>
mti_numreaders
;
-
-
i
>
=
0
;
)
{
if
(
r
[
i
]
.
mr_pid
)
{
mr
=
r
[
i
]
.
mr_txnid
;
if
(
oldest
>
mr
)
oldest
=
mr
;
}
}
}
return
oldest
;
}
static
void
mdb_page_dirty
(
MDB_txn
*
txn
MDB_page
*
mp
)
{
MDB_ID2
mid
;
int
rc
(
*
insert
)
(
MDB_ID2L
MDB_ID2
*
)
;
if
(
txn
-
>
mt_flags
&
MDB_TXN_WRITEMAP
)
{
insert
=
mdb_mid2l_append
;
}
else
{
insert
=
mdb_mid2l_insert
;
}
mid
.
mid
=
mp
-
>
mp_pgno
;
mid
.
mptr
=
mp
;
rc
=
insert
(
txn
-
>
mt_u
.
dirty_list
&
mid
)
;
mdb_tassert
(
txn
rc
=
=
0
)
;
txn
-
>
mt_dirty_room
-
-
;
}
static
int
mdb_page_alloc
(
MDB_cursor
*
mc
int
num
MDB_page
*
*
mp
)
{
#
ifdef
MDB_PARANOID
enum
{
Paranoid
=
1
Max_retries
=
500
}
;
#
else
enum
{
Paranoid
=
0
Max_retries
=
INT_MAX
}
;
#
endif
int
rc
retry
=
num
*
60
;
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
MDB_env
*
env
=
txn
-
>
mt_env
;
pgno_t
pgno
*
mop
=
env
-
>
me_pghead
;
unsigned
i
j
mop_len
=
mop
?
mop
[
0
]
:
0
n2
=
num
-
1
;
MDB_page
*
np
;
txnid_t
oldest
=
0
last
;
MDB_cursor_op
op
;
MDB_cursor
m2
;
int
found_old
=
0
;
if
(
num
=
=
1
&
&
txn
-
>
mt_loose_pgs
)
{
np
=
txn
-
>
mt_loose_pgs
;
txn
-
>
mt_loose_pgs
=
NEXT_LOOSE_PAGE
(
np
)
;
txn
-
>
mt_loose_count
-
-
;
DPRINTF
(
(
"
db
%
d
use
loose
page
%
"
Z
"
u
"
DDBI
(
mc
)
np
-
>
mp_pgno
)
)
;
*
mp
=
np
;
return
MDB_SUCCESS
;
}
*
mp
=
NULL
;
if
(
txn
-
>
mt_dirty_room
=
=
0
)
{
rc
=
MDB_TXN_FULL
;
goto
fail
;
}
for
(
op
=
MDB_FIRST
;
;
op
=
MDB_NEXT
)
{
MDB_val
key
data
;
MDB_node
*
leaf
;
pgno_t
*
idl
;
if
(
mop_len
>
n2
)
{
i
=
mop_len
;
do
{
pgno
=
mop
[
i
]
;
if
(
mop
[
i
-
n2
]
=
=
pgno
+
n2
)
goto
search_done
;
}
while
(
-
-
i
>
n2
)
;
if
(
-
-
retry
<
0
)
break
;
}
if
(
op
=
=
MDB_FIRST
)
{
last
=
env
-
>
me_pglast
;
oldest
=
env
-
>
me_pgoldest
;
mdb_cursor_init
(
&
m2
txn
FREE_DBI
NULL
)
;
if
(
last
)
{
op
=
MDB_SET_RANGE
;
key
.
mv_data
=
&
last
;
key
.
mv_size
=
sizeof
(
last
)
;
}
if
(
Paranoid
&
&
mc
-
>
mc_dbi
=
=
FREE_DBI
)
retry
=
-
1
;
}
if
(
Paranoid
&
&
retry
<
0
&
&
mop_len
)
break
;
last
+
+
;
if
(
oldest
<
=
last
)
{
if
(
!
found_old
)
{
oldest
=
mdb_find_oldest
(
txn
)
;
env
-
>
me_pgoldest
=
oldest
;
found_old
=
1
;
}
if
(
oldest
<
=
last
)
break
;
}
rc
=
mdb_cursor_get
(
&
m2
&
key
NULL
op
)
;
if
(
rc
)
{
if
(
rc
=
=
MDB_NOTFOUND
)
break
;
goto
fail
;
}
last
=
*
(
txnid_t
*
)
key
.
mv_data
;
if
(
oldest
<
=
last
)
{
if
(
!
found_old
)
{
oldest
=
mdb_find_oldest
(
txn
)
;
env
-
>
me_pgoldest
=
oldest
;
found_old
=
1
;
}
if
(
oldest
<
=
last
)
break
;
}
np
=
m2
.
mc_pg
[
m2
.
mc_top
]
;
leaf
=
NODEPTR
(
np
m2
.
mc_ki
[
m2
.
mc_top
]
)
;
if
(
(
rc
=
mdb_node_read
(
&
m2
leaf
&
data
)
)
!
=
MDB_SUCCESS
)
goto
fail
;
idl
=
(
MDB_ID
*
)
data
.
mv_data
;
i
=
idl
[
0
]
;
if
(
!
mop
)
{
if
(
!
(
env
-
>
me_pghead
=
mop
=
mdb_midl_alloc
(
i
)
)
)
{
rc
=
ENOMEM
;
goto
fail
;
}
}
else
{
if
(
(
rc
=
mdb_midl_need
(
&
env
-
>
me_pghead
i
)
)
!
=
0
)
goto
fail
;
mop
=
env
-
>
me_pghead
;
}
env
-
>
me_pglast
=
last
;
#
if
(
MDB_DEBUG
)
>
1
DPRINTF
(
(
"
IDL
read
txn
%
"
Z
"
u
root
%
"
Z
"
u
num
%
u
"
last
txn
-
>
mt_dbs
[
FREE_DBI
]
.
md_root
i
)
)
;
for
(
j
=
i
;
j
;
j
-
-
)
DPRINTF
(
(
"
IDL
%
"
Z
"
u
"
idl
[
j
]
)
)
;
#
endif
mdb_midl_xmerge
(
mop
idl
)
;
mop_len
=
mop
[
0
]
;
}
i
=
0
;
pgno
=
txn
-
>
mt_next_pgno
;
if
(
pgno
+
num
>
=
env
-
>
me_maxpg
)
{
DPUTS
(
"
DB
size
maxed
out
"
)
;
rc
=
MDB_MAP_FULL
;
goto
fail
;
}
search_done
:
if
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
{
np
=
(
MDB_page
*
)
(
env
-
>
me_map
+
env
-
>
me_psize
*
pgno
)
;
}
else
{
if
(
!
(
np
=
mdb_page_malloc
(
txn
num
)
)
)
{
rc
=
ENOMEM
;
goto
fail
;
}
}
if
(
i
)
{
mop
[
0
]
=
mop_len
-
=
num
;
for
(
j
=
i
-
num
;
j
<
mop_len
;
)
mop
[
+
+
j
]
=
mop
[
+
+
i
]
;
}
else
{
txn
-
>
mt_next_pgno
=
pgno
+
num
;
}
np
-
>
mp_pgno
=
pgno
;
mdb_page_dirty
(
txn
np
)
;
*
mp
=
np
;
return
MDB_SUCCESS
;
fail
:
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
rc
;
}
static
void
mdb_page_copy
(
MDB_page
*
dst
MDB_page
*
src
unsigned
int
psize
)
{
enum
{
Align
=
sizeof
(
pgno_t
)
}
;
indx_t
upper
=
src
-
>
mp_upper
lower
=
src
-
>
mp_lower
unused
=
upper
-
lower
;
if
(
(
unused
&
=
-
Align
)
&
&
!
IS_LEAF2
(
src
)
)
{
upper
=
(
upper
+
PAGEBASE
)
&
-
Align
;
memcpy
(
dst
src
(
lower
+
PAGEBASE
+
(
Align
-
1
)
)
&
-
Align
)
;
memcpy
(
(
pgno_t
*
)
(
(
char
*
)
dst
+
upper
)
(
pgno_t
*
)
(
(
char
*
)
src
+
upper
)
psize
-
upper
)
;
}
else
{
memcpy
(
dst
src
psize
-
unused
)
;
}
}
static
int
mdb_page_unspill
(
MDB_txn
*
txn
MDB_page
*
mp
MDB_page
*
*
ret
)
{
MDB_env
*
env
=
txn
-
>
mt_env
;
const
MDB_txn
*
tx2
;
unsigned
x
;
pgno_t
pgno
=
mp
-
>
mp_pgno
pn
=
pgno
<
<
1
;
for
(
tx2
=
txn
;
tx2
;
tx2
=
tx2
-
>
mt_parent
)
{
if
(
!
tx2
-
>
mt_spill_pgs
)
continue
;
x
=
mdb_midl_search
(
tx2
-
>
mt_spill_pgs
pn
)
;
if
(
x
<
=
tx2
-
>
mt_spill_pgs
[
0
]
&
&
tx2
-
>
mt_spill_pgs
[
x
]
=
=
pn
)
{
MDB_page
*
np
;
int
num
;
if
(
txn
-
>
mt_dirty_room
=
=
0
)
return
MDB_TXN_FULL
;
if
(
IS_OVERFLOW
(
mp
)
)
num
=
mp
-
>
mp_pages
;
else
num
=
1
;
if
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
{
np
=
mp
;
}
else
{
np
=
mdb_page_malloc
(
txn
num
)
;
if
(
!
np
)
return
ENOMEM
;
if
(
num
>
1
)
memcpy
(
np
mp
num
*
env
-
>
me_psize
)
;
else
mdb_page_copy
(
np
mp
env
-
>
me_psize
)
;
}
if
(
tx2
=
=
txn
)
{
if
(
x
=
=
txn
-
>
mt_spill_pgs
[
0
]
)
txn
-
>
mt_spill_pgs
[
0
]
-
-
;
else
txn
-
>
mt_spill_pgs
[
x
]
|
=
1
;
}
mdb_page_dirty
(
txn
np
)
;
np
-
>
mp_flags
|
=
P_DIRTY
;
*
ret
=
np
;
break
;
}
}
return
MDB_SUCCESS
;
}
static
int
mdb_page_touch
(
MDB_cursor
*
mc
)
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
*
np
;
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
MDB_cursor
*
m2
*
m3
;
pgno_t
pgno
;
int
rc
;
if
(
!
F_ISSET
(
mp
-
>
mp_flags
P_DIRTY
)
)
{
if
(
txn
-
>
mt_flags
&
MDB_TXN_SPILLS
)
{
np
=
NULL
;
rc
=
mdb_page_unspill
(
txn
mp
&
np
)
;
if
(
rc
)
goto
fail
;
if
(
np
)
goto
done
;
}
if
(
(
rc
=
mdb_midl_need
(
&
txn
-
>
mt_free_pgs
1
)
)
|
|
(
rc
=
mdb_page_alloc
(
mc
1
&
np
)
)
)
goto
fail
;
pgno
=
np
-
>
mp_pgno
;
DPRINTF
(
(
"
touched
db
%
d
page
%
"
Z
"
u
-
>
%
"
Z
"
u
"
DDBI
(
mc
)
mp
-
>
mp_pgno
pgno
)
)
;
mdb_cassert
(
mc
mp
-
>
mp_pgno
!
=
pgno
)
;
mdb_midl_xappend
(
txn
-
>
mt_free_pgs
mp
-
>
mp_pgno
)
;
if
(
mc
-
>
mc_top
)
{
MDB_page
*
parent
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
-
1
]
;
MDB_node
*
node
=
NODEPTR
(
parent
mc
-
>
mc_ki
[
mc
-
>
mc_top
-
1
]
)
;
SETPGNO
(
node
pgno
)
;
}
else
{
mc
-
>
mc_db
-
>
md_root
=
pgno
;
}
}
else
if
(
txn
-
>
mt_parent
&
&
!
IS_SUBP
(
mp
)
)
{
MDB_ID2
mid
*
dl
=
txn
-
>
mt_u
.
dirty_list
;
pgno
=
mp
-
>
mp_pgno
;
if
(
dl
[
0
]
.
mid
)
{
unsigned
x
=
mdb_mid2l_search
(
dl
pgno
)
;
if
(
x
<
=
dl
[
0
]
.
mid
&
&
dl
[
x
]
.
mid
=
=
pgno
)
{
if
(
mp
!
=
dl
[
x
]
.
mptr
)
{
mc
-
>
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_CORRUPTED
;
}
return
0
;
}
}
mdb_cassert
(
mc
dl
[
0
]
.
mid
<
MDB_IDL_UM_MAX
)
;
np
=
mdb_page_malloc
(
txn
1
)
;
if
(
!
np
)
return
ENOMEM
;
mid
.
mid
=
pgno
;
mid
.
mptr
=
np
;
rc
=
mdb_mid2l_insert
(
dl
&
mid
)
;
mdb_cassert
(
mc
rc
=
=
0
)
;
}
else
{
return
0
;
}
mdb_page_copy
(
np
mp
txn
-
>
mt_env
-
>
me_psize
)
;
np
-
>
mp_pgno
=
pgno
;
np
-
>
mp_flags
|
=
P_DIRTY
;
done
:
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
np
;
m2
=
txn
-
>
mt_cursors
[
mc
-
>
mc_dbi
]
;
if
(
mc
-
>
mc_flags
&
C_SUB
)
{
for
(
;
m2
;
m2
=
m2
-
>
mc_next
)
{
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
if
(
m3
-
>
mc_snum
<
mc
-
>
mc_snum
)
continue
;
if
(
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
=
=
mp
)
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
=
np
;
}
}
else
{
for
(
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
m2
-
>
mc_snum
<
mc
-
>
mc_snum
)
continue
;
if
(
m2
=
=
mc
)
continue
;
if
(
m2
-
>
mc_pg
[
mc
-
>
mc_top
]
=
=
mp
)
{
m2
-
>
mc_pg
[
mc
-
>
mc_top
]
=
np
;
if
(
XCURSOR_INITED
(
m2
)
&
&
IS_LEAF
(
np
)
)
XCURSOR_REFRESH
(
m2
np
m2
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
}
}
}
return
0
;
fail
:
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
rc
;
}
int
mdb_env_sync
(
MDB_env
*
env
int
force
)
{
int
rc
=
0
;
if
(
env
-
>
me_flags
&
MDB_RDONLY
)
return
EACCES
;
if
(
force
|
|
!
F_ISSET
(
env
-
>
me_flags
MDB_NOSYNC
)
)
{
if
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
{
int
flags
=
(
(
env
-
>
me_flags
&
MDB_MAPASYNC
)
&
&
!
force
)
?
MS_ASYNC
:
MS_SYNC
;
if
(
MDB_MSYNC
(
env
-
>
me_map
env
-
>
me_mapsize
flags
)
)
rc
=
ErrCode
(
)
;
#
ifdef
_WIN32
else
if
(
flags
=
=
MS_SYNC
&
&
MDB_FDATASYNC
(
env
-
>
me_fd
)
)
rc
=
ErrCode
(
)
;
#
endif
}
else
{
#
ifdef
BROKEN_FDATASYNC
if
(
env
-
>
me_flags
&
MDB_FSYNCONLY
)
{
if
(
fsync
(
env
-
>
me_fd
)
)
rc
=
ErrCode
(
)
;
}
else
#
endif
if
(
MDB_FDATASYNC
(
env
-
>
me_fd
)
)
rc
=
ErrCode
(
)
;
}
}
return
rc
;
}
static
int
mdb_cursor_shadow
(
MDB_txn
*
src
MDB_txn
*
dst
)
{
MDB_cursor
*
mc
*
bk
;
MDB_xcursor
*
mx
;
size_t
size
;
int
i
;
for
(
i
=
src
-
>
mt_numdbs
;
-
-
i
>
=
0
;
)
{
if
(
(
mc
=
src
-
>
mt_cursors
[
i
]
)
!
=
NULL
)
{
size
=
sizeof
(
MDB_cursor
)
;
if
(
mc
-
>
mc_xcursor
)
size
+
=
sizeof
(
MDB_xcursor
)
;
for
(
;
mc
;
mc
=
bk
-
>
mc_next
)
{
bk
=
malloc
(
size
)
;
if
(
!
bk
)
return
ENOMEM
;
*
bk
=
*
mc
;
mc
-
>
mc_backup
=
bk
;
mc
-
>
mc_db
=
&
dst
-
>
mt_dbs
[
i
]
;
mc
-
>
mc_txn
=
dst
;
mc
-
>
mc_dbflag
=
&
dst
-
>
mt_dbflags
[
i
]
;
if
(
(
mx
=
mc
-
>
mc_xcursor
)
!
=
NULL
)
{
*
(
MDB_xcursor
*
)
(
bk
+
1
)
=
*
mx
;
mx
-
>
mx_cursor
.
mc_txn
=
dst
;
}
mc
-
>
mc_next
=
dst
-
>
mt_cursors
[
i
]
;
dst
-
>
mt_cursors
[
i
]
=
mc
;
}
}
}
return
MDB_SUCCESS
;
}
static
void
mdb_cursors_close
(
MDB_txn
*
txn
unsigned
merge
)
{
MDB_cursor
*
*
cursors
=
txn
-
>
mt_cursors
*
mc
*
next
*
bk
;
MDB_xcursor
*
mx
;
int
i
;
for
(
i
=
txn
-
>
mt_numdbs
;
-
-
i
>
=
0
;
)
{
for
(
mc
=
cursors
[
i
]
;
mc
;
mc
=
next
)
{
next
=
mc
-
>
mc_next
;
if
(
(
bk
=
mc
-
>
mc_backup
)
!
=
NULL
)
{
if
(
merge
)
{
mc
-
>
mc_next
=
bk
-
>
mc_next
;
mc
-
>
mc_backup
=
bk
-
>
mc_backup
;
mc
-
>
mc_txn
=
bk
-
>
mc_txn
;
mc
-
>
mc_db
=
bk
-
>
mc_db
;
mc
-
>
mc_dbflag
=
bk
-
>
mc_dbflag
;
if
(
(
mx
=
mc
-
>
mc_xcursor
)
!
=
NULL
)
mx
-
>
mx_cursor
.
mc_txn
=
bk
-
>
mc_txn
;
}
else
{
*
mc
=
*
bk
;
if
(
(
mx
=
mc
-
>
mc_xcursor
)
!
=
NULL
)
*
mx
=
*
(
MDB_xcursor
*
)
(
bk
+
1
)
;
}
mc
=
bk
;
}
free
(
mc
)
;
}
cursors
[
i
]
=
NULL
;
}
}
#
if
!
(
MDB_PIDLOCK
)
enum
Pidlock_op
{
Pidset
Pidcheck
}
;
#
else
enum
Pidlock_op
{
Pidset
=
F_SETLK
Pidcheck
=
F_GETLK
}
;
#
endif
static
int
mdb_reader_pid
(
MDB_env
*
env
enum
Pidlock_op
op
MDB_PID_T
pid
)
{
#
if
!
(
MDB_PIDLOCK
)
int
ret
=
0
;
HANDLE
h
;
if
(
op
=
=
Pidcheck
)
{
h
=
OpenProcess
(
env
-
>
me_pidquery
FALSE
pid
)
;
if
(
!
h
)
return
ErrCode
(
)
!
=
ERROR_INVALID_PARAMETER
;
ret
=
WaitForSingleObject
(
h
0
)
!
=
0
;
CloseHandle
(
h
)
;
}
return
ret
;
#
else
for
(
;
;
)
{
int
rc
;
struct
flock
lock_info
;
memset
(
&
lock_info
0
sizeof
(
lock_info
)
)
;
lock_info
.
l_type
=
F_WRLCK
;
lock_info
.
l_whence
=
SEEK_SET
;
lock_info
.
l_start
=
pid
;
lock_info
.
l_len
=
1
;
if
(
(
rc
=
fcntl
(
env
-
>
me_lfd
op
&
lock_info
)
)
=
=
0
)
{
if
(
op
=
=
F_GETLK
&
&
lock_info
.
l_type
!
=
F_UNLCK
)
rc
=
-
1
;
}
else
if
(
(
rc
=
ErrCode
(
)
)
=
=
EINTR
)
{
continue
;
}
return
rc
;
}
#
endif
}
static
int
mdb_txn_renew0
(
MDB_txn
*
txn
)
{
MDB_env
*
env
=
txn
-
>
mt_env
;
MDB_txninfo
*
ti
=
env
-
>
me_txns
;
MDB_meta
*
meta
;
unsigned
int
i
nr
flags
=
txn
-
>
mt_flags
;
uint16_t
x
;
int
rc
new_notls
=
0
;
if
(
(
flags
&
=
MDB_TXN_RDONLY
)
!
=
0
)
{
if
(
!
ti
)
{
meta
=
mdb_env_pick_meta
(
env
)
;
txn
-
>
mt_txnid
=
meta
-
>
mm_txnid
;
txn
-
>
mt_u
.
reader
=
NULL
;
}
else
{
MDB_reader
*
r
=
(
env
-
>
me_flags
&
MDB_NOTLS
)
?
txn
-
>
mt_u
.
reader
:
pthread_getspecific
(
env
-
>
me_txkey
)
;
if
(
r
)
{
if
(
r
-
>
mr_pid
!
=
env
-
>
me_pid
|
|
r
-
>
mr_txnid
!
=
(
txnid_t
)
-
1
)
return
MDB_BAD_RSLOT
;
}
else
{
MDB_PID_T
pid
=
env
-
>
me_pid
;
MDB_THR_T
tid
=
pthread_self
(
)
;
mdb_mutexref_t
rmutex
=
env
-
>
me_rmutex
;
if
(
!
env
-
>
me_live_reader
)
{
rc
=
mdb_reader_pid
(
env
Pidset
pid
)
;
if
(
rc
)
return
rc
;
env
-
>
me_live_reader
=
1
;
}
if
(
LOCK_MUTEX
(
rc
env
rmutex
)
)
return
rc
;
nr
=
ti
-
>
mti_numreaders
;
for
(
i
=
0
;
i
<
nr
;
i
+
+
)
if
(
ti
-
>
mti_readers
[
i
]
.
mr_pid
=
=
0
)
break
;
if
(
i
=
=
env
-
>
me_maxreaders
)
{
UNLOCK_MUTEX
(
rmutex
)
;
return
MDB_READERS_FULL
;
}
r
=
&
ti
-
>
mti_readers
[
i
]
;
r
-
>
mr_pid
=
0
;
r
-
>
mr_txnid
=
(
txnid_t
)
-
1
;
r
-
>
mr_tid
=
tid
;
if
(
i
=
=
nr
)
ti
-
>
mti_numreaders
=
+
+
nr
;
env
-
>
me_close_readers
=
nr
;
r
-
>
mr_pid
=
pid
;
UNLOCK_MUTEX
(
rmutex
)
;
new_notls
=
(
env
-
>
me_flags
&
MDB_NOTLS
)
;
if
(
!
new_notls
&
&
(
rc
=
pthread_setspecific
(
env
-
>
me_txkey
r
)
)
)
{
r
-
>
mr_pid
=
0
;
return
rc
;
}
}
do
r
-
>
mr_txnid
=
ti
-
>
mti_txnid
;
while
(
r
-
>
mr_txnid
!
=
ti
-
>
mti_txnid
)
;
txn
-
>
mt_txnid
=
r
-
>
mr_txnid
;
txn
-
>
mt_u
.
reader
=
r
;
meta
=
env
-
>
me_metas
[
txn
-
>
mt_txnid
&
1
]
;
}
}
else
{
if
(
ti
)
{
if
(
LOCK_MUTEX
(
rc
env
env
-
>
me_wmutex
)
)
return
rc
;
txn
-
>
mt_txnid
=
ti
-
>
mti_txnid
;
meta
=
env
-
>
me_metas
[
txn
-
>
mt_txnid
&
1
]
;
}
else
{
meta
=
mdb_env_pick_meta
(
env
)
;
txn
-
>
mt_txnid
=
meta
-
>
mm_txnid
;
}
txn
-
>
mt_txnid
+
+
;
#
if
MDB_DEBUG
if
(
txn
-
>
mt_txnid
=
=
mdb_debug_start
)
mdb_debug
=
1
;
#
endif
txn
-
>
mt_child
=
NULL
;
txn
-
>
mt_loose_pgs
=
NULL
;
txn
-
>
mt_loose_count
=
0
;
txn
-
>
mt_dirty_room
=
MDB_IDL_UM_MAX
;
txn
-
>
mt_u
.
dirty_list
=
env
-
>
me_dirty_list
;
txn
-
>
mt_u
.
dirty_list
[
0
]
.
mid
=
0
;
txn
-
>
mt_free_pgs
=
env
-
>
me_free_pgs
;
txn
-
>
mt_free_pgs
[
0
]
=
0
;
txn
-
>
mt_spill_pgs
=
NULL
;
env
-
>
me_txn
=
txn
;
memcpy
(
txn
-
>
mt_dbiseqs
env
-
>
me_dbiseqs
env
-
>
me_maxdbs
*
sizeof
(
unsigned
int
)
)
;
}
memcpy
(
txn
-
>
mt_dbs
meta
-
>
mm_dbs
CORE_DBS
*
sizeof
(
MDB_db
)
)
;
txn
-
>
mt_next_pgno
=
meta
-
>
mm_last_pg
+
1
;
txn
-
>
mt_flags
=
flags
;
txn
-
>
mt_numdbs
=
env
-
>
me_numdbs
;
for
(
i
=
CORE_DBS
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
{
x
=
env
-
>
me_dbflags
[
i
]
;
txn
-
>
mt_dbs
[
i
]
.
md_flags
=
x
&
PERSISTENT_FLAGS
;
txn
-
>
mt_dbflags
[
i
]
=
(
x
&
MDB_VALID
)
?
DB_VALID
|
DB_USRVALID
|
DB_STALE
:
0
;
}
txn
-
>
mt_dbflags
[
MAIN_DBI
]
=
DB_VALID
|
DB_USRVALID
;
txn
-
>
mt_dbflags
[
FREE_DBI
]
=
DB_VALID
;
if
(
env
-
>
me_flags
&
MDB_FATAL_ERROR
)
{
DPUTS
(
"
environment
had
fatal
error
must
shutdown
!
"
)
;
rc
=
MDB_PANIC
;
}
else
if
(
env
-
>
me_maxpg
<
txn
-
>
mt_next_pgno
)
{
rc
=
MDB_MAP_RESIZED
;
}
else
{
return
MDB_SUCCESS
;
}
mdb_txn_end
(
txn
new_notls
|
MDB_END_FAIL_BEGIN
)
;
return
rc
;
}
int
mdb_txn_renew
(
MDB_txn
*
txn
)
{
int
rc
;
if
(
!
txn
|
|
!
F_ISSET
(
txn
-
>
mt_flags
MDB_TXN_RDONLY
|
MDB_TXN_FINISHED
)
)
return
EINVAL
;
rc
=
mdb_txn_renew0
(
txn
)
;
if
(
rc
=
=
MDB_SUCCESS
)
{
DPRINTF
(
(
"
renew
txn
%
"
Z
"
u
%
c
%
p
on
mdbenv
%
p
root
page
%
"
Z
"
u
"
txn
-
>
mt_txnid
(
txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
'
r
'
:
'
w
'
(
void
*
)
txn
(
void
*
)
txn
-
>
mt_env
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_root
)
)
;
}
return
rc
;
}
int
mdb_txn_begin
(
MDB_env
*
env
MDB_txn
*
parent
unsigned
int
flags
MDB_txn
*
*
ret
)
{
MDB_txn
*
txn
;
MDB_ntxn
*
ntxn
;
int
rc
size
tsize
;
flags
&
=
MDB_TXN_BEGIN_FLAGS
;
flags
|
=
env
-
>
me_flags
&
MDB_WRITEMAP
;
if
(
env
-
>
me_flags
&
MDB_RDONLY
&
~
flags
)
return
EACCES
;
if
(
parent
)
{
flags
|
=
parent
-
>
mt_flags
;
if
(
flags
&
(
MDB_RDONLY
|
MDB_WRITEMAP
|
MDB_TXN_BLOCKED
)
)
{
return
(
parent
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
EINVAL
:
MDB_BAD_TXN
;
}
size
=
env
-
>
me_maxdbs
*
(
sizeof
(
MDB_db
)
+
sizeof
(
MDB_cursor
*
)
+
1
)
;
size
+
=
tsize
=
sizeof
(
MDB_ntxn
)
;
}
else
if
(
flags
&
MDB_RDONLY
)
{
size
=
env
-
>
me_maxdbs
*
(
sizeof
(
MDB_db
)
+
1
)
;
size
+
=
tsize
=
sizeof
(
MDB_txn
)
;
}
else
{
txn
=
env
-
>
me_txn0
;
goto
renew
;
}
if
(
(
txn
=
calloc
(
1
size
)
)
=
=
NULL
)
{
DPRINTF
(
(
"
calloc
:
%
s
"
strerror
(
errno
)
)
)
;
return
ENOMEM
;
}
txn
-
>
mt_dbxs
=
env
-
>
me_dbxs
;
txn
-
>
mt_dbs
=
(
MDB_db
*
)
(
(
char
*
)
txn
+
tsize
)
;
txn
-
>
mt_dbflags
=
(
unsigned
char
*
)
txn
+
size
-
env
-
>
me_maxdbs
;
txn
-
>
mt_flags
=
flags
;
txn
-
>
mt_env
=
env
;
if
(
parent
)
{
unsigned
int
i
;
txn
-
>
mt_cursors
=
(
MDB_cursor
*
*
)
(
txn
-
>
mt_dbs
+
env
-
>
me_maxdbs
)
;
txn
-
>
mt_dbiseqs
=
parent
-
>
mt_dbiseqs
;
txn
-
>
mt_u
.
dirty_list
=
malloc
(
sizeof
(
MDB_ID2
)
*
MDB_IDL_UM_SIZE
)
;
if
(
!
txn
-
>
mt_u
.
dirty_list
|
|
!
(
txn
-
>
mt_free_pgs
=
mdb_midl_alloc
(
MDB_IDL_UM_MAX
)
)
)
{
free
(
txn
-
>
mt_u
.
dirty_list
)
;
free
(
txn
)
;
return
ENOMEM
;
}
txn
-
>
mt_txnid
=
parent
-
>
mt_txnid
;
txn
-
>
mt_dirty_room
=
parent
-
>
mt_dirty_room
;
txn
-
>
mt_u
.
dirty_list
[
0
]
.
mid
=
0
;
txn
-
>
mt_spill_pgs
=
NULL
;
txn
-
>
mt_next_pgno
=
parent
-
>
mt_next_pgno
;
parent
-
>
mt_flags
|
=
MDB_TXN_HAS_CHILD
;
parent
-
>
mt_child
=
txn
;
txn
-
>
mt_parent
=
parent
;
txn
-
>
mt_numdbs
=
parent
-
>
mt_numdbs
;
memcpy
(
txn
-
>
mt_dbs
parent
-
>
mt_dbs
txn
-
>
mt_numdbs
*
sizeof
(
MDB_db
)
)
;
for
(
i
=
0
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
txn
-
>
mt_dbflags
[
i
]
=
parent
-
>
mt_dbflags
[
i
]
&
~
DB_NEW
;
rc
=
0
;
ntxn
=
(
MDB_ntxn
*
)
txn
;
ntxn
-
>
mnt_pgstate
=
env
-
>
me_pgstate
;
if
(
env
-
>
me_pghead
)
{
size
=
MDB_IDL_SIZEOF
(
env
-
>
me_pghead
)
;
env
-
>
me_pghead
=
mdb_midl_alloc
(
env
-
>
me_pghead
[
0
]
)
;
if
(
env
-
>
me_pghead
)
memcpy
(
env
-
>
me_pghead
ntxn
-
>
mnt_pgstate
.
mf_pghead
size
)
;
else
rc
=
ENOMEM
;
}
if
(
!
rc
)
rc
=
mdb_cursor_shadow
(
parent
txn
)
;
if
(
rc
)
mdb_txn_end
(
txn
MDB_END_FAIL_BEGINCHILD
)
;
}
else
{
txn
-
>
mt_dbiseqs
=
env
-
>
me_dbiseqs
;
renew
:
rc
=
mdb_txn_renew0
(
txn
)
;
}
if
(
rc
)
{
if
(
txn
!
=
env
-
>
me_txn0
)
free
(
txn
)
;
}
else
{
txn
-
>
mt_flags
|
=
flags
;
*
ret
=
txn
;
DPRINTF
(
(
"
begin
txn
%
"
Z
"
u
%
c
%
p
on
mdbenv
%
p
root
page
%
"
Z
"
u
"
txn
-
>
mt_txnid
(
flags
&
MDB_RDONLY
)
?
'
r
'
:
'
w
'
(
void
*
)
txn
(
void
*
)
env
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_root
)
)
;
}
return
rc
;
}
MDB_env
*
mdb_txn_env
(
MDB_txn
*
txn
)
{
if
(
!
txn
)
return
NULL
;
return
txn
-
>
mt_env
;
}
size_t
mdb_txn_id
(
MDB_txn
*
txn
)
{
if
(
!
txn
)
return
0
;
return
txn
-
>
mt_txnid
;
}
static
void
mdb_dbis_update
(
MDB_txn
*
txn
int
keep
)
{
int
i
;
MDB_dbi
n
=
txn
-
>
mt_numdbs
;
MDB_env
*
env
=
txn
-
>
mt_env
;
unsigned
char
*
tdbflags
=
txn
-
>
mt_dbflags
;
for
(
i
=
n
;
-
-
i
>
=
CORE_DBS
;
)
{
if
(
tdbflags
[
i
]
&
DB_NEW
)
{
if
(
keep
)
{
env
-
>
me_dbflags
[
i
]
=
txn
-
>
mt_dbs
[
i
]
.
md_flags
|
MDB_VALID
;
}
else
{
char
*
ptr
=
env
-
>
me_dbxs
[
i
]
.
md_name
.
mv_data
;
if
(
ptr
)
{
env
-
>
me_dbxs
[
i
]
.
md_name
.
mv_data
=
NULL
;
env
-
>
me_dbxs
[
i
]
.
md_name
.
mv_size
=
0
;
env
-
>
me_dbflags
[
i
]
=
0
;
env
-
>
me_dbiseqs
[
i
]
+
+
;
free
(
ptr
)
;
}
}
}
}
if
(
keep
&
&
env
-
>
me_numdbs
<
n
)
env
-
>
me_numdbs
=
n
;
}
static
void
mdb_txn_end
(
MDB_txn
*
txn
unsigned
mode
)
{
MDB_env
*
env
=
txn
-
>
mt_env
;
#
if
MDB_DEBUG
static
const
char
*
const
names
[
]
=
MDB_END_NAMES
;
#
endif
mdb_dbis_update
(
txn
mode
&
MDB_END_UPDATE
)
;
DPRINTF
(
(
"
%
s
txn
%
"
Z
"
u
%
c
%
p
on
mdbenv
%
p
root
page
%
"
Z
"
u
"
names
[
mode
&
MDB_END_OPMASK
]
txn
-
>
mt_txnid
(
txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
'
r
'
:
'
w
'
(
void
*
)
txn
(
void
*
)
env
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_root
)
)
;
if
(
F_ISSET
(
txn
-
>
mt_flags
MDB_TXN_RDONLY
)
)
{
if
(
txn
-
>
mt_u
.
reader
)
{
txn
-
>
mt_u
.
reader
-
>
mr_txnid
=
(
txnid_t
)
-
1
;
if
(
!
(
env
-
>
me_flags
&
MDB_NOTLS
)
)
{
txn
-
>
mt_u
.
reader
=
NULL
;
}
else
if
(
mode
&
MDB_END_SLOT
)
{
txn
-
>
mt_u
.
reader
-
>
mr_pid
=
0
;
txn
-
>
mt_u
.
reader
=
NULL
;
}
}
txn
-
>
mt_numdbs
=
0
;
txn
-
>
mt_flags
|
=
MDB_TXN_FINISHED
;
}
else
if
(
!
F_ISSET
(
txn
-
>
mt_flags
MDB_TXN_FINISHED
)
)
{
pgno_t
*
pghead
=
env
-
>
me_pghead
;
if
(
!
(
mode
&
MDB_END_UPDATE
)
)
mdb_cursors_close
(
txn
0
)
;
if
(
!
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
)
{
mdb_dlist_free
(
txn
)
;
}
txn
-
>
mt_numdbs
=
0
;
txn
-
>
mt_flags
=
MDB_TXN_FINISHED
;
if
(
!
txn
-
>
mt_parent
)
{
mdb_midl_shrink
(
&
txn
-
>
mt_free_pgs
)
;
env
-
>
me_free_pgs
=
txn
-
>
mt_free_pgs
;
env
-
>
me_pghead
=
NULL
;
env
-
>
me_pglast
=
0
;
env
-
>
me_txn
=
NULL
;
mode
=
0
;
if
(
env
-
>
me_txns
)
UNLOCK_MUTEX
(
env
-
>
me_wmutex
)
;
}
else
{
txn
-
>
mt_parent
-
>
mt_child
=
NULL
;
txn
-
>
mt_parent
-
>
mt_flags
&
=
~
MDB_TXN_HAS_CHILD
;
env
-
>
me_pgstate
=
(
(
MDB_ntxn
*
)
txn
)
-
>
mnt_pgstate
;
mdb_midl_free
(
txn
-
>
mt_free_pgs
)
;
mdb_midl_free
(
txn
-
>
mt_spill_pgs
)
;
free
(
txn
-
>
mt_u
.
dirty_list
)
;
}
mdb_midl_free
(
pghead
)
;
}
if
(
mode
&
MDB_END_FREE
)
free
(
txn
)
;
}
void
mdb_txn_reset
(
MDB_txn
*
txn
)
{
if
(
txn
=
=
NULL
)
return
;
if
(
!
(
txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
)
return
;
mdb_txn_end
(
txn
MDB_END_RESET
)
;
}
void
mdb_txn_abort
(
MDB_txn
*
txn
)
{
if
(
txn
=
=
NULL
)
return
;
if
(
txn
-
>
mt_child
)
mdb_txn_abort
(
txn
-
>
mt_child
)
;
mdb_txn_end
(
txn
MDB_END_ABORT
|
MDB_END_SLOT
|
MDB_END_FREE
)
;
}
static
int
mdb_freelist_save
(
MDB_txn
*
txn
)
{
MDB_cursor
mc
;
MDB_env
*
env
=
txn
-
>
mt_env
;
int
rc
maxfree_1pg
=
env
-
>
me_maxfree_1pg
more
=
1
;
txnid_t
pglast
=
0
head_id
=
0
;
pgno_t
freecnt
=
0
*
free_pgs
*
mop
;
ssize_t
head_room
=
0
total_room
=
0
mop_len
clean_limit
;
mdb_cursor_init
(
&
mc
txn
FREE_DBI
NULL
)
;
if
(
env
-
>
me_pghead
)
{
rc
=
mdb_page_search
(
&
mc
NULL
MDB_PS_FIRST
|
MDB_PS_MODIFY
)
;
if
(
rc
&
&
rc
!
=
MDB_NOTFOUND
)
return
rc
;
}
if
(
!
env
-
>
me_pghead
&
&
txn
-
>
mt_loose_pgs
)
{
MDB_page
*
mp
=
txn
-
>
mt_loose_pgs
;
if
(
(
rc
=
mdb_midl_need
(
&
txn
-
>
mt_free_pgs
txn
-
>
mt_loose_count
)
)
!
=
0
)
return
rc
;
for
(
;
mp
;
mp
=
NEXT_LOOSE_PAGE
(
mp
)
)
mdb_midl_xappend
(
txn
-
>
mt_free_pgs
mp
-
>
mp_pgno
)
;
txn
-
>
mt_loose_pgs
=
NULL
;
txn
-
>
mt_loose_count
=
0
;
}
clean_limit
=
(
env
-
>
me_flags
&
(
MDB_NOMEMINIT
|
MDB_WRITEMAP
)
)
?
SSIZE_MAX
:
maxfree_1pg
;
for
(
;
;
)
{
MDB_val
key
data
;
pgno_t
*
pgs
;
ssize_t
j
;
while
(
pglast
<
env
-
>
me_pglast
)
{
rc
=
mdb_cursor_first
(
&
mc
&
key
NULL
)
;
if
(
rc
)
return
rc
;
pglast
=
head_id
=
*
(
txnid_t
*
)
key
.
mv_data
;
total_room
=
head_room
=
0
;
mdb_tassert
(
txn
pglast
<
=
env
-
>
me_pglast
)
;
rc
=
mdb_cursor_del
(
&
mc
0
)
;
if
(
rc
)
return
rc
;
}
if
(
freecnt
<
txn
-
>
mt_free_pgs
[
0
]
)
{
if
(
!
freecnt
)
{
rc
=
mdb_page_search
(
&
mc
NULL
MDB_PS_LAST
|
MDB_PS_MODIFY
)
;
if
(
rc
&
&
rc
!
=
MDB_NOTFOUND
)
return
rc
;
}
free_pgs
=
txn
-
>
mt_free_pgs
;
key
.
mv_size
=
sizeof
(
txn
-
>
mt_txnid
)
;
key
.
mv_data
=
&
txn
-
>
mt_txnid
;
do
{
freecnt
=
free_pgs
[
0
]
;
data
.
mv_size
=
MDB_IDL_SIZEOF
(
free_pgs
)
;
rc
=
mdb_cursor_put
(
&
mc
&
key
&
data
MDB_RESERVE
)
;
if
(
rc
)
return
rc
;
free_pgs
=
txn
-
>
mt_free_pgs
;
}
while
(
freecnt
<
free_pgs
[
0
]
)
;
mdb_midl_sort
(
free_pgs
)
;
memcpy
(
data
.
mv_data
free_pgs
data
.
mv_size
)
;
#
if
(
MDB_DEBUG
)
>
1
{
unsigned
int
i
=
free_pgs
[
0
]
;
DPRINTF
(
(
"
IDL
write
txn
%
"
Z
"
u
root
%
"
Z
"
u
num
%
u
"
txn
-
>
mt_txnid
txn
-
>
mt_dbs
[
FREE_DBI
]
.
md_root
i
)
)
;
for
(
;
i
;
i
-
-
)
DPRINTF
(
(
"
IDL
%
"
Z
"
u
"
free_pgs
[
i
]
)
)
;
}
#
endif
continue
;
}
mop
=
env
-
>
me_pghead
;
mop_len
=
(
mop
?
mop
[
0
]
:
0
)
+
txn
-
>
mt_loose_count
;
if
(
total_room
>
=
mop_len
)
{
if
(
total_room
=
=
mop_len
|
|
-
-
more
<
0
)
break
;
}
else
if
(
head_room
>
=
maxfree_1pg
&
&
head_id
>
1
)
{
head_id
-
-
;
head_room
=
0
;
}
total_room
-
=
head_room
;
head_room
=
mop_len
-
total_room
;
if
(
head_room
>
maxfree_1pg
&
&
head_id
>
1
)
{
head_room
/
=
head_id
;
head_room
+
=
maxfree_1pg
-
head_room
%
(
maxfree_1pg
+
1
)
;
}
else
if
(
head_room
<
0
)
{
head_room
=
0
;
}
key
.
mv_size
=
sizeof
(
head_id
)
;
key
.
mv_data
=
&
head_id
;
data
.
mv_size
=
(
head_room
+
1
)
*
sizeof
(
pgno_t
)
;
rc
=
mdb_cursor_put
(
&
mc
&
key
&
data
MDB_RESERVE
)
;
if
(
rc
)
return
rc
;
pgs
=
(
pgno_t
*
)
data
.
mv_data
;
j
=
head_room
>
clean_limit
?
head_room
:
0
;
do
{
pgs
[
j
]
=
0
;
}
while
(
-
-
j
>
=
0
)
;
total_room
+
=
head_room
;
}
if
(
txn
-
>
mt_loose_pgs
)
{
MDB_page
*
mp
=
txn
-
>
mt_loose_pgs
;
unsigned
count
=
txn
-
>
mt_loose_count
;
MDB_IDL
loose
;
if
(
(
rc
=
mdb_midl_need
(
&
env
-
>
me_pghead
2
*
count
+
1
)
)
!
=
0
)
return
rc
;
mop
=
env
-
>
me_pghead
;
loose
=
mop
+
MDB_IDL_ALLOCLEN
(
mop
)
-
count
;
for
(
count
=
0
;
mp
;
mp
=
NEXT_LOOSE_PAGE
(
mp
)
)
loose
[
+
+
count
]
=
mp
-
>
mp_pgno
;
loose
[
0
]
=
count
;
mdb_midl_sort
(
loose
)
;
mdb_midl_xmerge
(
mop
loose
)
;
txn
-
>
mt_loose_pgs
=
NULL
;
txn
-
>
mt_loose_count
=
0
;
mop_len
=
mop
[
0
]
;
}
rc
=
MDB_SUCCESS
;
if
(
mop_len
)
{
MDB_val
key
data
;
mop
+
=
mop_len
;
rc
=
mdb_cursor_first
(
&
mc
&
key
&
data
)
;
for
(
;
!
rc
;
rc
=
mdb_cursor_next
(
&
mc
&
key
&
data
MDB_NEXT
)
)
{
txnid_t
id
=
*
(
txnid_t
*
)
key
.
mv_data
;
ssize_t
len
=
(
ssize_t
)
(
data
.
mv_size
/
sizeof
(
MDB_ID
)
)
-
1
;
MDB_ID
save
;
mdb_tassert
(
txn
len
>
=
0
&
&
id
<
=
env
-
>
me_pglast
)
;
key
.
mv_data
=
&
id
;
if
(
len
>
mop_len
)
{
len
=
mop_len
;
data
.
mv_size
=
(
len
+
1
)
*
sizeof
(
MDB_ID
)
;
}
data
.
mv_data
=
mop
-
=
len
;
save
=
mop
[
0
]
;
mop
[
0
]
=
len
;
rc
=
mdb_cursor_put
(
&
mc
&
key
&
data
MDB_CURRENT
)
;
mop
[
0
]
=
save
;
if
(
rc
|
|
!
(
mop_len
-
=
len
)
)
break
;
}
}
return
rc
;
}
static
int
mdb_page_flush
(
MDB_txn
*
txn
int
keep
)
{
MDB_env
*
env
=
txn
-
>
mt_env
;
MDB_ID2L
dl
=
txn
-
>
mt_u
.
dirty_list
;
unsigned
psize
=
env
-
>
me_psize
j
;
int
i
pagecount
=
dl
[
0
]
.
mid
rc
;
size_t
size
=
0
pos
=
0
;
pgno_t
pgno
=
0
;
MDB_page
*
dp
=
NULL
;
#
ifdef
_WIN32
OVERLAPPED
ov
;
#
else
struct
iovec
iov
[
MDB_COMMIT_PAGES
]
;
ssize_t
wpos
=
0
wsize
=
0
wres
;
size_t
next_pos
=
1
;
int
n
=
0
;
#
endif
j
=
i
=
keep
;
if
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
{
while
(
+
+
i
<
=
pagecount
)
{
dp
=
dl
[
i
]
.
mptr
;
if
(
dp
-
>
mp_flags
&
(
P_LOOSE
|
P_KEEP
)
)
{
dp
-
>
mp_flags
&
=
~
P_KEEP
;
dl
[
+
+
j
]
=
dl
[
i
]
;
continue
;
}
dp
-
>
mp_flags
&
=
~
P_DIRTY
;
}
goto
done
;
}
for
(
;
;
)
{
if
(
+
+
i
<
=
pagecount
)
{
dp
=
dl
[
i
]
.
mptr
;
if
(
dp
-
>
mp_flags
&
(
P_LOOSE
|
P_KEEP
)
)
{
dp
-
>
mp_flags
&
=
~
P_KEEP
;
dl
[
i
]
.
mid
=
0
;
continue
;
}
pgno
=
dl
[
i
]
.
mid
;
dp
-
>
mp_flags
&
=
~
P_DIRTY
;
pos
=
pgno
*
psize
;
size
=
psize
;
if
(
IS_OVERFLOW
(
dp
)
)
size
*
=
dp
-
>
mp_pages
;
}
#
ifdef
_WIN32
else
break
;
DPRINTF
(
(
"
committing
page
%
"
Z
"
u
"
pgno
)
)
;
memset
(
&
ov
0
sizeof
(
ov
)
)
;
ov
.
Offset
=
pos
&
0xffffffff
;
ov
.
OffsetHigh
=
pos
>
>
16
>
>
16
;
if
(
!
WriteFile
(
env
-
>
me_fd
dp
size
NULL
&
ov
)
)
{
rc
=
ErrCode
(
)
;
DPRINTF
(
(
"
WriteFile
:
%
d
"
rc
)
)
;
return
rc
;
}
#
else
if
(
pos
!
=
next_pos
|
|
n
=
=
MDB_COMMIT_PAGES
|
|
wsize
+
size
>
MAX_WRITE
)
{
if
(
n
)
{
retry_write
:
#
ifdef
MDB_USE_PWRITEV
wres
=
pwritev
(
env
-
>
me_fd
iov
n
wpos
)
;
#
else
if
(
n
=
=
1
)
{
wres
=
pwrite
(
env
-
>
me_fd
iov
[
0
]
.
iov_base
wsize
wpos
)
;
}
else
{
retry_seek
:
if
(
lseek
(
env
-
>
me_fd
wpos
SEEK_SET
)
=
=
-
1
)
{
rc
=
ErrCode
(
)
;
if
(
rc
=
=
EINTR
)
goto
retry_seek
;
DPRINTF
(
(
"
lseek
:
%
s
"
strerror
(
rc
)
)
)
;
return
rc
;
}
wres
=
writev
(
env
-
>
me_fd
iov
n
)
;
}
#
endif
if
(
wres
!
=
wsize
)
{
if
(
wres
<
0
)
{
rc
=
ErrCode
(
)
;
if
(
rc
=
=
EINTR
)
goto
retry_write
;
DPRINTF
(
(
"
Write
error
:
%
s
"
strerror
(
rc
)
)
)
;
}
else
{
rc
=
EIO
;
DPUTS
(
"
short
write
filesystem
full
?
"
)
;
}
return
rc
;
}
n
=
0
;
}
if
(
i
>
pagecount
)
break
;
wpos
=
pos
;
wsize
=
0
;
}
DPRINTF
(
(
"
committing
page
%
"
Z
"
u
"
pgno
)
)
;
next_pos
=
pos
+
size
;
iov
[
n
]
.
iov_len
=
size
;
iov
[
n
]
.
iov_base
=
(
char
*
)
dp
;
wsize
+
=
size
;
n
+
+
;
#
endif
}
CACHEFLUSH
(
env
-
>
me_map
txn
-
>
mt_next_pgno
*
env
-
>
me_psize
DCACHE
)
;
for
(
i
=
keep
;
+
+
i
<
=
pagecount
;
)
{
dp
=
dl
[
i
]
.
mptr
;
if
(
!
dl
[
i
]
.
mid
)
{
dl
[
+
+
j
]
=
dl
[
i
]
;
dl
[
j
]
.
mid
=
dp
-
>
mp_pgno
;
continue
;
}
mdb_dpage_free
(
env
dp
)
;
}
done
:
i
-
-
;
txn
-
>
mt_dirty_room
+
=
i
-
j
;
dl
[
0
]
.
mid
=
j
;
return
MDB_SUCCESS
;
}
int
mdb_txn_commit
(
MDB_txn
*
txn
)
{
int
rc
;
unsigned
int
i
end_mode
;
MDB_env
*
env
;
if
(
txn
=
=
NULL
)
return
EINVAL
;
end_mode
=
MDB_END_EMPTY_COMMIT
|
MDB_END_UPDATE
|
MDB_END_SLOT
|
MDB_END_FREE
;
if
(
txn
-
>
mt_child
)
{
rc
=
mdb_txn_commit
(
txn
-
>
mt_child
)
;
if
(
rc
)
goto
fail
;
}
env
=
txn
-
>
mt_env
;
if
(
F_ISSET
(
txn
-
>
mt_flags
MDB_TXN_RDONLY
)
)
{
goto
done
;
}
if
(
txn
-
>
mt_flags
&
(
MDB_TXN_FINISHED
|
MDB_TXN_ERROR
)
)
{
DPUTS
(
"
txn
has
failed
/
finished
can
'
t
commit
"
)
;
if
(
txn
-
>
mt_parent
)
txn
-
>
mt_parent
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
rc
=
MDB_BAD_TXN
;
goto
fail
;
}
if
(
txn
-
>
mt_parent
)
{
MDB_txn
*
parent
=
txn
-
>
mt_parent
;
MDB_page
*
*
lp
;
MDB_ID2L
dst
src
;
MDB_IDL
pspill
;
unsigned
x
y
len
ps_len
;
rc
=
mdb_midl_append_list
(
&
parent
-
>
mt_free_pgs
txn
-
>
mt_free_pgs
)
;
if
(
rc
)
goto
fail
;
mdb_midl_free
(
txn
-
>
mt_free_pgs
)
;
parent
-
>
mt_next_pgno
=
txn
-
>
mt_next_pgno
;
parent
-
>
mt_flags
=
txn
-
>
mt_flags
;
mdb_cursors_close
(
txn
1
)
;
memcpy
(
parent
-
>
mt_dbs
txn
-
>
mt_dbs
txn
-
>
mt_numdbs
*
sizeof
(
MDB_db
)
)
;
parent
-
>
mt_numdbs
=
txn
-
>
mt_numdbs
;
parent
-
>
mt_dbflags
[
FREE_DBI
]
=
txn
-
>
mt_dbflags
[
FREE_DBI
]
;
parent
-
>
mt_dbflags
[
MAIN_DBI
]
=
txn
-
>
mt_dbflags
[
MAIN_DBI
]
;
for
(
i
=
CORE_DBS
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
{
x
=
parent
-
>
mt_dbflags
[
i
]
&
DB_NEW
;
parent
-
>
mt_dbflags
[
i
]
=
txn
-
>
mt_dbflags
[
i
]
|
x
;
}
dst
=
parent
-
>
mt_u
.
dirty_list
;
src
=
txn
-
>
mt_u
.
dirty_list
;
if
(
(
pspill
=
parent
-
>
mt_spill_pgs
)
&
&
(
ps_len
=
pspill
[
0
]
)
)
{
x
=
y
=
ps_len
;
pspill
[
0
]
=
(
pgno_t
)
-
1
;
for
(
i
=
0
len
=
src
[
0
]
.
mid
;
+
+
i
<
=
len
;
)
{
MDB_ID
pn
=
src
[
i
]
.
mid
<
<
1
;
while
(
pn
>
pspill
[
x
]
)
x
-
-
;
if
(
pn
=
=
pspill
[
x
]
)
{
pspill
[
x
]
=
1
;
y
=
-
-
x
;
}
}
for
(
x
=
y
;
+
+
x
<
=
ps_len
;
)
if
(
!
(
pspill
[
x
]
&
1
)
)
pspill
[
+
+
y
]
=
pspill
[
x
]
;
pspill
[
0
]
=
y
;
}
if
(
txn
-
>
mt_spill_pgs
&
&
txn
-
>
mt_spill_pgs
[
0
]
)
{
for
(
i
=
1
;
i
<
=
txn
-
>
mt_spill_pgs
[
0
]
;
i
+
+
)
{
MDB_ID
pn
=
txn
-
>
mt_spill_pgs
[
i
]
;
if
(
pn
&
1
)
continue
;
pn
>
>
=
1
;
y
=
mdb_mid2l_search
(
dst
pn
)
;
if
(
y
<
=
dst
[
0
]
.
mid
&
&
dst
[
y
]
.
mid
=
=
pn
)
{
free
(
dst
[
y
]
.
mptr
)
;
while
(
y
<
dst
[
0
]
.
mid
)
{
dst
[
y
]
=
dst
[
y
+
1
]
;
y
+
+
;
}
dst
[
0
]
.
mid
-
-
;
}
}
}
x
=
dst
[
0
]
.
mid
;
dst
[
0
]
.
mid
=
0
;
if
(
parent
-
>
mt_parent
)
{
len
=
x
+
src
[
0
]
.
mid
;
y
=
mdb_mid2l_search
(
src
dst
[
x
]
.
mid
+
1
)
-
1
;
for
(
i
=
x
;
y
&
&
i
;
y
-
-
)
{
pgno_t
yp
=
src
[
y
]
.
mid
;
while
(
yp
<
dst
[
i
]
.
mid
)
i
-
-
;
if
(
yp
=
=
dst
[
i
]
.
mid
)
{
i
-
-
;
len
-
-
;
}
}
}
else
{
len
=
MDB_IDL_UM_MAX
-
txn
-
>
mt_dirty_room
;
}
y
=
src
[
0
]
.
mid
;
for
(
i
=
len
;
y
;
dst
[
i
-
-
]
=
src
[
y
-
-
]
)
{
pgno_t
yp
=
src
[
y
]
.
mid
;
while
(
yp
<
dst
[
x
]
.
mid
)
dst
[
i
-
-
]
=
dst
[
x
-
-
]
;
if
(
yp
=
=
dst
[
x
]
.
mid
)
free
(
dst
[
x
-
-
]
.
mptr
)
;
}
mdb_tassert
(
txn
i
=
=
x
)
;
dst
[
0
]
.
mid
=
len
;
free
(
txn
-
>
mt_u
.
dirty_list
)
;
parent
-
>
mt_dirty_room
=
txn
-
>
mt_dirty_room
;
if
(
txn
-
>
mt_spill_pgs
)
{
if
(
parent
-
>
mt_spill_pgs
)
{
rc
=
mdb_midl_append_list
(
&
parent
-
>
mt_spill_pgs
txn
-
>
mt_spill_pgs
)
;
if
(
rc
)
parent
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
mdb_midl_free
(
txn
-
>
mt_spill_pgs
)
;
mdb_midl_sort
(
parent
-
>
mt_spill_pgs
)
;
}
else
{
parent
-
>
mt_spill_pgs
=
txn
-
>
mt_spill_pgs
;
}
}
for
(
lp
=
&
parent
-
>
mt_loose_pgs
;
*
lp
;
lp
=
&
NEXT_LOOSE_PAGE
(
*
lp
)
)
;
*
lp
=
txn
-
>
mt_loose_pgs
;
parent
-
>
mt_loose_count
+
=
txn
-
>
mt_loose_count
;
parent
-
>
mt_child
=
NULL
;
mdb_midl_free
(
(
(
MDB_ntxn
*
)
txn
)
-
>
mnt_pgstate
.
mf_pghead
)
;
free
(
txn
)
;
return
rc
;
}
if
(
txn
!
=
env
-
>
me_txn
)
{
DPUTS
(
"
attempt
to
commit
unknown
transaction
"
)
;
rc
=
EINVAL
;
goto
fail
;
}
mdb_cursors_close
(
txn
0
)
;
if
(
!
txn
-
>
mt_u
.
dirty_list
[
0
]
.
mid
&
&
!
(
txn
-
>
mt_flags
&
(
MDB_TXN_DIRTY
|
MDB_TXN_SPILLS
)
)
)
goto
done
;
DPRINTF
(
(
"
committing
txn
%
"
Z
"
u
%
p
on
mdbenv
%
p
root
page
%
"
Z
"
u
"
txn
-
>
mt_txnid
(
void
*
)
txn
(
void
*
)
env
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_root
)
)
;
if
(
txn
-
>
mt_numdbs
>
CORE_DBS
)
{
MDB_cursor
mc
;
MDB_dbi
i
;
MDB_val
data
;
data
.
mv_size
=
sizeof
(
MDB_db
)
;
mdb_cursor_init
(
&
mc
txn
MAIN_DBI
NULL
)
;
for
(
i
=
CORE_DBS
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
{
if
(
txn
-
>
mt_dbflags
[
i
]
&
DB_DIRTY
)
{
if
(
TXN_DBI_CHANGED
(
txn
i
)
)
{
rc
=
MDB_BAD_DBI
;
goto
fail
;
}
data
.
mv_data
=
&
txn
-
>
mt_dbs
[
i
]
;
rc
=
mdb_cursor_put
(
&
mc
&
txn
-
>
mt_dbxs
[
i
]
.
md_name
&
data
F_SUBDATA
)
;
if
(
rc
)
goto
fail
;
}
}
}
rc
=
mdb_freelist_save
(
txn
)
;
if
(
rc
)
goto
fail
;
mdb_midl_free
(
env
-
>
me_pghead
)
;
env
-
>
me_pghead
=
NULL
;
mdb_midl_shrink
(
&
txn
-
>
mt_free_pgs
)
;
#
if
(
MDB_DEBUG
)
>
2
mdb_audit
(
txn
)
;
#
endif
if
(
(
rc
=
mdb_page_flush
(
txn
0
)
)
|
|
(
rc
=
mdb_env_sync
(
env
0
)
)
|
|
(
rc
=
mdb_env_write_meta
(
txn
)
)
)
goto
fail
;
end_mode
=
MDB_END_COMMITTED
|
MDB_END_UPDATE
;
done
:
mdb_txn_end
(
txn
end_mode
)
;
return
MDB_SUCCESS
;
fail
:
mdb_txn_abort
(
txn
)
;
return
rc
;
}
static
int
ESECT
mdb_env_read_header
(
MDB_env
*
env
MDB_meta
*
meta
)
{
MDB_metabuf
pbuf
;
MDB_page
*
p
;
MDB_meta
*
m
;
int
i
rc
off
;
enum
{
Size
=
sizeof
(
pbuf
)
}
;
for
(
i
=
off
=
0
;
i
<
NUM_METAS
;
i
+
+
off
+
=
meta
-
>
mm_psize
)
{
#
ifdef
_WIN32
DWORD
len
;
OVERLAPPED
ov
;
memset
(
&
ov
0
sizeof
(
ov
)
)
;
ov
.
Offset
=
off
;
rc
=
ReadFile
(
env
-
>
me_fd
&
pbuf
Size
&
len
&
ov
)
?
(
int
)
len
:
-
1
;
if
(
rc
=
=
-
1
&
&
ErrCode
(
)
=
=
ERROR_HANDLE_EOF
)
rc
=
0
;
#
else
rc
=
pread
(
env
-
>
me_fd
&
pbuf
Size
off
)
;
#
endif
if
(
rc
!
=
Size
)
{
if
(
rc
=
=
0
&
&
off
=
=
0
)
return
ENOENT
;
rc
=
rc
<
0
?
(
int
)
ErrCode
(
)
:
MDB_INVALID
;
DPRINTF
(
(
"
read
:
%
s
"
mdb_strerror
(
rc
)
)
)
;
return
rc
;
}
p
=
(
MDB_page
*
)
&
pbuf
;
if
(
!
F_ISSET
(
p
-
>
mp_flags
P_META
)
)
{
DPRINTF
(
(
"
page
%
"
Z
"
u
not
a
meta
page
"
p
-
>
mp_pgno
)
)
;
return
MDB_INVALID
;
}
m
=
METADATA
(
p
)
;
if
(
m
-
>
mm_magic
!
=
MDB_MAGIC
)
{
DPUTS
(
"
meta
has
invalid
magic
"
)
;
return
MDB_INVALID
;
}
if
(
m
-
>
mm_version
!
=
MDB_DATA_VERSION
)
{
DPRINTF
(
(
"
database
is
version
%
u
expected
version
%
u
"
m
-
>
mm_version
MDB_DATA_VERSION
)
)
;
return
MDB_VERSION_MISMATCH
;
}
if
(
off
=
=
0
|
|
m
-
>
mm_txnid
>
meta
-
>
mm_txnid
)
*
meta
=
*
m
;
}
return
0
;
}
static
void
ESECT
mdb_env_init_meta0
(
MDB_env
*
env
MDB_meta
*
meta
)
{
meta
-
>
mm_magic
=
MDB_MAGIC
;
meta
-
>
mm_version
=
MDB_DATA_VERSION
;
meta
-
>
mm_mapsize
=
env
-
>
me_mapsize
;
meta
-
>
mm_psize
=
env
-
>
me_psize
;
meta
-
>
mm_last_pg
=
NUM_METAS
-
1
;
meta
-
>
mm_flags
=
env
-
>
me_flags
&
0xffff
;
meta
-
>
mm_flags
|
=
MDB_INTEGERKEY
;
meta
-
>
mm_dbs
[
FREE_DBI
]
.
md_root
=
P_INVALID
;
meta
-
>
mm_dbs
[
MAIN_DBI
]
.
md_root
=
P_INVALID
;
}
static
int
ESECT
mdb_env_init_meta
(
MDB_env
*
env
MDB_meta
*
meta
)
{
MDB_page
*
p
*
q
;
int
rc
;
unsigned
int
psize
;
#
ifdef
_WIN32
DWORD
len
;
OVERLAPPED
ov
;
memset
(
&
ov
0
sizeof
(
ov
)
)
;
#
define
DO_PWRITE
(
rc
fd
ptr
size
len
pos
)
do
{
\
ov
.
Offset
=
pos
;
\
rc
=
WriteFile
(
fd
ptr
size
&
len
&
ov
)
;
}
while
(
0
)
#
else
int
len
;
#
define
DO_PWRITE
(
rc
fd
ptr
size
len
pos
)
do
{
\
len
=
pwrite
(
fd
ptr
size
pos
)
;
\
if
(
len
=
=
-
1
&
&
ErrCode
(
)
=
=
EINTR
)
continue
;
\
rc
=
(
len
>
=
0
)
;
break
;
}
while
(
1
)
#
endif
DPUTS
(
"
writing
new
meta
page
"
)
;
psize
=
env
-
>
me_psize
;
p
=
calloc
(
NUM_METAS
psize
)
;
if
(
!
p
)
return
ENOMEM
;
p
-
>
mp_pgno
=
0
;
p
-
>
mp_flags
=
P_META
;
*
(
MDB_meta
*
)
METADATA
(
p
)
=
*
meta
;
q
=
(
MDB_page
*
)
(
(
char
*
)
p
+
psize
)
;
q
-
>
mp_pgno
=
1
;
q
-
>
mp_flags
=
P_META
;
*
(
MDB_meta
*
)
METADATA
(
q
)
=
*
meta
;
DO_PWRITE
(
rc
env
-
>
me_fd
p
psize
*
NUM_METAS
len
0
)
;
if
(
!
rc
)
rc
=
ErrCode
(
)
;
else
if
(
(
unsigned
)
len
=
=
psize
*
NUM_METAS
)
rc
=
MDB_SUCCESS
;
else
rc
=
ENOSPC
;
free
(
p
)
;
return
rc
;
}
static
int
mdb_env_write_meta
(
MDB_txn
*
txn
)
{
MDB_env
*
env
;
MDB_meta
meta
metab
*
mp
;
unsigned
flags
;
size_t
mapsize
;
off_t
off
;
int
rc
len
toggle
;
char
*
ptr
;
HANDLE
mfd
;
#
ifdef
_WIN32
OVERLAPPED
ov
;
#
else
int
r2
;
#
endif
toggle
=
txn
-
>
mt_txnid
&
1
;
DPRINTF
(
(
"
writing
meta
page
%
d
for
root
page
%
"
Z
"
u
"
toggle
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_root
)
)
;
env
=
txn
-
>
mt_env
;
flags
=
env
-
>
me_flags
;
mp
=
env
-
>
me_metas
[
toggle
]
;
mapsize
=
env
-
>
me_metas
[
toggle
^
1
]
-
>
mm_mapsize
;
if
(
mapsize
<
env
-
>
me_mapsize
)
mapsize
=
env
-
>
me_mapsize
;
if
(
flags
&
MDB_WRITEMAP
)
{
mp
-
>
mm_mapsize
=
mapsize
;
mp
-
>
mm_dbs
[
FREE_DBI
]
=
txn
-
>
mt_dbs
[
FREE_DBI
]
;
mp
-
>
mm_dbs
[
MAIN_DBI
]
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
;
mp
-
>
mm_last_pg
=
txn
-
>
mt_next_pgno
-
1
;
#
if
(
__GNUC__
*
100
+
__GNUC_MINOR__
>
=
404
)
&
&
\
!
(
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
)
__sync_synchronize
(
)
;
#
endif
mp
-
>
mm_txnid
=
txn
-
>
mt_txnid
;
if
(
!
(
flags
&
(
MDB_NOMETASYNC
|
MDB_NOSYNC
)
)
)
{
unsigned
meta_size
=
env
-
>
me_psize
;
rc
=
(
env
-
>
me_flags
&
MDB_MAPASYNC
)
?
MS_ASYNC
:
MS_SYNC
;
ptr
=
(
char
*
)
mp
-
PAGEHDRSZ
;
#
ifndef
_WIN32
r2
=
(
ptr
-
env
-
>
me_map
)
&
(
env
-
>
me_os_psize
-
1
)
;
ptr
-
=
r2
;
meta_size
+
=
r2
;
#
endif
if
(
MDB_MSYNC
(
ptr
meta_size
rc
)
)
{
rc
=
ErrCode
(
)
;
goto
fail
;
}
}
goto
done
;
}
metab
.
mm_txnid
=
mp
-
>
mm_txnid
;
metab
.
mm_last_pg
=
mp
-
>
mm_last_pg
;
meta
.
mm_mapsize
=
mapsize
;
meta
.
mm_dbs
[
FREE_DBI
]
=
txn
-
>
mt_dbs
[
FREE_DBI
]
;
meta
.
mm_dbs
[
MAIN_DBI
]
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
;
meta
.
mm_last_pg
=
txn
-
>
mt_next_pgno
-
1
;
meta
.
mm_txnid
=
txn
-
>
mt_txnid
;
off
=
offsetof
(
MDB_meta
mm_mapsize
)
;
ptr
=
(
char
*
)
&
meta
+
off
;
len
=
sizeof
(
MDB_meta
)
-
off
;
off
+
=
(
char
*
)
mp
-
env
-
>
me_map
;
mfd
=
(
flags
&
(
MDB_NOSYNC
|
MDB_NOMETASYNC
)
)
?
env
-
>
me_fd
:
env
-
>
me_mfd
;
#
ifdef
_WIN32
{
memset
(
&
ov
0
sizeof
(
ov
)
)
;
ov
.
Offset
=
off
;
if
(
!
WriteFile
(
mfd
ptr
len
(
DWORD
*
)
&
rc
&
ov
)
)
rc
=
-
1
;
}
#
else
retry_write
:
rc
=
pwrite
(
mfd
ptr
len
off
)
;
#
endif
if
(
rc
!
=
len
)
{
rc
=
rc
<
0
?
ErrCode
(
)
:
EIO
;
#
ifndef
_WIN32
if
(
rc
=
=
EINTR
)
goto
retry_write
;
#
endif
DPUTS
(
"
write
failed
disk
error
?
"
)
;
meta
.
mm_last_pg
=
metab
.
mm_last_pg
;
meta
.
mm_txnid
=
metab
.
mm_txnid
;
#
ifdef
_WIN32
memset
(
&
ov
0
sizeof
(
ov
)
)
;
ov
.
Offset
=
off
;
WriteFile
(
env
-
>
me_fd
ptr
len
NULL
&
ov
)
;
#
else
r2
=
pwrite
(
env
-
>
me_fd
ptr
len
off
)
;
(
void
)
r2
;
#
endif
fail
:
env
-
>
me_flags
|
=
MDB_FATAL_ERROR
;
return
rc
;
}
CACHEFLUSH
(
env
-
>
me_map
+
off
len
DCACHE
)
;
done
:
if
(
env
-
>
me_txns
)
env
-
>
me_txns
-
>
mti_txnid
=
txn
-
>
mt_txnid
;
return
MDB_SUCCESS
;
}
static
MDB_meta
*
mdb_env_pick_meta
(
const
MDB_env
*
env
)
{
MDB_meta
*
const
*
metas
=
env
-
>
me_metas
;
return
metas
[
metas
[
0
]
-
>
mm_txnid
<
metas
[
1
]
-
>
mm_txnid
]
;
}
int
ESECT
mdb_env_create
(
MDB_env
*
*
env
)
{
MDB_env
*
e
;
e
=
calloc
(
1
sizeof
(
MDB_env
)
)
;
if
(
!
e
)
return
ENOMEM
;
e
-
>
me_maxreaders
=
DEFAULT_READERS
;
e
-
>
me_maxdbs
=
e
-
>
me_numdbs
=
CORE_DBS
;
e
-
>
me_fd
=
INVALID_HANDLE_VALUE
;
e
-
>
me_lfd
=
INVALID_HANDLE_VALUE
;
e
-
>
me_mfd
=
INVALID_HANDLE_VALUE
;
#
ifdef
MDB_USE_POSIX_SEM
e
-
>
me_rmutex
=
SEM_FAILED
;
e
-
>
me_wmutex
=
SEM_FAILED
;
#
endif
e
-
>
me_pid
=
getpid
(
)
;
GET_PAGESIZE
(
e
-
>
me_os_psize
)
;
VGMEMP_CREATE
(
e
0
0
)
;
*
env
=
e
;
return
MDB_SUCCESS
;
}
static
int
ESECT
mdb_env_map
(
MDB_env
*
env
void
*
addr
)
{
MDB_page
*
p
;
unsigned
int
flags
=
env
-
>
me_flags
;
#
ifdef
_WIN32
int
rc
;
HANDLE
mh
;
LONG
sizelo
sizehi
;
size_t
msize
;
if
(
flags
&
MDB_RDONLY
)
{
msize
=
0
;
sizelo
=
0
;
sizehi
=
0
;
}
else
{
msize
=
env
-
>
me_mapsize
;
sizelo
=
msize
&
0xffffffff
;
sizehi
=
msize
>
>
16
>
>
16
;
if
(
SetFilePointer
(
env
-
>
me_fd
sizelo
&
sizehi
0
)
!
=
(
DWORD
)
sizelo
|
|
!
SetEndOfFile
(
env
-
>
me_fd
)
|
|
SetFilePointer
(
env
-
>
me_fd
0
NULL
0
)
!
=
0
)
return
ErrCode
(
)
;
}
mh
=
CreateFileMapping
(
env
-
>
me_fd
NULL
flags
&
MDB_WRITEMAP
?
PAGE_READWRITE
:
PAGE_READONLY
sizehi
sizelo
NULL
)
;
if
(
!
mh
)
return
ErrCode
(
)
;
env
-
>
me_map
=
MapViewOfFileEx
(
mh
flags
&
MDB_WRITEMAP
?
FILE_MAP_WRITE
:
FILE_MAP_READ
0
0
msize
addr
)
;
rc
=
env
-
>
me_map
?
0
:
ErrCode
(
)
;
CloseHandle
(
mh
)
;
if
(
rc
)
return
rc
;
#
else
int
prot
=
PROT_READ
;
if
(
flags
&
MDB_WRITEMAP
)
{
prot
|
=
PROT_WRITE
;
if
(
ftruncate
(
env
-
>
me_fd
env
-
>
me_mapsize
)
<
0
)
return
ErrCode
(
)
;
}
env
-
>
me_map
=
mmap
(
addr
env
-
>
me_mapsize
prot
MAP_SHARED
env
-
>
me_fd
0
)
;
if
(
env
-
>
me_map
=
=
MAP_FAILED
)
{
env
-
>
me_map
=
NULL
;
return
ErrCode
(
)
;
}
if
(
flags
&
MDB_NORDAHEAD
)
{
#
ifdef
MADV_RANDOM
madvise
(
env
-
>
me_map
env
-
>
me_mapsize
MADV_RANDOM
)
;
#
else
#
ifdef
POSIX_MADV_RANDOM
posix_madvise
(
env
-
>
me_map
env
-
>
me_mapsize
POSIX_MADV_RANDOM
)
;
#
endif
#
endif
}
#
endif
if
(
addr
&
&
env
-
>
me_map
!
=
addr
)
return
EBUSY
;
p
=
(
MDB_page
*
)
env
-
>
me_map
;
env
-
>
me_metas
[
0
]
=
METADATA
(
p
)
;
env
-
>
me_metas
[
1
]
=
(
MDB_meta
*
)
(
(
char
*
)
env
-
>
me_metas
[
0
]
+
env
-
>
me_psize
)
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_set_mapsize
(
MDB_env
*
env
size_t
size
)
{
if
(
env
-
>
me_map
)
{
int
rc
;
MDB_meta
*
meta
;
void
*
old
;
if
(
env
-
>
me_txn
)
return
EINVAL
;
meta
=
mdb_env_pick_meta
(
env
)
;
if
(
!
size
)
size
=
meta
-
>
mm_mapsize
;
{
size_t
minsize
=
(
meta
-
>
mm_last_pg
+
1
)
*
env
-
>
me_psize
;
if
(
size
<
minsize
)
size
=
minsize
;
}
munmap
(
env
-
>
me_map
env
-
>
me_mapsize
)
;
env
-
>
me_mapsize
=
size
;
old
=
(
env
-
>
me_flags
&
MDB_FIXEDMAP
)
?
env
-
>
me_map
:
NULL
;
rc
=
mdb_env_map
(
env
old
)
;
if
(
rc
)
return
rc
;
}
env
-
>
me_mapsize
=
size
;
if
(
env
-
>
me_psize
)
env
-
>
me_maxpg
=
env
-
>
me_mapsize
/
env
-
>
me_psize
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_set_maxdbs
(
MDB_env
*
env
MDB_dbi
dbs
)
{
if
(
env
-
>
me_map
)
return
EINVAL
;
env
-
>
me_maxdbs
=
dbs
+
CORE_DBS
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_set_maxreaders
(
MDB_env
*
env
unsigned
int
readers
)
{
if
(
env
-
>
me_map
|
|
readers
<
1
)
return
EINVAL
;
env
-
>
me_maxreaders
=
readers
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_get_maxreaders
(
MDB_env
*
env
unsigned
int
*
readers
)
{
if
(
!
env
|
|
!
readers
)
return
EINVAL
;
*
readers
=
env
-
>
me_maxreaders
;
return
MDB_SUCCESS
;
}
static
int
ESECT
mdb_fsize
(
HANDLE
fd
size_t
*
size
)
{
#
ifdef
_WIN32
LARGE_INTEGER
fsize
;
if
(
!
GetFileSizeEx
(
fd
&
fsize
)
)
return
ErrCode
(
)
;
*
size
=
fsize
.
QuadPart
;
#
else
struct
stat
st
;
if
(
fstat
(
fd
&
st
)
)
return
ErrCode
(
)
;
*
size
=
st
.
st_size
;
#
endif
return
MDB_SUCCESS
;
}
#
ifdef
_WIN32
typedef
wchar_t
mdb_nchar_t
;
#
define
MDB_NAME
(
str
)
L
#
#
str
#
define
mdb_name_cpy
wcscpy
#
else
typedef
char
mdb_nchar_t
;
#
define
MDB_NAME
(
str
)
str
/
*
*
<
#
mdb_nchar_t
[
]
string
literal
*
/
#
define
mdb_name_cpy
strcpy
/
*
*
<
Copy
name
(
#
mdb_nchar_t
string
)
*
/
#
endif
typedef
struct
MDB_name
{
int
mn_len
;
int
mn_alloced
;
mdb_nchar_t
*
mn_val
;
}
MDB_name
;
static
const
mdb_nchar_t
*
const
mdb_suffixes
[
2
]
[
2
]
=
{
{
MDB_NAME
(
"
/
data
.
mdb
"
)
MDB_NAME
(
"
"
)
}
{
MDB_NAME
(
"
/
lock
.
mdb
"
)
MDB_NAME
(
"
-
lock
"
)
}
}
;
#
define
MDB_SUFFLEN
9
/
*
*
<
Max
string
length
in
#
mdb_suffixes
[
]
*
/
static
int
ESECT
mdb_fname_init
(
const
char
*
path
unsigned
envflags
MDB_name
*
fname
)
{
int
no_suffix
=
F_ISSET
(
envflags
MDB_NOSUBDIR
|
MDB_NOLOCK
)
;
fname
-
>
mn_alloced
=
0
;
#
ifdef
_WIN32
return
utf8_to_utf16
(
path
fname
no_suffix
?
0
:
MDB_SUFFLEN
)
;
#
else
fname
-
>
mn_len
=
strlen
(
path
)
;
if
(
no_suffix
)
fname
-
>
mn_val
=
(
char
*
)
path
;
else
if
(
(
fname
-
>
mn_val
=
malloc
(
fname
-
>
mn_len
+
MDB_SUFFLEN
+
1
)
)
!
=
NULL
)
{
fname
-
>
mn_alloced
=
1
;
strcpy
(
fname
-
>
mn_val
path
)
;
}
else
return
ENOMEM
;
return
MDB_SUCCESS
;
#
endif
}
#
define
mdb_fname_destroy
(
fname
)
\
do
{
if
(
(
fname
)
.
mn_alloced
)
free
(
(
fname
)
.
mn_val
)
;
}
while
(
0
)
#
ifdef
O_CLOEXEC
#
define
MDB_CLOEXEC
O_CLOEXEC
#
else
#
define
MDB_CLOEXEC
0
#
endif
enum
mdb_fopen_type
{
#
ifdef
_WIN32
MDB_O_RDONLY
MDB_O_RDWR
MDB_O_META
MDB_O_COPY
MDB_O_LOCKS
#
else
MDB_O_RDONLY
=
O_RDONLY
MDB_O_RDWR
=
O_RDWR
|
O_CREAT
MDB_O_META
=
O_WRONLY
|
MDB_DSYNC
|
MDB_CLOEXEC
MDB_O_COPY
=
O_WRONLY
|
O_CREAT
|
O_EXCL
|
MDB_CLOEXEC
MDB_O_MASK
=
MDB_O_RDWR
|
MDB_CLOEXEC
|
MDB_O_RDONLY
|
MDB_O_META
|
MDB_O_COPY
MDB_O_LOCKS
=
MDB_O_RDWR
|
MDB_CLOEXEC
|
(
(
MDB_O_MASK
+
1
)
&
~
MDB_O_MASK
)
#
endif
}
;
static
int
ESECT
mdb_fopen
(
const
MDB_env
*
env
MDB_name
*
fname
enum
mdb_fopen_type
which
mdb_mode_t
mode
HANDLE
*
res
)
{
int
rc
=
MDB_SUCCESS
;
HANDLE
fd
;
#
ifdef
_WIN32
DWORD
acc
share
disp
attrs
;
#
else
int
flags
;
#
endif
if
(
fname
-
>
mn_alloced
)
mdb_name_cpy
(
fname
-
>
mn_val
+
fname
-
>
mn_len
mdb_suffixes
[
which
=
=
MDB_O_LOCKS
]
[
F_ISSET
(
env
-
>
me_flags
MDB_NOSUBDIR
)
]
)
;
#
ifdef
_WIN32
acc
=
GENERIC_READ
|
GENERIC_WRITE
;
share
=
FILE_SHARE_READ
|
FILE_SHARE_WRITE
;
disp
=
OPEN_ALWAYS
;
attrs
=
FILE_ATTRIBUTE_NORMAL
;
switch
(
which
)
{
case
MDB_O_RDONLY
:
acc
=
GENERIC_READ
;
disp
=
OPEN_EXISTING
;
break
;
case
MDB_O_META
:
acc
=
GENERIC_WRITE
;
disp
=
OPEN_EXISTING
;
attrs
=
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_WRITE_THROUGH
;
break
;
case
MDB_O_COPY
:
acc
=
GENERIC_WRITE
;
share
=
0
;
disp
=
CREATE_NEW
;
attrs
=
FILE_FLAG_NO_BUFFERING
|
FILE_FLAG_WRITE_THROUGH
;
break
;
default
:
break
;
}
fd
=
CreateFileW
(
fname
-
>
mn_val
acc
share
NULL
disp
attrs
NULL
)
;
#
else
fd
=
open
(
fname
-
>
mn_val
which
&
MDB_O_MASK
mode
)
;
#
endif
if
(
fd
=
=
INVALID_HANDLE_VALUE
)
rc
=
ErrCode
(
)
;
#
ifndef
_WIN32
else
{
if
(
which
!
=
MDB_O_RDONLY
&
&
which
!
=
MDB_O_RDWR
)
{
if
(
!
MDB_CLOEXEC
&
&
(
flags
=
fcntl
(
fd
F_GETFD
)
)
!
=
-
1
)
(
void
)
fcntl
(
fd
F_SETFD
flags
|
FD_CLOEXEC
)
;
}
if
(
which
=
=
MDB_O_COPY
&
&
env
-
>
me_psize
>
=
env
-
>
me_os_psize
)
{
#
ifdef
F_NOCACHE
(
void
)
fcntl
(
fd
F_NOCACHE
1
)
;
#
elif
defined
O_DIRECT
if
(
(
flags
=
fcntl
(
fd
F_GETFL
)
)
!
=
-
1
)
(
void
)
fcntl
(
fd
F_SETFL
flags
|
O_DIRECT
)
;
#
endif
}
}
#
endif
*
res
=
fd
;
return
rc
;
}
#
ifdef
BROKEN_FDATASYNC
#
include
<
sys
/
utsname
.
h
>
#
include
<
sys
/
vfs
.
h
>
#
endif
static
int
ESECT
mdb_env_open2
(
MDB_env
*
env
)
{
unsigned
int
flags
=
env
-
>
me_flags
;
int
i
newenv
=
0
rc
;
MDB_meta
meta
;
#
ifdef
_WIN32
rc
=
GetVersion
(
)
;
if
(
(
rc
&
0xff
)
>
5
)
env
-
>
me_pidquery
=
MDB_PROCESS_QUERY_LIMITED_INFORMATION
;
else
env
-
>
me_pidquery
=
PROCESS_QUERY_INFORMATION
;
#
endif
#
ifdef
BROKEN_FDATASYNC
{
struct
statfs
st
;
fstatfs
(
env
-
>
me_fd
&
st
)
;
while
(
st
.
f_type
=
=
0xEF53
)
{
struct
utsname
uts
;
int
i
;
uname
(
&
uts
)
;
if
(
uts
.
release
[
0
]
<
'
3
'
)
{
if
(
!
strncmp
(
uts
.
release
"
2
.
6
.
32
.
"
7
)
)
{
i
=
atoi
(
uts
.
release
+
7
)
;
if
(
i
>
=
60
)
break
;
}
else
if
(
!
strncmp
(
uts
.
release
"
2
.
6
.
34
.
"
7
)
)
{
i
=
atoi
(
uts
.
release
+
7
)
;
if
(
i
>
=
15
)
break
;
}
}
else
if
(
uts
.
release
[
0
]
=
=
'
3
'
)
{
i
=
atoi
(
uts
.
release
+
2
)
;
if
(
i
>
5
)
break
;
if
(
i
=
=
5
)
{
i
=
atoi
(
uts
.
release
+
4
)
;
if
(
i
>
=
4
)
break
;
}
else
if
(
i
=
=
2
)
{
i
=
atoi
(
uts
.
release
+
4
)
;
if
(
i
>
=
30
)
break
;
}
}
else
{
break
;
}
env
-
>
me_flags
|
=
MDB_FSYNCONLY
;
break
;
}
}
#
endif
if
(
(
i
=
mdb_env_read_header
(
env
&
meta
)
)
!
=
0
)
{
if
(
i
!
=
ENOENT
)
return
i
;
DPUTS
(
"
new
mdbenv
"
)
;
newenv
=
1
;
env
-
>
me_psize
=
env
-
>
me_os_psize
;
if
(
env
-
>
me_psize
>
MAX_PAGESIZE
)
env
-
>
me_psize
=
MAX_PAGESIZE
;
memset
(
&
meta
0
sizeof
(
meta
)
)
;
mdb_env_init_meta0
(
env
&
meta
)
;
meta
.
mm_mapsize
=
DEFAULT_MAPSIZE
;
}
else
{
env
-
>
me_psize
=
meta
.
mm_psize
;
}
if
(
!
env
-
>
me_mapsize
)
{
env
-
>
me_mapsize
=
meta
.
mm_mapsize
;
}
{
size_t
minsize
=
(
meta
.
mm_last_pg
+
1
)
*
meta
.
mm_psize
;
if
(
env
-
>
me_mapsize
<
minsize
)
env
-
>
me_mapsize
=
minsize
;
}
meta
.
mm_mapsize
=
env
-
>
me_mapsize
;
if
(
newenv
&
&
!
(
flags
&
MDB_FIXEDMAP
)
)
{
rc
=
mdb_env_init_meta
(
env
&
meta
)
;
if
(
rc
)
return
rc
;
newenv
=
0
;
}
rc
=
mdb_env_map
(
env
(
flags
&
MDB_FIXEDMAP
)
?
meta
.
mm_address
:
NULL
)
;
if
(
rc
)
return
rc
;
if
(
newenv
)
{
if
(
flags
&
MDB_FIXEDMAP
)
meta
.
mm_address
=
env
-
>
me_map
;
i
=
mdb_env_init_meta
(
env
&
meta
)
;
if
(
i
!
=
MDB_SUCCESS
)
{
return
i
;
}
}
env
-
>
me_maxfree_1pg
=
(
env
-
>
me_psize
-
PAGEHDRSZ
)
/
sizeof
(
pgno_t
)
-
1
;
env
-
>
me_nodemax
=
(
(
(
env
-
>
me_psize
-
PAGEHDRSZ
)
/
MDB_MINKEYS
)
&
-
2
)
-
sizeof
(
indx_t
)
;
#
if
!
(
MDB_MAXKEYSIZE
)
env
-
>
me_maxkey
=
env
-
>
me_nodemax
-
(
NODESIZE
+
sizeof
(
MDB_db
)
)
;
#
endif
env
-
>
me_maxpg
=
env
-
>
me_mapsize
/
env
-
>
me_psize
;
#
if
MDB_DEBUG
{
MDB_meta
*
meta
=
mdb_env_pick_meta
(
env
)
;
MDB_db
*
db
=
&
meta
-
>
mm_dbs
[
MAIN_DBI
]
;
DPRINTF
(
(
"
opened
database
version
%
u
pagesize
%
u
"
meta
-
>
mm_version
env
-
>
me_psize
)
)
;
DPRINTF
(
(
"
using
meta
page
%
d
"
(
int
)
(
meta
-
>
mm_txnid
&
1
)
)
)
;
DPRINTF
(
(
"
depth
:
%
u
"
db
-
>
md_depth
)
)
;
DPRINTF
(
(
"
entries
:
%
"
Z
"
u
"
db
-
>
md_entries
)
)
;
DPRINTF
(
(
"
branch
pages
:
%
"
Z
"
u
"
db
-
>
md_branch_pages
)
)
;
DPRINTF
(
(
"
leaf
pages
:
%
"
Z
"
u
"
db
-
>
md_leaf_pages
)
)
;
DPRINTF
(
(
"
overflow
pages
:
%
"
Z
"
u
"
db
-
>
md_overflow_pages
)
)
;
DPRINTF
(
(
"
root
:
%
"
Z
"
u
"
db
-
>
md_root
)
)
;
}
#
endif
return
MDB_SUCCESS
;
}
static
void
mdb_env_reader_dest
(
void
*
ptr
)
{
MDB_reader
*
reader
=
ptr
;
#
ifndef
_WIN32
if
(
reader
-
>
mr_pid
=
=
getpid
(
)
)
#
endif
reader
-
>
mr_pid
=
0
;
}
#
ifdef
_WIN32
#
ifndef
MAX_TLS_KEYS
#
define
MAX_TLS_KEYS
64
#
endif
static
pthread_key_t
mdb_tls_keys
[
MAX_TLS_KEYS
]
;
static
int
mdb_tls_nkeys
;
static
void
NTAPI
mdb_tls_callback
(
PVOID
module
DWORD
reason
PVOID
ptr
)
{
int
i
;
switch
(
reason
)
{
case
DLL_PROCESS_ATTACH
:
break
;
case
DLL_THREAD_ATTACH
:
break
;
case
DLL_THREAD_DETACH
:
for
(
i
=
0
;
i
<
mdb_tls_nkeys
;
i
+
+
)
{
MDB_reader
*
r
=
pthread_getspecific
(
mdb_tls_keys
[
i
]
)
;
if
(
r
)
{
mdb_env_reader_dest
(
r
)
;
}
}
break
;
case
DLL_PROCESS_DETACH
:
break
;
}
}
#
ifdef
__GNUC__
#
ifdef
_WIN64
const
PIMAGE_TLS_CALLBACK
mdb_tls_cbp
__attribute__
(
(
section
(
"
.
CRT
XLB
"
)
)
)
=
mdb_tls_callback
;
#
else
PIMAGE_TLS_CALLBACK
mdb_tls_cbp
__attribute__
(
(
section
(
"
.
CRT
XLB
"
)
)
)
=
mdb_tls_callback
;
#
endif
#
else
#
ifdef
_WIN64
#
pragma
comment
(
linker
"
/
INCLUDE
:
_tls_used
"
)
#
pragma
comment
(
linker
"
/
INCLUDE
:
mdb_tls_cbp
"
)
#
pragma
const_seg
(
"
.
CRT
XLB
"
)
extern
const
PIMAGE_TLS_CALLBACK
mdb_tls_cbp
;
const
PIMAGE_TLS_CALLBACK
mdb_tls_cbp
=
mdb_tls_callback
;
#
pragma
const_seg
(
)
#
else
#
pragma
comment
(
linker
"
/
INCLUDE
:
__tls_used
"
)
#
pragma
comment
(
linker
"
/
INCLUDE
:
_mdb_tls_cbp
"
)
#
pragma
data_seg
(
"
.
CRT
XLB
"
)
PIMAGE_TLS_CALLBACK
mdb_tls_cbp
=
mdb_tls_callback
;
#
pragma
data_seg
(
)
#
endif
#
endif
#
endif
static
int
ESECT
mdb_env_share_locks
(
MDB_env
*
env
int
*
excl
)
{
int
rc
=
0
;
MDB_meta
*
meta
=
mdb_env_pick_meta
(
env
)
;
env
-
>
me_txns
-
>
mti_txnid
=
meta
-
>
mm_txnid
;
#
ifdef
_WIN32
{
OVERLAPPED
ov
;
memset
(
&
ov
0
sizeof
(
ov
)
)
;
if
(
!
LockFileEx
(
env
-
>
me_lfd
0
0
1
0
&
ov
)
)
{
rc
=
ErrCode
(
)
;
}
else
{
UnlockFile
(
env
-
>
me_lfd
0
0
1
0
)
;
*
excl
=
0
;
}
}
#
else
{
struct
flock
lock_info
;
memset
(
(
void
*
)
&
lock_info
0
sizeof
(
lock_info
)
)
;
lock_info
.
l_type
=
F_RDLCK
;
lock_info
.
l_whence
=
SEEK_SET
;
lock_info
.
l_start
=
0
;
lock_info
.
l_len
=
1
;
while
(
(
rc
=
fcntl
(
env
-
>
me_lfd
F_SETLK
&
lock_info
)
)
&
&
(
rc
=
ErrCode
(
)
)
=
=
EINTR
)
;
*
excl
=
rc
?
-
1
:
0
;
}
#
endif
return
rc
;
}
static
int
ESECT
mdb_env_excl_lock
(
MDB_env
*
env
int
*
excl
)
{
int
rc
=
0
;
#
ifdef
_WIN32
if
(
LockFile
(
env
-
>
me_lfd
0
0
1
0
)
)
{
*
excl
=
1
;
}
else
{
OVERLAPPED
ov
;
memset
(
&
ov
0
sizeof
(
ov
)
)
;
if
(
LockFileEx
(
env
-
>
me_lfd
0
0
1
0
&
ov
)
)
{
*
excl
=
0
;
}
else
{
rc
=
ErrCode
(
)
;
}
}
#
else
struct
flock
lock_info
;
memset
(
(
void
*
)
&
lock_info
0
sizeof
(
lock_info
)
)
;
lock_info
.
l_type
=
F_WRLCK
;
lock_info
.
l_whence
=
SEEK_SET
;
lock_info
.
l_start
=
0
;
lock_info
.
l_len
=
1
;
while
(
(
rc
=
fcntl
(
env
-
>
me_lfd
F_SETLK
&
lock_info
)
)
&
&
(
rc
=
ErrCode
(
)
)
=
=
EINTR
)
;
if
(
!
rc
)
{
*
excl
=
1
;
}
else
#
ifndef
MDB_USE_POSIX_MUTEX
if
(
*
excl
<
0
)
#
endif
{
lock_info
.
l_type
=
F_RDLCK
;
while
(
(
rc
=
fcntl
(
env
-
>
me_lfd
F_SETLKW
&
lock_info
)
)
&
&
(
rc
=
ErrCode
(
)
)
=
=
EINTR
)
;
if
(
rc
=
=
0
)
*
excl
=
0
;
}
#
endif
return
rc
;
}
#
ifdef
MDB_USE_HASH
typedef
unsigned
long
long
mdb_hash_t
;
#
define
MDB_HASH_INIT
(
(
mdb_hash_t
)
0xcbf29ce484222325ULL
)
static
mdb_hash_t
mdb_hash_val
(
MDB_val
*
val
mdb_hash_t
hval
)
{
unsigned
char
*
s
=
(
unsigned
char
*
)
val
-
>
mv_data
;
unsigned
char
*
end
=
s
+
val
-
>
mv_size
;
while
(
s
<
end
)
{
hval
^
=
(
mdb_hash_t
)
*
s
+
+
;
hval
+
=
(
hval
<
<
1
)
+
(
hval
<
<
4
)
+
(
hval
<
<
5
)
+
(
hval
<
<
7
)
+
(
hval
<
<
8
)
+
(
hval
<
<
40
)
;
}
return
hval
;
}
static
const
char
mdb_a85
[
]
=
"
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
!
#
%
&
(
)
*
+
-
;
<
=
>
?
^
_
{
|
}
~
"
;
static
void
ESECT
mdb_pack85
(
unsigned
long
l
char
*
out
)
{
int
i
;
for
(
i
=
0
;
i
<
5
;
i
+
+
)
{
*
out
+
+
=
mdb_a85
[
l
%
85
]
;
l
/
=
85
;
}
}
static
void
ESECT
mdb_hash_enc
(
MDB_val
*
val
char
*
encbuf
)
{
mdb_hash_t
h
=
mdb_hash_val
(
val
MDB_HASH_INIT
)
;
mdb_pack85
(
h
encbuf
)
;
mdb_pack85
(
h
>
>
32
encbuf
+
5
)
;
encbuf
[
10
]
=
'
\
0
'
;
}
#
endif
static
int
ESECT
mdb_env_setup_locks
(
MDB_env
*
env
MDB_name
*
fname
int
mode
int
*
excl
)
{
#
ifdef
_WIN32
#
define
MDB_ERRCODE_ROFS
ERROR_WRITE_PROTECT
#
else
#
define
MDB_ERRCODE_ROFS
EROFS
#
endif
int
rc
;
off_t
size
rsize
;
rc
=
mdb_fopen
(
env
fname
MDB_O_LOCKS
mode
&
env
-
>
me_lfd
)
;
if
(
rc
)
{
if
(
rc
=
=
MDB_ERRCODE_ROFS
&
&
(
env
-
>
me_flags
&
MDB_RDONLY
)
)
{
return
MDB_SUCCESS
;
}
goto
fail
;
}
if
(
!
(
env
-
>
me_flags
&
MDB_NOTLS
)
)
{
rc
=
pthread_key_create
(
&
env
-
>
me_txkey
mdb_env_reader_dest
)
;
if
(
rc
)
goto
fail
;
env
-
>
me_flags
|
=
MDB_ENV_TXKEY
;
#
ifdef
_WIN32
if
(
mdb_tls_nkeys
>
=
MAX_TLS_KEYS
)
{
rc
=
MDB_TLS_FULL
;
goto
fail
;
}
mdb_tls_keys
[
mdb_tls_nkeys
+
+
]
=
env
-
>
me_txkey
;
#
endif
}
if
(
(
rc
=
mdb_env_excl_lock
(
env
excl
)
)
)
goto
fail
;
#
ifdef
_WIN32
size
=
GetFileSize
(
env
-
>
me_lfd
NULL
)
;
#
else
size
=
lseek
(
env
-
>
me_lfd
0
SEEK_END
)
;
if
(
size
=
=
-
1
)
goto
fail_errno
;
#
endif
rsize
=
(
env
-
>
me_maxreaders
-
1
)
*
sizeof
(
MDB_reader
)
+
sizeof
(
MDB_txninfo
)
;
if
(
size
<
rsize
&
&
*
excl
>
0
)
{
#
ifdef
_WIN32
if
(
SetFilePointer
(
env
-
>
me_lfd
rsize
NULL
FILE_BEGIN
)
!
=
(
DWORD
)
rsize
|
|
!
SetEndOfFile
(
env
-
>
me_lfd
)
)
goto
fail_errno
;
#
else
if
(
ftruncate
(
env
-
>
me_lfd
rsize
)
!
=
0
)
goto
fail_errno
;
#
endif
}
else
{
rsize
=
size
;
size
=
rsize
-
sizeof
(
MDB_txninfo
)
;
env
-
>
me_maxreaders
=
size
/
sizeof
(
MDB_reader
)
+
1
;
}
{
#
ifdef
_WIN32
HANDLE
mh
;
mh
=
CreateFileMapping
(
env
-
>
me_lfd
NULL
PAGE_READWRITE
0
0
NULL
)
;
if
(
!
mh
)
goto
fail_errno
;
env
-
>
me_txns
=
MapViewOfFileEx
(
mh
FILE_MAP_WRITE
0
0
rsize
NULL
)
;
CloseHandle
(
mh
)
;
if
(
!
env
-
>
me_txns
)
goto
fail_errno
;
#
else
void
*
m
=
mmap
(
NULL
rsize
PROT_READ
|
PROT_WRITE
MAP_SHARED
env
-
>
me_lfd
0
)
;
if
(
m
=
=
MAP_FAILED
)
goto
fail_errno
;
env
-
>
me_txns
=
m
;
#
endif
}
if
(
*
excl
>
0
)
{
#
ifdef
_WIN32
BY_HANDLE_FILE_INFORMATION
stbuf
;
struct
{
DWORD
volume
;
DWORD
nhigh
;
DWORD
nlow
;
}
idbuf
;
MDB_val
val
;
char
encbuf
[
11
]
;
if
(
!
mdb_sec_inited
)
{
InitializeSecurityDescriptor
(
&
mdb_null_sd
SECURITY_DESCRIPTOR_REVISION
)
;
SetSecurityDescriptorDacl
(
&
mdb_null_sd
TRUE
0
FALSE
)
;
mdb_all_sa
.
nLength
=
sizeof
(
SECURITY_ATTRIBUTES
)
;
mdb_all_sa
.
bInheritHandle
=
FALSE
;
mdb_all_sa
.
lpSecurityDescriptor
=
&
mdb_null_sd
;
mdb_sec_inited
=
1
;
}
if
(
!
GetFileInformationByHandle
(
env
-
>
me_lfd
&
stbuf
)
)
goto
fail_errno
;
idbuf
.
volume
=
stbuf
.
dwVolumeSerialNumber
;
idbuf
.
nhigh
=
stbuf
.
nFileIndexHigh
;
idbuf
.
nlow
=
stbuf
.
nFileIndexLow
;
val
.
mv_data
=
&
idbuf
;
val
.
mv_size
=
sizeof
(
idbuf
)
;
mdb_hash_enc
(
&
val
encbuf
)
;
sprintf
(
env
-
>
me_txns
-
>
mti_rmname
"
Global
\
\
MDBr
%
s
"
encbuf
)
;
sprintf
(
env
-
>
me_txns
-
>
mti_wmname
"
Global
\
\
MDBw
%
s
"
encbuf
)
;
env
-
>
me_rmutex
=
CreateMutexA
(
&
mdb_all_sa
FALSE
env
-
>
me_txns
-
>
mti_rmname
)
;
if
(
!
env
-
>
me_rmutex
)
goto
fail_errno
;
env
-
>
me_wmutex
=
CreateMutexA
(
&
mdb_all_sa
FALSE
env
-
>
me_txns
-
>
mti_wmname
)
;
if
(
!
env
-
>
me_wmutex
)
goto
fail_errno
;
#
elif
defined
(
MDB_USE_POSIX_SEM
)
struct
stat
stbuf
;
struct
{
dev_t
dev
;
ino_t
ino
;
}
idbuf
;
MDB_val
val
;
char
encbuf
[
11
]
;
#
if
defined
(
__NetBSD__
)
#
define
MDB_SHORT_SEMNAMES
1
/
*
limited
to
14
chars
*
/
#
endif
if
(
fstat
(
env
-
>
me_lfd
&
stbuf
)
)
goto
fail_errno
;
idbuf
.
dev
=
stbuf
.
st_dev
;
idbuf
.
ino
=
stbuf
.
st_ino
;
val
.
mv_data
=
&
idbuf
;
val
.
mv_size
=
sizeof
(
idbuf
)
;
mdb_hash_enc
(
&
val
encbuf
)
;
#
ifdef
MDB_SHORT_SEMNAMES
encbuf
[
9
]
=
'
\
0
'
;
#
endif
sprintf
(
env
-
>
me_txns
-
>
mti_rmname
"
/
MDBr
%
s
"
encbuf
)
;
sprintf
(
env
-
>
me_txns
-
>
mti_wmname
"
/
MDBw
%
s
"
encbuf
)
;
sem_unlink
(
env
-
>
me_txns
-
>
mti_rmname
)
;
sem_unlink
(
env
-
>
me_txns
-
>
mti_wmname
)
;
env
-
>
me_rmutex
=
sem_open
(
env
-
>
me_txns
-
>
mti_rmname
O_CREAT
|
O_EXCL
mode
1
)
;
if
(
env
-
>
me_rmutex
=
=
SEM_FAILED
)
goto
fail_errno
;
env
-
>
me_wmutex
=
sem_open
(
env
-
>
me_txns
-
>
mti_wmname
O_CREAT
|
O_EXCL
mode
1
)
;
if
(
env
-
>
me_wmutex
=
=
SEM_FAILED
)
goto
fail_errno
;
#
else
pthread_mutexattr_t
mattr
;
memset
(
env
-
>
me_txns
-
>
mti_rmutex
0
sizeof
(
*
env
-
>
me_txns
-
>
mti_rmutex
)
)
;
memset
(
env
-
>
me_txns
-
>
mti_wmutex
0
sizeof
(
*
env
-
>
me_txns
-
>
mti_wmutex
)
)
;
if
(
(
rc
=
pthread_mutexattr_init
(
&
mattr
)
)
)
goto
fail
;
rc
=
pthread_mutexattr_setpshared
(
&
mattr
PTHREAD_PROCESS_SHARED
)
;
#
ifdef
MDB_ROBUST_SUPPORTED
if
(
!
rc
)
rc
=
pthread_mutexattr_setrobust
(
&
mattr
PTHREAD_MUTEX_ROBUST
)
;
#
endif
if
(
!
rc
)
rc
=
pthread_mutex_init
(
env
-
>
me_txns
-
>
mti_rmutex
&
mattr
)
;
if
(
!
rc
)
rc
=
pthread_mutex_init
(
env
-
>
me_txns
-
>
mti_wmutex
&
mattr
)
;
pthread_mutexattr_destroy
(
&
mattr
)
;
if
(
rc
)
goto
fail
;
#
endif
env
-
>
me_txns
-
>
mti_magic
=
MDB_MAGIC
;
env
-
>
me_txns
-
>
mti_format
=
MDB_LOCK_FORMAT
;
env
-
>
me_txns
-
>
mti_txnid
=
0
;
env
-
>
me_txns
-
>
mti_numreaders
=
0
;
}
else
{
if
(
env
-
>
me_txns
-
>
mti_magic
!
=
MDB_MAGIC
)
{
DPUTS
(
"
lock
region
has
invalid
magic
"
)
;
rc
=
MDB_INVALID
;
goto
fail
;
}
if
(
env
-
>
me_txns
-
>
mti_format
!
=
MDB_LOCK_FORMAT
)
{
DPRINTF
(
(
"
lock
region
has
format
+
version
0x
%
x
expected
0x
%
x
"
env
-
>
me_txns
-
>
mti_format
MDB_LOCK_FORMAT
)
)
;
rc
=
MDB_VERSION_MISMATCH
;
goto
fail
;
}
rc
=
ErrCode
(
)
;
if
(
rc
&
&
rc
!
=
EACCES
&
&
rc
!
=
EAGAIN
)
{
goto
fail
;
}
#
ifdef
_WIN32
env
-
>
me_rmutex
=
OpenMutexA
(
SYNCHRONIZE
FALSE
env
-
>
me_txns
-
>
mti_rmname
)
;
if
(
!
env
-
>
me_rmutex
)
goto
fail_errno
;
env
-
>
me_wmutex
=
OpenMutexA
(
SYNCHRONIZE
FALSE
env
-
>
me_txns
-
>
mti_wmname
)
;
if
(
!
env
-
>
me_wmutex
)
goto
fail_errno
;
#
elif
defined
(
MDB_USE_POSIX_SEM
)
env
-
>
me_rmutex
=
sem_open
(
env
-
>
me_txns
-
>
mti_rmname
0
)
;
if
(
env
-
>
me_rmutex
=
=
SEM_FAILED
)
goto
fail_errno
;
env
-
>
me_wmutex
=
sem_open
(
env
-
>
me_txns
-
>
mti_wmname
0
)
;
if
(
env
-
>
me_wmutex
=
=
SEM_FAILED
)
goto
fail_errno
;
#
endif
}
return
MDB_SUCCESS
;
fail_errno
:
rc
=
ErrCode
(
)
;
fail
:
return
rc
;
}
#
define
CHANGEABLE
(
MDB_NOSYNC
|
MDB_NOMETASYNC
|
MDB_MAPASYNC
|
MDB_NOMEMINIT
)
#
define
CHANGELESS
(
MDB_FIXEDMAP
|
MDB_NOSUBDIR
|
MDB_RDONLY
|
\
MDB_WRITEMAP
|
MDB_NOTLS
|
MDB_NOLOCK
|
MDB_NORDAHEAD
)
#
if
VALID_FLAGS
&
PERSISTENT_FLAGS
&
(
CHANGEABLE
|
CHANGELESS
)
#
error
"
Persistent
DB
flags
&
env
flags
overlap
but
both
go
in
mm_flags
"
#
endif
int
ESECT
mdb_env_open
(
MDB_env
*
env
const
char
*
path
unsigned
int
flags
mdb_mode_t
mode
)
{
int
rc
excl
=
-
1
;
MDB_name
fname
;
if
(
env
-
>
me_fd
!
=
INVALID_HANDLE_VALUE
|
|
(
flags
&
~
(
CHANGEABLE
|
CHANGELESS
)
)
)
return
EINVAL
;
flags
|
=
env
-
>
me_flags
;
rc
=
mdb_fname_init
(
path
flags
&
fname
)
;
if
(
rc
)
return
rc
;
if
(
flags
&
MDB_RDONLY
)
{
flags
&
=
~
MDB_WRITEMAP
;
}
else
{
if
(
!
(
(
env
-
>
me_free_pgs
=
mdb_midl_alloc
(
MDB_IDL_UM_MAX
)
)
&
&
(
env
-
>
me_dirty_list
=
calloc
(
MDB_IDL_UM_SIZE
sizeof
(
MDB_ID2
)
)
)
)
)
rc
=
ENOMEM
;
}
env
-
>
me_flags
=
flags
|
=
MDB_ENV_ACTIVE
;
if
(
rc
)
goto
leave
;
env
-
>
me_path
=
strdup
(
path
)
;
env
-
>
me_dbxs
=
calloc
(
env
-
>
me_maxdbs
sizeof
(
MDB_dbx
)
)
;
env
-
>
me_dbflags
=
calloc
(
env
-
>
me_maxdbs
sizeof
(
uint16_t
)
)
;
env
-
>
me_dbiseqs
=
calloc
(
env
-
>
me_maxdbs
sizeof
(
unsigned
int
)
)
;
if
(
!
(
env
-
>
me_dbxs
&
&
env
-
>
me_path
&
&
env
-
>
me_dbflags
&
&
env
-
>
me_dbiseqs
)
)
{
rc
=
ENOMEM
;
goto
leave
;
}
env
-
>
me_dbxs
[
FREE_DBI
]
.
md_cmp
=
mdb_cmp_long
;
if
(
!
(
flags
&
(
MDB_RDONLY
|
MDB_NOLOCK
)
)
)
{
rc
=
mdb_env_setup_locks
(
env
&
fname
mode
&
excl
)
;
if
(
rc
)
goto
leave
;
}
rc
=
mdb_fopen
(
env
&
fname
(
flags
&
MDB_RDONLY
)
?
MDB_O_RDONLY
:
MDB_O_RDWR
mode
&
env
-
>
me_fd
)
;
if
(
rc
)
goto
leave
;
if
(
(
flags
&
(
MDB_RDONLY
|
MDB_NOLOCK
)
)
=
=
MDB_RDONLY
)
{
rc
=
mdb_env_setup_locks
(
env
&
fname
mode
&
excl
)
;
if
(
rc
)
goto
leave
;
}
if
(
(
rc
=
mdb_env_open2
(
env
)
)
=
=
MDB_SUCCESS
)
{
if
(
!
(
flags
&
(
MDB_RDONLY
|
MDB_WRITEMAP
)
)
)
{
rc
=
mdb_fopen
(
env
&
fname
MDB_O_META
mode
&
env
-
>
me_mfd
)
;
if
(
rc
)
goto
leave
;
}
DPRINTF
(
(
"
opened
dbenv
%
p
"
(
void
*
)
env
)
)
;
if
(
excl
>
0
)
{
rc
=
mdb_env_share_locks
(
env
&
excl
)
;
if
(
rc
)
goto
leave
;
}
if
(
!
(
flags
&
MDB_RDONLY
)
)
{
MDB_txn
*
txn
;
int
tsize
=
sizeof
(
MDB_txn
)
size
=
tsize
+
env
-
>
me_maxdbs
*
(
sizeof
(
MDB_db
)
+
sizeof
(
MDB_cursor
*
)
+
sizeof
(
unsigned
int
)
+
1
)
;
if
(
(
env
-
>
me_pbuf
=
calloc
(
1
env
-
>
me_psize
)
)
&
&
(
txn
=
calloc
(
1
size
)
)
)
{
txn
-
>
mt_dbs
=
(
MDB_db
*
)
(
(
char
*
)
txn
+
tsize
)
;
txn
-
>
mt_cursors
=
(
MDB_cursor
*
*
)
(
txn
-
>
mt_dbs
+
env
-
>
me_maxdbs
)
;
txn
-
>
mt_dbiseqs
=
(
unsigned
int
*
)
(
txn
-
>
mt_cursors
+
env
-
>
me_maxdbs
)
;
txn
-
>
mt_dbflags
=
(
unsigned
char
*
)
(
txn
-
>
mt_dbiseqs
+
env
-
>
me_maxdbs
)
;
txn
-
>
mt_env
=
env
;
txn
-
>
mt_dbxs
=
env
-
>
me_dbxs
;
txn
-
>
mt_flags
=
MDB_TXN_FINISHED
;
env
-
>
me_txn0
=
txn
;
}
else
{
rc
=
ENOMEM
;
}
}
}
leave
:
if
(
rc
)
{
mdb_env_close0
(
env
excl
)
;
}
mdb_fname_destroy
(
fname
)
;
return
rc
;
}
static
void
ESECT
mdb_env_close0
(
MDB_env
*
env
int
excl
)
{
int
i
;
if
(
!
(
env
-
>
me_flags
&
MDB_ENV_ACTIVE
)
)
return
;
if
(
env
-
>
me_dbxs
)
{
for
(
i
=
env
-
>
me_maxdbs
;
-
-
i
>
=
CORE_DBS
;
)
free
(
env
-
>
me_dbxs
[
i
]
.
md_name
.
mv_data
)
;
free
(
env
-
>
me_dbxs
)
;
}
free
(
env
-
>
me_pbuf
)
;
free
(
env
-
>
me_dbiseqs
)
;
free
(
env
-
>
me_dbflags
)
;
free
(
env
-
>
me_path
)
;
free
(
env
-
>
me_dirty_list
)
;
free
(
env
-
>
me_txn0
)
;
mdb_midl_free
(
env
-
>
me_free_pgs
)
;
if
(
env
-
>
me_flags
&
MDB_ENV_TXKEY
)
{
pthread_key_delete
(
env
-
>
me_txkey
)
;
#
ifdef
_WIN32
for
(
i
=
0
;
i
<
mdb_tls_nkeys
;
i
+
+
)
if
(
mdb_tls_keys
[
i
]
=
=
env
-
>
me_txkey
)
{
mdb_tls_keys
[
i
]
=
mdb_tls_keys
[
mdb_tls_nkeys
-
1
]
;
mdb_tls_nkeys
-
-
;
break
;
}
#
endif
}
if
(
env
-
>
me_map
)
{
munmap
(
env
-
>
me_map
env
-
>
me_mapsize
)
;
}
if
(
env
-
>
me_mfd
!
=
INVALID_HANDLE_VALUE
)
(
void
)
close
(
env
-
>
me_mfd
)
;
if
(
env
-
>
me_fd
!
=
INVALID_HANDLE_VALUE
)
(
void
)
close
(
env
-
>
me_fd
)
;
if
(
env
-
>
me_txns
)
{
MDB_PID_T
pid
=
env
-
>
me_pid
;
for
(
i
=
env
-
>
me_close_readers
;
-
-
i
>
=
0
;
)
if
(
env
-
>
me_txns
-
>
mti_readers
[
i
]
.
mr_pid
=
=
pid
)
env
-
>
me_txns
-
>
mti_readers
[
i
]
.
mr_pid
=
0
;
#
ifdef
_WIN32
if
(
env
-
>
me_rmutex
)
{
CloseHandle
(
env
-
>
me_rmutex
)
;
if
(
env
-
>
me_wmutex
)
CloseHandle
(
env
-
>
me_wmutex
)
;
}
#
elif
defined
(
MDB_USE_POSIX_SEM
)
if
(
env
-
>
me_rmutex
!
=
SEM_FAILED
)
{
sem_close
(
env
-
>
me_rmutex
)
;
if
(
env
-
>
me_wmutex
!
=
SEM_FAILED
)
sem_close
(
env
-
>
me_wmutex
)
;
if
(
excl
=
=
0
)
mdb_env_excl_lock
(
env
&
excl
)
;
if
(
excl
>
0
)
{
sem_unlink
(
env
-
>
me_txns
-
>
mti_rmname
)
;
sem_unlink
(
env
-
>
me_txns
-
>
mti_wmname
)
;
}
}
#
endif
munmap
(
(
void
*
)
env
-
>
me_txns
(
env
-
>
me_maxreaders
-
1
)
*
sizeof
(
MDB_reader
)
+
sizeof
(
MDB_txninfo
)
)
;
}
if
(
env
-
>
me_lfd
!
=
INVALID_HANDLE_VALUE
)
{
#
ifdef
_WIN32
if
(
excl
>
=
0
)
{
UnlockFile
(
env
-
>
me_lfd
0
0
1
0
)
;
}
#
endif
(
void
)
close
(
env
-
>
me_lfd
)
;
}
env
-
>
me_flags
&
=
~
(
MDB_ENV_ACTIVE
|
MDB_ENV_TXKEY
)
;
}
void
ESECT
mdb_env_close
(
MDB_env
*
env
)
{
MDB_page
*
dp
;
if
(
env
=
=
NULL
)
return
;
VGMEMP_DESTROY
(
env
)
;
while
(
(
dp
=
env
-
>
me_dpages
)
!
=
NULL
)
{
VGMEMP_DEFINED
(
&
dp
-
>
mp_next
sizeof
(
dp
-
>
mp_next
)
)
;
env
-
>
me_dpages
=
dp
-
>
mp_next
;
free
(
dp
)
;
}
mdb_env_close0
(
env
0
)
;
free
(
env
)
;
}
static
int
mdb_cmp_long
(
const
MDB_val
*
a
const
MDB_val
*
b
)
{
return
(
*
(
size_t
*
)
a
-
>
mv_data
<
*
(
size_t
*
)
b
-
>
mv_data
)
?
-
1
:
*
(
size_t
*
)
a
-
>
mv_data
>
*
(
size_t
*
)
b
-
>
mv_data
;
}
static
int
mdb_cmp_int
(
const
MDB_val
*
a
const
MDB_val
*
b
)
{
return
(
*
(
unsigned
int
*
)
a
-
>
mv_data
<
*
(
unsigned
int
*
)
b
-
>
mv_data
)
?
-
1
:
*
(
unsigned
int
*
)
a
-
>
mv_data
>
*
(
unsigned
int
*
)
b
-
>
mv_data
;
}
static
int
mdb_cmp_cint
(
const
MDB_val
*
a
const
MDB_val
*
b
)
{
#
if
BYTE_ORDER
=
=
LITTLE_ENDIAN
unsigned
short
*
u
*
c
;
int
x
;
u
=
(
unsigned
short
*
)
(
(
char
*
)
a
-
>
mv_data
+
a
-
>
mv_size
)
;
c
=
(
unsigned
short
*
)
(
(
char
*
)
b
-
>
mv_data
+
a
-
>
mv_size
)
;
do
{
x
=
*
-
-
u
-
*
-
-
c
;
}
while
(
!
x
&
&
u
>
(
unsigned
short
*
)
a
-
>
mv_data
)
;
return
x
;
#
else
unsigned
short
*
u
*
c
*
end
;
int
x
;
end
=
(
unsigned
short
*
)
(
(
char
*
)
a
-
>
mv_data
+
a
-
>
mv_size
)
;
u
=
(
unsigned
short
*
)
a
-
>
mv_data
;
c
=
(
unsigned
short
*
)
b
-
>
mv_data
;
do
{
x
=
*
u
+
+
-
*
c
+
+
;
}
while
(
!
x
&
&
u
<
end
)
;
return
x
;
#
endif
}
static
int
mdb_cmp_memn
(
const
MDB_val
*
a
const
MDB_val
*
b
)
{
int
diff
;
ssize_t
len_diff
;
unsigned
int
len
;
len
=
a
-
>
mv_size
;
len_diff
=
(
ssize_t
)
a
-
>
mv_size
-
(
ssize_t
)
b
-
>
mv_size
;
if
(
len_diff
>
0
)
{
len
=
b
-
>
mv_size
;
len_diff
=
1
;
}
diff
=
memcmp
(
a
-
>
mv_data
b
-
>
mv_data
len
)
;
return
diff
?
diff
:
len_diff
<
0
?
-
1
:
len_diff
;
}
static
int
mdb_cmp_memnr
(
const
MDB_val
*
a
const
MDB_val
*
b
)
{
const
unsigned
char
*
p1
*
p2
*
p1_lim
;
ssize_t
len_diff
;
int
diff
;
p1_lim
=
(
const
unsigned
char
*
)
a
-
>
mv_data
;
p1
=
(
const
unsigned
char
*
)
a
-
>
mv_data
+
a
-
>
mv_size
;
p2
=
(
const
unsigned
char
*
)
b
-
>
mv_data
+
b
-
>
mv_size
;
len_diff
=
(
ssize_t
)
a
-
>
mv_size
-
(
ssize_t
)
b
-
>
mv_size
;
if
(
len_diff
>
0
)
{
p1_lim
+
=
len_diff
;
len_diff
=
1
;
}
while
(
p1
>
p1_lim
)
{
diff
=
*
-
-
p1
-
*
-
-
p2
;
if
(
diff
)
return
diff
;
}
return
len_diff
<
0
?
-
1
:
len_diff
;
}
static
MDB_node
*
mdb_node_search
(
MDB_cursor
*
mc
MDB_val
*
key
int
*
exactp
)
{
unsigned
int
i
=
0
nkeys
;
int
low
high
;
int
rc
=
0
;
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
MDB_node
*
node
=
NULL
;
MDB_val
nodekey
;
MDB_cmp_func
*
cmp
;
DKBUF
;
nkeys
=
NUMKEYS
(
mp
)
;
DPRINTF
(
(
"
searching
%
u
keys
in
%
s
%
spage
%
"
Z
"
u
"
nkeys
IS_LEAF
(
mp
)
?
"
leaf
"
:
"
branch
"
IS_SUBP
(
mp
)
?
"
sub
-
"
:
"
"
mdb_dbg_pgno
(
mp
)
)
)
;
low
=
IS_LEAF
(
mp
)
?
0
:
1
;
high
=
nkeys
-
1
;
cmp
=
mc
-
>
mc_dbx
-
>
md_cmp
;
if
(
cmp
=
=
mdb_cmp_cint
&
&
IS_BRANCH
(
mp
)
)
{
if
(
NODEPTR
(
mp
1
)
-
>
mn_ksize
=
=
sizeof
(
size_t
)
)
cmp
=
mdb_cmp_long
;
else
cmp
=
mdb_cmp_int
;
}
if
(
IS_LEAF2
(
mp
)
)
{
nodekey
.
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
node
=
NODEPTR
(
mp
0
)
;
while
(
low
<
=
high
)
{
i
=
(
low
+
high
)
>
>
1
;
nodekey
.
mv_data
=
LEAF2KEY
(
mp
i
nodekey
.
mv_size
)
;
rc
=
cmp
(
key
&
nodekey
)
;
DPRINTF
(
(
"
found
leaf
index
%
u
[
%
s
]
rc
=
%
i
"
i
DKEY
(
&
nodekey
)
rc
)
)
;
if
(
rc
=
=
0
)
break
;
if
(
rc
>
0
)
low
=
i
+
1
;
else
high
=
i
-
1
;
}
}
else
{
while
(
low
<
=
high
)
{
i
=
(
low
+
high
)
>
>
1
;
node
=
NODEPTR
(
mp
i
)
;
nodekey
.
mv_size
=
NODEKSZ
(
node
)
;
nodekey
.
mv_data
=
NODEKEY
(
node
)
;
rc
=
cmp
(
key
&
nodekey
)
;
#
if
MDB_DEBUG
if
(
IS_LEAF
(
mp
)
)
DPRINTF
(
(
"
found
leaf
index
%
u
[
%
s
]
rc
=
%
i
"
i
DKEY
(
&
nodekey
)
rc
)
)
;
else
DPRINTF
(
(
"
found
branch
index
%
u
[
%
s
-
>
%
"
Z
"
u
]
rc
=
%
i
"
i
DKEY
(
&
nodekey
)
NODEPGNO
(
node
)
rc
)
)
;
#
endif
if
(
rc
=
=
0
)
break
;
if
(
rc
>
0
)
low
=
i
+
1
;
else
high
=
i
-
1
;
}
}
if
(
rc
>
0
)
{
i
+
+
;
if
(
!
IS_LEAF2
(
mp
)
)
node
=
NODEPTR
(
mp
i
)
;
}
if
(
exactp
)
*
exactp
=
(
rc
=
=
0
&
&
nkeys
>
0
)
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
i
;
if
(
i
>
=
nkeys
)
return
NULL
;
return
node
;
}
#
if
0
static
void
mdb_cursor_adjust
(
MDB_cursor
*
mc
func
)
{
MDB_cursor
*
m2
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
mc
-
>
mc_dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
m2
-
>
mc_pg
[
m2
-
>
mc_top
]
=
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
{
func
(
mc
m2
)
;
}
}
}
#
endif
static
void
mdb_cursor_pop
(
MDB_cursor
*
mc
)
{
if
(
mc
-
>
mc_snum
)
{
DPRINTF
(
(
"
popping
page
%
"
Z
"
u
off
db
%
d
cursor
%
p
"
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
-
>
mp_pgno
DDBI
(
mc
)
(
void
*
)
mc
)
)
;
mc
-
>
mc_snum
-
-
;
if
(
mc
-
>
mc_snum
)
{
mc
-
>
mc_top
-
-
;
}
else
{
mc
-
>
mc_flags
&
=
~
C_INITIALIZED
;
}
}
}
static
int
mdb_cursor_push
(
MDB_cursor
*
mc
MDB_page
*
mp
)
{
DPRINTF
(
(
"
pushing
page
%
"
Z
"
u
on
db
%
d
cursor
%
p
"
mp
-
>
mp_pgno
DDBI
(
mc
)
(
void
*
)
mc
)
)
;
if
(
mc
-
>
mc_snum
>
=
CURSOR_STACK
)
{
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_CURSOR_FULL
;
}
mc
-
>
mc_top
=
mc
-
>
mc_snum
+
+
;
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
mp
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
return
MDB_SUCCESS
;
}
static
int
mdb_page_get
(
MDB_cursor
*
mc
pgno_t
pgno
MDB_page
*
*
ret
int
*
lvl
)
{
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
MDB_env
*
env
=
txn
-
>
mt_env
;
MDB_page
*
p
=
NULL
;
int
level
;
if
(
!
(
txn
-
>
mt_flags
&
(
MDB_TXN_RDONLY
|
MDB_TXN_WRITEMAP
)
)
)
{
MDB_txn
*
tx2
=
txn
;
level
=
1
;
do
{
MDB_ID2L
dl
=
tx2
-
>
mt_u
.
dirty_list
;
unsigned
x
;
if
(
tx2
-
>
mt_spill_pgs
)
{
MDB_ID
pn
=
pgno
<
<
1
;
x
=
mdb_midl_search
(
tx2
-
>
mt_spill_pgs
pn
)
;
if
(
x
<
=
tx2
-
>
mt_spill_pgs
[
0
]
&
&
tx2
-
>
mt_spill_pgs
[
x
]
=
=
pn
)
{
p
=
(
MDB_page
*
)
(
env
-
>
me_map
+
env
-
>
me_psize
*
pgno
)
;
goto
done
;
}
}
if
(
dl
[
0
]
.
mid
)
{
unsigned
x
=
mdb_mid2l_search
(
dl
pgno
)
;
if
(
x
<
=
dl
[
0
]
.
mid
&
&
dl
[
x
]
.
mid
=
=
pgno
)
{
p
=
dl
[
x
]
.
mptr
;
goto
done
;
}
}
level
+
+
;
}
while
(
(
tx2
=
tx2
-
>
mt_parent
)
!
=
NULL
)
;
}
if
(
pgno
<
txn
-
>
mt_next_pgno
)
{
level
=
0
;
p
=
(
MDB_page
*
)
(
env
-
>
me_map
+
env
-
>
me_psize
*
pgno
)
;
}
else
{
DPRINTF
(
(
"
page
%
"
Z
"
u
not
found
"
pgno
)
)
;
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_PAGE_NOTFOUND
;
}
done
:
*
ret
=
p
;
if
(
lvl
)
*
lvl
=
level
;
return
MDB_SUCCESS
;
}
static
int
mdb_page_search_root
(
MDB_cursor
*
mc
MDB_val
*
key
int
flags
)
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
int
rc
;
DKBUF
;
while
(
IS_BRANCH
(
mp
)
)
{
MDB_node
*
node
;
indx_t
i
;
DPRINTF
(
(
"
branch
page
%
"
Z
"
u
has
%
u
keys
"
mp
-
>
mp_pgno
NUMKEYS
(
mp
)
)
)
;
mdb_cassert
(
mc
!
mc
-
>
mc_dbi
|
|
NUMKEYS
(
mp
)
>
1
)
;
DPRINTF
(
(
"
found
index
0
to
page
%
"
Z
"
u
"
NODEPGNO
(
NODEPTR
(
mp
0
)
)
)
)
;
if
(
flags
&
(
MDB_PS_FIRST
|
MDB_PS_LAST
)
)
{
i
=
0
;
if
(
flags
&
MDB_PS_LAST
)
{
i
=
NUMKEYS
(
mp
)
-
1
;
if
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
{
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
=
i
)
{
mc
-
>
mc_top
=
mc
-
>
mc_snum
+
+
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
goto
ready
;
}
}
}
}
else
{
int
exact
;
node
=
mdb_node_search
(
mc
key
&
exact
)
;
if
(
node
=
=
NULL
)
i
=
NUMKEYS
(
mp
)
-
1
;
else
{
i
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
;
if
(
!
exact
)
{
mdb_cassert
(
mc
i
>
0
)
;
i
-
-
;
}
}
DPRINTF
(
(
"
following
index
%
u
for
key
[
%
s
]
"
i
DKEY
(
key
)
)
)
;
}
mdb_cassert
(
mc
i
<
NUMKEYS
(
mp
)
)
;
node
=
NODEPTR
(
mp
i
)
;
if
(
(
rc
=
mdb_page_get
(
mc
NODEPGNO
(
node
)
&
mp
NULL
)
)
!
=
0
)
return
rc
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
i
;
if
(
(
rc
=
mdb_cursor_push
(
mc
mp
)
)
)
return
rc
;
ready
:
if
(
flags
&
MDB_PS_MODIFY
)
{
if
(
(
rc
=
mdb_page_touch
(
mc
)
)
!
=
0
)
return
rc
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
}
}
if
(
!
IS_LEAF
(
mp
)
)
{
DPRINTF
(
(
"
internal
error
index
points
to
a
%
02X
page
!
?
"
mp
-
>
mp_flags
)
)
;
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_CORRUPTED
;
}
DPRINTF
(
(
"
found
leaf
page
%
"
Z
"
u
for
key
[
%
s
]
"
mp
-
>
mp_pgno
key
?
DKEY
(
key
)
:
"
null
"
)
)
;
mc
-
>
mc_flags
|
=
C_INITIALIZED
;
mc
-
>
mc_flags
&
=
~
C_EOF
;
return
MDB_SUCCESS
;
}
static
int
mdb_page_search_lowest
(
MDB_cursor
*
mc
)
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
MDB_node
*
node
=
NODEPTR
(
mp
0
)
;
int
rc
;
if
(
(
rc
=
mdb_page_get
(
mc
NODEPGNO
(
node
)
&
mp
NULL
)
)
!
=
0
)
return
rc
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
if
(
(
rc
=
mdb_cursor_push
(
mc
mp
)
)
)
return
rc
;
return
mdb_page_search_root
(
mc
NULL
MDB_PS_FIRST
)
;
}
static
int
mdb_page_search
(
MDB_cursor
*
mc
MDB_val
*
key
int
flags
)
{
int
rc
;
pgno_t
root
;
if
(
mc
-
>
mc_txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
{
DPUTS
(
"
transaction
may
not
be
used
now
"
)
;
return
MDB_BAD_TXN
;
}
else
{
if
(
*
mc
-
>
mc_dbflag
&
DB_STALE
)
{
MDB_cursor
mc2
;
if
(
TXN_DBI_CHANGED
(
mc
-
>
mc_txn
mc
-
>
mc_dbi
)
)
return
MDB_BAD_DBI
;
mdb_cursor_init
(
&
mc2
mc
-
>
mc_txn
MAIN_DBI
NULL
)
;
rc
=
mdb_page_search
(
&
mc2
&
mc
-
>
mc_dbx
-
>
md_name
0
)
;
if
(
rc
)
return
rc
;
{
MDB_val
data
;
int
exact
=
0
;
uint16_t
flags
;
MDB_node
*
leaf
=
mdb_node_search
(
&
mc2
&
mc
-
>
mc_dbx
-
>
md_name
&
exact
)
;
if
(
!
exact
)
return
MDB_NOTFOUND
;
if
(
(
leaf
-
>
mn_flags
&
(
F_DUPDATA
|
F_SUBDATA
)
)
!
=
F_SUBDATA
)
return
MDB_INCOMPATIBLE
;
rc
=
mdb_node_read
(
&
mc2
leaf
&
data
)
;
if
(
rc
)
return
rc
;
memcpy
(
&
flags
(
(
char
*
)
data
.
mv_data
+
offsetof
(
MDB_db
md_flags
)
)
sizeof
(
uint16_t
)
)
;
if
(
(
mc
-
>
mc_db
-
>
md_flags
&
PERSISTENT_FLAGS
)
!
=
flags
)
return
MDB_INCOMPATIBLE
;
memcpy
(
mc
-
>
mc_db
data
.
mv_data
sizeof
(
MDB_db
)
)
;
}
*
mc
-
>
mc_dbflag
&
=
~
DB_STALE
;
}
root
=
mc
-
>
mc_db
-
>
md_root
;
if
(
root
=
=
P_INVALID
)
{
DPUTS
(
"
tree
is
empty
"
)
;
return
MDB_NOTFOUND
;
}
}
mdb_cassert
(
mc
root
>
1
)
;
if
(
!
mc
-
>
mc_pg
[
0
]
|
|
mc
-
>
mc_pg
[
0
]
-
>
mp_pgno
!
=
root
)
if
(
(
rc
=
mdb_page_get
(
mc
root
&
mc
-
>
mc_pg
[
0
]
NULL
)
)
!
=
0
)
return
rc
;
mc
-
>
mc_snum
=
1
;
mc
-
>
mc_top
=
0
;
DPRINTF
(
(
"
db
%
d
root
page
%
"
Z
"
u
has
flags
0x
%
X
"
DDBI
(
mc
)
root
mc
-
>
mc_pg
[
0
]
-
>
mp_flags
)
)
;
if
(
flags
&
MDB_PS_MODIFY
)
{
if
(
(
rc
=
mdb_page_touch
(
mc
)
)
)
return
rc
;
}
if
(
flags
&
MDB_PS_ROOTONLY
)
return
MDB_SUCCESS
;
return
mdb_page_search_root
(
mc
key
flags
)
;
}
static
int
mdb_ovpage_free
(
MDB_cursor
*
mc
MDB_page
*
mp
)
{
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
pgno_t
pg
=
mp
-
>
mp_pgno
;
unsigned
x
=
0
ovpages
=
mp
-
>
mp_pages
;
MDB_env
*
env
=
txn
-
>
mt_env
;
MDB_IDL
sl
=
txn
-
>
mt_spill_pgs
;
MDB_ID
pn
=
pg
<
<
1
;
int
rc
;
DPRINTF
(
(
"
free
ov
page
%
"
Z
"
u
(
%
d
)
"
pg
ovpages
)
)
;
if
(
env
-
>
me_pghead
&
&
!
txn
-
>
mt_parent
&
&
(
(
mp
-
>
mp_flags
&
P_DIRTY
)
|
|
(
sl
&
&
(
x
=
mdb_midl_search
(
sl
pn
)
)
<
=
sl
[
0
]
&
&
sl
[
x
]
=
=
pn
)
)
)
{
unsigned
i
j
;
pgno_t
*
mop
;
MDB_ID2
*
dl
ix
iy
;
rc
=
mdb_midl_need
(
&
env
-
>
me_pghead
ovpages
)
;
if
(
rc
)
return
rc
;
if
(
!
(
mp
-
>
mp_flags
&
P_DIRTY
)
)
{
if
(
x
=
=
sl
[
0
]
)
sl
[
0
]
-
-
;
else
sl
[
x
]
|
=
1
;
goto
release
;
}
dl
=
txn
-
>
mt_u
.
dirty_list
;
x
=
dl
[
0
]
.
mid
-
-
;
for
(
ix
=
dl
[
x
]
;
ix
.
mptr
!
=
mp
;
ix
=
iy
)
{
if
(
x
>
1
)
{
x
-
-
;
iy
=
dl
[
x
]
;
dl
[
x
]
=
ix
;
}
else
{
mdb_cassert
(
mc
x
>
1
)
;
j
=
+
+
(
dl
[
0
]
.
mid
)
;
dl
[
j
]
=
ix
;
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_CORRUPTED
;
}
}
txn
-
>
mt_dirty_room
+
+
;
if
(
!
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
)
mdb_dpage_free
(
env
mp
)
;
release
:
mop
=
env
-
>
me_pghead
;
j
=
mop
[
0
]
+
ovpages
;
for
(
i
=
mop
[
0
]
;
i
&
&
mop
[
i
]
<
pg
;
i
-
-
)
mop
[
j
-
-
]
=
mop
[
i
]
;
while
(
j
>
i
)
mop
[
j
-
-
]
=
pg
+
+
;
mop
[
0
]
+
=
ovpages
;
}
else
{
rc
=
mdb_midl_append_range
(
&
txn
-
>
mt_free_pgs
pg
ovpages
)
;
if
(
rc
)
return
rc
;
}
mc
-
>
mc_db
-
>
md_overflow_pages
-
=
ovpages
;
return
0
;
}
static
int
mdb_node_read
(
MDB_cursor
*
mc
MDB_node
*
leaf
MDB_val
*
data
)
{
MDB_page
*
omp
;
pgno_t
pgno
;
int
rc
;
if
(
!
F_ISSET
(
leaf
-
>
mn_flags
F_BIGDATA
)
)
{
data
-
>
mv_size
=
NODEDSZ
(
leaf
)
;
data
-
>
mv_data
=
NODEDATA
(
leaf
)
;
return
MDB_SUCCESS
;
}
data
-
>
mv_size
=
NODEDSZ
(
leaf
)
;
memcpy
(
&
pgno
NODEDATA
(
leaf
)
sizeof
(
pgno
)
)
;
if
(
(
rc
=
mdb_page_get
(
mc
pgno
&
omp
NULL
)
)
!
=
0
)
{
DPRINTF
(
(
"
read
overflow
page
%
"
Z
"
u
failed
"
pgno
)
)
;
return
rc
;
}
data
-
>
mv_data
=
METADATA
(
omp
)
;
return
MDB_SUCCESS
;
}
int
mdb_get
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_val
*
key
MDB_val
*
data
)
{
MDB_cursor
mc
;
MDB_xcursor
mx
;
int
exact
=
0
;
DKBUF
;
DPRINTF
(
(
"
=
=
=
>
get
db
%
u
key
[
%
s
]
"
dbi
DKEY
(
key
)
)
)
;
if
(
!
key
|
|
!
data
|
|
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
mdb_cursor_init
(
&
mc
txn
dbi
&
mx
)
;
return
mdb_cursor_set
(
&
mc
key
data
MDB_SET
&
exact
)
;
}
static
int
mdb_cursor_sibling
(
MDB_cursor
*
mc
int
move_right
)
{
int
rc
;
MDB_node
*
indx
;
MDB_page
*
mp
;
if
(
mc
-
>
mc_snum
<
2
)
{
return
MDB_NOTFOUND
;
}
mdb_cursor_pop
(
mc
)
;
DPRINTF
(
(
"
parent
page
is
page
%
"
Z
"
u
index
%
u
"
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
-
>
mp_pgno
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
if
(
move_right
?
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
+
1u
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
:
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
=
0
)
)
{
DPRINTF
(
(
"
no
more
keys
left
moving
to
%
s
sibling
"
move_right
?
"
right
"
:
"
left
"
)
)
;
if
(
(
rc
=
mdb_cursor_sibling
(
mc
move_right
)
)
!
=
MDB_SUCCESS
)
{
mc
-
>
mc_top
+
+
;
mc
-
>
mc_snum
+
+
;
return
rc
;
}
}
else
{
if
(
move_right
)
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
+
+
;
else
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
-
-
;
DPRINTF
(
(
"
just
moving
to
%
s
index
key
%
u
"
move_right
?
"
right
"
:
"
left
"
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
}
mdb_cassert
(
mc
IS_BRANCH
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
;
indx
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
(
rc
=
mdb_page_get
(
mc
NODEPGNO
(
indx
)
&
mp
NULL
)
)
!
=
0
)
{
mc
-
>
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
return
rc
;
}
mdb_cursor_push
(
mc
mp
)
;
if
(
!
move_right
)
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
NUMKEYS
(
mp
)
-
1
;
return
MDB_SUCCESS
;
}
static
int
mdb_cursor_next
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
)
{
MDB_page
*
mp
;
MDB_node
*
leaf
;
int
rc
;
if
(
(
mc
-
>
mc_flags
&
C_DEL
&
&
op
=
=
MDB_NEXT_DUP
)
)
return
MDB_NOTFOUND
;
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
return
mdb_cursor_first
(
mc
key
data
)
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
if
(
mc
-
>
mc_flags
&
C_EOF
)
{
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
NUMKEYS
(
mp
)
-
1
)
return
MDB_NOTFOUND
;
mc
-
>
mc_flags
^
=
C_EOF
;
}
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
{
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
if
(
op
=
=
MDB_NEXT
|
|
op
=
=
MDB_NEXT_DUP
)
{
rc
=
mdb_cursor_next
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
MDB_NEXT
)
;
if
(
op
!
=
MDB_NEXT
|
|
rc
!
=
MDB_NOTFOUND
)
{
if
(
rc
=
=
MDB_SUCCESS
)
MDB_GET_KEY
(
leaf
key
)
;
return
rc
;
}
}
}
else
{
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
op
=
=
MDB_NEXT_DUP
)
return
MDB_NOTFOUND
;
}
}
DPRINTF
(
(
"
cursor_next
:
top
page
is
%
"
Z
"
u
in
cursor
%
p
"
mdb_dbg_pgno
(
mp
)
(
void
*
)
mc
)
)
;
if
(
mc
-
>
mc_flags
&
C_DEL
)
{
mc
-
>
mc_flags
^
=
C_DEL
;
goto
skip
;
}
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
+
1u
>
=
NUMKEYS
(
mp
)
)
{
DPUTS
(
"
=
=
=
=
=
>
move
to
next
sibling
page
"
)
;
if
(
(
rc
=
mdb_cursor_sibling
(
mc
1
)
)
!
=
MDB_SUCCESS
)
{
mc
-
>
mc_flags
|
=
C_EOF
;
return
rc
;
}
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
DPRINTF
(
(
"
next
page
is
%
"
Z
"
u
key
index
%
u
"
mp
-
>
mp_pgno
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
}
else
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
+
+
;
skip
:
DPRINTF
(
(
"
=
=
>
cursor
points
to
page
%
"
Z
"
u
with
%
u
keys
key
index
%
u
"
mdb_dbg_pgno
(
mp
)
NUMKEYS
(
mp
)
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
if
(
IS_LEAF2
(
mp
)
)
{
key
-
>
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
key
-
>
mv_data
=
LEAF2KEY
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
key
-
>
mv_size
)
;
return
MDB_SUCCESS
;
}
mdb_cassert
(
mc
IS_LEAF
(
mp
)
)
;
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
mdb_xcursor_init1
(
mc
leaf
)
;
}
if
(
data
)
{
if
(
(
rc
=
mdb_node_read
(
mc
leaf
data
)
)
!
=
MDB_SUCCESS
)
return
rc
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
rc
=
mdb_cursor_first
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
}
}
MDB_GET_KEY
(
leaf
key
)
;
return
MDB_SUCCESS
;
}
static
int
mdb_cursor_prev
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
)
{
MDB_page
*
mp
;
MDB_node
*
leaf
;
int
rc
;
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
{
rc
=
mdb_cursor_last
(
mc
key
data
)
;
if
(
rc
)
return
rc
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
+
+
;
}
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
{
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
if
(
op
=
=
MDB_PREV
|
|
op
=
=
MDB_PREV_DUP
)
{
rc
=
mdb_cursor_prev
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
MDB_PREV
)
;
if
(
op
!
=
MDB_PREV
|
|
rc
!
=
MDB_NOTFOUND
)
{
if
(
rc
=
=
MDB_SUCCESS
)
{
MDB_GET_KEY
(
leaf
key
)
;
mc
-
>
mc_flags
&
=
~
C_EOF
;
}
return
rc
;
}
}
}
else
{
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
op
=
=
MDB_PREV_DUP
)
return
MDB_NOTFOUND
;
}
}
DPRINTF
(
(
"
cursor_prev
:
top
page
is
%
"
Z
"
u
in
cursor
%
p
"
mdb_dbg_pgno
(
mp
)
(
void
*
)
mc
)
)
;
mc
-
>
mc_flags
&
=
~
(
C_EOF
|
C_DEL
)
;
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
=
0
)
{
DPUTS
(
"
=
=
=
=
=
>
move
to
prev
sibling
page
"
)
;
if
(
(
rc
=
mdb_cursor_sibling
(
mc
0
)
)
!
=
MDB_SUCCESS
)
{
return
rc
;
}
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
NUMKEYS
(
mp
)
-
1
;
DPRINTF
(
(
"
prev
page
is
%
"
Z
"
u
key
index
%
u
"
mp
-
>
mp_pgno
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
}
else
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
-
-
;
DPRINTF
(
(
"
=
=
>
cursor
points
to
page
%
"
Z
"
u
with
%
u
keys
key
index
%
u
"
mdb_dbg_pgno
(
mp
)
NUMKEYS
(
mp
)
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
if
(
IS_LEAF2
(
mp
)
)
{
key
-
>
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
key
-
>
mv_data
=
LEAF2KEY
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
key
-
>
mv_size
)
;
return
MDB_SUCCESS
;
}
mdb_cassert
(
mc
IS_LEAF
(
mp
)
)
;
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
mdb_xcursor_init1
(
mc
leaf
)
;
}
if
(
data
)
{
if
(
(
rc
=
mdb_node_read
(
mc
leaf
data
)
)
!
=
MDB_SUCCESS
)
return
rc
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
rc
=
mdb_cursor_last
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
}
}
MDB_GET_KEY
(
leaf
key
)
;
return
MDB_SUCCESS
;
}
static
int
mdb_cursor_set
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
int
*
exactp
)
{
int
rc
;
MDB_page
*
mp
;
MDB_node
*
leaf
=
NULL
;
DKBUF
;
if
(
key
-
>
mv_size
=
=
0
)
return
MDB_BAD_VALSIZE
;
if
(
mc
-
>
mc_xcursor
)
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
{
MDB_val
nodekey
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
if
(
!
NUMKEYS
(
mp
)
)
{
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
return
MDB_NOTFOUND
;
}
if
(
mp
-
>
mp_flags
&
P_LEAF2
)
{
nodekey
.
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
nodekey
.
mv_data
=
LEAF2KEY
(
mp
0
nodekey
.
mv_size
)
;
}
else
{
leaf
=
NODEPTR
(
mp
0
)
;
MDB_GET_KEY2
(
leaf
nodekey
)
;
}
rc
=
mc
-
>
mc_dbx
-
>
md_cmp
(
key
&
nodekey
)
;
if
(
rc
=
=
0
)
{
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
if
(
exactp
)
*
exactp
=
1
;
goto
set1
;
}
if
(
rc
>
0
)
{
unsigned
int
i
;
unsigned
int
nkeys
=
NUMKEYS
(
mp
)
;
if
(
nkeys
>
1
)
{
if
(
mp
-
>
mp_flags
&
P_LEAF2
)
{
nodekey
.
mv_data
=
LEAF2KEY
(
mp
nkeys
-
1
nodekey
.
mv_size
)
;
}
else
{
leaf
=
NODEPTR
(
mp
nkeys
-
1
)
;
MDB_GET_KEY2
(
leaf
nodekey
)
;
}
rc
=
mc
-
>
mc_dbx
-
>
md_cmp
(
key
&
nodekey
)
;
if
(
rc
=
=
0
)
{
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
nkeys
-
1
;
if
(
exactp
)
*
exactp
=
1
;
goto
set1
;
}
if
(
rc
<
0
)
{
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
<
NUMKEYS
(
mp
)
)
{
if
(
mp
-
>
mp_flags
&
P_LEAF2
)
{
nodekey
.
mv_data
=
LEAF2KEY
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
nodekey
.
mv_size
)
;
}
else
{
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
MDB_GET_KEY2
(
leaf
nodekey
)
;
}
rc
=
mc
-
>
mc_dbx
-
>
md_cmp
(
key
&
nodekey
)
;
if
(
rc
=
=
0
)
{
if
(
exactp
)
*
exactp
=
1
;
goto
set1
;
}
}
rc
=
0
;
mc
-
>
mc_flags
&
=
~
C_EOF
;
goto
set2
;
}
}
for
(
i
=
0
;
i
<
mc
-
>
mc_top
;
i
+
+
)
if
(
mc
-
>
mc_ki
[
i
]
<
NUMKEYS
(
mc
-
>
mc_pg
[
i
]
)
-
1
)
break
;
if
(
i
=
=
mc
-
>
mc_top
)
{
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
nkeys
;
return
MDB_NOTFOUND
;
}
}
if
(
!
mc
-
>
mc_top
)
{
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
if
(
op
=
=
MDB_SET_RANGE
&
&
!
exactp
)
{
rc
=
0
;
goto
set1
;
}
else
return
MDB_NOTFOUND
;
}
}
else
{
mc
-
>
mc_pg
[
0
]
=
0
;
}
rc
=
mdb_page_search
(
mc
key
0
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
mdb_cassert
(
mc
IS_LEAF
(
mp
)
)
;
set2
:
leaf
=
mdb_node_search
(
mc
key
exactp
)
;
if
(
exactp
!
=
NULL
&
&
!
*
exactp
)
{
return
MDB_NOTFOUND
;
}
if
(
leaf
=
=
NULL
)
{
DPUTS
(
"
=
=
=
>
inexact
leaf
not
found
goto
sibling
"
)
;
if
(
(
rc
=
mdb_cursor_sibling
(
mc
1
)
)
!
=
MDB_SUCCESS
)
{
mc
-
>
mc_flags
|
=
C_EOF
;
return
rc
;
}
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
mdb_cassert
(
mc
IS_LEAF
(
mp
)
)
;
leaf
=
NODEPTR
(
mp
0
)
;
}
set1
:
mc
-
>
mc_flags
|
=
C_INITIALIZED
;
mc
-
>
mc_flags
&
=
~
C_EOF
;
if
(
IS_LEAF2
(
mp
)
)
{
if
(
op
=
=
MDB_SET_RANGE
|
|
op
=
=
MDB_SET_KEY
)
{
key
-
>
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
key
-
>
mv_data
=
LEAF2KEY
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
key
-
>
mv_size
)
;
}
return
MDB_SUCCESS
;
}
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
mdb_xcursor_init1
(
mc
leaf
)
;
}
if
(
data
)
{
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
if
(
op
=
=
MDB_SET
|
|
op
=
=
MDB_SET_KEY
|
|
op
=
=
MDB_SET_RANGE
)
{
rc
=
mdb_cursor_first
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
)
;
}
else
{
int
ex2
*
ex2p
;
if
(
op
=
=
MDB_GET_BOTH
)
{
ex2p
=
&
ex2
;
ex2
=
0
;
}
else
{
ex2p
=
NULL
;
}
rc
=
mdb_cursor_set
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
MDB_SET_RANGE
ex2p
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
}
}
else
if
(
op
=
=
MDB_GET_BOTH
|
|
op
=
=
MDB_GET_BOTH_RANGE
)
{
MDB_val
olddata
;
MDB_cmp_func
*
dcmp
;
if
(
(
rc
=
mdb_node_read
(
mc
leaf
&
olddata
)
)
!
=
MDB_SUCCESS
)
return
rc
;
dcmp
=
mc
-
>
mc_dbx
-
>
md_dcmp
;
#
if
UINT_MAX
<
SIZE_MAX
if
(
dcmp
=
=
mdb_cmp_int
&
&
olddata
.
mv_size
=
=
sizeof
(
size_t
)
)
dcmp
=
mdb_cmp_clong
;
#
endif
rc
=
dcmp
(
data
&
olddata
)
;
if
(
rc
)
{
if
(
op
=
=
MDB_GET_BOTH
|
|
rc
>
0
)
return
MDB_NOTFOUND
;
rc
=
0
;
}
*
data
=
olddata
;
}
else
{
if
(
mc
-
>
mc_xcursor
)
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
(
rc
=
mdb_node_read
(
mc
leaf
data
)
)
!
=
MDB_SUCCESS
)
return
rc
;
}
}
if
(
op
=
=
MDB_SET_RANGE
|
|
op
=
=
MDB_SET_KEY
)
MDB_GET_KEY
(
leaf
key
)
;
DPRINTF
(
(
"
=
=
>
cursor
placed
on
key
[
%
s
]
"
DKEY
(
key
)
)
)
;
return
rc
;
}
static
int
mdb_cursor_first
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
)
{
int
rc
;
MDB_node
*
leaf
;
if
(
mc
-
>
mc_xcursor
)
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
|
|
mc
-
>
mc_top
)
{
rc
=
mdb_page_search
(
mc
NULL
MDB_PS_FIRST
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
}
mdb_cassert
(
mc
IS_LEAF
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
;
leaf
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
0
)
;
mc
-
>
mc_flags
|
=
C_INITIALIZED
;
mc
-
>
mc_flags
&
=
~
C_EOF
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
if
(
IS_LEAF2
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
{
key
-
>
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
key
-
>
mv_data
=
LEAF2KEY
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
0
key
-
>
mv_size
)
;
return
MDB_SUCCESS
;
}
if
(
data
)
{
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
mdb_xcursor_init1
(
mc
leaf
)
;
rc
=
mdb_cursor_first
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
)
;
if
(
rc
)
return
rc
;
}
else
{
if
(
(
rc
=
mdb_node_read
(
mc
leaf
data
)
)
!
=
MDB_SUCCESS
)
return
rc
;
}
}
MDB_GET_KEY
(
leaf
key
)
;
return
MDB_SUCCESS
;
}
static
int
mdb_cursor_last
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
)
{
int
rc
;
MDB_node
*
leaf
;
if
(
mc
-
>
mc_xcursor
)
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
|
|
mc
-
>
mc_top
)
{
rc
=
mdb_page_search
(
mc
NULL
MDB_PS_LAST
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
}
mdb_cassert
(
mc
IS_LEAF
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
-
1
;
mc
-
>
mc_flags
|
=
C_INITIALIZED
|
C_EOF
;
leaf
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
IS_LEAF2
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
{
key
-
>
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
key
-
>
mv_data
=
LEAF2KEY
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
key
-
>
mv_size
)
;
return
MDB_SUCCESS
;
}
if
(
data
)
{
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
mdb_xcursor_init1
(
mc
leaf
)
;
rc
=
mdb_cursor_last
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
)
;
if
(
rc
)
return
rc
;
}
else
{
if
(
(
rc
=
mdb_node_read
(
mc
leaf
data
)
)
!
=
MDB_SUCCESS
)
return
rc
;
}
}
MDB_GET_KEY
(
leaf
key
)
;
return
MDB_SUCCESS
;
}
int
mdb_cursor_get
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
MDB_cursor_op
op
)
{
int
rc
;
int
exact
=
0
;
int
(
*
mfunc
)
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
)
;
if
(
mc
=
=
NULL
)
return
EINVAL
;
if
(
mc
-
>
mc_txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
switch
(
op
)
{
case
MDB_GET_CURRENT
:
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
{
rc
=
EINVAL
;
}
else
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
int
nkeys
=
NUMKEYS
(
mp
)
;
if
(
!
nkeys
|
|
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
nkeys
)
{
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
nkeys
;
rc
=
MDB_NOTFOUND
;
break
;
}
rc
=
MDB_SUCCESS
;
if
(
IS_LEAF2
(
mp
)
)
{
key
-
>
mv_size
=
mc
-
>
mc_db
-
>
md_pad
;
key
-
>
mv_data
=
LEAF2KEY
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
key
-
>
mv_size
)
;
}
else
{
MDB_node
*
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
MDB_GET_KEY
(
leaf
key
)
;
if
(
data
)
{
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
rc
=
mdb_cursor_get
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
MDB_GET_CURRENT
)
;
}
else
{
rc
=
mdb_node_read
(
mc
leaf
data
)
;
}
}
}
}
break
;
case
MDB_GET_BOTH
:
case
MDB_GET_BOTH_RANGE
:
if
(
data
=
=
NULL
)
{
rc
=
EINVAL
;
break
;
}
if
(
mc
-
>
mc_xcursor
=
=
NULL
)
{
rc
=
MDB_INCOMPATIBLE
;
break
;
}
case
MDB_SET
:
case
MDB_SET_KEY
:
case
MDB_SET_RANGE
:
if
(
key
=
=
NULL
)
{
rc
=
EINVAL
;
}
else
{
rc
=
mdb_cursor_set
(
mc
key
data
op
op
=
=
MDB_SET_RANGE
?
NULL
:
&
exact
)
;
}
break
;
case
MDB_GET_MULTIPLE
:
if
(
data
=
=
NULL
|
|
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
{
rc
=
EINVAL
;
break
;
}
if
(
!
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
)
{
rc
=
MDB_INCOMPATIBLE
;
break
;
}
rc
=
MDB_SUCCESS
;
if
(
!
(
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
|
|
(
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_EOF
)
)
break
;
goto
fetchm
;
case
MDB_NEXT_MULTIPLE
:
if
(
data
=
=
NULL
)
{
rc
=
EINVAL
;
break
;
}
if
(
!
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
)
{
rc
=
MDB_INCOMPATIBLE
;
break
;
}
rc
=
mdb_cursor_next
(
mc
key
data
MDB_NEXT_DUP
)
;
if
(
rc
=
=
MDB_SUCCESS
)
{
if
(
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
{
MDB_cursor
*
mx
;
fetchm
:
mx
=
&
mc
-
>
mc_xcursor
-
>
mx_cursor
;
data
-
>
mv_size
=
NUMKEYS
(
mx
-
>
mc_pg
[
mx
-
>
mc_top
]
)
*
mx
-
>
mc_db
-
>
md_pad
;
data
-
>
mv_data
=
METADATA
(
mx
-
>
mc_pg
[
mx
-
>
mc_top
]
)
;
mx
-
>
mc_ki
[
mx
-
>
mc_top
]
=
NUMKEYS
(
mx
-
>
mc_pg
[
mx
-
>
mc_top
]
)
-
1
;
}
else
{
rc
=
MDB_NOTFOUND
;
}
}
break
;
case
MDB_PREV_MULTIPLE
:
if
(
data
=
=
NULL
)
{
rc
=
EINVAL
;
break
;
}
if
(
!
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
)
{
rc
=
MDB_INCOMPATIBLE
;
break
;
}
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
rc
=
mdb_cursor_last
(
mc
key
data
)
;
else
rc
=
MDB_SUCCESS
;
if
(
rc
=
=
MDB_SUCCESS
)
{
MDB_cursor
*
mx
=
&
mc
-
>
mc_xcursor
-
>
mx_cursor
;
if
(
mx
-
>
mc_flags
&
C_INITIALIZED
)
{
rc
=
mdb_cursor_sibling
(
mx
0
)
;
if
(
rc
=
=
MDB_SUCCESS
)
goto
fetchm
;
}
else
{
rc
=
MDB_NOTFOUND
;
}
}
break
;
case
MDB_NEXT
:
case
MDB_NEXT_DUP
:
case
MDB_NEXT_NODUP
:
rc
=
mdb_cursor_next
(
mc
key
data
op
)
;
break
;
case
MDB_PREV
:
case
MDB_PREV_DUP
:
case
MDB_PREV_NODUP
:
rc
=
mdb_cursor_prev
(
mc
key
data
op
)
;
break
;
case
MDB_FIRST
:
rc
=
mdb_cursor_first
(
mc
key
data
)
;
break
;
case
MDB_FIRST_DUP
:
mfunc
=
mdb_cursor_first
;
mmove
:
if
(
data
=
=
NULL
|
|
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
{
rc
=
EINVAL
;
break
;
}
if
(
mc
-
>
mc_xcursor
=
=
NULL
)
{
rc
=
MDB_INCOMPATIBLE
;
break
;
}
{
MDB_node
*
leaf
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
!
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
MDB_GET_KEY
(
leaf
key
)
;
rc
=
mdb_node_read
(
mc
leaf
data
)
;
break
;
}
}
if
(
!
(
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
)
{
rc
=
EINVAL
;
break
;
}
rc
=
mfunc
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
NULL
)
;
break
;
case
MDB_LAST
:
rc
=
mdb_cursor_last
(
mc
key
data
)
;
break
;
case
MDB_LAST_DUP
:
mfunc
=
mdb_cursor_last
;
goto
mmove
;
default
:
DPRINTF
(
(
"
unhandled
/
unimplemented
cursor
operation
%
u
"
op
)
)
;
rc
=
EINVAL
;
break
;
}
if
(
mc
-
>
mc_flags
&
C_DEL
)
mc
-
>
mc_flags
^
=
C_DEL
;
return
rc
;
}
static
int
mdb_cursor_touch
(
MDB_cursor
*
mc
)
{
int
rc
=
MDB_SUCCESS
;
if
(
mc
-
>
mc_dbi
>
=
CORE_DBS
&
&
!
(
*
mc
-
>
mc_dbflag
&
(
DB_DIRTY
|
DB_DUPDATA
)
)
)
{
MDB_cursor
mc2
;
MDB_xcursor
mcx
;
if
(
TXN_DBI_CHANGED
(
mc
-
>
mc_txn
mc
-
>
mc_dbi
)
)
return
MDB_BAD_DBI
;
mdb_cursor_init
(
&
mc2
mc
-
>
mc_txn
MAIN_DBI
&
mcx
)
;
rc
=
mdb_page_search
(
&
mc2
&
mc
-
>
mc_dbx
-
>
md_name
MDB_PS_MODIFY
)
;
if
(
rc
)
return
rc
;
*
mc
-
>
mc_dbflag
|
=
DB_DIRTY
;
}
mc
-
>
mc_top
=
0
;
if
(
mc
-
>
mc_snum
)
{
do
{
rc
=
mdb_page_touch
(
mc
)
;
}
while
(
!
rc
&
&
+
+
(
mc
-
>
mc_top
)
<
mc
-
>
mc_snum
)
;
mc
-
>
mc_top
=
mc
-
>
mc_snum
-
1
;
}
return
rc
;
}
#
define
MDB_NOSPILL
0x8000
int
mdb_cursor_put
(
MDB_cursor
*
mc
MDB_val
*
key
MDB_val
*
data
unsigned
int
flags
)
{
MDB_env
*
env
;
MDB_node
*
leaf
=
NULL
;
MDB_page
*
fp
*
mp
*
sub_root
=
NULL
;
uint16_t
fp_flags
;
MDB_val
xdata
*
rdata
dkey
olddata
;
MDB_db
dummy
;
int
do_sub
=
0
insert_key
insert_data
;
unsigned
int
mcount
=
0
dcount
=
0
nospill
;
size_t
nsize
;
int
rc
rc2
;
unsigned
int
nflags
;
DKBUF
;
if
(
mc
=
=
NULL
|
|
key
=
=
NULL
)
return
EINVAL
;
env
=
mc
-
>
mc_txn
-
>
mt_env
;
if
(
flags
&
MDB_MULTIPLE
)
{
dcount
=
data
[
1
]
.
mv_size
;
data
[
1
]
.
mv_size
=
0
;
if
(
!
F_ISSET
(
mc
-
>
mc_db
-
>
md_flags
MDB_DUPFIXED
)
)
return
MDB_INCOMPATIBLE
;
}
nospill
=
flags
&
MDB_NOSPILL
;
flags
&
=
~
MDB_NOSPILL
;
if
(
mc
-
>
mc_txn
-
>
mt_flags
&
(
MDB_TXN_RDONLY
|
MDB_TXN_BLOCKED
)
)
return
(
mc
-
>
mc_txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
EACCES
:
MDB_BAD_TXN
;
if
(
key
-
>
mv_size
-
1
>
=
ENV_MAXKEY
(
env
)
)
return
MDB_BAD_VALSIZE
;
#
if
SIZE_MAX
>
MAXDATASIZE
if
(
data
-
>
mv_size
>
(
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
?
ENV_MAXKEY
(
env
)
:
MAXDATASIZE
)
)
return
MDB_BAD_VALSIZE
;
#
else
if
(
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
&
&
data
-
>
mv_size
>
ENV_MAXKEY
(
env
)
)
return
MDB_BAD_VALSIZE
;
#
endif
DPRINTF
(
(
"
=
=
>
put
db
%
d
key
[
%
s
]
size
%
"
Z
"
u
data
size
%
"
Z
"
u
"
DDBI
(
mc
)
DKEY
(
key
)
key
?
key
-
>
mv_size
:
0
data
-
>
mv_size
)
)
;
dkey
.
mv_size
=
0
;
if
(
flags
=
=
MDB_CURRENT
)
{
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
return
EINVAL
;
rc
=
MDB_SUCCESS
;
}
else
if
(
mc
-
>
mc_db
-
>
md_root
=
=
P_INVALID
)
{
mc
-
>
mc_snum
=
0
;
mc
-
>
mc_top
=
0
;
mc
-
>
mc_flags
&
=
~
C_INITIALIZED
;
rc
=
MDB_NO_ROOT
;
}
else
{
int
exact
=
0
;
MDB_val
d2
;
if
(
flags
&
MDB_APPEND
)
{
MDB_val
k2
;
rc
=
mdb_cursor_last
(
mc
&
k2
&
d2
)
;
if
(
rc
=
=
0
)
{
rc
=
mc
-
>
mc_dbx
-
>
md_cmp
(
key
&
k2
)
;
if
(
rc
>
0
)
{
rc
=
MDB_NOTFOUND
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
+
+
;
}
else
{
rc
=
MDB_KEYEXIST
;
}
}
}
else
{
rc
=
mdb_cursor_set
(
mc
key
&
d2
MDB_SET
&
exact
)
;
}
if
(
(
flags
&
MDB_NOOVERWRITE
)
&
&
rc
=
=
0
)
{
DPRINTF
(
(
"
duplicate
key
[
%
s
]
"
DKEY
(
key
)
)
)
;
*
data
=
d2
;
return
MDB_KEYEXIST
;
}
if
(
rc
&
&
rc
!
=
MDB_NOTFOUND
)
return
rc
;
}
if
(
mc
-
>
mc_flags
&
C_DEL
)
mc
-
>
mc_flags
^
=
C_DEL
;
if
(
!
nospill
)
{
if
(
flags
&
MDB_MULTIPLE
)
{
rdata
=
&
xdata
;
xdata
.
mv_size
=
data
-
>
mv_size
*
dcount
;
}
else
{
rdata
=
data
;
}
if
(
(
rc2
=
mdb_page_spill
(
mc
key
rdata
)
)
)
return
rc2
;
}
if
(
rc
=
=
MDB_NO_ROOT
)
{
MDB_page
*
np
;
DPUTS
(
"
allocating
new
root
leaf
page
"
)
;
if
(
(
rc2
=
mdb_page_new
(
mc
P_LEAF
1
&
np
)
)
)
{
return
rc2
;
}
mdb_cursor_push
(
mc
np
)
;
mc
-
>
mc_db
-
>
md_root
=
np
-
>
mp_pgno
;
mc
-
>
mc_db
-
>
md_depth
+
+
;
*
mc
-
>
mc_dbflag
|
=
DB_DIRTY
;
if
(
(
mc
-
>
mc_db
-
>
md_flags
&
(
MDB_DUPSORT
|
MDB_DUPFIXED
)
)
=
=
MDB_DUPFIXED
)
np
-
>
mp_flags
|
=
P_LEAF2
;
mc
-
>
mc_flags
|
=
C_INITIALIZED
;
}
else
{
rc2
=
mdb_cursor_touch
(
mc
)
;
if
(
rc2
)
return
rc2
;
}
insert_key
=
insert_data
=
rc
;
if
(
insert_key
)
{
DPRINTF
(
(
"
inserting
key
at
index
%
i
"
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
)
;
if
(
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
&
&
LEAFSIZE
(
key
data
)
>
env
-
>
me_nodemax
)
{
fp_flags
=
P_LEAF
|
P_DIRTY
;
fp
=
env
-
>
me_pbuf
;
fp
-
>
mp_pad
=
data
-
>
mv_size
;
fp
-
>
mp_lower
=
fp
-
>
mp_upper
=
(
PAGEHDRSZ
-
PAGEBASE
)
;
olddata
.
mv_size
=
PAGEHDRSZ
;
goto
prep_subDB
;
}
}
else
{
if
(
IS_LEAF2
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
{
char
*
ptr
;
unsigned
int
ksize
=
mc
-
>
mc_db
-
>
md_pad
;
if
(
key
-
>
mv_size
!
=
ksize
)
return
MDB_BAD_VALSIZE
;
ptr
=
LEAF2KEY
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
ksize
)
;
memcpy
(
ptr
key
-
>
mv_data
ksize
)
;
fix_parent
:
if
(
mc
-
>
mc_top
&
&
!
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
{
unsigned
short
dtop
=
1
;
mc
-
>
mc_top
-
-
;
while
(
mc
-
>
mc_top
&
&
!
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
{
mc
-
>
mc_top
-
-
;
dtop
+
+
;
}
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
rc2
=
mdb_update_key
(
mc
key
)
;
else
rc2
=
MDB_SUCCESS
;
mc
-
>
mc_top
+
=
dtop
;
if
(
rc2
)
return
rc2
;
}
return
MDB_SUCCESS
;
}
more
:
leaf
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
olddata
.
mv_size
=
NODEDSZ
(
leaf
)
;
olddata
.
mv_data
=
NODEDATA
(
leaf
)
;
if
(
F_ISSET
(
mc
-
>
mc_db
-
>
md_flags
MDB_DUPSORT
)
)
{
unsigned
i
offset
=
0
;
mp
=
fp
=
xdata
.
mv_data
=
env
-
>
me_pbuf
;
mp
-
>
mp_pgno
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
-
>
mp_pgno
;
if
(
!
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
MDB_cmp_func
*
dcmp
;
if
(
flags
=
=
MDB_CURRENT
)
goto
current
;
dcmp
=
mc
-
>
mc_dbx
-
>
md_dcmp
;
#
if
UINT_MAX
<
SIZE_MAX
if
(
dcmp
=
=
mdb_cmp_int
&
&
olddata
.
mv_size
=
=
sizeof
(
size_t
)
)
dcmp
=
mdb_cmp_clong
;
#
endif
if
(
!
dcmp
(
data
&
olddata
)
)
{
if
(
flags
&
(
MDB_NODUPDATA
|
MDB_APPENDDUP
)
)
return
MDB_KEYEXIST
;
goto
current
;
}
dkey
.
mv_size
=
olddata
.
mv_size
;
dkey
.
mv_data
=
memcpy
(
fp
+
1
olddata
.
mv_data
olddata
.
mv_size
)
;
fp
-
>
mp_flags
=
P_LEAF
|
P_DIRTY
|
P_SUBP
;
fp
-
>
mp_lower
=
(
PAGEHDRSZ
-
PAGEBASE
)
;
xdata
.
mv_size
=
PAGEHDRSZ
+
dkey
.
mv_size
+
data
-
>
mv_size
;
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
{
fp
-
>
mp_flags
|
=
P_LEAF2
;
fp
-
>
mp_pad
=
data
-
>
mv_size
;
xdata
.
mv_size
+
=
2
*
data
-
>
mv_size
;
}
else
{
xdata
.
mv_size
+
=
2
*
(
sizeof
(
indx_t
)
+
NODESIZE
)
+
(
dkey
.
mv_size
&
1
)
+
(
data
-
>
mv_size
&
1
)
;
}
fp
-
>
mp_upper
=
xdata
.
mv_size
-
PAGEBASE
;
olddata
.
mv_size
=
xdata
.
mv_size
;
}
else
if
(
leaf
-
>
mn_flags
&
F_SUBDATA
)
{
flags
|
=
F_DUPDATA
|
F_SUBDATA
;
goto
put_sub
;
}
else
{
fp
=
olddata
.
mv_data
;
switch
(
flags
)
{
default
:
if
(
!
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
)
{
offset
=
EVEN
(
NODESIZE
+
sizeof
(
indx_t
)
+
data
-
>
mv_size
)
;
break
;
}
offset
=
fp
-
>
mp_pad
;
if
(
SIZELEFT
(
fp
)
<
offset
)
{
offset
*
=
4
;
break
;
}
case
MDB_CURRENT
:
fp
-
>
mp_flags
|
=
P_DIRTY
;
COPY_PGNO
(
fp
-
>
mp_pgno
mp
-
>
mp_pgno
)
;
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
fp
;
flags
|
=
F_DUPDATA
;
goto
put_sub
;
}
xdata
.
mv_size
=
olddata
.
mv_size
+
offset
;
}
fp_flags
=
fp
-
>
mp_flags
;
if
(
NODESIZE
+
NODEKSZ
(
leaf
)
+
xdata
.
mv_size
>
env
-
>
me_nodemax
)
{
fp_flags
&
=
~
P_SUBP
;
prep_subDB
:
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
{
fp_flags
|
=
P_LEAF2
;
dummy
.
md_pad
=
fp
-
>
mp_pad
;
dummy
.
md_flags
=
MDB_DUPFIXED
;
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_INTEGERDUP
)
dummy
.
md_flags
|
=
MDB_INTEGERKEY
;
}
else
{
dummy
.
md_pad
=
0
;
dummy
.
md_flags
=
0
;
}
dummy
.
md_depth
=
1
;
dummy
.
md_branch_pages
=
0
;
dummy
.
md_leaf_pages
=
1
;
dummy
.
md_overflow_pages
=
0
;
dummy
.
md_entries
=
NUMKEYS
(
fp
)
;
xdata
.
mv_size
=
sizeof
(
MDB_db
)
;
xdata
.
mv_data
=
&
dummy
;
if
(
(
rc
=
mdb_page_alloc
(
mc
1
&
mp
)
)
)
return
rc
;
offset
=
env
-
>
me_psize
-
olddata
.
mv_size
;
flags
|
=
F_DUPDATA
|
F_SUBDATA
;
dummy
.
md_root
=
mp
-
>
mp_pgno
;
sub_root
=
mp
;
}
if
(
mp
!
=
fp
)
{
mp
-
>
mp_flags
=
fp_flags
|
P_DIRTY
;
mp
-
>
mp_pad
=
fp
-
>
mp_pad
;
mp
-
>
mp_lower
=
fp
-
>
mp_lower
;
mp
-
>
mp_upper
=
fp
-
>
mp_upper
+
offset
;
if
(
fp_flags
&
P_LEAF2
)
{
memcpy
(
METADATA
(
mp
)
METADATA
(
fp
)
NUMKEYS
(
fp
)
*
fp
-
>
mp_pad
)
;
}
else
{
memcpy
(
(
char
*
)
mp
+
mp
-
>
mp_upper
+
PAGEBASE
(
char
*
)
fp
+
fp
-
>
mp_upper
+
PAGEBASE
olddata
.
mv_size
-
fp
-
>
mp_upper
-
PAGEBASE
)
;
for
(
i
=
0
;
i
<
NUMKEYS
(
fp
)
;
i
+
+
)
mp
-
>
mp_ptrs
[
i
]
=
fp
-
>
mp_ptrs
[
i
]
+
offset
;
}
}
rdata
=
&
xdata
;
flags
|
=
F_DUPDATA
;
do_sub
=
1
;
if
(
!
insert_key
)
mdb_node_del
(
mc
0
)
;
goto
new_sub
;
}
current
:
if
(
(
leaf
-
>
mn_flags
^
flags
)
&
F_SUBDATA
)
return
MDB_INCOMPATIBLE
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_BIGDATA
)
)
{
MDB_page
*
omp
;
pgno_t
pg
;
int
level
ovpages
dpages
=
OVPAGES
(
data
-
>
mv_size
env
-
>
me_psize
)
;
memcpy
(
&
pg
olddata
.
mv_data
sizeof
(
pg
)
)
;
if
(
(
rc2
=
mdb_page_get
(
mc
pg
&
omp
&
level
)
)
!
=
0
)
return
rc2
;
ovpages
=
omp
-
>
mp_pages
;
if
(
ovpages
>
=
dpages
)
{
if
(
!
(
omp
-
>
mp_flags
&
P_DIRTY
)
&
&
(
level
|
|
(
env
-
>
me_flags
&
MDB_WRITEMAP
)
)
)
{
rc
=
mdb_page_unspill
(
mc
-
>
mc_txn
omp
&
omp
)
;
if
(
rc
)
return
rc
;
level
=
0
;
}
if
(
omp
-
>
mp_flags
&
P_DIRTY
)
{
if
(
level
>
1
)
{
size_t
sz
=
(
size_t
)
env
-
>
me_psize
*
ovpages
off
;
MDB_page
*
np
=
mdb_page_malloc
(
mc
-
>
mc_txn
ovpages
)
;
MDB_ID2
id2
;
if
(
!
np
)
return
ENOMEM
;
id2
.
mid
=
pg
;
id2
.
mptr
=
np
;
rc2
=
mdb_mid2l_insert
(
mc
-
>
mc_txn
-
>
mt_u
.
dirty_list
&
id2
)
;
mdb_cassert
(
mc
rc2
=
=
0
)
;
if
(
!
(
flags
&
MDB_RESERVE
)
)
{
off
=
(
PAGEHDRSZ
+
data
-
>
mv_size
)
&
-
sizeof
(
size_t
)
;
memcpy
(
(
size_t
*
)
(
(
char
*
)
np
+
off
)
(
size_t
*
)
(
(
char
*
)
omp
+
off
)
sz
-
off
)
;
sz
=
PAGEHDRSZ
;
}
memcpy
(
np
omp
sz
)
;
omp
=
np
;
}
SETDSZ
(
leaf
data
-
>
mv_size
)
;
if
(
F_ISSET
(
flags
MDB_RESERVE
)
)
data
-
>
mv_data
=
METADATA
(
omp
)
;
else
memcpy
(
METADATA
(
omp
)
data
-
>
mv_data
data
-
>
mv_size
)
;
return
MDB_SUCCESS
;
}
}
if
(
(
rc2
=
mdb_ovpage_free
(
mc
omp
)
)
!
=
MDB_SUCCESS
)
return
rc2
;
}
else
if
(
data
-
>
mv_size
=
=
olddata
.
mv_size
)
{
if
(
F_ISSET
(
flags
MDB_RESERVE
)
)
data
-
>
mv_data
=
olddata
.
mv_data
;
else
if
(
!
(
mc
-
>
mc_flags
&
C_SUB
)
)
memcpy
(
olddata
.
mv_data
data
-
>
mv_data
data
-
>
mv_size
)
;
else
{
memcpy
(
NODEKEY
(
leaf
)
key
-
>
mv_data
key
-
>
mv_size
)
;
goto
fix_parent
;
}
return
MDB_SUCCESS
;
}
mdb_node_del
(
mc
0
)
;
}
rdata
=
data
;
new_sub
:
nflags
=
flags
&
NODE_ADD_FLAGS
;
nsize
=
IS_LEAF2
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
?
key
-
>
mv_size
:
mdb_leaf_size
(
env
key
rdata
)
;
if
(
SIZELEFT
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
<
nsize
)
{
if
(
(
flags
&
(
F_DUPDATA
|
F_SUBDATA
)
)
=
=
F_DUPDATA
)
nflags
&
=
~
MDB_APPEND
;
if
(
!
insert_key
)
nflags
|
=
MDB_SPLIT_REPLACE
;
rc
=
mdb_page_split
(
mc
key
rdata
P_INVALID
nflags
)
;
}
else
{
rc
=
mdb_node_add
(
mc
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
key
rdata
0
nflags
)
;
if
(
rc
=
=
0
)
{
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
mc
-
>
mc_dbi
;
unsigned
i
=
mc
-
>
mc_top
;
MDB_page
*
mp
=
mc
-
>
mc_pg
[
i
]
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
mc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
m3
=
=
mc
|
|
m3
-
>
mc_snum
<
mc
-
>
mc_snum
|
|
m3
-
>
mc_pg
[
i
]
!
=
mp
)
continue
;
if
(
m3
-
>
mc_ki
[
i
]
>
=
mc
-
>
mc_ki
[
i
]
&
&
insert_key
)
{
m3
-
>
mc_ki
[
i
]
+
+
;
}
if
(
XCURSOR_INITED
(
m3
)
)
XCURSOR_REFRESH
(
m3
mp
m3
-
>
mc_ki
[
i
]
)
;
}
}
}
if
(
rc
=
=
MDB_SUCCESS
)
{
if
(
do_sub
)
{
int
xflags
new_dupdata
;
size_t
ecount
;
put_sub
:
xdata
.
mv_size
=
0
;
xdata
.
mv_data
=
"
"
;
leaf
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
flags
&
MDB_CURRENT
)
{
xflags
=
MDB_CURRENT
|
MDB_NOSPILL
;
}
else
{
mdb_xcursor_init1
(
mc
leaf
)
;
xflags
=
(
flags
&
MDB_NODUPDATA
)
?
MDB_NOOVERWRITE
|
MDB_NOSPILL
:
MDB_NOSPILL
;
}
if
(
sub_root
)
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
sub_root
;
new_dupdata
=
(
int
)
dkey
.
mv_size
;
if
(
dkey
.
mv_size
)
{
rc
=
mdb_cursor_put
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
&
dkey
&
xdata
xflags
)
;
if
(
rc
)
goto
bad_sub
;
dkey
.
mv_size
=
0
;
}
if
(
!
(
leaf
-
>
mn_flags
&
F_SUBDATA
)
|
|
sub_root
)
{
MDB_cursor
*
m2
;
MDB_xcursor
*
mx
=
mc
-
>
mc_xcursor
;
unsigned
i
=
mc
-
>
mc_top
;
MDB_page
*
mp
=
mc
-
>
mc_pg
[
i
]
;
int
nkeys
=
NUMKEYS
(
mp
)
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
mc
-
>
mc_dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
m2
=
=
mc
|
|
m2
-
>
mc_snum
<
mc
-
>
mc_snum
)
continue
;
if
(
!
(
m2
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
if
(
m2
-
>
mc_pg
[
i
]
=
=
mp
)
{
if
(
m2
-
>
mc_ki
[
i
]
=
=
mc
-
>
mc_ki
[
i
]
)
{
mdb_xcursor_init2
(
m2
mx
new_dupdata
)
;
}
else
if
(
!
insert_key
&
&
m2
-
>
mc_ki
[
i
]
<
nkeys
)
{
XCURSOR_REFRESH
(
m2
mp
m2
-
>
mc_ki
[
i
]
)
;
}
}
}
}
ecount
=
mc
-
>
mc_xcursor
-
>
mx_db
.
md_entries
;
if
(
flags
&
MDB_APPENDDUP
)
xflags
|
=
MDB_APPEND
;
rc
=
mdb_cursor_put
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
data
&
xdata
xflags
)
;
if
(
flags
&
F_SUBDATA
)
{
void
*
db
=
NODEDATA
(
leaf
)
;
memcpy
(
db
&
mc
-
>
mc_xcursor
-
>
mx_db
sizeof
(
MDB_db
)
)
;
}
insert_data
=
mc
-
>
mc_xcursor
-
>
mx_db
.
md_entries
-
ecount
;
}
if
(
insert_data
)
mc
-
>
mc_db
-
>
md_entries
+
+
;
if
(
insert_key
)
{
if
(
rc
)
goto
bad_sub
;
mc
-
>
mc_flags
|
=
C_INITIALIZED
;
}
if
(
flags
&
MDB_MULTIPLE
)
{
if
(
!
rc
)
{
mcount
+
+
;
data
[
1
]
.
mv_size
=
mcount
;
if
(
mcount
<
dcount
)
{
data
[
0
]
.
mv_data
=
(
char
*
)
data
[
0
]
.
mv_data
+
data
[
0
]
.
mv_size
;
insert_key
=
insert_data
=
0
;
goto
more
;
}
}
}
return
rc
;
bad_sub
:
if
(
rc
=
=
MDB_KEYEXIST
)
rc
=
MDB_CORRUPTED
;
}
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
rc
;
}
int
mdb_cursor_del
(
MDB_cursor
*
mc
unsigned
int
flags
)
{
MDB_node
*
leaf
;
MDB_page
*
mp
;
int
rc
;
if
(
mc
-
>
mc_txn
-
>
mt_flags
&
(
MDB_TXN_RDONLY
|
MDB_TXN_BLOCKED
)
)
return
(
mc
-
>
mc_txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
EACCES
:
MDB_BAD_TXN
;
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
return
EINVAL
;
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
return
MDB_NOTFOUND
;
if
(
!
(
flags
&
MDB_NOSPILL
)
&
&
(
rc
=
mdb_page_spill
(
mc
NULL
NULL
)
)
)
return
rc
;
rc
=
mdb_cursor_touch
(
mc
)
;
if
(
rc
)
return
rc
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
if
(
IS_LEAF2
(
mp
)
)
goto
del_key
;
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
if
(
flags
&
MDB_NODUPDATA
)
{
mc
-
>
mc_db
-
>
md_entries
-
=
mc
-
>
mc_xcursor
-
>
mx_db
.
md_entries
-
1
;
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
C_INITIALIZED
;
}
else
{
if
(
!
F_ISSET
(
leaf
-
>
mn_flags
F_SUBDATA
)
)
{
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
NODEDATA
(
leaf
)
;
}
rc
=
mdb_cursor_del
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
MDB_NOSPILL
)
;
if
(
rc
)
return
rc
;
if
(
mc
-
>
mc_xcursor
-
>
mx_db
.
md_entries
)
{
if
(
leaf
-
>
mn_flags
&
F_SUBDATA
)
{
void
*
db
=
NODEDATA
(
leaf
)
;
memcpy
(
db
&
mc
-
>
mc_xcursor
-
>
mx_db
sizeof
(
MDB_db
)
)
;
}
else
{
MDB_cursor
*
m2
;
mdb_node_shrink
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
leaf
=
NODEPTR
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
NODEDATA
(
leaf
)
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
mc
-
>
mc_dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
m2
=
=
mc
|
|
m2
-
>
mc_snum
<
mc
-
>
mc_snum
)
continue
;
if
(
!
(
m2
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
if
(
m2
-
>
mc_pg
[
mc
-
>
mc_top
]
=
=
mp
)
{
MDB_node
*
n2
=
leaf
;
if
(
m2
-
>
mc_ki
[
mc
-
>
mc_top
]
!
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
{
n2
=
NODEPTR
(
mp
m2
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
n2
-
>
mn_flags
&
F_SUBDATA
)
continue
;
}
m2
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
NODEDATA
(
n2
)
;
}
}
}
mc
-
>
mc_db
-
>
md_entries
-
-
;
return
rc
;
}
else
{
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
C_INITIALIZED
;
}
}
if
(
leaf
-
>
mn_flags
&
F_SUBDATA
)
{
rc
=
mdb_drop0
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
0
)
;
if
(
rc
)
goto
fail
;
}
}
else
if
(
(
leaf
-
>
mn_flags
^
flags
)
&
F_SUBDATA
)
{
rc
=
MDB_INCOMPATIBLE
;
goto
fail
;
}
if
(
F_ISSET
(
leaf
-
>
mn_flags
F_BIGDATA
)
)
{
MDB_page
*
omp
;
pgno_t
pg
;
memcpy
(
&
pg
NODEDATA
(
leaf
)
sizeof
(
pg
)
)
;
if
(
(
rc
=
mdb_page_get
(
mc
pg
&
omp
NULL
)
)
|
|
(
rc
=
mdb_ovpage_free
(
mc
omp
)
)
)
goto
fail
;
}
del_key
:
return
mdb_cursor_del0
(
mc
)
;
fail
:
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
rc
;
}
static
int
mdb_page_new
(
MDB_cursor
*
mc
uint32_t
flags
int
num
MDB_page
*
*
mp
)
{
MDB_page
*
np
;
int
rc
;
if
(
(
rc
=
mdb_page_alloc
(
mc
num
&
np
)
)
)
return
rc
;
DPRINTF
(
(
"
allocated
new
mpage
%
"
Z
"
u
page
size
%
u
"
np
-
>
mp_pgno
mc
-
>
mc_txn
-
>
mt_env
-
>
me_psize
)
)
;
np
-
>
mp_flags
=
flags
|
P_DIRTY
;
np
-
>
mp_lower
=
(
PAGEHDRSZ
-
PAGEBASE
)
;
np
-
>
mp_upper
=
mc
-
>
mc_txn
-
>
mt_env
-
>
me_psize
-
PAGEBASE
;
if
(
IS_BRANCH
(
np
)
)
mc
-
>
mc_db
-
>
md_branch_pages
+
+
;
else
if
(
IS_LEAF
(
np
)
)
mc
-
>
mc_db
-
>
md_leaf_pages
+
+
;
else
if
(
IS_OVERFLOW
(
np
)
)
{
mc
-
>
mc_db
-
>
md_overflow_pages
+
=
num
;
np
-
>
mp_pages
=
num
;
}
*
mp
=
np
;
return
0
;
}
static
size_t
mdb_leaf_size
(
MDB_env
*
env
MDB_val
*
key
MDB_val
*
data
)
{
size_t
sz
;
sz
=
LEAFSIZE
(
key
data
)
;
if
(
sz
>
env
-
>
me_nodemax
)
{
sz
-
=
data
-
>
mv_size
-
sizeof
(
pgno_t
)
;
}
return
EVEN
(
sz
+
sizeof
(
indx_t
)
)
;
}
static
size_t
mdb_branch_size
(
MDB_env
*
env
MDB_val
*
key
)
{
size_t
sz
;
sz
=
INDXSIZE
(
key
)
;
if
(
sz
>
env
-
>
me_nodemax
)
{
}
return
sz
+
sizeof
(
indx_t
)
;
}
static
int
mdb_node_add
(
MDB_cursor
*
mc
indx_t
indx
MDB_val
*
key
MDB_val
*
data
pgno_t
pgno
unsigned
int
flags
)
{
unsigned
int
i
;
size_t
node_size
=
NODESIZE
;
ssize_t
room
;
indx_t
ofs
;
MDB_node
*
node
;
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
MDB_page
*
ofp
=
NULL
;
void
*
ndata
;
DKBUF
;
mdb_cassert
(
mc
mp
-
>
mp_upper
>
=
mp
-
>
mp_lower
)
;
DPRINTF
(
(
"
add
to
%
s
%
spage
%
"
Z
"
u
index
%
i
data
size
%
"
Z
"
u
key
size
%
"
Z
"
u
[
%
s
]
"
IS_LEAF
(
mp
)
?
"
leaf
"
:
"
branch
"
IS_SUBP
(
mp
)
?
"
sub
-
"
:
"
"
mdb_dbg_pgno
(
mp
)
indx
data
?
data
-
>
mv_size
:
0
key
?
key
-
>
mv_size
:
0
key
?
DKEY
(
key
)
:
"
null
"
)
)
;
if
(
IS_LEAF2
(
mp
)
)
{
int
ksize
=
mc
-
>
mc_db
-
>
md_pad
dif
;
char
*
ptr
=
LEAF2KEY
(
mp
indx
ksize
)
;
dif
=
NUMKEYS
(
mp
)
-
indx
;
if
(
dif
>
0
)
memmove
(
ptr
+
ksize
ptr
dif
*
ksize
)
;
memcpy
(
ptr
key
-
>
mv_data
ksize
)
;
mp
-
>
mp_lower
+
=
sizeof
(
indx_t
)
;
mp
-
>
mp_upper
-
=
ksize
-
sizeof
(
indx_t
)
;
return
MDB_SUCCESS
;
}
room
=
(
ssize_t
)
SIZELEFT
(
mp
)
-
(
ssize_t
)
sizeof
(
indx_t
)
;
if
(
key
!
=
NULL
)
node_size
+
=
key
-
>
mv_size
;
if
(
IS_LEAF
(
mp
)
)
{
mdb_cassert
(
mc
key
&
&
data
)
;
if
(
F_ISSET
(
flags
F_BIGDATA
)
)
{
node_size
+
=
sizeof
(
pgno_t
)
;
}
else
if
(
node_size
+
data
-
>
mv_size
>
mc
-
>
mc_txn
-
>
mt_env
-
>
me_nodemax
)
{
int
ovpages
=
OVPAGES
(
data
-
>
mv_size
mc
-
>
mc_txn
-
>
mt_env
-
>
me_psize
)
;
int
rc
;
DPRINTF
(
(
"
data
size
is
%
"
Z
"
u
node
would
be
%
"
Z
"
u
put
data
on
overflow
page
"
data
-
>
mv_size
node_size
+
data
-
>
mv_size
)
)
;
node_size
=
EVEN
(
node_size
+
sizeof
(
pgno_t
)
)
;
if
(
(
ssize_t
)
node_size
>
room
)
goto
full
;
if
(
(
rc
=
mdb_page_new
(
mc
P_OVERFLOW
ovpages
&
ofp
)
)
)
return
rc
;
DPRINTF
(
(
"
allocated
overflow
page
%
"
Z
"
u
"
ofp
-
>
mp_pgno
)
)
;
flags
|
=
F_BIGDATA
;
goto
update
;
}
else
{
node_size
+
=
data
-
>
mv_size
;
}
}
node_size
=
EVEN
(
node_size
)
;
if
(
(
ssize_t
)
node_size
>
room
)
goto
full
;
update
:
for
(
i
=
NUMKEYS
(
mp
)
;
i
>
indx
;
i
-
-
)
mp
-
>
mp_ptrs
[
i
]
=
mp
-
>
mp_ptrs
[
i
-
1
]
;
ofs
=
mp
-
>
mp_upper
-
node_size
;
mdb_cassert
(
mc
ofs
>
=
mp
-
>
mp_lower
+
sizeof
(
indx_t
)
)
;
mp
-
>
mp_ptrs
[
indx
]
=
ofs
;
mp
-
>
mp_upper
=
ofs
;
mp
-
>
mp_lower
+
=
sizeof
(
indx_t
)
;
node
=
NODEPTR
(
mp
indx
)
;
node
-
>
mn_ksize
=
(
key
=
=
NULL
)
?
0
:
key
-
>
mv_size
;
node
-
>
mn_flags
=
flags
;
if
(
IS_LEAF
(
mp
)
)
SETDSZ
(
node
data
-
>
mv_size
)
;
else
SETPGNO
(
node
pgno
)
;
if
(
key
)
memcpy
(
NODEKEY
(
node
)
key
-
>
mv_data
key
-
>
mv_size
)
;
if
(
IS_LEAF
(
mp
)
)
{
ndata
=
NODEDATA
(
node
)
;
if
(
ofp
=
=
NULL
)
{
if
(
F_ISSET
(
flags
F_BIGDATA
)
)
memcpy
(
ndata
data
-
>
mv_data
sizeof
(
pgno_t
)
)
;
else
if
(
F_ISSET
(
flags
MDB_RESERVE
)
)
data
-
>
mv_data
=
ndata
;
else
memcpy
(
ndata
data
-
>
mv_data
data
-
>
mv_size
)
;
}
else
{
memcpy
(
ndata
&
ofp
-
>
mp_pgno
sizeof
(
pgno_t
)
)
;
ndata
=
METADATA
(
ofp
)
;
if
(
F_ISSET
(
flags
MDB_RESERVE
)
)
data
-
>
mv_data
=
ndata
;
else
memcpy
(
ndata
data
-
>
mv_data
data
-
>
mv_size
)
;
}
}
return
MDB_SUCCESS
;
full
:
DPRINTF
(
(
"
not
enough
room
in
page
%
"
Z
"
u
got
%
u
ptrs
"
mdb_dbg_pgno
(
mp
)
NUMKEYS
(
mp
)
)
)
;
DPRINTF
(
(
"
upper
-
lower
=
%
u
-
%
u
=
%
"
Z
"
d
"
mp
-
>
mp_upper
mp
-
>
mp_lower
room
)
)
;
DPRINTF
(
(
"
node
size
=
%
"
Z
"
u
"
node_size
)
)
;
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
MDB_PAGE_FULL
;
}
static
void
mdb_node_del
(
MDB_cursor
*
mc
int
ksize
)
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
indx_t
indx
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
;
unsigned
int
sz
;
indx_t
i
j
numkeys
ptr
;
MDB_node
*
node
;
char
*
base
;
DPRINTF
(
(
"
delete
node
%
u
on
%
s
page
%
"
Z
"
u
"
indx
IS_LEAF
(
mp
)
?
"
leaf
"
:
"
branch
"
mdb_dbg_pgno
(
mp
)
)
)
;
numkeys
=
NUMKEYS
(
mp
)
;
mdb_cassert
(
mc
indx
<
numkeys
)
;
if
(
IS_LEAF2
(
mp
)
)
{
int
x
=
numkeys
-
1
-
indx
;
base
=
LEAF2KEY
(
mp
indx
ksize
)
;
if
(
x
)
memmove
(
base
base
+
ksize
x
*
ksize
)
;
mp
-
>
mp_lower
-
=
sizeof
(
indx_t
)
;
mp
-
>
mp_upper
+
=
ksize
-
sizeof
(
indx_t
)
;
return
;
}
node
=
NODEPTR
(
mp
indx
)
;
sz
=
NODESIZE
+
node
-
>
mn_ksize
;
if
(
IS_LEAF
(
mp
)
)
{
if
(
F_ISSET
(
node
-
>
mn_flags
F_BIGDATA
)
)
sz
+
=
sizeof
(
pgno_t
)
;
else
sz
+
=
NODEDSZ
(
node
)
;
}
sz
=
EVEN
(
sz
)
;
ptr
=
mp
-
>
mp_ptrs
[
indx
]
;
for
(
i
=
j
=
0
;
i
<
numkeys
;
i
+
+
)
{
if
(
i
!
=
indx
)
{
mp
-
>
mp_ptrs
[
j
]
=
mp
-
>
mp_ptrs
[
i
]
;
if
(
mp
-
>
mp_ptrs
[
i
]
<
ptr
)
mp
-
>
mp_ptrs
[
j
]
+
=
sz
;
j
+
+
;
}
}
base
=
(
char
*
)
mp
+
mp
-
>
mp_upper
+
PAGEBASE
;
memmove
(
base
+
sz
base
ptr
-
mp
-
>
mp_upper
)
;
mp
-
>
mp_lower
-
=
sizeof
(
indx_t
)
;
mp
-
>
mp_upper
+
=
sz
;
}
static
void
mdb_node_shrink
(
MDB_page
*
mp
indx_t
indx
)
{
MDB_node
*
node
;
MDB_page
*
sp
*
xp
;
char
*
base
;
indx_t
delta
nsize
len
ptr
;
int
i
;
node
=
NODEPTR
(
mp
indx
)
;
sp
=
(
MDB_page
*
)
NODEDATA
(
node
)
;
delta
=
SIZELEFT
(
sp
)
;
nsize
=
NODEDSZ
(
node
)
-
delta
;
if
(
IS_LEAF2
(
sp
)
)
{
len
=
nsize
;
if
(
nsize
&
1
)
return
;
}
else
{
xp
=
(
MDB_page
*
)
(
(
char
*
)
sp
+
delta
)
;
for
(
i
=
NUMKEYS
(
sp
)
;
-
-
i
>
=
0
;
)
xp
-
>
mp_ptrs
[
i
]
=
sp
-
>
mp_ptrs
[
i
]
-
delta
;
len
=
PAGEHDRSZ
;
}
sp
-
>
mp_upper
=
sp
-
>
mp_lower
;
COPY_PGNO
(
sp
-
>
mp_pgno
mp
-
>
mp_pgno
)
;
SETDSZ
(
node
nsize
)
;
base
=
(
char
*
)
mp
+
mp
-
>
mp_upper
+
PAGEBASE
;
memmove
(
base
+
delta
base
(
char
*
)
sp
+
len
-
base
)
;
ptr
=
mp
-
>
mp_ptrs
[
indx
]
;
for
(
i
=
NUMKEYS
(
mp
)
;
-
-
i
>
=
0
;
)
{
if
(
mp
-
>
mp_ptrs
[
i
]
<
=
ptr
)
mp
-
>
mp_ptrs
[
i
]
+
=
delta
;
}
mp
-
>
mp_upper
+
=
delta
;
}
static
void
mdb_xcursor_init0
(
MDB_cursor
*
mc
)
{
MDB_xcursor
*
mx
=
mc
-
>
mc_xcursor
;
mx
-
>
mx_cursor
.
mc_xcursor
=
NULL
;
mx
-
>
mx_cursor
.
mc_txn
=
mc
-
>
mc_txn
;
mx
-
>
mx_cursor
.
mc_db
=
&
mx
-
>
mx_db
;
mx
-
>
mx_cursor
.
mc_dbx
=
&
mx
-
>
mx_dbx
;
mx
-
>
mx_cursor
.
mc_dbi
=
mc
-
>
mc_dbi
;
mx
-
>
mx_cursor
.
mc_dbflag
=
&
mx
-
>
mx_dbflag
;
mx
-
>
mx_cursor
.
mc_snum
=
0
;
mx
-
>
mx_cursor
.
mc_top
=
0
;
mx
-
>
mx_cursor
.
mc_flags
=
C_SUB
;
mx
-
>
mx_dbx
.
md_name
.
mv_size
=
0
;
mx
-
>
mx_dbx
.
md_name
.
mv_data
=
NULL
;
mx
-
>
mx_dbx
.
md_cmp
=
mc
-
>
mc_dbx
-
>
md_dcmp
;
mx
-
>
mx_dbx
.
md_dcmp
=
NULL
;
mx
-
>
mx_dbx
.
md_rel
=
mc
-
>
mc_dbx
-
>
md_rel
;
}
static
void
mdb_xcursor_init1
(
MDB_cursor
*
mc
MDB_node
*
node
)
{
MDB_xcursor
*
mx
=
mc
-
>
mc_xcursor
;
if
(
node
-
>
mn_flags
&
F_SUBDATA
)
{
memcpy
(
&
mx
-
>
mx_db
NODEDATA
(
node
)
sizeof
(
MDB_db
)
)
;
mx
-
>
mx_cursor
.
mc_pg
[
0
]
=
0
;
mx
-
>
mx_cursor
.
mc_snum
=
0
;
mx
-
>
mx_cursor
.
mc_top
=
0
;
mx
-
>
mx_cursor
.
mc_flags
=
C_SUB
;
}
else
{
MDB_page
*
fp
=
NODEDATA
(
node
)
;
mx
-
>
mx_db
.
md_pad
=
0
;
mx
-
>
mx_db
.
md_flags
=
0
;
mx
-
>
mx_db
.
md_depth
=
1
;
mx
-
>
mx_db
.
md_branch_pages
=
0
;
mx
-
>
mx_db
.
md_leaf_pages
=
1
;
mx
-
>
mx_db
.
md_overflow_pages
=
0
;
mx
-
>
mx_db
.
md_entries
=
NUMKEYS
(
fp
)
;
COPY_PGNO
(
mx
-
>
mx_db
.
md_root
fp
-
>
mp_pgno
)
;
mx
-
>
mx_cursor
.
mc_snum
=
1
;
mx
-
>
mx_cursor
.
mc_top
=
0
;
mx
-
>
mx_cursor
.
mc_flags
=
C_INITIALIZED
|
C_SUB
;
mx
-
>
mx_cursor
.
mc_pg
[
0
]
=
fp
;
mx
-
>
mx_cursor
.
mc_ki
[
0
]
=
0
;
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPFIXED
)
{
mx
-
>
mx_db
.
md_flags
=
MDB_DUPFIXED
;
mx
-
>
mx_db
.
md_pad
=
fp
-
>
mp_pad
;
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_INTEGERDUP
)
mx
-
>
mx_db
.
md_flags
|
=
MDB_INTEGERKEY
;
}
}
DPRINTF
(
(
"
Sub
-
db
-
%
u
root
page
%
"
Z
"
u
"
mx
-
>
mx_cursor
.
mc_dbi
mx
-
>
mx_db
.
md_root
)
)
;
mx
-
>
mx_dbflag
=
DB_VALID
|
DB_USRVALID
|
DB_DUPDATA
;
#
if
UINT_MAX
<
SIZE_MAX
if
(
mx
-
>
mx_dbx
.
md_cmp
=
=
mdb_cmp_int
&
&
mx
-
>
mx_db
.
md_pad
=
=
sizeof
(
size_t
)
)
mx
-
>
mx_dbx
.
md_cmp
=
mdb_cmp_clong
;
#
endif
}
static
void
mdb_xcursor_init2
(
MDB_cursor
*
mc
MDB_xcursor
*
src_mx
int
new_dupdata
)
{
MDB_xcursor
*
mx
=
mc
-
>
mc_xcursor
;
if
(
new_dupdata
)
{
mx
-
>
mx_cursor
.
mc_snum
=
1
;
mx
-
>
mx_cursor
.
mc_top
=
0
;
mx
-
>
mx_cursor
.
mc_flags
|
=
C_INITIALIZED
;
mx
-
>
mx_cursor
.
mc_ki
[
0
]
=
0
;
mx
-
>
mx_dbflag
=
DB_VALID
|
DB_USRVALID
|
DB_DUPDATA
;
#
if
UINT_MAX
<
SIZE_MAX
mx
-
>
mx_dbx
.
md_cmp
=
src_mx
-
>
mx_dbx
.
md_cmp
;
#
endif
}
else
if
(
!
(
mx
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
)
{
return
;
}
mx
-
>
mx_db
=
src_mx
-
>
mx_db
;
mx
-
>
mx_cursor
.
mc_pg
[
0
]
=
src_mx
-
>
mx_cursor
.
mc_pg
[
0
]
;
DPRINTF
(
(
"
Sub
-
db
-
%
u
root
page
%
"
Z
"
u
"
mx
-
>
mx_cursor
.
mc_dbi
mx
-
>
mx_db
.
md_root
)
)
;
}
static
void
mdb_cursor_init
(
MDB_cursor
*
mc
MDB_txn
*
txn
MDB_dbi
dbi
MDB_xcursor
*
mx
)
{
mc
-
>
mc_next
=
NULL
;
mc
-
>
mc_backup
=
NULL
;
mc
-
>
mc_dbi
=
dbi
;
mc
-
>
mc_txn
=
txn
;
mc
-
>
mc_db
=
&
txn
-
>
mt_dbs
[
dbi
]
;
mc
-
>
mc_dbx
=
&
txn
-
>
mt_dbxs
[
dbi
]
;
mc
-
>
mc_dbflag
=
&
txn
-
>
mt_dbflags
[
dbi
]
;
mc
-
>
mc_snum
=
0
;
mc
-
>
mc_top
=
0
;
mc
-
>
mc_pg
[
0
]
=
0
;
mc
-
>
mc_ki
[
0
]
=
0
;
mc
-
>
mc_flags
=
0
;
if
(
txn
-
>
mt_dbs
[
dbi
]
.
md_flags
&
MDB_DUPSORT
)
{
mdb_tassert
(
txn
mx
!
=
NULL
)
;
mc
-
>
mc_xcursor
=
mx
;
mdb_xcursor_init0
(
mc
)
;
}
else
{
mc
-
>
mc_xcursor
=
NULL
;
}
if
(
*
mc
-
>
mc_dbflag
&
DB_STALE
)
{
mdb_page_search
(
mc
NULL
MDB_PS_ROOTONLY
)
;
}
}
int
mdb_cursor_open
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_cursor
*
*
ret
)
{
MDB_cursor
*
mc
;
size_t
size
=
sizeof
(
MDB_cursor
)
;
if
(
!
ret
|
|
!
TXN_DBI_EXIST
(
txn
dbi
DB_VALID
)
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
if
(
dbi
=
=
FREE_DBI
&
&
!
F_ISSET
(
txn
-
>
mt_flags
MDB_TXN_RDONLY
)
)
return
EINVAL
;
if
(
txn
-
>
mt_dbs
[
dbi
]
.
md_flags
&
MDB_DUPSORT
)
size
+
=
sizeof
(
MDB_xcursor
)
;
if
(
(
mc
=
malloc
(
size
)
)
!
=
NULL
)
{
mdb_cursor_init
(
mc
txn
dbi
(
MDB_xcursor
*
)
(
mc
+
1
)
)
;
if
(
txn
-
>
mt_cursors
)
{
mc
-
>
mc_next
=
txn
-
>
mt_cursors
[
dbi
]
;
txn
-
>
mt_cursors
[
dbi
]
=
mc
;
mc
-
>
mc_flags
|
=
C_UNTRACK
;
}
}
else
{
return
ENOMEM
;
}
*
ret
=
mc
;
return
MDB_SUCCESS
;
}
int
mdb_cursor_renew
(
MDB_txn
*
txn
MDB_cursor
*
mc
)
{
if
(
!
mc
|
|
!
TXN_DBI_EXIST
(
txn
mc
-
>
mc_dbi
DB_VALID
)
)
return
EINVAL
;
if
(
(
mc
-
>
mc_flags
&
C_UNTRACK
)
|
|
txn
-
>
mt_cursors
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
mdb_cursor_init
(
mc
txn
mc
-
>
mc_dbi
mc
-
>
mc_xcursor
)
;
return
MDB_SUCCESS
;
}
int
mdb_cursor_count
(
MDB_cursor
*
mc
size_t
*
countp
)
{
MDB_node
*
leaf
;
if
(
mc
=
=
NULL
|
|
countp
=
=
NULL
)
return
EINVAL
;
if
(
mc
-
>
mc_xcursor
=
=
NULL
)
return
MDB_INCOMPATIBLE
;
if
(
mc
-
>
mc_txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
if
(
!
(
mc
-
>
mc_flags
&
C_INITIALIZED
)
)
return
EINVAL
;
if
(
!
mc
-
>
mc_snum
)
return
MDB_NOTFOUND
;
if
(
mc
-
>
mc_flags
&
C_EOF
)
{
if
(
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
return
MDB_NOTFOUND
;
mc
-
>
mc_flags
^
=
C_EOF
;
}
leaf
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
!
F_ISSET
(
leaf
-
>
mn_flags
F_DUPDATA
)
)
{
*
countp
=
1
;
}
else
{
if
(
!
(
mc
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
)
return
EINVAL
;
*
countp
=
mc
-
>
mc_xcursor
-
>
mx_db
.
md_entries
;
}
return
MDB_SUCCESS
;
}
void
mdb_cursor_close
(
MDB_cursor
*
mc
)
{
if
(
mc
&
&
!
mc
-
>
mc_backup
)
{
if
(
(
mc
-
>
mc_flags
&
C_UNTRACK
)
&
&
mc
-
>
mc_txn
-
>
mt_cursors
)
{
MDB_cursor
*
*
prev
=
&
mc
-
>
mc_txn
-
>
mt_cursors
[
mc
-
>
mc_dbi
]
;
while
(
*
prev
&
&
*
prev
!
=
mc
)
prev
=
&
(
*
prev
)
-
>
mc_next
;
if
(
*
prev
=
=
mc
)
*
prev
=
mc
-
>
mc_next
;
}
free
(
mc
)
;
}
}
MDB_txn
*
mdb_cursor_txn
(
MDB_cursor
*
mc
)
{
if
(
!
mc
)
return
NULL
;
return
mc
-
>
mc_txn
;
}
MDB_dbi
mdb_cursor_dbi
(
MDB_cursor
*
mc
)
{
return
mc
-
>
mc_dbi
;
}
static
int
mdb_update_key
(
MDB_cursor
*
mc
MDB_val
*
key
)
{
MDB_page
*
mp
;
MDB_node
*
node
;
char
*
base
;
size_t
len
;
int
delta
ksize
oksize
;
indx_t
ptr
i
numkeys
indx
;
DKBUF
;
indx
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
node
=
NODEPTR
(
mp
indx
)
;
ptr
=
mp
-
>
mp_ptrs
[
indx
]
;
#
if
MDB_DEBUG
{
MDB_val
k2
;
char
kbuf2
[
DKBUF_MAXKEYSIZE
*
2
+
1
]
;
k2
.
mv_data
=
NODEKEY
(
node
)
;
k2
.
mv_size
=
node
-
>
mn_ksize
;
DPRINTF
(
(
"
update
key
%
u
(
ofs
%
u
)
[
%
s
]
to
[
%
s
]
on
page
%
"
Z
"
u
"
indx
ptr
mdb_dkey
(
&
k2
kbuf2
)
DKEY
(
key
)
mp
-
>
mp_pgno
)
)
;
}
#
endif
ksize
=
EVEN
(
key
-
>
mv_size
)
;
oksize
=
EVEN
(
node
-
>
mn_ksize
)
;
delta
=
ksize
-
oksize
;
if
(
delta
)
{
if
(
delta
>
0
&
&
SIZELEFT
(
mp
)
<
delta
)
{
pgno_t
pgno
;
DPRINTF
(
(
"
Not
enough
room
delta
=
%
d
splitting
.
.
.
"
delta
)
)
;
pgno
=
NODEPGNO
(
node
)
;
mdb_node_del
(
mc
0
)
;
return
mdb_page_split
(
mc
key
NULL
pgno
MDB_SPLIT_REPLACE
)
;
}
numkeys
=
NUMKEYS
(
mp
)
;
for
(
i
=
0
;
i
<
numkeys
;
i
+
+
)
{
if
(
mp
-
>
mp_ptrs
[
i
]
<
=
ptr
)
mp
-
>
mp_ptrs
[
i
]
-
=
delta
;
}
base
=
(
char
*
)
mp
+
mp
-
>
mp_upper
+
PAGEBASE
;
len
=
ptr
-
mp
-
>
mp_upper
+
NODESIZE
;
memmove
(
base
-
delta
base
len
)
;
mp
-
>
mp_upper
-
=
delta
;
node
=
NODEPTR
(
mp
indx
)
;
}
if
(
node
-
>
mn_ksize
!
=
key
-
>
mv_size
)
node
-
>
mn_ksize
=
key
-
>
mv_size
;
if
(
key
-
>
mv_size
)
memcpy
(
NODEKEY
(
node
)
key
-
>
mv_data
key
-
>
mv_size
)
;
return
MDB_SUCCESS
;
}
static
void
mdb_cursor_copy
(
const
MDB_cursor
*
csrc
MDB_cursor
*
cdst
)
;
#
define
WITH_CURSOR_TRACKING
(
mn
act
)
do
{
\
MDB_cursor
dummy
*
tracked
*
*
tp
=
&
(
mn
)
.
mc_txn
-
>
mt_cursors
[
mn
.
mc_dbi
]
;
\
if
(
(
mn
)
.
mc_flags
&
C_SUB
)
{
\
dummy
.
mc_flags
=
C_INITIALIZED
;
\
dummy
.
mc_xcursor
=
(
MDB_xcursor
*
)
&
(
mn
)
;
\
tracked
=
&
dummy
;
\
}
else
{
\
tracked
=
&
(
mn
)
;
\
}
\
tracked
-
>
mc_next
=
*
tp
;
\
*
tp
=
tracked
;
\
{
act
;
}
\
*
tp
=
tracked
-
>
mc_next
;
\
}
while
(
0
)
static
int
mdb_node_move
(
MDB_cursor
*
csrc
MDB_cursor
*
cdst
int
fromleft
)
{
MDB_node
*
srcnode
;
MDB_val
key
data
;
pgno_t
srcpg
;
MDB_cursor
mn
;
int
rc
;
unsigned
short
flags
;
DKBUF
;
if
(
(
rc
=
mdb_page_touch
(
csrc
)
)
|
|
(
rc
=
mdb_page_touch
(
cdst
)
)
)
return
rc
;
if
(
IS_LEAF2
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
)
{
key
.
mv_size
=
csrc
-
>
mc_db
-
>
md_pad
;
key
.
mv_data
=
LEAF2KEY
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
key
.
mv_size
)
;
data
.
mv_size
=
0
;
data
.
mv_data
=
NULL
;
srcpg
=
0
;
flags
=
0
;
}
else
{
srcnode
=
NODEPTR
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
)
;
mdb_cassert
(
csrc
!
(
(
size_t
)
srcnode
&
1
)
)
;
srcpg
=
NODEPGNO
(
srcnode
)
;
flags
=
srcnode
-
>
mn_flags
;
if
(
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
=
0
&
&
IS_BRANCH
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
)
{
unsigned
int
snum
=
csrc
-
>
mc_snum
;
MDB_node
*
s2
;
rc
=
mdb_page_search_lowest
(
csrc
)
;
if
(
rc
)
return
rc
;
if
(
IS_LEAF2
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
)
{
key
.
mv_size
=
csrc
-
>
mc_db
-
>
md_pad
;
key
.
mv_data
=
LEAF2KEY
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
0
key
.
mv_size
)
;
}
else
{
s2
=
NODEPTR
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
0
)
;
key
.
mv_size
=
NODEKSZ
(
s2
)
;
key
.
mv_data
=
NODEKEY
(
s2
)
;
}
csrc
-
>
mc_snum
=
snum
-
-
;
csrc
-
>
mc_top
=
snum
;
}
else
{
key
.
mv_size
=
NODEKSZ
(
srcnode
)
;
key
.
mv_data
=
NODEKEY
(
srcnode
)
;
}
data
.
mv_size
=
NODEDSZ
(
srcnode
)
;
data
.
mv_data
=
NODEDATA
(
srcnode
)
;
}
mn
.
mc_xcursor
=
NULL
;
if
(
IS_BRANCH
(
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
)
&
&
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
=
=
0
)
{
unsigned
int
snum
=
cdst
-
>
mc_snum
;
MDB_node
*
s2
;
MDB_val
bkey
;
mdb_cursor_copy
(
cdst
&
mn
)
;
rc
=
mdb_page_search_lowest
(
&
mn
)
;
if
(
rc
)
return
rc
;
if
(
IS_LEAF2
(
mn
.
mc_pg
[
mn
.
mc_top
]
)
)
{
bkey
.
mv_size
=
mn
.
mc_db
-
>
md_pad
;
bkey
.
mv_data
=
LEAF2KEY
(
mn
.
mc_pg
[
mn
.
mc_top
]
0
bkey
.
mv_size
)
;
}
else
{
s2
=
NODEPTR
(
mn
.
mc_pg
[
mn
.
mc_top
]
0
)
;
bkey
.
mv_size
=
NODEKSZ
(
s2
)
;
bkey
.
mv_data
=
NODEKEY
(
s2
)
;
}
mn
.
mc_snum
=
snum
-
-
;
mn
.
mc_top
=
snum
;
mn
.
mc_ki
[
snum
]
=
0
;
rc
=
mdb_update_key
(
&
mn
&
bkey
)
;
if
(
rc
)
return
rc
;
}
DPRINTF
(
(
"
moving
%
s
node
%
u
[
%
s
]
on
page
%
"
Z
"
u
to
node
%
u
on
page
%
"
Z
"
u
"
IS_LEAF
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
?
"
leaf
"
:
"
branch
"
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
DKEY
(
&
key
)
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
-
>
mp_pgno
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
-
>
mp_pgno
)
)
;
rc
=
mdb_node_add
(
cdst
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
&
key
&
data
srcpg
flags
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
mdb_node_del
(
csrc
key
.
mv_size
)
;
{
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
csrc
-
>
mc_dbi
;
MDB_page
*
mpd
*
mps
;
mps
=
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
;
if
(
fromleft
)
{
mpd
=
cdst
-
>
mc_pg
[
csrc
-
>
mc_top
]
;
for
(
m2
=
csrc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
csrc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
!
(
m3
-
>
mc_flags
&
C_INITIALIZED
)
|
|
m3
-
>
mc_top
<
csrc
-
>
mc_top
)
continue
;
if
(
m3
!
=
cdst
&
&
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
=
=
mpd
&
&
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
>
=
cdst
-
>
mc_ki
[
csrc
-
>
mc_top
]
)
{
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
+
+
;
}
if
(
m3
!
=
csrc
&
&
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
=
=
mps
&
&
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
=
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
)
{
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
=
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
;
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
;
m3
-
>
mc_ki
[
csrc
-
>
mc_top
-
1
]
+
+
;
}
if
(
XCURSOR_INITED
(
m3
)
&
&
IS_LEAF
(
mps
)
)
XCURSOR_REFRESH
(
m3
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
)
;
}
}
else
{
for
(
m2
=
csrc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
csrc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
m3
=
=
csrc
)
continue
;
if
(
!
(
m3
-
>
mc_flags
&
C_INITIALIZED
)
|
|
m3
-
>
mc_top
<
csrc
-
>
mc_top
)
continue
;
if
(
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
=
=
mps
)
{
if
(
!
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
)
{
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
=
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
;
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
;
m3
-
>
mc_ki
[
csrc
-
>
mc_top
-
1
]
-
-
;
}
else
{
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
-
-
;
}
if
(
XCURSOR_INITED
(
m3
)
&
&
IS_LEAF
(
mps
)
)
XCURSOR_REFRESH
(
m3
m3
-
>
mc_pg
[
csrc
-
>
mc_top
]
m3
-
>
mc_ki
[
csrc
-
>
mc_top
]
)
;
}
}
}
}
if
(
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
=
0
)
{
if
(
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
-
1
]
!
=
0
)
{
if
(
IS_LEAF2
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
)
{
key
.
mv_data
=
LEAF2KEY
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
0
key
.
mv_size
)
;
}
else
{
srcnode
=
NODEPTR
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
0
)
;
key
.
mv_size
=
NODEKSZ
(
srcnode
)
;
key
.
mv_data
=
NODEKEY
(
srcnode
)
;
}
DPRINTF
(
(
"
update
separator
for
source
page
%
"
Z
"
u
to
[
%
s
]
"
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
-
>
mp_pgno
DKEY
(
&
key
)
)
)
;
mdb_cursor_copy
(
csrc
&
mn
)
;
mn
.
mc_snum
-
-
;
mn
.
mc_top
-
-
;
WITH_CURSOR_TRACKING
(
mn
rc
=
mdb_update_key
(
&
mn
&
key
)
)
;
if
(
rc
)
return
rc
;
}
if
(
IS_BRANCH
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
)
{
MDB_val
nullkey
;
indx_t
ix
=
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
;
nullkey
.
mv_size
=
0
;
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
0
;
rc
=
mdb_update_key
(
csrc
&
nullkey
)
;
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
ix
;
mdb_cassert
(
csrc
rc
=
=
MDB_SUCCESS
)
;
}
}
if
(
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
=
=
0
)
{
if
(
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
-
1
]
!
=
0
)
{
if
(
IS_LEAF2
(
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
)
)
{
key
.
mv_data
=
LEAF2KEY
(
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
0
key
.
mv_size
)
;
}
else
{
srcnode
=
NODEPTR
(
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
0
)
;
key
.
mv_size
=
NODEKSZ
(
srcnode
)
;
key
.
mv_data
=
NODEKEY
(
srcnode
)
;
}
DPRINTF
(
(
"
update
separator
for
destination
page
%
"
Z
"
u
to
[
%
s
]
"
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
-
>
mp_pgno
DKEY
(
&
key
)
)
)
;
mdb_cursor_copy
(
cdst
&
mn
)
;
mn
.
mc_snum
-
-
;
mn
.
mc_top
-
-
;
WITH_CURSOR_TRACKING
(
mn
rc
=
mdb_update_key
(
&
mn
&
key
)
)
;
if
(
rc
)
return
rc
;
}
if
(
IS_BRANCH
(
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
)
)
{
MDB_val
nullkey
;
indx_t
ix
=
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
;
nullkey
.
mv_size
=
0
;
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
=
0
;
rc
=
mdb_update_key
(
cdst
&
nullkey
)
;
cdst
-
>
mc_ki
[
cdst
-
>
mc_top
]
=
ix
;
mdb_cassert
(
cdst
rc
=
=
MDB_SUCCESS
)
;
}
}
return
MDB_SUCCESS
;
}
static
int
mdb_page_merge
(
MDB_cursor
*
csrc
MDB_cursor
*
cdst
)
{
MDB_page
*
psrc
*
pdst
;
MDB_node
*
srcnode
;
MDB_val
key
data
;
unsigned
nkeys
;
int
rc
;
indx_t
i
j
;
psrc
=
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
;
pdst
=
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
;
DPRINTF
(
(
"
merging
page
%
"
Z
"
u
into
%
"
Z
"
u
"
psrc
-
>
mp_pgno
pdst
-
>
mp_pgno
)
)
;
mdb_cassert
(
csrc
csrc
-
>
mc_snum
>
1
)
;
mdb_cassert
(
csrc
cdst
-
>
mc_snum
>
1
)
;
if
(
(
rc
=
mdb_page_touch
(
cdst
)
)
)
return
rc
;
pdst
=
cdst
-
>
mc_pg
[
cdst
-
>
mc_top
]
;
j
=
nkeys
=
NUMKEYS
(
pdst
)
;
if
(
IS_LEAF2
(
psrc
)
)
{
key
.
mv_size
=
csrc
-
>
mc_db
-
>
md_pad
;
key
.
mv_data
=
METADATA
(
psrc
)
;
for
(
i
=
0
;
i
<
NUMKEYS
(
psrc
)
;
i
+
+
j
+
+
)
{
rc
=
mdb_node_add
(
cdst
j
&
key
NULL
0
0
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
key
.
mv_data
=
(
char
*
)
key
.
mv_data
+
key
.
mv_size
;
}
}
else
{
for
(
i
=
0
;
i
<
NUMKEYS
(
psrc
)
;
i
+
+
j
+
+
)
{
srcnode
=
NODEPTR
(
psrc
i
)
;
if
(
i
=
=
0
&
&
IS_BRANCH
(
psrc
)
)
{
MDB_cursor
mn
;
MDB_node
*
s2
;
mdb_cursor_copy
(
csrc
&
mn
)
;
mn
.
mc_xcursor
=
NULL
;
rc
=
mdb_page_search_lowest
(
&
mn
)
;
if
(
rc
)
return
rc
;
if
(
IS_LEAF2
(
mn
.
mc_pg
[
mn
.
mc_top
]
)
)
{
key
.
mv_size
=
mn
.
mc_db
-
>
md_pad
;
key
.
mv_data
=
LEAF2KEY
(
mn
.
mc_pg
[
mn
.
mc_top
]
0
key
.
mv_size
)
;
}
else
{
s2
=
NODEPTR
(
mn
.
mc_pg
[
mn
.
mc_top
]
0
)
;
key
.
mv_size
=
NODEKSZ
(
s2
)
;
key
.
mv_data
=
NODEKEY
(
s2
)
;
}
}
else
{
key
.
mv_size
=
srcnode
-
>
mn_ksize
;
key
.
mv_data
=
NODEKEY
(
srcnode
)
;
}
data
.
mv_size
=
NODEDSZ
(
srcnode
)
;
data
.
mv_data
=
NODEDATA
(
srcnode
)
;
rc
=
mdb_node_add
(
cdst
j
&
key
&
data
NODEPGNO
(
srcnode
)
srcnode
-
>
mn_flags
)
;
if
(
rc
!
=
MDB_SUCCESS
)
return
rc
;
}
}
DPRINTF
(
(
"
dst
page
%
"
Z
"
u
now
has
%
u
keys
(
%
.
1f
%
%
filled
)
"
pdst
-
>
mp_pgno
NUMKEYS
(
pdst
)
(
float
)
PAGEFILL
(
cdst
-
>
mc_txn
-
>
mt_env
pdst
)
/
10
)
)
;
csrc
-
>
mc_top
-
-
;
mdb_node_del
(
csrc
0
)
;
if
(
csrc
-
>
mc_ki
[
csrc
-
>
mc_top
]
=
=
0
)
{
key
.
mv_size
=
0
;
rc
=
mdb_update_key
(
csrc
&
key
)
;
if
(
rc
)
{
csrc
-
>
mc_top
+
+
;
return
rc
;
}
}
csrc
-
>
mc_top
+
+
;
psrc
=
csrc
-
>
mc_pg
[
csrc
-
>
mc_top
]
;
rc
=
mdb_page_loose
(
csrc
psrc
)
;
if
(
rc
)
return
rc
;
if
(
IS_LEAF
(
psrc
)
)
csrc
-
>
mc_db
-
>
md_leaf_pages
-
-
;
else
csrc
-
>
mc_db
-
>
md_branch_pages
-
-
;
{
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
csrc
-
>
mc_dbi
;
unsigned
int
top
=
csrc
-
>
mc_top
;
for
(
m2
=
csrc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
csrc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
m3
=
=
csrc
)
continue
;
if
(
m3
-
>
mc_snum
<
csrc
-
>
mc_snum
)
continue
;
if
(
m3
-
>
mc_pg
[
top
]
=
=
psrc
)
{
m3
-
>
mc_pg
[
top
]
=
pdst
;
m3
-
>
mc_ki
[
top
]
+
=
nkeys
;
m3
-
>
mc_ki
[
top
-
1
]
=
cdst
-
>
mc_ki
[
top
-
1
]
;
}
else
if
(
m3
-
>
mc_pg
[
top
-
1
]
=
=
csrc
-
>
mc_pg
[
top
-
1
]
&
&
m3
-
>
mc_ki
[
top
-
1
]
>
csrc
-
>
mc_ki
[
top
-
1
]
)
{
m3
-
>
mc_ki
[
top
-
1
]
-
-
;
}
if
(
XCURSOR_INITED
(
m3
)
&
&
IS_LEAF
(
psrc
)
)
XCURSOR_REFRESH
(
m3
m3
-
>
mc_pg
[
top
]
m3
-
>
mc_ki
[
top
]
)
;
}
}
{
unsigned
int
snum
=
cdst
-
>
mc_snum
;
uint16_t
depth
=
cdst
-
>
mc_db
-
>
md_depth
;
mdb_cursor_pop
(
cdst
)
;
rc
=
mdb_rebalance
(
cdst
)
;
if
(
depth
!
=
cdst
-
>
mc_db
-
>
md_depth
)
snum
+
=
cdst
-
>
mc_db
-
>
md_depth
-
depth
;
cdst
-
>
mc_snum
=
snum
;
cdst
-
>
mc_top
=
snum
-
1
;
}
return
rc
;
}
static
void
mdb_cursor_copy
(
const
MDB_cursor
*
csrc
MDB_cursor
*
cdst
)
{
unsigned
int
i
;
cdst
-
>
mc_txn
=
csrc
-
>
mc_txn
;
cdst
-
>
mc_dbi
=
csrc
-
>
mc_dbi
;
cdst
-
>
mc_db
=
csrc
-
>
mc_db
;
cdst
-
>
mc_dbx
=
csrc
-
>
mc_dbx
;
cdst
-
>
mc_snum
=
csrc
-
>
mc_snum
;
cdst
-
>
mc_top
=
csrc
-
>
mc_top
;
cdst
-
>
mc_flags
=
csrc
-
>
mc_flags
;
for
(
i
=
0
;
i
<
csrc
-
>
mc_snum
;
i
+
+
)
{
cdst
-
>
mc_pg
[
i
]
=
csrc
-
>
mc_pg
[
i
]
;
cdst
-
>
mc_ki
[
i
]
=
csrc
-
>
mc_ki
[
i
]
;
}
}
static
int
mdb_rebalance
(
MDB_cursor
*
mc
)
{
MDB_node
*
node
;
int
rc
fromleft
;
unsigned
int
ptop
minkeys
thresh
;
MDB_cursor
mn
;
indx_t
oldki
;
if
(
IS_BRANCH
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
{
minkeys
=
2
;
thresh
=
1
;
}
else
{
minkeys
=
1
;
thresh
=
FILL_THRESHOLD
;
}
DPRINTF
(
(
"
rebalancing
%
s
page
%
"
Z
"
u
(
has
%
u
keys
%
.
1f
%
%
full
)
"
IS_LEAF
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
?
"
leaf
"
:
"
branch
"
mdb_dbg_pgno
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
(
float
)
PAGEFILL
(
mc
-
>
mc_txn
-
>
mt_env
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
/
10
)
)
;
if
(
PAGEFILL
(
mc
-
>
mc_txn
-
>
mt_env
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
>
=
thresh
&
&
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
>
=
minkeys
)
{
DPRINTF
(
(
"
no
need
to
rebalance
page
%
"
Z
"
u
above
fill
threshold
"
mdb_dbg_pgno
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
)
)
;
return
MDB_SUCCESS
;
}
if
(
mc
-
>
mc_snum
<
2
)
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
0
]
;
if
(
IS_SUBP
(
mp
)
)
{
DPUTS
(
"
Can
'
t
rebalance
a
subpage
ignoring
"
)
;
return
MDB_SUCCESS
;
}
if
(
NUMKEYS
(
mp
)
=
=
0
)
{
DPUTS
(
"
tree
is
completely
empty
"
)
;
mc
-
>
mc_db
-
>
md_root
=
P_INVALID
;
mc
-
>
mc_db
-
>
md_depth
=
0
;
mc
-
>
mc_db
-
>
md_leaf_pages
=
0
;
rc
=
mdb_midl_append
(
&
mc
-
>
mc_txn
-
>
mt_free_pgs
mp
-
>
mp_pgno
)
;
if
(
rc
)
return
rc
;
mc
-
>
mc_snum
=
0
;
mc
-
>
mc_top
=
0
;
mc
-
>
mc_flags
&
=
~
C_INITIALIZED
;
{
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
mc
-
>
mc_dbi
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
mc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
!
(
m3
-
>
mc_flags
&
C_INITIALIZED
)
|
|
(
m3
-
>
mc_snum
<
mc
-
>
mc_snum
)
)
continue
;
if
(
m3
-
>
mc_pg
[
0
]
=
=
mp
)
{
m3
-
>
mc_snum
=
0
;
m3
-
>
mc_top
=
0
;
m3
-
>
mc_flags
&
=
~
C_INITIALIZED
;
}
}
}
}
else
if
(
IS_BRANCH
(
mp
)
&
&
NUMKEYS
(
mp
)
=
=
1
)
{
int
i
;
DPUTS
(
"
collapsing
root
page
!
"
)
;
rc
=
mdb_midl_append
(
&
mc
-
>
mc_txn
-
>
mt_free_pgs
mp
-
>
mp_pgno
)
;
if
(
rc
)
return
rc
;
mc
-
>
mc_db
-
>
md_root
=
NODEPGNO
(
NODEPTR
(
mp
0
)
)
;
rc
=
mdb_page_get
(
mc
mc
-
>
mc_db
-
>
md_root
&
mc
-
>
mc_pg
[
0
]
NULL
)
;
if
(
rc
)
return
rc
;
mc
-
>
mc_db
-
>
md_depth
-
-
;
mc
-
>
mc_db
-
>
md_branch_pages
-
-
;
mc
-
>
mc_ki
[
0
]
=
mc
-
>
mc_ki
[
1
]
;
for
(
i
=
1
;
i
<
mc
-
>
mc_db
-
>
md_depth
;
i
+
+
)
{
mc
-
>
mc_pg
[
i
]
=
mc
-
>
mc_pg
[
i
+
1
]
;
mc
-
>
mc_ki
[
i
]
=
mc
-
>
mc_ki
[
i
+
1
]
;
}
{
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
mc
-
>
mc_dbi
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
mc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
m3
=
=
mc
)
continue
;
if
(
!
(
m3
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
if
(
m3
-
>
mc_pg
[
0
]
=
=
mp
)
{
for
(
i
=
0
;
i
<
mc
-
>
mc_db
-
>
md_depth
;
i
+
+
)
{
m3
-
>
mc_pg
[
i
]
=
m3
-
>
mc_pg
[
i
+
1
]
;
m3
-
>
mc_ki
[
i
]
=
m3
-
>
mc_ki
[
i
+
1
]
;
}
m3
-
>
mc_snum
-
-
;
m3
-
>
mc_top
-
-
;
}
}
}
}
else
DPUTS
(
"
root
page
doesn
'
t
need
rebalancing
"
)
;
return
MDB_SUCCESS
;
}
ptop
=
mc
-
>
mc_top
-
1
;
mdb_cassert
(
mc
NUMKEYS
(
mc
-
>
mc_pg
[
ptop
]
)
>
1
)
;
mdb_cursor_copy
(
mc
&
mn
)
;
mn
.
mc_xcursor
=
NULL
;
oldki
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
;
if
(
mc
-
>
mc_ki
[
ptop
]
=
=
0
)
{
DPUTS
(
"
reading
right
neighbor
"
)
;
mn
.
mc_ki
[
ptop
]
+
+
;
node
=
NODEPTR
(
mc
-
>
mc_pg
[
ptop
]
mn
.
mc_ki
[
ptop
]
)
;
rc
=
mdb_page_get
(
mc
NODEPGNO
(
node
)
&
mn
.
mc_pg
[
mn
.
mc_top
]
NULL
)
;
if
(
rc
)
return
rc
;
mn
.
mc_ki
[
mn
.
mc_top
]
=
0
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
NUMKEYS
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
)
;
fromleft
=
0
;
}
else
{
DPUTS
(
"
reading
left
neighbor
"
)
;
mn
.
mc_ki
[
ptop
]
-
-
;
node
=
NODEPTR
(
mc
-
>
mc_pg
[
ptop
]
mn
.
mc_ki
[
ptop
]
)
;
rc
=
mdb_page_get
(
mc
NODEPGNO
(
node
)
&
mn
.
mc_pg
[
mn
.
mc_top
]
NULL
)
;
if
(
rc
)
return
rc
;
mn
.
mc_ki
[
mn
.
mc_top
]
=
NUMKEYS
(
mn
.
mc_pg
[
mn
.
mc_top
]
)
-
1
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
fromleft
=
1
;
}
DPRINTF
(
(
"
found
neighbor
page
%
"
Z
"
u
(
%
u
keys
%
.
1f
%
%
full
)
"
mn
.
mc_pg
[
mn
.
mc_top
]
-
>
mp_pgno
NUMKEYS
(
mn
.
mc_pg
[
mn
.
mc_top
]
)
(
float
)
PAGEFILL
(
mc
-
>
mc_txn
-
>
mt_env
mn
.
mc_pg
[
mn
.
mc_top
]
)
/
10
)
)
;
if
(
PAGEFILL
(
mc
-
>
mc_txn
-
>
mt_env
mn
.
mc_pg
[
mn
.
mc_top
]
)
>
=
thresh
&
&
NUMKEYS
(
mn
.
mc_pg
[
mn
.
mc_top
]
)
>
minkeys
)
{
rc
=
mdb_node_move
(
&
mn
mc
fromleft
)
;
if
(
fromleft
)
{
oldki
+
+
;
}
}
else
{
if
(
!
fromleft
)
{
rc
=
mdb_page_merge
(
&
mn
mc
)
;
}
else
{
oldki
+
=
NUMKEYS
(
mn
.
mc_pg
[
mn
.
mc_top
]
)
;
mn
.
mc_ki
[
mn
.
mc_top
]
+
=
mc
-
>
mc_ki
[
mn
.
mc_top
]
+
1
;
WITH_CURSOR_TRACKING
(
mn
rc
=
mdb_page_merge
(
mc
&
mn
)
)
;
mdb_cursor_copy
(
&
mn
mc
)
;
}
mc
-
>
mc_flags
&
=
~
C_EOF
;
}
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
oldki
;
return
rc
;
}
static
int
mdb_cursor_del0
(
MDB_cursor
*
mc
)
{
int
rc
;
MDB_page
*
mp
;
indx_t
ki
;
unsigned
int
nkeys
;
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
mc
-
>
mc_dbi
;
ki
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
mdb_node_del
(
mc
mc
-
>
mc_db
-
>
md_pad
)
;
mc
-
>
mc_db
-
>
md_entries
-
-
;
{
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
m3
=
(
mc
-
>
mc_flags
&
C_SUB
)
?
&
m2
-
>
mc_xcursor
-
>
mx_cursor
:
m2
;
if
(
!
(
m2
-
>
mc_flags
&
m3
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
if
(
m3
=
=
mc
|
|
m3
-
>
mc_snum
<
mc
-
>
mc_snum
)
continue
;
if
(
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
=
=
mp
)
{
if
(
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
=
=
ki
)
{
m3
-
>
mc_flags
|
=
C_DEL
;
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
{
m3
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
}
continue
;
}
else
if
(
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
>
ki
)
{
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
-
-
;
}
if
(
XCURSOR_INITED
(
m3
)
)
XCURSOR_REFRESH
(
m3
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
}
}
}
rc
=
mdb_rebalance
(
mc
)
;
if
(
rc
=
=
MDB_SUCCESS
)
{
if
(
!
mc
-
>
mc_snum
)
return
rc
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
nkeys
=
NUMKEYS
(
mp
)
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
!
rc
&
&
m2
;
m2
=
m2
-
>
mc_next
)
{
m3
=
(
mc
-
>
mc_flags
&
C_SUB
)
?
&
m2
-
>
mc_xcursor
-
>
mx_cursor
:
m2
;
if
(
!
(
m2
-
>
mc_flags
&
m3
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
if
(
m3
-
>
mc_snum
<
mc
-
>
mc_snum
)
continue
;
if
(
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
=
=
mp
)
{
if
(
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
{
if
(
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
nkeys
)
{
rc
=
mdb_cursor_sibling
(
m3
1
)
;
if
(
rc
=
=
MDB_NOTFOUND
)
{
m3
-
>
mc_flags
|
=
C_EOF
;
rc
=
MDB_SUCCESS
;
continue
;
}
}
if
(
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
{
MDB_node
*
node
=
NODEPTR
(
m3
-
>
mc_pg
[
m3
-
>
mc_top
]
m3
-
>
mc_ki
[
m3
-
>
mc_top
]
)
;
if
(
node
-
>
mn_flags
&
F_DUPDATA
)
{
if
(
m3
-
>
mc_xcursor
-
>
mx_cursor
.
mc_flags
&
C_INITIALIZED
)
{
if
(
!
(
node
-
>
mn_flags
&
F_SUBDATA
)
)
m3
-
>
mc_xcursor
-
>
mx_cursor
.
mc_pg
[
0
]
=
NODEDATA
(
node
)
;
}
else
mdb_xcursor_init1
(
m3
node
)
;
}
}
}
}
}
mc
-
>
mc_flags
|
=
C_DEL
;
}
if
(
rc
)
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
rc
;
}
int
mdb_del
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_val
*
key
MDB_val
*
data
)
{
if
(
!
key
|
|
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
(
MDB_TXN_RDONLY
|
MDB_TXN_BLOCKED
)
)
return
(
txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
EACCES
:
MDB_BAD_TXN
;
if
(
!
F_ISSET
(
txn
-
>
mt_dbs
[
dbi
]
.
md_flags
MDB_DUPSORT
)
)
{
data
=
NULL
;
}
return
mdb_del0
(
txn
dbi
key
data
0
)
;
}
static
int
mdb_del0
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_val
*
key
MDB_val
*
data
unsigned
flags
)
{
MDB_cursor
mc
;
MDB_xcursor
mx
;
MDB_cursor_op
op
;
MDB_val
rdata
*
xdata
;
int
rc
exact
=
0
;
DKBUF
;
DPRINTF
(
(
"
=
=
=
=
>
delete
db
%
u
key
[
%
s
]
"
dbi
DKEY
(
key
)
)
)
;
mdb_cursor_init
(
&
mc
txn
dbi
&
mx
)
;
if
(
data
)
{
op
=
MDB_GET_BOTH
;
rdata
=
*
data
;
xdata
=
&
rdata
;
}
else
{
op
=
MDB_SET
;
xdata
=
NULL
;
flags
|
=
MDB_NODUPDATA
;
}
rc
=
mdb_cursor_set
(
&
mc
key
xdata
op
&
exact
)
;
if
(
rc
=
=
0
)
{
mc
.
mc_flags
|
=
C_UNTRACK
;
mc
.
mc_next
=
txn
-
>
mt_cursors
[
dbi
]
;
txn
-
>
mt_cursors
[
dbi
]
=
&
mc
;
rc
=
mdb_cursor_del
(
&
mc
flags
)
;
txn
-
>
mt_cursors
[
dbi
]
=
mc
.
mc_next
;
}
return
rc
;
}
static
int
mdb_page_split
(
MDB_cursor
*
mc
MDB_val
*
newkey
MDB_val
*
newdata
pgno_t
newpgno
unsigned
int
nflags
)
{
unsigned
int
flags
;
int
rc
=
MDB_SUCCESS
new_root
=
0
did_split
=
0
;
indx_t
newindx
;
pgno_t
pgno
=
0
;
int
i
j
split_indx
nkeys
pmax
;
MDB_env
*
env
=
mc
-
>
mc_txn
-
>
mt_env
;
MDB_node
*
node
;
MDB_val
sepkey
rkey
xdata
*
rdata
=
&
xdata
;
MDB_page
*
copy
=
NULL
;
MDB_page
*
mp
*
rp
*
pp
;
int
ptop
;
MDB_cursor
mn
;
DKBUF
;
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
newindx
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
;
nkeys
=
NUMKEYS
(
mp
)
;
DPRINTF
(
(
"
-
-
-
-
-
>
splitting
%
s
page
%
"
Z
"
u
and
adding
[
%
s
]
at
index
%
i
/
%
i
"
IS_LEAF
(
mp
)
?
"
leaf
"
:
"
branch
"
mp
-
>
mp_pgno
DKEY
(
newkey
)
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
nkeys
)
)
;
if
(
(
rc
=
mdb_page_new
(
mc
mp
-
>
mp_flags
1
&
rp
)
)
)
return
rc
;
rp
-
>
mp_pad
=
mp
-
>
mp_pad
;
DPRINTF
(
(
"
new
right
sibling
:
page
%
"
Z
"
u
"
rp
-
>
mp_pgno
)
)
;
if
(
mc
-
>
mc_top
<
1
)
{
if
(
(
rc
=
mdb_page_new
(
mc
P_BRANCH
1
&
pp
)
)
)
goto
done
;
for
(
i
=
mc
-
>
mc_snum
;
i
>
0
;
i
-
-
)
{
mc
-
>
mc_pg
[
i
]
=
mc
-
>
mc_pg
[
i
-
1
]
;
mc
-
>
mc_ki
[
i
]
=
mc
-
>
mc_ki
[
i
-
1
]
;
}
mc
-
>
mc_pg
[
0
]
=
pp
;
mc
-
>
mc_ki
[
0
]
=
0
;
mc
-
>
mc_db
-
>
md_root
=
pp
-
>
mp_pgno
;
DPRINTF
(
(
"
root
split
!
new
root
=
%
"
Z
"
u
"
pp
-
>
mp_pgno
)
)
;
new_root
=
mc
-
>
mc_db
-
>
md_depth
+
+
;
if
(
(
rc
=
mdb_node_add
(
mc
0
NULL
NULL
mp
-
>
mp_pgno
0
)
)
!
=
MDB_SUCCESS
)
{
mc
-
>
mc_pg
[
0
]
=
mc
-
>
mc_pg
[
1
]
;
mc
-
>
mc_ki
[
0
]
=
mc
-
>
mc_ki
[
1
]
;
mc
-
>
mc_db
-
>
md_root
=
mp
-
>
mp_pgno
;
mc
-
>
mc_db
-
>
md_depth
-
-
;
goto
done
;
}
mc
-
>
mc_snum
+
+
;
mc
-
>
mc_top
+
+
;
ptop
=
0
;
}
else
{
ptop
=
mc
-
>
mc_top
-
1
;
DPRINTF
(
(
"
parent
branch
page
is
%
"
Z
"
u
"
mc
-
>
mc_pg
[
ptop
]
-
>
mp_pgno
)
)
;
}
mdb_cursor_copy
(
mc
&
mn
)
;
mn
.
mc_xcursor
=
NULL
;
mn
.
mc_pg
[
mn
.
mc_top
]
=
rp
;
mn
.
mc_ki
[
ptop
]
=
mc
-
>
mc_ki
[
ptop
]
+
1
;
if
(
nflags
&
MDB_APPEND
)
{
mn
.
mc_ki
[
mn
.
mc_top
]
=
0
;
sepkey
=
*
newkey
;
split_indx
=
newindx
;
nkeys
=
0
;
}
else
{
split_indx
=
(
nkeys
+
1
)
/
2
;
if
(
IS_LEAF2
(
rp
)
)
{
char
*
split
*
ins
;
int
x
;
unsigned
int
lsize
rsize
ksize
;
x
=
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
-
split_indx
;
ksize
=
mc
-
>
mc_db
-
>
md_pad
;
split
=
LEAF2KEY
(
mp
split_indx
ksize
)
;
rsize
=
(
nkeys
-
split_indx
)
*
ksize
;
lsize
=
(
nkeys
-
split_indx
)
*
sizeof
(
indx_t
)
;
mp
-
>
mp_lower
-
=
lsize
;
rp
-
>
mp_lower
+
=
lsize
;
mp
-
>
mp_upper
+
=
rsize
-
lsize
;
rp
-
>
mp_upper
-
=
rsize
-
lsize
;
sepkey
.
mv_size
=
ksize
;
if
(
newindx
=
=
split_indx
)
{
sepkey
.
mv_data
=
newkey
-
>
mv_data
;
}
else
{
sepkey
.
mv_data
=
split
;
}
if
(
x
<
0
)
{
ins
=
LEAF2KEY
(
mp
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
ksize
)
;
memcpy
(
rp
-
>
mp_ptrs
split
rsize
)
;
sepkey
.
mv_data
=
rp
-
>
mp_ptrs
;
memmove
(
ins
+
ksize
ins
(
split_indx
-
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
*
ksize
)
;
memcpy
(
ins
newkey
-
>
mv_data
ksize
)
;
mp
-
>
mp_lower
+
=
sizeof
(
indx_t
)
;
mp
-
>
mp_upper
-
=
ksize
-
sizeof
(
indx_t
)
;
}
else
{
if
(
x
)
memcpy
(
rp
-
>
mp_ptrs
split
x
*
ksize
)
;
ins
=
LEAF2KEY
(
rp
x
ksize
)
;
memcpy
(
ins
newkey
-
>
mv_data
ksize
)
;
memcpy
(
ins
+
ksize
split
+
x
*
ksize
rsize
-
x
*
ksize
)
;
rp
-
>
mp_lower
+
=
sizeof
(
indx_t
)
;
rp
-
>
mp_upper
-
=
ksize
-
sizeof
(
indx_t
)
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
x
;
}
}
else
{
int
psize
nsize
k
;
pmax
=
env
-
>
me_psize
-
PAGEHDRSZ
;
if
(
IS_LEAF
(
mp
)
)
nsize
=
mdb_leaf_size
(
env
newkey
newdata
)
;
else
nsize
=
mdb_branch_size
(
env
newkey
)
;
nsize
=
EVEN
(
nsize
)
;
copy
=
mdb_page_malloc
(
mc
-
>
mc_txn
1
)
;
if
(
copy
=
=
NULL
)
{
rc
=
ENOMEM
;
goto
done
;
}
copy
-
>
mp_pgno
=
mp
-
>
mp_pgno
;
copy
-
>
mp_flags
=
mp
-
>
mp_flags
;
copy
-
>
mp_lower
=
(
PAGEHDRSZ
-
PAGEBASE
)
;
copy
-
>
mp_upper
=
env
-
>
me_psize
-
PAGEBASE
;
for
(
i
=
0
j
=
0
;
i
<
nkeys
;
i
+
+
)
{
if
(
i
=
=
newindx
)
{
copy
-
>
mp_ptrs
[
j
+
+
]
=
0
;
}
copy
-
>
mp_ptrs
[
j
+
+
]
=
mp
-
>
mp_ptrs
[
i
]
;
}
if
(
nkeys
<
20
|
|
nsize
>
pmax
/
16
|
|
newindx
>
=
nkeys
)
{
psize
=
0
;
if
(
newindx
<
=
split_indx
|
|
newindx
>
=
nkeys
)
{
i
=
0
;
j
=
1
;
k
=
newindx
>
=
nkeys
?
nkeys
:
split_indx
+
1
+
IS_LEAF
(
mp
)
;
}
else
{
i
=
nkeys
;
j
=
-
1
;
k
=
split_indx
-
1
;
}
for
(
;
i
!
=
k
;
i
+
=
j
)
{
if
(
i
=
=
newindx
)
{
psize
+
=
nsize
;
node
=
NULL
;
}
else
{
node
=
(
MDB_node
*
)
(
(
char
*
)
mp
+
copy
-
>
mp_ptrs
[
i
]
+
PAGEBASE
)
;
psize
+
=
NODESIZE
+
NODEKSZ
(
node
)
+
sizeof
(
indx_t
)
;
if
(
IS_LEAF
(
mp
)
)
{
if
(
F_ISSET
(
node
-
>
mn_flags
F_BIGDATA
)
)
psize
+
=
sizeof
(
pgno_t
)
;
else
psize
+
=
NODEDSZ
(
node
)
;
}
psize
=
EVEN
(
psize
)
;
}
if
(
psize
>
pmax
|
|
i
=
=
k
-
j
)
{
split_indx
=
i
+
(
j
<
0
)
;
break
;
}
}
}
if
(
split_indx
=
=
newindx
)
{
sepkey
.
mv_size
=
newkey
-
>
mv_size
;
sepkey
.
mv_data
=
newkey
-
>
mv_data
;
}
else
{
node
=
(
MDB_node
*
)
(
(
char
*
)
mp
+
copy
-
>
mp_ptrs
[
split_indx
]
+
PAGEBASE
)
;
sepkey
.
mv_size
=
node
-
>
mn_ksize
;
sepkey
.
mv_data
=
NODEKEY
(
node
)
;
}
}
}
DPRINTF
(
(
"
separator
is
%
d
[
%
s
]
"
split_indx
DKEY
(
&
sepkey
)
)
)
;
if
(
SIZELEFT
(
mn
.
mc_pg
[
ptop
]
)
<
mdb_branch_size
(
env
&
sepkey
)
)
{
int
snum
=
mc
-
>
mc_snum
;
mn
.
mc_snum
-
-
;
mn
.
mc_top
-
-
;
did_split
=
1
;
WITH_CURSOR_TRACKING
(
mn
rc
=
mdb_page_split
(
&
mn
&
sepkey
NULL
rp
-
>
mp_pgno
0
)
)
;
if
(
rc
)
goto
done
;
if
(
mc
-
>
mc_snum
>
snum
)
{
ptop
+
+
;
}
if
(
mn
.
mc_pg
[
ptop
]
!
=
mc
-
>
mc_pg
[
ptop
]
&
&
mc
-
>
mc_ki
[
ptop
]
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
ptop
]
)
)
{
for
(
i
=
0
;
i
<
ptop
;
i
+
+
)
{
mc
-
>
mc_pg
[
i
]
=
mn
.
mc_pg
[
i
]
;
mc
-
>
mc_ki
[
i
]
=
mn
.
mc_ki
[
i
]
;
}
mc
-
>
mc_pg
[
ptop
]
=
mn
.
mc_pg
[
ptop
]
;
if
(
mn
.
mc_ki
[
ptop
]
)
{
mc
-
>
mc_ki
[
ptop
]
=
mn
.
mc_ki
[
ptop
]
-
1
;
}
else
{
mc
-
>
mc_ki
[
ptop
]
=
mn
.
mc_ki
[
ptop
]
;
mdb_cursor_sibling
(
mc
0
)
;
}
}
}
else
{
mn
.
mc_top
-
-
;
rc
=
mdb_node_add
(
&
mn
mn
.
mc_ki
[
ptop
]
&
sepkey
NULL
rp
-
>
mp_pgno
0
)
;
mn
.
mc_top
+
+
;
}
if
(
rc
!
=
MDB_SUCCESS
)
{
goto
done
;
}
if
(
nflags
&
MDB_APPEND
)
{
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
rp
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
0
;
rc
=
mdb_node_add
(
mc
0
newkey
newdata
newpgno
nflags
)
;
if
(
rc
)
goto
done
;
for
(
i
=
0
;
i
<
mc
-
>
mc_top
;
i
+
+
)
mc
-
>
mc_ki
[
i
]
=
mn
.
mc_ki
[
i
]
;
}
else
if
(
!
IS_LEAF2
(
mp
)
)
{
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
rp
;
i
=
split_indx
;
j
=
0
;
do
{
if
(
i
=
=
newindx
)
{
rkey
.
mv_data
=
newkey
-
>
mv_data
;
rkey
.
mv_size
=
newkey
-
>
mv_size
;
if
(
IS_LEAF
(
mp
)
)
{
rdata
=
newdata
;
}
else
pgno
=
newpgno
;
flags
=
nflags
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
j
;
}
else
{
node
=
(
MDB_node
*
)
(
(
char
*
)
mp
+
copy
-
>
mp_ptrs
[
i
]
+
PAGEBASE
)
;
rkey
.
mv_data
=
NODEKEY
(
node
)
;
rkey
.
mv_size
=
node
-
>
mn_ksize
;
if
(
IS_LEAF
(
mp
)
)
{
xdata
.
mv_data
=
NODEDATA
(
node
)
;
xdata
.
mv_size
=
NODEDSZ
(
node
)
;
rdata
=
&
xdata
;
}
else
pgno
=
NODEPGNO
(
node
)
;
flags
=
node
-
>
mn_flags
;
}
if
(
!
IS_LEAF
(
mp
)
&
&
j
=
=
0
)
{
rkey
.
mv_size
=
0
;
}
rc
=
mdb_node_add
(
mc
j
&
rkey
rdata
pgno
flags
)
;
if
(
rc
)
goto
done
;
if
(
i
=
=
nkeys
)
{
i
=
0
;
j
=
0
;
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
copy
;
}
else
{
i
+
+
;
j
+
+
;
}
}
while
(
i
!
=
split_indx
)
;
nkeys
=
NUMKEYS
(
copy
)
;
for
(
i
=
0
;
i
<
nkeys
;
i
+
+
)
mp
-
>
mp_ptrs
[
i
]
=
copy
-
>
mp_ptrs
[
i
]
;
mp
-
>
mp_lower
=
copy
-
>
mp_lower
;
mp
-
>
mp_upper
=
copy
-
>
mp_upper
;
memcpy
(
NODEPTR
(
mp
nkeys
-
1
)
NODEPTR
(
copy
nkeys
-
1
)
env
-
>
me_psize
-
copy
-
>
mp_upper
-
PAGEBASE
)
;
if
(
newindx
<
split_indx
)
{
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
mp
;
}
else
{
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
rp
;
mc
-
>
mc_ki
[
ptop
]
+
+
;
if
(
mn
.
mc_pg
[
ptop
]
!
=
mc
-
>
mc_pg
[
ptop
]
&
&
mc
-
>
mc_ki
[
ptop
]
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
ptop
]
)
)
{
for
(
i
=
0
;
i
<
=
ptop
;
i
+
+
)
{
mc
-
>
mc_pg
[
i
]
=
mn
.
mc_pg
[
i
]
;
mc
-
>
mc_ki
[
i
]
=
mn
.
mc_ki
[
i
]
;
}
}
}
if
(
nflags
&
MDB_RESERVE
)
{
node
=
NODEPTR
(
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
if
(
!
(
node
-
>
mn_flags
&
F_BIGDATA
)
)
newdata
-
>
mv_data
=
NODEDATA
(
node
)
;
}
}
else
{
if
(
newindx
>
=
split_indx
)
{
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
=
rp
;
mc
-
>
mc_ki
[
ptop
]
+
+
;
if
(
mn
.
mc_pg
[
ptop
]
!
=
mc
-
>
mc_pg
[
ptop
]
&
&
mc
-
>
mc_ki
[
ptop
]
>
=
NUMKEYS
(
mc
-
>
mc_pg
[
ptop
]
)
)
{
for
(
i
=
0
;
i
<
=
ptop
;
i
+
+
)
{
mc
-
>
mc_pg
[
i
]
=
mn
.
mc_pg
[
i
]
;
mc
-
>
mc_ki
[
i
]
=
mn
.
mc_ki
[
i
]
;
}
}
}
}
{
MDB_cursor
*
m2
*
m3
;
MDB_dbi
dbi
=
mc
-
>
mc_dbi
;
nkeys
=
NUMKEYS
(
mp
)
;
for
(
m2
=
mc
-
>
mc_txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
{
if
(
mc
-
>
mc_flags
&
C_SUB
)
m3
=
&
m2
-
>
mc_xcursor
-
>
mx_cursor
;
else
m3
=
m2
;
if
(
m3
=
=
mc
)
continue
;
if
(
!
(
m2
-
>
mc_flags
&
m3
-
>
mc_flags
&
C_INITIALIZED
)
)
continue
;
if
(
new_root
)
{
int
k
;
if
(
m3
-
>
mc_pg
[
0
]
!
=
mp
)
continue
;
for
(
k
=
new_root
;
k
>
=
0
;
k
-
-
)
{
m3
-
>
mc_ki
[
k
+
1
]
=
m3
-
>
mc_ki
[
k
]
;
m3
-
>
mc_pg
[
k
+
1
]
=
m3
-
>
mc_pg
[
k
]
;
}
if
(
m3
-
>
mc_ki
[
0
]
>
=
nkeys
)
{
m3
-
>
mc_ki
[
0
]
=
1
;
}
else
{
m3
-
>
mc_ki
[
0
]
=
0
;
}
m3
-
>
mc_pg
[
0
]
=
mc
-
>
mc_pg
[
0
]
;
m3
-
>
mc_snum
+
+
;
m3
-
>
mc_top
+
+
;
}
if
(
m3
-
>
mc_top
>
=
mc
-
>
mc_top
&
&
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
=
=
mp
)
{
if
(
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
newindx
&
&
!
(
nflags
&
MDB_SPLIT_REPLACE
)
)
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
+
+
;
if
(
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
>
=
nkeys
)
{
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
=
rp
;
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
-
=
nkeys
;
for
(
i
=
0
;
i
<
mc
-
>
mc_top
;
i
+
+
)
{
m3
-
>
mc_ki
[
i
]
=
mn
.
mc_ki
[
i
]
;
m3
-
>
mc_pg
[
i
]
=
mn
.
mc_pg
[
i
]
;
}
}
}
else
if
(
!
did_split
&
&
m3
-
>
mc_top
>
=
ptop
&
&
m3
-
>
mc_pg
[
ptop
]
=
=
mc
-
>
mc_pg
[
ptop
]
&
&
m3
-
>
mc_ki
[
ptop
]
>
=
mc
-
>
mc_ki
[
ptop
]
)
{
m3
-
>
mc_ki
[
ptop
]
+
+
;
}
if
(
XCURSOR_INITED
(
m3
)
&
&
IS_LEAF
(
mp
)
)
XCURSOR_REFRESH
(
m3
m3
-
>
mc_pg
[
mc
-
>
mc_top
]
m3
-
>
mc_ki
[
mc
-
>
mc_top
]
)
;
}
}
DPRINTF
(
(
"
mp
left
:
%
d
rp
left
:
%
d
"
SIZELEFT
(
mp
)
SIZELEFT
(
rp
)
)
)
;
done
:
if
(
copy
)
mdb_page_free
(
env
copy
)
;
if
(
rc
)
mc
-
>
mc_txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
return
rc
;
}
int
mdb_put
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_val
*
key
MDB_val
*
data
unsigned
int
flags
)
{
MDB_cursor
mc
;
MDB_xcursor
mx
;
int
rc
;
if
(
!
key
|
|
!
data
|
|
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
if
(
flags
&
~
(
MDB_NOOVERWRITE
|
MDB_NODUPDATA
|
MDB_RESERVE
|
MDB_APPEND
|
MDB_APPENDDUP
)
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
(
MDB_TXN_RDONLY
|
MDB_TXN_BLOCKED
)
)
return
(
txn
-
>
mt_flags
&
MDB_TXN_RDONLY
)
?
EACCES
:
MDB_BAD_TXN
;
mdb_cursor_init
(
&
mc
txn
dbi
&
mx
)
;
mc
.
mc_next
=
txn
-
>
mt_cursors
[
dbi
]
;
txn
-
>
mt_cursors
[
dbi
]
=
&
mc
;
rc
=
mdb_cursor_put
(
&
mc
key
data
flags
)
;
txn
-
>
mt_cursors
[
dbi
]
=
mc
.
mc_next
;
return
rc
;
}
#
ifndef
MDB_WBUF
#
define
MDB_WBUF
(
1024
*
1024
)
#
endif
#
define
MDB_EOF
0x10
/
*
*
<
#
mdb_env_copyfd1
(
)
is
done
reading
*
/
typedef
struct
mdb_copy
{
MDB_env
*
mc_env
;
MDB_txn
*
mc_txn
;
pthread_mutex_t
mc_mutex
;
pthread_cond_t
mc_cond
;
char
*
mc_wbuf
[
2
]
;
char
*
mc_over
[
2
]
;
int
mc_wlen
[
2
]
;
int
mc_olen
[
2
]
;
pgno_t
mc_next_pgno
;
HANDLE
mc_fd
;
int
mc_toggle
;
int
mc_new
;
volatile
int
mc_error
;
}
mdb_copy
;
static
THREAD_RET
ESECT
CALL_CONV
mdb_env_copythr
(
void
*
arg
)
{
mdb_copy
*
my
=
arg
;
char
*
ptr
;
int
toggle
=
0
wsize
rc
;
#
ifdef
_WIN32
DWORD
len
;
#
define
DO_WRITE
(
rc
fd
ptr
w2
len
)
rc
=
WriteFile
(
fd
ptr
w2
&
len
NULL
)
#
else
int
len
;
#
define
DO_WRITE
(
rc
fd
ptr
w2
len
)
len
=
write
(
fd
ptr
w2
)
;
rc
=
(
len
>
=
0
)
#
ifdef
SIGPIPE
sigset_t
set
;
sigemptyset
(
&
set
)
;
sigaddset
(
&
set
SIGPIPE
)
;
if
(
(
rc
=
pthread_sigmask
(
SIG_BLOCK
&
set
NULL
)
)
!
=
0
)
my
-
>
mc_error
=
rc
;
#
endif
#
endif
pthread_mutex_lock
(
&
my
-
>
mc_mutex
)
;
for
(
;
;
)
{
while
(
!
my
-
>
mc_new
)
pthread_cond_wait
(
&
my
-
>
mc_cond
&
my
-
>
mc_mutex
)
;
if
(
my
-
>
mc_new
=
=
0
+
MDB_EOF
)
break
;
wsize
=
my
-
>
mc_wlen
[
toggle
]
;
ptr
=
my
-
>
mc_wbuf
[
toggle
]
;
again
:
rc
=
MDB_SUCCESS
;
while
(
wsize
>
0
&
&
!
my
-
>
mc_error
)
{
DO_WRITE
(
rc
my
-
>
mc_fd
ptr
wsize
len
)
;
if
(
!
rc
)
{
rc
=
ErrCode
(
)
;
#
if
defined
(
SIGPIPE
)
&
&
!
defined
(
_WIN32
)
if
(
rc
=
=
EPIPE
)
{
int
tmp
;
sigwait
(
&
set
&
tmp
)
;
}
#
endif
break
;
}
else
if
(
len
>
0
)
{
rc
=
MDB_SUCCESS
;
ptr
+
=
len
;
wsize
-
=
len
;
continue
;
}
else
{
rc
=
EIO
;
break
;
}
}
if
(
rc
)
{
my
-
>
mc_error
=
rc
;
}
if
(
my
-
>
mc_olen
[
toggle
]
)
{
wsize
=
my
-
>
mc_olen
[
toggle
]
;
ptr
=
my
-
>
mc_over
[
toggle
]
;
my
-
>
mc_olen
[
toggle
]
=
0
;
goto
again
;
}
my
-
>
mc_wlen
[
toggle
]
=
0
;
toggle
^
=
1
;
my
-
>
mc_new
-
-
;
pthread_cond_signal
(
&
my
-
>
mc_cond
)
;
}
pthread_mutex_unlock
(
&
my
-
>
mc_mutex
)
;
return
(
THREAD_RET
)
0
;
#
undef
DO_WRITE
}
static
int
ESECT
mdb_env_cthr_toggle
(
mdb_copy
*
my
int
adjust
)
{
pthread_mutex_lock
(
&
my
-
>
mc_mutex
)
;
my
-
>
mc_new
+
=
adjust
;
pthread_cond_signal
(
&
my
-
>
mc_cond
)
;
while
(
my
-
>
mc_new
&
2
)
pthread_cond_wait
(
&
my
-
>
mc_cond
&
my
-
>
mc_mutex
)
;
pthread_mutex_unlock
(
&
my
-
>
mc_mutex
)
;
my
-
>
mc_toggle
^
=
(
adjust
&
1
)
;
my
-
>
mc_wlen
[
my
-
>
mc_toggle
]
=
0
;
return
my
-
>
mc_error
;
}
static
int
ESECT
mdb_env_cwalk
(
mdb_copy
*
my
pgno_t
*
pg
int
flags
)
{
MDB_cursor
mc
=
{
0
}
;
MDB_node
*
ni
;
MDB_page
*
mo
*
mp
*
leaf
;
char
*
buf
*
ptr
;
int
rc
toggle
;
unsigned
int
i
;
if
(
*
pg
=
=
P_INVALID
)
return
MDB_SUCCESS
;
mc
.
mc_snum
=
1
;
mc
.
mc_txn
=
my
-
>
mc_txn
;
rc
=
mdb_page_get
(
&
mc
*
pg
&
mc
.
mc_pg
[
0
]
NULL
)
;
if
(
rc
)
return
rc
;
rc
=
mdb_page_search_root
(
&
mc
NULL
MDB_PS_FIRST
)
;
if
(
rc
)
return
rc
;
buf
=
ptr
=
malloc
(
my
-
>
mc_env
-
>
me_psize
*
mc
.
mc_snum
)
;
if
(
buf
=
=
NULL
)
return
ENOMEM
;
for
(
i
=
0
;
i
<
mc
.
mc_top
;
i
+
+
)
{
mdb_page_copy
(
(
MDB_page
*
)
ptr
mc
.
mc_pg
[
i
]
my
-
>
mc_env
-
>
me_psize
)
;
mc
.
mc_pg
[
i
]
=
(
MDB_page
*
)
ptr
;
ptr
+
=
my
-
>
mc_env
-
>
me_psize
;
}
leaf
=
(
MDB_page
*
)
ptr
;
toggle
=
my
-
>
mc_toggle
;
while
(
mc
.
mc_snum
>
0
)
{
unsigned
n
;
mp
=
mc
.
mc_pg
[
mc
.
mc_top
]
;
n
=
NUMKEYS
(
mp
)
;
if
(
IS_LEAF
(
mp
)
)
{
if
(
!
IS_LEAF2
(
mp
)
&
&
!
(
flags
&
F_DUPDATA
)
)
{
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
ni
=
NODEPTR
(
mp
i
)
;
if
(
ni
-
>
mn_flags
&
F_BIGDATA
)
{
MDB_page
*
omp
;
pgno_t
pg
;
if
(
mp
!
=
leaf
)
{
mc
.
mc_pg
[
mc
.
mc_top
]
=
leaf
;
mdb_page_copy
(
leaf
mp
my
-
>
mc_env
-
>
me_psize
)
;
mp
=
leaf
;
ni
=
NODEPTR
(
mp
i
)
;
}
memcpy
(
&
pg
NODEDATA
(
ni
)
sizeof
(
pg
)
)
;
memcpy
(
NODEDATA
(
ni
)
&
my
-
>
mc_next_pgno
sizeof
(
pgno_t
)
)
;
rc
=
mdb_page_get
(
&
mc
pg
&
omp
NULL
)
;
if
(
rc
)
goto
done
;
if
(
my
-
>
mc_wlen
[
toggle
]
>
=
MDB_WBUF
)
{
rc
=
mdb_env_cthr_toggle
(
my
1
)
;
if
(
rc
)
goto
done
;
toggle
=
my
-
>
mc_toggle
;
}
mo
=
(
MDB_page
*
)
(
my
-
>
mc_wbuf
[
toggle
]
+
my
-
>
mc_wlen
[
toggle
]
)
;
memcpy
(
mo
omp
my
-
>
mc_env
-
>
me_psize
)
;
mo
-
>
mp_pgno
=
my
-
>
mc_next_pgno
;
my
-
>
mc_next_pgno
+
=
omp
-
>
mp_pages
;
my
-
>
mc_wlen
[
toggle
]
+
=
my
-
>
mc_env
-
>
me_psize
;
if
(
omp
-
>
mp_pages
>
1
)
{
my
-
>
mc_olen
[
toggle
]
=
my
-
>
mc_env
-
>
me_psize
*
(
omp
-
>
mp_pages
-
1
)
;
my
-
>
mc_over
[
toggle
]
=
(
char
*
)
omp
+
my
-
>
mc_env
-
>
me_psize
;
rc
=
mdb_env_cthr_toggle
(
my
1
)
;
if
(
rc
)
goto
done
;
toggle
=
my
-
>
mc_toggle
;
}
}
else
if
(
ni
-
>
mn_flags
&
F_SUBDATA
)
{
MDB_db
db
;
if
(
mp
!
=
leaf
)
{
mc
.
mc_pg
[
mc
.
mc_top
]
=
leaf
;
mdb_page_copy
(
leaf
mp
my
-
>
mc_env
-
>
me_psize
)
;
mp
=
leaf
;
ni
=
NODEPTR
(
mp
i
)
;
}
memcpy
(
&
db
NODEDATA
(
ni
)
sizeof
(
db
)
)
;
my
-
>
mc_toggle
=
toggle
;
rc
=
mdb_env_cwalk
(
my
&
db
.
md_root
ni
-
>
mn_flags
&
F_DUPDATA
)
;
if
(
rc
)
goto
done
;
toggle
=
my
-
>
mc_toggle
;
memcpy
(
NODEDATA
(
ni
)
&
db
sizeof
(
db
)
)
;
}
}
}
}
else
{
mc
.
mc_ki
[
mc
.
mc_top
]
+
+
;
if
(
mc
.
mc_ki
[
mc
.
mc_top
]
<
n
)
{
pgno_t
pg
;
again
:
ni
=
NODEPTR
(
mp
mc
.
mc_ki
[
mc
.
mc_top
]
)
;
pg
=
NODEPGNO
(
ni
)
;
rc
=
mdb_page_get
(
&
mc
pg
&
mp
NULL
)
;
if
(
rc
)
goto
done
;
mc
.
mc_top
+
+
;
mc
.
mc_snum
+
+
;
mc
.
mc_ki
[
mc
.
mc_top
]
=
0
;
if
(
IS_BRANCH
(
mp
)
)
{
mdb_page_copy
(
mc
.
mc_pg
[
mc
.
mc_top
]
mp
my
-
>
mc_env
-
>
me_psize
)
;
goto
again
;
}
else
mc
.
mc_pg
[
mc
.
mc_top
]
=
mp
;
continue
;
}
}
if
(
my
-
>
mc_wlen
[
toggle
]
>
=
MDB_WBUF
)
{
rc
=
mdb_env_cthr_toggle
(
my
1
)
;
if
(
rc
)
goto
done
;
toggle
=
my
-
>
mc_toggle
;
}
mo
=
(
MDB_page
*
)
(
my
-
>
mc_wbuf
[
toggle
]
+
my
-
>
mc_wlen
[
toggle
]
)
;
mdb_page_copy
(
mo
mp
my
-
>
mc_env
-
>
me_psize
)
;
mo
-
>
mp_pgno
=
my
-
>
mc_next_pgno
+
+
;
my
-
>
mc_wlen
[
toggle
]
+
=
my
-
>
mc_env
-
>
me_psize
;
if
(
mc
.
mc_top
)
{
ni
=
NODEPTR
(
mc
.
mc_pg
[
mc
.
mc_top
-
1
]
mc
.
mc_ki
[
mc
.
mc_top
-
1
]
)
;
SETPGNO
(
ni
mo
-
>
mp_pgno
)
;
mdb_cursor_pop
(
&
mc
)
;
}
else
{
*
pg
=
mo
-
>
mp_pgno
;
break
;
}
}
done
:
free
(
buf
)
;
return
rc
;
}
static
int
ESECT
mdb_env_copyfd1
(
MDB_env
*
env
HANDLE
fd
)
{
MDB_meta
*
mm
;
MDB_page
*
mp
;
mdb_copy
my
=
{
0
}
;
MDB_txn
*
txn
=
NULL
;
pthread_t
thr
;
pgno_t
root
new_root
;
int
rc
=
MDB_SUCCESS
;
#
ifdef
_WIN32
if
(
!
(
my
.
mc_mutex
=
CreateMutex
(
NULL
FALSE
NULL
)
)
|
|
!
(
my
.
mc_cond
=
CreateEvent
(
NULL
FALSE
FALSE
NULL
)
)
)
{
rc
=
ErrCode
(
)
;
goto
done
;
}
my
.
mc_wbuf
[
0
]
=
_aligned_malloc
(
MDB_WBUF
*
2
env
-
>
me_os_psize
)
;
if
(
my
.
mc_wbuf
[
0
]
=
=
NULL
)
{
rc
=
ERROR_NOT_ENOUGH_MEMORY
;
goto
done
;
}
#
else
if
(
(
rc
=
pthread_mutex_init
(
&
my
.
mc_mutex
NULL
)
)
!
=
0
)
return
rc
;
if
(
(
rc
=
pthread_cond_init
(
&
my
.
mc_cond
NULL
)
)
!
=
0
)
goto
done2
;
#
ifdef
HAVE_MEMALIGN
my
.
mc_wbuf
[
0
]
=
memalign
(
env
-
>
me_os_psize
MDB_WBUF
*
2
)
;
if
(
my
.
mc_wbuf
[
0
]
=
=
NULL
)
{
rc
=
errno
;
goto
done
;
}
#
else
{
void
*
p
;
if
(
(
rc
=
posix_memalign
(
&
p
env
-
>
me_os_psize
MDB_WBUF
*
2
)
)
!
=
0
)
goto
done
;
my
.
mc_wbuf
[
0
]
=
p
;
}
#
endif
#
endif
memset
(
my
.
mc_wbuf
[
0
]
0
MDB_WBUF
*
2
)
;
my
.
mc_wbuf
[
1
]
=
my
.
mc_wbuf
[
0
]
+
MDB_WBUF
;
my
.
mc_next_pgno
=
NUM_METAS
;
my
.
mc_env
=
env
;
my
.
mc_fd
=
fd
;
rc
=
THREAD_CREATE
(
thr
mdb_env_copythr
&
my
)
;
if
(
rc
)
goto
done
;
rc
=
mdb_txn_begin
(
env
NULL
MDB_RDONLY
&
txn
)
;
if
(
rc
)
goto
finish
;
mp
=
(
MDB_page
*
)
my
.
mc_wbuf
[
0
]
;
memset
(
mp
0
NUM_METAS
*
env
-
>
me_psize
)
;
mp
-
>
mp_pgno
=
0
;
mp
-
>
mp_flags
=
P_META
;
mm
=
(
MDB_meta
*
)
METADATA
(
mp
)
;
mdb_env_init_meta0
(
env
mm
)
;
mm
-
>
mm_address
=
env
-
>
me_metas
[
0
]
-
>
mm_address
;
mp
=
(
MDB_page
*
)
(
my
.
mc_wbuf
[
0
]
+
env
-
>
me_psize
)
;
mp
-
>
mp_pgno
=
1
;
mp
-
>
mp_flags
=
P_META
;
*
(
MDB_meta
*
)
METADATA
(
mp
)
=
*
mm
;
mm
=
(
MDB_meta
*
)
METADATA
(
mp
)
;
root
=
new_root
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_root
;
if
(
root
!
=
P_INVALID
)
{
MDB_ID
freecount
=
0
;
MDB_cursor
mc
;
MDB_val
key
data
;
mdb_cursor_init
(
&
mc
txn
FREE_DBI
NULL
)
;
while
(
(
rc
=
mdb_cursor_get
(
&
mc
&
key
&
data
MDB_NEXT
)
)
=
=
0
)
freecount
+
=
*
(
MDB_ID
*
)
data
.
mv_data
;
if
(
rc
!
=
MDB_NOTFOUND
)
goto
finish
;
freecount
+
=
txn
-
>
mt_dbs
[
FREE_DBI
]
.
md_branch_pages
+
txn
-
>
mt_dbs
[
FREE_DBI
]
.
md_leaf_pages
+
txn
-
>
mt_dbs
[
FREE_DBI
]
.
md_overflow_pages
;
new_root
=
txn
-
>
mt_next_pgno
-
1
-
freecount
;
mm
-
>
mm_last_pg
=
new_root
;
mm
-
>
mm_dbs
[
MAIN_DBI
]
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
;
mm
-
>
mm_dbs
[
MAIN_DBI
]
.
md_root
=
new_root
;
}
else
{
mm
-
>
mm_dbs
[
MAIN_DBI
]
.
md_flags
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_flags
;
}
if
(
root
!
=
P_INVALID
|
|
mm
-
>
mm_dbs
[
MAIN_DBI
]
.
md_flags
)
{
mm
-
>
mm_txnid
=
1
;
}
my
.
mc_wlen
[
0
]
=
env
-
>
me_psize
*
NUM_METAS
;
my
.
mc_txn
=
txn
;
rc
=
mdb_env_cwalk
(
&
my
&
root
0
)
;
if
(
rc
=
=
MDB_SUCCESS
&
&
root
!
=
new_root
)
{
rc
=
MDB_INCOMPATIBLE
;
}
finish
:
if
(
rc
)
my
.
mc_error
=
rc
;
mdb_env_cthr_toggle
(
&
my
1
|
MDB_EOF
)
;
rc
=
THREAD_FINISH
(
thr
)
;
mdb_txn_abort
(
txn
)
;
done
:
#
ifdef
_WIN32
if
(
my
.
mc_wbuf
[
0
]
)
_aligned_free
(
my
.
mc_wbuf
[
0
]
)
;
if
(
my
.
mc_cond
)
CloseHandle
(
my
.
mc_cond
)
;
if
(
my
.
mc_mutex
)
CloseHandle
(
my
.
mc_mutex
)
;
#
else
free
(
my
.
mc_wbuf
[
0
]
)
;
pthread_cond_destroy
(
&
my
.
mc_cond
)
;
done2
:
pthread_mutex_destroy
(
&
my
.
mc_mutex
)
;
#
endif
return
rc
?
rc
:
my
.
mc_error
;
}
static
int
ESECT
mdb_env_copyfd0
(
MDB_env
*
env
HANDLE
fd
)
{
MDB_txn
*
txn
=
NULL
;
mdb_mutexref_t
wmutex
=
NULL
;
int
rc
;
size_t
wsize
w3
;
char
*
ptr
;
#
ifdef
_WIN32
DWORD
len
w2
;
#
define
DO_WRITE
(
rc
fd
ptr
w2
len
)
rc
=
WriteFile
(
fd
ptr
w2
&
len
NULL
)
#
else
ssize_t
len
;
size_t
w2
;
#
define
DO_WRITE
(
rc
fd
ptr
w2
len
)
len
=
write
(
fd
ptr
w2
)
;
rc
=
(
len
>
=
0
)
#
endif
rc
=
mdb_txn_begin
(
env
NULL
MDB_RDONLY
&
txn
)
;
if
(
rc
)
return
rc
;
if
(
env
-
>
me_txns
)
{
mdb_txn_end
(
txn
MDB_END_RESET_TMP
)
;
wmutex
=
env
-
>
me_wmutex
;
if
(
LOCK_MUTEX
(
rc
env
wmutex
)
)
goto
leave
;
rc
=
mdb_txn_renew0
(
txn
)
;
if
(
rc
)
{
UNLOCK_MUTEX
(
wmutex
)
;
goto
leave
;
}
}
wsize
=
env
-
>
me_psize
*
NUM_METAS
;
ptr
=
env
-
>
me_map
;
w2
=
wsize
;
while
(
w2
>
0
)
{
DO_WRITE
(
rc
fd
ptr
w2
len
)
;
if
(
!
rc
)
{
rc
=
ErrCode
(
)
;
break
;
}
else
if
(
len
>
0
)
{
rc
=
MDB_SUCCESS
;
ptr
+
=
len
;
w2
-
=
len
;
continue
;
}
else
{
rc
=
EIO
;
break
;
}
}
if
(
wmutex
)
UNLOCK_MUTEX
(
wmutex
)
;
if
(
rc
)
goto
leave
;
w3
=
txn
-
>
mt_next_pgno
*
env
-
>
me_psize
;
{
size_t
fsize
=
0
;
if
(
(
rc
=
mdb_fsize
(
env
-
>
me_fd
&
fsize
)
)
)
goto
leave
;
if
(
w3
>
fsize
)
w3
=
fsize
;
}
wsize
=
w3
-
wsize
;
while
(
wsize
>
0
)
{
if
(
wsize
>
MAX_WRITE
)
w2
=
MAX_WRITE
;
else
w2
=
wsize
;
DO_WRITE
(
rc
fd
ptr
w2
len
)
;
if
(
!
rc
)
{
rc
=
ErrCode
(
)
;
break
;
}
else
if
(
len
>
0
)
{
rc
=
MDB_SUCCESS
;
ptr
+
=
len
;
wsize
-
=
len
;
continue
;
}
else
{
rc
=
EIO
;
break
;
}
}
leave
:
mdb_txn_abort
(
txn
)
;
return
rc
;
}
int
ESECT
mdb_env_copyfd2
(
MDB_env
*
env
HANDLE
fd
unsigned
int
flags
)
{
if
(
flags
&
MDB_CP_COMPACT
)
return
mdb_env_copyfd1
(
env
fd
)
;
else
return
mdb_env_copyfd0
(
env
fd
)
;
}
int
ESECT
mdb_env_copyfd
(
MDB_env
*
env
HANDLE
fd
)
{
return
mdb_env_copyfd2
(
env
fd
0
)
;
}
int
ESECT
mdb_env_copy2
(
MDB_env
*
env
const
char
*
path
unsigned
int
flags
)
{
int
rc
;
MDB_name
fname
;
HANDLE
newfd
=
INVALID_HANDLE_VALUE
;
rc
=
mdb_fname_init
(
path
env
-
>
me_flags
|
MDB_NOLOCK
&
fname
)
;
if
(
rc
=
=
MDB_SUCCESS
)
{
rc
=
mdb_fopen
(
env
&
fname
MDB_O_COPY
0666
&
newfd
)
;
mdb_fname_destroy
(
fname
)
;
}
if
(
rc
=
=
MDB_SUCCESS
)
{
rc
=
mdb_env_copyfd2
(
env
newfd
flags
)
;
if
(
close
(
newfd
)
<
0
&
&
rc
=
=
MDB_SUCCESS
)
rc
=
ErrCode
(
)
;
}
return
rc
;
}
int
ESECT
mdb_env_copy
(
MDB_env
*
env
const
char
*
path
)
{
return
mdb_env_copy2
(
env
path
0
)
;
}
int
ESECT
mdb_env_set_flags
(
MDB_env
*
env
unsigned
int
flag
int
onoff
)
{
if
(
flag
&
~
CHANGEABLE
)
return
EINVAL
;
if
(
onoff
)
env
-
>
me_flags
|
=
flag
;
else
env
-
>
me_flags
&
=
~
flag
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_get_flags
(
MDB_env
*
env
unsigned
int
*
arg
)
{
if
(
!
env
|
|
!
arg
)
return
EINVAL
;
*
arg
=
env
-
>
me_flags
&
(
CHANGEABLE
|
CHANGELESS
)
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_set_userctx
(
MDB_env
*
env
void
*
ctx
)
{
if
(
!
env
)
return
EINVAL
;
env
-
>
me_userctx
=
ctx
;
return
MDB_SUCCESS
;
}
void
*
ESECT
mdb_env_get_userctx
(
MDB_env
*
env
)
{
return
env
?
env
-
>
me_userctx
:
NULL
;
}
int
ESECT
mdb_env_set_assert
(
MDB_env
*
env
MDB_assert_func
*
func
)
{
if
(
!
env
)
return
EINVAL
;
#
ifndef
NDEBUG
env
-
>
me_assert_func
=
func
;
#
endif
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_get_path
(
MDB_env
*
env
const
char
*
*
arg
)
{
if
(
!
env
|
|
!
arg
)
return
EINVAL
;
*
arg
=
env
-
>
me_path
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_get_fd
(
MDB_env
*
env
mdb_filehandle_t
*
arg
)
{
if
(
!
env
|
|
!
arg
)
return
EINVAL
;
*
arg
=
env
-
>
me_fd
;
return
MDB_SUCCESS
;
}
static
int
ESECT
mdb_stat0
(
MDB_env
*
env
MDB_db
*
db
MDB_stat
*
arg
)
{
arg
-
>
ms_psize
=
env
-
>
me_psize
;
arg
-
>
ms_depth
=
db
-
>
md_depth
;
arg
-
>
ms_branch_pages
=
db
-
>
md_branch_pages
;
arg
-
>
ms_leaf_pages
=
db
-
>
md_leaf_pages
;
arg
-
>
ms_overflow_pages
=
db
-
>
md_overflow_pages
;
arg
-
>
ms_entries
=
db
-
>
md_entries
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_stat
(
MDB_env
*
env
MDB_stat
*
arg
)
{
MDB_meta
*
meta
;
if
(
env
=
=
NULL
|
|
arg
=
=
NULL
)
return
EINVAL
;
meta
=
mdb_env_pick_meta
(
env
)
;
return
mdb_stat0
(
env
&
meta
-
>
mm_dbs
[
MAIN_DBI
]
arg
)
;
}
int
ESECT
mdb_env_info
(
MDB_env
*
env
MDB_envinfo
*
arg
)
{
MDB_meta
*
meta
;
if
(
env
=
=
NULL
|
|
arg
=
=
NULL
)
return
EINVAL
;
meta
=
mdb_env_pick_meta
(
env
)
;
arg
-
>
me_mapaddr
=
meta
-
>
mm_address
;
arg
-
>
me_last_pgno
=
meta
-
>
mm_last_pg
;
arg
-
>
me_last_txnid
=
meta
-
>
mm_txnid
;
arg
-
>
me_mapsize
=
env
-
>
me_mapsize
;
arg
-
>
me_maxreaders
=
env
-
>
me_maxreaders
;
arg
-
>
me_numreaders
=
env
-
>
me_txns
?
env
-
>
me_txns
-
>
mti_numreaders
:
0
;
return
MDB_SUCCESS
;
}
static
void
mdb_default_cmp
(
MDB_txn
*
txn
MDB_dbi
dbi
)
{
uint16_t
f
=
txn
-
>
mt_dbs
[
dbi
]
.
md_flags
;
txn
-
>
mt_dbxs
[
dbi
]
.
md_cmp
=
(
f
&
MDB_REVERSEKEY
)
?
mdb_cmp_memnr
:
(
f
&
MDB_INTEGERKEY
)
?
mdb_cmp_cint
:
mdb_cmp_memn
;
txn
-
>
mt_dbxs
[
dbi
]
.
md_dcmp
=
!
(
f
&
MDB_DUPSORT
)
?
0
:
(
(
f
&
MDB_INTEGERDUP
)
?
(
(
f
&
MDB_DUPFIXED
)
?
mdb_cmp_int
:
mdb_cmp_cint
)
:
(
(
f
&
MDB_REVERSEDUP
)
?
mdb_cmp_memnr
:
mdb_cmp_memn
)
)
;
}
int
mdb_dbi_open
(
MDB_txn
*
txn
const
char
*
name
unsigned
int
flags
MDB_dbi
*
dbi
)
{
MDB_val
key
data
;
MDB_dbi
i
;
MDB_cursor
mc
;
MDB_db
dummy
;
int
rc
dbflag
exact
;
unsigned
int
unused
=
0
seq
;
char
*
namedup
;
size_t
len
;
if
(
flags
&
~
VALID_FLAGS
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
if
(
!
name
)
{
*
dbi
=
MAIN_DBI
;
if
(
flags
&
PERSISTENT_FLAGS
)
{
uint16_t
f2
=
flags
&
PERSISTENT_FLAGS
;
if
(
(
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_flags
|
f2
)
!
=
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_flags
)
{
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_flags
|
=
f2
;
txn
-
>
mt_flags
|
=
MDB_TXN_DIRTY
;
}
}
mdb_default_cmp
(
txn
MAIN_DBI
)
;
return
MDB_SUCCESS
;
}
if
(
txn
-
>
mt_dbxs
[
MAIN_DBI
]
.
md_cmp
=
=
NULL
)
{
mdb_default_cmp
(
txn
MAIN_DBI
)
;
}
len
=
strlen
(
name
)
;
for
(
i
=
CORE_DBS
;
i
<
txn
-
>
mt_numdbs
;
i
+
+
)
{
if
(
!
txn
-
>
mt_dbxs
[
i
]
.
md_name
.
mv_size
)
{
if
(
!
unused
)
unused
=
i
;
continue
;
}
if
(
len
=
=
txn
-
>
mt_dbxs
[
i
]
.
md_name
.
mv_size
&
&
!
strncmp
(
name
txn
-
>
mt_dbxs
[
i
]
.
md_name
.
mv_data
len
)
)
{
*
dbi
=
i
;
return
MDB_SUCCESS
;
}
}
if
(
!
unused
&
&
txn
-
>
mt_numdbs
>
=
txn
-
>
mt_env
-
>
me_maxdbs
)
return
MDB_DBS_FULL
;
if
(
txn
-
>
mt_dbs
[
MAIN_DBI
]
.
md_flags
&
(
MDB_DUPSORT
|
MDB_INTEGERKEY
)
)
return
(
flags
&
MDB_CREATE
)
?
MDB_INCOMPATIBLE
:
MDB_NOTFOUND
;
dbflag
=
DB_NEW
|
DB_VALID
|
DB_USRVALID
;
exact
=
0
;
key
.
mv_size
=
len
;
key
.
mv_data
=
(
void
*
)
name
;
mdb_cursor_init
(
&
mc
txn
MAIN_DBI
NULL
)
;
rc
=
mdb_cursor_set
(
&
mc
&
key
&
data
MDB_SET
&
exact
)
;
if
(
rc
=
=
MDB_SUCCESS
)
{
MDB_node
*
node
=
NODEPTR
(
mc
.
mc_pg
[
mc
.
mc_top
]
mc
.
mc_ki
[
mc
.
mc_top
]
)
;
if
(
(
node
-
>
mn_flags
&
(
F_DUPDATA
|
F_SUBDATA
)
)
!
=
F_SUBDATA
)
return
MDB_INCOMPATIBLE
;
}
else
if
(
!
(
rc
=
=
MDB_NOTFOUND
&
&
(
flags
&
MDB_CREATE
)
)
)
{
return
rc
;
}
if
(
(
namedup
=
strdup
(
name
)
)
=
=
NULL
)
return
ENOMEM
;
if
(
rc
)
{
data
.
mv_size
=
sizeof
(
MDB_db
)
;
data
.
mv_data
=
&
dummy
;
memset
(
&
dummy
0
sizeof
(
dummy
)
)
;
dummy
.
md_root
=
P_INVALID
;
dummy
.
md_flags
=
flags
&
PERSISTENT_FLAGS
;
WITH_CURSOR_TRACKING
(
mc
rc
=
mdb_cursor_put
(
&
mc
&
key
&
data
F_SUBDATA
)
)
;
dbflag
|
=
DB_DIRTY
;
}
if
(
rc
)
{
free
(
namedup
)
;
}
else
{
unsigned
int
slot
=
unused
?
unused
:
txn
-
>
mt_numdbs
;
txn
-
>
mt_dbxs
[
slot
]
.
md_name
.
mv_data
=
namedup
;
txn
-
>
mt_dbxs
[
slot
]
.
md_name
.
mv_size
=
len
;
txn
-
>
mt_dbxs
[
slot
]
.
md_rel
=
NULL
;
txn
-
>
mt_dbflags
[
slot
]
=
dbflag
;
seq
=
+
+
txn
-
>
mt_env
-
>
me_dbiseqs
[
slot
]
;
txn
-
>
mt_dbiseqs
[
slot
]
=
seq
;
memcpy
(
&
txn
-
>
mt_dbs
[
slot
]
data
.
mv_data
sizeof
(
MDB_db
)
)
;
*
dbi
=
slot
;
mdb_default_cmp
(
txn
slot
)
;
if
(
!
unused
)
{
txn
-
>
mt_numdbs
+
+
;
}
}
return
rc
;
}
int
ESECT
mdb_stat
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_stat
*
arg
)
{
if
(
!
arg
|
|
!
TXN_DBI_EXIST
(
txn
dbi
DB_VALID
)
)
return
EINVAL
;
if
(
txn
-
>
mt_flags
&
MDB_TXN_BLOCKED
)
return
MDB_BAD_TXN
;
if
(
txn
-
>
mt_dbflags
[
dbi
]
&
DB_STALE
)
{
MDB_cursor
mc
;
MDB_xcursor
mx
;
mdb_cursor_init
(
&
mc
txn
dbi
&
mx
)
;
}
return
mdb_stat0
(
txn
-
>
mt_env
&
txn
-
>
mt_dbs
[
dbi
]
arg
)
;
}
void
mdb_dbi_close
(
MDB_env
*
env
MDB_dbi
dbi
)
{
char
*
ptr
;
if
(
dbi
<
CORE_DBS
|
|
dbi
>
=
env
-
>
me_maxdbs
)
return
;
ptr
=
env
-
>
me_dbxs
[
dbi
]
.
md_name
.
mv_data
;
if
(
ptr
)
{
env
-
>
me_dbxs
[
dbi
]
.
md_name
.
mv_data
=
NULL
;
env
-
>
me_dbxs
[
dbi
]
.
md_name
.
mv_size
=
0
;
env
-
>
me_dbflags
[
dbi
]
=
0
;
env
-
>
me_dbiseqs
[
dbi
]
+
+
;
free
(
ptr
)
;
}
}
int
mdb_dbi_flags
(
MDB_txn
*
txn
MDB_dbi
dbi
unsigned
int
*
flags
)
{
if
(
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
*
flags
=
txn
-
>
mt_dbs
[
dbi
]
.
md_flags
&
PERSISTENT_FLAGS
;
return
MDB_SUCCESS
;
}
static
int
mdb_drop0
(
MDB_cursor
*
mc
int
subs
)
{
int
rc
;
rc
=
mdb_page_search
(
mc
NULL
MDB_PS_FIRST
)
;
if
(
rc
=
=
MDB_SUCCESS
)
{
MDB_txn
*
txn
=
mc
-
>
mc_txn
;
MDB_node
*
ni
;
MDB_cursor
mx
;
unsigned
int
i
;
if
(
(
mc
-
>
mc_flags
&
C_SUB
)
|
|
(
!
subs
&
&
!
mc
-
>
mc_db
-
>
md_overflow_pages
)
)
mdb_cursor_pop
(
mc
)
;
mdb_cursor_copy
(
mc
&
mx
)
;
while
(
mc
-
>
mc_snum
>
0
)
{
MDB_page
*
mp
=
mc
-
>
mc_pg
[
mc
-
>
mc_top
]
;
unsigned
n
=
NUMKEYS
(
mp
)
;
if
(
IS_LEAF
(
mp
)
)
{
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
ni
=
NODEPTR
(
mp
i
)
;
if
(
ni
-
>
mn_flags
&
F_BIGDATA
)
{
MDB_page
*
omp
;
pgno_t
pg
;
memcpy
(
&
pg
NODEDATA
(
ni
)
sizeof
(
pg
)
)
;
rc
=
mdb_page_get
(
mc
pg
&
omp
NULL
)
;
if
(
rc
!
=
0
)
goto
done
;
mdb_cassert
(
mc
IS_OVERFLOW
(
omp
)
)
;
rc
=
mdb_midl_append_range
(
&
txn
-
>
mt_free_pgs
pg
omp
-
>
mp_pages
)
;
if
(
rc
)
goto
done
;
mc
-
>
mc_db
-
>
md_overflow_pages
-
=
omp
-
>
mp_pages
;
if
(
!
mc
-
>
mc_db
-
>
md_overflow_pages
&
&
!
subs
)
break
;
}
else
if
(
subs
&
&
(
ni
-
>
mn_flags
&
F_SUBDATA
)
)
{
mdb_xcursor_init1
(
mc
ni
)
;
rc
=
mdb_drop0
(
&
mc
-
>
mc_xcursor
-
>
mx_cursor
0
)
;
if
(
rc
)
goto
done
;
}
}
if
(
!
subs
&
&
!
mc
-
>
mc_db
-
>
md_overflow_pages
)
goto
pop
;
}
else
{
if
(
(
rc
=
mdb_midl_need
(
&
txn
-
>
mt_free_pgs
n
)
)
!
=
0
)
goto
done
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
pgno_t
pg
;
ni
=
NODEPTR
(
mp
i
)
;
pg
=
NODEPGNO
(
ni
)
;
mdb_midl_xappend
(
txn
-
>
mt_free_pgs
pg
)
;
}
}
if
(
!
mc
-
>
mc_top
)
break
;
mc
-
>
mc_ki
[
mc
-
>
mc_top
]
=
i
;
rc
=
mdb_cursor_sibling
(
mc
1
)
;
if
(
rc
)
{
if
(
rc
!
=
MDB_NOTFOUND
)
goto
done
;
pop
:
mdb_cursor_pop
(
mc
)
;
mc
-
>
mc_ki
[
0
]
=
0
;
for
(
i
=
1
;
i
<
mc
-
>
mc_snum
;
i
+
+
)
{
mc
-
>
mc_ki
[
i
]
=
0
;
mc
-
>
mc_pg
[
i
]
=
mx
.
mc_pg
[
i
]
;
}
}
}
rc
=
mdb_midl_append
(
&
txn
-
>
mt_free_pgs
mc
-
>
mc_db
-
>
md_root
)
;
done
:
if
(
rc
)
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
}
else
if
(
rc
=
=
MDB_NOTFOUND
)
{
rc
=
MDB_SUCCESS
;
}
mc
-
>
mc_flags
&
=
~
C_INITIALIZED
;
return
rc
;
}
int
mdb_drop
(
MDB_txn
*
txn
MDB_dbi
dbi
int
del
)
{
MDB_cursor
*
mc
*
m2
;
int
rc
;
if
(
(
unsigned
)
del
>
1
|
|
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
if
(
F_ISSET
(
txn
-
>
mt_flags
MDB_TXN_RDONLY
)
)
return
EACCES
;
if
(
TXN_DBI_CHANGED
(
txn
dbi
)
)
return
MDB_BAD_DBI
;
rc
=
mdb_cursor_open
(
txn
dbi
&
mc
)
;
if
(
rc
)
return
rc
;
rc
=
mdb_drop0
(
mc
mc
-
>
mc_db
-
>
md_flags
&
MDB_DUPSORT
)
;
for
(
m2
=
txn
-
>
mt_cursors
[
dbi
]
;
m2
;
m2
=
m2
-
>
mc_next
)
m2
-
>
mc_flags
&
=
~
(
C_INITIALIZED
|
C_EOF
)
;
if
(
rc
)
goto
leave
;
if
(
del
&
&
dbi
>
=
CORE_DBS
)
{
rc
=
mdb_del0
(
txn
MAIN_DBI
&
mc
-
>
mc_dbx
-
>
md_name
NULL
F_SUBDATA
)
;
if
(
!
rc
)
{
txn
-
>
mt_dbflags
[
dbi
]
=
DB_STALE
;
mdb_dbi_close
(
txn
-
>
mt_env
dbi
)
;
}
else
{
txn
-
>
mt_flags
|
=
MDB_TXN_ERROR
;
}
}
else
{
txn
-
>
mt_dbflags
[
dbi
]
|
=
DB_DIRTY
;
txn
-
>
mt_dbs
[
dbi
]
.
md_depth
=
0
;
txn
-
>
mt_dbs
[
dbi
]
.
md_branch_pages
=
0
;
txn
-
>
mt_dbs
[
dbi
]
.
md_leaf_pages
=
0
;
txn
-
>
mt_dbs
[
dbi
]
.
md_overflow_pages
=
0
;
txn
-
>
mt_dbs
[
dbi
]
.
md_entries
=
0
;
txn
-
>
mt_dbs
[
dbi
]
.
md_root
=
P_INVALID
;
txn
-
>
mt_flags
|
=
MDB_TXN_DIRTY
;
}
leave
:
mdb_cursor_close
(
mc
)
;
return
rc
;
}
int
mdb_set_compare
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_cmp_func
*
cmp
)
{
if
(
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
txn
-
>
mt_dbxs
[
dbi
]
.
md_cmp
=
cmp
;
return
MDB_SUCCESS
;
}
int
mdb_set_dupsort
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_cmp_func
*
cmp
)
{
if
(
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
txn
-
>
mt_dbxs
[
dbi
]
.
md_dcmp
=
cmp
;
return
MDB_SUCCESS
;
}
int
mdb_set_relfunc
(
MDB_txn
*
txn
MDB_dbi
dbi
MDB_rel_func
*
rel
)
{
if
(
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
txn
-
>
mt_dbxs
[
dbi
]
.
md_rel
=
rel
;
return
MDB_SUCCESS
;
}
int
mdb_set_relctx
(
MDB_txn
*
txn
MDB_dbi
dbi
void
*
ctx
)
{
if
(
!
TXN_DBI_EXIST
(
txn
dbi
DB_USRVALID
)
)
return
EINVAL
;
txn
-
>
mt_dbxs
[
dbi
]
.
md_relctx
=
ctx
;
return
MDB_SUCCESS
;
}
int
ESECT
mdb_env_get_maxkeysize
(
MDB_env
*
env
)
{
return
ENV_MAXKEY
(
env
)
;
}
int
ESECT
mdb_reader_list
(
MDB_env
*
env
MDB_msg_func
*
func
void
*
ctx
)
{
unsigned
int
i
rdrs
;
MDB_reader
*
mr
;
char
buf
[
64
]
;
int
rc
=
0
first
=
1
;
if
(
!
env
|
|
!
func
)
return
-
1
;
if
(
!
env
-
>
me_txns
)
{
return
func
(
"
(
no
reader
locks
)
\
n
"
ctx
)
;
}
rdrs
=
env
-
>
me_txns
-
>
mti_numreaders
;
mr
=
env
-
>
me_txns
-
>
mti_readers
;
for
(
i
=
0
;
i
<
rdrs
;
i
+
+
)
{
if
(
mr
[
i
]
.
mr_pid
)
{
txnid_t
txnid
=
mr
[
i
]
.
mr_txnid
;
sprintf
(
buf
txnid
=
=
(
txnid_t
)
-
1
?
"
%
10d
%
"
Z
"
x
-
\
n
"
:
"
%
10d
%
"
Z
"
x
%
"
Z
"
u
\
n
"
(
int
)
mr
[
i
]
.
mr_pid
(
size_t
)
mr
[
i
]
.
mr_tid
txnid
)
;
if
(
first
)
{
first
=
0
;
rc
=
func
(
"
pid
thread
txnid
\
n
"
ctx
)
;
if
(
rc
<
0
)
break
;
}
rc
=
func
(
buf
ctx
)
;
if
(
rc
<
0
)
break
;
}
}
if
(
first
)
{
rc
=
func
(
"
(
no
active
readers
)
\
n
"
ctx
)
;
}
return
rc
;
}
static
int
ESECT
mdb_pid_insert
(
MDB_PID_T
*
ids
MDB_PID_T
pid
)
{
unsigned
base
=
0
;
unsigned
cursor
=
1
;
int
val
=
0
;
unsigned
n
=
ids
[
0
]
;
while
(
0
<
n
)
{
unsigned
pivot
=
n
>
>
1
;
cursor
=
base
+
pivot
+
1
;
val
=
pid
-
ids
[
cursor
]
;
if
(
val
<
0
)
{
n
=
pivot
;
}
else
if
(
val
>
0
)
{
base
=
cursor
;
n
-
=
pivot
+
1
;
}
else
{
return
-
1
;
}
}
if
(
val
>
0
)
{
+
+
cursor
;
}
ids
[
0
]
+
+
;
for
(
n
=
ids
[
0
]
;
n
>
cursor
;
n
-
-
)
ids
[
n
]
=
ids
[
n
-
1
]
;
ids
[
n
]
=
pid
;
return
0
;
}
int
ESECT
mdb_reader_check
(
MDB_env
*
env
int
*
dead
)
{
if
(
!
env
)
return
EINVAL
;
if
(
dead
)
*
dead
=
0
;
return
env
-
>
me_txns
?
mdb_reader_check0
(
env
0
dead
)
:
MDB_SUCCESS
;
}
static
int
ESECT
mdb_reader_check0
(
MDB_env
*
env
int
rlocked
int
*
dead
)
{
mdb_mutexref_t
rmutex
=
rlocked
?
NULL
:
env
-
>
me_rmutex
;
unsigned
int
i
j
rdrs
;
MDB_reader
*
mr
;
MDB_PID_T
*
pids
pid
;
int
rc
=
MDB_SUCCESS
count
=
0
;
rdrs
=
env
-
>
me_txns
-
>
mti_numreaders
;
pids
=
malloc
(
(
rdrs
+
1
)
*
sizeof
(
MDB_PID_T
)
)
;
if
(
!
pids
)
return
ENOMEM
;
pids
[
0
]
=
0
;
mr
=
env
-
>
me_txns
-
>
mti_readers
;
for
(
i
=
0
;
i
<
rdrs
;
i
+
+
)
{
pid
=
mr
[
i
]
.
mr_pid
;
if
(
pid
&
&
pid
!
=
env
-
>
me_pid
)
{
if
(
mdb_pid_insert
(
pids
pid
)
=
=
0
)
{
if
(
!
mdb_reader_pid
(
env
Pidcheck
pid
)
)
{
j
=
i
;
if
(
rmutex
)
{
if
(
(
rc
=
LOCK_MUTEX0
(
rmutex
)
)
!
=
0
)
{
if
(
(
rc
=
mdb_mutex_failed
(
env
rmutex
rc
)
)
)
break
;
rdrs
=
0
;
}
else
{
if
(
mdb_reader_pid
(
env
Pidcheck
pid
)
)
j
=
rdrs
;
}
}
for
(
;
j
<
rdrs
;
j
+
+
)
if
(
mr
[
j
]
.
mr_pid
=
=
pid
)
{
DPRINTF
(
(
"
clear
stale
reader
pid
%
u
txn
%
"
Z
"
d
"
(
unsigned
)
pid
mr
[
j
]
.
mr_txnid
)
)
;
mr
[
j
]
.
mr_pid
=
0
;
count
+
+
;
}
if
(
rmutex
)
UNLOCK_MUTEX
(
rmutex
)
;
}
}
}
}
free
(
pids
)
;
if
(
dead
)
*
dead
=
count
;
return
rc
;
}
#
ifdef
MDB_ROBUST_SUPPORTED
static
int
ESECT
mdb_mutex_failed
(
MDB_env
*
env
mdb_mutexref_t
mutex
int
rc
)
{
int
rlocked
rc2
;
MDB_meta
*
meta
;
if
(
rc
=
=
MDB_OWNERDEAD
)
{
rc
=
MDB_SUCCESS
;
rlocked
=
(
mutex
=
=
env
-
>
me_rmutex
)
;
if
(
!
rlocked
)
{
meta
=
mdb_env_pick_meta
(
env
)
;
env
-
>
me_txns
-
>
mti_txnid
=
meta
-
>
mm_txnid
;
if
(
env
-
>
me_txn
)
{
env
-
>
me_flags
|
=
MDB_FATAL_ERROR
;
env
-
>
me_txn
=
NULL
;
rc
=
MDB_PANIC
;
}
}
DPRINTF
(
(
"
%
cmutex
owner
died
%
s
"
(
rlocked
?
'
r
'
:
'
w
'
)
(
rc
?
"
this
process
'
env
is
hosed
"
:
"
recovering
"
)
)
)
;
rc2
=
mdb_reader_check0
(
env
rlocked
NULL
)
;
if
(
rc2
=
=
0
)
rc2
=
mdb_mutex_consistent
(
mutex
)
;
if
(
rc
|
|
(
rc
=
rc2
)
)
{
DPRINTF
(
(
"
LOCK_MUTEX
recovery
failed
%
s
"
mdb_strerror
(
rc
)
)
)
;
UNLOCK_MUTEX
(
mutex
)
;
}
}
else
{
#
ifdef
_WIN32
rc
=
ErrCode
(
)
;
#
endif
DPRINTF
(
(
"
LOCK_MUTEX
failed
%
s
"
mdb_strerror
(
rc
)
)
)
;
}
return
rc
;
}
#
endif
#
if
defined
(
_WIN32
)
static
int
ESECT
utf8_to_utf16
(
const
char
*
src
MDB_name
*
dst
int
xtra
)
{
int
rc
need
=
0
;
wchar_t
*
result
=
NULL
;
for
(
;
;
)
{
need
=
MultiByteToWideChar
(
CP_UTF8
0
src
-
1
result
need
)
;
if
(
!
need
)
{
rc
=
ErrCode
(
)
;
free
(
result
)
;
return
rc
;
}
if
(
!
result
)
{
result
=
malloc
(
sizeof
(
wchar_t
)
*
(
need
+
xtra
)
)
;
if
(
!
result
)
return
ENOMEM
;
continue
;
}
dst
-
>
mn_alloced
=
1
;
dst
-
>
mn_len
=
need
-
1
;
dst
-
>
mn_val
=
result
;
return
MDB_SUCCESS
;
}
}
#
endif
