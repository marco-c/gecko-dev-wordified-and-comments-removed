use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
fmt
:
:
Formatter
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
ops
:
:
Index
;
use
std
:
:
ops
:
:
Range
;
use
std
:
:
ops
:
:
RangeFrom
;
use
std
:
:
ops
:
:
RangeFull
;
use
std
:
:
ops
:
:
RangeInclusive
;
use
std
:
:
ops
:
:
RangeTo
;
use
std
:
:
ops
:
:
RangeToInclusive
;
use
std
:
:
str
;
#
[
cfg
(
feature
=
"
memchr
"
)
]
use
memchr
:
:
memmem
:
:
find
;
#
[
cfg
(
feature
=
"
memchr
"
)
]
use
memchr
:
:
memmem
:
:
rfind
;
use
super
:
:
imp
:
:
raw
;
use
super
:
:
iter
:
:
Split
;
use
super
:
:
pattern
:
:
Encoded
as
EncodedPattern
;
use
super
:
:
OsStrBytes
;
use
super
:
:
OsStringBytes
;
use
super
:
:
Pattern
;
#
[
cfg
(
not
(
feature
=
"
memchr
"
)
)
]
fn
find
(
string
:
&
[
u8
]
pat
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
for
i
in
0
.
.
=
string
.
len
(
)
.
checked_sub
(
pat
.
len
(
)
)
?
{
if
string
[
i
.
.
]
.
starts_with
(
pat
)
{
return
Some
(
i
)
;
}
}
None
}
#
[
cfg
(
not
(
feature
=
"
memchr
"
)
)
]
fn
rfind
(
string
:
&
[
u8
]
pat
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
for
i
in
(
pat
.
len
(
)
.
.
=
string
.
len
(
)
)
.
rev
(
)
{
if
string
[
.
.
i
]
.
ends_with
(
pat
)
{
return
Some
(
i
-
pat
.
len
(
)
)
;
}
}
None
}
macro_rules
!
impl_trim_matches
{
(
self
:
ident
pat
:
expr
strip_method
:
ident
)
=
>
{
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
if
pat
.
is_empty
(
)
{
return
self
;
}
let
mut
string
=
&
self
.
0
;
while
let
Some
(
substring
)
=
string
.
strip_method
(
pat
)
{
string
=
substring
;
}
Self
:
:
from_raw_bytes_unchecked
(
string
)
}
}
;
}
macro_rules
!
impl_split_once_raw
{
(
self
:
ident
pat
:
expr
find_fn
:
expr
)
=
>
{
{
let
pat
=
pat
.
__get
(
)
;
let
index
=
find_fn
(
&
self
.
0
pat
)
?
;
let
prefix
=
&
self
.
0
[
.
.
index
]
;
let
suffix
=
&
self
.
0
[
index
+
pat
.
len
(
)
.
.
]
;
Some
(
(
Self
:
:
from_raw_bytes_unchecked
(
prefix
)
Self
:
:
from_raw_bytes_unchecked
(
suffix
)
)
)
}
}
;
}
#
[
derive
(
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
os_str_bytes_docs_rs
doc
(
cfg
(
feature
=
"
raw_os_str
"
)
)
)
]
#
[
repr
(
transparent
)
]
pub
struct
RawOsStr
(
[
u8
]
)
;
impl
RawOsStr
{
fn
from_raw_bytes_unchecked
(
string
:
&
[
u8
]
)
-
>
&
Self
{
unsafe
{
mem
:
:
transmute
(
string
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
new
(
string
:
&
OsStr
)
-
>
Cow
<
'
_
Self
>
{
match
string
.
to_raw_bytes
(
)
{
Cow
:
:
Borrowed
(
string
)
=
>
{
Cow
:
:
Borrowed
(
Self
:
:
from_raw_bytes_unchecked
(
string
)
)
}
Cow
:
:
Owned
(
string
)
=
>
Cow
:
:
Owned
(
RawOsString
(
string
)
)
}
}
#
[
allow
(
clippy
:
:
should_implement_trait
)
]
#
[
inline
]
#
[
must_use
]
pub
fn
from_str
(
string
:
&
str
)
-
>
&
Self
{
Self
:
:
from_raw_bytes_unchecked
(
string
.
as_bytes
(
)
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
as_raw_bytes
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
0
}
#
[
inline
]
#
[
must_use
]
pub
fn
contains
<
P
>
(
&
self
pat
:
P
)
-
>
bool
where
P
:
Pattern
{
self
.
find
(
pat
)
.
is_some
(
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
ends_with
<
P
>
(
&
self
pat
:
P
)
-
>
bool
where
P
:
Pattern
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
self
.
0
.
ends_with
(
pat
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
ends_with_os
(
&
self
pat
:
&
Self
)
-
>
bool
{
raw
:
:
ends_with
(
&
self
.
0
&
pat
.
0
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
find
<
P
>
(
&
self
pat
:
P
)
-
>
Option
<
usize
>
where
P
:
Pattern
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
find
(
&
self
.
0
pat
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
raw_len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
rfind
<
P
>
(
&
self
pat
:
P
)
-
>
Option
<
usize
>
where
P
:
Pattern
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
rfind
(
&
self
.
0
pat
)
}
pub
(
super
)
fn
rsplit_once_raw
<
P
>
(
&
self
pat
:
&
P
)
-
>
Option
<
(
&
Self
&
Self
)
>
where
P
:
EncodedPattern
{
impl_split_once_raw
!
(
self
pat
rfind
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
rsplit_once
<
P
>
(
&
self
pat
:
P
)
-
>
Option
<
(
&
Self
&
Self
)
>
where
P
:
Pattern
{
self
.
rsplit_once_raw
(
&
pat
.
__encode
(
)
)
}
#
[
cold
]
#
[
inline
(
never
)
]
#
[
track_caller
]
fn
index_boundary_error
(
&
self
index
:
usize
)
-
>
!
{
debug_assert
!
(
raw
:
:
is_continuation
(
self
.
0
[
index
]
)
)
;
let
start
=
self
.
0
[
.
.
index
]
.
iter
(
)
.
rposition
(
|
&
x
|
!
raw
:
:
is_continuation
(
x
)
)
.
expect
(
"
invalid
raw
bytes
"
)
;
let
mut
end
=
index
+
1
;
end
+
=
self
.
0
[
end
.
.
]
.
iter
(
)
.
position
(
|
&
x
|
!
raw
:
:
is_continuation
(
x
)
)
.
unwrap_or_else
(
|
|
self
.
raw_len
(
)
-
end
)
;
let
code_point
=
raw
:
:
decode_code_point
(
&
self
.
0
[
start
.
.
end
]
)
;
panic
!
(
"
byte
index
{
}
is
not
a
valid
boundary
;
it
is
inside
U
+
{
:
04X
}
\
(
bytes
{
}
.
.
{
}
)
"
index
code_point
start
end
)
;
}
#
[
track_caller
]
fn
check_bound
(
&
self
index
:
usize
)
{
if
let
Some
(
&
byte
)
=
self
.
0
.
get
(
index
)
{
if
raw
:
:
is_continuation
(
byte
)
{
self
.
index_boundary_error
(
index
)
;
}
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
split
<
P
>
(
&
self
pat
:
P
)
-
>
Split
<
'
_
P
>
where
P
:
Pattern
{
Split
:
:
new
(
self
pat
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
split_at
(
&
self
mid
:
usize
)
-
>
(
&
Self
&
Self
)
{
self
.
check_bound
(
mid
)
;
let
(
prefix
suffix
)
=
self
.
0
.
split_at
(
mid
)
;
(
Self
:
:
from_raw_bytes_unchecked
(
prefix
)
Self
:
:
from_raw_bytes_unchecked
(
suffix
)
)
}
pub
(
super
)
fn
split_once_raw
<
P
>
(
&
self
pat
:
&
P
)
-
>
Option
<
(
&
Self
&
Self
)
>
where
P
:
EncodedPattern
{
impl_split_once_raw
!
(
self
pat
find
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
split_once
<
P
>
(
&
self
pat
:
P
)
-
>
Option
<
(
&
Self
&
Self
)
>
where
P
:
Pattern
{
self
.
split_once_raw
(
&
pat
.
__encode
(
)
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
starts_with
<
P
>
(
&
self
pat
:
P
)
-
>
bool
where
P
:
Pattern
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
self
.
0
.
starts_with
(
pat
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
starts_with_os
(
&
self
pat
:
&
Self
)
-
>
bool
{
raw
:
:
starts_with
(
&
self
.
0
&
pat
.
0
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
strip_prefix
<
P
>
(
&
self
pat
:
P
)
-
>
Option
<
&
Self
>
where
P
:
Pattern
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
self
.
0
.
strip_prefix
(
pat
)
.
map
(
Self
:
:
from_raw_bytes_unchecked
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
strip_suffix
<
P
>
(
&
self
pat
:
P
)
-
>
Option
<
&
Self
>
where
P
:
Pattern
{
let
pat
=
pat
.
__encode
(
)
;
let
pat
=
pat
.
__get
(
)
;
self
.
0
.
strip_suffix
(
pat
)
.
map
(
Self
:
:
from_raw_bytes_unchecked
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
to_os_str
(
&
self
)
-
>
Cow
<
'
_
OsStr
>
{
OsStr
:
:
from_raw_bytes
(
&
self
.
0
)
.
expect
(
"
invalid
raw
bytes
"
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
to_str
(
&
self
)
-
>
Option
<
&
str
>
{
str
:
:
from_utf8
(
&
self
.
0
)
.
ok
(
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
to_str_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
String
:
:
from_utf8_lossy
(
&
self
.
0
)
}
#
[
must_use
]
pub
fn
trim_end_matches
<
P
>
(
&
self
pat
:
P
)
-
>
&
Self
where
P
:
Pattern
{
impl_trim_matches
!
(
self
pat
strip_suffix
)
}
#
[
must_use
]
pub
fn
trim_start_matches
<
P
>
(
&
self
pat
:
P
)
-
>
&
Self
where
P
:
Pattern
{
impl_trim_matches
!
(
self
pat
strip_prefix
)
}
}
impl
AsRef
<
Self
>
for
RawOsStr
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
Self
{
self
}
}
impl
AsRef
<
RawOsStr
>
for
str
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
RawOsStr
{
RawOsStr
:
:
from_str
(
self
)
}
}
impl
AsRef
<
RawOsStr
>
for
String
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
RawOsStr
{
(
*
*
self
)
.
as_ref
(
)
}
}
impl
Default
for
&
RawOsStr
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
RawOsStr
:
:
from_str
(
"
"
)
}
}
impl
<
'
a
>
From
<
&
'
a
RawOsStr
>
for
Cow
<
'
a
RawOsStr
>
{
#
[
inline
]
fn
from
(
other
:
&
'
a
RawOsStr
)
-
>
Self
{
Cow
:
:
Borrowed
(
other
)
}
}
macro_rules
!
r
#
impl
{
(
index_type
:
ty
(
index_var
:
ident
first_bound
:
expr
(
second_bound
:
expr
)
?
)
?
)
=
>
{
impl
Index
<
index_type
>
for
RawOsStr
{
type
Output
=
Self
;
#
[
inline
]
fn
index
(
&
self
idx
:
index_type
)
-
>
&
Self
:
:
Output
{
(
let
index_var
=
&
idx
;
self
.
check_bound
(
first_bound
)
;
(
self
.
check_bound
(
second_bound
)
;
)
?
)
?
Self
:
:
from_raw_bytes_unchecked
(
&
self
.
0
[
idx
]
)
}
}
}
;
}
r
#
impl
!
(
Range
<
usize
>
x
x
.
start
x
.
end
)
;
r
#
impl
!
(
RangeFrom
<
usize
>
x
x
.
start
)
;
r
#
impl
!
(
RangeFull
)
;
#
[
rustfmt
:
:
skip
]
r
#
impl
!
(
RangeInclusive
<
usize
>
x
*
x
.
start
(
)
x
.
end
(
)
.
wrapping_add
(
1
)
)
;
r
#
impl
!
(
RangeTo
<
usize
>
x
x
.
end
)
;
r
#
impl
!
(
RangeToInclusive
<
usize
>
x
x
.
end
.
wrapping_add
(
1
)
)
;
impl
ToOwned
for
RawOsStr
{
type
Owned
=
RawOsString
;
#
[
inline
]
fn
to_owned
(
&
self
)
-
>
Self
:
:
Owned
{
RawOsString
(
self
.
0
.
to_owned
(
)
)
}
}
#
[
derive
(
Clone
Default
Eq
Hash
Ord
PartialEq
PartialOrd
)
]
#
[
cfg_attr
(
os_str_bytes_docs_rs
doc
(
cfg
(
feature
=
"
raw_os_str
"
)
)
)
]
pub
struct
RawOsString
(
Vec
<
u8
>
)
;
impl
RawOsString
{
#
[
inline
]
#
[
must_use
]
pub
fn
new
(
string
:
OsString
)
-
>
Self
{
Self
(
string
.
into_raw_vec
(
)
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
from_string
(
string
:
String
)
-
>
Self
{
Self
(
string
.
into_bytes
(
)
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
into_os_string
(
self
)
-
>
OsString
{
OsString
:
:
from_raw_vec
(
self
.
0
)
.
expect
(
"
invalid
raw
bytes
"
)
}
#
[
inline
]
#
[
must_use
]
pub
fn
into_raw_vec
(
self
)
-
>
Vec
<
u8
>
{
self
.
0
}
#
[
inline
]
pub
fn
into_string
(
self
)
-
>
Result
<
String
Self
>
{
String
:
:
from_utf8
(
self
.
0
)
.
map_err
(
|
x
|
Self
(
x
.
into_bytes
(
)
)
)
}
}
impl
AsRef
<
RawOsStr
>
for
RawOsString
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
RawOsStr
{
self
}
}
impl
Borrow
<
RawOsStr
>
for
RawOsString
{
#
[
inline
]
fn
borrow
(
&
self
)
-
>
&
RawOsStr
{
self
}
}
impl
Deref
for
RawOsString
{
type
Target
=
RawOsStr
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
RawOsStr
:
:
from_raw_bytes_unchecked
(
&
self
.
0
)
}
}
impl
From
<
String
>
for
RawOsString
{
#
[
inline
]
fn
from
(
other
:
String
)
-
>
Self
{
Self
:
:
from_string
(
other
)
}
}
impl
From
<
RawOsString
>
for
Cow
<
'
_
RawOsStr
>
{
#
[
inline
]
fn
from
(
other
:
RawOsString
)
-
>
Self
{
Cow
:
:
Owned
(
other
)
}
}
macro_rules
!
r
#
impl
{
(
index_type
:
ty
)
=
>
{
impl
Index
<
index_type
>
for
RawOsString
{
type
Output
=
RawOsStr
;
#
[
inline
]
fn
index
(
&
self
idx
:
index_type
)
-
>
&
Self
:
:
Output
{
&
(
*
*
self
)
[
idx
]
}
}
}
;
}
r
#
impl
!
(
Range
<
usize
>
)
;
r
#
impl
!
(
RangeFrom
<
usize
>
)
;
r
#
impl
!
(
RangeFull
)
;
r
#
impl
!
(
RangeInclusive
<
usize
>
)
;
r
#
impl
!
(
RangeTo
<
usize
>
)
;
r
#
impl
!
(
RangeToInclusive
<
usize
>
)
;
struct
Buffer
<
'
a
>
(
&
'
a
[
u8
]
)
;
impl
Debug
for
Buffer
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
\
"
"
)
?
;
let
mut
string
=
self
.
0
;
let
mut
invalid_length
=
0
;
while
!
string
.
is_empty
(
)
{
let
(
invalid
substring
)
=
string
.
split_at
(
invalid_length
)
;
let
valid
=
match
str
:
:
from_utf8
(
substring
)
{
Ok
(
valid
)
=
>
{
string
=
&
[
]
;
valid
}
Err
(
error
)
=
>
{
let
(
valid
substring
)
=
substring
.
split_at
(
error
.
valid_up_to
(
)
)
;
let
invalid_char_length
=
error
.
error_len
(
)
.
unwrap_or_else
(
|
|
substring
.
len
(
)
)
;
if
valid
.
is_empty
(
)
{
invalid_length
+
=
invalid_char_length
;
continue
;
}
string
=
substring
;
invalid_length
=
invalid_char_length
;
unsafe
{
str
:
:
from_utf8_unchecked
(
valid
)
}
}
}
;
raw
:
:
debug
(
invalid
f
)
?
;
Display
:
:
fmt
(
&
valid
.
escape_debug
(
)
f
)
?
;
}
f
.
write_str
(
"
\
"
"
)
}
}
macro_rules
!
r
#
impl
{
(
type
:
ty
)
=
>
{
impl
Debug
for
type
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
stringify
!
(
type
)
)
.
field
(
&
Buffer
(
&
self
.
0
)
)
.
finish
(
)
}
}
}
;
}
r
#
impl
!
(
RawOsStr
)
;
r
#
impl
!
(
RawOsString
)
;
macro_rules
!
r
#
impl
{
(
type
:
ty
other_type
:
ty
)
=
>
{
impl
PartialEq
<
other_type
>
for
type
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
other_type
)
-
>
bool
{
let
raw
:
&
RawOsStr
=
self
;
let
other
:
&
RawOsStr
=
other
.
as_ref
(
)
;
raw
=
=
other
}
}
impl
PartialEq
<
type
>
for
other_type
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
type
)
-
>
bool
{
other
=
=
self
}
}
}
;
}
r
#
impl
!
(
RawOsStr
RawOsString
)
;
r
#
impl
!
(
&
RawOsStr
RawOsString
)
;
r
#
impl
!
(
RawOsStr
str
)
;
r
#
impl
!
(
RawOsStr
String
)
;
r
#
impl
!
(
&
RawOsStr
String
)
;
r
#
impl
!
(
RawOsString
str
)
;
r
#
impl
!
(
RawOsString
&
str
)
;
r
#
impl
!
(
RawOsString
String
)
;
#
[
cfg
(
feature
=
"
print_bytes
"
)
]
#
[
cfg_attr
(
os_str_bytes_docs_rs
doc
(
cfg
(
feature
=
"
print_bytes
"
)
)
)
]
mod
print_bytes
{
use
print_bytes
:
:
ByteStr
;
use
print_bytes
:
:
ToBytes
;
#
[
cfg
(
windows
)
]
use
print_bytes
:
:
WideStr
;
#
[
cfg
(
windows
)
]
use
crate
:
:
imp
:
:
raw
;
use
super
:
:
RawOsStr
;
use
super
:
:
RawOsString
;
impl
ToBytes
for
RawOsStr
{
#
[
inline
]
fn
to_bytes
(
&
self
)
-
>
ByteStr
<
'
_
>
{
self
.
0
.
to_bytes
(
)
}
#
[
cfg
(
windows
)
]
#
[
inline
]
fn
to_wide
(
&
self
)
-
>
Option
<
WideStr
>
{
Some
(
WideStr
:
:
new
(
raw
:
:
encode_wide_unchecked
(
&
self
.
0
)
.
collect
(
)
)
)
}
}
impl
ToBytes
for
RawOsString
{
#
[
inline
]
fn
to_bytes
(
&
self
)
-
>
ByteStr
<
'
_
>
{
(
*
*
self
)
.
to_bytes
(
)
}
#
[
cfg
(
windows
)
]
#
[
inline
]
fn
to_wide
(
&
self
)
-
>
Option
<
WideStr
>
{
(
*
*
self
)
.
to_wide
(
)
}
}
}
#
[
cfg
(
feature
=
"
uniquote
"
)
]
#
[
cfg_attr
(
os_str_bytes_docs_rs
doc
(
cfg
(
feature
=
"
uniquote
"
)
)
)
]
mod
uniquote
{
use
uniquote
:
:
Formatter
;
use
uniquote
:
:
Quote
;
use
uniquote
:
:
Result
;
use
crate
:
:
imp
:
:
raw
;
use
super
:
:
RawOsStr
;
use
super
:
:
RawOsString
;
impl
Quote
for
RawOsStr
{
#
[
inline
]
fn
escape
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
Result
{
raw
:
:
uniquote
:
:
escape
(
&
self
.
0
f
)
}
}
impl
Quote
for
RawOsString
{
#
[
inline
]
fn
escape
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
Result
{
(
*
*
self
)
.
escape
(
f
)
}
}
}
