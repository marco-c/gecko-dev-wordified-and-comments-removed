#
!
[
cfg_attr
(
os_str_bytes_docs_rs
feature
(
doc_cfg
)
)
]
#
!
[
cfg_attr
(
all
(
target_vendor
=
"
fortanix
"
target_env
=
"
sgx
"
)
feature
(
sgx_platform
)
)
]
#
!
[
forbid
(
unsafe_op_in_unsafe_fn
)
]
#
!
[
warn
(
unused_results
)
]
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
Display
;
use
std
:
:
fmt
:
:
Formatter
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
result
;
macro_rules
!
if_raw_str
{
(
(
item
:
item
)
+
)
=
>
{
(
#
[
cfg
(
feature
=
"
raw_os_str
"
)
]
item
)
+
}
;
}
#
[
cfg_attr
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
path
=
"
wasm32
/
mod
.
rs
"
)
]
#
[
cfg_attr
(
windows
path
=
"
windows
/
mod
.
rs
"
)
]
#
[
cfg_attr
(
not
(
any
(
all
(
target_arch
=
"
wasm32
"
target_os
=
"
unknown
"
)
windows
)
)
path
=
"
common
/
mod
.
rs
"
)
]
mod
imp
;
mod
util
;
if_raw_str
!
{
pub
mod
iter
;
mod
pattern
;
pub
use
pattern
:
:
Pattern
;
mod
raw_str
;
pub
use
raw_str
:
:
RawOsStr
;
pub
use
raw_str
:
:
RawOsString
;
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
EncodingError
(
imp
:
:
EncodingError
)
;
impl
Display
for
EncodingError
{
#
[
inline
]
fn
fmt
(
&
self
formatter
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
0
.
fmt
(
formatter
)
}
}
impl
Error
for
EncodingError
{
}
type
Result
<
T
>
=
result
:
:
Result
<
T
EncodingError
>
;
pub
trait
OsStrBytes
:
private
:
:
Sealed
+
ToOwned
{
fn
from_raw_bytes
<
'
a
S
>
(
string
:
S
)
-
>
Result
<
Cow
<
'
a
Self
>
>
where
S
:
Into
<
Cow
<
'
a
[
u8
]
>
>
;
#
[
must_use
]
fn
to_raw_bytes
(
&
self
)
-
>
Cow
<
'
_
[
u8
]
>
;
}
impl
OsStrBytes
for
OsStr
{
#
[
inline
]
fn
from_raw_bytes
<
'
a
S
>
(
string
:
S
)
-
>
Result
<
Cow
<
'
a
Self
>
>
where
S
:
Into
<
Cow
<
'
a
[
u8
]
>
>
{
match
string
.
into
(
)
{
Cow
:
:
Borrowed
(
string
)
=
>
{
imp
:
:
os_str_from_bytes
(
string
)
.
map_err
(
EncodingError
)
}
Cow
:
:
Owned
(
string
)
=
>
{
OsStringBytes
:
:
from_raw_vec
(
string
)
.
map
(
Cow
:
:
Owned
)
}
}
}
#
[
inline
]
fn
to_raw_bytes
(
&
self
)
-
>
Cow
<
'
_
[
u8
]
>
{
imp
:
:
os_str_to_bytes
(
self
)
}
}
impl
OsStrBytes
for
Path
{
#
[
inline
]
fn
from_raw_bytes
<
'
a
S
>
(
string
:
S
)
-
>
Result
<
Cow
<
'
a
Self
>
>
where
S
:
Into
<
Cow
<
'
a
[
u8
]
>
>
{
OsStr
:
:
from_raw_bytes
(
string
)
.
map
(
|
os_string
|
match
os_string
{
Cow
:
:
Borrowed
(
os_string
)
=
>
Cow
:
:
Borrowed
(
Self
:
:
new
(
os_string
)
)
Cow
:
:
Owned
(
os_string
)
=
>
Cow
:
:
Owned
(
os_string
.
into
(
)
)
}
)
}
#
[
inline
]
fn
to_raw_bytes
(
&
self
)
-
>
Cow
<
'
_
[
u8
]
>
{
self
.
as_os_str
(
)
.
to_raw_bytes
(
)
}
}
pub
trait
OsStringBytes
:
private
:
:
Sealed
+
Sized
{
fn
from_raw_vec
(
string
:
Vec
<
u8
>
)
-
>
Result
<
Self
>
;
#
[
must_use
]
fn
into_raw_vec
(
self
)
-
>
Vec
<
u8
>
;
}
impl
OsStringBytes
for
OsString
{
#
[
inline
]
fn
from_raw_vec
(
string
:
Vec
<
u8
>
)
-
>
Result
<
Self
>
{
imp
:
:
os_string_from_vec
(
string
)
.
map_err
(
EncodingError
)
}
#
[
inline
]
fn
into_raw_vec
(
self
)
-
>
Vec
<
u8
>
{
imp
:
:
os_string_into_vec
(
self
)
}
}
impl
OsStringBytes
for
PathBuf
{
#
[
inline
]
fn
from_raw_vec
(
string
:
Vec
<
u8
>
)
-
>
Result
<
Self
>
{
OsString
:
:
from_raw_vec
(
string
)
.
map
(
Into
:
:
into
)
}
#
[
inline
]
fn
into_raw_vec
(
self
)
-
>
Vec
<
u8
>
{
self
.
into_os_string
(
)
.
into_raw_vec
(
)
}
}
mod
private
{
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
ffi
:
:
OsString
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
path
:
:
PathBuf
;
pub
trait
Sealed
{
}
impl
Sealed
for
char
{
}
impl
Sealed
for
OsStr
{
}
impl
Sealed
for
OsString
{
}
impl
Sealed
for
Path
{
}
impl
Sealed
for
PathBuf
{
}
impl
Sealed
for
&
str
{
}
impl
Sealed
for
&
String
{
}
}
