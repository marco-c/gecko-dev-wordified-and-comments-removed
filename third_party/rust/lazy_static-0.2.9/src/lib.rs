#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
const_fn
allow_internal_unstable
core_intrinsics
const_unsafe_cell_new
)
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
lazy_static
/
0
.
2
.
8
"
)
]
#
!
[
no_std
]
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
#
[
doc
(
hidden
)
]
pub
mod
lazy
;
#
[
cfg
(
all
(
feature
=
"
nightly
"
not
(
feature
=
"
spin_no_std
"
)
)
)
]
#
[
path
=
"
nightly_lazy
.
rs
"
]
#
[
doc
(
hidden
)
]
pub
mod
lazy
;
#
[
cfg
(
all
(
feature
=
"
nightly
"
feature
=
"
spin_no_std
"
)
)
]
#
[
path
=
"
core_lazy
.
rs
"
]
#
[
doc
(
hidden
)
]
pub
mod
lazy
;
#
[
doc
(
hidden
)
]
pub
use
core
:
:
ops
:
:
Deref
as
__Deref
;
#
[
macro_export
]
#
[
cfg_attr
(
feature
=
"
nightly
"
allow_internal_unstable
)
]
#
[
doc
(
hidden
)
]
macro_rules
!
__lazy_static_internal
{
(
(
#
[
attr
:
meta
]
)
*
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
PRIV
(
#
[
attr
]
)
*
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
in
pub_in
:
path
)
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
PUB_IN
pub_in
(
#
[
attr
]
)
*
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
pub
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
PUB
(
#
[
attr
]
)
*
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
PUB_IN
pub_in
:
path
(
#
[
attr
:
meta
]
)
*
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
MAKE
TY
PUB_IN
pub_in
(
#
[
attr
]
)
*
N
)
;
__lazy_static_internal
!
(
TAIL
N
:
T
=
e
)
;
__lazy_static_internal
!
(
(
t
)
*
)
;
}
;
(
VIS
:
ident
(
#
[
attr
:
meta
]
)
*
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
MAKE
TY
VIS
(
#
[
attr
]
)
*
N
)
;
__lazy_static_internal
!
(
TAIL
N
:
T
=
e
)
;
__lazy_static_internal
!
(
(
t
)
*
)
;
}
;
(
TAIL
N
:
ident
:
T
:
ty
=
e
:
expr
)
=
>
{
impl
crate
:
:
__Deref
for
N
{
type
Target
=
T
;
#
[
allow
(
unsafe_code
)
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
#
[
inline
(
always
)
]
fn
__static_ref_initialize
(
)
-
>
T
{
e
}
#
[
inline
(
always
)
]
unsafe
fn
__stability
(
)
-
>
&
'
static
T
{
__lazy_static_create
!
(
LAZY
T
)
;
LAZY
.
get
(
__static_ref_initialize
)
}
__stability
(
)
}
}
}
impl
crate
:
:
LazyStatic
for
N
{
fn
initialize
(
lazy
:
&
Self
)
{
let
_
=
&
*
*
lazy
;
}
}
}
;
(
MAKE
TY
PUB
(
#
[
attr
:
meta
]
)
*
N
:
ident
)
=
>
{
#
[
allow
(
missing_copy_implementations
)
]
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
dead_code
)
]
(
#
[
attr
]
)
*
pub
struct
N
{
__private_field
:
(
)
}
#
[
doc
(
hidden
)
]
pub
static
N
:
N
=
N
{
__private_field
:
(
)
}
;
}
;
(
MAKE
TY
PUB_IN
pub_in
:
path
(
#
[
attr
:
meta
]
)
*
N
:
ident
)
=
>
{
#
[
allow
(
missing_copy_implementations
)
]
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
dead_code
)
]
(
#
[
attr
]
)
*
pub
(
in
pub_in
)
struct
N
{
__private_field
:
(
)
}
#
[
doc
(
hidden
)
]
pub
(
in
pub_in
)
static
N
:
N
=
N
{
__private_field
:
(
)
}
;
}
;
(
MAKE
TY
PRIV
(
#
[
attr
:
meta
]
)
*
N
:
ident
)
=
>
{
#
[
allow
(
missing_copy_implementations
)
]
#
[
allow
(
non_camel_case_types
)
]
#
[
allow
(
dead_code
)
]
(
#
[
attr
]
)
*
struct
N
{
__private_field
:
(
)
}
#
[
doc
(
hidden
)
]
static
N
:
N
=
N
{
__private_field
:
(
)
}
;
}
;
(
)
=
>
(
)
}
#
[
macro_export
]
#
[
cfg_attr
(
feature
=
"
nightly
"
allow_internal_unstable
)
]
macro_rules
!
lazy_static
{
(
(
#
[
attr
:
meta
]
)
*
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
PRIV
(
#
[
attr
]
)
*
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
in
pub_in
:
path
)
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
PUB_IN
pub_in
(
#
[
attr
]
)
*
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
(
#
[
attr
:
meta
]
)
*
pub
static
ref
N
:
ident
:
T
:
ty
=
e
:
expr
;
(
t
:
tt
)
*
)
=
>
{
__lazy_static_internal
!
(
PUB
(
#
[
attr
]
)
*
static
ref
N
:
T
=
e
;
(
t
)
*
)
;
}
;
(
)
=
>
(
)
}
pub
trait
LazyStatic
{
#
[
doc
(
hidden
)
]
fn
initialize
(
lazy
:
&
Self
)
;
}
pub
fn
initialize
<
T
:
LazyStatic
>
(
lazy
:
&
T
)
{
LazyStatic
:
:
initialize
(
lazy
)
;
}
