use
{
AsHandleRef
Cookied
HandleBased
Handle
HandleRef
Peered
Status
}
;
use
{
sys
into_result
}
;
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
EventPair
(
Handle
)
;
impl_handle_based
!
(
EventPair
)
;
impl
Peered
for
EventPair
{
}
impl
Cookied
for
EventPair
{
}
impl
EventPair
{
pub
fn
create
(
options
:
EventPairOpts
)
-
>
Result
<
(
EventPair
EventPair
)
Status
>
{
let
mut
out0
=
0
;
let
mut
out1
=
0
;
let
status
=
unsafe
{
sys
:
:
zx_eventpair_create
(
options
as
u32
&
mut
out0
&
mut
out1
)
}
;
into_result
(
status
|
|
(
Self
:
:
from
(
Handle
(
out0
)
)
Self
:
:
from
(
Handle
(
out1
)
)
)
)
}
}
#
[
repr
(
u32
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
pub
enum
EventPairOpts
{
Default
=
0
}
impl
Default
for
EventPairOpts
{
fn
default
(
)
-
>
Self
{
EventPairOpts
:
:
Default
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
{
Duration
ZX_SIGNAL_LAST_HANDLE
ZX_SIGNAL_NONE
ZX_USER_SIGNAL_0
}
;
use
deadline_after
;
#
[
test
]
fn
wait_and_signal_peer
(
)
{
let
(
p1
p2
)
=
EventPair
:
:
create
(
EventPairOpts
:
:
Default
)
.
unwrap
(
)
;
let
eighty_ms
:
Duration
=
80_000_000
;
assert_eq
!
(
p2
.
wait_handle
(
ZX_USER_SIGNAL_0
deadline_after
(
eighty_ms
)
)
Err
(
Status
:
:
ErrTimedOut
)
)
;
assert
!
(
p1
.
signal_peer
(
ZX_SIGNAL_NONE
ZX_USER_SIGNAL_0
)
.
is_ok
(
)
)
;
assert_eq
!
(
p2
.
wait_handle
(
ZX_USER_SIGNAL_0
deadline_after
(
eighty_ms
)
)
.
unwrap
(
)
ZX_USER_SIGNAL_0
|
ZX_SIGNAL_LAST_HANDLE
)
;
assert_eq
!
(
p2
.
wait_handle
(
ZX_USER_SIGNAL_0
deadline_after
(
eighty_ms
)
)
.
unwrap
(
)
ZX_USER_SIGNAL_0
|
ZX_SIGNAL_LAST_HANDLE
)
;
assert
!
(
p1
.
signal_peer
(
ZX_USER_SIGNAL_0
ZX_SIGNAL_NONE
)
.
is_ok
(
)
)
;
assert_eq
!
(
p2
.
wait_handle
(
ZX_USER_SIGNAL_0
deadline_after
(
eighty_ms
)
)
Err
(
Status
:
:
ErrTimedOut
)
)
;
}
}
