use
{
AsHandleRef
HandleBased
Handle
HandleRef
Peered
Status
Time
usize_into_u32
size_to_u32_sat
}
;
use
{
sys
ok
}
;
use
std
:
:
mem
;
#
[
derive
(
Debug
Eq
PartialEq
Hash
)
]
pub
struct
Channel
(
Handle
)
;
impl_handle_based
!
(
Channel
)
;
impl
Peered
for
Channel
{
}
impl
Channel
{
pub
fn
create
(
)
-
>
Result
<
(
Channel
Channel
)
Status
>
{
unsafe
{
let
mut
handle0
=
0
;
let
mut
handle1
=
0
;
let
opts
=
0
;
ok
(
sys
:
:
zx_channel_create
(
opts
&
mut
handle0
&
mut
handle1
)
)
?
;
Ok
(
(
Self
:
:
from
(
Handle
:
:
from_raw
(
handle0
)
)
Self
:
:
from
(
Handle
:
:
from_raw
(
handle1
)
)
)
)
}
}
pub
fn
read_raw
(
&
self
buf
:
&
mut
MessageBuf
)
-
>
Result
<
Result
<
(
)
Status
>
(
usize
usize
)
>
{
let
opts
=
0
;
unsafe
{
buf
.
clear
(
)
;
let
raw_handle
=
self
.
raw_handle
(
)
;
let
mut
num_bytes
:
u32
=
size_to_u32_sat
(
buf
.
bytes
.
capacity
(
)
)
;
let
mut
num_handles
:
u32
=
size_to_u32_sat
(
buf
.
handles
.
capacity
(
)
)
;
let
status
=
ok
(
sys
:
:
zx_channel_read
(
raw_handle
opts
buf
.
bytes
.
as_mut_ptr
(
)
buf
.
handles
.
as_mut_ptr
(
)
as
*
mut
_
num_bytes
num_handles
&
mut
num_bytes
&
mut
num_handles
)
)
;
if
status
=
=
Err
(
Status
:
:
BUFFER_TOO_SMALL
)
{
Err
(
(
num_bytes
as
usize
num_handles
as
usize
)
)
}
else
{
Ok
(
status
.
map
(
|
(
)
|
{
buf
.
bytes
.
set_len
(
num_bytes
as
usize
)
;
buf
.
handles
.
set_len
(
num_handles
as
usize
)
;
}
)
)
}
}
}
pub
fn
read
(
&
self
buf
:
&
mut
MessageBuf
)
-
>
Result
<
(
)
Status
>
{
loop
{
match
self
.
read_raw
(
buf
)
{
Ok
(
result
)
=
>
return
result
Err
(
(
num_bytes
num_handles
)
)
=
>
{
buf
.
ensure_capacity_bytes
(
num_bytes
)
;
buf
.
ensure_capacity_handles
(
num_handles
)
;
}
}
}
}
pub
fn
write
(
&
self
bytes
:
&
[
u8
]
handles
:
&
mut
Vec
<
Handle
>
)
-
>
Result
<
(
)
Status
>
{
let
opts
=
0
;
let
n_bytes
=
try
!
(
usize_into_u32
(
bytes
.
len
(
)
)
.
map_err
(
|
_
|
Status
:
:
OUT_OF_RANGE
)
)
;
let
n_handles
=
try
!
(
usize_into_u32
(
handles
.
len
(
)
)
.
map_err
(
|
_
|
Status
:
:
OUT_OF_RANGE
)
)
;
unsafe
{
let
status
=
sys
:
:
zx_channel_write
(
self
.
raw_handle
(
)
opts
bytes
.
as_ptr
(
)
n_bytes
handles
.
as_ptr
(
)
as
*
const
sys
:
:
zx_handle_t
n_handles
)
;
ok
(
status
)
?
;
handles
.
set_len
(
0
)
;
Ok
(
(
)
)
}
}
pub
fn
call
(
&
self
timeout
:
Time
bytes
:
&
[
u8
]
handles
:
&
mut
Vec
<
Handle
>
buf
:
&
mut
MessageBuf
)
-
>
Result
<
(
)
(
Status
Status
)
>
{
let
write_num_bytes
=
try
!
(
usize_into_u32
(
bytes
.
len
(
)
)
.
map_err
(
|
_
|
(
Status
:
:
OUT_OF_RANGE
Status
:
:
OK
)
)
)
;
let
write_num_handles
=
try
!
(
usize_into_u32
(
handles
.
len
(
)
)
.
map_err
(
|
_
|
(
Status
:
:
OUT_OF_RANGE
Status
:
:
OK
)
)
)
;
buf
.
clear
(
)
;
let
read_num_bytes
:
u32
=
size_to_u32_sat
(
buf
.
bytes
.
capacity
(
)
)
;
let
read_num_handles
:
u32
=
size_to_u32_sat
(
buf
.
handles
.
capacity
(
)
)
;
let
args
=
sys
:
:
zx_channel_call_args_t
{
wr_bytes
:
bytes
.
as_ptr
(
)
wr_handles
:
handles
.
as_ptr
(
)
as
*
const
sys
:
:
zx_handle_t
rd_bytes
:
buf
.
bytes
.
as_mut_ptr
(
)
rd_handles
:
buf
.
handles
.
as_mut_ptr
(
)
as
*
mut
_
wr_num_bytes
:
write_num_bytes
wr_num_handles
:
write_num_handles
rd_num_bytes
:
read_num_bytes
rd_num_handles
:
read_num_handles
}
;
let
mut
actual_read_bytes
:
u32
=
0
;
let
mut
actual_read_handles
:
u32
=
0
;
let
mut
read_status
=
Status
:
:
OK
.
into_raw
(
)
;
let
options
=
0
;
let
status
=
unsafe
{
Status
:
:
from_raw
(
sys
:
:
zx_channel_call
(
self
.
raw_handle
(
)
options
timeout
.
nanos
(
)
&
args
&
mut
actual_read_bytes
&
mut
actual_read_handles
&
mut
read_status
)
)
}
;
match
status
{
Status
:
:
OK
|
Status
:
:
TIMED_OUT
|
Status
:
:
CALL_FAILED
=
>
{
unsafe
{
handles
.
set_len
(
0
)
;
}
}
_
=
>
{
}
}
unsafe
{
buf
.
bytes
.
set_len
(
actual_read_bytes
as
usize
)
;
buf
.
handles
.
set_len
(
actual_read_handles
as
usize
)
;
}
if
Status
:
:
OK
=
=
status
{
Ok
(
(
)
)
}
else
{
Err
(
(
status
Status
:
:
from_raw
(
read_status
)
)
)
}
}
}
#
[
test
]
pub
fn
test_handle_repr
(
)
{
assert_eq
!
(
:
:
std
:
:
mem
:
:
size_of
:
:
<
sys
:
:
zx_handle_t
>
(
)
4
)
;
assert_eq
!
(
:
:
std
:
:
mem
:
:
size_of
:
:
<
Handle
>
(
)
4
)
;
assert_eq
!
(
:
:
std
:
:
mem
:
:
align_of
:
:
<
sys
:
:
zx_handle_t
>
(
)
:
:
std
:
:
mem
:
:
align_of
:
:
<
Handle
>
(
)
)
;
let
n
:
Vec
<
sys
:
:
zx_handle_t
>
=
vec
!
[
0
100
2
<
<
32
-
1
]
;
let
v
:
Vec
<
Handle
>
=
n
.
iter
(
)
.
map
(
|
h
|
unsafe
{
Handle
:
:
from_raw
(
*
h
)
}
)
.
collect
(
)
;
for
(
handle
raw
)
in
v
.
iter
(
)
.
zip
(
n
.
iter
(
)
)
{
unsafe
{
assert_eq
!
(
*
(
handle
as
*
const
_
as
*
const
[
u8
;
4
]
)
*
(
raw
as
*
const
_
as
*
const
[
u8
;
4
]
)
)
;
}
}
for
h
in
v
.
into_iter
(
)
{
:
:
std
:
:
mem
:
:
forget
(
h
)
;
}
}
impl
AsRef
<
Channel
>
for
Channel
{
fn
as_ref
(
&
self
)
-
>
&
Self
{
&
self
}
}
#
[
derive
(
Default
)
]
#
[
derive
(
Debug
)
]
pub
struct
MessageBuf
{
bytes
:
Vec
<
u8
>
handles
:
Vec
<
Handle
>
}
impl
MessageBuf
{
pub
fn
new
(
)
-
>
Self
{
Default
:
:
default
(
)
}
pub
fn
new_with
(
v
:
Vec
<
u8
>
h
:
Vec
<
Handle
>
)
-
>
Self
{
Self
{
bytes
:
v
handles
:
h
}
}
pub
fn
ensure_capacity_bytes
(
&
mut
self
n_bytes
:
usize
)
{
ensure_capacity
(
&
mut
self
.
bytes
n_bytes
)
;
}
pub
fn
ensure_capacity_handles
(
&
mut
self
n_handles
:
usize
)
{
ensure_capacity
(
&
mut
self
.
handles
n_handles
)
;
}
pub
fn
ensure_initialized_bytes
(
&
mut
self
n_bytes
:
usize
)
{
if
n_bytes
<
=
self
.
bytes
.
len
(
)
{
return
;
}
self
.
bytes
.
resize
(
n_bytes
0
)
;
}
pub
fn
bytes
(
&
self
)
-
>
&
[
u8
]
{
self
.
bytes
.
as_slice
(
)
}
pub
fn
n_handles
(
&
self
)
-
>
usize
{
self
.
handles
.
len
(
)
}
pub
fn
take_handle
(
&
mut
self
index
:
usize
)
-
>
Option
<
Handle
>
{
self
.
handles
.
get_mut
(
index
)
.
and_then
(
|
handle
|
if
handle
.
is_invalid
(
)
{
None
}
else
{
Some
(
mem
:
:
replace
(
handle
Handle
:
:
invalid
(
)
)
)
}
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
bytes
.
clear
(
)
;
self
.
handles
.
clear
(
)
;
}
}
fn
ensure_capacity
<
T
>
(
vec
:
&
mut
Vec
<
T
>
size
:
usize
)
{
let
len
=
vec
.
len
(
)
;
if
size
>
len
{
vec
.
reserve
(
size
-
len
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
{
DurationNum
Rights
Signals
Vmo
}
;
use
std
:
:
thread
;
#
[
test
]
fn
channel_basic
(
)
{
let
(
p1
p2
)
=
Channel
:
:
create
(
)
.
unwrap
(
)
;
let
mut
empty
=
vec
!
[
]
;
assert
!
(
p1
.
write
(
b
"
hello
"
&
mut
empty
)
.
is_ok
(
)
)
;
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
assert
!
(
p2
.
read
(
&
mut
buf
)
.
is_ok
(
)
)
;
assert_eq
!
(
buf
.
bytes
(
)
b
"
hello
"
)
;
}
#
[
test
]
fn
channel_read_raw_too_small
(
)
{
let
(
p1
p2
)
=
Channel
:
:
create
(
)
.
unwrap
(
)
;
let
mut
empty
=
vec
!
[
]
;
assert
!
(
p1
.
write
(
b
"
hello
"
&
mut
empty
)
.
is_ok
(
)
)
;
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
let
result
=
p2
.
read_raw
(
&
mut
buf
)
;
assert_eq
!
(
result
Err
(
(
5
0
)
)
)
;
assert_eq
!
(
buf
.
bytes
(
)
b
"
"
)
;
}
#
[
test
]
fn
channel_send_handle
(
)
{
let
hello_length
:
usize
=
5
;
let
(
p1
p2
)
=
Channel
:
:
create
(
)
.
unwrap
(
)
;
let
vmo
=
Vmo
:
:
create
(
hello_length
as
u64
)
.
unwrap
(
)
;
let
duplicate_vmo_handle
=
vmo
.
duplicate_handle
(
Rights
:
:
SAME_RIGHTS
)
.
unwrap
(
)
.
into
(
)
;
let
mut
handles_to_send
:
Vec
<
Handle
>
=
vec
!
[
duplicate_vmo_handle
]
;
assert
!
(
p1
.
write
(
b
"
"
&
mut
handles_to_send
)
.
is_ok
(
)
)
;
assert
!
(
handles_to_send
.
is_empty
(
)
)
;
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
assert
!
(
p2
.
read
(
&
mut
buf
)
.
is_ok
(
)
)
;
assert_eq
!
(
buf
.
n_handles
(
)
1
)
;
let
received_handle
=
buf
.
take_handle
(
0
)
.
unwrap
(
)
;
assert_eq
!
(
buf
.
n_handles
(
)
1
)
;
assert
!
(
buf
.
take_handle
(
0
)
.
is_none
(
)
)
;
let
received_vmo
=
Vmo
:
:
from
(
received_handle
)
;
assert_eq
!
(
received_vmo
.
write
(
b
"
hello
"
0
)
.
unwrap
(
)
hello_length
)
;
let
mut
read_vec
=
vec
!
[
0
;
hello_length
]
;
assert_eq
!
(
vmo
.
read
(
&
mut
read_vec
0
)
.
unwrap
(
)
hello_length
)
;
assert_eq
!
(
read_vec
b
"
hello
"
)
;
}
#
[
test
]
fn
channel_call_timeout
(
)
{
let
ten_ms
=
10
.
millis
(
)
;
let
(
p1
p2
)
=
Channel
:
:
create
(
)
.
unwrap
(
)
;
let
vmo
=
Vmo
:
:
create
(
0
as
u64
)
.
unwrap
(
)
;
let
duplicate_vmo_handle
=
vmo
.
duplicate_handle
(
Rights
:
:
SAME_RIGHTS
)
.
unwrap
(
)
.
into
(
)
;
let
mut
handles_to_send
:
Vec
<
Handle
>
=
vec
!
[
duplicate_vmo_handle
]
;
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
assert_eq
!
(
p1
.
call
(
ten_ms
.
after_now
(
)
b
"
call
"
&
mut
handles_to_send
&
mut
buf
)
Err
(
(
Status
:
:
TIMED_OUT
Status
:
:
OK
)
)
)
;
assert
!
(
handles_to_send
.
is_empty
(
)
)
;
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
assert
!
(
p2
.
read
(
&
mut
buf
)
.
is_ok
(
)
)
;
assert_eq
!
(
buf
.
bytes
(
)
b
"
call
"
)
;
assert_eq
!
(
buf
.
n_handles
(
)
1
)
;
}
#
[
test
]
fn
channel_call
(
)
{
let
(
p1
p2
)
=
Channel
:
:
create
(
)
.
unwrap
(
)
;
let
(
tx
rx
)
=
:
:
std
:
:
sync
:
:
mpsc
:
:
channel
(
)
;
thread
:
:
spawn
(
move
|
|
{
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
p2
.
wait_handle
(
Signals
:
:
CHANNEL_READABLE
1
.
seconds
(
)
.
after_now
(
)
)
.
expect
(
"
callee
wait
error
"
)
;
p2
.
read
(
&
mut
buf
)
.
expect
(
"
callee
read
error
"
)
;
p2
.
write
(
b
"
txidresponse
"
&
mut
vec
!
[
]
)
.
expect
(
"
callee
write
error
"
)
;
tx
.
send
(
buf
)
.
expect
(
"
callee
mpsc
send
error
"
)
;
}
)
;
let
mut
buf
=
MessageBuf
:
:
new
(
)
;
buf
.
ensure_capacity_bytes
(
12
)
;
p1
.
call
(
30
.
seconds
(
)
.
after_now
(
)
b
"
txidcall
"
&
mut
vec
!
[
]
&
mut
buf
)
.
expect
(
"
channel
call
error
"
)
;
assert_eq
!
(
buf
.
bytes
(
)
b
"
txidresponse
"
)
;
assert_eq
!
(
buf
.
n_handles
(
)
0
)
;
let
sbuf
=
rx
.
recv
(
)
.
expect
(
"
mpsc
channel
recv
error
"
)
;
assert_eq
!
(
sbuf
.
bytes
(
)
b
"
txidcall
"
)
;
assert_eq
!
(
sbuf
.
n_handles
(
)
0
)
;
}
}
