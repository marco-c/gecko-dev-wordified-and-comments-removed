use
{
AsHandleRef
HandleBased
Handle
HandleRef
Status
}
;
use
{
sys
ok
}
;
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
Fifo
(
Handle
)
;
impl_handle_based
!
(
Fifo
)
;
impl
Fifo
{
pub
fn
create
(
elem_count
:
u32
elem_size
:
u32
)
-
>
Result
<
(
Fifo
Fifo
)
Status
>
{
let
mut
out0
=
0
;
let
mut
out1
=
0
;
let
options
=
0
;
let
status
=
unsafe
{
sys
:
:
zx_fifo_create
(
elem_count
elem_size
options
&
mut
out0
&
mut
out1
)
}
;
ok
(
status
)
?
;
unsafe
{
Ok
(
(
Self
:
:
from
(
Handle
:
:
from_raw
(
out0
)
)
Self
:
:
from
(
Handle
:
:
from_raw
(
out1
)
)
)
)
}
}
pub
fn
write
(
&
self
bytes
:
&
[
u8
]
)
-
>
Result
<
u32
Status
>
{
let
mut
num_entries_written
=
0
;
let
status
=
unsafe
{
sys
:
:
zx_fifo_write
(
self
.
raw_handle
(
)
bytes
.
as_ptr
(
)
bytes
.
len
(
)
&
mut
num_entries_written
)
}
;
ok
(
status
)
.
map
(
|
(
)
|
num_entries_written
)
}
pub
fn
read
(
&
self
bytes
:
&
mut
[
u8
]
)
-
>
Result
<
u32
Status
>
{
let
mut
num_entries_read
=
0
;
let
status
=
unsafe
{
sys
:
:
zx_fifo_read
(
self
.
raw_handle
(
)
bytes
.
as_mut_ptr
(
)
bytes
.
len
(
)
&
mut
num_entries_read
)
}
;
ok
(
status
)
.
map
(
|
(
)
|
num_entries_read
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
fifo_basic
(
)
{
let
(
fifo1
fifo2
)
=
Fifo
:
:
create
(
4
2
)
.
unwrap
(
)
;
assert_eq
!
(
fifo1
.
write
(
b
"
"
)
Err
(
Status
:
:
OUT_OF_RANGE
)
)
;
assert_eq
!
(
fifo1
.
write
(
b
"
h
"
)
Err
(
Status
:
:
OUT_OF_RANGE
)
)
;
assert_eq
!
(
fifo1
.
write
(
b
"
hex
"
)
.
unwrap
(
)
1
)
;
assert_eq
!
(
fifo1
.
write
(
b
"
llo
worlds
"
)
.
unwrap
(
)
3
)
;
assert_eq
!
(
fifo1
.
write
(
b
"
blah
blah
"
)
Err
(
Status
:
:
SHOULD_WAIT
)
)
;
let
mut
read_vec
=
vec
!
[
0
;
8
]
;
assert_eq
!
(
fifo2
.
read
(
&
mut
read_vec
)
.
unwrap
(
)
4
)
;
assert_eq
!
(
read_vec
b
"
hello
wo
"
)
;
assert_eq
!
(
fifo2
.
read
(
&
mut
read_vec
)
Err
(
Status
:
:
SHOULD_WAIT
)
)
;
}
}
