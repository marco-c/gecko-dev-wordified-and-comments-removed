use
{
AsHandleRef
Cookied
HandleBased
Handle
HandleRef
Status
}
;
use
{
sys
ok
}
;
use
std
:
:
{
mem
ptr
}
;
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
struct
Vmo
(
Handle
)
;
impl_handle_based
!
(
Vmo
)
;
impl
Cookied
for
Vmo
{
}
impl
Vmo
{
pub
fn
create
(
size
:
u64
)
-
>
Result
<
Vmo
Status
>
{
let
mut
handle
=
0
;
let
opts
=
0
;
let
status
=
unsafe
{
sys
:
:
zx_vmo_create
(
size
opts
&
mut
handle
)
}
;
ok
(
status
)
?
;
unsafe
{
Ok
(
Vmo
:
:
from
(
Handle
:
:
from_raw
(
handle
)
)
)
}
}
pub
fn
read
(
&
self
data
:
&
mut
[
u8
]
offset
:
u64
)
-
>
Result
<
usize
Status
>
{
unsafe
{
let
mut
actual
=
0
;
let
status
=
sys
:
:
zx_vmo_read
(
self
.
raw_handle
(
)
data
.
as_mut_ptr
(
)
offset
data
.
len
(
)
&
mut
actual
)
;
ok
(
status
)
.
map
(
|
(
)
|
actual
)
}
}
pub
fn
write
(
&
self
data
:
&
[
u8
]
offset
:
u64
)
-
>
Result
<
usize
Status
>
{
unsafe
{
let
mut
actual
=
0
;
let
status
=
sys
:
:
zx_vmo_write
(
self
.
raw_handle
(
)
data
.
as_ptr
(
)
offset
data
.
len
(
)
&
mut
actual
)
;
ok
(
status
)
.
map
(
|
(
)
|
actual
)
}
}
pub
fn
get_size
(
&
self
)
-
>
Result
<
u64
Status
>
{
let
mut
size
=
0
;
let
status
=
unsafe
{
sys
:
:
zx_vmo_get_size
(
self
.
raw_handle
(
)
&
mut
size
)
}
;
ok
(
status
)
.
map
(
|
(
)
|
size
)
}
pub
fn
set_size
(
&
self
size
:
u64
)
-
>
Result
<
(
)
Status
>
{
let
status
=
unsafe
{
sys
:
:
zx_vmo_set_size
(
self
.
raw_handle
(
)
size
)
}
;
ok
(
status
)
}
pub
fn
op_range
(
&
self
op
:
VmoOp
offset
:
u64
size
:
u64
)
-
>
Result
<
(
)
Status
>
{
let
status
=
unsafe
{
sys
:
:
zx_vmo_op_range
(
self
.
raw_handle
(
)
op
.
into_raw
(
)
offset
size
ptr
:
:
null_mut
(
)
0
)
}
;
ok
(
status
)
}
pub
fn
lookup
(
&
self
offset
:
u64
size
:
u64
buffer
:
&
mut
[
sys
:
:
zx_paddr_t
]
)
-
>
Result
<
(
)
Status
>
{
let
status
=
unsafe
{
sys
:
:
zx_vmo_op_range
(
self
.
raw_handle
(
)
VmoOp
:
:
LOOKUP
.
into_raw
(
)
offset
size
buffer
.
as_mut_ptr
(
)
as
*
mut
u8
buffer
.
len
(
)
*
mem
:
:
size_of
:
:
<
sys
:
:
zx_paddr_t
>
(
)
)
}
;
ok
(
status
)
}
pub
fn
clone
(
&
self
offset
:
u64
size
:
u64
)
-
>
Result
<
Vmo
Status
>
{
let
mut
out
=
0
;
let
opts
=
sys
:
:
ZX_VMO_CLONE_COPY_ON_WRITE
;
let
status
=
unsafe
{
sys
:
:
zx_vmo_clone
(
self
.
raw_handle
(
)
opts
offset
size
&
mut
out
)
}
;
ok
(
status
)
?
;
unsafe
{
Ok
(
Vmo
:
:
from
(
Handle
:
:
from_raw
(
out
)
)
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
VmoOp
(
u32
)
;
impl
VmoOp
{
pub
fn
from_raw
(
raw
:
u32
)
-
>
VmoOp
{
VmoOp
(
raw
)
}
pub
fn
into_raw
(
self
)
-
>
u32
{
self
.
0
}
}
assoc_consts
!
(
VmoOp
[
COMMIT
=
sys
:
:
ZX_VMO_OP_COMMIT
;
DECOMMIT
=
sys
:
:
ZX_VMO_OP_DECOMMIT
;
LOCK
=
sys
:
:
ZX_VMO_OP_LOCK
;
UNLOCK
=
sys
:
:
ZX_VMO_OP_UNLOCK
;
LOOKUP
=
sys
:
:
ZX_VMO_OP_LOOKUP
;
CACHE_SYNC
=
sys
:
:
ZX_VMO_OP_CACHE_SYNC
;
CACHE_INVALIDATE
=
sys
:
:
ZX_VMO_OP_CACHE_INVALIDATE
;
CACHE_CLEAN
=
sys
:
:
ZX_VMO_OP_CACHE_CLEAN
;
CACHE_CLEAN_INVALIDATE
=
sys
:
:
ZX_VMO_OP_CACHE_CLEAN_INVALIDATE
;
]
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
vmo_get_size
(
)
{
let
size
=
16
*
1024
*
1024
;
let
vmo
=
Vmo
:
:
create
(
size
)
.
unwrap
(
)
;
assert_eq
!
(
size
vmo
.
get_size
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
vmo_set_size
(
)
{
let
start_size
=
12
;
let
vmo
=
Vmo
:
:
create
(
start_size
)
.
unwrap
(
)
;
assert_eq
!
(
start_size
vmo
.
get_size
(
)
.
unwrap
(
)
)
;
let
new_size
=
23
;
assert
!
(
vmo
.
set_size
(
new_size
)
.
is_ok
(
)
)
;
assert_eq
!
(
new_size
vmo
.
get_size
(
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
vmo_read_write
(
)
{
let
mut
vec1
=
vec
!
[
0
;
16
]
;
let
vmo
=
Vmo
:
:
create
(
vec1
.
len
(
)
as
u64
)
.
unwrap
(
)
;
assert_eq
!
(
vmo
.
write
(
b
"
abcdef
"
0
)
Ok
(
6
)
)
;
assert_eq
!
(
16
vmo
.
read
(
&
mut
vec1
0
)
.
unwrap
(
)
)
;
assert_eq
!
(
b
"
abcdef
"
&
vec1
[
0
.
.
6
]
)
;
assert_eq
!
(
vmo
.
write
(
b
"
123
"
2
)
Ok
(
3
)
)
;
assert_eq
!
(
16
vmo
.
read
(
&
mut
vec1
0
)
.
unwrap
(
)
)
;
assert_eq
!
(
b
"
ab123f
"
&
vec1
[
0
.
.
6
]
)
;
assert_eq
!
(
15
vmo
.
read
(
&
mut
vec1
1
)
.
unwrap
(
)
)
;
assert_eq
!
(
b
"
b123f
"
&
vec1
[
0
.
.
5
]
)
;
}
#
[
test
]
fn
vmo_op_range_unsupported
(
)
{
let
vmo
=
Vmo
:
:
create
(
12
)
.
unwrap
(
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
LOCK
0
1
)
Err
(
Status
:
:
NOT_SUPPORTED
)
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
UNLOCK
0
1
)
Err
(
Status
:
:
NOT_SUPPORTED
)
)
;
}
#
[
test
]
fn
vmo_lookup
(
)
{
let
vmo
=
Vmo
:
:
create
(
12
)
.
unwrap
(
)
;
let
mut
buffer
=
vec
!
[
0
;
2
]
;
assert_eq
!
(
vmo
.
lookup
(
0
12
&
mut
buffer
)
Err
(
Status
:
:
NO_MEMORY
)
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
COMMIT
0
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
vmo
.
lookup
(
0
12
&
mut
buffer
)
Ok
(
(
)
)
)
;
assert_ne
!
(
buffer
[
0
]
0
)
;
assert_eq
!
(
buffer
[
1
]
0
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
DECOMMIT
0
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
vmo
.
lookup
(
0
12
&
mut
buffer
)
Err
(
Status
:
:
NO_MEMORY
)
)
;
}
#
[
test
]
fn
vmo_cache
(
)
{
let
vmo
=
Vmo
:
:
create
(
12
)
.
unwrap
(
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
CACHE_SYNC
0
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
CACHE_INVALIDATE
0
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
CACHE_CLEAN
0
12
)
Ok
(
(
)
)
)
;
assert_eq
!
(
vmo
.
op_range
(
VmoOp
:
:
CACHE_CLEAN_INVALIDATE
0
12
)
Ok
(
(
)
)
)
;
}
#
[
test
]
fn
vmo_clone
(
)
{
let
original
=
Vmo
:
:
create
(
12
)
.
unwrap
(
)
;
assert_eq
!
(
original
.
write
(
b
"
one
"
0
)
Ok
(
3
)
)
;
let
clone
=
original
.
clone
(
0
10
)
.
unwrap
(
)
;
let
mut
read_buffer
=
vec
!
[
0
;
16
]
;
assert_eq
!
(
clone
.
read
(
&
mut
read_buffer
0
)
Ok
(
10
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
3
]
b
"
one
"
)
;
assert_eq
!
(
original
.
write
(
b
"
two
"
0
)
Ok
(
3
)
)
;
assert_eq
!
(
original
.
read
(
&
mut
read_buffer
0
)
Ok
(
12
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
3
]
b
"
two
"
)
;
assert_eq
!
(
clone
.
read
(
&
mut
read_buffer
0
)
Ok
(
10
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
3
]
b
"
two
"
)
;
assert_eq
!
(
clone
.
write
(
b
"
three
"
0
)
Ok
(
5
)
)
;
assert_eq
!
(
original
.
read
(
&
mut
read_buffer
0
)
Ok
(
12
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
3
]
b
"
two
"
)
;
assert_eq
!
(
clone
.
read
(
&
mut
read_buffer
0
)
Ok
(
10
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
5
]
b
"
three
"
)
;
assert_eq
!
(
original
.
write
(
b
"
four
"
0
)
Ok
(
4
)
)
;
assert_eq
!
(
original
.
read
(
&
mut
read_buffer
0
)
Ok
(
12
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
4
]
b
"
four
"
)
;
assert_eq
!
(
clone
.
read
(
&
mut
read_buffer
0
)
Ok
(
10
)
)
;
assert_eq
!
(
&
read_buffer
[
0
.
.
5
]
b
"
three
"
)
;
}
}
