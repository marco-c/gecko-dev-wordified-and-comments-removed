use
core
:
:
fmt
;
if_std
!
{
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
self
Read
}
;
}
use
crate
:
:
error
;
use
crate
:
:
mach
:
:
constants
:
:
cputype
:
:
{
CpuSubType
CpuType
CPU_ARCH_ABI64
CPU_SUBTYPE_MASK
}
;
use
scroll
:
:
{
Pread
Pwrite
SizeWith
}
;
pub
const
FAT_MAGIC
:
u32
=
0xcafe_babe
;
pub
const
FAT_CIGAM
:
u32
=
0xbeba_feca
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Default
Pread
Pwrite
SizeWith
)
]
pub
struct
FatHeader
{
pub
magic
:
u32
pub
nfat_arch
:
u32
}
pub
const
SIZEOF_FAT_HEADER
:
usize
=
8
;
impl
fmt
:
:
Debug
for
FatHeader
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
FatHeader
"
)
.
field
(
"
magic
"
&
format_args
!
(
"
0x
{
:
x
}
"
self
.
magic
)
)
.
field
(
"
nfat_arch
"
&
self
.
nfat_arch
)
.
finish
(
)
}
}
impl
FatHeader
{
pub
fn
from_bytes
(
bytes
:
[
u8
;
SIZEOF_FAT_HEADER
]
)
-
>
FatHeader
{
let
mut
offset
=
0
;
let
magic
=
bytes
.
gread_with
(
&
mut
offset
scroll
:
:
BE
)
.
unwrap
(
)
;
let
nfat_arch
=
bytes
.
gread_with
(
&
mut
offset
scroll
:
:
BE
)
.
unwrap
(
)
;
FatHeader
{
magic
nfat_arch
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
from_fd
(
fd
:
&
mut
File
)
-
>
io
:
:
Result
<
FatHeader
>
{
let
mut
header
=
[
0
;
SIZEOF_FAT_HEADER
]
;
fd
.
read_exact
(
&
mut
header
)
?
;
Ok
(
FatHeader
:
:
from_bytes
(
header
)
)
}
pub
fn
parse
(
bytes
:
&
[
u8
]
)
-
>
error
:
:
Result
<
FatHeader
>
{
Ok
(
bytes
.
pread_with
:
:
<
FatHeader
>
(
0
scroll
:
:
BE
)
?
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Default
Pread
Pwrite
SizeWith
)
]
pub
struct
FatArch
{
pub
cputype
:
u32
pub
cpusubtype
:
u32
pub
offset
:
u32
pub
size
:
u32
pub
align
:
u32
}
pub
const
SIZEOF_FAT_ARCH
:
usize
=
20
;
impl
fmt
:
:
Debug
for
FatArch
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
.
debug_struct
(
"
FatArch
"
)
.
field
(
"
cputype
"
&
self
.
cputype
(
)
)
.
field
(
"
cmdsize
"
&
self
.
cpusubtype
(
)
)
.
field
(
"
offset
"
&
format_args
!
(
"
{
:
#
x
}
"
&
self
.
offset
)
)
.
field
(
"
size
"
&
self
.
size
)
.
field
(
"
align
"
&
self
.
align
)
.
finish
(
)
}
}
impl
FatArch
{
pub
fn
slice
<
'
a
>
(
&
self
bytes
:
&
'
a
[
u8
]
)
-
>
&
'
a
[
u8
]
{
let
start
=
self
.
offset
as
usize
;
match
start
.
checked_add
(
self
.
size
as
usize
)
.
and_then
(
|
end
|
bytes
.
get
(
start
.
.
end
)
)
{
Some
(
slice
)
=
>
slice
None
=
>
{
log
:
:
warn
!
(
"
invalid
FatArch
offset
"
)
;
&
[
]
}
}
}
pub
fn
cputype
(
&
self
)
-
>
CpuType
{
self
.
cputype
}
pub
fn
cpusubtype
(
&
self
)
-
>
CpuSubType
{
self
.
cpusubtype
&
!
CPU_SUBTYPE_MASK
}
pub
fn
cpu_caps
(
&
self
)
-
>
u32
{
(
self
.
cpusubtype
&
CPU_SUBTYPE_MASK
)
>
>
24
}
pub
fn
is_64
(
&
self
)
-
>
bool
{
(
self
.
cputype
&
CPU_ARCH_ABI64
)
=
=
CPU_ARCH_ABI64
}
pub
fn
parse
(
bytes
:
&
[
u8
]
offset
:
usize
)
-
>
error
:
:
Result
<
Self
>
{
let
arch
=
bytes
.
pread_with
:
:
<
FatArch
>
(
offset
scroll
:
:
BE
)
?
;
Ok
(
arch
)
}
}
