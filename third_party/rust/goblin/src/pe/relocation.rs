use
crate
:
:
error
;
use
scroll
:
:
{
IOread
IOwrite
Pread
Pwrite
SizeWith
}
;
pub
const
COFF_RELOCATION_SIZE
:
usize
=
10
;
pub
const
IMAGE_REL_I386_ABSOLUTE
:
u16
=
0x0000
;
pub
const
IMAGE_REL_I386_DIR16
:
u16
=
0x0001
;
pub
const
IMAGE_REL_I386_REL16
:
u16
=
0x0002
;
pub
const
IMAGE_REL_I386_DIR32
:
u16
=
0x0006
;
pub
const
IMAGE_REL_I386_DIR32NB
:
u16
=
0x0007
;
pub
const
IMAGE_REL_I386_SEG12
:
u16
=
0x0009
;
pub
const
IMAGE_REL_I386_SECTION
:
u16
=
0x000A
;
pub
const
IMAGE_REL_I386_SECREL
:
u16
=
0x000B
;
pub
const
IMAGE_REL_I386_TOKEN
:
u16
=
0x000C
;
pub
const
IMAGE_REL_I386_SECREL7
:
u16
=
0x000D
;
pub
const
IMAGE_REL_I386_REL32
:
u16
=
0x0014
;
pub
const
IMAGE_REL_AMD64_ABSOLUTE
:
u16
=
0x0000
;
pub
const
IMAGE_REL_AMD64_ADDR64
:
u16
=
0x0001
;
pub
const
IMAGE_REL_AMD64_ADDR32
:
u16
=
0x0002
;
pub
const
IMAGE_REL_AMD64_ADDR32NB
:
u16
=
0x0003
;
pub
const
IMAGE_REL_AMD64_REL32
:
u16
=
0x0004
;
pub
const
IMAGE_REL_AMD64_REL32_1
:
u16
=
0x0005
;
pub
const
IMAGE_REL_AMD64_REL32_2
:
u16
=
0x0006
;
pub
const
IMAGE_REL_AMD64_REL32_3
:
u16
=
0x0007
;
pub
const
IMAGE_REL_AMD64_REL32_4
:
u16
=
0x0008
;
pub
const
IMAGE_REL_AMD64_REL32_5
:
u16
=
0x0009
;
pub
const
IMAGE_REL_AMD64_SECTION
:
u16
=
0x000A
;
pub
const
IMAGE_REL_AMD64_SECREL
:
u16
=
0x000B
;
pub
const
IMAGE_REL_AMD64_SECREL7
:
u16
=
0x000C
;
pub
const
IMAGE_REL_AMD64_TOKEN
:
u16
=
0x000D
;
pub
const
IMAGE_REL_AMD64_SREL32
:
u16
=
0x000E
;
pub
const
IMAGE_REL_AMD64_PAIR
:
u16
=
0x000F
;
pub
const
IMAGE_REL_AMD64_SSPAN32
:
u16
=
0x0010
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Default
Pread
Pwrite
IOread
IOwrite
SizeWith
)
]
pub
struct
Relocation
{
pub
virtual_address
:
u32
pub
symbol_table_index
:
u32
pub
typ
:
u16
}
#
[
derive
(
Default
)
]
pub
struct
Relocations
<
'
a
>
{
offset
:
usize
relocations
:
&
'
a
[
u8
]
}
impl
<
'
a
>
Relocations
<
'
a
>
{
pub
fn
parse
(
bytes
:
&
'
a
[
u8
]
offset
:
usize
number
:
usize
)
-
>
error
:
:
Result
<
Relocations
<
'
a
>
>
{
let
relocations
=
bytes
.
pread_with
(
offset
number
*
COFF_RELOCATION_SIZE
)
?
;
Ok
(
Relocations
{
offset
:
0
relocations
}
)
}
}
impl
<
'
a
>
Iterator
for
Relocations
<
'
a
>
{
type
Item
=
Relocation
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
offset
>
=
self
.
relocations
.
len
(
)
{
None
}
else
{
Some
(
self
.
relocations
.
gread_with
(
&
mut
self
.
offset
scroll
:
:
LE
)
.
unwrap
(
)
)
}
}
}
