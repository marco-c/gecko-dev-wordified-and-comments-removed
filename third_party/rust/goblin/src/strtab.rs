use
core
:
:
ops
:
:
Index
;
use
core
:
:
slice
;
use
core
:
:
str
;
use
core
:
:
fmt
;
use
scroll
:
:
{
ctx
Pread
}
;
if_alloc
!
{
use
crate
:
:
error
;
use
crate
:
:
alloc
:
:
vec
:
:
Vec
;
}
pub
struct
Strtab
<
'
a
>
{
bytes
:
&
'
a
[
u8
]
delim
:
ctx
:
:
StrCtx
}
#
[
inline
(
always
)
]
fn
get_str
(
offset
:
usize
bytes
:
&
[
u8
]
delim
:
ctx
:
:
StrCtx
)
-
>
scroll
:
:
Result
<
&
str
>
{
bytes
.
pread_with
:
:
<
&
str
>
(
offset
delim
)
}
impl
<
'
a
>
Strtab
<
'
a
>
{
pub
fn
new
(
bytes
:
&
'
a
[
u8
]
delim
:
u8
)
-
>
Self
{
Strtab
{
delim
:
ctx
:
:
StrCtx
:
:
Delimiter
(
delim
)
bytes
}
}
pub
unsafe
fn
from_raw
(
ptr
:
*
const
u8
size
:
usize
delim
:
u8
)
-
>
Strtab
<
'
a
>
{
Strtab
{
delim
:
ctx
:
:
StrCtx
:
:
Delimiter
(
delim
)
bytes
:
slice
:
:
from_raw_parts
(
ptr
size
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
parse
(
bytes
:
&
'
a
[
u8
]
offset
:
usize
len
:
usize
delim
:
u8
)
-
>
error
:
:
Result
<
Strtab
<
'
a
>
>
{
let
(
end
overflow
)
=
offset
.
overflowing_add
(
len
)
;
if
overflow
|
|
end
>
bytes
.
len
(
)
{
return
Err
(
error
:
:
Error
:
:
Malformed
(
format
!
(
"
Strtable
size
(
{
}
)
+
offset
(
{
}
)
is
out
of
bounds
for
{
}
#
bytes
.
Overflowed
:
{
}
"
len
offset
bytes
.
len
(
)
overflow
)
)
)
;
}
Ok
(
Strtab
{
bytes
:
&
bytes
[
offset
.
.
end
]
delim
:
ctx
:
:
StrCtx
:
:
Delimiter
(
delim
)
}
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
to_vec
(
&
self
)
-
>
error
:
:
Result
<
Vec
<
&
'
a
str
>
>
{
let
len
=
self
.
bytes
.
len
(
)
;
let
mut
strings
=
Vec
:
:
with_capacity
(
len
)
;
let
mut
i
=
0
;
while
i
<
len
{
let
string
=
self
.
get
(
i
)
.
unwrap
(
)
?
;
i
=
i
+
string
.
len
(
)
+
1
;
strings
.
push
(
string
)
;
}
Ok
(
strings
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
get
(
&
self
offset
:
usize
)
-
>
Option
<
error
:
:
Result
<
&
'
a
str
>
>
{
if
offset
>
=
self
.
bytes
.
len
(
)
{
None
}
else
{
Some
(
get_str
(
offset
self
.
bytes
self
.
delim
)
.
map_err
(
core
:
:
convert
:
:
Into
:
:
into
)
)
}
}
pub
fn
get_unsafe
(
&
self
offset
:
usize
)
-
>
Option
<
&
'
a
str
>
{
if
offset
>
=
self
.
bytes
.
len
(
)
{
None
}
else
{
Some
(
get_str
(
offset
self
.
bytes
self
.
delim
)
.
unwrap
(
)
)
}
}
}
impl
<
'
a
>
fmt
:
:
Debug
for
Strtab
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Strtab
"
)
.
field
(
"
delim
"
&
self
.
delim
)
.
field
(
"
bytes
"
&
str
:
:
from_utf8
(
self
.
bytes
)
)
.
finish
(
)
}
}
impl
<
'
a
>
Default
for
Strtab
<
'
a
>
{
fn
default
(
)
-
>
Strtab
<
'
a
>
{
Strtab
{
bytes
:
&
[
]
delim
:
ctx
:
:
StrCtx
:
:
default
(
)
}
}
}
impl
<
'
a
>
Index
<
usize
>
for
Strtab
<
'
a
>
{
type
Output
=
str
;
#
[
inline
(
always
)
]
fn
index
(
&
self
offset
:
usize
)
-
>
&
Self
:
:
Output
{
get_str
(
offset
self
.
bytes
self
.
delim
)
.
unwrap
(
)
}
}
#
[
test
]
fn
as_vec_no_final_null
(
)
{
let
bytes
=
b
"
\
0printf
\
0memmove
\
0busta
"
;
let
strtab
=
unsafe
{
Strtab
:
:
from_raw
(
bytes
.
as_ptr
(
)
bytes
.
len
(
)
0x0
)
}
;
let
vec
=
strtab
.
to_vec
(
)
.
unwrap
(
)
;
assert_eq
!
(
vec
.
len
(
)
4
)
;
assert_eq
!
(
vec
vec
!
[
"
"
"
printf
"
"
memmove
"
"
busta
"
]
)
;
}
#
[
test
]
fn
as_vec_no_first_null_no_final_null
(
)
{
let
bytes
=
b
"
printf
\
0memmove
\
0busta
"
;
let
strtab
=
unsafe
{
Strtab
:
:
from_raw
(
bytes
.
as_ptr
(
)
bytes
.
len
(
)
0x0
)
}
;
let
vec
=
strtab
.
to_vec
(
)
.
unwrap
(
)
;
assert_eq
!
(
vec
.
len
(
)
3
)
;
assert_eq
!
(
vec
vec
!
[
"
printf
"
"
memmove
"
"
busta
"
]
)
;
}
#
[
test
]
fn
to_vec_final_null
(
)
{
let
bytes
=
b
"
\
0printf
\
0memmove
\
0busta
\
0
"
;
let
strtab
=
unsafe
{
Strtab
:
:
from_raw
(
bytes
.
as_ptr
(
)
bytes
.
len
(
)
0x0
)
}
;
let
vec
=
strtab
.
to_vec
(
)
.
unwrap
(
)
;
assert_eq
!
(
vec
.
len
(
)
4
)
;
assert_eq
!
(
vec
vec
!
[
"
"
"
printf
"
"
memmove
"
"
busta
"
]
)
;
}
#
[
test
]
fn
to_vec_newline_delim
(
)
{
let
bytes
=
b
"
\
nprintf
\
nmemmove
\
nbusta
\
n
"
;
let
strtab
=
unsafe
{
Strtab
:
:
from_raw
(
bytes
.
as_ptr
(
)
bytes
.
len
(
)
b
'
\
n
'
)
}
;
let
vec
=
strtab
.
to_vec
(
)
.
unwrap
(
)
;
assert_eq
!
(
vec
.
len
(
)
4
)
;
assert_eq
!
(
vec
vec
!
[
"
"
"
printf
"
"
memmove
"
"
busta
"
]
)
;
}
