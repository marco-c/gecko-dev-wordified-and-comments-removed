use
proc_macro
:
:
TokenStream
;
use
quote
:
:
quote
;
use
syn
:
:
{
parse_quote
spanned
:
:
Spanned
}
;
const
ERR_MSG
:
&
str
=
"
Expected
#
[
handle_error
(
path
:
:
to
:
:
Error
)
]
"
;
#
[
proc_macro_attribute
]
pub
fn
handle_error
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
mut
err_path
=
None
;
let
parser
=
syn
:
:
meta
:
:
parser
(
|
meta
|
{
if
meta
.
input
.
is_empty
(
)
&
&
err_path
.
replace
(
meta
.
path
)
.
is_none
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
syn
:
:
Error
:
:
new
(
meta
.
input
.
span
(
)
ERR_MSG
)
)
}
}
)
;
TokenStream
:
:
from
(
match
syn
:
:
parse
:
:
Parser
:
:
parse
(
parser
args
)
.
map_err
(
|
e
|
syn
:
:
Error
:
:
new
(
e
.
span
(
)
ERR_MSG
)
)
.
and_then
(
|
(
)
|
syn
:
:
parse
:
:
<
syn
:
:
Item
>
(
input
)
)
.
and_then
(
|
parsed
|
impl_handle_error
(
&
parsed
err_path
.
unwrap
(
)
)
)
{
Ok
(
res
)
=
>
res
Err
(
e
)
=
>
e
.
to_compile_error
(
)
}
)
}
fn
impl_handle_error
(
input
:
&
syn
:
:
Item
err_path
:
syn
:
:
Path
)
-
>
syn
:
:
Result
<
proc_macro2
:
:
TokenStream
>
{
if
let
syn
:
:
Item
:
:
Fn
(
item_fn
)
=
input
{
let
original_body
=
&
item_fn
.
block
;
let
mut
new_fn
=
item_fn
.
clone
(
)
;
new_fn
.
block
=
parse_quote
!
{
{
(
|
|
-
>
:
:
std
:
:
result
:
:
Result
<
_
#
err_path
>
{
#
original_body
}
)
(
)
.
map_err
(
:
:
error_support
:
:
convert_log_report_error
)
}
}
;
Ok
(
quote
!
{
#
new_fn
}
)
}
else
{
Err
(
syn
:
:
Error
:
:
new
(
input
.
span
(
)
"
#
[
handle_error
(
.
.
)
]
can
only
be
used
on
functions
"
)
)
}
}
