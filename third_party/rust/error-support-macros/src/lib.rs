use
proc_macro
:
:
TokenStream
;
use
quote
:
:
quote
;
use
syn
:
:
{
parse_quote
spanned
:
:
Spanned
}
;
mod
argument
;
#
[
proc_macro_attribute
]
pub
fn
handle_error
(
args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
args
=
syn
:
:
parse_macro_input
!
(
args
as
syn
:
:
AttributeArgs
)
;
let
parsed
=
syn
:
:
parse_macro_input
!
(
input
as
syn
:
:
Item
)
;
TokenStream
:
:
from
(
match
impl_handle_error
(
&
parsed
&
args
)
{
Ok
(
res
)
=
>
res
Err
(
e
)
=
>
e
.
to_compile_error
(
)
}
)
}
fn
impl_handle_error
(
input
:
&
syn
:
:
Item
arguments
:
&
syn
:
:
AttributeArgs
)
-
>
syn
:
:
Result
<
proc_macro2
:
:
TokenStream
>
{
if
let
syn
:
:
Item
:
:
Fn
(
item_fn
)
=
input
{
argument
:
:
validate
(
arguments
)
?
;
let
original_body
=
&
item_fn
.
block
;
let
mut
new_fn
=
item_fn
.
clone
(
)
;
new_fn
.
block
=
parse_quote
!
{
{
/
/
Note
:
the
Result
here
is
a
smell
/
/
because
the
macro
is
*
*
assuming
*
*
a
Result
exists
/
/
that
reflects
the
return
value
of
the
block
/
/
An
improvement
would
include
the
error
of
the
original_block
/
/
as
an
attribute
to
the
macro
itself
.
(
|
|
-
>
Result
<
_
>
{
#
original_body
}
)
(
)
.
map_err
(
:
:
error_support
:
:
convert_log_report_error
)
}
}
;
Ok
(
quote
!
{
#
new_fn
}
)
}
else
{
Err
(
syn
:
:
Error
:
:
new
(
input
.
span
(
)
"
#
[
handle_error
]
can
only
be
used
on
functions
"
)
)
}
}
