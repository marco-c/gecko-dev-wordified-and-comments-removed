use
std
:
:
{
fmt
str
:
:
{
self
FromStr
}
}
;
use
bytes
:
:
Bytes
;
use
http
:
:
header
:
:
HeaderValue
;
use
super
:
:
IterExt
;
#
[
derive
(
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
(
crate
)
struct
HeaderValueString
{
value
:
HeaderValue
}
impl
HeaderValueString
{
pub
(
crate
)
fn
from_val
(
val
:
&
HeaderValue
)
-
>
Result
<
Self
:
:
Error
>
{
if
val
.
to_str
(
)
.
is_ok
(
)
{
Ok
(
HeaderValueString
{
value
:
val
.
clone
(
)
}
)
}
else
{
Err
(
:
:
Error
:
:
invalid
(
)
)
}
}
pub
(
crate
)
fn
from_string
(
src
:
String
)
-
>
Option
<
Self
>
{
let
bytes
=
Bytes
:
:
from
(
src
)
;
HeaderValue
:
:
from_shared
(
bytes
)
.
ok
(
)
.
map
(
|
value
|
HeaderValueString
{
value
}
)
}
pub
(
crate
)
fn
from_static
(
src
:
&
'
static
str
)
-
>
HeaderValueString
{
HeaderValueString
{
value
:
HeaderValue
:
:
from_static
(
src
)
}
}
pub
(
crate
)
fn
as_str
(
&
self
)
-
>
&
str
{
unsafe
{
str
:
:
from_utf8_unchecked
(
self
.
value
.
as_bytes
(
)
)
}
}
}
impl
fmt
:
:
Debug
for
HeaderValueString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
.
as_str
(
)
f
)
}
}
impl
fmt
:
:
Display
for
HeaderValueString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
.
as_str
(
)
f
)
}
}
impl
super
:
:
TryFromValues
for
HeaderValueString
{
fn
try_from_values
<
'
i
I
>
(
values
:
&
mut
I
)
-
>
Result
<
Self
:
:
Error
>
where
I
:
Iterator
<
Item
=
&
'
i
HeaderValue
>
{
values
.
just_one
(
)
.
map
(
HeaderValueString
:
:
from_val
)
.
unwrap_or_else
(
|
|
Err
(
:
:
Error
:
:
invalid
(
)
)
)
}
}
impl
<
'
a
>
From
<
&
'
a
HeaderValueString
>
for
HeaderValue
{
fn
from
(
src
:
&
'
a
HeaderValueString
)
-
>
HeaderValue
{
src
.
value
.
clone
(
)
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
FromStrError
(
(
)
)
;
impl
FromStr
for
HeaderValueString
{
type
Err
=
FromStrError
;
fn
from_str
(
src
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
src
.
parse
(
)
.
map
(
|
value
|
HeaderValueString
{
value
}
)
.
map_err
(
|
_
|
FromStrError
(
(
)
)
)
}
}
