use
base64
;
use
bytes
:
:
Bytes
;
use
{
HeaderValue
}
;
use
util
:
:
HeaderValueString
;
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
struct
Authorization
<
C
:
Credentials
>
(
pub
C
)
;
impl
Authorization
<
Basic
>
{
pub
fn
basic
(
username
:
&
str
password
:
&
str
)
-
>
Self
{
let
colon_pos
=
username
.
len
(
)
;
let
decoded
=
format
!
(
"
{
}
:
{
}
"
username
password
)
;
Authorization
(
Basic
{
decoded
colon_pos
}
)
}
}
impl
Authorization
<
Bearer
>
{
pub
fn
bearer
(
token
:
&
str
)
-
>
Result
<
Self
InvalidBearerToken
>
{
HeaderValueString
:
:
from_string
(
format
!
(
"
Bearer
{
}
"
token
)
)
.
map
(
|
val
|
Authorization
(
Bearer
(
val
)
)
)
.
ok_or_else
(
|
|
InvalidBearerToken
{
_inner
:
(
)
}
)
}
}
impl
<
C
:
Credentials
>
:
:
Header
for
Authorization
<
C
>
{
fn
name
(
)
-
>
&
'
static
:
:
HeaderName
{
&
:
:
http
:
:
header
:
:
AUTHORIZATION
}
fn
decode
<
'
i
I
:
Iterator
<
Item
=
&
'
i
HeaderValue
>
>
(
values
:
&
mut
I
)
-
>
Result
<
Self
:
:
Error
>
{
values
.
next
(
)
.
and_then
(
|
val
|
{
let
slice
=
val
.
as_bytes
(
)
;
if
slice
.
starts_with
(
C
:
:
SCHEME
.
as_bytes
(
)
)
&
&
slice
.
len
(
)
>
C
:
:
SCHEME
.
len
(
)
&
&
slice
[
C
:
:
SCHEME
.
len
(
)
]
=
=
b
'
'
{
C
:
:
decode
(
val
)
.
map
(
Authorization
)
}
else
{
None
}
}
)
.
ok_or_else
(
:
:
Error
:
:
invalid
)
}
fn
encode
<
E
:
Extend
<
:
:
HeaderValue
>
>
(
&
self
values
:
&
mut
E
)
{
let
value
=
self
.
0
.
encode
(
)
;
debug_assert
!
(
value
.
as_bytes
(
)
.
starts_with
(
C
:
:
SCHEME
.
as_bytes
(
)
)
"
Credentials
:
:
encode
should
include
its
scheme
:
scheme
=
{
:
?
}
encoded
=
{
:
?
}
"
C
:
:
SCHEME
value
)
;
values
.
extend
(
:
:
std
:
:
iter
:
:
once
(
value
)
)
;
}
}
pub
trait
Credentials
:
Sized
{
const
SCHEME
:
&
'
static
str
;
fn
decode
(
value
:
&
HeaderValue
)
-
>
Option
<
Self
>
;
fn
encode
(
&
self
)
-
>
HeaderValue
;
}
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
struct
Basic
{
decoded
:
String
colon_pos
:
usize
}
impl
Basic
{
pub
fn
username
(
&
self
)
-
>
&
str
{
&
self
.
decoded
[
.
.
self
.
colon_pos
]
}
pub
fn
password
(
&
self
)
-
>
&
str
{
&
self
.
decoded
[
self
.
colon_pos
+
1
.
.
]
}
}
impl
Credentials
for
Basic
{
const
SCHEME
:
&
'
static
str
=
"
Basic
"
;
fn
decode
(
value
:
&
HeaderValue
)
-
>
Option
<
Self
>
{
debug_assert
!
(
value
.
as_bytes
(
)
.
starts_with
(
b
"
Basic
"
)
"
HeaderValue
to
decode
should
start
with
\
"
Basic
.
.
\
"
received
=
{
:
?
}
"
value
)
;
let
bytes
=
&
value
.
as_bytes
(
)
[
"
Basic
"
.
len
(
)
.
.
]
;
let
non_space_pos
=
bytes
.
iter
(
)
.
position
(
|
b
|
*
b
!
=
b
'
'
)
?
;
let
bytes
=
&
bytes
[
non_space_pos
.
.
]
;
let
bytes
=
base64
:
:
decode
(
bytes
)
.
ok
(
)
?
;
let
decoded
=
String
:
:
from_utf8
(
bytes
)
.
ok
(
)
?
;
let
colon_pos
=
decoded
.
find
(
'
:
'
)
?
;
Some
(
Basic
{
decoded
colon_pos
}
)
}
fn
encode
(
&
self
)
-
>
HeaderValue
{
let
mut
encoded
=
String
:
:
from
(
"
Basic
"
)
;
base64
:
:
encode_config_buf
(
&
self
.
decoded
base64
:
:
STANDARD
&
mut
encoded
)
;
let
bytes
=
Bytes
:
:
from
(
encoded
)
;
HeaderValue
:
:
from_shared
(
bytes
)
.
expect
(
"
base64
encoding
is
always
a
valid
HeaderValue
"
)
}
}
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
struct
Bearer
(
HeaderValueString
)
;
impl
Bearer
{
pub
fn
token
(
&
self
)
-
>
&
str
{
&
self
.
0
.
as_str
(
)
[
"
Bearer
"
.
len
(
)
.
.
]
}
}
impl
Credentials
for
Bearer
{
const
SCHEME
:
&
'
static
str
=
"
Bearer
"
;
fn
decode
(
value
:
&
HeaderValue
)
-
>
Option
<
Self
>
{
debug_assert
!
(
value
.
as_bytes
(
)
.
starts_with
(
b
"
Bearer
"
)
"
HeaderValue
to
decode
should
start
with
\
"
Bearer
.
.
\
"
received
=
{
:
?
}
"
value
)
;
HeaderValueString
:
:
from_val
(
value
)
.
ok
(
)
.
map
(
Bearer
)
}
fn
encode
(
&
self
)
-
>
HeaderValue
{
(
&
self
.
0
)
.
into
(
)
}
}
error_type
!
(
InvalidBearerToken
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
:
:
HeaderMapExt
;
use
http
:
:
header
:
:
HeaderMap
;
use
super
:
:
{
Authorization
Basic
Bearer
}
;
use
super
:
:
super
:
:
{
test_decode
test_encode
}
;
#
[
test
]
fn
basic_encode
(
)
{
let
auth
=
Authorization
:
:
basic
(
"
Aladdin
"
"
open
sesame
"
)
;
let
headers
=
test_encode
(
auth
)
;
assert_eq
!
(
headers
[
"
authorization
"
]
"
Basic
QWxhZGRpbjpvcGVuIHNlc2FtZQ
=
=
"
)
;
}
#
[
test
]
fn
basic_roundtrip
(
)
{
let
auth
=
Authorization
:
:
basic
(
"
Aladdin
"
"
open
sesame
"
)
;
let
mut
h
=
HeaderMap
:
:
new
(
)
;
h
.
typed_insert
(
auth
.
clone
(
)
)
;
assert_eq
!
(
h
.
typed_get
(
)
Some
(
auth
)
)
;
}
#
[
test
]
fn
basic_encode_no_password
(
)
{
let
auth
=
Authorization
:
:
basic
(
"
Aladdin
"
"
"
)
;
let
headers
=
test_encode
(
auth
)
;
assert_eq
!
(
headers
[
"
authorization
"
]
"
Basic
QWxhZGRpbjo
=
"
)
;
}
#
[
test
]
fn
basic_decode
(
)
{
let
auth
:
Authorization
<
Basic
>
=
test_decode
(
&
[
"
Basic
QWxhZGRpbjpvcGVuIHNlc2FtZQ
=
=
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
auth
.
0
.
username
(
)
"
Aladdin
"
)
;
assert_eq
!
(
auth
.
0
.
password
(
)
"
open
sesame
"
)
;
}
#
[
test
]
fn
basic_decode_no_password
(
)
{
let
auth
:
Authorization
<
Basic
>
=
test_decode
(
&
[
"
Basic
QWxhZGRpbjo
=
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
auth
.
0
.
username
(
)
"
Aladdin
"
)
;
assert_eq
!
(
auth
.
0
.
password
(
)
"
"
)
;
}
#
[
test
]
fn
bearer_encode
(
)
{
let
auth
=
Authorization
:
:
bearer
(
"
fpKL54jvWmEGVoRdCNjG
"
)
.
unwrap
(
)
;
let
headers
=
test_encode
(
auth
)
;
assert_eq
!
(
headers
[
"
authorization
"
]
"
Bearer
fpKL54jvWmEGVoRdCNjG
"
)
;
}
#
[
test
]
fn
bearer_decode
(
)
{
let
auth
:
Authorization
<
Bearer
>
=
test_decode
(
&
[
"
Bearer
fpKL54jvWmEGVoRdCNjG
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
auth
.
0
.
token
(
)
.
as_bytes
(
)
b
"
fpKL54jvWmEGVoRdCNjG
"
)
;
}
}
