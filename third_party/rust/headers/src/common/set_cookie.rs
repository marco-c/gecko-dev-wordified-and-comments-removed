#
[
derive
(
Clone
Debug
)
]
pub
struct
SetCookie
(
Vec
<
:
:
HeaderValue
>
)
;
impl
:
:
Header
for
SetCookie
{
fn
name
(
)
-
>
&
'
static
:
:
HeaderName
{
&
:
:
http
:
:
header
:
:
SET_COOKIE
}
fn
decode
<
'
i
I
:
Iterator
<
Item
=
&
'
i
:
:
HeaderValue
>
>
(
values
:
&
mut
I
)
-
>
Result
<
Self
:
:
Error
>
{
let
vec
=
values
.
cloned
(
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
if
!
vec
.
is_empty
(
)
{
Ok
(
SetCookie
(
vec
)
)
}
else
{
Err
(
:
:
Error
:
:
invalid
(
)
)
}
}
fn
encode
<
E
:
Extend
<
:
:
HeaderValue
>
>
(
&
self
values
:
&
mut
E
)
{
values
.
extend
(
self
.
0
.
iter
(
)
.
cloned
(
)
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
super
:
:
super
:
:
{
test_decode
test_encode
}
;
#
[
test
]
fn
decode
(
)
{
let
set_cookie
=
test_decode
:
:
<
SetCookie
>
(
&
[
"
foo
=
bar
"
"
baz
=
quux
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
set_cookie
.
0
.
len
(
)
2
)
;
assert_eq
!
(
set_cookie
.
0
[
0
]
"
foo
=
bar
"
)
;
assert_eq
!
(
set_cookie
.
0
[
1
]
"
baz
=
quux
"
)
;
}
#
[
test
]
fn
encode
(
)
{
let
set_cookie
=
SetCookie
(
vec
!
[
:
:
HeaderValue
:
:
from_static
(
"
foo
=
bar
"
)
:
:
HeaderValue
:
:
from_static
(
"
baz
=
quux
"
)
]
)
;
let
headers
=
test_encode
(
set_cookie
)
;
let
mut
vals
=
headers
.
get_all
(
"
set
-
cookie
"
)
.
into_iter
(
)
;
assert_eq
!
(
vals
.
next
(
)
.
unwrap
(
)
"
foo
=
bar
"
)
;
assert_eq
!
(
vals
.
next
(
)
.
unwrap
(
)
"
baz
=
quux
"
)
;
assert_eq
!
(
vals
.
next
(
)
None
)
;
}
}
