use
super
:
:
ETag
;
use
util
:
:
EntityTagRange
;
use
HeaderValue
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
IfMatch
(
EntityTagRange
)
;
derive_header
!
{
IfMatch
(
_
)
name
:
IF_MATCH
}
impl
IfMatch
{
pub
fn
any
(
)
-
>
IfMatch
{
IfMatch
(
EntityTagRange
:
:
Any
)
}
pub
fn
is_any
(
&
self
)
-
>
bool
{
match
self
.
0
{
EntityTagRange
:
:
Any
=
>
true
EntityTagRange
:
:
Tags
(
.
.
)
=
>
false
}
}
pub
fn
precondition_passes
(
&
self
etag
:
&
ETag
)
-
>
bool
{
self
.
0
.
matches_strong
(
&
etag
.
0
)
}
}
impl
From
<
ETag
>
for
IfMatch
{
fn
from
(
etag
:
ETag
)
-
>
IfMatch
{
IfMatch
(
EntityTagRange
:
:
Tags
(
HeaderValue
:
:
from
(
etag
.
0
)
.
into
(
)
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
is_any
(
)
{
assert
!
(
IfMatch
:
:
any
(
)
.
is_any
(
)
)
;
assert
!
(
!
IfMatch
:
:
from
(
ETag
:
:
from_static
(
"
\
"
yolo
\
"
"
)
)
.
is_any
(
)
)
;
}
#
[
test
]
fn
precondition_fails
(
)
{
let
if_match
=
IfMatch
:
:
from
(
ETag
:
:
from_static
(
"
\
"
foo
\
"
"
)
)
;
let
bar
=
ETag
:
:
from_static
(
"
\
"
bar
\
"
"
)
;
let
weak_foo
=
ETag
:
:
from_static
(
"
W
/
\
"
foo
\
"
"
)
;
assert
!
(
!
if_match
.
precondition_passes
(
&
bar
)
)
;
assert
!
(
!
if_match
.
precondition_passes
(
&
weak_foo
)
)
;
}
#
[
test
]
fn
precondition_passes
(
)
{
let
foo
=
ETag
:
:
from_static
(
"
\
"
foo
\
"
"
)
;
let
if_match
=
IfMatch
:
:
from
(
foo
.
clone
(
)
)
;
assert
!
(
if_match
.
precondition_passes
(
&
foo
)
)
;
}
#
[
test
]
fn
precondition_any
(
)
{
let
foo
=
ETag
:
:
from_static
(
"
\
"
foo
\
"
"
)
;
let
if_match
=
IfMatch
:
:
any
(
)
;
assert
!
(
if_match
.
precondition_passes
(
&
foo
)
)
;
}
}
