use
util
:
:
{
FlatCsv
SemiColon
}
;
#
[
derive
(
Clone
Debug
Header
)
]
pub
struct
Cookie
(
FlatCsv
<
SemiColon
>
)
;
impl
Cookie
{
pub
fn
get
(
&
self
name
:
&
str
)
-
>
Option
<
&
str
>
{
self
.
iter
(
)
.
find
(
|
&
(
key
_
)
|
key
=
=
name
)
.
map
(
|
(
_
val
)
|
val
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
iter
(
)
.
count
(
)
}
pub
fn
iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
(
&
str
&
str
)
>
{
self
.
0
.
iter
(
)
.
filter_map
(
|
kv
|
{
let
mut
iter
=
kv
.
splitn
(
2
'
=
'
)
;
let
key
=
iter
.
next
(
)
?
.
trim
(
)
;
let
val
=
iter
.
next
(
)
?
.
trim
(
)
;
Some
(
(
key
val
)
)
}
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
Cookie
;
use
super
:
:
super
:
:
test_decode
;
#
[
test
]
fn
test_parse
(
)
{
let
cookie
=
test_decode
:
:
<
Cookie
>
(
&
[
"
foo
=
bar
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
cookie
.
get
(
"
foo
"
)
Some
(
"
bar
"
)
)
;
assert_eq
!
(
cookie
.
get
(
"
bar
"
)
None
)
;
}
#
[
test
]
fn
test_multipe_same_name
(
)
{
let
cookie
=
test_decode
:
:
<
Cookie
>
(
&
[
"
foo
=
bar
;
foo
=
baz
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
cookie
.
get
(
"
foo
"
)
Some
(
"
bar
"
)
)
;
}
#
[
test
]
fn
test_multipe_lines
(
)
{
let
cookie
=
test_decode
:
:
<
Cookie
>
(
&
[
"
foo
=
bar
"
"
lol
=
cat
"
]
)
.
unwrap
(
)
;
assert_eq
!
(
cookie
.
get
(
"
foo
"
)
Some
(
"
bar
"
)
)
;
assert_eq
!
(
cookie
.
get
(
"
lol
"
)
Some
(
"
cat
"
)
)
;
}
}
