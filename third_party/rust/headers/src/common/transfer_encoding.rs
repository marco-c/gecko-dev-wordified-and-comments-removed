use
util
:
:
FlatCsv
;
use
HeaderValue
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
TransferEncoding
(
FlatCsv
)
;
derive_header
!
{
TransferEncoding
(
_
)
name
:
TRANSFER_ENCODING
}
impl
TransferEncoding
{
pub
fn
chunked
(
)
-
>
TransferEncoding
{
TransferEncoding
(
HeaderValue
:
:
from_static
(
"
chunked
"
)
.
into
(
)
)
}
pub
fn
is_chunked
(
&
self
)
-
>
bool
{
self
.
0
.
value
.
to_str
(
)
.
map
(
|
s
|
{
s
.
split
(
'
'
)
.
next_back
(
)
.
map
(
|
encoding
|
encoding
.
trim
(
)
=
=
"
chunked
"
)
.
expect
(
"
split
always
has
at
least
1
item
"
)
}
)
.
unwrap_or
(
false
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
super
:
:
test_decode
;
use
super
:
:
TransferEncoding
;
#
[
test
]
fn
chunked_is_chunked
(
)
{
assert
!
(
TransferEncoding
:
:
chunked
(
)
.
is_chunked
(
)
)
;
}
#
[
test
]
fn
decode_gzip_chunked_is_chunked
(
)
{
let
te
=
test_decode
:
:
<
TransferEncoding
>
(
&
[
"
gzip
chunked
"
]
)
.
unwrap
(
)
;
assert
!
(
te
.
is_chunked
(
)
)
;
}
#
[
test
]
fn
decode_chunked_gzip_is_not_chunked
(
)
{
let
te
=
test_decode
:
:
<
TransferEncoding
>
(
&
[
"
chunked
gzip
"
]
)
.
unwrap
(
)
;
assert
!
(
!
te
.
is_chunked
(
)
)
;
}
#
[
test
]
fn
decode_notchunked_is_not_chunked
(
)
{
let
te
=
test_decode
:
:
<
TransferEncoding
>
(
&
[
"
notchunked
"
]
)
.
unwrap
(
)
;
assert
!
(
!
te
.
is_chunked
(
)
)
;
}
#
[
test
]
fn
decode_multiple_is_chunked
(
)
{
let
te
=
test_decode
:
:
<
TransferEncoding
>
(
&
[
"
gzip
"
"
chunked
"
]
)
.
unwrap
(
)
;
assert
!
(
te
.
is_chunked
(
)
)
;
}
}
