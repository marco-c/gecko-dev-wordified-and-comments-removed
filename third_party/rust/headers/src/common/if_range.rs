use
std
:
:
time
:
:
SystemTime
;
use
super
:
:
{
ETag
LastModified
}
;
use
util
:
:
{
EntityTag
HttpDate
}
;
use
HeaderValue
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
IfRange
(
IfRange_
)
;
derive_header
!
{
IfRange
(
_
)
name
:
IF_RANGE
}
impl
IfRange
{
pub
fn
etag
(
tag
:
ETag
)
-
>
IfRange
{
IfRange
(
IfRange_
:
:
EntityTag
(
tag
.
0
)
)
}
pub
fn
date
(
time
:
SystemTime
)
-
>
IfRange
{
IfRange
(
IfRange_
:
:
Date
(
time
.
into
(
)
)
)
}
pub
fn
is_modified
(
&
self
etag
:
Option
<
&
ETag
>
last_modified
:
Option
<
&
LastModified
>
)
-
>
bool
{
match
self
.
0
{
IfRange_
:
:
Date
(
since
)
=
>
last_modified
.
map
(
|
time
|
since
<
time
.
0
)
.
unwrap_or
(
true
)
IfRange_
:
:
EntityTag
(
ref
entity
)
=
>
{
etag
.
map
(
|
etag
|
!
etag
.
0
.
strong_eq
(
entity
)
)
.
unwrap_or
(
true
)
}
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
enum
IfRange_
{
EntityTag
(
EntityTag
)
Date
(
HttpDate
)
}
impl
:
:
util
:
:
TryFromValues
for
IfRange_
{
fn
try_from_values
<
'
i
I
>
(
values
:
&
mut
I
)
-
>
Result
<
Self
:
:
Error
>
where
I
:
Iterator
<
Item
=
&
'
i
HeaderValue
>
{
values
.
next
(
)
.
and_then
(
|
val
|
{
if
let
Some
(
tag
)
=
EntityTag
:
:
from_val
(
val
)
{
return
Some
(
IfRange_
:
:
EntityTag
(
tag
)
)
;
}
let
date
=
HttpDate
:
:
from_val
(
val
)
?
;
Some
(
IfRange_
:
:
Date
(
date
)
)
}
)
.
ok_or_else
(
:
:
Error
:
:
invalid
)
}
}
impl
<
'
a
>
From
<
&
'
a
IfRange_
>
for
HeaderValue
{
fn
from
(
if_range
:
&
'
a
IfRange_
)
-
>
HeaderValue
{
match
*
if_range
{
IfRange_
:
:
EntityTag
(
ref
tag
)
=
>
tag
.
into
(
)
IfRange_
:
:
Date
(
ref
date
)
=
>
date
.
into
(
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_is_modified_etag
(
)
{
let
etag
=
ETag
:
:
from_static
(
"
\
"
xyzzy
\
"
"
)
;
let
if_range
=
IfRange
:
:
etag
(
etag
.
clone
(
)
)
;
assert
!
(
!
if_range
.
is_modified
(
Some
(
&
etag
)
None
)
)
;
let
etag
=
ETag
:
:
from_static
(
"
W
/
\
"
xyzzy
\
"
"
)
;
assert
!
(
if_range
.
is_modified
(
Some
(
&
etag
)
None
)
)
;
}
}
