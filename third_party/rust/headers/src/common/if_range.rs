use
std
:
:
time
:
:
SystemTime
;
use
:
:
HeaderValue
;
use
util
:
:
{
EntityTag
HttpDate
}
;
use
super
:
:
{
LastModified
ETag
}
;
#
[
derive
(
Clone
Debug
PartialEq
Header
)
]
pub
struct
IfRange
(
IfRange_
)
;
impl
IfRange
{
pub
fn
etag
(
tag
:
ETag
)
-
>
IfRange
{
IfRange
(
IfRange_
:
:
EntityTag
(
tag
.
0
)
)
}
pub
fn
date
(
time
:
SystemTime
)
-
>
IfRange
{
IfRange
(
IfRange_
:
:
Date
(
time
.
into
(
)
)
)
}
pub
fn
is_modified
(
&
self
_etag
:
Option
<
&
ETag
>
last_modified
:
Option
<
&
LastModified
>
)
-
>
bool
{
match
self
.
0
{
IfRange_
:
:
Date
(
since
)
=
>
last_modified
.
map
(
|
time
|
since
<
time
.
0
)
.
unwrap_or
(
true
)
IfRange_
:
:
EntityTag
(
_
)
=
>
true
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
enum
IfRange_
{
EntityTag
(
EntityTag
)
Date
(
HttpDate
)
}
impl
:
:
util
:
:
TryFromValues
for
IfRange_
{
fn
try_from_values
<
'
i
I
>
(
values
:
&
mut
I
)
-
>
Result
<
Self
:
:
Error
>
where
I
:
Iterator
<
Item
=
&
'
i
HeaderValue
>
{
values
.
next
(
)
.
and_then
(
|
val
|
{
if
let
Some
(
tag
)
=
EntityTag
:
:
from_val
(
val
)
{
return
Some
(
IfRange_
:
:
EntityTag
(
tag
)
)
;
}
let
date
=
HttpDate
:
:
from_val
(
val
)
?
;
Some
(
IfRange_
:
:
Date
(
date
)
)
}
)
.
ok_or_else
(
:
:
Error
:
:
invalid
)
}
}
impl
<
'
a
>
From
<
&
'
a
IfRange_
>
for
HeaderValue
{
fn
from
(
if_range
:
&
'
a
IfRange_
)
-
>
HeaderValue
{
match
*
if_range
{
IfRange_
:
:
EntityTag
(
ref
tag
)
=
>
tag
.
into
(
)
IfRange_
:
:
Date
(
ref
date
)
=
>
date
.
into
(
)
}
}
}
