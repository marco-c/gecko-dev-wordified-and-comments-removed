#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
ExtendedValue
{
pub
charset
:
Charset
pub
language_tag
:
Option
<
LanguageTag
>
pub
value
:
Vec
<
u8
>
}
pub
fn
parse_extended_value
(
val
:
&
str
)
-
>
:
:
Result
<
ExtendedValue
>
{
let
mut
parts
=
val
.
splitn
(
3
'
\
'
'
)
;
let
charset
:
Charset
=
match
parts
.
next
(
)
{
None
=
>
return
Err
(
:
:
Error
:
:
Header
)
Some
(
n
)
=
>
try
!
(
FromStr
:
:
from_str
(
n
)
)
}
;
let
lang
:
Option
<
LanguageTag
>
=
match
parts
.
next
(
)
{
None
=
>
return
Err
(
:
:
Error
:
:
Header
)
Some
(
"
"
)
=
>
None
Some
(
s
)
=
>
match
s
.
parse
(
)
{
Ok
(
lt
)
=
>
Some
(
lt
)
Err
(
_
)
=
>
return
Err
(
:
:
Error
:
:
Header
)
}
}
;
let
value
:
Vec
<
u8
>
=
match
parts
.
next
(
)
{
None
=
>
return
Err
(
:
:
Error
:
:
Header
)
Some
(
v
)
=
>
percent_encoding
:
:
percent_decode
(
v
.
as_bytes
(
)
)
.
collect
(
)
}
;
Ok
(
ExtendedValue
{
charset
:
charset
language_tag
:
lang
value
:
value
}
)
}
impl
Display
for
ExtendedValue
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
encoded_value
=
percent_encoding
:
:
percent_encode
(
&
self
.
value
[
.
.
]
self
:
:
percent_encoding_http
:
:
HTTP_VALUE
)
;
if
let
Some
(
ref
lang
)
=
self
.
language_tag
{
write
!
(
f
"
{
}
'
{
}
'
{
}
"
self
.
charset
lang
encoded_value
)
}
else
{
write
!
(
f
"
{
}
'
'
{
}
"
self
.
charset
encoded_value
)
}
}
}
pub
fn
http_percent_encode
(
f
:
&
mut
fmt
:
:
Formatter
bytes
:
&
[
u8
]
)
-
>
fmt
:
:
Result
{
let
encoded
=
percent_encoding
:
:
percent_encode
(
bytes
self
:
:
percent_encoding_http
:
:
HTTP_VALUE
)
;
fmt
:
:
Display
:
:
fmt
(
&
encoded
f
)
}
mod
percent_encoding_http
{
use
percent_encoding
;
define_encode_set
!
{
/
/
This
encode
set
is
used
for
HTTP
header
values
and
is
defined
at
/
/
https
:
/
/
tools
.
ietf
.
org
/
html
/
rfc5987
#
section
-
3
.
2
pub
HTTP_VALUE
=
[
percent_encoding
:
:
SIMPLE_ENCODE_SET
]
|
{
'
'
'
"
'
'
%
'
'
\
'
'
'
(
'
'
)
'
'
*
'
'
'
'
/
'
'
:
'
'
;
'
'
<
'
'
-
'
'
>
'
'
?
'
'
[
'
'
\
\
'
'
]
'
'
{
'
'
}
'
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
shared
:
:
Charset
;
use
super
:
:
{
ExtendedValue
parse_extended_value
}
;
use
language_tags
:
:
LanguageTag
;
#
[
test
]
fn
test_parse_extended_value_with_encoding_and_language_tag
(
)
{
let
expected_language_tag
=
"
en
"
.
parse
:
:
<
LanguageTag
>
(
)
.
unwrap
(
)
;
let
result
=
parse_extended_value
(
"
iso
-
8859
-
1
'
en
'
%
A3
%
20rates
"
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
extended_value
=
result
.
unwrap
(
)
;
assert_eq
!
(
Charset
:
:
Iso_8859_1
extended_value
.
charset
)
;
assert
!
(
extended_value
.
language_tag
.
is_some
(
)
)
;
assert_eq
!
(
expected_language_tag
extended_value
.
language_tag
.
unwrap
(
)
)
;
assert_eq
!
(
vec
!
[
163
b
'
'
b
'
r
'
b
'
a
'
b
'
t
'
b
'
e
'
b
'
s
'
]
extended_value
.
value
)
;
}
#
[
test
]
fn
test_parse_extended_value_with_encoding
(
)
{
let
result
=
parse_extended_value
(
"
UTF
-
8
'
'
%
c2
%
a3
%
20and
%
20
%
e2
%
82
%
ac
%
20rates
"
)
;
assert
!
(
result
.
is_ok
(
)
)
;
let
extended_value
=
result
.
unwrap
(
)
;
assert_eq
!
(
Charset
:
:
Ext
(
"
UTF
-
8
"
.
to_string
(
)
)
extended_value
.
charset
)
;
assert
!
(
extended_value
.
language_tag
.
is_none
(
)
)
;
assert_eq
!
(
vec
!
[
194
163
b
'
'
b
'
a
'
b
'
n
'
b
'
d
'
b
'
'
226
130
172
b
'
'
b
'
r
'
b
'
a
'
b
'
t
'
b
'
e
'
b
'
s
'
]
extended_value
.
value
)
;
}
#
[
test
]
fn
test_parse_extended_value_missing_language_tag_and_encoding
(
)
{
let
result
=
parse_extended_value
(
"
foo
%
20bar
.
html
"
)
;
assert
!
(
result
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_parse_extended_value_partially_formatted
(
)
{
let
result
=
parse_extended_value
(
"
UTF
-
8
'
missing
third
part
"
)
;
assert
!
(
result
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_parse_extended_value_partially_formatted_blank
(
)
{
let
result
=
parse_extended_value
(
"
blank
second
part
'
"
)
;
assert
!
(
result
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_fmt_extended_value_with_encoding_and_language_tag
(
)
{
let
extended_value
=
ExtendedValue
{
charset
:
Charset
:
:
Iso_8859_1
language_tag
:
Some
(
"
en
"
.
parse
(
)
.
expect
(
"
Could
not
parse
language
tag
"
)
)
value
:
vec
!
[
163
b
'
'
b
'
r
'
b
'
a
'
b
'
t
'
b
'
e
'
b
'
s
'
]
}
;
assert_eq
!
(
"
ISO
-
8859
-
1
'
en
'
%
A3
%
20rates
"
format
!
(
"
{
}
"
extended_value
)
)
;
}
#
[
test
]
fn
test_fmt_extended_value_with_encoding
(
)
{
let
extended_value
=
ExtendedValue
{
charset
:
Charset
:
:
Ext
(
"
UTF
-
8
"
.
to_string
(
)
)
language_tag
:
None
value
:
vec
!
[
194
163
b
'
'
b
'
a
'
b
'
n
'
b
'
d
'
b
'
'
226
130
172
b
'
'
b
'
r
'
b
'
a
'
b
'
t
'
b
'
e
'
b
'
s
'
]
}
;
assert_eq
!
(
"
UTF
-
8
'
'
%
C2
%
A3
%
20and
%
20
%
E2
%
82
%
AC
%
20rates
"
format
!
(
"
{
}
"
extended_value
)
)
;
}
}
