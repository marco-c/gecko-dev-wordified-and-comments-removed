pub
use
name
:
:
{
HeaderName
InvalidHeaderName
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
str
:
:
FromStr
;
mod
name
;
#
[
derive
(
Clone
Debug
PartialEq
PartialOrd
Hash
Eq
Ord
)
]
pub
struct
Header
{
pub
name
:
HeaderName
pub
value
:
String
}
fn
trim_string
<
S
:
AsRef
<
str
>
+
Into
<
String
>
>
(
s
:
S
)
-
>
String
{
let
sr
=
s
.
as_ref
(
)
;
let
trimmed
=
sr
.
trim
(
)
;
if
sr
.
len
(
)
!
=
trimmed
.
len
(
)
{
trimmed
.
into
(
)
}
else
{
s
.
into
(
)
}
}
fn
is_valid_header_value
(
value
:
&
str
)
-
>
bool
{
value
.
bytes
(
)
.
all
(
|
b
|
(
32
.
.
127
)
.
contains
(
&
b
)
|
|
b
=
=
b
'
\
t
'
)
}
impl
Header
{
pub
fn
new
<
Name
Value
>
(
name
:
Name
value
:
Value
)
-
>
Result
<
Self
crate
:
:
ViaductError
>
where
Name
:
Into
<
HeaderName
>
Value
:
AsRef
<
str
>
+
Into
<
String
>
{
let
name
=
name
.
into
(
)
;
let
value
=
trim_string
(
value
)
;
if
!
is_valid_header_value
(
&
value
)
{
return
Err
(
crate
:
:
ViaductError
:
:
RequestHeaderError
(
name
.
to_string
(
)
)
)
;
}
Ok
(
Self
{
name
value
}
)
}
pub
fn
new_unchecked
<
Value
>
(
name
:
HeaderName
value
:
Value
)
-
>
Self
where
Value
:
AsRef
<
str
>
+
Into
<
String
>
{
Self
{
name
value
:
value
.
into
(
)
}
}
#
[
inline
]
pub
fn
name
(
&
self
)
-
>
&
HeaderName
{
&
self
.
name
}
#
[
inline
]
pub
fn
value
(
&
self
)
-
>
&
str
{
&
self
.
value
}
#
[
inline
]
fn
set_value
<
V
:
AsRef
<
str
>
>
(
&
mut
self
s
:
V
)
-
>
Result
<
(
)
crate
:
:
ViaductError
>
{
let
value
=
s
.
as_ref
(
)
;
if
!
is_valid_header_value
(
value
)
{
Err
(
crate
:
:
ViaductError
:
:
RequestHeaderError
(
self
.
name
.
to_string
(
)
)
)
}
else
{
self
.
value
.
clear
(
)
;
self
.
value
.
push_str
(
s
.
as_ref
(
)
.
trim
(
)
)
;
Ok
(
(
)
)
}
}
}
impl
std
:
:
fmt
:
:
Display
for
Header
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
:
{
}
"
self
.
name
self
.
value
)
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Default
)
]
pub
struct
Headers
{
headers
:
Vec
<
Header
>
}
impl
Headers
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
Default
:
:
default
(
)
}
pub
fn
with_capacity
(
c
:
usize
)
-
>
Self
{
Self
{
headers
:
Vec
:
:
with_capacity
(
c
)
}
}
#
[
inline
]
pub
fn
into_vec
(
self
)
-
>
Vec
<
Header
>
{
self
.
headers
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
headers
.
len
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
headers
.
is_empty
(
)
}
#
[
inline
]
pub
fn
clear
(
&
mut
self
)
{
self
.
headers
.
clear
(
)
;
}
pub
fn
insert
<
N
V
>
(
&
mut
self
name
:
N
value
:
V
)
-
>
Result
<
&
mut
Self
crate
:
:
ViaductError
>
where
N
:
Into
<
HeaderName
>
+
PartialEq
<
HeaderName
>
V
:
Into
<
String
>
+
AsRef
<
str
>
{
if
let
Some
(
entry
)
=
self
.
headers
.
iter_mut
(
)
.
find
(
|
h
|
name
=
=
h
.
name
)
{
entry
.
set_value
(
value
)
?
;
}
else
{
self
.
headers
.
push
(
Header
:
:
new
(
name
value
)
?
)
;
}
Ok
(
self
)
}
pub
fn
insert_if_missing
<
N
V
>
(
&
mut
self
name
:
N
value
:
V
)
-
>
Result
<
&
mut
Self
crate
:
:
ViaductError
>
where
N
:
Into
<
HeaderName
>
+
PartialEq
<
HeaderName
>
V
:
Into
<
String
>
+
AsRef
<
str
>
{
if
!
self
.
headers
.
iter_mut
(
)
.
any
(
|
h
|
name
=
=
h
.
name
)
{
self
.
headers
.
push
(
Header
:
:
new
(
name
value
)
?
)
;
}
Ok
(
self
)
}
pub
fn
insert_header
(
&
mut
self
new
:
Header
)
-
>
&
mut
Self
{
if
let
Some
(
entry
)
=
self
.
headers
.
iter_mut
(
)
.
find
(
|
h
|
h
.
name
=
=
new
.
name
)
{
entry
.
value
=
new
.
value
;
}
else
{
self
.
headers
.
push
(
new
)
;
}
self
}
pub
fn
extend
<
I
>
(
&
mut
self
iter
:
I
)
-
>
&
mut
Self
where
I
:
IntoIterator
<
Item
=
Header
>
{
let
it
=
iter
.
into_iter
(
)
;
self
.
headers
.
reserve
(
it
.
size_hint
(
)
.
0
)
;
for
h
in
it
{
self
.
insert_header
(
h
)
;
}
self
}
pub
fn
try_extend
<
I
E
>
(
&
mut
self
iter
:
I
)
-
>
Result
<
&
mut
Self
E
>
where
I
:
IntoIterator
<
Item
=
Result
<
Header
E
>
>
{
self
.
extend
(
iter
.
into_iter
(
)
.
collect
:
:
<
Result
<
Vec
<
_
>
E
>
>
(
)
?
)
;
Ok
(
self
)
}
pub
fn
get_header
<
S
>
(
&
self
name
:
S
)
-
>
Option
<
&
Header
>
where
S
:
PartialEq
<
HeaderName
>
{
self
.
headers
.
iter
(
)
.
find
(
|
h
|
name
=
=
h
.
name
)
}
pub
fn
get
<
S
>
(
&
self
name
:
S
)
-
>
Option
<
&
str
>
where
S
:
PartialEq
<
HeaderName
>
{
self
.
get_header
(
name
)
.
map
(
|
h
|
h
.
value
.
as_str
(
)
)
}
pub
fn
get_as
<
T
S
>
(
&
self
name
:
S
)
-
>
Option
<
Result
<
T
<
T
as
FromStr
>
:
:
Err
>
>
where
T
:
FromStr
S
:
PartialEq
<
HeaderName
>
{
self
.
get
(
name
)
.
map
(
str
:
:
parse
)
}
pub
fn
try_get
<
T
S
>
(
&
self
name
:
S
)
-
>
Option
<
T
>
where
T
:
FromStr
S
:
PartialEq
<
HeaderName
>
{
self
.
get
(
name
)
.
and_then
(
|
val
|
val
.
parse
:
:
<
T
>
(
)
.
ok
(
)
)
}
pub
fn
iter
(
&
self
)
-
>
<
&
Headers
as
IntoIterator
>
:
:
IntoIter
{
self
.
into_iter
(
)
}
}
impl
std
:
:
iter
:
:
IntoIterator
for
Headers
{
type
IntoIter
=
<
Vec
<
Header
>
as
IntoIterator
>
:
:
IntoIter
;
type
Item
=
Header
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
headers
.
into_iter
(
)
}
}
impl
<
'
a
>
std
:
:
iter
:
:
IntoIterator
for
&
'
a
Headers
{
type
IntoIter
=
<
&
'
a
[
Header
]
as
IntoIterator
>
:
:
IntoIter
;
type
Item
=
&
'
a
Header
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
headers
[
.
.
]
.
iter
(
)
}
}
impl
FromIterator
<
Header
>
for
Headers
{
fn
from_iter
<
T
>
(
iter
:
T
)
-
>
Self
where
T
:
IntoIterator
<
Item
=
Header
>
{
let
mut
v
=
iter
.
into_iter
(
)
.
collect
:
:
<
Vec
<
Header
>
>
(
)
;
v
.
sort_by
(
|
a
b
|
a
.
name
.
cmp
(
&
b
.
name
)
)
;
v
.
reverse
(
)
;
v
.
dedup_by
(
|
a
b
|
a
.
name
=
=
b
.
name
)
;
v
.
into
(
)
}
}
impl
From
<
Vec
<
Header
>
>
for
Headers
{
fn
from
(
headers
:
Vec
<
Header
>
)
-
>
Self
{
Self
{
headers
}
}
}
#
[
allow
(
clippy
:
:
implicit_hasher
)
]
impl
From
<
Headers
>
for
HashMap
<
String
String
>
{
fn
from
(
headers
:
Headers
)
-
>
HashMap
<
String
String
>
{
headers
.
into_iter
(
)
.
map
(
|
h
|
(
String
:
:
from
(
h
.
name
)
h
.
value
)
)
.
collect
(
)
}
}
pub
mod
consts
{
use
super
:
:
name
:
:
HeaderName
;
macro_rules
!
def_header_consts
{
(
(
(
NAME
:
ident
string
:
literal
)
)
*
(
)
?
)
=
>
{
(
pub
const
NAME
:
HeaderName
=
HeaderName
(
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
string
)
)
;
)
*
}
;
}
macro_rules
!
headers
{
(
(
(
NAME
:
ident
string
:
literal
)
)
*
(
)
?
)
=
>
{
def_header_consts
!
(
(
(
NAME
string
)
)
*
)
;
/
/
Unused
except
for
tests
.
const
_ALL
:
&
[
&
str
]
=
&
[
(
string
)
*
]
;
}
;
}
headers
!
(
(
ACCEPT_ENCODING
"
accept
-
encoding
"
)
(
ACCEPT
"
accept
"
)
(
AUTHORIZATION
"
authorization
"
)
(
CONTENT_TYPE
"
content
-
type
"
)
(
ETAG
"
etag
"
)
(
IF_NONE_MATCH
"
if
-
none
-
match
"
)
(
USER_AGENT
"
user
-
agent
"
)
/
/
non
-
standard
but
it
'
s
convenient
to
have
these
.
(
RETRY_AFTER
"
retry
-
after
"
)
(
X_IF_UNMODIFIED_SINCE
"
x
-
if
-
unmodified
-
since
"
)
(
X_KEYID
"
x
-
keyid
"
)
(
X_LAST_MODIFIED
"
x
-
last
-
modified
"
)
(
X_TIMESTAMP
"
x
-
timestamp
"
)
(
X_WEAVE_NEXT_OFFSET
"
x
-
weave
-
next
-
offset
"
)
(
X_WEAVE_RECORDS
"
x
-
weave
-
records
"
)
(
X_WEAVE_TIMESTAMP
"
x
-
weave
-
timestamp
"
)
(
X_WEAVE_BACKOFF
"
x
-
weave
-
backoff
"
)
)
;
#
[
test
]
fn
test_predefined
(
)
{
for
&
name
in
_ALL
{
assert
!
(
HeaderName
:
:
new
(
name
)
.
is_ok
(
)
"
Invalid
header
name
in
predefined
header
constants
:
{
}
"
name
)
;
assert_eq
!
(
name
.
to_ascii_lowercase
(
)
name
"
Non
-
lowercase
name
in
predefined
header
constants
:
{
}
"
name
)
;
}
}
}
