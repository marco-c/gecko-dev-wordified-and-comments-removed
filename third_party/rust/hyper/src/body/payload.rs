use
bytes
:
:
Buf
;
use
futures
:
:
{
Async
Poll
}
;
use
http
:
:
HeaderMap
;
use
super
:
:
internal
:
:
{
FullDataArg
FullDataRet
}
;
pub
trait
Payload
:
Send
+
'
static
{
type
Data
:
Buf
+
Send
;
type
Error
:
Into
<
Box
<
:
:
std
:
:
error
:
:
Error
+
Send
+
Sync
>
>
;
fn
poll_data
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Data
>
Self
:
:
Error
>
;
fn
poll_trailers
(
&
mut
self
)
-
>
Poll
<
Option
<
HeaderMap
>
Self
:
:
Error
>
{
Ok
(
Async
:
:
Ready
(
None
)
)
}
fn
is_end_stream
(
&
self
)
-
>
bool
{
false
}
fn
content_length
(
&
self
)
-
>
Option
<
u64
>
{
None
}
#
[
doc
(
hidden
)
]
fn
__hyper_full_data
(
&
mut
self
FullDataArg
)
-
>
FullDataRet
<
Self
:
:
Data
>
{
FullDataRet
(
None
)
}
}
impl
<
E
:
Payload
>
Payload
for
Box
<
E
>
{
type
Data
=
E
:
:
Data
;
type
Error
=
E
:
:
Error
;
fn
poll_data
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Data
>
Self
:
:
Error
>
{
(
*
*
self
)
.
poll_data
(
)
}
fn
poll_trailers
(
&
mut
self
)
-
>
Poll
<
Option
<
HeaderMap
>
Self
:
:
Error
>
{
(
*
*
self
)
.
poll_trailers
(
)
}
fn
is_end_stream
(
&
self
)
-
>
bool
{
(
*
*
self
)
.
is_end_stream
(
)
}
fn
content_length
(
&
self
)
-
>
Option
<
u64
>
{
(
*
*
self
)
.
content_length
(
)
}
#
[
doc
(
hidden
)
]
fn
__hyper_full_data
(
&
mut
self
arg
:
FullDataArg
)
-
>
FullDataRet
<
Self
:
:
Data
>
{
(
*
*
self
)
.
__hyper_full_data
(
arg
)
}
}
