use
bytes
:
:
{
Buf
BufMut
Bytes
}
;
use
super
:
:
HttpBody
;
pub
async
fn
to_bytes
<
T
>
(
body
:
T
)
-
>
Result
<
Bytes
T
:
:
Error
>
where
T
:
HttpBody
{
futures_util
:
:
pin_mut
!
(
body
)
;
let
mut
first
=
if
let
Some
(
buf
)
=
body
.
data
(
)
.
await
{
buf
?
}
else
{
return
Ok
(
Bytes
:
:
new
(
)
)
;
}
;
let
second
=
if
let
Some
(
buf
)
=
body
.
data
(
)
.
await
{
buf
?
}
else
{
return
Ok
(
first
.
copy_to_bytes
(
first
.
remaining
(
)
)
)
;
}
;
let
rest
=
(
body
.
size_hint
(
)
.
lower
(
)
as
usize
)
.
min
(
1024
*
16
)
;
let
cap
=
first
.
remaining
(
)
.
saturating_add
(
second
.
remaining
(
)
)
.
saturating_add
(
rest
)
;
let
mut
vec
=
Vec
:
:
with_capacity
(
cap
)
;
vec
.
put
(
first
)
;
vec
.
put
(
second
)
;
while
let
Some
(
buf
)
=
body
.
data
(
)
.
await
{
vec
.
put
(
buf
?
)
;
}
Ok
(
vec
.
into
(
)
)
}
