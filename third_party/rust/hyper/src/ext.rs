use
bytes
:
:
Bytes
;
use
http
:
:
header
:
:
HeaderName
;
#
[
cfg
(
feature
=
"
http1
"
)
]
use
http
:
:
header
:
:
{
IntoHeaderName
ValueIter
}
;
use
http
:
:
HeaderMap
;
#
[
cfg
(
feature
=
"
ffi
"
)
]
use
std
:
:
collections
:
:
HashMap
;
#
[
cfg
(
feature
=
"
http2
"
)
]
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
derive
(
Clone
Eq
PartialEq
)
]
pub
struct
Protocol
{
inner
:
h2
:
:
ext
:
:
Protocol
}
#
[
cfg
(
feature
=
"
http2
"
)
]
impl
Protocol
{
pub
const
fn
from_static
(
value
:
&
'
static
str
)
-
>
Self
{
Self
{
inner
:
h2
:
:
ext
:
:
Protocol
:
:
from_static
(
value
)
}
}
pub
fn
as_str
(
&
self
)
-
>
&
str
{
self
.
inner
.
as_str
(
)
}
pub
(
crate
)
fn
from_inner
(
inner
:
h2
:
:
ext
:
:
Protocol
)
-
>
Self
{
Self
{
inner
}
}
pub
(
crate
)
fn
into_inner
(
self
)
-
>
h2
:
:
ext
:
:
Protocol
{
self
.
inner
}
}
#
[
cfg
(
feature
=
"
http2
"
)
]
impl
<
'
a
>
From
<
&
'
a
str
>
for
Protocol
{
fn
from
(
value
:
&
'
a
str
)
-
>
Self
{
Self
{
inner
:
h2
:
:
ext
:
:
Protocol
:
:
from
(
value
)
}
}
}
#
[
cfg
(
feature
=
"
http2
"
)
]
impl
AsRef
<
[
u8
]
>
for
Protocol
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
self
.
inner
.
as_ref
(
)
}
}
#
[
cfg
(
feature
=
"
http2
"
)
]
impl
fmt
:
:
Debug
for
Protocol
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
inner
.
fmt
(
f
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
struct
HeaderCaseMap
(
HeaderMap
<
Bytes
>
)
;
#
[
cfg
(
feature
=
"
http1
"
)
]
impl
HeaderCaseMap
{
pub
(
crate
)
fn
get_all
<
'
a
>
(
&
'
a
self
name
:
&
HeaderName
)
-
>
impl
Iterator
<
Item
=
impl
AsRef
<
[
u8
]
>
+
'
a
>
+
'
a
{
self
.
get_all_internal
(
name
)
.
into_iter
(
)
}
pub
(
crate
)
fn
get_all_internal
<
'
a
>
(
&
'
a
self
name
:
&
HeaderName
)
-
>
ValueIter
<
'
_
Bytes
>
{
self
.
0
.
get_all
(
name
)
.
into_iter
(
)
}
pub
(
crate
)
fn
default
(
)
-
>
Self
{
Self
(
Default
:
:
default
(
)
)
}
#
[
cfg
(
any
(
test
feature
=
"
ffi
"
)
)
]
pub
(
crate
)
fn
insert
(
&
mut
self
name
:
HeaderName
orig
:
Bytes
)
{
self
.
0
.
insert
(
name
orig
)
;
}
pub
(
crate
)
fn
append
<
N
>
(
&
mut
self
name
:
N
orig
:
Bytes
)
where
N
:
IntoHeaderName
{
self
.
0
.
append
(
name
orig
)
;
}
}
#
[
cfg
(
feature
=
"
ffi
"
)
]
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
struct
OriginalHeaderOrder
{
num_entries
:
HashMap
<
HeaderName
usize
>
entry_order
:
Vec
<
(
HeaderName
usize
)
>
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
ffi
"
)
)
]
impl
OriginalHeaderOrder
{
pub
(
crate
)
fn
default
(
)
-
>
Self
{
OriginalHeaderOrder
{
num_entries
:
HashMap
:
:
new
(
)
entry_order
:
Vec
:
:
new
(
)
}
}
pub
(
crate
)
fn
insert
(
&
mut
self
name
:
HeaderName
)
{
if
!
self
.
num_entries
.
contains_key
(
&
name
)
{
let
idx
=
0
;
self
.
num_entries
.
insert
(
name
.
clone
(
)
1
)
;
self
.
entry_order
.
push
(
(
name
idx
)
)
;
}
}
pub
(
crate
)
fn
append
<
N
>
(
&
mut
self
name
:
N
)
where
N
:
IntoHeaderName
+
Into
<
HeaderName
>
+
Clone
{
let
name
:
HeaderName
=
name
.
into
(
)
;
let
idx
;
if
self
.
num_entries
.
contains_key
(
&
name
)
{
idx
=
self
.
num_entries
[
&
name
]
;
*
self
.
num_entries
.
get_mut
(
&
name
)
.
unwrap
(
)
+
=
1
;
}
else
{
idx
=
0
;
self
.
num_entries
.
insert
(
name
.
clone
(
)
1
)
;
}
self
.
entry_order
.
push
(
(
name
idx
)
)
;
}
pub
(
crate
)
fn
get_in_order
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
(
HeaderName
usize
)
>
{
self
.
entry_order
.
iter
(
)
}
}
