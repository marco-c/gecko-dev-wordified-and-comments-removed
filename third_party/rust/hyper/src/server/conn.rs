#
[
cfg
(
all
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
not
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
use
std
:
:
marker
:
:
PhantomData
;
#
[
cfg
(
all
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
feature
=
"
runtime
"
)
)
]
use
std
:
:
time
:
:
Duration
;
#
[
cfg
(
feature
=
"
http2
"
)
]
use
crate
:
:
common
:
:
io
:
:
Rewind
;
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
use
crate
:
:
error
:
:
{
Kind
Parse
}
;
#
[
cfg
(
feature
=
"
http1
"
)
]
use
crate
:
:
upgrade
:
:
Upgraded
;
cfg_feature
!
{
#
!
[
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
]
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
bytes
:
:
Bytes
;
use
pin_project_lite
:
:
pin_project
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
tracing
:
:
trace
;
pub
use
super
:
:
server
:
:
Connecting
;
use
crate
:
:
body
:
:
{
Body
HttpBody
}
;
use
crate
:
:
common
:
:
{
task
Future
Pin
Poll
Unpin
}
;
#
[
cfg
(
not
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
]
use
crate
:
:
common
:
:
Never
;
use
crate
:
:
common
:
:
exec
:
:
{
ConnStreamExec
Exec
}
;
use
crate
:
:
proto
;
use
crate
:
:
service
:
:
HttpService
;
pub
(
super
)
use
self
:
:
upgrades
:
:
UpgradeableConnection
;
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
pub
use
super
:
:
tcp
:
:
{
AddrIncoming
AddrStream
}
;
#
[
derive
(
Clone
Debug
)
]
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
pub
struct
Http
<
E
=
Exec
>
{
pub
(
crate
)
exec
:
E
h1_half_close
:
bool
h1_keep_alive
:
bool
h1_title_case_headers
:
bool
h1_preserve_header_case
:
bool
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
h1_header_read_timeout
:
Option
<
Duration
>
h1_writev
:
Option
<
bool
>
#
[
cfg
(
feature
=
"
http2
"
)
]
h2_builder
:
proto
:
:
h2
:
:
server
:
:
Config
mode
:
ConnectionMode
max_buf_size
:
Option
<
usize
>
pipeline_flush
:
bool
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
enum
ConnectionMode
{
#
[
cfg
(
feature
=
"
http1
"
)
]
H1Only
#
[
cfg
(
feature
=
"
http2
"
)
]
H2Only
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
Fallback
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
pin_project
!
{
/
/
/
A
future
binding
a
connection
with
a
Service
.
/
/
/
/
/
/
Polling
this
future
will
drive
HTTP
forward
.
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
pub
struct
Connection
<
T
S
E
=
Exec
>
where
S
:
HttpService
<
Body
>
{
pub
(
super
)
conn
:
Option
<
ProtoServer
<
T
S
:
:
ResBody
S
E
>
>
fallback
:
Fallback
<
E
>
}
}
#
[
cfg
(
feature
=
"
http1
"
)
]
type
Http1Dispatcher
<
T
B
S
>
=
proto
:
:
h1
:
:
Dispatcher
<
proto
:
:
h1
:
:
dispatch
:
:
Server
<
S
Body
>
B
T
proto
:
:
ServerTransaction
>
;
#
[
cfg
(
all
(
not
(
feature
=
"
http1
"
)
feature
=
"
http2
"
)
)
]
type
Http1Dispatcher
<
T
B
S
>
=
(
Never
PhantomData
<
(
T
Box
<
Pin
<
B
>
>
Box
<
Pin
<
S
>
>
)
>
)
;
#
[
cfg
(
feature
=
"
http2
"
)
]
type
Http2Server
<
T
B
S
E
>
=
proto
:
:
h2
:
:
Server
<
Rewind
<
T
>
S
B
E
>
;
#
[
cfg
(
all
(
not
(
feature
=
"
http2
"
)
feature
=
"
http1
"
)
)
]
type
Http2Server
<
T
B
S
E
>
=
(
Never
PhantomData
<
(
T
Box
<
Pin
<
S
>
>
Box
<
Pin
<
B
>
>
Box
<
Pin
<
E
>
>
)
>
)
;
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
pin_project
!
{
#
[
project
=
ProtoServerProj
]
pub
(
super
)
enum
ProtoServer
<
T
B
S
E
=
Exec
>
where
S
:
HttpService
<
Body
>
B
:
HttpBody
{
H1
{
#
[
pin
]
h1
:
Http1Dispatcher
<
T
B
S
>
}
H2
{
#
[
pin
]
h2
:
Http2Server
<
T
B
S
E
>
}
}
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
derive
(
Clone
Debug
)
]
enum
Fallback
<
E
>
{
ToHttp2
(
proto
:
:
h2
:
:
server
:
:
Config
E
)
Http1Only
}
#
[
cfg
(
all
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
not
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
type
Fallback
<
E
>
=
PhantomData
<
E
>
;
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
E
>
Fallback
<
E
>
{
fn
to_h2
(
&
self
)
-
>
bool
{
match
*
self
{
Fallback
:
:
ToHttp2
(
.
.
)
=
>
true
Fallback
:
:
Http1Only
=
>
false
}
}
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
E
>
Unpin
for
Fallback
<
E
>
{
}
#
[
derive
(
Debug
)
]
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
pub
struct
Parts
<
T
S
>
{
pub
io
:
T
pub
read_buf
:
Bytes
pub
service
:
S
_inner
:
(
)
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
Http
{
pub
fn
new
(
)
-
>
Http
{
Http
{
exec
:
Exec
:
:
Default
h1_half_close
:
false
h1_keep_alive
:
true
h1_title_case_headers
:
false
h1_preserve_header_case
:
false
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
h1_header_read_timeout
:
None
h1_writev
:
None
#
[
cfg
(
feature
=
"
http2
"
)
]
h2_builder
:
Default
:
:
default
(
)
mode
:
ConnectionMode
:
:
default
(
)
max_buf_size
:
None
pipeline_flush
:
false
}
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
E
>
Http
<
E
>
{
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_only
(
&
mut
self
val
:
bool
)
-
>
&
mut
Self
{
if
val
{
self
.
mode
=
ConnectionMode
:
:
H1Only
;
}
else
{
#
[
cfg
(
feature
=
"
http2
"
)
]
{
self
.
mode
=
ConnectionMode
:
:
Fallback
;
}
}
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_half_close
(
&
mut
self
val
:
bool
)
-
>
&
mut
Self
{
self
.
h1_half_close
=
val
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_keep_alive
(
&
mut
self
val
:
bool
)
-
>
&
mut
Self
{
self
.
h1_keep_alive
=
val
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_title_case_headers
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
self
.
h1_title_case_headers
=
enabled
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_preserve_header_case
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
self
.
h1_preserve_header_case
=
enabled
;
self
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
)
)
]
pub
fn
http1_header_read_timeout
(
&
mut
self
read_timeout
:
Duration
)
-
>
&
mut
Self
{
self
.
h1_header_read_timeout
=
Some
(
read_timeout
)
;
self
}
#
[
inline
]
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_writev
(
&
mut
self
val
:
bool
)
-
>
&
mut
Self
{
self
.
h1_writev
=
Some
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_only
(
&
mut
self
val
:
bool
)
-
>
&
mut
Self
{
if
val
{
self
.
mode
=
ConnectionMode
:
:
H2Only
;
}
else
{
#
[
cfg
(
feature
=
"
http1
"
)
]
{
self
.
mode
=
ConnectionMode
:
:
Fallback
;
}
}
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_initial_stream_window_size
(
&
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
if
let
Some
(
sz
)
=
sz
.
into
(
)
{
self
.
h2_builder
.
adaptive_window
=
false
;
self
.
h2_builder
.
initial_stream_window_size
=
sz
;
}
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_initial_connection_window_size
(
&
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
if
let
Some
(
sz
)
=
sz
.
into
(
)
{
self
.
h2_builder
.
adaptive_window
=
false
;
self
.
h2_builder
.
initial_conn_window_size
=
sz
;
}
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_adaptive_window
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
use
proto
:
:
h2
:
:
SPEC_WINDOW_SIZE
;
self
.
h2_builder
.
adaptive_window
=
enabled
;
if
enabled
{
self
.
h2_builder
.
initial_conn_window_size
=
SPEC_WINDOW_SIZE
;
self
.
h2_builder
.
initial_stream_window_size
=
SPEC_WINDOW_SIZE
;
}
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_frame_size
(
&
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
if
let
Some
(
sz
)
=
sz
.
into
(
)
{
self
.
h2_builder
.
max_frame_size
=
sz
;
}
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_concurrent_streams
(
&
mut
self
max
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
self
.
h2_builder
.
max_concurrent_streams
=
max
.
into
(
)
;
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_keep_alive_interval
(
&
mut
self
interval
:
impl
Into
<
Option
<
Duration
>
>
)
-
>
&
mut
Self
{
self
.
h2_builder
.
keep_alive_interval
=
interval
.
into
(
)
;
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_keep_alive_timeout
(
&
mut
self
timeout
:
Duration
)
-
>
&
mut
Self
{
self
.
h2_builder
.
keep_alive_timeout
=
timeout
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_send_buf_size
(
&
mut
self
max
:
usize
)
-
>
&
mut
Self
{
assert
!
(
max
<
=
std
:
:
u32
:
:
MAX
as
usize
)
;
self
.
h2_builder
.
max_send_buffer_size
=
max
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
pub
fn
http2_enable_connect_protocol
(
&
mut
self
)
-
>
&
mut
Self
{
self
.
h2_builder
.
enable_connect_protocol
=
true
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_header_list_size
(
&
mut
self
max
:
u32
)
-
>
&
mut
Self
{
self
.
h2_builder
.
max_header_list_size
=
max
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
max_buf_size
(
&
mut
self
max
:
usize
)
-
>
&
mut
Self
{
assert
!
(
max
>
=
proto
:
:
h1
:
:
MINIMUM_MAX_BUFFER_SIZE
"
the
max_buf_size
cannot
be
smaller
than
the
minimum
that
h1
specifies
.
"
)
;
self
.
max_buf_size
=
Some
(
max
)
;
self
}
pub
fn
pipeline_flush
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
self
.
pipeline_flush
=
enabled
;
self
}
pub
fn
with_executor
<
E2
>
(
self
exec
:
E2
)
-
>
Http
<
E2
>
{
Http
{
exec
h1_half_close
:
self
.
h1_half_close
h1_keep_alive
:
self
.
h1_keep_alive
h1_title_case_headers
:
self
.
h1_title_case_headers
h1_preserve_header_case
:
self
.
h1_preserve_header_case
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
h1_header_read_timeout
:
self
.
h1_header_read_timeout
h1_writev
:
self
.
h1_writev
#
[
cfg
(
feature
=
"
http2
"
)
]
h2_builder
:
self
.
h2_builder
mode
:
self
.
mode
max_buf_size
:
self
.
max_buf_size
pipeline_flush
:
self
.
pipeline_flush
}
}
pub
fn
serve_connection
<
S
I
Bd
>
(
&
self
io
:
I
service
:
S
)
-
>
Connection
<
I
S
E
>
where
S
:
HttpService
<
Body
ResBody
=
Bd
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
Bd
:
HttpBody
+
'
static
Bd
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
AsyncRead
+
AsyncWrite
+
Unpin
E
:
ConnStreamExec
<
S
:
:
Future
Bd
>
{
#
[
cfg
(
feature
=
"
http1
"
)
]
macro_rules
!
h1
{
(
)
=
>
{
{
let
mut
conn
=
proto
:
:
Conn
:
:
new
(
io
)
;
if
!
self
.
h1_keep_alive
{
conn
.
disable_keep_alive
(
)
;
}
if
self
.
h1_half_close
{
conn
.
set_allow_half_close
(
)
;
}
if
self
.
h1_title_case_headers
{
conn
.
set_title_case_headers
(
)
;
}
if
self
.
h1_preserve_header_case
{
conn
.
set_preserve_header_case
(
)
;
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
if
let
Some
(
header_read_timeout
)
=
self
.
h1_header_read_timeout
{
conn
.
set_http1_header_read_timeout
(
header_read_timeout
)
;
}
if
let
Some
(
writev
)
=
self
.
h1_writev
{
if
writev
{
conn
.
set_write_strategy_queue
(
)
;
}
else
{
conn
.
set_write_strategy_flatten
(
)
;
}
}
conn
.
set_flush_pipeline
(
self
.
pipeline_flush
)
;
if
let
Some
(
max
)
=
self
.
max_buf_size
{
conn
.
set_max_buf_size
(
max
)
;
}
let
sd
=
proto
:
:
h1
:
:
dispatch
:
:
Server
:
:
new
(
service
)
;
ProtoServer
:
:
H1
{
h1
:
proto
:
:
h1
:
:
Dispatcher
:
:
new
(
sd
conn
)
}
}
}
;
}
let
proto
=
match
self
.
mode
{
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg
(
not
(
feature
=
"
http2
"
)
)
]
ConnectionMode
:
:
H1Only
=
>
h1
!
(
)
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg
(
feature
=
"
http1
"
)
]
ConnectionMode
:
:
H1Only
|
ConnectionMode
:
:
Fallback
=
>
h1
!
(
)
#
[
cfg
(
feature
=
"
http2
"
)
]
ConnectionMode
:
:
H2Only
=
>
{
let
rewind_io
=
Rewind
:
:
new
(
io
)
;
let
h2
=
proto
:
:
h2
:
:
Server
:
:
new
(
rewind_io
service
&
self
.
h2_builder
self
.
exec
.
clone
(
)
)
;
ProtoServer
:
:
H2
{
h2
}
}
}
;
Connection
{
conn
:
Some
(
proto
)
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
fallback
:
if
self
.
mode
=
=
ConnectionMode
:
:
Fallback
{
Fallback
:
:
ToHttp2
(
self
.
h2_builder
.
clone
(
)
self
.
exec
.
clone
(
)
)
}
else
{
Fallback
:
:
Http1Only
}
#
[
cfg
(
not
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
]
fallback
:
PhantomData
}
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
I
B
S
E
>
Connection
<
I
S
E
>
where
S
:
HttpService
<
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
AsyncRead
+
AsyncWrite
+
Unpin
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
{
pub
fn
graceful_shutdown
(
mut
self
:
Pin
<
&
mut
Self
>
)
{
match
self
.
conn
{
#
[
cfg
(
feature
=
"
http1
"
)
]
Some
(
ProtoServer
:
:
H1
{
ref
mut
h1
.
.
}
)
=
>
{
h1
.
disable_keep_alive
(
)
;
}
#
[
cfg
(
feature
=
"
http2
"
)
]
Some
(
ProtoServer
:
:
H2
{
ref
mut
h2
}
)
=
>
{
h2
.
graceful_shutdown
(
)
;
}
None
=
>
(
)
#
[
cfg
(
not
(
feature
=
"
http1
"
)
)
]
Some
(
ProtoServer
:
:
H1
{
ref
mut
h1
.
.
}
)
=
>
match
h1
.
0
{
}
#
[
cfg
(
not
(
feature
=
"
http2
"
)
)
]
Some
(
ProtoServer
:
:
H2
{
ref
mut
h2
}
)
=
>
match
h2
.
0
{
}
}
}
pub
fn
into_parts
(
self
)
-
>
Parts
<
I
S
>
{
self
.
try_into_parts
(
)
.
unwrap_or_else
(
|
|
panic
!
(
"
h2
cannot
into_inner
"
)
)
}
pub
fn
try_into_parts
(
self
)
-
>
Option
<
Parts
<
I
S
>
>
{
match
self
.
conn
.
unwrap
(
)
{
#
[
cfg
(
feature
=
"
http1
"
)
]
ProtoServer
:
:
H1
{
h1
.
.
}
=
>
{
let
(
io
read_buf
dispatch
)
=
h1
.
into_inner
(
)
;
Some
(
Parts
{
io
read_buf
service
:
dispatch
.
into_service
(
)
_inner
:
(
)
}
)
}
ProtoServer
:
:
H2
{
.
.
}
=
>
None
#
[
cfg
(
not
(
feature
=
"
http1
"
)
)
]
ProtoServer
:
:
H1
{
h1
.
.
}
=
>
match
h1
.
0
{
}
}
}
pub
fn
poll_without_shutdown
(
&
mut
self
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
crate
:
:
Result
<
(
)
>
>
where
S
:
Unpin
S
:
:
Future
:
Unpin
B
:
Unpin
{
loop
{
match
*
self
.
conn
.
as_mut
(
)
.
unwrap
(
)
{
#
[
cfg
(
feature
=
"
http1
"
)
]
ProtoServer
:
:
H1
{
ref
mut
h1
.
.
}
=
>
match
ready
!
(
h1
.
poll_without_shutdown
(
cx
)
)
{
Ok
(
(
)
)
=
>
return
Poll
:
:
Ready
(
Ok
(
(
)
)
)
Err
(
e
)
=
>
{
#
[
cfg
(
feature
=
"
http2
"
)
]
match
*
e
.
kind
(
)
{
Kind
:
:
Parse
(
Parse
:
:
VersionH2
)
if
self
.
fallback
.
to_h2
(
)
=
>
{
self
.
upgrade_h2
(
)
;
continue
;
}
_
=
>
(
)
}
return
Poll
:
:
Ready
(
Err
(
e
)
)
;
}
}
#
[
cfg
(
feature
=
"
http2
"
)
]
ProtoServer
:
:
H2
{
ref
mut
h2
}
=
>
return
Pin
:
:
new
(
h2
)
.
poll
(
cx
)
.
map_ok
(
|
_
|
(
)
)
#
[
cfg
(
not
(
feature
=
"
http1
"
)
)
]
ProtoServer
:
:
H1
{
ref
mut
h1
.
.
}
=
>
match
h1
.
0
{
}
#
[
cfg
(
not
(
feature
=
"
http2
"
)
)
]
ProtoServer
:
:
H2
{
ref
mut
h2
}
=
>
match
h2
.
0
{
}
}
;
}
}
pub
fn
without_shutdown
(
self
)
-
>
impl
Future
<
Output
=
crate
:
:
Result
<
Parts
<
I
S
>
>
>
where
S
:
Unpin
S
:
:
Future
:
Unpin
B
:
Unpin
{
let
mut
conn
=
Some
(
self
)
;
futures_util
:
:
future
:
:
poll_fn
(
move
|
cx
|
{
ready
!
(
conn
.
as_mut
(
)
.
unwrap
(
)
.
poll_without_shutdown
(
cx
)
)
?
;
Poll
:
:
Ready
(
conn
.
take
(
)
.
unwrap
(
)
.
try_into_parts
(
)
.
ok_or_else
(
crate
:
:
Error
:
:
new_without_shutdown_not_h1
)
)
}
)
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
fn
upgrade_h2
(
&
mut
self
)
{
trace
!
(
"
Trying
to
upgrade
connection
to
h2
"
)
;
let
conn
=
self
.
conn
.
take
(
)
;
let
(
io
read_buf
dispatch
)
=
match
conn
.
unwrap
(
)
{
ProtoServer
:
:
H1
{
h1
.
.
}
=
>
h1
.
into_inner
(
)
ProtoServer
:
:
H2
{
.
.
}
=
>
{
panic
!
(
"
h2
cannot
into_inner
"
)
;
}
}
;
let
mut
rewind_io
=
Rewind
:
:
new
(
io
)
;
rewind_io
.
rewind
(
read_buf
)
;
let
(
builder
exec
)
=
match
self
.
fallback
{
Fallback
:
:
ToHttp2
(
ref
builder
ref
exec
)
=
>
(
builder
exec
)
Fallback
:
:
Http1Only
=
>
unreachable
!
(
"
upgrade_h2
with
Fallback
:
:
Http1Only
"
)
}
;
let
h2
=
proto
:
:
h2
:
:
Server
:
:
new
(
rewind_io
dispatch
.
into_service
(
)
builder
exec
.
clone
(
)
)
;
debug_assert
!
(
self
.
conn
.
is_none
(
)
)
;
self
.
conn
=
Some
(
ProtoServer
:
:
H2
{
h2
}
)
;
}
pub
fn
with_upgrades
(
self
)
-
>
UpgradeableConnection
<
I
S
E
>
where
I
:
Send
{
UpgradeableConnection
{
inner
:
self
}
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
I
B
S
E
>
Future
for
Connection
<
I
S
E
>
where
S
:
HttpService
<
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
AsyncRead
+
AsyncWrite
+
Unpin
+
'
static
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
{
type
Output
=
crate
:
:
Result
<
(
)
>
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
loop
{
match
ready
!
(
Pin
:
:
new
(
self
.
conn
.
as_mut
(
)
.
unwrap
(
)
)
.
poll
(
cx
)
)
{
Ok
(
done
)
=
>
{
match
done
{
proto
:
:
Dispatched
:
:
Shutdown
=
>
{
}
#
[
cfg
(
feature
=
"
http1
"
)
]
proto
:
:
Dispatched
:
:
Upgrade
(
pending
)
=
>
{
pending
.
manual
(
)
;
}
}
;
return
Poll
:
:
Ready
(
Ok
(
(
)
)
)
;
}
Err
(
e
)
=
>
{
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg
(
feature
=
"
http2
"
)
]
match
*
e
.
kind
(
)
{
Kind
:
:
Parse
(
Parse
:
:
VersionH2
)
if
self
.
fallback
.
to_h2
(
)
=
>
{
self
.
upgrade_h2
(
)
;
continue
;
}
_
=
>
(
)
}
return
Poll
:
:
Ready
(
Err
(
e
)
)
;
}
}
}
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
I
S
>
fmt
:
:
Debug
for
Connection
<
I
S
>
where
S
:
HttpService
<
Body
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Connection
"
)
.
finish
(
)
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
Default
for
ConnectionMode
{
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
fn
default
(
)
-
>
ConnectionMode
{
ConnectionMode
:
:
Fallback
}
#
[
cfg
(
all
(
feature
=
"
http1
"
not
(
feature
=
"
http2
"
)
)
)
]
fn
default
(
)
-
>
ConnectionMode
{
ConnectionMode
:
:
H1Only
}
#
[
cfg
(
all
(
not
(
feature
=
"
http1
"
)
feature
=
"
http2
"
)
)
]
fn
default
(
)
-
>
ConnectionMode
{
ConnectionMode
:
:
H2Only
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
T
B
S
E
>
Future
for
ProtoServer
<
T
B
S
E
>
where
T
:
AsyncRead
+
AsyncWrite
+
Unpin
S
:
HttpService
<
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
{
type
Output
=
crate
:
:
Result
<
proto
:
:
Dispatched
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
match
self
.
project
(
)
{
#
[
cfg
(
feature
=
"
http1
"
)
]
ProtoServerProj
:
:
H1
{
h1
.
.
}
=
>
h1
.
poll
(
cx
)
#
[
cfg
(
feature
=
"
http2
"
)
]
ProtoServerProj
:
:
H2
{
h2
}
=
>
h2
.
poll
(
cx
)
#
[
cfg
(
not
(
feature
=
"
http1
"
)
)
]
ProtoServerProj
:
:
H1
{
h1
.
.
}
=
>
match
h1
.
0
{
}
#
[
cfg
(
not
(
feature
=
"
http2
"
)
)
]
ProtoServerProj
:
:
H2
{
h2
}
=
>
match
h2
.
0
{
}
}
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
mod
upgrades
{
use
super
:
:
*
;
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
UpgradeableConnection
<
T
S
E
>
where
S
:
HttpService
<
Body
>
{
pub
(
super
)
inner
:
Connection
<
T
S
E
>
}
impl
<
I
B
S
E
>
UpgradeableConnection
<
I
S
E
>
where
S
:
HttpService
<
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
AsyncRead
+
AsyncWrite
+
Unpin
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
{
pub
fn
graceful_shutdown
(
mut
self
:
Pin
<
&
mut
Self
>
)
{
Pin
:
:
new
(
&
mut
self
.
inner
)
.
graceful_shutdown
(
)
}
}
impl
<
I
B
S
E
>
Future
for
UpgradeableConnection
<
I
S
E
>
where
S
:
HttpService
<
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
{
type
Output
=
crate
:
:
Result
<
(
)
>
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
loop
{
match
ready
!
(
Pin
:
:
new
(
self
.
inner
.
conn
.
as_mut
(
)
.
unwrap
(
)
)
.
poll
(
cx
)
)
{
Ok
(
proto
:
:
Dispatched
:
:
Shutdown
)
=
>
return
Poll
:
:
Ready
(
Ok
(
(
)
)
)
#
[
cfg
(
feature
=
"
http1
"
)
]
Ok
(
proto
:
:
Dispatched
:
:
Upgrade
(
pending
)
)
=
>
{
match
self
.
inner
.
conn
.
take
(
)
{
Some
(
ProtoServer
:
:
H1
{
h1
.
.
}
)
=
>
{
let
(
io
buf
_
)
=
h1
.
into_inner
(
)
;
pending
.
fulfill
(
Upgraded
:
:
new
(
io
buf
)
)
;
return
Poll
:
:
Ready
(
Ok
(
(
)
)
)
;
}
_
=
>
{
drop
(
pending
)
;
unreachable
!
(
"
Upgrade
expects
h1
"
)
}
}
;
}
Err
(
e
)
=
>
{
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg
(
feature
=
"
http2
"
)
]
match
*
e
.
kind
(
)
{
Kind
:
:
Parse
(
Parse
:
:
VersionH2
)
if
self
.
inner
.
fallback
.
to_h2
(
)
=
>
{
self
.
inner
.
upgrade_h2
(
)
;
continue
;
}
_
=
>
(
)
}
return
Poll
:
:
Ready
(
Err
(
e
)
)
;
}
}
}
}
}
}
