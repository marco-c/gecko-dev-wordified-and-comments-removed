pub
mod
accept
;
pub
mod
conn
;
mod
shutdown
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
mod
tcp
;
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
use
std
:
:
net
:
:
{
SocketAddr
TcpListener
as
StdTcpListener
}
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
use
std
:
:
time
:
:
Duration
;
use
pin_project
:
:
pin_project
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
self
:
:
accept
:
:
Accept
;
use
crate
:
:
body
:
:
{
Body
HttpBody
}
;
use
crate
:
:
common
:
:
exec
:
:
{
Exec
H2Exec
NewSvcExec
}
;
use
crate
:
:
common
:
:
{
task
Future
Pin
Poll
Unpin
}
;
use
crate
:
:
service
:
:
{
HttpService
MakeServiceRef
}
;
use
self
:
:
conn
:
:
{
Http
as
Http_
NoopWatcher
SpawnAll
}
;
use
self
:
:
shutdown
:
:
{
Graceful
GracefulWatcher
}
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
use
self
:
:
tcp
:
:
AddrIncoming
;
#
[
pin_project
]
pub
struct
Server
<
I
S
E
=
Exec
>
{
#
[
pin
]
spawn_all
:
SpawnAll
<
I
S
E
>
}
#
[
derive
(
Debug
)
]
pub
struct
Builder
<
I
E
=
Exec
>
{
incoming
:
I
protocol
:
Http_
<
E
>
}
impl
<
I
>
Server
<
I
(
)
>
{
pub
fn
builder
(
incoming
:
I
)
-
>
Builder
<
I
>
{
Builder
{
incoming
protocol
:
Http_
:
:
new
(
)
}
}
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
impl
Server
<
AddrIncoming
(
)
>
{
pub
fn
bind
(
addr
:
&
SocketAddr
)
-
>
Builder
<
AddrIncoming
>
{
let
incoming
=
AddrIncoming
:
:
new
(
addr
)
.
unwrap_or_else
(
|
e
|
{
panic
!
(
"
error
binding
to
{
}
:
{
}
"
addr
e
)
;
}
)
;
Server
:
:
builder
(
incoming
)
}
pub
fn
try_bind
(
addr
:
&
SocketAddr
)
-
>
crate
:
:
Result
<
Builder
<
AddrIncoming
>
>
{
AddrIncoming
:
:
new
(
addr
)
.
map
(
Server
:
:
builder
)
}
pub
fn
from_tcp
(
listener
:
StdTcpListener
)
-
>
Result
<
Builder
<
AddrIncoming
>
crate
:
:
Error
>
{
AddrIncoming
:
:
from_std
(
listener
)
.
map
(
Server
:
:
builder
)
}
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
impl
<
S
E
>
Server
<
AddrIncoming
S
E
>
{
pub
fn
local_addr
(
&
self
)
-
>
SocketAddr
{
self
.
spawn_all
.
local_addr
(
)
}
}
impl
<
I
IO
IE
S
E
B
>
Server
<
I
S
E
>
where
I
:
Accept
<
Conn
=
IO
Error
=
IE
>
IE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
IO
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
IO
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
Send
+
Sync
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
H2Exec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
GracefulWatcher
>
{
pub
fn
with_graceful_shutdown
<
F
>
(
self
signal
:
F
)
-
>
Graceful
<
I
S
F
E
>
where
F
:
Future
<
Output
=
(
)
>
{
Graceful
:
:
new
(
self
.
spawn_all
signal
)
}
}
impl
<
I
IO
IE
S
B
E
>
Future
for
Server
<
I
S
E
>
where
I
:
Accept
<
Conn
=
IO
Error
=
IE
>
IE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
IO
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
IO
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
H2Exec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
NoopWatcher
>
{
type
Output
=
crate
:
:
Result
<
(
)
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
self
.
project
(
)
.
spawn_all
.
poll_watch
(
cx
&
NoopWatcher
)
}
}
impl
<
I
:
fmt
:
:
Debug
S
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Server
<
I
S
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Server
"
)
.
field
(
"
listener
"
&
self
.
spawn_all
.
incoming_ref
(
)
)
.
finish
(
)
}
}
impl
<
I
E
>
Builder
<
I
E
>
{
pub
fn
new
(
incoming
:
I
protocol
:
Http_
<
E
>
)
-
>
Self
{
Builder
{
incoming
protocol
}
}
pub
fn
http1_keepalive
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_keep_alive
(
val
)
;
self
}
pub
fn
http1_half_close
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_half_close
(
val
)
;
self
}
pub
fn
http1_max_buf_size
(
mut
self
val
:
usize
)
-
>
Self
{
self
.
protocol
.
max_buf_size
(
val
)
;
self
}
#
[
doc
(
hidden
)
]
pub
fn
http1_pipeline_flush
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
pipeline_flush
(
val
)
;
self
}
pub
fn
http1_writev
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_writev
(
val
)
;
self
}
pub
fn
http1_only
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_only
(
val
)
;
self
}
pub
fn
http2_only
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http2_only
(
val
)
;
self
}
pub
fn
http2_initial_stream_window_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_initial_stream_window_size
(
sz
.
into
(
)
)
;
self
}
pub
fn
http2_initial_connection_window_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_initial_connection_window_size
(
sz
.
into
(
)
)
;
self
}
pub
fn
http2_adaptive_window
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
protocol
.
http2_adaptive_window
(
enabled
)
;
self
}
pub
fn
http2_max_concurrent_streams
(
mut
self
max
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_concurrent_streams
(
max
.
into
(
)
)
;
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
pub
fn
http2_keep_alive_interval
(
mut
self
interval
:
impl
Into
<
Option
<
Duration
>
>
)
-
>
Self
{
self
.
protocol
.
http2_keep_alive_interval
(
interval
)
;
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
pub
fn
http2_keep_alive_timeout
(
mut
self
timeout
:
Duration
)
-
>
Self
{
self
.
protocol
.
http2_keep_alive_timeout
(
timeout
)
;
self
}
pub
fn
executor
<
E2
>
(
self
executor
:
E2
)
-
>
Builder
<
I
E2
>
{
Builder
{
incoming
:
self
.
incoming
protocol
:
self
.
protocol
.
with_executor
(
executor
)
}
}
pub
fn
serve
<
S
B
>
(
self
new_service
:
S
)
-
>
Server
<
I
S
E
>
where
I
:
Accept
I
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
:
Conn
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
I
:
:
Conn
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
NewSvcExec
<
I
:
:
Conn
S
:
:
Future
S
:
:
Service
E
NoopWatcher
>
E
:
H2Exec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
{
let
serve
=
self
.
protocol
.
serve
(
self
.
incoming
new_service
)
;
let
spawn_all
=
serve
.
spawn_all
(
)
;
Server
{
spawn_all
}
}
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
impl
<
E
>
Builder
<
AddrIncoming
E
>
{
pub
fn
tcp_keepalive
(
mut
self
keepalive
:
Option
<
Duration
>
)
-
>
Self
{
self
.
incoming
.
set_keepalive
(
keepalive
)
;
self
}
pub
fn
tcp_nodelay
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
incoming
.
set_nodelay
(
enabled
)
;
self
}
pub
fn
tcp_sleep_on_accept_errors
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
incoming
.
set_sleep_on_errors
(
val
)
;
self
}
}
