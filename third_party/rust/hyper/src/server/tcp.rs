use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
net
:
:
{
SocketAddr
TcpListener
as
StdTcpListener
}
;
use
std
:
:
time
:
:
Duration
;
use
futures_util
:
:
FutureExt
as
_
;
use
tokio
:
:
net
:
:
TcpListener
;
use
tokio
:
:
time
:
:
Delay
;
use
crate
:
:
common
:
:
{
task
Future
Pin
Poll
}
;
pub
use
self
:
:
addr_stream
:
:
AddrStream
;
use
super
:
:
Accept
;
#
[
must_use
=
"
streams
do
nothing
unless
polled
"
]
pub
struct
AddrIncoming
{
addr
:
SocketAddr
listener
:
TcpListener
sleep_on_errors
:
bool
tcp_keepalive_timeout
:
Option
<
Duration
>
tcp_nodelay
:
bool
timeout
:
Option
<
Delay
>
}
impl
AddrIncoming
{
pub
(
super
)
fn
new
(
addr
:
&
SocketAddr
)
-
>
crate
:
:
Result
<
Self
>
{
let
std_listener
=
StdTcpListener
:
:
bind
(
addr
)
.
map_err
(
crate
:
:
Error
:
:
new_listen
)
?
;
AddrIncoming
:
:
from_std
(
std_listener
)
}
pub
(
super
)
fn
from_std
(
std_listener
:
StdTcpListener
)
-
>
crate
:
:
Result
<
Self
>
{
let
listener
=
TcpListener
:
:
from_std
(
std_listener
)
.
map_err
(
crate
:
:
Error
:
:
new_listen
)
?
;
let
addr
=
listener
.
local_addr
(
)
.
map_err
(
crate
:
:
Error
:
:
new_listen
)
?
;
Ok
(
AddrIncoming
{
listener
addr
sleep_on_errors
:
true
tcp_keepalive_timeout
:
None
tcp_nodelay
:
false
timeout
:
None
}
)
}
pub
fn
bind
(
addr
:
&
SocketAddr
)
-
>
crate
:
:
Result
<
Self
>
{
AddrIncoming
:
:
new
(
addr
)
}
pub
fn
local_addr
(
&
self
)
-
>
SocketAddr
{
self
.
addr
}
pub
fn
set_keepalive
(
&
mut
self
keepalive
:
Option
<
Duration
>
)
-
>
&
mut
Self
{
self
.
tcp_keepalive_timeout
=
keepalive
;
self
}
pub
fn
set_nodelay
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
self
.
tcp_nodelay
=
enabled
;
self
}
pub
fn
set_sleep_on_errors
(
&
mut
self
val
:
bool
)
{
self
.
sleep_on_errors
=
val
;
}
fn
poll_next_
(
&
mut
self
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
AddrStream
>
>
{
if
let
Some
(
ref
mut
to
)
=
self
.
timeout
{
match
Pin
:
:
new
(
to
)
.
poll
(
cx
)
{
Poll
:
:
Ready
(
(
)
)
=
>
{
}
Poll
:
:
Pending
=
>
return
Poll
:
:
Pending
}
}
self
.
timeout
=
None
;
let
accept
=
self
.
listener
.
accept
(
)
;
futures_util
:
:
pin_mut
!
(
accept
)
;
loop
{
match
accept
.
poll_unpin
(
cx
)
{
Poll
:
:
Ready
(
Ok
(
(
socket
addr
)
)
)
=
>
{
if
let
Some
(
dur
)
=
self
.
tcp_keepalive_timeout
{
if
let
Err
(
e
)
=
socket
.
set_keepalive
(
Some
(
dur
)
)
{
trace
!
(
"
error
trying
to
set
TCP
keepalive
:
{
}
"
e
)
;
}
}
if
let
Err
(
e
)
=
socket
.
set_nodelay
(
self
.
tcp_nodelay
)
{
trace
!
(
"
error
trying
to
set
TCP
nodelay
:
{
}
"
e
)
;
}
return
Poll
:
:
Ready
(
Ok
(
AddrStream
:
:
new
(
socket
addr
)
)
)
;
}
Poll
:
:
Pending
=
>
return
Poll
:
:
Pending
Poll
:
:
Ready
(
Err
(
e
)
)
=
>
{
if
is_connection_error
(
&
e
)
{
debug
!
(
"
accepted
connection
already
errored
:
{
}
"
e
)
;
continue
;
}
if
self
.
sleep_on_errors
{
error
!
(
"
accept
error
:
{
}
"
e
)
;
let
mut
timeout
=
tokio
:
:
time
:
:
delay_for
(
Duration
:
:
from_secs
(
1
)
)
;
match
Pin
:
:
new
(
&
mut
timeout
)
.
poll
(
cx
)
{
Poll
:
:
Ready
(
(
)
)
=
>
{
continue
;
}
Poll
:
:
Pending
=
>
{
self
.
timeout
=
Some
(
timeout
)
;
return
Poll
:
:
Pending
;
}
}
}
else
{
return
Poll
:
:
Ready
(
Err
(
e
)
)
;
}
}
}
}
}
}
impl
Accept
for
AddrIncoming
{
type
Conn
=
AddrStream
;
type
Error
=
io
:
:
Error
;
fn
poll_accept
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Option
<
Result
<
Self
:
:
Conn
Self
:
:
Error
>
>
>
{
let
result
=
ready
!
(
self
.
poll_next_
(
cx
)
)
;
Poll
:
:
Ready
(
Some
(
result
)
)
}
}
fn
is_connection_error
(
e
:
&
io
:
:
Error
)
-
>
bool
{
match
e
.
kind
(
)
{
io
:
:
ErrorKind
:
:
ConnectionRefused
|
io
:
:
ErrorKind
:
:
ConnectionAborted
|
io
:
:
ErrorKind
:
:
ConnectionReset
=
>
true
_
=
>
false
}
}
impl
fmt
:
:
Debug
for
AddrIncoming
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
AddrIncoming
"
)
.
field
(
"
addr
"
&
self
.
addr
)
.
field
(
"
sleep_on_errors
"
&
self
.
sleep_on_errors
)
.
field
(
"
tcp_keepalive_timeout
"
&
self
.
tcp_keepalive_timeout
)
.
field
(
"
tcp_nodelay
"
&
self
.
tcp_nodelay
)
.
finish
(
)
}
}
mod
addr_stream
{
use
bytes
:
:
{
Buf
BufMut
}
;
use
std
:
:
io
;
use
std
:
:
net
:
:
SocketAddr
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
tokio
:
:
net
:
:
TcpStream
;
use
crate
:
:
common
:
:
{
task
Pin
Poll
}
;
#
[
derive
(
Debug
)
]
pub
struct
AddrStream
{
inner
:
TcpStream
pub
(
super
)
remote_addr
:
SocketAddr
}
impl
AddrStream
{
pub
(
super
)
fn
new
(
tcp
:
TcpStream
addr
:
SocketAddr
)
-
>
AddrStream
{
AddrStream
{
inner
:
tcp
remote_addr
:
addr
}
}
#
[
inline
]
pub
fn
remote_addr
(
&
self
)
-
>
SocketAddr
{
self
.
remote_addr
}
#
[
inline
]
pub
fn
into_inner
(
self
)
-
>
TcpStream
{
self
.
inner
}
pub
fn
poll_peek
(
&
mut
self
cx
:
&
mut
task
:
:
Context
<
'
_
>
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
self
.
inner
.
poll_peek
(
cx
buf
)
}
}
impl
AsyncRead
for
AddrStream
{
unsafe
fn
prepare_uninitialized_buffer
(
&
self
buf
:
&
mut
[
std
:
:
mem
:
:
MaybeUninit
<
u8
>
]
)
-
>
bool
{
self
.
inner
.
prepare_uninitialized_buffer
(
buf
)
}
#
[
inline
]
fn
poll_read
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
buf
:
&
mut
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
Pin
:
:
new
(
&
mut
self
.
inner
)
.
poll_read
(
cx
buf
)
}
#
[
inline
]
fn
poll_read_buf
<
B
:
BufMut
>
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
buf
:
&
mut
B
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
Pin
:
:
new
(
&
mut
self
.
inner
)
.
poll_read_buf
(
cx
buf
)
}
}
impl
AsyncWrite
for
AddrStream
{
#
[
inline
]
fn
poll_write
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
buf
:
&
[
u8
]
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
Pin
:
:
new
(
&
mut
self
.
inner
)
.
poll_write
(
cx
buf
)
}
#
[
inline
]
fn
poll_write_buf
<
B
:
Buf
>
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
buf
:
&
mut
B
)
-
>
Poll
<
io
:
:
Result
<
usize
>
>
{
Pin
:
:
new
(
&
mut
self
.
inner
)
.
poll_write_buf
(
cx
buf
)
}
#
[
inline
]
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
_cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
#
[
inline
]
fn
poll_shutdown
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
io
:
:
Result
<
(
)
>
>
{
Pin
:
:
new
(
&
mut
self
.
inner
)
.
poll_shutdown
(
cx
)
}
}
}
