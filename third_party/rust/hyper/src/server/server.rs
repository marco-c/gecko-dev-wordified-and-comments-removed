use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
Unpin
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
use
std
:
:
net
:
:
{
SocketAddr
TcpListener
as
StdTcpListener
}
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
use
std
:
:
time
:
:
Duration
;
use
pin_project_lite
:
:
pin_project
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
tracing
:
:
trace
;
use
super
:
:
accept
:
:
Accept
;
#
[
cfg
(
all
(
feature
=
"
tcp
"
)
)
]
use
super
:
:
tcp
:
:
AddrIncoming
;
use
crate
:
:
body
:
:
{
Body
HttpBody
}
;
use
crate
:
:
common
:
:
exec
:
:
Exec
;
use
crate
:
:
common
:
:
exec
:
:
{
ConnStreamExec
NewSvcExec
}
;
use
super
:
:
conn
:
:
{
Connection
Http
as
Http_
UpgradeableConnection
}
;
use
super
:
:
shutdown
:
:
{
Graceful
GracefulWatcher
}
;
use
crate
:
:
service
:
:
{
HttpService
MakeServiceRef
}
;
use
self
:
:
new_svc
:
:
NewSvcTask
;
pin_project
!
{
/
/
/
A
listening
HTTP
server
that
accepts
connections
in
both
HTTP1
and
HTTP2
by
default
.
/
/
/
/
/
/
Server
is
a
Future
mapping
a
bound
listener
with
a
set
of
service
/
/
/
handlers
.
It
is
built
using
the
[
Builder
]
(
Builder
)
and
the
future
/
/
/
completes
when
the
server
has
been
shutdown
.
It
should
be
run
by
an
/
/
/
Executor
.
pub
struct
Server
<
I
S
E
=
Exec
>
{
#
[
pin
]
incoming
:
I
make_service
:
S
protocol
:
Http_
<
E
>
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
pub
struct
Builder
<
I
E
=
Exec
>
{
incoming
:
I
protocol
:
Http_
<
E
>
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
>
Server
<
I
(
)
>
{
pub
fn
builder
(
incoming
:
I
)
-
>
Builder
<
I
>
{
Builder
{
incoming
protocol
:
Http_
:
:
new
(
)
}
}
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
)
]
impl
Server
<
AddrIncoming
(
)
>
{
pub
fn
bind
(
addr
:
&
SocketAddr
)
-
>
Builder
<
AddrIncoming
>
{
let
incoming
=
AddrIncoming
:
:
new
(
addr
)
.
unwrap_or_else
(
|
e
|
{
panic
!
(
"
error
binding
to
{
}
:
{
}
"
addr
e
)
;
}
)
;
Server
:
:
builder
(
incoming
)
}
pub
fn
try_bind
(
addr
:
&
SocketAddr
)
-
>
crate
:
:
Result
<
Builder
<
AddrIncoming
>
>
{
AddrIncoming
:
:
new
(
addr
)
.
map
(
Server
:
:
builder
)
}
pub
fn
from_tcp
(
listener
:
StdTcpListener
)
-
>
Result
<
Builder
<
AddrIncoming
>
crate
:
:
Error
>
{
AddrIncoming
:
:
from_std
(
listener
)
.
map
(
Server
:
:
builder
)
}
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
)
]
impl
<
S
E
>
Server
<
AddrIncoming
S
E
>
{
pub
fn
local_addr
(
&
self
)
-
>
SocketAddr
{
self
.
incoming
.
local_addr
(
)
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
IO
IE
S
E
B
>
Server
<
I
S
E
>
where
I
:
Accept
<
Conn
=
IO
Error
=
IE
>
IE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
IO
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
IO
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
{
pub
fn
with_graceful_shutdown
<
F
>
(
self
signal
:
F
)
-
>
Graceful
<
I
S
F
E
>
where
F
:
Future
<
Output
=
(
)
>
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
GracefulWatcher
>
{
Graceful
:
:
new
(
self
signal
)
}
fn
poll_next_
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Option
<
crate
:
:
Result
<
Connecting
<
IO
S
:
:
Future
E
>
>
>
>
{
let
me
=
self
.
project
(
)
;
match
ready
!
(
me
.
make_service
.
poll_ready_ref
(
cx
)
)
{
Ok
(
(
)
)
=
>
(
)
Err
(
e
)
=
>
{
trace
!
(
"
make_service
closed
"
)
;
return
Poll
:
:
Ready
(
Some
(
Err
(
crate
:
:
Error
:
:
new_user_make_service
(
e
)
)
)
)
;
}
}
if
let
Some
(
item
)
=
ready
!
(
me
.
incoming
.
poll_accept
(
cx
)
)
{
let
io
=
item
.
map_err
(
crate
:
:
Error
:
:
new_accept
)
?
;
let
new_fut
=
me
.
make_service
.
make_service_ref
(
&
io
)
;
Poll
:
:
Ready
(
Some
(
Ok
(
Connecting
{
future
:
new_fut
io
:
Some
(
io
)
protocol
:
me
.
protocol
.
clone
(
)
}
)
)
)
}
else
{
Poll
:
:
Ready
(
None
)
}
}
pub
(
super
)
fn
poll_watch
<
W
>
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
watcher
:
&
W
)
-
>
Poll
<
crate
:
:
Result
<
(
)
>
>
where
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
W
>
W
:
Watcher
<
IO
S
:
:
Service
E
>
{
loop
{
if
let
Some
(
connecting
)
=
ready
!
(
self
.
as_mut
(
)
.
poll_next_
(
cx
)
?
)
{
let
fut
=
NewSvcTask
:
:
new
(
connecting
watcher
.
clone
(
)
)
;
self
.
as_mut
(
)
.
project
(
)
.
protocol
.
exec
.
execute_new_svc
(
fut
)
;
}
else
{
return
Poll
:
:
Ready
(
Ok
(
(
)
)
)
;
}
}
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
IO
IE
S
B
E
>
Future
for
Server
<
I
S
E
>
where
I
:
Accept
<
Conn
=
IO
Error
=
IE
>
IE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
IO
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
IO
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
NoopWatcher
>
{
type
Output
=
crate
:
:
Result
<
(
)
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
self
.
poll_watch
(
cx
&
NoopWatcher
)
}
}
impl
<
I
:
fmt
:
:
Debug
S
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Server
<
I
S
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
st
=
f
.
debug_struct
(
"
Server
"
)
;
st
.
field
(
"
listener
"
&
self
.
incoming
)
;
st
.
finish
(
)
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
E
>
Builder
<
I
E
>
{
pub
fn
new
(
incoming
:
I
protocol
:
Http_
<
E
>
)
-
>
Self
{
Builder
{
incoming
protocol
}
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_keepalive
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_keep_alive
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_half_close
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_half_close
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_max_buf_size
(
mut
self
val
:
usize
)
-
>
Self
{
self
.
protocol
.
max_buf_size
(
val
)
;
self
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
http1
"
)
]
pub
fn
http1_pipeline_flush
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
pipeline_flush
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
pub
fn
http1_writev
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_writev
(
enabled
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_title_case_headers
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_title_case_headers
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_preserve_header_case
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_preserve_header_case
(
val
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
)
)
]
pub
fn
http1_header_read_timeout
(
mut
self
read_timeout
:
Duration
)
-
>
Self
{
self
.
protocol
.
http1_header_read_timeout
(
read_timeout
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_only
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_only
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_only
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http2_only
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_pending_accept_reset_streams
(
mut
self
max
:
impl
Into
<
Option
<
usize
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_pending_accept_reset_streams
(
max
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_local_error_reset_streams
(
mut
self
max
:
impl
Into
<
Option
<
usize
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_local_error_reset_streams
(
max
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_initial_stream_window_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_initial_stream_window_size
(
sz
.
into
(
)
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_initial_connection_window_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_initial_connection_window_size
(
sz
.
into
(
)
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_adaptive_window
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
protocol
.
http2_adaptive_window
(
enabled
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_frame_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_frame_size
(
sz
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_header_list_size
(
mut
self
max
:
u32
)
-
>
Self
{
self
.
protocol
.
http2_max_header_list_size
(
max
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_concurrent_streams
(
mut
self
max
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_concurrent_streams
(
max
.
into
(
)
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
runtime
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_keep_alive_interval
(
mut
self
interval
:
impl
Into
<
Option
<
Duration
>
>
)
-
>
Self
{
self
.
protocol
.
http2_keep_alive_interval
(
interval
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
runtime
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_keep_alive_timeout
(
mut
self
timeout
:
Duration
)
-
>
Self
{
self
.
protocol
.
http2_keep_alive_timeout
(
timeout
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_send_buf_size
(
mut
self
max
:
usize
)
-
>
Self
{
self
.
protocol
.
http2_max_send_buf_size
(
max
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
pub
fn
http2_enable_connect_protocol
(
mut
self
)
-
>
Self
{
self
.
protocol
.
http2_enable_connect_protocol
(
)
;
self
}
pub
fn
executor
<
E2
>
(
self
executor
:
E2
)
-
>
Builder
<
I
E2
>
{
Builder
{
incoming
:
self
.
incoming
protocol
:
self
.
protocol
.
with_executor
(
executor
)
}
}
pub
fn
serve
<
S
B
>
(
self
make_service
:
S
)
-
>
Server
<
I
S
E
>
where
I
:
Accept
I
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
:
Conn
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
I
:
:
Conn
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
NewSvcExec
<
I
:
:
Conn
S
:
:
Future
S
:
:
Service
E
NoopWatcher
>
E
:
ConnStreamExec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
{
Server
{
incoming
:
self
.
incoming
make_service
protocol
:
self
.
protocol
.
clone
(
)
}
}
}
#
[
cfg
(
feature
=
"
tcp
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
)
]
impl
<
E
>
Builder
<
AddrIncoming
E
>
{
pub
fn
tcp_keepalive
(
mut
self
keepalive
:
Option
<
Duration
>
)
-
>
Self
{
self
.
incoming
.
set_keepalive
(
keepalive
)
;
self
}
pub
fn
tcp_keepalive_interval
(
mut
self
interval
:
Option
<
Duration
>
)
-
>
Self
{
self
.
incoming
.
set_keepalive_interval
(
interval
)
;
self
}
pub
fn
tcp_keepalive_retries
(
mut
self
retries
:
Option
<
u32
>
)
-
>
Self
{
self
.
incoming
.
set_keepalive_retries
(
retries
)
;
self
}
pub
fn
tcp_nodelay
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
incoming
.
set_nodelay
(
enabled
)
;
self
}
pub
fn
tcp_sleep_on_accept_errors
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
incoming
.
set_sleep_on_errors
(
val
)
;
self
}
pub
fn
local_addr
(
&
self
)
-
>
SocketAddr
{
self
.
incoming
.
local_addr
(
)
}
}
pub
trait
Watcher
<
I
S
:
HttpService
<
Body
>
E
>
:
Clone
{
type
Future
:
Future
<
Output
=
crate
:
:
Result
<
(
)
>
>
;
fn
watch
(
&
self
conn
:
UpgradeableConnection
<
I
S
E
>
)
-
>
Self
:
:
Future
;
}
#
[
allow
(
missing_debug_implementations
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
NoopWatcher
;
impl
<
I
S
E
>
Watcher
<
I
S
E
>
for
NoopWatcher
where
I
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
HttpService
<
Body
>
E
:
ConnStreamExec
<
S
:
:
Future
S
:
:
ResBody
>
S
:
:
ResBody
:
'
static
<
S
:
:
ResBody
as
HttpBody
>
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
{
type
Future
=
UpgradeableConnection
<
I
S
E
>
;
fn
watch
(
&
self
conn
:
UpgradeableConnection
<
I
S
E
>
)
-
>
Self
:
:
Future
{
conn
}
}
pub
(
crate
)
mod
new_svc
{
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
Unpin
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
tracing
:
:
debug
;
use
super
:
:
{
Connecting
Watcher
}
;
use
crate
:
:
body
:
:
{
Body
HttpBody
}
;
use
crate
:
:
common
:
:
exec
:
:
ConnStreamExec
;
use
crate
:
:
service
:
:
HttpService
;
use
pin_project_lite
:
:
pin_project
;
pin_project
!
{
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
NewSvcTask
<
I
N
S
:
HttpService
<
Body
>
E
W
:
Watcher
<
I
S
E
>
>
{
#
[
pin
]
state
:
State
<
I
N
S
E
W
>
}
}
pin_project
!
{
#
[
project
=
StateProj
]
pub
(
super
)
enum
State
<
I
N
S
:
HttpService
<
Body
>
E
W
:
Watcher
<
I
S
E
>
>
{
Connecting
{
#
[
pin
]
connecting
:
Connecting
<
I
N
E
>
watcher
:
W
}
Connected
{
#
[
pin
]
future
:
W
:
:
Future
}
}
}
impl
<
I
N
S
:
HttpService
<
Body
>
E
W
:
Watcher
<
I
S
E
>
>
NewSvcTask
<
I
N
S
E
W
>
{
pub
(
super
)
fn
new
(
connecting
:
Connecting
<
I
N
E
>
watcher
:
W
)
-
>
Self
{
NewSvcTask
{
state
:
State
:
:
Connecting
{
connecting
watcher
}
}
}
}
impl
<
I
N
S
NE
B
E
W
>
Future
for
NewSvcTask
<
I
N
S
E
W
>
where
I
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
N
:
Future
<
Output
=
Result
<
S
NE
>
>
NE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
S
:
HttpService
<
Body
ResBody
=
B
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
W
:
Watcher
<
I
S
E
>
{
type
Output
=
(
)
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
mut
me
=
self
.
project
(
)
;
loop
{
let
next
=
{
match
me
.
state
.
as_mut
(
)
.
project
(
)
{
StateProj
:
:
Connecting
{
connecting
watcher
}
=
>
{
let
res
=
ready
!
(
connecting
.
poll
(
cx
)
)
;
let
conn
=
match
res
{
Ok
(
conn
)
=
>
conn
Err
(
err
)
=
>
{
let
err
=
crate
:
:
Error
:
:
new_user_make_service
(
err
)
;
debug
!
(
"
connecting
error
:
{
}
"
err
)
;
return
Poll
:
:
Ready
(
(
)
)
;
}
}
;
let
future
=
watcher
.
watch
(
conn
.
with_upgrades
(
)
)
;
State
:
:
Connected
{
future
}
}
StateProj
:
:
Connected
{
future
}
=
>
{
return
future
.
poll
(
cx
)
.
map
(
|
res
|
{
if
let
Err
(
err
)
=
res
{
debug
!
(
"
connection
error
:
{
}
"
err
)
;
}
}
)
;
}
}
}
;
me
.
state
.
set
(
next
)
;
}
}
}
}
pin_project
!
{
/
/
/
A
future
building
a
new
Service
to
a
Connection
.
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
pub
struct
Connecting
<
I
F
E
=
Exec
>
{
#
[
pin
]
future
:
F
io
:
Option
<
I
>
protocol
:
Http_
<
E
>
}
}
impl
<
I
F
S
FE
E
B
>
Future
for
Connecting
<
I
F
E
>
where
I
:
AsyncRead
+
AsyncWrite
+
Unpin
F
:
Future
<
Output
=
Result
<
S
FE
>
>
S
:
HttpService
<
Body
ResBody
=
B
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
S
:
:
Future
B
>
{
type
Output
=
Result
<
Connection
<
I
S
E
>
FE
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
let
mut
me
=
self
.
project
(
)
;
let
service
=
ready
!
(
me
.
future
.
poll
(
cx
)
)
?
;
let
io
=
Option
:
:
take
(
&
mut
me
.
io
)
.
expect
(
"
polled
after
complete
"
)
;
Poll
:
:
Ready
(
Ok
(
me
.
protocol
.
serve_connection
(
io
service
)
)
)
}
}
