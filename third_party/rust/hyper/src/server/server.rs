use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
tcp
"
)
]
use
std
:
:
net
:
:
{
SocketAddr
TcpListener
as
StdTcpListener
}
;
#
[
cfg
(
any
(
feature
=
"
tcp
"
feature
=
"
http1
"
)
)
]
use
std
:
:
time
:
:
Duration
;
#
[
cfg
(
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
]
use
super
:
:
tcp
:
:
AddrIncoming
;
use
crate
:
:
common
:
:
exec
:
:
Exec
;
cfg_feature
!
{
#
!
[
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
]
use
std
:
:
error
:
:
Error
as
StdError
;
use
pin_project_lite
:
:
pin_project
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
super
:
:
accept
:
:
Accept
;
use
crate
:
:
body
:
:
{
Body
HttpBody
}
;
use
crate
:
:
common
:
:
{
task
Future
Pin
Poll
Unpin
}
;
use
crate
:
:
common
:
:
exec
:
:
{
ConnStreamExec
NewSvcExec
}
;
/
/
Renamed
Http
as
Http_
for
now
so
that
people
upgrading
don
'
t
see
an
/
/
error
that
hyper
:
:
server
:
:
Http
is
private
.
.
.
use
super
:
:
conn
:
:
{
Http
as
Http_
NoopWatcher
SpawnAll
}
;
use
super
:
:
shutdown
:
:
{
Graceful
GracefulWatcher
}
;
use
crate
:
:
service
:
:
{
HttpService
MakeServiceRef
}
;
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
pin_project
!
{
/
/
/
A
listening
HTTP
server
that
accepts
connections
in
both
HTTP1
and
HTTP2
by
default
.
/
/
/
/
/
/
Server
is
a
Future
mapping
a
bound
listener
with
a
set
of
service
/
/
/
handlers
.
It
is
built
using
the
[
Builder
]
(
Builder
)
and
the
future
/
/
/
completes
when
the
server
has
been
shutdown
.
It
should
be
run
by
an
/
/
/
Executor
.
pub
struct
Server
<
I
S
E
=
Exec
>
{
#
[
pin
]
spawn_all
:
SpawnAll
<
I
S
E
>
}
}
#
[
cfg
(
not
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
]
pub
struct
Server
<
I
S
E
=
Exec
>
{
_marker
:
std
:
:
marker
:
:
PhantomData
<
(
I
S
E
)
>
}
#
[
derive
(
Debug
)
]
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
pub
struct
Builder
<
I
E
=
Exec
>
{
incoming
:
I
protocol
:
Http_
<
E
>
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
>
Server
<
I
(
)
>
{
pub
fn
builder
(
incoming
:
I
)
-
>
Builder
<
I
>
{
Builder
{
incoming
protocol
:
Http_
:
:
new
(
)
}
}
}
cfg_feature
!
{
#
!
[
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
Server
<
AddrIncoming
(
)
>
{
/
/
/
Binds
to
the
provided
address
and
returns
a
[
Builder
]
(
Builder
)
.
/
/
/
/
/
/
#
Panics
/
/
/
/
/
/
This
method
will
panic
if
binding
to
the
address
fails
.
For
a
method
/
/
/
to
bind
to
an
address
and
return
a
Result
see
Server
:
:
try_bind
.
pub
fn
bind
(
addr
:
&
SocketAddr
)
-
>
Builder
<
AddrIncoming
>
{
let
incoming
=
AddrIncoming
:
:
new
(
addr
)
.
unwrap_or_else
(
|
e
|
{
panic
!
(
"
error
binding
to
{
}
:
{
}
"
addr
e
)
;
}
)
;
Server
:
:
builder
(
incoming
)
}
/
/
/
Tries
to
bind
to
the
provided
address
and
returns
a
[
Builder
]
(
Builder
)
.
pub
fn
try_bind
(
addr
:
&
SocketAddr
)
-
>
crate
:
:
Result
<
Builder
<
AddrIncoming
>
>
{
AddrIncoming
:
:
new
(
addr
)
.
map
(
Server
:
:
builder
)
}
/
/
/
Create
a
new
instance
from
a
std
:
:
net
:
:
TcpListener
instance
.
pub
fn
from_tcp
(
listener
:
StdTcpListener
)
-
>
Result
<
Builder
<
AddrIncoming
>
crate
:
:
Error
>
{
AddrIncoming
:
:
from_std
(
listener
)
.
map
(
Server
:
:
builder
)
}
}
}
cfg_feature
!
{
#
!
[
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
impl
<
S
E
>
Server
<
AddrIncoming
S
E
>
{
/
/
/
Returns
the
local
address
that
this
server
is
bound
to
.
pub
fn
local_addr
(
&
self
)
-
>
SocketAddr
{
self
.
spawn_all
.
local_addr
(
)
}
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
IO
IE
S
E
B
>
Server
<
I
S
E
>
where
I
:
Accept
<
Conn
=
IO
Error
=
IE
>
IE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
IO
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
IO
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
GracefulWatcher
>
{
pub
fn
with_graceful_shutdown
<
F
>
(
self
signal
:
F
)
-
>
Graceful
<
I
S
F
E
>
where
F
:
Future
<
Output
=
(
)
>
{
Graceful
:
:
new
(
self
.
spawn_all
signal
)
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
IO
IE
S
B
E
>
Future
for
Server
<
I
S
E
>
where
I
:
Accept
<
Conn
=
IO
Error
=
IE
>
IE
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
IO
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
IO
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
ConnStreamExec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
E
:
NewSvcExec
<
IO
S
:
:
Future
S
:
:
Service
E
NoopWatcher
>
{
type
Output
=
crate
:
:
Result
<
(
)
>
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
task
:
:
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
self
.
project
(
)
.
spawn_all
.
poll_watch
(
cx
&
NoopWatcher
)
}
}
impl
<
I
:
fmt
:
:
Debug
S
:
fmt
:
:
Debug
>
fmt
:
:
Debug
for
Server
<
I
S
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
let
mut
st
=
f
.
debug_struct
(
"
Server
"
)
;
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
st
.
field
(
"
listener
"
&
self
.
spawn_all
.
incoming_ref
(
)
)
;
st
.
finish
(
)
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
)
]
impl
<
I
E
>
Builder
<
I
E
>
{
pub
fn
new
(
incoming
:
I
protocol
:
Http_
<
E
>
)
-
>
Self
{
Builder
{
incoming
protocol
}
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_keepalive
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_keep_alive
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_half_close
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_half_close
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_max_buf_size
(
mut
self
val
:
usize
)
-
>
Self
{
self
.
protocol
.
max_buf_size
(
val
)
;
self
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
http1
"
)
]
pub
fn
http1_pipeline_flush
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
pipeline_flush
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
pub
fn
http1_writev
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_writev
(
enabled
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_title_case_headers
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_title_case_headers
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_preserve_header_case
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_preserve_header_case
(
val
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
http1
"
feature
=
"
runtime
"
)
)
)
)
]
pub
fn
http1_header_read_timeout
(
mut
self
read_timeout
:
Duration
)
-
>
Self
{
self
.
protocol
.
http1_header_read_timeout
(
read_timeout
)
;
self
}
#
[
cfg
(
feature
=
"
http1
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http1
"
)
)
)
]
pub
fn
http1_only
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http1_only
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_only
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
protocol
.
http2_only
(
val
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_initial_stream_window_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_initial_stream_window_size
(
sz
.
into
(
)
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_initial_connection_window_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_initial_connection_window_size
(
sz
.
into
(
)
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_adaptive_window
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
protocol
.
http2_adaptive_window
(
enabled
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_frame_size
(
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_frame_size
(
sz
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_concurrent_streams
(
mut
self
max
:
impl
Into
<
Option
<
u32
>
>
)
-
>
Self
{
self
.
protocol
.
http2_max_concurrent_streams
(
max
.
into
(
)
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
runtime
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_keep_alive_interval
(
mut
self
interval
:
impl
Into
<
Option
<
Duration
>
>
)
-
>
Self
{
self
.
protocol
.
http2_keep_alive_interval
(
interval
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
runtime
"
feature
=
"
http2
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_keep_alive_timeout
(
mut
self
timeout
:
Duration
)
-
>
Self
{
self
.
protocol
.
http2_keep_alive_timeout
(
timeout
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
feature
=
"
http2
"
)
)
)
]
pub
fn
http2_max_send_buf_size
(
mut
self
max
:
usize
)
-
>
Self
{
self
.
protocol
.
http2_max_send_buf_size
(
max
)
;
self
}
#
[
cfg
(
feature
=
"
http2
"
)
]
pub
fn
http2_enable_connect_protocol
(
mut
self
)
-
>
Self
{
self
.
protocol
.
http2_enable_connect_protocol
(
)
;
self
}
pub
fn
executor
<
E2
>
(
self
executor
:
E2
)
-
>
Builder
<
I
E2
>
{
Builder
{
incoming
:
self
.
incoming
protocol
:
self
.
protocol
.
with_executor
(
executor
)
}
}
pub
fn
serve
<
S
B
>
(
self
new_service
:
S
)
-
>
Server
<
I
S
E
>
where
I
:
Accept
I
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
I
:
:
Conn
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
S
:
MakeServiceRef
<
I
:
:
Conn
Body
ResBody
=
B
>
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
B
:
HttpBody
+
'
static
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
E
:
NewSvcExec
<
I
:
:
Conn
S
:
:
Future
S
:
:
Service
E
NoopWatcher
>
E
:
ConnStreamExec
<
<
S
:
:
Service
as
HttpService
<
Body
>
>
:
:
Future
B
>
{
let
serve
=
self
.
protocol
.
serve
(
self
.
incoming
new_service
)
;
let
spawn_all
=
serve
.
spawn_all
(
)
;
Server
{
spawn_all
}
}
}
#
[
cfg
(
all
(
feature
=
"
tcp
"
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
)
]
impl
<
E
>
Builder
<
AddrIncoming
E
>
{
pub
fn
tcp_keepalive
(
mut
self
keepalive
:
Option
<
Duration
>
)
-
>
Self
{
self
.
incoming
.
set_keepalive
(
keepalive
)
;
self
}
pub
fn
tcp_nodelay
(
mut
self
enabled
:
bool
)
-
>
Self
{
self
.
incoming
.
set_nodelay
(
enabled
)
;
self
}
pub
fn
tcp_sleep_on_accept_errors
(
mut
self
val
:
bool
)
-
>
Self
{
self
.
incoming
.
set_sleep_on_errors
(
val
)
;
self
}
}
