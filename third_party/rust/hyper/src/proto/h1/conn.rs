use
std
:
:
fmt
;
use
std
:
:
io
:
:
{
self
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
bytes
:
:
{
Buf
Bytes
}
;
use
futures
:
:
{
Async
Poll
}
;
use
http
:
:
{
HeaderMap
Method
Version
}
;
use
http
:
:
header
:
:
{
HeaderValue
CONNECTION
}
;
use
tokio_io
:
:
{
AsyncRead
AsyncWrite
}
;
use
:
:
Chunk
;
use
proto
:
:
{
BodyLength
DecodedLength
MessageHead
}
;
use
headers
:
:
connection_keep_alive
;
use
super
:
:
io
:
:
{
Buffered
}
;
use
super
:
:
{
EncodedBuf
Encode
Encoder
Decoder
Http1Transaction
ParseContext
}
;
const
H2_PREFACE
:
&
'
static
[
u8
]
=
b
"
PRI
*
HTTP
/
2
.
0
\
r
\
n
\
r
\
nSM
\
r
\
n
\
r
\
n
"
;
pub
(
crate
)
struct
Conn
<
I
B
T
>
{
io
:
Buffered
<
I
EncodedBuf
<
B
>
>
state
:
State
_marker
:
PhantomData
<
T
>
}
impl
<
I
B
T
>
Conn
<
I
B
T
>
where
I
:
AsyncRead
+
AsyncWrite
B
:
Buf
T
:
Http1Transaction
{
pub
fn
new
(
io
:
I
)
-
>
Conn
<
I
B
T
>
{
Conn
{
io
:
Buffered
:
:
new
(
io
)
state
:
State
{
allow_half_close
:
true
cached_headers
:
None
error
:
None
keep_alive
:
KA
:
:
Busy
method
:
None
title_case_headers
:
false
notify_read
:
false
reading
:
Reading
:
:
Init
writing
:
Writing
:
:
Init
upgrade
:
None
version
:
Version
:
:
HTTP_11
}
_marker
:
PhantomData
}
}
pub
fn
set_flush_pipeline
(
&
mut
self
enabled
:
bool
)
{
self
.
io
.
set_flush_pipeline
(
enabled
)
;
}
pub
fn
set_max_buf_size
(
&
mut
self
max
:
usize
)
{
self
.
io
.
set_max_buf_size
(
max
)
;
}
pub
fn
set_read_buf_exact_size
(
&
mut
self
sz
:
usize
)
{
self
.
io
.
set_read_buf_exact_size
(
sz
)
;
}
pub
fn
set_write_strategy_flatten
(
&
mut
self
)
{
self
.
io
.
set_write_strategy_flatten
(
)
;
}
pub
fn
set_title_case_headers
(
&
mut
self
)
{
self
.
state
.
title_case_headers
=
true
;
}
pub
(
crate
)
fn
set_disable_half_close
(
&
mut
self
)
{
self
.
state
.
allow_half_close
=
false
;
}
pub
fn
into_inner
(
self
)
-
>
(
I
Bytes
)
{
self
.
io
.
into_inner
(
)
}
pub
fn
pending_upgrade
(
&
mut
self
)
-
>
Option
<
:
:
upgrade
:
:
Pending
>
{
self
.
state
.
upgrade
.
take
(
)
}
pub
fn
is_read_closed
(
&
self
)
-
>
bool
{
self
.
state
.
is_read_closed
(
)
}
pub
fn
is_write_closed
(
&
self
)
-
>
bool
{
self
.
state
.
is_write_closed
(
)
}
pub
fn
can_read_head
(
&
self
)
-
>
bool
{
match
self
.
state
.
reading
{
Reading
:
:
Init
=
>
{
if
T
:
:
should_read_first
(
)
{
true
}
else
{
match
self
.
state
.
writing
{
Writing
:
:
Init
=
>
false
_
=
>
true
}
}
}
_
=
>
false
}
}
pub
fn
can_read_body
(
&
self
)
-
>
bool
{
match
self
.
state
.
reading
{
Reading
:
:
Body
(
.
.
)
=
>
true
_
=
>
false
}
}
fn
should_error_on_eof
(
&
self
)
-
>
bool
{
T
:
:
should_error_on_parse_eof
(
)
&
&
!
self
.
state
.
is_idle
(
)
}
fn
has_h2_prefix
(
&
self
)
-
>
bool
{
let
read_buf
=
self
.
io
.
read_buf
(
)
;
read_buf
.
len
(
)
>
=
24
&
&
read_buf
[
.
.
24
]
=
=
*
H2_PREFACE
}
pub
fn
read_head
(
&
mut
self
)
-
>
Poll
<
Option
<
(
MessageHead
<
T
:
:
Incoming
>
DecodedLength
bool
)
>
:
:
Error
>
{
debug_assert
!
(
self
.
can_read_head
(
)
)
;
trace
!
(
"
Conn
:
:
read_head
"
)
;
let
msg
=
match
self
.
io
.
parse
:
:
<
T
>
(
ParseContext
{
cached_headers
:
&
mut
self
.
state
.
cached_headers
req_method
:
&
mut
self
.
state
.
method
}
)
{
Ok
(
Async
:
:
Ready
(
msg
)
)
=
>
msg
Ok
(
Async
:
:
NotReady
)
=
>
return
Ok
(
Async
:
:
NotReady
)
Err
(
e
)
=
>
return
self
.
on_read_head_error
(
e
)
}
;
debug
!
(
"
incoming
body
is
{
}
"
msg
.
decode
)
;
self
.
state
.
busy
(
)
;
self
.
state
.
keep_alive
&
=
msg
.
keep_alive
;
self
.
state
.
version
=
msg
.
head
.
version
;
if
msg
.
decode
=
=
DecodedLength
:
:
ZERO
{
debug_assert
!
(
!
msg
.
expect_continue
"
expect
-
continue
needs
a
body
"
)
;
self
.
state
.
reading
=
Reading
:
:
KeepAlive
;
if
!
T
:
:
should_read_first
(
)
{
self
.
try_keep_alive
(
)
;
}
}
else
{
if
msg
.
expect_continue
{
let
cont
=
b
"
HTTP
/
1
.
1
100
Continue
\
r
\
n
\
r
\
n
"
;
self
.
io
.
headers_buf
(
)
.
extend_from_slice
(
cont
)
;
}
self
.
state
.
reading
=
Reading
:
:
Body
(
Decoder
:
:
new
(
msg
.
decode
)
)
;
}
;
Ok
(
Async
:
:
Ready
(
Some
(
(
msg
.
head
msg
.
decode
msg
.
wants_upgrade
)
)
)
)
}
fn
on_read_head_error
<
Z
>
(
&
mut
self
e
:
:
:
Error
)
-
>
Poll
<
Option
<
Z
>
:
:
Error
>
{
let
must_error
=
self
.
should_error_on_eof
(
)
;
self
.
state
.
close_read
(
)
;
self
.
io
.
consume_leading_lines
(
)
;
let
was_mid_parse
=
e
.
is_parse
(
)
|
|
!
self
.
io
.
read_buf
(
)
.
is_empty
(
)
;
if
was_mid_parse
|
|
must_error
{
debug
!
(
"
parse
error
(
{
}
)
with
{
}
bytes
"
e
self
.
io
.
read_buf
(
)
.
len
(
)
)
;
self
.
on_parse_error
(
e
)
.
map
(
|
(
)
|
Async
:
:
NotReady
)
}
else
{
debug
!
(
"
read
eof
"
)
;
Ok
(
Async
:
:
Ready
(
None
)
)
}
}
pub
fn
read_body
(
&
mut
self
)
-
>
Poll
<
Option
<
Chunk
>
io
:
:
Error
>
{
debug_assert
!
(
self
.
can_read_body
(
)
)
;
let
(
reading
ret
)
=
match
self
.
state
.
reading
{
Reading
:
:
Body
(
ref
mut
decoder
)
=
>
{
match
decoder
.
decode
(
&
mut
self
.
io
)
{
Ok
(
Async
:
:
Ready
(
slice
)
)
=
>
{
let
(
reading
chunk
)
=
if
decoder
.
is_eof
(
)
{
debug
!
(
"
incoming
body
completed
"
)
;
(
Reading
:
:
KeepAlive
if
!
slice
.
is_empty
(
)
{
Some
(
Chunk
:
:
from
(
slice
)
)
}
else
{
None
}
)
}
else
if
slice
.
is_empty
(
)
{
error
!
(
"
decode
stream
unexpectedly
ended
"
)
;
(
Reading
:
:
Closed
None
)
}
else
{
return
Ok
(
Async
:
:
Ready
(
Some
(
Chunk
:
:
from
(
slice
)
)
)
)
;
}
;
(
reading
Ok
(
Async
:
:
Ready
(
chunk
)
)
)
}
Ok
(
Async
:
:
NotReady
)
=
>
return
Ok
(
Async
:
:
NotReady
)
Err
(
e
)
=
>
{
debug
!
(
"
decode
stream
error
:
{
}
"
e
)
;
(
Reading
:
:
Closed
Err
(
e
)
)
}
}
}
_
=
>
unreachable
!
(
"
read_body
invalid
state
:
{
:
?
}
"
self
.
state
.
reading
)
}
;
self
.
state
.
reading
=
reading
;
self
.
try_keep_alive
(
)
;
ret
}
pub
fn
read_keep_alive
(
&
mut
self
)
-
>
Result
<
(
)
:
:
Error
>
{
debug_assert
!
(
!
self
.
can_read_head
(
)
&
&
!
self
.
can_read_body
(
)
)
;
trace
!
(
"
read_keep_alive
;
is_mid_message
=
{
}
"
self
.
is_mid_message
(
)
)
;
if
self
.
is_mid_message
(
)
{
self
.
mid_message_detect_eof
(
)
.
map_err
(
:
:
Error
:
:
new_io
)
}
else
{
self
.
require_empty_read
(
)
.
map_err
(
:
:
Error
:
:
new_io
)
}
}
fn
is_mid_message
(
&
self
)
-
>
bool
{
match
(
&
self
.
state
.
reading
&
self
.
state
.
writing
)
{
(
&
Reading
:
:
Init
&
Writing
:
:
Init
)
=
>
false
_
=
>
true
}
}
pub
fn
wants_read_again
(
&
mut
self
)
-
>
bool
{
let
ret
=
self
.
state
.
notify_read
;
self
.
state
.
notify_read
=
false
;
ret
}
fn
require_empty_read
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
debug_assert
!
(
!
self
.
can_read_head
(
)
&
&
!
self
.
can_read_body
(
)
)
;
if
!
self
.
io
.
read_buf
(
)
.
is_empty
(
)
{
debug
!
(
"
received
an
unexpected
{
}
bytes
"
self
.
io
.
read_buf
(
)
.
len
(
)
)
;
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
"
unexpected
bytes
after
message
ended
"
)
)
}
else
{
match
self
.
try_io_read
(
)
?
{
Async
:
:
Ready
(
0
)
=
>
{
Ok
(
(
)
)
}
Async
:
:
Ready
(
n
)
=
>
{
debug
!
(
"
received
{
}
bytes
on
an
idle
connection
"
n
)
;
let
desc
=
if
self
.
state
.
is_idle
(
)
{
"
unexpected
bytes
after
message
ended
"
}
else
{
"
unexpected
bytes
before
writing
message
"
}
;
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
desc
)
)
}
Async
:
:
NotReady
=
>
{
Ok
(
(
)
)
}
}
}
}
fn
mid_message_detect_eof
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
debug_assert
!
(
!
self
.
can_read_head
(
)
&
&
!
self
.
can_read_body
(
)
)
;
if
self
.
state
.
allow_half_close
|
|
!
self
.
io
.
read_buf
(
)
.
is_empty
(
)
{
Ok
(
(
)
)
}
else
{
self
.
try_io_read
(
)
.
map
(
|
_
|
(
)
)
}
}
fn
try_io_read
(
&
mut
self
)
-
>
Poll
<
usize
io
:
:
Error
>
{
match
self
.
io
.
read_from_io
(
)
{
Ok
(
Async
:
:
Ready
(
0
)
)
=
>
{
trace
!
(
"
try_io_read
;
found
EOF
on
connection
:
{
:
?
}
"
self
.
state
)
;
let
must_error
=
!
self
.
state
.
is_idle
(
)
;
let
ret
=
if
must_error
{
let
desc
=
if
self
.
is_mid_message
(
)
{
"
unexpected
EOF
waiting
for
response
"
}
else
{
"
unexpected
EOF
before
writing
message
"
}
;
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
UnexpectedEof
desc
)
)
}
else
{
Ok
(
Async
:
:
Ready
(
0
)
)
}
;
self
.
state
.
close_read
(
)
;
ret
}
Ok
(
Async
:
:
Ready
(
n
)
)
=
>
{
Ok
(
Async
:
:
Ready
(
n
)
)
}
Ok
(
Async
:
:
NotReady
)
=
>
{
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
{
trace
!
(
"
try_io_read
;
error
=
{
}
"
e
)
;
self
.
state
.
close
(
)
;
Err
(
e
)
}
}
}
fn
maybe_notify
(
&
mut
self
)
{
match
self
.
state
.
reading
{
Reading
:
:
Body
(
.
.
)
|
Reading
:
:
KeepAlive
|
Reading
:
:
Closed
=
>
return
Reading
:
:
Init
=
>
(
)
}
;
match
self
.
state
.
writing
{
Writing
:
:
Body
(
.
.
)
=
>
return
Writing
:
:
Init
|
Writing
:
:
KeepAlive
|
Writing
:
:
Closed
=
>
(
)
}
if
!
self
.
io
.
is_read_blocked
(
)
{
if
self
.
io
.
read_buf
(
)
.
is_empty
(
)
{
match
self
.
io
.
read_from_io
(
)
{
Ok
(
Async
:
:
Ready
(
_
)
)
=
>
(
)
Ok
(
Async
:
:
NotReady
)
=
>
{
trace
!
(
"
maybe_notify
;
read_from_io
blocked
"
)
;
return
}
Err
(
e
)
=
>
{
trace
!
(
"
maybe_notify
;
read_from_io
error
:
{
}
"
e
)
;
self
.
state
.
close
(
)
;
}
}
}
self
.
state
.
notify_read
=
true
;
}
}
fn
try_keep_alive
(
&
mut
self
)
{
self
.
state
.
try_keep_alive
:
:
<
T
>
(
)
;
self
.
maybe_notify
(
)
;
}
pub
fn
can_write_head
(
&
self
)
-
>
bool
{
if
!
T
:
:
should_read_first
(
)
{
match
self
.
state
.
reading
{
Reading
:
:
Closed
=
>
return
false
_
=
>
{
}
}
}
match
self
.
state
.
writing
{
Writing
:
:
Init
=
>
true
_
=
>
false
}
}
pub
fn
can_write_body
(
&
self
)
-
>
bool
{
match
self
.
state
.
writing
{
Writing
:
:
Body
(
.
.
)
=
>
true
Writing
:
:
Init
|
Writing
:
:
KeepAlive
|
Writing
:
:
Closed
=
>
false
}
}
pub
fn
can_buffer_body
(
&
self
)
-
>
bool
{
self
.
io
.
can_buffer
(
)
}
pub
fn
write_head
(
&
mut
self
head
:
MessageHead
<
T
:
:
Outgoing
>
body
:
Option
<
BodyLength
>
)
{
if
let
Some
(
encoder
)
=
self
.
encode_head
(
head
body
)
{
self
.
state
.
writing
=
if
!
encoder
.
is_eof
(
)
{
Writing
:
:
Body
(
encoder
)
}
else
if
encoder
.
is_last
(
)
{
Writing
:
:
Closed
}
else
{
Writing
:
:
KeepAlive
}
;
}
}
pub
fn
write_full_msg
(
&
mut
self
head
:
MessageHead
<
T
:
:
Outgoing
>
body
:
B
)
{
if
let
Some
(
encoder
)
=
self
.
encode_head
(
head
Some
(
BodyLength
:
:
Known
(
body
.
remaining
(
)
as
u64
)
)
)
{
let
is_last
=
encoder
.
is_last
(
)
;
if
!
encoder
.
is_eof
(
)
{
encoder
.
danger_full_buf
(
body
self
.
io
.
write_buf
(
)
)
;
}
self
.
state
.
writing
=
if
is_last
{
Writing
:
:
Closed
}
else
{
Writing
:
:
KeepAlive
}
}
}
fn
encode_head
(
&
mut
self
mut
head
:
MessageHead
<
T
:
:
Outgoing
>
body
:
Option
<
BodyLength
>
)
-
>
Option
<
Encoder
>
{
debug_assert
!
(
self
.
can_write_head
(
)
)
;
if
!
T
:
:
should_read_first
(
)
{
self
.
state
.
busy
(
)
;
}
self
.
enforce_version
(
&
mut
head
)
;
let
buf
=
self
.
io
.
headers_buf
(
)
;
match
T
:
:
encode
(
Encode
{
head
:
&
mut
head
body
keep_alive
:
self
.
state
.
wants_keep_alive
(
)
req_method
:
&
mut
self
.
state
.
method
title_case_headers
:
self
.
state
.
title_case_headers
}
buf
)
{
Ok
(
encoder
)
=
>
{
debug_assert
!
(
self
.
state
.
cached_headers
.
is_none
(
)
)
;
debug_assert
!
(
head
.
headers
.
is_empty
(
)
)
;
self
.
state
.
cached_headers
=
Some
(
head
.
headers
)
;
Some
(
encoder
)
}
Err
(
err
)
=
>
{
self
.
state
.
error
=
Some
(
err
)
;
self
.
state
.
writing
=
Writing
:
:
Closed
;
None
}
}
}
fn
fix_keep_alive
(
&
mut
self
head
:
&
mut
MessageHead
<
T
:
:
Outgoing
>
)
{
let
outgoing_is_keep_alive
=
head
.
headers
.
get
(
CONNECTION
)
.
and_then
(
|
value
|
Some
(
connection_keep_alive
(
value
)
)
)
.
unwrap_or
(
false
)
;
if
!
outgoing_is_keep_alive
{
match
head
.
version
{
Version
:
:
HTTP_10
=
>
self
.
state
.
disable_keep_alive
(
)
Version
:
:
HTTP_11
=
>
if
self
.
state
.
wants_keep_alive
(
)
{
head
.
headers
.
insert
(
CONNECTION
HeaderValue
:
:
from_static
(
"
keep
-
alive
"
)
)
;
}
_
=
>
(
)
}
}
}
fn
enforce_version
(
&
mut
self
head
:
&
mut
MessageHead
<
T
:
:
Outgoing
>
)
{
match
self
.
state
.
version
{
Version
:
:
HTTP_10
=
>
{
self
.
fix_keep_alive
(
head
)
;
head
.
version
=
Version
:
:
HTTP_10
;
}
_
=
>
{
}
}
}
pub
fn
write_body
(
&
mut
self
chunk
:
B
)
{
debug_assert
!
(
self
.
can_write_body
(
)
&
&
self
.
can_buffer_body
(
)
)
;
debug_assert
!
(
chunk
.
remaining
(
)
!
=
0
)
;
let
state
=
match
self
.
state
.
writing
{
Writing
:
:
Body
(
ref
mut
encoder
)
=
>
{
self
.
io
.
buffer
(
encoder
.
encode
(
chunk
)
)
;
if
encoder
.
is_eof
(
)
{
if
encoder
.
is_last
(
)
{
Writing
:
:
Closed
}
else
{
Writing
:
:
KeepAlive
}
}
else
{
return
;
}
}
_
=
>
unreachable
!
(
"
write_body
invalid
state
:
{
:
?
}
"
self
.
state
.
writing
)
}
;
self
.
state
.
writing
=
state
;
}
pub
fn
write_body_and_end
(
&
mut
self
chunk
:
B
)
{
debug_assert
!
(
self
.
can_write_body
(
)
&
&
self
.
can_buffer_body
(
)
)
;
debug_assert
!
(
chunk
.
remaining
(
)
!
=
0
)
;
let
state
=
match
self
.
state
.
writing
{
Writing
:
:
Body
(
ref
encoder
)
=
>
{
let
can_keep_alive
=
encoder
.
encode_and_end
(
chunk
self
.
io
.
write_buf
(
)
)
;
if
can_keep_alive
{
Writing
:
:
KeepAlive
}
else
{
Writing
:
:
Closed
}
}
_
=
>
unreachable
!
(
"
write_body
invalid
state
:
{
:
?
}
"
self
.
state
.
writing
)
}
;
self
.
state
.
writing
=
state
;
}
pub
fn
end_body
(
&
mut
self
)
{
debug_assert
!
(
self
.
can_write_body
(
)
)
;
let
state
=
match
self
.
state
.
writing
{
Writing
:
:
Body
(
ref
mut
encoder
)
=
>
{
match
encoder
.
end
(
)
{
Ok
(
end
)
=
>
{
if
let
Some
(
end
)
=
end
{
self
.
io
.
buffer
(
end
)
;
}
if
encoder
.
is_last
(
)
{
Writing
:
:
Closed
}
else
{
Writing
:
:
KeepAlive
}
}
Err
(
_not_eof
)
=
>
Writing
:
:
Closed
}
}
_
=
>
return
}
;
self
.
state
.
writing
=
state
;
}
fn
on_parse_error
(
&
mut
self
err
:
:
:
Error
)
-
>
:
:
Result
<
(
)
>
{
match
self
.
state
.
writing
{
Writing
:
:
Init
=
>
{
if
self
.
has_h2_prefix
(
)
{
return
Err
(
:
:
Error
:
:
new_version_h2
(
)
)
}
if
let
Some
(
msg
)
=
T
:
:
on_error
(
&
err
)
{
self
.
state
.
cached_headers
.
take
(
)
;
self
.
write_head
(
msg
None
)
;
self
.
state
.
error
=
Some
(
err
)
;
return
Ok
(
(
)
)
;
}
}
_
=
>
(
)
}
Err
(
err
)
}
pub
fn
flush
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
try_ready
!
(
self
.
io
.
flush
(
)
)
;
self
.
try_keep_alive
(
)
;
trace
!
(
"
flushed
(
{
}
)
:
{
:
?
}
"
T
:
:
LOG
self
.
state
)
;
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
pub
fn
shutdown
(
&
mut
self
)
-
>
Poll
<
(
)
io
:
:
Error
>
{
match
self
.
io
.
io_mut
(
)
.
shutdown
(
)
{
Ok
(
Async
:
:
NotReady
)
=
>
Ok
(
Async
:
:
NotReady
)
Ok
(
Async
:
:
Ready
(
(
)
)
)
=
>
{
trace
!
(
"
shut
down
IO
complete
"
)
;
Ok
(
Async
:
:
Ready
(
(
)
)
)
}
Err
(
e
)
=
>
{
debug
!
(
"
error
shutting
down
IO
:
{
}
"
e
)
;
Err
(
e
)
}
}
}
pub
fn
close_read
(
&
mut
self
)
{
self
.
state
.
close_read
(
)
;
}
pub
fn
close_write
(
&
mut
self
)
{
self
.
state
.
close_write
(
)
;
}
pub
fn
disable_keep_alive
(
&
mut
self
)
{
if
self
.
state
.
is_idle
(
)
{
self
.
state
.
close_read
(
)
;
}
else
{
self
.
state
.
disable_keep_alive
(
)
;
}
}
pub
fn
take_error
(
&
mut
self
)
-
>
:
:
Result
<
(
)
>
{
if
let
Some
(
err
)
=
self
.
state
.
error
.
take
(
)
{
Err
(
err
)
}
else
{
Ok
(
(
)
)
}
}
pub
(
super
)
fn
on_upgrade
(
&
mut
self
)
-
>
:
:
upgrade
:
:
OnUpgrade
{
trace
!
(
"
{
}
:
prepare
possible
HTTP
upgrade
"
T
:
:
LOG
)
;
self
.
state
.
prepare_upgrade
(
)
}
#
[
cfg
(
test
)
]
pub
(
super
)
fn
io_mut
(
&
mut
self
)
-
>
&
mut
I
{
self
.
io
.
io_mut
(
)
}
}
impl
<
I
B
:
Buf
T
>
fmt
:
:
Debug
for
Conn
<
I
B
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Conn
"
)
.
field
(
"
state
"
&
self
.
state
)
.
field
(
"
io
"
&
self
.
io
)
.
finish
(
)
}
}
struct
State
{
allow_half_close
:
bool
cached_headers
:
Option
<
HeaderMap
>
error
:
Option
<
:
:
Error
>
keep_alive
:
KA
method
:
Option
<
Method
>
title_case_headers
:
bool
notify_read
:
bool
reading
:
Reading
writing
:
Writing
upgrade
:
Option
<
:
:
upgrade
:
:
Pending
>
version
:
Version
}
#
[
derive
(
Debug
)
]
enum
Reading
{
Init
Body
(
Decoder
)
KeepAlive
Closed
}
enum
Writing
{
Init
Body
(
Encoder
)
KeepAlive
Closed
}
impl
fmt
:
:
Debug
for
State
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
State
"
)
.
field
(
"
reading
"
&
self
.
reading
)
.
field
(
"
writing
"
&
self
.
writing
)
.
field
(
"
keep_alive
"
&
self
.
keep_alive
)
.
field
(
"
error
"
&
self
.
error
)
.
finish
(
)
}
}
impl
fmt
:
:
Debug
for
Writing
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
Writing
:
:
Init
=
>
f
.
write_str
(
"
Init
"
)
Writing
:
:
Body
(
ref
enc
)
=
>
f
.
debug_tuple
(
"
Body
"
)
.
field
(
enc
)
.
finish
(
)
Writing
:
:
KeepAlive
=
>
f
.
write_str
(
"
KeepAlive
"
)
Writing
:
:
Closed
=
>
f
.
write_str
(
"
Closed
"
)
}
}
}
impl
:
:
std
:
:
ops
:
:
BitAndAssign
<
bool
>
for
KA
{
fn
bitand_assign
(
&
mut
self
enabled
:
bool
)
{
if
!
enabled
{
trace
!
(
"
remote
disabling
keep
-
alive
"
)
;
*
self
=
KA
:
:
Disabled
;
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
KA
{
Idle
Busy
Disabled
}
impl
Default
for
KA
{
fn
default
(
)
-
>
KA
{
KA
:
:
Busy
}
}
impl
KA
{
fn
idle
(
&
mut
self
)
{
*
self
=
KA
:
:
Idle
;
}
fn
busy
(
&
mut
self
)
{
*
self
=
KA
:
:
Busy
;
}
fn
disable
(
&
mut
self
)
{
*
self
=
KA
:
:
Disabled
;
}
fn
status
(
&
self
)
-
>
KA
{
*
self
}
}
impl
State
{
fn
close
(
&
mut
self
)
{
trace
!
(
"
State
:
:
close
(
)
"
)
;
self
.
reading
=
Reading
:
:
Closed
;
self
.
writing
=
Writing
:
:
Closed
;
self
.
keep_alive
.
disable
(
)
;
}
fn
close_read
(
&
mut
self
)
{
trace
!
(
"
State
:
:
close_read
(
)
"
)
;
self
.
reading
=
Reading
:
:
Closed
;
self
.
keep_alive
.
disable
(
)
;
}
fn
close_write
(
&
mut
self
)
{
trace
!
(
"
State
:
:
close_write
(
)
"
)
;
self
.
writing
=
Writing
:
:
Closed
;
self
.
keep_alive
.
disable
(
)
;
}
fn
wants_keep_alive
(
&
self
)
-
>
bool
{
if
let
KA
:
:
Disabled
=
self
.
keep_alive
.
status
(
)
{
false
}
else
{
true
}
}
fn
try_keep_alive
<
T
:
Http1Transaction
>
(
&
mut
self
)
{
match
(
&
self
.
reading
&
self
.
writing
)
{
(
&
Reading
:
:
KeepAlive
&
Writing
:
:
KeepAlive
)
=
>
{
if
let
KA
:
:
Busy
=
self
.
keep_alive
.
status
(
)
{
self
.
idle
:
:
<
T
>
(
)
;
}
else
{
trace
!
(
"
try_keep_alive
(
{
}
)
:
could
keep
-
alive
but
status
=
{
:
?
}
"
T
:
:
LOG
self
.
keep_alive
)
;
self
.
close
(
)
;
}
}
(
&
Reading
:
:
Closed
&
Writing
:
:
KeepAlive
)
|
(
&
Reading
:
:
KeepAlive
&
Writing
:
:
Closed
)
=
>
{
self
.
close
(
)
}
_
=
>
(
)
}
}
fn
disable_keep_alive
(
&
mut
self
)
{
self
.
keep_alive
.
disable
(
)
}
fn
busy
(
&
mut
self
)
{
if
let
KA
:
:
Disabled
=
self
.
keep_alive
.
status
(
)
{
return
;
}
self
.
keep_alive
.
busy
(
)
;
}
fn
idle
<
T
:
Http1Transaction
>
(
&
mut
self
)
{
debug_assert
!
(
!
self
.
is_idle
(
)
"
State
:
:
idle
(
)
called
while
idle
"
)
;
self
.
method
=
None
;
self
.
keep_alive
.
idle
(
)
;
if
self
.
is_idle
(
)
{
self
.
reading
=
Reading
:
:
Init
;
self
.
writing
=
Writing
:
:
Init
;
if
!
T
:
:
should_read_first
(
)
{
self
.
notify_read
=
true
;
}
}
else
{
self
.
close
(
)
;
}
}
fn
is_idle
(
&
self
)
-
>
bool
{
if
let
KA
:
:
Idle
=
self
.
keep_alive
.
status
(
)
{
true
}
else
{
false
}
}
fn
is_read_closed
(
&
self
)
-
>
bool
{
match
self
.
reading
{
Reading
:
:
Closed
=
>
true
_
=
>
false
}
}
fn
is_write_closed
(
&
self
)
-
>
bool
{
match
self
.
writing
{
Writing
:
:
Closed
=
>
true
_
=
>
false
}
}
fn
prepare_upgrade
(
&
mut
self
)
-
>
:
:
upgrade
:
:
OnUpgrade
{
debug_assert
!
(
self
.
upgrade
.
is_none
(
)
)
;
let
(
tx
rx
)
=
:
:
upgrade
:
:
pending
(
)
;
self
.
upgrade
=
Some
(
tx
)
;
rx
}
}
#
[
cfg
(
test
)
]
mod
tests
{
#
[
cfg
(
feature
=
"
nightly
"
)
]
#
[
bench
]
fn
bench_read_head_short
(
b
:
&
mut
:
:
test
:
:
Bencher
)
{
use
super
:
:
*
;
let
s
=
b
"
GET
/
HTTP
/
1
.
1
\
r
\
nHost
:
localhost
:
8080
\
r
\
n
\
r
\
n
"
;
let
len
=
s
.
len
(
)
;
b
.
bytes
=
len
as
u64
;
let
mut
io
=
:
:
mock
:
:
AsyncIo
:
:
new_buf
(
Vec
:
:
new
(
)
0
)
;
io
.
panic
(
)
;
let
mut
conn
=
Conn
:
:
<
_
:
:
Chunk
:
:
proto
:
:
h1
:
:
ServerTransaction
>
:
:
new
(
io
)
;
*
conn
.
io
.
read_buf_mut
(
)
=
:
:
bytes
:
:
BytesMut
:
:
from
(
&
s
[
.
.
]
)
;
conn
.
state
.
cached_headers
=
Some
(
HeaderMap
:
:
with_capacity
(
2
)
)
;
b
.
iter
(
|
|
{
match
conn
.
read_head
(
)
.
unwrap
(
)
{
Async
:
:
Ready
(
Some
(
x
)
)
=
>
{
:
:
test
:
:
black_box
(
&
x
)
;
let
mut
headers
=
x
.
0
.
headers
;
headers
.
clear
(
)
;
conn
.
state
.
cached_headers
=
Some
(
headers
)
;
}
f
=
>
panic
!
(
"
expected
Ready
(
Some
(
.
.
)
)
:
{
:
?
}
"
f
)
}
conn
.
io
.
read_buf_mut
(
)
.
reserve
(
1
)
;
unsafe
{
conn
.
io
.
read_buf_mut
(
)
.
set_len
(
len
)
;
}
conn
.
state
.
reading
=
Reading
:
:
Init
;
}
)
;
}
}
