use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
futures
:
:
{
Future
IntoFuture
}
;
use
body
:
:
Payload
;
use
super
:
:
Service
;
pub
trait
MakeService
<
Ctx
>
{
type
ReqBody
:
Payload
;
type
ResBody
:
Payload
;
type
Error
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
;
type
Service
:
Service
<
ReqBody
=
Self
:
:
ReqBody
ResBody
=
Self
:
:
ResBody
Error
=
Self
:
:
Error
>
;
type
Future
:
Future
<
Item
=
Self
:
:
Service
Error
=
Self
:
:
MakeError
>
;
type
MakeError
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
;
fn
make_service
(
&
mut
self
ctx
:
Ctx
)
-
>
Self
:
:
Future
;
}
#
[
doc
(
hidden
)
]
pub
trait
MakeServiceRef
<
Ctx
>
:
self
:
:
sealed
:
:
Sealed
<
Ctx
>
{
type
ReqBody
:
Payload
;
type
ResBody
:
Payload
;
type
Error
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
;
type
Service
:
Service
<
ReqBody
=
Self
:
:
ReqBody
ResBody
=
Self
:
:
ResBody
Error
=
Self
:
:
Error
>
;
type
Future
:
Future
<
Item
=
Self
:
:
Service
>
;
type
__DontNameMe
:
self
:
:
sealed
:
:
CantImpl
;
fn
make_service_ref
(
&
mut
self
ctx
:
&
Ctx
)
-
>
Self
:
:
Future
;
}
impl
<
T
Ctx
E
ME
S
F
IB
OB
>
MakeServiceRef
<
Ctx
>
for
T
where
T
:
for
<
'
a
>
MakeService
<
&
'
a
Ctx
Error
=
E
MakeError
=
ME
Service
=
S
Future
=
F
ReqBody
=
IB
ResBody
=
OB
>
E
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
ME
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
S
:
Service
<
ReqBody
=
IB
ResBody
=
OB
Error
=
E
>
F
:
Future
<
Item
=
S
Error
=
ME
>
IB
:
Payload
OB
:
Payload
{
type
Error
=
E
;
type
Service
=
S
;
type
ReqBody
=
IB
;
type
ResBody
=
OB
;
type
Future
=
F
;
type
__DontNameMe
=
self
:
:
sealed
:
:
CantName
;
fn
make_service_ref
(
&
mut
self
ctx
:
&
Ctx
)
-
>
Self
:
:
Future
{
self
.
make_service
(
ctx
)
}
}
impl
<
T
Ctx
E
ME
S
F
IB
OB
>
self
:
:
sealed
:
:
Sealed
<
Ctx
>
for
T
where
T
:
for
<
'
a
>
MakeService
<
&
'
a
Ctx
Error
=
E
MakeError
=
ME
Service
=
S
Future
=
F
ReqBody
=
IB
ResBody
=
OB
>
E
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
ME
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
S
:
Service
<
ReqBody
=
IB
ResBody
=
OB
Error
=
E
>
F
:
Future
<
Item
=
S
Error
=
ME
>
IB
:
Payload
OB
:
Payload
{
}
pub
fn
make_service_fn
<
F
Ctx
Ret
>
(
f
:
F
)
-
>
MakeServiceFn
<
F
>
where
F
:
Fn
(
&
Ctx
)
-
>
Ret
Ret
:
IntoFuture
{
MakeServiceFn
{
f
}
}
pub
struct
MakeServiceFn
<
F
>
{
f
:
F
}
impl
<
'
c
F
Ctx
Ret
ReqBody
ResBody
>
MakeService
<
&
'
c
Ctx
>
for
MakeServiceFn
<
F
>
where
F
:
Fn
(
&
Ctx
)
-
>
Ret
Ret
:
IntoFuture
Ret
:
:
Item
:
Service
<
ReqBody
=
ReqBody
ResBody
=
ResBody
>
Ret
:
:
Error
:
Into
<
Box
<
StdError
+
Send
+
Sync
>
>
ReqBody
:
Payload
ResBody
:
Payload
{
type
ReqBody
=
ReqBody
;
type
ResBody
=
ResBody
;
type
Error
=
<
Ret
:
:
Item
as
Service
>
:
:
Error
;
type
Service
=
Ret
:
:
Item
;
type
Future
=
Ret
:
:
Future
;
type
MakeError
=
Ret
:
:
Error
;
fn
make_service
(
&
mut
self
ctx
:
&
'
c
Ctx
)
-
>
Self
:
:
Future
{
(
self
.
f
)
(
ctx
)
.
into_future
(
)
}
}
impl
<
F
>
fmt
:
:
Debug
for
MakeServiceFn
<
F
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
MakeServiceFn
"
)
.
finish
(
)
}
}
mod
sealed
{
pub
trait
Sealed
<
T
>
{
}
pub
trait
CantImpl
{
}
#
[
allow
(
missing_debug_implementations
)
]
pub
enum
CantName
{
}
impl
CantImpl
for
CantName
{
}
}
