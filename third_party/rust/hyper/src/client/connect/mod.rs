use
std
:
:
fmt
;
use
std
:
:
fmt
:
:
{
Debug
Formatter
}
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
Arc
;
use
:
:
http
:
:
Extensions
;
use
tokio
:
:
sync
:
:
watch
;
cfg_feature
!
{
#
!
[
feature
=
"
tcp
"
]
pub
use
self
:
:
http
:
:
{
HttpConnector
HttpInfo
}
;
pub
mod
dns
;
mod
http
;
}
cfg_feature
!
{
#
!
[
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
]
pub
use
self
:
:
sealed
:
:
Connect
;
}
pub
trait
Connection
{
fn
connected
(
&
self
)
-
>
Connected
;
}
#
[
derive
(
Debug
)
]
pub
struct
Connected
{
pub
(
super
)
alpn
:
Alpn
pub
(
super
)
is_proxied
:
bool
pub
(
super
)
extra
:
Option
<
Extra
>
pub
(
super
)
poisoned
:
PoisonPill
}
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
PoisonPill
{
poisoned
:
Arc
<
AtomicBool
>
}
impl
Debug
for
PoisonPill
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
PoisonPill
{
:
p
}
{
{
poisoned
:
{
}
}
}
"
self
.
poisoned
self
.
poisoned
.
load
(
Ordering
:
:
Relaxed
)
)
}
}
impl
PoisonPill
{
pub
(
crate
)
fn
healthy
(
)
-
>
Self
{
Self
{
poisoned
:
Arc
:
:
new
(
AtomicBool
:
:
new
(
false
)
)
}
}
pub
(
crate
)
fn
poison
(
&
self
)
{
self
.
poisoned
.
store
(
true
Ordering
:
:
Relaxed
)
}
pub
(
crate
)
fn
poisoned
(
&
self
)
-
>
bool
{
self
.
poisoned
.
load
(
Ordering
:
:
Relaxed
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
CaptureConnection
{
rx
:
watch
:
:
Receiver
<
Option
<
Connected
>
>
}
pub
fn
capture_connection
<
B
>
(
request
:
&
mut
crate
:
:
http
:
:
Request
<
B
>
)
-
>
CaptureConnection
{
let
(
tx
rx
)
=
CaptureConnection
:
:
new
(
)
;
request
.
extensions_mut
(
)
.
insert
(
tx
)
;
rx
}
#
[
derive
(
Clone
)
]
pub
(
crate
)
struct
CaptureConnectionExtension
{
tx
:
Arc
<
watch
:
:
Sender
<
Option
<
Connected
>
>
>
}
impl
CaptureConnectionExtension
{
pub
(
crate
)
fn
set
(
&
self
connected
:
&
Connected
)
{
self
.
tx
.
send_replace
(
Some
(
connected
.
clone
(
)
)
)
;
}
}
impl
CaptureConnection
{
pub
(
crate
)
fn
new
(
)
-
>
(
CaptureConnectionExtension
Self
)
{
let
(
tx
rx
)
=
watch
:
:
channel
(
None
)
;
(
CaptureConnectionExtension
{
tx
:
Arc
:
:
new
(
tx
)
}
CaptureConnection
{
rx
}
)
}
pub
fn
connection_metadata
(
&
self
)
-
>
impl
Deref
<
Target
=
Option
<
Connected
>
>
+
'
_
{
self
.
rx
.
borrow
(
)
}
pub
async
fn
wait_for_connection_metadata
(
&
mut
self
)
-
>
impl
Deref
<
Target
=
Option
<
Connected
>
>
+
'
_
{
if
self
.
rx
.
borrow
(
)
.
is_some
(
)
{
return
self
.
rx
.
borrow
(
)
;
}
let
_
=
self
.
rx
.
changed
(
)
.
await
;
self
.
rx
.
borrow
(
)
}
}
pub
(
super
)
struct
Extra
(
Box
<
dyn
ExtraInner
>
)
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
(
super
)
enum
Alpn
{
H2
None
}
impl
Connected
{
pub
fn
new
(
)
-
>
Connected
{
Connected
{
alpn
:
Alpn
:
:
None
is_proxied
:
false
extra
:
None
poisoned
:
PoisonPill
:
:
healthy
(
)
}
}
pub
fn
proxy
(
mut
self
is_proxied
:
bool
)
-
>
Connected
{
self
.
is_proxied
=
is_proxied
;
self
}
pub
fn
is_proxied
(
&
self
)
-
>
bool
{
self
.
is_proxied
}
pub
fn
extra
<
T
:
Clone
+
Send
+
Sync
+
'
static
>
(
mut
self
extra
:
T
)
-
>
Connected
{
if
let
Some
(
prev
)
=
self
.
extra
{
self
.
extra
=
Some
(
Extra
(
Box
:
:
new
(
ExtraChain
(
prev
.
0
extra
)
)
)
)
;
}
else
{
self
.
extra
=
Some
(
Extra
(
Box
:
:
new
(
ExtraEnvelope
(
extra
)
)
)
)
;
}
self
}
pub
fn
get_extras
(
&
self
extensions
:
&
mut
Extensions
)
{
if
let
Some
(
extra
)
=
&
self
.
extra
{
extra
.
set
(
extensions
)
;
}
}
pub
fn
negotiated_h2
(
mut
self
)
-
>
Connected
{
self
.
alpn
=
Alpn
:
:
H2
;
self
}
pub
fn
is_negotiated_h2
(
&
self
)
-
>
bool
{
self
.
alpn
=
=
Alpn
:
:
H2
}
pub
fn
poison
(
&
self
)
{
self
.
poisoned
.
poison
(
)
;
tracing
:
:
debug
!
(
poison_pill
=
?
self
.
poisoned
"
connection
was
poisoned
"
)
;
}
pub
(
super
)
fn
clone
(
&
self
)
-
>
Connected
{
Connected
{
alpn
:
self
.
alpn
.
clone
(
)
is_proxied
:
self
.
is_proxied
extra
:
self
.
extra
.
clone
(
)
poisoned
:
self
.
poisoned
.
clone
(
)
}
}
}
impl
Extra
{
pub
(
super
)
fn
set
(
&
self
res
:
&
mut
Extensions
)
{
self
.
0
.
set
(
res
)
;
}
}
impl
Clone
for
Extra
{
fn
clone
(
&
self
)
-
>
Extra
{
Extra
(
self
.
0
.
clone_box
(
)
)
}
}
impl
fmt
:
:
Debug
for
Extra
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Extra
"
)
.
finish
(
)
}
}
trait
ExtraInner
:
Send
+
Sync
{
fn
clone_box
(
&
self
)
-
>
Box
<
dyn
ExtraInner
>
;
fn
set
(
&
self
res
:
&
mut
Extensions
)
;
}
#
[
derive
(
Clone
)
]
struct
ExtraEnvelope
<
T
>
(
T
)
;
impl
<
T
>
ExtraInner
for
ExtraEnvelope
<
T
>
where
T
:
Clone
+
Send
+
Sync
+
'
static
{
fn
clone_box
(
&
self
)
-
>
Box
<
dyn
ExtraInner
>
{
Box
:
:
new
(
self
.
clone
(
)
)
}
fn
set
(
&
self
res
:
&
mut
Extensions
)
{
res
.
insert
(
self
.
0
.
clone
(
)
)
;
}
}
struct
ExtraChain
<
T
>
(
Box
<
dyn
ExtraInner
>
T
)
;
impl
<
T
:
Clone
>
Clone
for
ExtraChain
<
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
ExtraChain
(
self
.
0
.
clone_box
(
)
self
.
1
.
clone
(
)
)
}
}
impl
<
T
>
ExtraInner
for
ExtraChain
<
T
>
where
T
:
Clone
+
Send
+
Sync
+
'
static
{
fn
clone_box
(
&
self
)
-
>
Box
<
dyn
ExtraInner
>
{
Box
:
:
new
(
self
.
clone
(
)
)
}
fn
set
(
&
self
res
:
&
mut
Extensions
)
{
self
.
0
.
set
(
res
)
;
res
.
insert
(
self
.
1
.
clone
(
)
)
;
}
}
#
[
cfg
(
any
(
feature
=
"
http1
"
feature
=
"
http2
"
)
)
]
pub
(
super
)
mod
sealed
{
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
Unpin
;
use
:
:
http
:
:
Uri
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
super
:
:
Connection
;
pub
trait
Connect
:
Sealed
+
Sized
{
#
[
doc
(
hidden
)
]
type
_Svc
:
ConnectSvc
;
#
[
doc
(
hidden
)
]
fn
connect
(
self
internal_only
:
Internal
dst
:
Uri
)
-
>
<
Self
:
:
_Svc
as
ConnectSvc
>
:
:
Future
;
}
#
[
allow
(
unreachable_pub
)
]
pub
trait
ConnectSvc
{
type
Connection
:
AsyncRead
+
AsyncWrite
+
Connection
+
Unpin
+
Send
+
'
static
;
type
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
;
type
Future
:
Future
<
Output
=
Result
<
Self
:
:
Connection
Self
:
:
Error
>
>
+
Unpin
+
Send
+
'
static
;
fn
connect
(
self
internal_only
:
Internal
dst
:
Uri
)
-
>
Self
:
:
Future
;
}
impl
<
S
T
>
Connect
for
S
where
S
:
tower_service
:
:
Service
<
Uri
Response
=
T
>
+
Send
+
'
static
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
S
:
:
Future
:
Unpin
+
Send
T
:
AsyncRead
+
AsyncWrite
+
Connection
+
Unpin
+
Send
+
'
static
{
type
_Svc
=
S
;
fn
connect
(
self
_
:
Internal
dst
:
Uri
)
-
>
crate
:
:
service
:
:
Oneshot
<
S
Uri
>
{
crate
:
:
service
:
:
oneshot
(
self
dst
)
}
}
impl
<
S
T
>
ConnectSvc
for
S
where
S
:
tower_service
:
:
Service
<
Uri
Response
=
T
>
+
Send
+
'
static
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
S
:
:
Future
:
Unpin
+
Send
T
:
AsyncRead
+
AsyncWrite
+
Connection
+
Unpin
+
Send
+
'
static
{
type
Connection
=
T
;
type
Error
=
S
:
:
Error
;
type
Future
=
crate
:
:
service
:
:
Oneshot
<
S
Uri
>
;
fn
connect
(
self
_
:
Internal
dst
:
Uri
)
-
>
Self
:
:
Future
{
crate
:
:
service
:
:
oneshot
(
self
dst
)
}
}
impl
<
S
T
>
Sealed
for
S
where
S
:
tower_service
:
:
Service
<
Uri
Response
=
T
>
+
Send
S
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
S
:
:
Future
:
Unpin
+
Send
T
:
AsyncRead
+
AsyncWrite
+
Connection
+
Unpin
+
Send
+
'
static
{
}
pub
trait
Sealed
{
}
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Internal
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
Connected
;
use
crate
:
:
client
:
:
connect
:
:
CaptureConnection
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
struct
Ex1
(
usize
)
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
struct
Ex2
(
&
'
static
str
)
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
struct
Ex3
(
&
'
static
str
)
;
#
[
test
]
fn
test_connected_extra
(
)
{
let
c1
=
Connected
:
:
new
(
)
.
extra
(
Ex1
(
41
)
)
;
let
mut
ex
=
:
:
http
:
:
Extensions
:
:
new
(
)
;
assert_eq
!
(
ex
.
get
:
:
<
Ex1
>
(
)
None
)
;
c1
.
extra
.
as_ref
(
)
.
expect
(
"
c1
extra
"
)
.
set
(
&
mut
ex
)
;
assert_eq
!
(
ex
.
get
:
:
<
Ex1
>
(
)
Some
(
&
Ex1
(
41
)
)
)
;
}
#
[
test
]
fn
test_connected_extra_chain
(
)
{
let
c1
=
Connected
:
:
new
(
)
.
extra
(
Ex1
(
45
)
)
.
extra
(
Ex2
(
"
zoom
"
)
)
.
extra
(
Ex3
(
"
pew
pew
"
)
)
;
let
mut
ex1
=
:
:
http
:
:
Extensions
:
:
new
(
)
;
assert_eq
!
(
ex1
.
get
:
:
<
Ex1
>
(
)
None
)
;
assert_eq
!
(
ex1
.
get
:
:
<
Ex2
>
(
)
None
)
;
assert_eq
!
(
ex1
.
get
:
:
<
Ex3
>
(
)
None
)
;
c1
.
extra
.
as_ref
(
)
.
expect
(
"
c1
extra
"
)
.
set
(
&
mut
ex1
)
;
assert_eq
!
(
ex1
.
get
:
:
<
Ex1
>
(
)
Some
(
&
Ex1
(
45
)
)
)
;
assert_eq
!
(
ex1
.
get
:
:
<
Ex2
>
(
)
Some
(
&
Ex2
(
"
zoom
"
)
)
)
;
assert_eq
!
(
ex1
.
get
:
:
<
Ex3
>
(
)
Some
(
&
Ex3
(
"
pew
pew
"
)
)
)
;
let
c2
=
Connected
:
:
new
(
)
.
extra
(
Ex1
(
33
)
)
.
extra
(
Ex2
(
"
hiccup
"
)
)
.
extra
(
Ex1
(
99
)
)
;
let
mut
ex2
=
:
:
http
:
:
Extensions
:
:
new
(
)
;
c2
.
extra
.
as_ref
(
)
.
expect
(
"
c2
extra
"
)
.
set
(
&
mut
ex2
)
;
assert_eq
!
(
ex2
.
get
:
:
<
Ex1
>
(
)
Some
(
&
Ex1
(
99
)
)
)
;
assert_eq
!
(
ex2
.
get
:
:
<
Ex2
>
(
)
Some
(
&
Ex2
(
"
hiccup
"
)
)
)
;
}
#
[
test
]
fn
test_sync_capture_connection
(
)
{
let
(
tx
rx
)
=
CaptureConnection
:
:
new
(
)
;
assert
!
(
rx
.
connection_metadata
(
)
.
is_none
(
)
"
connection
has
not
been
set
"
)
;
tx
.
set
(
&
Connected
:
:
new
(
)
.
proxy
(
true
)
)
;
assert_eq
!
(
rx
.
connection_metadata
(
)
.
as_ref
(
)
.
expect
(
"
connected
should
be
set
"
)
.
is_proxied
(
)
true
)
;
assert_eq
!
(
rx
.
connection_metadata
(
)
.
as_ref
(
)
.
expect
(
"
connected
should
be
set
"
)
.
is_proxied
(
)
true
)
;
}
#
[
tokio
:
:
test
]
async
fn
async_capture_connection
(
)
{
let
(
tx
mut
rx
)
=
CaptureConnection
:
:
new
(
)
;
assert
!
(
rx
.
connection_metadata
(
)
.
is_none
(
)
"
connection
has
not
been
set
"
)
;
let
test_task
=
tokio
:
:
spawn
(
async
move
{
assert_eq
!
(
rx
.
wait_for_connection_metadata
(
)
.
await
.
as_ref
(
)
.
expect
(
"
connection
should
be
set
"
)
.
is_proxied
(
)
true
)
;
assert
!
(
rx
.
wait_for_connection_metadata
(
)
.
await
.
is_some
(
)
"
should
be
awaitable
multiple
times
"
)
;
assert_eq
!
(
rx
.
connection_metadata
(
)
.
is_some
(
)
true
)
;
}
)
;
assert_eq
!
(
test_task
.
is_finished
(
)
false
)
;
tx
.
set
(
&
Connected
:
:
new
(
)
.
proxy
(
true
)
)
;
assert
!
(
test_task
.
await
.
is_ok
(
)
)
;
}
#
[
tokio
:
:
test
]
async
fn
capture_connection_sender_side_dropped
(
)
{
let
(
tx
mut
rx
)
=
CaptureConnection
:
:
new
(
)
;
assert
!
(
rx
.
connection_metadata
(
)
.
is_none
(
)
"
connection
has
not
been
set
"
)
;
drop
(
tx
)
;
assert
!
(
rx
.
wait_for_connection_metadata
(
)
.
await
.
is_none
(
)
)
;
}
}
