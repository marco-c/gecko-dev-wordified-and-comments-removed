use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
std
:
:
future
:
:
Future
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
marker
:
:
Unpin
;
use
std
:
:
pin
:
:
Pin
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
task
:
:
{
Context
Poll
}
;
use
std
:
:
time
:
:
Duration
;
use
http
:
:
{
Request
Response
}
;
use
tokio
:
:
io
:
:
{
AsyncRead
AsyncWrite
}
;
use
super
:
:
super
:
:
dispatch
;
use
crate
:
:
body
:
:
{
Body
as
IncomingBody
HttpBody
as
Body
}
;
use
crate
:
:
common
:
:
exec
:
:
{
BoxSendFuture
Exec
}
;
use
crate
:
:
proto
;
use
crate
:
:
rt
:
:
Executor
;
pub
struct
SendRequest
<
B
>
{
dispatch
:
dispatch
:
:
UnboundedSender
<
Request
<
B
>
Response
<
IncomingBody
>
>
}
impl
<
B
>
Clone
for
SendRequest
<
B
>
{
fn
clone
(
&
self
)
-
>
SendRequest
<
B
>
{
SendRequest
{
dispatch
:
self
.
dispatch
.
clone
(
)
}
}
}
#
[
must_use
=
"
futures
do
nothing
unless
polled
"
]
pub
struct
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
+
Send
+
'
static
B
:
Body
+
'
static
{
inner
:
(
PhantomData
<
T
>
proto
:
:
h2
:
:
ClientTask
<
B
>
)
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Builder
{
pub
(
super
)
exec
:
Exec
h2_builder
:
proto
:
:
h2
:
:
client
:
:
Config
}
pub
async
fn
handshake
<
E
T
B
>
(
exec
:
E
io
:
T
)
-
>
crate
:
:
Result
<
(
SendRequest
<
B
>
Connection
<
T
B
>
)
>
where
E
:
Executor
<
BoxSendFuture
>
+
Send
+
Sync
+
'
static
T
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
B
:
Body
+
'
static
B
:
:
Data
:
Send
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
{
Builder
:
:
new
(
exec
)
.
handshake
(
io
)
.
await
}
impl
<
B
>
SendRequest
<
B
>
{
pub
fn
poll_ready
(
&
mut
self
_cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
crate
:
:
Result
<
(
)
>
>
{
if
self
.
is_closed
(
)
{
Poll
:
:
Ready
(
Err
(
crate
:
:
Error
:
:
new_closed
(
)
)
)
}
else
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
}
pub
async
fn
ready
(
&
mut
self
)
-
>
crate
:
:
Result
<
(
)
>
{
futures_util
:
:
future
:
:
poll_fn
(
|
cx
|
self
.
poll_ready
(
cx
)
)
.
await
}
pub
(
super
)
fn
is_closed
(
&
self
)
-
>
bool
{
self
.
dispatch
.
is_closed
(
)
}
}
impl
<
B
>
SendRequest
<
B
>
where
B
:
Body
+
'
static
{
pub
fn
send_request
(
&
mut
self
req
:
Request
<
B
>
)
-
>
impl
Future
<
Output
=
crate
:
:
Result
<
Response
<
IncomingBody
>
>
>
{
let
sent
=
self
.
dispatch
.
send
(
req
)
;
async
move
{
match
sent
{
Ok
(
rx
)
=
>
match
rx
.
await
{
Ok
(
Ok
(
resp
)
)
=
>
Ok
(
resp
)
Ok
(
Err
(
err
)
)
=
>
Err
(
err
)
Err
(
_canceled
)
=
>
panic
!
(
"
dispatch
dropped
without
returning
error
"
)
}
Err
(
_req
)
=
>
{
tracing
:
:
debug
!
(
"
connection
was
not
ready
"
)
;
Err
(
crate
:
:
Error
:
:
new_canceled
(
)
.
with
(
"
connection
was
not
ready
"
)
)
}
}
}
}
}
impl
<
B
>
fmt
:
:
Debug
for
SendRequest
<
B
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
SendRequest
"
)
.
finish
(
)
}
}
impl
<
T
B
>
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
B
:
Body
+
Unpin
+
Send
+
'
static
B
:
:
Data
:
Send
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
{
pub
fn
is_extended_connect_protocol_enabled
(
&
self
)
-
>
bool
{
self
.
inner
.
1
.
is_extended_connect_protocol_enabled
(
)
}
}
impl
<
T
B
>
fmt
:
:
Debug
for
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
+
fmt
:
:
Debug
+
Send
+
'
static
B
:
Body
+
'
static
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Connection
"
)
.
finish
(
)
}
}
impl
<
T
B
>
Future
for
Connection
<
T
B
>
where
T
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
B
:
Body
+
Send
+
'
static
B
:
:
Data
:
Send
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
{
type
Output
=
crate
:
:
Result
<
(
)
>
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
match
ready
!
(
Pin
:
:
new
(
&
mut
self
.
inner
.
1
)
.
poll
(
cx
)
)
?
{
proto
:
:
Dispatched
:
:
Shutdown
=
>
Poll
:
:
Ready
(
Ok
(
(
)
)
)
#
[
cfg
(
feature
=
"
http1
"
)
]
proto
:
:
Dispatched
:
:
Upgrade
(
_pending
)
=
>
unreachable
!
(
"
http2
cannot
upgrade
"
)
}
}
}
impl
Builder
{
#
[
inline
]
pub
fn
new
<
E
>
(
exec
:
E
)
-
>
Builder
where
E
:
Executor
<
BoxSendFuture
>
+
Send
+
Sync
+
'
static
{
use
std
:
:
sync
:
:
Arc
;
Builder
{
exec
:
Exec
:
:
Executor
(
Arc
:
:
new
(
exec
)
)
h2_builder
:
Default
:
:
default
(
)
}
}
pub
fn
executor
<
E
>
(
&
mut
self
exec
:
E
)
-
>
&
mut
Builder
where
E
:
Executor
<
BoxSendFuture
>
+
Send
+
Sync
+
'
static
{
self
.
exec
=
Exec
:
:
Executor
(
Arc
:
:
new
(
exec
)
)
;
self
}
pub
fn
initial_stream_window_size
(
&
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
if
let
Some
(
sz
)
=
sz
.
into
(
)
{
self
.
h2_builder
.
adaptive_window
=
false
;
self
.
h2_builder
.
initial_stream_window_size
=
sz
;
}
self
}
pub
fn
initial_connection_window_size
(
&
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
if
let
Some
(
sz
)
=
sz
.
into
(
)
{
self
.
h2_builder
.
adaptive_window
=
false
;
self
.
h2_builder
.
initial_conn_window_size
=
sz
;
}
self
}
pub
fn
adaptive_window
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
use
proto
:
:
h2
:
:
SPEC_WINDOW_SIZE
;
self
.
h2_builder
.
adaptive_window
=
enabled
;
if
enabled
{
self
.
h2_builder
.
initial_conn_window_size
=
SPEC_WINDOW_SIZE
;
self
.
h2_builder
.
initial_stream_window_size
=
SPEC_WINDOW_SIZE
;
}
self
}
pub
fn
max_frame_size
(
&
mut
self
sz
:
impl
Into
<
Option
<
u32
>
>
)
-
>
&
mut
Self
{
if
let
Some
(
sz
)
=
sz
.
into
(
)
{
self
.
h2_builder
.
max_frame_size
=
sz
;
}
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
pub
fn
keep_alive_interval
(
&
mut
self
interval
:
impl
Into
<
Option
<
Duration
>
>
)
-
>
&
mut
Self
{
self
.
h2_builder
.
keep_alive_interval
=
interval
.
into
(
)
;
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
pub
fn
keep_alive_timeout
(
&
mut
self
timeout
:
Duration
)
-
>
&
mut
Self
{
self
.
h2_builder
.
keep_alive_timeout
=
timeout
;
self
}
#
[
cfg
(
feature
=
"
runtime
"
)
]
pub
fn
keep_alive_while_idle
(
&
mut
self
enabled
:
bool
)
-
>
&
mut
Self
{
self
.
h2_builder
.
keep_alive_while_idle
=
enabled
;
self
}
pub
fn
max_concurrent_reset_streams
(
&
mut
self
max
:
usize
)
-
>
&
mut
Self
{
self
.
h2_builder
.
max_concurrent_reset_streams
=
Some
(
max
)
;
self
}
pub
fn
max_send_buf_size
(
&
mut
self
max
:
usize
)
-
>
&
mut
Self
{
assert
!
(
max
<
=
std
:
:
u32
:
:
MAX
as
usize
)
;
self
.
h2_builder
.
max_send_buffer_size
=
max
;
self
}
pub
fn
handshake
<
T
B
>
(
&
self
io
:
T
)
-
>
impl
Future
<
Output
=
crate
:
:
Result
<
(
SendRequest
<
B
>
Connection
<
T
B
>
)
>
>
where
T
:
AsyncRead
+
AsyncWrite
+
Unpin
+
Send
+
'
static
B
:
Body
+
'
static
B
:
:
Data
:
Send
B
:
:
Error
:
Into
<
Box
<
dyn
StdError
+
Send
+
Sync
>
>
{
let
opts
=
self
.
clone
(
)
;
async
move
{
tracing
:
:
trace
!
(
"
client
handshake
HTTP
/
1
"
)
;
let
(
tx
rx
)
=
dispatch
:
:
channel
(
)
;
let
h2
=
proto
:
:
h2
:
:
client
:
:
handshake
(
io
rx
&
opts
.
h2_builder
opts
.
exec
)
.
await
?
;
Ok
(
(
SendRequest
{
dispatch
:
tx
.
unbound
(
)
}
Connection
{
inner
:
(
PhantomData
h2
)
}
)
)
}
}
}
