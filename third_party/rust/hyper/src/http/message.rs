use
std
:
:
any
:
:
{
Any
TypeId
}
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
io
:
:
{
Read
Write
}
;
use
std
:
:
mem
;
use
std
:
:
io
;
use
std
:
:
time
:
:
Duration
;
use
typeable
:
:
Typeable
;
use
header
:
:
Headers
;
use
http
:
:
RawStatus
;
use
url
:
:
Url
;
use
method
;
use
version
;
use
traitobject
;
pub
trait
Protocol
{
fn
new_message
(
&
self
host
:
&
str
port
:
u16
scheme
:
&
str
)
-
>
:
:
Result
<
Box
<
HttpMessage
>
>
;
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
RequestHead
{
pub
headers
:
Headers
pub
method
:
method
:
:
Method
pub
url
:
Url
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ResponseHead
{
pub
headers
:
Headers
pub
raw_status
:
RawStatus
pub
version
:
version
:
:
HttpVersion
}
pub
trait
HttpMessage
:
Write
+
Read
+
Send
+
Any
+
Typeable
+
Debug
{
fn
set_outgoing
(
&
mut
self
head
:
RequestHead
)
-
>
:
:
Result
<
RequestHead
>
;
fn
get_incoming
(
&
mut
self
)
-
>
:
:
Result
<
ResponseHead
>
;
fn
set_read_timeout
(
&
self
dur
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
;
fn
set_write_timeout
(
&
self
dur
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
;
fn
close_connection
(
&
mut
self
)
-
>
:
:
Result
<
(
)
>
;
fn
has_body
(
&
self
)
-
>
bool
;
fn
set_proxied
(
&
mut
self
val
:
bool
)
{
warn
!
(
"
default
set_proxied
(
{
:
?
}
)
"
val
)
;
}
}
impl
HttpMessage
{
unsafe
fn
downcast_ref_unchecked
<
T
:
'
static
>
(
&
self
)
-
>
&
T
{
mem
:
:
transmute
(
traitobject
:
:
data
(
self
)
)
}
unsafe
fn
downcast_mut_unchecked
<
T
:
'
static
>
(
&
mut
self
)
-
>
&
mut
T
{
mem
:
:
transmute
(
traitobject
:
:
data_mut
(
self
)
)
}
unsafe
fn
downcast_unchecked
<
T
:
'
static
>
(
self
:
Box
<
HttpMessage
>
)
-
>
Box
<
T
>
{
let
raw
:
*
mut
HttpMessage
=
mem
:
:
transmute
(
self
)
;
mem
:
:
transmute
(
traitobject
:
:
data_mut
(
raw
)
)
}
}
impl
HttpMessage
{
#
[
inline
]
pub
fn
is
<
T
:
Any
>
(
&
self
)
-
>
bool
{
(
*
self
)
.
get_type
(
)
=
=
TypeId
:
:
of
:
:
<
T
>
(
)
}
#
[
inline
]
pub
fn
downcast_ref
<
T
:
Any
>
(
&
self
)
-
>
Option
<
&
T
>
{
if
self
.
is
:
:
<
T
>
(
)
{
Some
(
unsafe
{
self
.
downcast_ref_unchecked
(
)
}
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
downcast_mut
<
T
:
Any
>
(
&
mut
self
)
-
>
Option
<
&
mut
T
>
{
if
self
.
is
:
:
<
T
>
(
)
{
Some
(
unsafe
{
self
.
downcast_mut_unchecked
(
)
}
)
}
else
{
None
}
}
#
[
inline
]
pub
fn
downcast
<
T
:
Any
>
(
self
:
Box
<
HttpMessage
>
)
-
>
Result
<
Box
<
T
>
Box
<
HttpMessage
>
>
{
if
self
.
is
:
:
<
T
>
(
)
{
Ok
(
unsafe
{
self
.
downcast_unchecked
(
)
}
)
}
else
{
Err
(
self
)
}
}
}
