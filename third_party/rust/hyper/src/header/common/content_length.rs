use
std
:
:
fmt
;
use
header
:
:
{
HeaderFormat
Header
parsing
}
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
struct
ContentLength
(
pub
u64
)
;
impl
Header
for
ContentLength
{
#
[
inline
]
fn
header_name
(
)
-
>
&
'
static
str
{
"
Content
-
Length
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
:
:
Result
<
ContentLength
>
{
raw
.
iter
(
)
.
map
(
:
:
std
:
:
ops
:
:
Deref
:
:
deref
)
.
map
(
parsing
:
:
from_raw_str
)
.
fold
(
None
|
prev
x
|
{
match
(
prev
x
)
{
(
None
x
)
=
>
Some
(
x
)
(
e
Some
(
Err
(
_
)
)
_
)
=
>
e
(
Some
(
Ok
(
prev
)
)
Ok
(
x
)
)
if
prev
=
=
x
=
>
Some
(
Ok
(
prev
)
)
_
=
>
Some
(
Err
(
:
:
Error
:
:
Header
)
)
}
}
)
.
unwrap_or
(
Err
(
:
:
Error
:
:
Header
)
)
.
map
(
ContentLength
)
}
}
impl
HeaderFormat
for
ContentLength
{
#
[
inline
]
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
0
f
)
}
}
impl
fmt
:
:
Display
for
ContentLength
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
0
f
)
}
}
__hyper__deref
!
(
ContentLength
=
>
u64
)
;
__hyper__tm
!
(
ContentLength
tests
{
/
/
Testcase
from
RFC
test_header
!
(
test1
vec
!
[
b
"
3495
"
]
Some
(
HeaderField
(
3495
)
)
)
;
test_header
!
(
test_invalid
vec
!
[
b
"
34v95
"
]
None
)
;
/
/
Can
'
t
use
the
test_header
macro
because
"
5
5
"
gets
cleaned
to
"
5
"
.
#
[
test
]
fn
test_duplicates
(
)
{
let
parsed
=
HeaderField
:
:
parse_header
(
&
[
b
"
5
"
[
.
.
]
.
into
(
)
b
"
5
"
[
.
.
]
.
into
(
)
]
)
.
unwrap
(
)
;
assert_eq
!
(
parsed
HeaderField
(
5
)
)
;
assert_eq
!
(
format
!
(
"
{
}
"
parsed
)
"
5
"
)
;
}
test_header
!
(
test_duplicates_vary
vec
!
[
b
"
5
"
b
"
6
"
b
"
5
"
]
None
)
;
}
)
;
bench_header
!
(
bench
ContentLength
{
vec
!
[
b
"
42349984
"
.
to_vec
(
)
]
}
)
;
