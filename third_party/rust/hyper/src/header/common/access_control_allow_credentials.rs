use
std
:
:
fmt
:
:
{
self
Display
}
;
use
std
:
:
str
;
use
unicase
:
:
UniCase
;
use
header
:
:
{
Header
HeaderFormat
}
;
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
struct
AccessControlAllowCredentials
;
const
ACCESS_CONTROL_ALLOW_CREDENTIALS_TRUE
:
UniCase
<
&
'
static
str
>
=
UniCase
(
"
true
"
)
;
impl
Header
for
AccessControlAllowCredentials
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
Access
-
Control
-
Allow
-
Credentials
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
:
:
Result
<
AccessControlAllowCredentials
>
{
if
raw
.
len
(
)
=
=
1
{
let
text
=
unsafe
{
str
:
:
from_utf8_unchecked
(
raw
.
get_unchecked
(
0
)
)
}
;
if
UniCase
(
text
)
=
=
ACCESS_CONTROL_ALLOW_CREDENTIALS_TRUE
{
return
Ok
(
AccessControlAllowCredentials
)
;
}
}
Err
(
:
:
Error
:
:
Header
)
}
}
impl
HeaderFormat
for
AccessControlAllowCredentials
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
true
"
)
}
}
impl
Display
for
AccessControlAllowCredentials
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
self
.
fmt_header
(
f
)
}
}
#
[
cfg
(
test
)
]
mod
test_access_control_allow_credentials
{
use
std
:
:
str
;
use
header
:
:
*
;
use
super
:
:
AccessControlAllowCredentials
as
HeaderField
;
test_header
!
(
works
vec
!
[
b
"
true
"
]
Some
(
HeaderField
)
)
;
test_header
!
(
ignores_case
vec
!
[
b
"
True
"
]
)
;
test_header
!
(
not_bool
vec
!
[
b
"
false
"
]
None
)
;
test_header
!
(
only_single
vec
!
[
b
"
true
"
b
"
true
"
]
None
)
;
test_header
!
(
no_gibberish
vec
!
[
"
\
u
{
645
}
\
u
{
631
}
\
u
{
62d
}
\
u
{
628
}
\
u
{
627
}
"
.
as_bytes
(
)
]
None
)
;
}
