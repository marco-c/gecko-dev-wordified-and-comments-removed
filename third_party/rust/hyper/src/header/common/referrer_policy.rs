use
std
:
:
fmt
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
header
:
:
{
Header
HeaderFormat
parsing
}
;
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
enum
ReferrerPolicy
{
NoReferrer
NoReferrerWhenDowngrade
SameOrigin
Origin
OriginWhenCrossOrigin
UnsafeUrl
StrictOrigin
StrictOriginWhenCrossOrigin
}
impl
Header
for
ReferrerPolicy
{
fn
header_name
(
)
-
>
&
'
static
str
{
static
NAME
:
&
'
static
str
=
"
Referrer
-
Policy
"
;
NAME
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
:
:
Result
<
ReferrerPolicy
>
{
use
self
:
:
ReferrerPolicy
:
:
*
;
let
headers
:
Vec
<
String
>
=
try
!
(
parsing
:
:
from_comma_delimited
(
raw
)
)
;
for
h
in
headers
.
iter
(
)
.
rev
(
)
{
let
slice
=
&
h
.
to_ascii_lowercase
(
)
[
.
.
]
;
match
slice
{
"
no
-
referrer
"
|
"
never
"
=
>
return
Ok
(
NoReferrer
)
"
no
-
referrer
-
when
-
downgrade
"
|
"
default
"
=
>
return
Ok
(
NoReferrerWhenDowngrade
)
"
same
-
origin
"
=
>
return
Ok
(
SameOrigin
)
"
origin
"
=
>
return
Ok
(
Origin
)
"
origin
-
when
-
cross
-
origin
"
=
>
return
Ok
(
OriginWhenCrossOrigin
)
"
strict
-
origin
"
=
>
return
Ok
(
StrictOrigin
)
"
strict
-
origin
-
when
-
cross
-
origin
"
=
>
return
Ok
(
StrictOriginWhenCrossOrigin
)
"
unsafe
-
url
"
|
"
always
"
=
>
return
Ok
(
UnsafeUrl
)
_
=
>
continue
}
}
Err
(
:
:
Error
:
:
Header
)
}
}
impl
HeaderFormat
for
ReferrerPolicy
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
ReferrerPolicy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
use
self
:
:
ReferrerPolicy
:
:
*
;
f
.
write_str
(
match
*
self
{
NoReferrer
=
>
"
no
-
referrer
"
NoReferrerWhenDowngrade
=
>
"
no
-
referrer
-
when
-
downgrade
"
SameOrigin
=
>
"
same
-
origin
"
Origin
=
>
"
origin
"
OriginWhenCrossOrigin
=
>
"
origin
-
when
-
cross
-
origin
"
StrictOrigin
=
>
"
strict
-
origin
"
StrictOriginWhenCrossOrigin
=
>
"
strict
-
origin
-
when
-
cross
-
origin
"
UnsafeUrl
=
>
"
unsafe
-
url
"
}
)
}
}
#
[
test
]
fn
test_parse_header
(
)
{
let
a
:
ReferrerPolicy
=
Header
:
:
parse_header
(
[
b
"
origin
"
.
to_vec
(
)
]
.
as_ref
(
)
)
.
unwrap
(
)
;
let
b
=
ReferrerPolicy
:
:
Origin
;
assert_eq
!
(
a
b
)
;
let
e
:
:
:
Result
<
ReferrerPolicy
>
=
Header
:
:
parse_header
(
[
b
"
foobar
"
.
to_vec
(
)
]
.
as_ref
(
)
)
;
assert
!
(
e
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_rightmost_header
(
)
{
let
a
:
ReferrerPolicy
=
Header
:
:
parse_header
(
&
[
"
same
-
origin
origin
foobar
"
.
into
(
)
]
)
.
unwrap
(
)
;
let
b
=
ReferrerPolicy
:
:
Origin
;
assert_eq
!
(
a
b
)
;
}
