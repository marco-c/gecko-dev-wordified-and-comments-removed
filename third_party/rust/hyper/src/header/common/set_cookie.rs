use
header
:
:
{
Header
HeaderFormat
}
;
use
std
:
:
fmt
:
:
{
self
}
;
use
std
:
:
str
:
:
from_utf8
;
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
struct
SetCookie
(
pub
Vec
<
String
>
)
;
__hyper__deref
!
(
SetCookie
=
>
Vec
<
String
>
)
;
impl
Header
for
SetCookie
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
Set
-
Cookie
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
:
:
Result
<
SetCookie
>
{
let
mut
set_cookies
=
Vec
:
:
with_capacity
(
raw
.
len
(
)
)
;
for
set_cookies_raw
in
raw
{
if
let
Ok
(
s
)
=
from_utf8
(
&
set_cookies_raw
[
.
.
]
)
{
set_cookies
.
push
(
s
.
trim
(
)
.
to_owned
(
)
)
;
}
}
if
!
set_cookies
.
is_empty
(
)
{
Ok
(
SetCookie
(
set_cookies
)
)
}
else
{
Err
(
:
:
Error
:
:
Header
)
}
}
}
impl
HeaderFormat
for
SetCookie
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
if
self
.
0
.
len
(
)
=
=
1
{
write
!
(
f
"
{
}
"
&
self
.
0
[
0
]
)
}
else
{
panic
!
(
"
SetCookie
with
multiple
cookies
cannot
be
used
with
fmt_header
must
use
fmt_multi_header
"
)
;
}
}
fn
fmt_multi_header
(
&
self
f
:
&
mut
:
:
header
:
:
MultilineFormatter
)
-
>
fmt
:
:
Result
{
for
cookie
in
&
self
.
0
{
try
!
(
f
.
fmt_line
(
cookie
)
)
;
}
Ok
(
(
)
)
}
}
#
[
test
]
fn
test_set_cookie_fmt
(
)
{
use
:
:
header
:
:
Headers
;
let
mut
headers
=
Headers
:
:
new
(
)
;
headers
.
set
(
SetCookie
(
vec
!
[
"
foo
=
bar
"
.
into
(
)
"
baz
=
quux
"
.
into
(
)
]
)
)
;
assert_eq
!
(
headers
.
to_string
(
)
"
Set
-
Cookie
:
foo
=
bar
\
r
\
nSet
-
Cookie
:
baz
=
quux
\
r
\
n
"
)
;
}
