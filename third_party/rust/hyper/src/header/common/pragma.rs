use
std
:
:
fmt
;
use
std
:
:
ascii
:
:
AsciiExt
;
use
header
:
:
{
Header
HeaderFormat
parsing
}
;
#
[
derive
(
Clone
PartialEq
Debug
)
]
pub
enum
Pragma
{
NoCache
Ext
(
String
)
}
impl
Header
for
Pragma
{
fn
header_name
(
)
-
>
&
'
static
str
{
"
Pragma
"
}
fn
parse_header
(
raw
:
&
[
Vec
<
u8
>
]
)
-
>
:
:
Result
<
Pragma
>
{
parsing
:
:
from_one_raw_str
(
raw
)
.
and_then
(
|
s
:
String
|
{
let
slice
=
&
s
.
to_ascii_lowercase
(
)
[
.
.
]
;
match
slice
{
"
no
-
cache
"
=
>
Ok
(
Pragma
:
:
NoCache
)
_
=
>
Ok
(
Pragma
:
:
Ext
(
s
)
)
}
}
)
}
}
impl
HeaderFormat
for
Pragma
{
fn
fmt_header
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
Pragma
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
*
self
{
Pragma
:
:
NoCache
=
>
"
no
-
cache
"
Pragma
:
:
Ext
(
ref
string
)
=
>
&
string
[
.
.
]
}
)
}
}
#
[
test
]
fn
test_parse_header
(
)
{
let
a
:
Pragma
=
Header
:
:
parse_header
(
[
b
"
no
-
cache
"
.
to_vec
(
)
]
.
as_ref
(
)
)
.
unwrap
(
)
;
let
b
=
Pragma
:
:
NoCache
;
assert_eq
!
(
a
b
)
;
let
c
:
Pragma
=
Header
:
:
parse_header
(
[
b
"
FoObar
"
.
to_vec
(
)
]
.
as_ref
(
)
)
.
unwrap
(
)
;
let
d
=
Pragma
:
:
Ext
(
"
FoObar
"
.
to_owned
(
)
)
;
assert_eq
!
(
c
d
)
;
let
e
:
:
:
Result
<
Pragma
>
=
Header
:
:
parse_header
(
[
b
"
"
.
to_vec
(
)
]
.
as_ref
(
)
)
;
assert_eq
!
(
e
.
ok
(
)
None
)
;
}
