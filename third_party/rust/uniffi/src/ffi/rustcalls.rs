use
super
:
:
FfiDefault
;
use
crate
:
:
{
FfiConverter
RustBuffer
RustBufferFfiConverter
}
;
use
anyhow
:
:
Result
;
use
std
:
:
mem
:
:
MaybeUninit
;
use
std
:
:
panic
;
#
[
repr
(
C
)
]
pub
struct
RustCallStatus
{
pub
code
:
i8
pub
error_buf
:
MaybeUninit
<
RustBuffer
>
}
impl
Default
for
RustCallStatus
{
fn
default
(
)
-
>
Self
{
Self
{
code
:
0
error_buf
:
MaybeUninit
:
:
uninit
(
)
}
}
}
#
[
allow
(
dead_code
)
]
const
CALL_SUCCESS
:
i8
=
0
;
const
CALL_ERROR
:
i8
=
1
;
const
CALL_PANIC
:
i8
=
2
;
pub
trait
FfiError
:
RustBufferFfiConverter
{
}
fn
make_call
<
F
R
>
(
out_status
:
&
mut
RustCallStatus
callback
:
F
)
-
>
R
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
RustBuffer
>
R
:
FfiDefault
{
let
result
=
panic
:
:
catch_unwind
(
|
|
{
crate
:
:
panichook
:
:
ensure_setup
(
)
;
callback
(
)
}
)
;
match
result
{
Ok
(
Ok
(
v
)
)
=
>
v
Ok
(
Err
(
buf
)
)
=
>
{
out_status
.
code
=
CALL_ERROR
;
unsafe
{
out_status
.
error_buf
.
as_mut_ptr
(
)
.
write
(
buf
)
;
}
R
:
:
ffi_default
(
)
}
Err
(
cause
)
=
>
{
out_status
.
code
=
CALL_PANIC
;
let
message_result
=
panic
:
:
catch_unwind
(
panic
:
:
AssertUnwindSafe
(
move
|
|
{
let
message
=
if
let
Some
(
s
)
=
cause
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
(
*
s
)
.
to_string
(
)
}
else
if
let
Some
(
s
)
=
cause
.
downcast_ref
:
:
<
String
>
(
)
{
s
.
clone
(
)
}
else
{
"
Unknown
panic
!
"
.
to_string
(
)
}
;
log
:
:
error
!
(
"
Caught
a
panic
calling
rust
code
:
{
:
?
}
"
message
)
;
String
:
:
lower
(
message
)
}
)
)
;
if
let
Ok
(
buf
)
=
message_result
{
unsafe
{
out_status
.
error_buf
.
as_mut_ptr
(
)
.
write
(
buf
)
;
}
}
R
:
:
ffi_default
(
)
}
}
}
pub
fn
call_with_output
<
F
R
>
(
out_status
:
&
mut
RustCallStatus
callback
:
F
)
-
>
R
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
R
R
:
FfiDefault
{
make_call
(
out_status
|
|
Ok
(
callback
(
)
)
)
}
pub
fn
call_with_result
<
F
R
>
(
out_status
:
&
mut
RustCallStatus
callback
:
F
)
-
>
R
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
RustBuffer
>
R
:
FfiDefault
{
make_call
(
out_status
callback
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
{
FfiConverter
RustBufferFfiConverter
}
;
fn
function
(
a
:
u8
)
-
>
i8
{
match
a
{
0
=
>
100
x
=
>
panic
!
(
"
Unexpected
value
:
{
x
}
"
)
}
}
fn
create_call_status
(
)
-
>
RustCallStatus
{
RustCallStatus
{
code
:
0
error_buf
:
MaybeUninit
:
:
new
(
RustBuffer
:
:
new
(
)
)
}
}
#
[
test
]
fn
test_call_with_output
(
)
{
let
mut
status
=
create_call_status
(
)
;
let
return_value
=
call_with_output
(
&
mut
status
|
|
function
(
0
)
)
;
assert_eq
!
(
status
.
code
CALL_SUCCESS
)
;
assert_eq
!
(
return_value
100
)
;
call_with_output
(
&
mut
status
|
|
function
(
1
)
)
;
assert_eq
!
(
status
.
code
CALL_PANIC
)
;
unsafe
{
assert_eq
!
(
String
:
:
try_lift
(
status
.
error_buf
.
assume_init
(
)
)
.
unwrap
(
)
"
Unexpected
value
:
1
"
)
;
}
}
#
[
derive
(
Debug
PartialEq
)
]
struct
TestError
(
String
)
;
impl
RustBufferFfiConverter
for
TestError
{
type
RustType
=
Self
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
<
String
as
FfiConverter
>
:
:
write
(
obj
.
0
buf
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
>
{
String
:
:
try_read
(
buf
)
.
map
(
TestError
)
}
}
impl
FfiError
for
TestError
{
}
fn
function_with_result
(
a
:
u8
)
-
>
Result
<
i8
TestError
>
{
match
a
{
0
=
>
Ok
(
100
)
1
=
>
Err
(
TestError
(
"
Error
"
.
to_owned
(
)
)
)
x
=
>
panic
!
(
"
Unexpected
value
:
{
x
}
"
)
}
}
#
[
test
]
fn
test_call_with_result
(
)
{
let
mut
status
=
create_call_status
(
)
;
let
return_value
=
call_with_result
(
&
mut
status
|
|
{
function_with_result
(
0
)
.
map_err
(
TestError
:
:
lower
)
}
)
;
assert_eq
!
(
status
.
code
CALL_SUCCESS
)
;
assert_eq
!
(
return_value
100
)
;
call_with_result
(
&
mut
status
|
|
{
function_with_result
(
1
)
.
map_err
(
TestError
:
:
lower
)
}
)
;
assert_eq
!
(
status
.
code
CALL_ERROR
)
;
unsafe
{
assert_eq
!
(
TestError
:
:
try_lift
(
status
.
error_buf
.
assume_init
(
)
)
.
unwrap
(
)
TestError
(
"
Error
"
.
to_owned
(
)
)
)
;
}
let
mut
status
=
create_call_status
(
)
;
call_with_result
(
&
mut
status
|
|
{
function_with_result
(
2
)
.
map_err
(
TestError
:
:
lower
)
}
)
;
assert_eq
!
(
status
.
code
CALL_PANIC
)
;
unsafe
{
assert_eq
!
(
String
:
:
try_lift
(
status
.
error_buf
.
assume_init
(
)
)
.
unwrap
(
)
"
Unexpected
value
:
2
"
)
;
}
}
}
