use
crate
:
:
ffi
:
:
{
call_with_output
ForeignBytes
RustCallStatus
}
;
use
std
:
:
convert
:
:
{
TryFrom
TryInto
}
;
#
[
repr
(
C
)
]
pub
struct
RustBuffer
{
capacity
:
i32
len
:
i32
data
:
*
mut
u8
}
impl
RustBuffer
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
from_vec
(
Vec
:
:
new
(
)
)
}
pub
unsafe
fn
from_raw_parts
(
data
:
*
mut
u8
len
:
i32
capacity
:
i32
)
-
>
Self
{
Self
{
capacity
len
data
}
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
len
.
try_into
(
)
.
expect
(
"
buffer
length
negative
or
overflowed
"
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
=
=
0
}
pub
fn
new_with_size
(
size
:
usize
)
-
>
Self
{
assert
!
(
size
<
i32
:
:
MAX
as
usize
"
RustBuffer
requested
size
too
large
"
)
;
Self
:
:
from_vec
(
vec
!
[
0u8
;
size
]
)
}
pub
fn
from_vec
(
v
:
Vec
<
u8
>
)
-
>
Self
{
let
capacity
=
i32
:
:
try_from
(
v
.
capacity
(
)
)
.
expect
(
"
buffer
capacity
cannot
fit
into
a
i32
.
"
)
;
let
len
=
i32
:
:
try_from
(
v
.
len
(
)
)
.
expect
(
"
buffer
length
cannot
fit
into
a
i32
.
"
)
;
let
mut
v
=
std
:
:
mem
:
:
ManuallyDrop
:
:
new
(
v
)
;
unsafe
{
Self
:
:
from_raw_parts
(
v
.
as_mut_ptr
(
)
len
capacity
)
}
}
pub
fn
destroy_into_vec
(
self
)
-
>
Vec
<
u8
>
{
if
self
.
data
.
is_null
(
)
{
assert
!
(
self
.
capacity
=
=
0
"
null
RustBuffer
had
non
-
zero
capacity
"
)
;
assert
!
(
self
.
len
=
=
0
"
null
RustBuffer
had
non
-
zero
length
"
)
;
vec
!
[
]
}
else
{
let
capacity
:
usize
=
self
.
capacity
.
try_into
(
)
.
expect
(
"
buffer
capacity
negative
or
overflowed
"
)
;
let
len
:
usize
=
self
.
len
.
try_into
(
)
.
expect
(
"
buffer
length
negative
or
overflowed
"
)
;
assert
!
(
len
<
=
capacity
"
RustBuffer
length
exceeds
capacity
"
)
;
unsafe
{
Vec
:
:
from_raw_parts
(
self
.
data
len
capacity
)
}
}
}
pub
fn
destroy
(
self
)
{
drop
(
self
.
destroy_into_vec
(
)
)
;
}
}
impl
Default
for
RustBuffer
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
uniffi_rustbuffer_alloc
(
size
:
i32
call_status
:
&
mut
RustCallStatus
)
-
>
RustBuffer
{
call_with_output
(
call_status
|
|
{
RustBuffer
:
:
new_with_size
(
size
.
max
(
0
)
as
usize
)
}
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
uniffi_rustbuffer_from_bytes
(
bytes
:
ForeignBytes
call_status
:
&
mut
RustCallStatus
)
-
>
RustBuffer
{
call_with_output
(
call_status
|
|
{
let
bytes
=
bytes
.
as_slice
(
)
;
RustBuffer
:
:
from_vec
(
bytes
.
to_vec
(
)
)
}
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
uniffi_rustbuffer_free
(
buf
:
RustBuffer
call_status
:
&
mut
RustCallStatus
)
{
call_with_output
(
call_status
|
|
RustBuffer
:
:
destroy
(
buf
)
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
uniffi_rustbuffer_reserve
(
buf
:
RustBuffer
additional
:
i32
call_status
:
&
mut
RustCallStatus
)
-
>
RustBuffer
{
call_with_output
(
call_status
|
|
{
let
additional
:
usize
=
additional
.
try_into
(
)
.
expect
(
"
additional
buffer
length
negative
or
overflowed
"
)
;
let
mut
v
=
buf
.
destroy_into_vec
(
)
;
v
.
reserve
(
additional
)
;
RustBuffer
:
:
from_vec
(
v
)
}
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_rustbuffer_from_vec
(
)
{
let
rbuf
=
RustBuffer
:
:
from_vec
(
vec
!
[
1u8
2
3
]
)
;
assert_eq
!
(
rbuf
.
len
(
)
3
)
;
assert_eq
!
(
rbuf
.
destroy_into_vec
(
)
vec
!
[
1u8
2
3
]
)
;
}
#
[
test
]
fn
test_rustbuffer_empty
(
)
{
let
rbuf
=
RustBuffer
:
:
new
(
)
;
assert_eq
!
(
rbuf
.
len
(
)
0
)
;
assert
!
(
!
rbuf
.
data
.
is_null
(
)
)
;
assert_eq
!
(
rbuf
.
destroy_into_vec
(
)
Vec
:
:
<
u8
>
:
:
new
(
)
)
;
}
#
[
test
]
fn
test_rustbuffer_new_with_size
(
)
{
let
rbuf
=
RustBuffer
:
:
new_with_size
(
5
)
;
assert_eq
!
(
rbuf
.
destroy_into_vec
(
)
.
as_slice
(
)
&
[
0u8
0
0
0
0
]
)
;
let
rbuf
=
RustBuffer
:
:
new_with_size
(
0
)
;
assert
!
(
!
rbuf
.
data
.
is_null
(
)
)
;
assert_eq
!
(
rbuf
.
destroy_into_vec
(
)
.
as_slice
(
)
&
[
0u8
;
0
]
)
;
}
#
[
test
]
fn
test_rustbuffer_null_means_empty
(
)
{
let
rbuf
=
unsafe
{
RustBuffer
:
:
from_raw_parts
(
std
:
:
ptr
:
:
null_mut
(
)
0
0
)
}
;
assert_eq
!
(
rbuf
.
destroy_into_vec
(
)
.
as_slice
(
)
&
[
0u8
;
0
]
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_rustbuffer_null_must_have_no_capacity
(
)
{
let
rbuf
=
unsafe
{
RustBuffer
:
:
from_raw_parts
(
std
:
:
ptr
:
:
null_mut
(
)
0
1
)
}
;
rbuf
.
destroy_into_vec
(
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_rustbuffer_null_must_have_zero_length
(
)
{
let
rbuf
=
unsafe
{
RustBuffer
:
:
from_raw_parts
(
std
:
:
ptr
:
:
null_mut
(
)
12
0
)
}
;
rbuf
.
destroy_into_vec
(
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_rustbuffer_provided_capacity_must_be_non_negative
(
)
{
let
mut
v
=
vec
!
[
0u8
1
2
]
;
let
rbuf
=
unsafe
{
RustBuffer
:
:
from_raw_parts
(
v
.
as_mut_ptr
(
)
3
-
7
)
}
;
rbuf
.
destroy_into_vec
(
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_rustbuffer_provided_len_must_be_non_negative
(
)
{
let
mut
v
=
vec
!
[
0u8
1
2
]
;
let
rbuf
=
unsafe
{
RustBuffer
:
:
from_raw_parts
(
v
.
as_mut_ptr
(
)
-
1
3
)
}
;
rbuf
.
destroy_into_vec
(
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_rustbuffer_provided_len_must_not_exceed_capacity
(
)
{
let
mut
v
=
vec
!
[
0u8
1
2
]
;
let
rbuf
=
unsafe
{
RustBuffer
:
:
from_raw_parts
(
v
.
as_mut_ptr
(
)
3
2
)
}
;
rbuf
.
destroy_into_vec
(
)
;
}
}
