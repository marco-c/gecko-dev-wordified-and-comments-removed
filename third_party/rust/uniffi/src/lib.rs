use
anyhow
:
:
bail
;
use
bytes
:
:
buf
:
:
{
Buf
BufMut
}
;
use
paste
:
:
paste
;
use
std
:
:
{
collections
:
:
HashMap
convert
:
:
TryFrom
time
:
:
{
Duration
SystemTime
}
}
;
pub
use
anyhow
:
:
Result
;
pub
mod
ffi
;
pub
use
ffi
:
:
*
;
pub
mod
testing
;
pub
mod
deps
{
pub
use
anyhow
;
pub
use
bytes
;
pub
use
log
;
pub
use
static_assertions
;
}
mod
panichook
;
const
PACKAGE_VERSION
:
&
str
=
env
!
(
"
CARGO_PKG_VERSION
"
)
;
static_assertions
:
:
const_assert
!
(
PACKAGE_VERSION
.
as_bytes
(
)
.
len
(
)
<
10
)
;
#
[
allow
(
clippy
:
:
len_zero
)
]
pub
const
fn
check_compatible_version
(
bindgen_version
:
&
'
static
str
)
-
>
bool
{
let
package_version
=
PACKAGE_VERSION
.
as_bytes
(
)
;
let
bindgen_version
=
bindgen_version
.
as_bytes
(
)
;
package_version
.
len
(
)
=
=
bindgen_version
.
len
(
)
&
&
(
package_version
.
len
(
)
=
=
0
|
|
package_version
[
0
]
=
=
bindgen_version
[
0
]
)
&
&
(
package_version
.
len
(
)
<
=
1
|
|
package_version
[
1
]
=
=
bindgen_version
[
1
]
)
&
&
(
package_version
.
len
(
)
<
=
2
|
|
package_version
[
2
]
=
=
bindgen_version
[
2
]
)
&
&
(
package_version
.
len
(
)
<
=
3
|
|
package_version
[
3
]
=
=
bindgen_version
[
3
]
)
&
&
(
package_version
.
len
(
)
<
=
4
|
|
package_version
[
4
]
=
=
bindgen_version
[
4
]
)
&
&
(
package_version
.
len
(
)
<
=
5
|
|
package_version
[
5
]
=
=
bindgen_version
[
5
]
)
&
&
(
package_version
.
len
(
)
<
=
6
|
|
package_version
[
6
]
=
=
bindgen_version
[
6
]
)
&
&
(
package_version
.
len
(
)
<
=
7
|
|
package_version
[
7
]
=
=
bindgen_version
[
7
]
)
&
&
(
package_version
.
len
(
)
<
=
8
|
|
package_version
[
8
]
=
=
bindgen_version
[
8
]
)
&
&
(
package_version
.
len
(
)
<
=
9
|
|
package_version
[
9
]
=
=
bindgen_version
[
9
]
)
&
&
package_version
.
len
(
)
<
10
}
#
[
macro_export
]
macro_rules
!
assert_compatible_version
{
(
v
:
expr
(
)
?
)
=
>
{
uniffi
:
:
deps
:
:
static_assertions
:
:
const_assert
!
(
uniffi
:
:
check_compatible_version
(
v
)
)
;
}
;
}
pub
unsafe
trait
FfiConverter
:
Sized
{
type
RustType
;
type
FfiType
;
fn
lower
(
obj
:
Self
:
:
RustType
)
-
>
Self
:
:
FfiType
;
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
Self
:
:
RustType
>
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
;
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
;
}
pub
fn
check_remaining
(
buf
:
&
[
u8
]
num_bytes
:
usize
)
-
>
Result
<
(
)
>
{
if
buf
.
remaining
(
)
<
num_bytes
{
bail
!
(
format
!
(
"
not
enough
bytes
remaining
in
buffer
(
{
}
<
{
}
)
"
buf
.
remaining
(
)
num_bytes
)
)
;
}
Ok
(
(
)
)
}
macro_rules
!
impl_via_ffi_for_num_primitive
{
(
(
T
:
ty
)
+
)
=
>
{
impl_via_ffi_for_num_primitive
!
(
(
T
)
+
)
;
}
;
(
(
T
:
ty
)
*
)
=
>
{
(
paste
!
{
unsafe
impl
FfiConverter
for
T
{
type
RustType
=
Self
;
type
FfiType
=
Self
;
fn
lower
(
obj
:
Self
:
:
RustType
)
-
>
Self
:
:
FfiType
{
obj
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
Self
>
{
Ok
(
v
)
}
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
[
<
put_
T
>
]
(
obj
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
>
{
check_remaining
(
buf
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
)
?
;
Ok
(
buf
.
[
<
get_
T
>
]
(
)
)
}
}
}
)
*
}
;
}
impl_via_ffi_for_num_primitive
!
{
i8
u8
i16
u16
i32
u32
i64
u64
f32
f64
}
unsafe
impl
FfiConverter
for
bool
{
type
RustType
=
Self
;
type
FfiType
=
i8
;
fn
lower
(
obj
:
Self
:
:
RustType
)
-
>
Self
:
:
FfiType
{
if
obj
{
1
}
else
{
0
}
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
Self
:
:
RustType
>
{
Ok
(
match
v
{
0
=
>
false
1
=
>
true
_
=
>
bail
!
(
"
unexpected
byte
for
Boolean
"
)
}
)
}
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
put_i8
(
<
bool
as
FfiConverter
>
:
:
lower
(
obj
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
1
)
?
;
<
bool
as
FfiConverter
>
:
:
try_lift
(
buf
.
get_i8
(
)
)
}
}
unsafe
impl
FfiConverter
for
String
{
type
RustType
=
Self
;
type
FfiType
=
RustBuffer
;
fn
lower
(
obj
:
Self
:
:
RustType
)
-
>
Self
:
:
FfiType
{
RustBuffer
:
:
from_vec
(
obj
.
into_bytes
(
)
)
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
Self
:
:
RustType
>
{
let
v
=
v
.
destroy_into_vec
(
)
;
Ok
(
unsafe
{
String
:
:
from_utf8_unchecked
(
v
)
}
)
}
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
buf
.
put
(
obj
.
as_bytes
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
check_remaining
(
buf
len
)
?
;
let
bytes
=
&
buf
.
chunk
(
)
[
.
.
len
]
;
let
res
=
String
:
:
from_utf8
(
bytes
.
to_vec
(
)
)
?
;
buf
.
advance
(
len
)
;
Ok
(
res
)
}
}
pub
trait
RustBufferFfiConverter
:
Sized
{
type
RustType
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
;
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
;
}
unsafe
impl
<
T
:
RustBufferFfiConverter
>
FfiConverter
for
T
{
type
RustType
=
T
:
:
RustType
;
type
FfiType
=
RustBuffer
;
fn
lower
(
obj
:
Self
:
:
RustType
)
-
>
RustBuffer
{
let
mut
buf
=
Vec
:
:
new
(
)
;
<
T
as
RustBufferFfiConverter
>
:
:
write
(
obj
&
mut
buf
)
;
RustBuffer
:
:
from_vec
(
buf
)
}
fn
try_lift
(
v
:
RustBuffer
)
-
>
Result
<
Self
:
:
RustType
>
{
let
vec
=
v
.
destroy_into_vec
(
)
;
let
mut
buf
=
vec
.
as_slice
(
)
;
let
value
=
T
:
:
try_read
(
&
mut
buf
)
?
;
if
buf
.
remaining
(
)
!
=
0
{
bail
!
(
"
junk
data
left
in
buffer
after
lifting
"
)
}
Ok
(
value
)
}
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
T
:
:
write
(
obj
buf
)
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
T
:
:
try_read
(
buf
)
}
}
impl
RustBufferFfiConverter
for
SystemTime
{
type
RustType
=
Self
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
let
mut
sign
=
1
;
let
epoch_offset
=
obj
.
duration_since
(
SystemTime
:
:
UNIX_EPOCH
)
.
unwrap_or_else
(
|
error
|
{
sign
=
-
1
;
error
.
duration
(
)
}
)
;
let
seconds
=
sign
*
i64
:
:
try_from
(
epoch_offset
.
as_secs
(
)
)
.
expect
(
"
SystemTime
overflow
seconds
greater
than
i64
:
:
MAX
"
)
;
buf
.
put_i64
(
seconds
)
;
buf
.
put_u32
(
epoch_offset
.
subsec_nanos
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
12
)
?
;
let
seconds
=
buf
.
get_i64
(
)
;
let
nanos
=
buf
.
get_u32
(
)
;
let
epoch_offset
=
Duration
:
:
new
(
seconds
.
wrapping_abs
(
)
as
u64
nanos
)
;
if
seconds
>
=
0
{
Ok
(
SystemTime
:
:
UNIX_EPOCH
+
epoch_offset
)
}
else
{
Ok
(
SystemTime
:
:
UNIX_EPOCH
-
epoch_offset
)
}
}
}
impl
RustBufferFfiConverter
for
Duration
{
type
RustType
=
Self
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
buf
.
put_u64
(
obj
.
as_secs
(
)
)
;
buf
.
put_u32
(
obj
.
subsec_nanos
(
)
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
12
)
?
;
Ok
(
Duration
:
:
new
(
buf
.
get_u64
(
)
buf
.
get_u32
(
)
)
)
}
}
impl
<
T
:
FfiConverter
>
RustBufferFfiConverter
for
Option
<
T
>
{
type
RustType
=
Option
<
T
:
:
RustType
>
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
match
obj
{
None
=
>
buf
.
put_i8
(
0
)
Some
(
v
)
=
>
{
buf
.
put_i8
(
1
)
;
<
T
as
FfiConverter
>
:
:
write
(
v
buf
)
;
}
}
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
1
)
?
;
Ok
(
match
buf
.
get_i8
(
)
{
0
=
>
None
1
=
>
Some
(
<
T
as
FfiConverter
>
:
:
try_read
(
buf
)
?
)
_
=
>
bail
!
(
"
unexpected
tag
byte
for
Option
"
)
}
)
}
}
impl
<
T
:
FfiConverter
>
RustBufferFfiConverter
for
Vec
<
T
>
{
type
RustType
=
Vec
<
T
:
:
RustType
>
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
for
item
in
obj
{
<
T
as
FfiConverter
>
:
:
write
(
item
buf
)
;
}
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
let
mut
vec
=
Vec
:
:
with_capacity
(
len
)
;
for
_
in
0
.
.
len
{
vec
.
push
(
<
T
as
FfiConverter
>
:
:
try_read
(
buf
)
?
)
}
Ok
(
vec
)
}
}
impl
<
K
:
FfiConverter
V
:
FfiConverter
>
RustBufferFfiConverter
for
HashMap
<
K
V
>
where
K
:
:
RustType
:
std
:
:
hash
:
:
Hash
+
Eq
{
type
RustType
=
HashMap
<
K
:
:
RustType
V
:
:
RustType
>
;
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
let
len
=
i32
:
:
try_from
(
obj
.
len
(
)
)
.
unwrap
(
)
;
buf
.
put_i32
(
len
)
;
for
(
key
value
)
in
obj
{
<
K
as
FfiConverter
>
:
:
write
(
key
buf
)
;
<
V
as
FfiConverter
>
:
:
write
(
value
buf
)
;
}
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
check_remaining
(
buf
4
)
?
;
let
len
=
usize
:
:
try_from
(
buf
.
get_i32
(
)
)
?
;
let
mut
map
=
HashMap
:
:
with_capacity
(
len
)
;
for
_
in
0
.
.
len
{
let
key
=
<
K
as
FfiConverter
>
:
:
try_read
(
buf
)
?
;
let
value
=
<
V
as
FfiConverter
>
:
:
try_read
(
buf
)
?
;
map
.
insert
(
key
value
)
;
}
Ok
(
map
)
}
}
unsafe
impl
<
T
:
Sync
+
Send
>
FfiConverter
for
std
:
:
sync
:
:
Arc
<
T
>
{
type
RustType
=
Self
;
type
FfiType
=
*
const
std
:
:
os
:
:
raw
:
:
c_void
;
fn
lower
(
obj
:
Self
:
:
RustType
)
-
>
Self
:
:
FfiType
{
std
:
:
sync
:
:
Arc
:
:
into_raw
(
obj
)
as
Self
:
:
FfiType
}
fn
try_lift
(
v
:
Self
:
:
FfiType
)
-
>
Result
<
Self
:
:
RustType
>
{
let
v
=
v
as
*
const
T
;
let
foreign_arc
=
std
:
:
mem
:
:
ManuallyDrop
:
:
new
(
unsafe
{
Self
:
:
from_raw
(
v
)
}
)
;
Ok
(
std
:
:
sync
:
:
Arc
:
:
clone
(
&
*
foreign_arc
)
)
}
fn
write
(
obj
:
Self
:
:
RustType
buf
:
&
mut
Vec
<
u8
>
)
{
static_assertions
:
:
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
*
const
std
:
:
ffi
:
:
c_void
>
(
)
<
=
8
)
;
buf
.
put_u64
(
Self
:
:
lower
(
obj
)
as
u64
)
;
}
fn
try_read
(
buf
:
&
mut
&
[
u8
]
)
-
>
Result
<
Self
:
:
RustType
>
{
static_assertions
:
:
const_assert
!
(
std
:
:
mem
:
:
size_of
:
:
<
*
const
std
:
:
ffi
:
:
c_void
>
(
)
<
=
8
)
;
check_remaining
(
buf
8
)
?
;
Self
:
:
try_lift
(
buf
.
get_u64
(
)
as
Self
:
:
FfiType
)
}
}
pub
fn
lower_anyhow_error_or_panic
<
ErrConverter
>
(
err
:
anyhow
:
:
Error
arg_name
:
&
str
)
-
>
ErrConverter
:
:
FfiType
where
ErrConverter
:
FfiConverter
ErrConverter
:
:
RustType
:
'
static
+
Sync
+
Send
+
std
:
:
fmt
:
:
Debug
+
std
:
:
fmt
:
:
Display
{
match
err
.
downcast
:
:
<
ErrConverter
:
:
RustType
>
(
)
{
Ok
(
actual_error
)
=
>
ErrConverter
:
:
lower
(
actual_error
)
Err
(
ohno
)
=
>
panic
!
(
"
Failed
to
convert
arg
'
{
}
'
:
{
}
"
arg_name
ohno
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
trybuild_ui_tests
(
)
{
let
t
=
trybuild
:
:
TestCases
:
:
new
(
)
;
t
.
compile_fail
(
"
tests
/
ui
/
*
.
rs
"
)
;
}
#
[
test
]
fn
timestamp_roundtrip_post_epoch
(
)
{
let
expected
=
SystemTime
:
:
UNIX_EPOCH
+
Duration
:
:
new
(
100
100
)
;
let
result
=
SystemTime
:
:
try_lift
(
SystemTime
:
:
lower
(
expected
)
)
.
expect
(
"
Failed
to
lift
!
"
)
;
assert_eq
!
(
expected
result
)
}
#
[
test
]
fn
timestamp_roundtrip_pre_epoch
(
)
{
let
expected
=
SystemTime
:
:
UNIX_EPOCH
-
Duration
:
:
new
(
100
100
)
;
let
result
=
SystemTime
:
:
try_lift
(
SystemTime
:
:
lower
(
expected
)
)
.
expect
(
"
Failed
to
lift
!
"
)
;
assert_eq
!
(
expected
result
"
Expected
results
after
lowering
and
lifting
to
be
equal
"
)
}
}
