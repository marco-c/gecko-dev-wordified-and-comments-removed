use
std
:
:
{
marker
:
:
PhantomData
mem
:
:
MaybeUninit
sync
:
:
Once
}
;
use
crate
:
:
Error
;
pub
(
crate
)
struct
JobToken
(
PhantomData
<
(
)
>
)
;
impl
JobToken
{
fn
new
(
)
-
>
Self
{
Self
(
PhantomData
)
}
}
impl
Drop
for
JobToken
{
fn
drop
(
&
mut
self
)
{
match
JobTokenServer
:
:
new
(
)
{
JobTokenServer
:
:
Inherited
(
jobserver
)
=
>
jobserver
.
release_token_raw
(
)
JobTokenServer
:
:
InProcess
(
jobserver
)
=
>
jobserver
.
release_token_raw
(
)
}
}
}
enum
JobTokenServer
{
Inherited
(
inherited_jobserver
:
:
JobServer
)
InProcess
(
inprocess_jobserver
:
:
JobServer
)
}
impl
JobTokenServer
{
fn
new
(
)
-
>
&
'
static
Self
{
static
INIT
:
Once
=
Once
:
:
new
(
)
;
static
mut
JOBSERVER
:
MaybeUninit
<
JobTokenServer
>
=
MaybeUninit
:
:
uninit
(
)
;
unsafe
{
INIT
.
call_once
(
|
|
{
let
server
=
inherited_jobserver
:
:
JobServer
:
:
from_env
(
)
.
map
(
Self
:
:
Inherited
)
.
unwrap_or_else
(
|
|
Self
:
:
InProcess
(
inprocess_jobserver
:
:
JobServer
:
:
new
(
)
)
)
;
JOBSERVER
=
MaybeUninit
:
:
new
(
server
)
;
}
)
;
&
*
JOBSERVER
.
as_ptr
(
)
}
}
}
pub
(
crate
)
enum
ActiveJobTokenServer
{
Inherited
(
inherited_jobserver
:
:
ActiveJobServer
<
'
static
>
)
InProcess
(
&
'
static
inprocess_jobserver
:
:
JobServer
)
}
impl
ActiveJobTokenServer
{
pub
(
crate
)
fn
new
(
)
-
>
Result
<
Self
Error
>
{
match
JobTokenServer
:
:
new
(
)
{
JobTokenServer
:
:
Inherited
(
inherited_jobserver
)
=
>
{
inherited_jobserver
.
enter_active
(
)
.
map
(
Self
:
:
Inherited
)
}
JobTokenServer
:
:
InProcess
(
inprocess_jobserver
)
=
>
{
Ok
(
Self
:
:
InProcess
(
inprocess_jobserver
)
)
}
}
}
pub
(
crate
)
async
fn
acquire
(
&
self
)
-
>
Result
<
JobToken
Error
>
{
match
&
self
{
Self
:
:
Inherited
(
jobserver
)
=
>
jobserver
.
acquire
(
)
.
await
Self
:
:
InProcess
(
jobserver
)
=
>
Ok
(
jobserver
.
acquire
(
)
.
await
)
}
}
}
mod
inherited_jobserver
{
use
super
:
:
JobToken
;
use
crate
:
:
{
parallel
:
:
async_executor
:
:
YieldOnce
Error
ErrorKind
}
;
use
std
:
:
{
io
mem
sync
:
:
{
mpsc
Mutex
MutexGuard
PoisonError
}
}
;
pub
(
super
)
struct
JobServer
{
global_implicit_token
:
Mutex
<
bool
>
inner
:
jobserver
:
:
Client
}
impl
JobServer
{
pub
(
super
)
unsafe
fn
from_env
(
)
-
>
Option
<
Self
>
{
jobserver
:
:
Client
:
:
from_env
(
)
.
map
(
|
inner
|
Self
{
inner
global_implicit_token
:
Mutex
:
:
new
(
true
)
}
)
}
fn
get_global_implicit_token
(
&
self
)
-
>
MutexGuard
<
'
_
bool
>
{
self
.
global_implicit_token
.
lock
(
)
.
unwrap_or_else
(
PoisonError
:
:
into_inner
)
}
pub
(
super
)
fn
release_token_raw
(
&
self
)
{
let
mut
global_implicit_token
=
self
.
get_global_implicit_token
(
)
;
if
*
global_implicit_token
{
let
_
=
self
.
inner
.
release_raw
(
)
;
}
else
{
*
global_implicit_token
=
true
;
}
}
pub
(
super
)
fn
enter_active
(
&
self
)
-
>
Result
<
ActiveJobServer
<
'
_
>
Error
>
{
ActiveJobServer
:
:
new
(
self
)
}
}
pub
(
crate
)
struct
ActiveJobServer
<
'
a
>
{
jobserver
:
&
'
a
JobServer
helper_thread
:
jobserver
:
:
HelperThread
rx
:
mpsc
:
:
Receiver
<
io
:
:
Result
<
jobserver
:
:
Acquired
>
>
}
impl
<
'
a
>
ActiveJobServer
<
'
a
>
{
fn
new
(
jobserver
:
&
'
a
JobServer
)
-
>
Result
<
Self
Error
>
{
let
(
tx
rx
)
=
mpsc
:
:
channel
(
)
;
Ok
(
Self
{
rx
helper_thread
:
jobserver
.
inner
.
clone
(
)
.
into_helper_thread
(
move
|
res
|
{
let
_
=
tx
.
send
(
res
)
;
}
)
?
jobserver
}
)
}
pub
(
super
)
async
fn
acquire
(
&
self
)
-
>
Result
<
JobToken
Error
>
{
let
mut
has_requested_token
=
false
;
loop
{
if
mem
:
:
replace
(
&
mut
*
self
.
jobserver
.
get_global_implicit_token
(
)
false
)
{
break
Ok
(
JobToken
:
:
new
(
)
)
;
}
match
self
.
rx
.
try_recv
(
)
{
Ok
(
res
)
=
>
{
let
acquired
=
res
?
;
acquired
.
drop_without_releasing
(
)
;
break
Ok
(
JobToken
:
:
new
(
)
)
;
}
Err
(
mpsc
:
:
TryRecvError
:
:
Disconnected
)
=
>
{
break
Err
(
Error
:
:
new
(
ErrorKind
:
:
JobserverHelpThreadError
"
jobserver
help
thread
has
returned
before
ActiveJobServer
is
dropped
"
)
)
}
Err
(
mpsc
:
:
TryRecvError
:
:
Empty
)
=
>
{
if
!
has_requested_token
{
self
.
helper_thread
.
request_token
(
)
;
has_requested_token
=
true
;
}
YieldOnce
:
:
default
(
)
.
await
}
}
}
}
}
}
mod
inprocess_jobserver
{
use
super
:
:
JobToken
;
use
crate
:
:
parallel
:
:
async_executor
:
:
YieldOnce
;
use
std
:
:
{
env
:
:
var
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
:
:
{
AcqRel
Acquire
}
}
}
;
pub
(
crate
)
struct
JobServer
(
AtomicU32
)
;
impl
JobServer
{
pub
(
super
)
fn
new
(
)
-
>
Self
{
let
mut
parallelism
=
4
;
if
let
Ok
(
amt
)
=
var
(
"
NUM_JOBS
"
)
{
if
let
Ok
(
amt
)
=
amt
.
parse
(
)
{
parallelism
=
amt
;
}
}
Self
(
AtomicU32
:
:
new
(
parallelism
)
)
}
pub
(
super
)
async
fn
acquire
(
&
self
)
-
>
JobToken
{
loop
{
let
res
=
self
.
0
.
fetch_update
(
AcqRel
Acquire
|
tokens
|
tokens
.
checked_sub
(
1
)
)
;
if
res
.
is_ok
(
)
{
break
JobToken
:
:
new
(
)
;
}
YieldOnce
:
:
default
(
)
.
await
}
}
pub
(
super
)
fn
release_token_raw
(
&
self
)
{
self
.
0
.
fetch_add
(
1
AcqRel
)
;
}
}
}
