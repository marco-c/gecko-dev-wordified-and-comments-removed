use
std
:
:
{
collections
:
:
HashMap
ffi
:
:
OsString
path
:
:
{
Path
PathBuf
}
process
:
:
Command
sync
:
:
Mutex
}
;
use
crate
:
:
command_helpers
:
:
{
run_output
CargoOutput
}
;
#
[
derive
(
Clone
Debug
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
Tool
{
pub
(
crate
)
path
:
PathBuf
pub
(
crate
)
cc_wrapper_path
:
Option
<
PathBuf
>
pub
(
crate
)
cc_wrapper_args
:
Vec
<
OsString
>
pub
(
crate
)
args
:
Vec
<
OsString
>
pub
(
crate
)
env
:
Vec
<
(
OsString
OsString
)
>
pub
(
crate
)
family
:
ToolFamily
pub
(
crate
)
cuda
:
bool
pub
(
crate
)
removed_args
:
Vec
<
OsString
>
pub
(
crate
)
has_internal_target_arg
:
bool
}
impl
Tool
{
pub
(
crate
)
fn
new
(
path
:
PathBuf
cached_compiler_family
:
&
Mutex
<
HashMap
<
Box
<
Path
>
ToolFamily
>
>
cargo_output
:
&
CargoOutput
)
-
>
Self
{
Self
:
:
with_features
(
path
None
false
cached_compiler_family
cargo_output
)
}
pub
(
crate
)
fn
with_clang_driver
(
path
:
PathBuf
clang_driver
:
Option
<
&
str
>
cached_compiler_family
:
&
Mutex
<
HashMap
<
Box
<
Path
>
ToolFamily
>
>
cargo_output
:
&
CargoOutput
)
-
>
Self
{
Self
:
:
with_features
(
path
clang_driver
false
cached_compiler_family
cargo_output
)
}
pub
(
crate
)
fn
with_family
(
path
:
PathBuf
family
:
ToolFamily
)
-
>
Self
{
Self
{
path
cc_wrapper_path
:
None
cc_wrapper_args
:
Vec
:
:
new
(
)
args
:
Vec
:
:
new
(
)
env
:
Vec
:
:
new
(
)
family
cuda
:
false
removed_args
:
Vec
:
:
new
(
)
has_internal_target_arg
:
false
}
}
pub
(
crate
)
fn
with_features
(
path
:
PathBuf
clang_driver
:
Option
<
&
str
>
cuda
:
bool
cached_compiler_family
:
&
Mutex
<
HashMap
<
Box
<
Path
>
ToolFamily
>
>
cargo_output
:
&
CargoOutput
)
-
>
Self
{
fn
detect_family_inner
(
path
:
&
Path
cargo_output
:
&
CargoOutput
)
-
>
ToolFamily
{
let
mut
cmd
=
Command
:
:
new
(
path
)
;
cmd
.
arg
(
"
-
-
version
"
)
;
let
stdout
=
match
run_output
(
&
mut
cmd
&
path
.
to_string_lossy
(
)
cargo_output
)
.
ok
(
)
.
and_then
(
|
o
|
String
:
:
from_utf8
(
o
)
.
ok
(
)
)
{
Some
(
s
)
=
>
s
None
=
>
{
cargo_output
.
print_warning
(
&
format_args
!
(
"
Failed
to
run
:
{
:
?
}
"
cmd
)
)
;
return
ToolFamily
:
:
Gnu
;
}
}
;
if
stdout
.
contains
(
"
clang
"
)
{
ToolFamily
:
:
Clang
}
else
if
stdout
.
contains
(
"
GCC
"
)
{
ToolFamily
:
:
Gnu
}
else
{
cargo_output
.
print_warning
(
&
format_args
!
(
"
Compiler
version
doesn
'
t
include
clang
or
GCC
:
{
:
?
}
"
cmd
)
)
;
ToolFamily
:
:
Gnu
}
}
let
detect_family
=
|
path
:
&
Path
|
-
>
ToolFamily
{
if
let
Some
(
family
)
=
cached_compiler_family
.
lock
(
)
.
unwrap
(
)
.
get
(
path
)
{
return
*
family
;
}
let
family
=
detect_family_inner
(
path
cargo_output
)
;
cached_compiler_family
.
lock
(
)
.
unwrap
(
)
.
insert
(
path
.
into
(
)
family
)
;
family
}
;
let
family
=
if
let
Some
(
fname
)
=
path
.
file_name
(
)
.
and_then
(
|
p
|
p
.
to_str
(
)
)
{
if
fname
.
contains
(
"
clang
-
cl
"
)
{
ToolFamily
:
:
Msvc
{
clang_cl
:
true
}
}
else
if
fname
.
ends_with
(
"
cl
"
)
|
|
fname
=
=
"
cl
.
exe
"
{
ToolFamily
:
:
Msvc
{
clang_cl
:
false
}
}
else
if
fname
.
contains
(
"
clang
"
)
{
match
clang_driver
{
Some
(
"
cl
"
)
=
>
ToolFamily
:
:
Msvc
{
clang_cl
:
true
}
_
=
>
ToolFamily
:
:
Clang
}
}
else
{
detect_family
(
&
path
)
}
}
else
{
detect_family
(
&
path
)
}
;
Tool
{
path
cc_wrapper_path
:
None
cc_wrapper_args
:
Vec
:
:
new
(
)
args
:
Vec
:
:
new
(
)
env
:
Vec
:
:
new
(
)
family
cuda
removed_args
:
Vec
:
:
new
(
)
has_internal_target_arg
:
false
}
}
pub
(
crate
)
fn
remove_arg
(
&
mut
self
flag
:
OsString
)
{
self
.
removed_args
.
push
(
flag
)
;
}
pub
(
crate
)
fn
push_cc_arg
(
&
mut
self
flag
:
OsString
)
{
if
self
.
cuda
{
self
.
args
.
push
(
"
-
Xcompiler
"
.
into
(
)
)
;
}
self
.
args
.
push
(
flag
)
;
}
pub
(
crate
)
fn
is_duplicate_opt_arg
(
&
self
flag
:
&
OsString
)
-
>
bool
{
let
flag
=
flag
.
to_str
(
)
.
unwrap
(
)
;
let
mut
chars
=
flag
.
chars
(
)
;
if
self
.
is_like_msvc
(
)
{
if
chars
.
next
(
)
!
=
Some
(
'
/
'
)
{
return
false
;
}
}
else
if
self
.
is_like_gnu
(
)
|
|
self
.
is_like_clang
(
)
{
if
chars
.
next
(
)
!
=
Some
(
'
-
'
)
{
return
false
;
}
}
if
chars
.
next
(
)
=
=
Some
(
'
O
'
)
{
return
self
.
args
(
)
.
iter
(
)
.
any
(
|
a
|
a
.
to_str
(
)
.
unwrap_or
(
"
"
)
.
chars
(
)
.
nth
(
1
)
=
=
Some
(
'
O
'
)
)
;
}
false
}
pub
(
crate
)
fn
push_opt_unless_duplicate
(
&
mut
self
flag
:
OsString
)
{
if
self
.
is_duplicate_opt_arg
(
&
flag
)
{
println
!
(
"
Info
:
Ignoring
duplicate
arg
{
:
?
}
"
&
flag
)
;
}
else
{
self
.
push_cc_arg
(
flag
)
;
}
}
pub
fn
to_command
(
&
self
)
-
>
Command
{
let
mut
cmd
=
match
self
.
cc_wrapper_path
{
Some
(
ref
cc_wrapper_path
)
=
>
{
let
mut
cmd
=
Command
:
:
new
(
cc_wrapper_path
)
;
cmd
.
arg
(
&
self
.
path
)
;
cmd
}
None
=
>
Command
:
:
new
(
&
self
.
path
)
}
;
cmd
.
args
(
&
self
.
cc_wrapper_args
)
;
let
value
=
self
.
args
.
iter
(
)
.
filter
(
|
a
|
!
self
.
removed_args
.
contains
(
a
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
cmd
.
args
(
&
value
)
;
for
(
k
v
)
in
self
.
env
.
iter
(
)
{
cmd
.
env
(
k
v
)
;
}
cmd
}
pub
fn
path
(
&
self
)
-
>
&
Path
{
&
self
.
path
}
pub
fn
args
(
&
self
)
-
>
&
[
OsString
]
{
&
self
.
args
}
pub
fn
env
(
&
self
)
-
>
&
[
(
OsString
OsString
)
]
{
&
self
.
env
}
pub
fn
cc_env
(
&
self
)
-
>
OsString
{
match
self
.
cc_wrapper_path
{
Some
(
ref
cc_wrapper_path
)
=
>
{
let
mut
cc_env
=
cc_wrapper_path
.
as_os_str
(
)
.
to_owned
(
)
;
cc_env
.
push
(
"
"
)
;
cc_env
.
push
(
self
.
path
.
to_path_buf
(
)
.
into_os_string
(
)
)
;
for
arg
in
self
.
cc_wrapper_args
.
iter
(
)
{
cc_env
.
push
(
"
"
)
;
cc_env
.
push
(
arg
)
;
}
cc_env
}
None
=
>
OsString
:
:
from
(
"
"
)
}
}
pub
fn
cflags_env
(
&
self
)
-
>
OsString
{
let
mut
flags
=
OsString
:
:
new
(
)
;
for
(
i
arg
)
in
self
.
args
.
iter
(
)
.
enumerate
(
)
{
if
i
>
0
{
flags
.
push
(
"
"
)
;
}
flags
.
push
(
arg
)
;
}
flags
}
pub
fn
is_like_gnu
(
&
self
)
-
>
bool
{
self
.
family
=
=
ToolFamily
:
:
Gnu
}
pub
fn
is_like_clang
(
&
self
)
-
>
bool
{
self
.
family
=
=
ToolFamily
:
:
Clang
}
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
pub
(
crate
)
fn
is_xctoolchain_clang
(
&
self
)
-
>
bool
{
let
path
=
self
.
path
.
to_string_lossy
(
)
;
path
.
contains
(
"
.
xctoolchain
/
"
)
}
#
[
cfg
(
not
(
target_vendor
=
"
apple
"
)
)
]
pub
(
crate
)
fn
is_xctoolchain_clang
(
&
self
)
-
>
bool
{
false
}
pub
fn
is_like_msvc
(
&
self
)
-
>
bool
{
match
self
.
family
{
ToolFamily
:
:
Msvc
{
.
.
}
=
>
true
_
=
>
false
}
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
pub
enum
ToolFamily
{
Gnu
Clang
Msvc
{
clang_cl
:
bool
}
}
impl
ToolFamily
{
pub
(
crate
)
fn
add_debug_flags
(
&
self
cmd
:
&
mut
Tool
dwarf_version
:
Option
<
u32
>
)
{
match
*
self
{
ToolFamily
:
:
Msvc
{
.
.
}
=
>
{
cmd
.
push_cc_arg
(
"
-
Z7
"
.
into
(
)
)
;
}
ToolFamily
:
:
Gnu
|
ToolFamily
:
:
Clang
=
>
{
cmd
.
push_cc_arg
(
dwarf_version
.
map_or_else
(
|
|
"
-
g
"
.
into
(
)
|
v
|
format
!
(
"
-
gdwarf
-
{
}
"
v
)
)
.
into
(
)
)
;
}
}
}
pub
(
crate
)
fn
add_force_frame_pointer
(
&
self
cmd
:
&
mut
Tool
)
{
match
*
self
{
ToolFamily
:
:
Gnu
|
ToolFamily
:
:
Clang
=
>
{
cmd
.
push_cc_arg
(
"
-
fno
-
omit
-
frame
-
pointer
"
.
into
(
)
)
;
}
_
=
>
(
)
}
}
pub
(
crate
)
fn
warnings_flags
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
ToolFamily
:
:
Msvc
{
.
.
}
=
>
"
-
W4
"
ToolFamily
:
:
Gnu
|
ToolFamily
:
:
Clang
=
>
"
-
Wall
"
}
}
pub
(
crate
)
fn
extra_warnings_flags
(
&
self
)
-
>
Option
<
&
'
static
str
>
{
match
*
self
{
ToolFamily
:
:
Msvc
{
.
.
}
=
>
None
ToolFamily
:
:
Gnu
|
ToolFamily
:
:
Clang
=
>
Some
(
"
-
Wextra
"
)
}
}
pub
(
crate
)
fn
warnings_to_errors_flag
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
ToolFamily
:
:
Msvc
{
.
.
}
=
>
"
-
WX
"
ToolFamily
:
:
Gnu
|
ToolFamily
:
:
Clang
=
>
"
-
Werror
"
}
}
pub
(
crate
)
fn
verbose_stderr
(
&
self
)
-
>
bool
{
*
self
=
=
ToolFamily
:
:
Clang
}
}
