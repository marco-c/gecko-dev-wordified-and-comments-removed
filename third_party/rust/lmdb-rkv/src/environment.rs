use
libc
:
:
{
c_uint
size_t
}
;
use
std
:
:
{
fmt
ptr
result
mem
}
;
use
std
:
:
ffi
:
:
CString
;
#
[
cfg
(
unix
)
]
use
std
:
:
os
:
:
unix
:
:
ffi
:
:
OsStrExt
;
#
[
cfg
(
windows
)
]
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
sync
:
:
Mutex
;
use
ffi
;
use
byteorder
:
:
{
ByteOrder
NativeEndian
}
;
use
cursor
:
:
Cursor
;
use
error
:
:
{
Error
Result
lmdb_result
}
;
use
database
:
:
Database
;
use
transaction
:
:
{
RoTransaction
RwTransaction
Transaction
}
;
use
flags
:
:
{
DatabaseFlags
EnvironmentFlags
}
;
#
[
cfg
(
windows
)
]
trait
OsStrExtLmdb
{
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
;
}
#
[
cfg
(
windows
)
]
impl
OsStrExtLmdb
for
OsStr
{
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
to_str
(
)
.
unwrap
(
)
.
as_bytes
(
)
}
}
pub
struct
Environment
{
env
:
*
mut
ffi
:
:
MDB_env
dbi_open_mutex
:
Mutex
<
(
)
>
}
impl
Environment
{
pub
fn
new
(
)
-
>
EnvironmentBuilder
{
EnvironmentBuilder
{
flags
:
EnvironmentFlags
:
:
empty
(
)
max_readers
:
None
max_dbs
:
None
map_size
:
None
}
}
pub
fn
env
(
&
self
)
-
>
*
mut
ffi
:
:
MDB_env
{
self
.
env
}
pub
fn
open_db
<
'
env
>
(
&
'
env
self
name
:
Option
<
&
str
>
)
-
>
Result
<
Database
>
{
let
mutex
=
self
.
dbi_open_mutex
.
lock
(
)
;
let
txn
=
self
.
begin_ro_txn
(
)
?
;
let
db
=
unsafe
{
txn
.
open_db
(
name
)
?
}
;
txn
.
commit
(
)
?
;
drop
(
mutex
)
;
Ok
(
db
)
}
pub
fn
create_db
<
'
env
>
(
&
'
env
self
name
:
Option
<
&
str
>
flags
:
DatabaseFlags
)
-
>
Result
<
Database
>
{
let
mutex
=
self
.
dbi_open_mutex
.
lock
(
)
;
let
txn
=
self
.
begin_rw_txn
(
)
?
;
let
db
=
unsafe
{
txn
.
create_db
(
name
flags
)
?
}
;
txn
.
commit
(
)
?
;
drop
(
mutex
)
;
Ok
(
db
)
}
pub
fn
get_db_flags
<
'
env
>
(
&
'
env
self
db
:
Database
)
-
>
Result
<
DatabaseFlags
>
{
let
txn
=
self
.
begin_ro_txn
(
)
?
;
let
mut
flags
:
c_uint
=
0
;
unsafe
{
lmdb_result
(
ffi
:
:
mdb_dbi_flags
(
txn
.
txn
(
)
db
.
dbi
(
)
&
mut
flags
)
)
?
;
}
Ok
(
DatabaseFlags
:
:
from_bits
(
flags
)
.
unwrap
(
)
)
}
pub
fn
begin_ro_txn
<
'
env
>
(
&
'
env
self
)
-
>
Result
<
RoTransaction
<
'
env
>
>
{
RoTransaction
:
:
new
(
self
)
}
pub
fn
begin_rw_txn
<
'
env
>
(
&
'
env
self
)
-
>
Result
<
RwTransaction
<
'
env
>
>
{
RwTransaction
:
:
new
(
self
)
}
pub
fn
sync
(
&
self
force
:
bool
)
-
>
Result
<
(
)
>
{
unsafe
{
lmdb_result
(
ffi
:
:
mdb_env_sync
(
self
.
env
(
)
if
force
{
1
}
else
{
0
}
)
)
}
}
pub
unsafe
fn
close_db
(
&
mut
self
db
:
Database
)
{
ffi
:
:
mdb_dbi_close
(
self
.
env
db
.
dbi
(
)
)
;
}
pub
fn
stat
(
&
self
)
-
>
Result
<
Stat
>
{
unsafe
{
let
mut
stat
=
Stat
:
:
new
(
)
;
lmdb_try
!
(
ffi
:
:
mdb_env_stat
(
self
.
env
(
)
stat
.
mdb_stat
(
)
)
)
;
Ok
(
stat
)
}
}
pub
fn
info
(
&
self
)
-
>
Result
<
Info
>
{
unsafe
{
let
mut
info
=
Info
(
mem
:
:
zeroed
(
)
)
;
lmdb_try
!
(
ffi
:
:
mdb_env_info
(
self
.
env
(
)
&
mut
info
.
0
)
)
;
Ok
(
info
)
}
}
pub
fn
freelist
(
&
self
)
-
>
Result
<
size_t
>
{
let
mut
freelist
:
size_t
=
0
;
let
db
=
Database
:
:
freelist_db
(
)
;
let
txn
=
self
.
begin_ro_txn
(
)
?
;
let
mut
cursor
=
txn
.
open_ro_cursor
(
db
)
?
;
for
result
in
cursor
.
iter
(
)
{
let
(
_key
value
)
=
result
?
;
if
value
.
len
(
)
<
mem
:
:
size_of
:
:
<
size_t
>
(
)
{
return
Err
(
Error
:
:
Corrupted
)
;
}
let
s
=
&
value
[
.
.
mem
:
:
size_of
:
:
<
size_t
>
(
)
]
;
if
cfg
!
(
target_pointer_width
=
"
64
"
)
{
freelist
+
=
NativeEndian
:
:
read_u64
(
s
)
as
size_t
;
}
else
{
freelist
+
=
NativeEndian
:
:
read_u32
(
s
)
as
size_t
;
}
}
Ok
(
freelist
)
}
pub
fn
set_map_size
(
&
self
size
:
size_t
)
-
>
Result
<
(
)
>
{
unsafe
{
lmdb_result
(
ffi
:
:
mdb_env_set_mapsize
(
self
.
env
(
)
size
)
)
}
}
}
pub
struct
Stat
(
ffi
:
:
MDB_stat
)
;
impl
Stat
{
pub
(
crate
)
fn
new
(
)
-
>
Stat
{
unsafe
{
Stat
(
mem
:
:
zeroed
(
)
)
}
}
pub
(
crate
)
fn
mdb_stat
(
&
mut
self
)
-
>
*
mut
ffi
:
:
MDB_stat
{
&
mut
self
.
0
}
}
impl
Stat
{
#
[
inline
]
pub
fn
page_size
(
&
self
)
-
>
u32
{
self
.
0
.
ms_psize
}
#
[
inline
]
pub
fn
depth
(
&
self
)
-
>
u32
{
self
.
0
.
ms_depth
}
#
[
inline
]
pub
fn
branch_pages
(
&
self
)
-
>
usize
{
self
.
0
.
ms_branch_pages
}
#
[
inline
]
pub
fn
leaf_pages
(
&
self
)
-
>
usize
{
self
.
0
.
ms_leaf_pages
}
#
[
inline
]
pub
fn
overflow_pages
(
&
self
)
-
>
usize
{
self
.
0
.
ms_overflow_pages
}
#
[
inline
]
pub
fn
entries
(
&
self
)
-
>
usize
{
self
.
0
.
ms_entries
}
}
pub
struct
Info
(
ffi
:
:
MDB_envinfo
)
;
impl
Info
{
#
[
inline
]
pub
fn
map_size
(
&
self
)
-
>
usize
{
self
.
0
.
me_mapsize
}
#
[
inline
]
pub
fn
last_pgno
(
&
self
)
-
>
usize
{
self
.
0
.
me_last_pgno
}
#
[
inline
]
pub
fn
last_txnid
(
&
self
)
-
>
usize
{
self
.
0
.
me_last_txnid
}
#
[
inline
]
pub
fn
max_readers
(
&
self
)
-
>
u32
{
self
.
0
.
me_maxreaders
}
#
[
inline
]
pub
fn
num_readers
(
&
self
)
-
>
u32
{
self
.
0
.
me_numreaders
}
}
unsafe
impl
Send
for
Environment
{
}
unsafe
impl
Sync
for
Environment
{
}
impl
fmt
:
:
Debug
for
Environment
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
result
:
:
Result
<
(
)
fmt
:
:
Error
>
{
f
.
debug_struct
(
"
Environment
"
)
.
finish
(
)
}
}
impl
Drop
for
Environment
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ffi
:
:
mdb_env_close
(
self
.
env
)
}
}
}
#
[
derive
(
Debug
PartialEq
Eq
Copy
Clone
)
]
pub
struct
EnvironmentBuilder
{
flags
:
EnvironmentFlags
max_readers
:
Option
<
c_uint
>
max_dbs
:
Option
<
c_uint
>
map_size
:
Option
<
size_t
>
}
impl
EnvironmentBuilder
{
pub
fn
open
(
&
self
path
:
&
Path
)
-
>
Result
<
Environment
>
{
self
.
open_with_permissions
(
path
0o644
)
}
pub
fn
open_with_permissions
(
&
self
path
:
&
Path
mode
:
ffi
:
:
mode_t
)
-
>
Result
<
Environment
>
{
let
mut
env
:
*
mut
ffi
:
:
MDB_env
=
ptr
:
:
null_mut
(
)
;
unsafe
{
lmdb_try
!
(
ffi
:
:
mdb_env_create
(
&
mut
env
)
)
;
if
let
Some
(
max_readers
)
=
self
.
max_readers
{
lmdb_try_with_cleanup
!
(
ffi
:
:
mdb_env_set_maxreaders
(
env
max_readers
)
ffi
:
:
mdb_env_close
(
env
)
)
}
if
let
Some
(
max_dbs
)
=
self
.
max_dbs
{
lmdb_try_with_cleanup
!
(
ffi
:
:
mdb_env_set_maxdbs
(
env
max_dbs
)
ffi
:
:
mdb_env_close
(
env
)
)
}
if
let
Some
(
map_size
)
=
self
.
map_size
{
lmdb_try_with_cleanup
!
(
ffi
:
:
mdb_env_set_mapsize
(
env
map_size
)
ffi
:
:
mdb_env_close
(
env
)
)
}
let
path
=
match
CString
:
:
new
(
path
.
as_os_str
(
)
.
as_bytes
(
)
)
{
Ok
(
path
)
=
>
path
Err
(
.
.
)
=
>
return
Err
(
:
:
Error
:
:
Invalid
)
}
;
lmdb_try_with_cleanup
!
(
ffi
:
:
mdb_env_open
(
env
path
.
as_ptr
(
)
self
.
flags
.
bits
(
)
mode
)
ffi
:
:
mdb_env_close
(
env
)
)
;
}
Ok
(
Environment
{
env
:
env
dbi_open_mutex
:
Mutex
:
:
new
(
(
)
)
}
)
}
pub
fn
set_flags
(
&
mut
self
flags
:
EnvironmentFlags
)
-
>
&
mut
EnvironmentBuilder
{
self
.
flags
=
flags
;
self
}
pub
fn
set_max_readers
(
&
mut
self
max_readers
:
c_uint
)
-
>
&
mut
EnvironmentBuilder
{
self
.
max_readers
=
Some
(
max_readers
)
;
self
}
pub
fn
set_max_dbs
(
&
mut
self
max_readers
:
c_uint
)
-
>
&
mut
EnvironmentBuilder
{
self
.
max_dbs
=
Some
(
max_readers
)
;
self
}
pub
fn
set_map_size
(
&
mut
self
map_size
:
size_t
)
-
>
&
mut
EnvironmentBuilder
{
self
.
map_size
=
Some
(
map_size
)
;
self
}
}
#
[
cfg
(
test
)
]
mod
test
{
extern
crate
byteorder
;
use
tempdir
:
:
TempDir
;
use
self
:
:
byteorder
:
:
{
ByteOrder
LittleEndian
}
;
use
flags
:
:
*
;
use
super
:
:
*
;
#
[
test
]
fn
test_open
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
assert
!
(
Environment
:
:
new
(
)
.
set_flags
(
EnvironmentFlags
:
:
READ_ONLY
)
.
open
(
dir
.
path
(
)
)
.
is_err
(
)
)
;
assert
!
(
Environment
:
:
new
(
)
.
open
(
dir
.
path
(
)
)
.
is_ok
(
)
)
;
assert
!
(
Environment
:
:
new
(
)
.
set_flags
(
EnvironmentFlags
:
:
READ_ONLY
)
.
open
(
dir
.
path
(
)
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
test_begin_txn
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
{
let
env
=
Environment
:
:
new
(
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
assert
!
(
env
.
begin_rw_txn
(
)
.
is_ok
(
)
)
;
assert
!
(
env
.
begin_ro_txn
(
)
.
is_ok
(
)
)
;
}
{
let
env
=
Environment
:
:
new
(
)
.
set_flags
(
EnvironmentFlags
:
:
READ_ONLY
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
assert
!
(
env
.
begin_rw_txn
(
)
.
is_err
(
)
)
;
assert
!
(
env
.
begin_ro_txn
(
)
.
is_ok
(
)
)
;
}
}
#
[
test
]
fn
test_open_db
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
env
=
Environment
:
:
new
(
)
.
set_max_dbs
(
1
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
assert
!
(
env
.
open_db
(
None
)
.
is_ok
(
)
)
;
assert
!
(
env
.
open_db
(
Some
(
"
testdb
"
)
)
.
is_err
(
)
)
;
}
#
[
test
]
fn
test_create_db
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
env
=
Environment
:
:
new
(
)
.
set_max_dbs
(
11
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
assert
!
(
env
.
open_db
(
Some
(
"
testdb
"
)
)
.
is_err
(
)
)
;
assert
!
(
env
.
create_db
(
Some
(
"
testdb
"
)
DatabaseFlags
:
:
empty
(
)
)
.
is_ok
(
)
)
;
assert
!
(
env
.
open_db
(
Some
(
"
testdb
"
)
)
.
is_ok
(
)
)
}
#
[
test
]
fn
test_close_database
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
mut
env
=
Environment
:
:
new
(
)
.
set_max_dbs
(
10
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
let
db
=
env
.
create_db
(
Some
(
"
db
"
)
DatabaseFlags
:
:
empty
(
)
)
.
unwrap
(
)
;
unsafe
{
env
.
close_db
(
db
)
;
}
assert
!
(
env
.
open_db
(
Some
(
"
db
"
)
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
test_sync
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
{
let
env
=
Environment
:
:
new
(
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
assert
!
(
env
.
sync
(
true
)
.
is_ok
(
)
)
;
}
{
let
env
=
Environment
:
:
new
(
)
.
set_flags
(
EnvironmentFlags
:
:
READ_ONLY
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
assert
!
(
env
.
sync
(
true
)
.
is_err
(
)
)
;
}
}
#
[
test
]
fn
test_stat
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
env
=
Environment
:
:
new
(
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
let
stat
=
env
.
stat
(
)
.
unwrap
(
)
;
assert_eq
!
(
stat
.
page_size
(
)
4096
)
;
assert_eq
!
(
stat
.
depth
(
)
0
)
;
assert_eq
!
(
stat
.
branch_pages
(
)
0
)
;
assert_eq
!
(
stat
.
leaf_pages
(
)
0
)
;
assert_eq
!
(
stat
.
overflow_pages
(
)
0
)
;
assert_eq
!
(
stat
.
entries
(
)
0
)
;
let
db
=
env
.
open_db
(
None
)
.
unwrap
(
)
;
for
i
in
0
.
.
64
{
let
mut
value
=
[
0u8
;
8
]
;
LittleEndian
:
:
write_u64
(
&
mut
value
i
)
;
let
mut
tx
=
env
.
begin_rw_txn
(
)
.
expect
(
"
begin_rw_txn
"
)
;
tx
.
put
(
db
&
value
&
value
WriteFlags
:
:
default
(
)
)
.
expect
(
"
tx
.
put
"
)
;
tx
.
commit
(
)
.
expect
(
"
tx
.
commit
"
)
}
let
stat
=
env
.
stat
(
)
.
unwrap
(
)
;
assert_eq
!
(
stat
.
page_size
(
)
4096
)
;
assert_eq
!
(
stat
.
depth
(
)
1
)
;
assert_eq
!
(
stat
.
branch_pages
(
)
0
)
;
assert_eq
!
(
stat
.
leaf_pages
(
)
1
)
;
assert_eq
!
(
stat
.
overflow_pages
(
)
0
)
;
assert_eq
!
(
stat
.
entries
(
)
64
)
;
}
#
[
test
]
fn
test_info
(
)
{
let
map_size
=
1024
*
1024
;
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
env
=
Environment
:
:
new
(
)
.
set_map_size
(
map_size
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
let
info
=
env
.
info
(
)
.
unwrap
(
)
;
assert_eq
!
(
info
.
map_size
(
)
map_size
)
;
assert_eq
!
(
info
.
last_pgno
(
)
1
)
;
assert_eq
!
(
info
.
last_txnid
(
)
0
)
;
assert_eq
!
(
info
.
max_readers
(
)
126
)
;
assert_eq
!
(
info
.
num_readers
(
)
0
)
;
}
#
[
test
]
fn
test_freelist
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
env
=
Environment
:
:
new
(
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
let
db
=
env
.
open_db
(
None
)
.
unwrap
(
)
;
let
mut
freelist
=
env
.
freelist
(
)
.
unwrap
(
)
;
assert_eq
!
(
freelist
0
)
;
for
i
in
0
.
.
64
{
let
mut
value
=
[
0u8
;
8
]
;
LittleEndian
:
:
write_u64
(
&
mut
value
i
)
;
let
mut
tx
=
env
.
begin_rw_txn
(
)
.
expect
(
"
begin_rw_txn
"
)
;
tx
.
put
(
db
&
value
&
value
WriteFlags
:
:
default
(
)
)
.
expect
(
"
tx
.
put
"
)
;
tx
.
commit
(
)
.
expect
(
"
tx
.
commit
"
)
}
let
mut
tx
=
env
.
begin_rw_txn
(
)
.
expect
(
"
begin_rw_txn
"
)
;
tx
.
clear_db
(
db
)
.
expect
(
"
clear
"
)
;
tx
.
commit
(
)
.
expect
(
"
tx
.
commit
"
)
;
freelist
=
env
.
freelist
(
)
.
unwrap
(
)
;
assert
!
(
freelist
>
0
)
;
}
#
[
test
]
fn
test_set_map_size
(
)
{
let
dir
=
TempDir
:
:
new
(
"
test
"
)
.
unwrap
(
)
;
let
env
=
Environment
:
:
new
(
)
.
open
(
dir
.
path
(
)
)
.
unwrap
(
)
;
let
mut
info
=
env
.
info
(
)
.
unwrap
(
)
;
let
default_size
=
info
.
map_size
(
)
;
env
.
set_map_size
(
0
)
.
unwrap
(
)
;
info
=
env
.
info
(
)
.
unwrap
(
)
;
assert_eq
!
(
info
.
map_size
(
)
default_size
)
;
env
.
set_map_size
(
2
*
default_size
)
.
unwrap
(
)
;
info
=
env
.
info
(
)
.
unwrap
(
)
;
assert_eq
!
(
info
.
map_size
(
)
2
*
default_size
)
;
env
.
set_map_size
(
4
*
default_size
)
.
unwrap
(
)
;
info
=
env
.
info
(
)
.
unwrap
(
)
;
assert_eq
!
(
info
.
map_size
(
)
4
*
default_size
)
;
env
.
set_map_size
(
2
*
default_size
)
.
unwrap
(
)
;
info
=
env
.
info
(
)
.
unwrap
(
)
;
assert_eq
!
(
info
.
map_size
(
)
2
*
default_size
)
;
}
}
