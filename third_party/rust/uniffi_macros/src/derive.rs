use
crate
:
:
util
:
:
kw
;
use
proc_macro2
:
:
{
Ident
Span
TokenStream
}
;
use
quote
:
:
{
quote
ToTokens
}
;
use
syn
:
:
{
parse
:
:
{
Parse
ParseStream
}
DeriveInput
}
;
pub
fn
expand_derive
(
kind
:
DeriveKind
input
:
DeriveInput
options
:
DeriveOptions
)
-
>
syn
:
:
Result
<
TokenStream
>
{
match
kind
{
DeriveKind
:
:
Record
(
_
)
=
>
crate
:
:
record
:
:
expand_record
(
input
options
)
DeriveKind
:
:
Object
(
_
)
=
>
crate
:
:
object
:
:
expand_object
(
input
options
)
DeriveKind
:
:
Enum
(
_
)
=
>
crate
:
:
enum_
:
:
expand_enum
(
input
options
)
DeriveKind
:
:
Error
(
_
)
=
>
crate
:
:
error
:
:
expand_error
(
input
options
)
}
}
pub
enum
DeriveKind
{
Record
(
kw
:
:
Record
)
Enum
(
kw
:
:
Enum
)
Error
(
kw
:
:
Error
)
Object
(
kw
:
:
Object
)
}
impl
Parse
for
DeriveKind
{
fn
parse
(
input
:
ParseStream
<
'
_
>
)
-
>
syn
:
:
Result
<
Self
>
{
let
lookahead
=
input
.
lookahead1
(
)
;
if
lookahead
.
peek
(
kw
:
:
Record
)
{
Ok
(
Self
:
:
Record
(
input
.
parse
(
)
?
)
)
}
else
if
lookahead
.
peek
(
kw
:
:
Enum
)
{
Ok
(
Self
:
:
Enum
(
input
.
parse
(
)
?
)
)
}
else
if
lookahead
.
peek
(
kw
:
:
Error
)
{
Ok
(
Self
:
:
Error
(
input
.
parse
(
)
?
)
)
}
else
if
lookahead
.
peek
(
kw
:
:
Object
)
{
Ok
(
Self
:
:
Object
(
input
.
parse
(
)
?
)
)
}
else
{
Err
(
lookahead
.
error
(
)
)
}
}
}
pub
struct
DeriveOptions
{
pub
local_tag
:
bool
pub
generate_metadata
:
bool
}
impl
Default
for
DeriveOptions
{
fn
default
(
)
-
>
Self
{
Self
{
local_tag
:
false
generate_metadata
:
true
}
}
}
impl
DeriveOptions
{
pub
fn
udl_derive
(
)
-
>
Self
{
Self
{
local_tag
:
true
generate_metadata
:
false
}
}
pub
fn
ffi_impl_header
(
&
self
trait_name
:
&
str
ident
:
&
impl
ToTokens
)
-
>
TokenStream
{
let
trait_name
=
Ident
:
:
new
(
trait_name
Span
:
:
call_site
(
)
)
;
if
self
.
local_tag
{
quote
!
{
impl
:
:
uniffi
:
:
#
trait_name
<
crate
:
:
UniFfiTag
>
for
#
ident
}
}
else
{
quote
!
{
impl
<
UT
>
:
:
uniffi
:
:
#
trait_name
<
UT
>
for
#
ident
}
}
}
pub
fn
derive_all_ffi_traits
(
&
self
ty
:
&
Ident
)
-
>
TokenStream
{
if
self
.
local_tag
{
quote
!
{
:
:
uniffi
:
:
derive_ffi_traits
!
(
local
#
ty
)
;
}
}
else
{
quote
!
{
:
:
uniffi
:
:
derive_ffi_traits
!
(
blanket
#
ty
)
;
}
}
}
pub
fn
derive_ffi_traits
(
&
self
ty
:
impl
ToTokens
trait_names
:
&
[
&
str
]
)
-
>
TokenStream
{
let
trait_idents
=
trait_names
.
iter
(
)
.
map
(
|
name
|
Ident
:
:
new
(
name
Span
:
:
call_site
(
)
)
)
;
if
self
.
local_tag
{
quote
!
{
#
(
:
:
uniffi
:
:
derive_ffi_traits
!
(
impl
#
trait_idents
<
crate
:
:
UniFfiTag
>
for
#
ty
)
;
)
*
}
}
else
{
quote
!
{
#
(
:
:
uniffi
:
:
derive_ffi_traits
!
(
impl
<
UT
>
#
trait_idents
<
UT
>
for
#
ty
)
;
)
*
}
}
}
}
