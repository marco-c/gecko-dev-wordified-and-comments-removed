#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
proc_macro_expand
)
)
]
#
!
[
warn
(
rust_2018_idioms
unused_qualifications
)
]
use
camino
:
:
Utf8Path
;
use
proc_macro
:
:
TokenStream
;
use
quote
:
:
quote
;
use
syn
:
:
{
parse_macro_input
LitStr
}
;
mod
enum_
;
mod
error
;
mod
export
;
mod
fnsig
;
mod
object
;
mod
record
;
mod
test
;
mod
util
;
use
self
:
:
{
enum_
:
:
expand_enum
error
:
:
expand_error
export
:
:
expand_export
object
:
:
expand_object
record
:
:
expand_record
}
;
#
[
proc_macro
]
pub
fn
build_foreign_language_testcases
(
tokens
:
TokenStream
)
-
>
TokenStream
{
test
:
:
build_foreign_language_testcases
(
tokens
)
}
#
[
proc_macro_attribute
]
pub
fn
export
(
attr_args
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
input2
=
proc_macro2
:
:
TokenStream
:
:
from
(
input
.
clone
(
)
)
;
let
gen_output
=
|
|
{
let
mod_path
=
util
:
:
mod_path
(
)
?
;
let
args
=
syn
:
:
parse
(
attr_args
)
?
;
let
item
=
syn
:
:
parse
(
input
)
?
;
expand_export
(
item
args
mod_path
)
}
;
let
output
=
gen_output
(
)
.
unwrap_or_else
(
syn
:
:
Error
:
:
into_compile_error
)
;
quote
!
{
#
input2
#
output
}
.
into
(
)
}
#
[
proc_macro_derive
(
Record
attributes
(
uniffi
)
)
]
pub
fn
derive_record
(
input
:
TokenStream
)
-
>
TokenStream
{
expand_record
(
parse_macro_input
!
(
input
)
)
.
into
(
)
}
#
[
proc_macro_derive
(
Enum
)
]
pub
fn
derive_enum
(
input
:
TokenStream
)
-
>
TokenStream
{
expand_enum
(
parse_macro_input
!
(
input
)
)
.
into
(
)
}
#
[
proc_macro_derive
(
Object
)
]
pub
fn
derive_object
(
input
:
TokenStream
)
-
>
TokenStream
{
let
mod_path
=
match
util
:
:
mod_path
(
)
{
Ok
(
p
)
=
>
p
Err
(
e
)
=
>
return
e
.
into_compile_error
(
)
.
into
(
)
}
;
let
input
=
parse_macro_input
!
(
input
)
;
expand_object
(
input
mod_path
)
.
into
(
)
}
#
[
proc_macro_derive
(
Error
attributes
(
uniffi
)
)
]
pub
fn
derive_error
(
input
:
TokenStream
)
-
>
TokenStream
{
expand_error
(
parse_macro_input
!
(
input
)
)
.
unwrap_or_else
(
syn
:
:
Error
:
:
into_compile_error
)
.
into
(
)
}
#
[
doc
(
hidden
)
]
#
[
proc_macro_attribute
]
pub
fn
ffi_converter_record
(
attrs
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
record
:
:
expand_record_ffi_converter
(
syn
:
:
parse_macro_input
!
(
attrs
)
syn
:
:
parse_macro_input
!
(
input
)
)
.
into
(
)
}
#
[
doc
(
hidden
)
]
#
[
proc_macro_attribute
]
pub
fn
ffi_converter_enum
(
attrs
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
enum_
:
:
expand_enum_ffi_converter
(
syn
:
:
parse_macro_input
!
(
attrs
)
syn
:
:
parse_macro_input
!
(
input
)
)
.
into
(
)
}
#
[
doc
(
hidden
)
]
#
[
proc_macro_attribute
]
pub
fn
ffi_converter_error
(
attrs
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
error
:
:
expand_ffi_converter_error
(
syn
:
:
parse_macro_input
!
(
attrs
)
syn
:
:
parse_macro_input
!
(
input
)
)
.
into
(
)
}
#
[
doc
(
hidden
)
]
#
[
proc_macro_attribute
]
pub
fn
ffi_converter_interface
(
attrs
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
object
:
:
expand_ffi_converter_interface
(
syn
:
:
parse_macro_input
!
(
attrs
)
syn
:
:
parse_macro_input
!
(
input
)
)
.
into
(
)
}
#
[
proc_macro
]
pub
fn
include_scaffolding
(
component_name
:
TokenStream
)
-
>
TokenStream
{
let
name
=
syn
:
:
parse_macro_input
!
(
component_name
as
LitStr
)
;
if
std
:
:
env
:
:
var
(
"
OUT_DIR
"
)
.
is_err
(
)
{
quote
!
{
compile_error
!
(
"
This
macro
assumes
the
crate
has
a
build
.
rs
script
but
OUT_DIR
is
not
present
"
)
;
}
}
else
{
let
udl_name
=
name
.
value
(
)
;
let
mod_path
=
match
util
:
:
mod_path
(
)
{
Ok
(
v
)
=
>
quote
!
{
#
v
}
Err
(
e
)
=
>
e
.
into_compile_error
(
)
}
;
let
metadata
=
util
:
:
create_metadata_items
(
"
UDL
"
&
udl_name
.
replace
(
'
-
'
"
_
"
)
.
to_ascii_uppercase
(
)
quote
!
{
:
:
uniffi
:
:
MetadataBuffer
:
:
from_code
(
:
:
uniffi
:
:
metadata
:
:
codes
:
:
UDL_FILE
)
.
concat_str
(
#
mod_path
)
.
concat_str
(
#
udl_name
)
}
None
)
;
let
toml_path
=
match
util
:
:
manifest_path
(
)
{
Ok
(
path
)
=
>
path
.
display
(
)
.
to_string
(
)
Err
(
_
)
=
>
{
return
quote
!
{
compile_error
!
(
"
This
macro
assumes
the
crate
has
a
build
.
rs
script
but
OUT_DIR
is
not
present
"
)
;
}
.
into
(
)
;
}
}
;
quote
!
{
#
metadata
/
/
FIXME
(
HACK
)
:
/
/
Include
the
Cargo
.
toml
file
into
the
build
.
/
/
That
way
cargo
tracks
the
file
and
other
tools
relying
on
file
/
/
tracking
see
it
as
well
.
/
/
See
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1846223
/
/
In
the
future
we
should
handle
that
by
using
the
track_path
:
:
path
API
/
/
see
https
:
/
/
github
.
com
/
rust
-
lang
/
rust
/
pull
/
84029
#
[
allow
(
dead_code
)
]
mod
__unused
{
const
_
:
&
[
u8
]
=
include_bytes
!
(
#
toml_path
)
;
}
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
"
#
name
"
.
uniffi
.
rs
"
)
)
;
}
}
.
into
(
)
}
#
[
proc_macro
]
pub
fn
generate_and_include_scaffolding
(
udl_file
:
TokenStream
)
-
>
TokenStream
{
let
udl_file
=
syn
:
:
parse_macro_input
!
(
udl_file
as
LitStr
)
;
let
udl_file_string
=
udl_file
.
value
(
)
;
let
udl_file_path
=
Utf8Path
:
:
new
(
&
udl_file_string
)
;
if
std
:
:
env
:
:
var
(
"
OUT_DIR
"
)
.
is_err
(
)
{
quote
!
{
compile_error
!
(
"
This
macro
assumes
the
crate
has
a
build
.
rs
script
but
OUT_DIR
is
not
present
"
)
;
}
}
else
if
let
Err
(
e
)
=
uniffi_build
:
:
generate_scaffolding
(
udl_file_path
)
{
let
err
=
format
!
(
"
{
e
:
#
}
"
)
;
quote
!
{
compile_error
!
(
concat
!
(
"
Failed
to
generate
scaffolding
from
UDL
file
at
"
#
udl_file
"
:
"
#
err
)
)
;
}
}
else
{
let
name
=
LitStr
:
:
new
(
udl_file_path
.
file_stem
(
)
.
unwrap
(
)
udl_file
.
span
(
)
)
;
quote
!
{
uniffi_macros
:
:
include_scaffolding
!
(
#
name
)
;
}
}
.
into
(
)
}
#
[
proc_macro_attribute
]
pub
fn
constructor
(
_attrs
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
input
}
