#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
proc_macro_expand
)
)
]
use
camino
:
:
{
Utf8Path
Utf8PathBuf
}
;
use
proc_macro
:
:
TokenStream
;
use
quote
:
:
{
format_ident
quote
}
;
use
std
:
:
env
;
use
syn
:
:
{
bracketed
parse_macro_input
punctuated
:
:
Punctuated
LitStr
Token
}
;
use
util
:
:
rewrite_self_type
;
mod
export
;
mod
object
;
mod
record
;
mod
util
;
use
self
:
:
{
export
:
:
expand_export
object
:
:
expand_object
record
:
:
expand_record
}
;
#
[
proc_macro_attribute
]
pub
fn
export
(
_attr
:
TokenStream
input
:
TokenStream
)
-
>
TokenStream
{
let
input2
=
proc_macro2
:
:
TokenStream
:
:
from
(
input
.
clone
(
)
)
;
let
gen_output
=
|
|
{
let
mod_path
=
util
:
:
mod_path
(
)
?
;
let
mut
item
=
syn
:
:
parse
(
input
)
?
;
rewrite_self_type
(
&
mut
item
)
;
let
metadata
=
export
:
:
gen_metadata
(
item
&
mod_path
)
?
;
Ok
(
expand_export
(
metadata
&
mod_path
)
)
}
;
let
output
=
gen_output
(
)
.
unwrap_or_else
(
syn
:
:
Error
:
:
into_compile_error
)
;
quote
!
{
#
input2
#
output
}
.
into
(
)
}
#
[
proc_macro_derive
(
Record
)
]
pub
fn
derive_record
(
input
:
TokenStream
)
-
>
TokenStream
{
let
mod_path
=
match
util
:
:
mod_path
(
)
{
Ok
(
p
)
=
>
p
Err
(
e
)
=
>
return
e
.
into_compile_error
(
)
.
into
(
)
}
;
let
input
=
parse_macro_input
!
(
input
)
;
expand_record
(
input
mod_path
)
.
into
(
)
}
#
[
proc_macro_derive
(
Object
)
]
pub
fn
derive_object
(
input
:
TokenStream
)
-
>
TokenStream
{
let
mod_path
=
match
util
:
:
mod_path
(
)
{
Ok
(
p
)
=
>
p
Err
(
e
)
=
>
return
e
.
into_compile_error
(
)
.
into
(
)
}
;
let
input
=
parse_macro_input
!
(
input
)
;
expand_object
(
input
mod_path
)
.
into
(
)
}
#
[
proc_macro
]
pub
fn
build_foreign_language_testcases
(
paths
:
TokenStream
)
-
>
TokenStream
{
let
paths
=
syn
:
:
parse_macro_input
!
(
paths
as
FilePaths
)
;
let
pkg_dir
=
env
:
:
var
(
"
CARGO_MANIFEST_DIR
"
)
.
expect
(
"
Missing
CARGO_MANIFEST_DIR
cannot
build
tests
for
generated
bindings
"
)
;
let
udl_files
=
&
paths
.
udl_files
.
iter
(
)
.
map
(
|
file_path
|
{
let
pathbuf
:
Utf8PathBuf
=
[
&
pkg_dir
file_path
]
.
iter
(
)
.
collect
(
)
;
let
path
=
pathbuf
.
to_string
(
)
;
quote
!
{
#
path
}
}
)
.
collect
:
:
<
Vec
<
proc_macro2
:
:
TokenStream
>
>
(
)
;
let
test_functions
=
paths
.
test_scripts
.
iter
(
)
.
map
(
|
file_path
|
{
let
test_file_pathbuf
:
Utf8PathBuf
=
[
&
pkg_dir
file_path
]
.
iter
(
)
.
collect
(
)
;
let
test_file_path
=
test_file_pathbuf
.
to_string
(
)
;
let
test_file_name
=
test_file_pathbuf
.
file_name
(
)
.
expect
(
"
Test
file
has
no
name
cannot
build
tests
for
generated
bindings
"
)
;
let
test_name
=
format_ident
!
(
"
uniffi_foreign_language_testcase_
{
}
"
test_file_name
.
replace
(
|
c
:
char
|
!
c
.
is_alphanumeric
(
)
"
_
"
)
)
;
let
maybe_ignore
=
if
should_skip_path
(
&
test_file_pathbuf
)
{
quote
!
{
#
[
ignore
]
}
}
else
{
quote
!
{
}
}
;
quote
!
{
#
maybe_ignore
#
[
test
]
fn
#
test_name
(
)
-
>
uniffi
:
:
deps
:
:
anyhow
:
:
Result
<
(
)
>
{
uniffi
:
:
testing
:
:
run_foreign_language_testcase
(
#
pkg_dir
&
[
#
(
#
udl_files
)
*
]
#
test_file_path
)
}
}
}
)
.
collect
:
:
<
Vec
<
proc_macro2
:
:
TokenStream
>
>
(
)
;
let
test_module
=
quote
!
{
#
(
#
test_functions
)
*
}
;
TokenStream
:
:
from
(
test_module
)
}
fn
should_skip_path
(
path
:
&
Utf8Path
)
-
>
bool
{
let
ext
=
path
.
extension
(
)
.
expect
(
"
File
has
no
extension
!
"
)
;
env
:
:
var
(
"
UNIFFI_TESTS_DISABLE_EXTENSIONS
"
)
.
map
(
|
v
|
v
.
split
(
'
'
)
.
any
(
|
look
|
look
=
=
ext
)
)
.
unwrap_or
(
false
)
}
#
[
derive
(
Debug
)
]
struct
FilePaths
{
udl_files
:
Vec
<
String
>
test_scripts
:
Vec
<
String
>
}
impl
syn
:
:
parse
:
:
Parse
for
FilePaths
{
fn
parse
(
input
:
syn
:
:
parse
:
:
ParseStream
)
-
>
syn
:
:
Result
<
Self
>
{
let
udl_array
;
bracketed
!
(
udl_array
in
input
)
;
let
udl_files
=
Punctuated
:
:
<
LitStr
Token
!
[
]
>
:
:
parse_terminated
(
&
udl_array
)
?
.
iter
(
)
.
map
(
|
s
|
s
.
value
(
)
)
.
collect
(
)
;
let
_comma
:
Token
!
[
]
=
input
.
parse
(
)
?
;
let
scripts_array
;
bracketed
!
(
scripts_array
in
input
)
;
let
test_scripts
=
Punctuated
:
:
<
LitStr
Token
!
[
]
>
:
:
parse_terminated
(
&
scripts_array
)
?
.
iter
(
)
.
map
(
|
s
|
s
.
value
(
)
)
.
collect
(
)
;
Ok
(
FilePaths
{
udl_files
test_scripts
}
)
}
}
#
[
proc_macro
]
pub
fn
include_scaffolding
(
component_name
:
TokenStream
)
-
>
TokenStream
{
let
name
=
syn
:
:
parse_macro_input
!
(
component_name
as
syn
:
:
LitStr
)
;
if
std
:
:
env
:
:
var
(
"
OUT_DIR
"
)
.
is_err
(
)
{
quote
!
{
compile_error
!
(
"
This
macro
assumes
the
crate
has
a
build
.
rs
script
but
OUT_DIR
is
not
present
"
)
;
}
}
else
{
quote
!
{
include
!
(
concat
!
(
env
!
(
"
OUT_DIR
"
)
"
/
"
#
name
"
.
uniffi
.
rs
"
)
)
;
}
}
.
into
(
)
}
#
[
proc_macro
]
pub
fn
generate_and_include_scaffolding
(
udl_file
:
TokenStream
)
-
>
TokenStream
{
let
udl_file
=
syn
:
:
parse_macro_input
!
(
udl_file
as
syn
:
:
LitStr
)
;
let
udl_file_string
=
udl_file
.
value
(
)
;
let
udl_file_path
=
Utf8Path
:
:
new
(
&
udl_file_string
)
;
if
std
:
:
env
:
:
var
(
"
OUT_DIR
"
)
.
is_err
(
)
{
quote
!
{
compile_error
!
(
"
This
macro
assumes
the
crate
has
a
build
.
rs
script
but
OUT_DIR
is
not
present
"
)
;
}
}
else
if
uniffi_build
:
:
generate_scaffolding
(
udl_file_path
)
.
is_err
(
)
{
quote
!
{
compile_error
!
(
concat
!
(
"
Failed
to
generate
scaffolding
from
UDL
file
at
"
#
udl_file
)
)
;
}
}
else
{
let
name
=
LitStr
:
:
new
(
udl_file_path
.
file_stem
(
)
.
unwrap
(
)
udl_file
.
span
(
)
)
;
quote
!
{
uniffi_macros
:
:
include_scaffolding
!
(
#
name
)
;
}
}
.
into
(
)
}
