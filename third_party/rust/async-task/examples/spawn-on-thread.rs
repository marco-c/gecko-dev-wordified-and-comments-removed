use
std
:
:
future
:
:
Future
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
async_task
:
:
Task
;
use
smol
:
:
future
;
fn
spawn_on_thread
<
F
T
>
(
future
:
F
)
-
>
Task
<
T
>
where
F
:
Future
<
Output
=
T
>
+
Send
+
'
static
T
:
Send
+
'
static
{
let
(
sender
receiver
)
=
flume
:
:
unbounded
(
)
;
let
sender
=
Arc
:
:
new
(
sender
)
;
let
s
=
Arc
:
:
downgrade
(
&
sender
)
;
let
future
=
async
move
{
let
_sender
=
sender
;
future
.
await
}
;
let
schedule
=
move
|
runnable
|
s
.
upgrade
(
)
.
unwrap
(
)
.
send
(
runnable
)
.
unwrap
(
)
;
let
(
runnable
task
)
=
async_task
:
:
spawn
(
future
schedule
)
;
runnable
.
schedule
(
)
;
thread
:
:
spawn
(
move
|
|
{
for
runnable
in
receiver
{
runnable
.
run
(
)
;
}
}
)
;
task
}
fn
main
(
)
{
future
:
:
block_on
(
spawn_on_thread
(
async
{
println
!
(
"
Hello
world
!
"
)
;
}
)
)
;
}
