use
std
:
:
future
:
:
Future
;
use
std
:
:
panic
:
:
catch_unwind
;
use
std
:
:
thread
;
use
async_task
:
:
{
Runnable
Task
}
;
use
once_cell
:
:
sync
:
:
Lazy
;
use
smol
:
:
future
;
fn
spawn
<
F
T
>
(
future
:
F
)
-
>
Task
<
T
>
where
F
:
Future
<
Output
=
T
>
+
Send
+
'
static
T
:
Send
+
'
static
{
static
QUEUE
:
Lazy
<
flume
:
:
Sender
<
Runnable
>
>
=
Lazy
:
:
new
(
|
|
{
let
(
sender
receiver
)
=
flume
:
:
unbounded
:
:
<
Runnable
>
(
)
;
thread
:
:
spawn
(
|
|
{
for
runnable
in
receiver
{
let
_ignore_panic
=
catch_unwind
(
|
|
runnable
.
run
(
)
)
;
}
}
)
;
sender
}
)
;
let
schedule
=
|
runnable
|
QUEUE
.
send
(
runnable
)
.
unwrap
(
)
;
let
(
runnable
task
)
=
async_task
:
:
spawn
(
future
schedule
)
;
runnable
.
schedule
(
)
;
task
}
fn
main
(
)
{
let
task
=
spawn
(
async
{
println
!
(
"
Hello
world
!
"
)
;
}
)
;
future
:
:
block_on
(
task
)
;
}
