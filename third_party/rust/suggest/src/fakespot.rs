pub
struct
FakespotScore
{
keywords_score
:
f64
product_type_score
:
f64
fakespot_score
:
f64
}
impl
FakespotScore
{
pub
fn
new
(
query
:
&
str
keywords
:
String
product_type
:
String
fakespot_score
:
f64
)
-
>
Self
{
let
query
=
query
.
to_lowercase
(
)
;
let
query_terms
=
split_terms
(
&
query
)
;
Self
{
keywords_score
:
calc_keywords_score
(
&
query_terms
&
keywords
)
product_type_score
:
calc_product_type_score
(
&
query_terms
&
product_type
)
fakespot_score
}
}
pub
fn
as_suggest_score
(
&
self
)
-
>
f64
{
0
.
30
+
(
0
.
01
*
self
.
keywords_score
)
+
(
0
.
001
*
self
.
product_type_score
)
+
(
0
.
0001
*
self
.
fakespot_score
)
}
}
fn
split_terms
(
string
:
&
str
)
-
>
Vec
<
&
str
>
{
string
.
split_whitespace
(
)
.
collect
(
)
}
fn
calc_keywords_score
(
query_terms
:
&
[
&
str
]
keywords
:
&
str
)
-
>
f64
{
let
keyword_terms
=
split_terms
(
keywords
)
;
if
keyword_terms
.
is_empty
(
)
{
return
0
.
0
;
}
if
query_terms
=
=
keyword_terms
{
1
.
0
}
else
{
0
.
0
}
}
fn
calc_product_type_score
(
query_terms
:
&
[
&
str
]
product_type
:
&
str
)
-
>
f64
{
let
product_type_terms
=
split_terms
(
product_type
)
;
if
product_type_terms
.
is_empty
(
)
{
return
0
.
0
;
}
let
count
=
product_type_terms
.
iter
(
)
.
filter
(
|
t
|
query_terms
.
contains
(
t
)
)
.
count
(
)
as
f64
;
count
/
product_type_terms
.
len
(
)
as
f64
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
struct
KeywordsTestCase
{
keywords
:
&
'
static
str
query
:
&
'
static
str
expected
:
f64
}
impl
KeywordsTestCase
{
fn
test
(
&
self
)
{
let
actual
=
calc_keywords_score
(
&
split_terms
(
&
self
.
query
.
to_lowercase
(
)
)
self
.
keywords
)
;
assert_eq
!
(
actual
self
.
expected
"
keywords
:
{
}
query
:
{
}
expected
:
{
}
actual
:
{
actual
}
"
self
.
keywords
self
.
query
self
.
expected
)
;
}
}
#
[
test
]
fn
test_keywords_score
(
)
{
KeywordsTestCase
{
keywords
:
"
apple
"
query
:
"
apple
"
expected
:
1
.
0
}
.
test
(
)
;
KeywordsTestCase
{
keywords
:
"
apple
"
query
:
"
android
"
expected
:
0
.
0
}
.
test
(
)
;
KeywordsTestCase
{
keywords
:
"
apple
"
query
:
"
apple
phone
"
expected
:
0
.
0
}
.
test
(
)
;
KeywordsTestCase
{
keywords
:
"
"
query
:
"
"
expected
:
0
.
0
}
.
test
(
)
;
KeywordsTestCase
{
keywords
:
"
"
query
:
"
apple
"
expected
:
0
.
0
}
.
test
(
)
;
KeywordsTestCase
{
keywords
:
"
apple
"
query
:
"
Apple
"
expected
:
1
.
0
}
.
test
(
)
;
}
struct
ProductTypeTestCase
{
query
:
&
'
static
str
product_type
:
&
'
static
str
expected
:
f64
}
impl
ProductTypeTestCase
{
fn
test
(
&
self
)
{
let
actual
=
calc_product_type_score
(
&
split_terms
(
&
self
.
query
.
to_lowercase
(
)
)
self
.
product_type
)
;
assert_eq
!
(
actual
self
.
expected
"
product_type
:
{
}
query
:
{
}
expected
:
{
}
actual
:
{
actual
}
"
self
.
product_type
self
.
query
self
.
expected
)
;
}
}
#
[
test
]
fn
test_product_type_score
(
)
{
ProductTypeTestCase
{
product_type
:
"
standing
desk
"
query
:
"
standing
desk
"
expected
:
1
.
0
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
standing
desk
"
query
:
"
desk
"
expected
:
0
.
5
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
standing
desk
"
query
:
"
desk
desk
desk
"
expected
:
0
.
5
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
standing
desk
"
query
:
"
standing
"
expected
:
0
.
5
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
standing
desk
"
query
:
"
phone
"
expected
:
0
.
0
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
standing
desk
"
query
:
"
standing
desk
for
my
office
"
expected
:
1
.
0
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
"
query
:
"
"
expected
:
0
.
0
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
desk
"
query
:
"
Desk
"
expected
:
1
.
0
}
.
test
(
)
;
ProductTypeTestCase
{
product_type
:
"
desk
"
query
:
"
desk
"
expected
:
1
.
0
}
.
test
(
)
;
}
}
