use
core
:
:
any
:
:
Any
;
use
crate
:
:
prelude
:
:
*
;
use
crate
:
:
ule
:
:
MaybeEncodeAsVarULE
;
use
crate
:
:
{
dynutil
:
:
UpcastDataPayload
ule
:
:
MaybeAsVarULE
}
;
use
alloc
:
:
sync
:
:
Arc
;
use
databake
:
:
{
Bake
BakeSize
CrateEnv
TokenStream
}
;
use
yoke
:
:
*
;
use
zerovec
:
:
VarZeroVec
;
#
[
cfg
(
doc
)
]
use
zerovec
:
:
ule
:
:
VarULE
;
trait
ExportableDataPayload
{
fn
bake_yoke
(
&
self
ctx
:
&
CrateEnv
)
-
>
TokenStream
;
fn
bake_size
(
&
self
)
-
>
usize
;
fn
serialize_yoke
(
&
self
serializer
:
&
mut
dyn
erased_serde
:
:
Serializer
)
-
>
Result
<
(
)
DataError
>
;
fn
maybe_bake_varule_encoded
(
&
self
rest
:
&
[
&
DataPayload
<
ExportMarker
>
]
ctx
:
&
CrateEnv
)
-
>
Option
<
TokenStream
>
;
fn
as_any
(
&
self
)
-
>
&
dyn
Any
;
fn
eq_dyn
(
&
self
other
:
&
dyn
ExportableDataPayload
)
-
>
bool
;
}
impl
<
M
:
DynamicDataMarker
>
ExportableDataPayload
for
DataPayload
<
M
>
where
for
<
'
a
>
<
M
:
:
DataStruct
as
Yokeable
<
'
a
>
>
:
:
Output
:
Bake
+
BakeSize
+
serde
:
:
Serialize
+
MaybeEncodeAsVarULE
+
PartialEq
{
fn
bake_yoke
(
&
self
ctx
:
&
CrateEnv
)
-
>
TokenStream
{
self
.
get
(
)
.
bake
(
ctx
)
}
fn
bake_size
(
&
self
)
-
>
usize
{
core
:
:
mem
:
:
size_of
:
:
<
<
M
:
:
DataStruct
as
Yokeable
>
:
:
Output
>
(
)
+
self
.
get
(
)
.
borrows_size
(
)
}
fn
serialize_yoke
(
&
self
serializer
:
&
mut
dyn
erased_serde
:
:
Serializer
)
-
>
Result
<
(
)
DataError
>
{
use
erased_serde
:
:
Serialize
;
self
.
get
(
)
.
erased_serialize
(
serializer
)
.
map_err
(
|
e
|
DataError
:
:
custom
(
"
Serde
export
"
)
.
with_display_context
(
&
e
)
)
?
;
Ok
(
(
)
)
}
fn
maybe_bake_varule_encoded
(
&
self
rest
:
&
[
&
DataPayload
<
ExportMarker
>
]
ctx
:
&
CrateEnv
)
-
>
Option
<
TokenStream
>
{
let
first_varule
=
self
.
get
(
)
.
maybe_encode_as_varule
(
)
?
;
let
recovered_vec
:
Vec
<
&
<
<
M
:
:
DataStruct
as
Yokeable
<
'
_
>
>
:
:
Output
as
MaybeAsVarULE
>
:
:
EncodedStruct
>
=
core
:
:
iter
:
:
once
(
first_varule
)
.
chain
(
rest
.
iter
(
)
.
map
(
|
v
|
{
#
[
allow
(
clippy
:
:
expect_used
)
]
v
.
get
(
)
.
payload
.
as_any
(
)
.
downcast_ref
:
:
<
Self
>
(
)
.
expect
(
"
payloads
expected
to
be
same
type
"
)
.
get
(
)
.
maybe_encode_as_varule
(
)
.
expect
(
"
MaybeEncodeAsVarULE
impl
should
be
symmetric
"
)
}
)
)
.
collect
(
)
;
let
vzv
:
VarZeroVec
<
<
<
M
:
:
DataStruct
as
Yokeable
<
'
_
>
>
:
:
Output
as
MaybeAsVarULE
>
:
:
EncodedStruct
>
=
VarZeroVec
:
:
from
(
&
recovered_vec
)
;
let
vzs
=
vzv
.
as_slice
(
)
;
Some
(
vzs
.
bake
(
ctx
)
)
}
fn
as_any
(
&
self
)
-
>
&
dyn
Any
{
self
}
fn
eq_dyn
(
&
self
other
:
&
dyn
ExportableDataPayload
)
-
>
bool
{
match
other
.
as_any
(
)
.
downcast_ref
:
:
<
Self
>
(
)
{
Some
(
downcasted
)
=
>
(
*
self
)
.
eq
(
downcasted
)
None
=
>
{
debug_assert
!
(
false
"
cannot
compare
ExportableDataPayloads
of
different
types
:
self
is
{
:
?
}
but
other
is
{
:
?
}
"
self
.
type_id
(
)
other
.
as_any
(
)
.
type_id
(
)
)
;
false
}
}
}
}
#
[
derive
(
yoke
:
:
Yokeable
Clone
)
]
#
[
allow
(
missing_docs
)
]
pub
struct
ExportBox
{
payload
:
Arc
<
dyn
ExportableDataPayload
+
Sync
+
Send
>
}
impl
PartialEq
for
ExportBox
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
payload
.
eq_dyn
(
&
*
other
.
payload
)
}
}
impl
Eq
for
ExportBox
{
}
impl
core
:
:
fmt
:
:
Debug
for
ExportBox
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
ExportBox
"
)
.
field
(
"
payload
"
&
"
<
payload
>
"
)
.
finish
(
)
}
}
impl
<
M
>
UpcastDataPayload
<
M
>
for
ExportMarker
where
M
:
DynamicDataMarker
M
:
:
DataStruct
:
Sync
+
Send
for
<
'
a
>
<
M
:
:
DataStruct
as
Yokeable
<
'
a
>
>
:
:
Output
:
Bake
+
BakeSize
+
serde
:
:
Serialize
+
MaybeEncodeAsVarULE
+
PartialEq
{
fn
upcast
(
other
:
DataPayload
<
M
>
)
-
>
DataPayload
<
ExportMarker
>
{
DataPayload
:
:
from_owned
(
ExportBox
{
payload
:
Arc
:
:
new
(
other
)
}
)
}
}
impl
DataPayload
<
ExportMarker
>
{
pub
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
(
)
DataError
>
where
S
:
serde
:
:
Serializer
S
:
:
Ok
:
'
static
{
self
.
get
(
)
.
payload
.
serialize_yoke
(
&
mut
<
dyn
erased_serde
:
:
Serializer
>
:
:
erase
(
serializer
)
)
}
pub
fn
tokenize
(
&
self
ctx
:
&
CrateEnv
)
-
>
TokenStream
{
self
.
get
(
)
.
payload
.
bake_yoke
(
ctx
)
}
pub
fn
tokenize_encoded_seq
(
structs
:
&
[
&
Self
]
ctx
:
&
CrateEnv
)
-
>
Option
<
TokenStream
>
{
let
(
first
rest
)
=
structs
.
split_first
(
)
?
;
first
.
get
(
)
.
payload
.
maybe_bake_varule_encoded
(
rest
ctx
)
}
pub
fn
postcard_size
(
&
self
)
-
>
usize
{
use
postcard
:
:
ser_flavors
:
:
{
Flavor
Size
}
;
let
mut
serializer
=
postcard
:
:
Serializer
{
output
:
Size
:
:
default
(
)
}
;
let
_infallible
=
self
.
get
(
)
.
payload
.
serialize_yoke
(
&
mut
<
dyn
erased_serde
:
:
Serializer
>
:
:
erase
(
&
mut
serializer
)
)
;
serializer
.
output
.
finalize
(
)
.
unwrap_or_default
(
)
}
pub
fn
baked_size
(
&
self
)
-
>
usize
{
self
.
get
(
)
.
payload
.
bake_size
(
)
}
}
impl
core
:
:
hash
:
:
Hash
for
DataPayload
<
ExportMarker
>
{
fn
hash
<
H
:
core
:
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
hash_and_postcard_size
(
state
)
;
}
}
impl
DataPayload
<
ExportMarker
>
{
pub
fn
hash_and_postcard_size
<
H
:
core
:
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
-
>
usize
{
use
postcard
:
:
ser_flavors
:
:
Flavor
;
struct
HashFlavor
<
'
a
H
>
(
&
'
a
mut
H
usize
)
;
impl
<
H
:
core
:
:
hash
:
:
Hasher
>
Flavor
for
HashFlavor
<
'
_
H
>
{
type
Output
=
usize
;
fn
try_push
(
&
mut
self
data
:
u8
)
-
>
postcard
:
:
Result
<
(
)
>
{
self
.
0
.
write_u8
(
data
)
;
self
.
1
+
=
1
;
Ok
(
(
)
)
}
fn
finalize
(
self
)
-
>
postcard
:
:
Result
<
Self
:
:
Output
>
{
Ok
(
self
.
1
)
}
}
let
mut
serializer
=
postcard
:
:
Serializer
{
output
:
HashFlavor
(
state
0
)
}
;
let
_infallible
=
self
.
get
(
)
.
payload
.
serialize_yoke
(
&
mut
<
dyn
erased_serde
:
:
Serializer
>
:
:
erase
(
&
mut
serializer
)
)
;
serializer
.
output
.
1
}
}
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
#
[
derive
(
Debug
)
]
pub
struct
ExportMarker
{
}
impl
DynamicDataMarker
for
ExportMarker
{
type
DataStruct
=
ExportBox
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
hello_world
:
:
*
;
#
[
test
]
fn
test_compare_with_dyn
(
)
{
let
payload1
:
DataPayload
<
HelloWorldV1
>
=
DataPayload
:
:
from_owned
(
HelloWorld
{
message
:
"
abc
"
.
into
(
)
}
)
;
let
payload2
:
DataPayload
<
HelloWorldV1
>
=
DataPayload
:
:
from_owned
(
HelloWorld
{
message
:
"
abc
"
.
into
(
)
}
)
;
let
payload3
:
DataPayload
<
HelloWorldV1
>
=
DataPayload
:
:
from_owned
(
HelloWorld
{
message
:
"
def
"
.
into
(
)
}
)
;
assert
!
(
payload1
.
eq_dyn
(
&
payload2
)
)
;
assert
!
(
payload2
.
eq_dyn
(
&
payload1
)
)
;
assert
!
(
!
payload1
.
eq_dyn
(
&
payload3
)
)
;
assert
!
(
!
payload3
.
eq_dyn
(
&
payload1
)
)
;
}
#
[
test
]
fn
test_export_marker_partial_eq
(
)
{
let
payload1
:
DataPayload
<
ExportMarker
>
=
UpcastDataPayload
:
:
upcast
(
DataPayload
:
:
<
HelloWorldV1
>
:
:
from_owned
(
HelloWorld
{
message
:
"
abc
"
.
into
(
)
}
)
)
;
let
payload2
:
DataPayload
<
ExportMarker
>
=
UpcastDataPayload
:
:
upcast
(
DataPayload
:
:
<
HelloWorldV1
>
:
:
from_owned
(
HelloWorld
{
message
:
"
abc
"
.
into
(
)
}
)
)
;
let
payload3
:
DataPayload
<
ExportMarker
>
=
UpcastDataPayload
:
:
upcast
(
DataPayload
:
:
<
HelloWorldV1
>
:
:
from_owned
(
HelloWorld
{
message
:
"
def
"
.
into
(
)
}
)
)
;
assert_eq
!
(
payload1
payload2
)
;
assert_eq
!
(
payload2
payload1
)
;
assert_ne
!
(
payload1
payload3
)
;
assert_ne
!
(
payload3
payload1
)
;
}
}
