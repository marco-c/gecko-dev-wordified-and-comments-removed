mod
payload
;
#
[
doc
(
hidden
)
]
pub
use
payload
:
:
ExportBox
;
pub
use
payload
:
:
ExportMarker
;
use
crate
:
:
prelude
:
:
*
;
use
alloc
:
:
collections
:
:
BTreeSet
;
pub
trait
DataExporter
:
Sync
{
fn
put_payload
(
&
self
marker
:
DataMarkerInfo
id
:
DataIdentifierBorrowed
payload
:
&
DataPayload
<
ExportMarker
>
)
-
>
Result
<
(
)
DataError
>
;
fn
flush_singleton
(
&
self
marker
:
DataMarkerInfo
payload
:
&
DataPayload
<
ExportMarker
>
metadata
:
FlushMetadata
)
-
>
Result
<
(
)
DataError
>
{
self
.
put_payload
(
marker
Default
:
:
default
(
)
payload
)
?
;
self
.
flush
(
marker
metadata
)
}
fn
flush
(
&
self
_marker
:
DataMarkerInfo
_metadata
:
FlushMetadata
)
-
>
Result
<
(
)
DataError
>
{
Ok
(
(
)
)
}
fn
close
(
&
mut
self
)
-
>
Result
<
ExporterCloseMetadata
DataError
>
{
Ok
(
ExporterCloseMetadata
:
:
default
(
)
)
}
}
#
[
derive
(
Debug
Default
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
ExporterCloseMetadata
(
pub
Option
<
Box
<
dyn
core
:
:
any
:
:
Any
>
>
)
;
#
[
non_exhaustive
]
#
[
derive
(
Debug
Copy
Clone
Default
)
]
pub
struct
FlushMetadata
{
pub
supports_dry_provider
:
bool
pub
checksum
:
Option
<
u64
>
}
impl
DataExporter
for
Box
<
dyn
DataExporter
>
{
fn
put_payload
(
&
self
marker
:
DataMarkerInfo
id
:
DataIdentifierBorrowed
payload
:
&
DataPayload
<
ExportMarker
>
)
-
>
Result
<
(
)
DataError
>
{
(
*
*
self
)
.
put_payload
(
marker
id
payload
)
}
fn
flush_singleton
(
&
self
marker
:
DataMarkerInfo
payload
:
&
DataPayload
<
ExportMarker
>
metadata
:
FlushMetadata
)
-
>
Result
<
(
)
DataError
>
{
(
*
*
self
)
.
flush_singleton
(
marker
payload
metadata
)
}
fn
flush
(
&
self
marker
:
DataMarkerInfo
metadata
:
FlushMetadata
)
-
>
Result
<
(
)
DataError
>
{
(
*
*
self
)
.
flush
(
marker
metadata
)
}
fn
close
(
&
mut
self
)
-
>
Result
<
ExporterCloseMetadata
DataError
>
{
(
*
*
self
)
.
close
(
)
}
}
pub
trait
ExportableProvider
:
crate
:
:
data_provider
:
:
IterableDynamicDataProvider
<
ExportMarker
>
+
Sync
{
fn
supported_markers
(
&
self
)
-
>
BTreeSet
<
DataMarkerInfo
>
;
}
impl
ExportableProvider
for
Box
<
dyn
ExportableProvider
>
{
fn
supported_markers
(
&
self
)
-
>
BTreeSet
<
DataMarkerInfo
>
{
(
*
*
self
)
.
supported_markers
(
)
}
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__make_exportable_provider
{
(
provider
:
ty
[
(
(
#
[
cfg
:
meta
]
)
?
struct_m
:
ty
)
+
]
)
=
>
{
impl
crate
:
:
export
:
:
ExportableProvider
for
provider
{
fn
supported_markers
(
&
self
)
-
>
alloc
:
:
collections
:
:
BTreeSet
<
crate
:
:
DataMarkerInfo
>
{
alloc
:
:
collections
:
:
BTreeSet
:
:
from_iter
(
[
(
(
#
[
cfg
]
)
?
<
struct_m
>
:
:
INFO
)
+
]
)
}
}
crate
:
:
dynutil
:
:
impl_dynamic_data_provider
!
(
provider
[
(
(
#
[
cfg
]
)
?
struct_m
)
+
]
crate
:
:
export
:
:
ExportMarker
)
;
crate
:
:
dynutil
:
:
impl_iterable_dynamic_data_provider
!
(
provider
[
(
(
#
[
cfg
]
)
?
struct_m
)
+
]
crate
:
:
export
:
:
ExportMarker
)
;
}
;
}
#
[
doc
(
inline
)
]
pub
use
__make_exportable_provider
as
make_exportable_provider
;
#
[
derive
(
Default
)
]
pub
struct
MultiExporter
(
Vec
<
Box
<
dyn
DataExporter
>
>
)
;
impl
MultiExporter
{
pub
const
fn
new
(
exporters
:
Vec
<
Box
<
dyn
DataExporter
>
>
)
-
>
Self
{
Self
(
exporters
)
}
}
impl
core
:
:
fmt
:
:
Debug
for
MultiExporter
{
fn
fmt
(
&
self
f
:
&
mut
alloc
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
alloc
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
MultiExporter
"
)
.
field
(
"
0
"
&
format
!
(
"
vec
[
len
=
{
}
]
"
self
.
0
.
len
(
)
)
)
.
finish
(
)
}
}
impl
DataExporter
for
MultiExporter
{
fn
put_payload
(
&
self
marker
:
DataMarkerInfo
id
:
DataIdentifierBorrowed
payload
:
&
DataPayload
<
ExportMarker
>
)
-
>
Result
<
(
)
DataError
>
{
self
.
0
.
iter
(
)
.
try_for_each
(
|
e
|
e
.
put_payload
(
marker
id
payload
)
)
}
fn
flush_singleton
(
&
self
marker
:
DataMarkerInfo
payload
:
&
DataPayload
<
ExportMarker
>
metadata
:
FlushMetadata
)
-
>
Result
<
(
)
DataError
>
{
self
.
0
.
iter
(
)
.
try_for_each
(
|
e
|
e
.
flush_singleton
(
marker
payload
metadata
)
)
}
fn
flush
(
&
self
marker
:
DataMarkerInfo
metadata
:
FlushMetadata
)
-
>
Result
<
(
)
DataError
>
{
self
.
0
.
iter
(
)
.
try_for_each
(
|
e
|
e
.
flush
(
marker
metadata
)
)
}
fn
close
(
&
mut
self
)
-
>
Result
<
ExporterCloseMetadata
DataError
>
{
Ok
(
ExporterCloseMetadata
(
Some
(
Box
:
:
new
(
self
.
0
.
iter_mut
(
)
.
try_fold
(
vec
!
[
]
|
mut
m
e
|
{
m
.
push
(
e
.
close
(
)
?
.
0
)
;
Ok
:
:
<
_
DataError
>
(
m
)
}
)
?
)
)
)
)
}
}
