#
!
[
allow
(
clippy
:
:
exhaustive_structs
)
]
use
crate
as
icu_provider
;
use
crate
:
:
prelude
:
:
*
;
use
alloc
:
:
borrow
:
:
Cow
;
use
alloc
:
:
string
:
:
String
;
use
core
:
:
fmt
:
:
Debug
;
use
writeable
:
:
Writeable
;
use
yoke
:
:
*
;
use
zerofrom
:
:
*
;
#
[
derive
(
Debug
PartialEq
Clone
Yokeable
ZeroFrom
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
cfg_attr
(
any
(
feature
=
"
deserialize_json
"
feature
=
"
datagen
"
)
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
databake
:
:
Bake
)
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
databake
(
path
=
icu_provider
:
:
hello_world
)
)
]
pub
struct
HelloWorldV1
<
'
data
>
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
pub
message
:
Cow
<
'
data
str
>
}
impl
Default
for
HelloWorldV1
<
'
_
>
{
fn
default
(
)
-
>
Self
{
HelloWorldV1
{
message
:
Cow
:
:
Borrowed
(
"
(
und
)
Hello
World
"
)
}
}
}
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
Default
databake
:
:
Bake
)
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
databake
(
path
=
icu_provider
:
:
hello_world
)
)
]
#
[
derive
(
Debug
)
]
pub
struct
HelloWorldV1Marker
;
impl
DataMarker
for
HelloWorldV1Marker
{
type
Yokeable
=
HelloWorldV1
<
'
static
>
;
}
impl
KeyedDataMarker
for
HelloWorldV1Marker
{
const
KEY
:
DataKey
=
icu_provider
:
:
data_key
!
(
"
core
/
helloworld
1
"
)
;
}
#
[
derive
(
Debug
PartialEq
Default
)
]
pub
struct
HelloWorldProvider
;
impl
HelloWorldProvider
{
const
DATA
:
&
'
static
[
(
&
'
static
str
&
'
static
str
)
]
=
&
[
(
"
bn
"
"
"
)
(
"
cs
"
"
Ahoj
sv
te
"
)
(
"
de
"
"
Hallo
Welt
"
)
(
"
de
-
AT
"
"
Servus
Welt
"
)
(
"
el
"
"
"
)
(
"
en
"
"
Hello
World
"
)
(
"
en
-
001
"
"
Hello
from
"
)
(
"
en
-
002
"
"
Hello
from
"
)
(
"
en
-
019
"
"
Hello
from
"
)
(
"
en
-
142
"
"
Hello
from
"
)
(
"
en
-
GB
"
"
Hello
from
"
)
(
"
en
-
GB
-
u
-
sd
-
gbeng
"
"
Hello
from
"
)
(
"
en
-
x
-
reverse
"
"
Olleh
Dlrow
"
)
(
"
eo
"
"
Saluton
Mondo
"
)
(
"
fa
"
"
"
)
(
"
fi
"
"
hei
maailma
"
)
(
"
is
"
"
Hall
heimur
"
)
(
"
ja
"
"
"
)
(
"
ja
-
x
-
reverse
"
"
"
)
(
"
la
"
"
Ave
munde
"
)
(
"
pt
"
"
Ol
mundo
"
)
(
"
ro
"
"
Salut
lume
"
)
(
"
ru
"
"
"
)
(
"
sr
"
"
"
)
(
"
sr
-
Latn
"
"
Pozdrav
svete
"
)
(
"
vi
"
"
Xin
ch
o
th
gi
i
"
)
(
"
zh
"
"
"
)
]
;
#
[
cfg
(
feature
=
"
deserialize_json
"
)
]
pub
fn
into_json_provider
(
self
)
-
>
HelloWorldJsonProvider
{
HelloWorldJsonProvider
}
}
impl
DataProvider
<
HelloWorldV1Marker
>
for
HelloWorldProvider
{
fn
load
(
&
self
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
HelloWorldV1Marker
>
DataError
>
{
#
[
allow
(
clippy
:
:
indexing_slicing
)
]
let
data
=
Self
:
:
DATA
.
binary_search_by
(
|
(
k
_
)
|
req
.
locale
.
strict_cmp
(
k
.
as_bytes
(
)
)
.
reverse
(
)
)
.
map
(
|
i
|
Self
:
:
DATA
[
i
]
.
1
)
.
map_err
(
|
_
|
DataErrorKind
:
:
MissingLocale
.
with_req
(
HelloWorldV1Marker
:
:
KEY
req
)
)
?
;
Ok
(
DataResponse
{
metadata
:
Default
:
:
default
(
)
payload
:
Some
(
DataPayload
:
:
from_static_str
(
data
)
)
}
)
}
}
impl
DataPayload
<
HelloWorldV1Marker
>
{
pub
fn
from_static_str
(
s
:
&
'
static
str
)
-
>
DataPayload
<
HelloWorldV1Marker
>
{
DataPayload
:
:
from_owned
(
HelloWorldV1
{
message
:
Cow
:
:
Borrowed
(
s
)
}
)
}
}
#
[
cfg
(
not
(
feature
=
"
datagen
"
)
)
]
icu_provider
:
:
impl_dynamic_data_provider
!
(
HelloWorldProvider
[
HelloWorldV1Marker
]
AnyMarker
)
;
#
[
cfg
(
feature
=
"
deserialize_json
"
)
]
#
[
derive
(
Debug
)
]
pub
struct
HelloWorldJsonProvider
;
#
[
cfg
(
feature
=
"
deserialize_json
"
)
]
impl
BufferProvider
for
HelloWorldJsonProvider
{
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
key
.
match_key
(
HelloWorldV1Marker
:
:
KEY
)
?
;
let
result
=
HelloWorldProvider
.
load
(
req
)
?
;
let
(
mut
metadata
old_payload
)
=
DataResponse
:
:
<
HelloWorldV1Marker
>
:
:
take_metadata_and_payload
(
result
)
?
;
metadata
.
buffer_format
=
Some
(
icu_provider
:
:
buf
:
:
BufferFormat
:
:
Json
)
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
Ok
(
DataResponse
{
metadata
payload
:
Some
(
DataPayload
:
:
from_owned_buffer
(
serde_json
:
:
to_string
(
old_payload
.
get
(
)
)
.
unwrap
(
)
.
into_bytes
(
)
.
into_boxed_slice
(
)
)
)
}
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
icu_provider
:
:
datagen
:
:
IterableDataProvider
<
HelloWorldV1Marker
>
for
HelloWorldProvider
{
fn
supported_locales
(
&
self
)
-
>
Result
<
Vec
<
DataLocale
>
DataError
>
{
#
[
allow
(
clippy
:
:
unwrap_used
)
]
Ok
(
Self
:
:
DATA
.
iter
(
)
.
map
(
|
(
s
_
)
|
s
.
parse
(
)
.
unwrap
(
)
)
.
collect
(
)
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
icu_provider
:
:
make_exportable_provider
!
(
HelloWorldProvider
[
HelloWorldV1Marker
]
)
;
#
[
derive
(
Debug
)
]
pub
struct
HelloWorldFormatter
{
data
:
DataPayload
<
HelloWorldV1Marker
>
}
#
[
derive
(
Debug
)
]
pub
struct
FormattedHelloWorld
<
'
l
>
{
data
:
&
'
l
HelloWorldV1
<
'
l
>
}
impl
HelloWorldFormatter
{
pub
fn
try_new
(
locale
:
&
DataLocale
)
-
>
Result
<
Self
DataError
>
{
Self
:
:
try_new_unstable
(
&
HelloWorldProvider
locale
)
}
icu_provider
:
:
gen_any_buffer_data_constructors
!
(
locale
:
include
options
:
skip
error
:
DataError
#
[
cfg
(
skip
)
]
functions
:
[
try_new
try_new_with_any_provider
try_new_with_buffer_provider
try_new_unstable
Self
]
)
;
#
[
doc
=
icu_provider
:
:
gen_any_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
try_new
)
]
pub
fn
try_new_unstable
<
P
>
(
provider
:
&
P
locale
:
&
DataLocale
)
-
>
Result
<
Self
DataError
>
where
P
:
DataProvider
<
HelloWorldV1Marker
>
{
let
data
=
provider
.
load
(
DataRequest
{
locale
metadata
:
Default
:
:
default
(
)
}
)
?
.
take_payload
(
)
?
;
Ok
(
Self
{
data
}
)
}
#
[
allow
(
clippy
:
:
needless_lifetimes
)
]
pub
fn
format
<
'
l
>
(
&
'
l
self
)
-
>
FormattedHelloWorld
<
'
l
>
{
FormattedHelloWorld
{
data
:
self
.
data
.
get
(
)
}
}
pub
fn
format_to_string
(
&
self
)
-
>
String
{
self
.
format
(
)
.
write_to_string
(
)
.
into_owned
(
)
}
}
impl
<
'
l
>
Writeable
for
FormattedHelloWorld
<
'
l
>
{
fn
write_to
<
W
:
core
:
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
sink
:
&
mut
W
)
-
>
core
:
:
fmt
:
:
Result
{
self
.
data
.
message
.
write_to
(
sink
)
}
fn
write_to_string
(
&
self
)
-
>
Cow
<
str
>
{
self
.
data
.
message
.
clone
(
)
}
fn
writeable_length_hint
(
&
self
)
-
>
writeable
:
:
LengthHint
{
self
.
data
.
message
.
writeable_length_hint
(
)
}
}
writeable
:
:
impl_display_with_writeable
!
(
FormattedHelloWorld
<
'
_
>
)
;
#
[
cfg
(
feature
=
"
datagen
"
)
]
#
[
test
]
fn
test_iter
(
)
{
use
crate
:
:
datagen
:
:
IterableDataProvider
;
use
icu_locid
:
:
locale
;
assert_eq
!
(
HelloWorldProvider
.
supported_locales
(
)
.
unwrap
(
)
vec
!
[
locale
!
(
"
bn
"
)
.
into
(
)
locale
!
(
"
cs
"
)
.
into
(
)
locale
!
(
"
de
"
)
.
into
(
)
locale
!
(
"
de
-
AT
"
)
.
into
(
)
locale
!
(
"
el
"
)
.
into
(
)
locale
!
(
"
en
"
)
.
into
(
)
locale
!
(
"
en
-
001
"
)
.
into
(
)
locale
!
(
"
en
-
002
"
)
.
into
(
)
locale
!
(
"
en
-
019
"
)
.
into
(
)
locale
!
(
"
en
-
142
"
)
.
into
(
)
locale
!
(
"
en
-
GB
"
)
.
into
(
)
locale
!
(
"
en
-
GB
-
u
-
sd
-
gbeng
"
)
.
into
(
)
"
en
-
x
-
reverse
"
.
parse
(
)
.
unwrap
(
)
locale
!
(
"
eo
"
)
.
into
(
)
locale
!
(
"
fa
"
)
.
into
(
)
locale
!
(
"
fi
"
)
.
into
(
)
locale
!
(
"
is
"
)
.
into
(
)
locale
!
(
"
ja
"
)
.
into
(
)
"
ja
-
x
-
reverse
"
.
parse
(
)
.
unwrap
(
)
locale
!
(
"
la
"
)
.
into
(
)
locale
!
(
"
pt
"
)
.
into
(
)
locale
!
(
"
ro
"
)
.
into
(
)
locale
!
(
"
ru
"
)
.
into
(
)
locale
!
(
"
sr
"
)
.
into
(
)
locale
!
(
"
sr
-
Latn
"
)
.
into
(
)
locale
!
(
"
vi
"
)
.
into
(
)
locale
!
(
"
zh
"
)
.
into
(
)
]
)
;
}
