#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
borrow
:
:
Cow
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
borrow
:
:
ToOwned
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
default
:
:
Default
;
use
core
:
:
fmt
;
use
core
:
:
fmt
:
:
Debug
;
use
core
:
:
hash
:
:
Hash
;
use
core
:
:
ops
:
:
Deref
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
zerovec
:
:
ule
:
:
VarULE
;
pub
use
icu_locale_core
:
:
DataLocale
;
#
[
derive
(
Default
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
DataRequest
<
'
a
>
{
pub
id
:
DataIdentifierBorrowed
<
'
a
>
pub
metadata
:
DataRequestMetadata
}
#
[
derive
(
Default
Debug
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
)
]
#
[
non_exhaustive
]
pub
struct
DataRequestMetadata
{
pub
silent
:
bool
pub
attributes_prefix_match
:
bool
}
#
[
derive
(
Default
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
struct
DataIdentifierBorrowed
<
'
a
>
{
pub
marker_attributes
:
&
'
a
DataMarkerAttributes
pub
locale
:
&
'
a
DataLocale
}
impl
fmt
:
:
Display
for
DataIdentifierBorrowed
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
.
locale
f
)
?
;
if
!
self
.
marker_attributes
.
is_empty
(
)
{
write
!
(
f
"
/
{
}
"
self
.
marker_attributes
.
as_str
(
)
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
'
a
>
DataIdentifierBorrowed
<
'
a
>
{
pub
fn
for_locale
(
locale
:
&
'
a
DataLocale
)
-
>
Self
{
Self
{
locale
.
.
Default
:
:
default
(
)
}
}
pub
fn
for_marker_attributes
(
marker_attributes
:
&
'
a
DataMarkerAttributes
)
-
>
Self
{
Self
{
marker_attributes
.
.
Default
:
:
default
(
)
}
}
pub
fn
for_marker_attributes_and_locale
(
marker_attributes
:
&
'
a
DataMarkerAttributes
locale
:
&
'
a
DataLocale
)
-
>
Self
{
Self
{
marker_attributes
locale
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
into_owned
(
self
)
-
>
DataIdentifierCow
<
'
static
>
{
DataIdentifierCow
{
marker_attributes
:
Cow
:
:
Owned
(
self
.
marker_attributes
.
to_owned
(
)
)
locale
:
*
self
.
locale
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
as_cow
(
self
)
-
>
DataIdentifierCow
<
'
a
>
{
DataIdentifierCow
{
marker_attributes
:
Cow
:
:
Borrowed
(
self
.
marker_attributes
)
locale
:
*
self
.
locale
}
}
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Clone
)
]
#
[
non_exhaustive
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
DataIdentifierCow
<
'
a
>
{
pub
marker_attributes
:
Cow
<
'
a
DataMarkerAttributes
>
pub
locale
:
DataLocale
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialOrd
for
DataIdentifierCow
<
'
_
>
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Ord
for
DataIdentifierCow
<
'
_
>
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
self
.
marker_attributes
.
cmp
(
&
other
.
marker_attributes
)
.
then_with
(
|
|
self
.
locale
.
total_cmp
(
&
other
.
locale
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
fmt
:
:
Display
for
DataIdentifierCow
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
locale
f
)
?
;
if
!
self
.
marker_attributes
.
is_empty
(
)
{
write
!
(
f
"
/
{
}
"
self
.
marker_attributes
.
as_str
(
)
)
?
;
}
Ok
(
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
DataIdentifierCow
<
'
a
>
{
pub
fn
as_borrowed
(
&
'
a
self
)
-
>
DataIdentifierBorrowed
<
'
a
>
{
DataIdentifierBorrowed
{
marker_attributes
:
&
self
.
marker_attributes
locale
:
&
self
.
locale
}
}
pub
fn
from_locale
(
locale
:
DataLocale
)
-
>
Self
{
Self
{
marker_attributes
:
Cow
:
:
Borrowed
(
DataMarkerAttributes
:
:
empty
(
)
)
locale
}
}
pub
fn
from_marker_attributes
(
marker_attributes
:
&
'
a
DataMarkerAttributes
)
-
>
Self
{
Self
{
marker_attributes
:
Cow
:
:
Borrowed
(
marker_attributes
)
locale
:
Default
:
:
default
(
)
}
}
pub
fn
from_marker_attributes_owned
(
marker_attributes
:
Box
<
DataMarkerAttributes
>
)
-
>
Self
{
Self
{
marker_attributes
:
Cow
:
:
Owned
(
marker_attributes
)
locale
:
Default
:
:
default
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
from_owned
(
marker_attributes
:
Box
<
DataMarkerAttributes
>
locale
:
DataLocale
)
-
>
Self
{
Self
{
marker_attributes
:
Cow
:
:
Owned
(
marker_attributes
)
locale
}
}
pub
fn
from_borrowed_and_owned
(
marker_attributes
:
&
'
a
DataMarkerAttributes
locale
:
DataLocale
)
-
>
Self
{
Self
{
marker_attributes
:
Cow
:
:
Borrowed
(
marker_attributes
)
locale
}
}
pub
fn
is_unknown
(
&
self
)
-
>
bool
{
self
.
marker_attributes
.
is_empty
(
)
&
&
self
.
locale
.
is_unknown
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Default
for
DataIdentifierCow
<
'
_
>
{
fn
default
(
)
-
>
Self
{
Self
{
marker_attributes
:
Cow
:
:
Borrowed
(
Default
:
:
default
(
)
)
locale
:
Default
:
:
default
(
)
}
}
}
#
[
derive
(
PartialEq
Eq
Ord
PartialOrd
Hash
)
]
#
[
repr
(
transparent
)
]
pub
struct
DataMarkerAttributes
{
value
:
str
}
impl
Default
for
&
DataMarkerAttributes
{
fn
default
(
)
-
>
Self
{
DataMarkerAttributes
:
:
empty
(
)
}
}
impl
Deref
for
DataMarkerAttributes
{
type
Target
=
str
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
value
}
}
impl
Debug
for
DataMarkerAttributes
{
#
[
inline
]
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
value
.
fmt
(
f
)
}
}
#
[
derive
(
Debug
)
]
#
[
non_exhaustive
]
pub
struct
AttributeParseError
;
impl
DataMarkerAttributes
{
const
fn
validate
(
s
:
&
[
u8
]
)
-
>
Result
<
(
)
AttributeParseError
>
{
let
mut
i
=
0
;
while
i
<
s
.
len
(
)
{
#
[
allow
(
clippy
:
:
indexing_slicing
)
]
if
!
matches
!
(
s
[
i
]
b
'
a
'
.
.
=
b
'
z
'
|
b
'
A
'
.
.
=
b
'
Z
'
|
b
'
0
'
.
.
=
b
'
9
'
|
b
'
-
'
|
b
'
_
'
)
{
return
Err
(
AttributeParseError
)
;
}
i
+
=
1
;
}
Ok
(
(
)
)
}
pub
const
fn
try_from_str
(
s
:
&
str
)
-
>
Result
<
&
Self
AttributeParseError
>
{
Self
:
:
try_from_utf8
(
s
.
as_bytes
(
)
)
}
pub
const
fn
try_from_utf8
(
code_units
:
&
[
u8
]
)
-
>
Result
<
&
Self
AttributeParseError
>
{
let
Ok
(
(
)
)
=
Self
:
:
validate
(
code_units
)
else
{
return
Err
(
AttributeParseError
)
;
}
;
let
s
=
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
code_units
)
}
;
Ok
(
unsafe
{
&
*
(
s
as
*
const
str
as
*
const
Self
)
}
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
try_from_string
(
s
:
String
)
-
>
Result
<
Box
<
Self
>
AttributeParseError
>
{
let
Ok
(
(
)
)
=
Self
:
:
validate
(
s
.
as_bytes
(
)
)
else
{
return
Err
(
AttributeParseError
)
;
}
;
Ok
(
unsafe
{
core
:
:
mem
:
:
transmute
:
:
<
Box
<
str
>
Box
<
Self
>
>
(
s
.
into_boxed_str
(
)
)
}
)
}
pub
const
fn
from_str_or_panic
(
s
:
&
str
)
-
>
&
Self
{
let
Ok
(
r
)
=
Self
:
:
try_from_str
(
s
)
else
{
panic
!
(
"
Invalid
marker
attribute
syntax
"
)
}
;
r
}
pub
const
fn
empty
(
)
-
>
&
'
static
Self
{
unsafe
{
&
*
(
"
"
as
*
const
str
as
*
const
Self
)
}
}
pub
const
fn
as_str
(
&
self
)
-
>
&
str
{
&
self
.
value
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ToOwned
for
DataMarkerAttributes
{
type
Owned
=
Box
<
Self
>
;
fn
to_owned
(
&
self
)
-
>
Self
:
:
Owned
{
unsafe
{
core
:
:
mem
:
:
transmute
:
:
<
Box
<
str
>
Box
<
Self
>
>
(
self
.
as_str
(
)
.
to_boxed
(
)
)
}
}
}
#
[
test
]
fn
test_data_marker_attributes_from_utf8
(
)
{
let
bytes_vec
:
Vec
<
&
[
u8
]
>
=
vec
!
[
b
"
long
-
meter
"
b
"
long
"
b
"
meter
"
b
"
short
-
meter
-
second
"
b
"
usd
"
]
;
for
bytes
in
bytes_vec
{
let
marker
=
DataMarkerAttributes
:
:
try_from_utf8
(
bytes
)
.
unwrap
(
)
;
assert_eq
!
(
marker
.
to_string
(
)
.
as_bytes
(
)
bytes
)
;
}
}
