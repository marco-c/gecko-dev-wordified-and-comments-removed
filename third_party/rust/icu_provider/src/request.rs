use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
default
:
:
Default
;
use
core
:
:
fmt
;
use
core
:
:
fmt
:
:
Debug
;
use
icu_locid
:
:
extensions
:
:
unicode
as
unicode_ext
;
use
icu_locid
:
:
subtags
:
:
{
Language
Region
Script
Variants
}
;
use
icu_locid
:
:
{
LanguageIdentifier
Locale
SubtagOrderingResult
}
;
use
writeable
:
:
{
LengthHint
Writeable
}
;
#
[
cfg
(
doc
)
]
use
icu_locid
:
:
subtags
:
:
Variant
;
#
[
derive
(
Default
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
DataRequest
<
'
a
>
{
pub
locale
:
&
'
a
DataLocale
pub
metadata
:
DataRequestMetadata
}
impl
fmt
:
:
Display
for
DataRequest
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
locale
f
)
}
}
#
[
derive
(
Default
Debug
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
)
]
#
[
non_exhaustive
]
pub
struct
DataRequestMetadata
{
pub
silent
:
bool
}
#
[
derive
(
PartialEq
Clone
Default
Eq
Hash
)
]
pub
struct
DataLocale
{
langid
:
LanguageIdentifier
keywords
:
unicode_ext
:
:
Keywords
}
impl
<
'
a
>
Default
for
&
'
a
DataLocale
{
fn
default
(
)
-
>
Self
{
static
DEFAULT
:
DataLocale
=
DataLocale
{
langid
:
LanguageIdentifier
:
:
UND
keywords
:
unicode_ext
:
:
Keywords
:
:
new
(
)
}
;
&
DEFAULT
}
}
impl
fmt
:
:
Debug
for
DataLocale
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
DataLocale
{
{
{
self
}
}
}
"
)
}
}
impl
Writeable
for
DataLocale
{
fn
write_to
<
W
:
core
:
:
fmt
:
:
Write
+
?
Sized
>
(
&
self
sink
:
&
mut
W
)
-
>
core
:
:
fmt
:
:
Result
{
self
.
langid
.
write_to
(
sink
)
?
;
if
!
self
.
keywords
.
is_empty
(
)
{
sink
.
write_str
(
"
-
u
-
"
)
?
;
self
.
keywords
.
write_to
(
sink
)
?
;
}
Ok
(
(
)
)
}
fn
writeable_length_hint
(
&
self
)
-
>
LengthHint
{
self
.
langid
.
writeable_length_hint
(
)
+
if
!
self
.
keywords
.
is_empty
(
)
{
self
.
keywords
.
writeable_length_hint
(
)
+
3
}
else
{
LengthHint
:
:
exact
(
0
)
}
}
fn
write_to_string
(
&
self
)
-
>
alloc
:
:
borrow
:
:
Cow
<
str
>
{
if
self
.
keywords
.
is_empty
(
)
{
return
self
.
langid
.
write_to_string
(
)
;
}
let
mut
string
=
alloc
:
:
string
:
:
String
:
:
with_capacity
(
self
.
writeable_length_hint
(
)
.
capacity
(
)
)
;
let
_
=
self
.
write_to
(
&
mut
string
)
;
alloc
:
:
borrow
:
:
Cow
:
:
Owned
(
string
)
}
}
writeable
:
:
impl_display_with_writeable
!
(
DataLocale
)
;
impl
From
<
LanguageIdentifier
>
for
DataLocale
{
fn
from
(
langid
:
LanguageIdentifier
)
-
>
Self
{
Self
{
langid
keywords
:
unicode_ext
:
:
Keywords
:
:
new
(
)
}
}
}
impl
From
<
Locale
>
for
DataLocale
{
fn
from
(
locale
:
Locale
)
-
>
Self
{
Self
{
langid
:
locale
.
id
keywords
:
locale
.
extensions
.
unicode
.
keywords
}
}
}
impl
From
<
&
LanguageIdentifier
>
for
DataLocale
{
fn
from
(
langid
:
&
LanguageIdentifier
)
-
>
Self
{
Self
{
langid
:
langid
.
clone
(
)
keywords
:
unicode_ext
:
:
Keywords
:
:
new
(
)
}
}
}
impl
From
<
&
Locale
>
for
DataLocale
{
fn
from
(
locale
:
&
Locale
)
-
>
Self
{
Self
{
langid
:
locale
.
id
.
clone
(
)
keywords
:
locale
.
extensions
.
unicode
.
keywords
.
clone
(
)
}
}
}
impl
DataLocale
{
pub
fn
strict_cmp
(
&
self
other
:
&
[
u8
]
)
-
>
Ordering
{
let
subtags
=
other
.
split
(
|
b
|
*
b
=
=
b
'
-
'
)
;
let
mut
subtag_result
=
self
.
langid
.
strict_cmp_iter
(
subtags
)
;
if
self
.
has_unicode_ext
(
)
{
let
mut
subtags
=
match
subtag_result
{
SubtagOrderingResult
:
:
Subtags
(
s
)
=
>
s
SubtagOrderingResult
:
:
Ordering
(
o
)
=
>
return
o
}
;
match
subtags
.
next
(
)
{
Some
(
b
"
u
"
)
=
>
(
)
Some
(
s
)
=
>
return
s
.
cmp
(
b
"
u
"
)
.
reverse
(
)
None
=
>
return
Ordering
:
:
Greater
}
subtag_result
=
self
.
keywords
.
strict_cmp_iter
(
subtags
)
;
}
subtag_result
.
end
(
)
}
}
impl
DataLocale
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
=
=
<
&
DataLocale
>
:
:
default
(
)
}
pub
fn
is_langid_und
(
&
self
)
-
>
bool
{
self
.
langid
=
=
LanguageIdentifier
:
:
UND
}
pub
fn
get_langid
(
&
self
)
-
>
LanguageIdentifier
{
self
.
langid
.
clone
(
)
}
#
[
inline
]
pub
fn
set_langid
(
&
mut
self
lid
:
LanguageIdentifier
)
{
self
.
langid
=
lid
;
}
pub
fn
into_locale
(
self
)
-
>
Locale
{
let
mut
loc
=
Locale
{
id
:
self
.
langid
.
.
Default
:
:
default
(
)
}
;
loc
.
extensions
.
unicode
.
keywords
=
self
.
keywords
;
loc
}
#
[
inline
]
pub
fn
language
(
&
self
)
-
>
Language
{
self
.
langid
.
language
}
#
[
inline
]
pub
fn
set_language
(
&
mut
self
language
:
Language
)
{
self
.
langid
.
language
=
language
;
}
#
[
inline
]
pub
fn
script
(
&
self
)
-
>
Option
<
Script
>
{
self
.
langid
.
script
}
#
[
inline
]
pub
fn
set_script
(
&
mut
self
script
:
Option
<
Script
>
)
{
self
.
langid
.
script
=
script
;
}
#
[
inline
]
pub
fn
region
(
&
self
)
-
>
Option
<
Region
>
{
self
.
langid
.
region
}
#
[
inline
]
pub
fn
set_region
(
&
mut
self
region
:
Option
<
Region
>
)
{
self
.
langid
.
region
=
region
;
}
#
[
inline
]
pub
fn
has_variants
(
&
self
)
-
>
bool
{
!
self
.
langid
.
variants
.
is_empty
(
)
}
#
[
inline
]
pub
fn
set_variants
(
&
mut
self
variants
:
Variants
)
{
self
.
langid
.
variants
=
variants
;
}
#
[
inline
]
pub
fn
clear_variants
(
&
mut
self
)
-
>
Variants
{
self
.
langid
.
variants
.
clear
(
)
}
#
[
inline
]
pub
fn
get_unicode_ext
(
&
self
key
:
&
unicode_ext
:
:
Key
)
-
>
Option
<
unicode_ext
:
:
Value
>
{
self
.
keywords
.
get
(
key
)
.
cloned
(
)
}
#
[
inline
]
pub
fn
has_unicode_ext
(
&
self
)
-
>
bool
{
!
self
.
keywords
.
is_empty
(
)
}
#
[
inline
]
pub
fn
contains_unicode_ext
(
&
self
key
:
&
unicode_ext
:
:
Key
)
-
>
bool
{
self
.
keywords
.
contains_key
(
key
)
}
#
[
inline
]
pub
fn
matches_unicode_ext
(
&
self
key
:
&
unicode_ext
:
:
Key
value
:
&
unicode_ext
:
:
Value
)
-
>
bool
{
self
.
keywords
.
get
(
key
)
=
=
Some
(
value
)
}
#
[
inline
]
pub
fn
set_unicode_ext
(
&
mut
self
key
:
unicode_ext
:
:
Key
value
:
unicode_ext
:
:
Value
)
-
>
Option
<
unicode_ext
:
:
Value
>
{
self
.
keywords
.
set
(
key
value
)
}
#
[
inline
]
pub
fn
remove_unicode_ext
(
&
mut
self
key
:
&
unicode_ext
:
:
Key
)
-
>
Option
<
unicode_ext
:
:
Value
>
{
self
.
keywords
.
remove
(
key
)
}
#
[
inline
]
pub
fn
retain_unicode_ext
<
F
>
(
&
mut
self
predicate
:
F
)
where
F
:
FnMut
(
&
unicode_ext
:
:
Key
)
-
>
bool
{
self
.
keywords
.
retain_by_key
(
predicate
)
}
}
#
[
test
]
fn
test_data_locale_to_string
(
)
{
use
icu_locid
:
:
locale
;
struct
TestCase
{
pub
locale
:
DataLocale
pub
expected
:
&
'
static
str
}
for
cas
in
[
TestCase
{
locale
:
Locale
:
:
UND
.
into
(
)
expected
:
"
und
"
}
TestCase
{
locale
:
locale
!
(
"
und
-
u
-
cu
-
gbp
"
)
.
into
(
)
expected
:
"
und
-
u
-
cu
-
gbp
"
}
TestCase
{
locale
:
locale
!
(
"
en
-
ZA
-
u
-
cu
-
gbp
"
)
.
into
(
)
expected
:
"
en
-
ZA
-
u
-
cu
-
gbp
"
}
]
{
writeable
:
:
assert_writeable_eq
!
(
cas
.
locale
cas
.
expected
)
;
}
}
