use
crate
:
:
prelude
:
:
*
;
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
#
[
derive
(
Debug
)
]
pub
struct
BufferMarker
;
impl
DataMarker
for
BufferMarker
{
type
Yokeable
=
&
'
static
[
u8
]
;
}
pub
trait
BufferProvider
{
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
;
}
impl
<
'
a
T
:
BufferProvider
+
?
Sized
>
BufferProvider
for
&
'
a
T
{
#
[
inline
]
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
(
*
*
self
)
.
load_buffer
(
key
req
)
}
}
impl
<
T
:
BufferProvider
+
?
Sized
>
BufferProvider
for
alloc
:
:
boxed
:
:
Box
<
T
>
{
#
[
inline
]
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
(
*
*
self
)
.
load_buffer
(
key
req
)
}
}
impl
<
T
:
BufferProvider
+
?
Sized
>
BufferProvider
for
alloc
:
:
rc
:
:
Rc
<
T
>
{
#
[
inline
]
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
(
*
*
self
)
.
load_buffer
(
key
req
)
}
}
#
[
cfg
(
target_has_atomic
=
"
ptr
"
)
]
impl
<
T
:
BufferProvider
+
?
Sized
>
BufferProvider
for
alloc
:
:
sync
:
:
Arc
<
T
>
{
#
[
inline
]
fn
load_buffer
(
&
self
key
:
DataKey
req
:
DataRequest
)
-
>
Result
<
DataResponse
<
BufferMarker
>
DataError
>
{
(
*
*
self
)
.
load_buffer
(
key
req
)
}
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
enum
BufferFormat
{
Json
Bincode1
Postcard1
}
impl
BufferFormat
{
pub
fn
check_available
(
&
self
)
-
>
Result
<
(
)
DataError
>
{
match
self
{
#
[
cfg
(
feature
=
"
deserialize_json
"
)
]
BufferFormat
:
:
Json
=
>
Ok
(
(
)
)
#
[
cfg
(
feature
=
"
deserialize_bincode_1
"
)
]
BufferFormat
:
:
Bincode1
=
>
Ok
(
(
)
)
#
[
cfg
(
feature
=
"
deserialize_postcard_1
"
)
]
BufferFormat
:
:
Postcard1
=
>
Ok
(
(
)
)
#
[
allow
(
unreachable_patterns
)
]
_
=
>
Err
(
DataErrorKind
:
:
UnavailableBufferFormat
(
*
self
)
.
into_error
(
)
)
}
}
}
