pub
trait
UpcastDataPayload
<
M
>
where
M
:
crate
:
:
DataMarker
Self
:
Sized
+
crate
:
:
DataMarker
{
fn
upcast
(
other
:
crate
:
:
DataPayload
<
M
>
)
-
>
crate
:
:
DataPayload
<
Self
>
;
}
#
[
macro_export
]
macro_rules
!
impl_casting_upcast
{
(
dyn_m
:
path
[
(
struct_m
:
ident
)
+
]
)
=
>
{
(
impl
crate
:
:
dynutil
:
:
UpcastDataPayload
<
struct_m
>
for
dyn_m
{
fn
upcast
(
other
:
crate
:
:
DataPayload
<
struct_m
>
)
-
>
crate
:
:
DataPayload
<
dyn_m
>
{
other
.
cast
(
)
}
}
)
+
}
}
#
[
macro_export
]
macro_rules
!
impl_dynamic_data_provider
{
(
provider
:
ty
arms
:
tt
one
:
path
(
rest
:
path
)
+
)
=
>
{
crate
:
:
impl_dynamic_data_provider
!
(
provider
arms
one
)
;
crate
:
:
impl_dynamic_data_provider
!
(
provider
arms
(
rest
)
+
)
;
}
;
(
provider
:
ty
{
(
ident
:
ident
=
key
:
path
=
>
struct_m
:
ty
)
+
(
_
=
>
struct_d
:
ty
)
?
}
dyn_m
:
ty
)
=
>
{
impl
crate
:
:
DynamicDataProvider
<
dyn_m
>
for
provider
{
fn
load_data
(
&
self
key
:
crate
:
:
DataKey
req
:
crate
:
:
DataRequest
)
-
>
Result
<
crate
:
:
DataResponse
<
dyn_m
>
crate
:
:
DataError
>
{
(
const
ident
:
crate
:
:
DataKeyHash
=
key
.
hashed
(
)
;
)
+
match
key
.
hashed
(
)
{
(
ident
=
>
{
let
result
:
crate
:
:
DataResponse
<
struct_m
>
=
crate
:
:
DynamicDataProvider
:
:
<
struct_m
>
:
:
load_data
(
self
key
req
)
?
;
Ok
(
crate
:
:
DataResponse
{
metadata
:
result
.
metadata
payload
:
result
.
payload
.
map
(
|
p
|
{
crate
:
:
dynutil
:
:
UpcastDataPayload
:
:
<
struct_m
>
:
:
upcast
(
p
)
}
)
}
)
}
)
+
(
_
=
>
{
let
result
:
crate
:
:
DataResponse
<
struct_d
>
=
crate
:
:
DynamicDataProvider
:
:
<
struct_d
>
:
:
load_data
(
self
key
req
)
?
;
Ok
(
crate
:
:
DataResponse
{
metadata
:
result
.
metadata
payload
:
result
.
payload
.
map
(
|
p
|
{
crate
:
:
dynutil
:
:
UpcastDataPayload
:
:
<
struct_d
>
:
:
upcast
(
p
)
}
)
}
)
}
)
?
_
=
>
Err
(
crate
:
:
DataErrorKind
:
:
MissingDataKey
.
with_req
(
key
req
)
)
}
}
}
}
;
(
provider
:
ty
[
(
struct_m
:
ident
)
+
]
dyn_m
:
path
)
=
>
{
impl
crate
:
:
DynamicDataProvider
<
dyn_m
>
for
provider
{
fn
load_data
(
&
self
key
:
crate
:
:
DataKey
req
:
crate
:
:
DataRequest
)
-
>
Result
<
crate
:
:
DataResponse
<
dyn_m
>
crate
:
:
DataError
>
{
#
!
[
allow
(
non_upper_case_globals
)
]
/
/
Reusing
the
struct
names
as
identifiers
(
const
struct_m
:
crate
:
:
DataKeyHash
=
struct_m
:
:
KEY
.
hashed
(
)
;
)
+
match
key
.
hashed
(
)
{
(
struct_m
=
>
{
let
result
:
crate
:
:
DataResponse
<
struct_m
>
=
crate
:
:
DataProvider
:
:
load
(
self
req
)
?
;
Ok
(
crate
:
:
DataResponse
{
metadata
:
result
.
metadata
payload
:
result
.
payload
.
map
(
|
p
|
{
crate
:
:
dynutil
:
:
UpcastDataPayload
:
:
<
struct_m
>
:
:
upcast
(
p
)
}
)
}
)
}
)
+
_
=
>
Err
(
crate
:
:
DataErrorKind
:
:
MissingDataKey
.
with_req
(
key
req
)
)
}
}
}
}
;
}
