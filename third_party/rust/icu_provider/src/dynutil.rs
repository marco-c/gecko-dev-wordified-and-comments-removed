pub
trait
UpcastDataPayload
<
M
>
where
M
:
crate
:
:
DynamicDataMarker
Self
:
Sized
+
crate
:
:
DynamicDataMarker
{
fn
upcast
(
other
:
crate
:
:
DataPayload
<
M
>
)
-
>
crate
:
:
DataPayload
<
Self
>
;
}
#
[
macro_export
]
#
[
doc
(
hidden
)
]
macro_rules
!
__impl_casting_upcast
{
(
dyn_m
:
path
[
(
struct_m
:
ident
)
+
]
)
=
>
{
(
impl
crate
:
:
dynutil
:
:
UpcastDataPayload
<
struct_m
>
for
dyn_m
{
fn
upcast
(
other
:
crate
:
:
DataPayload
<
struct_m
>
)
-
>
crate
:
:
DataPayload
<
dyn_m
>
{
other
.
cast
(
)
}
}
)
+
}
}
#
[
doc
(
inline
)
]
pub
use
__impl_casting_upcast
as
impl_casting_upcast
;
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__impl_dynamic_data_provider
{
(
provider
:
ty
arms
:
tt
one
:
path
(
rest
:
path
)
+
)
=
>
{
crate
:
:
dynutil
:
:
impl_dynamic_data_provider
!
(
provider
arms
one
)
;
crate
:
:
dynutil
:
:
impl_dynamic_data_provider
!
(
provider
arms
(
rest
)
+
)
;
}
;
(
provider
:
ty
{
(
ident
:
ident
=
marker
:
path
=
>
struct_m
:
ty
)
+
(
_
=
>
struct_d
:
ty
)
?
}
dyn_m
:
ty
)
=
>
{
impl
crate
:
:
DynamicDataProvider
<
dyn_m
>
for
provider
{
fn
load_data
(
&
self
marker
:
crate
:
:
DataMarkerInfo
req
:
crate
:
:
DataRequest
)
-
>
Result
<
crate
:
:
DataResponse
<
dyn_m
>
crate
:
:
DataError
>
{
match
marker
.
id
.
hashed
(
)
{
(
h
if
h
=
=
marker
.
id
.
hashed
(
)
=
>
{
let
result
:
crate
:
:
DataResponse
<
struct_m
>
=
crate
:
:
DynamicDataProvider
:
:
<
struct_m
>
:
:
load_data
(
self
marker
req
)
?
;
Ok
(
crate
:
:
DataResponse
{
metadata
:
result
.
metadata
payload
:
crate
:
:
dynutil
:
:
UpcastDataPayload
:
:
<
struct_m
>
:
:
upcast
(
result
.
payload
)
}
)
}
)
+
(
_
=
>
{
let
result
:
crate
:
:
DataResponse
<
struct_d
>
=
crate
:
:
DynamicDataProvider
:
:
<
struct_d
>
:
:
load_data
(
self
marker
req
)
?
;
Ok
(
crate
:
:
DataResponse
{
metadata
:
result
.
metadata
payload
:
crate
:
:
dynutil
:
:
UpcastDataPayload
:
:
<
struct_d
>
:
:
upcast
(
result
.
payload
)
}
)
}
)
?
_
=
>
Err
(
crate
:
:
DataErrorKind
:
:
MarkerNotFound
.
with_req
(
marker
req
)
)
}
}
}
}
;
(
provider
:
ty
[
(
(
#
[
cfg
:
meta
]
)
?
struct_m
:
ty
)
+
]
dyn_m
:
path
)
=
>
{
impl
crate
:
:
DynamicDataProvider
<
dyn_m
>
for
provider
{
fn
load_data
(
&
self
marker
:
crate
:
:
DataMarkerInfo
req
:
crate
:
:
DataRequest
)
-
>
Result
<
crate
:
:
DataResponse
<
dyn_m
>
crate
:
:
DataError
>
{
match
marker
.
id
.
hashed
(
)
{
(
(
#
[
cfg
]
)
?
h
if
h
=
=
<
struct_m
as
crate
:
:
DataMarker
>
:
:
INFO
.
id
.
hashed
(
)
=
>
{
let
result
:
crate
:
:
DataResponse
<
struct_m
>
=
crate
:
:
DataProvider
:
:
load
(
self
req
)
?
;
Ok
(
crate
:
:
DataResponse
{
metadata
:
result
.
metadata
payload
:
crate
:
:
dynutil
:
:
UpcastDataPayload
:
:
<
struct_m
>
:
:
upcast
(
result
.
payload
)
}
)
}
)
+
_
=
>
Err
(
crate
:
:
DataErrorKind
:
:
MarkerNotFound
.
with_req
(
marker
req
)
)
}
}
}
}
;
}
#
[
doc
(
inline
)
]
pub
use
__impl_dynamic_data_provider
as
impl_dynamic_data_provider
;
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__impl_iterable_dynamic_data_provider
{
(
provider
:
ty
[
(
(
#
[
cfg
:
meta
]
)
?
struct_m
:
ty
)
+
]
dyn_m
:
path
)
=
>
{
impl
crate
:
:
IterableDynamicDataProvider
<
dyn_m
>
for
provider
{
fn
iter_ids_for_marker
(
&
self
marker
:
crate
:
:
DataMarkerInfo
)
-
>
Result
<
alloc
:
:
collections
:
:
BTreeSet
<
crate
:
:
DataIdentifierCow
>
crate
:
:
DataError
>
{
match
marker
.
id
.
hashed
(
)
{
(
(
#
[
cfg
]
)
?
h
if
h
=
=
<
struct_m
as
crate
:
:
DataMarker
>
:
:
INFO
.
id
.
hashed
(
)
=
>
{
crate
:
:
IterableDataProvider
:
:
<
struct_m
>
:
:
iter_ids
(
self
)
}
)
+
_
=
>
Err
(
crate
:
:
DataErrorKind
:
:
MarkerNotFound
.
with_marker
(
marker
)
)
}
}
}
}
}
#
[
doc
(
inline
)
]
pub
use
__impl_iterable_dynamic_data_provider
as
impl_iterable_dynamic_data_provider
;
