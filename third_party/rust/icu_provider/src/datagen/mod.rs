mod
data_conversion
;
mod
iter
;
mod
payload
;
pub
use
data_conversion
:
:
DataConverter
;
pub
use
iter
:
:
IterableDataProvider
;
#
[
doc
(
hidden
)
]
pub
use
iter
:
:
IterableDynamicDataProvider
;
#
[
doc
(
hidden
)
]
pub
use
payload
:
:
{
ExportBox
ExportMarker
}
;
use
crate
:
:
prelude
:
:
*
;
pub
trait
DataExporter
:
Sync
{
fn
put_payload
(
&
self
key
:
DataKey
locale
:
&
DataLocale
payload
:
&
DataPayload
<
ExportMarker
>
)
-
>
Result
<
(
)
DataError
>
;
fn
flush
(
&
self
_key
:
DataKey
)
-
>
Result
<
(
)
DataError
>
{
Ok
(
(
)
)
}
fn
close
(
&
mut
self
)
-
>
Result
<
(
)
DataError
>
{
Ok
(
(
)
)
}
}
pub
trait
ExportableProvider
:
IterableDynamicDataProvider
<
ExportMarker
>
+
Sync
{
}
impl
<
T
>
ExportableProvider
for
T
where
T
:
IterableDynamicDataProvider
<
ExportMarker
>
+
Sync
{
}
#
[
macro_export
]
macro_rules
!
make_exportable_provider
{
(
provider
:
ty
[
(
struct_m
:
ident
)
+
]
)
=
>
{
crate
:
:
impl_dynamic_data_provider
!
(
provider
[
(
struct_m
)
+
]
crate
:
:
datagen
:
:
ExportMarker
)
;
crate
:
:
impl_dynamic_data_provider
!
(
provider
[
(
struct_m
)
+
]
crate
:
:
any
:
:
AnyMarker
)
;
impl
crate
:
:
datagen
:
:
IterableDynamicDataProvider
<
crate
:
:
datagen
:
:
ExportMarker
>
for
provider
{
fn
supported_locales_for_key
(
&
self
key
:
crate
:
:
DataKey
)
-
>
Result
<
Vec
<
crate
:
:
DataLocale
>
crate
:
:
DataError
>
{
#
!
[
allow
(
non_upper_case_globals
)
]
/
/
Reusing
the
struct
names
as
identifiers
(
const
struct_m
:
crate
:
:
DataKeyHash
=
<
struct_m
as
crate
:
:
KeyedDataMarker
>
:
:
KEY
.
hashed
(
)
;
)
+
match
key
.
hashed
(
)
{
(
struct_m
=
>
{
crate
:
:
datagen
:
:
IterableDataProvider
:
:
<
struct_m
>
:
:
supported_locales
(
self
)
}
)
+
_
=
>
Err
(
crate
:
:
DataErrorKind
:
:
MissingDataKey
.
with_key
(
key
)
)
}
}
}
}
;
}
