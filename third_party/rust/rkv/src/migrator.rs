use
crate
:
:
{
backend
:
:
{
LmdbEnvironment
SafeModeEnvironment
}
error
:
:
MigrateError
Rkv
StoreOptions
}
;
pub
use
crate
:
:
backend
:
:
{
LmdbArchMigrateError
LmdbArchMigrateResult
LmdbArchMigrator
}
;
macro_rules
!
fn_migrator
{
(
name
:
tt
src_env
:
ty
dst_env
:
ty
)
=
>
{
/
/
/
Migrate
all
data
in
all
of
databases
from
the
source
environment
to
the
destination
/
/
/
environment
.
This
includes
all
key
/
value
pairs
in
the
main
database
that
aren
'
t
/
/
/
metadata
about
subdatabases
and
all
key
/
value
pairs
in
all
subdatabases
.
/
/
/
/
/
/
Other
backend
-
specific
metadata
such
as
map
size
or
maximum
databases
left
intact
on
/
/
/
the
given
environments
.
/
/
/
/
/
/
The
destination
environment
should
be
empty
of
data
otherwise
an
error
is
returned
.
pub
fn
name
<
S
D
>
(
src_env
:
S
dst_env
:
D
)
-
>
Result
<
(
)
MigrateError
>
where
S
:
std
:
:
ops
:
:
Deref
<
Target
=
Rkv
<
src_env
>
>
D
:
std
:
:
ops
:
:
Deref
<
Target
=
Rkv
<
dst_env
>
>
{
let
src_dbs
=
src_env
.
get_dbs
(
)
.
unwrap
(
)
;
if
src_dbs
.
is_empty
(
)
{
return
Err
(
MigrateError
:
:
SourceEmpty
)
;
}
let
dst_dbs
=
dst_env
.
get_dbs
(
)
.
unwrap
(
)
;
if
!
dst_dbs
.
is_empty
(
)
{
return
Err
(
MigrateError
:
:
DestinationNotEmpty
)
;
}
for
name
in
src_dbs
{
let
src_store
=
src_env
.
open_single
(
name
.
as_deref
(
)
StoreOptions
:
:
default
(
)
)
?
;
let
dst_store
=
dst_env
.
open_single
(
name
.
as_deref
(
)
StoreOptions
:
:
create
(
)
)
?
;
let
reader
=
src_env
.
read
(
)
?
;
let
mut
writer
=
dst_env
.
write
(
)
?
;
let
mut
iter
=
src_store
.
iter_start
(
&
reader
)
?
;
while
let
Some
(
Ok
(
(
key
value
)
)
)
=
iter
.
next
(
)
{
dst_store
.
put
(
&
mut
writer
key
&
value
)
.
expect
(
"
wrote
"
)
;
}
writer
.
commit
(
)
?
;
}
Ok
(
(
)
)
}
}
;
(
open
migrate
:
tt
name
:
tt
builder
:
tt
src_env
:
ty
dst_env
:
ty
)
=
>
{
/
/
/
Same
as
the
the
migrate_x_to_y
migration
method
above
but
automatically
attempts
/
/
/
to
open
the
source
environment
.
Finally
deletes
all
of
its
supporting
files
if
/
/
/
there
'
s
no
other
environment
open
at
that
path
and
the
migration
succeeded
.
pub
fn
name
<
F
D
>
(
path
:
&
std
:
:
path
:
:
Path
build
:
F
dst_env
:
D
)
-
>
Result
<
(
)
MigrateError
>
where
F
:
FnOnce
(
crate
:
:
backend
:
:
builder
)
-
>
crate
:
:
backend
:
:
builder
D
:
std
:
:
ops
:
:
Deref
<
Target
=
Rkv
<
dst_env
>
>
{
use
crate
:
:
{
backend
:
:
*
CloseOptions
}
;
let
mut
manager
=
crate
:
:
Manager
:
:
<
src_env
>
:
:
singleton
(
)
.
write
(
)
?
;
let
mut
builder
=
Rkv
:
:
<
src_env
>
:
:
environment_builder
:
:
<
builder
>
(
)
;
builder
.
set_max_dbs
(
crate
:
:
env
:
:
DEFAULT_MAX_DBS
)
;
builder
=
build
(
builder
)
;
let
src_env
=
manager
.
get_or_create_from_builder
(
path
builder
Rkv
:
:
from_builder
:
:
<
builder
>
)
?
;
Migrator
:
:
migrate
(
src_env
.
read
(
)
?
dst_env
)
?
;
drop
(
src_env
)
;
manager
.
try_close
(
path
CloseOptions
:
:
delete_files_on_disk
(
)
)
?
;
Ok
(
(
)
)
}
}
;
(
easy
migrate
:
tt
name
:
tt
src_env
:
ty
dst_env
:
ty
)
=
>
{
/
/
/
Same
as
the
open_and_migrate_x_to_y
migration
method
above
but
ignores
the
/
/
/
migration
and
doesn
'
t
delete
any
files
if
the
following
conditions
apply
:
/
/
/
-
Source
environment
is
invalid
/
corrupted
unavailable
or
empty
.
/
/
/
-
Destination
environment
is
not
empty
.
/
/
/
Use
this
instead
of
the
other
migration
methods
if
:
/
/
/
-
You
'
re
not
concerned
by
throwing
away
old
data
and
starting
fresh
with
a
new
store
.
/
/
/
-
You
'
ll
never
want
to
overwrite
data
in
the
new
store
from
the
old
store
.
pub
fn
name
<
D
>
(
path
:
&
std
:
:
path
:
:
Path
dst_env
:
D
)
-
>
Result
<
(
)
MigrateError
>
where
D
:
std
:
:
ops
:
:
Deref
<
Target
=
Rkv
<
dst_env
>
>
{
match
Migrator
:
:
migrate
(
path
|
builder
|
builder
dst_env
)
{
/
/
Source
environment
is
an
invalid
file
or
corrupted
database
.
Err
(
crate
:
:
MigrateError
:
:
StoreError
(
crate
:
:
StoreError
:
:
FileInvalid
)
)
=
>
Ok
(
(
)
)
Err
(
crate
:
:
MigrateError
:
:
StoreError
(
crate
:
:
StoreError
:
:
DatabaseCorrupted
)
)
=
>
{
Ok
(
(
)
)
}
/
/
Path
not
accessible
.
Err
(
crate
:
:
MigrateError
:
:
StoreError
(
crate
:
:
StoreError
:
:
IoError
(
_
)
)
)
=
>
Ok
(
(
)
)
/
/
Path
accessible
but
incompatible
for
configuration
.
Err
(
crate
:
:
MigrateError
:
:
StoreError
(
crate
:
:
StoreError
:
:
UnsuitableEnvironmentPath
(
_
)
)
)
=
>
Ok
(
(
)
)
/
/
Couldn
'
t
close
source
environment
and
delete
files
on
disk
(
e
.
g
.
other
stores
still
open
)
.
Err
(
crate
:
:
MigrateError
:
:
CloseError
(
_
)
)
=
>
Ok
(
(
)
)
/
/
Nothing
to
migrate
.
Err
(
crate
:
:
MigrateError
:
:
SourceEmpty
)
=
>
Ok
(
(
)
)
/
/
Migrating
would
overwrite
.
Err
(
crate
:
:
MigrateError
:
:
DestinationNotEmpty
)
=
>
Ok
(
(
)
)
result
=
>
result
}
?
;
Ok
(
(
)
)
}
}
;
}
macro_rules
!
fns_migrator
{
(
src
:
tt
dst
:
tt
)
=
>
{
paste
:
:
item
!
{
fns_migrator
!
(
[
<
migrate_
src
_to_
dst
>
]
src
dst
)
;
fns_migrator
!
(
[
<
migrate_
dst
_to_
src
>
]
dst
src
)
;
}
}
;
(
name
:
tt
src
:
tt
dst
:
tt
)
=
>
{
paste
:
:
item
!
{
fn_migrator
!
(
name
[
<
src
:
camel
Environment
>
]
[
<
dst
:
camel
Environment
>
]
)
;
fn_migrator
!
(
open
name
[
<
open_and_
name
>
]
[
<
src
:
camel
>
]
[
<
src
:
camel
Environment
>
]
[
<
dst
:
camel
Environment
>
]
)
;
fn_migrator
!
(
easy
[
<
open_and_
name
>
]
[
<
easy_
name
>
]
[
<
src
:
camel
Environment
>
]
[
<
dst
:
camel
Environment
>
]
)
;
}
}
;
}
pub
struct
Migrator
;
impl
Migrator
{
fns_migrator
!
(
lmdb
safe_mode
)
;
}
