use
lmdb
:
:
{
Database
WriteFlags
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
crate
:
:
error
:
:
StoreError
;
use
crate
:
:
readwrite
:
:
{
Readable
Writer
}
;
use
crate
:
:
value
:
:
Value
;
use
crate
:
:
store
:
:
multi
:
:
{
Iter
MultiStore
}
;
use
crate
:
:
store
:
:
integer
:
:
{
Key
PrimitiveInt
}
;
pub
struct
MultiIntegerStore
<
K
>
where
K
:
PrimitiveInt
{
inner
:
MultiStore
phantom
:
PhantomData
<
K
>
}
impl
<
K
>
MultiIntegerStore
<
K
>
where
K
:
PrimitiveInt
{
pub
(
crate
)
fn
new
(
db
:
Database
)
-
>
MultiIntegerStore
<
K
>
{
MultiIntegerStore
{
inner
:
MultiStore
:
:
new
(
db
)
phantom
:
PhantomData
}
}
pub
fn
get
<
'
env
T
:
Readable
>
(
&
self
reader
:
&
'
env
T
k
:
K
)
-
>
Result
<
Iter
<
'
env
>
StoreError
>
{
self
.
inner
.
get
(
reader
Key
:
:
new
(
&
k
)
?
)
}
pub
fn
get_first
<
'
env
T
:
Readable
>
(
&
self
reader
:
&
'
env
T
k
:
K
)
-
>
Result
<
Option
<
Value
<
'
env
>
>
StoreError
>
{
self
.
inner
.
get_first
(
reader
Key
:
:
new
(
&
k
)
?
)
}
pub
fn
put
(
&
self
writer
:
&
mut
Writer
k
:
K
v
:
&
Value
)
-
>
Result
<
(
)
StoreError
>
{
self
.
inner
.
put
(
writer
Key
:
:
new
(
&
k
)
?
v
)
}
pub
fn
put_with_flags
(
&
self
writer
:
&
mut
Writer
k
:
K
v
:
&
Value
flags
:
WriteFlags
)
-
>
Result
<
(
)
StoreError
>
{
self
.
inner
.
put_with_flags
(
writer
Key
:
:
new
(
&
k
)
?
v
flags
)
}
pub
fn
delete_all
(
&
self
writer
:
&
mut
Writer
k
:
K
)
-
>
Result
<
(
)
StoreError
>
{
self
.
inner
.
delete_all
(
writer
Key
:
:
new
(
&
k
)
?
)
}
pub
fn
delete
(
&
self
writer
:
&
mut
Writer
k
:
K
v
:
&
Value
)
-
>
Result
<
(
)
StoreError
>
{
self
.
inner
.
delete
(
writer
Key
:
:
new
(
&
k
)
?
v
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
extern
crate
tempfile
;
use
self
:
:
tempfile
:
:
Builder
;
use
std
:
:
fs
;
use
super
:
:
*
;
use
crate
:
:
*
;
#
[
test
]
fn
test_integer_keys
(
)
{
let
root
=
Builder
:
:
new
(
)
.
prefix
(
"
test_integer_keys
"
)
.
tempdir
(
)
.
expect
(
"
tempdir
"
)
;
fs
:
:
create_dir_all
(
root
.
path
(
)
)
.
expect
(
"
dir
created
"
)
;
let
k
=
Rkv
:
:
new
(
root
.
path
(
)
)
.
expect
(
"
new
succeeded
"
)
;
let
s
=
k
.
open_multi_integer
(
"
s
"
StoreOptions
:
:
create
(
)
)
.
expect
(
"
open
"
)
;
macro_rules
!
test_integer_keys
{
(
type
:
ty
key
:
expr
)
=
>
{
{
let
mut
writer
=
k
.
write
(
)
.
expect
(
"
writer
"
)
;
s
.
put
(
&
mut
writer
key
&
Value
:
:
Str
(
"
hello
!
"
)
)
.
expect
(
"
write
"
)
;
assert_eq
!
(
s
.
get_first
(
&
writer
key
)
.
expect
(
"
read
"
)
Some
(
Value
:
:
Str
(
"
hello
!
"
)
)
)
;
writer
.
commit
(
)
.
expect
(
"
committed
"
)
;
let
reader
=
k
.
read
(
)
.
expect
(
"
reader
"
)
;
assert_eq
!
(
s
.
get_first
(
&
reader
key
)
.
expect
(
"
read
"
)
Some
(
Value
:
:
Str
(
"
hello
!
"
)
)
)
;
}
}
;
}
test_integer_keys
!
(
u32
std
:
:
u32
:
:
MIN
)
;
test_integer_keys
!
(
u32
std
:
:
u32
:
:
MAX
)
;
}
}
