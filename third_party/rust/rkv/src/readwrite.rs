use
lmdb
;
use
std
:
:
marker
:
:
PhantomData
;
use
lmdb
:
:
{
Cursor
Database
Iter
as
LmdbIter
RoCursor
RoTransaction
RwTransaction
Transaction
}
;
use
lmdb
:
:
WriteFlags
;
use
error
:
:
StoreError
;
use
value
:
:
Value
;
fn
read_transform
<
'
x
>
(
val
:
Result
<
&
'
x
[
u8
]
lmdb
:
:
Error
>
)
-
>
Result
<
Option
<
Value
<
'
x
>
>
StoreError
>
{
match
val
{
Ok
(
bytes
)
=
>
Value
:
:
from_tagged_slice
(
bytes
)
.
map
(
Some
)
.
map_err
(
StoreError
:
:
DataError
)
Err
(
lmdb
:
:
Error
:
:
NotFound
)
=
>
Ok
(
None
)
Err
(
e
)
=
>
Err
(
StoreError
:
:
LmdbError
(
e
)
)
}
}
pub
struct
Writer
<
'
env
K
>
where
K
:
AsRef
<
[
u8
]
>
{
tx
:
RwTransaction
<
'
env
>
phantom
:
PhantomData
<
K
>
}
pub
struct
Reader
<
'
env
K
>
where
K
:
AsRef
<
[
u8
]
>
{
tx
:
RoTransaction
<
'
env
>
phantom
:
PhantomData
<
K
>
}
pub
struct
Iter
<
'
env
>
{
iter
:
LmdbIter
<
'
env
>
cursor
:
RoCursor
<
'
env
>
}
impl
<
'
env
K
>
Writer
<
'
env
K
>
where
K
:
AsRef
<
[
u8
]
>
{
pub
(
crate
)
fn
new
(
txn
:
RwTransaction
)
-
>
Writer
<
K
>
{
Writer
{
tx
:
txn
phantom
:
PhantomData
}
}
pub
fn
get
<
'
s
>
(
&
'
s
self
store
:
&
'
s
Store
k
:
K
)
-
>
Result
<
Option
<
Value
<
'
s
>
>
StoreError
>
{
let
bytes
=
self
.
tx
.
get
(
store
.
db
&
k
.
as_ref
(
)
)
;
read_transform
(
bytes
)
}
pub
fn
put
<
'
s
>
(
&
'
s
mut
self
store
:
&
'
s
Store
k
:
K
v
:
&
Value
)
-
>
Result
<
(
)
StoreError
>
{
let
bytes
=
v
.
to_bytes
(
)
?
;
self
.
tx
.
put
(
store
.
db
&
k
.
as_ref
(
)
&
bytes
WriteFlags
:
:
empty
(
)
)
.
map_err
(
StoreError
:
:
LmdbError
)
}
pub
fn
delete
<
'
s
>
(
&
'
s
mut
self
store
:
&
'
s
Store
k
:
K
)
-
>
Result
<
(
)
StoreError
>
{
self
.
tx
.
del
(
store
.
db
&
k
.
as_ref
(
)
None
)
.
map_err
(
StoreError
:
:
LmdbError
)
}
pub
fn
delete_value
<
'
s
>
(
&
'
s
mut
self
_store
:
&
'
s
Store
_k
:
K
_v
:
&
Value
)
-
>
Result
<
(
)
StoreError
>
{
unimplemented
!
(
)
;
}
pub
fn
commit
(
self
)
-
>
Result
<
(
)
StoreError
>
{
self
.
tx
.
commit
(
)
.
map_err
(
StoreError
:
:
LmdbError
)
}
pub
fn
abort
(
self
)
{
self
.
tx
.
abort
(
)
;
}
}
impl
<
'
env
K
>
Reader
<
'
env
K
>
where
K
:
AsRef
<
[
u8
]
>
{
pub
(
crate
)
fn
new
(
txn
:
RoTransaction
)
-
>
Reader
<
K
>
{
Reader
{
tx
:
txn
phantom
:
PhantomData
}
}
pub
fn
get
<
'
s
>
(
&
'
s
self
store
:
&
'
s
Store
k
:
K
)
-
>
Result
<
Option
<
Value
<
'
s
>
>
StoreError
>
{
let
bytes
=
self
.
tx
.
get
(
store
.
db
&
k
.
as_ref
(
)
)
;
read_transform
(
bytes
)
}
pub
fn
abort
(
self
)
{
self
.
tx
.
abort
(
)
;
}
pub
fn
iter_start
<
'
s
>
(
&
'
s
self
store
:
&
'
s
Store
)
-
>
Result
<
Iter
<
'
s
>
StoreError
>
{
let
mut
cursor
=
self
.
tx
.
open_ro_cursor
(
store
.
db
)
.
map_err
(
StoreError
:
:
LmdbError
)
?
;
let
iter
=
cursor
.
iter
(
)
;
Ok
(
Iter
{
iter
cursor
}
)
}
pub
fn
iter_from
<
'
s
>
(
&
'
s
self
store
:
&
'
s
Store
k
:
K
)
-
>
Result
<
Iter
<
'
s
>
StoreError
>
{
let
mut
cursor
=
self
.
tx
.
open_ro_cursor
(
store
.
db
)
.
map_err
(
StoreError
:
:
LmdbError
)
?
;
let
iter
=
cursor
.
iter_from
(
k
)
;
Ok
(
Iter
{
iter
cursor
}
)
}
}
impl
<
'
env
>
Iterator
for
Iter
<
'
env
>
{
type
Item
=
(
&
'
env
[
u8
]
Result
<
Option
<
Value
<
'
env
>
>
StoreError
>
)
;
fn
next
(
&
mut
self
)
-
>
Option
<
(
&
'
env
[
u8
]
Result
<
Option
<
Value
<
'
env
>
>
StoreError
>
)
>
{
match
self
.
iter
.
next
(
)
{
None
=
>
None
Some
(
(
key
bytes
)
)
=
>
Some
(
(
key
read_transform
(
Ok
(
bytes
)
)
)
)
}
}
}
#
[
derive
(
Copy
Clone
)
]
pub
struct
Store
{
db
:
Database
}
impl
Store
{
pub
fn
new
(
db
:
Database
)
-
>
Store
{
Store
{
db
}
}
}
