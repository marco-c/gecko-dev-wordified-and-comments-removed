use
std
:
:
borrow
:
:
Cow
;
pub
struct
Shlex
<
'
a
>
{
in_iter
:
std
:
:
str
:
:
Bytes
<
'
a
>
pub
line_no
:
usize
pub
had_error
:
bool
}
impl
<
'
a
>
Shlex
<
'
a
>
{
pub
fn
new
(
in_str
:
&
'
a
str
)
-
>
Self
{
Shlex
{
in_iter
:
in_str
.
bytes
(
)
line_no
:
1
had_error
:
false
}
}
fn
parse_word
(
&
mut
self
mut
ch
:
u8
)
-
>
Option
<
String
>
{
let
mut
result
:
Vec
<
u8
>
=
Vec
:
:
new
(
)
;
loop
{
match
ch
as
char
{
'
"
'
=
>
if
let
Err
(
(
)
)
=
self
.
parse_double
(
&
mut
result
)
{
self
.
had_error
=
true
;
return
None
;
}
'
\
'
'
=
>
if
let
Err
(
(
)
)
=
self
.
parse_single
(
&
mut
result
)
{
self
.
had_error
=
true
;
return
None
;
}
'
\
\
'
=
>
if
let
Some
(
ch2
)
=
self
.
next_char
(
)
{
if
ch2
!
=
'
\
n
'
as
u8
{
result
.
push
(
ch2
)
;
}
}
else
{
self
.
had_error
=
true
;
return
None
;
}
'
'
|
'
\
t
'
|
'
\
n
'
=
>
{
break
;
}
_
=
>
{
result
.
push
(
ch
as
u8
)
;
}
}
if
let
Some
(
ch2
)
=
self
.
next_char
(
)
{
ch
=
ch2
;
}
else
{
break
;
}
}
unsafe
{
Some
(
String
:
:
from_utf8_unchecked
(
result
)
)
}
}
fn
parse_double
(
&
mut
self
result
:
&
mut
Vec
<
u8
>
)
-
>
Result
<
(
)
(
)
>
{
loop
{
if
let
Some
(
ch2
)
=
self
.
next_char
(
)
{
match
ch2
as
char
{
'
\
\
'
=
>
{
if
let
Some
(
ch3
)
=
self
.
next_char
(
)
{
match
ch3
as
char
{
'
'
|
'
'
|
'
"
'
|
'
\
\
'
=
>
{
result
.
push
(
ch3
)
;
}
'
\
n
'
=
>
{
}
_
=
>
{
result
.
push
(
'
\
\
'
as
u8
)
;
result
.
push
(
ch3
)
;
}
}
}
else
{
return
Err
(
(
)
)
;
}
}
'
"
'
=
>
{
return
Ok
(
(
)
)
;
}
_
=
>
{
result
.
push
(
ch2
)
;
}
}
}
else
{
return
Err
(
(
)
)
;
}
}
}
fn
parse_single
(
&
mut
self
result
:
&
mut
Vec
<
u8
>
)
-
>
Result
<
(
)
(
)
>
{
loop
{
if
let
Some
(
ch2
)
=
self
.
next_char
(
)
{
match
ch2
as
char
{
'
\
\
'
=
>
{
if
let
Some
(
ch3
)
=
self
.
next_char
(
)
{
match
ch3
as
char
{
'
\
'
'
|
'
\
\
'
=
>
{
result
.
push
(
ch3
)
;
}
_
=
>
{
result
.
push
(
'
\
\
'
as
u8
)
;
result
.
push
(
ch3
)
;
}
}
}
else
{
return
Err
(
(
)
)
;
}
}
'
\
'
'
=
>
{
return
Ok
(
(
)
)
;
}
_
=
>
{
result
.
push
(
ch2
)
;
}
}
}
else
{
return
Err
(
(
)
)
;
}
}
}
fn
next_char
(
&
mut
self
)
-
>
Option
<
u8
>
{
let
res
=
self
.
in_iter
.
next
(
)
;
if
res
=
=
Some
(
'
\
n
'
as
u8
)
{
self
.
line_no
+
=
1
;
}
res
}
}
impl
<
'
a
>
Iterator
for
Shlex
<
'
a
>
{
type
Item
=
String
;
fn
next
(
&
mut
self
)
-
>
Option
<
String
>
{
if
let
Some
(
mut
ch
)
=
self
.
next_char
(
)
{
loop
{
match
ch
as
char
{
'
'
|
'
\
t
'
|
'
\
n
'
=
>
{
}
'
#
'
=
>
{
while
let
Some
(
ch2
)
=
self
.
next_char
(
)
{
if
ch2
as
char
=
=
'
\
n
'
{
break
;
}
}
}
_
=
>
{
break
;
}
}
if
let
Some
(
ch2
)
=
self
.
next_char
(
)
{
ch
=
ch2
;
}
else
{
return
None
;
}
}
self
.
parse_word
(
ch
)
}
else
{
None
}
}
}
pub
fn
split
(
in_str
:
&
str
)
-
>
Option
<
Vec
<
String
>
>
{
let
mut
shl
=
Shlex
:
:
new
(
in_str
)
;
let
res
=
shl
.
by_ref
(
)
.
collect
(
)
;
if
shl
.
had_error
{
None
}
else
{
Some
(
res
)
}
}
pub
fn
quote
(
in_str
:
&
str
)
-
>
Cow
<
str
>
{
if
in_str
.
len
(
)
=
=
0
{
"
\
"
\
"
"
.
into
(
)
}
else
if
in_str
.
bytes
(
)
.
any
(
|
c
|
match
c
as
char
{
'
|
'
|
'
&
'
|
'
;
'
|
'
<
'
|
'
>
'
|
'
(
'
|
'
)
'
|
'
'
|
'
'
|
'
\
\
'
|
'
"
'
|
'
\
'
'
|
'
'
|
'
\
t
'
|
'
\
r
'
|
'
\
n
'
|
'
*
'
|
'
?
'
|
'
[
'
|
'
#
'
|
'
~
'
|
'
=
'
|
'
%
'
=
>
true
_
=
>
false
}
)
{
let
mut
out
:
Vec
<
u8
>
=
Vec
:
:
new
(
)
;
out
.
push
(
'
"
'
as
u8
)
;
for
c
in
in_str
.
bytes
(
)
{
match
c
as
char
{
'
'
|
'
'
|
'
"
'
|
'
\
\
'
=
>
out
.
push
(
'
\
\
'
as
u8
)
_
=
>
(
)
}
out
.
push
(
c
)
;
}
out
.
push
(
'
"
'
as
u8
)
;
unsafe
{
String
:
:
from_utf8_unchecked
(
out
)
}
.
into
(
)
}
else
{
in_str
.
into
(
)
}
}
#
[
cfg
(
test
)
]
static
SPLIT_TEST_ITEMS
:
&
'
static
[
(
&
'
static
str
Option
<
&
'
static
[
&
'
static
str
]
>
)
]
=
&
[
(
"
foo
baz
"
Some
(
&
[
"
foo
baz
"
]
)
)
(
"
foo
baz
"
Some
(
&
[
"
foo
"
"
baz
"
]
)
)
(
"
foo
\
"
bar
\
"
baz
"
Some
(
&
[
"
foobarbaz
"
]
)
)
(
"
foo
\
"
bar
\
"
baz
"
Some
(
&
[
"
foo
"
"
barbaz
"
]
)
)
(
"
foo
\
nbar
"
Some
(
&
[
"
foo
"
"
bar
"
]
)
)
(
"
foo
\
\
\
nbar
"
Some
(
&
[
"
foobar
"
]
)
)
(
"
\
"
foo
\
\
\
nbar
\
"
"
Some
(
&
[
"
foobar
"
]
)
)
(
"
'
baz
\
\
b
'
"
Some
(
&
[
"
baz
\
\
b
"
]
)
)
(
"
'
baz
\
\
\
'
'
"
Some
(
&
[
"
baz
\
'
"
]
)
)
(
"
\
\
"
None
)
(
"
\
"
\
\
"
None
)
(
"
'
\
\
"
None
)
(
"
\
"
"
None
)
(
"
'
"
None
)
(
"
foo
#
bar
\
nbaz
"
Some
(
&
[
"
foo
"
"
baz
"
]
)
)
(
"
foo
#
bar
"
Some
(
&
[
"
foo
"
]
)
)
(
"
foo
#
bar
"
Some
(
&
[
"
foo
#
bar
"
]
)
)
(
"
foo
\
"
#
bar
"
None
)
]
;
#
[
test
]
fn
test_split
(
)
{
for
&
(
input
output
)
in
SPLIT_TEST_ITEMS
{
assert_eq
!
(
split
(
input
)
output
.
map
(
|
o
|
o
.
iter
(
)
.
map
(
|
&
x
|
x
.
to_owned
(
)
)
.
collect
(
)
)
)
;
}
}
#
[
test
]
fn
test_lineno
(
)
{
let
mut
sh
=
Shlex
:
:
new
(
"
\
nfoo
\
nbar
"
)
;
while
let
Some
(
word
)
=
sh
.
next
(
)
{
if
word
=
=
"
bar
"
{
assert_eq
!
(
sh
.
line_no
3
)
;
}
}
}
#
[
test
]
fn
test_quote
(
)
{
assert_eq
!
(
quote
(
"
foobar
"
)
"
foobar
"
)
;
assert_eq
!
(
quote
(
"
foo
bar
"
)
"
\
"
foo
bar
\
"
"
)
;
assert_eq
!
(
quote
(
"
\
"
"
)
"
\
"
\
\
\
"
\
"
"
)
;
assert_eq
!
(
quote
(
"
"
)
"
\
"
\
"
"
)
;
}
