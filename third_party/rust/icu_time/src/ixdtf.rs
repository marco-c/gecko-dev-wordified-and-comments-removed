use
crate
:
:
{
zone
:
:
{
iana
:
:
IanaParserBorrowed
models
InvalidOffsetError
UtcOffset
VariantOffsetsCalculatorBorrowed
}
DateTime
Time
TimeZone
TimeZoneInfo
ZonedDateTime
}
;
use
core
:
:
str
:
:
FromStr
;
use
icu_calendar
:
:
{
AnyCalendarKind
AsCalendar
Date
DateError
Iso
RangeError
}
;
use
icu_locale_core
:
:
subtags
:
:
subtag
;
use
ixdtf
:
:
{
parsers
:
:
{
records
:
:
{
DateRecord
IxdtfParseRecord
TimeRecord
TimeZoneAnnotation
TimeZoneRecord
UtcOffsetRecord
UtcOffsetRecordOrZ
}
IxdtfParser
}
ParseError
as
Rfc9557ParseError
}
;
#
[
derive
(
Debug
PartialEq
displaydoc
:
:
Display
)
]
#
[
non_exhaustive
]
pub
enum
ParseError
{
#
[
displaydoc
(
"
Syntax
error
in
the
RFC
9557
string
:
{
0
}
"
)
]
Syntax
(
Rfc9557ParseError
)
#
[
displaydoc
(
"
Value
out
of
range
:
{
0
}
"
)
]
Range
(
RangeError
)
#
[
displaydoc
(
"
Parsed
date
and
time
records
were
not
a
valid
ISO
date
:
{
0
}
"
)
]
Date
(
DateError
)
MissingFields
InconsistentTimeUtcOffsets
InvalidOffsetError
ExcessivePrecision
#
[
displaydoc
(
"
The
set
of
time
zone
fields
was
not
expected
for
the
given
type
"
)
]
MismatchedTimeZoneFields
UnknownCalendar
#
[
displaydoc
(
"
Expected
calendar
{
0
}
but
found
calendar
{
1
}
"
)
]
MismatchedCalendar
(
AnyCalendarKind
AnyCalendarKind
)
#
[
displaydoc
(
"
A
timezone
calculation
is
required
to
interpret
this
string
which
is
not
supported
"
)
]
RequiresCalculation
}
impl
core
:
:
error
:
:
Error
for
ParseError
{
}
impl
From
<
Rfc9557ParseError
>
for
ParseError
{
fn
from
(
value
:
Rfc9557ParseError
)
-
>
Self
{
Self
:
:
Syntax
(
value
)
}
}
impl
From
<
RangeError
>
for
ParseError
{
fn
from
(
value
:
RangeError
)
-
>
Self
{
Self
:
:
Range
(
value
)
}
}
impl
From
<
DateError
>
for
ParseError
{
fn
from
(
value
:
DateError
)
-
>
Self
{
Self
:
:
Date
(
value
)
}
}
impl
From
<
InvalidOffsetError
>
for
ParseError
{
fn
from
(
_
:
InvalidOffsetError
)
-
>
Self
{
Self
:
:
InvalidOffsetError
}
}
impl
From
<
icu_calendar
:
:
ParseError
>
for
ParseError
{
fn
from
(
value
:
icu_calendar
:
:
ParseError
)
-
>
Self
{
match
value
{
icu_calendar
:
:
ParseError
:
:
MissingFields
=
>
Self
:
:
MissingFields
icu_calendar
:
:
ParseError
:
:
Range
(
r
)
=
>
Self
:
:
Range
(
r
)
icu_calendar
:
:
ParseError
:
:
Syntax
(
s
)
=
>
Self
:
:
Syntax
(
s
)
icu_calendar
:
:
ParseError
:
:
UnknownCalendar
=
>
Self
:
:
UnknownCalendar
_
=
>
unreachable
!
(
)
}
}
}
impl
UtcOffset
{
fn
try_from_utc_offset_record
(
record
:
UtcOffsetRecord
)
-
>
Result
<
Self
ParseError
>
{
let
hour_seconds
=
i32
:
:
from
(
record
.
hour
(
)
)
*
3600
;
let
minute_seconds
=
i32
:
:
from
(
record
.
minute
(
)
)
*
60
;
Self
:
:
try_from_seconds
(
i32
:
:
from
(
record
.
sign
(
)
as
i8
)
*
(
hour_seconds
+
minute_seconds
+
i32
:
:
from
(
record
.
second
(
)
.
unwrap_or
(
0
)
)
)
)
.
map_err
(
Into
:
:
into
)
}
}
struct
Intermediate
<
'
a
>
{
offset
:
Option
<
UtcOffsetRecord
>
is_z
:
bool
iana_identifier
:
Option
<
&
'
a
[
u8
]
>
date
:
DateRecord
time
:
TimeRecord
}
impl
<
'
a
>
Intermediate
<
'
a
>
{
fn
try_from_ixdtf_record
(
ixdtf_record
:
&
'
a
IxdtfParseRecord
)
-
>
Result
<
Self
ParseError
>
{
let
(
offset
is_z
iana_identifier
)
=
match
ixdtf_record
{
IxdtfParseRecord
{
offset
:
None
tz
:
None
.
.
}
=
>
(
None
false
None
)
IxdtfParseRecord
{
offset
:
Some
(
UtcOffsetRecordOrZ
:
:
Offset
(
offset
)
)
tz
:
None
.
.
}
=
>
(
Some
(
*
offset
)
false
None
)
IxdtfParseRecord
{
offset
:
Some
(
UtcOffsetRecordOrZ
:
:
Z
)
tz
:
None
.
.
}
=
>
(
None
true
None
)
IxdtfParseRecord
{
offset
:
None
tz
:
Some
(
TimeZoneAnnotation
{
tz
:
TimeZoneRecord
:
:
Offset
(
offset
)
.
.
}
)
.
.
}
=
>
(
Some
(
UtcOffsetRecord
:
:
MinutePrecision
(
*
offset
)
)
false
None
)
IxdtfParseRecord
{
offset
:
Some
(
UtcOffsetRecordOrZ
:
:
Offset
(
offset
)
)
tz
:
Some
(
TimeZoneAnnotation
{
tz
:
TimeZoneRecord
:
:
Offset
(
offset1
)
.
.
}
)
.
.
}
=
>
{
let
annotation_offset
=
UtcOffsetRecord
:
:
MinutePrecision
(
*
offset1
)
;
if
offset
!
=
&
annotation_offset
{
return
Err
(
ParseError
:
:
InconsistentTimeUtcOffsets
)
;
}
(
Some
(
*
offset
)
false
None
)
}
IxdtfParseRecord
{
offset
:
Some
(
UtcOffsetRecordOrZ
:
:
Offset
(
offset
)
)
tz
:
Some
(
TimeZoneAnnotation
{
tz
:
TimeZoneRecord
:
:
Name
(
iana_identifier
)
.
.
}
)
.
.
}
=
>
(
Some
(
*
offset
)
false
Some
(
*
iana_identifier
)
)
IxdtfParseRecord
{
offset
:
Some
(
UtcOffsetRecordOrZ
:
:
Z
)
tz
:
Some
(
TimeZoneAnnotation
{
tz
:
TimeZoneRecord
:
:
Offset
(
offset
)
.
.
}
)
.
.
}
=
>
(
Some
(
UtcOffsetRecord
:
:
MinutePrecision
(
*
offset
)
)
true
None
)
IxdtfParseRecord
{
offset
:
Some
(
UtcOffsetRecordOrZ
:
:
Z
)
tz
:
Some
(
TimeZoneAnnotation
{
tz
:
TimeZoneRecord
:
:
Name
(
iana_identifier
)
.
.
}
)
.
.
}
=
>
(
None
true
Some
(
*
iana_identifier
)
)
IxdtfParseRecord
{
offset
:
None
tz
:
Some
(
TimeZoneAnnotation
{
tz
:
TimeZoneRecord
:
:
Name
(
iana_identifier
)
.
.
}
)
.
.
}
=
>
(
None
false
Some
(
*
iana_identifier
)
)
IxdtfParseRecord
{
tz
:
Some
(
TimeZoneAnnotation
{
tz
.
.
}
)
.
.
}
=
>
{
debug_assert
!
(
false
"
unexpected
TimeZoneRecord
:
{
tz
:
?
}
"
)
;
(
None
false
None
)
}
}
;
let
IxdtfParseRecord
{
date
:
Some
(
date
)
time
:
Some
(
time
)
.
.
}
=
*
ixdtf_record
else
{
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
Ok
(
Self
{
offset
is_z
iana_identifier
date
time
}
)
}
fn
offset_only
(
self
)
-
>
Result
<
UtcOffset
ParseError
>
{
let
None
=
self
.
iana_identifier
else
{
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
if
self
.
is_z
{
if
let
Some
(
offset
)
=
self
.
offset
{
if
offset
!
=
UtcOffsetRecord
:
:
zero
(
)
{
return
Err
(
ParseError
:
:
RequiresCalculation
)
;
}
}
return
Ok
(
UtcOffset
:
:
zero
(
)
)
;
}
let
Some
(
offset
)
=
self
.
offset
else
{
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
UtcOffset
:
:
try_from_utc_offset_record
(
offset
)
}
fn
location_only
(
self
iana_parser
:
IanaParserBorrowed
<
'
_
>
)
-
>
Result
<
TimeZoneInfo
<
models
:
:
AtTime
>
ParseError
>
{
let
None
=
self
.
offset
else
{
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
let
Some
(
iana_identifier
)
=
self
.
iana_identifier
else
{
if
self
.
is_z
{
return
Err
(
ParseError
:
:
RequiresCalculation
)
;
}
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
let
id
=
iana_parser
.
parse_from_utf8
(
iana_identifier
)
;
let
date
=
Date
:
:
<
Iso
>
:
:
try_new_iso
(
self
.
date
.
year
self
.
date
.
month
self
.
date
.
day
)
?
;
let
time
=
Time
:
:
try_from_time_record
(
&
self
.
time
)
?
;
let
offset
=
match
id
.
as_str
(
)
{
"
utc
"
|
"
gmt
"
=
>
Some
(
UtcOffset
:
:
zero
(
)
)
_
=
>
None
}
;
Ok
(
id
.
with_offset
(
offset
)
.
at_date_time_iso
(
DateTime
{
date
time
}
)
)
}
fn
lenient
(
self
iana_parser
:
IanaParserBorrowed
<
'
_
>
)
-
>
Result
<
TimeZoneInfo
<
models
:
:
AtTime
>
ParseError
>
{
let
id
=
match
self
.
iana_identifier
{
Some
(
iana_identifier
)
=
>
{
if
self
.
is_z
{
return
Err
(
ParseError
:
:
RequiresCalculation
)
;
}
iana_parser
.
parse_from_utf8
(
iana_identifier
)
}
None
if
self
.
is_z
=
>
TimeZone
(
subtag
!
(
"
utc
"
)
)
None
=
>
TimeZone
:
:
UNKNOWN
}
;
let
offset
=
match
self
.
offset
{
Some
(
offset
)
=
>
{
if
self
.
is_z
&
&
offset
!
=
UtcOffsetRecord
:
:
zero
(
)
{
return
Err
(
ParseError
:
:
RequiresCalculation
)
;
}
Some
(
UtcOffset
:
:
try_from_utc_offset_record
(
offset
)
?
)
}
None
=
>
match
id
.
as_str
(
)
{
"
utc
"
|
"
gmt
"
=
>
Some
(
UtcOffset
:
:
zero
(
)
)
_
if
self
.
is_z
=
>
Some
(
UtcOffset
:
:
zero
(
)
)
_
=
>
None
}
}
;
let
date
=
Date
:
:
<
Iso
>
:
:
try_new_iso
(
self
.
date
.
year
self
.
date
.
month
self
.
date
.
day
)
?
;
let
time
=
Time
:
:
try_from_time_record
(
&
self
.
time
)
?
;
Ok
(
id
.
with_offset
(
offset
)
.
at_date_time_iso
(
DateTime
{
date
time
}
)
)
}
fn
full
(
self
iana_parser
:
IanaParserBorrowed
<
'
_
>
offset_calculator
:
VariantOffsetsCalculatorBorrowed
)
-
>
Result
<
TimeZoneInfo
<
models
:
:
Full
>
ParseError
>
{
let
Some
(
offset
)
=
self
.
offset
else
{
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
let
Some
(
iana_identifier
)
=
self
.
iana_identifier
else
{
return
Err
(
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
;
let
time_zone_id
=
iana_parser
.
parse_from_utf8
(
iana_identifier
)
;
let
date
=
Date
:
:
try_new_iso
(
self
.
date
.
year
self
.
date
.
month
self
.
date
.
day
)
?
;
let
time
=
Time
:
:
try_from_time_record
(
&
self
.
time
)
?
;
let
offset
=
UtcOffset
:
:
try_from_utc_offset_record
(
offset
)
?
;
Ok
(
time_zone_id
.
with_offset
(
Some
(
offset
)
)
.
at_date_time_iso
(
DateTime
{
date
time
}
)
.
infer_variant
(
offset_calculator
)
)
}
}
impl
<
A
:
AsCalendar
>
ZonedDateTime
<
A
UtcOffset
>
{
pub
fn
try_offset_only_from_str
(
rfc_9557_str
:
&
str
calendar
:
A
)
-
>
Result
<
Self
ParseError
>
{
Self
:
:
try_offset_only_from_utf8
(
rfc_9557_str
.
as_bytes
(
)
calendar
)
}
pub
fn
try_offset_only_from_utf8
(
rfc_9557_str
:
&
[
u8
]
calendar
:
A
)
-
>
Result
<
Self
ParseError
>
{
let
ixdtf_record
=
IxdtfParser
:
:
from_utf8
(
rfc_9557_str
)
.
parse
(
)
?
;
let
date
=
Date
:
:
try_from_ixdtf_record
(
&
ixdtf_record
calendar
)
?
;
let
time
=
Time
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
;
let
zone
=
Intermediate
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
.
offset_only
(
)
?
;
Ok
(
ZonedDateTime
{
date
time
zone
}
)
}
}
impl
<
A
:
AsCalendar
>
ZonedDateTime
<
A
TimeZoneInfo
<
models
:
:
AtTime
>
>
{
pub
fn
try_location_only_from_str
(
rfc_9557_str
:
&
str
calendar
:
A
iana_parser
:
IanaParserBorrowed
)
-
>
Result
<
Self
ParseError
>
{
Self
:
:
try_location_only_from_utf8
(
rfc_9557_str
.
as_bytes
(
)
calendar
iana_parser
)
}
pub
fn
try_location_only_from_utf8
(
rfc_9557_str
:
&
[
u8
]
calendar
:
A
iana_parser
:
IanaParserBorrowed
)
-
>
Result
<
Self
ParseError
>
{
let
ixdtf_record
=
IxdtfParser
:
:
from_utf8
(
rfc_9557_str
)
.
parse
(
)
?
;
let
date
=
Date
:
:
try_from_ixdtf_record
(
&
ixdtf_record
calendar
)
?
;
let
time
=
Time
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
;
let
zone
=
Intermediate
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
.
location_only
(
iana_parser
)
?
;
Ok
(
ZonedDateTime
{
date
time
zone
}
)
}
pub
fn
try_lenient_from_str
(
rfc_9557_str
:
&
str
calendar
:
A
iana_parser
:
IanaParserBorrowed
)
-
>
Result
<
Self
ParseError
>
{
Self
:
:
try_lenient_from_utf8
(
rfc_9557_str
.
as_bytes
(
)
calendar
iana_parser
)
}
pub
fn
try_lenient_from_utf8
(
rfc_9557_str
:
&
[
u8
]
calendar
:
A
iana_parser
:
IanaParserBorrowed
)
-
>
Result
<
Self
ParseError
>
{
let
ixdtf_record
=
IxdtfParser
:
:
from_utf8
(
rfc_9557_str
)
.
parse
(
)
?
;
let
date
=
Date
:
:
try_from_ixdtf_record
(
&
ixdtf_record
calendar
)
?
;
let
time
=
Time
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
;
let
zone
=
Intermediate
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
.
lenient
(
iana_parser
)
?
;
Ok
(
ZonedDateTime
{
date
time
zone
}
)
}
}
impl
<
A
:
AsCalendar
>
ZonedDateTime
<
A
TimeZoneInfo
<
models
:
:
Full
>
>
{
pub
fn
try_full_from_str
(
rfc_9557_str
:
&
str
calendar
:
A
iana_parser
:
IanaParserBorrowed
offset_calculator
:
VariantOffsetsCalculatorBorrowed
)
-
>
Result
<
Self
ParseError
>
{
Self
:
:
try_full_from_utf8
(
rfc_9557_str
.
as_bytes
(
)
calendar
iana_parser
offset_calculator
)
}
pub
fn
try_full_from_utf8
(
rfc_9557_str
:
&
[
u8
]
calendar
:
A
iana_parser
:
IanaParserBorrowed
offset_calculator
:
VariantOffsetsCalculatorBorrowed
)
-
>
Result
<
Self
ParseError
>
{
let
ixdtf_record
=
IxdtfParser
:
:
from_utf8
(
rfc_9557_str
)
.
parse
(
)
?
;
let
date
=
Date
:
:
try_from_ixdtf_record
(
&
ixdtf_record
calendar
)
?
;
let
time
=
Time
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
;
let
zone
=
Intermediate
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
.
full
(
iana_parser
offset_calculator
)
?
;
Ok
(
ZonedDateTime
{
date
time
zone
}
)
}
}
impl
FromStr
for
DateTime
<
Iso
>
{
type
Err
=
ParseError
;
fn
from_str
(
rfc_9557_str
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Self
:
:
try_from_str
(
rfc_9557_str
Iso
)
}
}
impl
<
A
:
AsCalendar
>
DateTime
<
A
>
{
pub
fn
try_from_str
(
rfc_9557_str
:
&
str
calendar
:
A
)
-
>
Result
<
Self
ParseError
>
{
Self
:
:
try_from_utf8
(
rfc_9557_str
.
as_bytes
(
)
calendar
)
}
pub
fn
try_from_utf8
(
rfc_9557_str
:
&
[
u8
]
calendar
:
A
)
-
>
Result
<
Self
ParseError
>
{
let
ixdtf_record
=
IxdtfParser
:
:
from_utf8
(
rfc_9557_str
)
.
parse
(
)
?
;
let
date
=
Date
:
:
try_from_ixdtf_record
(
&
ixdtf_record
calendar
)
?
;
let
time
=
Time
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
?
;
Ok
(
Self
{
date
time
}
)
}
}
impl
Time
{
pub
fn
try_from_str
(
rfc_9557_str
:
&
str
)
-
>
Result
<
Self
ParseError
>
{
Self
:
:
try_from_utf8
(
rfc_9557_str
.
as_bytes
(
)
)
}
pub
fn
try_from_utf8
(
rfc_9557_str
:
&
[
u8
]
)
-
>
Result
<
Self
ParseError
>
{
let
ixdtf_record
=
IxdtfParser
:
:
from_utf8
(
rfc_9557_str
)
.
parse_time
(
)
?
;
Self
:
:
try_from_ixdtf_record
(
&
ixdtf_record
)
}
fn
try_from_ixdtf_record
(
ixdtf_record
:
&
IxdtfParseRecord
)
-
>
Result
<
Self
ParseError
>
{
let
time_record
=
ixdtf_record
.
time
.
ok_or
(
ParseError
:
:
MissingFields
)
?
;
Self
:
:
try_from_time_record
(
&
time_record
)
}
fn
try_from_time_record
(
time_record
:
&
TimeRecord
)
-
>
Result
<
Self
ParseError
>
{
let
nanosecond
=
time_record
.
fraction
.
map
(
|
fraction
|
{
fraction
.
to_nanoseconds
(
)
.
ok_or
(
ParseError
:
:
ExcessivePrecision
)
}
)
.
transpose
(
)
?
.
unwrap_or_default
(
)
;
Ok
(
Self
:
:
try_new
(
time_record
.
hour
time_record
.
minute
time_record
.
second
nanosecond
)
?
)
}
}
impl
FromStr
for
Time
{
type
Err
=
ParseError
;
fn
from_str
(
rfc_9557_str
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Self
:
:
try_from_str
(
rfc_9557_str
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
TimeZone
;
#
[
test
]
fn
max_possible_rfc_9557_utc_offset
(
)
{
assert_eq
!
(
ZonedDateTime
:
:
try_offset_only_from_str
(
"
2024
-
08
-
08T12
:
08
:
19
+
23
:
59
:
59
.
999999999
"
Iso
)
.
unwrap_err
(
)
ParseError
:
:
InvalidOffsetError
)
;
}
#
[
test
]
fn
zone_calculations
(
)
{
ZonedDateTime
:
:
try_offset_only_from_str
(
"
2024
-
08
-
08T12
:
08
:
19Z
"
Iso
)
.
unwrap
(
)
;
assert_eq
!
(
ZonedDateTime
:
:
try_offset_only_from_str
(
"
2024
-
08
-
08T12
:
08
:
19Z
[
+
08
:
00
]
"
Iso
)
.
unwrap_err
(
)
ParseError
:
:
RequiresCalculation
)
;
assert_eq
!
(
ZonedDateTime
:
:
try_offset_only_from_str
(
"
2024
-
08
-
08T12
:
08
:
19Z
[
Europe
/
Zurich
]
"
Iso
)
.
unwrap_err
(
)
ParseError
:
:
MismatchedTimeZoneFields
)
;
}
#
[
test
]
fn
future_zone
(
)
{
let
result
=
ZonedDateTime
:
:
try_lenient_from_str
(
"
2024
-
08
-
08T12
:
08
:
19
[
Future
/
Zone
]
"
Iso
IanaParserBorrowed
:
:
new
(
)
)
.
unwrap
(
)
;
assert_eq
!
(
result
.
zone
.
id
(
)
TimeZone
:
:
UNKNOWN
)
;
assert_eq
!
(
result
.
zone
.
offset
(
)
None
)
;
}
#
[
test
]
fn
lax
(
)
{
ZonedDateTime
:
:
try_location_only_from_str
(
"
2024
-
10
-
18T15
:
44
[
America
/
Los_Angeles
]
"
icu_calendar
:
:
cal
:
:
Gregorian
IanaParserBorrowed
:
:
new
(
)
)
.
unwrap
(
)
;
}
}
