pub
mod
iana
;
mod
offset
;
pub
mod
windows
;
mod
zone_name_timestamp
;
#
[
doc
(
inline
)
]
pub
use
offset
:
:
InvalidOffsetError
;
pub
use
offset
:
:
UtcOffset
;
pub
use
offset
:
:
VariantOffsets
;
pub
use
offset
:
:
VariantOffsetsCalculator
;
pub
use
offset
:
:
VariantOffsetsCalculatorBorrowed
;
#
[
doc
(
no_inline
)
]
pub
use
iana
:
:
{
IanaParser
IanaParserBorrowed
}
;
#
[
doc
(
no_inline
)
]
pub
use
windows
:
:
{
WindowsParser
WindowsParserBorrowed
}
;
pub
use
zone_name_timestamp
:
:
ZoneNameTimestamp
;
use
crate
:
:
scaffold
:
:
IntoOption
;
use
crate
:
:
DateTime
;
use
core
:
:
fmt
;
use
core
:
:
ops
:
:
Deref
;
use
icu_calendar
:
:
Iso
;
use
icu_locale_core
:
:
subtags
:
:
{
subtag
Subtag
}
;
use
icu_provider
:
:
prelude
:
:
yoke
;
use
zerovec
:
:
ule
:
:
{
AsULE
ULE
}
;
use
zerovec
:
:
{
ZeroSlice
ZeroVec
}
;
pub
mod
models
{
use
super
:
:
*
;
mod
private
{
pub
trait
Sealed
{
}
}
pub
trait
TimeZoneModel
:
private
:
:
Sealed
{
type
TimeZoneVariant
:
IntoOption
<
TimeZoneVariant
>
+
fmt
:
:
Debug
+
Copy
;
type
ZoneNameTimestamp
:
IntoOption
<
ZoneNameTimestamp
>
+
fmt
:
:
Debug
+
Copy
;
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
struct
Base
;
impl
private
:
:
Sealed
for
Base
{
}
impl
TimeZoneModel
for
Base
{
type
TimeZoneVariant
=
(
)
;
type
ZoneNameTimestamp
=
(
)
;
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
struct
AtTime
;
impl
private
:
:
Sealed
for
AtTime
{
}
impl
TimeZoneModel
for
AtTime
{
type
TimeZoneVariant
=
(
)
;
type
ZoneNameTimestamp
=
ZoneNameTimestamp
;
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
struct
Full
;
impl
private
:
:
Sealed
for
Full
{
}
impl
TimeZoneModel
for
Full
{
type
TimeZoneVariant
=
TimeZoneVariant
;
type
ZoneNameTimestamp
=
ZoneNameTimestamp
;
}
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Clone
Copy
Eq
Ord
PartialEq
PartialOrd
yoke
:
:
Yokeable
ULE
Hash
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
serde
:
:
Serialize
databake
:
:
Bake
)
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
databake
(
path
=
icu_time
:
:
provider
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
TimeZone
(
pub
Subtag
)
;
impl
TimeZone
{
pub
const
UNKNOWN
:
Self
=
Self
(
subtag
!
(
"
unk
"
)
)
;
pub
const
fn
is_unknown
(
self
)
-
>
bool
{
matches
!
(
self
Self
:
:
UNKNOWN
)
}
}
pub
(
crate
)
mod
ule
{
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
#
[
zerovec
:
:
make_ule
(
TimeZoneVariantULE
)
]
#
[
repr
(
u8
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
serde
:
:
Serialize
databake
:
:
Bake
)
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
databake
(
path
=
icu_time
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
non_exhaustive
]
pub
enum
TimeZoneVariant
{
Standard
=
0
Daylight
=
1
}
}
pub
use
ule
:
:
TimeZoneVariant
;
impl
Deref
for
TimeZone
{
type
Target
=
Subtag
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
impl
AsULE
for
TimeZone
{
type
ULE
=
Self
;
#
[
inline
]
fn
to_unaligned
(
self
)
-
>
Self
:
:
ULE
{
self
}
#
[
inline
]
fn
from_unaligned
(
unaligned
:
Self
:
:
ULE
)
-
>
Self
{
unaligned
}
}
impl
<
'
a
>
zerovec
:
:
maps
:
:
ZeroMapKV
<
'
a
>
for
TimeZone
{
type
Container
=
ZeroVec
<
'
a
TimeZone
>
;
type
Slice
=
ZeroSlice
<
TimeZone
>
;
type
GetType
=
TimeZone
;
type
OwnedType
=
TimeZone
;
}
#
[
derive
(
Debug
PartialEq
Eq
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
TimeZoneInfo
<
Model
:
models
:
:
TimeZoneModel
>
{
id
:
TimeZone
offset
:
Option
<
UtcOffset
>
zone_name_timestamp
:
Model
:
:
ZoneNameTimestamp
variant
:
Model
:
:
TimeZoneVariant
}
impl
<
Model
:
models
:
:
TimeZoneModel
>
Clone
for
TimeZoneInfo
<
Model
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
Model
:
models
:
:
TimeZoneModel
>
Copy
for
TimeZoneInfo
<
Model
>
{
}
impl
<
Model
:
models
:
:
TimeZoneModel
>
TimeZoneInfo
<
Model
>
{
pub
fn
id
(
self
)
-
>
TimeZone
{
self
.
id
}
pub
fn
offset
(
self
)
-
>
Option
<
UtcOffset
>
{
self
.
offset
}
}
impl
<
Model
>
TimeZoneInfo
<
Model
>
where
Model
:
models
:
:
TimeZoneModel
<
ZoneNameTimestamp
=
ZoneNameTimestamp
>
{
pub
fn
zone_name_timestamp
(
self
)
-
>
ZoneNameTimestamp
{
self
.
zone_name_timestamp
}
}
impl
<
Model
>
TimeZoneInfo
<
Model
>
where
Model
:
models
:
:
TimeZoneModel
<
TimeZoneVariant
=
TimeZoneVariant
>
{
pub
fn
variant
(
self
)
-
>
TimeZoneVariant
{
self
.
variant
}
}
impl
TimeZone
{
pub
const
fn
with_offset
(
self
offset
:
Option
<
UtcOffset
>
)
-
>
TimeZoneInfo
<
models
:
:
Base
>
{
TimeZoneInfo
{
offset
id
:
self
zone_name_timestamp
:
(
)
variant
:
(
)
}
}
pub
const
fn
without_offset
(
self
)
-
>
TimeZoneInfo
<
models
:
:
Base
>
{
TimeZoneInfo
{
offset
:
None
id
:
self
zone_name_timestamp
:
(
)
variant
:
(
)
}
}
}
impl
TimeZoneInfo
<
models
:
:
Base
>
{
pub
const
fn
unknown
(
)
-
>
Self
{
TimeZone
:
:
UNKNOWN
.
with_offset
(
None
)
}
pub
const
fn
utc
(
)
-
>
Self
{
TimeZone
(
subtag
!
(
"
utc
"
)
)
.
with_offset
(
Some
(
UtcOffset
:
:
zero
(
)
)
)
}
pub
fn
with_zone_name_timestamp
(
self
zone_name_timestamp
:
ZoneNameTimestamp
)
-
>
TimeZoneInfo
<
models
:
:
AtTime
>
{
TimeZoneInfo
{
offset
:
self
.
offset
id
:
self
.
id
zone_name_timestamp
variant
:
(
)
}
}
pub
fn
at_date_time_iso
(
self
date_time
:
DateTime
<
Iso
>
)
-
>
TimeZoneInfo
<
models
:
:
AtTime
>
{
Self
:
:
with_zone_name_timestamp
(
self
ZoneNameTimestamp
:
:
from_date_time_iso
(
date_time
)
)
}
}
impl
TimeZoneInfo
<
models
:
:
AtTime
>
{
pub
const
fn
with_variant
(
self
variant
:
TimeZoneVariant
)
-
>
TimeZoneInfo
<
models
:
:
Full
>
{
TimeZoneInfo
{
offset
:
self
.
offset
id
:
self
.
id
zone_name_timestamp
:
self
.
zone_name_timestamp
variant
}
}
pub
fn
infer_variant
(
self
calculator
:
VariantOffsetsCalculatorBorrowed
)
-
>
TimeZoneInfo
<
models
:
:
Full
>
{
let
Some
(
offset
)
=
self
.
offset
else
{
return
TimeZone
:
:
UNKNOWN
.
with_offset
(
self
.
offset
)
.
with_zone_name_timestamp
(
self
.
zone_name_timestamp
)
.
with_variant
(
TimeZoneVariant
:
:
Standard
)
;
}
;
let
Some
(
variant
)
=
calculator
.
compute_offsets_from_time_zone_and_name_timestamp
(
self
.
id
self
.
zone_name_timestamp
)
.
and_then
(
|
os
|
{
if
os
.
standard
=
=
offset
{
Some
(
TimeZoneVariant
:
:
Standard
)
}
else
if
os
.
daylight
=
=
Some
(
offset
)
{
Some
(
TimeZoneVariant
:
:
Daylight
)
}
else
{
None
}
}
)
else
{
return
TimeZone
:
:
UNKNOWN
.
with_offset
(
self
.
offset
)
.
with_zone_name_timestamp
(
self
.
zone_name_timestamp
)
.
with_variant
(
TimeZoneVariant
:
:
Standard
)
;
}
;
self
.
with_variant
(
variant
)
}
}
impl
TimeZoneVariant
{
pub
const
fn
from_rearguard_isdst
(
isdst
:
bool
)
-
>
Self
{
if
isdst
{
TimeZoneVariant
:
:
Daylight
}
else
{
TimeZoneVariant
:
:
Standard
}
}
}
