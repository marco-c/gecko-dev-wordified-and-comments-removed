use
icu_calendar
:
:
{
types
:
:
RataDie
AsCalendar
Date
Iso
RangeError
}
;
use
crate
:
:
zone
:
:
UtcOffset
;
macro_rules
!
dt_unit
{
(
name
:
ident
storage
:
ident
value
:
expr
(
#
[
docs
:
meta
]
)
+
)
=
>
{
(
#
[
docs
]
)
+
#
[
derive
(
Debug
Default
Clone
Copy
PartialEq
Eq
Ord
PartialOrd
Hash
)
]
pub
struct
name
(
storage
)
;
impl
name
{
/
/
/
Gets
the
numeric
value
for
this
component
.
pub
const
fn
number
(
self
)
-
>
storage
{
self
.
0
}
/
/
/
Creates
a
new
value
at
0
.
pub
const
fn
zero
(
)
-
>
name
{
Self
(
0
)
}
/
/
/
Returns
whether
the
value
is
zero
.
#
[
inline
]
pub
fn
is_zero
(
self
)
-
>
bool
{
self
.
0
=
=
0
}
}
impl
TryFrom
<
storage
>
for
name
{
type
Error
=
RangeError
;
fn
try_from
(
input
:
storage
)
-
>
Result
<
Self
Self
:
:
Error
>
{
if
input
>
value
{
Err
(
RangeError
{
field
:
stringify
!
(
name
)
min
:
0
max
:
value
value
:
input
as
i32
}
)
}
else
{
Ok
(
Self
(
input
)
)
}
}
}
impl
TryFrom
<
usize
>
for
name
{
type
Error
=
RangeError
;
fn
try_from
(
input
:
usize
)
-
>
Result
<
Self
Self
:
:
Error
>
{
if
input
>
value
{
Err
(
RangeError
{
field
:
"
name
"
min
:
0
max
:
value
value
:
input
as
i32
}
)
}
else
{
Ok
(
Self
(
input
as
storage
)
)
}
}
}
impl
From
<
name
>
for
storage
{
fn
from
(
input
:
name
)
-
>
Self
{
input
.
0
}
}
impl
From
<
name
>
for
usize
{
fn
from
(
input
:
name
)
-
>
Self
{
input
.
0
as
Self
}
}
}
;
}
dt_unit
!
(
Hour
u8
23
/
/
/
An
ISO
-
8601
hour
component
for
use
with
ISO
calendars
.
/
/
/
/
/
/
Must
be
within
inclusive
bounds
[
0
23
]
.
)
;
dt_unit
!
(
Minute
u8
59
/
/
/
An
ISO
-
8601
minute
component
for
use
with
ISO
calendars
.
/
/
/
/
/
/
Must
be
within
inclusive
bounds
[
0
59
]
.
)
;
dt_unit
!
(
Second
u8
60
/
/
/
An
ISO
-
8601
second
component
for
use
with
ISO
calendars
.
/
/
/
/
/
/
Must
be
within
inclusive
bounds
[
0
60
]
.
60
accommodates
for
leap
seconds
.
)
;
dt_unit
!
(
Nanosecond
u32
999_999_999
/
/
/
A
fractional
second
component
stored
as
nanoseconds
.
/
/
/
/
/
/
Must
be
within
inclusive
bounds
[
0
999_999_999
]
.
"
)
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
Time
{
pub
hour
:
Hour
pub
minute
:
Minute
pub
second
:
Second
pub
subsecond
:
Nanosecond
}
impl
Time
{
pub
const
fn
new
(
hour
:
Hour
minute
:
Minute
second
:
Second
subsecond
:
Nanosecond
)
-
>
Self
{
Self
{
hour
minute
second
subsecond
}
}
pub
const
fn
start_of_day
(
)
-
>
Self
{
Self
{
hour
:
Hour
(
0
)
minute
:
Minute
(
0
)
second
:
Second
(
0
)
subsecond
:
Nanosecond
(
0
)
}
}
pub
const
fn
noon
(
)
-
>
Self
{
Self
{
hour
:
Hour
(
12
)
minute
:
Minute
(
0
)
second
:
Second
(
0
)
subsecond
:
Nanosecond
(
0
)
}
}
pub
fn
try_new
(
hour
:
u8
minute
:
u8
second
:
u8
nanosecond
:
u32
)
-
>
Result
<
Self
RangeError
>
{
Ok
(
Self
{
hour
:
hour
.
try_into
(
)
?
minute
:
minute
.
try_into
(
)
?
second
:
second
.
try_into
(
)
?
subsecond
:
nanosecond
.
try_into
(
)
?
}
)
}
}
#
[
derive
(
Debug
PartialEq
Eq
Clone
Copy
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
DateTime
<
A
:
AsCalendar
>
{
pub
date
:
Date
<
A
>
pub
time
:
Time
}
#
[
derive
(
Debug
PartialEq
Eq
Clone
Copy
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
ZonedDateTime
<
A
:
AsCalendar
Z
>
{
pub
date
:
Date
<
A
>
pub
time
:
Time
pub
zone
:
Z
}
impl
ZonedDateTime
<
Iso
UtcOffset
>
{
pub
fn
from_epoch_milliseconds_and_utc_offset
(
epoch_milliseconds
:
i64
utc_offset
:
UtcOffset
)
-
>
Self
{
let
local_epoch_milliseconds
=
epoch_milliseconds
+
(
1000
*
utc_offset
.
to_seconds
(
)
)
as
i64
;
let
(
epoch_days
time_millisecs
)
=
(
local_epoch_milliseconds
.
div_euclid
(
86400000
)
local_epoch_milliseconds
.
rem_euclid
(
86400000
)
)
;
const
UNIX_EPOCH
:
RataDie
=
calendrical_calculations
:
:
iso
:
:
const_fixed_from_iso
(
1970
1
1
)
;
let
rata_die
=
UNIX_EPOCH
+
epoch_days
;
#
[
allow
(
clippy
:
:
unwrap_used
)
]
let
time
=
Time
:
:
try_new
(
(
time_millisecs
/
3600000
)
as
u8
(
(
time_millisecs
%
3600000
)
/
60000
)
as
u8
(
(
time_millisecs
%
60000
)
/
1000
)
as
u8
(
(
time_millisecs
%
1000
)
as
u32
)
*
1000000
)
.
unwrap
(
)
;
ZonedDateTime
{
date
:
Date
:
:
from_rata_die
(
rata_die
Iso
)
time
zone
:
utc_offset
}
}
}
