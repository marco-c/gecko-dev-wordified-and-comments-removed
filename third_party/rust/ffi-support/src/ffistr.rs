use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
#
[
repr
(
transparent
)
]
pub
struct
FfiStr
<
'
a
>
{
cstr
:
*
const
c_char
_boo
:
PhantomData
<
&
'
a
(
)
>
}
impl
<
'
a
>
FfiStr
<
'
a
>
{
#
[
inline
]
pub
unsafe
fn
from_raw
(
ptr
:
*
const
c_char
)
-
>
Self
{
Self
{
cstr
:
ptr
_boo
:
PhantomData
}
}
#
[
inline
]
pub
fn
from_cstr
(
cstr
:
&
'
a
CStr
)
-
>
Self
{
Self
{
cstr
:
cstr
.
as_ptr
(
)
_boo
:
PhantomData
}
}
#
[
inline
]
pub
fn
as_str
(
&
self
)
-
>
&
'
a
str
{
self
.
as_opt_str
(
)
.
expect
(
"
Unexpected
null
string
pointer
passed
to
rust
"
)
}
pub
fn
as_opt_str
(
&
self
)
-
>
Option
<
&
'
a
str
>
{
if
self
.
cstr
.
is_null
(
)
{
return
None
;
}
unsafe
{
match
std
:
:
ffi
:
:
CStr
:
:
from_ptr
(
self
.
cstr
)
.
to_str
(
)
{
Ok
(
s
)
=
>
Some
(
s
)
Err
(
e
)
=
>
{
log
:
:
error
!
(
"
Invalid
UTF
-
8
was
passed
to
rust
!
{
:
?
}
"
e
)
;
None
}
}
}
}
/
/
/
Get
an
Option
<
String
>
out
of
the
FfiStr
.
Returns
None
if
this
/
/
/
FfiStr
holds
a
null
pointer
.
Note
that
unlike
[
FfiStr
:
:
as_opt_str
]
/
/
/
invalid
UTF
-
8
is
replaced
with
the
replacement
character
instead
of
/
/
/
causing
us
to
return
None
.
/
/
/
/
/
/
If
the
string
should
be
mandatory
you
should
use
/
/
/
[
FfiStr
:
:
into_string
]
instead
.
If
an
owned
string
is
not
needed
you
/
/
/
may
want
to
use
[
FfiStr
:
:
as_str
]
or
[
FfiStr
:
:
as_opt_str
]
instead
/
/
/
(
however
note
the
differences
in
how
invalid
UTF
-
8
is
handled
should
/
/
/
this
be
relevant
to
your
use
)
.
pub
fn
into_opt_string
(
self
)
-
>
Option
<
String
>
{
if
!
self
.
cstr
.
is_null
(
)
{
unsafe
{
Some
(
CStr
:
:
from_ptr
(
self
.
cstr
)
.
to_string_lossy
(
)
.
to_string
(
)
)
}
}
else
{
None
}
}
/
/
/
Get
a
String
out
of
a
FfiStr
.
This
function
is
essential
a
/
/
/
convenience
wrapper
for
ffi_str
.
into_opt_string
(
)
.
unwrap
(
)
with
a
/
/
/
message
that
indicates
that
a
null
argument
was
passed
to
rust
when
it
/
/
/
should
be
mandatory
.
As
with
[
FfiStr
:
:
into_opt_string
]
invalid
UTF
-
8
/
/
/
is
replaced
with
the
replacement
character
if
encountered
.
/
/
/
/
/
/
If
the
string
should
*
not
*
be
mandatory
you
should
use
/
/
/
[
FfiStr
:
:
into_opt_string
]
instead
.
If
an
owned
string
is
not
needed
/
/
/
you
may
want
to
use
[
FfiStr
:
:
as_str
]
or
[
FfiStr
:
:
as_opt_str
]
/
/
/
instead
(
however
note
the
differences
in
how
invalid
UTF
-
8
is
handled
/
/
/
should
this
be
relevant
to
your
use
)
.
#
[
inline
]
pub
fn
into_string
(
self
)
-
>
String
{
self
.
into_opt_string
(
)
.
expect
(
"
Unexpected
null
string
pointer
passed
to
rust
"
)
}
}
impl
<
'
a
>
std
:
:
fmt
:
:
Debug
for
FfiStr
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
if
let
Some
(
s
)
=
self
.
as_opt_str
(
)
{
write
!
(
f
"
FfiStr
(
{
:
?
}
)
"
s
)
}
else
{
write
!
(
f
"
FfiStr
(
null
)
"
)
}
}
}
impl
<
'
a
>
From
<
FfiStr
<
'
a
>
>
for
String
{
#
[
inline
]
fn
from
(
f
:
FfiStr
<
'
a
>
)
-
>
Self
{
f
.
into_string
(
)
}
}
impl
<
'
a
>
From
<
FfiStr
<
'
a
>
>
for
Option
<
String
>
{
#
[
inline
]
fn
from
(
f
:
FfiStr
<
'
a
>
)
-
>
Self
{
f
.
into_opt_string
(
)
}
}
impl
<
'
a
>
From
<
FfiStr
<
'
a
>
>
for
Option
<
&
'
a
str
>
{
#
[
inline
]
fn
from
(
f
:
FfiStr
<
'
a
>
)
-
>
Self
{
f
.
as_opt_str
(
)
}
}
impl
<
'
a
>
From
<
FfiStr
<
'
a
>
>
for
&
'
a
str
{
#
[
inline
]
fn
from
(
f
:
FfiStr
<
'
a
>
)
-
>
Self
{
f
.
as_str
(
)
}
}
impl
<
'
a
>
PartialEq
for
FfiStr
<
'
a
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
FfiStr
<
'
a
>
)
-
>
bool
{
self
.
as_opt_str
(
)
=
=
other
.
as_opt_str
(
)
}
}
impl
<
'
a
>
PartialEq
<
str
>
for
FfiStr
<
'
a
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
self
.
as_opt_str
(
)
=
=
Some
(
other
)
}
}
impl
<
'
a
'
b
>
PartialEq
<
&
'
b
str
>
for
FfiStr
<
'
a
>
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
&
'
b
str
)
-
>
bool
{
self
.
as_opt_str
(
)
=
=
Some
(
*
other
)
}
}
impl
<
'
a
>
PartialEq
<
FfiStr
<
'
a
>
>
for
str
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
FfiStr
<
'
a
>
)
-
>
bool
{
Some
(
self
)
=
=
other
.
as_opt_str
(
)
}
}
impl
<
'
a
'
b
>
PartialEq
<
FfiStr
<
'
a
>
>
for
&
'
b
str
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
FfiStr
<
'
a
>
)
-
>
bool
{
Some
(
*
self
)
=
=
other
.
as_opt_str
(
)
}
}
