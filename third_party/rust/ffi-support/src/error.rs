use
crate
:
:
string
:
:
{
destroy_c_string
rust_string_to_c
}
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
{
self
ptr
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ExternError
{
code
:
ErrorCode
message
:
*
mut
c_char
}
impl
std
:
:
panic
:
:
UnwindSafe
for
ExternError
{
}
impl
std
:
:
panic
:
:
RefUnwindSafe
for
ExternError
{
}
unsafe
impl
Send
for
ExternError
{
}
impl
ExternError
{
#
[
inline
]
pub
fn
new_error
(
code
:
ErrorCode
message
:
impl
Into
<
String
>
)
-
>
Self
{
assert
!
(
!
code
.
is_success
(
)
"
Attempted
to
construct
a
success
ExternError
with
a
message
"
)
;
Self
{
code
message
:
rust_string_to_c
(
message
)
}
}
#
[
inline
]
pub
fn
success
(
)
-
>
Self
{
Self
{
code
:
ErrorCode
:
:
SUCCESS
message
:
ptr
:
:
null_mut
(
)
}
}
pub
fn
consume_and_log_if_error
(
self
)
{
if
!
self
.
code
.
is_success
(
)
{
crate
:
:
abort_on_panic
:
:
call_with_output
(
|
|
{
log
:
:
error
!
(
"
Unhandled
ExternError
(
{
:
?
}
)
{
:
?
}
"
self
.
code
unsafe
{
crate
:
:
FfiStr
:
:
from_raw
(
self
.
message
)
}
)
;
unsafe
{
self
.
manually_release
(
)
;
}
}
)
}
}
#
[
inline
]
pub
fn
get_code
(
&
self
)
-
>
ErrorCode
{
self
.
code
}
#
[
inline
]
pub
fn
get_raw_message
(
&
self
)
-
>
*
const
c_char
{
self
.
message
as
*
const
_
}
#
[
inline
]
pub
fn
get_message
(
&
self
)
-
>
crate
:
:
FfiStr
<
'
_
>
{
unsafe
{
crate
:
:
FfiStr
:
:
from_raw
(
self
.
get_raw_message
(
)
)
}
}
#
[
inline
]
pub
unsafe
fn
get_and_consume_message
(
self
)
-
>
Option
<
String
>
{
if
self
.
code
.
is_success
(
)
{
None
}
else
{
let
res
=
self
.
get_message
(
)
.
into_string
(
)
;
self
.
manually_release
(
)
;
Some
(
res
)
}
}
pub
unsafe
fn
manually_release
(
self
)
{
if
!
self
.
message
.
is_null
(
)
{
destroy_c_string
(
self
.
message
)
}
}
}
impl
Default
for
ExternError
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
ExternError
:
:
success
(
)
}
}
impl
From
<
Box
<
dyn
std
:
:
any
:
:
Any
+
Send
+
'
static
>
>
for
ExternError
{
fn
from
(
e
:
Box
<
dyn
std
:
:
any
:
:
Any
+
Send
+
'
static
>
)
-
>
Self
{
let
message
=
if
let
Some
(
s
)
=
e
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
(
*
s
)
.
to_string
(
)
}
else
if
let
Some
(
s
)
=
e
.
downcast_ref
:
:
<
String
>
(
)
{
s
.
clone
(
)
}
else
{
"
Unknown
panic
!
"
.
to_string
(
)
}
;
log
:
:
error
!
(
"
Caught
a
panic
calling
rust
code
:
{
:
?
}
"
message
)
;
ExternError
:
:
new_error
(
ErrorCode
:
:
PANIC
message
)
}
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
Default
)
]
pub
struct
ErrorCode
(
i32
)
;
impl
ErrorCode
{
pub
const
SUCCESS
:
ErrorCode
=
ErrorCode
(
0
)
;
pub
const
PANIC
:
ErrorCode
=
ErrorCode
(
-
1
)
;
pub
const
INVALID_HANDLE
:
ErrorCode
=
ErrorCode
(
-
1000
)
;
pub
fn
new
(
code
:
i32
)
-
>
Self
{
assert
!
(
code
>
ErrorCode
:
:
INVALID_HANDLE
.
0
&
&
code
!
=
ErrorCode
:
:
PANIC
.
0
&
&
code
!
=
ErrorCode
:
:
SUCCESS
.
0
"
Error
:
The
ErrorCodes
{
success
}
{
panic
}
and
all
error
codes
less
than
or
equal
\
to
{
reserved
}
are
reserved
(
got
{
code
}
)
.
You
may
use
the
associated
constants
on
this
\
type
(
ErrorCode
:
:
PANIC
etc
)
if
you
'
d
like
instances
of
those
error
codes
.
"
panic
=
ErrorCode
:
:
PANIC
.
0
success
=
ErrorCode
:
:
SUCCESS
.
0
reserved
=
ErrorCode
:
:
INVALID_HANDLE
.
0
code
=
code
)
;
ErrorCode
(
code
)
}
#
[
inline
]
pub
fn
code
(
self
)
-
>
i32
{
self
.
0
}
#
[
inline
]
pub
fn
is_success
(
self
)
-
>
bool
{
self
.
code
(
)
=
=
0
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_success
(
)
{
ErrorCode
:
:
new
(
0
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_panic
(
)
{
ErrorCode
:
:
new
(
-
1
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_handle_error
(
)
{
ErrorCode
:
:
new
(
-
1000
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_unknown
(
)
{
ErrorCode
:
:
new
(
-
1043
)
;
}
#
[
test
]
fn
test_code_new_allowed
(
)
{
ErrorCode
:
:
new
(
-
2
)
;
}
#
[
test
]
fn
test_code
(
)
{
assert
!
(
!
ErrorCode
:
:
PANIC
.
is_success
(
)
)
;
assert
!
(
!
ErrorCode
:
:
INVALID_HANDLE
.
is_success
(
)
)
;
assert
!
(
ErrorCode
:
:
SUCCESS
.
is_success
(
)
)
;
assert_eq
!
(
ErrorCode
:
:
default
(
)
ErrorCode
:
:
SUCCESS
)
;
}
}
