use
crate
:
:
string
:
:
{
destroy_c_string
rust_string_to_c
}
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
{
self
ptr
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
ExternError
{
code
:
ErrorCode
message
:
*
mut
c_char
}
impl
std
:
:
panic
:
:
UnwindSafe
for
ExternError
{
}
impl
std
:
:
panic
:
:
RefUnwindSafe
for
ExternError
{
}
unsafe
impl
Send
for
ExternError
{
}
impl
ExternError
{
#
[
inline
]
pub
fn
new_error
(
code
:
ErrorCode
message
:
impl
Into
<
String
>
)
-
>
Self
{
assert
!
(
!
code
.
is_success
(
)
"
Attempted
to
construct
a
success
ExternError
with
a
message
"
)
;
Self
{
code
message
:
rust_string_to_c
(
message
)
}
}
#
[
inline
]
pub
fn
success
(
)
-
>
Self
{
Self
{
code
:
ErrorCode
:
:
SUCCESS
message
:
ptr
:
:
null_mut
(
)
}
}
pub
fn
consume_and_log_if_error
(
self
)
{
if
!
self
.
code
.
is_success
(
)
{
crate
:
:
abort_on_panic
:
:
call_with_output
(
|
|
{
log
:
:
error
!
(
"
Unhandled
ExternError
(
{
:
?
}
)
{
:
?
}
"
self
.
code
unsafe
{
crate
:
:
FfiStr
:
:
from_raw
(
self
.
message
)
}
)
;
unsafe
{
self
.
manually_release
(
)
;
}
}
)
}
}
/
/
/
Get
the
code
property
.
#
[
inline
]
pub
fn
get_code
(
&
self
)
-
>
ErrorCode
{
self
.
code
}
/
/
/
Get
the
message
property
as
a
pointer
to
c_char
.
#
[
inline
]
pub
fn
get_raw_message
(
&
self
)
-
>
*
const
c_char
{
self
.
message
as
*
const
_
}
/
/
/
Get
the
message
property
as
an
[
FfiStr
]
#
[
inline
]
pub
fn
get_message
(
&
self
)
-
>
crate
:
:
FfiStr
<
'
_
>
{
/
/
Safe
because
the
lifetime
is
the
same
as
our
lifetime
.
unsafe
{
crate
:
:
FfiStr
:
:
from_raw
(
self
.
get_raw_message
(
)
)
}
}
/
/
/
Get
the
message
property
as
a
String
or
None
if
this
is
not
an
error
result
.
/
/
/
/
/
/
#
#
Safety
/
/
/
/
/
/
You
should
only
call
this
if
you
are
certain
that
the
other
side
of
the
FFI
doesn
'
t
have
a
/
/
/
reference
to
this
result
(
more
specifically
to
the
message
property
)
anywhere
!
#
[
inline
]
pub
unsafe
fn
get_and_consume_message
(
self
)
-
>
Option
<
String
>
{
if
self
.
code
.
is_success
(
)
{
None
}
else
{
let
res
=
self
.
get_message
(
)
.
into_string
(
)
;
self
.
manually_release
(
)
;
Some
(
res
)
}
}
/
/
/
Manually
release
the
memory
behind
this
string
.
You
probably
don
'
t
want
to
call
this
.
/
/
/
/
/
/
#
#
Safety
/
/
/
/
/
/
You
should
only
call
this
if
you
are
certain
that
the
other
side
of
the
FFI
doesn
'
t
have
a
/
/
/
reference
to
this
result
(
more
specifically
to
the
message
property
)
anywhere
!
pub
unsafe
fn
manually_release
(
self
)
{
if
!
self
.
message
.
is_null
(
)
{
destroy_c_string
(
self
.
message
)
}
}
}
impl
Default
for
ExternError
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
ExternError
:
:
success
(
)
}
}
/
/
This
is
the
Err
of
std
:
:
thread
:
:
Result
which
is
what
/
/
panic
:
:
catch_unwind
returns
.
impl
From
<
Box
<
dyn
std
:
:
any
:
:
Any
+
Send
+
'
static
>
>
for
ExternError
{
fn
from
(
e
:
Box
<
dyn
std
:
:
any
:
:
Any
+
Send
+
'
static
>
)
-
>
Self
{
/
/
The
documentation
suggests
that
it
will
*
usually
*
be
a
str
or
String
.
let
message
=
if
let
Some
(
s
)
=
e
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
s
.
to_string
(
)
}
else
if
let
Some
(
s
)
=
e
.
downcast_ref
:
:
<
String
>
(
)
{
s
.
clone
(
)
}
else
{
"
Unknown
panic
!
"
.
to_string
(
)
}
;
log
:
:
error
!
(
"
Caught
a
panic
calling
rust
code
:
{
:
?
}
"
message
)
;
ExternError
:
:
new_error
(
ErrorCode
:
:
PANIC
message
)
}
}
/
/
/
A
wrapper
around
error
codes
which
is
represented
identically
to
an
i32
on
the
other
side
of
/
/
/
the
FFI
.
Essentially
exists
to
check
that
we
don
'
t
accidentally
reuse
success
/
panic
codes
for
/
/
/
other
things
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Debug
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
Default
)
]
pub
struct
ErrorCode
(
i32
)
;
impl
ErrorCode
{
/
/
/
The
ErrorCode
used
for
success
.
pub
const
SUCCESS
:
ErrorCode
=
ErrorCode
(
0
)
;
/
/
/
The
ErrorCode
used
for
panics
.
It
'
s
unlikely
you
need
to
ever
use
this
.
/
/
TODO
:
Consider
moving
to
the
reserved
region
.
.
.
pub
const
PANIC
:
ErrorCode
=
ErrorCode
(
-
1
)
;
/
/
/
The
ErrorCode
used
for
handle
map
errors
.
pub
const
INVALID_HANDLE
:
ErrorCode
=
ErrorCode
(
-
1000
)
;
/
/
/
Construct
an
error
code
from
an
integer
code
.
/
/
/
/
/
/
#
#
Panics
/
/
/
/
/
/
Panics
if
you
call
it
with
0
(
reserved
for
success
but
you
can
use
ErrorCode
:
:
SUCCESS
if
/
/
/
that
'
s
what
you
want
)
or
-
1
(
reserved
for
panics
but
you
can
use
ErrorCode
:
:
PANIC
if
/
/
/
that
'
s
what
you
want
)
.
pub
fn
new
(
code
:
i32
)
-
>
Self
{
assert
!
(
code
>
ErrorCode
:
:
INVALID_HANDLE
.
0
&
&
code
!
=
ErrorCode
:
:
PANIC
.
0
&
&
code
!
=
ErrorCode
:
:
SUCCESS
.
0
"
Error
:
The
ErrorCodes
{
success
}
{
panic
}
and
all
error
codes
less
than
or
equal
\
to
{
reserved
}
are
reserved
(
got
{
code
}
)
.
You
may
use
the
associated
constants
on
this
\
type
(
ErrorCode
:
:
PANIC
etc
)
if
you
'
d
like
instances
of
those
error
codes
.
"
panic
=
ErrorCode
:
:
PANIC
.
0
success
=
ErrorCode
:
:
SUCCESS
.
0
reserved
=
ErrorCode
:
:
INVALID_HANDLE
.
0
code
=
code
)
;
ErrorCode
(
code
)
}
#
[
inline
]
pub
fn
code
(
self
)
-
>
i32
{
self
.
0
}
#
[
inline
]
pub
fn
is_success
(
self
)
-
>
bool
{
self
.
code
(
)
=
=
0
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_success
(
)
{
ErrorCode
:
:
new
(
0
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_panic
(
)
{
ErrorCode
:
:
new
(
-
1
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_handle_error
(
)
{
ErrorCode
:
:
new
(
-
1000
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_code_new_reserved_unknown
(
)
{
ErrorCode
:
:
new
(
-
1043
)
;
}
#
[
test
]
fn
test_code_new_allowed
(
)
{
ErrorCode
:
:
new
(
-
2
)
;
}
#
[
test
]
fn
test_code
(
)
{
assert
!
(
!
ErrorCode
:
:
PANIC
.
is_success
(
)
)
;
assert
!
(
!
ErrorCode
:
:
INVALID_HANDLE
.
is_success
(
)
)
;
assert
!
(
ErrorCode
:
:
SUCCESS
.
is_success
(
)
)
;
assert_eq
!
(
ErrorCode
:
:
default
(
)
ErrorCode
:
:
SUCCESS
)
;
}
}
