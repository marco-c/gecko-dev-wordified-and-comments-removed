#
!
[
deny
(
missing_docs
)
]
#
!
[
allow
(
unknown_lints
)
]
#
!
[
warn
(
rust_2018_idioms
)
]
use
std
:
:
{
panic
thread
}
;
mod
error
;
mod
ffistr
;
pub
mod
handle_map
;
mod
into_ffi
;
#
[
macro_use
]
mod
macros
;
mod
string
;
pub
use
crate
:
:
error
:
:
*
;
pub
use
crate
:
:
ffistr
:
:
FfiStr
;
pub
use
crate
:
:
into_ffi
:
:
*
;
pub
use
crate
:
:
macros
:
:
*
;
pub
use
crate
:
:
string
:
:
*
;
pub
use
crate
:
:
handle_map
:
:
{
ConcurrentHandleMap
Handle
HandleError
HandleMap
}
;
pub
fn
call_with_result
<
R
E
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
E
>
E
:
Into
<
ExternError
>
R
:
IntoFfi
{
call_with_result_impl
(
out_error
callback
)
}
pub
fn
call_with_output
<
R
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
R
R
:
IntoFfi
{
call_with_result
(
out_error
|
|
-
>
Result
<
_
ExternError
>
{
Ok
(
callback
(
)
)
}
)
}
fn
call_with_result_impl
<
R
E
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
E
>
E
:
Into
<
ExternError
>
R
:
IntoFfi
{
*
out_error
=
ExternError
:
:
success
(
)
;
let
res
:
thread
:
:
Result
<
(
ExternError
R
:
:
Value
)
>
=
panic
:
:
catch_unwind
(
|
|
{
init_panic_handling_once
(
)
;
match
callback
(
)
{
Ok
(
v
)
=
>
(
ExternError
:
:
default
(
)
v
.
into_ffi_value
(
)
)
Err
(
e
)
=
>
(
e
.
into
(
)
R
:
:
ffi_default
(
)
)
}
}
)
;
match
res
{
Ok
(
(
err
o
)
)
=
>
{
*
out_error
=
err
;
o
}
Err
(
e
)
=
>
{
*
out_error
=
e
.
into
(
)
;
R
:
:
ffi_default
(
)
}
}
}
pub
mod
abort_on_panic
{
use
super
:
:
*
;
struct
AbortOnDrop
;
impl
Drop
for
AbortOnDrop
{
fn
drop
(
&
mut
self
)
{
std
:
:
process
:
:
abort
(
)
;
}
}
#
[
inline
]
pub
fn
with_abort_on_panic
<
R
F
>
(
callback
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
let
aborter
=
AbortOnDrop
;
let
res
=
callback
(
)
;
std
:
:
mem
:
:
forget
(
aborter
)
;
res
}
pub
fn
call_with_result
<
R
E
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
FnOnce
(
)
-
>
Result
<
R
E
>
E
:
Into
<
ExternError
>
R
:
IntoFfi
{
with_abort_on_panic
(
|
|
match
callback
(
)
{
Ok
(
v
)
=
>
{
*
out_error
=
ExternError
:
:
default
(
)
;
v
.
into_ffi_value
(
)
}
Err
(
e
)
=
>
{
*
out_error
=
e
.
into
(
)
;
R
:
:
ffi_default
(
)
}
}
)
}
pub
fn
call_with_output
<
R
F
>
(
callback
:
F
)
-
>
R
:
:
Value
where
F
:
FnOnce
(
)
-
>
R
R
:
IntoFfi
{
with_abort_on_panic
(
callback
)
.
into_ffi_value
(
)
}
}
#
[
cfg
(
feature
=
"
log_panics
"
)
]
fn
init_panic_handling_once
(
)
{
use
std
:
:
sync
:
:
{
Once
ONCE_INIT
}
;
static
INIT_BACKTRACES
:
Once
=
ONCE_INIT
;
INIT_BACKTRACES
.
call_once
(
move
|
|
{
#
[
cfg
(
all
(
feature
=
"
log_backtraces
"
not
(
target_os
=
"
android
"
)
)
)
]
{
std
:
:
env
:
:
set_var
(
"
RUST_BACKTRACE
"
"
1
"
)
;
}
std
:
:
panic
:
:
set_hook
(
Box
:
:
new
(
move
|
panic_info
|
{
let
(
file
line
)
=
if
let
Some
(
loc
)
=
panic_info
.
location
(
)
{
(
loc
.
file
(
)
loc
.
line
(
)
)
}
else
{
(
"
<
unknown
>
"
0
)
}
;
log
:
:
error
!
(
"
#
#
#
Rust
panic
!
hit
at
file
'
{
}
'
line
{
}
"
file
line
)
;
/
/
We
could
use
failure
for
failure
:
:
Backtrace
(
and
we
enable
RUST_BACKTRACE
/
/
to
opt
-
in
to
backtraces
on
failure
errors
if
possible
)
however
:
/
/
-
failure
only
checks
the
RUST_BACKTRACE
variable
once
and
we
could
have
errors
/
/
before
this
.
So
we
just
use
the
backtrace
crate
directly
.
#
[
cfg
(
all
(
feature
=
"
log_backtraces
"
not
(
target_os
=
"
android
"
)
)
)
]
{
log
:
:
error
!
(
"
Complete
stack
trace
:
\
n
{
:
?
}
"
backtrace
:
:
Backtrace
:
:
new
(
)
)
;
}
}
)
)
;
}
)
;
}
#
[
cfg
(
not
(
feature
=
"
log_panics
"
)
)
]
fn
init_panic_handling_once
(
)
{
}
/
/
/
ByteBuffer
is
a
struct
that
represents
an
array
of
bytes
to
be
sent
over
the
FFI
boundaries
.
/
/
/
There
are
several
cases
when
you
might
want
to
use
this
but
the
primary
one
for
us
/
/
/
is
for
returning
protobuf
-
encoded
data
to
Swift
and
Java
.
The
type
is
currently
rather
/
/
/
limited
(
implementing
almost
no
functionality
)
however
in
the
future
it
may
be
/
/
/
more
expanded
.
/
/
/
/
/
/
#
#
Caveats
/
/
/
/
/
/
Note
that
the
order
of
the
fields
is
len
(
an
i64
)
then
data
(
a
*
mut
u8
)
getting
/
/
/
this
wrong
on
the
other
side
of
the
FFI
will
cause
memory
corruption
and
crashes
.
/
/
/
i64
is
used
for
the
length
instead
of
u64
and
usize
because
JNA
has
interop
/
/
/
issues
with
both
these
types
.
/
/
/
/
/
/
ByteBuffer
does
not
implement
Drop
.
This
is
intentional
.
Memory
passed
into
it
will
/
/
/
be
leaked
if
it
is
not
explicitly
destroyed
by
calling
[
ByteBuffer
:
:
destroy
]
.
This
/
/
/
is
because
in
the
future
we
may
allow
it
'
s
use
for
passing
data
into
Rust
code
.
/
/
/
ByteBuffer
assuming
ownership
of
the
data
would
make
this
a
problem
.
/
/
/
/
/
/
Note
that
alling
destroy
manually
is
not
typically
needed
or
recommended
/
/
/
and
instead
you
should
use
[
define_bytebuffer_destructor
!
]
.
/
/
/
/
/
/
#
#
Layout
/
fields
/
/
/
/
/
/
This
struct
'
s
field
are
not
pub
(
mostly
so
that
we
can
soundly
implement
Send
but
also
so
/
/
/
that
we
can
verify
rust
users
are
constructing
them
appropriately
)
the
fields
their
types
and
/
/
/
their
order
are
*
very
much
*
a
part
of
the
public
API
of
this
type
.
Consumers
on
the
other
side
/
/
/
of
the
FFI
will
need
to
know
its
layout
.
/
/
/
/
/
/
If
this
were
a
C
struct
it
would
look
like
/
/
/
/
/
/
c
no_run
/
/
/
struct
ByteBuffer
{
/
/
/
int64_t
len
;
/
/
/
uint8_t
*
data
;
/
/
note
:
nullable
/
/
/
}
;
/
/
/
/
/
/
/
/
/
In
rust
there
are
two
fields
in
this
order
:
len
:
i64
and
data
:
*
mut
u8
.
/
/
/
/
/
/
#
#
#
Description
of
fields
/
/
/
/
/
/
data
is
a
pointer
to
an
array
of
len
bytes
.
Not
that
data
can
be
a
null
pointer
and
therefore
/
/
/
should
be
checked
.
/
/
/
/
/
/
The
bytes
array
is
allocated
on
the
heap
and
must
be
freed
on
it
as
well
.
Critically
if
there
/
/
/
are
multiple
rust
packages
using
being
used
in
the
same
application
it
*
must
be
freed
on
the
/
/
/
same
heap
that
allocated
it
*
or
you
will
corrupt
both
heaps
.
/
/
/
/
/
/
Typically
this
object
is
managed
on
the
other
side
of
the
FFI
(
on
the
"
FFI
consumer
"
)
which
/
/
/
means
you
must
expose
a
function
to
release
the
resources
of
data
which
can
be
done
easily
/
/
/
using
the
[
define_bytebuffer_destructor
!
]
macro
provided
by
this
crate
.
#
[
repr
(
C
)
]
pub
struct
ByteBuffer
{
len
:
i64
data
:
*
mut
u8
}
impl
From
<
Vec
<
u8
>
>
for
ByteBuffer
{
#
[
inline
]
fn
from
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
Self
:
:
from_vec
(
bytes
)
}
}
impl
ByteBuffer
{
/
/
/
Creates
a
ByteBuffer
of
the
requested
size
zero
-
filled
.
/
/
/
/
/
/
The
contents
of
the
vector
will
not
be
dropped
.
Instead
destroy
must
/
/
/
be
called
later
to
reclaim
this
memory
or
it
will
be
leaked
.
/
/
/
/
/
/
#
#
Caveats
/
/
/
/
/
/
This
will
panic
if
the
buffer
length
(
usize
)
cannot
fit
into
a
i64
.
#
[
inline
]
pub
fn
new_with_size
(
size
:
usize
)
-
>
Self
{
let
mut
buf
=
vec
!
[
]
;
buf
.
reserve_exact
(
size
)
;
buf
.
resize
(
size
0
)
;
ByteBuffer
:
:
from_vec
(
buf
)
}
/
/
/
Creates
a
ByteBuffer
instance
from
a
Vec
instance
.
/
/
/
/
/
/
The
contents
of
the
vector
will
not
be
dropped
.
Instead
destroy
must
/
/
/
be
called
later
to
reclaim
this
memory
or
it
will
be
leaked
.
/
/
/
/
/
/
#
#
Caveats
/
/
/
/
/
/
This
will
panic
if
the
buffer
length
(
usize
)
cannot
fit
into
a
i64
.
#
[
inline
]
pub
fn
from_vec
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
use
std
:
:
convert
:
:
TryFrom
;
let
mut
buf
=
bytes
.
into_boxed_slice
(
)
;
let
data
=
buf
.
as_mut_ptr
(
)
;
let
len
=
i64
:
:
try_from
(
buf
.
len
(
)
)
.
expect
(
"
buffer
length
cannot
fit
into
a
i64
.
"
)
;
std
:
:
mem
:
:
forget
(
buf
)
;
Self
{
data
len
}
}
#
[
inline
]
pub
fn
into_vec
(
self
)
-
>
Vec
<
u8
>
{
if
self
.
data
.
is_null
(
)
{
vec
!
[
]
}
else
{
unsafe
{
Vec
:
:
from_raw_parts
(
self
.
data
self
.
len
as
usize
self
.
len
as
usize
)
}
}
}
#
[
inline
]
pub
fn
destroy
(
self
)
{
drop
(
self
.
into_vec
(
)
)
}
}
impl
Default
for
ByteBuffer
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
{
len
:
0
as
i64
data
:
std
:
:
ptr
:
:
null_mut
(
)
}
}
}
