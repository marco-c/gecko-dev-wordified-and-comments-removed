#
!
[
deny
(
missing_docs
)
]
#
!
[
allow
(
unknown_lints
)
]
#
!
[
warn
(
rust_2018_idioms
)
]
use
std
:
:
{
panic
thread
}
;
mod
error
;
mod
ffistr
;
pub
mod
handle_map
;
mod
into_ffi
;
#
[
macro_use
]
mod
macros
;
mod
string
;
pub
use
crate
:
:
error
:
:
*
;
pub
use
crate
:
:
ffistr
:
:
FfiStr
;
pub
use
crate
:
:
into_ffi
:
:
*
;
pub
use
crate
:
:
macros
:
:
*
;
pub
use
crate
:
:
string
:
:
*
;
pub
use
crate
:
:
handle_map
:
:
{
ConcurrentHandleMap
Handle
HandleError
HandleMap
}
;
pub
fn
call_with_result
<
R
E
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
E
>
E
:
Into
<
ExternError
>
R
:
IntoFfi
{
call_with_result_impl
(
out_error
callback
)
}
pub
fn
call_with_output
<
R
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
R
R
:
IntoFfi
{
call_with_result
(
out_error
|
|
-
>
Result
<
_
ExternError
>
{
Ok
(
callback
(
)
)
}
)
}
fn
call_with_result_impl
<
R
E
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
panic
:
:
UnwindSafe
+
FnOnce
(
)
-
>
Result
<
R
E
>
E
:
Into
<
ExternError
>
R
:
IntoFfi
{
*
out_error
=
ExternError
:
:
success
(
)
;
let
res
:
thread
:
:
Result
<
(
ExternError
R
:
:
Value
)
>
=
panic
:
:
catch_unwind
(
|
|
{
init_panic_handling_once
(
)
;
match
callback
(
)
{
Ok
(
v
)
=
>
(
ExternError
:
:
default
(
)
v
.
into_ffi_value
(
)
)
Err
(
e
)
=
>
(
e
.
into
(
)
R
:
:
ffi_default
(
)
)
}
}
)
;
match
res
{
Ok
(
(
err
o
)
)
=
>
{
*
out_error
=
err
;
o
}
Err
(
e
)
=
>
{
*
out_error
=
e
.
into
(
)
;
R
:
:
ffi_default
(
)
}
}
}
pub
mod
abort_on_panic
{
use
super
:
:
*
;
struct
AbortOnDrop
;
impl
Drop
for
AbortOnDrop
{
fn
drop
(
&
mut
self
)
{
std
:
:
process
:
:
abort
(
)
;
}
}
#
[
inline
]
pub
fn
with_abort_on_panic
<
R
F
>
(
callback
:
F
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
{
let
aborter
=
AbortOnDrop
;
let
res
=
callback
(
)
;
std
:
:
mem
:
:
forget
(
aborter
)
;
res
}
pub
fn
call_with_result
<
R
E
F
>
(
out_error
:
&
mut
ExternError
callback
:
F
)
-
>
R
:
:
Value
where
F
:
FnOnce
(
)
-
>
Result
<
R
E
>
E
:
Into
<
ExternError
>
R
:
IntoFfi
{
with_abort_on_panic
(
|
|
match
callback
(
)
{
Ok
(
v
)
=
>
{
*
out_error
=
ExternError
:
:
default
(
)
;
v
.
into_ffi_value
(
)
}
Err
(
e
)
=
>
{
*
out_error
=
e
.
into
(
)
;
R
:
:
ffi_default
(
)
}
}
)
}
pub
fn
call_with_output
<
R
F
>
(
callback
:
F
)
-
>
R
:
:
Value
where
F
:
FnOnce
(
)
-
>
R
R
:
IntoFfi
{
with_abort_on_panic
(
callback
)
.
into_ffi_value
(
)
}
}
#
[
cfg
(
feature
=
"
log_panics
"
)
]
fn
init_panic_handling_once
(
)
{
use
std
:
:
sync
:
:
Once
;
static
INIT_BACKTRACES
:
Once
=
Once
:
:
new
(
)
;
INIT_BACKTRACES
.
call_once
(
move
|
|
{
#
[
cfg
(
all
(
feature
=
"
log_backtraces
"
not
(
target_os
=
"
android
"
)
)
)
]
{
std
:
:
env
:
:
set_var
(
"
RUST_BACKTRACE
"
"
1
"
)
;
}
std
:
:
panic
:
:
set_hook
(
Box
:
:
new
(
move
|
panic_info
|
{
let
(
file
line
)
=
if
let
Some
(
loc
)
=
panic_info
.
location
(
)
{
(
loc
.
file
(
)
loc
.
line
(
)
)
}
else
{
(
"
<
unknown
>
"
0
)
}
;
log
:
:
error
!
(
"
#
#
#
Rust
panic
!
hit
at
file
'
{
}
'
line
{
}
"
file
line
)
;
#
[
cfg
(
all
(
feature
=
"
log_backtraces
"
not
(
target_os
=
"
android
"
)
)
)
]
{
log
:
:
error
!
(
"
Complete
stack
trace
:
\
n
{
:
?
}
"
backtrace
:
:
Backtrace
:
:
new
(
)
)
;
}
}
)
)
;
}
)
;
}
#
[
cfg
(
not
(
feature
=
"
log_panics
"
)
)
]
fn
init_panic_handling_once
(
)
{
}
#
[
repr
(
C
)
]
pub
struct
ByteBuffer
{
len
:
i64
data
:
*
mut
u8
}
impl
From
<
Vec
<
u8
>
>
for
ByteBuffer
{
#
[
inline
]
fn
from
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
Self
:
:
from_vec
(
bytes
)
}
}
impl
ByteBuffer
{
#
[
inline
]
pub
fn
new_with_size
(
size
:
usize
)
-
>
Self
{
assert
!
(
size
<
i64
:
:
MAX
as
usize
)
;
let
mut
buf
=
vec
!
[
]
;
buf
.
reserve_exact
(
size
)
;
buf
.
resize
(
size
0
)
;
ByteBuffer
:
:
from_vec
(
buf
)
}
#
[
inline
]
pub
fn
from_vec
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
use
std
:
:
convert
:
:
TryFrom
;
let
mut
buf
=
bytes
.
into_boxed_slice
(
)
;
let
data
=
buf
.
as_mut_ptr
(
)
;
let
len
=
i64
:
:
try_from
(
buf
.
len
(
)
)
.
expect
(
"
buffer
length
cannot
fit
into
a
i64
.
"
)
;
std
:
:
mem
:
:
forget
(
buf
)
;
Self
{
data
len
}
}
#
[
inline
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
u8
]
{
if
self
.
data
.
is_null
(
)
{
&
[
]
}
else
{
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
self
.
data
self
.
len
(
)
)
}
}
}
#
[
inline
]
fn
len
(
&
self
)
-
>
usize
{
use
std
:
:
convert
:
:
TryInto
;
self
.
len
.
try_into
(
)
.
expect
(
"
ByteBuffer
length
negative
or
overflowed
"
)
}
#
[
inline
]
pub
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
if
self
.
data
.
is_null
(
)
{
&
mut
[
]
}
else
{
unsafe
{
std
:
:
slice
:
:
from_raw_parts_mut
(
self
.
data
self
.
len
(
)
)
}
}
}
#
[
inline
]
#
[
deprecated
=
"
Name
is
confusing
please
use
destroy_into_vec
instead
"
]
pub
fn
into_vec
(
self
)
-
>
Vec
<
u8
>
{
self
.
destroy_into_vec
(
)
}
#
[
inline
]
pub
fn
destroy_into_vec
(
self
)
-
>
Vec
<
u8
>
{
if
self
.
data
.
is_null
(
)
{
vec
!
[
]
}
else
{
let
len
=
self
.
len
(
)
;
unsafe
{
Vec
:
:
from_raw_parts
(
self
.
data
len
len
)
}
}
}
#
[
inline
]
pub
fn
destroy
(
self
)
{
drop
(
self
.
destroy_into_vec
(
)
)
}
}
impl
Default
for
ByteBuffer
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
{
len
:
0
as
i64
data
:
std
:
:
ptr
:
:
null_mut
(
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_bb_access
(
)
{
let
mut
bb
=
ByteBuffer
:
:
from
(
vec
!
[
1u8
2
3
]
)
;
assert_eq
!
(
bb
.
as_slice
(
)
&
[
1u8
2
3
]
)
;
assert_eq
!
(
bb
.
as_mut_slice
(
)
&
mut
[
1u8
2
3
]
)
;
bb
.
as_mut_slice
(
)
[
2
]
=
4
;
#
[
allow
(
deprecated
)
]
{
assert_eq
!
(
bb
.
into_vec
(
)
&
[
1u8
2
4
]
)
;
}
}
#
[
test
]
fn
test_bb_empty
(
)
{
let
mut
bb
=
ByteBuffer
:
:
default
(
)
;
assert_eq
!
(
bb
.
as_slice
(
)
&
[
]
)
;
assert_eq
!
(
bb
.
as_mut_slice
(
)
&
[
]
)
;
assert_eq
!
(
bb
.
destroy_into_vec
(
)
&
[
]
)
;
}
#
[
test
]
fn
test_bb_new
(
)
{
let
bb
=
ByteBuffer
:
:
new_with_size
(
5
)
;
assert_eq
!
(
bb
.
as_slice
(
)
&
[
0u8
0
0
0
0
]
)
;
bb
.
destroy
(
)
;
let
bb
=
ByteBuffer
:
:
new_with_size
(
0
)
;
assert_eq
!
(
bb
.
as_slice
(
)
&
[
]
)
;
assert
!
(
!
bb
.
data
.
is_null
(
)
)
;
bb
.
destroy
(
)
;
let
bb
=
ByteBuffer
:
:
from_vec
(
vec
!
[
]
)
;
assert_eq
!
(
bb
.
as_slice
(
)
&
[
]
)
;
assert
!
(
!
bb
.
data
.
is_null
(
)
)
;
bb
.
destroy
(
)
;
}
}
