#
[
macro_export
]
macro_rules
!
implement_into_ffi_by_pointer
{
(
(
T
:
ty
)
*
(
)
*
)
=
>
{
(
unsafe
impl
crate
:
:
IntoFfi
for
T
where
T
:
Send
{
type
Value
=
*
mut
T
;
#
[
inline
]
fn
ffi_default
(
)
-
>
*
mut
T
{
std
:
:
ptr
:
:
null_mut
(
)
}
#
[
inline
]
fn
into_ffi_value
(
self
)
-
>
*
mut
T
{
Box
:
:
into_raw
(
Box
:
:
new
(
self
)
)
}
}
)
*
}
}
#
[
macro_export
]
macro_rules
!
implement_into_ffi_by_json
{
(
(
T
:
ty
)
*
(
)
*
)
=
>
{
(
unsafe
impl
crate
:
:
IntoFfi
for
T
where
T
:
serde
:
:
Serialize
{
type
Value
=
*
mut
std
:
:
os
:
:
raw
:
:
c_char
;
#
[
inline
]
fn
ffi_default
(
)
-
>
*
mut
std
:
:
os
:
:
raw
:
:
c_char
{
std
:
:
ptr
:
:
null_mut
(
)
}
#
[
inline
]
fn
into_ffi_value
(
self
)
-
>
*
mut
std
:
:
os
:
:
raw
:
:
c_char
{
/
/
This
panic
is
inside
our
catch_panic
so
it
should
be
fine
.
/
/
We
'
ve
also
documented
the
case
where
the
IntoFfi
impl
that
/
/
calls
this
panics
and
it
'
s
rare
enough
that
it
shouldn
'
t
/
/
matter
that
if
it
happens
we
return
an
ExternError
/
/
representing
a
panic
instead
of
one
of
some
other
type
/
/
(
especially
given
that
the
application
isn
'
t
likely
to
be
/
/
able
to
meaningfully
handle
JSON
serialization
failure
)
.
let
as_string
=
serde_json
:
:
to_string
(
&
self
)
.
unwrap
(
)
;
crate
:
:
rust_string_to_c
(
as_string
)
}
}
)
*
}
}
#
[
macro_export
]
macro_rules
!
implement_into_ffi_by_protobuf
{
(
(
FFIType
:
ty
)
*
(
)
*
)
=
>
{
(
unsafe
impl
crate
:
:
IntoFfi
for
FFIType
where
FFIType
:
prost
:
:
Message
{
type
Value
=
crate
:
:
ByteBuffer
;
#
[
inline
]
fn
ffi_default
(
)
-
>
Self
:
:
Value
{
Default
:
:
default
(
)
}
#
[
inline
]
fn
into_ffi_value
(
self
)
-
>
Self
:
:
Value
{
use
prost
:
:
Message
;
let
mut
bytes
=
Vec
:
:
with_capacity
(
self
.
encoded_len
(
)
)
;
/
/
Unwrap
is
safe
since
we
have
reserved
sufficient
capacity
in
/
/
the
vector
.
self
.
encode
(
&
mut
bytes
)
.
unwrap
(
)
;
bytes
.
into
(
)
}
}
)
*
}
}
#
[
macro_export
]
macro_rules
!
implement_into_ffi_by_delegation
{
(
SrcTy
:
ty
MidTy
:
ty
)
=
>
{
unsafe
impl
crate
:
:
IntoFfi
for
SrcTy
where
MidTy
:
From
<
SrcTy
>
+
crate
:
:
IntoFfi
{
/
/
The
<
MidTy
as
SomeTrait
>
:
:
method
is
required
even
when
it
would
/
/
be
ambiguous
due
to
some
obscure
details
of
macro
syntax
.
type
Value
=
<
MidTy
as
crate
:
:
IntoFfi
>
:
:
Value
;
#
[
inline
]
fn
ffi_default
(
)
-
>
Self
:
:
Value
{
<
MidTy
as
crate
:
:
IntoFfi
>
:
:
ffi_default
(
)
}
#
[
inline
]
fn
into_ffi_value
(
self
)
-
>
Self
:
:
Value
{
use
crate
:
:
IntoFfi
;
<
MidTy
as
From
<
SrcTy
>
>
:
:
from
(
self
)
.
into_ffi_value
(
)
}
}
}
;
}
#
[
macro_export
]
macro_rules
!
define_string_destructor
{
(
mylib_destroy_string
:
ident
)
=
>
{
#
[
doc
=
"
Public
destructor
for
strings
managed
by
the
other
side
of
the
FFI
.
"
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mylib_destroy_string
(
s
:
*
mut
std
:
:
os
:
:
raw
:
:
c_char
)
{
/
/
Note
:
This
should
never
happen
but
in
the
case
of
a
bug
aborting
/
/
here
is
better
than
the
badness
that
happens
if
we
unwind
across
/
/
the
FFI
boundary
.
crate
:
:
abort_on_panic
:
:
with_abort_on_panic
(
|
|
{
if
!
s
.
is_null
(
)
{
crate
:
:
destroy_c_string
(
s
)
}
}
)
;
}
}
;
}
#
[
macro_export
]
macro_rules
!
define_box_destructor
{
(
T
:
ty
destructor_name
:
ident
)
=
>
{
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
destructor_name
(
v
:
*
mut
T
)
{
/
/
We
should
consider
passing
an
error
parameter
in
here
rather
than
/
/
aborting
but
at
the
moment
the
only
case
where
we
do
this
/
/
(
interrupt
handles
)
should
never
panic
in
Drop
so
it
'
s
probably
/
/
fine
.
crate
:
:
abort_on_panic
:
:
with_abort_on_panic
(
|
|
{
if
!
v
.
is_null
(
)
{
drop
(
Box
:
:
from_raw
(
v
)
)
}
}
)
;
}
}
;
}
#
[
macro_export
]
macro_rules
!
define_bytebuffer_destructor
{
(
destructor_name
:
ident
)
=
>
{
#
[
no_mangle
]
pub
extern
"
C
"
fn
destructor_name
(
v
:
crate
:
:
ByteBuffer
)
{
/
/
Note
:
This
should
never
happen
but
in
the
case
of
a
bug
aborting
/
/
here
is
better
than
the
badness
that
happens
if
we
unwind
across
/
/
the
FFI
boundary
.
crate
:
:
abort_on_panic
:
:
with_abort_on_panic
(
|
|
v
.
destroy
(
)
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
define_handle_map_deleter
{
(
HANDLE_MAP_NAME
:
ident
destructor_name
:
ident
)
=
>
{
#
[
no_mangle
]
pub
extern
"
C
"
fn
destructor_name
(
v
:
u64
err
:
&
mut
crate
:
:
ExternError
)
{
crate
:
:
call_with_result
(
err
|
|
{
/
/
Force
type
errors
here
.
let
map
:
&
crate
:
:
ConcurrentHandleMap
<
_
>
=
&
*
HANDLE_MAP_NAME
;
map
.
delete_u64
(
v
)
}
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
static_assert
{
(
ASSERT_NAME
:
ident
test
:
expr
)
=
>
{
#
[
allow
(
dead_code
nonstandard_style
)
]
const
ASSERT_NAME
:
[
u8
;
0
-
(
!
test
as
bool
as
usize
)
]
=
[
0u8
;
0
-
(
!
test
as
bool
as
usize
)
]
;
}
;
}
