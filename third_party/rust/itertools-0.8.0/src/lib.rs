#
!
[
warn
(
missing_docs
)
]
#
!
[
crate_name
=
"
itertools
"
]
#
!
[
cfg_attr
(
not
(
feature
=
"
use_std
"
)
no_std
)
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
itertools
/
0
.
8
/
"
)
]
extern
crate
either
;
#
[
cfg
(
not
(
feature
=
"
use_std
"
)
)
]
extern
crate
core
as
std
;
pub
use
either
:
:
Either
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
iter
:
:
{
IntoIterator
}
;
use
std
:
:
cmp
:
:
Ordering
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
use
std
:
:
hash
:
:
Hash
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
use
std
:
:
fmt
:
:
Write
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
type
VecIntoIter
<
T
>
=
:
:
std
:
:
vec
:
:
IntoIter
<
T
>
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
use
std
:
:
iter
:
:
FromIterator
;
#
[
macro_use
]
mod
impl_macros
;
#
[
doc
(
hidden
)
]
pub
use
std
:
:
iter
as
__std_iter
;
pub
mod
structs
{
pub
use
adaptors
:
:
{
Dedup
Interleave
InterleaveShortest
Product
PutBack
Batching
MapInto
MapResults
Merge
MergeBy
TakeWhileRef
WhileSome
Coalesce
TupleCombinations
Positions
Update
}
;
#
[
allow
(
deprecated
)
]
pub
use
adaptors
:
:
Step
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
adaptors
:
:
MultiProduct
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
combinations
:
:
Combinations
;
pub
use
cons_tuples_impl
:
:
ConsTuples
;
pub
use
format
:
:
{
Format
FormatWith
}
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
groupbylazy
:
:
{
IntoChunks
Chunk
Chunks
GroupBy
Group
Groups
}
;
pub
use
intersperse
:
:
Intersperse
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
kmerge_impl
:
:
{
KMerge
KMergeBy
}
;
pub
use
merge_join
:
:
MergeJoinBy
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
multipeek_impl
:
:
MultiPeek
;
pub
use
pad_tail
:
:
PadUsing
;
pub
use
peeking_take_while
:
:
PeekingTakeWhile
;
pub
use
process_results_impl
:
:
ProcessResults
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
put_back_n_impl
:
:
PutBackN
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
rciter_impl
:
:
RcIter
;
pub
use
repeatn
:
:
RepeatN
;
#
[
allow
(
deprecated
)
]
pub
use
sources
:
:
{
RepeatCall
Unfold
Iterate
}
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
tee
:
:
Tee
;
pub
use
tuple_impl
:
:
{
TupleBuffer
TupleWindows
Tuples
}
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
unique_impl
:
:
{
Unique
UniqueBy
}
;
pub
use
with_position
:
:
WithPosition
;
pub
use
zip_eq_impl
:
:
ZipEq
;
pub
use
zip_longest
:
:
ZipLongest
;
pub
use
ziptuple
:
:
Zip
;
}
#
[
allow
(
deprecated
)
]
pub
use
structs
:
:
*
;
pub
use
concat_impl
:
:
concat
;
pub
use
cons_tuples_impl
:
:
cons_tuples
;
pub
use
diff
:
:
diff_with
;
pub
use
diff
:
:
Diff
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
kmerge_impl
:
:
{
kmerge_by
}
;
pub
use
minmax
:
:
MinMaxResult
;
pub
use
peeking_take_while
:
:
PeekingNext
;
pub
use
process_results_impl
:
:
process_results
;
pub
use
repeatn
:
:
repeat_n
;
#
[
allow
(
deprecated
)
]
pub
use
sources
:
:
{
repeat_call
unfold
iterate
}
;
pub
use
with_position
:
:
Position
;
pub
use
ziptuple
:
:
multizip
;
mod
adaptors
;
mod
either_or_both
;
pub
use
either_or_both
:
:
EitherOrBoth
;
#
[
doc
(
hidden
)
]
pub
mod
free
;
#
[
doc
(
inline
)
]
pub
use
free
:
:
*
;
mod
concat_impl
;
mod
cons_tuples_impl
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
combinations
;
mod
diff
;
mod
format
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
group_map
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
groupbylazy
;
mod
intersperse
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
kmerge_impl
;
mod
merge_join
;
mod
minmax
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
multipeek_impl
;
mod
pad_tail
;
mod
peeking_take_while
;
mod
process_results_impl
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
put_back_n_impl
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
rciter_impl
;
mod
repeatn
;
mod
size_hint
;
mod
sources
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
tee
;
mod
tuple_impl
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
mod
unique_impl
;
mod
with_position
;
mod
zip_eq_impl
;
mod
zip_longest
;
mod
ziptuple
;
#
[
macro_export
]
macro_rules
!
iproduct
{
(
flatten
I
:
expr
)
=
>
(
I
)
;
(
flatten
I
:
expr
J
:
expr
(
K
:
expr
)
*
)
=
>
(
iproduct
!
(
flatten
crate
:
:
cons_tuples
(
iproduct
!
(
I
J
)
)
(
K
)
*
)
)
;
(
I
:
expr
)
=
>
(
crate
:
:
__std_iter
:
:
IntoIterator
:
:
into_iter
(
I
)
)
;
(
I
:
expr
J
:
expr
)
=
>
(
crate
:
:
Itertools
:
:
cartesian_product
(
iproduct
!
(
I
)
iproduct
!
(
J
)
)
)
;
(
I
:
expr
J
:
expr
(
K
:
expr
)
+
)
=
>
(
iproduct
!
(
flatten
iproduct
!
(
I
J
)
(
K
)
+
)
)
;
}
#
[
macro_export
]
macro_rules
!
izip
{
(
closure
p
:
pat
=
>
tup
:
expr
)
=
>
{
|
p
|
tup
}
;
(
closure
p
:
pat
=
>
(
(
tup
:
tt
)
*
)
_iter
:
expr
(
tail
:
expr
)
*
)
=
>
{
izip
!
(
closure
(
p
b
)
=
>
(
(
tup
)
*
b
)
(
tail
)
*
)
}
;
(
first
:
expr
(
)
*
)
=
>
{
crate
:
:
__std_iter
:
:
IntoIterator
:
:
into_iter
(
first
)
}
;
(
first
:
expr
second
:
expr
(
)
*
)
=
>
{
izip
!
(
first
)
.
zip
(
second
)
}
;
(
first
:
expr
(
rest
:
expr
)
*
(
)
*
)
=
>
{
izip
!
(
first
)
(
.
zip
(
rest
)
)
*
.
map
(
izip
!
(
closure
a
=
>
(
a
)
(
rest
)
*
)
)
}
;
}
pub
trait
Itertools
:
Iterator
{
fn
interleave
<
J
>
(
self
other
:
J
)
-
>
Interleave
<
Self
J
:
:
IntoIter
>
where
J
:
IntoIterator
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
interleave
(
self
other
)
}
fn
interleave_shortest
<
J
>
(
self
other
:
J
)
-
>
InterleaveShortest
<
Self
J
:
:
IntoIter
>
where
J
:
IntoIterator
<
Item
=
Self
:
:
Item
>
Self
:
Sized
{
adaptors
:
:
interleave_shortest
(
self
other
.
into_iter
(
)
)
}
fn
intersperse
(
self
element
:
Self
:
:
Item
)
-
>
Intersperse
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Clone
{
intersperse
:
:
intersperse
(
self
element
)
}
#
[
inline
]
fn
zip_longest
<
J
>
(
self
other
:
J
)
-
>
ZipLongest
<
Self
J
:
:
IntoIter
>
where
J
:
IntoIterator
Self
:
Sized
{
zip_longest
:
:
zip_longest
(
self
other
.
into_iter
(
)
)
}
#
[
inline
]
fn
zip_eq
<
J
>
(
self
other
:
J
)
-
>
ZipEq
<
Self
J
:
:
IntoIter
>
where
J
:
IntoIterator
Self
:
Sized
{
zip_eq
(
self
other
)
}
fn
batching
<
B
F
>
(
self
f
:
F
)
-
>
Batching
<
Self
F
>
where
F
:
FnMut
(
&
mut
Self
)
-
>
Option
<
B
>
Self
:
Sized
{
adaptors
:
:
batching
(
self
f
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
group_by
<
K
F
>
(
self
key
:
F
)
-
>
GroupBy
<
K
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
K
K
:
PartialEq
{
groupbylazy
:
:
new
(
self
key
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
chunks
(
self
size
:
usize
)
-
>
IntoChunks
<
Self
>
where
Self
:
Sized
{
assert
!
(
size
!
=
0
)
;
groupbylazy
:
:
new_chunks
(
self
size
)
}
fn
tuple_windows
<
T
>
(
self
)
-
>
TupleWindows
<
Self
T
>
where
Self
:
Sized
+
Iterator
<
Item
=
T
:
:
Item
>
T
:
tuple_impl
:
:
TupleCollect
T
:
:
Item
:
Clone
{
tuple_impl
:
:
tuple_windows
(
self
)
}
fn
tuples
<
T
>
(
self
)
-
>
Tuples
<
Self
T
>
where
Self
:
Sized
+
Iterator
<
Item
=
T
:
:
Item
>
T
:
tuple_impl
:
:
TupleCollect
{
tuple_impl
:
:
tuples
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
tee
(
self
)
-
>
(
Tee
<
Self
>
Tee
<
Self
>
)
where
Self
:
Sized
Self
:
:
Item
:
Clone
{
tee
:
:
new
(
self
)
}
#
[
deprecated
(
note
=
"
Use
std
.
step_by
(
)
instead
"
since
=
"
0
.
8
"
)
]
#
[
allow
(
deprecated
)
]
fn
step
(
self
n
:
usize
)
-
>
Step
<
Self
>
where
Self
:
Sized
{
adaptors
:
:
step
(
self
n
)
}
fn
map_into
<
R
>
(
self
)
-
>
MapInto
<
Self
R
>
where
Self
:
Sized
Self
:
:
Item
:
Into
<
R
>
{
adaptors
:
:
map_into
(
self
)
}
fn
map_results
<
F
T
U
E
>
(
self
f
:
F
)
-
>
MapResults
<
Self
F
>
where
Self
:
Iterator
<
Item
=
Result
<
T
E
>
>
+
Sized
F
:
FnMut
(
T
)
-
>
U
{
adaptors
:
:
map_results
(
self
f
)
}
fn
merge
<
J
>
(
self
other
:
J
)
-
>
Merge
<
Self
J
:
:
IntoIter
>
where
Self
:
Sized
Self
:
:
Item
:
PartialOrd
J
:
IntoIterator
<
Item
=
Self
:
:
Item
>
{
merge
(
self
other
)
}
fn
merge_by
<
J
F
>
(
self
other
:
J
is_first
:
F
)
-
>
MergeBy
<
Self
J
:
:
IntoIter
F
>
where
Self
:
Sized
J
:
IntoIterator
<
Item
=
Self
:
:
Item
>
F
:
FnMut
(
&
Self
:
:
Item
&
Self
:
:
Item
)
-
>
bool
{
adaptors
:
:
merge_by_new
(
self
other
.
into_iter
(
)
is_first
)
}
#
[
inline
]
fn
merge_join_by
<
J
F
>
(
self
other
:
J
cmp_fn
:
F
)
-
>
MergeJoinBy
<
Self
J
:
:
IntoIter
F
>
where
J
:
IntoIterator
F
:
FnMut
(
&
Self
:
:
Item
&
J
:
:
Item
)
-
>
std
:
:
cmp
:
:
Ordering
Self
:
Sized
{
merge_join_by
(
self
other
cmp_fn
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
kmerge
(
self
)
-
>
KMerge
<
<
Self
:
:
Item
as
IntoIterator
>
:
:
IntoIter
>
where
Self
:
Sized
Self
:
:
Item
:
IntoIterator
<
Self
:
:
Item
as
IntoIterator
>
:
:
Item
:
PartialOrd
{
kmerge
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
kmerge_by
<
F
>
(
self
first
:
F
)
-
>
KMergeBy
<
<
Self
:
:
Item
as
IntoIterator
>
:
:
IntoIter
F
>
where
Self
:
Sized
Self
:
:
Item
:
IntoIterator
F
:
FnMut
(
&
<
Self
:
:
Item
as
IntoIterator
>
:
:
Item
&
<
Self
:
:
Item
as
IntoIterator
>
:
:
Item
)
-
>
bool
{
kmerge_by
(
self
first
)
}
fn
cartesian_product
<
J
>
(
self
other
:
J
)
-
>
Product
<
Self
J
:
:
IntoIter
>
where
Self
:
Sized
Self
:
:
Item
:
Clone
J
:
IntoIterator
J
:
:
IntoIter
:
Clone
{
adaptors
:
:
cartesian_product
(
self
other
.
into_iter
(
)
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
multi_cartesian_product
(
self
)
-
>
MultiProduct
<
<
Self
:
:
Item
as
IntoIterator
>
:
:
IntoIter
>
where
Self
:
Iterator
+
Sized
Self
:
:
Item
:
IntoIterator
<
Self
:
:
Item
as
IntoIterator
>
:
:
IntoIter
:
Clone
<
Self
:
:
Item
as
IntoIterator
>
:
:
Item
:
Clone
{
adaptors
:
:
multi_cartesian_product
(
self
)
}
fn
coalesce
<
F
>
(
self
f
:
F
)
-
>
Coalesce
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Item
Self
:
:
Item
)
-
>
Result
<
Self
:
:
Item
(
Self
:
:
Item
Self
:
:
Item
)
>
{
adaptors
:
:
coalesce
(
self
f
)
}
fn
dedup
(
self
)
-
>
Dedup
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
PartialEq
{
adaptors
:
:
dedup
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
unique
(
self
)
-
>
Unique
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Clone
+
Eq
+
Hash
{
unique_impl
:
:
unique
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
unique_by
<
V
F
>
(
self
f
:
F
)
-
>
UniqueBy
<
Self
V
F
>
where
Self
:
Sized
V
:
Eq
+
Hash
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
V
{
unique_impl
:
:
unique_by
(
self
f
)
}
fn
peeking_take_while
<
F
>
(
&
mut
self
accept
:
F
)
-
>
PeekingTakeWhile
<
Self
F
>
where
Self
:
Sized
+
PeekingNext
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
bool
{
peeking_take_while
:
:
peeking_take_while
(
self
accept
)
}
fn
take_while_ref
<
F
>
(
&
mut
self
accept
:
F
)
-
>
TakeWhileRef
<
Self
F
>
where
Self
:
Clone
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
bool
{
adaptors
:
:
take_while_ref
(
self
accept
)
}
fn
while_some
<
A
>
(
self
)
-
>
WhileSome
<
Self
>
where
Self
:
Sized
+
Iterator
<
Item
=
Option
<
A
>
>
{
adaptors
:
:
while_some
(
self
)
}
fn
tuple_combinations
<
T
>
(
self
)
-
>
TupleCombinations
<
Self
T
>
where
Self
:
Sized
+
Clone
Self
:
:
Item
:
Clone
T
:
adaptors
:
:
HasCombination
<
Self
>
{
adaptors
:
:
tuple_combinations
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
combinations
(
self
n
:
usize
)
-
>
Combinations
<
Self
>
where
Self
:
Sized
Self
:
:
Item
:
Clone
{
combinations
:
:
combinations
(
self
n
)
}
fn
pad_using
<
F
>
(
self
min
:
usize
f
:
F
)
-
>
PadUsing
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
usize
)
-
>
Self
:
:
Item
{
pad_tail
:
:
pad_using
(
self
min
f
)
}
fn
with_position
(
self
)
-
>
WithPosition
<
Self
>
where
Self
:
Sized
{
with_position
:
:
with_position
(
self
)
}
fn
positions
<
P
>
(
self
predicate
:
P
)
-
>
Positions
<
Self
P
>
where
Self
:
Sized
P
:
FnMut
(
Self
:
:
Item
)
-
>
bool
{
adaptors
:
:
positions
(
self
predicate
)
}
fn
update
<
F
>
(
self
updater
:
F
)
-
>
Update
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
&
mut
Self
:
:
Item
)
{
adaptors
:
:
update
(
self
updater
)
}
fn
next_tuple
<
T
>
(
&
mut
self
)
-
>
Option
<
T
>
where
Self
:
Sized
+
Iterator
<
Item
=
T
:
:
Item
>
T
:
tuple_impl
:
:
TupleCollect
{
T
:
:
collect_from_iter_no_buf
(
self
)
}
fn
collect_tuple
<
T
>
(
mut
self
)
-
>
Option
<
T
>
where
Self
:
Sized
+
Iterator
<
Item
=
T
:
:
Item
>
T
:
tuple_impl
:
:
TupleCollect
{
match
self
.
next_tuple
(
)
{
elt
Some
(
_
)
=
>
match
self
.
next
(
)
{
Some
(
_
)
=
>
None
None
=
>
elt
}
_
=
>
None
}
}
fn
find_position
<
P
>
(
&
mut
self
mut
pred
:
P
)
-
>
Option
<
(
usize
Self
:
:
Item
)
>
where
P
:
FnMut
(
&
Self
:
:
Item
)
-
>
bool
{
let
mut
index
=
0usize
;
for
elt
in
self
{
if
pred
(
&
elt
)
{
return
Some
(
(
index
elt
)
)
;
}
index
+
=
1
;
}
None
}
fn
all_equal
(
&
mut
self
)
-
>
bool
where
Self
:
:
Item
:
PartialEq
{
self
.
dedup
(
)
.
nth
(
1
)
.
is_none
(
)
}
fn
dropping
(
mut
self
n
:
usize
)
-
>
Self
where
Self
:
Sized
{
if
n
>
0
{
self
.
nth
(
n
-
1
)
;
}
self
}
fn
dropping_back
(
mut
self
n
:
usize
)
-
>
Self
where
Self
:
Sized
Self
:
DoubleEndedIterator
{
if
n
>
0
{
(
&
mut
self
)
.
rev
(
)
.
nth
(
n
-
1
)
;
}
self
}
#
[
deprecated
(
note
=
"
Use
.
for_each
(
)
instead
"
since
=
"
0
.
8
"
)
]
fn
foreach
<
F
>
(
self
f
:
F
)
where
F
:
FnMut
(
Self
:
:
Item
)
Self
:
Sized
{
self
.
for_each
(
f
)
}
fn
concat
(
self
)
-
>
Self
:
:
Item
where
Self
:
Sized
Self
:
:
Item
:
Extend
<
<
<
Self
as
Iterator
>
:
:
Item
as
IntoIterator
>
:
:
Item
>
+
IntoIterator
+
Default
{
concat
(
self
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
collect_vec
(
self
)
-
>
Vec
<
Self
:
:
Item
>
where
Self
:
Sized
{
self
.
collect
(
)
}
#
[
inline
]
fn
set_from
<
'
a
A
:
'
a
J
>
(
&
mut
self
from
:
J
)
-
>
usize
where
Self
:
Iterator
<
Item
=
&
'
a
mut
A
>
J
:
IntoIterator
<
Item
=
A
>
{
let
mut
count
=
0
;
for
elt
in
from
{
match
self
.
next
(
)
{
None
=
>
break
Some
(
ptr
)
=
>
*
ptr
=
elt
}
count
+
=
1
;
}
count
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
join
(
&
mut
self
sep
:
&
str
)
-
>
String
where
Self
:
:
Item
:
std
:
:
fmt
:
:
Display
{
match
self
.
next
(
)
{
None
=
>
String
:
:
new
(
)
Some
(
first_elt
)
=
>
{
let
(
lower
_
)
=
self
.
size_hint
(
)
;
let
mut
result
=
String
:
:
with_capacity
(
sep
.
len
(
)
*
lower
)
;
write
!
(
&
mut
result
"
{
}
"
first_elt
)
.
unwrap
(
)
;
for
elt
in
self
{
result
.
push_str
(
sep
)
;
write
!
(
&
mut
result
"
{
}
"
elt
)
.
unwrap
(
)
;
}
result
}
}
}
fn
format
(
self
sep
:
&
str
)
-
>
Format
<
Self
>
where
Self
:
Sized
{
format
:
:
new_format_default
(
self
sep
)
}
fn
format_with
<
F
>
(
self
sep
:
&
str
format
:
F
)
-
>
FormatWith
<
Self
F
>
where
Self
:
Sized
F
:
FnMut
(
Self
:
:
Item
&
mut
FnMut
(
&
fmt
:
:
Display
)
-
>
fmt
:
:
Result
)
-
>
fmt
:
:
Result
{
format
:
:
new_format
(
self
sep
format
)
}
fn
fold_results
<
A
E
B
F
>
(
&
mut
self
mut
start
:
B
mut
f
:
F
)
-
>
Result
<
B
E
>
where
Self
:
Iterator
<
Item
=
Result
<
A
E
>
>
F
:
FnMut
(
B
A
)
-
>
B
{
for
elt
in
self
{
match
elt
{
Ok
(
v
)
=
>
start
=
f
(
start
v
)
Err
(
u
)
=
>
return
Err
(
u
)
}
}
Ok
(
start
)
}
fn
fold_options
<
A
B
F
>
(
&
mut
self
mut
start
:
B
mut
f
:
F
)
-
>
Option
<
B
>
where
Self
:
Iterator
<
Item
=
Option
<
A
>
>
F
:
FnMut
(
B
A
)
-
>
B
{
for
elt
in
self
{
match
elt
{
Some
(
v
)
=
>
start
=
f
(
start
v
)
None
=
>
return
None
}
}
Some
(
start
)
}
fn
fold1
<
F
>
(
mut
self
f
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnMut
(
Self
:
:
Item
Self
:
:
Item
)
-
>
Self
:
:
Item
Self
:
Sized
{
self
.
next
(
)
.
map
(
move
|
x
|
self
.
fold
(
x
f
)
)
}
fn
tree_fold1
<
F
>
(
mut
self
mut
f
:
F
)
-
>
Option
<
Self
:
:
Item
>
where
F
:
FnMut
(
Self
:
:
Item
Self
:
:
Item
)
-
>
Self
:
:
Item
Self
:
Sized
{
type
State
<
T
>
=
Result
<
T
Option
<
T
>
>
;
fn
inner0
<
T
II
FF
>
(
it
:
&
mut
II
f
:
&
mut
FF
)
-
>
State
<
T
>
where
II
:
Iterator
<
Item
=
T
>
FF
:
FnMut
(
T
T
)
-
>
T
{
let
a
=
if
let
Some
(
v
)
=
it
.
next
(
)
{
v
}
else
{
return
Err
(
None
)
}
;
let
b
=
if
let
Some
(
v
)
=
it
.
next
(
)
{
v
}
else
{
return
Err
(
Some
(
a
)
)
}
;
Ok
(
f
(
a
b
)
)
}
fn
inner
<
T
II
FF
>
(
stop
:
usize
it
:
&
mut
II
f
:
&
mut
FF
)
-
>
State
<
T
>
where
II
:
Iterator
<
Item
=
T
>
FF
:
FnMut
(
T
T
)
-
>
T
{
let
mut
x
=
try
!
(
inner0
(
it
f
)
)
;
for
height
in
0
.
.
stop
{
let
next
=
if
height
=
=
0
{
inner0
(
it
f
)
}
else
{
inner
(
height
it
f
)
}
;
match
next
{
Ok
(
y
)
=
>
x
=
f
(
x
y
)
Err
(
None
)
=
>
return
Err
(
Some
(
x
)
)
Err
(
Some
(
y
)
)
=
>
return
Err
(
Some
(
f
(
x
y
)
)
)
}
}
Ok
(
x
)
}
match
inner
(
usize
:
:
max_value
(
)
&
mut
self
&
mut
f
)
{
Err
(
x
)
=
>
x
_
=
>
unreachable
!
(
)
}
}
#
[
deprecated
(
note
=
"
Use
.
try_fold
(
)
instead
"
since
=
"
0
.
8
"
)
]
fn
fold_while
<
B
F
>
(
&
mut
self
init
:
B
mut
f
:
F
)
-
>
FoldWhile
<
B
>
where
Self
:
Sized
F
:
FnMut
(
B
Self
:
:
Item
)
-
>
FoldWhile
<
B
>
{
let
mut
acc
=
init
;
while
let
Some
(
item
)
=
self
.
next
(
)
{
match
f
(
acc
item
)
{
FoldWhile
:
:
Continue
(
res
)
=
>
acc
=
res
res
FoldWhile
:
:
Done
(
_
)
=
>
return
res
}
}
FoldWhile
:
:
Continue
(
acc
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
sorted
(
self
)
-
>
VecIntoIter
<
Self
:
:
Item
>
where
Self
:
Sized
Self
:
:
Item
:
Ord
{
let
mut
v
=
Vec
:
:
from_iter
(
self
)
;
v
.
sort
(
)
;
v
.
into_iter
(
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
sorted_by
<
F
>
(
self
cmp
:
F
)
-
>
VecIntoIter
<
Self
:
:
Item
>
where
Self
:
Sized
F
:
FnMut
(
&
Self
:
:
Item
&
Self
:
:
Item
)
-
>
Ordering
{
let
mut
v
=
Vec
:
:
from_iter
(
self
)
;
v
.
sort_by
(
cmp
)
;
v
.
into_iter
(
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
sorted_by_key
<
K
F
>
(
self
f
:
F
)
-
>
VecIntoIter
<
Self
:
:
Item
>
where
Self
:
Sized
K
:
Ord
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
K
{
let
mut
v
=
Vec
:
:
from_iter
(
self
)
;
v
.
sort_by_key
(
f
)
;
v
.
into_iter
(
)
}
fn
partition_map
<
A
B
F
L
R
>
(
self
predicate
:
F
)
-
>
(
A
B
)
where
Self
:
Sized
F
:
Fn
(
Self
:
:
Item
)
-
>
Either
<
L
R
>
A
:
Default
+
Extend
<
L
>
B
:
Default
+
Extend
<
R
>
{
let
mut
left
=
A
:
:
default
(
)
;
let
mut
right
=
B
:
:
default
(
)
;
for
val
in
self
{
match
predicate
(
val
)
{
Either
:
:
Left
(
v
)
=
>
left
.
extend
(
Some
(
v
)
)
Either
:
:
Right
(
v
)
=
>
right
.
extend
(
Some
(
v
)
)
}
}
(
left
right
)
}
#
[
cfg
(
feature
=
"
use_std
"
)
]
fn
into_group_map
<
K
V
>
(
self
)
-
>
HashMap
<
K
Vec
<
V
>
>
where
Self
:
Iterator
<
Item
=
(
K
V
)
>
+
Sized
K
:
Hash
+
Eq
{
group_map
:
:
into_group_map
(
self
)
}
fn
minmax
(
self
)
-
>
MinMaxResult
<
Self
:
:
Item
>
where
Self
:
Sized
Self
:
:
Item
:
PartialOrd
{
minmax
:
:
minmax_impl
(
self
|
_
|
(
)
|
x
y
_
_
|
x
<
y
)
}
fn
minmax_by_key
<
K
F
>
(
self
key
:
F
)
-
>
MinMaxResult
<
Self
:
:
Item
>
where
Self
:
Sized
K
:
PartialOrd
F
:
FnMut
(
&
Self
:
:
Item
)
-
>
K
{
minmax
:
:
minmax_impl
(
self
key
|
_
_
xk
yk
|
xk
<
yk
)
}
fn
minmax_by
<
F
>
(
self
mut
compare
:
F
)
-
>
MinMaxResult
<
Self
:
:
Item
>
where
Self
:
Sized
F
:
FnMut
(
&
Self
:
:
Item
&
Self
:
:
Item
)
-
>
Ordering
{
minmax
:
:
minmax_impl
(
self
|
_
|
(
)
|
x
y
_
_
|
Ordering
:
:
Less
=
=
compare
(
x
y
)
)
}
}
impl
<
T
:
?
Sized
>
Itertools
for
T
where
T
:
Iterator
{
}
pub
fn
equal
<
I
J
>
(
a
:
I
b
:
J
)
-
>
bool
where
I
:
IntoIterator
J
:
IntoIterator
I
:
:
Item
:
PartialEq
<
J
:
:
Item
>
{
let
mut
ia
=
a
.
into_iter
(
)
;
let
mut
ib
=
b
.
into_iter
(
)
;
loop
{
match
ia
.
next
(
)
{
Some
(
x
)
=
>
match
ib
.
next
(
)
{
Some
(
y
)
=
>
if
x
!
=
y
{
return
false
;
}
None
=
>
return
false
}
None
=
>
return
ib
.
next
(
)
.
is_none
(
)
}
}
}
pub
fn
assert_equal
<
I
J
>
(
a
:
I
b
:
J
)
where
I
:
IntoIterator
J
:
IntoIterator
I
:
:
Item
:
fmt
:
:
Debug
+
PartialEq
<
J
:
:
Item
>
J
:
:
Item
:
fmt
:
:
Debug
{
let
mut
ia
=
a
.
into_iter
(
)
;
let
mut
ib
=
b
.
into_iter
(
)
;
let
mut
i
=
0
;
loop
{
match
(
ia
.
next
(
)
ib
.
next
(
)
)
{
(
None
None
)
=
>
return
(
a
b
)
=
>
{
let
equal
=
match
(
&
a
&
b
)
{
(
&
Some
(
ref
a
)
&
Some
(
ref
b
)
)
=
>
a
=
=
b
_
=
>
false
}
;
assert
!
(
equal
"
Failed
assertion
{
a
:
?
}
=
=
{
b
:
?
}
for
iteration
{
i
}
"
i
=
i
a
=
a
b
=
b
)
;
i
+
=
1
;
}
}
}
}
pub
fn
partition
<
'
a
A
:
'
a
I
F
>
(
iter
:
I
mut
pred
:
F
)
-
>
usize
where
I
:
IntoIterator
<
Item
=
&
'
a
mut
A
>
I
:
:
IntoIter
:
DoubleEndedIterator
F
:
FnMut
(
&
A
)
-
>
bool
{
let
mut
split_index
=
0
;
let
mut
iter
=
iter
.
into_iter
(
)
;
'
main
:
while
let
Some
(
front
)
=
iter
.
next
(
)
{
if
!
pred
(
front
)
{
loop
{
match
iter
.
next_back
(
)
{
Some
(
back
)
=
>
if
pred
(
back
)
{
std
:
:
mem
:
:
swap
(
front
back
)
;
break
;
}
None
=
>
break
'
main
}
}
}
split_index
+
=
1
;
}
split_index
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
pub
enum
FoldWhile
<
T
>
{
Continue
(
T
)
Done
(
T
)
}
impl
<
T
>
FoldWhile
<
T
>
{
pub
fn
into_inner
(
self
)
-
>
T
{
match
self
{
FoldWhile
:
:
Continue
(
x
)
|
FoldWhile
:
:
Done
(
x
)
=
>
x
}
}
pub
fn
is_done
(
&
self
)
-
>
bool
{
match
*
self
{
FoldWhile
:
:
Continue
(
_
)
=
>
false
FoldWhile
:
:
Done
(
_
)
=
>
true
}
}
}
