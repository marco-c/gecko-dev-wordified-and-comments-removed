use
bytes
:
:
{
BufMut
BytesMut
}
;
use
std
:
:
{
cmp
io
str
usize
}
;
use
tokio_io
:
:
_tokio_codec
:
:
{
Decoder
Encoder
}
;
#
[
derive
(
Clone
Debug
Eq
PartialEq
Ord
PartialOrd
Hash
)
]
pub
struct
LinesCodec
{
next_index
:
usize
max_length
:
usize
is_discarding
:
bool
}
impl
LinesCodec
{
pub
fn
new
(
)
-
>
LinesCodec
{
LinesCodec
{
next_index
:
0
max_length
:
usize
:
:
MAX
is_discarding
:
false
}
}
pub
fn
new_with_max_length
(
max_length
:
usize
)
-
>
Self
{
LinesCodec
{
max_length
.
.
LinesCodec
:
:
new
(
)
}
}
pub
fn
max_length
(
&
self
)
-
>
usize
{
self
.
max_length
}
fn
discard
(
&
mut
self
newline_offset
:
Option
<
usize
>
read_to
:
usize
buf
:
&
mut
BytesMut
)
{
let
discard_to
=
if
let
Some
(
offset
)
=
newline_offset
{
self
.
is_discarding
=
false
;
offset
+
self
.
next_index
+
1
}
else
{
read_to
}
;
buf
.
advance
(
discard_to
)
;
self
.
next_index
=
0
;
}
}
fn
utf8
(
buf
:
&
[
u8
]
)
-
>
Result
<
&
str
io
:
:
Error
>
{
str
:
:
from_utf8
(
buf
)
.
map_err
(
|
_
|
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidData
"
Unable
to
decode
input
as
UTF8
"
)
)
}
fn
without_carriage_return
(
s
:
&
[
u8
]
)
-
>
&
[
u8
]
{
if
let
Some
(
&
b
'
\
r
'
)
=
s
.
last
(
)
{
&
s
[
.
.
s
.
len
(
)
-
1
]
}
else
{
s
}
}
impl
Decoder
for
LinesCodec
{
type
Item
=
String
;
type
Error
=
io
:
:
Error
;
fn
decode
(
&
mut
self
buf
:
&
mut
BytesMut
)
-
>
Result
<
Option
<
String
>
io
:
:
Error
>
{
loop
{
let
read_to
=
cmp
:
:
min
(
self
.
max_length
.
saturating_add
(
1
)
buf
.
len
(
)
)
;
let
newline_offset
=
buf
[
self
.
next_index
.
.
read_to
]
.
iter
(
)
.
position
(
|
b
|
*
b
=
=
b
'
\
n
'
)
;
if
self
.
is_discarding
{
self
.
discard
(
newline_offset
read_to
buf
)
;
}
else
{
return
if
let
Some
(
offset
)
=
newline_offset
{
let
newline_index
=
offset
+
self
.
next_index
;
self
.
next_index
=
0
;
let
line
=
buf
.
split_to
(
newline_index
+
1
)
;
let
line
=
&
line
[
.
.
line
.
len
(
)
-
1
]
;
let
line
=
without_carriage_return
(
line
)
;
let
line
=
utf8
(
line
)
?
;
Ok
(
Some
(
line
.
to_string
(
)
)
)
}
else
if
buf
.
len
(
)
>
self
.
max_length
{
self
.
is_discarding
=
true
;
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
line
length
limit
exceeded
"
)
)
}
else
{
self
.
next_index
=
read_to
;
Ok
(
None
)
}
;
}
}
}
fn
decode_eof
(
&
mut
self
buf
:
&
mut
BytesMut
)
-
>
Result
<
Option
<
String
>
io
:
:
Error
>
{
Ok
(
match
self
.
decode
(
buf
)
?
{
Some
(
frame
)
=
>
Some
(
frame
)
None
=
>
{
if
buf
.
is_empty
(
)
|
|
buf
=
=
&
b
"
\
r
"
[
.
.
]
{
None
}
else
{
let
line
=
buf
.
take
(
)
;
let
line
=
without_carriage_return
(
&
line
)
;
let
line
=
utf8
(
line
)
?
;
self
.
next_index
=
0
;
Some
(
line
.
to_string
(
)
)
}
}
}
)
}
}
impl
Encoder
for
LinesCodec
{
type
Item
=
String
;
type
Error
=
io
:
:
Error
;
fn
encode
(
&
mut
self
line
:
String
buf
:
&
mut
BytesMut
)
-
>
Result
<
(
)
io
:
:
Error
>
{
buf
.
reserve
(
line
.
len
(
)
+
1
)
;
buf
.
put
(
line
)
;
buf
.
put_u8
(
b
'
\
n
'
)
;
Ok
(
(
)
)
}
}
