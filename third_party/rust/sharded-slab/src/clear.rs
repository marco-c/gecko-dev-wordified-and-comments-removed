use
std
:
:
{
collections
hash
ops
:
:
DerefMut
sync
}
;
pub
trait
Clear
{
fn
clear
(
&
mut
self
)
;
}
impl
<
T
>
Clear
for
Option
<
T
>
{
fn
clear
(
&
mut
self
)
{
let
_
=
self
.
take
(
)
;
}
}
impl
<
T
>
Clear
for
Box
<
T
>
where
T
:
Clear
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
self
.
deref_mut
(
)
.
clear
(
)
}
}
impl
<
T
>
Clear
for
Vec
<
T
>
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
Vec
:
:
clear
(
self
)
}
}
impl
<
K
V
S
>
Clear
for
collections
:
:
HashMap
<
K
V
S
>
where
K
:
hash
:
:
Hash
+
Eq
S
:
hash
:
:
BuildHasher
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
collections
:
:
HashMap
:
:
clear
(
self
)
}
}
impl
<
T
S
>
Clear
for
collections
:
:
HashSet
<
T
S
>
where
T
:
hash
:
:
Hash
+
Eq
S
:
hash
:
:
BuildHasher
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
collections
:
:
HashSet
:
:
clear
(
self
)
}
}
impl
Clear
for
String
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
String
:
:
clear
(
self
)
}
}
impl
<
T
:
Clear
>
Clear
for
sync
:
:
Mutex
<
T
>
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
self
.
get_mut
(
)
.
unwrap
(
)
.
clear
(
)
;
}
}
impl
<
T
:
Clear
>
Clear
for
sync
:
:
RwLock
<
T
>
{
#
[
inline
]
fn
clear
(
&
mut
self
)
{
self
.
write
(
)
.
unwrap
(
)
.
clear
(
)
;
}
}
#
[
cfg
(
all
(
loom
test
)
)
]
impl
<
T
:
Clear
>
Clear
for
crate
:
:
sync
:
:
alloc
:
:
Track
<
T
>
{
fn
clear
(
&
mut
self
)
{
self
.
get_mut
(
)
.
clear
(
)
}
}
