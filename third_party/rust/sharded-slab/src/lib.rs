#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
sharded
-
slab
/
0
.
1
.
4
"
)
]
#
!
[
warn
(
missing_debug_implementations
missing_docs
)
]
#
!
[
cfg_attr
(
docsrs
warn
(
rustdoc
:
:
broken_intra_doc_links
)
)
]
#
[
macro_use
]
mod
macros
;
pub
mod
implementation
;
pub
mod
pool
;
pub
(
crate
)
mod
cfg
;
pub
(
crate
)
mod
sync
;
mod
clear
;
mod
iter
;
mod
page
;
mod
shard
;
mod
tid
;
pub
use
self
:
:
{
cfg
:
:
{
Config
DefaultConfig
}
clear
:
:
Clear
iter
:
:
UniqueIter
}
;
#
[
doc
(
inline
)
]
pub
use
pool
:
:
Pool
;
pub
(
crate
)
use
tid
:
:
Tid
;
use
cfg
:
:
CfgPrivate
;
use
shard
:
:
Shard
;
use
std
:
:
{
fmt
marker
:
:
PhantomData
ptr
sync
:
:
Arc
}
;
pub
struct
Slab
<
T
C
:
cfg
:
:
Config
=
DefaultConfig
>
{
shards
:
shard
:
:
Array
<
Option
<
T
>
C
>
_cfg
:
PhantomData
<
C
>
}
pub
struct
Entry
<
'
a
T
C
:
cfg
:
:
Config
=
DefaultConfig
>
{
inner
:
page
:
:
slot
:
:
Guard
<
Option
<
T
>
C
>
value
:
ptr
:
:
NonNull
<
T
>
shard
:
&
'
a
Shard
<
Option
<
T
>
C
>
key
:
usize
}
#
[
derive
(
Debug
)
]
pub
struct
VacantEntry
<
'
a
T
C
:
cfg
:
:
Config
=
DefaultConfig
>
{
inner
:
page
:
:
slot
:
:
InitGuard
<
Option
<
T
>
C
>
key
:
usize
_lt
:
PhantomData
<
&
'
a
(
)
>
}
pub
struct
OwnedEntry
<
T
C
=
DefaultConfig
>
where
C
:
cfg
:
:
Config
{
inner
:
page
:
:
slot
:
:
Guard
<
Option
<
T
>
C
>
value
:
ptr
:
:
NonNull
<
T
>
slab
:
Arc
<
Slab
<
T
C
>
>
key
:
usize
}
impl
<
T
>
Slab
<
T
>
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
new_with_config
(
)
}
pub
fn
new_with_config
<
C
:
cfg
:
:
Config
>
(
)
-
>
Slab
<
T
C
>
{
C
:
:
validate
(
)
;
Slab
{
shards
:
shard
:
:
Array
:
:
new
(
)
_cfg
:
PhantomData
}
}
}
impl
<
T
C
:
cfg
:
:
Config
>
Slab
<
T
C
>
{
pub
const
USED_BITS
:
usize
=
C
:
:
USED_BITS
;
pub
fn
insert
(
&
self
value
:
T
)
-
>
Option
<
usize
>
{
let
(
tid
shard
)
=
self
.
shards
.
current
(
)
;
test_println
!
(
"
insert
{
:
?
}
"
tid
)
;
let
mut
value
=
Some
(
value
)
;
shard
.
init_with
(
|
idx
slot
|
{
let
gen
=
slot
.
insert
(
&
mut
value
)
?
;
Some
(
gen
.
pack
(
idx
)
)
}
)
.
map
(
|
idx
|
tid
.
pack
(
idx
)
)
}
pub
fn
vacant_entry
(
&
self
)
-
>
Option
<
VacantEntry
<
'
_
T
C
>
>
{
let
(
tid
shard
)
=
self
.
shards
.
current
(
)
;
test_println
!
(
"
vacant_entry
{
:
?
}
"
tid
)
;
shard
.
init_with
(
|
idx
slot
|
{
let
inner
=
slot
.
init
(
)
?
;
let
key
=
inner
.
generation
(
)
.
pack
(
tid
.
pack
(
idx
)
)
;
Some
(
VacantEntry
{
inner
key
_lt
:
PhantomData
}
)
}
)
}
pub
fn
remove
(
&
self
idx
:
usize
)
-
>
bool
{
let
tid
=
C
:
:
unpack_tid
(
idx
)
;
test_println
!
(
"
rm_deferred
{
:
?
}
"
tid
)
;
let
shard
=
self
.
shards
.
get
(
tid
.
as_usize
(
)
)
;
if
tid
.
is_current
(
)
{
shard
.
map
(
|
shard
|
shard
.
remove_local
(
idx
)
)
.
unwrap_or
(
false
)
}
else
{
shard
.
map
(
|
shard
|
shard
.
remove_remote
(
idx
)
)
.
unwrap_or
(
false
)
}
}
pub
fn
take
(
&
self
idx
:
usize
)
-
>
Option
<
T
>
{
let
tid
=
C
:
:
unpack_tid
(
idx
)
;
test_println
!
(
"
rm
{
:
?
}
"
tid
)
;
let
shard
=
self
.
shards
.
get
(
tid
.
as_usize
(
)
)
?
;
if
tid
.
is_current
(
)
{
shard
.
take_local
(
idx
)
}
else
{
shard
.
take_remote
(
idx
)
}
}
pub
fn
get
(
&
self
key
:
usize
)
-
>
Option
<
Entry
<
'
_
T
C
>
>
{
let
tid
=
C
:
:
unpack_tid
(
key
)
;
test_println
!
(
"
get
{
:
?
}
;
current
=
{
:
?
}
"
tid
Tid
:
:
<
C
>
:
:
current
(
)
)
;
let
shard
=
self
.
shards
.
get
(
tid
.
as_usize
(
)
)
?
;
shard
.
with_slot
(
key
|
slot
|
{
let
inner
=
slot
.
get
(
C
:
:
unpack_gen
(
key
)
)
?
;
let
value
=
ptr
:
:
NonNull
:
:
from
(
slot
.
value
(
)
.
as_ref
(
)
.
unwrap
(
)
)
;
Some
(
Entry
{
inner
value
shard
key
}
)
}
)
}
pub
fn
get_owned
(
self
:
Arc
<
Self
>
key
:
usize
)
-
>
Option
<
OwnedEntry
<
T
C
>
>
{
let
tid
=
C
:
:
unpack_tid
(
key
)
;
test_println
!
(
"
get_owned
{
:
?
}
;
current
=
{
:
?
}
"
tid
Tid
:
:
<
C
>
:
:
current
(
)
)
;
let
shard
=
self
.
shards
.
get
(
tid
.
as_usize
(
)
)
?
;
shard
.
with_slot
(
key
|
slot
|
{
let
inner
=
slot
.
get
(
C
:
:
unpack_gen
(
key
)
)
?
;
let
value
=
ptr
:
:
NonNull
:
:
from
(
slot
.
value
(
)
.
as_ref
(
)
.
unwrap
(
)
)
;
Some
(
OwnedEntry
{
inner
value
slab
:
self
.
clone
(
)
key
}
)
}
)
}
pub
fn
contains
(
&
self
key
:
usize
)
-
>
bool
{
self
.
get
(
key
)
.
is_some
(
)
}
pub
fn
unique_iter
(
&
mut
self
)
-
>
iter
:
:
UniqueIter
<
'
_
T
C
>
{
let
mut
shards
=
self
.
shards
.
iter_mut
(
)
;
let
(
pages
slots
)
=
match
shards
.
next
(
)
{
Some
(
shard
)
=
>
{
let
mut
pages
=
shard
.
iter
(
)
;
let
slots
=
pages
.
next
(
)
.
and_then
(
page
:
:
Shared
:
:
iter
)
;
(
pages
slots
)
}
None
=
>
(
[
]
.
iter
(
)
None
)
}
;
iter
:
:
UniqueIter
{
shards
pages
slots
}
}
}
impl
<
T
>
Default
for
Slab
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
fmt
:
:
Debug
C
:
cfg
:
:
Config
>
fmt
:
:
Debug
for
Slab
<
T
C
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
Slab
"
)
.
field
(
"
shards
"
&
self
.
shards
)
.
field
(
"
config
"
&
C
:
:
debug
(
)
)
.
finish
(
)
}
}
unsafe
impl
<
T
:
Send
C
:
cfg
:
:
Config
>
Send
for
Slab
<
T
C
>
{
}
unsafe
impl
<
T
:
Sync
C
:
cfg
:
:
Config
>
Sync
for
Slab
<
T
C
>
{
}
impl
<
'
a
T
C
:
cfg
:
:
Config
>
Entry
<
'
a
T
C
>
{
pub
fn
key
(
&
self
)
-
>
usize
{
self
.
key
}
#
[
inline
(
always
)
]
fn
value
(
&
self
)
-
>
&
T
{
unsafe
{
self
.
value
.
as_ref
(
)
}
}
}
impl
<
'
a
T
C
:
cfg
:
:
Config
>
std
:
:
ops
:
:
Deref
for
Entry
<
'
a
T
C
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
self
.
value
(
)
}
}
impl
<
'
a
T
C
:
cfg
:
:
Config
>
Drop
for
Entry
<
'
a
T
C
>
{
fn
drop
(
&
mut
self
)
{
let
should_remove
=
unsafe
{
self
.
inner
.
release
(
)
}
;
if
should_remove
{
self
.
shard
.
clear_after_release
(
self
.
key
)
}
}
}
impl
<
'
a
T
C
>
fmt
:
:
Debug
for
Entry
<
'
a
T
C
>
where
T
:
fmt
:
:
Debug
C
:
cfg
:
:
Config
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
.
value
(
)
f
)
}
}
impl
<
'
a
T
C
>
PartialEq
<
T
>
for
Entry
<
'
a
T
C
>
where
T
:
PartialEq
<
T
>
C
:
cfg
:
:
Config
{
fn
eq
(
&
self
other
:
&
T
)
-
>
bool
{
self
.
value
(
)
.
eq
(
other
)
}
}
impl
<
'
a
T
C
:
cfg
:
:
Config
>
VacantEntry
<
'
a
T
C
>
{
pub
fn
insert
(
mut
self
val
:
T
)
{
let
value
=
unsafe
{
self
.
inner
.
value_mut
(
)
}
;
debug_assert
!
(
value
.
is_none
(
)
"
tried
to
insert
to
a
slot
that
already
had
a
value
!
"
)
;
*
value
=
Some
(
val
)
;
let
_released
=
unsafe
{
self
.
inner
.
release
(
)
}
;
debug_assert
!
(
!
_released
"
removing
a
value
before
it
was
inserted
should
be
a
no
-
op
"
)
}
pub
fn
key
(
&
self
)
-
>
usize
{
self
.
key
}
}
impl
<
T
C
>
OwnedEntry
<
T
C
>
where
C
:
cfg
:
:
Config
{
pub
fn
key
(
&
self
)
-
>
usize
{
self
.
key
}
#
[
inline
(
always
)
]
fn
value
(
&
self
)
-
>
&
T
{
unsafe
{
self
.
value
.
as_ref
(
)
}
}
}
impl
<
T
C
>
std
:
:
ops
:
:
Deref
for
OwnedEntry
<
T
C
>
where
C
:
cfg
:
:
Config
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
self
.
value
(
)
}
}
impl
<
T
C
>
Drop
for
OwnedEntry
<
T
C
>
where
C
:
cfg
:
:
Config
{
fn
drop
(
&
mut
self
)
{
test_println
!
(
"
drop
OwnedEntry
:
try
clearing
data
"
)
;
let
should_clear
=
unsafe
{
self
.
inner
.
release
(
)
}
;
if
should_clear
{
let
shard_idx
=
Tid
:
:
<
C
>
:
:
from_packed
(
self
.
key
)
;
test_println
!
(
"
-
>
shard
=
{
:
?
}
"
shard_idx
)
;
if
let
Some
(
shard
)
=
self
.
slab
.
shards
.
get
(
shard_idx
.
as_usize
(
)
)
{
shard
.
clear_after_release
(
self
.
key
)
}
else
{
test_println
!
(
"
-
>
shard
=
{
:
?
}
does
not
exist
!
THIS
IS
A
BUG
"
shard_idx
)
;
debug_assert
!
(
std
:
:
thread
:
:
panicking
(
)
"
[
internal
error
]
tried
to
drop
an
OwnedEntry
to
a
slot
on
a
shard
that
never
existed
!
"
)
;
}
}
}
}
impl
<
T
C
>
fmt
:
:
Debug
for
OwnedEntry
<
T
C
>
where
T
:
fmt
:
:
Debug
C
:
cfg
:
:
Config
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
.
value
(
)
f
)
}
}
impl
<
T
C
>
PartialEq
<
T
>
for
OwnedEntry
<
T
C
>
where
T
:
PartialEq
<
T
>
C
:
cfg
:
:
Config
{
fn
eq
(
&
self
other
:
&
T
)
-
>
bool
{
*
self
.
value
(
)
=
=
*
other
}
}
unsafe
impl
<
T
C
>
Sync
for
OwnedEntry
<
T
C
>
where
T
:
Sync
C
:
cfg
:
:
Config
{
}
unsafe
impl
<
T
C
>
Send
for
OwnedEntry
<
T
C
>
where
T
:
Sync
C
:
cfg
:
:
Config
{
}
pub
(
crate
)
trait
Pack
<
C
:
cfg
:
:
Config
>
:
Sized
{
const
LEN
:
usize
;
type
Prev
:
Pack
<
C
>
;
const
BITS
:
usize
=
{
let
shift
=
1
<
<
(
Self
:
:
LEN
-
1
)
;
shift
|
(
shift
-
1
)
}
;
const
SHIFT
:
usize
=
Self
:
:
Prev
:
:
SHIFT
+
Self
:
:
Prev
:
:
LEN
;
const
MASK
:
usize
=
Self
:
:
BITS
<
<
Self
:
:
SHIFT
;
fn
as_usize
(
&
self
)
-
>
usize
;
fn
from_usize
(
val
:
usize
)
-
>
Self
;
#
[
inline
(
always
)
]
fn
pack
(
&
self
to
:
usize
)
-
>
usize
{
let
value
=
self
.
as_usize
(
)
;
debug_assert
!
(
value
<
=
Self
:
:
BITS
)
;
(
to
&
!
Self
:
:
MASK
)
|
(
value
<
<
Self
:
:
SHIFT
)
}
#
[
inline
(
always
)
]
fn
from_packed
(
from
:
usize
)
-
>
Self
{
let
value
=
(
from
&
Self
:
:
MASK
)
>
>
Self
:
:
SHIFT
;
debug_assert
!
(
value
<
=
Self
:
:
BITS
)
;
Self
:
:
from_usize
(
value
)
}
}
impl
<
C
:
cfg
:
:
Config
>
Pack
<
C
>
for
(
)
{
const
BITS
:
usize
=
0
;
const
LEN
:
usize
=
0
;
const
SHIFT
:
usize
=
0
;
const
MASK
:
usize
=
0
;
type
Prev
=
(
)
;
fn
as_usize
(
&
self
)
-
>
usize
{
unreachable
!
(
)
}
fn
from_usize
(
_val
:
usize
)
-
>
Self
{
unreachable
!
(
)
}
fn
pack
(
&
self
_to
:
usize
)
-
>
usize
{
unreachable
!
(
)
}
fn
from_packed
(
_from
:
usize
)
-
>
Self
{
unreachable
!
(
)
}
}
#
[
cfg
(
test
)
]
pub
(
crate
)
use
self
:
:
tests
:
:
util
as
test_util
;
#
[
cfg
(
test
)
]
mod
tests
;
