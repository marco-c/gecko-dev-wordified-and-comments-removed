#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
serde_bytes
/
0
.
10
.
4
"
)
]
#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
cfg_attr
(
feature
=
"
alloc
"
feature
(
alloc
)
)
]
#
!
[
deny
(
missing_docs
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
{
fmt
ops
}
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
core
:
:
{
fmt
ops
}
;
use
self
:
:
fmt
:
:
Debug
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
Vec
;
#
[
macro_use
]
extern
crate
serde
;
use
serde
:
:
ser
:
:
{
Serialize
Serializer
}
;
use
serde
:
:
de
:
:
{
Deserialize
Deserializer
Visitor
Error
}
;
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
alloc
"
)
)
]
pub
use
self
:
:
bytebuf
:
:
ByteBuf
;
mod
value
;
pub
fn
serialize
<
T
S
>
(
bytes
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
?
Sized
+
AsRef
<
[
u8
]
>
S
:
Serializer
{
serializer
.
serialize_bytes
(
bytes
.
as_ref
(
)
)
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
alloc
"
)
)
]
pub
fn
deserialize
<
'
de
T
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
From
<
Vec
<
u8
>
>
D
:
Deserializer
<
'
de
>
{
ByteBuf
:
:
deserialize
(
deserializer
)
.
map
(
|
buf
|
Into
:
:
<
Vec
<
u8
>
>
:
:
into
(
buf
)
.
into
(
)
)
}
#
[
derive
(
Clone
Copy
Eq
Hash
PartialEq
PartialOrd
Ord
)
]
pub
struct
Bytes
<
'
a
>
{
bytes
:
&
'
a
[
u8
]
}
impl
<
'
a
>
Bytes
<
'
a
>
{
pub
fn
new
(
bytes
:
&
'
a
[
u8
]
)
-
>
Self
{
Bytes
{
bytes
:
bytes
}
}
}
impl
<
'
a
>
Debug
for
Bytes
<
'
a
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
self
.
bytes
f
)
}
}
impl
<
'
a
>
From
<
&
'
a
[
u8
]
>
for
Bytes
<
'
a
>
{
fn
from
(
bytes
:
&
'
a
[
u8
]
)
-
>
Self
{
Bytes
:
:
new
(
bytes
)
}
}
impl
<
'
a
>
From
<
Bytes
<
'
a
>
>
for
&
'
a
[
u8
]
{
fn
from
(
wrapper
:
Bytes
<
'
a
>
)
-
>
&
'
a
[
u8
]
{
wrapper
.
bytes
}
}
impl
<
'
a
>
ops
:
:
Deref
for
Bytes
<
'
a
>
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
self
.
bytes
}
}
impl
<
'
a
>
Serialize
for
Bytes
<
'
a
>
{
#
[
inline
]
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_bytes
(
self
.
bytes
)
}
}
struct
BytesVisitor
;
impl
<
'
de
>
Visitor
<
'
de
>
for
BytesVisitor
{
type
Value
=
Bytes
<
'
de
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
borrowed
byte
array
"
)
}
#
[
inline
]
fn
visit_borrowed_bytes
<
E
>
(
self
v
:
&
'
de
[
u8
]
)
-
>
Result
<
Bytes
<
'
de
>
E
>
where
E
:
Error
{
Ok
(
Bytes
:
:
from
(
v
)
)
}
#
[
inline
]
fn
visit_borrowed_str
<
E
>
(
self
v
:
&
'
de
str
)
-
>
Result
<
Bytes
<
'
de
>
E
>
where
E
:
Error
{
Ok
(
Bytes
:
:
from
(
v
.
as_bytes
(
)
)
)
}
}
impl
<
'
a
'
de
:
'
a
>
Deserialize
<
'
de
>
for
Bytes
<
'
a
>
{
#
[
inline
]
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Bytes
<
'
a
>
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_bytes
(
BytesVisitor
)
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
feature
=
"
alloc
"
)
)
]
mod
bytebuf
{
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
{
cmp
fmt
ops
}
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
core
:
:
{
cmp
fmt
ops
}
;
use
self
:
:
fmt
:
:
Debug
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
{
String
Vec
}
;
use
serde
:
:
ser
:
:
{
Serialize
Serializer
}
;
use
serde
:
:
de
:
:
{
Deserialize
Deserializer
Visitor
SeqAccess
Error
}
;
#
[
derive
(
Clone
Default
Eq
Hash
PartialEq
PartialOrd
Ord
)
]
pub
struct
ByteBuf
{
bytes
:
Vec
<
u8
>
}
impl
ByteBuf
{
pub
fn
new
(
)
-
>
Self
{
ByteBuf
:
:
from
(
Vec
:
:
new
(
)
)
}
pub
fn
with_capacity
(
cap
:
usize
)
-
>
Self
{
ByteBuf
:
:
from
(
Vec
:
:
with_capacity
(
cap
)
)
}
pub
fn
from
<
T
:
Into
<
Vec
<
u8
>
>
>
(
bytes
:
T
)
-
>
Self
{
ByteBuf
{
bytes
:
bytes
.
into
(
)
}
}
}
impl
Debug
for
ByteBuf
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
bytes
f
)
}
}
impl
From
<
ByteBuf
>
for
Vec
<
u8
>
{
fn
from
(
wrapper
:
ByteBuf
)
-
>
Vec
<
u8
>
{
wrapper
.
bytes
}
}
impl
From
<
Vec
<
u8
>
>
for
ByteBuf
{
fn
from
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
ByteBuf
:
:
from
(
bytes
)
}
}
impl
AsRef
<
Vec
<
u8
>
>
for
ByteBuf
{
fn
as_ref
(
&
self
)
-
>
&
Vec
<
u8
>
{
&
self
.
bytes
}
}
impl
AsRef
<
[
u8
]
>
for
ByteBuf
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
bytes
}
}
impl
AsMut
<
Vec
<
u8
>
>
for
ByteBuf
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
Vec
<
u8
>
{
&
mut
self
.
bytes
}
}
impl
AsMut
<
[
u8
]
>
for
ByteBuf
{
fn
as_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
&
mut
self
.
bytes
}
}
impl
ops
:
:
Deref
for
ByteBuf
{
type
Target
=
[
u8
]
;
fn
deref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
bytes
[
.
.
]
}
}
impl
ops
:
:
DerefMut
for
ByteBuf
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
u8
]
{
&
mut
self
.
bytes
[
.
.
]
}
}
impl
Serialize
for
ByteBuf
{
#
[
inline
]
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_bytes
(
&
self
.
bytes
)
}
}
struct
ByteBufVisitor
;
impl
<
'
de
>
Visitor
<
'
de
>
for
ByteBufVisitor
{
type
Value
=
ByteBuf
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
byte
array
"
)
}
#
[
inline
]
fn
visit_seq
<
V
>
(
self
mut
visitor
:
V
)
-
>
Result
<
ByteBuf
V
:
:
Error
>
where
V
:
SeqAccess
<
'
de
>
{
let
len
=
cmp
:
:
min
(
visitor
.
size_hint
(
)
.
unwrap_or
(
0
)
4096
)
;
let
mut
values
=
Vec
:
:
with_capacity
(
len
)
;
while
let
Some
(
value
)
=
try
!
(
visitor
.
next_element
(
)
)
{
values
.
push
(
value
)
;
}
Ok
(
ByteBuf
:
:
from
(
values
)
)
}
#
[
inline
]
fn
visit_bytes
<
E
>
(
self
v
:
&
[
u8
]
)
-
>
Result
<
ByteBuf
E
>
where
E
:
Error
{
Ok
(
ByteBuf
:
:
from
(
v
)
)
}
#
[
inline
]
fn
visit_byte_buf
<
E
>
(
self
v
:
Vec
<
u8
>
)
-
>
Result
<
ByteBuf
E
>
where
E
:
Error
{
Ok
(
ByteBuf
:
:
from
(
v
)
)
}
#
[
inline
]
fn
visit_str
<
E
>
(
self
v
:
&
str
)
-
>
Result
<
ByteBuf
E
>
where
E
:
Error
{
Ok
(
ByteBuf
:
:
from
(
v
)
)
}
#
[
inline
]
fn
visit_string
<
E
>
(
self
v
:
String
)
-
>
Result
<
ByteBuf
E
>
where
E
:
Error
{
Ok
(
ByteBuf
:
:
from
(
v
)
)
}
}
impl
<
'
de
>
Deserialize
<
'
de
>
for
ByteBuf
{
#
[
inline
]
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
ByteBuf
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_byte_buf
(
ByteBufVisitor
)
}
}
}
