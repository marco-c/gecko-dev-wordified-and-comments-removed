#
!
[
allow
(
non_snake_case
)
]
use
std
:
:
ops
:
:
{
Sub
Mul
Add
AddAssign
SubAssign
MulAssign
Div
}
;
macro_rules
!
IFC
{
(
e
:
expr
)
=
>
{
assert_eq
!
(
e
S_OK
)
;
}
}
pub
type
HRESULT
=
i32
;
pub
const
S_OK
:
i32
=
0
;
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
pub
struct
GpPointR
{
pub
x
:
f32
pub
y
:
f32
}
impl
Sub
for
GpPointR
{
type
Output
=
Self
;
fn
sub
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
GpPointR
{
x
:
self
.
x
-
rhs
.
x
y
:
self
.
y
-
rhs
.
y
}
}
}
impl
Add
for
GpPointR
{
type
Output
=
Self
;
fn
add
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
GpPointR
{
x
:
self
.
x
+
rhs
.
x
y
:
self
.
y
+
rhs
.
y
}
}
}
impl
AddAssign
for
GpPointR
{
fn
add_assign
(
&
mut
self
rhs
:
Self
)
{
*
self
=
*
self
+
rhs
;
}
}
impl
SubAssign
for
GpPointR
{
fn
sub_assign
(
&
mut
self
rhs
:
Self
)
{
*
self
=
*
self
-
rhs
;
}
}
impl
MulAssign
<
f32
>
for
GpPointR
{
fn
mul_assign
(
&
mut
self
rhs
:
f32
)
{
*
self
=
*
self
*
rhs
;
}
}
impl
Mul
<
f32
>
for
GpPointR
{
type
Output
=
Self
;
fn
mul
(
self
rhs
:
f32
)
-
>
Self
:
:
Output
{
GpPointR
{
x
:
self
.
x
*
rhs
y
:
self
.
y
*
rhs
}
}
}
impl
Div
<
f32
>
for
GpPointR
{
type
Output
=
Self
;
fn
div
(
self
rhs
:
f32
)
-
>
Self
:
:
Output
{
GpPointR
{
x
:
self
.
x
/
rhs
y
:
self
.
y
/
rhs
}
}
}
impl
Mul
for
GpPointR
{
type
Output
=
f32
;
fn
mul
(
self
rhs
:
Self
)
-
>
Self
:
:
Output
{
self
.
x
*
rhs
.
x
+
self
.
y
*
rhs
.
y
}
}
impl
GpPointR
{
pub
fn
ApproxNorm
(
&
self
)
-
>
f32
{
self
.
x
.
abs
(
)
.
max
(
self
.
y
.
abs
(
)
)
}
pub
fn
Norm
(
&
self
)
-
>
f32
{
self
.
x
.
hypot
(
self
.
y
)
}
}
const
SQ_LENGTH_FUZZ
:
f32
=
1
.
0e
-
4
;
const
TWICE_MIN_BEZIER_STEP_SIZE
:
f32
=
1
.
0e
-
3
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
CBezier
{
m_ptB
:
[
GpPointR
;
4
]
}
impl
CBezier
{
pub
fn
new
(
curve
:
[
GpPointR
;
4
]
)
-
>
Self
{
Self
{
m_ptB
:
curve
}
}
pub
fn
is_degenerate
(
&
self
)
-
>
bool
{
self
.
m_ptB
[
0
]
=
=
self
.
m_ptB
[
1
]
&
&
self
.
m_ptB
[
0
]
=
=
self
.
m_ptB
[
2
]
&
&
self
.
m_ptB
[
0
]
=
=
self
.
m_ptB
[
3
]
}
}
pub
trait
CFlatteningSink
{
fn
AcceptPointAndTangent
(
&
mut
self
pt
:
&
GpPointR
vec
:
&
GpPointR
fLast
:
bool
)
-
>
HRESULT
;
fn
AcceptPoint
(
&
mut
self
pt
:
&
GpPointR
t
:
f32
fAborted
:
&
mut
bool
lastPoint
:
bool
)
-
>
HRESULT
;
}
pub
struct
CBezierFlattener
<
'
a
>
{
bezier
:
CBezier
m_pSink
:
&
'
a
mut
dyn
CFlatteningSink
m_rTolerance
:
f32
m_fWithTangents
:
bool
m_rQuarterTolerance
:
f32
m_rFuzz
:
f32
m_ptE
:
[
GpPointR
;
4
]
m_cSteps
:
i32
m_rParameter
:
f32
m_rStepSize
:
f32
}
impl
<
'
a
>
CBezierFlattener
<
'
a
>
{
}
impl
<
'
a
>
CBezierFlattener
<
'
a
>
{
pub
fn
new
(
bezier
:
&
CBezier
pSink
:
&
'
a
mut
dyn
CFlatteningSink
rTolerance
:
f32
)
-
>
Self
{
let
mut
result
=
CBezierFlattener
{
bezier
:
bezier
.
clone
(
)
m_pSink
:
pSink
m_rTolerance
:
0
.
m_fWithTangents
:
false
m_rQuarterTolerance
:
0
.
m_rFuzz
:
0
.
m_ptE
:
[
GpPointR
{
x
:
0
.
y
:
0
.
}
;
4
]
m_cSteps
:
0
m_rParameter
:
0
.
m_rStepSize
:
0
.
}
;
result
.
m_rTolerance
=
if
rTolerance
>
=
0
.
0
{
rTolerance
}
else
{
0
.
0
}
;
result
.
m_rFuzz
=
rTolerance
*
rTolerance
*
SQ_LENGTH_FUZZ
;
result
.
m_rTolerance
*
=
6
.
;
result
.
m_rQuarterTolerance
=
result
.
m_rTolerance
*
0
.
25
;
result
}
pub
fn
Flatten
(
&
mut
self
fWithTangents
:
bool
)
-
>
HRESULT
{
let
hr
=
S_OK
;
let
mut
fAbort
=
false
;
self
.
m_fWithTangents
=
fWithTangents
;
self
.
m_cSteps
=
1
;
self
.
m_rParameter
=
0
.
;
self
.
m_rStepSize
=
1
.
;
self
.
m_ptE
[
0
]
=
self
.
bezier
.
m_ptB
[
0
]
;
self
.
m_ptE
[
1
]
=
self
.
bezier
.
m_ptB
[
3
]
-
self
.
bezier
.
m_ptB
[
0
]
;
self
.
m_ptE
[
2
]
=
(
self
.
bezier
.
m_ptB
[
1
]
-
self
.
bezier
.
m_ptB
[
2
]
*
2
.
+
self
.
bezier
.
m_ptB
[
3
]
)
*
6
.
;
self
.
m_ptE
[
3
]
=
(
self
.
bezier
.
m_ptB
[
0
]
-
self
.
bezier
.
m_ptB
[
1
]
*
2
.
+
self
.
bezier
.
m_ptB
[
2
]
)
*
6
.
;
self
.
m_cSteps
=
1
;
while
(
(
self
.
m_ptE
[
2
]
.
ApproxNorm
(
)
>
self
.
m_rTolerance
)
|
|
(
self
.
m_ptE
[
3
]
.
ApproxNorm
(
)
>
self
.
m_rTolerance
)
)
&
&
(
self
.
m_rStepSize
>
TWICE_MIN_BEZIER_STEP_SIZE
)
{
self
.
HalveTheStep
(
)
;
}
while
self
.
m_cSteps
>
1
{
IFC
!
(
self
.
Step
(
&
mut
fAbort
)
)
;
if
fAbort
{
return
hr
;
}
if
self
.
m_ptE
[
2
]
.
ApproxNorm
(
)
>
self
.
m_rTolerance
&
&
self
.
m_rStepSize
>
TWICE_MIN_BEZIER_STEP_SIZE
{
self
.
HalveTheStep
(
)
;
}
else
{
while
self
.
TryDoubleTheStep
(
)
{
continue
;
}
}
}
if
self
.
m_fWithTangents
{
IFC
!
(
self
.
m_pSink
.
AcceptPointAndTangent
(
&
self
.
bezier
.
m_ptB
[
3
]
&
self
.
GetLastTangent
(
)
true
/
*
last
point
*
/
)
)
;
}
else
{
IFC
!
(
self
.
m_pSink
.
AcceptPoint
(
&
self
.
bezier
.
m_ptB
[
3
]
1
.
&
mut
fAbort
true
)
)
;
}
return
hr
;
}
fn
Step
(
&
mut
self
fAbort
:
&
mut
bool
)
-
>
HRESULT
{
let
hr
=
S_OK
;
let
mut
pt
;
self
.
m_ptE
[
0
]
+
=
self
.
m_ptE
[
1
]
;
pt
=
self
.
m_ptE
[
2
]
;
self
.
m_ptE
[
1
]
+
=
pt
;
self
.
m_ptE
[
2
]
+
=
pt
;
self
.
m_ptE
[
2
]
-
=
self
.
m_ptE
[
3
]
;
self
.
m_ptE
[
3
]
=
pt
;
self
.
m_rParameter
+
=
self
.
m_rStepSize
;
if
self
.
m_fWithTangents
{
pt
=
self
.
m_ptE
[
1
]
*
6
.
-
self
.
m_ptE
[
2
]
-
self
.
m_ptE
[
3
]
*
2
.
;
IFC
!
(
self
.
m_pSink
.
AcceptPointAndTangent
(
&
self
.
m_ptE
[
0
]
&
pt
false
/
*
not
the
last
point
*
/
)
)
;
}
else
{
IFC
!
(
self
.
m_pSink
.
AcceptPoint
(
&
self
.
m_ptE
[
0
]
self
.
m_rParameter
fAbort
false
)
)
;
}
self
.
m_cSteps
-
=
1
;
return
hr
;
}
fn
HalveTheStep
(
&
mut
self
)
{
self
.
m_ptE
[
2
]
+
=
self
.
m_ptE
[
3
]
;
self
.
m_ptE
[
2
]
*
=
0
.
125
;
self
.
m_ptE
[
1
]
-
=
self
.
m_ptE
[
2
]
;
self
.
m_ptE
[
1
]
*
=
0
.
5
;
self
.
m_ptE
[
3
]
*
=
0
.
25
;
self
.
m_cSteps
*
=
2
;
self
.
m_rStepSize
*
=
0
.
5
;
}
fn
TryDoubleTheStep
(
&
mut
self
)
-
>
bool
{
let
mut
fDoubled
=
0
=
=
(
self
.
m_cSteps
&
1
)
;
if
fDoubled
{
let
ptTemp
=
self
.
m_ptE
[
2
]
*
2
.
-
self
.
m_ptE
[
3
]
;
fDoubled
=
(
self
.
m_ptE
[
3
]
.
ApproxNorm
(
)
<
=
self
.
m_rQuarterTolerance
)
&
&
(
ptTemp
.
ApproxNorm
(
)
<
=
self
.
m_rQuarterTolerance
)
;
if
fDoubled
{
self
.
m_ptE
[
1
]
*
=
2
.
;
self
.
m_ptE
[
1
]
+
=
self
.
m_ptE
[
2
]
;
self
.
m_ptE
[
3
]
*
=
4
.
;
self
.
m_ptE
[
2
]
=
ptTemp
*
4
.
;
self
.
m_cSteps
/
=
2
;
self
.
m_rStepSize
*
=
2
.
;
}
}
return
fDoubled
;
}
pub
fn
GetFirstTangent
(
&
self
)
-
>
Option
<
GpPointR
>
{
let
mut
vecTangent
=
self
.
bezier
.
m_ptB
[
1
]
-
self
.
bezier
.
m_ptB
[
0
]
;
if
vecTangent
*
vecTangent
>
self
.
m_rFuzz
{
return
Some
(
vecTangent
)
;
}
vecTangent
=
self
.
bezier
.
m_ptB
[
2
]
-
self
.
bezier
.
m_ptB
[
0
]
;
if
vecTangent
*
vecTangent
>
self
.
m_rFuzz
{
return
Some
(
vecTangent
)
;
}
vecTangent
=
self
.
bezier
.
m_ptB
[
3
]
-
self
.
bezier
.
m_ptB
[
0
]
;
if
vecTangent
*
vecTangent
<
=
self
.
m_rFuzz
{
return
None
;
}
return
Some
(
vecTangent
)
;
}
fn
GetLastTangent
(
&
self
)
-
>
GpPointR
{
let
mut
vecTangent
=
self
.
bezier
.
m_ptB
[
3
]
-
self
.
bezier
.
m_ptB
[
2
]
;
let
rLastTangentFuzz
=
self
.
m_rFuzz
/
8
.
;
if
vecTangent
*
vecTangent
<
=
rLastTangentFuzz
{
vecTangent
=
self
.
bezier
.
m_ptB
[
3
]
-
self
.
bezier
.
m_ptB
[
1
]
;
if
vecTangent
*
vecTangent
<
=
rLastTangentFuzz
{
vecTangent
=
self
.
bezier
.
m_ptB
[
3
]
-
self
.
bezier
.
m_ptB
[
0
]
;
}
}
debug_assert
!
(
!
(
vecTangent
*
vecTangent
<
rLastTangentFuzz
)
)
;
return
vecTangent
;
}
}
#
[
test
]
#
[
cfg_attr
(
debug_assertions
should_panic
)
]
fn
degenerate_tangent
(
)
{
struct
Sink
;
impl
CFlatteningSink
for
Sink
{
fn
AcceptPointAndTangent
(
&
mut
self
_
:
&
GpPointR
_
:
&
GpPointR
_
:
bool
)
-
>
HRESULT
{
return
S_OK
;
}
fn
AcceptPoint
(
&
mut
self
_
:
&
GpPointR
_
:
f32
_
:
&
mut
bool
_
:
bool
)
-
>
HRESULT
{
return
S_OK
;
}
}
let
bezier
=
CBezier
{
m_ptB
:
[
GpPointR
{
x
:
0
.
y
:
0
.
0005
}
GpPointR
{
x
:
0
.
y
:
0
.
0005
}
GpPointR
{
x
:
0
.
y
:
0
.
}
GpPointR
{
x
:
0
.
y
:
0
.
}
]
}
;
let
mut
t
=
Sink
;
let
mut
f
=
CBezierFlattener
:
:
new
(
&
bezier
&
mut
t
0
.
25
)
;
f
.
Flatten
(
true
)
;
}
