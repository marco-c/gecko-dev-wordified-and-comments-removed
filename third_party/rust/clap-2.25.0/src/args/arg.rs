#
[
cfg
(
feature
=
"
yaml
"
)
]
use
std
:
:
collections
:
:
BTreeMap
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
ffi
:
:
{
OsString
OsStr
}
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
use
osstringext
:
:
OsStrExt3
;
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
use
std
:
:
os
:
:
unix
:
:
ffi
:
:
OsStrExt
;
#
[
cfg
(
feature
=
"
yaml
"
)
]
use
yaml_rust
:
:
Yaml
;
use
vec_map
:
:
VecMap
;
use
usage_parser
:
:
UsageParser
;
use
args
:
:
settings
:
:
ArgSettings
;
use
args
:
:
arg_builder
:
:
{
Base
Valued
Switched
}
;
#
[
allow
(
missing_debug_implementations
)
]
#
[
derive
(
Default
Clone
)
]
pub
struct
Arg
<
'
a
'
b
>
where
'
a
:
'
b
{
#
[
doc
(
hidden
)
]
pub
b
:
Base
<
'
a
'
b
>
#
[
doc
(
hidden
)
]
pub
s
:
Switched
<
'
b
>
#
[
doc
(
hidden
)
]
pub
v
:
Valued
<
'
a
'
b
>
#
[
doc
(
hidden
)
]
pub
index
:
Option
<
u64
>
#
[
doc
(
hidden
)
]
pub
r_ifs
:
Option
<
Vec
<
(
&
'
a
str
&
'
b
str
)
>
>
}
impl
<
'
a
'
b
>
Arg
<
'
a
'
b
>
{
pub
fn
with_name
(
n
:
&
'
a
str
)
-
>
Self
{
Arg
{
b
:
Base
:
:
new
(
n
)
.
.
Default
:
:
default
(
)
}
}
#
[
cfg
(
feature
=
"
yaml
"
)
]
pub
fn
from_yaml
(
y
:
&
BTreeMap
<
Yaml
Yaml
>
)
-
>
Arg
{
let
name_yml
=
y
.
keys
(
)
.
nth
(
0
)
.
unwrap
(
)
;
let
name_str
=
name_yml
.
as_str
(
)
.
unwrap
(
)
;
let
mut
a
=
Arg
:
:
with_name
(
name_str
)
;
let
arg_settings
=
y
.
get
(
name_yml
)
.
unwrap
(
)
.
as_hash
(
)
.
unwrap
(
)
;
for
(
k
v
)
in
arg_settings
.
iter
(
)
{
a
=
match
k
.
as_str
(
)
.
unwrap
(
)
{
"
short
"
=
>
yaml_to_str
!
(
a
v
short
)
"
long
"
=
>
yaml_to_str
!
(
a
v
long
)
"
aliases
"
=
>
yaml_vec_or_str
!
(
v
a
alias
)
"
help
"
=
>
yaml_to_str
!
(
a
v
help
)
"
long_help
"
=
>
yaml_to_str
!
(
a
v
long_help
)
"
required
"
=
>
yaml_to_bool
!
(
a
v
required
)
"
required_if
"
=
>
yaml_tuple2
!
(
a
v
required_if
)
"
required_ifs
"
=
>
yaml_tuple2
!
(
a
v
required_if
)
"
takes_value
"
=
>
yaml_to_bool
!
(
a
v
takes_value
)
"
index
"
=
>
yaml_to_u64
!
(
a
v
index
)
"
global
"
=
>
yaml_to_bool
!
(
a
v
global
)
"
multiple
"
=
>
yaml_to_bool
!
(
a
v
multiple
)
"
hidden
"
=
>
yaml_to_bool
!
(
a
v
hidden
)
"
next_line_help
"
=
>
yaml_to_bool
!
(
a
v
next_line_help
)
"
empty_values
"
=
>
yaml_to_bool
!
(
a
v
empty_values
)
"
group
"
=
>
yaml_to_str
!
(
a
v
group
)
"
number_of_values
"
=
>
yaml_to_u64
!
(
a
v
number_of_values
)
"
max_values
"
=
>
yaml_to_u64
!
(
a
v
max_values
)
"
min_values
"
=
>
yaml_to_u64
!
(
a
v
min_values
)
"
value_name
"
=
>
yaml_to_str
!
(
a
v
value_name
)
"
use_delimiter
"
=
>
yaml_to_bool
!
(
a
v
use_delimiter
)
"
allow_hyphen_values
"
=
>
yaml_to_bool
!
(
a
v
allow_hyphen_values
)
"
require_delimiter
"
=
>
yaml_to_bool
!
(
a
v
require_delimiter
)
"
value_delimiter
"
=
>
yaml_to_str
!
(
a
v
value_delimiter
)
"
required_unless
"
=
>
yaml_to_str
!
(
a
v
required_unless
)
"
display_order
"
=
>
yaml_to_usize
!
(
a
v
display_order
)
"
default_value
"
=
>
yaml_to_str
!
(
a
v
default_value
)
"
default_value_if
"
=
>
yaml_tuple3
!
(
a
v
default_value_if
)
"
default_value_ifs
"
=
>
yaml_tuple3
!
(
a
v
default_value_if
)
"
value_names
"
=
>
yaml_vec_or_str
!
(
v
a
value_name
)
"
groups
"
=
>
yaml_vec_or_str
!
(
v
a
group
)
"
requires
"
=
>
yaml_vec_or_str
!
(
v
a
requires
)
"
requires_if
"
=
>
yaml_tuple2
!
(
a
v
requires_if
)
"
requires_ifs
"
=
>
yaml_tuple2
!
(
a
v
requires_if
)
"
conflicts_with
"
=
>
yaml_vec_or_str
!
(
v
a
conflicts_with
)
"
overrides_with
"
=
>
yaml_vec_or_str
!
(
v
a
overrides_with
)
"
possible_values
"
=
>
yaml_vec_or_str
!
(
v
a
possible_value
)
"
required_unless_one
"
=
>
yaml_vec_or_str
!
(
v
a
required_unless
)
"
required_unless_all
"
=
>
{
a
=
yaml_vec_or_str
!
(
v
a
required_unless
)
;
a
.
setb
(
ArgSettings
:
:
RequiredUnlessAll
)
;
a
}
s
=
>
{
panic
!
(
"
Unknown
Arg
setting
'
{
}
'
in
YAML
file
for
arg
'
{
}
'
"
s
name_str
)
}
}
}
a
}
pub
fn
from_usage
(
u
:
&
'
a
str
)
-
>
Self
{
let
parser
=
UsageParser
:
:
from_usage
(
u
)
;
parser
.
parse
(
)
}
pub
fn
short
<
S
:
AsRef
<
str
>
>
(
mut
self
s
:
S
)
-
>
Self
{
self
.
s
.
short
=
s
.
as_ref
(
)
.
trim_left_matches
(
|
c
|
c
=
=
'
-
'
)
.
chars
(
)
.
nth
(
0
)
;
self
}
pub
fn
long
(
mut
self
l
:
&
'
b
str
)
-
>
Self
{
self
.
s
.
long
=
Some
(
l
.
trim_left_matches
(
|
c
|
c
=
=
'
-
'
)
)
;
self
}
pub
fn
alias
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
s
.
aliases
{
als
.
push
(
(
name
.
into
(
)
false
)
)
;
}
else
{
self
.
s
.
aliases
=
Some
(
vec
!
[
(
name
.
into
(
)
false
)
]
)
;
}
self
}
pub
fn
aliases
(
mut
self
names
:
&
[
&
'
b
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
s
.
aliases
{
for
n
in
names
{
als
.
push
(
(
n
false
)
)
;
}
}
else
{
self
.
s
.
aliases
=
Some
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
false
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
visible_alias
<
S
:
Into
<
&
'
b
str
>
>
(
mut
self
name
:
S
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
s
.
aliases
{
als
.
push
(
(
name
.
into
(
)
true
)
)
;
}
else
{
self
.
s
.
aliases
=
Some
(
vec
!
[
(
name
.
into
(
)
true
)
]
)
;
}
self
}
pub
fn
visible_aliases
(
mut
self
names
:
&
[
&
'
b
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
als
)
=
self
.
s
.
aliases
{
for
n
in
names
{
als
.
push
(
(
n
true
)
)
;
}
}
else
{
self
.
s
.
aliases
=
Some
(
names
.
iter
(
)
.
map
(
|
n
|
(
*
n
true
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
help
(
mut
self
h
:
&
'
b
str
)
-
>
Self
{
self
.
b
.
help
=
Some
(
h
)
;
self
}
pub
fn
long_help
(
mut
self
h
:
&
'
b
str
)
-
>
Self
{
self
.
b
.
long_help
=
Some
(
h
)
;
self
}
pub
fn
last
(
self
l
:
bool
)
-
>
Self
{
if
l
{
self
.
set
(
ArgSettings
:
:
Last
)
}
else
{
self
.
unset
(
ArgSettings
:
:
Last
)
}
}
pub
fn
required
(
self
r
:
bool
)
-
>
Self
{
if
r
{
self
.
set
(
ArgSettings
:
:
Required
)
}
else
{
self
.
unset
(
ArgSettings
:
:
Required
)
}
}
pub
fn
require_equals
(
mut
self
r
:
bool
)
-
>
Self
{
if
r
{
self
.
unsetb
(
ArgSettings
:
:
EmptyValues
)
;
self
.
set
(
ArgSettings
:
:
RequireEquals
)
}
else
{
self
.
unset
(
ArgSettings
:
:
RequireEquals
)
}
}
pub
fn
allow_hyphen_values
(
self
a
:
bool
)
-
>
Self
{
if
a
{
self
.
set
(
ArgSettings
:
:
AllowLeadingHyphen
)
}
else
{
self
.
unset
(
ArgSettings
:
:
AllowLeadingHyphen
)
}
}
pub
fn
required_unless
(
mut
self
name
:
&
'
a
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
r_unless
{
vec
.
push
(
name
)
;
}
else
{
self
.
b
.
r_unless
=
Some
(
vec
!
[
name
]
)
;
}
self
.
required
(
true
)
}
pub
fn
required_unless_all
(
mut
self
names
:
&
[
&
'
a
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
r_unless
{
for
s
in
names
{
vec
.
push
(
s
)
;
}
}
else
{
self
.
b
.
r_unless
=
Some
(
names
.
iter
(
)
.
map
(
|
s
|
*
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
.
setb
(
ArgSettings
:
:
RequiredUnlessAll
)
;
self
.
required
(
true
)
}
pub
fn
required_unless_one
(
mut
self
names
:
&
[
&
'
a
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
r_unless
{
for
s
in
names
{
vec
.
push
(
s
)
;
}
}
else
{
self
.
b
.
r_unless
=
Some
(
names
.
iter
(
)
.
map
(
|
s
|
*
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
.
required
(
true
)
}
pub
fn
conflicts_with
(
mut
self
name
:
&
'
a
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
blacklist
{
vec
.
push
(
name
)
;
}
else
{
self
.
b
.
blacklist
=
Some
(
vec
!
[
name
]
)
;
}
self
}
pub
fn
conflicts_with_all
(
mut
self
names
:
&
[
&
'
a
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
blacklist
{
for
s
in
names
{
vec
.
push
(
s
)
;
}
}
else
{
self
.
b
.
blacklist
=
Some
(
names
.
iter
(
)
.
map
(
|
s
|
*
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
overrides_with
(
mut
self
name
:
&
'
a
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
overrides
{
vec
.
push
(
name
.
as_ref
(
)
)
;
}
else
{
self
.
b
.
overrides
=
Some
(
vec
!
[
name
.
as_ref
(
)
]
)
;
}
self
}
pub
fn
overrides_with_all
(
mut
self
names
:
&
[
&
'
a
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
overrides
{
for
s
in
names
{
vec
.
push
(
s
)
;
}
}
else
{
self
.
b
.
overrides
=
Some
(
names
.
iter
(
)
.
map
(
|
s
|
*
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
requires
(
mut
self
name
:
&
'
a
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
requires
{
vec
.
push
(
(
None
name
)
)
;
}
else
{
let
mut
vec
=
vec
!
[
]
;
vec
.
push
(
(
None
name
)
)
;
self
.
b
.
requires
=
Some
(
vec
)
;
}
self
}
pub
fn
requires_if
(
mut
self
val
:
&
'
b
str
arg
:
&
'
a
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
requires
{
vec
.
push
(
(
Some
(
val
)
arg
)
)
;
}
else
{
self
.
b
.
requires
=
Some
(
vec
!
[
(
Some
(
val
)
arg
)
]
)
;
}
self
}
pub
fn
requires_ifs
(
mut
self
ifs
:
&
[
(
&
'
b
str
&
'
a
str
)
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
requires
{
for
&
(
val
arg
)
in
ifs
{
vec
.
push
(
(
Some
(
val
)
arg
)
)
;
}
}
else
{
let
mut
vec
=
vec
!
[
]
;
for
&
(
val
arg
)
in
ifs
{
vec
.
push
(
(
Some
(
val
)
arg
)
)
;
}
self
.
b
.
requires
=
Some
(
vec
)
;
}
self
}
pub
fn
required_if
(
mut
self
arg
:
&
'
a
str
val
:
&
'
b
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
r_ifs
{
vec
.
push
(
(
arg
val
)
)
;
}
else
{
self
.
r_ifs
=
Some
(
vec
!
[
(
arg
val
)
]
)
;
}
self
}
pub
fn
required_ifs
(
mut
self
ifs
:
&
[
(
&
'
a
str
&
'
b
str
)
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
r_ifs
{
for
r_if
in
ifs
{
vec
.
push
(
(
r_if
.
0
r_if
.
1
)
)
;
}
}
else
{
let
mut
vec
=
vec
!
[
]
;
for
r_if
in
ifs
{
vec
.
push
(
(
r_if
.
0
r_if
.
1
)
)
;
}
self
.
r_ifs
=
Some
(
vec
)
;
}
self
}
pub
fn
requires_all
(
mut
self
names
:
&
[
&
'
a
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
requires
{
for
s
in
names
{
vec
.
push
(
(
None
s
)
)
;
}
}
else
{
let
mut
vec
=
vec
!
[
]
;
for
s
in
names
{
vec
.
push
(
(
None
*
s
)
)
;
}
self
.
b
.
requires
=
Some
(
vec
)
;
}
self
}
pub
fn
takes_value
(
self
tv
:
bool
)
-
>
Self
{
if
tv
{
self
.
set
(
ArgSettings
:
:
TakesValue
)
}
else
{
self
.
unset
(
ArgSettings
:
:
TakesValue
)
}
}
pub
fn
hide_possible_values
(
self
hide
:
bool
)
-
>
Self
{
if
hide
{
self
.
set
(
ArgSettings
:
:
HidePossibleValues
)
}
else
{
self
.
unset
(
ArgSettings
:
:
HidePossibleValues
)
}
}
pub
fn
hide_default_value
(
self
hide
:
bool
)
-
>
Self
{
if
hide
{
self
.
set
(
ArgSettings
:
:
HideDefaultValue
)
}
else
{
self
.
unset
(
ArgSettings
:
:
HideDefaultValue
)
}
}
pub
fn
index
(
mut
self
idx
:
u64
)
-
>
Self
{
self
.
index
=
Some
(
idx
)
;
self
}
pub
fn
multiple
(
self
multi
:
bool
)
-
>
Self
{
if
multi
{
self
.
set
(
ArgSettings
:
:
Multiple
)
}
else
{
self
.
unset
(
ArgSettings
:
:
Multiple
)
}
}
pub
fn
value_terminator
(
mut
self
term
:
&
'
b
str
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
self
.
v
.
terminator
=
Some
(
term
)
;
self
}
pub
fn
global
(
self
g
:
bool
)
-
>
Self
{
if
g
{
self
.
set
(
ArgSettings
:
:
Global
)
}
else
{
self
.
unset
(
ArgSettings
:
:
Global
)
}
}
pub
fn
empty_values
(
mut
self
ev
:
bool
)
-
>
Self
{
if
ev
{
self
.
set
(
ArgSettings
:
:
EmptyValues
)
}
else
{
self
=
self
.
set
(
ArgSettings
:
:
TakesValue
)
;
self
.
unset
(
ArgSettings
:
:
EmptyValues
)
}
}
pub
fn
hidden
(
self
h
:
bool
)
-
>
Self
{
if
h
{
self
.
set
(
ArgSettings
:
:
Hidden
)
}
else
{
self
.
unset
(
ArgSettings
:
:
Hidden
)
}
}
pub
fn
possible_values
(
mut
self
names
:
&
[
&
'
b
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
v
.
possible_vals
{
for
s
in
names
{
vec
.
push
(
s
)
;
}
}
else
{
self
.
v
.
possible_vals
=
Some
(
names
.
iter
(
)
.
map
(
|
s
|
*
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
possible_value
(
mut
self
name
:
&
'
b
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
v
.
possible_vals
{
vec
.
push
(
name
)
;
}
else
{
self
.
v
.
possible_vals
=
Some
(
vec
!
[
name
]
)
;
}
self
}
pub
fn
group
(
mut
self
name
:
&
'
a
str
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
groups
{
vec
.
push
(
name
)
;
}
else
{
self
.
b
.
groups
=
Some
(
vec
!
[
name
]
)
;
}
self
}
pub
fn
groups
(
mut
self
names
:
&
[
&
'
a
str
]
)
-
>
Self
{
if
let
Some
(
ref
mut
vec
)
=
self
.
b
.
groups
{
for
s
in
names
{
vec
.
push
(
s
)
;
}
}
else
{
self
.
b
.
groups
=
Some
(
names
.
into_iter
(
)
.
map
(
|
s
|
*
s
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
)
;
}
self
}
pub
fn
number_of_values
(
mut
self
qty
:
u64
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
self
.
v
.
num_vals
=
Some
(
qty
)
;
self
}
pub
fn
validator
<
F
>
(
mut
self
f
:
F
)
-
>
Self
where
F
:
Fn
(
String
)
-
>
Result
<
(
)
String
>
+
'
static
{
self
.
v
.
validator
=
Some
(
Rc
:
:
new
(
f
)
)
;
self
}
#
[
cfg_attr
(
not
(
unix
)
doc
=
"
ignore
"
)
]
#
[
cfg_attr
(
unix
doc
=
"
rust
"
)
]
pub
fn
validator_os
<
F
>
(
mut
self
f
:
F
)
-
>
Self
where
F
:
Fn
(
&
OsStr
)
-
>
Result
<
(
)
OsString
>
+
'
static
{
self
.
v
.
validator_os
=
Some
(
Rc
:
:
new
(
f
)
)
;
self
}
pub
fn
max_values
(
mut
self
qty
:
u64
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
self
.
v
.
max_vals
=
Some
(
qty
)
;
self
}
pub
fn
min_values
(
mut
self
qty
:
u64
)
-
>
Self
{
self
.
v
.
min_vals
=
Some
(
qty
)
;
self
.
set
(
ArgSettings
:
:
TakesValue
)
}
pub
fn
use_delimiter
(
mut
self
d
:
bool
)
-
>
Self
{
if
d
{
if
self
.
v
.
val_delim
.
is_none
(
)
{
self
.
v
.
val_delim
=
Some
(
'
'
)
;
}
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
self
.
setb
(
ArgSettings
:
:
UseValueDelimiter
)
;
self
.
unset
(
ArgSettings
:
:
ValueDelimiterNotSet
)
}
else
{
self
.
v
.
val_delim
=
None
;
self
.
unsetb
(
ArgSettings
:
:
UseValueDelimiter
)
;
self
.
unset
(
ArgSettings
:
:
ValueDelimiterNotSet
)
}
}
pub
fn
require_delimiter
(
mut
self
d
:
bool
)
-
>
Self
{
if
d
{
self
=
self
.
use_delimiter
(
true
)
;
self
.
unsetb
(
ArgSettings
:
:
ValueDelimiterNotSet
)
;
self
.
setb
(
ArgSettings
:
:
UseValueDelimiter
)
;
self
.
set
(
ArgSettings
:
:
RequireDelimiter
)
}
else
{
self
=
self
.
use_delimiter
(
false
)
;
self
.
unsetb
(
ArgSettings
:
:
UseValueDelimiter
)
;
self
.
unset
(
ArgSettings
:
:
RequireDelimiter
)
}
}
pub
fn
value_delimiter
(
mut
self
d
:
&
str
)
-
>
Self
{
self
.
unsetb
(
ArgSettings
:
:
ValueDelimiterNotSet
)
;
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
self
.
setb
(
ArgSettings
:
:
UseValueDelimiter
)
;
self
.
v
.
val_delim
=
Some
(
d
.
chars
(
)
.
nth
(
0
)
.
expect
(
"
Failed
to
get
value_delimiter
from
arg
"
)
)
;
self
}
pub
fn
value_names
(
mut
self
names
:
&
[
&
'
b
str
]
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
if
self
.
is_set
(
ArgSettings
:
:
ValueDelimiterNotSet
)
{
self
.
unsetb
(
ArgSettings
:
:
ValueDelimiterNotSet
)
;
self
.
setb
(
ArgSettings
:
:
UseValueDelimiter
)
;
}
if
let
Some
(
ref
mut
vals
)
=
self
.
v
.
val_names
{
let
mut
l
=
vals
.
len
(
)
;
for
s
in
names
{
vals
.
insert
(
l
s
)
;
l
+
=
1
;
}
}
else
{
let
mut
vm
=
VecMap
:
:
new
(
)
;
for
(
i
n
)
in
names
.
iter
(
)
.
enumerate
(
)
{
vm
.
insert
(
i
*
n
)
;
}
self
.
v
.
val_names
=
Some
(
vm
)
;
}
self
}
pub
fn
value_name
(
mut
self
name
:
&
'
b
str
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
if
let
Some
(
ref
mut
vals
)
=
self
.
v
.
val_names
{
let
l
=
vals
.
len
(
)
;
vals
.
insert
(
l
name
)
;
}
else
{
let
mut
vm
=
VecMap
:
:
new
(
)
;
vm
.
insert
(
0
name
)
;
self
.
v
.
val_names
=
Some
(
vm
)
;
}
self
}
pub
fn
default_value
(
self
val
:
&
'
a
str
)
-
>
Self
{
self
.
default_value_os
(
OsStr
:
:
from_bytes
(
val
.
as_bytes
(
)
)
)
}
pub
fn
default_value_os
(
mut
self
val
:
&
'
a
OsStr
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
self
.
v
.
default_val
=
Some
(
val
)
;
self
}
pub
fn
default_value_if
(
self
arg
:
&
'
a
str
val
:
Option
<
&
'
b
str
>
default
:
&
'
b
str
)
-
>
Self
{
self
.
default_value_if_os
(
arg
val
.
map
(
str
:
:
as_bytes
)
.
map
(
OsStr
:
:
from_bytes
)
OsStr
:
:
from_bytes
(
default
.
as_bytes
(
)
)
)
}
pub
fn
default_value_if_os
(
mut
self
arg
:
&
'
a
str
val
:
Option
<
&
'
b
OsStr
>
default
:
&
'
b
OsStr
)
-
>
Self
{
self
.
setb
(
ArgSettings
:
:
TakesValue
)
;
if
let
Some
(
ref
mut
vm
)
=
self
.
v
.
default_vals_ifs
{
let
l
=
vm
.
len
(
)
;
vm
.
insert
(
l
(
arg
val
default
)
)
;
}
else
{
let
mut
vm
=
VecMap
:
:
new
(
)
;
vm
.
insert
(
0
(
arg
val
default
)
)
;
self
.
v
.
default_vals_ifs
=
Some
(
vm
)
;
}
self
}
pub
fn
default_value_ifs
(
mut
self
ifs
:
&
[
(
&
'
a
str
Option
<
&
'
b
str
>
&
'
b
str
)
]
)
-
>
Self
{
for
&
(
arg
val
default
)
in
ifs
{
self
=
self
.
default_value_if_os
(
arg
val
.
map
(
str
:
:
as_bytes
)
.
map
(
OsStr
:
:
from_bytes
)
OsStr
:
:
from_bytes
(
default
.
as_bytes
(
)
)
)
;
}
self
}
#
[
cfg_attr
(
feature
=
"
lints
"
allow
(
explicit_counter_loop
)
)
]
pub
fn
default_value_ifs_os
(
mut
self
ifs
:
&
[
(
&
'
a
str
Option
<
&
'
b
OsStr
>
&
'
b
OsStr
)
]
)
-
>
Self
{
for
&
(
arg
val
default
)
in
ifs
{
self
=
self
.
default_value_if_os
(
arg
val
default
)
;
}
self
}
pub
fn
next_line_help
(
mut
self
nlh
:
bool
)
-
>
Self
{
if
nlh
{
self
.
setb
(
ArgSettings
:
:
NextLineHelp
)
;
}
else
{
self
.
unsetb
(
ArgSettings
:
:
NextLineHelp
)
;
}
self
}
pub
fn
display_order
(
mut
self
ord
:
usize
)
-
>
Self
{
self
.
s
.
disp_ord
=
ord
;
self
}
pub
fn
is_set
(
&
self
s
:
ArgSettings
)
-
>
bool
{
self
.
b
.
is_set
(
s
)
}
pub
fn
set
(
mut
self
s
:
ArgSettings
)
-
>
Self
{
self
.
setb
(
s
)
;
self
}
pub
fn
unset
(
mut
self
s
:
ArgSettings
)
-
>
Self
{
self
.
unsetb
(
s
)
;
self
}
#
[
doc
(
hidden
)
]
pub
fn
setb
(
&
mut
self
s
:
ArgSettings
)
{
self
.
b
.
set
(
s
)
;
}
#
[
doc
(
hidden
)
]
pub
fn
unsetb
(
&
mut
self
s
:
ArgSettings
)
{
self
.
b
.
unset
(
s
)
;
}
}
impl
<
'
a
'
b
'
z
>
From
<
&
'
z
Arg
<
'
a
'
b
>
>
for
Arg
<
'
a
'
b
>
{
fn
from
(
a
:
&
'
z
Arg
<
'
a
'
b
>
)
-
>
Self
{
Arg
{
b
:
a
.
b
.
clone
(
)
v
:
a
.
v
.
clone
(
)
s
:
a
.
s
.
clone
(
)
index
:
a
.
index
r_ifs
:
a
.
r_ifs
.
clone
(
)
}
}
}
impl
<
'
n
'
e
>
PartialEq
for
Arg
<
'
n
'
e
>
{
fn
eq
(
&
self
other
:
&
Arg
<
'
n
'
e
>
)
-
>
bool
{
self
.
b
=
=
other
.
b
}
}
