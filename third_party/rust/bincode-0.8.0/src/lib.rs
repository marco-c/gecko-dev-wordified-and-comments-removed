#
!
[
deny
(
missing_docs
)
]
#
!
[
crate_name
=
"
bincode
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
crate_type
=
"
dylib
"
]
extern
crate
byteorder
;
extern
crate
num_traits
;
extern
crate
serde
as
serde_crate
;
mod
ser
;
mod
de
;
pub
mod
internal
;
pub
mod
read_types
{
pub
use
:
:
de
:
:
read
:
:
{
SliceReader
BincodeRead
IoReadReader
}
;
}
use
std
:
:
io
:
:
{
Read
Write
}
;
pub
use
internal
:
:
{
ErrorKind
Error
Result
serialized_size
serialized_size_bounded
}
;
pub
type
Deserializer
<
W
S
>
=
internal
:
:
Deserializer
<
W
S
byteorder
:
:
LittleEndian
>
;
pub
type
Serializer
<
W
>
=
internal
:
:
Serializer
<
W
byteorder
:
:
LittleEndian
>
;
pub
fn
deserialize
<
'
a
T
>
(
bytes
:
&
'
a
[
u8
]
)
-
>
internal
:
:
Result
<
T
>
where
T
:
serde_crate
:
:
de
:
:
Deserialize
<
'
a
>
{
internal
:
:
deserialize
:
:
<
_
byteorder
:
:
LittleEndian
>
(
bytes
)
}
pub
fn
deserialize_from
<
R
:
?
Sized
T
S
>
(
reader
:
&
mut
R
size_limit
:
S
)
-
>
internal
:
:
Result
<
T
>
where
R
:
Read
T
:
serde_crate
:
:
de
:
:
DeserializeOwned
S
:
SizeLimit
{
internal
:
:
deserialize_from
:
:
<
_
_
_
byteorder
:
:
LittleEndian
>
(
reader
size_limit
)
}
pub
fn
serialize_into
<
W
:
?
Sized
T
:
?
Sized
S
>
(
writer
:
&
mut
W
value
:
&
T
size_limit
:
S
)
-
>
internal
:
:
Result
<
(
)
>
where
W
:
Write
T
:
serde_crate
:
:
Serialize
S
:
SizeLimit
{
internal
:
:
serialize_into
:
:
<
_
_
_
byteorder
:
:
LittleEndian
>
(
writer
value
size_limit
)
}
pub
fn
serialize
<
T
:
?
Sized
S
>
(
value
:
&
T
size_limit
:
S
)
-
>
internal
:
:
Result
<
Vec
<
u8
>
>
where
T
:
serde_crate
:
:
Serialize
S
:
SizeLimit
{
internal
:
:
serialize
:
:
<
_
_
byteorder
:
:
LittleEndian
>
(
value
size_limit
)
}
pub
trait
SizeLimit
{
fn
add
(
&
mut
self
n
:
u64
)
-
>
Result
<
(
)
>
;
fn
limit
(
&
self
)
-
>
Option
<
u64
>
;
}
#
[
derive
(
Copy
Clone
)
]
pub
struct
Bounded
(
pub
u64
)
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
Infinite
;
impl
SizeLimit
for
Bounded
{
#
[
inline
(
always
)
]
fn
add
(
&
mut
self
n
:
u64
)
-
>
Result
<
(
)
>
{
if
self
.
0
>
=
n
{
self
.
0
-
=
n
;
Ok
(
(
)
)
}
else
{
Err
(
Box
:
:
new
(
ErrorKind
:
:
SizeLimit
)
)
}
}
#
[
inline
(
always
)
]
fn
limit
(
&
self
)
-
>
Option
<
u64
>
{
Some
(
self
.
0
)
}
}
impl
SizeLimit
for
Infinite
{
#
[
inline
(
always
)
]
fn
add
(
&
mut
self
_
:
u64
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
#
[
inline
(
always
)
]
fn
limit
(
&
self
)
-
>
Option
<
u64
>
{
None
}
}
