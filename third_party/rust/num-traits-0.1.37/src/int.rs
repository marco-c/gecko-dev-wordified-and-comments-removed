use
std
:
:
ops
:
:
{
Not
BitAnd
BitOr
BitXor
Shl
Shr
}
;
use
{
Num
NumCast
}
;
use
bounds
:
:
Bounded
;
use
ops
:
:
checked
:
:
*
;
use
ops
:
:
saturating
:
:
Saturating
;
pub
trait
PrimInt
:
Sized
+
Copy
+
Num
+
NumCast
+
Bounded
+
PartialOrd
+
Ord
+
Eq
+
Not
<
Output
=
Self
>
+
BitAnd
<
Output
=
Self
>
+
BitOr
<
Output
=
Self
>
+
BitXor
<
Output
=
Self
>
+
Shl
<
usize
Output
=
Self
>
+
Shr
<
usize
Output
=
Self
>
+
CheckedAdd
<
Output
=
Self
>
+
CheckedSub
<
Output
=
Self
>
+
CheckedMul
<
Output
=
Self
>
+
CheckedDiv
<
Output
=
Self
>
+
Saturating
{
fn
count_ones
(
self
)
-
>
u32
;
fn
count_zeros
(
self
)
-
>
u32
;
fn
leading_zeros
(
self
)
-
>
u32
;
fn
trailing_zeros
(
self
)
-
>
u32
;
fn
rotate_left
(
self
n
:
u32
)
-
>
Self
;
fn
rotate_right
(
self
n
:
u32
)
-
>
Self
;
fn
signed_shl
(
self
n
:
u32
)
-
>
Self
;
fn
signed_shr
(
self
n
:
u32
)
-
>
Self
;
fn
unsigned_shl
(
self
n
:
u32
)
-
>
Self
;
fn
unsigned_shr
(
self
n
:
u32
)
-
>
Self
;
fn
swap_bytes
(
self
)
-
>
Self
;
fn
from_be
(
x
:
Self
)
-
>
Self
;
fn
from_le
(
x
:
Self
)
-
>
Self
;
fn
to_be
(
self
)
-
>
Self
;
fn
to_le
(
self
)
-
>
Self
;
fn
pow
(
self
exp
:
u32
)
-
>
Self
;
}
macro_rules
!
prim_int_impl
{
(
T
:
ty
S
:
ty
U
:
ty
)
=
>
(
impl
PrimInt
for
T
{
#
[
inline
]
fn
count_ones
(
self
)
-
>
u32
{
<
T
>
:
:
count_ones
(
self
)
}
#
[
inline
]
fn
count_zeros
(
self
)
-
>
u32
{
<
T
>
:
:
count_zeros
(
self
)
}
#
[
inline
]
fn
leading_zeros
(
self
)
-
>
u32
{
<
T
>
:
:
leading_zeros
(
self
)
}
#
[
inline
]
fn
trailing_zeros
(
self
)
-
>
u32
{
<
T
>
:
:
trailing_zeros
(
self
)
}
#
[
inline
]
fn
rotate_left
(
self
n
:
u32
)
-
>
Self
{
<
T
>
:
:
rotate_left
(
self
n
)
}
#
[
inline
]
fn
rotate_right
(
self
n
:
u32
)
-
>
Self
{
<
T
>
:
:
rotate_right
(
self
n
)
}
#
[
inline
]
fn
signed_shl
(
self
n
:
u32
)
-
>
Self
{
(
(
self
as
S
)
<
<
n
)
as
T
}
#
[
inline
]
fn
signed_shr
(
self
n
:
u32
)
-
>
Self
{
(
(
self
as
S
)
>
>
n
)
as
T
}
#
[
inline
]
fn
unsigned_shl
(
self
n
:
u32
)
-
>
Self
{
(
(
self
as
U
)
<
<
n
)
as
T
}
#
[
inline
]
fn
unsigned_shr
(
self
n
:
u32
)
-
>
Self
{
(
(
self
as
U
)
>
>
n
)
as
T
}
#
[
inline
]
fn
swap_bytes
(
self
)
-
>
Self
{
<
T
>
:
:
swap_bytes
(
self
)
}
#
[
inline
]
fn
from_be
(
x
:
Self
)
-
>
Self
{
<
T
>
:
:
from_be
(
x
)
}
#
[
inline
]
fn
from_le
(
x
:
Self
)
-
>
Self
{
<
T
>
:
:
from_le
(
x
)
}
#
[
inline
]
fn
to_be
(
self
)
-
>
Self
{
<
T
>
:
:
to_be
(
self
)
}
#
[
inline
]
fn
to_le
(
self
)
-
>
Self
{
<
T
>
:
:
to_le
(
self
)
}
#
[
inline
]
fn
pow
(
self
exp
:
u32
)
-
>
Self
{
<
T
>
:
:
pow
(
self
exp
)
}
}
)
}
prim_int_impl
!
(
u8
i8
u8
)
;
prim_int_impl
!
(
u16
i16
u16
)
;
prim_int_impl
!
(
u32
i32
u32
)
;
prim_int_impl
!
(
u64
i64
u64
)
;
prim_int_impl
!
(
usize
isize
usize
)
;
prim_int_impl
!
(
i8
i8
u8
)
;
prim_int_impl
!
(
i16
i16
u16
)
;
prim_int_impl
!
(
i32
i32
u32
)
;
prim_int_impl
!
(
i64
i64
u64
)
;
prim_int_impl
!
(
isize
isize
usize
)
;
