use
std
:
:
ffi
:
:
CString
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
use
runtime
:
:
{
BOOL
Class
Imp
NO
Object
Protocol
Sel
self
}
;
use
{
Encode
EncodeArguments
Encoding
Message
}
;
pub
trait
MethodImplementation
{
type
Callee
:
Message
;
type
Ret
:
Encode
;
type
Args
:
EncodeArguments
;
fn
imp
(
self
)
-
>
Imp
;
}
macro_rules
!
method_decl_impl
{
(
-
s
:
ident
r
:
ident
f
:
ty
(
t
:
ident
)
*
)
=
>
(
impl
<
s
r
(
t
)
*
>
MethodImplementation
for
f
where
s
:
Message
r
:
Encode
(
t
:
Encode
)
*
{
type
Callee
=
s
;
type
Ret
=
r
;
type
Args
=
(
(
t
)
*
)
;
fn
imp
(
self
)
-
>
Imp
{
unsafe
{
mem
:
:
transmute
(
self
)
}
}
}
)
;
(
(
t
:
ident
)
*
)
=
>
(
method_decl_impl
!
(
-
T
R
extern
fn
(
&
T
Sel
(
t
)
*
)
-
>
R
(
t
)
*
)
;
method_decl_impl
!
(
-
T
R
extern
fn
(
&
mut
T
Sel
(
t
)
*
)
-
>
R
(
t
)
*
)
;
)
;
}
method_decl_impl
!
(
)
;
method_decl_impl
!
(
A
)
;
method_decl_impl
!
(
A
B
)
;
method_decl_impl
!
(
A
B
C
)
;
method_decl_impl
!
(
A
B
C
D
)
;
method_decl_impl
!
(
A
B
C
D
E
)
;
method_decl_impl
!
(
A
B
C
D
E
F
)
;
method_decl_impl
!
(
A
B
C
D
E
F
G
)
;
method_decl_impl
!
(
A
B
C
D
E
F
G
H
)
;
method_decl_impl
!
(
A
B
C
D
E
F
G
H
I
)
;
method_decl_impl
!
(
A
B
C
D
E
F
G
H
I
J
)
;
method_decl_impl
!
(
A
B
C
D
E
F
G
H
I
J
K
)
;
method_decl_impl
!
(
A
B
C
D
E
F
G
H
I
J
K
L
)
;
fn
count_args
(
sel
:
Sel
)
-
>
usize
{
sel
.
name
(
)
.
chars
(
)
.
filter
(
|
&
c
|
c
=
=
'
:
'
)
.
count
(
)
}
fn
method_type_encoding
(
ret
:
&
Encoding
args
:
&
[
Encoding
]
)
-
>
CString
{
let
mut
types
=
ret
.
as_str
(
)
.
to_owned
(
)
;
types
.
push_str
(
<
*
mut
Object
>
:
:
encode
(
)
.
as_str
(
)
)
;
types
.
push_str
(
Sel
:
:
encode
(
)
.
as_str
(
)
)
;
types
.
extend
(
args
.
iter
(
)
.
map
(
|
e
|
e
.
as_str
(
)
)
)
;
CString
:
:
new
(
types
)
.
unwrap
(
)
}
fn
log2_align_of
<
T
>
(
)
-
>
u8
{
let
align
=
mem
:
:
align_of
:
:
<
T
>
(
)
;
debug_assert
!
(
align
.
count_ones
(
)
=
=
1
)
;
align
.
trailing_zeros
(
)
as
u8
}
pub
struct
ClassDecl
{
cls
:
*
mut
Class
}
impl
ClassDecl
{
fn
with_superclass
(
name
:
&
str
superclass
:
Option
<
&
Class
>
)
-
>
Option
<
ClassDecl
>
{
let
name
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
let
super_ptr
=
superclass
.
map_or
(
ptr
:
:
null
(
)
|
c
|
c
)
;
let
cls
=
unsafe
{
runtime
:
:
objc_allocateClassPair
(
super_ptr
name
.
as_ptr
(
)
0
)
}
;
if
cls
.
is_null
(
)
{
None
}
else
{
Some
(
ClassDecl
{
cls
:
cls
}
)
}
}
pub
fn
new
(
name
:
&
str
superclass
:
&
Class
)
-
>
Option
<
ClassDecl
>
{
ClassDecl
:
:
with_superclass
(
name
Some
(
superclass
)
)
}
pub
fn
root
(
name
:
&
str
intitialize_fn
:
extern
fn
(
&
Class
Sel
)
)
-
>
Option
<
ClassDecl
>
{
let
mut
decl
=
ClassDecl
:
:
with_superclass
(
name
None
)
;
if
let
Some
(
ref
mut
decl
)
=
decl
{
unsafe
{
decl
.
add_class_method
(
sel
!
(
initialize
)
intitialize_fn
)
;
}
}
decl
}
pub
unsafe
fn
add_method
<
F
>
(
&
mut
self
sel
:
Sel
func
:
F
)
where
F
:
MethodImplementation
<
Callee
=
Object
>
{
let
encs
=
F
:
:
Args
:
:
encodings
(
)
;
let
encs
=
encs
.
as_ref
(
)
;
let
sel_args
=
count_args
(
sel
)
;
assert
!
(
sel_args
=
=
encs
.
len
(
)
"
Selector
accepts
{
}
arguments
but
function
accepts
{
}
"
sel_args
encs
.
len
(
)
)
;
let
types
=
method_type_encoding
(
&
F
:
:
Ret
:
:
encode
(
)
encs
)
;
let
success
=
runtime
:
:
class_addMethod
(
self
.
cls
sel
func
.
imp
(
)
types
.
as_ptr
(
)
)
;
assert
!
(
success
!
=
NO
"
Failed
to
add
method
{
:
?
}
"
sel
)
;
}
pub
unsafe
fn
add_class_method
<
F
>
(
&
mut
self
sel
:
Sel
func
:
F
)
where
F
:
MethodImplementation
<
Callee
=
Class
>
{
let
encs
=
F
:
:
Args
:
:
encodings
(
)
;
let
encs
=
encs
.
as_ref
(
)
;
let
sel_args
=
count_args
(
sel
)
;
assert
!
(
sel_args
=
=
encs
.
len
(
)
"
Selector
accepts
{
}
arguments
but
function
accepts
{
}
"
sel_args
encs
.
len
(
)
)
;
let
types
=
method_type_encoding
(
&
F
:
:
Ret
:
:
encode
(
)
encs
)
;
let
metaclass
=
(
*
self
.
cls
)
.
metaclass
(
)
as
*
const
_
as
*
mut
_
;
let
success
=
runtime
:
:
class_addMethod
(
metaclass
sel
func
.
imp
(
)
types
.
as_ptr
(
)
)
;
assert
!
(
success
!
=
NO
"
Failed
to
add
class
method
{
:
?
}
"
sel
)
;
}
pub
fn
add_ivar
<
T
>
(
&
mut
self
name
:
&
str
)
where
T
:
Encode
{
let
c_name
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
let
encoding
=
CString
:
:
new
(
T
:
:
encode
(
)
.
as_str
(
)
)
.
unwrap
(
)
;
let
size
=
mem
:
:
size_of
:
:
<
T
>
(
)
;
let
align
=
log2_align_of
:
:
<
T
>
(
)
;
let
success
=
unsafe
{
runtime
:
:
class_addIvar
(
self
.
cls
c_name
.
as_ptr
(
)
size
align
encoding
.
as_ptr
(
)
)
}
;
assert
!
(
success
!
=
NO
"
Failed
to
add
ivar
{
}
"
name
)
;
}
pub
fn
add_protocol
(
&
mut
self
proto
:
&
Protocol
)
{
let
success
=
unsafe
{
runtime
:
:
class_addProtocol
(
self
.
cls
proto
)
}
;
assert
!
(
success
!
=
NO
"
Failed
to
add
protocol
{
:
?
}
"
proto
)
;
}
pub
fn
register
(
self
)
-
>
&
'
static
Class
{
unsafe
{
let
cls
=
self
.
cls
;
runtime
:
:
objc_registerClassPair
(
cls
)
;
mem
:
:
forget
(
self
)
;
&
*
cls
}
}
}
impl
Drop
for
ClassDecl
{
fn
drop
(
&
mut
self
)
{
unsafe
{
runtime
:
:
objc_disposeClassPair
(
self
.
cls
)
;
}
}
}
pub
struct
ProtocolDecl
{
proto
:
*
mut
Protocol
}
impl
ProtocolDecl
{
pub
fn
new
(
name
:
&
str
)
-
>
Option
<
ProtocolDecl
>
{
let
c_name
=
CString
:
:
new
(
name
)
.
unwrap
(
)
;
let
proto
=
unsafe
{
runtime
:
:
objc_allocateProtocol
(
c_name
.
as_ptr
(
)
)
}
;
if
proto
.
is_null
(
)
{
None
}
else
{
Some
(
ProtocolDecl
{
proto
:
proto
}
)
}
}
fn
add_method_description_common
<
Args
Ret
>
(
&
mut
self
sel
:
Sel
is_required
:
bool
is_instance_method
:
bool
)
where
Args
:
EncodeArguments
Ret
:
Encode
{
let
encs
=
Args
:
:
encodings
(
)
;
let
encs
=
encs
.
as_ref
(
)
;
let
sel_args
=
count_args
(
sel
)
;
assert
!
(
sel_args
=
=
encs
.
len
(
)
"
Selector
accepts
{
}
arguments
but
function
accepts
{
}
"
sel_args
encs
.
len
(
)
)
;
let
types
=
method_type_encoding
(
&
Ret
:
:
encode
(
)
encs
)
;
unsafe
{
runtime
:
:
protocol_addMethodDescription
(
self
.
proto
sel
types
.
as_ptr
(
)
is_required
as
BOOL
is_instance_method
as
BOOL
)
;
}
}
pub
fn
add_method_description
<
Args
Ret
>
(
&
mut
self
sel
:
Sel
is_required
:
bool
)
where
Args
:
EncodeArguments
Ret
:
Encode
{
self
.
add_method_description_common
:
:
<
Args
Ret
>
(
sel
is_required
true
)
}
pub
fn
add_class_method_description
<
Args
Ret
>
(
&
mut
self
sel
:
Sel
is_required
:
bool
)
where
Args
:
EncodeArguments
Ret
:
Encode
{
self
.
add_method_description_common
:
:
<
Args
Ret
>
(
sel
is_required
false
)
}
pub
fn
add_protocol
(
&
mut
self
proto
:
&
Protocol
)
{
unsafe
{
runtime
:
:
protocol_addProtocol
(
self
.
proto
proto
)
;
}
}
pub
fn
register
(
self
)
-
>
&
'
static
Protocol
{
unsafe
{
runtime
:
:
objc_registerProtocol
(
self
.
proto
)
;
&
*
self
.
proto
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
test_utils
;
#
[
test
]
fn
test_custom_class
(
)
{
let
obj
=
test_utils
:
:
custom_object
(
)
;
unsafe
{
let
_
:
(
)
=
msg_send
!
[
obj
setFoo
:
13u32
]
;
let
result
:
u32
=
msg_send
!
[
obj
foo
]
;
assert
!
(
result
=
=
13
)
;
}
}
#
[
test
]
fn
test_class_method
(
)
{
let
cls
=
test_utils
:
:
custom_class
(
)
;
unsafe
{
let
result
:
u32
=
msg_send
!
[
cls
classFoo
]
;
assert
!
(
result
=
=
7
)
;
}
}
}
