use
relevancy
:
:
{
url_hash
:
:
{
hash_url
UrlHash
}
Interest
}
;
use
std
:
:
{
collections
:
:
HashMap
fs
:
:
File
io
:
:
Write
}
;
const
TEST_INTEREST_DATA
:
&
[
(
&
str
Interest
)
]
=
&
[
(
"
https
:
/
/
espn
.
com
/
"
Interest
:
:
Sports
)
(
"
https
:
/
/
dogs
.
com
/
"
Interest
:
:
Animals
)
(
"
https
:
/
/
cars
.
com
/
"
Interest
:
:
Autos
)
(
"
https
:
/
/
www
.
vouge
.
com
/
"
Interest
:
:
Fashion
)
(
"
https
:
/
/
slashdot
.
org
/
"
Interest
:
:
Tech
)
(
"
https
:
/
/
www
.
nascar
.
com
/
"
Interest
:
:
Autos
)
(
"
https
:
/
/
www
.
nascar
.
com
/
"
Interest
:
:
Sports
)
]
;
fn
main
(
)
{
let
mut
interest_map
:
HashMap
<
Interest
Vec
<
UrlHash
>
>
=
HashMap
:
:
from_iter
(
Interest
:
:
all
(
)
.
into_iter
(
)
.
map
(
|
i
|
(
i
vec
!
[
]
)
)
)
;
for
(
url
interest
)
in
TEST_INTEREST_DATA
{
if
let
Some
(
hash
)
=
hash_url
(
url
)
{
interest_map
.
get_mut
(
interest
)
.
unwrap
(
)
.
push
(
hash
)
}
}
let
mut
f
=
File
:
:
create
(
"
test
-
data
"
)
.
expect
(
"
Error
opening
file
"
)
;
for
interest
in
Interest
:
:
all
(
)
{
let
hashes
=
interest_map
.
get
(
&
interest
)
.
unwrap
(
)
;
f
.
write_all
(
&
(
hashes
.
len
(
)
as
u32
)
.
to_le_bytes
(
)
)
.
expect
(
"
Error
writing
file
"
)
;
for
hash
in
hashes
{
f
.
write_all
(
hash
)
.
expect
(
"
Error
writing
file
"
)
;
}
}
}
