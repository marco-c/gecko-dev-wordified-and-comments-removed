mod
db
;
mod
error
;
mod
ingest
;
mod
interest
;
mod
rs
;
mod
schema
;
pub
mod
url_hash
;
pub
use
db
:
:
RelevancyDb
;
pub
use
error
:
:
{
ApiResult
Error
RelevancyApiError
Result
}
;
pub
use
interest
:
:
{
Interest
InterestVector
}
;
use
error_support
:
:
handle_error
;
pub
struct
RelevancyStore
{
db
:
RelevancyDb
}
impl
RelevancyStore
{
pub
fn
new
(
db_path
:
String
)
-
>
Self
{
Self
{
db
:
RelevancyDb
:
:
new
(
db_path
)
}
}
pub
fn
close
(
&
self
)
{
self
.
db
.
close
(
)
}
pub
fn
interrupt
(
&
self
)
{
self
.
db
.
interrupt
(
)
}
#
[
handle_error
(
Error
)
]
pub
fn
ensure_interest_data_populated
(
&
self
)
-
>
ApiResult
<
(
)
>
{
ingest
:
:
ensure_interest_data_populated
(
&
self
.
db
)
?
;
Ok
(
(
)
)
}
#
[
handle_error
(
Error
)
]
pub
fn
ingest
(
&
self
top_urls_by_frecency
:
Vec
<
String
>
)
-
>
ApiResult
<
InterestVector
>
{
ingest
:
:
ensure_interest_data_populated
(
&
self
.
db
)
?
;
let
interest_vec
=
self
.
classify
(
top_urls_by_frecency
)
?
;
self
.
db
.
read_write
(
|
dao
|
dao
.
update_frecency_user_interest_vector
(
&
interest_vec
)
)
?
;
Ok
(
interest_vec
)
}
pub
fn
classify
(
&
self
top_urls_by_frecency
:
Vec
<
String
>
)
-
>
Result
<
InterestVector
>
{
let
mut
interest_vector
=
InterestVector
:
:
default
(
)
;
for
url
in
top_urls_by_frecency
{
let
interest_count
=
self
.
db
.
read
(
|
dao
|
dao
.
get_url_interest_vector
(
&
url
)
)
?
;
log
:
:
trace
!
(
"
classified
:
{
url
}
{
}
"
interest_count
.
summary
(
)
)
;
interest_vector
=
interest_vector
+
interest_count
;
}
Ok
(
interest_vector
)
}
#
[
handle_error
(
Error
)
]
pub
fn
calculate_metrics
(
&
self
)
-
>
ApiResult
<
InterestMetrics
>
{
todo
!
(
)
}
#
[
handle_error
(
Error
)
]
pub
fn
user_interest_vector
(
&
self
)
-
>
ApiResult
<
InterestVector
>
{
todo
!
(
)
}
}
pub
struct
InterestMetrics
{
pub
top_single_interest_similarity
:
u32
pub
top_2interest_similarity
:
u32
pub
top_3interest_similarity
:
u32
}
uniffi
:
:
include_scaffolding
!
(
"
relevancy
"
)
;
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
url_hash
:
:
hash_url
;
use
super
:
:
*
;
#
[
test
]
fn
test_ingest
(
)
{
let
top_urls
=
vec
!
[
"
https
:
/
/
food
.
com
/
"
.
to_string
(
)
"
https
:
/
/
hello
.
com
"
.
to_string
(
)
"
https
:
/
/
pasta
.
com
"
.
to_string
(
)
"
https
:
/
/
dog
.
com
"
.
to_string
(
)
]
;
let
relevancy_store
=
RelevancyStore
:
:
new
(
"
file
:
test_store_data
?
mode
=
memory
&
cache
=
shared
"
.
to_owned
(
)
)
;
relevancy_store
.
db
.
read_write
(
|
dao
|
{
dao
.
add_url_interest
(
hash_url
(
"
https
:
/
/
food
.
com
"
)
.
unwrap
(
)
Interest
:
:
Food
)
?
;
dao
.
add_url_interest
(
hash_url
(
"
https
:
/
/
hello
.
com
"
)
.
unwrap
(
)
Interest
:
:
Inconclusive
)
?
;
dao
.
add_url_interest
(
hash_url
(
"
https
:
/
/
pasta
.
com
"
)
.
unwrap
(
)
Interest
:
:
Food
)
?
;
dao
.
add_url_interest
(
hash_url
(
"
https
:
/
/
dog
.
com
"
)
.
unwrap
(
)
Interest
:
:
Animals
)
?
;
Ok
(
(
)
)
}
)
.
expect
(
"
Insert
should
succeed
"
)
;
assert_eq
!
(
relevancy_store
.
ingest
(
top_urls
)
.
unwrap
(
)
InterestVector
{
inconclusive
:
1
animals
:
1
food
:
2
.
.
InterestVector
:
:
default
(
)
}
)
;
}
}
