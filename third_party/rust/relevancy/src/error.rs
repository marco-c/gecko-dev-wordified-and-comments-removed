use
error_support
:
:
{
ErrorHandling
GetErrorHandling
}
;
#
[
derive
(
Debug
thiserror
:
:
Error
uniffi
:
:
Error
)
]
pub
enum
RelevancyApiError
{
#
[
error
(
"
Unexpected
Error
:
{
reason
}
"
)
]
Unexpected
{
reason
:
String
}
}
#
[
derive
(
Debug
thiserror
:
:
Error
)
]
pub
enum
Error
{
#
[
error
(
"
Error
opening
database
:
{
0
}
"
)
]
OpenDatabase
(
#
[
from
]
sql_support
:
:
open_database
:
:
Error
)
#
[
error
(
"
Sql
error
:
{
0
}
"
)
]
SqlError
(
#
[
from
]
rusqlite
:
:
Error
)
#
[
error
(
"
Error
fetching
interest
data
"
)
]
FetchInterestDataError
#
[
error
(
"
Interrupted
"
)
]
Interrupted
(
#
[
from
]
interrupt_support
:
:
Interrupted
)
#
[
error
(
"
Invalid
interest
code
:
{
0
}
"
)
]
InvalidInterestCode
(
u32
)
#
[
error
(
"
Remote
Setting
Error
:
{
0
}
"
)
]
RemoteSettingsError
(
#
[
from
]
remote_settings
:
:
RemoteSettingsError
)
#
[
error
(
"
Error
parsing
{
type_name
}
:
{
error
}
(
{
path
}
)
"
)
]
RemoteSettingsParseError
{
type_name
:
String
path
:
String
error
:
serde_json
:
:
Error
}
#
[
error
(
"
Base64
Decode
Error
:
{
0
}
"
)
]
Base64DecodeError
(
String
)
#
[
error
(
"
Error
retrieving
bandit
data
for
bandit
{
bandit
}
and
arm
{
arm
}
"
)
]
BanditNotFound
{
bandit
:
String
arm
:
String
}
}
pub
type
ApiResult
<
T
>
=
std
:
:
result
:
:
Result
<
T
RelevancyApiError
>
;
pub
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
Error
>
;
impl
GetErrorHandling
for
Error
{
type
ExternalError
=
RelevancyApiError
;
fn
get_error_handling
(
&
self
)
-
>
ErrorHandling
<
Self
:
:
ExternalError
>
{
match
self
{
Self
:
:
RemoteSettingsParseError
{
.
.
}
=
>
{
ErrorHandling
:
:
convert
(
RelevancyApiError
:
:
Unexpected
{
reason
:
self
.
to_string
(
)
}
)
.
report_error
(
"
relevancy
-
remote
-
settings
-
parse
-
error
"
)
}
_
=
>
ErrorHandling
:
:
convert
(
RelevancyApiError
:
:
Unexpected
{
reason
:
self
.
to_string
(
)
}
)
}
}
}
