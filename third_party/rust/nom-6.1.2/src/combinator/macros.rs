#
[
allow
(
unused_variables
)
]
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
named
(
(
#
(
args
:
tt
)
*
)
=
>
(
named_attr
!
(
#
(
args
)
*
)
;
)
;
(
vis
:
vis
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
vis
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
crate
:
:
error
:
:
Error
<
i
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
vis
:
vis
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
vis
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
vis
:
vis
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
vis
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
crate
:
:
error
:
:
Error
<
i
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
vis
:
vis
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
vis
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
crate
:
:
error
:
:
Error
<
&
[
u8
]
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
vis
:
vis
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
vis
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
crate
:
:
error
:
:
Error
<
&
[
u8
]
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
named_args
{
(
vis
:
vis
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
vis
fn
func_name
(
input
:
&
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
vis
:
vis
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
vis
fn
func_name
<
'
this_is_probably_unique_i_hope_please
'
a
>
(
input
:
&
'
this_is_probably_unique_i_hope_please
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
'
this_is_probably_unique_i_hope_please
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
vis
:
vis
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
input_type
:
ty
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
vis
fn
func_name
(
input
:
input_type
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
input_type
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
vis
:
vis
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
input_type
:
ty
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
vis
fn
func_name
<
'
a
>
(
input
:
input_type
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
input_type
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
}
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
named_attr
(
(
(
#
[
attr
:
meta
]
)
*
vis
:
vis
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
vis
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
crate
:
:
error
:
:
Error
<
i
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
vis
:
vis
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
vis
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
vis
:
vis
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
vis
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
crate
:
:
error
:
:
Error
<
i
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
vis
:
vis
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
vis
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
crate
:
:
error
:
:
Error
<
&
[
u8
]
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
vis
:
vis
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
vis
fn
name
<
'
a
>
(
i
:
&
'
a
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
crate
:
:
error
:
:
Error
<
&
[
u8
]
>
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
call
(
(
i
:
expr
fun
:
expr
)
=
>
(
fun
(
i
)
)
;
(
i
:
expr
fun
:
expr
(
args
:
expr
)
*
)
=
>
(
fun
(
i
(
args
)
*
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
return_error
(
(
i
:
expr
code
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
let
i_
=
i
.
clone
(
)
;
let
cl
=
|
|
{
submac
!
(
i_
(
args
)
*
)
}
;
match
cl
(
)
{
Err
(
Err
:
:
Incomplete
(
x
)
)
=
>
Err
(
Err
:
:
Incomplete
(
x
)
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
Err
:
:
Error
(
e
)
)
|
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
return
Err
(
Err
:
:
Failure
(
crate
:
:
error
:
:
append_error
(
i
code
e
)
)
)
}
}
}
)
;
(
i
:
expr
code
:
expr
f
:
expr
)
=
>
(
return_error
!
(
i
code
call
!
(
f
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
let
i_
=
i
.
clone
(
)
;
let
cl
=
|
|
{
submac
!
(
i_
(
args
)
*
)
}
;
match
cl
(
)
{
Err
(
Err
:
:
Incomplete
(
x
)
)
=
>
Err
(
Err
:
:
Incomplete
(
x
)
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
Err
:
:
Error
(
e
)
)
|
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
return
Err
(
Err
:
:
Failure
(
e
)
)
}
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
return_error
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
add_return_error
(
(
i
:
expr
code
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
error
:
:
ErrorKind
}
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
{
Err
(
Err
:
:
Error
(
error_node_position
!
(
i
code
e
)
)
)
}
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
Err
(
Err
:
:
Failure
(
error_node_position
!
(
i
code
e
)
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
code
:
expr
f
:
expr
)
=
>
(
add_return_error
!
(
i
code
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
complete
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
completec
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
)
)
;
(
i
:
expr
f
:
expr
)
=
>
(
complete
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
try_parse
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
(
i
o
)
Err
(
e
)
=
>
return
Err
(
e
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
try_parse
!
(
i
call
!
(
f
)
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
map
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
crate
:
:
combinator
:
:
mapc
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
g
)
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map
!
(
__impl
i
submac
!
(
(
args
)
*
)
g
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map
!
(
__impl
i
call
!
(
f
)
g
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
map_res
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
map_resc
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
move
|
i
|
{
submac2
!
(
i
(
args2
)
*
)
}
)
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map_res
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
map_res
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map_res
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
map_res
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
map_opt
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
map_optc
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
move
|
i
|
{
submac2
!
(
i
(
args2
)
*
)
}
)
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map_opt
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
map_opt
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map_opt
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
map_opt
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
parse_to
(
(
i
:
expr
t
:
ty
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
*
;
use
crate
:
:
{
Err
error
:
:
ErrorKind
}
;
use
crate
:
:
ParseTo
;
use
crate
:
:
Slice
;
use
crate
:
:
InputLength
;
let
res
:
Option
<
t
>
=
(
i
)
.
parse_to
(
)
;
match
res
{
Some
(
output
)
=
>
Ok
(
(
i
.
slice
(
i
.
input_len
(
)
.
.
)
output
)
)
None
=
>
Err
(
Err
:
:
Error
(
crate
:
:
error
:
:
make_error
(
i
ErrorKind
:
:
ParseTo
)
)
)
}
}
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
verify
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
crate
:
:
combinator
:
:
verifyc
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
g
)
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
verifyc
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
|
&
o
|
submac2
!
(
o
(
args2
)
*
)
)
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
crate
:
:
combinator
:
:
verify
(
f
g
)
(
i
)
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
verify
(
f
|
&
o
|
submac
!
(
o
(
args
)
*
)
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
value
(
(
i
:
expr
res
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
valuec
(
i
res
|
i
|
submac
!
(
i
(
args
)
*
)
)
)
;
(
i
:
expr
res
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
valuec
(
i
res
f
)
)
;
(
i
:
expr
res
:
expr
)
=
>
(
Ok
(
(
i
res
)
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
opt
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
crate
:
:
combinator
:
:
optc
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
opt
(
f
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
opt_res
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
Ok
(
o
)
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Ok
(
(
i
Err
(
Err
:
:
Error
(
e
)
)
)
)
/
/
in
case
of
failure
we
return
a
real
error
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
opt_res
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
cond
(
(
i
:
expr
cond
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
condc
(
i
cond
|
i
|
submac
!
(
i
(
args
)
*
)
)
)
;
(
i
:
expr
cond
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
cond
(
cond
f
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
peek
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
peekc
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
)
;
(
i
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
peek
(
f
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
not
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
notc
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
)
;
(
i
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
not
(
f
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
tap
(
(
i
:
expr
name
:
ident
:
submac
:
ident
!
(
(
args
:
tt
)
*
)
=
>
e
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
Needed
IResult
}
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
{
let
name
=
o
;
e
;
Ok
(
(
i
name
)
)
}
Err
(
e
)
=
>
Err
(
Err
:
:
convert
(
e
)
)
}
}
)
;
(
i
:
expr
name
:
ident
:
f
:
expr
=
>
e
:
expr
)
=
>
(
tap
!
(
i
name
:
call
!
(
f
)
=
>
e
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
eof
(
(
i
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
error
:
:
ErrorKind
}
;
use
crate
:
:
InputLength
;
if
(
i
)
.
input_len
(
)
=
=
0
{
let
clone
=
i
.
clone
(
)
;
Ok
(
(
i
clone
)
)
}
else
{
Err
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
Eof
)
)
)
}
}
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
exact
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
terminated
!
(
i
submac
!
(
(
args
)
*
)
eof
!
(
)
)
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
exact
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
recognize
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
recognizec
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
)
;
(
i
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
recognize
(
f
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
into
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
intoc
(
i
|
i
|
submac
!
(
i
(
args
)
*
)
)
)
;
(
i
:
expr
f
:
expr
)
=
>
(
crate
:
:
combinator
:
:
intoc
(
i
f
)
)
;
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
error
:
:
ErrorKind
;
use
crate
:
:
error
:
:
ParseError
;
use
crate
:
:
internal
:
:
{
Err
IResult
Needed
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
lib
:
:
std
:
:
boxed
:
:
Box
;
macro_rules
!
tag
(
(
i
:
expr
tag
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
Needed
IResult
error
:
:
ErrorKind
}
;
use
crate
:
:
{
Compare
CompareResult
InputLength
Slice
}
;
let
res
:
IResult
<
_
_
>
=
match
(
i
)
.
compare
(
tag
)
{
CompareResult
:
:
Ok
=
>
{
let
blen
=
tag
.
input_len
(
)
;
Ok
(
(
i
.
slice
(
blen
.
.
)
i
.
slice
(
.
.
blen
)
)
)
}
CompareResult
:
:
Incomplete
=
>
{
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
tag
.
input_len
(
)
-
i
.
input_len
(
)
)
)
)
}
CompareResult
:
:
Error
=
>
{
let
e
:
ErrorKind
=
ErrorKind
:
:
Tag
;
Err
(
Err
:
:
Error
(
crate
:
:
error
:
:
make_error
(
i
e
)
)
)
}
}
;
res
}
)
;
)
;
macro_rules
!
take
(
(
i
:
expr
count
:
expr
)
=
>
(
{
let
cnt
=
count
as
usize
;
let
res
:
IResult
<
&
[
u8
]
&
[
u8
]
>
=
if
i
.
len
(
)
<
cnt
{
Err
(
crate
:
:
Err
:
:
Incomplete
(
crate
:
:
Needed
:
:
new
(
cnt
-
i
.
len
(
)
)
)
)
}
else
{
Ok
(
(
&
i
[
cnt
.
.
]
&
i
[
0
.
.
cnt
]
)
)
}
;
res
}
)
;
)
;
mod
pub_named_mod
{
named
!
(
pub
tst
tag
!
(
"
abcd
"
)
)
;
}
#
[
test
]
fn
pub_named_test
(
)
{
let
a
=
&
b
"
abcd
"
[
.
.
]
;
let
res
=
pub_named_mod
:
:
tst
(
a
)
;
assert_eq
!
(
res
Ok
(
(
&
b
"
"
[
.
.
]
a
)
)
)
;
}
mod
pub_crate_named_mod
{
named
!
(
pub
(
crate
)
tst
tag
!
(
"
abcd
"
)
)
;
}
#
[
test
]
fn
pub_crate_named_test
(
)
{
let
a
=
&
b
"
abcd
"
[
.
.
]
;
let
res
=
pub_crate_named_mod
:
:
tst
(
a
)
;
assert_eq
!
(
res
Ok
(
(
&
b
"
"
[
.
.
]
a
)
)
)
;
}
#
[
test
]
fn
apply_test
(
)
{
fn
sum2
(
a
:
u8
b
:
u8
)
-
>
u8
{
a
+
b
}
fn
sum3
(
a
:
u8
b
:
u8
c
:
u8
)
-
>
u8
{
a
+
b
+
c
}
let
a
=
call
!
(
1
sum2
2
)
;
let
b
=
call
!
(
1
sum3
2
3
)
;
assert_eq
!
(
a
3
)
;
assert_eq
!
(
b
6
)
;
}
#
[
test
]
fn
opt
(
)
{
named
!
(
opt_abcd
<
&
[
u8
]
Option
<
&
[
u8
]
>
>
opt
!
(
tag
!
(
"
abcd
"
)
)
)
;
let
a
=
&
b
"
abcdef
"
[
.
.
]
;
let
b
=
&
b
"
bcdefg
"
[
.
.
]
;
let
c
=
&
b
"
ab
"
[
.
.
]
;
assert_eq
!
(
opt_abcd
(
a
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Some
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
opt_abcd
(
b
)
Ok
(
(
&
b
"
bcdefg
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
opt_abcd
(
c
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
2
)
)
)
)
;
}
#
[
test
]
fn
opt_res
(
)
{
named
!
(
opt_res_abcd
<
&
[
u8
]
Result
<
&
[
u8
]
Err
<
crate
:
:
error
:
:
Error
<
&
[
u8
]
>
>
>
>
opt_res
!
(
tag
!
(
"
abcd
"
)
)
)
;
let
a
=
&
b
"
abcdef
"
[
.
.
]
;
let
b
=
&
b
"
bcdefg
"
[
.
.
]
;
let
c
=
&
b
"
ab
"
[
.
.
]
;
assert_eq
!
(
opt_res_abcd
(
a
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Ok
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
opt_res_abcd
(
b
)
Ok
(
(
&
b
"
bcdefg
"
[
.
.
]
Err
(
Err
:
:
Error
(
error_position
!
(
b
ErrorKind
:
:
Tag
)
)
)
)
)
)
;
assert_eq
!
(
opt_res_abcd
(
c
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
2
)
)
)
)
;
}
use
crate
:
:
lib
:
:
std
:
:
convert
:
:
From
;
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CustomError
(
&
'
static
str
)
;
impl
<
I
>
From
<
(
I
ErrorKind
)
>
for
CustomError
{
fn
from
(
_
:
(
I
ErrorKind
)
)
-
>
Self
{
CustomError
(
"
test
"
)
}
}
impl
<
I
>
From
<
crate
:
:
error
:
:
Error
<
I
>
>
for
CustomError
{
fn
from
(
_
:
crate
:
:
error
:
:
Error
<
I
>
)
-
>
Self
{
CustomError
(
"
test
"
)
}
}
impl
<
I
>
ParseError
<
I
>
for
CustomError
{
fn
from_error_kind
(
_
:
I
_
:
ErrorKind
)
-
>
Self
{
CustomError
(
"
from_error_kind
"
)
}
fn
append
(
_
:
I
_
:
ErrorKind
_
:
CustomError
)
-
>
Self
{
CustomError
(
"
append
"
)
}
}
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
cond
(
)
{
fn
f_true
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
{
fix_error
!
(
i
CustomError
cond
!
(
true
tag
!
(
"
abcd
"
)
)
)
}
fn
f_false
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
{
fix_error
!
(
i
CustomError
cond
!
(
false
tag
!
(
"
abcd
"
)
)
)
}
assert_eq
!
(
f_true
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Some
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
ab
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
2
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
xxx
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
CustomError
(
"
test
"
)
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
abcdef
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
ab
"
[
.
.
]
)
Ok
(
(
&
b
"
ab
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
xxx
"
[
.
.
]
)
Ok
(
(
&
b
"
xxx
"
[
.
.
]
None
)
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
cond_wrapping
(
)
{
named
!
(
tag_abcd
tag
!
(
"
abcd
"
)
)
;
fn
f_true
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
{
fix_error
!
(
i
CustomError
cond
!
(
true
tag_abcd
)
)
}
fn
f_false
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
{
fix_error
!
(
i
CustomError
cond
!
(
false
tag_abcd
)
)
}
assert_eq
!
(
f_true
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Some
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
ab
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
2
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
xxx
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
CustomError
(
"
test
"
)
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
abcdef
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
ab
"
[
.
.
]
)
Ok
(
(
&
b
"
ab
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
xxx
"
[
.
.
]
)
Ok
(
(
&
b
"
xxx
"
[
.
.
]
None
)
)
)
;
}
#
[
test
]
fn
peek
(
)
{
named
!
(
peek_tag
<
&
[
u8
]
&
[
u8
]
>
peek
!
(
tag
!
(
"
abcd
"
)
)
)
;
assert_eq
!
(
peek_tag
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
abcdef
"
[
.
.
]
&
b
"
abcd
"
[
.
.
]
)
)
)
;
assert_eq
!
(
peek_tag
(
&
b
"
ab
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
2
)
)
)
)
;
assert_eq
!
(
peek_tag
(
&
b
"
xxx
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
xxx
"
[
.
.
]
ErrorKind
:
:
Tag
)
)
)
)
;
}
#
[
test
]
fn
not
(
)
{
named
!
(
not_aaa
<
(
)
>
not
!
(
tag
!
(
"
aaa
"
)
)
)
;
assert_eq
!
(
not_aaa
(
&
b
"
aaa
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
aaa
"
[
.
.
]
ErrorKind
:
:
Not
)
)
)
)
;
assert_eq
!
(
not_aaa
(
&
b
"
aa
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
1
)
)
)
)
;
assert_eq
!
(
not_aaa
(
&
b
"
abcd
"
[
.
.
]
)
Ok
(
(
&
b
"
abcd
"
[
.
.
]
(
)
)
)
)
;
}
#
[
test
]
fn
verify
(
)
{
named
!
(
test
verify
!
(
take
!
(
5
)
|
slice
:
&
[
u8
]
|
slice
[
0
]
=
=
b
'
a
'
)
)
;
assert_eq
!
(
test
(
&
b
"
bcd
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
new
(
2
)
)
)
)
;
assert_eq
!
(
test
(
&
b
"
bcdefg
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
bcdefg
"
[
.
.
]
ErrorKind
:
:
Verify
)
)
)
)
;
assert_eq
!
(
test
(
&
b
"
abcdefg
"
[
.
.
]
)
Ok
(
(
&
b
"
fg
"
[
.
.
]
&
b
"
abcde
"
[
.
.
]
)
)
)
;
}
#
[
test
]
fn
parse_to
(
)
{
let
res
:
IResult
<
_
_
(
&
str
ErrorKind
)
>
=
parse_to
!
(
"
ab
"
usize
)
;
assert_eq
!
(
res
Err
(
Err
:
:
Error
(
error_position
!
(
"
ab
"
ErrorKind
:
:
ParseTo
)
)
)
)
;
let
res
:
IResult
<
_
_
(
&
str
ErrorKind
)
>
=
parse_to
!
(
"
42
"
usize
)
;
assert_eq
!
(
res
Ok
(
(
"
"
42
)
)
)
;
}
}
