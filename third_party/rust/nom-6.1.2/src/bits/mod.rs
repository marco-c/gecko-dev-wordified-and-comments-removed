#
[
macro_use
]
mod
macros
;
pub
mod
complete
;
pub
mod
streaming
;
use
crate
:
:
error
:
:
{
ErrorKind
ParseError
}
;
use
crate
:
:
internal
:
:
{
Err
IResult
Needed
}
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
RangeFrom
;
use
crate
:
:
traits
:
:
{
ErrorConvert
Slice
}
;
pub
fn
bits
<
I
O
E1
:
ParseError
<
(
I
usize
)
>
+
ErrorConvert
<
E2
>
E2
:
ParseError
<
I
>
P
>
(
mut
parser
:
P
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E2
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
P
:
FnMut
(
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
O
E1
>
{
move
|
input
:
I
|
match
parser
(
(
input
0
)
)
{
Ok
(
(
(
rest
offset
)
res
)
)
=
>
{
let
byte_index
=
offset
/
8
+
if
offset
%
8
=
=
0
{
0
}
else
{
1
}
;
Ok
(
(
rest
.
slice
(
byte_index
.
.
)
res
)
)
}
Err
(
Err
:
:
Incomplete
(
n
)
)
=
>
Err
(
Err
:
:
Incomplete
(
n
.
map
(
|
u
|
u
.
get
(
)
/
8
+
1
)
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
e
.
convert
(
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
.
convert
(
)
)
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
bitsc
<
I
O
E1
:
ParseError
<
(
I
usize
)
>
+
ErrorConvert
<
E2
>
E2
:
ParseError
<
I
>
P
>
(
input
:
I
parser
:
P
)
-
>
IResult
<
I
O
E2
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
P
:
FnMut
(
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
O
E1
>
{
bits
(
parser
)
(
input
)
}
pub
fn
bytes
<
I
O
E1
:
ParseError
<
I
>
+
ErrorConvert
<
E2
>
E2
:
ParseError
<
(
I
usize
)
>
P
>
(
mut
parser
:
P
)
-
>
impl
FnMut
(
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
O
E2
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
Clone
P
:
FnMut
(
I
)
-
>
IResult
<
I
O
E1
>
{
move
|
(
input
offset
)
:
(
I
usize
)
|
{
let
inner
=
if
offset
%
8
!
=
0
{
input
.
slice
(
(
1
+
offset
/
8
)
.
.
)
}
else
{
input
.
slice
(
(
offset
/
8
)
.
.
)
}
;
let
i
=
(
input
offset
)
;
match
parser
(
inner
)
{
Ok
(
(
rest
res
)
)
=
>
Ok
(
(
(
rest
0
)
res
)
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Unknown
)
)
=
>
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Unknown
)
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
sz
)
)
)
=
>
Err
(
match
sz
.
get
(
)
.
checked_mul
(
8
)
{
Some
(
v
)
=
>
Err
:
:
Incomplete
(
Needed
:
:
new
(
v
)
)
None
=
>
Err
:
:
Failure
(
E2
:
:
from_error_kind
(
i
ErrorKind
:
:
TooLarge
)
)
}
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
e
.
convert
(
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
.
convert
(
)
)
)
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
bytesc
<
I
O
E1
:
ParseError
<
I
>
+
ErrorConvert
<
E2
>
E2
:
ParseError
<
(
I
usize
)
>
P
>
(
input
:
(
I
usize
)
parser
:
P
)
-
>
IResult
<
(
I
usize
)
O
E2
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
Clone
P
:
FnMut
(
I
)
-
>
IResult
<
I
O
E1
>
{
bytes
(
parser
)
(
input
)
}
