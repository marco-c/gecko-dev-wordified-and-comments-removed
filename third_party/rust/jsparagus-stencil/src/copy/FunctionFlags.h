#
ifndef
vm_FunctionFlags_h
#
define
vm_FunctionFlags_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
class
JS_PUBLIC_API
JSAtom
;
namespace
js
{
class
FunctionFlags
{
public
:
enum
FunctionKind
:
uint8_t
{
NormalFunction
=
0
Arrow
Method
ClassConstructor
Getter
Setter
AsmJS
Wasm
FunctionKindLimit
}
;
enum
Flags
:
uint16_t
{
FUNCTION_KIND_SHIFT
=
0
FUNCTION_KIND_MASK
=
0x0007
EXTENDED
=
1
<
<
3
SELF_HOSTED
=
1
<
<
4
BASESCRIPT
=
1
<
<
5
SELFHOSTLAZY
=
1
<
<
6
CONSTRUCTOR
=
1
<
<
7
BOUND_FUN
=
1
<
<
8
LAMBDA
=
1
<
<
9
WASM_JIT_ENTRY
=
1
<
<
10
HAS_INFERRED_NAME
=
1
<
<
11
ATOM_EXTRA_FLAG
=
1
<
<
12
HAS_GUESSED_ATOM
=
ATOM_EXTRA_FLAG
HAS_BOUND_FUNCTION_NAME_PREFIX
=
ATOM_EXTRA_FLAG
RESOLVED_NAME
=
1
<
<
13
RESOLVED_LENGTH
=
1
<
<
14
NEW_SCRIPT_CLEARED
=
1
<
<
15
NORMAL_KIND
=
NormalFunction
<
<
FUNCTION_KIND_SHIFT
ASMJS_KIND
=
AsmJS
<
<
FUNCTION_KIND_SHIFT
WASM_KIND
=
Wasm
<
<
FUNCTION_KIND_SHIFT
ARROW_KIND
=
Arrow
<
<
FUNCTION_KIND_SHIFT
METHOD_KIND
=
Method
<
<
FUNCTION_KIND_SHIFT
CLASSCONSTRUCTOR_KIND
=
ClassConstructor
<
<
FUNCTION_KIND_SHIFT
GETTER_KIND
=
Getter
<
<
FUNCTION_KIND_SHIFT
SETTER_KIND
=
Setter
<
<
FUNCTION_KIND_SHIFT
NATIVE_FUN
=
NORMAL_KIND
NATIVE_CTOR
=
CONSTRUCTOR
|
NORMAL_KIND
ASMJS_CTOR
=
CONSTRUCTOR
|
ASMJS_KIND
ASMJS_LAMBDA_CTOR
=
CONSTRUCTOR
|
LAMBDA
|
ASMJS_KIND
WASM
=
WASM_KIND
INTERPRETED_NORMAL
=
BASESCRIPT
|
CONSTRUCTOR
|
NORMAL_KIND
INTERPRETED_CLASS_CTOR
=
BASESCRIPT
|
CONSTRUCTOR
|
CLASSCONSTRUCTOR_KIND
INTERPRETED_GENERATOR_OR_ASYNC
=
BASESCRIPT
|
NORMAL_KIND
INTERPRETED_LAMBDA
=
BASESCRIPT
|
LAMBDA
|
CONSTRUCTOR
|
NORMAL_KIND
INTERPRETED_LAMBDA_ARROW
=
BASESCRIPT
|
LAMBDA
|
ARROW_KIND
INTERPRETED_LAMBDA_GENERATOR_OR_ASYNC
=
BASESCRIPT
|
LAMBDA
|
NORMAL_KIND
INTERPRETED_GETTER
=
BASESCRIPT
|
GETTER_KIND
INTERPRETED_SETTER
=
BASESCRIPT
|
SETTER_KIND
INTERPRETED_METHOD
=
BASESCRIPT
|
METHOD_KIND
MUTABLE_FLAGS
=
RESOLVED_NAME
|
RESOLVED_LENGTH
|
NEW_SCRIPT_CLEARED
STABLE_ACROSS_CLONES
=
CONSTRUCTOR
|
LAMBDA
|
SELF_HOSTED
|
FUNCTION_KIND_MASK
}
;
uint16_t
flags_
;
public
:
FunctionFlags
(
)
:
flags_
(
)
{
static_assert
(
sizeof
(
FunctionFlags
)
=
=
sizeof
(
flags_
)
"
No
extra
members
allowed
is
it
'
ll
grow
JSFunction
"
)
;
static_assert
(
offsetof
(
FunctionFlags
flags_
)
=
=
0
"
Required
for
JIT
flag
access
"
)
;
}
explicit
FunctionFlags
(
uint16_t
flags
)
:
flags_
(
flags
)
{
}
MOZ_IMPLICIT
FunctionFlags
(
Flags
f
)
:
flags_
(
f
)
{
}
static_assert
(
(
(
FunctionKindLimit
-
1
)
<
<
FUNCTION_KIND_SHIFT
)
<
=
FUNCTION_KIND_MASK
"
FunctionKind
doesn
'
t
fit
into
flags_
"
)
;
uint16_t
toRaw
(
)
const
{
return
flags_
;
}
uint16_t
stableAcrossClones
(
)
const
{
return
flags_
&
STABLE_ACROSS_CLONES
;
}
bool
hasFlags
(
uint16_t
flags
)
const
{
return
flags_
&
flags
;
}
void
setFlags
(
uint16_t
flags
)
{
flags_
|
=
flags
;
}
void
clearFlags
(
uint16_t
flags
)
{
flags_
&
=
~
flags
;
}
void
setFlags
(
uint16_t
flags
bool
set
)
{
if
(
set
)
{
setFlags
(
flags
)
;
}
else
{
clearFlags
(
flags
)
;
}
}
FunctionKind
kind
(
)
const
{
return
static_cast
<
FunctionKind
>
(
(
flags_
&
FUNCTION_KIND_MASK
)
>
>
FUNCTION_KIND_SHIFT
)
;
}
bool
isInterpreted
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
|
|
hasFlags
(
SELFHOSTLAZY
)
;
}
bool
isNative
(
)
const
{
return
!
isInterpreted
(
)
;
}
bool
isConstructor
(
)
const
{
return
hasFlags
(
CONSTRUCTOR
)
;
}
bool
isNonBuiltinConstructor
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
&
&
hasFlags
(
CONSTRUCTOR
)
&
&
!
hasFlags
(
SELF_HOSTED
)
;
}
bool
isAsmJSNative
(
)
const
{
MOZ_ASSERT_IF
(
kind
(
)
=
=
AsmJS
isNative
(
)
)
;
return
kind
(
)
=
=
AsmJS
;
}
bool
isWasm
(
)
const
{
MOZ_ASSERT_IF
(
kind
(
)
=
=
Wasm
isNative
(
)
)
;
return
kind
(
)
=
=
Wasm
;
}
bool
isWasmWithJitEntry
(
)
const
{
MOZ_ASSERT_IF
(
hasFlags
(
WASM_JIT_ENTRY
)
isWasm
(
)
)
;
return
hasFlags
(
WASM_JIT_ENTRY
)
;
}
bool
isNativeWithoutJitEntry
(
)
const
{
MOZ_ASSERT_IF
(
!
hasJitEntry
(
)
isNative
(
)
)
;
return
!
hasJitEntry
(
)
;
}
bool
isBuiltinNative
(
)
const
{
return
isNative
(
)
&
&
!
isAsmJSNative
(
)
&
&
!
isWasm
(
)
;
}
bool
hasJitEntry
(
)
const
{
return
hasBaseScript
(
)
|
|
hasSelfHostedLazyScript
(
)
|
|
isWasmWithJitEntry
(
)
;
}
bool
isBoundFunction
(
)
const
{
return
hasFlags
(
BOUND_FUN
)
;
}
bool
hasInferredName
(
)
const
{
return
hasFlags
(
HAS_INFERRED_NAME
)
;
}
bool
hasGuessedAtom
(
)
const
{
static_assert
(
HAS_GUESSED_ATOM
=
=
HAS_BOUND_FUNCTION_NAME_PREFIX
"
HAS_GUESSED_ATOM
is
unused
for
bound
functions
"
)
;
bool
hasGuessedAtom
=
hasFlags
(
HAS_GUESSED_ATOM
)
;
bool
boundFun
=
hasFlags
(
BOUND_FUN
)
;
return
hasGuessedAtom
&
&
!
boundFun
;
}
bool
hasBoundFunctionNamePrefix
(
)
const
{
static_assert
(
HAS_BOUND_FUNCTION_NAME_PREFIX
=
=
HAS_GUESSED_ATOM
"
HAS_BOUND_FUNCTION_NAME_PREFIX
is
only
used
for
bound
functions
"
)
;
MOZ_ASSERT
(
isBoundFunction
(
)
)
;
return
hasFlags
(
HAS_BOUND_FUNCTION_NAME_PREFIX
)
;
}
bool
isLambda
(
)
const
{
return
hasFlags
(
LAMBDA
)
;
}
bool
isNamedLambda
(
bool
hasName
)
const
{
return
hasName
&
&
isLambda
(
)
&
&
!
hasInferredName
(
)
&
&
!
hasGuessedAtom
(
)
;
}
bool
hasBaseScript
(
)
const
{
return
hasFlags
(
BASESCRIPT
)
;
}
bool
hasSelfHostedLazyScript
(
)
const
{
return
hasFlags
(
SELFHOSTLAZY
)
;
}
bool
isArrow
(
)
const
{
return
kind
(
)
=
=
Arrow
;
}
bool
isMethod
(
)
const
{
return
kind
(
)
=
=
Method
|
|
kind
(
)
=
=
ClassConstructor
;
}
bool
isClassConstructor
(
)
const
{
return
kind
(
)
=
=
ClassConstructor
;
}
bool
isGetter
(
)
const
{
return
kind
(
)
=
=
Getter
;
}
bool
isSetter
(
)
const
{
return
kind
(
)
=
=
Setter
;
}
bool
allowSuperProperty
(
)
const
{
return
isMethod
(
)
|
|
isGetter
(
)
|
|
isSetter
(
)
;
}
bool
hasResolvedLength
(
)
const
{
return
hasFlags
(
RESOLVED_LENGTH
)
;
}
bool
hasResolvedName
(
)
const
{
return
hasFlags
(
RESOLVED_NAME
)
;
}
bool
isSelfHostedOrIntrinsic
(
)
const
{
return
hasFlags
(
SELF_HOSTED
)
;
}
bool
isSelfHostedBuiltin
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
!
isNative
(
)
;
}
bool
isIntrinsic
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
isNative
(
)
;
}
void
setKind
(
FunctionKind
kind
)
{
this
-
>
flags_
&
=
~
FUNCTION_KIND_MASK
;
this
-
>
flags_
|
=
static_cast
<
uint16_t
>
(
kind
)
<
<
FUNCTION_KIND_SHIFT
;
}
void
setIsConstructor
(
)
{
MOZ_ASSERT
(
!
isConstructor
(
)
)
;
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
setFlags
(
CONSTRUCTOR
)
;
}
void
setIsClassConstructor
(
)
{
MOZ_ASSERT
(
!
isClassConstructor
(
)
)
;
MOZ_ASSERT
(
isConstructor
(
)
)
;
setKind
(
ClassConstructor
)
;
}
void
setIsBoundFunction
(
)
{
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
setFlags
(
BOUND_FUN
)
;
}
void
setIsSelfHostedBuiltin
(
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
MOZ_ASSERT
(
!
isSelfHostedBuiltin
(
)
)
;
setFlags
(
SELF_HOSTED
)
;
clearFlags
(
CONSTRUCTOR
)
;
}
void
setIsIntrinsic
(
)
{
MOZ_ASSERT
(
isNative
(
)
)
;
MOZ_ASSERT
(
!
isIntrinsic
(
)
)
;
setFlags
(
SELF_HOSTED
)
;
}
void
setResolvedLength
(
)
{
setFlags
(
RESOLVED_LENGTH
)
;
}
void
setResolvedName
(
)
{
setFlags
(
RESOLVED_NAME
)
;
}
bool
wasNewScriptCleared
(
)
const
{
return
hasFlags
(
NEW_SCRIPT_CLEARED
)
;
}
void
setNewScriptCleared
(
)
{
setFlags
(
NEW_SCRIPT_CLEARED
)
;
}
void
setInferredName
(
)
{
setFlags
(
HAS_INFERRED_NAME
)
;
}
void
clearInferredName
(
)
{
clearFlags
(
HAS_INFERRED_NAME
)
;
}
void
setGuessedAtom
(
)
{
setFlags
(
HAS_GUESSED_ATOM
)
;
}
void
setPrefixedBoundFunctionName
(
)
{
setFlags
(
HAS_BOUND_FUNCTION_NAME_PREFIX
)
;
}
void
setSelfHostedLazy
(
)
{
setFlags
(
SELFHOSTLAZY
)
;
}
void
clearSelfHostedLazy
(
)
{
clearFlags
(
SELFHOSTLAZY
)
;
}
void
setBaseScript
(
)
{
setFlags
(
BASESCRIPT
)
;
}
void
clearBaseScript
(
)
{
clearFlags
(
BASESCRIPT
)
;
}
void
setWasmJitEntry
(
)
{
setFlags
(
WASM_JIT_ENTRY
)
;
}
bool
isExtended
(
)
const
{
return
hasFlags
(
EXTENDED
)
;
}
void
setIsExtended
(
)
{
setFlags
(
EXTENDED
)
;
}
bool
isNativeConstructor
(
)
const
{
return
hasFlags
(
NATIVE_CTOR
)
;
}
static
uint16_t
HasJitEntryFlags
(
bool
isConstructing
)
{
uint16_t
flags
=
BASESCRIPT
|
SELFHOSTLAZY
;
if
(
!
isConstructing
)
{
flags
|
=
WASM_JIT_ENTRY
;
}
return
flags
;
}
static
FunctionFlags
clearMutableflags
(
FunctionFlags
flags
)
{
return
FunctionFlags
(
flags
.
toRaw
(
)
&
~
FunctionFlags
:
:
MUTABLE_FLAGS
)
;
}
}
;
}
#
endif
