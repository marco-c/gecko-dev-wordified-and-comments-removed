use
crate
:
:
frame_slot
:
:
FrameSlot
;
use
crate
:
:
script
:
:
ScriptStencilIndex
;
use
ast
:
:
associated_data
:
:
AssociatedData
;
use
ast
:
:
source_atom_set
:
:
SourceAtomSetIndex
;
use
ast
:
:
source_location_accessor
:
:
SourceLocationAccessor
;
use
ast
:
:
type_id
:
:
NodeTypeIdAccessor
;
#
[
derive
(
Debug
Clone
Copy
PartialEq
)
]
pub
enum
BindingKind
{
Var
Let
Const
}
#
[
derive
(
Debug
)
]
pub
struct
BindingName
{
pub
name
:
SourceAtomSetIndex
pub
is_closed_over
:
bool
pub
is_top_level_function
:
bool
}
impl
BindingName
{
pub
fn
new
(
name
:
SourceAtomSetIndex
is_closed_over
:
bool
)
-
>
Self
{
Self
{
name
is_closed_over
is_top_level_function
:
false
}
}
pub
fn
new_top_level_function
(
name
:
SourceAtomSetIndex
is_closed_over
:
bool
)
-
>
Self
{
Self
{
name
is_closed_over
is_top_level_function
:
true
}
}
}
pub
struct
BindingIterItem
<
'
a
>
{
name
:
&
'
a
BindingName
kind
:
BindingKind
}
impl
<
'
a
>
BindingIterItem
<
'
a
>
{
fn
new
(
name
:
&
'
a
BindingName
kind
:
BindingKind
)
-
>
Self
{
Self
{
name
kind
}
}
pub
fn
name
(
&
self
)
-
>
SourceAtomSetIndex
{
self
.
name
.
name
}
pub
fn
is_top_level_function
(
&
self
)
-
>
bool
{
self
.
name
.
is_top_level_function
}
pub
fn
is_closed_over
(
&
self
)
-
>
bool
{
self
.
name
.
is_closed_over
}
pub
fn
kind
(
&
self
)
-
>
BindingKind
{
self
.
kind
}
}
pub
trait
MaybeBindingName
{
fn
is_closed_over
(
&
self
)
-
>
bool
;
}
impl
MaybeBindingName
for
BindingName
{
fn
is_closed_over
(
&
self
)
-
>
bool
{
self
.
is_closed_over
}
}
impl
MaybeBindingName
for
Option
<
BindingName
>
{
fn
is_closed_over
(
&
self
)
-
>
bool
{
match
self
{
Some
(
b
)
=
>
b
.
is_closed_over
None
=
>
false
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
BaseScopeData
<
BindingItemT
>
where
BindingItemT
:
MaybeBindingName
{
pub
bindings
:
Vec
<
BindingItemT
>
pub
has_eval
:
bool
pub
has_with
:
bool
}
impl
<
BindingItemT
>
BaseScopeData
<
BindingItemT
>
where
BindingItemT
:
MaybeBindingName
{
pub
fn
new
(
bindings_count
:
usize
)
-
>
Self
{
Self
{
bindings
:
Vec
:
:
with_capacity
(
bindings_count
)
has_eval
:
false
has_with
:
false
}
}
pub
fn
is_all_bindings_closed_over
(
&
self
)
-
>
bool
{
self
.
has_eval
|
|
self
.
has_with
}
pub
fn
needs_environment_object
(
&
self
)
-
>
bool
{
if
self
.
is_all_bindings_closed_over
(
)
{
return
true
;
}
for
binding
in
&
self
.
bindings
{
if
binding
.
is_closed_over
(
)
{
return
true
;
}
}
false
}
}
#
[
derive
(
Debug
)
]
pub
struct
GlobalScopeData
{
pub
base
:
BaseScopeData
<
BindingName
>
pub
let_start
:
usize
pub
const_start
:
usize
pub
functions
:
Vec
<
ScriptStencilIndex
>
}
impl
GlobalScopeData
{
pub
fn
new
(
var_count
:
usize
let_count
:
usize
const_count
:
usize
functions
:
Vec
<
ScriptStencilIndex
>
)
-
>
Self
{
let
capacity
=
var_count
+
let_count
+
const_count
;
Self
{
base
:
BaseScopeData
:
:
new
(
capacity
)
let_start
:
var_count
const_start
:
var_count
+
let_count
functions
}
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
GlobalBindingIter
<
'
a
>
{
GlobalBindingIter
:
:
new
(
self
)
}
}
pub
struct
GlobalBindingIter
<
'
a
>
{
data
:
&
'
a
GlobalScopeData
i
:
usize
}
impl
<
'
a
>
GlobalBindingIter
<
'
a
>
{
fn
new
(
data
:
&
'
a
GlobalScopeData
)
-
>
Self
{
Self
{
data
i
:
0
}
}
}
impl
<
'
a
>
Iterator
for
GlobalBindingIter
<
'
a
>
{
type
Item
=
BindingIterItem
<
'
a
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
BindingIterItem
<
'
a
>
>
{
if
self
.
i
=
=
self
.
data
.
base
.
bindings
.
len
(
)
{
return
None
;
}
let
kind
=
if
self
.
i
<
self
.
data
.
let_start
{
BindingKind
:
:
Var
}
else
if
self
.
i
<
self
.
data
.
const_start
{
BindingKind
:
:
Let
}
else
{
BindingKind
:
:
Const
}
;
let
name
=
&
self
.
data
.
base
.
bindings
[
self
.
i
]
;
self
.
i
+
=
1
;
Some
(
BindingIterItem
:
:
new
(
name
kind
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
VarScopeData
{
pub
base
:
BaseScopeData
<
BindingName
>
pub
first_frame_slot
:
FrameSlot
pub
function_has_extensible_scope
:
bool
pub
enclosing
:
ScopeIndex
}
impl
VarScopeData
{
pub
fn
new
(
var_count
:
usize
function_has_extensible_scope
:
bool
enclosing
:
ScopeIndex
)
-
>
Self
{
let
capacity
=
var_count
;
Self
{
base
:
BaseScopeData
:
:
new
(
capacity
)
first_frame_slot
:
FrameSlot
:
:
new
(
0
)
function_has_extensible_scope
enclosing
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
LexicalScopeData
{
pub
base
:
BaseScopeData
<
BindingName
>
pub
const_start
:
usize
pub
first_frame_slot
:
FrameSlot
pub
enclosing
:
ScopeIndex
pub
functions
:
Vec
<
ScriptStencilIndex
>
}
impl
LexicalScopeData
{
fn
new
(
let_count
:
usize
const_count
:
usize
enclosing
:
ScopeIndex
functions
:
Vec
<
ScriptStencilIndex
>
)
-
>
Self
{
let
capacity
=
let_count
+
const_count
;
Self
{
base
:
BaseScopeData
:
:
new
(
capacity
)
const_start
:
let_count
first_frame_slot
:
FrameSlot
:
:
new
(
0
)
enclosing
functions
}
}
pub
fn
new_block
(
let_count
:
usize
const_count
:
usize
enclosing
:
ScopeIndex
functions
:
Vec
<
ScriptStencilIndex
>
)
-
>
Self
{
Self
:
:
new
(
let_count
const_count
enclosing
functions
)
}
pub
fn
new_named_lambda
(
enclosing
:
ScopeIndex
)
-
>
Self
{
Self
:
:
new
(
0
1
enclosing
Vec
:
:
new
(
)
)
}
pub
fn
new_function_lexical
(
let_count
:
usize
const_count
:
usize
enclosing
:
ScopeIndex
)
-
>
Self
{
Self
:
:
new
(
let_count
const_count
enclosing
Vec
:
:
new
(
)
)
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
LexicalBindingIter
<
'
a
>
{
LexicalBindingIter
:
:
new
(
self
)
}
pub
fn
mark_annex_b_function
(
&
mut
self
name
:
SourceAtomSetIndex
original_binding_index
:
usize
)
{
let
binding_index
=
self
.
find_binding
(
name
original_binding_index
)
;
debug_assert
!
(
binding_index
<
self
.
const_start
)
;
self
.
const_start
-
=
1
;
self
.
base
.
bindings
.
remove
(
binding_index
)
;
}
fn
find_binding
(
&
self
name
:
SourceAtomSetIndex
original_binding_index
:
usize
)
-
>
usize
{
if
original_binding_index
<
self
.
base
.
bindings
.
len
(
)
{
let
binding
=
&
self
.
base
.
bindings
[
original_binding_index
]
;
if
binding
.
name
=
=
name
{
return
original_binding_index
;
}
}
for
(
i
binding
)
in
self
.
base
.
bindings
.
iter
(
)
.
enumerate
(
)
{
if
binding
.
name
=
=
name
{
return
i
;
}
}
panic
!
(
"
The
binding
should
exist
"
)
;
}
}
pub
struct
LexicalBindingIter
<
'
a
>
{
data
:
&
'
a
LexicalScopeData
i
:
usize
}
impl
<
'
a
>
LexicalBindingIter
<
'
a
>
{
fn
new
(
data
:
&
'
a
LexicalScopeData
)
-
>
Self
{
Self
{
data
i
:
0
}
}
}
impl
<
'
a
>
Iterator
for
LexicalBindingIter
<
'
a
>
{
type
Item
=
BindingIterItem
<
'
a
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
BindingIterItem
<
'
a
>
>
{
if
self
.
i
=
=
self
.
data
.
base
.
bindings
.
len
(
)
{
return
None
;
}
let
kind
=
if
self
.
i
<
self
.
data
.
const_start
{
BindingKind
:
:
Let
}
else
{
BindingKind
:
:
Const
}
;
let
name
=
&
self
.
data
.
base
.
bindings
[
self
.
i
]
;
self
.
i
+
=
1
;
Some
(
BindingIterItem
:
:
new
(
name
kind
)
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
FunctionScopeData
{
pub
base
:
BaseScopeData
<
Option
<
BindingName
>
>
pub
has_parameter_exprs
:
bool
pub
non_positional_formal_start
:
usize
pub
var_start
:
usize
pub
first_frame_slot
:
FrameSlot
pub
enclosing
:
ScopeIndex
pub
function_index
:
ScriptStencilIndex
}
impl
FunctionScopeData
{
pub
fn
new
(
has_parameter_exprs
:
bool
positional_parameter_count
:
usize
non_positional_formal_start
:
usize
max_var_count
:
usize
enclosing
:
ScopeIndex
function_index
:
ScriptStencilIndex
)
-
>
Self
{
let
capacity
=
positional_parameter_count
+
non_positional_formal_start
+
max_var_count
;
Self
{
base
:
BaseScopeData
:
:
new
(
capacity
)
has_parameter_exprs
non_positional_formal_start
:
positional_parameter_count
var_start
:
positional_parameter_count
+
non_positional_formal_start
first_frame_slot
:
FrameSlot
:
:
new
(
0
)
enclosing
function_index
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
ScopeData
{
Alias
(
ScopeIndex
)
Global
(
GlobalScopeData
)
Var
(
VarScopeData
)
Lexical
(
LexicalScopeData
)
Function
(
FunctionScopeData
)
}
#
[
derive
(
Debug
Clone
Copy
PartialEq
)
]
pub
struct
ScopeIndex
{
index
:
usize
}
impl
ScopeIndex
{
fn
new
(
index
:
usize
)
-
>
Self
{
Self
{
index
}
}
pub
fn
next
(
&
self
)
-
>
Self
{
Self
{
index
:
self
.
index
+
1
}
}
}
impl
From
<
ScopeIndex
>
for
usize
{
fn
from
(
index
:
ScopeIndex
)
-
>
usize
{
index
.
index
}
}
#
[
derive
(
Debug
)
]
pub
struct
ScopeDataList
{
scopes
:
Vec
<
Option
<
ScopeData
>
>
}
impl
ScopeDataList
{
pub
fn
new
(
)
-
>
Self
{
Self
{
scopes
:
Vec
:
:
new
(
)
}
}
pub
fn
push
(
&
mut
self
scope
:
ScopeData
)
-
>
ScopeIndex
{
let
index
=
self
.
scopes
.
len
(
)
;
self
.
scopes
.
push
(
Some
(
scope
)
)
;
ScopeIndex
:
:
new
(
index
)
}
pub
fn
allocate
(
&
mut
self
)
-
>
ScopeIndex
{
let
index
=
self
.
scopes
.
len
(
)
;
self
.
scopes
.
push
(
None
)
;
ScopeIndex
:
:
new
(
index
)
}
pub
fn
populate
(
&
mut
self
index
:
ScopeIndex
scope
:
ScopeData
)
{
self
.
scopes
[
usize
:
:
from
(
index
)
]
.
replace
(
scope
)
;
}
fn
get
(
&
self
index
:
ScopeIndex
)
-
>
&
ScopeData
{
self
.
scopes
[
usize
:
:
from
(
index
)
]
.
as_ref
(
)
.
expect
(
"
Should
be
populated
"
)
}
pub
fn
get_mut
(
&
mut
self
index
:
ScopeIndex
)
-
>
&
mut
ScopeData
{
self
.
scopes
[
usize
:
:
from
(
index
)
]
.
as_mut
(
)
.
expect
(
"
Should
be
populated
"
)
}
}
impl
From
<
ScopeDataList
>
for
Vec
<
ScopeData
>
{
fn
from
(
list
:
ScopeDataList
)
-
>
Vec
<
ScopeData
>
{
list
.
scopes
.
into_iter
(
)
.
map
(
|
g
|
g
.
expect
(
"
Should
be
populated
"
)
)
.
collect
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
ScopeDataMap
{
scopes
:
ScopeDataList
global
:
ScopeIndex
non_global
:
AssociatedData
<
ScopeIndex
>
}
impl
ScopeDataMap
{
pub
fn
new
(
scopes
:
ScopeDataList
global
:
ScopeIndex
non_global
:
AssociatedData
<
ScopeIndex
>
)
-
>
Self
{
Self
{
scopes
global
non_global
}
}
pub
fn
get_global_index
(
&
self
)
-
>
ScopeIndex
{
self
.
global
}
pub
fn
get_global_at
(
&
self
index
:
ScopeIndex
)
-
>
&
GlobalScopeData
{
match
self
.
scopes
.
get
(
index
)
{
ScopeData
:
:
Global
(
scope
)
=
>
scope
_
=
>
panic
!
(
"
Unexpected
scope
data
for
global
"
)
}
}
pub
fn
get_index
<
NodeT
>
(
&
self
node
:
&
NodeT
)
-
>
ScopeIndex
where
NodeT
:
SourceLocationAccessor
+
NodeTypeIdAccessor
{
self
.
non_global
.
get
(
node
)
.
expect
(
"
There
should
be
a
scope
data
associated
"
)
.
clone
(
)
}
pub
fn
get_lexical_at
(
&
self
index
:
ScopeIndex
)
-
>
&
LexicalScopeData
{
match
self
.
scopes
.
get
(
index
)
{
ScopeData
:
:
Lexical
(
scope
)
=
>
scope
_
=
>
panic
!
(
"
Unexpected
scope
data
for
lexical
"
)
}
}
pub
fn
get_lexical_at_mut
(
&
mut
self
index
:
ScopeIndex
)
-
>
&
mut
LexicalScopeData
{
match
self
.
scopes
.
get_mut
(
index
)
{
ScopeData
:
:
Lexical
(
scope
)
=
>
scope
_
=
>
panic
!
(
"
Unexpected
scope
data
for
lexical
"
)
}
}
pub
fn
get_function_at_mut
(
&
mut
self
index
:
ScopeIndex
)
-
>
&
mut
FunctionScopeData
{
match
self
.
scopes
.
get_mut
(
index
)
{
ScopeData
:
:
Function
(
scope
)
=
>
scope
_
=
>
panic
!
(
"
Unexpected
scope
data
for
function
"
)
}
}
pub
fn
is_alias
(
&
mut
self
index
:
ScopeIndex
)
-
>
bool
{
match
self
.
scopes
.
get
(
index
)
{
ScopeData
:
:
Alias
(
_
)
=
>
true
_
=
>
false
}
}
}
impl
From
<
ScopeDataMap
>
for
Vec
<
ScopeData
>
{
fn
from
(
map
:
ScopeDataMap
)
-
>
Vec
<
ScopeData
>
{
map
.
scopes
.
into
(
)
}
}
