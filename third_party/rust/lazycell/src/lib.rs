#
!
[
deny
(
missing_docs
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
plugin
)
)
]
#
!
[
cfg_attr
(
feature
=
"
clippy
"
plugin
(
clippy
)
)
]
use
std
:
:
cell
:
:
UnsafeCell
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
#
[
derive
(
Debug
Default
)
]
pub
struct
LazyCell
<
T
>
{
inner
:
UnsafeCell
<
Option
<
T
>
>
}
impl
<
T
>
LazyCell
<
T
>
{
pub
fn
new
(
)
-
>
LazyCell
<
T
>
{
LazyCell
{
inner
:
UnsafeCell
:
:
new
(
None
)
}
}
pub
fn
fill
(
&
self
value
:
T
)
-
>
Result
<
(
)
T
>
{
let
mut
slot
=
unsafe
{
&
mut
*
self
.
inner
.
get
(
)
}
;
if
slot
.
is_some
(
)
{
return
Err
(
value
)
;
}
*
slot
=
Some
(
value
)
;
Ok
(
(
)
)
}
pub
fn
filled
(
&
self
)
-
>
bool
{
self
.
borrow
(
)
.
is_some
(
)
}
pub
fn
borrow
(
&
self
)
-
>
Option
<
&
T
>
{
unsafe
{
&
*
self
.
inner
.
get
(
)
}
.
as_ref
(
)
}
pub
fn
borrow_mut
(
&
mut
self
)
-
>
Option
<
&
mut
T
>
{
unsafe
{
&
mut
*
self
.
inner
.
get
(
)
}
.
as_mut
(
)
}
pub
fn
borrow_with
<
F
:
FnOnce
(
)
-
>
T
>
(
&
self
f
:
F
)
-
>
&
T
{
if
let
Some
(
value
)
=
self
.
borrow
(
)
{
return
value
;
}
let
value
=
f
(
)
;
if
self
.
fill
(
value
)
.
is_err
(
)
{
panic
!
(
"
borrow_with
:
cell
was
filled
by
closure
"
)
}
self
.
borrow
(
)
.
unwrap
(
)
}
pub
fn
try_borrow_with
<
E
F
>
(
&
self
f
:
F
)
-
>
Result
<
&
T
E
>
where
F
:
FnOnce
(
)
-
>
Result
<
T
E
>
{
if
let
Some
(
value
)
=
self
.
borrow
(
)
{
return
Ok
(
value
)
;
}
let
value
=
f
(
)
?
;
if
self
.
fill
(
value
)
.
is_err
(
)
{
panic
!
(
"
try_borrow_with
:
cell
was
filled
by
closure
"
)
}
Ok
(
self
.
borrow
(
)
.
unwrap
(
)
)
}
pub
fn
into_inner
(
self
)
-
>
Option
<
T
>
{
unsafe
{
self
.
inner
.
into_inner
(
)
}
}
}
impl
<
T
:
Copy
>
LazyCell
<
T
>
{
pub
fn
get
(
&
self
)
-
>
Option
<
T
>
{
unsafe
{
*
self
.
inner
.
get
(
)
}
}
}
const
NONE
:
usize
=
0
;
const
LOCK
:
usize
=
1
;
const
SOME
:
usize
=
2
;
#
[
derive
(
Debug
Default
)
]
pub
struct
AtomicLazyCell
<
T
>
{
inner
:
UnsafeCell
<
Option
<
T
>
>
state
:
AtomicUsize
}
impl
<
T
>
AtomicLazyCell
<
T
>
{
pub
fn
new
(
)
-
>
AtomicLazyCell
<
T
>
{
AtomicLazyCell
{
inner
:
UnsafeCell
:
:
new
(
None
)
state
:
AtomicUsize
:
:
new
(
NONE
)
}
}
pub
fn
fill
(
&
self
t
:
T
)
-
>
Result
<
(
)
T
>
{
if
NONE
!
=
self
.
state
.
compare_and_swap
(
NONE
LOCK
Ordering
:
:
Acquire
)
{
return
Err
(
t
)
;
}
unsafe
{
*
self
.
inner
.
get
(
)
=
Some
(
t
)
}
;
if
LOCK
!
=
self
.
state
.
compare_and_swap
(
LOCK
SOME
Ordering
:
:
Release
)
{
panic
!
(
"
unable
to
release
lock
"
)
;
}
Ok
(
(
)
)
}
pub
fn
filled
(
&
self
)
-
>
bool
{
self
.
state
.
load
(
Ordering
:
:
Acquire
)
=
=
SOME
}
pub
fn
borrow
(
&
self
)
-
>
Option
<
&
T
>
{
match
self
.
state
.
load
(
Ordering
:
:
Acquire
)
{
SOME
=
>
unsafe
{
&
*
self
.
inner
.
get
(
)
}
.
as_ref
(
)
_
=
>
None
}
}
pub
fn
into_inner
(
self
)
-
>
Option
<
T
>
{
unsafe
{
self
.
inner
.
into_inner
(
)
}
}
}
impl
<
T
:
Copy
>
AtomicLazyCell
<
T
>
{
pub
fn
get
(
&
self
)
-
>
Option
<
T
>
{
match
self
.
state
.
load
(
Ordering
:
:
Acquire
)
{
SOME
=
>
unsafe
{
*
self
.
inner
.
get
(
)
}
_
=
>
None
}
}
}
unsafe
impl
<
T
:
Sync
+
Send
>
Sync
for
AtomicLazyCell
<
T
>
{
}
unsafe
impl
<
T
:
Send
>
Send
for
AtomicLazyCell
<
T
>
{
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
AtomicLazyCell
LazyCell
}
;
#
[
test
]
fn
test_borrow_from_empty
(
)
{
let
lazycell
:
LazyCell
<
usize
>
=
LazyCell
:
:
new
(
)
;
let
value
=
lazycell
.
borrow
(
)
;
assert_eq
!
(
value
None
)
;
let
value
=
lazycell
.
get
(
)
;
assert_eq
!
(
value
None
)
;
}
#
[
test
]
fn
test_fill_and_borrow
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
assert
!
(
!
lazycell
.
filled
(
)
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
assert
!
(
lazycell
.
filled
(
)
)
;
let
value
=
lazycell
.
borrow
(
)
;
assert_eq
!
(
value
Some
(
&
1
)
)
;
let
value
=
lazycell
.
get
(
)
;
assert_eq
!
(
value
Some
(
1
)
)
;
}
#
[
test
]
fn
test_borrow_mut
(
)
{
let
mut
lazycell
=
LazyCell
:
:
new
(
)
;
assert
!
(
lazycell
.
borrow_mut
(
)
.
is_none
(
)
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
assert_eq
!
(
lazycell
.
borrow_mut
(
)
Some
(
&
mut
1
)
)
;
*
lazycell
.
borrow_mut
(
)
.
unwrap
(
)
=
2
;
assert_eq
!
(
lazycell
.
borrow_mut
(
)
Some
(
&
mut
2
)
)
;
lazycell
=
LazyCell
:
:
new
(
)
;
assert
!
(
lazycell
.
borrow_mut
(
)
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_already_filled_error
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
assert_eq
!
(
lazycell
.
fill
(
1
)
Err
(
1
)
)
;
}
#
[
test
]
fn
test_borrow_with
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
let
value
=
lazycell
.
borrow_with
(
|
|
1
)
;
assert_eq
!
(
&
1
value
)
;
}
#
[
test
]
fn
test_borrow_with_already_filled
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
let
value
=
lazycell
.
borrow_with
(
|
|
1
)
;
assert_eq
!
(
&
1
value
)
;
}
#
[
test
]
fn
test_borrow_with_not_called_when_filled
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
let
value
=
lazycell
.
borrow_with
(
|
|
2
)
;
assert_eq
!
(
&
1
value
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_borrow_with_sound_with_reentrancy
(
)
{
let
lazycell
:
LazyCell
<
Box
<
i32
>
>
=
LazyCell
:
:
new
(
)
;
let
mut
reference
:
Option
<
&
i32
>
=
None
;
lazycell
.
borrow_with
(
|
|
{
let
_
=
lazycell
.
fill
(
Box
:
:
new
(
1
)
)
;
reference
=
lazycell
.
borrow
(
)
.
map
(
|
r
|
&
*
*
r
)
;
Box
:
:
new
(
2
)
}
)
;
}
#
[
test
]
fn
test_try_borrow_with_ok
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
let
result
=
lazycell
.
try_borrow_with
:
:
<
(
)
_
>
(
|
|
Ok
(
1
)
)
;
assert_eq
!
(
result
Ok
(
&
1
)
)
;
}
#
[
test
]
fn
test_try_borrow_with_err
(
)
{
let
lazycell
=
LazyCell
:
:
<
(
)
>
:
:
new
(
)
;
let
result
=
lazycell
.
try_borrow_with
(
|
|
Err
(
1
)
)
;
assert_eq
!
(
result
Err
(
1
)
)
;
}
#
[
test
]
fn
test_try_borrow_with_already_filled
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
let
result
=
lazycell
.
try_borrow_with
:
:
<
(
)
_
>
(
|
|
unreachable
!
(
)
)
;
assert_eq
!
(
result
Ok
(
&
1
)
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_try_borrow_with_sound_with_reentrancy
(
)
{
let
lazycell
:
LazyCell
<
Box
<
i32
>
>
=
LazyCell
:
:
new
(
)
;
let
mut
reference
:
Option
<
&
i32
>
=
None
;
let
_
=
lazycell
.
try_borrow_with
:
:
<
(
)
_
>
(
|
|
{
let
_
=
lazycell
.
fill
(
Box
:
:
new
(
1
)
)
;
reference
=
lazycell
.
borrow
(
)
.
map
(
|
r
|
&
*
*
r
)
;
Ok
(
Box
:
:
new
(
2
)
)
}
)
;
}
#
[
test
]
fn
test_into_inner
(
)
{
let
lazycell
=
LazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
let
value
=
lazycell
.
into_inner
(
)
;
assert_eq
!
(
value
Some
(
1
)
)
;
}
#
[
test
]
fn
test_atomic_borrow_from_empty
(
)
{
let
lazycell
:
AtomicLazyCell
<
usize
>
=
AtomicLazyCell
:
:
new
(
)
;
let
value
=
lazycell
.
borrow
(
)
;
assert_eq
!
(
value
None
)
;
let
value
=
lazycell
.
get
(
)
;
assert_eq
!
(
value
None
)
;
}
#
[
test
]
fn
test_atomic_fill_and_borrow
(
)
{
let
lazycell
=
AtomicLazyCell
:
:
new
(
)
;
assert
!
(
!
lazycell
.
filled
(
)
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
assert
!
(
lazycell
.
filled
(
)
)
;
let
value
=
lazycell
.
borrow
(
)
;
assert_eq
!
(
value
Some
(
&
1
)
)
;
let
value
=
lazycell
.
get
(
)
;
assert_eq
!
(
value
Some
(
1
)
)
;
}
#
[
test
]
fn
test_atomic_already_filled_panic
(
)
{
let
lazycell
=
AtomicLazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
assert_eq
!
(
1
lazycell
.
fill
(
1
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
test_atomic_into_inner
(
)
{
let
lazycell
=
AtomicLazyCell
:
:
new
(
)
;
lazycell
.
fill
(
1
)
.
unwrap
(
)
;
let
value
=
lazycell
.
into_inner
(
)
;
assert_eq
!
(
value
Some
(
1
)
)
;
}
}
