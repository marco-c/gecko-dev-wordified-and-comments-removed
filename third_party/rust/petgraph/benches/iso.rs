#
!
[
feature
(
test
)
]
extern
crate
test
;
extern
crate
petgraph
;
use
petgraph
:
:
prelude
:
:
*
;
use
petgraph
:
:
{
EdgeType
}
;
use
petgraph
:
:
graph
:
:
{
node_index
}
;
const
PETERSEN_A
:
&
'
static
str
=
"
0
1
0
0
1
0
1
0
0
0
1
0
1
0
0
0
0
1
0
0
0
1
0
1
0
0
0
0
1
0
0
0
1
0
1
0
0
0
0
1
1
0
0
1
0
1
0
0
0
0
0
0
0
0
1
0
0
1
1
0
1
0
0
0
0
0
0
0
1
1
0
1
0
0
0
1
0
0
0
1
0
0
1
0
0
1
1
0
0
0
0
0
0
1
0
0
1
1
0
0
"
;
const
PETERSEN_B
:
&
'
static
str
=
"
0
0
0
1
0
1
0
0
0
1
0
0
0
1
1
0
1
0
0
0
0
0
0
0
0
0
1
1
0
1
1
1
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
1
1
1
0
0
0
0
0
1
0
1
0
0
1
1
0
0
1
0
0
0
0
0
0
1
1
0
0
0
0
1
0
0
0
0
0
1
1
0
1
0
0
1
0
1
0
1
0
0
0
0
0
"
;
const
FULL_A
:
&
'
static
str
=
"
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
1
1
1
0
1
1
1
1
1
1
1
1
1
1
1
"
;
const
FULL_B
:
&
'
static
str
=
"
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
1
1
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
"
;
const
PRAUST_A
:
&
'
static
str
=
"
0
1
1
1
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
1
0
1
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
1
1
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
1
0
1
1
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
1
1
0
1
0
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
1
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
0
1
1
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
1
1
0
1
0
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
1
1
1
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
0
1
1
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
1
1
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
1
0
"
;
const
PRAUST_B
:
&
'
static
str
=
"
0
1
1
1
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
1
0
1
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
1
0
1
1
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
1
1
0
1
0
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
0
0
1
0
1
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
1
1
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
1
0
0
1
0
1
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
0
1
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
1
0
1
1
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
1
0
1
0
0
1
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
1
0
1
0
0
1
1
0
"
;
fn
parse_graph
<
Ty
:
EdgeType
>
(
s
:
&
str
)
-
>
Graph
<
(
)
(
)
Ty
>
{
let
mut
gr
=
Graph
:
:
with_capacity
(
0
0
)
;
let
s
=
s
.
trim
(
)
;
let
lines
=
s
.
lines
(
)
.
filter
(
|
l
|
!
l
.
is_empty
(
)
)
;
for
(
row
line
)
in
lines
.
enumerate
(
)
{
for
(
col
word
)
in
line
.
split
(
'
'
)
.
filter
(
|
s
|
s
.
len
(
)
>
0
)
.
enumerate
(
)
{
let
has_edge
=
word
.
parse
:
:
<
i32
>
(
)
.
unwrap
(
)
;
assert
!
(
has_edge
=
=
0
|
|
has_edge
=
=
1
)
;
if
has_edge
=
=
0
{
continue
;
}
while
col
>
=
gr
.
node_count
(
)
|
|
row
>
=
gr
.
node_count
(
)
{
gr
.
add_node
(
(
)
)
;
}
gr
.
update_edge
(
node_index
(
row
)
node_index
(
col
)
(
)
)
;
}
}
gr
}
fn
str_to_graph
(
s
:
&
str
)
-
>
Graph
<
(
)
(
)
Undirected
>
{
parse_graph
(
s
)
}
fn
str_to_digraph
(
s
:
&
str
)
-
>
Graph
<
(
)
(
)
Directed
>
{
parse_graph
(
s
)
}
#
[
bench
]
fn
petersen_iso_bench
(
bench
:
&
mut
test
:
:
Bencher
)
{
let
a
=
str_to_digraph
(
PETERSEN_A
)
;
let
b
=
str_to_digraph
(
PETERSEN_B
)
;
bench
.
iter
(
|
|
petgraph
:
:
algo
:
:
is_isomorphic
(
&
a
&
b
)
)
;
}
#
[
bench
]
fn
petersen_undir_iso_bench
(
bench
:
&
mut
test
:
:
Bencher
)
{
let
a
=
str_to_graph
(
PETERSEN_A
)
;
let
b
=
str_to_graph
(
PETERSEN_B
)
;
bench
.
iter
(
|
|
petgraph
:
:
algo
:
:
is_isomorphic
(
&
a
&
b
)
)
;
}
#
[
bench
]
fn
full_iso_bench
(
bench
:
&
mut
test
:
:
Bencher
)
{
let
a
=
str_to_graph
(
FULL_A
)
;
let
b
=
str_to_graph
(
FULL_B
)
;
bench
.
iter
(
|
|
petgraph
:
:
algo
:
:
is_isomorphic
(
&
a
&
b
)
)
;
}
#
[
bench
]
fn
praust_dir_no_iso_bench
(
bench
:
&
mut
test
:
:
Bencher
)
{
let
a
=
str_to_digraph
(
PRAUST_A
)
;
let
b
=
str_to_digraph
(
PRAUST_B
)
;
bench
.
iter
(
|
|
petgraph
:
:
algo
:
:
is_isomorphic
(
&
a
&
b
)
)
;
}
#
[
bench
]
fn
praust_undir_no_iso_bench
(
bench
:
&
mut
test
:
:
Bencher
)
{
let
a
=
str_to_graph
(
PRAUST_A
)
;
let
b
=
str_to_graph
(
PRAUST_B
)
;
bench
.
iter
(
|
|
petgraph
:
:
algo
:
:
is_isomorphic
(
&
a
&
b
)
)
;
}
#
[
bench
]
fn
bench_praust_mst
(
bb
:
&
mut
test
:
:
Bencher
)
{
let
a
=
str_to_digraph
(
PRAUST_A
)
;
let
b
=
str_to_digraph
(
PRAUST_B
)
;
bb
.
iter
(
|
|
{
(
petgraph
:
:
algo
:
:
min_spanning_tree
(
&
a
)
petgraph
:
:
algo
:
:
min_spanning_tree
(
&
b
)
)
}
)
;
}
