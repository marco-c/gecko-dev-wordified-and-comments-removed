use
std
:
:
marker
;
use
fixedbitset
:
:
FixedBitSet
;
use
super
:
:
{
EdgeType
Incoming
}
;
use
super
:
:
graph
:
:
{
Graph
IndexType
NodeIndex
}
;
use
super
:
:
visit
:
:
GetAdjacencyMatrix
;
#
[
derive
(
Debug
)
]
struct
Vf2State
<
Ty
Ix
>
{
mapping
:
Vec
<
NodeIndex
<
Ix
>
>
out
:
Vec
<
usize
>
ins
:
Vec
<
usize
>
out_size
:
usize
ins_size
:
usize
adjacency_matrix
:
FixedBitSet
generation
:
usize
_etype
:
marker
:
:
PhantomData
<
Ty
>
}
impl
<
Ty
Ix
>
Vf2State
<
Ty
Ix
>
where
Ty
:
EdgeType
Ix
:
IndexType
{
pub
fn
new
<
N
E
>
(
g
:
&
Graph
<
N
E
Ty
Ix
>
)
-
>
Self
{
let
c0
=
g
.
node_count
(
)
;
let
mut
state
=
Vf2State
{
mapping
:
Vec
:
:
with_capacity
(
c0
)
out
:
Vec
:
:
with_capacity
(
c0
)
ins
:
Vec
:
:
with_capacity
(
c0
*
(
g
.
is_directed
(
)
as
usize
)
)
out_size
:
0
ins_size
:
0
adjacency_matrix
:
g
.
adjacency_matrix
(
)
generation
:
0
_etype
:
marker
:
:
PhantomData
}
;
for
_
in
0
.
.
c0
{
state
.
mapping
.
push
(
NodeIndex
:
:
end
(
)
)
;
state
.
out
.
push
(
0
)
;
if
Ty
:
:
is_directed
(
)
{
state
.
ins
.
push
(
0
)
;
}
}
state
}
pub
fn
is_complete
(
&
self
)
-
>
bool
{
self
.
generation
=
=
self
.
mapping
.
len
(
)
}
pub
fn
push_mapping
<
N
E
>
(
&
mut
self
from
:
NodeIndex
<
Ix
>
to
:
NodeIndex
<
Ix
>
g
:
&
Graph
<
N
E
Ty
Ix
>
)
{
self
.
generation
+
=
1
;
let
s
=
self
.
generation
;
self
.
mapping
[
from
.
index
(
)
]
=
to
;
for
ix
in
g
.
neighbors
(
from
)
{
if
self
.
out
[
ix
.
index
(
)
]
=
=
0
{
self
.
out
[
ix
.
index
(
)
]
=
s
;
self
.
out_size
+
=
1
;
}
}
if
g
.
is_directed
(
)
{
for
ix
in
g
.
neighbors_directed
(
from
Incoming
)
{
if
self
.
ins
[
ix
.
index
(
)
]
=
=
0
{
self
.
ins
[
ix
.
index
(
)
]
=
s
;
self
.
ins_size
+
=
1
;
}
}
}
}
pub
fn
pop_mapping
<
N
E
>
(
&
mut
self
from
:
NodeIndex
<
Ix
>
g
:
&
Graph
<
N
E
Ty
Ix
>
)
{
let
s
=
self
.
generation
;
self
.
generation
-
=
1
;
self
.
mapping
[
from
.
index
(
)
]
=
NodeIndex
:
:
end
(
)
;
for
ix
in
g
.
neighbors
(
from
)
{
if
self
.
out
[
ix
.
index
(
)
]
=
=
s
{
self
.
out
[
ix
.
index
(
)
]
=
0
;
self
.
out_size
-
=
1
;
}
}
if
g
.
is_directed
(
)
{
for
ix
in
g
.
neighbors_directed
(
from
Incoming
)
{
if
self
.
ins
[
ix
.
index
(
)
]
=
=
s
{
self
.
ins
[
ix
.
index
(
)
]
=
0
;
self
.
ins_size
-
=
1
;
}
}
}
}
pub
fn
next_out_index
(
&
self
from_index
:
usize
)
-
>
Option
<
usize
>
{
self
.
out
[
from_index
.
.
]
.
iter
(
)
.
enumerate
(
)
.
find
(
move
|
&
(
index
elt
)
|
*
elt
>
0
&
&
self
.
mapping
[
from_index
+
index
]
=
=
NodeIndex
:
:
end
(
)
)
.
map
(
|
(
index
_
)
|
index
)
}
pub
fn
next_in_index
(
&
self
from_index
:
usize
)
-
>
Option
<
usize
>
{
if
!
Ty
:
:
is_directed
(
)
{
return
None
}
self
.
ins
[
from_index
.
.
]
.
iter
(
)
.
enumerate
(
)
.
find
(
move
|
&
(
index
elt
)
|
*
elt
>
0
&
&
self
.
mapping
[
from_index
+
index
]
=
=
NodeIndex
:
:
end
(
)
)
.
map
(
|
(
index
_
)
|
index
)
}
pub
fn
next_rest_index
(
&
self
from_index
:
usize
)
-
>
Option
<
usize
>
{
self
.
mapping
[
from_index
.
.
]
.
iter
(
)
.
enumerate
(
)
.
find
(
|
&
(
_
elt
)
|
*
elt
=
=
NodeIndex
:
:
end
(
)
)
.
map
(
|
(
index
_
)
|
index
)
}
}
pub
fn
is_isomorphic
<
N
E
Ty
Ix
>
(
g0
:
&
Graph
<
N
E
Ty
Ix
>
g1
:
&
Graph
<
N
E
Ty
Ix
>
)
-
>
bool
where
Ty
:
EdgeType
Ix
:
IndexType
{
if
g0
.
node_count
(
)
!
=
g1
.
node_count
(
)
|
|
g0
.
edge_count
(
)
!
=
g1
.
edge_count
(
)
{
return
false
}
let
mut
st
=
[
Vf2State
:
:
new
(
g0
)
Vf2State
:
:
new
(
g1
)
]
;
try_match
(
&
mut
st
g0
g1
&
mut
NoSemanticMatch
&
mut
NoSemanticMatch
)
.
unwrap_or
(
false
)
}
pub
fn
is_isomorphic_matching
<
N
E
Ty
Ix
F
G
>
(
g0
:
&
Graph
<
N
E
Ty
Ix
>
g1
:
&
Graph
<
N
E
Ty
Ix
>
mut
node_match
:
F
mut
edge_match
:
G
)
-
>
bool
where
Ty
:
EdgeType
Ix
:
IndexType
F
:
FnMut
(
&
N
&
N
)
-
>
bool
G
:
FnMut
(
&
E
&
E
)
-
>
bool
{
if
g0
.
node_count
(
)
!
=
g1
.
node_count
(
)
|
|
g0
.
edge_count
(
)
!
=
g1
.
edge_count
(
)
{
return
false
}
let
mut
st
=
[
Vf2State
:
:
new
(
g0
)
Vf2State
:
:
new
(
g1
)
]
;
try_match
(
&
mut
st
g0
g1
&
mut
node_match
&
mut
edge_match
)
.
unwrap_or
(
false
)
}
trait
SemanticMatcher
<
T
>
{
fn
enabled
(
)
-
>
bool
;
fn
eq
(
&
mut
self
&
T
&
T
)
-
>
bool
;
}
struct
NoSemanticMatch
;
impl
<
T
>
SemanticMatcher
<
T
>
for
NoSemanticMatch
{
#
[
inline
]
fn
enabled
(
)
-
>
bool
{
false
}
#
[
inline
]
fn
eq
(
&
mut
self
_
:
&
T
_
:
&
T
)
-
>
bool
{
true
}
}
impl
<
T
F
>
SemanticMatcher
<
T
>
for
F
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
#
[
inline
]
fn
enabled
(
)
-
>
bool
{
true
}
#
[
inline
]
fn
eq
(
&
mut
self
a
:
&
T
b
:
&
T
)
-
>
bool
{
self
(
a
b
)
}
}
fn
try_match
<
N
E
Ty
Ix
F
G
>
(
st
:
&
mut
[
Vf2State
<
Ty
Ix
>
;
2
]
g0
:
&
Graph
<
N
E
Ty
Ix
>
g1
:
&
Graph
<
N
E
Ty
Ix
>
node_match
:
&
mut
F
edge_match
:
&
mut
G
)
-
>
Option
<
bool
>
where
Ty
:
EdgeType
Ix
:
IndexType
F
:
SemanticMatcher
<
N
>
G
:
SemanticMatcher
<
E
>
{
let
g
=
[
g0
g1
]
;
let
graph_indices
=
0
.
.
2
;
let
end
=
NodeIndex
:
:
end
(
)
;
if
st
[
0
]
.
is_complete
(
)
{
return
Some
(
true
)
}
#
[
derive
(
Copy
Clone
PartialEq
Debug
)
]
enum
OpenList
{
Out
In
Other
}
let
mut
open_list
=
OpenList
:
:
Out
;
let
mut
to_index
;
let
mut
from_index
=
None
;
to_index
=
st
[
1
]
.
next_out_index
(
0
)
;
if
to_index
.
is_some
(
)
{
from_index
=
st
[
0
]
.
next_out_index
(
0
)
;
open_list
=
OpenList
:
:
Out
;
}
if
to_index
.
is_none
(
)
|
|
from_index
.
is_none
(
)
{
to_index
=
st
[
1
]
.
next_in_index
(
0
)
;
if
to_index
.
is_some
(
)
{
from_index
=
st
[
0
]
.
next_in_index
(
0
)
;
open_list
=
OpenList
:
:
In
;
}
}
if
to_index
.
is_none
(
)
|
|
from_index
.
is_none
(
)
{
to_index
=
st
[
1
]
.
next_rest_index
(
0
)
;
if
to_index
.
is_some
(
)
{
from_index
=
st
[
0
]
.
next_rest_index
(
0
)
;
open_list
=
OpenList
:
:
Other
;
}
}
let
(
cand0
cand1
)
=
match
(
from_index
to_index
)
{
(
Some
(
n
)
Some
(
m
)
)
=
>
(
n
m
)
_
=
>
return
None
}
;
let
mut
nx
=
NodeIndex
:
:
new
(
cand0
)
;
let
mx
=
NodeIndex
:
:
new
(
cand1
)
;
let
mut
first
=
true
;
'
candidates
:
loop
{
if
!
first
{
let
start
=
nx
.
index
(
)
+
1
;
let
cand0
=
match
open_list
{
OpenList
:
:
Out
=
>
st
[
0
]
.
next_out_index
(
start
)
OpenList
:
:
In
=
>
st
[
0
]
.
next_in_index
(
start
)
OpenList
:
:
Other
=
>
st
[
0
]
.
next_rest_index
(
start
)
}
.
map
(
|
c
|
c
+
start
)
;
nx
=
match
cand0
{
None
=
>
break
Some
(
ix
)
=
>
NodeIndex
:
:
new
(
ix
)
}
;
debug_assert
!
(
nx
.
index
(
)
>
=
start
)
;
}
first
=
false
;
let
nodes
=
[
nx
mx
]
;
let
mut
succ_count
=
[
0
0
]
;
for
j
in
graph_indices
.
clone
(
)
{
for
n_neigh
in
g
[
j
]
.
neighbors
(
nodes
[
j
]
)
{
succ_count
[
j
]
+
=
1
;
let
m_neigh
=
if
nodes
[
j
]
!
=
n_neigh
{
st
[
j
]
.
mapping
[
n_neigh
.
index
(
)
]
}
else
{
nodes
[
1
-
j
]
}
;
if
m_neigh
=
=
end
{
continue
;
}
let
has_edge
=
g
[
1
-
j
]
.
is_adjacent
(
&
st
[
1
-
j
]
.
adjacency_matrix
nodes
[
1
-
j
]
m_neigh
)
;
if
!
has_edge
{
continue
'
candidates
;
}
}
}
if
succ_count
[
0
]
!
=
succ_count
[
1
]
{
continue
'
candidates
;
}
if
g
[
0
]
.
is_directed
(
)
{
let
mut
pred_count
=
[
0
0
]
;
for
j
in
graph_indices
.
clone
(
)
{
for
n_neigh
in
g
[
j
]
.
neighbors_directed
(
nodes
[
j
]
Incoming
)
{
pred_count
[
j
]
+
=
1
;
let
m_neigh
=
st
[
j
]
.
mapping
[
n_neigh
.
index
(
)
]
;
if
m_neigh
=
=
end
{
continue
;
}
let
has_edge
=
g
[
1
-
j
]
.
is_adjacent
(
&
st
[
1
-
j
]
.
adjacency_matrix
m_neigh
nodes
[
1
-
j
]
)
;
if
!
has_edge
{
continue
'
candidates
;
}
}
}
if
pred_count
[
0
]
!
=
pred_count
[
1
]
{
continue
'
candidates
;
}
}
if
F
:
:
enabled
(
)
&
&
!
node_match
.
eq
(
&
g
[
0
]
[
nodes
[
0
]
]
&
g
[
1
]
[
nodes
[
1
]
]
)
{
continue
'
candidates
;
}
if
G
:
:
enabled
(
)
{
for
j
in
graph_indices
.
clone
(
)
{
let
mut
edges
=
g
[
j
]
.
neighbors
(
nodes
[
j
]
)
.
detach
(
)
;
while
let
Some
(
(
n_edge
n_neigh
)
)
=
edges
.
next
(
g
[
j
]
)
{
let
m_neigh
=
if
nodes
[
j
]
!
=
n_neigh
{
st
[
j
]
.
mapping
[
n_neigh
.
index
(
)
]
}
else
{
nodes
[
1
-
j
]
}
;
if
m_neigh
=
=
end
{
continue
;
}
match
g
[
1
-
j
]
.
find_edge
(
nodes
[
1
-
j
]
m_neigh
)
{
Some
(
m_edge
)
=
>
{
if
!
edge_match
.
eq
(
&
g
[
j
]
[
n_edge
]
&
g
[
1
-
j
]
[
m_edge
]
)
{
continue
'
candidates
;
}
}
None
=
>
unreachable
!
(
)
}
}
}
if
g
[
0
]
.
is_directed
(
)
{
for
j
in
graph_indices
.
clone
(
)
{
let
mut
edges
=
g
[
j
]
.
neighbors_directed
(
nodes
[
j
]
Incoming
)
.
detach
(
)
;
while
let
Some
(
(
n_edge
n_neigh
)
)
=
edges
.
next
(
g
[
j
]
)
{
let
m_neigh
=
st
[
j
]
.
mapping
[
n_neigh
.
index
(
)
]
;
if
m_neigh
=
=
end
{
continue
;
}
match
g
[
1
-
j
]
.
find_edge
(
m_neigh
nodes
[
1
-
j
]
)
{
Some
(
m_edge
)
=
>
{
if
!
edge_match
.
eq
(
&
g
[
j
]
[
n_edge
]
&
g
[
1
-
j
]
[
m_edge
]
)
{
continue
'
candidates
;
}
}
None
=
>
unreachable
!
(
)
}
}
}
}
}
for
j
in
graph_indices
.
clone
(
)
{
st
[
j
]
.
push_mapping
(
nodes
[
j
]
nodes
[
1
-
j
]
g
[
j
]
)
;
}
if
st
[
0
]
.
out_size
=
=
st
[
1
]
.
out_size
&
&
st
[
0
]
.
ins_size
=
=
st
[
1
]
.
ins_size
{
match
try_match
(
st
g0
g1
node_match
edge_match
)
{
None
=
>
{
}
result
=
>
return
result
}
}
for
j
in
graph_indices
.
clone
(
)
{
st
[
j
]
.
pop_mapping
(
nodes
[
j
]
g
[
j
]
)
;
}
}
None
}
