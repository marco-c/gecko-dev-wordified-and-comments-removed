pub
mod
dominators
;
use
std
:
:
cmp
:
:
min
;
use
std
:
:
collections
:
:
{
BinaryHeap
HashMap
}
;
use
crate
:
:
prelude
:
:
*
;
use
super
:
:
graph
:
:
IndexType
;
use
super
:
:
unionfind
:
:
UnionFind
;
use
super
:
:
visit
:
:
{
GraphBase
GraphRef
IntoEdgeReferences
IntoEdges
IntoNeighbors
IntoNeighborsDirected
IntoNodeIdentifiers
NodeCompactIndexable
NodeCount
NodeIndexable
Reversed
VisitMap
Visitable
}
;
use
super
:
:
EdgeType
;
use
crate
:
:
data
:
:
Element
;
use
crate
:
:
scored
:
:
MinScored
;
use
crate
:
:
visit
:
:
Walker
;
use
crate
:
:
visit
:
:
{
Data
IntoNodeReferences
NodeRef
}
;
pub
use
super
:
:
astar
:
:
astar
;
pub
use
super
:
:
dijkstra
:
:
dijkstra
;
pub
use
super
:
:
isomorphism
:
:
{
is_isomorphic
is_isomorphic_matching
}
;
pub
use
super
:
:
simple_paths
:
:
all_simple_paths
;
pub
fn
connected_components
<
G
>
(
g
:
G
)
-
>
usize
where
G
:
NodeCompactIndexable
+
IntoEdgeReferences
{
let
mut
vertex_sets
=
UnionFind
:
:
new
(
g
.
node_bound
(
)
)
;
for
edge
in
g
.
edge_references
(
)
{
let
(
a
b
)
=
(
edge
.
source
(
)
edge
.
target
(
)
)
;
vertex_sets
.
union
(
g
.
to_index
(
a
)
g
.
to_index
(
b
)
)
;
}
let
mut
labels
=
vertex_sets
.
into_labeling
(
)
;
labels
.
sort
(
)
;
labels
.
dedup
(
)
;
labels
.
len
(
)
}
pub
fn
is_cyclic_undirected
<
G
>
(
g
:
G
)
-
>
bool
where
G
:
NodeIndexable
+
IntoEdgeReferences
{
let
mut
edge_sets
=
UnionFind
:
:
new
(
g
.
node_bound
(
)
)
;
for
edge
in
g
.
edge_references
(
)
{
let
(
a
b
)
=
(
edge
.
source
(
)
edge
.
target
(
)
)
;
if
!
edge_sets
.
union
(
g
.
to_index
(
a
)
g
.
to_index
(
b
)
)
{
return
true
;
}
}
false
}
pub
fn
toposort
<
G
>
(
g
:
G
space
:
Option
<
&
mut
DfsSpace
<
G
:
:
NodeId
G
:
:
Map
>
>
)
-
>
Result
<
Vec
<
G
:
:
NodeId
>
Cycle
<
G
:
:
NodeId
>
>
where
G
:
IntoNeighborsDirected
+
IntoNodeIdentifiers
+
Visitable
{
with_dfs
(
g
space
|
dfs
|
{
dfs
.
reset
(
g
)
;
let
mut
finished
=
g
.
visit_map
(
)
;
let
mut
finish_stack
=
Vec
:
:
new
(
)
;
for
i
in
g
.
node_identifiers
(
)
{
if
dfs
.
discovered
.
is_visited
(
&
i
)
{
continue
;
}
dfs
.
stack
.
push
(
i
)
;
while
let
Some
(
&
nx
)
=
dfs
.
stack
.
last
(
)
{
if
dfs
.
discovered
.
visit
(
nx
)
{
for
succ
in
g
.
neighbors
(
nx
)
{
if
succ
=
=
nx
{
return
Err
(
Cycle
(
nx
)
)
;
}
if
!
dfs
.
discovered
.
is_visited
(
&
succ
)
{
dfs
.
stack
.
push
(
succ
)
;
}
}
}
else
{
dfs
.
stack
.
pop
(
)
;
if
finished
.
visit
(
nx
)
{
finish_stack
.
push
(
nx
)
;
}
}
}
}
finish_stack
.
reverse
(
)
;
dfs
.
reset
(
g
)
;
for
&
i
in
&
finish_stack
{
dfs
.
move_to
(
i
)
;
let
mut
cycle
=
false
;
while
let
Some
(
j
)
=
dfs
.
next
(
Reversed
(
g
)
)
{
if
cycle
{
return
Err
(
Cycle
(
j
)
)
;
}
cycle
=
true
;
}
}
Ok
(
finish_stack
)
}
)
}
pub
fn
is_cyclic_directed
<
G
>
(
g
:
G
)
-
>
bool
where
G
:
IntoNodeIdentifiers
+
IntoNeighbors
+
Visitable
{
use
crate
:
:
visit
:
:
{
depth_first_search
DfsEvent
}
;
depth_first_search
(
g
g
.
node_identifiers
(
)
|
event
|
match
event
{
DfsEvent
:
:
BackEdge
(
_
_
)
=
>
Err
(
(
)
)
_
=
>
Ok
(
(
)
)
}
)
.
is_err
(
)
}
type
DfsSpaceType
<
G
>
=
DfsSpace
<
<
G
as
GraphBase
>
:
:
NodeId
<
G
as
Visitable
>
:
:
Map
>
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
DfsSpace
<
N
VM
>
{
dfs
:
Dfs
<
N
VM
>
}
impl
<
N
VM
>
DfsSpace
<
N
VM
>
where
N
:
Copy
+
PartialEq
VM
:
VisitMap
<
N
>
{
pub
fn
new
<
G
>
(
g
:
G
)
-
>
Self
where
G
:
GraphRef
+
Visitable
<
NodeId
=
N
Map
=
VM
>
{
DfsSpace
{
dfs
:
Dfs
:
:
empty
(
g
)
}
}
}
impl
<
N
VM
>
Default
for
DfsSpace
<
N
VM
>
where
VM
:
VisitMap
<
N
>
+
Default
{
fn
default
(
)
-
>
Self
{
DfsSpace
{
dfs
:
Dfs
{
stack
:
<
_
>
:
:
default
(
)
discovered
:
<
_
>
:
:
default
(
)
}
}
}
}
fn
with_dfs
<
G
F
R
>
(
g
:
G
space
:
Option
<
&
mut
DfsSpaceType
<
G
>
>
f
:
F
)
-
>
R
where
G
:
GraphRef
+
Visitable
F
:
FnOnce
(
&
mut
Dfs
<
G
:
:
NodeId
G
:
:
Map
>
)
-
>
R
{
let
mut
local_visitor
;
let
dfs
=
if
let
Some
(
v
)
=
space
{
&
mut
v
.
dfs
}
else
{
local_visitor
=
Dfs
:
:
empty
(
g
)
;
&
mut
local_visitor
}
;
f
(
dfs
)
}
pub
fn
has_path_connecting
<
G
>
(
g
:
G
from
:
G
:
:
NodeId
to
:
G
:
:
NodeId
space
:
Option
<
&
mut
DfsSpace
<
G
:
:
NodeId
G
:
:
Map
>
>
)
-
>
bool
where
G
:
IntoNeighbors
+
Visitable
{
with_dfs
(
g
space
|
dfs
|
{
dfs
.
reset
(
g
)
;
dfs
.
move_to
(
from
)
;
dfs
.
iter
(
g
)
.
any
(
|
x
|
x
=
=
to
)
}
)
}
#
[
deprecated
(
note
=
"
renamed
to
kosaraju_scc
"
)
]
pub
fn
scc
<
G
>
(
g
:
G
)
-
>
Vec
<
Vec
<
G
:
:
NodeId
>
>
where
G
:
IntoNeighborsDirected
+
Visitable
+
IntoNodeIdentifiers
{
kosaraju_scc
(
g
)
}
pub
fn
kosaraju_scc
<
G
>
(
g
:
G
)
-
>
Vec
<
Vec
<
G
:
:
NodeId
>
>
where
G
:
IntoNeighborsDirected
+
Visitable
+
IntoNodeIdentifiers
{
let
mut
dfs
=
DfsPostOrder
:
:
empty
(
g
)
;
let
mut
finish_order
=
Vec
:
:
with_capacity
(
0
)
;
for
i
in
g
.
node_identifiers
(
)
{
if
dfs
.
discovered
.
is_visited
(
&
i
)
{
continue
;
}
dfs
.
move_to
(
i
)
;
while
let
Some
(
nx
)
=
dfs
.
next
(
Reversed
(
g
)
)
{
finish_order
.
push
(
nx
)
;
}
}
let
mut
dfs
=
Dfs
:
:
from_parts
(
dfs
.
stack
dfs
.
discovered
)
;
dfs
.
reset
(
g
)
;
let
mut
sccs
=
Vec
:
:
new
(
)
;
for
i
in
finish_order
.
into_iter
(
)
.
rev
(
)
{
if
dfs
.
discovered
.
is_visited
(
&
i
)
{
continue
;
}
dfs
.
move_to
(
i
)
;
let
mut
scc
=
Vec
:
:
new
(
)
;
while
let
Some
(
nx
)
=
dfs
.
next
(
g
)
{
scc
.
push
(
nx
)
;
}
sccs
.
push
(
scc
)
;
}
sccs
}
pub
fn
tarjan_scc
<
G
>
(
g
:
G
)
-
>
Vec
<
Vec
<
G
:
:
NodeId
>
>
where
G
:
IntoNodeIdentifiers
+
IntoNeighbors
+
NodeIndexable
{
#
[
derive
(
Copy
Clone
Debug
)
]
struct
NodeData
{
index
:
Option
<
usize
>
lowlink
:
usize
on_stack
:
bool
}
#
[
derive
(
Debug
)
]
struct
Data
<
'
a
G
>
where
G
:
NodeIndexable
G
:
:
NodeId
:
'
a
{
index
:
usize
nodes
:
Vec
<
NodeData
>
stack
:
Vec
<
G
:
:
NodeId
>
sccs
:
&
'
a
mut
Vec
<
Vec
<
G
:
:
NodeId
>
>
}
fn
scc_visit
<
G
>
(
v
:
G
:
:
NodeId
g
:
G
data
:
&
mut
Data
<
G
>
)
where
G
:
IntoNeighbors
+
NodeIndexable
{
macro_rules
!
node
{
(
node
:
expr
)
=
>
{
data
.
nodes
[
g
.
to_index
(
node
)
]
}
;
}
if
node
!
[
v
]
.
index
.
is_some
(
)
{
return
;
}
let
v_index
=
data
.
index
;
node
!
[
v
]
.
index
=
Some
(
v_index
)
;
node
!
[
v
]
.
lowlink
=
v_index
;
node
!
[
v
]
.
on_stack
=
true
;
data
.
stack
.
push
(
v
)
;
data
.
index
+
=
1
;
for
w
in
g
.
neighbors
(
v
)
{
match
node
!
[
w
]
.
index
{
None
=
>
{
scc_visit
(
w
g
data
)
;
node
!
[
v
]
.
lowlink
=
min
(
node
!
[
v
]
.
lowlink
node
!
[
w
]
.
lowlink
)
;
}
Some
(
w_index
)
=
>
{
if
node
!
[
w
]
.
on_stack
{
let
v_lowlink
=
&
mut
node
!
[
v
]
.
lowlink
;
*
v_lowlink
=
min
(
*
v_lowlink
w_index
)
;
}
}
}
}
if
let
Some
(
v_index
)
=
node
!
[
v
]
.
index
{
if
node
!
[
v
]
.
lowlink
=
=
v_index
{
let
mut
cur_scc
=
Vec
:
:
new
(
)
;
loop
{
let
w
=
data
.
stack
.
pop
(
)
.
unwrap
(
)
;
node
!
[
w
]
.
on_stack
=
false
;
cur_scc
.
push
(
w
)
;
if
g
.
to_index
(
w
)
=
=
g
.
to_index
(
v
)
{
break
;
}
}
data
.
sccs
.
push
(
cur_scc
)
;
}
}
}
let
mut
sccs
=
Vec
:
:
new
(
)
;
{
let
map
=
vec
!
[
NodeData
{
index
:
None
lowlink
:
!
0
on_stack
:
false
}
;
g
.
node_bound
(
)
]
;
let
mut
data
=
Data
{
index
:
0
nodes
:
map
stack
:
Vec
:
:
new
(
)
sccs
:
&
mut
sccs
}
;
for
n
in
g
.
node_identifiers
(
)
{
scc_visit
(
n
g
&
mut
data
)
;
}
}
sccs
}
pub
fn
condensation
<
N
E
Ty
Ix
>
(
g
:
Graph
<
N
E
Ty
Ix
>
make_acyclic
:
bool
)
-
>
Graph
<
Vec
<
N
>
E
Ty
Ix
>
where
Ty
:
EdgeType
Ix
:
IndexType
{
let
sccs
=
kosaraju_scc
(
&
g
)
;
let
mut
condensed
:
Graph
<
Vec
<
N
>
E
Ty
Ix
>
=
Graph
:
:
with_capacity
(
sccs
.
len
(
)
g
.
edge_count
(
)
)
;
let
mut
node_map
=
vec
!
[
NodeIndex
:
:
end
(
)
;
g
.
node_count
(
)
]
;
for
comp
in
sccs
{
let
new_nix
=
condensed
.
add_node
(
Vec
:
:
new
(
)
)
;
for
nix
in
comp
{
node_map
[
nix
.
index
(
)
]
=
new_nix
;
}
}
let
(
nodes
edges
)
=
g
.
into_nodes_edges
(
)
;
for
(
nix
node
)
in
nodes
.
into_iter
(
)
.
enumerate
(
)
{
condensed
[
node_map
[
nix
]
]
.
push
(
node
.
weight
)
;
}
for
edge
in
edges
{
let
source
=
node_map
[
edge
.
source
(
)
.
index
(
)
]
;
let
target
=
node_map
[
edge
.
target
(
)
.
index
(
)
]
;
if
make_acyclic
{
if
source
!
=
target
{
condensed
.
update_edge
(
source
target
edge
.
weight
)
;
}
}
else
{
condensed
.
add_edge
(
source
target
edge
.
weight
)
;
}
}
condensed
}
pub
fn
min_spanning_tree
<
G
>
(
g
:
G
)
-
>
MinSpanningTree
<
G
>
where
G
:
:
NodeWeight
:
Clone
G
:
:
EdgeWeight
:
Clone
+
PartialOrd
G
:
IntoNodeReferences
+
IntoEdgeReferences
+
NodeIndexable
{
let
subgraphs
=
UnionFind
:
:
new
(
g
.
node_bound
(
)
)
;
let
edges
=
g
.
edge_references
(
)
;
let
mut
sort_edges
=
BinaryHeap
:
:
with_capacity
(
edges
.
size_hint
(
)
.
0
)
;
for
edge
in
edges
{
sort_edges
.
push
(
MinScored
(
edge
.
weight
(
)
.
clone
(
)
(
edge
.
source
(
)
edge
.
target
(
)
)
)
)
;
}
MinSpanningTree
{
graph
:
g
node_ids
:
Some
(
g
.
node_references
(
)
)
subgraphs
sort_edges
node_map
:
HashMap
:
:
new
(
)
node_count
:
0
}
}
pub
struct
MinSpanningTree
<
G
>
where
G
:
Data
+
IntoNodeReferences
{
graph
:
G
node_ids
:
Option
<
G
:
:
NodeReferences
>
subgraphs
:
UnionFind
<
usize
>
sort_edges
:
BinaryHeap
<
MinScored
<
G
:
:
EdgeWeight
(
G
:
:
NodeId
G
:
:
NodeId
)
>
>
node_map
:
HashMap
<
usize
usize
>
node_count
:
usize
}
impl
<
G
>
Iterator
for
MinSpanningTree
<
G
>
where
G
:
IntoNodeReferences
+
NodeIndexable
G
:
:
NodeWeight
:
Clone
G
:
:
EdgeWeight
:
PartialOrd
{
type
Item
=
Element
<
G
:
:
NodeWeight
G
:
:
EdgeWeight
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
g
=
self
.
graph
;
if
let
Some
(
ref
mut
iter
)
=
self
.
node_ids
{
if
let
Some
(
node
)
=
iter
.
next
(
)
{
self
.
node_map
.
insert
(
g
.
to_index
(
node
.
id
(
)
)
self
.
node_count
)
;
self
.
node_count
+
=
1
;
return
Some
(
Element
:
:
Node
{
weight
:
node
.
weight
(
)
.
clone
(
)
}
)
;
}
}
self
.
node_ids
=
None
;
while
let
Some
(
MinScored
(
score
(
a
b
)
)
)
=
self
.
sort_edges
.
pop
(
)
{
let
(
a_index
b_index
)
=
(
g
.
to_index
(
a
)
g
.
to_index
(
b
)
)
;
if
self
.
subgraphs
.
union
(
a_index
b_index
)
{
let
(
&
a_order
&
b_order
)
=
match
(
self
.
node_map
.
get
(
&
a_index
)
self
.
node_map
.
get
(
&
b_index
)
)
{
(
Some
(
a_id
)
Some
(
b_id
)
)
=
>
(
a_id
b_id
)
_
=
>
panic
!
(
"
Edge
references
unknown
node
"
)
}
;
return
Some
(
Element
:
:
Edge
{
source
:
a_order
target
:
b_order
weight
:
score
}
)
;
}
}
None
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
Cycle
<
N
>
(
N
)
;
impl
<
N
>
Cycle
<
N
>
{
pub
fn
node_id
(
&
self
)
-
>
N
where
N
:
Copy
{
self
.
0
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
NegativeCycle
(
(
)
)
;
pub
fn
bellman_ford
<
G
>
(
g
:
G
source
:
G
:
:
NodeId
)
-
>
Result
<
(
Vec
<
G
:
:
EdgeWeight
>
Vec
<
Option
<
G
:
:
NodeId
>
>
)
NegativeCycle
>
where
G
:
NodeCount
+
IntoNodeIdentifiers
+
IntoEdges
+
NodeIndexable
G
:
:
EdgeWeight
:
FloatMeasure
{
let
mut
predecessor
=
vec
!
[
None
;
g
.
node_bound
(
)
]
;
let
mut
distance
=
vec
!
[
<
_
>
:
:
infinite
(
)
;
g
.
node_bound
(
)
]
;
let
ix
=
|
i
|
g
.
to_index
(
i
)
;
distance
[
ix
(
source
)
]
=
<
_
>
:
:
zero
(
)
;
for
_
in
1
.
.
g
.
node_count
(
)
{
let
mut
did_update
=
false
;
for
i
in
g
.
node_identifiers
(
)
{
for
edge
in
g
.
edges
(
i
)
{
let
i
=
edge
.
source
(
)
;
let
j
=
edge
.
target
(
)
;
let
w
=
*
edge
.
weight
(
)
;
if
distance
[
ix
(
i
)
]
+
w
<
distance
[
ix
(
j
)
]
{
distance
[
ix
(
j
)
]
=
distance
[
ix
(
i
)
]
+
w
;
predecessor
[
ix
(
j
)
]
=
Some
(
i
)
;
did_update
=
true
;
}
}
}
if
!
did_update
{
break
;
}
}
for
i
in
g
.
node_identifiers
(
)
{
for
edge
in
g
.
edges
(
i
)
{
let
j
=
edge
.
target
(
)
;
let
w
=
*
edge
.
weight
(
)
;
if
distance
[
ix
(
i
)
]
+
w
<
distance
[
ix
(
j
)
]
{
return
Err
(
NegativeCycle
(
(
)
)
)
;
}
}
}
Ok
(
(
distance
predecessor
)
)
}
pub
fn
is_bipartite_undirected
<
G
N
VM
>
(
g
:
G
start
:
N
)
-
>
bool
where
G
:
GraphRef
+
Visitable
<
NodeId
=
N
Map
=
VM
>
+
IntoNeighbors
<
NodeId
=
N
>
N
:
Copy
+
PartialEq
+
std
:
:
fmt
:
:
Debug
VM
:
VisitMap
<
N
>
{
let
mut
red
=
g
.
visit_map
(
)
;
red
.
visit
(
start
)
;
let
mut
blue
=
g
.
visit_map
(
)
;
let
mut
stack
=
:
:
std
:
:
collections
:
:
VecDeque
:
:
new
(
)
;
stack
.
push_front
(
start
)
;
while
let
Some
(
node
)
=
stack
.
pop_front
(
)
{
let
is_red
=
red
.
is_visited
(
&
node
)
;
let
is_blue
=
blue
.
is_visited
(
&
node
)
;
assert
!
(
is_red
^
is_blue
)
;
for
neighbour
in
g
.
neighbors
(
node
)
{
let
is_neigbour_red
=
red
.
is_visited
(
&
neighbour
)
;
let
is_neigbour_blue
=
blue
.
is_visited
(
&
neighbour
)
;
if
(
is_red
&
&
is_neigbour_red
)
|
|
(
is_blue
&
&
is_neigbour_blue
)
{
return
false
;
}
if
!
is_neigbour_red
&
&
!
is_neigbour_blue
{
match
(
is_red
is_blue
)
{
(
true
false
)
=
>
{
blue
.
visit
(
neighbour
)
;
}
(
false
true
)
=
>
{
red
.
visit
(
neighbour
)
;
}
(
_
_
)
=
>
{
panic
!
(
"
Invariant
doesn
'
t
hold
"
)
;
}
}
stack
.
push_back
(
neighbour
)
;
}
}
}
true
}
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
ops
:
:
Add
;
pub
trait
Measure
:
Debug
+
PartialOrd
+
Add
<
Self
Output
=
Self
>
+
Default
+
Clone
{
}
impl
<
M
>
Measure
for
M
where
M
:
Debug
+
PartialOrd
+
Add
<
M
Output
=
M
>
+
Default
+
Clone
{
}
pub
trait
FloatMeasure
:
Measure
+
Copy
{
fn
zero
(
)
-
>
Self
;
fn
infinite
(
)
-
>
Self
;
}
impl
FloatMeasure
for
f32
{
fn
zero
(
)
-
>
Self
{
0
.
}
fn
infinite
(
)
-
>
Self
{
1
.
/
0
.
}
}
impl
FloatMeasure
for
f64
{
fn
zero
(
)
-
>
Self
{
0
.
}
fn
infinite
(
)
-
>
Self
{
1
.
/
0
.
}
}
