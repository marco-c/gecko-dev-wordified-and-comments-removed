#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
petgraph
/
0
.
4
/
"
)
]
extern
crate
fixedbitset
;
#
[
cfg
(
feature
=
"
graphmap
"
)
]
extern
crate
ordermap
;
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
extern
crate
serde
;
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
#
[
macro_use
]
extern
crate
serde_derive
;
#
[
cfg
(
all
(
feature
=
"
serde
-
1
"
test
)
)
]
extern
crate
itertools
;
#
[
doc
(
no_inline
)
]
pub
use
graph
:
:
Graph
;
pub
use
Direction
:
:
{
Outgoing
Incoming
}
;
#
[
macro_use
]
mod
macros
;
mod
scored
;
#
[
macro_use
]
pub
mod
visit
;
#
[
macro_use
]
pub
mod
data
;
pub
mod
algo
;
#
[
cfg
(
feature
=
"
generate
"
)
]
pub
mod
generate
;
#
[
cfg
(
feature
=
"
graphmap
"
)
]
pub
mod
graphmap
;
mod
graph_impl
;
pub
mod
dot
;
pub
mod
unionfind
;
mod
dijkstra
;
mod
astar
;
pub
mod
csr
;
mod
iter_format
;
mod
iter_utils
;
mod
isomorphism
;
mod
traits_graph
;
mod
util
;
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
mod
quickcheck
;
#
[
cfg
(
feature
=
"
serde
-
1
"
)
]
mod
serde_utils
;
pub
mod
prelude
;
pub
mod
graph
{
pub
use
graph_impl
:
:
{
Edge
EdgeIndex
EdgeIndices
EdgeReference
EdgeReferences
EdgeWeightsMut
Edges
Externals
Frozen
Graph
Neighbors
Node
NodeIndex
NodeIndices
NodeWeightsMut
NodeReferences
WalkNeighbors
GraphIndex
IndexType
edge_index
node_index
DefaultIx
DiGraph
UnGraph
}
;
}
#
[
cfg
(
feature
=
"
stable_graph
"
)
]
pub
use
graph_impl
:
:
stable_graph
;
macro_rules
!
copyclone
{
(
name
:
ident
)
=
>
{
impl
Clone
for
name
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
}
}
#
[
derive
(
Copy
Debug
PartialEq
PartialOrd
Ord
Eq
Hash
)
]
#
[
repr
(
usize
)
]
pub
enum
Direction
{
Outgoing
=
0
Incoming
=
1
}
copyclone
!
(
Direction
)
;
impl
Direction
{
#
[
inline
]
pub
fn
opposite
(
&
self
)
-
>
Direction
{
match
*
self
{
Outgoing
=
>
Incoming
Incoming
=
>
Outgoing
}
}
#
[
inline
]
pub
fn
index
(
&
self
)
-
>
usize
{
(
*
self
as
usize
)
&
0x1
}
}
#
[
doc
(
hidden
)
]
pub
use
Direction
as
EdgeDirection
;
#
[
derive
(
Copy
Debug
)
]
pub
enum
Directed
{
}
copyclone
!
(
Directed
)
;
#
[
derive
(
Copy
Debug
)
]
pub
enum
Undirected
{
}
copyclone
!
(
Undirected
)
;
pub
trait
EdgeType
{
fn
is_directed
(
)
-
>
bool
;
}
impl
EdgeType
for
Directed
{
#
[
inline
]
fn
is_directed
(
)
-
>
bool
{
true
}
}
impl
EdgeType
for
Undirected
{
#
[
inline
]
fn
is_directed
(
)
-
>
bool
{
false
}
}
pub
trait
IntoWeightedEdge
<
E
>
{
type
NodeId
;
fn
into_weighted_edge
(
self
)
-
>
(
Self
:
:
NodeId
Self
:
:
NodeId
E
)
;
}
impl
<
Ix
E
>
IntoWeightedEdge
<
E
>
for
(
Ix
Ix
)
where
E
:
Default
{
type
NodeId
=
Ix
;
fn
into_weighted_edge
(
self
)
-
>
(
Ix
Ix
E
)
{
let
(
s
t
)
=
self
;
(
s
t
E
:
:
default
(
)
)
}
}
impl
<
Ix
E
>
IntoWeightedEdge
<
E
>
for
(
Ix
Ix
E
)
{
type
NodeId
=
Ix
;
fn
into_weighted_edge
(
self
)
-
>
(
Ix
Ix
E
)
{
self
}
}
impl
<
'
a
Ix
E
>
IntoWeightedEdge
<
E
>
for
(
Ix
Ix
&
'
a
E
)
where
E
:
Clone
{
type
NodeId
=
Ix
;
fn
into_weighted_edge
(
self
)
-
>
(
Ix
Ix
E
)
{
let
(
a
b
c
)
=
self
;
(
a
b
c
.
clone
(
)
)
}
}
impl
<
'
a
Ix
E
>
IntoWeightedEdge
<
E
>
for
&
'
a
(
Ix
Ix
)
where
Ix
:
Copy
E
:
Default
{
type
NodeId
=
Ix
;
fn
into_weighted_edge
(
self
)
-
>
(
Ix
Ix
E
)
{
let
(
s
t
)
=
*
self
;
(
s
t
E
:
:
default
(
)
)
}
}
impl
<
'
a
Ix
E
>
IntoWeightedEdge
<
E
>
for
&
'
a
(
Ix
Ix
E
)
where
Ix
:
Copy
E
:
Clone
{
type
NodeId
=
Ix
;
fn
into_weighted_edge
(
self
)
-
>
(
Ix
Ix
E
)
{
self
.
clone
(
)
}
}
