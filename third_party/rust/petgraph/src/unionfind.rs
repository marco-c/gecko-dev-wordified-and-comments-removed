use
super
:
:
graph
:
:
IndexType
;
use
std
:
:
cmp
:
:
Ordering
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
UnionFind
<
K
>
{
parent
:
Vec
<
K
>
rank
:
Vec
<
u8
>
}
#
[
inline
]
unsafe
fn
get_unchecked
<
K
>
(
xs
:
&
[
K
]
index
:
usize
)
-
>
&
K
{
debug_assert
!
(
index
<
xs
.
len
(
)
)
;
xs
.
get_unchecked
(
index
)
}
#
[
inline
]
unsafe
fn
get_unchecked_mut
<
K
>
(
xs
:
&
mut
[
K
]
index
:
usize
)
-
>
&
mut
K
{
debug_assert
!
(
index
<
xs
.
len
(
)
)
;
xs
.
get_unchecked_mut
(
index
)
}
impl
<
K
>
UnionFind
<
K
>
where
K
:
IndexType
{
pub
fn
new
(
n
:
usize
)
-
>
Self
{
let
rank
=
vec
!
[
0
;
n
]
;
let
parent
=
(
0
.
.
n
)
.
map
(
K
:
:
new
)
.
collect
:
:
<
Vec
<
K
>
>
(
)
;
UnionFind
{
parent
rank
}
}
pub
fn
find
(
&
self
x
:
K
)
-
>
K
{
assert
!
(
x
.
index
(
)
<
self
.
parent
.
len
(
)
)
;
unsafe
{
let
mut
x
=
x
;
loop
{
let
xparent
=
*
get_unchecked
(
&
self
.
parent
x
.
index
(
)
)
;
if
xparent
=
=
x
{
break
;
}
x
=
xparent
;
}
x
}
}
pub
fn
find_mut
(
&
mut
self
x
:
K
)
-
>
K
{
assert
!
(
x
.
index
(
)
<
self
.
parent
.
len
(
)
)
;
unsafe
{
self
.
find_mut_recursive
(
x
)
}
}
unsafe
fn
find_mut_recursive
(
&
mut
self
mut
x
:
K
)
-
>
K
{
let
mut
parent
=
*
get_unchecked
(
&
self
.
parent
x
.
index
(
)
)
;
while
parent
!
=
x
{
let
grandparent
=
*
get_unchecked
(
&
self
.
parent
parent
.
index
(
)
)
;
*
get_unchecked_mut
(
&
mut
self
.
parent
x
.
index
(
)
)
=
grandparent
;
x
=
parent
;
parent
=
grandparent
;
}
x
}
pub
fn
equiv
(
&
self
x
:
K
y
:
K
)
-
>
bool
{
self
.
find
(
x
)
=
=
self
.
find
(
y
)
}
pub
fn
union
(
&
mut
self
x
:
K
y
:
K
)
-
>
bool
{
if
x
=
=
y
{
return
false
;
}
let
xrep
=
self
.
find_mut
(
x
)
;
let
yrep
=
self
.
find_mut
(
y
)
;
if
xrep
=
=
yrep
{
return
false
;
}
let
xrepu
=
xrep
.
index
(
)
;
let
yrepu
=
yrep
.
index
(
)
;
let
xrank
=
self
.
rank
[
xrepu
]
;
let
yrank
=
self
.
rank
[
yrepu
]
;
match
xrank
.
cmp
(
&
yrank
)
{
Ordering
:
:
Less
=
>
self
.
parent
[
xrepu
]
=
yrep
Ordering
:
:
Greater
=
>
self
.
parent
[
yrepu
]
=
xrep
Ordering
:
:
Equal
=
>
{
self
.
parent
[
yrepu
]
=
xrep
;
self
.
rank
[
xrepu
]
+
=
1
;
}
}
true
}
pub
fn
into_labeling
(
mut
self
)
-
>
Vec
<
K
>
{
unsafe
{
for
ix
in
0
.
.
self
.
parent
.
len
(
)
{
let
k
=
*
get_unchecked
(
&
self
.
parent
ix
)
;
let
xrep
=
self
.
find_mut_recursive
(
k
)
;
*
self
.
parent
.
get_unchecked_mut
(
ix
)
=
xrep
;
}
}
self
.
parent
}
}
