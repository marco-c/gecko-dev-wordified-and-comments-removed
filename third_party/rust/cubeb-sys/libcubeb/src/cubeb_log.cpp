#
define
NOMINMAX
#
include
"
cubeb_log
.
h
"
#
include
"
cubeb_ringbuffer
.
h
"
#
include
"
cubeb_tracing
.
h
"
#
include
<
cstdarg
>
#
ifdef
_WIN32
#
include
<
windows
.
h
>
#
else
#
include
<
time
.
h
>
#
endif
std
:
:
atomic
<
cubeb_log_level
>
g_cubeb_log_level
;
std
:
:
atomic
<
cubeb_log_callback
>
g_cubeb_log_callback
;
const
size_t
CUBEB_LOG_MESSAGE_MAX_SIZE
=
256
;
const
size_t
CUBEB_LOG_MESSAGE_QUEUE_DEPTH
=
40
;
#
define
CUBEB_LOG_BATCH_PRINT_INTERVAL_MS
10
class
cubeb_log_message
{
public
:
cubeb_log_message
(
)
{
*
storage
=
'
\
0
'
;
}
cubeb_log_message
(
char
const
str
[
CUBEB_LOG_MESSAGE_MAX_SIZE
]
)
{
size_t
length
=
strlen
(
str
)
;
assert
(
length
<
CUBEB_LOG_MESSAGE_MAX_SIZE
)
;
if
(
length
>
CUBEB_LOG_MESSAGE_MAX_SIZE
-
1
)
{
return
;
}
PodCopy
(
storage
str
length
)
;
storage
[
length
]
=
'
\
0
'
;
}
char
const
*
get
(
)
{
return
storage
;
}
private
:
char
storage
[
CUBEB_LOG_MESSAGE_MAX_SIZE
]
;
}
;
class
cubeb_async_logger
{
public
:
static
cubeb_async_logger
&
get
(
)
{
static
cubeb_async_logger
instance
;
return
instance
;
}
void
push
(
char
const
str
[
CUBEB_LOG_MESSAGE_MAX_SIZE
]
)
{
cubeb_log_message
msg
(
str
)
;
msg_queue
.
enqueue
(
msg
)
;
}
void
run
(
)
{
std
:
:
thread
(
[
this
]
(
)
{
CUBEB_REGISTER_THREAD
(
"
cubeb_log
"
)
;
while
(
true
)
{
cubeb_log_message
msg
;
while
(
msg_queue
.
dequeue
(
&
msg
1
)
)
{
cubeb_log_internal_no_format
(
msg
.
get
(
)
)
;
}
#
ifdef
_WIN32
Sleep
(
CUBEB_LOG_BATCH_PRINT_INTERVAL_MS
)
;
#
else
timespec
sleep_duration
=
sleep_for
;
timespec
remainder
;
do
{
if
(
nanosleep
(
&
sleep_duration
&
remainder
)
=
=
0
|
|
errno
!
=
EINTR
)
{
break
;
}
sleep_duration
=
remainder
;
}
while
(
remainder
.
tv_sec
|
|
remainder
.
tv_nsec
)
;
#
endif
}
CUBEB_UNREGISTER_THREAD
(
)
;
}
)
.
detach
(
)
;
}
void
reset_producer_thread
(
)
{
msg_queue
.
reset_thread_ids
(
)
;
}
private
:
#
ifndef
_WIN32
const
struct
timespec
sleep_for
=
{
CUBEB_LOG_BATCH_PRINT_INTERVAL_MS
/
1000
(
CUBEB_LOG_BATCH_PRINT_INTERVAL_MS
%
1000
)
*
1000
*
1000
}
;
#
endif
cubeb_async_logger
(
)
:
msg_queue
(
CUBEB_LOG_MESSAGE_QUEUE_DEPTH
)
{
run
(
)
;
}
lock_free_queue
<
cubeb_log_message
>
msg_queue
;
}
;
void
cubeb_log_internal
(
char
const
*
file
uint32_t
line
char
const
*
fmt
.
.
.
)
{
va_list
args
;
va_start
(
args
fmt
)
;
char
msg
[
CUBEB_LOG_MESSAGE_MAX_SIZE
]
;
vsnprintf
(
msg
CUBEB_LOG_MESSAGE_MAX_SIZE
fmt
args
)
;
g_cubeb_log_callback
.
load
(
)
(
"
%
s
:
%
d
:
%
s
"
file
line
msg
)
;
va_end
(
args
)
;
}
void
cubeb_log_internal_no_format
(
const
char
*
msg
)
{
g_cubeb_log_callback
.
load
(
)
(
msg
)
;
}
void
cubeb_async_log
(
char
const
*
fmt
.
.
.
)
{
va_list
args
;
va_start
(
args
fmt
)
;
char
msg
[
CUBEB_LOG_MESSAGE_MAX_SIZE
]
;
vsnprintf
(
msg
CUBEB_LOG_MESSAGE_MAX_SIZE
fmt
args
)
;
cubeb_async_logger
:
:
get
(
)
.
push
(
msg
)
;
va_end
(
args
)
;
}
void
cubeb_async_log_reset_threads
(
void
)
{
if
(
!
g_cubeb_log_callback
)
{
return
;
}
cubeb_async_logger
:
:
get
(
)
.
reset_producer_thread
(
)
;
}
void
cubeb_log_set
(
cubeb_log_level
log_level
cubeb_log_callback
log_callback
)
{
g_cubeb_log_level
=
log_level
;
g_cubeb_log_callback
=
log_callback
;
}
cubeb_log_level
cubeb_log_get_level
(
)
{
return
g_cubeb_log_level
;
}
cubeb_log_callback
cubeb_log_get_callback
(
)
{
return
g_cubeb_log_callback
;
}
