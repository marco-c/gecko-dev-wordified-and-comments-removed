use
{
io
sys
Ready
Poll
PollOpt
Token
}
;
use
event
:
:
Evented
;
use
poll
:
:
SelectorId
;
use
std
:
:
fmt
;
use
std
:
:
net
:
:
{
self
Ipv4Addr
Ipv6Addr
SocketAddr
}
;
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
use
iovec
:
:
IoVec
;
pub
struct
UdpSocket
{
sys
:
sys
:
:
UdpSocket
selector_id
:
SelectorId
}
impl
UdpSocket
{
pub
fn
bind
(
addr
:
&
SocketAddr
)
-
>
io
:
:
Result
<
UdpSocket
>
{
let
socket
=
net
:
:
UdpSocket
:
:
bind
(
addr
)
?
;
UdpSocket
:
:
from_socket
(
socket
)
}
pub
fn
from_socket
(
socket
:
net
:
:
UdpSocket
)
-
>
io
:
:
Result
<
UdpSocket
>
{
Ok
(
UdpSocket
{
sys
:
sys
:
:
UdpSocket
:
:
new
(
socket
)
?
selector_id
:
SelectorId
:
:
new
(
)
}
)
}
#
[
cfg_attr
(
not
(
target_os
=
"
freebsd
"
)
doc
=
"
"
)
]
#
[
cfg_attr
(
target_os
=
"
freebsd
"
doc
=
"
no_run
"
)
]
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
sys
.
local_addr
(
)
}
pub
fn
try_clone
(
&
self
)
-
>
io
:
:
Result
<
UdpSocket
>
{
self
.
sys
.
try_clone
(
)
.
map
(
|
s
|
{
UdpSocket
{
sys
:
s
selector_id
:
self
.
selector_id
.
clone
(
)
}
}
)
}
pub
fn
send_to
(
&
self
buf
:
&
[
u8
]
target
:
&
SocketAddr
)
-
>
io
:
:
Result
<
usize
>
{
self
.
sys
.
send_to
(
buf
target
)
}
pub
fn
recv_from
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
usize
SocketAddr
)
>
{
self
.
sys
.
recv_from
(
buf
)
}
pub
fn
send
(
&
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
sys
.
send
(
buf
)
}
pub
fn
recv
(
&
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
sys
.
recv
(
buf
)
}
pub
fn
connect
(
&
self
addr
:
SocketAddr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
connect
(
addr
)
}
pub
fn
set_broadcast
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
set_broadcast
(
on
)
}
pub
fn
broadcast
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
sys
.
broadcast
(
)
}
pub
fn
set_multicast_loop_v4
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
set_multicast_loop_v4
(
on
)
}
pub
fn
multicast_loop_v4
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
sys
.
multicast_loop_v4
(
)
}
pub
fn
set_multicast_ttl_v4
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
set_multicast_ttl_v4
(
ttl
)
}
pub
fn
multicast_ttl_v4
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
sys
.
multicast_ttl_v4
(
)
}
pub
fn
set_multicast_loop_v6
(
&
self
on
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
set_multicast_loop_v6
(
on
)
}
pub
fn
multicast_loop_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
sys
.
multicast_loop_v6
(
)
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
set_ttl
(
ttl
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
sys
.
ttl
(
)
}
pub
fn
join_multicast_v4
(
&
self
multiaddr
:
&
Ipv4Addr
interface
:
&
Ipv4Addr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
join_multicast_v4
(
multiaddr
interface
)
}
pub
fn
join_multicast_v6
(
&
self
multiaddr
:
&
Ipv6Addr
interface
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
join_multicast_v6
(
multiaddr
interface
)
}
pub
fn
leave_multicast_v4
(
&
self
multiaddr
:
&
Ipv4Addr
interface
:
&
Ipv4Addr
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
leave_multicast_v4
(
multiaddr
interface
)
}
pub
fn
leave_multicast_v6
(
&
self
multiaddr
:
&
Ipv6Addr
interface
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
leave_multicast_v6
(
multiaddr
interface
)
}
pub
fn
set_only_v6
(
&
self
only_v6
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
set_only_v6
(
only_v6
)
}
pub
fn
only_v6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
self
.
sys
.
only_v6
(
)
}
pub
fn
take_error
(
&
self
)
-
>
io
:
:
Result
<
Option
<
io
:
:
Error
>
>
{
self
.
sys
.
take_error
(
)
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
pub
fn
recv_bufs
(
&
self
bufs
:
&
mut
[
&
mut
IoVec
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
sys
.
readv
(
bufs
)
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
pub
fn
send_bufs
(
&
self
bufs
:
&
[
&
IoVec
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
sys
.
writev
(
bufs
)
}
}
impl
Evented
for
UdpSocket
{
fn
register
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
selector_id
.
associate_selector
(
poll
)
?
;
self
.
sys
.
register
(
poll
token
interest
opts
)
}
fn
reregister
(
&
self
poll
:
&
Poll
token
:
Token
interest
:
Ready
opts
:
PollOpt
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
reregister
(
poll
token
interest
opts
)
}
fn
deregister
(
&
self
poll
:
&
Poll
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
sys
.
deregister
(
poll
)
}
}
impl
fmt
:
:
Debug
for
UdpSocket
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
sys
f
)
}
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
IntoRawFd
AsRawFd
FromRawFd
RawFd
}
;
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
impl
IntoRawFd
for
UdpSocket
{
fn
into_raw_fd
(
self
)
-
>
RawFd
{
self
.
sys
.
into_raw_fd
(
)
}
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
impl
AsRawFd
for
UdpSocket
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
sys
.
as_raw_fd
(
)
}
}
#
[
cfg
(
all
(
unix
not
(
target_os
=
"
fuchsia
"
)
)
)
]
impl
FromRawFd
for
UdpSocket
{
unsafe
fn
from_raw_fd
(
fd
:
RawFd
)
-
>
UdpSocket
{
UdpSocket
{
sys
:
FromRawFd
:
:
from_raw_fd
(
fd
)
selector_id
:
SelectorId
:
:
new
(
)
}
}
}
