use
{
anyhow
:
:
Result
regex
:
:
{
RegexSet
RegexSetBuilder
}
regex_test
:
:
{
CompiledRegex
RegexTest
TestResult
TestRunner
}
}
;
#
[
test
]
fn
default
(
)
-
>
Result
<
(
)
>
{
let
mut
runner
=
TestRunner
:
:
new
(
)
?
;
runner
.
expand
(
&
[
"
is_match
"
"
which
"
]
|
test
|
test
.
compiles
(
)
)
.
blacklist_iter
(
super
:
:
BLACKLIST
)
.
test_iter
(
crate
:
:
suite
(
)
?
.
iter
(
)
compiler
)
.
assert
(
)
;
Ok
(
(
)
)
}
fn
run_test
(
re
:
&
RegexSet
test
:
&
RegexTest
)
-
>
TestResult
{
let
hay
=
match
std
:
:
str
:
:
from_utf8
(
test
.
haystack
(
)
)
{
Ok
(
hay
)
=
>
hay
Err
(
err
)
=
>
{
return
TestResult
:
:
fail
(
&
format
!
(
"
haystack
is
not
valid
UTF
-
8
:
{
}
"
err
)
)
;
}
}
;
match
test
.
additional_name
(
)
{
"
is_match
"
=
>
TestResult
:
:
matched
(
re
.
is_match
(
hay
)
)
"
which
"
=
>
TestResult
:
:
which
(
re
.
matches
(
hay
)
.
iter
(
)
)
name
=
>
TestResult
:
:
fail
(
&
format
!
(
"
unrecognized
test
name
:
{
}
"
name
)
)
}
}
fn
compiler
(
test
:
&
RegexTest
_patterns
:
&
[
String
]
)
-
>
anyhow
:
:
Result
<
CompiledRegex
>
{
let
skip
=
Ok
(
CompiledRegex
:
:
skip
(
)
)
;
if
!
matches
!
(
test
.
search_kind
(
)
regex_test
:
:
SearchKind
:
:
Overlapping
)
{
return
skip
;
}
if
!
matches
!
(
test
.
match_kind
(
)
regex_test
:
:
MatchKind
:
:
All
)
{
return
skip
;
}
if
test
.
anchored
(
)
{
return
skip
;
}
let
bounds
=
test
.
bounds
(
)
;
if
!
(
bounds
.
start
=
=
0
&
&
bounds
.
end
=
=
test
.
haystack
(
)
.
len
(
)
)
{
return
skip
;
}
if
!
test
.
utf8
(
)
{
return
skip
;
}
if
test
.
unicode
(
)
&
&
!
cfg
!
(
feature
=
"
unicode
"
)
{
return
skip
;
}
let
re
=
RegexSetBuilder
:
:
new
(
test
.
regexes
(
)
)
.
case_insensitive
(
test
.
case_insensitive
(
)
)
.
unicode
(
test
.
unicode
(
)
)
.
line_terminator
(
test
.
line_terminator
(
)
)
.
build
(
)
?
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
run_test
(
&
re
test
)
)
)
}
