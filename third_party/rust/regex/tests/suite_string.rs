use
{
anyhow
:
:
Result
regex
:
:
{
Regex
RegexBuilder
}
regex_test
:
:
{
CompiledRegex
Match
RegexTest
Span
TestResult
TestRunner
}
}
;
#
[
test
]
fn
default
(
)
-
>
Result
<
(
)
>
{
let
mut
runner
=
TestRunner
:
:
new
(
)
?
;
runner
.
expand
(
&
[
"
is_match
"
"
find
"
"
captures
"
]
|
test
|
test
.
compiles
(
)
)
.
blacklist_iter
(
super
:
:
BLACKLIST
)
.
test_iter
(
crate
:
:
suite
(
)
?
.
iter
(
)
compiler
)
.
assert
(
)
;
Ok
(
(
)
)
}
fn
run_test
(
re
:
&
Regex
test
:
&
RegexTest
)
-
>
TestResult
{
let
hay
=
match
std
:
:
str
:
:
from_utf8
(
test
.
haystack
(
)
)
{
Ok
(
hay
)
=
>
hay
Err
(
err
)
=
>
{
return
TestResult
:
:
fail
(
&
format
!
(
"
haystack
is
not
valid
UTF
-
8
:
{
}
"
err
)
)
;
}
}
;
match
test
.
additional_name
(
)
{
"
is_match
"
=
>
TestResult
:
:
matched
(
re
.
is_match
(
hay
)
)
"
find
"
=
>
TestResult
:
:
matches
(
re
.
find_iter
(
hay
)
.
take
(
test
.
match_limit
(
)
.
unwrap_or
(
std
:
:
usize
:
:
MAX
)
)
.
map
(
|
m
|
Match
{
id
:
0
span
:
Span
{
start
:
m
.
start
(
)
end
:
m
.
end
(
)
}
}
)
)
"
captures
"
=
>
{
let
it
=
re
.
captures_iter
(
hay
)
.
take
(
test
.
match_limit
(
)
.
unwrap_or
(
std
:
:
usize
:
:
MAX
)
)
.
map
(
|
caps
|
testify_captures
(
&
caps
)
)
;
TestResult
:
:
captures
(
it
)
}
name
=
>
TestResult
:
:
fail
(
&
format
!
(
"
unrecognized
test
name
:
{
}
"
name
)
)
}
}
fn
compiler
(
test
:
&
RegexTest
_patterns
:
&
[
String
]
)
-
>
anyhow
:
:
Result
<
CompiledRegex
>
{
let
skip
=
Ok
(
CompiledRegex
:
:
skip
(
)
)
;
let
pattern
=
match
test
.
regexes
(
)
.
len
(
)
{
1
=
>
&
test
.
regexes
(
)
[
0
]
_
=
>
return
skip
}
;
if
!
matches
!
(
test
.
search_kind
(
)
regex_test
:
:
SearchKind
:
:
Leftmost
)
{
return
skip
;
}
if
!
matches
!
(
test
.
match_kind
(
)
regex_test
:
:
MatchKind
:
:
LeftmostFirst
)
{
return
skip
;
}
if
test
.
anchored
(
)
&
&
test
.
match_limit
(
)
!
=
Some
(
1
)
{
return
skip
;
}
let
bounds
=
test
.
bounds
(
)
;
if
!
(
bounds
.
start
=
=
0
&
&
bounds
.
end
=
=
test
.
haystack
(
)
.
len
(
)
)
{
return
skip
;
}
if
!
test
.
utf8
(
)
{
return
skip
;
}
if
test
.
unicode
(
)
&
&
!
cfg
!
(
feature
=
"
unicode
"
)
{
return
skip
;
}
let
re
=
RegexBuilder
:
:
new
(
pattern
)
.
case_insensitive
(
test
.
case_insensitive
(
)
)
.
unicode
(
test
.
unicode
(
)
)
.
line_terminator
(
test
.
line_terminator
(
)
)
.
build
(
)
?
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
run_test
(
&
re
test
)
)
)
}
fn
testify_captures
(
caps
:
&
regex
:
:
Captures
<
'
_
>
)
-
>
regex_test
:
:
Captures
{
let
spans
=
caps
.
iter
(
)
.
map
(
|
group
|
{
group
.
map
(
|
m
|
regex_test
:
:
Span
{
start
:
m
.
start
(
)
end
:
m
.
end
(
)
}
)
}
)
;
regex_test
:
:
Captures
:
:
new
(
0
spans
)
.
unwrap
(
)
}
