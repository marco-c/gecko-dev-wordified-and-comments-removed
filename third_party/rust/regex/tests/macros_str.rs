macro_rules
!
text
{
(
text
:
expr
)
=
>
{
text
}
}
macro_rules
!
t
{
(
text
:
expr
)
=
>
{
text
!
(
text
)
}
}
macro_rules
!
match_text
{
(
text
:
expr
)
=
>
{
text
.
as_str
(
)
}
}
macro_rules
!
use_
{
(
(
path
:
tt
)
*
)
=
>
{
use
regex
:
:
(
path
)
*
;
}
}
macro_rules
!
empty_vec
{
(
)
=
>
{
<
Vec
<
&
str
>
>
:
:
new
(
)
}
}
macro_rules
!
bytes
{
(
text
:
expr
)
=
>
{
std
:
:
str
:
:
from_utf8
(
text
.
as_ref
(
)
)
.
unwrap
(
)
}
}
macro_rules
!
no_expand
{
(
text
:
expr
)
=
>
{
{
use
regex
:
:
NoExpand
;
NoExpand
(
text
!
(
text
)
)
}
}
}
macro_rules
!
show
{
(
text
:
expr
)
=
>
{
text
}
}
macro_rules
!
expand
{
(
name
:
ident
re
:
expr
text
:
expr
expand
:
expr
expected
:
expr
)
=
>
{
#
[
test
]
fn
name
(
)
{
let
re
=
regex
!
(
re
)
;
let
cap
=
re
.
captures
(
t
!
(
text
)
)
.
unwrap
(
)
;
let
mut
got
=
String
:
:
new
(
)
;
cap
.
expand
(
t
!
(
expand
)
&
mut
got
)
;
assert_eq
!
(
show
!
(
t
!
(
expected
)
)
show
!
(
&
*
got
)
)
;
}
}
}
#
[
cfg
(
feature
=
"
pattern
"
)
]
macro_rules
!
searcher_expr
{
(
e
:
expr
)
=
>
(
e
)
}
#
[
cfg
(
not
(
feature
=
"
pattern
"
)
)
]
macro_rules
!
searcher_expr
{
(
e
:
expr
)
=
>
(
{
}
)
}
