use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
cmp
;
use
std
:
:
sync
:
:
Arc
;
use
thread_local
:
:
CachedThreadLocal
;
use
syntax
:
:
{
Expr
ExprBuilder
Literals
}
;
use
backtrack
;
use
compile
:
:
Compiler
;
use
dfa
;
use
error
:
:
Error
;
use
input
:
:
{
ByteInput
CharInput
}
;
use
literals
:
:
LiteralSearcher
;
use
pikevm
;
use
prog
:
:
Program
;
use
re_builder
:
:
RegexOptions
;
use
re_bytes
;
use
re_set
;
use
re_trait
:
:
{
RegularExpression
Slot
Locations
as_slots
}
;
use
re_unicode
;
use
utf8
:
:
next_utf8
;
pub
struct
Exec
{
ro
:
Arc
<
ExecReadOnly
>
cache
:
CachedThreadLocal
<
ProgramCache
>
}
#
[
derive
(
Debug
)
]
pub
struct
ExecNoSync
<
'
c
>
{
ro
:
&
'
c
Arc
<
ExecReadOnly
>
cache
:
&
'
c
ProgramCache
}
pub
struct
ExecNoSyncStr
<
'
c
>
(
ExecNoSync
<
'
c
>
)
;
#
[
derive
(
Debug
)
]
struct
ExecReadOnly
{
res
:
Vec
<
String
>
nfa
:
Program
dfa
:
Program
dfa_reverse
:
Program
suffixes
:
LiteralSearcher
match_type
:
MatchType
}
pub
struct
ExecBuilder
{
options
:
RegexOptions
match_type
:
Option
<
MatchType
>
bytes
:
bool
only_utf8
:
bool
}
struct
Parsed
{
exprs
:
Vec
<
Expr
>
prefixes
:
Literals
suffixes
:
Literals
bytes
:
bool
}
impl
ExecBuilder
{
pub
fn
new
(
re
:
&
str
)
-
>
Self
{
Self
:
:
new_many
(
&
[
re
]
)
}
pub
fn
new_many
<
I
S
>
(
res
:
I
)
-
>
Self
where
S
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
S
>
{
let
mut
opts
=
RegexOptions
:
:
default
(
)
;
opts
.
pats
=
res
.
into_iter
(
)
.
map
(
|
s
|
s
.
as_ref
(
)
.
to_owned
(
)
)
.
collect
(
)
;
Self
:
:
new_options
(
opts
)
}
pub
fn
new_options
(
opts
:
RegexOptions
)
-
>
Self
{
ExecBuilder
{
options
:
opts
match_type
:
None
bytes
:
false
only_utf8
:
true
}
}
pub
fn
automatic
(
mut
self
)
-
>
Self
{
self
.
match_type
=
None
;
self
}
pub
fn
nfa
(
mut
self
)
-
>
Self
{
self
.
match_type
=
Some
(
MatchType
:
:
Nfa
(
MatchNfaType
:
:
PikeVM
)
)
;
self
}
pub
fn
bounded_backtracking
(
mut
self
)
-
>
Self
{
self
.
match_type
=
Some
(
MatchType
:
:
Nfa
(
MatchNfaType
:
:
Backtrack
)
)
;
self
}
pub
fn
bytes
(
mut
self
yes
:
bool
)
-
>
Self
{
self
.
bytes
=
yes
;
self
}
pub
fn
only_utf8
(
mut
self
yes
:
bool
)
-
>
Self
{
self
.
only_utf8
=
yes
;
self
}
pub
fn
unicode
(
mut
self
yes
:
bool
)
-
>
Self
{
self
.
options
.
unicode
=
yes
;
self
}
fn
parse
(
&
self
)
-
>
Result
<
Parsed
Error
>
{
let
mut
exprs
=
Vec
:
:
with_capacity
(
self
.
options
.
pats
.
len
(
)
)
;
let
mut
prefixes
=
Some
(
Literals
:
:
empty
(
)
)
;
let
mut
suffixes
=
Some
(
Literals
:
:
empty
(
)
)
;
let
mut
bytes
=
false
;
for
pat
in
&
self
.
options
.
pats
{
let
parser
=
ExprBuilder
:
:
new
(
)
.
case_insensitive
(
self
.
options
.
case_insensitive
)
.
multi_line
(
self
.
options
.
multi_line
)
.
dot_matches_new_line
(
self
.
options
.
dot_matches_new_line
)
.
swap_greed
(
self
.
options
.
swap_greed
)
.
ignore_whitespace
(
self
.
options
.
ignore_whitespace
)
.
unicode
(
self
.
options
.
unicode
)
.
allow_bytes
(
!
self
.
only_utf8
)
;
let
expr
=
try
!
(
parser
.
parse
(
pat
)
)
;
bytes
=
bytes
|
|
expr
.
has_bytes
(
)
;
if
!
expr
.
is_anchored_start
(
)
&
&
expr
.
has_anchored_start
(
)
{
prefixes
=
None
;
}
prefixes
=
prefixes
.
and_then
(
|
mut
prefixes
|
{
if
!
prefixes
.
union_prefixes
(
&
expr
)
{
None
}
else
{
Some
(
prefixes
)
}
}
)
;
if
!
expr
.
is_anchored_end
(
)
&
&
expr
.
has_anchored_end
(
)
{
suffixes
=
None
;
}
suffixes
=
suffixes
.
and_then
(
|
mut
suffixes
|
{
if
!
suffixes
.
union_suffixes
(
&
expr
)
{
None
}
else
{
Some
(
suffixes
)
}
}
)
;
exprs
.
push
(
expr
)
;
}
Ok
(
Parsed
{
exprs
:
exprs
prefixes
:
prefixes
.
unwrap_or
(
Literals
:
:
empty
(
)
)
suffixes
:
suffixes
.
unwrap_or
(
Literals
:
:
empty
(
)
)
bytes
:
bytes
}
)
}
pub
fn
build
(
self
)
-
>
Result
<
Exec
Error
>
{
if
self
.
options
.
pats
.
is_empty
(
)
{
let
ro
=
Arc
:
:
new
(
ExecReadOnly
{
res
:
vec
!
[
]
nfa
:
Program
:
:
new
(
)
dfa
:
Program
:
:
new
(
)
dfa_reverse
:
Program
:
:
new
(
)
suffixes
:
LiteralSearcher
:
:
empty
(
)
match_type
:
MatchType
:
:
Nothing
}
)
;
return
Ok
(
Exec
{
ro
:
ro
cache
:
CachedThreadLocal
:
:
new
(
)
}
)
;
}
let
parsed
=
try
!
(
self
.
parse
(
)
)
;
let
mut
nfa
=
try
!
(
Compiler
:
:
new
(
)
.
size_limit
(
self
.
options
.
size_limit
)
.
bytes
(
self
.
bytes
|
|
parsed
.
bytes
)
.
only_utf8
(
self
.
only_utf8
)
.
compile
(
&
parsed
.
exprs
)
)
;
let
mut
dfa
=
try
!
(
Compiler
:
:
new
(
)
.
size_limit
(
self
.
options
.
size_limit
)
.
dfa
(
true
)
.
only_utf8
(
self
.
only_utf8
)
.
compile
(
&
parsed
.
exprs
)
)
;
let
mut
dfa_reverse
=
try
!
(
Compiler
:
:
new
(
)
.
size_limit
(
self
.
options
.
size_limit
)
.
dfa
(
true
)
.
only_utf8
(
self
.
only_utf8
)
.
reverse
(
true
)
.
compile
(
&
parsed
.
exprs
)
)
;
let
prefixes
=
parsed
.
prefixes
.
unambiguous_prefixes
(
)
;
let
suffixes
=
parsed
.
suffixes
.
unambiguous_suffixes
(
)
;
nfa
.
prefixes
=
LiteralSearcher
:
:
prefixes
(
prefixes
)
;
dfa
.
prefixes
=
nfa
.
prefixes
.
clone
(
)
;
dfa
.
dfa_size_limit
=
self
.
options
.
dfa_size_limit
;
dfa_reverse
.
dfa_size_limit
=
self
.
options
.
dfa_size_limit
;
let
mut
ro
=
ExecReadOnly
{
res
:
self
.
options
.
pats
nfa
:
nfa
dfa
:
dfa
dfa_reverse
:
dfa_reverse
suffixes
:
LiteralSearcher
:
:
suffixes
(
suffixes
)
match_type
:
MatchType
:
:
Nothing
}
;
ro
.
match_type
=
ro
.
choose_match_type
(
self
.
match_type
)
;
let
ro
=
Arc
:
:
new
(
ro
)
;
Ok
(
Exec
{
ro
:
ro
cache
:
CachedThreadLocal
:
:
new
(
)
}
)
}
}
impl
<
'
c
>
RegularExpression
for
ExecNoSyncStr
<
'
c
>
{
type
Text
=
str
;
fn
slots_len
(
&
self
)
-
>
usize
{
self
.
0
.
slots_len
(
)
}
fn
next_after_empty
(
&
self
text
:
&
str
i
:
usize
)
-
>
usize
{
next_utf8
(
text
.
as_bytes
(
)
i
)
}
#
[
inline
(
always
)
]
fn
shortest_match_at
(
&
self
text
:
&
str
start
:
usize
)
-
>
Option
<
usize
>
{
self
.
0
.
shortest_match_at
(
text
.
as_bytes
(
)
start
)
}
#
[
inline
(
always
)
]
fn
is_match_at
(
&
self
text
:
&
str
start
:
usize
)
-
>
bool
{
self
.
0
.
is_match_at
(
text
.
as_bytes
(
)
start
)
}
#
[
inline
(
always
)
]
fn
find_at
(
&
self
text
:
&
str
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
self
.
0
.
find_at
(
text
.
as_bytes
(
)
start
)
}
#
[
inline
(
always
)
]
fn
read_captures_at
(
&
self
locs
:
&
mut
Locations
text
:
&
str
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
self
.
0
.
read_captures_at
(
locs
text
.
as_bytes
(
)
start
)
}
}
impl
<
'
c
>
RegularExpression
for
ExecNoSync
<
'
c
>
{
type
Text
=
[
u8
]
;
fn
slots_len
(
&
self
)
-
>
usize
{
self
.
ro
.
nfa
.
captures
.
len
(
)
*
2
}
fn
next_after_empty
(
&
self
_text
:
&
[
u8
]
i
:
usize
)
-
>
usize
{
i
+
1
}
#
[
inline
(
always
)
]
fn
shortest_match_at
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
usize
>
{
if
!
self
.
is_anchor_end_match
(
text
)
{
return
None
;
}
match
self
.
ro
.
match_type
{
MatchType
:
:
Literal
(
ty
)
=
>
{
self
.
find_literals
(
ty
text
start
)
.
map
(
|
(
_
e
)
|
e
)
}
MatchType
:
:
Dfa
|
MatchType
:
:
DfaMany
=
>
{
match
self
.
shortest_dfa
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
end
)
=
>
Some
(
end
)
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
self
.
shortest_nfa
(
text
start
)
}
}
MatchType
:
:
DfaAnchoredReverse
=
>
{
match
dfa
:
:
Fsm
:
:
reverse
(
&
self
.
ro
.
dfa_reverse
&
self
.
cache
true
&
text
[
start
.
.
]
text
.
len
(
)
)
{
dfa
:
:
Result
:
:
Match
(
_
)
=
>
Some
(
text
.
len
(
)
)
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
self
.
shortest_nfa
(
text
start
)
}
}
MatchType
:
:
DfaSuffix
=
>
{
match
self
.
shortest_dfa_reverse_suffix
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
e
)
=
>
Some
(
e
)
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
self
.
shortest_nfa
(
text
start
)
}
}
MatchType
:
:
Nfa
(
ty
)
=
>
self
.
shortest_nfa_type
(
ty
text
start
)
MatchType
:
:
Nothing
=
>
None
}
}
#
[
inline
(
always
)
]
fn
is_match_at
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
if
!
self
.
is_anchor_end_match
(
text
)
{
return
false
;
}
match
self
.
ro
.
match_type
{
MatchType
:
:
Literal
(
ty
)
=
>
{
self
.
find_literals
(
ty
text
start
)
.
is_some
(
)
}
MatchType
:
:
Dfa
|
MatchType
:
:
DfaMany
=
>
{
match
self
.
shortest_dfa
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
_
)
=
>
true
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
false
dfa
:
:
Result
:
:
Quit
=
>
self
.
match_nfa
(
text
start
)
}
}
MatchType
:
:
DfaAnchoredReverse
=
>
{
match
dfa
:
:
Fsm
:
:
reverse
(
&
self
.
ro
.
dfa_reverse
&
self
.
cache
true
&
text
[
start
.
.
]
text
.
len
(
)
)
{
dfa
:
:
Result
:
:
Match
(
_
)
=
>
true
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
false
dfa
:
:
Result
:
:
Quit
=
>
self
.
match_nfa
(
text
start
)
}
}
MatchType
:
:
DfaSuffix
=
>
{
match
self
.
shortest_dfa_reverse_suffix
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
_
)
=
>
true
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
false
dfa
:
:
Result
:
:
Quit
=
>
self
.
match_nfa
(
text
start
)
}
}
MatchType
:
:
Nfa
(
ty
)
=
>
self
.
match_nfa_type
(
ty
text
start
)
MatchType
:
:
Nothing
=
>
false
}
}
#
[
inline
(
always
)
]
fn
find_at
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
if
!
self
.
is_anchor_end_match
(
text
)
{
return
None
;
}
match
self
.
ro
.
match_type
{
MatchType
:
:
Literal
(
ty
)
=
>
{
self
.
find_literals
(
ty
text
start
)
}
MatchType
:
:
Dfa
=
>
{
match
self
.
find_dfa_forward
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
(
s
e
)
)
=
>
Some
(
(
s
e
)
)
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
{
self
.
find_nfa
(
MatchNfaType
:
:
Auto
text
start
)
}
}
}
MatchType
:
:
DfaAnchoredReverse
=
>
{
match
self
.
find_dfa_anchored_reverse
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
(
s
e
)
)
=
>
Some
(
(
s
e
)
)
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
{
self
.
find_nfa
(
MatchNfaType
:
:
Auto
text
start
)
}
}
}
MatchType
:
:
DfaSuffix
=
>
{
match
self
.
find_dfa_reverse_suffix
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
(
s
e
)
)
=
>
Some
(
(
s
e
)
)
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
{
self
.
find_nfa
(
MatchNfaType
:
:
Auto
text
start
)
}
}
}
MatchType
:
:
Nfa
(
ty
)
=
>
self
.
find_nfa
(
ty
text
start
)
MatchType
:
:
Nothing
=
>
None
MatchType
:
:
DfaMany
=
>
{
unreachable
!
(
"
BUG
:
RegexSet
cannot
be
used
with
find
"
)
}
}
}
fn
read_captures_at
(
&
self
locs
:
&
mut
Locations
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
let
slots
=
as_slots
(
locs
)
;
for
slot
in
slots
.
iter_mut
(
)
{
*
slot
=
None
;
}
match
slots
.
len
(
)
{
0
=
>
return
self
.
find_at
(
text
start
)
2
=
>
{
return
self
.
find_at
(
text
start
)
.
map
(
|
(
s
e
)
|
{
slots
[
0
]
=
Some
(
s
)
;
slots
[
1
]
=
Some
(
e
)
;
(
s
e
)
}
)
;
}
_
=
>
{
}
}
if
!
self
.
is_anchor_end_match
(
text
)
{
return
None
;
}
match
self
.
ro
.
match_type
{
MatchType
:
:
Literal
(
ty
)
=
>
{
self
.
find_literals
(
ty
text
start
)
.
and_then
(
|
(
s
e
)
|
{
self
.
captures_nfa_with_match
(
slots
text
s
e
)
}
)
}
MatchType
:
:
Dfa
=
>
{
match
self
.
find_dfa_forward
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
(
s
e
)
)
=
>
{
self
.
captures_nfa_with_match
(
slots
text
s
e
)
}
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
self
.
captures_nfa
(
slots
text
start
)
}
}
MatchType
:
:
DfaAnchoredReverse
=
>
{
match
self
.
find_dfa_anchored_reverse
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
(
s
e
)
)
=
>
{
self
.
captures_nfa_with_match
(
slots
text
s
e
)
}
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
self
.
captures_nfa
(
slots
text
start
)
}
}
MatchType
:
:
DfaSuffix
=
>
{
match
self
.
find_dfa_reverse_suffix
(
text
start
)
{
dfa
:
:
Result
:
:
Match
(
(
s
e
)
)
=
>
{
self
.
captures_nfa_with_match
(
slots
text
s
e
)
}
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
None
dfa
:
:
Result
:
:
Quit
=
>
self
.
captures_nfa
(
slots
text
start
)
}
}
MatchType
:
:
Nfa
(
ty
)
=
>
{
self
.
captures_nfa_type
(
ty
slots
text
start
)
}
MatchType
:
:
Nothing
=
>
None
MatchType
:
:
DfaMany
=
>
{
unreachable
!
(
"
BUG
:
RegexSet
cannot
be
used
with
captures
"
)
}
}
}
}
impl
<
'
c
>
ExecNoSync
<
'
c
>
{
#
[
inline
(
always
)
]
fn
find_literals
(
&
self
ty
:
MatchLiteralType
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
use
self
:
:
MatchLiteralType
:
:
*
;
match
ty
{
Unanchored
=
>
{
let
lits
=
&
self
.
ro
.
nfa
.
prefixes
;
lits
.
find
(
&
text
[
start
.
.
]
)
.
map
(
|
(
s
e
)
|
(
start
+
s
start
+
e
)
)
}
AnchoredStart
=
>
{
let
lits
=
&
self
.
ro
.
nfa
.
prefixes
;
lits
.
find_start
(
&
text
[
start
.
.
]
)
.
map
(
|
(
s
e
)
|
(
start
+
s
start
+
e
)
)
}
AnchoredEnd
=
>
{
let
lits
=
&
self
.
ro
.
suffixes
;
lits
.
find_end
(
&
text
[
start
.
.
]
)
.
map
(
|
(
s
e
)
|
(
start
+
s
start
+
e
)
)
}
}
}
#
[
inline
(
always
)
]
fn
find_dfa_forward
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
dfa
:
:
Result
<
(
usize
usize
)
>
{
use
dfa
:
:
Result
:
:
*
;
let
end
=
match
dfa
:
:
Fsm
:
:
forward
(
&
self
.
ro
.
dfa
&
self
.
cache
false
text
start
)
{
NoMatch
(
i
)
=
>
return
NoMatch
(
i
)
Quit
=
>
return
Quit
Match
(
end
)
if
start
=
=
end
=
>
return
Match
(
(
start
start
)
)
Match
(
end
)
=
>
end
}
;
match
dfa
:
:
Fsm
:
:
reverse
(
&
self
.
ro
.
dfa_reverse
&
self
.
cache
false
&
text
[
start
.
.
]
end
-
start
)
{
Match
(
s
)
=
>
Match
(
(
start
+
s
end
)
)
NoMatch
(
i
)
=
>
NoMatch
(
i
)
Quit
=
>
Quit
}
}
#
[
inline
(
always
)
]
fn
find_dfa_anchored_reverse
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
dfa
:
:
Result
<
(
usize
usize
)
>
{
use
dfa
:
:
Result
:
:
*
;
match
dfa
:
:
Fsm
:
:
reverse
(
&
self
.
ro
.
dfa_reverse
&
self
.
cache
false
&
text
[
start
.
.
]
text
.
len
(
)
-
start
)
{
Match
(
s
)
=
>
Match
(
(
start
+
s
text
.
len
(
)
)
)
NoMatch
(
i
)
=
>
NoMatch
(
i
)
Quit
=
>
Quit
}
}
#
[
inline
(
always
)
]
fn
shortest_dfa
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
dfa
:
:
Result
<
usize
>
{
dfa
:
:
Fsm
:
:
forward
(
&
self
.
ro
.
dfa
&
self
.
cache
true
text
start
)
}
#
[
inline
(
always
)
]
fn
shortest_dfa_reverse_suffix
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
dfa
:
:
Result
<
usize
>
{
match
self
.
exec_dfa_reverse_suffix
(
text
start
)
{
None
=
>
self
.
shortest_dfa
(
text
start
)
Some
(
r
)
=
>
r
.
map
(
|
(
_
end
)
|
end
)
}
}
#
[
inline
(
always
)
]
fn
exec_dfa_reverse_suffix
(
&
self
text
:
&
[
u8
]
original_start
:
usize
)
-
>
Option
<
dfa
:
:
Result
<
(
usize
usize
)
>
>
{
use
dfa
:
:
Result
:
:
*
;
let
lcs
=
self
.
ro
.
suffixes
.
lcs
(
)
;
debug_assert
!
(
lcs
.
len
(
)
>
=
1
)
;
let
mut
start
=
original_start
;
let
mut
end
=
start
;
while
end
<
=
text
.
len
(
)
{
start
=
end
;
end
=
end
+
match
lcs
.
find
(
&
text
[
end
.
.
]
)
{
None
=
>
return
Some
(
NoMatch
(
text
.
len
(
)
)
)
Some
(
start
)
=
>
start
+
lcs
.
len
(
)
}
;
match
dfa
:
:
Fsm
:
:
reverse
(
&
self
.
ro
.
dfa_reverse
&
self
.
cache
false
&
text
[
start
.
.
end
]
end
-
start
)
{
Match
(
0
)
|
NoMatch
(
0
)
=
>
return
None
Match
(
s
)
=
>
return
Some
(
Match
(
(
s
+
start
end
)
)
)
NoMatch
(
_
)
=
>
continue
Quit
=
>
return
Some
(
Quit
)
}
;
}
Some
(
NoMatch
(
text
.
len
(
)
)
)
}
#
[
inline
(
always
)
]
fn
find_dfa_reverse_suffix
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
dfa
:
:
Result
<
(
usize
usize
)
>
{
use
dfa
:
:
Result
:
:
*
;
let
match_start
=
match
self
.
exec_dfa_reverse_suffix
(
text
start
)
{
None
=
>
return
self
.
find_dfa_forward
(
text
start
)
Some
(
Match
(
(
start
_
)
)
)
=
>
start
Some
(
r
)
=
>
return
r
}
;
match
dfa
:
:
Fsm
:
:
forward
(
&
self
.
ro
.
dfa
&
self
.
cache
false
text
match_start
)
{
NoMatch
(
_
)
=
>
panic
!
(
"
BUG
:
reverse
match
implies
forward
match
"
)
Quit
=
>
Quit
Match
(
e
)
=
>
Match
(
(
match_start
e
)
)
}
}
fn
match_nfa
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
self
.
match_nfa_type
(
MatchNfaType
:
:
Auto
text
start
)
}
fn
match_nfa_type
(
&
self
ty
:
MatchNfaType
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
self
.
exec_nfa
(
ty
&
mut
[
false
]
&
mut
[
]
true
text
start
)
}
fn
shortest_nfa
(
&
self
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
usize
>
{
self
.
shortest_nfa_type
(
MatchNfaType
:
:
Auto
text
start
)
}
fn
shortest_nfa_type
(
&
self
ty
:
MatchNfaType
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
usize
>
{
let
mut
slots
=
[
None
None
]
;
if
self
.
exec_nfa
(
ty
&
mut
[
false
]
&
mut
slots
true
text
start
)
{
slots
[
1
]
}
else
{
None
}
}
fn
find_nfa
(
&
self
ty
:
MatchNfaType
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
let
mut
slots
=
[
None
None
]
;
if
self
.
exec_nfa
(
ty
&
mut
[
false
]
&
mut
slots
false
text
start
)
{
match
(
slots
[
0
]
slots
[
1
]
)
{
(
Some
(
s
)
Some
(
e
)
)
=
>
Some
(
(
s
e
)
)
_
=
>
None
}
}
else
{
None
}
}
fn
captures_nfa_with_match
(
&
self
slots
:
&
mut
[
Slot
]
text
:
&
[
u8
]
match_start
:
usize
match_end
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
let
e
=
cmp
:
:
min
(
next_utf8
(
text
match_end
)
text
.
len
(
)
)
;
self
.
captures_nfa
(
slots
&
text
[
.
.
e
]
match_start
)
}
fn
captures_nfa
(
&
self
slots
:
&
mut
[
Slot
]
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
self
.
captures_nfa_type
(
MatchNfaType
:
:
Auto
slots
text
start
)
}
fn
captures_nfa_type
(
&
self
ty
:
MatchNfaType
slots
:
&
mut
[
Slot
]
text
:
&
[
u8
]
start
:
usize
)
-
>
Option
<
(
usize
usize
)
>
{
if
self
.
exec_nfa
(
ty
&
mut
[
false
]
slots
false
text
start
)
{
match
(
slots
[
0
]
slots
[
1
]
)
{
(
Some
(
s
)
Some
(
e
)
)
=
>
Some
(
(
s
e
)
)
_
=
>
None
}
}
else
{
None
}
}
fn
exec_nfa
(
&
self
mut
ty
:
MatchNfaType
matches
:
&
mut
[
bool
]
slots
:
&
mut
[
Slot
]
quit_after_match
:
bool
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
use
self
:
:
MatchNfaType
:
:
*
;
if
let
Auto
=
ty
{
if
backtrack
:
:
should_exec
(
self
.
ro
.
nfa
.
len
(
)
text
.
len
(
)
)
{
ty
=
Backtrack
;
}
else
{
ty
=
PikeVM
;
}
}
match
ty
{
Auto
=
>
unreachable
!
(
)
Backtrack
=
>
self
.
exec_backtrack
(
matches
slots
text
start
)
PikeVM
=
>
{
self
.
exec_pikevm
(
matches
slots
quit_after_match
text
start
)
}
}
}
fn
exec_pikevm
(
&
self
matches
:
&
mut
[
bool
]
slots
:
&
mut
[
Slot
]
quit_after_match
:
bool
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
if
self
.
ro
.
nfa
.
uses_bytes
(
)
{
pikevm
:
:
Fsm
:
:
exec
(
&
self
.
ro
.
nfa
&
self
.
cache
matches
slots
quit_after_match
ByteInput
:
:
new
(
text
self
.
ro
.
nfa
.
only_utf8
)
start
)
}
else
{
pikevm
:
:
Fsm
:
:
exec
(
&
self
.
ro
.
nfa
&
self
.
cache
matches
slots
quit_after_match
CharInput
:
:
new
(
text
)
start
)
}
}
fn
exec_backtrack
(
&
self
matches
:
&
mut
[
bool
]
slots
:
&
mut
[
Slot
]
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
if
self
.
ro
.
nfa
.
uses_bytes
(
)
{
backtrack
:
:
Bounded
:
:
exec
(
&
self
.
ro
.
nfa
&
self
.
cache
matches
slots
ByteInput
:
:
new
(
text
self
.
ro
.
nfa
.
only_utf8
)
start
)
}
else
{
backtrack
:
:
Bounded
:
:
exec
(
&
self
.
ro
.
nfa
&
self
.
cache
matches
slots
CharInput
:
:
new
(
text
)
start
)
}
}
pub
fn
many_matches_at
(
&
self
matches
:
&
mut
[
bool
]
text
:
&
[
u8
]
start
:
usize
)
-
>
bool
{
use
self
:
:
MatchType
:
:
*
;
if
!
self
.
is_anchor_end_match
(
text
)
{
return
false
;
}
match
self
.
ro
.
match_type
{
Literal
(
ty
)
=
>
{
debug_assert
!
(
matches
.
len
(
)
=
=
1
)
;
matches
[
0
]
=
self
.
find_literals
(
ty
text
start
)
.
is_some
(
)
;
matches
[
0
]
}
Dfa
|
DfaAnchoredReverse
|
DfaSuffix
|
DfaMany
=
>
{
match
dfa
:
:
Fsm
:
:
forward_many
(
&
self
.
ro
.
dfa
&
self
.
cache
matches
text
start
)
{
dfa
:
:
Result
:
:
Match
(
_
)
=
>
true
dfa
:
:
Result
:
:
NoMatch
(
_
)
=
>
false
dfa
:
:
Result
:
:
Quit
=
>
{
self
.
exec_nfa
(
MatchNfaType
:
:
Auto
matches
&
mut
[
]
false
text
start
)
}
}
}
Nfa
(
ty
)
=
>
self
.
exec_nfa
(
ty
matches
&
mut
[
]
false
text
start
)
Nothing
=
>
false
}
}
#
[
inline
(
always
)
]
fn
is_anchor_end_match
(
&
self
text
:
&
[
u8
]
)
-
>
bool
{
if
text
.
len
(
)
>
(
1
<
<
20
)
&
&
self
.
ro
.
nfa
.
is_anchored_end
{
let
lcs
=
self
.
ro
.
suffixes
.
lcs
(
)
;
if
lcs
.
len
(
)
>
=
1
&
&
!
lcs
.
is_suffix
(
text
)
{
return
false
;
}
}
true
}
pub
fn
capture_name_idx
(
&
self
)
-
>
&
Arc
<
HashMap
<
String
usize
>
>
{
&
self
.
ro
.
nfa
.
capture_name_idx
}
}
impl
<
'
c
>
ExecNoSyncStr
<
'
c
>
{
pub
fn
capture_name_idx
(
&
self
)
-
>
&
Arc
<
HashMap
<
String
usize
>
>
{
self
.
0
.
capture_name_idx
(
)
}
}
impl
Exec
{
#
[
inline
(
always
)
]
pub
fn
searcher
(
&
self
)
-
>
ExecNoSync
{
let
create
=
|
|
Box
:
:
new
(
RefCell
:
:
new
(
ProgramCacheInner
:
:
new
(
&
self
.
ro
)
)
)
;
ExecNoSync
{
ro
:
&
self
.
ro
cache
:
self
.
cache
.
get_or
(
create
)
}
}
#
[
inline
(
always
)
]
pub
fn
searcher_str
(
&
self
)
-
>
ExecNoSyncStr
{
ExecNoSyncStr
(
self
.
searcher
(
)
)
}
pub
fn
into_regex
(
self
)
-
>
re_unicode
:
:
Regex
{
re_unicode
:
:
Regex
:
:
from
(
self
)
}
pub
fn
into_regex_set
(
self
)
-
>
re_set
:
:
unicode
:
:
RegexSet
{
re_set
:
:
unicode
:
:
RegexSet
:
:
from
(
self
)
}
pub
fn
into_byte_regex
(
self
)
-
>
re_bytes
:
:
Regex
{
re_bytes
:
:
Regex
:
:
from
(
self
)
}
pub
fn
into_byte_regex_set
(
self
)
-
>
re_set
:
:
bytes
:
:
RegexSet
{
re_set
:
:
bytes
:
:
RegexSet
:
:
from
(
self
)
}
pub
fn
regex_strings
(
&
self
)
-
>
&
[
String
]
{
&
self
.
ro
.
res
}
pub
fn
capture_names
(
&
self
)
-
>
&
[
Option
<
String
>
]
{
&
self
.
ro
.
nfa
.
captures
}
pub
fn
capture_name_idx
(
&
self
)
-
>
&
Arc
<
HashMap
<
String
usize
>
>
{
&
self
.
ro
.
nfa
.
capture_name_idx
}
}
impl
Clone
for
Exec
{
fn
clone
(
&
self
)
-
>
Exec
{
Exec
{
ro
:
self
.
ro
.
clone
(
)
cache
:
CachedThreadLocal
:
:
new
(
)
}
}
}
impl
ExecReadOnly
{
fn
choose_match_type
(
&
self
hint
:
Option
<
MatchType
>
)
-
>
MatchType
{
use
self
:
:
MatchType
:
:
*
;
if
let
Some
(
Nfa
(
_
)
)
=
hint
{
return
hint
.
unwrap
(
)
;
}
if
self
.
nfa
.
insts
.
is_empty
(
)
{
return
Nothing
;
}
if
self
.
res
.
len
(
)
=
=
1
{
if
self
.
nfa
.
prefixes
.
complete
(
)
{
return
if
self
.
nfa
.
is_anchored_start
{
Literal
(
MatchLiteralType
:
:
AnchoredStart
)
}
else
{
Literal
(
MatchLiteralType
:
:
Unanchored
)
}
;
}
if
self
.
suffixes
.
complete
(
)
{
return
if
self
.
nfa
.
is_anchored_end
{
Literal
(
MatchLiteralType
:
:
AnchoredEnd
)
}
else
{
Literal
(
MatchLiteralType
:
:
Unanchored
)
}
;
}
}
if
dfa
:
:
can_exec
(
&
self
.
dfa
)
{
if
self
.
res
.
len
(
)
>
=
2
{
return
DfaMany
;
}
if
!
self
.
nfa
.
is_anchored_start
&
&
self
.
nfa
.
is_anchored_end
{
return
DfaAnchoredReverse
;
}
if
self
.
should_suffix_scan
(
)
{
return
DfaSuffix
;
}
return
Dfa
;
}
Nfa
(
MatchNfaType
:
:
Auto
)
}
fn
should_suffix_scan
(
&
self
)
-
>
bool
{
if
self
.
suffixes
.
is_empty
(
)
{
return
false
;
}
let
lcs_len
=
self
.
suffixes
.
lcs
(
)
.
char_len
(
)
;
lcs_len
>
=
3
&
&
lcs_len
>
self
.
dfa
.
prefixes
.
lcp
(
)
.
char_len
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
MatchType
{
Literal
(
MatchLiteralType
)
Dfa
DfaAnchoredReverse
DfaSuffix
DfaMany
Nfa
(
MatchNfaType
)
Nothing
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
MatchLiteralType
{
Unanchored
AnchoredStart
AnchoredEnd
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
MatchNfaType
{
Auto
Backtrack
PikeVM
}
pub
type
ProgramCache
=
RefCell
<
ProgramCacheInner
>
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
ProgramCacheInner
{
pub
pikevm
:
pikevm
:
:
Cache
pub
backtrack
:
backtrack
:
:
Cache
pub
dfa
:
dfa
:
:
Cache
pub
dfa_reverse
:
dfa
:
:
Cache
}
impl
ProgramCacheInner
{
fn
new
(
ro
:
&
ExecReadOnly
)
-
>
Self
{
ProgramCacheInner
{
pikevm
:
pikevm
:
:
Cache
:
:
new
(
&
ro
.
nfa
)
backtrack
:
backtrack
:
:
Cache
:
:
new
(
&
ro
.
nfa
)
dfa
:
dfa
:
:
Cache
:
:
new
(
&
ro
.
dfa
)
dfa_reverse
:
dfa
:
:
Cache
:
:
new
(
&
ro
.
dfa_reverse
)
}
}
}
