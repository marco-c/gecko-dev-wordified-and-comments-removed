#
!
[
deny
(
missing_docs
)
]
#
!
[
allow
(
ellipsis_inclusive_range_patterns
)
]
#
!
[
cfg_attr
(
test
deny
(
warnings
)
)
]
#
!
[
cfg_attr
(
feature
=
"
pattern
"
feature
(
pattern
)
)
]
#
[
cfg
(
not
(
feature
=
"
use_std
"
)
)
]
compile_error
!
(
"
use_std
feature
is
currently
required
to
build
this
crate
"
)
;
extern
crate
aho_corasick
;
extern
crate
memchr
;
extern
crate
thread_local
;
#
[
cfg
(
test
)
]
#
[
macro_use
]
extern
crate
quickcheck
;
extern
crate
regex_syntax
as
syntax
;
extern
crate
utf8_ranges
;
#
[
cfg
(
test
)
]
extern
crate
doc_comment
;
#
[
cfg
(
test
)
]
doc_comment
:
:
doctest
!
(
"
.
.
/
README
.
md
"
)
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
error
:
:
Error
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
re_builder
:
:
unicode
:
:
*
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
re_builder
:
:
set_unicode
:
:
*
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
re_set
:
:
unicode
:
:
*
;
#
[
cfg
(
feature
=
"
use_std
"
)
]
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
use
re_unicode
:
:
{
Regex
Match
Captures
CaptureNames
Matches
CaptureMatches
SubCaptureMatches
CaptureLocations
Locations
Replacer
ReplacerRef
NoExpand
Split
SplitN
escape
}
;
/
*
*
Match
regular
expressions
on
arbitrary
bytes
.
This
module
provides
a
nearly
identical
API
to
the
one
found
in
the
top
-
level
of
this
crate
.
There
are
two
important
differences
:
1
.
Matching
is
done
on
&
[
u8
]
instead
of
&
str
.
Additionally
Vec
<
u8
>
is
used
where
String
would
have
been
used
.
2
.
Unicode
support
can
be
disabled
even
when
disabling
it
would
result
in
matching
invalid
UTF
-
8
bytes
.
#
Example
:
match
null
terminated
string
This
shows
how
to
find
all
null
-
terminated
strings
in
a
slice
of
bytes
:
rust
#
use
regex
:
:
bytes
:
:
Regex
;
let
re
=
Regex
:
:
new
(
r
"
(
?
-
u
)
(
?
P
<
cstr
>
[
^
\
x00
]
+
)
\
x00
"
)
.
unwrap
(
)
;
let
text
=
b
"
foo
\
x00bar
\
x00baz
\
x00
"
;
/
/
Extract
all
of
the
strings
without
the
null
terminator
from
each
match
.
/
/
The
unwrap
is
OK
here
since
a
match
requires
the
cstr
capture
to
match
.
let
cstrs
:
Vec
<
&
[
u8
]
>
=
re
.
captures_iter
(
text
)
.
map
(
|
c
|
c
.
name
(
"
cstr
"
)
.
unwrap
(
)
.
as_bytes
(
)
)
.
collect
(
)
;
assert_eq
!
(
vec
!
[
&
b
"
foo
"
[
.
.
]
&
b
"
bar
"
[
.
.
]
&
b
"
baz
"
[
.
.
]
]
cstrs
)
;
#
Example
:
selectively
enable
Unicode
support
This
shows
how
to
match
an
arbitrary
byte
pattern
followed
by
a
UTF
-
8
encoded
string
(
e
.
g
.
to
extract
a
title
from
a
Matroska
file
)
:
rust
#
use
std
:
:
str
;
#
use
regex
:
:
bytes
:
:
Regex
;
let
re
=
Regex
:
:
new
(
r
"
(
?
-
u
)
\
x7b
\
xa9
(
?
:
[
\
x80
-
\
xfe
]
|
[
\
x40
-
\
xff
]
.
)
(
?
u
:
(
.
*
)
)
"
)
.
unwrap
(
)
;
let
text
=
b
"
\
x12
\
xd0
\
x3b
\
x5f
\
x7b
\
xa9
\
x85
\
xe2
\
x98
\
x83
\
x80
\
x98
\
x54
\
x76
\
x68
\
x65
"
;
let
caps
=
re
.
captures
(
text
)
.
unwrap
(
)
;
/
/
Notice
that
despite
the
.
*
at
the
end
it
will
only
match
valid
UTF
-
8
/
/
because
Unicode
mode
was
enabled
with
the
u
flag
.
Without
the
u
flag
/
/
the
.
*
would
match
the
rest
of
the
bytes
.
let
mat
=
caps
.
get
(
1
)
.
unwrap
(
)
;
assert_eq
!
(
(
7
10
)
(
mat
.
start
(
)
mat
.
end
(
)
)
)
;
/
/
If
there
was
a
match
Unicode
mode
guarantees
that
title
is
valid
UTF
-
8
.
let
title
=
str
:
:
from_utf8
(
&
caps
[
1
]
)
.
unwrap
(
)
;
assert_eq
!
(
"
"
title
)
;
In
general
if
the
Unicode
flag
is
enabled
in
a
capture
group
and
that
capture
is
part
of
the
overall
match
then
the
capture
is
*
guaranteed
*
to
be
valid
UTF
-
8
.
#
Syntax
The
supported
syntax
is
pretty
much
the
same
as
the
syntax
for
Unicode
regular
expressions
with
a
few
changes
that
make
sense
for
matching
arbitrary
bytes
:
1
.
The
u
flag
can
be
disabled
even
when
disabling
it
might
cause
the
regex
to
match
invalid
UTF
-
8
.
When
the
u
flag
is
disabled
the
regex
is
said
to
be
in
"
ASCII
compatible
"
mode
.
2
.
In
ASCII
compatible
mode
neither
Unicode
scalar
values
nor
Unicode
character
classes
are
allowed
.
3
.
In
ASCII
compatible
mode
Perl
character
classes
(
\
w
\
d
and
\
s
)
revert
to
their
typical
ASCII
definition
.
\
w
maps
to
[
[
:
word
:
]
]
\
d
maps
to
[
[
:
digit
:
]
]
and
\
s
maps
to
[
[
:
space
:
]
]
.
4
.
In
ASCII
compatible
mode
word
boundaries
use
the
ASCII
compatible
\
w
to
determine
whether
a
byte
is
a
word
byte
or
not
.
5
.
Hexadecimal
notation
can
be
used
to
specify
arbitrary
bytes
instead
of
Unicode
codepoints
.
For
example
in
ASCII
compatible
mode
\
xFF
matches
the
literal
byte
\
xFF
while
in
Unicode
mode
\
xFF
is
a
Unicode
codepoint
that
matches
its
UTF
-
8
encoding
of
\
xC3
\
xBF
.
Similarly
for
octal
notation
when
enabled
.
6
.
.
matches
any
*
byte
*
except
for
\
n
instead
of
any
Unicode
scalar
value
.
When
the
s
flag
is
enabled
.
matches
any
byte
.
#
Performance
In
general
one
should
expect
performance
on
&
[
u8
]
to
be
roughly
similar
to
performance
on
&
str
.
*
/
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
mod
bytes
{
pub
use
re_builder
:
:
bytes
:
:
*
;
pub
use
re_builder
:
:
set_bytes
:
:
*
;
pub
use
re_bytes
:
:
*
;
pub
use
re_set
:
:
bytes
:
:
*
;
}
mod
backtrack
;
mod
utf8
;
mod
compile
;
mod
dfa
;
mod
error
;
mod
exec
;
mod
expand
;
mod
freqs
;
mod
input
;
mod
literal
;
#
[
cfg
(
feature
=
"
pattern
"
)
]
mod
pattern
;
mod
pikevm
;
mod
prog
;
mod
re_builder
;
mod
re_bytes
;
mod
re_set
;
mod
re_trait
;
mod
re_unicode
;
mod
sparse
;
#
[
cfg
(
any
(
regex_runtime_teddy_ssse3
regex_runtime_teddy_avx2
)
)
]
mod
vector
;
/
/
/
The
internal
module
exists
to
support
suspicious
activity
such
as
/
/
/
testing
different
matching
engines
and
supporting
the
regex
-
debug
CLI
/
/
/
utility
.
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
use_std
"
)
]
pub
mod
internal
{
pub
use
compile
:
:
Compiler
;
pub
use
exec
:
:
{
Exec
ExecBuilder
}
;
pub
use
input
:
:
{
Char
Input
CharInput
InputAt
}
;
pub
use
literal
:
:
LiteralSearcher
;
pub
use
prog
:
:
{
Program
Inst
EmptyLook
InstRanges
}
;
}
