#
!
[
allow
(
warnings
)
]
use
alloc
:
:
{
string
:
:
{
String
ToString
}
sync
:
:
Arc
vec
vec
:
:
Vec
}
;
use
regex_automata
:
:
{
meta
nfa
:
:
thompson
:
:
WhichCaptures
util
:
:
syntax
MatchKind
}
;
use
crate
:
:
error
:
:
Error
;
#
[
derive
(
Clone
Debug
)
]
struct
Builder
{
pats
:
Vec
<
String
>
metac
:
meta
:
:
Config
syntaxc
:
syntax
:
:
Config
}
impl
Default
for
Builder
{
fn
default
(
)
-
>
Builder
{
let
metac
=
meta
:
:
Config
:
:
new
(
)
.
nfa_size_limit
(
Some
(
10
*
(
1
<
<
20
)
)
)
.
hybrid_cache_capacity
(
2
*
(
1
<
<
20
)
)
;
Builder
{
pats
:
vec
!
[
]
metac
syntaxc
:
syntax
:
:
Config
:
:
default
(
)
}
}
}
impl
Builder
{
fn
new
<
I
S
>
(
patterns
:
I
)
-
>
Builder
where
S
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
S
>
{
let
mut
b
=
Builder
:
:
default
(
)
;
b
.
pats
.
extend
(
patterns
.
into_iter
(
)
.
map
(
|
p
|
p
.
as_ref
(
)
.
to_string
(
)
)
)
;
b
}
fn
build_one_string
(
&
self
)
-
>
Result
<
crate
:
:
Regex
Error
>
{
assert_eq
!
(
1
self
.
pats
.
len
(
)
)
;
let
metac
=
self
.
metac
.
clone
(
)
.
match_kind
(
MatchKind
:
:
LeftmostFirst
)
.
utf8_empty
(
true
)
;
let
syntaxc
=
self
.
syntaxc
.
clone
(
)
.
utf8
(
true
)
;
let
pattern
=
Arc
:
:
from
(
self
.
pats
[
0
]
.
as_str
(
)
)
;
meta
:
:
Builder
:
:
new
(
)
.
configure
(
metac
)
.
syntax
(
syntaxc
)
.
build
(
&
pattern
)
.
map
(
|
meta
|
crate
:
:
Regex
{
meta
pattern
}
)
.
map_err
(
Error
:
:
from_meta_build_error
)
}
fn
build_one_bytes
(
&
self
)
-
>
Result
<
crate
:
:
bytes
:
:
Regex
Error
>
{
assert_eq
!
(
1
self
.
pats
.
len
(
)
)
;
let
metac
=
self
.
metac
.
clone
(
)
.
match_kind
(
MatchKind
:
:
LeftmostFirst
)
.
utf8_empty
(
false
)
;
let
syntaxc
=
self
.
syntaxc
.
clone
(
)
.
utf8
(
false
)
;
let
pattern
=
Arc
:
:
from
(
self
.
pats
[
0
]
.
as_str
(
)
)
;
meta
:
:
Builder
:
:
new
(
)
.
configure
(
metac
)
.
syntax
(
syntaxc
)
.
build
(
&
pattern
)
.
map
(
|
meta
|
crate
:
:
bytes
:
:
Regex
{
meta
pattern
}
)
.
map_err
(
Error
:
:
from_meta_build_error
)
}
fn
build_many_string
(
&
self
)
-
>
Result
<
crate
:
:
RegexSet
Error
>
{
let
metac
=
self
.
metac
.
clone
(
)
.
match_kind
(
MatchKind
:
:
All
)
.
utf8_empty
(
true
)
.
which_captures
(
WhichCaptures
:
:
None
)
;
let
syntaxc
=
self
.
syntaxc
.
clone
(
)
.
utf8
(
true
)
;
let
patterns
=
Arc
:
:
from
(
self
.
pats
.
as_slice
(
)
)
;
meta
:
:
Builder
:
:
new
(
)
.
configure
(
metac
)
.
syntax
(
syntaxc
)
.
build_many
(
&
patterns
)
.
map
(
|
meta
|
crate
:
:
RegexSet
{
meta
patterns
}
)
.
map_err
(
Error
:
:
from_meta_build_error
)
}
fn
build_many_bytes
(
&
self
)
-
>
Result
<
crate
:
:
bytes
:
:
RegexSet
Error
>
{
let
metac
=
self
.
metac
.
clone
(
)
.
match_kind
(
MatchKind
:
:
All
)
.
utf8_empty
(
false
)
.
which_captures
(
WhichCaptures
:
:
None
)
;
let
syntaxc
=
self
.
syntaxc
.
clone
(
)
.
utf8
(
false
)
;
let
patterns
=
Arc
:
:
from
(
self
.
pats
.
as_slice
(
)
)
;
meta
:
:
Builder
:
:
new
(
)
.
configure
(
metac
)
.
syntax
(
syntaxc
)
.
build_many
(
&
patterns
)
.
map
(
|
meta
|
crate
:
:
bytes
:
:
RegexSet
{
meta
patterns
}
)
.
map_err
(
Error
:
:
from_meta_build_error
)
}
fn
case_insensitive
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
case_insensitive
(
yes
)
;
self
}
fn
multi_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
multi_line
(
yes
)
;
self
}
fn
dot_matches_new_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
dot_matches_new_line
(
yes
)
;
self
}
fn
crlf
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
crlf
(
yes
)
;
self
}
fn
line_terminator
(
&
mut
self
byte
:
u8
)
-
>
&
mut
Builder
{
self
.
metac
=
self
.
metac
.
clone
(
)
.
line_terminator
(
byte
)
;
self
.
syntaxc
=
self
.
syntaxc
.
line_terminator
(
byte
)
;
self
}
fn
swap_greed
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
swap_greed
(
yes
)
;
self
}
fn
ignore_whitespace
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
ignore_whitespace
(
yes
)
;
self
}
fn
unicode
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
unicode
(
yes
)
;
self
}
fn
octal
(
&
mut
self
yes
:
bool
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
octal
(
yes
)
;
self
}
fn
size_limit
(
&
mut
self
limit
:
usize
)
-
>
&
mut
Builder
{
self
.
metac
=
self
.
metac
.
clone
(
)
.
nfa_size_limit
(
Some
(
limit
)
)
;
self
}
fn
dfa_size_limit
(
&
mut
self
limit
:
usize
)
-
>
&
mut
Builder
{
self
.
metac
=
self
.
metac
.
clone
(
)
.
hybrid_cache_capacity
(
limit
)
;
self
}
fn
nest_limit
(
&
mut
self
limit
:
u32
)
-
>
&
mut
Builder
{
self
.
syntaxc
=
self
.
syntaxc
.
nest_limit
(
limit
)
;
self
}
}
pub
(
crate
)
mod
string
{
use
crate
:
:
{
error
:
:
Error
Regex
RegexSet
}
;
use
super
:
:
Builder
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
RegexBuilder
{
builder
:
Builder
}
impl
RegexBuilder
{
pub
fn
new
(
pattern
:
&
str
)
-
>
RegexBuilder
{
RegexBuilder
{
builder
:
Builder
:
:
new
(
[
pattern
]
)
}
}
pub
fn
build
(
&
self
)
-
>
Result
<
Regex
Error
>
{
self
.
builder
.
build_one_string
(
)
}
pub
fn
unicode
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
unicode
(
yes
)
;
self
}
pub
fn
case_insensitive
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
case_insensitive
(
yes
)
;
self
}
pub
fn
multi_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
multi_line
(
yes
)
;
self
}
pub
fn
dot_matches_new_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
dot_matches_new_line
(
yes
)
;
self
}
pub
fn
crlf
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
crlf
(
yes
)
;
self
}
pub
fn
line_terminator
(
&
mut
self
byte
:
u8
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
line_terminator
(
byte
)
;
self
}
pub
fn
swap_greed
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
swap_greed
(
yes
)
;
self
}
pub
fn
ignore_whitespace
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
ignore_whitespace
(
yes
)
;
self
}
pub
fn
octal
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
octal
(
yes
)
;
self
}
pub
fn
size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
size_limit
(
bytes
)
;
self
}
pub
fn
dfa_size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
dfa_size_limit
(
bytes
)
;
self
}
pub
fn
nest_limit
(
&
mut
self
limit
:
u32
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
nest_limit
(
limit
)
;
self
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
RegexSetBuilder
{
builder
:
Builder
}
impl
RegexSetBuilder
{
pub
fn
new
<
I
S
>
(
patterns
:
I
)
-
>
RegexSetBuilder
where
I
:
IntoIterator
<
Item
=
S
>
S
:
AsRef
<
str
>
{
RegexSetBuilder
{
builder
:
Builder
:
:
new
(
patterns
)
}
}
pub
fn
build
(
&
self
)
-
>
Result
<
RegexSet
Error
>
{
self
.
builder
.
build_many_string
(
)
}
pub
fn
unicode
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
unicode
(
yes
)
;
self
}
pub
fn
case_insensitive
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
case_insensitive
(
yes
)
;
self
}
pub
fn
multi_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
multi_line
(
yes
)
;
self
}
pub
fn
dot_matches_new_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
dot_matches_new_line
(
yes
)
;
self
}
pub
fn
crlf
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
crlf
(
yes
)
;
self
}
pub
fn
line_terminator
(
&
mut
self
byte
:
u8
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
line_terminator
(
byte
)
;
self
}
pub
fn
swap_greed
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
swap_greed
(
yes
)
;
self
}
pub
fn
ignore_whitespace
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
ignore_whitespace
(
yes
)
;
self
}
pub
fn
octal
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
octal
(
yes
)
;
self
}
pub
fn
size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
size_limit
(
bytes
)
;
self
}
pub
fn
dfa_size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
dfa_size_limit
(
bytes
)
;
self
}
pub
fn
nest_limit
(
&
mut
self
limit
:
u32
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
nest_limit
(
limit
)
;
self
}
}
}
pub
(
crate
)
mod
bytes
{
use
crate
:
:
{
bytes
:
:
{
Regex
RegexSet
}
error
:
:
Error
}
;
use
super
:
:
Builder
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
RegexBuilder
{
builder
:
Builder
}
impl
RegexBuilder
{
pub
fn
new
(
pattern
:
&
str
)
-
>
RegexBuilder
{
RegexBuilder
{
builder
:
Builder
:
:
new
(
[
pattern
]
)
}
}
pub
fn
build
(
&
self
)
-
>
Result
<
Regex
Error
>
{
self
.
builder
.
build_one_bytes
(
)
}
pub
fn
unicode
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
unicode
(
yes
)
;
self
}
pub
fn
case_insensitive
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
case_insensitive
(
yes
)
;
self
}
pub
fn
multi_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
multi_line
(
yes
)
;
self
}
pub
fn
dot_matches_new_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
dot_matches_new_line
(
yes
)
;
self
}
pub
fn
crlf
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
crlf
(
yes
)
;
self
}
pub
fn
line_terminator
(
&
mut
self
byte
:
u8
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
line_terminator
(
byte
)
;
self
}
pub
fn
swap_greed
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
swap_greed
(
yes
)
;
self
}
pub
fn
ignore_whitespace
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
ignore_whitespace
(
yes
)
;
self
}
pub
fn
octal
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
octal
(
yes
)
;
self
}
pub
fn
size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
size_limit
(
bytes
)
;
self
}
pub
fn
dfa_size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
dfa_size_limit
(
bytes
)
;
self
}
pub
fn
nest_limit
(
&
mut
self
limit
:
u32
)
-
>
&
mut
RegexBuilder
{
self
.
builder
.
nest_limit
(
limit
)
;
self
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
RegexSetBuilder
{
builder
:
Builder
}
impl
RegexSetBuilder
{
pub
fn
new
<
I
S
>
(
patterns
:
I
)
-
>
RegexSetBuilder
where
I
:
IntoIterator
<
Item
=
S
>
S
:
AsRef
<
str
>
{
RegexSetBuilder
{
builder
:
Builder
:
:
new
(
patterns
)
}
}
pub
fn
build
(
&
self
)
-
>
Result
<
RegexSet
Error
>
{
self
.
builder
.
build_many_bytes
(
)
}
pub
fn
unicode
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
unicode
(
yes
)
;
self
}
pub
fn
case_insensitive
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
case_insensitive
(
yes
)
;
self
}
pub
fn
multi_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
multi_line
(
yes
)
;
self
}
pub
fn
dot_matches_new_line
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
dot_matches_new_line
(
yes
)
;
self
}
pub
fn
crlf
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
crlf
(
yes
)
;
self
}
pub
fn
line_terminator
(
&
mut
self
byte
:
u8
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
line_terminator
(
byte
)
;
self
}
pub
fn
swap_greed
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
swap_greed
(
yes
)
;
self
}
pub
fn
ignore_whitespace
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
ignore_whitespace
(
yes
)
;
self
}
pub
fn
octal
(
&
mut
self
yes
:
bool
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
octal
(
yes
)
;
self
}
pub
fn
size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
size_limit
(
bytes
)
;
self
}
pub
fn
dfa_size_limit
(
&
mut
self
bytes
:
usize
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
dfa_size_limit
(
bytes
)
;
self
}
pub
fn
nest_limit
(
&
mut
self
limit
:
u32
)
-
>
&
mut
RegexSetBuilder
{
self
.
builder
.
nest_limit
(
limit
)
;
self
}
}
}
