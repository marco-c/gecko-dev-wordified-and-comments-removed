use
alloc
:
:
string
:
:
String
;
use
regex_automata
:
:
{
meta
Input
PatternID
PatternSet
PatternSetIter
}
;
use
crate
:
:
{
Error
RegexSetBuilder
}
;
#
[
derive
(
Clone
)
]
pub
struct
RegexSet
{
pub
(
crate
)
meta
:
meta
:
:
Regex
pub
(
crate
)
patterns
:
alloc
:
:
sync
:
:
Arc
<
[
String
]
>
}
impl
RegexSet
{
pub
fn
new
<
I
S
>
(
exprs
:
I
)
-
>
Result
<
RegexSet
Error
>
where
S
:
AsRef
<
str
>
I
:
IntoIterator
<
Item
=
S
>
{
RegexSetBuilder
:
:
new
(
exprs
)
.
build
(
)
}
pub
fn
empty
(
)
-
>
RegexSet
{
let
empty
:
[
&
str
;
0
]
=
[
]
;
RegexSetBuilder
:
:
new
(
empty
)
.
build
(
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
is_match
(
&
self
haystack
:
&
str
)
-
>
bool
{
self
.
is_match_at
(
haystack
0
)
}
#
[
inline
]
pub
fn
is_match_at
(
&
self
haystack
:
&
str
start
:
usize
)
-
>
bool
{
self
.
meta
.
is_match
(
Input
:
:
new
(
haystack
)
.
span
(
start
.
.
haystack
.
len
(
)
)
)
}
#
[
inline
]
pub
fn
matches
(
&
self
haystack
:
&
str
)
-
>
SetMatches
{
self
.
matches_at
(
haystack
0
)
}
#
[
inline
]
pub
fn
matches_at
(
&
self
haystack
:
&
str
start
:
usize
)
-
>
SetMatches
{
let
input
=
Input
:
:
new
(
haystack
)
.
span
(
start
.
.
haystack
.
len
(
)
)
;
let
mut
patset
=
PatternSet
:
:
new
(
self
.
meta
.
pattern_len
(
)
)
;
self
.
meta
.
which_overlapping_matches
(
&
input
&
mut
patset
)
;
SetMatches
(
patset
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
matches_read_at
(
&
self
matches
:
&
mut
[
bool
]
haystack
:
&
str
start
:
usize
)
-
>
bool
{
let
mut
patset
=
PatternSet
:
:
new
(
self
.
meta
.
pattern_len
(
)
)
;
let
mut
input
=
Input
:
:
new
(
haystack
)
;
input
.
set_start
(
start
)
;
self
.
meta
.
which_overlapping_matches
(
&
input
&
mut
patset
)
;
for
pid
in
patset
.
iter
(
)
{
matches
[
pid
]
=
true
;
}
!
patset
.
is_empty
(
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
read_matches_at
(
&
self
matches
:
&
mut
[
bool
]
haystack
:
&
str
start
:
usize
)
-
>
bool
{
self
.
matches_read_at
(
matches
haystack
start
)
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
meta
.
pattern_len
(
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
meta
.
pattern_len
(
)
=
=
0
}
#
[
inline
]
pub
fn
patterns
(
&
self
)
-
>
&
[
String
]
{
&
self
.
patterns
}
}
impl
Default
for
RegexSet
{
fn
default
(
)
-
>
Self
{
RegexSet
:
:
empty
(
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
SetMatches
(
PatternSet
)
;
impl
SetMatches
{
#
[
inline
]
pub
fn
matched_any
(
&
self
)
-
>
bool
{
!
self
.
0
.
is_empty
(
)
}
#
[
inline
]
pub
fn
matched
(
&
self
index
:
usize
)
-
>
bool
{
self
.
0
.
contains
(
PatternID
:
:
new_unchecked
(
index
)
)
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
capacity
(
)
}
#
[
inline
]
pub
fn
iter
(
&
self
)
-
>
SetMatchesIter
<
'
_
>
{
SetMatchesIter
(
self
.
0
.
iter
(
)
)
}
}
impl
IntoIterator
for
SetMatches
{
type
IntoIter
=
SetMatchesIntoIter
;
type
Item
=
usize
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
let
it
=
0
.
.
self
.
0
.
capacity
(
)
;
SetMatchesIntoIter
{
patset
:
self
.
0
it
}
}
}
impl
<
'
a
>
IntoIterator
for
&
'
a
SetMatches
{
type
IntoIter
=
SetMatchesIter
<
'
a
>
;
type
Item
=
usize
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
iter
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
SetMatchesIntoIter
{
patset
:
PatternSet
it
:
core
:
:
ops
:
:
Range
<
usize
>
}
impl
Iterator
for
SetMatchesIntoIter
{
type
Item
=
usize
;
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
loop
{
let
id
=
self
.
it
.
next
(
)
?
;
if
self
.
patset
.
contains
(
PatternID
:
:
new_unchecked
(
id
)
)
{
return
Some
(
id
)
;
}
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
it
.
size_hint
(
)
}
}
impl
DoubleEndedIterator
for
SetMatchesIntoIter
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
usize
>
{
loop
{
let
id
=
self
.
it
.
next_back
(
)
?
;
if
self
.
patset
.
contains
(
PatternID
:
:
new_unchecked
(
id
)
)
{
return
Some
(
id
)
;
}
}
}
}
impl
core
:
:
iter
:
:
FusedIterator
for
SetMatchesIntoIter
{
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
SetMatchesIter
<
'
a
>
(
PatternSetIter
<
'
a
>
)
;
impl
<
'
a
>
Iterator
for
SetMatchesIter
<
'
a
>
{
type
Item
=
usize
;
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next
(
)
.
map
(
|
pid
|
pid
.
as_usize
(
)
)
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
0
.
size_hint
(
)
}
}
impl
<
'
a
>
DoubleEndedIterator
for
SetMatchesIter
<
'
a
>
{
fn
next_back
(
&
mut
self
)
-
>
Option
<
usize
>
{
self
.
0
.
next_back
(
)
.
map
(
|
pid
|
pid
.
as_usize
(
)
)
}
}
impl
<
'
a
>
core
:
:
iter
:
:
FusedIterator
for
SetMatchesIter
<
'
a
>
{
}
impl
core
:
:
fmt
:
:
Debug
for
RegexSet
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
write
!
(
f
"
RegexSet
(
{
:
?
}
)
"
self
.
patterns
(
)
)
}
}
