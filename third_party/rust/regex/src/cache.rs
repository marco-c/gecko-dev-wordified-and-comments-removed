pub
use
self
:
:
imp
:
:
{
Cached
CachedGuard
}
;
#
[
cfg
(
feature
=
"
perf
-
cache
"
)
]
mod
imp
{
use
thread_local
:
:
CachedThreadLocal
;
#
[
derive
(
Debug
)
]
pub
struct
Cached
<
T
:
Send
>
(
CachedThreadLocal
<
T
>
)
;
#
[
derive
(
Debug
)
]
pub
struct
CachedGuard
<
'
a
T
:
'
a
>
(
&
'
a
T
)
;
impl
<
T
:
Send
>
Cached
<
T
>
{
pub
fn
new
(
)
-
>
Cached
<
T
>
{
Cached
(
CachedThreadLocal
:
:
new
(
)
)
}
pub
fn
get_or
(
&
self
create
:
impl
FnOnce
(
)
-
>
T
)
-
>
CachedGuard
<
T
>
{
CachedGuard
(
self
.
0
.
get_or
(
|
|
create
(
)
)
)
}
}
impl
<
'
a
T
:
Send
>
CachedGuard
<
'
a
T
>
{
pub
fn
value
(
&
self
)
-
>
&
T
{
self
.
0
}
}
}
#
[
cfg
(
not
(
feature
=
"
perf
-
cache
"
)
)
]
mod
imp
{
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
panic
:
:
UnwindSafe
;
use
std
:
:
sync
:
:
Mutex
;
#
[
derive
(
Debug
)
]
pub
struct
Cached
<
T
:
Send
>
{
stack
:
Mutex
<
Vec
<
T
>
>
_phantom
:
PhantomData
<
Box
<
dyn
Send
+
Sync
+
UnwindSafe
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
CachedGuard
<
'
a
T
:
'
a
+
Send
>
{
cache
:
&
'
a
Cached
<
T
>
value
:
Option
<
T
>
}
impl
<
T
:
Send
>
Cached
<
T
>
{
pub
fn
new
(
)
-
>
Cached
<
T
>
{
Cached
{
stack
:
Mutex
:
:
new
(
vec
!
[
]
)
_phantom
:
PhantomData
}
}
pub
fn
get_or
(
&
self
create
:
impl
FnOnce
(
)
-
>
T
)
-
>
CachedGuard
<
T
>
{
let
mut
stack
=
self
.
stack
.
lock
(
)
.
unwrap
(
)
;
match
stack
.
pop
(
)
{
None
=
>
CachedGuard
{
cache
:
self
value
:
Some
(
create
(
)
)
}
Some
(
value
)
=
>
CachedGuard
{
cache
:
self
value
:
Some
(
value
)
}
}
}
fn
put
(
&
self
value
:
T
)
{
let
mut
stack
=
self
.
stack
.
lock
(
)
.
unwrap
(
)
;
stack
.
push
(
value
)
;
}
}
impl
<
'
a
T
:
Send
>
CachedGuard
<
'
a
T
>
{
pub
fn
value
(
&
self
)
-
>
&
T
{
self
.
value
.
as_ref
(
)
.
unwrap
(
)
}
}
impl
<
'
a
T
:
Send
>
Drop
for
CachedGuard
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
if
let
Some
(
value
)
=
self
.
value
.
take
(
)
{
self
.
cache
.
put
(
value
)
;
}
}
}
}
