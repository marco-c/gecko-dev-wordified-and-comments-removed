use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
str
;
use
icu_provider
:
:
prelude
:
:
*
;
use
tinystr
:
:
TinyStr4
;
use
zerovec
:
:
ule
:
:
{
UnvalidatedStr
VarULE
}
;
use
zerovec
:
:
{
maps
:
:
ZeroMapKV
VarZeroSlice
VarZeroVec
ZeroMap
ZeroVec
}
;
#
[
derive
(
PartialEq
Eq
)
]
#
[
derive
(
Debug
VarULE
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
repr
(
transparent
)
]
pub
struct
NormalizedPropertyNameStr
(
UnvalidatedStr
)
;
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
for
Box
<
NormalizedPropertyNameStr
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
<
Box
<
UnvalidatedStr
>
>
:
:
deserialize
(
deserializer
)
.
map
(
NormalizedPropertyNameStr
:
:
cast_box
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
'
a
>
serde
:
:
Deserialize
<
'
de
>
for
&
'
a
NormalizedPropertyNameStr
where
'
de
:
'
a
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
<
&
UnvalidatedStr
>
:
:
deserialize
(
deserializer
)
.
map
(
NormalizedPropertyNameStr
:
:
cast_ref
)
}
}
impl
<
'
a
>
ZeroMapKV
<
'
a
>
for
NormalizedPropertyNameStr
{
type
Container
=
VarZeroVec
<
'
a
NormalizedPropertyNameStr
>
;
type
Slice
=
VarZeroSlice
<
NormalizedPropertyNameStr
>
;
type
GetType
=
NormalizedPropertyNameStr
;
type
OwnedType
=
Box
<
NormalizedPropertyNameStr
>
;
}
impl
PartialOrd
for
NormalizedPropertyNameStr
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
Ordering
>
{
Some
(
self
.
cmp
(
other
)
)
}
}
fn
normalize_char
(
ch
:
u8
)
-
>
Option
<
u8
>
{
match
ch
{
ch
if
ch
.
is_ascii_whitespace
(
)
=
>
None
b
'
_
'
|
b
'
-
'
|
0x0B
=
>
None
ch
=
>
Some
(
ch
.
to_ascii_lowercase
(
)
)
}
}
impl
Ord
for
NormalizedPropertyNameStr
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
Ordering
{
let
cmp
=
self
.
cmp_loose
(
other
)
;
if
cmp
=
=
Ordering
:
:
Equal
{
self
.
0
.
cmp
(
&
other
.
0
)
}
else
{
cmp
}
}
}
impl
NormalizedPropertyNameStr
{
pub
fn
cmp_loose
(
&
self
other
:
&
Self
)
-
>
Ordering
{
let
self_iter
=
self
.
0
.
iter
(
)
.
copied
(
)
.
filter_map
(
normalize_char
)
;
let
other_iter
=
other
.
0
.
iter
(
)
.
copied
(
)
.
filter_map
(
normalize_char
)
;
self_iter
.
cmp
(
other_iter
)
}
pub
const
fn
from_str
(
s
:
&
str
)
-
>
&
Self
{
Self
:
:
cast_ref
(
UnvalidatedStr
:
:
from_str
(
s
)
)
}
pub
const
fn
cast_ref
(
value
:
&
UnvalidatedStr
)
-
>
&
Self
{
unsafe
{
core
:
:
mem
:
:
transmute
(
value
)
}
}
pub
const
fn
cast_box
(
value
:
Box
<
UnvalidatedStr
>
)
-
>
Box
<
Self
>
{
unsafe
{
core
:
:
mem
:
:
transmute
(
value
)
}
}
pub
fn
boxed_from_bytes
(
b
:
&
[
u8
]
)
-
>
Box
<
Self
>
{
Self
:
:
cast_box
(
UnvalidatedStr
:
:
from_boxed_bytes
(
b
.
into
(
)
)
)
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
icu_provider
:
:
data_struct
(
marker
(
GeneralCategoryMaskNameToValueV1Marker
"
propnames
/
from
/
gcm
1
"
singleton
)
)
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
serde
:
:
Serialize
databake
:
:
Bake
)
databake
(
path
=
icu_properties
:
:
provider
:
:
names
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
yoke
(
prove_covariance_manually
)
]
pub
struct
PropertyValueNameToEnumMapV1
<
'
data
>
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
pub
map
:
ZeroMap
<
'
data
NormalizedPropertyNameStr
u16
>
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
icu_provider
:
:
data_struct
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
serde
:
:
Serialize
databake
:
:
Bake
)
databake
(
path
=
icu_properties
:
:
provider
:
:
names
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
yoke
(
prove_covariance_manually
)
]
pub
struct
PropertyEnumToValueNameSparseMapV1
<
'
data
>
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
pub
map
:
ZeroMap
<
'
data
u16
str
>
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
icu_provider
:
:
data_struct
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
serde
:
:
Serialize
databake
:
:
Bake
)
databake
(
path
=
icu_properties
:
:
provider
:
:
names
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
yoke
(
prove_covariance_manually
)
]
pub
struct
PropertyEnumToValueNameLinearMapV1
<
'
data
>
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
pub
map
:
VarZeroVec
<
'
data
str
>
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
#
[
icu_provider
:
:
data_struct
]
#
[
cfg_attr
(
feature
=
"
datagen
"
derive
(
serde
:
:
Serialize
databake
:
:
Bake
)
databake
(
path
=
icu_properties
:
:
provider
:
:
names
)
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
serde
:
:
Deserialize
)
)
]
#
[
yoke
(
prove_covariance_manually
)
]
pub
struct
PropertyEnumToValueNameLinearTiny4MapV1
<
'
data
>
{
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
borrow
)
)
]
pub
map
:
ZeroVec
<
'
data
TinyStr4
>
}
