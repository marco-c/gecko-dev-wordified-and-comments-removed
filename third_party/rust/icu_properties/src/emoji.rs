use
crate
:
:
provider
:
:
*
;
use
icu_collections
:
:
codepointinvliststringlist
:
:
CodePointInversionListAndStringList
;
use
icu_provider
:
:
marker
:
:
ErasedMarker
;
use
icu_provider
:
:
prelude
:
:
*
;
#
[
derive
(
Debug
)
]
pub
struct
EmojiSetData
{
data
:
DataPayload
<
ErasedMarker
<
PropertyUnicodeSet
<
'
static
>
>
>
}
impl
EmojiSetData
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
#
[
allow
(
clippy
:
:
new_ret_no_self
)
]
pub
const
fn
new
<
P
:
EmojiSet
>
(
)
-
>
EmojiSetDataBorrowed
<
'
static
>
{
EmojiSetDataBorrowed
:
:
new
:
:
<
P
>
(
)
}
pub
fn
try_new_unstable
<
P
:
EmojiSet
>
(
provider
:
&
(
impl
DataProvider
<
P
:
:
DataMarker
>
+
?
Sized
)
)
-
>
Result
<
EmojiSetData
DataError
>
{
Ok
(
EmojiSetData
:
:
from_data
(
provider
.
load
(
Default
:
:
default
(
)
)
?
.
payload
)
)
}
#
[
inline
]
pub
fn
as_borrowed
(
&
self
)
-
>
EmojiSetDataBorrowed
<
'
_
>
{
EmojiSetDataBorrowed
{
set
:
self
.
data
.
get
(
)
}
}
pub
(
crate
)
fn
from_data
<
M
>
(
data
:
DataPayload
<
M
>
)
-
>
Self
where
M
:
DynamicDataMarker
<
DataStruct
=
PropertyUnicodeSet
<
'
static
>
>
{
Self
{
data
:
data
.
cast
(
)
}
}
pub
fn
from_code_point_inversion_list_string_list
(
set
:
CodePointInversionListAndStringList
<
'
static
>
)
-
>
Self
{
let
set
=
PropertyUnicodeSet
:
:
from_code_point_inversion_list_string_list
(
set
)
;
EmojiSetData
:
:
from_data
(
DataPayload
:
:
<
ErasedMarker
<
PropertyUnicodeSet
<
'
static
>
>
>
:
:
from_owned
(
set
)
)
}
pub
fn
as_code_point_inversion_list_string_list
(
&
self
)
-
>
Option
<
&
CodePointInversionListAndStringList
<
'
_
>
>
{
self
.
data
.
get
(
)
.
as_code_point_inversion_list_string_list
(
)
}
pub
fn
to_code_point_inversion_list_string_list
(
&
self
)
-
>
CodePointInversionListAndStringList
<
'
_
>
{
self
.
data
.
get
(
)
.
to_code_point_inversion_list_string_list
(
)
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
EmojiSetDataBorrowed
<
'
a
>
{
set
:
&
'
a
PropertyUnicodeSet
<
'
a
>
}
impl
EmojiSetDataBorrowed
<
'
_
>
{
#
[
inline
]
pub
fn
contains_str
(
self
s
:
&
str
)
-
>
bool
{
self
.
set
.
contains_str
(
s
)
}
#
[
inline
]
pub
fn
contains
(
self
ch
:
char
)
-
>
bool
{
self
.
set
.
contains
(
ch
)
}
#
[
inline
]
pub
fn
contains32
(
self
cp
:
u32
)
-
>
bool
{
self
.
set
.
contains32
(
cp
)
}
}
impl
EmojiSetDataBorrowed
<
'
static
>
{
#
[
inline
]
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
const
fn
new
<
P
:
EmojiSet
>
(
)
-
>
Self
{
EmojiSetDataBorrowed
{
set
:
P
:
:
SINGLETON
}
}
pub
const
fn
static_to_owned
(
self
)
-
>
EmojiSetData
{
EmojiSetData
{
data
:
DataPayload
:
:
from_static_ref
(
self
.
set
)
}
}
}
pub
trait
EmojiSet
:
crate
:
:
private
:
:
Sealed
{
#
[
doc
(
hidden
)
]
type
DataMarker
:
DataMarker
<
DataStruct
=
PropertyUnicodeSet
<
'
static
>
>
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON
:
&
'
static
PropertyUnicodeSet
<
'
static
>
;
}
