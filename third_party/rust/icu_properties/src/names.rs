use
crate
:
:
props
:
:
*
;
use
crate
:
:
provider
:
:
names
:
:
*
;
use
core
:
:
marker
:
:
PhantomData
;
use
icu_collections
:
:
codepointtrie
:
:
TrieValue
;
use
icu_provider
:
:
marker
:
:
ErasedMarker
;
use
icu_provider
:
:
prelude
:
:
*
;
use
yoke
:
:
Yokeable
;
use
zerotrie
:
:
cursor
:
:
ZeroTrieSimpleAsciiCursor
;
#
[
derive
(
Debug
)
]
pub
struct
PropertyParser
<
T
>
{
map
:
DataPayload
<
ErasedMarker
<
PropertyValueNameToEnumMap
<
'
static
>
>
>
markers
:
PhantomData
<
fn
(
)
-
>
T
>
}
#
[
derive
(
Debug
)
]
pub
struct
PropertyParserBorrowed
<
'
a
T
>
{
map
:
&
'
a
PropertyValueNameToEnumMap
<
'
a
>
markers
:
PhantomData
<
fn
(
)
-
>
T
>
}
impl
<
T
>
Clone
for
PropertyParserBorrowed
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
T
>
Copy
for
PropertyParserBorrowed
<
'
_
T
>
{
}
impl
<
T
>
PropertyParser
<
T
>
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
#
[
allow
(
clippy
:
:
new_ret_no_self
)
]
pub
fn
new
(
)
-
>
PropertyParserBorrowed
<
'
static
T
>
where
T
:
ParseableEnumeratedProperty
{
PropertyParserBorrowed
:
:
new
(
)
}
#
[
doc
=
icu_provider
:
:
gen_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
new
)
]
pub
fn
try_new_unstable
(
provider
:
&
(
impl
DataProvider
<
T
:
:
DataMarker
>
+
?
Sized
)
)
-
>
Result
<
Self
DataError
>
where
T
:
ParseableEnumeratedProperty
{
Ok
(
Self
{
map
:
provider
.
load
(
Default
:
:
default
(
)
)
?
.
payload
.
cast
(
)
markers
:
PhantomData
}
)
}
#
[
inline
]
pub
fn
as_borrowed
(
&
self
)
-
>
PropertyParserBorrowed
<
'
_
T
>
{
PropertyParserBorrowed
{
map
:
self
.
map
.
get
(
)
markers
:
PhantomData
}
}
#
[
doc
(
hidden
)
]
pub
fn
erase
(
self
)
-
>
PropertyParser
<
u16
>
{
PropertyParser
{
map
:
self
.
map
.
cast
(
)
markers
:
PhantomData
}
}
}
impl
<
T
:
TrieValue
>
PropertyParserBorrowed
<
'
_
T
>
{
#
[
inline
]
pub
fn
get_strict_u16
(
self
name
:
&
str
)
-
>
Option
<
u16
>
{
get_strict_u16
(
self
.
map
name
)
}
#
[
inline
]
pub
fn
get_strict
(
self
name
:
&
str
)
-
>
Option
<
T
>
{
T
:
:
try_from_u32
(
self
.
get_strict_u16
(
name
)
?
as
u32
)
.
ok
(
)
}
#
[
inline
]
pub
fn
get_loose_u16
(
self
name
:
&
str
)
-
>
Option
<
u16
>
{
get_loose_u16
(
self
.
map
name
)
}
#
[
inline
]
pub
fn
get_loose
(
self
name
:
&
str
)
-
>
Option
<
T
>
{
T
:
:
try_from_u32
(
self
.
get_loose_u16
(
name
)
?
as
u32
)
.
ok
(
)
}
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
impl
<
T
:
ParseableEnumeratedProperty
>
Default
for
PropertyParserBorrowed
<
'
static
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
TrieValue
>
PropertyParserBorrowed
<
'
static
T
>
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
fn
new
(
)
-
>
Self
where
T
:
ParseableEnumeratedProperty
{
Self
{
map
:
T
:
:
SINGLETON
markers
:
PhantomData
}
}
pub
const
fn
static_to_owned
(
self
)
-
>
PropertyParser
<
T
>
{
PropertyParser
{
map
:
DataPayload
:
:
from_static_ref
(
self
.
map
)
markers
:
PhantomData
}
}
}
fn
get_strict_u16
(
payload
:
&
PropertyValueNameToEnumMap
<
'
_
>
name
:
&
str
)
-
>
Option
<
u16
>
{
payload
.
map
.
get
(
name
)
.
and_then
(
|
i
|
i
.
try_into
(
)
.
ok
(
)
)
}
fn
get_loose_u16
(
payload
:
&
PropertyValueNameToEnumMap
<
'
_
>
name
:
&
str
)
-
>
Option
<
u16
>
{
fn
recurse
(
mut
cursor
:
ZeroTrieSimpleAsciiCursor
mut
rest
:
&
[
u8
]
)
-
>
Option
<
usize
>
{
if
cursor
.
is_empty
(
)
{
return
None
;
}
for
skip
in
[
b
'
\
t
'
b
'
\
n
'
b
'
\
x0C
'
b
'
\
r
'
b
'
'
0x0B
b
'
_
'
b
'
-
'
]
{
let
mut
skip_cursor
=
cursor
.
clone
(
)
;
skip_cursor
.
step
(
skip
)
;
if
let
Some
(
r
)
=
recurse
(
skip_cursor
rest
)
{
return
Some
(
r
)
;
}
}
let
ascii
=
loop
{
let
Some
(
(
&
a
r
)
)
=
rest
.
split_first
(
)
else
{
return
cursor
.
take_value
(
)
;
}
;
rest
=
r
;
if
!
matches
!
(
a
b
'
\
t
'
|
b
'
\
n
'
|
b
'
\
x0C
'
|
b
'
\
r
'
|
b
'
'
|
0x0B
|
b
'
_
'
|
b
'
-
'
)
{
break
a
;
}
}
;
let
mut
other_case_cursor
=
cursor
.
clone
(
)
;
cursor
.
step
(
ascii
)
;
other_case_cursor
.
step
(
if
ascii
.
is_ascii_lowercase
(
)
{
ascii
.
to_ascii_uppercase
(
)
}
else
{
ascii
.
to_ascii_lowercase
(
)
}
)
;
recurse
(
cursor
rest
)
.
or_else
(
|
|
recurse
(
other_case_cursor
rest
)
)
}
recurse
(
payload
.
map
.
cursor
(
)
name
.
as_bytes
(
)
)
.
and_then
(
|
i
|
i
.
try_into
(
)
.
ok
(
)
)
}
pub
struct
PropertyNamesLong
<
T
:
NamedEnumeratedProperty
>
{
map
:
DataPayload
<
ErasedMarker
<
T
:
:
DataStructLong
>
>
}
impl
<
T
:
NamedEnumeratedProperty
>
core
:
:
fmt
:
:
Debug
for
PropertyNamesLong
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
PropertyNamesLong
"
)
.
finish
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
PropertyNamesLongBorrowed
<
'
a
T
:
NamedEnumeratedProperty
>
{
map
:
&
'
a
T
:
:
DataStructLongBorrowed
<
'
a
>
}
impl
<
T
:
NamedEnumeratedProperty
>
Clone
for
PropertyNamesLongBorrowed
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
T
:
NamedEnumeratedProperty
>
Copy
for
PropertyNamesLongBorrowed
<
'
_
T
>
{
}
impl
<
T
:
NamedEnumeratedProperty
>
PropertyNamesLong
<
T
>
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
#
[
allow
(
clippy
:
:
new_ret_no_self
)
]
pub
fn
new
(
)
-
>
PropertyNamesLongBorrowed
<
'
static
T
>
{
PropertyNamesLongBorrowed
:
:
new
(
)
}
#
[
doc
=
icu_provider
:
:
gen_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
new
)
]
pub
fn
try_new_unstable
(
provider
:
&
(
impl
DataProvider
<
T
:
:
DataMarkerLong
>
+
?
Sized
)
)
-
>
Result
<
Self
DataError
>
{
Ok
(
Self
{
map
:
provider
.
load
(
Default
:
:
default
(
)
)
?
.
payload
.
cast
(
)
}
)
}
#
[
inline
]
pub
fn
as_borrowed
(
&
self
)
-
>
PropertyNamesLongBorrowed
<
'
_
T
>
{
PropertyNamesLongBorrowed
{
map
:
T
:
:
nep_long_identity
(
self
.
map
.
get
(
)
)
}
}
}
impl
<
'
a
T
:
NamedEnumeratedProperty
>
PropertyNamesLongBorrowed
<
'
a
T
>
{
#
[
inline
]
pub
fn
get
(
self
property
:
T
)
-
>
Option
<
&
'
a
str
>
{
self
.
map
.
get
(
property
.
to_u32
(
)
)
}
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
impl
<
T
:
NamedEnumeratedProperty
>
Default
for
PropertyNamesLongBorrowed
<
'
static
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
NamedEnumeratedProperty
>
PropertyNamesLongBorrowed
<
'
static
T
>
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
T
:
:
SINGLETON_LONG
}
}
pub
fn
static_to_owned
(
self
)
-
>
PropertyNamesLong
<
T
>
{
PropertyNamesLong
{
map
:
DataPayload
:
:
from_static_ref
(
T
:
:
nep_long_identity_static
(
self
.
map
)
)
}
}
}
pub
struct
PropertyNamesShort
<
T
:
NamedEnumeratedProperty
>
{
map
:
DataPayload
<
ErasedMarker
<
T
:
:
DataStructShort
>
>
}
impl
<
T
:
NamedEnumeratedProperty
>
core
:
:
fmt
:
:
Debug
for
PropertyNamesShort
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
PropertyNamesShort
"
)
.
finish
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
PropertyNamesShortBorrowed
<
'
a
T
:
NamedEnumeratedProperty
>
{
map
:
&
'
a
T
:
:
DataStructShortBorrowed
<
'
a
>
}
impl
<
T
:
NamedEnumeratedProperty
>
Clone
for
PropertyNamesShortBorrowed
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
T
:
NamedEnumeratedProperty
>
Copy
for
PropertyNamesShortBorrowed
<
'
_
T
>
{
}
impl
<
T
:
NamedEnumeratedProperty
>
PropertyNamesShort
<
T
>
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
#
[
allow
(
clippy
:
:
new_ret_no_self
)
]
pub
fn
new
(
)
-
>
PropertyNamesShortBorrowed
<
'
static
T
>
{
PropertyNamesShortBorrowed
:
:
new
(
)
}
#
[
doc
=
icu_provider
:
:
gen_buffer_unstable_docs
!
(
UNSTABLE
Self
:
:
new
)
]
pub
fn
try_new_unstable
(
provider
:
&
(
impl
DataProvider
<
T
:
:
DataMarkerShort
>
+
?
Sized
)
)
-
>
Result
<
Self
DataError
>
{
Ok
(
Self
{
map
:
provider
.
load
(
Default
:
:
default
(
)
)
?
.
payload
.
cast
(
)
}
)
}
#
[
inline
]
pub
fn
as_borrowed
(
&
self
)
-
>
PropertyNamesShortBorrowed
<
'
_
T
>
{
PropertyNamesShortBorrowed
{
map
:
T
:
:
nep_short_identity
(
self
.
map
.
get
(
)
)
}
}
}
impl
<
'
a
T
:
NamedEnumeratedProperty
>
PropertyNamesShortBorrowed
<
'
a
T
>
{
#
[
inline
]
pub
fn
get
(
self
property
:
T
)
-
>
Option
<
&
'
a
str
>
{
self
.
map
.
get
(
property
.
to_u32
(
)
)
}
}
impl
PropertyNamesShortBorrowed
<
'
_
Script
>
{
#
[
inline
]
pub
fn
get_locale_script
(
self
property
:
Script
)
-
>
Option
<
icu_locale_core
:
:
subtags
:
:
Script
>
{
let
prop
=
usize
:
:
try_from
(
property
.
to_u32
(
)
)
.
ok
(
)
?
;
self
.
map
.
map
.
get
(
prop
)
.
and_then
(
|
o
|
o
.
0
)
}
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
impl
<
T
:
NamedEnumeratedProperty
>
Default
for
PropertyNamesShortBorrowed
<
'
static
T
>
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
<
T
:
NamedEnumeratedProperty
>
PropertyNamesShortBorrowed
<
'
static
T
>
{
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
pub
fn
new
(
)
-
>
Self
{
Self
{
map
:
T
:
:
SINGLETON_SHORT
}
}
pub
fn
static_to_owned
(
self
)
-
>
PropertyNamesShort
<
T
>
{
PropertyNamesShort
{
map
:
DataPayload
:
:
from_static_ref
(
T
:
:
nep_short_identity_static
(
self
.
map
)
)
}
}
}
pub
trait
ParseableEnumeratedProperty
:
crate
:
:
private
:
:
Sealed
+
TrieValue
{
#
[
doc
(
hidden
)
]
type
DataMarker
:
DataMarker
<
DataStruct
=
PropertyValueNameToEnumMap
<
'
static
>
>
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON
:
&
'
static
PropertyValueNameToEnumMap
<
'
static
>
;
}
pub
trait
PropertyEnumToValueNameLookup
{
fn
get
(
&
self
prop
:
u32
)
-
>
Option
<
&
str
>
;
}
impl
PropertyEnumToValueNameLookup
for
PropertyEnumToValueNameLinearMap
<
'
_
>
{
fn
get
(
&
self
prop
:
u32
)
-
>
Option
<
&
str
>
{
self
.
map
.
get
(
usize
:
:
try_from
(
prop
)
.
ok
(
)
?
)
}
}
impl
PropertyEnumToValueNameLookup
for
PropertyEnumToValueNameSparseMap
<
'
_
>
{
fn
get
(
&
self
prop
:
u32
)
-
>
Option
<
&
str
>
{
self
.
map
.
get
(
&
u16
:
:
try_from
(
prop
)
.
ok
(
)
?
)
}
}
impl
PropertyEnumToValueNameLookup
for
PropertyScriptToIcuScriptMap
<
'
_
>
{
fn
get
(
&
self
prop
:
u32
)
-
>
Option
<
&
str
>
{
self
.
map
.
get_ule_ref
(
usize
:
:
try_from
(
prop
)
.
ok
(
)
?
)
.
and_then
(
|
no
|
no
.
as_ref
(
)
)
.
map
(
|
s
|
s
.
as_str
(
)
)
}
}
pub
trait
NamedEnumeratedProperty
:
ParseableEnumeratedProperty
{
#
[
doc
(
hidden
)
]
type
DataStructLong
:
'
static
+
for
<
'
a
>
Yokeable
<
'
a
Output
=
Self
:
:
DataStructLongBorrowed
<
'
a
>
>
+
PropertyEnumToValueNameLookup
;
#
[
doc
(
hidden
)
]
type
DataStructShort
:
'
static
+
for
<
'
a
>
Yokeable
<
'
a
Output
=
Self
:
:
DataStructShortBorrowed
<
'
a
>
>
+
PropertyEnumToValueNameLookup
;
#
[
doc
(
hidden
)
]
type
DataStructLongBorrowed
<
'
a
>
:
PropertyEnumToValueNameLookup
;
#
[
doc
(
hidden
)
]
type
DataStructShortBorrowed
<
'
a
>
:
PropertyEnumToValueNameLookup
;
#
[
doc
(
hidden
)
]
type
DataMarkerLong
:
DataMarker
<
DataStruct
=
Self
:
:
DataStructLong
>
;
#
[
doc
(
hidden
)
]
type
DataMarkerShort
:
DataMarker
<
DataStruct
=
Self
:
:
DataStructShort
>
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON_LONG
:
&
'
static
Self
:
:
DataStructLongBorrowed
<
'
static
>
;
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON_SHORT
:
&
'
static
Self
:
:
DataStructShortBorrowed
<
'
static
>
;
#
[
doc
(
hidden
)
]
fn
nep_long_identity
<
'
a
>
(
stat
:
&
'
a
<
Self
:
:
DataStructLong
as
Yokeable
<
'
a
>
>
:
:
Output
)
-
>
&
'
a
Self
:
:
DataStructLongBorrowed
<
'
a
>
;
#
[
doc
(
hidden
)
]
fn
nep_long_identity_static
(
stat
:
&
'
static
Self
:
:
DataStructLongBorrowed
<
'
static
>
)
-
>
&
'
static
Self
:
:
DataStructLong
;
#
[
doc
(
hidden
)
]
fn
nep_short_identity
<
'
a
>
(
stat
:
&
'
a
<
Self
:
:
DataStructShort
as
Yokeable
<
'
a
>
>
:
:
Output
)
-
>
&
'
a
Self
:
:
DataStructShortBorrowed
<
'
a
>
;
#
[
doc
(
hidden
)
]
fn
nep_short_identity_static
(
stat
:
&
'
static
Self
:
:
DataStructShortBorrowed
<
'
static
>
)
-
>
&
'
static
Self
:
:
DataStructShort
;
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
fn
try_from_str
(
s
:
&
str
)
-
>
Option
<
Self
>
{
PropertyParser
:
:
new
(
)
.
get_loose
(
s
)
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
fn
long_name
(
&
self
)
-
>
&
'
static
str
{
PropertyNamesLong
:
:
new
(
)
.
get
(
*
self
)
.
unwrap_or
(
"
unreachable
"
)
}
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
fn
short_name
(
&
self
)
-
>
&
'
static
str
{
PropertyNamesShort
:
:
new
(
)
.
get
(
*
self
)
.
unwrap_or
(
"
unreachable
"
)
}
}
macro_rules
!
impl_value_getter
{
(
impl
ty
:
ident
{
marker_n2e
:
ident
/
singleton_n2e
:
ident
;
(
data_struct_s
:
ident
/
marker_e2sn
:
ident
/
singleton_e2sn
:
ident
;
data_struct_l
:
ident
/
marker_e2ln
:
ident
/
singleton_e2ln
:
ident
;
)
?
}
)
=
>
{
impl
ParseableEnumeratedProperty
for
ty
{
type
DataMarker
=
marker_n2e
;
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON
:
&
'
static
PropertyValueNameToEnumMap
<
'
static
>
=
crate
:
:
provider
:
:
Baked
:
:
singleton_n2e
;
}
(
impl
NamedEnumeratedProperty
for
ty
{
type
DataStructLong
=
data_struct_l
<
'
static
>
;
type
DataStructShort
=
data_struct_s
<
'
static
>
;
type
DataStructLongBorrowed
<
'
a
>
=
data_struct_l
<
'
a
>
;
type
DataStructShortBorrowed
<
'
a
>
=
data_struct_s
<
'
a
>
;
type
DataMarkerLong
=
crate
:
:
provider
:
:
marker_e2ln
;
type
DataMarkerShort
=
crate
:
:
provider
:
:
marker_e2sn
;
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON_LONG
:
&
'
static
Self
:
:
DataStructLong
=
crate
:
:
provider
:
:
Baked
:
:
singleton_e2ln
;
#
[
cfg
(
feature
=
"
compiled_data
"
)
]
const
SINGLETON_SHORT
:
&
'
static
Self
:
:
DataStructShort
=
crate
:
:
provider
:
:
Baked
:
:
singleton_e2sn
;
fn
nep_long_identity
<
'
a
>
(
yoked
:
&
'
a
data_struct_l
<
'
a
>
)
-
>
&
'
a
Self
:
:
DataStructLongBorrowed
<
'
a
>
{
yoked
}
fn
nep_long_identity_static
(
stat
:
&
'
static
data_struct_l
<
'
static
>
)
-
>
&
'
static
data_struct_l
<
'
static
>
{
stat
}
fn
nep_short_identity
<
'
a
>
(
yoked
:
&
'
a
data_struct_s
<
'
a
>
)
-
>
&
'
a
Self
:
:
DataStructShortBorrowed
<
'
a
>
{
yoked
}
fn
nep_short_identity_static
(
stat
:
&
'
static
data_struct_s
<
'
static
>
)
-
>
&
'
static
data_struct_s
<
'
static
>
{
stat
}
}
)
?
}
;
}
impl_value_getter
!
{
impl
BidiClass
{
PropertyNameParseBidiClassV1
/
SINGLETON_PROPERTY_NAME_PARSE_BIDI_CLASS_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortBidiClassV1
/
SINGLETON_PROPERTY_NAME_SHORT_BIDI_CLASS_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongBidiClassV1
/
SINGLETON_PROPERTY_NAME_LONG_BIDI_CLASS_V1
;
}
}
impl_value_getter
!
{
impl
GeneralCategory
{
PropertyNameParseGeneralCategoryV1
/
SINGLETON_PROPERTY_NAME_PARSE_GENERAL_CATEGORY_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortGeneralCategoryV1
/
SINGLETON_PROPERTY_NAME_SHORT_GENERAL_CATEGORY_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongGeneralCategoryV1
/
SINGLETON_PROPERTY_NAME_LONG_GENERAL_CATEGORY_V1
;
}
}
impl_value_getter
!
{
impl
GeneralCategoryGroup
{
PropertyNameParseGeneralCategoryMaskV1
/
SINGLETON_PROPERTY_NAME_PARSE_GENERAL_CATEGORY_MASK_V1
;
}
}
impl_value_getter
!
{
impl
Script
{
PropertyNameParseScriptV1
/
SINGLETON_PROPERTY_NAME_PARSE_SCRIPT_V1
;
PropertyScriptToIcuScriptMap
/
PropertyNameShortScriptV1
/
SINGLETON_PROPERTY_NAME_SHORT_SCRIPT_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongScriptV1
/
SINGLETON_PROPERTY_NAME_LONG_SCRIPT_V1
;
}
}
impl_value_getter
!
{
impl
HangulSyllableType
{
PropertyNameParseHangulSyllableTypeV1
/
SINGLETON_PROPERTY_NAME_PARSE_HANGUL_SYLLABLE_TYPE_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortHangulSyllableTypeV1
/
SINGLETON_PROPERTY_NAME_SHORT_HANGUL_SYLLABLE_TYPE_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongHangulSyllableTypeV1
/
SINGLETON_PROPERTY_NAME_LONG_HANGUL_SYLLABLE_TYPE_V1
;
}
}
impl_value_getter
!
{
impl
EastAsianWidth
{
PropertyNameParseEastAsianWidthV1
/
SINGLETON_PROPERTY_NAME_PARSE_EAST_ASIAN_WIDTH_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortEastAsianWidthV1
/
SINGLETON_PROPERTY_NAME_SHORT_EAST_ASIAN_WIDTH_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongEastAsianWidthV1
/
SINGLETON_PROPERTY_NAME_LONG_EAST_ASIAN_WIDTH_V1
;
}
}
impl_value_getter
!
{
impl
LineBreak
{
PropertyNameParseLineBreakV1
/
SINGLETON_PROPERTY_NAME_PARSE_LINE_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortLineBreakV1
/
SINGLETON_PROPERTY_NAME_SHORT_LINE_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongLineBreakV1
/
SINGLETON_PROPERTY_NAME_LONG_LINE_BREAK_V1
;
}
}
impl_value_getter
!
{
impl
GraphemeClusterBreak
{
PropertyNameParseGraphemeClusterBreakV1
/
SINGLETON_PROPERTY_NAME_PARSE_GRAPHEME_CLUSTER_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortGraphemeClusterBreakV1
/
SINGLETON_PROPERTY_NAME_SHORT_GRAPHEME_CLUSTER_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongGraphemeClusterBreakV1
/
SINGLETON_PROPERTY_NAME_LONG_GRAPHEME_CLUSTER_BREAK_V1
;
}
}
impl_value_getter
!
{
impl
WordBreak
{
PropertyNameParseWordBreakV1
/
SINGLETON_PROPERTY_NAME_PARSE_WORD_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortWordBreakV1
/
SINGLETON_PROPERTY_NAME_SHORT_WORD_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongWordBreakV1
/
SINGLETON_PROPERTY_NAME_LONG_WORD_BREAK_V1
;
}
}
impl_value_getter
!
{
impl
SentenceBreak
{
PropertyNameParseSentenceBreakV1
/
SINGLETON_PROPERTY_NAME_PARSE_SENTENCE_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortSentenceBreakV1
/
SINGLETON_PROPERTY_NAME_SHORT_SENTENCE_BREAK_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongSentenceBreakV1
/
SINGLETON_PROPERTY_NAME_LONG_SENTENCE_BREAK_V1
;
}
}
impl_value_getter
!
{
impl
CanonicalCombiningClass
{
PropertyNameParseCanonicalCombiningClassV1
/
SINGLETON_PROPERTY_NAME_PARSE_CANONICAL_COMBINING_CLASS_V1
;
PropertyEnumToValueNameSparseMap
/
PropertyNameShortCanonicalCombiningClassV1
/
SINGLETON_PROPERTY_NAME_SHORT_CANONICAL_COMBINING_CLASS_V1
;
PropertyEnumToValueNameSparseMap
/
PropertyNameLongCanonicalCombiningClassV1
/
SINGLETON_PROPERTY_NAME_LONG_CANONICAL_COMBINING_CLASS_V1
;
}
}
impl_value_getter
!
{
impl
IndicSyllabicCategory
{
PropertyNameParseIndicSyllabicCategoryV1
/
SINGLETON_PROPERTY_NAME_PARSE_INDIC_SYLLABIC_CATEGORY_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortIndicSyllabicCategoryV1
/
SINGLETON_PROPERTY_NAME_SHORT_INDIC_SYLLABIC_CATEGORY_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongIndicSyllabicCategoryV1
/
SINGLETON_PROPERTY_NAME_LONG_INDIC_SYLLABIC_CATEGORY_V1
;
}
}
impl_value_getter
!
{
impl
JoiningType
{
PropertyNameParseJoiningTypeV1
/
SINGLETON_PROPERTY_NAME_PARSE_JOINING_TYPE_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortJoiningTypeV1
/
SINGLETON_PROPERTY_NAME_SHORT_JOINING_TYPE_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongJoiningTypeV1
/
SINGLETON_PROPERTY_NAME_LONG_JOINING_TYPE_V1
;
}
}
impl_value_getter
!
{
impl
VerticalOrientation
{
PropertyNameParseVerticalOrientationV1
/
SINGLETON_PROPERTY_NAME_PARSE_VERTICAL_ORIENTATION_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameShortVerticalOrientationV1
/
SINGLETON_PROPERTY_NAME_SHORT_VERTICAL_ORIENTATION_V1
;
PropertyEnumToValueNameLinearMap
/
PropertyNameLongVerticalOrientationV1
/
SINGLETON_PROPERTY_NAME_LONG_VERTICAL_ORIENTATION_V1
;
}
}
