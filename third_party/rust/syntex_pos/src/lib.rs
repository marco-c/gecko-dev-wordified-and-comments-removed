#
!
[
crate_type
=
"
dylib
"
]
#
!
[
crate_type
=
"
rlib
"
]
#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
-
v2
.
png
"
html_favicon_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
doc
.
rust
-
lang
.
org
/
nightly
/
"
)
]
#
!
[
cfg_attr
(
not
(
stage0
)
deny
(
warnings
)
)
]
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
std
:
:
ops
:
:
{
Add
Sub
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
cmp
;
use
std
:
:
fmt
;
use
serialize
:
:
{
Encodable
Decodable
Encoder
Decoder
}
;
extern
crate
rustc_serialize
;
extern
crate
rustc_serialize
as
serialize
;
pub
type
FileName
=
String
;
#
[
derive
(
Clone
Copy
Hash
PartialEq
Eq
)
]
pub
struct
Span
{
pub
lo
:
BytePos
pub
hi
:
BytePos
pub
expn_id
:
ExpnId
}
#
[
derive
(
Clone
)
]
pub
struct
MultiSpan
{
primary_spans
:
Vec
<
Span
>
span_labels
:
Vec
<
(
Span
String
)
>
}
impl
Span
{
pub
fn
end_point
(
self
)
-
>
Span
{
let
lo
=
cmp
:
:
max
(
self
.
hi
.
0
-
1
self
.
lo
.
0
)
;
Span
{
lo
:
BytePos
(
lo
)
hi
:
self
.
hi
expn_id
:
self
.
expn_id
}
}
pub
fn
substitute_dummy
(
self
other
:
Span
)
-
>
Span
{
if
self
.
source_equal
(
&
DUMMY_SP
)
{
other
}
else
{
self
}
}
pub
fn
contains
(
self
other
:
Span
)
-
>
bool
{
self
.
lo
<
=
other
.
lo
&
&
other
.
hi
<
=
self
.
hi
}
pub
fn
source_equal
(
&
self
other
:
&
Span
)
-
>
bool
{
self
.
lo
=
=
other
.
lo
&
&
self
.
hi
=
=
other
.
hi
}
pub
fn
trim_start
(
self
other
:
Span
)
-
>
Option
<
Span
>
{
if
self
.
hi
>
other
.
hi
{
Some
(
Span
{
lo
:
cmp
:
:
max
(
self
.
lo
other
.
hi
)
.
.
self
}
)
}
else
{
None
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
SpanLabel
{
pub
span
:
Span
pub
is_primary
:
bool
pub
label
:
Option
<
String
>
}
impl
Encodable
for
Span
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
s
.
emit_struct
(
"
Span
"
2
|
s
|
{
try
!
(
s
.
emit_struct_field
(
"
lo
"
0
|
s
|
{
self
.
lo
.
encode
(
s
)
}
)
)
;
s
.
emit_struct_field
(
"
hi
"
1
|
s
|
{
self
.
hi
.
encode
(
s
)
}
)
}
)
}
}
impl
Decodable
for
Span
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
Span
D
:
:
Error
>
{
d
.
read_struct
(
"
Span
"
2
|
d
|
{
let
lo
=
try
!
(
d
.
read_struct_field
(
"
lo
"
0
Decodable
:
:
decode
)
)
;
let
hi
=
try
!
(
d
.
read_struct_field
(
"
hi
"
1
Decodable
:
:
decode
)
)
;
Ok
(
mk_sp
(
lo
hi
)
)
}
)
}
}
fn
default_span_debug
(
span
:
Span
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Span
{
{
lo
:
{
:
?
}
hi
:
{
:
?
}
expn_id
:
{
:
?
}
}
}
"
span
.
lo
span
.
hi
span
.
expn_id
)
}
impl
fmt
:
:
Debug
for
Span
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
SPAN_DEBUG
.
with
(
|
span_debug
|
span_debug
.
get
(
)
(
*
self
f
)
)
}
}
pub
const
DUMMY_SP
:
Span
=
Span
{
lo
:
BytePos
(
0
)
hi
:
BytePos
(
0
)
expn_id
:
NO_EXPANSION
}
;
pub
const
COMMAND_LINE_SP
:
Span
=
Span
{
lo
:
BytePos
(
0
)
hi
:
BytePos
(
0
)
expn_id
:
COMMAND_LINE_EXPN
}
;
impl
MultiSpan
{
pub
fn
new
(
)
-
>
MultiSpan
{
MultiSpan
{
primary_spans
:
vec
!
[
]
span_labels
:
vec
!
[
]
}
}
pub
fn
from_span
(
primary_span
:
Span
)
-
>
MultiSpan
{
MultiSpan
{
primary_spans
:
vec
!
[
primary_span
]
span_labels
:
vec
!
[
]
}
}
pub
fn
from_spans
(
vec
:
Vec
<
Span
>
)
-
>
MultiSpan
{
MultiSpan
{
primary_spans
:
vec
span_labels
:
vec
!
[
]
}
}
pub
fn
push_span_label
(
&
mut
self
span
:
Span
label
:
String
)
{
self
.
span_labels
.
push
(
(
span
label
)
)
;
}
pub
fn
primary_span
(
&
self
)
-
>
Option
<
Span
>
{
self
.
primary_spans
.
first
(
)
.
cloned
(
)
}
pub
fn
primary_spans
(
&
self
)
-
>
&
[
Span
]
{
&
self
.
primary_spans
}
pub
fn
replace
(
&
mut
self
before
:
Span
after
:
Span
)
-
>
bool
{
let
mut
replacements_occurred
=
false
;
for
primary_span
in
&
mut
self
.
primary_spans
{
if
*
primary_span
=
=
before
{
*
primary_span
=
after
;
replacements_occurred
=
true
;
}
}
for
span_label
in
&
mut
self
.
span_labels
{
if
span_label
.
0
=
=
before
{
span_label
.
0
=
after
;
replacements_occurred
=
true
;
}
}
replacements_occurred
}
pub
fn
span_labels
(
&
self
)
-
>
Vec
<
SpanLabel
>
{
let
is_primary
=
|
span
|
self
.
primary_spans
.
contains
(
&
span
)
;
let
mut
span_labels
=
vec
!
[
]
;
for
&
(
span
ref
label
)
in
&
self
.
span_labels
{
span_labels
.
push
(
SpanLabel
{
span
:
span
is_primary
:
is_primary
(
span
)
label
:
Some
(
label
.
clone
(
)
)
}
)
;
}
for
&
span
in
&
self
.
primary_spans
{
if
!
span_labels
.
iter
(
)
.
any
(
|
sl
|
sl
.
span
=
=
span
)
{
span_labels
.
push
(
SpanLabel
{
span
:
span
is_primary
:
true
label
:
None
}
)
;
}
}
span_labels
}
}
impl
From
<
Span
>
for
MultiSpan
{
fn
from
(
span
:
Span
)
-
>
MultiSpan
{
MultiSpan
:
:
from_span
(
span
)
}
}
#
[
derive
(
PartialEq
Eq
Clone
Debug
Hash
RustcEncodable
RustcDecodable
Copy
)
]
pub
struct
ExpnId
(
pub
u32
)
;
pub
const
NO_EXPANSION
:
ExpnId
=
ExpnId
(
!
0
)
;
pub
const
COMMAND_LINE_EXPN
:
ExpnId
=
ExpnId
(
!
1
)
;
pub
const
PROC_EXPN
:
ExpnId
=
ExpnId
(
!
2
)
;
impl
ExpnId
{
pub
fn
from_u32
(
id
:
u32
)
-
>
ExpnId
{
ExpnId
(
id
)
}
pub
fn
into_u32
(
self
)
-
>
u32
{
self
.
0
}
}
#
[
derive
(
Copy
Clone
RustcEncodable
RustcDecodable
Eq
PartialEq
)
]
pub
struct
MultiByteChar
{
pub
pos
:
BytePos
pub
bytes
:
usize
}
pub
struct
FileMap
{
pub
name
:
FileName
pub
abs_path
:
Option
<
FileName
>
pub
src
:
Option
<
Rc
<
String
>
>
pub
start_pos
:
BytePos
pub
end_pos
:
BytePos
pub
lines
:
RefCell
<
Vec
<
BytePos
>
>
pub
multibyte_chars
:
RefCell
<
Vec
<
MultiByteChar
>
>
}
impl
Encodable
for
FileMap
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
s
.
emit_struct
(
"
FileMap
"
6
|
s
|
{
try
!
(
s
.
emit_struct_field
(
"
name
"
0
|
s
|
self
.
name
.
encode
(
s
)
)
)
;
try
!
(
s
.
emit_struct_field
(
"
abs_path
"
1
|
s
|
self
.
abs_path
.
encode
(
s
)
)
)
;
try
!
(
s
.
emit_struct_field
(
"
start_pos
"
2
|
s
|
self
.
start_pos
.
encode
(
s
)
)
)
;
try
!
(
s
.
emit_struct_field
(
"
end_pos
"
3
|
s
|
self
.
end_pos
.
encode
(
s
)
)
)
;
try
!
(
s
.
emit_struct_field
(
"
lines
"
4
|
s
|
{
let
lines
=
self
.
lines
.
borrow
(
)
;
/
/
store
the
length
try
!
(
s
.
emit_u32
(
lines
.
len
(
)
as
u32
)
)
;
if
!
lines
.
is_empty
(
)
{
/
/
In
order
to
preserve
some
space
we
exploit
the
fact
that
/
/
the
lines
list
is
sorted
and
individual
lines
are
/
/
probably
not
that
long
.
Because
of
that
we
can
store
lines
/
/
as
a
difference
list
using
as
little
space
as
possible
/
/
for
the
differences
.
let
max_line_length
=
if
lines
.
len
(
)
=
=
1
{
0
}
else
{
lines
.
windows
(
2
)
.
map
(
|
w
|
w
[
1
]
-
w
[
0
]
)
.
map
(
|
bp
|
bp
.
to_usize
(
)
)
.
max
(
)
.
unwrap
(
)
}
;
let
bytes_per_diff
:
u8
=
match
max_line_length
{
0
.
.
.
0xFF
=
>
1
0x100
.
.
.
0xFFFF
=
>
2
_
=
>
4
}
;
/
/
Encode
the
number
of
bytes
used
per
diff
.
try
!
(
bytes_per_diff
.
encode
(
s
)
)
;
/
/
Encode
the
first
element
.
try
!
(
lines
[
0
]
.
encode
(
s
)
)
;
let
diff_iter
=
(
&
lines
[
.
.
]
)
.
windows
(
2
)
.
map
(
|
w
|
(
w
[
1
]
-
w
[
0
]
)
)
;
match
bytes_per_diff
{
1
=
>
for
diff
in
diff_iter
{
try
!
(
(
diff
.
0
as
u8
)
.
encode
(
s
)
)
}
2
=
>
for
diff
in
diff_iter
{
try
!
(
(
diff
.
0
as
u16
)
.
encode
(
s
)
)
}
4
=
>
for
diff
in
diff_iter
{
try
!
(
diff
.
0
.
encode
(
s
)
)
}
_
=
>
unreachable
!
(
)
}
}
Ok
(
(
)
)
}
)
)
;
s
.
emit_struct_field
(
"
multibyte_chars
"
5
|
s
|
{
(
*
self
.
multibyte_chars
.
borrow
(
)
)
.
encode
(
s
)
}
)
}
)
}
}
impl
Decodable
for
FileMap
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
FileMap
D
:
:
Error
>
{
d
.
read_struct
(
"
FileMap
"
6
|
d
|
{
let
name
:
String
=
try
!
(
d
.
read_struct_field
(
"
name
"
0
|
d
|
Decodable
:
:
decode
(
d
)
)
)
;
let
abs_path
:
Option
<
String
>
=
try
!
(
d
.
read_struct_field
(
"
abs_path
"
1
|
d
|
Decodable
:
:
decode
(
d
)
)
)
;
let
start_pos
:
BytePos
=
try
!
(
d
.
read_struct_field
(
"
start_pos
"
2
|
d
|
Decodable
:
:
decode
(
d
)
)
)
;
let
end_pos
:
BytePos
=
try
!
(
d
.
read_struct_field
(
"
end_pos
"
3
|
d
|
Decodable
:
:
decode
(
d
)
)
)
;
let
lines
:
Vec
<
BytePos
>
=
try
!
(
d
.
read_struct_field
(
"
lines
"
4
|
d
|
{
let
num_lines
:
u32
=
try
!
(
Decodable
:
:
decode
(
d
)
)
;
let
mut
lines
=
Vec
:
:
with_capacity
(
num_lines
as
usize
)
;
if
num_lines
>
0
{
/
/
Read
the
number
of
bytes
used
per
diff
.
let
bytes_per_diff
:
u8
=
try
!
(
Decodable
:
:
decode
(
d
)
)
;
/
/
Read
the
first
element
.
let
mut
line_start
:
BytePos
=
try
!
(
Decodable
:
:
decode
(
d
)
)
;
lines
.
push
(
line_start
)
;
for
_
in
1
.
.
num_lines
{
let
diff
=
match
bytes_per_diff
{
1
=
>
try
!
(
d
.
read_u8
(
)
)
as
u32
2
=
>
try
!
(
d
.
read_u16
(
)
)
as
u32
4
=
>
try
!
(
d
.
read_u32
(
)
)
_
=
>
unreachable
!
(
)
}
;
line_start
=
line_start
+
BytePos
(
diff
)
;
lines
.
push
(
line_start
)
;
}
}
Ok
(
lines
)
}
)
)
;
let
multibyte_chars
:
Vec
<
MultiByteChar
>
=
try
!
(
d
.
read_struct_field
(
"
multibyte_chars
"
5
|
d
|
Decodable
:
:
decode
(
d
)
)
)
;
Ok
(
FileMap
{
name
:
name
abs_path
:
abs_path
start_pos
:
start_pos
end_pos
:
end_pos
src
:
None
lines
:
RefCell
:
:
new
(
lines
)
multibyte_chars
:
RefCell
:
:
new
(
multibyte_chars
)
}
)
}
)
}
}
impl
fmt
:
:
Debug
for
FileMap
{
fn
fmt
(
&
self
fmt
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
fmt
"
FileMap
(
{
}
)
"
self
.
name
)
}
}
impl
FileMap
{
pub
fn
next_line
(
&
self
pos
:
BytePos
)
{
let
mut
lines
=
self
.
lines
.
borrow_mut
(
)
;
let
line_len
=
lines
.
len
(
)
;
assert
!
(
line_len
=
=
0
|
|
(
(
*
lines
)
[
line_len
-
1
]
<
pos
)
)
;
lines
.
push
(
pos
)
;
}
pub
fn
get_line
(
&
self
line_number
:
usize
)
-
>
Option
<
&
str
>
{
match
self
.
src
{
Some
(
ref
src
)
=
>
{
let
lines
=
self
.
lines
.
borrow
(
)
;
lines
.
get
(
line_number
)
.
map
(
|
&
line
|
{
let
begin
:
BytePos
=
line
-
self
.
start_pos
;
let
begin
=
begin
.
to_usize
(
)
;
let
slice
=
&
src
[
begin
.
.
]
;
match
slice
.
find
(
'
\
n
'
)
{
Some
(
e
)
=
>
&
slice
[
.
.
e
]
None
=
>
slice
}
}
)
}
None
=
>
None
}
}
pub
fn
record_multibyte_char
(
&
self
pos
:
BytePos
bytes
:
usize
)
{
assert
!
(
bytes
>
=
2
&
&
bytes
<
=
4
)
;
let
mbc
=
MultiByteChar
{
pos
:
pos
bytes
:
bytes
}
;
self
.
multibyte_chars
.
borrow_mut
(
)
.
push
(
mbc
)
;
}
pub
fn
is_real_file
(
&
self
)
-
>
bool
{
!
(
self
.
name
.
starts_with
(
"
<
"
)
&
&
self
.
name
.
ends_with
(
"
>
"
)
)
}
pub
fn
is_imported
(
&
self
)
-
>
bool
{
self
.
src
.
is_none
(
)
}
pub
fn
byte_length
(
&
self
)
-
>
u32
{
self
.
end_pos
.
0
-
self
.
start_pos
.
0
}
pub
fn
count_lines
(
&
self
)
-
>
usize
{
self
.
lines
.
borrow
(
)
.
len
(
)
}
pub
fn
lookup_line
(
&
self
pos
:
BytePos
)
-
>
Option
<
usize
>
{
let
lines
=
self
.
lines
.
borrow
(
)
;
if
lines
.
len
(
)
=
=
0
{
return
None
;
}
let
line_index
=
lookup_line
(
&
lines
[
.
.
]
pos
)
;
assert
!
(
line_index
<
lines
.
len
(
)
as
isize
)
;
if
line_index
>
=
0
{
Some
(
line_index
as
usize
)
}
else
{
None
}
}
pub
fn
line_bounds
(
&
self
line_index
:
usize
)
-
>
(
BytePos
BytePos
)
{
if
self
.
start_pos
=
=
self
.
end_pos
{
return
(
self
.
start_pos
self
.
end_pos
)
;
}
let
lines
=
self
.
lines
.
borrow
(
)
;
assert
!
(
line_index
<
lines
.
len
(
)
)
;
if
line_index
=
=
(
lines
.
len
(
)
-
1
)
{
(
lines
[
line_index
]
self
.
end_pos
)
}
else
{
(
lines
[
line_index
]
lines
[
line_index
+
1
]
)
}
}
}
pub
trait
Pos
{
fn
from_usize
(
n
:
usize
)
-
>
Self
;
fn
to_usize
(
&
self
)
-
>
usize
;
}
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
PartialOrd
Ord
Debug
)
]
pub
struct
BytePos
(
pub
u32
)
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
PartialOrd
Ord
Debug
)
]
pub
struct
CharPos
(
pub
usize
)
;
impl
Pos
for
BytePos
{
fn
from_usize
(
n
:
usize
)
-
>
BytePos
{
BytePos
(
n
as
u32
)
}
fn
to_usize
(
&
self
)
-
>
usize
{
let
BytePos
(
n
)
=
*
self
;
n
as
usize
}
}
impl
Add
for
BytePos
{
type
Output
=
BytePos
;
fn
add
(
self
rhs
:
BytePos
)
-
>
BytePos
{
BytePos
(
(
self
.
to_usize
(
)
+
rhs
.
to_usize
(
)
)
as
u32
)
}
}
impl
Sub
for
BytePos
{
type
Output
=
BytePos
;
fn
sub
(
self
rhs
:
BytePos
)
-
>
BytePos
{
BytePos
(
(
self
.
to_usize
(
)
-
rhs
.
to_usize
(
)
)
as
u32
)
}
}
impl
Encodable
for
BytePos
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
s
.
emit_u32
(
self
.
0
)
}
}
impl
Decodable
for
BytePos
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
BytePos
D
:
:
Error
>
{
Ok
(
BytePos
(
try
!
(
d
.
read_u32
(
)
)
)
)
}
}
impl
Pos
for
CharPos
{
fn
from_usize
(
n
:
usize
)
-
>
CharPos
{
CharPos
(
n
)
}
fn
to_usize
(
&
self
)
-
>
usize
{
let
CharPos
(
n
)
=
*
self
;
n
}
}
impl
Add
for
CharPos
{
type
Output
=
CharPos
;
fn
add
(
self
rhs
:
CharPos
)
-
>
CharPos
{
CharPos
(
self
.
to_usize
(
)
+
rhs
.
to_usize
(
)
)
}
}
impl
Sub
for
CharPos
{
type
Output
=
CharPos
;
fn
sub
(
self
rhs
:
CharPos
)
-
>
CharPos
{
CharPos
(
self
.
to_usize
(
)
-
rhs
.
to_usize
(
)
)
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Loc
{
pub
file
:
Rc
<
FileMap
>
pub
line
:
usize
pub
col
:
CharPos
}
#
[
derive
(
Debug
)
]
pub
struct
LocWithOpt
{
pub
filename
:
FileName
pub
line
:
usize
pub
col
:
CharPos
pub
file
:
Option
<
Rc
<
FileMap
>
>
}
#
[
derive
(
Debug
)
]
pub
struct
FileMapAndLine
{
pub
fm
:
Rc
<
FileMap
>
pub
line
:
usize
}
#
[
derive
(
Debug
)
]
pub
struct
FileMapAndBytePos
{
pub
fm
:
Rc
<
FileMap
>
pub
pos
:
BytePos
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
pub
struct
LineInfo
{
pub
line_index
:
usize
pub
start_col
:
CharPos
pub
end_col
:
CharPos
}
pub
struct
FileLines
{
pub
file
:
Rc
<
FileMap
>
pub
lines
:
Vec
<
LineInfo
>
}
thread_local
!
(
pub
static
SPAN_DEBUG
:
Cell
<
fn
(
Span
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
>
=
Cell
:
:
new
(
default_span_debug
)
)
;
pub
fn
mk_sp
(
lo
:
BytePos
hi
:
BytePos
)
-
>
Span
{
Span
{
lo
:
lo
hi
:
hi
expn_id
:
NO_EXPANSION
}
}
pub
struct
MacroBacktrace
{
pub
call_site
:
Span
pub
macro_decl_name
:
String
pub
def_site_span
:
Option
<
Span
>
}
pub
type
FileLinesResult
=
Result
<
FileLines
SpanLinesError
>
;
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
enum
SpanLinesError
{
IllFormedSpan
(
Span
)
DistinctSources
(
DistinctSources
)
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
enum
SpanSnippetError
{
IllFormedSpan
(
Span
)
DistinctSources
(
DistinctSources
)
MalformedForCodemap
(
MalformedCodemapPositions
)
SourceNotAvailable
{
filename
:
String
}
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
struct
DistinctSources
{
pub
begin
:
(
String
BytePos
)
pub
end
:
(
String
BytePos
)
}
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
struct
MalformedCodemapPositions
{
pub
name
:
String
pub
source_len
:
usize
pub
begin_pos
:
BytePos
pub
end_pos
:
BytePos
}
fn
lookup_line
(
lines
:
&
[
BytePos
]
pos
:
BytePos
)
-
>
isize
{
match
lines
.
binary_search
(
&
pos
)
{
Ok
(
line
)
=
>
line
as
isize
Err
(
line
)
=
>
line
as
isize
-
1
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
{
lookup_line
BytePos
}
;
#
[
test
]
fn
test_lookup_line
(
)
{
let
lines
=
&
[
BytePos
(
3
)
BytePos
(
17
)
BytePos
(
28
)
]
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
0
)
)
-
1
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
3
)
)
0
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
4
)
)
0
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
16
)
)
0
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
17
)
)
1
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
18
)
)
1
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
28
)
)
2
)
;
assert_eq
!
(
lookup_line
(
lines
BytePos
(
29
)
)
2
)
;
}
}
