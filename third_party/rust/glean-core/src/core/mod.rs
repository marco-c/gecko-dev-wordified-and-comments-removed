use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU8
Ordering
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
chrono
:
:
{
DateTime
FixedOffset
}
;
use
once_cell
:
:
sync
:
:
OnceCell
;
use
crate
:
:
database
:
:
Database
;
use
crate
:
:
debug
:
:
DebugOptions
;
use
crate
:
:
event_database
:
:
EventDatabase
;
use
crate
:
:
internal_metrics
:
:
{
AdditionalMetrics
CoreMetrics
DatabaseMetrics
}
;
use
crate
:
:
internal_pings
:
:
InternalPings
;
use
crate
:
:
metrics
:
:
{
self
ExperimentMetric
Metric
MetricType
MetricsEnabledConfig
PingType
RecordedExperiment
}
;
use
crate
:
:
ping
:
:
PingMaker
;
use
crate
:
:
storage
:
:
{
StorageManager
INTERNAL_STORAGE
}
;
use
crate
:
:
upload
:
:
{
PingUploadManager
PingUploadTask
UploadResult
UploadTaskAction
}
;
use
crate
:
:
util
:
:
{
local_now_with_offset
sanitize_application_id
}
;
use
crate
:
:
{
scheduler
system
CommonMetricData
ErrorKind
InternalConfiguration
Lifetime
PingRateLimit
Result
DEFAULT_MAX_EVENTS
GLEAN_SCHEMA_VERSION
GLEAN_VERSION
KNOWN_CLIENT_ID
}
;
static
GLEAN
:
OnceCell
<
Mutex
<
Glean
>
>
=
OnceCell
:
:
new
(
)
;
pub
fn
global_glean
(
)
-
>
Option
<
&
'
static
Mutex
<
Glean
>
>
{
GLEAN
.
get
(
)
}
pub
fn
setup_glean
(
glean
:
Glean
)
-
>
Result
<
(
)
>
{
if
GLEAN
.
get
(
)
.
is_none
(
)
{
if
GLEAN
.
set
(
Mutex
:
:
new
(
glean
)
)
.
is_err
(
)
{
log
:
:
warn
!
(
"
Global
Glean
object
is
initialized
already
.
This
probably
happened
concurrently
.
"
)
}
}
else
{
let
mut
lock
=
GLEAN
.
get
(
)
.
unwrap
(
)
.
lock
(
)
.
unwrap
(
)
;
*
lock
=
glean
;
}
Ok
(
(
)
)
}
pub
fn
with_glean
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
Glean
)
-
>
R
{
let
glean
=
global_glean
(
)
.
expect
(
"
Global
Glean
object
not
initialized
"
)
;
let
lock
=
glean
.
lock
(
)
.
unwrap
(
)
;
f
(
&
lock
)
}
pub
fn
with_glean_mut
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Glean
)
-
>
R
{
let
glean
=
global_glean
(
)
.
expect
(
"
Global
Glean
object
not
initialized
"
)
;
let
mut
lock
=
glean
.
lock
(
)
.
unwrap
(
)
;
f
(
&
mut
lock
)
}
pub
fn
with_opt_glean
<
F
R
>
(
f
:
F
)
-
>
Option
<
R
>
where
F
:
FnOnce
(
&
Glean
)
-
>
R
{
let
glean
=
global_glean
(
)
?
;
let
lock
=
glean
.
lock
(
)
.
unwrap
(
)
;
Some
(
f
(
&
lock
)
)
}
#
[
derive
(
Debug
)
]
pub
struct
Glean
{
upload_enabled
:
bool
pub
(
crate
)
data_store
:
Option
<
Database
>
event_data_store
:
EventDatabase
pub
(
crate
)
core_metrics
:
CoreMetrics
pub
(
crate
)
additional_metrics
:
AdditionalMetrics
pub
(
crate
)
database_metrics
:
DatabaseMetrics
pub
(
crate
)
internal_pings
:
InternalPings
data_path
:
PathBuf
application_id
:
String
ping_registry
:
HashMap
<
String
PingType
>
start_time
:
DateTime
<
FixedOffset
>
max_events
:
u32
is_first_run
:
bool
pub
(
crate
)
upload_manager
:
PingUploadManager
debug
:
DebugOptions
pub
(
crate
)
app_build
:
String
pub
(
crate
)
schedule_metrics_pings
:
bool
pub
(
crate
)
remote_settings_epoch
:
AtomicU8
pub
(
crate
)
remote_settings_metrics_config
:
Arc
<
Mutex
<
MetricsEnabledConfig
>
>
pub
(
crate
)
with_timestamps
:
bool
}
impl
Glean
{
pub
fn
new_for_subprocess
(
cfg
:
&
InternalConfiguration
scan_directories
:
bool
)
-
>
Result
<
Self
>
{
log
:
:
info
!
(
"
Creating
new
Glean
v
{
}
"
GLEAN_VERSION
)
;
let
application_id
=
sanitize_application_id
(
&
cfg
.
application_id
)
;
if
application_id
.
is_empty
(
)
{
return
Err
(
ErrorKind
:
:
InvalidConfig
.
into
(
)
)
;
}
let
data_path
=
Path
:
:
new
(
&
cfg
.
data_path
)
;
let
event_data_store
=
EventDatabase
:
:
new
(
data_path
)
?
;
let
mut
upload_manager
=
PingUploadManager
:
:
new
(
&
cfg
.
data_path
&
cfg
.
language_binding_name
)
;
let
rate_limit
=
cfg
.
rate_limit
.
as_ref
(
)
.
unwrap_or
(
&
PingRateLimit
{
seconds_per_interval
:
60
pings_per_interval
:
15
}
)
;
upload_manager
.
set_rate_limiter
(
rate_limit
.
seconds_per_interval
rate_limit
.
pings_per_interval
)
;
if
scan_directories
{
let
_scanning_thread
=
upload_manager
.
scan_pending_pings_directories
(
false
)
;
}
let
start_time
=
local_now_with_offset
(
)
;
let
mut
this
=
Self
{
upload_enabled
:
cfg
.
upload_enabled
data_store
:
None
event_data_store
core_metrics
:
CoreMetrics
:
:
new
(
)
additional_metrics
:
AdditionalMetrics
:
:
new
(
)
database_metrics
:
DatabaseMetrics
:
:
new
(
)
internal_pings
:
InternalPings
:
:
new
(
)
upload_manager
data_path
:
PathBuf
:
:
from
(
&
cfg
.
data_path
)
application_id
ping_registry
:
HashMap
:
:
new
(
)
start_time
max_events
:
cfg
.
max_events
.
unwrap_or
(
DEFAULT_MAX_EVENTS
)
is_first_run
:
false
debug
:
DebugOptions
:
:
new
(
)
app_build
:
cfg
.
app_build
.
to_string
(
)
schedule_metrics_pings
:
false
remote_settings_epoch
:
AtomicU8
:
:
new
(
0
)
remote_settings_metrics_config
:
Arc
:
:
new
(
Mutex
:
:
new
(
MetricsEnabledConfig
:
:
new
(
)
)
)
with_timestamps
:
cfg
.
enable_event_timestamps
}
;
let
pings
=
this
.
internal_pings
.
clone
(
)
;
this
.
register_ping_type
(
&
pings
.
baseline
)
;
this
.
register_ping_type
(
&
pings
.
metrics
)
;
this
.
register_ping_type
(
&
pings
.
events
)
;
this
.
register_ping_type
(
&
pings
.
deletion_request
)
;
Ok
(
this
)
}
pub
fn
new
(
cfg
:
InternalConfiguration
)
-
>
Result
<
Self
>
{
let
mut
glean
=
Self
:
:
new_for_subprocess
(
&
cfg
false
)
?
;
let
data_path
=
Path
:
:
new
(
&
cfg
.
data_path
)
;
glean
.
data_store
=
Some
(
Database
:
:
new
(
data_path
cfg
.
delay_ping_lifetime_io
)
?
)
;
if
let
Some
(
experimentation_id
)
=
&
cfg
.
experimentation_id
{
glean
.
additional_metrics
.
experimentation_id
.
set_sync
(
&
glean
experimentation_id
.
to_string
(
)
)
;
}
if
cfg
.
upload_enabled
{
glean
.
on_upload_enabled
(
)
;
}
else
{
match
glean
.
core_metrics
.
client_id
.
get_value
(
&
glean
Some
(
"
glean_client_info
"
)
)
{
None
=
>
glean
.
clear_metrics
(
)
Some
(
uuid
)
=
>
{
if
uuid
!
=
*
KNOWN_CLIENT_ID
{
glean
.
upload_enabled
=
true
;
glean
.
on_upload_disabled
(
true
)
;
}
}
}
}
glean
.
schedule_metrics_pings
=
cfg
.
use_core_mps
;
let
_scanning_thread
=
glean
.
upload_manager
.
scan_pending_pings_directories
(
true
)
;
Ok
(
glean
)
}
#
[
cfg
(
test
)
]
pub
(
crate
)
fn
with_options
(
data_path
:
&
str
application_id
:
&
str
upload_enabled
:
bool
)
-
>
Self
{
let
cfg
=
InternalConfiguration
{
data_path
:
data_path
.
into
(
)
application_id
:
application_id
.
into
(
)
language_binding_name
:
"
Rust
"
.
into
(
)
upload_enabled
max_events
:
None
delay_ping_lifetime_io
:
false
app_build
:
"
Unknown
"
.
into
(
)
use_core_mps
:
false
trim_data_to_registered_pings
:
false
log_level
:
None
rate_limit
:
None
enable_event_timestamps
:
true
experimentation_id
:
None
}
;
let
mut
glean
=
Self
:
:
new
(
cfg
)
.
unwrap
(
)
;
glean
.
upload_manager
=
PingUploadManager
:
:
no_policy
(
data_path
)
;
glean
}
pub
fn
destroy_db
(
&
mut
self
)
{
self
.
data_store
=
None
;
}
fn
initialize_core_metrics
(
&
mut
self
)
{
let
need_new_client_id
=
match
self
.
core_metrics
.
client_id
.
get_value
(
self
Some
(
"
glean_client_info
"
)
)
{
None
=
>
true
Some
(
uuid
)
=
>
uuid
=
=
*
KNOWN_CLIENT_ID
}
;
if
need_new_client_id
{
self
.
core_metrics
.
client_id
.
generate_and_set_sync
(
self
)
;
}
if
self
.
core_metrics
.
first_run_date
.
get_value
(
self
"
glean_client_info
"
)
.
is_none
(
)
{
self
.
core_metrics
.
first_run_date
.
set_sync
(
self
None
)
;
self
.
is_first_run
=
true
;
}
self
.
set_application_lifetime_core_metrics
(
)
;
}
fn
initialize_database_metrics
(
&
mut
self
)
{
log
:
:
trace
!
(
"
Initializing
database
metrics
"
)
;
if
let
Some
(
size
)
=
self
.
data_store
.
as_ref
(
)
.
and_then
(
|
database
|
database
.
file_size
(
)
)
{
log
:
:
trace
!
(
"
Database
file
size
:
{
}
"
size
.
get
(
)
)
;
self
.
database_metrics
.
size
.
accumulate_sync
(
self
size
.
get
(
)
as
i64
)
}
if
let
Some
(
rkv_load_state
)
=
self
.
data_store
.
as_ref
(
)
.
and_then
(
|
database
|
database
.
rkv_load_state
(
)
)
{
self
.
database_metrics
.
rkv_load_error
.
set_sync
(
self
rkv_load_state
)
}
}
pub
fn
on_ready_to_submit_pings
(
&
self
trim_data_to_registered_pings
:
bool
)
-
>
bool
{
self
.
event_data_store
.
flush_pending_events_on_startup
(
self
trim_data_to_registered_pings
)
}
pub
fn
set_upload_enabled
(
&
mut
self
flag
:
bool
)
-
>
bool
{
log
:
:
info
!
(
"
Upload
enabled
:
{
:
?
}
"
flag
)
;
if
self
.
upload_enabled
!
=
flag
{
if
flag
{
self
.
on_upload_enabled
(
)
;
}
else
{
self
.
on_upload_disabled
(
false
)
;
}
true
}
else
{
false
}
}
pub
fn
is_upload_enabled
(
&
self
)
-
>
bool
{
self
.
upload_enabled
}
fn
on_upload_enabled
(
&
mut
self
)
{
self
.
upload_enabled
=
true
;
self
.
initialize_core_metrics
(
)
;
self
.
initialize_database_metrics
(
)
;
}
fn
on_upload_disabled
(
&
mut
self
during_init
:
bool
)
{
let
reason
=
if
during_init
{
Some
(
"
at_init
"
)
}
else
{
Some
(
"
set_upload_enabled
"
)
}
;
if
!
self
.
internal_pings
.
deletion_request
.
submit_sync
(
self
reason
)
{
log
:
:
error
!
(
"
Failed
to
submit
deletion
-
request
ping
on
optout
.
"
)
;
}
self
.
clear_metrics
(
)
;
self
.
upload_enabled
=
false
;
}
fn
clear_metrics
(
&
mut
self
)
{
let
_lock
=
self
.
upload_manager
.
clear_ping_queue
(
)
;
let
existing_first_run_date
=
self
.
core_metrics
.
first_run_date
.
get_value
(
self
"
glean_client_info
"
)
;
let
ping_maker
=
PingMaker
:
:
new
(
)
;
if
let
Err
(
err
)
=
ping_maker
.
clear_pending_pings
(
self
.
get_data_path
(
)
)
{
log
:
:
warn
!
(
"
Error
clearing
pending
pings
:
{
}
"
err
)
;
}
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
data
.
clear_all
(
)
}
if
let
Err
(
err
)
=
self
.
event_data_store
.
clear_all
(
)
{
log
:
:
warn
!
(
"
Error
clearing
pending
events
:
{
}
"
err
)
;
}
{
self
.
upload_enabled
=
true
;
self
.
core_metrics
.
client_id
.
set_from_uuid_sync
(
self
*
KNOWN_CLIENT_ID
)
;
if
let
Some
(
existing_first_run_date
)
=
existing_first_run_date
{
self
.
core_metrics
.
first_run_date
.
set_sync_chrono
(
self
existing_first_run_date
)
;
}
self
.
upload_enabled
=
false
;
}
}
pub
fn
get_application_id
(
&
self
)
-
>
&
str
{
&
self
.
application_id
}
pub
fn
get_data_path
(
&
self
)
-
>
&
Path
{
&
self
.
data_path
}
#
[
track_caller
]
pub
fn
storage
(
&
self
)
-
>
&
Database
{
self
.
data_store
.
as_ref
(
)
.
expect
(
"
No
database
found
"
)
}
pub
fn
storage_opt
(
&
self
)
-
>
Option
<
&
Database
>
{
self
.
data_store
.
as_ref
(
)
}
pub
fn
event_storage
(
&
self
)
-
>
&
EventDatabase
{
&
self
.
event_data_store
}
pub
(
crate
)
fn
with_timestamps
(
&
self
)
-
>
bool
{
self
.
with_timestamps
}
pub
fn
get_max_events
(
&
self
)
-
>
usize
{
self
.
max_events
as
usize
}
pub
fn
get_upload_task
(
&
self
)
-
>
PingUploadTask
{
self
.
upload_manager
.
get_upload_task
(
self
self
.
log_pings
(
)
)
}
pub
fn
process_ping_upload_response
(
&
self
uuid
:
&
str
status
:
UploadResult
)
-
>
UploadTaskAction
{
self
.
upload_manager
.
process_ping_upload_response
(
self
uuid
status
)
}
pub
fn
snapshot
(
&
mut
self
store_name
:
&
str
clear_store
:
bool
)
-
>
String
{
StorageManager
.
snapshot
(
self
.
storage
(
)
store_name
clear_store
)
.
unwrap_or_else
(
|
|
String
:
:
from
(
"
"
)
)
}
pub
(
crate
)
fn
make_path
(
&
self
ping_name
:
&
str
doc_id
:
&
str
)
-
>
String
{
format
!
(
"
/
submit
/
{
}
/
{
}
/
{
}
/
{
}
"
self
.
get_application_id
(
)
ping_name
GLEAN_SCHEMA_VERSION
doc_id
)
}
pub
fn
submit_ping_by_name
(
&
self
ping_name
:
&
str
reason
:
Option
<
&
str
>
)
-
>
bool
{
match
self
.
get_ping_by_name
(
ping_name
)
{
None
=
>
{
log
:
:
error
!
(
"
Attempted
to
submit
unknown
ping
'
{
}
'
"
ping_name
)
;
false
}
Some
(
ping
)
=
>
ping
.
submit_sync
(
self
reason
)
}
}
pub
fn
get_ping_by_name
(
&
self
ping_name
:
&
str
)
-
>
Option
<
&
PingType
>
{
self
.
ping_registry
.
get
(
ping_name
)
}
pub
fn
register_ping_type
(
&
mut
self
ping
:
&
PingType
)
{
if
self
.
ping_registry
.
contains_key
(
ping
.
name
(
)
)
{
log
:
:
debug
!
(
"
Duplicate
ping
named
'
{
}
'
"
ping
.
name
(
)
)
}
self
.
ping_registry
.
insert
(
ping
.
name
(
)
.
to_string
(
)
ping
.
clone
(
)
)
;
}
pub
(
crate
)
fn
start_time
(
&
self
)
-
>
DateTime
<
FixedOffset
>
{
self
.
start_time
}
pub
fn
set_experiment_active
(
&
self
experiment_id
:
String
branch
:
String
extra
:
HashMap
<
String
String
>
)
{
let
metric
=
ExperimentMetric
:
:
new
(
self
experiment_id
)
;
metric
.
set_active_sync
(
self
branch
extra
)
;
}
pub
fn
set_experiment_inactive
(
&
self
experiment_id
:
String
)
{
let
metric
=
ExperimentMetric
:
:
new
(
self
experiment_id
)
;
metric
.
set_inactive_sync
(
self
)
;
}
pub
fn
test_get_experiment_data
(
&
self
experiment_id
:
String
)
-
>
Option
<
RecordedExperiment
>
{
let
metric
=
ExperimentMetric
:
:
new
(
self
experiment_id
)
;
metric
.
test_get_value
(
self
)
}
pub
fn
test_get_experimentation_id
(
&
self
)
-
>
Option
<
String
>
{
self
.
additional_metrics
.
experimentation_id
.
get_value
(
self
None
)
}
pub
fn
set_metrics_enabled_config
(
&
self
cfg
:
MetricsEnabledConfig
)
{
let
mut
metric_config
=
self
.
remote_settings_metrics_config
.
lock
(
)
.
unwrap
(
)
;
metric_config
.
metrics_enabled
.
extend
(
cfg
.
metrics_enabled
)
;
self
.
remote_settings_epoch
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
}
pub
fn
persist_ping_lifetime_data
(
&
self
)
-
>
Result
<
(
)
>
{
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
return
data
.
persist_ping_lifetime_data
(
)
;
}
Ok
(
(
)
)
}
fn
set_application_lifetime_core_metrics
(
&
self
)
{
self
.
core_metrics
.
os
.
set_sync
(
self
system
:
:
OS
)
;
}
pub
fn
clear_application_lifetime_metrics
(
&
self
)
{
log
:
:
trace
!
(
"
Clearing
Lifetime
:
:
Application
metrics
"
)
;
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
data
.
clear_lifetime
(
Lifetime
:
:
Application
)
;
}
self
.
set_application_lifetime_core_metrics
(
)
;
}
pub
fn
is_first_run
(
&
self
)
-
>
bool
{
self
.
is_first_run
}
pub
fn
set_debug_view_tag
(
&
mut
self
value
:
&
str
)
-
>
bool
{
self
.
debug
.
debug_view_tag
.
set
(
value
.
into
(
)
)
}
pub
(
crate
)
fn
debug_view_tag
(
&
self
)
-
>
Option
<
&
String
>
{
self
.
debug
.
debug_view_tag
.
get
(
)
}
pub
fn
set_source_tags
(
&
mut
self
value
:
Vec
<
String
>
)
-
>
bool
{
self
.
debug
.
source_tags
.
set
(
value
)
}
pub
(
crate
)
fn
source_tags
(
&
self
)
-
>
Option
<
&
Vec
<
String
>
>
{
self
.
debug
.
source_tags
.
get
(
)
}
pub
fn
set_log_pings
(
&
mut
self
value
:
bool
)
-
>
bool
{
self
.
debug
.
log_pings
.
set
(
value
)
}
pub
(
crate
)
fn
log_pings
(
&
self
)
-
>
bool
{
self
.
debug
.
log_pings
.
get
(
)
.
copied
(
)
.
unwrap_or
(
false
)
}
fn
get_dirty_bit_metric
(
&
self
)
-
>
metrics
:
:
BooleanMetric
{
metrics
:
:
BooleanMetric
:
:
new
(
CommonMetricData
{
name
:
"
dirtybit
"
.
into
(
)
category
:
"
"
.
into
(
)
send_in_pings
:
vec
!
[
INTERNAL_STORAGE
.
into
(
)
]
lifetime
:
Lifetime
:
:
User
.
.
Default
:
:
default
(
)
}
)
}
pub
fn
set_dirty_flag
(
&
self
new_value
:
bool
)
{
self
.
get_dirty_bit_metric
(
)
.
set_sync
(
self
new_value
)
;
}
pub
fn
is_dirty_flag_set
(
&
self
)
-
>
bool
{
let
dirty_bit_metric
=
self
.
get_dirty_bit_metric
(
)
;
match
StorageManager
.
snapshot_metric
(
self
.
storage
(
)
INTERNAL_STORAGE
&
dirty_bit_metric
.
meta
(
)
.
identifier
(
self
)
dirty_bit_metric
.
meta
(
)
.
inner
.
lifetime
)
{
Some
(
Metric
:
:
Boolean
(
b
)
)
=
>
b
_
=
>
false
}
}
pub
fn
handle_client_active
(
&
mut
self
)
{
if
!
self
.
internal_pings
.
baseline
.
submit_sync
(
self
Some
(
"
active
"
)
)
{
log
:
:
info
!
(
"
baseline
ping
not
submitted
on
active
"
)
;
}
self
.
set_dirty_flag
(
true
)
;
}
pub
fn
handle_client_inactive
(
&
mut
self
)
{
if
!
self
.
internal_pings
.
baseline
.
submit_sync
(
self
Some
(
"
inactive
"
)
)
{
log
:
:
info
!
(
"
baseline
ping
not
submitted
on
inactive
"
)
;
}
if
!
self
.
internal_pings
.
events
.
submit_sync
(
self
Some
(
"
inactive
"
)
)
{
log
:
:
info
!
(
"
events
ping
not
submitted
on
inactive
"
)
;
}
self
.
set_dirty_flag
(
false
)
;
}
pub
fn
test_clear_all_stores
(
&
self
)
{
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
data
.
clear_all
(
)
}
let
_
=
self
.
event_data_store
.
clear_all
(
)
;
}
pub
fn
cancel_metrics_ping_scheduler
(
&
self
)
{
if
self
.
schedule_metrics_pings
{
scheduler
:
:
cancel
(
)
;
}
}
pub
fn
start_metrics_ping_scheduler
(
&
self
)
{
if
self
.
schedule_metrics_pings
{
scheduler
:
:
schedule
(
self
)
;
}
}
}
