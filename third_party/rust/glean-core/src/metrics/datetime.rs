#
!
[
allow
(
clippy
:
:
too_many_arguments
)
]
use
crate
:
:
error_recording
:
:
{
record_error
ErrorType
}
;
use
crate
:
:
metrics
:
:
time_unit
:
:
TimeUnit
;
use
crate
:
:
metrics
:
:
Metric
;
use
crate
:
:
metrics
:
:
MetricType
;
use
crate
:
:
storage
:
:
StorageManager
;
use
crate
:
:
util
:
:
{
get_iso_time_string
local_now_with_offset
}
;
use
crate
:
:
CommonMetricData
;
use
crate
:
:
Glean
;
use
chrono
:
:
{
DateTime
FixedOffset
TimeZone
Timelike
}
;
pub
type
Datetime
=
DateTime
<
FixedOffset
>
;
#
[
derive
(
Debug
)
]
pub
struct
DatetimeMetric
{
meta
:
CommonMetricData
time_unit
:
TimeUnit
}
impl
MetricType
for
DatetimeMetric
{
fn
meta
(
&
self
)
-
>
&
CommonMetricData
{
&
self
.
meta
}
fn
meta_mut
(
&
mut
self
)
-
>
&
mut
CommonMetricData
{
&
mut
self
.
meta
}
}
impl
DatetimeMetric
{
pub
fn
new
(
meta
:
CommonMetricData
time_unit
:
TimeUnit
)
-
>
Self
{
Self
{
meta
time_unit
}
}
pub
fn
set_with_details
(
&
self
glean
:
&
Glean
year
:
i32
month
:
u32
day
:
u32
hour
:
u32
minute
:
u32
second
:
u32
nano
:
u32
offset_seconds
:
i32
)
{
if
!
self
.
should_record
(
glean
)
{
return
;
}
let
timezone_offset
=
FixedOffset
:
:
east_opt
(
offset_seconds
)
;
if
timezone_offset
.
is_none
(
)
{
let
msg
=
format
!
(
"
Invalid
timezone
offset
{
}
.
Not
recording
.
"
offset_seconds
)
;
record_error
(
glean
&
self
.
meta
ErrorType
:
:
InvalidValue
msg
None
)
;
return
;
}
;
let
datetime_obj
=
FixedOffset
:
:
east
(
offset_seconds
)
.
ymd_opt
(
year
month
day
)
.
and_hms_nano_opt
(
hour
minute
second
nano
)
;
match
datetime_obj
.
single
(
)
{
Some
(
d
)
=
>
self
.
set
(
glean
Some
(
d
)
)
_
=
>
{
record_error
(
glean
&
self
.
meta
ErrorType
:
:
InvalidValue
"
Invalid
input
data
.
Not
recording
.
"
None
)
;
}
}
}
pub
fn
set
(
&
self
glean
:
&
Glean
value
:
Option
<
Datetime
>
)
{
if
!
self
.
should_record
(
glean
)
{
return
;
}
let
value
=
value
.
unwrap_or_else
(
local_now_with_offset
)
;
let
value
=
Metric
:
:
Datetime
(
value
self
.
time_unit
)
;
glean
.
storage
(
)
.
record
(
glean
&
self
.
meta
&
value
)
}
pub
(
crate
)
fn
get_value
(
&
self
glean
:
&
Glean
storage_name
:
&
str
)
-
>
Option
<
Datetime
>
{
match
StorageManager
.
snapshot_metric
(
glean
.
storage
(
)
storage_name
&
self
.
meta
.
identifier
(
glean
)
self
.
meta
.
lifetime
)
{
Some
(
Metric
:
:
Datetime
(
dt
_
)
)
=
>
Some
(
dt
)
_
=
>
None
}
}
pub
fn
test_get_value
(
&
self
glean
:
&
Glean
storage_name
:
&
str
)
-
>
Option
<
Datetime
>
{
match
StorageManager
.
snapshot_metric_for_test
(
glean
.
storage
(
)
storage_name
&
self
.
meta
.
identifier
(
glean
)
self
.
meta
.
lifetime
)
{
Some
(
Metric
:
:
Datetime
(
d
tu
)
)
=
>
{
let
time
=
d
.
time
(
)
;
match
tu
{
TimeUnit
:
:
Nanosecond
=
>
d
.
date
(
)
.
and_hms_nano_opt
(
time
.
hour
(
)
time
.
minute
(
)
time
.
second
(
)
time
.
nanosecond
(
)
)
TimeUnit
:
:
Microsecond
=
>
d
.
date
(
)
.
and_hms_nano_opt
(
time
.
hour
(
)
time
.
minute
(
)
time
.
second
(
)
time
.
nanosecond
(
)
/
1000
)
TimeUnit
:
:
Millisecond
=
>
d
.
date
(
)
.
and_hms_nano_opt
(
time
.
hour
(
)
time
.
minute
(
)
time
.
second
(
)
time
.
nanosecond
(
)
/
1000000
)
TimeUnit
:
:
Second
=
>
{
d
.
date
(
)
.
and_hms_nano_opt
(
time
.
hour
(
)
time
.
minute
(
)
time
.
second
(
)
0
)
}
TimeUnit
:
:
Minute
=
>
d
.
date
(
)
.
and_hms_nano_opt
(
time
.
hour
(
)
time
.
minute
(
)
0
0
)
TimeUnit
:
:
Hour
=
>
d
.
date
(
)
.
and_hms_nano_opt
(
time
.
hour
(
)
0
0
0
)
TimeUnit
:
:
Day
=
>
d
.
date
(
)
.
and_hms_nano_opt
(
0
0
0
0
)
}
}
_
=
>
None
}
}
pub
fn
test_get_value_as_string
(
&
self
glean
:
&
Glean
storage_name
:
&
str
)
-
>
Option
<
String
>
{
match
StorageManager
.
snapshot_metric_for_test
(
glean
.
storage
(
)
storage_name
&
self
.
meta
.
identifier
(
glean
)
self
.
meta
.
lifetime
)
{
Some
(
Metric
:
:
Datetime
(
d
tu
)
)
=
>
Some
(
get_iso_time_string
(
d
tu
)
)
_
=
>
None
}
}
}
