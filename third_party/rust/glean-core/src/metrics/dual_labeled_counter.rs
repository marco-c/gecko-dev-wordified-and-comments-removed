use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
char
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
crate
:
:
common_metric_data
:
:
{
CommonMetricData
CommonMetricDataInternal
DynamicLabelType
}
;
use
crate
:
:
error_recording
:
:
{
record_error
test_get_num_recorded_errors
ErrorType
}
;
use
crate
:
:
metrics
:
:
{
CounterMetric
Metric
MetricType
}
;
use
crate
:
:
Glean
;
const
MAX_LABELS
:
usize
=
16
;
const
OTHER_LABEL
:
&
str
=
"
__other__
"
;
const
MAX_LABEL_LENGTH
:
usize
=
111
;
pub
(
crate
)
const
RECORD_SEPARATOR
:
char
=
'
\
x1E
'
;
#
[
derive
(
Debug
)
]
pub
struct
DualLabeledCounterMetric
{
keys
:
Option
<
Vec
<
Cow
<
'
static
str
>
>
>
categories
:
Option
<
Vec
<
Cow
<
'
static
str
>
>
>
counter
:
CounterMetric
dual_label_map
:
Mutex
<
HashMap
<
(
String
String
)
Arc
<
CounterMetric
>
>
>
}
impl
:
:
malloc_size_of
:
:
MallocSizeOf
for
DualLabeledCounterMetric
{
fn
size_of
(
&
self
_ops
:
&
mut
malloc_size_of
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
impl
MetricType
for
DualLabeledCounterMetric
{
fn
meta
(
&
self
)
-
>
&
CommonMetricDataInternal
{
self
.
counter
.
meta
(
)
}
}
impl
DualLabeledCounterMetric
{
pub
fn
new
(
meta
:
CommonMetricData
keys
:
Option
<
Vec
<
Cow
<
'
static
str
>
>
>
catgories
:
Option
<
Vec
<
Cow
<
'
static
str
>
>
>
)
-
>
DualLabeledCounterMetric
{
let
submetric
=
CounterMetric
:
:
new
(
meta
)
;
DualLabeledCounterMetric
:
:
new_inner
(
submetric
keys
catgories
)
}
fn
new_inner
(
counter
:
CounterMetric
keys
:
Option
<
Vec
<
Cow
<
'
static
str
>
>
>
categories
:
Option
<
Vec
<
Cow
<
'
static
str
>
>
>
)
-
>
DualLabeledCounterMetric
{
let
dual_label_map
=
Default
:
:
default
(
)
;
DualLabeledCounterMetric
{
keys
categories
counter
dual_label_map
}
}
fn
new_counter_metric
(
&
self
key
:
&
str
category
:
&
str
)
-
>
CounterMetric
{
match
(
&
self
.
keys
&
self
.
categories
)
{
(
None
None
)
=
>
self
.
counter
.
with_dynamic_label
(
DynamicLabelType
:
:
KeyAndCategory
(
make_label_from_key_and_category
(
key
category
)
)
)
(
None
_
)
=
>
{
let
static_category
=
self
.
static_category
(
category
)
;
self
.
counter
.
with_dynamic_label
(
DynamicLabelType
:
:
KeyOnly
(
make_label_from_key_and_category
(
key
static_category
)
)
)
}
(
_
None
)
=
>
{
let
static_key
=
self
.
static_key
(
key
)
;
self
.
counter
.
with_dynamic_label
(
DynamicLabelType
:
:
CategoryOnly
(
make_label_from_key_and_category
(
static_key
category
)
)
)
}
(
_
_
)
=
>
{
let
static_key
=
self
.
static_key
(
key
)
;
let
static_category
=
self
.
static_category
(
category
)
;
let
name
=
combine_base_identifier_and_labels
(
self
.
counter
.
meta
(
)
.
inner
.
name
.
as_str
(
)
static_key
static_category
)
;
self
.
counter
.
with_name
(
name
)
}
}
}
fn
static_key
<
'
a
>
(
&
self
key
:
&
'
a
str
)
-
>
&
'
a
str
{
debug_assert
!
(
self
.
keys
.
is_some
(
)
)
;
let
keys
=
self
.
keys
.
as_ref
(
)
.
unwrap
(
)
;
if
keys
.
iter
(
)
.
any
(
|
l
|
l
=
=
key
)
{
key
}
else
{
OTHER_LABEL
}
}
fn
static_category
<
'
a
>
(
&
self
category
:
&
'
a
str
)
-
>
&
'
a
str
{
debug_assert
!
(
self
.
categories
.
is_some
(
)
)
;
let
categories
=
self
.
categories
.
as_ref
(
)
.
unwrap
(
)
;
if
categories
.
iter
(
)
.
any
(
|
l
|
l
=
=
category
)
{
category
}
else
{
OTHER_LABEL
}
}
pub
fn
get
<
S
:
AsRef
<
str
>
>
(
&
self
key
:
S
category
:
S
)
-
>
Arc
<
CounterMetric
>
{
let
key
=
key
.
as_ref
(
)
;
let
category
=
category
.
as_ref
(
)
;
let
mut
map
=
self
.
dual_label_map
.
lock
(
)
.
unwrap
(
)
;
map
.
entry
(
(
key
.
to_string
(
)
category
.
to_string
(
)
)
)
.
or_insert_with
(
|
|
{
let
metric
=
self
.
new_counter_metric
(
key
category
)
;
Arc
:
:
new
(
metric
)
}
)
.
clone
(
)
}
pub
fn
test_get_num_recorded_errors
(
&
self
error
:
ErrorType
)
-
>
i32
{
crate
:
:
block_on_dispatcher
(
)
;
crate
:
:
core
:
:
with_glean
(
|
glean
|
{
test_get_num_recorded_errors
(
glean
self
.
counter
.
meta
(
)
error
)
.
unwrap_or
(
0
)
}
)
}
}
pub
fn
combine_base_identifier_and_labels
(
base_identifer
:
&
str
key
:
&
str
category
:
&
str
)
-
>
String
{
format
!
(
"
{
}
{
}
"
base_identifer
make_label_from_key_and_category
(
key
category
)
)
}
pub
fn
separate_label_into_key_and_category
(
label
:
&
str
)
-
>
Option
<
(
&
str
&
str
)
>
{
label
.
strip_prefix
(
RECORD_SEPARATOR
)
.
unwrap_or
(
label
)
.
split_once
(
RECORD_SEPARATOR
)
}
pub
fn
make_label_from_key_and_category
(
key
:
&
str
category
:
&
str
)
-
>
String
{
format
!
(
"
{
}
{
}
{
}
{
}
"
RECORD_SEPARATOR
key
RECORD_SEPARATOR
category
)
}
pub
fn
validate_dynamic_key_and_or_category
(
glean
:
&
Glean
meta
:
&
CommonMetricDataInternal
base_identifier
:
&
str
label
:
DynamicLabelType
)
-
>
String
{
if
label
.
split
(
RECORD_SEPARATOR
)
.
count
(
)
!
=
3
{
let
msg
=
"
Label
cannot
contain
the
ASCII
record
separator
character
(
0x1E
)
"
.
to_string
(
)
;
record_error
(
glean
meta
ErrorType
:
:
InvalidLabel
msg
None
)
;
return
combine_base_identifier_and_labels
(
base_identifier
OTHER_LABEL
OTHER_LABEL
)
;
}
if
let
Some
(
(
mut
key
mut
category
)
)
=
separate_label_into_key_and_category
(
&
label
)
{
for
store
in
&
meta
.
inner
.
send_in_pings
{
if
glean
.
storage
(
)
.
has_metric
(
meta
.
inner
.
lifetime
store
key
)
{
return
combine_base_identifier_and_labels
(
base_identifier
key
category
)
;
}
}
let
(
seen_keys
seen_categories
)
=
get_seen_keys_and_categories
(
meta
glean
)
;
match
label
{
DynamicLabelType
:
:
Label
(
ref
label
)
=
>
{
record_error
(
glean
meta
ErrorType
:
:
InvalidLabel
format
!
(
"
Invalid
DualLabeledCounter
label
format
:
{
label
:
?
}
"
)
None
)
;
key
=
OTHER_LABEL
;
category
=
OTHER_LABEL
;
}
DynamicLabelType
:
:
KeyOnly
(
_
)
=
>
{
if
(
!
seen_keys
.
contains
(
key
)
&
&
seen_keys
.
len
(
)
>
=
MAX_LABELS
)
|
|
!
label_is_valid
(
key
glean
meta
)
{
key
=
OTHER_LABEL
;
}
}
DynamicLabelType
:
:
CategoryOnly
(
_
)
=
>
{
if
(
!
seen_categories
.
contains
(
category
)
&
&
seen_categories
.
len
(
)
>
=
MAX_LABELS
)
|
|
!
label_is_valid
(
category
glean
meta
)
{
category
=
OTHER_LABEL
;
}
}
DynamicLabelType
:
:
KeyAndCategory
(
_
)
=
>
{
if
(
!
seen_keys
.
contains
(
key
)
&
&
seen_keys
.
len
(
)
>
=
MAX_LABELS
)
|
|
!
label_is_valid
(
key
glean
meta
)
{
key
=
OTHER_LABEL
;
}
if
(
!
seen_categories
.
contains
(
category
)
&
&
seen_categories
.
len
(
)
>
=
MAX_LABELS
)
|
|
!
label_is_valid
(
category
glean
meta
)
{
category
=
OTHER_LABEL
;
}
}
}
combine_base_identifier_and_labels
(
base_identifier
key
category
)
}
else
{
record_error
(
glean
meta
ErrorType
:
:
InvalidLabel
"
Invalid
DualLabeledCounter
label
format
unable
to
determine
key
and
/
or
category
"
None
)
;
combine_base_identifier_and_labels
(
base_identifier
OTHER_LABEL
OTHER_LABEL
)
}
}
fn
label_is_valid
(
label
:
&
str
glean
:
&
Glean
meta
:
&
CommonMetricDataInternal
)
-
>
bool
{
if
label
.
len
(
)
>
MAX_LABEL_LENGTH
{
let
msg
=
format
!
(
"
label
length
{
}
exceeds
maximum
of
{
}
"
label
.
len
(
)
MAX_LABEL_LENGTH
)
;
record_error
(
glean
meta
ErrorType
:
:
InvalidLabel
msg
None
)
;
false
}
else
{
true
}
}
fn
get_seen_keys_and_categories
(
meta
:
&
CommonMetricDataInternal
glean
:
&
Glean
)
-
>
(
HashSet
<
String
>
HashSet
<
String
>
)
{
let
base_identifier
=
&
meta
.
base_identifier
(
)
;
let
prefix
=
format
!
(
"
{
base_identifier
}
{
RECORD_SEPARATOR
}
"
)
;
let
mut
seen_keys
:
HashSet
<
String
>
=
HashSet
:
:
new
(
)
;
let
mut
seen_categories
:
HashSet
<
String
>
=
HashSet
:
:
new
(
)
;
let
mut
snapshotter
=
|
metric_id
:
&
[
u8
]
_
:
&
Metric
|
{
let
metric_id_str
=
String
:
:
from_utf8_lossy
(
metric_id
)
;
let
parts
:
Vec
<
&
str
>
=
metric_id_str
.
split
(
RECORD_SEPARATOR
)
.
collect
(
)
;
if
parts
.
len
(
)
=
=
2
{
seen_keys
.
insert
(
parts
[
0
]
.
into
(
)
)
;
seen_categories
.
insert
(
parts
[
1
]
.
into
(
)
)
;
}
else
{
record_error
(
glean
meta
ErrorType
:
:
InvalidLabel
"
Dual
Labeled
Counter
label
doesn
'
t
contain
exactly
2
parts
"
.
to_string
(
)
None
)
;
}
}
;
let
lifetime
=
meta
.
inner
.
lifetime
;
for
store
in
&
meta
.
inner
.
send_in_pings
{
glean
.
storage
(
)
.
iter_store_from
(
lifetime
store
Some
(
&
prefix
)
&
mut
snapshotter
)
;
}
(
seen_keys
seen_categories
)
}
