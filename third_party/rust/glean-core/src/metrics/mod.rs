use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
;
use
chrono
:
:
{
DateTime
FixedOffset
}
;
use
malloc_size_of
:
:
MallocSizeOf
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
serde_json
:
:
json
;
pub
use
serde_json
:
:
Value
as
JsonValue
;
mod
boolean
;
mod
counter
;
mod
custom_distribution
;
mod
datetime
;
mod
denominator
;
mod
event
;
mod
experiment
;
pub
(
crate
)
mod
labeled
;
mod
memory_distribution
;
mod
memory_unit
;
mod
numerator
;
mod
object
;
mod
ping
;
mod
quantity
;
mod
rate
;
mod
recorded_experiment
;
mod
remote_settings_config
;
mod
string
;
mod
string_list
;
mod
text
;
mod
time_unit
;
mod
timespan
;
mod
timing_distribution
;
mod
url
;
mod
uuid
;
use
crate
:
:
common_metric_data
:
:
CommonMetricDataInternal
;
pub
use
crate
:
:
event_database
:
:
RecordedEvent
;
use
crate
:
:
histogram
:
:
{
Functional
Histogram
PrecomputedExponential
PrecomputedLinear
}
;
pub
use
crate
:
:
metrics
:
:
datetime
:
:
Datetime
;
use
crate
:
:
util
:
:
get_iso_time_string
;
use
crate
:
:
Glean
;
pub
use
self
:
:
boolean
:
:
BooleanMetric
;
pub
use
self
:
:
counter
:
:
CounterMetric
;
pub
use
self
:
:
custom_distribution
:
:
{
CustomDistributionMetric
LocalCustomDistribution
}
;
pub
use
self
:
:
datetime
:
:
DatetimeMetric
;
pub
use
self
:
:
denominator
:
:
DenominatorMetric
;
pub
use
self
:
:
event
:
:
EventMetric
;
pub
(
crate
)
use
self
:
:
experiment
:
:
ExperimentMetric
;
pub
use
self
:
:
labeled
:
:
{
LabeledBoolean
LabeledCounter
LabeledCustomDistribution
LabeledMemoryDistribution
LabeledMetric
LabeledQuantity
LabeledString
LabeledTimingDistribution
}
;
pub
use
self
:
:
memory_distribution
:
:
{
LocalMemoryDistribution
MemoryDistributionMetric
}
;
pub
use
self
:
:
memory_unit
:
:
MemoryUnit
;
pub
use
self
:
:
numerator
:
:
NumeratorMetric
;
pub
use
self
:
:
object
:
:
ObjectMetric
;
pub
use
self
:
:
ping
:
:
PingType
;
pub
use
self
:
:
quantity
:
:
QuantityMetric
;
pub
use
self
:
:
rate
:
:
{
Rate
RateMetric
}
;
pub
use
self
:
:
string
:
:
StringMetric
;
pub
use
self
:
:
string_list
:
:
StringListMetric
;
pub
use
self
:
:
text
:
:
TextMetric
;
pub
use
self
:
:
time_unit
:
:
TimeUnit
;
pub
use
self
:
:
timespan
:
:
TimespanMetric
;
pub
use
self
:
:
timing_distribution
:
:
LocalTimingDistribution
;
pub
use
self
:
:
timing_distribution
:
:
TimerId
;
pub
use
self
:
:
timing_distribution
:
:
TimingDistributionMetric
;
pub
use
self
:
:
url
:
:
UrlMetric
;
pub
use
self
:
:
uuid
:
:
UuidMetric
;
pub
use
crate
:
:
histogram
:
:
HistogramType
;
pub
use
recorded_experiment
:
:
RecordedExperiment
;
pub
use
self
:
:
remote_settings_config
:
:
RemoteSettingsConfig
;
#
[
derive
(
Debug
Serialize
PartialEq
)
]
pub
struct
DistributionData
{
pub
values
:
HashMap
<
i64
i64
>
pub
sum
:
i64
#
[
serde
(
skip
)
]
pub
count
:
i64
}
#
[
derive
(
Serialize
Deserialize
Clone
Debug
PartialEq
)
]
pub
enum
Metric
{
Boolean
(
bool
)
Counter
(
i32
)
CustomDistributionExponential
(
Histogram
<
PrecomputedExponential
>
)
CustomDistributionLinear
(
Histogram
<
PrecomputedLinear
>
)
Datetime
(
DateTime
<
FixedOffset
>
TimeUnit
)
Experiment
(
recorded_experiment
:
:
RecordedExperiment
)
Quantity
(
i64
)
String
(
String
)
StringList
(
Vec
<
String
>
)
Uuid
(
String
)
Timespan
(
std
:
:
time
:
:
Duration
TimeUnit
)
TimingDistribution
(
Histogram
<
Functional
>
)
MemoryDistribution
(
Histogram
<
Functional
>
)
Jwe
(
String
)
Rate
(
i32
i32
)
Url
(
String
)
Text
(
String
)
Object
(
String
)
}
impl
MallocSizeOf
for
Metric
{
fn
size_of
(
&
self
ops
:
&
mut
malloc_size_of
:
:
MallocSizeOfOps
)
-
>
usize
{
match
self
{
Metric
:
:
Boolean
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Counter
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
CustomDistributionExponential
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
CustomDistributionLinear
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Datetime
(
_a
b
)
=
>
b
.
size_of
(
ops
)
Metric
:
:
Experiment
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Quantity
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Rate
(
a
b
)
=
>
a
.
size_of
(
ops
)
+
b
.
size_of
(
ops
)
Metric
:
:
String
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
StringList
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Timespan
(
a
b
)
=
>
a
.
size_of
(
ops
)
+
b
.
size_of
(
ops
)
Metric
:
:
TimingDistribution
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Url
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Uuid
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
MemoryDistribution
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Jwe
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Text
(
m
)
=
>
m
.
size_of
(
ops
)
Metric
:
:
Object
(
m
)
=
>
m
.
size_of
(
ops
)
}
}
}
pub
trait
MetricType
{
fn
meta
(
&
self
)
-
>
&
CommonMetricDataInternal
;
fn
with_name
(
&
self
_name
:
String
)
-
>
Self
where
Self
:
Sized
{
unimplemented
!
(
)
}
fn
with_dynamic_label
(
&
self
_label
:
String
)
-
>
Self
where
Self
:
Sized
{
unimplemented
!
(
)
}
fn
should_record
(
&
self
glean
:
&
Glean
)
-
>
bool
{
let
disabled_field
=
self
.
meta
(
)
.
disabled
.
load
(
Ordering
:
:
Relaxed
)
;
let
epoch
=
disabled_field
>
>
4
;
let
disabled
=
disabled_field
&
0xF
;
let
remote_settings_epoch
=
glean
.
remote_settings_epoch
.
load
(
Ordering
:
:
Acquire
)
;
if
epoch
=
=
remote_settings_epoch
{
return
disabled
=
=
0
;
}
let
remote_settings_config
=
&
glean
.
remote_settings_config
.
lock
(
)
.
unwrap
(
)
;
let
current_disabled
=
{
let
base_id
=
self
.
meta
(
)
.
base_identifier
(
)
;
let
identifier
=
base_id
.
split_once
(
'
/
'
)
.
map
(
|
split
|
split
.
0
)
.
unwrap_or
(
&
base_id
)
;
if
!
remote_settings_config
.
metrics_enabled
.
is_empty
(
)
{
if
let
Some
(
is_enabled
)
=
remote_settings_config
.
metrics_enabled
.
get
(
identifier
)
{
u8
:
:
from
(
!
*
is_enabled
)
}
else
{
u8
:
:
from
(
self
.
meta
(
)
.
inner
.
disabled
)
}
}
else
{
u8
:
:
from
(
self
.
meta
(
)
.
inner
.
disabled
)
}
}
;
let
new_disabled
=
(
remote_settings_epoch
<
<
4
)
|
(
current_disabled
&
0xF
)
;
self
.
meta
(
)
.
disabled
.
store
(
new_disabled
Ordering
:
:
Relaxed
)
;
current_disabled
=
=
0
}
}
pub
trait
MetricIdentifier
<
'
a
>
{
fn
get_identifiers
(
&
'
a
self
)
-
>
(
&
'
a
str
&
'
a
str
Option
<
&
'
a
str
>
)
;
}
impl
<
'
a
T
>
MetricIdentifier
<
'
a
>
for
T
where
T
:
MetricType
{
fn
get_identifiers
(
&
'
a
self
)
-
>
(
&
'
a
str
&
'
a
str
Option
<
&
'
a
str
>
)
{
let
meta
=
&
self
.
meta
(
)
.
inner
;
(
&
meta
.
category
&
meta
.
name
meta
.
dynamic_label
.
as_deref
(
)
)
}
}
impl
Metric
{
pub
fn
ping_section
(
&
self
)
-
>
&
'
static
str
{
match
self
{
Metric
:
:
Boolean
(
_
)
=
>
"
boolean
"
Metric
:
:
Counter
(
_
)
=
>
"
counter
"
Metric
:
:
CustomDistributionExponential
(
_
)
=
>
"
custom_distribution
"
Metric
:
:
CustomDistributionLinear
(
_
)
=
>
"
custom_distribution
"
Metric
:
:
Datetime
(
_
_
)
=
>
"
datetime
"
Metric
:
:
Experiment
(
_
)
=
>
panic
!
(
"
Experiments
should
not
be
serialized
through
this
"
)
Metric
:
:
Quantity
(
_
)
=
>
"
quantity
"
Metric
:
:
Rate
(
.
.
)
=
>
"
rate
"
Metric
:
:
String
(
_
)
=
>
"
string
"
Metric
:
:
StringList
(
_
)
=
>
"
string_list
"
Metric
:
:
Timespan
(
.
.
)
=
>
"
timespan
"
Metric
:
:
TimingDistribution
(
_
)
=
>
"
timing_distribution
"
Metric
:
:
Url
(
_
)
=
>
"
url
"
Metric
:
:
Uuid
(
_
)
=
>
"
uuid
"
Metric
:
:
MemoryDistribution
(
_
)
=
>
"
memory_distribution
"
Metric
:
:
Jwe
(
_
)
=
>
"
jwe
"
Metric
:
:
Text
(
_
)
=
>
"
text
"
Metric
:
:
Object
(
_
)
=
>
"
object
"
}
}
pub
fn
as_json
(
&
self
)
-
>
JsonValue
{
match
self
{
Metric
:
:
Boolean
(
b
)
=
>
json
!
(
b
)
Metric
:
:
Counter
(
c
)
=
>
json
!
(
c
)
Metric
:
:
CustomDistributionExponential
(
hist
)
=
>
{
json
!
(
custom_distribution
:
:
snapshot
(
hist
)
)
}
Metric
:
:
CustomDistributionLinear
(
hist
)
=
>
json
!
(
custom_distribution
:
:
snapshot
(
hist
)
)
Metric
:
:
Datetime
(
d
time_unit
)
=
>
json
!
(
get_iso_time_string
(
*
d
*
time_unit
)
)
Metric
:
:
Experiment
(
e
)
=
>
e
.
as_json
(
)
Metric
:
:
Quantity
(
q
)
=
>
json
!
(
q
)
Metric
:
:
Rate
(
num
den
)
=
>
{
json
!
(
{
"
numerator
"
:
num
"
denominator
"
:
den
}
)
}
Metric
:
:
String
(
s
)
=
>
json
!
(
s
)
Metric
:
:
StringList
(
v
)
=
>
json
!
(
v
)
Metric
:
:
Timespan
(
time
time_unit
)
=
>
{
json
!
(
{
"
value
"
:
time_unit
.
duration_convert
(
*
time
)
"
time_unit
"
:
time_unit
}
)
}
Metric
:
:
TimingDistribution
(
hist
)
=
>
json
!
(
timing_distribution
:
:
snapshot
(
hist
)
)
Metric
:
:
Url
(
s
)
=
>
json
!
(
s
)
Metric
:
:
Uuid
(
s
)
=
>
json
!
(
s
)
Metric
:
:
MemoryDistribution
(
hist
)
=
>
json
!
(
memory_distribution
:
:
snapshot
(
hist
)
)
Metric
:
:
Jwe
(
s
)
=
>
json
!
(
s
)
Metric
:
:
Text
(
s
)
=
>
json
!
(
s
)
Metric
:
:
Object
(
s
)
=
>
{
serde_json
:
:
from_str
(
s
)
.
expect
(
"
object
storage
should
have
been
json
"
)
}
}
}
}
macro_rules
!
impl_malloc_size_of_for_metric
{
(
ty
:
ident
)
=
>
{
impl
:
:
malloc_size_of
:
:
MallocSizeOf
for
ty
{
fn
size_of
(
&
self
ops
:
&
mut
malloc_size_of
:
:
MallocSizeOfOps
)
-
>
usize
{
/
/
Note
:
meta
is
likely
s
behind
an
Arc
.
/
/
size_of
should
only
be
called
from
a
single
thread
to
avoid
double
-
counting
.
self
.
meta
(
)
.
size_of
(
ops
)
}
}
}
;
}
impl_malloc_size_of_for_metric
!
(
BooleanMetric
)
;
impl_malloc_size_of_for_metric
!
(
CounterMetric
)
;
impl_malloc_size_of_for_metric
!
(
CustomDistributionMetric
)
;
impl_malloc_size_of_for_metric
!
(
DatetimeMetric
)
;
impl_malloc_size_of_for_metric
!
(
DenominatorMetric
)
;
impl_malloc_size_of_for_metric
!
(
EventMetric
)
;
impl_malloc_size_of_for_metric
!
(
ExperimentMetric
)
;
impl_malloc_size_of_for_metric
!
(
MemoryDistributionMetric
)
;
impl_malloc_size_of_for_metric
!
(
NumeratorMetric
)
;
impl_malloc_size_of_for_metric
!
(
ObjectMetric
)
;
impl_malloc_size_of_for_metric
!
(
QuantityMetric
)
;
impl_malloc_size_of_for_metric
!
(
RateMetric
)
;
impl_malloc_size_of_for_metric
!
(
StringMetric
)
;
impl_malloc_size_of_for_metric
!
(
StringListMetric
)
;
impl_malloc_size_of_for_metric
!
(
TextMetric
)
;
impl_malloc_size_of_for_metric
!
(
TimespanMetric
)
;
impl_malloc_size_of_for_metric
!
(
UrlMetric
)
;
impl_malloc_size_of_for_metric
!
(
UuidMetric
)
;
