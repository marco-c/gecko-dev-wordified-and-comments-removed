use
std
:
:
cmp
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicU8
;
use
crate
:
:
common_metric_data
:
:
CommonMetricDataInternal
;
use
crate
:
:
error_recording
:
:
{
record_error
ErrorType
}
;
use
crate
:
:
metrics
:
:
{
Metric
MetricType
RecordedExperiment
}
;
use
crate
:
:
storage
:
:
{
StorageManager
INTERNAL_STORAGE
}
;
use
crate
:
:
util
:
:
{
truncate_string_at_boundary
truncate_string_at_boundary_with_error
}
;
use
crate
:
:
Lifetime
;
use
crate
:
:
{
CommonMetricData
Glean
}
;
const
MAX_EXPERIMENTS_IDS_LEN
:
usize
=
100
;
const
MAX_EXPERIMENT_VALUE_LEN
:
usize
=
MAX_EXPERIMENTS_IDS_LEN
;
const
MAX_EXPERIMENTS_EXTRAS_SIZE
:
usize
=
20
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
ExperimentMetric
{
meta
:
CommonMetricDataInternal
}
impl
MetricType
for
ExperimentMetric
{
fn
meta
(
&
self
)
-
>
&
CommonMetricDataInternal
{
&
self
.
meta
}
}
impl
ExperimentMetric
{
pub
fn
new
(
glean
:
&
Glean
id
:
String
)
-
>
Self
{
let
mut
error
=
None
;
let
truncated_id
=
if
id
.
len
(
)
>
MAX_EXPERIMENTS_IDS_LEN
{
let
msg
=
format
!
(
"
Value
length
{
}
for
experiment
id
exceeds
maximum
of
{
}
"
id
.
len
(
)
MAX_EXPERIMENTS_IDS_LEN
)
;
error
=
Some
(
msg
)
;
truncate_string_at_boundary
(
id
MAX_EXPERIMENTS_IDS_LEN
)
}
else
{
id
}
;
let
new_experiment
=
Self
{
meta
:
CommonMetricDataInternal
{
inner
:
CommonMetricData
{
name
:
format
!
(
"
{
}
#
experiment
"
truncated_id
)
category
:
"
"
.
into
(
)
send_in_pings
:
vec
!
[
INTERNAL_STORAGE
.
into
(
)
]
lifetime
:
Lifetime
:
:
Application
.
.
Default
:
:
default
(
)
}
disabled
:
AtomicU8
:
:
new
(
0
)
}
}
;
if
let
Some
(
msg
)
=
error
{
record_error
(
glean
&
new_experiment
.
meta
ErrorType
:
:
InvalidValue
msg
None
)
;
}
new_experiment
}
pub
fn
set_active_sync
(
&
self
glean
:
&
Glean
branch
:
String
extra
:
HashMap
<
String
String
>
)
{
if
!
self
.
should_record
(
glean
)
{
return
;
}
let
truncated_branch
=
if
branch
.
len
(
)
>
MAX_EXPERIMENTS_IDS_LEN
{
truncate_string_at_boundary_with_error
(
glean
&
self
.
meta
branch
MAX_EXPERIMENTS_IDS_LEN
)
}
else
{
branch
}
;
if
extra
.
len
(
)
>
MAX_EXPERIMENTS_EXTRAS_SIZE
{
let
msg
=
format
!
(
"
Extra
hash
map
length
{
}
exceeds
maximum
of
{
}
"
extra
.
len
(
)
MAX_EXPERIMENTS_EXTRAS_SIZE
)
;
record_error
(
glean
&
self
.
meta
ErrorType
:
:
InvalidValue
msg
None
)
;
}
let
mut
truncated_extras
=
HashMap
:
:
with_capacity
(
cmp
:
:
min
(
extra
.
len
(
)
MAX_EXPERIMENTS_EXTRAS_SIZE
)
)
;
for
(
key
value
)
in
extra
.
into_iter
(
)
.
take
(
MAX_EXPERIMENTS_EXTRAS_SIZE
)
{
let
truncated_key
=
if
key
.
len
(
)
>
MAX_EXPERIMENTS_IDS_LEN
{
truncate_string_at_boundary_with_error
(
glean
&
self
.
meta
key
MAX_EXPERIMENTS_IDS_LEN
)
}
else
{
key
}
;
let
truncated_value
=
if
value
.
len
(
)
>
MAX_EXPERIMENT_VALUE_LEN
{
truncate_string_at_boundary_with_error
(
glean
&
self
.
meta
value
MAX_EXPERIMENT_VALUE_LEN
)
}
else
{
value
}
;
truncated_extras
.
insert
(
truncated_key
truncated_value
)
;
}
let
truncated_extras
=
if
truncated_extras
.
is_empty
(
)
{
None
}
else
{
Some
(
truncated_extras
)
}
;
let
value
=
Metric
:
:
Experiment
(
RecordedExperiment
{
branch
:
truncated_branch
extra
:
truncated_extras
}
)
;
glean
.
storage
(
)
.
record
(
glean
&
self
.
meta
&
value
)
}
pub
fn
set_inactive_sync
(
&
self
glean
:
&
Glean
)
{
if
!
self
.
should_record
(
glean
)
{
return
;
}
if
let
Err
(
e
)
=
glean
.
storage
(
)
.
remove_single_metric
(
Lifetime
:
:
Application
INTERNAL_STORAGE
&
self
.
meta
.
inner
.
name
)
{
log
:
:
error
!
(
"
Failed
to
set
experiment
as
inactive
:
{
:
?
}
"
e
)
;
}
}
pub
fn
test_get_value
(
&
self
glean
:
&
Glean
)
-
>
Option
<
RecordedExperiment
>
{
match
StorageManager
.
snapshot_metric_for_test
(
glean
.
storage
(
)
INTERNAL_STORAGE
&
self
.
meta
.
identifier
(
glean
)
self
.
meta
.
inner
.
lifetime
)
{
Some
(
Metric
:
:
Experiment
(
e
)
)
=
>
Some
(
e
)
_
=
>
None
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
stable_serialization
(
)
{
let
experiment_empty
=
RecordedExperiment
{
branch
:
"
branch
"
.
into
(
)
extra
:
Default
:
:
default
(
)
}
;
let
mut
data
=
HashMap
:
:
new
(
)
;
data
.
insert
(
"
a
key
"
.
to_string
(
)
"
a
value
"
.
to_string
(
)
)
;
let
experiment_data
=
RecordedExperiment
{
branch
:
"
branch
"
.
into
(
)
extra
:
Some
(
data
)
}
;
let
experiment_empty_bin
=
bincode
:
:
serialize
(
&
experiment_empty
)
.
unwrap
(
)
;
let
experiment_data_bin
=
bincode
:
:
serialize
(
&
experiment_data
)
.
unwrap
(
)
;
assert_eq
!
(
experiment_empty
bincode
:
:
deserialize
(
&
experiment_empty_bin
)
.
unwrap
(
)
)
;
assert_eq
!
(
experiment_data
bincode
:
:
deserialize
(
&
experiment_data_bin
)
.
unwrap
(
)
)
;
}
#
[
test
]
#
[
rustfmt
:
:
skip
]
fn
deserialize_old_encoding
(
)
{
let
empty_bin
=
vec
!
[
6
0
0
0
0
0
0
0
98
114
97
110
99
104
]
;
let
data_bin
=
vec
!
[
6
0
0
0
0
0
0
0
98
114
97
110
99
104
1
1
0
0
0
0
0
0
0
5
0
0
0
0
0
0
0
97
32
107
101
121
7
0
0
0
0
0
0
0
97
32
118
97
108
117
101
]
;
let
mut
data
=
HashMap
:
:
new
(
)
;
data
.
insert
(
"
a
key
"
.
to_string
(
)
"
a
value
"
.
to_string
(
)
)
;
let
experiment_data
=
RecordedExperiment
{
branch
:
"
branch
"
.
into
(
)
extra
:
Some
(
data
)
}
;
let
experiment_empty
:
Result
<
RecordedExperiment
_
>
=
bincode
:
:
deserialize
(
&
empty_bin
)
;
assert
!
(
experiment_empty
.
is_err
(
)
)
;
assert_eq
!
(
experiment_data
bincode
:
:
deserialize
(
&
data_bin
)
.
unwrap
(
)
)
;
}
}
