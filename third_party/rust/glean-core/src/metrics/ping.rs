use
std
:
:
fmt
;
use
std
:
:
sync
:
:
Arc
;
use
crate
:
:
ping
:
:
PingMaker
;
use
crate
:
:
Glean
;
use
uuid
:
:
Uuid
;
#
[
derive
(
Clone
)
]
pub
struct
PingType
(
Arc
<
InnerPing
>
)
;
struct
InnerPing
{
pub
name
:
String
pub
include_client_id
:
bool
pub
send_if_empty
:
bool
pub
precise_timestamps
:
bool
pub
reason_codes
:
Vec
<
String
>
}
impl
fmt
:
:
Debug
for
PingType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
PingType
"
)
.
field
(
"
name
"
&
self
.
0
.
name
)
.
field
(
"
include_client_id
"
&
self
.
0
.
include_client_id
)
.
field
(
"
send_if_empty
"
&
self
.
0
.
send_if_empty
)
.
field
(
"
precise_timestamps
"
&
self
.
0
.
precise_timestamps
)
.
field
(
"
reason_codes
"
&
self
.
0
.
reason_codes
)
.
finish
(
)
}
}
impl
PingType
{
pub
fn
new
<
A
:
Into
<
String
>
>
(
name
:
A
include_client_id
:
bool
send_if_empty
:
bool
precise_timestamps
:
bool
reason_codes
:
Vec
<
String
>
)
-
>
Self
{
let
this
=
Self
(
Arc
:
:
new
(
InnerPing
{
name
:
name
.
into
(
)
include_client_id
send_if_empty
precise_timestamps
reason_codes
}
)
)
;
crate
:
:
register_ping_type
(
&
this
)
;
this
}
pub
(
crate
)
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
0
.
name
}
pub
(
crate
)
fn
include_client_id
(
&
self
)
-
>
bool
{
self
.
0
.
include_client_id
}
pub
(
crate
)
fn
send_if_empty
(
&
self
)
-
>
bool
{
self
.
0
.
send_if_empty
}
pub
(
crate
)
fn
precise_timestamps
(
&
self
)
-
>
bool
{
self
.
0
.
precise_timestamps
}
pub
fn
submit
(
&
self
reason
:
Option
<
String
>
)
{
let
ping
=
PingType
(
Arc
:
:
clone
(
&
self
.
0
)
)
;
crate
:
:
dispatcher
:
:
launch
(
|
|
{
let
sent
=
crate
:
:
core
:
:
with_glean
(
move
|
glean
|
ping
.
submit_sync
(
glean
reason
.
as_deref
(
)
)
)
;
if
sent
{
let
state
=
crate
:
:
global_state
(
)
.
lock
(
)
.
unwrap
(
)
;
if
let
Err
(
e
)
=
state
.
callbacks
.
trigger_upload
(
)
{
log
:
:
error
!
(
"
Triggering
upload
failed
.
Error
:
{
}
"
e
)
;
}
}
}
)
}
#
[
doc
(
hidden
)
]
pub
fn
submit_sync
(
&
self
glean
:
&
Glean
reason
:
Option
<
&
str
>
)
-
>
bool
{
if
!
glean
.
is_upload_enabled
(
)
{
log
:
:
info
!
(
"
Glean
disabled
:
not
submitting
any
pings
.
"
)
;
return
false
;
}
let
ping
=
&
self
.
0
;
#
[
allow
(
unknown_lints
)
]
#
[
allow
(
clippy
:
:
manual_filter
)
]
let
corrected_reason
=
match
reason
{
Some
(
reason
)
=
>
{
if
ping
.
reason_codes
.
contains
(
&
reason
.
to_string
(
)
)
{
Some
(
reason
)
}
else
{
log
:
:
error
!
(
"
Invalid
reason
code
{
}
for
ping
{
}
"
reason
ping
.
name
)
;
None
}
}
None
=
>
None
}
;
let
ping_maker
=
PingMaker
:
:
new
(
)
;
let
doc_id
=
Uuid
:
:
new_v4
(
)
.
to_string
(
)
;
let
url_path
=
glean
.
make_path
(
&
ping
.
name
&
doc_id
)
;
match
ping_maker
.
collect
(
glean
self
corrected_reason
&
doc_id
&
url_path
)
{
None
=
>
{
log
:
:
info
!
(
"
No
content
for
ping
'
{
}
'
therefore
no
ping
queued
.
"
ping
.
name
)
;
false
}
Some
(
ping
)
=
>
{
glean
.
additional_metrics
.
pings_submitted
.
get
(
ping
.
name
)
.
add_sync
(
glean
1
)
;
if
let
Err
(
e
)
=
ping_maker
.
store_ping
(
glean
.
get_data_path
(
)
&
ping
)
{
log
:
:
warn
!
(
"
IO
error
while
writing
ping
to
file
:
{
}
.
Enqueuing
upload
of
what
we
have
in
memory
.
"
e
)
;
glean
.
additional_metrics
.
io_errors
.
add_sync
(
glean
1
)
;
let
content
=
:
:
serde_json
:
:
to_string
(
&
ping
.
content
)
.
expect
(
"
ping
serialization
failed
"
)
;
glean
.
upload_manager
.
enqueue_ping
(
glean
ping
.
doc_id
ping
.
url_path
&
content
Some
(
ping
.
headers
)
)
;
return
true
;
}
glean
.
upload_manager
.
enqueue_ping_from_file
(
glean
&
doc_id
)
;
log
:
:
info
!
(
"
The
ping
'
{
}
'
was
submitted
and
will
be
sent
as
soon
as
possible
"
ping
.
name
)
;
true
}
}
}
}
