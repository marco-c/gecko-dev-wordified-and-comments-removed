use
std
:
:
fmt
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
Arc
;
use
crate
:
:
ping
:
:
PingMaker
;
use
crate
:
:
upload
:
:
PingPayload
;
use
crate
:
:
Glean
;
use
uuid
:
:
Uuid
;
#
[
derive
(
Clone
)
]
pub
struct
PingType
(
Arc
<
InnerPing
>
)
;
struct
InnerPing
{
pub
name
:
String
pub
include_client_id
:
bool
pub
send_if_empty
:
bool
pub
precise_timestamps
:
bool
pub
include_info_sections
:
bool
pub
enabled
:
AtomicBool
pub
schedules_pings
:
Vec
<
String
>
pub
reason_codes
:
Vec
<
String
>
follows_collection_enabled
:
AtomicBool
}
impl
fmt
:
:
Debug
for
PingType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
PingType
"
)
.
field
(
"
name
"
&
self
.
0
.
name
)
.
field
(
"
include_client_id
"
&
self
.
0
.
include_client_id
)
.
field
(
"
send_if_empty
"
&
self
.
0
.
send_if_empty
)
.
field
(
"
precise_timestamps
"
&
self
.
0
.
precise_timestamps
)
.
field
(
"
include_info_sections
"
&
self
.
0
.
include_info_sections
)
.
field
(
"
enabled
"
&
self
.
0
.
enabled
.
load
(
Ordering
:
:
Relaxed
)
)
.
field
(
"
schedules_pings
"
&
self
.
0
.
schedules_pings
)
.
field
(
"
reason_codes
"
&
self
.
0
.
reason_codes
)
.
field
(
"
follows_collection_enabled
"
&
self
.
0
.
follows_collection_enabled
.
load
(
Ordering
:
:
Relaxed
)
)
.
finish
(
)
}
}
impl
PingType
{
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
pub
fn
new
<
A
:
Into
<
String
>
>
(
name
:
A
include_client_id
:
bool
send_if_empty
:
bool
precise_timestamps
:
bool
include_info_sections
:
bool
enabled
:
bool
schedules_pings
:
Vec
<
String
>
reason_codes
:
Vec
<
String
>
follows_collection_enabled
:
bool
)
-
>
Self
{
Self
:
:
new_internal
(
name
include_client_id
send_if_empty
precise_timestamps
include_info_sections
enabled
schedules_pings
reason_codes
follows_collection_enabled
)
}
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
pub
(
crate
)
fn
new_internal
<
A
:
Into
<
String
>
>
(
name
:
A
include_client_id
:
bool
send_if_empty
:
bool
precise_timestamps
:
bool
include_info_sections
:
bool
enabled
:
bool
schedules_pings
:
Vec
<
String
>
reason_codes
:
Vec
<
String
>
follows_collection_enabled
:
bool
)
-
>
Self
{
let
this
=
Self
(
Arc
:
:
new
(
InnerPing
{
name
:
name
.
into
(
)
include_client_id
send_if_empty
precise_timestamps
include_info_sections
enabled
:
AtomicBool
:
:
new
(
enabled
)
schedules_pings
reason_codes
follows_collection_enabled
:
AtomicBool
:
:
new
(
follows_collection_enabled
)
}
)
)
;
crate
:
:
register_ping_type
(
&
this
)
;
this
}
pub
(
crate
)
fn
name
(
&
self
)
-
>
&
str
{
&
self
.
0
.
name
}
pub
(
crate
)
fn
include_client_id
(
&
self
)
-
>
bool
{
self
.
0
.
include_client_id
}
pub
(
crate
)
fn
send_if_empty
(
&
self
)
-
>
bool
{
self
.
0
.
send_if_empty
}
pub
(
crate
)
fn
precise_timestamps
(
&
self
)
-
>
bool
{
self
.
0
.
precise_timestamps
}
pub
(
crate
)
fn
include_info_sections
(
&
self
)
-
>
bool
{
self
.
0
.
include_info_sections
}
pub
fn
set_enabled
(
&
self
enabled
:
bool
)
{
crate
:
:
set_ping_enabled
(
self
enabled
)
}
pub
(
crate
)
fn
store_enabled
(
&
self
enabled
:
bool
)
{
self
.
0
.
enabled
.
store
(
enabled
Ordering
:
:
Release
)
;
}
pub
(
crate
)
fn
enabled
(
&
self
glean
:
&
Glean
)
-
>
bool
{
if
self
.
0
.
follows_collection_enabled
.
load
(
Ordering
:
:
Relaxed
)
{
if
!
glean
.
is_upload_enabled
(
)
{
return
false
;
}
let
remote_settings_config
=
&
glean
.
remote_settings_config
.
lock
(
)
.
unwrap
(
)
;
if
!
remote_settings_config
.
pings_enabled
.
is_empty
(
)
{
if
let
Some
(
remote_enabled
)
=
remote_settings_config
.
pings_enabled
.
get
(
self
.
name
(
)
)
{
return
*
remote_enabled
;
}
}
}
self
.
0
.
enabled
.
load
(
Ordering
:
:
Relaxed
)
}
pub
(
crate
)
fn
follows_collection_enabled
(
&
self
)
-
>
bool
{
self
.
0
.
follows_collection_enabled
.
load
(
Ordering
:
:
Relaxed
)
}
pub
(
crate
)
fn
schedules_pings
(
&
self
)
-
>
&
[
String
]
{
&
self
.
0
.
schedules_pings
}
pub
fn
submit
(
&
self
reason
:
Option
<
String
>
)
{
let
ping
=
PingType
(
Arc
:
:
clone
(
&
self
.
0
)
)
;
crate
:
:
dispatcher
:
:
launch
(
|
|
{
let
sent
=
crate
:
:
core
:
:
with_glean
(
move
|
glean
|
ping
.
submit_sync
(
glean
reason
.
as_deref
(
)
)
)
;
if
sent
{
let
state
=
crate
:
:
global_state
(
)
.
lock
(
)
.
unwrap
(
)
;
if
let
Err
(
e
)
=
state
.
callbacks
.
trigger_upload
(
)
{
log
:
:
error
!
(
"
Triggering
upload
failed
.
Error
:
{
}
"
e
)
;
}
}
}
)
}
#
[
doc
(
hidden
)
]
pub
fn
submit_sync
(
&
self
glean
:
&
Glean
reason
:
Option
<
&
str
>
)
-
>
bool
{
if
!
self
.
enabled
(
glean
)
{
log
:
:
info
!
(
"
The
ping
'
{
}
'
is
disabled
and
will
be
discarded
and
not
submitted
"
self
.
0
.
name
)
;
return
false
;
}
let
ping
=
&
self
.
0
;
#
[
allow
(
unknown_lints
)
]
#
[
allow
(
clippy
:
:
manual_filter
)
]
let
corrected_reason
=
match
reason
{
Some
(
reason
)
=
>
{
if
ping
.
reason_codes
.
contains
(
&
reason
.
to_string
(
)
)
{
Some
(
reason
)
}
else
{
log
:
:
error
!
(
"
Invalid
reason
code
{
}
for
ping
{
}
"
reason
ping
.
name
)
;
None
}
}
None
=
>
None
}
;
let
ping_maker
=
PingMaker
:
:
new
(
)
;
let
doc_id
=
Uuid
:
:
new_v4
(
)
.
to_string
(
)
;
let
url_path
=
glean
.
make_path
(
&
ping
.
name
&
doc_id
)
;
match
ping_maker
.
collect
(
glean
self
corrected_reason
&
doc_id
&
url_path
)
{
None
=
>
{
log
:
:
info
!
(
"
No
content
for
ping
'
{
}
'
therefore
no
ping
queued
.
"
ping
.
name
)
;
false
}
Some
(
ping
)
=
>
{
if
!
self
.
enabled
(
glean
)
{
log
:
:
info
!
(
"
The
ping
'
{
}
'
is
disabled
and
will
be
discarded
and
not
submitted
"
ping
.
name
)
;
return
false
;
}
glean
.
additional_metrics
.
pings_submitted
.
get
(
ping
.
name
)
.
add_sync
(
glean
1
)
;
if
let
Err
(
e
)
=
ping_maker
.
store_ping
(
glean
.
get_data_path
(
)
&
ping
)
{
log
:
:
warn
!
(
"
IO
error
while
writing
ping
to
file
:
{
}
.
Enqueuing
upload
of
what
we
have
in
memory
.
"
e
)
;
glean
.
additional_metrics
.
io_errors
.
add_sync
(
glean
1
)
;
let
content
=
:
:
serde_json
:
:
to_string
(
&
ping
.
content
)
.
expect
(
"
ping
serialization
failed
"
)
;
let
ping
=
PingPayload
{
document_id
:
ping
.
doc_id
.
to_string
(
)
upload_path
:
ping
.
url_path
.
to_string
(
)
json_body
:
content
headers
:
Some
(
ping
.
headers
)
body_has_info_sections
:
self
.
0
.
include_info_sections
ping_name
:
self
.
0
.
name
.
to_string
(
)
}
;
glean
.
upload_manager
.
enqueue_ping
(
glean
ping
)
;
return
true
;
}
glean
.
upload_manager
.
enqueue_ping_from_file
(
glean
&
doc_id
)
;
log
:
:
info
!
(
"
The
ping
'
{
}
'
was
submitted
and
will
be
sent
as
soon
as
possible
"
ping
.
name
)
;
if
ping
.
schedules_pings
.
is_empty
(
)
{
let
ping_schedule
=
glean
.
ping_schedule
.
get
(
ping
.
name
)
.
map
(
|
v
|
&
v
[
.
.
]
)
.
unwrap_or
(
&
[
]
)
;
if
!
ping_schedule
.
is_empty
(
)
{
log
:
:
info
!
(
"
The
ping
'
{
}
'
is
being
used
to
schedule
other
pings
:
{
:
?
}
"
ping
.
name
ping_schedule
)
;
for
scheduled_ping_name
in
ping_schedule
{
glean
.
submit_ping_by_name
(
scheduled_ping_name
reason
)
;
}
}
}
else
{
log
:
:
info
!
(
"
The
ping
'
{
}
'
is
being
used
to
schedule
other
pings
:
{
:
?
}
"
ping
.
name
ping
.
schedules_pings
)
;
for
scheduled_ping_name
in
&
ping
.
schedules_pings
{
glean
.
submit_ping_by_name
(
scheduled_ping_name
reason
)
;
}
}
true
}
}
}
}
