#
!
[
allow
(
non_upper_case_globals
)
]
use
std
:
:
collections
:
:
HashMap
;
use
serde_json
:
:
{
json
Value
as
JsonValue
}
;
use
crate
:
:
coverage
:
:
record_coverage
;
use
crate
:
:
database
:
:
Database
;
use
crate
:
:
metrics
:
:
Metric
;
use
crate
:
:
Lifetime
;
pub
struct
StorageManager
;
fn
snapshot_labeled_metrics
(
snapshot
:
&
mut
HashMap
<
String
HashMap
<
String
JsonValue
>
>
metric_id
:
&
str
metric
:
&
Metric
)
{
let
ping_section
=
format
!
(
"
labeled_
{
}
"
metric
.
ping_section
(
)
)
;
let
map
=
snapshot
.
entry
(
ping_section
)
.
or_insert_with
(
HashMap
:
:
new
)
;
let
mut
s
=
metric_id
.
splitn
(
2
'
/
'
)
;
let
metric_id
=
s
.
next
(
)
.
unwrap
(
)
;
let
label
=
s
.
next
(
)
.
unwrap
(
)
;
let
obj
=
map
.
entry
(
metric_id
.
into
(
)
)
.
or_insert_with
(
|
|
json
!
(
{
}
)
)
;
let
obj
=
obj
.
as_object_mut
(
)
.
unwrap
(
)
;
obj
.
insert
(
label
.
into
(
)
metric
.
as_json
(
)
)
;
}
impl
StorageManager
{
pub
fn
snapshot
(
&
self
storage
:
&
Database
store_name
:
&
str
clear_store
:
bool
)
-
>
Option
<
String
>
{
self
.
snapshot_as_json
(
storage
store_name
clear_store
)
.
map
(
|
data
|
:
:
serde_json
:
:
to_string_pretty
(
&
data
)
.
unwrap
(
)
)
}
pub
fn
snapshot_as_json
(
&
self
storage
:
&
Database
store_name
:
&
str
clear_store
:
bool
)
-
>
Option
<
JsonValue
>
{
let
mut
snapshot
:
HashMap
<
String
HashMap
<
String
JsonValue
>
>
=
HashMap
:
:
new
(
)
;
let
mut
snapshotter
=
|
metric_id
:
&
[
u8
]
metric
:
&
Metric
|
{
let
metric_id
=
String
:
:
from_utf8_lossy
(
metric_id
)
.
into_owned
(
)
;
if
metric_id
.
contains
(
'
/
'
)
{
snapshot_labeled_metrics
(
&
mut
snapshot
&
metric_id
&
metric
)
;
}
else
{
let
map
=
snapshot
.
entry
(
metric
.
ping_section
(
)
.
into
(
)
)
.
or_insert_with
(
HashMap
:
:
new
)
;
map
.
insert
(
metric_id
metric
.
as_json
(
)
)
;
}
}
;
storage
.
iter_store_from
(
Lifetime
:
:
Ping
&
store_name
None
&
mut
snapshotter
)
;
storage
.
iter_store_from
(
Lifetime
:
:
Application
&
store_name
None
&
mut
snapshotter
)
;
storage
.
iter_store_from
(
Lifetime
:
:
User
&
store_name
None
&
mut
snapshotter
)
;
if
clear_store
{
if
let
Err
(
e
)
=
storage
.
clear_ping_lifetime_storage
(
store_name
)
{
log
:
:
warn
!
(
"
Failed
to
clear
lifetime
storage
:
{
:
?
}
"
e
)
;
}
}
if
snapshot
.
is_empty
(
)
{
None
}
else
{
Some
(
json
!
(
snapshot
)
)
}
}
pub
fn
snapshot_metric
(
&
self
storage
:
&
Database
store_name
:
&
str
metric_id
:
&
str
metric_lifetime
:
Lifetime
)
-
>
Option
<
Metric
>
{
let
mut
snapshot
:
Option
<
Metric
>
=
None
;
let
mut
snapshotter
=
|
id
:
&
[
u8
]
metric
:
&
Metric
|
{
let
id
=
String
:
:
from_utf8_lossy
(
id
)
.
into_owned
(
)
;
if
id
=
=
metric_id
{
snapshot
=
Some
(
metric
.
clone
(
)
)
}
}
;
storage
.
iter_store_from
(
metric_lifetime
&
store_name
None
&
mut
snapshotter
)
;
snapshot
}
pub
fn
snapshot_metric_for_test
(
&
self
storage
:
&
Database
store_name
:
&
str
metric_id
:
&
str
metric_lifetime
:
Lifetime
)
-
>
Option
<
Metric
>
{
record_coverage
(
metric_id
)
;
self
.
snapshot_metric
(
storage
store_name
metric_id
metric_lifetime
)
}
pub
fn
snapshot_experiments_as_json
(
&
self
storage
:
&
Database
store_name
:
&
str
)
-
>
Option
<
JsonValue
>
{
let
mut
snapshot
:
HashMap
<
String
JsonValue
>
=
HashMap
:
:
new
(
)
;
let
mut
snapshotter
=
|
metric_id
:
&
[
u8
]
metric
:
&
Metric
|
{
let
metric_id
=
String
:
:
from_utf8_lossy
(
metric_id
)
.
into_owned
(
)
;
if
metric_id
.
ends_with
(
"
#
experiment
"
)
{
let
name
=
metric_id
.
splitn
(
2
'
#
'
)
.
next
(
)
.
unwrap
(
)
;
snapshot
.
insert
(
name
.
to_string
(
)
metric
.
as_json
(
)
)
;
}
}
;
storage
.
iter_store_from
(
Lifetime
:
:
Application
store_name
None
&
mut
snapshotter
)
;
if
snapshot
.
is_empty
(
)
{
None
}
else
{
Some
(
json
!
(
snapshot
)
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
metrics
:
:
ExperimentMetric
;
use
crate
:
:
Glean
;
#
[
test
]
fn
test_experiments_json_serialization
(
)
{
let
t
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
name
=
t
.
path
(
)
.
display
(
)
.
to_string
(
)
;
let
glean
=
Glean
:
:
with_options
(
&
name
"
org
.
mozilla
.
glean
"
true
)
;
let
extra
:
HashMap
<
String
String
>
=
[
(
"
test
-
key
"
.
into
(
)
"
test
-
value
"
.
into
(
)
)
]
.
iter
(
)
.
cloned
(
)
.
collect
(
)
;
let
metric
=
ExperimentMetric
:
:
new
(
&
glean
"
some
-
experiment
"
.
to_string
(
)
)
;
metric
.
set_active
(
&
glean
"
test
-
branch
"
.
to_string
(
)
Some
(
extra
)
)
;
let
snapshot
=
StorageManager
.
snapshot_experiments_as_json
(
glean
.
storage
(
)
"
glean_internal_info
"
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
some
-
experiment
"
:
{
"
branch
"
:
"
test
-
branch
"
"
extra
"
:
{
"
test
-
key
"
:
"
test
-
value
"
}
}
}
)
snapshot
)
;
metric
.
set_inactive
(
&
glean
)
;
let
empty_snapshot
=
StorageManager
.
snapshot_experiments_as_json
(
glean
.
storage
(
)
"
glean_internal_info
"
)
;
assert
!
(
empty_snapshot
.
is_none
(
)
)
;
}
#
[
test
]
fn
test_experiments_json_serialization_empty
(
)
{
let
t
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
name
=
t
.
path
(
)
.
display
(
)
.
to_string
(
)
;
let
glean
=
Glean
:
:
with_options
(
&
name
"
org
.
mozilla
.
glean
"
true
)
;
let
metric
=
ExperimentMetric
:
:
new
(
&
glean
"
some
-
experiment
"
.
to_string
(
)
)
;
metric
.
set_active
(
&
glean
"
test
-
branch
"
.
to_string
(
)
None
)
;
let
snapshot
=
StorageManager
.
snapshot_experiments_as_json
(
glean
.
storage
(
)
"
glean_internal_info
"
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
some
-
experiment
"
:
{
"
branch
"
:
"
test
-
branch
"
}
}
)
snapshot
)
;
metric
.
set_inactive
(
&
glean
)
;
let
empty_snapshot
=
StorageManager
.
snapshot_experiments_as_json
(
glean
.
storage
(
)
"
glean_internal_info
"
)
;
assert
!
(
empty_snapshot
.
is_none
(
)
)
;
}
}
