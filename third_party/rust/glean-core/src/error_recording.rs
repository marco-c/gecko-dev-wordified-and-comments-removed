use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
fmt
:
:
Display
;
use
crate
:
:
error
:
:
{
Error
ErrorKind
}
;
use
crate
:
:
metrics
:
:
CounterMetric
;
use
crate
:
:
metrics
:
:
{
combine_base_identifier_and_label
strip_label
}
;
use
crate
:
:
CommonMetricData
;
use
crate
:
:
Glean
;
use
crate
:
:
Lifetime
;
#
[
derive
(
Debug
)
]
pub
enum
ErrorType
{
InvalidValue
InvalidLabel
InvalidState
InvalidOverflow
}
impl
ErrorType
{
pub
fn
as_str
(
&
self
)
-
>
&
'
static
str
{
match
self
{
ErrorType
:
:
InvalidValue
=
>
"
invalid_value
"
ErrorType
:
:
InvalidLabel
=
>
"
invalid_label
"
ErrorType
:
:
InvalidState
=
>
"
invalid_state
"
ErrorType
:
:
InvalidOverflow
=
>
"
invalid_overflow
"
}
}
}
impl
TryFrom
<
i32
>
for
ErrorType
{
type
Error
=
Error
;
fn
try_from
(
value
:
i32
)
-
>
Result
<
ErrorType
Self
:
:
Error
>
{
match
value
{
0
=
>
Ok
(
ErrorType
:
:
InvalidValue
)
1
=
>
Ok
(
ErrorType
:
:
InvalidLabel
)
2
=
>
Ok
(
ErrorType
:
:
InvalidState
)
4
=
>
Ok
(
ErrorType
:
:
InvalidOverflow
)
e
=
>
Err
(
ErrorKind
:
:
Lifetime
(
e
)
.
into
(
)
)
}
}
}
fn
get_error_metric_for_metric
(
meta
:
&
CommonMetricData
error
:
ErrorType
)
-
>
CounterMetric
{
let
identifier
=
meta
.
base_identifier
(
)
;
let
name
=
strip_label
(
&
identifier
)
;
let
mut
send_in_pings
=
meta
.
send_in_pings
.
clone
(
)
;
let
ping_name
=
"
metrics
"
.
to_string
(
)
;
if
!
send_in_pings
.
contains
(
&
ping_name
)
{
send_in_pings
.
push
(
ping_name
)
;
}
CounterMetric
:
:
new
(
CommonMetricData
{
name
:
combine_base_identifier_and_label
(
error
.
as_str
(
)
name
)
category
:
"
glean
.
error
"
.
into
(
)
lifetime
:
Lifetime
:
:
Ping
send_in_pings
.
.
Default
:
:
default
(
)
}
)
}
pub
fn
record_error
<
O
:
Into
<
Option
<
i32
>
>
>
(
glean
:
&
Glean
meta
:
&
CommonMetricData
error
:
ErrorType
message
:
impl
Display
num_errors
:
O
)
{
let
metric
=
get_error_metric_for_metric
(
meta
error
)
;
log
:
:
warn
!
(
"
{
}
:
{
}
"
meta
.
base_identifier
(
)
message
)
;
let
to_report
=
num_errors
.
into
(
)
.
unwrap_or
(
1
)
;
debug_assert
!
(
to_report
>
0
)
;
metric
.
add
(
glean
to_report
)
;
}
/
/
/
Get
the
number
of
recorded
errors
for
the
given
metric
and
error
type
.
/
/
/
/
/
/
*
Notes
:
This
is
a
*
*
test
-
only
*
*
API
but
we
need
to
expose
it
to
be
used
in
integration
tests
.
/
/
/
/
/
/
#
#
Arguments
/
/
/
/
/
/
*
glean
-
The
Glean
object
holding
the
database
/
/
/
*
meta
-
The
metadata
of
the
metric
instance
/
/
/
*
error
-
The
type
of
error
/
/
/
/
/
/
#
#
Return
value
/
/
/
/
/
/
The
number
of
errors
reported
pub
fn
test_get_num_recorded_errors
(
glean
:
&
Glean
meta
:
&
CommonMetricData
error
:
ErrorType
ping_name
:
Option
<
&
str
>
)
-
>
Result
<
i32
String
>
{
let
use_ping_name
=
ping_name
.
unwrap_or
(
&
meta
.
send_in_pings
[
0
]
)
;
let
metric
=
get_error_metric_for_metric
(
meta
error
)
;
metric
.
test_get_value
(
glean
use_ping_name
)
.
ok_or_else
(
|
|
{
format
!
(
"
No
error
recorded
for
{
}
in
'
{
}
'
store
"
meta
.
base_identifier
(
)
use_ping_name
)
}
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
metrics
:
:
*
;
const
GLOBAL_APPLICATION_ID
:
&
str
=
"
org
.
mozilla
.
glean
.
test
.
app
"
;
pub
fn
new_glean
(
)
-
>
(
Glean
tempfile
:
:
TempDir
)
{
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
tmpname
=
dir
.
path
(
)
.
display
(
)
.
to_string
(
)
;
let
glean
=
Glean
:
:
with_options
(
&
tmpname
GLOBAL_APPLICATION_ID
true
)
.
unwrap
(
)
;
(
glean
dir
)
}
#
[
test
]
fn
recording_of_all_error_types
(
)
{
let
(
glean
_t
)
=
new_glean
(
)
;
let
string_metric
=
StringMetric
:
:
new
(
CommonMetricData
{
name
:
"
string_metric
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
"
store2
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
User
.
.
Default
:
:
default
(
)
}
)
;
let
expected_invalid_values_errors
:
i32
=
1
;
let
expected_invalid_labels_errors
:
i32
=
2
;
record_error
(
&
glean
string_metric
.
meta
(
)
ErrorType
:
:
InvalidValue
"
Invalid
value
"
None
)
;
record_error
(
&
glean
string_metric
.
meta
(
)
ErrorType
:
:
InvalidLabel
"
Invalid
label
"
expected_invalid_labels_errors
)
;
for
store
in
&
[
"
store1
"
"
store2
"
"
metrics
"
]
{
assert_eq
!
(
Ok
(
expected_invalid_values_errors
)
test_get_num_recorded_errors
(
&
glean
string_metric
.
meta
(
)
ErrorType
:
:
InvalidValue
Some
(
store
)
)
)
;
assert_eq
!
(
Ok
(
expected_invalid_labels_errors
)
test_get_num_recorded_errors
(
&
glean
string_metric
.
meta
(
)
ErrorType
:
:
InvalidLabel
Some
(
store
)
)
)
;
}
}
}
