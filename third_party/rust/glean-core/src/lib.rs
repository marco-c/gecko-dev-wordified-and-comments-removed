#
!
[
deny
(
missing_docs
)
]
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
chrono
:
:
{
DateTime
FixedOffset
}
;
use
once_cell
:
:
sync
:
:
Lazy
;
use
once_cell
:
:
sync
:
:
OnceCell
;
use
std
:
:
sync
:
:
Mutex
;
use
uuid
:
:
Uuid
;
mod
macros
;
mod
common_metric_data
;
mod
database
;
mod
debug
;
mod
error
;
mod
error_recording
;
mod
event_database
;
mod
histogram
;
mod
internal_metrics
;
mod
internal_pings
;
pub
mod
metrics
;
pub
mod
ping
;
pub
mod
storage
;
mod
system
;
pub
mod
traits
;
pub
mod
upload
;
mod
util
;
pub
use
crate
:
:
common_metric_data
:
:
{
CommonMetricData
Lifetime
}
;
use
crate
:
:
database
:
:
Database
;
use
crate
:
:
debug
:
:
DebugOptions
;
pub
use
crate
:
:
error
:
:
{
Error
ErrorKind
Result
}
;
pub
use
crate
:
:
error_recording
:
:
{
test_get_num_recorded_errors
ErrorType
}
;
use
crate
:
:
event_database
:
:
EventDatabase
;
use
crate
:
:
internal_metrics
:
:
{
CoreMetrics
DatabaseMetrics
}
;
use
crate
:
:
internal_pings
:
:
InternalPings
;
use
crate
:
:
metrics
:
:
{
Metric
MetricType
PingType
}
;
use
crate
:
:
ping
:
:
PingMaker
;
use
crate
:
:
storage
:
:
StorageManager
;
use
crate
:
:
upload
:
:
{
PingUploadManager
PingUploadTask
UploadResult
}
;
use
crate
:
:
util
:
:
{
local_now_with_offset
sanitize_application_id
}
;
const
GLEAN_VERSION
:
&
str
=
env
!
(
"
CARGO_PKG_VERSION
"
)
;
const
GLEAN_SCHEMA_VERSION
:
u32
=
1
;
const
DEFAULT_MAX_EVENTS
:
usize
=
500
;
static
KNOWN_CLIENT_ID
:
Lazy
<
Uuid
>
=
Lazy
:
:
new
(
|
|
Uuid
:
:
parse_str
(
"
c0ffeec0
-
ffee
-
c0ff
-
eec0
-
ffeec0ffeec0
"
)
.
unwrap
(
)
)
;
pub
(
crate
)
const
INTERNAL_STORAGE
:
&
str
=
"
glean_internal_info
"
;
pub
(
crate
)
const
PENDING_PINGS_DIRECTORY
:
&
str
=
"
pending_pings
"
;
pub
(
crate
)
const
DELETION_REQUEST_PINGS_DIRECTORY
:
&
str
=
"
deletion_request
"
;
static
GLEAN
:
OnceCell
<
Mutex
<
Glean
>
>
=
OnceCell
:
:
new
(
)
;
pub
fn
global_glean
(
)
-
>
Option
<
&
'
static
Mutex
<
Glean
>
>
{
GLEAN
.
get
(
)
}
pub
fn
setup_glean
(
glean
:
Glean
)
-
>
Result
<
(
)
>
{
if
GLEAN
.
get
(
)
.
is_none
(
)
{
if
GLEAN
.
set
(
Mutex
:
:
new
(
glean
)
)
.
is_err
(
)
{
log
:
:
error
!
(
"
Global
Glean
object
is
initialized
already
.
This
probably
happened
concurrently
.
"
)
}
}
else
{
let
mut
lock
=
GLEAN
.
get
(
)
.
unwrap
(
)
.
lock
(
)
.
unwrap
(
)
;
*
lock
=
glean
;
}
Ok
(
(
)
)
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
Configuration
{
pub
upload_enabled
:
bool
pub
data_path
:
String
pub
application_id
:
String
pub
language_binding_name
:
String
pub
max_events
:
Option
<
usize
>
pub
delay_ping_lifetime_io
:
bool
}
#
[
derive
(
Debug
)
]
pub
struct
Glean
{
upload_enabled
:
bool
data_store
:
Option
<
Database
>
event_data_store
:
EventDatabase
core_metrics
:
CoreMetrics
database_metrics
:
DatabaseMetrics
internal_pings
:
InternalPings
data_path
:
PathBuf
application_id
:
String
ping_registry
:
HashMap
<
String
PingType
>
start_time
:
DateTime
<
FixedOffset
>
max_events
:
usize
is_first_run
:
bool
upload_manager
:
PingUploadManager
debug
:
DebugOptions
}
impl
Glean
{
pub
fn
new_for_subprocess
(
cfg
:
&
Configuration
scan_directories
:
bool
)
-
>
Result
<
Self
>
{
log
:
:
info
!
(
"
Creating
new
Glean
v
{
}
"
GLEAN_VERSION
)
;
let
application_id
=
sanitize_application_id
(
&
cfg
.
application_id
)
;
if
application_id
.
is_empty
(
)
{
return
Err
(
ErrorKind
:
:
InvalidConfig
.
into
(
)
)
;
}
let
data_store
=
Some
(
Database
:
:
new
(
&
cfg
.
data_path
cfg
.
delay_ping_lifetime_io
)
?
)
;
let
event_data_store
=
EventDatabase
:
:
new
(
&
cfg
.
data_path
)
?
;
let
mut
upload_manager
=
PingUploadManager
:
:
new
(
&
cfg
.
data_path
&
cfg
.
language_binding_name
)
;
upload_manager
.
set_rate_limiter
(
60
15
)
;
if
scan_directories
{
let
_scanning_thread
=
upload_manager
.
scan_pending_pings_directories
(
)
;
}
Ok
(
Self
{
upload_enabled
:
cfg
.
upload_enabled
data_store
event_data_store
core_metrics
:
CoreMetrics
:
:
new
(
)
database_metrics
:
DatabaseMetrics
:
:
new
(
)
internal_pings
:
InternalPings
:
:
new
(
)
upload_manager
data_path
:
PathBuf
:
:
from
(
&
cfg
.
data_path
)
application_id
ping_registry
:
HashMap
:
:
new
(
)
start_time
:
local_now_with_offset
(
)
max_events
:
cfg
.
max_events
.
unwrap_or
(
DEFAULT_MAX_EVENTS
)
is_first_run
:
false
debug
:
DebugOptions
:
:
new
(
)
}
)
}
pub
fn
new
(
cfg
:
Configuration
)
-
>
Result
<
Self
>
{
let
mut
glean
=
Self
:
:
new_for_subprocess
(
&
cfg
false
)
?
;
if
cfg
.
upload_enabled
{
glean
.
on_upload_enabled
(
)
;
}
else
{
match
glean
.
core_metrics
.
client_id
.
get_value
(
&
glean
"
glean_client_info
"
)
{
None
=
>
glean
.
clear_metrics
(
)
Some
(
uuid
)
=
>
{
if
uuid
!
=
*
KNOWN_CLIENT_ID
{
glean
.
upload_enabled
=
true
;
glean
.
on_upload_disabled
(
)
;
}
}
}
}
let
_scanning_thread
=
glean
.
upload_manager
.
scan_pending_pings_directories
(
)
;
Ok
(
glean
)
}
#
[
cfg
(
test
)
]
pub
(
crate
)
fn
with_options
(
data_path
:
&
str
application_id
:
&
str
upload_enabled
:
bool
)
-
>
Self
{
let
cfg
=
Configuration
{
data_path
:
data_path
.
into
(
)
application_id
:
application_id
.
into
(
)
language_binding_name
:
"
Rust
"
.
into
(
)
upload_enabled
max_events
:
None
delay_ping_lifetime_io
:
false
}
;
let
mut
glean
=
Self
:
:
new
(
cfg
)
.
unwrap
(
)
;
glean
.
upload_manager
=
PingUploadManager
:
:
no_policy
(
data_path
)
;
glean
}
pub
fn
destroy_db
(
&
mut
self
)
{
self
.
data_store
=
None
;
}
fn
initialize_core_metrics
(
&
mut
self
)
{
let
need_new_client_id
=
match
self
.
core_metrics
.
client_id
.
get_value
(
self
"
glean_client_info
"
)
{
None
=
>
true
Some
(
uuid
)
=
>
uuid
=
=
*
KNOWN_CLIENT_ID
}
;
if
need_new_client_id
{
self
.
core_metrics
.
client_id
.
generate_and_set
(
self
)
;
}
if
self
.
core_metrics
.
first_run_date
.
get_value
(
self
"
glean_client_info
"
)
.
is_none
(
)
{
self
.
core_metrics
.
first_run_date
.
set
(
self
None
)
;
self
.
is_first_run
=
true
;
}
self
.
set_application_lifetime_core_metrics
(
)
;
}
fn
initialize_database_metrics
(
&
mut
self
)
{
log
:
:
trace
!
(
"
Initializing
database
metrics
"
)
;
if
let
Some
(
size
)
=
self
.
data_store
.
as_ref
(
)
.
and_then
(
|
database
|
database
.
file_size
(
)
)
{
log
:
:
trace
!
(
"
Database
file
size
:
{
}
"
size
.
get
(
)
)
;
self
.
database_metrics
.
size
.
accumulate
(
self
size
.
get
(
)
)
}
}
pub
fn
on_ready_to_submit_pings
(
&
self
)
-
>
bool
{
self
.
event_data_store
.
flush_pending_events_on_startup
(
&
self
)
}
pub
fn
set_upload_enabled
(
&
mut
self
flag
:
bool
)
-
>
bool
{
log
:
:
info
!
(
"
Upload
enabled
:
{
:
?
}
"
flag
)
;
if
self
.
upload_enabled
!
=
flag
{
if
flag
{
self
.
on_upload_enabled
(
)
;
}
else
{
self
.
on_upload_disabled
(
)
;
}
true
}
else
{
false
}
}
pub
fn
is_upload_enabled
(
&
self
)
-
>
bool
{
self
.
upload_enabled
}
fn
on_upload_enabled
(
&
mut
self
)
{
self
.
upload_enabled
=
true
;
self
.
initialize_core_metrics
(
)
;
self
.
initialize_database_metrics
(
)
;
}
fn
on_upload_disabled
(
&
mut
self
)
{
if
let
Err
(
err
)
=
self
.
internal_pings
.
deletion_request
.
submit
(
self
None
)
{
log
:
:
error
!
(
"
Failed
to
submit
deletion
-
request
ping
on
optout
:
{
}
"
err
)
;
}
self
.
clear_metrics
(
)
;
self
.
upload_enabled
=
false
;
}
fn
clear_metrics
(
&
mut
self
)
{
let
_lock
=
self
.
upload_manager
.
clear_ping_queue
(
)
;
let
existing_first_run_date
=
self
.
core_metrics
.
first_run_date
.
get_value
(
self
"
glean_client_info
"
)
;
let
ping_maker
=
PingMaker
:
:
new
(
)
;
if
let
Err
(
err
)
=
ping_maker
.
clear_pending_pings
(
self
.
get_data_path
(
)
)
{
log
:
:
error
!
(
"
Error
clearing
pending
pings
:
{
}
"
err
)
;
}
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
data
.
clear_all
(
)
}
if
let
Err
(
err
)
=
self
.
event_data_store
.
clear_all
(
)
{
log
:
:
error
!
(
"
Error
clearing
pending
events
:
{
}
"
err
)
;
}
{
self
.
upload_enabled
=
true
;
self
.
core_metrics
.
client_id
.
set
(
self
*
KNOWN_CLIENT_ID
)
;
if
let
Some
(
existing_first_run_date
)
=
existing_first_run_date
{
self
.
core_metrics
.
first_run_date
.
set
(
self
Some
(
existing_first_run_date
)
)
;
}
self
.
upload_enabled
=
false
;
}
}
pub
fn
get_application_id
(
&
self
)
-
>
&
str
{
&
self
.
application_id
}
pub
fn
get_data_path
(
&
self
)
-
>
&
Path
{
&
self
.
data_path
}
pub
fn
storage
(
&
self
)
-
>
&
Database
{
&
self
.
data_store
.
as_ref
(
)
.
expect
(
"
No
database
found
"
)
}
pub
fn
event_storage
(
&
self
)
-
>
&
EventDatabase
{
&
self
.
event_data_store
}
pub
fn
get_max_events
(
&
self
)
-
>
usize
{
self
.
max_events
}
pub
fn
get_upload_task
(
&
self
)
-
>
PingUploadTask
{
self
.
upload_manager
.
get_upload_task
(
self
self
.
log_pings
(
)
)
}
pub
fn
process_ping_upload_response
(
&
self
uuid
:
&
str
status
:
UploadResult
)
{
self
.
upload_manager
.
process_ping_upload_response
(
self
uuid
status
)
;
}
pub
fn
snapshot
(
&
mut
self
store_name
:
&
str
clear_store
:
bool
)
-
>
String
{
StorageManager
.
snapshot
(
&
self
.
storage
(
)
store_name
clear_store
)
.
unwrap_or_else
(
|
|
String
:
:
from
(
"
"
)
)
}
fn
make_path
(
&
self
ping_name
:
&
str
doc_id
:
&
str
)
-
>
String
{
format
!
(
"
/
submit
/
{
}
/
{
}
/
{
}
/
{
}
"
self
.
get_application_id
(
)
ping_name
GLEAN_SCHEMA_VERSION
doc_id
)
}
pub
fn
submit_ping
(
&
self
ping
:
&
PingType
reason
:
Option
<
&
str
>
)
-
>
Result
<
bool
>
{
if
!
self
.
is_upload_enabled
(
)
{
log
:
:
info
!
(
"
Glean
disabled
:
not
submitting
any
pings
.
"
)
;
return
Ok
(
false
)
;
}
let
ping_maker
=
PingMaker
:
:
new
(
)
;
let
doc_id
=
Uuid
:
:
new_v4
(
)
.
to_string
(
)
;
let
url_path
=
self
.
make_path
(
&
ping
.
name
&
doc_id
)
;
match
ping_maker
.
collect
(
self
&
ping
reason
)
{
None
=
>
{
log
:
:
info
!
(
"
No
content
for
ping
'
{
}
'
therefore
no
ping
queued
.
"
ping
.
name
)
;
Ok
(
false
)
}
Some
(
content
)
=
>
{
if
let
Err
(
e
)
=
ping_maker
.
store_ping
(
self
&
doc_id
&
ping
.
name
&
self
.
get_data_path
(
)
&
url_path
&
content
)
{
log
:
:
warn
!
(
"
IO
error
while
writing
ping
to
file
:
{
}
"
e
)
;
return
Err
(
e
.
into
(
)
)
;
}
self
.
upload_manager
.
enqueue_ping_from_file
(
self
&
doc_id
)
;
log
:
:
info
!
(
"
The
ping
'
{
}
'
was
submitted
and
will
be
sent
as
soon
as
possible
"
ping
.
name
)
;
Ok
(
true
)
}
}
}
pub
fn
submit_ping_by_name
(
&
self
ping_name
:
&
str
reason
:
Option
<
&
str
>
)
-
>
Result
<
bool
>
{
match
self
.
get_ping_by_name
(
ping_name
)
{
None
=
>
{
log
:
:
error
!
(
"
Attempted
to
submit
unknown
ping
'
{
}
'
"
ping_name
)
;
Ok
(
false
)
}
Some
(
ping
)
=
>
self
.
submit_ping
(
ping
reason
)
}
}
pub
fn
get_ping_by_name
(
&
self
ping_name
:
&
str
)
-
>
Option
<
&
PingType
>
{
self
.
ping_registry
.
get
(
ping_name
)
}
pub
fn
register_ping_type
(
&
mut
self
ping
:
&
PingType
)
{
if
self
.
ping_registry
.
contains_key
(
&
ping
.
name
)
{
log
:
:
debug
!
(
"
Duplicate
ping
named
'
{
}
'
"
ping
.
name
)
}
self
.
ping_registry
.
insert
(
ping
.
name
.
clone
(
)
ping
.
clone
(
)
)
;
}
pub
(
crate
)
fn
start_time
(
&
self
)
-
>
DateTime
<
FixedOffset
>
{
self
.
start_time
}
pub
fn
set_experiment_active
(
&
self
experiment_id
:
String
branch
:
String
extra
:
Option
<
HashMap
<
String
String
>
>
)
{
let
metric
=
metrics
:
:
ExperimentMetric
:
:
new
(
&
self
experiment_id
)
;
metric
.
set_active
(
&
self
branch
extra
)
;
}
pub
fn
set_experiment_inactive
(
&
self
experiment_id
:
String
)
{
let
metric
=
metrics
:
:
ExperimentMetric
:
:
new
(
&
self
experiment_id
)
;
metric
.
set_inactive
(
&
self
)
;
}
pub
fn
persist_ping_lifetime_data
(
&
self
)
-
>
Result
<
(
)
>
{
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
return
data
.
persist_ping_lifetime_data
(
)
;
}
Ok
(
(
)
)
}
fn
set_application_lifetime_core_metrics
(
&
self
)
{
self
.
core_metrics
.
os
.
set
(
self
system
:
:
OS
)
;
}
pub
fn
clear_application_lifetime_metrics
(
&
self
)
{
log
:
:
debug
!
(
"
Clearing
Lifetime
:
:
Application
metrics
"
)
;
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
data
.
clear_lifetime
(
Lifetime
:
:
Application
)
;
}
self
.
set_application_lifetime_core_metrics
(
)
;
}
pub
fn
is_first_run
(
&
self
)
-
>
bool
{
self
.
is_first_run
}
pub
fn
set_debug_view_tag
(
&
mut
self
value
:
&
str
)
-
>
bool
{
self
.
debug
.
debug_view_tag
.
set
(
value
.
into
(
)
)
}
pub
(
crate
)
fn
debug_view_tag
(
&
self
)
-
>
Option
<
&
String
>
{
self
.
debug
.
debug_view_tag
.
get
(
)
}
pub
fn
set_source_tags
(
&
mut
self
value
:
Vec
<
String
>
)
-
>
bool
{
self
.
debug
.
source_tags
.
set
(
value
)
}
pub
(
crate
)
fn
source_tags
(
&
self
)
-
>
Option
<
&
Vec
<
String
>
>
{
self
.
debug
.
source_tags
.
get
(
)
}
pub
fn
set_log_pings
(
&
mut
self
value
:
bool
)
-
>
bool
{
self
.
debug
.
log_pings
.
set
(
value
)
}
pub
(
crate
)
fn
log_pings
(
&
self
)
-
>
bool
{
self
.
debug
.
log_pings
.
get
(
)
.
copied
(
)
.
unwrap_or
(
false
)
}
fn
get_dirty_bit_metric
(
&
self
)
-
>
metrics
:
:
BooleanMetric
{
metrics
:
:
BooleanMetric
:
:
new
(
CommonMetricData
{
name
:
"
dirtybit
"
.
into
(
)
category
:
"
"
.
into
(
)
send_in_pings
:
vec
!
[
INTERNAL_STORAGE
.
into
(
)
]
lifetime
:
Lifetime
:
:
User
.
.
Default
:
:
default
(
)
}
)
}
pub
fn
set_dirty_flag
(
&
self
new_value
:
bool
)
{
self
.
get_dirty_bit_metric
(
)
.
set
(
self
new_value
)
;
}
pub
fn
is_dirty_flag_set
(
&
self
)
-
>
bool
{
let
dirty_bit_metric
=
self
.
get_dirty_bit_metric
(
)
;
match
StorageManager
.
snapshot_metric
(
self
.
storage
(
)
INTERNAL_STORAGE
&
dirty_bit_metric
.
meta
(
)
.
identifier
(
self
)
)
{
Some
(
Metric
:
:
Boolean
(
b
)
)
=
>
b
_
=
>
false
}
}
pub
fn
test_is_experiment_active
(
&
self
experiment_id
:
String
)
-
>
bool
{
self
.
test_get_experiment_data_as_json
(
experiment_id
)
.
is_some
(
)
}
pub
fn
test_get_experiment_data_as_json
(
&
self
experiment_id
:
String
)
-
>
Option
<
String
>
{
let
metric
=
metrics
:
:
ExperimentMetric
:
:
new
(
&
self
experiment_id
)
;
metric
.
test_get_value_as_json_string
(
&
self
)
}
pub
fn
test_clear_all_stores
(
&
self
)
{
if
let
Some
(
data
)
=
self
.
data_store
.
as_ref
(
)
{
data
.
clear_all
(
)
}
let
_
=
self
.
event_data_store
.
clear_all
(
)
;
}
}
#
[
cfg
(
test
)
]
#
[
cfg
(
test
)
]
#
[
path
=
"
lib_unit_tests
.
rs
"
]
mod
tests
;
