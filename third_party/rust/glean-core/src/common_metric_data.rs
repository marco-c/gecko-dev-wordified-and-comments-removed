use
std
:
:
convert
:
:
TryFrom
;
use
crate
:
:
error
:
:
{
Error
ErrorKind
}
;
#
[
allow
(
unused_imports
)
]
use
crate
:
:
metrics
:
:
{
dynamic_label
LabeledMetric
}
;
use
crate
:
:
Glean
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
repr
(
i32
)
]
pub
enum
Lifetime
{
Ping
Application
User
}
impl
Default
for
Lifetime
{
fn
default
(
)
-
>
Self
{
Lifetime
:
:
Ping
}
}
impl
Lifetime
{
pub
fn
as_str
(
self
)
-
>
&
'
static
str
{
match
self
{
Lifetime
:
:
Ping
=
>
"
ping
"
Lifetime
:
:
Application
=
>
"
app
"
Lifetime
:
:
User
=
>
"
user
"
}
}
}
impl
TryFrom
<
i32
>
for
Lifetime
{
type
Error
=
Error
;
fn
try_from
(
value
:
i32
)
-
>
Result
<
Lifetime
Self
:
:
Error
>
{
match
value
{
0
=
>
Ok
(
Lifetime
:
:
Ping
)
1
=
>
Ok
(
Lifetime
:
:
Application
)
2
=
>
Ok
(
Lifetime
:
:
User
)
e
=
>
Err
(
ErrorKind
:
:
Lifetime
(
e
)
.
into
(
)
)
}
}
}
#
[
derive
(
Default
Debug
Clone
)
]
pub
struct
CommonMetricData
{
pub
name
:
String
pub
category
:
String
pub
send_in_pings
:
Vec
<
String
>
pub
lifetime
:
Lifetime
pub
disabled
:
bool
pub
dynamic_label
:
Option
<
String
>
}
impl
CommonMetricData
{
pub
fn
new
<
A
:
Into
<
String
>
B
:
Into
<
String
>
C
:
Into
<
String
>
>
(
category
:
A
name
:
B
ping_name
:
C
)
-
>
CommonMetricData
{
CommonMetricData
{
name
:
name
.
into
(
)
category
:
category
.
into
(
)
send_in_pings
:
vec
!
[
ping_name
.
into
(
)
]
.
.
Default
:
:
default
(
)
}
}
pub
(
crate
)
fn
base_identifier
(
&
self
)
-
>
String
{
if
self
.
category
.
is_empty
(
)
{
self
.
name
.
clone
(
)
}
else
{
format
!
(
"
{
}
.
{
}
"
self
.
category
self
.
name
)
}
}
pub
(
crate
)
fn
identifier
(
&
self
glean
:
&
Glean
)
-
>
String
{
let
base_identifier
=
self
.
base_identifier
(
)
;
if
let
Some
(
label
)
=
&
self
.
dynamic_label
{
dynamic_label
(
glean
self
&
base_identifier
label
)
}
else
{
base_identifier
}
}
pub
fn
should_record
(
&
self
)
-
>
bool
{
!
self
.
disabled
}
pub
fn
storage_names
(
&
self
)
-
>
&
[
String
]
{
&
self
.
send_in_pings
}
}
