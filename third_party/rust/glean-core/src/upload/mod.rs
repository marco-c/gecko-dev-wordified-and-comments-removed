#
!
[
allow
(
dead_code
)
]
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
{
Arc
RwLock
RwLockWriteGuard
}
;
use
std
:
:
thread
;
use
log
;
use
serde_json
:
:
Value
as
JsonValue
;
use
directory
:
:
PingDirectoryManager
;
use
request
:
:
PingRequest
;
mod
directory
;
mod
request
;
#
[
derive
(
PartialEq
Debug
)
]
pub
enum
PingUploadTask
{
Upload
(
PingRequest
)
Wait
Done
}
#
[
derive
(
Debug
)
]
pub
struct
PingUploadManager
{
queue
:
Arc
<
RwLock
<
VecDeque
<
PingRequest
>
>
>
directory_manager
:
PingDirectoryManager
processed_pending_pings
:
Arc
<
AtomicBool
>
}
impl
PingUploadManager
{
pub
fn
new
<
P
:
Into
<
PathBuf
>
>
(
data_path
:
P
)
-
>
Self
{
let
queue
=
Arc
:
:
new
(
RwLock
:
:
new
(
VecDeque
:
:
new
(
)
)
)
;
let
directory_manager
=
PingDirectoryManager
:
:
new
(
data_path
)
;
let
processed_pending_pings
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
false
)
)
;
let
local_queue
=
queue
.
clone
(
)
;
let
local_flag
=
processed_pending_pings
.
clone
(
)
;
let
local_manager
=
directory_manager
.
clone
(
)
;
let
_
=
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
glean
.
ping_directory_manager
.
process_dir
"
.
to_string
(
)
)
.
spawn
(
move
|
|
{
let
mut
local_queue
=
local_queue
.
write
(
)
.
expect
(
"
Can
'
t
write
to
pending
pings
queue
.
"
)
;
local_queue
.
extend
(
local_manager
.
process_dir
(
)
)
;
local_flag
.
store
(
true
Ordering
:
:
SeqCst
)
;
}
)
.
expect
(
"
Unable
to
spawn
thread
to
process
pings
directories
.
"
)
;
Self
{
queue
processed_pending_pings
directory_manager
}
}
fn
has_processed_pings_dir
(
&
self
)
-
>
bool
{
self
.
processed_pending_pings
.
load
(
Ordering
:
:
SeqCst
)
}
pub
fn
enqueue_ping
(
&
self
uuid
:
&
str
path
:
&
str
body
:
JsonValue
)
{
let
mut
queue
=
self
.
queue
.
write
(
)
.
expect
(
"
Can
'
t
write
to
pending
pings
queue
.
"
)
;
let
request
=
PingRequest
:
:
new
(
uuid
path
body
)
;
queue
.
push_back
(
request
)
;
}
pub
fn
clear_ping_queue
(
&
self
)
-
>
RwLockWriteGuard
<
'
_
VecDeque
<
PingRequest
>
>
{
let
mut
queue
=
self
.
queue
.
write
(
)
.
expect
(
"
Can
'
t
write
to
pending
pings
queue
.
"
)
;
queue
.
retain
(
|
ping
|
ping
.
is_deletion_request
(
)
)
;
queue
}
pub
fn
get_upload_task
(
&
self
)
-
>
PingUploadTask
{
if
!
self
.
has_processed_pings_dir
(
)
{
return
PingUploadTask
:
:
Wait
;
}
let
mut
queue
=
self
.
queue
.
write
(
)
.
expect
(
"
Can
'
t
write
to
pending
pings
queue
.
"
)
;
match
queue
.
pop_front
(
)
{
Some
(
request
)
=
>
PingUploadTask
:
:
Upload
(
request
)
None
=
>
PingUploadTask
:
:
Done
}
}
pub
fn
process_ping_upload_response
(
&
self
uuid
:
&
str
status
:
u16
)
{
match
status
{
200
.
.
=
299
=
>
{
log
:
:
info
!
(
"
Ping
{
}
successfully
sent
{
}
.
"
uuid
status
)
;
self
.
directory_manager
.
delete_file
(
uuid
)
;
}
400
.
.
=
499
=
>
{
log
:
:
error
!
(
"
Server
returned
client
error
code
{
}
while
attempting
to
send
ping
{
}
.
"
status
uuid
)
;
self
.
directory_manager
.
delete_file
(
uuid
)
;
}
_
=
>
{
log
:
:
error
!
(
"
Server
returned
response
code
{
}
while
attempting
to
send
ping
{
}
.
"
status
uuid
)
;
if
let
Some
(
request
)
=
self
.
directory_manager
.
process_file
(
uuid
)
{
let
mut
queue
=
self
.
queue
.
write
(
)
.
expect
(
"
Can
'
t
write
to
pending
pings
queue
.
"
)
;
queue
.
push_back
(
request
)
;
}
}
}
;
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
std
:
:
thread
;
use
std
:
:
time
:
:
Duration
;
use
serde_json
:
:
json
;
use
super
:
:
*
;
use
crate
:
:
metrics
:
:
PingType
;
use
crate
:
:
{
tests
:
:
new_glean
PENDING_PINGS_DIRECTORY
}
;
const
UUID
:
&
str
=
"
40e31919
-
684f
-
43b0
-
a5aa
-
e15c2d56a674
"
;
const
PATH
:
&
str
=
"
/
submit
/
app_id
/
ping_name
/
schema_version
/
doc_id
"
;
#
[
test
]
fn
test_doesnt_error_when_there_are_no_pending_pings
(
)
{
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
dir
.
path
(
)
)
;
while
upload_manager
.
get_upload_task
(
)
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
}
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_returns_ping_request_when_there_is_one
(
)
{
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
dir
.
path
(
)
)
;
while
upload_manager
.
get_upload_task
(
)
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
}
upload_manager
.
enqueue_ping
(
UUID
PATH
json
!
(
{
}
)
)
;
match
upload_manager
.
get_upload_task
(
)
{
PingUploadTask
:
:
Upload
(
_
)
=
>
{
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
}
#
[
test
]
fn
test_returns_as_many_ping_requests_as_there_are
(
)
{
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
dir
.
path
(
)
)
;
while
upload_manager
.
get_upload_task
(
)
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
}
let
n
=
10
;
for
_
in
0
.
.
n
{
upload_manager
.
enqueue_ping
(
UUID
PATH
json
!
(
{
}
)
)
;
}
for
_
in
0
.
.
n
{
match
upload_manager
.
get_upload_task
(
)
{
PingUploadTask
:
:
Upload
(
_
)
=
>
{
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
}
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_clearing_the_queue_works_correctly
(
)
{
let
dir
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
dir
.
path
(
)
)
;
while
upload_manager
.
get_upload_task
(
)
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
}
for
_
in
0
.
.
10
{
upload_manager
.
enqueue_ping
(
UUID
PATH
json
!
(
{
}
)
)
;
}
let
_
=
upload_manager
.
clear_ping_queue
(
)
;
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_clearing_the_queue_doesnt_clear_deletion_request_pings
(
)
{
let
(
mut
glean
_
)
=
new_glean
(
None
)
;
let
ping_type
=
PingType
:
:
new
(
"
test
"
true
true
vec
!
[
]
)
;
glean
.
register_ping_type
(
&
ping_type
)
;
let
n
=
10
;
for
_
in
0
.
.
n
{
glean
.
submit_ping
(
&
ping_type
None
)
.
unwrap
(
)
;
}
glean
.
internal_pings
.
deletion_request
.
submit
(
&
glean
None
)
.
unwrap
(
)
;
let
_
=
glean
.
upload_manager
.
clear_ping_queue
(
)
;
let
upload_task
=
glean
.
get_upload_task
(
)
;
match
upload_task
{
PingUploadTask
:
:
Upload
(
request
)
=
>
assert
!
(
request
.
is_deletion_request
(
)
)
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
assert_eq
!
(
glean
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_fills_up_queue_successfully_from_disk
(
)
{
let
(
mut
glean
dir
)
=
new_glean
(
None
)
;
let
ping_type
=
PingType
:
:
new
(
"
test
"
true
true
vec
!
[
]
)
;
glean
.
register_ping_type
(
&
ping_type
)
;
let
n
=
10
;
for
_
in
0
.
.
n
{
glean
.
submit_ping
(
&
ping_type
None
)
.
unwrap
(
)
;
}
let
upload_manager
=
PingUploadManager
:
:
new
(
dir
.
path
(
)
)
;
let
mut
upload_task
=
upload_manager
.
get_upload_task
(
)
;
while
upload_task
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
upload_task
=
upload_manager
.
get_upload_task
(
)
;
}
for
_
in
0
.
.
n
{
match
upload_task
{
PingUploadTask
:
:
Upload
(
_
)
=
>
{
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
upload_task
=
upload_manager
.
get_upload_task
(
)
;
}
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_processes_correctly_success_upload_response
(
)
{
let
(
mut
glean
dir
)
=
new_glean
(
None
)
;
let
ping_type
=
PingType
:
:
new
(
"
test
"
true
true
vec
!
[
]
)
;
glean
.
register_ping_type
(
&
ping_type
)
;
glean
.
submit_ping
(
&
ping_type
None
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
&
dir
.
path
(
)
)
;
let
mut
upload_task
=
upload_manager
.
get_upload_task
(
)
;
while
upload_task
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
upload_task
=
upload_manager
.
get_upload_task
(
)
;
}
let
pending_pings_dir
=
dir
.
path
(
)
.
join
(
PENDING_PINGS_DIRECTORY
)
;
match
upload_task
{
PingUploadTask
:
:
Upload
(
request
)
=
>
{
let
uuid
=
request
.
uuid
;
upload_manager
.
process_ping_upload_response
(
&
uuid
200
)
;
assert
!
(
!
pending_pings_dir
.
join
(
uuid
)
.
exists
(
)
)
;
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_processes_correctly_client_error_upload_response
(
)
{
let
(
mut
glean
dir
)
=
new_glean
(
None
)
;
let
ping_type
=
PingType
:
:
new
(
"
test
"
true
true
vec
!
[
]
)
;
glean
.
register_ping_type
(
&
ping_type
)
;
glean
.
submit_ping
(
&
ping_type
None
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
&
dir
.
path
(
)
)
;
let
mut
upload_task
=
upload_manager
.
get_upload_task
(
)
;
while
upload_task
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
upload_task
=
upload_manager
.
get_upload_task
(
)
;
}
let
pending_pings_dir
=
dir
.
path
(
)
.
join
(
PENDING_PINGS_DIRECTORY
)
;
match
upload_task
{
PingUploadTask
:
:
Upload
(
request
)
=
>
{
let
uuid
=
request
.
uuid
;
upload_manager
.
process_ping_upload_response
(
&
uuid
404
)
;
assert
!
(
!
pending_pings_dir
.
join
(
uuid
)
.
exists
(
)
)
;
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
#
[
test
]
fn
test_processes_correctly_server_error_upload_response
(
)
{
let
(
mut
glean
dir
)
=
new_glean
(
None
)
;
let
ping_type
=
PingType
:
:
new
(
"
test
"
true
true
vec
!
[
]
)
;
glean
.
register_ping_type
(
&
ping_type
)
;
glean
.
submit_ping
(
&
ping_type
None
)
.
unwrap
(
)
;
let
upload_manager
=
PingUploadManager
:
:
new
(
dir
.
path
(
)
)
;
let
mut
upload_task
=
upload_manager
.
get_upload_task
(
)
;
while
upload_task
=
=
PingUploadTask
:
:
Wait
{
thread
:
:
sleep
(
Duration
:
:
from_millis
(
10
)
)
;
upload_task
=
upload_manager
.
get_upload_task
(
)
;
}
match
upload_task
{
PingUploadTask
:
:
Upload
(
request
)
=
>
{
let
uuid
=
request
.
uuid
;
upload_manager
.
process_ping_upload_response
(
&
uuid
500
)
;
match
upload_manager
.
get_upload_task
(
)
{
PingUploadTask
:
:
Upload
(
request
)
=
>
{
assert_eq
!
(
uuid
request
.
uuid
)
;
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
}
_
=
>
panic
!
(
"
Expected
upload
manager
to
return
the
next
request
!
"
)
}
assert_eq
!
(
upload_manager
.
get_upload_task
(
)
PingUploadTask
:
:
Done
)
;
}
}
