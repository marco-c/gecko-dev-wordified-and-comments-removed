use
std
:
:
fs
:
:
{
create_dir_all
File
}
;
use
std
:
:
io
:
:
Write
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
log
:
:
info
;
use
serde_json
:
:
{
json
Value
as
JsonValue
}
;
use
crate
:
:
common_metric_data
:
:
{
CommonMetricData
Lifetime
}
;
use
crate
:
:
metrics
:
:
{
CounterMetric
DatetimeMetric
Metric
MetricType
PingType
TimeUnit
}
;
use
crate
:
:
storage
:
:
{
StorageManager
INTERNAL_STORAGE
}
;
use
crate
:
:
upload
:
:
{
HeaderMap
PingMetadata
}
;
use
crate
:
:
util
:
:
{
get_iso_time_string
local_now_with_offset
}
;
use
crate
:
:
{
Glean
Result
DELETION_REQUEST_PINGS_DIRECTORY
PENDING_PINGS_DIRECTORY
}
;
pub
struct
Ping
<
'
a
>
{
pub
doc_id
:
&
'
a
str
pub
name
:
&
'
a
str
pub
url_path
:
&
'
a
str
pub
content
:
JsonValue
pub
headers
:
HeaderMap
pub
includes_info_sections
:
bool
}
pub
struct
PingMaker
;
fn
merge
(
a
:
&
mut
JsonValue
b
:
&
JsonValue
)
{
match
(
a
b
)
{
(
&
mut
JsonValue
:
:
Object
(
ref
mut
a
)
JsonValue
:
:
Object
(
b
)
)
=
>
{
for
(
k
v
)
in
b
{
merge
(
a
.
entry
(
k
.
clone
(
)
)
.
or_insert
(
JsonValue
:
:
Null
)
v
)
;
}
}
(
a
b
)
=
>
{
*
a
=
b
.
clone
(
)
;
}
}
}
impl
Default
for
PingMaker
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
PingMaker
{
pub
fn
new
(
)
-
>
Self
{
Self
}
fn
get_ping_seq
(
&
self
glean
:
&
Glean
storage_name
:
&
str
)
-
>
usize
{
let
seq
=
CounterMetric
:
:
new
(
CommonMetricData
{
name
:
format
!
(
"
{
}
#
sequence
"
storage_name
)
category
:
"
"
.
into
(
)
send_in_pings
:
vec
!
[
INTERNAL_STORAGE
.
into
(
)
]
lifetime
:
Lifetime
:
:
User
.
.
Default
:
:
default
(
)
}
)
;
let
current_seq
=
match
StorageManager
.
snapshot_metric
(
glean
.
storage
(
)
INTERNAL_STORAGE
&
seq
.
meta
(
)
.
identifier
(
glean
)
seq
.
meta
(
)
.
inner
.
lifetime
)
{
Some
(
Metric
:
:
Counter
(
i
)
)
=
>
i
_
=
>
0
}
;
seq
.
add_sync
(
glean
1
)
;
current_seq
as
usize
}
fn
get_start_end_times
(
&
self
glean
:
&
Glean
storage_name
:
&
str
time_unit
:
TimeUnit
)
-
>
(
String
String
)
{
let
start_time
=
DatetimeMetric
:
:
new
(
CommonMetricData
{
name
:
format
!
(
"
{
}
#
start
"
storage_name
)
category
:
"
"
.
into
(
)
send_in_pings
:
vec
!
[
INTERNAL_STORAGE
.
into
(
)
]
lifetime
:
Lifetime
:
:
User
.
.
Default
:
:
default
(
)
}
time_unit
)
;
let
start_time_data
=
start_time
.
get_value
(
glean
INTERNAL_STORAGE
)
.
unwrap_or_else
(
|
|
glean
.
start_time
(
)
)
;
let
end_time_data
=
local_now_with_offset
(
)
;
start_time
.
set_sync_chrono
(
glean
end_time_data
)
;
let
start_time_data
=
get_iso_time_string
(
start_time_data
time_unit
)
;
let
end_time_data
=
get_iso_time_string
(
end_time_data
time_unit
)
;
(
start_time_data
end_time_data
)
}
fn
get_ping_info
(
&
self
glean
:
&
Glean
storage_name
:
&
str
reason
:
Option
<
&
str
>
precision
:
TimeUnit
)
-
>
JsonValue
{
let
(
start_time
end_time
)
=
self
.
get_start_end_times
(
glean
storage_name
precision
)
;
let
mut
map
=
json
!
(
{
"
seq
"
:
self
.
get_ping_seq
(
glean
storage_name
)
"
start_time
"
:
start_time
"
end_time
"
:
end_time
}
)
;
if
let
Some
(
reason
)
=
reason
{
map
.
as_object_mut
(
)
.
unwrap
(
)
.
insert
(
"
reason
"
.
to_string
(
)
JsonValue
:
:
String
(
reason
.
to_string
(
)
)
)
;
}
;
if
let
Some
(
experiment_data
)
=
StorageManager
.
snapshot_experiments_as_json
(
glean
.
storage
(
)
INTERNAL_STORAGE
)
{
map
.
as_object_mut
(
)
.
unwrap
(
)
.
insert
(
"
experiments
"
.
to_string
(
)
experiment_data
)
;
}
;
map
}
fn
get_client_info
(
&
self
glean
:
&
Glean
include_client_id
:
bool
)
-
>
JsonValue
{
let
mut
map
=
json
!
(
{
"
telemetry_sdk_build
"
:
crate
:
:
GLEAN_VERSION
}
)
;
if
let
Some
(
client_info
)
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
glean_client_info
"
true
)
{
let
client_info_obj
=
client_info
.
as_object
(
)
.
unwrap
(
)
;
for
(
_key
value
)
in
client_info_obj
{
merge
(
&
mut
map
value
)
;
}
}
else
{
log
:
:
warn
!
(
"
Empty
client
info
data
.
"
)
;
}
if
!
include_client_id
{
map
.
as_object_mut
(
)
.
unwrap
(
)
.
remove
(
"
client_id
"
)
;
}
json
!
(
map
)
}
fn
get_headers
(
&
self
glean
:
&
Glean
)
-
>
HeaderMap
{
let
mut
headers_map
=
HeaderMap
:
:
new
(
)
;
if
let
Some
(
debug_view_tag
)
=
glean
.
debug_view_tag
(
)
{
headers_map
.
insert
(
"
X
-
Debug
-
ID
"
.
to_string
(
)
debug_view_tag
.
to_string
(
)
)
;
}
if
let
Some
(
source_tags
)
=
glean
.
source_tags
(
)
{
headers_map
.
insert
(
"
X
-
Source
-
Tags
"
.
to_string
(
)
source_tags
.
join
(
"
"
)
)
;
}
headers_map
}
pub
fn
collect
<
'
a
>
(
&
self
glean
:
&
Glean
ping
:
&
'
a
PingType
reason
:
Option
<
&
str
>
doc_id
:
&
'
a
str
url_path
:
&
'
a
str
)
-
>
Option
<
Ping
<
'
a
>
>
{
info
!
(
"
Collecting
{
}
"
ping
.
name
(
)
)
;
let
mut
metrics_data
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
ping
.
name
(
)
true
)
;
let
events_data
=
glean
.
event_storage
(
)
.
snapshot_as_json
(
glean
ping
.
name
(
)
true
)
;
if
(
!
ping
.
include_client_id
(
)
|
|
!
ping
.
send_if_empty
(
)
|
|
!
ping
.
include_info_sections
(
)
)
&
&
glean
.
test_get_experimentation_id
(
)
.
is_some
(
)
&
&
metrics_data
.
is_some
(
)
{
let
metrics
=
metrics_data
.
as_mut
(
)
.
unwrap
(
)
.
as_object_mut
(
)
.
unwrap
(
)
;
let
metrics_count
=
metrics
.
len
(
)
;
let
strings
=
metrics
.
get_mut
(
"
string
"
)
.
unwrap
(
)
.
as_object_mut
(
)
.
unwrap
(
)
;
let
string_count
=
strings
.
len
(
)
;
let
empty_payload
=
events_data
.
is_none
(
)
&
&
metrics_count
=
=
1
&
&
string_count
=
=
1
;
if
!
ping
.
include_client_id
(
)
|
|
(
!
ping
.
send_if_empty
(
)
&
&
empty_payload
)
{
strings
.
remove
(
"
glean
.
client
.
annotation
.
experimentation_id
"
)
;
}
if
strings
.
is_empty
(
)
{
metrics
.
remove
(
"
string
"
)
;
}
if
metrics
.
is_empty
(
)
{
metrics_data
=
None
;
}
}
let
is_empty
=
metrics_data
.
is_none
(
)
&
&
events_data
.
is_none
(
)
;
if
!
ping
.
send_if_empty
(
)
&
&
is_empty
{
info
!
(
"
Storage
for
{
}
empty
.
Bailing
out
.
"
ping
.
name
(
)
)
;
return
None
;
}
else
if
ping
.
name
(
)
=
=
"
events
"
&
&
events_data
.
is_none
(
)
{
info
!
(
"
No
events
for
'
events
'
ping
.
Bailing
out
.
"
)
;
return
None
;
}
else
if
is_empty
{
info
!
(
"
Storage
for
{
}
empty
.
Ping
will
still
be
sent
.
"
ping
.
name
(
)
)
;
}
let
precision
=
if
ping
.
precise_timestamps
(
)
{
TimeUnit
:
:
Millisecond
}
else
{
TimeUnit
:
:
Minute
}
;
let
mut
json
=
if
ping
.
include_info_sections
(
)
{
let
ping_info
=
self
.
get_ping_info
(
glean
ping
.
name
(
)
reason
precision
)
;
let
client_info
=
self
.
get_client_info
(
glean
ping
.
include_client_id
(
)
)
;
json
!
(
{
"
ping_info
"
:
ping_info
"
client_info
"
:
client_info
}
)
}
else
{
json
!
(
{
}
)
}
;
let
json_obj
=
json
.
as_object_mut
(
)
?
;
if
let
Some
(
metrics_data
)
=
metrics_data
{
json_obj
.
insert
(
"
metrics
"
.
to_string
(
)
metrics_data
)
;
}
if
let
Some
(
events_data
)
=
events_data
{
json_obj
.
insert
(
"
events
"
.
to_string
(
)
events_data
)
;
}
Some
(
Ping
{
content
:
json
name
:
ping
.
name
(
)
doc_id
url_path
headers
:
self
.
get_headers
(
glean
)
includes_info_sections
:
ping
.
include_info_sections
(
)
}
)
}
fn
get_pings_dir
(
&
self
data_path
:
&
Path
ping_type
:
Option
<
&
str
>
)
-
>
std
:
:
io
:
:
Result
<
PathBuf
>
{
let
pings_dir
=
match
ping_type
{
Some
(
"
deletion
-
request
"
)
=
>
data_path
.
join
(
DELETION_REQUEST_PINGS_DIRECTORY
)
_
=
>
data_path
.
join
(
PENDING_PINGS_DIRECTORY
)
}
;
create_dir_all
(
&
pings_dir
)
?
;
Ok
(
pings_dir
)
}
fn
get_tmp_dir
(
&
self
data_path
:
&
Path
)
-
>
std
:
:
io
:
:
Result
<
PathBuf
>
{
let
pings_dir
=
data_path
.
join
(
"
tmp
"
)
;
create_dir_all
(
&
pings_dir
)
?
;
Ok
(
pings_dir
)
}
pub
fn
store_ping
(
&
self
data_path
:
&
Path
ping
:
&
Ping
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
let
pings_dir
=
self
.
get_pings_dir
(
data_path
Some
(
ping
.
name
)
)
?
;
let
temp_dir
=
self
.
get_tmp_dir
(
data_path
)
?
;
let
temp_ping_path
=
temp_dir
.
join
(
ping
.
doc_id
)
;
let
ping_path
=
pings_dir
.
join
(
ping
.
doc_id
)
;
log
:
:
debug
!
(
"
Storing
ping
'
{
}
'
at
'
{
}
'
"
ping
.
doc_id
ping_path
.
display
(
)
)
;
{
let
mut
file
=
File
:
:
create
(
&
temp_ping_path
)
?
;
file
.
write_all
(
ping
.
url_path
.
as_bytes
(
)
)
?
;
file
.
write_all
(
b
"
\
n
"
)
?
;
file
.
write_all
(
:
:
serde_json
:
:
to_string
(
&
ping
.
content
)
?
.
as_bytes
(
)
)
?
;
file
.
write_all
(
b
"
\
n
"
)
?
;
let
metadata
=
PingMetadata
{
headers
:
Some
(
ping
.
headers
.
clone
(
)
)
body_has_info_sections
:
Some
(
ping
.
includes_info_sections
)
ping_name
:
Some
(
ping
.
name
.
to_string
(
)
)
}
;
file
.
write_all
(
:
:
serde_json
:
:
to_string
(
&
metadata
)
?
.
as_bytes
(
)
)
?
;
}
if
let
Err
(
e
)
=
std
:
:
fs
:
:
rename
(
&
temp_ping_path
&
ping_path
)
{
log
:
:
warn
!
(
"
Unable
to
move
'
{
}
'
to
'
{
}
"
temp_ping_path
.
display
(
)
ping_path
.
display
(
)
)
;
return
Err
(
e
)
;
}
Ok
(
(
)
)
}
pub
fn
clear_pending_pings
(
&
self
data_path
:
&
Path
)
-
>
Result
<
(
)
>
{
let
pings_dir
=
self
.
get_pings_dir
(
data_path
None
)
?
;
std
:
:
fs
:
:
remove_dir_all
(
&
pings_dir
)
?
;
create_dir_all
(
&
pings_dir
)
?
;
log
:
:
debug
!
(
"
All
pending
pings
deleted
"
)
;
Ok
(
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
tests
:
:
new_glean
;
#
[
test
]
fn
sequence_numbers_should_be_reset_when_toggling_uploading
(
)
{
let
(
mut
glean
_t
)
=
new_glean
(
None
)
;
let
ping_maker
=
PingMaker
:
:
new
(
)
;
assert_eq
!
(
0
ping_maker
.
get_ping_seq
(
&
glean
"
custom
"
)
)
;
assert_eq
!
(
1
ping_maker
.
get_ping_seq
(
&
glean
"
custom
"
)
)
;
glean
.
set_upload_enabled
(
false
)
;
assert_eq
!
(
0
ping_maker
.
get_ping_seq
(
&
glean
"
custom
"
)
)
;
assert_eq
!
(
0
ping_maker
.
get_ping_seq
(
&
glean
"
custom
"
)
)
;
glean
.
set_upload_enabled
(
true
)
;
assert_eq
!
(
0
ping_maker
.
get_ping_seq
(
&
glean
"
custom
"
)
)
;
assert_eq
!
(
1
ping_maker
.
get_ping_seq
(
&
glean
"
custom
"
)
)
;
}
}
