#
!
[
allow
(
dead_code
)
]
use
glean_core
:
:
{
Glean
Result
}
;
use
std
:
:
fs
:
:
{
read_dir
File
}
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
use
std
:
:
path
:
:
Path
;
use
chrono
:
:
offset
:
:
TimeZone
;
use
iso8601
:
:
Date
:
:
YMD
;
use
serde_json
:
:
Value
as
JsonValue
;
use
ctor
:
:
ctor
;
#
[
ctor
]
fn
enable_test_logging
(
)
{
let
_
=
env_logger
:
:
builder
(
)
.
is_test
(
true
)
.
try_init
(
)
;
}
pub
fn
tempdir
(
)
-
>
(
tempfile
:
:
TempDir
String
)
{
let
t
=
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
;
let
name
=
t
.
path
(
)
.
display
(
)
.
to_string
(
)
;
(
t
name
)
}
pub
const
GLOBAL_APPLICATION_ID
:
&
str
=
"
org
.
mozilla
.
glean
.
test
.
app
"
;
pub
fn
new_glean
(
tempdir
:
Option
<
tempfile
:
:
TempDir
>
)
-
>
(
Glean
tempfile
:
:
TempDir
)
{
let
dir
=
match
tempdir
{
Some
(
tempdir
)
=
>
tempdir
None
=
>
tempfile
:
:
tempdir
(
)
.
unwrap
(
)
}
;
let
cfg
=
glean_core
:
:
InternalConfiguration
{
data_path
:
dir
.
path
(
)
.
display
(
)
.
to_string
(
)
application_id
:
GLOBAL_APPLICATION_ID
.
into
(
)
language_binding_name
:
"
Rust
"
.
into
(
)
upload_enabled
:
true
max_events
:
None
delay_ping_lifetime_io
:
false
app_build
:
"
Unknown
"
.
into
(
)
use_core_mps
:
false
trim_data_to_registered_pings
:
false
log_level
:
None
}
;
let
glean
=
Glean
:
:
new
(
cfg
)
.
unwrap
(
)
;
(
glean
dir
)
}
pub
fn
iso8601_to_chrono
(
datetime
:
&
iso8601
:
:
DateTime
)
-
>
chrono
:
:
DateTime
<
chrono
:
:
FixedOffset
>
{
if
let
YMD
{
year
month
day
}
=
datetime
.
date
{
return
chrono
:
:
FixedOffset
:
:
east
(
datetime
.
time
.
tz_offset_hours
*
3600
)
.
ymd
(
year
month
day
)
.
and_hms_milli
(
datetime
.
time
.
hour
datetime
.
time
.
minute
datetime
.
time
.
second
datetime
.
time
.
millisecond
)
;
}
;
panic
!
(
"
Unsupported
datetime
format
"
)
;
}
pub
fn
get_queued_pings
(
data_path
:
&
Path
)
-
>
Result
<
Vec
<
(
String
JsonValue
Option
<
JsonValue
>
)
>
>
{
get_pings
(
&
data_path
.
join
(
"
pending_pings
"
)
)
}
pub
fn
get_deletion_pings
(
data_path
:
&
Path
)
-
>
Result
<
Vec
<
(
String
JsonValue
Option
<
JsonValue
>
)
>
>
{
get_pings
(
&
data_path
.
join
(
"
deletion_request
"
)
)
}
fn
get_pings
(
pings_dir
:
&
Path
)
-
>
Result
<
Vec
<
(
String
JsonValue
Option
<
JsonValue
>
)
>
>
{
let
entries
=
read_dir
(
pings_dir
)
?
;
Ok
(
entries
.
filter_map
(
|
entry
|
entry
.
ok
(
)
)
.
filter
(
|
entry
|
match
entry
.
file_type
(
)
{
Ok
(
file_type
)
=
>
file_type
.
is_file
(
)
Err
(
_
)
=
>
false
}
)
.
filter_map
(
|
entry
|
File
:
:
open
(
entry
.
path
(
)
)
.
ok
(
)
)
.
filter_map
(
|
file
|
{
let
mut
lines
=
BufReader
:
:
new
(
file
)
.
lines
(
)
;
if
let
(
Some
(
Ok
(
url
)
)
Some
(
Ok
(
body
)
)
Ok
(
metadata
)
)
=
(
lines
.
next
(
)
lines
.
next
(
)
lines
.
next
(
)
.
transpose
(
)
)
{
let
parsed_metadata
=
metadata
.
map
(
|
m
|
{
serde_json
:
:
from_str
:
:
<
JsonValue
>
(
&
m
)
.
expect
(
"
metadata
should
be
valid
JSON
"
)
}
)
;
if
let
Ok
(
parsed_body
)
=
serde_json
:
:
from_str
:
:
<
JsonValue
>
(
&
body
)
{
Some
(
(
url
parsed_body
parsed_metadata
)
)
}
else
{
None
}
}
else
{
None
}
}
)
.
collect
(
)
)
}
