mod
common
;
use
crate
:
:
common
:
:
*
;
use
serde_json
:
:
json
;
use
glean_core
:
:
metrics
:
:
*
;
use
glean_core
:
:
storage
:
:
StorageManager
;
use
glean_core
:
:
{
test_get_num_recorded_errors
ErrorType
}
;
use
glean_core
:
:
{
CommonMetricData
Lifetime
}
;
#
[
test
]
fn
can_create_dual_labeled_counter_metric
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
Some
(
vec
!
[
"
key1
"
.
into
(
)
]
)
Some
(
vec
!
[
"
category1
"
.
into
(
)
]
)
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
1
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
dual_labeled_counter
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
{
"
key1
"
:
{
"
category1
"
:
1
}
}
}
}
)
snapshot
)
;
}
#
[
test
]
fn
can_use_multiple_labels
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
1
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category2
"
)
;
metric
.
add_sync
(
&
glean
2
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key2
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
3
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key2
"
"
category3
"
)
;
metric
.
add_sync
(
&
glean
4
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
dual_labeled_counter
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
{
"
key1
"
:
{
"
category1
"
:
1
"
category2
"
:
2
}
"
key2
"
:
{
"
category1
"
:
3
"
category3
"
:
4
}
}
}
}
)
snapshot
)
;
}
#
[
test
]
fn
can_record_error_for_submetric
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
Some
(
vec
!
[
"
key1
"
.
into
(
)
]
)
Some
(
vec
!
[
"
category1
"
.
into
(
)
]
)
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
-
1
)
;
assert_eq
!
(
Ok
(
1
)
test_get_num_recorded_errors
(
&
glean
metric
.
meta
(
)
ErrorType
:
:
InvalidValue
)
)
;
}
#
[
test
]
fn
labels_are_checked_against_static_list
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
Some
(
vec
!
[
"
key1
"
.
into
(
)
"
key2
"
.
into
(
)
]
)
Some
(
vec
!
[
"
category1
"
.
into
(
)
"
category2
"
.
into
(
)
]
)
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
1
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category2
"
)
;
metric
.
add_sync
(
&
glean
2
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key2
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
3
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key2
"
"
category2
"
)
;
metric
.
add_sync
(
&
glean
4
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key3
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
5
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key1
"
"
category3
"
)
;
metric
.
add_sync
(
&
glean
6
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
key3
"
"
category3
"
)
;
metric
.
add_sync
(
&
glean
7
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
dual_labeled_counter
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
{
"
key1
"
:
{
"
category1
"
:
1
"
category2
"
:
2
"
__other__
"
:
6
}
"
key2
"
:
{
"
category1
"
:
3
"
category2
"
:
4
}
"
__other__
"
:
{
"
category1
"
:
5
"
__other__
"
:
7
}
}
}
}
)
snapshot
)
;
}
#
[
test
]
fn
dynamic_labels_too_long
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
1
"
.
repeat
(
112
)
"
2
"
.
repeat
(
112
)
)
;
metric
.
add_sync
(
&
glean
1
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
dual_labeled_counter
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
{
"
__other__
"
:
{
"
__other__
"
:
1
}
}
}
"
labeled_counter
"
:
{
"
glean
.
error
.
invalid_label
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
2
}
}
}
)
snapshot
)
;
}
#
[
test
]
fn
dynamic_labels_regex_allowed
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
let
labels_validating
=
vec
!
[
(
"
key
.
is
.
fine
"
"
cat
.
is
.
fine
"
)
(
"
key_is_fine_too
"
"
cat_is_fine_too
"
)
(
"
key
.
is_still_fine
"
"
cat
.
is_still_fine
"
)
(
"
keyisfine
"
"
catisfine
"
)
(
"
_
.
key
-
is_fine
"
"
_
.
cat
-
is_fine
"
)
(
"
key
.
is
-
fine
"
"
cat
.
is
-
fine
"
)
(
"
key
-
is
-
fine
"
"
cat
-
is
-
fine
"
)
]
;
for
(
key
category
)
in
&
labels_validating
{
dual_labeled_counter
.
get
(
key
category
)
.
add_sync
(
&
glean
1
)
;
}
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
dual_labeled_counter
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
{
"
key
.
is
.
fine
"
:
{
"
cat
.
is
.
fine
"
:
1
}
"
key_is_fine_too
"
:
{
"
cat_is_fine_too
"
:
1
}
"
key
.
is_still_fine
"
:
{
"
cat
.
is_still_fine
"
:
1
}
"
keyisfine
"
:
{
"
catisfine
"
:
1
}
"
_
.
key
-
is_fine
"
:
{
"
_
.
cat
-
is_fine
"
:
1
}
"
key
.
is
-
fine
"
:
{
"
cat
.
is
-
fine
"
:
1
}
"
key
-
is
-
fine
"
:
{
"
cat
-
is
-
fine
"
:
1
}
}
}
}
)
snapshot
)
;
}
#
[
test
]
fn
seen_labels_get_reloaded_from_disk
(
)
{
let
(
mut
tempdir
_
)
=
tempdir
(
)
;
let
(
glean
dir
)
=
new_glean
(
Some
(
tempdir
)
)
;
tempdir
=
dir
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
{
for
i
in
1
.
.
=
16
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
let
category
=
format
!
(
"
category
{
i
}
"
)
;
dual_labeled_counter
.
get
(
key
category
)
.
add_sync
(
&
glean
i
)
;
}
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
false
)
.
unwrap
(
)
;
for
i
in
1
.
.
=
16
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
let
category
=
format
!
(
"
category
{
i
}
"
)
;
assert_eq
!
(
i
snapshot
[
"
dual_labeled_counter
"
]
[
"
telemetry
.
dual_labeled_counter
"
]
[
&
key
]
[
&
category
]
)
;
}
drop
(
glean
)
;
}
{
let
(
glean
_t
)
=
new_glean
(
Some
(
tempdir
)
)
;
dual_labeled_counter
.
get
(
"
new_key
"
"
new_category
"
)
.
add_sync
(
&
glean
40
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
false
)
.
unwrap
(
)
;
for
i
in
1
.
.
=
16
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
let
category
=
format
!
(
"
category
{
i
}
"
)
;
assert_eq
!
(
i
snapshot
[
"
dual_labeled_counter
"
]
[
"
telemetry
.
dual_labeled_counter
"
]
[
&
key
]
[
&
category
]
)
;
}
assert_eq
!
(
40
snapshot
[
"
dual_labeled_counter
"
]
[
"
telemetry
.
dual_labeled_counter
"
]
[
"
__other__
"
]
[
"
__other__
"
]
)
;
}
}
#
[
test
]
fn
caching_metrics_with_dynamic_labels
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
let
metrics
=
(
1
.
.
=
20
)
.
map
(
|
i
|
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
let
category
=
format
!
(
"
category
{
i
}
"
)
;
dual_labeled_counter
.
get
(
key
category
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
for
metric
in
metrics
{
metric
.
add_sync
(
&
glean
1
)
;
}
let
other
=
dual_labeled_counter
.
get
(
"
__other__
"
"
__other__
"
)
;
assert_eq
!
(
Some
(
4
)
other
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
}
#
[
test
]
fn
metrics_with_static_keys_and_dynamic_categories
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
Some
(
vec
!
[
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
key1
"
)
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
key2
"
)
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
key3
"
)
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
key4
"
)
]
)
None
)
;
let
mut
metrics
:
Vec
<
std
:
:
sync
:
:
Arc
<
CounterMetric
>
>
=
Vec
:
:
new
(
)
;
for
i
in
1
.
.
=
5
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
for
j
in
1
.
.
=
20
{
let
category
=
format
!
(
"
category
{
j
}
"
)
;
metrics
.
push
(
dual_labeled_counter
.
get
(
&
key
&
category
)
)
;
}
}
for
metric
in
metrics
{
metric
.
add_sync
(
&
glean
1
)
;
}
for
i
in
1
.
.
=
5
{
let
other
=
dual_labeled_counter
.
get
(
format
!
(
"
key
{
i
}
"
)
"
__other__
"
.
into
(
)
)
;
let
recorded_value
=
other
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
;
assert_eq
!
(
Some
(
4
)
recorded_value
"
Other
value
should
be
4
found
{
recorded_value
:
?
}
for
key
{
i
}
"
)
;
}
let
other
=
dual_labeled_counter
.
get
(
"
__other__
"
.
to_string
(
)
"
__other__
"
.
to_string
(
)
)
;
let
recorded_value
=
other
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
;
assert_eq
!
(
Some
(
4
)
recorded_value
"
Other
value
should
be
4
found
{
recorded_value
:
?
}
"
)
;
}
#
[
test
]
fn
metrics_with_dynamic_keys_and_static_categories
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
Some
(
vec
!
[
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
category1
"
)
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
category2
"
)
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
category3
"
)
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
"
category4
"
)
]
)
)
;
let
mut
metrics
:
Vec
<
std
:
:
sync
:
:
Arc
<
CounterMetric
>
>
=
Vec
:
:
new
(
)
;
for
i
in
1
.
.
=
20
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
for
j
in
1
.
.
=
5
{
let
category
=
format
!
(
"
category
{
j
}
"
)
;
metrics
.
push
(
dual_labeled_counter
.
get
(
&
key
&
category
)
)
;
}
}
for
metric
in
metrics
{
metric
.
add_sync
(
&
glean
1
)
;
}
for
i
in
1
.
.
=
16
{
for
j
in
1
.
.
=
4
{
let
metric
=
dual_labeled_counter
.
get
(
format
!
(
"
key
{
i
}
"
)
format
!
(
"
category
{
j
}
"
)
)
;
let
recorded_value
=
metric
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
;
assert_eq
!
(
Some
(
1
)
recorded_value
"
Value
should
be
1
found
{
recorded_value
:
?
}
for
key
{
i
}
/
category
{
j
}
"
)
;
}
let
metric
=
dual_labeled_counter
.
get
(
format
!
(
"
key
{
i
}
"
)
"
__other__
"
.
to_string
(
)
)
;
let
recorded_value
=
metric
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
;
assert_eq
!
(
Some
(
1
)
recorded_value
"
Value
should
be
1
found
{
recorded_value
:
?
}
for
key
{
i
}
/
__other__
"
)
;
}
for
i
in
1
.
.
=
4
{
let
metric
=
dual_labeled_counter
.
get
(
"
__other__
"
.
into
(
)
format
!
(
"
category
{
i
}
"
)
)
;
let
recorded_value
=
metric
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
;
assert_eq
!
(
Some
(
4
)
recorded_value
"
Value
should
be
4
found
{
recorded_value
:
?
}
for
__other__
/
category
{
i
}
"
)
;
}
let
metric
=
dual_labeled_counter
.
get
(
"
__other__
"
"
__other__
"
)
;
let
recorded_value
=
metric
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
;
assert_eq
!
(
Some
(
4
)
recorded_value
"
Value
should
be
4
found
{
recorded_value
:
?
}
for
__other__
/
__other__
"
)
;
}
#
[
test
]
fn
caching_metrics_with_dynamic_labels_across_pings
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
let
metrics
=
(
1
.
.
=
20
)
.
map
(
|
i
|
{
let
key
=
format
!
(
"
key
{
i
}
"
)
;
let
category
=
format
!
(
"
category
{
i
}
"
)
;
dual_labeled_counter
.
get
(
key
category
)
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
for
metric
in
&
metrics
{
metric
.
add_sync
(
&
glean
1
)
;
}
let
other
=
dual_labeled_counter
.
get
(
"
__other__
"
"
__other__
"
)
;
assert_eq
!
(
Some
(
4
)
other
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
null
)
snapshot
[
"
dual_labeled_counter
"
]
[
"
telemetry
.
dual_labeled_counter
"
]
[
"
key20
"
]
[
"
category20
"
]
)
;
metrics
[
16
]
.
add_sync
(
&
glean
17
)
;
metrics
[
17
]
.
add_sync
(
&
glean
18
)
;
metrics
[
18
]
.
add_sync
(
&
glean
19
)
;
metrics
[
19
]
.
add_sync
(
&
glean
20
)
;
assert_eq
!
(
Some
(
17
)
metrics
[
16
]
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
assert_eq
!
(
Some
(
18
)
metrics
[
17
]
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
assert_eq
!
(
Some
(
19
)
metrics
[
18
]
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
assert_eq
!
(
Some
(
20
)
metrics
[
19
]
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
assert_eq
!
(
None
other
.
get_value
(
&
glean
Some
(
"
store1
"
)
)
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
let
cached_labels
=
&
snapshot
[
"
dual_labeled_counter
"
]
[
"
telemetry
.
dual_labeled_counter
"
]
;
assert_eq
!
(
json
!
(
17
)
cached_labels
[
"
key17
"
]
[
"
category17
"
]
)
;
assert_eq
!
(
json
!
(
18
)
cached_labels
[
"
key18
"
]
[
"
category18
"
]
)
;
assert_eq
!
(
json
!
(
19
)
cached_labels
[
"
key19
"
]
[
"
category19
"
]
)
;
assert_eq
!
(
json
!
(
20
)
cached_labels
[
"
key20
"
]
[
"
category20
"
]
)
;
assert_eq
!
(
json
!
(
null
)
cached_labels
[
"
__other__
"
]
[
"
__other__
"
]
)
;
}
#
[
test
]
fn
labels_containing_a_record_separator_record_an_error
(
)
{
let
(
glean
_t
)
=
new_glean
(
None
)
;
let
dual_labeled_counter
=
DualLabeledCounterMetric
:
:
new
(
CommonMetricData
{
name
:
"
dual_labeled_counter
"
.
into
(
)
category
:
"
telemetry
"
.
into
(
)
send_in_pings
:
vec
!
[
"
store1
"
.
into
(
)
]
disabled
:
false
lifetime
:
Lifetime
:
:
Ping
.
.
Default
:
:
default
(
)
}
None
None
)
;
let
metric
=
dual_labeled_counter
.
get
(
"
record
\
x1eseparator
"
"
category1
"
)
;
metric
.
add_sync
(
&
glean
1
)
;
let
snapshot
=
StorageManager
.
snapshot_as_json
(
glean
.
storage
(
)
"
store1
"
true
)
.
unwrap
(
)
;
assert_eq
!
(
json
!
(
{
"
dual_labeled_counter
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
{
"
__other__
"
:
{
"
__other__
"
:
1
}
}
}
"
labeled_counter
"
:
{
"
glean
.
error
.
invalid_label
"
:
{
"
telemetry
.
dual_labeled_counter
"
:
1
}
}
}
)
snapshot
)
;
}
