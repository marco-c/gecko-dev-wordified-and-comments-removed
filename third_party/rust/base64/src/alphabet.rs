use
crate
:
:
PAD_BYTE
;
use
core
:
:
fmt
;
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
use
std
:
:
error
;
const
ALPHABET_SIZE
:
usize
=
64
;
#
[
derive
(
Clone
Debug
Eq
PartialEq
)
]
pub
struct
Alphabet
{
pub
(
crate
)
symbols
:
[
u8
;
ALPHABET_SIZE
]
}
impl
Alphabet
{
const
fn
from_str_unchecked
(
alphabet
:
&
str
)
-
>
Self
{
let
mut
symbols
=
[
0_u8
;
ALPHABET_SIZE
]
;
let
source_bytes
=
alphabet
.
as_bytes
(
)
;
let
mut
index
=
0
;
while
index
<
ALPHABET_SIZE
{
symbols
[
index
]
=
source_bytes
[
index
]
;
index
+
=
1
;
}
Self
{
symbols
}
}
pub
const
fn
new
(
alphabet
:
&
str
)
-
>
Result
<
Self
ParseAlphabetError
>
{
let
bytes
=
alphabet
.
as_bytes
(
)
;
if
bytes
.
len
(
)
!
=
ALPHABET_SIZE
{
return
Err
(
ParseAlphabetError
:
:
InvalidLength
)
;
}
{
let
mut
index
=
0
;
while
index
<
ALPHABET_SIZE
{
let
byte
=
bytes
[
index
]
;
if
!
(
byte
>
=
32_u8
&
&
byte
<
=
126_u8
)
{
return
Err
(
ParseAlphabetError
:
:
UnprintableByte
(
byte
)
)
;
}
if
byte
=
=
PAD_BYTE
{
return
Err
(
ParseAlphabetError
:
:
ReservedByte
(
byte
)
)
;
}
let
mut
probe_index
=
0
;
while
probe_index
<
ALPHABET_SIZE
{
if
probe_index
=
=
index
{
probe_index
+
=
1
;
continue
;
}
let
probe_byte
=
bytes
[
probe_index
]
;
if
byte
=
=
probe_byte
{
return
Err
(
ParseAlphabetError
:
:
DuplicatedByte
(
byte
)
)
;
}
probe_index
+
=
1
;
}
index
+
=
1
;
}
}
Ok
(
Self
:
:
from_str_unchecked
(
alphabet
)
)
}
}
impl
TryFrom
<
&
str
>
for
Alphabet
{
type
Error
=
ParseAlphabetError
;
fn
try_from
(
value
:
&
str
)
-
>
Result
<
Self
Self
:
:
Error
>
{
Self
:
:
new
(
value
)
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
pub
enum
ParseAlphabetError
{
InvalidLength
DuplicatedByte
(
u8
)
UnprintableByte
(
u8
)
ReservedByte
(
u8
)
}
impl
fmt
:
:
Display
for
ParseAlphabetError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
self
{
Self
:
:
InvalidLength
=
>
write
!
(
f
"
Invalid
length
-
must
be
64
bytes
"
)
Self
:
:
DuplicatedByte
(
b
)
=
>
write
!
(
f
"
Duplicated
byte
:
{
:
#
04x
}
"
b
)
Self
:
:
UnprintableByte
(
b
)
=
>
write
!
(
f
"
Unprintable
byte
:
{
:
#
04x
}
"
b
)
Self
:
:
ReservedByte
(
b
)
=
>
write
!
(
f
"
Reserved
byte
:
{
:
#
04x
}
"
b
)
}
}
}
#
[
cfg
(
any
(
feature
=
"
std
"
test
)
)
]
impl
error
:
:
Error
for
ParseAlphabetError
{
}
pub
const
STANDARD
:
Alphabet
=
Alphabet
:
:
from_str_unchecked
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
)
;
pub
const
URL_SAFE
:
Alphabet
=
Alphabet
:
:
from_str_unchecked
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
-
_
"
)
;
pub
const
CRYPT
:
Alphabet
=
Alphabet
:
:
from_str_unchecked
(
"
.
/
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
"
)
;
pub
const
BCRYPT
:
Alphabet
=
Alphabet
:
:
from_str_unchecked
(
"
.
/
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
"
)
;
pub
const
IMAP_MUTF7
:
Alphabet
=
Alphabet
:
:
from_str_unchecked
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
"
)
;
pub
const
BIN_HEX
:
Alphabet
=
Alphabet
:
:
from_str_unchecked
(
"
!
\
"
#
%
&
'
(
)
*
+
-
0123456789
ABCDEFGHIJKLMNPQRSTUVXYZ
[
abcdehijklmpqr
"
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
alphabet
:
:
*
;
use
std
:
:
convert
:
:
TryFrom
as
_
;
#
[
test
]
fn
detects_duplicate_start
(
)
{
assert_eq
!
(
ParseAlphabetError
:
:
DuplicatedByte
(
b
'
A
'
)
Alphabet
:
:
new
(
"
AACDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
detects_duplicate_end
(
)
{
assert_eq
!
(
ParseAlphabetError
:
:
DuplicatedByte
(
b
'
/
'
)
Alphabet
:
:
new
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
/
/
"
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
detects_duplicate_middle
(
)
{
assert_eq
!
(
ParseAlphabetError
:
:
DuplicatedByte
(
b
'
Z
'
)
Alphabet
:
:
new
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZZbcdefghijklmnopqrstuvwxyz0123456789
+
/
"
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
detects_length
(
)
{
assert_eq
!
(
ParseAlphabetError
:
:
InvalidLength
Alphabet
:
:
new
(
"
xxxxxxxxxABCDEFGHIJKLMNOPQRSTUVWXYZZbcdefghijklmnopqrstuvwxyz0123456789
+
/
"
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
detects_padding
(
)
{
assert_eq
!
(
ParseAlphabetError
:
:
ReservedByte
(
b
'
=
'
)
Alphabet
:
:
new
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
=
"
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
detects_unprintable
(
)
{
assert_eq
!
(
ParseAlphabetError
:
:
UnprintableByte
(
0xc
)
Alphabet
:
:
new
(
"
\
x0cBCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
)
.
unwrap_err
(
)
)
;
}
#
[
test
]
fn
same_as_unchecked
(
)
{
assert_eq
!
(
STANDARD
Alphabet
:
:
try_from
(
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
)
.
unwrap
(
)
)
;
}
}
