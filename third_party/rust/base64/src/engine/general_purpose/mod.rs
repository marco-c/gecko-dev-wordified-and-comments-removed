use
crate
:
:
{
alphabet
alphabet
:
:
Alphabet
engine
:
:
{
Config
DecodeMetadata
DecodePaddingMode
}
DecodeSliceError
}
;
use
core
:
:
convert
:
:
TryInto
;
pub
(
crate
)
mod
decode
;
pub
(
crate
)
mod
decode_suffix
;
pub
use
decode
:
:
GeneralPurposeEstimate
;
pub
(
crate
)
const
INVALID_VALUE
:
u8
=
255
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
GeneralPurpose
{
encode_table
:
[
u8
;
64
]
decode_table
:
[
u8
;
256
]
config
:
GeneralPurposeConfig
}
impl
GeneralPurpose
{
pub
const
fn
new
(
alphabet
:
&
Alphabet
config
:
GeneralPurposeConfig
)
-
>
Self
{
Self
{
encode_table
:
encode_table
(
alphabet
)
decode_table
:
decode_table
(
alphabet
)
config
}
}
}
impl
super
:
:
Engine
for
GeneralPurpose
{
type
Config
=
GeneralPurposeConfig
;
type
DecodeEstimate
=
GeneralPurposeEstimate
;
fn
internal_encode
(
&
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
)
-
>
usize
{
let
mut
input_index
:
usize
=
0
;
const
BLOCKS_PER_FAST_LOOP
:
usize
=
4
;
const
LOW_SIX_BITS
:
u64
=
0x3F
;
let
last_fast_index
=
input
.
len
(
)
.
saturating_sub
(
BLOCKS_PER_FAST_LOOP
*
6
+
2
)
;
let
mut
output_index
=
0
;
if
last_fast_index
>
0
{
while
input_index
<
=
last_fast_index
{
let
input_chunk
=
&
input
[
input_index
.
.
(
input_index
+
(
BLOCKS_PER_FAST_LOOP
*
6
+
2
)
)
]
;
let
output_chunk
=
&
mut
output
[
output_index
.
.
(
output_index
+
BLOCKS_PER_FAST_LOOP
*
8
)
]
;
let
input_u64
=
read_u64
(
&
input_chunk
[
0
.
.
]
)
;
output_chunk
[
0
]
=
self
.
encode_table
[
(
(
input_u64
>
>
58
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
1
]
=
self
.
encode_table
[
(
(
input_u64
>
>
52
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
2
]
=
self
.
encode_table
[
(
(
input_u64
>
>
46
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
3
]
=
self
.
encode_table
[
(
(
input_u64
>
>
40
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
4
]
=
self
.
encode_table
[
(
(
input_u64
>
>
34
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
5
]
=
self
.
encode_table
[
(
(
input_u64
>
>
28
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
6
]
=
self
.
encode_table
[
(
(
input_u64
>
>
22
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
7
]
=
self
.
encode_table
[
(
(
input_u64
>
>
16
)
&
LOW_SIX_BITS
)
as
usize
]
;
let
input_u64
=
read_u64
(
&
input_chunk
[
6
.
.
]
)
;
output_chunk
[
8
]
=
self
.
encode_table
[
(
(
input_u64
>
>
58
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
9
]
=
self
.
encode_table
[
(
(
input_u64
>
>
52
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
10
]
=
self
.
encode_table
[
(
(
input_u64
>
>
46
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
11
]
=
self
.
encode_table
[
(
(
input_u64
>
>
40
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
12
]
=
self
.
encode_table
[
(
(
input_u64
>
>
34
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
13
]
=
self
.
encode_table
[
(
(
input_u64
>
>
28
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
14
]
=
self
.
encode_table
[
(
(
input_u64
>
>
22
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
15
]
=
self
.
encode_table
[
(
(
input_u64
>
>
16
)
&
LOW_SIX_BITS
)
as
usize
]
;
let
input_u64
=
read_u64
(
&
input_chunk
[
12
.
.
]
)
;
output_chunk
[
16
]
=
self
.
encode_table
[
(
(
input_u64
>
>
58
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
17
]
=
self
.
encode_table
[
(
(
input_u64
>
>
52
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
18
]
=
self
.
encode_table
[
(
(
input_u64
>
>
46
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
19
]
=
self
.
encode_table
[
(
(
input_u64
>
>
40
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
20
]
=
self
.
encode_table
[
(
(
input_u64
>
>
34
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
21
]
=
self
.
encode_table
[
(
(
input_u64
>
>
28
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
22
]
=
self
.
encode_table
[
(
(
input_u64
>
>
22
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
23
]
=
self
.
encode_table
[
(
(
input_u64
>
>
16
)
&
LOW_SIX_BITS
)
as
usize
]
;
let
input_u64
=
read_u64
(
&
input_chunk
[
18
.
.
]
)
;
output_chunk
[
24
]
=
self
.
encode_table
[
(
(
input_u64
>
>
58
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
25
]
=
self
.
encode_table
[
(
(
input_u64
>
>
52
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
26
]
=
self
.
encode_table
[
(
(
input_u64
>
>
46
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
27
]
=
self
.
encode_table
[
(
(
input_u64
>
>
40
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
28
]
=
self
.
encode_table
[
(
(
input_u64
>
>
34
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
29
]
=
self
.
encode_table
[
(
(
input_u64
>
>
28
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
30
]
=
self
.
encode_table
[
(
(
input_u64
>
>
22
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_chunk
[
31
]
=
self
.
encode_table
[
(
(
input_u64
>
>
16
)
&
LOW_SIX_BITS
)
as
usize
]
;
output_index
+
=
BLOCKS_PER_FAST_LOOP
*
8
;
input_index
+
=
BLOCKS_PER_FAST_LOOP
*
6
;
}
}
const
LOW_SIX_BITS_U8
:
u8
=
0x3F
;
let
rem
=
input
.
len
(
)
%
3
;
let
start_of_rem
=
input
.
len
(
)
-
rem
;
while
input_index
<
start_of_rem
{
let
input_chunk
=
&
input
[
input_index
.
.
(
input_index
+
3
)
]
;
let
output_chunk
=
&
mut
output
[
output_index
.
.
(
output_index
+
4
)
]
;
output_chunk
[
0
]
=
self
.
encode_table
[
(
input_chunk
[
0
]
>
>
2
)
as
usize
]
;
output_chunk
[
1
]
=
self
.
encode_table
[
(
(
input_chunk
[
0
]
<
<
4
|
input_chunk
[
1
]
>
>
4
)
&
LOW_SIX_BITS_U8
)
as
usize
]
;
output_chunk
[
2
]
=
self
.
encode_table
[
(
(
input_chunk
[
1
]
<
<
2
|
input_chunk
[
2
]
>
>
6
)
&
LOW_SIX_BITS_U8
)
as
usize
]
;
output_chunk
[
3
]
=
self
.
encode_table
[
(
input_chunk
[
2
]
&
LOW_SIX_BITS_U8
)
as
usize
]
;
input_index
+
=
3
;
output_index
+
=
4
;
}
if
rem
=
=
2
{
output
[
output_index
]
=
self
.
encode_table
[
(
input
[
start_of_rem
]
>
>
2
)
as
usize
]
;
output
[
output_index
+
1
]
=
self
.
encode_table
[
(
(
input
[
start_of_rem
]
<
<
4
|
input
[
start_of_rem
+
1
]
>
>
4
)
&
LOW_SIX_BITS_U8
)
as
usize
]
;
output
[
output_index
+
2
]
=
self
.
encode_table
[
(
(
input
[
start_of_rem
+
1
]
<
<
2
)
&
LOW_SIX_BITS_U8
)
as
usize
]
;
output_index
+
=
3
;
}
else
if
rem
=
=
1
{
output
[
output_index
]
=
self
.
encode_table
[
(
input
[
start_of_rem
]
>
>
2
)
as
usize
]
;
output
[
output_index
+
1
]
=
self
.
encode_table
[
(
(
input
[
start_of_rem
]
<
<
4
)
&
LOW_SIX_BITS_U8
)
as
usize
]
;
output_index
+
=
2
;
}
output_index
}
fn
internal_decoded_len_estimate
(
&
self
input_len
:
usize
)
-
>
Self
:
:
DecodeEstimate
{
GeneralPurposeEstimate
:
:
new
(
input_len
)
}
fn
internal_decode
(
&
self
input
:
&
[
u8
]
output
:
&
mut
[
u8
]
estimate
:
Self
:
:
DecodeEstimate
)
-
>
Result
<
DecodeMetadata
DecodeSliceError
>
{
decode
:
:
decode_helper
(
input
estimate
output
&
self
.
decode_table
self
.
config
.
decode_allow_trailing_bits
self
.
config
.
decode_padding_mode
)
}
fn
config
(
&
self
)
-
>
&
Self
:
:
Config
{
&
self
.
config
}
}
pub
(
crate
)
const
fn
encode_table
(
alphabet
:
&
Alphabet
)
-
>
[
u8
;
64
]
{
let
mut
encode_table
=
[
0_u8
;
64
]
;
{
let
mut
index
=
0
;
while
index
<
64
{
encode_table
[
index
]
=
alphabet
.
symbols
[
index
]
;
index
+
=
1
;
}
}
encode_table
}
pub
(
crate
)
const
fn
decode_table
(
alphabet
:
&
Alphabet
)
-
>
[
u8
;
256
]
{
let
mut
decode_table
=
[
INVALID_VALUE
;
256
]
;
let
mut
index
=
0
;
while
index
<
64
{
decode_table
[
alphabet
.
symbols
[
index
]
as
usize
]
=
index
as
u8
;
index
+
=
1
;
}
decode_table
}
#
[
inline
]
fn
read_u64
(
s
:
&
[
u8
]
)
-
>
u64
{
u64
:
:
from_be_bytes
(
s
[
.
.
8
]
.
try_into
(
)
.
unwrap
(
)
)
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
GeneralPurposeConfig
{
encode_padding
:
bool
decode_allow_trailing_bits
:
bool
decode_padding_mode
:
DecodePaddingMode
}
impl
GeneralPurposeConfig
{
pub
const
fn
new
(
)
-
>
Self
{
Self
{
encode_padding
:
true
decode_allow_trailing_bits
:
false
decode_padding_mode
:
DecodePaddingMode
:
:
RequireCanonical
}
}
pub
const
fn
with_encode_padding
(
self
padding
:
bool
)
-
>
Self
{
Self
{
encode_padding
:
padding
.
.
self
}
}
pub
const
fn
with_decode_allow_trailing_bits
(
self
allow
:
bool
)
-
>
Self
{
Self
{
decode_allow_trailing_bits
:
allow
.
.
self
}
}
pub
const
fn
with_decode_padding_mode
(
self
mode
:
DecodePaddingMode
)
-
>
Self
{
Self
{
decode_padding_mode
:
mode
.
.
self
}
}
}
impl
Default
for
GeneralPurposeConfig
{
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
Config
for
GeneralPurposeConfig
{
fn
encode_padding
(
&
self
)
-
>
bool
{
self
.
encode_padding
}
}
pub
const
STANDARD
:
GeneralPurpose
=
GeneralPurpose
:
:
new
(
&
alphabet
:
:
STANDARD
PAD
)
;
pub
const
STANDARD_NO_PAD
:
GeneralPurpose
=
GeneralPurpose
:
:
new
(
&
alphabet
:
:
STANDARD
NO_PAD
)
;
pub
const
URL_SAFE
:
GeneralPurpose
=
GeneralPurpose
:
:
new
(
&
alphabet
:
:
URL_SAFE
PAD
)
;
pub
const
URL_SAFE_NO_PAD
:
GeneralPurpose
=
GeneralPurpose
:
:
new
(
&
alphabet
:
:
URL_SAFE
NO_PAD
)
;
pub
const
PAD
:
GeneralPurposeConfig
=
GeneralPurposeConfig
:
:
new
(
)
;
pub
const
NO_PAD
:
GeneralPurposeConfig
=
GeneralPurposeConfig
:
:
new
(
)
.
with_encode_padding
(
false
)
.
with_decode_padding_mode
(
DecodePaddingMode
:
:
RequireNone
)
;
