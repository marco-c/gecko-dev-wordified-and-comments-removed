use
crate
:
:
{
engine
:
:
{
general_purpose
:
:
INVALID_VALUE
DecodeEstimate
DecodePaddingMode
}
DecodeError
PAD_BYTE
}
;
const
INPUT_CHUNK_LEN
:
usize
=
8
;
const
DECODED_CHUNK_LEN
:
usize
=
6
;
const
DECODED_CHUNK_SUFFIX
:
usize
=
2
;
const
CHUNKS_PER_FAST_LOOP_BLOCK
:
usize
=
4
;
const
INPUT_BLOCK_LEN
:
usize
=
CHUNKS_PER_FAST_LOOP_BLOCK
*
INPUT_CHUNK_LEN
;
const
DECODED_BLOCK_LEN
:
usize
=
CHUNKS_PER_FAST_LOOP_BLOCK
*
DECODED_CHUNK_LEN
+
DECODED_CHUNK_SUFFIX
;
#
[
doc
(
hidden
)
]
pub
struct
GeneralPurposeEstimate
{
num_chunks
:
usize
decoded_len_estimate
:
usize
}
impl
GeneralPurposeEstimate
{
pub
(
crate
)
fn
new
(
encoded_len
:
usize
)
-
>
Self
{
Self
{
num_chunks
:
encoded_len
.
checked_add
(
INPUT_CHUNK_LEN
-
1
)
.
expect
(
"
Overflow
when
calculating
number
of
chunks
in
input
"
)
/
INPUT_CHUNK_LEN
decoded_len_estimate
:
encoded_len
.
checked_add
(
3
)
.
expect
(
"
Overflow
when
calculating
decoded
len
estimate
"
)
/
4
*
3
}
}
}
impl
DecodeEstimate
for
GeneralPurposeEstimate
{
fn
decoded_len_estimate
(
&
self
)
-
>
usize
{
self
.
decoded_len_estimate
}
}
#
[
inline
]
pub
(
crate
)
fn
decode_helper
(
input
:
&
[
u8
]
estimate
:
GeneralPurposeEstimate
output
:
&
mut
[
u8
]
decode_table
:
&
[
u8
;
256
]
decode_allow_trailing_bits
:
bool
padding_mode
:
DecodePaddingMode
)
-
>
Result
<
usize
DecodeError
>
{
let
remainder_len
=
input
.
len
(
)
%
INPUT_CHUNK_LEN
;
let
trailing_bytes_to_skip
=
match
remainder_len
{
0
=
>
INPUT_CHUNK_LEN
1
|
5
=
>
{
if
let
Some
(
b
)
=
input
.
last
(
)
{
if
*
b
!
=
PAD_BYTE
&
&
decode_table
[
*
b
as
usize
]
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
input
.
len
(
)
-
1
*
b
)
)
;
}
}
return
Err
(
DecodeError
:
:
InvalidLength
)
;
}
2
=
>
INPUT_CHUNK_LEN
+
2
3
=
>
INPUT_CHUNK_LEN
+
3
4
=
>
INPUT_CHUNK_LEN
+
4
_
=
>
remainder_len
}
;
let
mut
remaining_chunks
=
estimate
.
num_chunks
;
let
mut
input_index
=
0
;
let
mut
output_index
=
0
;
{
let
length_of_fast_decode_chunks
=
input
.
len
(
)
.
saturating_sub
(
trailing_bytes_to_skip
)
;
if
let
Some
(
max_start_index
)
=
length_of_fast_decode_chunks
.
checked_sub
(
INPUT_BLOCK_LEN
)
{
while
input_index
<
=
max_start_index
{
let
input_slice
=
&
input
[
input_index
.
.
(
input_index
+
INPUT_BLOCK_LEN
)
]
;
let
output_slice
=
&
mut
output
[
output_index
.
.
(
output_index
+
DECODED_BLOCK_LEN
)
]
;
decode_chunk
(
&
input_slice
[
0
.
.
]
input_index
decode_table
&
mut
output_slice
[
0
.
.
]
)
?
;
decode_chunk
(
&
input_slice
[
8
.
.
]
input_index
+
8
decode_table
&
mut
output_slice
[
6
.
.
]
)
?
;
decode_chunk
(
&
input_slice
[
16
.
.
]
input_index
+
16
decode_table
&
mut
output_slice
[
12
.
.
]
)
?
;
decode_chunk
(
&
input_slice
[
24
.
.
]
input_index
+
24
decode_table
&
mut
output_slice
[
18
.
.
]
)
?
;
input_index
+
=
INPUT_BLOCK_LEN
;
output_index
+
=
DECODED_BLOCK_LEN
-
DECODED_CHUNK_SUFFIX
;
remaining_chunks
-
=
CHUNKS_PER_FAST_LOOP_BLOCK
;
}
}
if
let
Some
(
max_start_index
)
=
length_of_fast_decode_chunks
.
checked_sub
(
INPUT_CHUNK_LEN
)
{
while
input_index
<
max_start_index
{
decode_chunk
(
&
input
[
input_index
.
.
(
input_index
+
INPUT_CHUNK_LEN
)
]
input_index
decode_table
&
mut
output
[
output_index
.
.
(
output_index
+
DECODED_CHUNK_LEN
+
DECODED_CHUNK_SUFFIX
)
]
)
?
;
output_index
+
=
DECODED_CHUNK_LEN
;
input_index
+
=
INPUT_CHUNK_LEN
;
remaining_chunks
-
=
1
;
}
}
}
for
_
in
1
.
.
remaining_chunks
{
decode_chunk_precise
(
&
input
[
input_index
.
.
]
input_index
decode_table
&
mut
output
[
output_index
.
.
(
output_index
+
DECODED_CHUNK_LEN
)
]
)
?
;
input_index
+
=
INPUT_CHUNK_LEN
;
output_index
+
=
DECODED_CHUNK_LEN
;
}
debug_assert
!
(
input
.
len
(
)
-
input_index
>
1
|
|
input
.
is_empty
(
)
)
;
debug_assert
!
(
input
.
len
(
)
-
input_index
<
=
8
)
;
super
:
:
decode_suffix
:
:
decode_suffix
(
input
input_index
output
output_index
decode_table
decode_allow_trailing_bits
padding_mode
)
}
#
[
inline
(
always
)
]
fn
decode_chunk
(
input
:
&
[
u8
]
index_at_start_of_input
:
usize
decode_table
:
&
[
u8
;
256
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
DecodeError
>
{
let
morsel
=
decode_table
[
input
[
0
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
input
[
0
]
)
)
;
}
let
mut
accum
=
(
morsel
as
u64
)
<
<
58
;
let
morsel
=
decode_table
[
input
[
1
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
1
input
[
1
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
52
;
let
morsel
=
decode_table
[
input
[
2
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
2
input
[
2
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
46
;
let
morsel
=
decode_table
[
input
[
3
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
3
input
[
3
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
40
;
let
morsel
=
decode_table
[
input
[
4
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
4
input
[
4
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
34
;
let
morsel
=
decode_table
[
input
[
5
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
5
input
[
5
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
28
;
let
morsel
=
decode_table
[
input
[
6
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
6
input
[
6
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
22
;
let
morsel
=
decode_table
[
input
[
7
]
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
index_at_start_of_input
+
7
input
[
7
]
)
)
;
}
accum
|
=
(
morsel
as
u64
)
<
<
16
;
write_u64
(
output
accum
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
decode_chunk_precise
(
input
:
&
[
u8
]
index_at_start_of_input
:
usize
decode_table
:
&
[
u8
;
256
]
output
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
DecodeError
>
{
let
mut
tmp_buf
=
[
0_u8
;
8
]
;
decode_chunk
(
input
index_at_start_of_input
decode_table
&
mut
tmp_buf
[
.
.
]
)
?
;
output
[
0
.
.
6
]
.
copy_from_slice
(
&
tmp_buf
[
0
.
.
6
]
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
write_u64
(
output
:
&
mut
[
u8
]
value
:
u64
)
{
output
[
.
.
8
]
.
copy_from_slice
(
&
value
.
to_be_bytes
(
)
)
;
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
engine
:
:
general_purpose
:
:
STANDARD
;
#
[
test
]
fn
decode_chunk_precise_writes_only_6_bytes
(
)
{
let
input
=
b
"
Zm9vYmFy
"
;
let
mut
output
=
[
0_u8
1
2
3
4
5
6
7
]
;
decode_chunk_precise
(
&
input
[
.
.
]
0
&
STANDARD
.
decode_table
&
mut
output
)
.
unwrap
(
)
;
assert_eq
!
(
&
vec
!
[
b
'
f
'
b
'
o
'
b
'
o
'
b
'
b
'
b
'
a
'
b
'
r
'
6
7
]
&
output
)
;
}
#
[
test
]
fn
decode_chunk_writes_8_bytes
(
)
{
let
input
=
b
"
Zm9vYmFy
"
;
let
mut
output
=
[
0_u8
1
2
3
4
5
6
7
]
;
decode_chunk
(
&
input
[
.
.
]
0
&
STANDARD
.
decode_table
&
mut
output
)
.
unwrap
(
)
;
assert_eq
!
(
&
vec
!
[
b
'
f
'
b
'
o
'
b
'
o
'
b
'
b
'
b
'
a
'
b
'
r
'
0
0
]
&
output
)
;
}
}
