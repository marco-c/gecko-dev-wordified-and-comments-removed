use
crate
:
:
{
engine
:
:
{
general_purpose
:
:
INVALID_VALUE
DecodePaddingMode
}
DecodeError
PAD_BYTE
}
;
pub
(
crate
)
fn
decode_suffix
(
input
:
&
[
u8
]
input_index
:
usize
output
:
&
mut
[
u8
]
mut
output_index
:
usize
decode_table
:
&
[
u8
;
256
]
decode_allow_trailing_bits
:
bool
padding_mode
:
DecodePaddingMode
)
-
>
Result
<
usize
DecodeError
>
{
let
mut
leftover_bits
:
u64
=
0
;
let
mut
morsels_in_leftover
=
0
;
let
mut
padding_bytes
=
0
;
let
mut
first_padding_index
:
usize
=
0
;
let
mut
last_symbol
=
0_u8
;
let
start_of_leftovers
=
input_index
;
for
(
i
&
b
)
in
input
[
start_of_leftovers
.
.
]
.
iter
(
)
.
enumerate
(
)
{
if
b
=
=
PAD_BYTE
{
if
i
%
4
<
2
{
let
bad_padding_index
=
start_of_leftovers
+
if
padding_bytes
>
0
{
first_padding_index
}
else
{
i
}
;
return
Err
(
DecodeError
:
:
InvalidByte
(
bad_padding_index
b
)
)
;
}
if
padding_bytes
=
=
0
{
first_padding_index
=
i
;
}
padding_bytes
+
=
1
;
continue
;
}
if
padding_bytes
>
0
{
return
Err
(
DecodeError
:
:
InvalidByte
(
start_of_leftovers
+
first_padding_index
PAD_BYTE
)
)
;
}
last_symbol
=
b
;
let
shift
=
64
-
(
morsels_in_leftover
+
1
)
*
6
;
let
morsel
=
decode_table
[
b
as
usize
]
;
if
morsel
=
=
INVALID_VALUE
{
return
Err
(
DecodeError
:
:
InvalidByte
(
start_of_leftovers
+
i
b
)
)
;
}
leftover_bits
|
=
(
morsel
as
u64
)
<
<
shift
;
morsels_in_leftover
+
=
1
;
}
match
padding_mode
{
DecodePaddingMode
:
:
Indifferent
=
>
{
}
DecodePaddingMode
:
:
RequireCanonical
=
>
{
if
(
padding_bytes
+
morsels_in_leftover
)
%
4
!
=
0
{
return
Err
(
DecodeError
:
:
InvalidPadding
)
;
}
}
DecodePaddingMode
:
:
RequireNone
=
>
{
if
padding_bytes
>
0
{
return
Err
(
DecodeError
:
:
InvalidPadding
)
;
}
}
}
let
leftover_bits_ready_to_append
=
match
morsels_in_leftover
{
0
=
>
0
2
=
>
8
3
=
>
16
4
=
>
24
6
=
>
32
7
=
>
40
8
=
>
48
_
=
>
unreachable
!
(
"
Impossible
:
must
only
have
0
to
8
input
bytes
in
last
chunk
with
no
invalid
lengths
"
)
}
;
let
mask
=
!
0
>
>
leftover_bits_ready_to_append
;
if
!
decode_allow_trailing_bits
&
&
(
leftover_bits
&
mask
)
!
=
0
{
return
Err
(
DecodeError
:
:
InvalidLastSymbol
(
start_of_leftovers
+
morsels_in_leftover
-
1
last_symbol
)
)
;
}
let
mut
leftover_bits_appended_to_buf
=
0
;
while
leftover_bits_appended_to_buf
<
leftover_bits_ready_to_append
{
let
selected_bits
=
(
leftover_bits
>
>
(
56
-
leftover_bits_appended_to_buf
)
)
as
u8
;
output
[
output_index
]
=
selected_bits
;
output_index
+
=
1
;
leftover_bits_appended_to_buf
+
=
8
;
}
Ok
(
output_index
)
}
