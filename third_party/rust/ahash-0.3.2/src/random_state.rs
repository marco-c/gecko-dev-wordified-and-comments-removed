use
crate
:
:
AHasher
;
use
core
:
:
hash
:
:
BuildHasher
;
use
core
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
core
:
:
sync
:
:
atomic
:
:
Ordering
;
#
[
cfg
(
feature
=
"
compile
-
time
-
rng
"
)
]
use
const_random
:
:
const_random
;
pub
(
crate
)
const
MULTIPLE
:
u64
=
6364136223846793005
;
#
[
cfg
(
feature
=
"
compile
-
time
-
rng
"
)
]
static
SEED
:
AtomicUsize
=
AtomicUsize
:
:
new
(
const_random
!
(
u64
)
)
;
#
[
cfg
(
not
(
feature
=
"
compile
-
time
-
rng
"
)
)
]
static
SEED
:
AtomicUsize
=
AtomicUsize
:
:
new
(
MULTIPLE
as
usize
)
;
#
[
derive
(
Clone
)
]
pub
struct
RandomState
{
pub
(
crate
)
k0
:
u64
pub
(
crate
)
k1
:
u64
}
impl
RandomState
{
#
[
inline
]
pub
fn
new
(
)
-
>
RandomState
{
let
previous
=
SEED
.
load
(
Ordering
:
:
Relaxed
)
as
u64
;
let
stack_mem_loc
=
&
previous
as
*
const
_
as
u64
;
let
current_seed
=
previous
.
wrapping_mul
(
MULTIPLE
)
.
wrapping_add
(
stack_mem_loc
)
.
rotate_left
(
31
)
;
SEED
.
store
(
current_seed
as
usize
Ordering
:
:
Relaxed
)
;
let
(
k0
k1
)
=
scramble_keys
(
&
SEED
as
*
const
_
as
u64
current_seed
)
;
RandomState
{
k0
k1
}
}
}
pub
(
crate
)
fn
scramble_keys
(
k0
:
u64
k1
:
u64
)
-
>
(
u64
u64
)
{
let
result1
=
k0
.
wrapping_add
(
k1
)
;
let
k1
=
k1
^
k0
;
let
k0
=
k0
.
rotate_left
(
24
)
^
k1
^
(
k1
.
wrapping_shl
(
16
)
)
;
let
result2
=
k0
.
wrapping_add
(
k1
.
rotate_left
(
37
)
)
;
(
result2
result1
)
}
impl
Default
for
RandomState
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
impl
BuildHasher
for
RandomState
{
type
Hasher
=
AHasher
;
#
[
inline
]
fn
build_hasher
(
&
self
)
-
>
AHasher
{
AHasher
:
:
new_with_keys
(
self
.
k0
self
.
k1
)
}
}
