use
std
:
:
fmt
;
use
crate
:
:
{
capitalize
lowercase
transform
}
;
pub
trait
ToLowerCamelCase
:
ToOwned
{
fn
to_lower_camel_case
(
&
self
)
-
>
Self
:
:
Owned
;
}
impl
ToLowerCamelCase
for
str
{
fn
to_lower_camel_case
(
&
self
)
-
>
String
{
AsLowerCamelCase
(
self
)
.
to_string
(
)
}
}
pub
struct
AsLowerCamelCase
<
T
:
AsRef
<
str
>
>
(
pub
T
)
;
impl
<
T
:
AsRef
<
str
>
>
fmt
:
:
Display
for
AsLowerCamelCase
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
first
=
true
;
transform
(
self
.
0
.
as_ref
(
)
|
s
f
|
{
if
first
{
first
=
false
;
lowercase
(
s
f
)
}
else
{
capitalize
(
s
f
)
}
}
|
_
|
Ok
(
(
)
)
f
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
ToLowerCamelCase
;
macro_rules
!
t
{
(
t
:
ident
:
s1
:
expr
=
>
s2
:
expr
)
=
>
{
#
[
test
]
fn
t
(
)
{
assert_eq
!
(
s1
.
to_lower_camel_case
(
)
s2
)
}
}
;
}
t
!
(
test1
:
"
CamelCase
"
=
>
"
camelCase
"
)
;
t
!
(
test2
:
"
This
is
Human
case
.
"
=
>
"
thisIsHumanCase
"
)
;
t
!
(
test3
:
"
MixedUP
CamelCase
with
some
Spaces
"
=
>
"
mixedUpCamelCaseWithSomeSpaces
"
)
;
t
!
(
test4
:
"
mixed_up_
snake_case
with
some
_spaces
"
=
>
"
mixedUpSnakeCaseWithSomeSpaces
"
)
;
t
!
(
test5
:
"
kebab
-
case
"
=
>
"
kebabCase
"
)
;
t
!
(
test6
:
"
SHOUTY_SNAKE_CASE
"
=
>
"
shoutySnakeCase
"
)
;
t
!
(
test7
:
"
snake_case
"
=
>
"
snakeCase
"
)
;
t
!
(
test8
:
"
this
-
contains_
ALLKinds
OfWord_Boundaries
"
=
>
"
thisContainsAllKindsOfWordBoundaries
"
)
;
#
[
cfg
(
feature
=
"
unicode
"
)
]
t
!
(
test9
:
"
X
X
ba
e
"
=
>
"
x
x
Ba
e
"
)
;
t
!
(
test10
:
"
XMLHttpRequest
"
=
>
"
xmlHttpRequest
"
)
;
}
