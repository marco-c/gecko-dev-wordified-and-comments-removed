#
!
[
deny
(
missing_docs
)
]
#
!
[
forbid
(
unsafe_code
)
]
mod
kebab
;
mod
lower_camel
;
mod
shouty_kebab
;
mod
shouty_snake
;
mod
snake
;
mod
title
;
mod
train
;
mod
upper_camel
;
pub
use
kebab
:
:
{
AsKebabCase
ToKebabCase
}
;
pub
use
lower_camel
:
:
{
AsLowerCamelCase
ToLowerCamelCase
}
;
pub
use
shouty_kebab
:
:
{
AsShoutyKebabCase
ToShoutyKebabCase
}
;
pub
use
shouty_snake
:
:
{
AsShoutySnakeCase
AsShoutySnakeCase
as
AsShoutySnekCase
ToShoutySnakeCase
ToShoutySnekCase
}
;
pub
use
snake
:
:
{
AsSnakeCase
AsSnakeCase
as
AsSnekCase
ToSnakeCase
ToSnekCase
}
;
pub
use
title
:
:
{
AsTitleCase
ToTitleCase
}
;
pub
use
train
:
:
{
AsTrainCase
ToTrainCase
}
;
pub
use
upper_camel
:
:
{
AsUpperCamelCase
AsUpperCamelCase
as
AsPascalCase
ToPascalCase
ToUpperCamelCase
}
;
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
unicode
"
)
]
fn
get_iterator
(
s
:
&
str
)
-
>
unicode_segmentation
:
:
UnicodeWords
{
use
unicode_segmentation
:
:
UnicodeSegmentation
;
s
.
unicode_words
(
)
}
#
[
cfg
(
not
(
feature
=
"
unicode
"
)
)
]
fn
get_iterator
(
s
:
&
str
)
-
>
impl
Iterator
<
Item
=
&
str
>
{
s
.
split
(
|
letter
:
char
|
!
letter
.
is_ascii_alphanumeric
(
)
)
}
fn
transform
<
F
G
>
(
s
:
&
str
mut
with_word
:
F
mut
boundary
:
G
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
where
F
:
FnMut
(
&
str
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
G
:
FnMut
(
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
#
[
derive
(
Clone
Copy
PartialEq
)
]
enum
WordMode
{
Boundary
Lowercase
Uppercase
}
let
mut
first_word
=
true
;
for
word
in
get_iterator
(
s
)
{
let
mut
char_indices
=
word
.
char_indices
(
)
.
peekable
(
)
;
let
mut
init
=
0
;
let
mut
mode
=
WordMode
:
:
Boundary
;
while
let
Some
(
(
i
c
)
)
=
char_indices
.
next
(
)
{
if
c
=
=
'
_
'
{
if
init
=
=
i
{
init
+
=
1
;
}
continue
;
}
if
let
Some
(
&
(
next_i
next
)
)
=
char_indices
.
peek
(
)
{
let
next_mode
=
if
c
.
is_lowercase
(
)
{
WordMode
:
:
Lowercase
}
else
if
c
.
is_uppercase
(
)
{
WordMode
:
:
Uppercase
}
else
{
mode
}
;
if
next
=
=
'
_
'
|
|
(
next_mode
=
=
WordMode
:
:
Lowercase
&
&
next
.
is_uppercase
(
)
)
{
if
!
first_word
{
boundary
(
f
)
?
;
}
with_word
(
&
word
[
init
.
.
next_i
]
f
)
?
;
first_word
=
false
;
init
=
next_i
;
mode
=
WordMode
:
:
Boundary
;
}
else
if
mode
=
=
WordMode
:
:
Uppercase
&
&
c
.
is_uppercase
(
)
&
&
next
.
is_lowercase
(
)
{
if
!
first_word
{
boundary
(
f
)
?
;
}
else
{
first_word
=
false
;
}
with_word
(
&
word
[
init
.
.
i
]
f
)
?
;
init
=
i
;
mode
=
WordMode
:
:
Boundary
;
}
else
{
mode
=
next_mode
;
}
}
else
{
if
!
first_word
{
boundary
(
f
)
?
;
}
else
{
first_word
=
false
;
}
with_word
(
&
word
[
init
.
.
]
f
)
?
;
break
;
}
}
}
Ok
(
(
)
)
}
fn
lowercase
(
s
:
&
str
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
chars
=
s
.
chars
(
)
.
peekable
(
)
;
while
let
Some
(
c
)
=
chars
.
next
(
)
{
if
c
=
=
'
'
&
&
chars
.
peek
(
)
.
is_none
(
)
{
write
!
(
f
"
"
)
?
;
}
else
{
write
!
(
f
"
{
}
"
c
.
to_lowercase
(
)
)
?
;
}
}
Ok
(
(
)
)
}
fn
uppercase
(
s
:
&
str
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
for
c
in
s
.
chars
(
)
{
write
!
(
f
"
{
}
"
c
.
to_uppercase
(
)
)
?
;
}
Ok
(
(
)
)
}
fn
capitalize
(
s
:
&
str
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
mut
char_indices
=
s
.
char_indices
(
)
;
if
let
Some
(
(
_
c
)
)
=
char_indices
.
next
(
)
{
write
!
(
f
"
{
}
"
c
.
to_uppercase
(
)
)
?
;
if
let
Some
(
(
i
_
)
)
=
char_indices
.
next
(
)
{
lowercase
(
&
s
[
i
.
.
]
f
)
?
;
}
}
Ok
(
(
)
)
}
