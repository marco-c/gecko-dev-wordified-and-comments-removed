#
!
[
cfg_attr
(
all
(
feature
=
"
nightly
"
test
)
feature
(
test
)
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
drop_types_in_const
)
)
]
#
!
[
cfg_attr
(
all
(
feature
=
"
nightly
"
test
)
feature
(
core_intrinsics
)
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
const_fn
)
)
]
#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
const_unsafe_cell_new
)
)
]
#
!
[
warn
(
missing_docs
)
]
#
[
macro_use
]
#
[
cfg
(
test
)
]
extern
crate
lazy_static
;
use
std
:
:
thread
:
:
{
self
JoinHandle
}
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
Receiver
SyncSender
sync_channel
RecvError
}
;
use
std
:
:
sync
:
:
{
Arc
Mutex
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
enum
Message
{
NewJob
(
Thunk
<
'
static
>
)
Join
}
trait
FnBox
{
fn
call_box
(
self
:
Box
<
Self
>
)
;
}
impl
<
F
:
FnOnce
(
)
>
FnBox
for
F
{
fn
call_box
(
self
:
Box
<
F
>
)
{
(
*
self
)
(
)
}
}
type
Thunk
<
'
a
>
=
Box
<
FnBox
+
Send
+
'
a
>
;
impl
Drop
for
Pool
{
fn
drop
(
&
mut
self
)
{
self
.
job_sender
=
None
;
}
}
pub
struct
Pool
{
threads
:
Vec
<
ThreadData
>
job_sender
:
Option
<
Sender
<
Message
>
>
}
struct
ThreadData
{
_thread_join_handle
:
JoinHandle
<
(
)
>
pool_sync_rx
:
Receiver
<
(
)
>
thread_sync_tx
:
SyncSender
<
(
)
>
}
impl
Pool
{
pub
fn
new
(
n
:
u32
)
-
>
Pool
{
assert
!
(
n
>
=
1
)
;
let
(
job_sender
job_receiver
)
=
channel
(
)
;
let
job_receiver
=
Arc
:
:
new
(
Mutex
:
:
new
(
job_receiver
)
)
;
let
mut
threads
=
Vec
:
:
with_capacity
(
n
as
usize
)
;
for
_
in
0
.
.
n
{
let
job_receiver
=
job_receiver
.
clone
(
)
;
let
(
pool_sync_tx
pool_sync_rx
)
=
sync_channel
:
:
<
(
)
>
(
0
)
;
let
(
thread_sync_tx
thread_sync_rx
)
=
sync_channel
:
:
<
(
)
>
(
0
)
;
let
thread
=
thread
:
:
spawn
(
move
|
|
{
loop
{
let
message
=
{
let
lock
=
job_receiver
.
lock
(
)
.
unwrap
(
)
;
lock
.
recv
(
)
}
;
match
message
{
Ok
(
Message
:
:
NewJob
(
job
)
)
=
>
{
job
.
call_box
(
)
;
}
Ok
(
Message
:
:
Join
)
=
>
{
if
pool_sync_tx
.
send
(
(
)
)
.
is_err
(
)
{
break
;
}
if
thread_sync_rx
.
recv
(
)
.
is_err
(
)
{
break
;
}
}
Err
(
.
.
)
=
>
{
break
}
}
}
}
)
;
threads
.
push
(
ThreadData
{
_thread_join_handle
:
thread
pool_sync_rx
:
pool_sync_rx
thread_sync_tx
:
thread_sync_tx
}
)
;
}
Pool
{
threads
:
threads
job_sender
:
Some
(
job_sender
)
}
}
pub
fn
scoped
<
'
pool
'
scope
F
R
>
(
&
'
pool
mut
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
Scope
<
'
pool
'
scope
>
)
-
>
R
{
let
scope
=
Scope
{
pool
:
self
_marker
:
PhantomData
}
;
f
(
&
scope
)
}
pub
fn
thread_count
(
&
self
)
-
>
u32
{
self
.
threads
.
len
(
)
as
u32
}
}
pub
struct
Scope
<
'
pool
'
scope
>
{
pool
:
&
'
pool
mut
Pool
_marker
:
PhantomData
<
:
:
std
:
:
cell
:
:
Cell
<
&
'
scope
mut
(
)
>
>
}
impl
<
'
pool
'
scope
>
Scope
<
'
pool
'
scope
>
{
pub
fn
execute
<
F
>
(
&
self
f
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
scope
{
self
.
execute_
(
f
)
}
fn
execute_
<
F
>
(
&
self
f
:
F
)
where
F
:
FnOnce
(
)
+
Send
+
'
scope
{
let
b
=
unsafe
{
mem
:
:
transmute
:
:
<
Thunk
<
'
scope
>
Thunk
<
'
static
>
>
(
Box
:
:
new
(
f
)
)
}
;
self
.
pool
.
job_sender
.
as_ref
(
)
.
unwrap
(
)
.
send
(
Message
:
:
NewJob
(
b
)
)
.
unwrap
(
)
;
}
pub
fn
join_all
(
&
self
)
{
for
_
in
0
.
.
self
.
pool
.
threads
.
len
(
)
{
self
.
pool
.
job_sender
.
as_ref
(
)
.
unwrap
(
)
.
send
(
Message
:
:
Join
)
.
unwrap
(
)
;
}
let
mut
worker_panic
=
false
;
for
thread_data
in
&
self
.
pool
.
threads
{
if
let
Err
(
RecvError
)
=
thread_data
.
pool_sync_rx
.
recv
(
)
{
worker_panic
=
true
;
}
}
if
worker_panic
{
panic
!
(
"
Thread
pool
worker
panicked
"
)
;
}
for
thread_data
in
&
self
.
pool
.
threads
{
thread_data
.
thread_sync_tx
.
send
(
(
)
)
.
unwrap
(
)
;
}
}
}
impl
<
'
pool
'
scope
>
Drop
for
Scope
<
'
pool
'
scope
>
{
fn
drop
(
&
mut
self
)
{
self
.
join_all
(
)
;
}
}
#
[
cfg
(
test
)
]
mod
tests
{
#
!
[
cfg_attr
(
feature
=
"
nightly
"
allow
(
unused_unsafe
)
)
]
use
super
:
:
Pool
;
use
std
:
:
thread
;
use
std
:
:
sync
;
use
std
:
:
time
;
fn
sleep_ms
(
ms
:
u64
)
{
thread
:
:
sleep
(
time
:
:
Duration
:
:
from_millis
(
ms
)
)
;
}
#
[
test
]
fn
smoketest
(
)
{
let
mut
pool
=
Pool
:
:
new
(
4
)
;
for
i
in
1
.
.
7
{
let
mut
vec
=
vec
!
[
0
1
2
3
4
]
;
pool
.
scoped
(
|
s
|
{
for
e
in
vec
.
iter_mut
(
)
{
s
.
execute
(
move
|
|
{
*
e
+
=
i
;
}
)
;
}
}
)
;
let
mut
vec2
=
vec
!
[
0
1
2
3
4
]
;
for
e
in
vec2
.
iter_mut
(
)
{
*
e
+
=
i
;
}
assert_eq
!
(
vec
vec2
)
;
}
}
#
[
test
]
#
[
should_panic
]
fn
thread_panic
(
)
{
let
mut
pool
=
Pool
:
:
new
(
4
)
;
pool
.
scoped
(
|
scoped
|
{
scoped
.
execute
(
move
|
|
{
panic
!
(
)
}
)
;
}
)
;
}
#
[
test
]
#
[
should_panic
]
fn
scope_panic
(
)
{
let
mut
pool
=
Pool
:
:
new
(
4
)
;
pool
.
scoped
(
|
_scoped
|
{
panic
!
(
)
}
)
;
}
#
[
test
]
#
[
should_panic
]
fn
pool_panic
(
)
{
let
_pool
=
Pool
:
:
new
(
4
)
;
panic
!
(
)
}
#
[
test
]
fn
join_all
(
)
{
let
mut
pool
=
Pool
:
:
new
(
4
)
;
let
(
tx_
rx
)
=
sync
:
:
mpsc
:
:
channel
(
)
;
pool
.
scoped
(
|
scoped
|
{
let
tx
=
tx_
.
clone
(
)
;
scoped
.
execute
(
move
|
|
{
sleep_ms
(
1000
)
;
tx
.
send
(
2
)
.
unwrap
(
)
;
}
)
;
let
tx
=
tx_
.
clone
(
)
;
scoped
.
execute
(
move
|
|
{
tx
.
send
(
1
)
.
unwrap
(
)
;
}
)
;
scoped
.
join_all
(
)
;
let
tx
=
tx_
.
clone
(
)
;
scoped
.
execute
(
move
|
|
{
tx
.
send
(
3
)
.
unwrap
(
)
;
}
)
;
}
)
;
assert_eq
!
(
rx
.
iter
(
)
.
take
(
3
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
vec
!
[
1
2
3
]
)
;
}
#
[
test
]
fn
join_all_with_thread_panic
(
)
{
use
std
:
:
sync
:
:
mpsc
:
:
Sender
;
struct
OnScopeEnd
(
Sender
<
u8
>
)
;
impl
Drop
for
OnScopeEnd
{
fn
drop
(
&
mut
self
)
{
self
.
0
.
send
(
1
)
.
unwrap
(
)
;
sleep_ms
(
200
)
;
}
}
let
(
tx_
rx
)
=
sync
:
:
mpsc
:
:
channel
(
)
;
let
handle
=
thread
:
:
spawn
(
move
|
|
{
let
mut
pool
=
Pool
:
:
new
(
8
)
;
let
_on_scope_end
=
OnScopeEnd
(
tx_
.
clone
(
)
)
;
pool
.
scoped
(
|
scoped
|
{
scoped
.
execute
(
move
|
|
{
sleep_ms
(
100
)
;
panic
!
(
)
;
}
)
;
for
_
in
1
.
.
8
{
let
tx
=
tx_
.
clone
(
)
;
scoped
.
execute
(
move
|
|
{
sleep_ms
(
200
)
;
tx
.
send
(
0
)
.
unwrap
(
)
;
}
)
;
}
}
)
;
}
)
;
if
let
Ok
(
.
.
)
=
handle
.
join
(
)
{
panic
!
(
"
Pool
didn
'
t
panic
as
expected
"
)
;
}
let
values
:
Vec
<
u8
>
=
rx
.
into_iter
(
)
.
collect
(
)
;
assert_eq
!
(
&
values
[
.
.
]
&
[
0
0
0
0
0
0
0
1
]
)
;
}
#
[
test
]
fn
safe_execute
(
)
{
let
mut
pool
=
Pool
:
:
new
(
4
)
;
pool
.
scoped
(
|
scoped
|
{
scoped
.
execute
(
move
|
|
{
}
)
;
}
)
;
}
}
#
[
cfg
(
all
(
test
feature
=
"
nightly
"
)
)
]
mod
benches
{
extern
crate
test
;
use
self
:
:
test
:
:
{
Bencher
black_box
}
;
use
super
:
:
Pool
;
use
std
:
:
sync
:
:
Mutex
;
lazy_static
!
{
static
ref
POOL_1
:
Mutex
<
Pool
>
=
Mutex
:
:
new
(
Pool
:
:
new
(
1
)
)
;
static
ref
POOL_2
:
Mutex
<
Pool
>
=
Mutex
:
:
new
(
Pool
:
:
new
(
2
)
)
;
static
ref
POOL_3
:
Mutex
<
Pool
>
=
Mutex
:
:
new
(
Pool
:
:
new
(
3
)
)
;
static
ref
POOL_4
:
Mutex
<
Pool
>
=
Mutex
:
:
new
(
Pool
:
:
new
(
4
)
)
;
static
ref
POOL_5
:
Mutex
<
Pool
>
=
Mutex
:
:
new
(
Pool
:
:
new
(
5
)
)
;
static
ref
POOL_8
:
Mutex
<
Pool
>
=
Mutex
:
:
new
(
Pool
:
:
new
(
8
)
)
;
}
fn
fib
(
n
:
u64
)
-
>
u64
{
let
mut
prev_prev
:
u64
=
1
;
let
mut
prev
=
1
;
let
mut
current
=
1
;
for
_
in
2
.
.
(
n
+
1
)
{
current
=
prev_prev
.
wrapping_add
(
prev
)
;
prev_prev
=
prev
;
prev
=
current
;
}
current
}
fn
threads_interleaved_n
(
pool
:
&
mut
Pool
)
{
let
size
=
1024
;
let
mut
data
=
vec
!
[
1u8
;
size
]
;
pool
.
scoped
(
|
s
|
{
for
e
in
data
.
iter_mut
(
)
{
s
.
execute
(
move
|
|
{
*
e
+
=
fib
(
black_box
(
1000
*
(
*
e
as
u64
)
)
)
as
u8
;
for
i
in
0
.
.
10000
{
black_box
(
i
)
;
}
}
)
;
}
}
)
;
}
#
[
bench
]
fn
threads_interleaved_1
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_interleaved_n
(
&
mut
POOL_1
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_interleaved_2
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_interleaved_n
(
&
mut
POOL_2
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_interleaved_4
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_interleaved_n
(
&
mut
POOL_4
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_interleaved_8
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_interleaved_n
(
&
mut
POOL_8
.
lock
(
)
.
unwrap
(
)
)
)
}
fn
threads_chunked_n
(
pool
:
&
mut
Pool
)
{
let
size
=
1024
*
1024
*
10
/
4
;
let
bb_repeat
=
50
;
let
n
=
pool
.
thread_count
(
)
;
let
mut
data
=
vec
!
[
0u32
;
size
]
;
pool
.
scoped
(
|
s
|
{
let
l
=
(
data
.
len
(
)
-
1
)
/
n
as
usize
+
1
;
for
es
in
data
.
chunks_mut
(
l
)
{
s
.
execute
(
move
|
|
{
if
es
.
len
(
)
>
1
{
es
[
0
]
=
1
;
es
[
1
]
=
1
;
for
i
in
2
.
.
es
.
len
(
)
{
es
[
i
]
=
black_box
(
es
[
i
-
1
]
.
wrapping_add
(
es
[
i
-
2
]
)
)
;
for
i
in
0
.
.
bb_repeat
{
black_box
(
i
)
;
}
}
}
}
)
;
}
}
)
;
}
#
[
bench
]
fn
threads_chunked_1
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_chunked_n
(
&
mut
POOL_1
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_chunked_2
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_chunked_n
(
&
mut
POOL_2
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_chunked_3
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_chunked_n
(
&
mut
POOL_3
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_chunked_4
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_chunked_n
(
&
mut
POOL_4
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_chunked_5
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_chunked_n
(
&
mut
POOL_5
.
lock
(
)
.
unwrap
(
)
)
)
}
#
[
bench
]
fn
threads_chunked_8
(
b
:
&
mut
Bencher
)
{
b
.
iter
(
|
|
threads_chunked_n
(
&
mut
POOL_8
.
lock
(
)
.
unwrap
(
)
)
)
}
}
