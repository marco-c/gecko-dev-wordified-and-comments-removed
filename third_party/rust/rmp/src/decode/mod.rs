mod
dec
;
mod
ext
;
mod
sint
;
mod
str
;
mod
uint
;
pub
use
self
:
:
dec
:
:
{
read_f32
read_f64
}
;
pub
use
self
:
:
ext
:
:
{
read_ext_meta
read_fixext1
read_fixext16
read_fixext2
read_fixext4
read_fixext8
ExtMeta
}
;
pub
use
self
:
:
sint
:
:
{
read_i16
read_i32
read_i64
read_i8
read_nfix
}
;
#
[
allow
(
deprecated
)
]
pub
use
self
:
:
str
:
:
{
read_str
read_str_from_slice
read_str_len
read_str_ref
DecodeStringError
}
;
pub
use
self
:
:
uint
:
:
{
read_pfix
read_u16
read_u32
read_u64
read_u8
}
;
use
core
:
:
fmt
:
:
{
self
Debug
Display
Formatter
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
error
;
use
num_traits
:
:
cast
:
:
FromPrimitive
;
use
crate
:
:
Marker
;
pub
mod
bytes
;
pub
use
bytes
:
:
Bytes
;
#
[
doc
(
inline
)
]
#
[
allow
(
deprecated
)
]
pub
use
crate
:
:
errors
:
:
Error
;
pub
trait
RmpReadErr
:
Display
+
Debug
+
crate
:
:
errors
:
:
MaybeErrBound
+
'
static
{
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
RmpReadErr
for
std
:
:
io
:
:
Error
{
}
impl
RmpReadErr
for
core
:
:
convert
:
:
Infallible
{
}
macro_rules
!
read_byteorder_utils
{
(
(
name
:
ident
=
>
tp
:
ident
)
*
(
)
?
)
=
>
{
(
#
[
inline
]
#
[
doc
(
hidden
)
]
fn
name
(
&
mut
self
)
-
>
Result
<
tp
ValueReadError
<
Self
:
:
Error
>
>
where
Self
:
Sized
{
const
SIZE
:
usize
=
core
:
:
mem
:
:
size_of
:
:
<
tp
>
(
)
;
let
mut
buf
:
[
u8
;
SIZE
]
=
[
0u8
;
SIZE
]
;
self
.
read_exact_buf
(
&
mut
buf
)
.
map_err
(
ValueReadError
:
:
InvalidDataRead
)
?
;
Ok
(
paste
:
:
paste
!
{
<
byteorder
:
:
BigEndian
as
byteorder
:
:
ByteOrder
>
:
:
[
<
read_
tp
>
]
(
&
mut
buf
)
}
)
}
)
*
}
;
}
mod
sealed
{
pub
trait
Sealed
{
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
T
:
?
Sized
+
std
:
:
io
:
:
Read
>
Sealed
for
T
{
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
impl
<
'
a
>
Sealed
for
&
'
a
[
u8
]
{
}
impl
Sealed
for
super
:
:
Bytes
<
'
_
>
{
}
}
pub
trait
RmpRead
:
sealed
:
:
Sealed
{
type
Error
:
RmpReadErr
;
#
[
inline
]
fn
read_u8
(
&
mut
self
)
-
>
Result
<
u8
Self
:
:
Error
>
{
let
mut
buf
=
[
0
;
1
]
;
self
.
read_exact_buf
(
&
mut
buf
)
?
;
Ok
(
buf
[
0
]
)
}
fn
read_exact_buf
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
#
[
inline
]
#
[
doc
(
hidden
)
]
fn
read_data_u8
(
&
mut
self
)
-
>
Result
<
u8
ValueReadError
<
Self
:
:
Error
>
>
{
self
.
read_u8
(
)
.
map_err
(
ValueReadError
:
:
InvalidDataRead
)
}
#
[
inline
]
#
[
doc
(
hidden
)
]
fn
read_data_i8
(
&
mut
self
)
-
>
Result
<
i8
ValueReadError
<
Self
:
:
Error
>
>
{
self
.
read_data_u8
(
)
.
map
(
|
b
|
b
as
i8
)
}
read_byteorder_utils
!
(
read_data_u16
=
>
u16
read_data_u32
=
>
u32
read_data_u64
=
>
u64
read_data_i16
=
>
i16
read_data_i32
=
>
i32
read_data_i64
=
>
i64
read_data_f32
=
>
f32
read_data_f64
=
>
f64
)
;
}
macro_rules
!
wrap_data_funcs_for_compatibility
{
(
(
tp
:
ident
)
*
(
)
?
)
=
>
{
(
paste
:
:
paste
!
{
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
doc
(
hidden
)
]
#
[
deprecated
(
note
=
"
internal
function
.
rmpv
&
rmp
-
serde
need
to
switch
to
RmpRead
"
)
]
pub
fn
[
<
read_data_
tp
>
]
<
R
:
std
:
:
io
:
:
Read
>
(
buf
:
&
mut
R
)
-
>
Result
<
tp
ValueReadError
>
{
buf
.
[
<
read_data_
tp
>
]
(
)
}
}
)
*
}
;
}
wrap_data_funcs_for_compatibility
!
(
u8
u16
u32
u64
i8
i16
i32
i64
f32
f64
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
T
:
std
:
:
io
:
:
Read
>
RmpRead
for
T
{
type
Error
=
std
:
:
io
:
:
Error
;
#
[
inline
]
fn
read_exact_buf
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
std
:
:
io
:
:
Read
:
:
read_exact
(
self
buf
)
}
}
struct
MarkerWriteError
<
E
:
RmpReadErr
>
(
E
)
;
impl
<
E
:
RmpReadErr
>
From
<
E
>
for
MarkerWriteError
<
E
>
{
#
[
cold
]
fn
from
(
err
:
E
)
-
>
Self
{
MarkerWriteError
(
err
)
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
deprecated
)
]
pub
struct
MarkerReadError
<
E
:
RmpReadErr
=
Error
>
(
pub
E
)
;
#
[
derive
(
Debug
)
]
#
[
allow
(
deprecated
)
]
pub
enum
ValueReadError
<
E
:
RmpReadErr
=
Error
>
{
InvalidMarkerRead
(
E
)
InvalidDataRead
(
E
)
TypeMismatch
(
Marker
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
error
:
:
Error
for
ValueReadError
{
#
[
cold
]
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
match
*
self
{
ValueReadError
:
:
InvalidMarkerRead
(
ref
err
)
|
ValueReadError
:
:
InvalidDataRead
(
ref
err
)
=
>
Some
(
err
)
ValueReadError
:
:
TypeMismatch
(
.
.
)
=
>
None
}
}
}
impl
Display
for
ValueReadError
{
#
[
cold
]
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
f
.
write_str
(
match
*
self
{
ValueReadError
:
:
InvalidMarkerRead
(
.
.
)
=
>
"
failed
to
read
MessagePack
marker
"
ValueReadError
:
:
InvalidDataRead
(
.
.
)
=
>
"
failed
to
read
MessagePack
data
"
ValueReadError
:
:
TypeMismatch
(
.
.
)
=
>
{
"
the
type
decoded
isn
'
t
match
with
the
expected
one
"
}
}
)
}
}
impl
<
E
:
RmpReadErr
>
From
<
MarkerReadError
<
E
>
>
for
ValueReadError
<
E
>
{
#
[
cold
]
fn
from
(
err
:
MarkerReadError
<
E
>
)
-
>
ValueReadError
<
E
>
{
match
err
{
MarkerReadError
(
err
)
=
>
ValueReadError
:
:
InvalidMarkerRead
(
err
)
}
}
}
impl
<
E
:
RmpReadErr
>
From
<
E
>
for
MarkerReadError
<
E
>
{
#
[
cold
]
fn
from
(
err
:
E
)
-
>
MarkerReadError
<
E
>
{
MarkerReadError
(
err
)
}
}
#
[
inline
]
pub
fn
read_marker
<
R
:
RmpRead
>
(
rd
:
&
mut
R
)
-
>
Result
<
Marker
MarkerReadError
<
R
:
:
Error
>
>
{
Ok
(
Marker
:
:
from_u8
(
rd
.
read_u8
(
)
?
)
)
}
pub
fn
read_nil
<
R
:
RmpRead
>
(
rd
:
&
mut
R
)
-
>
Result
<
(
)
ValueReadError
<
R
:
:
Error
>
>
{
match
read_marker
(
rd
)
?
{
Marker
:
:
Null
=
>
Ok
(
(
)
)
marker
=
>
Err
(
ValueReadError
:
:
TypeMismatch
(
marker
)
)
}
}
pub
fn
read_bool
<
R
:
RmpRead
>
(
rd
:
&
mut
R
)
-
>
Result
<
bool
ValueReadError
<
R
:
:
Error
>
>
{
match
read_marker
(
rd
)
?
{
Marker
:
:
True
=
>
Ok
(
true
)
Marker
:
:
False
=
>
Ok
(
false
)
marker
=
>
Err
(
ValueReadError
:
:
TypeMismatch
(
marker
)
)
}
}
#
[
derive
(
Debug
)
]
#
[
allow
(
deprecated
)
]
pub
enum
NumValueReadError
<
E
:
RmpReadErr
=
Error
>
{
InvalidMarkerRead
(
E
)
InvalidDataRead
(
E
)
TypeMismatch
(
Marker
)
OutOfRange
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
error
:
:
Error
for
NumValueReadError
{
fn
source
(
&
self
)
-
>
Option
<
&
(
dyn
error
:
:
Error
+
'
static
)
>
{
match
*
self
{
NumValueReadError
:
:
InvalidMarkerRead
(
ref
err
)
|
NumValueReadError
:
:
InvalidDataRead
(
ref
err
)
=
>
Some
(
err
)
NumValueReadError
:
:
TypeMismatch
(
.
.
)
|
NumValueReadError
:
:
OutOfRange
=
>
None
}
}
}
impl
<
E
:
RmpReadErr
>
Display
for
NumValueReadError
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
f
.
write_str
(
match
*
self
{
NumValueReadError
:
:
InvalidMarkerRead
(
.
.
)
=
>
"
failed
to
read
MessagePack
marker
"
NumValueReadError
:
:
InvalidDataRead
(
.
.
)
=
>
"
failed
to
read
MessagePack
data
"
NumValueReadError
:
:
TypeMismatch
(
.
.
)
=
>
{
"
the
type
decoded
isn
'
t
match
with
the
expected
one
"
}
NumValueReadError
:
:
OutOfRange
=
>
"
out
of
range
integral
type
conversion
attempted
"
}
)
}
}
impl
<
E
:
RmpReadErr
>
From
<
MarkerReadError
<
E
>
>
for
NumValueReadError
<
E
>
{
#
[
cold
]
fn
from
(
err
:
MarkerReadError
<
E
>
)
-
>
NumValueReadError
<
E
>
{
match
err
{
MarkerReadError
(
err
)
=
>
NumValueReadError
:
:
InvalidMarkerRead
(
err
)
}
}
}
impl
<
E
:
RmpReadErr
>
From
<
ValueReadError
<
E
>
>
for
NumValueReadError
<
E
>
{
#
[
cold
]
fn
from
(
err
:
ValueReadError
<
E
>
)
-
>
NumValueReadError
<
E
>
{
match
err
{
ValueReadError
:
:
InvalidMarkerRead
(
err
)
=
>
NumValueReadError
:
:
InvalidMarkerRead
(
err
)
ValueReadError
:
:
InvalidDataRead
(
err
)
=
>
NumValueReadError
:
:
InvalidDataRead
(
err
)
ValueReadError
:
:
TypeMismatch
(
err
)
=
>
NumValueReadError
:
:
TypeMismatch
(
err
)
}
}
}
pub
fn
read_int
<
T
:
FromPrimitive
R
:
RmpRead
>
(
rd
:
&
mut
R
)
-
>
Result
<
T
NumValueReadError
<
R
:
:
Error
>
>
{
let
val
=
match
read_marker
(
rd
)
?
{
Marker
:
:
FixPos
(
val
)
=
>
T
:
:
from_u8
(
val
)
Marker
:
:
FixNeg
(
val
)
=
>
T
:
:
from_i8
(
val
)
Marker
:
:
U8
=
>
T
:
:
from_u8
(
rd
.
read_data_u8
(
)
?
)
Marker
:
:
U16
=
>
T
:
:
from_u16
(
rd
.
read_data_u16
(
)
?
)
Marker
:
:
U32
=
>
T
:
:
from_u32
(
rd
.
read_data_u32
(
)
?
)
Marker
:
:
U64
=
>
T
:
:
from_u64
(
rd
.
read_data_u64
(
)
?
)
Marker
:
:
I8
=
>
T
:
:
from_i8
(
rd
.
read_data_i8
(
)
?
)
Marker
:
:
I16
=
>
T
:
:
from_i16
(
rd
.
read_data_i16
(
)
?
)
Marker
:
:
I32
=
>
T
:
:
from_i32
(
rd
.
read_data_i32
(
)
?
)
Marker
:
:
I64
=
>
T
:
:
from_i64
(
rd
.
read_data_i64
(
)
?
)
marker
=
>
return
Err
(
NumValueReadError
:
:
TypeMismatch
(
marker
)
)
}
;
val
.
ok_or
(
NumValueReadError
:
:
OutOfRange
)
}
pub
fn
read_array_len
<
R
>
(
rd
:
&
mut
R
)
-
>
Result
<
u32
ValueReadError
<
R
:
:
Error
>
>
where
R
:
RmpRead
{
match
read_marker
(
rd
)
?
{
Marker
:
:
FixArray
(
size
)
=
>
Ok
(
u32
:
:
from
(
size
)
)
Marker
:
:
Array16
=
>
Ok
(
u32
:
:
from
(
rd
.
read_data_u16
(
)
?
)
)
Marker
:
:
Array32
=
>
Ok
(
rd
.
read_data_u32
(
)
?
)
marker
=
>
Err
(
ValueReadError
:
:
TypeMismatch
(
marker
)
)
}
}
pub
fn
read_map_len
<
R
:
RmpRead
>
(
rd
:
&
mut
R
)
-
>
Result
<
u32
ValueReadError
<
R
:
:
Error
>
>
{
let
marker
=
read_marker
(
rd
)
?
;
marker_to_len
(
rd
marker
)
}
pub
fn
marker_to_len
<
R
:
RmpRead
>
(
rd
:
&
mut
R
marker
:
Marker
)
-
>
Result
<
u32
ValueReadError
<
R
:
:
Error
>
>
{
match
marker
{
Marker
:
:
FixMap
(
size
)
=
>
Ok
(
u32
:
:
from
(
size
)
)
Marker
:
:
Map16
=
>
Ok
(
u32
:
:
from
(
rd
.
read_data_u16
(
)
?
)
)
Marker
:
:
Map32
=
>
Ok
(
rd
.
read_data_u32
(
)
?
)
marker
=
>
Err
(
ValueReadError
:
:
TypeMismatch
(
marker
)
)
}
}
pub
fn
read_bin_len
<
R
:
RmpRead
>
(
rd
:
&
mut
R
)
-
>
Result
<
u32
ValueReadError
<
R
:
:
Error
>
>
{
match
read_marker
(
rd
)
?
{
Marker
:
:
Bin8
=
>
Ok
(
u32
:
:
from
(
rd
.
read_data_u8
(
)
?
)
)
Marker
:
:
Bin16
=
>
Ok
(
u32
:
:
from
(
rd
.
read_data_u16
(
)
?
)
)
Marker
:
:
Bin32
=
>
Ok
(
rd
.
read_data_u32
(
)
?
)
marker
=
>
Err
(
ValueReadError
:
:
TypeMismatch
(
marker
)
)
}
}
