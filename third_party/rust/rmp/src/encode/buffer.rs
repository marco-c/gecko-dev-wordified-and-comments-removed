use
super
:
:
RmpWrite
;
use
alloc
:
:
vec
:
:
Vec
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
use
core
:
:
fmt
:
:
{
self
Display
Formatter
}
;
#
[
derive
(
Debug
)
]
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
#
[
doc
(
hidden
)
]
pub
struct
FixedBufCapacityOverflow
{
_priv
:
(
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
doc
(
hidden
)
]
pub
type
FixedBufCapacityOverflow
=
std
:
:
io
:
:
Error
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
impl
Display
for
FixedBufCapacityOverflow
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
Capacity
overflow
for
fixed
-
size
byte
buffer
"
)
}
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
impl
crate
:
:
encode
:
:
RmpWriteErr
for
FixedBufCapacityOverflow
{
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
impl
<
'
a
>
RmpWrite
for
&
'
a
mut
[
u8
]
{
type
Error
=
FixedBufCapacityOverflow
;
#
[
inline
]
fn
write_bytes
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
let
to_write
=
buf
.
len
(
)
;
let
remaining
=
self
.
len
(
)
;
if
to_write
<
=
remaining
{
self
[
.
.
to_write
]
.
copy_from_slice
(
buf
)
;
unsafe
{
*
self
=
core
:
:
slice
:
:
from_raw_parts_mut
(
self
.
as_mut_ptr
(
)
.
add
(
to_write
)
remaining
-
to_write
)
}
Ok
(
(
)
)
}
else
{
Err
(
FixedBufCapacityOverflow
{
_priv
:
(
)
}
)
}
}
}
#
[
derive
(
Debug
Clone
Default
Eq
PartialEq
Hash
Ord
PartialOrd
)
]
pub
struct
ByteBuf
{
bytes
:
Vec
<
u8
>
}
impl
ByteBuf
{
#
[
inline
]
#
[
must_use
]
pub
fn
new
(
)
-
>
Self
{
ByteBuf
{
bytes
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
ByteBuf
{
bytes
:
Vec
:
:
with_capacity
(
capacity
)
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
into_vec
(
self
)
-
>
Vec
<
u8
>
{
self
.
bytes
}
#
[
inline
]
#
[
must_use
]
pub
fn
from_vec
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
ByteBuf
{
bytes
}
}
#
[
inline
]
#
[
must_use
]
pub
fn
as_vec
(
&
self
)
-
>
&
Vec
<
u8
>
{
&
self
.
bytes
}
#
[
inline
]
pub
fn
as_mut_vec
(
&
mut
self
)
-
>
&
mut
Vec
<
u8
>
{
&
mut
self
.
bytes
}
#
[
inline
]
#
[
must_use
]
pub
fn
as_slice
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
bytes
}
}
impl
AsRef
<
[
u8
]
>
for
ByteBuf
{
fn
as_ref
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
bytes
}
}
impl
AsRef
<
Vec
<
u8
>
>
for
ByteBuf
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
Vec
<
u8
>
{
&
self
.
bytes
}
}
impl
AsMut
<
Vec
<
u8
>
>
for
ByteBuf
{
#
[
inline
]
fn
as_mut
(
&
mut
self
)
-
>
&
mut
Vec
<
u8
>
{
&
mut
self
.
bytes
}
}
impl
From
<
ByteBuf
>
for
Vec
<
u8
>
{
#
[
inline
]
fn
from
(
buf
:
ByteBuf
)
-
>
Self
{
buf
.
bytes
}
}
impl
From
<
Vec
<
u8
>
>
for
ByteBuf
{
#
[
inline
]
fn
from
(
bytes
:
Vec
<
u8
>
)
-
>
Self
{
ByteBuf
{
bytes
}
}
}
impl
RmpWrite
for
ByteBuf
{
type
Error
=
core
:
:
convert
:
:
Infallible
;
#
[
inline
]
fn
write_u8
(
&
mut
self
val
:
u8
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
bytes
.
push
(
val
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
write_bytes
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
bytes
.
extend_from_slice
(
buf
)
;
Ok
(
(
)
)
}
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
impl
<
'
a
>
RmpWrite
for
Vec
<
u8
>
{
type
Error
=
core
:
:
convert
:
:
Infallible
;
#
[
inline
]
fn
write_u8
(
&
mut
self
val
:
u8
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
push
(
val
)
;
Ok
(
(
)
)
}
#
[
inline
]
fn
write_bytes
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
extend_from_slice
(
buf
)
;
Ok
(
(
)
)
}
}
