#
!
[
cfg
(
feature
=
"
alloc
"
)
]
use
num_traits
:
:
Float
;
use
crate
:
:
{
Distribution
Exp1
Gamma
Open01
StandardNormal
}
;
use
rand
:
:
Rng
;
use
core
:
:
fmt
;
use
alloc
:
:
{
boxed
:
:
Box
vec
vec
:
:
Vec
}
;
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
serde1
"
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
)
)
]
pub
struct
Dirichlet
<
F
>
where
F
:
Float
StandardNormal
:
Distribution
<
F
>
Exp1
:
Distribution
<
F
>
Open01
:
Distribution
<
F
>
{
alpha
:
Box
<
[
F
]
>
}
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
)
]
pub
enum
Error
{
AlphaTooShort
AlphaTooSmall
SizeTooSmall
}
impl
fmt
:
:
Display
for
Error
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
self
{
Error
:
:
AlphaTooShort
|
Error
:
:
SizeTooSmall
=
>
{
"
less
than
2
dimensions
in
Dirichlet
distribution
"
}
Error
:
:
AlphaTooSmall
=
>
"
alpha
is
not
positive
in
Dirichlet
distribution
"
}
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
doc_cfg
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
impl
std
:
:
error
:
:
Error
for
Error
{
}
impl
<
F
>
Dirichlet
<
F
>
where
F
:
Float
StandardNormal
:
Distribution
<
F
>
Exp1
:
Distribution
<
F
>
Open01
:
Distribution
<
F
>
{
#
[
inline
]
pub
fn
new
(
alpha
:
&
[
F
]
)
-
>
Result
<
Dirichlet
<
F
>
Error
>
{
if
alpha
.
len
(
)
<
2
{
return
Err
(
Error
:
:
AlphaTooShort
)
;
}
for
&
ai
in
alpha
.
iter
(
)
{
if
!
(
ai
>
F
:
:
zero
(
)
)
{
return
Err
(
Error
:
:
AlphaTooSmall
)
;
}
}
Ok
(
Dirichlet
{
alpha
:
alpha
.
to_vec
(
)
.
into_boxed_slice
(
)
}
)
}
#
[
inline
]
pub
fn
new_with_size
(
alpha
:
F
size
:
usize
)
-
>
Result
<
Dirichlet
<
F
>
Error
>
{
if
!
(
alpha
>
F
:
:
zero
(
)
)
{
return
Err
(
Error
:
:
AlphaTooSmall
)
;
}
if
size
<
2
{
return
Err
(
Error
:
:
SizeTooSmall
)
;
}
Ok
(
Dirichlet
{
alpha
:
vec
!
[
alpha
;
size
]
.
into_boxed_slice
(
)
}
)
}
}
impl
<
F
>
Distribution
<
Vec
<
F
>
>
for
Dirichlet
<
F
>
where
F
:
Float
StandardNormal
:
Distribution
<
F
>
Exp1
:
Distribution
<
F
>
Open01
:
Distribution
<
F
>
{
fn
sample
<
R
:
Rng
+
?
Sized
>
(
&
self
rng
:
&
mut
R
)
-
>
Vec
<
F
>
{
let
n
=
self
.
alpha
.
len
(
)
;
let
mut
samples
=
vec
!
[
F
:
:
zero
(
)
;
n
]
;
let
mut
sum
=
F
:
:
zero
(
)
;
for
(
s
&
a
)
in
samples
.
iter_mut
(
)
.
zip
(
self
.
alpha
.
iter
(
)
)
{
let
g
=
Gamma
:
:
new
(
a
F
:
:
one
(
)
)
.
unwrap
(
)
;
*
s
=
g
.
sample
(
rng
)
;
sum
=
sum
+
(
*
s
)
;
}
let
invacc
=
F
:
:
one
(
)
/
sum
;
for
s
in
samples
.
iter_mut
(
)
{
*
s
=
(
*
s
)
*
invacc
;
}
samples
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_dirichlet
(
)
{
let
d
=
Dirichlet
:
:
new
(
&
[
1
.
0
2
.
0
3
.
0
]
)
.
unwrap
(
)
;
let
mut
rng
=
crate
:
:
test
:
:
rng
(
221
)
;
let
samples
=
d
.
sample
(
&
mut
rng
)
;
let
_
:
Vec
<
f64
>
=
samples
.
into_iter
(
)
.
map
(
|
x
|
{
assert
!
(
x
>
0
.
0
)
;
x
}
)
.
collect
(
)
;
}
#
[
test
]
fn
test_dirichlet_with_param
(
)
{
let
alpha
=
0
.
5f64
;
let
size
=
2
;
let
d
=
Dirichlet
:
:
new_with_size
(
alpha
size
)
.
unwrap
(
)
;
let
mut
rng
=
crate
:
:
test
:
:
rng
(
221
)
;
let
samples
=
d
.
sample
(
&
mut
rng
)
;
let
_
:
Vec
<
f64
>
=
samples
.
into_iter
(
)
.
map
(
|
x
|
{
assert
!
(
x
>
0
.
0
)
;
x
}
)
.
collect
(
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_dirichlet_invalid_length
(
)
{
Dirichlet
:
:
new_with_size
(
0
.
5f64
1
)
.
unwrap
(
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_dirichlet_invalid_alpha
(
)
{
Dirichlet
:
:
new_with_size
(
0
.
0f64
2
)
.
unwrap
(
)
;
}
}
