use
super
:
:
Guid
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
serde_json
:
:
{
Map
Value
as
JsonValue
}
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
Serialize
Deserialize
)
]
pub
struct
Payload
{
pub
id
:
Guid
#
[
serde
(
default
)
]
#
[
serde
(
skip_serializing_if
=
"
crate
:
:
skip_if_default
"
)
]
pub
deleted
:
bool
#
[
serde
(
flatten
)
]
pub
data
:
Map
<
String
JsonValue
>
}
impl
Payload
{
pub
fn
new_tombstone
(
id
:
impl
Into
<
Guid
>
)
-
>
Payload
{
Payload
{
id
:
id
.
into
(
)
deleted
:
true
data
:
Map
:
:
new
(
)
}
}
pub
fn
new_tombstone_with_ttl
(
id
:
impl
Into
<
Guid
>
ttl
:
u32
)
-
>
Payload
{
let
mut
result
=
Payload
:
:
new_tombstone
(
id
)
;
result
.
data
.
insert
(
"
ttl
"
.
into
(
)
ttl
.
into
(
)
)
;
result
}
#
[
inline
]
pub
fn
with_sortindex
(
mut
self
index
:
i32
)
-
>
Payload
{
self
.
data
.
insert
(
"
sortindex
"
.
into
(
)
index
.
into
(
)
)
;
self
}
pub
fn
with_auto_field
<
T
:
Into
<
JsonValue
>
>
(
mut
self
name
:
&
str
v
:
Option
<
T
>
)
-
>
Payload
{
let
old_value
:
Option
<
JsonValue
>
=
if
let
Some
(
value
)
=
v
{
self
.
data
.
insert
(
name
.
into
(
)
value
.
into
(
)
)
}
else
{
self
.
data
.
remove
(
name
)
}
;
if
let
Some
(
old_value
)
=
old_value
{
log
:
:
warn
!
(
"
Payload
for
record
{
}
already
contains
'
automatic
'
field
\
"
{
}
\
"
?
\
Overwriting
auto
value
:
{
}
with
'
real
'
value
"
self
.
id
name
old_value
)
;
}
self
}
pub
fn
take_auto_field
<
V
>
(
&
mut
self
name
:
&
str
)
-
>
Option
<
V
>
where
for
<
'
a
>
V
:
Deserialize
<
'
a
>
{
let
v
=
self
.
data
.
remove
(
name
)
?
;
match
serde_json
:
:
from_value
(
v
)
{
Ok
(
v
)
=
>
Some
(
v
)
Err
(
e
)
=
>
{
log
:
:
error
!
(
"
Automatic
field
{
}
exists
on
payload
but
cannot
be
deserialized
:
{
}
"
name
e
)
;
None
}
}
}
#
[
inline
]
pub
fn
id
(
&
self
)
-
>
&
str
{
&
self
.
id
[
.
.
]
}
#
[
inline
]
pub
fn
is_tombstone
(
&
self
)
-
>
bool
{
self
.
deleted
}
pub
fn
from_json
(
value
:
JsonValue
)
-
>
Result
<
Payload
serde_json
:
:
Error
>
{
serde_json
:
:
from_value
(
value
)
}
pub
fn
into_record
<
T
>
(
self
)
-
>
Result
<
T
serde_json
:
:
Error
>
where
for
<
'
a
>
T
:
Deserialize
<
'
a
>
{
serde_json
:
:
from_value
(
JsonValue
:
:
from
(
self
)
)
}
pub
fn
from_record
<
T
:
Serialize
>
(
v
:
T
)
-
>
Result
<
Payload
serde_json
:
:
Error
>
{
Payload
:
:
from_json
(
serde_json
:
:
to_value
(
v
)
?
)
}
pub
fn
into_json_string
(
self
)
-
>
String
{
serde_json
:
:
to_string
(
&
JsonValue
:
:
from
(
self
)
)
.
expect
(
"
JSON
.
stringify
failed
which
shouldn
'
t
be
possible
"
)
}
}
impl
From
<
Payload
>
for
JsonValue
{
fn
from
(
cleartext
:
Payload
)
-
>
Self
{
let
Payload
{
mut
data
id
deleted
}
=
cleartext
;
data
.
insert
(
"
id
"
.
to_string
(
)
JsonValue
:
:
String
(
id
.
into_string
(
)
)
)
;
if
deleted
{
data
.
insert
(
"
deleted
"
.
to_string
(
)
JsonValue
:
:
Bool
(
true
)
)
;
}
JsonValue
:
:
Object
(
data
)
}
}
