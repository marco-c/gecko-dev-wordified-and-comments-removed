use
serde_derive
:
:
*
;
use
super
:
:
Command
;
#
[
derive
(
Clone
Debug
Eq
Deserialize
Hash
PartialEq
Serialize
)
]
#
[
serde
(
rename_all
=
"
camelCase
"
)
]
pub
struct
ClientRecord
{
#
[
serde
(
rename
=
"
id
"
)
]
pub
id
:
String
pub
name
:
String
#
[
serde
(
default
rename
=
"
type
"
)
]
pub
typ
:
Option
<
crate
:
:
DeviceType
>
#
[
serde
(
default
skip_serializing_if
=
"
Vec
:
:
is_empty
"
)
]
pub
commands
:
Vec
<
CommandRecord
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
fxa_device_id
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
version
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Vec
:
:
is_empty
"
)
]
pub
protocols
:
Vec
<
String
>
#
[
serde
(
default
rename
=
"
formfactor
"
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
form_factor
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
os
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
app_package
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
application
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
device
:
Option
<
String
>
#
[
serde
(
default
)
]
pub
ttl
:
u32
}
impl
From
<
&
ClientRecord
>
for
crate
:
:
RemoteClient
{
fn
from
(
record
:
&
ClientRecord
)
-
>
crate
:
:
RemoteClient
{
crate
:
:
RemoteClient
{
fxa_device_id
:
record
.
fxa_device_id
.
clone
(
)
device_name
:
record
.
name
.
clone
(
)
device_type
:
record
.
typ
}
}
}
#
[
derive
(
Clone
Debug
Eq
Deserialize
Hash
PartialEq
Serialize
)
]
#
[
serde
(
rename_all
=
"
camelCase
"
)
]
pub
struct
CommandRecord
{
#
[
serde
(
rename
=
"
command
"
)
]
pub
name
:
String
#
[
serde
(
default
)
]
pub
args
:
Vec
<
String
>
#
[
serde
(
default
rename
=
"
flowID
"
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
flow_id
:
Option
<
String
>
}
impl
CommandRecord
{
pub
fn
as_command
(
&
self
)
-
>
Option
<
Command
>
{
match
self
.
name
.
as_str
(
)
{
"
wipeEngine
"
=
>
self
.
args
.
get
(
0
)
.
map
(
|
e
|
Command
:
:
Wipe
(
e
.
into
(
)
)
)
"
resetEngine
"
=
>
self
.
args
.
get
(
0
)
.
map
(
|
e
|
Command
:
:
Reset
(
e
.
into
(
)
)
)
"
resetAll
"
=
>
Some
(
Command
:
:
ResetAll
)
_
=
>
None
}
}
}
impl
From
<
Command
>
for
CommandRecord
{
fn
from
(
command
:
Command
)
-
>
CommandRecord
{
match
command
{
Command
:
:
Wipe
(
engine
)
=
>
CommandRecord
{
name
:
"
wipeEngine
"
.
into
(
)
args
:
vec
!
[
engine
]
flow_id
:
None
}
Command
:
:
Reset
(
engine
)
=
>
CommandRecord
{
name
:
"
resetEngine
"
.
into
(
)
args
:
vec
!
[
engine
]
flow_id
:
None
}
Command
:
:
ResetAll
=
>
CommandRecord
{
name
:
"
resetAll
"
.
into
(
)
args
:
Vec
:
:
new
(
)
flow_id
:
None
}
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
Payload
;
#
[
test
]
fn
test_ttl
(
)
{
let
record
=
ClientRecord
{
id
:
"
id
"
.
into
(
)
name
:
"
my
device
"
.
into
(
)
typ
:
Some
(
crate
:
:
DeviceType
:
:
VR
)
commands
:
Vec
:
:
new
(
)
fxa_device_id
:
Some
(
"
12345
"
.
into
(
)
)
version
:
None
protocols
:
vec
!
[
"
1
.
5
"
.
into
(
)
]
form_factor
:
None
os
:
None
app_package
:
None
application
:
None
device
:
None
ttl
:
123
}
;
let
p
=
Payload
:
:
from_record
(
record
)
.
unwrap
(
)
;
let
bso
=
crate
:
:
CleartextBso
:
:
from_payload
(
p
"
clients
"
)
;
assert_eq
!
(
bso
.
ttl
Some
(
123
)
)
;
}
}
