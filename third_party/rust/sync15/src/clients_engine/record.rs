use
crate
:
:
error
:
:
error
;
use
serde_derive
:
:
*
;
use
super
:
:
Command
;
#
[
derive
(
Clone
Debug
Eq
Deserialize
Hash
PartialEq
Serialize
)
]
#
[
serde
(
rename_all
=
"
camelCase
"
)
]
pub
struct
ClientRecord
{
#
[
serde
(
rename
=
"
id
"
)
]
pub
id
:
String
pub
name
:
String
#
[
serde
(
rename
=
"
type
"
)
]
pub
typ
:
crate
:
:
DeviceType
#
[
serde
(
default
skip_serializing_if
=
"
Vec
:
:
is_empty
"
)
]
pub
commands
:
Vec
<
CommandRecord
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
fxa_device_id
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
version
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Vec
:
:
is_empty
"
)
]
pub
protocols
:
Vec
<
String
>
#
[
serde
(
default
rename
=
"
formfactor
"
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
form_factor
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
os
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
app_package
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
application
:
Option
<
String
>
#
[
serde
(
default
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
device
:
Option
<
String
>
}
impl
From
<
&
ClientRecord
>
for
crate
:
:
RemoteClient
{
fn
from
(
record
:
&
ClientRecord
)
-
>
crate
:
:
RemoteClient
{
crate
:
:
RemoteClient
{
fxa_device_id
:
record
.
fxa_device_id
.
clone
(
)
device_name
:
record
.
name
.
clone
(
)
device_type
:
record
.
typ
}
}
}
#
[
derive
(
Clone
Debug
Eq
Deserialize
Hash
PartialEq
Serialize
)
]
#
[
serde
(
rename_all
=
"
camelCase
"
)
]
pub
struct
CommandRecord
{
#
[
serde
(
rename
=
"
command
"
)
]
pub
name
:
String
#
[
serde
(
default
)
]
pub
args
:
Vec
<
Option
<
String
>
>
#
[
serde
(
default
rename
=
"
flowID
"
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
flow_id
:
Option
<
String
>
}
impl
CommandRecord
{
fn
get_single_string_arg
(
&
self
)
-
>
Option
<
String
>
{
let
cmd_name
=
&
self
.
name
;
if
self
.
args
.
len
(
)
=
=
1
{
match
&
self
.
args
[
0
]
{
Some
(
name
)
=
>
Some
(
name
.
into
(
)
)
None
=
>
{
error
!
(
"
Incoming
'
{
cmd_name
}
'
command
has
null
argument
"
)
;
None
}
}
}
else
{
error
!
(
"
Incoming
'
{
cmd_name
}
'
command
has
wrong
number
of
arguments
(
{
}
)
"
self
.
args
.
len
(
)
)
;
None
}
}
pub
fn
as_command
(
&
self
)
-
>
Option
<
Command
>
{
match
self
.
name
.
as_str
(
)
{
"
wipeEngine
"
=
>
self
.
get_single_string_arg
(
)
.
map
(
Command
:
:
Wipe
)
"
resetEngine
"
=
>
self
.
get_single_string_arg
(
)
.
map
(
Command
:
:
Reset
)
"
resetAll
"
=
>
{
if
self
.
args
.
is_empty
(
)
{
Some
(
Command
:
:
ResetAll
)
}
else
{
error
!
(
"
Invalid
arguments
for
'
resetAll
'
command
"
)
;
None
}
}
_
=
>
None
}
}
}
impl
From
<
Command
>
for
CommandRecord
{
fn
from
(
command
:
Command
)
-
>
CommandRecord
{
match
command
{
Command
:
:
Wipe
(
engine
)
=
>
CommandRecord
{
name
:
"
wipeEngine
"
.
into
(
)
args
:
vec
!
[
Some
(
engine
)
]
flow_id
:
None
}
Command
:
:
Reset
(
engine
)
=
>
CommandRecord
{
name
:
"
resetEngine
"
.
into
(
)
args
:
vec
!
[
Some
(
engine
)
]
flow_id
:
None
}
Command
:
:
ResetAll
=
>
CommandRecord
{
name
:
"
resetAll
"
.
into
(
)
args
:
Vec
:
:
new
(
)
flow_id
:
None
}
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_valid_commands
(
)
{
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
wipeEngine
"
"
args
"
:
[
"
foo
"
]
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
Some
(
Command
:
:
Wipe
(
"
foo
"
.
to_string
(
)
)
)
)
;
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
resetEngine
"
"
args
"
:
[
"
foo
"
]
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
Some
(
Command
:
:
Reset
(
"
foo
"
.
to_string
(
)
)
)
)
;
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
resetAll
"
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
Some
(
Command
:
:
ResetAll
)
)
;
}
#
[
test
]
fn
test_unknown_command
(
)
{
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
unknown
"
"
args
"
:
[
"
foo
"
"
bar
"
]
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
None
)
;
}
#
[
test
]
fn
test_bad_args
(
)
{
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
wipeEngine
"
"
args
"
:
[
"
foo
"
"
bar
"
]
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
None
)
;
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
wipeEngine
"
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
None
)
;
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
resetAll
"
"
args
"
:
[
"
foo
"
]
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
None
)
;
}
#
[
test
]
fn
test_null_args
(
)
{
let
ser
=
serde_json
:
:
json
!
(
{
"
command
"
:
"
unknown
"
"
args
"
:
[
"
foo
"
null
]
}
)
;
let
record
:
CommandRecord
=
serde_json
:
:
from_value
(
ser
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
as_command
(
)
None
)
;
}
}
