use
crate
:
:
record_types
:
:
MetaGlobalRecord
;
use
crate
:
:
state
:
:
PersistedGlobalState
;
use
crate
:
:
CollSyncIds
;
use
serde_json
:
:
Value
;
pub
fn
extract_v1_state
(
state
:
Option
<
String
>
collection
:
&
'
static
str
)
-
>
(
Option
<
CollSyncIds
>
Option
<
String
>
)
{
let
state
=
match
state
{
Some
(
s
)
=
>
s
None
=
>
return
(
None
None
)
}
;
let
j
:
serde_json
:
:
Value
=
match
serde_json
:
:
from_str
(
&
state
)
{
Ok
(
j
)
=
>
j
Err
(
_
)
=
>
return
(
None
None
)
}
;
if
Some
(
"
V1
"
)
!
=
j
.
get
(
"
schema_version
"
)
.
and_then
(
Value
:
:
as_str
)
{
return
(
None
None
)
;
}
let
empty
=
Vec
:
:
<
serde_json
:
:
Value
>
:
:
new
(
)
;
let
global
=
match
j
.
get
(
"
global
"
)
.
and_then
(
Value
:
:
as_object
)
{
None
=
>
return
(
None
None
)
Some
(
v
)
=
>
v
}
;
let
meta_global
=
match
global
[
"
payload
"
]
.
as_str
(
)
.
and_then
(
|
s
|
serde_json
:
:
from_str
:
:
<
MetaGlobalRecord
>
(
s
)
.
ok
(
)
)
{
Some
(
p
)
=
>
p
None
=
>
return
(
None
None
)
}
;
let
pgs
=
PersistedGlobalState
:
:
V2
{
declined
:
Some
(
meta_global
.
declined
)
}
;
let
new_global_state
=
serde_json
:
:
to_string
(
&
pgs
)
.
ok
(
)
;
for
change
in
j
.
get
(
"
engine_state_changes
"
)
.
and_then
(
Value
:
:
as_array
)
.
unwrap_or
(
&
empty
)
{
if
change
.
as_str
(
)
=
=
Some
(
"
ResetAll
"
)
{
return
(
None
new_global_state
)
;
}
if
let
Some
(
change_ob
)
=
change
.
as_object
(
)
{
if
change_ob
.
get
(
"
Reset
"
)
.
and_then
(
Value
:
:
as_str
)
=
=
Some
(
collection
)
{
return
(
None
new_global_state
)
;
}
if
let
Some
(
except_array
)
=
change_ob
.
get
(
"
ResetAllExcept
"
)
.
and_then
(
Value
:
:
as_array
)
{
if
except_array
.
iter
(
)
.
filter_map
(
Value
:
:
as_str
)
.
all
(
|
s
|
s
!
=
collection
)
{
return
(
None
new_global_state
)
;
}
}
}
}
let
gsid
=
meta_global
.
sync_id
;
let
ids
=
meta_global
.
engines
.
get
(
collection
)
.
map
(
|
coll
|
CollSyncIds
{
global
:
gsid
coll
:
coll
.
sync_id
.
clone
(
)
}
)
;
(
ids
new_global_state
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
fn
get_state_with_engine_changes_and_declined
(
changes
:
&
str
declined
:
&
str
)
-
>
String
{
format
!
(
r
#
"
{
{
"
schema_version
"
:
"
V1
"
"
global
"
:
{
{
"
id
"
:
"
global
"
"
collection
"
:
"
"
"
payload
"
:
"
{
{
\
"
syncID
\
"
:
\
"
qZKAMjhyV6Ti
\
"
\
"
storageVersion
\
"
:
5
\
"
engines
\
"
:
{
{
\
"
addresses
\
"
:
{
{
\
"
version
\
"
:
1
\
"
syncID
\
"
:
\
"
8M
-
HfX6dm
-
pD
\
"
}
}
\
"
bookmarks
\
"
:
{
{
\
"
version
\
"
:
2
\
"
syncID
\
"
:
\
"
AVXtnKkH5OTi
\
"
}
}
}
}
\
"
declined
\
"
:
[
{
declined
}
]
}
}
"
}
}
"
keys
"
:
{
{
"
timestamp
"
:
1548214240
.
34
"
default
"
:
{
{
"
enc_key
"
:
[
36
76
]
"
mac_key
"
:
[
222
241
]
}
}
"
collections
"
:
{
{
}
}
}
}
"
engine_state_changes
"
:
[
{
changes
}
]
}
}
"
#
changes
=
changes
declined
=
declined
)
}
fn
get_state_with_engine_changes
(
changes
:
&
str
)
-
>
String
{
get_state_with_engine_changes_and_declined
(
changes
"
"
)
}
fn
make_csids
(
global
:
&
str
coll
:
&
str
)
-
>
Option
<
CollSyncIds
>
{
Some
(
CollSyncIds
{
global
:
global
.
into
(
)
coll
:
coll
.
into
(
)
}
)
}
fn
extract_v1_ids_only
(
state
:
Option
<
String
>
collection
:
&
'
static
str
)
-
>
Option
<
CollSyncIds
>
{
let
(
sync_ids
new_state
)
=
extract_v1_state
(
state
collection
)
;
let
expected_state
=
serde_json
:
:
to_string
(
&
PersistedGlobalState
:
:
V2
{
declined
:
Some
(
Vec
:
:
<
String
>
:
:
new
(
)
)
}
)
.
expect
(
"
should
stringify
"
)
;
assert_eq
!
(
new_state
Some
(
expected_state
)
)
;
sync_ids
}
#
[
test
]
fn
test_extract_state_simple
(
)
{
let
s
=
get_state_with_engine_changes
(
"
"
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
.
clone
(
)
)
"
addresses
"
)
make_csids
(
"
qZKAMjhyV6Ti
"
"
8M
-
HfX6dm
-
pD
"
)
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
)
"
bookmarks
"
)
make_csids
(
"
qZKAMjhyV6Ti
"
"
AVXtnKkH5OTi
"
)
)
;
}
#
[
test
]
fn
test_extract_state_simple_with_declined
(
)
{
let
s
=
get_state_with_engine_changes_and_declined
(
"
"
"
\
\
\
"
foo
\
\
\
"
"
)
;
let
expected_state
=
serde_json
:
:
to_string
(
&
PersistedGlobalState
:
:
V2
{
declined
:
Some
(
vec
!
[
"
foo
"
.
to_string
(
)
]
)
}
)
.
unwrap
(
)
;
assert_eq
!
(
extract_v1_state
(
Some
(
s
)
"
addresses
"
)
(
make_csids
(
"
qZKAMjhyV6Ti
"
"
8M
-
HfX6dm
-
pD
"
)
Some
(
expected_state
)
)
)
;
}
#
[
test
]
fn
test_extract_with_engine_reset_all
(
)
{
let
s
=
get_state_with_engine_changes
(
"
\
"
ResetAll
\
"
"
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
)
"
addresses
"
)
None
)
;
}
#
[
test
]
fn
test_extract_with_engine_reset
(
)
{
let
s
=
get_state_with_engine_changes
(
"
{
\
"
Reset
\
"
:
\
"
addresses
\
"
}
"
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
.
clone
(
)
)
"
addresses
"
)
None
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
)
"
bookmarks
"
)
make_csids
(
"
qZKAMjhyV6Ti
"
"
AVXtnKkH5OTi
"
)
)
;
}
#
[
test
]
fn
test_extract_with_engine_reset_except
(
)
{
let
s
=
get_state_with_engine_changes
(
"
{
\
"
ResetAllExcept
\
"
:
[
\
"
addresses
\
"
]
}
"
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
.
clone
(
)
)
"
addresses
"
)
make_csids
(
"
qZKAMjhyV6Ti
"
"
8M
-
HfX6dm
-
pD
"
)
)
;
assert_eq
!
(
extract_v1_ids_only
(
Some
(
s
)
"
bookmarks
"
)
None
)
;
}
}
