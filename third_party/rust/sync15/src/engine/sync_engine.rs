use
super
:
:
CollectionRequest
;
use
crate
:
:
bso
:
:
{
IncomingBso
OutgoingBso
}
;
use
crate
:
:
client_types
:
:
ClientData
;
use
crate
:
:
{
telemetry
CollectionName
Guid
ServerTimestamp
}
;
use
anyhow
:
:
Result
;
use
std
:
:
fmt
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
CollSyncIds
{
pub
global
:
Guid
pub
coll
:
Guid
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
enum
EngineSyncAssociation
{
Disconnected
Connected
(
CollSyncIds
)
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
enum
SyncEngineId
{
Passwords
Tabs
Bookmarks
Addresses
CreditCards
History
}
impl
SyncEngineId
{
pub
fn
iter
(
)
-
>
impl
Iterator
<
Item
=
SyncEngineId
>
{
[
Self
:
:
Passwords
Self
:
:
Tabs
Self
:
:
Bookmarks
Self
:
:
Addresses
Self
:
:
CreditCards
Self
:
:
History
]
.
into_iter
(
)
}
pub
fn
name
(
&
self
)
-
>
&
'
static
str
{
match
self
{
Self
:
:
Passwords
=
>
"
passwords
"
Self
:
:
History
=
>
"
history
"
Self
:
:
Bookmarks
=
>
"
bookmarks
"
Self
:
:
Tabs
=
>
"
tabs
"
Self
:
:
Addresses
=
>
"
addresses
"
Self
:
:
CreditCards
=
>
"
creditcards
"
}
}
}
impl
fmt
:
:
Display
for
SyncEngineId
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
name
(
)
)
}
}
impl
TryFrom
<
&
str
>
for
SyncEngineId
{
type
Error
=
String
;
fn
try_from
(
value
:
&
str
)
-
>
std
:
:
result
:
:
Result
<
Self
Self
:
:
Error
>
{
match
value
{
"
passwords
"
=
>
Ok
(
Self
:
:
Passwords
)
"
history
"
=
>
Ok
(
Self
:
:
History
)
"
bookmarks
"
=
>
Ok
(
Self
:
:
Bookmarks
)
"
tabs
"
=
>
Ok
(
Self
:
:
Tabs
)
"
addresses
"
=
>
Ok
(
Self
:
:
Addresses
)
"
creditcards
"
=
>
Ok
(
Self
:
:
CreditCards
)
_
=
>
Err
(
value
.
into
(
)
)
}
}
}
pub
trait
SyncEngine
{
fn
collection_name
(
&
self
)
-
>
CollectionName
;
fn
prepare_for_sync
(
&
self
_get_client_data
:
&
dyn
Fn
(
)
-
>
ClientData
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
set_local_encryption_key
(
&
mut
self
_key
:
&
str
)
-
>
Result
<
(
)
>
{
unimplemented
!
(
"
This
engine
does
not
support
local
encryption
"
)
;
}
fn
stage_incoming
(
&
self
inbound
:
Vec
<
IncomingBso
>
telem
:
&
mut
telemetry
:
:
Engine
)
-
>
Result
<
(
)
>
;
fn
apply
(
&
self
timestamp
:
ServerTimestamp
telem
:
&
mut
telemetry
:
:
Engine
)
-
>
Result
<
Vec
<
OutgoingBso
>
>
;
fn
set_uploaded
(
&
self
new_timestamp
:
ServerTimestamp
ids
:
Vec
<
Guid
>
)
-
>
Result
<
(
)
>
;
fn
sync_finished
(
&
self
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
get_collection_request
(
&
self
server_timestamp
:
ServerTimestamp
)
-
>
Result
<
Option
<
CollectionRequest
>
>
;
fn
get_sync_assoc
(
&
self
)
-
>
Result
<
EngineSyncAssociation
>
;
fn
reset
(
&
self
assoc
:
&
EngineSyncAssociation
)
-
>
Result
<
(
)
>
;
fn
wipe
(
&
self
)
-
>
Result
<
(
)
>
{
unimplemented
!
(
"
The
engine
does
not
implement
wipe
no
wipe
should
be
requested
"
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
std
:
:
iter
:
:
zip
;
#
[
test
]
fn
test_engine_priority
(
)
{
fn
sorted
(
mut
engines
:
Vec
<
SyncEngineId
>
)
-
>
Vec
<
SyncEngineId
>
{
engines
.
sort
(
)
;
engines
}
assert_eq
!
(
vec
!
[
SyncEngineId
:
:
Passwords
SyncEngineId
:
:
Tabs
]
sorted
(
vec
!
[
SyncEngineId
:
:
Passwords
SyncEngineId
:
:
Tabs
]
)
)
;
assert_eq
!
(
vec
!
[
SyncEngineId
:
:
Passwords
SyncEngineId
:
:
Tabs
]
sorted
(
vec
!
[
SyncEngineId
:
:
Tabs
SyncEngineId
:
:
Passwords
]
)
)
;
}
#
[
test
]
fn
test_engine_enum_order
(
)
{
let
unsorted
=
SyncEngineId
:
:
iter
(
)
.
collect
:
:
<
Vec
<
SyncEngineId
>
>
(
)
;
let
mut
sorted
=
SyncEngineId
:
:
iter
(
)
.
collect
:
:
<
Vec
<
SyncEngineId
>
>
(
)
;
sorted
.
sort
(
)
;
assert
!
(
zip
(
unsorted
sorted
)
.
fold
(
true
|
acc
(
a
b
)
|
acc
&
&
(
a
=
=
b
)
)
)
}
}
