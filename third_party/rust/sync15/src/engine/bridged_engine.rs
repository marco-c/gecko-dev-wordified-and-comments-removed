use
crate
:
:
{
telemetry
ServerTimestamp
}
;
use
anyhow
:
:
Result
;
use
crate
:
:
bso
:
:
{
IncomingBso
OutgoingBso
}
;
use
crate
:
:
Guid
;
use
super
:
:
{
CollSyncIds
EngineSyncAssociation
SyncEngine
}
;
pub
trait
BridgedEngine
:
Send
+
Sync
{
fn
last_sync
(
&
self
)
-
>
Result
<
i64
>
;
fn
set_last_sync
(
&
self
last_sync_millis
:
i64
)
-
>
Result
<
(
)
>
;
fn
sync_id
(
&
self
)
-
>
Result
<
Option
<
String
>
>
;
fn
reset_sync_id
(
&
self
)
-
>
Result
<
String
>
;
fn
ensure_current_sync_id
(
&
self
new_sync_id
:
&
str
)
-
>
Result
<
String
>
;
fn
prepare_for_sync
(
&
self
_client_data
:
&
str
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
sync_started
(
&
self
)
-
>
Result
<
(
)
>
;
fn
store_incoming
(
&
self
incoming_records
:
Vec
<
IncomingBso
>
)
-
>
Result
<
(
)
>
;
fn
apply
(
&
self
)
-
>
Result
<
ApplyResults
>
;
fn
set_uploaded
(
&
self
server_modified_millis
:
i64
ids
:
&
[
Guid
]
)
-
>
Result
<
(
)
>
;
fn
sync_finished
(
&
self
)
-
>
Result
<
(
)
>
;
fn
reset
(
&
self
)
-
>
Result
<
(
)
>
;
fn
wipe
(
&
self
)
-
>
Result
<
(
)
>
;
}
pub
trait
BridgedEngineAdaptor
:
Send
+
Sync
{
fn
last_sync
(
&
self
)
-
>
Result
<
i64
>
;
fn
set_last_sync
(
&
self
last_sync_millis
:
i64
)
-
>
Result
<
(
)
>
;
fn
sync_started
(
&
self
)
-
>
Result
<
(
)
>
{
Ok
(
(
)
)
}
fn
engine
(
&
self
)
-
>
&
dyn
SyncEngine
;
}
impl
<
A
:
BridgedEngineAdaptor
>
BridgedEngine
for
A
{
fn
last_sync
(
&
self
)
-
>
Result
<
i64
>
{
self
.
last_sync
(
)
}
fn
set_last_sync
(
&
self
last_sync_millis
:
i64
)
-
>
Result
<
(
)
>
{
self
.
set_last_sync
(
last_sync_millis
)
}
fn
sync_id
(
&
self
)
-
>
Result
<
Option
<
String
>
>
{
Ok
(
match
self
.
engine
(
)
.
get_sync_assoc
(
)
?
{
EngineSyncAssociation
:
:
Disconnected
=
>
None
EngineSyncAssociation
:
:
Connected
(
c
)
=
>
Some
(
c
.
coll
.
into
(
)
)
}
)
}
fn
reset_sync_id
(
&
self
)
-
>
Result
<
String
>
{
let
global
=
Guid
:
:
empty
(
)
;
let
coll
=
Guid
:
:
random
(
)
;
self
.
engine
(
)
.
reset
(
&
EngineSyncAssociation
:
:
Connected
(
CollSyncIds
{
global
coll
:
coll
.
clone
(
)
}
)
)
?
;
Ok
(
coll
.
to_string
(
)
)
}
fn
ensure_current_sync_id
(
&
self
sync_id
:
&
str
)
-
>
Result
<
String
>
{
let
engine
=
self
.
engine
(
)
;
let
assoc
=
engine
.
get_sync_assoc
(
)
?
;
if
matches
!
(
assoc
EngineSyncAssociation
:
:
Connected
(
c
)
if
c
.
coll
=
=
sync_id
)
{
log
:
:
debug
!
(
"
ensure_current_sync_id
is
current
"
)
;
}
else
{
let
new_coll_ids
=
CollSyncIds
{
global
:
Guid
:
:
empty
(
)
coll
:
sync_id
.
into
(
)
}
;
engine
.
reset
(
&
EngineSyncAssociation
:
:
Connected
(
new_coll_ids
)
)
?
;
}
Ok
(
sync_id
.
to_string
(
)
)
}
fn
prepare_for_sync
(
&
self
client_data
:
&
str
)
-
>
Result
<
(
)
>
{
self
.
engine
(
)
.
prepare_for_sync
(
&
|
|
serde_json
:
:
from_str
:
:
<
crate
:
:
ClientData
>
(
client_data
)
.
unwrap
(
)
)
}
fn
sync_started
(
&
self
)
-
>
Result
<
(
)
>
{
A
:
:
sync_started
(
self
)
}
fn
store_incoming
(
&
self
incoming_records
:
Vec
<
IncomingBso
>
)
-
>
Result
<
(
)
>
{
let
engine
=
self
.
engine
(
)
;
let
mut
telem
=
telemetry
:
:
Engine
:
:
new
(
engine
.
collection_name
(
)
)
;
engine
.
stage_incoming
(
incoming_records
&
mut
telem
)
}
fn
apply
(
&
self
)
-
>
Result
<
ApplyResults
>
{
let
engine
=
self
.
engine
(
)
;
let
mut
telem
=
telemetry
:
:
Engine
:
:
new
(
engine
.
collection_name
(
)
)
;
let
records
=
engine
.
apply
(
ServerTimestamp
:
:
from_millis
(
0
)
&
mut
telem
)
?
;
Ok
(
ApplyResults
{
records
num_reconciled
:
telem
.
get_incoming
(
)
.
as_ref
(
)
.
map
(
|
i
|
i
.
get_reconciled
(
)
as
usize
)
}
)
}
fn
set_uploaded
(
&
self
millis
:
i64
ids
:
&
[
Guid
]
)
-
>
Result
<
(
)
>
{
self
.
engine
(
)
.
set_uploaded
(
ServerTimestamp
:
:
from_millis
(
millis
)
ids
.
to_vec
(
)
)
}
fn
sync_finished
(
&
self
)
-
>
Result
<
(
)
>
{
self
.
engine
(
)
.
sync_finished
(
)
}
fn
reset
(
&
self
)
-
>
Result
<
(
)
>
{
self
.
engine
(
)
.
reset
(
&
EngineSyncAssociation
:
:
Disconnected
)
}
fn
wipe
(
&
self
)
-
>
Result
<
(
)
>
{
self
.
engine
(
)
.
wipe
(
)
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ApplyResults
{
pub
records
:
Vec
<
OutgoingBso
>
pub
num_reconciled
:
Option
<
usize
>
}
impl
ApplyResults
{
pub
fn
new
(
records
:
Vec
<
OutgoingBso
>
num_reconciled
:
impl
Into
<
Option
<
usize
>
>
)
-
>
Self
{
Self
{
records
num_reconciled
:
num_reconciled
.
into
(
)
}
}
}
impl
From
<
Vec
<
OutgoingBso
>
>
for
ApplyResults
{
fn
from
(
records
:
Vec
<
OutgoingBso
>
)
-
>
Self
{
Self
{
records
num_reconciled
:
None
}
}
}
