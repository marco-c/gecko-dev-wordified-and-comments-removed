use
super
:
:
{
IncomingBso
IncomingEnvelope
OutgoingBso
OutgoingEnvelope
}
;
use
crate
:
:
error
;
use
crate
:
:
key_bundle
:
:
KeyBundle
;
use
crate
:
:
EncryptedPayload
;
use
serde
:
:
{
de
:
:
DeserializeOwned
Deserialize
Serialize
}
;
#
[
derive
(
Deserialize
Debug
)
]
pub
struct
IncomingEncryptedBso
{
#
[
serde
(
flatten
)
]
pub
envelope
:
IncomingEnvelope
#
[
serde
(
with
=
"
as_json
"
bound
(
deserialize
=
"
EncryptedPayload
:
DeserializeOwned
"
)
)
]
pub
(
crate
)
payload
:
EncryptedPayload
}
impl
IncomingEncryptedBso
{
pub
fn
new
(
envelope
:
IncomingEnvelope
payload
:
EncryptedPayload
)
-
>
Self
{
Self
{
envelope
payload
}
}
pub
fn
into_decrypted
(
self
key
:
&
KeyBundle
)
-
>
error
:
:
Result
<
IncomingBso
>
{
Ok
(
IncomingBso
:
:
new
(
self
.
envelope
self
.
payload
.
decrypt
(
key
)
?
)
)
}
}
#
[
derive
(
Serialize
Debug
)
]
pub
struct
OutgoingEncryptedBso
{
#
[
serde
(
flatten
)
]
pub
envelope
:
OutgoingEnvelope
#
[
serde
(
with
=
"
as_json
"
bound
(
serialize
=
"
EncryptedPayload
:
Serialize
"
)
)
]
payload
:
EncryptedPayload
}
impl
OutgoingEncryptedBso
{
pub
fn
new
(
envelope
:
OutgoingEnvelope
payload
:
EncryptedPayload
)
-
>
Self
{
Self
{
envelope
payload
}
}
#
[
inline
]
pub
fn
serialized_payload_len
(
&
self
)
-
>
usize
{
self
.
payload
.
serialized_len
(
)
}
}
impl
OutgoingBso
{
pub
fn
into_encrypted
(
self
key
:
&
KeyBundle
)
-
>
error
:
:
Result
<
OutgoingEncryptedBso
>
{
Ok
(
OutgoingEncryptedBso
{
envelope
:
self
.
envelope
payload
:
EncryptedPayload
:
:
from_cleartext
(
key
self
.
payload
)
?
}
)
}
}
mod
as_json
{
use
serde
:
:
de
:
:
{
self
Deserialize
DeserializeOwned
Deserializer
}
;
use
serde
:
:
ser
:
:
{
self
Serialize
Serializer
}
;
pub
fn
serialize
<
T
S
>
(
t
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
let
j
=
serde_json
:
:
to_string
(
t
)
.
map_err
(
ser
:
:
Error
:
:
custom
)
?
;
serializer
.
serialize_str
(
&
j
)
}
pub
fn
deserialize
<
'
de
T
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
DeserializeOwned
D
:
Deserializer
<
'
de
>
{
let
j
=
String
:
:
deserialize
(
deserializer
)
?
;
serde_json
:
:
from_str
(
&
j
)
.
map_err
(
de
:
:
Error
:
:
custom
)
}
}
#
[
cfg
(
test
)
]
impl
OutgoingEncryptedBso
{
pub
fn
payload_serialized_len
(
&
self
)
-
>
usize
{
self
.
payload
.
serialized_len
(
)
}
pub
fn
make_test_bso
(
ciphertext
:
String
)
-
>
Self
{
Self
{
envelope
:
OutgoingEnvelope
{
id
:
"
"
.
into
(
)
sortindex
:
None
ttl
:
None
}
payload
:
EncryptedPayload
{
iv
:
"
"
.
into
(
)
hmac
:
"
"
.
into
(
)
ciphertext
}
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
bso
:
:
OutgoingEnvelope
;
#
[
test
]
fn
test_deserialize_enc
(
)
{
let
serialized
=
r
#
"
{
"
id
"
:
"
1234
"
"
collection
"
:
"
passwords
"
"
modified
"
:
12344321
.
0
"
payload
"
:
"
{
\
"
IV
\
"
:
\
"
aaaaa
\
"
\
"
hmac
\
"
:
\
"
bbbbb
\
"
\
"
ciphertext
\
"
:
\
"
ccccc
\
"
}
"
}
"
#
;
let
record
:
IncomingEncryptedBso
=
serde_json
:
:
from_str
(
serialized
)
.
unwrap
(
)
;
assert_eq
!
(
&
record
.
envelope
.
id
"
1234
"
)
;
assert_eq
!
(
(
record
.
envelope
.
modified
.
0
-
12_344_321_000
)
.
abs
(
)
0
)
;
assert_eq
!
(
record
.
envelope
.
sortindex
None
)
;
assert_eq
!
(
&
record
.
payload
.
iv
"
aaaaa
"
)
;
assert_eq
!
(
&
record
.
payload
.
hmac
"
bbbbb
"
)
;
assert_eq
!
(
&
record
.
payload
.
ciphertext
"
ccccc
"
)
;
}
#
[
test
]
fn
test_deserialize_autofields
(
)
{
let
serialized
=
r
#
"
{
"
id
"
:
"
1234
"
"
collection
"
:
"
passwords
"
"
modified
"
:
12344321
.
0
"
sortindex
"
:
100
"
ttl
"
:
99
"
payload
"
:
"
{
\
"
IV
\
"
:
\
"
aaaaa
\
"
\
"
hmac
\
"
:
\
"
bbbbb
\
"
\
"
ciphertext
\
"
:
\
"
ccccc
\
"
}
"
}
"
#
;
let
record
:
IncomingEncryptedBso
=
serde_json
:
:
from_str
(
serialized
)
.
unwrap
(
)
;
assert_eq
!
(
record
.
envelope
.
sortindex
Some
(
100
)
)
;
assert_eq
!
(
record
.
envelope
.
ttl
Some
(
99
)
)
;
}
#
[
test
]
fn
test_serialize_enc
(
)
{
let
goal
=
r
#
"
{
"
id
"
:
"
1234
"
"
payload
"
:
"
{
\
"
IV
\
"
:
\
"
aaaaa
\
"
\
"
hmac
\
"
:
\
"
bbbbb
\
"
\
"
ciphertext
\
"
:
\
"
ccccc
\
"
}
"
}
"
#
;
let
record
=
OutgoingEncryptedBso
{
envelope
:
OutgoingEnvelope
{
id
:
"
1234
"
.
into
(
)
.
.
Default
:
:
default
(
)
}
payload
:
EncryptedPayload
{
iv
:
"
aaaaa
"
.
into
(
)
hmac
:
"
bbbbb
"
.
into
(
)
ciphertext
:
"
ccccc
"
.
into
(
)
}
}
;
let
actual
=
serde_json
:
:
to_string
(
&
record
)
.
unwrap
(
)
;
assert_eq
!
(
actual
goal
)
;
let
val_str_payload
:
serde_json
:
:
Value
=
serde_json
:
:
from_str
(
goal
)
.
unwrap
(
)
;
assert_eq
!
(
val_str_payload
[
"
payload
"
]
.
as_str
(
)
.
unwrap
(
)
.
len
(
)
record
.
payload
.
serialized_len
(
)
)
}
}
