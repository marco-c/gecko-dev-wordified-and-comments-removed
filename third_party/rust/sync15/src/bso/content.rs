use
super
:
:
{
IncomingBso
IncomingContent
IncomingKind
OutgoingBso
OutgoingEnvelope
}
;
use
crate
:
:
Guid
;
use
error_support
:
:
report_error
;
use
serde
:
:
Serialize
;
type
Result
<
T
>
=
std
:
:
result
:
:
Result
<
T
serde_json
:
:
Error
>
;
impl
<
T
>
IncomingContent
<
T
>
{
pub
fn
content
(
self
)
-
>
Option
<
T
>
{
match
self
.
kind
{
IncomingKind
:
:
Content
(
t
)
=
>
Some
(
t
)
_
=
>
None
}
}
}
impl
<
T
:
std
:
:
fmt
:
:
Debug
>
std
:
:
fmt
:
:
Debug
for
IncomingKind
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
self
{
IncomingKind
:
:
Content
(
r
)
=
>
{
write
!
(
f
"
IncomingKind
:
:
Content
<
{
:
?
}
>
"
r
)
}
IncomingKind
:
:
Tombstone
=
>
write
!
(
f
"
IncomingKind
:
:
Tombstone
"
)
IncomingKind
:
:
Malformed
=
>
write
!
(
f
"
IncomingKind
:
:
Malformed
"
)
}
}
}
impl
IncomingBso
{
pub
fn
into_content
<
T
:
for
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
>
(
self
)
-
>
IncomingContent
<
T
>
{
match
serde_json
:
:
from_str
(
&
self
.
payload
)
{
Ok
(
json
)
=
>
{
let
kind
=
json_to_kind
(
json
&
self
.
envelope
.
id
)
;
IncomingContent
{
envelope
:
self
.
envelope
kind
}
}
Err
(
e
)
=
>
{
log
:
:
warn
!
(
"
Invalid
incoming
cleartext
{
}
:
{
}
"
self
.
envelope
.
id
e
)
;
IncomingContent
{
envelope
:
self
.
envelope
kind
:
IncomingKind
:
:
Malformed
}
}
}
}
}
impl
OutgoingBso
{
pub
fn
new_tombstone
(
envelope
:
OutgoingEnvelope
)
-
>
Self
{
Self
{
envelope
payload
:
serde_json
:
:
json
!
(
{
"
deleted
"
:
true
}
)
.
to_string
(
)
}
}
pub
fn
from_content_with_id
<
T
>
(
record
:
T
)
-
>
Result
<
Self
>
where
T
:
Serialize
{
let
(
json
id
)
=
content_with_id_to_json
(
record
)
?
;
Ok
(
Self
{
envelope
:
id
.
into
(
)
payload
:
serde_json
:
:
to_string
(
&
json
)
?
}
)
}
pub
fn
from_content
<
T
>
(
envelope
:
OutgoingEnvelope
record
:
T
)
-
>
Result
<
Self
>
where
T
:
Serialize
{
let
json
=
content_to_json
(
record
&
envelope
.
id
)
?
;
Ok
(
Self
{
envelope
payload
:
serde_json
:
:
to_string
(
&
json
)
?
}
)
}
}
fn
json_to_kind
<
T
>
(
mut
json
:
serde_json
:
:
Value
id
:
&
Guid
)
-
>
IncomingKind
<
T
>
where
T
:
for
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
{
if
let
serde_json
:
:
Value
:
:
Object
(
ref
mut
map
)
=
json
{
if
map
.
contains_key
(
"
deleted
"
)
{
return
IncomingKind
:
:
Tombstone
;
}
match
map
.
get
(
"
id
"
)
{
Some
(
serde_json
:
:
Value
:
:
String
(
content_id
)
)
=
>
{
if
content_id
!
=
id
{
log
:
:
trace
!
(
"
malformed
incoming
record
:
envelope
id
:
{
}
payload
id
:
{
}
"
content_id
id
)
;
report_error
!
(
"
incoming
-
invalid
-
mismatched
-
ids
"
"
Envelope
and
payload
don
'
t
agree
on
the
ID
"
)
;
return
IncomingKind
:
:
Malformed
;
}
if
!
id
.
is_valid_for_sync_server
(
)
{
log
:
:
trace
!
(
"
malformed
incoming
record
:
id
is
not
valid
:
{
}
"
id
)
;
report_error
!
(
"
incoming
-
invalid
-
bad
-
payload
-
id
"
"
ID
in
the
payload
is
invalid
"
)
;
return
IncomingKind
:
:
Malformed
;
}
log
:
:
info
!
(
"
incoming
record
has
'
id
'
in
the
payload
-
it
does
match
but
is
still
unexpected
"
)
;
}
Some
(
v
)
=
>
{
log
:
:
trace
!
(
"
malformed
incoming
record
:
id
is
not
a
string
:
{
}
"
v
)
;
report_error
!
(
"
incoming
-
invalid
-
wrong_type
"
"
ID
is
not
a
string
"
)
;
return
IncomingKind
:
:
Malformed
;
}
None
=
>
{
if
!
id
.
is_valid_for_sync_server
(
)
{
log
:
:
trace
!
(
"
malformed
incoming
record
:
id
is
not
valid
:
{
}
"
id
)
;
report_error
!
(
"
incoming
-
invalid
-
bad
-
envelope
-
id
"
"
ID
in
envelope
is
not
valid
"
)
;
return
IncomingKind
:
:
Malformed
;
}
map
.
insert
(
"
id
"
.
to_string
(
)
id
.
to_string
(
)
.
into
(
)
)
;
}
}
}
;
match
serde_json
:
:
from_value
(
json
)
{
Ok
(
v
)
=
>
IncomingKind
:
:
Content
(
v
)
Err
(
e
)
=
>
{
report_error
!
(
"
invalid
-
incoming
-
content
"
"
Invalid
incoming
T
:
{
}
"
e
)
;
IncomingKind
:
:
Malformed
}
}
}
fn
content_with_id_to_json
<
T
>
(
record
:
T
)
-
>
Result
<
(
serde_json
:
:
Value
Guid
)
>
where
T
:
Serialize
{
let
mut
json
=
serde_json
:
:
to_value
(
record
)
?
;
let
id
=
match
json
.
as_object_mut
(
)
{
Some
(
ref
mut
map
)
=
>
{
match
map
.
remove
(
"
id
"
)
.
as_ref
(
)
.
and_then
(
|
v
|
v
.
as_str
(
)
)
{
Some
(
id
)
=
>
{
let
id
:
Guid
=
id
.
into
(
)
;
assert
!
(
id
.
is_valid_for_sync_server
(
)
"
record
'
s
ID
is
invalid
"
)
;
id
}
None
=
>
panic
!
(
"
record
does
not
have
an
ID
in
the
payload
"
)
}
}
None
=
>
panic
!
(
"
record
is
not
a
json
object
"
)
}
;
Ok
(
(
json
id
)
)
}
fn
content_to_json
<
T
>
(
record
:
T
id
:
&
Guid
)
-
>
Result
<
serde_json
:
:
Value
>
where
T
:
Serialize
{
let
mut
payload
=
serde_json
:
:
to_value
(
record
)
?
;
if
let
Some
(
ref
mut
map
)
=
payload
.
as_object_mut
(
)
{
if
let
Some
(
content_id
)
=
map
.
remove
(
"
id
"
)
.
as_ref
(
)
.
and_then
(
|
v
|
v
.
as_str
(
)
)
{
assert_eq
!
(
content_id
id
)
;
assert
!
(
id
.
is_valid_for_sync_server
(
)
"
record
'
s
ID
is
invalid
"
)
;
}
}
;
Ok
(
payload
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
bso
:
:
IncomingBso
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
serde_json
:
:
json
;
#
[
derive
(
Default
Debug
PartialEq
Serialize
Deserialize
)
]
struct
TestStruct
{
id
:
Guid
data
:
u32
}
#
[
test
]
fn
test_content_deser
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
json
=
json
!
(
{
"
id
"
:
"
test
"
"
payload
"
:
json
!
(
{
"
data
"
:
1
}
)
.
to_string
(
)
}
)
;
let
incoming
:
IncomingBso
=
serde_json
:
:
from_value
(
json
)
.
unwrap
(
)
;
assert_eq
!
(
incoming
.
envelope
.
id
"
test
"
)
;
let
record
=
incoming
.
into_content
:
:
<
TestStruct
>
(
)
.
content
(
)
.
unwrap
(
)
;
let
expected
=
TestStruct
{
id
:
Guid
:
:
new
(
"
test
"
)
data
:
1
}
;
assert_eq
!
(
record
expected
)
;
}
#
[
test
]
fn
test_content_deser_empty_id
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
json
=
json
!
(
{
"
id
"
:
"
"
"
payload
"
:
json
!
(
{
"
data
"
:
1
}
)
.
to_string
(
)
}
)
;
let
incoming
:
IncomingBso
=
serde_json
:
:
from_value
(
json
)
.
unwrap
(
)
;
assert_eq
!
(
incoming
.
envelope
.
id
"
"
)
;
let
content
=
incoming
.
into_content
:
:
<
TestStruct
>
(
)
;
assert
!
(
matches
!
(
content
.
kind
IncomingKind
:
:
Malformed
)
)
;
}
#
[
test
]
fn
test_content_deser_invalid
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
json
=
json
!
(
{
"
id
"
:
"
X
"
.
repeat
(
65
)
"
payload
"
:
json
!
(
{
"
data
"
:
1
}
)
.
to_string
(
)
}
)
;
let
incoming
:
IncomingBso
=
serde_json
:
:
from_value
(
json
)
.
unwrap
(
)
;
let
content
=
incoming
.
into_content
:
:
<
TestStruct
>
(
)
;
assert
!
(
matches
!
(
content
.
kind
IncomingKind
:
:
Malformed
)
)
;
}
#
[
test
]
fn
test_content_deser_not_string
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
json
=
json
!
(
{
"
id
"
:
"
0
"
"
payload
"
:
json
!
(
{
"
id
"
:
0
"
data
"
:
1
}
)
.
to_string
(
)
}
)
;
let
incoming
:
IncomingBso
=
serde_json
:
:
from_value
(
json
)
.
unwrap
(
)
;
let
content
=
incoming
.
into_content
:
:
<
serde_json
:
:
Value
>
(
)
;
assert
!
(
matches
!
(
content
.
kind
IncomingKind
:
:
Malformed
)
)
;
}
#
[
test
]
fn
test_content_ser_with_id
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
val
=
TestStruct
{
id
:
Guid
:
:
new
(
"
test
"
)
data
:
1
}
;
let
outgoing
=
OutgoingBso
:
:
from_content_with_id
(
val
)
.
unwrap
(
)
;
assert_eq
!
(
outgoing
.
envelope
.
id
Guid
:
:
new
(
"
test
"
)
)
;
let
ct_value
=
serde_json
:
:
from_str
:
:
<
serde_json
:
:
Value
>
(
&
outgoing
.
payload
)
.
unwrap
(
)
;
assert_eq
!
(
ct_value
json
!
(
{
"
data
"
:
1
}
)
)
;
}
#
[
test
]
fn
test_content_ser_with_envelope
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
val
=
TestStruct
{
id
:
Guid
:
:
new
(
"
test
"
)
data
:
1
}
;
let
envelope
:
OutgoingEnvelope
=
Guid
:
:
new
(
"
test
"
)
.
into
(
)
;
let
outgoing
=
OutgoingBso
:
:
from_content
(
envelope
val
)
.
unwrap
(
)
;
assert_eq
!
(
outgoing
.
envelope
.
id
Guid
:
:
new
(
"
test
"
)
)
;
let
ct_value
=
serde_json
:
:
from_str
:
:
<
serde_json
:
:
Value
>
(
&
outgoing
.
payload
)
.
unwrap
(
)
;
assert_eq
!
(
ct_value
json
!
(
{
"
data
"
:
1
}
)
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_content_ser_no_ids
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
#
[
derive
(
Serialize
)
]
struct
StructWithNoId
{
data
:
u32
}
let
val
=
StructWithNoId
{
data
:
1
}
;
let
_
=
OutgoingBso
:
:
from_content_with_id
(
val
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_content_ser_not_object
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
_
=
OutgoingBso
:
:
from_content_with_id
(
json
!
(
"
string
"
)
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_content_ser_mismatched_ids
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
val
=
TestStruct
{
id
:
Guid
:
:
new
(
"
test
"
)
data
:
1
}
;
let
envelope
:
OutgoingEnvelope
=
Guid
:
:
new
(
"
different
"
)
.
into
(
)
;
let
_
=
OutgoingBso
:
:
from_content
(
envelope
val
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_content_empty_id
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
val
=
TestStruct
{
id
:
Guid
:
:
new
(
"
"
)
data
:
1
}
;
let
_
=
OutgoingBso
:
:
from_content_with_id
(
val
)
;
}
#
[
test
]
#
[
should_panic
]
fn
test_content_invalid_id
(
)
{
env_logger
:
:
try_init
(
)
.
ok
(
)
;
let
val
=
TestStruct
{
id
:
Guid
:
:
new
(
&
"
X
"
.
repeat
(
65
)
)
data
:
1
}
;
let
_
=
OutgoingBso
:
:
from_content_with_id
(
val
)
;
}
}
