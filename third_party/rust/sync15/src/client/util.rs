use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU32
Ordering
}
;
pub
(
crate
)
fn
atomic_update_max
(
v
:
&
AtomicU32
new
:
u32
)
{
let
mut
cur
=
v
.
load
(
Ordering
:
:
SeqCst
)
;
while
cur
<
new
{
match
v
.
compare_exchange_weak
(
cur
new
Ordering
:
:
SeqCst
Ordering
:
:
SeqCst
)
{
Ok
(
_
)
=
>
{
break
;
}
Err
(
new_cur
)
=
>
{
cur
=
new_cur
}
}
}
}
pub
(
crate
)
fn
set_union
(
a
:
&
HashSet
<
String
>
b
:
&
HashSet
<
String
>
)
-
>
HashSet
<
String
>
{
a
.
union
(
b
)
.
cloned
(
)
.
collect
(
)
}
pub
(
crate
)
fn
set_difference
(
a
:
&
HashSet
<
String
>
b
:
&
HashSet
<
String
>
)
-
>
HashSet
<
String
>
{
a
.
difference
(
b
)
.
cloned
(
)
.
collect
(
)
}
pub
(
crate
)
fn
set_intersection
(
a
:
&
HashSet
<
String
>
b
:
&
HashSet
<
String
>
)
-
>
HashSet
<
String
>
{
a
.
intersection
(
b
)
.
cloned
(
)
.
collect
(
)
}
pub
(
crate
)
fn
partition_by_value
(
v
:
&
HashMap
<
String
bool
>
)
-
>
(
HashSet
<
String
>
HashSet
<
String
>
)
{
let
mut
true_
:
HashSet
<
String
>
=
HashSet
:
:
new
(
)
;
let
mut
false_
:
HashSet
<
String
>
=
HashSet
:
:
new
(
)
;
for
(
s
val
)
in
v
{
if
*
val
{
true_
.
insert
(
s
.
clone
(
)
)
;
}
else
{
false_
.
insert
(
s
.
clone
(
)
)
;
}
}
(
true_
false_
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_set_ops
(
)
{
fn
hash_set
(
s
:
&
[
&
str
]
)
-
>
HashSet
<
String
>
{
s
.
iter
(
)
.
copied
(
)
.
map
(
ToOwned
:
:
to_owned
)
.
collect
:
:
<
HashSet
<
_
>
>
(
)
}
assert_eq
!
(
set_union
(
&
hash_set
(
&
[
"
a
"
"
b
"
"
c
"
]
)
&
hash_set
(
&
[
"
b
"
"
d
"
]
)
)
hash_set
(
&
[
"
a
"
"
b
"
"
c
"
"
d
"
]
)
)
;
assert_eq
!
(
set_difference
(
&
hash_set
(
&
[
"
a
"
"
b
"
"
c
"
]
)
&
hash_set
(
&
[
"
b
"
"
d
"
]
)
)
hash_set
(
&
[
"
a
"
"
c
"
]
)
)
;
assert_eq
!
(
set_intersection
(
&
hash_set
(
&
[
"
a
"
"
b
"
"
c
"
]
)
&
hash_set
(
&
[
"
b
"
"
d
"
]
)
)
hash_set
(
&
[
"
b
"
]
)
)
;
let
m
:
HashMap
<
String
bool
>
=
[
(
"
foo
"
true
)
(
"
bar
"
true
)
(
"
baz
"
false
)
(
"
quux
"
false
)
]
.
iter
(
)
.
copied
(
)
.
map
(
|
(
a
b
)
|
(
a
.
to_owned
(
)
b
)
)
.
collect
(
)
;
assert_eq
!
(
partition_by_value
(
&
m
)
(
hash_set
(
&
[
"
foo
"
"
bar
"
]
)
hash_set
(
&
[
"
baz
"
"
quux
"
]
)
)
)
;
}
}
