use
super
:
:
{
CollectionUpdate
GlobalState
LocalCollStateMachine
Sync15StorageClient
}
;
use
crate
:
:
clients_engine
;
use
crate
:
:
engine
:
:
SyncEngine
;
use
crate
:
:
error
:
:
{
info
warn
Error
}
;
use
crate
:
:
telemetry
;
use
crate
:
:
KeyBundle
;
use
interrupt_support
:
:
Interruptee
;
#
[
allow
(
clippy
:
:
too_many_arguments
)
]
pub
fn
synchronize_with_clients_engine
(
client
:
&
Sync15StorageClient
global_state
:
&
GlobalState
root_sync_key
:
&
KeyBundle
clients
:
Option
<
&
clients_engine
:
:
Engine
<
'
_
>
>
engine
:
&
dyn
SyncEngine
fully_atomic
:
bool
telem_engine
:
&
mut
telemetry
:
:
Engine
interruptee
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Error
>
{
let
collection
=
engine
.
collection_name
(
)
;
info
!
(
"
Syncing
collection
{
}
"
collection
)
;
let
coll_state
=
match
LocalCollStateMachine
:
:
get_state
(
engine
global_state
root_sync_key
)
?
{
Some
(
coll_state
)
=
>
coll_state
None
=
>
{
warn
!
(
"
can
'
t
setup
for
the
{
}
collection
-
hopefully
it
works
later
"
collection
)
;
return
Ok
(
(
)
)
;
}
}
;
if
let
Some
(
clients
)
=
clients
{
engine
.
prepare_for_sync
(
&
|
|
clients
.
get_client_data
(
)
)
?
;
}
interruptee
.
err_if_interrupted
(
)
?
;
match
engine
.
get_collection_request
(
coll_state
.
last_modified
)
?
{
None
=
>
{
info
!
(
"
skipping
incoming
for
{
}
-
not
needed
.
"
collection
)
;
}
Some
(
collection_request
)
=
>
{
let
incoming
=
super
:
:
fetch_incoming
(
client
&
coll_state
collection_request
)
?
;
info
!
(
"
Downloaded
{
}
remote
changes
"
incoming
.
len
(
)
)
;
engine
.
stage_incoming
(
incoming
telem_engine
)
?
;
interruptee
.
err_if_interrupted
(
)
?
;
}
}
;
info
!
(
"
Applying
changes
"
)
;
let
outgoing
=
engine
.
apply
(
coll_state
.
last_modified
telem_engine
)
?
;
interruptee
.
err_if_interrupted
(
)
?
;
info
!
(
"
Uploading
{
}
outgoing
changes
"
outgoing
.
len
(
)
)
;
let
upload_info
=
CollectionUpdate
:
:
new_from_changeset
(
client
&
coll_state
collection
outgoing
fully_atomic
)
?
.
upload
(
)
?
;
info
!
(
"
Upload
success
(
{
}
records
success
{
}
records
failed
)
"
upload_info
.
successful_ids
.
len
(
)
upload_info
.
failed_ids
.
len
(
)
)
;
let
mut
telem_outgoing
=
telemetry
:
:
EngineOutgoing
:
:
new
(
)
;
telem_outgoing
.
sent
(
upload_info
.
successful_ids
.
len
(
)
+
upload_info
.
failed_ids
.
len
(
)
)
;
telem_outgoing
.
failed
(
upload_info
.
failed_ids
.
len
(
)
)
;
telem_engine
.
outgoing
(
telem_outgoing
)
;
engine
.
set_uploaded
(
upload_info
.
modified_timestamp
upload_info
.
successful_ids
)
?
;
engine
.
sync_finished
(
)
?
;
info
!
(
"
Sync
finished
!
"
)
;
Ok
(
(
)
)
}
