use
std
:
:
cmp
:
:
min
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
use
std
:
:
io
:
:
IoSlice
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
:
:
{
self
size_of
MaybeUninit
}
;
use
std
:
:
net
:
:
Shutdown
;
use
std
:
:
net
:
:
{
Ipv4Addr
Ipv6Addr
}
;
#
[
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
]
use
std
:
:
num
:
:
NonZeroU32
;
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
linux
"
target_vendor
=
"
apple
"
)
)
)
]
use
std
:
:
num
:
:
NonZeroUsize
;
#
[
cfg
(
feature
=
"
all
"
)
]
use
std
:
:
os
:
:
unix
:
:
ffi
:
:
OsStrExt
;
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
linux
"
target_vendor
=
"
apple
"
)
)
)
]
use
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
{
AsRawFd
FromRawFd
IntoRawFd
}
;
#
[
cfg
(
feature
=
"
all
"
)
]
use
std
:
:
os
:
:
unix
:
:
net
:
:
{
UnixDatagram
UnixListener
UnixStream
}
;
#
[
cfg
(
feature
=
"
all
"
)
]
use
std
:
:
path
:
:
Path
;
#
[
cfg
(
not
(
all
(
target_os
=
"
redox
"
not
(
feature
=
"
all
"
)
)
)
)
]
use
std
:
:
ptr
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
std
:
:
{
io
slice
}
;
#
[
cfg
(
not
(
target_vendor
=
"
apple
"
)
)
]
use
libc
:
:
ssize_t
;
use
libc
:
:
{
c_void
in6_addr
in_addr
}
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
use
crate
:
:
RecvFlags
;
use
crate
:
:
{
Domain
Protocol
SockAddr
TcpKeepalive
Type
}
;
pub
(
crate
)
use
libc
:
:
c_int
;
pub
(
crate
)
use
libc
:
:
{
AF_INET
AF_INET6
}
;
#
[
cfg
(
all
(
feature
=
"
all
"
not
(
target_os
=
"
redox
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
SOCK_RAW
;
#
[
cfg
(
feature
=
"
all
"
)
]
pub
(
crate
)
use
libc
:
:
SOCK_SEQPACKET
;
pub
(
crate
)
use
libc
:
:
{
SOCK_DGRAM
SOCK_STREAM
}
;
pub
(
crate
)
use
libc
:
:
{
IPPROTO_ICMP
IPPROTO_ICMPV6
IPPROTO_TCP
IPPROTO_UDP
}
;
pub
(
crate
)
use
libc
:
:
{
sa_family_t
sockaddr
sockaddr_in
sockaddr_in6
sockaddr_storage
socklen_t
}
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
pub
(
crate
)
use
libc
:
:
{
MSG_TRUNC
SO_OOBINLINE
}
;
#
[
cfg
(
not
(
target_os
=
"
nto
"
)
)
]
pub
(
crate
)
use
libc
:
:
ipv6_mreq
as
Ipv6Mreq
;
#
[
cfg
(
all
(
feature
=
"
all
"
not
(
target_os
=
"
redox
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
IP_HDRINCL
;
#
[
cfg
(
not
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
haiku
"
target_os
=
"
nto
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
IP_RECVTOS
;
#
[
cfg
(
not
(
any
(
target_os
=
"
fuchsia
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
IP_TOS
;
#
[
cfg
(
not
(
target_vendor
=
"
apple
"
)
)
]
pub
(
crate
)
use
libc
:
:
SO_LINGER
;
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
pub
(
crate
)
use
libc
:
:
SO_LINGER_SEC
as
SO_LINGER
;
pub
(
crate
)
use
libc
:
:
{
ip_mreq
as
IpMreq
linger
IPPROTO_IP
IPPROTO_IPV6
IPV6_MULTICAST_HOPS
IPV6_MULTICAST_IF
IPV6_MULTICAST_LOOP
IPV6_UNICAST_HOPS
IPV6_V6ONLY
IP_ADD_MEMBERSHIP
IP_DROP_MEMBERSHIP
IP_MULTICAST_IF
IP_MULTICAST_LOOP
IP_MULTICAST_TTL
IP_TTL
MSG_OOB
MSG_PEEK
SOL_SOCKET
SO_BROADCAST
SO_ERROR
SO_KEEPALIVE
SO_RCVBUF
SO_RCVTIMEO
SO_REUSEADDR
SO_SNDBUF
SO_SNDTIMEO
SO_TYPE
TCP_NODELAY
}
;
#
[
cfg
(
not
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
haiku
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
fuchsia
"
target_os
=
"
nto
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
{
ip_mreq_source
as
IpMreqSource
IP_ADD_SOURCE_MEMBERSHIP
IP_DROP_SOURCE_MEMBERSHIP
}
;
#
[
cfg
(
not
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
solaris
"
target_os
=
"
nto
"
target_vendor
=
"
apple
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
{
IPV6_ADD_MEMBERSHIP
IPV6_DROP_MEMBERSHIP
}
;
#
[
cfg
(
any
(
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
haiku
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
solaris
"
target_vendor
=
"
apple
"
)
)
]
pub
(
crate
)
use
libc
:
:
{
IPV6_JOIN_GROUP
as
IPV6_ADD_MEMBERSHIP
IPV6_LEAVE_GROUP
as
IPV6_DROP_MEMBERSHIP
}
;
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_vendor
=
"
apple
"
)
)
)
]
pub
(
crate
)
use
libc
:
:
{
TCP_KEEPCNT
TCP_KEEPINTVL
}
;
pub
(
crate
)
type
Bool
=
c_int
;
#
[
cfg
(
any
(
target_vendor
=
"
apple
"
target_os
=
"
nto
"
)
)
]
use
libc
:
:
TCP_KEEPALIVE
as
KEEPALIVE_TIME
;
#
[
cfg
(
not
(
any
(
target_vendor
=
"
apple
"
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
target_os
=
"
nto
"
)
)
)
]
use
libc
:
:
TCP_KEEPIDLE
as
KEEPALIVE_TIME
;
macro_rules
!
syscall
{
(
fn
:
ident
(
(
arg
:
expr
)
*
(
)
*
)
)
=
>
{
{
#
[
allow
(
unused_unsafe
)
]
let
res
=
unsafe
{
libc
:
:
fn
(
(
arg
)
*
)
}
;
if
res
=
=
-
1
{
Err
(
std
:
:
io
:
:
Error
:
:
last_os_error
(
)
)
}
else
{
Ok
(
res
)
}
}
}
;
}
#
[
cfg
(
not
(
target_vendor
=
"
apple
"
)
)
]
const
MAX_BUF_LEN
:
usize
=
<
ssize_t
>
:
:
max_value
(
)
as
usize
;
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
const
MAX_BUF_LEN
:
usize
=
<
c_int
>
:
:
max_value
(
)
as
usize
-
1
;
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
any
(
target_env
=
"
gnu
"
all
(
target_env
=
"
uclibc
"
target_pointer_width
=
"
64
"
)
)
)
target_os
=
"
android
"
)
)
]
type
IovLen
=
usize
;
#
[
cfg
(
any
(
all
(
target_os
=
"
linux
"
any
(
target_env
=
"
musl
"
all
(
target_env
=
"
uclibc
"
target_pointer_width
=
"
32
"
)
)
)
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
haiku
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
solaris
"
target_os
=
"
nto
"
target_vendor
=
"
apple
"
)
)
]
type
IovLen
=
c_int
;
impl
Domain
{
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
pub
const
UNIX
:
Domain
=
Domain
(
libc
:
:
AF_UNIX
)
;
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
const
PACKET
:
Domain
=
Domain
(
libc
:
:
AF_PACKET
)
;
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
const
VSOCK
:
Domain
=
Domain
(
libc
:
:
AF_VSOCK
)
;
}
impl_debug
!
(
Domain
libc
:
:
AF_INET
libc
:
:
AF_INET6
libc
:
:
AF_UNIX
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
]
libc
:
:
AF_PACKET
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
)
]
libc
:
:
AF_VSOCK
libc
:
:
AF_UNSPEC
/
/
=
0
.
)
;
impl
Type
{
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
)
)
]
pub
const
fn
nonblocking
(
self
)
-
>
Type
{
Type
(
self
.
0
|
libc
:
:
SOCK_NONBLOCK
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
)
)
]
pub
const
fn
cloexec
(
self
)
-
>
Type
{
self
.
_cloexec
(
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
pub
(
crate
)
const
fn
_cloexec
(
self
)
-
>
Type
{
Type
(
self
.
0
|
libc
:
:
SOCK_CLOEXEC
)
}
}
impl_debug
!
(
Type
libc
:
:
SOCK_STREAM
libc
:
:
SOCK_DGRAM
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
libc
:
:
SOCK_RAW
#
[
cfg
(
not
(
any
(
target_os
=
"
redox
"
target_os
=
"
haiku
"
)
)
)
]
libc
:
:
SOCK_RDM
libc
:
:
SOCK_SEQPACKET
/
*
TODO
:
add
these
optional
bit
OR
-
ed
flags
:
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
libc
:
:
SOCK_NONBLOCK
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
libc
:
:
SOCK_CLOEXEC
*
/
)
;
impl_debug
!
(
Protocol
libc
:
:
IPPROTO_ICMP
libc
:
:
IPPROTO_ICMPV6
libc
:
:
IPPROTO_TCP
libc
:
:
IPPROTO_UDP
)
;
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
impl
RecvFlags
{
pub
const
fn
is_end_of_record
(
self
)
-
>
bool
{
self
.
0
&
libc
:
:
MSG_EOR
!
=
0
}
pub
const
fn
is_out_of_band
(
self
)
-
>
bool
{
self
.
0
&
libc
:
:
MSG_OOB
!
=
0
}
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
impl
std
:
:
fmt
:
:
Debug
for
RecvFlags
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
"
RecvFlags
"
)
.
field
(
"
is_end_of_record
"
&
self
.
is_end_of_record
(
)
)
.
field
(
"
is_out_of_band
"
&
self
.
is_out_of_band
(
)
)
.
field
(
"
is_truncated
"
&
self
.
is_truncated
(
)
)
.
finish
(
)
}
}
#
[
repr
(
transparent
)
]
pub
struct
MaybeUninitSlice
<
'
a
>
{
vec
:
libc
:
:
iovec
_lifetime
:
PhantomData
<
&
'
a
mut
[
MaybeUninit
<
u8
>
]
>
}
unsafe
impl
<
'
a
>
Send
for
MaybeUninitSlice
<
'
a
>
{
}
unsafe
impl
<
'
a
>
Sync
for
MaybeUninitSlice
<
'
a
>
{
}
impl
<
'
a
>
MaybeUninitSlice
<
'
a
>
{
pub
(
crate
)
fn
new
(
buf
:
&
'
a
mut
[
MaybeUninit
<
u8
>
]
)
-
>
MaybeUninitSlice
<
'
a
>
{
MaybeUninitSlice
{
vec
:
libc
:
:
iovec
{
iov_base
:
buf
.
as_mut_ptr
(
)
.
cast
(
)
iov_len
:
buf
.
len
(
)
}
_lifetime
:
PhantomData
}
}
pub
(
crate
)
fn
as_slice
(
&
self
)
-
>
&
[
MaybeUninit
<
u8
>
]
{
unsafe
{
slice
:
:
from_raw_parts
(
self
.
vec
.
iov_base
.
cast
(
)
self
.
vec
.
iov_len
)
}
}
pub
(
crate
)
fn
as_mut_slice
(
&
mut
self
)
-
>
&
mut
[
MaybeUninit
<
u8
>
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
vec
.
iov_base
.
cast
(
)
self
.
vec
.
iov_len
)
}
}
}
impl
SockAddr
{
#
[
cfg
(
feature
=
"
all
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
unix
feature
=
"
all
"
)
)
)
)
]
#
[
allow
(
unused_unsafe
)
]
pub
fn
unix
<
P
>
(
path
:
P
)
-
>
io
:
:
Result
<
SockAddr
>
where
P
:
AsRef
<
Path
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
{
let
storage
:
&
mut
libc
:
:
sockaddr_un
=
unsafe
{
&
mut
*
storage
.
cast
(
)
}
;
let
len
:
&
mut
socklen_t
=
unsafe
{
&
mut
*
len
}
;
let
bytes
=
path
.
as_ref
(
)
.
as_os_str
(
)
.
as_bytes
(
)
;
let
too_long
=
match
bytes
.
first
(
)
{
None
=
>
false
Some
(
&
0
)
=
>
bytes
.
len
(
)
>
storage
.
sun_path
.
len
(
)
Some
(
_
)
=
>
bytes
.
len
(
)
>
=
storage
.
sun_path
.
len
(
)
}
;
if
too_long
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
InvalidInput
"
path
must
be
shorter
than
SUN_LEN
"
)
)
;
}
storage
.
sun_family
=
libc
:
:
AF_UNIX
as
sa_family_t
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
bytes
.
as_ptr
(
)
storage
.
sun_path
.
as_mut_ptr
(
)
as
*
mut
u8
bytes
.
len
(
)
)
}
;
let
base
=
storage
as
*
const
_
as
usize
;
let
path
=
&
storage
.
sun_path
as
*
const
_
as
usize
;
let
sun_path_offset
=
path
-
base
;
let
length
=
sun_path_offset
+
bytes
.
len
(
)
+
match
bytes
.
first
(
)
{
Some
(
&
0
)
|
None
=
>
0
Some
(
_
)
=
>
1
}
;
*
len
=
length
as
socklen_t
;
Ok
(
(
)
)
}
)
}
.
map
(
|
(
_
addr
)
|
addr
)
}
}
impl
SockAddr
{
#
[
allow
(
unused_unsafe
)
]
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
vsock
(
cid
:
u32
port
:
u32
)
-
>
io
:
:
Result
<
SockAddr
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
{
let
storage
:
&
mut
libc
:
:
sockaddr_vm
=
unsafe
{
&
mut
*
storage
.
cast
(
)
}
;
let
len
:
&
mut
socklen_t
=
unsafe
{
&
mut
*
len
}
;
storage
.
svm_family
=
libc
:
:
AF_VSOCK
as
sa_family_t
;
storage
.
svm_cid
=
cid
;
storage
.
svm_port
=
port
;
*
len
=
mem
:
:
size_of
:
:
<
libc
:
:
sockaddr_vm
>
(
)
as
socklen_t
;
Ok
(
(
)
)
}
)
}
.
map
(
|
(
_
addr
)
|
addr
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
vsock_address
(
&
self
)
-
>
Option
<
(
u32
u32
)
>
{
if
self
.
family
(
)
=
=
libc
:
:
AF_VSOCK
as
sa_family_t
{
let
addr
=
unsafe
{
&
*
(
self
.
as_ptr
(
)
as
*
const
libc
:
:
sockaddr_vm
)
}
;
Some
(
(
addr
.
svm_cid
addr
.
svm_port
)
)
}
else
{
None
}
}
}
pub
(
crate
)
type
Socket
=
c_int
;
pub
(
crate
)
unsafe
fn
socket_from_raw
(
socket
:
Socket
)
-
>
crate
:
:
socket
:
:
Inner
{
crate
:
:
socket
:
:
Inner
:
:
from_raw_fd
(
socket
)
}
pub
(
crate
)
fn
socket_as_raw
(
socket
:
&
crate
:
:
socket
:
:
Inner
)
-
>
Socket
{
socket
.
as_raw_fd
(
)
}
pub
(
crate
)
fn
socket_into_raw
(
socket
:
crate
:
:
socket
:
:
Inner
)
-
>
Socket
{
socket
.
into_raw_fd
(
)
}
pub
(
crate
)
fn
socket
(
family
:
c_int
ty
:
c_int
protocol
:
c_int
)
-
>
io
:
:
Result
<
Socket
>
{
syscall
!
(
socket
(
family
ty
protocol
)
)
}
#
[
cfg
(
feature
=
"
all
"
)
]
pub
(
crate
)
fn
socketpair
(
family
:
c_int
ty
:
c_int
protocol
:
c_int
)
-
>
io
:
:
Result
<
[
Socket
;
2
]
>
{
let
mut
fds
=
[
0
0
]
;
syscall
!
(
socketpair
(
family
ty
protocol
fds
.
as_mut_ptr
(
)
)
)
.
map
(
|
_
|
fds
)
}
pub
(
crate
)
fn
bind
(
fd
:
Socket
addr
:
&
SockAddr
)
-
>
io
:
:
Result
<
(
)
>
{
syscall
!
(
bind
(
fd
addr
.
as_ptr
(
)
addr
.
len
(
)
as
_
)
)
.
map
(
|
_
|
(
)
)
}
pub
(
crate
)
fn
connect
(
fd
:
Socket
addr
:
&
SockAddr
)
-
>
io
:
:
Result
<
(
)
>
{
syscall
!
(
connect
(
fd
addr
.
as_ptr
(
)
addr
.
len
(
)
)
)
.
map
(
|
_
|
(
)
)
}
pub
(
crate
)
fn
poll_connect
(
socket
:
&
crate
:
:
Socket
timeout
:
Duration
)
-
>
io
:
:
Result
<
(
)
>
{
let
start
=
Instant
:
:
now
(
)
;
let
mut
pollfd
=
libc
:
:
pollfd
{
fd
:
socket
.
as_raw
(
)
events
:
libc
:
:
POLLIN
|
libc
:
:
POLLOUT
revents
:
0
}
;
loop
{
let
elapsed
=
start
.
elapsed
(
)
;
if
elapsed
>
=
timeout
{
return
Err
(
io
:
:
ErrorKind
:
:
TimedOut
.
into
(
)
)
;
}
let
timeout
=
(
timeout
-
elapsed
)
.
as_millis
(
)
;
let
timeout
=
clamp
(
timeout
1
c_int
:
:
max_value
(
)
as
u128
)
as
c_int
;
match
syscall
!
(
poll
(
&
mut
pollfd
1
timeout
)
)
{
Ok
(
0
)
=
>
return
Err
(
io
:
:
ErrorKind
:
:
TimedOut
.
into
(
)
)
Ok
(
_
)
=
>
{
if
(
pollfd
.
revents
&
libc
:
:
POLLHUP
)
!
=
0
|
|
(
pollfd
.
revents
&
libc
:
:
POLLERR
)
!
=
0
{
match
socket
.
take_error
(
)
{
Ok
(
Some
(
err
)
)
=
>
return
Err
(
err
)
Ok
(
None
)
=
>
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
no
error
set
after
POLLHUP
"
)
)
}
Err
(
err
)
=
>
return
Err
(
err
)
}
}
return
Ok
(
(
)
)
;
}
Err
(
ref
err
)
if
err
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
Interrupted
=
>
continue
Err
(
err
)
=
>
return
Err
(
err
)
}
}
}
fn
clamp
<
T
>
(
value
:
T
min
:
T
max
:
T
)
-
>
T
where
T
:
Ord
{
if
value
<
=
min
{
min
}
else
if
value
>
=
max
{
max
}
else
{
value
}
}
pub
(
crate
)
fn
listen
(
fd
:
Socket
backlog
:
c_int
)
-
>
io
:
:
Result
<
(
)
>
{
syscall
!
(
listen
(
fd
backlog
)
)
.
map
(
|
_
|
(
)
)
}
pub
(
crate
)
fn
accept
(
fd
:
Socket
)
-
>
io
:
:
Result
<
(
Socket
SockAddr
)
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
syscall
!
(
accept
(
fd
storage
.
cast
(
)
len
)
)
)
}
}
pub
(
crate
)
fn
getsockname
(
fd
:
Socket
)
-
>
io
:
:
Result
<
SockAddr
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
syscall
!
(
getsockname
(
fd
storage
.
cast
(
)
len
)
)
)
}
.
map
(
|
(
_
addr
)
|
addr
)
}
pub
(
crate
)
fn
getpeername
(
fd
:
Socket
)
-
>
io
:
:
Result
<
SockAddr
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
syscall
!
(
getpeername
(
fd
storage
.
cast
(
)
len
)
)
)
}
.
map
(
|
(
_
addr
)
|
addr
)
}
pub
(
crate
)
fn
try_clone
(
fd
:
Socket
)
-
>
io
:
:
Result
<
Socket
>
{
syscall
!
(
fcntl
(
fd
libc
:
:
F_DUPFD_CLOEXEC
0
)
)
}
pub
(
crate
)
fn
set_nonblocking
(
fd
:
Socket
nonblocking
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
if
nonblocking
{
fcntl_add
(
fd
libc
:
:
F_GETFL
libc
:
:
F_SETFL
libc
:
:
O_NONBLOCK
)
}
else
{
fcntl_remove
(
fd
libc
:
:
F_GETFL
libc
:
:
F_SETFL
libc
:
:
O_NONBLOCK
)
}
}
pub
(
crate
)
fn
shutdown
(
fd
:
Socket
how
:
Shutdown
)
-
>
io
:
:
Result
<
(
)
>
{
let
how
=
match
how
{
Shutdown
:
:
Write
=
>
libc
:
:
SHUT_WR
Shutdown
:
:
Read
=
>
libc
:
:
SHUT_RD
Shutdown
:
:
Both
=
>
libc
:
:
SHUT_RDWR
}
;
syscall
!
(
shutdown
(
fd
how
)
)
.
map
(
|
_
|
(
)
)
}
pub
(
crate
)
fn
recv
(
fd
:
Socket
buf
:
&
mut
[
MaybeUninit
<
u8
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
usize
>
{
syscall
!
(
recv
(
fd
buf
.
as_mut_ptr
(
)
.
cast
(
)
min
(
buf
.
len
(
)
MAX_BUF_LEN
)
flags
)
)
.
map
(
|
n
|
n
as
usize
)
}
pub
(
crate
)
fn
recv_from
(
fd
:
Socket
buf
:
&
mut
[
MaybeUninit
<
u8
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
(
usize
SockAddr
)
>
{
unsafe
{
SockAddr
:
:
init
(
|
addr
addrlen
|
{
syscall
!
(
recvfrom
(
fd
buf
.
as_mut_ptr
(
)
.
cast
(
)
min
(
buf
.
len
(
)
MAX_BUF_LEN
)
flags
addr
.
cast
(
)
addrlen
)
)
.
map
(
|
n
|
n
as
usize
)
}
)
}
}
pub
(
crate
)
fn
peek_sender
(
fd
:
Socket
)
-
>
io
:
:
Result
<
SockAddr
>
{
let
(
_
sender
)
=
recv_from
(
fd
&
mut
[
MaybeUninit
:
:
uninit
(
)
;
8
]
MSG_PEEK
)
?
;
Ok
(
sender
)
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
pub
(
crate
)
fn
recv_vectored
(
fd
:
Socket
bufs
:
&
mut
[
crate
:
:
MaybeUninitSlice
<
'
_
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
(
usize
RecvFlags
)
>
{
recvmsg
(
fd
ptr
:
:
null_mut
(
)
bufs
flags
)
.
map
(
|
(
n
_
recv_flags
)
|
(
n
recv_flags
)
)
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
pub
(
crate
)
fn
recv_from_vectored
(
fd
:
Socket
bufs
:
&
mut
[
crate
:
:
MaybeUninitSlice
<
'
_
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
(
usize
RecvFlags
SockAddr
)
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
{
recvmsg
(
fd
storage
bufs
flags
)
.
map
(
|
(
n
addrlen
recv_flags
)
|
{
*
len
=
addrlen
;
(
n
recv_flags
)
}
)
}
)
}
.
map
(
|
(
(
n
recv_flags
)
addr
)
|
(
n
recv_flags
addr
)
)
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
fn
recvmsg
(
fd
:
Socket
msg_name
:
*
mut
sockaddr_storage
bufs
:
&
mut
[
crate
:
:
MaybeUninitSlice
<
'
_
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
(
usize
libc
:
:
socklen_t
RecvFlags
)
>
{
let
msg_namelen
=
if
msg_name
.
is_null
(
)
{
0
}
else
{
size_of
:
:
<
sockaddr_storage
>
(
)
as
libc
:
:
socklen_t
}
;
let
mut
msg
:
libc
:
:
msghdr
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
msg
.
msg_name
=
msg_name
.
cast
(
)
;
msg
.
msg_namelen
=
msg_namelen
;
msg
.
msg_iov
=
bufs
.
as_mut_ptr
(
)
.
cast
(
)
;
msg
.
msg_iovlen
=
min
(
bufs
.
len
(
)
IovLen
:
:
MAX
as
usize
)
as
IovLen
;
syscall
!
(
recvmsg
(
fd
&
mut
msg
flags
)
)
.
map
(
|
n
|
(
n
as
usize
msg
.
msg_namelen
RecvFlags
(
msg
.
msg_flags
)
)
)
}
pub
(
crate
)
fn
send
(
fd
:
Socket
buf
:
&
[
u8
]
flags
:
c_int
)
-
>
io
:
:
Result
<
usize
>
{
syscall
!
(
send
(
fd
buf
.
as_ptr
(
)
.
cast
(
)
min
(
buf
.
len
(
)
MAX_BUF_LEN
)
flags
)
)
.
map
(
|
n
|
n
as
usize
)
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
pub
(
crate
)
fn
send_vectored
(
fd
:
Socket
bufs
:
&
[
IoSlice
<
'
_
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
usize
>
{
sendmsg
(
fd
ptr
:
:
null
(
)
0
bufs
flags
)
}
pub
(
crate
)
fn
send_to
(
fd
:
Socket
buf
:
&
[
u8
]
addr
:
&
SockAddr
flags
:
c_int
)
-
>
io
:
:
Result
<
usize
>
{
syscall
!
(
sendto
(
fd
buf
.
as_ptr
(
)
.
cast
(
)
min
(
buf
.
len
(
)
MAX_BUF_LEN
)
flags
addr
.
as_ptr
(
)
addr
.
len
(
)
)
)
.
map
(
|
n
|
n
as
usize
)
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
pub
(
crate
)
fn
send_to_vectored
(
fd
:
Socket
bufs
:
&
[
IoSlice
<
'
_
>
]
addr
:
&
SockAddr
flags
:
c_int
)
-
>
io
:
:
Result
<
usize
>
{
sendmsg
(
fd
addr
.
as_storage_ptr
(
)
addr
.
len
(
)
bufs
flags
)
}
#
[
cfg
(
not
(
target_os
=
"
redox
"
)
)
]
fn
sendmsg
(
fd
:
Socket
msg_name
:
*
const
sockaddr_storage
msg_namelen
:
socklen_t
bufs
:
&
[
IoSlice
<
'
_
>
]
flags
:
c_int
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
msg
:
libc
:
:
msghdr
=
unsafe
{
mem
:
:
zeroed
(
)
}
;
msg
.
msg_name
=
(
msg_name
as
*
mut
sockaddr_storage
)
.
cast
(
)
;
msg
.
msg_namelen
=
msg_namelen
;
msg
.
msg_iov
=
bufs
.
as_ptr
(
)
as
*
mut
_
;
msg
.
msg_iovlen
=
min
(
bufs
.
len
(
)
IovLen
:
:
MAX
as
usize
)
as
IovLen
;
syscall
!
(
sendmsg
(
fd
&
msg
flags
)
)
.
map
(
|
n
|
n
as
usize
)
}
pub
(
crate
)
fn
timeout_opt
(
fd
:
Socket
opt
:
c_int
val
:
c_int
)
-
>
io
:
:
Result
<
Option
<
Duration
>
>
{
unsafe
{
getsockopt
(
fd
opt
val
)
.
map
(
from_timeval
)
}
}
fn
from_timeval
(
duration
:
libc
:
:
timeval
)
-
>
Option
<
Duration
>
{
if
duration
.
tv_sec
=
=
0
&
&
duration
.
tv_usec
=
=
0
{
None
}
else
{
let
sec
=
duration
.
tv_sec
as
u64
;
let
nsec
=
(
duration
.
tv_usec
as
u32
)
*
1000
;
Some
(
Duration
:
:
new
(
sec
nsec
)
)
}
}
pub
(
crate
)
fn
set_timeout_opt
(
fd
:
Socket
opt
:
c_int
val
:
c_int
duration
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
duration
=
into_timeval
(
duration
)
;
unsafe
{
setsockopt
(
fd
opt
val
duration
)
}
}
fn
into_timeval
(
duration
:
Option
<
Duration
>
)
-
>
libc
:
:
timeval
{
match
duration
{
#
[
cfg_attr
(
target_env
=
"
musl
"
allow
(
deprecated
)
)
]
Some
(
duration
)
=
>
libc
:
:
timeval
{
tv_sec
:
min
(
duration
.
as_secs
(
)
libc
:
:
time_t
:
:
max_value
(
)
as
u64
)
as
libc
:
:
time_t
tv_usec
:
duration
.
subsec_micros
(
)
as
libc
:
:
suseconds_t
}
None
=
>
libc
:
:
timeval
{
tv_sec
:
0
tv_usec
:
0
}
}
}
#
[
cfg
(
feature
=
"
all
"
)
]
#
[
cfg
(
not
(
any
(
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
)
)
)
]
pub
(
crate
)
fn
keepalive_time
(
fd
:
Socket
)
-
>
io
:
:
Result
<
Duration
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
fd
IPPROTO_TCP
KEEPALIVE_TIME
)
.
map
(
|
secs
|
Duration
:
:
from_secs
(
secs
as
u64
)
)
}
}
#
[
allow
(
unused_variables
)
]
pub
(
crate
)
fn
set_tcp_keepalive
(
fd
:
Socket
keepalive
:
&
TcpKeepalive
)
-
>
io
:
:
Result
<
(
)
>
{
#
[
cfg
(
not
(
any
(
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
target_os
=
"
nto
"
)
)
)
]
if
let
Some
(
time
)
=
keepalive
.
time
{
let
secs
=
into_secs
(
time
)
;
unsafe
{
setsockopt
(
fd
libc
:
:
IPPROTO_TCP
KEEPALIVE_TIME
secs
)
?
}
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_vendor
=
"
apple
"
)
)
]
{
if
let
Some
(
interval
)
=
keepalive
.
interval
{
let
secs
=
into_secs
(
interval
)
;
unsafe
{
setsockopt
(
fd
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_KEEPINTVL
secs
)
?
}
}
if
let
Some
(
retries
)
=
keepalive
.
retries
{
unsafe
{
setsockopt
(
fd
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_KEEPCNT
retries
as
c_int
)
?
}
}
}
#
[
cfg
(
target_os
=
"
nto
"
)
]
if
let
Some
(
time
)
=
keepalive
.
time
{
let
secs
=
into_timeval
(
Some
(
time
)
)
;
unsafe
{
setsockopt
(
fd
libc
:
:
IPPROTO_TCP
KEEPALIVE_TIME
secs
)
?
}
}
Ok
(
(
)
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
haiku
"
target_os
=
"
openbsd
"
target_os
=
"
nto
"
)
)
)
]
fn
into_secs
(
duration
:
Duration
)
-
>
c_int
{
min
(
duration
.
as_secs
(
)
c_int
:
:
max_value
(
)
as
u64
)
as
c_int
}
fn
fcntl_add
(
fd
:
Socket
get_cmd
:
c_int
set_cmd
:
c_int
flag
:
c_int
)
-
>
io
:
:
Result
<
(
)
>
{
let
previous
=
syscall
!
(
fcntl
(
fd
get_cmd
)
)
?
;
let
new
=
previous
|
flag
;
if
new
!
=
previous
{
syscall
!
(
fcntl
(
fd
set_cmd
new
)
)
.
map
(
|
_
|
(
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
fcntl_remove
(
fd
:
Socket
get_cmd
:
c_int
set_cmd
:
c_int
flag
:
c_int
)
-
>
io
:
:
Result
<
(
)
>
{
let
previous
=
syscall
!
(
fcntl
(
fd
get_cmd
)
)
?
;
let
new
=
previous
&
!
flag
;
if
new
!
=
previous
{
syscall
!
(
fcntl
(
fd
set_cmd
new
)
)
.
map
(
|
_
|
(
)
)
}
else
{
Ok
(
(
)
)
}
}
pub
(
crate
)
unsafe
fn
getsockopt
<
T
>
(
fd
:
Socket
opt
:
c_int
val
:
c_int
)
-
>
io
:
:
Result
<
T
>
{
let
mut
payload
:
MaybeUninit
<
T
>
=
MaybeUninit
:
:
uninit
(
)
;
let
mut
len
=
size_of
:
:
<
T
>
(
)
as
libc
:
:
socklen_t
;
syscall
!
(
getsockopt
(
fd
opt
val
payload
.
as_mut_ptr
(
)
.
cast
(
)
&
mut
len
)
)
.
map
(
|
_
|
{
debug_assert_eq
!
(
len
as
usize
size_of
:
:
<
T
>
(
)
)
;
payload
.
assume_init
(
)
}
)
}
pub
(
crate
)
unsafe
fn
setsockopt
<
T
>
(
fd
:
Socket
opt
:
c_int
val
:
c_int
payload
:
T
)
-
>
io
:
:
Result
<
(
)
>
{
let
payload
=
&
payload
as
*
const
T
as
*
const
c_void
;
syscall
!
(
setsockopt
(
fd
opt
val
payload
mem
:
:
size_of
:
:
<
T
>
(
)
as
libc
:
:
socklen_t
)
)
.
map
(
|
_
|
(
)
)
}
pub
(
crate
)
fn
to_in_addr
(
addr
:
&
Ipv4Addr
)
-
>
in_addr
{
in_addr
{
s_addr
:
u32
:
:
from_ne_bytes
(
addr
.
octets
(
)
)
}
}
pub
(
crate
)
fn
from_in_addr
(
in_addr
:
in_addr
)
-
>
Ipv4Addr
{
Ipv4Addr
:
:
from
(
in_addr
.
s_addr
.
to_ne_bytes
(
)
)
}
pub
(
crate
)
fn
to_in6_addr
(
addr
:
&
Ipv6Addr
)
-
>
in6_addr
{
in6_addr
{
s6_addr
:
addr
.
octets
(
)
}
}
pub
(
crate
)
fn
from_in6_addr
(
addr
:
in6_addr
)
-
>
Ipv6Addr
{
Ipv6Addr
:
:
from
(
addr
.
s6_addr
)
}
#
[
cfg
(
not
(
any
(
target_os
=
"
haiku
"
target_os
=
"
illumos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
nto
"
)
)
)
]
pub
(
crate
)
fn
to_mreqn
(
multiaddr
:
&
Ipv4Addr
interface
:
&
crate
:
:
socket
:
:
InterfaceIndexOrAddress
)
-
>
libc
:
:
ip_mreqn
{
match
interface
{
crate
:
:
socket
:
:
InterfaceIndexOrAddress
:
:
Index
(
interface
)
=
>
libc
:
:
ip_mreqn
{
imr_multiaddr
:
to_in_addr
(
multiaddr
)
imr_address
:
to_in_addr
(
&
Ipv4Addr
:
:
UNSPECIFIED
)
imr_ifindex
:
*
interface
as
_
}
crate
:
:
socket
:
:
InterfaceIndexOrAddress
:
:
Address
(
interface
)
=
>
libc
:
:
ip_mreqn
{
imr_multiaddr
:
to_in_addr
(
multiaddr
)
imr_address
:
to_in_addr
(
interface
)
imr_ifindex
:
0
}
}
}
impl
crate
:
:
Socket
{
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
)
)
)
]
pub
fn
accept4
(
&
self
flags
:
c_int
)
-
>
io
:
:
Result
<
(
crate
:
:
Socket
SockAddr
)
>
{
self
.
_accept4
(
flags
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
dragonfly
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
illumos
"
target_os
=
"
linux
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
)
)
]
pub
(
crate
)
fn
_accept4
(
&
self
flags
:
c_int
)
-
>
io
:
:
Result
<
(
crate
:
:
Socket
SockAddr
)
>
{
unsafe
{
SockAddr
:
:
init
(
|
storage
len
|
{
syscall
!
(
accept4
(
self
.
as_raw
(
)
storage
.
cast
(
)
len
flags
)
)
.
map
(
crate
:
:
Socket
:
:
from_raw
)
}
)
}
}
#
[
cfg
(
feature
=
"
all
"
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
unix
)
)
)
)
]
pub
fn
set_cloexec
(
&
self
close_on_exec
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_set_cloexec
(
close_on_exec
)
}
pub
(
crate
)
fn
_set_cloexec
(
&
self
close_on_exec
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
if
close_on_exec
{
fcntl_add
(
self
.
as_raw
(
)
libc
:
:
F_GETFD
libc
:
:
F_SETFD
libc
:
:
FD_CLOEXEC
)
}
else
{
fcntl_remove
(
self
.
as_raw
(
)
libc
:
:
F_GETFD
libc
:
:
F_SETFD
libc
:
:
FD_CLOEXEC
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
doc
target_vendor
=
"
apple
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
)
)
]
pub
fn
set_nosigpipe
(
&
self
nosigpipe
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
_set_nosigpipe
(
nosigpipe
)
}
#
[
cfg
(
target_vendor
=
"
apple
"
)
]
pub
(
crate
)
fn
_set_nosigpipe
(
&
self
nosigpipe
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_NOSIGPIPE
nosigpipe
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
not
(
target_os
=
"
redox
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
unix
not
(
target_os
=
"
redox
"
)
)
)
)
)
]
pub
fn
mss
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_MAXSEG
)
.
map
(
|
mss
|
mss
as
u32
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
not
(
target_os
=
"
redox
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
unix
not
(
target_os
=
"
redox
"
)
)
)
)
)
]
pub
fn
set_mss
(
&
self
mss
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_MAXSEG
mss
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
is_listener
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_ACCEPTCONN
)
.
map
(
|
v
|
v
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
domain
(
&
self
)
-
>
io
:
:
Result
<
Domain
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_DOMAIN
)
.
map
(
Domain
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
protocol
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Protocol
>
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_PROTOCOL
)
.
map
(
|
v
|
match
v
{
0
=
>
None
p
=
>
Some
(
Protocol
(
p
)
)
}
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
mark
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_MARK
)
.
map
(
|
mark
|
mark
as
u32
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_mark
(
&
self
mark
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_MARK
mark
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
cork
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
Bool
>
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_CORK
)
.
map
(
|
cork
|
cork
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_cork
(
&
self
cork
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_CORK
cork
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
quickack
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
Bool
>
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_QUICKACK
)
.
map
(
|
quickack
|
quickack
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_quickack
(
&
self
quickack
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_QUICKACK
quickack
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
thin_linear_timeouts
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
Bool
>
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_THIN_LINEAR_TIMEOUTS
)
.
map
(
|
timeouts
|
timeouts
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_thin_linear_timeouts
(
&
self
timeouts
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_THIN_LINEAR_TIMEOUTS
timeouts
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
device
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Vec
<
u8
>
>
>
{
let
mut
buf
:
[
MaybeUninit
<
u8
>
;
libc
:
:
IFNAMSIZ
]
=
unsafe
{
MaybeUninit
:
:
uninit
(
)
.
assume_init
(
)
}
;
let
mut
len
=
buf
.
len
(
)
as
libc
:
:
socklen_t
;
syscall
!
(
getsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_BINDTODEVICE
buf
.
as_mut_ptr
(
)
.
cast
(
)
&
mut
len
)
)
?
;
if
len
=
=
0
{
Ok
(
None
)
}
else
{
let
buf
=
&
buf
[
.
.
len
as
usize
-
1
]
;
Ok
(
Some
(
unsafe
{
&
*
(
buf
as
*
const
[
_
]
as
*
const
[
u8
]
)
}
.
into
(
)
)
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
bind_device
(
&
self
interface
:
Option
<
&
[
u8
]
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
(
value
len
)
=
if
let
Some
(
interface
)
=
interface
{
(
interface
.
as_ptr
(
)
interface
.
len
(
)
)
}
else
{
(
ptr
:
:
null
(
)
0
)
}
;
syscall
!
(
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_BINDTODEVICE
value
.
cast
(
)
len
as
libc
:
:
socklen_t
)
)
.
map
(
|
_
|
(
)
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
freebsd
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
freebsd
"
)
)
)
)
)
]
pub
fn
set_fib
(
&
self
fib
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
syscall
!
(
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_SETFIB
(
&
fib
as
*
const
u32
)
.
cast
(
)
mem
:
:
size_of
:
:
<
u32
>
(
)
as
libc
:
:
socklen_t
)
)
.
map
(
|
_
|
(
)
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
)
)
]
pub
fn
bind_device_by_index
(
&
self
interface
:
Option
<
NonZeroU32
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
index
=
interface
.
map
(
NonZeroU32
:
:
get
)
.
unwrap_or
(
0
)
;
unsafe
{
setsockopt
(
self
.
as_raw
(
)
IPPROTO_IP
libc
:
:
IP_BOUND_IF
index
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
)
)
]
pub
fn
device_index
(
&
self
)
-
>
io
:
:
Result
<
Option
<
NonZeroU32
>
>
{
let
index
=
unsafe
{
getsockopt
:
:
<
libc
:
:
c_uint
>
(
self
.
as_raw
(
)
IPPROTO_IP
libc
:
:
IP_BOUND_IF
)
?
}
;
Ok
(
NonZeroU32
:
:
new
(
index
)
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
target_os
=
"
linux
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
target_os
=
"
linux
"
)
)
)
)
]
pub
fn
cpu_affinity
(
&
self
)
-
>
io
:
:
Result
<
usize
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_INCOMING_CPU
)
.
map
(
|
cpu
|
cpu
as
usize
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
target_os
=
"
linux
"
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
target_os
=
"
linux
"
)
)
)
)
]
pub
fn
set_cpu_affinity
(
&
self
cpu
:
usize
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_INCOMING_CPU
cpu
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
not
(
any
(
target_os
=
"
solaris
"
target_os
=
"
illumos
"
)
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
unix
not
(
any
(
target_os
=
"
solaris
"
target_os
=
"
illumos
"
)
)
)
)
)
)
]
pub
fn
reuse_port
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_REUSEPORT
)
.
map
(
|
reuse
|
reuse
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
not
(
any
(
target_os
=
"
solaris
"
target_os
=
"
illumos
"
)
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
unix
not
(
any
(
target_os
=
"
solaris
"
target_os
=
"
illumos
"
)
)
)
)
)
)
]
pub
fn
set_reuse_port
(
&
self
reuse
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_REUSEPORT
reuse
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
freebind
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_IP
libc
:
:
IP_FREEBIND
)
.
map
(
|
freebind
|
freebind
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_freebind
(
&
self
freebind
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_IP
libc
:
:
IP_FREEBIND
freebind
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
freebind_ipv6
(
&
self
)
-
>
io
:
:
Result
<
bool
>
{
unsafe
{
getsockopt
:
:
<
c_int
>
(
self
.
as_raw
(
)
libc
:
:
SOL_IPV6
libc
:
:
IPV6_FREEBIND
)
.
map
(
|
freebind
|
freebind
!
=
0
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_freebind_ipv6
(
&
self
freebind
:
bool
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_IPV6
libc
:
:
IPV6_FREEBIND
freebind
as
c_int
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
linux
"
target_vendor
=
"
apple
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
freebsd
"
target_os
=
"
linux
"
target_vendor
=
"
apple
"
)
)
)
)
)
]
pub
fn
sendfile
<
F
>
(
&
self
file
:
&
F
offset
:
usize
length
:
Option
<
NonZeroUsize
>
)
-
>
io
:
:
Result
<
usize
>
where
F
:
AsRawFd
{
self
.
_sendfile
(
file
.
as_raw_fd
(
)
offset
as
_
length
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
target_vendor
=
"
apple
"
)
)
]
fn
_sendfile
(
&
self
file
:
RawFd
offset
:
libc
:
:
off_t
length
:
Option
<
NonZeroUsize
>
)
-
>
io
:
:
Result
<
usize
>
{
let
mut
length
=
match
length
{
Some
(
n
)
=
>
n
.
get
(
)
as
libc
:
:
off_t
None
=
>
0
}
;
syscall
!
(
sendfile
(
file
self
.
as_raw
(
)
offset
&
mut
length
ptr
:
:
null_mut
(
)
0
)
)
.
map
(
|
_
|
length
as
usize
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
)
]
fn
_sendfile
(
&
self
file
:
RawFd
offset
:
libc
:
:
off_t
length
:
Option
<
NonZeroUsize
>
)
-
>
io
:
:
Result
<
usize
>
{
let
count
=
match
length
{
Some
(
n
)
=
>
n
.
get
(
)
as
libc
:
:
size_t
None
=
>
0x7ffff000
}
;
let
mut
offset
=
offset
;
syscall
!
(
sendfile
(
self
.
as_raw
(
)
file
&
mut
offset
count
)
)
.
map
(
|
n
|
n
as
usize
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
target_os
=
"
freebsd
"
)
)
]
fn
_sendfile
(
&
self
file
:
RawFd
offset
:
libc
:
:
off_t
length
:
Option
<
NonZeroUsize
>
)
-
>
io
:
:
Result
<
usize
>
{
let
nbytes
=
match
length
{
Some
(
n
)
=
>
n
.
get
(
)
as
libc
:
:
size_t
None
=
>
0
}
;
let
mut
sbytes
:
libc
:
:
off_t
=
0
;
syscall
!
(
sendfile
(
file
self
.
as_raw
(
)
offset
nbytes
ptr
:
:
null_mut
(
)
&
mut
sbytes
0
)
)
.
map
(
|
_
|
sbytes
as
usize
)
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
set_tcp_user_timeout
(
&
self
timeout
:
Option
<
Duration
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
timeout
=
timeout
.
map
(
|
to
|
min
(
to
.
as_millis
(
)
libc
:
:
c_uint
:
:
MAX
as
u128
)
as
libc
:
:
c_uint
)
.
unwrap_or
(
0
)
;
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_USER_TIMEOUT
timeout
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
]
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
android
"
target_os
=
"
fuchsia
"
target_os
=
"
linux
"
)
)
)
)
)
]
pub
fn
tcp_user_timeout
(
&
self
)
-
>
io
:
:
Result
<
Option
<
Duration
>
>
{
unsafe
{
getsockopt
:
:
<
libc
:
:
c_uint
>
(
self
.
as_raw
(
)
libc
:
:
IPPROTO_TCP
libc
:
:
TCP_USER_TIMEOUT
)
.
map
(
|
millis
|
{
if
millis
=
=
0
{
None
}
else
{
Some
(
Duration
:
:
from_millis
(
millis
as
u64
)
)
}
}
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
]
pub
fn
attach_filter
(
&
self
filters
:
&
[
libc
:
:
sock_filter
]
)
-
>
io
:
:
Result
<
(
)
>
{
let
prog
=
libc
:
:
sock_fprog
{
len
:
filters
.
len
(
)
as
u16
filter
:
filters
.
as_ptr
(
)
as
*
mut
_
}
;
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_ATTACH_FILTER
prog
)
}
}
#
[
cfg
(
all
(
feature
=
"
all
"
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
)
]
pub
fn
detach_filter
(
&
self
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
setsockopt
(
self
.
as_raw
(
)
libc
:
:
SOL_SOCKET
libc
:
:
SO_DETACH_FILTER
0
)
}
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
impl
AsRawFd
for
crate
:
:
Socket
{
fn
as_raw_fd
(
&
self
)
-
>
c_int
{
self
.
as_raw
(
)
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
impl
IntoRawFd
for
crate
:
:
Socket
{
fn
into_raw_fd
(
self
)
-
>
c_int
{
self
.
into_raw
(
)
}
}
#
[
cfg_attr
(
docsrs
doc
(
cfg
(
unix
)
)
)
]
impl
FromRawFd
for
crate
:
:
Socket
{
unsafe
fn
from_raw_fd
(
fd
:
c_int
)
-
>
crate
:
:
Socket
{
crate
:
:
Socket
:
:
from_raw
(
fd
)
}
}
#
[
cfg
(
feature
=
"
all
"
)
]
from
!
(
UnixStream
crate
:
:
Socket
)
;
#
[
cfg
(
feature
=
"
all
"
)
]
from
!
(
UnixListener
crate
:
:
Socket
)
;
#
[
cfg
(
feature
=
"
all
"
)
]
from
!
(
UnixDatagram
crate
:
:
Socket
)
;
#
[
cfg
(
feature
=
"
all
"
)
]
from
!
(
crate
:
:
Socket
UnixStream
)
;
#
[
cfg
(
feature
=
"
all
"
)
]
from
!
(
crate
:
:
Socket
UnixListener
)
;
#
[
cfg
(
feature
=
"
all
"
)
]
from
!
(
crate
:
:
Socket
UnixDatagram
)
;
#
[
test
]
fn
in_addr_convertion
(
)
{
let
ip
=
Ipv4Addr
:
:
new
(
127
0
0
1
)
;
let
raw
=
to_in_addr
(
&
ip
)
;
let
a
=
raw
.
s_addr
;
assert_eq
!
(
a
u32
:
:
from_ne_bytes
(
[
127
0
0
1
]
)
)
;
assert_eq
!
(
from_in_addr
(
raw
)
ip
)
;
let
ip
=
Ipv4Addr
:
:
new
(
127
34
4
12
)
;
let
raw
=
to_in_addr
(
&
ip
)
;
let
a
=
raw
.
s_addr
;
assert_eq
!
(
a
u32
:
:
from_ne_bytes
(
[
127
34
4
12
]
)
)
;
assert_eq
!
(
from_in_addr
(
raw
)
ip
)
;
}
#
[
test
]
fn
in6_addr_convertion
(
)
{
let
ip
=
Ipv6Addr
:
:
new
(
0x2000
1
2
3
4
5
6
7
)
;
let
raw
=
to_in6_addr
(
&
ip
)
;
let
want
=
[
32
0
0
1
0
2
0
3
0
4
0
5
0
6
0
7
]
;
assert_eq
!
(
raw
.
s6_addr
want
)
;
assert_eq
!
(
from_in6_addr
(
raw
)
ip
)
;
}
