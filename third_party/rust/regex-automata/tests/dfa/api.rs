use
std
:
:
error
:
:
Error
;
use
regex_automata
:
:
{
dfa
:
:
{
dense
Automaton
OverlappingState
}
nfa
:
:
thompson
HalfMatch
Input
MatchError
}
;
#
[
test
]
fn
quit_fwd
(
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
let
dfa
=
dense
:
:
Builder
:
:
new
(
)
.
configure
(
dense
:
:
Config
:
:
new
(
)
.
quit
(
b
'
x
'
true
)
)
.
build
(
"
[
[
:
word
:
]
]
+
"
)
?
;
assert_eq
!
(
Err
(
MatchError
:
:
quit
(
b
'
x
'
3
)
)
dfa
.
try_search_fwd
(
&
Input
:
:
new
(
b
"
abcxyz
"
)
)
)
;
assert_eq
!
(
dfa
.
try_search_overlapping_fwd
(
&
Input
:
:
new
(
b
"
abcxyz
"
)
&
mut
OverlappingState
:
:
start
(
)
)
Err
(
MatchError
:
:
quit
(
b
'
x
'
3
)
)
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
quit_rev
(
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
let
dfa
=
dense
:
:
Builder
:
:
new
(
)
.
configure
(
dense
:
:
Config
:
:
new
(
)
.
quit
(
b
'
x
'
true
)
)
.
thompson
(
thompson
:
:
Config
:
:
new
(
)
.
reverse
(
true
)
)
.
build
(
"
^
[
[
:
word
:
]
]
+
"
)
?
;
assert_eq
!
(
Err
(
MatchError
:
:
quit
(
b
'
x
'
3
)
)
dfa
.
try_search_rev
(
&
Input
:
:
new
(
b
"
abcxyz
"
)
)
)
;
Ok
(
(
)
)
}
#
[
test
]
#
[
should_panic
]
fn
quit_panics
(
)
{
dense
:
:
Config
:
:
new
(
)
.
unicode_word_boundary
(
true
)
.
quit
(
b
'
\
xFF
'
false
)
;
}
#
[
test
]
fn
unicode_word_implicitly_works
(
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
let
mut
config
=
dense
:
:
Config
:
:
new
(
)
;
for
b
in
0x80
.
.
=
0xFF
{
config
=
config
.
quit
(
b
true
)
;
}
let
dfa
=
dense
:
:
Builder
:
:
new
(
)
.
configure
(
config
)
.
build
(
r
"
\
b
"
)
?
;
let
expected
=
HalfMatch
:
:
must
(
0
1
)
;
assert_eq
!
(
Ok
(
Some
(
expected
)
)
dfa
.
try_search_fwd
(
&
Input
:
:
new
(
b
"
a
"
)
)
)
;
Ok
(
(
)
)
}
