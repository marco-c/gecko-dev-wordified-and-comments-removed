use
{
anyhow
:
:
Result
regex_automata
:
:
{
dfa
:
:
{
self
dense
regex
:
:
Regex
sparse
Automaton
OverlappingState
StartKind
}
nfa
:
:
thompson
util
:
:
{
prefilter
:
:
Prefilter
syntax
}
Anchored
Input
PatternSet
}
regex_syntax
:
:
hir
regex_test
:
:
{
CompiledRegex
Match
RegexTest
SearchKind
Span
TestResult
TestRunner
}
}
;
use
crate
:
:
{
create_input
suite
untestify_kind
}
;
const
EXPANSIONS
:
&
[
&
str
]
=
&
[
"
is_match
"
"
find
"
"
which
"
]
;
#
[
test
]
fn
unminimized_default
(
)
-
>
Result
<
(
)
>
{
let
builder
=
Regex
:
:
builder
(
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
dense_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
unminimized_prefilter
(
)
-
>
Result
<
(
)
>
{
let
my_compiler
=
|
test
:
&
RegexTest
regexes
:
&
[
String
]
|
{
let
mut
hirs
=
vec
!
[
]
;
for
pattern
in
regexes
.
iter
(
)
{
hirs
.
push
(
syntax
:
:
parse_with
(
pattern
&
config_syntax
(
test
)
)
?
)
;
}
let
kind
=
match
untestify_kind
(
test
.
match_kind
(
)
)
{
None
=
>
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
Some
(
kind
)
=
>
kind
}
;
let
pre
=
Prefilter
:
:
from_hirs_prefix
(
kind
&
hirs
)
;
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dense
(
dense
:
:
DFA
:
:
config
(
)
.
prefilter
(
pre
)
)
;
compiler
(
builder
|
_
_
re
|
{
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
run_test
(
&
re
test
)
}
)
)
}
)
(
test
regexes
)
}
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
my_compiler
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
unminimized_specialized_start_states
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dense
(
dense
:
:
Config
:
:
new
(
)
.
specialize_start_states
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
dense_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
unminimized_no_byte_class
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dense
(
dense
:
:
Config
:
:
new
(
)
.
byte_classes
(
false
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
dense_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
unminimized_nfa_shrink
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
thompson
(
thompson
:
:
Config
:
:
new
(
)
.
shrink
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
dense_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
minimized_default
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dense
(
dense
:
:
Config
:
:
new
(
)
.
minimize
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
dense_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
minimized_no_byte_class
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dense
(
dense
:
:
Config
:
:
new
(
)
.
minimize
(
true
)
.
byte_classes
(
false
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
dense_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
sparse_unminimized_default
(
)
-
>
Result
<
(
)
>
{
let
builder
=
Regex
:
:
builder
(
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
sparse_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
sparse_unminimized_prefilter
(
)
-
>
Result
<
(
)
>
{
let
my_compiler
=
|
test
:
&
RegexTest
regexes
:
&
[
String
]
|
{
let
mut
hirs
=
vec
!
[
]
;
for
pattern
in
regexes
.
iter
(
)
{
hirs
.
push
(
syntax
:
:
parse_with
(
pattern
&
config_syntax
(
test
)
)
?
)
;
}
let
kind
=
match
untestify_kind
(
test
.
match_kind
(
)
)
{
None
=
>
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
Some
(
kind
)
=
>
kind
}
;
let
pre
=
Prefilter
:
:
from_hirs_prefix
(
kind
&
hirs
)
;
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dense
(
dense
:
:
DFA
:
:
config
(
)
.
prefilter
(
pre
)
)
;
compiler
(
builder
|
builder
_
re
|
{
let
fwd
=
re
.
forward
(
)
.
to_sparse
(
)
?
;
let
rev
=
re
.
reverse
(
)
.
to_sparse
(
)
?
;
let
re
=
builder
.
build_from_dfas
(
fwd
rev
)
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
run_test
(
&
re
test
)
}
)
)
}
)
(
test
regexes
)
}
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
my_compiler
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
serialization_unminimized_default
(
)
-
>
Result
<
(
)
>
{
let
builder
=
Regex
:
:
builder
(
)
;
let
my_compiler
=
|
builder
|
{
compiler
(
builder
|
builder
_
re
|
{
let
builder
=
builder
.
clone
(
)
;
let
(
fwd_bytes
_
)
=
re
.
forward
(
)
.
to_bytes_native_endian
(
)
;
let
(
rev_bytes
_
)
=
re
.
reverse
(
)
.
to_bytes_native_endian
(
)
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
let
fwd
:
dense
:
:
DFA
<
&
[
u32
]
>
=
dense
:
:
DFA
:
:
from_bytes
(
&
fwd_bytes
)
.
unwrap
(
)
.
0
;
let
rev
:
dense
:
:
DFA
<
&
[
u32
]
>
=
dense
:
:
DFA
:
:
from_bytes
(
&
rev_bytes
)
.
unwrap
(
)
.
0
;
let
re
=
builder
.
build_from_dfas
(
fwd
rev
)
;
run_test
(
&
re
test
)
}
)
)
}
)
}
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
my_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
sparse_serialization_unminimized_default
(
)
-
>
Result
<
(
)
>
{
let
builder
=
Regex
:
:
builder
(
)
;
let
my_compiler
=
|
builder
|
{
compiler
(
builder
|
builder
_
re
|
{
let
builder
=
builder
.
clone
(
)
;
let
fwd_bytes
=
re
.
forward
(
)
.
to_sparse
(
)
?
.
to_bytes_native_endian
(
)
;
let
rev_bytes
=
re
.
reverse
(
)
.
to_sparse
(
)
?
.
to_bytes_native_endian
(
)
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
let
fwd
:
sparse
:
:
DFA
<
&
[
u8
]
>
=
sparse
:
:
DFA
:
:
from_bytes
(
&
fwd_bytes
)
.
unwrap
(
)
.
0
;
let
rev
:
sparse
:
:
DFA
<
&
[
u8
]
>
=
sparse
:
:
DFA
:
:
from_bytes
(
&
rev_bytes
)
.
unwrap
(
)
.
0
;
let
re
=
builder
.
build_from_dfas
(
fwd
rev
)
;
run_test
(
&
re
test
)
}
)
)
}
)
}
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
my_compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
fn
dense_compiler
(
builder
:
dfa
:
:
regex
:
:
Builder
)
-
>
impl
FnMut
(
&
RegexTest
&
[
String
]
)
-
>
Result
<
CompiledRegex
>
{
compiler
(
builder
|
_
_
re
|
{
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
run_test
(
&
re
test
)
}
)
)
}
)
}
fn
sparse_compiler
(
builder
:
dfa
:
:
regex
:
:
Builder
)
-
>
impl
FnMut
(
&
RegexTest
&
[
String
]
)
-
>
Result
<
CompiledRegex
>
{
compiler
(
builder
|
builder
_
re
|
{
let
fwd
=
re
.
forward
(
)
.
to_sparse
(
)
?
;
let
rev
=
re
.
reverse
(
)
.
to_sparse
(
)
?
;
let
re
=
builder
.
build_from_dfas
(
fwd
rev
)
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
run_test
(
&
re
test
)
}
)
)
}
)
}
fn
compiler
(
mut
builder
:
dfa
:
:
regex
:
:
Builder
mut
create_matcher
:
impl
FnMut
(
&
dfa
:
:
regex
:
:
Builder
Option
<
Prefilter
>
Regex
)
-
>
Result
<
CompiledRegex
>
)
-
>
impl
FnMut
(
&
RegexTest
&
[
String
]
)
-
>
Result
<
CompiledRegex
>
{
move
|
test
regexes
|
{
let
mut
hirs
=
vec
!
[
]
;
for
pattern
in
regexes
.
iter
(
)
{
hirs
.
push
(
syntax
:
:
parse_with
(
pattern
&
config_syntax
(
test
)
)
?
)
;
}
let
kind
=
match
untestify_kind
(
test
.
match_kind
(
)
)
{
None
=
>
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
Some
(
kind
)
=
>
kind
}
;
let
pre
=
Prefilter
:
:
from_hirs_prefix
(
kind
&
hirs
)
;
if
!
test
.
haystack
(
)
.
is_ascii
(
)
{
for
hir
in
hirs
.
iter
(
)
{
let
looks
=
hir
.
properties
(
)
.
look_set
(
)
;
if
looks
.
contains
(
hir
:
:
Look
:
:
WordUnicode
)
|
|
looks
.
contains
(
hir
:
:
Look
:
:
WordUnicodeNegate
)
{
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
;
}
}
}
if
!
configure_regex_builder
(
test
&
mut
builder
)
{
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
;
}
create_matcher
(
&
builder
pre
builder
.
build_many
(
&
regexes
)
?
)
}
}
fn
run_test
<
A
:
Automaton
>
(
re
:
&
Regex
<
A
>
test
:
&
RegexTest
)
-
>
TestResult
{
let
input
=
create_input
(
test
)
;
match
test
.
additional_name
(
)
{
"
is_match
"
=
>
TestResult
:
:
matched
(
re
.
is_match
(
input
.
earliest
(
true
)
)
)
"
find
"
=
>
match
test
.
search_kind
(
)
{
SearchKind
:
:
Earliest
|
SearchKind
:
:
Leftmost
=
>
{
let
input
=
input
.
earliest
(
test
.
search_kind
(
)
=
=
SearchKind
:
:
Earliest
)
;
TestResult
:
:
matches
(
re
.
find_iter
(
input
)
.
take
(
test
.
match_limit
(
)
.
unwrap_or
(
std
:
:
usize
:
:
MAX
)
)
.
map
(
|
m
|
Match
{
id
:
m
.
pattern
(
)
.
as_usize
(
)
span
:
Span
{
start
:
m
.
start
(
)
end
:
m
.
end
(
)
}
}
)
)
}
SearchKind
:
:
Overlapping
=
>
{
try_search_overlapping
(
re
&
input
)
.
unwrap
(
)
}
}
"
which
"
=
>
match
test
.
search_kind
(
)
{
SearchKind
:
:
Earliest
|
SearchKind
:
:
Leftmost
=
>
{
TestResult
:
:
skip
(
)
}
SearchKind
:
:
Overlapping
=
>
{
let
dfa
=
re
.
forward
(
)
;
let
mut
patset
=
PatternSet
:
:
new
(
dfa
.
pattern_len
(
)
)
;
dfa
.
try_which_overlapping_matches
(
&
input
&
mut
patset
)
.
unwrap
(
)
;
TestResult
:
:
which
(
patset
.
iter
(
)
.
map
(
|
p
|
p
.
as_usize
(
)
)
)
}
}
name
=
>
TestResult
:
:
fail
(
&
format
!
(
"
unrecognized
test
name
:
{
}
"
name
)
)
}
}
fn
configure_regex_builder
(
test
:
&
RegexTest
builder
:
&
mut
dfa
:
:
regex
:
:
Builder
)
-
>
bool
{
let
match_kind
=
match
untestify_kind
(
test
.
match_kind
(
)
)
{
None
=
>
return
false
Some
(
k
)
=
>
k
}
;
let
starts
=
if
test
.
anchored
(
)
{
StartKind
:
:
Anchored
}
else
{
StartKind
:
:
Unanchored
}
;
let
mut
dense_config
=
dense
:
:
Config
:
:
new
(
)
.
start_kind
(
starts
)
.
match_kind
(
match_kind
)
.
unicode_word_boundary
(
true
)
;
if
test
.
search_kind
(
)
=
=
SearchKind
:
:
Overlapping
{
dense_config
=
dense_config
.
starts_for_each_pattern
(
true
)
;
}
builder
.
syntax
(
config_syntax
(
test
)
)
.
thompson
(
config_thompson
(
test
)
)
.
dense
(
dense_config
)
;
true
}
fn
config_thompson
(
test
:
&
RegexTest
)
-
>
thompson
:
:
Config
{
let
mut
lookm
=
regex_automata
:
:
util
:
:
look
:
:
LookMatcher
:
:
new
(
)
;
lookm
.
set_line_terminator
(
test
.
line_terminator
(
)
)
;
thompson
:
:
Config
:
:
new
(
)
.
utf8
(
test
.
utf8
(
)
)
.
look_matcher
(
lookm
)
}
fn
config_syntax
(
test
:
&
RegexTest
)
-
>
syntax
:
:
Config
{
syntax
:
:
Config
:
:
new
(
)
.
case_insensitive
(
test
.
case_insensitive
(
)
)
.
unicode
(
test
.
unicode
(
)
)
.
utf8
(
test
.
utf8
(
)
)
.
line_terminator
(
test
.
line_terminator
(
)
)
}
fn
try_search_overlapping
<
A
:
Automaton
>
(
re
:
&
Regex
<
A
>
input
:
&
Input
<
'
_
>
)
-
>
Result
<
TestResult
>
{
let
mut
matches
=
vec
!
[
]
;
let
mut
fwd_state
=
OverlappingState
:
:
start
(
)
;
let
(
fwd_dfa
rev_dfa
)
=
(
re
.
forward
(
)
re
.
reverse
(
)
)
;
while
let
Some
(
end
)
=
{
fwd_dfa
.
try_search_overlapping_fwd
(
input
&
mut
fwd_state
)
?
;
fwd_state
.
get_match
(
)
}
{
let
revsearch
=
input
.
clone
(
)
.
range
(
input
.
start
(
)
.
.
end
.
offset
(
)
)
.
anchored
(
Anchored
:
:
Pattern
(
end
.
pattern
(
)
)
)
.
earliest
(
false
)
;
let
mut
rev_state
=
OverlappingState
:
:
start
(
)
;
while
let
Some
(
start
)
=
{
rev_dfa
.
try_search_overlapping_rev
(
&
revsearch
&
mut
rev_state
)
?
;
rev_state
.
get_match
(
)
}
{
let
span
=
Span
{
start
:
start
.
offset
(
)
end
:
end
.
offset
(
)
}
;
let
mat
=
Match
{
id
:
end
.
pattern
(
)
.
as_usize
(
)
span
}
;
matches
.
push
(
mat
)
;
}
}
Ok
(
TestResult
:
:
matches
(
matches
)
)
}
