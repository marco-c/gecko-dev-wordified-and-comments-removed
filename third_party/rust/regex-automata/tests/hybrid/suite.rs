use
{
anyhow
:
:
Result
regex_automata
:
:
{
hybrid
:
:
{
dfa
:
:
{
OverlappingState
DFA
}
regex
:
:
{
self
Regex
}
}
nfa
:
:
thompson
util
:
:
{
prefilter
:
:
Prefilter
syntax
}
Anchored
Input
PatternSet
}
regex_test
:
:
{
CompiledRegex
Match
RegexTest
SearchKind
Span
TestResult
TestRunner
}
}
;
use
crate
:
:
{
create_input
suite
untestify_kind
}
;
const
EXPANSIONS
:
&
[
&
str
]
=
&
[
"
is_match
"
"
find
"
"
which
"
]
;
#
[
test
]
fn
default
(
)
-
>
Result
<
(
)
>
{
let
builder
=
Regex
:
:
builder
(
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
/
regression
-
many
-
repeat
-
no
-
stack
-
overflow
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
prefilter
(
)
-
>
Result
<
(
)
>
{
let
my_compiler
=
|
test
:
&
RegexTest
regexes
:
&
[
String
]
|
{
let
mut
hirs
=
vec
!
[
]
;
for
pattern
in
regexes
.
iter
(
)
{
hirs
.
push
(
syntax
:
:
parse_with
(
pattern
&
config_syntax
(
test
)
)
?
)
;
}
let
kind
=
match
untestify_kind
(
test
.
match_kind
(
)
)
{
None
=
>
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
Some
(
kind
)
=
>
kind
}
;
let
pre
=
Prefilter
:
:
from_hirs_prefix
(
kind
&
hirs
)
;
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dfa
(
DFA
:
:
config
(
)
.
prefilter
(
pre
)
)
;
compiler
(
builder
)
(
test
regexes
)
}
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
/
regression
-
many
-
repeat
-
no
-
stack
-
overflow
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
my_compiler
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
nfa_shrink
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
thompson
(
thompson
:
:
Config
:
:
new
(
)
.
shrink
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
starts_for_each_pattern
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dfa
(
DFA
:
:
config
(
)
.
starts_for_each_pattern
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
/
regression
-
many
-
repeat
-
no
-
stack
-
overflow
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
specialize_start_states
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dfa
(
DFA
:
:
config
(
)
.
specialize_start_states
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
/
regression
-
many
-
repeat
-
no
-
stack
-
overflow
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
no_byte_classes
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dfa
(
DFA
:
:
config
(
)
.
byte_classes
(
false
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
/
regression
-
many
-
repeat
-
no
-
stack
-
overflow
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
no_cache_clearing
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dfa
(
DFA
:
:
config
(
)
.
minimum_cache_clear_count
(
Some
(
0
)
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
blacklist
(
"
expensive
/
regression
-
many
-
repeat
-
no
-
stack
-
overflow
"
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
#
[
test
]
fn
min_cache_capacity
(
)
-
>
Result
<
(
)
>
{
let
mut
builder
=
Regex
:
:
builder
(
)
;
builder
.
dfa
(
DFA
:
:
config
(
)
.
cache_capacity
(
0
)
.
skip_cache_capacity_check
(
true
)
)
;
TestRunner
:
:
new
(
)
?
.
expand
(
EXPANSIONS
|
t
|
t
.
compiles
(
)
)
.
test_iter
(
suite
(
)
?
.
iter
(
)
compiler
(
builder
)
)
.
assert
(
)
;
Ok
(
(
)
)
}
fn
compiler
(
mut
builder
:
regex
:
:
Builder
)
-
>
impl
FnMut
(
&
RegexTest
&
[
String
]
)
-
>
Result
<
CompiledRegex
>
{
move
|
test
regexes
|
{
let
mut
hirs
=
vec
!
[
]
;
for
pattern
in
regexes
.
iter
(
)
{
hirs
.
push
(
syntax
:
:
parse_with
(
pattern
&
config_syntax
(
test
)
)
?
)
;
}
if
!
test
.
haystack
(
)
.
is_ascii
(
)
{
for
hir
in
hirs
.
iter
(
)
{
if
hir
.
properties
(
)
.
look_set
(
)
.
contains_word_unicode
(
)
{
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
;
}
}
}
if
!
configure_regex_builder
(
test
&
mut
builder
)
{
return
Ok
(
CompiledRegex
:
:
skip
(
)
)
;
}
let
re
=
builder
.
build_many
(
&
regexes
)
?
;
let
mut
cache
=
re
.
create_cache
(
)
;
Ok
(
CompiledRegex
:
:
compiled
(
move
|
test
|
-
>
TestResult
{
run_test
(
&
re
&
mut
cache
test
)
}
)
)
}
}
fn
run_test
(
re
:
&
Regex
cache
:
&
mut
regex
:
:
Cache
test
:
&
RegexTest
)
-
>
TestResult
{
let
input
=
create_input
(
test
)
;
match
test
.
additional_name
(
)
{
"
is_match
"
=
>
{
TestResult
:
:
matched
(
re
.
is_match
(
cache
input
.
earliest
(
true
)
)
)
}
"
find
"
=
>
match
test
.
search_kind
(
)
{
SearchKind
:
:
Earliest
|
SearchKind
:
:
Leftmost
=
>
{
let
input
=
input
.
earliest
(
test
.
search_kind
(
)
=
=
SearchKind
:
:
Earliest
)
;
TestResult
:
:
matches
(
re
.
find_iter
(
cache
input
)
.
take
(
test
.
match_limit
(
)
.
unwrap_or
(
std
:
:
usize
:
:
MAX
)
)
.
map
(
|
m
|
Match
{
id
:
m
.
pattern
(
)
.
as_usize
(
)
span
:
Span
{
start
:
m
.
start
(
)
end
:
m
.
end
(
)
}
}
)
)
}
SearchKind
:
:
Overlapping
=
>
{
try_search_overlapping
(
re
cache
&
input
)
.
unwrap
(
)
}
}
"
which
"
=
>
match
test
.
search_kind
(
)
{
SearchKind
:
:
Earliest
|
SearchKind
:
:
Leftmost
=
>
{
TestResult
:
:
skip
(
)
}
SearchKind
:
:
Overlapping
=
>
{
let
dfa
=
re
.
forward
(
)
;
let
cache
=
cache
.
as_parts_mut
(
)
.
0
;
let
mut
patset
=
PatternSet
:
:
new
(
dfa
.
pattern_len
(
)
)
;
dfa
.
try_which_overlapping_matches
(
cache
&
input
&
mut
patset
)
.
unwrap
(
)
;
TestResult
:
:
which
(
patset
.
iter
(
)
.
map
(
|
p
|
p
.
as_usize
(
)
)
)
}
}
name
=
>
TestResult
:
:
fail
(
&
format
!
(
"
unrecognized
test
name
:
{
}
"
name
)
)
}
}
fn
configure_regex_builder
(
test
:
&
RegexTest
builder
:
&
mut
regex
:
:
Builder
)
-
>
bool
{
let
match_kind
=
match
untestify_kind
(
test
.
match_kind
(
)
)
{
None
=
>
return
false
Some
(
k
)
=
>
k
}
;
let
mut
dfa_config
=
DFA
:
:
config
(
)
.
match_kind
(
match_kind
)
.
unicode_word_boundary
(
true
)
;
if
test
.
search_kind
(
)
=
=
SearchKind
:
:
Overlapping
{
dfa_config
=
dfa_config
.
starts_for_each_pattern
(
true
)
;
}
builder
.
syntax
(
config_syntax
(
test
)
)
.
thompson
(
config_thompson
(
test
)
)
.
dfa
(
dfa_config
)
;
true
}
fn
config_thompson
(
test
:
&
RegexTest
)
-
>
thompson
:
:
Config
{
let
mut
lookm
=
regex_automata
:
:
util
:
:
look
:
:
LookMatcher
:
:
new
(
)
;
lookm
.
set_line_terminator
(
test
.
line_terminator
(
)
)
;
thompson
:
:
Config
:
:
new
(
)
.
utf8
(
test
.
utf8
(
)
)
.
look_matcher
(
lookm
)
}
fn
config_syntax
(
test
:
&
RegexTest
)
-
>
syntax
:
:
Config
{
syntax
:
:
Config
:
:
new
(
)
.
case_insensitive
(
test
.
case_insensitive
(
)
)
.
unicode
(
test
.
unicode
(
)
)
.
utf8
(
test
.
utf8
(
)
)
.
line_terminator
(
test
.
line_terminator
(
)
)
}
fn
try_search_overlapping
(
re
:
&
Regex
cache
:
&
mut
regex
:
:
Cache
input
:
&
Input
<
'
_
>
)
-
>
Result
<
TestResult
>
{
let
mut
matches
=
vec
!
[
]
;
let
mut
fwd_state
=
OverlappingState
:
:
start
(
)
;
let
(
fwd_dfa
rev_dfa
)
=
(
re
.
forward
(
)
re
.
reverse
(
)
)
;
let
(
fwd_cache
rev_cache
)
=
cache
.
as_parts_mut
(
)
;
while
let
Some
(
end
)
=
{
fwd_dfa
.
try_search_overlapping_fwd
(
fwd_cache
input
&
mut
fwd_state
)
?
;
fwd_state
.
get_match
(
)
}
{
let
revsearch
=
input
.
clone
(
)
.
range
(
input
.
start
(
)
.
.
end
.
offset
(
)
)
.
anchored
(
Anchored
:
:
Pattern
(
end
.
pattern
(
)
)
)
.
earliest
(
false
)
;
let
mut
rev_state
=
OverlappingState
:
:
start
(
)
;
while
let
Some
(
start
)
=
{
rev_dfa
.
try_search_overlapping_rev
(
rev_cache
&
revsearch
&
mut
rev_state
)
?
;
rev_state
.
get_match
(
)
}
{
let
span
=
Span
{
start
:
start
.
offset
(
)
end
:
end
.
offset
(
)
}
;
let
mat
=
Match
{
id
:
end
.
pattern
(
)
.
as_usize
(
)
span
}
;
matches
.
push
(
mat
)
;
}
}
Ok
(
TestResult
:
:
matches
(
matches
)
)
}
