use
regex_automata
:
:
{
dfa
:
:
{
dense
:
:
DFA
regex
:
:
Regex
}
util
:
:
{
lazy
:
:
Lazy
wire
:
:
AlignAs
}
}
;
pub
static
MULTI_PATTERN_V2
:
Lazy
<
Regex
<
DFA
<
&
'
static
[
u32
]
>
>
>
=
Lazy
:
:
new
(
|
|
{
let
dfafwd
=
{
static
ALIGNED
:
&
AlignAs
<
[
u8
]
u32
>
=
&
AlignAs
{
_align
:
[
]
#
[
cfg
(
target_endian
=
"
big
"
)
]
bytes
:
*
include_bytes
!
(
"
multi_pattern_v2_fwd
.
bigendian
.
dfa
"
)
#
[
cfg
(
target_endian
=
"
little
"
)
]
bytes
:
*
include_bytes
!
(
"
multi_pattern_v2_fwd
.
littleendian
.
dfa
"
)
}
;
DFA
:
:
from_bytes
(
&
ALIGNED
.
bytes
)
.
expect
(
"
serialized
forward
DFA
should
be
valid
"
)
.
0
}
;
let
dfarev
=
{
static
ALIGNED
:
&
AlignAs
<
[
u8
]
u32
>
=
&
AlignAs
{
_align
:
[
]
#
[
cfg
(
target_endian
=
"
big
"
)
]
bytes
:
*
include_bytes
!
(
"
multi_pattern_v2_rev
.
bigendian
.
dfa
"
)
#
[
cfg
(
target_endian
=
"
little
"
)
]
bytes
:
*
include_bytes
!
(
"
multi_pattern_v2_rev
.
littleendian
.
dfa
"
)
}
;
DFA
:
:
from_bytes
(
&
ALIGNED
.
bytes
)
.
expect
(
"
serialized
reverse
DFA
should
be
valid
"
)
.
0
}
;
Regex
:
:
builder
(
)
.
build_from_dfas
(
dfafwd
dfarev
)
}
)
;
