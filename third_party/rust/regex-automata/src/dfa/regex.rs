#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
:
:
Vec
;
#
[
cfg
(
feature
=
"
dfa
-
build
"
)
]
use
crate
:
:
dfa
:
:
dense
:
:
BuildError
;
use
crate
:
:
{
dfa
:
:
{
automaton
:
:
Automaton
dense
}
util
:
:
{
iter
search
:
:
Input
}
Anchored
Match
MatchError
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
{
dfa
:
:
{
sparse
StartKind
}
util
:
:
search
:
:
MatchKind
}
;
macro_rules
!
define_regex_type
{
(
(
#
[
doc
:
meta
]
)
*
)
=
>
{
#
[
cfg
(
feature
=
"
alloc
"
)
]
(
#
[
doc
]
)
*
pub
struct
Regex
<
A
=
dense
:
:
OwnedDFA
>
{
forward
:
A
reverse
:
A
}
#
[
cfg
(
not
(
feature
=
"
alloc
"
)
)
]
(
#
[
doc
]
)
*
pub
struct
Regex
<
A
>
{
forward
:
A
reverse
:
A
}
}
;
}
define_regex_type
!
(
/
/
/
A
regular
expression
that
uses
deterministic
finite
automata
for
fast
/
/
/
searching
.
/
/
/
/
/
/
A
regular
expression
is
comprised
of
two
DFAs
a
"
forward
"
DFA
and
a
/
/
/
"
reverse
"
DFA
.
The
forward
DFA
is
responsible
for
detecting
the
end
of
/
/
/
a
match
while
the
reverse
DFA
is
responsible
for
detecting
the
start
/
/
/
of
a
match
.
Thus
in
order
to
find
the
bounds
of
any
given
match
a
/
/
/
forward
search
must
first
be
run
followed
by
a
reverse
search
.
A
match
/
/
/
found
by
the
forward
DFA
guarantees
that
the
reverse
DFA
will
also
find
/
/
/
a
match
.
/
/
/
/
/
/
The
type
of
the
DFA
used
by
a
Regex
corresponds
to
the
A
type
/
/
/
parameter
which
must
satisfy
the
[
Automaton
]
trait
.
Typically
/
/
/
A
is
either
a
[
dense
:
:
DFA
]
(
crate
:
:
dfa
:
:
dense
:
:
DFA
)
or
a
/
/
/
[
sparse
:
:
DFA
]
(
crate
:
:
dfa
:
:
sparse
:
:
DFA
)
where
dense
DFAs
use
more
/
/
/
memory
but
search
faster
while
sparse
DFAs
use
less
memory
but
search
/
/
/
more
slowly
.
/
/
/
/
/
/
#
Crate
features
/
/
/
/
/
/
Note
that
despite
what
the
documentation
auto
-
generates
the
_only_
/
/
/
crate
feature
needed
to
use
this
type
is
dfa
-
search
.
You
do
_not_
/
/
/
need
to
enable
the
alloc
feature
.
/
/
/
/
/
/
By
default
a
regex
'
s
automaton
type
parameter
is
set
to
/
/
/
dense
:
:
DFA
<
Vec
<
u32
>
>
when
the
alloc
feature
is
enabled
.
For
most
/
/
/
in
-
memory
work
loads
this
is
the
most
convenient
type
that
gives
the
/
/
/
best
search
performance
.
When
the
alloc
feature
is
disabled
no
/
/
/
default
type
is
used
.
/
/
/
/
/
/
#
When
should
I
use
this
?
/
/
/
/
/
/
Generally
speaking
if
you
can
afford
the
overhead
of
building
a
full
/
/
/
DFA
for
your
regex
and
you
don
'
t
need
things
like
capturing
groups
/
/
/
then
this
is
a
good
choice
if
you
'
re
looking
to
optimize
for
matching
/
/
/
speed
.
Note
however
that
its
speed
may
be
worse
than
a
general
purpose
/
/
/
regex
engine
if
you
don
'
t
provide
a
[
dense
:
:
Config
:
:
prefilter
]
to
the
/
/
/
underlying
DFA
.
/
/
/
/
/
/
#
Sparse
DFAs
/
/
/
/
/
/
Since
a
Regex
is
generic
over
the
[
Automaton
]
trait
it
can
be
/
/
/
used
with
any
kind
of
DFA
.
While
this
crate
constructs
dense
DFAs
by
/
/
/
default
it
is
easy
enough
to
build
corresponding
sparse
DFAs
and
then
/
/
/
build
a
regex
from
them
:
/
/
/
/
/
/
#
[
derive
(
Clone
Debug
)
]
)
;
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
impl
Regex
{
pub
fn
new
(
pattern
:
&
str
)
-
>
Result
<
Regex
BuildError
>
{
Builder
:
:
new
(
)
.
build
(
pattern
)
}
pub
fn
new_many
<
P
:
AsRef
<
str
>
>
(
patterns
:
&
[
P
]
)
-
>
Result
<
Regex
BuildError
>
{
Builder
:
:
new
(
)
.
build_many
(
patterns
)
}
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
impl
Regex
<
sparse
:
:
DFA
<
Vec
<
u8
>
>
>
{
pub
fn
new_sparse
(
pattern
:
&
str
)
-
>
Result
<
Regex
<
sparse
:
:
DFA
<
Vec
<
u8
>
>
>
BuildError
>
{
Builder
:
:
new
(
)
.
build_sparse
(
pattern
)
}
pub
fn
new_many_sparse
<
P
:
AsRef
<
str
>
>
(
patterns
:
&
[
P
]
)
-
>
Result
<
Regex
<
sparse
:
:
DFA
<
Vec
<
u8
>
>
>
BuildError
>
{
Builder
:
:
new
(
)
.
build_many_sparse
(
patterns
)
}
}
impl
Regex
<
dense
:
:
DFA
<
&
'
static
[
u32
]
>
>
{
pub
fn
builder
(
)
-
>
Builder
{
Builder
:
:
new
(
)
}
}
impl
<
A
:
Automaton
>
Regex
<
A
>
{
#
[
inline
]
pub
fn
is_match
<
'
h
I
:
Into
<
Input
<
'
h
>
>
>
(
&
self
input
:
I
)
-
>
bool
{
let
input
=
input
.
into
(
)
.
earliest
(
true
)
;
self
.
forward
(
)
.
try_search_fwd
(
&
input
)
.
map
(
|
x
|
x
.
is_some
(
)
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
find
<
'
h
I
:
Into
<
Input
<
'
h
>
>
>
(
&
self
input
:
I
)
-
>
Option
<
Match
>
{
self
.
try_search
(
&
input
.
into
(
)
)
.
unwrap
(
)
}
#
[
inline
]
pub
fn
find_iter
<
'
r
'
h
I
:
Into
<
Input
<
'
h
>
>
>
(
&
'
r
self
input
:
I
)
-
>
FindMatches
<
'
r
'
h
A
>
{
let
it
=
iter
:
:
Searcher
:
:
new
(
input
.
into
(
)
)
;
FindMatches
{
re
:
self
it
}
}
}
impl
<
A
:
Automaton
>
Regex
<
A
>
{
#
[
inline
]
pub
fn
try_search
(
&
self
input
:
&
Input
<
'
_
>
)
-
>
Result
<
Option
<
Match
>
MatchError
>
{
let
(
fwd
rev
)
=
(
self
.
forward
(
)
self
.
reverse
(
)
)
;
let
end
=
match
fwd
.
try_search_fwd
(
input
)
?
{
None
=
>
return
Ok
(
None
)
Some
(
end
)
=
>
end
}
;
if
input
.
start
(
)
=
=
end
.
offset
(
)
{
return
Ok
(
Some
(
Match
:
:
new
(
end
.
pattern
(
)
end
.
offset
(
)
.
.
end
.
offset
(
)
)
)
)
;
}
if
self
.
is_anchored
(
input
)
{
return
Ok
(
Some
(
Match
:
:
new
(
end
.
pattern
(
)
input
.
start
(
)
.
.
end
.
offset
(
)
)
)
)
;
}
let
revsearch
=
input
.
clone
(
)
.
span
(
input
.
start
(
)
.
.
end
.
offset
(
)
)
.
anchored
(
Anchored
:
:
Yes
)
.
earliest
(
false
)
;
let
start
=
rev
.
try_search_rev
(
&
revsearch
)
?
.
expect
(
"
reverse
search
must
match
if
forward
search
does
"
)
;
assert_eq
!
(
start
.
pattern
(
)
end
.
pattern
(
)
"
forward
and
reverse
search
must
match
same
pattern
"
)
;
assert
!
(
start
.
offset
(
)
<
=
end
.
offset
(
)
)
;
Ok
(
Some
(
Match
:
:
new
(
end
.
pattern
(
)
start
.
offset
(
)
.
.
end
.
offset
(
)
)
)
)
}
fn
is_anchored
(
&
self
input
:
&
Input
<
'
_
>
)
-
>
bool
{
match
input
.
get_anchored
(
)
{
Anchored
:
:
No
=
>
self
.
forward
(
)
.
is_always_start_anchored
(
)
Anchored
:
:
Yes
|
Anchored
:
:
Pattern
(
_
)
=
>
true
}
}
}
impl
<
A
:
Automaton
>
Regex
<
A
>
{
pub
fn
forward
(
&
self
)
-
>
&
A
{
&
self
.
forward
}
pub
fn
reverse
(
&
self
)
-
>
&
A
{
&
self
.
reverse
}
pub
fn
pattern_len
(
&
self
)
-
>
usize
{
assert_eq
!
(
self
.
forward
(
)
.
pattern_len
(
)
self
.
reverse
(
)
.
pattern_len
(
)
)
;
self
.
forward
(
)
.
pattern_len
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
FindMatches
<
'
r
'
h
A
>
{
re
:
&
'
r
Regex
<
A
>
it
:
iter
:
:
Searcher
<
'
h
>
}
impl
<
'
r
'
h
A
:
Automaton
>
Iterator
for
FindMatches
<
'
r
'
h
A
>
{
type
Item
=
Match
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
Match
>
{
let
FindMatches
{
re
ref
mut
it
}
=
*
self
;
it
.
advance
(
|
input
|
re
.
try_search
(
input
)
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Builder
{
#
[
cfg
(
feature
=
"
dfa
-
build
"
)
]
dfa
:
dense
:
:
Builder
}
impl
Builder
{
pub
fn
new
(
)
-
>
Builder
{
Builder
{
#
[
cfg
(
feature
=
"
dfa
-
build
"
)
]
dfa
:
dense
:
:
Builder
:
:
new
(
)
}
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
pub
fn
build
(
&
self
pattern
:
&
str
)
-
>
Result
<
Regex
BuildError
>
{
self
.
build_many
(
&
[
pattern
]
)
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
pub
fn
build_sparse
(
&
self
pattern
:
&
str
)
-
>
Result
<
Regex
<
sparse
:
:
DFA
<
Vec
<
u8
>
>
>
BuildError
>
{
self
.
build_many_sparse
(
&
[
pattern
]
)
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
pub
fn
build_many
<
P
:
AsRef
<
str
>
>
(
&
self
patterns
:
&
[
P
]
)
-
>
Result
<
Regex
BuildError
>
{
let
forward
=
self
.
dfa
.
build_many
(
patterns
)
?
;
let
reverse
=
self
.
dfa
.
clone
(
)
.
configure
(
dense
:
:
Config
:
:
new
(
)
.
prefilter
(
None
)
.
specialize_start_states
(
false
)
.
start_kind
(
StartKind
:
:
Anchored
)
.
match_kind
(
MatchKind
:
:
All
)
)
.
thompson
(
crate
:
:
nfa
:
:
thompson
:
:
Config
:
:
new
(
)
.
reverse
(
true
)
)
.
build_many
(
patterns
)
?
;
Ok
(
self
.
build_from_dfas
(
forward
reverse
)
)
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
pub
fn
build_many_sparse
<
P
:
AsRef
<
str
>
>
(
&
self
patterns
:
&
[
P
]
)
-
>
Result
<
Regex
<
sparse
:
:
DFA
<
Vec
<
u8
>
>
>
BuildError
>
{
let
re
=
self
.
build_many
(
patterns
)
?
;
let
forward
=
re
.
forward
(
)
.
to_sparse
(
)
?
;
let
reverse
=
re
.
reverse
(
)
.
to_sparse
(
)
?
;
Ok
(
self
.
build_from_dfas
(
forward
reverse
)
)
}
pub
fn
build_from_dfas
<
A
:
Automaton
>
(
&
self
forward
:
A
reverse
:
A
)
-
>
Regex
<
A
>
{
Regex
{
forward
reverse
}
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
pub
fn
syntax
(
&
mut
self
config
:
crate
:
:
util
:
:
syntax
:
:
Config
)
-
>
&
mut
Builder
{
self
.
dfa
.
syntax
(
config
)
;
self
}
#
[
cfg
(
all
(
feature
=
"
syntax
"
feature
=
"
dfa
-
build
"
)
)
]
pub
fn
thompson
(
&
mut
self
config
:
crate
:
:
nfa
:
:
thompson
:
:
Config
)
-
>
&
mut
Builder
{
self
.
dfa
.
thompson
(
config
)
;
self
}
#
[
cfg
(
feature
=
"
dfa
-
build
"
)
]
pub
fn
dense
(
&
mut
self
config
:
dense
:
:
Config
)
-
>
&
mut
Builder
{
self
.
dfa
.
configure
(
config
)
;
self
}
}
impl
Default
for
Builder
{
fn
default
(
)
-
>
Builder
{
Builder
:
:
new
(
)
}
}
