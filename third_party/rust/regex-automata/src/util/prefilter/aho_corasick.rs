use
crate
:
:
util
:
:
{
prefilter
:
:
PrefilterI
search
:
:
{
MatchKind
Span
}
}
;
#
[
derive
(
Clone
Debug
)
]
pub
(
crate
)
struct
AhoCorasick
{
#
[
cfg
(
not
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
)
]
_unused
:
(
)
#
[
cfg
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
]
ac
:
aho_corasick
:
:
AhoCorasick
}
impl
AhoCorasick
{
pub
(
crate
)
fn
new
<
B
:
AsRef
<
[
u8
]
>
>
(
kind
:
MatchKind
needles
:
&
[
B
]
)
-
>
Option
<
AhoCorasick
>
{
#
[
cfg
(
not
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
)
]
{
None
}
#
[
cfg
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
]
{
let
ac_match_kind
=
match
kind
{
MatchKind
:
:
LeftmostFirst
|
MatchKind
:
:
All
=
>
{
aho_corasick
:
:
MatchKind
:
:
LeftmostFirst
}
}
;
let
ac_kind
=
if
needles
.
len
(
)
<
=
500
{
aho_corasick
:
:
AhoCorasickKind
:
:
DFA
}
else
{
aho_corasick
:
:
AhoCorasickKind
:
:
ContiguousNFA
}
;
let
result
=
aho_corasick
:
:
AhoCorasick
:
:
builder
(
)
.
kind
(
Some
(
ac_kind
)
)
.
match_kind
(
ac_match_kind
)
.
start_kind
(
aho_corasick
:
:
StartKind
:
:
Both
)
.
prefilter
(
false
)
.
build
(
needles
)
;
let
ac
=
match
result
{
Ok
(
ac
)
=
>
ac
Err
(
_err
)
=
>
{
debug
!
(
"
aho
-
corasick
prefilter
failed
to
build
:
{
}
"
_err
)
;
return
None
;
}
}
;
Some
(
AhoCorasick
{
ac
}
)
}
}
}
impl
PrefilterI
for
AhoCorasick
{
fn
find
(
&
self
haystack
:
&
[
u8
]
span
:
Span
)
-
>
Option
<
Span
>
{
#
[
cfg
(
not
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
)
]
{
unreachable
!
(
)
}
#
[
cfg
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
]
{
let
input
=
aho_corasick
:
:
Input
:
:
new
(
haystack
)
.
span
(
span
.
start
.
.
span
.
end
)
;
self
.
ac
.
find
(
input
)
.
map
(
|
m
|
Span
{
start
:
m
.
start
(
)
end
:
m
.
end
(
)
}
)
}
}
fn
prefix
(
&
self
haystack
:
&
[
u8
]
span
:
Span
)
-
>
Option
<
Span
>
{
#
[
cfg
(
not
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
)
]
{
unreachable
!
(
)
}
#
[
cfg
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
]
{
let
input
=
aho_corasick
:
:
Input
:
:
new
(
haystack
)
.
anchored
(
aho_corasick
:
:
Anchored
:
:
Yes
)
.
span
(
span
.
start
.
.
span
.
end
)
;
self
.
ac
.
find
(
input
)
.
map
(
|
m
|
Span
{
start
:
m
.
start
(
)
end
:
m
.
end
(
)
}
)
}
}
fn
memory_usage
(
&
self
)
-
>
usize
{
#
[
cfg
(
not
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
)
]
{
unreachable
!
(
)
}
#
[
cfg
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
]
{
self
.
ac
.
memory_usage
(
)
}
}
fn
is_fast
(
&
self
)
-
>
bool
{
#
[
cfg
(
not
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
)
]
{
unreachable
!
(
)
}
#
[
cfg
(
feature
=
"
perf
-
literal
-
multisubstring
"
)
]
{
false
}
}
}
