use
alloc
:
:
vec
:
:
Vec
;
use
regex_syntax
:
:
hir
:
:
{
self
literal
Hir
HirKind
}
;
use
crate
:
:
{
util
:
:
prefilter
:
:
Prefilter
MatchKind
}
;
pub
(
crate
)
fn
extract
(
hirs
:
&
[
&
Hir
]
)
-
>
Option
<
(
Hir
Prefilter
)
>
{
if
hirs
.
len
(
)
!
=
1
{
debug
!
(
"
skipping
reverse
inner
optimization
since
it
only
\
supports
1
pattern
{
}
were
given
"
hirs
.
len
(
)
)
;
return
None
;
}
let
mut
concat
=
match
top_concat
(
hirs
[
0
]
)
{
Some
(
concat
)
=
>
concat
None
=
>
{
debug
!
(
"
skipping
reverse
inner
optimization
because
a
top
-
level
\
concatenation
could
not
found
"
)
;
return
None
;
}
}
;
for
i
in
1
.
.
concat
.
len
(
)
{
let
hir
=
&
concat
[
i
]
;
let
pre
=
match
prefilter
(
hir
)
{
None
=
>
continue
Some
(
pre
)
=
>
pre
}
;
if
!
pre
.
is_fast
(
)
{
debug
!
(
"
skipping
extracted
inner
prefilter
because
\
it
probably
isn
'
t
fast
"
)
;
continue
;
}
let
concat_suffix
=
Hir
:
:
concat
(
concat
.
split_off
(
i
)
)
;
let
concat_prefix
=
Hir
:
:
concat
(
concat
)
;
let
pre2
=
match
prefilter
(
&
concat_suffix
)
{
None
=
>
pre
Some
(
pre2
)
=
>
{
if
pre2
.
is_fast
(
)
{
pre2
}
else
{
pre
}
}
}
;
return
Some
(
(
concat_prefix
pre2
)
)
;
}
debug
!
(
"
skipping
reverse
inner
optimization
because
a
top
-
level
\
sub
-
expression
with
a
fast
prefilter
could
not
be
found
"
)
;
None
}
fn
prefilter
(
hir
:
&
Hir
)
-
>
Option
<
Prefilter
>
{
let
mut
extractor
=
literal
:
:
Extractor
:
:
new
(
)
;
extractor
.
kind
(
literal
:
:
ExtractKind
:
:
Prefix
)
;
let
mut
prefixes
=
extractor
.
extract
(
hir
)
;
debug
!
(
"
inner
prefixes
(
len
=
{
:
?
}
)
extracted
before
optimization
:
{
:
?
}
"
prefixes
.
len
(
)
prefixes
)
;
prefixes
.
make_inexact
(
)
;
prefixes
.
optimize_for_prefix_by_preference
(
)
;
debug
!
(
"
inner
prefixes
(
len
=
{
:
?
}
)
extracted
after
optimization
:
{
:
?
}
"
prefixes
.
len
(
)
prefixes
)
;
prefixes
.
literals
(
)
.
and_then
(
|
lits
|
Prefilter
:
:
new
(
MatchKind
:
:
LeftmostFirst
lits
)
)
}
fn
top_concat
(
mut
hir
:
&
Hir
)
-
>
Option
<
Vec
<
Hir
>
>
{
loop
{
hir
=
match
hir
.
kind
(
)
{
HirKind
:
:
Empty
|
HirKind
:
:
Literal
(
_
)
|
HirKind
:
:
Class
(
_
)
|
HirKind
:
:
Look
(
_
)
|
HirKind
:
:
Repetition
(
_
)
|
HirKind
:
:
Alternation
(
_
)
=
>
return
None
HirKind
:
:
Capture
(
hir
:
:
Capture
{
ref
sub
.
.
}
)
=
>
sub
HirKind
:
:
Concat
(
ref
subs
)
=
>
{
let
concat
=
Hir
:
:
concat
(
subs
.
iter
(
)
.
map
(
|
h
|
flatten
(
h
)
)
.
collect
(
)
)
;
return
match
concat
.
into_kind
(
)
{
HirKind
:
:
Concat
(
xs
)
=
>
Some
(
xs
)
_
=
>
return
None
}
;
}
}
;
}
}
fn
flatten
(
hir
:
&
Hir
)
-
>
Hir
{
match
hir
.
kind
(
)
{
HirKind
:
:
Empty
=
>
Hir
:
:
empty
(
)
HirKind
:
:
Literal
(
hir
:
:
Literal
(
ref
x
)
)
=
>
Hir
:
:
literal
(
x
.
clone
(
)
)
HirKind
:
:
Class
(
ref
x
)
=
>
Hir
:
:
class
(
x
.
clone
(
)
)
HirKind
:
:
Look
(
ref
x
)
=
>
Hir
:
:
look
(
x
.
clone
(
)
)
HirKind
:
:
Repetition
(
ref
x
)
=
>
Hir
:
:
repetition
(
x
.
with
(
flatten
(
&
x
.
sub
)
)
)
HirKind
:
:
Capture
(
hir
:
:
Capture
{
ref
sub
.
.
}
)
=
>
flatten
(
sub
)
HirKind
:
:
Alternation
(
ref
xs
)
=
>
{
Hir
:
:
alternation
(
xs
.
iter
(
)
.
map
(
|
x
|
flatten
(
x
)
)
.
collect
(
)
)
}
HirKind
:
:
Concat
(
ref
xs
)
=
>
{
Hir
:
:
concat
(
xs
.
iter
(
)
.
map
(
|
x
|
flatten
(
x
)
)
.
collect
(
)
)
}
}
}
