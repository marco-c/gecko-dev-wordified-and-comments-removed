#
[
allow
(
unused_macro_rules
)
]
macro_rules
!
cfg_if
{
(
(
if
#
[
cfg
(
(
meta
:
meta
)
*
)
]
{
(
it
:
item
)
*
}
)
else
*
else
{
(
it2
:
item
)
*
}
)
=
>
{
cfg_if
!
{
__items
(
)
;
(
(
(
(
meta
)
*
)
(
(
it
)
*
)
)
)
*
(
(
)
(
(
it2
)
*
)
)
}
}
;
(
if
#
[
cfg
(
(
i_met
:
meta
)
*
)
]
{
(
i_it
:
item
)
*
}
(
else
if
#
[
cfg
(
(
e_met
:
meta
)
*
)
]
{
(
e_it
:
item
)
*
}
)
*
)
=
>
{
cfg_if
!
{
__items
(
)
;
(
(
(
i_met
)
*
)
(
(
i_it
)
*
)
)
(
(
(
(
e_met
)
*
)
(
(
e_it
)
*
)
)
)
*
(
(
)
(
)
)
}
}
;
(
__items
(
(
not
:
meta
)
*
)
;
)
=
>
{
}
;
(
__items
(
(
not
:
meta
)
*
)
;
(
(
(
m
:
meta
)
*
)
(
(
it
:
item
)
*
)
)
(
rest
:
tt
)
*
)
=
>
{
/
/
Emit
all
items
within
one
block
applying
an
approprate
#
[
cfg
]
.
The
/
/
#
[
cfg
]
will
require
all
m
matchers
specified
and
must
also
negate
/
/
all
previous
matchers
.
cfg_if
!
{
__apply
cfg
(
all
(
(
m
)
*
not
(
any
(
(
not
)
*
)
)
)
)
(
it
)
*
}
/
/
Recurse
to
emit
all
other
items
in
rest
and
when
we
do
so
add
all
/
/
our
m
matchers
to
the
list
of
not
matchers
as
future
emissions
/
/
will
have
to
negate
everything
we
just
matched
as
well
.
cfg_if
!
{
__items
(
(
not
)
*
(
m
)
*
)
;
(
rest
)
*
}
}
;
(
__apply
m
:
meta
(
it
:
item
)
*
)
=
>
{
(
#
[
m
]
it
)
*
}
;
}
#
[
cfg
(
feature
=
"
nightly
"
)
]
macro_rules
!
default_fn
{
(
#
[
(
a
:
tt
)
*
]
(
tt
:
tt
)
*
)
=
>
{
#
[
(
a
)
*
]
default
(
tt
)
*
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
macro_rules
!
default_fn
{
(
(
tt
:
tt
)
*
)
=
>
{
(
tt
)
*
}
}
