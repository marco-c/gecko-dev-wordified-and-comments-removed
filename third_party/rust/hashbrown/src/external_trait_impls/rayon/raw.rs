use
alloc
:
:
alloc
:
:
dealloc
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
use
core
:
:
ptr
:
:
NonNull
;
use
raw
:
:
Bucket
;
use
raw
:
:
{
RawIterRange
RawTable
}
;
use
rayon
:
:
iter
:
:
{
plumbing
:
:
{
self
Folder
UnindexedConsumer
UnindexedProducer
}
ParallelIterator
}
;
use
scopeguard
:
:
guard
;
pub
struct
RawParIter
<
T
>
{
iter
:
RawIterRange
<
T
>
}
unsafe
impl
<
T
>
Send
for
RawParIter
<
T
>
{
}
impl
<
T
>
ParallelIterator
for
RawParIter
<
T
>
{
type
Item
=
Bucket
<
T
>
;
#
[
inline
]
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
producer
=
ParIterProducer
{
iter
:
self
.
iter
}
;
plumbing
:
:
bridge_unindexed
(
producer
consumer
)
}
}
struct
ParIterProducer
<
T
>
{
iter
:
RawIterRange
<
T
>
}
unsafe
impl
<
T
>
Send
for
ParIterProducer
<
T
>
{
}
impl
<
T
>
UnindexedProducer
for
ParIterProducer
<
T
>
{
type
Item
=
Bucket
<
T
>
;
#
[
inline
]
fn
split
(
self
)
-
>
(
Self
Option
<
Self
>
)
{
let
(
left
right
)
=
self
.
iter
.
split
(
)
;
let
left
=
ParIterProducer
{
iter
:
left
}
;
let
right
=
right
.
map
(
|
right
|
ParIterProducer
{
iter
:
right
}
)
;
(
left
right
)
}
#
[
inline
]
fn
fold_with
<
F
>
(
self
folder
:
F
)
-
>
F
where
F
:
Folder
<
Self
:
:
Item
>
{
folder
.
consume_iter
(
self
.
iter
)
}
}
pub
struct
RawIntoParIter
<
T
>
{
table
:
RawTable
<
T
>
}
unsafe
impl
<
T
>
Send
for
RawIntoParIter
<
T
>
{
}
impl
<
T
:
Send
>
ParallelIterator
for
RawIntoParIter
<
T
>
{
type
Item
=
T
;
#
[
inline
]
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
iter
=
unsafe
{
self
.
table
.
iter
(
)
.
iter
}
;
let
_guard
=
guard
(
self
.
table
.
into_alloc
(
)
|
alloc
|
{
if
let
Some
(
(
ptr
layout
)
)
=
*
alloc
{
unsafe
{
dealloc
(
ptr
.
as_ptr
(
)
layout
)
;
}
}
}
)
;
let
producer
=
ParDrainProducer
{
iter
}
;
plumbing
:
:
bridge_unindexed
(
producer
consumer
)
}
}
pub
struct
RawParDrain
<
'
a
T
>
{
table
:
NonNull
<
RawTable
<
T
>
>
_marker
:
PhantomData
<
&
'
a
RawTable
<
T
>
>
}
unsafe
impl
<
'
a
T
>
Send
for
RawParDrain
<
'
a
T
>
{
}
impl
<
'
a
T
:
Send
>
ParallelIterator
for
RawParDrain
<
'
a
T
>
{
type
Item
=
T
;
#
[
inline
]
fn
drive_unindexed
<
C
>
(
self
consumer
:
C
)
-
>
C
:
:
Result
where
C
:
UnindexedConsumer
<
Self
:
:
Item
>
{
let
_guard
=
guard
(
self
.
table
|
table
|
unsafe
{
table
.
as_mut
(
)
.
clear_no_drop
(
)
}
)
;
let
iter
=
unsafe
{
self
.
table
.
as_ref
(
)
.
iter
(
)
.
iter
}
;
mem
:
:
forget
(
self
)
;
let
producer
=
ParDrainProducer
{
iter
}
;
plumbing
:
:
bridge_unindexed
(
producer
consumer
)
}
}
impl
<
'
a
T
>
Drop
for
RawParDrain
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
table
.
as_mut
(
)
.
clear
(
)
}
}
}
struct
ParDrainProducer
<
T
>
{
iter
:
RawIterRange
<
T
>
}
unsafe
impl
<
T
:
Send
>
Send
for
ParDrainProducer
<
T
>
{
}
impl
<
T
:
Send
>
UnindexedProducer
for
ParDrainProducer
<
T
>
{
type
Item
=
T
;
#
[
inline
]
fn
split
(
self
)
-
>
(
Self
Option
<
Self
>
)
{
let
(
left
right
)
=
self
.
iter
.
clone
(
)
.
split
(
)
;
mem
:
:
forget
(
self
)
;
let
left
=
ParDrainProducer
{
iter
:
left
}
;
let
right
=
right
.
map
(
|
right
|
ParDrainProducer
{
iter
:
right
}
)
;
(
left
right
)
}
#
[
inline
]
fn
fold_with
<
F
>
(
mut
self
mut
folder
:
F
)
-
>
F
where
F
:
Folder
<
Self
:
:
Item
>
{
while
let
Some
(
item
)
=
self
.
iter
.
next
(
)
{
folder
=
folder
.
consume
(
unsafe
{
item
.
read
(
)
}
)
;
if
folder
.
full
(
)
{
return
folder
;
}
}
mem
:
:
forget
(
self
)
;
folder
}
}
impl
<
T
>
Drop
for
ParDrainProducer
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
mem
:
:
needs_drop
:
:
<
T
>
(
)
{
while
let
Some
(
item
)
=
self
.
iter
.
next
(
)
{
unsafe
{
item
.
drop
(
)
;
}
}
}
}
}
impl
<
T
>
RawTable
<
T
>
{
#
[
inline
]
pub
fn
par_iter
(
&
self
)
-
>
RawParIter
<
T
>
{
RawParIter
{
iter
:
unsafe
{
self
.
iter
(
)
.
iter
}
}
}
#
[
inline
]
pub
fn
into_par_iter
(
self
)
-
>
RawIntoParIter
<
T
>
{
RawIntoParIter
{
table
:
self
}
}
#
[
inline
]
pub
fn
par_drain
(
&
mut
self
)
-
>
RawParDrain
<
T
>
{
RawParDrain
{
table
:
NonNull
:
:
from
(
self
)
_marker
:
PhantomData
}
}
}
