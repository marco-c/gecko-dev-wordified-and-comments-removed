use
self
:
:
RustcEntry
:
:
*
;
use
crate
:
:
map
:
:
{
make_insert_hash
Drain
HashMap
IntoIter
Iter
IterMut
}
;
use
crate
:
:
raw
:
:
{
Allocator
Bucket
Global
RawTable
}
;
use
core
:
:
fmt
:
:
{
self
Debug
}
;
use
core
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
core
:
:
mem
;
impl
<
K
V
S
A
>
HashMap
<
K
V
S
A
>
where
K
:
Eq
+
Hash
S
:
BuildHasher
A
:
Allocator
+
Clone
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
rustc_entry
(
&
mut
self
key
:
K
)
-
>
RustcEntry
<
'
_
K
V
A
>
{
let
hash
=
make_insert_hash
(
&
self
.
hash_builder
&
key
)
;
if
let
Some
(
elem
)
=
self
.
table
.
find
(
hash
|
q
|
q
.
0
.
eq
(
&
key
)
)
{
RustcEntry
:
:
Occupied
(
RustcOccupiedEntry
{
key
:
Some
(
key
)
elem
table
:
&
mut
self
.
table
}
)
}
else
{
self
.
reserve
(
1
)
;
RustcEntry
:
:
Vacant
(
RustcVacantEntry
{
hash
key
table
:
&
mut
self
.
table
}
)
}
}
}
pub
enum
RustcEntry
<
'
a
K
V
A
=
Global
>
where
A
:
Allocator
+
Clone
{
Occupied
(
RustcOccupiedEntry
<
'
a
K
V
A
>
)
Vacant
(
RustcVacantEntry
<
'
a
K
V
A
>
)
}
impl
<
K
:
Debug
V
:
Debug
A
:
Allocator
+
Clone
>
Debug
for
RustcEntry
<
'
_
K
V
A
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Vacant
(
ref
v
)
=
>
f
.
debug_tuple
(
"
Entry
"
)
.
field
(
v
)
.
finish
(
)
Occupied
(
ref
o
)
=
>
f
.
debug_tuple
(
"
Entry
"
)
.
field
(
o
)
.
finish
(
)
}
}
}
pub
struct
RustcOccupiedEntry
<
'
a
K
V
A
=
Global
>
where
A
:
Allocator
+
Clone
{
key
:
Option
<
K
>
elem
:
Bucket
<
(
K
V
)
>
table
:
&
'
a
mut
RawTable
<
(
K
V
)
A
>
}
unsafe
impl
<
K
V
A
>
Send
for
RustcOccupiedEntry
<
'
_
K
V
A
>
where
K
:
Send
V
:
Send
A
:
Allocator
+
Clone
+
Send
{
}
unsafe
impl
<
K
V
A
>
Sync
for
RustcOccupiedEntry
<
'
_
K
V
A
>
where
K
:
Sync
V
:
Sync
A
:
Allocator
+
Clone
+
Sync
{
}
impl
<
K
:
Debug
V
:
Debug
A
:
Allocator
+
Clone
>
Debug
for
RustcOccupiedEntry
<
'
_
K
V
A
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_struct
(
"
OccupiedEntry
"
)
.
field
(
"
key
"
self
.
key
(
)
)
.
field
(
"
value
"
self
.
get
(
)
)
.
finish
(
)
}
}
pub
struct
RustcVacantEntry
<
'
a
K
V
A
=
Global
>
where
A
:
Allocator
+
Clone
{
hash
:
u64
key
:
K
table
:
&
'
a
mut
RawTable
<
(
K
V
)
A
>
}
impl
<
K
:
Debug
V
A
:
Allocator
+
Clone
>
Debug
for
RustcVacantEntry
<
'
_
K
V
A
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
VacantEntry
"
)
.
field
(
self
.
key
(
)
)
.
finish
(
)
}
}
impl
<
'
a
K
V
A
:
Allocator
+
Clone
>
RustcEntry
<
'
a
K
V
A
>
{
pub
fn
insert
(
self
value
:
V
)
-
>
RustcOccupiedEntry
<
'
a
K
V
A
>
{
match
self
{
Vacant
(
entry
)
=
>
entry
.
insert_entry
(
value
)
Occupied
(
mut
entry
)
=
>
{
entry
.
insert
(
value
)
;
entry
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
or_insert
(
self
default
:
V
)
-
>
&
'
a
mut
V
where
K
:
Hash
{
match
self
{
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Vacant
(
entry
)
=
>
entry
.
insert
(
default
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
or_insert_with
<
F
:
FnOnce
(
)
-
>
V
>
(
self
default
:
F
)
-
>
&
'
a
mut
V
where
K
:
Hash
{
match
self
{
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Vacant
(
entry
)
=
>
entry
.
insert
(
default
(
)
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
key
(
&
self
)
-
>
&
K
{
match
*
self
{
Occupied
(
ref
entry
)
=
>
entry
.
key
(
)
Vacant
(
ref
entry
)
=
>
entry
.
key
(
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
and_modify
<
F
>
(
self
f
:
F
)
-
>
Self
where
F
:
FnOnce
(
&
mut
V
)
{
match
self
{
Occupied
(
mut
entry
)
=
>
{
f
(
entry
.
get_mut
(
)
)
;
Occupied
(
entry
)
}
Vacant
(
entry
)
=
>
Vacant
(
entry
)
}
}
}
impl
<
'
a
K
V
:
Default
A
:
Allocator
+
Clone
>
RustcEntry
<
'
a
K
V
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
or_default
(
self
)
-
>
&
'
a
mut
V
where
K
:
Hash
{
match
self
{
Occupied
(
entry
)
=
>
entry
.
into_mut
(
)
Vacant
(
entry
)
=
>
entry
.
insert
(
Default
:
:
default
(
)
)
}
}
}
impl
<
'
a
K
V
A
:
Allocator
+
Clone
>
RustcOccupiedEntry
<
'
a
K
V
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
key
(
&
self
)
-
>
&
K
{
unsafe
{
&
self
.
elem
.
as_ref
(
)
.
0
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
remove_entry
(
self
)
-
>
(
K
V
)
{
unsafe
{
self
.
table
.
remove
(
self
.
elem
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
get
(
&
self
)
-
>
&
V
{
unsafe
{
&
self
.
elem
.
as_ref
(
)
.
1
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
get_mut
(
&
mut
self
)
-
>
&
mut
V
{
unsafe
{
&
mut
self
.
elem
.
as_mut
(
)
.
1
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
into_mut
(
self
)
-
>
&
'
a
mut
V
{
unsafe
{
&
mut
self
.
elem
.
as_mut
(
)
.
1
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
insert
(
&
mut
self
value
:
V
)
-
>
V
{
mem
:
:
replace
(
self
.
get_mut
(
)
value
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
remove
(
self
)
-
>
V
{
self
.
remove_entry
(
)
.
1
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
replace_entry
(
self
value
:
V
)
-
>
(
K
V
)
{
let
entry
=
unsafe
{
self
.
elem
.
as_mut
(
)
}
;
let
old_key
=
mem
:
:
replace
(
&
mut
entry
.
0
self
.
key
.
unwrap
(
)
)
;
let
old_value
=
mem
:
:
replace
(
&
mut
entry
.
1
value
)
;
(
old_key
old_value
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
replace_key
(
self
)
-
>
K
{
let
entry
=
unsafe
{
self
.
elem
.
as_mut
(
)
}
;
mem
:
:
replace
(
&
mut
entry
.
0
self
.
key
.
unwrap
(
)
)
}
}
impl
<
'
a
K
V
A
:
Allocator
+
Clone
>
RustcVacantEntry
<
'
a
K
V
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
key
(
&
self
)
-
>
&
K
{
&
self
.
key
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
into_key
(
self
)
-
>
K
{
self
.
key
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
insert
(
self
value
:
V
)
-
>
&
'
a
mut
V
{
unsafe
{
let
bucket
=
self
.
table
.
insert_no_grow
(
self
.
hash
(
self
.
key
value
)
)
;
&
mut
bucket
.
as_mut
(
)
.
1
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
insert_entry
(
self
value
:
V
)
-
>
RustcOccupiedEntry
<
'
a
K
V
A
>
{
let
bucket
=
unsafe
{
self
.
table
.
insert_no_grow
(
self
.
hash
(
self
.
key
value
)
)
}
;
RustcOccupiedEntry
{
key
:
None
elem
:
bucket
table
:
self
.
table
}
}
}
impl
<
K
V
>
IterMut
<
'
_
K
V
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
rustc_iter
(
&
self
)
-
>
Iter
<
'
_
K
V
>
{
self
.
iter
(
)
}
}
impl
<
K
V
>
IntoIter
<
K
V
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
rustc_iter
(
&
self
)
-
>
Iter
<
'
_
K
V
>
{
self
.
iter
(
)
}
}
impl
<
K
V
>
Drain
<
'
_
K
V
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
rustc_iter
(
&
self
)
-
>
Iter
<
'
_
K
V
>
{
self
.
iter
(
)
}
}
