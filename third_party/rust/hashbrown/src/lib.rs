#
!
[
no_std
]
#
!
[
cfg_attr
(
feature
=
"
nightly
"
feature
(
test
core_intrinsics
dropck_eyepatch
min_specialization
extend_one
allocator_api
slice_ptr_get
nonnull_slice_from_raw_parts
maybe_uninit_array_assume_init
build_hasher_simple_hash_one
)
)
]
#
!
[
allow
(
clippy
:
:
doc_markdown
clippy
:
:
module_name_repetitions
clippy
:
:
must_use_candidate
clippy
:
:
option_if_let_else
clippy
:
:
redundant_else
clippy
:
:
manual_map
clippy
:
:
missing_safety_doc
clippy
:
:
missing_errors_doc
)
]
#
!
[
warn
(
missing_docs
)
]
#
!
[
warn
(
rust_2018_idioms
)
]
#
[
cfg
(
test
)
]
#
[
macro_use
]
extern
crate
std
;
#
[
cfg_attr
(
test
macro_use
)
]
extern
crate
alloc
;
#
[
cfg
(
feature
=
"
nightly
"
)
]
#
[
cfg
(
doctest
)
]
doc_comment
:
:
doctest
!
(
"
.
.
/
README
.
md
"
)
;
#
[
macro_use
]
mod
macros
;
#
[
cfg
(
feature
=
"
raw
"
)
]
pub
mod
raw
{
#
[
allow
(
missing_docs
)
]
#
[
path
=
"
mod
.
rs
"
]
mod
inner
;
pub
use
inner
:
:
*
;
#
[
cfg
(
feature
=
"
rayon
"
)
]
pub
mod
rayon
{
pub
use
crate
:
:
external_trait_impls
:
:
rayon
:
:
raw
:
:
*
;
}
}
#
[
cfg
(
not
(
feature
=
"
raw
"
)
)
]
mod
raw
;
mod
external_trait_impls
;
mod
map
;
#
[
cfg
(
feature
=
"
rustc
-
internal
-
api
"
)
]
mod
rustc_entry
;
mod
scopeguard
;
mod
set
;
pub
mod
hash_map
{
pub
use
crate
:
:
map
:
:
*
;
#
[
cfg
(
feature
=
"
rustc
-
internal
-
api
"
)
]
pub
use
crate
:
:
rustc_entry
:
:
*
;
#
[
cfg
(
feature
=
"
rayon
"
)
]
pub
mod
rayon
{
pub
use
crate
:
:
external_trait_impls
:
:
rayon
:
:
map
:
:
*
;
}
}
pub
mod
hash_set
{
pub
use
crate
:
:
set
:
:
*
;
#
[
cfg
(
feature
=
"
rayon
"
)
]
pub
mod
rayon
{
pub
use
crate
:
:
external_trait_impls
:
:
rayon
:
:
set
:
:
*
;
}
}
pub
use
crate
:
:
map
:
:
HashMap
;
pub
use
crate
:
:
set
:
:
HashSet
;
#
[
derive
(
Clone
PartialEq
Eq
Debug
)
]
pub
enum
TryReserveError
{
CapacityOverflow
AllocError
{
layout
:
alloc
:
:
alloc
:
:
Layout
}
}
#
[
cfg
(
feature
=
"
bumpalo
"
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
BumpWrapper
<
'
a
>
(
pub
&
'
a
bumpalo
:
:
Bump
)
;
#
[
cfg
(
feature
=
"
bumpalo
"
)
]
#
[
test
]
fn
test_bumpalo
(
)
{
use
bumpalo
:
:
Bump
;
let
bump
=
Bump
:
:
new
(
)
;
let
mut
map
=
HashMap
:
:
new_in
(
BumpWrapper
(
&
bump
)
)
;
map
.
insert
(
0
1
)
;
}
