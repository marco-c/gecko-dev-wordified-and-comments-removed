use
super
:
:
bitmask
:
:
BitMask
;
use
super
:
:
EMPTY
;
use
core
:
:
mem
;
#
[
cfg
(
target_arch
=
"
x86
"
)
]
use
core
:
:
arch
:
:
x86
;
#
[
cfg
(
target_arch
=
"
x86_64
"
)
]
use
core
:
:
arch
:
:
x86_64
as
x86
;
pub
type
BitMaskWord
=
u16
;
pub
const
BITMASK_STRIDE
:
usize
=
1
;
pub
const
BITMASK_MASK
:
BitMaskWord
=
0xffff
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
Group
(
x86
:
:
__m128i
)
;
impl
Group
{
pub
const
WIDTH
:
usize
=
mem
:
:
size_of
:
:
<
Self
>
(
)
;
#
[
inline
]
pub
fn
static_empty
(
)
-
>
&
'
static
[
u8
]
{
union
AlignedBytes
{
_align
:
Group
bytes
:
[
u8
;
Group
:
:
WIDTH
]
}
;
const
ALIGNED_BYTES
:
AlignedBytes
=
AlignedBytes
{
bytes
:
[
EMPTY
;
Group
:
:
WIDTH
]
}
;
unsafe
{
&
ALIGNED_BYTES
.
bytes
}
}
#
[
inline
]
pub
unsafe
fn
load
(
ptr
:
*
const
u8
)
-
>
Group
{
Group
(
x86
:
:
_mm_loadu_si128
(
ptr
as
*
const
_
)
)
}
#
[
inline
]
pub
unsafe
fn
load_aligned
(
ptr
:
*
const
u8
)
-
>
Group
{
debug_assert_eq
!
(
ptr
as
usize
&
(
mem
:
:
align_of
:
:
<
Group
>
(
)
-
1
)
0
)
;
Group
(
x86
:
:
_mm_load_si128
(
ptr
as
*
const
_
)
)
}
#
[
inline
]
pub
unsafe
fn
store_aligned
(
&
self
ptr
:
*
mut
u8
)
{
debug_assert_eq
!
(
ptr
as
usize
&
(
mem
:
:
align_of
:
:
<
Group
>
(
)
-
1
)
0
)
;
x86
:
:
_mm_store_si128
(
ptr
as
*
mut
_
self
.
0
)
;
}
#
[
inline
]
pub
fn
match_byte
(
&
self
byte
:
u8
)
-
>
BitMask
{
unsafe
{
let
cmp
=
x86
:
:
_mm_cmpeq_epi8
(
self
.
0
x86
:
:
_mm_set1_epi8
(
byte
as
i8
)
)
;
BitMask
(
x86
:
:
_mm_movemask_epi8
(
cmp
)
as
u16
)
}
}
#
[
inline
]
pub
fn
match_empty
(
&
self
)
-
>
BitMask
{
self
.
match_byte
(
EMPTY
)
}
#
[
inline
]
pub
fn
match_empty_or_deleted
(
&
self
)
-
>
BitMask
{
unsafe
{
BitMask
(
x86
:
:
_mm_movemask_epi8
(
self
.
0
)
as
u16
)
}
}
#
[
inline
]
pub
fn
convert_special_to_empty_and_full_to_deleted
(
&
self
)
-
>
Group
{
unsafe
{
let
zero
=
x86
:
:
_mm_setzero_si128
(
)
;
let
special
=
x86
:
:
_mm_cmpgt_epi8
(
zero
self
.
0
)
;
Group
(
x86
:
:
_mm_or_si128
(
special
x86
:
:
_mm_set1_epi8
(
0x80u8
as
i8
)
)
)
}
}
}
