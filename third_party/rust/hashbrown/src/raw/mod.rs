use
crate
:
:
alloc
:
:
alloc
:
:
{
handle_alloc_error
Layout
}
;
use
crate
:
:
control
:
:
{
BitMaskIter
Group
Tag
TagSliceExt
}
;
use
crate
:
:
scopeguard
:
:
{
guard
ScopeGuard
}
;
use
crate
:
:
util
:
:
{
invalid_mut
likely
unlikely
}
;
use
crate
:
:
TryReserveError
;
use
core
:
:
array
;
use
core
:
:
iter
:
:
FusedIterator
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
;
use
core
:
:
ptr
:
:
NonNull
;
use
core
:
:
slice
;
use
core
:
:
{
hint
ptr
}
;
mod
alloc
;
#
[
cfg
(
test
)
]
pub
(
crate
)
use
self
:
:
alloc
:
:
AllocError
;
pub
(
crate
)
use
self
:
:
alloc
:
:
{
do_alloc
Allocator
Global
}
;
#
[
inline
]
unsafe
fn
offset_from
<
T
>
(
to
:
*
const
T
from
:
*
const
T
)
-
>
usize
{
to
.
offset_from
(
from
)
as
usize
}
#
[
derive
(
Copy
Clone
)
]
enum
Fallibility
{
Fallible
Infallible
}
impl
Fallibility
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
capacity_overflow
(
self
)
-
>
TryReserveError
{
match
self
{
Fallibility
:
:
Fallible
=
>
TryReserveError
:
:
CapacityOverflow
Fallibility
:
:
Infallible
=
>
panic
!
(
"
Hash
table
capacity
overflow
"
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
alloc_err
(
self
layout
:
Layout
)
-
>
TryReserveError
{
match
self
{
Fallibility
:
:
Fallible
=
>
TryReserveError
:
:
AllocError
{
layout
}
Fallibility
:
:
Infallible
=
>
handle_alloc_error
(
layout
)
}
}
}
trait
SizedTypeProperties
:
Sized
{
const
IS_ZERO_SIZED
:
bool
=
mem
:
:
size_of
:
:
<
Self
>
(
)
=
=
0
;
const
NEEDS_DROP
:
bool
=
mem
:
:
needs_drop
:
:
<
Self
>
(
)
;
}
impl
<
T
>
SizedTypeProperties
for
T
{
}
#
[
inline
]
#
[
allow
(
clippy
:
:
cast_possible_truncation
)
]
fn
h1
(
hash
:
u64
)
-
>
usize
{
hash
as
usize
}
#
[
derive
(
Clone
)
]
struct
ProbeSeq
{
pos
:
usize
stride
:
usize
}
impl
ProbeSeq
{
#
[
inline
]
fn
move_next
(
&
mut
self
bucket_mask
:
usize
)
{
debug_assert
!
(
self
.
stride
<
=
bucket_mask
"
Went
past
end
of
probe
sequence
"
)
;
self
.
stride
+
=
Group
:
:
WIDTH
;
self
.
pos
+
=
self
.
stride
;
self
.
pos
&
=
bucket_mask
;
}
}
#
[
cfg_attr
(
target_os
=
"
emscripten
"
inline
(
never
)
)
]
#
[
cfg_attr
(
not
(
target_os
=
"
emscripten
"
)
inline
)
]
fn
capacity_to_buckets
(
cap
:
usize
table_layout
:
TableLayout
)
-
>
Option
<
usize
>
{
debug_assert_ne
!
(
cap
0
)
;
if
cap
<
15
{
let
min_cap
=
match
(
Group
:
:
WIDTH
table_layout
.
size
)
{
(
16
0
.
.
=
1
)
=
>
14
(
16
2
.
.
=
3
)
=
>
7
(
8
0
.
.
=
1
)
=
>
7
_
=
>
3
}
;
let
cap
=
min_cap
.
max
(
cap
)
;
return
Some
(
if
cap
<
4
{
4
}
else
if
cap
<
8
{
8
}
else
{
16
}
)
;
}
let
adjusted_cap
=
cap
.
checked_mul
(
8
)
?
/
7
;
Some
(
adjusted_cap
.
next_power_of_two
(
)
)
}
#
[
inline
]
fn
bucket_mask_to_capacity
(
bucket_mask
:
usize
)
-
>
usize
{
if
bucket_mask
<
8
{
bucket_mask
}
else
{
(
(
bucket_mask
+
1
)
/
8
)
*
7
}
}
#
[
derive
(
Copy
Clone
)
]
struct
TableLayout
{
size
:
usize
ctrl_align
:
usize
}
impl
TableLayout
{
#
[
inline
]
const
fn
new
<
T
>
(
)
-
>
Self
{
let
layout
=
Layout
:
:
new
:
:
<
T
>
(
)
;
Self
{
size
:
layout
.
size
(
)
ctrl_align
:
if
layout
.
align
(
)
>
Group
:
:
WIDTH
{
layout
.
align
(
)
}
else
{
Group
:
:
WIDTH
}
}
}
#
[
inline
]
fn
calculate_layout_for
(
self
buckets
:
usize
)
-
>
Option
<
(
Layout
usize
)
>
{
debug_assert
!
(
buckets
.
is_power_of_two
(
)
)
;
let
TableLayout
{
size
ctrl_align
}
=
self
;
let
ctrl_offset
=
size
.
checked_mul
(
buckets
)
?
.
checked_add
(
ctrl_align
-
1
)
?
&
!
(
ctrl_align
-
1
)
;
let
len
=
ctrl_offset
.
checked_add
(
buckets
+
Group
:
:
WIDTH
)
?
;
if
len
>
isize
:
:
MAX
as
usize
-
(
ctrl_align
-
1
)
{
return
None
;
}
Some
(
(
unsafe
{
Layout
:
:
from_size_align_unchecked
(
len
ctrl_align
)
}
ctrl_offset
)
)
}
}
pub
struct
InsertSlot
{
index
:
usize
}
pub
struct
Bucket
<
T
>
{
ptr
:
NonNull
<
T
>
}
unsafe
impl
<
T
>
Send
for
Bucket
<
T
>
{
}
impl
<
T
>
Clone
for
Bucket
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
Self
{
ptr
:
self
.
ptr
}
}
}
impl
<
T
>
Bucket
<
T
>
{
#
[
inline
]
unsafe
fn
from_base_index
(
base
:
NonNull
<
T
>
index
:
usize
)
-
>
Self
{
let
ptr
=
if
T
:
:
IS_ZERO_SIZED
{
invalid_mut
(
index
+
1
)
}
else
{
base
.
as_ptr
(
)
.
sub
(
index
)
}
;
Self
{
ptr
:
NonNull
:
:
new_unchecked
(
ptr
)
}
}
#
[
inline
]
unsafe
fn
to_base_index
(
&
self
base
:
NonNull
<
T
>
)
-
>
usize
{
if
T
:
:
IS_ZERO_SIZED
{
self
.
ptr
.
as_ptr
(
)
as
usize
-
1
}
else
{
offset_from
(
base
.
as_ptr
(
)
self
.
ptr
.
as_ptr
(
)
)
}
}
#
[
inline
]
pub
fn
as_ptr
(
&
self
)
-
>
*
mut
T
{
if
T
:
:
IS_ZERO_SIZED
{
invalid_mut
(
mem
:
:
align_of
:
:
<
T
>
(
)
)
}
else
{
unsafe
{
self
.
ptr
.
as_ptr
(
)
.
sub
(
1
)
}
}
}
#
[
inline
]
fn
as_non_null
(
&
self
)
-
>
NonNull
<
T
>
{
unsafe
{
NonNull
:
:
new_unchecked
(
self
.
as_ptr
(
)
)
}
}
#
[
inline
]
unsafe
fn
next_n
(
&
self
offset
:
usize
)
-
>
Self
{
let
ptr
=
if
T
:
:
IS_ZERO_SIZED
{
invalid_mut
(
self
.
ptr
.
as_ptr
(
)
as
usize
+
offset
)
}
else
{
self
.
ptr
.
as_ptr
(
)
.
sub
(
offset
)
}
;
Self
{
ptr
:
NonNull
:
:
new_unchecked
(
ptr
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
(
crate
)
unsafe
fn
drop
(
&
self
)
{
self
.
as_ptr
(
)
.
drop_in_place
(
)
;
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
read
(
&
self
)
-
>
T
{
self
.
as_ptr
(
)
.
read
(
)
}
#
[
inline
]
pub
(
crate
)
unsafe
fn
write
(
&
self
val
:
T
)
{
self
.
as_ptr
(
)
.
write
(
val
)
;
}
#
[
inline
]
pub
unsafe
fn
as_ref
<
'
a
>
(
&
self
)
-
>
&
'
a
T
{
&
*
self
.
as_ptr
(
)
}
#
[
inline
]
pub
unsafe
fn
as_mut
<
'
a
>
(
&
self
)
-
>
&
'
a
mut
T
{
&
mut
*
self
.
as_ptr
(
)
}
}
pub
struct
RawTable
<
T
A
:
Allocator
=
Global
>
{
table
:
RawTableInner
alloc
:
A
marker
:
PhantomData
<
T
>
}
struct
RawTableInner
{
bucket_mask
:
usize
ctrl
:
NonNull
<
u8
>
growth_left
:
usize
items
:
usize
}
impl
<
T
>
RawTable
<
T
Global
>
{
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
rustc
-
dep
-
of
-
std
"
rustc_const_stable_indirect
)
]
pub
const
fn
new
(
)
-
>
Self
{
Self
{
table
:
RawTableInner
:
:
NEW
alloc
:
Global
marker
:
PhantomData
}
}
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
:
:
with_capacity_in
(
capacity
Global
)
}
}
impl
<
T
A
:
Allocator
>
RawTable
<
T
A
>
{
const
TABLE_LAYOUT
:
TableLayout
=
TableLayout
:
:
new
:
:
<
T
>
(
)
;
#
[
inline
]
#
[
cfg_attr
(
feature
=
"
rustc
-
dep
-
of
-
std
"
rustc_const_stable_indirect
)
]
pub
const
fn
new_in
(
alloc
:
A
)
-
>
Self
{
Self
{
table
:
RawTableInner
:
:
NEW
alloc
marker
:
PhantomData
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
new_uninitialized
(
alloc
:
A
buckets
:
usize
fallibility
:
Fallibility
)
-
>
Result
<
Self
TryReserveError
>
{
debug_assert
!
(
buckets
.
is_power_of_two
(
)
)
;
Ok
(
Self
{
table
:
RawTableInner
:
:
new_uninitialized
(
&
alloc
Self
:
:
TABLE_LAYOUT
buckets
fallibility
)
?
alloc
marker
:
PhantomData
}
)
}
pub
fn
with_capacity_in
(
capacity
:
usize
alloc
:
A
)
-
>
Self
{
Self
{
table
:
RawTableInner
:
:
with_capacity
(
&
alloc
Self
:
:
TABLE_LAYOUT
capacity
)
alloc
marker
:
PhantomData
}
}
#
[
inline
]
pub
fn
allocator
(
&
self
)
-
>
&
A
{
&
self
.
alloc
}
#
[
inline
]
pub
fn
data_end
(
&
self
)
-
>
NonNull
<
T
>
{
self
.
table
.
ctrl
.
cast
(
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
nightly
"
)
]
pub
unsafe
fn
data_start
(
&
self
)
-
>
NonNull
<
T
>
{
NonNull
:
:
new_unchecked
(
self
.
data_end
(
)
.
as_ptr
(
)
.
wrapping_sub
(
self
.
buckets
(
)
)
)
}
#
[
inline
]
pub
fn
allocation_size
(
&
self
)
-
>
usize
{
unsafe
{
self
.
table
.
allocation_size_or_zero
(
Self
:
:
TABLE_LAYOUT
)
}
}
#
[
inline
]
pub
unsafe
fn
bucket_index
(
&
self
bucket
:
&
Bucket
<
T
>
)
-
>
usize
{
bucket
.
to_base_index
(
self
.
data_end
(
)
)
}
#
[
inline
]
pub
unsafe
fn
bucket
(
&
self
index
:
usize
)
-
>
Bucket
<
T
>
{
debug_assert_ne
!
(
self
.
table
.
bucket_mask
0
)
;
debug_assert
!
(
index
<
self
.
buckets
(
)
)
;
Bucket
:
:
from_base_index
(
self
.
data_end
(
)
index
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
erase_no_drop
(
&
mut
self
item
:
&
Bucket
<
T
>
)
{
let
index
=
self
.
bucket_index
(
item
)
;
self
.
table
.
erase
(
index
)
;
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
#
[
allow
(
clippy
:
:
needless_pass_by_value
)
]
pub
unsafe
fn
erase
(
&
mut
self
item
:
Bucket
<
T
>
)
{
self
.
erase_no_drop
(
&
item
)
;
item
.
drop
(
)
;
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
#
[
allow
(
clippy
:
:
needless_pass_by_value
)
]
pub
unsafe
fn
remove
(
&
mut
self
item
:
Bucket
<
T
>
)
-
>
(
T
InsertSlot
)
{
self
.
erase_no_drop
(
&
item
)
;
(
item
.
read
(
)
InsertSlot
{
index
:
self
.
bucket_index
(
&
item
)
}
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
remove_entry
(
&
mut
self
hash
:
u64
eq
:
impl
FnMut
(
&
T
)
-
>
bool
)
-
>
Option
<
T
>
{
match
self
.
find
(
hash
eq
)
{
Some
(
bucket
)
=
>
Some
(
unsafe
{
self
.
remove
(
bucket
)
.
0
}
)
None
=
>
None
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
clear_no_drop
(
&
mut
self
)
{
self
.
table
.
clear_no_drop
(
)
;
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
clear
(
&
mut
self
)
{
if
self
.
is_empty
(
)
{
return
;
}
let
mut
self_
=
guard
(
self
|
self_
|
self_
.
clear_no_drop
(
)
)
;
unsafe
{
self_
.
table
.
drop_elements
:
:
<
T
>
(
)
;
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
shrink_to
(
&
mut
self
min_size
:
usize
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
{
let
min_size
=
usize
:
:
max
(
self
.
table
.
items
min_size
)
;
if
min_size
=
=
0
{
let
mut
old_inner
=
mem
:
:
replace
(
&
mut
self
.
table
RawTableInner
:
:
NEW
)
;
unsafe
{
old_inner
.
drop_inner_table
:
:
<
T
_
>
(
&
self
.
alloc
Self
:
:
TABLE_LAYOUT
)
;
}
return
;
}
let
min_buckets
=
match
capacity_to_buckets
(
min_size
Self
:
:
TABLE_LAYOUT
)
{
Some
(
buckets
)
=
>
buckets
None
=
>
return
}
;
if
min_buckets
<
self
.
buckets
(
)
{
if
self
.
table
.
items
=
=
0
{
let
new_inner
=
RawTableInner
:
:
with_capacity
(
&
self
.
alloc
Self
:
:
TABLE_LAYOUT
min_size
)
;
let
mut
old_inner
=
mem
:
:
replace
(
&
mut
self
.
table
new_inner
)
;
unsafe
{
old_inner
.
drop_inner_table
:
:
<
T
_
>
(
&
self
.
alloc
Self
:
:
TABLE_LAYOUT
)
;
}
}
else
{
unsafe
{
if
self
.
resize
(
min_size
hasher
Fallibility
:
:
Infallible
)
.
is_err
(
)
{
hint
:
:
unreachable_unchecked
(
)
}
}
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
reserve
(
&
mut
self
additional
:
usize
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
{
if
unlikely
(
additional
>
self
.
table
.
growth_left
)
{
unsafe
{
if
self
.
reserve_rehash
(
additional
hasher
Fallibility
:
:
Infallible
)
.
is_err
(
)
{
hint
:
:
unreachable_unchecked
(
)
}
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
try_reserve
(
&
mut
self
additional
:
usize
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
-
>
Result
<
(
)
TryReserveError
>
{
if
additional
>
self
.
table
.
growth_left
{
unsafe
{
self
.
reserve_rehash
(
additional
hasher
Fallibility
:
:
Fallible
)
}
}
else
{
Ok
(
(
)
)
}
}
#
[
cold
]
#
[
inline
(
never
)
]
unsafe
fn
reserve_rehash
(
&
mut
self
additional
:
usize
hasher
:
impl
Fn
(
&
T
)
-
>
u64
fallibility
:
Fallibility
)
-
>
Result
<
(
)
TryReserveError
>
{
unsafe
{
self
.
table
.
reserve_rehash_inner
(
&
self
.
alloc
additional
&
|
table
index
|
hasher
(
table
.
bucket
:
:
<
T
>
(
index
)
.
as_ref
(
)
)
fallibility
Self
:
:
TABLE_LAYOUT
if
T
:
:
NEEDS_DROP
{
Some
(
|
ptr
|
ptr
:
:
drop_in_place
(
ptr
as
*
mut
T
)
)
}
else
{
None
}
)
}
}
unsafe
fn
resize
(
&
mut
self
capacity
:
usize
hasher
:
impl
Fn
(
&
T
)
-
>
u64
fallibility
:
Fallibility
)
-
>
Result
<
(
)
TryReserveError
>
{
self
.
table
.
resize_inner
(
&
self
.
alloc
capacity
&
|
table
index
|
hasher
(
table
.
bucket
:
:
<
T
>
(
index
)
.
as_ref
(
)
)
fallibility
Self
:
:
TABLE_LAYOUT
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
insert
(
&
mut
self
hash
:
u64
value
:
T
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
-
>
Bucket
<
T
>
{
unsafe
{
let
mut
slot
=
self
.
table
.
find_insert_slot
(
hash
)
;
let
old_ctrl
=
*
self
.
table
.
ctrl
(
slot
.
index
)
;
if
unlikely
(
self
.
table
.
growth_left
=
=
0
&
&
old_ctrl
.
special_is_empty
(
)
)
{
self
.
reserve
(
1
hasher
)
;
slot
=
self
.
table
.
find_insert_slot
(
hash
)
;
}
self
.
insert_in_slot
(
hash
slot
value
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
insert_entry
(
&
mut
self
hash
:
u64
value
:
T
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
-
>
&
mut
T
{
unsafe
{
self
.
insert
(
hash
value
hasher
)
.
as_mut
(
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
#
[
cfg
(
feature
=
"
rustc
-
internal
-
api
"
)
]
pub
unsafe
fn
insert_no_grow
(
&
mut
self
hash
:
u64
value
:
T
)
-
>
Bucket
<
T
>
{
let
(
index
old_ctrl
)
=
self
.
table
.
prepare_insert_slot
(
hash
)
;
let
bucket
=
self
.
table
.
bucket
(
index
)
;
self
.
table
.
growth_left
-
=
old_ctrl
.
special_is_empty
(
)
as
usize
;
bucket
.
write
(
value
)
;
self
.
table
.
items
+
=
1
;
bucket
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
unsafe
fn
replace_bucket_with
<
F
>
(
&
mut
self
bucket
:
Bucket
<
T
>
f
:
F
)
-
>
bool
where
F
:
FnOnce
(
T
)
-
>
Option
<
T
>
{
let
index
=
self
.
bucket_index
(
&
bucket
)
;
let
old_ctrl
=
*
self
.
table
.
ctrl
(
index
)
;
debug_assert
!
(
self
.
is_bucket_full
(
index
)
)
;
let
old_growth_left
=
self
.
table
.
growth_left
;
let
item
=
self
.
remove
(
bucket
)
.
0
;
if
let
Some
(
new_item
)
=
f
(
item
)
{
self
.
table
.
growth_left
=
old_growth_left
;
self
.
table
.
set_ctrl
(
index
old_ctrl
)
;
self
.
table
.
items
+
=
1
;
self
.
bucket
(
index
)
.
write
(
new_item
)
;
true
}
else
{
false
}
}
#
[
inline
]
pub
fn
find_or_find_insert_slot
(
&
mut
self
hash
:
u64
mut
eq
:
impl
FnMut
(
&
T
)
-
>
bool
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
-
>
Result
<
Bucket
<
T
>
InsertSlot
>
{
self
.
reserve
(
1
hasher
)
;
unsafe
{
match
self
.
table
.
find_or_find_insert_slot_inner
(
hash
&
mut
|
index
|
eq
(
self
.
bucket
(
index
)
.
as_ref
(
)
)
)
{
Ok
(
index
)
=
>
Ok
(
self
.
bucket
(
index
)
)
Err
(
slot
)
=
>
Err
(
slot
)
}
}
}
#
[
inline
]
pub
unsafe
fn
insert_in_slot
(
&
mut
self
hash
:
u64
slot
:
InsertSlot
value
:
T
)
-
>
Bucket
<
T
>
{
let
old_ctrl
=
*
self
.
table
.
ctrl
(
slot
.
index
)
;
self
.
table
.
record_item_insert_at
(
slot
.
index
old_ctrl
hash
)
;
let
bucket
=
self
.
bucket
(
slot
.
index
)
;
bucket
.
write
(
value
)
;
bucket
}
#
[
inline
]
pub
fn
find
(
&
self
hash
:
u64
mut
eq
:
impl
FnMut
(
&
T
)
-
>
bool
)
-
>
Option
<
Bucket
<
T
>
>
{
unsafe
{
let
result
=
self
.
table
.
find_inner
(
hash
&
mut
|
index
|
eq
(
self
.
bucket
(
index
)
.
as_ref
(
)
)
)
;
match
result
{
Some
(
index
)
=
>
Some
(
self
.
bucket
(
index
)
)
None
=
>
None
}
}
}
#
[
inline
]
pub
fn
get
(
&
self
hash
:
u64
eq
:
impl
FnMut
(
&
T
)
-
>
bool
)
-
>
Option
<
&
T
>
{
match
self
.
find
(
hash
eq
)
{
Some
(
bucket
)
=
>
Some
(
unsafe
{
bucket
.
as_ref
(
)
}
)
None
=
>
None
}
}
#
[
inline
]
pub
fn
get_mut
(
&
mut
self
hash
:
u64
eq
:
impl
FnMut
(
&
T
)
-
>
bool
)
-
>
Option
<
&
mut
T
>
{
match
self
.
find
(
hash
eq
)
{
Some
(
bucket
)
=
>
Some
(
unsafe
{
bucket
.
as_mut
(
)
}
)
None
=
>
None
}
}
pub
fn
get_many_mut
<
const
N
:
usize
>
(
&
mut
self
hashes
:
[
u64
;
N
]
eq
:
impl
FnMut
(
usize
&
T
)
-
>
bool
)
-
>
[
Option
<
&
'
_
mut
T
>
;
N
]
{
unsafe
{
let
ptrs
=
self
.
get_many_mut_pointers
(
hashes
eq
)
;
for
(
i
cur
)
in
ptrs
.
iter
(
)
.
enumerate
(
)
{
if
cur
.
is_some
(
)
&
&
ptrs
[
.
.
i
]
.
contains
(
cur
)
{
panic
!
(
"
duplicate
keys
found
"
)
;
}
}
ptrs
.
map
(
|
ptr
|
ptr
.
map
(
|
mut
ptr
|
ptr
.
as_mut
(
)
)
)
}
}
pub
unsafe
fn
get_many_unchecked_mut
<
const
N
:
usize
>
(
&
mut
self
hashes
:
[
u64
;
N
]
eq
:
impl
FnMut
(
usize
&
T
)
-
>
bool
)
-
>
[
Option
<
&
'
_
mut
T
>
;
N
]
{
let
ptrs
=
self
.
get_many_mut_pointers
(
hashes
eq
)
;
ptrs
.
map
(
|
ptr
|
ptr
.
map
(
|
mut
ptr
|
ptr
.
as_mut
(
)
)
)
}
unsafe
fn
get_many_mut_pointers
<
const
N
:
usize
>
(
&
mut
self
hashes
:
[
u64
;
N
]
mut
eq
:
impl
FnMut
(
usize
&
T
)
-
>
bool
)
-
>
[
Option
<
NonNull
<
T
>
>
;
N
]
{
array
:
:
from_fn
(
|
i
|
{
self
.
find
(
hashes
[
i
]
|
k
|
eq
(
i
k
)
)
.
map
(
|
cur
|
cur
.
as_non_null
(
)
)
}
)
}
#
[
inline
]
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
table
.
items
+
self
.
table
.
growth_left
}
#
[
inline
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
table
.
items
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
=
=
0
}
#
[
inline
]
pub
fn
buckets
(
&
self
)
-
>
usize
{
self
.
table
.
bucket_mask
+
1
}
#
[
inline
]
pub
unsafe
fn
is_bucket_full
(
&
self
index
:
usize
)
-
>
bool
{
self
.
table
.
is_bucket_full
(
index
)
}
#
[
inline
]
pub
unsafe
fn
iter
(
&
self
)
-
>
RawIter
<
T
>
{
self
.
table
.
iter
(
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
unsafe
fn
iter_hash
(
&
self
hash
:
u64
)
-
>
RawIterHash
<
T
>
{
RawIterHash
:
:
new
(
self
hash
)
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
drain
(
&
mut
self
)
-
>
RawDrain
<
'
_
T
A
>
{
unsafe
{
let
iter
=
self
.
iter
(
)
;
self
.
drain_iter_from
(
iter
)
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
unsafe
fn
drain_iter_from
(
&
mut
self
iter
:
RawIter
<
T
>
)
-
>
RawDrain
<
'
_
T
A
>
{
debug_assert_eq
!
(
iter
.
len
(
)
self
.
len
(
)
)
;
RawDrain
{
iter
table
:
mem
:
:
replace
(
&
mut
self
.
table
RawTableInner
:
:
NEW
)
orig_table
:
NonNull
:
:
from
(
&
mut
self
.
table
)
marker
:
PhantomData
}
}
pub
unsafe
fn
into_iter_from
(
self
iter
:
RawIter
<
T
>
)
-
>
RawIntoIter
<
T
A
>
{
debug_assert_eq
!
(
iter
.
len
(
)
self
.
len
(
)
)
;
let
allocation
=
self
.
into_allocation
(
)
;
RawIntoIter
{
iter
allocation
marker
:
PhantomData
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
(
crate
)
fn
into_allocation
(
self
)
-
>
Option
<
(
NonNull
<
u8
>
Layout
A
)
>
{
let
alloc
=
if
self
.
table
.
is_empty_singleton
(
)
{
None
}
else
{
let
(
layout
ctrl_offset
)
=
match
Self
:
:
TABLE_LAYOUT
.
calculate_layout_for
(
self
.
table
.
buckets
(
)
)
{
Some
(
lco
)
=
>
lco
None
=
>
unsafe
{
hint
:
:
unreachable_unchecked
(
)
}
}
;
Some
(
(
unsafe
{
NonNull
:
:
new_unchecked
(
self
.
table
.
ctrl
.
as_ptr
(
)
.
sub
(
ctrl_offset
)
.
cast
(
)
)
}
layout
unsafe
{
ptr
:
:
read
(
&
self
.
alloc
)
}
)
)
}
;
mem
:
:
forget
(
self
)
;
alloc
}
}
unsafe
impl
<
T
A
:
Allocator
>
Send
for
RawTable
<
T
A
>
where
T
:
Send
A
:
Send
{
}
unsafe
impl
<
T
A
:
Allocator
>
Sync
for
RawTable
<
T
A
>
where
T
:
Sync
A
:
Sync
{
}
impl
RawTableInner
{
const
NEW
:
Self
=
RawTableInner
:
:
new
(
)
;
#
[
inline
]
const
fn
new
(
)
-
>
Self
{
Self
{
ctrl
:
unsafe
{
NonNull
:
:
new_unchecked
(
Group
:
:
static_empty
(
)
.
as_ptr
(
)
.
cast_mut
(
)
.
cast
(
)
)
}
bucket_mask
:
0
items
:
0
growth_left
:
0
}
}
}
impl
RawTableInner
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
new_uninitialized
<
A
>
(
alloc
:
&
A
table_layout
:
TableLayout
buckets
:
usize
fallibility
:
Fallibility
)
-
>
Result
<
Self
TryReserveError
>
where
A
:
Allocator
{
debug_assert
!
(
buckets
.
is_power_of_two
(
)
)
;
let
(
layout
ctrl_offset
)
=
match
table_layout
.
calculate_layout_for
(
buckets
)
{
Some
(
lco
)
=
>
lco
None
=
>
return
Err
(
fallibility
.
capacity_overflow
(
)
)
}
;
let
ptr
:
NonNull
<
u8
>
=
match
do_alloc
(
alloc
layout
)
{
Ok
(
block
)
=
>
block
.
cast
(
)
Err
(
_
)
=
>
return
Err
(
fallibility
.
alloc_err
(
layout
)
)
}
;
let
ctrl
=
NonNull
:
:
new_unchecked
(
ptr
.
as_ptr
(
)
.
add
(
ctrl_offset
)
)
;
Ok
(
Self
{
ctrl
bucket_mask
:
buckets
-
1
items
:
0
growth_left
:
bucket_mask_to_capacity
(
buckets
-
1
)
}
)
}
#
[
inline
]
fn
fallible_with_capacity
<
A
>
(
alloc
:
&
A
table_layout
:
TableLayout
capacity
:
usize
fallibility
:
Fallibility
)
-
>
Result
<
Self
TryReserveError
>
where
A
:
Allocator
{
if
capacity
=
=
0
{
Ok
(
Self
:
:
NEW
)
}
else
{
unsafe
{
let
buckets
=
capacity_to_buckets
(
capacity
table_layout
)
.
ok_or_else
(
|
|
fallibility
.
capacity_overflow
(
)
)
?
;
let
mut
result
=
Self
:
:
new_uninitialized
(
alloc
table_layout
buckets
fallibility
)
?
;
result
.
ctrl_slice
(
)
.
fill_empty
(
)
;
Ok
(
result
)
}
}
}
fn
with_capacity
<
A
>
(
alloc
:
&
A
table_layout
:
TableLayout
capacity
:
usize
)
-
>
Self
where
A
:
Allocator
{
match
Self
:
:
fallible_with_capacity
(
alloc
table_layout
capacity
Fallibility
:
:
Infallible
)
{
Ok
(
table_inner
)
=
>
table_inner
Err
(
_
)
=
>
unsafe
{
hint
:
:
unreachable_unchecked
(
)
}
}
}
#
[
inline
]
unsafe
fn
fix_insert_slot
(
&
self
mut
index
:
usize
)
-
>
InsertSlot
{
if
unlikely
(
self
.
is_bucket_full
(
index
)
)
{
debug_assert
!
(
self
.
bucket_mask
<
Group
:
:
WIDTH
)
;
index
=
Group
:
:
load_aligned
(
self
.
ctrl
(
0
)
)
.
match_empty_or_deleted
(
)
.
lowest_set_bit
(
)
.
unwrap_unchecked
(
)
;
}
InsertSlot
{
index
}
}
#
[
inline
]
fn
find_insert_slot_in_group
(
&
self
group
:
&
Group
probe_seq
:
&
ProbeSeq
)
-
>
Option
<
usize
>
{
let
bit
=
group
.
match_empty_or_deleted
(
)
.
lowest_set_bit
(
)
;
if
likely
(
bit
.
is_some
(
)
)
{
Some
(
(
probe_seq
.
pos
+
bit
.
unwrap
(
)
)
&
self
.
bucket_mask
)
}
else
{
None
}
}
#
[
inline
]
unsafe
fn
find_or_find_insert_slot_inner
(
&
self
hash
:
u64
eq
:
&
mut
dyn
FnMut
(
usize
)
-
>
bool
)
-
>
Result
<
usize
InsertSlot
>
{
let
mut
insert_slot
=
None
;
let
tag_hash
=
Tag
:
:
full
(
hash
)
;
let
mut
probe_seq
=
self
.
probe_seq
(
hash
)
;
loop
{
let
group
=
unsafe
{
Group
:
:
load
(
self
.
ctrl
(
probe_seq
.
pos
)
)
}
;
for
bit
in
group
.
match_tag
(
tag_hash
)
{
let
index
=
(
probe_seq
.
pos
+
bit
)
&
self
.
bucket_mask
;
if
likely
(
eq
(
index
)
)
{
return
Ok
(
index
)
;
}
}
if
likely
(
insert_slot
.
is_none
(
)
)
{
insert_slot
=
self
.
find_insert_slot_in_group
(
&
group
&
probe_seq
)
;
}
if
let
Some
(
insert_slot
)
=
insert_slot
{
if
likely
(
group
.
match_empty
(
)
.
any_bit_set
(
)
)
{
unsafe
{
return
Err
(
self
.
fix_insert_slot
(
insert_slot
)
)
;
}
}
}
probe_seq
.
move_next
(
self
.
bucket_mask
)
;
}
}
#
[
inline
]
unsafe
fn
prepare_insert_slot
(
&
mut
self
hash
:
u64
)
-
>
(
usize
Tag
)
{
let
index
:
usize
=
self
.
find_insert_slot
(
hash
)
.
index
;
let
old_ctrl
=
*
self
.
ctrl
(
index
)
;
self
.
set_ctrl_hash
(
index
hash
)
;
(
index
old_ctrl
)
}
#
[
inline
]
unsafe
fn
find_insert_slot
(
&
self
hash
:
u64
)
-
>
InsertSlot
{
let
mut
probe_seq
=
self
.
probe_seq
(
hash
)
;
loop
{
let
group
=
unsafe
{
Group
:
:
load
(
self
.
ctrl
(
probe_seq
.
pos
)
)
}
;
let
index
=
self
.
find_insert_slot_in_group
(
&
group
&
probe_seq
)
;
if
likely
(
index
.
is_some
(
)
)
{
unsafe
{
return
self
.
fix_insert_slot
(
index
.
unwrap_unchecked
(
)
)
;
}
}
probe_seq
.
move_next
(
self
.
bucket_mask
)
;
}
}
#
[
inline
(
always
)
]
unsafe
fn
find_inner
(
&
self
hash
:
u64
eq
:
&
mut
dyn
FnMut
(
usize
)
-
>
bool
)
-
>
Option
<
usize
>
{
let
tag_hash
=
Tag
:
:
full
(
hash
)
;
let
mut
probe_seq
=
self
.
probe_seq
(
hash
)
;
loop
{
let
group
=
unsafe
{
Group
:
:
load
(
self
.
ctrl
(
probe_seq
.
pos
)
)
}
;
for
bit
in
group
.
match_tag
(
tag_hash
)
{
let
index
=
(
probe_seq
.
pos
+
bit
)
&
self
.
bucket_mask
;
if
likely
(
eq
(
index
)
)
{
return
Some
(
index
)
;
}
}
if
likely
(
group
.
match_empty
(
)
.
any_bit_set
(
)
)
{
return
None
;
}
probe_seq
.
move_next
(
self
.
bucket_mask
)
;
}
}
#
[
allow
(
clippy
:
:
mut_mut
)
]
#
[
inline
]
unsafe
fn
prepare_rehash_in_place
(
&
mut
self
)
{
for
i
in
(
0
.
.
self
.
buckets
(
)
)
.
step_by
(
Group
:
:
WIDTH
)
{
let
group
=
Group
:
:
load_aligned
(
self
.
ctrl
(
i
)
)
;
let
group
=
group
.
convert_special_to_empty_and_full_to_deleted
(
)
;
group
.
store_aligned
(
self
.
ctrl
(
i
)
)
;
}
if
unlikely
(
self
.
buckets
(
)
<
Group
:
:
WIDTH
)
{
self
.
ctrl
(
0
)
.
copy_to
(
self
.
ctrl
(
Group
:
:
WIDTH
)
self
.
buckets
(
)
)
;
}
else
{
self
.
ctrl
(
0
)
.
copy_to
(
self
.
ctrl
(
self
.
buckets
(
)
)
Group
:
:
WIDTH
)
;
}
}
#
[
inline
]
unsafe
fn
iter
<
T
>
(
&
self
)
-
>
RawIter
<
T
>
{
let
data
=
Bucket
:
:
from_base_index
(
self
.
data_end
(
)
0
)
;
RawIter
{
iter
:
RawIterRange
:
:
new
(
self
.
ctrl
.
as_ptr
(
)
data
self
.
buckets
(
)
)
items
:
self
.
items
}
}
unsafe
fn
drop_elements
<
T
>
(
&
mut
self
)
{
if
T
:
:
NEEDS_DROP
&
&
self
.
items
!
=
0
{
for
item
in
self
.
iter
:
:
<
T
>
(
)
{
item
.
drop
(
)
;
}
}
}
unsafe
fn
drop_inner_table
<
T
A
:
Allocator
>
(
&
mut
self
alloc
:
&
A
table_layout
:
TableLayout
)
{
if
!
self
.
is_empty_singleton
(
)
{
unsafe
{
self
.
drop_elements
:
:
<
T
>
(
)
;
self
.
free_buckets
(
alloc
table_layout
)
;
}
}
}
#
[
inline
]
unsafe
fn
bucket
<
T
>
(
&
self
index
:
usize
)
-
>
Bucket
<
T
>
{
debug_assert_ne
!
(
self
.
bucket_mask
0
)
;
debug_assert
!
(
index
<
self
.
buckets
(
)
)
;
Bucket
:
:
from_base_index
(
self
.
data_end
(
)
index
)
}
#
[
inline
]
unsafe
fn
bucket_ptr
(
&
self
index
:
usize
size_of
:
usize
)
-
>
*
mut
u8
{
debug_assert_ne
!
(
self
.
bucket_mask
0
)
;
debug_assert
!
(
index
<
self
.
buckets
(
)
)
;
let
base
:
*
mut
u8
=
self
.
data_end
(
)
.
as_ptr
(
)
;
base
.
sub
(
(
index
+
1
)
*
size_of
)
}
#
[
inline
]
fn
data_end
<
T
>
(
&
self
)
-
>
NonNull
<
T
>
{
self
.
ctrl
.
cast
(
)
}
#
[
inline
]
fn
probe_seq
(
&
self
hash
:
u64
)
-
>
ProbeSeq
{
ProbeSeq
{
pos
:
h1
(
hash
)
&
self
.
bucket_mask
stride
:
0
}
}
#
[
inline
]
unsafe
fn
record_item_insert_at
(
&
mut
self
index
:
usize
old_ctrl
:
Tag
hash
:
u64
)
{
self
.
growth_left
-
=
usize
:
:
from
(
old_ctrl
.
special_is_empty
(
)
)
;
self
.
set_ctrl_hash
(
index
hash
)
;
self
.
items
+
=
1
;
}
#
[
inline
]
fn
is_in_same_group
(
&
self
i
:
usize
new_i
:
usize
hash
:
u64
)
-
>
bool
{
let
probe_seq_pos
=
self
.
probe_seq
(
hash
)
.
pos
;
let
probe_index
=
|
pos
:
usize
|
(
pos
.
wrapping_sub
(
probe_seq_pos
)
&
self
.
bucket_mask
)
/
Group
:
:
WIDTH
;
probe_index
(
i
)
=
=
probe_index
(
new_i
)
}
#
[
inline
]
unsafe
fn
set_ctrl_hash
(
&
mut
self
index
:
usize
hash
:
u64
)
{
self
.
set_ctrl
(
index
Tag
:
:
full
(
hash
)
)
;
}
#
[
inline
]
unsafe
fn
replace_ctrl_hash
(
&
mut
self
index
:
usize
hash
:
u64
)
-
>
Tag
{
let
prev_ctrl
=
*
self
.
ctrl
(
index
)
;
self
.
set_ctrl_hash
(
index
hash
)
;
prev_ctrl
}
#
[
inline
]
unsafe
fn
set_ctrl
(
&
mut
self
index
:
usize
ctrl
:
Tag
)
{
let
index2
=
(
(
index
.
wrapping_sub
(
Group
:
:
WIDTH
)
)
&
self
.
bucket_mask
)
+
Group
:
:
WIDTH
;
*
self
.
ctrl
(
index
)
=
ctrl
;
*
self
.
ctrl
(
index2
)
=
ctrl
;
}
#
[
inline
]
unsafe
fn
ctrl
(
&
self
index
:
usize
)
-
>
*
mut
Tag
{
debug_assert
!
(
index
<
self
.
num_ctrl_bytes
(
)
)
;
self
.
ctrl
.
as_ptr
(
)
.
add
(
index
)
.
cast
(
)
}
fn
ctrl_slice
(
&
mut
self
)
-
>
&
mut
[
Tag
]
{
unsafe
{
slice
:
:
from_raw_parts_mut
(
self
.
ctrl
.
as_ptr
(
)
.
cast
(
)
self
.
num_ctrl_bytes
(
)
)
}
}
#
[
inline
]
fn
buckets
(
&
self
)
-
>
usize
{
self
.
bucket_mask
+
1
}
#
[
inline
]
unsafe
fn
is_bucket_full
(
&
self
index
:
usize
)
-
>
bool
{
debug_assert
!
(
index
<
self
.
buckets
(
)
)
;
(
*
self
.
ctrl
(
index
)
)
.
is_full
(
)
}
#
[
inline
]
fn
num_ctrl_bytes
(
&
self
)
-
>
usize
{
self
.
bucket_mask
+
1
+
Group
:
:
WIDTH
}
#
[
inline
]
fn
is_empty_singleton
(
&
self
)
-
>
bool
{
self
.
bucket_mask
=
=
0
}
#
[
allow
(
clippy
:
:
mut_mut
)
]
#
[
inline
]
fn
prepare_resize
<
'
a
A
>
(
&
self
alloc
:
&
'
a
A
table_layout
:
TableLayout
capacity
:
usize
fallibility
:
Fallibility
)
-
>
Result
<
crate
:
:
scopeguard
:
:
ScopeGuard
<
Self
impl
FnMut
(
&
mut
Self
)
+
'
a
>
TryReserveError
>
where
A
:
Allocator
{
debug_assert
!
(
self
.
items
<
=
capacity
)
;
let
new_table
=
RawTableInner
:
:
fallible_with_capacity
(
alloc
table_layout
capacity
fallibility
)
?
;
Ok
(
guard
(
new_table
move
|
self_
|
{
if
!
self_
.
is_empty_singleton
(
)
{
unsafe
{
self_
.
free_buckets
(
alloc
table_layout
)
}
;
}
}
)
)
}
#
[
allow
(
clippy
:
:
inline_always
)
]
#
[
inline
(
always
)
]
unsafe
fn
reserve_rehash_inner
<
A
>
(
&
mut
self
alloc
:
&
A
additional
:
usize
hasher
:
&
dyn
Fn
(
&
mut
Self
usize
)
-
>
u64
fallibility
:
Fallibility
layout
:
TableLayout
drop
:
Option
<
unsafe
fn
(
*
mut
u8
)
>
)
-
>
Result
<
(
)
TryReserveError
>
where
A
:
Allocator
{
let
new_items
=
match
self
.
items
.
checked_add
(
additional
)
{
Some
(
new_items
)
=
>
new_items
None
=
>
return
Err
(
fallibility
.
capacity_overflow
(
)
)
}
;
let
full_capacity
=
bucket_mask_to_capacity
(
self
.
bucket_mask
)
;
if
new_items
<
=
full_capacity
/
2
{
self
.
rehash_in_place
(
hasher
layout
.
size
drop
)
;
Ok
(
(
)
)
}
else
{
self
.
resize_inner
(
alloc
usize
:
:
max
(
new_items
full_capacity
+
1
)
hasher
fallibility
layout
)
}
}
#
[
inline
(
always
)
]
unsafe
fn
full_buckets_indices
(
&
self
)
-
>
FullBucketsIndices
{
let
ctrl
=
NonNull
:
:
new_unchecked
(
self
.
ctrl
(
0
)
.
cast
:
:
<
u8
>
(
)
)
;
FullBucketsIndices
{
current_group
:
Group
:
:
load_aligned
(
ctrl
.
as_ptr
(
)
.
cast
(
)
)
.
match_full
(
)
.
into_iter
(
)
group_first_index
:
0
ctrl
items
:
self
.
items
}
}
#
[
allow
(
clippy
:
:
inline_always
)
]
#
[
inline
(
always
)
]
unsafe
fn
resize_inner
<
A
>
(
&
mut
self
alloc
:
&
A
capacity
:
usize
hasher
:
&
dyn
Fn
(
&
mut
Self
usize
)
-
>
u64
fallibility
:
Fallibility
layout
:
TableLayout
)
-
>
Result
<
(
)
TryReserveError
>
where
A
:
Allocator
{
let
mut
new_table
=
self
.
prepare_resize
(
alloc
layout
capacity
fallibility
)
?
;
for
full_byte_index
in
self
.
full_buckets_indices
(
)
{
let
hash
=
hasher
(
self
full_byte_index
)
;
let
(
new_index
_
)
=
new_table
.
prepare_insert_slot
(
hash
)
;
ptr
:
:
copy_nonoverlapping
(
self
.
bucket_ptr
(
full_byte_index
layout
.
size
)
new_table
.
bucket_ptr
(
new_index
layout
.
size
)
layout
.
size
)
;
}
new_table
.
growth_left
-
=
self
.
items
;
new_table
.
items
=
self
.
items
;
mem
:
:
swap
(
self
&
mut
new_table
)
;
Ok
(
(
)
)
}
#
[
allow
(
clippy
:
:
inline_always
)
]
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
(
always
)
)
]
#
[
cfg_attr
(
not
(
feature
=
"
inline
-
more
"
)
inline
)
]
unsafe
fn
rehash_in_place
(
&
mut
self
hasher
:
&
dyn
Fn
(
&
mut
Self
usize
)
-
>
u64
size_of
:
usize
drop
:
Option
<
unsafe
fn
(
*
mut
u8
)
>
)
{
self
.
prepare_rehash_in_place
(
)
;
let
mut
guard
=
guard
(
self
move
|
self_
|
{
if
let
Some
(
drop
)
=
drop
{
for
i
in
0
.
.
self_
.
buckets
(
)
{
if
*
self_
.
ctrl
(
i
)
=
=
Tag
:
:
DELETED
{
self_
.
set_ctrl
(
i
Tag
:
:
EMPTY
)
;
drop
(
self_
.
bucket_ptr
(
i
size_of
)
)
;
self_
.
items
-
=
1
;
}
}
}
self_
.
growth_left
=
bucket_mask_to_capacity
(
self_
.
bucket_mask
)
-
self_
.
items
;
}
)
;
'
outer
:
for
i
in
0
.
.
guard
.
buckets
(
)
{
if
*
guard
.
ctrl
(
i
)
!
=
Tag
:
:
DELETED
{
continue
;
}
let
i_p
=
guard
.
bucket_ptr
(
i
size_of
)
;
'
inner
:
loop
{
let
hash
=
hasher
(
*
guard
i
)
;
let
new_i
=
guard
.
find_insert_slot
(
hash
)
.
index
;
if
likely
(
guard
.
is_in_same_group
(
i
new_i
hash
)
)
{
guard
.
set_ctrl_hash
(
i
hash
)
;
continue
'
outer
;
}
let
new_i_p
=
guard
.
bucket_ptr
(
new_i
size_of
)
;
let
prev_ctrl
=
guard
.
replace_ctrl_hash
(
new_i
hash
)
;
if
prev_ctrl
=
=
Tag
:
:
EMPTY
{
guard
.
set_ctrl
(
i
Tag
:
:
EMPTY
)
;
ptr
:
:
copy_nonoverlapping
(
i_p
new_i_p
size_of
)
;
continue
'
outer
;
}
else
{
debug_assert_eq
!
(
prev_ctrl
Tag
:
:
DELETED
)
;
ptr
:
:
swap_nonoverlapping
(
i_p
new_i_p
size_of
)
;
continue
'
inner
;
}
}
}
guard
.
growth_left
=
bucket_mask_to_capacity
(
guard
.
bucket_mask
)
-
guard
.
items
;
mem
:
:
forget
(
guard
)
;
}
#
[
inline
]
unsafe
fn
free_buckets
<
A
>
(
&
mut
self
alloc
:
&
A
table_layout
:
TableLayout
)
where
A
:
Allocator
{
let
(
ptr
layout
)
=
self
.
allocation_info
(
table_layout
)
;
alloc
.
deallocate
(
ptr
layout
)
;
}
#
[
inline
]
unsafe
fn
allocation_info
(
&
self
table_layout
:
TableLayout
)
-
>
(
NonNull
<
u8
>
Layout
)
{
debug_assert
!
(
!
self
.
is_empty_singleton
(
)
"
this
function
can
only
be
called
on
non
-
empty
tables
"
)
;
let
(
layout
ctrl_offset
)
=
match
table_layout
.
calculate_layout_for
(
self
.
buckets
(
)
)
{
Some
(
lco
)
=
>
lco
None
=
>
unsafe
{
hint
:
:
unreachable_unchecked
(
)
}
}
;
(
unsafe
{
NonNull
:
:
new_unchecked
(
self
.
ctrl
.
as_ptr
(
)
.
sub
(
ctrl_offset
)
)
}
layout
)
}
#
[
inline
]
unsafe
fn
allocation_size_or_zero
(
&
self
table_layout
:
TableLayout
)
-
>
usize
{
if
self
.
is_empty_singleton
(
)
{
0
}
else
{
unsafe
{
self
.
allocation_info
(
table_layout
)
.
1
.
size
(
)
}
}
}
#
[
inline
]
fn
clear_no_drop
(
&
mut
self
)
{
if
!
self
.
is_empty_singleton
(
)
{
self
.
ctrl_slice
(
)
.
fill_empty
(
)
;
}
self
.
items
=
0
;
self
.
growth_left
=
bucket_mask_to_capacity
(
self
.
bucket_mask
)
;
}
#
[
inline
]
unsafe
fn
erase
(
&
mut
self
index
:
usize
)
{
debug_assert
!
(
self
.
is_bucket_full
(
index
)
)
;
let
index_before
=
index
.
wrapping_sub
(
Group
:
:
WIDTH
)
&
self
.
bucket_mask
;
let
empty_before
=
Group
:
:
load
(
self
.
ctrl
(
index_before
)
)
.
match_empty
(
)
;
let
empty_after
=
Group
:
:
load
(
self
.
ctrl
(
index
)
)
.
match_empty
(
)
;
let
ctrl
=
if
empty_before
.
leading_zeros
(
)
+
empty_after
.
trailing_zeros
(
)
>
=
Group
:
:
WIDTH
{
Tag
:
:
DELETED
}
else
{
self
.
growth_left
+
=
1
;
Tag
:
:
EMPTY
}
;
self
.
set_ctrl
(
index
ctrl
)
;
self
.
items
-
=
1
;
}
}
impl
<
T
:
Clone
A
:
Allocator
+
Clone
>
Clone
for
RawTable
<
T
A
>
{
fn
clone
(
&
self
)
-
>
Self
{
if
self
.
table
.
is_empty_singleton
(
)
{
Self
:
:
new_in
(
self
.
alloc
.
clone
(
)
)
}
else
{
unsafe
{
let
mut
new_table
=
match
Self
:
:
new_uninitialized
(
self
.
alloc
.
clone
(
)
self
.
table
.
buckets
(
)
Fallibility
:
:
Infallible
)
{
Ok
(
table
)
=
>
table
Err
(
_
)
=
>
hint
:
:
unreachable_unchecked
(
)
}
;
new_table
.
clone_from_spec
(
self
)
;
new_table
}
}
}
fn
clone_from
(
&
mut
self
source
:
&
Self
)
{
if
source
.
table
.
is_empty_singleton
(
)
{
let
mut
old_inner
=
mem
:
:
replace
(
&
mut
self
.
table
RawTableInner
:
:
NEW
)
;
unsafe
{
old_inner
.
drop_inner_table
:
:
<
T
_
>
(
&
self
.
alloc
Self
:
:
TABLE_LAYOUT
)
;
}
}
else
{
unsafe
{
let
mut
self_
=
guard
(
self
|
self_
|
{
self_
.
clear_no_drop
(
)
;
}
)
;
self_
.
table
.
drop_elements
:
:
<
T
>
(
)
;
if
self_
.
buckets
(
)
!
=
source
.
buckets
(
)
{
let
new_inner
=
match
RawTableInner
:
:
new_uninitialized
(
&
self_
.
alloc
Self
:
:
TABLE_LAYOUT
source
.
buckets
(
)
Fallibility
:
:
Infallible
)
{
Ok
(
table
)
=
>
table
Err
(
_
)
=
>
hint
:
:
unreachable_unchecked
(
)
}
;
let
mut
old_inner
=
mem
:
:
replace
(
&
mut
self_
.
table
new_inner
)
;
if
!
old_inner
.
is_empty_singleton
(
)
{
old_inner
.
free_buckets
(
&
self_
.
alloc
Self
:
:
TABLE_LAYOUT
)
;
}
}
self_
.
clone_from_spec
(
source
)
;
ScopeGuard
:
:
into_inner
(
self_
)
;
}
}
}
}
trait
RawTableClone
{
unsafe
fn
clone_from_spec
(
&
mut
self
source
:
&
Self
)
;
}
impl
<
T
:
Clone
A
:
Allocator
+
Clone
>
RawTableClone
for
RawTable
<
T
A
>
{
default_fn
!
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
clone_from_spec
(
&
mut
self
source
:
&
Self
)
{
self
.
clone_from_impl
(
source
)
;
}
}
}
#
[
cfg
(
feature
=
"
nightly
"
)
]
impl
<
T
:
Copy
A
:
Allocator
+
Clone
>
RawTableClone
for
RawTable
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
clone_from_spec
(
&
mut
self
source
:
&
Self
)
{
source
.
table
.
ctrl
(
0
)
.
copy_to_nonoverlapping
(
self
.
table
.
ctrl
(
0
)
self
.
table
.
num_ctrl_bytes
(
)
)
;
source
.
data_start
(
)
.
as_ptr
(
)
.
copy_to_nonoverlapping
(
self
.
data_start
(
)
.
as_ptr
(
)
self
.
table
.
buckets
(
)
)
;
self
.
table
.
items
=
source
.
table
.
items
;
self
.
table
.
growth_left
=
source
.
table
.
growth_left
;
}
}
impl
<
T
:
Clone
A
:
Allocator
+
Clone
>
RawTable
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
clone_from_impl
(
&
mut
self
source
:
&
Self
)
{
source
.
table
.
ctrl
(
0
)
.
copy_to_nonoverlapping
(
self
.
table
.
ctrl
(
0
)
self
.
table
.
num_ctrl_bytes
(
)
)
;
let
mut
guard
=
guard
(
(
0
&
mut
*
self
)
|
(
index
self_
)
|
{
if
T
:
:
NEEDS_DROP
{
for
i
in
0
.
.
*
index
{
if
self_
.
is_bucket_full
(
i
)
{
self_
.
bucket
(
i
)
.
drop
(
)
;
}
}
}
}
)
;
for
from
in
source
.
iter
(
)
{
let
index
=
source
.
bucket_index
(
&
from
)
;
let
to
=
guard
.
1
.
bucket
(
index
)
;
to
.
write
(
from
.
as_ref
(
)
.
clone
(
)
)
;
guard
.
0
=
index
+
1
;
}
mem
:
:
forget
(
guard
)
;
self
.
table
.
items
=
source
.
table
.
items
;
self
.
table
.
growth_left
=
source
.
table
.
growth_left
;
}
}
impl
<
T
A
:
Allocator
+
Default
>
Default
for
RawTable
<
T
A
>
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new_in
(
Default
:
:
default
(
)
)
}
}
#
[
cfg
(
feature
=
"
nightly
"
)
]
unsafe
impl
<
#
[
may_dangle
]
T
A
:
Allocator
>
Drop
for
RawTable
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
table
.
drop_inner_table
:
:
<
T
_
>
(
&
self
.
alloc
Self
:
:
TABLE_LAYOUT
)
;
}
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
impl
<
T
A
:
Allocator
>
Drop
for
RawTable
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
table
.
drop_inner_table
:
:
<
T
_
>
(
&
self
.
alloc
Self
:
:
TABLE_LAYOUT
)
;
}
}
}
impl
<
T
A
:
Allocator
>
IntoIterator
for
RawTable
<
T
A
>
{
type
Item
=
T
;
type
IntoIter
=
RawIntoIter
<
T
A
>
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
into_iter
(
self
)
-
>
RawIntoIter
<
T
A
>
{
unsafe
{
let
iter
=
self
.
iter
(
)
;
self
.
into_iter_from
(
iter
)
}
}
}
pub
(
crate
)
struct
RawIterRange
<
T
>
{
current_group
:
BitMaskIter
data
:
Bucket
<
T
>
next_ctrl
:
*
const
u8
end
:
*
const
u8
}
impl
<
T
>
RawIterRange
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
new
(
ctrl
:
*
const
u8
data
:
Bucket
<
T
>
len
:
usize
)
-
>
Self
{
debug_assert_ne
!
(
len
0
)
;
debug_assert_eq
!
(
ctrl
as
usize
%
Group
:
:
WIDTH
0
)
;
let
end
=
ctrl
.
add
(
len
)
;
let
current_group
=
Group
:
:
load_aligned
(
ctrl
.
cast
(
)
)
.
match_full
(
)
;
let
next_ctrl
=
ctrl
.
add
(
Group
:
:
WIDTH
)
;
Self
{
current_group
:
current_group
.
into_iter
(
)
data
next_ctrl
end
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
#
[
cfg
(
feature
=
"
rayon
"
)
]
pub
(
crate
)
fn
split
(
mut
self
)
-
>
(
Self
Option
<
RawIterRange
<
T
>
>
)
{
unsafe
{
if
self
.
end
<
=
self
.
next_ctrl
{
(
self
None
)
}
else
{
let
len
=
offset_from
(
self
.
end
self
.
next_ctrl
)
;
debug_assert_eq
!
(
len
%
Group
:
:
WIDTH
0
)
;
let
mid
=
(
len
/
2
)
&
!
(
Group
:
:
WIDTH
-
1
)
;
let
tail
=
Self
:
:
new
(
self
.
next_ctrl
.
add
(
mid
)
self
.
data
.
next_n
(
Group
:
:
WIDTH
)
.
next_n
(
mid
)
len
-
mid
)
;
debug_assert_eq
!
(
self
.
data
.
next_n
(
Group
:
:
WIDTH
)
.
next_n
(
mid
)
.
ptr
tail
.
data
.
ptr
)
;
debug_assert_eq
!
(
self
.
end
tail
.
end
)
;
self
.
end
=
self
.
next_ctrl
.
add
(
mid
)
;
debug_assert_eq
!
(
self
.
end
.
add
(
Group
:
:
WIDTH
)
tail
.
next_ctrl
)
;
(
self
Some
(
tail
)
)
}
}
}
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
next_impl
<
const
DO_CHECK_PTR_RANGE
:
bool
>
(
&
mut
self
)
-
>
Option
<
Bucket
<
T
>
>
{
loop
{
if
let
Some
(
index
)
=
self
.
current_group
.
next
(
)
{
return
Some
(
self
.
data
.
next_n
(
index
)
)
;
}
if
DO_CHECK_PTR_RANGE
&
&
self
.
next_ctrl
>
=
self
.
end
{
return
None
;
}
self
.
current_group
=
Group
:
:
load_aligned
(
self
.
next_ctrl
.
cast
(
)
)
.
match_full
(
)
.
into_iter
(
)
;
self
.
data
=
self
.
data
.
next_n
(
Group
:
:
WIDTH
)
;
self
.
next_ctrl
=
self
.
next_ctrl
.
add
(
Group
:
:
WIDTH
)
;
}
}
#
[
allow
(
clippy
:
:
while_let_on_iterator
)
]
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
fold_impl
<
F
B
>
(
mut
self
mut
n
:
usize
mut
acc
:
B
mut
f
:
F
)
-
>
B
where
F
:
FnMut
(
B
Bucket
<
T
>
)
-
>
B
{
loop
{
while
let
Some
(
index
)
=
self
.
current_group
.
next
(
)
{
debug_assert
!
(
n
!
=
0
)
;
let
bucket
=
self
.
data
.
next_n
(
index
)
;
acc
=
f
(
acc
bucket
)
;
n
-
=
1
;
}
if
n
=
=
0
{
return
acc
;
}
self
.
current_group
=
Group
:
:
load_aligned
(
self
.
next_ctrl
.
cast
(
)
)
.
match_full
(
)
.
into_iter
(
)
;
self
.
data
=
self
.
data
.
next_n
(
Group
:
:
WIDTH
)
;
self
.
next_ctrl
=
self
.
next_ctrl
.
add
(
Group
:
:
WIDTH
)
;
}
}
}
unsafe
impl
<
T
>
Send
for
RawIterRange
<
T
>
{
}
unsafe
impl
<
T
>
Sync
for
RawIterRange
<
T
>
{
}
impl
<
T
>
Clone
for
RawIterRange
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Self
{
data
:
self
.
data
.
clone
(
)
next_ctrl
:
self
.
next_ctrl
current_group
:
self
.
current_group
.
clone
(
)
end
:
self
.
end
}
}
}
impl
<
T
>
Iterator
for
RawIterRange
<
T
>
{
type
Item
=
Bucket
<
T
>
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
Bucket
<
T
>
>
{
unsafe
{
self
.
next_impl
:
:
<
true
>
(
)
}
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
remaining_buckets
=
if
self
.
end
>
self
.
next_ctrl
{
unsafe
{
offset_from
(
self
.
end
self
.
next_ctrl
)
}
}
else
{
0
}
;
(
0
Some
(
Group
:
:
WIDTH
+
remaining_buckets
)
)
}
}
impl
<
T
>
FusedIterator
for
RawIterRange
<
T
>
{
}
pub
struct
RawIter
<
T
>
{
pub
(
crate
)
iter
:
RawIterRange
<
T
>
items
:
usize
}
impl
<
T
>
RawIter
<
T
>
{
unsafe
fn
drop_elements
(
&
mut
self
)
{
if
T
:
:
NEEDS_DROP
&
&
self
.
items
!
=
0
{
for
item
in
self
{
item
.
drop
(
)
;
}
}
}
}
impl
<
T
>
Clone
for
RawIter
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Self
{
iter
:
self
.
iter
.
clone
(
)
items
:
self
.
items
}
}
}
impl
<
T
>
Default
for
RawIter
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
default
(
)
-
>
Self
{
unsafe
{
RawTableInner
:
:
NEW
.
iter
(
)
}
}
}
impl
<
T
>
Iterator
for
RawIter
<
T
>
{
type
Item
=
Bucket
<
T
>
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
Bucket
<
T
>
>
{
if
self
.
items
=
=
0
{
return
None
;
}
let
nxt
=
unsafe
{
self
.
iter
.
next_impl
:
:
<
false
>
(
)
}
;
debug_assert
!
(
nxt
.
is_some
(
)
)
;
self
.
items
-
=
1
;
nxt
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
self
.
items
Some
(
self
.
items
)
)
}
#
[
inline
]
fn
fold
<
B
F
>
(
self
init
:
B
f
:
F
)
-
>
B
where
Self
:
Sized
F
:
FnMut
(
B
Self
:
:
Item
)
-
>
B
{
unsafe
{
self
.
iter
.
fold_impl
(
self
.
items
init
f
)
}
}
}
impl
<
T
>
ExactSizeIterator
for
RawIter
<
T
>
{
}
impl
<
T
>
FusedIterator
for
RawIter
<
T
>
{
}
pub
(
crate
)
struct
FullBucketsIndices
{
current_group
:
BitMaskIter
group_first_index
:
usize
ctrl
:
NonNull
<
u8
>
items
:
usize
}
impl
FullBucketsIndices
{
#
[
inline
(
always
)
]
unsafe
fn
next_impl
(
&
mut
self
)
-
>
Option
<
usize
>
{
loop
{
if
let
Some
(
index
)
=
self
.
current_group
.
next
(
)
{
return
Some
(
self
.
group_first_index
+
index
)
;
}
self
.
ctrl
=
NonNull
:
:
new_unchecked
(
self
.
ctrl
.
as_ptr
(
)
.
add
(
Group
:
:
WIDTH
)
)
;
self
.
current_group
=
Group
:
:
load_aligned
(
self
.
ctrl
.
as_ptr
(
)
.
cast
(
)
)
.
match_full
(
)
.
into_iter
(
)
;
self
.
group_first_index
+
=
Group
:
:
WIDTH
;
}
}
}
impl
Iterator
for
FullBucketsIndices
{
type
Item
=
usize
;
#
[
inline
(
always
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
usize
>
{
if
self
.
items
=
=
0
{
return
None
;
}
let
nxt
=
unsafe
{
self
.
next_impl
(
)
}
;
debug_assert
!
(
nxt
.
is_some
(
)
)
;
self
.
items
-
=
1
;
nxt
}
#
[
inline
(
always
)
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
self
.
items
Some
(
self
.
items
)
)
}
}
impl
ExactSizeIterator
for
FullBucketsIndices
{
}
impl
FusedIterator
for
FullBucketsIndices
{
}
pub
struct
RawIntoIter
<
T
A
:
Allocator
=
Global
>
{
iter
:
RawIter
<
T
>
allocation
:
Option
<
(
NonNull
<
u8
>
Layout
A
)
>
marker
:
PhantomData
<
T
>
}
impl
<
T
A
:
Allocator
>
RawIntoIter
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
iter
(
&
self
)
-
>
RawIter
<
T
>
{
self
.
iter
.
clone
(
)
}
}
unsafe
impl
<
T
A
:
Allocator
>
Send
for
RawIntoIter
<
T
A
>
where
T
:
Send
A
:
Send
{
}
unsafe
impl
<
T
A
:
Allocator
>
Sync
for
RawIntoIter
<
T
A
>
where
T
:
Sync
A
:
Sync
{
}
#
[
cfg
(
feature
=
"
nightly
"
)
]
unsafe
impl
<
#
[
may_dangle
]
T
A
:
Allocator
>
Drop
for
RawIntoIter
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
iter
.
drop_elements
(
)
;
if
let
Some
(
(
ptr
layout
ref
alloc
)
)
=
self
.
allocation
{
alloc
.
deallocate
(
ptr
layout
)
;
}
}
}
}
#
[
cfg
(
not
(
feature
=
"
nightly
"
)
)
]
impl
<
T
A
:
Allocator
>
Drop
for
RawIntoIter
<
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
iter
.
drop_elements
(
)
;
if
let
Some
(
(
ptr
layout
ref
alloc
)
)
=
self
.
allocation
{
alloc
.
deallocate
(
ptr
layout
)
;
}
}
}
}
impl
<
T
A
:
Allocator
>
Default
for
RawIntoIter
<
T
A
>
{
fn
default
(
)
-
>
Self
{
Self
{
iter
:
Default
:
:
default
(
)
allocation
:
None
marker
:
PhantomData
}
}
}
impl
<
T
A
:
Allocator
>
Iterator
for
RawIntoIter
<
T
A
>
{
type
Item
=
T
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
unsafe
{
Some
(
self
.
iter
.
next
(
)
?
.
read
(
)
)
}
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
T
A
:
Allocator
>
ExactSizeIterator
for
RawIntoIter
<
T
A
>
{
}
impl
<
T
A
:
Allocator
>
FusedIterator
for
RawIntoIter
<
T
A
>
{
}
pub
struct
RawDrain
<
'
a
T
A
:
Allocator
=
Global
>
{
iter
:
RawIter
<
T
>
table
:
RawTableInner
orig_table
:
NonNull
<
RawTableInner
>
marker
:
PhantomData
<
&
'
a
RawTable
<
T
A
>
>
}
impl
<
T
A
:
Allocator
>
RawDrain
<
'
_
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
fn
iter
(
&
self
)
-
>
RawIter
<
T
>
{
self
.
iter
.
clone
(
)
}
}
unsafe
impl
<
T
A
:
Allocator
>
Send
for
RawDrain
<
'
_
T
A
>
where
T
:
Send
A
:
Send
{
}
unsafe
impl
<
T
A
:
Allocator
>
Sync
for
RawDrain
<
'
_
T
A
>
where
T
:
Sync
A
:
Sync
{
}
impl
<
T
A
:
Allocator
>
Drop
for
RawDrain
<
'
_
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
iter
.
drop_elements
(
)
;
self
.
table
.
clear_no_drop
(
)
;
self
.
orig_table
.
as_ptr
(
)
.
copy_from_nonoverlapping
(
&
self
.
table
1
)
;
}
}
}
impl
<
T
A
:
Allocator
>
Iterator
for
RawDrain
<
'
_
T
A
>
{
type
Item
=
T
;
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
unsafe
{
let
item
=
self
.
iter
.
next
(
)
?
;
Some
(
item
.
read
(
)
)
}
}
#
[
inline
]
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
self
.
iter
.
size_hint
(
)
}
}
impl
<
T
A
:
Allocator
>
ExactSizeIterator
for
RawDrain
<
'
_
T
A
>
{
}
impl
<
T
A
:
Allocator
>
FusedIterator
for
RawDrain
<
'
_
T
A
>
{
}
pub
struct
RawIterHash
<
T
>
{
inner
:
RawIterHashInner
_marker
:
PhantomData
<
T
>
}
#
[
derive
(
Clone
)
]
struct
RawIterHashInner
{
bucket_mask
:
usize
ctrl
:
NonNull
<
u8
>
tag_hash
:
Tag
probe_seq
:
ProbeSeq
group
:
Group
bitmask
:
BitMaskIter
}
impl
<
T
>
RawIterHash
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
new
<
A
:
Allocator
>
(
table
:
&
RawTable
<
T
A
>
hash
:
u64
)
-
>
Self
{
RawIterHash
{
inner
:
RawIterHashInner
:
:
new
(
&
table
.
table
hash
)
_marker
:
PhantomData
}
}
}
impl
<
T
>
Clone
for
RawIterHash
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
clone
(
&
self
)
-
>
Self
{
Self
{
inner
:
self
.
inner
.
clone
(
)
_marker
:
PhantomData
}
}
}
impl
<
T
>
Default
for
RawIterHash
<
T
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
fn
default
(
)
-
>
Self
{
Self
{
inner
:
unsafe
{
RawIterHashInner
:
:
new
(
&
RawTableInner
:
:
NEW
0
)
}
_marker
:
PhantomData
}
}
}
impl
RawIterHashInner
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
unsafe
fn
new
(
table
:
&
RawTableInner
hash
:
u64
)
-
>
Self
{
let
tag_hash
=
Tag
:
:
full
(
hash
)
;
let
probe_seq
=
table
.
probe_seq
(
hash
)
;
let
group
=
Group
:
:
load
(
table
.
ctrl
(
probe_seq
.
pos
)
)
;
let
bitmask
=
group
.
match_tag
(
tag_hash
)
.
into_iter
(
)
;
RawIterHashInner
{
bucket_mask
:
table
.
bucket_mask
ctrl
:
table
.
ctrl
tag_hash
probe_seq
group
bitmask
}
}
}
impl
<
T
>
Iterator
for
RawIterHash
<
T
>
{
type
Item
=
Bucket
<
T
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Bucket
<
T
>
>
{
unsafe
{
match
self
.
inner
.
next
(
)
{
Some
(
index
)
=
>
{
debug_assert
!
(
index
<
=
self
.
inner
.
bucket_mask
)
;
let
bucket
=
Bucket
:
:
from_base_index
(
self
.
inner
.
ctrl
.
cast
(
)
index
)
;
Some
(
bucket
)
}
None
=
>
None
}
}
}
}
impl
Iterator
for
RawIterHashInner
{
type
Item
=
usize
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
unsafe
{
loop
{
if
let
Some
(
bit
)
=
self
.
bitmask
.
next
(
)
{
let
index
=
(
self
.
probe_seq
.
pos
+
bit
)
&
self
.
bucket_mask
;
return
Some
(
index
)
;
}
if
likely
(
self
.
group
.
match_empty
(
)
.
any_bit_set
(
)
)
{
return
None
;
}
self
.
probe_seq
.
move_next
(
self
.
bucket_mask
)
;
let
index
=
self
.
probe_seq
.
pos
;
debug_assert
!
(
index
<
self
.
bucket_mask
+
1
+
Group
:
:
WIDTH
)
;
let
group_ctrl
=
self
.
ctrl
.
as_ptr
(
)
.
add
(
index
)
.
cast
(
)
;
self
.
group
=
Group
:
:
load
(
group_ctrl
)
;
self
.
bitmask
=
self
.
group
.
match_tag
(
self
.
tag_hash
)
.
into_iter
(
)
;
}
}
}
}
pub
(
crate
)
struct
RawExtractIf
<
'
a
T
A
:
Allocator
>
{
pub
iter
:
RawIter
<
T
>
pub
table
:
&
'
a
mut
RawTable
<
T
A
>
}
impl
<
T
A
:
Allocator
>
RawExtractIf
<
'
_
T
A
>
{
#
[
cfg_attr
(
feature
=
"
inline
-
more
"
inline
)
]
pub
(
crate
)
fn
next
<
F
>
(
&
mut
self
mut
f
:
F
)
-
>
Option
<
T
>
where
F
:
FnMut
(
&
mut
T
)
-
>
bool
{
unsafe
{
for
item
in
&
mut
self
.
iter
{
if
f
(
item
.
as_mut
(
)
)
{
return
Some
(
self
.
table
.
remove
(
item
)
.
0
)
;
}
}
}
None
}
}
#
[
cfg
(
test
)
]
mod
test_map
{
use
super
:
:
*
;
#
[
test
]
fn
test_minimum_capacity_for_small_types
(
)
{
#
[
track_caller
]
fn
test_t
<
T
>
(
)
{
let
raw_table
:
RawTable
<
T
>
=
RawTable
:
:
with_capacity
(
1
)
;
let
actual_buckets
=
raw_table
.
buckets
(
)
;
let
min_buckets
=
Group
:
:
WIDTH
/
core
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
;
assert
!
(
actual_buckets
>
=
min_buckets
"
expected
at
least
{
min_buckets
}
buckets
got
{
actual_buckets
}
buckets
"
)
;
}
test_t
:
:
<
u8
>
(
)
;
test_t
:
:
<
u16
>
(
)
;
}
fn
rehash_in_place
<
T
>
(
table
:
&
mut
RawTable
<
T
>
hasher
:
impl
Fn
(
&
T
)
-
>
u64
)
{
unsafe
{
table
.
table
.
rehash_in_place
(
&
|
table
index
|
hasher
(
table
.
bucket
:
:
<
T
>
(
index
)
.
as_ref
(
)
)
mem
:
:
size_of
:
:
<
T
>
(
)
if
mem
:
:
needs_drop
:
:
<
T
>
(
)
{
Some
(
|
ptr
|
ptr
:
:
drop_in_place
(
ptr
as
*
mut
T
)
)
}
else
{
None
}
)
;
}
}
#
[
test
]
fn
rehash
(
)
{
let
mut
table
=
RawTable
:
:
new
(
)
;
let
hasher
=
|
i
:
&
u64
|
*
i
;
for
i
in
0
.
.
100
{
table
.
insert
(
i
i
hasher
)
;
}
for
i
in
0
.
.
100
{
unsafe
{
assert_eq
!
(
table
.
find
(
i
|
x
|
*
x
=
=
i
)
.
map
(
|
b
|
b
.
read
(
)
)
Some
(
i
)
)
;
}
assert
!
(
table
.
find
(
i
+
100
|
x
|
*
x
=
=
i
+
100
)
.
is_none
(
)
)
;
}
rehash_in_place
(
&
mut
table
hasher
)
;
for
i
in
0
.
.
100
{
unsafe
{
assert_eq
!
(
table
.
find
(
i
|
x
|
*
x
=
=
i
)
.
map
(
|
b
|
b
.
read
(
)
)
Some
(
i
)
)
;
}
assert
!
(
table
.
find
(
i
+
100
|
x
|
*
x
=
=
i
+
100
)
.
is_none
(
)
)
;
}
}
#
[
test
]
fn
test_drop_uninitialized
(
)
{
use
:
:
alloc
:
:
vec
:
:
Vec
;
let
table
=
unsafe
{
RawTable
:
:
<
(
u64
Vec
<
i32
>
)
>
:
:
new_uninitialized
(
Global
8
Fallibility
:
:
Infallible
)
.
unwrap
(
)
}
;
drop
(
table
)
;
}
#
[
test
]
fn
test_drop_zero_items
(
)
{
use
:
:
alloc
:
:
vec
:
:
Vec
;
unsafe
{
let
mut
table
=
RawTable
:
:
<
(
u64
Vec
<
i32
>
)
>
:
:
new_uninitialized
(
Global
8
Fallibility
:
:
Infallible
)
.
unwrap
(
)
;
table
.
table
.
ctrl_slice
(
)
.
fill_empty
(
)
;
table
.
table
.
ctrl
(
0
)
.
write_bytes
(
0
table
.
capacity
(
)
)
;
if
table
.
buckets
(
)
<
Group
:
:
WIDTH
{
table
.
table
.
ctrl
(
0
)
.
copy_to
(
table
.
table
.
ctrl
(
Group
:
:
WIDTH
)
table
.
table
.
buckets
(
)
)
;
}
else
{
table
.
table
.
ctrl
(
0
)
.
copy_to
(
table
.
table
.
ctrl
(
table
.
table
.
buckets
(
)
)
Group
:
:
WIDTH
)
;
}
drop
(
table
)
;
}
}
#
[
test
]
fn
test_catch_panic_clone_from
(
)
{
use
super
:
:
{
AllocError
Allocator
Global
}
;
use
:
:
alloc
:
:
sync
:
:
Arc
;
use
:
:
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
sync
:
:
atomic
:
:
{
AtomicI8
Ordering
}
;
use
std
:
:
thread
;
struct
MyAllocInner
{
drop_count
:
Arc
<
AtomicI8
>
}
#
[
derive
(
Clone
)
]
struct
MyAlloc
{
_inner
:
Arc
<
MyAllocInner
>
}
impl
Drop
for
MyAllocInner
{
fn
drop
(
&
mut
self
)
{
println
!
(
"
MyAlloc
freed
.
"
)
;
self
.
drop_count
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
;
}
}
unsafe
impl
Allocator
for
MyAlloc
{
fn
allocate
(
&
self
layout
:
Layout
)
-
>
std
:
:
result
:
:
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
let
g
=
Global
;
g
.
allocate
(
layout
)
}
unsafe
fn
deallocate
(
&
self
ptr
:
NonNull
<
u8
>
layout
:
Layout
)
{
let
g
=
Global
;
g
.
deallocate
(
ptr
layout
)
}
}
const
DISARMED
:
bool
=
false
;
const
ARMED
:
bool
=
true
;
struct
CheckedCloneDrop
{
panic_in_clone
:
bool
dropped
:
bool
need_drop
:
Vec
<
u64
>
}
impl
Clone
for
CheckedCloneDrop
{
fn
clone
(
&
self
)
-
>
Self
{
if
self
.
panic_in_clone
{
panic
!
(
"
panic
in
clone
"
)
}
Self
{
panic_in_clone
:
self
.
panic_in_clone
dropped
:
self
.
dropped
need_drop
:
self
.
need_drop
.
clone
(
)
}
}
}
impl
Drop
for
CheckedCloneDrop
{
fn
drop
(
&
mut
self
)
{
if
self
.
dropped
{
panic
!
(
"
double
drop
"
)
;
}
self
.
dropped
=
true
;
}
}
let
dropped
:
Arc
<
AtomicI8
>
=
Arc
:
:
new
(
AtomicI8
:
:
new
(
2
)
)
;
let
mut
table
=
RawTable
:
:
new_in
(
MyAlloc
{
_inner
:
Arc
:
:
new
(
MyAllocInner
{
drop_count
:
dropped
.
clone
(
)
}
)
}
)
;
for
(
idx
panic_in_clone
)
in
core
:
:
iter
:
:
repeat
(
DISARMED
)
.
take
(
7
)
.
enumerate
(
)
{
let
idx
=
idx
as
u64
;
table
.
insert
(
idx
(
idx
CheckedCloneDrop
{
panic_in_clone
dropped
:
false
need_drop
:
vec
!
[
idx
]
}
)
|
(
k
_
)
|
*
k
)
;
}
assert_eq
!
(
table
.
len
(
)
7
)
;
thread
:
:
scope
(
|
s
|
{
let
result
=
s
.
spawn
(
|
|
{
let
armed_flags
=
[
DISARMED
DISARMED
ARMED
DISARMED
DISARMED
DISARMED
DISARMED
]
;
let
mut
scope_table
=
RawTable
:
:
new_in
(
MyAlloc
{
_inner
:
Arc
:
:
new
(
MyAllocInner
{
drop_count
:
dropped
.
clone
(
)
}
)
}
)
;
for
(
idx
&
panic_in_clone
)
in
armed_flags
.
iter
(
)
.
enumerate
(
)
{
let
idx
=
idx
as
u64
;
scope_table
.
insert
(
idx
(
idx
CheckedCloneDrop
{
panic_in_clone
dropped
:
false
need_drop
:
vec
!
[
idx
+
100
]
}
)
|
(
k
_
)
|
*
k
)
;
}
table
.
clone_from
(
&
scope_table
)
;
}
)
;
assert
!
(
result
.
join
(
)
.
is_err
(
)
)
;
}
)
;
assert_eq
!
(
table
.
len
(
)
0
)
;
assert_eq
!
(
unsafe
{
table
.
iter
(
)
.
count
(
)
}
0
)
;
assert_eq
!
(
unsafe
{
table
.
iter
(
)
.
iter
.
count
(
)
}
0
)
;
for
idx
in
0
.
.
table
.
buckets
(
)
{
let
idx
=
idx
as
u64
;
assert
!
(
table
.
find
(
idx
|
(
k
_
)
|
*
k
=
=
idx
)
.
is_none
(
)
"
Index
:
{
idx
}
"
)
;
}
assert_eq
!
(
dropped
.
load
(
Ordering
:
:
SeqCst
)
1
)
;
}
}
