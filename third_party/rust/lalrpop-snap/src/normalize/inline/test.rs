use
grammar
:
:
parse_tree
:
:
NonterminalString
;
use
grammar
:
:
repr
:
:
Grammar
;
use
string_cache
:
:
DefaultAtom
as
Atom
;
use
normalize
:
:
{
self
NormResult
}
;
use
parser
;
use
session
:
:
Session
;
use
super
:
:
inline
;
fn
inlined_grammar
(
text
:
&
str
)
-
>
NormResult
<
Grammar
>
{
let
g
=
parser
:
:
parse_grammar
(
text
)
.
unwrap
(
)
;
let
g
=
normalize
:
:
lower_helper
(
&
Session
:
:
test
(
)
g
true
)
.
unwrap
(
)
;
inline
(
g
)
}
#
[
test
]
fn
sri
(
)
{
let
grammar
=
inlined_grammar
(
r
#
"
grammar
;
E
:
(
)
=
{
"
L
"
"
&
"
OPT_L
E
}
;
#
[
inline
]
OPT_L
:
(
)
=
{
(
)
"
L
"
}
;
"
#
)
.
unwrap
(
)
;
let
nt
=
NonterminalString
(
Atom
:
:
from
(
"
E
"
)
)
;
let
e_productions
=
grammar
.
productions_for
(
&
nt
)
;
assert_eq
!
(
e_productions
.
len
(
)
3
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
e_productions
[
0
]
.
symbols
)
r
#
"
[
"
L
"
]
"
#
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
e_productions
[
1
]
.
symbols
)
r
#
"
[
"
&
"
E
]
"
#
)
;
assert_eq
!
(
format
!
(
"
{
:
?
}
"
e_productions
[
2
]
.
symbols
)
r
#
"
[
"
&
"
"
L
"
E
]
"
#
)
;
}
#
[
test
]
fn
issue_55
(
)
{
let
grammar
=
inlined_grammar
(
r
#
"
grammar
;
pub
E
:
(
)
=
{
"
X
"
"
{
"
<
a
:
AT
*
>
<
e
:
ET
>
<
b
:
AT
*
>
"
}
"
=
>
(
)
}
;
AT
:
(
)
=
{
"
type
"
"
;
"
=
>
(
)
}
;
ET
:
(
)
=
{
"
enum
"
"
{
"
"
}
"
=
>
(
)
}
;
"
#
)
.
unwrap
(
)
;
let
nt
=
NonterminalString
(
Atom
:
:
from
(
"
E
"
)
)
;
assert
!
(
grammar
.
productions_for
(
&
nt
)
.
len
(
)
=
=
4
)
;
}
