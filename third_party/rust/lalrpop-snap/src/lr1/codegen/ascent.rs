use
collections
:
:
{
Multimap
Set
}
;
use
grammar
:
:
parse_tree
:
:
WhereClause
;
use
grammar
:
:
repr
:
:
{
Grammar
NonterminalString
Production
Symbol
TerminalString
TypeParameter
TypeRepr
Visibility
}
;
use
lr1
:
:
core
:
:
*
;
use
lr1
:
:
lookahead
:
:
Token
;
use
lr1
:
:
state_graph
:
:
StateGraph
;
use
rust
:
:
RustWrite
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
tls
:
:
Tls
;
use
util
:
:
{
Escape
Sep
}
;
use
super
:
:
base
:
:
CodeGenerator
;
pub
fn
compile
<
'
grammar
W
:
Write
>
(
grammar
:
&
'
grammar
Grammar
user_start_symbol
:
NonterminalString
start_symbol
:
NonterminalString
states
:
&
[
LR1State
<
'
grammar
>
]
action_module
:
&
str
out
:
&
mut
RustWrite
<
W
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
graph
=
StateGraph
:
:
new
(
&
states
)
;
let
mut
ascent
=
CodeGenerator
:
:
new_ascent
(
grammar
user_start_symbol
start_symbol
&
graph
states
action_module
out
)
;
ascent
.
write
(
)
}
struct
RecursiveAscent
<
'
ascent
'
grammar
>
{
graph
:
&
'
ascent
StateGraph
state_inputs
:
Vec
<
StackSuffix
<
'
grammar
>
>
nonterminal_type_params
:
Vec
<
TypeParameter
>
nonterminal_where_clauses
:
Vec
<
WhereClause
<
TypeRepr
>
>
}
#
[
derive
(
Copy
Clone
Debug
)
]
struct
StackSuffix
<
'
grammar
>
{
all
:
&
'
grammar
[
Symbol
]
len_optional
:
usize
}
impl
<
'
grammar
>
StackSuffix
<
'
grammar
>
{
fn
len
(
&
self
)
-
>
usize
{
self
.
all
.
len
(
)
}
fn
optional_fixed_lens
(
&
self
)
-
>
(
usize
usize
)
{
(
self
.
len_optional
self
.
len
(
)
-
self
.
len_optional
)
}
fn
is_not_empty
(
&
self
)
-
>
bool
{
self
.
len
(
)
>
0
}
fn
optional
(
&
self
)
-
>
&
'
grammar
[
Symbol
]
{
&
self
.
all
[
.
.
self
.
len_optional
]
}
fn
fixed
(
&
self
)
-
>
&
'
grammar
[
Symbol
]
{
&
self
.
all
[
self
.
len_optional
.
.
]
}
}
impl
<
'
ascent
'
grammar
W
:
Write
>
CodeGenerator
<
'
ascent
'
grammar
W
RecursiveAscent
<
'
ascent
'
grammar
>
>
{
fn
new_ascent
(
grammar
:
&
'
grammar
Grammar
user_start_symbol
:
NonterminalString
start_symbol
:
NonterminalString
graph
:
&
'
ascent
StateGraph
states
:
&
'
ascent
[
LR1State
<
'
grammar
>
]
action_module
:
&
str
out
:
&
'
ascent
mut
RustWrite
<
W
>
)
-
>
Self
{
let
referenced_ty_params
:
Set
<
TypeParameter
>
=
grammar
.
types
.
nonterminal_types
(
)
.
into_iter
(
)
.
flat_map
(
|
t
|
t
.
referenced
(
)
)
.
collect
(
)
;
let
nonterminal_type_params
:
Vec
<
_
>
=
grammar
.
type_parameters
.
iter
(
)
.
filter
(
|
t
|
referenced_ty_params
.
contains
(
t
)
)
.
cloned
(
)
.
collect
(
)
;
let
mut
referenced_where_clauses
=
Set
:
:
new
(
)
;
for
wc
in
&
grammar
.
where_clauses
{
wc
.
map
(
|
ty
|
{
if
ty
.
referenced
(
)
.
iter
(
)
.
any
(
|
p
|
nonterminal_type_params
.
contains
(
p
)
)
{
referenced_where_clauses
.
insert
(
wc
.
clone
(
)
)
;
}
}
)
;
}
let
nonterminal_where_clauses
:
Vec
<
_
>
=
grammar
.
where_clauses
.
iter
(
)
.
filter
(
|
wc
|
referenced_where_clauses
.
contains
(
wc
)
)
.
cloned
(
)
.
collect
(
)
;
let
state_inputs
=
states
.
iter
(
)
.
map
(
|
state
|
Self
:
:
state_input_for
(
state
)
)
.
collect
(
)
;
CodeGenerator
:
:
new
(
grammar
user_start_symbol
start_symbol
states
out
false
action_module
RecursiveAscent
{
graph
:
graph
state_inputs
:
state_inputs
nonterminal_type_params
:
nonterminal_type_params
nonterminal_where_clauses
:
nonterminal_where_clauses
}
)
}
fn
state_input_for
(
state
:
&
'
ascent
LR1State
<
'
grammar
>
)
-
>
StackSuffix
<
'
grammar
>
{
let
max_prefix
=
state
.
max_prefix
(
)
;
let
will_pop
=
state
.
will_pop
(
)
;
StackSuffix
{
all
:
max_prefix
len_optional
:
max_prefix
.
len
(
)
-
will_pop
.
len
(
)
}
}
fn
write
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
write_parse_mod
(
|
this
|
{
try
!
(
this
.
write_start_fn
(
)
)
;
rust
!
(
this
.
out
"
"
)
;
try
!
(
this
.
write_return_type_defn
(
)
)
;
for
i
in
0
.
.
this
.
states
.
len
(
)
{
try
!
(
this
.
write_state_fn
(
StateIndex
(
i
)
)
)
;
}
Ok
(
(
)
)
}
)
}
fn
write_return_type_defn
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
rust
!
(
self
.
out
"
#
[
allow
(
dead_code
)
]
"
)
;
rust
!
(
self
.
out
"
pub
enum
{
}
Nonterminal
<
{
}
>
"
self
.
prefix
Sep
(
"
"
&
self
.
custom
.
nonterminal_type_params
)
)
;
if
!
self
.
custom
.
nonterminal_where_clauses
.
is_empty
(
)
{
rust
!
(
self
.
out
"
where
{
}
"
Sep
(
"
"
&
self
.
custom
.
nonterminal_where_clauses
)
)
;
}
rust
!
(
self
.
out
"
{
{
"
)
;
for
ref
nt
in
self
.
grammar
.
nonterminals
.
keys
(
)
{
let
ty
=
self
.
types
.
spanned_type
(
self
.
types
.
nonterminal_type
(
nt
)
.
clone
(
)
)
;
rust
!
(
self
.
out
"
{
}
(
{
}
)
"
Escape
(
nt
)
ty
)
;
}
rust
!
(
self
.
out
"
}
}
"
)
;
Ok
(
(
)
)
}
fn
write_start_fn
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
let
phantom_data
=
self
.
phantom_data_expr
(
)
;
try
!
(
self
.
start_parser_fn
(
)
)
;
try
!
(
self
.
define_tokens
(
)
)
;
try
!
(
self
.
next_token
(
"
lookahead
"
"
tokens
"
)
)
;
rust
!
(
self
.
out
"
match
try
!
(
{
}
state0
(
{
}
&
mut
{
}
tokens
{
}
lookahead
{
}
)
)
{
{
"
self
.
prefix
self
.
grammar
.
user_parameter_refs
(
)
self
.
prefix
self
.
prefix
phantom_data
)
;
rust
!
(
self
.
out
"
(
Some
(
{
}
lookahead
)
_
)
=
>
{
{
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
Err
(
{
}
lalrpop_util
:
:
ParseError
:
:
ExtraToken
{
{
token
:
{
}
lookahead
}
}
)
"
self
.
prefix
self
.
prefix
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
rust
!
(
self
.
out
"
(
None
{
}
Nonterminal
:
:
{
}
(
(
_
{
}
nt
_
)
)
)
=
>
{
{
"
self
.
prefix
Escape
(
&
self
.
start_symbol
)
self
.
prefix
)
;
rust
!
(
self
.
out
"
Ok
(
{
}
nt
)
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
rust
!
(
self
.
out
"
_
=
>
unreachable
!
(
)
"
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
self
.
end_parser_fn
(
)
}
fn
write_state_fn
(
&
mut
self
this_index
:
StateIndex
)
-
>
io
:
:
Result
<
(
)
>
{
let
this_state
=
&
self
.
states
[
this_index
.
0
]
;
let
inputs
=
self
.
custom
.
state_inputs
[
this_index
.
0
]
;
rust
!
(
self
.
out
"
"
)
;
if
Tls
:
:
session
(
)
.
emit_comments
{
rust
!
(
self
.
out
"
/
/
State
{
}
"
this_index
.
0
)
;
rust
!
(
self
.
out
"
/
/
AllInputs
=
{
:
?
}
"
inputs
.
all
)
;
rust
!
(
self
.
out
"
/
/
OptionalInputs
=
{
:
?
}
"
inputs
.
optional
(
)
)
;
rust
!
(
self
.
out
"
/
/
FixedInputs
=
{
:
?
}
"
inputs
.
fixed
(
)
)
;
rust
!
(
self
.
out
"
/
/
WillPushLen
=
{
:
?
}
"
this_state
.
will_push
(
)
.
len
(
)
)
;
rust
!
(
self
.
out
"
/
/
WillPush
=
{
:
?
}
"
this_state
.
will_push
(
)
)
;
rust
!
(
self
.
out
"
/
/
WillProduce
=
{
:
?
}
"
this_state
.
will_produce
(
)
)
;
rust
!
(
self
.
out
"
/
/
"
)
;
for
item
in
this_state
.
items
.
vec
.
iter
(
)
{
rust
!
(
self
.
out
"
/
/
{
:
?
}
"
item
)
;
}
rust
!
(
self
.
out
"
/
/
"
)
;
for
(
terminal
action
)
in
&
this_state
.
shifts
{
rust
!
(
self
.
out
"
/
/
{
:
?
}
-
>
{
:
?
}
"
terminal
action
)
;
}
for
&
(
ref
tokens
action
)
in
&
this_state
.
reductions
{
rust
!
(
self
.
out
"
/
/
{
:
?
}
-
>
{
:
?
}
"
tokens
action
)
;
}
rust
!
(
self
.
out
"
/
/
"
)
;
for
(
nt
state
)
in
&
this_state
.
gotos
{
rust
!
(
self
.
out
"
/
/
{
:
?
}
-
>
{
:
?
}
"
nt
state
)
;
}
}
try
!
(
self
.
emit_state_fn_header
(
"
state
"
this_index
.
0
inputs
)
)
;
let
stack_suffix
=
try
!
(
self
.
adjust_inputs
(
this_index
inputs
)
)
;
let
mut
fallthrough
=
false
;
rust
!
(
self
.
out
"
match
{
}
lookahead
{
{
"
self
.
prefix
)
;
for
(
terminal
&
next_index
)
in
&
this_state
.
shifts
{
let
sym_name
=
format
!
(
"
{
}
sym
{
}
"
self
.
prefix
inputs
.
len
(
)
)
;
try
!
(
self
.
consume_terminal
(
terminal
sym_name
)
)
;
if
try
!
(
self
.
transition
(
"
result
"
stack_suffix
next_index
&
[
"
tokens
"
]
)
)
{
fallthrough
=
true
;
}
rust
!
(
self
.
out
"
}
}
"
)
;
}
let
reductions
:
Multimap
<
_
Vec
<
_
>
>
=
this_state
.
reductions
.
iter
(
)
.
flat_map
(
|
&
(
ref
tokens
production
)
|
tokens
.
iter
(
)
.
map
(
move
|
t
|
(
production
t
)
)
)
.
collect
(
)
;
for
(
production
tokens
)
in
reductions
{
for
(
index
token
)
in
tokens
.
iter
(
)
.
enumerate
(
)
{
let
pattern
=
match
*
token
{
Token
:
:
Terminal
(
ref
s
)
=
>
format
!
(
"
Some
(
{
}
)
"
self
.
match_terminal_pattern
(
s
)
)
Token
:
:
Error
=
>
{
panic
!
(
"
Error
recovery
is
not
implemented
for
recursive
ascent
parsers
"
)
}
Token
:
:
EOF
=
>
format
!
(
"
None
"
)
}
;
if
index
<
tokens
.
len
(
)
-
1
{
rust
!
(
self
.
out
"
{
}
|
"
pattern
)
;
}
else
{
rust
!
(
self
.
out
"
{
}
=
>
{
{
"
pattern
)
;
}
}
try
!
(
self
.
emit_reduce_action
(
"
result
"
stack_suffix
production
)
)
;
if
production
.
symbols
.
len
(
)
>
0
{
rust
!
(
self
.
out
"
return
Ok
(
{
}
result
)
;
"
self
.
prefix
)
;
}
else
{
fallthrough
=
true
;
}
rust
!
(
self
.
out
"
}
}
"
)
;
}
rust
!
(
self
.
out
"
_
=
>
{
{
"
)
;
let
successful_terminals
=
self
.
grammar
.
terminals
.
all
.
iter
(
)
.
filter
(
|
&
terminal
|
{
this_state
.
shifts
.
contains_key
(
terminal
)
|
|
this_state
.
reductions
.
iter
(
)
.
any
(
|
&
(
ref
t
_
)
|
t
.
contains
(
&
Token
:
:
Terminal
(
terminal
.
clone
(
)
)
)
)
}
)
;
rust
!
(
self
.
out
"
return
Err
(
{
}
lalrpop_util
:
:
ParseError
:
:
UnrecognizedToken
{
{
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
token
:
{
}
lookahead
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
expected
:
vec
!
[
"
)
;
for
terminal
in
successful_terminals
{
rust
!
(
self
.
out
"
r
#
#
#
\
"
{
}
\
"
#
#
#
.
to_string
(
)
"
terminal
)
;
}
rust
!
(
self
.
out
"
]
"
)
;
rust
!
(
self
.
out
"
}
}
)
;
"
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
if
fallthrough
&
&
!
this_state
.
gotos
.
is_empty
(
)
{
rust
!
(
self
.
out
"
loop
{
{
"
)
;
let
top_slot_optional
=
{
stack_suffix
.
is_not_empty
(
)
&
&
stack_suffix
.
fixed
(
)
.
is_empty
(
)
}
;
if
top_slot_optional
{
rust
!
(
self
.
out
"
if
{
}
sym
{
}
.
is_none
(
)
{
{
"
self
.
prefix
stack_suffix
.
len
(
)
-
1
)
;
rust
!
(
self
.
out
"
return
Ok
(
{
}
result
)
;
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
}
rust
!
(
self
.
out
"
let
(
{
}
lookahead
{
}
nt
)
=
{
}
result
;
"
self
.
prefix
self
.
prefix
self
.
prefix
)
;
rust
!
(
self
.
out
"
match
{
}
nt
{
{
"
self
.
prefix
)
;
for
(
ref
nt
&
next_index
)
in
&
this_state
.
gotos
{
rust
!
(
self
.
out
"
{
}
Nonterminal
:
:
{
}
(
{
}
sym
{
}
)
=
>
{
{
"
self
.
prefix
Escape
(
nt
)
self
.
prefix
stack_suffix
.
len
(
)
)
;
try
!
(
self
.
transition
(
"
result
"
stack_suffix
next_index
&
[
"
tokens
"
"
lookahead
"
]
)
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
}
if
this_state
.
gotos
.
len
(
)
!
=
self
.
grammar
.
nonterminals
.
keys
(
)
.
len
(
)
{
rust
!
(
self
.
out
"
_
=
>
{
{
"
)
;
rust
!
(
self
.
out
"
return
Ok
(
(
{
}
lookahead
{
}
nt
)
)
;
"
self
.
prefix
self
.
prefix
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
}
rust
!
(
self
.
out
"
}
}
"
)
;
rust
!
(
self
.
out
"
}
}
"
)
;
}
else
if
fallthrough
{
rust
!
(
self
.
out
"
return
Ok
(
{
}
result
)
;
"
self
.
prefix
)
;
}
rust
!
(
self
.
out
"
}
}
"
)
;
Ok
(
(
)
)
}
fn
emit_state_fn_header
(
&
mut
self
fn_kind
:
&
str
fn_index
:
usize
suffix
:
StackSuffix
<
'
grammar
>
)
-
>
io
:
:
Result
<
(
)
>
{
let
optional_prefix
=
suffix
.
optional
(
)
;
let
fixed_prefix
=
suffix
.
fixed
(
)
;
let
triple_type
=
self
.
triple_type
(
)
;
let
parse_error_type
=
self
.
types
.
parse_error_type
(
)
;
let
error_type
=
self
.
types
.
error_type
(
)
;
let
iter_error_type
=
if
self
.
grammar
.
intern_token
.
is_some
(
)
{
parse_error_type
}
else
{
&
error_type
}
;
let
(
fn_args
starts_with_terminal
)
=
self
.
fn_args
(
optional_prefix
fixed_prefix
)
;
try
!
(
self
.
out
.
write_fn_header
(
self
.
grammar
&
Visibility
:
:
Priv
format
!
(
"
{
}
{
}
{
}
"
self
.
prefix
fn_kind
fn_index
)
vec
!
[
format
!
(
"
{
}
TOKENS
:
Iterator
<
Item
=
Result
<
{
}
{
}
>
>
"
self
.
prefix
triple_type
iter_error_type
)
]
None
fn_args
format
!
(
"
Result
<
(
Option
<
{
}
>
{
}
Nonterminal
<
{
}
>
)
{
}
>
"
triple_type
self
.
prefix
Sep
(
"
"
&
self
.
custom
.
nonterminal_type_params
)
parse_error_type
)
vec
!
[
]
)
)
;
rust
!
(
self
.
out
"
{
{
"
)
;
rust
!
(
self
.
out
"
let
mut
{
}
result
:
(
Option
<
{
}
>
{
}
Nonterminal
<
{
}
>
)
;
"
self
.
prefix
triple_type
self
.
prefix
Sep
(
"
"
&
self
.
custom
.
nonterminal_type_params
)
)
;
if
starts_with_terminal
{
try
!
(
self
.
next_token
(
"
lookahead
"
"
tokens
"
)
)
;
}
Ok
(
(
)
)
}
fn
fn_args
(
&
mut
self
optional_prefix
:
&
[
Symbol
]
fixed_prefix
:
&
[
Symbol
]
)
-
>
(
Vec
<
String
>
bool
)
{
assert
!
(
/
/
start
state
:
(
optional_prefix
.
is_empty
(
)
&
&
fixed_prefix
.
is_empty
(
)
)
|
|
/
*
any
other
state
:
*
/
!
fixed_prefix
.
is_empty
(
)
)
;
let
triple_type
=
self
.
triple_type
(
)
;
let
starts_with_terminal
=
fixed_prefix
.
last
(
)
.
map
(
|
l
|
l
.
is_terminal
(
)
)
.
unwrap_or
(
false
)
;
let
mut
base_args
=
vec
!
[
format
!
(
"
{
}
tokens
:
&
mut
{
}
TOKENS
"
self
.
prefix
self
.
prefix
)
]
;
if
!
starts_with_terminal
{
base_args
.
push
(
format
!
(
"
{
}
lookahead
:
Option
<
{
}
>
"
self
.
prefix
triple_type
)
)
;
}
let
optional_args
=
(
0
.
.
optional_prefix
.
len
(
)
)
.
map
(
|
i
|
{
format
!
(
"
{
}
sym
{
}
:
&
mut
Option
<
{
}
>
"
self
.
prefix
i
self
.
types
.
spanned_type
(
optional_prefix
[
i
]
.
ty
(
&
self
.
types
)
.
clone
(
)
)
)
}
)
;
let
fixed_args
=
(
0
.
.
fixed_prefix
.
len
(
)
)
.
map
(
|
i
|
{
format
!
(
"
{
}
sym
{
}
:
{
}
"
self
.
prefix
optional_prefix
.
len
(
)
+
i
self
.
types
.
spanned_type
(
fixed_prefix
[
i
]
.
ty
(
&
self
.
types
)
.
clone
(
)
)
)
}
)
;
let
all_args
=
base_args
.
into_iter
(
)
.
chain
(
optional_args
)
.
chain
(
fixed_args
)
.
chain
(
Some
(
format
!
(
"
_
:
{
}
"
self
.
phantom_data_type
(
)
)
)
)
.
collect
(
)
;
(
all_args
starts_with_terminal
)
}
fn
adjust_inputs
(
&
mut
self
state_index
:
StateIndex
inputs
:
StackSuffix
<
'
grammar
>
)
-
>
io
:
:
Result
<
StackSuffix
<
'
grammar
>
>
{
let
mut
result
=
inputs
;
let
top_opt
=
self
.
custom
.
graph
.
successors
(
state_index
)
.
iter
(
)
.
any
(
|
succ_state
|
{
let
succ_inputs
=
&
self
.
custom
.
state_inputs
[
succ_state
.
0
]
;
assert
!
(
succ_inputs
.
fixed
(
)
.
len
(
)
>
=
1
)
;
succ_inputs
.
fixed
(
)
.
len
(
)
=
=
1
&
&
succ_inputs
.
optional
(
)
.
len
(
)
>
0
}
)
;
if
top_opt
{
let
start_num
=
inputs
.
optional
(
)
.
len
(
)
;
for
sym_num
in
(
start_num
.
.
start_num
+
inputs
.
fixed
(
)
.
len
(
)
)
{
rust
!
(
self
.
out
"
let
{
}
sym
{
}
=
&
mut
Some
(
{
}
sym
{
}
)
;
"
self
.
prefix
sym_num
self
.
prefix
sym_num
)
;
}
result
.
len_optional
=
result
.
len
(
)
;
}
Ok
(
result
)
}
fn
pop_syms
(
&
mut
self
optional
:
usize
fixed
:
usize
inputs
:
StackSuffix
<
'
grammar
>
)
-
>
io
:
:
Result
<
Vec
<
String
>
>
{
let
total_have
=
optional
+
fixed
;
let
total_need
=
inputs
.
len
(
)
;
(
total_have
-
total_need
.
.
total_have
)
.
zip
(
0
.
.
total_need
)
.
map
(
|
(
h
n
)
|
{
let
name
=
format
!
(
"
{
}
sym
{
}
"
self
.
prefix
h
)
;
let
have_optional
=
h
<
optional
;
let
need_optional
=
n
<
inputs
.
len_optional
;
if
have_optional
&
&
!
need_optional
{
rust
!
(
self
.
out
"
let
{
}
=
{
}
.
take
(
)
.
unwrap
(
)
;
"
name
name
)
;
}
else
{
assert_eq
!
(
have_optional
need_optional
)
;
}
Ok
(
name
)
}
)
.
collect
(
)
}
fn
transition
(
&
mut
self
into_result
:
&
str
stack_suffix
:
StackSuffix
<
'
grammar
>
next_index
:
StateIndex
other_args
:
&
[
&
str
]
)
-
>
io
:
:
Result
<
bool
>
{
let
(
optional
mut
fixed
)
=
stack_suffix
.
optional_fixed_lens
(
)
;
fixed
+
=
1
;
let
total
=
optional
+
fixed
;
assert
!
(
total
=
=
stack_suffix
.
len
(
)
+
1
)
;
let
next_inputs
=
self
.
custom
.
state_inputs
[
next_index
.
0
]
;
assert
!
(
next_inputs
.
fixed
(
)
.
len
(
)
>
=
1
)
;
assert
!
(
next_inputs
.
len
(
)
<
=
total
)
;
let
transfer_syms
=
try
!
(
self
.
pop_syms
(
optional
fixed
next_inputs
)
)
;
let
other_args
=
other_args
.
iter
(
)
.
map
(
|
s
|
format
!
(
"
{
}
{
}
"
self
.
prefix
s
)
)
.
collect
(
)
;
let
fn_name
=
format
!
(
"
{
}
state
{
}
"
self
.
prefix
next_index
.
0
)
;
let
phantom_data_expr
=
self
.
phantom_data_expr
(
)
;
rust
!
(
self
.
out
"
{
}
{
}
=
try
!
(
{
}
(
{
}
{
}
{
}
{
}
)
)
;
"
self
.
prefix
into_result
fn_name
self
.
grammar
.
user_parameter_refs
(
)
Sep
(
"
"
&
other_args
)
Sep
(
"
"
&
transfer_syms
)
phantom_data_expr
)
;
if
next_inputs
.
fixed
(
)
.
len
(
)
>
=
2
{
rust
!
(
self
.
out
"
return
Ok
(
{
}
{
}
)
;
"
self
.
prefix
into_result
)
;
Ok
(
false
)
}
else
{
Ok
(
true
)
}
}
fn
emit_reduce_action
(
&
mut
self
into_var
:
&
str
stack_suffix
:
StackSuffix
<
'
grammar
>
production
:
&
'
grammar
Production
)
-
>
io
:
:
Result
<
(
)
>
{
let
loc_type
=
self
.
types
.
terminal_loc_type
(
)
;
let
(
optional
fixed
)
=
stack_suffix
.
optional_fixed_lens
(
)
;
let
production_inputs
=
StackSuffix
{
all
:
&
production
.
symbols
len_optional
:
0
}
;
let
transfer_syms
=
try
!
(
self
.
pop_syms
(
optional
fixed
production_inputs
)
)
;
if
let
Some
(
first_sym
)
=
transfer_syms
.
first
(
)
{
rust
!
(
self
.
out
"
let
{
}
start
=
{
}
.
0
.
clone
(
)
;
"
self
.
prefix
first_sym
)
;
}
else
if
stack_suffix
.
len
(
)
>
0
{
let
top
=
stack_suffix
.
len
(
)
-
1
;
if
!
stack_suffix
.
fixed
(
)
.
is_empty
(
)
{
rust
!
(
self
.
out
"
let
{
}
start
=
{
}
sym
{
}
.
2
.
clone
(
)
;
"
self
.
prefix
self
.
prefix
top
)
;
}
else
{
rust
!
(
self
.
out
"
let
{
}
start
=
{
}
sym
{
}
.
as_ref
(
)
.
unwrap
(
)
.
2
.
clone
(
)
;
"
self
.
prefix
self
.
prefix
top
)
;
}
}
else
{
rust
!
(
self
.
out
"
let
{
}
start
:
{
}
=
:
:
std
:
:
default
:
:
Default
:
:
default
(
)
;
"
self
.
prefix
loc_type
)
;
}
if
let
Some
(
last_sym
)
=
transfer_syms
.
last
(
)
{
rust
!
(
self
.
out
"
let
{
}
end
=
{
}
.
2
.
clone
(
)
;
"
self
.
prefix
last_sym
)
;
}
else
{
rust
!
(
self
.
out
"
let
{
}
end
=
{
}
lookahead
.
as_ref
(
)
.
map
(
|
o
|
o
.
0
.
clone
(
)
)
.
unwrap_or_else
(
|
|
\
{
}
start
.
clone
(
)
)
;
"
self
.
prefix
self
.
prefix
self
.
prefix
)
;
}
let
transfered_syms
=
transfer_syms
.
len
(
)
;
let
mut
args
=
transfer_syms
;
if
transfered_syms
=
=
0
{
args
.
push
(
format
!
(
"
&
{
}
start
"
self
.
prefix
)
)
;
args
.
push
(
format
!
(
"
&
{
}
end
"
self
.
prefix
)
)
;
}
let
is_fallible
=
self
.
grammar
.
action_is_fallible
(
production
.
action
)
;
if
is_fallible
{
rust
!
(
self
.
out
"
let
{
}
nt
=
try
!
(
{
}
:
:
{
}
action
{
}
:
:
<
{
}
>
(
{
}
{
}
)
)
;
"
self
.
prefix
self
.
action_module
self
.
prefix
production
.
action
.
index
(
)
Sep
(
"
"
&
self
.
grammar
.
non_lifetime_type_parameters
(
)
)
self
.
grammar
.
user_parameter_refs
(
)
Sep
(
"
"
&
args
)
)
}
else
{
rust
!
(
self
.
out
"
let
{
}
nt
=
{
}
:
:
{
}
action
{
}
:
:
<
{
}
>
(
{
}
{
}
)
;
"
self
.
prefix
self
.
action_module
self
.
prefix
production
.
action
.
index
(
)
Sep
(
"
"
&
self
.
grammar
.
non_lifetime_type_parameters
(
)
)
self
.
grammar
.
user_parameter_refs
(
)
Sep
(
"
"
&
args
)
)
}
rust
!
(
self
.
out
"
let
{
}
nt
=
{
}
Nonterminal
:
:
{
}
(
(
"
self
.
prefix
self
.
prefix
Escape
(
&
production
.
nonterminal
)
)
;
rust
!
(
self
.
out
"
{
}
start
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
{
}
nt
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
{
}
end
"
self
.
prefix
)
;
rust
!
(
self
.
out
"
)
)
;
"
)
;
rust
!
(
self
.
out
"
{
}
{
}
=
(
{
}
lookahead
{
}
nt
)
;
"
self
.
prefix
into_var
self
.
prefix
self
.
prefix
)
;
Ok
(
(
)
)
}
fn
match_terminal_pattern
(
&
mut
self
id
:
&
TerminalString
)
-
>
String
{
let
pattern
=
self
.
grammar
.
pattern
(
id
)
.
map
(
&
mut
|
_
|
"
_
"
)
;
let
pattern
=
format
!
(
"
{
}
"
pattern
)
;
format
!
(
"
(
_
{
}
_
)
"
pattern
)
}
fn
consume_terminal
(
&
mut
self
id
:
&
TerminalString
let_name
:
String
)
-
>
io
:
:
Result
<
(
)
>
{
let
mut
pattern_names
=
vec
!
[
]
;
let
pattern
=
self
.
grammar
.
pattern
(
id
)
.
map
(
&
mut
|
_
|
{
let
index
=
pattern_names
.
len
(
)
;
pattern_names
.
push
(
format
!
(
"
{
}
tok
{
}
"
self
.
prefix
index
)
)
;
pattern_names
.
last
(
)
.
cloned
(
)
.
unwrap
(
)
}
)
;
let
mut
pattern
=
format
!
(
"
{
}
"
pattern
)
;
if
pattern_names
.
is_empty
(
)
{
pattern_names
.
push
(
format
!
(
"
{
}
tok
"
self
.
prefix
)
)
;
pattern
=
format
!
(
"
{
}
tok
{
}
"
self
.
prefix
pattern
)
;
}
pattern
=
format
!
(
"
(
{
}
loc1
{
}
{
}
loc2
)
"
self
.
prefix
pattern
self
.
prefix
)
;
rust
!
(
self
.
out
"
Some
(
{
}
)
=
>
{
{
"
pattern
)
;
rust
!
(
self
.
out
"
let
{
}
=
(
{
}
loc1
(
{
}
)
{
}
loc2
)
;
"
let_name
self
.
prefix
pattern_names
.
join
(
"
"
)
self
.
prefix
)
;
Ok
(
(
)
)
}
fn
triple_type
(
&
self
)
-
>
TypeRepr
{
self
.
types
.
triple_type
(
)
}
fn
next_token
(
&
mut
self
lookahead
:
&
str
tokens
:
&
str
)
-
>
io
:
:
Result
<
(
)
>
{
rust
!
(
self
.
out
"
let
{
}
{
}
=
match
{
}
{
}
.
next
(
)
{
{
"
self
.
prefix
lookahead
self
.
prefix
tokens
)
;
rust
!
(
self
.
out
"
Some
(
Ok
(
v
)
)
=
>
Some
(
v
)
"
)
;
rust
!
(
self
.
out
"
None
=
>
None
"
)
;
if
self
.
grammar
.
intern_token
.
is_some
(
)
{
rust
!
(
self
.
out
"
Some
(
Err
(
e
)
)
=
>
return
Err
(
e
)
"
)
;
}
else
{
rust
!
(
self
.
out
"
Some
(
Err
(
e
)
)
=
>
return
Err
(
{
}
lalrpop_util
:
:
ParseError
:
:
User
{
{
error
:
e
}
}
)
"
self
.
prefix
)
;
}
rust
!
(
self
.
out
"
}
}
;
"
)
;
Ok
(
(
)
)
}
}
