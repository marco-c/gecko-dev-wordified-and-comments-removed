#
include
<
stdlib
.
h
>
#
ifndef
assert
#
include
<
assert
.
h
>
#
endif
#
include
<
limits
.
h
>
#
include
<
errno
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sched
.
h
>
#
include
<
stdint
.
h
>
#
if
!
defined
(
__CYGWIN__
)
&
&
!
defined
(
__APPLE__
)
&
&
!
defined
(
__NetBSD__
)
#
define
EMULATED_THREADS_USE_NATIVE_TIMEDLOCK
#
endif
#
include
<
pthread
.
h
>
#
define
ONCE_FLAG_INIT
PTHREAD_ONCE_INIT
#
ifdef
INIT_ONCE_STATIC_INIT
#
define
TSS_DTOR_ITERATIONS
PTHREAD_DESTRUCTOR_ITERATIONS
#
else
#
define
TSS_DTOR_ITERATIONS
1
/
/
assume
TSS
dtor
MAY
be
called
at
least
once
.
#
endif
#
define
_MTX_INITIALIZER_NP
PTHREAD_MUTEX_INITIALIZER
typedef
pthread_cond_t
cnd_t
;
typedef
pthread_t
thrd_t
;
typedef
pthread_key_t
tss_t
;
typedef
pthread_mutex_t
mtx_t
;
typedef
pthread_once_t
once_flag
;
struct
impl_thrd_param
{
thrd_start_t
func
;
void
*
arg
;
}
;
static
inline
void
*
impl_thrd_routine
(
void
*
p
)
{
struct
impl_thrd_param
pack
=
*
(
(
struct
impl_thrd_param
*
)
p
)
;
free
(
p
)
;
return
(
void
*
)
(
intptr_t
)
pack
.
func
(
pack
.
arg
)
;
}
static
inline
void
call_once
(
once_flag
*
flag
void
(
*
func
)
(
void
)
)
{
pthread_once
(
flag
func
)
;
}
static
inline
int
cnd_broadcast
(
cnd_t
*
cond
)
{
assert
(
cond
!
=
NULL
)
;
return
(
pthread_cond_broadcast
(
cond
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
void
cnd_destroy
(
cnd_t
*
cond
)
{
assert
(
cond
)
;
pthread_cond_destroy
(
cond
)
;
}
static
inline
int
cnd_init
(
cnd_t
*
cond
)
{
assert
(
cond
!
=
NULL
)
;
return
(
pthread_cond_init
(
cond
NULL
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
int
cnd_signal
(
cnd_t
*
cond
)
{
assert
(
cond
!
=
NULL
)
;
return
(
pthread_cond_signal
(
cond
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
int
cnd_timedwait
(
cnd_t
*
cond
mtx_t
*
mtx
const
struct
timespec
*
abs_time
)
{
int
rt
;
assert
(
mtx
!
=
NULL
)
;
assert
(
cond
!
=
NULL
)
;
assert
(
abs_time
!
=
NULL
)
;
rt
=
pthread_cond_timedwait
(
cond
mtx
abs_time
)
;
if
(
rt
=
=
ETIMEDOUT
)
return
thrd_busy
;
return
(
rt
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
int
cnd_wait
(
cnd_t
*
cond
mtx_t
*
mtx
)
{
assert
(
mtx
!
=
NULL
)
;
assert
(
cond
!
=
NULL
)
;
return
(
pthread_cond_wait
(
cond
mtx
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
void
mtx_destroy
(
mtx_t
*
mtx
)
{
assert
(
mtx
!
=
NULL
)
;
pthread_mutex_destroy
(
mtx
)
;
}
#
if
defined
(
HAVE_FUNC_ATTRIBUTE_WEAK
)
&
&
!
defined
(
__CYGWIN__
)
__attribute__
(
(
weak
)
)
int
pthread_mutexattr_init
(
pthread_mutexattr_t
*
attr
)
;
__attribute__
(
(
weak
)
)
int
pthread_mutexattr_settype
(
pthread_mutexattr_t
*
attr
int
type
)
;
__attribute__
(
(
weak
)
)
int
pthread_mutexattr_destroy
(
pthread_mutexattr_t
*
attr
)
;
#
endif
static
inline
int
mtx_init
(
mtx_t
*
mtx
int
type
)
{
pthread_mutexattr_t
attr
;
assert
(
mtx
!
=
NULL
)
;
if
(
type
!
=
mtx_plain
&
&
type
!
=
mtx_timed
&
&
type
!
=
mtx_try
&
&
type
!
=
(
mtx_plain
|
mtx_recursive
)
&
&
type
!
=
(
mtx_timed
|
mtx_recursive
)
&
&
type
!
=
(
mtx_try
|
mtx_recursive
)
)
return
thrd_error
;
if
(
(
type
&
mtx_recursive
)
=
=
0
)
{
pthread_mutex_init
(
mtx
NULL
)
;
return
thrd_success
;
}
pthread_mutexattr_init
(
&
attr
)
;
pthread_mutexattr_settype
(
&
attr
PTHREAD_MUTEX_RECURSIVE
)
;
pthread_mutex_init
(
mtx
&
attr
)
;
pthread_mutexattr_destroy
(
&
attr
)
;
return
thrd_success
;
}
static
inline
int
mtx_lock
(
mtx_t
*
mtx
)
{
assert
(
mtx
!
=
NULL
)
;
return
(
pthread_mutex_lock
(
mtx
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
int
mtx_trylock
(
mtx_t
*
mtx
)
;
static
inline
void
thrd_yield
(
void
)
;
static
inline
int
mtx_timedlock
(
mtx_t
*
mtx
const
struct
timespec
*
ts
)
{
assert
(
mtx
!
=
NULL
)
;
assert
(
ts
!
=
NULL
)
;
{
#
ifdef
EMULATED_THREADS_USE_NATIVE_TIMEDLOCK
int
rt
;
rt
=
pthread_mutex_timedlock
(
mtx
ts
)
;
if
(
rt
=
=
0
)
return
thrd_success
;
return
(
rt
=
=
ETIMEDOUT
)
?
thrd_busy
:
thrd_error
;
#
else
time_t
expire
=
time
(
NULL
)
;
expire
+
=
ts
-
>
tv_sec
;
while
(
mtx_trylock
(
mtx
)
!
=
thrd_success
)
{
time_t
now
=
time
(
NULL
)
;
if
(
expire
<
now
)
return
thrd_busy
;
thrd_yield
(
)
;
}
return
thrd_success
;
#
endif
}
}
static
inline
int
mtx_trylock
(
mtx_t
*
mtx
)
{
assert
(
mtx
!
=
NULL
)
;
return
(
pthread_mutex_trylock
(
mtx
)
=
=
0
)
?
thrd_success
:
thrd_busy
;
}
static
inline
int
mtx_unlock
(
mtx_t
*
mtx
)
{
assert
(
mtx
!
=
NULL
)
;
return
(
pthread_mutex_unlock
(
mtx
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
int
thrd_create
(
thrd_t
*
thr
thrd_start_t
func
void
*
arg
)
{
struct
impl_thrd_param
*
pack
;
assert
(
thr
!
=
NULL
)
;
pack
=
(
struct
impl_thrd_param
*
)
malloc
(
sizeof
(
struct
impl_thrd_param
)
)
;
if
(
!
pack
)
return
thrd_nomem
;
pack
-
>
func
=
func
;
pack
-
>
arg
=
arg
;
if
(
pthread_create
(
thr
NULL
impl_thrd_routine
pack
)
!
=
0
)
{
free
(
pack
)
;
return
thrd_error
;
}
return
thrd_success
;
}
static
inline
thrd_t
thrd_current
(
void
)
{
return
pthread_self
(
)
;
}
static
inline
int
thrd_detach
(
thrd_t
thr
)
{
return
(
pthread_detach
(
thr
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
int
thrd_equal
(
thrd_t
thr0
thrd_t
thr1
)
{
return
pthread_equal
(
thr0
thr1
)
;
}
static
inline
void
thrd_exit
(
int
res
)
{
pthread_exit
(
(
void
*
)
(
intptr_t
)
res
)
;
}
static
inline
int
thrd_join
(
thrd_t
thr
int
*
res
)
{
void
*
code
;
if
(
pthread_join
(
thr
&
code
)
!
=
0
)
return
thrd_error
;
if
(
res
)
*
res
=
(
int
)
(
intptr_t
)
code
;
return
thrd_success
;
}
static
inline
void
thrd_sleep
(
const
struct
timespec
*
time_point
struct
timespec
*
remaining
)
{
assert
(
time_point
!
=
NULL
)
;
nanosleep
(
time_point
remaining
)
;
}
static
inline
void
thrd_yield
(
void
)
{
sched_yield
(
)
;
}
static
inline
int
tss_create
(
tss_t
*
key
tss_dtor_t
dtor
)
{
assert
(
key
!
=
NULL
)
;
return
(
pthread_key_create
(
key
dtor
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
static
inline
void
tss_delete
(
tss_t
key
)
{
pthread_key_delete
(
key
)
;
}
static
inline
void
*
tss_get
(
tss_t
key
)
{
return
pthread_getspecific
(
key
)
;
}
static
inline
int
tss_set
(
tss_t
key
void
*
val
)
{
return
(
pthread_setspecific
(
key
val
)
=
=
0
)
?
thrd_success
:
thrd_error
;
}
#
ifndef
HAVE_TIMESPEC_GET
static
inline
int
timespec_get
(
struct
timespec
*
ts
int
base
)
{
if
(
!
ts
)
return
0
;
if
(
base
=
=
TIME_UTC
)
{
clock_gettime
(
CLOCK_REALTIME
ts
)
;
return
base
;
}
return
0
;
}
#
endif
