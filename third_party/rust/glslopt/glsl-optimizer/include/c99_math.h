#
ifndef
_C99_MATH_H_
#
define
_C99_MATH_H_
#
include
<
math
.
h
>
#
include
"
c99_compat
.
h
"
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
_USE_MATH_DEFINES
)
#
error
_USE_MATH_DEFINES
define
required
when
building
with
MSVC
#
endif
#
if
!
defined
(
_MSC_VER
)
&
&
\
__STDC_VERSION__
<
199901L
&
&
\
(
!
defined
(
_XOPEN_SOURCE
)
|
|
_XOPEN_SOURCE
<
600
)
&
&
\
!
defined
(
__cplusplus
)
static
inline
long
int
lrint
(
double
d
)
{
long
int
rounded
=
(
long
int
)
(
d
+
0
.
5
)
;
if
(
d
-
floor
(
d
)
=
=
0
.
5
)
{
if
(
rounded
%
2
!
=
0
)
rounded
+
=
(
d
>
0
)
?
-
1
:
1
;
}
return
rounded
;
}
static
inline
long
int
lrintf
(
float
f
)
{
long
int
rounded
=
(
long
int
)
(
f
+
0
.
5f
)
;
if
(
f
-
floorf
(
f
)
=
=
0
.
5f
)
{
if
(
rounded
%
2
!
=
0
)
rounded
+
=
(
f
>
0
)
?
-
1
:
1
;
}
return
rounded
;
}
static
inline
long
long
int
llrint
(
double
d
)
{
long
long
int
rounded
=
(
long
long
int
)
(
d
+
0
.
5
)
;
if
(
d
-
floor
(
d
)
=
=
0
.
5
)
{
if
(
rounded
%
2
!
=
0
)
rounded
+
=
(
d
>
0
)
?
-
1
:
1
;
}
return
rounded
;
}
static
inline
long
long
int
llrintf
(
float
f
)
{
long
long
int
rounded
=
(
long
long
int
)
(
f
+
0
.
5f
)
;
if
(
f
-
floorf
(
f
)
=
=
0
.
5f
)
{
if
(
rounded
%
2
!
=
0
)
rounded
+
=
(
f
>
0
)
?
-
1
:
1
;
}
return
rounded
;
}
static
inline
float
exp2f
(
float
f
)
{
return
powf
(
2
.
0f
f
)
;
}
static
inline
double
exp2
(
double
d
)
{
return
pow
(
2
.
0
d
)
;
}
#
endif
#
ifndef
signbit
#
define
signbit
(
x
)
(
(
x
)
<
0
.
0f
)
#
endif
#
ifndef
M_PI
#
define
M_PI
(
3
.
14159265358979323846
)
#
endif
#
ifndef
M_E
#
define
M_E
(
2
.
7182818284590452354
)
#
endif
#
ifndef
M_LOG2E
#
define
M_LOG2E
(
1
.
4426950408889634074
)
#
endif
#
ifndef
FLT_MAX_EXP
#
define
FLT_MAX_EXP
128
#
endif
#
if
defined
(
fpclassify
)
#
elif
defined
(
__cplusplus
)
#
elif
defined
(
_MSC_VER
)
#
include
<
float
.
h
>
static
inline
enum
{
FP_NAN
FP_INFINITE
FP_ZERO
FP_SUBNORMAL
FP_NORMAL
}
fpclassify
(
double
x
)
{
switch
(
_fpclass
(
x
)
)
{
case
_FPCLASS_SNAN
:
case
_FPCLASS_QNAN
:
return
FP_NAN
;
case
_FPCLASS_NINF
:
case
_FPCLASS_PINF
:
return
FP_INFINITE
;
case
_FPCLASS_NN
:
case
_FPCLASS_PN
:
return
FP_NORMAL
;
case
_FPCLASS_ND
:
case
_FPCLASS_PD
:
return
FP_SUBNORMAL
;
case
_FPCLASS_NZ
:
case
_FPCLASS_PZ
:
return
FP_ZERO
;
default
:
return
FP_NAN
;
}
}
#
else
#
error
"
Need
to
include
or
define
an
fpclassify
function
"
#
endif
#
if
__cplusplus
>
=
201103L
&
&
(
__GLIBC__
>
2
|
|
(
__GLIBC__
=
=
2
&
&
__GLIBC_MINOR__
>
=
23
)
)
#
include
<
cmath
>
using
std
:
:
fpclassify
;
using
std
:
:
isfinite
;
using
std
:
:
isinf
;
using
std
:
:
isnan
;
using
std
:
:
isnormal
;
using
std
:
:
signbit
;
using
std
:
:
isgreater
;
using
std
:
:
isgreaterequal
;
using
std
:
:
isless
;
using
std
:
:
islessequal
;
using
std
:
:
islessgreater
;
using
std
:
:
isunordered
;
#
endif
#
endif
