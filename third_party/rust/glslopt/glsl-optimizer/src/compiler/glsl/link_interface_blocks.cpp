#
include
"
ir
.
h
"
#
include
"
glsl_symbol_table
.
h
"
#
include
"
linker
.
h
"
#
include
"
main
/
macros
.
h
"
#
include
"
main
/
mtypes
.
h
"
#
include
"
util
/
hash_table
.
h
"
#
include
"
util
/
u_string
.
h
"
namespace
{
static
bool
interstage_member_mismatch
(
struct
gl_shader_program
*
prog
const
glsl_type
*
c
const
glsl_type
*
p
)
{
if
(
c
-
>
length
!
=
p
-
>
length
)
return
true
;
for
(
unsigned
i
=
0
;
i
<
c
-
>
length
;
i
+
+
)
{
if
(
c
-
>
fields
.
structure
[
i
]
.
type
!
=
p
-
>
fields
.
structure
[
i
]
.
type
)
return
true
;
if
(
strcmp
(
c
-
>
fields
.
structure
[
i
]
.
name
p
-
>
fields
.
structure
[
i
]
.
name
)
!
=
0
)
return
true
;
if
(
c
-
>
fields
.
structure
[
i
]
.
location
!
=
p
-
>
fields
.
structure
[
i
]
.
location
)
return
true
;
if
(
c
-
>
fields
.
structure
[
i
]
.
patch
!
=
p
-
>
fields
.
structure
[
i
]
.
patch
)
return
true
;
if
(
prog
-
>
IsES
|
|
prog
-
>
data
-
>
Version
<
440
)
if
(
c
-
>
fields
.
structure
[
i
]
.
interpolation
!
=
p
-
>
fields
.
structure
[
i
]
.
interpolation
)
return
true
;
if
(
!
prog
-
>
IsES
|
|
prog
-
>
data
-
>
Version
<
310
)
if
(
c
-
>
fields
.
structure
[
i
]
.
centroid
!
=
p
-
>
fields
.
structure
[
i
]
.
centroid
)
return
true
;
if
(
!
prog
-
>
IsES
)
if
(
c
-
>
fields
.
structure
[
i
]
.
sample
!
=
p
-
>
fields
.
structure
[
i
]
.
sample
)
return
true
;
}
return
false
;
}
bool
intrastage_match
(
ir_variable
*
a
ir_variable
*
b
struct
gl_shader_program
*
prog
bool
match_precision
)
{
if
(
a
-
>
get_interface_type
(
)
!
=
b
-
>
get_interface_type
(
)
)
{
if
(
(
a
-
>
data
.
how_declared
!
=
ir_var_declared_implicitly
|
|
b
-
>
data
.
how_declared
!
=
ir_var_declared_implicitly
)
&
&
(
!
prog
-
>
IsES
|
|
interstage_member_mismatch
(
prog
a
-
>
get_interface_type
(
)
b
-
>
get_interface_type
(
)
)
)
)
return
false
;
}
if
(
a
-
>
is_interface_instance
(
)
!
=
b
-
>
is_interface_instance
(
)
)
return
false
;
if
(
a
-
>
is_interface_instance
(
)
&
&
b
-
>
data
.
mode
!
=
ir_var_uniform
&
&
b
-
>
data
.
mode
!
=
ir_var_shader_storage
&
&
strcmp
(
a
-
>
name
b
-
>
name
)
!
=
0
)
{
return
false
;
}
bool
type_match
=
(
match_precision
?
a
-
>
type
=
=
b
-
>
type
:
a
-
>
type
-
>
compare_no_precision
(
b
-
>
type
)
)
;
if
(
!
type_match
&
&
(
b
-
>
type
-
>
is_array
(
)
|
|
a
-
>
type
-
>
is_array
(
)
)
&
&
(
b
-
>
is_interface_instance
(
)
|
|
a
-
>
is_interface_instance
(
)
)
&
&
!
validate_intrastage_arrays
(
prog
b
a
match_precision
)
)
return
false
;
return
true
;
}
static
bool
interstage_match
(
struct
gl_shader_program
*
prog
ir_variable
*
producer
ir_variable
*
consumer
bool
extra_array_level
)
{
if
(
consumer
-
>
get_interface_type
(
)
!
=
producer
-
>
get_interface_type
(
)
)
{
if
(
(
consumer
-
>
data
.
how_declared
!
=
ir_var_declared_implicitly
|
|
producer
-
>
data
.
how_declared
!
=
ir_var_declared_implicitly
)
&
&
interstage_member_mismatch
(
prog
consumer
-
>
get_interface_type
(
)
producer
-
>
get_interface_type
(
)
)
)
return
false
;
}
const
glsl_type
*
consumer_instance_type
;
if
(
extra_array_level
)
{
consumer_instance_type
=
consumer
-
>
type
-
>
fields
.
array
;
}
else
{
consumer_instance_type
=
consumer
-
>
type
;
}
if
(
(
consumer
-
>
is_interface_instance
(
)
&
&
consumer_instance_type
-
>
is_array
(
)
)
|
|
(
producer
-
>
is_interface_instance
(
)
&
&
producer
-
>
type
-
>
is_array
(
)
)
)
{
if
(
consumer_instance_type
!
=
producer
-
>
type
)
return
false
;
}
return
true
;
}
class
interface_block_definitions
{
public
:
interface_block_definitions
(
)
:
mem_ctx
(
ralloc_context
(
NULL
)
)
ht
(
_mesa_hash_table_create
(
NULL
_mesa_hash_string
_mesa_key_string_equal
)
)
{
}
~
interface_block_definitions
(
)
{
ralloc_free
(
mem_ctx
)
;
_mesa_hash_table_destroy
(
ht
NULL
)
;
}
ir_variable
*
lookup
(
ir_variable
*
var
)
{
if
(
var
-
>
data
.
explicit_location
&
&
var
-
>
data
.
location
>
=
VARYING_SLOT_VAR0
)
{
char
location_str
[
11
]
;
snprintf
(
location_str
11
"
%
d
"
var
-
>
data
.
location
)
;
const
struct
hash_entry
*
entry
=
_mesa_hash_table_search
(
ht
location_str
)
;
return
entry
?
(
ir_variable
*
)
entry
-
>
data
:
NULL
;
}
else
{
const
struct
hash_entry
*
entry
=
_mesa_hash_table_search
(
ht
var
-
>
get_interface_type
(
)
-
>
without_array
(
)
-
>
name
)
;
return
entry
?
(
ir_variable
*
)
entry
-
>
data
:
NULL
;
}
}
void
store
(
ir_variable
*
var
)
{
if
(
var
-
>
data
.
explicit_location
&
&
var
-
>
data
.
location
>
=
VARYING_SLOT_VAR0
)
{
char
location_str
[
11
]
;
snprintf
(
location_str
11
"
%
d
"
var
-
>
data
.
location
)
;
_mesa_hash_table_insert
(
ht
ralloc_strdup
(
mem_ctx
location_str
)
var
)
;
}
else
{
_mesa_hash_table_insert
(
ht
var
-
>
get_interface_type
(
)
-
>
without_array
(
)
-
>
name
var
)
;
}
}
private
:
void
*
mem_ctx
;
hash_table
*
ht
;
}
;
}
;
void
validate_intrastage_interface_blocks
(
struct
gl_shader_program
*
prog
const
gl_shader
*
*
shader_list
unsigned
num_shaders
)
{
interface_block_definitions
in_interfaces
;
interface_block_definitions
out_interfaces
;
interface_block_definitions
uniform_interfaces
;
interface_block_definitions
buffer_interfaces
;
for
(
unsigned
int
i
=
0
;
i
<
num_shaders
;
i
+
+
)
{
if
(
shader_list
[
i
]
=
=
NULL
)
continue
;
foreach_in_list
(
ir_instruction
node
shader_list
[
i
]
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
)
continue
;
const
glsl_type
*
iface_type
=
var
-
>
get_interface_type
(
)
;
if
(
iface_type
=
=
NULL
)
continue
;
interface_block_definitions
*
definitions
;
switch
(
var
-
>
data
.
mode
)
{
case
ir_var_shader_in
:
definitions
=
&
in_interfaces
;
break
;
case
ir_var_shader_out
:
definitions
=
&
out_interfaces
;
break
;
case
ir_var_uniform
:
definitions
=
&
uniform_interfaces
;
break
;
case
ir_var_shader_storage
:
definitions
=
&
buffer_interfaces
;
break
;
default
:
assert
(
!
"
illegal
interface
type
"
)
;
continue
;
}
ir_variable
*
prev_def
=
definitions
-
>
lookup
(
var
)
;
if
(
prev_def
=
=
NULL
)
{
definitions
-
>
store
(
var
)
;
}
else
if
(
!
intrastage_match
(
prev_def
var
prog
true
)
)
{
linker_error
(
prog
"
definitions
of
interface
block
%
s
'
do
not
"
"
match
\
n
"
iface_type
-
>
name
)
;
return
;
}
}
}
}
static
bool
is_builtin_gl_in_block
(
ir_variable
*
var
int
consumer_stage
)
{
return
!
strcmp
(
var
-
>
name
"
gl_in
"
)
&
&
(
consumer_stage
=
=
MESA_SHADER_TESS_CTRL
|
|
consumer_stage
=
=
MESA_SHADER_TESS_EVAL
|
|
consumer_stage
=
=
MESA_SHADER_GEOMETRY
)
;
}
void
validate_interstage_inout_blocks
(
struct
gl_shader_program
*
prog
const
gl_linked_shader
*
producer
const
gl_linked_shader
*
consumer
)
{
interface_block_definitions
definitions
;
const
bool
extra_array_level
=
(
producer
-
>
Stage
=
=
MESA_SHADER_VERTEX
&
&
consumer
-
>
Stage
!
=
MESA_SHADER_FRAGMENT
)
|
|
consumer
-
>
Stage
=
=
MESA_SHADER_GEOMETRY
;
const
glsl_type
*
consumer_iface
=
consumer
-
>
symbols
-
>
get_interface
(
"
gl_PerVertex
"
ir_var_shader_in
)
;
const
glsl_type
*
producer_iface
=
producer
-
>
symbols
-
>
get_interface
(
"
gl_PerVertex
"
ir_var_shader_out
)
;
if
(
producer_iface
&
&
consumer_iface
&
&
interstage_member_mismatch
(
prog
consumer_iface
producer_iface
)
)
{
linker_error
(
prog
"
Incompatible
or
missing
gl_PerVertex
re
-
declaration
"
"
in
consecutive
shaders
"
)
;
return
;
}
foreach_in_list
(
ir_instruction
node
producer
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
|
|
!
var
-
>
get_interface_type
(
)
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_out
)
continue
;
if
(
prog
-
>
SeparateShader
&
&
!
prog
-
>
IsES
&
&
prog
-
>
data
-
>
Version
>
=
150
&
&
var
-
>
data
.
how_declared
=
=
ir_var_declared_implicitly
&
&
var
-
>
data
.
used
&
&
!
producer_iface
)
{
linker_error
(
prog
"
missing
output
builtin
block
%
s
redeclaration
"
"
in
separable
shader
program
"
var
-
>
get_interface_type
(
)
-
>
name
)
;
return
;
}
definitions
.
store
(
var
)
;
}
foreach_in_list
(
ir_instruction
node
consumer
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
|
|
!
var
-
>
get_interface_type
(
)
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_in
)
continue
;
ir_variable
*
producer_def
=
definitions
.
lookup
(
var
)
;
if
(
prog
-
>
SeparateShader
&
&
!
prog
-
>
IsES
&
&
prog
-
>
data
-
>
Version
>
=
150
&
&
var
-
>
data
.
how_declared
=
=
ir_var_declared_implicitly
&
&
var
-
>
data
.
used
&
&
!
producer_iface
)
{
linker_error
(
prog
"
missing
input
builtin
block
%
s
redeclaration
"
"
in
separable
shader
program
"
var
-
>
get_interface_type
(
)
-
>
name
)
;
return
;
}
if
(
producer_def
=
=
NULL
&
&
!
is_builtin_gl_in_block
(
var
consumer
-
>
Stage
)
&
&
var
-
>
data
.
used
)
{
linker_error
(
prog
"
Input
block
%
s
'
is
not
an
output
of
"
"
the
previous
stage
\
n
"
var
-
>
get_interface_type
(
)
-
>
name
)
;
return
;
}
if
(
producer_def
&
&
!
interstage_match
(
prog
producer_def
var
extra_array_level
)
)
{
linker_error
(
prog
"
definitions
of
interface
block
%
s
'
do
not
"
"
match
\
n
"
var
-
>
get_interface_type
(
)
-
>
name
)
;
return
;
}
}
}
void
validate_interstage_uniform_blocks
(
struct
gl_shader_program
*
prog
gl_linked_shader
*
*
stages
)
{
interface_block_definitions
definitions
;
for
(
int
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
{
if
(
stages
[
i
]
=
=
NULL
)
continue
;
const
gl_linked_shader
*
stage
=
stages
[
i
]
;
foreach_in_list
(
ir_instruction
node
stage
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
|
|
!
var
-
>
get_interface_type
(
)
|
|
(
var
-
>
data
.
mode
!
=
ir_var_uniform
&
&
var
-
>
data
.
mode
!
=
ir_var_shader_storage
)
)
continue
;
ir_variable
*
old_def
=
definitions
.
lookup
(
var
)
;
if
(
old_def
=
=
NULL
)
{
definitions
.
store
(
var
)
;
}
else
{
if
(
!
intrastage_match
(
old_def
var
prog
false
)
)
{
linker_error
(
prog
"
definitions
of
uniform
block
%
s
'
do
not
"
"
match
\
n
"
var
-
>
get_interface_type
(
)
-
>
name
)
;
return
;
}
}
}
}
}
