#
include
"
main
/
errors
.
h
"
#
include
"
main
/
mtypes
.
h
"
#
include
"
glsl_symbol_table
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
ir_optimization
.
h
"
#
include
"
linker
.
h
"
#
include
"
link_varyings
.
h
"
#
include
"
main
/
macros
.
h
"
#
include
"
util
/
hash_table
.
h
"
#
include
"
util
/
u_math
.
h
"
#
include
"
program
.
h
"
static
const
glsl_type
*
get_varying_type
(
const
ir_variable
*
var
gl_shader_stage
stage
)
{
const
glsl_type
*
type
=
var
-
>
type
;
if
(
!
var
-
>
data
.
patch
&
&
(
(
var
-
>
data
.
mode
=
=
ir_var_shader_out
&
&
stage
=
=
MESA_SHADER_TESS_CTRL
)
|
|
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
(
stage
=
=
MESA_SHADER_TESS_CTRL
|
|
stage
=
=
MESA_SHADER_TESS_EVAL
|
|
stage
=
=
MESA_SHADER_GEOMETRY
)
)
)
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
return
type
;
}
static
void
create_xfb_varying_names
(
void
*
mem_ctx
const
glsl_type
*
t
char
*
*
name
size_t
name_length
unsigned
*
count
const
char
*
ifc_member_name
const
glsl_type
*
ifc_member_t
char
*
*
*
varying_names
)
{
if
(
t
-
>
is_interface
(
)
)
{
size_t
new_length
=
name_length
;
assert
(
ifc_member_name
&
&
ifc_member_t
)
;
ralloc_asprintf_rewrite_tail
(
name
&
new_length
"
.
%
s
"
ifc_member_name
)
;
create_xfb_varying_names
(
mem_ctx
ifc_member_t
name
new_length
count
NULL
NULL
varying_names
)
;
}
else
if
(
t
-
>
is_struct
(
)
)
{
for
(
unsigned
i
=
0
;
i
<
t
-
>
length
;
i
+
+
)
{
const
char
*
field
=
t
-
>
fields
.
structure
[
i
]
.
name
;
size_t
new_length
=
name_length
;
ralloc_asprintf_rewrite_tail
(
name
&
new_length
"
.
%
s
"
field
)
;
create_xfb_varying_names
(
mem_ctx
t
-
>
fields
.
structure
[
i
]
.
type
name
new_length
count
NULL
NULL
varying_names
)
;
}
}
else
if
(
t
-
>
without_array
(
)
-
>
is_struct
(
)
|
|
t
-
>
without_array
(
)
-
>
is_interface
(
)
|
|
(
t
-
>
is_array
(
)
&
&
t
-
>
fields
.
array
-
>
is_array
(
)
)
)
{
for
(
unsigned
i
=
0
;
i
<
t
-
>
length
;
i
+
+
)
{
size_t
new_length
=
name_length
;
ralloc_asprintf_rewrite_tail
(
name
&
new_length
"
[
%
u
]
"
i
)
;
create_xfb_varying_names
(
mem_ctx
t
-
>
fields
.
array
name
new_length
count
ifc_member_name
ifc_member_t
varying_names
)
;
}
}
else
{
(
*
varying_names
)
[
(
*
count
)
+
+
]
=
ralloc_strdup
(
mem_ctx
*
name
)
;
}
}
static
bool
process_xfb_layout_qualifiers
(
void
*
mem_ctx
const
gl_linked_shader
*
sh
struct
gl_shader_program
*
prog
unsigned
*
num_tfeedback_decls
char
*
*
*
varying_names
)
{
bool
has_xfb_qualifiers
=
false
;
for
(
unsigned
j
=
0
;
j
<
MAX_FEEDBACK_BUFFERS
;
j
+
+
)
{
if
(
prog
-
>
TransformFeedback
.
BufferStride
[
j
]
)
{
has_xfb_qualifiers
=
true
;
break
;
}
}
foreach_in_list
(
ir_instruction
node
sh
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_out
)
continue
;
if
(
var
-
>
data
.
explicit_xfb_buffer
|
|
var
-
>
data
.
explicit_xfb_stride
)
{
has_xfb_qualifiers
=
true
;
}
if
(
var
-
>
data
.
explicit_xfb_offset
)
{
*
num_tfeedback_decls
+
=
var
-
>
type
-
>
varying_count
(
)
;
has_xfb_qualifiers
=
true
;
}
}
if
(
*
num_tfeedback_decls
=
=
0
)
return
has_xfb_qualifiers
;
unsigned
i
=
0
;
*
varying_names
=
ralloc_array
(
mem_ctx
char
*
*
num_tfeedback_decls
)
;
foreach_in_list
(
ir_instruction
node
sh
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_out
)
continue
;
if
(
var
-
>
data
.
explicit_xfb_offset
)
{
char
*
name
;
const
glsl_type
*
type
*
member_type
;
if
(
var
-
>
data
.
from_named_ifc_block
)
{
type
=
var
-
>
get_interface_type
(
)
;
const
glsl_type
*
type_wa
=
type
-
>
without_array
(
)
;
member_type
=
type_wa
-
>
fields
.
structure
[
type_wa
-
>
field_index
(
var
-
>
name
)
]
.
type
;
name
=
ralloc_strdup
(
NULL
type_wa
-
>
name
)
;
}
else
{
type
=
var
-
>
type
;
member_type
=
NULL
;
name
=
ralloc_strdup
(
NULL
var
-
>
name
)
;
}
create_xfb_varying_names
(
mem_ctx
type
&
name
strlen
(
name
)
&
i
var
-
>
name
member_type
varying_names
)
;
ralloc_free
(
name
)
;
}
}
assert
(
i
=
=
*
num_tfeedback_decls
)
;
return
has_xfb_qualifiers
;
}
static
void
cross_validate_types_and_qualifiers
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
const
ir_variable
*
input
const
ir_variable
*
output
gl_shader_stage
consumer_stage
gl_shader_stage
producer_stage
)
{
const
glsl_type
*
type_to_match
=
input
-
>
type
;
const
bool
extra_array_level
=
(
producer_stage
=
=
MESA_SHADER_VERTEX
&
&
consumer_stage
!
=
MESA_SHADER_FRAGMENT
)
|
|
consumer_stage
=
=
MESA_SHADER_GEOMETRY
;
if
(
extra_array_level
)
{
assert
(
type_to_match
-
>
is_array
(
)
)
;
type_to_match
=
type_to_match
-
>
fields
.
array
;
}
if
(
type_to_match
!
=
output
-
>
type
)
{
if
(
output
-
>
type
-
>
is_struct
(
)
)
{
if
(
!
output
-
>
type
-
>
record_compare
(
type_to_match
false
true
false
)
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
declared
as
struct
%
s
'
"
"
doesn
'
t
match
in
type
with
%
s
shader
input
"
"
declared
as
struct
%
s
'
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
output
-
>
type
-
>
name
_mesa_shader_stage_to_string
(
consumer_stage
)
input
-
>
type
-
>
name
)
;
}
}
else
if
(
!
output
-
>
type
-
>
is_array
(
)
|
|
!
is_gl_identifier
(
output
-
>
name
)
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
declared
as
type
%
s
'
"
"
but
%
s
shader
input
declared
as
type
%
s
'
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
output
-
>
type
-
>
name
_mesa_shader_stage_to_string
(
consumer_stage
)
input
-
>
type
-
>
name
)
;
return
;
}
}
if
(
false
&
&
prog
-
>
data
-
>
Version
<
(
prog
-
>
IsES
?
310
:
430
)
&
&
input
-
>
data
.
centroid
!
=
output
-
>
data
.
centroid
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
%
s
centroid
qualifier
"
"
but
%
s
shader
input
%
s
centroid
qualifier
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
(
output
-
>
data
.
centroid
)
?
"
has
"
:
"
lacks
"
_mesa_shader_stage_to_string
(
consumer_stage
)
(
input
-
>
data
.
centroid
)
?
"
has
"
:
"
lacks
"
)
;
return
;
}
if
(
input
-
>
data
.
sample
!
=
output
-
>
data
.
sample
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
%
s
sample
qualifier
"
"
but
%
s
shader
input
%
s
sample
qualifier
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
(
output
-
>
data
.
sample
)
?
"
has
"
:
"
lacks
"
_mesa_shader_stage_to_string
(
consumer_stage
)
(
input
-
>
data
.
sample
)
?
"
has
"
:
"
lacks
"
)
;
return
;
}
if
(
input
-
>
data
.
patch
!
=
output
-
>
data
.
patch
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
%
s
patch
qualifier
"
"
but
%
s
shader
input
%
s
patch
qualifier
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
(
output
-
>
data
.
patch
)
?
"
has
"
:
"
lacks
"
_mesa_shader_stage_to_string
(
consumer_stage
)
(
input
-
>
data
.
patch
)
?
"
has
"
:
"
lacks
"
)
;
return
;
}
if
(
input
-
>
data
.
explicit_invariant
!
=
output
-
>
data
.
explicit_invariant
&
&
prog
-
>
data
-
>
Version
<
(
prog
-
>
IsES
?
300
:
430
)
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
%
s
invariant
qualifier
"
"
but
%
s
shader
input
%
s
invariant
qualifier
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
(
output
-
>
data
.
explicit_invariant
)
?
"
has
"
:
"
lacks
"
_mesa_shader_stage_to_string
(
consumer_stage
)
(
input
-
>
data
.
explicit_invariant
)
?
"
has
"
:
"
lacks
"
)
;
return
;
}
unsigned
input_interpolation
=
input
-
>
data
.
interpolation
;
unsigned
output_interpolation
=
output
-
>
data
.
interpolation
;
if
(
prog
-
>
IsES
)
{
if
(
input_interpolation
=
=
INTERP_MODE_NONE
)
input_interpolation
=
INTERP_MODE_SMOOTH
;
if
(
output_interpolation
=
=
INTERP_MODE_NONE
)
output_interpolation
=
INTERP_MODE_SMOOTH
;
}
if
(
input_interpolation
!
=
output_interpolation
&
&
prog
-
>
data
-
>
Version
<
440
)
{
if
(
!
ctx
-
>
Const
.
AllowGLSLCrossStageInterpolationMismatch
)
{
linker_error
(
prog
"
%
s
shader
output
%
s
'
specifies
%
s
"
"
interpolation
qualifier
"
"
but
%
s
shader
input
specifies
%
s
"
"
interpolation
qualifier
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
interpolation_string
(
output
-
>
data
.
interpolation
)
_mesa_shader_stage_to_string
(
consumer_stage
)
interpolation_string
(
input
-
>
data
.
interpolation
)
)
;
return
;
}
else
{
linker_warning
(
prog
"
%
s
shader
output
%
s
'
specifies
%
s
"
"
interpolation
qualifier
"
"
but
%
s
shader
input
specifies
%
s
"
"
interpolation
qualifier
\
n
"
_mesa_shader_stage_to_string
(
producer_stage
)
output
-
>
name
interpolation_string
(
output
-
>
data
.
interpolation
)
_mesa_shader_stage_to_string
(
consumer_stage
)
interpolation_string
(
input
-
>
data
.
interpolation
)
)
;
}
}
}
static
void
cross_validate_front_and_back_color
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
const
ir_variable
*
input
const
ir_variable
*
front_color
const
ir_variable
*
back_color
gl_shader_stage
consumer_stage
gl_shader_stage
producer_stage
)
{
if
(
front_color
!
=
NULL
&
&
front_color
-
>
data
.
assigned
)
cross_validate_types_and_qualifiers
(
ctx
prog
input
front_color
consumer_stage
producer_stage
)
;
if
(
back_color
!
=
NULL
&
&
back_color
-
>
data
.
assigned
)
cross_validate_types_and_qualifiers
(
ctx
prog
input
back_color
consumer_stage
producer_stage
)
;
}
static
unsigned
compute_variable_location_slot
(
ir_variable
*
var
gl_shader_stage
stage
)
{
unsigned
location_start
=
VARYING_SLOT_VAR0
;
switch
(
stage
)
{
case
MESA_SHADER_VERTEX
:
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
location_start
=
VERT_ATTRIB_GENERIC0
;
break
;
case
MESA_SHADER_TESS_CTRL
:
case
MESA_SHADER_TESS_EVAL
:
if
(
var
-
>
data
.
patch
)
location_start
=
VARYING_SLOT_PATCH0
;
break
;
case
MESA_SHADER_FRAGMENT
:
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_out
)
location_start
=
FRAG_RESULT_DATA0
;
break
;
default
:
break
;
}
return
var
-
>
data
.
location
-
location_start
;
}
struct
explicit_location_info
{
ir_variable
*
var
;
bool
base_type_is_integer
;
unsigned
base_type_bit_size
;
unsigned
interpolation
;
bool
centroid
;
bool
sample
;
bool
patch
;
}
;
static
bool
check_location_aliasing
(
struct
explicit_location_info
explicit_locations
[
]
[
4
]
ir_variable
*
var
unsigned
location
unsigned
component
unsigned
location_limit
const
glsl_type
*
type
unsigned
interpolation
bool
centroid
bool
sample
bool
patch
gl_shader_program
*
prog
gl_shader_stage
stage
)
{
unsigned
last_comp
;
unsigned
base_type_bit_size
;
const
glsl_type
*
type_without_array
=
type
-
>
without_array
(
)
;
const
bool
base_type_is_integer
=
glsl_base_type_is_integer
(
type_without_array
-
>
base_type
)
;
const
bool
is_struct
=
type_without_array
-
>
is_struct
(
)
;
if
(
is_struct
)
{
last_comp
=
4
;
base_type_bit_size
=
0
;
}
else
{
unsigned
dmul
=
type_without_array
-
>
is_64bit
(
)
?
2
:
1
;
last_comp
=
component
+
type_without_array
-
>
vector_elements
*
dmul
;
base_type_bit_size
=
glsl_base_type_get_bit_size
(
type_without_array
-
>
base_type
)
;
}
while
(
location
<
location_limit
)
{
unsigned
comp
=
0
;
while
(
comp
<
4
)
{
struct
explicit_location_info
*
info
=
&
explicit_locations
[
location
]
[
comp
]
;
if
(
info
-
>
var
)
{
if
(
info
-
>
var
-
>
type
-
>
without_array
(
)
-
>
is_struct
(
)
|
|
is_struct
)
{
linker_error
(
prog
"
%
s
shader
has
multiple
%
sputs
sharing
the
"
"
same
location
that
don
'
t
have
the
same
"
"
underlying
numerical
type
.
Struct
variable
'
%
s
'
"
"
location
%
u
\
n
"
_mesa_shader_stage_to_string
(
stage
)
var
-
>
data
.
mode
=
=
ir_var_shader_in
?
"
in
"
:
"
out
"
is_struct
?
var
-
>
name
:
info
-
>
var
-
>
name
location
)
;
return
false
;
}
else
if
(
comp
>
=
component
&
&
comp
<
last_comp
)
{
linker_error
(
prog
"
%
s
shader
has
multiple
%
sputs
explicitly
"
"
assigned
to
location
%
d
and
component
%
d
\
n
"
_mesa_shader_stage_to_string
(
stage
)
var
-
>
data
.
mode
=
=
ir_var_shader_in
?
"
in
"
:
"
out
"
location
comp
)
;
return
false
;
}
else
{
if
(
info
-
>
base_type_is_integer
!
=
base_type_is_integer
)
{
linker_error
(
prog
"
%
s
shader
has
multiple
%
sputs
sharing
the
"
"
same
location
that
don
'
t
have
the
same
"
"
underlying
numerical
type
.
Location
%
u
"
"
component
%
u
.
\
n
"
_mesa_shader_stage_to_string
(
stage
)
var
-
>
data
.
mode
=
=
ir_var_shader_in
?
"
in
"
:
"
out
"
location
comp
)
;
return
false
;
}
if
(
info
-
>
base_type_bit_size
!
=
base_type_bit_size
)
{
linker_error
(
prog
"
%
s
shader
has
multiple
%
sputs
sharing
the
"
"
same
location
that
don
'
t
have
the
same
"
"
underlying
numerical
bit
size
.
Location
%
u
"
"
component
%
u
.
\
n
"
_mesa_shader_stage_to_string
(
stage
)
var
-
>
data
.
mode
=
=
ir_var_shader_in
?
"
in
"
:
"
out
"
location
comp
)
;
return
false
;
}
if
(
info
-
>
interpolation
!
=
interpolation
)
{
linker_error
(
prog
"
%
s
shader
has
multiple
%
sputs
sharing
the
"
"
same
location
that
don
'
t
have
the
same
"
"
interpolation
qualification
.
Location
%
u
"
"
component
%
u
.
\
n
"
_mesa_shader_stage_to_string
(
stage
)
var
-
>
data
.
mode
=
=
ir_var_shader_in
?
"
in
"
:
"
out
"
location
comp
)
;
return
false
;
}
if
(
info
-
>
centroid
!
=
centroid
|
|
info
-
>
sample
!
=
sample
|
|
info
-
>
patch
!
=
patch
)
{
linker_error
(
prog
"
%
s
shader
has
multiple
%
sputs
sharing
the
"
"
same
location
that
don
'
t
have
the
same
"
"
auxiliary
storage
qualification
.
Location
%
u
"
"
component
%
u
.
\
n
"
_mesa_shader_stage_to_string
(
stage
)
var
-
>
data
.
mode
=
=
ir_var_shader_in
?
"
in
"
:
"
out
"
location
comp
)
;
return
false
;
}
}
}
else
if
(
comp
>
=
component
&
&
comp
<
last_comp
)
{
info
-
>
var
=
var
;
info
-
>
base_type_is_integer
=
base_type_is_integer
;
info
-
>
base_type_bit_size
=
base_type_bit_size
;
info
-
>
interpolation
=
interpolation
;
info
-
>
centroid
=
centroid
;
info
-
>
sample
=
sample
;
info
-
>
patch
=
patch
;
}
comp
+
+
;
if
(
comp
=
=
4
&
&
last_comp
>
4
)
{
last_comp
=
last_comp
-
4
;
location
+
+
;
comp
=
0
;
component
=
0
;
}
}
location
+
+
;
}
return
true
;
}
static
bool
validate_explicit_variable_location
(
struct
gl_context
*
ctx
struct
explicit_location_info
explicit_locations
[
]
[
4
]
ir_variable
*
var
gl_shader_program
*
prog
gl_linked_shader
*
sh
)
{
const
glsl_type
*
type
=
get_varying_type
(
var
sh
-
>
Stage
)
;
unsigned
num_elements
=
type
-
>
count_attribute_slots
(
false
)
;
unsigned
idx
=
compute_variable_location_slot
(
var
sh
-
>
Stage
)
;
unsigned
slot_limit
=
idx
+
num_elements
;
unsigned
slot_max
;
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_out
)
{
assert
(
sh
-
>
Stage
!
=
MESA_SHADER_FRAGMENT
)
;
slot_max
=
ctx
-
>
Const
.
Program
[
sh
-
>
Stage
]
.
MaxOutputComponents
/
4
;
}
else
{
assert
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
;
assert
(
sh
-
>
Stage
!
=
MESA_SHADER_VERTEX
)
;
slot_max
=
ctx
-
>
Const
.
Program
[
sh
-
>
Stage
]
.
MaxInputComponents
/
4
;
}
if
(
slot_limit
>
slot_max
)
{
linker_error
(
prog
"
Invalid
location
%
u
in
%
s
shader
\
n
"
idx
_mesa_shader_stage_to_string
(
sh
-
>
Stage
)
)
;
return
false
;
}
const
glsl_type
*
type_without_array
=
type
-
>
without_array
(
)
;
if
(
type_without_array
-
>
is_interface
(
)
)
{
for
(
unsigned
i
=
0
;
i
<
type_without_array
-
>
length
;
i
+
+
)
{
glsl_struct_field
*
field
=
&
type_without_array
-
>
fields
.
structure
[
i
]
;
unsigned
field_location
=
field
-
>
location
-
(
field
-
>
patch
?
VARYING_SLOT_PATCH0
:
VARYING_SLOT_VAR0
)
;
if
(
!
check_location_aliasing
(
explicit_locations
var
field_location
0
field_location
+
1
field
-
>
type
field
-
>
interpolation
field
-
>
centroid
field
-
>
sample
field
-
>
patch
prog
sh
-
>
Stage
)
)
{
return
false
;
}
}
}
else
if
(
!
check_location_aliasing
(
explicit_locations
var
idx
var
-
>
data
.
location_frac
slot_limit
type
var
-
>
data
.
interpolation
var
-
>
data
.
centroid
var
-
>
data
.
sample
var
-
>
data
.
patch
prog
sh
-
>
Stage
)
)
{
return
false
;
}
return
true
;
}
void
validate_first_and_last_interface_explicit_locations
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
gl_shader_stage
first_stage
gl_shader_stage
last_stage
)
{
bool
validate_first_stage
=
first_stage
!
=
MESA_SHADER_VERTEX
;
bool
validate_last_stage
=
last_stage
!
=
MESA_SHADER_FRAGMENT
;
if
(
!
validate_first_stage
&
&
!
validate_last_stage
)
return
;
struct
explicit_location_info
explicit_locations
[
MAX_VARYING
]
[
4
]
;
gl_shader_stage
stages
[
2
]
=
{
first_stage
last_stage
}
;
bool
validate_stage
[
2
]
=
{
validate_first_stage
validate_last_stage
}
;
ir_variable_mode
var_direction
[
2
]
=
{
ir_var_shader_in
ir_var_shader_out
}
;
for
(
unsigned
i
=
0
;
i
<
2
;
i
+
+
)
{
if
(
!
validate_stage
[
i
]
)
continue
;
gl_shader_stage
stage
=
stages
[
i
]
;
gl_linked_shader
*
sh
=
prog
-
>
_LinkedShaders
[
stage
]
;
assert
(
sh
)
;
memset
(
explicit_locations
0
sizeof
(
explicit_locations
)
)
;
foreach_in_list
(
ir_instruction
node
sh
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
|
|
!
var
-
>
data
.
explicit_location
|
|
var
-
>
data
.
location
<
VARYING_SLOT_VAR0
|
|
var
-
>
data
.
mode
!
=
var_direction
[
i
]
)
continue
;
if
(
!
validate_explicit_variable_location
(
ctx
explicit_locations
var
prog
sh
)
)
{
return
;
}
}
}
}
void
cross_validate_outputs_to_inputs
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
gl_linked_shader
*
producer
gl_linked_shader
*
consumer
)
{
glsl_symbol_table
parameters
;
struct
explicit_location_info
output_explicit_locations
[
MAX_VARYING
]
[
4
]
=
{
}
;
struct
explicit_location_info
input_explicit_locations
[
MAX_VARYING
]
[
4
]
=
{
}
;
foreach_in_list
(
ir_instruction
node
producer
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_out
)
continue
;
if
(
!
var
-
>
data
.
explicit_location
|
|
var
-
>
data
.
location
<
VARYING_SLOT_VAR0
)
parameters
.
add_variable
(
var
)
;
else
{
if
(
!
validate_explicit_variable_location
(
ctx
output_explicit_locations
var
prog
producer
)
)
{
return
;
}
}
}
foreach_in_list
(
ir_instruction
node
consumer
-
>
ir
)
{
ir_variable
*
const
input
=
node
-
>
as_variable
(
)
;
if
(
input
=
=
NULL
|
|
input
-
>
data
.
mode
!
=
ir_var_shader_in
)
continue
;
if
(
strcmp
(
input
-
>
name
"
gl_Color
"
)
=
=
0
&
&
input
-
>
data
.
used
)
{
const
ir_variable
*
const
front_color
=
parameters
.
get_variable
(
"
gl_FrontColor
"
)
;
const
ir_variable
*
const
back_color
=
parameters
.
get_variable
(
"
gl_BackColor
"
)
;
cross_validate_front_and_back_color
(
ctx
prog
input
front_color
back_color
consumer
-
>
Stage
producer
-
>
Stage
)
;
}
else
if
(
strcmp
(
input
-
>
name
"
gl_SecondaryColor
"
)
=
=
0
&
&
input
-
>
data
.
used
)
{
const
ir_variable
*
const
front_color
=
parameters
.
get_variable
(
"
gl_FrontSecondaryColor
"
)
;
const
ir_variable
*
const
back_color
=
parameters
.
get_variable
(
"
gl_BackSecondaryColor
"
)
;
cross_validate_front_and_back_color
(
ctx
prog
input
front_color
back_color
consumer
-
>
Stage
producer
-
>
Stage
)
;
}
else
{
ir_variable
*
output
=
NULL
;
if
(
input
-
>
data
.
explicit_location
&
&
input
-
>
data
.
location
>
=
VARYING_SLOT_VAR0
)
{
const
glsl_type
*
type
=
get_varying_type
(
input
consumer
-
>
Stage
)
;
unsigned
num_elements
=
type
-
>
count_attribute_slots
(
false
)
;
unsigned
idx
=
compute_variable_location_slot
(
input
consumer
-
>
Stage
)
;
unsigned
slot_limit
=
idx
+
num_elements
;
if
(
!
validate_explicit_variable_location
(
ctx
input_explicit_locations
input
prog
consumer
)
)
{
return
;
}
while
(
idx
<
slot_limit
)
{
if
(
idx
>
=
MAX_VARYING
)
{
linker_error
(
prog
"
Invalid
location
%
u
in
%
s
shader
\
n
"
idx
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
)
;
return
;
}
output
=
output_explicit_locations
[
idx
]
[
input
-
>
data
.
location_frac
]
.
var
;
if
(
output
=
=
NULL
)
{
if
(
input
-
>
data
.
used
)
{
linker_error
(
prog
"
%
s
shader
input
%
s
'
with
explicit
location
"
"
has
no
matching
output
\
n
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
input
-
>
name
)
;
break
;
}
}
else
if
(
input
-
>
data
.
location
!
=
output
-
>
data
.
location
)
{
linker_error
(
prog
"
%
s
shader
input
%
s
'
with
explicit
location
"
"
has
no
matching
output
\
n
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
input
-
>
name
)
;
break
;
}
idx
+
+
;
}
}
else
{
output
=
parameters
.
get_variable
(
input
-
>
name
)
;
}
if
(
output
!
=
NULL
)
{
if
(
!
(
input
-
>
get_interface_type
(
)
&
&
output
-
>
get_interface_type
(
)
)
)
cross_validate_types_and_qualifiers
(
ctx
prog
input
output
consumer
-
>
Stage
producer
-
>
Stage
)
;
}
else
{
assert
(
!
input
-
>
data
.
assigned
)
;
if
(
input
-
>
data
.
used
&
&
!
input
-
>
get_interface_type
(
)
&
&
!
input
-
>
data
.
explicit_location
)
linker_error
(
prog
"
%
s
shader
input
%
s
'
"
"
has
no
matching
output
in
the
previous
stage
\
n
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
input
-
>
name
)
;
}
}
}
}
static
void
remove_unused_shader_inputs_and_outputs
(
bool
is_separate_shader_object
gl_linked_shader
*
sh
enum
ir_variable_mode
mode
)
{
if
(
is_separate_shader_object
)
return
;
foreach_in_list
(
ir_instruction
node
sh
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
|
|
var
-
>
data
.
mode
!
=
int
(
mode
)
)
continue
;
if
(
var
-
>
data
.
is_unmatched_generic_inout
&
&
!
var
-
>
data
.
is_xfb_only
)
{
assert
(
var
-
>
data
.
mode
!
=
ir_var_temporary
)
;
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
!
var
-
>
constant_value
)
var
-
>
constant_value
=
ir_constant
:
:
zero
(
var
var
-
>
type
)
;
var
-
>
data
.
mode
=
ir_var_auto
;
}
}
while
(
do_dead_code
(
sh
-
>
ir
false
)
)
;
}
void
tfeedback_decl
:
:
init
(
struct
gl_context
*
ctx
const
void
*
mem_ctx
const
char
*
input
)
{
this
-
>
location
=
-
1
;
this
-
>
orig_name
=
input
;
this
-
>
lowered_builtin_array_variable
=
none
;
this
-
>
skip_components
=
0
;
this
-
>
next_buffer_separator
=
false
;
this
-
>
matched_candidate
=
NULL
;
this
-
>
stream_id
=
0
;
this
-
>
buffer
=
0
;
this
-
>
offset
=
0
;
if
(
ctx
-
>
Extensions
.
ARB_transform_feedback3
)
{
if
(
strcmp
(
input
"
gl_NextBuffer
"
)
=
=
0
)
{
this
-
>
next_buffer_separator
=
true
;
return
;
}
if
(
strcmp
(
input
"
gl_SkipComponents1
"
)
=
=
0
)
this
-
>
skip_components
=
1
;
else
if
(
strcmp
(
input
"
gl_SkipComponents2
"
)
=
=
0
)
this
-
>
skip_components
=
2
;
else
if
(
strcmp
(
input
"
gl_SkipComponents3
"
)
=
=
0
)
this
-
>
skip_components
=
3
;
else
if
(
strcmp
(
input
"
gl_SkipComponents4
"
)
=
=
0
)
this
-
>
skip_components
=
4
;
if
(
this
-
>
skip_components
)
return
;
}
const
char
*
base_name_end
;
long
subscript
=
parse_program_resource_name
(
input
&
base_name_end
)
;
this
-
>
var_name
=
ralloc_strndup
(
mem_ctx
input
base_name_end
-
input
)
;
if
(
this
-
>
var_name
=
=
NULL
)
{
_mesa_error_no_memory
(
__func__
)
;
return
;
}
if
(
subscript
>
=
0
)
{
this
-
>
array_subscript
=
subscript
;
this
-
>
is_subscripted
=
true
;
}
else
{
this
-
>
is_subscripted
=
false
;
}
if
(
ctx
-
>
Const
.
ShaderCompilerOptions
[
MESA_SHADER_VERTEX
]
.
LowerCombinedClipCullDistance
&
&
strcmp
(
this
-
>
var_name
"
gl_ClipDistance
"
)
=
=
0
)
{
this
-
>
lowered_builtin_array_variable
=
clip_distance
;
}
if
(
ctx
-
>
Const
.
ShaderCompilerOptions
[
MESA_SHADER_VERTEX
]
.
LowerCombinedClipCullDistance
&
&
strcmp
(
this
-
>
var_name
"
gl_CullDistance
"
)
=
=
0
)
{
this
-
>
lowered_builtin_array_variable
=
cull_distance
;
}
if
(
ctx
-
>
Const
.
LowerTessLevel
&
&
(
strcmp
(
this
-
>
var_name
"
gl_TessLevelOuter
"
)
=
=
0
)
)
this
-
>
lowered_builtin_array_variable
=
tess_level_outer
;
if
(
ctx
-
>
Const
.
LowerTessLevel
&
&
(
strcmp
(
this
-
>
var_name
"
gl_TessLevelInner
"
)
=
=
0
)
)
this
-
>
lowered_builtin_array_variable
=
tess_level_inner
;
}
bool
tfeedback_decl
:
:
is_same
(
const
tfeedback_decl
&
x
const
tfeedback_decl
&
y
)
{
assert
(
x
.
is_varying
(
)
&
&
y
.
is_varying
(
)
)
;
if
(
strcmp
(
x
.
var_name
y
.
var_name
)
!
=
0
)
return
false
;
if
(
x
.
is_subscripted
!
=
y
.
is_subscripted
)
return
false
;
if
(
x
.
is_subscripted
&
&
x
.
array_subscript
!
=
y
.
array_subscript
)
return
false
;
return
true
;
}
bool
tfeedback_decl
:
:
assign_location
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
)
{
assert
(
this
-
>
is_varying
(
)
)
;
unsigned
fine_location
=
this
-
>
matched_candidate
-
>
toplevel_var
-
>
data
.
location
*
4
+
this
-
>
matched_candidate
-
>
toplevel_var
-
>
data
.
location_frac
+
this
-
>
matched_candidate
-
>
offset
;
const
unsigned
dmul
=
this
-
>
matched_candidate
-
>
type
-
>
without_array
(
)
-
>
is_64bit
(
)
?
2
:
1
;
if
(
this
-
>
matched_candidate
-
>
type
-
>
is_array
(
)
)
{
const
unsigned
matrix_cols
=
this
-
>
matched_candidate
-
>
type
-
>
fields
.
array
-
>
matrix_columns
;
const
unsigned
vector_elements
=
this
-
>
matched_candidate
-
>
type
-
>
fields
.
array
-
>
vector_elements
;
unsigned
actual_array_size
;
switch
(
this
-
>
lowered_builtin_array_variable
)
{
case
clip_distance
:
actual_array_size
=
prog
-
>
last_vert_prog
?
prog
-
>
last_vert_prog
-
>
info
.
clip_distance_array_size
:
0
;
break
;
case
cull_distance
:
actual_array_size
=
prog
-
>
last_vert_prog
?
prog
-
>
last_vert_prog
-
>
info
.
cull_distance_array_size
:
0
;
break
;
case
tess_level_outer
:
actual_array_size
=
4
;
break
;
case
tess_level_inner
:
actual_array_size
=
2
;
break
;
case
none
:
default
:
actual_array_size
=
this
-
>
matched_candidate
-
>
type
-
>
array_size
(
)
;
break
;
}
if
(
this
-
>
is_subscripted
)
{
if
(
this
-
>
array_subscript
>
=
actual_array_size
)
{
linker_error
(
prog
"
Transform
feedback
varying
%
s
has
index
"
"
%
i
but
the
array
size
is
%
u
.
"
this
-
>
orig_name
this
-
>
array_subscript
actual_array_size
)
;
return
false
;
}
unsigned
array_elem_size
=
this
-
>
lowered_builtin_array_variable
?
1
:
vector_elements
*
matrix_cols
*
dmul
;
fine_location
+
=
array_elem_size
*
this
-
>
array_subscript
;
this
-
>
size
=
1
;
}
else
{
this
-
>
size
=
actual_array_size
;
}
this
-
>
vector_elements
=
vector_elements
;
this
-
>
matrix_columns
=
matrix_cols
;
if
(
this
-
>
lowered_builtin_array_variable
)
this
-
>
type
=
GL_FLOAT
;
else
this
-
>
type
=
this
-
>
matched_candidate
-
>
type
-
>
fields
.
array
-
>
gl_type
;
}
else
{
if
(
this
-
>
is_subscripted
)
{
linker_error
(
prog
"
Transform
feedback
varying
%
s
requested
"
"
but
%
s
is
not
an
array
.
"
this
-
>
orig_name
this
-
>
var_name
)
;
return
false
;
}
this
-
>
size
=
1
;
this
-
>
vector_elements
=
this
-
>
matched_candidate
-
>
type
-
>
vector_elements
;
this
-
>
matrix_columns
=
this
-
>
matched_candidate
-
>
type
-
>
matrix_columns
;
this
-
>
type
=
this
-
>
matched_candidate
-
>
type
-
>
gl_type
;
}
this
-
>
location
=
fine_location
/
4
;
this
-
>
location_frac
=
fine_location
%
4
;
if
(
prog
-
>
TransformFeedback
.
BufferMode
=
=
GL_SEPARATE_ATTRIBS
&
&
this
-
>
num_components
(
)
>
ctx
-
>
Const
.
MaxTransformFeedbackSeparateComponents
)
{
linker_error
(
prog
"
Transform
feedback
varying
%
s
exceeds
"
"
MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
.
"
this
-
>
orig_name
)
;
return
false
;
}
this
-
>
stream_id
=
this
-
>
matched_candidate
-
>
toplevel_var
-
>
data
.
stream
;
unsigned
array_offset
=
this
-
>
array_subscript
*
4
*
dmul
;
unsigned
struct_offset
=
this
-
>
matched_candidate
-
>
offset
*
4
*
dmul
;
this
-
>
buffer
=
this
-
>
matched_candidate
-
>
toplevel_var
-
>
data
.
xfb_buffer
;
this
-
>
offset
=
this
-
>
matched_candidate
-
>
toplevel_var
-
>
data
.
offset
+
array_offset
+
struct_offset
;
return
true
;
}
unsigned
tfeedback_decl
:
:
get_num_outputs
(
)
const
{
if
(
!
this
-
>
is_varying
(
)
)
{
return
0
;
}
return
(
this
-
>
num_components
(
)
+
this
-
>
location_frac
+
3
)
/
4
;
}
bool
tfeedback_decl
:
:
store
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
struct
gl_transform_feedback_info
*
info
unsigned
buffer
unsigned
buffer_index
const
unsigned
max_outputs
BITSET_WORD
*
used_components
[
MAX_FEEDBACK_BUFFERS
]
bool
*
explicit_stride
bool
has_xfb_qualifiers
const
void
*
mem_ctx
)
const
{
unsigned
xfb_offset
=
0
;
unsigned
size
=
this
-
>
size
;
if
(
this
-
>
skip_components
)
{
info
-
>
Buffers
[
buffer
]
.
Stride
+
=
this
-
>
skip_components
;
size
=
this
-
>
skip_components
;
goto
store_varying
;
}
if
(
this
-
>
next_buffer_separator
)
{
size
=
0
;
goto
store_varying
;
}
if
(
has_xfb_qualifiers
)
{
xfb_offset
=
this
-
>
offset
/
4
;
}
else
{
xfb_offset
=
info
-
>
Buffers
[
buffer
]
.
Stride
;
}
info
-
>
Varyings
[
info
-
>
NumVarying
]
.
Offset
=
xfb_offset
*
4
;
{
unsigned
location
=
this
-
>
location
;
unsigned
location_frac
=
this
-
>
location_frac
;
unsigned
num_components
=
this
-
>
num_components
(
)
;
if
(
(
prog
-
>
TransformFeedback
.
BufferMode
=
=
GL_INTERLEAVED_ATTRIBS
|
|
has_xfb_qualifiers
)
&
&
xfb_offset
+
num_components
>
ctx
-
>
Const
.
MaxTransformFeedbackInterleavedComponents
)
{
linker_error
(
prog
"
The
MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
"
"
limit
has
been
exceeded
.
"
)
;
return
false
;
}
const
unsigned
max_components
=
ctx
-
>
Const
.
MaxTransformFeedbackInterleavedComponents
;
const
unsigned
first_component
=
xfb_offset
;
const
unsigned
last_component
=
xfb_offset
+
num_components
-
1
;
const
unsigned
start_word
=
BITSET_BITWORD
(
first_component
)
;
const
unsigned
end_word
=
BITSET_BITWORD
(
last_component
)
;
BITSET_WORD
*
used
;
assert
(
last_component
<
max_components
)
;
if
(
!
used_components
[
buffer
]
)
{
used_components
[
buffer
]
=
rzalloc_array
(
mem_ctx
BITSET_WORD
BITSET_WORDS
(
max_components
)
)
;
}
used
=
used_components
[
buffer
]
;
for
(
unsigned
word
=
start_word
;
word
<
=
end_word
;
word
+
+
)
{
unsigned
start_range
=
0
;
unsigned
end_range
=
BITSET_WORDBITS
-
1
;
if
(
word
=
=
start_word
)
start_range
=
first_component
%
BITSET_WORDBITS
;
if
(
word
=
=
end_word
)
end_range
=
last_component
%
BITSET_WORDBITS
;
if
(
used
[
word
]
&
BITSET_RANGE
(
start_range
end_range
)
)
{
linker_error
(
prog
"
variable
'
%
s
'
xfb_offset
(
%
d
)
is
causing
aliasing
.
"
this
-
>
orig_name
xfb_offset
*
4
)
;
return
false
;
}
used
[
word
]
|
=
BITSET_RANGE
(
start_range
end_range
)
;
}
while
(
num_components
>
0
)
{
unsigned
output_size
=
MIN2
(
num_components
4
-
location_frac
)
;
assert
(
(
info
-
>
NumOutputs
=
=
0
&
&
max_outputs
=
=
0
)
|
|
info
-
>
NumOutputs
<
max_outputs
)
;
if
(
this
-
>
is_varying_written
(
)
)
{
info
-
>
Outputs
[
info
-
>
NumOutputs
]
.
ComponentOffset
=
location_frac
;
info
-
>
Outputs
[
info
-
>
NumOutputs
]
.
OutputRegister
=
location
;
info
-
>
Outputs
[
info
-
>
NumOutputs
]
.
NumComponents
=
output_size
;
info
-
>
Outputs
[
info
-
>
NumOutputs
]
.
StreamId
=
stream_id
;
info
-
>
Outputs
[
info
-
>
NumOutputs
]
.
OutputBuffer
=
buffer
;
info
-
>
Outputs
[
info
-
>
NumOutputs
]
.
DstOffset
=
xfb_offset
;
+
+
info
-
>
NumOutputs
;
}
info
-
>
Buffers
[
buffer
]
.
Stream
=
this
-
>
stream_id
;
xfb_offset
+
=
output_size
;
num_components
-
=
output_size
;
location
+
+
;
location_frac
=
0
;
}
}
if
(
explicit_stride
&
&
explicit_stride
[
buffer
]
)
{
if
(
this
-
>
is_64bit
(
)
&
&
info
-
>
Buffers
[
buffer
]
.
Stride
%
2
)
{
linker_error
(
prog
"
invalid
qualifier
xfb_stride
=
%
d
must
be
a
"
"
multiple
of
8
as
its
applied
to
a
type
that
is
or
"
"
contains
a
double
.
"
info
-
>
Buffers
[
buffer
]
.
Stride
*
4
)
;
return
false
;
}
if
(
xfb_offset
>
info
-
>
Buffers
[
buffer
]
.
Stride
)
{
linker_error
(
prog
"
xfb_offset
(
%
d
)
overflows
xfb_stride
(
%
d
)
for
"
"
buffer
(
%
d
)
"
xfb_offset
*
4
info
-
>
Buffers
[
buffer
]
.
Stride
*
4
buffer
)
;
return
false
;
}
}
else
{
info
-
>
Buffers
[
buffer
]
.
Stride
=
xfb_offset
;
}
store_varying
:
info
-
>
Varyings
[
info
-
>
NumVarying
]
.
Name
=
ralloc_strdup
(
prog
this
-
>
orig_name
)
;
info
-
>
Varyings
[
info
-
>
NumVarying
]
.
Type
=
this
-
>
type
;
info
-
>
Varyings
[
info
-
>
NumVarying
]
.
Size
=
size
;
info
-
>
Varyings
[
info
-
>
NumVarying
]
.
BufferIndex
=
buffer_index
;
info
-
>
NumVarying
+
+
;
info
-
>
Buffers
[
buffer
]
.
NumVaryings
+
+
;
return
true
;
}
const
tfeedback_candidate
*
tfeedback_decl
:
:
find_candidate
(
gl_shader_program
*
prog
hash_table
*
tfeedback_candidates
)
{
const
char
*
name
=
this
-
>
var_name
;
switch
(
this
-
>
lowered_builtin_array_variable
)
{
case
none
:
name
=
this
-
>
var_name
;
break
;
case
clip_distance
:
name
=
"
gl_ClipDistanceMESA
"
;
break
;
case
cull_distance
:
name
=
"
gl_CullDistanceMESA
"
;
break
;
case
tess_level_outer
:
name
=
"
gl_TessLevelOuterMESA
"
;
break
;
case
tess_level_inner
:
name
=
"
gl_TessLevelInnerMESA
"
;
break
;
}
hash_entry
*
entry
=
_mesa_hash_table_search
(
tfeedback_candidates
name
)
;
this
-
>
matched_candidate
=
entry
?
(
const
tfeedback_candidate
*
)
entry
-
>
data
:
NULL
;
if
(
!
this
-
>
matched_candidate
)
{
linker_error
(
prog
"
Transform
feedback
varying
%
s
undeclared
.
"
this
-
>
orig_name
)
;
}
return
this
-
>
matched_candidate
;
}
static
bool
parse_tfeedback_decls
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
const
void
*
mem_ctx
unsigned
num_names
char
*
*
varying_names
tfeedback_decl
*
decls
)
{
for
(
unsigned
i
=
0
;
i
<
num_names
;
+
+
i
)
{
decls
[
i
]
.
init
(
ctx
mem_ctx
varying_names
[
i
]
)
;
if
(
!
decls
[
i
]
.
is_varying
(
)
)
continue
;
for
(
unsigned
j
=
0
;
j
<
i
;
+
+
j
)
{
if
(
decls
[
j
]
.
is_varying
(
)
)
{
if
(
tfeedback_decl
:
:
is_same
(
decls
[
i
]
decls
[
j
]
)
)
{
linker_error
(
prog
"
Transform
feedback
varying
%
s
specified
"
"
more
than
once
.
"
varying_names
[
i
]
)
;
return
false
;
}
}
}
}
return
true
;
}
static
int
cmp_xfb_offset
(
const
void
*
x_generic
const
void
*
y_generic
)
{
tfeedback_decl
*
x
=
(
tfeedback_decl
*
)
x_generic
;
tfeedback_decl
*
y
=
(
tfeedback_decl
*
)
y_generic
;
if
(
x
-
>
get_buffer
(
)
!
=
y
-
>
get_buffer
(
)
)
return
x
-
>
get_buffer
(
)
-
y
-
>
get_buffer
(
)
;
return
x
-
>
get_offset
(
)
-
y
-
>
get_offset
(
)
;
}
static
bool
store_tfeedback_info
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
unsigned
num_tfeedback_decls
tfeedback_decl
*
tfeedback_decls
bool
has_xfb_qualifiers
const
void
*
mem_ctx
)
{
if
(
!
prog
-
>
last_vert_prog
)
return
true
;
assert
(
ctx
-
>
Const
.
MaxTransformFeedbackBuffers
<
32
)
;
bool
separate_attribs_mode
=
prog
-
>
TransformFeedback
.
BufferMode
=
=
GL_SEPARATE_ATTRIBS
;
struct
gl_program
*
xfb_prog
=
prog
-
>
last_vert_prog
;
xfb_prog
-
>
sh
.
LinkedTransformFeedback
=
rzalloc
(
xfb_prog
struct
gl_transform_feedback_info
)
;
if
(
has_xfb_qualifiers
)
{
qsort
(
tfeedback_decls
num_tfeedback_decls
sizeof
(
*
tfeedback_decls
)
cmp_xfb_offset
)
;
}
xfb_prog
-
>
sh
.
LinkedTransformFeedback
-
>
Varyings
=
rzalloc_array
(
xfb_prog
struct
gl_transform_feedback_varying_info
num_tfeedback_decls
)
;
unsigned
num_outputs
=
0
;
for
(
unsigned
i
=
0
;
i
<
num_tfeedback_decls
;
+
+
i
)
{
if
(
tfeedback_decls
[
i
]
.
is_varying_written
(
)
)
num_outputs
+
=
tfeedback_decls
[
i
]
.
get_num_outputs
(
)
;
}
xfb_prog
-
>
sh
.
LinkedTransformFeedback
-
>
Outputs
=
rzalloc_array
(
xfb_prog
struct
gl_transform_feedback_output
num_outputs
)
;
unsigned
num_buffers
=
0
;
unsigned
buffers
=
0
;
BITSET_WORD
*
used_components
[
MAX_FEEDBACK_BUFFERS
]
=
{
}
;
if
(
!
has_xfb_qualifiers
&
&
separate_attribs_mode
)
{
for
(
unsigned
i
=
0
;
i
<
num_tfeedback_decls
;
+
+
i
)
{
if
(
!
tfeedback_decls
[
i
]
.
store
(
ctx
prog
xfb_prog
-
>
sh
.
LinkedTransformFeedback
num_buffers
num_buffers
num_outputs
used_components
NULL
has_xfb_qualifiers
mem_ctx
)
)
return
false
;
buffers
|
=
1
<
<
num_buffers
;
num_buffers
+
+
;
}
}
else
{
int
buffer_stream_id
=
-
1
;
unsigned
buffer
=
num_tfeedback_decls
?
tfeedback_decls
[
0
]
.
get_buffer
(
)
:
0
;
bool
explicit_stride
[
MAX_FEEDBACK_BUFFERS
]
=
{
false
}
;
if
(
has_xfb_qualifiers
)
{
for
(
unsigned
j
=
0
;
j
<
MAX_FEEDBACK_BUFFERS
;
j
+
+
)
{
if
(
prog
-
>
TransformFeedback
.
BufferStride
[
j
]
)
{
explicit_stride
[
j
]
=
true
;
xfb_prog
-
>
sh
.
LinkedTransformFeedback
-
>
Buffers
[
j
]
.
Stride
=
prog
-
>
TransformFeedback
.
BufferStride
[
j
]
/
4
;
}
}
}
for
(
unsigned
i
=
0
;
i
<
num_tfeedback_decls
;
+
+
i
)
{
if
(
has_xfb_qualifiers
&
&
buffer
!
=
tfeedback_decls
[
i
]
.
get_buffer
(
)
)
{
buffer_stream_id
=
-
1
;
num_buffers
+
+
;
}
if
(
tfeedback_decls
[
i
]
.
is_next_buffer_separator
(
)
)
{
if
(
!
tfeedback_decls
[
i
]
.
store
(
ctx
prog
xfb_prog
-
>
sh
.
LinkedTransformFeedback
buffer
num_buffers
num_outputs
used_components
explicit_stride
has_xfb_qualifiers
mem_ctx
)
)
return
false
;
num_buffers
+
+
;
buffer_stream_id
=
-
1
;
continue
;
}
if
(
has_xfb_qualifiers
)
{
buffer
=
tfeedback_decls
[
i
]
.
get_buffer
(
)
;
}
else
{
buffer
=
num_buffers
;
}
if
(
tfeedback_decls
[
i
]
.
is_varying
(
)
)
{
if
(
buffer_stream_id
=
=
-
1
)
{
buffer_stream_id
=
(
int
)
tfeedback_decls
[
i
]
.
get_stream_id
(
)
;
buffers
|
=
1
<
<
buffer
;
}
else
if
(
buffer_stream_id
!
=
(
int
)
tfeedback_decls
[
i
]
.
get_stream_id
(
)
)
{
linker_error
(
prog
"
Transform
feedback
can
'
t
capture
varyings
belonging
"
"
to
different
vertex
streams
in
a
single
buffer
.
"
"
Varying
%
s
writes
to
buffer
from
stream
%
u
other
"
"
varyings
in
the
same
buffer
write
from
stream
%
u
.
"
tfeedback_decls
[
i
]
.
name
(
)
tfeedback_decls
[
i
]
.
get_stream_id
(
)
buffer_stream_id
)
;
return
false
;
}
}
if
(
!
tfeedback_decls
[
i
]
.
store
(
ctx
prog
xfb_prog
-
>
sh
.
LinkedTransformFeedback
buffer
num_buffers
num_outputs
used_components
explicit_stride
has_xfb_qualifiers
mem_ctx
)
)
return
false
;
}
}
assert
(
xfb_prog
-
>
sh
.
LinkedTransformFeedback
-
>
NumOutputs
=
=
num_outputs
)
;
xfb_prog
-
>
sh
.
LinkedTransformFeedback
-
>
ActiveBuffers
=
buffers
;
return
true
;
}
namespace
{
class
varying_matches
{
public
:
varying_matches
(
bool
disable_varying_packing
bool
xfb_enabled
bool
enhanced_layouts_enabled
gl_shader_stage
producer_stage
gl_shader_stage
consumer_stage
)
;
~
varying_matches
(
)
;
void
record
(
ir_variable
*
producer_var
ir_variable
*
consumer_var
)
;
unsigned
assign_locations
(
struct
gl_shader_program
*
prog
uint8_t
components
[
]
uint64_t
reserved_slots
)
;
void
store_locations
(
)
const
;
private
:
bool
is_varying_packing_safe
(
const
glsl_type
*
type
const
ir_variable
*
var
)
const
;
const
bool
disable_varying_packing
;
const
bool
xfb_enabled
;
const
bool
enhanced_layouts_enabled
;
enum
packing_order_enum
{
PACKING_ORDER_VEC4
PACKING_ORDER_VEC2
PACKING_ORDER_SCALAR
PACKING_ORDER_VEC3
}
;
static
unsigned
compute_packing_class
(
const
ir_variable
*
var
)
;
static
packing_order_enum
compute_packing_order
(
const
ir_variable
*
var
)
;
static
int
match_comparator
(
const
void
*
x_generic
const
void
*
y_generic
)
;
static
int
xfb_comparator
(
const
void
*
x_generic
const
void
*
y_generic
)
;
struct
match
{
unsigned
packing_class
;
packing_order_enum
packing_order
;
unsigned
num_components
;
ir_variable
*
producer_var
;
ir_variable
*
consumer_var
;
unsigned
generic_location
;
}
*
matches
;
unsigned
num_matches
;
unsigned
matches_capacity
;
gl_shader_stage
producer_stage
;
gl_shader_stage
consumer_stage
;
}
;
}
varying_matches
:
:
varying_matches
(
bool
disable_varying_packing
bool
xfb_enabled
bool
enhanced_layouts_enabled
gl_shader_stage
producer_stage
gl_shader_stage
consumer_stage
)
:
disable_varying_packing
(
disable_varying_packing
)
xfb_enabled
(
xfb_enabled
)
enhanced_layouts_enabled
(
enhanced_layouts_enabled
)
producer_stage
(
producer_stage
)
consumer_stage
(
consumer_stage
)
{
this
-
>
matches_capacity
=
8
;
this
-
>
matches
=
(
match
*
)
malloc
(
sizeof
(
*
this
-
>
matches
)
*
this
-
>
matches_capacity
)
;
this
-
>
num_matches
=
0
;
}
varying_matches
:
:
~
varying_matches
(
)
{
free
(
this
-
>
matches
)
;
}
bool
varying_matches
:
:
is_varying_packing_safe
(
const
glsl_type
*
type
const
ir_variable
*
var
)
const
{
if
(
consumer_stage
=
=
MESA_SHADER_TESS_EVAL
|
|
consumer_stage
=
=
MESA_SHADER_TESS_CTRL
|
|
producer_stage
=
=
MESA_SHADER_TESS_CTRL
)
return
false
;
return
xfb_enabled
&
&
(
type
-
>
is_array
(
)
|
|
type
-
>
is_struct
(
)
|
|
type
-
>
is_matrix
(
)
|
|
var
-
>
data
.
is_xfb_only
)
;
}
void
varying_matches
:
:
record
(
ir_variable
*
producer_var
ir_variable
*
consumer_var
)
{
assert
(
producer_var
!
=
NULL
|
|
consumer_var
!
=
NULL
)
;
if
(
(
producer_var
&
&
(
!
producer_var
-
>
data
.
is_unmatched_generic_inout
|
|
producer_var
-
>
data
.
explicit_location
)
)
|
|
(
consumer_var
&
&
(
!
consumer_var
-
>
data
.
is_unmatched_generic_inout
|
|
consumer_var
-
>
data
.
explicit_location
)
)
)
{
return
;
}
bool
needs_flat_qualifier
=
consumer_var
=
=
NULL
&
&
(
producer_var
-
>
type
-
>
contains_integer
(
)
|
|
producer_var
-
>
type
-
>
contains_double
(
)
)
;
if
(
!
disable_varying_packing
&
&
(
needs_flat_qualifier
|
|
(
consumer_stage
!
=
MESA_SHADER_NONE
&
&
consumer_stage
!
=
MESA_SHADER_FRAGMENT
)
)
)
{
if
(
producer_var
)
{
producer_var
-
>
data
.
centroid
=
false
;
producer_var
-
>
data
.
sample
=
false
;
producer_var
-
>
data
.
interpolation
=
INTERP_MODE_FLAT
;
}
if
(
consumer_var
)
{
consumer_var
-
>
data
.
centroid
=
false
;
consumer_var
-
>
data
.
sample
=
false
;
consumer_var
-
>
data
.
interpolation
=
INTERP_MODE_FLAT
;
}
}
if
(
this
-
>
num_matches
=
=
this
-
>
matches_capacity
)
{
this
-
>
matches_capacity
*
=
2
;
this
-
>
matches
=
(
match
*
)
realloc
(
this
-
>
matches
sizeof
(
*
this
-
>
matches
)
*
this
-
>
matches_capacity
)
;
}
const
ir_variable
*
const
var
=
(
consumer_var
!
=
NULL
)
?
consumer_var
:
producer_var
;
const
gl_shader_stage
stage
=
(
consumer_var
!
=
NULL
)
?
consumer_stage
:
producer_stage
;
const
glsl_type
*
type
=
get_varying_type
(
var
stage
)
;
if
(
producer_var
&
&
consumer_var
&
&
consumer_var
-
>
data
.
must_be_shader_input
)
{
producer_var
-
>
data
.
must_be_shader_input
=
1
;
}
this
-
>
matches
[
this
-
>
num_matches
]
.
packing_class
=
this
-
>
compute_packing_class
(
var
)
;
this
-
>
matches
[
this
-
>
num_matches
]
.
packing_order
=
this
-
>
compute_packing_order
(
var
)
;
if
(
(
this
-
>
disable_varying_packing
&
&
!
is_varying_packing_safe
(
type
var
)
)
|
|
var
-
>
data
.
must_be_shader_input
)
{
unsigned
slots
=
type
-
>
count_attribute_slots
(
false
)
;
this
-
>
matches
[
this
-
>
num_matches
]
.
num_components
=
slots
*
4
;
}
else
{
this
-
>
matches
[
this
-
>
num_matches
]
.
num_components
=
type
-
>
component_slots
(
)
;
}
this
-
>
matches
[
this
-
>
num_matches
]
.
producer_var
=
producer_var
;
this
-
>
matches
[
this
-
>
num_matches
]
.
consumer_var
=
consumer_var
;
this
-
>
num_matches
+
+
;
if
(
producer_var
)
producer_var
-
>
data
.
is_unmatched_generic_inout
=
0
;
if
(
consumer_var
)
consumer_var
-
>
data
.
is_unmatched_generic_inout
=
0
;
}
unsigned
varying_matches
:
:
assign_locations
(
struct
gl_shader_program
*
prog
uint8_t
components
[
]
uint64_t
reserved_slots
)
{
if
(
!
this
-
>
disable_varying_packing
)
{
qsort
(
this
-
>
matches
this
-
>
num_matches
sizeof
(
*
this
-
>
matches
)
&
varying_matches
:
:
match_comparator
)
;
}
else
{
qsort
(
this
-
>
matches
this
-
>
num_matches
sizeof
(
*
this
-
>
matches
)
&
varying_matches
:
:
xfb_comparator
)
;
}
unsigned
generic_location
=
0
;
unsigned
generic_patch_location
=
MAX_VARYING
*
4
;
bool
previous_var_xfb_only
=
false
;
unsigned
previous_packing_class
=
~
0u
;
const
bool
dont_pack_vec3
=
(
prog
-
>
TransformFeedback
.
BufferMode
=
=
GL_SEPARATE_ATTRIBS
&
&
prog
-
>
TransformFeedback
.
NumVarying
>
0
)
;
for
(
unsigned
i
=
0
;
i
<
this
-
>
num_matches
;
i
+
+
)
{
unsigned
*
location
=
&
generic_location
;
const
ir_variable
*
var
;
const
glsl_type
*
type
;
bool
is_vertex_input
=
false
;
if
(
matches
[
i
]
.
consumer_var
)
{
var
=
matches
[
i
]
.
consumer_var
;
type
=
get_varying_type
(
var
consumer_stage
)
;
if
(
consumer_stage
=
=
MESA_SHADER_VERTEX
)
is_vertex_input
=
true
;
}
else
{
var
=
matches
[
i
]
.
producer_var
;
type
=
get_varying_type
(
var
producer_stage
)
;
}
if
(
var
-
>
data
.
patch
)
location
=
&
generic_patch_location
;
if
(
var
-
>
data
.
must_be_shader_input
|
|
(
this
-
>
disable_varying_packing
&
&
!
(
previous_var_xfb_only
&
&
var
-
>
data
.
is_xfb_only
)
)
|
|
(
previous_packing_class
!
=
this
-
>
matches
[
i
]
.
packing_class
)
|
|
(
this
-
>
matches
[
i
]
.
packing_order
=
=
PACKING_ORDER_VEC3
&
&
dont_pack_vec3
)
)
{
*
location
=
ALIGN
(
*
location
4
)
;
}
previous_var_xfb_only
=
var
-
>
data
.
is_xfb_only
;
previous_packing_class
=
this
-
>
matches
[
i
]
.
packing_class
;
unsigned
num_components
=
is_vertex_input
?
type
-
>
count_attribute_slots
(
is_vertex_input
)
*
4
:
this
-
>
matches
[
i
]
.
num_components
;
unsigned
slot_end
=
*
location
+
num_components
-
1
;
while
(
slot_end
<
MAX_VARYING
*
4u
)
{
const
unsigned
slots
=
(
slot_end
/
4u
)
-
(
*
location
/
4u
)
+
1
;
const
uint64_t
slot_mask
=
(
(
1ull
<
<
slots
)
-
1
)
<
<
(
*
location
/
4u
)
;
assert
(
slots
>
0
)
;
if
(
(
reserved_slots
&
slot_mask
)
=
=
0
)
{
break
;
}
*
location
=
ALIGN
(
*
location
+
1
4
)
;
slot_end
=
*
location
+
num_components
-
1
;
}
if
(
!
var
-
>
data
.
patch
&
&
slot_end
>
=
MAX_VARYING
*
4u
)
{
linker_error
(
prog
"
insufficient
contiguous
locations
available
for
"
"
%
s
it
is
possible
an
array
or
struct
could
not
be
"
"
packed
between
varyings
with
explicit
locations
.
Try
"
"
using
an
explicit
location
for
arrays
and
structs
.
"
var
-
>
name
)
;
}
if
(
slot_end
<
MAX_VARYINGS_INCL_PATCH
*
4u
)
{
for
(
unsigned
j
=
*
location
/
4u
;
j
<
slot_end
/
4u
;
j
+
+
)
components
[
j
]
=
4
;
components
[
slot_end
/
4u
]
=
(
slot_end
&
3
)
+
1
;
}
this
-
>
matches
[
i
]
.
generic_location
=
*
location
;
*
location
=
slot_end
+
1
;
}
return
(
generic_location
+
3
)
/
4
;
}
void
varying_matches
:
:
store_locations
(
)
const
{
bool
pack_loc
[
MAX_VARYINGS_INCL_PATCH
]
=
{
0
}
;
const
glsl_type
*
loc_type
[
MAX_VARYINGS_INCL_PATCH
]
[
4
]
=
{
{
NULL
NULL
}
}
;
for
(
unsigned
i
=
0
;
i
<
this
-
>
num_matches
;
i
+
+
)
{
ir_variable
*
producer_var
=
this
-
>
matches
[
i
]
.
producer_var
;
ir_variable
*
consumer_var
=
this
-
>
matches
[
i
]
.
consumer_var
;
unsigned
generic_location
=
this
-
>
matches
[
i
]
.
generic_location
;
unsigned
slot
=
generic_location
/
4
;
unsigned
offset
=
generic_location
%
4
;
if
(
producer_var
)
{
producer_var
-
>
data
.
location
=
VARYING_SLOT_VAR0
+
slot
;
producer_var
-
>
data
.
location_frac
=
offset
;
}
if
(
consumer_var
)
{
assert
(
consumer_var
-
>
data
.
location
=
=
-
1
)
;
consumer_var
-
>
data
.
location
=
VARYING_SLOT_VAR0
+
slot
;
consumer_var
-
>
data
.
location_frac
=
offset
;
}
if
(
producer_var
&
&
consumer_var
)
{
if
(
enhanced_layouts_enabled
)
{
const
glsl_type
*
type
=
get_varying_type
(
producer_var
producer_stage
)
;
if
(
type
-
>
is_array
(
)
|
|
type
-
>
is_matrix
(
)
|
|
type
-
>
is_struct
(
)
|
|
type
-
>
is_double
(
)
)
{
unsigned
comp_slots
=
type
-
>
component_slots
(
)
+
offset
;
unsigned
slots
=
comp_slots
/
4
;
if
(
comp_slots
%
4
)
slots
+
=
1
;
for
(
unsigned
j
=
0
;
j
<
slots
;
j
+
+
)
{
pack_loc
[
slot
+
j
]
=
true
;
}
}
else
if
(
offset
+
type
-
>
vector_elements
>
4
)
{
pack_loc
[
slot
]
=
true
;
pack_loc
[
slot
+
1
]
=
true
;
}
else
{
loc_type
[
slot
]
[
offset
]
=
type
;
}
}
}
}
if
(
enhanced_layouts_enabled
)
{
for
(
unsigned
i
=
0
;
i
<
this
-
>
num_matches
;
i
+
+
)
{
ir_variable
*
producer_var
=
this
-
>
matches
[
i
]
.
producer_var
;
ir_variable
*
consumer_var
=
this
-
>
matches
[
i
]
.
consumer_var
;
unsigned
generic_location
=
this
-
>
matches
[
i
]
.
generic_location
;
unsigned
slot
=
generic_location
/
4
;
if
(
pack_loc
[
slot
]
|
|
!
producer_var
|
|
!
consumer_var
)
continue
;
const
glsl_type
*
type
=
get_varying_type
(
producer_var
producer_stage
)
;
bool
type_match
=
true
;
for
(
unsigned
j
=
0
;
j
<
4
;
j
+
+
)
{
if
(
loc_type
[
slot
]
[
j
]
)
{
if
(
type
-
>
base_type
!
=
loc_type
[
slot
]
[
j
]
-
>
base_type
)
type_match
=
false
;
}
}
if
(
type_match
)
{
producer_var
-
>
data
.
explicit_location
=
1
;
consumer_var
-
>
data
.
explicit_location
=
1
;
producer_var
-
>
data
.
explicit_component
=
1
;
consumer_var
-
>
data
.
explicit_component
=
1
;
}
}
}
}
unsigned
varying_matches
:
:
compute_packing_class
(
const
ir_variable
*
var
)
{
const
unsigned
interp
=
var
-
>
is_interpolation_flat
(
)
?
unsigned
(
INTERP_MODE_FLAT
)
:
var
-
>
data
.
interpolation
;
assert
(
interp
<
(
1
<
<
3
)
)
;
const
unsigned
packing_class
=
(
interp
<
<
0
)
|
(
var
-
>
data
.
centroid
<
<
3
)
|
(
var
-
>
data
.
sample
<
<
4
)
|
(
var
-
>
data
.
patch
<
<
5
)
|
(
var
-
>
data
.
must_be_shader_input
<
<
6
)
;
return
packing_class
;
}
varying_matches
:
:
packing_order_enum
varying_matches
:
:
compute_packing_order
(
const
ir_variable
*
var
)
{
const
glsl_type
*
element_type
=
var
-
>
type
;
while
(
element_type
-
>
is_array
(
)
)
{
element_type
=
element_type
-
>
fields
.
array
;
}
switch
(
element_type
-
>
component_slots
(
)
%
4
)
{
case
1
:
return
PACKING_ORDER_SCALAR
;
case
2
:
return
PACKING_ORDER_VEC2
;
case
3
:
return
PACKING_ORDER_VEC3
;
case
0
:
return
PACKING_ORDER_VEC4
;
default
:
assert
(
!
"
Unexpected
value
of
vector_elements
"
)
;
return
PACKING_ORDER_VEC4
;
}
}
int
varying_matches
:
:
match_comparator
(
const
void
*
x_generic
const
void
*
y_generic
)
{
const
match
*
x
=
(
const
match
*
)
x_generic
;
const
match
*
y
=
(
const
match
*
)
y_generic
;
if
(
x
-
>
packing_class
!
=
y
-
>
packing_class
)
return
x
-
>
packing_class
-
y
-
>
packing_class
;
return
x
-
>
packing_order
-
y
-
>
packing_order
;
}
int
varying_matches
:
:
xfb_comparator
(
const
void
*
x_generic
const
void
*
y_generic
)
{
const
match
*
x
=
(
const
match
*
)
x_generic
;
if
(
x
-
>
producer_var
!
=
NULL
&
&
x
-
>
producer_var
-
>
data
.
is_xfb_only
)
return
match_comparator
(
x_generic
y_generic
)
;
return
0
;
}
static
bool
var_counts_against_varying_limit
(
gl_shader_stage
stage
const
ir_variable
*
var
)
{
if
(
stage
=
=
MESA_SHADER_FRAGMENT
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
switch
(
var
-
>
data
.
location
)
{
case
VARYING_SLOT_POS
:
case
VARYING_SLOT_FACE
:
case
VARYING_SLOT_PNTC
:
return
false
;
default
:
return
true
;
}
}
return
false
;
}
class
tfeedback_candidate_generator
:
public
program_resource_visitor
{
public
:
tfeedback_candidate_generator
(
void
*
mem_ctx
hash_table
*
tfeedback_candidates
gl_shader_stage
stage
)
:
mem_ctx
(
mem_ctx
)
tfeedback_candidates
(
tfeedback_candidates
)
stage
(
stage
)
toplevel_var
(
NULL
)
varying_floats
(
0
)
{
}
void
process
(
ir_variable
*
var
)
{
assert
(
!
var
-
>
is_interface_instance
(
)
)
;
assert
(
var
-
>
data
.
mode
=
=
ir_var_shader_out
)
;
this
-
>
toplevel_var
=
var
;
this
-
>
varying_floats
=
0
;
const
glsl_type
*
t
=
var
-
>
data
.
from_named_ifc_block
?
var
-
>
get_interface_type
(
)
:
var
-
>
type
;
if
(
!
var
-
>
data
.
patch
&
&
stage
=
=
MESA_SHADER_TESS_CTRL
)
{
assert
(
t
-
>
is_array
(
)
)
;
t
=
t
-
>
fields
.
array
;
}
program_resource_visitor
:
:
process
(
var
t
false
)
;
}
private
:
virtual
void
visit_field
(
const
glsl_type
*
type
const
char
*
name
bool
const
glsl_type
*
const
enum
glsl_interface_packing
bool
)
{
assert
(
!
type
-
>
without_array
(
)
-
>
is_struct
(
)
)
;
assert
(
!
type
-
>
without_array
(
)
-
>
is_interface
(
)
)
;
tfeedback_candidate
*
candidate
=
rzalloc
(
this
-
>
mem_ctx
tfeedback_candidate
)
;
candidate
-
>
toplevel_var
=
this
-
>
toplevel_var
;
candidate
-
>
type
=
type
;
candidate
-
>
offset
=
this
-
>
varying_floats
;
_mesa_hash_table_insert
(
this
-
>
tfeedback_candidates
ralloc_strdup
(
this
-
>
mem_ctx
name
)
candidate
)
;
this
-
>
varying_floats
+
=
type
-
>
component_slots
(
)
;
}
void
*
const
mem_ctx
;
hash_table
*
const
tfeedback_candidates
;
gl_shader_stage
stage
;
ir_variable
*
toplevel_var
;
unsigned
varying_floats
;
}
;
namespace
linker
{
void
populate_consumer_input_sets
(
void
*
mem_ctx
exec_list
*
ir
hash_table
*
consumer_inputs
hash_table
*
consumer_interface_inputs
ir_variable
*
consumer_inputs_with_locations
[
VARYING_SLOT_TESS_MAX
]
)
{
memset
(
consumer_inputs_with_locations
0
sizeof
(
consumer_inputs_with_locations
[
0
]
)
*
VARYING_SLOT_TESS_MAX
)
;
foreach_in_list
(
ir_instruction
node
ir
)
{
ir_variable
*
const
input_var
=
node
-
>
as_variable
(
)
;
if
(
input_var
!
=
NULL
&
&
input_var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
assert
(
!
input_var
-
>
type
-
>
is_interface
(
)
)
;
if
(
input_var
-
>
data
.
explicit_location
)
{
consumer_inputs_with_locations
[
input_var
-
>
data
.
location
]
=
input_var
;
}
else
if
(
input_var
-
>
get_interface_type
(
)
!
=
NULL
)
{
char
*
const
iface_field_name
=
ralloc_asprintf
(
mem_ctx
"
%
s
.
%
s
"
input_var
-
>
get_interface_type
(
)
-
>
without_array
(
)
-
>
name
input_var
-
>
name
)
;
_mesa_hash_table_insert
(
consumer_interface_inputs
iface_field_name
input_var
)
;
}
else
{
_mesa_hash_table_insert
(
consumer_inputs
ralloc_strdup
(
mem_ctx
input_var
-
>
name
)
input_var
)
;
}
}
}
}
ir_variable
*
get_matching_input
(
void
*
mem_ctx
const
ir_variable
*
output_var
hash_table
*
consumer_inputs
hash_table
*
consumer_interface_inputs
ir_variable
*
consumer_inputs_with_locations
[
VARYING_SLOT_TESS_MAX
]
)
{
ir_variable
*
input_var
;
if
(
output_var
-
>
data
.
explicit_location
)
{
input_var
=
consumer_inputs_with_locations
[
output_var
-
>
data
.
location
]
;
}
else
if
(
output_var
-
>
get_interface_type
(
)
!
=
NULL
)
{
char
*
const
iface_field_name
=
ralloc_asprintf
(
mem_ctx
"
%
s
.
%
s
"
output_var
-
>
get_interface_type
(
)
-
>
without_array
(
)
-
>
name
output_var
-
>
name
)
;
hash_entry
*
entry
=
_mesa_hash_table_search
(
consumer_interface_inputs
iface_field_name
)
;
input_var
=
entry
?
(
ir_variable
*
)
entry
-
>
data
:
NULL
;
}
else
{
hash_entry
*
entry
=
_mesa_hash_table_search
(
consumer_inputs
output_var
-
>
name
)
;
input_var
=
entry
?
(
ir_variable
*
)
entry
-
>
data
:
NULL
;
}
return
(
input_var
=
=
NULL
|
|
input_var
-
>
data
.
mode
!
=
ir_var_shader_in
)
?
NULL
:
input_var
;
}
}
static
int
io_variable_cmp
(
const
void
*
_a
const
void
*
_b
)
{
const
ir_variable
*
const
a
=
*
(
const
ir_variable
*
*
)
_a
;
const
ir_variable
*
const
b
=
*
(
const
ir_variable
*
*
)
_b
;
if
(
a
-
>
data
.
explicit_location
&
&
b
-
>
data
.
explicit_location
)
return
b
-
>
data
.
location
-
a
-
>
data
.
location
;
if
(
a
-
>
data
.
explicit_location
&
&
!
b
-
>
data
.
explicit_location
)
return
1
;
if
(
!
a
-
>
data
.
explicit_location
&
&
b
-
>
data
.
explicit_location
)
return
-
1
;
return
-
strcmp
(
a
-
>
name
b
-
>
name
)
;
}
static
void
canonicalize_shader_io
(
exec_list
*
ir
enum
ir_variable_mode
io_mode
)
{
ir_variable
*
var_table
[
MAX_PROGRAM_OUTPUTS
*
4
]
;
unsigned
num_variables
=
0
;
foreach_in_list
(
ir_instruction
node
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
|
|
var
-
>
data
.
mode
!
=
io_mode
)
continue
;
if
(
num_variables
=
=
ARRAY_SIZE
(
var_table
)
)
return
;
var_table
[
num_variables
+
+
]
=
var
;
}
if
(
num_variables
=
=
0
)
return
;
qsort
(
var_table
num_variables
sizeof
(
var_table
[
0
]
)
io_variable_cmp
)
;
for
(
unsigned
i
=
0
;
i
<
num_variables
;
i
+
+
)
{
var_table
[
i
]
-
>
remove
(
)
;
ir
-
>
push_head
(
var_table
[
i
]
)
;
}
}
static
uint64_t
reserved_varying_slot
(
struct
gl_linked_shader
*
stage
ir_variable_mode
io_mode
)
{
assert
(
io_mode
=
=
ir_var_shader_in
|
|
io_mode
=
=
ir_var_shader_out
)
;
assert
(
MAX_VARYINGS_INCL_PATCH
<
=
64
)
;
uint64_t
slots
=
0
;
int
var_slot
;
if
(
!
stage
)
return
slots
;
foreach_in_list
(
ir_instruction
node
stage
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
|
|
var
-
>
data
.
mode
!
=
io_mode
|
|
!
var
-
>
data
.
explicit_location
|
|
var
-
>
data
.
location
<
VARYING_SLOT_VAR0
)
continue
;
var_slot
=
var
-
>
data
.
location
-
VARYING_SLOT_VAR0
;
unsigned
num_elements
=
get_varying_type
(
var
stage
-
>
Stage
)
-
>
count_attribute_slots
(
io_mode
=
=
ir_var_shader_in
&
&
stage
-
>
Stage
=
=
MESA_SHADER_VERTEX
)
;
for
(
unsigned
i
=
0
;
i
<
num_elements
;
i
+
+
)
{
if
(
var_slot
>
=
0
&
&
var_slot
<
MAX_VARYINGS_INCL_PATCH
)
slots
|
=
UINT64_C
(
1
)
<
<
var_slot
;
var_slot
+
=
1
;
}
}
return
slots
;
}
static
bool
assign_varying_locations
(
struct
gl_context
*
ctx
void
*
mem_ctx
struct
gl_shader_program
*
prog
gl_linked_shader
*
producer
gl_linked_shader
*
consumer
unsigned
num_tfeedback_decls
tfeedback_decl
*
tfeedback_decls
const
uint64_t
reserved_slots
)
{
bool
unpackable_tess
=
(
consumer
&
&
consumer
-
>
Stage
=
=
MESA_SHADER_TESS_EVAL
)
|
|
(
consumer
&
&
consumer
-
>
Stage
=
=
MESA_SHADER_TESS_CTRL
)
|
|
(
producer
&
&
producer
-
>
Stage
=
=
MESA_SHADER_TESS_CTRL
)
;
bool
xfb_enabled
=
ctx
-
>
Extensions
.
EXT_transform_feedback
&
&
!
unpackable_tess
;
bool
disable_varying_packing
=
ctx
-
>
Const
.
DisableVaryingPacking
|
|
unpackable_tess
;
if
(
prog
-
>
SeparateShader
&
&
(
producer
=
=
NULL
|
|
consumer
=
=
NULL
)
)
disable_varying_packing
=
true
;
varying_matches
matches
(
disable_varying_packing
xfb_enabled
ctx
-
>
Extensions
.
ARB_enhanced_layouts
producer
?
producer
-
>
Stage
:
MESA_SHADER_NONE
consumer
?
consumer
-
>
Stage
:
MESA_SHADER_NONE
)
;
void
*
hash_table_ctx
=
ralloc_context
(
NULL
)
;
hash_table
*
tfeedback_candidates
=
_mesa_hash_table_create
(
hash_table_ctx
_mesa_hash_string
_mesa_key_string_equal
)
;
hash_table
*
consumer_inputs
=
_mesa_hash_table_create
(
hash_table_ctx
_mesa_hash_string
_mesa_key_string_equal
)
;
hash_table
*
consumer_interface_inputs
=
_mesa_hash_table_create
(
hash_table_ctx
_mesa_hash_string
_mesa_key_string_equal
)
;
ir_variable
*
consumer_inputs_with_locations
[
VARYING_SLOT_TESS_MAX
]
=
{
NULL
}
;
unsigned
consumer_vertices
=
0
;
if
(
consumer
&
&
consumer
-
>
Stage
=
=
MESA_SHADER_GEOMETRY
)
consumer_vertices
=
prog
-
>
Geom
.
VerticesIn
;
if
(
consumer
)
canonicalize_shader_io
(
consumer
-
>
ir
ir_var_shader_in
)
;
if
(
producer
)
canonicalize_shader_io
(
producer
-
>
ir
ir_var_shader_out
)
;
if
(
consumer
)
linker
:
:
populate_consumer_input_sets
(
mem_ctx
consumer
-
>
ir
consumer_inputs
consumer_interface_inputs
consumer_inputs_with_locations
)
;
if
(
producer
)
{
foreach_in_list
(
ir_instruction
node
producer
-
>
ir
)
{
ir_variable
*
const
output_var
=
node
-
>
as_variable
(
)
;
if
(
output_var
=
=
NULL
|
|
output_var
-
>
data
.
mode
!
=
ir_var_shader_out
)
continue
;
assert
(
output_var
-
>
data
.
stream
=
=
0
|
|
(
output_var
-
>
data
.
stream
<
MAX_VERTEX_STREAMS
&
&
producer
-
>
Stage
=
=
MESA_SHADER_GEOMETRY
)
)
;
if
(
num_tfeedback_decls
>
0
)
{
tfeedback_candidate_generator
g
(
mem_ctx
tfeedback_candidates
producer
-
>
Stage
)
;
if
(
!
prog
-
>
IsES
|
|
producer
-
>
Stage
!
=
MESA_SHADER_TESS_CTRL
)
{
g
.
process
(
output_var
)
;
}
}
ir_variable
*
const
input_var
=
linker
:
:
get_matching_input
(
mem_ctx
output_var
consumer_inputs
consumer_interface_inputs
consumer_inputs_with_locations
)
;
if
(
input_var
|
|
(
prog
-
>
SeparateShader
&
&
consumer
=
=
NULL
)
|
|
producer
-
>
Stage
=
=
MESA_SHADER_TESS_CTRL
)
{
matches
.
record
(
output_var
input_var
)
;
}
if
(
input_var
&
&
output_var
-
>
data
.
stream
!
=
0
)
{
linker_error
(
prog
"
output
%
s
is
assigned
to
stream
=
%
d
but
"
"
is
linked
to
an
input
which
requires
stream
=
0
"
output_var
-
>
name
output_var
-
>
data
.
stream
)
;
ralloc_free
(
hash_table_ctx
)
;
return
false
;
}
}
}
else
{
foreach_in_list
(
ir_instruction
node
consumer
-
>
ir
)
{
ir_variable
*
const
input_var
=
node
-
>
as_variable
(
)
;
if
(
input_var
&
&
input_var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
matches
.
record
(
NULL
input_var
)
;
}
}
}
for
(
unsigned
i
=
0
;
i
<
num_tfeedback_decls
;
+
+
i
)
{
if
(
!
tfeedback_decls
[
i
]
.
is_varying
(
)
)
continue
;
const
tfeedback_candidate
*
matched_candidate
=
tfeedback_decls
[
i
]
.
find_candidate
(
prog
tfeedback_candidates
)
;
if
(
matched_candidate
=
=
NULL
)
{
ralloc_free
(
hash_table_ctx
)
;
return
false
;
}
matched_candidate
-
>
toplevel_var
-
>
data
.
always_active_io
=
1
;
ir_variable
*
const
input_var
=
linker
:
:
get_matching_input
(
mem_ctx
matched_candidate
-
>
toplevel_var
consumer_inputs
consumer_interface_inputs
consumer_inputs_with_locations
)
;
if
(
input_var
)
input_var
-
>
data
.
always_active_io
=
1
;
if
(
matched_candidate
-
>
toplevel_var
-
>
data
.
is_unmatched_generic_inout
)
{
matched_candidate
-
>
toplevel_var
-
>
data
.
is_xfb_only
=
1
;
matches
.
record
(
matched_candidate
-
>
toplevel_var
NULL
)
;
}
}
uint8_t
components
[
MAX_VARYINGS_INCL_PATCH
]
=
{
0
}
;
const
unsigned
slots_used
=
matches
.
assign_locations
(
prog
components
reserved_slots
)
;
matches
.
store_locations
(
)
;
for
(
unsigned
i
=
0
;
i
<
num_tfeedback_decls
;
+
+
i
)
{
if
(
tfeedback_decls
[
i
]
.
is_varying
(
)
)
{
if
(
!
tfeedback_decls
[
i
]
.
assign_location
(
ctx
prog
)
)
{
ralloc_free
(
hash_table_ctx
)
;
return
false
;
}
}
}
ralloc_free
(
hash_table_ctx
)
;
if
(
consumer
&
&
producer
)
{
foreach_in_list
(
ir_instruction
node
consumer
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
var
-
>
data
.
is_unmatched_generic_inout
)
{
if
(
!
prog
-
>
IsES
&
&
prog
-
>
data
-
>
Version
<
=
120
)
{
linker_error
(
prog
"
%
s
shader
varying
%
s
not
written
"
"
by
%
s
shader
\
n
.
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
var
-
>
name
_mesa_shader_stage_to_string
(
producer
-
>
Stage
)
)
;
}
else
{
linker_warning
(
prog
"
%
s
shader
varying
%
s
not
written
"
"
by
%
s
shader
\
n
.
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
var
-
>
name
_mesa_shader_stage_to_string
(
producer
-
>
Stage
)
)
;
}
}
}
remove_unused_shader_inputs_and_outputs
(
false
producer
ir_var_shader_out
)
;
remove_unused_shader_inputs_and_outputs
(
false
consumer
ir_var_shader_in
)
;
}
if
(
producer
)
{
lower_packed_varyings
(
mem_ctx
slots_used
components
ir_var_shader_out
0
producer
disable_varying_packing
xfb_enabled
)
;
}
if
(
consumer
)
{
lower_packed_varyings
(
mem_ctx
slots_used
components
ir_var_shader_in
consumer_vertices
consumer
disable_varying_packing
xfb_enabled
)
;
}
return
true
;
}
static
bool
check_against_output_limit
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
gl_linked_shader
*
producer
unsigned
num_explicit_locations
)
{
unsigned
output_vectors
=
num_explicit_locations
;
foreach_in_list
(
ir_instruction
node
producer
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
&
&
!
var
-
>
data
.
explicit_location
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_out
&
&
var_counts_against_varying_limit
(
producer
-
>
Stage
var
)
)
{
output_vectors
+
=
var
-
>
type
-
>
count_attribute_slots
(
false
)
;
}
}
assert
(
producer
-
>
Stage
!
=
MESA_SHADER_FRAGMENT
)
;
unsigned
max_output_components
=
ctx
-
>
Const
.
Program
[
producer
-
>
Stage
]
.
MaxOutputComponents
;
const
unsigned
output_components
=
output_vectors
*
4
;
if
(
output_components
>
max_output_components
)
{
if
(
ctx
-
>
API
=
=
API_OPENGLES2
|
|
prog
-
>
IsES
)
linker_error
(
prog
"
%
s
shader
uses
too
many
output
vectors
"
"
(
%
u
>
%
u
)
\
n
"
_mesa_shader_stage_to_string
(
producer
-
>
Stage
)
output_vectors
max_output_components
/
4
)
;
else
linker_error
(
prog
"
%
s
shader
uses
too
many
output
components
"
"
(
%
u
>
%
u
)
\
n
"
_mesa_shader_stage_to_string
(
producer
-
>
Stage
)
output_components
max_output_components
)
;
return
false
;
}
return
true
;
}
static
bool
check_against_input_limit
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
gl_linked_shader
*
consumer
unsigned
num_explicit_locations
)
{
unsigned
input_vectors
=
num_explicit_locations
;
foreach_in_list
(
ir_instruction
node
consumer
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
&
&
!
var
-
>
data
.
explicit_location
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
var_counts_against_varying_limit
(
consumer
-
>
Stage
var
)
)
{
input_vectors
+
=
var
-
>
type
-
>
count_attribute_slots
(
false
)
;
}
}
assert
(
consumer
-
>
Stage
!
=
MESA_SHADER_VERTEX
)
;
unsigned
max_input_components
=
ctx
-
>
Const
.
Program
[
consumer
-
>
Stage
]
.
MaxInputComponents
;
const
unsigned
input_components
=
input_vectors
*
4
;
if
(
input_components
>
max_input_components
)
{
if
(
ctx
-
>
API
=
=
API_OPENGLES2
|
|
prog
-
>
IsES
)
linker_error
(
prog
"
%
s
shader
uses
too
many
input
vectors
"
"
(
%
u
>
%
u
)
\
n
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
input_vectors
max_input_components
/
4
)
;
else
linker_error
(
prog
"
%
s
shader
uses
too
many
input
components
"
"
(
%
u
>
%
u
)
\
n
"
_mesa_shader_stage_to_string
(
consumer
-
>
Stage
)
input_components
max_input_components
)
;
return
false
;
}
return
true
;
}
bool
link_varyings
(
struct
gl_shader_program
*
prog
unsigned
first
unsigned
last
struct
gl_context
*
ctx
void
*
mem_ctx
)
{
bool
has_xfb_qualifiers
=
false
;
unsigned
num_tfeedback_decls
=
0
;
char
*
*
varying_names
=
NULL
;
tfeedback_decl
*
tfeedback_decls
=
NULL
;
for
(
int
i
=
MESA_SHADER_FRAGMENT
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
prog
-
>
_LinkedShaders
[
i
]
)
{
has_xfb_qualifiers
=
process_xfb_layout_qualifiers
(
mem_ctx
prog
-
>
_LinkedShaders
[
i
]
prog
&
num_tfeedback_decls
&
varying_names
)
;
break
;
}
}
if
(
!
has_xfb_qualifiers
)
{
num_tfeedback_decls
=
prog
-
>
TransformFeedback
.
NumVarying
;
varying_names
=
prog
-
>
TransformFeedback
.
VaryingNames
;
}
if
(
num_tfeedback_decls
!
=
0
)
{
if
(
first
>
=
MESA_SHADER_FRAGMENT
)
{
linker_error
(
prog
"
Transform
feedback
varyings
specified
but
"
"
no
vertex
tessellation
or
geometry
shader
is
"
"
present
.
\
n
"
)
;
return
false
;
}
tfeedback_decls
=
rzalloc_array
(
mem_ctx
tfeedback_decl
num_tfeedback_decls
)
;
if
(
!
parse_tfeedback_decls
(
ctx
prog
mem_ctx
num_tfeedback_decls
varying_names
tfeedback_decls
)
)
return
false
;
}
if
(
last
<
MESA_SHADER_FRAGMENT
&
&
(
num_tfeedback_decls
!
=
0
|
|
prog
-
>
SeparateShader
)
)
{
const
uint64_t
reserved_out_slots
=
reserved_varying_slot
(
prog
-
>
_LinkedShaders
[
last
]
ir_var_shader_out
)
;
if
(
!
assign_varying_locations
(
ctx
mem_ctx
prog
prog
-
>
_LinkedShaders
[
last
]
NULL
num_tfeedback_decls
tfeedback_decls
reserved_out_slots
)
)
return
false
;
}
if
(
last
<
=
MESA_SHADER_FRAGMENT
)
{
remove_unused_shader_inputs_and_outputs
(
prog
-
>
SeparateShader
prog
-
>
_LinkedShaders
[
first
]
ir_var_shader_in
)
;
remove_unused_shader_inputs_and_outputs
(
prog
-
>
SeparateShader
prog
-
>
_LinkedShaders
[
last
]
ir_var_shader_out
)
;
if
(
first
=
=
last
)
{
gl_linked_shader
*
const
sh
=
prog
-
>
_LinkedShaders
[
last
]
;
do_dead_builtin_varyings
(
ctx
NULL
sh
0
NULL
)
;
do_dead_builtin_varyings
(
ctx
sh
NULL
num_tfeedback_decls
tfeedback_decls
)
;
if
(
prog
-
>
SeparateShader
)
{
const
uint64_t
reserved_slots
=
reserved_varying_slot
(
sh
ir_var_shader_in
)
;
if
(
!
assign_varying_locations
(
ctx
mem_ctx
prog
NULL
sh
0
NULL
reserved_slots
)
)
return
false
;
}
}
else
{
int
next
=
last
;
for
(
int
i
=
next
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
prog
-
>
_LinkedShaders
[
i
]
=
=
NULL
&
&
i
!
=
0
)
continue
;
gl_linked_shader
*
const
sh_i
=
prog
-
>
_LinkedShaders
[
i
]
;
gl_linked_shader
*
const
sh_next
=
prog
-
>
_LinkedShaders
[
next
]
;
const
uint64_t
reserved_out_slots
=
reserved_varying_slot
(
sh_i
ir_var_shader_out
)
;
const
uint64_t
reserved_in_slots
=
reserved_varying_slot
(
sh_next
ir_var_shader_in
)
;
do_dead_builtin_varyings
(
ctx
sh_i
sh_next
next
=
=
MESA_SHADER_FRAGMENT
?
num_tfeedback_decls
:
0
tfeedback_decls
)
;
if
(
!
assign_varying_locations
(
ctx
mem_ctx
prog
sh_i
sh_next
next
=
=
MESA_SHADER_FRAGMENT
?
num_tfeedback_decls
:
0
tfeedback_decls
reserved_out_slots
|
reserved_in_slots
)
)
return
false
;
if
(
sh_i
!
=
NULL
)
{
unsigned
slots_used
=
util_bitcount64
(
reserved_out_slots
)
;
if
(
!
check_against_output_limit
(
ctx
prog
sh_i
slots_used
)
)
{
return
false
;
}
}
unsigned
slots_used
=
util_bitcount64
(
reserved_in_slots
)
;
if
(
!
check_against_input_limit
(
ctx
prog
sh_next
slots_used
)
)
return
false
;
next
=
i
;
}
}
}
if
(
!
store_tfeedback_info
(
ctx
prog
num_tfeedback_decls
tfeedback_decls
has_xfb_qualifiers
mem_ctx
)
)
return
false
;
return
true
;
}
