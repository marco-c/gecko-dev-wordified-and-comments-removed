#
ifndef
AST_H
#
define
AST_H
#
include
"
list
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
util
/
bitset
.
h
"
struct
_mesa_glsl_parse_state
;
struct
YYLTYPE
;
class
ast_node
{
public
:
DECLARE_LINEAR_ZALLOC_CXX_OPERATORS
(
ast_node
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
virtual
bool
has_sequence_subexpression
(
)
const
;
struct
YYLTYPE
get_location
(
void
)
const
{
struct
YYLTYPE
locp
;
locp
.
path
=
this
-
>
location
.
path
;
locp
.
source
=
this
-
>
location
.
source
;
locp
.
first_line
=
this
-
>
location
.
first_line
;
locp
.
first_column
=
this
-
>
location
.
first_column
;
locp
.
last_line
=
this
-
>
location
.
last_line
;
locp
.
last_column
=
this
-
>
location
.
last_column
;
return
locp
;
}
void
set_location
(
const
struct
YYLTYPE
&
locp
)
{
this
-
>
location
.
path
=
locp
.
path
;
this
-
>
location
.
source
=
locp
.
source
;
this
-
>
location
.
first_line
=
locp
.
first_line
;
this
-
>
location
.
first_column
=
locp
.
first_column
;
this
-
>
location
.
last_line
=
locp
.
last_line
;
this
-
>
location
.
last_column
=
locp
.
last_column
;
}
void
set_location_range
(
const
struct
YYLTYPE
&
begin
const
struct
YYLTYPE
&
end
)
{
this
-
>
location
.
path
=
begin
.
path
;
this
-
>
location
.
source
=
begin
.
source
;
this
-
>
location
.
first_line
=
begin
.
first_line
;
this
-
>
location
.
last_line
=
end
.
last_line
;
this
-
>
location
.
first_column
=
begin
.
first_column
;
this
-
>
location
.
last_column
=
end
.
last_column
;
}
struct
{
char
*
path
;
unsigned
source
;
unsigned
first_line
;
unsigned
first_column
;
unsigned
last_line
;
unsigned
last_column
;
}
location
;
exec_node
link
;
virtual
void
set_is_lhs
(
bool
)
;
protected
:
ast_node
(
void
)
;
}
;
enum
ast_operators
{
ast_assign
ast_plus
ast_neg
ast_add
ast_sub
ast_mul
ast_div
ast_mod
ast_lshift
ast_rshift
ast_less
ast_greater
ast_lequal
ast_gequal
ast_equal
ast_nequal
ast_bit_and
ast_bit_xor
ast_bit_or
ast_bit_not
ast_logic_and
ast_logic_xor
ast_logic_or
ast_logic_not
ast_mul_assign
ast_div_assign
ast_mod_assign
ast_add_assign
ast_sub_assign
ast_ls_assign
ast_rs_assign
ast_and_assign
ast_xor_assign
ast_or_assign
ast_conditional
ast_pre_inc
ast_pre_dec
ast_post_inc
ast_post_dec
ast_field_selection
ast_array_index
ast_unsized_array_dim
ast_function_call
ast_identifier
ast_int_constant
ast_uint_constant
ast_float_constant
ast_bool_constant
ast_double_constant
ast_int64_constant
ast_uint64_constant
ast_sequence
ast_aggregate
#
define
AST_NUM_OPERATORS
(
ast_aggregate
+
1
)
}
;
class
ast_expression
:
public
ast_node
{
public
:
ast_expression
(
int
oper
ast_expression
*
ast_expression
*
ast_expression
*
)
;
ast_expression
(
const
char
*
identifier
)
:
oper
(
ast_identifier
)
{
subexpressions
[
0
]
=
NULL
;
subexpressions
[
1
]
=
NULL
;
subexpressions
[
2
]
=
NULL
;
primary_expression
.
identifier
=
identifier
;
this
-
>
non_lvalue_description
=
NULL
;
this
-
>
is_lhs
=
false
;
}
static
const
char
*
operator_string
(
enum
ast_operators
op
)
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
virtual
void
hir_no_rvalue
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
virtual
bool
has_sequence_subexpression
(
)
const
;
ir_rvalue
*
do_hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
bool
needs_rvalue
)
;
virtual
void
print
(
void
)
const
;
enum
ast_operators
oper
;
ast_expression
*
subexpressions
[
3
]
;
union
{
const
char
*
identifier
;
int
int_constant
;
float
float_constant
;
unsigned
uint_constant
;
int
bool_constant
;
double
double_constant
;
uint64_t
uint64_constant
;
int64_t
int64_constant
;
}
primary_expression
;
exec_list
expressions
;
const
char
*
non_lvalue_description
;
void
set_is_lhs
(
bool
new_value
)
;
private
:
bool
is_lhs
;
}
;
class
ast_expression_bin
:
public
ast_expression
{
public
:
ast_expression_bin
(
int
oper
ast_expression
*
ast_expression
*
)
;
virtual
void
print
(
void
)
const
;
}
;
class
ast_function_expression
:
public
ast_expression
{
public
:
ast_function_expression
(
ast_expression
*
callee
)
:
ast_expression
(
ast_function_call
callee
NULL
NULL
)
cons
(
false
)
{
}
ast_function_expression
(
class
ast_type_specifier
*
type
)
:
ast_expression
(
ast_function_call
(
ast_expression
*
)
type
NULL
NULL
)
cons
(
true
)
{
}
bool
is_constructor
(
)
const
{
return
cons
;
}
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
virtual
void
hir_no_rvalue
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
virtual
bool
has_sequence_subexpression
(
)
const
;
private
:
bool
cons
;
ir_rvalue
*
handle_method
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
}
;
class
ast_subroutine_list
:
public
ast_node
{
public
:
virtual
void
print
(
void
)
const
;
exec_list
declarations
;
}
;
class
ast_array_specifier
:
public
ast_node
{
public
:
ast_array_specifier
(
const
struct
YYLTYPE
&
locp
ast_expression
*
dim
)
{
set_location
(
locp
)
;
array_dimensions
.
push_tail
(
&
dim
-
>
link
)
;
}
void
add_dimension
(
ast_expression
*
dim
)
{
array_dimensions
.
push_tail
(
&
dim
-
>
link
)
;
}
bool
is_single_dimension
(
)
const
{
return
this
-
>
array_dimensions
.
get_tail_raw
(
)
-
>
prev
!
=
NULL
&
&
this
-
>
array_dimensions
.
get_tail_raw
(
)
-
>
prev
-
>
is_head_sentinel
(
)
;
}
virtual
void
print
(
void
)
const
;
exec_list
array_dimensions
;
}
;
class
ast_layout_expression
:
public
ast_node
{
public
:
ast_layout_expression
(
const
struct
YYLTYPE
&
locp
ast_expression
*
expr
)
{
set_location
(
locp
)
;
layout_const_expressions
.
push_tail
(
&
expr
-
>
link
)
;
}
bool
process_qualifier_constant
(
struct
_mesa_glsl_parse_state
*
state
const
char
*
qual_indentifier
unsigned
*
value
bool
can_be_zero
)
;
void
merge_qualifier
(
ast_layout_expression
*
l_expr
)
{
layout_const_expressions
.
append_list
(
&
l_expr
-
>
layout_const_expressions
)
;
}
exec_list
layout_const_expressions
;
}
;
class
ast_aggregate_initializer
:
public
ast_expression
{
public
:
ast_aggregate_initializer
(
)
:
ast_expression
(
ast_aggregate
NULL
NULL
NULL
)
constructor_type
(
NULL
)
{
}
const
glsl_type
*
constructor_type
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
virtual
void
hir_no_rvalue
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
}
;
class
ast_compound_statement
:
public
ast_node
{
public
:
ast_compound_statement
(
int
new_scope
ast_node
*
statements
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
int
new_scope
;
exec_list
statements
;
}
;
class
ast_declaration
:
public
ast_node
{
public
:
ast_declaration
(
const
char
*
identifier
ast_array_specifier
*
array_specifier
ast_expression
*
initializer
)
;
virtual
void
print
(
void
)
const
;
const
char
*
identifier
;
ast_array_specifier
*
array_specifier
;
ast_expression
*
initializer
;
}
;
enum
{
ast_precision_none
=
0
ast_precision_high
ast_precision_medium
ast_precision_low
}
;
enum
{
ast_depth_none
=
0
ast_depth_any
ast_depth_greater
ast_depth_less
ast_depth_unchanged
}
;
struct
ast_type_qualifier
{
DECLARE_RALLOC_CXX_OPERATORS
(
ast_type_qualifier
)
;
DECLARE_BITSET_T
(
bitset_t
96
)
;
union
flags
{
struct
{
unsigned
invariant
:
1
;
unsigned
precise
:
1
;
unsigned
constant
:
1
;
unsigned
attribute
:
1
;
unsigned
varying
:
1
;
unsigned
in
:
1
;
unsigned
out
:
1
;
unsigned
centroid
:
1
;
unsigned
sample
:
1
;
unsigned
patch
:
1
;
unsigned
uniform
:
1
;
unsigned
buffer
:
1
;
unsigned
shared_storage
:
1
;
unsigned
smooth
:
1
;
unsigned
flat
:
1
;
unsigned
noperspective
:
1
;
unsigned
origin_upper_left
:
1
;
unsigned
pixel_center_integer
:
1
;
unsigned
explicit_align
:
1
;
unsigned
explicit_location
:
1
;
unsigned
explicit_index
:
1
;
unsigned
explicit_component
:
1
;
unsigned
explicit_binding
:
1
;
unsigned
explicit_offset
:
1
;
unsigned
depth_type
:
1
;
unsigned
std140
:
1
;
unsigned
std430
:
1
;
unsigned
shared
:
1
;
unsigned
packed
:
1
;
unsigned
column_major
:
1
;
unsigned
row_major
:
1
;
unsigned
prim_type
:
1
;
unsigned
max_vertices
:
1
;
unsigned
local_size
:
3
;
unsigned
local_size_variable
:
1
;
unsigned
early_fragment_tests
:
1
;
unsigned
explicit_image_format
:
1
;
unsigned
coherent
:
1
;
unsigned
_volatile
:
1
;
unsigned
restrict_flag
:
1
;
unsigned
read_only
:
1
;
unsigned
write_only
:
1
;
unsigned
invocations
:
1
;
unsigned
stream
:
1
;
unsigned
explicit_stream
:
1
;
unsigned
explicit_xfb_offset
:
1
;
unsigned
xfb_buffer
:
1
;
unsigned
explicit_xfb_buffer
:
1
;
unsigned
xfb_stride
:
1
;
unsigned
explicit_xfb_stride
:
1
;
unsigned
vertex_spacing
:
1
;
unsigned
ordering
:
1
;
unsigned
point_mode
:
1
;
unsigned
vertices
:
1
;
unsigned
subroutine
:
1
;
unsigned
blend_support
:
1
;
unsigned
post_depth_coverage
:
1
;
unsigned
pixel_interlock_ordered
:
1
;
unsigned
pixel_interlock_unordered
:
1
;
unsigned
sample_interlock_ordered
:
1
;
unsigned
sample_interlock_unordered
:
1
;
unsigned
inner_coverage
:
1
;
unsigned
bindless_sampler
:
1
;
unsigned
bindless_image
:
1
;
unsigned
bound_sampler
:
1
;
unsigned
bound_image
:
1
;
unsigned
non_coherent
:
1
;
unsigned
derivative_group
:
1
;
}
q
;
bitset_t
i
;
}
flags
;
unsigned
precision
:
2
;
unsigned
depth_type
:
3
;
ast_expression
*
align
;
ast_layout_expression
*
invocations
;
ast_expression
*
location
;
ast_expression
*
index
;
ast_expression
*
component
;
ast_layout_expression
*
max_vertices
;
ast_expression
*
stream
;
ast_expression
*
xfb_buffer
;
ast_expression
*
xfb_stride
;
ast_layout_expression
*
out_xfb_stride
[
MAX_FEEDBACK_BUFFERS
]
;
GLenum
prim_type
;
ast_expression
*
binding
;
ast_expression
*
offset
;
ast_layout_expression
*
local_size
[
3
]
;
enum
gl_tess_spacing
vertex_spacing
;
GLenum
ordering
;
bool
point_mode
;
ast_layout_expression
*
vertices
;
GLenum
image_format
;
enum
gl_derivative_group
derivative_group
;
glsl_base_type
image_base_type
;
bool
has_interpolation
(
)
const
;
bool
has_layout
(
)
const
;
bool
has_storage
(
)
const
;
bool
has_auxiliary_storage
(
)
const
;
bool
has_memory
(
)
const
;
bool
is_subroutine_decl
(
)
const
;
bool
merge_qualifier
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
const
ast_type_qualifier
&
q
bool
is_single_layout_merge
bool
is_multiple_layouts_merge
=
false
)
;
bool
validate_out_qualifier
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
)
;
bool
merge_into_out_qualifier
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
ast_node
*
&
node
)
;
bool
validate_in_qualifier
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
)
;
bool
merge_into_in_qualifier
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
ast_node
*
&
node
)
;
bool
push_to_global
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
)
;
bool
validate_flags
(
YYLTYPE
*
loc
_mesa_glsl_parse_state
*
state
const
ast_type_qualifier
&
allowed_flags
const
char
*
message
const
char
*
name
)
;
ast_subroutine_list
*
subroutine_list
;
}
;
class
ast_declarator_list
;
class
ast_struct_specifier
:
public
ast_node
{
public
:
ast_struct_specifier
(
const
char
*
identifier
ast_declarator_list
*
declarator_list
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
const
char
*
name
;
ast_type_qualifier
*
layout
;
exec_list
declarations
;
bool
is_declaration
;
const
glsl_type
*
type
;
}
;
class
ast_type_specifier
:
public
ast_node
{
public
:
ast_type_specifier
(
const
char
*
name
)
:
type
(
NULL
)
type_name
(
name
)
structure
(
NULL
)
array_specifier
(
NULL
)
default_precision
(
ast_precision_none
)
{
}
ast_type_specifier
(
ast_struct_specifier
*
s
)
:
type
(
NULL
)
type_name
(
s
-
>
name
)
structure
(
s
)
array_specifier
(
NULL
)
default_precision
(
ast_precision_none
)
{
}
ast_type_specifier
(
const
glsl_type
*
t
)
:
type
(
t
)
type_name
(
t
-
>
name
)
structure
(
NULL
)
array_specifier
(
NULL
)
default_precision
(
ast_precision_none
)
{
}
const
struct
glsl_type
*
glsl_type
(
const
char
*
*
name
struct
_mesa_glsl_parse_state
*
state
)
const
;
virtual
void
print
(
void
)
const
;
ir_rvalue
*
hir
(
exec_list
*
struct
_mesa_glsl_parse_state
*
)
;
const
struct
glsl_type
*
type
;
const
char
*
type_name
;
ast_struct_specifier
*
structure
;
ast_array_specifier
*
array_specifier
;
unsigned
default_precision
:
2
;
}
;
class
ast_fully_specified_type
:
public
ast_node
{
public
:
virtual
void
print
(
void
)
const
;
bool
has_qualifiers
(
_mesa_glsl_parse_state
*
state
)
const
;
ast_fully_specified_type
(
)
:
qualifier
(
)
specifier
(
NULL
)
{
}
const
struct
glsl_type
*
glsl_type
(
const
char
*
*
name
struct
_mesa_glsl_parse_state
*
state
)
const
;
ast_type_qualifier
qualifier
;
ast_type_specifier
*
specifier
;
}
;
class
ast_declarator_list
:
public
ast_node
{
public
:
ast_declarator_list
(
ast_fully_specified_type
*
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_fully_specified_type
*
type
;
exec_list
declarations
;
int
invariant
;
int
precise
;
}
;
class
ast_parameter_declarator
:
public
ast_node
{
public
:
ast_parameter_declarator
(
)
:
type
(
NULL
)
identifier
(
NULL
)
array_specifier
(
NULL
)
formal_parameter
(
false
)
is_void
(
false
)
{
}
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_fully_specified_type
*
type
;
const
char
*
identifier
;
ast_array_specifier
*
array_specifier
;
static
void
parameters_to_hir
(
exec_list
*
ast_parameters
bool
formal
exec_list
*
ir_parameters
struct
_mesa_glsl_parse_state
*
state
)
;
private
:
bool
formal_parameter
;
bool
is_void
;
}
;
class
ast_function
:
public
ast_node
{
public
:
ast_function
(
void
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_fully_specified_type
*
return_type
;
const
char
*
identifier
;
exec_list
parameters
;
private
:
bool
is_definition
;
class
ir_function_signature
*
signature
;
friend
class
ast_function_definition
;
}
;
class
ast_expression_statement
:
public
ast_node
{
public
:
ast_expression_statement
(
ast_expression
*
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_expression
*
expression
;
}
;
class
ast_case_label
:
public
ast_node
{
public
:
ast_case_label
(
ast_expression
*
test_value
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_expression
*
test_value
;
}
;
class
ast_case_label_list
:
public
ast_node
{
public
:
ast_case_label_list
(
void
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
exec_list
labels
;
}
;
class
ast_case_statement
:
public
ast_node
{
public
:
ast_case_statement
(
ast_case_label_list
*
labels
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_case_label_list
*
labels
;
exec_list
stmts
;
}
;
class
ast_case_statement_list
:
public
ast_node
{
public
:
ast_case_statement_list
(
void
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
exec_list
cases
;
}
;
class
ast_switch_body
:
public
ast_node
{
public
:
ast_switch_body
(
ast_case_statement_list
*
stmts
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_case_statement_list
*
stmts
;
}
;
class
ast_selection_statement
:
public
ast_node
{
public
:
ast_selection_statement
(
ast_expression
*
condition
ast_node
*
then_statement
ast_node
*
else_statement
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_expression
*
condition
;
ast_node
*
then_statement
;
ast_node
*
else_statement
;
}
;
class
ast_switch_statement
:
public
ast_node
{
public
:
ast_switch_statement
(
ast_expression
*
test_expression
ast_node
*
body
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_expression
*
test_expression
;
ast_node
*
body
;
protected
:
void
test_to_hir
(
exec_list
*
struct
_mesa_glsl_parse_state
*
)
;
}
;
class
ast_iteration_statement
:
public
ast_node
{
public
:
ast_iteration_statement
(
int
mode
ast_node
*
init
ast_node
*
condition
ast_expression
*
rest_expression
ast_node
*
body
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
struct
_mesa_glsl_parse_state
*
)
;
enum
ast_iteration_modes
{
ast_for
ast_while
ast_do_while
}
mode
;
ast_node
*
init_statement
;
ast_node
*
condition
;
ast_expression
*
rest_expression
;
ast_node
*
body
;
void
condition_to_hir
(
exec_list
*
struct
_mesa_glsl_parse_state
*
)
;
}
;
class
ast_jump_statement
:
public
ast_node
{
public
:
ast_jump_statement
(
int
mode
ast_expression
*
return_value
)
;
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
enum
ast_jump_modes
{
ast_continue
ast_break
ast_return
ast_discard
}
mode
;
ast_expression
*
opt_return_value
;
}
;
class
ast_demote_statement
:
public
ast_node
{
public
:
ast_demote_statement
(
void
)
{
}
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
}
;
class
ast_function_definition
:
public
ast_node
{
public
:
ast_function_definition
(
)
:
prototype
(
NULL
)
body
(
NULL
)
{
}
virtual
void
print
(
void
)
const
;
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_function
*
prototype
;
ast_compound_statement
*
body
;
}
;
class
ast_interface_block
:
public
ast_node
{
public
:
ast_interface_block
(
const
char
*
instance_name
ast_array_specifier
*
array_specifier
)
:
block_name
(
NULL
)
instance_name
(
instance_name
)
array_specifier
(
array_specifier
)
{
}
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
ast_type_qualifier
default_layout
;
ast_type_qualifier
layout
;
const
char
*
block_name
;
const
char
*
instance_name
;
exec_list
declarations
;
ast_array_specifier
*
array_specifier
;
}
;
class
ast_tcs_output_layout
:
public
ast_node
{
public
:
ast_tcs_output_layout
(
const
struct
YYLTYPE
&
locp
)
{
set_location
(
locp
)
;
}
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
}
;
class
ast_gs_input_layout
:
public
ast_node
{
public
:
ast_gs_input_layout
(
const
struct
YYLTYPE
&
locp
GLenum
prim_type
)
:
prim_type
(
prim_type
)
{
set_location
(
locp
)
;
}
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
private
:
const
GLenum
prim_type
;
}
;
class
ast_cs_input_layout
:
public
ast_node
{
public
:
ast_cs_input_layout
(
const
struct
YYLTYPE
&
locp
ast_layout_expression
*
const
*
local_size
)
{
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
this
-
>
local_size
[
i
]
=
local_size
[
i
]
;
}
set_location
(
locp
)
;
}
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
private
:
ast_layout_expression
*
local_size
[
3
]
;
}
;
class
ast_warnings_toggle
:
public
ast_node
{
public
:
ast_warnings_toggle
(
bool
_enable
)
:
enable
(
_enable
)
{
}
virtual
ir_rvalue
*
hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
private
:
bool
enable
;
}
;
extern
void
_mesa_ast_to_hir
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
extern
ir_rvalue
*
_mesa_ast_field_selection_to_hir
(
const
ast_expression
*
expr
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
extern
ir_rvalue
*
_mesa_ast_array_index_to_hir
(
void
*
mem_ctx
struct
_mesa_glsl_parse_state
*
state
ir_rvalue
*
array
ir_rvalue
*
idx
YYLTYPE
&
loc
YYLTYPE
&
idx_loc
)
;
extern
void
_mesa_ast_set_aggregate_type
(
const
glsl_type
*
type
ast_expression
*
expr
)
;
void
emit_function
(
_mesa_glsl_parse_state
*
state
ir_function
*
f
)
;
extern
void
check_builtin_array_max_size
(
const
char
*
name
unsigned
size
YYLTYPE
loc
struct
_mesa_glsl_parse_state
*
state
)
;
extern
void
_mesa_ast_process_interface_block
(
YYLTYPE
*
locp
_mesa_glsl_parse_state
*
state
ast_interface_block
*
const
block
const
struct
ast_type_qualifier
&
q
)
;
extern
bool
process_qualifier_constant
(
struct
_mesa_glsl_parse_state
*
state
YYLTYPE
*
loc
const
char
*
qual_indentifier
ast_expression
*
const_expression
unsigned
*
value
)
;
#
endif
