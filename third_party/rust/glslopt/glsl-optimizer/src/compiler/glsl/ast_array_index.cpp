#
include
"
ast
.
h
"
#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
ir
.
h
"
void
ast_array_specifier
:
:
print
(
void
)
const
{
foreach_list_typed
(
ast_node
array_dimension
link
&
this
-
>
array_dimensions
)
{
printf
(
"
[
"
)
;
if
(
(
(
ast_expression
*
)
array_dimension
)
-
>
oper
!
=
ast_unsized_array_dim
)
array_dimension
-
>
print
(
)
;
printf
(
"
]
"
)
;
}
}
static
void
update_max_array_access
(
ir_rvalue
*
ir
int
idx
YYLTYPE
*
loc
struct
_mesa_glsl_parse_state
*
state
)
{
if
(
ir_dereference_variable
*
deref_var
=
ir
-
>
as_dereference_variable
(
)
)
{
ir_variable
*
var
=
deref_var
-
>
var
;
if
(
idx
>
(
int
)
var
-
>
data
.
max_array_access
)
{
var
-
>
data
.
max_array_access
=
idx
;
check_builtin_array_max_size
(
var
-
>
name
idx
+
1
*
loc
state
)
;
}
}
else
if
(
ir_dereference_record
*
deref_record
=
ir
-
>
as_dereference_record
(
)
)
{
ir_dereference_variable
*
deref_var
=
deref_record
-
>
record
-
>
as_dereference_variable
(
)
;
if
(
deref_var
=
=
NULL
)
{
ir_dereference_array
*
deref_array
=
deref_record
-
>
record
-
>
as_dereference_array
(
)
;
ir_dereference_array
*
deref_array_prev
=
NULL
;
while
(
deref_array
!
=
NULL
)
{
deref_array_prev
=
deref_array
;
deref_array
=
deref_array
-
>
array
-
>
as_dereference_array
(
)
;
}
if
(
deref_array_prev
!
=
NULL
)
deref_var
=
deref_array_prev
-
>
array
-
>
as_dereference_variable
(
)
;
}
if
(
deref_var
!
=
NULL
)
{
if
(
deref_var
-
>
var
-
>
is_interface_instance
(
)
)
{
unsigned
field_idx
=
deref_record
-
>
field_idx
;
assert
(
field_idx
<
deref_var
-
>
var
-
>
get_interface_type
(
)
-
>
length
)
;
int
*
const
max_ifc_array_access
=
deref_var
-
>
var
-
>
get_max_ifc_array_access
(
)
;
assert
(
max_ifc_array_access
!
=
NULL
)
;
if
(
idx
>
max_ifc_array_access
[
field_idx
]
)
{
max_ifc_array_access
[
field_idx
]
=
idx
;
const
char
*
field_name
=
deref_record
-
>
record
-
>
type
-
>
fields
.
structure
[
field_idx
]
.
name
;
check_builtin_array_max_size
(
field_name
idx
+
1
*
loc
state
)
;
}
}
}
}
}
static
int
get_implicit_array_size
(
struct
_mesa_glsl_parse_state
*
state
ir_rvalue
*
array
)
{
ir_variable
*
var
=
array
-
>
variable_referenced
(
)
;
if
(
state
-
>
stage
=
=
MESA_SHADER_TESS_CTRL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
return
state
-
>
Const
.
MaxPatchVertices
;
}
if
(
state
-
>
stage
=
=
MESA_SHADER_TESS_EVAL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
!
var
-
>
data
.
patch
)
{
return
state
-
>
Const
.
MaxPatchVertices
;
}
return
0
;
}
ir_rvalue
*
_mesa_ast_array_index_to_hir
(
void
*
mem_ctx
struct
_mesa_glsl_parse_state
*
state
ir_rvalue
*
array
ir_rvalue
*
idx
YYLTYPE
&
loc
YYLTYPE
&
idx_loc
)
{
if
(
!
array
-
>
type
-
>
is_error
(
)
&
&
!
array
-
>
type
-
>
is_array
(
)
&
&
!
array
-
>
type
-
>
is_matrix
(
)
&
&
!
array
-
>
type
-
>
is_vector
(
)
)
{
_mesa_glsl_error
(
&
idx_loc
state
"
cannot
dereference
non
-
array
/
non
-
matrix
/
"
"
non
-
vector
"
)
;
}
if
(
!
idx
-
>
type
-
>
is_error
(
)
)
{
if
(
!
idx
-
>
type
-
>
is_integer_32
(
)
)
{
_mesa_glsl_error
(
&
idx_loc
state
"
array
index
must
be
integer
type
"
)
;
}
else
if
(
!
idx
-
>
type
-
>
is_scalar
(
)
)
{
_mesa_glsl_error
(
&
idx_loc
state
"
array
index
must
be
scalar
"
)
;
}
}
ir_constant
*
const
const_index
=
idx
-
>
constant_expression_value
(
mem_ctx
)
;
if
(
const_index
!
=
NULL
&
&
idx
-
>
type
-
>
is_integer_32
(
)
)
{
const
int
idx
=
const_index
-
>
value
.
i
[
0
]
;
const
char
*
type_name
=
"
error
"
;
unsigned
bound
=
0
;
if
(
array
-
>
type
-
>
is_matrix
(
)
)
{
if
(
array
-
>
type
-
>
row_type
(
)
-
>
vector_elements
<
=
idx
)
{
type_name
=
"
matrix
"
;
bound
=
array
-
>
type
-
>
row_type
(
)
-
>
vector_elements
;
}
}
else
if
(
array
-
>
type
-
>
is_vector
(
)
)
{
if
(
array
-
>
type
-
>
vector_elements
<
=
idx
)
{
type_name
=
"
vector
"
;
bound
=
array
-
>
type
-
>
vector_elements
;
}
}
else
{
if
(
(
array
-
>
type
-
>
array_size
(
)
>
0
)
&
&
(
array
-
>
type
-
>
array_size
(
)
<
=
idx
)
)
{
type_name
=
"
array
"
;
bound
=
array
-
>
type
-
>
array_size
(
)
;
}
}
if
(
bound
>
0
)
{
_mesa_glsl_error
(
&
loc
state
"
%
s
index
must
be
<
%
u
"
type_name
bound
)
;
}
else
if
(
idx
<
0
)
{
_mesa_glsl_error
(
&
loc
state
"
%
s
index
must
be
>
=
0
"
type_name
)
;
}
if
(
array
-
>
type
-
>
is_array
(
)
)
update_max_array_access
(
array
idx
&
loc
state
)
;
}
else
if
(
const_index
=
=
NULL
&
&
array
-
>
type
-
>
is_array
(
)
)
{
if
(
array
-
>
type
-
>
is_unsized_array
(
)
)
{
int
implicit_size
=
get_implicit_array_size
(
state
array
)
;
if
(
implicit_size
)
{
ir_variable
*
v
=
array
-
>
whole_variable_referenced
(
)
;
if
(
v
!
=
NULL
)
v
-
>
data
.
max_array_access
=
implicit_size
-
1
;
}
else
if
(
state
-
>
stage
=
=
MESA_SHADER_TESS_CTRL
&
&
array
-
>
variable_referenced
(
)
-
>
data
.
mode
=
=
ir_var_shader_out
&
&
!
array
-
>
variable_referenced
(
)
-
>
data
.
patch
)
{
}
else
if
(
array
-
>
variable_referenced
(
)
-
>
data
.
mode
!
=
ir_var_shader_storage
)
{
_mesa_glsl_error
(
&
loc
state
"
unsized
array
index
must
be
constant
"
)
;
}
else
{
ir_variable
*
var
=
array
-
>
variable_referenced
(
)
;
const
glsl_type
*
iface_type
=
var
-
>
get_interface_type
(
)
;
int
field_index
=
iface_type
-
>
field_index
(
var
-
>
name
)
;
if
(
field_index
>
=
0
&
&
field_index
!
=
(
int
)
iface_type
-
>
length
-
1
)
{
_mesa_glsl_error
(
&
loc
state
"
Indirect
access
on
unsized
"
"
array
is
limited
to
the
last
member
of
"
"
SSBO
.
"
)
;
}
}
}
else
if
(
array
-
>
type
-
>
without_array
(
)
-
>
is_interface
(
)
&
&
(
(
array
-
>
variable_referenced
(
)
-
>
data
.
mode
=
=
ir_var_uniform
&
&
!
state
-
>
is_version
(
400
320
)
&
&
!
state
-
>
ARB_gpu_shader5_enable
&
&
!
state
-
>
EXT_gpu_shader5_enable
&
&
!
state
-
>
OES_gpu_shader5_enable
)
|
|
(
array
-
>
variable_referenced
(
)
-
>
data
.
mode
=
=
ir_var_shader_storage
&
&
!
state
-
>
is_version
(
400
0
)
&
&
!
state
-
>
ARB_gpu_shader5_enable
)
)
)
{
_mesa_glsl_error
(
&
loc
state
"
%
s
block
array
index
must
be
constant
"
array
-
>
variable_referenced
(
)
-
>
data
.
mode
=
=
ir_var_uniform
?
"
uniform
"
:
"
shader
storage
"
)
;
}
else
{
ir_variable
*
v
=
array
-
>
whole_variable_referenced
(
)
;
if
(
v
!
=
NULL
)
v
-
>
data
.
max_array_access
=
array
-
>
type
-
>
array_size
(
)
-
1
;
}
if
(
array
-
>
type
-
>
without_array
(
)
-
>
is_sampler
(
)
)
{
if
(
!
state
-
>
is_version
(
400
320
)
&
&
!
state
-
>
ARB_gpu_shader5_enable
&
&
!
state
-
>
EXT_gpu_shader5_enable
&
&
!
state
-
>
OES_gpu_shader5_enable
&
&
!
state
-
>
has_bindless
(
)
)
{
if
(
state
-
>
is_version
(
130
300
)
)
_mesa_glsl_error
(
&
loc
state
"
sampler
arrays
indexed
with
non
-
constant
"
"
expressions
are
forbidden
in
GLSL
%
s
"
"
and
later
"
state
-
>
es_shader
?
"
ES
3
.
00
"
:
"
1
.
30
"
)
;
else
if
(
state
-
>
es_shader
)
_mesa_glsl_warning
(
&
loc
state
"
sampler
arrays
indexed
with
non
-
constant
"
"
expressions
will
be
forbidden
in
GLSL
"
"
3
.
00
and
later
"
)
;
else
_mesa_glsl_warning
(
&
loc
state
"
sampler
arrays
indexed
with
non
-
constant
"
"
expressions
will
be
forbidden
in
GLSL
"
"
1
.
30
and
later
"
)
;
}
}
if
(
state
-
>
es_shader
&
&
array
-
>
type
-
>
without_array
(
)
-
>
is_image
(
)
)
{
_mesa_glsl_error
(
&
loc
state
"
image
arrays
indexed
with
non
-
constant
"
"
expressions
are
forbidden
in
GLSL
ES
.
"
)
;
}
}
if
(
array
-
>
type
-
>
is_array
(
)
|
|
array
-
>
type
-
>
is_matrix
(
)
|
|
array
-
>
type
-
>
is_vector
(
)
)
{
return
new
(
mem_ctx
)
ir_dereference_array
(
array
idx
)
;
}
else
if
(
array
-
>
type
-
>
is_error
(
)
)
{
return
array
;
}
else
{
ir_rvalue
*
result
=
new
(
mem_ctx
)
ir_dereference_array
(
array
idx
)
;
result
-
>
type
=
glsl_type
:
:
error_type
;
return
result
;
}
}
