#
include
"
main
/
macros
.
h
"
#
include
"
glsl_symbol_table
.
h
"
#
include
"
ir_rvalue_visitor
.
h
"
#
include
"
ir
.
h
"
#
include
"
program
/
prog_instruction
.
h
"
#
include
"
main
/
mtypes
.
h
"
#
define
GLSL_CLIP_VAR_NAME
"
gl_ClipDistanceMESA
"
namespace
{
class
lower_distance_visitor
:
public
ir_rvalue_visitor
{
public
:
explicit
lower_distance_visitor
(
gl_shader_stage
shader_stage
const
char
*
in_name
int
total_size
int
offset
)
:
progress
(
false
)
old_distance_out_var
(
NULL
)
old_distance_in_var
(
NULL
)
new_distance_out_var
(
NULL
)
new_distance_in_var
(
NULL
)
shader_stage
(
shader_stage
)
in_name
(
in_name
)
total_size
(
total_size
)
offset
(
offset
)
{
}
explicit
lower_distance_visitor
(
gl_shader_stage
shader_stage
const
char
*
in_name
const
lower_distance_visitor
*
orig
int
offset
)
:
progress
(
false
)
old_distance_out_var
(
NULL
)
old_distance_in_var
(
NULL
)
new_distance_out_var
(
orig
-
>
new_distance_out_var
)
new_distance_in_var
(
orig
-
>
new_distance_in_var
)
shader_stage
(
shader_stage
)
in_name
(
in_name
)
total_size
(
orig
-
>
total_size
)
offset
(
offset
)
{
}
virtual
ir_visitor_status
visit
(
ir_variable
*
)
;
void
create_indices
(
ir_rvalue
*
ir_rvalue
*
&
ir_rvalue
*
&
)
;
bool
is_distance_vec8
(
ir_rvalue
*
ir
)
;
ir_rvalue
*
lower_distance_vec8
(
ir_rvalue
*
ir
)
;
virtual
ir_visitor_status
visit_leave
(
ir_assignment
*
)
;
void
visit_new_assignment
(
ir_assignment
*
ir
)
;
virtual
ir_visitor_status
visit_leave
(
ir_call
*
)
;
virtual
void
handle_rvalue
(
ir_rvalue
*
*
rvalue
)
;
void
fix_lhs
(
ir_assignment
*
)
;
bool
progress
;
ir_variable
*
old_distance_out_var
;
ir_variable
*
old_distance_in_var
;
ir_variable
*
new_distance_out_var
;
ir_variable
*
new_distance_in_var
;
const
gl_shader_stage
shader_stage
;
const
char
*
in_name
;
int
total_size
;
int
offset
;
}
;
}
ir_visitor_status
lower_distance_visitor
:
:
visit
(
ir_variable
*
ir
)
{
ir_variable
*
*
old_var
;
ir_variable
*
*
new_var
;
if
(
!
ir
-
>
name
|
|
strcmp
(
ir
-
>
name
in_name
)
!
=
0
)
return
visit_continue
;
assert
(
ir
-
>
type
-
>
is_array
(
)
)
;
if
(
ir
-
>
data
.
mode
=
=
ir_var_shader_out
)
{
if
(
this
-
>
old_distance_out_var
)
return
visit_continue
;
old_var
=
&
old_distance_out_var
;
new_var
=
&
new_distance_out_var
;
}
else
if
(
ir
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
if
(
this
-
>
old_distance_in_var
)
return
visit_continue
;
old_var
=
&
old_distance_in_var
;
new_var
=
&
new_distance_in_var
;
}
else
{
unreachable
(
"
not
reached
"
)
;
}
this
-
>
progress
=
true
;
*
old_var
=
ir
;
if
(
!
(
*
new_var
)
)
{
unsigned
new_size
=
(
total_size
+
3
)
/
4
;
*
new_var
=
ir
-
>
clone
(
ralloc_parent
(
ir
)
NULL
)
;
(
*
new_var
)
-
>
name
=
ralloc_strdup
(
*
new_var
GLSL_CLIP_VAR_NAME
)
;
(
*
new_var
)
-
>
data
.
location
=
VARYING_SLOT_CLIP_DIST0
;
if
(
!
ir
-
>
type
-
>
fields
.
array
-
>
is_array
(
)
)
{
assert
(
(
ir
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
this
-
>
shader_stage
=
=
MESA_SHADER_FRAGMENT
)
|
|
(
ir
-
>
data
.
mode
=
=
ir_var_shader_out
&
&
(
this
-
>
shader_stage
=
=
MESA_SHADER_VERTEX
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_EVAL
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_GEOMETRY
)
)
)
;
assert
(
ir
-
>
type
-
>
fields
.
array
=
=
glsl_type
:
:
float_type
)
;
(
*
new_var
)
-
>
data
.
max_array_access
=
new_size
-
1
;
(
*
new_var
)
-
>
type
=
glsl_type
:
:
get_array_instance
(
glsl_type
:
:
vec4_type
new_size
)
;
}
else
{
assert
(
(
ir
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
(
this
-
>
shader_stage
=
=
MESA_SHADER_GEOMETRY
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_EVAL
)
)
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_CTRL
)
;
assert
(
ir
-
>
type
-
>
fields
.
array
-
>
fields
.
array
=
=
glsl_type
:
:
float_type
)
;
(
*
new_var
)
-
>
type
=
glsl_type
:
:
get_array_instance
(
glsl_type
:
:
get_array_instance
(
glsl_type
:
:
vec4_type
new_size
)
ir
-
>
type
-
>
array_size
(
)
)
;
}
ir
-
>
replace_with
(
*
new_var
)
;
}
else
{
ir
-
>
remove
(
)
;
}
return
visit_continue
;
}
void
lower_distance_visitor
:
:
create_indices
(
ir_rvalue
*
old_index
ir_rvalue
*
&
array_index
ir_rvalue
*
&
swizzle_index
)
{
void
*
ctx
=
ralloc_parent
(
old_index
)
;
if
(
old_index
-
>
type
!
=
glsl_type
:
:
int_type
)
{
assert
(
old_index
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
old_index
=
new
(
ctx
)
ir_expression
(
ir_unop_u2i
old_index
)
;
}
ir_constant
*
old_index_constant
=
old_index
-
>
constant_expression_value
(
ctx
)
;
if
(
old_index_constant
)
{
int
const_val
=
old_index_constant
-
>
get_int_component
(
0
)
+
offset
;
array_index
=
new
(
ctx
)
ir_constant
(
const_val
/
4
)
;
swizzle_index
=
new
(
ctx
)
ir_constant
(
const_val
%
4
)
;
}
else
{
ir_variable
*
old_index_var
=
new
(
ctx
)
ir_variable
(
glsl_type
:
:
int_type
"
distance_index
"
ir_var_temporary
)
;
this
-
>
base_ir
-
>
insert_before
(
old_index_var
)
;
this
-
>
base_ir
-
>
insert_before
(
new
(
ctx
)
ir_assignment
(
new
(
ctx
)
ir_dereference_variable
(
old_index_var
)
old_index
)
)
;
array_index
=
new
(
ctx
)
ir_expression
(
ir_binop_rshift
new
(
ctx
)
ir_expression
(
ir_binop_add
new
(
ctx
)
ir_dereference_variable
(
old_index_var
)
new
(
ctx
)
ir_constant
(
offset
)
)
new
(
ctx
)
ir_constant
(
2
)
)
;
swizzle_index
=
new
(
ctx
)
ir_expression
(
ir_binop_bit_and
new
(
ctx
)
ir_expression
(
ir_binop_add
new
(
ctx
)
ir_dereference_variable
(
old_index_var
)
new
(
ctx
)
ir_constant
(
offset
)
)
new
(
ctx
)
ir_constant
(
3
)
)
;
}
}
bool
lower_distance_visitor
:
:
is_distance_vec8
(
ir_rvalue
*
ir
)
{
if
(
!
ir
-
>
type
-
>
is_array
(
)
)
return
false
;
if
(
ir
-
>
type
-
>
fields
.
array
!
=
glsl_type
:
:
float_type
)
return
false
;
if
(
this
-
>
old_distance_out_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_distance_out_var
)
return
true
;
}
if
(
this
-
>
old_distance_in_var
)
{
assert
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_CTRL
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_EVAL
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_GEOMETRY
|
|
this
-
>
shader_stage
=
=
MESA_SHADER_FRAGMENT
)
;
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_distance_in_var
)
return
true
;
}
return
false
;
}
ir_rvalue
*
lower_distance_visitor
:
:
lower_distance_vec8
(
ir_rvalue
*
ir
)
{
if
(
!
ir
-
>
type
-
>
is_array
(
)
)
return
NULL
;
if
(
ir
-
>
type
-
>
fields
.
array
!
=
glsl_type
:
:
float_type
)
return
NULL
;
ir_variable
*
*
new_var
=
NULL
;
if
(
this
-
>
old_distance_out_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_distance_out_var
)
new_var
=
&
this
-
>
new_distance_out_var
;
}
if
(
this
-
>
old_distance_in_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_distance_in_var
)
new_var
=
&
this
-
>
new_distance_in_var
;
}
if
(
new_var
=
=
NULL
)
return
NULL
;
if
(
ir
-
>
as_dereference_variable
(
)
)
{
return
new
(
ralloc_parent
(
ir
)
)
ir_dereference_variable
(
*
new_var
)
;
}
else
{
ir_dereference_array
*
array_ref
=
ir
-
>
as_dereference_array
(
)
;
assert
(
array_ref
)
;
assert
(
array_ref
-
>
array
-
>
as_dereference_variable
(
)
)
;
return
new
(
ralloc_parent
(
ir
)
)
ir_dereference_array
(
*
new_var
array_ref
-
>
array_index
)
;
}
}
void
lower_distance_visitor
:
:
handle_rvalue
(
ir_rvalue
*
*
rv
)
{
if
(
*
rv
=
=
NULL
)
return
;
ir_dereference_array
*
const
array_deref
=
(
*
rv
)
-
>
as_dereference_array
(
)
;
if
(
array_deref
=
=
NULL
)
return
;
ir_rvalue
*
lowered_vec8
=
this
-
>
lower_distance_vec8
(
array_deref
-
>
array
)
;
if
(
lowered_vec8
!
=
NULL
)
{
this
-
>
progress
=
true
;
ir_rvalue
*
array_index
;
ir_rvalue
*
swizzle_index
;
this
-
>
create_indices
(
array_deref
-
>
array_index
array_index
swizzle_index
)
;
void
*
mem_ctx
=
ralloc_parent
(
array_deref
)
;
ir_dereference_array
*
const
new_array_deref
=
new
(
mem_ctx
)
ir_dereference_array
(
lowered_vec8
array_index
)
;
ir_expression
*
const
expr
=
new
(
mem_ctx
)
ir_expression
(
ir_binop_vector_extract
new_array_deref
swizzle_index
)
;
*
rv
=
expr
;
}
}
void
lower_distance_visitor
:
:
fix_lhs
(
ir_assignment
*
ir
)
{
if
(
ir
-
>
lhs
-
>
ir_type
=
=
ir_type_expression
)
{
void
*
mem_ctx
=
ralloc_parent
(
ir
)
;
ir_expression
*
const
expr
=
(
ir_expression
*
)
ir
-
>
lhs
;
assert
(
expr
-
>
operation
=
=
ir_binop_vector_extract
)
;
assert
(
expr
-
>
operands
[
0
]
-
>
ir_type
=
=
ir_type_dereference_array
)
;
assert
(
expr
-
>
operands
[
0
]
-
>
type
=
=
glsl_type
:
:
vec4_type
)
;
ir_dereference
*
const
new_lhs
=
(
ir_dereference
*
)
expr
-
>
operands
[
0
]
;
ir
-
>
rhs
=
new
(
mem_ctx
)
ir_expression
(
ir_triop_vector_insert
glsl_type
:
:
vec4_type
new_lhs
-
>
clone
(
mem_ctx
NULL
)
ir
-
>
rhs
expr
-
>
operands
[
1
]
)
;
ir
-
>
set_lhs
(
new_lhs
)
;
ir
-
>
write_mask
=
WRITEMASK_XYZW
;
}
}
ir_visitor_status
lower_distance_visitor
:
:
visit_leave
(
ir_assignment
*
ir
)
{
ir_rvalue_visitor
:
:
visit_leave
(
ir
)
;
if
(
this
-
>
is_distance_vec8
(
ir
-
>
lhs
)
|
|
this
-
>
is_distance_vec8
(
ir
-
>
rhs
)
)
{
void
*
ctx
=
ralloc_parent
(
ir
)
;
int
array_size
=
ir
-
>
lhs
-
>
type
-
>
array_size
(
)
;
for
(
int
i
=
0
;
i
<
array_size
;
+
+
i
)
{
ir_dereference_array
*
new_lhs
=
new
(
ctx
)
ir_dereference_array
(
ir
-
>
lhs
-
>
clone
(
ctx
NULL
)
new
(
ctx
)
ir_constant
(
i
)
)
;
ir_dereference_array
*
new_rhs
=
new
(
ctx
)
ir_dereference_array
(
ir
-
>
rhs
-
>
clone
(
ctx
NULL
)
new
(
ctx
)
ir_constant
(
i
)
)
;
this
-
>
handle_rvalue
(
(
ir_rvalue
*
*
)
&
new_rhs
)
;
ir_assignment
*
const
assign
=
new
(
ctx
)
ir_assignment
(
new_lhs
new_rhs
)
;
this
-
>
handle_rvalue
(
(
ir_rvalue
*
*
)
&
assign
-
>
lhs
)
;
this
-
>
fix_lhs
(
assign
)
;
this
-
>
base_ir
-
>
insert_before
(
assign
)
;
}
ir
-
>
remove
(
)
;
return
visit_continue
;
}
handle_rvalue
(
(
ir_rvalue
*
*
)
&
ir
-
>
lhs
)
;
this
-
>
fix_lhs
(
ir
)
;
return
rvalue_visit
(
ir
)
;
}
void
lower_distance_visitor
:
:
visit_new_assignment
(
ir_assignment
*
ir
)
{
ir_instruction
*
old_base_ir
=
this
-
>
base_ir
;
this
-
>
base_ir
=
ir
;
ir
-
>
accept
(
this
)
;
this
-
>
base_ir
=
old_base_ir
;
}
ir_visitor_status
lower_distance_visitor
:
:
visit_leave
(
ir_call
*
ir
)
{
void
*
ctx
=
ralloc_parent
(
ir
)
;
const
exec_node
*
formal_param_node
=
ir
-
>
callee
-
>
parameters
.
get_head_raw
(
)
;
const
exec_node
*
actual_param_node
=
ir
-
>
actual_parameters
.
get_head_raw
(
)
;
while
(
!
actual_param_node
-
>
is_tail_sentinel
(
)
)
{
ir_variable
*
formal_param
=
(
ir_variable
*
)
formal_param_node
;
ir_rvalue
*
actual_param
=
(
ir_rvalue
*
)
actual_param_node
;
formal_param_node
=
formal_param_node
-
>
next
;
actual_param_node
=
actual_param_node
-
>
next
;
if
(
this
-
>
is_distance_vec8
(
actual_param
)
)
{
ir_variable
*
temp_clip_distance
=
new
(
ctx
)
ir_variable
(
actual_param
-
>
type
"
temp_clip_distance
"
ir_var_temporary
)
;
this
-
>
base_ir
-
>
insert_before
(
temp_clip_distance
)
;
actual_param
-
>
replace_with
(
new
(
ctx
)
ir_dereference_variable
(
temp_clip_distance
)
)
;
if
(
formal_param
-
>
data
.
mode
=
=
ir_var_function_in
|
|
formal_param
-
>
data
.
mode
=
=
ir_var_function_inout
)
{
ir_assignment
*
new_assignment
=
new
(
ctx
)
ir_assignment
(
new
(
ctx
)
ir_dereference_variable
(
temp_clip_distance
)
actual_param
-
>
clone
(
ctx
NULL
)
)
;
this
-
>
base_ir
-
>
insert_before
(
new_assignment
)
;
this
-
>
visit_new_assignment
(
new_assignment
)
;
}
if
(
formal_param
-
>
data
.
mode
=
=
ir_var_function_out
|
|
formal_param
-
>
data
.
mode
=
=
ir_var_function_inout
)
{
ir_assignment
*
new_assignment
=
new
(
ctx
)
ir_assignment
(
actual_param
-
>
clone
(
ctx
NULL
)
new
(
ctx
)
ir_dereference_variable
(
temp_clip_distance
)
)
;
this
-
>
base_ir
-
>
insert_after
(
new_assignment
)
;
this
-
>
visit_new_assignment
(
new_assignment
)
;
}
}
}
return
rvalue_visit
(
ir
)
;
}
namespace
{
class
lower_distance_visitor_counter
:
public
ir_rvalue_visitor
{
public
:
explicit
lower_distance_visitor_counter
(
void
)
:
in_clip_size
(
0
)
in_cull_size
(
0
)
out_clip_size
(
0
)
out_cull_size
(
0
)
{
}
virtual
ir_visitor_status
visit
(
ir_variable
*
)
;
virtual
void
handle_rvalue
(
ir_rvalue
*
*
rvalue
)
;
int
in_clip_size
;
int
in_cull_size
;
int
out_clip_size
;
int
out_cull_size
;
}
;
}
ir_visitor_status
lower_distance_visitor_counter
:
:
visit
(
ir_variable
*
ir
)
{
int
*
clip_size
*
cull_size
;
if
(
!
ir
-
>
name
)
return
visit_continue
;
if
(
ir
-
>
data
.
mode
=
=
ir_var_shader_out
)
{
clip_size
=
&
out_clip_size
;
cull_size
=
&
out_cull_size
;
}
else
if
(
ir
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
clip_size
=
&
in_clip_size
;
cull_size
=
&
in_cull_size
;
}
else
return
visit_continue
;
if
(
ir
-
>
type
-
>
is_unsized_array
(
)
)
return
visit_continue
;
if
(
*
clip_size
=
=
0
)
{
if
(
!
strcmp
(
ir
-
>
name
"
gl_ClipDistance
"
)
)
{
if
(
!
ir
-
>
type
-
>
fields
.
array
-
>
is_array
(
)
)
*
clip_size
=
ir
-
>
type
-
>
array_size
(
)
;
else
*
clip_size
=
ir
-
>
type
-
>
fields
.
array
-
>
array_size
(
)
;
}
}
if
(
*
cull_size
=
=
0
)
{
if
(
!
strcmp
(
ir
-
>
name
"
gl_CullDistance
"
)
)
{
if
(
!
ir
-
>
type
-
>
fields
.
array
-
>
is_array
(
)
)
*
cull_size
=
ir
-
>
type
-
>
array_size
(
)
;
else
*
cull_size
=
ir
-
>
type
-
>
fields
.
array
-
>
array_size
(
)
;
}
}
return
visit_continue
;
}
void
lower_distance_visitor_counter
:
:
handle_rvalue
(
ir_rvalue
*
*
)
{
return
;
}
bool
lower_clip_cull_distance
(
struct
gl_shader_program
*
prog
struct
gl_linked_shader
*
shader
)
{
int
clip_size
cull_size
;
lower_distance_visitor_counter
count
;
visit_list_elements
(
&
count
shader
-
>
ir
)
;
clip_size
=
MAX2
(
count
.
in_clip_size
count
.
out_clip_size
)
;
cull_size
=
MAX2
(
count
.
in_cull_size
count
.
out_cull_size
)
;
if
(
clip_size
=
=
0
&
&
cull_size
=
=
0
)
return
false
;
lower_distance_visitor
v
(
shader
-
>
Stage
"
gl_ClipDistance
"
clip_size
+
cull_size
0
)
;
visit_list_elements
(
&
v
shader
-
>
ir
)
;
lower_distance_visitor
v2
(
shader
-
>
Stage
"
gl_CullDistance
"
&
v
clip_size
)
;
visit_list_elements
(
&
v2
shader
-
>
ir
)
;
if
(
v2
.
new_distance_out_var
)
shader
-
>
symbols
-
>
add_variable
(
v2
.
new_distance_out_var
)
;
if
(
v2
.
new_distance_in_var
)
shader
-
>
symbols
-
>
add_variable
(
v2
.
new_distance_in_var
)
;
return
v2
.
progress
;
}
