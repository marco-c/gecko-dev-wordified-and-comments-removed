#
include
"
glsl_optimizer
.
h
"
#
include
"
ast
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
glsl_parser
.
h
"
#
include
"
ir_optimization
.
h
"
#
include
"
ir_print_glsl_visitor
.
h
"
#
include
"
ir_print_visitor
.
h
"
#
include
"
loop_analysis
.
h
"
#
include
"
program
.
h
"
#
include
"
linker
.
h
"
#
include
"
main
/
mtypes
.
h
"
#
include
"
standalone_scaffolding
.
h
"
#
include
"
builtin_functions
.
h
"
#
include
"
program
/
program
.
h
"
static
void
init_gl_program
(
struct
gl_program
*
prog
bool
is_arb_asm
GLenum
target
)
{
prog
-
>
RefCount
=
1
;
prog
-
>
Format
=
GL_PROGRAM_FORMAT_ASCII_ARB
;
prog
-
>
is_arb_asm
=
is_arb_asm
;
prog
-
>
info
.
stage
=
(
gl_shader_stage
)
_mesa_program_enum_to_shader_stage
(
target
)
;
}
static
struct
gl_program
*
new_program
(
UNUSED
struct
gl_context
*
ctx
GLenum
target
UNUSED
GLuint
id
bool
is_arb_asm
)
{
switch
(
target
)
{
case
GL_VERTEX_PROGRAM_ARB
:
case
GL_GEOMETRY_PROGRAM_NV
:
case
GL_TESS_CONTROL_PROGRAM_NV
:
case
GL_TESS_EVALUATION_PROGRAM_NV
:
case
GL_FRAGMENT_PROGRAM_ARB
:
case
GL_COMPUTE_PROGRAM_NV
:
{
struct
gl_program
*
prog
=
rzalloc
(
NULL
struct
gl_program
)
;
init_gl_program
(
prog
is_arb_asm
target
)
;
return
prog
;
}
default
:
printf
(
"
bad
target
in
new_program
\
n
"
)
;
return
NULL
;
}
}
static
void
initialize_mesa_context
(
struct
gl_context
*
ctx
glslopt_target
api
)
{
gl_api
mesaAPI
;
switch
(
api
)
{
default
:
case
kGlslTargetOpenGL
:
mesaAPI
=
API_OPENGL_COMPAT
;
break
;
case
kGlslTargetOpenGLES20
:
mesaAPI
=
API_OPENGLES2
;
break
;
case
kGlslTargetOpenGLES30
:
mesaAPI
=
API_OPENGL_CORE
;
break
;
case
kGlslTargetMetal
:
mesaAPI
=
API_OPENGL_CORE
;
break
;
}
initialize_context_to_defaults
(
ctx
mesaAPI
)
;
_mesa_glsl_builtin_functions_init_or_ref
(
)
;
switch
(
api
)
{
default
:
case
kGlslTargetOpenGL
:
ctx
-
>
Const
.
GLSLVersion
=
150
;
break
;
case
kGlslTargetOpenGLES20
:
ctx
-
>
Extensions
.
OES_standard_derivatives
=
true
;
ctx
-
>
Extensions
.
EXT_shader_framebuffer_fetch
=
true
;
break
;
case
kGlslTargetOpenGLES30
:
ctx
-
>
Extensions
.
ARB_ES3_compatibility
=
true
;
ctx
-
>
Extensions
.
EXT_shader_framebuffer_fetch
=
true
;
break
;
case
kGlslTargetMetal
:
ctx
-
>
Extensions
.
ARB_ES3_compatibility
=
true
;
ctx
-
>
Extensions
.
EXT_shader_framebuffer_fetch
=
true
;
break
;
}
ctx
-
>
Const
.
MaxTextureCoordUnits
=
16
;
ctx
-
>
Const
.
Program
[
MESA_SHADER_VERTEX
]
.
MaxTextureImageUnits
=
16
;
ctx
-
>
Const
.
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
=
16
;
ctx
-
>
Const
.
Program
[
MESA_SHADER_GEOMETRY
]
.
MaxTextureImageUnits
=
16
;
ctx
-
>
Const
.
MaxDrawBuffers
=
4
;
ctx
-
>
Driver
.
NewProgram
=
new_program
;
}
struct
glslopt_ctx
{
glslopt_ctx
(
glslopt_target
target
)
{
this
-
>
target
=
target
;
mem_ctx
=
ralloc_context
(
NULL
)
;
initialize_mesa_context
(
&
mesa_ctx
target
)
;
}
~
glslopt_ctx
(
)
{
ralloc_free
(
mem_ctx
)
;
}
struct
gl_context
mesa_ctx
;
void
*
mem_ctx
;
glslopt_target
target
;
}
;
glslopt_ctx
*
glslopt_initialize
(
glslopt_target
target
)
{
return
new
glslopt_ctx
(
target
)
;
}
void
glslopt_cleanup
(
glslopt_ctx
*
ctx
)
{
delete
ctx
;
}
void
glslopt_set_max_unroll_iterations
(
glslopt_ctx
*
ctx
unsigned
iterations
)
{
for
(
int
i
=
0
;
i
<
MESA_SHADER_STAGES
;
+
+
i
)
ctx
-
>
mesa_ctx
.
Const
.
ShaderCompilerOptions
[
i
]
.
MaxUnrollIterations
=
iterations
;
}
struct
glslopt_shader_var
{
const
char
*
name
;
glslopt_basic_type
type
;
glslopt_precision
prec
;
int
vectorSize
;
int
matrixSize
;
int
arraySize
;
int
location
;
}
;
struct
glslopt_shader
{
static
void
*
operator
new
(
size_t
size
void
*
ctx
)
{
void
*
node
;
node
=
ralloc_size
(
ctx
size
)
;
assert
(
node
!
=
NULL
)
;
return
node
;
}
static
void
operator
delete
(
void
*
node
)
{
ralloc_free
(
node
)
;
}
glslopt_shader
(
)
:
rawOutput
(
0
)
optimizedOutput
(
0
)
status
(
false
)
uniformCount
(
0
)
uniformsSize
(
0
)
inputCount
(
0
)
textureCount
(
0
)
statsMath
(
0
)
statsTex
(
0
)
statsFlow
(
0
)
{
infoLog
=
"
Shader
not
compiled
yet
"
;
whole_program
=
rzalloc
(
NULL
struct
gl_shader_program
)
;
assert
(
whole_program
!
=
NULL
)
;
whole_program
-
>
data
=
rzalloc
(
whole_program
struct
gl_shader_program_data
)
;
assert
(
whole_program
-
>
data
!
=
NULL
)
;
whole_program
-
>
data
-
>
InfoLog
=
ralloc_strdup
(
whole_program
-
>
data
"
"
)
;
whole_program
-
>
Shaders
=
reralloc
(
whole_program
whole_program
-
>
Shaders
struct
gl_shader
*
whole_program
-
>
NumShaders
+
1
)
;
assert
(
whole_program
-
>
Shaders
!
=
NULL
)
;
shader
=
rzalloc
(
whole_program
gl_shader
)
;
whole_program
-
>
Shaders
[
whole_program
-
>
NumShaders
]
=
shader
;
whole_program
-
>
NumShaders
+
+
;
whole_program
-
>
data
-
>
LinkStatus
=
LINKING_SUCCESS
;
}
~
glslopt_shader
(
)
{
for
(
unsigned
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
ralloc_free
(
whole_program
-
>
_LinkedShaders
[
i
]
)
;
ralloc_free
(
whole_program
)
;
ralloc_free
(
rawOutput
)
;
ralloc_free
(
optimizedOutput
)
;
}
struct
gl_shader_program
*
whole_program
;
struct
gl_shader
*
shader
;
static
const
int
kMaxShaderUniforms
=
1024
;
static
const
int
kMaxShaderInputs
=
128
;
static
const
int
kMaxShaderTextures
=
128
;
glslopt_shader_var
uniforms
[
kMaxShaderUniforms
]
;
glslopt_shader_var
inputs
[
kMaxShaderInputs
]
;
glslopt_shader_var
textures
[
kMaxShaderInputs
]
;
int
uniformCount
uniformsSize
;
int
inputCount
;
int
textureCount
;
int
statsMath
statsTex
statsFlow
;
char
*
rawOutput
;
char
*
optimizedOutput
;
const
char
*
infoLog
;
bool
status
;
}
;
static
inline
void
debug_print_ir
(
const
char
*
name
exec_list
*
ir
_mesa_glsl_parse_state
*
state
void
*
memctx
)
{
#
if
0
printf
(
"
*
*
*
*
%
s
:
\
n
"
name
)
;
char
*
foobar
=
_mesa_print_ir_glsl
(
ir
state
ralloc_strdup
(
memctx
"
"
)
kPrintGlslFragment
)
;
printf
(
"
%
s
\
n
"
foobar
)
;
validate_ir_tree
(
ir
)
;
#
endif
}
static
void
do_optimization_passes
(
exec_list
*
ir
bool
linked
_mesa_glsl_parse_state
*
state
void
*
mem_ctx
)
{
bool
progress
;
int
passes
=
0
kMaximumPasses
=
1000
;
do
{
progress
=
false
;
+
+
passes
;
bool
progress2
;
debug_print_ir
(
"
Initial
"
ir
state
mem_ctx
)
;
if
(
linked
)
{
progress2
=
do_function_inlining
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
inlining
"
ir
state
mem_ctx
)
;
progress2
=
do_dead_functions
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
dead
functions
"
ir
state
mem_ctx
)
;
progress2
=
do_structure_splitting
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
struct
splitting
"
ir
state
mem_ctx
)
;
}
progress2
=
do_if_simplification
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
if
simpl
"
ir
state
mem_ctx
)
;
progress2
=
opt_flatten_nested_if_blocks
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
if
flatten
"
ir
state
mem_ctx
)
;
progress2
=
do_copy_propagation_elements
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
copy
propagation
elems
"
ir
state
mem_ctx
)
;
if
(
linked
)
{
progress2
=
do_vectorize
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
vectorize
"
ir
state
mem_ctx
)
;
}
if
(
linked
)
{
progress2
=
do_dead_code
(
ir
false
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
dead
code
"
ir
state
mem_ctx
)
;
}
else
{
progress2
=
do_dead_code_unlinked
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
dead
code
unlinked
"
ir
state
mem_ctx
)
;
}
progress2
=
do_dead_code_local
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
dead
code
local
"
ir
state
mem_ctx
)
;
progress2
=
do_tree_grafting
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
tree
grafting
"
ir
state
mem_ctx
)
;
progress2
=
do_constant_propagation
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
const
propagation
"
ir
state
mem_ctx
)
;
if
(
linked
)
{
progress2
=
do_constant_variable
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
const
variable
"
ir
state
mem_ctx
)
;
}
else
{
progress2
=
do_constant_variable_unlinked
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
const
variable
unlinked
"
ir
state
mem_ctx
)
;
}
progress2
=
do_constant_folding
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
const
folding
"
ir
state
mem_ctx
)
;
progress2
=
do_minmax_prune
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
minmax
prune
"
ir
state
mem_ctx
)
;
progress2
=
do_rebalance_tree
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
rebalance
tree
"
ir
state
mem_ctx
)
;
progress2
=
do_algebraic
(
ir
state
-
>
ctx
-
>
Const
.
NativeIntegers
&
state
-
>
ctx
-
>
Const
.
ShaderCompilerOptions
[
state
-
>
stage
]
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
algebraic
"
ir
state
mem_ctx
)
;
progress2
=
do_lower_jumps
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
lower
jumps
"
ir
state
mem_ctx
)
;
progress2
=
do_vec_index_to_swizzle
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
vec
index
to
swizzle
"
ir
state
mem_ctx
)
;
progress2
=
lower_vector_insert
(
ir
false
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
lower
vector
insert
"
ir
state
mem_ctx
)
;
progress2
=
optimize_swizzles
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
optimize
swizzles
"
ir
state
mem_ctx
)
;
progress2
=
optimize_split_arrays
(
ir
linked
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
split
arrays
"
ir
state
mem_ctx
)
;
progress2
=
optimize_redundant_jumps
(
ir
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
redundant
jumps
"
ir
state
mem_ctx
)
;
if
(
linked
)
{
loop_state
*
ls
=
analyze_loop_variables
(
ir
)
;
if
(
ls
-
>
loop_found
)
{
progress2
=
unroll_loops
(
ir
ls
&
state
-
>
ctx
-
>
Const
.
ShaderCompilerOptions
[
state
-
>
stage
]
)
;
progress
|
=
progress2
;
if
(
progress2
)
debug_print_ir
(
"
After
unroll
"
ir
state
mem_ctx
)
;
}
delete
ls
;
}
}
while
(
progress
&
&
passes
<
kMaximumPasses
)
;
lower_instructions
(
ir
SAT_TO_CLAMP
)
;
}
static
void
find_shader_variables
(
glslopt_shader
*
sh
exec_list
*
ir
)
{
foreach_in_list
(
ir_instruction
node
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
)
continue
;
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
if
(
sh
-
>
inputCount
>
=
glslopt_shader
:
:
kMaxShaderInputs
)
continue
;
glslopt_shader_var
&
v
=
sh
-
>
inputs
[
sh
-
>
inputCount
]
;
v
.
name
=
ralloc_strdup
(
sh
var
-
>
name
)
;
v
.
location
=
var
-
>
data
.
explicit_location
?
var
-
>
data
.
location
:
-
1
;
+
+
sh
-
>
inputCount
;
}
if
(
var
-
>
data
.
mode
=
=
ir_var_uniform
&
&
!
var
-
>
type
-
>
is_sampler
(
)
)
{
if
(
sh
-
>
uniformCount
>
=
glslopt_shader
:
:
kMaxShaderUniforms
)
continue
;
glslopt_shader_var
&
v
=
sh
-
>
uniforms
[
sh
-
>
uniformCount
]
;
v
.
name
=
ralloc_strdup
(
sh
var
-
>
name
)
;
v
.
location
=
var
-
>
data
.
explicit_location
?
var
-
>
data
.
location
:
-
1
;
+
+
sh
-
>
uniformCount
;
}
if
(
var
-
>
data
.
mode
=
=
ir_var_uniform
&
&
var
-
>
type
-
>
is_sampler
(
)
)
{
if
(
sh
-
>
textureCount
>
=
glslopt_shader
:
:
kMaxShaderTextures
)
continue
;
glslopt_shader_var
&
v
=
sh
-
>
textures
[
sh
-
>
textureCount
]
;
v
.
name
=
ralloc_strdup
(
sh
var
-
>
name
)
;
v
.
location
=
var
-
>
data
.
explicit_location
?
var
-
>
data
.
location
:
-
1
;
+
+
sh
-
>
textureCount
;
}
}
}
glslopt_shader
*
glslopt_optimize
(
glslopt_ctx
*
ctx
glslopt_shader_type
type
const
char
*
shaderSource
unsigned
options
)
{
glslopt_shader
*
shader
=
new
(
ctx
-
>
mem_ctx
)
glslopt_shader
(
)
;
PrintGlslMode
printMode
=
kPrintGlslVertex
;
switch
(
type
)
{
case
kGlslOptShaderVertex
:
shader
-
>
shader
-
>
Type
=
GL_VERTEX_SHADER
;
shader
-
>
shader
-
>
Stage
=
MESA_SHADER_VERTEX
;
printMode
=
kPrintGlslVertex
;
break
;
case
kGlslOptShaderFragment
:
shader
-
>
shader
-
>
Type
=
GL_FRAGMENT_SHADER
;
shader
-
>
shader
-
>
Stage
=
MESA_SHADER_FRAGMENT
;
printMode
=
kPrintGlslFragment
;
break
;
}
if
(
!
shader
-
>
shader
-
>
Type
)
{
shader
-
>
infoLog
=
ralloc_asprintf
(
shader
"
Unknown
shader
type
%
d
"
(
int
)
type
)
;
shader
-
>
status
=
false
;
return
shader
;
}
_mesa_glsl_parse_state
*
state
=
new
(
shader
)
_mesa_glsl_parse_state
(
&
ctx
-
>
mesa_ctx
shader
-
>
shader
-
>
Stage
shader
)
;
state
-
>
error
=
0
;
if
(
!
(
options
&
kGlslOptionSkipPreprocessor
)
)
{
state
-
>
error
=
!
!
glcpp_preprocess
(
state
&
shaderSource
&
state
-
>
info_log
add_builtin_defines
state
&
ctx
-
>
mesa_ctx
)
;
if
(
state
-
>
error
)
{
shader
-
>
status
=
!
state
-
>
error
;
shader
-
>
infoLog
=
state
-
>
info_log
;
return
shader
;
}
}
_mesa_glsl_lexer_ctor
(
state
shaderSource
)
;
_mesa_glsl_parse
(
state
)
;
_mesa_glsl_lexer_dtor
(
state
)
;
exec_list
*
ir
=
new
(
shader
)
exec_list
(
)
;
shader
-
>
shader
-
>
ir
=
ir
;
if
(
!
state
-
>
error
&
&
!
state
-
>
translation_unit
.
is_empty
(
)
)
_mesa_ast_to_hir
(
ir
state
)
;
if
(
!
state
-
>
error
)
{
validate_ir_tree
(
ir
)
;
shader
-
>
rawOutput
=
_mesa_print_ir_glsl
(
ir
state
ralloc_strdup
(
shader
"
"
)
printMode
)
;
}
shader
-
>
shader
-
>
symbols
=
state
-
>
symbols
;
struct
gl_linked_shader
*
linked_shader
=
NULL
;
if
(
!
state
-
>
error
&
&
!
ir
-
>
is_empty
(
)
&
&
!
(
options
&
kGlslOptionNotFullShader
)
)
{
linked_shader
=
link_intrastage_shaders
(
shader
&
ctx
-
>
mesa_ctx
shader
-
>
whole_program
shader
-
>
whole_program
-
>
Shaders
shader
-
>
whole_program
-
>
NumShaders
true
)
;
if
(
!
linked_shader
)
{
shader
-
>
status
=
false
;
shader
-
>
infoLog
=
shader
-
>
whole_program
-
>
data
-
>
InfoLog
;
return
shader
;
}
ir
=
linked_shader
-
>
ir
;
debug_print_ir
(
"
=
=
=
=
After
link
=
=
=
=
"
ir
state
shader
)
;
}
if
(
!
state
-
>
error
&
&
!
ir
-
>
is_empty
(
)
)
{
const
bool
linked
=
!
(
options
&
kGlslOptionNotFullShader
)
;
do_optimization_passes
(
ir
linked
state
shader
)
;
validate_ir_tree
(
ir
)
;
}
if
(
!
state
-
>
error
)
{
shader
-
>
optimizedOutput
=
_mesa_print_ir_glsl
(
ir
state
ralloc_strdup
(
shader
"
"
)
printMode
)
;
}
shader
-
>
status
=
!
state
-
>
error
;
shader
-
>
infoLog
=
state
-
>
info_log
;
find_shader_variables
(
shader
ir
)
;
ralloc_free
(
ir
)
;
ralloc_free
(
state
)
;
if
(
linked_shader
)
ralloc_free
(
linked_shader
)
;
return
shader
;
}
void
glslopt_shader_delete
(
glslopt_shader
*
shader
)
{
delete
shader
;
}
bool
glslopt_get_status
(
glslopt_shader
*
shader
)
{
return
shader
-
>
status
;
}
const
char
*
glslopt_get_output
(
glslopt_shader
*
shader
)
{
return
shader
-
>
optimizedOutput
;
}
const
char
*
glslopt_get_raw_output
(
glslopt_shader
*
shader
)
{
return
shader
-
>
rawOutput
;
}
const
char
*
glslopt_get_log
(
glslopt_shader
*
shader
)
{
return
shader
-
>
infoLog
;
}
int
glslopt_shader_get_input_count
(
glslopt_shader
*
shader
)
{
return
shader
-
>
inputCount
;
}
int
glslopt_shader_get_uniform_count
(
glslopt_shader
*
shader
)
{
return
shader
-
>
uniformCount
;
}
int
glslopt_shader_get_uniform_total_size
(
glslopt_shader
*
shader
)
{
return
shader
-
>
uniformsSize
;
}
int
glslopt_shader_get_texture_count
(
glslopt_shader
*
shader
)
{
return
shader
-
>
textureCount
;
}
void
glslopt_shader_get_input_desc
(
glslopt_shader
*
shader
int
index
const
char
*
*
outName
glslopt_basic_type
*
outType
glslopt_precision
*
outPrec
int
*
outVecSize
int
*
outMatSize
int
*
outArraySize
int
*
outLocation
)
{
const
glslopt_shader_var
&
v
=
shader
-
>
inputs
[
index
]
;
*
outName
=
v
.
name
;
*
outType
=
v
.
type
;
*
outPrec
=
v
.
prec
;
*
outVecSize
=
v
.
vectorSize
;
*
outMatSize
=
v
.
matrixSize
;
*
outArraySize
=
v
.
arraySize
;
*
outLocation
=
v
.
location
;
}
void
glslopt_shader_get_uniform_desc
(
glslopt_shader
*
shader
int
index
const
char
*
*
outName
glslopt_basic_type
*
outType
glslopt_precision
*
outPrec
int
*
outVecSize
int
*
outMatSize
int
*
outArraySize
int
*
outLocation
)
{
const
glslopt_shader_var
&
v
=
shader
-
>
uniforms
[
index
]
;
*
outName
=
v
.
name
;
*
outType
=
v
.
type
;
*
outPrec
=
v
.
prec
;
*
outVecSize
=
v
.
vectorSize
;
*
outMatSize
=
v
.
matrixSize
;
*
outArraySize
=
v
.
arraySize
;
*
outLocation
=
v
.
location
;
}
void
glslopt_shader_get_texture_desc
(
glslopt_shader
*
shader
int
index
const
char
*
*
outName
glslopt_basic_type
*
outType
glslopt_precision
*
outPrec
int
*
outVecSize
int
*
outMatSize
int
*
outArraySize
int
*
outLocation
)
{
const
glslopt_shader_var
&
v
=
shader
-
>
textures
[
index
]
;
*
outName
=
v
.
name
;
*
outType
=
v
.
type
;
*
outPrec
=
v
.
prec
;
*
outVecSize
=
v
.
vectorSize
;
*
outMatSize
=
v
.
matrixSize
;
*
outArraySize
=
v
.
arraySize
;
*
outLocation
=
v
.
location
;
}
void
glslopt_shader_get_stats
(
glslopt_shader
*
shader
int
*
approxMath
int
*
approxTex
int
*
approxFlow
)
{
*
approxMath
=
shader
-
>
statsMath
;
*
approxTex
=
shader
-
>
statsTex
;
*
approxFlow
=
shader
-
>
statsFlow
;
}
