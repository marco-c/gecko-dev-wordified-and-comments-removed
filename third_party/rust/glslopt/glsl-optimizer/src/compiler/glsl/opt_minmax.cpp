#
include
"
ir
.
h
"
#
include
"
ir_visitor
.
h
"
#
include
"
ir_rvalue_visitor
.
h
"
#
include
"
ir_optimization
.
h
"
#
include
"
ir_builder
.
h
"
#
include
"
program
/
prog_instruction
.
h
"
#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
main
/
macros
.
h
"
#
include
"
util
/
half_float
.
h
"
using
namespace
ir_builder
;
namespace
{
enum
compare_components_result
{
LESS
LESS_OR_EQUAL
EQUAL
GREATER_OR_EQUAL
GREATER
MIXED
}
;
class
minmax_range
{
public
:
minmax_range
(
ir_constant
*
low
=
NULL
ir_constant
*
high
=
NULL
)
{
this
-
>
low
=
low
;
this
-
>
high
=
high
;
}
ir_constant
*
low
;
ir_constant
*
high
;
}
;
class
ir_minmax_visitor
:
public
ir_rvalue_enter_visitor
{
public
:
ir_minmax_visitor
(
)
:
progress
(
false
)
{
}
ir_rvalue
*
prune_expression
(
ir_expression
*
expr
minmax_range
baserange
)
;
void
handle_rvalue
(
ir_rvalue
*
*
rvalue
)
;
bool
progress
;
}
;
static
enum
compare_components_result
compare_components
(
ir_constant
*
a
ir_constant
*
b
)
{
assert
(
a
!
=
NULL
)
;
assert
(
b
!
=
NULL
)
;
assert
(
a
-
>
type
-
>
base_type
=
=
b
-
>
type
-
>
base_type
)
;
unsigned
a_inc
=
a
-
>
type
-
>
is_scalar
(
)
?
0
:
1
;
unsigned
b_inc
=
b
-
>
type
-
>
is_scalar
(
)
?
0
:
1
;
unsigned
components
=
MAX2
(
a
-
>
type
-
>
components
(
)
b
-
>
type
-
>
components
(
)
)
;
bool
foundless
=
false
;
bool
foundgreater
=
false
;
bool
foundequal
=
false
;
for
(
unsigned
i
=
0
c0
=
0
c1
=
0
;
i
<
components
;
c0
+
=
a_inc
c1
+
=
b_inc
+
+
i
)
{
switch
(
a
-
>
type
-
>
base_type
)
{
case
GLSL_TYPE_UINT
:
if
(
a
-
>
value
.
u
[
c0
]
<
b
-
>
value
.
u
[
c1
]
)
foundless
=
true
;
else
if
(
a
-
>
value
.
u
[
c0
]
>
b
-
>
value
.
u
[
c1
]
)
foundgreater
=
true
;
else
foundequal
=
true
;
break
;
case
GLSL_TYPE_INT
:
if
(
a
-
>
value
.
i
[
c0
]
<
b
-
>
value
.
i
[
c1
]
)
foundless
=
true
;
else
if
(
a
-
>
value
.
i
[
c0
]
>
b
-
>
value
.
i
[
c1
]
)
foundgreater
=
true
;
else
foundequal
=
true
;
break
;
case
GLSL_TYPE_FLOAT16
:
{
float
af
=
_mesa_half_to_float
(
a
-
>
value
.
f16
[
c0
]
)
;
float
bf
=
_mesa_half_to_float
(
b
-
>
value
.
f16
[
c1
]
)
;
if
(
af
<
bf
)
foundless
=
true
;
else
if
(
af
>
bf
)
foundgreater
=
true
;
else
foundequal
=
true
;
break
;
}
case
GLSL_TYPE_FLOAT
:
if
(
a
-
>
value
.
f
[
c0
]
<
b
-
>
value
.
f
[
c1
]
)
foundless
=
true
;
else
if
(
a
-
>
value
.
f
[
c0
]
>
b
-
>
value
.
f
[
c1
]
)
foundgreater
=
true
;
else
foundequal
=
true
;
break
;
case
GLSL_TYPE_DOUBLE
:
if
(
a
-
>
value
.
d
[
c0
]
<
b
-
>
value
.
d
[
c1
]
)
foundless
=
true
;
else
if
(
a
-
>
value
.
d
[
c0
]
>
b
-
>
value
.
d
[
c1
]
)
foundgreater
=
true
;
else
foundequal
=
true
;
break
;
default
:
unreachable
(
"
not
reached
"
)
;
}
}
if
(
foundless
&
&
foundgreater
)
{
return
MIXED
;
}
if
(
foundequal
)
{
if
(
foundless
)
return
LESS_OR_EQUAL
;
if
(
foundgreater
)
return
GREATER_OR_EQUAL
;
return
EQUAL
;
}
return
foundless
?
LESS
:
GREATER
;
}
static
ir_constant
*
combine_constant
(
bool
ismin
ir_constant
*
a
ir_constant
*
b
)
{
void
*
mem_ctx
=
ralloc_parent
(
a
)
;
ir_constant
*
c
=
a
-
>
clone
(
mem_ctx
NULL
)
;
for
(
unsigned
i
=
0
;
i
<
c
-
>
type
-
>
components
(
)
;
i
+
+
)
{
switch
(
c
-
>
type
-
>
base_type
)
{
case
GLSL_TYPE_UINT
:
if
(
(
ismin
&
&
b
-
>
value
.
u
[
i
]
<
c
-
>
value
.
u
[
i
]
)
|
|
(
!
ismin
&
&
b
-
>
value
.
u
[
i
]
>
c
-
>
value
.
u
[
i
]
)
)
c
-
>
value
.
u
[
i
]
=
b
-
>
value
.
u
[
i
]
;
break
;
case
GLSL_TYPE_INT
:
if
(
(
ismin
&
&
b
-
>
value
.
i
[
i
]
<
c
-
>
value
.
i
[
i
]
)
|
|
(
!
ismin
&
&
b
-
>
value
.
i
[
i
]
>
c
-
>
value
.
i
[
i
]
)
)
c
-
>
value
.
i
[
i
]
=
b
-
>
value
.
i
[
i
]
;
break
;
case
GLSL_TYPE_FLOAT16
:
{
float
bf
=
_mesa_half_to_float
(
b
-
>
value
.
f16
[
i
]
)
;
float
cf
=
_mesa_half_to_float
(
c
-
>
value
.
f16
[
i
]
)
;
if
(
(
ismin
&
&
bf
<
cf
)
|
|
(
!
ismin
&
&
bf
>
cf
)
)
c
-
>
value
.
f16
[
i
]
=
b
-
>
value
.
f16
[
i
]
;
break
;
}
case
GLSL_TYPE_FLOAT
:
if
(
(
ismin
&
&
b
-
>
value
.
f
[
i
]
<
c
-
>
value
.
f
[
i
]
)
|
|
(
!
ismin
&
&
b
-
>
value
.
f
[
i
]
>
c
-
>
value
.
f
[
i
]
)
)
c
-
>
value
.
f
[
i
]
=
b
-
>
value
.
f
[
i
]
;
break
;
case
GLSL_TYPE_DOUBLE
:
if
(
(
ismin
&
&
b
-
>
value
.
d
[
i
]
<
c
-
>
value
.
d
[
i
]
)
|
|
(
!
ismin
&
&
b
-
>
value
.
d
[
i
]
>
c
-
>
value
.
d
[
i
]
)
)
c
-
>
value
.
d
[
i
]
=
b
-
>
value
.
d
[
i
]
;
break
;
default
:
assert
(
!
"
not
reached
"
)
;
}
}
return
c
;
}
static
ir_constant
*
smaller_constant
(
ir_constant
*
a
ir_constant
*
b
)
{
assert
(
a
!
=
NULL
)
;
assert
(
b
!
=
NULL
)
;
enum
compare_components_result
ret
=
compare_components
(
a
b
)
;
if
(
ret
=
=
MIXED
)
return
combine_constant
(
true
a
b
)
;
else
if
(
ret
<
EQUAL
)
return
a
;
else
return
b
;
}
static
ir_constant
*
larger_constant
(
ir_constant
*
a
ir_constant
*
b
)
{
assert
(
a
!
=
NULL
)
;
assert
(
b
!
=
NULL
)
;
enum
compare_components_result
ret
=
compare_components
(
a
b
)
;
if
(
ret
=
=
MIXED
)
return
combine_constant
(
false
a
b
)
;
else
if
(
ret
<
EQUAL
)
return
b
;
else
return
a
;
}
static
minmax_range
combine_range
(
minmax_range
r0
minmax_range
r1
bool
ismin
)
{
minmax_range
ret
;
if
(
!
r0
.
low
)
{
ret
.
low
=
ismin
?
r0
.
low
:
r1
.
low
;
}
else
if
(
!
r1
.
low
)
{
ret
.
low
=
ismin
?
r1
.
low
:
r0
.
low
;
}
else
{
ret
.
low
=
ismin
?
smaller_constant
(
r0
.
low
r1
.
low
)
:
larger_constant
(
r0
.
low
r1
.
low
)
;
}
if
(
!
r0
.
high
)
{
ret
.
high
=
ismin
?
r1
.
high
:
r0
.
high
;
}
else
if
(
!
r1
.
high
)
{
ret
.
high
=
ismin
?
r0
.
high
:
r1
.
high
;
}
else
{
ret
.
high
=
ismin
?
smaller_constant
(
r0
.
high
r1
.
high
)
:
larger_constant
(
r0
.
high
r1
.
high
)
;
}
return
ret
;
}
static
minmax_range
range_intersection
(
minmax_range
r0
minmax_range
r1
)
{
minmax_range
ret
;
if
(
!
r0
.
low
)
ret
.
low
=
r1
.
low
;
else
if
(
!
r1
.
low
)
ret
.
low
=
r0
.
low
;
else
ret
.
low
=
larger_constant
(
r0
.
low
r1
.
low
)
;
if
(
!
r0
.
high
)
ret
.
high
=
r1
.
high
;
else
if
(
!
r1
.
high
)
ret
.
high
=
r0
.
high
;
else
ret
.
high
=
smaller_constant
(
r0
.
high
r1
.
high
)
;
return
ret
;
}
static
minmax_range
get_range
(
ir_rvalue
*
rval
)
{
ir_expression
*
expr
=
rval
-
>
as_expression
(
)
;
if
(
expr
&
&
(
expr
-
>
operation
=
=
ir_binop_min
|
|
expr
-
>
operation
=
=
ir_binop_max
)
)
{
minmax_range
r0
=
get_range
(
expr
-
>
operands
[
0
]
)
;
minmax_range
r1
=
get_range
(
expr
-
>
operands
[
1
]
)
;
return
combine_range
(
r0
r1
expr
-
>
operation
=
=
ir_binop_min
)
;
}
ir_constant
*
c
=
rval
-
>
as_constant
(
)
;
if
(
c
)
{
return
minmax_range
(
c
c
)
;
}
return
minmax_range
(
)
;
}
ir_rvalue
*
ir_minmax_visitor
:
:
prune_expression
(
ir_expression
*
expr
minmax_range
baserange
)
{
assert
(
expr
-
>
operation
=
=
ir_binop_min
|
|
expr
-
>
operation
=
=
ir_binop_max
)
;
bool
ismin
=
expr
-
>
operation
=
=
ir_binop_min
;
minmax_range
limits
[
2
]
;
for
(
unsigned
i
=
0
;
i
<
2
;
+
+
i
)
limits
[
i
]
=
get_range
(
expr
-
>
operands
[
i
]
)
;
for
(
unsigned
i
=
0
;
i
<
2
;
+
+
i
)
{
bool
is_redundant
=
false
;
enum
compare_components_result
cr
=
LESS
;
if
(
ismin
)
{
if
(
limits
[
i
]
.
low
&
&
limits
[
1
-
i
]
.
high
)
{
cr
=
compare_components
(
limits
[
i
]
.
low
limits
[
1
-
i
]
.
high
)
;
if
(
cr
>
=
EQUAL
&
&
cr
!
=
MIXED
)
is_redundant
=
true
;
}
if
(
!
is_redundant
&
&
limits
[
i
]
.
low
&
&
baserange
.
high
)
{
cr
=
compare_components
(
limits
[
i
]
.
low
baserange
.
high
)
;
if
(
cr
>
EQUAL
&
&
cr
!
=
MIXED
)
is_redundant
=
true
;
}
}
else
{
if
(
limits
[
i
]
.
high
&
&
limits
[
1
-
i
]
.
low
)
{
cr
=
compare_components
(
limits
[
i
]
.
high
limits
[
1
-
i
]
.
low
)
;
if
(
cr
<
=
EQUAL
)
is_redundant
=
true
;
}
if
(
!
is_redundant
&
&
limits
[
i
]
.
high
&
&
baserange
.
low
)
{
cr
=
compare_components
(
limits
[
i
]
.
high
baserange
.
low
)
;
if
(
cr
<
EQUAL
)
is_redundant
=
true
;
}
}
if
(
is_redundant
)
{
progress
=
true
;
ir_expression
*
op_expr
=
expr
-
>
operands
[
1
-
i
]
-
>
as_expression
(
)
;
if
(
op_expr
&
&
(
op_expr
-
>
operation
=
=
ir_binop_min
|
|
op_expr
-
>
operation
=
=
ir_binop_max
)
)
{
return
prune_expression
(
op_expr
baserange
)
;
}
return
expr
-
>
operands
[
1
-
i
]
;
}
else
if
(
cr
=
=
MIXED
)
{
ir_constant
*
a
=
expr
-
>
operands
[
0
]
-
>
as_constant
(
)
;
ir_constant
*
b
=
expr
-
>
operands
[
1
]
-
>
as_constant
(
)
;
if
(
a
&
&
b
)
return
combine_constant
(
ismin
a
b
)
;
}
}
for
(
unsigned
i
=
0
;
i
<
2
;
+
+
i
)
{
ir_expression
*
op_expr
=
expr
-
>
operands
[
i
]
-
>
as_expression
(
)
;
if
(
op_expr
&
&
(
op_expr
-
>
operation
=
=
ir_binop_min
|
|
op_expr
-
>
operation
=
=
ir_binop_max
)
)
{
if
(
ismin
)
limits
[
1
-
i
]
.
low
=
NULL
;
else
limits
[
1
-
i
]
.
high
=
NULL
;
minmax_range
base
=
range_intersection
(
limits
[
1
-
i
]
baserange
)
;
expr
-
>
operands
[
i
]
=
prune_expression
(
op_expr
base
)
;
}
}
ir_constant
*
a
=
expr
-
>
operands
[
0
]
-
>
as_constant
(
)
;
ir_constant
*
b
=
expr
-
>
operands
[
1
]
-
>
as_constant
(
)
;
if
(
a
&
&
b
)
return
combine_constant
(
ismin
a
b
)
;
return
expr
;
}
static
ir_rvalue
*
swizzle_if_required
(
ir_expression
*
expr
ir_rvalue
*
rval
)
{
if
(
expr
-
>
type
-
>
is_vector
(
)
&
&
rval
-
>
type
-
>
is_scalar
(
)
)
{
return
swizzle
(
rval
SWIZZLE_XXXX
expr
-
>
type
-
>
vector_elements
)
;
}
else
{
return
rval
;
}
}
void
ir_minmax_visitor
:
:
handle_rvalue
(
ir_rvalue
*
*
rvalue
)
{
if
(
!
*
rvalue
)
return
;
ir_expression
*
expr
=
(
*
rvalue
)
-
>
as_expression
(
)
;
if
(
!
expr
|
|
(
expr
-
>
operation
!
=
ir_binop_min
&
&
expr
-
>
operation
!
=
ir_binop_max
)
)
return
;
ir_rvalue
*
new_rvalue
=
prune_expression
(
expr
minmax_range
(
)
)
;
if
(
new_rvalue
=
=
*
rvalue
)
return
;
*
rvalue
=
swizzle_if_required
(
expr
new_rvalue
)
;
progress
=
true
;
}
}
bool
do_minmax_prune
(
exec_list
*
instructions
)
{
ir_minmax_visitor
v
;
visit_list_elements
(
&
v
instructions
)
;
return
v
.
progress
;
}
