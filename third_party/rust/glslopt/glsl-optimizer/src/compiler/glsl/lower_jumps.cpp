#
include
"
compiler
/
glsl_types
.
h
"
#
include
<
string
.
h
>
#
include
"
ir
.
h
"
enum
jump_strength
{
strength_none
strength_always_clears_execute_flag
strength_continue
strength_break
strength_return
}
;
namespace
{
struct
block_record
{
jump_strength
min_strength
;
bool
may_clear_execute_flag
;
block_record
(
)
{
this
-
>
min_strength
=
strength_none
;
this
-
>
may_clear_execute_flag
=
false
;
}
}
;
struct
loop_record
{
ir_function_signature
*
signature
;
ir_loop
*
loop
;
unsigned
nesting_depth
;
bool
in_if_at_the_end_of_the_loop
;
bool
may_set_return_flag
;
ir_variable
*
break_flag
;
ir_variable
*
execute_flag
;
loop_record
(
ir_function_signature
*
p_signature
=
0
ir_loop
*
p_loop
=
0
)
{
this
-
>
signature
=
p_signature
;
this
-
>
loop
=
p_loop
;
this
-
>
nesting_depth
=
0
;
this
-
>
in_if_at_the_end_of_the_loop
=
false
;
this
-
>
may_set_return_flag
=
false
;
this
-
>
break_flag
=
0
;
this
-
>
execute_flag
=
0
;
}
ir_variable
*
get_execute_flag
(
)
{
if
(
!
this
-
>
execute_flag
)
{
exec_list
&
list
=
this
-
>
loop
?
this
-
>
loop
-
>
body_instructions
:
signature
-
>
body
;
this
-
>
execute_flag
=
new
(
this
-
>
signature
)
ir_variable
(
glsl_type
:
:
bool_type
"
execute_flag
"
ir_var_temporary
)
;
list
.
push_head
(
new
(
this
-
>
signature
)
ir_assignment
(
new
(
this
-
>
signature
)
ir_dereference_variable
(
execute_flag
)
new
(
this
-
>
signature
)
ir_constant
(
true
)
)
)
;
list
.
push_head
(
this
-
>
execute_flag
)
;
}
return
this
-
>
execute_flag
;
}
ir_variable
*
get_break_flag
(
)
{
assert
(
this
-
>
loop
)
;
if
(
!
this
-
>
break_flag
)
{
this
-
>
break_flag
=
new
(
this
-
>
signature
)
ir_variable
(
glsl_type
:
:
bool_type
"
break_flag
"
ir_var_temporary
)
;
this
-
>
loop
-
>
insert_before
(
this
-
>
break_flag
)
;
this
-
>
loop
-
>
insert_before
(
new
(
this
-
>
signature
)
ir_assignment
(
new
(
this
-
>
signature
)
ir_dereference_variable
(
break_flag
)
new
(
this
-
>
signature
)
ir_constant
(
false
)
)
)
;
}
return
this
-
>
break_flag
;
}
}
;
struct
function_record
{
ir_function_signature
*
signature
;
ir_variable
*
return_flag
;
ir_variable
*
return_value
;
bool
lower_return
;
unsigned
nesting_depth
;
function_record
(
ir_function_signature
*
p_signature
=
0
bool
lower_return
=
false
)
{
this
-
>
signature
=
p_signature
;
this
-
>
return_flag
=
0
;
this
-
>
return_value
=
0
;
this
-
>
nesting_depth
=
0
;
this
-
>
lower_return
=
lower_return
;
}
ir_variable
*
get_return_flag
(
)
{
if
(
!
this
-
>
return_flag
)
{
this
-
>
return_flag
=
new
(
this
-
>
signature
)
ir_variable
(
glsl_type
:
:
bool_type
"
return_flag
"
ir_var_temporary
)
;
this
-
>
signature
-
>
body
.
push_head
(
new
(
this
-
>
signature
)
ir_assignment
(
new
(
this
-
>
signature
)
ir_dereference_variable
(
return_flag
)
new
(
this
-
>
signature
)
ir_constant
(
false
)
)
)
;
this
-
>
signature
-
>
body
.
push_head
(
this
-
>
return_flag
)
;
}
return
this
-
>
return_flag
;
}
ir_variable
*
get_return_value
(
)
{
if
(
!
this
-
>
return_value
)
{
assert
(
!
this
-
>
signature
-
>
return_type
-
>
is_void
(
)
)
;
return_value
=
new
(
this
-
>
signature
)
ir_variable
(
this
-
>
signature
-
>
return_type
"
return_value
"
ir_var_temporary
)
;
this
-
>
signature
-
>
body
.
push_head
(
this
-
>
return_value
)
;
}
return
this
-
>
return_value
;
}
}
;
struct
ir_lower_jumps_visitor
:
public
ir_control_flow_visitor
{
bool
progress
;
struct
function_record
function
;
struct
loop_record
loop
;
struct
block_record
block
;
bool
pull_out_jumps
;
bool
lower_continue
;
bool
lower_break
;
bool
lower_sub_return
;
bool
lower_main_return
;
ir_lower_jumps_visitor
(
)
:
progress
(
false
)
pull_out_jumps
(
false
)
lower_continue
(
false
)
lower_break
(
false
)
lower_sub_return
(
false
)
lower_main_return
(
false
)
{
}
void
truncate_after_instruction
(
exec_node
*
ir
)
{
if
(
!
ir
)
return
;
while
(
!
ir
-
>
get_next
(
)
-
>
is_tail_sentinel
(
)
)
{
(
(
ir_instruction
*
)
ir
-
>
get_next
(
)
)
-
>
remove
(
)
;
this
-
>
progress
=
true
;
}
}
void
move_outer_block_inside
(
ir_instruction
*
ir
exec_list
*
inner_block
)
{
while
(
!
ir
-
>
get_next
(
)
-
>
is_tail_sentinel
(
)
)
{
ir_instruction
*
move_ir
=
(
ir_instruction
*
)
ir
-
>
get_next
(
)
;
move_ir
-
>
remove
(
)
;
inner_block
-
>
push_tail
(
move_ir
)
;
}
}
void
insert_lowered_return
(
ir_return
*
ir
)
{
ir_variable
*
return_flag
=
this
-
>
function
.
get_return_flag
(
)
;
if
(
!
this
-
>
function
.
signature
-
>
return_type
-
>
is_void
(
)
)
{
ir_variable
*
return_value
=
this
-
>
function
.
get_return_value
(
)
;
ir
-
>
insert_before
(
new
(
ir
)
ir_assignment
(
new
(
ir
)
ir_dereference_variable
(
return_value
)
ir
-
>
value
)
)
;
}
ir
-
>
insert_before
(
new
(
ir
)
ir_assignment
(
new
(
ir
)
ir_dereference_variable
(
return_flag
)
new
(
ir
)
ir_constant
(
true
)
)
)
;
this
-
>
loop
.
may_set_return_flag
=
true
;
}
void
lower_return_unconditionally
(
ir_instruction
*
ir
)
{
if
(
get_jump_strength
(
ir
)
!
=
strength_return
)
{
return
;
}
insert_lowered_return
(
(
ir_return
*
)
ir
)
;
ir
-
>
replace_with
(
new
(
ir
)
ir_loop_jump
(
ir_loop_jump
:
:
jump_break
)
)
;
}
ir_instruction
*
create_lowered_break
(
)
{
void
*
ctx
=
this
-
>
function
.
signature
;
return
new
(
ctx
)
ir_assignment
(
new
(
ctx
)
ir_dereference_variable
(
this
-
>
loop
.
get_break_flag
(
)
)
new
(
ctx
)
ir_constant
(
true
)
)
;
}
void
lower_break_unconditionally
(
ir_instruction
*
ir
)
{
if
(
get_jump_strength
(
ir
)
!
=
strength_break
)
{
return
;
}
ir
-
>
replace_with
(
create_lowered_break
(
)
)
;
}
void
lower_final_breaks
(
exec_list
*
block
)
{
ir_instruction
*
ir
=
(
ir_instruction
*
)
block
-
>
get_tail
(
)
;
lower_break_unconditionally
(
ir
)
;
ir_if
*
ir_if
=
ir
-
>
as_if
(
)
;
if
(
ir_if
)
{
lower_break_unconditionally
(
(
ir_instruction
*
)
ir_if
-
>
then_instructions
.
get_tail
(
)
)
;
lower_break_unconditionally
(
(
ir_instruction
*
)
ir_if
-
>
else_instructions
.
get_tail
(
)
)
;
}
}
virtual
void
visit
(
class
ir_loop_jump
*
ir
)
{
truncate_after_instruction
(
ir
)
;
this
-
>
block
.
min_strength
=
ir
-
>
is_break
(
)
?
strength_break
:
strength_continue
;
}
virtual
void
visit
(
class
ir_return
*
ir
)
{
truncate_after_instruction
(
ir
)
;
this
-
>
block
.
min_strength
=
strength_return
;
}
virtual
void
visit
(
class
ir_discard
*
ir
)
{
(
void
)
ir
;
}
virtual
void
visit
(
class
ir_precision_statement
*
ir
)
{
}
virtual
void
visit
(
class
ir_typedecl_statement
*
ir
)
{
}
enum
jump_strength
get_jump_strength
(
ir_instruction
*
ir
)
{
if
(
!
ir
)
return
strength_none
;
else
if
(
ir
-
>
ir_type
=
=
ir_type_loop_jump
)
{
if
(
(
(
ir_loop_jump
*
)
ir
)
-
>
is_break
(
)
)
return
strength_break
;
else
return
strength_continue
;
}
else
if
(
ir
-
>
ir_type
=
=
ir_type_return
)
return
strength_return
;
else
return
strength_none
;
}
bool
should_lower_jump
(
ir_jump
*
ir
)
{
unsigned
strength
=
get_jump_strength
(
ir
)
;
bool
lower
;
switch
(
strength
)
{
case
strength_none
:
lower
=
false
;
break
;
case
strength_continue
:
lower
=
lower_continue
;
break
;
case
strength_break
:
assert
(
this
-
>
loop
.
loop
)
;
if
(
ir
-
>
get_next
(
)
-
>
is_tail_sentinel
(
)
&
&
(
this
-
>
loop
.
nesting_depth
=
=
0
|
|
(
this
-
>
loop
.
nesting_depth
=
=
1
&
&
this
-
>
loop
.
in_if_at_the_end_of_the_loop
)
)
)
lower
=
false
;
else
lower
=
lower_break
;
break
;
case
strength_return
:
if
(
this
-
>
function
.
nesting_depth
=
=
0
&
&
ir
-
>
get_next
(
)
-
>
is_tail_sentinel
(
)
)
lower
=
false
;
else
lower
=
this
-
>
function
.
lower_return
;
break
;
}
return
lower
;
}
block_record
visit_block
(
exec_list
*
list
)
{
block_record
saved_block
=
this
-
>
block
;
this
-
>
block
=
block_record
(
)
;
foreach_in_list
(
ir_instruction
node
list
)
{
node
-
>
accept
(
this
)
;
}
block_record
ret
=
this
-
>
block
;
this
-
>
block
=
saved_block
;
return
ret
;
}
virtual
void
visit
(
ir_if
*
ir
)
{
if
(
this
-
>
loop
.
nesting_depth
=
=
0
&
&
ir
-
>
get_next
(
)
-
>
is_tail_sentinel
(
)
)
this
-
>
loop
.
in_if_at_the_end_of_the_loop
=
true
;
+
+
this
-
>
function
.
nesting_depth
;
+
+
this
-
>
loop
.
nesting_depth
;
block_record
block_records
[
2
]
;
ir_jump
*
jumps
[
2
]
;
block_records
[
0
]
=
visit_block
(
&
ir
-
>
then_instructions
)
;
block_records
[
1
]
=
visit_block
(
&
ir
-
>
else_instructions
)
;
retry
:
for
(
unsigned
i
=
0
;
i
<
2
;
+
+
i
)
{
exec_list
&
list
=
i
?
ir
-
>
else_instructions
:
ir
-
>
then_instructions
;
jumps
[
i
]
=
0
;
if
(
!
list
.
is_empty
(
)
&
&
get_jump_strength
(
(
ir_instruction
*
)
list
.
get_tail
(
)
)
)
jumps
[
i
]
=
(
ir_jump
*
)
list
.
get_tail
(
)
;
}
for
(
;
;
)
{
jump_strength
jump_strengths
[
2
]
;
for
(
unsigned
i
=
0
;
i
<
2
;
+
+
i
)
{
if
(
jumps
[
i
]
)
{
jump_strengths
[
i
]
=
block_records
[
i
]
.
min_strength
;
assert
(
jump_strengths
[
i
]
=
=
get_jump_strength
(
jumps
[
i
]
)
)
;
}
else
jump_strengths
[
i
]
=
strength_none
;
}
if
(
pull_out_jumps
&
&
jump_strengths
[
0
]
=
=
jump_strengths
[
1
]
)
{
bool
unify
=
true
;
if
(
jump_strengths
[
0
]
=
=
strength_continue
)
ir
-
>
insert_after
(
new
(
ir
)
ir_loop_jump
(
ir_loop_jump
:
:
jump_continue
)
)
;
else
if
(
jump_strengths
[
0
]
=
=
strength_break
)
ir
-
>
insert_after
(
new
(
ir
)
ir_loop_jump
(
ir_loop_jump
:
:
jump_break
)
)
;
else
if
(
jump_strengths
[
0
]
=
=
strength_return
&
&
this
-
>
function
.
signature
-
>
return_type
-
>
is_void
(
)
)
ir
-
>
insert_after
(
new
(
ir
)
ir_return
(
NULL
)
)
;
else
unify
=
false
;
if
(
unify
)
{
jumps
[
0
]
-
>
remove
(
)
;
jumps
[
1
]
-
>
remove
(
)
;
this
-
>
progress
=
true
;
jumps
[
0
]
=
0
;
jumps
[
1
]
=
0
;
block_records
[
0
]
.
min_strength
=
strength_none
;
block_records
[
1
]
.
min_strength
=
strength_none
;
break
;
}
}
bool
should_lower
[
2
]
;
for
(
unsigned
i
=
0
;
i
<
2
;
+
+
i
)
should_lower
[
i
]
=
should_lower_jump
(
jumps
[
i
]
)
;
int
lower
;
if
(
should_lower
[
1
]
&
&
should_lower
[
0
]
)
lower
=
jump_strengths
[
1
]
>
jump_strengths
[
0
]
;
else
if
(
should_lower
[
0
]
)
lower
=
0
;
else
if
(
should_lower
[
1
]
)
lower
=
1
;
else
break
;
if
(
jump_strengths
[
lower
]
=
=
strength_return
)
{
insert_lowered_return
(
(
ir_return
*
)
jumps
[
lower
]
)
;
if
(
this
-
>
loop
.
loop
)
{
ir_loop_jump
*
lowered
=
0
;
lowered
=
new
(
ir
)
ir_loop_jump
(
ir_loop_jump
:
:
jump_break
)
;
block_records
[
lower
]
.
min_strength
=
strength_break
;
jumps
[
lower
]
-
>
replace_with
(
lowered
)
;
jumps
[
lower
]
=
lowered
;
}
else
{
goto
lower_continue
;
}
this
-
>
progress
=
true
;
}
else
if
(
jump_strengths
[
lower
]
=
=
strength_break
)
{
jumps
[
lower
]
-
>
insert_before
(
create_lowered_break
(
)
)
;
goto
lower_continue
;
}
else
if
(
jump_strengths
[
lower
]
=
=
strength_continue
)
{
lower_continue
:
ir_variable
*
execute_flag
=
this
-
>
loop
.
get_execute_flag
(
)
;
jumps
[
lower
]
-
>
replace_with
(
new
(
ir
)
ir_assignment
(
new
(
ir
)
ir_dereference_variable
(
execute_flag
)
new
(
ir
)
ir_constant
(
false
)
)
)
;
jumps
[
lower
]
=
0
;
block_records
[
lower
]
.
min_strength
=
strength_always_clears_execute_flag
;
block_records
[
lower
]
.
may_clear_execute_flag
=
true
;
this
-
>
progress
=
true
;
}
}
if
(
pull_out_jumps
)
{
int
move_out
=
-
1
;
if
(
jumps
[
0
]
&
&
block_records
[
1
]
.
min_strength
>
=
strength_continue
)
move_out
=
0
;
else
if
(
jumps
[
1
]
&
&
block_records
[
0
]
.
min_strength
>
=
strength_continue
)
move_out
=
1
;
if
(
move_out
>
=
0
)
{
jumps
[
move_out
]
-
>
remove
(
)
;
ir
-
>
insert_after
(
jumps
[
move_out
]
)
;
jumps
[
move_out
]
=
0
;
block_records
[
move_out
]
.
min_strength
=
strength_none
;
this
-
>
progress
=
true
;
}
}
if
(
block_records
[
0
]
.
min_strength
<
block_records
[
1
]
.
min_strength
)
this
-
>
block
.
min_strength
=
block_records
[
0
]
.
min_strength
;
else
this
-
>
block
.
min_strength
=
block_records
[
1
]
.
min_strength
;
this
-
>
block
.
may_clear_execute_flag
=
this
-
>
block
.
may_clear_execute_flag
|
|
block_records
[
0
]
.
may_clear_execute_flag
|
|
block_records
[
1
]
.
may_clear_execute_flag
;
if
(
this
-
>
block
.
min_strength
)
truncate_after_instruction
(
ir
)
;
else
if
(
this
-
>
block
.
may_clear_execute_flag
)
{
int
move_into
=
-
1
;
if
(
block_records
[
0
]
.
min_strength
&
&
!
block_records
[
1
]
.
may_clear_execute_flag
)
move_into
=
1
;
else
if
(
block_records
[
1
]
.
min_strength
&
&
!
block_records
[
0
]
.
may_clear_execute_flag
)
move_into
=
0
;
if
(
move_into
>
=
0
)
{
assert
(
!
block_records
[
move_into
]
.
min_strength
&
&
!
block_records
[
move_into
]
.
may_clear_execute_flag
)
;
exec_list
*
list
=
move_into
?
&
ir
-
>
else_instructions
:
&
ir
-
>
then_instructions
;
exec_node
*
next
=
ir
-
>
get_next
(
)
;
if
(
!
next
-
>
is_tail_sentinel
(
)
)
{
move_outer_block_inside
(
ir
list
)
;
exec_list
list
;
list
.
head_sentinel
.
next
=
next
;
block_records
[
move_into
]
=
visit_block
(
&
list
)
;
this
-
>
progress
=
true
;
goto
retry
;
}
}
else
{
ir_instruction
*
ir_after
;
for
(
ir_after
=
(
ir_instruction
*
)
ir
-
>
get_next
(
)
;
!
ir_after
-
>
is_tail_sentinel
(
)
;
)
{
ir_if
*
ir_if
=
ir_after
-
>
as_if
(
)
;
if
(
ir_if
&
&
ir_if
-
>
else_instructions
.
is_empty
(
)
)
{
ir_dereference_variable
*
ir_if_cond_deref
=
ir_if
-
>
condition
-
>
as_dereference_variable
(
)
;
if
(
ir_if_cond_deref
&
&
ir_if_cond_deref
-
>
var
=
=
this
-
>
loop
.
execute_flag
)
{
ir_instruction
*
ir_next
=
(
ir_instruction
*
)
ir_after
-
>
get_next
(
)
;
ir_after
-
>
insert_before
(
&
ir_if
-
>
then_instructions
)
;
ir_after
-
>
remove
(
)
;
ir_after
=
ir_next
;
continue
;
}
}
ir_after
=
(
ir_instruction
*
)
ir_after
-
>
get_next
(
)
;
this
-
>
progress
=
true
;
}
if
(
!
ir
-
>
get_next
(
)
-
>
is_tail_sentinel
(
)
)
{
assert
(
this
-
>
loop
.
execute_flag
)
;
ir_if
*
if_execute
=
new
(
ir
)
ir_if
(
new
(
ir
)
ir_dereference_variable
(
this
-
>
loop
.
execute_flag
)
)
;
move_outer_block_inside
(
ir
&
if_execute
-
>
then_instructions
)
;
ir
-
>
insert_after
(
if_execute
)
;
}
}
}
-
-
this
-
>
loop
.
nesting_depth
;
-
-
this
-
>
function
.
nesting_depth
;
}
virtual
void
visit
(
ir_loop
*
ir
)
{
+
+
this
-
>
function
.
nesting_depth
;
loop_record
saved_loop
=
this
-
>
loop
;
this
-
>
loop
=
loop_record
(
this
-
>
function
.
signature
ir
)
;
block_record
body
=
visit_block
(
&
ir
-
>
body_instructions
)
;
ir_instruction
*
ir_last
=
(
ir_instruction
*
)
ir
-
>
body_instructions
.
get_tail
(
)
;
if
(
get_jump_strength
(
ir_last
)
=
=
strength_continue
)
{
ir_last
-
>
remove
(
)
;
}
if
(
this
-
>
function
.
lower_return
)
lower_return_unconditionally
(
ir_last
)
;
if
(
body
.
min_strength
>
=
strength_break
)
{
}
if
(
this
-
>
loop
.
break_flag
)
{
assert
(
lower_break
)
;
lower_final_breaks
(
&
ir
-
>
body_instructions
)
;
ir_if
*
break_if
=
new
(
ir
)
ir_if
(
new
(
ir
)
ir_dereference_variable
(
this
-
>
loop
.
break_flag
)
)
;
break_if
-
>
then_instructions
.
push_tail
(
new
(
ir
)
ir_loop_jump
(
ir_loop_jump
:
:
jump_break
)
)
;
ir
-
>
body_instructions
.
push_tail
(
break_if
)
;
}
if
(
this
-
>
loop
.
may_set_return_flag
)
{
assert
(
this
-
>
function
.
return_flag
)
;
ir_if
*
return_if
=
new
(
ir
)
ir_if
(
new
(
ir
)
ir_dereference_variable
(
this
-
>
function
.
return_flag
)
)
;
saved_loop
.
may_set_return_flag
=
true
;
if
(
saved_loop
.
loop
)
return_if
-
>
then_instructions
.
push_tail
(
new
(
ir
)
ir_loop_jump
(
ir_loop_jump
:
:
jump_break
)
)
;
else
{
move_outer_block_inside
(
ir
&
return_if
-
>
else_instructions
)
;
if
(
this
-
>
function
.
signature
-
>
return_type
-
>
is_void
(
)
)
return_if
-
>
then_instructions
.
push_tail
(
new
(
ir
)
ir_return
(
NULL
)
)
;
else
{
assert
(
this
-
>
function
.
return_value
)
;
ir_variable
*
return_value
=
this
-
>
function
.
return_value
;
return_if
-
>
then_instructions
.
push_tail
(
new
(
ir
)
ir_return
(
new
(
ir
)
ir_dereference_variable
(
return_value
)
)
)
;
}
}
ir
-
>
insert_after
(
return_if
)
;
}
this
-
>
loop
=
saved_loop
;
-
-
this
-
>
function
.
nesting_depth
;
}
virtual
void
visit
(
ir_function_signature
*
ir
)
{
assert
(
!
this
-
>
function
.
signature
)
;
assert
(
!
this
-
>
loop
.
loop
)
;
bool
lower_return
;
if
(
strcmp
(
ir
-
>
function_name
(
)
"
main
"
)
=
=
0
)
lower_return
=
lower_main_return
;
else
lower_return
=
lower_sub_return
;
function_record
saved_function
=
this
-
>
function
;
loop_record
saved_loop
=
this
-
>
loop
;
this
-
>
function
=
function_record
(
ir
lower_return
)
;
this
-
>
loop
=
loop_record
(
ir
)
;
assert
(
!
this
-
>
loop
.
loop
)
;
visit_block
(
&
ir
-
>
body
)
;
if
(
ir
-
>
return_type
-
>
is_void
(
)
&
&
get_jump_strength
(
(
ir_instruction
*
)
ir
-
>
body
.
get_tail
(
)
)
)
{
ir_jump
*
jump
=
(
ir_jump
*
)
ir
-
>
body
.
get_tail
(
)
;
assert
(
jump
-
>
ir_type
=
=
ir_type_return
)
;
jump
-
>
remove
(
)
;
}
if
(
this
-
>
function
.
return_value
)
ir
-
>
body
.
push_tail
(
new
(
ir
)
ir_return
(
new
(
ir
)
ir_dereference_variable
(
this
-
>
function
.
return_value
)
)
)
;
this
-
>
loop
=
saved_loop
;
this
-
>
function
=
saved_function
;
}
virtual
void
visit
(
class
ir_function
*
ir
)
{
visit_block
(
&
ir
-
>
signatures
)
;
}
}
;
}
bool
do_lower_jumps
(
exec_list
*
instructions
bool
pull_out_jumps
bool
lower_sub_return
bool
lower_main_return
bool
lower_continue
bool
lower_break
)
{
ir_lower_jumps_visitor
v
;
v
.
pull_out_jumps
=
pull_out_jumps
;
v
.
lower_continue
=
lower_continue
;
v
.
lower_break
=
lower_break
;
v
.
lower_sub_return
=
lower_sub_return
;
v
.
lower_main_return
=
lower_main_return
;
bool
progress_ever
=
false
;
do
{
v
.
progress
=
false
;
visit_exec_list
(
instructions
&
v
)
;
progress_ever
=
v
.
progress
|
|
progress_ever
;
}
while
(
v
.
progress
)
;
return
progress_ever
;
}
