#
include
"
ir
.
h
"
#
include
"
linker
.
h
"
#
include
"
ir_uniform
.
h
"
#
include
"
glsl_symbol_table
.
h
"
#
include
"
program
.
h
"
#
include
"
string_to_uint_map
.
h
"
#
include
"
ir_array_refcount
.
h
"
#
include
"
main
/
mtypes
.
h
"
#
include
"
util
/
strndup
.
h
"
#
define
UNMAPPED_UNIFORM_LOC
~
0u
static
char
*
get_top_level_name
(
const
char
*
name
)
{
const
char
*
first_dot
=
strchr
(
name
'
.
'
)
;
const
char
*
first_square_bracket
=
strchr
(
name
'
[
'
)
;
int
name_size
=
0
;
if
(
!
first_square_bracket
&
&
!
first_dot
)
name_size
=
strlen
(
name
)
;
else
if
(
(
!
first_square_bracket
|
|
(
first_dot
&
&
first_dot
<
first_square_bracket
)
)
)
name_size
=
first_dot
-
name
;
else
name_size
=
first_square_bracket
-
name
;
return
strndup
(
name
name_size
)
;
}
static
char
*
get_var_name
(
const
char
*
name
)
{
const
char
*
first_dot
=
strchr
(
name
'
.
'
)
;
if
(
!
first_dot
)
return
strdup
(
name
)
;
return
strndup
(
first_dot
+
1
strlen
(
first_dot
)
-
1
)
;
}
static
bool
is_top_level_shader_storage_block_member
(
const
char
*
name
const
char
*
interface_name
const
char
*
field_name
)
{
bool
result
=
false
;
int
name_length
=
strlen
(
interface_name
)
+
1
+
strlen
(
field_name
)
+
1
;
char
*
full_instanced_name
=
(
char
*
)
calloc
(
name_length
sizeof
(
char
)
)
;
if
(
!
full_instanced_name
)
{
fprintf
(
stderr
"
%
s
:
Cannot
allocate
space
for
name
\
n
"
__func__
)
;
return
false
;
}
snprintf
(
full_instanced_name
name_length
"
%
s
.
%
s
"
interface_name
field_name
)
;
if
(
strcmp
(
name
full_instanced_name
)
=
=
0
|
|
strcmp
(
name
field_name
)
=
=
0
)
result
=
true
;
free
(
full_instanced_name
)
;
return
result
;
}
static
int
get_array_size
(
struct
gl_uniform_storage
*
uni
const
glsl_struct_field
*
field
char
*
interface_name
char
*
var_name
)
{
if
(
is_top_level_shader_storage_block_member
(
uni
-
>
name
interface_name
var_name
)
)
return
1
;
else
if
(
field
-
>
type
-
>
is_array
(
)
)
return
field
-
>
type
-
>
length
;
return
1
;
}
static
int
get_array_stride
(
struct
gl_uniform_storage
*
uni
const
glsl_type
*
iface
const
glsl_struct_field
*
field
char
*
interface_name
char
*
var_name
bool
use_std430_as_default
)
{
if
(
field
-
>
type
-
>
is_array
(
)
)
{
const
enum
glsl_matrix_layout
matrix_layout
=
glsl_matrix_layout
(
field
-
>
matrix_layout
)
;
bool
row_major
=
matrix_layout
=
=
GLSL_MATRIX_LAYOUT_ROW_MAJOR
;
const
glsl_type
*
array_type
=
field
-
>
type
-
>
fields
.
array
;
if
(
is_top_level_shader_storage_block_member
(
uni
-
>
name
interface_name
var_name
)
)
return
0
;
if
(
GLSL_INTERFACE_PACKING_STD140
=
=
iface
-
>
get_internal_ifc_packing
(
use_std430_as_default
)
)
{
if
(
array_type
-
>
is_struct
(
)
|
|
array_type
-
>
is_array
(
)
)
return
glsl_align
(
array_type
-
>
std140_size
(
row_major
)
16
)
;
else
return
MAX2
(
array_type
-
>
std140_base_alignment
(
row_major
)
16
)
;
}
else
{
return
array_type
-
>
std430_array_stride
(
row_major
)
;
}
}
return
0
;
}
static
void
calculate_array_size_and_stride
(
struct
gl_shader_program
*
shProg
struct
gl_uniform_storage
*
uni
bool
use_std430_as_default
)
{
if
(
!
uni
-
>
is_shader_storage
)
return
;
int
block_index
=
uni
-
>
block_index
;
int
array_size
=
-
1
;
int
array_stride
=
-
1
;
char
*
var_name
=
get_top_level_name
(
uni
-
>
name
)
;
char
*
interface_name
=
get_top_level_name
(
uni
-
>
is_shader_storage
?
shProg
-
>
data
-
>
ShaderStorageBlocks
[
block_index
]
.
Name
:
shProg
-
>
data
-
>
UniformBlocks
[
block_index
]
.
Name
)
;
if
(
strcmp
(
var_name
interface_name
)
=
=
0
)
{
char
*
temp_name
=
get_var_name
(
uni
-
>
name
)
;
if
(
!
temp_name
)
{
linker_error
(
shProg
"
Out
of
memory
during
linking
.
\
n
"
)
;
goto
write_top_level_array_size_and_stride
;
}
free
(
var_name
)
;
var_name
=
get_top_level_name
(
temp_name
)
;
free
(
temp_name
)
;
if
(
!
var_name
)
{
linker_error
(
shProg
"
Out
of
memory
during
linking
.
\
n
"
)
;
goto
write_top_level_array_size_and_stride
;
}
}
for
(
unsigned
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
{
const
gl_linked_shader
*
sh
=
shProg
-
>
_LinkedShaders
[
i
]
;
if
(
sh
=
=
NULL
)
continue
;
foreach_in_list
(
ir_instruction
node
sh
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
!
var
|
|
!
var
-
>
get_interface_type
(
)
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_storage
)
continue
;
const
glsl_type
*
iface
=
var
-
>
get_interface_type
(
)
;
if
(
strcmp
(
interface_name
iface
-
>
name
)
!
=
0
)
continue
;
for
(
unsigned
i
=
0
;
i
<
iface
-
>
length
;
i
+
+
)
{
const
glsl_struct_field
*
field
=
&
iface
-
>
fields
.
structure
[
i
]
;
if
(
strcmp
(
field
-
>
name
var_name
)
!
=
0
)
continue
;
array_stride
=
get_array_stride
(
uni
iface
field
interface_name
var_name
use_std430_as_default
)
;
array_size
=
get_array_size
(
uni
field
interface_name
var_name
)
;
goto
write_top_level_array_size_and_stride
;
}
}
}
write_top_level_array_size_and_stride
:
free
(
interface_name
)
;
free
(
var_name
)
;
uni
-
>
top_level_array_stride
=
array_stride
;
uni
-
>
top_level_array_size
=
array_size
;
}
void
program_resource_visitor
:
:
process
(
const
glsl_type
*
type
const
char
*
name
bool
use_std430_as_default
)
{
assert
(
type
-
>
without_array
(
)
-
>
is_struct
(
)
|
|
type
-
>
without_array
(
)
-
>
is_interface
(
)
)
;
unsigned
record_array_count
=
1
;
char
*
name_copy
=
ralloc_strdup
(
NULL
name
)
;
enum
glsl_interface_packing
packing
=
type
-
>
get_internal_ifc_packing
(
use_std430_as_default
)
;
recursion
(
type
&
name_copy
strlen
(
name
)
false
NULL
packing
false
record_array_count
NULL
)
;
ralloc_free
(
name_copy
)
;
}
void
program_resource_visitor
:
:
process
(
ir_variable
*
var
bool
use_std430_as_default
)
{
const
glsl_type
*
t
=
var
-
>
data
.
from_named_ifc_block
?
var
-
>
get_interface_type
(
)
:
var
-
>
type
;
process
(
var
t
use_std430_as_default
)
;
}
void
program_resource_visitor
:
:
process
(
ir_variable
*
var
const
glsl_type
*
var_type
bool
use_std430_as_default
)
{
unsigned
record_array_count
=
1
;
const
bool
row_major
=
var
-
>
data
.
matrix_layout
=
=
GLSL_MATRIX_LAYOUT_ROW_MAJOR
;
enum
glsl_interface_packing
packing
=
var
-
>
get_interface_type
(
)
?
var
-
>
get_interface_type
(
)
-
>
get_internal_ifc_packing
(
use_std430_as_default
)
:
var
-
>
type
-
>
get_internal_ifc_packing
(
use_std430_as_default
)
;
const
glsl_type
*
t
=
var_type
;
const
glsl_type
*
t_without_array
=
t
-
>
without_array
(
)
;
if
(
t_without_array
-
>
is_struct
(
)
|
|
(
t
-
>
is_array
(
)
&
&
t
-
>
fields
.
array
-
>
is_array
(
)
)
)
{
char
*
name
=
ralloc_strdup
(
NULL
var
-
>
name
)
;
recursion
(
var
-
>
type
&
name
strlen
(
name
)
row_major
NULL
packing
false
record_array_count
NULL
)
;
ralloc_free
(
name
)
;
}
else
if
(
t_without_array
-
>
is_interface
(
)
)
{
char
*
name
=
ralloc_strdup
(
NULL
t_without_array
-
>
name
)
;
const
glsl_struct_field
*
ifc_member
=
var
-
>
data
.
from_named_ifc_block
?
&
t_without_array
-
>
fields
.
structure
[
t_without_array
-
>
field_index
(
var
-
>
name
)
]
:
NULL
;
recursion
(
t
&
name
strlen
(
name
)
row_major
NULL
packing
false
record_array_count
ifc_member
)
;
ralloc_free
(
name
)
;
}
else
{
this
-
>
set_record_array_count
(
record_array_count
)
;
this
-
>
visit_field
(
t
var
-
>
name
row_major
NULL
packing
false
)
;
}
}
void
program_resource_visitor
:
:
recursion
(
const
glsl_type
*
t
char
*
*
name
size_t
name_length
bool
row_major
const
glsl_type
*
record_type
const
enum
glsl_interface_packing
packing
bool
last_field
unsigned
record_array_count
const
glsl_struct_field
*
named_ifc_member
)
{
if
(
t
-
>
is_interface
(
)
&
&
named_ifc_member
)
{
ralloc_asprintf_rewrite_tail
(
name
&
name_length
"
.
%
s
"
named_ifc_member
-
>
name
)
;
recursion
(
named_ifc_member
-
>
type
name
name_length
row_major
NULL
packing
false
record_array_count
NULL
)
;
}
else
if
(
t
-
>
is_struct
(
)
|
|
t
-
>
is_interface
(
)
)
{
if
(
record_type
=
=
NULL
&
&
t
-
>
is_struct
(
)
)
record_type
=
t
;
if
(
t
-
>
is_struct
(
)
)
this
-
>
enter_record
(
t
*
name
row_major
packing
)
;
for
(
unsigned
i
=
0
;
i
<
t
-
>
length
;
i
+
+
)
{
const
char
*
field
=
t
-
>
fields
.
structure
[
i
]
.
name
;
size_t
new_length
=
name_length
;
if
(
t
-
>
is_interface
(
)
&
&
t
-
>
fields
.
structure
[
i
]
.
offset
!
=
-
1
)
this
-
>
set_buffer_offset
(
t
-
>
fields
.
structure
[
i
]
.
offset
)
;
if
(
name_length
=
=
0
)
{
ralloc_asprintf_rewrite_tail
(
name
&
new_length
"
%
s
"
field
)
;
}
else
{
ralloc_asprintf_rewrite_tail
(
name
&
new_length
"
.
%
s
"
field
)
;
}
bool
field_row_major
=
row_major
;
const
enum
glsl_matrix_layout
matrix_layout
=
glsl_matrix_layout
(
t
-
>
fields
.
structure
[
i
]
.
matrix_layout
)
;
if
(
matrix_layout
=
=
GLSL_MATRIX_LAYOUT_ROW_MAJOR
)
{
field_row_major
=
true
;
}
else
if
(
matrix_layout
=
=
GLSL_MATRIX_LAYOUT_COLUMN_MAJOR
)
{
field_row_major
=
false
;
}
recursion
(
t
-
>
fields
.
structure
[
i
]
.
type
name
new_length
field_row_major
record_type
packing
(
i
+
1
)
=
=
t
-
>
length
record_array_count
NULL
)
;
record_type
=
NULL
;
}
if
(
t
-
>
is_struct
(
)
)
{
(
*
name
)
[
name_length
]
=
'
\
0
'
;
this
-
>
leave_record
(
t
*
name
row_major
packing
)
;
}
}
else
if
(
t
-
>
without_array
(
)
-
>
is_struct
(
)
|
|
t
-
>
without_array
(
)
-
>
is_interface
(
)
|
|
(
t
-
>
is_array
(
)
&
&
t
-
>
fields
.
array
-
>
is_array
(
)
)
)
{
if
(
record_type
=
=
NULL
&
&
t
-
>
fields
.
array
-
>
is_struct
(
)
)
record_type
=
t
-
>
fields
.
array
;
unsigned
length
=
t
-
>
length
;
if
(
t
-
>
is_unsized_array
(
)
)
length
=
1
;
record_array_count
*
=
length
;
for
(
unsigned
i
=
0
;
i
<
length
;
i
+
+
)
{
size_t
new_length
=
name_length
;
ralloc_asprintf_rewrite_tail
(
name
&
new_length
"
[
%
u
]
"
i
)
;
recursion
(
t
-
>
fields
.
array
name
new_length
row_major
record_type
packing
(
i
+
1
)
=
=
t
-
>
length
record_array_count
named_ifc_member
)
;
record_type
=
NULL
;
}
}
else
{
this
-
>
set_record_array_count
(
record_array_count
)
;
this
-
>
visit_field
(
t
*
name
row_major
record_type
packing
last_field
)
;
}
}
void
program_resource_visitor
:
:
enter_record
(
const
glsl_type
*
const
char
*
bool
const
enum
glsl_interface_packing
)
{
}
void
program_resource_visitor
:
:
leave_record
(
const
glsl_type
*
const
char
*
bool
const
enum
glsl_interface_packing
)
{
}
void
program_resource_visitor
:
:
set_buffer_offset
(
unsigned
)
{
}
void
program_resource_visitor
:
:
set_record_array_count
(
unsigned
)
{
}
namespace
{
class
count_uniform_size
:
public
program_resource_visitor
{
public
:
count_uniform_size
(
struct
string_to_uint_map
*
map
struct
string_to_uint_map
*
hidden_map
bool
use_std430_as_default
)
:
num_active_uniforms
(
0
)
num_hidden_uniforms
(
0
)
num_values
(
0
)
num_shader_samplers
(
0
)
num_shader_images
(
0
)
num_shader_uniform_components
(
0
)
num_shader_subroutines
(
0
)
is_buffer_block
(
false
)
is_shader_storage
(
false
)
map
(
map
)
hidden_map
(
hidden_map
)
current_var
(
NULL
)
use_std430_as_default
(
use_std430_as_default
)
{
}
void
start_shader
(
)
{
this
-
>
num_shader_samplers
=
0
;
this
-
>
num_shader_images
=
0
;
this
-
>
num_shader_uniform_components
=
0
;
this
-
>
num_shader_subroutines
=
0
;
}
void
process
(
ir_variable
*
var
)
{
this
-
>
current_var
=
var
;
this
-
>
is_buffer_block
=
var
-
>
is_in_buffer_block
(
)
;
this
-
>
is_shader_storage
=
var
-
>
is_in_shader_storage_block
(
)
;
if
(
var
-
>
is_interface_instance
(
)
)
program_resource_visitor
:
:
process
(
var
-
>
get_interface_type
(
)
var
-
>
get_interface_type
(
)
-
>
name
use_std430_as_default
)
;
else
program_resource_visitor
:
:
process
(
var
use_std430_as_default
)
;
}
unsigned
num_active_uniforms
;
unsigned
num_hidden_uniforms
;
unsigned
num_values
;
unsigned
num_shader_samplers
;
unsigned
num_shader_images
;
unsigned
num_shader_uniform_components
;
unsigned
num_shader_subroutines
;
bool
is_buffer_block
;
bool
is_shader_storage
;
struct
string_to_uint_map
*
map
;
private
:
virtual
void
visit_field
(
const
glsl_type
*
type
const
char
*
name
bool
const
glsl_type
*
const
enum
glsl_interface_packing
bool
)
{
assert
(
!
type
-
>
without_array
(
)
-
>
is_struct
(
)
)
;
assert
(
!
type
-
>
without_array
(
)
-
>
is_interface
(
)
)
;
assert
(
!
(
type
-
>
is_array
(
)
&
&
type
-
>
fields
.
array
-
>
is_array
(
)
)
)
;
const
unsigned
values
=
type
-
>
component_slots
(
)
;
if
(
type
-
>
contains_subroutine
(
)
)
{
this
-
>
num_shader_subroutines
+
=
values
;
}
else
if
(
type
-
>
contains_sampler
(
)
&
&
!
current_var
-
>
data
.
bindless
)
{
this
-
>
num_shader_samplers
+
=
values
/
2
;
}
else
if
(
type
-
>
contains_image
(
)
&
&
!
current_var
-
>
data
.
bindless
)
{
this
-
>
num_shader_images
+
=
values
/
2
;
if
(
!
is_shader_storage
)
this
-
>
num_shader_uniform_components
+
=
values
;
}
else
{
if
(
!
is_buffer_block
)
this
-
>
num_shader_uniform_components
+
=
values
;
}
unsigned
id
;
if
(
this
-
>
map
-
>
get
(
id
name
)
)
return
;
if
(
this
-
>
current_var
-
>
data
.
how_declared
=
=
ir_var_hidden
)
{
this
-
>
hidden_map
-
>
put
(
this
-
>
num_hidden_uniforms
name
)
;
this
-
>
num_hidden_uniforms
+
+
;
}
else
{
this
-
>
map
-
>
put
(
this
-
>
num_active_uniforms
-
this
-
>
num_hidden_uniforms
name
)
;
}
this
-
>
num_active_uniforms
+
+
;
if
(
!
is_gl_identifier
(
name
)
&
&
!
is_shader_storage
&
&
!
is_buffer_block
)
this
-
>
num_values
+
=
values
;
}
struct
string_to_uint_map
*
hidden_map
;
ir_variable
*
current_var
;
bool
use_std430_as_default
;
}
;
}
unsigned
link_calculate_matrix_stride
(
const
glsl_type
*
matrix
bool
row_major
enum
glsl_interface_packing
packing
)
{
const
unsigned
N
=
matrix
-
>
is_double
(
)
?
8
:
4
;
const
unsigned
items
=
row_major
?
matrix
-
>
matrix_columns
:
matrix
-
>
vector_elements
;
assert
(
items
<
=
4
)
;
return
packing
=
=
GLSL_INTERFACE_PACKING_STD430
?
(
items
<
3
?
items
*
N
:
glsl_align
(
items
*
N
16
)
)
:
glsl_align
(
items
*
N
16
)
;
}
class
parcel_out_uniform_storage
:
public
program_resource_visitor
{
public
:
parcel_out_uniform_storage
(
struct
gl_shader_program
*
prog
struct
string_to_uint_map
*
map
struct
gl_uniform_storage
*
uniforms
union
gl_constant_value
*
values
bool
use_std430_as_default
)
:
prog
(
prog
)
map
(
map
)
uniforms
(
uniforms
)
use_std430_as_default
(
use_std430_as_default
)
values
(
values
)
bindless_targets
(
NULL
)
bindless_access
(
NULL
)
shader_storage_blocks_write_access
(
0
)
{
}
virtual
~
parcel_out_uniform_storage
(
)
{
free
(
this
-
>
bindless_targets
)
;
free
(
this
-
>
bindless_access
)
;
}
void
start_shader
(
gl_shader_stage
shader_type
)
{
assert
(
shader_type
<
MESA_SHADER_STAGES
)
;
this
-
>
shader_type
=
shader_type
;
this
-
>
shader_samplers_used
=
0
;
this
-
>
shader_shadow_samplers
=
0
;
this
-
>
next_sampler
=
0
;
this
-
>
next_image
=
0
;
this
-
>
next_subroutine
=
0
;
this
-
>
record_array_count
=
1
;
memset
(
this
-
>
targets
0
sizeof
(
this
-
>
targets
)
)
;
this
-
>
num_bindless_samplers
=
0
;
this
-
>
next_bindless_sampler
=
0
;
free
(
this
-
>
bindless_targets
)
;
this
-
>
bindless_targets
=
NULL
;
this
-
>
num_bindless_images
=
0
;
this
-
>
next_bindless_image
=
0
;
free
(
this
-
>
bindless_access
)
;
this
-
>
bindless_access
=
NULL
;
this
-
>
shader_storage_blocks_write_access
=
0
;
}
void
set_and_process
(
ir_variable
*
var
)
{
current_var
=
var
;
field_counter
=
0
;
this
-
>
record_next_sampler
=
new
string_to_uint_map
;
this
-
>
record_next_bindless_sampler
=
new
string_to_uint_map
;
this
-
>
record_next_image
=
new
string_to_uint_map
;
this
-
>
record_next_bindless_image
=
new
string_to_uint_map
;
buffer_block_index
=
-
1
;
if
(
var
-
>
is_in_buffer_block
(
)
)
{
struct
gl_uniform_block
*
blks
=
var
-
>
is_in_shader_storage_block
(
)
?
prog
-
>
data
-
>
ShaderStorageBlocks
:
prog
-
>
data
-
>
UniformBlocks
;
unsigned
num_blks
=
var
-
>
is_in_shader_storage_block
(
)
?
prog
-
>
data
-
>
NumShaderStorageBlocks
:
prog
-
>
data
-
>
NumUniformBlocks
;
bool
is_interface_array
=
var
-
>
is_interface_instance
(
)
&
&
var
-
>
type
-
>
is_array
(
)
;
if
(
is_interface_array
)
{
unsigned
l
=
strlen
(
var
-
>
get_interface_type
(
)
-
>
name
)
;
for
(
unsigned
i
=
0
;
i
<
num_blks
;
i
+
+
)
{
if
(
strncmp
(
var
-
>
get_interface_type
(
)
-
>
name
blks
[
i
]
.
Name
l
)
=
=
0
&
&
blks
[
i
]
.
Name
[
l
]
=
=
'
[
'
)
{
buffer_block_index
=
i
;
break
;
}
}
}
else
{
for
(
unsigned
i
=
0
;
i
<
num_blks
;
i
+
+
)
{
if
(
strcmp
(
var
-
>
get_interface_type
(
)
-
>
name
blks
[
i
]
.
Name
)
=
=
0
)
{
buffer_block_index
=
i
;
break
;
}
}
}
assert
(
buffer_block_index
!
=
-
1
)
;
if
(
var
-
>
is_in_shader_storage_block
(
)
&
&
!
var
-
>
data
.
memory_read_only
)
{
unsigned
array_size
=
is_interface_array
?
var
-
>
type
-
>
array_size
(
)
:
1
;
STATIC_ASSERT
(
MAX_SHADER_STORAGE_BUFFERS
<
=
32
)
;
if
(
buffer_block_index
+
array_size
<
=
32
)
{
shader_storage_blocks_write_access
|
=
u_bit_consecutive
(
buffer_block_index
array_size
)
;
}
}
if
(
var
-
>
is_interface_instance
(
)
)
{
ubo_byte_offset
=
0
;
process
(
var
-
>
get_interface_type
(
)
var
-
>
get_interface_type
(
)
-
>
name
use_std430_as_default
)
;
}
else
{
const
struct
gl_uniform_block
*
const
block
=
&
blks
[
buffer_block_index
]
;
assert
(
var
-
>
data
.
location
!
=
-
1
)
;
const
struct
gl_uniform_buffer_variable
*
const
ubo_var
=
&
block
-
>
Uniforms
[
var
-
>
data
.
location
]
;
ubo_byte_offset
=
ubo_var
-
>
Offset
;
process
(
var
use_std430_as_default
)
;
}
}
else
{
this
-
>
explicit_location
=
current_var
-
>
data
.
location
;
current_var
-
>
data
.
location
=
-
1
;
process
(
var
use_std430_as_default
)
;
}
delete
this
-
>
record_next_sampler
;
delete
this
-
>
record_next_bindless_sampler
;
delete
this
-
>
record_next_image
;
delete
this
-
>
record_next_bindless_image
;
}
int
buffer_block_index
;
int
ubo_byte_offset
;
gl_shader_stage
shader_type
;
private
:
bool
set_opaque_indices
(
const
glsl_type
*
base_type
struct
gl_uniform_storage
*
uniform
const
char
*
name
unsigned
&
next_index
struct
string_to_uint_map
*
record_next_index
)
{
assert
(
base_type
-
>
is_sampler
(
)
|
|
base_type
-
>
is_image
(
)
)
;
if
(
this
-
>
record_array_count
>
1
)
{
unsigned
inner_array_size
=
MAX2
(
1
uniform
-
>
array_elements
)
;
char
*
name_copy
=
ralloc_strdup
(
NULL
name
)
;
char
*
str_start
;
const
char
*
str_end
;
while
(
(
str_start
=
strchr
(
name_copy
'
[
'
)
)
&
&
(
str_end
=
strchr
(
name_copy
'
]
'
)
)
)
{
memmove
(
str_start
str_end
+
1
1
+
strlen
(
str_end
+
1
)
)
;
}
unsigned
index
=
0
;
if
(
record_next_index
-
>
get
(
index
name_copy
)
)
{
uniform
-
>
opaque
[
shader_type
]
.
index
=
index
;
index
=
inner_array_size
+
uniform
-
>
opaque
[
shader_type
]
.
index
;
record_next_index
-
>
put
(
index
name_copy
)
;
ralloc_free
(
name_copy
)
;
return
false
;
}
else
{
uniform
-
>
opaque
[
shader_type
]
.
index
=
next_index
;
next_index
+
=
inner_array_size
*
this
-
>
record_array_count
;
index
=
uniform
-
>
opaque
[
shader_type
]
.
index
+
inner_array_size
;
record_next_index
-
>
put
(
index
name_copy
)
;
ralloc_free
(
name_copy
)
;
}
}
else
{
uniform
-
>
opaque
[
shader_type
]
.
index
=
next_index
;
next_index
+
=
MAX2
(
1
uniform
-
>
array_elements
)
;
}
return
true
;
}
void
handle_samplers
(
const
glsl_type
*
base_type
struct
gl_uniform_storage
*
uniform
const
char
*
name
)
{
if
(
base_type
-
>
is_sampler
(
)
)
{
uniform
-
>
opaque
[
shader_type
]
.
active
=
true
;
const
gl_texture_index
target
=
base_type
-
>
sampler_index
(
)
;
const
unsigned
shadow
=
base_type
-
>
sampler_shadow
;
if
(
current_var
-
>
data
.
bindless
)
{
if
(
!
set_opaque_indices
(
base_type
uniform
name
this
-
>
next_bindless_sampler
this
-
>
record_next_bindless_sampler
)
)
return
;
this
-
>
num_bindless_samplers
=
this
-
>
next_bindless_sampler
;
this
-
>
bindless_targets
=
(
gl_texture_index
*
)
realloc
(
this
-
>
bindless_targets
this
-
>
num_bindless_samplers
*
sizeof
(
gl_texture_index
)
)
;
for
(
unsigned
i
=
uniform
-
>
opaque
[
shader_type
]
.
index
;
i
<
this
-
>
num_bindless_samplers
;
i
+
+
)
{
this
-
>
bindless_targets
[
i
]
=
target
;
}
}
else
{
if
(
!
set_opaque_indices
(
base_type
uniform
name
this
-
>
next_sampler
this
-
>
record_next_sampler
)
)
return
;
for
(
unsigned
i
=
uniform
-
>
opaque
[
shader_type
]
.
index
;
i
<
MIN2
(
this
-
>
next_sampler
MAX_SAMPLERS
)
;
i
+
+
)
{
this
-
>
targets
[
i
]
=
target
;
this
-
>
shader_samplers_used
|
=
1U
<
<
i
;
this
-
>
shader_shadow_samplers
|
=
shadow
<
<
i
;
}
}
}
}
void
handle_images
(
const
glsl_type
*
base_type
struct
gl_uniform_storage
*
uniform
const
char
*
name
)
{
if
(
base_type
-
>
is_image
(
)
)
{
uniform
-
>
opaque
[
shader_type
]
.
active
=
true
;
const
GLenum
access
=
current_var
-
>
data
.
memory_read_only
?
(
current_var
-
>
data
.
memory_write_only
?
GL_NONE
:
GL_READ_ONLY
)
:
(
current_var
-
>
data
.
memory_write_only
?
GL_WRITE_ONLY
:
GL_READ_WRITE
)
;
if
(
current_var
-
>
data
.
bindless
)
{
if
(
!
set_opaque_indices
(
base_type
uniform
name
this
-
>
next_bindless_image
this
-
>
record_next_bindless_image
)
)
return
;
this
-
>
num_bindless_images
=
this
-
>
next_bindless_image
;
this
-
>
bindless_access
=
(
GLenum
*
)
realloc
(
this
-
>
bindless_access
this
-
>
num_bindless_images
*
sizeof
(
GLenum
)
)
;
for
(
unsigned
i
=
uniform
-
>
opaque
[
shader_type
]
.
index
;
i
<
this
-
>
num_bindless_images
;
i
+
+
)
{
this
-
>
bindless_access
[
i
]
=
access
;
}
}
else
{
if
(
!
set_opaque_indices
(
base_type
uniform
name
this
-
>
next_image
this
-
>
record_next_image
)
)
return
;
for
(
unsigned
i
=
uniform
-
>
opaque
[
shader_type
]
.
index
;
i
<
MIN2
(
this
-
>
next_image
MAX_IMAGE_UNIFORMS
)
;
i
+
+
)
{
prog
-
>
_LinkedShaders
[
shader_type
]
-
>
Program
-
>
sh
.
ImageAccess
[
i
]
=
access
;
}
}
}
}
void
handle_subroutines
(
const
glsl_type
*
base_type
struct
gl_uniform_storage
*
uniform
)
{
if
(
base_type
-
>
is_subroutine
(
)
)
{
uniform
-
>
opaque
[
shader_type
]
.
index
=
this
-
>
next_subroutine
;
uniform
-
>
opaque
[
shader_type
]
.
active
=
true
;
prog
-
>
_LinkedShaders
[
shader_type
]
-
>
Program
-
>
sh
.
NumSubroutineUniforms
+
+
;
this
-
>
next_subroutine
+
=
MAX2
(
1
uniform
-
>
array_elements
)
;
}
}
virtual
void
set_buffer_offset
(
unsigned
offset
)
{
this
-
>
ubo_byte_offset
=
offset
;
}
virtual
void
set_record_array_count
(
unsigned
record_array_count
)
{
this
-
>
record_array_count
=
record_array_count
;
}
virtual
void
enter_record
(
const
glsl_type
*
type
const
char
*
bool
row_major
const
enum
glsl_interface_packing
packing
)
{
assert
(
type
-
>
is_struct
(
)
)
;
if
(
this
-
>
buffer_block_index
=
=
-
1
)
return
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
this
-
>
ubo_byte_offset
=
glsl_align
(
this
-
>
ubo_byte_offset
type
-
>
std430_base_alignment
(
row_major
)
)
;
else
this
-
>
ubo_byte_offset
=
glsl_align
(
this
-
>
ubo_byte_offset
type
-
>
std140_base_alignment
(
row_major
)
)
;
}
virtual
void
leave_record
(
const
glsl_type
*
type
const
char
*
bool
row_major
const
enum
glsl_interface_packing
packing
)
{
assert
(
type
-
>
is_struct
(
)
)
;
if
(
this
-
>
buffer_block_index
=
=
-
1
)
return
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
this
-
>
ubo_byte_offset
=
glsl_align
(
this
-
>
ubo_byte_offset
type
-
>
std430_base_alignment
(
row_major
)
)
;
else
this
-
>
ubo_byte_offset
=
glsl_align
(
this
-
>
ubo_byte_offset
type
-
>
std140_base_alignment
(
row_major
)
)
;
}
virtual
void
visit_field
(
const
glsl_type
*
type
const
char
*
name
bool
row_major
const
glsl_type
*
const
enum
glsl_interface_packing
packing
bool
)
{
assert
(
!
type
-
>
without_array
(
)
-
>
is_struct
(
)
)
;
assert
(
!
type
-
>
without_array
(
)
-
>
is_interface
(
)
)
;
assert
(
!
(
type
-
>
is_array
(
)
&
&
type
-
>
fields
.
array
-
>
is_array
(
)
)
)
;
unsigned
id
;
bool
found
=
this
-
>
map
-
>
get
(
id
name
)
;
assert
(
found
)
;
if
(
!
found
)
return
;
const
glsl_type
*
base_type
;
if
(
type
-
>
is_array
(
)
)
{
this
-
>
uniforms
[
id
]
.
array_elements
=
type
-
>
length
;
base_type
=
type
-
>
fields
.
array
;
}
else
{
this
-
>
uniforms
[
id
]
.
array_elements
=
0
;
base_type
=
type
;
}
this
-
>
uniforms
[
id
]
.
opaque
[
shader_type
]
.
index
=
~
0
;
this
-
>
uniforms
[
id
]
.
opaque
[
shader_type
]
.
active
=
false
;
if
(
current_var
-
>
data
.
used
|
|
base_type
-
>
is_subroutine
(
)
)
this
-
>
uniforms
[
id
]
.
active_shader_mask
|
=
1
<
<
shader_type
;
handle_samplers
(
base_type
&
this
-
>
uniforms
[
id
]
name
)
;
handle_images
(
base_type
&
this
-
>
uniforms
[
id
]
name
)
;
handle_subroutines
(
base_type
&
this
-
>
uniforms
[
id
]
)
;
if
(
buffer_block_index
=
=
-
1
&
&
current_var
-
>
data
.
location
=
=
-
1
)
{
current_var
-
>
data
.
location
=
id
;
}
if
(
this
-
>
uniforms
[
id
]
.
storage
!
=
NULL
|
|
this
-
>
uniforms
[
id
]
.
builtin
)
{
return
;
}
if
(
current_var
-
>
data
.
explicit_location
)
{
if
(
current_var
-
>
type
-
>
without_array
(
)
-
>
is_struct
(
)
|
|
current_var
-
>
type
-
>
is_array_of_arrays
(
)
)
{
const
unsigned
entries
=
MAX2
(
1
this
-
>
uniforms
[
id
]
.
array_elements
)
;
this
-
>
uniforms
[
id
]
.
remap_location
=
this
-
>
explicit_location
+
field_counter
;
field_counter
+
=
entries
;
}
else
{
this
-
>
uniforms
[
id
]
.
remap_location
=
this
-
>
explicit_location
;
}
}
else
{
this
-
>
uniforms
[
id
]
.
remap_location
=
UNMAPPED_UNIFORM_LOC
;
}
this
-
>
uniforms
[
id
]
.
name
=
ralloc_strdup
(
this
-
>
uniforms
name
)
;
this
-
>
uniforms
[
id
]
.
type
=
base_type
;
this
-
>
uniforms
[
id
]
.
num_driver_storage
=
0
;
this
-
>
uniforms
[
id
]
.
driver_storage
=
NULL
;
this
-
>
uniforms
[
id
]
.
atomic_buffer_index
=
-
1
;
this
-
>
uniforms
[
id
]
.
hidden
=
current_var
-
>
data
.
how_declared
=
=
ir_var_hidden
;
this
-
>
uniforms
[
id
]
.
builtin
=
is_gl_identifier
(
name
)
;
this
-
>
uniforms
[
id
]
.
is_shader_storage
=
current_var
-
>
is_in_shader_storage_block
(
)
;
this
-
>
uniforms
[
id
]
.
is_bindless
=
current_var
-
>
data
.
bindless
;
if
(
!
this
-
>
uniforms
[
id
]
.
builtin
&
&
!
this
-
>
uniforms
[
id
]
.
is_shader_storage
&
&
this
-
>
buffer_block_index
=
=
-
1
)
this
-
>
uniforms
[
id
]
.
storage
=
this
-
>
values
;
if
(
this
-
>
buffer_block_index
!
=
-
1
)
{
this
-
>
uniforms
[
id
]
.
block_index
=
this
-
>
buffer_block_index
;
unsigned
alignment
=
type
-
>
std140_base_alignment
(
row_major
)
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
alignment
=
type
-
>
std430_base_alignment
(
row_major
)
;
this
-
>
ubo_byte_offset
=
glsl_align
(
this
-
>
ubo_byte_offset
alignment
)
;
this
-
>
uniforms
[
id
]
.
offset
=
this
-
>
ubo_byte_offset
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
this
-
>
ubo_byte_offset
+
=
type
-
>
std430_size
(
row_major
)
;
else
this
-
>
ubo_byte_offset
+
=
type
-
>
std140_size
(
row_major
)
;
if
(
type
-
>
is_array
(
)
)
{
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
this
-
>
uniforms
[
id
]
.
array_stride
=
type
-
>
without_array
(
)
-
>
std430_array_stride
(
row_major
)
;
else
this
-
>
uniforms
[
id
]
.
array_stride
=
glsl_align
(
type
-
>
without_array
(
)
-
>
std140_size
(
row_major
)
16
)
;
}
else
{
this
-
>
uniforms
[
id
]
.
array_stride
=
0
;
}
if
(
type
-
>
without_array
(
)
-
>
is_matrix
(
)
)
{
this
-
>
uniforms
[
id
]
.
matrix_stride
=
link_calculate_matrix_stride
(
type
-
>
without_array
(
)
row_major
packing
)
;
this
-
>
uniforms
[
id
]
.
row_major
=
row_major
;
}
else
{
this
-
>
uniforms
[
id
]
.
matrix_stride
=
0
;
this
-
>
uniforms
[
id
]
.
row_major
=
false
;
}
}
else
{
this
-
>
uniforms
[
id
]
.
block_index
=
-
1
;
this
-
>
uniforms
[
id
]
.
offset
=
-
1
;
this
-
>
uniforms
[
id
]
.
array_stride
=
-
1
;
this
-
>
uniforms
[
id
]
.
matrix_stride
=
-
1
;
this
-
>
uniforms
[
id
]
.
row_major
=
false
;
}
if
(
!
this
-
>
uniforms
[
id
]
.
builtin
&
&
!
this
-
>
uniforms
[
id
]
.
is_shader_storage
&
&
this
-
>
buffer_block_index
=
=
-
1
)
this
-
>
values
+
=
type
-
>
component_slots
(
)
;
calculate_array_size_and_stride
(
prog
&
this
-
>
uniforms
[
id
]
use_std430_as_default
)
;
}
struct
gl_shader_program
*
prog
;
struct
string_to_uint_map
*
map
;
struct
gl_uniform_storage
*
uniforms
;
unsigned
next_sampler
;
unsigned
next_bindless_sampler
;
unsigned
next_image
;
unsigned
next_bindless_image
;
unsigned
next_subroutine
;
bool
use_std430_as_default
;
unsigned
field_counter
;
ir_variable
*
current_var
;
int
explicit_location
;
unsigned
record_array_count
;
struct
string_to_uint_map
*
record_next_sampler
;
struct
string_to_uint_map
*
record_next_image
;
struct
string_to_uint_map
*
record_next_bindless_sampler
;
struct
string_to_uint_map
*
record_next_bindless_image
;
public
:
union
gl_constant_value
*
values
;
gl_texture_index
targets
[
MAX_SAMPLERS
]
;
unsigned
shader_samplers_used
;
unsigned
shader_shadow_samplers
;
unsigned
num_bindless_samplers
;
gl_texture_index
*
bindless_targets
;
unsigned
num_bindless_images
;
GLenum
*
bindless_access
;
unsigned
shader_storage_blocks_write_access
;
}
;
static
bool
variable_is_referenced
(
ir_array_refcount_visitor
&
v
ir_variable
*
var
)
{
ir_array_refcount_entry
*
const
entry
=
v
.
get_variable_entry
(
var
)
;
return
entry
-
>
is_referenced
;
}
static
void
link_update_uniform_buffer_variables
(
struct
gl_linked_shader
*
shader
unsigned
stage
)
{
ir_array_refcount_visitor
v
;
v
.
run
(
shader
-
>
ir
)
;
foreach_in_list
(
ir_instruction
node
shader
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
|
|
!
var
-
>
is_in_buffer_block
(
)
)
continue
;
assert
(
var
-
>
data
.
mode
=
=
ir_var_uniform
|
|
var
-
>
data
.
mode
=
=
ir_var_shader_storage
)
;
unsigned
num_blocks
=
var
-
>
data
.
mode
=
=
ir_var_uniform
?
shader
-
>
Program
-
>
info
.
num_ubos
:
shader
-
>
Program
-
>
info
.
num_ssbos
;
struct
gl_uniform_block
*
*
blks
=
var
-
>
data
.
mode
=
=
ir_var_uniform
?
shader
-
>
Program
-
>
sh
.
UniformBlocks
:
shader
-
>
Program
-
>
sh
.
ShaderStorageBlocks
;
if
(
var
-
>
is_interface_instance
(
)
)
{
const
ir_array_refcount_entry
*
const
entry
=
v
.
get_variable_entry
(
var
)
;
if
(
entry
-
>
is_referenced
)
{
assert
(
var
-
>
type
-
>
without_array
(
)
=
=
var
-
>
get_interface_type
(
)
)
;
const
char
sentinel
=
var
-
>
type
-
>
is_array
(
)
?
'
[
'
:
'
\
0
'
;
const
ptrdiff_t
len
=
strlen
(
var
-
>
get_interface_type
(
)
-
>
name
)
;
for
(
unsigned
i
=
0
;
i
<
num_blocks
;
i
+
+
)
{
const
char
*
const
begin
=
blks
[
i
]
-
>
Name
;
const
char
*
const
end
=
strchr
(
begin
sentinel
)
;
if
(
end
=
=
NULL
)
continue
;
if
(
len
!
=
(
end
-
begin
)
)
continue
;
if
(
strncmp
(
begin
var
-
>
get_interface_type
(
)
-
>
name
len
)
=
=
0
&
&
(
!
var
-
>
type
-
>
is_array
(
)
|
|
entry
-
>
is_linearized_index_referenced
(
blks
[
i
]
-
>
linearized_array_index
)
)
)
{
blks
[
i
]
-
>
stageref
|
=
1U
<
<
stage
;
}
}
}
var
-
>
data
.
location
=
0
;
continue
;
}
bool
found
=
false
;
char
sentinel
=
'
\
0
'
;
if
(
var
-
>
type
-
>
is_struct
(
)
)
{
sentinel
=
'
.
'
;
}
else
if
(
var
-
>
type
-
>
is_array
(
)
&
&
(
var
-
>
type
-
>
fields
.
array
-
>
is_array
(
)
|
|
var
-
>
type
-
>
without_array
(
)
-
>
is_struct
(
)
)
)
{
sentinel
=
'
[
'
;
}
const
unsigned
l
=
strlen
(
var
-
>
name
)
;
for
(
unsigned
i
=
0
;
i
<
num_blocks
;
i
+
+
)
{
for
(
unsigned
j
=
0
;
j
<
blks
[
i
]
-
>
NumUniforms
;
j
+
+
)
{
if
(
sentinel
)
{
const
char
*
begin
=
blks
[
i
]
-
>
Uniforms
[
j
]
.
Name
;
const
char
*
end
=
strchr
(
begin
sentinel
)
;
if
(
end
=
=
NULL
)
continue
;
if
(
(
ptrdiff_t
)
l
!
=
(
end
-
begin
)
)
continue
;
found
=
strncmp
(
var
-
>
name
begin
l
)
=
=
0
;
}
else
{
found
=
strcmp
(
var
-
>
name
blks
[
i
]
-
>
Uniforms
[
j
]
.
Name
)
=
=
0
;
}
if
(
found
)
{
var
-
>
data
.
location
=
j
;
if
(
variable_is_referenced
(
v
var
)
)
blks
[
i
]
-
>
stageref
|
=
1U
<
<
stage
;
break
;
}
}
if
(
found
)
break
;
}
assert
(
found
)
;
}
}
static
void
assign_hidden_uniform_slot_id
(
const
char
*
name
unsigned
hidden_id
void
*
closure
)
{
count_uniform_size
*
uniform_size
=
(
count_uniform_size
*
)
closure
;
unsigned
hidden_uniform_start
=
uniform_size
-
>
num_active_uniforms
-
uniform_size
-
>
num_hidden_uniforms
;
uniform_size
-
>
map
-
>
put
(
hidden_uniform_start
+
hidden_id
name
)
;
}
static
void
link_setup_uniform_remap_tables
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
)
{
unsigned
total_entries
=
prog
-
>
NumExplicitUniformLocations
;
unsigned
empty_locs
=
prog
-
>
NumUniformRemapTable
-
total_entries
;
for
(
unsigned
i
=
0
;
i
<
prog
-
>
data
-
>
NumUniformStorage
;
i
+
+
)
{
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
type
-
>
is_subroutine
(
)
|
|
prog
-
>
data
-
>
UniformStorage
[
i
]
.
is_shader_storage
)
continue
;
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
!
=
UNMAPPED_UNIFORM_LOC
)
{
const
unsigned
entries
=
MAX2
(
1
prog
-
>
data
-
>
UniformStorage
[
i
]
.
array_elements
)
;
for
(
unsigned
j
=
0
;
j
<
entries
;
j
+
+
)
{
unsigned
element_loc
=
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
+
j
;
assert
(
prog
-
>
UniformRemapTable
[
element_loc
]
=
=
INACTIVE_UNIFORM_EXPLICIT_LOCATION
)
;
prog
-
>
UniformRemapTable
[
element_loc
]
=
&
prog
-
>
data
-
>
UniformStorage
[
i
]
;
}
}
}
for
(
unsigned
i
=
0
;
i
<
prog
-
>
data
-
>
NumUniformStorage
;
i
+
+
)
{
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
type
-
>
is_subroutine
(
)
|
|
prog
-
>
data
-
>
UniformStorage
[
i
]
.
is_shader_storage
)
continue
;
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
builtin
)
continue
;
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
!
=
UNMAPPED_UNIFORM_LOC
)
continue
;
const
unsigned
entries
=
MAX2
(
1
prog
-
>
data
-
>
UniformStorage
[
i
]
.
array_elements
)
;
int
chosen_location
=
-
1
;
if
(
empty_locs
)
chosen_location
=
link_util_find_empty_block
(
prog
&
prog
-
>
data
-
>
UniformStorage
[
i
]
)
;
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
block_index
=
=
-
1
)
total_entries
+
=
entries
;
if
(
chosen_location
!
=
-
1
)
{
empty_locs
-
=
entries
;
}
else
{
chosen_location
=
prog
-
>
NumUniformRemapTable
;
prog
-
>
UniformRemapTable
=
reralloc
(
prog
prog
-
>
UniformRemapTable
gl_uniform_storage
*
prog
-
>
NumUniformRemapTable
+
entries
)
;
prog
-
>
NumUniformRemapTable
+
=
entries
;
}
for
(
unsigned
j
=
0
;
j
<
entries
;
j
+
+
)
prog
-
>
UniformRemapTable
[
chosen_location
+
j
]
=
&
prog
-
>
data
-
>
UniformStorage
[
i
]
;
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
=
chosen_location
;
}
if
(
total_entries
>
ctx
-
>
Const
.
MaxUserAssignableUniformLocations
)
{
linker_error
(
prog
"
count
of
uniform
locations
>
MAX_UNIFORM_LOCATIONS
"
"
(
%
u
>
%
u
)
"
total_entries
ctx
-
>
Const
.
MaxUserAssignableUniformLocations
)
;
}
for
(
unsigned
i
=
0
;
i
<
prog
-
>
data
-
>
NumUniformStorage
;
i
+
+
)
{
if
(
!
prog
-
>
data
-
>
UniformStorage
[
i
]
.
type
-
>
is_subroutine
(
)
)
continue
;
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
=
=
UNMAPPED_UNIFORM_LOC
)
continue
;
const
unsigned
entries
=
MAX2
(
1
prog
-
>
data
-
>
UniformStorage
[
i
]
.
array_elements
)
;
unsigned
mask
=
prog
-
>
data
-
>
linked_stages
;
while
(
mask
)
{
const
int
j
=
u_bit_scan
(
&
mask
)
;
struct
gl_program
*
p
=
prog
-
>
_LinkedShaders
[
j
]
-
>
Program
;
if
(
!
prog
-
>
data
-
>
UniformStorage
[
i
]
.
opaque
[
j
]
.
active
)
continue
;
for
(
unsigned
k
=
0
;
k
<
entries
;
k
+
+
)
{
unsigned
element_loc
=
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
+
k
;
assert
(
p
-
>
sh
.
SubroutineUniformRemapTable
[
element_loc
]
=
=
INACTIVE_UNIFORM_EXPLICIT_LOCATION
)
;
p
-
>
sh
.
SubroutineUniformRemapTable
[
element_loc
]
=
&
prog
-
>
data
-
>
UniformStorage
[
i
]
;
}
}
}
for
(
unsigned
i
=
0
;
i
<
prog
-
>
data
-
>
NumUniformStorage
;
i
+
+
)
{
if
(
!
prog
-
>
data
-
>
UniformStorage
[
i
]
.
type
-
>
is_subroutine
(
)
)
continue
;
if
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
!
=
UNMAPPED_UNIFORM_LOC
)
continue
;
const
unsigned
entries
=
MAX2
(
1
prog
-
>
data
-
>
UniformStorage
[
i
]
.
array_elements
)
;
unsigned
mask
=
prog
-
>
data
-
>
linked_stages
;
while
(
mask
)
{
const
int
j
=
u_bit_scan
(
&
mask
)
;
struct
gl_program
*
p
=
prog
-
>
_LinkedShaders
[
j
]
-
>
Program
;
if
(
!
prog
-
>
data
-
>
UniformStorage
[
i
]
.
opaque
[
j
]
.
active
)
continue
;
p
-
>
sh
.
SubroutineUniformRemapTable
=
reralloc
(
p
p
-
>
sh
.
SubroutineUniformRemapTable
gl_uniform_storage
*
p
-
>
sh
.
NumSubroutineUniformRemapTable
+
entries
)
;
for
(
unsigned
k
=
0
;
k
<
entries
;
k
+
+
)
{
p
-
>
sh
.
SubroutineUniformRemapTable
[
p
-
>
sh
.
NumSubroutineUniformRemapTable
+
k
]
=
&
prog
-
>
data
-
>
UniformStorage
[
i
]
;
}
prog
-
>
data
-
>
UniformStorage
[
i
]
.
remap_location
=
p
-
>
sh
.
NumSubroutineUniformRemapTable
;
p
-
>
sh
.
NumSubroutineUniformRemapTable
+
=
entries
;
}
}
}
static
void
link_assign_uniform_storage
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
const
unsigned
num_data_slots
)
{
if
(
prog
-
>
data
-
>
NumUniformStorage
=
=
0
)
return
;
unsigned
int
boolean_true
=
ctx
-
>
Const
.
UniformBooleanTrue
;
union
gl_constant_value
*
data
;
if
(
prog
-
>
data
-
>
UniformStorage
=
=
NULL
)
{
prog
-
>
data
-
>
UniformStorage
=
rzalloc_array
(
prog
-
>
data
struct
gl_uniform_storage
prog
-
>
data
-
>
NumUniformStorage
)
;
data
=
rzalloc_array
(
prog
-
>
data
-
>
UniformStorage
union
gl_constant_value
num_data_slots
)
;
prog
-
>
data
-
>
UniformDataDefaults
=
rzalloc_array
(
prog
-
>
data
-
>
UniformStorage
union
gl_constant_value
num_data_slots
)
;
}
else
{
data
=
prog
-
>
data
-
>
UniformDataSlots
;
}
#
ifndef
NDEBUG
union
gl_constant_value
*
data_end
=
&
data
[
num_data_slots
]
;
#
endif
parcel_out_uniform_storage
parcel
(
prog
prog
-
>
UniformHash
prog
-
>
data
-
>
UniformStorage
data
ctx
-
>
Const
.
UseSTD430AsDefaultPacking
)
;
for
(
unsigned
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
{
struct
gl_linked_shader
*
shader
=
prog
-
>
_LinkedShaders
[
i
]
;
if
(
!
shader
)
continue
;
parcel
.
start_shader
(
(
gl_shader_stage
)
i
)
;
foreach_in_list
(
ir_instruction
node
shader
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
(
var
=
=
NULL
)
|
|
(
var
-
>
data
.
mode
!
=
ir_var_uniform
&
&
var
-
>
data
.
mode
!
=
ir_var_shader_storage
)
)
continue
;
parcel
.
set_and_process
(
var
)
;
}
shader
-
>
Program
-
>
SamplersUsed
=
parcel
.
shader_samplers_used
;
shader
-
>
shadow_samplers
=
parcel
.
shader_shadow_samplers
;
shader
-
>
Program
-
>
sh
.
ShaderStorageBlocksWriteAccess
=
parcel
.
shader_storage_blocks_write_access
;
if
(
parcel
.
num_bindless_samplers
>
0
)
{
shader
-
>
Program
-
>
sh
.
NumBindlessSamplers
=
parcel
.
num_bindless_samplers
;
shader
-
>
Program
-
>
sh
.
BindlessSamplers
=
rzalloc_array
(
shader
-
>
Program
gl_bindless_sampler
parcel
.
num_bindless_samplers
)
;
for
(
unsigned
j
=
0
;
j
<
parcel
.
num_bindless_samplers
;
j
+
+
)
{
shader
-
>
Program
-
>
sh
.
BindlessSamplers
[
j
]
.
target
=
parcel
.
bindless_targets
[
j
]
;
}
}
if
(
parcel
.
num_bindless_images
>
0
)
{
shader
-
>
Program
-
>
sh
.
NumBindlessImages
=
parcel
.
num_bindless_images
;
shader
-
>
Program
-
>
sh
.
BindlessImages
=
rzalloc_array
(
shader
-
>
Program
gl_bindless_image
parcel
.
num_bindless_images
)
;
for
(
unsigned
j
=
0
;
j
<
parcel
.
num_bindless_images
;
j
+
+
)
{
shader
-
>
Program
-
>
sh
.
BindlessImages
[
j
]
.
access
=
parcel
.
bindless_access
[
j
]
;
}
}
STATIC_ASSERT
(
ARRAY_SIZE
(
shader
-
>
Program
-
>
sh
.
SamplerTargets
)
=
=
ARRAY_SIZE
(
parcel
.
targets
)
)
;
for
(
unsigned
j
=
0
;
j
<
ARRAY_SIZE
(
parcel
.
targets
)
;
j
+
+
)
shader
-
>
Program
-
>
sh
.
SamplerTargets
[
j
]
=
parcel
.
targets
[
j
]
;
}
#
ifndef
NDEBUG
for
(
unsigned
i
=
0
;
i
<
prog
-
>
data
-
>
NumUniformStorage
;
i
+
+
)
{
assert
(
prog
-
>
data
-
>
UniformStorage
[
i
]
.
storage
!
=
NULL
|
|
prog
-
>
data
-
>
UniformStorage
[
i
]
.
builtin
|
|
prog
-
>
data
-
>
UniformStorage
[
i
]
.
is_shader_storage
|
|
prog
-
>
data
-
>
UniformStorage
[
i
]
.
block_index
!
=
-
1
)
;
}
assert
(
parcel
.
values
=
=
data_end
)
;
#
endif
link_setup_uniform_remap_tables
(
ctx
prog
)
;
prog
-
>
data
-
>
NumUniformDataSlots
=
num_data_slots
;
prog
-
>
data
-
>
UniformDataSlots
=
data
;
link_set_uniform_initializers
(
prog
boolean_true
)
;
}
void
link_assign_uniform_locations
(
struct
gl_shader_program
*
prog
struct
gl_context
*
ctx
)
{
ralloc_free
(
prog
-
>
data
-
>
UniformStorage
)
;
prog
-
>
data
-
>
UniformStorage
=
NULL
;
prog
-
>
data
-
>
NumUniformStorage
=
0
;
if
(
prog
-
>
UniformHash
!
=
NULL
)
{
prog
-
>
UniformHash
-
>
clear
(
)
;
}
else
{
prog
-
>
UniformHash
=
new
string_to_uint_map
;
}
struct
string_to_uint_map
*
hiddenUniforms
=
new
string_to_uint_map
;
count_uniform_size
uniform_size
(
prog
-
>
UniformHash
hiddenUniforms
ctx
-
>
Const
.
UseSTD430AsDefaultPacking
)
;
for
(
unsigned
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
{
struct
gl_linked_shader
*
sh
=
prog
-
>
_LinkedShaders
[
i
]
;
if
(
sh
=
=
NULL
)
continue
;
link_update_uniform_buffer_variables
(
sh
i
)
;
uniform_size
.
start_shader
(
)
;
foreach_in_list
(
ir_instruction
node
sh
-
>
ir
)
{
ir_variable
*
const
var
=
node
-
>
as_variable
(
)
;
if
(
(
var
=
=
NULL
)
|
|
(
var
-
>
data
.
mode
!
=
ir_var_uniform
&
&
var
-
>
data
.
mode
!
=
ir_var_shader_storage
)
)
continue
;
uniform_size
.
process
(
var
)
;
}
if
(
uniform_size
.
num_shader_samplers
>
ctx
-
>
Const
.
Program
[
i
]
.
MaxTextureImageUnits
)
{
linker_error
(
prog
"
Too
many
%
s
shader
texture
samplers
\
n
"
_mesa_shader_stage_to_string
(
i
)
)
;
continue
;
}
if
(
uniform_size
.
num_shader_images
>
ctx
-
>
Const
.
Program
[
i
]
.
MaxImageUniforms
)
{
linker_error
(
prog
"
Too
many
%
s
shader
image
uniforms
(
%
u
>
%
u
)
\
n
"
_mesa_shader_stage_to_string
(
i
)
sh
-
>
Program
-
>
info
.
num_images
ctx
-
>
Const
.
Program
[
i
]
.
MaxImageUniforms
)
;
continue
;
}
sh
-
>
Program
-
>
info
.
num_textures
=
uniform_size
.
num_shader_samplers
;
sh
-
>
Program
-
>
info
.
num_images
=
uniform_size
.
num_shader_images
;
sh
-
>
num_uniform_components
=
uniform_size
.
num_shader_uniform_components
;
sh
-
>
num_combined_uniform_components
=
sh
-
>
num_uniform_components
;
for
(
unsigned
i
=
0
;
i
<
sh
-
>
Program
-
>
info
.
num_ubos
;
i
+
+
)
{
sh
-
>
num_combined_uniform_components
+
=
sh
-
>
Program
-
>
sh
.
UniformBlocks
[
i
]
-
>
UniformBufferSize
/
4
;
}
}
if
(
prog
-
>
data
-
>
LinkStatus
=
=
LINKING_FAILURE
)
{
delete
hiddenUniforms
;
return
;
}
prog
-
>
data
-
>
NumUniformStorage
=
uniform_size
.
num_active_uniforms
;
prog
-
>
data
-
>
NumHiddenUniforms
=
uniform_size
.
num_hidden_uniforms
;
hiddenUniforms
-
>
iterate
(
assign_hidden_uniform_slot_id
&
uniform_size
)
;
delete
hiddenUniforms
;
link_assign_uniform_storage
(
ctx
prog
uniform_size
.
num_values
)
;
}
