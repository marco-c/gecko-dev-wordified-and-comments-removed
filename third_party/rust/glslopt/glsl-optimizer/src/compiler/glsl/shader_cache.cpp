#
include
"
compiler
/
shader_info
.
h
"
#
include
"
glsl_symbol_table
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
ir
.
h
"
#
include
"
ir_optimization
.
h
"
#
include
"
ir_rvalue_visitor
.
h
"
#
include
"
ir_uniform
.
h
"
#
include
"
linker
.
h
"
#
include
"
link_varyings
.
h
"
#
include
"
program
.
h
"
#
include
"
serialize
.
h
"
#
include
"
shader_cache
.
h
"
#
include
"
util
/
mesa
-
sha1
.
h
"
#
include
"
string_to_uint_map
.
h
"
#
include
"
main
/
mtypes
.
h
"
extern
"
C
"
{
#
include
"
main
/
enums
.
h
"
#
include
"
main
/
shaderobj
.
h
"
#
include
"
program
/
program
.
h
"
}
static
void
compile_shaders
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
)
{
for
(
unsigned
i
=
0
;
i
<
prog
-
>
NumShaders
;
i
+
+
)
{
_mesa_glsl_compile_shader
(
ctx
prog
-
>
Shaders
[
i
]
false
false
true
)
;
}
}
static
void
create_binding_str
(
const
char
*
key
unsigned
value
void
*
closure
)
{
char
*
*
bindings_str
=
(
char
*
*
)
closure
;
ralloc_asprintf_append
(
bindings_str
"
%
s
:
%
u
"
key
value
)
;
}
void
shader_cache_write_program_metadata
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
)
{
struct
disk_cache
*
cache
=
ctx
-
>
Cache
;
if
(
!
cache
)
return
;
static
const
char
zero
[
sizeof
(
prog
-
>
data
-
>
sha1
)
]
=
{
0
}
;
if
(
memcmp
(
prog
-
>
data
-
>
sha1
zero
sizeof
(
prog
-
>
data
-
>
sha1
)
)
=
=
0
)
return
;
struct
blob
metadata
;
blob_init
(
&
metadata
)
;
if
(
ctx
-
>
Driver
.
ShaderCacheSerializeDriverBlob
)
{
for
(
unsigned
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
{
struct
gl_linked_shader
*
sh
=
prog
-
>
_LinkedShaders
[
i
]
;
if
(
sh
)
ctx
-
>
Driver
.
ShaderCacheSerializeDriverBlob
(
ctx
sh
-
>
Program
)
;
}
}
serialize_glsl_program
(
&
metadata
ctx
prog
)
;
struct
cache_item_metadata
cache_item_metadata
;
cache_item_metadata
.
type
=
CACHE_ITEM_TYPE_GLSL
;
cache_item_metadata
.
keys
=
(
cache_key
*
)
malloc
(
prog
-
>
NumShaders
*
sizeof
(
cache_key
)
)
;
cache_item_metadata
.
num_keys
=
prog
-
>
NumShaders
;
if
(
!
cache_item_metadata
.
keys
)
goto
fail
;
for
(
unsigned
i
=
0
;
i
<
prog
-
>
NumShaders
;
i
+
+
)
{
memcpy
(
cache_item_metadata
.
keys
[
i
]
prog
-
>
Shaders
[
i
]
-
>
sha1
sizeof
(
cache_key
)
)
;
}
disk_cache_put
(
cache
prog
-
>
data
-
>
sha1
metadata
.
data
metadata
.
size
&
cache_item_metadata
)
;
char
sha1_buf
[
41
]
;
if
(
ctx
-
>
_Shader
-
>
Flags
&
GLSL_CACHE_INFO
)
{
_mesa_sha1_format
(
sha1_buf
prog
-
>
data
-
>
sha1
)
;
fprintf
(
stderr
"
putting
program
metadata
in
cache
:
%
s
\
n
"
sha1_buf
)
;
}
fail
:
free
(
cache_item_metadata
.
keys
)
;
blob_finish
(
&
metadata
)
;
}
bool
shader_cache_read_program_metadata
(
struct
gl_context
*
ctx
struct
gl_shader_program
*
prog
)
{
if
(
prog
-
>
Name
=
=
0
|
|
prog
-
>
data
-
>
spirv
)
return
false
;
struct
disk_cache
*
cache
=
ctx
-
>
Cache
;
if
(
!
cache
)
return
false
;
char
*
buf
=
ralloc_strdup
(
NULL
"
vb
:
"
)
;
prog
-
>
AttributeBindings
-
>
iterate
(
create_binding_str
&
buf
)
;
ralloc_strcat
(
&
buf
"
fb
:
"
)
;
prog
-
>
FragDataBindings
-
>
iterate
(
create_binding_str
&
buf
)
;
ralloc_strcat
(
&
buf
"
fbi
:
"
)
;
prog
-
>
FragDataIndexBindings
-
>
iterate
(
create_binding_str
&
buf
)
;
ralloc_asprintf_append
(
&
buf
"
tf
:
%
d
"
prog
-
>
TransformFeedback
.
BufferMode
)
;
for
(
unsigned
int
i
=
0
;
i
<
prog
-
>
TransformFeedback
.
NumVarying
;
i
+
+
)
{
ralloc_asprintf_append
(
&
buf
"
%
s
"
prog
-
>
TransformFeedback
.
VaryingNames
[
i
]
)
;
}
ralloc_asprintf_append
(
&
buf
"
sso
:
%
s
\
n
"
prog
-
>
SeparateShader
?
"
T
"
:
"
F
"
)
;
ralloc_asprintf_append
(
&
buf
"
api
:
%
d
glsl
:
%
d
fglsl
:
%
d
\
n
"
ctx
-
>
API
ctx
-
>
Const
.
GLSLVersion
ctx
-
>
Const
.
ForceGLSLVersion
)
;
char
*
ext_override
=
getenv
(
"
MESA_EXTENSION_OVERRIDE
"
)
;
if
(
ext_override
)
{
ralloc_asprintf_append
(
&
buf
"
ext
:
%
s
"
ext_override
)
;
}
char
sha1buf
[
41
]
;
_mesa_sha1_format
(
sha1buf
ctx
-
>
Const
.
dri_config_options_sha1
)
;
ralloc_strcat
(
&
buf
sha1buf
)
;
for
(
unsigned
i
=
0
;
i
<
prog
-
>
NumShaders
;
i
+
+
)
{
struct
gl_shader
*
sh
=
prog
-
>
Shaders
[
i
]
;
_mesa_sha1_format
(
sha1buf
sh
-
>
sha1
)
;
ralloc_asprintf_append
(
&
buf
"
%
s
:
%
s
\
n
"
_mesa_shader_stage_to_abbrev
(
sh
-
>
Stage
)
sha1buf
)
;
}
disk_cache_compute_key
(
cache
buf
strlen
(
buf
)
prog
-
>
data
-
>
sha1
)
;
ralloc_free
(
buf
)
;
size_t
size
;
uint8_t
*
buffer
=
(
uint8_t
*
)
disk_cache_get
(
cache
prog
-
>
data
-
>
sha1
&
size
)
;
if
(
buffer
=
=
NULL
)
{
compile_shaders
(
ctx
prog
)
;
return
false
;
}
if
(
ctx
-
>
_Shader
-
>
Flags
&
GLSL_CACHE_INFO
)
{
_mesa_sha1_format
(
sha1buf
prog
-
>
data
-
>
sha1
)
;
fprintf
(
stderr
"
loading
shader
program
meta
data
from
cache
:
%
s
\
n
"
sha1buf
)
;
}
struct
blob_reader
metadata
;
blob_reader_init
(
&
metadata
buffer
size
)
;
bool
deserialized
=
deserialize_glsl_program
(
&
metadata
ctx
prog
)
;
if
(
!
deserialized
|
|
metadata
.
current
!
=
metadata
.
end
|
|
metadata
.
overrun
)
{
assert
(
!
"
Invalid
GLSL
shader
disk
cache
item
!
"
)
;
if
(
ctx
-
>
_Shader
-
>
Flags
&
GLSL_CACHE_INFO
)
{
fprintf
(
stderr
"
Error
reading
program
from
cache
(
invalid
GLSL
"
"
cache
item
)
\
n
"
)
;
}
disk_cache_remove
(
cache
prog
-
>
data
-
>
sha1
)
;
compile_shaders
(
ctx
prog
)
;
free
(
buffer
)
;
return
false
;
}
prog
-
>
data
-
>
LinkStatus
=
LINKING_SKIPPED
;
free
(
buffer
)
;
return
true
;
}
