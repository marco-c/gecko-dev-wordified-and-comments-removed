#
include
"
glsl_symbol_table
.
h
"
#
include
"
ir
.
h
"
#
include
"
ir_builder
.
h
"
#
include
"
ir_optimization
.
h
"
#
include
"
program
/
prog_instruction
.
h
"
#
include
"
main
/
mtypes
.
h
"
using
namespace
ir_builder
;
namespace
{
class
lower_packed_varyings_visitor
{
public
:
lower_packed_varyings_visitor
(
void
*
mem_ctx
unsigned
locations_used
const
uint8_t
*
components
ir_variable_mode
mode
unsigned
gs_input_vertices
exec_list
*
out_instructions
exec_list
*
out_variables
bool
disable_varying_packing
bool
xfb_enabled
)
;
void
run
(
struct
gl_linked_shader
*
shader
)
;
private
:
void
bitwise_assign_pack
(
ir_rvalue
*
lhs
ir_rvalue
*
rhs
)
;
void
bitwise_assign_unpack
(
ir_rvalue
*
lhs
ir_rvalue
*
rhs
)
;
unsigned
lower_rvalue
(
ir_rvalue
*
rvalue
unsigned
fine_location
ir_variable
*
unpacked_var
const
char
*
name
bool
gs_input_toplevel
unsigned
vertex_index
)
;
unsigned
lower_arraylike
(
ir_rvalue
*
rvalue
unsigned
array_size
unsigned
fine_location
ir_variable
*
unpacked_var
const
char
*
name
bool
gs_input_toplevel
unsigned
vertex_index
)
;
ir_dereference
*
get_packed_varying_deref
(
unsigned
location
ir_variable
*
unpacked_var
const
char
*
name
unsigned
vertex_index
)
;
bool
needs_lowering
(
ir_variable
*
var
)
;
void
*
const
mem_ctx
;
const
unsigned
locations_used
;
const
uint8_t
*
components
;
ir_variable
*
*
packed_varyings
;
const
ir_variable_mode
mode
;
const
unsigned
gs_input_vertices
;
exec_list
*
out_instructions
;
exec_list
*
out_variables
;
bool
disable_varying_packing
;
bool
xfb_enabled
;
}
;
}
lower_packed_varyings_visitor
:
:
lower_packed_varyings_visitor
(
void
*
mem_ctx
unsigned
locations_used
const
uint8_t
*
components
ir_variable_mode
mode
unsigned
gs_input_vertices
exec_list
*
out_instructions
exec_list
*
out_variables
bool
disable_varying_packing
bool
xfb_enabled
)
:
mem_ctx
(
mem_ctx
)
locations_used
(
locations_used
)
components
(
components
)
packed_varyings
(
(
ir_variable
*
*
)
rzalloc_array_size
(
mem_ctx
sizeof
(
*
packed_varyings
)
locations_used
)
)
mode
(
mode
)
gs_input_vertices
(
gs_input_vertices
)
out_instructions
(
out_instructions
)
out_variables
(
out_variables
)
disable_varying_packing
(
disable_varying_packing
)
xfb_enabled
(
xfb_enabled
)
{
}
void
lower_packed_varyings_visitor
:
:
run
(
struct
gl_linked_shader
*
shader
)
{
foreach_in_list
(
ir_instruction
node
shader
-
>
ir
)
{
ir_variable
*
var
=
node
-
>
as_variable
(
)
;
if
(
var
=
=
NULL
)
continue
;
if
(
var
-
>
data
.
mode
!
=
this
-
>
mode
|
|
var
-
>
data
.
location
<
VARYING_SLOT_VAR0
|
|
!
this
-
>
needs_lowering
(
var
)
)
continue
;
assert
(
var
-
>
data
.
interpolation
=
=
INTERP_MODE_FLAT
|
|
var
-
>
data
.
interpolation
=
=
INTERP_MODE_NONE
|
|
!
var
-
>
type
-
>
contains_integer
(
)
)
;
if
(
!
shader
-
>
packed_varyings
)
shader
-
>
packed_varyings
=
new
(
shader
)
exec_list
;
shader
-
>
packed_varyings
-
>
push_tail
(
var
-
>
clone
(
shader
NULL
)
)
;
assert
(
var
-
>
data
.
mode
!
=
ir_var_temporary
)
;
var
-
>
data
.
mode
=
ir_var_auto
;
ir_dereference_variable
*
deref
=
new
(
this
-
>
mem_ctx
)
ir_dereference_variable
(
var
)
;
this
-
>
lower_rvalue
(
deref
var
-
>
data
.
location
*
4
+
var
-
>
data
.
location_frac
var
var
-
>
name
this
-
>
gs_input_vertices
!
=
0
0
)
;
}
}
#
define
SWIZZLE_ZWZW
MAKE_SWIZZLE4
(
SWIZZLE_Z
SWIZZLE_W
SWIZZLE_Z
SWIZZLE_W
)
void
lower_packed_varyings_visitor
:
:
bitwise_assign_pack
(
ir_rvalue
*
lhs
ir_rvalue
*
rhs
)
{
if
(
lhs
-
>
type
-
>
base_type
!
=
rhs
-
>
type
-
>
base_type
)
{
assert
(
lhs
-
>
type
-
>
base_type
=
=
GLSL_TYPE_INT
)
;
switch
(
rhs
-
>
type
-
>
base_type
)
{
case
GLSL_TYPE_UINT
:
rhs
=
new
(
this
-
>
mem_ctx
)
ir_expression
(
ir_unop_u2i
lhs
-
>
type
rhs
)
;
break
;
case
GLSL_TYPE_FLOAT
:
rhs
=
new
(
this
-
>
mem_ctx
)
ir_expression
(
ir_unop_bitcast_f2i
lhs
-
>
type
rhs
)
;
break
;
case
GLSL_TYPE_DOUBLE
:
assert
(
rhs
-
>
type
-
>
vector_elements
<
=
2
)
;
if
(
rhs
-
>
type
-
>
vector_elements
=
=
2
)
{
ir_variable
*
t
=
new
(
mem_ctx
)
ir_variable
(
lhs
-
>
type
"
pack
"
ir_var_temporary
)
;
assert
(
lhs
-
>
type
-
>
vector_elements
=
=
4
)
;
this
-
>
out_variables
-
>
push_tail
(
t
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
u2i
(
expr
(
ir_unop_unpack_double_2x32
swizzle_x
(
rhs
-
>
clone
(
mem_ctx
NULL
)
)
)
)
0x3
)
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
u2i
(
expr
(
ir_unop_unpack_double_2x32
swizzle_y
(
rhs
)
)
)
0xc
)
)
;
rhs
=
deref
(
t
)
.
val
;
}
else
{
rhs
=
u2i
(
expr
(
ir_unop_unpack_double_2x32
rhs
)
)
;
}
break
;
case
GLSL_TYPE_INT64
:
assert
(
rhs
-
>
type
-
>
vector_elements
<
=
2
)
;
if
(
rhs
-
>
type
-
>
vector_elements
=
=
2
)
{
ir_variable
*
t
=
new
(
mem_ctx
)
ir_variable
(
lhs
-
>
type
"
pack
"
ir_var_temporary
)
;
assert
(
lhs
-
>
type
-
>
vector_elements
=
=
4
)
;
this
-
>
out_variables
-
>
push_tail
(
t
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_unpack_int_2x32
swizzle_x
(
rhs
-
>
clone
(
mem_ctx
NULL
)
)
)
0x3
)
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_unpack_int_2x32
swizzle_y
(
rhs
)
)
0xc
)
)
;
rhs
=
deref
(
t
)
.
val
;
}
else
{
rhs
=
expr
(
ir_unop_unpack_int_2x32
rhs
)
;
}
break
;
case
GLSL_TYPE_UINT64
:
assert
(
rhs
-
>
type
-
>
vector_elements
<
=
2
)
;
if
(
rhs
-
>
type
-
>
vector_elements
=
=
2
)
{
ir_variable
*
t
=
new
(
mem_ctx
)
ir_variable
(
lhs
-
>
type
"
pack
"
ir_var_temporary
)
;
assert
(
lhs
-
>
type
-
>
vector_elements
=
=
4
)
;
this
-
>
out_variables
-
>
push_tail
(
t
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
u2i
(
expr
(
ir_unop_unpack_uint_2x32
swizzle_x
(
rhs
-
>
clone
(
mem_ctx
NULL
)
)
)
)
0x3
)
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
u2i
(
expr
(
ir_unop_unpack_uint_2x32
swizzle_y
(
rhs
)
)
)
0xc
)
)
;
rhs
=
deref
(
t
)
.
val
;
}
else
{
rhs
=
u2i
(
expr
(
ir_unop_unpack_uint_2x32
rhs
)
)
;
}
break
;
case
GLSL_TYPE_SAMPLER
:
rhs
=
u2i
(
expr
(
ir_unop_unpack_sampler_2x32
rhs
)
)
;
break
;
case
GLSL_TYPE_IMAGE
:
rhs
=
u2i
(
expr
(
ir_unop_unpack_image_2x32
rhs
)
)
;
break
;
default
:
assert
(
!
"
Unexpected
type
conversion
while
lowering
varyings
"
)
;
break
;
}
}
this
-
>
out_instructions
-
>
push_tail
(
new
(
this
-
>
mem_ctx
)
ir_assignment
(
lhs
rhs
)
)
;
}
void
lower_packed_varyings_visitor
:
:
bitwise_assign_unpack
(
ir_rvalue
*
lhs
ir_rvalue
*
rhs
)
{
if
(
lhs
-
>
type
-
>
base_type
!
=
rhs
-
>
type
-
>
base_type
)
{
assert
(
rhs
-
>
type
-
>
base_type
=
=
GLSL_TYPE_INT
)
;
switch
(
lhs
-
>
type
-
>
base_type
)
{
case
GLSL_TYPE_UINT
:
rhs
=
new
(
this
-
>
mem_ctx
)
ir_expression
(
ir_unop_i2u
lhs
-
>
type
rhs
)
;
break
;
case
GLSL_TYPE_FLOAT
:
rhs
=
new
(
this
-
>
mem_ctx
)
ir_expression
(
ir_unop_bitcast_i2f
lhs
-
>
type
rhs
)
;
break
;
case
GLSL_TYPE_DOUBLE
:
assert
(
lhs
-
>
type
-
>
vector_elements
<
=
2
)
;
if
(
lhs
-
>
type
-
>
vector_elements
=
=
2
)
{
ir_variable
*
t
=
new
(
mem_ctx
)
ir_variable
(
lhs
-
>
type
"
unpack
"
ir_var_temporary
)
;
assert
(
rhs
-
>
type
-
>
vector_elements
=
=
4
)
;
this
-
>
out_variables
-
>
push_tail
(
t
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_pack_double_2x32
i2u
(
swizzle_xy
(
rhs
-
>
clone
(
mem_ctx
NULL
)
)
)
)
0x1
)
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_pack_double_2x32
i2u
(
swizzle
(
rhs
-
>
clone
(
mem_ctx
NULL
)
SWIZZLE_ZWZW
2
)
)
)
0x2
)
)
;
rhs
=
deref
(
t
)
.
val
;
}
else
{
rhs
=
expr
(
ir_unop_pack_double_2x32
i2u
(
rhs
)
)
;
}
break
;
case
GLSL_TYPE_INT64
:
assert
(
lhs
-
>
type
-
>
vector_elements
<
=
2
)
;
if
(
lhs
-
>
type
-
>
vector_elements
=
=
2
)
{
ir_variable
*
t
=
new
(
mem_ctx
)
ir_variable
(
lhs
-
>
type
"
unpack
"
ir_var_temporary
)
;
assert
(
rhs
-
>
type
-
>
vector_elements
=
=
4
)
;
this
-
>
out_variables
-
>
push_tail
(
t
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_pack_int_2x32
swizzle_xy
(
rhs
-
>
clone
(
mem_ctx
NULL
)
)
)
0x1
)
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_pack_int_2x32
swizzle
(
rhs
-
>
clone
(
mem_ctx
NULL
)
SWIZZLE_ZWZW
2
)
)
0x2
)
)
;
rhs
=
deref
(
t
)
.
val
;
}
else
{
rhs
=
expr
(
ir_unop_pack_int_2x32
rhs
)
;
}
break
;
case
GLSL_TYPE_UINT64
:
assert
(
lhs
-
>
type
-
>
vector_elements
<
=
2
)
;
if
(
lhs
-
>
type
-
>
vector_elements
=
=
2
)
{
ir_variable
*
t
=
new
(
mem_ctx
)
ir_variable
(
lhs
-
>
type
"
unpack
"
ir_var_temporary
)
;
assert
(
rhs
-
>
type
-
>
vector_elements
=
=
4
)
;
this
-
>
out_variables
-
>
push_tail
(
t
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_pack_uint_2x32
i2u
(
swizzle_xy
(
rhs
-
>
clone
(
mem_ctx
NULL
)
)
)
)
0x1
)
)
;
this
-
>
out_instructions
-
>
push_tail
(
assign
(
t
expr
(
ir_unop_pack_uint_2x32
i2u
(
swizzle
(
rhs
-
>
clone
(
mem_ctx
NULL
)
SWIZZLE_ZWZW
2
)
)
)
0x2
)
)
;
rhs
=
deref
(
t
)
.
val
;
}
else
{
rhs
=
expr
(
ir_unop_pack_uint_2x32
i2u
(
rhs
)
)
;
}
break
;
case
GLSL_TYPE_SAMPLER
:
rhs
=
new
(
mem_ctx
)
ir_expression
(
ir_unop_pack_sampler_2x32
lhs
-
>
type
i2u
(
rhs
)
)
;
break
;
case
GLSL_TYPE_IMAGE
:
rhs
=
new
(
mem_ctx
)
ir_expression
(
ir_unop_pack_image_2x32
lhs
-
>
type
i2u
(
rhs
)
)
;
break
;
default
:
assert
(
!
"
Unexpected
type
conversion
while
lowering
varyings
"
)
;
break
;
}
}
this
-
>
out_instructions
-
>
push_tail
(
new
(
this
-
>
mem_ctx
)
ir_assignment
(
lhs
rhs
)
)
;
}
unsigned
lower_packed_varyings_visitor
:
:
lower_rvalue
(
ir_rvalue
*
rvalue
unsigned
fine_location
ir_variable
*
unpacked_var
const
char
*
name
bool
gs_input_toplevel
unsigned
vertex_index
)
{
unsigned
dmul
=
rvalue
-
>
type
-
>
is_64bit
(
)
?
2
:
1
;
assert
(
!
gs_input_toplevel
|
|
rvalue
-
>
type
-
>
is_array
(
)
)
;
if
(
rvalue
-
>
type
-
>
is_struct
(
)
)
{
for
(
unsigned
i
=
0
;
i
<
rvalue
-
>
type
-
>
length
;
i
+
+
)
{
if
(
i
!
=
0
)
rvalue
=
rvalue
-
>
clone
(
this
-
>
mem_ctx
NULL
)
;
const
char
*
field_name
=
rvalue
-
>
type
-
>
fields
.
structure
[
i
]
.
name
;
ir_dereference_record
*
dereference_record
=
new
(
this
-
>
mem_ctx
)
ir_dereference_record
(
rvalue
field_name
)
;
char
*
deref_name
=
ralloc_asprintf
(
this
-
>
mem_ctx
"
%
s
.
%
s
"
name
field_name
)
;
fine_location
=
this
-
>
lower_rvalue
(
dereference_record
fine_location
unpacked_var
deref_name
false
vertex_index
)
;
}
return
fine_location
;
}
else
if
(
rvalue
-
>
type
-
>
is_array
(
)
)
{
return
this
-
>
lower_arraylike
(
rvalue
rvalue
-
>
type
-
>
array_size
(
)
fine_location
unpacked_var
name
gs_input_toplevel
vertex_index
)
;
}
else
if
(
rvalue
-
>
type
-
>
is_matrix
(
)
)
{
return
this
-
>
lower_arraylike
(
rvalue
rvalue
-
>
type
-
>
matrix_columns
fine_location
unpacked_var
name
false
vertex_index
)
;
}
else
if
(
rvalue
-
>
type
-
>
vector_elements
*
dmul
+
fine_location
%
4
>
4
)
{
unsigned
left_components
right_components
;
unsigned
left_swizzle_values
[
4
]
=
{
0
0
0
0
}
;
unsigned
right_swizzle_values
[
4
]
=
{
0
0
0
0
}
;
char
left_swizzle_name
[
4
]
=
{
0
0
0
0
}
;
char
right_swizzle_name
[
4
]
=
{
0
0
0
0
}
;
left_components
=
4
-
fine_location
%
4
;
if
(
rvalue
-
>
type
-
>
is_64bit
(
)
)
{
left_components
/
=
2
;
}
right_components
=
rvalue
-
>
type
-
>
vector_elements
-
left_components
;
for
(
unsigned
i
=
0
;
i
<
left_components
;
i
+
+
)
{
left_swizzle_values
[
i
]
=
i
;
left_swizzle_name
[
i
]
=
"
xyzw
"
[
i
]
;
}
for
(
unsigned
i
=
0
;
i
<
right_components
;
i
+
+
)
{
right_swizzle_values
[
i
]
=
i
+
left_components
;
right_swizzle_name
[
i
]
=
"
xyzw
"
[
i
+
left_components
]
;
}
ir_swizzle
*
left_swizzle
=
new
(
this
-
>
mem_ctx
)
ir_swizzle
(
rvalue
left_swizzle_values
left_components
)
;
ir_swizzle
*
right_swizzle
=
new
(
this
-
>
mem_ctx
)
ir_swizzle
(
rvalue
-
>
clone
(
this
-
>
mem_ctx
NULL
)
right_swizzle_values
right_components
)
;
char
*
left_name
=
ralloc_asprintf
(
this
-
>
mem_ctx
"
%
s
.
%
s
"
name
left_swizzle_name
)
;
char
*
right_name
=
ralloc_asprintf
(
this
-
>
mem_ctx
"
%
s
.
%
s
"
name
right_swizzle_name
)
;
if
(
left_components
)
fine_location
=
this
-
>
lower_rvalue
(
left_swizzle
fine_location
unpacked_var
left_name
false
vertex_index
)
;
else
fine_location
+
+
;
return
this
-
>
lower_rvalue
(
right_swizzle
fine_location
unpacked_var
right_name
false
vertex_index
)
;
}
else
{
unsigned
swizzle_values
[
4
]
=
{
0
0
0
0
}
;
unsigned
components
=
rvalue
-
>
type
-
>
vector_elements
*
dmul
;
unsigned
location
=
fine_location
/
4
;
unsigned
location_frac
=
fine_location
%
4
;
for
(
unsigned
i
=
0
;
i
<
components
;
+
+
i
)
swizzle_values
[
i
]
=
i
+
location_frac
;
ir_dereference
*
packed_deref
=
this
-
>
get_packed_varying_deref
(
location
unpacked_var
name
vertex_index
)
;
if
(
unpacked_var
-
>
data
.
stream
!
=
0
)
{
assert
(
unpacked_var
-
>
data
.
stream
<
4
)
;
ir_variable
*
packed_var
=
packed_deref
-
>
variable_referenced
(
)
;
for
(
unsigned
i
=
0
;
i
<
components
;
+
+
i
)
{
packed_var
-
>
data
.
stream
|
=
unpacked_var
-
>
data
.
stream
<
<
(
2
*
(
location_frac
+
i
)
)
;
}
}
ir_swizzle
*
swizzle
=
new
(
this
-
>
mem_ctx
)
ir_swizzle
(
packed_deref
swizzle_values
components
)
;
if
(
this
-
>
mode
=
=
ir_var_shader_out
)
{
this
-
>
bitwise_assign_pack
(
swizzle
rvalue
)
;
}
else
{
this
-
>
bitwise_assign_unpack
(
rvalue
swizzle
)
;
}
return
fine_location
+
components
;
}
}
unsigned
lower_packed_varyings_visitor
:
:
lower_arraylike
(
ir_rvalue
*
rvalue
unsigned
array_size
unsigned
fine_location
ir_variable
*
unpacked_var
const
char
*
name
bool
gs_input_toplevel
unsigned
vertex_index
)
{
for
(
unsigned
i
=
0
;
i
<
array_size
;
i
+
+
)
{
if
(
i
!
=
0
)
rvalue
=
rvalue
-
>
clone
(
this
-
>
mem_ctx
NULL
)
;
ir_constant
*
constant
=
new
(
this
-
>
mem_ctx
)
ir_constant
(
i
)
;
ir_dereference_array
*
dereference_array
=
new
(
this
-
>
mem_ctx
)
ir_dereference_array
(
rvalue
constant
)
;
if
(
gs_input_toplevel
)
{
(
void
)
this
-
>
lower_rvalue
(
dereference_array
fine_location
unpacked_var
name
false
i
)
;
}
else
{
char
*
subscripted_name
=
ralloc_asprintf
(
this
-
>
mem_ctx
"
%
s
[
%
d
]
"
name
i
)
;
fine_location
=
this
-
>
lower_rvalue
(
dereference_array
fine_location
unpacked_var
subscripted_name
false
vertex_index
)
;
}
}
return
fine_location
;
}
ir_dereference
*
lower_packed_varyings_visitor
:
:
get_packed_varying_deref
(
unsigned
location
ir_variable
*
unpacked_var
const
char
*
name
unsigned
vertex_index
)
{
unsigned
slot
=
location
-
VARYING_SLOT_VAR0
;
assert
(
slot
<
locations_used
)
;
if
(
this
-
>
packed_varyings
[
slot
]
=
=
NULL
)
{
char
*
packed_name
=
ralloc_asprintf
(
this
-
>
mem_ctx
"
packed
:
%
s
"
name
)
;
const
glsl_type
*
packed_type
;
assert
(
components
[
slot
]
!
=
0
)
;
if
(
unpacked_var
-
>
is_interpolation_flat
(
)
)
packed_type
=
glsl_type
:
:
get_instance
(
GLSL_TYPE_INT
components
[
slot
]
1
)
;
else
packed_type
=
glsl_type
:
:
get_instance
(
GLSL_TYPE_FLOAT
components
[
slot
]
1
)
;
if
(
this
-
>
gs_input_vertices
!
=
0
)
{
packed_type
=
glsl_type
:
:
get_array_instance
(
packed_type
this
-
>
gs_input_vertices
)
;
}
ir_variable
*
packed_var
=
new
(
this
-
>
mem_ctx
)
ir_variable
(
packed_type
packed_name
this
-
>
mode
)
;
if
(
this
-
>
gs_input_vertices
!
=
0
)
{
packed_var
-
>
data
.
max_array_access
=
this
-
>
gs_input_vertices
-
1
;
}
packed_var
-
>
data
.
centroid
=
unpacked_var
-
>
data
.
centroid
;
packed_var
-
>
data
.
sample
=
unpacked_var
-
>
data
.
sample
;
packed_var
-
>
data
.
patch
=
unpacked_var
-
>
data
.
patch
;
packed_var
-
>
data
.
interpolation
=
packed_type
-
>
without_array
(
)
=
=
glsl_type
:
:
ivec4_type
?
unsigned
(
INTERP_MODE_FLAT
)
:
unpacked_var
-
>
data
.
interpolation
;
packed_var
-
>
data
.
location
=
location
;
packed_var
-
>
data
.
precision
=
unpacked_var
-
>
data
.
precision
;
packed_var
-
>
data
.
always_active_io
=
unpacked_var
-
>
data
.
always_active_io
;
packed_var
-
>
data
.
stream
=
1u
<
<
31
;
unpacked_var
-
>
insert_before
(
packed_var
)
;
this
-
>
packed_varyings
[
slot
]
=
packed_var
;
}
else
{
ir_variable
*
var
=
this
-
>
packed_varyings
[
slot
]
;
var
-
>
data
.
always_active_io
|
=
unpacked_var
-
>
data
.
always_active_io
;
if
(
this
-
>
gs_input_vertices
=
=
0
|
|
vertex_index
=
=
0
)
{
if
(
var
-
>
is_name_ralloced
(
)
)
ralloc_asprintf_append
(
(
char
*
*
)
&
var
-
>
name
"
%
s
"
name
)
;
else
var
-
>
name
=
ralloc_asprintf
(
var
"
%
s
%
s
"
var
-
>
name
name
)
;
}
}
ir_dereference
*
deref
=
new
(
this
-
>
mem_ctx
)
ir_dereference_variable
(
this
-
>
packed_varyings
[
slot
]
)
;
if
(
this
-
>
gs_input_vertices
!
=
0
)
{
ir_constant
*
constant
=
new
(
this
-
>
mem_ctx
)
ir_constant
(
vertex_index
)
;
deref
=
new
(
this
-
>
mem_ctx
)
ir_dereference_array
(
deref
constant
)
;
}
return
deref
;
}
bool
lower_packed_varyings_visitor
:
:
needs_lowering
(
ir_variable
*
var
)
{
if
(
var
-
>
data
.
explicit_location
|
|
var
-
>
data
.
must_be_shader_input
)
return
false
;
const
glsl_type
*
type
=
var
-
>
type
;
if
(
disable_varying_packing
&
&
!
var
-
>
data
.
is_xfb_only
&
&
!
(
(
type
-
>
is_array
(
)
|
|
type
-
>
is_struct
(
)
|
|
type
-
>
is_matrix
(
)
)
&
&
xfb_enabled
)
)
return
false
;
type
=
type
-
>
without_array
(
)
;
if
(
type
-
>
vector_elements
=
=
4
&
&
!
type
-
>
is_64bit
(
)
)
return
false
;
return
true
;
}
class
lower_packed_varyings_gs_splicer
:
public
ir_hierarchical_visitor
{
public
:
explicit
lower_packed_varyings_gs_splicer
(
void
*
mem_ctx
const
exec_list
*
instructions
)
;
virtual
ir_visitor_status
visit_leave
(
ir_emit_vertex
*
ev
)
;
private
:
void
*
const
mem_ctx
;
const
exec_list
*
instructions
;
}
;
lower_packed_varyings_gs_splicer
:
:
lower_packed_varyings_gs_splicer
(
void
*
mem_ctx
const
exec_list
*
instructions
)
:
mem_ctx
(
mem_ctx
)
instructions
(
instructions
)
{
}
ir_visitor_status
lower_packed_varyings_gs_splicer
:
:
visit_leave
(
ir_emit_vertex
*
ev
)
{
foreach_in_list
(
ir_instruction
ir
this
-
>
instructions
)
{
ev
-
>
insert_before
(
ir
-
>
clone
(
this
-
>
mem_ctx
NULL
)
)
;
}
return
visit_continue
;
}
class
lower_packed_varyings_return_splicer
:
public
ir_hierarchical_visitor
{
public
:
explicit
lower_packed_varyings_return_splicer
(
void
*
mem_ctx
const
exec_list
*
instructions
)
;
virtual
ir_visitor_status
visit_leave
(
ir_return
*
ret
)
;
private
:
void
*
const
mem_ctx
;
const
exec_list
*
instructions
;
}
;
lower_packed_varyings_return_splicer
:
:
lower_packed_varyings_return_splicer
(
void
*
mem_ctx
const
exec_list
*
instructions
)
:
mem_ctx
(
mem_ctx
)
instructions
(
instructions
)
{
}
ir_visitor_status
lower_packed_varyings_return_splicer
:
:
visit_leave
(
ir_return
*
ret
)
{
foreach_in_list
(
ir_instruction
ir
this
-
>
instructions
)
{
ret
-
>
insert_before
(
ir
-
>
clone
(
this
-
>
mem_ctx
NULL
)
)
;
}
return
visit_continue
;
}
void
lower_packed_varyings
(
void
*
mem_ctx
unsigned
locations_used
const
uint8_t
*
components
ir_variable_mode
mode
unsigned
gs_input_vertices
gl_linked_shader
*
shader
bool
disable_varying_packing
bool
xfb_enabled
)
{
exec_list
*
instructions
=
shader
-
>
ir
;
ir_function
*
main_func
=
shader
-
>
symbols
-
>
get_function
(
"
main
"
)
;
exec_list
void_parameters
;
ir_function_signature
*
main_func_sig
=
main_func
-
>
matching_signature
(
NULL
&
void_parameters
false
)
;
exec_list
new_instructions
new_variables
;
lower_packed_varyings_visitor
visitor
(
mem_ctx
locations_used
components
mode
gs_input_vertices
&
new_instructions
&
new_variables
disable_varying_packing
xfb_enabled
)
;
visitor
.
run
(
shader
)
;
if
(
mode
=
=
ir_var_shader_out
)
{
if
(
shader
-
>
Stage
=
=
MESA_SHADER_GEOMETRY
)
{
lower_packed_varyings_gs_splicer
splicer
(
mem_ctx
&
new_instructions
)
;
main_func_sig
-
>
body
.
get_head_raw
(
)
-
>
insert_before
(
&
new_variables
)
;
splicer
.
run
(
instructions
)
;
}
else
{
lower_packed_varyings_return_splicer
splicer
(
mem_ctx
&
new_instructions
)
;
main_func_sig
-
>
body
.
get_head_raw
(
)
-
>
insert_before
(
&
new_variables
)
;
splicer
.
run
(
instructions
)
;
if
(
(
(
ir_instruction
*
)
instructions
-
>
get_tail
(
)
)
-
>
ir_type
!
=
ir_type_return
)
{
main_func_sig
-
>
body
.
append_list
(
&
new_instructions
)
;
}
}
}
else
{
main_func_sig
-
>
body
.
get_head_raw
(
)
-
>
insert_before
(
&
new_instructions
)
;
main_func_sig
-
>
body
.
get_head_raw
(
)
-
>
insert_before
(
&
new_variables
)
;
}
}
