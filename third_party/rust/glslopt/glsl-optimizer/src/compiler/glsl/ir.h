#
ifndef
IR_H
#
define
IR_H
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
util
/
ralloc
.
h
"
#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
list
.
h
"
#
include
"
ir_visitor
.
h
"
#
include
"
ir_hierarchical_visitor
.
h
"
#
ifdef
__cplusplus
enum
ir_node_type
{
ir_type_dereference_array
ir_type_dereference_record
ir_type_dereference_variable
ir_type_constant
ir_type_expression
ir_type_swizzle
ir_type_texture
ir_type_variable
ir_type_assignment
ir_type_call
ir_type_function
ir_type_function_signature
ir_type_if
ir_type_loop
ir_type_loop_jump
ir_type_return
ir_type_precision
ir_type_typedecl
ir_type_discard
ir_type_demote
ir_type_emit_vertex
ir_type_end_primitive
ir_type_barrier
ir_type_max
ir_type_unset
=
ir_type_max
}
;
class
ir_instruction
:
public
exec_node
{
public
:
enum
ir_node_type
ir_type
;
virtual
~
ir_instruction
(
)
{
}
void
print
(
void
)
const
;
void
fprint
(
FILE
*
f
)
const
;
virtual
void
accept
(
ir_visitor
*
)
=
0
;
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
=
0
;
virtual
ir_instruction
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
=
0
;
bool
is_rvalue
(
)
const
{
return
ir_type
=
=
ir_type_dereference_array
|
|
ir_type
=
=
ir_type_dereference_record
|
|
ir_type
=
=
ir_type_dereference_variable
|
|
ir_type
=
=
ir_type_constant
|
|
ir_type
=
=
ir_type_expression
|
|
ir_type
=
=
ir_type_swizzle
|
|
ir_type
=
=
ir_type_texture
;
}
bool
is_dereference
(
)
const
{
return
ir_type
=
=
ir_type_dereference_array
|
|
ir_type
=
=
ir_type_dereference_record
|
|
ir_type
=
=
ir_type_dereference_variable
;
}
bool
is_jump
(
)
const
{
return
ir_type
=
=
ir_type_loop_jump
|
|
ir_type
=
=
ir_type_return
|
|
ir_type
=
=
ir_type_discard
;
}
#
define
AS_BASE
(
TYPE
)
\
class
ir_
#
#
TYPE
*
as_
#
#
TYPE
(
)
\
{
\
assume
(
this
!
=
NULL
)
;
\
return
is_
#
#
TYPE
(
)
?
(
ir_
#
#
TYPE
*
)
this
:
NULL
;
\
}
\
const
class
ir_
#
#
TYPE
*
as_
#
#
TYPE
(
)
const
\
{
\
assume
(
this
!
=
NULL
)
;
\
return
is_
#
#
TYPE
(
)
?
(
ir_
#
#
TYPE
*
)
this
:
NULL
;
\
}
AS_BASE
(
rvalue
)
AS_BASE
(
dereference
)
AS_BASE
(
jump
)
#
undef
AS_BASE
#
define
AS_CHILD
(
TYPE
)
\
class
ir_
#
#
TYPE
*
as_
#
#
TYPE
(
)
\
{
\
assume
(
this
!
=
NULL
)
;
\
return
ir_type
=
=
ir_type_
#
#
TYPE
?
(
ir_
#
#
TYPE
*
)
this
:
NULL
;
\
}
\
const
class
ir_
#
#
TYPE
*
as_
#
#
TYPE
(
)
const
\
{
\
assume
(
this
!
=
NULL
)
;
\
return
ir_type
=
=
ir_type_
#
#
TYPE
?
(
const
ir_
#
#
TYPE
*
)
this
:
NULL
;
\
}
AS_CHILD
(
variable
)
AS_CHILD
(
function
)
AS_CHILD
(
dereference_array
)
AS_CHILD
(
dereference_variable
)
AS_CHILD
(
dereference_record
)
AS_CHILD
(
expression
)
AS_CHILD
(
loop
)
AS_CHILD
(
assignment
)
AS_CHILD
(
call
)
AS_CHILD
(
return
)
AS_CHILD
(
if
)
AS_CHILD
(
swizzle
)
AS_CHILD
(
texture
)
AS_CHILD
(
constant
)
AS_CHILD
(
discard
)
#
undef
AS_CHILD
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
protected
:
ir_instruction
(
enum
ir_node_type
t
)
:
ir_type
(
t
)
{
}
private
:
ir_instruction
(
)
{
assert
(
!
"
Should
not
get
here
.
"
)
;
}
}
;
class
ir_rvalue
:
public
ir_instruction
{
public
:
const
struct
glsl_type
*
type
;
virtual
ir_rvalue
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
ir_rvalue
*
as_rvalue_to_saturate
(
)
;
virtual
bool
is_lvalue
(
const
struct
_mesa_glsl_parse_state
*
=
NULL
)
const
{
return
false
;
}
virtual
ir_variable
*
variable_referenced
(
)
const
{
return
NULL
;
}
virtual
ir_variable
*
whole_variable_referenced
(
)
{
return
NULL
;
}
virtual
bool
is_zero
(
)
const
;
virtual
bool
is_one
(
)
const
;
virtual
bool
is_negative_one
(
)
const
;
virtual
bool
is_uint16_constant
(
)
const
{
return
false
;
}
static
ir_rvalue
*
error_value
(
void
*
mem_ctx
)
;
protected
:
ir_rvalue
(
enum
ir_node_type
t
)
;
}
;
enum
ir_variable_mode
{
ir_var_auto
=
0
ir_var_uniform
ir_var_shader_storage
ir_var_shader_shared
ir_var_shader_in
ir_var_shader_out
ir_var_function_in
ir_var_function_out
ir_var_function_inout
ir_var_const_in
ir_var_system_value
ir_var_temporary
ir_var_mode_count
}
;
enum
ir_var_declaration_type
{
ir_var_declared_normally
=
0
ir_var_declared_in_block
ir_var_declared_implicitly
ir_var_hidden
}
;
enum
ir_depth_layout
{
ir_depth_layout_none
ir_depth_layout_any
ir_depth_layout_greater
ir_depth_layout_less
ir_depth_layout_unchanged
}
;
const
char
*
depth_layout_string
(
ir_depth_layout
layout
)
;
struct
ir_state_slot
{
gl_state_index16
tokens
[
STATE_LENGTH
]
;
int
swizzle
;
}
;
const
char
*
interpolation_string
(
unsigned
interpolation
)
;
class
ir_variable
:
public
ir_instruction
{
public
:
ir_variable
(
const
struct
glsl_type
*
const
char
*
ir_variable_mode
)
;
virtual
ir_variable
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
inline
bool
is_in_buffer_block
(
)
const
{
return
(
this
-
>
data
.
mode
=
=
ir_var_uniform
|
|
this
-
>
data
.
mode
=
=
ir_var_shader_storage
)
&
&
this
-
>
interface_type
!
=
NULL
;
}
inline
bool
is_in_shader_storage_block
(
)
const
{
return
this
-
>
data
.
mode
=
=
ir_var_shader_storage
&
&
this
-
>
interface_type
!
=
NULL
;
}
inline
bool
is_interface_instance
(
)
const
{
return
this
-
>
type
-
>
without_array
(
)
=
=
this
-
>
interface_type
;
}
inline
bool
contains_bindless
(
)
const
{
if
(
!
this
-
>
type
-
>
contains_sampler
(
)
&
&
!
this
-
>
type
-
>
contains_image
(
)
)
return
false
;
return
this
-
>
data
.
bindless
|
|
this
-
>
data
.
mode
!
=
ir_var_uniform
;
}
void
init_interface_type
(
const
struct
glsl_type
*
type
)
{
assert
(
this
-
>
interface_type
=
=
NULL
)
;
this
-
>
interface_type
=
type
;
if
(
this
-
>
is_interface_instance
(
)
)
{
this
-
>
u
.
max_ifc_array_access
=
ralloc_array
(
this
int
type
-
>
length
)
;
for
(
unsigned
i
=
0
;
i
<
type
-
>
length
;
i
+
+
)
{
this
-
>
u
.
max_ifc_array_access
[
i
]
=
-
1
;
}
}
}
void
change_interface_type
(
const
struct
glsl_type
*
type
)
{
if
(
this
-
>
u
.
max_ifc_array_access
!
=
NULL
)
{
assert
(
this
-
>
interface_type
-
>
length
=
=
type
-
>
length
)
;
}
this
-
>
interface_type
=
type
;
}
void
reinit_interface_type
(
const
struct
glsl_type
*
type
)
{
if
(
this
-
>
u
.
max_ifc_array_access
!
=
NULL
)
{
#
ifndef
NDEBUG
for
(
unsigned
i
=
0
;
i
<
this
-
>
interface_type
-
>
length
;
i
+
+
)
assert
(
this
-
>
u
.
max_ifc_array_access
[
i
]
=
=
-
1
)
;
#
endif
ralloc_free
(
this
-
>
u
.
max_ifc_array_access
)
;
this
-
>
u
.
max_ifc_array_access
=
NULL
;
}
this
-
>
interface_type
=
NULL
;
init_interface_type
(
type
)
;
}
const
glsl_type
*
get_interface_type
(
)
const
{
return
this
-
>
interface_type
;
}
enum
glsl_interface_packing
get_interface_type_packing
(
)
const
{
return
this
-
>
interface_type
-
>
get_interface_packing
(
)
;
}
inline
int
*
get_max_ifc_array_access
(
)
{
assert
(
this
-
>
data
.
_num_state_slots
=
=
0
)
;
return
this
-
>
u
.
max_ifc_array_access
;
}
inline
unsigned
get_num_state_slots
(
)
const
{
assert
(
!
this
-
>
is_interface_instance
(
)
|
|
this
-
>
data
.
_num_state_slots
=
=
0
)
;
return
this
-
>
data
.
_num_state_slots
;
}
inline
void
set_num_state_slots
(
unsigned
n
)
{
assert
(
!
this
-
>
is_interface_instance
(
)
|
|
n
=
=
0
)
;
this
-
>
data
.
_num_state_slots
=
n
;
}
inline
ir_state_slot
*
get_state_slots
(
)
{
return
this
-
>
is_interface_instance
(
)
?
NULL
:
this
-
>
u
.
state_slots
;
}
inline
const
ir_state_slot
*
get_state_slots
(
)
const
{
return
this
-
>
is_interface_instance
(
)
?
NULL
:
this
-
>
u
.
state_slots
;
}
inline
ir_state_slot
*
allocate_state_slots
(
unsigned
n
)
{
assert
(
!
this
-
>
is_interface_instance
(
)
)
;
this
-
>
u
.
state_slots
=
ralloc_array
(
this
ir_state_slot
n
)
;
this
-
>
data
.
_num_state_slots
=
0
;
if
(
this
-
>
u
.
state_slots
!
=
NULL
)
this
-
>
data
.
_num_state_slots
=
n
;
return
this
-
>
u
.
state_slots
;
}
inline
bool
is_interpolation_flat
(
)
const
{
return
this
-
>
data
.
interpolation
=
=
INTERP_MODE_FLAT
|
|
this
-
>
type
-
>
contains_integer
(
)
|
|
this
-
>
type
-
>
contains_double
(
)
;
}
inline
bool
is_name_ralloced
(
)
const
{
return
this
-
>
name
!
=
ir_variable
:
:
tmp_name
&
&
this
-
>
name
!
=
this
-
>
name_storage
;
}
void
enable_extension_warning
(
const
char
*
extension
)
;
const
char
*
get_extension_warning
(
)
const
;
const
struct
glsl_type
*
type
;
const
char
*
name
;
private
:
char
name_storage
[
16
]
;
public
:
struct
ir_variable_data
{
unsigned
read_only
:
1
;
unsigned
centroid
:
1
;
unsigned
sample
:
1
;
unsigned
patch
:
1
;
unsigned
explicit_invariant
:
1
;
unsigned
invariant
:
1
;
unsigned
precise
:
1
;
unsigned
used
:
1
;
unsigned
assigned
:
1
;
unsigned
always_active_io
:
1
;
unsigned
how_declared
:
2
;
unsigned
mode
:
4
;
unsigned
interpolation
:
2
;
unsigned
explicit_location
:
1
;
unsigned
explicit_index
:
1
;
unsigned
explicit_binding
:
1
;
unsigned
explicit_component
:
1
;
unsigned
has_initializer
:
1
;
unsigned
is_unmatched_generic_inout
:
1
;
unsigned
is_xfb_only
:
1
;
unsigned
explicit_xfb_buffer
:
1
;
unsigned
explicit_xfb_offset
:
1
;
unsigned
explicit_xfb_stride
:
1
;
unsigned
location_frac
:
2
;
unsigned
matrix_layout
:
2
;
unsigned
from_named_ifc_block
:
1
;
unsigned
must_be_shader_input
:
1
;
unsigned
index
:
1
;
unsigned
precision
:
2
;
ir_depth_layout
depth_layout
:
3
;
unsigned
memory_read_only
:
1
;
unsigned
memory_write_only
:
1
;
unsigned
memory_coherent
:
1
;
unsigned
memory_volatile
:
1
;
unsigned
memory_restrict
:
1
;
unsigned
from_ssbo_unsized_array
:
1
;
unsigned
implicit_sized_array
:
1
;
unsigned
fb_fetch_output
:
1
;
unsigned
bindless
:
1
;
unsigned
bound
:
1
;
private
:
uint8_t
warn_extension_index
;
public
:
uint16_t
image_format
;
private
:
uint16_t
_num_state_slots
;
public
:
uint16_t
binding
;
int
location
;
int
param_index
;
unsigned
stream
;
unsigned
offset
;
int
max_array_access
;
unsigned
xfb_buffer
;
unsigned
xfb_stride
;
friend
class
ir_variable
;
}
data
;
ir_constant
*
constant_value
;
ir_constant
*
constant_initializer
;
private
:
static
const
char
*
const
warn_extension_table
[
]
;
union
{
int
*
max_ifc_array_access
;
ir_state_slot
*
state_slots
;
}
u
;
const
glsl_type
*
interface_type
;
static
const
char
tmp_name
[
]
;
public
:
static
bool
temporaries_allocate_names
;
}
;
typedef
bool
(
*
builtin_available_predicate
)
(
const
_mesa_glsl_parse_state
*
)
;
#
define
MAKE_INTRINSIC_FOR_TYPE
(
op
t
)
\
ir_intrinsic_generic_
#
#
op
-
ir_intrinsic_generic_load
+
ir_intrinsic_
#
#
t
#
#
_
#
#
load
#
define
MAP_INTRINSIC_TO_TYPE
(
i
t
)
\
ir_intrinsic_id
(
int
(
i
)
-
int
(
ir_intrinsic_generic_load
)
+
int
(
ir_intrinsic_
#
#
t
#
#
_
#
#
load
)
)
enum
ir_intrinsic_id
{
ir_intrinsic_invalid
=
0
ir_intrinsic_generic_load
ir_intrinsic_generic_store
ir_intrinsic_generic_atomic_add
ir_intrinsic_generic_atomic_and
ir_intrinsic_generic_atomic_or
ir_intrinsic_generic_atomic_xor
ir_intrinsic_generic_atomic_min
ir_intrinsic_generic_atomic_max
ir_intrinsic_generic_atomic_exchange
ir_intrinsic_generic_atomic_comp_swap
ir_intrinsic_atomic_counter_read
ir_intrinsic_atomic_counter_increment
ir_intrinsic_atomic_counter_predecrement
ir_intrinsic_atomic_counter_add
ir_intrinsic_atomic_counter_and
ir_intrinsic_atomic_counter_or
ir_intrinsic_atomic_counter_xor
ir_intrinsic_atomic_counter_min
ir_intrinsic_atomic_counter_max
ir_intrinsic_atomic_counter_exchange
ir_intrinsic_atomic_counter_comp_swap
ir_intrinsic_image_load
ir_intrinsic_image_store
ir_intrinsic_image_atomic_add
ir_intrinsic_image_atomic_and
ir_intrinsic_image_atomic_or
ir_intrinsic_image_atomic_xor
ir_intrinsic_image_atomic_min
ir_intrinsic_image_atomic_max
ir_intrinsic_image_atomic_exchange
ir_intrinsic_image_atomic_comp_swap
ir_intrinsic_image_size
ir_intrinsic_image_samples
ir_intrinsic_image_atomic_inc_wrap
ir_intrinsic_image_atomic_dec_wrap
ir_intrinsic_ssbo_load
ir_intrinsic_ssbo_store
=
MAKE_INTRINSIC_FOR_TYPE
(
store
ssbo
)
ir_intrinsic_ssbo_atomic_add
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_add
ssbo
)
ir_intrinsic_ssbo_atomic_and
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_and
ssbo
)
ir_intrinsic_ssbo_atomic_or
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_or
ssbo
)
ir_intrinsic_ssbo_atomic_xor
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_xor
ssbo
)
ir_intrinsic_ssbo_atomic_min
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_min
ssbo
)
ir_intrinsic_ssbo_atomic_max
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_max
ssbo
)
ir_intrinsic_ssbo_atomic_exchange
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_exchange
ssbo
)
ir_intrinsic_ssbo_atomic_comp_swap
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_comp_swap
ssbo
)
ir_intrinsic_memory_barrier
ir_intrinsic_shader_clock
ir_intrinsic_group_memory_barrier
ir_intrinsic_memory_barrier_atomic_counter
ir_intrinsic_memory_barrier_buffer
ir_intrinsic_memory_barrier_image
ir_intrinsic_memory_barrier_shared
ir_intrinsic_begin_invocation_interlock
ir_intrinsic_end_invocation_interlock
ir_intrinsic_vote_all
ir_intrinsic_vote_any
ir_intrinsic_vote_eq
ir_intrinsic_ballot
ir_intrinsic_read_invocation
ir_intrinsic_read_first_invocation
ir_intrinsic_helper_invocation
ir_intrinsic_shared_load
ir_intrinsic_shared_store
=
MAKE_INTRINSIC_FOR_TYPE
(
store
shared
)
ir_intrinsic_shared_atomic_add
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_add
shared
)
ir_intrinsic_shared_atomic_and
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_and
shared
)
ir_intrinsic_shared_atomic_or
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_or
shared
)
ir_intrinsic_shared_atomic_xor
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_xor
shared
)
ir_intrinsic_shared_atomic_min
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_min
shared
)
ir_intrinsic_shared_atomic_max
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_max
shared
)
ir_intrinsic_shared_atomic_exchange
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_exchange
shared
)
ir_intrinsic_shared_atomic_comp_swap
=
MAKE_INTRINSIC_FOR_TYPE
(
atomic_comp_swap
shared
)
}
;
class
ir_function_signature
:
public
ir_instruction
{
public
:
ir_function_signature
(
const
glsl_type
*
return_type
builtin_available_predicate
builtin_avail
=
NULL
)
;
virtual
ir_function_signature
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
ir_function_signature
*
clone_prototype
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
exec_list
*
actual_parameters
struct
hash_table
*
variable_context
)
;
const
char
*
function_name
(
)
const
;
inline
const
class
ir_function
*
function
(
)
const
{
return
this
-
>
_function
;
}
const
char
*
qualifiers_match
(
exec_list
*
params
)
;
void
replace_parameters
(
exec_list
*
new_params
)
;
const
struct
glsl_type
*
return_type
;
struct
exec_list
parameters
;
unsigned
is_defined
:
1
;
unsigned
return_precision
:
2
;
bool
is_builtin
(
)
const
;
inline
bool
is_intrinsic
(
)
const
{
return
intrinsic_id
!
=
ir_intrinsic_invalid
;
}
enum
ir_intrinsic_id
intrinsic_id
;
bool
is_builtin_available
(
const
_mesa_glsl_parse_state
*
state
)
const
;
struct
exec_list
body
;
private
:
builtin_available_predicate
builtin_avail
;
class
ir_function
*
_function
;
const
ir_function_signature
*
origin
;
friend
class
ir_function
;
bool
constant_expression_evaluate_expression_list
(
void
*
mem_ctx
const
struct
exec_list
&
body
struct
hash_table
*
variable_context
ir_constant
*
*
result
)
;
}
;
class
ir_function
:
public
ir_instruction
{
public
:
ir_function
(
const
char
*
name
)
;
virtual
ir_function
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
void
add_signature
(
ir_function_signature
*
sig
)
{
sig
-
>
_function
=
this
;
this
-
>
signatures
.
push_tail
(
sig
)
;
}
ir_function_signature
*
matching_signature
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_param
bool
allow_builtins
bool
*
match_is_exact
)
;
ir_function_signature
*
matching_signature
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_param
bool
allow_builtins
)
;
ir_function_signature
*
exact_matching_signature
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_ps
)
;
const
char
*
name
;
bool
has_user_signature
(
)
;
struct
exec_list
signatures
;
bool
is_subroutine
;
int
num_subroutine_types
;
const
struct
glsl_type
*
*
subroutine_types
;
int
subroutine_index
;
}
;
inline
const
char
*
ir_function_signature
:
:
function_name
(
)
const
{
return
this
-
>
_function
-
>
name
;
}
class
ir_if
:
public
ir_instruction
{
public
:
ir_if
(
ir_rvalue
*
condition
)
:
ir_instruction
(
ir_type_if
)
condition
(
condition
)
{
}
virtual
ir_if
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_rvalue
*
condition
;
exec_list
then_instructions
;
exec_list
else_instructions
;
}
;
class
ir_loop
:
public
ir_instruction
{
public
:
ir_loop
(
)
;
virtual
ir_loop
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
exec_list
body_instructions
;
}
;
class
ir_assignment
:
public
ir_instruction
{
public
:
ir_assignment
(
ir_rvalue
*
lhs
ir_rvalue
*
rhs
ir_rvalue
*
condition
=
NULL
)
;
ir_assignment
(
ir_dereference
*
lhs
ir_rvalue
*
rhs
ir_rvalue
*
condition
unsigned
write_mask
)
;
virtual
ir_assignment
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_variable
*
whole_variable_written
(
)
;
void
set_lhs
(
ir_rvalue
*
lhs
)
;
ir_dereference
*
lhs
;
ir_rvalue
*
rhs
;
ir_rvalue
*
condition
;
unsigned
write_mask
:
4
;
}
;
#
include
"
ir_expression_operation
.
h
"
extern
const
char
*
const
ir_expression_operation_strings
[
ir_last_opcode
+
1
]
;
extern
const
char
*
const
ir_expression_operation_enum_strings
[
ir_last_opcode
+
1
]
;
class
ir_expression
:
public
ir_rvalue
{
public
:
ir_expression
(
int
op
const
struct
glsl_type
*
type
ir_rvalue
*
op0
ir_rvalue
*
op1
=
NULL
ir_rvalue
*
op2
=
NULL
ir_rvalue
*
op3
=
NULL
)
;
ir_expression
(
int
op
ir_rvalue
*
)
;
ir_expression
(
int
op
ir_rvalue
*
op0
ir_rvalue
*
op1
)
;
ir_expression
(
int
op
ir_rvalue
*
op0
ir_rvalue
*
op1
ir_rvalue
*
op2
)
;
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
virtual
ir_expression
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
static
unsigned
get_num_operands
(
ir_expression_operation
)
;
bool
is_horizontal
(
)
const
{
return
operation
=
=
ir_binop_all_equal
|
|
operation
=
=
ir_binop_any_nequal
|
|
operation
=
=
ir_binop_dot
|
|
operation
=
=
ir_binop_vector_extract
|
|
operation
=
=
ir_triop_vector_insert
|
|
operation
=
=
ir_binop_ubo_load
|
|
operation
=
=
ir_quadop_vector
;
}
static
ir_expression_operation
get_operator
(
const
char
*
)
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
virtual
ir_variable
*
variable_referenced
(
)
const
;
void
init_num_operands
(
)
{
if
(
operation
=
=
ir_quadop_vector
)
{
num_operands
=
this
-
>
type
-
>
vector_elements
;
}
else
{
num_operands
=
get_num_operands
(
operation
)
;
}
}
ir_expression_operation
operation
;
ir_rvalue
*
operands
[
4
]
;
uint8_t
num_operands
;
}
;
class
ir_call
:
public
ir_instruction
{
public
:
ir_call
(
ir_function_signature
*
callee
ir_dereference_variable
*
return_deref
exec_list
*
actual_parameters
)
:
ir_instruction
(
ir_type_call
)
return_deref
(
return_deref
)
callee
(
callee
)
sub_var
(
NULL
)
array_idx
(
NULL
)
{
assert
(
callee
-
>
return_type
!
=
NULL
)
;
actual_parameters
-
>
move_nodes_to
(
&
this
-
>
actual_parameters
)
;
}
ir_call
(
ir_function_signature
*
callee
ir_dereference_variable
*
return_deref
exec_list
*
actual_parameters
ir_variable
*
var
ir_rvalue
*
array_idx
)
:
ir_instruction
(
ir_type_call
)
return_deref
(
return_deref
)
callee
(
callee
)
sub_var
(
var
)
array_idx
(
array_idx
)
{
assert
(
callee
-
>
return_type
!
=
NULL
)
;
actual_parameters
-
>
move_nodes_to
(
&
this
-
>
actual_parameters
)
;
}
virtual
ir_call
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
const
char
*
callee_name
(
)
const
{
return
callee
-
>
function_name
(
)
;
}
void
generate_inline
(
ir_instruction
*
ir
)
;
ir_dereference_variable
*
return_deref
;
ir_function_signature
*
callee
;
exec_list
actual_parameters
;
ir_variable
*
sub_var
;
ir_rvalue
*
array_idx
;
}
;
class
ir_jump
:
public
ir_instruction
{
protected
:
ir_jump
(
enum
ir_node_type
t
)
:
ir_instruction
(
t
)
{
}
}
;
class
ir_return
:
public
ir_jump
{
public
:
ir_return
(
)
:
ir_jump
(
ir_type_return
)
value
(
NULL
)
{
}
ir_return
(
ir_rvalue
*
value
)
:
ir_jump
(
ir_type_return
)
value
(
value
)
{
}
virtual
ir_return
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
ir_rvalue
*
get_value
(
)
const
{
return
value
;
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_rvalue
*
value
;
}
;
class
ir_loop_jump
:
public
ir_jump
{
public
:
enum
jump_mode
{
jump_break
jump_continue
}
;
ir_loop_jump
(
jump_mode
mode
)
:
ir_jump
(
ir_type_loop_jump
)
{
this
-
>
mode
=
mode
;
}
virtual
ir_loop_jump
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
bool
is_break
(
)
const
{
return
mode
=
=
jump_break
;
}
bool
is_continue
(
)
const
{
return
mode
=
=
jump_continue
;
}
enum
jump_mode
mode
;
}
;
class
ir_discard
:
public
ir_jump
{
public
:
ir_discard
(
)
:
ir_jump
(
ir_type_discard
)
{
this
-
>
condition
=
NULL
;
}
ir_discard
(
ir_rvalue
*
cond
)
:
ir_jump
(
ir_type_discard
)
{
this
-
>
condition
=
cond
;
}
virtual
ir_discard
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_rvalue
*
condition
;
}
;
class
ir_demote
:
public
ir_instruction
{
public
:
ir_demote
(
)
:
ir_instruction
(
ir_type_demote
)
{
}
virtual
ir_demote
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
}
;
enum
ir_texture_opcode
{
ir_tex
ir_txb
ir_txl
ir_txd
ir_txf
ir_txf_ms
ir_txs
ir_lod
ir_tg4
ir_query_levels
ir_texture_samples
ir_samples_identical
}
;
class
ir_texture
:
public
ir_rvalue
{
public
:
ir_texture
(
enum
ir_texture_opcode
op
)
:
ir_rvalue
(
ir_type_texture
)
op
(
op
)
sampler
(
NULL
)
coordinate
(
NULL
)
projector
(
NULL
)
shadow_comparator
(
NULL
)
offset
(
NULL
)
{
memset
(
&
lod_info
0
sizeof
(
lod_info
)
)
;
}
virtual
ir_texture
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
const
char
*
opcode_string
(
)
;
void
set_sampler
(
ir_dereference
*
sampler
const
glsl_type
*
type
)
;
static
bool
has_lod
(
const
glsl_type
*
sampler_type
)
;
static
ir_texture_opcode
get_opcode
(
const
char
*
)
;
enum
ir_texture_opcode
op
;
ir_dereference
*
sampler
;
ir_rvalue
*
coordinate
;
ir_rvalue
*
projector
;
ir_rvalue
*
shadow_comparator
;
ir_rvalue
*
offset
;
union
{
ir_rvalue
*
lod
;
ir_rvalue
*
bias
;
ir_rvalue
*
sample_index
;
ir_rvalue
*
component
;
struct
{
ir_rvalue
*
dPdx
;
ir_rvalue
*
dPdy
;
}
grad
;
}
lod_info
;
}
;
struct
ir_swizzle_mask
{
unsigned
x
:
2
;
unsigned
y
:
2
;
unsigned
z
:
2
;
unsigned
w
:
2
;
unsigned
num_components
:
3
;
unsigned
has_duplicates
:
1
;
}
;
class
ir_swizzle
:
public
ir_rvalue
{
public
:
ir_swizzle
(
ir_rvalue
*
unsigned
x
unsigned
y
unsigned
z
unsigned
w
unsigned
count
)
;
ir_swizzle
(
ir_rvalue
*
val
const
unsigned
*
components
unsigned
count
)
;
ir_swizzle
(
ir_rvalue
*
val
ir_swizzle_mask
mask
)
;
virtual
ir_swizzle
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
static
ir_swizzle
*
create
(
ir_rvalue
*
const
char
*
unsigned
vector_length
)
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
bool
is_lvalue
(
const
struct
_mesa_glsl_parse_state
*
state
)
const
{
return
val
-
>
is_lvalue
(
state
)
&
&
!
mask
.
has_duplicates
;
}
virtual
ir_variable
*
variable_referenced
(
)
const
;
ir_rvalue
*
val
;
ir_swizzle_mask
mask
;
private
:
void
init_mask
(
const
unsigned
*
components
unsigned
count
)
;
}
;
class
ir_dereference
:
public
ir_rvalue
{
public
:
virtual
ir_dereference
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
=
0
;
bool
is_lvalue
(
const
struct
_mesa_glsl_parse_state
*
state
)
const
;
virtual
ir_variable
*
variable_referenced
(
)
const
=
0
;
protected
:
ir_dereference
(
enum
ir_node_type
t
)
:
ir_rvalue
(
t
)
{
}
}
;
class
ir_dereference_variable
:
public
ir_dereference
{
public
:
ir_dereference_variable
(
ir_variable
*
var
)
;
virtual
ir_dereference_variable
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
virtual
ir_variable
*
variable_referenced
(
)
const
{
return
this
-
>
var
;
}
virtual
ir_variable
*
whole_variable_referenced
(
)
{
return
this
-
>
var
;
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_variable
*
var
;
}
;
class
ir_dereference_array
:
public
ir_dereference
{
public
:
ir_dereference_array
(
ir_rvalue
*
value
ir_rvalue
*
array_index
)
;
ir_dereference_array
(
ir_variable
*
var
ir_rvalue
*
array_index
)
;
virtual
ir_dereference_array
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
virtual
ir_variable
*
variable_referenced
(
)
const
{
return
this
-
>
array
-
>
variable_referenced
(
)
;
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_rvalue
*
array
;
ir_rvalue
*
array_index
;
private
:
void
set_array
(
ir_rvalue
*
value
)
;
}
;
class
ir_dereference_record
:
public
ir_dereference
{
public
:
ir_dereference_record
(
ir_rvalue
*
value
const
char
*
field
)
;
ir_dereference_record
(
ir_variable
*
var
const
char
*
field
)
;
virtual
ir_dereference_record
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
ir_variable
*
variable_referenced
(
)
const
{
return
this
-
>
record
-
>
variable_referenced
(
)
;
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
ir_rvalue
*
record
;
int
field_idx
;
}
;
union
ir_constant_data
{
unsigned
u
[
16
]
;
int
i
[
16
]
;
float
f
[
16
]
;
bool
b
[
16
]
;
double
d
[
16
]
;
uint64_t
u64
[
16
]
;
int64_t
i64
[
16
]
;
}
;
class
ir_constant
:
public
ir_rvalue
{
public
:
ir_constant
(
const
struct
glsl_type
*
type
const
ir_constant_data
*
data
)
;
ir_constant
(
bool
b
unsigned
vector_elements
=
1
)
;
ir_constant
(
unsigned
int
u
unsigned
vector_elements
=
1
)
;
ir_constant
(
int
i
unsigned
vector_elements
=
1
)
;
ir_constant
(
float
f
unsigned
vector_elements
=
1
)
;
ir_constant
(
double
d
unsigned
vector_elements
=
1
)
;
ir_constant
(
uint64_t
u64
unsigned
vector_elements
=
1
)
;
ir_constant
(
int64_t
i64
unsigned
vector_elements
=
1
)
;
ir_constant
(
const
struct
glsl_type
*
type
exec_list
*
values
)
;
ir_constant
(
const
ir_constant
*
c
unsigned
i
)
;
static
ir_constant
*
zero
(
void
*
mem_ctx
const
glsl_type
*
type
)
;
virtual
ir_constant
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
ir_constant
*
constant_expression_value
(
void
*
mem_ctx
struct
hash_table
*
variable_context
=
NULL
)
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
virtual
bool
equals
(
const
ir_instruction
*
ir
enum
ir_node_type
ignore
=
ir_type_unset
)
const
;
bool
get_bool_component
(
unsigned
i
)
const
;
float
get_float_component
(
unsigned
i
)
const
;
double
get_double_component
(
unsigned
i
)
const
;
int
get_int_component
(
unsigned
i
)
const
;
unsigned
get_uint_component
(
unsigned
i
)
const
;
int64_t
get_int64_component
(
unsigned
i
)
const
;
uint64_t
get_uint64_component
(
unsigned
i
)
const
;
ir_constant
*
get_array_element
(
unsigned
i
)
const
;
ir_constant
*
get_record_field
(
int
idx
)
;
void
copy_offset
(
ir_constant
*
src
int
offset
)
;
void
copy_masked_offset
(
ir_constant
*
src
int
offset
unsigned
int
mask
)
;
bool
has_value
(
const
ir_constant
*
)
const
;
virtual
bool
is_value
(
float
f
int
i
)
const
;
virtual
bool
is_zero
(
)
const
;
virtual
bool
is_one
(
)
const
;
virtual
bool
is_negative_one
(
)
const
;
virtual
bool
is_uint16_constant
(
)
const
;
union
ir_constant_data
value
;
ir_constant
*
*
const_elements
;
private
:
ir_constant
(
void
)
;
}
;
class
ir_precision_statement
:
public
ir_instruction
{
public
:
ir_precision_statement
(
const
char
*
statement_to_store
)
:
ir_instruction
(
ir_type_precision
)
{
ir_type
=
ir_type_precision
;
precision_statement
=
statement_to_store
;
}
virtual
ir_precision_statement
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
const
char
*
precision_statement
;
}
;
class
ir_typedecl_statement
:
public
ir_instruction
{
public
:
ir_typedecl_statement
(
const
glsl_type
*
type_decl
)
:
ir_instruction
(
ir_type_typedecl
)
{
this
-
>
ir_type
=
ir_type_typedecl
;
this
-
>
type_decl
=
type_decl
;
}
virtual
ir_typedecl_statement
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
;
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
const
glsl_type
*
type_decl
;
}
;
class
ir_emit_vertex
:
public
ir_instruction
{
public
:
ir_emit_vertex
(
ir_rvalue
*
stream
)
:
ir_instruction
(
ir_type_emit_vertex
)
stream
(
stream
)
{
assert
(
stream
)
;
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_emit_vertex
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
{
return
new
(
mem_ctx
)
ir_emit_vertex
(
this
-
>
stream
-
>
clone
(
mem_ctx
ht
)
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
int
stream_id
(
)
const
{
return
stream
-
>
as_constant
(
)
-
>
value
.
i
[
0
]
;
}
ir_rvalue
*
stream
;
}
;
class
ir_end_primitive
:
public
ir_instruction
{
public
:
ir_end_primitive
(
ir_rvalue
*
stream
)
:
ir_instruction
(
ir_type_end_primitive
)
stream
(
stream
)
{
assert
(
stream
)
;
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_end_primitive
*
clone
(
void
*
mem_ctx
struct
hash_table
*
ht
)
const
{
return
new
(
mem_ctx
)
ir_end_primitive
(
this
-
>
stream
-
>
clone
(
mem_ctx
ht
)
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
int
stream_id
(
)
const
{
return
stream
-
>
as_constant
(
)
-
>
value
.
i
[
0
]
;
}
ir_rvalue
*
stream
;
}
;
class
ir_barrier
:
public
ir_instruction
{
public
:
ir_barrier
(
)
:
ir_instruction
(
ir_type_barrier
)
{
}
virtual
void
accept
(
ir_visitor
*
v
)
{
v
-
>
visit
(
this
)
;
}
virtual
ir_barrier
*
clone
(
void
*
mem_ctx
struct
hash_table
*
)
const
{
return
new
(
mem_ctx
)
ir_barrier
(
)
;
}
virtual
ir_visitor_status
accept
(
ir_hierarchical_visitor
*
)
;
}
;
void
visit_exec_list
(
exec_list
*
list
ir_visitor
*
visitor
)
;
void
validate_ir_tree
(
exec_list
*
instructions
)
;
struct
_mesa_glsl_parse_state
;
struct
gl_shader_program
;
void
detect_recursion_unlinked
(
struct
_mesa_glsl_parse_state
*
state
exec_list
*
instructions
)
;
void
detect_recursion_linked
(
struct
gl_shader_program
*
prog
exec_list
*
instructions
)
;
void
clone_ir_list
(
void
*
mem_ctx
exec_list
*
out
const
exec_list
*
in
)
;
extern
void
_mesa_glsl_initialize_variables
(
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
extern
void
reparent_ir
(
exec_list
*
list
void
*
mem_ctx
)
;
extern
void
do_set_program_inouts
(
exec_list
*
instructions
struct
gl_program
*
prog
gl_shader_stage
shader_stage
)
;
extern
char
*
prototype_string
(
const
glsl_type
*
return_type
const
char
*
name
exec_list
*
parameters
)
;
const
char
*
mode_string
(
const
ir_variable
*
var
)
;
static
inline
bool
is_gl_identifier
(
const
char
*
s
)
{
return
s
&
&
s
[
0
]
=
=
'
g
'
&
&
s
[
1
]
=
=
'
l
'
&
&
s
[
2
]
=
=
'
_
'
;
}
extern
"
C
"
{
#
endif
extern
void
_mesa_print_ir
(
FILE
*
f
struct
exec_list
*
instructions
struct
_mesa_glsl_parse_state
*
state
)
;
extern
void
fprint_ir
(
FILE
*
f
const
void
*
instruction
)
;
extern
const
struct
gl_builtin_uniform_desc
*
_mesa_glsl_get_builtin_uniform_desc
(
const
char
*
name
)
;
#
ifdef
__cplusplus
}
#
endif
unsigned
vertices_per_prim
(
GLenum
prim
)
;
#
endif
