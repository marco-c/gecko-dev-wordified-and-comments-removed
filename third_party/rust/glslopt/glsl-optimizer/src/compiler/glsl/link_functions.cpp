#
include
"
glsl_symbol_table
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
ir
.
h
"
#
include
"
program
.
h
"
#
include
"
util
/
set
.
h
"
#
include
"
util
/
hash_table
.
h
"
#
include
"
linker
.
h
"
#
include
"
main
/
mtypes
.
h
"
static
ir_function_signature
*
find_matching_signature
(
const
char
*
name
const
exec_list
*
actual_parameters
glsl_symbol_table
*
symbols
)
;
namespace
{
class
call_link_visitor
:
public
ir_hierarchical_visitor
{
public
:
call_link_visitor
(
gl_shader_program
*
prog
gl_linked_shader
*
linked
gl_shader
*
*
shader_list
unsigned
num_shaders
)
{
this
-
>
prog
=
prog
;
this
-
>
shader_list
=
shader_list
;
this
-
>
num_shaders
=
num_shaders
;
this
-
>
success
=
true
;
this
-
>
linked
=
linked
;
this
-
>
locals
=
_mesa_pointer_set_create
(
NULL
)
;
}
~
call_link_visitor
(
)
{
_mesa_set_destroy
(
this
-
>
locals
NULL
)
;
}
virtual
ir_visitor_status
visit
(
ir_variable
*
ir
)
{
_mesa_set_add
(
locals
ir
)
;
return
visit_continue
;
}
virtual
ir_visitor_status
visit_enter
(
ir_call
*
ir
)
{
const
ir_function_signature
*
const
callee
=
ir
-
>
callee
;
assert
(
callee
!
=
NULL
)
;
const
char
*
const
name
=
callee
-
>
function_name
(
)
;
if
(
callee
-
>
is_intrinsic
(
)
)
return
visit_continue
;
ir_function_signature
*
sig
=
find_matching_signature
(
name
&
callee
-
>
parameters
linked
-
>
symbols
)
;
if
(
sig
!
=
NULL
)
{
ir
-
>
callee
=
sig
;
return
visit_continue
;
}
for
(
unsigned
i
=
0
;
i
<
num_shaders
;
i
+
+
)
{
sig
=
find_matching_signature
(
name
&
ir
-
>
actual_parameters
shader_list
[
i
]
-
>
symbols
)
;
if
(
sig
)
break
;
}
if
(
sig
=
=
NULL
)
{
linker_error
(
this
-
>
prog
"
unresolved
reference
to
function
%
s
'
\
n
"
name
)
;
this
-
>
success
=
false
;
return
visit_stop
;
}
ir_function
*
f
=
linked
-
>
symbols
-
>
get_function
(
name
)
;
if
(
f
=
=
NULL
)
{
f
=
new
(
linked
)
ir_function
(
name
)
;
linked
-
>
symbols
-
>
add_function
(
f
)
;
linked
-
>
ir
-
>
push_tail
(
f
)
;
}
ir_function_signature
*
linked_sig
=
f
-
>
exact_matching_signature
(
NULL
&
callee
-
>
parameters
)
;
if
(
linked_sig
=
=
NULL
)
{
linked_sig
=
new
(
linked
)
ir_function_signature
(
callee
-
>
return_type
)
;
f
-
>
add_signature
(
linked_sig
)
;
}
assert
(
!
linked_sig
-
>
is_defined
)
;
assert
(
linked_sig
-
>
body
.
is_empty
(
)
)
;
struct
hash_table
*
ht
=
_mesa_pointer_hash_table_create
(
NULL
)
;
exec_list
formal_parameters
;
foreach_in_list
(
const
ir_instruction
original
&
sig
-
>
parameters
)
{
assert
(
const_cast
<
ir_instruction
*
>
(
original
)
-
>
as_variable
(
)
)
;
ir_instruction
*
copy
=
original
-
>
clone
(
linked
ht
)
;
formal_parameters
.
push_tail
(
copy
)
;
}
linked_sig
-
>
replace_parameters
(
&
formal_parameters
)
;
linked_sig
-
>
intrinsic_id
=
sig
-
>
intrinsic_id
;
if
(
sig
-
>
is_defined
)
{
foreach_in_list
(
const
ir_instruction
original
&
sig
-
>
body
)
{
ir_instruction
*
copy
=
original
-
>
clone
(
linked
ht
)
;
linked_sig
-
>
body
.
push_tail
(
copy
)
;
}
linked_sig
-
>
is_defined
=
true
;
}
_mesa_hash_table_destroy
(
ht
NULL
)
;
linked_sig
-
>
accept
(
this
)
;
ir
-
>
callee
=
linked_sig
;
return
visit_continue
;
}
virtual
ir_visitor_status
visit_leave
(
ir_call
*
ir
)
{
const
exec_node
*
formal_param_node
=
ir
-
>
callee
-
>
parameters
.
get_head
(
)
;
if
(
formal_param_node
)
{
const
exec_node
*
actual_param_node
=
ir
-
>
actual_parameters
.
get_head
(
)
;
while
(
!
actual_param_node
-
>
is_tail_sentinel
(
)
)
{
ir_variable
*
formal_param
=
(
ir_variable
*
)
formal_param_node
;
ir_rvalue
*
actual_param
=
(
ir_rvalue
*
)
actual_param_node
;
formal_param_node
=
formal_param_node
-
>
get_next
(
)
;
actual_param_node
=
actual_param_node
-
>
get_next
(
)
;
if
(
formal_param
-
>
type
-
>
is_array
(
)
)
{
ir_dereference_variable
*
deref
=
actual_param
-
>
as_dereference_variable
(
)
;
if
(
deref
&
&
deref
-
>
var
&
&
deref
-
>
var
-
>
type
-
>
is_array
(
)
)
{
deref
-
>
var
-
>
data
.
max_array_access
=
MAX2
(
formal_param
-
>
data
.
max_array_access
deref
-
>
var
-
>
data
.
max_array_access
)
;
}
}
}
}
return
visit_continue
;
}
virtual
ir_visitor_status
visit
(
ir_dereference_variable
*
ir
)
{
if
(
_mesa_set_search
(
locals
ir
-
>
var
)
=
=
NULL
)
{
ir_variable
*
var
=
linked
-
>
symbols
-
>
get_variable
(
ir
-
>
var
-
>
name
)
;
if
(
var
=
=
NULL
)
{
var
=
ir
-
>
var
-
>
clone
(
linked
NULL
)
;
linked
-
>
symbols
-
>
add_variable
(
var
)
;
linked
-
>
ir
-
>
push_head
(
var
)
;
}
else
{
if
(
var
-
>
type
-
>
is_array
(
)
)
{
var
-
>
data
.
max_array_access
=
MAX2
(
var
-
>
data
.
max_array_access
ir
-
>
var
-
>
data
.
max_array_access
)
;
if
(
var
-
>
type
-
>
length
=
=
0
&
&
ir
-
>
var
-
>
type
-
>
length
!
=
0
)
var
-
>
type
=
ir
-
>
var
-
>
type
;
}
if
(
var
-
>
is_interface_instance
(
)
)
{
int
*
const
linked_max_ifc_array_access
=
var
-
>
get_max_ifc_array_access
(
)
;
int
*
const
ir_max_ifc_array_access
=
ir
-
>
var
-
>
get_max_ifc_array_access
(
)
;
assert
(
linked_max_ifc_array_access
!
=
NULL
)
;
assert
(
ir_max_ifc_array_access
!
=
NULL
)
;
for
(
unsigned
i
=
0
;
i
<
var
-
>
get_interface_type
(
)
-
>
length
;
i
+
+
)
{
linked_max_ifc_array_access
[
i
]
=
MAX2
(
linked_max_ifc_array_access
[
i
]
ir_max_ifc_array_access
[
i
]
)
;
}
}
}
ir
-
>
var
=
var
;
}
return
visit_continue
;
}
bool
success
;
private
:
gl_shader_program
*
prog
;
gl_shader
*
*
shader_list
;
unsigned
num_shaders
;
gl_linked_shader
*
linked
;
set
*
locals
;
}
;
}
ir_function_signature
*
find_matching_signature
(
const
char
*
name
const
exec_list
*
actual_parameters
glsl_symbol_table
*
symbols
)
{
ir_function
*
const
f
=
symbols
-
>
get_function
(
name
)
;
if
(
f
)
{
ir_function_signature
*
sig
=
f
-
>
matching_signature
(
NULL
actual_parameters
false
)
;
if
(
sig
&
&
(
sig
-
>
is_defined
|
|
sig
-
>
is_intrinsic
(
)
)
)
return
sig
;
}
return
NULL
;
}
bool
link_function_calls
(
gl_shader_program
*
prog
gl_linked_shader
*
main
gl_shader
*
*
shader_list
unsigned
num_shaders
)
{
call_link_visitor
v
(
prog
main
shader_list
num_shaders
)
;
v
.
run
(
main
-
>
ir
)
;
return
v
.
success
;
}
