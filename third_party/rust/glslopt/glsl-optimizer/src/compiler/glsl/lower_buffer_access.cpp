#
include
"
lower_buffer_access
.
h
"
#
include
"
ir_builder
.
h
"
#
include
"
main
/
macros
.
h
"
#
include
"
util
/
list
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
linker
.
h
"
using
namespace
ir_builder
;
namespace
lower_buffer_access
{
static
inline
int
writemask_for_size
(
unsigned
n
)
{
return
(
(
1
<
<
n
)
-
1
)
;
}
void
lower_buffer_access
:
:
emit_access
(
void
*
mem_ctx
bool
is_write
ir_dereference
*
deref
ir_variable
*
base_offset
unsigned
int
deref_offset
bool
row_major
const
glsl_type
*
matrix_type
enum
glsl_interface_packing
packing
unsigned
int
write_mask
)
{
if
(
deref
-
>
type
-
>
is_struct
(
)
)
{
unsigned
int
field_offset
=
0
;
for
(
unsigned
i
=
0
;
i
<
deref
-
>
type
-
>
length
;
i
+
+
)
{
const
struct
glsl_struct_field
*
field
=
&
deref
-
>
type
-
>
fields
.
structure
[
i
]
;
ir_dereference
*
field_deref
=
new
(
mem_ctx
)
ir_dereference_record
(
deref
-
>
clone
(
mem_ctx
NULL
)
field
-
>
name
)
;
unsigned
field_align
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
field_align
=
field
-
>
type
-
>
std430_base_alignment
(
row_major
)
;
else
field_align
=
field
-
>
type
-
>
std140_base_alignment
(
row_major
)
;
field_offset
=
glsl_align
(
field_offset
field_align
)
;
emit_access
(
mem_ctx
is_write
field_deref
base_offset
deref_offset
+
field_offset
row_major
NULL
packing
writemask_for_size
(
field_deref
-
>
type
-
>
vector_elements
)
)
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
field_offset
+
=
field
-
>
type
-
>
std430_size
(
row_major
)
;
else
field_offset
+
=
field
-
>
type
-
>
std140_size
(
row_major
)
;
}
return
;
}
if
(
deref
-
>
type
-
>
is_array
(
)
)
{
unsigned
array_stride
=
packing
=
=
GLSL_INTERFACE_PACKING_STD430
?
deref
-
>
type
-
>
fields
.
array
-
>
std430_array_stride
(
row_major
)
:
glsl_align
(
deref
-
>
type
-
>
fields
.
array
-
>
std140_size
(
row_major
)
16
)
;
for
(
unsigned
i
=
0
;
i
<
deref
-
>
type
-
>
length
;
i
+
+
)
{
ir_constant
*
element
=
new
(
mem_ctx
)
ir_constant
(
i
)
;
ir_dereference
*
element_deref
=
new
(
mem_ctx
)
ir_dereference_array
(
deref
-
>
clone
(
mem_ctx
NULL
)
element
)
;
emit_access
(
mem_ctx
is_write
element_deref
base_offset
deref_offset
+
i
*
array_stride
row_major
NULL
packing
writemask_for_size
(
element_deref
-
>
type
-
>
vector_elements
)
)
;
}
return
;
}
if
(
deref
-
>
type
-
>
is_matrix
(
)
)
{
for
(
unsigned
i
=
0
;
i
<
deref
-
>
type
-
>
matrix_columns
;
i
+
+
)
{
ir_constant
*
col
=
new
(
mem_ctx
)
ir_constant
(
i
)
;
ir_dereference
*
col_deref
=
new
(
mem_ctx
)
ir_dereference_array
(
deref
-
>
clone
(
mem_ctx
NULL
)
col
)
;
const
unsigned
size_mul
=
row_major
?
(
deref
-
>
type
-
>
is_double
(
)
?
8
:
4
)
:
link_calculate_matrix_stride
(
deref
-
>
type
row_major
packing
)
;
emit_access
(
mem_ctx
is_write
col_deref
base_offset
deref_offset
+
i
*
size_mul
row_major
deref
-
>
type
packing
writemask_for_size
(
col_deref
-
>
type
-
>
vector_elements
)
)
;
}
return
;
}
assert
(
deref
-
>
type
-
>
is_scalar
(
)
|
|
deref
-
>
type
-
>
is_vector
(
)
)
;
if
(
!
row_major
)
{
ir_rvalue
*
offset
=
add
(
base_offset
new
(
mem_ctx
)
ir_constant
(
deref_offset
)
)
;
unsigned
mask
=
is_write
?
write_mask
:
(
1
<
<
deref
-
>
type
-
>
vector_elements
)
-
1
;
insert_buffer_access
(
mem_ctx
deref
deref
-
>
type
offset
mask
-
1
)
;
}
else
{
assert
(
deref
-
>
type
-
>
is_float
(
)
|
|
deref
-
>
type
-
>
is_double
(
)
)
;
assert
(
matrix_type
!
=
NULL
)
;
const
unsigned
matrix_stride
=
link_calculate_matrix_stride
(
matrix_type
row_major
packing
)
;
const
glsl_type
*
deref_type
=
deref
-
>
type
-
>
get_scalar_type
(
)
;
for
(
unsigned
i
=
0
;
i
<
deref
-
>
type
-
>
vector_elements
;
i
+
+
)
{
ir_rvalue
*
chan_offset
=
add
(
base_offset
new
(
mem_ctx
)
ir_constant
(
deref_offset
+
i
*
matrix_stride
)
)
;
if
(
!
is_write
|
|
(
(
1U
<
<
i
)
&
write_mask
)
)
insert_buffer_access
(
mem_ctx
deref
deref_type
chan_offset
(
1U
<
<
i
)
i
)
;
}
}
}
bool
lower_buffer_access
:
:
is_dereferenced_thing_row_major
(
const
ir_rvalue
*
deref
)
{
bool
matrix
=
false
;
const
ir_rvalue
*
ir
=
deref
;
while
(
true
)
{
matrix
=
matrix
|
|
ir
-
>
type
-
>
without_array
(
)
-
>
is_matrix
(
)
;
switch
(
ir
-
>
ir_type
)
{
case
ir_type_dereference_array
:
{
const
ir_dereference_array
*
const
array_deref
=
(
const
ir_dereference_array
*
)
ir
;
ir
=
array_deref
-
>
array
;
break
;
}
case
ir_type_dereference_record
:
{
const
ir_dereference_record
*
const
record_deref
=
(
const
ir_dereference_record
*
)
ir
;
ir
=
record_deref
-
>
record
;
const
int
idx
=
record_deref
-
>
field_idx
;
assert
(
idx
>
=
0
)
;
const
enum
glsl_matrix_layout
matrix_layout
=
glsl_matrix_layout
(
ir
-
>
type
-
>
fields
.
structure
[
idx
]
.
matrix_layout
)
;
switch
(
matrix_layout
)
{
case
GLSL_MATRIX_LAYOUT_INHERITED
:
break
;
case
GLSL_MATRIX_LAYOUT_COLUMN_MAJOR
:
return
false
;
case
GLSL_MATRIX_LAYOUT_ROW_MAJOR
:
return
matrix
|
|
deref
-
>
type
-
>
without_array
(
)
-
>
is_struct
(
)
;
}
break
;
}
case
ir_type_dereference_variable
:
{
const
ir_dereference_variable
*
const
var_deref
=
(
const
ir_dereference_variable
*
)
ir
;
const
enum
glsl_matrix_layout
matrix_layout
=
glsl_matrix_layout
(
var_deref
-
>
var
-
>
data
.
matrix_layout
)
;
switch
(
matrix_layout
)
{
case
GLSL_MATRIX_LAYOUT_INHERITED
:
{
ASSERTED
ir_variable
*
var
=
deref
-
>
variable_referenced
(
)
;
assert
(
(
var
-
>
is_in_buffer_block
(
)
&
&
!
matrix
)
|
|
var
-
>
data
.
mode
=
=
ir_var_shader_shared
)
;
return
false
;
}
case
GLSL_MATRIX_LAYOUT_COLUMN_MAJOR
:
return
false
;
case
GLSL_MATRIX_LAYOUT_ROW_MAJOR
:
return
matrix
|
|
deref
-
>
type
-
>
without_array
(
)
-
>
is_struct
(
)
;
}
unreachable
(
"
invalid
matrix
layout
"
)
;
break
;
}
default
:
return
false
;
}
}
unreachable
(
"
invalid
dereference
tree
"
)
;
return
false
;
}
void
lower_buffer_access
:
:
setup_buffer_access
(
void
*
mem_ctx
ir_rvalue
*
deref
ir_rvalue
*
*
offset
unsigned
*
const_offset
bool
*
row_major
const
glsl_type
*
*
matrix_type
const
glsl_struct_field
*
*
struct_field
enum
glsl_interface_packing
packing
)
{
*
offset
=
new
(
mem_ctx
)
ir_constant
(
0u
)
;
*
row_major
=
is_dereferenced_thing_row_major
(
deref
)
;
*
matrix_type
=
NULL
;
while
(
deref
)
{
switch
(
deref
-
>
ir_type
)
{
case
ir_type_dereference_variable
:
{
deref
=
NULL
;
break
;
}
case
ir_type_dereference_array
:
{
ir_dereference_array
*
deref_array
=
(
ir_dereference_array
*
)
deref
;
unsigned
array_stride
;
if
(
deref_array
-
>
array
-
>
type
-
>
is_vector
(
)
)
{
array_stride
=
4
;
if
(
deref_array
-
>
array
-
>
type
-
>
is_64bit
(
)
)
array_stride
*
=
2
;
}
else
if
(
deref_array
-
>
array
-
>
type
-
>
is_matrix
(
)
&
&
*
row_major
)
{
array_stride
=
4
;
if
(
deref_array
-
>
array
-
>
type
-
>
is_64bit
(
)
)
array_stride
*
=
2
;
*
matrix_type
=
deref_array
-
>
array
-
>
type
;
}
else
if
(
deref_array
-
>
type
-
>
without_array
(
)
-
>
is_interface
(
)
)
{
deref
=
deref_array
-
>
array
-
>
as_dereference
(
)
;
break
;
}
else
{
const
bool
array_row_major
=
is_dereferenced_thing_row_major
(
deref_array
)
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
{
array_stride
=
deref_array
-
>
type
-
>
std430_array_stride
(
array_row_major
)
;
}
else
{
array_stride
=
deref_array
-
>
type
-
>
std140_size
(
array_row_major
)
;
array_stride
=
glsl_align
(
array_stride
16
)
;
}
}
ir_rvalue
*
array_index
=
deref_array
-
>
array_index
;
if
(
array_index
-
>
type
-
>
base_type
=
=
GLSL_TYPE_INT
)
array_index
=
i2u
(
array_index
)
;
ir_constant
*
const_index
=
array_index
-
>
constant_expression_value
(
mem_ctx
NULL
)
;
if
(
const_index
)
{
*
const_offset
+
=
array_stride
*
const_index
-
>
value
.
u
[
0
]
;
}
else
{
*
offset
=
add
(
*
offset
mul
(
array_index
new
(
mem_ctx
)
ir_constant
(
array_stride
)
)
)
;
}
deref
=
deref_array
-
>
array
-
>
as_dereference
(
)
;
break
;
}
case
ir_type_dereference_record
:
{
ir_dereference_record
*
deref_record
=
(
ir_dereference_record
*
)
deref
;
const
glsl_type
*
struct_type
=
deref_record
-
>
record
-
>
type
;
unsigned
intra_struct_offset
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
struct_type
-
>
length
;
i
+
+
)
{
const
glsl_type
*
type
=
struct_type
-
>
fields
.
structure
[
i
]
.
type
;
ir_dereference_record
*
field_deref
=
new
(
mem_ctx
)
ir_dereference_record
(
deref_record
-
>
record
struct_type
-
>
fields
.
structure
[
i
]
.
name
)
;
const
bool
field_row_major
=
is_dereferenced_thing_row_major
(
field_deref
)
;
ralloc_free
(
field_deref
)
;
unsigned
field_align
=
0
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
field_align
=
type
-
>
std430_base_alignment
(
field_row_major
)
;
else
field_align
=
type
-
>
std140_base_alignment
(
field_row_major
)
;
if
(
struct_type
-
>
fields
.
structure
[
i
]
.
offset
!
=
-
1
)
{
intra_struct_offset
=
struct_type
-
>
fields
.
structure
[
i
]
.
offset
;
}
intra_struct_offset
=
glsl_align
(
intra_struct_offset
field_align
)
;
assert
(
deref_record
-
>
field_idx
>
=
0
)
;
if
(
i
=
=
(
unsigned
)
deref_record
-
>
field_idx
)
{
if
(
struct_field
)
*
struct_field
=
&
struct_type
-
>
fields
.
structure
[
i
]
;
break
;
}
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
)
intra_struct_offset
+
=
type
-
>
std430_size
(
field_row_major
)
;
else
intra_struct_offset
+
=
type
-
>
std140_size
(
field_row_major
)
;
if
(
type
-
>
without_array
(
)
-
>
is_struct
(
)
)
{
intra_struct_offset
=
glsl_align
(
intra_struct_offset
field_align
)
;
}
}
*
const_offset
+
=
intra_struct_offset
;
deref
=
deref_record
-
>
record
-
>
as_dereference
(
)
;
break
;
}
case
ir_type_swizzle
:
{
ir_swizzle
*
deref_swizzle
=
(
ir_swizzle
*
)
deref
;
assert
(
deref_swizzle
-
>
mask
.
num_components
=
=
1
)
;
*
const_offset
+
=
deref_swizzle
-
>
mask
.
x
*
sizeof
(
int
)
;
deref
=
deref_swizzle
-
>
val
-
>
as_dereference
(
)
;
break
;
}
default
:
assert
(
!
"
not
reached
"
)
;
deref
=
NULL
;
break
;
}
}
}
}
