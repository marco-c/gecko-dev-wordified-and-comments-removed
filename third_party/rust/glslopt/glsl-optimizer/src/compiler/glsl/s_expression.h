#
ifndef
S_EXPRESSION_H
#
define
S_EXPRESSION_H
#
include
"
util
/
strtod
.
h
"
#
include
"
list
.
h
"
#
define
SX_AS_
(
t
x
)
(
(
x
)
&
&
(
(
s_expression
*
)
x
)
-
>
is_
#
#
t
(
)
)
?
(
(
s_
#
#
t
*
)
(
x
)
)
\
:
NULL
#
define
SX_AS_LIST
(
x
)
SX_AS_
(
list
x
)
#
define
SX_AS_SYMBOL
(
x
)
SX_AS_
(
symbol
x
)
#
define
SX_AS_NUMBER
(
x
)
SX_AS_
(
number
x
)
#
define
SX_AS_INT
(
x
)
SX_AS_
(
int
x
)
#
define
MATCH
(
list
pat
)
s_match
(
list
ARRAY_SIZE
(
pat
)
pat
false
)
#
define
PARTIAL_MATCH
(
list
pat
)
s_match
(
list
ARRAY_SIZE
(
pat
)
pat
true
)
class
s_expression
:
public
exec_node
{
public
:
static
s_expression
*
read_expression
(
void
*
ctx
const
char
*
&
src
)
;
virtual
void
print
(
)
=
0
;
virtual
bool
is_list
(
)
const
{
return
false
;
}
virtual
bool
is_symbol
(
)
const
{
return
false
;
}
virtual
bool
is_number
(
)
const
{
return
false
;
}
virtual
bool
is_int
(
)
const
{
return
false
;
}
protected
:
s_expression
(
)
{
}
}
;
class
s_number
:
public
s_expression
{
public
:
bool
is_number
(
)
const
{
return
true
;
}
virtual
float
fvalue
(
)
=
0
;
protected
:
s_number
(
)
{
}
}
;
class
s_int
:
public
s_number
{
public
:
s_int
(
int
x
)
:
val
(
x
)
{
}
bool
is_int
(
)
const
{
return
true
;
}
float
fvalue
(
)
{
return
float
(
this
-
>
val
)
;
}
int
value
(
)
{
return
this
-
>
val
;
}
void
print
(
)
;
private
:
int
val
;
}
;
class
s_float
:
public
s_number
{
public
:
s_float
(
float
x
)
:
val
(
x
)
{
}
float
fvalue
(
)
{
return
this
-
>
val
;
}
void
print
(
)
;
private
:
float
val
;
}
;
class
s_symbol
:
public
s_expression
{
public
:
s_symbol
(
const
char
*
size_t
)
;
bool
is_symbol
(
)
const
{
return
true
;
}
const
char
*
value
(
)
{
return
this
-
>
str
;
}
void
print
(
)
;
private
:
const
char
*
str
;
}
;
class
s_list
:
public
s_expression
{
public
:
s_list
(
)
;
virtual
bool
is_list
(
)
const
{
return
true
;
}
void
print
(
)
;
exec_list
subexpressions
;
}
;
class
s_pattern
{
public
:
s_pattern
(
s_expression
*
&
s
)
:
p_expr
(
&
s
)
type
(
EXPR
)
{
}
s_pattern
(
s_list
*
&
s
)
:
p_list
(
&
s
)
type
(
LIST
)
{
}
s_pattern
(
s_symbol
*
&
s
)
:
p_symbol
(
&
s
)
type
(
SYMBOL
)
{
}
s_pattern
(
s_number
*
&
s
)
:
p_number
(
&
s
)
type
(
NUMBER
)
{
}
s_pattern
(
s_int
*
&
s
)
:
p_int
(
&
s
)
type
(
INT
)
{
}
s_pattern
(
const
char
*
str
)
:
literal
(
str
)
type
(
STRING
)
{
}
bool
match
(
s_expression
*
expr
)
;
private
:
union
{
s_expression
*
*
p_expr
;
s_list
*
*
p_list
;
s_symbol
*
*
p_symbol
;
s_number
*
*
p_number
;
s_int
*
*
p_int
;
const
char
*
literal
;
}
;
enum
{
EXPR
LIST
SYMBOL
NUMBER
INT
STRING
}
type
;
}
;
bool
s_match
(
s_expression
*
top
unsigned
n
s_pattern
*
pattern
bool
partial
)
;
#
endif
