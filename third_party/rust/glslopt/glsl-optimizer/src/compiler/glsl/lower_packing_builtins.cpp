#
include
"
ir
.
h
"
#
include
"
ir_builder
.
h
"
#
include
"
ir_optimization
.
h
"
#
include
"
ir_rvalue_visitor
.
h
"
namespace
{
using
namespace
ir_builder
;
class
lower_packing_builtins_visitor
:
public
ir_rvalue_visitor
{
public
:
explicit
lower_packing_builtins_visitor
(
int
op_mask
)
:
op_mask
(
op_mask
)
progress
(
false
)
{
factory
.
instructions
=
&
factory_instructions
;
}
virtual
~
lower_packing_builtins_visitor
(
)
{
assert
(
factory_instructions
.
is_empty
(
)
)
;
}
bool
get_progress
(
)
{
return
progress
;
}
void
handle_rvalue
(
ir_rvalue
*
*
rvalue
)
{
if
(
!
*
rvalue
)
return
;
ir_expression
*
expr
=
(
*
rvalue
)
-
>
as_expression
(
)
;
if
(
!
expr
)
return
;
enum
lower_packing_builtins_op
lowering_op
=
choose_lowering_op
(
expr
-
>
operation
)
;
if
(
lowering_op
=
=
LOWER_PACK_UNPACK_NONE
)
return
;
setup_factory
(
ralloc_parent
(
expr
)
)
;
ir_rvalue
*
op0
=
expr
-
>
operands
[
0
]
;
ralloc_steal
(
factory
.
mem_ctx
op0
)
;
switch
(
lowering_op
)
{
case
LOWER_PACK_SNORM_2x16
:
*
rvalue
=
lower_pack_snorm_2x16
(
op0
)
;
break
;
case
LOWER_PACK_SNORM_4x8
:
*
rvalue
=
lower_pack_snorm_4x8
(
op0
)
;
break
;
case
LOWER_PACK_UNORM_2x16
:
*
rvalue
=
lower_pack_unorm_2x16
(
op0
)
;
break
;
case
LOWER_PACK_UNORM_4x8
:
*
rvalue
=
lower_pack_unorm_4x8
(
op0
)
;
break
;
case
LOWER_PACK_HALF_2x16
:
*
rvalue
=
lower_pack_half_2x16
(
op0
)
;
break
;
case
LOWER_UNPACK_SNORM_2x16
:
*
rvalue
=
lower_unpack_snorm_2x16
(
op0
)
;
break
;
case
LOWER_UNPACK_SNORM_4x8
:
*
rvalue
=
lower_unpack_snorm_4x8
(
op0
)
;
break
;
case
LOWER_UNPACK_UNORM_2x16
:
*
rvalue
=
lower_unpack_unorm_2x16
(
op0
)
;
break
;
case
LOWER_UNPACK_UNORM_4x8
:
*
rvalue
=
lower_unpack_unorm_4x8
(
op0
)
;
break
;
case
LOWER_UNPACK_HALF_2x16
:
*
rvalue
=
lower_unpack_half_2x16
(
op0
)
;
break
;
case
LOWER_PACK_UNPACK_NONE
:
case
LOWER_PACK_USE_BFI
:
case
LOWER_PACK_USE_BFE
:
assert
(
!
"
not
reached
"
)
;
break
;
}
teardown_factory
(
)
;
progress
=
true
;
}
private
:
const
int
op_mask
;
bool
progress
;
ir_factory
factory
;
exec_list
factory_instructions
;
enum
lower_packing_builtins_op
choose_lowering_op
(
ir_expression_operation
expr_op
)
{
int
result
;
switch
(
expr_op
)
{
case
ir_unop_pack_snorm_2x16
:
result
=
op_mask
&
LOWER_PACK_SNORM_2x16
;
break
;
case
ir_unop_pack_snorm_4x8
:
result
=
op_mask
&
LOWER_PACK_SNORM_4x8
;
break
;
case
ir_unop_pack_unorm_2x16
:
result
=
op_mask
&
LOWER_PACK_UNORM_2x16
;
break
;
case
ir_unop_pack_unorm_4x8
:
result
=
op_mask
&
LOWER_PACK_UNORM_4x8
;
break
;
case
ir_unop_pack_half_2x16
:
result
=
op_mask
&
LOWER_PACK_HALF_2x16
;
break
;
case
ir_unop_unpack_snorm_2x16
:
result
=
op_mask
&
LOWER_UNPACK_SNORM_2x16
;
break
;
case
ir_unop_unpack_snorm_4x8
:
result
=
op_mask
&
LOWER_UNPACK_SNORM_4x8
;
break
;
case
ir_unop_unpack_unorm_2x16
:
result
=
op_mask
&
LOWER_UNPACK_UNORM_2x16
;
break
;
case
ir_unop_unpack_unorm_4x8
:
result
=
op_mask
&
LOWER_UNPACK_UNORM_4x8
;
break
;
case
ir_unop_unpack_half_2x16
:
result
=
op_mask
&
LOWER_UNPACK_HALF_2x16
;
break
;
default
:
result
=
LOWER_PACK_UNPACK_NONE
;
break
;
}
return
static_cast
<
enum
lower_packing_builtins_op
>
(
result
)
;
}
void
setup_factory
(
void
*
mem_ctx
)
{
assert
(
factory
.
mem_ctx
=
=
NULL
)
;
assert
(
factory
.
instructions
-
>
is_empty
(
)
)
;
factory
.
mem_ctx
=
mem_ctx
;
}
void
teardown_factory
(
)
{
base_ir
-
>
insert_before
(
factory
.
instructions
)
;
assert
(
factory
.
instructions
-
>
is_empty
(
)
)
;
factory
.
mem_ctx
=
NULL
;
}
template
<
typename
T
>
ir_constant
*
constant
(
T
x
)
{
return
factory
.
constant
(
x
)
;
}
ir_rvalue
*
pack_uvec2_to_uint
(
ir_rvalue
*
uvec2_rval
)
{
assert
(
uvec2_rval
-
>
type
=
=
glsl_type
:
:
uvec2_type
)
;
ir_variable
*
u
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_pack_uvec2_to_uint
"
)
;
factory
.
emit
(
assign
(
u
uvec2_rval
)
)
;
if
(
op_mask
&
LOWER_PACK_USE_BFI
)
{
return
bitfield_insert
(
bit_and
(
swizzle_x
(
u
)
constant
(
0xffffu
)
)
swizzle_y
(
u
)
constant
(
16u
)
constant
(
16u
)
)
;
}
return
bit_or
(
lshift
(
swizzle_y
(
u
)
constant
(
16u
)
)
bit_and
(
swizzle_x
(
u
)
constant
(
0xffffu
)
)
)
;
}
ir_rvalue
*
pack_uvec4_to_uint
(
ir_rvalue
*
uvec4_rval
)
{
assert
(
uvec4_rval
-
>
type
=
=
glsl_type
:
:
uvec4_type
)
;
ir_variable
*
u
=
factory
.
make_temp
(
glsl_type
:
:
uvec4_type
"
tmp_pack_uvec4_to_uint
"
)
;
if
(
op_mask
&
LOWER_PACK_USE_BFI
)
{
factory
.
emit
(
assign
(
u
uvec4_rval
)
)
;
return
bitfield_insert
(
bitfield_insert
(
bitfield_insert
(
bit_and
(
swizzle_x
(
u
)
constant
(
0xffu
)
)
swizzle_y
(
u
)
constant
(
8u
)
constant
(
8u
)
)
swizzle_z
(
u
)
constant
(
16u
)
constant
(
8u
)
)
swizzle_w
(
u
)
constant
(
24u
)
constant
(
8u
)
)
;
}
factory
.
emit
(
assign
(
u
bit_and
(
uvec4_rval
constant
(
0xffu
)
)
)
)
;
return
bit_or
(
bit_or
(
lshift
(
swizzle_w
(
u
)
constant
(
24u
)
)
lshift
(
swizzle_z
(
u
)
constant
(
16u
)
)
)
bit_or
(
lshift
(
swizzle_y
(
u
)
constant
(
8u
)
)
swizzle_x
(
u
)
)
)
;
}
ir_rvalue
*
unpack_uint_to_uvec2
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_variable
*
u
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_unpack_uint_to_uvec2_u
"
)
;
factory
.
emit
(
assign
(
u
uint_rval
)
)
;
ir_variable
*
u2
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_unpack_uint_to_uvec2_u2
"
)
;
factory
.
emit
(
assign
(
u2
bit_and
(
u
constant
(
0xffffu
)
)
WRITEMASK_X
)
)
;
factory
.
emit
(
assign
(
u2
rshift
(
u
constant
(
16u
)
)
WRITEMASK_Y
)
)
;
return
deref
(
u2
)
.
val
;
}
ir_rvalue
*
unpack_uint_to_ivec2
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
if
(
!
(
op_mask
&
LOWER_PACK_USE_BFE
)
)
{
return
rshift
(
lshift
(
u2i
(
unpack_uint_to_uvec2
(
uint_rval
)
)
constant
(
16u
)
)
constant
(
16u
)
)
;
}
ir_variable
*
i
=
factory
.
make_temp
(
glsl_type
:
:
int_type
"
tmp_unpack_uint_to_ivec2_i
"
)
;
factory
.
emit
(
assign
(
i
u2i
(
uint_rval
)
)
)
;
ir_variable
*
i2
=
factory
.
make_temp
(
glsl_type
:
:
ivec2_type
"
tmp_unpack_uint_to_ivec2_i2
"
)
;
factory
.
emit
(
assign
(
i2
bitfield_extract
(
i
constant
(
0
)
constant
(
16
)
)
WRITEMASK_X
)
)
;
factory
.
emit
(
assign
(
i2
bitfield_extract
(
i
constant
(
16
)
constant
(
16
)
)
WRITEMASK_Y
)
)
;
return
deref
(
i2
)
.
val
;
}
ir_rvalue
*
unpack_uint_to_uvec4
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_variable
*
u
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_unpack_uint_to_uvec4_u
"
)
;
factory
.
emit
(
assign
(
u
uint_rval
)
)
;
ir_variable
*
u4
=
factory
.
make_temp
(
glsl_type
:
:
uvec4_type
"
tmp_unpack_uint_to_uvec4_u4
"
)
;
factory
.
emit
(
assign
(
u4
bit_and
(
u
constant
(
0xffu
)
)
WRITEMASK_X
)
)
;
if
(
op_mask
&
LOWER_PACK_USE_BFE
)
{
factory
.
emit
(
assign
(
u4
bitfield_extract
(
u
constant
(
8u
)
constant
(
8u
)
)
WRITEMASK_Y
)
)
;
factory
.
emit
(
assign
(
u4
bitfield_extract
(
u
constant
(
16u
)
constant
(
8u
)
)
WRITEMASK_Z
)
)
;
}
else
{
factory
.
emit
(
assign
(
u4
bit_and
(
rshift
(
u
constant
(
8u
)
)
constant
(
0xffu
)
)
WRITEMASK_Y
)
)
;
factory
.
emit
(
assign
(
u4
bit_and
(
rshift
(
u
constant
(
16u
)
)
constant
(
0xffu
)
)
WRITEMASK_Z
)
)
;
}
factory
.
emit
(
assign
(
u4
rshift
(
u
constant
(
24u
)
)
WRITEMASK_W
)
)
;
return
deref
(
u4
)
.
val
;
}
ir_rvalue
*
unpack_uint_to_ivec4
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
if
(
!
(
op_mask
&
LOWER_PACK_USE_BFE
)
)
{
return
rshift
(
lshift
(
u2i
(
unpack_uint_to_uvec4
(
uint_rval
)
)
constant
(
24u
)
)
constant
(
24u
)
)
;
}
ir_variable
*
i
=
factory
.
make_temp
(
glsl_type
:
:
int_type
"
tmp_unpack_uint_to_ivec4_i
"
)
;
factory
.
emit
(
assign
(
i
u2i
(
uint_rval
)
)
)
;
ir_variable
*
i4
=
factory
.
make_temp
(
glsl_type
:
:
ivec4_type
"
tmp_unpack_uint_to_ivec4_i4
"
)
;
factory
.
emit
(
assign
(
i4
bitfield_extract
(
i
constant
(
0
)
constant
(
8
)
)
WRITEMASK_X
)
)
;
factory
.
emit
(
assign
(
i4
bitfield_extract
(
i
constant
(
8
)
constant
(
8
)
)
WRITEMASK_Y
)
)
;
factory
.
emit
(
assign
(
i4
bitfield_extract
(
i
constant
(
16
)
constant
(
8
)
)
WRITEMASK_Z
)
)
;
factory
.
emit
(
assign
(
i4
bitfield_extract
(
i
constant
(
24
)
constant
(
8
)
)
WRITEMASK_W
)
)
;
return
deref
(
i4
)
.
val
;
}
ir_rvalue
*
lower_pack_snorm_2x16
(
ir_rvalue
*
vec2_rval
)
{
assert
(
vec2_rval
-
>
type
=
=
glsl_type
:
:
vec2_type
)
;
ir_rvalue
*
result
=
pack_uvec2_to_uint
(
i2u
(
f2i
(
round_even
(
mul
(
clamp
(
vec2_rval
constant
(
-
1
.
0f
)
constant
(
1
.
0f
)
)
constant
(
32767
.
0f
)
)
)
)
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
return
result
;
}
ir_rvalue
*
lower_pack_snorm_4x8
(
ir_rvalue
*
vec4_rval
)
{
assert
(
vec4_rval
-
>
type
=
=
glsl_type
:
:
vec4_type
)
;
ir_rvalue
*
result
=
pack_uvec4_to_uint
(
i2u
(
f2i
(
round_even
(
mul
(
clamp
(
vec4_rval
constant
(
-
1
.
0f
)
constant
(
1
.
0f
)
)
constant
(
127
.
0f
)
)
)
)
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
return
result
;
}
ir_rvalue
*
lower_unpack_snorm_2x16
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_rvalue
*
result
=
clamp
(
div
(
i2f
(
unpack_uint_to_ivec2
(
uint_rval
)
)
constant
(
32767
.
0f
)
)
constant
(
-
1
.
0f
)
constant
(
1
.
0f
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
vec2_type
)
;
return
result
;
}
ir_rvalue
*
lower_unpack_snorm_4x8
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_rvalue
*
result
=
clamp
(
div
(
i2f
(
unpack_uint_to_ivec4
(
uint_rval
)
)
constant
(
127
.
0f
)
)
constant
(
-
1
.
0f
)
constant
(
1
.
0f
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
vec4_type
)
;
return
result
;
}
ir_rvalue
*
lower_pack_unorm_2x16
(
ir_rvalue
*
vec2_rval
)
{
assert
(
vec2_rval
-
>
type
=
=
glsl_type
:
:
vec2_type
)
;
ir_rvalue
*
result
=
pack_uvec2_to_uint
(
f2u
(
round_even
(
mul
(
saturate
(
vec2_rval
)
constant
(
65535
.
0f
)
)
)
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
return
result
;
}
ir_rvalue
*
lower_pack_unorm_4x8
(
ir_rvalue
*
vec4_rval
)
{
assert
(
vec4_rval
-
>
type
=
=
glsl_type
:
:
vec4_type
)
;
ir_rvalue
*
result
=
pack_uvec4_to_uint
(
f2u
(
round_even
(
mul
(
saturate
(
vec4_rval
)
constant
(
255
.
0f
)
)
)
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
return
result
;
}
ir_rvalue
*
lower_unpack_unorm_2x16
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_rvalue
*
result
=
div
(
u2f
(
unpack_uint_to_uvec2
(
uint_rval
)
)
constant
(
65535
.
0f
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
vec2_type
)
;
return
result
;
}
ir_rvalue
*
lower_unpack_unorm_4x8
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_rvalue
*
result
=
div
(
u2f
(
unpack_uint_to_uvec4
(
uint_rval
)
)
constant
(
255
.
0f
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
vec4_type
)
;
return
result
;
}
ir_rvalue
*
pack_half_1x16_nosign
(
ir_rvalue
*
f_rval
ir_rvalue
*
e_rval
ir_rvalue
*
m_rval
)
{
assert
(
e_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
assert
(
m_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_variable
*
u16
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_pack_half_1x16_u16
"
)
;
ir_variable
*
f
=
factory
.
make_temp
(
glsl_type
:
:
float_type
"
tmp_pack_half_1x16_f
"
)
;
factory
.
emit
(
assign
(
f
f_rval
)
)
;
ir_variable
*
e
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_pack_half_1x16_e
"
)
;
factory
.
emit
(
assign
(
e
e_rval
)
)
;
ir_variable
*
m
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_pack_half_1x16_m
"
)
;
factory
.
emit
(
assign
(
m
m_rval
)
)
;
factory
.
emit
(
if_tree
(
logic_and
(
equal
(
e
constant
(
0xffu
<
<
23u
)
)
logic_not
(
equal
(
m
constant
(
0u
)
)
)
)
assign
(
u16
constant
(
0x7fffu
)
)
if_tree
(
less
(
e
constant
(
113u
<
<
23u
)
)
assign
(
u16
f2u
(
round_even
(
mul
(
expr
(
ir_unop_abs
f
)
constant
(
(
float
)
(
1
<
<
24
)
)
)
)
)
)
if_tree
(
less
(
e
constant
(
143u
<
<
23u
)
)
assign
(
u16
add
(
rshift
(
sub
(
e
constant
(
112u
<
<
23u
)
)
constant
(
13u
)
)
f2u
(
round_even
(
div
(
u2f
(
m
)
constant
(
(
float
)
(
1
<
<
13
)
)
)
)
)
)
)
assign
(
u16
constant
(
31u
<
<
10u
)
)
)
)
)
)
;
return
deref
(
u16
)
.
val
;
}
ir_rvalue
*
lower_pack_half_2x16
(
ir_rvalue
*
vec2_rval
)
{
assert
(
vec2_rval
-
>
type
=
=
glsl_type
:
:
vec2_type
)
;
ir_variable
*
f
=
factory
.
make_temp
(
glsl_type
:
:
vec2_type
"
tmp_pack_half_2x16_f
"
)
;
factory
.
emit
(
assign
(
f
vec2_rval
)
)
;
ir_variable
*
f32
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_pack_half_2x16_f32
"
)
;
factory
.
emit
(
assign
(
f32
expr
(
ir_unop_bitcast_f2u
f
)
)
)
;
ir_variable
*
f16
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_pack_half_2x16_f16
"
)
;
ir_variable
*
e
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_pack_half_2x16_e
"
)
;
factory
.
emit
(
assign
(
e
bit_and
(
f32
constant
(
0x7f800000u
)
)
)
)
;
ir_variable
*
m
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_pack_half_2x16_m
"
)
;
factory
.
emit
(
assign
(
m
bit_and
(
f32
constant
(
0x007fffffu
)
)
)
)
;
factory
.
emit
(
assign
(
f16
pack_half_1x16_nosign
(
swizzle_x
(
f
)
swizzle_x
(
e
)
swizzle_x
(
m
)
)
WRITEMASK_X
)
)
;
factory
.
emit
(
assign
(
f16
pack_half_1x16_nosign
(
swizzle_y
(
f
)
swizzle_y
(
e
)
swizzle_y
(
m
)
)
WRITEMASK_Y
)
)
;
factory
.
emit
(
assign
(
f16
bit_or
(
f16
rshift
(
bit_and
(
f32
constant
(
1u
<
<
31u
)
)
constant
(
16u
)
)
)
)
)
;
ir_rvalue
*
result
=
bit_or
(
lshift
(
swizzle_y
(
f16
)
constant
(
16u
)
)
swizzle_x
(
f16
)
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
return
result
;
}
ir_rvalue
*
unpack_half_1x16_nosign
(
ir_rvalue
*
e_rval
ir_rvalue
*
m_rval
)
{
assert
(
e_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
assert
(
m_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_variable
*
u32
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_unpack_half_1x16_u32
"
)
;
ir_variable
*
e
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_unpack_half_1x16_e
"
)
;
factory
.
emit
(
assign
(
e
e_rval
)
)
;
ir_variable
*
m
=
factory
.
make_temp
(
glsl_type
:
:
uint_type
"
tmp_unpack_half_1x16_m
"
)
;
factory
.
emit
(
assign
(
m
m_rval
)
)
;
factory
.
emit
(
if_tree
(
equal
(
e
constant
(
0u
)
)
assign
(
u32
expr
(
ir_unop_bitcast_f2u
div
(
u2f
(
m
)
constant
(
(
float
)
(
1
<
<
24
)
)
)
)
)
if_tree
(
less
(
e
constant
(
31u
<
<
10u
)
)
assign
(
u32
lshift
(
bit_or
(
add
(
e
constant
(
112u
<
<
10u
)
)
m
)
constant
(
13u
)
)
)
if_tree
(
equal
(
m
constant
(
0u
)
)
assign
(
u32
constant
(
255u
<
<
23u
)
)
assign
(
u32
constant
(
0x7fffffffu
)
)
)
)
)
)
;
return
deref
(
u32
)
.
val
;
}
ir_rvalue
*
lower_unpack_half_2x16
(
ir_rvalue
*
uint_rval
)
{
assert
(
uint_rval
-
>
type
=
=
glsl_type
:
:
uint_type
)
;
ir_variable
*
f16
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_unpack_half_2x16_f16
"
)
;
factory
.
emit
(
assign
(
f16
unpack_uint_to_uvec2
(
uint_rval
)
)
)
;
ir_variable
*
f32
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_unpack_half_2x16_f32
"
)
;
ir_variable
*
e
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_unpack_half_2x16_e
"
)
;
factory
.
emit
(
assign
(
e
bit_and
(
f16
constant
(
0x7c00u
)
)
)
)
;
ir_variable
*
m
=
factory
.
make_temp
(
glsl_type
:
:
uvec2_type
"
tmp_unpack_half_2x16_m
"
)
;
factory
.
emit
(
assign
(
m
bit_and
(
f16
constant
(
0x03ffu
)
)
)
)
;
factory
.
emit
(
assign
(
f32
unpack_half_1x16_nosign
(
swizzle_x
(
e
)
swizzle_x
(
m
)
)
WRITEMASK_X
)
)
;
factory
.
emit
(
assign
(
f32
unpack_half_1x16_nosign
(
swizzle_y
(
e
)
swizzle_y
(
m
)
)
WRITEMASK_Y
)
)
;
factory
.
emit
(
assign
(
f32
bit_or
(
f32
lshift
(
bit_and
(
f16
constant
(
0x8000u
)
)
constant
(
16u
)
)
)
)
)
;
ir_rvalue
*
result
=
expr
(
ir_unop_bitcast_u2f
f32
)
;
assert
(
result
-
>
type
=
=
glsl_type
:
:
vec2_type
)
;
return
result
;
}
}
;
}
bool
lower_packing_builtins
(
exec_list
*
instructions
int
op_mask
)
{
lower_packing_builtins_visitor
v
(
op_mask
)
;
visit_list_elements
(
&
v
instructions
true
)
;
return
v
.
get_progress
(
)
;
}
