#
include
"
ir
.
h
"
#
include
"
ir_visitor
.
h
"
#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
main
/
mtypes
.
h
"
namespace
{
class
ir_set_program_inouts_visitor
:
public
ir_hierarchical_visitor
{
public
:
ir_set_program_inouts_visitor
(
struct
gl_program
*
prog
gl_shader_stage
shader_stage
)
{
this
-
>
prog
=
prog
;
this
-
>
shader_stage
=
shader_stage
;
}
~
ir_set_program_inouts_visitor
(
)
{
}
virtual
ir_visitor_status
visit_enter
(
ir_dereference_array
*
)
;
virtual
ir_visitor_status
visit_enter
(
ir_function_signature
*
)
;
virtual
ir_visitor_status
visit_enter
(
ir_discard
*
)
;
virtual
ir_visitor_status
visit_enter
(
ir_texture
*
)
;
virtual
ir_visitor_status
visit
(
ir_dereference_variable
*
)
;
private
:
void
mark_whole_variable
(
ir_variable
*
var
)
;
bool
try_mark_partial_variable
(
ir_variable
*
var
ir_rvalue
*
index
)
;
struct
gl_program
*
prog
;
gl_shader_stage
shader_stage
;
}
;
}
static
inline
bool
is_shader_inout
(
ir_variable
*
var
)
{
return
var
-
>
data
.
mode
=
=
ir_var_shader_in
|
|
var
-
>
data
.
mode
=
=
ir_var_shader_out
|
|
var
-
>
data
.
mode
=
=
ir_var_system_value
;
}
static
void
mark
(
struct
gl_program
*
prog
ir_variable
*
var
int
offset
int
len
gl_shader_stage
stage
)
{
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
assert
(
var
-
>
data
.
location
!
=
-
1
)
;
int
idx
=
var
-
>
data
.
location
+
offset
+
i
;
bool
is_patch_generic
=
var
-
>
data
.
patch
&
&
idx
!
=
VARYING_SLOT_TESS_LEVEL_INNER
&
&
idx
!
=
VARYING_SLOT_TESS_LEVEL_OUTER
&
&
idx
!
=
VARYING_SLOT_BOUNDING_BOX0
&
&
idx
!
=
VARYING_SLOT_BOUNDING_BOX1
;
GLbitfield64
bitfield
;
if
(
is_patch_generic
)
{
assert
(
idx
>
=
VARYING_SLOT_PATCH0
&
&
idx
<
VARYING_SLOT_TESS_MAX
)
;
bitfield
=
BITFIELD64_BIT
(
idx
-
VARYING_SLOT_PATCH0
)
;
}
else
{
assert
(
idx
<
VARYING_SLOT_MAX
)
;
bitfield
=
BITFIELD64_BIT
(
idx
)
;
}
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
if
(
is_patch_generic
)
prog
-
>
info
.
patch_inputs_read
|
=
bitfield
;
else
prog
-
>
info
.
inputs_read
|
=
bitfield
;
if
(
stage
=
=
MESA_SHADER_VERTEX
&
&
var
-
>
type
-
>
without_array
(
)
-
>
is_dual_slot
(
)
)
prog
-
>
DualSlotInputs
|
=
bitfield
;
if
(
stage
=
=
MESA_SHADER_FRAGMENT
)
{
prog
-
>
info
.
fs
.
uses_sample_qualifier
|
=
var
-
>
data
.
sample
;
}
}
else
if
(
var
-
>
data
.
mode
=
=
ir_var_system_value
)
{
prog
-
>
info
.
system_values_read
|
=
bitfield
;
}
else
{
assert
(
var
-
>
data
.
mode
=
=
ir_var_shader_out
)
;
if
(
is_patch_generic
)
{
prog
-
>
info
.
patch_outputs_written
|
=
bitfield
;
}
else
if
(
!
var
-
>
data
.
read_only
)
{
prog
-
>
info
.
outputs_written
|
=
bitfield
;
if
(
var
-
>
data
.
index
>
0
)
prog
-
>
SecondaryOutputsWritten
|
=
bitfield
;
}
if
(
var
-
>
data
.
fb_fetch_output
)
prog
-
>
info
.
outputs_read
|
=
bitfield
;
}
}
}
void
ir_set_program_inouts_visitor
:
:
mark_whole_variable
(
ir_variable
*
var
)
{
const
glsl_type
*
type
=
var
-
>
type
;
bool
is_vertex_input
=
false
;
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_GEOMETRY
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
type
-
>
is_array
(
)
)
{
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_CTRL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_CTRL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_out
&
&
!
var
-
>
data
.
patch
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_EVAL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
!
var
-
>
data
.
patch
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_VERTEX
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
is_vertex_input
=
true
;
mark
(
this
-
>
prog
var
0
type
-
>
count_attribute_slots
(
is_vertex_input
)
this
-
>
shader_stage
)
;
}
ir_visitor_status
ir_set_program_inouts_visitor
:
:
visit
(
ir_dereference_variable
*
ir
)
{
if
(
!
is_shader_inout
(
ir
-
>
var
)
)
return
visit_continue
;
mark_whole_variable
(
ir
-
>
var
)
;
return
visit_continue
;
}
bool
ir_set_program_inouts_visitor
:
:
try_mark_partial_variable
(
ir_variable
*
var
ir_rvalue
*
index
)
{
const
glsl_type
*
type
=
var
-
>
type
;
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_GEOMETRY
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_CTRL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_CTRL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_out
&
&
!
var
-
>
data
.
patch
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
this
-
>
shader_stage
=
=
MESA_SHADER_TESS_EVAL
&
&
var
-
>
data
.
mode
=
=
ir_var_shader_in
&
&
!
var
-
>
data
.
patch
)
{
assert
(
type
-
>
is_array
(
)
)
;
type
=
type
-
>
fields
.
array
;
}
if
(
type
-
>
is_array
(
)
&
&
type
-
>
fields
.
array
-
>
is_array
(
)
)
return
false
;
if
(
!
(
type
-
>
is_matrix
(
)
|
|
(
type
-
>
is_array
(
)
&
&
(
type
-
>
fields
.
array
-
>
is_numeric
(
)
|
|
type
-
>
fields
.
array
-
>
is_boolean
(
)
)
)
)
)
{
return
false
;
}
ir_constant
*
index_as_constant
=
index
-
>
as_constant
(
)
;
if
(
!
index_as_constant
)
return
false
;
unsigned
elem_width
;
unsigned
num_elems
;
if
(
type
-
>
is_array
(
)
)
{
num_elems
=
type
-
>
length
;
if
(
type
-
>
fields
.
array
-
>
is_matrix
(
)
)
elem_width
=
type
-
>
fields
.
array
-
>
matrix_columns
;
else
elem_width
=
1
;
}
else
{
num_elems
=
type
-
>
matrix_columns
;
elem_width
=
1
;
}
if
(
index_as_constant
-
>
value
.
u
[
0
]
>
=
num_elems
)
{
return
false
;
}
if
(
this
-
>
shader_stage
!
=
MESA_SHADER_VERTEX
|
|
var
-
>
data
.
mode
!
=
ir_var_shader_in
)
{
if
(
type
-
>
without_array
(
)
-
>
is_dual_slot
(
)
)
elem_width
*
=
2
;
}
mark
(
this
-
>
prog
var
index_as_constant
-
>
value
.
u
[
0
]
*
elem_width
elem_width
this
-
>
shader_stage
)
;
return
true
;
}
static
bool
is_multiple_vertices
(
gl_shader_stage
stage
ir_variable
*
var
)
{
if
(
var
-
>
data
.
patch
)
return
false
;
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_in
)
return
stage
=
=
MESA_SHADER_GEOMETRY
|
|
stage
=
=
MESA_SHADER_TESS_CTRL
|
|
stage
=
=
MESA_SHADER_TESS_EVAL
;
if
(
var
-
>
data
.
mode
=
=
ir_var_shader_out
)
return
stage
=
=
MESA_SHADER_TESS_CTRL
;
return
false
;
}
ir_visitor_status
ir_set_program_inouts_visitor
:
:
visit_enter
(
ir_dereference_array
*
ir
)
{
if
(
ir_dereference_array
*
const
inner_array
=
ir
-
>
array
-
>
as_dereference_array
(
)
)
{
if
(
ir_dereference_variable
*
const
deref_var
=
inner_array
-
>
array
-
>
as_dereference_variable
(
)
)
{
if
(
is_multiple_vertices
(
this
-
>
shader_stage
deref_var
-
>
var
)
)
{
if
(
try_mark_partial_variable
(
deref_var
-
>
var
ir
-
>
array_index
)
)
{
inner_array
-
>
array_index
-
>
accept
(
this
)
;
return
visit_continue_with_parent
;
}
}
}
}
else
if
(
ir_dereference_variable
*
const
deref_var
=
ir
-
>
array
-
>
as_dereference_variable
(
)
)
{
if
(
is_multiple_vertices
(
this
-
>
shader_stage
deref_var
-
>
var
)
)
{
mark_whole_variable
(
deref_var
-
>
var
)
;
ir
-
>
array_index
-
>
accept
(
this
)
;
return
visit_continue_with_parent
;
}
else
if
(
is_shader_inout
(
deref_var
-
>
var
)
)
{
if
(
try_mark_partial_variable
(
deref_var
-
>
var
ir
-
>
array_index
)
)
return
visit_continue_with_parent
;
}
}
return
visit_continue
;
}
ir_visitor_status
ir_set_program_inouts_visitor
:
:
visit_enter
(
ir_function_signature
*
ir
)
{
visit_list_elements
(
this
&
ir
-
>
body
)
;
return
visit_continue_with_parent
;
}
ir_visitor_status
ir_set_program_inouts_visitor
:
:
visit_enter
(
ir_discard
*
)
{
assert
(
this
-
>
shader_stage
=
=
MESA_SHADER_FRAGMENT
)
;
prog
-
>
info
.
fs
.
uses_discard
=
true
;
return
visit_continue
;
}
ir_visitor_status
ir_set_program_inouts_visitor
:
:
visit_enter
(
ir_texture
*
ir
)
{
if
(
ir
-
>
op
=
=
ir_tg4
)
prog
-
>
info
.
uses_texture_gather
=
true
;
return
visit_continue
;
}
void
do_set_program_inouts
(
exec_list
*
instructions
struct
gl_program
*
prog
gl_shader_stage
shader_stage
)
{
ir_set_program_inouts_visitor
v
(
prog
shader_stage
)
;
prog
-
>
info
.
inputs_read
=
0
;
prog
-
>
info
.
outputs_written
=
0
;
prog
-
>
SecondaryOutputsWritten
=
0
;
prog
-
>
info
.
outputs_read
=
0
;
prog
-
>
info
.
patch_inputs_read
=
0
;
prog
-
>
info
.
patch_outputs_written
=
0
;
prog
-
>
info
.
system_values_read
=
0
;
if
(
shader_stage
=
=
MESA_SHADER_FRAGMENT
)
{
prog
-
>
info
.
fs
.
uses_sample_qualifier
=
false
;
prog
-
>
info
.
fs
.
uses_discard
=
false
;
}
visit_list_elements
(
&
v
instructions
)
;
}
