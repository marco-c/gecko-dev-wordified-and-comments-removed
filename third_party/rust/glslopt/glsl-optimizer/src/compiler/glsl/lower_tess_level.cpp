#
include
"
glsl_symbol_table
.
h
"
#
include
"
ir_rvalue_visitor
.
h
"
#
include
"
ir
.
h
"
#
include
"
program
/
prog_instruction
.
h
"
#
include
"
main
/
mtypes
.
h
"
namespace
{
class
lower_tess_level_visitor
:
public
ir_rvalue_visitor
{
public
:
explicit
lower_tess_level_visitor
(
gl_shader_stage
shader_stage
)
:
progress
(
false
)
old_tess_level_outer_var
(
NULL
)
old_tess_level_inner_var
(
NULL
)
new_tess_level_outer_var
(
NULL
)
new_tess_level_inner_var
(
NULL
)
shader_stage
(
shader_stage
)
{
}
virtual
ir_visitor_status
visit
(
ir_variable
*
)
;
bool
is_tess_level_array
(
ir_rvalue
*
ir
)
;
ir_rvalue
*
lower_tess_level_array
(
ir_rvalue
*
ir
)
;
virtual
ir_visitor_status
visit_leave
(
ir_assignment
*
)
;
void
visit_new_assignment
(
ir_assignment
*
ir
)
;
virtual
ir_visitor_status
visit_leave
(
ir_call
*
)
;
virtual
void
handle_rvalue
(
ir_rvalue
*
*
rvalue
)
;
void
fix_lhs
(
ir_assignment
*
)
;
bool
progress
;
ir_variable
*
old_tess_level_outer_var
;
ir_variable
*
old_tess_level_inner_var
;
ir_variable
*
new_tess_level_outer_var
;
ir_variable
*
new_tess_level_inner_var
;
const
gl_shader_stage
shader_stage
;
}
;
}
ir_visitor_status
lower_tess_level_visitor
:
:
visit
(
ir_variable
*
ir
)
{
if
(
(
!
ir
-
>
name
)
|
|
(
(
strcmp
(
ir
-
>
name
"
gl_TessLevelInner
"
)
!
=
0
)
&
&
(
strcmp
(
ir
-
>
name
"
gl_TessLevelOuter
"
)
!
=
0
)
)
)
return
visit_continue
;
assert
(
ir
-
>
type
-
>
is_array
(
)
)
;
if
(
strcmp
(
ir
-
>
name
"
gl_TessLevelOuter
"
)
=
=
0
)
{
if
(
this
-
>
old_tess_level_outer_var
)
return
visit_continue
;
old_tess_level_outer_var
=
ir
;
assert
(
ir
-
>
type
-
>
fields
.
array
=
=
glsl_type
:
:
float_type
)
;
new_tess_level_outer_var
=
ir
-
>
clone
(
ralloc_parent
(
ir
)
NULL
)
;
new_tess_level_outer_var
-
>
name
=
ralloc_strdup
(
new_tess_level_outer_var
"
gl_TessLevelOuterMESA
"
)
;
new_tess_level_outer_var
-
>
type
=
glsl_type
:
:
vec4_type
;
new_tess_level_outer_var
-
>
data
.
max_array_access
=
0
;
ir
-
>
replace_with
(
new_tess_level_outer_var
)
;
}
else
if
(
strcmp
(
ir
-
>
name
"
gl_TessLevelInner
"
)
=
=
0
)
{
if
(
this
-
>
old_tess_level_inner_var
)
return
visit_continue
;
old_tess_level_inner_var
=
ir
;
assert
(
ir
-
>
type
-
>
fields
.
array
=
=
glsl_type
:
:
float_type
)
;
new_tess_level_inner_var
=
ir
-
>
clone
(
ralloc_parent
(
ir
)
NULL
)
;
new_tess_level_inner_var
-
>
name
=
ralloc_strdup
(
new_tess_level_inner_var
"
gl_TessLevelInnerMESA
"
)
;
new_tess_level_inner_var
-
>
type
=
glsl_type
:
:
vec2_type
;
new_tess_level_inner_var
-
>
data
.
max_array_access
=
0
;
ir
-
>
replace_with
(
new_tess_level_inner_var
)
;
}
else
{
assert
(
0
)
;
}
this
-
>
progress
=
true
;
return
visit_continue
;
}
bool
lower_tess_level_visitor
:
:
is_tess_level_array
(
ir_rvalue
*
ir
)
{
if
(
!
ir
-
>
type
-
>
is_array
(
)
)
return
false
;
if
(
ir
-
>
type
-
>
fields
.
array
!
=
glsl_type
:
:
float_type
)
return
false
;
if
(
this
-
>
old_tess_level_outer_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_tess_level_outer_var
)
return
true
;
}
if
(
this
-
>
old_tess_level_inner_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_tess_level_inner_var
)
return
true
;
}
return
false
;
}
ir_rvalue
*
lower_tess_level_visitor
:
:
lower_tess_level_array
(
ir_rvalue
*
ir
)
{
if
(
!
ir
-
>
type
-
>
is_array
(
)
)
return
NULL
;
if
(
ir
-
>
type
-
>
fields
.
array
!
=
glsl_type
:
:
float_type
)
return
NULL
;
ir_variable
*
*
new_var
=
NULL
;
if
(
this
-
>
old_tess_level_outer_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_tess_level_outer_var
)
new_var
=
&
this
-
>
new_tess_level_outer_var
;
}
if
(
this
-
>
old_tess_level_inner_var
)
{
if
(
ir
-
>
variable_referenced
(
)
=
=
this
-
>
old_tess_level_inner_var
)
new_var
=
&
this
-
>
new_tess_level_inner_var
;
}
if
(
new_var
=
=
NULL
)
return
NULL
;
assert
(
ir
-
>
as_dereference_variable
(
)
)
;
return
new
(
ralloc_parent
(
ir
)
)
ir_dereference_variable
(
*
new_var
)
;
}
void
lower_tess_level_visitor
:
:
handle_rvalue
(
ir_rvalue
*
*
rv
)
{
if
(
*
rv
=
=
NULL
)
return
;
ir_dereference_array
*
const
array_deref
=
(
*
rv
)
-
>
as_dereference_array
(
)
;
if
(
array_deref
=
=
NULL
)
return
;
ir_rvalue
*
lowered_vec4
=
this
-
>
lower_tess_level_array
(
array_deref
-
>
array
)
;
if
(
lowered_vec4
!
=
NULL
)
{
this
-
>
progress
=
true
;
void
*
mem_ctx
=
ralloc_parent
(
array_deref
)
;
ir_expression
*
const
expr
=
new
(
mem_ctx
)
ir_expression
(
ir_binop_vector_extract
lowered_vec4
array_deref
-
>
array_index
)
;
*
rv
=
expr
;
}
}
void
lower_tess_level_visitor
:
:
fix_lhs
(
ir_assignment
*
ir
)
{
if
(
ir
-
>
lhs
-
>
ir_type
!
=
ir_type_expression
)
return
;
void
*
mem_ctx
=
ralloc_parent
(
ir
)
;
ir_expression
*
const
expr
=
(
ir_expression
*
)
ir
-
>
lhs
;
assert
(
expr
-
>
operation
=
=
ir_binop_vector_extract
)
;
assert
(
expr
-
>
operands
[
0
]
-
>
ir_type
=
=
ir_type_dereference_variable
)
;
assert
(
(
expr
-
>
operands
[
0
]
-
>
type
=
=
glsl_type
:
:
vec4_type
)
|
|
(
expr
-
>
operands
[
0
]
-
>
type
=
=
glsl_type
:
:
vec2_type
)
)
;
ir_dereference
*
const
new_lhs
=
(
ir_dereference
*
)
expr
-
>
operands
[
0
]
;
ir_constant
*
old_index_constant
=
expr
-
>
operands
[
1
]
-
>
constant_expression_value
(
mem_ctx
)
;
if
(
!
old_index_constant
)
{
ir
-
>
rhs
=
new
(
mem_ctx
)
ir_expression
(
ir_triop_vector_insert
expr
-
>
operands
[
0
]
-
>
type
new_lhs
-
>
clone
(
mem_ctx
NULL
)
ir
-
>
rhs
expr
-
>
operands
[
1
]
)
;
}
ir
-
>
set_lhs
(
new_lhs
)
;
if
(
old_index_constant
)
{
ir
-
>
write_mask
=
1
<
<
old_index_constant
-
>
get_int_component
(
0
)
;
}
else
{
ir
-
>
write_mask
=
(
1
<
<
expr
-
>
operands
[
0
]
-
>
type
-
>
vector_elements
)
-
1
;
}
}
ir_visitor_status
lower_tess_level_visitor
:
:
visit_leave
(
ir_assignment
*
ir
)
{
ir_rvalue_visitor
:
:
visit_leave
(
ir
)
;
if
(
this
-
>
is_tess_level_array
(
ir
-
>
lhs
)
|
|
this
-
>
is_tess_level_array
(
ir
-
>
rhs
)
)
{
void
*
ctx
=
ralloc_parent
(
ir
)
;
int
array_size
=
ir
-
>
lhs
-
>
type
-
>
array_size
(
)
;
for
(
int
i
=
0
;
i
<
array_size
;
+
+
i
)
{
ir_dereference_array
*
new_lhs
=
new
(
ctx
)
ir_dereference_array
(
ir
-
>
lhs
-
>
clone
(
ctx
NULL
)
new
(
ctx
)
ir_constant
(
i
)
)
;
ir_dereference_array
*
new_rhs
=
new
(
ctx
)
ir_dereference_array
(
ir
-
>
rhs
-
>
clone
(
ctx
NULL
)
new
(
ctx
)
ir_constant
(
i
)
)
;
this
-
>
handle_rvalue
(
(
ir_rvalue
*
*
)
&
new_rhs
)
;
ir_assignment
*
const
assign
=
new
(
ctx
)
ir_assignment
(
new_lhs
new_rhs
)
;
this
-
>
handle_rvalue
(
(
ir_rvalue
*
*
)
&
assign
-
>
lhs
)
;
this
-
>
fix_lhs
(
assign
)
;
this
-
>
base_ir
-
>
insert_before
(
assign
)
;
}
ir
-
>
remove
(
)
;
return
visit_continue
;
}
handle_rvalue
(
(
ir_rvalue
*
*
)
&
ir
-
>
lhs
)
;
this
-
>
fix_lhs
(
ir
)
;
return
rvalue_visit
(
ir
)
;
}
void
lower_tess_level_visitor
:
:
visit_new_assignment
(
ir_assignment
*
ir
)
{
ir_instruction
*
old_base_ir
=
this
-
>
base_ir
;
this
-
>
base_ir
=
ir
;
ir
-
>
accept
(
this
)
;
this
-
>
base_ir
=
old_base_ir
;
}
ir_visitor_status
lower_tess_level_visitor
:
:
visit_leave
(
ir_call
*
ir
)
{
void
*
ctx
=
ralloc_parent
(
ir
)
;
const
exec_node
*
formal_param_node
=
ir
-
>
callee
-
>
parameters
.
get_head_raw
(
)
;
const
exec_node
*
actual_param_node
=
ir
-
>
actual_parameters
.
get_head_raw
(
)
;
while
(
!
actual_param_node
-
>
is_tail_sentinel
(
)
)
{
ir_variable
*
formal_param
=
(
ir_variable
*
)
formal_param_node
;
ir_rvalue
*
actual_param
=
(
ir_rvalue
*
)
actual_param_node
;
formal_param_node
=
formal_param_node
-
>
next
;
actual_param_node
=
actual_param_node
-
>
next
;
if
(
!
this
-
>
is_tess_level_array
(
actual_param
)
)
continue
;
ir_variable
*
temp
=
new
(
ctx
)
ir_variable
(
actual_param
-
>
type
"
temp_tess_level
"
ir_var_temporary
)
;
this
-
>
base_ir
-
>
insert_before
(
temp
)
;
actual_param
-
>
replace_with
(
new
(
ctx
)
ir_dereference_variable
(
temp
)
)
;
if
(
formal_param
-
>
data
.
mode
=
=
ir_var_function_in
|
|
formal_param
-
>
data
.
mode
=
=
ir_var_function_inout
)
{
ir_assignment
*
new_assignment
=
new
(
ctx
)
ir_assignment
(
new
(
ctx
)
ir_dereference_variable
(
temp
)
actual_param
-
>
clone
(
ctx
NULL
)
)
;
this
-
>
base_ir
-
>
insert_before
(
new_assignment
)
;
this
-
>
visit_new_assignment
(
new_assignment
)
;
}
if
(
formal_param
-
>
data
.
mode
=
=
ir_var_function_out
|
|
formal_param
-
>
data
.
mode
=
=
ir_var_function_inout
)
{
ir_assignment
*
new_assignment
=
new
(
ctx
)
ir_assignment
(
actual_param
-
>
clone
(
ctx
NULL
)
new
(
ctx
)
ir_dereference_variable
(
temp
)
)
;
this
-
>
base_ir
-
>
insert_after
(
new_assignment
)
;
this
-
>
visit_new_assignment
(
new_assignment
)
;
}
}
return
rvalue_visit
(
ir
)
;
}
bool
lower_tess_level
(
gl_linked_shader
*
shader
)
{
if
(
(
shader
-
>
Stage
!
=
MESA_SHADER_TESS_CTRL
)
&
&
(
shader
-
>
Stage
!
=
MESA_SHADER_TESS_EVAL
)
)
return
false
;
lower_tess_level_visitor
v
(
shader
-
>
Stage
)
;
visit_list_elements
(
&
v
shader
-
>
ir
)
;
if
(
v
.
new_tess_level_outer_var
)
shader
-
>
symbols
-
>
add_variable
(
v
.
new_tess_level_outer_var
)
;
if
(
v
.
new_tess_level_inner_var
)
shader
-
>
symbols
-
>
add_variable
(
v
.
new_tess_level_inner_var
)
;
return
v
.
progress
;
}
