#
include
<
assert
.
h
>
#
include
<
stdio
.
h
>
#
include
<
math
.
h
>
#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
s_expression
.
h
"
s_symbol
:
:
s_symbol
(
const
char
*
str
size_t
n
)
{
assert
(
str
[
n
]
=
=
'
\
0
'
)
;
this
-
>
str
=
str
;
}
s_list
:
:
s_list
(
)
{
}
static
void
skip_whitespace
(
const
char
*
&
src
char
*
&
symbol_buffer
)
{
size_t
n
=
strspn
(
src
"
\
v
\
t
\
r
\
n
"
)
;
src
+
=
n
;
symbol_buffer
+
=
n
;
if
(
src
[
0
]
=
=
'
;
'
)
{
n
=
strcspn
(
src
"
\
n
"
)
;
src
+
=
n
;
symbol_buffer
+
=
n
;
skip_whitespace
(
src
symbol_buffer
)
;
}
}
static
s_expression
*
read_atom
(
void
*
ctx
const
char
*
&
src
char
*
&
symbol_buffer
)
{
s_expression
*
expr
=
NULL
;
skip_whitespace
(
src
symbol_buffer
)
;
size_t
n
=
strcspn
(
src
"
(
\
v
\
t
\
r
\
n
)
;
"
)
;
if
(
n
=
=
0
)
return
NULL
;
if
(
n
=
=
4
&
&
strncmp
(
src
"
+
INF
"
4
)
=
=
0
)
{
expr
=
new
(
ctx
)
s_float
(
INFINITY
)
;
}
else
{
char
*
float_end
=
NULL
;
float
f
=
_mesa_strtof
(
src
&
float_end
)
;
if
(
float_end
!
=
src
)
{
char
*
int_end
=
NULL
;
int
i
=
strtol
(
src
&
int_end
10
)
;
if
(
float_end
>
int_end
)
expr
=
new
(
ctx
)
s_float
(
f
)
;
else
expr
=
new
(
ctx
)
s_int
(
i
)
;
}
else
{
symbol_buffer
[
n
]
=
'
\
0
'
;
expr
=
new
(
ctx
)
s_symbol
(
symbol_buffer
n
)
;
}
}
src
+
=
n
;
symbol_buffer
+
=
n
;
return
expr
;
}
static
s_expression
*
__read_expression
(
void
*
ctx
const
char
*
&
src
char
*
&
symbol_buffer
)
{
s_expression
*
atom
=
read_atom
(
ctx
src
symbol_buffer
)
;
if
(
atom
!
=
NULL
)
return
atom
;
skip_whitespace
(
src
symbol_buffer
)
;
if
(
src
[
0
]
=
=
'
(
'
)
{
+
+
src
;
+
+
symbol_buffer
;
s_list
*
list
=
new
(
ctx
)
s_list
;
s_expression
*
expr
;
while
(
(
expr
=
__read_expression
(
ctx
src
symbol_buffer
)
)
!
=
NULL
)
{
list
-
>
subexpressions
.
push_tail
(
expr
)
;
}
skip_whitespace
(
src
symbol_buffer
)
;
if
(
src
[
0
]
!
=
'
)
'
)
{
printf
(
"
Unclosed
expression
(
check
your
parenthesis
)
.
\
n
"
)
;
return
NULL
;
}
+
+
src
;
+
+
symbol_buffer
;
return
list
;
}
return
NULL
;
}
s_expression
*
s_expression
:
:
read_expression
(
void
*
ctx
const
char
*
&
src
)
{
assert
(
src
!
=
NULL
)
;
char
*
symbol_buffer
=
ralloc_strdup
(
ctx
src
)
;
return
__read_expression
(
ctx
src
symbol_buffer
)
;
}
void
s_int
:
:
print
(
)
{
printf
(
"
%
d
"
this
-
>
val
)
;
}
void
s_float
:
:
print
(
)
{
printf
(
"
%
f
"
this
-
>
val
)
;
}
void
s_symbol
:
:
print
(
)
{
printf
(
"
%
s
"
this
-
>
str
)
;
}
void
s_list
:
:
print
(
)
{
printf
(
"
(
"
)
;
foreach_in_list
(
s_expression
expr
&
this
-
>
subexpressions
)
{
expr
-
>
print
(
)
;
if
(
!
expr
-
>
next
-
>
is_tail_sentinel
(
)
)
printf
(
"
"
)
;
}
printf
(
"
)
"
)
;
}
bool
s_pattern
:
:
match
(
s_expression
*
expr
)
{
switch
(
type
)
{
case
EXPR
:
*
p_expr
=
expr
;
break
;
case
LIST
:
if
(
expr
-
>
is_list
(
)
)
*
p_list
=
(
s_list
*
)
expr
;
break
;
case
SYMBOL
:
if
(
expr
-
>
is_symbol
(
)
)
*
p_symbol
=
(
s_symbol
*
)
expr
;
break
;
case
NUMBER
:
if
(
expr
-
>
is_number
(
)
)
*
p_number
=
(
s_number
*
)
expr
;
break
;
case
INT
:
if
(
expr
-
>
is_int
(
)
)
*
p_int
=
(
s_int
*
)
expr
;
break
;
case
STRING
:
s_symbol
*
sym
=
SX_AS_SYMBOL
(
expr
)
;
if
(
sym
!
=
NULL
&
&
strcmp
(
sym
-
>
value
(
)
literal
)
=
=
0
)
return
true
;
return
false
;
}
;
return
*
p_expr
=
=
expr
;
}
bool
s_match
(
s_expression
*
top
unsigned
n
s_pattern
*
pattern
bool
partial
)
{
s_list
*
list
=
SX_AS_LIST
(
top
)
;
if
(
list
=
=
NULL
)
return
false
;
unsigned
i
=
0
;
foreach_in_list
(
s_expression
expr
&
list
-
>
subexpressions
)
{
if
(
i
>
=
n
)
return
partial
;
if
(
expr
=
=
NULL
|
|
!
pattern
[
i
]
.
match
(
expr
)
)
return
false
;
i
+
+
;
}
if
(
i
<
n
)
return
false
;
return
true
;
}
