#
line
1
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
c
"
#
line
3
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
c
"
#
define
YY_INT_ALIGNED
short
int
#
define
FLEX_SCANNER
#
define
YY_FLEX_MAJOR_VERSION
2
#
define
YY_FLEX_MINOR_VERSION
6
#
define
YY_FLEX_SUBMINOR_VERSION
4
#
if
YY_FLEX_SUBMINOR_VERSION
>
0
#
define
FLEX_BETA
#
endif
#
ifdef
yy_create_buffer
#
define
glcpp__create_buffer_ALREADY_DEFINED
#
else
#
define
yy_create_buffer
glcpp__create_buffer
#
endif
#
ifdef
yy_delete_buffer
#
define
glcpp__delete_buffer_ALREADY_DEFINED
#
else
#
define
yy_delete_buffer
glcpp__delete_buffer
#
endif
#
ifdef
yy_scan_buffer
#
define
glcpp__scan_buffer_ALREADY_DEFINED
#
else
#
define
yy_scan_buffer
glcpp__scan_buffer
#
endif
#
ifdef
yy_scan_string
#
define
glcpp__scan_string_ALREADY_DEFINED
#
else
#
define
yy_scan_string
glcpp__scan_string
#
endif
#
ifdef
yy_scan_bytes
#
define
glcpp__scan_bytes_ALREADY_DEFINED
#
else
#
define
yy_scan_bytes
glcpp__scan_bytes
#
endif
#
ifdef
yy_init_buffer
#
define
glcpp__init_buffer_ALREADY_DEFINED
#
else
#
define
yy_init_buffer
glcpp__init_buffer
#
endif
#
ifdef
yy_flush_buffer
#
define
glcpp__flush_buffer_ALREADY_DEFINED
#
else
#
define
yy_flush_buffer
glcpp__flush_buffer
#
endif
#
ifdef
yy_load_buffer_state
#
define
glcpp__load_buffer_state_ALREADY_DEFINED
#
else
#
define
yy_load_buffer_state
glcpp__load_buffer_state
#
endif
#
ifdef
yy_switch_to_buffer
#
define
glcpp__switch_to_buffer_ALREADY_DEFINED
#
else
#
define
yy_switch_to_buffer
glcpp__switch_to_buffer
#
endif
#
ifdef
yypush_buffer_state
#
define
glcpp_push_buffer_state_ALREADY_DEFINED
#
else
#
define
yypush_buffer_state
glcpp_push_buffer_state
#
endif
#
ifdef
yypop_buffer_state
#
define
glcpp_pop_buffer_state_ALREADY_DEFINED
#
else
#
define
yypop_buffer_state
glcpp_pop_buffer_state
#
endif
#
ifdef
yyensure_buffer_stack
#
define
glcpp_ensure_buffer_stack_ALREADY_DEFINED
#
else
#
define
yyensure_buffer_stack
glcpp_ensure_buffer_stack
#
endif
#
ifdef
yylex
#
define
glcpp_lex_ALREADY_DEFINED
#
else
#
define
yylex
glcpp_lex
#
endif
#
ifdef
yyrestart
#
define
glcpp_restart_ALREADY_DEFINED
#
else
#
define
yyrestart
glcpp_restart
#
endif
#
ifdef
yylex_init
#
define
glcpp_lex_init_ALREADY_DEFINED
#
else
#
define
yylex_init
glcpp_lex_init
#
endif
#
ifdef
yylex_init_extra
#
define
glcpp_lex_init_extra_ALREADY_DEFINED
#
else
#
define
yylex_init_extra
glcpp_lex_init_extra
#
endif
#
ifdef
yylex_destroy
#
define
glcpp_lex_destroy_ALREADY_DEFINED
#
else
#
define
yylex_destroy
glcpp_lex_destroy
#
endif
#
ifdef
yyget_debug
#
define
glcpp_get_debug_ALREADY_DEFINED
#
else
#
define
yyget_debug
glcpp_get_debug
#
endif
#
ifdef
yyset_debug
#
define
glcpp_set_debug_ALREADY_DEFINED
#
else
#
define
yyset_debug
glcpp_set_debug
#
endif
#
ifdef
yyget_extra
#
define
glcpp_get_extra_ALREADY_DEFINED
#
else
#
define
yyget_extra
glcpp_get_extra
#
endif
#
ifdef
yyset_extra
#
define
glcpp_set_extra_ALREADY_DEFINED
#
else
#
define
yyset_extra
glcpp_set_extra
#
endif
#
ifdef
yyget_in
#
define
glcpp_get_in_ALREADY_DEFINED
#
else
#
define
yyget_in
glcpp_get_in
#
endif
#
ifdef
yyset_in
#
define
glcpp_set_in_ALREADY_DEFINED
#
else
#
define
yyset_in
glcpp_set_in
#
endif
#
ifdef
yyget_out
#
define
glcpp_get_out_ALREADY_DEFINED
#
else
#
define
yyget_out
glcpp_get_out
#
endif
#
ifdef
yyset_out
#
define
glcpp_set_out_ALREADY_DEFINED
#
else
#
define
yyset_out
glcpp_set_out
#
endif
#
ifdef
yyget_leng
#
define
glcpp_get_leng_ALREADY_DEFINED
#
else
#
define
yyget_leng
glcpp_get_leng
#
endif
#
ifdef
yyget_text
#
define
glcpp_get_text_ALREADY_DEFINED
#
else
#
define
yyget_text
glcpp_get_text
#
endif
#
ifdef
yyget_lineno
#
define
glcpp_get_lineno_ALREADY_DEFINED
#
else
#
define
yyget_lineno
glcpp_get_lineno
#
endif
#
ifdef
yyset_lineno
#
define
glcpp_set_lineno_ALREADY_DEFINED
#
else
#
define
yyset_lineno
glcpp_set_lineno
#
endif
#
ifdef
yyget_column
#
define
glcpp_get_column_ALREADY_DEFINED
#
else
#
define
yyget_column
glcpp_get_column
#
endif
#
ifdef
yyset_column
#
define
glcpp_set_column_ALREADY_DEFINED
#
else
#
define
yyset_column
glcpp_set_column
#
endif
#
ifdef
yywrap
#
define
glcpp_wrap_ALREADY_DEFINED
#
else
#
define
yywrap
glcpp_wrap
#
endif
#
ifdef
yyget_lval
#
define
glcpp_get_lval_ALREADY_DEFINED
#
else
#
define
yyget_lval
glcpp_get_lval
#
endif
#
ifdef
yyset_lval
#
define
glcpp_set_lval_ALREADY_DEFINED
#
else
#
define
yyset_lval
glcpp_set_lval
#
endif
#
ifdef
yyget_lloc
#
define
glcpp_get_lloc_ALREADY_DEFINED
#
else
#
define
yyget_lloc
glcpp_get_lloc
#
endif
#
ifdef
yyset_lloc
#
define
glcpp_set_lloc_ALREADY_DEFINED
#
else
#
define
yyset_lloc
glcpp_set_lloc
#
endif
#
ifdef
yyalloc
#
define
glcpp_alloc_ALREADY_DEFINED
#
else
#
define
yyalloc
glcpp_alloc
#
endif
#
ifdef
yyrealloc
#
define
glcpp_realloc_ALREADY_DEFINED
#
else
#
define
yyrealloc
glcpp_realloc
#
endif
#
ifdef
yyfree
#
define
glcpp_free_ALREADY_DEFINED
#
else
#
define
yyfree
glcpp_free
#
endif
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
FLEXINT_H
#
define
FLEXINT_H
#
if
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
ifndef
__STDC_LIMIT_MACROS
#
define
__STDC_LIMIT_MACROS
1
#
endif
#
include
<
inttypes
.
h
>
typedef
int8_t
flex_int8_t
;
typedef
uint8_t
flex_uint8_t
;
typedef
int16_t
flex_int16_t
;
typedef
uint16_t
flex_uint16_t
;
typedef
int32_t
flex_int32_t
;
typedef
uint32_t
flex_uint32_t
;
#
else
typedef
signed
char
flex_int8_t
;
typedef
short
int
flex_int16_t
;
typedef
int
flex_int32_t
;
typedef
unsigned
char
flex_uint8_t
;
typedef
unsigned
short
int
flex_uint16_t
;
typedef
unsigned
int
flex_uint32_t
;
#
ifndef
INT8_MIN
#
define
INT8_MIN
(
-
128
)
#
endif
#
ifndef
INT16_MIN
#
define
INT16_MIN
(
-
32767
-
1
)
#
endif
#
ifndef
INT32_MIN
#
define
INT32_MIN
(
-
2147483647
-
1
)
#
endif
#
ifndef
INT8_MAX
#
define
INT8_MAX
(
127
)
#
endif
#
ifndef
INT16_MAX
#
define
INT16_MAX
(
32767
)
#
endif
#
ifndef
INT32_MAX
#
define
INT32_MAX
(
2147483647
)
#
endif
#
ifndef
UINT8_MAX
#
define
UINT8_MAX
(
255U
)
#
endif
#
ifndef
UINT16_MAX
#
define
UINT16_MAX
(
65535U
)
#
endif
#
ifndef
UINT32_MAX
#
define
UINT32_MAX
(
4294967295U
)
#
endif
#
ifndef
SIZE_MAX
#
define
SIZE_MAX
(
~
(
size_t
)
0
)
#
endif
#
endif
#
endif
#
define
yyconst
const
#
if
defined
(
__GNUC__
)
&
&
__GNUC__
>
=
3
#
define
yynoreturn
__attribute__
(
(
__noreturn__
)
)
#
else
#
define
yynoreturn
#
endif
#
define
YY_NULL
0
#
define
YY_SC_TO_UI
(
c
)
(
(
YY_CHAR
)
(
c
)
)
#
ifndef
YY_TYPEDEF_YY_SCANNER_T
#
define
YY_TYPEDEF_YY_SCANNER_T
typedef
void
*
yyscan_t
;
#
endif
#
define
yyin
yyg
-
>
yyin_r
#
define
yyout
yyg
-
>
yyout_r
#
define
yyextra
yyg
-
>
yyextra_r
#
define
yyleng
yyg
-
>
yyleng_r
#
define
yytext
yyg
-
>
yytext_r
#
define
yylineno
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_lineno
)
#
define
yycolumn
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_column
)
#
define
yy_flex_debug
yyg
-
>
yy_flex_debug_r
#
define
BEGIN
yyg
-
>
yy_start
=
1
+
2
*
#
define
YY_START
(
(
yyg
-
>
yy_start
-
1
)
/
2
)
#
define
YYSTATE
YY_START
#
define
YY_STATE_EOF
(
state
)
(
YY_END_OF_BUFFER
+
state
+
1
)
#
define
YY_NEW_FILE
yyrestart
(
yyin
yyscanner
)
#
define
YY_END_OF_BUFFER_CHAR
0
#
ifndef
YY_BUF_SIZE
#
ifdef
__ia64__
#
define
YY_BUF_SIZE
32768
#
else
#
define
YY_BUF_SIZE
16384
#
endif
#
endif
#
define
YY_STATE_BUF_SIZE
(
(
YY_BUF_SIZE
+
2
)
*
sizeof
(
yy_state_type
)
)
#
ifndef
YY_TYPEDEF_YY_BUFFER_STATE
#
define
YY_TYPEDEF_YY_BUFFER_STATE
typedef
struct
yy_buffer_state
*
YY_BUFFER_STATE
;
#
endif
#
ifndef
YY_TYPEDEF_YY_SIZE_T
#
define
YY_TYPEDEF_YY_SIZE_T
typedef
size_t
yy_size_t
;
#
endif
#
define
EOB_ACT_CONTINUE_SCAN
0
#
define
EOB_ACT_END_OF_FILE
1
#
define
EOB_ACT_LAST_MATCH
2
#
define
YY_LESS_LINENO
(
n
)
#
define
YY_LINENO_REWIND_TO
(
ptr
)
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
*
yy_cp
=
yyg
-
>
yy_hold_char
;
\
YY_RESTORE_YY_MORE_OFFSET
\
yyg
-
>
yy_c_buf_p
=
yy_cp
=
yy_bp
+
yyless_macro_arg
-
YY_MORE_ADJ
;
\
YY_DO_BEFORE_ACTION
;
/
*
set
up
yytext
again
*
/
\
}
\
while
(
0
)
#
define
unput
(
c
)
yyunput
(
c
yyg
-
>
yytext_ptr
yyscanner
)
#
ifndef
YY_STRUCT_YY_BUFFER_STATE
#
define
YY_STRUCT_YY_BUFFER_STATE
struct
yy_buffer_state
{
FILE
*
yy_input_file
;
char
*
yy_ch_buf
;
char
*
yy_buf_pos
;
int
yy_buf_size
;
int
yy_n_chars
;
int
yy_is_our_buffer
;
int
yy_is_interactive
;
int
yy_at_bol
;
int
yy_bs_lineno
;
int
yy_bs_column
;
int
yy_fill_buffer
;
int
yy_buffer_status
;
#
define
YY_BUFFER_NEW
0
#
define
YY_BUFFER_NORMAL
1
#
define
YY_BUFFER_EOF_PENDING
2
}
;
#
endif
#
define
YY_CURRENT_BUFFER
(
yyg
-
>
yy_buffer_stack
\
?
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
\
:
NULL
)
#
define
YY_CURRENT_BUFFER_LVALUE
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
void
yyrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
;
void
yy_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
yy_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
;
void
yy_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
yy_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
yypush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
void
yypop_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
yyensure_buffer_stack
(
yyscan_t
yyscanner
)
;
static
void
yy_load_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
yy_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
;
#
define
YY_FLUSH_BUFFER
yy_flush_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
YY_BUFFER_STATE
yy_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
yy_scan_string
(
const
char
*
yy_str
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
yy_scan_bytes
(
const
char
*
bytes
int
len
yyscan_t
yyscanner
)
;
void
*
yyalloc
(
yy_size_t
yyscan_t
yyscanner
)
;
void
*
yyrealloc
(
void
*
yy_size_t
yyscan_t
yyscanner
)
;
void
yyfree
(
void
*
yyscan_t
yyscanner
)
;
#
define
yy_new_buffer
yy_create_buffer
#
define
yy_set_interactive
(
is_interactive
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
yyensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
yy_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
=
is_interactive
;
\
}
#
define
yy_set_bol
(
at_bol
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
yyensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
yy_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
=
at_bol
;
\
}
#
define
YY_AT_BOL
(
)
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
)
#
define
glcpp_wrap
(
yyscanner
)
(
/
*
CONSTCOND
*
/
1
)
#
define
YY_SKIP_YYWRAP
typedef
flex_uint8_t
YY_CHAR
;
typedef
int
yy_state_type
;
#
define
yytext_ptr
yytext_r
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
;
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
current_state
yyscan_t
yyscanner
)
;
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
;
static
void
yynoreturn
yy_fatal_error
(
const
char
*
msg
yyscan_t
yyscanner
)
;
#
define
YY_DO_BEFORE_ACTION
\
yyg
-
>
yytext_ptr
=
yy_bp
;
\
yyleng
=
(
int
)
(
yy_cp
-
yy_bp
)
;
\
yyg
-
>
yy_hold_char
=
*
yy_cp
;
\
*
yy_cp
=
'
\
0
'
;
\
yyg
-
>
yy_c_buf_p
=
yy_cp
;
#
define
YY_NUM_RULES
54
#
define
YY_END_OF_BUFFER
55
struct
yy_trans_info
{
flex_int32_t
yy_verify
;
flex_int32_t
yy_nxt
;
}
;
static
const
flex_int16_t
yy_accept
[
189
]
=
{
0
0
0
3
3
0
0
0
0
0
0
0
0
0
0
55
49
50
52
52
48
49
8
48
48
48
48
48
48
32
31
48
48
48
46
46
48
3
4
4
5
30
28
53
27
53
25
24
14
14
25
25
25
25
25
25
25
25
49
52
39
0
49
49
44
40
42
43
47
2
1
47
32
47
32
47
31
31
34
36
38
37
35
46
46
41
3
4
4
4
5
6
6
5
7
30
28
29
1
26
27
24
14
0
0
0
0
0
0
0
0
0
0
0
51
1
33
33
46
4
6
29
1
0
0
0
0
0
0
17
0
0
0
0
0
0
0
33
46
0
0
19
0
0
0
0
0
0
0
0
0
0
46
0
18
20
21
0
15
0
0
13
0
23
0
46
22
21
0
16
0
11
0
45
22
0
0
11
11
10
0
0
0
9
11
0
0
12
0
}
;
static
const
YY_CHAR
yy_ec
[
256
]
=
{
0
1
1
1
1
1
1
1
1
2
3
2
2
4
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
5
6
7
8
1
9
10
1
11
9
12
13
9
14
15
16
17
18
18
18
18
18
18
18
19
19
20
9
21
22
23
20
1
24
24
24
24
25
24
26
26
26
26
26
26
26
26
26
27
26
26
26
26
28
26
26
29
26
26
9
1
9
9
26
1
30
24
31
32
33
34
35
26
36
26
26
37
38
39
40
41
26
42
43
44
45
46
26
47
26
26
9
48
9
9
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
}
;
static
const
YY_CHAR
yy_meta
[
49
]
=
{
0
1
2
3
3
4
5
1
6
5
5
7
8
5
5
9
5
10
10
10
5
6
5
6
10
10
10
10
10
10
10
10
11
10
10
10
10
10
10
11
10
10
10
10
10
10
10
10
5
}
;
static
const
flex_int16_t
yy_base
[
208
]
=
{
0
0
0
46
48
60
0
50
52
107
152
110
112
114
116
538
121
539
533
533
513
125
526
539
523
519
517
112
109
182
213
112
508
113
0
496
480
134
523
523
146
0
122
130
514
539
539
158
520
520
135
489
122
131
485
478
480
485
166
539
539
165
170
174
539
539
539
539
179
539
0
192
217
230
165
259
0
169
539
539
539
539
539
0
483
539
188
512
512
539
210
510
510
244
539
0
200
0
216
539
496
237
539
451
144
440
412
400
164
412
403
402
395
384
539
0
221
237
370
539
539
0
259
369
370
355
334
327
333
539
297
297
291
294
291
292
281
239
284
283
0
539
287
278
280
284
271
251
265
257
253
250
248
247
539
539
0
236
539
225
205
283
198
539
176
169
292
0
159
539
143
296
135
0
300
19
301
265
305
539
309
18
310
311
271
0
201
539
539
331
342
353
364
367
369
380
391
402
413
418
429
440
451
462
473
482
493
501
}
;
static
const
flex_int16_t
yy_def
[
208
]
=
{
0
188
1
189
189
188
5
190
190
191
191
190
190
190
190
188
188
188
188
188
188
192
188
188
188
188
188
188
188
193
193
188
188
188
194
194
188
195
188
188
196
197
188
198
199
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
192
188
192
188
188
188
188
193
188
200
193
30
193
73
73
30
73
188
188
188
188
188
194
194
188
195
188
188
188
196
188
188
196
188
197
188
201
202
188
199
188
188
188
188
188
188
188
203
188
188
188
188
188
188
200
75
75
194
188
188
201
202
188
188
188
188
188
188
188
188
188
188
188
188
188
188
73
194
188
204
188
188
188
188
188
188
188
188
188
188
188
194
188
188
188
205
188
188
188
188
188
188
188
188
194
188
205
188
188
188
206
188
194
188
188
188
206
206
188
188
188
188
188
206
207
207
188
0
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
}
;
static
const
flex_int16_t
yy_nxt
[
588
]
=
{
0
16
17
18
19
17
20
21
22
23
24
23
23
25
26
27
28
29
30
30
16
31
32
33
34
34
34
34
34
34
34
34
35
34
34
34
34
34
34
34
34
34
34
34
34
34
34
34
36
38
39
38
39
18
19
18
19
184
40
181
40
41
42
18
19
42
41
41
41
41
41
41
41
41
41
41
43
41
41
41
41
41
41
41
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
44
41
47
48
49
47
18
19
18
19
18
19
18
19
69
58
50
96
70
58
96
58
68
68
68
62
78
79
81
82
87
88
51
52
58
69
53
54
63
98
69
55
91
92
70
56
57
47
48
49
47
93
104
101
105
94
101
106
108
188
58
50
107
109
58
114
58
180
58
176
58
188
188
124
62
188
188
51
52
58
125
53
54
58
87
88
55
63
175
130
56
57
72
72
173
96
131
73
96
73
73
187
73
74
75
73
91
92
73
172
73
115
73
73
115
188
73
187
73
188
74
171
75
76
76
76
73
72
72
71
170
73
101
73
77
101
71
71
74
73
91
92
137
71
71
188
188
73
73
93
73
77
169
94
115
74
73
115
137
137
161
188
188
161
73
188
188
188
188
116
116
116
168
166
165
137
116
117
161
164
163
161
116
116
116
117
116
174
162
160
174
178
179
179
178
174
182
159
174
182
178
179
179
178
183
182
183
183
182
183
185
158
157
156
155
153
152
151
150
149
148
147
146
145
185
37
37
37
37
37
37
37
37
37
37
37
45
45
45
45
45
45
45
45
45
45
45
46
46
46
46
46
46
46
46
46
46
46
61
144
143
61
61
142
61
61
61
61
61
71
71
71
83
83
86
86
86
86
86
86
86
141
86
86
86
90
90
90
90
90
90
90
90
90
90
90
95
140
139
138
95
95
95
95
95
95
95
97
97
97
97
97
97
97
97
97
97
97
100
136
135
100
100
115
115
134
115
115
115
115
115
115
115
115
121
133
132
128
121
121
121
121
121
121
121
122
122
127
122
122
122
122
122
122
122
122
129
129
129
129
129
129
129
129
129
126
129
154
154
154
154
154
154
154
154
154
167
167
123
167
167
167
167
167
167
167
167
177
177
177
177
177
177
177
177
177
177
177
186
186
99
186
186
186
186
186
120
120
119
119
118
113
112
111
110
103
102
102
99
89
89
85
84
80
67
66
65
64
60
59
59
188
15
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
}
;
static
const
flex_int16_t
yy_chk
[
588
]
=
{
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
3
3
4
4
7
7
8
8
181
3
175
4
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
9
9
9
9
11
11
12
12
13
13
14
14
28
16
9
42
28
21
42
16
27
27
27
21
31
31
33
33
37
37
9
9
16
43
9
9
21
43
50
9
40
40
50
9
9
10
10
10
10
40
52
47
52
40
47
52
53
61
58
10
52
53
62
61
58
172
63
170
62
74
74
104
63
77
77
10
10
58
104
10
10
62
86
86
10
63
168
108
10
10
29
29
165
96
108
68
96
68
29
186
29
29
29
68
90
90
29
164
71
98
71
68
98
90
29
186
71
90
29
162
29
30
30
30
71
72
72
72
160
30
101
30
30
101
73
73
72
30
93
93
116
117
117
137
137
30
73
93
73
30
159
93
122
72
73
122
117
116
148
177
177
148
73
75
75
184
184
75
75
75
157
153
152
117
75
75
161
151
150
161
75
75
75
75
75
166
149
147
166
171
171
171
171
174
176
146
174
176
178
178
178
178
180
182
183
180
182
183
182
145
144
143
142
139
138
136
135
134
133
132
131
130
182
189
189
189
189
189
189
189
189
189
189
189
190
190
190
190
190
190
190
190
190
190
190
191
191
191
191
191
191
191
191
191
191
191
192
128
127
192
192
126
192
192
192
192
192
193
193
193
194
194
195
195
195
195
195
195
195
125
195
195
195
196
196
196
196
196
196
196
196
196
196
196
197
124
123
118
197
197
197
197
197
197
197
198
198
198
198
198
198
198
198
198
198
198
199
113
112
199
199
200
200
111
200
200
200
200
200
200
200
200
201
110
109
107
201
201
201
201
201
201
201
202
202
106
202
202
202
202
202
202
202
202
203
203
203
203
203
203
203
203
203
105
203
204
204
204
204
204
204
204
204
204
205
205
103
205
205
205
205
205
205
205
205
206
206
206
206
206
206
206
206
206
206
206
207
207
100
207
207
207
207
207
92
91
88
87
84
57
56
55
54
51
49
48
44
39
38
36
35
32
26
25
24
22
20
19
18
15
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
188
}
;
#
define
REJECT
reject_used_but_not_detected
#
define
yymore
(
)
yymore_used_but_not_detected
#
define
YY_MORE_ADJ
0
#
define
YY_RESTORE_YY_MORE_OFFSET
#
line
1
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
#
line
2
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
ctype
.
h
>
#
include
"
glcpp
.
h
"
#
include
"
glcpp
-
parse
.
h
"
int
glcpp_get_column
(
yyscan_t
yyscanner
)
;
void
glcpp_set_column
(
int
column_no
yyscan_t
yyscanner
)
;
#
ifdef
_MSC_VER
#
define
YY_NO_UNISTD_H
#
endif
#
define
YY_NO_INPUT
#
define
YY_USER_ACTION
\
do
{
\
if
(
parser
-
>
has_new_line_number
)
\
yylineno
=
parser
-
>
new_line_number
;
\
if
(
parser
-
>
has_new_source_number
)
\
yylloc
-
>
source
=
parser
-
>
new_source_number
;
\
yylloc
-
>
first_column
=
yycolumn
+
1
;
\
yylloc
-
>
first_line
=
yylloc
-
>
last_line
=
yylineno
;
\
yycolumn
+
=
yyleng
;
\
yylloc
-
>
last_column
=
yycolumn
+
1
;
\
parser
-
>
has_new_line_number
=
0
;
\
parser
-
>
has_new_source_number
=
0
;
\
}
while
(
0
)
;
#
define
YY_USER_INIT
\
do
{
\
yylineno
=
1
;
\
yycolumn
=
0
;
\
yylloc
-
>
source
=
0
;
\
}
while
(
0
)
#
define
RETURN_TOKEN_NEVER_SKIP
(
token
)
\
do
{
\
if
(
glcpp_lex_update_state_per_token
(
parser
token
)
)
\
return
token
;
\
}
while
(
0
)
#
define
RETURN_TOKEN
(
token
)
\
do
{
\
if
(
!
parser
-
>
skipping
)
{
\
RETURN_TOKEN_NEVER_SKIP
(
token
)
;
\
}
\
}
while
(
0
)
#
define
RETURN_STRING_TOKEN
(
token
)
\
do
{
\
if
(
!
parser
-
>
skipping
)
{
\
/
*
We
'
re
not
doing
linear_strdup
here
to
avoid
\
*
an
implicit
call
on
strlen
(
)
for
the
length
\
*
of
the
string
as
this
is
already
found
by
\
*
flex
and
stored
in
yyleng
*
/
\
void
*
mem_ctx
=
yyextra
-
>
linalloc
;
\
yylval
-
>
str
=
linear_alloc_child
(
mem_ctx
\
yyleng
+
1
)
;
\
memcpy
(
yylval
-
>
str
yytext
yyleng
+
1
)
;
\
RETURN_TOKEN_NEVER_SKIP
(
token
)
;
\
}
\
}
while
(
0
)
static
int
glcpp_lex_update_state_per_token
(
glcpp_parser_t
*
parser
int
token
)
{
if
(
token
!
=
NEWLINE
&
&
token
!
=
SPACE
&
&
token
!
=
HASH_TOKEN
&
&
!
parser
-
>
lexing_version_directive
)
{
glcpp_parser_resolve_implicit_version
(
parser
)
;
}
if
(
token
=
=
NEWLINE
)
{
parser
-
>
first_non_space_token_this_line
=
1
;
}
else
if
(
token
!
=
SPACE
)
{
parser
-
>
first_non_space_token_this_line
=
0
;
}
if
(
token
=
=
NEWLINE
)
{
parser
-
>
last_token_was_newline
=
1
;
}
else
{
parser
-
>
last_token_was_newline
=
0
;
}
if
(
token
=
=
SPACE
)
{
if
(
!
parser
-
>
last_token_was_space
)
{
parser
-
>
last_token_was_space
=
1
;
return
1
;
}
else
{
parser
-
>
last_token_was_space
=
1
;
return
0
;
}
}
else
{
parser
-
>
last_token_was_space
=
0
;
return
1
;
}
}
#
line
1015
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
c
"
#
line
178
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
#
line
1027
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
c
"
#
define
INITIAL
0
#
define
COMMENT
1
#
define
DEFINE
2
#
define
DONE
3
#
define
HASH
4
#
define
NEWLINE_CATCHUP
5
#
define
UNREACHABLE
6
#
define
YY_EXTRA_TYPE
glcpp_parser_t
*
struct
yyguts_t
{
YY_EXTRA_TYPE
yyextra_r
;
FILE
*
yyin_r
*
yyout_r
;
size_t
yy_buffer_stack_top
;
size_t
yy_buffer_stack_max
;
YY_BUFFER_STATE
*
yy_buffer_stack
;
char
yy_hold_char
;
int
yy_n_chars
;
int
yyleng_r
;
char
*
yy_c_buf_p
;
int
yy_init
;
int
yy_start
;
int
yy_did_buffer_switch_on_eof
;
int
yy_start_stack_ptr
;
int
yy_start_stack_depth
;
int
*
yy_start_stack
;
yy_state_type
yy_last_accepting_state
;
char
*
yy_last_accepting_cpos
;
int
yylineno_r
;
int
yy_flex_debug_r
;
char
*
yytext_r
;
int
yy_more_flag
;
int
yy_more_len
;
YYSTYPE
*
yylval_r
;
YYLTYPE
*
yylloc_r
;
}
;
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
;
#
define
yylval
yyg
-
>
yylval_r
#
define
yylloc
yyg
-
>
yylloc_r
int
yylex_init
(
yyscan_t
*
scanner
)
;
int
yylex_init_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
*
scanner
)
;
int
yylex_destroy
(
yyscan_t
yyscanner
)
;
int
yyget_debug
(
yyscan_t
yyscanner
)
;
void
yyset_debug
(
int
debug_flag
yyscan_t
yyscanner
)
;
YY_EXTRA_TYPE
yyget_extra
(
yyscan_t
yyscanner
)
;
void
yyset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
;
FILE
*
yyget_in
(
yyscan_t
yyscanner
)
;
void
yyset_in
(
FILE
*
_in_str
yyscan_t
yyscanner
)
;
FILE
*
yyget_out
(
yyscan_t
yyscanner
)
;
void
yyset_out
(
FILE
*
_out_str
yyscan_t
yyscanner
)
;
int
yyget_leng
(
yyscan_t
yyscanner
)
;
char
*
yyget_text
(
yyscan_t
yyscanner
)
;
int
yyget_lineno
(
yyscan_t
yyscanner
)
;
void
yyset_lineno
(
int
_line_number
yyscan_t
yyscanner
)
;
int
yyget_column
(
yyscan_t
yyscanner
)
;
void
yyset_column
(
int
_column_no
yyscan_t
yyscanner
)
;
YYSTYPE
*
yyget_lval
(
yyscan_t
yyscanner
)
;
void
yyset_lval
(
YYSTYPE
*
yylval_param
yyscan_t
yyscanner
)
;
YYLTYPE
*
yyget_lloc
(
yyscan_t
yyscanner
)
;
void
yyset_lloc
(
YYLTYPE
*
yylloc_param
yyscan_t
yyscanner
)
;
#
ifndef
YY_SKIP_YYWRAP
#
ifdef
__cplusplus
extern
"
C
"
int
yywrap
(
yyscan_t
yyscanner
)
;
#
else
extern
int
yywrap
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
#
ifndef
YY_NO_UNPUT
static
void
yyunput
(
int
c
char
*
buf_ptr
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
const
char
*
int
yyscan_t
yyscanner
)
;
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
const
char
*
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
;
#
else
static
int
input
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
static
void
yy_push_state
(
int
_new_state
yyscan_t
yyscanner
)
;
static
void
yy_pop_state
(
yyscan_t
yyscanner
)
;
static
int
yy_top_state
(
yyscan_t
yyscanner
)
;
#
ifndef
YY_READ_BUF_SIZE
#
ifdef
__ia64__
#
define
YY_READ_BUF_SIZE
16384
#
else
#
define
YY_READ_BUF_SIZE
8192
#
endif
#
endif
#
ifndef
ECHO
#
define
ECHO
do
{
if
(
fwrite
(
yytext
(
size_t
)
yyleng
1
yyout
)
)
{
}
}
while
(
0
)
#
endif
#
ifndef
YY_INPUT
#
define
YY_INPUT
(
buf
result
max_size
)
\
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
)
\
{
\
int
c
=
'
*
'
;
\
int
n
;
\
for
(
n
=
0
;
n
<
max_size
&
&
\
(
c
=
getc
(
yyin
)
)
!
=
EOF
&
&
c
!
=
'
\
n
'
;
+
+
n
)
\
buf
[
n
]
=
(
char
)
c
;
\
if
(
c
=
=
'
\
n
'
)
\
buf
[
n
+
+
]
=
(
char
)
c
;
\
if
(
c
=
=
EOF
&
&
ferror
(
yyin
)
)
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
result
=
n
;
\
}
\
else
\
{
\
errno
=
0
;
\
while
(
(
result
=
(
int
)
fread
(
buf
1
(
yy_size_t
)
max_size
yyin
)
)
=
=
0
&
&
ferror
(
yyin
)
)
\
{
\
if
(
errno
!
=
EINTR
)
\
{
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
break
;
\
}
\
errno
=
0
;
\
clearerr
(
yyin
)
;
\
}
\
}
\
\
#
endif
#
ifndef
yyterminate
#
define
yyterminate
(
)
return
YY_NULL
#
endif
#
ifndef
YY_START_STACK_INCR
#
define
YY_START_STACK_INCR
25
#
endif
#
ifndef
YY_FATAL_ERROR
#
define
YY_FATAL_ERROR
(
msg
)
yy_fatal_error
(
msg
yyscanner
)
#
endif
#
ifndef
YY_DECL
#
define
YY_DECL_IS_OURS
1
extern
int
yylex
\
(
YYSTYPE
*
yylval_param
YYLTYPE
*
yylloc_param
yyscan_t
yyscanner
)
;
#
define
YY_DECL
int
yylex
\
(
YYSTYPE
*
yylval_param
YYLTYPE
*
yylloc_param
yyscan_t
yyscanner
)
#
endif
#
ifndef
YY_USER_ACTION
#
define
YY_USER_ACTION
#
endif
#
ifndef
YY_BREAK
#
define
YY_BREAKbreak
;
#
endif
#
define
YY_RULE_SETUP
\
YY_USER_ACTION
YY_DECL
{
yy_state_type
yy_current_state
;
char
*
yy_cp
*
yy_bp
;
int
yy_act
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yylval
=
yylval_param
;
yylloc
=
yylloc_param
;
if
(
!
yyg
-
>
yy_init
)
{
yyg
-
>
yy_init
=
1
;
#
ifdef
YY_USER_INIT
YY_USER_INIT
;
#
endif
if
(
!
yyg
-
>
yy_start
)
yyg
-
>
yy_start
=
1
;
if
(
!
yyin
)
yyin
=
stdin
;
if
(
!
yyout
)
yyout
=
stdout
;
if
(
!
YY_CURRENT_BUFFER
)
{
yyensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
yy_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
yy_load_buffer_state
(
yyscanner
)
;
}
{
#
line
208
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
glcpp_parser_t
*
parser
=
yyextra
;
if
(
YY_START
=
=
NEWLINE_CATCHUP
)
{
if
(
parser
-
>
commented_newlines
)
parser
-
>
commented_newlines
-
-
;
if
(
parser
-
>
commented_newlines
=
=
0
)
BEGIN
INITIAL
;
RETURN_TOKEN_NEVER_SKIP
(
NEWLINE
)
;
}
if
(
parser
-
>
skip_stack
&
&
parser
-
>
skip_stack
-
>
type
!
=
SKIP_NO_SKIP
&
&
!
parser
-
>
lexing_directive
)
{
parser
-
>
skipping
=
1
;
}
else
{
parser
-
>
skipping
=
0
;
}
#
line
1374
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
c
"
while
(
1
)
{
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_bp
=
yy_cp
;
yy_current_state
=
yyg
-
>
yy_start
;
yy_match
:
do
{
YY_CHAR
yy_c
=
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
189
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
+
+
yy_cp
;
}
while
(
yy_current_state
!
=
188
)
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
yy_find_action
:
yy_act
=
yy_accept
[
yy_current_state
]
;
YY_DO_BEFORE_ACTION
;
do_action
:
switch
(
yy_act
)
{
case
0
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
case
1
:
YY_RULE_SETUP
#
line
268
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
}
YY_BREAK
case
2
:
YY_RULE_SETUP
#
line
272
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
yy_push_state
(
COMMENT
yyscanner
)
;
}
YY_BREAK
case
3
:
YY_RULE_SETUP
#
line
273
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
YY_BREAK
case
4
:
YY_RULE_SETUP
#
line
274
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
yylineno
+
+
;
yycolumn
=
0
;
parser
-
>
commented_newlines
+
+
;
}
YY_BREAK
case
5
:
YY_RULE_SETUP
#
line
275
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
YY_BREAK
case
6
:
YY_RULE_SETUP
#
line
276
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
yylineno
+
+
;
yycolumn
=
0
;
parser
-
>
commented_newlines
+
+
;
}
YY_BREAK
case
7
:
YY_RULE_SETUP
#
line
277
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
yy_pop_state
(
yyscanner
)
;
if
(
yyextra
-
>
space_tokens
&
&
YY_START
!
=
HASH
)
RETURN_TOKEN
(
SPACE
)
;
}
YY_BREAK
case
8
:
YY_RULE_SETUP
#
line
284
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
parser
-
>
first_non_space_token_this_line
)
{
BEGIN
HASH
;
yyextra
-
>
in_define
=
false
;
}
RETURN_TOKEN_NEVER_SKIP
(
HASH_TOKEN
)
;
}
YY_BREAK
case
9
:
YY_RULE_SETUP
#
line
300
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
yyextra
-
>
space_tokens
=
0
;
yyextra
-
>
lexing_version_directive
=
1
;
RETURN_STRING_TOKEN
(
VERSION_TOKEN
)
;
}
YY_BREAK
case
10
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_LINENO_REWIND_TO
(
yy_cp
-
1
)
;
yyg
-
>
yy_c_buf_p
=
yy_cp
-
=
1
;
YY_DO_BEFORE_ACTION
;
YY_RULE_SETUP
#
line
315
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
}
YY_BREAK
case
11
:
YY_RULE_SETUP
#
line
321
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
RETURN_STRING_TOKEN
(
PRAGMA
)
;
}
YY_BREAK
case
12
:
YY_RULE_SETUP
#
line
326
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
RETURN_STRING_TOKEN
(
INCLUDE
)
;
}
YY_BREAK
case
13
:
YY_RULE_SETUP
#
line
331
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
RETURN_TOKEN
(
LINE
)
;
}
YY_BREAK
case
14
:
YY_RULE_SETUP
#
line
336
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
yyextra
-
>
space_tokens
=
0
;
yylineno
+
+
;
yycolumn
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
NEWLINE
)
;
}
YY_BREAK
case
15
:
YY_RULE_SETUP
#
line
346
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
yyextra
-
>
in_define
)
{
BEGIN
INITIAL
;
yyextra
-
>
lexing_directive
=
1
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
IFDEF
)
;
}
}
YY_BREAK
case
16
:
YY_RULE_SETUP
#
line
355
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
yyextra
-
>
in_define
)
{
BEGIN
INITIAL
;
yyextra
-
>
lexing_directive
=
1
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
IFNDEF
)
;
}
}
YY_BREAK
case
17
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_LINENO_REWIND_TO
(
yy_bp
+
2
)
;
yyg
-
>
yy_c_buf_p
=
yy_cp
=
yy_bp
+
2
;
YY_DO_BEFORE_ACTION
;
YY_RULE_SETUP
#
line
364
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
yyextra
-
>
in_define
)
{
BEGIN
INITIAL
;
yyextra
-
>
lexing_directive
=
1
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
IF
)
;
}
}
YY_BREAK
case
18
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_LINENO_REWIND_TO
(
yy_bp
+
4
)
;
yyg
-
>
yy_c_buf_p
=
yy_cp
=
yy_bp
+
4
;
YY_DO_BEFORE_ACTION
;
YY_RULE_SETUP
#
line
373
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
yyextra
-
>
in_define
)
{
BEGIN
INITIAL
;
yyextra
-
>
lexing_directive
=
1
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
ELIF
)
;
}
}
YY_BREAK
case
19
:
YY_RULE_SETUP
#
line
382
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
yyextra
-
>
in_define
)
{
BEGIN
INITIAL
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
ELSE
)
;
}
}
YY_BREAK
case
20
:
YY_RULE_SETUP
#
line
390
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
yyextra
-
>
in_define
)
{
BEGIN
INITIAL
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
ENDIF
)
;
}
}
YY_BREAK
case
21
:
YY_RULE_SETUP
#
line
398
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
RETURN_STRING_TOKEN
(
ERROR_TOKEN
)
;
}
YY_BREAK
case
22
:
YY_RULE_SETUP
#
line
421
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
yyextra
-
>
in_define
=
true
;
if
(
!
parser
-
>
skipping
)
{
BEGIN
DEFINE
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN
(
DEFINE_TOKEN
)
;
}
}
YY_BREAK
case
23
:
YY_RULE_SETUP
#
line
430
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
yyextra
-
>
space_tokens
=
0
;
RETURN_TOKEN
(
UNDEF
)
;
}
YY_BREAK
case
24
:
YY_RULE_SETUP
#
line
436
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
}
YY_BREAK
case
25
:
YY_RULE_SETUP
#
line
443
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
parser
-
>
skipping
)
{
BEGIN
INITIAL
;
RETURN_TOKEN
(
GARBAGE
)
;
}
}
YY_BREAK
case
26
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yyg
-
>
yy_c_buf_p
=
yy_cp
-
=
1
;
YY_DO_BEFORE_ACTION
;
YY_RULE_SETUP
#
line
451
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
RETURN_STRING_TOKEN
(
FUNC_IDENTIFIER
)
;
}
YY_BREAK
case
27
:
YY_RULE_SETUP
#
line
457
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
RETURN_STRING_TOKEN
(
OBJ_IDENTIFIER
)
;
}
YY_BREAK
case
28
:
YY_RULE_SETUP
#
line
463
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
}
YY_BREAK
case
29
:
YY_RULE_SETUP
#
line
468
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
glcpp_error
(
yylloc
yyextra
"
#
define
followed
by
a
non
-
identifier
:
%
s
"
yytext
)
;
RETURN_STRING_TOKEN
(
INTEGER_STRING
)
;
}
YY_BREAK
case
30
:
YY_RULE_SETUP
#
line
476
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
BEGIN
INITIAL
;
glcpp_error
(
yylloc
yyextra
"
#
define
followed
by
a
non
-
identifier
:
%
s
"
yytext
)
;
RETURN_STRING_TOKEN
(
INTEGER_STRING
)
;
}
YY_BREAK
case
31
:
YY_RULE_SETUP
#
line
482
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
INTEGER_STRING
)
;
}
YY_BREAK
case
32
:
YY_RULE_SETUP
#
line
486
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
INTEGER_STRING
)
;
}
YY_BREAK
case
33
:
YY_RULE_SETUP
#
line
490
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
INTEGER_STRING
)
;
}
YY_BREAK
case
34
:
YY_RULE_SETUP
#
line
494
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
LEFT_SHIFT
)
;
}
YY_BREAK
case
35
:
YY_RULE_SETUP
#
line
498
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
RIGHT_SHIFT
)
;
}
YY_BREAK
case
36
:
YY_RULE_SETUP
#
line
502
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
LESS_OR_EQUAL
)
;
}
YY_BREAK
case
37
:
YY_RULE_SETUP
#
line
506
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
GREATER_OR_EQUAL
)
;
}
YY_BREAK
case
38
:
YY_RULE_SETUP
#
line
510
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
EQUAL
)
;
}
YY_BREAK
case
39
:
YY_RULE_SETUP
#
line
514
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
NOT_EQUAL
)
;
}
YY_BREAK
case
40
:
YY_RULE_SETUP
#
line
518
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
AND
)
;
}
YY_BREAK
case
41
:
YY_RULE_SETUP
#
line
522
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
OR
)
;
}
YY_BREAK
case
42
:
YY_RULE_SETUP
#
line
526
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
PLUS_PLUS
)
;
}
YY_BREAK
case
43
:
YY_RULE_SETUP
#
line
530
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
MINUS_MINUS
)
;
}
YY_BREAK
case
44
:
YY_RULE_SETUP
#
line
534
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
!
parser
-
>
skipping
)
{
if
(
parser
-
>
is_gles
)
glcpp_error
(
yylloc
yyextra
"
Token
pasting
(
#
#
)
is
illegal
in
GLES
"
)
;
RETURN_TOKEN
(
PASTE
)
;
}
}
YY_BREAK
case
45
:
YY_RULE_SETUP
#
line
542
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
DEFINED
)
;
}
YY_BREAK
case
46
:
YY_RULE_SETUP
#
line
546
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
IDENTIFIER
)
;
}
YY_BREAK
case
47
:
YY_RULE_SETUP
#
line
550
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
OTHER
)
;
}
YY_BREAK
case
48
:
YY_RULE_SETUP
#
line
554
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_TOKEN
(
yytext
[
0
]
)
;
}
YY_BREAK
case
49
:
YY_RULE_SETUP
#
line
558
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
OTHER
)
;
}
YY_BREAK
case
50
:
YY_RULE_SETUP
#
line
562
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
yyextra
-
>
space_tokens
)
{
RETURN_TOKEN
(
SPACE
)
;
}
}
YY_BREAK
case
51
:
YY_RULE_SETUP
#
line
568
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
RETURN_STRING_TOKEN
(
PATH
)
;
}
YY_BREAK
case
52
:
YY_RULE_SETUP
#
line
574
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
parser
-
>
commented_newlines
)
{
BEGIN
NEWLINE_CATCHUP
;
}
else
{
BEGIN
INITIAL
;
}
yyextra
-
>
space_tokens
=
1
;
yyextra
-
>
lexing_directive
=
0
;
yyextra
-
>
lexing_version_directive
=
0
;
yylineno
+
+
;
yycolumn
=
0
;
RETURN_TOKEN_NEVER_SKIP
(
NEWLINE
)
;
}
YY_BREAK
case
YY_STATE_EOF
(
INITIAL
)
:
case
YY_STATE_EOF
(
COMMENT
)
:
case
YY_STATE_EOF
(
DEFINE
)
:
case
YY_STATE_EOF
(
HASH
)
:
#
line
588
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
if
(
YY_START
=
=
COMMENT
)
glcpp_error
(
yylloc
yyextra
"
Unterminated
comment
"
)
;
BEGIN
DONE
;
yyextra
-
>
lexing_directive
=
0
;
yyextra
-
>
lexing_version_directive
=
0
;
if
(
!
parser
-
>
last_token_was_newline
)
RETURN_TOKEN
(
NEWLINE
)
;
}
YY_BREAK
case
53
:
YY_RULE_SETUP
#
line
603
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
{
glcpp_error
(
yylloc
yyextra
"
Internal
compiler
error
:
Unexpected
character
:
%
s
"
yytext
)
;
if
(
YY_START
=
=
UNREACHABLE
)
{
unput
(
'
.
'
)
;
yy_top_state
(
yyextra
)
;
}
}
YY_BREAK
case
54
:
YY_RULE_SETUP
#
line
616
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
YY_FATAL_ERROR
(
"
flex
scanner
jammed
"
)
;
YY_BREAK
#
line
1971
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
c
"
case
YY_STATE_EOF
(
DONE
)
:
case
YY_STATE_EOF
(
NEWLINE_CATCHUP
)
:
case
YY_STATE_EOF
(
UNREACHABLE
)
:
yyterminate
(
)
;
case
YY_END_OF_BUFFER
:
{
int
yy_amount_of_matched_text
=
(
int
)
(
yy_cp
-
yyg
-
>
yytext_ptr
)
-
1
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_RESTORE_YY_MORE_OFFSET
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_NEW
)
{
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
=
yyin
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_NORMAL
;
}
if
(
yyg
-
>
yy_c_buf_p
<
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
{
yy_state_type
yy_next_state
;
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_next_state
=
yy_try_NUL_trans
(
yy_current_state
yyscanner
)
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
if
(
yy_next_state
)
{
yy_cp
=
+
+
yyg
-
>
yy_c_buf_p
;
yy_current_state
=
yy_next_state
;
goto
yy_match
;
}
else
{
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
}
}
else
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_END_OF_FILE
:
{
yyg
-
>
yy_did_buffer_switch_on_eof
=
0
;
if
(
yywrap
(
yyscanner
)
)
{
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_act
=
YY_STATE_EOF
(
YY_START
)
;
goto
do_action
;
}
else
{
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
}
break
;
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_match
;
case
EOB_ACT_LAST_MATCH
:
yyg
-
>
yy_c_buf_p
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_find_action
;
}
break
;
}
default
:
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
no
action
found
"
)
;
}
}
}
}
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
char
*
dest
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
;
char
*
source
=
yyg
-
>
yytext_ptr
;
int
number_to_move
i
;
int
ret_val
;
if
(
yyg
-
>
yy_c_buf_p
>
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
)
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
end
of
buffer
missed
"
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_fill_buffer
=
=
0
)
{
if
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
YY_MORE_ADJ
=
=
1
)
{
return
EOB_ACT_END_OF_FILE
;
}
else
{
return
EOB_ACT_LAST_MATCH
;
}
}
number_to_move
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
1
)
;
for
(
i
=
0
;
i
<
number_to_move
;
+
+
i
)
*
(
dest
+
+
)
=
*
(
source
+
+
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_EOF_PENDING
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
0
;
else
{
int
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
while
(
num_to_read
<
=
0
)
{
YY_BUFFER_STATE
b
=
YY_CURRENT_BUFFER_LVALUE
;
int
yy_c_buf_p_offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
b
-
>
yy_ch_buf
)
;
if
(
b
-
>
yy_is_our_buffer
)
{
int
new_size
=
b
-
>
yy_buf_size
*
2
;
if
(
new_size
<
=
0
)
b
-
>
yy_buf_size
+
=
b
-
>
yy_buf_size
/
8
;
else
b
-
>
yy_buf_size
*
=
2
;
b
-
>
yy_ch_buf
=
(
char
*
)
yyrealloc
(
(
void
*
)
b
-
>
yy_ch_buf
(
yy_size_t
)
(
b
-
>
yy_buf_size
+
2
)
yyscanner
)
;
}
else
b
-
>
yy_ch_buf
=
NULL
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
fatal
error
-
scanner
input
buffer
overflow
"
)
;
yyg
-
>
yy_c_buf_p
=
&
b
-
>
yy_ch_buf
[
yy_c_buf_p_offset
]
;
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
}
if
(
num_to_read
>
YY_READ_BUF_SIZE
)
num_to_read
=
YY_READ_BUF_SIZE
;
YY_INPUT
(
(
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
)
yyg
-
>
yy_n_chars
num_to_read
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
yyg
-
>
yy_n_chars
=
=
0
)
{
if
(
number_to_move
=
=
YY_MORE_ADJ
)
{
ret_val
=
EOB_ACT_END_OF_FILE
;
yyrestart
(
yyin
yyscanner
)
;
}
else
{
ret_val
=
EOB_ACT_LAST_MATCH
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_EOF_PENDING
;
}
}
else
ret_val
=
EOB_ACT_CONTINUE_SCAN
;
if
(
(
yyg
-
>
yy_n_chars
+
number_to_move
)
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
)
{
int
new_size
=
yyg
-
>
yy_n_chars
+
number_to_move
+
(
yyg
-
>
yy_n_chars
>
>
1
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
=
(
char
*
)
yyrealloc
(
(
void
*
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
(
yy_size_t
)
new_size
yyscanner
)
;
if
(
!
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_get_next_buffer
(
)
"
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
=
(
int
)
(
new_size
-
2
)
;
}
yyg
-
>
yy_n_chars
+
=
number_to_move
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
=
YY_END_OF_BUFFER_CHAR
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
yyg
-
>
yytext_ptr
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
0
]
;
return
ret_val
;
}
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
{
yy_state_type
yy_current_state
;
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_current_state
=
yyg
-
>
yy_start
;
for
(
yy_cp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_cp
<
yyg
-
>
yy_c_buf_p
;
+
+
yy_cp
)
{
YY_CHAR
yy_c
=
(
*
yy_cp
?
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
:
1
)
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
189
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
}
return
yy_current_state
;
}
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
yy_current_state
yyscan_t
yyscanner
)
{
int
yy_is_jam
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
char
*
yy_cp
=
yyg
-
>
yy_c_buf_p
;
YY_CHAR
yy_c
=
1
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
189
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
yy_is_jam
=
(
yy_current_state
=
=
188
)
;
(
void
)
yyg
;
return
yy_is_jam
?
0
:
yy_current_state
;
}
#
ifndef
YY_NO_UNPUT
static
void
yyunput
(
int
c
char
*
yy_bp
yyscan_t
yyscanner
)
{
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
{
int
number_to_move
=
yyg
-
>
yy_n_chars
+
2
;
char
*
dest
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
+
2
]
;
char
*
source
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
;
while
(
source
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
*
-
-
dest
=
*
-
-
source
;
yy_cp
+
=
(
int
)
(
dest
-
source
)
;
yy_bp
+
=
(
int
)
(
dest
-
source
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
(
int
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
YY_FATAL_ERROR
(
"
flex
scanner
push
-
back
overflow
"
)
;
}
*
-
-
yy_cp
=
(
char
)
c
;
yyg
-
>
yytext_ptr
=
yy_bp
;
yyg
-
>
yy_hold_char
=
*
yy_cp
;
yyg
-
>
yy_c_buf_p
=
yy_cp
;
}
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
#
else
static
int
input
(
yyscan_t
yyscanner
)
#
endif
{
int
c
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
if
(
*
yyg
-
>
yy_c_buf_p
=
=
YY_END_OF_BUFFER_CHAR
)
{
if
(
yyg
-
>
yy_c_buf_p
<
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
else
{
int
offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
)
;
+
+
yyg
-
>
yy_c_buf_p
;
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_LAST_MATCH
:
yyrestart
(
yyin
yyscanner
)
;
case
EOB_ACT_END_OF_FILE
:
{
if
(
yywrap
(
yyscanner
)
)
return
0
;
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
#
ifdef
__cplusplus
return
yyinput
(
yyscanner
)
;
#
else
return
input
(
yyscanner
)
;
#
endif
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
offset
;
break
;
}
}
}
c
=
*
(
unsigned
char
*
)
yyg
-
>
yy_c_buf_p
;
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
yyg
-
>
yy_hold_char
=
*
+
+
yyg
-
>
yy_c_buf_p
;
return
c
;
}
#
endif
void
yyrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
{
yyensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
yy_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
yy_init_buffer
(
YY_CURRENT_BUFFER
input_file
yyscanner
)
;
yy_load_buffer_state
(
yyscanner
)
;
}
void
yy_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
=
=
new_buffer
)
return
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
yy_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
static
void
yy_load_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
yyg
-
>
yytext_ptr
=
yyg
-
>
yy_c_buf_p
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
;
yyin
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
;
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
}
YY_BUFFER_STATE
yy_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
b
=
(
YY_BUFFER_STATE
)
yyalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_create_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
size
;
b
-
>
yy_ch_buf
=
(
char
*
)
yyalloc
(
(
yy_size_t
)
(
b
-
>
yy_buf_size
+
2
)
yyscanner
)
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_create_buffer
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
yy_init_buffer
(
b
file
yyscanner
)
;
return
b
;
}
void
yy_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
YY_CURRENT_BUFFER_LVALUE
=
(
YY_BUFFER_STATE
)
0
;
if
(
b
-
>
yy_is_our_buffer
)
yyfree
(
(
void
*
)
b
-
>
yy_ch_buf
yyscanner
)
;
yyfree
(
(
void
*
)
b
yyscanner
)
;
}
static
void
yy_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
{
int
oerrno
=
errno
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_flush_buffer
(
b
yyscanner
)
;
b
-
>
yy_input_file
=
file
;
b
-
>
yy_fill_buffer
=
1
;
if
(
b
!
=
YY_CURRENT_BUFFER
)
{
b
-
>
yy_bs_lineno
=
1
;
b
-
>
yy_bs_column
=
0
;
}
b
-
>
yy_is_interactive
=
0
;
errno
=
oerrno
;
}
void
yy_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
b
-
>
yy_n_chars
=
0
;
b
-
>
yy_ch_buf
[
0
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_ch_buf
[
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_buf_pos
=
&
b
-
>
yy_ch_buf
[
0
]
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
yy_load_buffer_state
(
yyscanner
)
;
}
void
yypush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
new_buffer
=
=
NULL
)
return
;
yyensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
YY_CURRENT_BUFFER
)
yyg
-
>
yy_buffer_stack_top
+
+
;
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
yy_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
void
yypop_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
;
yy_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
if
(
yyg
-
>
yy_buffer_stack_top
>
0
)
-
-
yyg
-
>
yy_buffer_stack_top
;
if
(
YY_CURRENT_BUFFER
)
{
yy_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
}
static
void
yyensure_buffer_stack
(
yyscan_t
yyscanner
)
{
yy_size_t
num_to_alloc
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
yyg
-
>
yy_buffer_stack
)
{
num_to_alloc
=
1
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
yyalloc
(
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yyensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
0
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
yyg
-
>
yy_buffer_stack_top
=
0
;
return
;
}
if
(
yyg
-
>
yy_buffer_stack_top
>
=
(
yyg
-
>
yy_buffer_stack_max
)
-
1
)
{
yy_size_t
grow_size
=
8
;
num_to_alloc
=
yyg
-
>
yy_buffer_stack_max
+
grow_size
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
yyrealloc
(
yyg
-
>
yy_buffer_stack
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yyensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
+
yyg
-
>
yy_buffer_stack_max
0
grow_size
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
}
}
YY_BUFFER_STATE
yy_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
if
(
size
<
2
|
|
base
[
size
-
2
]
!
=
YY_END_OF_BUFFER_CHAR
|
|
base
[
size
-
1
]
!
=
YY_END_OF_BUFFER_CHAR
)
return
NULL
;
b
=
(
YY_BUFFER_STATE
)
yyalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_scan_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
(
int
)
(
size
-
2
)
;
b
-
>
yy_buf_pos
=
b
-
>
yy_ch_buf
=
base
;
b
-
>
yy_is_our_buffer
=
0
;
b
-
>
yy_input_file
=
NULL
;
b
-
>
yy_n_chars
=
b
-
>
yy_buf_size
;
b
-
>
yy_is_interactive
=
0
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_fill_buffer
=
0
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
yy_switch_to_buffer
(
b
yyscanner
)
;
return
b
;
}
YY_BUFFER_STATE
yy_scan_string
(
const
char
*
yystr
yyscan_t
yyscanner
)
{
return
yy_scan_bytes
(
yystr
(
int
)
strlen
(
yystr
)
yyscanner
)
;
}
YY_BUFFER_STATE
yy_scan_bytes
(
const
char
*
yybytes
int
_yybytes_len
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
char
*
buf
;
yy_size_t
n
;
int
i
;
n
=
(
yy_size_t
)
(
_yybytes_len
+
2
)
;
buf
=
(
char
*
)
yyalloc
(
n
yyscanner
)
;
if
(
!
buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_scan_bytes
(
)
"
)
;
for
(
i
=
0
;
i
<
_yybytes_len
;
+
+
i
)
buf
[
i
]
=
yybytes
[
i
]
;
buf
[
_yybytes_len
]
=
buf
[
_yybytes_len
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
=
yy_scan_buffer
(
buf
n
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
bad
buffer
in
yy_scan_bytes
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
return
b
;
}
static
void
yy_push_state
(
int
_new_state
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
yyg
-
>
yy_start_stack_ptr
>
=
yyg
-
>
yy_start_stack_depth
)
{
yy_size_t
new_size
;
yyg
-
>
yy_start_stack_depth
+
=
YY_START_STACK_INCR
;
new_size
=
(
yy_size_t
)
yyg
-
>
yy_start_stack_depth
*
sizeof
(
int
)
;
if
(
!
yyg
-
>
yy_start_stack
)
yyg
-
>
yy_start_stack
=
(
int
*
)
yyalloc
(
new_size
yyscanner
)
;
else
yyg
-
>
yy_start_stack
=
(
int
*
)
yyrealloc
(
(
void
*
)
yyg
-
>
yy_start_stack
new_size
yyscanner
)
;
if
(
!
yyg
-
>
yy_start_stack
)
YY_FATAL_ERROR
(
"
out
of
memory
expanding
start
-
condition
stack
"
)
;
}
yyg
-
>
yy_start_stack
[
yyg
-
>
yy_start_stack_ptr
+
+
]
=
YY_START
;
BEGIN
(
_new_state
)
;
}
static
void
yy_pop_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
-
-
yyg
-
>
yy_start_stack_ptr
<
0
)
YY_FATAL_ERROR
(
"
start
-
condition
stack
underflow
"
)
;
BEGIN
(
yyg
-
>
yy_start_stack
[
yyg
-
>
yy_start_stack_ptr
]
)
;
}
static
int
yy_top_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyg
-
>
yy_start_stack
[
yyg
-
>
yy_start_stack_ptr
-
1
]
;
}
#
ifndef
YY_EXIT_FAILURE
#
define
YY_EXIT_FAILURE
2
#
endif
static
void
yynoreturn
yy_fatal_error
(
const
char
*
msg
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
fprintf
(
stderr
"
%
s
\
n
"
msg
)
;
exit
(
YY_EXIT_FAILURE
)
;
}
#
undef
yyless
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
yytext
[
yyleng
]
=
yyg
-
>
yy_hold_char
;
\
yyg
-
>
yy_c_buf_p
=
yytext
+
yyless_macro_arg
;
\
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
\
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
\
yyleng
=
yyless_macro_arg
;
\
}
\
while
(
0
)
YY_EXTRA_TYPE
yyget_extra
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyextra
;
}
int
yyget_lineno
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yylineno
;
}
int
yyget_column
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yycolumn
;
}
FILE
*
yyget_in
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyin
;
}
FILE
*
yyget_out
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyout
;
}
int
yyget_leng
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyleng
;
}
char
*
yyget_text
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yytext
;
}
void
yyset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyextra
=
user_defined
;
}
void
yyset_lineno
(
int
_line_number
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
yyset_lineno
called
with
no
buffer
"
)
;
yylineno
=
_line_number
;
}
void
yyset_column
(
int
_column_no
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
yyset_column
called
with
no
buffer
"
)
;
yycolumn
=
_column_no
;
}
void
yyset_in
(
FILE
*
_in_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyin
=
_in_str
;
}
void
yyset_out
(
FILE
*
_out_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyout
=
_out_str
;
}
int
yyget_debug
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yy_flex_debug
;
}
void
yyset_debug
(
int
_bdebug
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_flex_debug
=
_bdebug
;
}
YYSTYPE
*
yyget_lval
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yylval
;
}
void
yyset_lval
(
YYSTYPE
*
yylval_param
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yylval
=
yylval_param
;
}
YYLTYPE
*
yyget_lloc
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yylloc
;
}
void
yyset_lloc
(
YYLTYPE
*
yylloc_param
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yylloc
=
yylloc_param
;
}
int
yylex_init
(
yyscan_t
*
ptr_yy_globals
)
{
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
yyalloc
(
sizeof
(
struct
yyguts_t
)
NULL
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
int
yylex_init_extra
(
YY_EXTRA_TYPE
yy_user_defined
yyscan_t
*
ptr_yy_globals
)
{
struct
yyguts_t
dummy_yyguts
;
yyset_extra
(
yy_user_defined
&
dummy_yyguts
)
;
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
yyalloc
(
sizeof
(
struct
yyguts_t
)
&
dummy_yyguts
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
yyset_extra
(
yy_user_defined
*
ptr_yy_globals
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_buffer_stack
=
NULL
;
yyg
-
>
yy_buffer_stack_top
=
0
;
yyg
-
>
yy_buffer_stack_max
=
0
;
yyg
-
>
yy_c_buf_p
=
NULL
;
yyg
-
>
yy_init
=
0
;
yyg
-
>
yy_start
=
0
;
yyg
-
>
yy_start_stack_ptr
=
0
;
yyg
-
>
yy_start_stack_depth
=
0
;
yyg
-
>
yy_start_stack
=
NULL
;
#
ifdef
YY_STDINIT
yyin
=
stdin
;
yyout
=
stdout
;
#
else
yyin
=
NULL
;
yyout
=
NULL
;
#
endif
return
0
;
}
int
yylex_destroy
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
while
(
YY_CURRENT_BUFFER
)
{
yy_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
yypop_buffer_state
(
yyscanner
)
;
}
yyfree
(
yyg
-
>
yy_buffer_stack
yyscanner
)
;
yyg
-
>
yy_buffer_stack
=
NULL
;
yyfree
(
yyg
-
>
yy_start_stack
yyscanner
)
;
yyg
-
>
yy_start_stack
=
NULL
;
yy_init_globals
(
yyscanner
)
;
yyfree
(
yyscanner
yyscanner
)
;
yyscanner
=
NULL
;
return
0
;
}
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
s1
const
char
*
s2
int
n
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
int
i
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
s1
[
i
]
=
s2
[
i
]
;
}
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
const
char
*
s
yyscan_t
yyscanner
)
{
int
n
;
for
(
n
=
0
;
s
[
n
]
;
+
+
n
)
;
return
n
;
}
#
endif
void
*
yyalloc
(
yy_size_t
size
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
return
malloc
(
size
)
;
}
void
*
yyrealloc
(
void
*
ptr
yy_size_t
size
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
return
realloc
(
ptr
size
)
;
}
void
yyfree
(
void
*
ptr
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
free
(
(
char
*
)
ptr
)
;
}
#
define
YYTABLES_NAME
"
yytables
"
#
line
616
"
src
/
compiler
/
glsl
/
glcpp
/
glcpp
-
lex
.
l
"
void
glcpp_lex_set_source_string
(
glcpp_parser_t
*
parser
const
char
*
shader
)
{
yy_scan_string
(
shader
parser
-
>
scanner
)
;
}
