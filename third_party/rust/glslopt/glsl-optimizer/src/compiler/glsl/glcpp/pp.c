#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
<
ctype
.
h
>
#
include
"
glcpp
.
h
"
#
include
"
main
/
mtypes
.
h
"
void
glcpp_error
(
YYLTYPE
*
locp
glcpp_parser_t
*
parser
const
char
*
fmt
.
.
.
)
{
va_list
ap
;
parser
-
>
error
=
1
;
_mesa_string_buffer_printf
(
parser
-
>
info_log
"
%
u
:
%
u
(
%
u
)
:
"
"
preprocessor
error
:
"
locp
-
>
source
locp
-
>
first_line
locp
-
>
first_column
)
;
va_start
(
ap
fmt
)
;
_mesa_string_buffer_vprintf
(
parser
-
>
info_log
fmt
ap
)
;
va_end
(
ap
)
;
_mesa_string_buffer_append_char
(
parser
-
>
info_log
'
\
n
'
)
;
}
void
glcpp_warning
(
YYLTYPE
*
locp
glcpp_parser_t
*
parser
const
char
*
fmt
.
.
.
)
{
va_list
ap
;
_mesa_string_buffer_printf
(
parser
-
>
info_log
"
%
u
:
%
u
(
%
u
)
:
"
"
preprocessor
warning
:
"
locp
-
>
source
locp
-
>
first_line
locp
-
>
first_column
)
;
va_start
(
ap
fmt
)
;
_mesa_string_buffer_vprintf
(
parser
-
>
info_log
fmt
ap
)
;
va_end
(
ap
)
;
_mesa_string_buffer_append_char
(
parser
-
>
info_log
'
\
n
'
)
;
}
static
const
char
*
skip_newline
(
const
char
*
str
)
{
const
char
*
ret
=
str
;
if
(
ret
=
=
NULL
)
return
ret
;
if
(
*
ret
=
=
'
\
0
'
)
return
ret
;
if
(
*
ret
=
=
'
\
r
'
)
{
ret
+
+
;
if
(
*
ret
&
&
*
ret
=
=
'
\
n
'
)
ret
+
+
;
}
else
if
(
*
ret
=
=
'
\
n
'
)
{
ret
+
+
;
if
(
*
ret
&
&
*
ret
=
=
'
\
r
'
)
ret
+
+
;
}
return
ret
;
}
#
define
INITIAL_PP_OUTPUT_BUF_SIZE
4048
static
char
*
remove_line_continuations
(
glcpp_parser_t
*
ctx
const
char
*
shader
)
{
struct
_mesa_string_buffer
*
sb
=
_mesa_string_buffer_create
(
ctx
INITIAL_PP_OUTPUT_BUF_SIZE
)
;
const
char
*
backslash
*
newline
*
search_start
;
const
char
*
cr
*
lf
;
char
newline_separator
[
3
]
;
int
collapsed_newlines
=
0
;
int
separator_len
;
backslash
=
strchr
(
shader
'
\
\
'
)
;
if
(
backslash
=
=
NULL
)
return
(
char
*
)
shader
;
search_start
=
shader
;
cr
=
strchr
(
search_start
'
\
r
'
)
;
lf
=
strchr
(
search_start
'
\
n
'
)
;
newline_separator
[
0
]
=
'
\
n
'
;
newline_separator
[
1
]
=
'
\
0
'
;
newline_separator
[
2
]
=
'
\
0
'
;
if
(
cr
=
=
NULL
)
{
}
else
if
(
lf
=
=
NULL
)
{
newline_separator
[
0
]
=
'
\
r
'
;
}
else
if
(
lf
=
=
cr
+
1
)
{
newline_separator
[
0
]
=
'
\
r
'
;
newline_separator
[
1
]
=
'
\
n
'
;
}
else
if
(
cr
=
=
lf
+
1
)
{
newline_separator
[
0
]
=
'
\
n
'
;
newline_separator
[
1
]
=
'
\
r
'
;
}
separator_len
=
strlen
(
newline_separator
)
;
while
(
true
)
{
if
(
collapsed_newlines
)
{
cr
=
strchr
(
search_start
'
\
r
'
)
;
lf
=
strchr
(
search_start
'
\
n
'
)
;
if
(
cr
&
&
lf
)
newline
=
cr
<
lf
?
cr
:
lf
;
else
if
(
cr
)
newline
=
cr
;
else
newline
=
lf
;
if
(
newline
&
&
(
backslash
=
=
NULL
|
|
newline
<
backslash
)
)
{
_mesa_string_buffer_append_len
(
sb
shader
newline
-
shader
+
1
)
;
while
(
collapsed_newlines
)
{
_mesa_string_buffer_append_len
(
sb
newline_separator
separator_len
)
;
collapsed_newlines
-
-
;
}
shader
=
skip_newline
(
newline
)
;
search_start
=
shader
;
}
}
search_start
=
backslash
+
1
;
if
(
backslash
=
=
NULL
)
break
;
if
(
backslash
[
1
]
=
=
'
\
r
'
|
|
backslash
[
1
]
=
=
'
\
n
'
)
{
collapsed_newlines
+
+
;
_mesa_string_buffer_append_len
(
sb
shader
backslash
-
shader
)
;
shader
=
skip_newline
(
backslash
+
1
)
;
search_start
=
shader
;
}
backslash
=
strchr
(
search_start
'
\
\
'
)
;
}
_mesa_string_buffer_append
(
sb
shader
)
;
return
sb
-
>
buf
;
}
int
glcpp_preprocess
(
void
*
ralloc_ctx
const
char
*
*
shader
char
*
*
info_log
glcpp_extension_iterator
extensions
void
*
state
struct
gl_context
*
gl_ctx
)
{
int
errors
;
glcpp_parser_t
*
parser
=
glcpp_parser_create
(
gl_ctx
extensions
state
)
;
if
(
!
gl_ctx
-
>
Const
.
DisableGLSLLineContinuations
)
*
shader
=
remove_line_continuations
(
parser
*
shader
)
;
glcpp_lex_set_source_string
(
parser
*
shader
)
;
glcpp_parser_parse
(
parser
)
;
if
(
parser
-
>
skip_stack
)
glcpp_error
(
&
parser
-
>
skip_stack
-
>
loc
parser
"
Unterminated
#
if
\
n
"
)
;
glcpp_parser_resolve_implicit_version
(
parser
)
;
ralloc_strcat
(
info_log
parser
-
>
info_log
-
>
buf
)
;
_mesa_string_buffer_crimp_to_fit
(
parser
-
>
output
)
;
ralloc_steal
(
ralloc_ctx
parser
-
>
output
-
>
buf
)
;
*
shader
=
parser
-
>
output
-
>
buf
;
errors
=
parser
-
>
error
;
glcpp_parser_destroy
(
parser
)
;
return
errors
;
}
