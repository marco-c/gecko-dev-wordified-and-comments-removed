#
include
"
ir
.
h
"
namespace
{
class
ir_if_simplification_visitor
:
public
ir_hierarchical_visitor
{
public
:
ir_if_simplification_visitor
(
)
{
this
-
>
made_progress
=
false
;
}
ir_visitor_status
visit_leave
(
ir_if
*
)
;
ir_visitor_status
visit_enter
(
ir_assignment
*
)
;
bool
made_progress
;
}
;
}
ir_visitor_status
ir_if_simplification_visitor
:
:
visit_enter
(
ir_assignment
*
ir
)
{
(
void
)
ir
;
return
visit_continue_with_parent
;
}
bool
do_if_simplification
(
exec_list
*
instructions
)
{
ir_if_simplification_visitor
v
;
v
.
run
(
instructions
)
;
return
v
.
made_progress
;
}
ir_visitor_status
ir_if_simplification_visitor
:
:
visit_leave
(
ir_if
*
ir
)
{
if
(
ir
-
>
then_instructions
.
is_empty
(
)
&
&
ir
-
>
else_instructions
.
is_empty
(
)
)
{
ir
-
>
remove
(
)
;
this
-
>
made_progress
=
true
;
return
visit_continue
;
}
ir_constant
*
condition_constant
=
ir
-
>
condition
-
>
constant_expression_value
(
ralloc_parent
(
ir
)
)
;
if
(
condition_constant
)
{
if
(
condition_constant
-
>
value
.
b
[
0
]
)
{
ir
-
>
insert_before
(
&
ir
-
>
then_instructions
)
;
}
else
{
ir
-
>
insert_before
(
&
ir
-
>
else_instructions
)
;
}
ir
-
>
remove
(
)
;
this
-
>
made_progress
=
true
;
return
visit_continue
;
}
if
(
ir
-
>
then_instructions
.
is_empty
(
)
)
{
ir
-
>
condition
=
new
(
ralloc_parent
(
ir
-
>
condition
)
)
ir_expression
(
ir_unop_logic_not
ir
-
>
condition
)
;
ir
-
>
else_instructions
.
move_nodes_to
(
&
ir
-
>
then_instructions
)
;
this
-
>
made_progress
=
true
;
}
return
visit_continue
;
}
