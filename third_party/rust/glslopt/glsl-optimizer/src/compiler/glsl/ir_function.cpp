#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
ir
.
h
"
#
include
"
glsl_parser_extras
.
h
"
#
include
"
main
/
errors
.
h
"
typedef
enum
{
PARAMETER_LIST_NO_MATCH
PARAMETER_LIST_EXACT_MATCH
PARAMETER_LIST_INEXACT_MATCH
}
parameter_list_match_t
;
static
parameter_list_match_t
parameter_lists_match
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
list_a
const
exec_list
*
list_b
)
{
const
exec_node
*
node_a
=
list_a
-
>
get_head_raw
(
)
;
const
exec_node
*
node_b
=
list_b
-
>
get_head_raw
(
)
;
bool
inexact_match
=
false
;
for
(
;
!
node_a
-
>
is_tail_sentinel
(
)
;
node_a
=
node_a
-
>
next
node_b
=
node_b
-
>
next
)
{
if
(
node_b
-
>
is_tail_sentinel
(
)
)
return
PARAMETER_LIST_NO_MATCH
;
const
ir_variable
*
const
param
=
(
ir_variable
*
)
node_a
;
const
ir_rvalue
*
const
actual
=
(
ir_rvalue
*
)
node_b
;
if
(
param
-
>
type
=
=
actual
-
>
type
)
continue
;
inexact_match
=
true
;
switch
(
(
enum
ir_variable_mode
)
(
param
-
>
data
.
mode
)
)
{
case
ir_var_auto
:
case
ir_var_uniform
:
case
ir_var_shader_storage
:
case
ir_var_temporary
:
assert
(
0
)
;
return
PARAMETER_LIST_NO_MATCH
;
case
ir_var_const_in
:
case
ir_var_function_in
:
if
(
!
actual
-
>
type
-
>
can_implicitly_convert_to
(
param
-
>
type
state
)
)
return
PARAMETER_LIST_NO_MATCH
;
break
;
case
ir_var_function_out
:
if
(
!
param
-
>
type
-
>
can_implicitly_convert_to
(
actual
-
>
type
state
)
)
return
PARAMETER_LIST_NO_MATCH
;
break
;
case
ir_var_function_inout
:
return
PARAMETER_LIST_NO_MATCH
;
default
:
assert
(
false
)
;
return
PARAMETER_LIST_NO_MATCH
;
}
}
if
(
!
node_b
-
>
is_tail_sentinel
(
)
)
return
PARAMETER_LIST_NO_MATCH
;
if
(
inexact_match
)
return
PARAMETER_LIST_INEXACT_MATCH
;
else
return
PARAMETER_LIST_EXACT_MATCH
;
}
typedef
enum
{
PARAMETER_EXACT_MATCH
PARAMETER_FLOAT_TO_DOUBLE
PARAMETER_INT_TO_FLOAT
PARAMETER_INT_TO_DOUBLE
PARAMETER_OTHER_CONVERSION
}
parameter_match_t
;
static
parameter_match_t
get_parameter_match_type
(
const
ir_variable
*
param
const
ir_rvalue
*
actual
)
{
const
glsl_type
*
from_type
;
const
glsl_type
*
to_type
;
if
(
param
-
>
data
.
mode
=
=
ir_var_function_out
)
{
from_type
=
param
-
>
type
;
to_type
=
actual
-
>
type
;
}
else
{
from_type
=
actual
-
>
type
;
to_type
=
param
-
>
type
;
}
if
(
from_type
=
=
to_type
)
return
PARAMETER_EXACT_MATCH
;
if
(
to_type
-
>
is_double
(
)
)
{
if
(
from_type
-
>
is_float
(
)
)
return
PARAMETER_FLOAT_TO_DOUBLE
;
return
PARAMETER_INT_TO_DOUBLE
;
}
if
(
to_type
-
>
is_float
(
)
)
return
PARAMETER_INT_TO_FLOAT
;
return
PARAMETER_OTHER_CONVERSION
;
}
static
bool
is_better_parameter_match
(
parameter_match_t
a_match
parameter_match_t
b_match
)
{
if
(
a_match
>
=
PARAMETER_INT_TO_FLOAT
&
&
b_match
=
=
PARAMETER_OTHER_CONVERSION
)
return
false
;
return
a_match
<
b_match
;
}
static
bool
is_best_inexact_overload
(
const
exec_list
*
actual_parameters
ir_function_signature
*
*
matches
int
num_matches
ir_function_signature
*
sig
)
{
for
(
ir_function_signature
*
*
other
=
matches
;
other
<
matches
+
num_matches
;
other
+
+
)
{
if
(
*
other
=
=
sig
)
continue
;
const
exec_node
*
node_a
=
sig
-
>
parameters
.
get_head_raw
(
)
;
const
exec_node
*
node_b
=
(
*
other
)
-
>
parameters
.
get_head_raw
(
)
;
const
exec_node
*
node_p
=
actual_parameters
-
>
get_head_raw
(
)
;
bool
better_for_some_parameter
=
false
;
for
(
;
!
node_a
-
>
is_tail_sentinel
(
)
;
node_a
=
node_a
-
>
next
node_b
=
node_b
-
>
next
node_p
=
node_p
-
>
next
)
{
parameter_match_t
a_match
=
get_parameter_match_type
(
(
const
ir_variable
*
)
node_a
(
const
ir_rvalue
*
)
node_p
)
;
parameter_match_t
b_match
=
get_parameter_match_type
(
(
const
ir_variable
*
)
node_b
(
const
ir_rvalue
*
)
node_p
)
;
if
(
is_better_parameter_match
(
a_match
b_match
)
)
better_for_some_parameter
=
true
;
if
(
is_better_parameter_match
(
b_match
a_match
)
)
return
false
;
}
if
(
!
better_for_some_parameter
)
return
false
;
}
return
true
;
}
static
ir_function_signature
*
choose_best_inexact_overload
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_parameters
ir_function_signature
*
*
matches
int
num_matches
)
{
if
(
num_matches
=
=
0
)
return
NULL
;
if
(
num_matches
=
=
1
)
return
*
matches
;
if
(
!
state
|
|
state
-
>
is_version
(
400
0
)
|
|
state
-
>
ARB_gpu_shader5_enable
|
|
state
-
>
MESA_shader_integer_functions_enable
|
|
state
-
>
EXT_shader_implicit_conversions_enable
)
{
for
(
ir_function_signature
*
*
sig
=
matches
;
sig
<
matches
+
num_matches
;
sig
+
+
)
{
if
(
is_best_inexact_overload
(
actual_parameters
matches
num_matches
*
sig
)
)
return
*
sig
;
}
}
return
NULL
;
}
ir_function_signature
*
ir_function
:
:
matching_signature
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_parameters
bool
allow_builtins
)
{
bool
is_exact
;
return
matching_signature
(
state
actual_parameters
allow_builtins
&
is_exact
)
;
}
ir_function_signature
*
ir_function
:
:
matching_signature
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_parameters
bool
allow_builtins
bool
*
is_exact
)
{
ir_function_signature
*
*
inexact_matches
=
NULL
;
ir_function_signature
*
*
inexact_matches_temp
;
ir_function_signature
*
match
=
NULL
;
int
num_inexact_matches
=
0
;
foreach_in_list
(
ir_function_signature
sig
&
this
-
>
signatures
)
{
if
(
sig
-
>
is_builtin
(
)
&
&
(
!
allow_builtins
|
|
!
sig
-
>
is_builtin_available
(
state
)
)
)
continue
;
switch
(
parameter_lists_match
(
state
&
sig
-
>
parameters
actual_parameters
)
)
{
case
PARAMETER_LIST_EXACT_MATCH
:
*
is_exact
=
true
;
free
(
inexact_matches
)
;
return
sig
;
case
PARAMETER_LIST_INEXACT_MATCH
:
inexact_matches_temp
=
(
ir_function_signature
*
*
)
realloc
(
inexact_matches
sizeof
(
*
inexact_matches
)
*
(
num_inexact_matches
+
1
)
)
;
if
(
inexact_matches_temp
=
=
NULL
)
{
_mesa_error_no_memory
(
__func__
)
;
free
(
inexact_matches
)
;
return
NULL
;
}
inexact_matches
=
inexact_matches_temp
;
inexact_matches
[
num_inexact_matches
+
+
]
=
sig
;
continue
;
case
PARAMETER_LIST_NO_MATCH
:
continue
;
default
:
assert
(
false
)
;
return
NULL
;
}
}
*
is_exact
=
false
;
match
=
choose_best_inexact_overload
(
state
actual_parameters
inexact_matches
num_inexact_matches
)
;
free
(
inexact_matches
)
;
return
match
;
}
static
bool
parameter_lists_match_exact
(
const
exec_list
*
list_a
const
exec_list
*
list_b
)
{
const
exec_node
*
node_a
=
list_a
-
>
get_head_raw
(
)
;
const
exec_node
*
node_b
=
list_b
-
>
get_head_raw
(
)
;
for
(
;
!
node_a
-
>
is_tail_sentinel
(
)
&
&
!
node_b
-
>
is_tail_sentinel
(
)
;
node_a
=
node_a
-
>
next
node_b
=
node_b
-
>
next
)
{
ir_variable
*
a
=
(
ir_variable
*
)
node_a
;
ir_variable
*
b
=
(
ir_variable
*
)
node_b
;
if
(
a
-
>
type
!
=
b
-
>
type
)
return
false
;
}
return
(
node_a
-
>
is_tail_sentinel
(
)
=
=
node_b
-
>
is_tail_sentinel
(
)
)
;
}
ir_function_signature
*
ir_function
:
:
exact_matching_signature
(
_mesa_glsl_parse_state
*
state
const
exec_list
*
actual_parameters
)
{
foreach_in_list
(
ir_function_signature
sig
&
this
-
>
signatures
)
{
if
(
sig
-
>
is_builtin
(
)
&
&
!
sig
-
>
is_builtin_available
(
state
)
)
continue
;
if
(
parameter_lists_match_exact
(
&
sig
-
>
parameters
actual_parameters
)
)
return
sig
;
}
return
NULL
;
}
