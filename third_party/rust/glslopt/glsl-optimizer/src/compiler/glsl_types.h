#
ifndef
GLSL_TYPES_H
#
define
GLSL_TYPES_H
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
include
"
shader_enums
.
h
"
#
include
"
c11
/
threads
.
h
"
#
include
"
util
/
blob
.
h
"
#
include
"
util
/
macros
.
h
"
#
ifdef
__cplusplus
#
include
"
main
/
config
.
h
"
#
endif
struct
glsl_type
;
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
struct
_mesa_glsl_parse_state
;
struct
glsl_symbol_table
;
extern
void
glsl_type_singleton_init_or_ref
(
)
;
extern
void
glsl_type_singleton_decref
(
)
;
extern
void
_mesa_glsl_initialize_types
(
struct
_mesa_glsl_parse_state
*
state
)
;
void
encode_type_to_blob
(
struct
blob
*
blob
const
struct
glsl_type
*
type
)
;
const
struct
glsl_type
*
decode_type_from_blob
(
struct
blob_reader
*
blob
)
;
#
ifdef
__cplusplus
}
#
endif
typedef
void
(
*
glsl_type_size_align_func
)
(
const
struct
glsl_type
*
type
unsigned
*
size
unsigned
*
align
)
;
enum
glsl_base_type
{
GLSL_TYPE_UINT
=
0
GLSL_TYPE_INT
GLSL_TYPE_FLOAT
GLSL_TYPE_FLOAT16
GLSL_TYPE_DOUBLE
GLSL_TYPE_UINT8
GLSL_TYPE_INT8
GLSL_TYPE_UINT16
GLSL_TYPE_INT16
GLSL_TYPE_UINT64
GLSL_TYPE_INT64
GLSL_TYPE_BOOL
GLSL_TYPE_SAMPLER
GLSL_TYPE_IMAGE
GLSL_TYPE_ATOMIC_UINT
GLSL_TYPE_STRUCT
GLSL_TYPE_INTERFACE
GLSL_TYPE_ARRAY
GLSL_TYPE_VOID
GLSL_TYPE_SUBROUTINE
GLSL_TYPE_FUNCTION
GLSL_TYPE_ERROR
}
;
static
unsigned
glsl_base_type_bit_size
(
enum
glsl_base_type
type
)
{
switch
(
type
)
{
case
GLSL_TYPE_BOOL
:
case
GLSL_TYPE_INT
:
case
GLSL_TYPE_UINT
:
case
GLSL_TYPE_FLOAT
:
case
GLSL_TYPE_SUBROUTINE
:
return
32
;
case
GLSL_TYPE_FLOAT16
:
case
GLSL_TYPE_UINT16
:
case
GLSL_TYPE_INT16
:
return
16
;
case
GLSL_TYPE_UINT8
:
case
GLSL_TYPE_INT8
:
return
8
;
case
GLSL_TYPE_DOUBLE
:
case
GLSL_TYPE_INT64
:
case
GLSL_TYPE_UINT64
:
case
GLSL_TYPE_IMAGE
:
case
GLSL_TYPE_SAMPLER
:
return
64
;
default
:
return
0
;
}
return
0
;
}
static
inline
bool
glsl_base_type_is_16bit
(
enum
glsl_base_type
type
)
{
return
glsl_base_type_bit_size
(
type
)
=
=
16
;
}
static
inline
bool
glsl_base_type_is_64bit
(
enum
glsl_base_type
type
)
{
return
glsl_base_type_bit_size
(
type
)
=
=
64
;
}
static
inline
bool
glsl_base_type_is_integer
(
enum
glsl_base_type
type
)
{
return
type
=
=
GLSL_TYPE_UINT8
|
|
type
=
=
GLSL_TYPE_INT8
|
|
type
=
=
GLSL_TYPE_UINT16
|
|
type
=
=
GLSL_TYPE_INT16
|
|
type
=
=
GLSL_TYPE_UINT
|
|
type
=
=
GLSL_TYPE_INT
|
|
type
=
=
GLSL_TYPE_UINT64
|
|
type
=
=
GLSL_TYPE_INT64
|
|
type
=
=
GLSL_TYPE_BOOL
|
|
type
=
=
GLSL_TYPE_SAMPLER
|
|
type
=
=
GLSL_TYPE_IMAGE
;
}
static
inline
unsigned
int
glsl_base_type_get_bit_size
(
const
enum
glsl_base_type
base_type
)
{
switch
(
base_type
)
{
case
GLSL_TYPE_BOOL
:
return
1
;
case
GLSL_TYPE_INT
:
case
GLSL_TYPE_UINT
:
case
GLSL_TYPE_FLOAT
:
case
GLSL_TYPE_SUBROUTINE
:
return
32
;
case
GLSL_TYPE_FLOAT16
:
case
GLSL_TYPE_UINT16
:
case
GLSL_TYPE_INT16
:
return
16
;
case
GLSL_TYPE_UINT8
:
case
GLSL_TYPE_INT8
:
return
8
;
case
GLSL_TYPE_DOUBLE
:
case
GLSL_TYPE_INT64
:
case
GLSL_TYPE_UINT64
:
case
GLSL_TYPE_IMAGE
:
case
GLSL_TYPE_SAMPLER
:
return
64
;
default
:
unreachable
(
"
unknown
base
type
"
)
;
}
return
0
;
}
static
inline
enum
glsl_base_type
glsl_unsigned_base_type_of
(
enum
glsl_base_type
type
)
{
switch
(
type
)
{
case
GLSL_TYPE_INT
:
return
GLSL_TYPE_UINT
;
case
GLSL_TYPE_INT8
:
return
GLSL_TYPE_UINT8
;
case
GLSL_TYPE_INT16
:
return
GLSL_TYPE_UINT16
;
case
GLSL_TYPE_INT64
:
return
GLSL_TYPE_UINT64
;
default
:
assert
(
type
=
=
GLSL_TYPE_UINT
|
|
type
=
=
GLSL_TYPE_UINT8
|
|
type
=
=
GLSL_TYPE_UINT16
|
|
type
=
=
GLSL_TYPE_UINT64
)
;
return
type
;
}
}
enum
glsl_sampler_dim
{
GLSL_SAMPLER_DIM_1D
=
0
GLSL_SAMPLER_DIM_2D
GLSL_SAMPLER_DIM_3D
GLSL_SAMPLER_DIM_CUBE
GLSL_SAMPLER_DIM_RECT
GLSL_SAMPLER_DIM_BUF
GLSL_SAMPLER_DIM_EXTERNAL
GLSL_SAMPLER_DIM_MS
GLSL_SAMPLER_DIM_SUBPASS
GLSL_SAMPLER_DIM_SUBPASS_MS
}
;
enum
glsl_matrix_layout
{
GLSL_MATRIX_LAYOUT_INHERITED
GLSL_MATRIX_LAYOUT_COLUMN_MAJOR
GLSL_MATRIX_LAYOUT_ROW_MAJOR
}
;
enum
{
GLSL_PRECISION_NONE
=
0
GLSL_PRECISION_HIGH
GLSL_PRECISION_MEDIUM
GLSL_PRECISION_LOW
}
;
#
ifdef
__cplusplus
#
include
"
GL
/
gl
.
h
"
#
include
"
util
/
ralloc
.
h
"
#
include
"
main
/
menums
.
h
"
struct
glsl_type
{
GLenum
gl_type
;
glsl_base_type
base_type
:
8
;
glsl_base_type
sampled_type
:
8
;
unsigned
sampler_dimensionality
:
4
;
unsigned
sampler_shadow
:
1
;
unsigned
sampler_array
:
1
;
unsigned
interface_packing
:
2
;
unsigned
interface_row_major
:
1
;
unsigned
packed
:
1
;
private
:
glsl_type
(
)
:
mem_ctx
(
NULL
)
{
}
public
:
uint8_t
vector_elements
;
uint8_t
matrix_columns
;
unsigned
length
;
const
char
*
name
;
unsigned
explicit_stride
;
union
{
const
struct
glsl_type
*
array
;
struct
glsl_function_param
*
parameters
;
struct
glsl_struct_field
*
structure
;
}
fields
;
#
undef
DECL_TYPE
#
define
DECL_TYPE
(
NAME
.
.
.
)
\
static
const
glsl_type
*
const
NAME
#
#
_type
;
#
undef
STRUCT_TYPE
#
define
STRUCT_TYPE
(
NAME
)
\
static
const
glsl_type
*
const
struct_
#
#
NAME
#
#
_type
;
#
include
"
compiler
/
builtin_type_macros
.
h
"
static
const
glsl_type
*
vec
(
unsigned
components
const
glsl_type
*
const
ts
[
]
)
;
static
const
glsl_type
*
vec
(
unsigned
components
)
;
static
const
glsl_type
*
f16vec
(
unsigned
components
)
;
static
const
glsl_type
*
dvec
(
unsigned
components
)
;
static
const
glsl_type
*
ivec
(
unsigned
components
)
;
static
const
glsl_type
*
uvec
(
unsigned
components
)
;
static
const
glsl_type
*
bvec
(
unsigned
components
)
;
static
const
glsl_type
*
i64vec
(
unsigned
components
)
;
static
const
glsl_type
*
u64vec
(
unsigned
components
)
;
static
const
glsl_type
*
i16vec
(
unsigned
components
)
;
static
const
glsl_type
*
u16vec
(
unsigned
components
)
;
static
const
glsl_type
*
i8vec
(
unsigned
components
)
;
static
const
glsl_type
*
u8vec
(
unsigned
components
)
;
const
glsl_type
*
get_base_type
(
)
const
;
const
glsl_type
*
get_scalar_type
(
)
const
;
const
glsl_type
*
get_bare_type
(
)
const
;
static
const
glsl_type
*
get_instance
(
unsigned
base_type
unsigned
rows
unsigned
columns
unsigned
explicit_stride
=
0
bool
row_major
=
false
)
;
static
const
glsl_type
*
get_sampler_instance
(
enum
glsl_sampler_dim
dim
bool
shadow
bool
array
glsl_base_type
type
)
;
static
const
glsl_type
*
get_image_instance
(
enum
glsl_sampler_dim
dim
bool
array
glsl_base_type
type
)
;
static
const
glsl_type
*
get_array_instance
(
const
glsl_type
*
base
unsigned
elements
unsigned
explicit_stride
=
0
)
;
static
const
glsl_type
*
get_struct_instance
(
const
glsl_struct_field
*
fields
unsigned
num_fields
const
char
*
name
bool
packed
=
false
)
;
static
const
glsl_type
*
get_interface_instance
(
const
glsl_struct_field
*
fields
unsigned
num_fields
enum
glsl_interface_packing
packing
bool
row_major
const
char
*
block_name
)
;
static
const
glsl_type
*
get_subroutine_instance
(
const
char
*
subroutine_name
)
;
static
const
glsl_type
*
get_function_instance
(
const
struct
glsl_type
*
return_type
const
glsl_function_param
*
parameters
unsigned
num_params
)
;
static
const
glsl_type
*
get_mul_type
(
const
glsl_type
*
type_a
const
glsl_type
*
type_b
)
;
unsigned
components
(
)
const
{
return
vector_elements
*
matrix_columns
;
}
unsigned
component_slots
(
)
const
;
unsigned
struct_location_offset
(
unsigned
length
)
const
;
unsigned
uniform_locations
(
)
const
;
unsigned
varying_count
(
)
const
;
unsigned
count_vec4_slots
(
bool
is_gl_vertex_input
bool
bindless
)
const
;
unsigned
count_dword_slots
(
bool
bindless
)
const
;
unsigned
count_attribute_slots
(
bool
is_gl_vertex_input
)
const
{
return
count_vec4_slots
(
is_gl_vertex_input
true
)
;
}
unsigned
std140_base_alignment
(
bool
row_major
)
const
;
unsigned
std140_size
(
bool
row_major
)
const
;
const
glsl_type
*
get_explicit_std140_type
(
bool
row_major
)
const
;
unsigned
std430_base_alignment
(
bool
row_major
)
const
;
unsigned
std430_array_stride
(
bool
row_major
)
const
;
unsigned
std430_size
(
bool
row_major
)
const
;
const
glsl_type
*
get_explicit_std430_type
(
bool
row_major
)
const
;
const
glsl_type
*
get_explicit_interface_type
(
bool
supports_std430
)
const
;
const
glsl_type
*
get_explicit_type_for_size_align
(
glsl_type_size_align_func
type_info
unsigned
*
size
unsigned
*
align
)
const
;
unsigned
cl_alignment
(
)
const
;
unsigned
cl_size
(
)
const
;
unsigned
explicit_size
(
bool
align_to_stride
=
false
)
const
;
bool
can_implicitly_convert_to
(
const
glsl_type
*
desired
_mesa_glsl_parse_state
*
state
)
const
;
bool
is_scalar
(
)
const
{
return
(
vector_elements
=
=
1
)
&
&
(
base_type
>
=
GLSL_TYPE_UINT
)
&
&
(
base_type
<
=
GLSL_TYPE_IMAGE
)
;
}
bool
is_vector
(
)
const
{
return
(
vector_elements
>
1
)
&
&
(
matrix_columns
=
=
1
)
&
&
(
base_type
>
=
GLSL_TYPE_UINT
)
&
&
(
base_type
<
=
GLSL_TYPE_BOOL
)
;
}
bool
is_matrix
(
)
const
{
return
(
matrix_columns
>
1
)
&
&
(
base_type
=
=
GLSL_TYPE_FLOAT
|
|
base_type
=
=
GLSL_TYPE_DOUBLE
|
|
base_type
=
=
GLSL_TYPE_FLOAT16
)
;
}
bool
is_numeric
(
)
const
{
return
(
base_type
>
=
GLSL_TYPE_UINT
)
&
&
(
base_type
<
=
GLSL_TYPE_INT64
)
;
}
bool
is_integer
(
)
const
{
return
glsl_base_type_is_integer
(
base_type
)
;
}
bool
is_integer_32
(
)
const
{
return
(
base_type
=
=
GLSL_TYPE_UINT
)
|
|
(
base_type
=
=
GLSL_TYPE_INT
)
;
}
bool
is_integer_64
(
)
const
{
return
base_type
=
=
GLSL_TYPE_UINT64
|
|
base_type
=
=
GLSL_TYPE_INT64
;
}
bool
is_integer_32_64
(
)
const
{
return
is_integer_32
(
)
|
|
is_integer_64
(
)
;
}
bool
contains_integer
(
)
const
;
bool
contains_double
(
)
const
;
bool
contains_64bit
(
)
const
;
bool
is_float
(
)
const
{
return
base_type
=
=
GLSL_TYPE_FLOAT
;
}
bool
is_double
(
)
const
{
return
base_type
=
=
GLSL_TYPE_DOUBLE
;
}
bool
is_dual_slot
(
)
const
{
return
is_64bit
(
)
&
&
vector_elements
>
2
;
}
bool
is_64bit
(
)
const
{
return
glsl_base_type_is_64bit
(
base_type
)
;
}
bool
is_16bit
(
)
const
{
return
glsl_base_type_is_16bit
(
base_type
)
;
}
bool
is_32bit
(
)
const
{
return
base_type
=
=
GLSL_TYPE_UINT
|
|
base_type
=
=
GLSL_TYPE_INT
|
|
base_type
=
=
GLSL_TYPE_FLOAT
;
}
bool
is_boolean
(
)
const
{
return
base_type
=
=
GLSL_TYPE_BOOL
;
}
bool
is_sampler
(
)
const
{
return
base_type
=
=
GLSL_TYPE_SAMPLER
;
}
bool
contains_sampler
(
)
const
;
bool
contains_array
(
)
const
;
gl_texture_index
sampler_index
(
)
const
;
bool
contains_image
(
)
const
;
bool
is_image
(
)
const
{
return
base_type
=
=
GLSL_TYPE_IMAGE
;
}
bool
is_array
(
)
const
{
return
base_type
=
=
GLSL_TYPE_ARRAY
;
}
bool
is_array_of_arrays
(
)
const
{
return
is_array
(
)
&
&
fields
.
array
-
>
is_array
(
)
;
}
bool
is_struct
(
)
const
{
return
base_type
=
=
GLSL_TYPE_STRUCT
;
}
bool
is_interface
(
)
const
{
return
base_type
=
=
GLSL_TYPE_INTERFACE
;
}
bool
is_void
(
)
const
{
return
base_type
=
=
GLSL_TYPE_VOID
;
}
bool
is_error
(
)
const
{
return
base_type
=
=
GLSL_TYPE_ERROR
;
}
bool
is_subroutine
(
)
const
{
return
base_type
=
=
GLSL_TYPE_SUBROUTINE
;
}
bool
contains_subroutine
(
)
const
;
bool
is_anonymous
(
)
const
{
return
!
strncmp
(
name
"
#
anon
"
5
)
;
}
const
glsl_type
*
without_array
(
)
const
{
const
glsl_type
*
t
=
this
;
while
(
t
-
>
is_array
(
)
)
t
=
t
-
>
fields
.
array
;
return
t
;
}
unsigned
arrays_of_arrays_size
(
)
const
{
if
(
!
is_array
(
)
)
return
0
;
unsigned
size
=
length
;
const
glsl_type
*
base_type
=
fields
.
array
;
while
(
base_type
-
>
is_array
(
)
)
{
size
=
size
*
base_type
-
>
length
;
base_type
=
base_type
-
>
fields
.
array
;
}
return
size
;
}
unsigned
bit_size
(
)
const
{
return
glsl_base_type_bit_size
(
this
-
>
base_type
)
;
}
bool
is_atomic_uint
(
)
const
{
return
base_type
=
=
GLSL_TYPE_ATOMIC_UINT
;
}
unsigned
atomic_size
(
)
const
{
if
(
is_atomic_uint
(
)
)
return
ATOMIC_COUNTER_SIZE
;
else
if
(
is_array
(
)
)
return
length
*
fields
.
array
-
>
atomic_size
(
)
;
else
return
0
;
}
bool
contains_atomic
(
)
const
{
return
atomic_size
(
)
>
0
;
}
bool
contains_opaque
(
)
const
;
const
glsl_type
*
row_type
(
)
const
{
if
(
!
is_matrix
(
)
)
return
error_type
;
if
(
explicit_stride
&
&
!
interface_row_major
)
return
get_instance
(
base_type
matrix_columns
1
explicit_stride
)
;
else
return
get_instance
(
base_type
matrix_columns
1
)
;
}
const
glsl_type
*
column_type
(
)
const
{
if
(
!
is_matrix
(
)
)
return
error_type
;
if
(
explicit_stride
&
&
interface_row_major
)
return
get_instance
(
base_type
vector_elements
1
explicit_stride
)
;
else
return
get_instance
(
base_type
vector_elements
1
)
;
}
const
glsl_type
*
field_type
(
const
char
*
name
)
const
;
int
field_index
(
const
char
*
name
)
const
;
int
array_size
(
)
const
{
return
is_array
(
)
?
length
:
-
1
;
}
bool
is_unsized_array
(
)
const
{
return
is_array
(
)
&
&
length
=
=
0
;
}
int
coordinate_components
(
)
const
;
bool
compare_no_precision
(
const
glsl_type
*
b
)
const
;
bool
record_compare
(
const
glsl_type
*
b
bool
match_name
bool
match_locations
=
true
bool
match_precision
=
true
)
const
;
enum
glsl_interface_packing
get_interface_packing
(
)
const
{
return
(
enum
glsl_interface_packing
)
interface_packing
;
}
enum
glsl_interface_packing
get_internal_ifc_packing
(
bool
std430_supported
)
const
{
enum
glsl_interface_packing
packing
=
this
-
>
get_interface_packing
(
)
;
if
(
packing
=
=
GLSL_INTERFACE_PACKING_STD140
|
|
(
!
std430_supported
&
&
(
packing
=
=
GLSL_INTERFACE_PACKING_SHARED
|
|
packing
=
=
GLSL_INTERFACE_PACKING_PACKED
)
)
)
{
return
GLSL_INTERFACE_PACKING_STD140
;
}
else
{
assert
(
packing
=
=
GLSL_INTERFACE_PACKING_STD430
|
|
(
std430_supported
&
&
(
packing
=
=
GLSL_INTERFACE_PACKING_SHARED
|
|
packing
=
=
GLSL_INTERFACE_PACKING_PACKED
)
)
)
;
return
GLSL_INTERFACE_PACKING_STD430
;
}
}
bool
get_interface_row_major
(
)
const
{
return
(
bool
)
interface_row_major
;
}
~
glsl_type
(
)
;
private
:
static
mtx_t
hash_mutex
;
void
*
mem_ctx
;
glsl_type
(
GLenum
gl_type
glsl_base_type
base_type
unsigned
vector_elements
unsigned
matrix_columns
const
char
*
name
unsigned
explicit_stride
=
0
bool
row_major
=
false
)
;
glsl_type
(
GLenum
gl_type
glsl_base_type
base_type
enum
glsl_sampler_dim
dim
bool
shadow
bool
array
glsl_base_type
type
const
char
*
name
)
;
glsl_type
(
const
glsl_struct_field
*
fields
unsigned
num_fields
const
char
*
name
bool
packed
=
false
)
;
glsl_type
(
const
glsl_struct_field
*
fields
unsigned
num_fields
enum
glsl_interface_packing
packing
bool
row_major
const
char
*
name
)
;
glsl_type
(
const
glsl_type
*
return_type
const
glsl_function_param
*
params
unsigned
num_params
)
;
glsl_type
(
const
glsl_type
*
array
unsigned
length
unsigned
explicit_stride
)
;
glsl_type
(
const
char
*
name
)
;
static
struct
hash_table
*
explicit_matrix_types
;
static
struct
hash_table
*
array_types
;
static
struct
hash_table
*
struct_types
;
static
struct
hash_table
*
interface_types
;
static
struct
hash_table
*
subroutine_types
;
static
struct
hash_table
*
function_types
;
static
bool
record_key_compare
(
const
void
*
a
const
void
*
b
)
;
static
unsigned
record_key_hash
(
const
void
*
key
)
;
#
undef
DECL_TYPE
#
define
DECL_TYPE
(
NAME
.
.
.
)
static
const
glsl_type
_
#
#
NAME
#
#
_type
;
#
undef
STRUCT_TYPE
#
define
STRUCT_TYPE
(
NAME
)
static
const
glsl_type
_struct_
#
#
NAME
#
#
_type
;
#
include
"
compiler
/
builtin_type_macros
.
h
"
friend
void
glsl_type_singleton_init_or_ref
(
void
)
;
friend
void
glsl_type_singleton_decref
(
void
)
;
friend
void
_mesa_glsl_initialize_types
(
struct
_mesa_glsl_parse_state
*
)
;
}
;
#
undef
DECL_TYPE
#
undef
STRUCT_TYPE
#
endif
struct
glsl_struct_field
{
const
struct
glsl_type
*
type
;
const
char
*
name
;
int
location
;
int
offset
;
int
xfb_buffer
;
int
xfb_stride
;
unsigned
interpolation
:
3
;
unsigned
centroid
:
1
;
unsigned
sample
:
1
;
unsigned
matrix_layout
:
2
;
unsigned
patch
:
1
;
unsigned
precision
:
2
;
unsigned
memory_read_only
:
1
;
unsigned
memory_write_only
:
1
;
unsigned
memory_coherent
:
1
;
unsigned
memory_volatile
:
1
;
unsigned
memory_restrict
:
1
;
unsigned
image_format
:
16
;
unsigned
explicit_xfb_buffer
:
1
;
unsigned
implicit_sized_array
:
1
;
#
ifdef
__cplusplus
#
define
DEFAULT_CONSTRUCTORS
(
_type
_precision
_name
)
\
type
(
_type
)
name
(
_name
)
location
(
-
1
)
offset
(
-
1
)
xfb_buffer
(
0
)
\
xfb_stride
(
0
)
interpolation
(
0
)
centroid
(
0
)
\
sample
(
0
)
matrix_layout
(
GLSL_MATRIX_LAYOUT_INHERITED
)
patch
(
0
)
\
precision
(
_precision
)
memory_read_only
(
0
)
\
memory_write_only
(
0
)
memory_coherent
(
0
)
memory_volatile
(
0
)
\
memory_restrict
(
0
)
image_format
(
0
)
explicit_xfb_buffer
(
0
)
\
implicit_sized_array
(
0
)
glsl_struct_field
(
const
struct
glsl_type
*
_type
int
_precision
const
char
*
_name
)
:
DEFAULT_CONSTRUCTORS
(
_type
_precision
_name
)
{
}
glsl_struct_field
(
const
struct
glsl_type
*
_type
const
char
*
_name
)
:
DEFAULT_CONSTRUCTORS
(
_type
GLSL_PRECISION_NONE
_name
)
{
}
glsl_struct_field
(
)
:
DEFAULT_CONSTRUCTORS
(
NULL
GLSL_PRECISION_NONE
NULL
)
{
}
#
undef
DEFAULT_CONSTRUCTORS
#
endif
}
;
struct
glsl_function_param
{
const
struct
glsl_type
*
type
;
bool
in
;
bool
out
;
}
;
static
inline
unsigned
int
glsl_align
(
unsigned
int
a
unsigned
int
align
)
{
return
(
a
+
align
-
1
)
/
align
*
align
;
}
#
endif
