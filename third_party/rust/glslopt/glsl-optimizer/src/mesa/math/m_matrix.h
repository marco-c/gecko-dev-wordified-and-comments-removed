#
ifndef
_M_MATRIX_H
#
define
_M_MATRIX_H
#
include
"
main
/
glheader
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
MAT_SX
0
#
define
MAT_SY
5
#
define
MAT_SZ
10
#
define
MAT_TX
12
#
define
MAT_TY
13
#
define
MAT_TZ
14
enum
GLmatrixtype
{
MATRIX_GENERAL
MATRIX_IDENTITY
MATRIX_3D_NO_ROT
MATRIX_PERSPECTIVE
MATRIX_2D
MATRIX_2D_NO_ROT
MATRIX_3D
}
;
typedef
struct
{
GLfloat
*
m
;
GLfloat
*
inv
;
GLuint
flags
;
enum
GLmatrixtype
type
;
}
GLmatrix
;
extern
void
_math_matrix_ctr
(
GLmatrix
*
m
)
;
extern
void
_math_matrix_dtr
(
GLmatrix
*
m
)
;
extern
void
_math_matrix_mul_matrix
(
GLmatrix
*
dest
const
GLmatrix
*
a
const
GLmatrix
*
b
)
;
extern
void
_math_matrix_mul_floats
(
GLmatrix
*
dest
const
GLfloat
*
b
)
;
extern
void
_math_matrix_loadf
(
GLmatrix
*
mat
const
GLfloat
*
m
)
;
extern
void
_math_matrix_translate
(
GLmatrix
*
mat
GLfloat
x
GLfloat
y
GLfloat
z
)
;
extern
void
_math_matrix_rotate
(
GLmatrix
*
m
GLfloat
angle
GLfloat
x
GLfloat
y
GLfloat
z
)
;
extern
void
_math_matrix_scale
(
GLmatrix
*
mat
GLfloat
x
GLfloat
y
GLfloat
z
)
;
extern
void
_math_matrix_ortho
(
GLmatrix
*
mat
GLfloat
left
GLfloat
right
GLfloat
bottom
GLfloat
top
GLfloat
nearval
GLfloat
farval
)
;
extern
void
_math_matrix_frustum
(
GLmatrix
*
mat
GLfloat
left
GLfloat
right
GLfloat
bottom
GLfloat
top
GLfloat
nearval
GLfloat
farval
)
;
extern
void
_math_matrix_viewport
(
GLmatrix
*
m
const
float
scale
[
3
]
const
float
translate
[
3
]
double
depthMax
)
;
extern
void
_math_matrix_set_identity
(
GLmatrix
*
dest
)
;
extern
void
_math_matrix_copy
(
GLmatrix
*
to
const
GLmatrix
*
from
)
;
extern
void
_math_matrix_analyse
(
GLmatrix
*
mat
)
;
extern
void
_math_matrix_print
(
const
GLmatrix
*
m
)
;
extern
GLboolean
_math_matrix_is_length_preserving
(
const
GLmatrix
*
m
)
;
extern
GLboolean
_math_matrix_has_rotation
(
const
GLmatrix
*
m
)
;
extern
GLboolean
_math_matrix_is_general_scale
(
const
GLmatrix
*
m
)
;
extern
GLboolean
_math_matrix_is_dirty
(
const
GLmatrix
*
m
)
;
extern
void
_math_transposef
(
GLfloat
to
[
16
]
const
GLfloat
from
[
16
]
)
;
extern
void
_math_transposed
(
GLdouble
to
[
16
]
const
GLdouble
from
[
16
]
)
;
extern
void
_math_transposefd
(
GLfloat
to
[
16
]
const
GLdouble
from
[
16
]
)
;
#
define
TRANSFORM_POINT
(
Q
M
P
)
\
Q
[
0
]
=
M
[
0
]
*
P
[
0
]
+
M
[
4
]
*
P
[
1
]
+
M
[
8
]
*
P
[
2
]
+
M
[
12
]
*
P
[
3
]
;
\
Q
[
1
]
=
M
[
1
]
*
P
[
0
]
+
M
[
5
]
*
P
[
1
]
+
M
[
9
]
*
P
[
2
]
+
M
[
13
]
*
P
[
3
]
;
\
Q
[
2
]
=
M
[
2
]
*
P
[
0
]
+
M
[
6
]
*
P
[
1
]
+
M
[
10
]
*
P
[
2
]
+
M
[
14
]
*
P
[
3
]
;
\
Q
[
3
]
=
M
[
3
]
*
P
[
0
]
+
M
[
7
]
*
P
[
1
]
+
M
[
11
]
*
P
[
2
]
+
M
[
15
]
*
P
[
3
]
;
#
define
TRANSFORM_POINT3
(
Q
M
P
)
\
Q
[
0
]
=
M
[
0
]
*
P
[
0
]
+
M
[
4
]
*
P
[
1
]
+
M
[
8
]
*
P
[
2
]
+
M
[
12
]
;
\
Q
[
1
]
=
M
[
1
]
*
P
[
0
]
+
M
[
5
]
*
P
[
1
]
+
M
[
9
]
*
P
[
2
]
+
M
[
13
]
;
\
Q
[
2
]
=
M
[
2
]
*
P
[
0
]
+
M
[
6
]
*
P
[
1
]
+
M
[
10
]
*
P
[
2
]
+
M
[
14
]
;
\
Q
[
3
]
=
M
[
3
]
*
P
[
0
]
+
M
[
7
]
*
P
[
1
]
+
M
[
11
]
*
P
[
2
]
+
M
[
15
]
;
#
define
TRANSFORM_NORMAL
(
TO
N
MAT
)
\
do
{
\
TO
[
0
]
=
N
[
0
]
*
MAT
[
0
]
+
N
[
1
]
*
MAT
[
1
]
+
N
[
2
]
*
MAT
[
2
]
;
\
TO
[
1
]
=
N
[
0
]
*
MAT
[
4
]
+
N
[
1
]
*
MAT
[
5
]
+
N
[
2
]
*
MAT
[
6
]
;
\
TO
[
2
]
=
N
[
0
]
*
MAT
[
8
]
+
N
[
1
]
*
MAT
[
9
]
+
N
[
2
]
*
MAT
[
10
]
;
\
}
while
(
0
)
#
define
TRANSFORM_DIRECTION
(
TO
DIR
MAT
)
\
do
{
\
TO
[
0
]
=
DIR
[
0
]
*
MAT
[
0
]
+
DIR
[
1
]
*
MAT
[
4
]
+
DIR
[
2
]
*
MAT
[
8
]
;
\
TO
[
1
]
=
DIR
[
0
]
*
MAT
[
1
]
+
DIR
[
1
]
*
MAT
[
5
]
+
DIR
[
2
]
*
MAT
[
9
]
;
\
TO
[
2
]
=
DIR
[
0
]
*
MAT
[
2
]
+
DIR
[
1
]
*
MAT
[
6
]
+
DIR
[
2
]
*
MAT
[
10
]
;
\
}
while
(
0
)
extern
void
_mesa_transform_vector
(
GLfloat
u
[
4
]
const
GLfloat
v
[
4
]
const
GLfloat
m
[
16
]
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
