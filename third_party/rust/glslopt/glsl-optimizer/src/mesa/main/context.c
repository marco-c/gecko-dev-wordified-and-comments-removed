#
include
"
glheader
.
h
"
#
include
"
imports
.
h
"
#
include
"
accum
.
h
"
#
include
"
api_exec
.
h
"
#
include
"
api_loopback
.
h
"
#
include
"
arrayobj
.
h
"
#
include
"
attrib
.
h
"
#
include
"
bbox
.
h
"
#
include
"
blend
.
h
"
#
include
"
buffers
.
h
"
#
include
"
bufferobj
.
h
"
#
include
"
conservativeraster
.
h
"
#
include
"
context
.
h
"
#
include
"
cpuinfo
.
h
"
#
include
"
debug
.
h
"
#
include
"
debug_output
.
h
"
#
include
"
depth
.
h
"
#
include
"
dlist
.
h
"
#
include
"
eval
.
h
"
#
include
"
extensions
.
h
"
#
include
"
fbobject
.
h
"
#
include
"
feedback
.
h
"
#
include
"
fog
.
h
"
#
include
"
formats
.
h
"
#
include
"
framebuffer
.
h
"
#
include
"
glthread
.
h
"
#
include
"
hint
.
h
"
#
include
"
hash
.
h
"
#
include
"
light
.
h
"
#
include
"
lines
.
h
"
#
include
"
macros
.
h
"
#
include
"
matrix
.
h
"
#
include
"
multisample
.
h
"
#
include
"
performance_monitor
.
h
"
#
include
"
performance_query
.
h
"
#
include
"
pipelineobj
.
h
"
#
include
"
pixel
.
h
"
#
include
"
pixelstore
.
h
"
#
include
"
points
.
h
"
#
include
"
polygon
.
h
"
#
include
"
queryobj
.
h
"
#
include
"
syncobj
.
h
"
#
include
"
rastpos
.
h
"
#
include
"
remap
.
h
"
#
include
"
scissor
.
h
"
#
include
"
shared
.
h
"
#
include
"
shaderobj
.
h
"
#
include
"
shaderimage
.
h
"
#
include
"
state
.
h
"
#
include
"
util
/
debug
.
h
"
#
include
"
util
/
disk_cache
.
h
"
#
include
"
util
/
strtod
.
h
"
#
include
"
stencil
.
h
"
#
include
"
shaderimage
.
h
"
#
include
"
texcompress_s3tc
.
h
"
#
include
"
texstate
.
h
"
#
include
"
transformfeedback
.
h
"
#
include
"
mtypes
.
h
"
#
include
"
varray
.
h
"
#
include
"
version
.
h
"
#
include
"
viewport
.
h
"
#
include
"
texturebindless
.
h
"
#
include
"
program
/
program
.
h
"
#
include
"
math
/
m_matrix
.
h
"
#
include
"
main
/
dispatch
.
h
"
#
include
"
macros
.
h
"
#
include
"
git_sha1
.
h
"
#
ifdef
USE_SPARC_ASM
#
include
"
sparc
/
sparc
.
h
"
#
endif
#
include
"
compiler
/
glsl_types
.
h
"
#
include
"
compiler
/
glsl
/
builtin_functions
.
h
"
#
include
"
compiler
/
glsl
/
glsl_parser_extras
.
h
"
#
include
<
stdbool
.
h
>
#
ifndef
MESA_VERBOSE
int
MESA_VERBOSE
=
0
;
#
endif
#
ifndef
MESA_DEBUG_FLAGS
int
MESA_DEBUG_FLAGS
=
0
;
#
endif
GLfloat
_mesa_ubyte_to_float_color_tab
[
256
]
;
void
_mesa_notifySwapBuffers
(
struct
gl_context
*
ctx
)
{
if
(
MESA_VERBOSE
&
VERBOSE_SWAPBUFFERS
)
_mesa_debug
(
ctx
"
SwapBuffers
\
n
"
)
;
FLUSH_CURRENT
(
ctx
0
)
;
if
(
ctx
-
>
Driver
.
Flush
)
{
ctx
-
>
Driver
.
Flush
(
ctx
)
;
}
}
struct
gl_config
*
_mesa_create_visual
(
GLboolean
dbFlag
GLboolean
stereoFlag
GLint
redBits
GLint
greenBits
GLint
blueBits
GLint
alphaBits
GLint
depthBits
GLint
stencilBits
GLint
accumRedBits
GLint
accumGreenBits
GLint
accumBlueBits
GLint
accumAlphaBits
GLuint
numSamples
)
{
struct
gl_config
*
vis
=
CALLOC_STRUCT
(
gl_config
)
;
if
(
vis
)
{
if
(
!
_mesa_initialize_visual
(
vis
dbFlag
stereoFlag
redBits
greenBits
blueBits
alphaBits
depthBits
stencilBits
accumRedBits
accumGreenBits
accumBlueBits
accumAlphaBits
numSamples
)
)
{
free
(
vis
)
;
return
NULL
;
}
}
return
vis
;
}
GLboolean
_mesa_initialize_visual
(
struct
gl_config
*
vis
GLboolean
dbFlag
GLboolean
stereoFlag
GLint
redBits
GLint
greenBits
GLint
blueBits
GLint
alphaBits
GLint
depthBits
GLint
stencilBits
GLint
accumRedBits
GLint
accumGreenBits
GLint
accumBlueBits
GLint
accumAlphaBits
GLuint
numSamples
)
{
assert
(
vis
)
;
if
(
depthBits
<
0
|
|
depthBits
>
32
)
{
return
GL_FALSE
;
}
if
(
stencilBits
<
0
|
|
stencilBits
>
8
)
{
return
GL_FALSE
;
}
assert
(
accumRedBits
>
=
0
)
;
assert
(
accumGreenBits
>
=
0
)
;
assert
(
accumBlueBits
>
=
0
)
;
assert
(
accumAlphaBits
>
=
0
)
;
vis
-
>
doubleBufferMode
=
dbFlag
;
vis
-
>
stereoMode
=
stereoFlag
;
vis
-
>
redBits
=
redBits
;
vis
-
>
greenBits
=
greenBits
;
vis
-
>
blueBits
=
blueBits
;
vis
-
>
alphaBits
=
alphaBits
;
vis
-
>
rgbBits
=
redBits
+
greenBits
+
blueBits
;
vis
-
>
depthBits
=
depthBits
;
vis
-
>
stencilBits
=
stencilBits
;
vis
-
>
accumRedBits
=
accumRedBits
;
vis
-
>
accumGreenBits
=
accumGreenBits
;
vis
-
>
accumBlueBits
=
accumBlueBits
;
vis
-
>
accumAlphaBits
=
accumAlphaBits
;
vis
-
>
numAuxBuffers
=
0
;
vis
-
>
level
=
0
;
vis
-
>
sampleBuffers
=
numSamples
>
0
?
1
:
0
;
vis
-
>
samples
=
numSamples
;
return
GL_TRUE
;
}
void
_mesa_destroy_visual
(
struct
gl_config
*
vis
)
{
free
(
vis
)
;
}
mtx_t
OneTimeLock
=
_MTX_INITIALIZER_NP
;
static
void
one_time_fini
(
void
)
{
glsl_type_singleton_decref
(
)
;
_mesa_locale_fini
(
)
;
}
static
void
one_time_init
(
struct
gl_context
*
ctx
)
{
static
GLbitfield
api_init_mask
=
0x0
;
mtx_lock
(
&
OneTimeLock
)
;
if
(
!
api_init_mask
)
{
GLuint
i
;
STATIC_ASSERT
(
sizeof
(
GLbyte
)
=
=
1
)
;
STATIC_ASSERT
(
sizeof
(
GLubyte
)
=
=
1
)
;
STATIC_ASSERT
(
sizeof
(
GLshort
)
=
=
2
)
;
STATIC_ASSERT
(
sizeof
(
GLushort
)
=
=
2
)
;
STATIC_ASSERT
(
sizeof
(
GLint
)
=
=
4
)
;
STATIC_ASSERT
(
sizeof
(
GLuint
)
=
=
4
)
;
_mesa_locale_init
(
)
;
_mesa_one_time_init_extension_overrides
(
ctx
)
;
_mesa_get_cpu_features
(
)
;
for
(
i
=
0
;
i
<
256
;
i
+
+
)
{
_mesa_ubyte_to_float_color_tab
[
i
]
=
(
float
)
i
/
255
.
0F
;
}
atexit
(
one_time_fini
)
;
#
if
defined
(
DEBUG
)
if
(
MESA_VERBOSE
!
=
0
)
{
_mesa_debug
(
ctx
"
Mesa
"
PACKAGE_VERSION
"
DEBUG
build
"
MESA_GIT_SHA1
"
\
n
"
)
;
}
#
endif
glsl_type_singleton_init_or_ref
(
)
;
}
if
(
!
(
api_init_mask
&
(
1
<
<
ctx
-
>
API
)
)
)
{
_mesa_init_remap_table
(
)
;
}
api_init_mask
|
=
1
<
<
ctx
-
>
API
;
mtx_unlock
(
&
OneTimeLock
)
;
}
static
void
_mesa_init_current
(
struct
gl_context
*
ctx
)
{
GLuint
i
;
for
(
i
=
0
;
i
<
ARRAY_SIZE
(
ctx
-
>
Current
.
Attrib
)
;
i
+
+
)
{
ASSIGN_4V
(
ctx
-
>
Current
.
Attrib
[
i
]
0
.
0
0
.
0
0
.
0
1
.
0
)
;
}
ASSIGN_4V
(
ctx
-
>
Current
.
Attrib
[
VERT_ATTRIB_NORMAL
]
0
.
0
0
.
0
1
.
0
1
.
0
)
;
ASSIGN_4V
(
ctx
-
>
Current
.
Attrib
[
VERT_ATTRIB_COLOR0
]
1
.
0
1
.
0
1
.
0
1
.
0
)
;
ASSIGN_4V
(
ctx
-
>
Current
.
Attrib
[
VERT_ATTRIB_COLOR1
]
0
.
0
0
.
0
0
.
0
1
.
0
)
;
ASSIGN_4V
(
ctx
-
>
Current
.
Attrib
[
VERT_ATTRIB_COLOR_INDEX
]
1
.
0
0
.
0
0
.
0
1
.
0
)
;
ASSIGN_4V
(
ctx
-
>
Current
.
Attrib
[
VERT_ATTRIB_EDGEFLAG
]
1
.
0
0
.
0
0
.
0
1
.
0
)
;
}
static
void
init_program_limits
(
struct
gl_constants
*
consts
gl_shader_stage
stage
struct
gl_program_constants
*
prog
)
{
prog
-
>
MaxInstructions
=
MAX_PROGRAM_INSTRUCTIONS
;
prog
-
>
MaxAluInstructions
=
MAX_PROGRAM_INSTRUCTIONS
;
prog
-
>
MaxTexInstructions
=
MAX_PROGRAM_INSTRUCTIONS
;
prog
-
>
MaxTexIndirections
=
MAX_PROGRAM_INSTRUCTIONS
;
prog
-
>
MaxTemps
=
MAX_PROGRAM_TEMPS
;
prog
-
>
MaxEnvParams
=
MAX_PROGRAM_ENV_PARAMS
;
prog
-
>
MaxLocalParams
=
MAX_PROGRAM_LOCAL_PARAMS
;
prog
-
>
MaxAddressOffset
=
MAX_PROGRAM_LOCAL_PARAMS
;
switch
(
stage
)
{
case
MESA_SHADER_VERTEX
:
prog
-
>
MaxParameters
=
MAX_VERTEX_PROGRAM_PARAMS
;
prog
-
>
MaxAttribs
=
MAX_VERTEX_GENERIC_ATTRIBS
;
prog
-
>
MaxAddressRegs
=
MAX_VERTEX_PROGRAM_ADDRESS_REGS
;
prog
-
>
MaxUniformComponents
=
4
*
MAX_UNIFORMS
;
prog
-
>
MaxInputComponents
=
0
;
prog
-
>
MaxOutputComponents
=
16
*
4
;
break
;
case
MESA_SHADER_FRAGMENT
:
prog
-
>
MaxParameters
=
MAX_FRAGMENT_PROGRAM_PARAMS
;
prog
-
>
MaxAttribs
=
MAX_FRAGMENT_PROGRAM_INPUTS
;
prog
-
>
MaxAddressRegs
=
MAX_FRAGMENT_PROGRAM_ADDRESS_REGS
;
prog
-
>
MaxUniformComponents
=
4
*
MAX_UNIFORMS
;
prog
-
>
MaxInputComponents
=
16
*
4
;
prog
-
>
MaxOutputComponents
=
0
;
break
;
case
MESA_SHADER_TESS_CTRL
:
case
MESA_SHADER_TESS_EVAL
:
case
MESA_SHADER_GEOMETRY
:
prog
-
>
MaxParameters
=
MAX_VERTEX_PROGRAM_PARAMS
;
prog
-
>
MaxAttribs
=
MAX_VERTEX_GENERIC_ATTRIBS
;
prog
-
>
MaxAddressRegs
=
MAX_VERTEX_PROGRAM_ADDRESS_REGS
;
prog
-
>
MaxUniformComponents
=
4
*
MAX_UNIFORMS
;
prog
-
>
MaxInputComponents
=
16
*
4
;
prog
-
>
MaxOutputComponents
=
16
*
4
;
break
;
case
MESA_SHADER_COMPUTE
:
prog
-
>
MaxParameters
=
0
;
prog
-
>
MaxAttribs
=
0
;
prog
-
>
MaxAddressRegs
=
0
;
prog
-
>
MaxUniformComponents
=
4
*
MAX_UNIFORMS
;
prog
-
>
MaxInputComponents
=
0
;
prog
-
>
MaxOutputComponents
=
0
;
break
;
default
:
assert
(
0
&
&
"
Bad
shader
stage
in
init_program_limits
(
)
"
)
;
}
prog
-
>
MaxNativeInstructions
=
0
;
prog
-
>
MaxNativeAluInstructions
=
0
;
prog
-
>
MaxNativeTexInstructions
=
0
;
prog
-
>
MaxNativeTexIndirections
=
0
;
prog
-
>
MaxNativeAttribs
=
0
;
prog
-
>
MaxNativeTemps
=
0
;
prog
-
>
MaxNativeAddressRegs
=
0
;
prog
-
>
MaxNativeParameters
=
0
;
prog
-
>
MediumFloat
.
RangeMin
=
127
;
prog
-
>
MediumFloat
.
RangeMax
=
127
;
prog
-
>
MediumFloat
.
Precision
=
23
;
prog
-
>
LowFloat
=
prog
-
>
HighFloat
=
prog
-
>
MediumFloat
;
prog
-
>
MediumInt
.
RangeMin
=
24
;
prog
-
>
MediumInt
.
RangeMax
=
24
;
prog
-
>
MediumInt
.
Precision
=
0
;
prog
-
>
LowInt
=
prog
-
>
HighInt
=
prog
-
>
MediumInt
;
prog
-
>
MaxUniformBlocks
=
12
;
prog
-
>
MaxCombinedUniformComponents
=
(
prog
-
>
MaxUniformComponents
+
consts
-
>
MaxUniformBlockSize
/
4
*
prog
-
>
MaxUniformBlocks
)
;
prog
-
>
MaxAtomicBuffers
=
0
;
prog
-
>
MaxAtomicCounters
=
0
;
prog
-
>
MaxShaderStorageBlocks
=
8
;
}
void
_mesa_init_constants
(
struct
gl_constants
*
consts
gl_api
api
)
{
int
i
;
assert
(
consts
)
;
consts
-
>
MaxTextureMbytes
=
MAX_TEXTURE_MBYTES
;
consts
-
>
MaxTextureSize
=
1
<
<
(
MAX_TEXTURE_LEVELS
-
1
)
;
consts
-
>
Max3DTextureLevels
=
MAX_3D_TEXTURE_LEVELS
;
consts
-
>
MaxCubeTextureLevels
=
MAX_CUBE_TEXTURE_LEVELS
;
consts
-
>
MaxTextureRectSize
=
MAX_TEXTURE_RECT_SIZE
;
consts
-
>
MaxArrayTextureLayers
=
MAX_ARRAY_TEXTURE_LAYERS
;
consts
-
>
MaxTextureCoordUnits
=
MAX_TEXTURE_COORD_UNITS
;
consts
-
>
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
=
MAX_TEXTURE_IMAGE_UNITS
;
consts
-
>
MaxTextureUnits
=
MIN2
(
consts
-
>
MaxTextureCoordUnits
consts
-
>
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
)
;
consts
-
>
MaxTextureMaxAnisotropy
=
MAX_TEXTURE_MAX_ANISOTROPY
;
consts
-
>
MaxTextureLodBias
=
MAX_TEXTURE_LOD_BIAS
;
consts
-
>
MaxTextureBufferSize
=
65536
;
consts
-
>
TextureBufferOffsetAlignment
=
1
;
consts
-
>
MaxArrayLockSize
=
MAX_ARRAY_LOCK_SIZE
;
consts
-
>
SubPixelBits
=
SUB_PIXEL_BITS
;
consts
-
>
MinPointSize
=
MIN_POINT_SIZE
;
consts
-
>
MaxPointSize
=
MAX_POINT_SIZE
;
consts
-
>
MinPointSizeAA
=
MIN_POINT_SIZE
;
consts
-
>
MaxPointSizeAA
=
MAX_POINT_SIZE
;
consts
-
>
PointSizeGranularity
=
(
GLfloat
)
POINT_SIZE_GRANULARITY
;
consts
-
>
MinLineWidth
=
MIN_LINE_WIDTH
;
consts
-
>
MaxLineWidth
=
MAX_LINE_WIDTH
;
consts
-
>
MinLineWidthAA
=
MIN_LINE_WIDTH
;
consts
-
>
MaxLineWidthAA
=
MAX_LINE_WIDTH
;
consts
-
>
LineWidthGranularity
=
(
GLfloat
)
LINE_WIDTH_GRANULARITY
;
consts
-
>
MaxClipPlanes
=
6
;
consts
-
>
MaxLights
=
MAX_LIGHTS
;
consts
-
>
MaxShininess
=
128
.
0
;
consts
-
>
MaxSpotExponent
=
128
.
0
;
consts
-
>
MaxViewportWidth
=
16384
;
consts
-
>
MaxViewportHeight
=
16384
;
consts
-
>
MinMapBufferAlignment
=
64
;
consts
-
>
MaxViewports
=
1
;
consts
-
>
ViewportSubpixelBits
=
0
;
consts
-
>
ViewportBounds
.
Min
=
0
;
consts
-
>
ViewportBounds
.
Max
=
0
;
consts
-
>
MaxCombinedUniformBlocks
=
36
;
consts
-
>
MaxUniformBufferBindings
=
36
;
consts
-
>
MaxUniformBlockSize
=
16384
;
consts
-
>
UniformBufferOffsetAlignment
=
1
;
consts
-
>
MaxCombinedShaderStorageBlocks
=
8
;
consts
-
>
MaxShaderStorageBufferBindings
=
8
;
consts
-
>
MaxShaderStorageBlockSize
=
128
*
1024
*
1024
;
consts
-
>
ShaderStorageBufferOffsetAlignment
=
256
;
consts
-
>
MaxUserAssignableUniformLocations
=
4
*
MESA_SHADER_STAGES
*
MAX_UNIFORMS
;
for
(
i
=
0
;
i
<
MESA_SHADER_STAGES
;
i
+
+
)
init_program_limits
(
consts
i
&
consts
-
>
Program
[
i
]
)
;
consts
-
>
MaxProgramMatrices
=
MAX_PROGRAM_MATRICES
;
consts
-
>
MaxProgramMatrixStackDepth
=
MAX_PROGRAM_MATRIX_STACK_DEPTH
;
consts
-
>
GLSLVersion
=
api
=
=
API_OPENGL_CORE
?
130
:
120
;
consts
-
>
GLSLVersionCompat
=
consts
-
>
GLSLVersion
;
consts
-
>
GLSLLowerConstArrays
=
true
;
consts
-
>
VertexID_is_zero_based
=
false
;
consts
-
>
MaxDrawBuffers
=
MAX_DRAW_BUFFERS
;
consts
-
>
MaxColorAttachments
=
MAX_COLOR_ATTACHMENTS
;
consts
-
>
MaxRenderbufferSize
=
MAX_RENDERBUFFER_SIZE
;
consts
-
>
Program
[
MESA_SHADER_VERTEX
]
.
MaxTextureImageUnits
=
MAX_TEXTURE_IMAGE_UNITS
;
consts
-
>
MaxCombinedTextureImageUnits
=
MAX_COMBINED_TEXTURE_IMAGE_UNITS
;
consts
-
>
MaxVarying
=
16
;
consts
-
>
Program
[
MESA_SHADER_GEOMETRY
]
.
MaxTextureImageUnits
=
MAX_TEXTURE_IMAGE_UNITS
;
consts
-
>
MaxGeometryOutputVertices
=
MAX_GEOMETRY_OUTPUT_VERTICES
;
consts
-
>
MaxGeometryTotalOutputComponents
=
MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS
;
consts
-
>
MaxGeometryShaderInvocations
=
MAX_GEOMETRY_SHADER_INVOCATIONS
;
#
ifdef
DEBUG
consts
-
>
GenerateTemporaryNames
=
true
;
#
else
consts
-
>
GenerateTemporaryNames
=
false
;
#
endif
consts
-
>
MaxSamples
=
0
;
consts
-
>
UniformBooleanTrue
=
FLOAT_AS_UNION
(
1
.
0f
)
.
u
;
consts
-
>
MaxServerWaitTimeout
=
0x7fffffff7fffffffULL
;
consts
-
>
QuadsFollowProvokingVertexConvention
=
GL_TRUE
;
consts
-
>
LayerAndVPIndexProvokingVertex
=
GL_UNDEFINED_VERTEX
;
consts
-
>
MaxTransformFeedbackBuffers
=
MAX_FEEDBACK_BUFFERS
;
consts
-
>
MaxTransformFeedbackSeparateComponents
=
4
*
MAX_FEEDBACK_ATTRIBS
;
consts
-
>
MaxTransformFeedbackInterleavedComponents
=
4
*
MAX_FEEDBACK_ATTRIBS
;
consts
-
>
MaxVertexStreams
=
1
;
consts
-
>
ProfileMask
=
api
=
=
API_OPENGL_CORE
?
GL_CONTEXT_CORE_PROFILE_BIT
:
GL_CONTEXT_COMPATIBILITY_PROFILE_BIT
;
consts
-
>
MaxVertexAttribStride
=
2048
;
consts
-
>
MinProgramTexelOffset
=
-
8
;
consts
-
>
MaxProgramTexelOffset
=
7
;
consts
-
>
MinProgramTextureGatherOffset
=
-
8
;
consts
-
>
MaxProgramTextureGatherOffset
=
7
;
consts
-
>
ResetStrategy
=
GL_NO_RESET_NOTIFICATION_ARB
;
consts
-
>
RobustAccess
=
GL_FALSE
;
consts
-
>
MaxElementIndex
=
0xffffffffu
;
consts
-
>
MaxColorTextureSamples
=
1
;
consts
-
>
MaxDepthTextureSamples
=
1
;
consts
-
>
MaxIntegerSamples
=
1
;
consts
-
>
MaxAtomicBufferBindings
=
MAX_COMBINED_ATOMIC_BUFFERS
;
consts
-
>
MaxAtomicBufferSize
=
MAX_ATOMIC_COUNTERS
*
ATOMIC_COUNTER_SIZE
;
consts
-
>
MaxCombinedAtomicBuffers
=
MAX_COMBINED_ATOMIC_BUFFERS
;
consts
-
>
MaxCombinedAtomicCounters
=
MAX_ATOMIC_COUNTERS
;
consts
-
>
MaxVertexAttribRelativeOffset
=
2047
;
consts
-
>
MaxVertexAttribBindings
=
MAX_VERTEX_GENERIC_ATTRIBS
;
consts
-
>
MaxComputeWorkGroupCount
[
0
]
=
65535
;
consts
-
>
MaxComputeWorkGroupCount
[
1
]
=
65535
;
consts
-
>
MaxComputeWorkGroupCount
[
2
]
=
65535
;
consts
-
>
MaxComputeWorkGroupSize
[
0
]
=
1024
;
consts
-
>
MaxComputeWorkGroupSize
[
1
]
=
1024
;
consts
-
>
MaxComputeWorkGroupSize
[
2
]
=
64
;
consts
-
>
MaxComputeWorkGroupInvocations
=
0
;
consts
-
>
MinFragmentInterpolationOffset
=
MIN_FRAGMENT_INTERPOLATION_OFFSET
;
consts
-
>
MaxFragmentInterpolationOffset
=
MAX_FRAGMENT_INTERPOLATION_OFFSET
;
consts
-
>
ContextReleaseBehavior
=
GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH
;
consts
-
>
MaxTessGenLevel
=
MAX_TESS_GEN_LEVEL
;
consts
-
>
MaxPatchVertices
=
MAX_PATCH_VERTICES
;
consts
-
>
Program
[
MESA_SHADER_TESS_CTRL
]
.
MaxTextureImageUnits
=
MAX_TEXTURE_IMAGE_UNITS
;
consts
-
>
Program
[
MESA_SHADER_TESS_EVAL
]
.
MaxTextureImageUnits
=
MAX_TEXTURE_IMAGE_UNITS
;
consts
-
>
MaxTessPatchComponents
=
MAX_TESS_PATCH_COMPONENTS
;
consts
-
>
MaxTessControlTotalOutputComponents
=
MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS
;
consts
-
>
PrimitiveRestartForPatches
=
false
;
consts
-
>
MaxComputeVariableGroupSize
[
0
]
=
512
;
consts
-
>
MaxComputeVariableGroupSize
[
1
]
=
512
;
consts
-
>
MaxComputeVariableGroupSize
[
2
]
=
64
;
consts
-
>
MaxComputeVariableGroupInvocations
=
512
;
consts
-
>
MaxSubpixelPrecisionBiasBits
=
0
;
consts
-
>
ConservativeRasterDilateRange
[
0
]
=
0
.
0
;
consts
-
>
ConservativeRasterDilateRange
[
1
]
=
0
.
0
;
consts
-
>
ConservativeRasterDilateGranularity
=
0
.
0
;
}
static
void
check_context_limits
(
struct
gl_context
*
ctx
)
{
(
void
)
ctx
;
assert
(
VARYING_SLOT_MAX
<
=
(
8
*
sizeof
(
ctx
-
>
VertexProgram
.
_Current
-
>
info
.
outputs_written
)
)
)
;
assert
(
VARYING_SLOT_MAX
<
=
(
8
*
sizeof
(
ctx
-
>
FragmentProgram
.
_Current
-
>
info
.
inputs_read
)
)
)
;
assert
(
ctx
-
>
Const
.
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxLocalParams
<
=
MAX_PROGRAM_LOCAL_PARAMS
)
;
assert
(
ctx
-
>
Const
.
Program
[
MESA_SHADER_VERTEX
]
.
MaxLocalParams
<
=
MAX_PROGRAM_LOCAL_PARAMS
)
;
assert
(
ctx
-
>
Const
.
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
>
0
)
;
assert
(
ctx
-
>
Const
.
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
<
=
MAX_TEXTURE_IMAGE_UNITS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureCoordUnits
>
0
)
;
assert
(
ctx
-
>
Const
.
MaxTextureCoordUnits
<
=
MAX_TEXTURE_COORD_UNITS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureUnits
>
0
)
;
assert
(
ctx
-
>
Const
.
MaxTextureUnits
<
=
MAX_TEXTURE_IMAGE_UNITS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureUnits
<
=
MAX_TEXTURE_COORD_UNITS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureUnits
=
=
MIN2
(
ctx
-
>
Const
.
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
ctx
-
>
Const
.
MaxTextureCoordUnits
)
)
;
assert
(
ctx
-
>
Const
.
MaxCombinedTextureImageUnits
>
0
)
;
assert
(
ctx
-
>
Const
.
MaxCombinedTextureImageUnits
<
=
MAX_COMBINED_TEXTURE_IMAGE_UNITS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureCoordUnits
<
=
MAX_COMBINED_TEXTURE_IMAGE_UNITS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureCoordUnits
<
=
ctx
-
>
Const
.
Program
[
MESA_SHADER_FRAGMENT
]
.
MaxTextureImageUnits
)
;
assert
(
ctx
-
>
Const
.
MaxTextureSize
<
=
(
1
<
<
(
MAX_TEXTURE_LEVELS
-
1
)
)
)
;
assert
(
ctx
-
>
Const
.
Max3DTextureLevels
<
=
MAX_3D_TEXTURE_LEVELS
)
;
assert
(
ctx
-
>
Const
.
MaxCubeTextureLevels
<
=
MAX_CUBE_TEXTURE_LEVELS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureRectSize
<
=
MAX_TEXTURE_RECT_SIZE
)
;
assert
(
MAX_TEXTURE_LEVELS
>
=
MAX_3D_TEXTURE_LEVELS
)
;
assert
(
MAX_TEXTURE_LEVELS
>
=
MAX_CUBE_TEXTURE_LEVELS
)
;
assert
(
ctx
-
>
Const
.
MaxTextureSize
<
=
ctx
-
>
Const
.
MaxViewportWidth
)
;
assert
(
ctx
-
>
Const
.
MaxTextureSize
<
=
ctx
-
>
Const
.
MaxViewportHeight
)
;
assert
(
ctx
-
>
Const
.
MaxDrawBuffers
<
=
MAX_DRAW_BUFFERS
)
;
assert
(
BUFFER_COLOR0
+
MAX_DRAW_BUFFERS
<
=
BUFFER_COUNT
)
;
}
static
GLboolean
init_attrib_groups
(
struct
gl_context
*
ctx
)
{
assert
(
ctx
)
;
_mesa_init_constants
(
&
ctx
-
>
Const
ctx
-
>
API
)
;
_mesa_init_extensions
(
&
ctx
-
>
Extensions
)
;
_mesa_init_accum
(
ctx
)
;
_mesa_init_attrib
(
ctx
)
;
_mesa_init_bbox
(
ctx
)
;
_mesa_init_buffer_objects
(
ctx
)
;
_mesa_init_color
(
ctx
)
;
_mesa_init_conservative_raster
(
ctx
)
;
_mesa_init_current
(
ctx
)
;
_mesa_init_depth
(
ctx
)
;
_mesa_init_debug
(
ctx
)
;
_mesa_init_debug_output
(
ctx
)
;
_mesa_init_display_list
(
ctx
)
;
_mesa_init_eval
(
ctx
)
;
_mesa_init_fbobjects
(
ctx
)
;
_mesa_init_feedback
(
ctx
)
;
_mesa_init_fog
(
ctx
)
;
_mesa_init_hint
(
ctx
)
;
_mesa_init_image_units
(
ctx
)
;
_mesa_init_line
(
ctx
)
;
_mesa_init_lighting
(
ctx
)
;
_mesa_init_matrix
(
ctx
)
;
_mesa_init_multisample
(
ctx
)
;
_mesa_init_performance_monitors
(
ctx
)
;
_mesa_init_performance_queries
(
ctx
)
;
_mesa_init_pipeline
(
ctx
)
;
_mesa_init_pixel
(
ctx
)
;
_mesa_init_pixelstore
(
ctx
)
;
_mesa_init_point
(
ctx
)
;
_mesa_init_polygon
(
ctx
)
;
_mesa_init_program
(
ctx
)
;
_mesa_init_queryobj
(
ctx
)
;
_mesa_init_sync
(
ctx
)
;
_mesa_init_rastpos
(
ctx
)
;
_mesa_init_scissor
(
ctx
)
;
_mesa_init_shader_state
(
ctx
)
;
_mesa_init_stencil
(
ctx
)
;
_mesa_init_transform
(
ctx
)
;
_mesa_init_transform_feedback
(
ctx
)
;
_mesa_init_varray
(
ctx
)
;
_mesa_init_viewport
(
ctx
)
;
_mesa_init_resident_handles
(
ctx
)
;
if
(
!
_mesa_init_texture
(
ctx
)
)
return
GL_FALSE
;
ctx
-
>
TileRasterOrderIncreasingX
=
GL_TRUE
;
ctx
-
>
TileRasterOrderIncreasingY
=
GL_TRUE
;
ctx
-
>
NewState
=
_NEW_ALL
;
ctx
-
>
NewDriverState
=
~
0
;
ctx
-
>
ErrorValue
=
GL_NO_ERROR
;
ctx
-
>
ShareGroupReset
=
false
;
ctx
-
>
varying_vp_inputs
=
VERT_BIT_ALL
;
return
GL_TRUE
;
}
static
GLboolean
update_default_objects
(
struct
gl_context
*
ctx
)
{
assert
(
ctx
)
;
_mesa_update_default_objects_program
(
ctx
)
;
_mesa_update_default_objects_texture
(
ctx
)
;
_mesa_update_default_objects_buffer_objects
(
ctx
)
;
return
GL_TRUE
;
}
#
if
!
defined
(
_WIN32
)
#
define
USE_GLAPI_NOP_FEATURES
0
#
else
#
define
USE_GLAPI_NOP_FEATURES
1
#
endif
#
if
USE_GLAPI_NOP_FEATURES
static
void
nop_handler
(
const
char
*
name
)
{
GET_CURRENT_CONTEXT
(
ctx
)
;
if
(
ctx
)
{
_mesa_error
(
ctx
GL_INVALID_OPERATION
"
%
s
(
invalid
call
)
"
name
)
;
}
#
ifndef
NDEBUG
else
if
(
getenv
(
"
MESA_DEBUG
"
)
|
|
getenv
(
"
LIBGL_DEBUG
"
)
)
{
fprintf
(
stderr
"
GL
User
Error
:
gl
%
s
called
without
a
rendering
context
\
n
"
name
)
;
fflush
(
stderr
)
;
}
#
endif
}
#
endif
#
if
defined
(
_WIN32
)
static
void
GLAPIENTRY
nop_glFlush
(
void
)
{
}
#
endif
#
if
!
USE_GLAPI_NOP_FEATURES
static
int
generic_nop
(
void
)
{
GET_CURRENT_CONTEXT
(
ctx
)
;
_mesa_error
(
ctx
GL_INVALID_OPERATION
"
unsupported
function
called
"
"
(
unsupported
extension
or
deprecated
function
?
)
"
)
;
return
0
;
}
#
endif
struct
_glapi_table
*
_mesa_new_nop_table
(
unsigned
numEntries
)
{
struct
_glapi_table
*
table
;
#
if
!
USE_GLAPI_NOP_FEATURES
table
=
malloc
(
numEntries
*
sizeof
(
_glapi_proc
)
)
;
if
(
table
)
{
_glapi_proc
*
entry
=
(
_glapi_proc
*
)
table
;
unsigned
i
;
for
(
i
=
0
;
i
<
numEntries
;
i
+
+
)
{
entry
[
i
]
=
(
_glapi_proc
)
generic_nop
;
}
}
#
else
table
=
_glapi_new_nop_table
(
numEntries
)
;
#
endif
return
table
;
}
struct
_glapi_table
*
_mesa_alloc_dispatch_table
(
void
)
{
int
numEntries
=
MAX2
(
_glapi_get_dispatch_table_size
(
)
_gloffset_COUNT
)
;
struct
_glapi_table
*
table
=
_mesa_new_nop_table
(
numEntries
)
;
#
if
defined
(
_WIN32
)
if
(
table
)
{
SET_Flush
(
table
nop_glFlush
)
;
}
#
endif
#
if
USE_GLAPI_NOP_FEATURES
_glapi_set_nop_handler
(
nop_handler
)
;
#
endif
return
table
;
}
static
struct
_glapi_table
*
create_beginend_table
(
const
struct
gl_context
*
ctx
)
{
struct
_glapi_table
*
table
;
table
=
_mesa_alloc_dispatch_table
(
)
;
if
(
!
table
)
return
NULL
;
#
define
COPY_DISPATCH
(
func
)
SET_
#
#
func
(
table
GET_
#
#
func
(
ctx
-
>
Exec
)
)
COPY_DISPATCH
(
GenLists
)
;
COPY_DISPATCH
(
IsProgram
)
;
COPY_DISPATCH
(
IsVertexArray
)
;
COPY_DISPATCH
(
IsBuffer
)
;
COPY_DISPATCH
(
IsEnabled
)
;
COPY_DISPATCH
(
IsEnabledi
)
;
COPY_DISPATCH
(
IsRenderbuffer
)
;
COPY_DISPATCH
(
IsFramebuffer
)
;
COPY_DISPATCH
(
CheckFramebufferStatus
)
;
COPY_DISPATCH
(
RenderMode
)
;
COPY_DISPATCH
(
GetString
)
;
COPY_DISPATCH
(
GetStringi
)
;
COPY_DISPATCH
(
GetPointerv
)
;
COPY_DISPATCH
(
IsQuery
)
;
COPY_DISPATCH
(
IsSampler
)
;
COPY_DISPATCH
(
IsSync
)
;
COPY_DISPATCH
(
IsTexture
)
;
COPY_DISPATCH
(
IsTransformFeedback
)
;
COPY_DISPATCH
(
DeleteQueries
)
;
COPY_DISPATCH
(
AreTexturesResident
)
;
COPY_DISPATCH
(
FenceSync
)
;
COPY_DISPATCH
(
ClientWaitSync
)
;
COPY_DISPATCH
(
MapBuffer
)
;
COPY_DISPATCH
(
UnmapBuffer
)
;
COPY_DISPATCH
(
MapBufferRange
)
;
COPY_DISPATCH
(
ObjectPurgeableAPPLE
)
;
COPY_DISPATCH
(
ObjectUnpurgeableAPPLE
)
;
_mesa_loopback_init_api_table
(
ctx
table
)
;
return
table
;
}
void
_mesa_initialize_dispatch_tables
(
struct
gl_context
*
ctx
)
{
_mesa_initialize_exec_table
(
ctx
)
;
if
(
ctx
-
>
Save
)
_mesa_initialize_save_table
(
ctx
)
;
}
GLboolean
_mesa_initialize_context
(
struct
gl_context
*
ctx
gl_api
api
const
struct
gl_config
*
visual
struct
gl_context
*
share_list
const
struct
dd_function_table
*
driverFunctions
)
{
struct
gl_shared_state
*
shared
;
int
i
;
assert
(
driverFunctions
-
>
NewTextureObject
)
;
assert
(
driverFunctions
-
>
FreeTextureImageBuffer
)
;
ctx
-
>
API
=
api
;
ctx
-
>
DrawBuffer
=
NULL
;
ctx
-
>
ReadBuffer
=
NULL
;
ctx
-
>
WinSysDrawBuffer
=
NULL
;
ctx
-
>
WinSysReadBuffer
=
NULL
;
if
(
visual
)
{
ctx
-
>
Visual
=
*
visual
;
ctx
-
>
HasConfig
=
GL_TRUE
;
}
else
{
memset
(
&
ctx
-
>
Visual
0
sizeof
ctx
-
>
Visual
)
;
ctx
-
>
HasConfig
=
GL_FALSE
;
}
_mesa_override_gl_version
(
ctx
)
;
one_time_init
(
ctx
)
;
ctx
-
>
Driver
=
*
driverFunctions
;
if
(
share_list
)
{
shared
=
share_list
-
>
Shared
;
}
else
{
shared
=
_mesa_alloc_shared_state
(
ctx
)
;
if
(
!
shared
)
return
GL_FALSE
;
}
_mesa_reference_shared_state
(
ctx
&
ctx
-
>
Shared
shared
)
;
if
(
!
init_attrib_groups
(
ctx
)
)
goto
fail
;
if
(
env_var_as_boolean
(
"
MESA_NO_ERROR
"
false
)
)
{
#
if
!
defined
(
_WIN32
)
if
(
geteuid
(
)
=
=
getuid
(
)
)
#
endif
ctx
-
>
Const
.
ContextFlags
|
=
GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR
;
}
ctx
-
>
OutsideBeginEnd
=
_mesa_alloc_dispatch_table
(
)
;
if
(
!
ctx
-
>
OutsideBeginEnd
)
goto
fail
;
ctx
-
>
Exec
=
ctx
-
>
OutsideBeginEnd
;
ctx
-
>
CurrentClientDispatch
=
ctx
-
>
CurrentServerDispatch
=
ctx
-
>
OutsideBeginEnd
;
ctx
-
>
FragmentProgram
.
_MaintainTexEnvProgram
=
(
getenv
(
"
MESA_TEX_PROG
"
)
!
=
NULL
)
;
ctx
-
>
VertexProgram
.
_MaintainTnlProgram
=
(
getenv
(
"
MESA_TNL_PROG
"
)
!
=
NULL
)
;
if
(
ctx
-
>
VertexProgram
.
_MaintainTnlProgram
)
{
ctx
-
>
FragmentProgram
.
_MaintainTexEnvProgram
=
GL_TRUE
;
}
memset
(
&
ctx
-
>
TextureFormatSupported
GL_TRUE
sizeof
(
ctx
-
>
TextureFormatSupported
)
)
;
switch
(
ctx
-
>
API
)
{
case
API_OPENGL_COMPAT
:
ctx
-
>
BeginEnd
=
create_beginend_table
(
ctx
)
;
ctx
-
>
Save
=
_mesa_alloc_dispatch_table
(
)
;
if
(
!
ctx
-
>
BeginEnd
|
|
!
ctx
-
>
Save
)
goto
fail
;
case
API_OPENGL_CORE
:
break
;
case
API_OPENGLES
:
for
(
i
=
0
;
i
<
ARRAY_SIZE
(
ctx
-
>
Texture
.
FixedFuncUnit
)
;
i
+
+
)
{
struct
gl_fixedfunc_texture_unit
*
texUnit
=
&
ctx
-
>
Texture
.
FixedFuncUnit
[
i
]
;
texUnit
-
>
GenS
.
Mode
=
GL_REFLECTION_MAP_NV
;
texUnit
-
>
GenT
.
Mode
=
GL_REFLECTION_MAP_NV
;
texUnit
-
>
GenR
.
Mode
=
GL_REFLECTION_MAP_NV
;
texUnit
-
>
GenS
.
_ModeBit
=
TEXGEN_REFLECTION_MAP_NV
;
texUnit
-
>
GenT
.
_ModeBit
=
TEXGEN_REFLECTION_MAP_NV
;
texUnit
-
>
GenR
.
_ModeBit
=
TEXGEN_REFLECTION_MAP_NV
;
}
break
;
case
API_OPENGLES2
:
ctx
-
>
FragmentProgram
.
_MaintainTexEnvProgram
=
GL_TRUE
;
ctx
-
>
VertexProgram
.
_MaintainTnlProgram
=
GL_TRUE
;
break
;
}
ctx
-
>
FirstTimeCurrent
=
GL_TRUE
;
return
GL_TRUE
;
fail
:
_mesa_reference_shared_state
(
ctx
&
ctx
-
>
Shared
NULL
)
;
free
(
ctx
-
>
BeginEnd
)
;
free
(
ctx
-
>
OutsideBeginEnd
)
;
free
(
ctx
-
>
Save
)
;
return
GL_FALSE
;
}
void
_mesa_free_context_data
(
struct
gl_context
*
ctx
)
{
if
(
!
_mesa_get_current_context
(
)
)
{
_mesa_make_current
(
ctx
NULL
NULL
)
;
}
_mesa_reference_framebuffer
(
&
ctx
-
>
WinSysDrawBuffer
NULL
)
;
_mesa_reference_framebuffer
(
&
ctx
-
>
WinSysReadBuffer
NULL
)
;
_mesa_reference_framebuffer
(
&
ctx
-
>
DrawBuffer
NULL
)
;
_mesa_reference_framebuffer
(
&
ctx
-
>
ReadBuffer
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
VertexProgram
.
Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
VertexProgram
.
_Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
VertexProgram
.
_TnlProgram
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
TessCtrlProgram
.
_Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
TessEvalProgram
.
_Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
GeometryProgram
.
_Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
FragmentProgram
.
Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
FragmentProgram
.
_Current
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
FragmentProgram
.
_TexEnvProgram
NULL
)
;
_mesa_reference_program
(
ctx
&
ctx
-
>
ComputeProgram
.
_Current
NULL
)
;
_mesa_reference_vao
(
ctx
&
ctx
-
>
Array
.
VAO
NULL
)
;
_mesa_reference_vao
(
ctx
&
ctx
-
>
Array
.
DefaultVAO
NULL
)
;
_mesa_reference_vao
(
ctx
&
ctx
-
>
Array
.
_EmptyVAO
NULL
)
;
_mesa_reference_vao
(
ctx
&
ctx
-
>
Array
.
_DrawVAO
NULL
)
;
_mesa_free_attrib_data
(
ctx
)
;
_mesa_free_buffer_objects
(
ctx
)
;
_mesa_free_eval_data
(
ctx
)
;
_mesa_free_texture_data
(
ctx
)
;
_mesa_free_image_textures
(
ctx
)
;
_mesa_free_matrix_data
(
ctx
)
;
_mesa_free_pipeline_data
(
ctx
)
;
_mesa_free_program_data
(
ctx
)
;
_mesa_free_shader_state
(
ctx
)
;
_mesa_free_queryobj_data
(
ctx
)
;
_mesa_free_sync_data
(
ctx
)
;
_mesa_free_varray_data
(
ctx
)
;
_mesa_free_transform_feedback
(
ctx
)
;
_mesa_free_performance_monitors
(
ctx
)
;
_mesa_free_performance_queries
(
ctx
)
;
_mesa_free_resident_handles
(
ctx
)
;
_mesa_reference_buffer_object
(
ctx
&
ctx
-
>
Pack
.
BufferObj
NULL
)
;
_mesa_reference_buffer_object
(
ctx
&
ctx
-
>
Unpack
.
BufferObj
NULL
)
;
_mesa_reference_buffer_object
(
ctx
&
ctx
-
>
DefaultPacking
.
BufferObj
NULL
)
;
_mesa_reference_buffer_object
(
ctx
&
ctx
-
>
Array
.
ArrayBufferObj
NULL
)
;
free
(
ctx
-
>
BeginEnd
)
;
free
(
ctx
-
>
OutsideBeginEnd
)
;
free
(
ctx
-
>
Save
)
;
free
(
ctx
-
>
ContextLost
)
;
free
(
ctx
-
>
MarshalExec
)
;
_mesa_reference_shared_state
(
ctx
&
ctx
-
>
Shared
NULL
)
;
_mesa_free_display_list_data
(
ctx
)
;
_mesa_free_errors_data
(
ctx
)
;
free
(
(
void
*
)
ctx
-
>
Extensions
.
String
)
;
free
(
ctx
-
>
VersionString
)
;
ralloc_free
(
ctx
-
>
SoftFP64
)
;
if
(
ctx
=
=
_mesa_get_current_context
(
)
)
{
_mesa_make_current
(
NULL
NULL
NULL
)
;
}
if
(
ctx
-
>
shader_builtin_ref
)
{
_mesa_glsl_builtin_functions_decref
(
)
;
ctx
-
>
shader_builtin_ref
=
false
;
}
free
(
ctx
-
>
Const
.
SpirVExtensions
)
;
}
void
_mesa_destroy_context
(
struct
gl_context
*
ctx
)
{
if
(
ctx
)
{
_mesa_free_context_data
(
ctx
)
;
free
(
(
void
*
)
ctx
)
;
}
}
void
_mesa_copy_context
(
const
struct
gl_context
*
src
struct
gl_context
*
dst
GLuint
mask
)
{
if
(
mask
&
GL_ACCUM_BUFFER_BIT
)
{
dst
-
>
Accum
=
src
-
>
Accum
;
}
if
(
mask
&
GL_COLOR_BUFFER_BIT
)
{
dst
-
>
Color
=
src
-
>
Color
;
}
if
(
mask
&
GL_CURRENT_BIT
)
{
dst
-
>
Current
=
src
-
>
Current
;
}
if
(
mask
&
GL_DEPTH_BUFFER_BIT
)
{
dst
-
>
Depth
=
src
-
>
Depth
;
}
if
(
mask
&
GL_ENABLE_BIT
)
{
}
if
(
mask
&
GL_EVAL_BIT
)
{
dst
-
>
Eval
=
src
-
>
Eval
;
}
if
(
mask
&
GL_FOG_BIT
)
{
dst
-
>
Fog
=
src
-
>
Fog
;
}
if
(
mask
&
GL_HINT_BIT
)
{
dst
-
>
Hint
=
src
-
>
Hint
;
}
if
(
mask
&
GL_LIGHTING_BIT
)
{
dst
-
>
Light
=
src
-
>
Light
;
}
if
(
mask
&
GL_LINE_BIT
)
{
dst
-
>
Line
=
src
-
>
Line
;
}
if
(
mask
&
GL_LIST_BIT
)
{
dst
-
>
List
=
src
-
>
List
;
}
if
(
mask
&
GL_PIXEL_MODE_BIT
)
{
dst
-
>
Pixel
=
src
-
>
Pixel
;
}
if
(
mask
&
GL_POINT_BIT
)
{
dst
-
>
Point
=
src
-
>
Point
;
}
if
(
mask
&
GL_POLYGON_BIT
)
{
dst
-
>
Polygon
=
src
-
>
Polygon
;
}
if
(
mask
&
GL_POLYGON_STIPPLE_BIT
)
{
GLuint
i
;
for
(
i
=
0
;
i
<
32
;
i
+
+
)
{
dst
-
>
PolygonStipple
[
i
]
=
src
-
>
PolygonStipple
[
i
]
;
}
}
if
(
mask
&
GL_SCISSOR_BIT
)
{
dst
-
>
Scissor
=
src
-
>
Scissor
;
}
if
(
mask
&
GL_STENCIL_BUFFER_BIT
)
{
dst
-
>
Stencil
=
src
-
>
Stencil
;
}
if
(
mask
&
GL_TEXTURE_BIT
)
{
_mesa_copy_texture_state
(
src
dst
)
;
}
if
(
mask
&
GL_TRANSFORM_BIT
)
{
dst
-
>
Transform
=
src
-
>
Transform
;
}
if
(
mask
&
GL_VIEWPORT_BIT
)
{
unsigned
i
;
for
(
i
=
0
;
i
<
src
-
>
Const
.
MaxViewports
;
i
+
+
)
{
dst
-
>
ViewportArray
[
i
]
=
src
-
>
ViewportArray
[
i
]
;
}
}
dst
-
>
NewState
=
_NEW_ALL
;
dst
-
>
NewDriverState
=
~
0
;
}
static
GLboolean
check_compatible
(
const
struct
gl_context
*
ctx
const
struct
gl_framebuffer
*
buffer
)
{
const
struct
gl_config
*
ctxvis
=
&
ctx
-
>
Visual
;
const
struct
gl_config
*
bufvis
=
&
buffer
-
>
Visual
;
if
(
buffer
=
=
_mesa_get_incomplete_framebuffer
(
)
)
return
GL_TRUE
;
#
define
check_component
(
foo
)
\
if
(
ctxvis
-
>
foo
&
&
bufvis
-
>
foo
&
&
\
ctxvis
-
>
foo
!
=
bufvis
-
>
foo
)
\
return
GL_FALSE
check_component
(
redShift
)
;
check_component
(
greenShift
)
;
check_component
(
blueShift
)
;
check_component
(
redBits
)
;
check_component
(
greenBits
)
;
check_component
(
blueBits
)
;
check_component
(
depthBits
)
;
check_component
(
stencilBits
)
;
#
undef
check_component
return
GL_TRUE
;
}
static
void
check_init_viewport
(
struct
gl_context
*
ctx
GLuint
width
GLuint
height
)
{
if
(
!
ctx
-
>
ViewportInitialized
&
&
width
>
0
&
&
height
>
0
)
{
unsigned
i
;
ctx
-
>
ViewportInitialized
=
GL_TRUE
;
for
(
i
=
0
;
i
<
MAX_VIEWPORTS
;
i
+
+
)
{
_mesa_set_viewport
(
ctx
i
0
0
width
height
)
;
_mesa_set_scissor
(
ctx
i
0
0
width
height
)
;
}
}
}
static
void
handle_first_current
(
struct
gl_context
*
ctx
)
{
if
(
ctx
-
>
Version
=
=
0
|
|
!
ctx
-
>
DrawBuffer
)
{
return
;
}
check_context_limits
(
ctx
)
;
_mesa_update_vertex_processing_mode
(
ctx
)
;
if
(
!
ctx
-
>
HasConfig
&
&
_mesa_is_desktop_gl
(
ctx
)
)
{
if
(
ctx
-
>
DrawBuffer
!
=
_mesa_get_incomplete_framebuffer
(
)
)
{
GLenum16
buffer
;
if
(
ctx
-
>
DrawBuffer
-
>
Visual
.
doubleBufferMode
)
buffer
=
GL_BACK
;
else
buffer
=
GL_FRONT
;
_mesa_drawbuffers
(
ctx
ctx
-
>
DrawBuffer
1
&
buffer
NULL
)
;
}
if
(
ctx
-
>
ReadBuffer
!
=
_mesa_get_incomplete_framebuffer
(
)
)
{
gl_buffer_index
bufferIndex
;
GLenum
buffer
;
if
(
ctx
-
>
ReadBuffer
-
>
Visual
.
doubleBufferMode
)
{
buffer
=
GL_BACK
;
bufferIndex
=
BUFFER_BACK_LEFT
;
}
else
{
buffer
=
GL_FRONT
;
bufferIndex
=
BUFFER_FRONT_LEFT
;
}
_mesa_readbuffer
(
ctx
ctx
-
>
ReadBuffer
buffer
bufferIndex
)
;
}
}
{
const
bool
is_forward_compatible_context
=
ctx
-
>
Const
.
ContextFlags
&
GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT
;
ctx
-
>
_AttribZeroAliasesVertex
=
(
ctx
-
>
API
=
=
API_OPENGLES
|
|
(
ctx
-
>
API
=
=
API_OPENGL_COMPAT
&
&
!
is_forward_compatible_context
)
)
;
}
if
(
getenv
(
"
MESA_INFO
"
)
)
{
_mesa_print_info
(
ctx
)
;
}
}
GLboolean
_mesa_make_current
(
struct
gl_context
*
newCtx
struct
gl_framebuffer
*
drawBuffer
struct
gl_framebuffer
*
readBuffer
)
{
GET_CURRENT_CONTEXT
(
curCtx
)
;
if
(
MESA_VERBOSE
&
VERBOSE_API
)
_mesa_debug
(
newCtx
"
_mesa_make_current
(
)
\
n
"
)
;
if
(
newCtx
&
&
drawBuffer
&
&
newCtx
-
>
WinSysDrawBuffer
!
=
drawBuffer
)
{
if
(
!
check_compatible
(
newCtx
drawBuffer
)
)
{
_mesa_warning
(
newCtx
"
MakeCurrent
:
incompatible
visuals
for
context
and
drawbuffer
"
)
;
return
GL_FALSE
;
}
}
if
(
newCtx
&
&
readBuffer
&
&
newCtx
-
>
WinSysReadBuffer
!
=
readBuffer
)
{
if
(
!
check_compatible
(
newCtx
readBuffer
)
)
{
_mesa_warning
(
newCtx
"
MakeCurrent
:
incompatible
visuals
for
context
and
readbuffer
"
)
;
return
GL_FALSE
;
}
}
if
(
curCtx
&
&
(
curCtx
-
>
WinSysDrawBuffer
|
|
curCtx
-
>
WinSysReadBuffer
)
&
&
curCtx
!
=
newCtx
&
&
curCtx
-
>
Const
.
ContextReleaseBehavior
=
=
GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH
)
{
_mesa_flush
(
curCtx
)
;
}
_glapi_check_multithread
(
)
;
if
(
!
newCtx
)
{
_glapi_set_dispatch
(
NULL
)
;
if
(
curCtx
)
{
_mesa_reference_framebuffer
(
&
curCtx
-
>
WinSysDrawBuffer
NULL
)
;
_mesa_reference_framebuffer
(
&
curCtx
-
>
WinSysReadBuffer
NULL
)
;
}
_glapi_set_context
(
NULL
)
;
assert
(
_mesa_get_current_context
(
)
=
=
NULL
)
;
}
else
{
_glapi_set_context
(
(
void
*
)
newCtx
)
;
assert
(
_mesa_get_current_context
(
)
=
=
newCtx
)
;
_glapi_set_dispatch
(
newCtx
-
>
CurrentClientDispatch
)
;
if
(
drawBuffer
&
&
readBuffer
)
{
assert
(
_mesa_is_winsys_fbo
(
drawBuffer
)
)
;
assert
(
_mesa_is_winsys_fbo
(
readBuffer
)
)
;
_mesa_reference_framebuffer
(
&
newCtx
-
>
WinSysDrawBuffer
drawBuffer
)
;
_mesa_reference_framebuffer
(
&
newCtx
-
>
WinSysReadBuffer
readBuffer
)
;
if
(
!
newCtx
-
>
DrawBuffer
|
|
_mesa_is_winsys_fbo
(
newCtx
-
>
DrawBuffer
)
)
{
_mesa_reference_framebuffer
(
&
newCtx
-
>
DrawBuffer
drawBuffer
)
;
_mesa_update_draw_buffers
(
newCtx
)
;
}
if
(
!
newCtx
-
>
ReadBuffer
|
|
_mesa_is_winsys_fbo
(
newCtx
-
>
ReadBuffer
)
)
{
_mesa_reference_framebuffer
(
&
newCtx
-
>
ReadBuffer
readBuffer
)
;
if
(
_mesa_is_gles
(
newCtx
)
&
&
!
newCtx
-
>
ReadBuffer
-
>
Visual
.
doubleBufferMode
)
if
(
newCtx
-
>
ReadBuffer
-
>
ColorReadBuffer
=
=
GL_FRONT
)
newCtx
-
>
ReadBuffer
-
>
ColorReadBuffer
=
GL_BACK
;
}
newCtx
-
>
NewState
|
=
_NEW_BUFFERS
;
check_init_viewport
(
newCtx
drawBuffer
-
>
Width
drawBuffer
-
>
Height
)
;
}
if
(
newCtx
-
>
FirstTimeCurrent
)
{
handle_first_current
(
newCtx
)
;
newCtx
-
>
FirstTimeCurrent
=
GL_FALSE
;
}
}
return
GL_TRUE
;
}
GLboolean
_mesa_share_state
(
struct
gl_context
*
ctx
struct
gl_context
*
ctxToShare
)
{
if
(
ctx
&
&
ctxToShare
&
&
ctx
-
>
Shared
&
&
ctxToShare
-
>
Shared
)
{
struct
gl_shared_state
*
oldShared
=
NULL
;
_mesa_reference_shared_state
(
ctx
&
oldShared
ctx
-
>
Shared
)
;
_mesa_reference_shared_state
(
ctx
&
ctx
-
>
Shared
ctxToShare
-
>
Shared
)
;
update_default_objects
(
ctx
)
;
_mesa_reference_shared_state
(
ctx
&
oldShared
NULL
)
;
return
GL_TRUE
;
}
else
{
return
GL_FALSE
;
}
}
struct
gl_context
*
_mesa_get_current_context
(
void
)
{
return
(
struct
gl_context
*
)
_glapi_get_context
(
)
;
}
struct
_glapi_table
*
_mesa_get_dispatch
(
struct
gl_context
*
ctx
)
{
return
ctx
-
>
CurrentClientDispatch
;
}
void
_mesa_flush
(
struct
gl_context
*
ctx
)
{
FLUSH_VERTICES
(
ctx
0
)
;
FLUSH_CURRENT
(
ctx
0
)
;
if
(
ctx
-
>
Driver
.
Flush
)
{
ctx
-
>
Driver
.
Flush
(
ctx
)
;
}
}
void
GLAPIENTRY
_mesa_Finish
(
void
)
{
GET_CURRENT_CONTEXT
(
ctx
)
;
ASSERT_OUTSIDE_BEGIN_END
(
ctx
)
;
FLUSH_VERTICES
(
ctx
0
)
;
FLUSH_CURRENT
(
ctx
0
)
;
if
(
ctx
-
>
Driver
.
Finish
)
{
ctx
-
>
Driver
.
Finish
(
ctx
)
;
}
}
void
GLAPIENTRY
_mesa_Flush
(
void
)
{
GET_CURRENT_CONTEXT
(
ctx
)
;
ASSERT_OUTSIDE_BEGIN_END
(
ctx
)
;
_mesa_flush
(
ctx
)
;
}
