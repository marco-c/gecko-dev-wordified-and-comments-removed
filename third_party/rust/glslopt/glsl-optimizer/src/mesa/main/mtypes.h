#
ifndef
MTYPES_H
#
define
MTYPES_H
#
include
<
stdint
.
h
>
#
include
<
stdbool
.
h
>
#
include
"
c11
/
threads
.
h
"
#
include
"
main
/
glheader
.
h
"
#
include
"
main
/
glthread
.
h
"
#
include
"
main
/
menums
.
h
"
#
include
"
main
/
config
.
h
"
#
include
"
glapi
/
glapi
.
h
"
#
include
"
math
/
m_matrix
.
h
"
#
include
"
compiler
/
shader_enums
.
h
"
#
include
"
compiler
/
shader_info
.
h
"
#
include
"
main
/
formats
.
h
"
#
include
"
compiler
/
glsl
/
list
.
h
"
#
include
"
util
/
simple_mtx
.
h
"
#
include
"
util
/
u_dynarray
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
define
GET_COLORMASK_BIT
(
mask
buf
chan
)
(
(
(
mask
)
>
>
(
4
*
(
buf
)
+
(
chan
)
)
)
&
0x1
)
#
define
GET_COLORMASK
(
mask
buf
)
(
(
(
mask
)
>
>
(
4
*
(
buf
)
)
)
&
0xf
)
struct
_mesa_HashTable
;
struct
gl_attrib_node
;
struct
gl_list_extensions
;
struct
gl_meta_state
;
struct
gl_program_cache
;
struct
gl_texture_object
;
struct
gl_debug_state
;
struct
gl_context
;
struct
st_context
;
struct
gl_uniform_storage
;
struct
prog_instruction
;
struct
gl_program_parameter_list
;
struct
gl_shader_spirv_data
;
struct
set
;
struct
shader_includes
;
struct
vbo_context
;
#
define
PRIM_MAX
GL_PATCHES
#
define
PRIM_OUTSIDE_BEGIN_END
(
PRIM_MAX
+
1
)
#
define
PRIM_UNKNOWN
(
PRIM_MAX
+
2
)
static
inline
GLboolean
_mesa_varying_slot_in_fs
(
gl_varying_slot
slot
)
{
switch
(
slot
)
{
case
VARYING_SLOT_PSIZ
:
case
VARYING_SLOT_BFC0
:
case
VARYING_SLOT_BFC1
:
case
VARYING_SLOT_EDGE
:
case
VARYING_SLOT_CLIP_VERTEX
:
case
VARYING_SLOT_LAYER
:
case
VARYING_SLOT_TESS_LEVEL_OUTER
:
case
VARYING_SLOT_TESS_LEVEL_INNER
:
case
VARYING_SLOT_BOUNDING_BOX0
:
case
VARYING_SLOT_BOUNDING_BOX1
:
case
VARYING_SLOT_VIEWPORT_MASK
:
return
GL_FALSE
;
default
:
return
GL_TRUE
;
}
}
#
define
BUFFER_BIT_FRONT_LEFT
(
1
<
<
BUFFER_FRONT_LEFT
)
#
define
BUFFER_BIT_BACK_LEFT
(
1
<
<
BUFFER_BACK_LEFT
)
#
define
BUFFER_BIT_FRONT_RIGHT
(
1
<
<
BUFFER_FRONT_RIGHT
)
#
define
BUFFER_BIT_BACK_RIGHT
(
1
<
<
BUFFER_BACK_RIGHT
)
#
define
BUFFER_BIT_AUX0
(
1
<
<
BUFFER_AUX0
)
#
define
BUFFER_BIT_AUX1
(
1
<
<
BUFFER_AUX1
)
#
define
BUFFER_BIT_AUX2
(
1
<
<
BUFFER_AUX2
)
#
define
BUFFER_BIT_AUX3
(
1
<
<
BUFFER_AUX3
)
#
define
BUFFER_BIT_DEPTH
(
1
<
<
BUFFER_DEPTH
)
#
define
BUFFER_BIT_STENCIL
(
1
<
<
BUFFER_STENCIL
)
#
define
BUFFER_BIT_ACCUM
(
1
<
<
BUFFER_ACCUM
)
#
define
BUFFER_BIT_COLOR0
(
1
<
<
BUFFER_COLOR0
)
#
define
BUFFER_BIT_COLOR1
(
1
<
<
BUFFER_COLOR1
)
#
define
BUFFER_BIT_COLOR2
(
1
<
<
BUFFER_COLOR2
)
#
define
BUFFER_BIT_COLOR3
(
1
<
<
BUFFER_COLOR3
)
#
define
BUFFER_BIT_COLOR4
(
1
<
<
BUFFER_COLOR4
)
#
define
BUFFER_BIT_COLOR5
(
1
<
<
BUFFER_COLOR5
)
#
define
BUFFER_BIT_COLOR6
(
1
<
<
BUFFER_COLOR6
)
#
define
BUFFER_BIT_COLOR7
(
1
<
<
BUFFER_COLOR7
)
#
define
BUFFER_BITS_COLOR
(
BUFFER_BIT_FRONT_LEFT
|
\
BUFFER_BIT_BACK_LEFT
|
\
BUFFER_BIT_FRONT_RIGHT
|
\
BUFFER_BIT_BACK_RIGHT
|
\
BUFFER_BIT_AUX0
|
\
BUFFER_BIT_COLOR0
|
\
BUFFER_BIT_COLOR1
|
\
BUFFER_BIT_COLOR2
|
\
BUFFER_BIT_COLOR3
|
\
BUFFER_BIT_COLOR4
|
\
BUFFER_BIT_COLOR5
|
\
BUFFER_BIT_COLOR6
|
\
BUFFER_BIT_COLOR7
)
#
define
BUFFER_BITS_DEPTH_STENCIL
(
BUFFER_BIT_DEPTH
|
BUFFER_BIT_STENCIL
)
struct
gl_config
{
GLboolean
floatMode
;
GLuint
doubleBufferMode
;
GLuint
stereoMode
;
GLint
redBits
greenBits
blueBits
alphaBits
;
GLuint
redMask
greenMask
blueMask
alphaMask
;
GLint
redShift
greenShift
blueShift
alphaShift
;
GLint
rgbBits
;
GLint
accumRedBits
accumGreenBits
accumBlueBits
accumAlphaBits
;
GLint
depthBits
;
GLint
stencilBits
;
GLint
numAuxBuffers
;
GLint
level
;
GLint
visualRating
;
GLint
transparentPixel
;
GLint
transparentRed
transparentGreen
transparentBlue
transparentAlpha
;
GLint
transparentIndex
;
GLint
sampleBuffers
;
GLuint
samples
;
GLint
maxPbufferWidth
;
GLint
maxPbufferHeight
;
GLint
maxPbufferPixels
;
GLint
optimalPbufferWidth
;
GLint
optimalPbufferHeight
;
GLint
swapMethod
;
GLint
bindToTextureRgb
;
GLint
bindToTextureRgba
;
GLint
bindToMipmapTexture
;
GLint
bindToTextureTargets
;
GLint
yInverted
;
GLint
sRGBCapable
;
GLuint
mutableRenderBuffer
;
}
;
#
define
MAT_ATTRIB_FRONT_AMBIENT
0
#
define
MAT_ATTRIB_BACK_AMBIENT
1
#
define
MAT_ATTRIB_FRONT_DIFFUSE
2
#
define
MAT_ATTRIB_BACK_DIFFUSE
3
#
define
MAT_ATTRIB_FRONT_SPECULAR
4
#
define
MAT_ATTRIB_BACK_SPECULAR
5
#
define
MAT_ATTRIB_FRONT_EMISSION
6
#
define
MAT_ATTRIB_BACK_EMISSION
7
#
define
MAT_ATTRIB_FRONT_SHININESS
8
#
define
MAT_ATTRIB_BACK_SHININESS
9
#
define
MAT_ATTRIB_FRONT_INDEXES
10
#
define
MAT_ATTRIB_BACK_INDEXES
11
#
define
MAT_ATTRIB_MAX
12
#
define
MAT_ATTRIB_AMBIENT
(
f
)
(
MAT_ATTRIB_FRONT_AMBIENT
+
(
f
)
)
#
define
MAT_ATTRIB_DIFFUSE
(
f
)
(
MAT_ATTRIB_FRONT_DIFFUSE
+
(
f
)
)
#
define
MAT_ATTRIB_SPECULAR
(
f
)
(
MAT_ATTRIB_FRONT_SPECULAR
+
(
f
)
)
#
define
MAT_ATTRIB_EMISSION
(
f
)
(
MAT_ATTRIB_FRONT_EMISSION
+
(
f
)
)
#
define
MAT_ATTRIB_SHININESS
(
f
)
(
MAT_ATTRIB_FRONT_SHININESS
+
(
f
)
)
#
define
MAT_ATTRIB_INDEXES
(
f
)
(
MAT_ATTRIB_FRONT_INDEXES
+
(
f
)
)
#
define
MAT_BIT_FRONT_AMBIENT
(
1
<
<
MAT_ATTRIB_FRONT_AMBIENT
)
#
define
MAT_BIT_BACK_AMBIENT
(
1
<
<
MAT_ATTRIB_BACK_AMBIENT
)
#
define
MAT_BIT_FRONT_DIFFUSE
(
1
<
<
MAT_ATTRIB_FRONT_DIFFUSE
)
#
define
MAT_BIT_BACK_DIFFUSE
(
1
<
<
MAT_ATTRIB_BACK_DIFFUSE
)
#
define
MAT_BIT_FRONT_SPECULAR
(
1
<
<
MAT_ATTRIB_FRONT_SPECULAR
)
#
define
MAT_BIT_BACK_SPECULAR
(
1
<
<
MAT_ATTRIB_BACK_SPECULAR
)
#
define
MAT_BIT_FRONT_EMISSION
(
1
<
<
MAT_ATTRIB_FRONT_EMISSION
)
#
define
MAT_BIT_BACK_EMISSION
(
1
<
<
MAT_ATTRIB_BACK_EMISSION
)
#
define
MAT_BIT_FRONT_SHININESS
(
1
<
<
MAT_ATTRIB_FRONT_SHININESS
)
#
define
MAT_BIT_BACK_SHININESS
(
1
<
<
MAT_ATTRIB_BACK_SHININESS
)
#
define
MAT_BIT_FRONT_INDEXES
(
1
<
<
MAT_ATTRIB_FRONT_INDEXES
)
#
define
MAT_BIT_BACK_INDEXES
(
1
<
<
MAT_ATTRIB_BACK_INDEXES
)
#
define
FRONT_MATERIAL_BITS
(
MAT_BIT_FRONT_EMISSION
|
\
MAT_BIT_FRONT_AMBIENT
|
\
MAT_BIT_FRONT_DIFFUSE
|
\
MAT_BIT_FRONT_SPECULAR
|
\
MAT_BIT_FRONT_SHININESS
|
\
MAT_BIT_FRONT_INDEXES
)
#
define
BACK_MATERIAL_BITS
(
MAT_BIT_BACK_EMISSION
|
\
MAT_BIT_BACK_AMBIENT
|
\
MAT_BIT_BACK_DIFFUSE
|
\
MAT_BIT_BACK_SPECULAR
|
\
MAT_BIT_BACK_SHININESS
|
\
MAT_BIT_BACK_INDEXES
)
#
define
ALL_MATERIAL_BITS
(
FRONT_MATERIAL_BITS
|
BACK_MATERIAL_BITS
)
struct
gl_material
{
GLfloat
Attrib
[
MAT_ATTRIB_MAX
]
[
4
]
;
}
;
#
define
LIGHT_SPOT
0x1
#
define
LIGHT_LOCAL_VIEWER
0x2
#
define
LIGHT_POSITIONAL
0x4
#
define
LIGHT_NEED_VERTICES
(
LIGHT_POSITIONAL
|
LIGHT_LOCAL_VIEWER
)
struct
gl_light
{
GLfloat
Ambient
[
4
]
;
GLfloat
Diffuse
[
4
]
;
GLfloat
Specular
[
4
]
;
GLfloat
EyePosition
[
4
]
;
GLfloat
SpotDirection
[
4
]
;
GLfloat
SpotExponent
;
GLfloat
SpotCutoff
;
GLfloat
_CosCutoff
;
GLfloat
ConstantAttenuation
;
GLfloat
LinearAttenuation
;
GLfloat
QuadraticAttenuation
;
GLboolean
Enabled
;
GLbitfield
_Flags
;
GLfloat
_Position
[
4
]
;
GLfloat
_VP_inf_norm
[
3
]
;
GLfloat
_h_inf_norm
[
3
]
;
GLfloat
_NormSpotDirection
[
4
]
;
GLfloat
_VP_inf_spot_attenuation
;
GLfloat
_MatAmbient
[
2
]
[
3
]
;
GLfloat
_MatDiffuse
[
2
]
[
3
]
;
GLfloat
_MatSpecular
[
2
]
[
3
]
;
}
;
struct
gl_lightmodel
{
GLfloat
Ambient
[
4
]
;
GLboolean
LocalViewer
;
GLboolean
TwoSide
;
GLenum16
ColorControl
;
}
;
struct
gl_accum_attrib
{
GLfloat
ClearColor
[
4
]
;
}
;
union
gl_color_union
{
GLfloat
f
[
4
]
;
GLint
i
[
4
]
;
GLuint
ui
[
4
]
;
}
;
struct
gl_colorbuffer_attrib
{
GLuint
ClearIndex
;
union
gl_color_union
ClearColor
;
GLuint
IndexMask
;
GLbitfield
ColorMask
;
GLenum16
DrawBuffer
[
MAX_DRAW_BUFFERS
]
;
GLboolean
AlphaEnabled
;
GLenum16
AlphaFunc
;
GLfloat
AlphaRefUnclamped
;
GLclampf
AlphaRef
;
GLbitfield
BlendEnabled
;
GLfloat
BlendColorUnclamped
[
4
]
;
GLfloat
BlendColor
[
4
]
;
struct
{
GLenum16
SrcRGB
;
GLenum16
DstRGB
;
GLenum16
SrcA
;
GLenum16
DstA
;
GLenum16
EquationRGB
;
GLenum16
EquationA
;
GLboolean
_UsesDualSrc
;
}
Blend
[
MAX_DRAW_BUFFERS
]
;
GLboolean
_BlendFuncPerBuffer
;
GLboolean
_BlendEquationPerBuffer
;
enum
gl_advanced_blend_mode
_AdvancedBlendMode
;
bool
BlendCoherent
;
GLboolean
IndexLogicOpEnabled
;
GLboolean
ColorLogicOpEnabled
;
GLenum16
LogicOp
;
enum
gl_logicop_mode
_LogicOp
;
GLboolean
DitherFlag
;
GLboolean
_ClampFragmentColor
;
GLenum16
ClampFragmentColor
;
GLenum16
ClampReadColor
;
GLboolean
sRGBEnabled
;
}
;
struct
gl_vertex_format
{
GLenum16
Type
;
GLenum16
Format
;
enum
pipe_format
_PipeFormat
:
16
;
GLubyte
Size
:
5
;
GLubyte
Normalized
:
1
;
GLubyte
Integer
:
1
;
GLubyte
Doubles
:
1
;
GLubyte
_ElementSize
;
}
;
struct
gl_current_attrib
{
GLfloat
Attrib
[
VERT_ATTRIB_MAX
]
[
4
*
2
]
;
GLfloat
RasterPos
[
4
]
;
GLfloat
RasterDistance
;
GLfloat
RasterColor
[
4
]
;
GLfloat
RasterSecondaryColor
[
4
]
;
GLfloat
RasterTexCoords
[
MAX_TEXTURE_COORD_UNITS
]
[
4
]
;
GLboolean
RasterPosValid
;
}
;
struct
gl_depthbuffer_attrib
{
GLenum16
Func
;
GLclampd
Clear
;
GLboolean
Test
;
GLboolean
Mask
;
GLboolean
BoundsTest
;
GLfloat
BoundsMin
BoundsMax
;
}
;
struct
gl_eval_attrib
{
GLboolean
Map1Color4
;
GLboolean
Map1Index
;
GLboolean
Map1Normal
;
GLboolean
Map1TextureCoord1
;
GLboolean
Map1TextureCoord2
;
GLboolean
Map1TextureCoord3
;
GLboolean
Map1TextureCoord4
;
GLboolean
Map1Vertex3
;
GLboolean
Map1Vertex4
;
GLboolean
Map2Color4
;
GLboolean
Map2Index
;
GLboolean
Map2Normal
;
GLboolean
Map2TextureCoord1
;
GLboolean
Map2TextureCoord2
;
GLboolean
Map2TextureCoord3
;
GLboolean
Map2TextureCoord4
;
GLboolean
Map2Vertex3
;
GLboolean
Map2Vertex4
;
GLboolean
AutoNormal
;
GLint
MapGrid1un
;
GLfloat
MapGrid1u1
MapGrid1u2
MapGrid1du
;
GLint
MapGrid2un
MapGrid2vn
;
GLfloat
MapGrid2u1
MapGrid2u2
MapGrid2du
;
GLfloat
MapGrid2v1
MapGrid2v2
MapGrid2dv
;
}
;
enum
gl_fog_mode
{
FOG_NONE
FOG_LINEAR
FOG_EXP
FOG_EXP2
}
;
struct
gl_fog_attrib
{
GLboolean
Enabled
;
GLboolean
ColorSumEnabled
;
uint8_t
_PackedMode
;
uint8_t
_PackedEnabledMode
;
GLfloat
ColorUnclamped
[
4
]
;
GLfloat
Color
[
4
]
;
GLfloat
Density
;
GLfloat
Start
;
GLfloat
End
;
GLfloat
Index
;
GLenum16
Mode
;
GLenum16
FogCoordinateSource
;
GLenum16
FogDistanceMode
;
}
;
struct
gl_hint_attrib
{
GLenum16
PerspectiveCorrection
;
GLenum16
PointSmooth
;
GLenum16
LineSmooth
;
GLenum16
PolygonSmooth
;
GLenum16
Fog
;
GLenum16
TextureCompression
;
GLenum16
GenerateMipmap
;
GLenum16
FragmentShaderDerivative
;
GLuint
MaxShaderCompilerThreads
;
}
;
struct
gl_light_attrib
{
struct
gl_light
Light
[
MAX_LIGHTS
]
;
struct
gl_lightmodel
Model
;
struct
gl_material
Material
;
GLboolean
Enabled
;
GLboolean
ColorMaterialEnabled
;
GLenum16
ShadeModel
;
GLenum16
ProvokingVertex
;
GLenum16
ColorMaterialFace
;
GLenum16
ColorMaterialMode
;
GLbitfield
_ColorMaterialBitmask
;
GLboolean
_ClampVertexColor
;
GLenum16
ClampVertexColor
;
GLbitfield
_EnabledLights
;
GLboolean
_NeedEyeCoords
;
GLboolean
_NeedVertices
;
GLfloat
_BaseColor
[
2
]
[
3
]
;
}
;
struct
gl_line_attrib
{
GLboolean
SmoothFlag
;
GLboolean
StippleFlag
;
GLushort
StipplePattern
;
GLint
StippleFactor
;
GLfloat
Width
;
}
;
struct
gl_list_attrib
{
GLuint
ListBase
;
}
;
struct
gl_multisample_attrib
{
GLboolean
Enabled
;
GLboolean
SampleAlphaToCoverage
;
GLboolean
SampleAlphaToOne
;
GLboolean
SampleCoverage
;
GLboolean
SampleCoverageInvert
;
GLboolean
SampleShading
;
GLboolean
SampleMask
;
GLfloat
SampleCoverageValue
;
GLfloat
MinSampleShadingValue
;
GLbitfield
SampleMaskValue
;
GLenum
SampleAlphaToCoverageDitherControl
;
}
;
struct
gl_pixelmap
{
GLint
Size
;
GLfloat
Map
[
MAX_PIXEL_MAP_TABLE
]
;
}
;
struct
gl_pixelmaps
{
struct
gl_pixelmap
RtoR
;
struct
gl_pixelmap
GtoG
;
struct
gl_pixelmap
BtoB
;
struct
gl_pixelmap
AtoA
;
struct
gl_pixelmap
ItoR
;
struct
gl_pixelmap
ItoG
;
struct
gl_pixelmap
ItoB
;
struct
gl_pixelmap
ItoA
;
struct
gl_pixelmap
ItoI
;
struct
gl_pixelmap
StoS
;
}
;
struct
gl_pixel_attrib
{
GLenum16
ReadBuffer
;
GLfloat
RedBias
RedScale
;
GLfloat
GreenBias
GreenScale
;
GLfloat
BlueBias
BlueScale
;
GLfloat
AlphaBias
AlphaScale
;
GLfloat
DepthBias
DepthScale
;
GLint
IndexShift
IndexOffset
;
GLboolean
MapColorFlag
;
GLboolean
MapStencilFlag
;
GLfloat
ZoomX
ZoomY
;
}
;
struct
gl_point_attrib
{
GLfloat
Size
;
GLfloat
Params
[
3
]
;
GLfloat
MinSize
MaxSize
;
GLfloat
Threshold
;
GLboolean
SmoothFlag
;
GLboolean
_Attenuated
;
GLboolean
PointSprite
;
GLbitfield
CoordReplace
;
GLenum16
SpriteRMode
;
GLenum16
SpriteOrigin
;
}
;
struct
gl_polygon_attrib
{
GLenum16
FrontFace
;
GLenum
FrontMode
;
GLenum
BackMode
;
GLboolean
CullFlag
;
GLboolean
SmoothFlag
;
GLboolean
StippleFlag
;
GLenum16
CullFaceMode
;
GLfloat
OffsetFactor
;
GLfloat
OffsetUnits
;
GLfloat
OffsetClamp
;
GLboolean
OffsetPoint
;
GLboolean
OffsetLine
;
GLboolean
OffsetFill
;
}
;
struct
gl_scissor_rect
{
GLint
X
Y
;
GLsizei
Width
Height
;
}
;
struct
gl_scissor_attrib
{
GLbitfield
EnableFlags
;
struct
gl_scissor_rect
ScissorArray
[
MAX_VIEWPORTS
]
;
GLint
NumWindowRects
;
GLenum16
WindowRectMode
;
struct
gl_scissor_rect
WindowRects
[
MAX_WINDOW_RECTANGLES
]
;
}
;
struct
gl_stencil_attrib
{
GLboolean
Enabled
;
GLboolean
TestTwoSide
;
GLubyte
ActiveFace
;
GLubyte
_BackFace
;
GLenum16
Function
[
3
]
;
GLenum16
FailFunc
[
3
]
;
GLenum16
ZPassFunc
[
3
]
;
GLenum16
ZFailFunc
[
3
]
;
GLint
Ref
[
3
]
;
GLuint
ValueMask
[
3
]
;
GLuint
WriteMask
[
3
]
;
GLuint
Clear
;
}
;
#
define
TEXTURE_2D_MULTISAMPLE_BIT
(
1
<
<
TEXTURE_2D_MULTISAMPLE_INDEX
)
#
define
TEXTURE_2D_MULTISAMPLE_ARRAY_BIT
(
1
<
<
TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX
)
#
define
TEXTURE_CUBE_ARRAY_BIT
(
1
<
<
TEXTURE_CUBE_ARRAY_INDEX
)
#
define
TEXTURE_BUFFER_BIT
(
1
<
<
TEXTURE_BUFFER_INDEX
)
#
define
TEXTURE_2D_ARRAY_BIT
(
1
<
<
TEXTURE_2D_ARRAY_INDEX
)
#
define
TEXTURE_1D_ARRAY_BIT
(
1
<
<
TEXTURE_1D_ARRAY_INDEX
)
#
define
TEXTURE_EXTERNAL_BIT
(
1
<
<
TEXTURE_EXTERNAL_INDEX
)
#
define
TEXTURE_CUBE_BIT
(
1
<
<
TEXTURE_CUBE_INDEX
)
#
define
TEXTURE_3D_BIT
(
1
<
<
TEXTURE_3D_INDEX
)
#
define
TEXTURE_RECT_BIT
(
1
<
<
TEXTURE_RECT_INDEX
)
#
define
TEXTURE_2D_BIT
(
1
<
<
TEXTURE_2D_INDEX
)
#
define
TEXTURE_1D_BIT
(
1
<
<
TEXTURE_1D_INDEX
)
struct
gl_texture_image
{
GLint
InternalFormat
;
GLenum16
_BaseFormat
;
mesa_format
TexFormat
;
GLuint
Border
;
GLuint
Width
;
GLuint
Height
;
GLuint
Depth
;
GLuint
Width2
;
GLuint
Height2
;
GLuint
Depth2
;
GLuint
WidthLog2
;
GLuint
HeightLog2
;
GLuint
DepthLog2
;
GLuint
MaxNumLevels
;
struct
gl_texture_object
*
TexObject
;
GLuint
Level
;
GLuint
Face
;
GLuint
NumSamples
;
GLboolean
FixedSampleLocations
;
}
;
typedef
enum
{
FACE_POS_X
=
0
FACE_NEG_X
=
1
FACE_POS_Y
=
2
FACE_NEG_Y
=
3
FACE_POS_Z
=
4
FACE_NEG_Z
=
5
MAX_FACES
=
6
}
gl_face_index
;
struct
gl_sampler_object
{
simple_mtx_t
Mutex
;
GLuint
Name
;
GLchar
*
Label
;
GLint
RefCount
;
GLenum16
WrapS
;
GLenum16
WrapT
;
GLenum16
WrapR
;
GLenum16
MinFilter
;
GLenum16
MagFilter
;
GLenum16
sRGBDecode
;
union
gl_color_union
BorderColor
;
GLfloat
MinLod
;
GLfloat
MaxLod
;
GLfloat
LodBias
;
GLfloat
MaxAnisotropy
;
GLenum16
CompareMode
;
GLenum16
CompareFunc
;
GLboolean
CubeMapSeamless
;
bool
HandleAllocated
;
struct
util_dynarray
Handles
;
}
;
struct
gl_texture_object
{
simple_mtx_t
Mutex
;
GLint
RefCount
;
GLuint
Name
;
GLenum16
Target
;
GLenum16
DepthMode
;
GLchar
*
Label
;
struct
gl_sampler_object
Sampler
;
gl_texture_index
TargetIndex
;
GLfloat
Priority
;
GLint
MaxLevel
;
GLint
BaseLevel
;
GLbyte
_MaxLevel
;
GLfloat
_MaxLambda
;
GLint
CropRect
[
4
]
;
GLenum
Swizzle
[
4
]
;
GLushort
_Swizzle
;
GLbyte
ImmutableLevels
;
GLboolean
GenerateMipmap
;
GLboolean
_BaseComplete
;
GLboolean
_MipmapComplete
;
GLboolean
_IsIntegerFormat
;
GLboolean
_RenderToTexture
;
GLboolean
Purgeable
;
GLboolean
Immutable
;
GLboolean
_IsFloat
;
GLboolean
_IsHalfFloat
;
bool
StencilSampling
;
bool
HandleAllocated
;
GLubyte
RequiredTextureImageUnits
;
GLubyte
MinLevel
;
GLubyte
NumLevels
;
GLushort
MinLayer
;
GLushort
NumLayers
;
GLenum16
TextureTiling
;
GLenum16
ImageFormatCompatibilityType
;
GLenum16
BufferObjectFormat
;
mesa_format
_BufferObjectFormat
;
struct
gl_buffer_object
*
BufferObject
;
GLintptr
BufferOffset
;
GLsizeiptr
BufferSize
;
struct
gl_texture_image
*
Image
[
MAX_FACES
]
[
MAX_TEXTURE_LEVELS
]
;
struct
util_dynarray
SamplerHandles
;
struct
util_dynarray
ImageHandles
;
}
;
#
define
MAX_COMBINER_TERMS
4
struct
gl_tex_env_combine_state
{
GLenum16
ModeRGB
;
GLenum16
ModeA
;
GLenum16
SourceRGB
[
MAX_COMBINER_TERMS
]
;
GLenum16
SourceA
[
MAX_COMBINER_TERMS
]
;
GLenum16
OperandRGB
[
MAX_COMBINER_TERMS
]
;
GLenum16
OperandA
[
MAX_COMBINER_TERMS
]
;
GLubyte
ScaleShiftRGB
;
GLubyte
ScaleShiftA
;
GLubyte
_NumArgsRGB
;
GLubyte
_NumArgsA
;
}
;
enum
gl_tex_env_mode
{
TEXENV_MODE_REPLACE
TEXENV_MODE_MODULATE
TEXENV_MODE_ADD
TEXENV_MODE_ADD_SIGNED
TEXENV_MODE_INTERPOLATE
TEXENV_MODE_SUBTRACT
TEXENV_MODE_DOT3_RGB
TEXENV_MODE_DOT3_RGB_EXT
TEXENV_MODE_DOT3_RGBA
TEXENV_MODE_DOT3_RGBA_EXT
TEXENV_MODE_MODULATE_ADD_ATI
TEXENV_MODE_MODULATE_SIGNED_ADD_ATI
TEXENV_MODE_MODULATE_SUBTRACT_ATI
TEXENV_MODE_ADD_PRODUCTS_NV
TEXENV_MODE_ADD_PRODUCTS_SIGNED_NV
}
;
enum
gl_tex_env_source
{
TEXENV_SRC_TEXTURE0
TEXENV_SRC_TEXTURE1
TEXENV_SRC_TEXTURE2
TEXENV_SRC_TEXTURE3
TEXENV_SRC_TEXTURE4
TEXENV_SRC_TEXTURE5
TEXENV_SRC_TEXTURE6
TEXENV_SRC_TEXTURE7
TEXENV_SRC_TEXTURE
TEXENV_SRC_PREVIOUS
TEXENV_SRC_PRIMARY_COLOR
TEXENV_SRC_CONSTANT
TEXENV_SRC_ZERO
TEXENV_SRC_ONE
}
;
enum
gl_tex_env_operand
{
TEXENV_OPR_COLOR
TEXENV_OPR_ONE_MINUS_COLOR
TEXENV_OPR_ALPHA
TEXENV_OPR_ONE_MINUS_ALPHA
}
;
struct
gl_tex_env_argument
{
#
ifdef
__GNUC__
__extension__
uint8_t
Source
:
4
;
__extension__
uint8_t
Operand
:
2
;
#
else
uint8_t
Source
;
uint8_t
Operand
;
#
endif
}
;
struct
gl_tex_env_combine_packed
{
uint32_t
ModeRGB
:
4
;
uint32_t
ModeA
:
4
;
uint32_t
ScaleShiftRGB
:
2
;
uint32_t
ScaleShiftA
:
2
;
uint32_t
NumArgsRGB
:
3
;
uint32_t
NumArgsA
:
3
;
struct
gl_tex_env_argument
ArgsRGB
[
MAX_COMBINER_TERMS
]
;
struct
gl_tex_env_argument
ArgsA
[
MAX_COMBINER_TERMS
]
;
}
;
#
define
S_BIT
1
#
define
T_BIT
2
#
define
R_BIT
4
#
define
Q_BIT
8
#
define
STR_BITS
(
S_BIT
|
T_BIT
|
R_BIT
)
#
define
TEXGEN_SPHERE_MAP
0x1
#
define
TEXGEN_OBJ_LINEAR
0x2
#
define
TEXGEN_EYE_LINEAR
0x4
#
define
TEXGEN_REFLECTION_MAP_NV
0x8
#
define
TEXGEN_NORMAL_MAP_NV
0x10
#
define
TEXGEN_NEED_NORMALS
(
TEXGEN_SPHERE_MAP
|
\
TEXGEN_REFLECTION_MAP_NV
|
\
TEXGEN_NORMAL_MAP_NV
)
#
define
TEXGEN_NEED_EYE_COORD
(
TEXGEN_SPHERE_MAP
|
\
TEXGEN_REFLECTION_MAP_NV
|
\
TEXGEN_NORMAL_MAP_NV
|
\
TEXGEN_EYE_LINEAR
)
#
define
ENABLE_TEXGEN
(
unit
)
(
1
<
<
(
unit
)
)
#
define
ENABLE_TEXMAT
(
unit
)
(
1
<
<
(
unit
)
)
struct
gl_texgen
{
GLenum16
Mode
;
GLbitfield8
_ModeBit
;
GLfloat
ObjectPlane
[
4
]
;
GLfloat
EyePlane
[
4
]
;
}
;
struct
gl_texture_unit
{
GLfloat
LodBias
;
GLbitfield
_BoundTextures
;
struct
gl_sampler_object
*
Sampler
;
struct
gl_texture_object
*
CurrentTex
[
NUM_TEXTURE_TARGETS
]
;
struct
gl_texture_object
*
_Current
;
}
;
struct
gl_fixedfunc_texture_unit
{
GLbitfield16
Enabled
;
GLenum16
EnvMode
;
GLclampf
EnvColor
[
4
]
;
GLfloat
EnvColorUnclamped
[
4
]
;
struct
gl_texgen
GenS
;
struct
gl_texgen
GenT
;
struct
gl_texgen
GenR
;
struct
gl_texgen
GenQ
;
GLbitfield8
TexGenEnabled
;
GLbitfield8
_GenFlags
;
struct
gl_tex_env_combine_state
Combine
;
struct
gl_tex_env_combine_state
_EnvMode
;
struct
gl_tex_env_combine_packed
_CurrentCombinePacked
;
struct
gl_tex_env_combine_state
*
_CurrentCombine
;
}
;
struct
gl_texture_attrib
{
struct
gl_texture_object
*
ProxyTex
[
NUM_TEXTURE_TARGETS
]
;
struct
gl_buffer_object
*
BufferObject
;
GLuint
CurrentUnit
;
GLbitfield8
_EnabledCoordUnits
;
GLbitfield8
_TexGenEnabled
;
GLbitfield8
_TexMatEnabled
;
GLbitfield8
_GenFlags
;
GLshort
_MaxEnabledTexImageUnit
;
GLubyte
NumCurrentTexUsed
;
GLboolean
CubeMapSeamless
;
struct
gl_texture_unit
Unit
[
MAX_COMBINED_TEXTURE_IMAGE_UNITS
]
;
struct
gl_fixedfunc_texture_unit
FixedFuncUnit
[
MAX_TEXTURE_COORD_UNITS
]
;
}
;
typedef
GLfloat
gl_clip_plane
[
4
]
;
struct
gl_transform_attrib
{
GLenum16
MatrixMode
;
gl_clip_plane
EyeUserPlane
[
MAX_CLIP_PLANES
]
;
gl_clip_plane
_ClipUserPlane
[
MAX_CLIP_PLANES
]
;
GLbitfield
ClipPlanesEnabled
;
GLboolean
Normalize
;
GLboolean
RescaleNormals
;
GLboolean
RasterPositionUnclipped
;
GLboolean
DepthClampNear
;
GLboolean
DepthClampFar
;
GLenum16
ClipOrigin
;
GLenum16
ClipDepthMode
;
}
;
struct
gl_viewport_attrib
{
GLfloat
X
Y
;
GLfloat
Width
Height
;
GLfloat
Near
Far
;
GLenum16
SwizzleX
SwizzleY
SwizzleZ
SwizzleW
;
}
;
struct
gl_buffer_mapping
{
GLbitfield
AccessFlags
;
GLvoid
*
Pointer
;
GLintptr
Offset
;
GLsizeiptr
Length
;
}
;
typedef
enum
{
USAGE_UNIFORM_BUFFER
=
0x1
USAGE_TEXTURE_BUFFER
=
0x2
USAGE_ATOMIC_COUNTER_BUFFER
=
0x4
USAGE_SHADER_STORAGE_BUFFER
=
0x8
USAGE_TRANSFORM_FEEDBACK_BUFFER
=
0x10
USAGE_PIXEL_PACK_BUFFER
=
0x20
USAGE_ARRAY_BUFFER
=
0x40
USAGE_ELEMENT_ARRAY_BUFFER
=
0x80
USAGE_DISABLE_MINMAX_CACHE
=
0x100
}
gl_buffer_usage
;
struct
gl_buffer_object
{
GLint
RefCount
;
GLuint
Name
;
GLchar
*
Label
;
GLenum16
Usage
;
GLbitfield
StorageFlags
;
GLsizeiptrARB
Size
;
GLubyte
*
Data
;
GLboolean
DeletePending
;
GLboolean
Written
;
GLboolean
Purgeable
;
GLboolean
Immutable
;
gl_buffer_usage
UsageHistory
;
GLuint
NumSubDataCalls
;
GLuint
NumMapBufferWriteCalls
;
struct
gl_buffer_mapping
Mappings
[
MAP_COUNT
]
;
simple_mtx_t
MinMaxCacheMutex
;
struct
hash_table
*
MinMaxCache
;
unsigned
MinMaxCacheHitIndices
;
unsigned
MinMaxCacheMissIndices
;
bool
MinMaxCacheDirty
;
bool
HandleAllocated
;
}
;
struct
gl_pixelstore_attrib
{
GLint
Alignment
;
GLint
RowLength
;
GLint
SkipPixels
;
GLint
SkipRows
;
GLint
ImageHeight
;
GLint
SkipImages
;
GLboolean
SwapBytes
;
GLboolean
LsbFirst
;
GLboolean
Invert
;
GLint
CompressedBlockWidth
;
GLint
CompressedBlockHeight
;
GLint
CompressedBlockDepth
;
GLint
CompressedBlockSize
;
struct
gl_buffer_object
*
BufferObj
;
}
;
typedef
enum
{
ATTRIBUTE_MAP_MODE_IDENTITY
ATTRIBUTE_MAP_MODE_POSITION
ATTRIBUTE_MAP_MODE_GENERIC0
ATTRIBUTE_MAP_MODE_MAX
}
gl_attribute_map_mode
;
struct
gl_array_attributes
{
const
GLubyte
*
Ptr
;
GLuint
RelativeOffset
;
struct
gl_vertex_format
Format
;
GLshort
Stride
;
GLubyte
BufferBindingIndex
;
GLubyte
_EffBufferBindingIndex
;
GLushort
_EffRelativeOffset
;
}
;
struct
gl_vertex_buffer_binding
{
GLintptr
Offset
;
GLsizei
Stride
;
GLuint
InstanceDivisor
;
struct
gl_buffer_object
*
BufferObj
;
GLbitfield
_BoundArrays
;
GLbitfield
_EffBoundArrays
;
GLintptr
_EffOffset
;
}
;
struct
gl_vertex_array_object
{
GLuint
Name
;
GLint
RefCount
;
GLchar
*
Label
;
GLboolean
EverBound
;
bool
SharedAndImmutable
;
struct
gl_array_attributes
VertexAttrib
[
VERT_ATTRIB_MAX
]
;
struct
gl_vertex_buffer_binding
BufferBinding
[
VERT_ATTRIB_MAX
]
;
GLbitfield
VertexAttribBufferMask
;
GLbitfield
NonZeroDivisorMask
;
GLbitfield
Enabled
;
GLbitfield
_EffEnabledVBO
;
GLbitfield
_EffEnabledNonZeroDivisor
;
gl_attribute_map_mode
_AttributeMapMode
;
GLbitfield
NewArrays
;
struct
gl_buffer_object
*
IndexBufferObj
;
}
;
struct
gl_array_attrib
{
struct
gl_vertex_array_object
*
VAO
;
struct
gl_vertex_array_object
*
DefaultVAO
;
struct
gl_vertex_array_object
*
LastLookedUpVAO
;
struct
gl_vertex_array_object
DefaultVAOState
;
struct
_mesa_HashTable
*
Objects
;
GLint
ActiveTexture
;
GLuint
LockFirst
;
GLuint
LockCount
;
GLboolean
PrimitiveRestart
;
GLboolean
PrimitiveRestartFixedIndex
;
GLboolean
_PrimitiveRestart
;
GLuint
RestartIndex
;
GLuint
_RestartIndex
[
4
]
;
struct
gl_buffer_object
*
ArrayBufferObj
;
struct
gl_vertex_array_object
*
_DrawVAO
;
GLbitfield
_DrawVAOEnabledAttribs
;
struct
gl_vertex_array_object
*
_EmptyVAO
;
GLbitfield
LegalTypesMask
;
gl_api
LegalTypesMaskAPI
;
}
;
struct
gl_feedback
{
GLenum16
Type
;
GLbitfield
_Mask
;
GLfloat
*
Buffer
;
GLuint
BufferSize
;
GLuint
Count
;
}
;
struct
gl_selection
{
GLuint
*
Buffer
;
GLuint
BufferSize
;
GLuint
BufferCount
;
GLuint
Hits
;
GLuint
NameStackDepth
;
GLuint
NameStack
[
MAX_NAME_STACK_DEPTH
]
;
GLboolean
HitFlag
;
GLfloat
HitMinZ
;
GLfloat
HitMaxZ
;
}
;
struct
gl_1d_map
{
GLuint
Order
;
GLfloat
u1
u2
du
;
GLfloat
*
Points
;
}
;
struct
gl_2d_map
{
GLuint
Uorder
;
GLuint
Vorder
;
GLfloat
u1
u2
du
;
GLfloat
v1
v2
dv
;
GLfloat
*
Points
;
}
;
struct
gl_evaluators
{
struct
gl_1d_map
Map1Vertex3
;
struct
gl_1d_map
Map1Vertex4
;
struct
gl_1d_map
Map1Index
;
struct
gl_1d_map
Map1Color4
;
struct
gl_1d_map
Map1Normal
;
struct
gl_1d_map
Map1Texture1
;
struct
gl_1d_map
Map1Texture2
;
struct
gl_1d_map
Map1Texture3
;
struct
gl_1d_map
Map1Texture4
;
struct
gl_2d_map
Map2Vertex3
;
struct
gl_2d_map
Map2Vertex4
;
struct
gl_2d_map
Map2Index
;
struct
gl_2d_map
Map2Color4
;
struct
gl_2d_map
Map2Normal
;
struct
gl_2d_map
Map2Texture1
;
struct
gl_2d_map
Map2Texture2
;
struct
gl_2d_map
Map2Texture3
;
struct
gl_2d_map
Map2Texture4
;
}
;
struct
gl_transform_feedback_varying_info
{
char
*
Name
;
GLenum16
Type
;
GLint
BufferIndex
;
GLint
Size
;
GLint
Offset
;
}
;
struct
gl_transform_feedback_output
{
uint32_t
OutputRegister
;
uint32_t
OutputBuffer
;
uint32_t
NumComponents
;
uint32_t
StreamId
;
uint32_t
DstOffset
;
uint32_t
ComponentOffset
;
}
;
struct
gl_transform_feedback_buffer
{
uint32_t
Binding
;
uint32_t
NumVaryings
;
uint32_t
Stride
;
uint32_t
Stream
;
}
;
struct
gl_transform_feedback_info
{
unsigned
NumOutputs
;
unsigned
ActiveBuffers
;
struct
gl_transform_feedback_output
*
Outputs
;
struct
gl_transform_feedback_varying_info
*
Varyings
;
GLint
NumVarying
;
struct
gl_transform_feedback_buffer
Buffers
[
MAX_FEEDBACK_BUFFERS
]
;
}
;
struct
gl_transform_feedback_object
{
GLuint
Name
;
GLint
RefCount
;
GLchar
*
Label
;
GLboolean
Active
;
GLboolean
Paused
;
GLboolean
EndedAnytime
;
GLboolean
EverBound
;
unsigned
GlesRemainingPrims
;
struct
gl_program
*
program
;
GLuint
BufferNames
[
MAX_FEEDBACK_BUFFERS
]
;
struct
gl_buffer_object
*
Buffers
[
MAX_FEEDBACK_BUFFERS
]
;
GLintptr
Offset
[
MAX_FEEDBACK_BUFFERS
]
;
GLsizeiptr
Size
[
MAX_FEEDBACK_BUFFERS
]
;
GLsizeiptr
RequestedSize
[
MAX_FEEDBACK_BUFFERS
]
;
}
;
struct
gl_transform_feedback_state
{
GLenum16
Mode
;
struct
gl_buffer_object
*
CurrentBuffer
;
struct
_mesa_HashTable
*
Objects
;
struct
gl_transform_feedback_object
*
CurrentObject
;
struct
gl_transform_feedback_object
*
DefaultObject
;
}
;
struct
gl_perf_monitor_object
{
GLuint
Name
;
GLboolean
Active
;
GLboolean
Ended
;
unsigned
*
ActiveGroups
;
GLuint
*
*
ActiveCounters
;
}
;
union
gl_perf_monitor_counter_value
{
float
f
;
uint64_t
u64
;
uint32_t
u32
;
}
;
struct
gl_perf_monitor_counter
{
const
char
*
Name
;
GLenum16
Type
;
union
gl_perf_monitor_counter_value
Minimum
;
union
gl_perf_monitor_counter_value
Maximum
;
}
;
struct
gl_perf_monitor_group
{
const
char
*
Name
;
GLuint
MaxActiveCounters
;
const
struct
gl_perf_monitor_counter
*
Counters
;
GLuint
NumCounters
;
}
;
struct
gl_perf_query_object
{
GLuint
Id
;
unsigned
Used
:
1
;
unsigned
Active
:
1
;
unsigned
Ready
:
1
;
}
;
struct
gl_perf_monitor_state
{
const
struct
gl_perf_monitor_group
*
Groups
;
GLuint
NumGroups
;
struct
_mesa_HashTable
*
Monitors
;
}
;
struct
gl_perf_query_state
{
struct
_mesa_HashTable
*
Objects
;
}
;
struct
gl_bindless_sampler
{
GLubyte
unit
;
GLboolean
bound
;
gl_texture_index
target
;
GLvoid
*
data
;
}
;
struct
gl_bindless_image
{
GLubyte
unit
;
GLboolean
bound
;
GLenum16
access
;
GLvoid
*
data
;
}
;
typedef
enum
{
VP_MODE_FF
VP_MODE_SHADER
VP_MODE_MAX
}
gl_vertex_processing_mode
;
struct
gl_program
{
struct
shader_info
info
;
GLuint
Id
;
GLint
RefCount
;
GLubyte
*
String
;
GLenum16
Target
;
GLenum16
Format
;
GLboolean
_Used
;
struct
nir_shader
*
nir
;
void
*
driver_cache_blob
;
size_t
driver_cache_blob_size
;
bool
is_arb_asm
;
bool
program_written_to_cache
;
GLbitfield64
DualSlotInputs
;
GLbitfield64
SecondaryOutputsWritten
;
GLbitfield16
TexturesUsed
[
MAX_COMBINED_TEXTURE_IMAGE_UNITS
]
;
GLbitfield
SamplersUsed
;
GLbitfield
ShadowSamplers
;
GLbitfield
ExternalSamplersUsed
;
struct
gl_program_parameter_list
*
Parameters
;
GLubyte
SamplerUnits
[
MAX_SAMPLERS
]
;
struct
{
struct
{
struct
gl_shader_program_data
*
data
;
struct
gl_active_atomic_buffer
*
*
AtomicBuffers
;
struct
gl_transform_feedback_info
*
LinkedTransformFeedback
;
GLuint
NumSubroutineUniformTypes
;
GLuint
NumSubroutineUniforms
;
GLuint
NumSubroutineUniformRemapTable
;
struct
gl_uniform_storage
*
*
SubroutineUniformRemapTable
;
GLuint
NumSubroutineFunctions
;
GLuint
MaxSubroutineFunctionIndex
;
struct
gl_subroutine_function
*
SubroutineFunctions
;
GLubyte
ImageUnits
[
MAX_IMAGE_UNIFORMS
]
;
GLenum16
ImageAccess
[
MAX_IMAGE_UNIFORMS
]
;
struct
gl_uniform_block
*
*
UniformBlocks
;
struct
gl_uniform_block
*
*
ShaderStorageBlocks
;
unsigned
ShaderStorageBlocksWriteAccess
;
GLubyte
SamplerTargets
[
MAX_SAMPLERS
]
;
GLuint
NumBindlessSamplers
;
GLboolean
HasBoundBindlessSampler
;
struct
gl_bindless_sampler
*
BindlessSamplers
;
GLuint
NumBindlessImages
;
GLboolean
HasBoundBindlessImage
;
struct
gl_bindless_image
*
BindlessImages
;
union
{
struct
{
GLbitfield
BlendSupport
;
}
fs
;
}
;
}
sh
;
struct
{
struct
prog_instruction
*
Instructions
;
GLfloat
(
*
LocalParams
)
[
4
]
;
GLbitfield
IndirectRegisterFiles
;
GLuint
NumInstructions
;
GLuint
NumTemporaries
;
GLuint
NumParameters
;
GLuint
NumAttributes
;
GLuint
NumAddressRegs
;
GLuint
NumAluInstructions
;
GLuint
NumTexInstructions
;
GLuint
NumTexIndirections
;
GLuint
NumNativeInstructions
;
GLuint
NumNativeTemporaries
;
GLuint
NumNativeParameters
;
GLuint
NumNativeAttributes
;
GLuint
NumNativeAddressRegs
;
GLuint
NumNativeAluInstructions
;
GLuint
NumNativeTexInstructions
;
GLuint
NumNativeTexIndirections
;
GLboolean
IsPositionInvariant
;
}
arb
;
}
;
}
;
struct
gl_program_state
{
GLint
ErrorPos
;
const
char
*
ErrorString
;
}
;
struct
gl_vertex_program_state
{
GLboolean
Enabled
;
GLboolean
PointSizeEnabled
;
GLboolean
TwoSideEnabled
;
GLboolean
_MaintainTnlProgram
;
struct
gl_program
*
Current
;
struct
gl_program
*
_Current
;
GLfloat
Parameters
[
MAX_PROGRAM_ENV_PARAMS
]
[
4
]
;
struct
gl_program
*
_TnlProgram
;
struct
gl_program_cache
*
Cache
;
GLboolean
_Overriden
;
gl_vertex_processing_mode
_VPMode
;
}
;
struct
gl_tess_ctrl_program_state
{
struct
gl_program
*
_Current
;
GLint
patch_vertices
;
GLfloat
patch_default_outer_level
[
4
]
;
GLfloat
patch_default_inner_level
[
2
]
;
}
;
struct
gl_tess_eval_program_state
{
struct
gl_program
*
_Current
;
}
;
struct
gl_geometry_program_state
{
struct
gl_program
*
_Current
;
}
;
struct
gl_fragment_program_state
{
GLboolean
Enabled
;
GLboolean
_MaintainTexEnvProgram
;
struct
gl_program
*
Current
;
struct
gl_program
*
_Current
;
GLfloat
Parameters
[
MAX_PROGRAM_ENV_PARAMS
]
[
4
]
;
struct
gl_program
*
_TexEnvProgram
;
struct
gl_program_cache
*
Cache
;
}
;
struct
gl_compute_program_state
{
struct
gl_program
*
_Current
;
}
;
struct
atifs_instruction
;
struct
atifs_setupinst
;
struct
ati_fragment_shader
{
GLuint
Id
;
GLint
RefCount
;
struct
atifs_instruction
*
Instructions
[
2
]
;
struct
atifs_setupinst
*
SetupInst
[
2
]
;
GLfloat
Constants
[
8
]
[
4
]
;
GLbitfield
LocalConstDef
;
GLubyte
numArithInstr
[
2
]
;
GLubyte
regsAssigned
[
2
]
;
GLubyte
NumPasses
;
GLubyte
cur_pass
;
GLubyte
last_optype
;
GLboolean
interpinp1
;
GLboolean
isValid
;
GLuint
swizzlerq
;
struct
gl_program
*
Program
;
}
;
struct
gl_ati_fragment_shader_state
{
GLboolean
Enabled
;
GLboolean
Compiling
;
GLfloat
GlobalConstants
[
8
]
[
4
]
;
struct
ati_fragment_shader
*
Current
;
}
;
struct
gl_subroutine_function
{
char
*
name
;
int
index
;
int
num_compat_types
;
const
struct
glsl_type
*
*
types
;
}
;
struct
gl_shader_info
{
struct
{
GLint
VerticesOut
;
}
TessCtrl
;
struct
{
GLenum16
PrimitiveMode
;
enum
gl_tess_spacing
Spacing
;
GLenum16
VertexOrder
;
int
PointMode
;
}
TessEval
;
struct
{
GLint
VerticesOut
;
GLint
Invocations
;
GLenum16
InputType
;
GLenum16
OutputType
;
}
Geom
;
struct
{
unsigned
LocalSize
[
3
]
;
bool
LocalSizeVariable
;
enum
gl_derivative_group
DerivativeGroup
;
}
Comp
;
}
;
struct
gl_linked_shader
{
gl_shader_stage
Stage
;
#
ifdef
DEBUG
unsigned
SourceChecksum
;
#
endif
struct
gl_program
*
Program
;
GLbitfield
shadow_samplers
;
unsigned
num_uniform_components
;
unsigned
num_combined_uniform_components
;
struct
exec_list
*
ir
;
struct
exec_list
*
packed_varyings
;
struct
exec_list
*
fragdata_arrays
;
struct
glsl_symbol_table
*
symbols
;
struct
gl_shader_spirv_data
*
spirv_data
;
}
;
enum
gl_compile_status
{
COMPILE_FAILURE
=
0
COMPILE_SUCCESS
COMPILE_SKIPPED
}
;
struct
gl_shader
{
GLenum16
Type
;
gl_shader_stage
Stage
;
GLuint
Name
;
GLint
RefCount
;
GLchar
*
Label
;
unsigned
char
sha1
[
20
]
;
GLboolean
DeletePending
;
bool
IsES
;
enum
gl_compile_status
CompileStatus
;
#
ifdef
DEBUG
unsigned
SourceChecksum
;
#
endif
const
GLchar
*
Source
;
const
GLchar
*
FallbackSource
;
GLchar
*
InfoLog
;
unsigned
Version
;
GLbitfield
BlendSupport
;
struct
exec_list
*
ir
;
struct
glsl_symbol_table
*
symbols
;
bool
EarlyFragmentTests
;
bool
ARB_fragment_coord_conventions_enable
;
bool
redeclares_gl_fragcoord
;
bool
uses_gl_fragcoord
;
bool
PostDepthCoverage
;
bool
PixelInterlockOrdered
;
bool
PixelInterlockUnordered
;
bool
SampleInterlockOrdered
;
bool
SampleInterlockUnordered
;
bool
InnerCoverage
;
bool
origin_upper_left
;
bool
pixel_center_integer
;
bool
bindless_sampler
;
bool
bindless_image
;
bool
bound_sampler
;
bool
bound_image
;
bool
redeclares_gl_layer
;
bool
layer_viewport_relative
;
GLuint
TransformFeedbackBufferStride
[
MAX_FEEDBACK_BUFFERS
]
;
struct
gl_shader_info
info
;
struct
gl_shader_spirv_data
*
spirv_data
;
}
;
struct
gl_uniform_buffer_variable
{
char
*
Name
;
char
*
IndexName
;
const
struct
glsl_type
*
Type
;
unsigned
int
Offset
;
GLboolean
RowMajor
;
}
;
struct
gl_uniform_block
{
char
*
Name
;
struct
gl_uniform_buffer_variable
*
Uniforms
;
GLuint
NumUniforms
;
GLuint
Binding
;
GLuint
UniformBufferSize
;
uint8_t
stageref
;
uint8_t
linearized_array_index
;
enum
glsl_interface_packing
_Packing
;
GLboolean
_RowMajor
;
}
;
struct
gl_active_atomic_buffer
{
GLuint
*
Uniforms
;
GLuint
NumUniforms
;
GLuint
Binding
;
GLuint
MinimumSize
;
GLboolean
StageReferences
[
MESA_SHADER_STAGES
]
;
}
;
struct
gl_shader_variable
{
const
struct
glsl_type
*
type
;
const
struct
glsl_type
*
interface_type
;
const
struct
glsl_type
*
outermost_struct_type
;
char
*
name
;
int
location
;
unsigned
component
:
2
;
unsigned
index
:
1
;
unsigned
patch
:
1
;
unsigned
mode
:
4
;
unsigned
interpolation
:
2
;
unsigned
explicit_location
:
1
;
unsigned
precision
:
2
;
}
;
struct
gl_program_resource
{
GLenum16
Type
;
const
void
*
Data
;
uint8_t
StageReferences
;
}
;
enum
gl_link_status
{
LINKING_FAILURE
=
0
LINKING_SUCCESS
LINKING_SKIPPED
}
;
struct
gl_shader_program_data
{
GLint
RefCount
;
unsigned
char
sha1
[
20
]
;
unsigned
NumUniformStorage
;
unsigned
NumHiddenUniforms
;
struct
gl_uniform_storage
*
UniformStorage
;
unsigned
NumUniformBlocks
;
unsigned
NumShaderStorageBlocks
;
struct
gl_uniform_block
*
UniformBlocks
;
struct
gl_uniform_block
*
ShaderStorageBlocks
;
struct
gl_active_atomic_buffer
*
AtomicBuffers
;
unsigned
NumAtomicBuffers
;
unsigned
NumUniformDataSlots
;
union
gl_constant_value
*
UniformDataSlots
;
union
gl_constant_value
*
UniformDataDefaults
;
struct
hash_table_u64
*
ProgramResourceHash
;
GLboolean
Validated
;
struct
gl_program_resource
*
ProgramResourceList
;
unsigned
NumProgramResourceList
;
enum
gl_link_status
LinkStatus
;
GLchar
*
InfoLog
;
unsigned
Version
;
unsigned
linked_stages
;
bool
spirv
;
}
;
struct
gl_shader_program
{
GLenum16
Type
;
GLuint
Name
;
GLchar
*
Label
;
GLint
RefCount
;
GLboolean
DeletePending
;
GLboolean
BinaryRetrievableHint
;
GLboolean
BinaryRetrievableHintPending
;
GLboolean
SeparateShader
;
GLuint
NumShaders
;
struct
gl_shader
*
*
Shaders
;
struct
string_to_uint_map
*
AttributeBindings
;
struct
string_to_uint_map
*
FragDataBindings
;
struct
string_to_uint_map
*
FragDataIndexBindings
;
struct
{
GLenum16
BufferMode
;
GLuint
BufferStride
[
MAX_FEEDBACK_BUFFERS
]
;
GLuint
NumVarying
;
GLchar
*
*
VaryingNames
;
}
TransformFeedback
;
struct
gl_program
*
last_vert_prog
;
enum
gl_frag_depth_layout
FragDepthLayout
;
struct
{
GLint
VerticesIn
;
bool
UsesEndPrimitive
;
bool
UsesStreams
;
}
Geom
;
struct
{
unsigned
SharedSize
;
}
Comp
;
struct
gl_shader_program_data
*
data
;
unsigned
NumUniformRemapTable
;
struct
gl_uniform_storage
*
*
UniformRemapTable
;
struct
exec_list
EmptyUniformLocations
;
unsigned
NumExplicitUniformLocations
;
struct
string_to_uint_map
*
UniformHash
;
GLboolean
SamplersValidated
;
bool
IsES
;
struct
gl_linked_shader
*
_LinkedShaders
[
MESA_SHADER_STAGES
]
;
GLboolean
ARB_fragment_coord_conventions_enable
;
}
;
#
define
GLSL_DUMP
0x1
/
*
*
<
Dump
shaders
to
stdout
*
/
#
define
GLSL_LOG
0x2
/
*
*
<
Write
shaders
to
files
*
/
#
define
GLSL_UNIFORMS
0x4
/
*
*
<
Print
glUniform
calls
*
/
#
define
GLSL_NOP_VERT
0x8
/
*
*
<
Force
no
-
op
vertex
shaders
*
/
#
define
GLSL_NOP_FRAG
0x10
/
*
*
<
Force
no
-
op
fragment
shaders
*
/
#
define
GLSL_USE_PROG
0x20
/
*
*
<
Log
glUseProgram
calls
*
/
#
define
GLSL_REPORT_ERRORS
0x40
/
*
*
<
Print
compilation
errors
*
/
#
define
GLSL_DUMP_ON_ERROR
0x80
/
*
*
<
Dump
shaders
to
stderr
on
compile
error
*
/
#
define
GLSL_CACHE_INFO
0x100
/
*
*
<
Print
debug
information
about
shader
cache
*
/
#
define
GLSL_CACHE_FALLBACK
0x200
/
*
*
<
Force
shader
cache
fallback
paths
*
/
struct
gl_pipeline_object
{
GLuint
Name
;
GLint
RefCount
;
GLchar
*
Label
;
struct
gl_program
*
CurrentProgram
[
MESA_SHADER_STAGES
]
;
struct
gl_shader_program
*
ReferencedPrograms
[
MESA_SHADER_STAGES
]
;
struct
gl_shader_program
*
ActiveProgram
;
GLbitfield
Flags
;
GLboolean
EverBound
;
GLboolean
Validated
;
GLchar
*
InfoLog
;
}
;
struct
gl_pipeline_shader_state
{
struct
gl_pipeline_object
*
Current
;
struct
gl_pipeline_object
*
Default
;
struct
_mesa_HashTable
*
Objects
;
}
;
struct
gl_shader_compiler_options
{
GLboolean
EmitNoLoops
;
GLboolean
EmitNoCont
;
GLboolean
EmitNoMainReturn
;
GLboolean
EmitNoPow
;
GLboolean
EmitNoSat
;
GLboolean
LowerCombinedClipCullDistance
;
GLbitfield
LowerBuiltinVariablesXfb
;
GLboolean
LowerPrecision
;
GLboolean
EmitNoIndirectInput
;
GLboolean
EmitNoIndirectOutput
;
GLboolean
EmitNoIndirectTemp
;
GLboolean
EmitNoIndirectUniform
;
GLboolean
EmitNoIndirectSampler
;
GLuint
MaxIfDepth
;
GLuint
MaxUnrollIterations
;
GLboolean
OptimizeForAOS
;
GLboolean
LowerBufferInterfaceBlocks
;
GLboolean
ClampBlockIndicesToArrayBounds
;
GLboolean
PositionAlwaysInvariant
;
const
struct
nir_shader_compiler_options
*
NirOptions
;
}
;
struct
gl_query_object
{
GLenum16
Target
;
GLuint
Id
;
GLchar
*
Label
;
GLuint64EXT
Result
;
GLboolean
Active
;
GLboolean
Ready
;
GLboolean
EverBound
;
GLuint
Stream
;
}
;
struct
gl_query_state
{
struct
_mesa_HashTable
*
QueryObjects
;
struct
gl_query_object
*
CurrentOcclusionObject
;
struct
gl_query_object
*
CurrentTimerObject
;
struct
gl_query_object
*
CondRenderQuery
;
struct
gl_query_object
*
PrimitivesGenerated
[
MAX_VERTEX_STREAMS
]
;
struct
gl_query_object
*
PrimitivesWritten
[
MAX_VERTEX_STREAMS
]
;
struct
gl_query_object
*
TransformFeedbackOverflow
[
MAX_VERTEX_STREAMS
]
;
struct
gl_query_object
*
TransformFeedbackOverflowAny
;
struct
gl_query_object
*
TimeElapsed
;
struct
gl_query_object
*
pipeline_stats
[
MAX_PIPELINE_STATISTICS
]
;
GLenum16
CondRenderMode
;
}
;
struct
gl_sync_object
{
GLuint
Name
;
GLint
RefCount
;
GLchar
*
Label
;
GLboolean
DeletePending
;
GLenum16
SyncCondition
;
GLbitfield
Flags
;
GLuint
StatusFlag
:
1
;
}
;
struct
gl_shared_state
{
simple_mtx_t
Mutex
;
GLint
RefCount
;
struct
_mesa_HashTable
*
DisplayList
;
struct
_mesa_HashTable
*
BitmapAtlas
;
struct
_mesa_HashTable
*
TexObjects
;
struct
gl_texture_object
*
DefaultTex
[
NUM_TEXTURE_TARGETS
]
;
struct
gl_texture_object
*
FallbackTex
[
NUM_TEXTURE_TARGETS
]
;
mtx_t
TexMutex
;
GLuint
TextureStateStamp
;
struct
_mesa_HashTable
*
Programs
;
struct
gl_program
*
DefaultVertexProgram
;
struct
gl_program
*
DefaultFragmentProgram
;
struct
_mesa_HashTable
*
ATIShaders
;
struct
ati_fragment_shader
*
DefaultFragmentShader
;
struct
_mesa_HashTable
*
BufferObjects
;
struct
_mesa_HashTable
*
ShaderObjects
;
struct
_mesa_HashTable
*
RenderBuffers
;
struct
_mesa_HashTable
*
FrameBuffers
;
struct
set
*
SyncObjects
;
struct
_mesa_HashTable
*
SamplerObjects
;
struct
hash_table_u64
*
TextureHandles
;
struct
hash_table_u64
*
ImageHandles
;
mtx_t
HandlesMutex
;
struct
shader_includes
*
ShaderIncludes
;
mtx_t
ShaderIncludeMutex
;
bool
ShareGroupReset
;
struct
_mesa_HashTable
*
MemoryObjects
;
struct
_mesa_HashTable
*
SemaphoreObjects
;
bool
DisjointOperation
;
}
;
struct
gl_renderbuffer
{
simple_mtx_t
Mutex
;
GLuint
ClassID
;
GLuint
Name
;
GLchar
*
Label
;
GLint
RefCount
;
GLuint
Width
Height
;
GLuint
Depth
;
GLboolean
Purgeable
;
GLboolean
AttachedAnytime
;
GLboolean
NeedsFinishRenderTexture
;
GLubyte
NumSamples
;
GLubyte
NumStorageSamples
;
GLenum16
InternalFormat
;
GLenum16
_BaseFormat
;
mesa_format
Format
;
struct
gl_texture_image
*
TexImage
;
void
(
*
Delete
)
(
struct
gl_context
*
ctx
struct
gl_renderbuffer
*
rb
)
;
GLboolean
(
*
AllocStorage
)
(
struct
gl_context
*
ctx
struct
gl_renderbuffer
*
rb
GLenum
internalFormat
GLuint
width
GLuint
height
)
;
}
;
struct
gl_renderbuffer_attachment
{
GLenum16
Type
;
GLboolean
Complete
;
struct
gl_renderbuffer
*
Renderbuffer
;
struct
gl_texture_object
*
Texture
;
GLuint
TextureLevel
;
GLsizei
NumSamples
;
GLuint
CubeMapFace
;
GLuint
Zoffset
;
GLboolean
Layered
;
}
;
struct
gl_framebuffer
{
simple_mtx_t
Mutex
;
GLuint
Name
;
GLint
RefCount
;
GLchar
*
Label
;
GLboolean
DeletePending
;
struct
gl_config
Visual
;
GLuint
Width
Height
;
struct
{
GLuint
Width
Height
Layers
NumSamples
;
GLboolean
FixedSampleLocations
;
GLuint
_NumSamples
;
}
DefaultGeometry
;
GLint
_Xmin
_Xmax
;
GLint
_Ymin
_Ymax
;
GLuint
_DepthMax
;
GLfloat
_DepthMaxF
;
GLfloat
_MRD
;
GLenum16
_Status
;
bool
_HasAttachments
;
GLbitfield
_IntegerBuffers
;
GLbitfield
_RGBBuffers
;
GLbitfield
_FP32Buffers
;
GLboolean
_AllColorBuffersFixedPoint
;
GLboolean
_HasSNormOrFloatColorBuffer
;
GLuint
MaxNumLayers
;
struct
gl_renderbuffer_attachment
Attachment
[
BUFFER_COUNT
]
;
GLenum16
ColorDrawBuffer
[
MAX_DRAW_BUFFERS
]
;
GLenum16
ColorReadBuffer
;
GLfloat
*
SampleLocationTable
;
GLboolean
ProgrammableSampleLocations
;
GLboolean
SampleLocationPixelGrid
;
GLuint
_NumColorDrawBuffers
;
gl_buffer_index
_ColorDrawBufferIndexes
[
MAX_DRAW_BUFFERS
]
;
gl_buffer_index
_ColorReadBufferIndex
;
struct
gl_renderbuffer
*
_ColorDrawBuffers
[
MAX_DRAW_BUFFERS
]
;
struct
gl_renderbuffer
*
_ColorReadBuffer
;
bool
FlipY
;
void
(
*
Delete
)
(
struct
gl_framebuffer
*
fb
)
;
}
;
struct
gl_precision
{
GLushort
RangeMin
;
GLushort
RangeMax
;
GLushort
Precision
;
}
;
struct
gl_program_constants
{
GLuint
MaxInstructions
;
GLuint
MaxAluInstructions
;
GLuint
MaxTexInstructions
;
GLuint
MaxTexIndirections
;
GLuint
MaxAttribs
;
GLuint
MaxTemps
;
GLuint
MaxAddressRegs
;
GLuint
MaxAddressOffset
;
GLuint
MaxParameters
;
GLuint
MaxLocalParams
;
GLuint
MaxEnvParams
;
GLuint
MaxNativeInstructions
;
GLuint
MaxNativeAluInstructions
;
GLuint
MaxNativeTexInstructions
;
GLuint
MaxNativeTexIndirections
;
GLuint
MaxNativeAttribs
;
GLuint
MaxNativeTemps
;
GLuint
MaxNativeAddressRegs
;
GLuint
MaxNativeParameters
;
GLuint
MaxUniformComponents
;
GLuint
MaxInputComponents
;
GLuint
MaxOutputComponents
;
struct
gl_precision
LowFloat
MediumFloat
HighFloat
;
struct
gl_precision
LowInt
MediumInt
HighInt
;
GLuint
MaxUniformBlocks
;
uint64_t
MaxCombinedUniformComponents
;
GLuint
MaxTextureImageUnits
;
GLuint
MaxAtomicBuffers
;
GLuint
MaxAtomicCounters
;
GLuint
MaxImageUniforms
;
GLuint
MaxShaderStorageBlocks
;
}
;
struct
gl_constants
{
GLuint
MaxTextureMbytes
;
GLuint
MaxTextureSize
;
GLuint
Max3DTextureLevels
;
GLuint
MaxCubeTextureLevels
;
GLuint
MaxArrayTextureLayers
;
GLuint
MaxTextureRectSize
;
GLuint
MaxTextureCoordUnits
;
GLuint
MaxCombinedTextureImageUnits
;
GLuint
MaxTextureUnits
;
GLfloat
MaxTextureMaxAnisotropy
;
GLfloat
MaxTextureLodBias
;
GLuint
MaxTextureBufferSize
;
GLuint
TextureBufferOffsetAlignment
;
GLuint
MaxArrayLockSize
;
GLint
SubPixelBits
;
GLfloat
MinPointSize
MaxPointSize
;
GLfloat
MinPointSizeAA
MaxPointSizeAA
;
GLfloat
PointSizeGranularity
;
GLfloat
MinLineWidth
MaxLineWidth
;
GLfloat
MinLineWidthAA
MaxLineWidthAA
;
GLfloat
LineWidthGranularity
;
GLuint
MaxClipPlanes
;
GLuint
MaxLights
;
GLfloat
MaxShininess
;
GLfloat
MaxSpotExponent
;
GLuint
MaxViewportWidth
MaxViewportHeight
;
GLuint
MaxViewports
;
GLuint
ViewportSubpixelBits
;
struct
{
GLfloat
Min
;
GLfloat
Max
;
}
ViewportBounds
;
GLuint
MaxWindowRectangles
;
struct
gl_program_constants
Program
[
MESA_SHADER_STAGES
]
;
GLuint
MaxProgramMatrices
;
GLuint
MaxProgramMatrixStackDepth
;
struct
{
GLuint
SamplesPassed
;
GLuint
TimeElapsed
;
GLuint
Timestamp
;
GLuint
PrimitivesGenerated
;
GLuint
PrimitivesWritten
;
GLuint
VerticesSubmitted
;
GLuint
PrimitivesSubmitted
;
GLuint
VsInvocations
;
GLuint
TessPatches
;
GLuint
TessInvocations
;
GLuint
GsInvocations
;
GLuint
GsPrimitives
;
GLuint
FsInvocations
;
GLuint
ComputeInvocations
;
GLuint
ClInPrimitives
;
GLuint
ClOutPrimitives
;
}
QueryCounterBits
;
GLuint
MaxDrawBuffers
;
GLuint
MaxColorAttachments
;
GLuint
MaxRenderbufferSize
;
GLuint
MaxSamples
;
GLuint
MaxFramebufferWidth
;
GLuint
MaxFramebufferHeight
;
GLuint
MaxFramebufferLayers
;
GLuint
MaxFramebufferSamples
;
GLuint
MaxVarying
;
GLuint
MaxCombinedUniformBlocks
;
GLuint
MaxUniformBufferBindings
;
GLuint
MaxUniformBlockSize
;
GLuint
UniformBufferOffsetAlignment
;
GLuint
MaxCombinedShaderStorageBlocks
;
GLuint
MaxShaderStorageBufferBindings
;
GLuint
MaxShaderStorageBlockSize
;
GLuint
ShaderStorageBufferOffsetAlignment
;
GLuint
MaxUserAssignableUniformLocations
;
GLuint
MaxGeometryOutputVertices
;
GLuint
MaxGeometryTotalOutputComponents
;
GLuint
MaxGeometryShaderInvocations
;
GLuint
GLSLVersion
;
GLuint
GLSLVersionCompat
;
GLboolean
ForceGLSLExtensionsWarn
;
GLuint
ForceGLSLVersion
;
GLboolean
AllowGLSLExtensionDirectiveMidShader
;
GLboolean
AllowGLSLBuiltinConstantExpression
;
GLboolean
AllowGLSLRelaxedES
;
GLboolean
AllowGLSLBuiltinVariableRedeclaration
;
GLboolean
AllowGLSLCrossStageInterpolationMismatch
;
GLboolean
AllowHigherCompatVersion
;
GLboolean
AllowLayoutQualifiersOnFunctionParameters
;
GLboolean
ForceGLSLAbsSqrt
;
GLboolean
GLSLZeroInit
;
GLboolean
ForceIntegerTexNearest
;
GLboolean
NativeIntegers
;
bool
VertexID_is_zero_based
;
GLuint
UniformBooleanTrue
;
GLuint64
MaxServerWaitTimeout
;
GLboolean
QuadsFollowProvokingVertexConvention
;
GLenum16
LayerAndVPIndexProvokingVertex
;
GLbitfield
ContextFlags
;
GLbitfield
ProfileMask
;
GLuint
MaxVertexAttribStride
;
GLuint
MaxTransformFeedbackBuffers
;
GLuint
MaxTransformFeedbackSeparateComponents
;
GLuint
MaxTransformFeedbackInterleavedComponents
;
GLuint
MaxVertexStreams
;
GLint
MinProgramTexelOffset
MaxProgramTexelOffset
;
GLuint
MinProgramTextureGatherOffset
;
GLuint
MaxProgramTextureGatherOffset
;
GLuint
MaxProgramTextureGatherComponents
;
GLenum16
ResetStrategy
;
GLboolean
RobustAccess
;
GLuint
MaxDualSourceDrawBuffers
;
GLboolean
StripTextureBorder
;
GLboolean
GLSLSkipStrictMaxUniformLimitCheck
;
bool
GLSLFragCoordIsSysVal
;
bool
GLSLPointCoordIsSysVal
;
bool
GLSLFrontFacingIsSysVal
;
bool
GLSLOptimizeConservatively
;
bool
GLSLLowerConstArrays
;
bool
GLSLTessLevelsAsInputs
;
GLboolean
AlwaysUseGetTransformFeedbackVertexCount
;
GLuint
MinMapBufferAlignment
;
GLboolean
DisableVaryingPacking
;
GLboolean
DisableTransformFeedbackPacking
;
bool
UseSTD430AsDefaultPacking
;
bool
GenerateTemporaryNames
;
GLuint64
MaxElementIndex
;
GLboolean
DisableGLSLLineContinuations
;
GLint
MaxColorTextureSamples
;
GLint
MaxDepthTextureSamples
;
GLint
MaxIntegerSamples
;
GLint
MaxColorFramebufferSamples
;
GLint
MaxColorFramebufferStorageSamples
;
GLint
MaxDepthStencilFramebufferSamples
;
struct
{
GLint
NumColorSamples
;
GLint
NumColorStorageSamples
;
GLint
NumDepthStencilSamples
;
}
SupportedMultisampleModes
[
40
]
;
GLint
NumSupportedMultisampleModes
;
GLuint
MaxAtomicBufferBindings
;
GLuint
MaxAtomicBufferSize
;
GLuint
MaxCombinedAtomicBuffers
;
GLuint
MaxCombinedAtomicCounters
;
GLint
MaxVertexAttribRelativeOffset
;
GLint
MaxVertexAttribBindings
;
GLuint
MaxImageUnits
;
GLuint
MaxCombinedShaderOutputResources
;
GLuint
MaxImageSamples
;
GLuint
MaxCombinedImageUniforms
;
GLuint
MaxComputeWorkGroupCount
[
3
]
;
GLuint
MaxComputeWorkGroupSize
[
3
]
;
GLuint
MaxComputeWorkGroupInvocations
;
GLuint
MaxComputeSharedMemorySize
;
GLuint
MaxComputeVariableGroupSize
[
3
]
;
GLuint
MaxComputeVariableGroupInvocations
;
GLfloat
MinFragmentInterpolationOffset
;
GLfloat
MaxFragmentInterpolationOffset
;
GLboolean
FakeSWMSAA
;
GLenum16
ContextReleaseBehavior
;
struct
gl_shader_compiler_options
ShaderCompilerOptions
[
MESA_SHADER_STAGES
]
;
GLuint
MaxPatchVertices
;
GLuint
MaxTessGenLevel
;
GLuint
MaxTessPatchComponents
;
GLuint
MaxTessControlTotalOutputComponents
;
bool
LowerTessLevel
;
bool
PrimitiveRestartForPatches
;
bool
LowerCsDerivedVariables
;
bool
NoPrimitiveBoundingBoxOutput
;
GLuint
SparseBufferPageSize
;
unsigned
char
*
dri_config_options_sha1
;
bool
AllowMappedBuffersDuringExecution
;
bool
BufferCreateMapUnsynchronizedThreadSafe
;
GLuint
NumProgramBinaryFormats
;
GLuint
MaxSubpixelPrecisionBiasBits
;
GLfloat
ConservativeRasterDilateRange
[
2
]
;
GLfloat
ConservativeRasterDilateGranularity
;
bool
PackedDriverUniformStorage
;
bool
UseNIRGLSLLinker
;
bool
BitmapUsesRed
;
bool
VertexBufferOffsetIsInt32
;
bool
MultiDrawWithUserIndices
;
bool
AllowDrawOutOfOrder
;
struct
spirv_supported_capabilities
SpirVCapabilities
;
struct
spirv_supported_extensions
*
SpirVExtensions
;
char
*
VendorOverride
;
unsigned
glBeginEndBufferSize
;
}
;
struct
gl_extensions
{
GLboolean
dummy
;
GLboolean
dummy_true
;
GLboolean
dummy_false
;
GLboolean
ANGLE_texture_compression_dxt
;
GLboolean
ARB_ES2_compatibility
;
GLboolean
ARB_ES3_compatibility
;
GLboolean
ARB_ES3_1_compatibility
;
GLboolean
ARB_ES3_2_compatibility
;
GLboolean
ARB_arrays_of_arrays
;
GLboolean
ARB_base_instance
;
GLboolean
ARB_bindless_texture
;
GLboolean
ARB_blend_func_extended
;
GLboolean
ARB_buffer_storage
;
GLboolean
ARB_clear_texture
;
GLboolean
ARB_clip_control
;
GLboolean
ARB_color_buffer_float
;
GLboolean
ARB_compatibility
;
GLboolean
ARB_compute_shader
;
GLboolean
ARB_compute_variable_group_size
;
GLboolean
ARB_conditional_render_inverted
;
GLboolean
ARB_conservative_depth
;
GLboolean
ARB_copy_image
;
GLboolean
ARB_cull_distance
;
GLboolean
ARB_depth_buffer_float
;
GLboolean
ARB_depth_clamp
;
GLboolean
ARB_depth_texture
;
GLboolean
ARB_derivative_control
;
GLboolean
ARB_draw_buffers_blend
;
GLboolean
ARB_draw_elements_base_vertex
;
GLboolean
ARB_draw_indirect
;
GLboolean
ARB_draw_instanced
;
GLboolean
ARB_fragment_coord_conventions
;
GLboolean
ARB_fragment_layer_viewport
;
GLboolean
ARB_fragment_program
;
GLboolean
ARB_fragment_program_shadow
;
GLboolean
ARB_fragment_shader
;
GLboolean
ARB_framebuffer_no_attachments
;
GLboolean
ARB_framebuffer_object
;
GLboolean
ARB_fragment_shader_interlock
;
GLboolean
ARB_enhanced_layouts
;
GLboolean
ARB_explicit_attrib_location
;
GLboolean
ARB_explicit_uniform_location
;
GLboolean
ARB_gl_spirv
;
GLboolean
ARB_gpu_shader5
;
GLboolean
ARB_gpu_shader_fp64
;
GLboolean
ARB_gpu_shader_int64
;
GLboolean
ARB_half_float_vertex
;
GLboolean
ARB_indirect_parameters
;
GLboolean
ARB_instanced_arrays
;
GLboolean
ARB_internalformat_query
;
GLboolean
ARB_internalformat_query2
;
GLboolean
ARB_map_buffer_range
;
GLboolean
ARB_occlusion_query
;
GLboolean
ARB_occlusion_query2
;
GLboolean
ARB_pipeline_statistics_query
;
GLboolean
ARB_point_sprite
;
GLboolean
ARB_polygon_offset_clamp
;
GLboolean
ARB_post_depth_coverage
;
GLboolean
ARB_query_buffer_object
;
GLboolean
ARB_robust_buffer_access_behavior
;
GLboolean
ARB_sample_locations
;
GLboolean
ARB_sample_shading
;
GLboolean
ARB_seamless_cube_map
;
GLboolean
ARB_shader_atomic_counter_ops
;
GLboolean
ARB_shader_atomic_counters
;
GLboolean
ARB_shader_ballot
;
GLboolean
ARB_shader_bit_encoding
;
GLboolean
ARB_shader_clock
;
GLboolean
ARB_shader_draw_parameters
;
GLboolean
ARB_shader_group_vote
;
GLboolean
ARB_shader_image_load_store
;
GLboolean
ARB_shader_image_size
;
GLboolean
ARB_shader_precision
;
GLboolean
ARB_shader_stencil_export
;
GLboolean
ARB_shader_storage_buffer_object
;
GLboolean
ARB_shader_texture_image_samples
;
GLboolean
ARB_shader_texture_lod
;
GLboolean
ARB_shader_viewport_layer_array
;
GLboolean
ARB_shading_language_packing
;
GLboolean
ARB_shading_language_420pack
;
GLboolean
ARB_shadow
;
GLboolean
ARB_sparse_buffer
;
GLboolean
ARB_stencil_texturing
;
GLboolean
ARB_spirv_extensions
;
GLboolean
ARB_sync
;
GLboolean
ARB_tessellation_shader
;
GLboolean
ARB_texture_border_clamp
;
GLboolean
ARB_texture_buffer_object
;
GLboolean
ARB_texture_buffer_object_rgb32
;
GLboolean
ARB_texture_buffer_range
;
GLboolean
ARB_texture_compression_bptc
;
GLboolean
ARB_texture_compression_rgtc
;
GLboolean
ARB_texture_cube_map
;
GLboolean
ARB_texture_cube_map_array
;
GLboolean
ARB_texture_env_combine
;
GLboolean
ARB_texture_env_crossbar
;
GLboolean
ARB_texture_env_dot3
;
GLboolean
ARB_texture_filter_anisotropic
;
GLboolean
ARB_texture_float
;
GLboolean
ARB_texture_gather
;
GLboolean
ARB_texture_mirror_clamp_to_edge
;
GLboolean
ARB_texture_multisample
;
GLboolean
ARB_texture_non_power_of_two
;
GLboolean
ARB_texture_stencil8
;
GLboolean
ARB_texture_query_levels
;
GLboolean
ARB_texture_query_lod
;
GLboolean
ARB_texture_rg
;
GLboolean
ARB_texture_rgb10_a2ui
;
GLboolean
ARB_texture_view
;
GLboolean
ARB_timer_query
;
GLboolean
ARB_transform_feedback2
;
GLboolean
ARB_transform_feedback3
;
GLboolean
ARB_transform_feedback_instanced
;
GLboolean
ARB_transform_feedback_overflow_query
;
GLboolean
ARB_uniform_buffer_object
;
GLboolean
ARB_vertex_attrib_64bit
;
GLboolean
ARB_vertex_program
;
GLboolean
ARB_vertex_shader
;
GLboolean
ARB_vertex_type_10f_11f_11f_rev
;
GLboolean
ARB_vertex_type_2_10_10_10_rev
;
GLboolean
ARB_viewport_array
;
GLboolean
EXT_blend_color
;
GLboolean
EXT_blend_equation_separate
;
GLboolean
EXT_blend_func_separate
;
GLboolean
EXT_blend_minmax
;
GLboolean
EXT_demote_to_helper_invocation
;
GLboolean
EXT_depth_bounds_test
;
GLboolean
EXT_disjoint_timer_query
;
GLboolean
EXT_draw_buffers2
;
GLboolean
EXT_EGL_image_storage
;
GLboolean
EXT_float_blend
;
GLboolean
EXT_framebuffer_multisample
;
GLboolean
EXT_framebuffer_multisample_blit_scaled
;
GLboolean
EXT_framebuffer_sRGB
;
GLboolean
EXT_gpu_program_parameters
;
GLboolean
EXT_gpu_shader4
;
GLboolean
EXT_memory_object
;
GLboolean
EXT_memory_object_fd
;
GLboolean
EXT_multisampled_render_to_texture
;
GLboolean
EXT_packed_float
;
GLboolean
EXT_pixel_buffer_object
;
GLboolean
EXT_point_parameters
;
GLboolean
EXT_provoking_vertex
;
GLboolean
EXT_render_snorm
;
GLboolean
EXT_semaphore
;
GLboolean
EXT_semaphore_fd
;
GLboolean
EXT_shader_image_load_formatted
;
GLboolean
EXT_shader_image_load_store
;
GLboolean
EXT_shader_integer_mix
;
GLboolean
EXT_shader_samples_identical
;
GLboolean
EXT_sRGB
;
GLboolean
EXT_stencil_two_side
;
GLboolean
EXT_texture_array
;
GLboolean
EXT_texture_buffer_object
;
GLboolean
EXT_texture_compression_latc
;
GLboolean
EXT_texture_compression_s3tc
;
GLboolean
EXT_texture_compression_s3tc_srgb
;
GLboolean
EXT_texture_env_dot3
;
GLboolean
EXT_texture_filter_anisotropic
;
GLboolean
EXT_texture_integer
;
GLboolean
EXT_texture_mirror_clamp
;
GLboolean
EXT_texture_norm16
;
GLboolean
EXT_texture_shadow_lod
;
GLboolean
EXT_texture_shared_exponent
;
GLboolean
EXT_texture_snorm
;
GLboolean
EXT_texture_sRGB
;
GLboolean
EXT_texture_sRGB_R8
;
GLboolean
EXT_texture_sRGB_decode
;
GLboolean
EXT_texture_swizzle
;
GLboolean
EXT_texture_type_2_10_10_10_REV
;
GLboolean
EXT_transform_feedback
;
GLboolean
EXT_timer_query
;
GLboolean
EXT_vertex_array_bgra
;
GLboolean
EXT_window_rectangles
;
GLboolean
OES_copy_image
;
GLboolean
OES_primitive_bounding_box
;
GLboolean
OES_sample_variables
;
GLboolean
OES_standard_derivatives
;
GLboolean
OES_texture_buffer
;
GLboolean
OES_texture_cube_map_array
;
GLboolean
OES_texture_view
;
GLboolean
OES_viewport_array
;
GLboolean
AMD_compressed_ATC_texture
;
GLboolean
AMD_framebuffer_multisample_advanced
;
GLboolean
AMD_depth_clamp_separate
;
GLboolean
AMD_performance_monitor
;
GLboolean
AMD_pinned_memory
;
GLboolean
AMD_seamless_cubemap_per_texture
;
GLboolean
AMD_vertex_shader_layer
;
GLboolean
AMD_vertex_shader_viewport_index
;
GLboolean
ANDROID_extension_pack_es31a
;
GLboolean
APPLE_object_purgeable
;
GLboolean
ATI_meminfo
;
GLboolean
ATI_texture_compression_3dc
;
GLboolean
ATI_texture_mirror_once
;
GLboolean
ATI_texture_env_combine3
;
GLboolean
ATI_fragment_shader
;
GLboolean
GREMEDY_string_marker
;
GLboolean
INTEL_blackhole_render
;
GLboolean
INTEL_conservative_rasterization
;
GLboolean
INTEL_performance_query
;
GLboolean
INTEL_shader_atomic_float_minmax
;
GLboolean
INTEL_shader_integer_functions2
;
GLboolean
KHR_blend_equation_advanced
;
GLboolean
KHR_blend_equation_advanced_coherent
;
GLboolean
KHR_robustness
;
GLboolean
KHR_texture_compression_astc_hdr
;
GLboolean
KHR_texture_compression_astc_ldr
;
GLboolean
KHR_texture_compression_astc_sliced_3d
;
GLboolean
MESA_framebuffer_flip_y
;
GLboolean
MESA_tile_raster_order
;
GLboolean
MESA_pack_invert
;
GLboolean
EXT_shader_framebuffer_fetch
;
GLboolean
EXT_shader_framebuffer_fetch_non_coherent
;
GLboolean
MESA_shader_integer_functions
;
GLboolean
MESA_ycbcr_texture
;
GLboolean
NV_alpha_to_coverage_dither_control
;
GLboolean
NV_compute_shader_derivatives
;
GLboolean
NV_conditional_render
;
GLboolean
NV_copy_image
;
GLboolean
NV_fill_rectangle
;
GLboolean
NV_fog_distance
;
GLboolean
NV_point_sprite
;
GLboolean
NV_primitive_restart
;
GLboolean
NV_shader_atomic_float
;
GLboolean
NV_texture_barrier
;
GLboolean
NV_texture_env_combine4
;
GLboolean
NV_texture_rectangle
;
GLboolean
NV_vdpau_interop
;
GLboolean
NV_conservative_raster
;
GLboolean
NV_conservative_raster_dilate
;
GLboolean
NV_conservative_raster_pre_snap_triangles
;
GLboolean
NV_conservative_raster_pre_snap
;
GLboolean
NV_viewport_array2
;
GLboolean
NV_viewport_swizzle
;
GLboolean
NVX_gpu_memory_info
;
GLboolean
TDFX_texture_compression_FXT1
;
GLboolean
OES_EGL_image
;
GLboolean
OES_draw_texture
;
GLboolean
OES_depth_texture_cube_map
;
GLboolean
OES_EGL_image_external
;
GLboolean
OES_texture_float
;
GLboolean
OES_texture_float_linear
;
GLboolean
OES_texture_half_float
;
GLboolean
OES_texture_half_float_linear
;
GLboolean
OES_compressed_ETC1_RGB8_texture
;
GLboolean
OES_geometry_shader
;
GLboolean
OES_texture_compression_astc
;
GLboolean
extension_sentinel
;
const
GLubyte
*
String
;
GLuint
Count
;
GLubyte
Version
;
}
;
struct
gl_matrix_stack
{
GLmatrix
*
Top
;
GLmatrix
*
Stack
;
unsigned
StackSize
;
GLuint
Depth
;
GLuint
MaxDepth
;
GLuint
DirtyFlag
;
}
;
#
define
IMAGE_SCALE_BIAS_BIT
0x1
#
define
IMAGE_SHIFT_OFFSET_BIT
0x2
#
define
IMAGE_MAP_COLOR_BIT
0x4
#
define
IMAGE_CLAMP_BIT
0x800
#
define
IMAGE_BITS
(
IMAGE_SCALE_BIAS_BIT
|
\
IMAGE_SHIFT_OFFSET_BIT
|
\
IMAGE_MAP_COLOR_BIT
)
#
define
_NEW_MODELVIEW
(
1u
<
<
0
)
/
*
*
<
gl_context
:
:
ModelView
*
/
#
define
_NEW_PROJECTION
(
1u
<
<
1
)
/
*
*
<
gl_context
:
:
Projection
*
/
#
define
_NEW_TEXTURE_MATRIX
(
1u
<
<
2
)
/
*
*
<
gl_context
:
:
TextureMatrix
*
/
#
define
_NEW_COLOR
(
1u
<
<
3
)
/
*
*
<
gl_context
:
:
Color
*
/
#
define
_NEW_DEPTH
(
1u
<
<
4
)
/
*
*
<
gl_context
:
:
Depth
*
/
#
define
_NEW_FOG
(
1u
<
<
6
)
/
*
*
<
gl_context
:
:
Fog
*
/
#
define
_NEW_HINT
(
1u
<
<
7
)
/
*
*
<
gl_context
:
:
Hint
*
/
#
define
_NEW_LIGHT
(
1u
<
<
8
)
/
*
*
<
gl_context
:
:
Light
*
/
#
define
_NEW_LINE
(
1u
<
<
9
)
/
*
*
<
gl_context
:
:
Line
*
/
#
define
_NEW_PIXEL
(
1u
<
<
10
)
/
*
*
<
gl_context
:
:
Pixel
*
/
#
define
_NEW_POINT
(
1u
<
<
11
)
/
*
*
<
gl_context
:
:
Point
*
/
#
define
_NEW_POLYGON
(
1u
<
<
12
)
/
*
*
<
gl_context
:
:
Polygon
*
/
#
define
_NEW_POLYGONSTIPPLE
(
1u
<
<
13
)
/
*
*
<
gl_context
:
:
PolygonStipple
*
/
#
define
_NEW_SCISSOR
(
1u
<
<
14
)
/
*
*
<
gl_context
:
:
Scissor
*
/
#
define
_NEW_STENCIL
(
1u
<
<
15
)
/
*
*
<
gl_context
:
:
Stencil
*
/
#
define
_NEW_TEXTURE_OBJECT
(
1u
<
<
16
)
/
*
*
<
gl_context
:
:
Texture
(
bindings
only
)
*
/
#
define
_NEW_TRANSFORM
(
1u
<
<
17
)
/
*
*
<
gl_context
:
:
Transform
*
/
#
define
_NEW_VIEWPORT
(
1u
<
<
18
)
/
*
*
<
gl_context
:
:
Viewport
*
/
#
define
_NEW_TEXTURE_STATE
(
1u
<
<
19
)
/
*
*
<
gl_context
:
:
Texture
(
states
only
)
*
/
#
define
_NEW_RENDERMODE
(
1u
<
<
21
)
/
*
*
<
gl_context
:
:
RenderMode
etc
*
/
#
define
_NEW_BUFFERS
(
1u
<
<
22
)
/
*
*
<
gl_context
:
:
Visual
DrawBuffer
*
/
#
define
_NEW_CURRENT_ATTRIB
(
1u
<
<
23
)
/
*
*
<
gl_context
:
:
Current
*
/
#
define
_NEW_MULTISAMPLE
(
1u
<
<
24
)
/
*
*
<
gl_context
:
:
Multisample
*
/
#
define
_NEW_TRACK_MATRIX
(
1u
<
<
25
)
/
*
*
<
gl_context
:
:
VertexProgram
*
/
#
define
_NEW_PROGRAM
(
1u
<
<
26
)
/
*
*
<
New
program
/
shader
state
*
/
#
define
_NEW_PROGRAM_CONSTANTS
(
1u
<
<
27
)
#
define
_NEW_FRAG_CLAMP
(
1u
<
<
29
)
#
define
_NEW_VARYING_VP_INPUTS
(
1u
<
<
31
)
/
*
*
<
gl_context
:
:
varying_vp_inputs
*
/
#
define
_NEW_ALL
~
0
#
define
_NEW_TEXTURE
(
_NEW_TEXTURE_OBJECT
|
_NEW_TEXTURE_STATE
)
#
define
_MESA_NEW_NEED_EYE_COORDS
(
_NEW_LIGHT
|
\
_NEW_TEXTURE_STATE
|
\
_NEW_POINT
|
\
_NEW_PROGRAM
|
\
_NEW_MODELVIEW
)
#
define
_MESA_NEW_SEPARATE_SPECULAR
(
_NEW_LIGHT
|
\
_NEW_FOG
|
\
_NEW_PROGRAM
)
#
include
"
dd
.
h
"
union
gl_dlist_node
;
struct
gl_display_list
{
GLuint
Name
;
GLbitfield
Flags
;
GLchar
*
Label
;
union
gl_dlist_node
*
Head
;
}
;
struct
gl_dlist_state
{
struct
gl_display_list
*
CurrentList
;
union
gl_dlist_node
*
CurrentBlock
;
GLuint
CurrentPos
;
GLuint
CallDepth
;
GLvertexformat
ListVtxfmt
;
GLubyte
ActiveAttribSize
[
VERT_ATTRIB_MAX
]
;
uint32_t
CurrentAttrib
[
VERT_ATTRIB_MAX
]
[
8
]
;
GLubyte
ActiveMaterialSize
[
MAT_ATTRIB_MAX
]
;
GLfloat
CurrentMaterial
[
MAT_ATTRIB_MAX
]
[
4
]
;
struct
{
GLenum16
ShadeModel
;
}
Current
;
}
;
struct
gl_driver_flags
{
uint64_t
NewArray
;
uint64_t
NewTransformFeedback
;
uint64_t
NewTransformFeedbackProg
;
uint64_t
NewRasterizerDiscard
;
uint64_t
NewTileRasterOrder
;
uint64_t
NewUniformBuffer
;
uint64_t
NewShaderStorageBuffer
;
uint64_t
NewTextureBuffer
;
uint64_t
NewAtomicBuffer
;
uint64_t
NewImageUnits
;
uint64_t
NewDefaultTessLevels
;
uint64_t
NewIntelConservativeRasterization
;
uint64_t
NewNvConservativeRasterization
;
uint64_t
NewNvConservativeRasterizationParams
;
uint64_t
NewWindowRectangles
;
uint64_t
NewFramebufferSRGB
;
uint64_t
NewScissorTest
;
uint64_t
NewScissorRect
;
uint64_t
NewAlphaTest
;
uint64_t
NewBlend
;
uint64_t
NewBlendColor
;
uint64_t
NewColorMask
;
uint64_t
NewDepth
;
uint64_t
NewLogicOp
;
uint64_t
NewMultisampleEnable
;
uint64_t
NewSampleAlphaToXEnable
;
uint64_t
NewSampleMask
;
uint64_t
NewSampleShading
;
uint64_t
NewStencil
;
uint64_t
NewClipControl
;
uint64_t
NewClipPlane
;
uint64_t
NewClipPlaneEnable
;
uint64_t
NewDepthClamp
;
uint64_t
NewLineState
;
uint64_t
NewPolygonState
;
uint64_t
NewPolygonStipple
;
uint64_t
NewViewport
;
uint64_t
NewShaderConstants
[
MESA_SHADER_STAGES
]
;
uint64_t
NewSampleLocations
;
}
;
struct
gl_buffer_binding
{
struct
gl_buffer_object
*
BufferObject
;
GLintptr
Offset
;
GLsizeiptr
Size
;
GLboolean
AutomaticSize
;
}
;
struct
gl_image_unit
{
struct
gl_texture_object
*
TexObj
;
GLubyte
Level
;
GLboolean
Layered
;
GLushort
Layer
;
GLushort
_Layer
;
GLenum16
Access
;
GLenum16
Format
;
mesa_format
_ActualFormat
:
16
;
}
;
struct
gl_subroutine_index_binding
{
GLuint
NumIndex
;
GLuint
*
IndexPtr
;
}
;
struct
gl_texture_handle_object
{
struct
gl_texture_object
*
texObj
;
struct
gl_sampler_object
*
sampObj
;
GLuint64
handle
;
}
;
struct
gl_image_handle_object
{
struct
gl_image_unit
imgObj
;
GLuint64
handle
;
}
;
struct
gl_memory_object
{
GLuint
Name
;
GLboolean
Immutable
;
GLboolean
Dedicated
;
}
;
struct
gl_semaphore_object
{
GLuint
Name
;
}
;
struct
gl_context
{
struct
gl_shared_state
*
Shared
;
gl_api
API
;
struct
_glapi_table
*
Exec
;
struct
_glapi_table
*
OutsideBeginEnd
;
struct
_glapi_table
*
Save
;
struct
_glapi_table
*
BeginEnd
;
struct
_glapi_table
*
ContextLost
;
struct
_glapi_table
*
MarshalExec
;
struct
_glapi_table
*
CurrentClientDispatch
;
struct
_glapi_table
*
CurrentServerDispatch
;
struct
glthread_state
GLThread
;
struct
gl_config
Visual
;
struct
gl_framebuffer
*
DrawBuffer
;
struct
gl_framebuffer
*
ReadBuffer
;
struct
gl_framebuffer
*
WinSysDrawBuffer
;
struct
gl_framebuffer
*
WinSysReadBuffer
;
struct
dd_function_table
Driver
;
struct
gl_constants
Const
;
struct
gl_matrix_stack
ModelviewMatrixStack
;
struct
gl_matrix_stack
ProjectionMatrixStack
;
struct
gl_matrix_stack
TextureMatrixStack
[
MAX_TEXTURE_UNITS
]
;
struct
gl_matrix_stack
ProgramMatrixStack
[
MAX_PROGRAM_MATRICES
]
;
struct
gl_matrix_stack
*
CurrentStack
;
GLmatrix
_ModelProjectMatrix
;
struct
gl_dlist_state
ListState
;
GLboolean
ExecuteFlag
;
GLboolean
CompileFlag
;
struct
gl_extensions
Extensions
;
GLuint
Version
;
char
*
VersionString
;
GLuint
AttribStackDepth
;
struct
gl_attrib_node
*
AttribStack
[
MAX_ATTRIB_STACK_DEPTH
]
;
struct
gl_accum_attrib
Accum
;
struct
gl_colorbuffer_attrib
Color
;
struct
gl_current_attrib
Current
;
struct
gl_depthbuffer_attrib
Depth
;
struct
gl_eval_attrib
Eval
;
struct
gl_fog_attrib
Fog
;
struct
gl_hint_attrib
Hint
;
struct
gl_light_attrib
Light
;
struct
gl_line_attrib
Line
;
struct
gl_list_attrib
List
;
struct
gl_multisample_attrib
Multisample
;
struct
gl_pixel_attrib
Pixel
;
struct
gl_point_attrib
Point
;
struct
gl_polygon_attrib
Polygon
;
GLuint
PolygonStipple
[
32
]
;
struct
gl_scissor_attrib
Scissor
;
struct
gl_stencil_attrib
Stencil
;
struct
gl_texture_attrib
Texture
;
struct
gl_transform_attrib
Transform
;
struct
gl_viewport_attrib
ViewportArray
[
MAX_VIEWPORTS
]
;
GLuint
SubpixelPrecisionBias
[
2
]
;
GLuint
ClientAttribStackDepth
;
struct
gl_attrib_node
*
ClientAttribStack
[
MAX_CLIENT_ATTRIB_STACK_DEPTH
]
;
struct
gl_array_attrib
Array
;
struct
gl_pixelstore_attrib
Pack
;
struct
gl_pixelstore_attrib
Unpack
;
struct
gl_pixelstore_attrib
DefaultPacking
;
struct
gl_pixelmaps
PixelMaps
;
struct
gl_evaluators
EvalMap
;
struct
gl_feedback
Feedback
;
struct
gl_selection
Select
;
struct
gl_program_state
Program
;
struct
gl_vertex_program_state
VertexProgram
;
struct
gl_fragment_program_state
FragmentProgram
;
struct
gl_geometry_program_state
GeometryProgram
;
struct
gl_compute_program_state
ComputeProgram
;
struct
gl_tess_ctrl_program_state
TessCtrlProgram
;
struct
gl_tess_eval_program_state
TessEvalProgram
;
struct
gl_ati_fragment_shader_state
ATIFragmentShader
;
struct
gl_pipeline_shader_state
Pipeline
;
struct
gl_pipeline_object
Shader
;
struct
gl_pipeline_object
*
_Shader
;
struct
nir_shader
*
SoftFP64
;
struct
gl_query_state
Query
;
struct
gl_transform_feedback_state
TransformFeedback
;
struct
gl_perf_monitor_state
PerfMonitor
;
struct
gl_perf_query_state
PerfQuery
;
struct
gl_buffer_object
*
DrawIndirectBuffer
;
struct
gl_buffer_object
*
ParameterBuffer
;
struct
gl_buffer_object
*
DispatchIndirectBuffer
;
struct
gl_buffer_object
*
CopyReadBuffer
;
struct
gl_buffer_object
*
CopyWriteBuffer
;
struct
gl_buffer_object
*
QueryBuffer
;
struct
gl_buffer_object
*
UniformBuffer
;
struct
gl_buffer_object
*
ShaderStorageBuffer
;
struct
gl_buffer_binding
UniformBufferBindings
[
MAX_COMBINED_UNIFORM_BUFFERS
]
;
struct
gl_buffer_binding
ShaderStorageBufferBindings
[
MAX_COMBINED_SHADER_STORAGE_BUFFERS
]
;
struct
gl_buffer_object
*
AtomicBuffer
;
struct
gl_buffer_object
*
ExternalVirtualMemoryBuffer
;
struct
gl_buffer_binding
AtomicBufferBindings
[
MAX_COMBINED_ATOMIC_BUFFERS
]
;
struct
gl_image_unit
ImageUnits
[
MAX_IMAGE_UNITS
]
;
struct
gl_subroutine_index_binding
SubroutineIndex
[
MESA_SHADER_STAGES
]
;
struct
gl_meta_state
*
Meta
;
struct
gl_renderbuffer
*
CurrentRenderbuffer
;
GLenum16
ErrorValue
;
const
char
*
ErrorDebugFmtString
;
GLuint
ErrorDebugCount
;
simple_mtx_t
DebugMutex
;
struct
gl_debug_state
*
Debug
;
GLenum16
RenderMode
;
GLbitfield
NewState
;
uint64_t
NewDriverState
;
struct
gl_driver_flags
DriverFlags
;
GLboolean
ViewportInitialized
;
GLboolean
_AllowDrawOutOfOrder
;
GLbitfield
varying_vp_inputs
;
GLbitfield
_ImageTransferState
;
GLfloat
_EyeZDir
[
3
]
;
GLfloat
_ModelViewInvScale
;
GLfloat
_ModelViewInvScaleEyespace
;
GLboolean
_NeedEyeCoords
;
GLboolean
_ForceEyeCoords
;
GLuint
TextureStateTimestamp
;
struct
gl_list_extensions
*
ListExt
;
GLboolean
FirstTimeCurrent
;
GLboolean
HasConfig
;
GLboolean
TextureFormatSupported
[
MESA_FORMAT_COUNT
]
;
GLboolean
RasterDiscard
;
GLboolean
IntelConservativeRasterization
;
GLboolean
ConservativeRasterization
;
GLfloat
ConservativeRasterDilate
;
GLenum16
ConservativeRasterMode
;
GLboolean
IntelBlackholeRender
;
bool
_AttribZeroAliasesVertex
;
GLboolean
TileRasterOrderFixed
;
GLboolean
TileRasterOrderIncreasingX
;
GLboolean
TileRasterOrderIncreasingY
;
void
*
swrast_context
;
void
*
swsetup_context
;
void
*
swtnl_context
;
struct
vbo_context
*
vbo_context
;
struct
st_context
*
st
;
const
void
*
vdpDevice
;
const
void
*
vdpGetProcAddress
;
struct
set
*
vdpSurfaces
;
GLboolean
ShareGroupReset
;
GLfloat
PrimitiveBoundingBox
[
8
]
;
struct
disk_cache
*
Cache
;
struct
hash_table_u64
*
ResidentTextureHandles
;
struct
hash_table_u64
*
ResidentImageHandles
;
bool
shader_builtin_ref
;
}
;
struct
gl_memory_info
{
unsigned
total_device_memory
;
unsigned
avail_device_memory
;
unsigned
total_staging_memory
;
unsigned
avail_staging_memory
;
unsigned
device_memory_evicted
;
unsigned
nr_device_memory_evictions
;
}
;
#
ifndef
NDEBUG
extern
int
MESA_VERBOSE
;
extern
int
MESA_DEBUG_FLAGS
;
#
else
#
define
MESA_VERBOSE
0
#
define
MESA_DEBUG_FLAGS
0
#
endif
enum
_verbose
{
VERBOSE_VARRAY
=
0x0001
VERBOSE_TEXTURE
=
0x0002
VERBOSE_MATERIAL
=
0x0004
VERBOSE_PIPELINE
=
0x0008
VERBOSE_DRIVER
=
0x0010
VERBOSE_STATE
=
0x0020
VERBOSE_API
=
0x0040
VERBOSE_DISPLAY_LIST
=
0x0100
VERBOSE_LIGHTING
=
0x0200
VERBOSE_PRIMS
=
0x0400
VERBOSE_VERTS
=
0x0800
VERBOSE_DISASSEM
=
0x1000
VERBOSE_DRAW
=
0x2000
VERBOSE_SWAPBUFFERS
=
0x4000
}
;
enum
_debug
{
DEBUG_SILENT
=
(
1
<
<
0
)
DEBUG_ALWAYS_FLUSH
=
(
1
<
<
1
)
DEBUG_INCOMPLETE_TEXTURE
=
(
1
<
<
2
)
DEBUG_INCOMPLETE_FBO
=
(
1
<
<
3
)
DEBUG_CONTEXT
=
(
1
<
<
4
)
}
;
#
ifdef
__cplusplus
}
#
endif
#
endif
