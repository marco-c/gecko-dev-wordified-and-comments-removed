#
ifndef
BITSET_H
#
define
BITSET_H
#
include
"
util
/
bitscan
.
h
"
#
include
"
util
/
macros
.
h
"
#
define
BITSET_WORD
unsigned
int
#
define
BITSET_WORDBITS
(
sizeof
(
BITSET_WORD
)
*
8
)
#
define
BITSET_WORDS
(
bits
)
(
(
(
bits
)
+
BITSET_WORDBITS
-
1
)
/
BITSET_WORDBITS
)
#
define
BITSET_DECLARE
(
name
bits
)
BITSET_WORD
name
[
BITSET_WORDS
(
bits
)
]
#
define
BITSET_COPY
(
x
y
)
memcpy
(
(
x
)
(
y
)
sizeof
(
x
)
)
#
define
BITSET_EQUAL
(
x
y
)
(
memcmp
(
(
x
)
(
y
)
sizeof
(
x
)
)
=
=
0
)
#
define
BITSET_ZERO
(
x
)
memset
(
(
x
)
0
sizeof
(
x
)
)
#
define
BITSET_ONES
(
x
)
memset
(
(
x
)
0xff
sizeof
(
x
)
)
#
define
BITSET_BITWORD
(
b
)
(
(
b
)
/
BITSET_WORDBITS
)
#
define
BITSET_BIT
(
b
)
(
1u
<
<
(
(
b
)
%
BITSET_WORDBITS
)
)
#
define
BITSET_TEST
(
x
b
)
(
(
(
x
)
[
BITSET_BITWORD
(
b
)
]
&
BITSET_BIT
(
b
)
)
!
=
0
)
#
define
BITSET_SET
(
x
b
)
(
(
x
)
[
BITSET_BITWORD
(
b
)
]
|
=
BITSET_BIT
(
b
)
)
#
define
BITSET_CLEAR
(
x
b
)
(
(
x
)
[
BITSET_BITWORD
(
b
)
]
&
=
~
BITSET_BIT
(
b
)
)
#
define
BITSET_MASK
(
b
)
(
(
(
b
)
%
BITSET_WORDBITS
=
=
0
)
?
~
0
:
BITSET_BIT
(
b
)
-
1
)
#
define
BITSET_RANGE
(
b
e
)
(
(
BITSET_MASK
(
(
e
)
+
1
)
)
&
~
(
BITSET_BIT
(
b
)
-
1
)
)
#
define
BITSET_TEST_RANGE
(
x
b
e
)
\
(
BITSET_BITWORD
(
b
)
=
=
BITSET_BITWORD
(
e
)
?
\
(
(
(
x
)
[
BITSET_BITWORD
(
b
)
]
&
BITSET_RANGE
(
b
e
)
)
!
=
0
)
:
\
(
assert
(
!
"
BITSET_TEST_RANGE
:
bit
range
crosses
word
boundary
"
)
0
)
)
#
define
BITSET_SET_RANGE
(
x
b
e
)
\
(
BITSET_BITWORD
(
b
)
=
=
BITSET_BITWORD
(
e
)
?
\
(
(
x
)
[
BITSET_BITWORD
(
b
)
]
|
=
BITSET_RANGE
(
b
e
)
)
:
\
(
assert
(
!
"
BITSET_SET_RANGE
:
bit
range
crosses
word
boundary
"
)
0
)
)
#
define
BITSET_CLEAR_RANGE
(
x
b
e
)
\
(
BITSET_BITWORD
(
b
)
=
=
BITSET_BITWORD
(
e
)
?
\
(
(
x
)
[
BITSET_BITWORD
(
b
)
]
&
=
~
BITSET_RANGE
(
b
e
)
)
:
\
(
assert
(
!
"
BITSET_CLEAR_RANGE
:
bit
range
crosses
word
boundary
"
)
0
)
)
static
inline
int
__bitset_ffs
(
const
BITSET_WORD
*
x
int
n
)
{
int
i
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
if
(
x
[
i
]
)
return
ffs
(
x
[
i
]
)
+
BITSET_WORDBITS
*
i
;
}
return
0
;
}
#
define
BITSET_FFS
(
x
)
__bitset_ffs
(
x
ARRAY_SIZE
(
x
)
)
static
inline
unsigned
__bitset_next_set
(
unsigned
i
BITSET_WORD
*
tmp
const
BITSET_WORD
*
set
unsigned
size
)
{
unsigned
bit
word
;
word
=
BITSET_BITWORD
(
i
)
;
while
(
*
tmp
=
=
0
)
{
word
+
+
;
if
(
word
>
=
BITSET_WORDS
(
size
)
)
return
size
;
*
tmp
=
set
[
word
]
;
}
bit
=
ffs
(
*
tmp
)
-
1
;
*
tmp
&
=
~
(
1ull
<
<
bit
)
;
return
word
*
BITSET_WORDBITS
+
bit
;
}
#
define
BITSET_FOREACH_SET
(
__i
__set
__size
)
\
for
(
BITSET_WORD
__tmp
=
*
(
__set
)
*
__foo
=
&
__tmp
;
__foo
!
=
NULL
;
__foo
=
NULL
)
\
for
(
__i
=
0
;
\
(
__i
=
__bitset_next_set
(
__i
&
__tmp
__set
__size
)
)
<
__size
;
)
#
ifdef
__cplusplus
#
define
DECLARE_BITSET_T
(
T
N
)
struct
T
{
\
EXPLICIT_CONVERSION
\
operator
bool
(
)
const
\
{
\
for
(
unsigned
i
=
0
;
i
<
BITSET_WORDS
(
N
)
;
i
+
+
)
\
if
(
words
[
i
]
)
\
return
true
;
\
return
false
;
\
}
\
\
T
&
\
operator
=
(
int
x
)
\
{
\
const
T
c
=
{
{
(
BITSET_WORD
)
x
}
}
;
\
return
*
this
=
c
;
\
}
\
\
friend
bool
\
operator
=
=
(
const
T
&
b
const
T
&
c
)
\
{
\
return
BITSET_EQUAL
(
b
.
words
c
.
words
)
;
\
}
\
\
friend
bool
\
operator
!
=
(
const
T
&
b
const
T
&
c
)
\
{
\
return
!
(
b
=
=
c
)
;
\
}
\
\
friend
bool
\
operator
=
=
(
const
T
&
b
int
x
)
\
{
\
const
T
c
=
{
{
(
BITSET_WORD
)
x
}
}
;
\
return
b
=
=
c
;
\
}
\
\
friend
bool
\
operator
!
=
(
const
T
&
b
int
x
)
\
{
\
return
!
(
b
=
=
x
)
;
\
}
\
\
friend
T
\
operator
~
(
const
T
&
b
)
\
{
\
T
c
;
\
for
(
unsigned
i
=
0
;
i
<
BITSET_WORDS
(
N
)
;
i
+
+
)
\
c
.
words
[
i
]
=
~
b
.
words
[
i
]
;
\
return
c
;
\
}
\
\
T
&
\
operator
|
=
(
const
T
&
b
)
\
{
\
for
(
unsigned
i
=
0
;
i
<
BITSET_WORDS
(
N
)
;
i
+
+
)
\
words
[
i
]
|
=
b
.
words
[
i
]
;
\
return
*
this
;
\
}
\
\
friend
T
\
operator
|
(
const
T
&
b
const
T
&
c
)
\
{
\
T
d
=
b
;
\
d
|
=
c
;
\
return
d
;
\
}
\
\
T
&
\
operator
&
=
(
const
T
&
b
)
\
{
\
for
(
unsigned
i
=
0
;
i
<
BITSET_WORDS
(
N
)
;
i
+
+
)
\
words
[
i
]
&
=
b
.
words
[
i
]
;
\
return
*
this
;
\
}
\
\
friend
T
\
operator
&
(
const
T
&
b
const
T
&
c
)
\
{
\
T
d
=
b
;
\
d
&
=
c
;
\
return
d
;
\
}
\
\
bool
\
test
(
unsigned
i
)
const
\
{
\
return
BITSET_TEST
(
words
i
)
;
\
}
\
\
T
&
\
set
(
unsigned
i
)
\
{
\
BITSET_SET
(
words
i
)
;
\
return
*
this
;
\
}
\
\
T
&
\
clear
(
unsigned
i
)
\
{
\
BITSET_CLEAR
(
words
i
)
;
\
return
*
this
;
\
}
\
\
BITSET_WORD
words
[
BITSET_WORDS
(
N
)
]
;
\
}
#
endif
#
endif
