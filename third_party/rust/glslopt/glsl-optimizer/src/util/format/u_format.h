#
ifndef
U_FORMAT_H
#
define
U_FORMAT_H
#
include
"
pipe
/
p_format
.
h
"
#
include
"
pipe
/
p_defines
.
h
"
#
include
"
util
/
u_debug
.
h
"
union
pipe_color_union
;
struct
pipe_screen
;
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
enum
util_format_layout
{
UTIL_FORMAT_LAYOUT_PLAIN
UTIL_FORMAT_LAYOUT_SUBSAMPLED
UTIL_FORMAT_LAYOUT_S3TC
UTIL_FORMAT_LAYOUT_RGTC
UTIL_FORMAT_LAYOUT_ETC
UTIL_FORMAT_LAYOUT_BPTC
UTIL_FORMAT_LAYOUT_ASTC
UTIL_FORMAT_LAYOUT_ATC
UTIL_FORMAT_LAYOUT_PLANAR2
UTIL_FORMAT_LAYOUT_PLANAR3
UTIL_FORMAT_LAYOUT_FXT1
=
10
UTIL_FORMAT_LAYOUT_OTHER
}
;
struct
util_format_block
{
unsigned
width
;
unsigned
height
;
unsigned
depth
;
unsigned
bits
;
}
;
enum
util_format_type
{
UTIL_FORMAT_TYPE_VOID
=
0
UTIL_FORMAT_TYPE_UNSIGNED
=
1
UTIL_FORMAT_TYPE_SIGNED
=
2
UTIL_FORMAT_TYPE_FIXED
=
3
UTIL_FORMAT_TYPE_FLOAT
=
4
}
;
enum
util_format_colorspace
{
UTIL_FORMAT_COLORSPACE_RGB
=
0
UTIL_FORMAT_COLORSPACE_SRGB
=
1
UTIL_FORMAT_COLORSPACE_YUV
=
2
UTIL_FORMAT_COLORSPACE_ZS
=
3
}
;
struct
util_format_channel_description
{
unsigned
type
:
5
;
unsigned
normalized
:
1
;
unsigned
pure_integer
:
1
;
unsigned
size
:
9
;
unsigned
shift
:
16
;
}
;
struct
util_format_description
{
enum
pipe_format
format
;
const
char
*
name
;
const
char
*
short_name
;
struct
util_format_block
block
;
enum
util_format_layout
layout
;
unsigned
nr_channels
:
3
;
unsigned
is_array
:
1
;
unsigned
is_bitmask
:
1
;
unsigned
is_mixed
:
1
;
unsigned
is_unorm
:
1
;
unsigned
is_snorm
:
1
;
struct
util_format_channel_description
channel
[
4
]
;
unsigned
char
swizzle
[
4
]
;
enum
util_format_colorspace
colorspace
;
void
(
*
unpack_rgba_8unorm
)
(
uint8_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_rgba_8unorm
)
(
uint8_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
fetch_rgba_8unorm
)
(
uint8_t
*
dst
const
uint8_t
*
src
unsigned
i
unsigned
j
)
;
void
(
*
unpack_rgba_float
)
(
float
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_rgba_float
)
(
uint8_t
*
dst
unsigned
dst_stride
const
float
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
fetch_rgba_float
)
(
float
*
dst
const
uint8_t
*
src
unsigned
i
unsigned
j
)
;
void
(
*
unpack_z_32unorm
)
(
uint32_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_z_32unorm
)
(
uint8_t
*
dst
unsigned
dst_stride
const
uint32_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
unpack_z_float
)
(
float
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_z_float
)
(
uint8_t
*
dst
unsigned
dst_stride
const
float
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
unpack_s_8uint
)
(
uint8_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_s_8uint
)
(
uint8_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
unpack_rgba_uint
)
(
uint32_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_rgba_uint
)
(
uint8_t
*
dst
unsigned
dst_stride
const
uint32_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
unpack_rgba_sint
)
(
int32_t
*
dst
unsigned
dst_stride
const
uint8_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
pack_rgba_sint
)
(
uint8_t
*
dst
unsigned
dst_stride
const
int32_t
*
src
unsigned
src_stride
unsigned
width
unsigned
height
)
;
void
(
*
fetch_rgba_uint
)
(
uint32_t
*
dst
const
uint8_t
*
src
unsigned
i
unsigned
j
)
;
void
(
*
fetch_rgba_sint
)
(
int32_t
*
dst
const
uint8_t
*
src
unsigned
i
unsigned
j
)
;
}
;
const
struct
util_format_description
*
util_format_description
(
enum
pipe_format
format
)
;
static
inline
const
char
*
util_format_name
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
"
PIPE_FORMAT_
?
?
?
"
;
}
return
desc
-
>
name
;
}
static
inline
const
char
*
util_format_short_name
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
"
?
?
?
"
;
}
return
desc
-
>
short_name
;
}
static
inline
boolean
util_format_is_plain
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
if
(
!
format
)
{
return
FALSE
;
}
return
desc
-
>
layout
=
=
UTIL_FORMAT_LAYOUT_PLAIN
?
TRUE
:
FALSE
;
}
static
inline
boolean
util_format_is_compressed
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
FALSE
;
}
switch
(
desc
-
>
layout
)
{
case
UTIL_FORMAT_LAYOUT_S3TC
:
case
UTIL_FORMAT_LAYOUT_RGTC
:
case
UTIL_FORMAT_LAYOUT_ETC
:
case
UTIL_FORMAT_LAYOUT_BPTC
:
case
UTIL_FORMAT_LAYOUT_ASTC
:
case
UTIL_FORMAT_LAYOUT_ATC
:
case
UTIL_FORMAT_LAYOUT_FXT1
:
return
TRUE
;
default
:
return
FALSE
;
}
}
static
inline
boolean
util_format_is_s3tc
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
FALSE
;
}
return
desc
-
>
layout
=
=
UTIL_FORMAT_LAYOUT_S3TC
?
TRUE
:
FALSE
;
}
static
inline
boolean
util_format_is_etc
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
FALSE
;
}
return
desc
-
>
layout
=
=
UTIL_FORMAT_LAYOUT_ETC
?
TRUE
:
FALSE
;
}
static
inline
boolean
util_format_is_srgb
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
return
desc
-
>
colorspace
=
=
UTIL_FORMAT_COLORSPACE_SRGB
;
}
static
inline
boolean
util_format_has_depth
(
const
struct
util_format_description
*
desc
)
{
return
desc
-
>
colorspace
=
=
UTIL_FORMAT_COLORSPACE_ZS
&
&
desc
-
>
swizzle
[
0
]
!
=
PIPE_SWIZZLE_NONE
;
}
static
inline
boolean
util_format_has_stencil
(
const
struct
util_format_description
*
desc
)
{
return
desc
-
>
colorspace
=
=
UTIL_FORMAT_COLORSPACE_ZS
&
&
desc
-
>
swizzle
[
1
]
!
=
PIPE_SWIZZLE_NONE
;
}
static
inline
boolean
util_format_is_depth_or_stencil
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
FALSE
;
}
return
util_format_has_depth
(
desc
)
|
|
util_format_has_stencil
(
desc
)
;
}
static
inline
boolean
util_format_is_depth_and_stencil
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
FALSE
;
}
return
util_format_has_depth
(
desc
)
&
&
util_format_has_stencil
(
desc
)
;
}
static
inline
enum
pipe_format
util_format_get_depth_only
(
enum
pipe_format
format
)
{
switch
(
format
)
{
case
PIPE_FORMAT_Z24_UNORM_S8_UINT
:
return
PIPE_FORMAT_Z24X8_UNORM
;
case
PIPE_FORMAT_S8_UINT_Z24_UNORM
:
return
PIPE_FORMAT_X8Z24_UNORM
;
case
PIPE_FORMAT_Z32_FLOAT_S8X24_UINT
:
return
PIPE_FORMAT_Z32_FLOAT
;
default
:
return
format
;
}
}
static
inline
boolean
util_format_is_yuv
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
FALSE
;
}
return
desc
-
>
colorspace
=
=
UTIL_FORMAT_COLORSPACE_YUV
;
}
static
inline
unsigned
util_get_depth_format_type
(
const
struct
util_format_description
*
desc
)
{
unsigned
depth_channel
=
desc
-
>
swizzle
[
0
]
;
if
(
desc
-
>
colorspace
=
=
UTIL_FORMAT_COLORSPACE_ZS
&
&
depth_channel
!
=
PIPE_SWIZZLE_NONE
)
{
return
desc
-
>
channel
[
depth_channel
]
.
type
;
}
else
{
return
UTIL_FORMAT_TYPE_VOID
;
}
}
double
util_get_depth_format_mrd
(
const
struct
util_format_description
*
desc
)
;
static
inline
unsigned
util_format_get_mask
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
if
(
!
desc
)
return
0
;
if
(
util_format_has_depth
(
desc
)
)
{
if
(
util_format_has_stencil
(
desc
)
)
{
return
PIPE_MASK_ZS
;
}
else
{
return
PIPE_MASK_Z
;
}
}
else
{
if
(
util_format_has_stencil
(
desc
)
)
{
return
PIPE_MASK_S
;
}
else
{
return
PIPE_MASK_RGBA
;
}
}
}
static
inline
unsigned
util_format_colormask
(
const
struct
util_format_description
*
desc
)
{
unsigned
colormask
;
unsigned
chan
;
switch
(
desc
-
>
colorspace
)
{
case
UTIL_FORMAT_COLORSPACE_RGB
:
case
UTIL_FORMAT_COLORSPACE_SRGB
:
case
UTIL_FORMAT_COLORSPACE_YUV
:
colormask
=
0
;
for
(
chan
=
0
;
chan
<
4
;
+
+
chan
)
{
if
(
desc
-
>
swizzle
[
chan
]
<
4
)
{
colormask
|
=
(
1
<
<
chan
)
;
}
}
return
colormask
;
case
UTIL_FORMAT_COLORSPACE_ZS
:
return
0
;
default
:
assert
(
0
)
;
return
0
;
}
}
static
inline
boolean
util_format_colormask_full
(
const
struct
util_format_description
*
desc
unsigned
colormask
)
{
return
(
~
colormask
&
util_format_colormask
(
desc
)
)
=
=
0
;
}
boolean
util_format_is_float
(
enum
pipe_format
format
)
;
boolean
util_format_has_alpha
(
enum
pipe_format
format
)
;
boolean
util_format_is_luminance
(
enum
pipe_format
format
)
;
boolean
util_format_is_alpha
(
enum
pipe_format
format
)
;
boolean
util_format_is_luminance_alpha
(
enum
pipe_format
format
)
;
boolean
util_format_is_intensity
(
enum
pipe_format
format
)
;
boolean
util_format_is_subsampled_422
(
enum
pipe_format
format
)
;
boolean
util_format_is_pure_integer
(
enum
pipe_format
format
)
;
boolean
util_format_is_pure_sint
(
enum
pipe_format
format
)
;
boolean
util_format_is_pure_uint
(
enum
pipe_format
format
)
;
boolean
util_format_is_snorm
(
enum
pipe_format
format
)
;
boolean
util_format_is_unorm
(
enum
pipe_format
format
)
;
boolean
util_format_is_snorm8
(
enum
pipe_format
format
)
;
boolean
util_is_format_compatible
(
const
struct
util_format_description
*
src_desc
const
struct
util_format_description
*
dst_desc
)
;
static
inline
boolean
util_format_is_rgba8_variant
(
const
struct
util_format_description
*
desc
)
{
unsigned
chan
;
if
(
desc
-
>
block
.
width
!
=
1
|
|
desc
-
>
block
.
height
!
=
1
|
|
desc
-
>
block
.
bits
!
=
32
)
return
FALSE
;
for
(
chan
=
0
;
chan
<
4
;
+
+
chan
)
{
if
(
desc
-
>
channel
[
chan
]
.
type
!
=
UTIL_FORMAT_TYPE_UNSIGNED
&
&
desc
-
>
channel
[
chan
]
.
type
!
=
UTIL_FORMAT_TYPE_VOID
)
return
FALSE
;
if
(
desc
-
>
channel
[
chan
]
.
type
=
=
UTIL_FORMAT_TYPE_UNSIGNED
&
&
!
desc
-
>
channel
[
chan
]
.
normalized
)
return
FALSE
;
if
(
desc
-
>
channel
[
chan
]
.
size
!
=
8
)
return
FALSE
;
}
return
TRUE
;
}
static
inline
uint
util_format_get_blocksizebits
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
0
;
}
return
desc
-
>
block
.
bits
;
}
static
inline
uint
util_format_get_blocksize
(
enum
pipe_format
format
)
{
uint
bits
=
util_format_get_blocksizebits
(
format
)
;
uint
bytes
=
bits
/
8
;
assert
(
bits
%
8
=
=
0
)
;
assert
(
bytes
>
0
)
;
if
(
bytes
=
=
0
)
{
bytes
=
1
;
}
return
bytes
;
}
static
inline
uint
util_format_get_blockwidth
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
1
;
}
return
desc
-
>
block
.
width
;
}
static
inline
uint
util_format_get_blockheight
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
1
;
}
return
desc
-
>
block
.
height
;
}
static
inline
uint
util_format_get_blockdepth
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
assert
(
desc
)
;
if
(
!
desc
)
{
return
1
;
}
return
desc
-
>
block
.
depth
;
}
static
inline
unsigned
util_format_get_nblocksx
(
enum
pipe_format
format
unsigned
x
)
{
unsigned
blockwidth
=
util_format_get_blockwidth
(
format
)
;
return
(
x
+
blockwidth
-
1
)
/
blockwidth
;
}
static
inline
unsigned
util_format_get_nblocksy
(
enum
pipe_format
format
unsigned
y
)
{
unsigned
blockheight
=
util_format_get_blockheight
(
format
)
;
return
(
y
+
blockheight
-
1
)
/
blockheight
;
}
static
inline
unsigned
util_format_get_nblocksz
(
enum
pipe_format
format
unsigned
z
)
{
unsigned
blockdepth
=
util_format_get_blockdepth
(
format
)
;
return
(
z
+
blockdepth
-
1
)
/
blockdepth
;
}
static
inline
unsigned
util_format_get_nblocks
(
enum
pipe_format
format
unsigned
width
unsigned
height
)
{
assert
(
util_format_get_blockdepth
(
format
)
=
=
1
)
;
return
util_format_get_nblocksx
(
format
width
)
*
util_format_get_nblocksy
(
format
height
)
;
}
static
inline
size_t
util_format_get_stride
(
enum
pipe_format
format
unsigned
width
)
{
return
(
size_t
)
util_format_get_nblocksx
(
format
width
)
*
util_format_get_blocksize
(
format
)
;
}
static
inline
size_t
util_format_get_2d_size
(
enum
pipe_format
format
size_t
stride
unsigned
height
)
{
return
util_format_get_nblocksy
(
format
height
)
*
stride
;
}
static
inline
uint
util_format_get_component_bits
(
enum
pipe_format
format
enum
util_format_colorspace
colorspace
uint
component
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
enum
util_format_colorspace
desc_colorspace
;
assert
(
format
)
;
if
(
!
format
)
{
return
0
;
}
assert
(
component
<
4
)
;
if
(
colorspace
=
=
UTIL_FORMAT_COLORSPACE_SRGB
)
{
colorspace
=
UTIL_FORMAT_COLORSPACE_RGB
;
}
if
(
desc
-
>
colorspace
=
=
UTIL_FORMAT_COLORSPACE_SRGB
)
{
desc_colorspace
=
UTIL_FORMAT_COLORSPACE_RGB
;
}
else
{
desc_colorspace
=
desc
-
>
colorspace
;
}
if
(
desc_colorspace
!
=
colorspace
)
{
return
0
;
}
switch
(
desc
-
>
swizzle
[
component
]
)
{
case
PIPE_SWIZZLE_X
:
return
desc
-
>
channel
[
0
]
.
size
;
case
PIPE_SWIZZLE_Y
:
return
desc
-
>
channel
[
1
]
.
size
;
case
PIPE_SWIZZLE_Z
:
return
desc
-
>
channel
[
2
]
.
size
;
case
PIPE_SWIZZLE_W
:
return
desc
-
>
channel
[
3
]
.
size
;
default
:
return
0
;
}
}
static
inline
enum
pipe_format
util_format_srgb
(
enum
pipe_format
format
)
{
if
(
util_format_is_srgb
(
format
)
)
return
format
;
switch
(
format
)
{
case
PIPE_FORMAT_L8_UNORM
:
return
PIPE_FORMAT_L8_SRGB
;
case
PIPE_FORMAT_R8_UNORM
:
return
PIPE_FORMAT_R8_SRGB
;
case
PIPE_FORMAT_L8A8_UNORM
:
return
PIPE_FORMAT_L8A8_SRGB
;
case
PIPE_FORMAT_R8G8_UNORM
:
return
PIPE_FORMAT_R8G8_SRGB
;
case
PIPE_FORMAT_R8G8B8_UNORM
:
return
PIPE_FORMAT_R8G8B8_SRGB
;
case
PIPE_FORMAT_B8G8R8_UNORM
:
return
PIPE_FORMAT_B8G8R8_SRGB
;
case
PIPE_FORMAT_A8B8G8R8_UNORM
:
return
PIPE_FORMAT_A8B8G8R8_SRGB
;
case
PIPE_FORMAT_X8B8G8R8_UNORM
:
return
PIPE_FORMAT_X8B8G8R8_SRGB
;
case
PIPE_FORMAT_B8G8R8A8_UNORM
:
return
PIPE_FORMAT_B8G8R8A8_SRGB
;
case
PIPE_FORMAT_B8G8R8X8_UNORM
:
return
PIPE_FORMAT_B8G8R8X8_SRGB
;
case
PIPE_FORMAT_A8R8G8B8_UNORM
:
return
PIPE_FORMAT_A8R8G8B8_SRGB
;
case
PIPE_FORMAT_X8R8G8B8_UNORM
:
return
PIPE_FORMAT_X8R8G8B8_SRGB
;
case
PIPE_FORMAT_R8G8B8A8_UNORM
:
return
PIPE_FORMAT_R8G8B8A8_SRGB
;
case
PIPE_FORMAT_R8G8B8X8_UNORM
:
return
PIPE_FORMAT_R8G8B8X8_SRGB
;
case
PIPE_FORMAT_DXT1_RGB
:
return
PIPE_FORMAT_DXT1_SRGB
;
case
PIPE_FORMAT_DXT1_RGBA
:
return
PIPE_FORMAT_DXT1_SRGBA
;
case
PIPE_FORMAT_DXT3_RGBA
:
return
PIPE_FORMAT_DXT3_SRGBA
;
case
PIPE_FORMAT_DXT5_RGBA
:
return
PIPE_FORMAT_DXT5_SRGBA
;
case
PIPE_FORMAT_B5G6R5_UNORM
:
return
PIPE_FORMAT_B5G6R5_SRGB
;
case
PIPE_FORMAT_BPTC_RGBA_UNORM
:
return
PIPE_FORMAT_BPTC_SRGBA
;
case
PIPE_FORMAT_ETC2_RGB8
:
return
PIPE_FORMAT_ETC2_SRGB8
;
case
PIPE_FORMAT_ETC2_RGB8A1
:
return
PIPE_FORMAT_ETC2_SRGB8A1
;
case
PIPE_FORMAT_ETC2_RGBA8
:
return
PIPE_FORMAT_ETC2_SRGBA8
;
case
PIPE_FORMAT_ASTC_4x4
:
return
PIPE_FORMAT_ASTC_4x4_SRGB
;
case
PIPE_FORMAT_ASTC_5x4
:
return
PIPE_FORMAT_ASTC_5x4_SRGB
;
case
PIPE_FORMAT_ASTC_5x5
:
return
PIPE_FORMAT_ASTC_5x5_SRGB
;
case
PIPE_FORMAT_ASTC_6x5
:
return
PIPE_FORMAT_ASTC_6x5_SRGB
;
case
PIPE_FORMAT_ASTC_6x6
:
return
PIPE_FORMAT_ASTC_6x6_SRGB
;
case
PIPE_FORMAT_ASTC_8x5
:
return
PIPE_FORMAT_ASTC_8x5_SRGB
;
case
PIPE_FORMAT_ASTC_8x6
:
return
PIPE_FORMAT_ASTC_8x6_SRGB
;
case
PIPE_FORMAT_ASTC_8x8
:
return
PIPE_FORMAT_ASTC_8x8_SRGB
;
case
PIPE_FORMAT_ASTC_10x5
:
return
PIPE_FORMAT_ASTC_10x5_SRGB
;
case
PIPE_FORMAT_ASTC_10x6
:
return
PIPE_FORMAT_ASTC_10x6_SRGB
;
case
PIPE_FORMAT_ASTC_10x8
:
return
PIPE_FORMAT_ASTC_10x8_SRGB
;
case
PIPE_FORMAT_ASTC_10x10
:
return
PIPE_FORMAT_ASTC_10x10_SRGB
;
case
PIPE_FORMAT_ASTC_12x10
:
return
PIPE_FORMAT_ASTC_12x10_SRGB
;
case
PIPE_FORMAT_ASTC_12x12
:
return
PIPE_FORMAT_ASTC_12x12_SRGB
;
case
PIPE_FORMAT_ASTC_3x3x3
:
return
PIPE_FORMAT_ASTC_3x3x3_SRGB
;
case
PIPE_FORMAT_ASTC_4x3x3
:
return
PIPE_FORMAT_ASTC_4x3x3_SRGB
;
case
PIPE_FORMAT_ASTC_4x4x3
:
return
PIPE_FORMAT_ASTC_4x4x3_SRGB
;
case
PIPE_FORMAT_ASTC_4x4x4
:
return
PIPE_FORMAT_ASTC_4x4x4_SRGB
;
case
PIPE_FORMAT_ASTC_5x4x4
:
return
PIPE_FORMAT_ASTC_5x4x4_SRGB
;
case
PIPE_FORMAT_ASTC_5x5x4
:
return
PIPE_FORMAT_ASTC_5x5x4_SRGB
;
case
PIPE_FORMAT_ASTC_5x5x5
:
return
PIPE_FORMAT_ASTC_5x5x5_SRGB
;
case
PIPE_FORMAT_ASTC_6x5x5
:
return
PIPE_FORMAT_ASTC_6x5x5_SRGB
;
case
PIPE_FORMAT_ASTC_6x6x5
:
return
PIPE_FORMAT_ASTC_6x6x5_SRGB
;
case
PIPE_FORMAT_ASTC_6x6x6
:
return
PIPE_FORMAT_ASTC_6x6x6_SRGB
;
default
:
return
PIPE_FORMAT_NONE
;
}
}
static
inline
enum
pipe_format
util_format_linear
(
enum
pipe_format
format
)
{
switch
(
format
)
{
case
PIPE_FORMAT_L8_SRGB
:
return
PIPE_FORMAT_L8_UNORM
;
case
PIPE_FORMAT_R8_SRGB
:
return
PIPE_FORMAT_R8_UNORM
;
case
PIPE_FORMAT_L8A8_SRGB
:
return
PIPE_FORMAT_L8A8_UNORM
;
case
PIPE_FORMAT_R8G8_SRGB
:
return
PIPE_FORMAT_R8G8_UNORM
;
case
PIPE_FORMAT_R8G8B8_SRGB
:
return
PIPE_FORMAT_R8G8B8_UNORM
;
case
PIPE_FORMAT_B8G8R8_SRGB
:
return
PIPE_FORMAT_B8G8R8_UNORM
;
case
PIPE_FORMAT_A8B8G8R8_SRGB
:
return
PIPE_FORMAT_A8B8G8R8_UNORM
;
case
PIPE_FORMAT_X8B8G8R8_SRGB
:
return
PIPE_FORMAT_X8B8G8R8_UNORM
;
case
PIPE_FORMAT_B8G8R8A8_SRGB
:
return
PIPE_FORMAT_B8G8R8A8_UNORM
;
case
PIPE_FORMAT_B8G8R8X8_SRGB
:
return
PIPE_FORMAT_B8G8R8X8_UNORM
;
case
PIPE_FORMAT_A8R8G8B8_SRGB
:
return
PIPE_FORMAT_A8R8G8B8_UNORM
;
case
PIPE_FORMAT_X8R8G8B8_SRGB
:
return
PIPE_FORMAT_X8R8G8B8_UNORM
;
case
PIPE_FORMAT_R8G8B8A8_SRGB
:
return
PIPE_FORMAT_R8G8B8A8_UNORM
;
case
PIPE_FORMAT_R8G8B8X8_SRGB
:
return
PIPE_FORMAT_R8G8B8X8_UNORM
;
case
PIPE_FORMAT_DXT1_SRGB
:
return
PIPE_FORMAT_DXT1_RGB
;
case
PIPE_FORMAT_DXT1_SRGBA
:
return
PIPE_FORMAT_DXT1_RGBA
;
case
PIPE_FORMAT_DXT3_SRGBA
:
return
PIPE_FORMAT_DXT3_RGBA
;
case
PIPE_FORMAT_DXT5_SRGBA
:
return
PIPE_FORMAT_DXT5_RGBA
;
case
PIPE_FORMAT_B5G6R5_SRGB
:
return
PIPE_FORMAT_B5G6R5_UNORM
;
case
PIPE_FORMAT_BPTC_SRGBA
:
return
PIPE_FORMAT_BPTC_RGBA_UNORM
;
case
PIPE_FORMAT_ETC2_SRGB8
:
return
PIPE_FORMAT_ETC2_RGB8
;
case
PIPE_FORMAT_ETC2_SRGB8A1
:
return
PIPE_FORMAT_ETC2_RGB8A1
;
case
PIPE_FORMAT_ETC2_SRGBA8
:
return
PIPE_FORMAT_ETC2_RGBA8
;
case
PIPE_FORMAT_ASTC_4x4_SRGB
:
return
PIPE_FORMAT_ASTC_4x4
;
case
PIPE_FORMAT_ASTC_5x4_SRGB
:
return
PIPE_FORMAT_ASTC_5x4
;
case
PIPE_FORMAT_ASTC_5x5_SRGB
:
return
PIPE_FORMAT_ASTC_5x5
;
case
PIPE_FORMAT_ASTC_6x5_SRGB
:
return
PIPE_FORMAT_ASTC_6x5
;
case
PIPE_FORMAT_ASTC_6x6_SRGB
:
return
PIPE_FORMAT_ASTC_6x6
;
case
PIPE_FORMAT_ASTC_8x5_SRGB
:
return
PIPE_FORMAT_ASTC_8x5
;
case
PIPE_FORMAT_ASTC_8x6_SRGB
:
return
PIPE_FORMAT_ASTC_8x6
;
case
PIPE_FORMAT_ASTC_8x8_SRGB
:
return
PIPE_FORMAT_ASTC_8x8
;
case
PIPE_FORMAT_ASTC_10x5_SRGB
:
return
PIPE_FORMAT_ASTC_10x5
;
case
PIPE_FORMAT_ASTC_10x6_SRGB
:
return
PIPE_FORMAT_ASTC_10x6
;
case
PIPE_FORMAT_ASTC_10x8_SRGB
:
return
PIPE_FORMAT_ASTC_10x8
;
case
PIPE_FORMAT_ASTC_10x10_SRGB
:
return
PIPE_FORMAT_ASTC_10x10
;
case
PIPE_FORMAT_ASTC_12x10_SRGB
:
return
PIPE_FORMAT_ASTC_12x10
;
case
PIPE_FORMAT_ASTC_12x12_SRGB
:
return
PIPE_FORMAT_ASTC_12x12
;
case
PIPE_FORMAT_ASTC_3x3x3_SRGB
:
return
PIPE_FORMAT_ASTC_3x3x3
;
case
PIPE_FORMAT_ASTC_4x3x3_SRGB
:
return
PIPE_FORMAT_ASTC_4x3x3
;
case
PIPE_FORMAT_ASTC_4x4x3_SRGB
:
return
PIPE_FORMAT_ASTC_4x4x3
;
case
PIPE_FORMAT_ASTC_4x4x4_SRGB
:
return
PIPE_FORMAT_ASTC_4x4x4
;
case
PIPE_FORMAT_ASTC_5x4x4_SRGB
:
return
PIPE_FORMAT_ASTC_5x4x4
;
case
PIPE_FORMAT_ASTC_5x5x4_SRGB
:
return
PIPE_FORMAT_ASTC_5x5x4
;
case
PIPE_FORMAT_ASTC_5x5x5_SRGB
:
return
PIPE_FORMAT_ASTC_5x5x5
;
case
PIPE_FORMAT_ASTC_6x5x5_SRGB
:
return
PIPE_FORMAT_ASTC_6x5x5
;
case
PIPE_FORMAT_ASTC_6x6x5_SRGB
:
return
PIPE_FORMAT_ASTC_6x6x5
;
case
PIPE_FORMAT_ASTC_6x6x6_SRGB
:
return
PIPE_FORMAT_ASTC_6x6x6
;
default
:
return
format
;
}
}
static
inline
enum
pipe_format
util_format_stencil_only
(
enum
pipe_format
format
)
{
switch
(
format
)
{
case
PIPE_FORMAT_Z24_UNORM_S8_UINT
:
return
PIPE_FORMAT_X24S8_UINT
;
case
PIPE_FORMAT_S8_UINT_Z24_UNORM
:
return
PIPE_FORMAT_S8X24_UINT
;
case
PIPE_FORMAT_Z32_FLOAT_S8X24_UINT
:
return
PIPE_FORMAT_X32_S8X24_UINT
;
case
PIPE_FORMAT_X24S8_UINT
:
case
PIPE_FORMAT_S8X24_UINT
:
case
PIPE_FORMAT_X32_S8X24_UINT
:
case
PIPE_FORMAT_S8_UINT
:
return
format
;
default
:
assert
(
0
)
;
return
PIPE_FORMAT_NONE
;
}
}
static
inline
enum
pipe_format
util_format_intensity_to_red
(
enum
pipe_format
format
)
{
switch
(
format
)
{
case
PIPE_FORMAT_I8_UNORM
:
return
PIPE_FORMAT_R8_UNORM
;
case
PIPE_FORMAT_I8_SNORM
:
return
PIPE_FORMAT_R8_SNORM
;
case
PIPE_FORMAT_I16_UNORM
:
return
PIPE_FORMAT_R16_UNORM
;
case
PIPE_FORMAT_I16_SNORM
:
return
PIPE_FORMAT_R16_SNORM
;
case
PIPE_FORMAT_I16_FLOAT
:
return
PIPE_FORMAT_R16_FLOAT
;
case
PIPE_FORMAT_I32_FLOAT
:
return
PIPE_FORMAT_R32_FLOAT
;
case
PIPE_FORMAT_I8_UINT
:
return
PIPE_FORMAT_R8_UINT
;
case
PIPE_FORMAT_I8_SINT
:
return
PIPE_FORMAT_R8_SINT
;
case
PIPE_FORMAT_I16_UINT
:
return
PIPE_FORMAT_R16_UINT
;
case
PIPE_FORMAT_I16_SINT
:
return
PIPE_FORMAT_R16_SINT
;
case
PIPE_FORMAT_I32_UINT
:
return
PIPE_FORMAT_R32_UINT
;
case
PIPE_FORMAT_I32_SINT
:
return
PIPE_FORMAT_R32_SINT
;
default
:
assert
(
!
util_format_is_intensity
(
format
)
)
;
return
format
;
}
}
static
inline
enum
pipe_format
util_format_luminance_to_red
(
enum
pipe_format
format
)
{
switch
(
format
)
{
case
PIPE_FORMAT_L8_UNORM
:
return
PIPE_FORMAT_R8_UNORM
;
case
PIPE_FORMAT_L8_SNORM
:
return
PIPE_FORMAT_R8_SNORM
;
case
PIPE_FORMAT_L16_UNORM
:
return
PIPE_FORMAT_R16_UNORM
;
case
PIPE_FORMAT_L16_SNORM
:
return
PIPE_FORMAT_R16_SNORM
;
case
PIPE_FORMAT_L16_FLOAT
:
return
PIPE_FORMAT_R16_FLOAT
;
case
PIPE_FORMAT_L32_FLOAT
:
return
PIPE_FORMAT_R32_FLOAT
;
case
PIPE_FORMAT_L8_UINT
:
return
PIPE_FORMAT_R8_UINT
;
case
PIPE_FORMAT_L8_SINT
:
return
PIPE_FORMAT_R8_SINT
;
case
PIPE_FORMAT_L16_UINT
:
return
PIPE_FORMAT_R16_UINT
;
case
PIPE_FORMAT_L16_SINT
:
return
PIPE_FORMAT_R16_SINT
;
case
PIPE_FORMAT_L32_UINT
:
return
PIPE_FORMAT_R32_UINT
;
case
PIPE_FORMAT_L32_SINT
:
return
PIPE_FORMAT_R32_SINT
;
case
PIPE_FORMAT_LATC1_UNORM
:
return
PIPE_FORMAT_RGTC1_UNORM
;
case
PIPE_FORMAT_LATC1_SNORM
:
return
PIPE_FORMAT_RGTC1_SNORM
;
case
PIPE_FORMAT_L4A4_UNORM
:
return
PIPE_FORMAT_R4A4_UNORM
;
case
PIPE_FORMAT_L8A8_UNORM
:
return
PIPE_FORMAT_R8A8_UNORM
;
case
PIPE_FORMAT_L8A8_SNORM
:
return
PIPE_FORMAT_R8A8_SNORM
;
case
PIPE_FORMAT_L16A16_UNORM
:
return
PIPE_FORMAT_R16A16_UNORM
;
case
PIPE_FORMAT_L16A16_SNORM
:
return
PIPE_FORMAT_R16A16_SNORM
;
case
PIPE_FORMAT_L16A16_FLOAT
:
return
PIPE_FORMAT_R16A16_FLOAT
;
case
PIPE_FORMAT_L32A32_FLOAT
:
return
PIPE_FORMAT_R32A32_FLOAT
;
case
PIPE_FORMAT_L8A8_UINT
:
return
PIPE_FORMAT_R8A8_UINT
;
case
PIPE_FORMAT_L8A8_SINT
:
return
PIPE_FORMAT_R8A8_SINT
;
case
PIPE_FORMAT_L16A16_UINT
:
return
PIPE_FORMAT_R16A16_UINT
;
case
PIPE_FORMAT_L16A16_SINT
:
return
PIPE_FORMAT_R16A16_SINT
;
case
PIPE_FORMAT_L32A32_UINT
:
return
PIPE_FORMAT_R32A32_UINT
;
case
PIPE_FORMAT_L32A32_SINT
:
return
PIPE_FORMAT_R32A32_SINT
;
case
PIPE_FORMAT_LATC2_UNORM
:
case
PIPE_FORMAT_LATC2_SNORM
:
return
PIPE_FORMAT_NONE
;
default
:
assert
(
!
util_format_is_luminance
(
format
)
&
&
!
util_format_is_luminance_alpha
(
format
)
)
;
return
format
;
}
}
static
inline
unsigned
util_format_get_num_planes
(
enum
pipe_format
format
)
{
switch
(
util_format_description
(
format
)
-
>
layout
)
{
case
UTIL_FORMAT_LAYOUT_PLANAR3
:
return
3
;
case
UTIL_FORMAT_LAYOUT_PLANAR2
:
return
2
;
default
:
return
1
;
}
}
static
inline
enum
pipe_format
util_format_get_plane_format
(
enum
pipe_format
format
unsigned
plane
)
{
switch
(
format
)
{
case
PIPE_FORMAT_YV12
:
case
PIPE_FORMAT_YV16
:
case
PIPE_FORMAT_IYUV
:
return
PIPE_FORMAT_R8_UNORM
;
case
PIPE_FORMAT_NV12
:
return
!
plane
?
PIPE_FORMAT_R8_UNORM
:
PIPE_FORMAT_RG88_UNORM
;
case
PIPE_FORMAT_NV21
:
return
!
plane
?
PIPE_FORMAT_R8_UNORM
:
PIPE_FORMAT_GR88_UNORM
;
case
PIPE_FORMAT_P010
:
case
PIPE_FORMAT_P016
:
return
!
plane
?
PIPE_FORMAT_R16_UNORM
:
PIPE_FORMAT_R16G16_UNORM
;
default
:
return
format
;
}
}
static
inline
unsigned
util_format_get_plane_width
(
enum
pipe_format
format
unsigned
plane
unsigned
width
)
{
switch
(
format
)
{
case
PIPE_FORMAT_YV12
:
case
PIPE_FORMAT_YV16
:
case
PIPE_FORMAT_IYUV
:
case
PIPE_FORMAT_NV12
:
case
PIPE_FORMAT_NV21
:
case
PIPE_FORMAT_P010
:
case
PIPE_FORMAT_P016
:
return
!
plane
?
width
:
(
width
+
1
)
/
2
;
default
:
return
width
;
}
}
static
inline
unsigned
util_format_get_plane_height
(
enum
pipe_format
format
unsigned
plane
unsigned
height
)
{
switch
(
format
)
{
case
PIPE_FORMAT_YV12
:
case
PIPE_FORMAT_IYUV
:
case
PIPE_FORMAT_NV12
:
case
PIPE_FORMAT_NV21
:
case
PIPE_FORMAT_P010
:
case
PIPE_FORMAT_P016
:
return
!
plane
?
height
:
(
height
+
1
)
/
2
;
case
PIPE_FORMAT_YV16
:
default
:
return
height
;
}
}
bool
util_format_planar_is_supported
(
struct
pipe_screen
*
screen
enum
pipe_format
format
enum
pipe_texture_target
target
unsigned
sample_count
unsigned
storage_sample_count
unsigned
bind
)
;
static
inline
unsigned
util_format_get_nr_components
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
return
desc
-
>
nr_channels
;
}
static
inline
int
util_format_get_first_non_void_channel
(
enum
pipe_format
format
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
int
i
;
for
(
i
=
0
;
i
<
4
;
i
+
+
)
if
(
desc
-
>
channel
[
i
]
.
type
!
=
UTIL_FORMAT_TYPE_VOID
)
break
;
if
(
i
=
=
4
)
return
-
1
;
return
i
;
}
static
inline
bool
util_format_is_unorm8
(
const
struct
util_format_description
*
desc
)
{
int
c
=
util_format_get_first_non_void_channel
(
desc
-
>
format
)
;
if
(
c
=
=
-
1
)
return
false
;
return
desc
-
>
is_unorm
&
&
desc
-
>
is_array
&
&
desc
-
>
channel
[
c
]
.
size
=
=
8
;
}
static
inline
void
util_format_unpack_z_float
(
enum
pipe_format
format
float
*
dst
const
void
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
unpack_z_float
(
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
}
static
inline
void
util_format_unpack_z_32unorm
(
enum
pipe_format
format
uint32_t
*
dst
const
void
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
unpack_z_32unorm
(
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
}
static
inline
void
util_format_unpack_s_8uint
(
enum
pipe_format
format
uint8_t
*
dst
const
void
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
unpack_s_8uint
(
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
}
static
inline
void
util_format_unpack_rgba_float
(
enum
pipe_format
format
float
*
dst
const
void
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
unpack_rgba_float
(
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
}
static
inline
void
util_format_unpack_rgba
(
enum
pipe_format
format
void
*
dst
const
void
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
if
(
util_format_is_pure_uint
(
format
)
)
desc
-
>
unpack_rgba_uint
(
(
uint32_t
*
)
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
else
if
(
util_format_is_pure_sint
(
format
)
)
desc
-
>
unpack_rgba_sint
(
(
int32_t
*
)
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
else
desc
-
>
unpack_rgba_float
(
(
float
*
)
dst
0
(
const
uint8_t
*
)
src
0
w
1
)
;
}
static
inline
void
util_format_pack_z_float
(
enum
pipe_format
format
void
*
dst
const
float
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
pack_z_float
(
(
uint8_t
*
)
dst
0
src
0
w
1
)
;
}
static
inline
void
util_format_pack_z_32unorm
(
enum
pipe_format
format
void
*
dst
const
uint32_t
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
pack_z_32unorm
(
(
uint8_t
*
)
dst
0
src
0
w
1
)
;
}
static
inline
void
util_format_pack_s_8uint
(
enum
pipe_format
format
void
*
dst
const
uint8_t
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
desc
-
>
pack_s_8uint
(
(
uint8_t
*
)
dst
0
src
0
w
1
)
;
}
static
inline
void
util_format_pack_rgba
(
enum
pipe_format
format
void
*
dst
const
void
*
src
unsigned
w
)
{
const
struct
util_format_description
*
desc
=
util_format_description
(
format
)
;
if
(
util_format_is_pure_uint
(
format
)
)
desc
-
>
pack_rgba_uint
(
(
uint8_t
*
)
dst
0
(
const
uint32_t
*
)
src
0
w
1
)
;
else
if
(
util_format_is_pure_sint
(
format
)
)
desc
-
>
pack_rgba_sint
(
(
uint8_t
*
)
dst
0
(
const
int32_t
*
)
src
0
w
1
)
;
else
desc
-
>
pack_rgba_float
(
(
uint8_t
*
)
dst
0
(
const
float
*
)
src
0
w
1
)
;
}
void
util_format_read_4f
(
enum
pipe_format
format
float
*
dst
unsigned
dst_stride
const
void
*
src
unsigned
src_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_write_4f
(
enum
pipe_format
format
const
float
*
src
unsigned
src_stride
void
*
dst
unsigned
dst_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_read_4ub
(
enum
pipe_format
format
uint8_t
*
dst
unsigned
dst_stride
const
void
*
src
unsigned
src_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_write_4ub
(
enum
pipe_format
format
const
uint8_t
*
src
unsigned
src_stride
void
*
dst
unsigned
dst_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_read_4ui
(
enum
pipe_format
format
unsigned
*
dst
unsigned
dst_stride
const
void
*
src
unsigned
src_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_write_4ui
(
enum
pipe_format
format
const
unsigned
int
*
src
unsigned
src_stride
void
*
dst
unsigned
dst_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_read_4i
(
enum
pipe_format
format
int
*
dst
unsigned
dst_stride
const
void
*
src
unsigned
src_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
void
util_format_write_4i
(
enum
pipe_format
format
const
int
*
src
unsigned
src_stride
void
*
dst
unsigned
dst_stride
unsigned
x
unsigned
y
unsigned
w
unsigned
h
)
;
boolean
util_format_fits_8unorm
(
const
struct
util_format_description
*
format_desc
)
;
boolean
util_format_translate
(
enum
pipe_format
dst_format
void
*
dst
unsigned
dst_stride
unsigned
dst_x
unsigned
dst_y
enum
pipe_format
src_format
const
void
*
src
unsigned
src_stride
unsigned
src_x
unsigned
src_y
unsigned
width
unsigned
height
)
;
boolean
util_format_translate_3d
(
enum
pipe_format
dst_format
void
*
dst
unsigned
dst_stride
unsigned
dst_slice_stride
unsigned
dst_x
unsigned
dst_y
unsigned
dst_z
enum
pipe_format
src_format
const
void
*
src
unsigned
src_stride
unsigned
src_slice_stride
unsigned
src_x
unsigned
src_y
unsigned
src_z
unsigned
width
unsigned
height
unsigned
depth
)
;
void
util_format_compose_swizzles
(
const
unsigned
char
swz1
[
4
]
const
unsigned
char
swz2
[
4
]
unsigned
char
dst
[
4
]
)
;
void
util_format_apply_color_swizzle
(
union
pipe_color_union
*
dst
const
union
pipe_color_union
*
src
const
unsigned
char
swz
[
4
]
const
boolean
is_integer
)
;
void
pipe_swizzle_4f
(
float
*
dst
const
float
*
src
const
unsigned
char
swz
[
4
]
)
;
void
util_format_unswizzle_4f
(
float
*
dst
const
float
*
src
const
unsigned
char
swz
[
4
]
)
;
enum
pipe_format
util_format_snorm8_to_sint8
(
enum
pipe_format
format
)
;
extern
void
util_copy_rect
(
ubyte
*
dst
enum
pipe_format
format
unsigned
dst_stride
unsigned
dst_x
unsigned
dst_y
unsigned
width
unsigned
height
const
ubyte
*
src
int
src_stride
unsigned
src_x
unsigned
src_y
)
;
#
ifdef
__cplusplus
}
#
endif
#
endif
