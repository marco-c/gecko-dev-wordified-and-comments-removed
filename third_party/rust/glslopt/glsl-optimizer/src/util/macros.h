#
ifndef
UTIL_MACROS_H
#
define
UTIL_MACROS_H
#
include
<
assert
.
h
>
#
include
"
c99_compat
.
h
"
#
include
"
c11_compat
.
h
"
#
ifndef
ARRAY_SIZE
#
define
ARRAY_SIZE
(
x
)
(
sizeof
(
x
)
/
sizeof
(
(
x
)
[
0
]
)
)
#
endif
#
ifndef
__has_builtin
#
define
__has_builtin
(
x
)
0
#
endif
#
if
!
defined
(
HAVE___BUILTIN_EXPECT
)
#
define
__builtin_expect
(
x
y
)
(
x
)
#
endif
#
ifndef
likely
#
ifdef
HAVE___BUILTIN_EXPECT
#
define
likely
(
x
)
__builtin_expect
(
!
!
(
x
)
1
)
#
define
unlikely
(
x
)
__builtin_expect
(
!
!
(
x
)
0
)
#
else
#
define
likely
(
x
)
(
x
)
#
define
unlikely
(
x
)
(
x
)
#
endif
#
endif
#
define
STATIC_ASSERT
(
COND
)
\
do
{
\
(
void
)
sizeof
(
char
[
1
-
2
*
!
(
COND
)
]
)
;
\
}
while
(
0
)
#
if
defined
(
HAVE___BUILTIN_UNREACHABLE
)
|
|
__has_builtin
(
__builtin_unreachable
)
#
define
unreachable
(
str
)
\
do
{
\
assert
(
!
str
)
;
\
__builtin_unreachable
(
)
;
\
}
while
(
0
)
#
elif
defined
(
_MSC_VER
)
#
define
unreachable
(
str
)
\
do
{
\
assert
(
!
str
)
;
\
__assume
(
0
)
;
\
}
while
(
0
)
#
else
#
define
unreachable
(
str
)
assert
(
!
str
)
#
endif
#
if
__has_builtin
(
__builtin_assume
)
#
define
assume
(
expr
)
\
do
{
\
assert
(
expr
)
;
\
__builtin_assume
(
expr
)
;
\
}
while
(
0
)
#
elif
defined
HAVE___BUILTIN_UNREACHABLE
#
define
assume
(
expr
)
(
(
expr
)
?
(
(
void
)
0
)
\
:
(
assert
(
!
"
assumption
failed
"
)
\
__builtin_unreachable
(
)
)
)
#
elif
defined
(
_MSC_VER
)
#
define
assume
(
expr
)
__assume
(
expr
)
#
else
#
define
assume
(
expr
)
assert
(
expr
)
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_CONST
#
define
ATTRIBUTE_CONST
__attribute__
(
(
__const__
)
)
#
else
#
define
ATTRIBUTE_CONST
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_FLATTEN
#
define
FLATTEN
__attribute__
(
(
__flatten__
)
)
#
else
#
define
FLATTEN
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_FORMAT
#
define
PRINTFLIKE
(
f
a
)
__attribute__
(
(
format
(
__printf__
f
a
)
)
)
#
else
#
define
PRINTFLIKE
(
f
a
)
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_MALLOC
#
define
MALLOCLIKE
__attribute__
(
(
__malloc__
)
)
#
else
#
define
MALLOCLIKE
#
endif
#
ifndef
ALWAYS_INLINE
#
if
defined
(
__GNUC__
)
#
define
ALWAYS_INLINE
inline
__attribute__
(
(
always_inline
)
)
#
elif
defined
(
_MSC_VER
)
#
define
ALWAYS_INLINE
__forceinline
#
else
#
define
ALWAYS_INLINE
inline
#
endif
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_PACKED
#
define
PACKED
__attribute__
(
(
__packed__
)
)
#
else
#
define
PACKED
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_PURE
#
define
ATTRIBUTE_PURE
__attribute__
(
(
__pure__
)
)
#
else
#
define
ATTRIBUTE_PURE
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_RETURNS_NONNULL
#
define
ATTRIBUTE_RETURNS_NONNULL
__attribute__
(
(
__returns_nonnull__
)
)
#
else
#
define
ATTRIBUTE_RETURNS_NONNULL
#
endif
#
ifndef
NORETURN
#
ifdef
_MSC_VER
#
define
NORETURN
__declspec
(
noreturn
)
#
elif
defined
HAVE_FUNC_ATTRIBUTE_NORETURN
#
define
NORETURN
__attribute__
(
(
__noreturn__
)
)
#
else
#
define
NORETURN
#
endif
#
endif
#
ifdef
__cplusplus
#
if
(
defined
(
__clang__
)
&
&
defined
(
__has_feature
)
)
#
if
__has_feature
(
has_trivial_destructor
)
#
define
HAS_TRIVIAL_DESTRUCTOR
(
T
)
__has_trivial_destructor
(
T
)
#
endif
#
elif
defined
(
__GNUC__
)
#
if
(
(
__GNUC__
>
4
)
|
|
(
(
__GNUC__
=
=
4
)
&
&
(
__GNUC_MINOR__
>
=
3
)
)
)
#
define
HAS_TRIVIAL_DESTRUCTOR
(
T
)
__has_trivial_destructor
(
T
)
#
endif
#
elif
defined
(
_MSC_VER
)
&
&
!
defined
(
__INTEL_COMPILER
)
#
define
HAS_TRIVIAL_DESTRUCTOR
(
T
)
__has_trivial_destructor
(
T
)
#
endif
#
ifndef
HAS_TRIVIAL_DESTRUCTOR
#
define
HAS_TRIVIAL_DESTRUCTOR
(
T
)
(
false
)
#
endif
#
endif
#
ifndef
PUBLIC
#
if
defined
(
__GNUC__
)
#
define
PUBLIC
__attribute__
(
(
visibility
(
"
default
"
)
)
)
#
define
USED
__attribute__
(
(
used
)
)
#
elif
defined
(
_MSC_VER
)
#
define
PUBLIC
__declspec
(
dllexport
)
#
define
USED
#
else
#
define
PUBLIC
#
define
USED
#
endif
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_UNUSED
#
define
UNUSED
__attribute__
(
(
unused
)
)
#
else
#
define
UNUSED
#
endif
#
ifdef
NDEBUG
#
define
ASSERTED
UNUSED
#
else
#
define
ASSERTED
#
endif
#
ifdef
HAVE_FUNC_ATTRIBUTE_WARN_UNUSED_RESULT
#
define
MUST_CHECK
__attribute__
(
(
warn_unused_result
)
)
#
else
#
define
MUST_CHECK
#
endif
#
if
defined
(
__GNUC__
)
#
define
ATTRIBUTE_NOINLINE
__attribute__
(
(
noinline
)
)
#
else
#
define
ATTRIBUTE_NOINLINE
#
endif
#
define
ASSERT_BITFIELD_SIZE
(
STRUCT
FIELD
MAXVAL
)
\
do
{
\
ASSERTED
STRUCT
s
;
\
s
.
FIELD
=
(
MAXVAL
)
;
\
assert
(
(
int
)
s
.
FIELD
=
=
(
MAXVAL
)
&
&
"
Insufficient
bitfield
size
!
"
)
;
\
}
while
(
0
)
#
define
DIV_ROUND_UP
(
A
B
)
(
(
(
A
)
+
(
B
)
-
1
)
/
(
B
)
)
#
define
CLAMP
(
X
MIN
MAX
)
(
(
X
)
>
(
MIN
)
?
(
(
X
)
>
(
MAX
)
?
(
MAX
)
:
(
X
)
)
:
(
MIN
)
)
#
define
MIN2
(
A
B
)
(
(
A
)
<
(
B
)
?
(
A
)
:
(
B
)
)
#
define
MAX2
(
A
B
)
(
(
A
)
>
(
B
)
?
(
A
)
:
(
B
)
)
#
define
MIN3
(
A
B
C
)
(
(
A
)
<
(
B
)
?
MIN2
(
A
C
)
:
MIN2
(
B
C
)
)
#
define
MAX3
(
A
B
C
)
(
(
A
)
>
(
B
)
?
MAX2
(
A
C
)
:
MAX2
(
B
C
)
)
#
define
ALIGN_POT
(
x
pot_align
)
(
(
(
x
)
+
(
pot_align
)
-
1
)
&
~
(
(
pot_align
)
-
1
)
)
#
if
__cplusplus
>
=
201103L
#
define
EXPLICIT_CONVERSION
explicit
#
elif
defined
(
__cplusplus
)
#
define
EXPLICIT_CONVERSION
#
endif
#
define
BITFIELD_BIT
(
b
)
(
1u
<
<
(
b
)
)
#
define
BITFIELD_MASK
(
b
)
\
(
(
b
)
=
=
32
?
(
~
0u
)
:
BITFIELD_BIT
(
(
b
)
%
32
)
-
1
)
#
define
BITFIELD_RANGE
(
b
count
)
\
(
BITFIELD_MASK
(
(
b
)
+
(
count
)
)
&
~
BITFIELD_MASK
(
b
)
)
#
define
BITFIELD64_BIT
(
b
)
(
1ull
<
<
(
b
)
)
#
define
BITFIELD64_MASK
(
b
)
\
(
(
b
)
=
=
64
?
(
~
0ull
)
:
BITFIELD64_BIT
(
b
)
-
1
)
#
define
BITFIELD64_RANGE
(
b
count
)
\
(
BITFIELD64_MASK
(
(
b
)
+
(
count
)
)
&
~
BITFIELD64_MASK
(
b
)
)
#
endif
