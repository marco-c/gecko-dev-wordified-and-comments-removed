#
include
"
os_misc
.
h
"
#
include
<
stdarg
.
h
>
#
if
DETECT_OS_WINDOWS
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
endif
#
include
<
windows
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
else
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
endif
#
if
DETECT_OS_ANDROID
#
define
LOG_TAG
"
MESA
"
#
include
<
unistd
.
h
>
#
include
<
log
/
log
.
h
>
#
elif
DETECT_OS_LINUX
|
|
DETECT_OS_CYGWIN
|
|
DETECT_OS_SOLARIS
|
|
DETECT_OS_HURD
#
include
<
unistd
.
h
>
#
elif
DETECT_OS_APPLE
|
|
DETECT_OS_BSD
#
include
<
sys
/
sysctl
.
h
>
#
elif
DETECT_OS_HAIKU
#
include
<
kernel
/
OS
.
h
>
#
elif
DETECT_OS_WINDOWS
#
include
<
windows
.
h
>
#
else
#
error
unexpected
platform
in
os_sysinfo
.
c
#
endif
void
os_log_message
(
const
char
*
message
)
{
static
FILE
*
fout
=
NULL
;
if
(
!
fout
)
{
#
ifdef
DEBUG
const
char
*
filename
=
os_get_option
(
"
GALLIUM_LOG_FILE
"
)
;
if
(
filename
)
{
const
char
*
mode
=
"
w
"
;
if
(
filename
[
0
]
=
=
'
+
'
)
{
mode
=
"
a
"
;
filename
+
+
;
}
fout
=
fopen
(
filename
mode
)
;
}
#
endif
if
(
!
fout
)
fout
=
stderr
;
}
#
if
DETECT_OS_WINDOWS
OutputDebugStringA
(
message
)
;
if
(
GetConsoleWindow
(
)
&
&
!
IsDebuggerPresent
(
)
)
{
fflush
(
stdout
)
;
fputs
(
message
fout
)
;
fflush
(
fout
)
;
}
else
if
(
fout
!
=
stderr
)
{
fputs
(
message
fout
)
;
fflush
(
fout
)
;
}
#
else
fflush
(
stdout
)
;
fputs
(
message
fout
)
;
fflush
(
fout
)
;
#
if
DETECT_OS_ANDROID
LOG_PRI
(
ANDROID_LOG_ERROR
LOG_TAG
"
%
s
"
message
)
;
#
endif
#
endif
}
#
if
!
defined
(
EMBEDDED_DEVICE
)
const
char
*
os_get_option
(
const
char
*
name
)
{
return
getenv
(
name
)
;
}
#
endif
bool
os_get_total_physical_memory
(
uint64_t
*
size
)
{
#
if
DETECT_OS_LINUX
|
|
DETECT_OS_CYGWIN
|
|
DETECT_OS_SOLARIS
|
|
DETECT_OS_HURD
const
long
phys_pages
=
sysconf
(
_SC_PHYS_PAGES
)
;
const
long
page_size
=
sysconf
(
_SC_PAGE_SIZE
)
;
if
(
phys_pages
<
=
0
|
|
page_size
<
=
0
)
return
false
;
*
size
=
(
uint64_t
)
phys_pages
*
(
uint64_t
)
page_size
;
return
true
;
#
elif
DETECT_OS_APPLE
|
|
DETECT_OS_BSD
size_t
len
=
sizeof
(
*
size
)
;
int
mib
[
2
]
;
mib
[
0
]
=
CTL_HW
;
#
if
DETECT_OS_APPLE
mib
[
1
]
=
HW_MEMSIZE
;
#
elif
DETECT_OS_NETBSD
|
|
DETECT_OS_OPENBSD
mib
[
1
]
=
HW_PHYSMEM64
;
#
elif
DETECT_OS_FREEBSD
mib
[
1
]
=
HW_REALMEM
;
#
elif
DETECT_OS_DRAGONFLY
mib
[
1
]
=
HW_PHYSMEM
;
#
else
#
error
Unsupported
*
BSD
#
endif
return
(
sysctl
(
mib
2
size
&
len
NULL
0
)
=
=
0
)
;
#
elif
DETECT_OS_HAIKU
system_info
info
;
status_t
ret
;
ret
=
get_system_info
(
&
info
)
;
if
(
ret
!
=
B_OK
|
|
info
.
max_pages
<
=
0
)
return
false
;
*
size
=
(
uint64_t
)
info
.
max_pages
*
(
uint64_t
)
B_PAGE_SIZE
;
return
true
;
#
elif
DETECT_OS_WINDOWS
MEMORYSTATUSEX
status
;
BOOL
ret
;
status
.
dwLength
=
sizeof
(
status
)
;
ret
=
GlobalMemoryStatusEx
(
&
status
)
;
*
size
=
status
.
ullTotalPhys
;
return
(
ret
=
=
TRUE
)
;
#
else
#
error
unexpected
platform
in
os_sysinfo
.
c
return
false
;
#
endif
}
