use
rand_core
:
:
{
Error
ErrorKind
}
;
use
super
:
:
OsRngImpl
;
use
super
:
:
__wbg_shims
:
:
*
;
use
wasm_bindgen
:
:
prelude
:
:
*
;
#
[
derive
(
Clone
Debug
)
]
pub
enum
OsRng
{
Node
(
NodeCrypto
)
Browser
(
BrowserCrypto
)
}
impl
OsRngImpl
for
OsRng
{
fn
new
(
)
-
>
Result
<
OsRng
Error
>
{
let
this
=
Function
:
:
new
(
"
return
this
"
)
.
call
(
&
JsValue
:
:
undefined
(
)
)
;
assert
!
(
this
!
=
JsValue
:
:
undefined
(
)
)
;
let
this
=
This
:
:
from
(
this
)
;
let
is_browser
=
this
.
self_
(
)
!
=
JsValue
:
:
undefined
(
)
;
if
!
is_browser
{
return
Ok
(
OsRng
:
:
Node
(
node_require
(
"
crypto
"
)
)
)
}
let
crypto
=
this
.
crypto
(
)
;
if
crypto
.
is_undefined
(
)
{
let
msg
=
"
self
.
crypto
is
undefined
"
;
return
Err
(
Error
:
:
new
(
ErrorKind
:
:
Unavailable
msg
)
)
}
let
crypto
:
BrowserCrypto
=
crypto
.
into
(
)
;
if
crypto
.
get_random_values_fn
(
)
.
is_undefined
(
)
{
let
msg
=
"
crypto
.
getRandomValues
is
undefined
"
;
return
Err
(
Error
:
:
new
(
ErrorKind
:
:
Unavailable
msg
)
)
}
Ok
(
OsRng
:
:
Browser
(
crypto
)
)
}
fn
fill_chunk
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
match
*
self
{
OsRng
:
:
Node
(
ref
n
)
=
>
n
.
random_fill_sync
(
dest
)
OsRng
:
:
Browser
(
ref
n
)
=
>
n
.
get_random_values
(
dest
)
}
Ok
(
(
)
)
}
fn
max_chunk_size
(
&
self
)
-
>
usize
{
match
*
self
{
OsRng
:
:
Node
(
_
)
=
>
usize
:
:
max_value
(
)
OsRng
:
:
Browser
(
_
)
=
>
{
65536
}
}
}
fn
method_str
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
OsRng
:
:
Node
(
_
)
=
>
"
crypto
.
randomFillSync
"
OsRng
:
:
Browser
(
_
)
=
>
"
crypto
.
getRandomValues
"
}
}
}
