#
!
[
doc
(
html_logo_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
logos
/
rust
-
logo
-
128x128
-
blk
.
png
"
html_favicon_url
=
"
https
:
/
/
www
.
rust
-
lang
.
org
/
favicon
.
ico
"
html_root_url
=
"
https
:
/
/
rust
-
random
.
github
.
io
/
rand
/
"
)
]
#
!
[
deny
(
missing_docs
)
]
#
!
[
deny
(
missing_debug_implementations
)
]
#
!
[
doc
(
test
(
attr
(
allow
(
unused_variables
)
deny
(
warnings
)
)
)
)
]
#
!
[
cfg_attr
(
feature
=
"
stdweb
"
recursion_limit
=
"
128
"
)
]
pub
extern
crate
rand_core
;
#
[
cfg
(
feature
=
"
log
"
)
]
#
[
macro_use
]
extern
crate
log
;
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
target_os
=
"
emscripten
"
)
feature
=
"
wasm
-
bindgen
"
)
)
]
extern
crate
wasm_bindgen
;
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
target_os
=
"
emscripten
"
)
not
(
feature
=
"
wasm
-
bindgen
"
)
feature
=
"
stdweb
"
)
)
]
#
[
macro_use
]
extern
crate
stdweb
;
#
[
cfg
(
target_env
=
"
sgx
"
)
]
extern
crate
rdrand
;
#
[
cfg
(
not
(
feature
=
"
log
"
)
)
]
#
[
macro_use
]
mod
dummy_log
;
use
std
:
:
fmt
;
use
rand_core
:
:
{
CryptoRng
RngCore
Error
impls
}
;
#
[
derive
(
Clone
)
]
pub
struct
OsRng
(
imp
:
:
OsRng
)
;
impl
fmt
:
:
Debug
for
OsRng
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
0
.
fmt
(
f
)
}
}
impl
OsRng
{
pub
fn
new
(
)
-
>
Result
<
OsRng
Error
>
{
imp
:
:
OsRng
:
:
new
(
)
.
map
(
OsRng
)
}
}
impl
CryptoRng
for
OsRng
{
}
impl
RngCore
for
OsRng
{
fn
next_u32
(
&
mut
self
)
-
>
u32
{
impls
:
:
next_u32_via_fill
(
self
)
}
fn
next_u64
(
&
mut
self
)
-
>
u64
{
impls
:
:
next_u64_via_fill
(
self
)
}
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
use
std
:
:
{
time
thread
}
;
const
MAX_RETRY_PERIOD
:
u32
=
10
;
const
WAIT_DUR_MS
:
u32
=
100
;
let
wait_dur
=
time
:
:
Duration
:
:
from_millis
(
WAIT_DUR_MS
as
u64
)
;
const
RETRY_LIMIT
:
u32
=
(
MAX_RETRY_PERIOD
*
1000
)
/
WAIT_DUR_MS
;
const
TRANSIENT_RETRIES
:
u32
=
8
;
let
mut
err_count
=
0
;
let
mut
error_logged
=
false
;
let
mut
read
=
0
;
if
let
Ok
(
n
)
=
self
.
0
.
test_initialized
(
dest
true
)
{
read
=
n
}
;
let
dest
=
&
mut
dest
[
read
.
.
]
;
loop
{
if
let
Err
(
e
)
=
self
.
try_fill_bytes
(
dest
)
{
if
err_count
>
=
RETRY_LIMIT
{
error
!
(
"
OsRng
failed
too
many
times
;
last
error
:
{
}
"
e
)
;
panic
!
(
"
OsRng
failed
too
many
times
;
last
error
:
{
}
"
e
)
;
}
if
e
.
kind
.
should_wait
(
)
{
if
!
error_logged
{
warn
!
(
"
OsRng
failed
;
waiting
up
to
{
}
s
and
retrying
.
Error
:
{
}
"
MAX_RETRY_PERIOD
e
)
;
error_logged
=
true
;
}
err_count
+
=
1
;
thread
:
:
sleep
(
wait_dur
)
;
continue
;
}
else
if
e
.
kind
.
should_retry
(
)
{
if
!
error_logged
{
warn
!
(
"
OsRng
failed
;
retrying
up
to
{
}
times
.
Error
:
{
}
"
TRANSIENT_RETRIES
e
)
;
error_logged
=
true
;
}
err_count
+
=
(
RETRY_LIMIT
+
TRANSIENT_RETRIES
-
1
)
/
TRANSIENT_RETRIES
;
continue
;
}
else
{
error
!
(
"
OsRng
failed
:
{
}
"
e
)
;
panic
!
(
"
OsRng
fatal
error
:
{
}
"
e
)
;
}
}
break
;
}
}
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
if
dest
.
len
(
)
=
=
0
{
return
Ok
(
(
)
)
;
}
let
read
=
self
.
0
.
test_initialized
(
dest
false
)
?
;
let
dest
=
&
mut
dest
[
read
.
.
]
;
let
max
=
self
.
0
.
max_chunk_size
(
)
;
if
dest
.
len
(
)
<
=
max
{
trace
!
(
"
OsRng
:
reading
{
}
bytes
via
{
}
"
dest
.
len
(
)
self
.
0
.
method_str
(
)
)
;
}
else
{
trace
!
(
"
OsRng
:
reading
{
}
bytes
via
{
}
in
{
}
chunks
of
{
}
bytes
"
dest
.
len
(
)
self
.
0
.
method_str
(
)
(
dest
.
len
(
)
+
max
)
/
max
max
)
;
}
for
slice
in
dest
.
chunks_mut
(
max
)
{
self
.
0
.
fill_chunk
(
slice
)
?
;
}
Ok
(
(
)
)
}
}
trait
OsRngImpl
where
Self
:
Sized
{
fn
new
(
)
-
>
Result
<
Self
Error
>
;
fn
fill_chunk
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
;
fn
test_initialized
(
&
mut
self
_dest
:
&
mut
[
u8
]
_blocking
:
bool
)
-
>
Result
<
usize
Error
>
{
Ok
(
0
)
}
fn
max_chunk_size
(
&
self
)
-
>
usize
{
:
:
std
:
:
usize
:
:
MAX
}
fn
method_str
(
&
self
)
-
>
&
'
static
str
;
}
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
target_os
=
"
netbsd
"
target_os
=
"
dragonfly
"
target_os
=
"
solaris
"
target_os
=
"
redox
"
target_os
=
"
haiku
"
target_os
=
"
emscripten
"
target_os
=
"
illumos
"
)
)
]
mod
random_device
;
macro_rules
!
mod_use
{
(
cond
:
meta
module
:
ident
)
=
>
{
#
[
cond
]
mod
module
;
#
[
cond
]
use
module
as
imp
;
}
}
mod_use
!
(
cfg
(
target_os
=
"
android
"
)
linux_android
)
;
mod_use
!
(
cfg
(
target_os
=
"
bitrig
"
)
openbsd_bitrig
)
;
mod_use
!
(
cfg
(
target_os
=
"
cloudabi
"
)
cloudabi
)
;
mod_use
!
(
cfg
(
target_os
=
"
dragonfly
"
)
dragonfly_haiku_emscripten
)
;
mod_use
!
(
cfg
(
target_os
=
"
emscripten
"
)
dragonfly_haiku_emscripten
)
;
mod_use
!
(
cfg
(
target_os
=
"
freebsd
"
)
freebsd
)
;
mod_use
!
(
cfg
(
target_os
=
"
fuchsia
"
)
fuchsia
)
;
mod_use
!
(
cfg
(
target_os
=
"
haiku
"
)
dragonfly_haiku_emscripten
)
;
mod_use
!
(
cfg
(
target_os
=
"
ios
"
)
macos
)
;
mod_use
!
(
cfg
(
target_os
=
"
linux
"
)
linux_android
)
;
mod_use
!
(
cfg
(
target_os
=
"
macos
"
)
macos
)
;
mod_use
!
(
cfg
(
target_os
=
"
netbsd
"
)
netbsd
)
;
mod_use
!
(
cfg
(
target_os
=
"
openbsd
"
)
openbsd_bitrig
)
;
mod_use
!
(
cfg
(
target_os
=
"
redox
"
)
redox
)
;
mod_use
!
(
cfg
(
any
(
target_os
=
"
solaris
"
target_os
=
"
illumos
"
)
)
solarish
)
;
mod_use
!
(
cfg
(
windows
)
windows
)
;
mod_use
!
(
cfg
(
target_env
=
"
sgx
"
)
sgx
)
;
mod_use
!
(
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
target_os
=
"
emscripten
"
)
feature
=
"
wasm
-
bindgen
"
)
)
wasm32_bindgen
)
;
mod_use
!
(
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
target_os
=
"
emscripten
"
)
not
(
feature
=
"
wasm
-
bindgen
"
)
feature
=
"
stdweb
"
)
)
wasm32_stdweb
)
;
#
[
cfg
(
all
(
target_arch
=
"
wasm32
"
not
(
target_os
=
"
emscripten
"
)
not
(
feature
=
"
wasm
-
bindgen
"
)
not
(
feature
=
"
stdweb
"
)
)
)
]
mod
imp
{
use
rand_core
:
:
{
Error
ErrorKind
}
;
use
super
:
:
OsRngImpl
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
OsRng
;
impl
OsRngImpl
for
OsRng
{
fn
new
(
)
-
>
Result
<
OsRng
Error
>
{
Err
(
Error
:
:
new
(
ErrorKind
:
:
Unavailable
"
OsRng
:
support
for
wasm32
requires
emscripten
stdweb
or
wasm
-
bindgen
"
)
)
}
fn
fill_chunk
(
&
mut
self
_dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
unimplemented
!
(
)
}
fn
method_str
(
&
self
)
-
>
&
'
static
str
{
unimplemented
!
(
)
}
}
}
#
[
cfg
(
not
(
any
(
target_os
=
"
android
"
target_os
=
"
bitrig
"
target_os
=
"
cloudabi
"
target_os
=
"
dragonfly
"
target_os
=
"
emscripten
"
target_os
=
"
freebsd
"
target_os
=
"
fuchsia
"
target_os
=
"
haiku
"
target_os
=
"
ios
"
target_os
=
"
linux
"
target_os
=
"
macos
"
target_os
=
"
netbsd
"
target_os
=
"
openbsd
"
target_os
=
"
redox
"
target_os
=
"
solaris
"
target_os
=
"
illumos
"
windows
target_arch
=
"
wasm32
"
target_env
=
"
sgx
"
)
)
)
]
compile_error
!
(
"
OS
RNG
support
is
not
available
for
this
platform
"
)
;
#
[
cfg
(
all
(
feature
=
"
wasm
-
bindgen
"
target_arch
=
"
wasm32
"
)
)
]
#
[
doc
(
hidden
)
]
#
[
allow
(
missing_debug_implementations
)
]
pub
mod
__wbg_shims
{
macro_rules
!
rust_122_compat
{
(
(
t
:
tt
)
*
)
=
>
(
(
t
)
*
)
}
rust_122_compat
!
{
extern
crate
wasm_bindgen
;
pub
use
wasm_bindgen
:
:
prelude
:
:
*
;
#
[
wasm_bindgen
]
extern
"
C
"
{
pub
type
Function
;
#
[
wasm_bindgen
(
constructor
)
]
pub
fn
new
(
s
:
&
str
)
-
>
Function
;
#
[
wasm_bindgen
(
method
)
]
pub
fn
call
(
this
:
&
Function
self_
:
&
JsValue
)
-
>
JsValue
;
pub
type
This
;
#
[
wasm_bindgen
(
method
getter
structural
js_name
=
self
)
]
pub
fn
self_
(
me
:
&
This
)
-
>
JsValue
;
#
[
wasm_bindgen
(
method
getter
structural
)
]
pub
fn
crypto
(
me
:
&
This
)
-
>
JsValue
;
#
[
derive
(
Clone
Debug
)
]
pub
type
BrowserCrypto
;
/
/
TODO
:
these
structural
annotations
here
ideally
wouldn
'
t
be
here
to
/
/
avoid
a
JS
shim
but
for
now
with
feature
detection
they
'
re
/
/
unavoidable
.
#
[
wasm_bindgen
(
method
js_name
=
getRandomValues
structural
getter
)
]
pub
fn
get_random_values_fn
(
me
:
&
BrowserCrypto
)
-
>
JsValue
;
#
[
wasm_bindgen
(
method
js_name
=
getRandomValues
structural
)
]
pub
fn
get_random_values
(
me
:
&
BrowserCrypto
buf
:
&
mut
[
u8
]
)
;
#
[
wasm_bindgen
(
js_name
=
require
)
]
pub
fn
node_require
(
s
:
&
str
)
-
>
NodeCrypto
;
#
[
derive
(
Clone
Debug
)
]
pub
type
NodeCrypto
;
#
[
wasm_bindgen
(
method
js_name
=
randomFillSync
structural
)
]
pub
fn
random_fill_sync
(
me
:
&
NodeCrypto
buf
:
&
mut
[
u8
]
)
;
}
}
}
