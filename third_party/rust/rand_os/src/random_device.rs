use
rand_core
:
:
{
Error
ErrorKind
}
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
sync
:
:
{
Once
Mutex
ONCE_INIT
}
;
static
mut
READ_RNG_FILE
:
Option
<
Mutex
<
Option
<
File
>
>
>
=
None
;
static
READ_RNG_ONCE
:
Once
=
ONCE_INIT
;
#
[
allow
(
unused
)
]
pub
fn
open
<
F
>
(
path
:
&
'
static
str
open_fn
:
F
)
-
>
Result
<
(
)
Error
>
where
F
:
Fn
(
&
'
static
str
)
-
>
Result
<
File
io
:
:
Error
>
{
READ_RNG_ONCE
.
call_once
(
|
|
{
unsafe
{
READ_RNG_FILE
=
Some
(
Mutex
:
:
new
(
None
)
)
}
}
)
;
let
mutex
=
unsafe
{
READ_RNG_FILE
.
as_ref
(
)
.
unwrap
(
)
}
;
let
mut
guard
=
mutex
.
lock
(
)
.
unwrap
(
)
;
if
(
*
guard
)
.
is_none
(
)
{
info
!
(
"
OsRng
:
opening
random
device
{
}
"
path
)
;
let
file
=
open_fn
(
path
)
.
map_err
(
map_err
)
?
;
*
guard
=
Some
(
file
)
;
}
;
Ok
(
(
)
)
}
pub
fn
read
(
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
let
mutex
=
unsafe
{
READ_RNG_FILE
.
as_ref
(
)
.
unwrap
(
)
}
;
let
mut
guard
=
mutex
.
lock
(
)
.
unwrap
(
)
;
let
file
=
(
*
guard
)
.
as_mut
(
)
.
unwrap
(
)
;
file
.
read_exact
(
dest
)
.
map_err
(
|
err
|
{
Error
:
:
with_cause
(
ErrorKind
:
:
Unavailable
"
error
reading
random
device
"
err
)
}
)
}
pub
fn
map_err
(
err
:
io
:
:
Error
)
-
>
Error
{
match
err
.
kind
(
)
{
io
:
:
ErrorKind
:
:
Interrupted
=
>
Error
:
:
new
(
ErrorKind
:
:
Transient
"
interrupted
"
)
io
:
:
ErrorKind
:
:
WouldBlock
=
>
Error
:
:
with_cause
(
ErrorKind
:
:
NotReady
"
OS
RNG
not
yet
seeded
"
err
)
_
=
>
Error
:
:
with_cause
(
ErrorKind
:
:
Unavailable
"
error
while
opening
random
device
"
err
)
}
}
