use
alloc
:
:
boxed
:
:
Box
;
use
core
:
:
marker
:
:
PhantomData
;
use
core
:
:
mem
:
:
ManuallyDrop
;
use
core
:
:
ops
:
:
{
Deref
DerefMut
}
;
use
core
:
:
ptr
:
:
NonNull
;
#
[
repr
(
C
)
]
pub
struct
DiplomatSlice
<
'
a
T
>
{
ptr
:
*
const
T
len
:
usize
phantom
:
PhantomData
<
&
'
a
[
T
]
>
}
impl
<
T
>
Clone
for
DiplomatSlice
<
'
_
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
T
>
Copy
for
DiplomatSlice
<
'
_
T
>
{
}
impl
<
'
a
T
>
From
<
&
'
a
[
T
]
>
for
DiplomatSlice
<
'
a
T
>
{
fn
from
(
x
:
&
'
a
[
T
]
)
-
>
Self
{
DiplomatSlice
{
ptr
:
x
.
as_ptr
(
)
len
:
x
.
len
(
)
phantom
:
PhantomData
}
}
}
impl
<
'
a
T
>
From
<
DiplomatSlice
<
'
a
T
>
>
for
&
'
a
[
T
]
{
fn
from
(
x
:
DiplomatSlice
<
'
a
T
>
)
-
>
Self
{
unsafe
{
if
x
.
ptr
.
is_null
(
)
{
debug_assert
!
(
x
.
len
=
=
0
)
;
return
&
[
]
;
}
core
:
:
slice
:
:
from_raw_parts
(
x
.
ptr
x
.
len
)
}
}
}
impl
<
T
>
Deref
for
DiplomatSlice
<
'
_
T
>
{
type
Target
=
[
T
]
;
fn
deref
(
&
self
)
-
>
&
[
T
]
{
(
*
self
)
.
into
(
)
}
}
#
[
repr
(
C
)
]
pub
struct
DiplomatSliceMut
<
'
a
T
>
{
ptr
:
*
mut
T
len
:
usize
phantom
:
PhantomData
<
&
'
a
mut
[
T
]
>
}
impl
<
'
a
T
>
From
<
&
'
a
mut
[
T
]
>
for
DiplomatSliceMut
<
'
a
T
>
{
fn
from
(
x
:
&
'
a
mut
[
T
]
)
-
>
Self
{
DiplomatSliceMut
{
ptr
:
x
.
as_mut_ptr
(
)
len
:
x
.
len
(
)
phantom
:
PhantomData
}
}
}
impl
<
'
a
T
>
From
<
DiplomatSliceMut
<
'
a
T
>
>
for
&
'
a
mut
[
T
]
{
fn
from
(
x
:
DiplomatSliceMut
<
'
a
T
>
)
-
>
Self
{
unsafe
{
if
x
.
ptr
.
is_null
(
)
{
debug_assert
!
(
x
.
len
=
=
0
)
;
return
&
mut
[
]
;
}
core
:
:
slice
:
:
from_raw_parts_mut
(
x
.
ptr
x
.
len
)
}
}
}
impl
<
T
>
Deref
for
DiplomatSliceMut
<
'
_
T
>
{
type
Target
=
[
T
]
;
fn
deref
(
&
self
)
-
>
&
[
T
]
{
if
self
.
ptr
.
is_null
(
)
{
debug_assert
!
(
self
.
len
=
=
0
)
;
return
&
[
]
;
}
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
self
.
ptr
self
.
len
)
}
}
}
impl
<
T
>
DerefMut
for
DiplomatSliceMut
<
'
_
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
if
self
.
ptr
.
is_null
(
)
{
debug_assert
!
(
self
.
len
=
=
0
)
;
return
&
mut
[
]
;
}
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
self
.
ptr
self
.
len
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
DiplomatOwnedSlice
<
T
>
{
ptr
:
*
mut
T
len
:
usize
phantom
:
PhantomData
<
Box
<
[
T
]
>
>
}
impl
<
T
>
Drop
for
DiplomatOwnedSlice
<
T
>
{
fn
drop
(
&
mut
self
)
{
if
!
self
.
ptr
.
is_null
(
)
{
unsafe
{
drop
(
Box
:
:
from_raw
(
core
:
:
ptr
:
:
slice_from_raw_parts_mut
(
self
.
ptr
self
.
len
)
)
)
;
}
}
}
}
impl
<
T
>
From
<
Box
<
[
T
]
>
>
for
DiplomatOwnedSlice
<
T
>
{
fn
from
(
x
:
Box
<
[
T
]
>
)
-
>
Self
{
let
len
=
x
.
len
(
)
;
DiplomatOwnedSlice
{
ptr
:
Box
:
:
into_raw
(
x
)
as
*
mut
T
len
phantom
:
PhantomData
}
}
}
impl
<
T
>
From
<
DiplomatOwnedSlice
<
T
>
>
for
Box
<
[
T
]
>
{
fn
from
(
x
:
DiplomatOwnedSlice
<
T
>
)
-
>
Self
{
let
x
=
ManuallyDrop
:
:
new
(
x
)
;
unsafe
{
if
x
.
ptr
.
is_null
(
)
{
debug_assert
!
(
x
.
len
=
=
0
)
;
let
dangling
=
core
:
:
ptr
:
:
NonNull
:
:
dangling
(
)
.
as_ptr
(
)
;
return
Box
:
:
from_raw
(
core
:
:
ptr
:
:
slice_from_raw_parts_mut
(
dangling
x
.
len
)
)
;
}
Box
:
:
from_raw
(
core
:
:
ptr
:
:
slice_from_raw_parts_mut
(
x
.
ptr
x
.
len
)
)
}
}
}
impl
<
T
>
Deref
for
DiplomatOwnedSlice
<
T
>
{
type
Target
=
[
T
]
;
fn
deref
(
&
self
)
-
>
&
[
T
]
{
if
self
.
ptr
.
is_null
(
)
{
debug_assert
!
(
self
.
len
=
=
0
)
;
return
&
[
]
;
}
unsafe
{
core
:
:
slice
:
:
from_raw_parts
(
self
.
ptr
self
.
len
)
}
}
}
impl
<
T
>
DerefMut
for
DiplomatOwnedSlice
<
T
>
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
[
T
]
{
if
self
.
ptr
.
is_null
(
)
{
debug_assert
!
(
self
.
len
=
=
0
)
;
return
&
mut
[
]
;
}
unsafe
{
core
:
:
slice
:
:
from_raw_parts_mut
(
self
.
ptr
self
.
len
)
}
}
}
#
[
repr
(
transparent
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
DiplomatUtf8StrSlice
<
'
a
>
(
DiplomatSlice
<
'
a
u8
>
)
;
impl
<
'
a
>
From
<
&
'
a
str
>
for
DiplomatUtf8StrSlice
<
'
a
>
{
fn
from
(
x
:
&
'
a
str
)
-
>
Self
{
Self
(
x
.
as_bytes
(
)
.
into
(
)
)
}
}
impl
<
'
a
>
From
<
DiplomatUtf8StrSlice
<
'
a
>
>
for
&
'
a
str
{
fn
from
(
x
:
DiplomatUtf8StrSlice
<
'
a
>
)
-
>
Self
{
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
<
&
[
u8
]
>
:
:
from
(
x
.
0
)
)
}
}
}
impl
Deref
for
DiplomatUtf8StrSlice
<
'
_
>
{
type
Target
=
str
;
fn
deref
(
&
self
)
-
>
&
str
{
(
*
self
)
.
into
(
)
}
}
#
[
repr
(
transparent
)
]
pub
struct
DiplomatOwnedUTF8StrSlice
(
DiplomatOwnedSlice
<
u8
>
)
;
impl
From
<
Box
<
str
>
>
for
DiplomatOwnedUTF8StrSlice
{
fn
from
(
x
:
Box
<
str
>
)
-
>
Self
{
Self
(
Box
:
:
<
[
u8
]
>
:
:
from
(
x
)
.
into
(
)
)
}
}
impl
From
<
DiplomatOwnedUTF8StrSlice
>
for
Box
<
str
>
{
fn
from
(
x
:
DiplomatOwnedUTF8StrSlice
)
-
>
Self
{
let
buf
=
Box
:
:
<
[
u8
]
>
:
:
from
(
x
.
0
)
;
let
len
=
buf
.
len
(
)
;
let
raw
=
Box
:
:
into_raw
(
buf
)
;
let
raw
=
if
raw
.
is_null
(
)
{
debug_assert
!
(
len
=
=
0
)
;
NonNull
:
:
<
u8
>
:
:
dangling
(
)
.
as_ptr
(
)
}
else
{
raw
as
*
mut
u8
}
;
unsafe
{
let
slice
=
core
:
:
slice
:
:
from_raw_parts_mut
(
raw
len
)
;
let
strslice
=
core
:
:
str
:
:
from_utf8_unchecked_mut
(
slice
)
;
Box
:
:
from_raw
(
strslice
as
*
mut
str
)
}
}
}
impl
Deref
for
DiplomatOwnedUTF8StrSlice
{
type
Target
=
str
;
fn
deref
(
&
self
)
-
>
&
str
{
let
slice
=
&
self
.
0
;
unsafe
{
core
:
:
str
:
:
from_utf8_unchecked
(
slice
)
}
}
}
pub
type
DiplomatStrSlice
<
'
a
>
=
DiplomatSlice
<
'
a
u8
>
;
pub
type
DiplomatOwnedStrSlice
=
DiplomatOwnedSlice
<
u8
>
;
pub
type
DiplomatStr16Slice
<
'
a
>
=
DiplomatSlice
<
'
a
u16
>
;
pub
type
DiplomatOwnedStr16Slice
<
'
a
>
=
DiplomatOwnedSlice
<
u16
>
;
