use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
vec
:
:
Vec
;
use
core
:
:
ffi
:
:
c_void
;
use
core
:
:
{
fmt
ptr
}
;
#
[
repr
(
C
)
]
pub
struct
DiplomatWrite
{
context
:
*
mut
c_void
buf
:
*
mut
u8
len
:
usize
cap
:
usize
grow_failed
:
bool
flush
:
extern
"
C
"
fn
(
*
mut
DiplomatWrite
)
grow
:
extern
"
C
"
fn
(
*
mut
DiplomatWrite
usize
)
-
>
bool
}
impl
DiplomatWrite
{
pub
fn
flush
(
&
mut
self
)
{
(
self
.
flush
)
(
self
)
;
}
}
impl
fmt
:
:
Write
for
DiplomatWrite
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
if
self
.
grow_failed
{
return
Ok
(
(
)
)
;
}
let
needed_len
=
self
.
len
+
s
.
len
(
)
;
if
needed_len
>
self
.
cap
{
let
success
=
(
self
.
grow
)
(
self
needed_len
)
;
if
!
success
{
self
.
grow_failed
=
true
;
return
Ok
(
(
)
)
;
}
}
debug_assert
!
(
needed_len
<
=
self
.
cap
)
;
unsafe
{
ptr
:
:
copy_nonoverlapping
(
s
.
as_bytes
(
)
.
as_ptr
(
)
self
.
buf
.
add
(
self
.
len
)
s
.
len
(
)
)
;
}
self
.
len
=
needed_len
;
Ok
(
(
)
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
diplomat_simple_write
(
buf
:
*
mut
u8
buf_size
:
usize
)
-
>
DiplomatWrite
{
extern
"
C
"
fn
grow
(
_this
:
*
mut
DiplomatWrite
_cap
:
usize
)
-
>
bool
{
false
}
extern
"
C
"
fn
flush
(
this
:
*
mut
DiplomatWrite
)
{
unsafe
{
debug_assert
!
(
(
*
this
)
.
len
<
=
(
*
this
)
.
cap
)
;
let
buf
=
(
*
this
)
.
buf
;
ptr
:
:
write
(
buf
.
add
(
(
*
this
)
.
len
)
0
)
}
}
DiplomatWrite
{
context
:
ptr
:
:
null_mut
(
)
buf
len
:
0
grow_failed
:
false
cap
:
buf_size
-
1
flush
grow
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
diplomat_buffer_write_create
(
cap
:
usize
)
-
>
*
mut
DiplomatWrite
{
extern
"
C
"
fn
grow
(
this
:
*
mut
DiplomatWrite
new_cap
:
usize
)
-
>
bool
{
unsafe
{
let
this
=
this
.
as_mut
(
)
.
unwrap
(
)
;
let
mut
vec
=
Vec
:
:
from_raw_parts
(
this
.
buf
0
this
.
cap
)
;
vec
.
reserve
(
new_cap
)
;
this
.
cap
=
vec
.
capacity
(
)
;
this
.
buf
=
vec
.
as_mut_ptr
(
)
;
core
:
:
mem
:
:
forget
(
vec
)
;
}
true
}
extern
"
C
"
fn
flush
(
_
:
*
mut
DiplomatWrite
)
{
}
let
mut
vec
=
Vec
:
:
<
u8
>
:
:
with_capacity
(
cap
)
;
let
ret
=
DiplomatWrite
{
context
:
ptr
:
:
null_mut
(
)
buf
:
vec
.
as_mut_ptr
(
)
len
:
0
grow_failed
:
false
cap
flush
grow
}
;
core
:
:
mem
:
:
forget
(
vec
)
;
Box
:
:
into_raw
(
Box
:
:
new
(
ret
)
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
diplomat_buffer_write_get_bytes
(
this
:
&
DiplomatWrite
)
-
>
*
mut
u8
{
if
this
.
grow_failed
{
core
:
:
ptr
:
:
null_mut
(
)
}
else
{
this
.
buf
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
diplomat_buffer_write_len
(
this
:
&
DiplomatWrite
)
-
>
usize
{
if
this
.
grow_failed
{
0
}
else
{
this
.
len
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
diplomat_buffer_write_destroy
(
this
:
*
mut
DiplomatWrite
)
{
let
this
=
Box
:
:
from_raw
(
this
)
;
let
vec
=
Vec
:
:
from_raw_parts
(
this
.
buf
0
this
.
cap
)
;
drop
(
vec
)
;
drop
(
this
)
;
}
