macro_rules
!
cfg_if
{
(
(
if
#
[
cfg
(
(
meta
:
meta
)
*
)
]
{
(
it
:
item
)
*
}
)
else
*
else
{
(
it2
:
item
)
*
}
)
=
>
{
cfg_if
!
{
__items
(
)
;
(
(
(
(
meta
)
*
)
(
(
it
)
*
)
)
)
*
(
(
)
(
(
it2
)
*
)
)
}
}
;
(
if
#
[
cfg
(
(
i_met
:
meta
)
*
)
]
{
(
i_it
:
item
)
*
}
(
else
if
#
[
cfg
(
(
e_met
:
meta
)
*
)
]
{
(
e_it
:
item
)
*
}
)
*
)
=
>
{
cfg_if
!
{
__items
(
)
;
(
(
(
i_met
)
*
)
(
(
i_it
)
*
)
)
(
(
(
(
e_met
)
*
)
(
(
e_it
)
*
)
)
)
*
(
(
)
(
)
)
}
}
;
(
__items
(
(
not
:
meta
)
*
)
;
)
=
>
{
}
;
(
__items
(
(
not
:
meta
)
*
)
;
(
(
(
m
:
meta
)
*
)
(
(
it
:
item
)
*
)
)
(
rest
:
tt
)
*
)
=
>
{
/
/
Emit
all
items
within
one
block
applying
an
appropriate
#
[
cfg
]
.
The
/
/
#
[
cfg
]
will
require
all
m
matchers
specified
and
must
also
negate
/
/
all
previous
matchers
.
cfg_if
!
{
__apply
cfg
(
all
(
(
m
)
*
not
(
any
(
(
not
)
*
)
)
)
)
(
it
)
*
}
/
/
Recurse
to
emit
all
other
items
in
rest
and
when
we
do
so
add
all
/
/
our
m
matchers
to
the
list
of
not
matchers
as
future
emissions
/
/
will
have
to
negate
everything
we
just
matched
as
well
.
cfg_if
!
{
__items
(
(
not
)
*
(
m
)
*
)
;
(
rest
)
*
}
}
;
(
__apply
m
:
meta
(
it
:
item
)
*
)
=
>
{
(
#
[
m
]
it
)
*
}
;
}
macro_rules
!
prelude
{
(
)
=
>
{
/
/
/
Frequently
-
used
types
that
are
available
on
all
platforms
/
/
/
/
/
/
We
need
to
reexport
the
core
types
so
this
works
with
rust
-
dep
-
of
-
std
.
mod
prelude
{
/
/
Exports
from
core
#
[
allow
(
unused_imports
)
]
pub
(
crate
)
use
:
:
core
:
:
clone
:
:
Clone
;
#
[
allow
(
unused_imports
)
]
pub
(
crate
)
use
:
:
core
:
:
marker
:
:
{
Copy
Send
Sync
}
;
#
[
allow
(
unused_imports
)
]
pub
(
crate
)
use
:
:
core
:
:
option
:
:
Option
;
#
[
allow
(
unused_imports
)
]
pub
(
crate
)
use
:
:
core
:
:
{
fmt
hash
iter
mem
}
;
/
/
Commonly
used
types
defined
in
this
crate
#
[
allow
(
unused_imports
)
]
pub
(
crate
)
use
crate
:
:
{
c_char
c_double
c_float
c_int
c_long
c_longlong
c_short
c_uchar
c_uint
c_ulong
c_ulonglong
c_ushort
c_void
intptr_t
size_t
ssize_t
uintptr_t
}
;
}
}
;
}
macro_rules
!
s
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
t
:
ident
i
:
ident
{
(
field
:
tt
)
*
}
)
*
)
=
>
(
(
s
!
(
it
:
(
#
[
attr
]
)
*
pub
t
i
{
(
field
)
*
}
)
;
)
*
)
;
(
it
:
(
#
[
attr
:
meta
]
)
*
pub
union
i
:
ident
{
(
field
:
tt
)
*
}
)
=
>
(
compile_error
!
(
"
unions
cannot
derive
extra
traits
use
s_no_extra_traits
instead
"
)
;
)
;
(
it
:
(
#
[
attr
:
meta
]
)
*
pub
struct
i
:
ident
{
(
field
:
tt
)
*
}
)
=
>
(
__item
!
{
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
extra_traits
"
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
Debug
Eq
Hash
PartialEq
)
)
]
#
[
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
:
:
core
:
:
clone
:
:
Clone
:
:
core
:
:
marker
:
:
Copy
)
]
#
[
allow
(
deprecated
)
]
(
#
[
attr
]
)
*
pub
struct
i
{
(
field
)
*
}
}
)
;
}
macro_rules
!
s_paren
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
struct
i
:
ident
(
(
field
:
tt
)
*
)
;
)
*
)
=
>
(
(
__item
!
{
#
[
cfg_attr
(
feature
=
"
extra_traits
"
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
Debug
Eq
Hash
PartialEq
)
)
]
#
[
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
:
:
core
:
:
clone
:
:
Clone
:
:
core
:
:
marker
:
:
Copy
)
]
(
#
[
attr
]
)
*
pub
struct
i
(
(
field
)
*
)
;
}
)
*
)
;
}
macro_rules
!
s_no_extra_traits
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
t
:
ident
i
:
ident
{
(
field
:
tt
)
*
}
)
*
)
=
>
(
(
s_no_extra_traits
!
(
it
:
(
#
[
attr
]
)
*
pub
t
i
{
(
field
)
*
}
)
;
)
*
)
;
(
it
:
(
#
[
attr
:
meta
]
)
*
pub
union
i
:
ident
{
(
field
:
tt
)
*
}
)
=
>
(
__item
!
{
#
[
repr
(
C
)
]
#
[
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
:
:
core
:
:
clone
:
:
Clone
:
:
core
:
:
marker
:
:
Copy
)
]
(
#
[
attr
]
)
*
pub
union
i
{
(
field
)
*
}
}
#
[
cfg
(
feature
=
"
extra_traits
"
)
]
impl
:
:
core
:
:
fmt
:
:
Debug
for
i
{
fn
fmt
(
&
self
f
:
&
mut
:
:
core
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
:
:
core
:
:
fmt
:
:
Result
{
f
.
debug_struct
(
:
:
core
:
:
stringify
!
(
i
)
)
.
finish_non_exhaustive
(
)
}
}
)
;
(
it
:
(
#
[
attr
:
meta
]
)
*
pub
struct
i
:
ident
{
(
field
:
tt
)
*
}
)
=
>
(
__item
!
{
#
[
repr
(
C
)
]
#
[
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
:
:
core
:
:
clone
:
:
Clone
:
:
core
:
:
marker
:
:
Copy
)
]
(
#
[
attr
]
)
*
pub
struct
i
{
(
field
)
*
}
}
)
;
}
macro_rules
!
missing
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
enum
i
:
ident
{
}
)
*
)
=
>
(
(
(
#
[
attr
]
)
*
#
[
allow
(
missing_copy_implementations
)
]
pub
enum
i
{
}
)
*
)
;
}
macro_rules
!
e
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
enum
i
:
ident
{
(
field
:
tt
)
*
}
)
*
)
=
>
(
(
__item
!
{
#
[
cfg_attr
(
feature
=
"
extra_traits
"
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
Debug
Eq
Hash
PartialEq
)
)
]
#
[
:
:
core
:
:
prelude
:
:
v1
:
:
derive
(
:
:
core
:
:
clone
:
:
Clone
:
:
core
:
:
marker
:
:
Copy
)
]
(
#
[
attr
]
)
*
pub
enum
i
{
(
field
)
*
}
}
)
*
)
;
}
cfg_if
!
{
if
#
[
cfg
(
libc_const_extern_fn
)
]
{
/
/
/
Define
an
unsafe
function
that
is
const
as
long
as
libc_const_extern_fn
is
enabled
.
macro_rules
!
f
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
(
{
constness
:
ident
}
)
*
fn
i
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
(
)
*
)
-
>
ret
:
ty
body
:
block
)
*
)
=
>
(
(
#
[
inline
]
(
#
[
attr
]
)
*
pub
(
constness
)
*
unsafe
extern
"
C
"
fn
i
(
(
arg
:
argty
)
*
)
-
>
ret
body
)
*
)
}
/
/
/
Define
a
safe
function
that
is
const
as
long
as
libc_const_extern_fn
is
enabled
.
macro_rules
!
safe_f
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
(
{
constness
:
ident
}
)
*
fn
i
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
(
)
*
)
-
>
ret
:
ty
body
:
block
)
*
)
=
>
(
(
#
[
inline
]
(
#
[
attr
]
)
*
pub
(
constness
)
*
extern
"
C
"
fn
i
(
(
arg
:
argty
)
*
)
-
>
ret
body
)
*
)
}
/
/
/
A
nonpublic
function
that
is
const
as
long
as
libc_const_extern_fn
is
enabled
.
macro_rules
!
const_fn
{
(
(
(
#
[
attr
:
meta
]
)
*
(
{
constness
:
ident
}
)
*
fn
i
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
(
)
*
)
-
>
ret
:
ty
body
:
block
)
*
)
=
>
(
(
#
[
inline
]
(
#
[
attr
]
)
*
(
constness
)
*
fn
i
(
(
arg
:
argty
)
*
)
-
>
ret
body
)
*
)
}
}
else
{
/
/
/
Define
an
unsafe
function
that
is
const
as
long
as
libc_const_extern_fn
is
enabled
.
macro_rules
!
f
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
(
{
constness
:
ident
}
)
*
fn
i
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
(
)
*
)
-
>
ret
:
ty
body
:
block
)
*
)
=
>
(
(
#
[
inline
]
(
#
[
attr
]
)
*
pub
unsafe
extern
"
C
"
fn
i
(
(
arg
:
argty
)
*
)
-
>
ret
body
)
*
)
}
/
/
/
Define
a
safe
function
that
is
const
as
long
as
libc_const_extern_fn
is
enabled
.
macro_rules
!
safe_f
{
(
(
(
#
[
attr
:
meta
]
)
*
pub
(
{
constness
:
ident
}
)
*
fn
i
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
(
)
*
)
-
>
ret
:
ty
body
:
block
)
*
)
=
>
(
(
#
[
inline
]
(
#
[
attr
]
)
*
pub
extern
"
C
"
fn
i
(
(
arg
:
argty
)
*
)
-
>
ret
body
)
*
)
}
/
/
/
A
nonpublic
function
that
is
const
as
long
as
libc_const_extern_fn
is
enabled
.
macro_rules
!
const_fn
{
(
(
(
#
[
attr
:
meta
]
)
*
(
{
constness
:
ident
}
)
*
fn
i
:
ident
(
(
arg
:
ident
:
argty
:
ty
)
*
(
)
*
)
-
>
ret
:
ty
body
:
block
)
*
)
=
>
(
(
#
[
inline
]
(
#
[
attr
]
)
*
fn
i
(
(
arg
:
argty
)
*
)
-
>
ret
body
)
*
)
}
}
}
macro_rules
!
__item
{
(
i
:
item
)
=
>
{
i
}
;
}
macro_rules
!
deprecated_mach
{
(
pub
const
id
:
ident
:
ty
:
ty
=
expr
:
expr
;
)
=
>
{
#
[
deprecated
(
since
=
"
0
.
2
.
55
"
note
=
"
Use
the
mach2
crate
instead
"
)
]
#
[
allow
(
deprecated
)
]
pub
const
id
:
ty
=
expr
;
}
;
(
(
pub
const
id
:
ident
:
ty
:
ty
=
expr
:
expr
;
)
*
)
=
>
{
(
deprecated_mach
!
(
pub
const
id
:
ty
=
expr
;
)
;
)
*
}
;
(
pub
type
id
:
ident
=
ty
:
ty
;
)
=
>
{
#
[
deprecated
(
since
=
"
0
.
2
.
55
"
note
=
"
Use
the
mach2
crate
instead
"
)
]
#
[
allow
(
deprecated
)
]
pub
type
id
=
ty
;
}
;
(
(
pub
type
id
:
ident
=
ty
:
ty
;
)
*
)
=
>
{
(
deprecated_mach
!
(
pub
type
id
=
ty
;
)
;
)
*
}
}
