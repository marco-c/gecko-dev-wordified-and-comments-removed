use
crate
:
:
any_calendar
:
:
{
AnyCalendar
IntoAnyCalendar
}
;
use
crate
:
:
week
:
:
{
WeekCalculator
WeekOf
}
;
use
crate
:
:
{
types
Calendar
CalendarError
DateDuration
DateDurationUnit
Iso
}
;
use
alloc
:
:
rc
:
:
Rc
;
use
alloc
:
:
sync
:
:
Arc
;
use
core
:
:
fmt
;
use
core
:
:
ops
:
:
Deref
;
pub
trait
AsCalendar
{
type
Calendar
:
Calendar
;
fn
as_calendar
(
&
self
)
-
>
&
Self
:
:
Calendar
;
}
impl
<
C
:
Calendar
>
AsCalendar
for
C
{
type
Calendar
=
C
;
#
[
inline
]
fn
as_calendar
(
&
self
)
-
>
&
Self
{
self
}
}
impl
<
C
:
Calendar
>
AsCalendar
for
Rc
<
C
>
{
type
Calendar
=
C
;
#
[
inline
]
fn
as_calendar
(
&
self
)
-
>
&
C
{
self
}
}
impl
<
C
:
Calendar
>
AsCalendar
for
Arc
<
C
>
{
type
Calendar
=
C
;
#
[
inline
]
fn
as_calendar
(
&
self
)
-
>
&
C
{
self
}
}
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
#
[
derive
(
PartialEq
Eq
Debug
)
]
pub
struct
Ref
<
'
a
C
>
(
pub
&
'
a
C
)
;
impl
<
C
>
Copy
for
Ref
<
'
_
C
>
{
}
impl
<
C
>
Clone
for
Ref
<
'
_
C
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
C
:
Calendar
>
AsCalendar
for
Ref
<
'
_
C
>
{
type
Calendar
=
C
;
#
[
inline
]
fn
as_calendar
(
&
self
)
-
>
&
C
{
self
.
0
}
}
impl
<
'
a
C
>
Deref
for
Ref
<
'
a
C
>
{
type
Target
=
C
;
fn
deref
(
&
self
)
-
>
&
C
{
self
.
0
}
}
pub
struct
Date
<
A
:
AsCalendar
>
{
pub
(
crate
)
inner
:
<
A
:
:
Calendar
as
Calendar
>
:
:
DateInner
pub
(
crate
)
calendar
:
A
}
impl
<
A
:
AsCalendar
>
Date
<
A
>
{
#
[
inline
]
pub
fn
try_new_from_codes
(
era
:
types
:
:
Era
year
:
i32
month_code
:
types
:
:
MonthCode
day
:
u8
calendar
:
A
)
-
>
Result
<
Self
CalendarError
>
{
let
inner
=
calendar
.
as_calendar
(
)
.
date_from_codes
(
era
year
month_code
day
)
?
;
Ok
(
Date
{
inner
calendar
}
)
}
#
[
inline
]
pub
fn
new_from_iso
(
iso
:
Date
<
Iso
>
calendar
:
A
)
-
>
Self
{
let
inner
=
calendar
.
as_calendar
(
)
.
date_from_iso
(
iso
)
;
Date
{
inner
calendar
}
}
#
[
inline
]
pub
fn
to_iso
(
&
self
)
-
>
Date
<
Iso
>
{
self
.
calendar
.
as_calendar
(
)
.
date_to_iso
(
self
.
inner
(
)
)
}
#
[
inline
]
pub
fn
to_calendar
<
A2
:
AsCalendar
>
(
&
self
calendar
:
A2
)
-
>
Date
<
A2
>
{
Date
:
:
new_from_iso
(
self
.
to_iso
(
)
calendar
)
}
#
[
inline
]
pub
fn
months_in_year
(
&
self
)
-
>
u8
{
self
.
calendar
.
as_calendar
(
)
.
months_in_year
(
self
.
inner
(
)
)
}
#
[
inline
]
pub
fn
days_in_year
(
&
self
)
-
>
u16
{
self
.
calendar
.
as_calendar
(
)
.
days_in_year
(
self
.
inner
(
)
)
}
#
[
inline
]
pub
fn
days_in_month
(
&
self
)
-
>
u8
{
self
.
calendar
.
as_calendar
(
)
.
days_in_month
(
self
.
inner
(
)
)
}
#
[
inline
]
pub
fn
day_of_week
(
&
self
)
-
>
types
:
:
IsoWeekday
{
self
.
calendar
.
as_calendar
(
)
.
day_of_week
(
self
.
inner
(
)
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
add
(
&
mut
self
duration
:
DateDuration
<
A
:
:
Calendar
>
)
{
self
.
calendar
.
as_calendar
(
)
.
offset_date
(
&
mut
self
.
inner
duration
)
}
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
added
(
mut
self
duration
:
DateDuration
<
A
:
:
Calendar
>
)
-
>
Self
{
self
.
add
(
duration
)
;
self
}
#
[
doc
(
hidden
)
]
#
[
inline
]
pub
fn
until
<
B
:
AsCalendar
<
Calendar
=
A
:
:
Calendar
>
>
(
&
self
other
:
&
Date
<
B
>
largest_unit
:
DateDurationUnit
smallest_unit
:
DateDurationUnit
)
-
>
DateDuration
<
A
:
:
Calendar
>
{
self
.
calendar
.
as_calendar
(
)
.
until
(
self
.
inner
(
)
other
.
inner
(
)
other
.
calendar
.
as_calendar
(
)
largest_unit
smallest_unit
)
}
#
[
inline
]
pub
fn
year
(
&
self
)
-
>
types
:
:
FormattableYear
{
self
.
calendar
.
as_calendar
(
)
.
year
(
&
self
.
inner
)
}
#
[
inline
]
pub
fn
is_in_leap_year
(
&
self
)
-
>
bool
{
self
.
calendar
.
as_calendar
(
)
.
is_in_leap_year
(
&
self
.
inner
)
}
#
[
inline
]
pub
fn
month
(
&
self
)
-
>
types
:
:
FormattableMonth
{
self
.
calendar
.
as_calendar
(
)
.
month
(
&
self
.
inner
)
}
#
[
inline
]
pub
fn
day_of_month
(
&
self
)
-
>
types
:
:
DayOfMonth
{
self
.
calendar
.
as_calendar
(
)
.
day_of_month
(
&
self
.
inner
)
}
#
[
inline
]
pub
fn
day_of_year_info
(
&
self
)
-
>
types
:
:
DayOfYearInfo
{
self
.
calendar
.
as_calendar
(
)
.
day_of_year_info
(
&
self
.
inner
)
}
pub
fn
week_of_month
(
&
self
first_weekday
:
types
:
:
IsoWeekday
)
-
>
types
:
:
WeekOfMonth
{
let
config
=
WeekCalculator
{
first_weekday
min_week_days
:
0
weekend
:
None
}
;
config
.
week_of_month
(
self
.
day_of_month
(
)
self
.
day_of_week
(
)
)
}
pub
fn
week_of_year
(
&
self
config
:
&
WeekCalculator
)
-
>
Result
<
WeekOf
CalendarError
>
{
config
.
week_of_year
(
self
.
day_of_year_info
(
)
self
.
day_of_week
(
)
)
}
#
[
inline
]
pub
fn
from_raw
(
inner
:
<
A
:
:
Calendar
as
Calendar
>
:
:
DateInner
calendar
:
A
)
-
>
Self
{
Self
{
inner
calendar
}
}
#
[
inline
]
pub
fn
inner
(
&
self
)
-
>
&
<
A
:
:
Calendar
as
Calendar
>
:
:
DateInner
{
&
self
.
inner
}
#
[
inline
]
pub
fn
calendar
(
&
self
)
-
>
&
A
:
:
Calendar
{
self
.
calendar
.
as_calendar
(
)
}
#
[
inline
]
pub
fn
calendar_wrapper
(
&
self
)
-
>
&
A
{
&
self
.
calendar
}
#
[
cfg
(
test
)
]
pub
(
crate
)
fn
to_fixed
(
&
self
)
-
>
calendrical_calculations
:
:
rata_die
:
:
RataDie
{
Iso
:
:
fixed_from_iso
(
self
.
to_iso
(
)
.
inner
)
}
}
impl
<
C
:
IntoAnyCalendar
A
:
AsCalendar
<
Calendar
=
C
>
>
Date
<
A
>
{
pub
fn
to_any
(
&
self
)
-
>
Date
<
AnyCalendar
>
{
let
cal
=
self
.
calendar
(
)
;
Date
:
:
from_raw
(
cal
.
date_to_any
(
self
.
inner
(
)
)
cal
.
to_any_cloned
(
)
)
}
}
impl
<
C
:
Calendar
>
Date
<
C
>
{
pub
fn
wrap_calendar_in_rc
(
self
)
-
>
Date
<
Rc
<
C
>
>
{
Date
:
:
from_raw
(
self
.
inner
Rc
:
:
new
(
self
.
calendar
)
)
}
pub
fn
wrap_calendar_in_arc
(
self
)
-
>
Date
<
Arc
<
C
>
>
{
Date
:
:
from_raw
(
self
.
inner
Arc
:
:
new
(
self
.
calendar
)
)
}
}
impl
<
C
A
B
>
PartialEq
<
Date
<
B
>
>
for
Date
<
A
>
where
C
:
Calendar
A
:
AsCalendar
<
Calendar
=
C
>
B
:
AsCalendar
<
Calendar
=
C
>
{
fn
eq
(
&
self
other
:
&
Date
<
B
>
)
-
>
bool
{
self
.
inner
.
eq
(
&
other
.
inner
)
}
}
impl
<
A
:
AsCalendar
>
Eq
for
Date
<
A
>
{
}
impl
<
C
A
B
>
PartialOrd
<
Date
<
B
>
>
for
Date
<
A
>
where
C
:
Calendar
C
:
:
DateInner
:
PartialOrd
A
:
AsCalendar
<
Calendar
=
C
>
B
:
AsCalendar
<
Calendar
=
C
>
{
fn
partial_cmp
(
&
self
other
:
&
Date
<
B
>
)
-
>
Option
<
core
:
:
cmp
:
:
Ordering
>
{
self
.
inner
.
partial_cmp
(
&
other
.
inner
)
}
}
impl
<
C
A
>
Ord
for
Date
<
A
>
where
C
:
Calendar
C
:
:
DateInner
:
Ord
A
:
AsCalendar
<
Calendar
=
C
>
{
fn
cmp
(
&
self
other
:
&
Self
)
-
>
core
:
:
cmp
:
:
Ordering
{
self
.
inner
.
cmp
(
&
other
.
inner
)
}
}
impl
<
A
:
AsCalendar
>
fmt
:
:
Debug
for
Date
<
A
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
Result
<
(
)
fmt
:
:
Error
>
{
write
!
(
f
"
Date
(
{
}
-
{
}
-
{
}
{
}
era
for
calendar
{
}
)
"
self
.
year
(
)
.
number
self
.
month
(
)
.
ordinal
self
.
day_of_month
(
)
.
0
self
.
year
(
)
.
era
.
0
self
.
calendar
.
as_calendar
(
)
.
debug_name
(
)
)
}
}
impl
<
A
:
AsCalendar
+
Clone
>
Clone
for
Date
<
A
>
{
fn
clone
(
&
self
)
-
>
Self
{
Self
{
inner
:
self
.
inner
.
clone
(
)
calendar
:
self
.
calendar
.
clone
(
)
}
}
}
impl
<
A
>
Copy
for
Date
<
A
>
where
A
:
AsCalendar
+
Copy
<
<
A
as
AsCalendar
>
:
:
Calendar
as
Calendar
>
:
:
DateInner
:
Copy
{
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_ord
(
)
{
let
dates_in_order
=
[
Date
:
:
try_new_iso_date
(
-
10
1
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
-
10
1
2
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
-
10
2
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
-
1
1
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
-
1
1
2
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
-
1
2
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
0
1
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
0
1
2
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
0
2
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
1
1
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
1
1
2
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
1
2
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
10
1
1
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
10
1
2
)
.
unwrap
(
)
Date
:
:
try_new_iso_date
(
10
2
1
)
.
unwrap
(
)
]
;
for
(
i
i_date
)
in
dates_in_order
.
iter
(
)
.
enumerate
(
)
{
for
(
j
j_date
)
in
dates_in_order
.
iter
(
)
.
enumerate
(
)
{
let
result1
=
i_date
.
cmp
(
j_date
)
;
let
result2
=
j_date
.
cmp
(
i_date
)
;
assert_eq
!
(
result1
.
reverse
(
)
result2
)
;
assert_eq
!
(
i
.
cmp
(
&
j
)
i_date
.
cmp
(
j_date
)
)
;
}
}
}
}
