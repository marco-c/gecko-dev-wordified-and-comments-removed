use
crate
:
:
any_calendar
:
:
AnyCalendarKind
;
use
crate
:
:
calendar_arithmetic
:
:
CalendarArithmetic
;
use
crate
:
:
chinese_based
:
:
{
chinese_based_ordinal_lunar_month_from_code
ChineseBasedCompiledData
ChineseBasedDateInner
ChineseBasedWithDataLoading
ChineseBasedYearInfo
}
;
use
crate
:
:
iso
:
:
Iso
;
use
crate
:
:
types
:
:
{
Era
FormattableYear
}
;
use
crate
:
:
AsCalendar
;
use
crate
:
:
{
chinese_data
types
Calendar
CalendarError
Date
DateDuration
DateDurationUnit
DateTime
}
;
use
core
:
:
num
:
:
NonZeroU8
;
use
tinystr
:
:
tinystr
;
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
non_exhaustive
]
pub
struct
Chinese
;
#
[
derive
(
Debug
Eq
PartialEq
PartialOrd
Ord
)
]
pub
struct
ChineseDateInner
(
ChineseBasedDateInner
<
Chinese
>
)
;
type
Inner
=
ChineseBasedDateInner
<
Chinese
>
;
impl
Copy
for
ChineseDateInner
{
}
impl
Clone
for
ChineseDateInner
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
Chinese
{
pub
fn
new_always_calculating
(
)
-
>
Self
{
Chinese
}
}
impl
Calendar
for
Chinese
{
type
DateInner
=
ChineseDateInner
;
fn
date_from_codes
(
&
self
era
:
types
:
:
Era
year
:
i32
month_code
:
types
:
:
MonthCode
day
:
u8
)
-
>
Result
<
Self
:
:
DateInner
CalendarError
>
{
let
year_info
=
ChineseBasedYearInfo
:
:
get_year_info
:
:
<
Chinese
>
(
year
)
;
let
month
=
if
let
Some
(
ordinal
)
=
chinese_based_ordinal_lunar_month_from_code
(
month_code
year_info
)
{
ordinal
}
else
{
return
Err
(
CalendarError
:
:
UnknownMonthCode
(
month_code
.
0
self
.
debug_name
(
)
)
)
;
}
;
if
era
.
0
!
=
tinystr
!
(
16
"
chinese
"
)
{
return
Err
(
CalendarError
:
:
UnknownEra
(
era
.
0
self
.
debug_name
(
)
)
)
;
}
let
arithmetic
=
Inner
:
:
new_from_ordinals
(
year
month
day
&
year_info
)
;
Ok
(
ChineseDateInner
(
ChineseBasedDateInner
(
arithmetic
?
year_info
)
)
)
}
fn
date_from_iso
(
&
self
iso
:
Date
<
Iso
>
)
-
>
Self
:
:
DateInner
{
let
fixed
=
Iso
:
:
fixed_from_iso
(
iso
.
inner
)
;
ChineseDateInner
(
Inner
:
:
chinese_based_date_from_fixed
(
fixed
iso
.
year
(
)
.
number
)
)
}
fn
date_to_iso
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
Date
<
Iso
>
{
let
fixed
=
Inner
:
:
fixed_from_chinese_based_date_inner
(
date
.
0
)
;
Iso
:
:
iso_from_fixed
(
fixed
)
}
fn
days_in_year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
u16
{
date
.
0
.
days_in_year_inner
(
)
}
fn
days_in_month
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
u8
{
date
.
0
.
days_in_month_inner
(
)
}
#
[
doc
(
hidden
)
]
fn
offset_date
(
&
self
date
:
&
mut
Self
:
:
DateInner
offset
:
DateDuration
<
Self
>
)
{
let
year
=
date
.
0
.
0
.
year
;
date
.
0
.
0
.
offset_date
(
offset
)
;
if
date
.
0
.
0
.
year
!
=
year
{
date
.
0
.
1
=
ChineseBasedYearInfo
:
:
get_year_info
:
:
<
Chinese
>
(
year
)
;
}
}
#
[
doc
(
hidden
)
]
#
[
allow
(
clippy
:
:
field_reassign_with_default
)
]
fn
until
(
&
self
date1
:
&
Self
:
:
DateInner
date2
:
&
Self
:
:
DateInner
_calendar2
:
&
Self
_largest_unit
:
DateDurationUnit
_smallest_unit
:
DateDurationUnit
)
-
>
DateDuration
<
Self
>
{
date1
.
0
.
0
.
until
(
date2
.
0
.
0
_largest_unit
_smallest_unit
)
}
fn
debug_name
(
&
self
)
-
>
&
'
static
str
{
"
Chinese
"
}
fn
year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
FormattableYear
{
Self
:
:
format_chinese_year
(
date
.
0
.
0
.
year
Some
(
date
.
0
.
1
)
)
}
fn
is_in_leap_year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
bool
{
Self
:
:
is_leap_year
(
date
.
0
.
0
.
year
)
}
fn
month
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
FormattableMonth
{
let
ordinal
=
date
.
0
.
0
.
month
;
let
leap_month_option
=
date
.
0
.
1
.
get_leap_month
(
)
;
let
leap_month
=
if
let
Some
(
leap
)
=
leap_month_option
{
leap
.
get
(
)
}
else
{
14
}
;
let
code_inner
=
if
leap_month
=
=
ordinal
{
debug_assert
!
(
(
2
.
.
=
13
)
.
contains
(
&
ordinal
)
)
;
match
ordinal
{
2
=
>
tinystr
!
(
4
"
M01L
"
)
3
=
>
tinystr
!
(
4
"
M02L
"
)
4
=
>
tinystr
!
(
4
"
M03L
"
)
5
=
>
tinystr
!
(
4
"
M04L
"
)
6
=
>
tinystr
!
(
4
"
M05L
"
)
7
=
>
tinystr
!
(
4
"
M06L
"
)
8
=
>
tinystr
!
(
4
"
M07L
"
)
9
=
>
tinystr
!
(
4
"
M08L
"
)
10
=
>
tinystr
!
(
4
"
M09L
"
)
11
=
>
tinystr
!
(
4
"
M10L
"
)
12
=
>
tinystr
!
(
4
"
M11L
"
)
13
=
>
tinystr
!
(
4
"
M12L
"
)
_
=
>
tinystr
!
(
4
"
und
"
)
}
}
else
{
let
mut
adjusted_ordinal
=
ordinal
;
if
ordinal
>
leap_month
{
debug_assert
!
(
(
2
.
.
=
13
)
.
contains
(
&
ordinal
)
)
;
adjusted_ordinal
-
=
1
;
}
debug_assert
!
(
(
1
.
.
=
12
)
.
contains
(
&
adjusted_ordinal
)
)
;
match
adjusted_ordinal
{
1
=
>
tinystr
!
(
4
"
M01
"
)
2
=
>
tinystr
!
(
4
"
M02
"
)
3
=
>
tinystr
!
(
4
"
M03
"
)
4
=
>
tinystr
!
(
4
"
M04
"
)
5
=
>
tinystr
!
(
4
"
M05
"
)
6
=
>
tinystr
!
(
4
"
M06
"
)
7
=
>
tinystr
!
(
4
"
M07
"
)
8
=
>
tinystr
!
(
4
"
M08
"
)
9
=
>
tinystr
!
(
4
"
M09
"
)
10
=
>
tinystr
!
(
4
"
M10
"
)
11
=
>
tinystr
!
(
4
"
M11
"
)
12
=
>
tinystr
!
(
4
"
M12
"
)
_
=
>
tinystr
!
(
4
"
und
"
)
}
}
;
let
code
=
types
:
:
MonthCode
(
code_inner
)
;
types
:
:
FormattableMonth
{
ordinal
:
ordinal
as
u32
code
}
}
fn
day_of_month
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
DayOfMonth
{
types
:
:
DayOfMonth
(
date
.
0
.
0
.
day
as
u32
)
}
fn
day_of_year_info
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
DayOfYearInfo
{
let
prev_year
=
date
.
0
.
0
.
year
.
saturating_sub
(
1
)
;
let
next_year
=
date
.
0
.
0
.
year
.
saturating_add
(
1
)
;
types
:
:
DayOfYearInfo
{
day_of_year
:
date
.
0
.
day_of_year
(
)
days_in_year
:
date
.
0
.
days_in_year_inner
(
)
prev_year
:
Self
:
:
format_chinese_year
(
prev_year
None
)
days_in_prev_year
:
Self
:
:
days_in_provided_year
(
prev_year
)
next_year
:
Self
:
:
format_chinese_year
(
next_year
None
)
}
}
fn
any_calendar_kind
(
&
self
)
-
>
Option
<
AnyCalendarKind
>
{
Some
(
AnyCalendarKind
:
:
Chinese
)
}
fn
months_in_year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
u8
{
date
.
0
.
months_in_year_inner
(
)
}
}
impl
<
A
:
AsCalendar
<
Calendar
=
Chinese
>
>
Date
<
A
>
{
pub
fn
try_new_chinese_date_with_calendar
(
year
:
i32
month
:
u8
day
:
u8
calendar
:
A
)
-
>
Result
<
Date
<
A
>
CalendarError
>
{
let
cache
=
ChineseBasedYearInfo
:
:
Cache
(
Inner
:
:
compute_cache
(
year
)
)
;
let
arithmetic
=
Inner
:
:
new_from_ordinals
(
year
month
day
&
cache
)
;
Ok
(
Date
:
:
from_raw
(
ChineseDateInner
(
ChineseBasedDateInner
(
arithmetic
?
cache
)
)
calendar
)
)
}
}
impl
<
A
:
AsCalendar
<
Calendar
=
Chinese
>
>
DateTime
<
A
>
{
pub
fn
try_new_chinese_datetime_with_calendar
(
year
:
i32
month
:
u8
day
:
u8
hour
:
u8
minute
:
u8
second
:
u8
calendar
:
A
)
-
>
Result
<
DateTime
<
A
>
CalendarError
>
{
Ok
(
DateTime
{
date
:
Date
:
:
try_new_chinese_date_with_calendar
(
year
month
day
calendar
)
?
time
:
types
:
:
Time
:
:
try_new
(
hour
minute
second
0
)
?
}
)
}
}
impl
ChineseBasedWithDataLoading
for
Chinese
{
type
CB
=
calendrical_calculations
:
:
chinese_based
:
:
Chinese
;
fn
get_compiled_data_for_year
(
extended_year
:
i32
)
-
>
Option
<
ChineseBasedCompiledData
>
{
let
offset_year
=
(
extended_year
-
chinese_data
:
:
MIN_YEAR
)
as
usize
;
chinese_data
:
:
CHINESE_DATA_ARRAY
.
get
(
offset_year
)
.
map
(
|
packed_data
|
packed_data
.
unpack
(
offset_year
as
i32
+
chinese_data
:
:
MIN_YEAR_ISO
)
)
}
}
impl
Chinese
{
fn
format_chinese_year
(
year
:
i32
year_info_option
:
Option
<
ChineseBasedYearInfo
>
)
-
>
FormattableYear
{
let
era
=
Era
(
tinystr
!
(
16
"
chinese
"
)
)
;
let
number
=
year
;
let
cyclic
=
(
number
-
1
)
.
rem_euclid
(
60
)
as
u8
;
let
cyclic
=
NonZeroU8
:
:
new
(
cyclic
+
1
)
;
let
rata_die_in_year
=
if
let
Some
(
info
)
=
year_info_option
{
info
.
get_new_year
(
)
}
else
{
Inner
:
:
fixed_mid_year_from_year
(
number
)
}
;
let
iso_formattable_year
=
Iso
:
:
iso_from_fixed
(
rata_die_in_year
)
.
year
(
)
;
let
related_iso
=
Some
(
iso_formattable_year
.
number
)
;
types
:
:
FormattableYear
{
era
number
cyclic
related_iso
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
types
:
:
MonthCode
;
use
calendrical_calculations
:
:
rata_die
:
:
RataDie
;
#
[
test
]
fn
test_chinese_from_fixed
(
)
{
#
[
derive
(
Debug
)
]
struct
TestCase
{
fixed
:
i64
expected_year
:
i32
expected_month
:
u8
expected_day
:
u8
}
let
cases
=
[
TestCase
{
fixed
:
-
964192
expected_year
:
-
2
expected_month
:
1
expected_day
:
1
}
TestCase
{
fixed
:
-
963838
expected_year
:
-
1
expected_month
:
1
expected_day
:
1
}
TestCase
{
fixed
:
-
963129
expected_year
:
0
expected_month
:
13
expected_day
:
1
}
TestCase
{
fixed
:
-
963100
expected_year
:
0
expected_month
:
13
expected_day
:
30
}
TestCase
{
fixed
:
-
963099
expected_year
:
1
expected_month
:
1
expected_day
:
1
}
TestCase
{
fixed
:
738700
expected_year
:
4660
expected_month
:
6
expected_day
:
12
}
TestCase
{
fixed
:
738718
expected_year
:
4660
expected_month
:
6
expected_day
:
30
}
TestCase
{
fixed
:
738747
expected_year
:
4660
expected_month
:
7
expected_day
:
29
}
TestCase
{
fixed
:
738748
expected_year
:
4660
expected_month
:
8
expected_day
:
1
}
TestCase
{
fixed
:
738865
expected_year
:
4660
expected_month
:
11
expected_day
:
29
}
TestCase
{
fixed
:
738895
expected_year
:
4660
expected_month
:
12
expected_day
:
29
}
TestCase
{
fixed
:
738925
expected_year
:
4660
expected_month
:
13
expected_day
:
30
}
]
;
for
case
in
cases
{
let
rata_die
=
RataDie
:
:
new
(
case
.
fixed
)
;
let
iso
=
Iso
:
:
iso_from_fixed
(
rata_die
)
;
let
chinese
=
Inner
:
:
chinese_based_date_from_fixed
(
rata_die
iso
.
year
(
)
.
number
)
;
assert_eq
!
(
case
.
expected_year
chinese
.
0
.
year
"
Chinese
from
fixed
failed
for
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
case
.
expected_month
chinese
.
0
.
month
"
Chinese
from
fixed
failed
for
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
case
.
expected_day
chinese
.
0
.
day
"
Chinese
from
fixed
failed
for
case
:
{
case
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_fixed_from_chinese
(
)
{
#
[
derive
(
Debug
)
]
struct
TestCase
{
year
:
i32
month
:
u8
day
:
u8
expected
:
i64
}
let
cases
=
[
TestCase
{
year
:
4660
month
:
6
day
:
6
expected
:
738694
}
TestCase
{
year
:
1
month
:
1
day
:
1
expected
:
-
963099
}
]
;
let
chinese
=
Chinese
:
:
new_always_calculating
(
)
;
let
chinese
=
crate
:
:
Ref
(
&
chinese
)
;
for
case
in
cases
{
let
date
=
Date
:
:
try_new_chinese_date_with_calendar
(
case
.
year
case
.
month
case
.
day
chinese
)
.
unwrap
(
)
;
let
fixed
=
Inner
:
:
fixed_from_chinese_based_date_inner
(
date
.
inner
.
0
)
.
to_i64_date
(
)
;
let
expected
=
case
.
expected
;
assert_eq
!
(
fixed
expected
"
Fixed
from
Chinese
failed
with
expected
:
{
fixed
}
and
calculated
:
{
expected
}
for
test
case
:
{
case
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_fixed_chinese_roundtrip
(
)
{
let
mut
fixed
=
-
1963020
;
let
max_fixed
=
1963020
;
let
mut
iters
=
0
;
let
max_iters
=
560
;
while
fixed
<
max_fixed
&
&
iters
<
max_iters
{
let
rata_die
=
RataDie
:
:
new
(
fixed
)
;
let
iso
=
Iso
:
:
iso_from_fixed
(
rata_die
)
;
let
chinese
=
Inner
:
:
chinese_based_date_from_fixed
(
rata_die
iso
.
year
(
)
.
number
)
;
let
result
=
Inner
:
:
fixed_from_chinese_based_date_inner
(
chinese
)
;
let
result_debug
=
result
.
to_i64_date
(
)
;
assert_eq
!
(
result
rata_die
"
Failed
roundtrip
fixed
-
>
Chinese
-
>
fixed
for
fixed
:
{
fixed
}
with
calculated
:
{
result_debug
}
from
Chinese
date
:
\
n
{
chinese
:
?
}
"
)
;
fixed
+
=
7043
;
iters
+
=
1
;
}
}
#
[
test
]
fn
test_chinese_epoch
(
)
{
let
iso
=
Date
:
:
try_new_iso_date
(
-
2636
2
15
)
.
unwrap
(
)
;
let
chinese
=
iso
.
to_calendar
(
Chinese
)
;
assert_eq
!
(
chinese
.
year
(
)
.
number
1
)
;
assert_eq
!
(
chinese
.
month
(
)
.
ordinal
1
)
;
assert_eq
!
(
chinese
.
month
(
)
.
code
.
0
"
M01
"
)
;
assert_eq
!
(
chinese
.
day_of_month
(
)
.
0
1
)
;
assert_eq
!
(
chinese
.
year
(
)
.
cyclic
.
unwrap
(
)
.
get
(
)
1
)
;
assert_eq
!
(
chinese
.
year
(
)
.
related_iso
Some
(
-
2636
)
)
;
}
#
[
test
]
fn
test_iso_to_chinese_negative_years
(
)
{
#
[
derive
(
Debug
)
]
struct
TestCase
{
iso_year
:
i32
iso_month
:
u8
iso_day
:
u8
expected_year
:
i32
expected_month
:
u32
expected_day
:
u32
}
let
cases
=
[
TestCase
{
iso_year
:
-
2636
iso_month
:
2
iso_day
:
14
expected_year
:
0
expected_month
:
13
expected_day
:
30
}
TestCase
{
iso_year
:
-
2636
iso_month
:
1
iso_day
:
15
expected_year
:
0
expected_month
:
12
expected_day
:
30
}
]
;
for
case
in
cases
{
let
iso
=
Date
:
:
try_new_iso_date
(
case
.
iso_year
case
.
iso_month
case
.
iso_day
)
.
unwrap
(
)
;
let
chinese
=
iso
.
to_calendar
(
Chinese
)
;
assert_eq
!
(
case
.
expected_year
chinese
.
year
(
)
.
number
"
ISO
to
Chinese
failed
for
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
case
.
expected_month
chinese
.
month
(
)
.
ordinal
"
ISO
to
Chinese
failed
for
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
case
.
expected_day
chinese
.
day_of_month
(
)
.
0
"
ISO
to
Chinese
failed
for
case
:
{
case
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_chinese_leap_months
(
)
{
let
expected
=
[
(
1933
6
)
(
1938
8
)
(
1984
11
)
(
2009
6
)
(
2017
7
)
(
2028
6
)
]
;
for
case
in
expected
{
let
year
=
case
.
0
;
let
expected_month
=
case
.
1
;
let
iso
=
Date
:
:
try_new_iso_date
(
year
6
1
)
.
unwrap
(
)
;
let
chinese_year
=
iso
.
to_calendar
(
Chinese
)
.
year
(
)
.
number
;
let
cache
=
Inner
:
:
compute_cache
(
chinese_year
)
;
assert
!
(
Chinese
:
:
is_leap_year
(
chinese_year
)
)
;
assert_eq
!
(
expected_month
calendrical_calculations
:
:
chinese_based
:
:
get_leap_month_from_new_year
:
:
<
calendrical_calculations
:
:
chinese_based
:
:
Chinese
>
(
cache
.
new_year
)
)
;
}
}
#
[
test
]
fn
test_month_days
(
)
{
let
year
=
4660
;
let
cases
=
[
(
1
29
)
(
2
30
)
(
3
29
)
(
4
29
)
(
5
30
)
(
6
30
)
(
7
29
)
(
8
30
)
(
9
30
)
(
10
29
)
(
11
30
)
(
12
29
)
(
13
30
)
]
;
for
case
in
cases
{
let
days_in_month
=
Chinese
:
:
month_days
(
year
case
.
0
)
;
assert_eq
!
(
case
.
1
days_in_month
"
month_days
test
failed
for
case
:
{
case
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_ordinal_to_month_code
(
)
{
#
[
derive
(
Debug
)
]
struct
TestCase
{
year
:
i32
month
:
u8
day
:
u8
expected_code
:
&
'
static
str
}
let
cases
=
[
TestCase
{
year
:
2023
month
:
1
day
:
9
expected_code
:
"
M12
"
}
TestCase
{
year
:
2023
month
:
2
day
:
9
expected_code
:
"
M01
"
}
TestCase
{
year
:
2023
month
:
3
day
:
9
expected_code
:
"
M02
"
}
TestCase
{
year
:
2023
month
:
4
day
:
9
expected_code
:
"
M02L
"
}
TestCase
{
year
:
2023
month
:
5
day
:
9
expected_code
:
"
M03
"
}
TestCase
{
year
:
2023
month
:
6
day
:
9
expected_code
:
"
M04
"
}
TestCase
{
year
:
2023
month
:
7
day
:
9
expected_code
:
"
M05
"
}
TestCase
{
year
:
2023
month
:
8
day
:
9
expected_code
:
"
M06
"
}
TestCase
{
year
:
2023
month
:
9
day
:
9
expected_code
:
"
M07
"
}
TestCase
{
year
:
2023
month
:
10
day
:
9
expected_code
:
"
M08
"
}
TestCase
{
year
:
2023
month
:
11
day
:
9
expected_code
:
"
M09
"
}
TestCase
{
year
:
2023
month
:
12
day
:
9
expected_code
:
"
M10
"
}
TestCase
{
year
:
2024
month
:
1
day
:
9
expected_code
:
"
M11
"
}
TestCase
{
year
:
2024
month
:
2
day
:
9
expected_code
:
"
M12
"
}
TestCase
{
year
:
2024
month
:
2
day
:
10
expected_code
:
"
M01
"
}
]
;
for
case
in
cases
{
let
iso
=
Date
:
:
try_new_iso_date
(
case
.
year
case
.
month
case
.
day
)
.
unwrap
(
)
;
let
chinese
=
iso
.
to_calendar
(
Chinese
)
;
let
result_code
=
chinese
.
month
(
)
.
code
.
0
;
let
expected_code
=
case
.
expected_code
.
to_string
(
)
;
assert_eq
!
(
expected_code
result_code
"
Month
codes
did
not
match
for
test
case
:
{
case
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_month_code_to_ordinal
(
)
{
let
year
=
4660
;
let
cache
=
Inner
:
:
compute_cache
(
year
)
;
let
codes
=
[
(
1
tinystr
!
(
4
"
M01
"
)
)
(
2
tinystr
!
(
4
"
M02
"
)
)
(
3
tinystr
!
(
4
"
M02L
"
)
)
(
4
tinystr
!
(
4
"
M03
"
)
)
(
5
tinystr
!
(
4
"
M04
"
)
)
(
6
tinystr
!
(
4
"
M05
"
)
)
(
7
tinystr
!
(
4
"
M06
"
)
)
(
8
tinystr
!
(
4
"
M07
"
)
)
(
9
tinystr
!
(
4
"
M08
"
)
)
(
10
tinystr
!
(
4
"
M09
"
)
)
(
11
tinystr
!
(
4
"
M10
"
)
)
(
12
tinystr
!
(
4
"
M11
"
)
)
(
13
tinystr
!
(
4
"
M12
"
)
)
]
;
for
ordinal_code_pair
in
codes
{
let
code
=
MonthCode
(
ordinal_code_pair
.
1
)
;
let
ordinal
=
chinese_based_ordinal_lunar_month_from_code
(
code
ChineseBasedYearInfo
:
:
Cache
(
cache
)
)
;
assert_eq
!
(
ordinal
Some
(
ordinal_code_pair
.
0
)
"
Code
to
ordinal
failed
for
year
:
{
year
}
code
:
{
code
}
"
)
;
}
}
#
[
test
]
fn
check_invalid_month_code_to_ordinal
(
)
{
let
non_leap_year
=
4659
;
let
leap_year
=
4660
;
let
invalid_codes
=
[
(
non_leap_year
tinystr
!
(
4
"
M2
"
)
)
(
leap_year
tinystr
!
(
4
"
M0
"
)
)
(
non_leap_year
tinystr
!
(
4
"
J01
"
)
)
(
leap_year
tinystr
!
(
4
"
3M
"
)
)
(
non_leap_year
tinystr
!
(
4
"
M04L
"
)
)
(
leap_year
tinystr
!
(
4
"
M04L
"
)
)
(
non_leap_year
tinystr
!
(
4
"
M13
"
)
)
(
leap_year
tinystr
!
(
4
"
M13
"
)
)
]
;
for
year_code_pair
in
invalid_codes
{
let
year
=
year_code_pair
.
0
;
let
cache
=
Inner
:
:
compute_cache
(
year
)
;
let
code
=
MonthCode
(
year_code_pair
.
1
)
;
let
ordinal
=
chinese_based_ordinal_lunar_month_from_code
(
code
ChineseBasedYearInfo
:
:
Cache
(
cache
)
)
;
assert_eq
!
(
ordinal
None
"
Invalid
month
code
failed
for
year
:
{
year
}
code
:
{
code
}
"
)
;
}
}
#
[
test
]
fn
test_iso_chinese_roundtrip
(
)
{
for
i
in
-
1000
.
.
=
1000
{
let
year
=
i
;
let
month
=
i
as
u8
%
12
+
1
;
let
day
=
i
as
u8
%
28
+
1
;
let
iso
=
Date
:
:
try_new_iso_date
(
year
month
day
)
.
unwrap
(
)
;
let
chinese
=
iso
.
to_calendar
(
Chinese
)
;
let
result
=
chinese
.
to_calendar
(
Iso
)
;
assert_eq
!
(
iso
result
"
ISO
to
Chinese
roundtrip
failed
!
\
nIso
:
{
iso
:
?
}
\
nChinese
:
{
chinese
:
?
}
\
nResult
:
{
result
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_consistent_with_icu
(
)
{
#
[
derive
(
Debug
)
]
struct
TestCase
{
iso_year
:
i32
iso_month
:
u8
iso_day
:
u8
expected_rel_iso
:
i32
expected_cyclic
:
u8
expected_month
:
u32
expected_day
:
u32
}
let
cases
=
[
TestCase
{
iso_year
:
-
2332
iso_month
:
3
iso_day
:
1
expected_rel_iso
:
-
2332
expected_cyclic
:
5
expected_month
:
1
expected_day
:
16
}
TestCase
{
iso_year
:
-
2332
iso_month
:
2
iso_day
:
15
expected_rel_iso
:
-
2332
expected_cyclic
:
5
expected_month
:
1
expected_day
:
1
}
TestCase
{
iso_year
:
-
2332
iso_month
:
2
iso_day
:
14
expected_rel_iso
:
-
2333
expected_cyclic
:
4
expected_month
:
13
expected_day
:
30
}
TestCase
{
iso_year
:
-
2332
iso_month
:
1
iso_day
:
17
expected_rel_iso
:
-
2333
expected_cyclic
:
4
expected_month
:
13
expected_day
:
2
}
TestCase
{
iso_year
:
-
2332
iso_month
:
1
iso_day
:
16
expected_rel_iso
:
-
2333
expected_cyclic
:
4
expected_month
:
13
expected_day
:
1
}
TestCase
{
iso_year
:
-
2332
iso_month
:
1
iso_day
:
15
expected_rel_iso
:
-
2333
expected_cyclic
:
4
expected_month
:
12
expected_day
:
29
}
TestCase
{
iso_year
:
-
2332
iso_month
:
1
iso_day
:
1
expected_rel_iso
:
-
2333
expected_cyclic
:
4
expected_month
:
12
expected_day
:
15
}
TestCase
{
iso_year
:
-
2333
iso_month
:
1
iso_day
:
16
expected_rel_iso
:
-
2334
expected_cyclic
:
3
expected_month
:
12
expected_day
:
19
}
]
;
for
case
in
cases
{
let
iso
=
Date
:
:
try_new_iso_date
(
case
.
iso_year
case
.
iso_month
case
.
iso_day
)
.
unwrap
(
)
;
let
chinese
=
iso
.
to_calendar
(
Chinese
)
;
let
chinese_rel_iso
=
chinese
.
year
(
)
.
related_iso
;
let
chinese_cyclic
=
chinese
.
year
(
)
.
cyclic
;
let
chinese_month
=
chinese
.
month
(
)
.
ordinal
;
let
chinese_day
=
chinese
.
day_of_month
(
)
.
0
;
assert_eq
!
(
chinese_rel_iso
Some
(
case
.
expected_rel_iso
)
"
Related
ISO
failed
for
test
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
chinese_cyclic
.
unwrap
(
)
.
get
(
)
case
.
expected_cyclic
"
Cyclic
year
failed
for
test
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
chinese_month
case
.
expected_month
"
Month
failed
for
test
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
chinese_day
case
.
expected_day
"
Day
failed
for
test
case
:
{
case
:
?
}
"
)
;
}
}
}
