use
crate
:
:
{
calendar_arithmetic
:
:
{
ArithmeticDate
CalendarArithmetic
}
types
:
:
MonthCode
CalendarError
Iso
}
;
use
calendrical_calculations
:
:
chinese_based
:
:
{
self
ChineseBased
YearBounds
}
;
use
calendrical_calculations
:
:
rata_die
:
:
RataDie
;
use
core
:
:
num
:
:
NonZeroU8
;
pub
(
crate
)
trait
ChineseBasedWithDataLoading
:
CalendarArithmetic
{
type
CB
:
ChineseBased
;
fn
get_compiled_data_for_year
(
extended_year
:
i32
)
-
>
Option
<
ChineseBasedCompiledData
>
;
}
#
[
derive
(
Debug
Eq
PartialEq
PartialOrd
Ord
)
]
pub
(
crate
)
struct
ChineseBasedDateInner
<
C
>
(
pub
(
crate
)
ArithmeticDate
<
C
>
pub
(
crate
)
ChineseBasedYearInfo
)
;
impl
<
C
>
Copy
for
ChineseBasedDateInner
<
C
>
{
}
impl
<
C
>
Clone
for
ChineseBasedDateInner
<
C
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
PartialOrd
Ord
)
]
pub
(
crate
)
enum
ChineseBasedYearInfo
{
Cache
(
ChineseBasedCache
)
Data
(
ChineseBasedCompiledData
)
}
impl
ChineseBasedYearInfo
{
pub
(
crate
)
fn
get_new_year
(
&
self
)
-
>
RataDie
{
match
self
{
Self
:
:
Cache
(
cache
)
=
>
cache
.
new_year
Self
:
:
Data
(
data
)
=
>
data
.
new_year
}
}
pub
(
crate
)
fn
get_next_new_year
(
&
self
)
-
>
RataDie
{
match
self
{
Self
:
:
Cache
(
cache
)
=
>
cache
.
next_new_year
Self
:
:
Data
(
data
)
=
>
data
.
next_new_year
(
)
}
}
pub
(
crate
)
fn
get_leap_month
(
&
self
)
-
>
Option
<
NonZeroU8
>
{
match
self
{
Self
:
:
Cache
(
cache
)
=
>
cache
.
leap_month
Self
:
:
Data
(
data
)
=
>
data
.
leap_month
}
}
pub
(
crate
)
fn
get_year_info
<
C
:
ChineseBasedWithDataLoading
>
(
year
:
i32
)
-
>
ChineseBasedYearInfo
{
if
let
Some
(
data
)
=
C
:
:
get_compiled_data_for_year
(
year
)
{
Self
:
:
Data
(
data
)
}
else
{
Self
:
:
Cache
(
ChineseBasedDateInner
:
:
<
C
>
:
:
compute_cache
(
year
)
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
PartialOrd
Ord
)
]
pub
(
crate
)
struct
ChineseBasedCache
{
pub
(
crate
)
new_year
:
RataDie
pub
(
crate
)
next_new_year
:
RataDie
pub
(
crate
)
leap_month
:
Option
<
NonZeroU8
>
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
(
crate
)
struct
PackedChineseBasedCompiledData
(
pub
(
crate
)
u8
pub
(
crate
)
u8
pub
(
crate
)
u8
)
;
impl
PackedChineseBasedCompiledData
{
pub
(
crate
)
fn
unpack
(
self
related_iso
:
i32
)
-
>
ChineseBasedCompiledData
{
fn
month_length
(
is_long
:
bool
)
-
>
u16
{
if
is_long
{
30
}
else
{
29
}
}
let
new_year_offset
=
(
(
self
.
0
&
0b11111000
)
>
>
3
)
as
u16
;
let
new_year
=
Iso
:
:
fixed_from_iso
(
Iso
:
:
iso_from_year_day
(
related_iso
21
+
new_year_offset
)
.
inner
)
;
let
mut
last_day_of_month
:
[
u16
;
13
]
=
[
0
;
13
]
;
let
mut
months_total
=
0
;
months_total
+
=
month_length
(
self
.
0
&
0b100
!
=
0
)
;
last_day_of_month
[
0
]
=
months_total
;
months_total
+
=
month_length
(
self
.
0
&
0b010
!
=
0
)
;
last_day_of_month
[
1
]
=
months_total
;
months_total
+
=
month_length
(
self
.
0
&
0b001
!
=
0
)
;
last_day_of_month
[
2
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b10000000
!
=
0
)
;
last_day_of_month
[
3
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b01000000
!
=
0
)
;
last_day_of_month
[
4
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b00100000
!
=
0
)
;
last_day_of_month
[
5
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b00010000
!
=
0
)
;
last_day_of_month
[
6
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b00001000
!
=
0
)
;
last_day_of_month
[
7
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b00000100
!
=
0
)
;
last_day_of_month
[
8
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b00000010
!
=
0
)
;
last_day_of_month
[
9
]
=
months_total
;
months_total
+
=
month_length
(
self
.
1
&
0b00000001
!
=
0
)
;
last_day_of_month
[
10
]
=
months_total
;
months_total
+
=
month_length
(
self
.
2
&
0b10000000
!
=
0
)
;
last_day_of_month
[
11
]
=
months_total
;
let
leap_month_bits
=
self
.
2
&
0b00111111
;
if
leap_month_bits
!
=
0
{
months_total
+
=
month_length
(
self
.
2
&
0b01000000
!
=
0
)
;
}
last_day_of_month
[
12
]
=
months_total
;
let
leap_month
=
NonZeroU8
:
:
new
(
leap_month_bits
)
;
ChineseBasedCompiledData
{
new_year
last_day_of_month
leap_month
}
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
PartialOrd
Ord
)
]
pub
(
crate
)
struct
ChineseBasedCompiledData
{
pub
(
crate
)
new_year
:
RataDie
last_day_of_month
:
[
u16
;
13
]
pub
(
crate
)
leap_month
:
Option
<
NonZeroU8
>
}
impl
ChineseBasedCompiledData
{
fn
next_new_year
(
self
)
-
>
RataDie
{
self
.
new_year
+
i64
:
:
from
(
self
.
last_day_of_month
[
12
]
)
}
fn
last_day_of_previous_month
(
self
month
:
u8
)
-
>
u16
{
debug_assert
!
(
(
1
.
.
=
13
)
.
contains
(
&
month
)
"
Month
out
of
bounds
!
"
)
;
if
month
<
2
{
0
}
else
{
self
.
last_day_of_month
.
get
(
usize
:
:
from
(
month
-
2
)
)
.
copied
(
)
.
unwrap_or
(
0
)
}
}
fn
last_day_of_month
(
self
month
:
u8
)
-
>
u16
{
debug_assert
!
(
(
1
.
.
=
13
)
.
contains
(
&
month
)
"
Month
out
of
bounds
!
"
)
;
self
.
last_day_of_month
.
get
(
usize
:
:
from
(
month
-
1
)
)
.
copied
(
)
.
unwrap_or
(
0
)
}
fn
days_in_month
(
self
month
:
u8
)
-
>
u8
{
let
ret
=
u8
:
:
try_from
(
self
.
last_day_of_month
(
month
)
-
self
.
last_day_of_previous_month
(
month
)
)
;
debug_assert
!
(
ret
.
is_ok
(
)
"
Month
too
big
!
"
)
;
ret
.
unwrap_or
(
30
)
}
}
impl
<
C
:
ChineseBasedWithDataLoading
>
ChineseBasedDateInner
<
C
>
{
fn
get_compiled_data_for_year_helper
(
date
:
RataDie
getter_year
:
&
mut
i32
)
-
>
Option
<
ChineseBasedCompiledData
>
{
let
data_option
=
C
:
:
get_compiled_data_for_year
(
*
getter_year
)
;
if
let
Some
(
data
)
=
data_option
{
if
date
<
data
.
new_year
{
*
getter_year
-
=
1
;
C
:
:
get_compiled_data_for_year
(
*
getter_year
)
}
else
if
date
>
=
data
.
next_new_year
(
)
{
*
getter_year
+
=
1
;
C
:
:
get_compiled_data_for_year
(
*
getter_year
)
}
else
{
data_option
}
}
else
{
None
}
}
fn
chinese_based_date_from_cached
(
date
:
RataDie
data
:
ChineseBasedCompiledData
extended_year
:
i32
)
-
>
ChineseBasedDateInner
<
C
>
{
debug_assert
!
(
date
<
data
.
next_new_year
(
)
"
Stored
date
{
date
:
?
}
out
of
bounds
!
"
)
;
let
day_of_year
=
u16
:
:
try_from
(
date
-
data
.
new_year
+
1
)
;
debug_assert
!
(
day_of_year
.
is_ok
(
)
"
Somehow
got
a
very
large
year
in
data
"
)
;
let
day_of_year
=
day_of_year
.
unwrap_or
(
1
)
;
let
mut
month
=
1
;
for
iter_month
in
1
.
.
=
13
{
month
=
iter_month
;
if
data
.
last_day_of_month
(
iter_month
)
>
=
day_of_year
{
break
;
}
}
debug_assert
!
(
(
1
.
.
=
13
)
.
contains
(
&
month
)
"
Month
out
of
bounds
!
"
)
;
debug_assert
!
(
month
<
13
|
|
data
.
leap_month
.
is_some
(
)
"
Cannot
have
13
months
in
a
non
-
leap
year
!
"
)
;
let
day_before_month_start
=
data
.
last_day_of_previous_month
(
month
)
;
let
day_of_month
=
day_of_year
-
day_before_month_start
;
let
day_of_month
=
u8
:
:
try_from
(
day_of_month
)
;
debug_assert
!
(
day_of_month
.
is_ok
(
)
"
Month
too
big
!
"
)
;
let
day_of_month
=
day_of_month
.
unwrap_or
(
1
)
;
ChineseBasedDateInner
(
ArithmeticDate
:
:
new_unchecked
(
extended_year
month
day_of_month
)
ChineseBasedYearInfo
:
:
Data
(
data
)
)
}
pub
(
crate
)
fn
chinese_based_date_from_fixed
(
date
:
RataDie
iso_year
:
i32
)
-
>
ChineseBasedDateInner
<
C
>
{
let
epoch_as_iso
=
Iso
:
:
iso_from_fixed
(
C
:
:
CB
:
:
EPOCH
)
;
let
mut
getter_year
=
iso_year
-
epoch_as_iso
.
year
(
)
.
number
+
1
;
let
data_option
=
Self
:
:
get_compiled_data_for_year_helper
(
date
&
mut
getter_year
)
;
if
let
Some
(
data
)
=
data_option
{
Self
:
:
chinese_based_date_from_cached
(
date
data
getter_year
)
}
else
{
let
date
=
chinese_based
:
:
chinese_based_date_from_fixed
:
:
<
C
:
:
CB
>
(
date
)
;
let
cache
=
ChineseBasedCache
{
new_year
:
date
.
year_bounds
.
new_year
next_new_year
:
date
.
year_bounds
.
next_new_year
leap_month
:
date
.
leap_month
}
;
ChineseBasedDateInner
(
ArithmeticDate
:
:
new_unchecked
(
date
.
year
date
.
month
date
.
day
)
ChineseBasedYearInfo
:
:
Cache
(
cache
)
)
}
}
pub
(
crate
)
fn
fixed_from_chinese_based_date_inner
(
date
:
ChineseBasedDateInner
<
C
>
)
-
>
RataDie
{
let
first_day_of_year
=
date
.
1
.
get_new_year
(
)
;
let
day_of_year
=
date
.
day_of_year
(
)
;
first_day_of_year
+
i64
:
:
from
(
day_of_year
)
-
1
}
pub
(
crate
)
fn
new_from_ordinals
(
year
:
i32
month
:
u8
day
:
u8
year_info
:
&
ChineseBasedYearInfo
)
-
>
Result
<
ArithmeticDate
<
C
>
CalendarError
>
{
let
max_month
=
Self
:
:
months_in_year_with_info
(
year_info
)
;
if
!
(
1
.
.
=
max_month
)
.
contains
(
&
month
)
{
return
Err
(
CalendarError
:
:
Overflow
{
field
:
"
month
"
max
:
max_month
as
usize
}
)
;
}
let
max_day
=
if
let
ChineseBasedYearInfo
:
:
Data
(
data
)
=
year_info
{
data
.
days_in_month
(
month
)
}
else
{
chinese_based
:
:
days_in_month
:
:
<
C
:
:
CB
>
(
month
year_info
.
get_new_year
(
)
None
)
.
0
}
;
if
day
>
max_day
{
return
Err
(
CalendarError
:
:
Overflow
{
field
:
"
day
"
max
:
max_day
as
usize
}
)
;
}
Ok
(
ArithmeticDate
:
:
<
C
>
:
:
new_unchecked
(
year
month
day
)
)
}
pub
(
crate
)
fn
months_in_year_inner
(
&
self
)
-
>
u8
{
Self
:
:
months_in_year_with_info
(
&
self
.
1
)
}
fn
months_in_year_with_info
(
year_info
:
&
ChineseBasedYearInfo
)
-
>
u8
{
if
year_info
.
get_leap_month
(
)
.
is_some
(
)
{
13
}
else
{
12
}
}
pub
(
crate
)
fn
days_in_month_inner
(
&
self
)
-
>
u8
{
if
let
ChineseBasedYearInfo
:
:
Data
(
data
)
=
self
.
1
{
data
.
days_in_month
(
self
.
0
.
month
)
}
else
{
chinese_based
:
:
days_in_month
:
:
<
C
:
:
CB
>
(
self
.
0
.
month
self
.
1
.
get_new_year
(
)
None
)
.
0
}
}
pub
(
crate
)
fn
fixed_mid_year_from_year
(
year
:
i32
)
-
>
RataDie
{
chinese_based
:
:
fixed_mid_year_from_year
:
:
<
C
:
:
CB
>
(
year
)
}
pub
(
crate
)
fn
days_in_year_inner
(
&
self
)
-
>
u16
{
let
next_new_year
=
self
.
1
.
get_next_new_year
(
)
;
let
new_year
=
self
.
1
.
get_new_year
(
)
;
YearBounds
{
new_year
next_new_year
}
.
count_days
(
)
}
pub
(
crate
)
fn
day_of_year
(
&
self
)
-
>
u16
{
let
days_until_month
=
if
let
ChineseBasedYearInfo
:
:
Data
(
data
)
=
self
.
1
{
data
.
last_day_of_previous_month
(
self
.
0
.
month
)
}
else
{
let
new_year
=
self
.
1
.
get_new_year
(
)
;
chinese_based
:
:
days_until_month
:
:
<
C
:
:
CB
>
(
new_year
self
.
0
.
month
)
}
;
days_until_month
+
u16
:
:
from
(
self
.
0
.
day
)
}
pub
(
crate
)
fn
compute_cache
(
year
:
i32
)
-
>
ChineseBasedCache
{
let
mid_year
=
Self
:
:
fixed_mid_year_from_year
(
year
)
;
let
year_bounds
=
YearBounds
:
:
compute
:
:
<
C
:
:
CB
>
(
mid_year
)
;
let
YearBounds
{
new_year
next_new_year
.
.
}
=
year_bounds
;
let
is_leap_year
=
year_bounds
.
is_leap
(
)
;
let
leap_month
=
if
is_leap_year
{
NonZeroU8
:
:
new
(
chinese_based
:
:
get_leap_month_from_new_year
:
:
<
C
:
:
CB
>
(
new_year
)
)
}
else
{
None
}
;
ChineseBasedCache
{
new_year
next_new_year
leap_month
}
}
}
impl
<
C
:
ChineseBasedWithDataLoading
>
CalendarArithmetic
for
C
{
fn
month_days
(
year
:
i32
month
:
u8
)
-
>
u8
{
chinese_based
:
:
month_days
:
:
<
C
:
:
CB
>
(
year
month
)
}
fn
months_for_every_year
(
year
:
i32
)
-
>
u8
{
if
Self
:
:
is_leap_year
(
year
)
{
13
}
else
{
12
}
}
fn
is_leap_year
(
year
:
i32
)
-
>
bool
{
if
let
Some
(
data
)
=
C
:
:
get_compiled_data_for_year
(
year
)
{
data
.
leap_month
.
is_some
(
)
}
else
{
chinese_based
:
:
is_leap_year
:
:
<
C
:
:
CB
>
(
year
)
}
}
fn
last_month_day_in_year
(
year
:
i32
)
-
>
(
u8
u8
)
{
if
let
Some
(
data
)
=
C
:
:
get_compiled_data_for_year
(
year
)
{
if
data
.
leap_month
.
is_some
(
)
{
(
13
data
.
days_in_month
(
13
)
)
}
else
{
(
12
data
.
days_in_month
(
12
)
)
}
}
else
{
chinese_based
:
:
last_month_day_in_year
:
:
<
C
:
:
CB
>
(
year
)
}
}
fn
days_in_provided_year
(
year
:
i32
)
-
>
u16
{
if
let
Some
(
data
)
=
C
:
:
get_compiled_data_for_year
(
year
)
{
data
.
last_day_of_month
(
13
)
}
else
{
chinese_based
:
:
days_in_provided_year
:
:
<
C
:
:
CB
>
(
year
)
}
}
}
pub
(
crate
)
fn
chinese_based_ordinal_lunar_month_from_code
(
code
:
MonthCode
year_info
:
ChineseBasedYearInfo
)
-
>
Option
<
u8
>
{
let
leap_month
=
if
let
Some
(
leap
)
=
year_info
.
get_leap_month
(
)
{
leap
.
get
(
)
}
else
{
14
}
;
if
code
.
0
.
len
(
)
<
3
{
return
None
;
}
let
bytes
=
code
.
0
.
all_bytes
(
)
;
if
bytes
[
0
]
!
=
b
'
M
'
{
return
None
;
}
if
code
.
0
.
len
(
)
=
=
4
&
&
bytes
[
3
]
!
=
b
'
L
'
{
return
None
;
}
let
mut
unadjusted
=
0
;
if
bytes
[
1
]
=
=
b
'
0
'
{
if
bytes
[
2
]
>
=
b
'
1
'
&
&
bytes
[
2
]
<
=
b
'
9
'
{
unadjusted
=
bytes
[
2
]
-
b
'
0
'
;
}
}
else
if
bytes
[
1
]
=
=
b
'
1
'
&
&
bytes
[
2
]
>
=
b
'
0
'
&
&
bytes
[
2
]
<
=
b
'
2
'
{
unadjusted
=
10
+
bytes
[
2
]
-
b
'
0
'
;
}
if
bytes
[
3
]
=
=
b
'
L
'
{
if
unadjusted
+
1
!
=
leap_month
{
return
None
;
}
else
{
return
Some
(
unadjusted
+
1
)
;
}
}
if
unadjusted
!
=
0
{
if
unadjusted
+
1
>
leap_month
{
return
Some
(
unadjusted
+
1
)
;
}
else
{
return
Some
(
unadjusted
)
;
}
}
None
}
