use
crate
:
:
any_calendar
:
:
AnyCalendarKind
;
use
crate
:
:
calendar_arithmetic
:
:
{
ArithmeticDate
CalendarArithmetic
}
;
use
crate
:
:
iso
:
:
Iso
;
use
crate
:
:
{
types
Calendar
CalendarError
Date
DateDuration
DateDurationUnit
DateTime
}
;
use
tinystr
:
:
tinystr
;
#
[
derive
(
Copy
Clone
Debug
Hash
Default
Eq
PartialEq
PartialOrd
Ord
)
]
#
[
allow
(
clippy
:
:
exhaustive_structs
)
]
pub
struct
Indian
;
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
PartialOrd
Ord
)
]
pub
struct
IndianDateInner
(
ArithmeticDate
<
Indian
>
)
;
impl
CalendarArithmetic
for
Indian
{
fn
month_days
(
year
:
i32
month
:
u8
)
-
>
u8
{
if
month
=
=
1
{
if
Self
:
:
is_leap_year
(
year
)
{
31
}
else
{
30
}
}
else
if
(
2
.
.
=
6
)
.
contains
(
&
month
)
{
31
}
else
if
(
7
.
.
=
12
)
.
contains
(
&
month
)
{
30
}
else
{
0
}
}
fn
months_for_every_year
(
_
:
i32
)
-
>
u8
{
12
}
fn
is_leap_year
(
year
:
i32
)
-
>
bool
{
Iso
:
:
is_leap_year
(
year
+
78
)
}
fn
last_month_day_in_year
(
_year
:
i32
)
-
>
(
u8
u8
)
{
(
12
30
)
}
fn
days_in_provided_year
(
year
:
i32
)
-
>
u16
{
if
Self
:
:
is_leap_year
(
year
)
{
366
}
else
{
365
}
}
}
const
DAY_OFFSET
:
u16
=
80
;
const
YEAR_OFFSET
:
i32
=
78
;
impl
Calendar
for
Indian
{
type
DateInner
=
IndianDateInner
;
fn
date_from_codes
(
&
self
era
:
types
:
:
Era
year
:
i32
month_code
:
types
:
:
MonthCode
day
:
u8
)
-
>
Result
<
Self
:
:
DateInner
CalendarError
>
{
if
era
.
0
!
=
tinystr
!
(
16
"
saka
"
)
&
&
era
.
0
!
=
tinystr
!
(
16
"
indian
"
)
{
return
Err
(
CalendarError
:
:
UnknownEra
(
era
.
0
self
.
debug_name
(
)
)
)
;
}
ArithmeticDate
:
:
new_from_codes
(
self
year
month_code
day
)
.
map
(
IndianDateInner
)
}
fn
date_from_iso
(
&
self
iso
:
Date
<
Iso
>
)
-
>
IndianDateInner
{
let
day_of_year_iso
=
Iso
:
:
day_of_year
(
*
iso
.
inner
(
)
)
;
let
mut
year
=
iso
.
inner
(
)
.
0
.
year
-
YEAR_OFFSET
;
let
day_of_year_indian
=
if
day_of_year_iso
<
=
DAY_OFFSET
{
year
-
=
1
;
let
n_days
=
Self
:
:
days_in_provided_year
(
year
)
;
n_days
+
day_of_year_iso
-
DAY_OFFSET
}
else
{
day_of_year_iso
-
DAY_OFFSET
}
;
IndianDateInner
(
ArithmeticDate
:
:
date_from_year_day
(
year
day_of_year_indian
as
u32
)
)
}
fn
date_to_iso
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
Date
<
Iso
>
{
let
day_of_year_indian
=
date
.
0
.
day_of_year
(
)
;
let
days_in_year
=
date
.
0
.
days_in_year
(
)
;
let
mut
year
=
date
.
0
.
year
+
YEAR_OFFSET
;
let
day_of_year_iso
=
if
day_of_year_indian
+
DAY_OFFSET
>
=
days_in_year
{
year
+
=
1
;
day_of_year_indian
+
DAY_OFFSET
-
days_in_year
}
else
{
day_of_year_indian
+
DAY_OFFSET
}
;
Iso
:
:
iso_from_year_day
(
year
day_of_year_iso
)
}
fn
months_in_year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
u8
{
date
.
0
.
months_in_year
(
)
}
fn
days_in_year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
u16
{
date
.
0
.
days_in_year
(
)
}
fn
days_in_month
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
u8
{
date
.
0
.
days_in_month
(
)
}
fn
day_of_week
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
IsoWeekday
{
Iso
.
day_of_week
(
Indian
.
date_to_iso
(
date
)
.
inner
(
)
)
}
fn
offset_date
(
&
self
date
:
&
mut
Self
:
:
DateInner
offset
:
DateDuration
<
Self
>
)
{
date
.
0
.
offset_date
(
offset
)
;
}
#
[
allow
(
clippy
:
:
field_reassign_with_default
)
]
fn
until
(
&
self
date1
:
&
Self
:
:
DateInner
date2
:
&
Self
:
:
DateInner
_calendar2
:
&
Self
_largest_unit
:
DateDurationUnit
_smallest_unit
:
DateDurationUnit
)
-
>
DateDuration
<
Self
>
{
date1
.
0
.
until
(
date2
.
0
_largest_unit
_smallest_unit
)
}
fn
year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
FormattableYear
{
types
:
:
FormattableYear
{
era
:
types
:
:
Era
(
tinystr
!
(
16
"
saka
"
)
)
number
:
date
.
0
.
year
cyclic
:
None
related_iso
:
None
}
}
fn
is_in_leap_year
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
bool
{
Self
:
:
is_leap_year
(
date
.
0
.
year
)
}
fn
month
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
FormattableMonth
{
date
.
0
.
month
(
)
}
fn
day_of_month
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
DayOfMonth
{
date
.
0
.
day_of_month
(
)
}
fn
day_of_year_info
(
&
self
date
:
&
Self
:
:
DateInner
)
-
>
types
:
:
DayOfYearInfo
{
let
prev_year
=
types
:
:
FormattableYear
{
era
:
types
:
:
Era
(
tinystr
!
(
16
"
saka
"
)
)
number
:
date
.
0
.
year
-
1
cyclic
:
None
related_iso
:
None
}
;
let
next_year
=
types
:
:
FormattableYear
{
era
:
types
:
:
Era
(
tinystr
!
(
16
"
saka
"
)
)
number
:
date
.
0
.
year
+
1
cyclic
:
None
related_iso
:
None
}
;
types
:
:
DayOfYearInfo
{
day_of_year
:
date
.
0
.
day_of_year
(
)
days_in_year
:
date
.
0
.
days_in_year
(
)
prev_year
days_in_prev_year
:
Indian
:
:
days_in_year_direct
(
date
.
0
.
year
-
1
)
next_year
}
}
fn
debug_name
(
&
self
)
-
>
&
'
static
str
{
"
Indian
"
}
fn
any_calendar_kind
(
&
self
)
-
>
Option
<
AnyCalendarKind
>
{
Some
(
AnyCalendarKind
:
:
Indian
)
}
}
impl
Indian
{
pub
fn
new
(
)
-
>
Self
{
Self
}
fn
days_in_year_direct
(
year
:
i32
)
-
>
u16
{
if
Indian
:
:
is_leap_year
(
year
)
{
366
}
else
{
365
}
}
}
impl
Date
<
Indian
>
{
pub
fn
try_new_indian_date
(
year
:
i32
month
:
u8
day
:
u8
)
-
>
Result
<
Date
<
Indian
>
CalendarError
>
{
ArithmeticDate
:
:
new_from_ordinals
(
year
month
day
)
.
map
(
IndianDateInner
)
.
map
(
|
inner
|
Date
:
:
from_raw
(
inner
Indian
)
)
}
}
impl
DateTime
<
Indian
>
{
pub
fn
try_new_indian_datetime
(
year
:
i32
month
:
u8
day
:
u8
hour
:
u8
minute
:
u8
second
:
u8
)
-
>
Result
<
DateTime
<
Indian
>
CalendarError
>
{
Ok
(
DateTime
{
date
:
Date
:
:
try_new_indian_date
(
year
month
day
)
?
time
:
types
:
:
Time
:
:
try_new
(
hour
minute
second
0
)
?
}
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
calendrical_calculations
:
:
rata_die
:
:
RataDie
;
fn
assert_roundtrip
(
y
:
i32
m
:
u8
d
:
u8
iso_y
:
i32
iso_m
:
u8
iso_d
:
u8
)
{
let
indian
=
Date
:
:
try_new_indian_date
(
y
m
d
)
.
expect
(
"
Indian
date
should
construct
successfully
"
)
;
let
iso
=
indian
.
to_iso
(
)
;
assert_eq
!
(
iso
.
year
(
)
.
number
iso_y
"
{
y
}
-
{
m
}
-
{
d
}
:
ISO
year
did
not
match
"
)
;
assert_eq
!
(
iso
.
month
(
)
.
ordinal
as
u8
iso_m
"
{
y
}
-
{
m
}
-
{
d
}
:
ISO
month
did
not
match
"
)
;
assert_eq
!
(
iso
.
day_of_month
(
)
.
0
as
u8
iso_d
"
{
y
}
-
{
m
}
-
{
d
}
:
ISO
day
did
not
match
"
)
;
let
roundtrip
=
iso
.
to_calendar
(
Indian
)
;
assert_eq
!
(
roundtrip
.
year
(
)
.
number
indian
.
year
(
)
.
number
"
{
y
}
-
{
m
}
-
{
d
}
:
roundtrip
year
did
not
match
"
)
;
assert_eq
!
(
roundtrip
.
month
(
)
.
ordinal
indian
.
month
(
)
.
ordinal
"
{
y
}
-
{
m
}
-
{
d
}
:
roundtrip
month
did
not
match
"
)
;
assert_eq
!
(
roundtrip
.
day_of_month
(
)
indian
.
day_of_month
(
)
"
{
y
}
-
{
m
}
-
{
d
}
:
roundtrip
day
did
not
match
"
)
;
}
#
[
test
]
fn
roundtrip_indian
(
)
{
assert_roundtrip
(
1944
6
7
2022
8
29
)
;
assert_roundtrip
(
1943
6
7
2021
8
29
)
;
assert_roundtrip
(
1942
6
7
2020
8
29
)
;
assert_roundtrip
(
1941
6
7
2019
8
29
)
;
assert_roundtrip
(
1944
11
7
2023
1
27
)
;
assert_roundtrip
(
1943
11
7
2022
1
27
)
;
assert_roundtrip
(
1942
11
7
2021
1
27
)
;
assert_roundtrip
(
1941
11
7
2020
1
27
)
;
}
#
[
derive
(
Debug
)
]
struct
TestCase
{
iso_year
:
i32
iso_month
:
u8
iso_day
:
u8
expected_year
:
i32
expected_month
:
u32
expected_day
:
u32
}
fn
check_case
(
case
:
TestCase
)
{
let
iso
=
Date
:
:
try_new_iso_date
(
case
.
iso_year
case
.
iso_month
case
.
iso_day
)
.
unwrap
(
)
;
let
saka
=
iso
.
to_calendar
(
Indian
)
;
assert_eq
!
(
saka
.
year
(
)
.
number
case
.
expected_year
"
Year
check
failed
for
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
saka
.
month
(
)
.
ordinal
case
.
expected_month
"
Month
check
failed
for
case
:
{
case
:
?
}
"
)
;
assert_eq
!
(
saka
.
day_of_month
(
)
.
0
case
.
expected_day
"
Day
check
failed
for
case
:
{
case
:
?
}
"
)
;
}
#
[
test
]
fn
test_cases_near_epoch_start
(
)
{
let
cases
=
[
TestCase
{
iso_year
:
79
iso_month
:
3
iso_day
:
23
expected_year
:
1
expected_month
:
1
expected_day
:
2
}
TestCase
{
iso_year
:
79
iso_month
:
3
iso_day
:
22
expected_year
:
1
expected_month
:
1
expected_day
:
1
}
TestCase
{
iso_year
:
79
iso_month
:
3
iso_day
:
21
expected_year
:
0
expected_month
:
12
expected_day
:
30
}
TestCase
{
iso_year
:
79
iso_month
:
3
iso_day
:
20
expected_year
:
0
expected_month
:
12
expected_day
:
29
}
TestCase
{
iso_year
:
78
iso_month
:
3
iso_day
:
21
expected_year
:
-
1
expected_month
:
12
expected_day
:
30
}
]
;
for
case
in
cases
{
check_case
(
case
)
;
}
}
#
[
test
]
fn
test_cases_near_rd_zero
(
)
{
let
cases
=
[
TestCase
{
iso_year
:
1
iso_month
:
3
iso_day
:
22
expected_year
:
-
77
expected_month
:
1
expected_day
:
1
}
TestCase
{
iso_year
:
1
iso_month
:
3
iso_day
:
21
expected_year
:
-
78
expected_month
:
12
expected_day
:
30
}
TestCase
{
iso_year
:
1
iso_month
:
1
iso_day
:
1
expected_year
:
-
78
expected_month
:
10
expected_day
:
11
}
TestCase
{
iso_year
:
0
iso_month
:
3
iso_day
:
21
expected_year
:
-
78
expected_month
:
1
expected_day
:
1
}
TestCase
{
iso_year
:
0
iso_month
:
1
iso_day
:
1
expected_year
:
-
79
expected_month
:
10
expected_day
:
11
}
TestCase
{
iso_year
:
-
1
iso_month
:
3
iso_day
:
21
expected_year
:
-
80
expected_month
:
12
expected_day
:
30
}
]
;
for
case
in
cases
{
check_case
(
case
)
;
}
}
#
[
test
]
fn
test_roundtrip_near_rd_zero
(
)
{
for
i
in
-
1000
.
.
=
1000
{
let
initial
=
RataDie
:
:
new
(
i
)
;
let
result
=
Iso
:
:
fixed_from_iso
(
Iso
:
:
iso_from_fixed
(
initial
)
.
to_calendar
(
Indian
)
.
to_calendar
(
Iso
)
.
inner
)
;
assert_eq
!
(
initial
result
"
Roundtrip
failed
for
initial
:
{
initial
:
?
}
result
:
{
result
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_roundtrip_near_epoch_start
(
)
{
for
i
in
27570
.
.
=
29570
{
let
initial
=
RataDie
:
:
new
(
i
)
;
let
result
=
Iso
:
:
fixed_from_iso
(
Iso
:
:
iso_from_fixed
(
initial
)
.
to_calendar
(
Indian
)
.
to_calendar
(
Iso
)
.
inner
)
;
assert_eq
!
(
initial
result
"
Roundtrip
failed
for
initial
:
{
initial
:
?
}
result
:
{
result
:
?
}
"
)
;
}
}
#
[
test
]
fn
test_directionality_near_rd_zero
(
)
{
for
i
in
-
100
.
.
=
100
{
for
j
in
-
100
.
.
=
100
{
let
rd_i
=
RataDie
:
:
new
(
i
)
;
let
rd_j
=
RataDie
:
:
new
(
j
)
;
let
indian_i
=
Iso
:
:
iso_from_fixed
(
rd_i
)
.
to_calendar
(
Indian
)
;
let
indian_j
=
Iso
:
:
iso_from_fixed
(
rd_j
)
.
to_calendar
(
Indian
)
;
assert_eq
!
(
i
.
cmp
(
&
j
)
indian_i
.
cmp
(
&
indian_j
)
"
Directionality
test
failed
for
i
:
{
i
}
j
:
{
j
}
indian_i
:
{
indian_i
:
?
}
indian_j
:
{
indian_j
:
?
}
"
)
;
}
}
}
#
[
test
]
fn
test_directionality_near_epoch_start
(
)
{
for
i
in
28470
.
.
=
28670
{
for
j
in
28470
.
.
=
28670
{
let
indian_i
=
Iso
:
:
iso_from_fixed
(
RataDie
:
:
new
(
i
)
)
.
to_calendar
(
Indian
)
;
let
indian_j
=
Iso
:
:
iso_from_fixed
(
RataDie
:
:
new
(
j
)
)
.
to_calendar
(
Indian
)
;
assert_eq
!
(
i
.
cmp
(
&
j
)
indian_i
.
cmp
(
&
indian_j
)
"
Directionality
test
failed
for
i
:
{
i
}
j
:
{
j
}
indian_i
:
{
indian_i
:
?
}
indian_j
:
{
indian_j
:
?
}
"
)
;
}
}
}
}
