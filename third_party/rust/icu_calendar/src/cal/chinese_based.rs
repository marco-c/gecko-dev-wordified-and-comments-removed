use
crate
:
:
{
calendar_arithmetic
:
:
{
ArithmeticDate
CalendarArithmetic
PrecomputedDataSource
}
error
:
:
DateError
provider
:
:
chinese_based
:
:
{
ChineseBasedCache
PackedChineseBasedYearInfo
}
types
:
:
{
MonthCode
MonthInfo
}
Calendar
Iso
}
;
use
calendrical_calculations
:
:
chinese_based
:
:
{
self
ChineseBased
YearBounds
}
;
use
calendrical_calculations
:
:
rata_die
:
:
RataDie
;
use
core
:
:
marker
:
:
PhantomData
;
use
tinystr
:
:
tinystr
;
pub
(
crate
)
trait
ChineseBasedWithDataLoading
:
Calendar
{
type
CB
:
ChineseBased
;
fn
get_precomputed_data
(
&
self
)
-
>
ChineseBasedPrecomputedData
<
'
_
Self
:
:
CB
>
;
}
#
[
derive
(
Default
)
]
pub
(
crate
)
struct
ChineseBasedPrecomputedData
<
'
a
CB
:
ChineseBased
>
{
data
:
Option
<
&
'
a
ChineseBasedCache
<
'
a
>
>
_cb
:
PhantomData
<
CB
>
}
impl
<
CB
:
ChineseBased
>
PrecomputedDataSource
<
ChineseBasedYearInfo
>
for
ChineseBasedPrecomputedData
<
'
_
CB
>
{
fn
load_or_compute_info
(
&
self
related_iso
:
i32
)
-
>
ChineseBasedYearInfo
{
self
.
data
.
and_then
(
|
d
|
{
Some
(
ChineseBasedYearInfo
{
packed_data
:
d
.
data
.
get
(
usize
:
:
try_from
(
related_iso
-
d
.
first_related_iso_year
)
.
ok
(
)
?
)
?
related_iso
}
)
}
)
.
unwrap_or_else
(
|
|
ChineseBasedYearInfo
:
:
compute
:
:
<
CB
>
(
related_iso
)
)
}
}
impl
<
'
b
CB
:
ChineseBased
>
ChineseBasedPrecomputedData
<
'
b
CB
>
{
pub
(
crate
)
fn
new
(
data
:
Option
<
&
'
b
ChineseBasedCache
<
'
b
>
>
)
-
>
Self
{
Self
{
data
_cb
:
PhantomData
}
}
pub
(
crate
)
fn
load_or_compute_info_for_rd
(
&
self
rd
:
RataDie
iso
:
ArithmeticDate
<
Iso
>
)
-
>
ChineseBasedYearInfo
{
if
let
Some
(
cached
)
=
self
.
data
.
and_then
(
|
d
|
{
let
delta
=
usize
:
:
try_from
(
iso
.
year
-
d
.
first_related_iso_year
)
.
ok
(
)
?
;
if
delta
=
=
0
{
return
None
;
}
let
packed_data
=
d
.
data
.
get
(
delta
)
?
;
if
iso
.
day_of_year
(
)
.
0
>
packed_data
.
ny_offset
(
)
as
u16
{
Some
(
ChineseBasedYearInfo
{
packed_data
related_iso
:
iso
.
year
}
)
}
else
{
if
delta
<
=
1
{
return
None
;
}
Some
(
ChineseBasedYearInfo
{
packed_data
:
d
.
data
.
get
(
delta
-
1
)
?
related_iso
:
iso
.
year
-
1
}
)
}
}
)
{
return
cached
;
}
;
let
mid_year
=
calendrical_calculations
:
:
iso
:
:
fixed_from_iso
(
iso
.
year
7
1
)
;
let
year_bounds
=
YearBounds
:
:
compute
:
:
<
CB
>
(
mid_year
)
;
let
YearBounds
{
new_year
.
.
}
=
year_bounds
;
if
rd
>
=
new_year
{
ChineseBasedYearInfo
:
:
compute_with_yb
:
:
<
CB
>
(
iso
.
year
year_bounds
)
}
else
{
ChineseBasedYearInfo
:
:
compute
:
:
<
CB
>
(
iso
.
year
-
1
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
PartialOrd
Ord
)
]
pub
(
crate
)
struct
ChineseBasedYearInfo
{
packed_data
:
PackedChineseBasedYearInfo
pub
(
crate
)
related_iso
:
i32
}
impl
From
<
ChineseBasedYearInfo
>
for
i32
{
fn
from
(
value
:
ChineseBasedYearInfo
)
-
>
Self
{
value
.
related_iso
}
}
impl
ChineseBasedYearInfo
{
fn
compute
<
CB
:
ChineseBased
>
(
related_iso
:
i32
)
-
>
Self
{
let
mid_year
=
calendrical_calculations
:
:
iso
:
:
fixed_from_iso
(
related_iso
7
1
)
;
let
year_bounds
=
YearBounds
:
:
compute
:
:
<
CB
>
(
mid_year
)
;
Self
:
:
compute_with_yb
:
:
<
CB
>
(
related_iso
year_bounds
)
}
fn
compute_with_yb
<
CB
:
ChineseBased
>
(
related_iso
:
i32
year_bounds
:
YearBounds
)
-
>
Self
{
let
YearBounds
{
new_year
next_new_year
.
.
}
=
year_bounds
;
let
(
month_lengths
leap_month
)
=
chinese_based
:
:
month_structure_for_year
:
:
<
CB
>
(
new_year
next_new_year
)
;
let
ny_offset
=
new_year
-
calendrical_calculations
:
:
iso
:
:
fixed_from_iso
(
related_iso
1
1
)
;
Self
{
packed_data
:
PackedChineseBasedYearInfo
:
:
new
(
month_lengths
leap_month
ny_offset
)
related_iso
}
}
pub
(
crate
)
fn
new_year
(
self
)
-
>
RataDie
{
calendrical_calculations
:
:
iso
:
:
fixed_from_iso
(
self
.
related_iso
1
1
)
+
self
.
packed_data
.
ny_offset
(
)
as
i64
}
fn
next_new_year
(
self
)
-
>
RataDie
{
self
.
new_year
(
)
+
i64
:
:
from
(
self
.
days_in_year
(
)
)
}
fn
leap_month
(
self
)
-
>
Option
<
u8
>
{
self
.
packed_data
.
leap_month
(
)
}
fn
last_day_of_previous_month
(
self
month
:
u8
)
-
>
u16
{
debug_assert
!
(
(
1
.
.
=
13
)
.
contains
(
&
month
)
"
Month
out
of
bounds
!
"
)
;
if
month
=
=
1
{
0
}
else
{
self
.
packed_data
.
last_day_of_month
(
month
-
1
)
}
}
fn
days_in_year
(
self
)
-
>
u16
{
self
.
last_day_of_month
(
self
.
months_in_year
(
)
)
}
fn
months_in_year
(
self
)
-
>
u8
{
if
self
.
leap_month
(
)
.
is_some
(
)
{
13
}
else
{
12
}
}
fn
last_day_of_month
(
self
month
:
u8
)
-
>
u16
{
debug_assert
!
(
(
1
.
.
=
13
)
.
contains
(
&
month
)
"
Month
out
of
bounds
!
"
)
;
self
.
packed_data
.
last_day_of_month
(
month
)
}
fn
days_in_month
(
self
month
:
u8
)
-
>
u8
{
if
self
.
packed_data
.
month_has_30_days
(
month
)
{
30
}
else
{
29
}
}
pub
(
crate
)
fn
md_from_rd
(
self
rd
:
RataDie
)
-
>
(
u8
u8
)
{
debug_assert
!
(
rd
<
self
.
next_new_year
(
)
"
Stored
date
{
rd
:
?
}
out
of
bounds
!
"
)
;
let
day_of_year
=
u16
:
:
try_from
(
rd
-
self
.
new_year
(
)
+
1
)
;
debug_assert
!
(
day_of_year
.
is_ok
(
)
"
Somehow
got
a
very
large
year
in
data
"
)
;
let
day_of_year
=
day_of_year
.
unwrap_or
(
1
)
;
let
mut
month
=
1
;
for
iter_month
in
1
.
.
=
13
{
month
=
iter_month
;
if
self
.
last_day_of_month
(
iter_month
)
>
=
day_of_year
{
break
;
}
}
debug_assert
!
(
(
1
.
.
=
13
)
.
contains
(
&
month
)
"
Month
out
of
bounds
!
"
)
;
debug_assert
!
(
month
<
13
|
|
self
.
leap_month
(
)
.
is_some
(
)
"
Cannot
have
13
months
in
a
non
-
leap
year
!
"
)
;
let
day_before_month_start
=
self
.
last_day_of_previous_month
(
month
)
;
let
day_of_month
=
day_of_year
-
day_before_month_start
;
let
day_of_month
=
u8
:
:
try_from
(
day_of_month
)
;
debug_assert
!
(
day_of_month
.
is_ok
(
)
"
Month
too
big
!
"
)
;
let
day_of_month
=
day_of_month
.
unwrap_or
(
1
)
;
(
month
day_of_month
)
}
pub
(
crate
)
fn
rd_from_md
(
self
month
:
u8
day
:
u8
)
-
>
RataDie
{
self
.
new_year
(
)
+
self
.
day_of_year
(
month
day
)
as
i64
-
1
}
pub
(
crate
)
fn
day_of_year
(
self
month
:
u8
day
:
u8
)
-
>
u16
{
self
.
last_day_of_previous_month
(
month
)
+
day
as
u16
}
pub
(
crate
)
fn
month
(
self
month
:
u8
)
-
>
MonthInfo
{
let
leap_month
=
self
.
leap_month
(
)
.
unwrap_or
(
14
)
;
let
code_inner
=
if
leap_month
=
=
month
{
debug_assert
!
(
(
2
.
.
=
13
)
.
contains
(
&
month
)
)
;
match
month
{
2
=
>
tinystr
!
(
4
"
M01L
"
)
3
=
>
tinystr
!
(
4
"
M02L
"
)
4
=
>
tinystr
!
(
4
"
M03L
"
)
5
=
>
tinystr
!
(
4
"
M04L
"
)
6
=
>
tinystr
!
(
4
"
M05L
"
)
7
=
>
tinystr
!
(
4
"
M06L
"
)
8
=
>
tinystr
!
(
4
"
M07L
"
)
9
=
>
tinystr
!
(
4
"
M08L
"
)
10
=
>
tinystr
!
(
4
"
M09L
"
)
11
=
>
tinystr
!
(
4
"
M10L
"
)
12
=
>
tinystr
!
(
4
"
M11L
"
)
13
=
>
tinystr
!
(
4
"
M12L
"
)
_
=
>
tinystr
!
(
4
"
und
"
)
}
}
else
{
let
mut
adjusted_ordinal
=
month
;
if
month
>
leap_month
{
debug_assert
!
(
(
2
.
.
=
13
)
.
contains
(
&
month
)
)
;
adjusted_ordinal
-
=
1
;
}
debug_assert
!
(
(
1
.
.
=
12
)
.
contains
(
&
adjusted_ordinal
)
)
;
match
adjusted_ordinal
{
1
=
>
tinystr
!
(
4
"
M01
"
)
2
=
>
tinystr
!
(
4
"
M02
"
)
3
=
>
tinystr
!
(
4
"
M03
"
)
4
=
>
tinystr
!
(
4
"
M04
"
)
5
=
>
tinystr
!
(
4
"
M05
"
)
6
=
>
tinystr
!
(
4
"
M06
"
)
7
=
>
tinystr
!
(
4
"
M07
"
)
8
=
>
tinystr
!
(
4
"
M08
"
)
9
=
>
tinystr
!
(
4
"
M09
"
)
10
=
>
tinystr
!
(
4
"
M10
"
)
11
=
>
tinystr
!
(
4
"
M11
"
)
12
=
>
tinystr
!
(
4
"
M12
"
)
_
=
>
tinystr
!
(
4
"
und
"
)
}
}
;
let
code
=
MonthCode
(
code_inner
)
;
MonthInfo
{
ordinal
:
month
standard_code
:
code
formatting_code
:
code
}
}
pub
(
crate
)
fn
validate_md
(
self
month
:
u8
day
:
u8
)
-
>
Result
<
(
)
DateError
>
{
let
max_month
=
self
.
months_in_year
(
)
;
if
month
=
=
0
|
|
!
(
1
.
.
=
max_month
)
.
contains
(
&
month
)
{
return
Err
(
DateError
:
:
Range
{
field
:
"
month
"
value
:
month
as
i32
min
:
1
max
:
max_month
as
i32
}
)
;
}
let
max_day
=
self
.
days_in_month
(
month
)
;
if
day
=
=
0
|
|
day
>
max_day
{
return
Err
(
DateError
:
:
Range
{
field
:
"
day
"
value
:
day
as
i32
min
:
1
max
:
max_day
as
i32
}
)
;
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
parse_month_code
(
self
code
:
MonthCode
)
-
>
Option
<
u8
>
{
let
leap_month
=
self
.
leap_month
(
)
.
unwrap_or
(
14
)
;
if
code
.
0
.
len
(
)
<
3
{
return
None
;
}
let
bytes
=
code
.
0
.
all_bytes
(
)
;
if
bytes
[
0
]
!
=
b
'
M
'
{
return
None
;
}
if
code
.
0
.
len
(
)
=
=
4
&
&
bytes
[
3
]
!
=
b
'
L
'
{
return
None
;
}
let
mut
unadjusted
=
0
;
if
bytes
[
1
]
=
=
b
'
0
'
{
if
bytes
[
2
]
>
=
b
'
1
'
&
&
bytes
[
2
]
<
=
b
'
9
'
{
unadjusted
=
bytes
[
2
]
-
b
'
0
'
;
}
}
else
if
bytes
[
1
]
=
=
b
'
1
'
&
&
bytes
[
2
]
>
=
b
'
0
'
&
&
bytes
[
2
]
<
=
b
'
2
'
{
unadjusted
=
10
+
bytes
[
2
]
-
b
'
0
'
;
}
if
bytes
[
3
]
=
=
b
'
L
'
{
if
unadjusted
+
1
!
=
leap_month
{
return
None
;
}
else
{
return
Some
(
unadjusted
+
1
)
;
}
}
if
unadjusted
!
=
0
{
if
unadjusted
+
1
>
leap_month
{
return
Some
(
unadjusted
+
1
)
;
}
else
{
return
Some
(
unadjusted
)
;
}
}
None
}
}
impl
<
C
:
ChineseBasedWithDataLoading
>
CalendarArithmetic
for
C
{
type
YearInfo
=
ChineseBasedYearInfo
;
fn
days_in_provided_month
(
year
:
ChineseBasedYearInfo
month
:
u8
)
-
>
u8
{
year
.
days_in_month
(
month
)
}
fn
months_in_provided_year
(
year
:
ChineseBasedYearInfo
)
-
>
u8
{
year
.
months_in_year
(
)
}
fn
provided_year_is_leap
(
year
:
ChineseBasedYearInfo
)
-
>
bool
{
year
.
leap_month
(
)
.
is_some
(
)
}
fn
last_month_day_in_provided_year
(
year
:
ChineseBasedYearInfo
)
-
>
(
u8
u8
)
{
if
year
.
leap_month
(
)
.
is_some
(
)
{
(
13
year
.
days_in_month
(
13
)
)
}
else
{
(
12
year
.
days_in_month
(
12
)
)
}
}
fn
days_in_provided_year
(
year
:
ChineseBasedYearInfo
)
-
>
u16
{
year
.
days_in_year
(
)
}
}
#
[
cfg
(
feature
=
"
datagen
"
)
]
impl
ChineseBasedCache
<
'
_
>
{
pub
fn
compute_for
<
CB
:
ChineseBased
>
(
related_isos
:
core
:
:
ops
:
:
Range
<
i32
>
)
-
>
Self
{
ChineseBasedCache
{
first_related_iso_year
:
related_isos
.
start
data
:
related_isos
.
map
(
|
related_iso
|
ChineseBasedYearInfo
:
:
compute
:
:
<
CB
>
(
related_iso
)
.
packed_data
)
.
collect
(
)
}
}
}
