use
integer
:
:
Integer
;
use
traits
:
:
Zero
;
use
biguint
:
:
BigUint
;
struct
MontyReducer
<
'
a
>
{
n
:
&
'
a
BigUint
n0inv
:
u32
}
fn
inv_mod_u32
(
num
:
u32
)
-
>
u32
{
assert
!
(
num
%
2
!
=
0
)
;
let
mut
a
:
i64
=
i64
:
:
from
(
num
)
;
let
mut
b
:
i64
=
i64
:
:
from
(
u32
:
:
max_value
(
)
)
+
1
;
let
mut
u
=
1
;
let
mut
w
=
0
;
while
b
!
=
0
{
let
q
=
a
/
b
;
let
r
=
a
%
b
;
a
=
b
;
b
=
r
;
let
m
=
u
-
w
*
q
;
u
=
w
;
w
=
m
;
}
assert
!
(
a
=
=
1
)
;
u
as
u32
}
impl
<
'
a
>
MontyReducer
<
'
a
>
{
fn
new
(
n
:
&
'
a
BigUint
)
-
>
Self
{
let
n0inv
=
inv_mod_u32
(
n
.
data
[
0
]
)
;
MontyReducer
{
n
:
n
n0inv
:
n0inv
}
}
}
fn
monty_redc
(
a
:
BigUint
mr
:
&
MontyReducer
)
-
>
BigUint
{
let
mut
c
=
a
.
data
;
let
n
=
&
mr
.
n
.
data
;
let
n_size
=
n
.
len
(
)
;
c
.
resize
(
2
*
n_size
+
2
0
)
;
let
mu
=
0u32
.
wrapping_sub
(
mr
.
n0inv
)
;
for
i
in
0
.
.
n_size
{
let
q_i
=
c
[
i
]
.
wrapping_mul
(
mu
)
;
super
:
:
algorithms
:
:
mac_digit
(
&
mut
c
[
i
.
.
]
n
q_i
)
;
}
let
ret
=
BigUint
:
:
new
(
c
[
n_size
.
.
]
.
to_vec
(
)
)
;
if
&
ret
<
mr
.
n
{
ret
}
else
{
ret
-
mr
.
n
}
}
fn
monty_mult
(
a
:
BigUint
b
:
&
BigUint
mr
:
&
MontyReducer
)
-
>
BigUint
{
monty_redc
(
a
*
b
mr
)
}
fn
monty_sqr
(
a
:
BigUint
mr
:
&
MontyReducer
)
-
>
BigUint
{
monty_redc
(
&
a
*
&
a
mr
)
}
pub
fn
monty_modpow
(
a
:
&
BigUint
exp
:
&
BigUint
modulus
:
&
BigUint
)
-
>
BigUint
{
let
mr
=
MontyReducer
:
:
new
(
modulus
)
;
let
mut
v
=
vec
!
[
0
;
modulus
.
data
.
len
(
)
]
;
v
.
push
(
1
)
;
let
r
=
BigUint
:
:
new
(
v
)
;
let
mut
apri
=
a
*
&
r
%
modulus
;
let
mut
ans
=
&
r
%
modulus
;
let
mut
e
=
exp
.
clone
(
)
;
while
!
e
.
is_zero
(
)
{
if
e
.
is_odd
(
)
{
ans
=
monty_mult
(
ans
&
apri
&
mr
)
;
}
apri
=
monty_sqr
(
apri
&
mr
)
;
e
=
e
>
>
1
;
}
monty_redc
(
ans
&
mr
)
}
