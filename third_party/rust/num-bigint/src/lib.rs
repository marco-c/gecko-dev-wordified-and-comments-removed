#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
num
-
bigint
/
0
.
1
"
)
]
#
[
cfg
(
any
(
feature
=
"
rand
"
test
)
)
]
extern
crate
rand
;
#
[
cfg
(
feature
=
"
rustc
-
serialize
"
)
]
extern
crate
rustc_serialize
;
#
[
cfg
(
feature
=
"
serde
"
)
]
extern
crate
serde
;
extern
crate
num_integer
as
integer
;
extern
crate
num_traits
as
traits
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
num
:
:
ParseIntError
;
use
std
:
:
fmt
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
type
UsizePromotion
=
u32
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
type
UsizePromotion
=
u64
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
type
IsizePromotion
=
i32
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
type
IsizePromotion
=
i64
;
#
[
derive
(
Debug
PartialEq
)
]
pub
enum
ParseBigIntError
{
ParseInt
(
ParseIntError
)
Other
}
impl
fmt
:
:
Display
for
ParseBigIntError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
&
ParseBigIntError
:
:
ParseInt
(
ref
e
)
=
>
e
.
fmt
(
f
)
&
ParseBigIntError
:
:
Other
=
>
"
failed
to
parse
provided
string
"
.
fmt
(
f
)
}
}
}
impl
Error
for
ParseBigIntError
{
fn
description
(
&
self
)
-
>
&
str
{
"
failed
to
parse
bigint
/
biguint
"
}
}
impl
From
<
ParseIntError
>
for
ParseBigIntError
{
fn
from
(
err
:
ParseIntError
)
-
>
ParseBigIntError
{
ParseBigIntError
:
:
ParseInt
(
err
)
}
}
#
[
cfg
(
test
)
]
use
std
:
:
hash
;
#
[
cfg
(
test
)
]
fn
hash
<
T
:
hash
:
:
Hash
>
(
x
:
&
T
)
-
>
u64
{
use
std
:
:
hash
:
:
{
BuildHasher
Hasher
}
;
use
std
:
:
collections
:
:
hash_map
:
:
RandomState
;
let
mut
hasher
=
<
RandomState
as
BuildHasher
>
:
:
Hasher
:
:
new
(
)
;
x
.
hash
(
&
mut
hasher
)
;
hasher
.
finish
(
)
}
#
[
macro_use
]
mod
macros
;
mod
biguint
;
mod
bigint
;
pub
use
biguint
:
:
BigUint
;
pub
use
biguint
:
:
ToBigUint
;
pub
use
biguint
:
:
big_digit
;
pub
use
biguint
:
:
big_digit
:
:
{
BigDigit
DoubleBigDigit
ZERO_BIG_DIGIT
}
;
pub
use
bigint
:
:
Sign
;
pub
use
bigint
:
:
BigInt
;
pub
use
bigint
:
:
ToBigInt
;
pub
use
bigint
:
:
RandBigInt
;
