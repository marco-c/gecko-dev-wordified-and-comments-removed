#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
num
-
bigint
/
0
.
3
"
)
]
#
!
[
no_std
]
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
macro_use
]
extern
crate
std
;
#
[
cfg
(
feature
=
"
std
"
)
]
mod
std_alloc
{
pub
(
crate
)
use
std
:
:
borrow
:
:
Cow
;
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
pub
(
crate
)
use
std
:
:
boxed
:
:
Box
;
pub
(
crate
)
use
std
:
:
string
:
:
String
;
pub
(
crate
)
use
std
:
:
vec
:
:
Vec
;
}
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
#
[
macro_use
]
extern
crate
alloc
;
#
[
cfg
(
not
(
feature
=
"
std
"
)
)
]
mod
std_alloc
{
pub
(
crate
)
use
alloc
:
:
borrow
:
:
Cow
;
#
[
cfg
(
feature
=
"
quickcheck
"
)
]
pub
(
crate
)
use
alloc
:
:
boxed
:
:
Box
;
pub
(
crate
)
use
alloc
:
:
string
:
:
String
;
pub
(
crate
)
use
alloc
:
:
vec
:
:
Vec
;
}
use
core
:
:
fmt
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
error
:
:
Error
;
#
[
macro_use
]
mod
macros
;
mod
bigint
;
mod
biguint
;
#
[
cfg
(
feature
=
"
rand
"
)
]
mod
bigrand
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
type
UsizePromotion
=
u32
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
type
UsizePromotion
=
u64
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
type
IsizePromotion
=
i32
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
type
IsizePromotion
=
i64
;
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
pub
struct
ParseBigIntError
{
kind
:
BigIntErrorKind
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
)
]
enum
BigIntErrorKind
{
Empty
InvalidDigit
}
impl
ParseBigIntError
{
fn
__description
(
&
self
)
-
>
&
str
{
use
crate
:
:
BigIntErrorKind
:
:
*
;
match
self
.
kind
{
Empty
=
>
"
cannot
parse
integer
from
empty
string
"
InvalidDigit
=
>
"
invalid
digit
found
in
string
"
}
}
fn
empty
(
)
-
>
Self
{
ParseBigIntError
{
kind
:
BigIntErrorKind
:
:
Empty
}
}
fn
invalid
(
)
-
>
Self
{
ParseBigIntError
{
kind
:
BigIntErrorKind
:
:
InvalidDigit
}
}
}
impl
fmt
:
:
Display
for
ParseBigIntError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
self
.
__description
(
)
.
fmt
(
f
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
Error
for
ParseBigIntError
{
fn
description
(
&
self
)
-
>
&
str
{
self
.
__description
(
)
}
}
#
[
cfg
(
has_try_from
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
pub
struct
TryFromBigIntError
<
T
>
{
original
:
T
}
#
[
cfg
(
has_try_from
)
]
impl
<
T
>
TryFromBigIntError
<
T
>
{
fn
new
(
original
:
T
)
-
>
Self
{
TryFromBigIntError
{
original
}
}
fn
__description
(
&
self
)
-
>
&
str
{
"
out
of
range
conversion
regarding
big
integer
attempted
"
}
pub
fn
into_original
(
self
)
-
>
T
{
self
.
original
}
}
#
[
cfg
(
all
(
feature
=
"
std
"
has_try_from
)
)
]
impl
<
T
>
std
:
:
error
:
:
Error
for
TryFromBigIntError
<
T
>
where
T
:
fmt
:
:
Debug
{
fn
description
(
&
self
)
-
>
&
str
{
self
.
__description
(
)
}
}
#
[
cfg
(
has_try_from
)
]
impl
<
T
>
fmt
:
:
Display
for
TryFromBigIntError
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
__description
(
)
.
fmt
(
f
)
}
}
pub
use
crate
:
:
biguint
:
:
BigUint
;
pub
use
crate
:
:
biguint
:
:
ToBigUint
;
pub
use
crate
:
:
bigint
:
:
BigInt
;
pub
use
crate
:
:
bigint
:
:
Sign
;
pub
use
crate
:
:
bigint
:
:
ToBigInt
;
#
[
cfg
(
feature
=
"
rand
"
)
]
pub
use
crate
:
:
bigrand
:
:
{
RandBigInt
RandomBits
UniformBigInt
UniformBigUint
}
;
mod
big_digit
{
#
[
cfg
(
not
(
u64_digit
)
)
]
pub
(
crate
)
type
BigDigit
=
u32
;
#
[
cfg
(
u64_digit
)
]
pub
(
crate
)
type
BigDigit
=
u64
;
#
[
cfg
(
not
(
u64_digit
)
)
]
pub
(
crate
)
type
DoubleBigDigit
=
u64
;
#
[
cfg
(
u64_digit
)
]
pub
(
crate
)
type
DoubleBigDigit
=
u128
;
#
[
cfg
(
not
(
u64_digit
)
)
]
pub
(
crate
)
type
SignedDoubleBigDigit
=
i64
;
#
[
cfg
(
u64_digit
)
]
pub
(
crate
)
type
SignedDoubleBigDigit
=
i128
;
#
[
cfg
(
not
(
u64_digit
)
)
]
pub
(
crate
)
const
BITS
:
u8
=
32
;
#
[
cfg
(
u64_digit
)
]
pub
(
crate
)
const
BITS
:
u8
=
64
;
pub
(
crate
)
const
HALF_BITS
:
u8
=
BITS
/
2
;
pub
(
crate
)
const
HALF
:
BigDigit
=
(
1
<
<
HALF_BITS
)
-
1
;
const
LO_MASK
:
DoubleBigDigit
=
(
1
<
<
BITS
)
-
1
;
#
[
inline
]
fn
get_hi
(
n
:
DoubleBigDigit
)
-
>
BigDigit
{
(
n
>
>
BITS
)
as
BigDigit
}
#
[
inline
]
fn
get_lo
(
n
:
DoubleBigDigit
)
-
>
BigDigit
{
(
n
&
LO_MASK
)
as
BigDigit
}
#
[
inline
]
pub
(
crate
)
fn
from_doublebigdigit
(
n
:
DoubleBigDigit
)
-
>
(
BigDigit
BigDigit
)
{
(
get_hi
(
n
)
get_lo
(
n
)
)
}
#
[
inline
]
pub
(
crate
)
fn
to_doublebigdigit
(
hi
:
BigDigit
lo
:
BigDigit
)
-
>
DoubleBigDigit
{
DoubleBigDigit
:
:
from
(
lo
)
|
(
DoubleBigDigit
:
:
from
(
hi
)
<
<
BITS
)
}
}
