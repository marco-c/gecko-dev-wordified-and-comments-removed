use
super
:
:
addition
:
:
__add2
;
use
super
:
:
{
cmp_slice
BigUint
}
;
use
crate
:
:
big_digit
:
:
{
self
BigDigit
DoubleBigDigit
}
;
use
crate
:
:
UsizePromotion
;
use
core
:
:
cmp
:
:
Ordering
:
:
{
Equal
Greater
Less
}
;
use
core
:
:
mem
;
use
core
:
:
ops
:
:
{
Div
DivAssign
Rem
RemAssign
}
;
use
num_integer
:
:
Integer
;
use
num_traits
:
:
{
CheckedDiv
CheckedEuclid
Euclid
One
ToPrimitive
Zero
}
;
pub
(
super
)
const
FAST_DIV_WIDE
:
bool
=
cfg
!
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
;
#
[
cfg
(
any
(
miri
not
(
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
)
]
#
[
inline
]
fn
div_wide
(
hi
:
BigDigit
lo
:
BigDigit
divisor
:
BigDigit
)
-
>
(
BigDigit
BigDigit
)
{
debug_assert
!
(
hi
<
divisor
)
;
let
lhs
=
big_digit
:
:
to_doublebigdigit
(
hi
lo
)
;
let
rhs
=
DoubleBigDigit
:
:
from
(
divisor
)
;
(
(
lhs
/
rhs
)
as
BigDigit
(
lhs
%
rhs
)
as
BigDigit
)
}
#
[
cfg
(
all
(
not
(
miri
)
any
(
target_arch
=
"
x86
"
target_arch
=
"
x86_64
"
)
)
)
]
#
[
inline
]
fn
div_wide
(
hi
:
BigDigit
lo
:
BigDigit
divisor
:
BigDigit
)
-
>
(
BigDigit
BigDigit
)
{
debug_assert
!
(
hi
<
divisor
)
;
unsafe
{
let
(
div
rem
)
;
cfg_digit
!
(
macro_rules
!
div
{
(
)
=
>
{
"
div
{
0
:
e
}
"
}
;
}
macro_rules
!
div
{
(
)
=
>
{
"
div
{
0
:
r
}
"
}
;
}
)
;
core
:
:
arch
:
:
asm
!
(
div
!
(
)
in
(
reg
)
divisor
inout
(
"
dx
"
)
hi
=
>
rem
inout
(
"
ax
"
)
lo
=
>
div
options
(
pure
nomem
nostack
)
)
;
(
div
rem
)
}
}
#
[
inline
]
fn
div_half
(
rem
:
BigDigit
digit
:
BigDigit
divisor
:
BigDigit
)
-
>
(
BigDigit
BigDigit
)
{
use
crate
:
:
big_digit
:
:
{
HALF
HALF_BITS
}
;
debug_assert
!
(
rem
<
divisor
&
&
divisor
<
=
HALF
)
;
let
(
hi
rem
)
=
(
(
rem
<
<
HALF_BITS
)
|
(
digit
>
>
HALF_BITS
)
)
.
div_rem
(
&
divisor
)
;
let
(
lo
rem
)
=
(
(
rem
<
<
HALF_BITS
)
|
(
digit
&
HALF
)
)
.
div_rem
(
&
divisor
)
;
(
(
hi
<
<
HALF_BITS
)
|
lo
rem
)
}
#
[
inline
]
pub
(
super
)
fn
div_rem_digit
(
mut
a
:
BigUint
b
:
BigDigit
)
-
>
(
BigUint
BigDigit
)
{
if
b
=
=
0
{
panic
!
(
"
attempt
to
divide
by
zero
"
)
}
let
mut
rem
=
0
;
if
!
FAST_DIV_WIDE
&
&
b
<
=
big_digit
:
:
HALF
{
for
d
in
a
.
data
.
iter_mut
(
)
.
rev
(
)
{
let
(
q
r
)
=
div_half
(
rem
*
d
b
)
;
*
d
=
q
;
rem
=
r
;
}
}
else
{
for
d
in
a
.
data
.
iter_mut
(
)
.
rev
(
)
{
let
(
q
r
)
=
div_wide
(
rem
*
d
b
)
;
*
d
=
q
;
rem
=
r
;
}
}
(
a
.
normalized
(
)
rem
)
}
#
[
inline
]
fn
rem_digit
(
a
:
&
BigUint
b
:
BigDigit
)
-
>
BigDigit
{
if
b
=
=
0
{
panic
!
(
"
attempt
to
divide
by
zero
"
)
}
let
mut
rem
=
0
;
if
!
FAST_DIV_WIDE
&
&
b
<
=
big_digit
:
:
HALF
{
for
&
digit
in
a
.
data
.
iter
(
)
.
rev
(
)
{
let
(
_
r
)
=
div_half
(
rem
digit
b
)
;
rem
=
r
;
}
}
else
{
for
&
digit
in
a
.
data
.
iter
(
)
.
rev
(
)
{
let
(
_
r
)
=
div_wide
(
rem
digit
b
)
;
rem
=
r
;
}
}
rem
}
fn
sub_mul_digit_same_len
(
a
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
c
:
BigDigit
)
-
>
BigDigit
{
debug_assert
!
(
a
.
len
(
)
=
=
b
.
len
(
)
)
;
let
mut
offset_carry
=
big_digit
:
:
MAX
;
for
(
x
y
)
in
a
.
iter_mut
(
)
.
zip
(
b
)
{
let
offset_sum
=
big_digit
:
:
to_doublebigdigit
(
big_digit
:
:
MAX
*
x
)
-
big_digit
:
:
MAX
as
DoubleBigDigit
+
offset_carry
as
DoubleBigDigit
-
*
y
as
DoubleBigDigit
*
c
as
DoubleBigDigit
;
let
(
new_offset_carry
new_x
)
=
big_digit
:
:
from_doublebigdigit
(
offset_sum
)
;
offset_carry
=
new_offset_carry
;
*
x
=
new_x
;
}
big_digit
:
:
MAX
-
offset_carry
}
fn
div_rem
(
mut
u
:
BigUint
mut
d
:
BigUint
)
-
>
(
BigUint
BigUint
)
{
if
d
.
is_zero
(
)
{
panic
!
(
"
attempt
to
divide
by
zero
"
)
}
if
u
.
is_zero
(
)
{
return
(
BigUint
:
:
ZERO
BigUint
:
:
ZERO
)
;
}
if
d
.
data
.
len
(
)
=
=
1
{
if
d
.
data
=
=
[
1
]
{
return
(
u
BigUint
:
:
ZERO
)
;
}
let
(
div
rem
)
=
div_rem_digit
(
u
d
.
data
[
0
]
)
;
d
.
data
.
clear
(
)
;
d
+
=
rem
;
return
(
div
d
)
;
}
match
u
.
cmp
(
&
d
)
{
Less
=
>
return
(
BigUint
:
:
ZERO
u
)
Equal
=
>
{
u
.
set_one
(
)
;
return
(
u
BigUint
:
:
ZERO
)
;
}
Greater
=
>
{
}
}
let
shift
=
d
.
data
.
last
(
)
.
unwrap
(
)
.
leading_zeros
(
)
as
usize
;
if
shift
=
=
0
{
div_rem_core
(
u
&
d
.
data
)
}
else
{
let
(
q
r
)
=
div_rem_core
(
u
<
<
shift
&
(
d
<
<
shift
)
.
data
)
;
(
q
r
>
>
shift
)
}
}
pub
(
super
)
fn
div_rem_ref
(
u
:
&
BigUint
d
:
&
BigUint
)
-
>
(
BigUint
BigUint
)
{
if
d
.
is_zero
(
)
{
panic
!
(
"
attempt
to
divide
by
zero
"
)
}
if
u
.
is_zero
(
)
{
return
(
BigUint
:
:
ZERO
BigUint
:
:
ZERO
)
;
}
if
d
.
data
.
len
(
)
=
=
1
{
if
d
.
data
=
=
[
1
]
{
return
(
u
.
clone
(
)
BigUint
:
:
ZERO
)
;
}
let
(
div
rem
)
=
div_rem_digit
(
u
.
clone
(
)
d
.
data
[
0
]
)
;
return
(
div
rem
.
into
(
)
)
;
}
match
u
.
cmp
(
d
)
{
Less
=
>
return
(
BigUint
:
:
ZERO
u
.
clone
(
)
)
Equal
=
>
return
(
One
:
:
one
(
)
BigUint
:
:
ZERO
)
Greater
=
>
{
}
}
let
shift
=
d
.
data
.
last
(
)
.
unwrap
(
)
.
leading_zeros
(
)
as
usize
;
if
shift
=
=
0
{
div_rem_core
(
u
.
clone
(
)
&
d
.
data
)
}
else
{
let
(
q
r
)
=
div_rem_core
(
u
<
<
shift
&
(
d
<
<
shift
)
.
data
)
;
(
q
r
>
>
shift
)
}
}
fn
div_rem_core
(
mut
a
:
BigUint
b
:
&
[
BigDigit
]
)
-
>
(
BigUint
BigUint
)
{
debug_assert
!
(
a
.
data
.
len
(
)
>
=
b
.
len
(
)
&
&
b
.
len
(
)
>
1
)
;
debug_assert
!
(
b
.
last
(
)
.
unwrap
(
)
.
leading_zeros
(
)
=
=
0
)
;
let
mut
a0
=
0
;
let
b0
=
b
[
b
.
len
(
)
-
1
]
;
let
b1
=
b
[
b
.
len
(
)
-
2
]
;
let
q_len
=
a
.
data
.
len
(
)
-
b
.
len
(
)
+
1
;
let
mut
q
=
BigUint
{
data
:
vec
!
[
0
;
q_len
]
}
;
for
j
in
(
0
.
.
q_len
)
.
rev
(
)
{
debug_assert
!
(
a
.
data
.
len
(
)
=
=
b
.
len
(
)
+
j
)
;
let
a1
=
*
a
.
data
.
last
(
)
.
unwrap
(
)
;
let
a2
=
a
.
data
[
a
.
data
.
len
(
)
-
2
]
;
let
(
mut
q0
mut
r
)
=
if
a0
<
b0
{
let
(
q0
r
)
=
div_wide
(
a0
a1
b0
)
;
(
q0
r
as
DoubleBigDigit
)
}
else
{
debug_assert
!
(
a0
=
=
b0
)
;
(
big_digit
:
:
MAX
a0
as
DoubleBigDigit
+
a1
as
DoubleBigDigit
)
}
;
while
r
<
=
big_digit
:
:
MAX
as
DoubleBigDigit
&
&
big_digit
:
:
to_doublebigdigit
(
r
as
BigDigit
a2
)
<
q0
as
DoubleBigDigit
*
b1
as
DoubleBigDigit
{
q0
-
=
1
;
r
+
=
b0
as
DoubleBigDigit
;
}
let
mut
borrow
=
sub_mul_digit_same_len
(
&
mut
a
.
data
[
j
.
.
]
b
q0
)
;
if
borrow
>
a0
{
q0
-
=
1
;
borrow
-
=
__add2
(
&
mut
a
.
data
[
j
.
.
]
b
)
;
}
debug_assert
!
(
borrow
=
=
a0
)
;
q
.
data
[
j
]
=
q0
;
a0
=
a
.
data
.
pop
(
)
.
unwrap
(
)
;
}
a
.
data
.
push
(
a0
)
;
a
.
normalize
(
)
;
debug_assert_eq
!
(
cmp_slice
(
&
a
.
data
b
)
Less
)
;
(
q
.
normalized
(
)
a
)
}
forward_val_ref_binop
!
(
impl
Div
for
BigUint
div
)
;
forward_ref_val_binop
!
(
impl
Div
for
BigUint
div
)
;
forward_val_assign
!
(
impl
DivAssign
for
BigUint
div_assign
)
;
impl
Div
<
BigUint
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
div
(
self
other
:
BigUint
)
-
>
BigUint
{
let
(
q
_
)
=
div_rem
(
self
other
)
;
q
}
}
impl
Div
<
&
BigUint
>
for
&
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
div
(
self
other
:
&
BigUint
)
-
>
BigUint
{
let
(
q
_
)
=
self
.
div_rem
(
other
)
;
q
}
}
impl
DivAssign
<
&
BigUint
>
for
BigUint
{
#
[
inline
]
fn
div_assign
(
&
mut
self
other
:
&
BigUint
)
{
*
self
=
&
*
self
/
other
;
}
}
promote_unsigned_scalars
!
(
impl
Div
for
BigUint
div
)
;
promote_unsigned_scalars_assign
!
(
impl
DivAssign
for
BigUint
div_assign
)
;
forward_all_scalar_binop_to_val_val
!
(
impl
Div
<
u32
>
for
BigUint
div
)
;
forward_all_scalar_binop_to_val_val
!
(
impl
Div
<
u64
>
for
BigUint
div
)
;
forward_all_scalar_binop_to_val_val
!
(
impl
Div
<
u128
>
for
BigUint
div
)
;
impl
Div
<
u32
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
div
(
self
other
:
u32
)
-
>
BigUint
{
let
(
q
_
)
=
div_rem_digit
(
self
other
as
BigDigit
)
;
q
}
}
impl
DivAssign
<
u32
>
for
BigUint
{
#
[
inline
]
fn
div_assign
(
&
mut
self
other
:
u32
)
{
*
self
=
&
*
self
/
other
;
}
}
impl
Div
<
BigUint
>
for
u32
{
type
Output
=
BigUint
;
#
[
inline
]
fn
div
(
self
other
:
BigUint
)
-
>
BigUint
{
match
other
.
data
.
len
(
)
{
0
=
>
panic
!
(
"
attempt
to
divide
by
zero
"
)
1
=
>
From
:
:
from
(
self
as
BigDigit
/
other
.
data
[
0
]
)
_
=
>
BigUint
:
:
ZERO
}
}
}
impl
Div
<
u64
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
div
(
self
other
:
u64
)
-
>
BigUint
{
let
(
q
_
)
=
div_rem
(
self
From
:
:
from
(
other
)
)
;
q
}
}
impl
DivAssign
<
u64
>
for
BigUint
{
#
[
inline
]
fn
div_assign
(
&
mut
self
other
:
u64
)
{
let
temp
=
mem
:
:
replace
(
self
Self
:
:
ZERO
)
;
*
self
=
temp
/
other
;
}
}
impl
Div
<
BigUint
>
for
u64
{
type
Output
=
BigUint
;
cfg_digit
!
(
#
[
inline
]
fn
div
(
self
other
:
BigUint
)
-
>
BigUint
{
match
other
.
data
.
len
(
)
{
0
=
>
panic
!
(
"
attempt
to
divide
by
zero
"
)
1
=
>
From
:
:
from
(
self
/
u64
:
:
from
(
other
.
data
[
0
]
)
)
2
=
>
From
:
:
from
(
self
/
big_digit
:
:
to_doublebigdigit
(
other
.
data
[
1
]
other
.
data
[
0
]
)
)
_
=
>
BigUint
:
:
ZERO
}
}
#
[
inline
]
fn
div
(
self
other
:
BigUint
)
-
>
BigUint
{
match
other
.
data
.
len
(
)
{
0
=
>
panic
!
(
"
attempt
to
divide
by
zero
"
)
1
=
>
From
:
:
from
(
self
/
other
.
data
[
0
]
)
_
=
>
BigUint
:
:
ZERO
}
}
)
;
}
impl
Div
<
u128
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
div
(
self
other
:
u128
)
-
>
BigUint
{
let
(
q
_
)
=
div_rem
(
self
From
:
:
from
(
other
)
)
;
q
}
}
impl
DivAssign
<
u128
>
for
BigUint
{
#
[
inline
]
fn
div_assign
(
&
mut
self
other
:
u128
)
{
*
self
=
&
*
self
/
other
;
}
}
impl
Div
<
BigUint
>
for
u128
{
type
Output
=
BigUint
;
cfg_digit
!
(
#
[
inline
]
fn
div
(
self
other
:
BigUint
)
-
>
BigUint
{
use
super
:
:
u32_to_u128
;
match
other
.
data
.
len
(
)
{
0
=
>
panic
!
(
"
attempt
to
divide
by
zero
"
)
1
=
>
From
:
:
from
(
self
/
u128
:
:
from
(
other
.
data
[
0
]
)
)
2
=
>
From
:
:
from
(
self
/
u128
:
:
from
(
big_digit
:
:
to_doublebigdigit
(
other
.
data
[
1
]
other
.
data
[
0
]
)
)
)
3
=
>
From
:
:
from
(
self
/
u32_to_u128
(
0
other
.
data
[
2
]
other
.
data
[
1
]
other
.
data
[
0
]
)
)
4
=
>
From
:
:
from
(
self
/
u32_to_u128
(
other
.
data
[
3
]
other
.
data
[
2
]
other
.
data
[
1
]
other
.
data
[
0
]
)
)
_
=
>
BigUint
:
:
ZERO
}
}
#
[
inline
]
fn
div
(
self
other
:
BigUint
)
-
>
BigUint
{
match
other
.
data
.
len
(
)
{
0
=
>
panic
!
(
"
attempt
to
divide
by
zero
"
)
1
=
>
From
:
:
from
(
self
/
other
.
data
[
0
]
as
u128
)
2
=
>
From
:
:
from
(
self
/
big_digit
:
:
to_doublebigdigit
(
other
.
data
[
1
]
other
.
data
[
0
]
)
)
_
=
>
BigUint
:
:
ZERO
}
}
)
;
}
forward_val_ref_binop
!
(
impl
Rem
for
BigUint
rem
)
;
forward_ref_val_binop
!
(
impl
Rem
for
BigUint
rem
)
;
forward_val_assign
!
(
impl
RemAssign
for
BigUint
rem_assign
)
;
impl
Rem
<
BigUint
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
self
other
:
BigUint
)
-
>
BigUint
{
if
let
Some
(
other
)
=
other
.
to_u32
(
)
{
&
self
%
other
}
else
{
let
(
_
r
)
=
div_rem
(
self
other
)
;
r
}
}
}
impl
Rem
<
&
BigUint
>
for
&
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
self
other
:
&
BigUint
)
-
>
BigUint
{
if
let
Some
(
other
)
=
other
.
to_u32
(
)
{
self
%
other
}
else
{
let
(
_
r
)
=
self
.
div_rem
(
other
)
;
r
}
}
}
impl
RemAssign
<
&
BigUint
>
for
BigUint
{
#
[
inline
]
fn
rem_assign
(
&
mut
self
other
:
&
BigUint
)
{
*
self
=
&
*
self
%
other
;
}
}
promote_unsigned_scalars
!
(
impl
Rem
for
BigUint
rem
)
;
promote_unsigned_scalars_assign
!
(
impl
RemAssign
for
BigUint
rem_assign
)
;
forward_all_scalar_binop_to_ref_val
!
(
impl
Rem
<
u32
>
for
BigUint
rem
)
;
forward_all_scalar_binop_to_val_val
!
(
impl
Rem
<
u64
>
for
BigUint
rem
)
;
forward_all_scalar_binop_to_val_val
!
(
impl
Rem
<
u128
>
for
BigUint
rem
)
;
impl
Rem
<
u32
>
for
&
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
self
other
:
u32
)
-
>
BigUint
{
rem_digit
(
self
other
as
BigDigit
)
.
into
(
)
}
}
impl
RemAssign
<
u32
>
for
BigUint
{
#
[
inline
]
fn
rem_assign
(
&
mut
self
other
:
u32
)
{
*
self
=
&
*
self
%
other
;
}
}
impl
Rem
<
&
BigUint
>
for
u32
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
mut
self
other
:
&
BigUint
)
-
>
BigUint
{
self
%
=
other
;
From
:
:
from
(
self
)
}
}
macro_rules
!
impl_rem_assign_scalar
{
(
scalar
:
ty
to_scalar
:
ident
)
=
>
{
forward_val_assign_scalar
!
(
impl
RemAssign
for
BigUint
scalar
rem_assign
)
;
impl
RemAssign
<
&
BigUint
>
for
scalar
{
#
[
inline
]
fn
rem_assign
(
&
mut
self
other
:
&
BigUint
)
{
*
self
=
match
other
.
to_scalar
(
)
{
None
=
>
*
self
Some
(
0
)
=
>
panic
!
(
"
attempt
to
divide
by
zero
"
)
Some
(
v
)
=
>
*
self
%
v
}
;
}
}
}
}
impl_rem_assign_scalar
!
(
u128
to_u128
)
;
impl_rem_assign_scalar
!
(
usize
to_usize
)
;
impl_rem_assign_scalar
!
(
u64
to_u64
)
;
impl_rem_assign_scalar
!
(
u32
to_u32
)
;
impl_rem_assign_scalar
!
(
u16
to_u16
)
;
impl_rem_assign_scalar
!
(
u8
to_u8
)
;
impl_rem_assign_scalar
!
(
i128
to_i128
)
;
impl_rem_assign_scalar
!
(
isize
to_isize
)
;
impl_rem_assign_scalar
!
(
i64
to_i64
)
;
impl_rem_assign_scalar
!
(
i32
to_i32
)
;
impl_rem_assign_scalar
!
(
i16
to_i16
)
;
impl_rem_assign_scalar
!
(
i8
to_i8
)
;
impl
Rem
<
u64
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
self
other
:
u64
)
-
>
BigUint
{
let
(
_
r
)
=
div_rem
(
self
From
:
:
from
(
other
)
)
;
r
}
}
impl
RemAssign
<
u64
>
for
BigUint
{
#
[
inline
]
fn
rem_assign
(
&
mut
self
other
:
u64
)
{
*
self
=
&
*
self
%
other
;
}
}
impl
Rem
<
BigUint
>
for
u64
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
mut
self
other
:
BigUint
)
-
>
BigUint
{
self
%
=
other
;
From
:
:
from
(
self
)
}
}
impl
Rem
<
u128
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
self
other
:
u128
)
-
>
BigUint
{
let
(
_
r
)
=
div_rem
(
self
From
:
:
from
(
other
)
)
;
r
}
}
impl
RemAssign
<
u128
>
for
BigUint
{
#
[
inline
]
fn
rem_assign
(
&
mut
self
other
:
u128
)
{
*
self
=
&
*
self
%
other
;
}
}
impl
Rem
<
BigUint
>
for
u128
{
type
Output
=
BigUint
;
#
[
inline
]
fn
rem
(
mut
self
other
:
BigUint
)
-
>
BigUint
{
self
%
=
other
;
From
:
:
from
(
self
)
}
}
impl
CheckedDiv
for
BigUint
{
#
[
inline
]
fn
checked_div
(
&
self
v
:
&
BigUint
)
-
>
Option
<
BigUint
>
{
if
v
.
is_zero
(
)
{
return
None
;
}
Some
(
self
.
div
(
v
)
)
}
}
impl
CheckedEuclid
for
BigUint
{
#
[
inline
]
fn
checked_div_euclid
(
&
self
v
:
&
BigUint
)
-
>
Option
<
BigUint
>
{
if
v
.
is_zero
(
)
{
return
None
;
}
Some
(
self
.
div_euclid
(
v
)
)
}
#
[
inline
]
fn
checked_rem_euclid
(
&
self
v
:
&
BigUint
)
-
>
Option
<
BigUint
>
{
if
v
.
is_zero
(
)
{
return
None
;
}
Some
(
self
.
rem_euclid
(
v
)
)
}
fn
checked_div_rem_euclid
(
&
self
v
:
&
Self
)
-
>
Option
<
(
Self
Self
)
>
{
Some
(
self
.
div_rem_euclid
(
v
)
)
}
}
impl
Euclid
for
BigUint
{
#
[
inline
]
fn
div_euclid
(
&
self
v
:
&
BigUint
)
-
>
BigUint
{
self
/
v
}
#
[
inline
]
fn
rem_euclid
(
&
self
v
:
&
BigUint
)
-
>
BigUint
{
self
%
v
}
fn
div_rem_euclid
(
&
self
v
:
&
Self
)
-
>
(
Self
Self
)
{
self
.
div_rem
(
v
)
}
}
