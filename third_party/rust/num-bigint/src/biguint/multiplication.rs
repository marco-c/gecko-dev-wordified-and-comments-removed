use
super
:
:
addition
:
:
{
__add2
add2
}
;
use
super
:
:
subtraction
:
:
sub2
;
use
super
:
:
{
biguint_from_vec
cmp_slice
BigUint
IntDigits
}
;
use
crate
:
:
big_digit
:
:
{
self
BigDigit
DoubleBigDigit
}
;
use
crate
:
:
Sign
:
:
{
self
Minus
NoSign
Plus
}
;
use
crate
:
:
{
BigInt
UsizePromotion
}
;
use
core
:
:
cmp
:
:
Ordering
;
use
core
:
:
iter
:
:
Product
;
use
core
:
:
ops
:
:
{
Mul
MulAssign
}
;
use
num_traits
:
:
{
CheckedMul
FromPrimitive
One
Zero
}
;
#
[
inline
]
pub
(
super
)
fn
mac_with_carry
(
a
:
BigDigit
b
:
BigDigit
c
:
BigDigit
acc
:
&
mut
DoubleBigDigit
)
-
>
BigDigit
{
*
acc
+
=
DoubleBigDigit
:
:
from
(
a
)
;
*
acc
+
=
DoubleBigDigit
:
:
from
(
b
)
*
DoubleBigDigit
:
:
from
(
c
)
;
let
lo
=
*
acc
as
BigDigit
;
*
acc
>
>
=
big_digit
:
:
BITS
;
lo
}
#
[
inline
]
fn
mul_with_carry
(
a
:
BigDigit
b
:
BigDigit
acc
:
&
mut
DoubleBigDigit
)
-
>
BigDigit
{
*
acc
+
=
DoubleBigDigit
:
:
from
(
a
)
*
DoubleBigDigit
:
:
from
(
b
)
;
let
lo
=
*
acc
as
BigDigit
;
*
acc
>
>
=
big_digit
:
:
BITS
;
lo
}
fn
mac_digit
(
acc
:
&
mut
[
BigDigit
]
b
:
&
[
BigDigit
]
c
:
BigDigit
)
{
if
c
=
=
0
{
return
;
}
let
mut
carry
=
0
;
let
(
a_lo
a_hi
)
=
acc
.
split_at_mut
(
b
.
len
(
)
)
;
for
(
a
&
b
)
in
a_lo
.
iter_mut
(
)
.
zip
(
b
)
{
*
a
=
mac_with_carry
(
*
a
b
c
&
mut
carry
)
;
}
let
(
carry_hi
carry_lo
)
=
big_digit
:
:
from_doublebigdigit
(
carry
)
;
let
final_carry
=
if
carry_hi
=
=
0
{
__add2
(
a_hi
&
[
carry_lo
]
)
}
else
{
__add2
(
a_hi
&
[
carry_hi
carry_lo
]
)
}
;
assert_eq
!
(
final_carry
0
"
carry
overflow
during
multiplication
!
"
)
;
}
fn
bigint_from_slice
(
slice
:
&
[
BigDigit
]
)
-
>
BigInt
{
BigInt
:
:
from
(
biguint_from_vec
(
slice
.
to_vec
(
)
)
)
}
#
[
allow
(
clippy
:
:
many_single_char_names
)
]
fn
mac3
(
mut
acc
:
&
mut
[
BigDigit
]
mut
b
:
&
[
BigDigit
]
mut
c
:
&
[
BigDigit
]
)
{
if
let
Some
(
&
0
)
=
b
.
first
(
)
{
if
let
Some
(
nz
)
=
b
.
iter
(
)
.
position
(
|
&
d
|
d
!
=
0
)
{
b
=
&
b
[
nz
.
.
]
;
acc
=
&
mut
acc
[
nz
.
.
]
;
}
else
{
return
;
}
}
if
let
Some
(
&
0
)
=
c
.
first
(
)
{
if
let
Some
(
nz
)
=
c
.
iter
(
)
.
position
(
|
&
d
|
d
!
=
0
)
{
c
=
&
c
[
nz
.
.
]
;
acc
=
&
mut
acc
[
nz
.
.
]
;
}
else
{
return
;
}
}
let
acc
=
acc
;
let
(
x
y
)
=
if
b
.
len
(
)
<
c
.
len
(
)
{
(
b
c
)
}
else
{
(
c
b
)
}
;
if
x
.
len
(
)
<
=
32
{
for
(
i
xi
)
in
x
.
iter
(
)
.
enumerate
(
)
{
mac_digit
(
&
mut
acc
[
i
.
.
]
y
*
xi
)
;
}
}
else
if
x
.
len
(
)
*
2
<
=
y
.
len
(
)
{
let
m2
=
y
.
len
(
)
/
2
;
let
(
low2
high2
)
=
y
.
split_at
(
m2
)
;
mac3
(
acc
x
low2
)
;
mac3
(
&
mut
acc
[
m2
.
.
]
x
high2
)
;
}
else
if
x
.
len
(
)
<
=
256
{
let
b
=
x
.
len
(
)
/
2
;
let
(
x0
x1
)
=
x
.
split_at
(
b
)
;
let
(
y0
y1
)
=
y
.
split_at
(
b
)
;
let
len
=
x1
.
len
(
)
+
y1
.
len
(
)
+
1
;
let
mut
p
=
BigUint
{
data
:
vec
!
[
0
;
len
]
}
;
mac3
(
&
mut
p
.
data
x1
y1
)
;
p
.
normalize
(
)
;
add2
(
&
mut
acc
[
b
.
.
]
&
p
.
data
)
;
add2
(
&
mut
acc
[
b
*
2
.
.
]
&
p
.
data
)
;
p
.
data
.
truncate
(
0
)
;
p
.
data
.
resize
(
len
0
)
;
mac3
(
&
mut
p
.
data
x0
y0
)
;
p
.
normalize
(
)
;
add2
(
acc
&
p
.
data
)
;
add2
(
&
mut
acc
[
b
.
.
]
&
p
.
data
)
;
let
(
j0_sign
j0
)
=
sub_sign
(
x1
x0
)
;
let
(
j1_sign
j1
)
=
sub_sign
(
y1
y0
)
;
match
j0_sign
*
j1_sign
{
Plus
=
>
{
p
.
data
.
truncate
(
0
)
;
p
.
data
.
resize
(
len
0
)
;
mac3
(
&
mut
p
.
data
&
j0
.
data
&
j1
.
data
)
;
p
.
normalize
(
)
;
sub2
(
&
mut
acc
[
b
.
.
]
&
p
.
data
)
;
}
Minus
=
>
{
mac3
(
&
mut
acc
[
b
.
.
]
&
j0
.
data
&
j1
.
data
)
;
}
NoSign
=
>
(
)
}
}
else
{
let
i
=
y
.
len
(
)
/
3
+
1
;
let
x0_len
=
Ord
:
:
min
(
x
.
len
(
)
i
)
;
let
x1_len
=
Ord
:
:
min
(
x
.
len
(
)
-
x0_len
i
)
;
let
y0_len
=
i
;
let
y1_len
=
Ord
:
:
min
(
y
.
len
(
)
-
y0_len
i
)
;
let
x0
=
bigint_from_slice
(
&
x
[
.
.
x0_len
]
)
;
let
x1
=
bigint_from_slice
(
&
x
[
x0_len
.
.
x0_len
+
x1_len
]
)
;
let
x2
=
bigint_from_slice
(
&
x
[
x0_len
+
x1_len
.
.
]
)
;
let
y0
=
bigint_from_slice
(
&
y
[
.
.
y0_len
]
)
;
let
y1
=
bigint_from_slice
(
&
y
[
y0_len
.
.
y0_len
+
y1_len
]
)
;
let
y2
=
bigint_from_slice
(
&
y
[
y0_len
+
y1_len
.
.
]
)
;
let
p
=
&
x0
+
&
x2
;
let
q
=
&
y0
+
&
y2
;
let
p2
=
&
p
-
&
x1
;
let
q2
=
&
q
-
&
y1
;
let
r0
=
&
x0
*
&
y0
;
let
r4
=
&
x2
*
&
y2
;
let
r1
=
(
p
+
x1
)
*
(
q
+
y1
)
;
let
r2
=
&
p2
*
&
q2
;
let
r3
=
(
(
p2
+
x2
)
*
2
-
x0
)
*
(
(
q2
+
y2
)
*
2
-
y0
)
;
let
mut
comp3
:
BigInt
=
(
r3
-
&
r1
)
/
3u32
;
let
mut
comp1
:
BigInt
=
(
r1
-
&
r2
)
>
>
1
;
let
mut
comp2
:
BigInt
=
r2
-
&
r0
;
comp3
=
(
(
&
comp2
-
comp3
)
>
>
1
)
+
(
&
r4
<
<
1
)
;
comp2
+
=
&
comp1
-
&
r4
;
comp1
-
=
&
comp3
;
for
(
j
result
)
in
[
&
r0
&
comp1
&
comp2
&
comp3
&
r4
]
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
{
match
result
.
sign
(
)
{
Plus
=
>
add2
(
&
mut
acc
[
i
*
j
.
.
]
result
.
digits
(
)
)
Minus
=
>
sub2
(
&
mut
acc
[
i
*
j
.
.
]
result
.
digits
(
)
)
NoSign
=
>
{
}
}
}
}
}
fn
mul3
(
x
:
&
[
BigDigit
]
y
:
&
[
BigDigit
]
)
-
>
BigUint
{
let
len
=
x
.
len
(
)
+
y
.
len
(
)
+
1
;
let
mut
prod
=
BigUint
{
data
:
vec
!
[
0
;
len
]
}
;
mac3
(
&
mut
prod
.
data
x
y
)
;
prod
.
normalized
(
)
}
fn
scalar_mul
(
a
:
&
mut
BigUint
b
:
BigDigit
)
{
match
b
{
0
=
>
a
.
set_zero
(
)
1
=
>
{
}
_
=
>
{
if
b
.
is_power_of_two
(
)
{
*
a
<
<
=
b
.
trailing_zeros
(
)
;
}
else
{
let
mut
carry
=
0
;
for
a
in
a
.
data
.
iter_mut
(
)
{
*
a
=
mul_with_carry
(
*
a
b
&
mut
carry
)
;
}
if
carry
!
=
0
{
a
.
data
.
push
(
carry
as
BigDigit
)
;
}
}
}
}
}
fn
sub_sign
(
mut
a
:
&
[
BigDigit
]
mut
b
:
&
[
BigDigit
]
)
-
>
(
Sign
BigUint
)
{
if
let
Some
(
&
0
)
=
a
.
last
(
)
{
a
=
&
a
[
.
.
a
.
iter
(
)
.
rposition
(
|
&
x
|
x
!
=
0
)
.
map_or
(
0
|
i
|
i
+
1
)
]
;
}
if
let
Some
(
&
0
)
=
b
.
last
(
)
{
b
=
&
b
[
.
.
b
.
iter
(
)
.
rposition
(
|
&
x
|
x
!
=
0
)
.
map_or
(
0
|
i
|
i
+
1
)
]
;
}
match
cmp_slice
(
a
b
)
{
Ordering
:
:
Greater
=
>
{
let
mut
a
=
a
.
to_vec
(
)
;
sub2
(
&
mut
a
b
)
;
(
Plus
biguint_from_vec
(
a
)
)
}
Ordering
:
:
Less
=
>
{
let
mut
b
=
b
.
to_vec
(
)
;
sub2
(
&
mut
b
a
)
;
(
Minus
biguint_from_vec
(
b
)
)
}
Ordering
:
:
Equal
=
>
(
NoSign
BigUint
:
:
ZERO
)
}
}
macro_rules
!
impl_mul
{
(
(
impl
Mul
<
Other
:
ty
>
for
Self
:
ty
;
)
*
)
=
>
{
(
impl
Mul
<
Other
>
for
Self
{
type
Output
=
BigUint
;
#
[
inline
]
fn
mul
(
self
other
:
Other
)
-
>
BigUint
{
match
(
&
*
self
.
data
&
*
other
.
data
)
{
/
/
multiply
by
zero
(
&
[
]
_
)
|
(
_
&
[
]
)
=
>
BigUint
:
:
ZERO
/
/
multiply
by
a
scalar
(
_
&
[
digit
]
)
=
>
self
*
digit
(
&
[
digit
]
_
)
=
>
other
*
digit
/
/
full
multiplication
(
x
y
)
=
>
mul3
(
x
y
)
}
}
}
)
*
}
}
impl_mul
!
{
impl
Mul
<
BigUint
>
for
BigUint
;
impl
Mul
<
BigUint
>
for
&
BigUint
;
impl
Mul
<
&
BigUint
>
for
BigUint
;
impl
Mul
<
&
BigUint
>
for
&
BigUint
;
}
macro_rules
!
impl_mul_assign
{
(
(
impl
MulAssign
<
Other
:
ty
>
for
BigUint
;
)
*
)
=
>
{
(
impl
MulAssign
<
Other
>
for
BigUint
{
#
[
inline
]
fn
mul_assign
(
&
mut
self
other
:
Other
)
{
match
(
&
*
self
.
data
&
*
other
.
data
)
{
/
/
multiply
by
zero
(
&
[
]
_
)
=
>
{
}
(
_
&
[
]
)
=
>
self
.
set_zero
(
)
/
/
multiply
by
a
scalar
(
_
&
[
digit
]
)
=
>
*
self
*
=
digit
(
&
[
digit
]
_
)
=
>
*
self
=
other
*
digit
/
/
full
multiplication
(
x
y
)
=
>
*
self
=
mul3
(
x
y
)
}
}
}
)
*
}
}
impl_mul_assign
!
{
impl
MulAssign
<
BigUint
>
for
BigUint
;
impl
MulAssign
<
&
BigUint
>
for
BigUint
;
}
promote_unsigned_scalars
!
(
impl
Mul
for
BigUint
mul
)
;
promote_unsigned_scalars_assign
!
(
impl
MulAssign
for
BigUint
mul_assign
)
;
forward_all_scalar_binop_to_val_val_commutative
!
(
impl
Mul
<
u32
>
for
BigUint
mul
)
;
forward_all_scalar_binop_to_val_val_commutative
!
(
impl
Mul
<
u64
>
for
BigUint
mul
)
;
forward_all_scalar_binop_to_val_val_commutative
!
(
impl
Mul
<
u128
>
for
BigUint
mul
)
;
impl
Mul
<
u32
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
mul
(
mut
self
other
:
u32
)
-
>
BigUint
{
self
*
=
other
;
self
}
}
impl
MulAssign
<
u32
>
for
BigUint
{
#
[
inline
]
fn
mul_assign
(
&
mut
self
other
:
u32
)
{
scalar_mul
(
self
other
as
BigDigit
)
;
}
}
impl
Mul
<
u64
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
mul
(
mut
self
other
:
u64
)
-
>
BigUint
{
self
*
=
other
;
self
}
}
impl
MulAssign
<
u64
>
for
BigUint
{
cfg_digit
!
(
#
[
inline
]
fn
mul_assign
(
&
mut
self
other
:
u64
)
{
if
let
Some
(
other
)
=
BigDigit
:
:
from_u64
(
other
)
{
scalar_mul
(
self
other
)
;
}
else
{
let
(
hi
lo
)
=
big_digit
:
:
from_doublebigdigit
(
other
)
;
*
self
=
mul3
(
&
self
.
data
&
[
lo
hi
]
)
;
}
}
#
[
inline
]
fn
mul_assign
(
&
mut
self
other
:
u64
)
{
scalar_mul
(
self
other
)
;
}
)
;
}
impl
Mul
<
u128
>
for
BigUint
{
type
Output
=
BigUint
;
#
[
inline
]
fn
mul
(
mut
self
other
:
u128
)
-
>
BigUint
{
self
*
=
other
;
self
}
}
impl
MulAssign
<
u128
>
for
BigUint
{
cfg_digit
!
(
#
[
inline
]
fn
mul_assign
(
&
mut
self
other
:
u128
)
{
if
let
Some
(
other
)
=
BigDigit
:
:
from_u128
(
other
)
{
scalar_mul
(
self
other
)
;
}
else
{
*
self
=
match
super
:
:
u32_from_u128
(
other
)
{
(
0
0
c
d
)
=
>
mul3
(
&
self
.
data
&
[
d
c
]
)
(
0
b
c
d
)
=
>
mul3
(
&
self
.
data
&
[
d
c
b
]
)
(
a
b
c
d
)
=
>
mul3
(
&
self
.
data
&
[
d
c
b
a
]
)
}
;
}
}
#
[
inline
]
fn
mul_assign
(
&
mut
self
other
:
u128
)
{
if
let
Some
(
other
)
=
BigDigit
:
:
from_u128
(
other
)
{
scalar_mul
(
self
other
)
;
}
else
{
let
(
hi
lo
)
=
big_digit
:
:
from_doublebigdigit
(
other
)
;
*
self
=
mul3
(
&
self
.
data
&
[
lo
hi
]
)
;
}
}
)
;
}
impl
CheckedMul
for
BigUint
{
#
[
inline
]
fn
checked_mul
(
&
self
v
:
&
BigUint
)
-
>
Option
<
BigUint
>
{
Some
(
self
.
mul
(
v
)
)
}
}
impl_product_iter_type
!
(
BigUint
)
;
#
[
test
]
fn
test_sub_sign
(
)
{
use
crate
:
:
BigInt
;
use
num_traits
:
:
Num
;
fn
sub_sign_i
(
a
:
&
[
BigDigit
]
b
:
&
[
BigDigit
]
)
-
>
BigInt
{
let
(
sign
val
)
=
sub_sign
(
a
b
)
;
BigInt
:
:
from_biguint
(
sign
val
)
}
let
a
=
BigUint
:
:
from_str_radix
(
"
265252859812191058636308480000000
"
10
)
.
unwrap
(
)
;
let
b
=
BigUint
:
:
from_str_radix
(
"
26525285981219105863630848000000
"
10
)
.
unwrap
(
)
;
let
a_i
=
BigInt
:
:
from
(
a
.
clone
(
)
)
;
let
b_i
=
BigInt
:
:
from
(
b
.
clone
(
)
)
;
assert_eq
!
(
sub_sign_i
(
&
a
.
data
&
b
.
data
)
&
a_i
-
&
b_i
)
;
assert_eq
!
(
sub_sign_i
(
&
b
.
data
&
a
.
data
)
&
b_i
-
&
a_i
)
;
}
