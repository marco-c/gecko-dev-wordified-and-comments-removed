pub
use
self
:
:
BinOpToken
:
:
*
;
pub
use
self
:
:
Nonterminal
:
:
*
;
pub
use
self
:
:
DelimToken
:
:
*
;
pub
use
self
:
:
Lit
:
:
*
;
pub
use
self
:
:
Token
:
:
*
;
use
ast
:
:
{
self
}
;
use
ptr
:
:
P
;
use
symbol
:
:
keywords
;
use
tokenstream
;
use
std
:
:
fmt
;
use
std
:
:
rc
:
:
Rc
;
#
[
derive
(
Clone
RustcEncodable
RustcDecodable
PartialEq
Eq
Hash
Debug
Copy
)
]
pub
enum
BinOpToken
{
Plus
Minus
Star
Slash
Percent
Caret
And
Or
Shl
Shr
}
#
[
derive
(
Clone
RustcEncodable
RustcDecodable
PartialEq
Eq
Hash
Debug
Copy
)
]
pub
enum
DelimToken
{
Paren
Bracket
Brace
NoDelim
}
#
[
derive
(
Clone
RustcEncodable
RustcDecodable
PartialEq
Eq
Hash
Debug
Copy
)
]
pub
enum
Lit
{
Byte
(
ast
:
:
Name
)
Char
(
ast
:
:
Name
)
Integer
(
ast
:
:
Name
)
Float
(
ast
:
:
Name
)
Str_
(
ast
:
:
Name
)
StrRaw
(
ast
:
:
Name
usize
)
ByteStr
(
ast
:
:
Name
)
ByteStrRaw
(
ast
:
:
Name
usize
)
}
impl
Lit
{
pub
fn
short_name
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
Byte
(
_
)
=
>
"
byte
"
Char
(
_
)
=
>
"
char
"
Integer
(
_
)
=
>
"
integer
"
Float
(
_
)
=
>
"
float
"
Str_
(
_
)
|
StrRaw
(
.
.
)
=
>
"
string
"
ByteStr
(
_
)
|
ByteStrRaw
(
.
.
)
=
>
"
byte
string
"
}
}
}
#
[
derive
(
Clone
RustcEncodable
RustcDecodable
PartialEq
Eq
Hash
Debug
)
]
pub
enum
Token
{
Eq
Lt
Le
EqEq
Ne
Ge
Gt
AndAnd
OrOr
Not
Tilde
BinOp
(
BinOpToken
)
BinOpEq
(
BinOpToken
)
At
Dot
DotDot
DotDotDot
Comma
Semi
Colon
ModSep
RArrow
LArrow
FatArrow
Pound
Dollar
Question
OpenDelim
(
DelimToken
)
CloseDelim
(
DelimToken
)
Literal
(
Lit
Option
<
ast
:
:
Name
>
)
Ident
(
ast
:
:
Ident
)
Underscore
Lifetime
(
ast
:
:
Ident
)
Interpolated
(
Rc
<
Nonterminal
>
)
DocComment
(
ast
:
:
Name
)
MatchNt
(
ast
:
:
Ident
ast
:
:
Ident
)
SubstNt
(
ast
:
:
Ident
)
Whitespace
Comment
Shebang
(
ast
:
:
Name
)
Eof
}
impl
Token
{
pub
fn
is_like_gt
(
&
self
)
-
>
bool
{
match
*
self
{
BinOp
(
Shr
)
|
BinOpEq
(
Shr
)
|
Gt
|
Ge
=
>
true
_
=
>
false
}
}
pub
fn
can_begin_expr
(
&
self
)
-
>
bool
{
match
*
self
{
OpenDelim
(
.
.
)
=
>
true
Ident
(
.
.
)
=
>
true
Literal
(
.
.
)
=
>
true
Not
=
>
true
BinOp
(
Minus
)
=
>
true
BinOp
(
Star
)
=
>
true
BinOp
(
And
)
=
>
true
BinOp
(
Or
)
=
>
true
OrOr
=
>
true
AndAnd
=
>
true
DotDot
|
DotDotDot
=
>
true
Lt
|
BinOp
(
Shl
)
=
>
true
ModSep
=
>
true
Pound
=
>
true
Interpolated
(
ref
nt
)
=
>
match
*
*
nt
{
NtExpr
(
.
.
)
=
>
true
NtIdent
(
.
.
)
=
>
true
NtBlock
(
.
.
)
=
>
true
NtPath
(
.
.
)
=
>
true
_
=
>
false
}
_
=
>
false
}
}
pub
fn
is_lit
(
&
self
)
-
>
bool
{
match
*
self
{
Literal
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_ident
(
&
self
)
-
>
bool
{
match
*
self
{
Ident
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_doc_comment
(
&
self
)
-
>
bool
{
match
*
self
{
DocComment
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_interpolated
(
&
self
)
-
>
bool
{
match
*
self
{
Interpolated
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_path
(
&
self
)
-
>
bool
{
if
let
Interpolated
(
ref
nt
)
=
*
self
{
if
let
NtPath
(
.
.
)
=
*
*
nt
{
return
true
;
}
}
false
}
pub
fn
is_lifetime
(
&
self
)
-
>
bool
{
match
*
self
{
Lifetime
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_mutability
(
&
self
)
-
>
bool
{
self
.
is_keyword
(
keywords
:
:
Mut
)
|
|
self
.
is_keyword
(
keywords
:
:
Const
)
}
pub
fn
is_qpath_start
(
&
self
)
-
>
bool
{
self
=
=
&
Lt
|
|
self
=
=
&
BinOp
(
Shl
)
}
pub
fn
is_path_start
(
&
self
)
-
>
bool
{
self
=
=
&
ModSep
|
|
self
.
is_qpath_start
(
)
|
|
self
.
is_path
(
)
|
|
self
.
is_path_segment_keyword
(
)
|
|
self
.
is_ident
(
)
&
&
!
self
.
is_any_keyword
(
)
}
pub
fn
is_keyword
(
&
self
kw
:
keywords
:
:
Keyword
)
-
>
bool
{
match
*
self
{
Ident
(
id
)
=
>
id
.
name
=
=
kw
.
name
(
)
_
=
>
false
}
}
pub
fn
is_path_segment_keyword
(
&
self
)
-
>
bool
{
match
*
self
{
Ident
(
id
)
=
>
id
.
name
=
=
keywords
:
:
Super
.
name
(
)
|
|
id
.
name
=
=
keywords
:
:
SelfValue
.
name
(
)
|
|
id
.
name
=
=
keywords
:
:
SelfType
.
name
(
)
_
=
>
false
}
}
pub
fn
is_any_keyword
(
&
self
)
-
>
bool
{
self
.
is_strict_keyword
(
)
|
|
self
.
is_reserved_keyword
(
)
}
pub
fn
is_strict_keyword
(
&
self
)
-
>
bool
{
match
*
self
{
Ident
(
id
)
=
>
id
.
name
>
=
keywords
:
:
As
.
name
(
)
&
&
id
.
name
<
=
keywords
:
:
While
.
name
(
)
_
=
>
false
}
}
pub
fn
is_reserved_keyword
(
&
self
)
-
>
bool
{
match
*
self
{
Ident
(
id
)
=
>
id
.
name
>
=
keywords
:
:
Abstract
.
name
(
)
&
&
id
.
name
<
=
keywords
:
:
Yield
.
name
(
)
_
=
>
false
}
}
}
#
[
derive
(
Clone
RustcEncodable
RustcDecodable
PartialEq
Eq
Hash
)
]
pub
enum
Nonterminal
{
NtItem
(
P
<
ast
:
:
Item
>
)
NtBlock
(
P
<
ast
:
:
Block
>
)
NtStmt
(
ast
:
:
Stmt
)
NtPat
(
P
<
ast
:
:
Pat
>
)
NtExpr
(
P
<
ast
:
:
Expr
>
)
NtTy
(
P
<
ast
:
:
Ty
>
)
NtIdent
(
ast
:
:
SpannedIdent
)
NtMeta
(
ast
:
:
MetaItem
)
NtPath
(
ast
:
:
Path
)
NtTT
(
tokenstream
:
:
TokenTree
)
NtArm
(
ast
:
:
Arm
)
NtImplItem
(
ast
:
:
ImplItem
)
NtTraitItem
(
ast
:
:
TraitItem
)
NtGenerics
(
ast
:
:
Generics
)
NtWhereClause
(
ast
:
:
WhereClause
)
NtArg
(
ast
:
:
Arg
)
}
impl
fmt
:
:
Debug
for
Nonterminal
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
NtItem
(
.
.
)
=
>
f
.
pad
(
"
NtItem
(
.
.
)
"
)
NtBlock
(
.
.
)
=
>
f
.
pad
(
"
NtBlock
(
.
.
)
"
)
NtStmt
(
.
.
)
=
>
f
.
pad
(
"
NtStmt
(
.
.
)
"
)
NtPat
(
.
.
)
=
>
f
.
pad
(
"
NtPat
(
.
.
)
"
)
NtExpr
(
.
.
)
=
>
f
.
pad
(
"
NtExpr
(
.
.
)
"
)
NtTy
(
.
.
)
=
>
f
.
pad
(
"
NtTy
(
.
.
)
"
)
NtIdent
(
.
.
)
=
>
f
.
pad
(
"
NtIdent
(
.
.
)
"
)
NtMeta
(
.
.
)
=
>
f
.
pad
(
"
NtMeta
(
.
.
)
"
)
NtPath
(
.
.
)
=
>
f
.
pad
(
"
NtPath
(
.
.
)
"
)
NtTT
(
.
.
)
=
>
f
.
pad
(
"
NtTT
(
.
.
)
"
)
NtArm
(
.
.
)
=
>
f
.
pad
(
"
NtArm
(
.
.
)
"
)
NtImplItem
(
.
.
)
=
>
f
.
pad
(
"
NtImplItem
(
.
.
)
"
)
NtTraitItem
(
.
.
)
=
>
f
.
pad
(
"
NtTraitItem
(
.
.
)
"
)
NtGenerics
(
.
.
)
=
>
f
.
pad
(
"
NtGenerics
(
.
.
)
"
)
NtWhereClause
(
.
.
)
=
>
f
.
pad
(
"
NtWhereClause
(
.
.
)
"
)
NtArg
(
.
.
)
=
>
f
.
pad
(
"
NtArg
(
.
.
)
"
)
}
}
}
