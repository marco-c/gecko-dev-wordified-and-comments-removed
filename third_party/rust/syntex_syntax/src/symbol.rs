use
serialize
:
:
{
Decodable
Decoder
Encodable
Encoder
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
Symbol
(
u32
)
;
impl
Symbol
{
pub
fn
intern
(
string
:
&
str
)
-
>
Self
{
with_interner
(
|
interner
|
interner
.
intern
(
string
)
)
}
pub
fn
gensym
(
string
:
&
str
)
-
>
Self
{
with_interner
(
|
interner
|
interner
.
gensym
(
string
)
)
}
pub
fn
as_str
(
self
)
-
>
InternedString
{
with_interner
(
|
interner
|
unsafe
{
InternedString
{
string
:
:
:
std
:
:
mem
:
:
transmute
:
:
<
&
str
&
str
>
(
interner
.
get
(
self
)
)
}
}
)
}
pub
fn
as_u32
(
self
)
-
>
u32
{
self
.
0
}
}
impl
fmt
:
:
Debug
for
Symbol
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
(
{
}
)
"
self
self
.
0
)
}
}
impl
fmt
:
:
Display
for
Symbol
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
as_str
(
)
f
)
}
}
impl
Encodable
for
Symbol
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
s
.
emit_str
(
&
self
.
as_str
(
)
)
}
}
impl
Decodable
for
Symbol
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
Symbol
D
:
:
Error
>
{
Ok
(
Symbol
:
:
intern
(
&
try
!
(
d
.
read_str
(
)
)
)
)
}
}
impl
<
'
a
>
PartialEq
<
&
'
a
str
>
for
Symbol
{
fn
eq
(
&
self
other
:
&
&
str
)
-
>
bool
{
*
self
.
as_str
(
)
=
=
*
*
other
}
}
#
[
derive
(
Default
)
]
pub
struct
Interner
{
names
:
HashMap
<
Box
<
str
>
Symbol
>
strings
:
Vec
<
Box
<
str
>
>
}
impl
Interner
{
pub
fn
new
(
)
-
>
Self
{
Interner
:
:
default
(
)
}
fn
prefill
(
init
:
&
[
&
str
]
)
-
>
Self
{
let
mut
this
=
Interner
:
:
new
(
)
;
for
&
string
in
init
{
this
.
intern
(
string
)
;
}
this
}
pub
fn
intern
(
&
mut
self
string
:
&
str
)
-
>
Symbol
{
if
let
Some
(
&
name
)
=
self
.
names
.
get
(
string
)
{
return
name
;
}
let
name
=
Symbol
(
self
.
strings
.
len
(
)
as
u32
)
;
let
string
=
string
.
to_string
(
)
.
into_boxed_str
(
)
;
self
.
strings
.
push
(
string
.
clone
(
)
)
;
self
.
names
.
insert
(
string
name
)
;
name
}
fn
gensym
(
&
mut
self
string
:
&
str
)
-
>
Symbol
{
let
gensym
=
Symbol
(
self
.
strings
.
len
(
)
as
u32
)
;
self
.
strings
.
push
(
string
.
to_string
(
)
.
into_boxed_str
(
)
)
;
gensym
}
pub
fn
get
(
&
self
name
:
Symbol
)
-
>
&
str
{
&
self
.
strings
[
name
.
0
as
usize
]
}
}
macro_rules
!
declare_keywords
{
(
(
(
index
:
expr
konst
:
ident
string
:
expr
)
)
*
)
=
>
{
pub
mod
keywords
{
use
ast
;
use
ext
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
)
]
pub
struct
Keyword
{
ident
:
ast
:
:
Ident
}
impl
Keyword
{
#
[
inline
]
pub
fn
ident
(
self
)
-
>
ast
:
:
Ident
{
self
.
ident
}
#
[
inline
]
pub
fn
name
(
self
)
-
>
ast
:
:
Name
{
self
.
ident
.
name
}
}
(
#
[
allow
(
non_upper_case_globals
)
]
pub
const
konst
:
Keyword
=
Keyword
{
ident
:
ast
:
:
Ident
{
name
:
ast
:
:
Name
(
index
)
ctxt
:
ext
:
:
hygiene
:
:
SyntaxContext
(
0
)
}
}
;
)
*
}
impl
Interner
{
fn
fresh
(
)
-
>
Self
{
Interner
:
:
prefill
(
&
[
(
string
)
*
]
)
}
}
}
}
declare_keywords
!
{
/
/
Invalid
identifier
(
0
Invalid
"
"
)
/
/
Strict
keywords
used
in
the
language
.
(
1
As
"
as
"
)
(
2
Box
"
box
"
)
(
3
Break
"
break
"
)
(
4
Const
"
const
"
)
(
5
Continue
"
continue
"
)
(
6
Crate
"
crate
"
)
(
7
Else
"
else
"
)
(
8
Enum
"
enum
"
)
(
9
Extern
"
extern
"
)
(
10
False
"
false
"
)
(
11
Fn
"
fn
"
)
(
12
For
"
for
"
)
(
13
If
"
if
"
)
(
14
Impl
"
impl
"
)
(
15
In
"
in
"
)
(
16
Let
"
let
"
)
(
17
Loop
"
loop
"
)
(
18
Match
"
match
"
)
(
19
Mod
"
mod
"
)
(
20
Move
"
move
"
)
(
21
Mut
"
mut
"
)
(
22
Pub
"
pub
"
)
(
23
Ref
"
ref
"
)
(
24
Return
"
return
"
)
(
25
SelfValue
"
self
"
)
(
26
SelfType
"
Self
"
)
(
27
Static
"
static
"
)
(
28
Struct
"
struct
"
)
(
29
Super
"
super
"
)
(
30
Trait
"
trait
"
)
(
31
True
"
true
"
)
(
32
Type
"
type
"
)
(
33
Unsafe
"
unsafe
"
)
(
34
Use
"
use
"
)
(
35
Where
"
where
"
)
(
36
While
"
while
"
)
/
/
Keywords
reserved
for
future
use
.
(
37
Abstract
"
abstract
"
)
(
38
Alignof
"
alignof
"
)
(
39
Become
"
become
"
)
(
40
Do
"
do
"
)
(
41
Final
"
final
"
)
(
42
Macro
"
macro
"
)
(
43
Offsetof
"
offsetof
"
)
(
44
Override
"
override
"
)
(
45
Priv
"
priv
"
)
(
46
Proc
"
proc
"
)
(
47
Pure
"
pure
"
)
(
48
Sizeof
"
sizeof
"
)
(
49
Typeof
"
typeof
"
)
(
50
Unsized
"
unsized
"
)
(
51
Virtual
"
virtual
"
)
(
52
Yield
"
yield
"
)
/
/
Weak
keywords
have
special
meaning
only
in
specific
contexts
.
(
53
Default
"
default
"
)
(
54
StaticLifetime
"
'
static
"
)
(
55
Union
"
union
"
)
/
/
A
virtual
keyword
that
resolves
to
the
crate
root
when
used
in
a
lexical
scope
.
(
56
CrateRoot
"
{
{
root
}
}
"
)
}
fn
with_interner
<
T
F
:
FnOnce
(
&
mut
Interner
)
-
>
T
>
(
f
:
F
)
-
>
T
{
thread_local
!
(
static
INTERNER
:
RefCell
<
Interner
>
=
{
RefCell
:
:
new
(
Interner
:
:
fresh
(
)
)
}
)
;
INTERNER
.
with
(
|
interner
|
f
(
&
mut
*
interner
.
borrow_mut
(
)
)
)
}
#
[
derive
(
Clone
PartialEq
Hash
PartialOrd
Eq
Ord
)
]
pub
struct
InternedString
{
string
:
&
'
static
str
}
impl
:
:
std
:
:
ops
:
:
Deref
for
InternedString
{
type
Target
=
str
;
fn
deref
(
&
self
)
-
>
&
str
{
self
.
string
}
}
impl
fmt
:
:
Debug
for
InternedString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
self
.
string
f
)
}
}
impl
fmt
:
:
Display
for
InternedString
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
.
string
f
)
}
}
impl
Decodable
for
InternedString
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
InternedString
D
:
:
Error
>
{
Ok
(
Symbol
:
:
intern
(
&
try
!
(
d
.
read_str
(
)
)
)
.
as_str
(
)
)
}
}
impl
Encodable
for
InternedString
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
s
.
emit_str
(
self
.
string
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
ast
:
:
Name
;
#
[
test
]
fn
interner_tests
(
)
{
let
mut
i
:
Interner
=
Interner
:
:
new
(
)
;
assert_eq
!
(
i
.
intern
(
"
dog
"
)
Name
(
0
)
)
;
assert_eq
!
(
i
.
intern
(
"
dog
"
)
Name
(
0
)
)
;
assert_eq
!
(
i
.
intern
(
"
cat
"
)
Name
(
1
)
)
;
assert_eq
!
(
i
.
intern
(
"
cat
"
)
Name
(
1
)
)
;
assert_eq
!
(
i
.
intern
(
"
dog
"
)
Name
(
0
)
)
;
assert_eq
!
(
i
.
gensym
(
"
zebra
"
)
Name
(
2
)
)
;
assert_eq
!
(
i
.
gensym
(
"
zebra
"
)
Name
(
3
)
)
;
assert_eq
!
(
i
.
gensym
(
"
dog
"
)
Name
(
4
)
)
;
}
}
