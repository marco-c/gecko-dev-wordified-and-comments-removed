pub
use
self
:
:
TyParamBound
:
:
*
;
pub
use
self
:
:
UnsafeSource
:
:
*
;
pub
use
self
:
:
ViewPath_
:
:
*
;
pub
use
self
:
:
PathParameters
:
:
*
;
pub
use
symbol
:
:
Symbol
as
Name
;
pub
use
util
:
:
ThinVec
;
use
syntax_pos
:
:
{
mk_sp
Span
DUMMY_SP
ExpnId
}
;
use
codemap
:
:
{
respan
Spanned
}
;
use
abi
:
:
Abi
;
use
ext
:
:
hygiene
:
:
SyntaxContext
;
use
print
:
:
pprust
;
use
ptr
:
:
P
;
use
symbol
:
:
{
Symbol
keywords
}
;
use
tokenstream
:
:
{
TokenTree
}
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
fmt
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
u32
;
use
serialize
:
:
{
self
Encodable
Decodable
Encoder
Decoder
}
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
)
]
pub
struct
Ident
{
pub
name
:
Symbol
pub
ctxt
:
SyntaxContext
}
impl
Ident
{
pub
fn
with_empty_ctxt
(
name
:
Name
)
-
>
Ident
{
Ident
{
name
:
name
ctxt
:
SyntaxContext
:
:
empty
(
)
}
}
pub
fn
from_str
(
s
:
&
str
)
-
>
Ident
{
Ident
:
:
with_empty_ctxt
(
Symbol
:
:
intern
(
s
)
)
}
pub
fn
unhygienize
(
&
self
)
-
>
Ident
{
Ident
{
name
:
self
.
name
ctxt
:
SyntaxContext
:
:
empty
(
)
}
}
}
impl
fmt
:
:
Debug
for
Ident
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
{
:
?
}
"
self
.
name
self
.
ctxt
)
}
}
impl
fmt
:
:
Display
for
Ident
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
name
f
)
}
}
impl
Encodable
for
Ident
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
self
.
name
.
encode
(
s
)
}
}
impl
Decodable
for
Ident
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
Ident
D
:
:
Error
>
{
Ok
(
Ident
:
:
with_empty_ctxt
(
try
!
(
Name
:
:
decode
(
d
)
)
)
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Copy
)
]
pub
struct
Lifetime
{
pub
id
:
NodeId
pub
span
:
Span
pub
name
:
Name
}
impl
fmt
:
:
Debug
for
Lifetime
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
lifetime
(
{
}
:
{
}
)
"
self
.
id
pprust
:
:
lifetime_to_string
(
self
)
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
LifetimeDef
{
pub
attrs
:
ThinVec
<
Attribute
>
pub
lifetime
:
Lifetime
pub
bounds
:
Vec
<
Lifetime
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
struct
Path
{
pub
span
:
Span
pub
segments
:
Vec
<
PathSegment
>
}
impl
fmt
:
:
Debug
for
Path
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
path
(
{
}
)
"
pprust
:
:
path_to_string
(
self
)
)
}
}
impl
fmt
:
:
Display
for
Path
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
pprust
:
:
path_to_string
(
self
)
)
}
}
impl
Path
{
pub
fn
from_ident
(
s
:
Span
identifier
:
Ident
)
-
>
Path
{
Path
{
span
:
s
segments
:
vec
!
[
identifier
.
into
(
)
]
}
}
pub
fn
default_to_global
(
mut
self
)
-
>
Path
{
let
name
=
self
.
segments
[
0
]
.
identifier
.
name
;
if
!
self
.
is_global
(
)
&
&
name
!
=
"
crate
"
&
&
name
!
=
keywords
:
:
SelfValue
.
name
(
)
&
&
name
!
=
keywords
:
:
Super
.
name
(
)
{
self
.
segments
.
insert
(
0
PathSegment
:
:
crate_root
(
)
)
;
}
self
}
pub
fn
is_global
(
&
self
)
-
>
bool
{
!
self
.
segments
.
is_empty
(
)
&
&
self
.
segments
[
0
]
.
identifier
.
name
=
=
keywords
:
:
CrateRoot
.
name
(
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
PathSegment
{
pub
identifier
:
Ident
pub
parameters
:
Option
<
P
<
PathParameters
>
>
}
impl
From
<
Ident
>
for
PathSegment
{
fn
from
(
id
:
Ident
)
-
>
Self
{
PathSegment
{
identifier
:
id
parameters
:
None
}
}
}
impl
PathSegment
{
pub
fn
crate_root
(
)
-
>
Self
{
PathSegment
{
identifier
:
keywords
:
:
CrateRoot
.
ident
(
)
parameters
:
None
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
PathParameters
{
AngleBracketed
(
AngleBracketedParameterData
)
Parenthesized
(
ParenthesizedParameterData
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Default
)
]
pub
struct
AngleBracketedParameterData
{
pub
lifetimes
:
Vec
<
Lifetime
>
pub
types
:
P
<
[
P
<
Ty
>
]
>
pub
bindings
:
P
<
[
TypeBinding
]
>
}
impl
Into
<
Option
<
P
<
PathParameters
>
>
>
for
AngleBracketedParameterData
{
fn
into
(
self
)
-
>
Option
<
P
<
PathParameters
>
>
{
let
empty
=
self
.
lifetimes
.
is_empty
(
)
&
&
self
.
types
.
is_empty
(
)
&
&
self
.
bindings
.
is_empty
(
)
;
if
empty
{
None
}
else
{
Some
(
P
(
PathParameters
:
:
AngleBracketed
(
self
)
)
)
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
ParenthesizedParameterData
{
pub
span
:
Span
pub
inputs
:
Vec
<
P
<
Ty
>
>
pub
output
:
Option
<
P
<
Ty
>
>
}
#
[
derive
(
Clone
Copy
PartialEq
PartialOrd
Eq
Ord
Hash
Debug
)
]
pub
struct
NodeId
(
u32
)
;
impl
NodeId
{
pub
fn
new
(
x
:
usize
)
-
>
NodeId
{
assert
!
(
x
<
(
u32
:
:
MAX
as
usize
)
)
;
NodeId
(
x
as
u32
)
}
pub
fn
from_u32
(
x
:
u32
)
-
>
NodeId
{
NodeId
(
x
)
}
pub
fn
as_usize
(
&
self
)
-
>
usize
{
self
.
0
as
usize
}
pub
fn
as_u32
(
&
self
)
-
>
u32
{
self
.
0
}
}
impl
fmt
:
:
Display
for
NodeId
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
&
self
.
0
f
)
}
}
impl
serialize
:
:
Encodable
for
NodeId
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
s
.
emit_u32
(
self
.
0
)
}
}
impl
serialize
:
:
Decodable
for
NodeId
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
NodeId
D
:
:
Error
>
{
d
.
read_u32
(
)
.
map
(
NodeId
)
}
}
pub
const
CRATE_NODE_ID
:
NodeId
=
NodeId
(
0
)
;
pub
const
DUMMY_NODE_ID
:
NodeId
=
NodeId
(
!
0
)
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
TyParamBound
{
TraitTyParamBound
(
PolyTraitRef
TraitBoundModifier
)
RegionTyParamBound
(
Lifetime
)
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
TraitBoundModifier
{
None
Maybe
}
pub
type
TyParamBounds
=
P
<
[
TyParamBound
]
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
TyParam
{
pub
attrs
:
ThinVec
<
Attribute
>
pub
ident
:
Ident
pub
id
:
NodeId
pub
bounds
:
TyParamBounds
pub
default
:
Option
<
P
<
Ty
>
>
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Generics
{
pub
lifetimes
:
Vec
<
LifetimeDef
>
pub
ty_params
:
P
<
[
TyParam
]
>
pub
where_clause
:
WhereClause
pub
span
:
Span
}
impl
Generics
{
pub
fn
is_lt_parameterized
(
&
self
)
-
>
bool
{
!
self
.
lifetimes
.
is_empty
(
)
}
pub
fn
is_type_parameterized
(
&
self
)
-
>
bool
{
!
self
.
ty_params
.
is_empty
(
)
}
pub
fn
is_parameterized
(
&
self
)
-
>
bool
{
self
.
is_lt_parameterized
(
)
|
|
self
.
is_type_parameterized
(
)
}
pub
fn
span_for_name
(
&
self
name
:
&
str
)
-
>
Option
<
Span
>
{
for
t
in
&
self
.
ty_params
{
if
t
.
ident
.
name
=
=
name
{
return
Some
(
t
.
span
)
;
}
}
None
}
}
impl
Default
for
Generics
{
fn
default
(
)
-
>
Generics
{
Generics
{
lifetimes
:
Vec
:
:
new
(
)
ty_params
:
P
:
:
new
(
)
where_clause
:
WhereClause
{
id
:
DUMMY_NODE_ID
predicates
:
Vec
:
:
new
(
)
}
span
:
DUMMY_SP
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
WhereClause
{
pub
id
:
NodeId
pub
predicates
:
Vec
<
WherePredicate
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
WherePredicate
{
BoundPredicate
(
WhereBoundPredicate
)
RegionPredicate
(
WhereRegionPredicate
)
EqPredicate
(
WhereEqPredicate
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
WhereBoundPredicate
{
pub
span
:
Span
pub
bound_lifetimes
:
Vec
<
LifetimeDef
>
pub
bounded_ty
:
P
<
Ty
>
pub
bounds
:
TyParamBounds
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
WhereRegionPredicate
{
pub
span
:
Span
pub
lifetime
:
Lifetime
pub
bounds
:
Vec
<
Lifetime
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
WhereEqPredicate
{
pub
id
:
NodeId
pub
span
:
Span
pub
path
:
Path
pub
ty
:
P
<
Ty
>
}
pub
type
CrateConfig
=
HashSet
<
(
Name
Option
<
Symbol
>
)
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Crate
{
pub
module
:
Mod
pub
attrs
:
Vec
<
Attribute
>
pub
span
:
Span
pub
exported_macros
:
Vec
<
MacroDef
>
}
pub
type
NestedMetaItem
=
Spanned
<
NestedMetaItemKind
>
;
#
[
derive
(
Clone
Eq
RustcEncodable
RustcDecodable
Hash
Debug
PartialEq
)
]
pub
enum
NestedMetaItemKind
{
MetaItem
(
MetaItem
)
Literal
(
Lit
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
MetaItem
{
pub
name
:
Name
pub
node
:
MetaItemKind
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
MetaItemKind
{
Word
List
(
Vec
<
NestedMetaItem
>
)
NameValue
(
Lit
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Block
{
pub
stmts
:
Vec
<
Stmt
>
pub
id
:
NodeId
pub
rules
:
BlockCheckMode
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
struct
Pat
{
pub
id
:
NodeId
pub
node
:
PatKind
pub
span
:
Span
}
impl
fmt
:
:
Debug
for
Pat
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
pat
(
{
}
:
{
}
)
"
self
.
id
pprust
:
:
pat_to_string
(
self
)
)
}
}
impl
Pat
{
pub
fn
walk
<
F
>
(
&
self
it
:
&
mut
F
)
-
>
bool
where
F
:
FnMut
(
&
Pat
)
-
>
bool
{
if
!
it
(
self
)
{
return
false
;
}
match
self
.
node
{
PatKind
:
:
Ident
(
_
_
Some
(
ref
p
)
)
=
>
p
.
walk
(
it
)
PatKind
:
:
Struct
(
_
ref
fields
_
)
=
>
{
fields
.
iter
(
)
.
all
(
|
field
|
field
.
node
.
pat
.
walk
(
it
)
)
}
PatKind
:
:
TupleStruct
(
_
ref
s
_
)
|
PatKind
:
:
Tuple
(
ref
s
_
)
=
>
{
s
.
iter
(
)
.
all
(
|
p
|
p
.
walk
(
it
)
)
}
PatKind
:
:
Box
(
ref
s
)
|
PatKind
:
:
Ref
(
ref
s
_
)
=
>
{
s
.
walk
(
it
)
}
PatKind
:
:
Slice
(
ref
before
ref
slice
ref
after
)
=
>
{
before
.
iter
(
)
.
all
(
|
p
|
p
.
walk
(
it
)
)
&
&
slice
.
iter
(
)
.
all
(
|
p
|
p
.
walk
(
it
)
)
&
&
after
.
iter
(
)
.
all
(
|
p
|
p
.
walk
(
it
)
)
}
PatKind
:
:
Wild
|
PatKind
:
:
Lit
(
_
)
|
PatKind
:
:
Range
(
.
.
)
|
PatKind
:
:
Ident
(
.
.
)
|
PatKind
:
:
Path
(
.
.
)
|
PatKind
:
:
Mac
(
_
)
=
>
{
true
}
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
FieldPat
{
pub
ident
:
Ident
pub
pat
:
P
<
Pat
>
pub
is_shorthand
:
bool
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
BindingMode
{
ByRef
(
Mutability
)
ByValue
(
Mutability
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
PatKind
{
Wild
Ident
(
BindingMode
SpannedIdent
Option
<
P
<
Pat
>
>
)
Struct
(
Path
Vec
<
Spanned
<
FieldPat
>
>
bool
)
TupleStruct
(
Path
Vec
<
P
<
Pat
>
>
Option
<
usize
>
)
Path
(
Option
<
QSelf
>
Path
)
Tuple
(
Vec
<
P
<
Pat
>
>
Option
<
usize
>
)
Box
(
P
<
Pat
>
)
Ref
(
P
<
Pat
>
Mutability
)
Lit
(
P
<
Expr
>
)
Range
(
P
<
Expr
>
P
<
Expr
>
)
Slice
(
Vec
<
P
<
Pat
>
>
Option
<
P
<
Pat
>
>
Vec
<
P
<
Pat
>
>
)
Mac
(
Mac
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
Mutability
{
Mutable
Immutable
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
BinOpKind
{
Add
Sub
Mul
Div
Rem
And
Or
BitXor
BitAnd
BitOr
Shl
Shr
Eq
Lt
Le
Ne
Ge
Gt
}
impl
BinOpKind
{
pub
fn
to_string
(
&
self
)
-
>
&
'
static
str
{
use
self
:
:
BinOpKind
:
:
*
;
match
*
self
{
Add
=
>
"
+
"
Sub
=
>
"
-
"
Mul
=
>
"
*
"
Div
=
>
"
/
"
Rem
=
>
"
%
"
And
=
>
"
&
&
"
Or
=
>
"
|
|
"
BitXor
=
>
"
^
"
BitAnd
=
>
"
&
"
BitOr
=
>
"
|
"
Shl
=
>
"
<
<
"
Shr
=
>
"
>
>
"
Eq
=
>
"
=
=
"
Lt
=
>
"
<
"
Le
=
>
"
<
=
"
Ne
=
>
"
!
=
"
Ge
=
>
"
>
=
"
Gt
=
>
"
>
"
}
}
pub
fn
lazy
(
&
self
)
-
>
bool
{
match
*
self
{
BinOpKind
:
:
And
|
BinOpKind
:
:
Or
=
>
true
_
=
>
false
}
}
pub
fn
is_shift
(
&
self
)
-
>
bool
{
match
*
self
{
BinOpKind
:
:
Shl
|
BinOpKind
:
:
Shr
=
>
true
_
=
>
false
}
}
pub
fn
is_comparison
(
&
self
)
-
>
bool
{
use
self
:
:
BinOpKind
:
:
*
;
match
*
self
{
Eq
|
Lt
|
Le
|
Ne
|
Gt
|
Ge
=
>
true
And
|
Or
|
Add
|
Sub
|
Mul
|
Div
|
Rem
|
BitXor
|
BitAnd
|
BitOr
|
Shl
|
Shr
=
>
false
}
}
pub
fn
is_by_value
(
&
self
)
-
>
bool
{
!
self
.
is_comparison
(
)
}
}
pub
type
BinOp
=
Spanned
<
BinOpKind
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
UnOp
{
Deref
Not
Neg
}
impl
UnOp
{
pub
fn
is_by_value
(
u
:
UnOp
)
-
>
bool
{
match
u
{
UnOp
:
:
Neg
|
UnOp
:
:
Not
=
>
true
_
=
>
false
}
}
pub
fn
to_string
(
op
:
UnOp
)
-
>
&
'
static
str
{
match
op
{
UnOp
:
:
Deref
=
>
"
*
"
UnOp
:
:
Not
=
>
"
!
"
UnOp
:
:
Neg
=
>
"
-
"
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
struct
Stmt
{
pub
id
:
NodeId
pub
node
:
StmtKind
pub
span
:
Span
}
impl
Stmt
{
pub
fn
add_trailing_semicolon
(
mut
self
)
-
>
Self
{
self
.
node
=
match
self
.
node
{
StmtKind
:
:
Expr
(
expr
)
=
>
StmtKind
:
:
Semi
(
expr
)
StmtKind
:
:
Mac
(
mac
)
=
>
StmtKind
:
:
Mac
(
mac
.
map
(
|
(
mac
_style
attrs
)
|
{
(
mac
MacStmtStyle
:
:
Semicolon
attrs
)
}
)
)
node
_
=
>
node
}
;
self
}
}
impl
fmt
:
:
Debug
for
Stmt
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
stmt
(
{
}
:
{
}
)
"
self
.
id
.
to_string
(
)
pprust
:
:
stmt_to_string
(
self
)
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
enum
StmtKind
{
Local
(
P
<
Local
>
)
Item
(
P
<
Item
>
)
Expr
(
P
<
Expr
>
)
Semi
(
P
<
Expr
>
)
Mac
(
P
<
(
Mac
MacStmtStyle
ThinVec
<
Attribute
>
)
>
)
}
#
[
derive
(
Clone
Copy
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
MacStmtStyle
{
Semicolon
Braces
NoBraces
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Local
{
pub
pat
:
P
<
Pat
>
pub
ty
:
Option
<
P
<
Ty
>
>
pub
init
:
Option
<
P
<
Expr
>
>
pub
id
:
NodeId
pub
span
:
Span
pub
attrs
:
ThinVec
<
Attribute
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Arm
{
pub
attrs
:
Vec
<
Attribute
>
pub
pats
:
Vec
<
P
<
Pat
>
>
pub
guard
:
Option
<
P
<
Expr
>
>
pub
body
:
P
<
Expr
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Field
{
pub
ident
:
SpannedIdent
pub
expr
:
P
<
Expr
>
pub
span
:
Span
pub
is_shorthand
:
bool
}
pub
type
SpannedIdent
=
Spanned
<
Ident
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
BlockCheckMode
{
Default
Unsafe
(
UnsafeSource
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
UnsafeSource
{
CompilerGenerated
UserProvided
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
struct
Expr
{
pub
id
:
NodeId
pub
node
:
ExprKind
pub
span
:
Span
pub
attrs
:
ThinVec
<
Attribute
>
}
impl
fmt
:
:
Debug
for
Expr
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
expr
(
{
}
:
{
}
)
"
self
.
id
pprust
:
:
expr_to_string
(
self
)
)
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
RangeLimits
{
HalfOpen
Closed
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
ExprKind
{
Box
(
P
<
Expr
>
)
InPlace
(
P
<
Expr
>
P
<
Expr
>
)
Vec
(
Vec
<
P
<
Expr
>
>
)
Call
(
P
<
Expr
>
Vec
<
P
<
Expr
>
>
)
MethodCall
(
SpannedIdent
Vec
<
P
<
Ty
>
>
Vec
<
P
<
Expr
>
>
)
Tup
(
Vec
<
P
<
Expr
>
>
)
Binary
(
BinOp
P
<
Expr
>
P
<
Expr
>
)
Unary
(
UnOp
P
<
Expr
>
)
Lit
(
P
<
Lit
>
)
Cast
(
P
<
Expr
>
P
<
Ty
>
)
Type
(
P
<
Expr
>
P
<
Ty
>
)
If
(
P
<
Expr
>
P
<
Block
>
Option
<
P
<
Expr
>
>
)
IfLet
(
P
<
Pat
>
P
<
Expr
>
P
<
Block
>
Option
<
P
<
Expr
>
>
)
While
(
P
<
Expr
>
P
<
Block
>
Option
<
SpannedIdent
>
)
WhileLet
(
P
<
Pat
>
P
<
Expr
>
P
<
Block
>
Option
<
SpannedIdent
>
)
ForLoop
(
P
<
Pat
>
P
<
Expr
>
P
<
Block
>
Option
<
SpannedIdent
>
)
Loop
(
P
<
Block
>
Option
<
SpannedIdent
>
)
Match
(
P
<
Expr
>
Vec
<
Arm
>
)
Closure
(
CaptureBy
P
<
FnDecl
>
P
<
Expr
>
Span
)
Block
(
P
<
Block
>
)
Assign
(
P
<
Expr
>
P
<
Expr
>
)
AssignOp
(
BinOp
P
<
Expr
>
P
<
Expr
>
)
Field
(
P
<
Expr
>
SpannedIdent
)
TupField
(
P
<
Expr
>
Spanned
<
usize
>
)
Index
(
P
<
Expr
>
P
<
Expr
>
)
Range
(
Option
<
P
<
Expr
>
>
Option
<
P
<
Expr
>
>
RangeLimits
)
Path
(
Option
<
QSelf
>
Path
)
AddrOf
(
Mutability
P
<
Expr
>
)
Break
(
Option
<
SpannedIdent
>
Option
<
P
<
Expr
>
>
)
Continue
(
Option
<
SpannedIdent
>
)
Ret
(
Option
<
P
<
Expr
>
>
)
InlineAsm
(
P
<
InlineAsm
>
)
Mac
(
Mac
)
Struct
(
Path
Vec
<
Field
>
Option
<
P
<
Expr
>
>
)
Repeat
(
P
<
Expr
>
P
<
Expr
>
)
Paren
(
P
<
Expr
>
)
Try
(
P
<
Expr
>
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
QSelf
{
pub
ty
:
P
<
Ty
>
pub
position
:
usize
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
CaptureBy
{
Value
Ref
}
pub
type
Mac
=
Spanned
<
Mac_
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Mac_
{
pub
path
:
Path
pub
tts
:
Vec
<
TokenTree
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
StrStyle
{
Cooked
Raw
(
usize
)
}
pub
type
Lit
=
Spanned
<
LitKind
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
LitIntType
{
Signed
(
IntTy
)
Unsigned
(
UintTy
)
Unsuffixed
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
LitKind
{
Str
(
Symbol
StrStyle
)
ByteStr
(
Rc
<
Vec
<
u8
>
>
)
Byte
(
u8
)
Char
(
char
)
Int
(
u64
LitIntType
)
Float
(
Symbol
FloatTy
)
FloatUnsuffixed
(
Symbol
)
Bool
(
bool
)
}
impl
LitKind
{
pub
fn
is_str
(
&
self
)
-
>
bool
{
match
*
self
{
LitKind
:
:
Str
(
.
.
)
=
>
true
_
=
>
false
}
}
pub
fn
is_unsuffixed
(
&
self
)
-
>
bool
{
match
*
self
{
LitKind
:
:
Str
(
.
.
)
=
>
true
LitKind
:
:
ByteStr
(
.
.
)
=
>
true
LitKind
:
:
Byte
(
.
.
)
=
>
true
LitKind
:
:
Char
(
.
.
)
=
>
true
LitKind
:
:
Int
(
_
LitIntType
:
:
Unsuffixed
)
=
>
true
LitKind
:
:
FloatUnsuffixed
(
.
.
)
=
>
true
LitKind
:
:
Bool
(
.
.
)
=
>
true
LitKind
:
:
Int
(
_
LitIntType
:
:
Signed
(
.
.
)
)
=
>
false
LitKind
:
:
Int
(
_
LitIntType
:
:
Unsigned
(
.
.
)
)
=
>
false
LitKind
:
:
Float
(
.
.
)
=
>
false
}
}
pub
fn
is_suffixed
(
&
self
)
-
>
bool
{
!
self
.
is_unsuffixed
(
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
MutTy
{
pub
ty
:
P
<
Ty
>
pub
mutbl
:
Mutability
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
MethodSig
{
pub
unsafety
:
Unsafety
pub
constness
:
Spanned
<
Constness
>
pub
abi
:
Abi
pub
decl
:
P
<
FnDecl
>
pub
generics
:
Generics
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
TraitItem
{
pub
id
:
NodeId
pub
ident
:
Ident
pub
attrs
:
Vec
<
Attribute
>
pub
node
:
TraitItemKind
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
TraitItemKind
{
Const
(
P
<
Ty
>
Option
<
P
<
Expr
>
>
)
Method
(
MethodSig
Option
<
P
<
Block
>
>
)
Type
(
TyParamBounds
Option
<
P
<
Ty
>
>
)
Macro
(
Mac
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
ImplItem
{
pub
id
:
NodeId
pub
ident
:
Ident
pub
vis
:
Visibility
pub
defaultness
:
Defaultness
pub
attrs
:
Vec
<
Attribute
>
pub
node
:
ImplItemKind
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
ImplItemKind
{
Const
(
P
<
Ty
>
P
<
Expr
>
)
Method
(
MethodSig
P
<
Block
>
)
Type
(
P
<
Ty
>
)
Macro
(
Mac
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Copy
)
]
pub
enum
IntTy
{
Is
I8
I16
I32
I64
I128
}
impl
fmt
:
:
Debug
for
IntTy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
IntTy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
ty_to_string
(
)
)
}
}
impl
IntTy
{
pub
fn
ty_to_string
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
IntTy
:
:
Is
=
>
"
isize
"
IntTy
:
:
I8
=
>
"
i8
"
IntTy
:
:
I16
=
>
"
i16
"
IntTy
:
:
I32
=
>
"
i32
"
IntTy
:
:
I64
=
>
"
i64
"
IntTy
:
:
I128
=
>
"
i128
"
}
}
pub
fn
val_to_string
(
&
self
val
:
i64
)
-
>
String
{
format
!
(
"
{
}
{
}
"
val
as
u64
self
.
ty_to_string
(
)
)
}
pub
fn
bit_width
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
match
*
self
{
IntTy
:
:
Is
=
>
return
None
IntTy
:
:
I8
=
>
8
IntTy
:
:
I16
=
>
16
IntTy
:
:
I32
=
>
32
IntTy
:
:
I64
=
>
64
IntTy
:
:
I128
=
>
128
}
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Copy
)
]
pub
enum
UintTy
{
Us
U8
U16
U32
U64
U128
}
impl
UintTy
{
pub
fn
ty_to_string
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
UintTy
:
:
Us
=
>
"
usize
"
UintTy
:
:
U8
=
>
"
u8
"
UintTy
:
:
U16
=
>
"
u16
"
UintTy
:
:
U32
=
>
"
u32
"
UintTy
:
:
U64
=
>
"
u64
"
UintTy
:
:
U128
=
>
"
u128
"
}
}
pub
fn
val_to_string
(
&
self
val
:
u64
)
-
>
String
{
format
!
(
"
{
}
{
}
"
val
self
.
ty_to_string
(
)
)
}
pub
fn
bit_width
(
&
self
)
-
>
Option
<
usize
>
{
Some
(
match
*
self
{
UintTy
:
:
Us
=
>
return
None
UintTy
:
:
U8
=
>
8
UintTy
:
:
U16
=
>
16
UintTy
:
:
U32
=
>
32
UintTy
:
:
U64
=
>
64
UintTy
:
:
U128
=
>
128
}
)
}
}
impl
fmt
:
:
Debug
for
UintTy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
UintTy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
ty_to_string
(
)
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Copy
)
]
pub
enum
FloatTy
{
F32
F64
}
impl
fmt
:
:
Debug
for
FloatTy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
impl
fmt
:
:
Display
for
FloatTy
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
ty_to_string
(
)
)
}
}
impl
FloatTy
{
pub
fn
ty_to_string
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
FloatTy
:
:
F32
=
>
"
f32
"
FloatTy
:
:
F64
=
>
"
f64
"
}
}
pub
fn
bit_width
(
&
self
)
-
>
usize
{
match
*
self
{
FloatTy
:
:
F32
=
>
32
FloatTy
:
:
F64
=
>
64
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
TypeBinding
{
pub
id
:
NodeId
pub
ident
:
Ident
pub
ty
:
P
<
Ty
>
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
struct
Ty
{
pub
id
:
NodeId
pub
node
:
TyKind
pub
span
:
Span
}
impl
fmt
:
:
Debug
for
Ty
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
type
(
{
}
)
"
pprust
:
:
ty_to_string
(
self
)
)
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
BareFnTy
{
pub
unsafety
:
Unsafety
pub
abi
:
Abi
pub
lifetimes
:
Vec
<
LifetimeDef
>
pub
decl
:
P
<
FnDecl
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
TyKind
{
Slice
(
P
<
Ty
>
)
Array
(
P
<
Ty
>
P
<
Expr
>
)
Ptr
(
MutTy
)
Rptr
(
Option
<
Lifetime
>
MutTy
)
BareFn
(
P
<
BareFnTy
>
)
Never
Tup
(
Vec
<
P
<
Ty
>
>
)
Path
(
Option
<
QSelf
>
Path
)
ObjectSum
(
P
<
Ty
>
TyParamBounds
)
PolyTraitRef
(
TyParamBounds
)
ImplTrait
(
TyParamBounds
)
Paren
(
P
<
Ty
>
)
Typeof
(
P
<
Expr
>
)
Infer
ImplicitSelf
Mac
(
Mac
)
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
AsmDialect
{
Att
Intel
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
InlineAsmOutput
{
pub
constraint
:
Symbol
pub
expr
:
P
<
Expr
>
pub
is_rw
:
bool
pub
is_indirect
:
bool
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
InlineAsm
{
pub
asm
:
Symbol
pub
asm_str_style
:
StrStyle
pub
outputs
:
Vec
<
InlineAsmOutput
>
pub
inputs
:
Vec
<
(
Symbol
P
<
Expr
>
)
>
pub
clobbers
:
Vec
<
Symbol
>
pub
volatile
:
bool
pub
alignstack
:
bool
pub
dialect
:
AsmDialect
pub
expn_id
:
ExpnId
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Arg
{
pub
ty
:
P
<
Ty
>
pub
pat
:
P
<
Pat
>
pub
id
:
NodeId
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
SelfKind
{
Value
(
Mutability
)
Region
(
Option
<
Lifetime
>
Mutability
)
Explicit
(
P
<
Ty
>
Mutability
)
}
pub
type
ExplicitSelf
=
Spanned
<
SelfKind
>
;
impl
Arg
{
pub
fn
to_self
(
&
self
)
-
>
Option
<
ExplicitSelf
>
{
if
let
PatKind
:
:
Ident
(
BindingMode
:
:
ByValue
(
mutbl
)
ident
_
)
=
self
.
pat
.
node
{
if
ident
.
node
.
name
=
=
keywords
:
:
SelfValue
.
name
(
)
{
return
match
self
.
ty
.
node
{
TyKind
:
:
ImplicitSelf
=
>
Some
(
respan
(
self
.
pat
.
span
SelfKind
:
:
Value
(
mutbl
)
)
)
TyKind
:
:
Rptr
(
lt
MutTy
{
ref
ty
mutbl
}
)
if
ty
.
node
=
=
TyKind
:
:
ImplicitSelf
=
>
{
Some
(
respan
(
self
.
pat
.
span
SelfKind
:
:
Region
(
lt
mutbl
)
)
)
}
_
=
>
Some
(
respan
(
mk_sp
(
self
.
pat
.
span
.
lo
self
.
ty
.
span
.
hi
)
SelfKind
:
:
Explicit
(
self
.
ty
.
clone
(
)
mutbl
)
)
)
}
}
}
None
}
pub
fn
is_self
(
&
self
)
-
>
bool
{
if
let
PatKind
:
:
Ident
(
_
ident
_
)
=
self
.
pat
.
node
{
ident
.
node
.
name
=
=
keywords
:
:
SelfValue
.
name
(
)
}
else
{
false
}
}
pub
fn
from_self
(
eself
:
ExplicitSelf
eself_ident
:
SpannedIdent
)
-
>
Arg
{
let
span
=
mk_sp
(
eself
.
span
.
lo
eself_ident
.
span
.
hi
)
;
let
infer_ty
=
P
(
Ty
{
id
:
DUMMY_NODE_ID
node
:
TyKind
:
:
ImplicitSelf
span
:
span
}
)
;
let
arg
=
|
mutbl
ty
|
Arg
{
pat
:
P
(
Pat
{
id
:
DUMMY_NODE_ID
node
:
PatKind
:
:
Ident
(
BindingMode
:
:
ByValue
(
mutbl
)
eself_ident
None
)
span
:
span
}
)
ty
:
ty
id
:
DUMMY_NODE_ID
}
;
match
eself
.
node
{
SelfKind
:
:
Explicit
(
ty
mutbl
)
=
>
arg
(
mutbl
ty
)
SelfKind
:
:
Value
(
mutbl
)
=
>
arg
(
mutbl
infer_ty
)
SelfKind
:
:
Region
(
lt
mutbl
)
=
>
arg
(
Mutability
:
:
Immutable
P
(
Ty
{
id
:
DUMMY_NODE_ID
node
:
TyKind
:
:
Rptr
(
lt
MutTy
{
ty
:
infer_ty
mutbl
:
mutbl
}
)
span
:
span
}
)
)
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
FnDecl
{
pub
inputs
:
Vec
<
Arg
>
pub
output
:
FunctionRetTy
pub
variadic
:
bool
}
impl
FnDecl
{
pub
fn
get_self
(
&
self
)
-
>
Option
<
ExplicitSelf
>
{
self
.
inputs
.
get
(
0
)
.
and_then
(
Arg
:
:
to_self
)
}
pub
fn
has_self
(
&
self
)
-
>
bool
{
self
.
inputs
.
get
(
0
)
.
map
(
Arg
:
:
is_self
)
.
unwrap_or
(
false
)
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
Unsafety
{
Unsafe
Normal
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
Constness
{
Const
NotConst
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
Defaultness
{
Default
Final
}
impl
fmt
:
:
Display
for
Unsafety
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Display
:
:
fmt
(
match
*
self
{
Unsafety
:
:
Normal
=
>
"
normal
"
Unsafety
:
:
Unsafe
=
>
"
unsafe
"
}
f
)
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
)
]
pub
enum
ImplPolarity
{
Positive
Negative
}
impl
fmt
:
:
Debug
for
ImplPolarity
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
ImplPolarity
:
:
Positive
=
>
"
positive
"
.
fmt
(
f
)
ImplPolarity
:
:
Negative
=
>
"
negative
"
.
fmt
(
f
)
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
FunctionRetTy
{
Default
(
Span
)
Ty
(
P
<
Ty
>
)
}
impl
FunctionRetTy
{
pub
fn
span
(
&
self
)
-
>
Span
{
match
*
self
{
FunctionRetTy
:
:
Default
(
span
)
=
>
span
FunctionRetTy
:
:
Ty
(
ref
ty
)
=
>
ty
.
span
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Mod
{
pub
inner
:
Span
pub
items
:
Vec
<
P
<
Item
>
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
ForeignMod
{
pub
abi
:
Abi
pub
items
:
Vec
<
ForeignItem
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
EnumDef
{
pub
variants
:
Vec
<
Variant
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Variant_
{
pub
name
:
Ident
pub
attrs
:
Vec
<
Attribute
>
pub
data
:
VariantData
pub
disr_expr
:
Option
<
P
<
Expr
>
>
}
pub
type
Variant
=
Spanned
<
Variant_
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
struct
PathListItem_
{
pub
name
:
Ident
pub
rename
:
Option
<
Ident
>
pub
id
:
NodeId
}
pub
type
PathListItem
=
Spanned
<
PathListItem_
>
;
pub
type
ViewPath
=
Spanned
<
ViewPath_
>
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
ViewPath_
{
ViewPathSimple
(
Ident
Path
)
ViewPathGlob
(
Path
)
ViewPathList
(
Path
Vec
<
PathListItem
>
)
}
impl
ViewPath_
{
pub
fn
path
(
&
self
)
-
>
&
Path
{
match
*
self
{
ViewPathSimple
(
_
ref
path
)
|
ViewPathGlob
(
ref
path
)
|
ViewPathList
(
ref
path
_
)
=
>
path
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
enum
AttrStyle
{
Outer
Inner
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
Copy
)
]
pub
struct
AttrId
(
pub
usize
)
;
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Attribute
{
pub
id
:
AttrId
pub
style
:
AttrStyle
pub
value
:
MetaItem
pub
is_sugared_doc
:
bool
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
TraitRef
{
pub
path
:
Path
pub
ref_id
:
NodeId
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
PolyTraitRef
{
pub
bound_lifetimes
:
Vec
<
LifetimeDef
>
pub
trait_ref
:
TraitRef
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
Visibility
{
Public
Crate
(
Span
)
Restricted
{
path
:
P
<
Path
>
id
:
NodeId
}
Inherited
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
StructField
{
pub
span
:
Span
pub
ident
:
Option
<
Ident
>
pub
vis
:
Visibility
pub
id
:
NodeId
pub
ty
:
P
<
Ty
>
pub
attrs
:
Vec
<
Attribute
>
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
VariantData
{
Struct
(
Vec
<
StructField
>
NodeId
)
Tuple
(
Vec
<
StructField
>
NodeId
)
Unit
(
NodeId
)
}
impl
VariantData
{
pub
fn
fields
(
&
self
)
-
>
&
[
StructField
]
{
match
*
self
{
VariantData
:
:
Struct
(
ref
fields
_
)
|
VariantData
:
:
Tuple
(
ref
fields
_
)
=
>
fields
_
=
>
&
[
]
}
}
pub
fn
id
(
&
self
)
-
>
NodeId
{
match
*
self
{
VariantData
:
:
Struct
(
_
id
)
|
VariantData
:
:
Tuple
(
_
id
)
|
VariantData
:
:
Unit
(
id
)
=
>
id
}
}
pub
fn
is_struct
(
&
self
)
-
>
bool
{
if
let
VariantData
:
:
Struct
(
.
.
)
=
*
self
{
true
}
else
{
false
}
}
pub
fn
is_tuple
(
&
self
)
-
>
bool
{
if
let
VariantData
:
:
Tuple
(
.
.
)
=
*
self
{
true
}
else
{
false
}
}
pub
fn
is_unit
(
&
self
)
-
>
bool
{
if
let
VariantData
:
:
Unit
(
.
.
)
=
*
self
{
true
}
else
{
false
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
Item
{
pub
ident
:
Ident
pub
attrs
:
Vec
<
Attribute
>
pub
id
:
NodeId
pub
node
:
ItemKind
pub
vis
:
Visibility
pub
span
:
Span
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
ItemKind
{
ExternCrate
(
Option
<
Name
>
)
Use
(
P
<
ViewPath
>
)
Static
(
P
<
Ty
>
Mutability
P
<
Expr
>
)
Const
(
P
<
Ty
>
P
<
Expr
>
)
Fn
(
P
<
FnDecl
>
Unsafety
Spanned
<
Constness
>
Abi
Generics
P
<
Block
>
)
Mod
(
Mod
)
ForeignMod
(
ForeignMod
)
Ty
(
P
<
Ty
>
Generics
)
Enum
(
EnumDef
Generics
)
Struct
(
VariantData
Generics
)
Union
(
VariantData
Generics
)
Trait
(
Unsafety
Generics
TyParamBounds
Vec
<
TraitItem
>
)
DefaultImpl
(
Unsafety
TraitRef
)
Impl
(
Unsafety
ImplPolarity
Generics
Option
<
TraitRef
>
P
<
Ty
>
Vec
<
ImplItem
>
)
Mac
(
Mac
)
}
impl
ItemKind
{
pub
fn
descriptive_variant
(
&
self
)
-
>
&
str
{
match
*
self
{
ItemKind
:
:
ExternCrate
(
.
.
)
=
>
"
extern
crate
"
ItemKind
:
:
Use
(
.
.
)
=
>
"
use
"
ItemKind
:
:
Static
(
.
.
)
=
>
"
static
item
"
ItemKind
:
:
Const
(
.
.
)
=
>
"
constant
item
"
ItemKind
:
:
Fn
(
.
.
)
=
>
"
function
"
ItemKind
:
:
Mod
(
.
.
)
=
>
"
module
"
ItemKind
:
:
ForeignMod
(
.
.
)
=
>
"
foreign
module
"
ItemKind
:
:
Ty
(
.
.
)
=
>
"
type
alias
"
ItemKind
:
:
Enum
(
.
.
)
=
>
"
enum
"
ItemKind
:
:
Struct
(
.
.
)
=
>
"
struct
"
ItemKind
:
:
Union
(
.
.
)
=
>
"
union
"
ItemKind
:
:
Trait
(
.
.
)
=
>
"
trait
"
ItemKind
:
:
Mac
(
.
.
)
|
ItemKind
:
:
Impl
(
.
.
)
|
ItemKind
:
:
DefaultImpl
(
.
.
)
=
>
"
item
"
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
ForeignItem
{
pub
ident
:
Ident
pub
attrs
:
Vec
<
Attribute
>
pub
node
:
ForeignItemKind
pub
id
:
NodeId
pub
span
:
Span
pub
vis
:
Visibility
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
enum
ForeignItemKind
{
Fn
(
P
<
FnDecl
>
Generics
)
Static
(
P
<
Ty
>
bool
)
}
impl
ForeignItemKind
{
pub
fn
descriptive_variant
(
&
self
)
-
>
&
str
{
match
*
self
{
ForeignItemKind
:
:
Fn
(
.
.
)
=
>
"
foreign
function
"
ForeignItemKind
:
:
Static
(
.
.
)
=
>
"
foreign
static
item
"
}
}
}
#
[
derive
(
Clone
PartialEq
Eq
RustcEncodable
RustcDecodable
Hash
Debug
)
]
pub
struct
MacroDef
{
pub
ident
:
Ident
pub
attrs
:
Vec
<
Attribute
>
pub
id
:
NodeId
pub
span
:
Span
pub
body
:
Vec
<
TokenTree
>
}
#
[
cfg
(
test
)
]
mod
tests
{
use
serialize
;
use
super
:
:
*
;
#
[
test
]
fn
check_asts_encodable
(
)
{
fn
assert_encodable
<
T
:
serialize
:
:
Encodable
>
(
)
{
}
assert_encodable
:
:
<
Crate
>
(
)
;
}
}
