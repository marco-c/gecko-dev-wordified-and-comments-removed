use
ast
;
use
syntax_pos
:
:
{
self
Pos
Span
}
;
use
ext
:
:
base
:
:
*
;
use
ext
:
:
base
;
use
ext
:
:
build
:
:
AstBuilder
;
use
parse
:
:
{
token
DirectoryOwnership
}
;
use
parse
;
use
print
:
:
pprust
;
use
ptr
:
:
P
;
use
symbol
:
:
Symbol
;
use
tokenstream
;
use
util
:
:
small_vector
:
:
SmallVector
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
prelude
:
:
*
;
use
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
std
:
:
rc
:
:
Rc
;
pub
fn
expand_line
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
base
:
:
check_zero_tts
(
cx
sp
tts
"
line
!
"
)
;
let
topmost
=
cx
.
expansion_cause
(
)
;
let
loc
=
cx
.
codemap
(
)
.
lookup_char_pos
(
topmost
.
lo
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_u32
(
topmost
loc
.
line
as
u32
)
)
}
pub
fn
expand_column
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
base
:
:
check_zero_tts
(
cx
sp
tts
"
column
!
"
)
;
let
topmost
=
cx
.
expansion_cause
(
)
;
let
loc
=
cx
.
codemap
(
)
.
lookup_char_pos
(
topmost
.
lo
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_u32
(
topmost
loc
.
col
.
to_usize
(
)
as
u32
)
)
}
pub
fn
expand_file
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
base
:
:
check_zero_tts
(
cx
sp
tts
"
file
!
"
)
;
let
topmost
=
cx
.
expansion_cause
(
)
;
let
loc
=
cx
.
codemap
(
)
.
lookup_char_pos
(
topmost
.
lo
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_str
(
topmost
Symbol
:
:
intern
(
&
loc
.
file
.
name
)
)
)
}
pub
fn
expand_stringify
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
let
s
=
pprust
:
:
tts_to_string
(
tts
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_str
(
sp
Symbol
:
:
intern
(
&
s
)
)
)
}
pub
fn
expand_mod
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
base
:
:
check_zero_tts
(
cx
sp
tts
"
module_path
!
"
)
;
let
mod_path
=
&
cx
.
current_expansion
.
module
.
mod_path
;
let
string
=
mod_path
.
iter
(
)
.
map
(
|
x
|
x
.
to_string
(
)
)
.
collect
:
:
<
Vec
<
String
>
>
(
)
.
join
(
"
:
:
"
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_str
(
sp
Symbol
:
:
intern
(
&
string
)
)
)
}
pub
fn
expand_include
<
'
cx
>
(
cx
:
&
'
cx
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
cx
>
{
let
file
=
match
get_single_str_from_tts
(
cx
sp
tts
"
include
!
"
)
{
Some
(
f
)
=
>
f
None
=
>
return
DummyResult
:
:
expr
(
sp
)
}
;
let
path
=
res_rel_file
(
cx
sp
Path
:
:
new
(
&
file
)
)
;
let
directory_ownership
=
DirectoryOwnership
:
:
Owned
;
let
p
=
parse
:
:
new_sub_parser_from_file
(
cx
.
parse_sess
(
)
&
path
directory_ownership
None
sp
)
;
struct
ExpandResult
<
'
a
>
{
p
:
parse
:
:
parser
:
:
Parser
<
'
a
>
}
impl
<
'
a
>
base
:
:
MacResult
for
ExpandResult
<
'
a
>
{
fn
make_expr
(
mut
self
:
Box
<
ExpandResult
<
'
a
>
>
)
-
>
Option
<
P
<
ast
:
:
Expr
>
>
{
Some
(
panictry
!
(
self
.
p
.
parse_expr
(
)
)
)
}
fn
make_items
(
mut
self
:
Box
<
ExpandResult
<
'
a
>
>
)
-
>
Option
<
SmallVector
<
P
<
ast
:
:
Item
>
>
>
{
let
mut
ret
=
SmallVector
:
:
new
(
)
;
while
self
.
p
.
token
!
=
token
:
:
Eof
{
match
panictry
!
(
self
.
p
.
parse_item
(
)
)
{
Some
(
item
)
=
>
ret
.
push
(
item
)
None
=
>
panic
!
(
self
.
p
.
diagnostic
(
)
.
span_fatal
(
self
.
p
.
span
&
format
!
(
"
expected
item
found
{
}
"
self
.
p
.
this_token_to_string
(
)
)
)
)
}
}
Some
(
ret
)
}
}
Box
:
:
new
(
ExpandResult
{
p
:
p
}
)
}
pub
fn
expand_include_str
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
let
file
=
match
get_single_str_from_tts
(
cx
sp
tts
"
include_str
!
"
)
{
Some
(
f
)
=
>
f
None
=
>
return
DummyResult
:
:
expr
(
sp
)
}
;
let
file
=
res_rel_file
(
cx
sp
Path
:
:
new
(
&
file
)
)
;
let
mut
bytes
=
Vec
:
:
new
(
)
;
match
File
:
:
open
(
&
file
)
.
and_then
(
|
mut
f
|
f
.
read_to_end
(
&
mut
bytes
)
)
{
Ok
(
.
.
)
=
>
{
}
Err
(
e
)
=
>
{
cx
.
span_err
(
sp
&
format
!
(
"
couldn
'
t
read
{
}
:
{
}
"
file
.
display
(
)
e
)
)
;
return
DummyResult
:
:
expr
(
sp
)
;
}
}
;
match
String
:
:
from_utf8
(
bytes
)
{
Ok
(
src
)
=
>
{
let
filename
=
format
!
(
"
{
}
"
file
.
display
(
)
)
;
cx
.
codemap
(
)
.
new_filemap_and_lines
(
&
filename
None
&
src
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_str
(
sp
Symbol
:
:
intern
(
&
src
)
)
)
}
Err
(
_
)
=
>
{
cx
.
span_err
(
sp
&
format
!
(
"
{
}
wasn
'
t
a
utf
-
8
file
"
file
.
display
(
)
)
)
;
return
DummyResult
:
:
expr
(
sp
)
;
}
}
}
pub
fn
expand_include_bytes
(
cx
:
&
mut
ExtCtxt
sp
:
Span
tts
:
&
[
tokenstream
:
:
TokenTree
]
)
-
>
Box
<
base
:
:
MacResult
+
'
static
>
{
let
file
=
match
get_single_str_from_tts
(
cx
sp
tts
"
include_bytes
!
"
)
{
Some
(
f
)
=
>
f
None
=
>
return
DummyResult
:
:
expr
(
sp
)
}
;
let
file
=
res_rel_file
(
cx
sp
Path
:
:
new
(
&
file
)
)
;
let
mut
bytes
=
Vec
:
:
new
(
)
;
match
File
:
:
open
(
&
file
)
.
and_then
(
|
mut
f
|
f
.
read_to_end
(
&
mut
bytes
)
)
{
Err
(
e
)
=
>
{
cx
.
span_err
(
sp
&
format
!
(
"
couldn
'
t
read
{
}
:
{
}
"
file
.
display
(
)
e
)
)
;
return
DummyResult
:
:
expr
(
sp
)
;
}
Ok
(
.
.
)
=
>
{
let
filename
=
format
!
(
"
{
}
"
file
.
display
(
)
)
;
cx
.
codemap
(
)
.
new_filemap_and_lines
(
&
filename
None
"
"
)
;
base
:
:
MacEager
:
:
expr
(
cx
.
expr_lit
(
sp
ast
:
:
LitKind
:
:
ByteStr
(
Rc
:
:
new
(
bytes
)
)
)
)
}
}
}
fn
res_rel_file
(
cx
:
&
mut
ExtCtxt
sp
:
syntax_pos
:
:
Span
arg
:
&
Path
)
-
>
PathBuf
{
if
!
arg
.
is_absolute
(
)
{
let
callsite
=
cx
.
codemap
(
)
.
source_callsite
(
sp
)
;
let
mut
cu
=
PathBuf
:
:
from
(
&
cx
.
codemap
(
)
.
span_to_filename
(
callsite
)
)
;
cu
.
pop
(
)
;
cu
.
push
(
arg
)
;
cu
}
else
{
arg
.
to_path_buf
(
)
}
}
