use
ast
:
:
NodeId
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
fmt
;
#
[
derive
(
Clone
Copy
PartialEq
Eq
Hash
RustcEncodable
RustcDecodable
Default
)
]
pub
struct
SyntaxContext
(
pub
u32
)
;
#
[
derive
(
Copy
Clone
)
]
pub
struct
SyntaxContextData
{
pub
outer_mark
:
Mark
pub
prev_ctxt
:
SyntaxContext
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
Debug
Default
)
]
pub
struct
Mark
(
u32
)
;
impl
Mark
{
pub
fn
fresh
(
)
-
>
Self
{
HygieneData
:
:
with
(
|
data
|
{
let
next_mark
=
Mark
(
data
.
next_mark
.
0
+
1
)
;
:
:
std
:
:
mem
:
:
replace
(
&
mut
data
.
next_mark
next_mark
)
}
)
}
pub
fn
root
(
)
-
>
Self
{
Mark
(
0
)
}
pub
fn
from_placeholder_id
(
id
:
NodeId
)
-
>
Self
{
Mark
(
id
.
as_u32
(
)
)
}
pub
fn
as_u32
(
&
self
)
-
>
u32
{
self
.
0
}
}
struct
HygieneData
{
syntax_contexts
:
Vec
<
SyntaxContextData
>
markings
:
HashMap
<
(
SyntaxContext
Mark
)
SyntaxContext
>
next_mark
:
Mark
}
impl
HygieneData
{
fn
new
(
)
-
>
Self
{
HygieneData
{
syntax_contexts
:
vec
!
[
SyntaxContextData
{
outer_mark
:
Mark
:
:
root
(
)
prev_ctxt
:
SyntaxContext
:
:
empty
(
)
}
]
markings
:
HashMap
:
:
new
(
)
next_mark
:
Mark
(
1
)
}
}
fn
with
<
T
F
:
FnOnce
(
&
mut
HygieneData
)
-
>
T
>
(
f
:
F
)
-
>
T
{
thread_local
!
{
static
HYGIENE_DATA
:
RefCell
<
HygieneData
>
=
RefCell
:
:
new
(
HygieneData
:
:
new
(
)
)
}
HYGIENE_DATA
.
with
(
|
data
|
f
(
&
mut
*
data
.
borrow_mut
(
)
)
)
}
}
pub
fn
reset_hygiene_data
(
)
{
HygieneData
:
:
with
(
|
data
|
*
data
=
HygieneData
:
:
new
(
)
)
}
impl
SyntaxContext
{
pub
fn
empty
(
)
-
>
Self
{
SyntaxContext
(
0
)
}
pub
fn
data
(
self
)
-
>
SyntaxContextData
{
HygieneData
:
:
with
(
|
data
|
data
.
syntax_contexts
[
self
.
0
as
usize
]
)
}
pub
fn
apply_mark
(
self
mark
:
Mark
)
-
>
SyntaxContext
{
let
ctxt_data
=
self
.
data
(
)
;
if
mark
=
=
ctxt_data
.
outer_mark
{
return
ctxt_data
.
prev_ctxt
;
}
HygieneData
:
:
with
(
|
data
|
{
let
syntax_contexts
=
&
mut
data
.
syntax_contexts
;
*
data
.
markings
.
entry
(
(
self
mark
)
)
.
or_insert_with
(
|
|
{
syntax_contexts
.
push
(
SyntaxContextData
{
outer_mark
:
mark
prev_ctxt
:
self
}
)
;
SyntaxContext
(
syntax_contexts
.
len
(
)
as
u32
-
1
)
}
)
}
)
}
pub
fn
source
(
self
)
-
>
(
Self
Mark
)
{
let
macro_def_ctxt
=
self
.
data
(
)
.
prev_ctxt
.
data
(
)
;
(
macro_def_ctxt
.
prev_ctxt
macro_def_ctxt
.
outer_mark
)
}
}
impl
fmt
:
:
Debug
for
SyntaxContext
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
#
{
}
"
self
.
0
)
}
}
