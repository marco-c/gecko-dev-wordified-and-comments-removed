use
std
:
:
cmp
;
use
symbol
:
:
Symbol
;
pub
fn
lev_distance
(
a
:
&
str
b
:
&
str
)
-
>
usize
{
if
a
.
is_empty
(
)
{
return
b
.
chars
(
)
.
count
(
)
;
}
else
if
b
.
is_empty
(
)
{
return
a
.
chars
(
)
.
count
(
)
;
}
let
mut
dcol
:
Vec
<
_
>
=
(
0
.
.
b
.
len
(
)
+
1
)
.
collect
(
)
;
let
mut
t_last
=
0
;
for
(
i
sc
)
in
a
.
chars
(
)
.
enumerate
(
)
{
let
mut
current
=
i
;
dcol
[
0
]
=
current
+
1
;
for
(
j
tc
)
in
b
.
chars
(
)
.
enumerate
(
)
{
let
next
=
dcol
[
j
+
1
]
;
if
sc
=
=
tc
{
dcol
[
j
+
1
]
=
current
;
}
else
{
dcol
[
j
+
1
]
=
cmp
:
:
min
(
current
next
)
;
dcol
[
j
+
1
]
=
cmp
:
:
min
(
dcol
[
j
+
1
]
dcol
[
j
]
)
+
1
;
}
current
=
next
;
t_last
=
j
;
}
}
dcol
[
t_last
+
1
]
}
pub
fn
find_best_match_for_name
<
'
a
T
>
(
iter_names
:
T
lookup
:
&
str
dist
:
Option
<
usize
>
)
-
>
Option
<
Symbol
>
where
T
:
Iterator
<
Item
=
&
'
a
Symbol
>
{
let
max_dist
=
dist
.
map_or_else
(
|
|
cmp
:
:
max
(
lookup
.
len
(
)
3
)
/
3
|
d
|
d
)
;
iter_names
.
filter_map
(
|
&
name
|
{
let
dist
=
lev_distance
(
lookup
&
name
.
as_str
(
)
)
;
match
dist
<
=
max_dist
{
true
=
>
Some
(
(
name
dist
)
)
false
=
>
None
}
}
)
.
min_by_key
(
|
&
(
_
val
)
|
val
)
.
map
(
|
(
s
_
)
|
s
)
}
#
[
test
]
fn
test_lev_distance
(
)
{
use
std
:
:
char
:
:
{
from_u32
MAX
}
;
for
c
in
(
0
.
.
MAX
as
u32
)
.
filter_map
(
|
i
|
from_u32
(
i
)
)
.
map
(
|
i
|
i
.
to_string
(
)
)
{
assert_eq
!
(
lev_distance
(
&
c
[
.
.
]
&
c
[
.
.
]
)
0
)
;
}
let
a
=
"
\
nM
ry
h
d
little
l
mb
\
n
\
nLittle
l
mb
\
n
"
;
let
b
=
"
\
nMary
h
d
little
l
mb
\
n
\
nLittle
l
mb
\
n
"
;
let
c
=
"
Mary
h
d
little
l
mb
\
n
\
nLittle
l
mb
\
n
"
;
assert_eq
!
(
lev_distance
(
a
b
)
1
)
;
assert_eq
!
(
lev_distance
(
b
a
)
1
)
;
assert_eq
!
(
lev_distance
(
a
c
)
2
)
;
assert_eq
!
(
lev_distance
(
c
a
)
2
)
;
assert_eq
!
(
lev_distance
(
b
c
)
1
)
;
assert_eq
!
(
lev_distance
(
c
b
)
1
)
;
}
