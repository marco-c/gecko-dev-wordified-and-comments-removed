use
codemap
:
:
CodeMap
;
use
syntax_pos
:
:
{
self
MacroBacktrace
Span
SpanLabel
MultiSpan
}
;
use
errors
:
:
registry
:
:
Registry
;
use
errors
:
:
{
DiagnosticBuilder
SubDiagnostic
RenderSpan
CodeSuggestion
CodeMapper
}
;
use
errors
:
:
emitter
:
:
Emitter
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
vec
;
use
rustc_serialize
:
:
json
:
:
as_json
;
pub
struct
JsonEmitter
{
dst
:
Box
<
Write
+
Send
>
registry
:
Option
<
Registry
>
cm
:
Rc
<
CodeMapper
+
'
static
>
}
impl
JsonEmitter
{
pub
fn
stderr
(
registry
:
Option
<
Registry
>
code_map
:
Rc
<
CodeMap
>
)
-
>
JsonEmitter
{
JsonEmitter
{
dst
:
Box
:
:
new
(
io
:
:
stderr
(
)
)
registry
:
registry
cm
:
code_map
}
}
pub
fn
basic
(
)
-
>
JsonEmitter
{
JsonEmitter
:
:
stderr
(
None
Rc
:
:
new
(
CodeMap
:
:
new
(
)
)
)
}
pub
fn
new
(
dst
:
Box
<
Write
+
Send
>
registry
:
Option
<
Registry
>
code_map
:
Rc
<
CodeMap
>
)
-
>
JsonEmitter
{
JsonEmitter
{
dst
:
dst
registry
:
registry
cm
:
code_map
}
}
}
impl
Emitter
for
JsonEmitter
{
fn
emit
(
&
mut
self
db
:
&
DiagnosticBuilder
)
{
let
data
=
Diagnostic
:
:
from_diagnostic_builder
(
db
self
)
;
if
let
Err
(
e
)
=
writeln
!
(
&
mut
self
.
dst
"
{
}
"
as_json
(
&
data
)
)
{
panic
!
(
"
failed
to
print
diagnostics
:
{
:
?
}
"
e
)
;
}
}
}
#
[
derive
(
RustcEncodable
)
]
struct
Diagnostic
<
'
a
>
{
message
:
&
'
a
str
code
:
Option
<
DiagnosticCode
>
level
:
&
'
static
str
spans
:
Vec
<
DiagnosticSpan
>
children
:
Vec
<
Diagnostic
<
'
a
>
>
rendered
:
Option
<
String
>
}
#
[
derive
(
RustcEncodable
)
]
struct
DiagnosticSpan
{
file_name
:
String
byte_start
:
u32
byte_end
:
u32
line_start
:
usize
line_end
:
usize
column_start
:
usize
column_end
:
usize
is_primary
:
bool
text
:
Vec
<
DiagnosticSpanLine
>
label
:
Option
<
String
>
suggested_replacement
:
Option
<
String
>
expansion
:
Option
<
Box
<
DiagnosticSpanMacroExpansion
>
>
}
#
[
derive
(
RustcEncodable
)
]
struct
DiagnosticSpanLine
{
text
:
String
highlight_start
:
usize
highlight_end
:
usize
}
#
[
derive
(
RustcEncodable
)
]
struct
DiagnosticSpanMacroExpansion
{
span
:
DiagnosticSpan
macro_decl_name
:
String
def_site_span
:
Option
<
DiagnosticSpan
>
}
#
[
derive
(
RustcEncodable
)
]
struct
DiagnosticCode
{
code
:
String
explanation
:
Option
<
&
'
static
str
>
}
impl
<
'
a
>
Diagnostic
<
'
a
>
{
fn
from_diagnostic_builder
<
'
c
>
(
db
:
&
'
c
DiagnosticBuilder
je
:
&
JsonEmitter
)
-
>
Diagnostic
<
'
c
>
{
Diagnostic
{
message
:
&
db
.
message
code
:
DiagnosticCode
:
:
map_opt_string
(
db
.
code
.
clone
(
)
je
)
level
:
db
.
level
.
to_str
(
)
spans
:
DiagnosticSpan
:
:
from_multispan
(
&
db
.
span
je
)
children
:
db
.
children
.
iter
(
)
.
map
(
|
c
|
{
Diagnostic
:
:
from_sub_diagnostic
(
c
je
)
}
)
.
collect
(
)
rendered
:
None
}
}
fn
from_sub_diagnostic
<
'
c
>
(
db
:
&
'
c
SubDiagnostic
je
:
&
JsonEmitter
)
-
>
Diagnostic
<
'
c
>
{
Diagnostic
{
message
:
&
db
.
message
code
:
None
level
:
db
.
level
.
to_str
(
)
spans
:
db
.
render_span
.
as_ref
(
)
.
map
(
|
sp
|
DiagnosticSpan
:
:
from_render_span
(
sp
je
)
)
.
unwrap_or_else
(
|
|
DiagnosticSpan
:
:
from_multispan
(
&
db
.
span
je
)
)
children
:
vec
!
[
]
rendered
:
db
.
render_span
.
as_ref
(
)
.
and_then
(
|
rsp
|
je
.
render
(
rsp
)
)
}
}
}
impl
DiagnosticSpan
{
fn
from_span_label
(
span
:
SpanLabel
suggestion
:
Option
<
&
String
>
je
:
&
JsonEmitter
)
-
>
DiagnosticSpan
{
Self
:
:
from_span_etc
(
span
.
span
span
.
is_primary
span
.
label
suggestion
je
)
}
fn
from_span_etc
(
span
:
Span
is_primary
:
bool
label
:
Option
<
String
>
suggestion
:
Option
<
&
String
>
je
:
&
JsonEmitter
)
-
>
DiagnosticSpan
{
let
backtrace
=
je
.
cm
.
macro_backtrace
(
span
)
.
into_iter
(
)
;
DiagnosticSpan
:
:
from_span_full
(
span
is_primary
label
suggestion
backtrace
je
)
}
fn
from_span_full
(
span
:
Span
is_primary
:
bool
label
:
Option
<
String
>
suggestion
:
Option
<
&
String
>
mut
backtrace
:
vec
:
:
IntoIter
<
MacroBacktrace
>
je
:
&
JsonEmitter
)
-
>
DiagnosticSpan
{
let
start
=
je
.
cm
.
lookup_char_pos
(
span
.
lo
)
;
let
end
=
je
.
cm
.
lookup_char_pos
(
span
.
hi
)
;
let
backtrace_step
=
backtrace
.
next
(
)
.
map
(
|
bt
|
{
let
call_site
=
Self
:
:
from_span_full
(
bt
.
call_site
false
None
None
backtrace
je
)
;
let
def_site_span
=
bt
.
def_site_span
.
map
(
|
sp
|
{
Self
:
:
from_span_full
(
sp
false
None
None
vec
!
[
]
.
into_iter
(
)
je
)
}
)
;
Box
:
:
new
(
DiagnosticSpanMacroExpansion
{
span
:
call_site
macro_decl_name
:
bt
.
macro_decl_name
def_site_span
:
def_site_span
}
)
}
)
;
DiagnosticSpan
{
file_name
:
start
.
file
.
name
.
clone
(
)
byte_start
:
span
.
lo
.
0
byte_end
:
span
.
hi
.
0
line_start
:
start
.
line
line_end
:
end
.
line
column_start
:
start
.
col
.
0
+
1
column_end
:
end
.
col
.
0
+
1
is_primary
:
is_primary
text
:
DiagnosticSpanLine
:
:
from_span
(
span
je
)
suggested_replacement
:
suggestion
.
cloned
(
)
expansion
:
backtrace_step
label
:
label
}
}
fn
from_multispan
(
msp
:
&
MultiSpan
je
:
&
JsonEmitter
)
-
>
Vec
<
DiagnosticSpan
>
{
msp
.
span_labels
(
)
.
into_iter
(
)
.
map
(
|
span_str
|
Self
:
:
from_span_label
(
span_str
None
je
)
)
.
collect
(
)
}
fn
from_suggestion
(
suggestion
:
&
CodeSuggestion
je
:
&
JsonEmitter
)
-
>
Vec
<
DiagnosticSpan
>
{
assert_eq
!
(
suggestion
.
msp
.
span_labels
(
)
.
len
(
)
suggestion
.
substitutes
.
len
(
)
)
;
suggestion
.
msp
.
span_labels
(
)
.
into_iter
(
)
.
zip
(
&
suggestion
.
substitutes
)
.
map
(
|
(
span_label
suggestion
)
|
{
DiagnosticSpan
:
:
from_span_label
(
span_label
Some
(
suggestion
)
je
)
}
)
.
collect
(
)
}
fn
from_render_span
(
rsp
:
&
RenderSpan
je
:
&
JsonEmitter
)
-
>
Vec
<
DiagnosticSpan
>
{
match
*
rsp
{
RenderSpan
:
:
FullSpan
(
ref
msp
)
=
>
DiagnosticSpan
:
:
from_multispan
(
msp
je
)
RenderSpan
:
:
Suggestion
(
ref
suggestion
)
=
>
DiagnosticSpan
:
:
from_suggestion
(
suggestion
je
)
}
}
}
impl
DiagnosticSpanLine
{
fn
line_from_filemap
(
fm
:
&
syntax_pos
:
:
FileMap
index
:
usize
h_start
:
usize
h_end
:
usize
)
-
>
DiagnosticSpanLine
{
DiagnosticSpanLine
{
text
:
fm
.
get_line
(
index
)
.
unwrap
(
)
.
to_owned
(
)
highlight_start
:
h_start
highlight_end
:
h_end
}
}
fn
from_span
(
span
:
Span
je
:
&
JsonEmitter
)
-
>
Vec
<
DiagnosticSpanLine
>
{
je
.
cm
.
span_to_lines
(
span
)
.
map
(
|
lines
|
{
let
fm
=
&
*
lines
.
file
;
lines
.
lines
.
iter
(
)
.
map
(
|
line
|
{
DiagnosticSpanLine
:
:
line_from_filemap
(
fm
line
.
line_index
line
.
start_col
.
0
+
1
line
.
end_col
.
0
+
1
)
}
)
.
collect
(
)
}
)
.
unwrap_or
(
vec
!
[
]
)
}
}
impl
DiagnosticCode
{
fn
map_opt_string
(
s
:
Option
<
String
>
je
:
&
JsonEmitter
)
-
>
Option
<
DiagnosticCode
>
{
s
.
map
(
|
s
|
{
let
explanation
=
je
.
registry
.
as_ref
(
)
.
and_then
(
|
registry
|
registry
.
find_description
(
&
s
)
)
;
DiagnosticCode
{
code
:
s
explanation
:
explanation
}
}
)
}
}
impl
JsonEmitter
{
fn
render
(
&
self
render_span
:
&
RenderSpan
)
-
>
Option
<
String
>
{
use
std
:
:
borrow
:
:
Borrow
;
match
*
render_span
{
RenderSpan
:
:
FullSpan
(
_
)
=
>
{
None
}
RenderSpan
:
:
Suggestion
(
ref
suggestion
)
=
>
{
Some
(
suggestion
.
splice_lines
(
self
.
cm
.
borrow
(
)
)
)
}
}
}
}
