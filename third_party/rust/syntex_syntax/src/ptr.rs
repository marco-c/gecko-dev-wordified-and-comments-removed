use
std
:
:
fmt
:
:
{
self
Display
Debug
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
{
mem
ptr
slice
vec
}
;
use
serialize
:
:
{
Encodable
Decodable
Encoder
Decoder
}
;
#
[
derive
(
Hash
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
P
<
T
:
?
Sized
>
{
ptr
:
Box
<
T
>
}
#
[
allow
(
non_snake_case
)
]
pub
fn
P
<
T
:
'
static
>
(
value
:
T
)
-
>
P
<
T
>
{
P
{
ptr
:
Box
:
:
new
(
value
)
}
}
impl
<
T
:
'
static
>
P
<
T
>
{
pub
fn
and_then
<
U
F
>
(
self
f
:
F
)
-
>
U
where
F
:
FnOnce
(
T
)
-
>
U
{
f
(
*
self
.
ptr
)
}
pub
fn
unwrap
(
self
)
-
>
T
{
*
self
.
ptr
}
pub
fn
map
<
F
>
(
mut
self
f
:
F
)
-
>
P
<
T
>
where
F
:
FnOnce
(
T
)
-
>
T
{
let
p
:
*
mut
T
=
&
mut
*
self
.
ptr
;
mem
:
:
forget
(
self
)
;
unsafe
{
ptr
:
:
write
(
p
f
(
ptr
:
:
read
(
p
)
)
)
;
P
{
ptr
:
Box
:
:
from_raw
(
p
)
}
}
}
}
impl
<
T
:
?
Sized
>
Deref
for
P
<
T
>
{
type
Target
=
T
;
fn
deref
(
&
self
)
-
>
&
T
{
&
self
.
ptr
}
}
impl
<
T
:
'
static
+
Clone
>
Clone
for
P
<
T
>
{
fn
clone
(
&
self
)
-
>
P
<
T
>
{
P
(
(
*
*
self
)
.
clone
(
)
)
}
}
impl
<
T
:
?
Sized
+
Debug
>
Debug
for
P
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Debug
:
:
fmt
(
&
self
.
ptr
f
)
}
}
impl
<
T
:
Display
>
Display
for
P
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
Display
:
:
fmt
(
&
*
*
self
f
)
}
}
impl
<
T
>
fmt
:
:
Pointer
for
P
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
fmt
:
:
Pointer
:
:
fmt
(
&
self
.
ptr
f
)
}
}
impl
<
T
:
'
static
+
Decodable
>
Decodable
for
P
<
T
>
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
P
<
T
>
D
:
:
Error
>
{
Decodable
:
:
decode
(
d
)
.
map
(
P
)
}
}
impl
<
T
:
Encodable
>
Encodable
for
P
<
T
>
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
(
*
*
self
)
.
encode
(
s
)
}
}
impl
<
T
>
P
<
[
T
]
>
{
pub
fn
new
(
)
-
>
P
<
[
T
]
>
{
P
{
ptr
:
Default
:
:
default
(
)
}
}
#
[
inline
(
never
)
]
pub
fn
from_vec
(
v
:
Vec
<
T
>
)
-
>
P
<
[
T
]
>
{
P
{
ptr
:
v
.
into_boxed_slice
(
)
}
}
#
[
inline
(
never
)
]
pub
fn
into_vec
(
self
)
-
>
Vec
<
T
>
{
self
.
ptr
.
into_vec
(
)
}
}
impl
<
T
>
Default
for
P
<
[
T
]
>
{
fn
default
(
)
-
>
P
<
[
T
]
>
{
P
:
:
new
(
)
}
}
impl
<
T
:
Clone
>
Clone
for
P
<
[
T
]
>
{
fn
clone
(
&
self
)
-
>
P
<
[
T
]
>
{
P
:
:
from_vec
(
self
.
to_vec
(
)
)
}
}
impl
<
T
>
From
<
Vec
<
T
>
>
for
P
<
[
T
]
>
{
fn
from
(
v
:
Vec
<
T
>
)
-
>
Self
{
P
:
:
from_vec
(
v
)
}
}
impl
<
T
>
Into
<
Vec
<
T
>
>
for
P
<
[
T
]
>
{
fn
into
(
self
)
-
>
Vec
<
T
>
{
self
.
into_vec
(
)
}
}
impl
<
T
>
FromIterator
<
T
>
for
P
<
[
T
]
>
{
fn
from_iter
<
I
:
IntoIterator
<
Item
=
T
>
>
(
iter
:
I
)
-
>
P
<
[
T
]
>
{
P
:
:
from_vec
(
iter
.
into_iter
(
)
.
collect
(
)
)
}
}
impl
<
T
>
IntoIterator
for
P
<
[
T
]
>
{
type
Item
=
T
;
type
IntoIter
=
vec
:
:
IntoIter
<
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
into_vec
(
)
.
into_iter
(
)
}
}
impl
<
'
a
T
>
IntoIterator
for
&
'
a
P
<
[
T
]
>
{
type
Item
=
&
'
a
T
;
type
IntoIter
=
slice
:
:
Iter
<
'
a
T
>
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
ptr
.
into_iter
(
)
}
}
impl
<
T
:
Encodable
>
Encodable
for
P
<
[
T
]
>
{
fn
encode
<
S
:
Encoder
>
(
&
self
s
:
&
mut
S
)
-
>
Result
<
(
)
S
:
:
Error
>
{
Encodable
:
:
encode
(
&
*
*
self
s
)
}
}
impl
<
T
:
Decodable
>
Decodable
for
P
<
[
T
]
>
{
fn
decode
<
D
:
Decoder
>
(
d
:
&
mut
D
)
-
>
Result
<
P
<
[
T
]
>
D
:
:
Error
>
{
Ok
(
P
:
:
from_vec
(
match
Decodable
:
:
decode
(
d
)
{
Ok
(
t
)
=
>
t
Err
(
e
)
=
>
return
Err
(
e
)
}
)
)
}
}
