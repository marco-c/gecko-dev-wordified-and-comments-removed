#
[
macro_export
]
macro_rules
!
flattened_maybe
{
(
fn
:
ident
field
:
expr
)
=
>
{
fn
fn
<
'
de
T
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
serde
:
:
Deserialize
<
'
de
>
D
:
serde
:
:
Deserializer
<
'
de
>
{
#
[
derive
(
serde
:
:
Deserialize
)
]
struct
Both
<
T
>
{
#
[
serde
(
flatten
)
]
flat
:
Option
<
T
>
#
[
serde
(
rename
=
field
)
]
not_flat
:
Option
<
T
>
}
let
both
:
Both
<
T
>
=
serde
:
:
Deserialize
:
:
deserialize
(
deserializer
)
?
;
match
(
both
.
flat
both
.
not_flat
)
{
(
Some
(
t
)
None
)
|
(
None
Some
(
t
)
)
=
>
Ok
(
t
)
(
None
None
)
=
>
Err
(
serde
:
:
de
:
:
Error
:
:
missing_field
(
field
)
)
(
Some
(
_
)
Some
(
_
)
)
=
>
Err
(
serde
:
:
de
:
:
Error
:
:
custom
(
concat
!
(
"
"
field
"
is
both
flattened
and
not
"
)
)
)
}
}
}
;
}
