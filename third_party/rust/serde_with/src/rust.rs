use
crate
:
:
{
utils
Separator
}
;
#
[
cfg
(
doc
)
]
use
alloc
:
:
collections
:
:
BTreeMap
;
use
alloc
:
:
{
string
:
:
{
String
ToString
}
vec
:
:
Vec
}
;
use
core
:
:
{
cmp
:
:
Eq
fmt
:
:
{
self
Display
}
hash
:
:
Hash
iter
:
:
FromIterator
marker
:
:
PhantomData
str
:
:
FromStr
}
;
use
serde
:
:
{
de
:
:
{
Deserialize
DeserializeOwned
Deserializer
Error
MapAccess
SeqAccess
Visitor
}
ser
:
:
{
Serialize
Serializer
}
}
;
#
[
cfg
(
doc
)
]
use
std
:
:
collections
:
:
HashMap
;
pub
mod
display_fromstr
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
T
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
FromStr
T
:
:
Err
:
Display
{
struct
Helper
<
S
>
(
PhantomData
<
S
>
)
;
impl
<
'
de
S
>
Visitor
<
'
de
>
for
Helper
<
S
>
where
S
:
FromStr
<
S
as
FromStr
>
:
:
Err
:
Display
{
type
Value
=
S
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
a
string
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
Error
{
value
.
parse
:
:
<
Self
:
:
Value
>
(
)
.
map_err
(
Error
:
:
custom
)
}
}
deserializer
.
deserialize_str
(
Helper
(
PhantomData
)
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Display
S
:
Serializer
{
serializer
.
collect_str
(
&
value
)
}
}
pub
mod
seq_display_fromstr
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
T
I
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
FromIterator
<
I
>
+
Sized
I
:
FromStr
I
:
:
Err
:
Display
{
struct
Helper
<
S
>
(
PhantomData
<
S
>
)
;
impl
<
'
de
S
>
Visitor
<
'
de
>
for
Helper
<
S
>
where
S
:
FromStr
<
S
as
FromStr
>
:
:
Err
:
Display
{
type
Value
=
Vec
<
S
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
formatter
"
a
sequence
"
)
}
fn
visit_seq
<
A
>
(
self
seq
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
utils
:
:
SeqIter
:
:
new
(
seq
)
.
map
(
|
res
|
{
res
.
and_then
(
|
value
:
&
str
|
value
.
parse
:
:
<
S
>
(
)
.
map_err
(
Error
:
:
custom
)
)
}
)
.
collect
(
)
}
}
deserializer
.
deserialize_seq
(
Helper
(
PhantomData
)
)
.
map
(
T
:
:
from_iter
)
}
pub
fn
serialize
<
S
T
I
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
for
<
'
a
>
&
'
a
T
:
IntoIterator
<
Item
=
&
'
a
I
>
I
:
Display
{
struct
SerializeString
<
'
a
I
>
(
&
'
a
I
)
;
impl
<
'
a
I
>
Serialize
for
SerializeString
<
'
a
I
>
where
I
:
Display
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
collect_str
(
self
.
0
)
}
}
serializer
.
collect_seq
(
value
.
into_iter
(
)
.
map
(
SerializeString
)
)
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Ord
PartialOrd
Hash
Debug
Default
)
]
pub
struct
StringWithSeparator
<
Sep
T
=
(
)
>
(
PhantomData
<
(
Sep
T
)
>
)
;
impl
<
Sep
>
StringWithSeparator
<
Sep
>
where
Sep
:
Separator
{
pub
fn
serialize
<
S
T
V
>
(
values
:
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
T
:
IntoIterator
<
Item
=
V
>
V
:
Display
{
let
mut
s
=
String
:
:
new
(
)
;
for
v
in
values
{
s
.
push_str
(
&
*
v
.
to_string
(
)
)
;
s
.
push_str
(
Sep
:
:
separator
(
)
)
;
}
serializer
.
serialize_str
(
if
!
s
.
is_empty
(
)
{
&
s
[
.
.
s
.
len
(
)
-
Sep
:
:
separator
(
)
.
len
(
)
]
}
else
{
&
s
[
.
.
]
}
)
}
pub
fn
deserialize
<
'
de
D
T
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
FromIterator
<
V
>
V
:
FromStr
V
:
:
Err
:
Display
{
let
s
=
String
:
:
deserialize
(
deserializer
)
?
;
if
s
.
is_empty
(
)
{
Ok
(
None
.
into_iter
(
)
.
collect
(
)
)
}
else
{
s
.
split
(
Sep
:
:
separator
(
)
)
.
map
(
FromStr
:
:
from_str
)
.
collect
:
:
<
Result
<
_
_
>
>
(
)
.
map_err
(
Error
:
:
custom
)
}
}
}
#
[
allow
(
clippy
:
:
option_option
)
]
pub
mod
double_option
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
T
D
>
(
deserializer
:
D
)
-
>
Result
<
Option
<
Option
<
T
>
>
D
:
:
Error
>
where
T
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
Deserialize
:
:
deserialize
(
deserializer
)
.
map
(
Some
)
}
pub
fn
serialize
<
S
T
>
(
values
:
&
Option
<
Option
<
T
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
T
:
Serialize
{
match
values
{
None
=
>
serializer
.
serialize_unit
(
)
Some
(
None
)
=
>
serializer
.
serialize_none
(
)
Some
(
Some
(
v
)
)
=
>
serializer
.
serialize_some
(
&
v
)
}
}
}
pub
mod
unwrap_or_skip
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
T
>
(
deserializer
:
D
)
-
>
Result
<
Option
<
T
>
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
DeserializeOwned
{
T
:
:
deserialize
(
deserializer
)
.
map
(
Some
)
}
pub
fn
serialize
<
T
S
>
(
option
:
&
Option
<
T
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
if
let
Some
(
value
)
=
option
{
value
.
serialize
(
serializer
)
}
else
{
(
)
.
serialize
(
serializer
)
}
}
}
pub
mod
sets_duplicate_value_is_error
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
PreventDuplicateInsertsSet
;
pub
fn
deserialize
<
'
de
D
T
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
PreventDuplicateInsertsSet
<
V
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
SeqVisitor
<
T
V
>
{
marker
:
PhantomData
<
T
>
set_item_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
V
>
Visitor
<
'
de
>
for
SeqVisitor
<
T
V
>
where
T
:
PreventDuplicateInsertsSet
<
V
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
sequence
"
)
}
#
[
inline
]
fn
visit_seq
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
value
)
=
access
.
next_element
(
)
?
{
if
!
values
.
insert
(
value
)
{
return
Err
(
Error
:
:
custom
(
"
invalid
entry
:
found
duplicate
value
"
)
)
;
}
;
}
Ok
(
values
)
}
}
let
visitor
=
SeqVisitor
{
marker
:
PhantomData
set_item_type
:
PhantomData
}
;
deserializer
.
deserialize_seq
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
mod
maps_duplicate_key_is_error
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
PreventDuplicateInsertsMap
;
pub
fn
deserialize
<
'
de
D
T
K
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
PreventDuplicateInsertsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
MapVisitor
<
T
K
V
>
{
marker
:
PhantomData
<
T
>
map_key_type
:
PhantomData
<
K
>
map_value_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
K
V
>
Visitor
<
'
de
>
for
MapVisitor
<
T
K
V
>
where
T
:
PreventDuplicateInsertsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
map
"
)
}
#
[
inline
]
fn
visit_map
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
MapAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
(
key
value
)
)
=
access
.
next_entry
(
)
?
{
if
!
values
.
insert
(
key
value
)
{
return
Err
(
Error
:
:
custom
(
"
invalid
entry
:
found
duplicate
key
"
)
)
;
}
;
}
Ok
(
values
)
}
}
let
visitor
=
MapVisitor
{
marker
:
PhantomData
map_key_type
:
PhantomData
map_value_type
:
PhantomData
}
;
deserializer
.
deserialize_map
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
#
[
deprecated
=
"
This
module
does
nothing
.
Remove
the
attribute
.
Serde
'
s
default
behavior
is
to
use
the
first
value
when
deserializing
a
set
.
"
]
#
[
allow
(
deprecated
)
]
pub
mod
sets_first_value_wins
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
DuplicateInsertsFirstWinsSet
;
#
[
deprecated
=
"
This
function
does
nothing
.
Remove
the
attribute
.
Serde
'
s
default
behavior
is
to
use
the
first
value
when
deserializing
a
set
.
"
]
pub
fn
deserialize
<
'
de
D
T
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
DuplicateInsertsFirstWinsSet
<
V
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
SeqVisitor
<
T
V
>
{
marker
:
PhantomData
<
T
>
set_item_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
V
>
Visitor
<
'
de
>
for
SeqVisitor
<
T
V
>
where
T
:
DuplicateInsertsFirstWinsSet
<
V
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
sequence
"
)
}
#
[
inline
]
fn
visit_seq
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
value
)
=
access
.
next_element
(
)
?
{
values
.
insert
(
value
)
;
}
Ok
(
values
)
}
}
let
visitor
=
SeqVisitor
{
marker
:
PhantomData
set_item_type
:
PhantomData
}
;
deserializer
.
deserialize_seq
(
visitor
)
}
#
[
deprecated
=
"
This
function
does
nothing
.
Remove
the
attribute
.
Serde
'
s
default
behavior
is
to
use
the
first
value
when
deserializing
a
set
.
"
]
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
mod
sets_last_value_wins
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
DuplicateInsertsLastWinsSet
;
pub
fn
deserialize
<
'
de
D
T
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
DuplicateInsertsLastWinsSet
<
V
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
SeqVisitor
<
T
V
>
{
marker
:
PhantomData
<
T
>
set_item_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
V
>
Visitor
<
'
de
>
for
SeqVisitor
<
T
V
>
where
T
:
DuplicateInsertsLastWinsSet
<
V
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
sequence
"
)
}
#
[
inline
]
fn
visit_seq
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
value
)
=
access
.
next_element
(
)
?
{
values
.
replace
(
value
)
;
}
Ok
(
values
)
}
}
let
visitor
=
SeqVisitor
{
marker
:
PhantomData
set_item_type
:
PhantomData
}
;
deserializer
.
deserialize_seq
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
mod
maps_first_key_wins
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
DuplicateInsertsFirstWinsMap
;
pub
fn
deserialize
<
'
de
D
T
K
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
DuplicateInsertsFirstWinsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
MapVisitor
<
T
K
V
>
{
marker
:
PhantomData
<
T
>
map_key_type
:
PhantomData
<
K
>
map_value_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
K
V
>
Visitor
<
'
de
>
for
MapVisitor
<
T
K
V
>
where
T
:
DuplicateInsertsFirstWinsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
map
"
)
}
#
[
inline
]
fn
visit_map
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
MapAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
(
key
value
)
)
=
access
.
next_entry
(
)
?
{
values
.
insert
(
key
value
)
;
}
Ok
(
values
)
}
}
let
visitor
=
MapVisitor
{
marker
:
PhantomData
map_key_type
:
PhantomData
map_value_type
:
PhantomData
}
;
deserializer
.
deserialize_map
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
mod
string_empty_as_none
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
S
>
(
deserializer
:
D
)
-
>
Result
<
Option
<
S
>
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
S
:
FromStr
S
:
:
Err
:
Display
{
struct
OptionStringEmptyNone
<
S
>
(
PhantomData
<
S
>
)
;
impl
<
'
de
S
>
Visitor
<
'
de
>
for
OptionStringEmptyNone
<
S
>
where
S
:
FromStr
S
:
:
Err
:
Display
{
type
Value
=
Option
<
S
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
any
string
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
Error
{
match
value
{
"
"
=
>
Ok
(
None
)
v
=
>
S
:
:
from_str
(
v
)
.
map
(
Some
)
.
map_err
(
Error
:
:
custom
)
}
}
fn
visit_string
<
E
>
(
self
value
:
String
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
Error
{
match
&
*
value
{
"
"
=
>
Ok
(
None
)
v
=
>
S
:
:
from_str
(
v
)
.
map
(
Some
)
.
map_err
(
Error
:
:
custom
)
}
}
fn
visit_unit
<
E
>
(
self
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
Error
{
Ok
(
None
)
}
}
deserializer
.
deserialize_any
(
OptionStringEmptyNone
(
PhantomData
)
)
}
pub
fn
serialize
<
T
S
>
(
option
:
&
Option
<
T
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
AsRef
<
str
>
S
:
Serializer
{
if
let
Some
(
value
)
=
option
{
value
.
as_ref
(
)
.
serialize
(
serializer
)
}
else
{
"
"
.
serialize
(
serializer
)
}
}
}
pub
mod
map_as_tuple_list
{
use
super
:
:
*
;
pub
fn
serialize
<
'
a
T
K
V
S
>
(
map
:
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
T
:
IntoIterator
<
Item
=
(
&
'
a
K
&
'
a
V
)
>
T
:
:
IntoIter
:
ExactSizeIterator
K
:
Serialize
+
'
a
V
:
Serialize
+
'
a
{
serializer
.
collect_seq
(
map
)
}
pub
fn
deserialize
<
'
de
T
K
V
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
FromIterator
<
(
K
V
)
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
struct
SeqVisitor
<
T
K
V
>
(
PhantomData
<
(
T
K
V
)
>
)
;
impl
<
'
de
T
K
V
>
Visitor
<
'
de
>
for
SeqVisitor
<
T
K
V
>
where
T
:
FromIterator
<
(
K
V
)
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
list
of
key
-
value
pairs
"
)
}
fn
visit_seq
<
A
>
(
self
seq
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
utils
:
:
SeqIter
:
:
new
(
seq
)
.
collect
(
)
}
}
deserializer
.
deserialize_seq
(
SeqVisitor
(
PhantomData
)
)
}
}
#
[
deprecated
(
since
=
"
1
.
8
.
0
"
note
=
"
Use
the
more
general
map_as_tuple_list
module
.
"
)
]
pub
mod
hashmap_as_tuple_list
{
#
[
doc
(
inline
)
]
#
[
deprecated
(
since
=
"
1
.
8
.
0
"
note
=
"
Use
the
more
general
map_as_tuple_list
:
:
deserialize
function
.
"
)
]
pub
use
super
:
:
map_as_tuple_list
:
:
deserialize
;
#
[
doc
(
inline
)
]
#
[
deprecated
(
since
=
"
1
.
8
.
0
"
note
=
"
Use
the
more
general
map_as_tuple_list
:
:
serialize
function
.
"
)
]
pub
use
super
:
:
map_as_tuple_list
:
:
serialize
;
}
#
[
deprecated
(
since
=
"
1
.
8
.
0
"
note
=
"
Use
the
more
general
map_as_tuple_list
module
.
"
)
]
pub
mod
btreemap_as_tuple_list
{
#
[
doc
(
inline
)
]
#
[
deprecated
(
since
=
"
1
.
8
.
0
"
note
=
"
Use
the
more
general
map_as_tuple_list
:
:
deserialize
function
.
"
)
]
pub
use
super
:
:
map_as_tuple_list
:
:
deserialize
;
#
[
doc
(
inline
)
]
#
[
deprecated
(
since
=
"
1
.
8
.
0
"
note
=
"
Use
the
more
general
map_as_tuple_list
:
:
serialize
function
.
"
)
]
pub
use
super
:
:
map_as_tuple_list
:
:
serialize
;
}
pub
mod
tuple_list_as_map
{
use
super
:
:
*
;
pub
fn
serialize
<
'
a
I
K
V
S
>
(
iter
:
I
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
I
:
IntoIterator
<
Item
=
&
'
a
(
K
V
)
>
I
:
:
IntoIter
:
ExactSizeIterator
K
:
Serialize
+
'
a
V
:
Serialize
+
'
a
S
:
Serializer
{
let
iter
=
iter
.
into_iter
(
)
.
map
(
|
(
k
v
)
|
(
k
v
)
)
;
serializer
.
collect_map
(
iter
)
}
pub
fn
deserialize
<
'
de
I
K
V
D
>
(
deserializer
:
D
)
-
>
Result
<
I
D
:
:
Error
>
where
I
:
FromIterator
<
(
K
V
)
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_map
(
MapVisitor
(
PhantomData
)
)
}
#
[
allow
(
clippy
:
:
type_complexity
)
]
struct
MapVisitor
<
I
K
V
>
(
PhantomData
<
fn
(
)
-
>
(
I
K
V
)
>
)
;
impl
<
'
de
I
K
V
>
Visitor
<
'
de
>
for
MapVisitor
<
I
K
V
>
where
I
:
FromIterator
<
(
K
V
)
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
I
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
map
"
)
}
fn
visit_map
<
A
>
(
self
map
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
MapAccess
<
'
de
>
{
utils
:
:
MapIter
:
:
new
(
map
)
.
collect
(
)
}
}
}
pub
mod
bytes_or_string
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
>
(
deserializer
:
D
)
-
>
Result
<
Vec
<
u8
>
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
deserializer
.
deserialize_any
(
BytesOrStringVisitor
)
}
struct
BytesOrStringVisitor
;
impl
<
'
de
>
Visitor
<
'
de
>
for
BytesOrStringVisitor
{
type
Value
=
Vec
<
u8
>
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
list
of
bytes
or
a
string
"
)
}
fn
visit_bytes
<
E
>
(
self
v
:
&
[
u8
]
)
-
>
Result
<
Self
:
:
Value
E
>
{
Ok
(
v
.
to_vec
(
)
)
}
fn
visit_byte_buf
<
E
>
(
self
v
:
Vec
<
u8
>
)
-
>
Result
<
Self
:
:
Value
E
>
{
Ok
(
v
)
}
fn
visit_str
<
E
>
(
self
v
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
{
Ok
(
v
.
as_bytes
(
)
.
to_vec
(
)
)
}
fn
visit_string
<
E
>
(
self
v
:
String
)
-
>
Result
<
Self
:
:
Value
E
>
{
Ok
(
v
.
into_bytes
(
)
)
}
fn
visit_seq
<
A
>
(
self
seq
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
utils
:
:
SeqIter
:
:
new
(
seq
)
.
collect
(
)
}
}
}
pub
mod
default_on_error
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
T
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
Deserialize
<
'
de
>
+
Default
{
#
[
derive
(
Debug
serde
:
:
Deserialize
)
]
#
[
serde
(
untagged
)
]
enum
GoodOrError
<
T
>
{
Good
(
T
)
Error
(
serde
:
:
de
:
:
IgnoredAny
)
}
Ok
(
match
Deserialize
:
:
deserialize
(
deserializer
)
{
Ok
(
GoodOrError
:
:
Good
(
res
)
)
=
>
res
_
=
>
Default
:
:
default
(
)
}
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
mod
default_on_null
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
T
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
Deserialize
<
'
de
>
+
Default
{
Ok
(
Option
:
:
deserialize
(
deserializer
)
?
.
unwrap_or_default
(
)
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
fn
deserialize_ignore_any
<
'
de
D
:
Deserializer
<
'
de
>
T
:
Default
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
{
serde
:
:
de
:
:
IgnoredAny
:
:
deserialize
(
deserializer
)
.
map
(
|
_
|
T
:
:
default
(
)
)
}
