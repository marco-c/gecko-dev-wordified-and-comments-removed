use
crate
:
:
prelude
:
:
*
;
#
[
allow
(
clippy
:
:
option_option
)
]
pub
mod
double_option
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
T
D
>
(
deserializer
:
D
)
-
>
Result
<
Option
<
Option
<
T
>
>
D
:
:
Error
>
where
T
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
Deserialize
:
:
deserialize
(
deserializer
)
.
map
(
Some
)
}
pub
fn
serialize
<
S
T
>
(
values
:
&
Option
<
Option
<
T
>
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
T
:
Serialize
{
match
values
{
None
=
>
serializer
.
serialize_unit
(
)
Some
(
None
)
=
>
serializer
.
serialize_none
(
)
Some
(
Some
(
v
)
)
=
>
serializer
.
serialize_some
(
&
v
)
}
}
}
pub
mod
unwrap_or_skip
{
use
super
:
:
*
;
pub
fn
deserialize
<
'
de
D
T
>
(
deserializer
:
D
)
-
>
Result
<
Option
<
T
>
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
T
:
DeserializeOwned
{
T
:
:
deserialize
(
deserializer
)
.
map
(
Some
)
}
pub
fn
serialize
<
T
S
>
(
option
:
&
Option
<
T
>
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
if
let
Some
(
value
)
=
option
{
value
.
serialize
(
serializer
)
}
else
{
(
)
.
serialize
(
serializer
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
mod
sets_duplicate_value_is_error
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
PreventDuplicateInsertsSet
;
pub
fn
deserialize
<
'
de
D
T
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
PreventDuplicateInsertsSet
<
V
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
SeqVisitor
<
T
V
>
{
marker
:
PhantomData
<
T
>
set_item_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
V
>
Visitor
<
'
de
>
for
SeqVisitor
<
T
V
>
where
T
:
PreventDuplicateInsertsSet
<
V
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
sequence
"
)
}
#
[
inline
]
fn
visit_seq
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
value
)
=
access
.
next_element
(
)
?
{
if
!
values
.
insert
(
value
)
{
return
Err
(
DeError
:
:
custom
(
"
invalid
entry
:
found
duplicate
value
"
)
)
;
}
;
}
Ok
(
values
)
}
}
let
visitor
=
SeqVisitor
{
marker
:
PhantomData
set_item_type
:
PhantomData
}
;
deserializer
.
deserialize_seq
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
mod
maps_duplicate_key_is_error
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
PreventDuplicateInsertsMap
;
pub
fn
deserialize
<
'
de
D
T
K
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
PreventDuplicateInsertsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
MapVisitor
<
T
K
V
>
{
marker
:
PhantomData
<
T
>
map_key_type
:
PhantomData
<
K
>
map_value_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
K
V
>
Visitor
<
'
de
>
for
MapVisitor
<
T
K
V
>
where
T
:
PreventDuplicateInsertsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
map
"
)
}
#
[
inline
]
fn
visit_map
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
MapAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
(
key
value
)
)
=
access
.
next_entry
(
)
?
{
if
!
values
.
insert
(
key
value
)
{
return
Err
(
DeError
:
:
custom
(
"
invalid
entry
:
found
duplicate
key
"
)
)
;
}
;
}
Ok
(
values
)
}
}
let
visitor
=
MapVisitor
{
marker
:
PhantomData
map_key_type
:
PhantomData
map_value_type
:
PhantomData
}
;
deserializer
.
deserialize_map
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
mod
sets_last_value_wins
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
DuplicateInsertsLastWinsSet
;
pub
fn
deserialize
<
'
de
D
T
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
DuplicateInsertsLastWinsSet
<
V
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
SeqVisitor
<
T
V
>
{
marker
:
PhantomData
<
T
>
set_item_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
V
>
Visitor
<
'
de
>
for
SeqVisitor
<
T
V
>
where
T
:
DuplicateInsertsLastWinsSet
<
V
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
sequence
"
)
}
#
[
inline
]
fn
visit_seq
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
SeqAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
value
)
=
access
.
next_element
(
)
?
{
values
.
replace
(
value
)
;
}
Ok
(
values
)
}
}
let
visitor
=
SeqVisitor
{
marker
:
PhantomData
set_item_type
:
PhantomData
}
;
deserializer
.
deserialize_seq
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
mod
maps_first_key_wins
{
use
super
:
:
*
;
use
crate
:
:
duplicate_key_impls
:
:
DuplicateInsertsFirstWinsMap
;
pub
fn
deserialize
<
'
de
D
T
K
V
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
T
:
DuplicateInsertsFirstWinsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
D
:
Deserializer
<
'
de
>
{
struct
MapVisitor
<
T
K
V
>
{
marker
:
PhantomData
<
T
>
map_key_type
:
PhantomData
<
K
>
map_value_type
:
PhantomData
<
V
>
}
impl
<
'
de
T
K
V
>
Visitor
<
'
de
>
for
MapVisitor
<
T
K
V
>
where
T
:
DuplicateInsertsFirstWinsMap
<
K
V
>
K
:
Deserialize
<
'
de
>
V
:
Deserialize
<
'
de
>
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
map
"
)
}
#
[
inline
]
fn
visit_map
<
A
>
(
self
mut
access
:
A
)
-
>
Result
<
Self
:
:
Value
A
:
:
Error
>
where
A
:
MapAccess
<
'
de
>
{
let
mut
values
=
Self
:
:
Value
:
:
new
(
access
.
size_hint
(
)
)
;
while
let
Some
(
(
key
value
)
)
=
access
.
next_entry
(
)
?
{
values
.
insert
(
key
value
)
;
}
Ok
(
values
)
}
}
let
visitor
=
MapVisitor
{
marker
:
PhantomData
map_key_type
:
PhantomData
map_value_type
:
PhantomData
}
;
deserializer
.
deserialize_map
(
visitor
)
}
pub
fn
serialize
<
T
S
>
(
value
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
T
:
Serialize
S
:
Serializer
{
value
.
serialize
(
serializer
)
}
}
pub
fn
deserialize_ignore_any
<
'
de
D
:
Deserializer
<
'
de
>
T
:
Default
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
{
IgnoredAny
:
:
deserialize
(
deserializer
)
.
map
(
|
_
|
T
:
:
default
(
)
)
}
