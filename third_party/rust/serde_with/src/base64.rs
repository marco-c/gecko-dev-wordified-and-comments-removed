use
crate
:
:
prelude
:
:
*
;
pub
struct
Base64
<
ALPHABET
:
Alphabet
=
Standard
PADDING
:
formats
:
:
Format
=
formats
:
:
Padded
>
(
PhantomData
<
(
ALPHABET
PADDING
)
>
)
;
impl
<
T
ALPHABET
>
SerializeAs
<
T
>
for
Base64
<
ALPHABET
formats
:
:
Padded
>
where
T
:
AsRef
<
[
u8
]
>
ALPHABET
:
Alphabet
{
fn
serialize_as
<
S
>
(
source
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
use
:
:
base64
:
:
Engine
as
_
;
:
:
base64
:
:
engine
:
:
GeneralPurpose
:
:
new
(
&
ALPHABET
:
:
charset
(
)
:
:
base64
:
:
engine
:
:
general_purpose
:
:
PAD
)
.
encode
(
source
)
.
serialize
(
serializer
)
}
}
impl
<
T
ALPHABET
>
SerializeAs
<
T
>
for
Base64
<
ALPHABET
formats
:
:
Unpadded
>
where
T
:
AsRef
<
[
u8
]
>
ALPHABET
:
Alphabet
{
fn
serialize_as
<
S
>
(
source
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
use
:
:
base64
:
:
Engine
as
_
;
:
:
base64
:
:
engine
:
:
GeneralPurpose
:
:
new
(
&
ALPHABET
:
:
charset
(
)
:
:
base64
:
:
engine
:
:
general_purpose
:
:
NO_PAD
)
.
encode
(
source
)
.
serialize
(
serializer
)
}
}
const
PAD_INDIFFERENT
:
:
:
base64
:
:
engine
:
:
GeneralPurposeConfig
=
:
:
base64
:
:
engine
:
:
GeneralPurposeConfig
:
:
new
(
)
.
with_decode_padding_mode
(
:
:
base64
:
:
engine
:
:
DecodePaddingMode
:
:
Indifferent
)
;
impl
<
'
de
T
ALPHABET
FORMAT
>
DeserializeAs
<
'
de
T
>
for
Base64
<
ALPHABET
FORMAT
>
where
T
:
TryFrom
<
Vec
<
u8
>
>
ALPHABET
:
Alphabet
FORMAT
:
formats
:
:
Format
{
fn
deserialize_as
<
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
struct
Helper
<
T
ALPHABET
>
(
PhantomData
<
(
T
ALPHABET
)
>
)
;
impl
<
T
ALPHABET
>
Visitor
<
'
_
>
for
Helper
<
T
ALPHABET
>
where
T
:
TryFrom
<
Vec
<
u8
>
>
ALPHABET
:
Alphabet
{
type
Value
=
T
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
a
base64
encoded
string
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
Self
:
:
Value
E
>
where
E
:
DeError
{
use
:
:
base64
:
:
Engine
as
_
;
let
bytes
=
:
:
base64
:
:
engine
:
:
GeneralPurpose
:
:
new
(
&
ALPHABET
:
:
charset
(
)
PAD_INDIFFERENT
)
.
decode
(
value
)
.
map_err
(
DeError
:
:
custom
)
?
;
let
length
=
bytes
.
len
(
)
;
bytes
.
try_into
(
)
.
map_err
(
|
_e
:
T
:
:
Error
|
{
DeError
:
:
custom
(
format_args
!
(
"
Can
'
t
convert
a
Byte
Vector
of
length
{
length
}
to
the
output
type
.
"
)
)
}
)
}
}
deserializer
.
deserialize_str
(
Helper
:
:
<
T
ALPHABET
>
(
PhantomData
)
)
}
}
mod
sealed
{
pub
trait
Sealed
{
}
impl
Sealed
for
super
:
:
Standard
{
}
impl
Sealed
for
super
:
:
UrlSafe
{
}
impl
Sealed
for
super
:
:
Crypt
{
}
impl
Sealed
for
super
:
:
Bcrypt
{
}
impl
Sealed
for
super
:
:
ImapMutf7
{
}
impl
Sealed
for
super
:
:
BinHex
{
}
}
pub
trait
Alphabet
:
sealed
:
:
Sealed
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
;
}
pub
struct
Standard
;
impl
Alphabet
for
Standard
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
{
:
:
base64
:
:
alphabet
:
:
STANDARD
}
}
pub
struct
UrlSafe
;
impl
Alphabet
for
UrlSafe
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
{
:
:
base64
:
:
alphabet
:
:
URL_SAFE
}
}
pub
struct
Crypt
;
impl
Alphabet
for
Crypt
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
{
:
:
base64
:
:
alphabet
:
:
CRYPT
}
}
pub
struct
Bcrypt
;
impl
Alphabet
for
Bcrypt
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
{
:
:
base64
:
:
alphabet
:
:
BCRYPT
}
}
pub
struct
ImapMutf7
;
impl
Alphabet
for
ImapMutf7
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
{
:
:
base64
:
:
alphabet
:
:
IMAP_MUTF7
}
}
pub
struct
BinHex
;
impl
Alphabet
for
BinHex
{
fn
charset
(
)
-
>
:
:
base64
:
:
alphabet
:
:
Alphabet
{
:
:
base64
:
:
alphabet
:
:
BIN_HEX
}
}
