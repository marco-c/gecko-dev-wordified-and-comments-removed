use
crate
:
:
prelude
:
:
*
;
pub
struct
Hex
<
FORMAT
:
formats
:
:
Format
=
formats
:
:
Lowercase
>
(
PhantomData
<
FORMAT
>
)
;
impl
<
T
>
SerializeAs
<
T
>
for
Hex
<
formats
:
:
Lowercase
>
where
T
:
AsRef
<
[
u8
]
>
{
fn
serialize_as
<
S
>
(
source
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_str
(
&
:
:
hex
:
:
encode
(
source
)
)
}
}
impl
<
T
>
SerializeAs
<
T
>
for
Hex
<
formats
:
:
Uppercase
>
where
T
:
AsRef
<
[
u8
]
>
{
fn
serialize_as
<
S
>
(
source
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_str
(
&
:
:
hex
:
:
encode_upper
(
source
)
)
}
}
impl
<
'
de
T
FORMAT
>
DeserializeAs
<
'
de
T
>
for
Hex
<
FORMAT
>
where
T
:
TryFrom
<
Vec
<
u8
>
>
FORMAT
:
formats
:
:
Format
{
fn
deserialize_as
<
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
<
Cow
<
'
de
str
>
as
Deserialize
<
'
de
>
>
:
:
deserialize
(
deserializer
)
.
and_then
(
|
s
|
:
:
hex
:
:
decode
(
&
*
s
)
.
map_err
(
DeError
:
:
custom
)
)
.
and_then
(
|
vec
:
Vec
<
u8
>
|
{
let
length
=
vec
.
len
(
)
;
vec
.
try_into
(
)
.
map_err
(
|
_e
:
T
:
:
Error
|
{
DeError
:
:
custom
(
format_args
!
(
"
Can
'
t
convert
a
Byte
Vector
of
length
{
length
}
to
the
output
type
.
"
)
)
}
)
}
)
}
}
