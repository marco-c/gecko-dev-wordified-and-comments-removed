use
crate
:
:
prelude
:
:
*
;
pub
struct
JsonString
<
T
=
Same
>
(
PhantomData
<
T
>
)
;
impl
<
T
TAs
>
SerializeAs
<
T
>
for
JsonString
<
TAs
>
where
TAs
:
SerializeAs
<
T
>
{
fn
serialize_as
<
S
>
(
source
:
&
T
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
Serializer
{
serializer
.
serialize_str
(
&
serde_json
:
:
to_string
(
&
SerializeAsWrap
:
:
<
T
TAs
>
:
:
new
(
source
)
)
.
map_err
(
SerError
:
:
custom
)
?
)
}
}
impl
<
'
de
T
TAs
>
DeserializeAs
<
'
de
T
>
for
JsonString
<
TAs
>
where
TAs
:
for
<
'
a
>
DeserializeAs
<
'
a
T
>
{
fn
deserialize_as
<
D
>
(
deserializer
:
D
)
-
>
Result
<
T
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
struct
Helper
<
S
SAs
>
(
PhantomData
<
(
S
SAs
)
>
)
;
impl
<
S
SAs
>
Visitor
<
'
_
>
for
Helper
<
S
SAs
>
where
SAs
:
for
<
'
a
>
DeserializeAs
<
'
a
S
>
{
type
Value
=
S
;
fn
expecting
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
formatter
.
write_str
(
"
valid
json
object
"
)
}
fn
visit_str
<
E
>
(
self
value
:
&
str
)
-
>
Result
<
S
E
>
where
E
:
DeError
{
serde_json
:
:
from_str
(
value
)
.
map
(
DeserializeAsWrap
:
:
<
S
SAs
>
:
:
into_inner
)
.
map_err
(
DeError
:
:
custom
)
}
}
deserializer
.
deserialize_str
(
Helper
:
:
<
T
TAs
>
(
PhantomData
)
)
}
}
