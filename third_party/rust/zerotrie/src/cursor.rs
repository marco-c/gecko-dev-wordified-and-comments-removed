use
crate
:
:
reader
;
use
crate
:
:
ZeroAsciiIgnoreCaseTrie
;
use
crate
:
:
ZeroTrieSimpleAscii
;
use
core
:
:
fmt
;
impl
<
Store
>
ZeroTrieSimpleAscii
<
Store
>
where
Store
:
AsRef
<
[
u8
]
>
+
?
Sized
{
#
[
inline
]
pub
fn
cursor
(
&
self
)
-
>
ZeroTrieSimpleAsciiCursor
{
ZeroTrieSimpleAsciiCursor
{
trie
:
self
.
as_borrowed_slice
(
)
}
}
}
impl
<
Store
>
ZeroAsciiIgnoreCaseTrie
<
Store
>
where
Store
:
AsRef
<
[
u8
]
>
+
?
Sized
{
#
[
inline
]
pub
fn
cursor
(
&
self
)
-
>
ZeroAsciiIgnoreCaseTrieCursor
{
ZeroAsciiIgnoreCaseTrieCursor
{
trie
:
self
.
as_borrowed_slice
(
)
}
}
}
impl
<
'
a
>
ZeroTrieSimpleAscii
<
&
'
a
[
u8
]
>
{
#
[
inline
]
pub
fn
into_cursor
(
self
)
-
>
ZeroTrieSimpleAsciiCursor
<
'
a
>
{
ZeroTrieSimpleAsciiCursor
{
trie
:
self
}
}
}
impl
<
'
a
>
ZeroAsciiIgnoreCaseTrie
<
&
'
a
[
u8
]
>
{
#
[
inline
]
pub
fn
into_cursor
(
self
)
-
>
ZeroAsciiIgnoreCaseTrieCursor
<
'
a
>
{
ZeroAsciiIgnoreCaseTrieCursor
{
trie
:
self
}
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ZeroTrieSimpleAsciiCursor
<
'
a
>
{
trie
:
ZeroTrieSimpleAscii
<
&
'
a
[
u8
]
>
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ZeroAsciiIgnoreCaseTrieCursor
<
'
a
>
{
trie
:
ZeroAsciiIgnoreCaseTrie
<
&
'
a
[
u8
]
>
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
)
]
#
[
non_exhaustive
]
pub
struct
AsciiProbeResult
{
pub
byte
:
u8
pub
total_siblings
:
u8
}
impl
ZeroTrieSimpleAsciiCursor
<
'
_
>
{
#
[
inline
]
pub
fn
step
(
&
mut
self
byte
:
u8
)
{
reader
:
:
step_parameterized
:
:
<
ZeroTrieSimpleAscii
<
[
u8
]
>
>
(
&
mut
self
.
trie
.
store
byte
)
;
}
#
[
inline
]
pub
fn
take_value
(
&
mut
self
)
-
>
Option
<
usize
>
{
reader
:
:
take_value
(
&
mut
self
.
trie
.
store
)
}
pub
fn
probe
(
&
mut
self
index
:
usize
)
-
>
Option
<
AsciiProbeResult
>
{
reader
:
:
probe_parameterized
:
:
<
ZeroTrieSimpleAscii
<
[
u8
]
>
>
(
&
mut
self
.
trie
.
store
index
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
trie
.
is_empty
(
)
}
}
impl
ZeroAsciiIgnoreCaseTrieCursor
<
'
_
>
{
#
[
inline
]
pub
fn
step
(
&
mut
self
byte
:
u8
)
-
>
Option
<
u8
>
{
reader
:
:
step_parameterized
:
:
<
ZeroAsciiIgnoreCaseTrie
<
[
u8
]
>
>
(
&
mut
self
.
trie
.
store
byte
)
}
#
[
inline
]
pub
fn
take_value
(
&
mut
self
)
-
>
Option
<
usize
>
{
reader
:
:
take_value
(
&
mut
self
.
trie
.
store
)
}
pub
fn
probe
(
&
mut
self
index
:
usize
)
-
>
Option
<
AsciiProbeResult
>
{
reader
:
:
probe_parameterized
:
:
<
ZeroAsciiIgnoreCaseTrie
<
[
u8
]
>
>
(
&
mut
self
.
trie
.
store
index
)
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
trie
.
is_empty
(
)
}
}
impl
fmt
:
:
Write
for
ZeroTrieSimpleAsciiCursor
<
'
_
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
for
b
in
s
.
bytes
(
)
{
if
!
b
.
is_ascii
(
)
{
return
Err
(
fmt
:
:
Error
)
;
}
self
.
step
(
b
)
;
}
Ok
(
(
)
)
}
fn
write_char
(
&
mut
self
c
:
char
)
-
>
fmt
:
:
Result
{
if
!
c
.
is_ascii
(
)
{
return
Err
(
fmt
:
:
Error
)
;
}
self
.
step
(
c
as
u8
)
;
Ok
(
(
)
)
}
}
impl
fmt
:
:
Write
for
ZeroAsciiIgnoreCaseTrieCursor
<
'
_
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
fmt
:
:
Result
{
for
b
in
s
.
bytes
(
)
{
if
!
b
.
is_ascii
(
)
{
return
Err
(
fmt
:
:
Error
)
;
}
self
.
step
(
b
)
;
}
Ok
(
(
)
)
}
fn
write_char
(
&
mut
self
c
:
char
)
-
>
fmt
:
:
Result
{
if
!
c
.
is_ascii
(
)
{
return
Err
(
fmt
:
:
Error
)
;
}
self
.
step
(
c
as
u8
)
;
Ok
(
(
)
)
}
}
