use
crate
:
:
{
derives
:
:
{
args
into_app
subcommand
}
dummies
}
;
use
proc_macro2
:
:
TokenStream
;
use
proc_macro_error
:
:
abort_call_site
;
use
quote
:
:
quote
;
use
syn
:
:
{
self
punctuated
:
:
Punctuated
token
:
:
Comma
Attribute
Data
DataEnum
DataStruct
DeriveInput
Field
Fields
Generics
Ident
}
;
pub
fn
derive_parser
(
input
:
&
DeriveInput
)
-
>
TokenStream
{
let
ident
=
&
input
.
ident
;
match
input
.
data
{
Data
:
:
Struct
(
DataStruct
{
fields
:
Fields
:
:
Named
(
ref
fields
)
.
.
}
)
=
>
{
dummies
:
:
parser_struct
(
ident
)
;
gen_for_struct
(
ident
&
input
.
generics
&
fields
.
named
&
input
.
attrs
)
}
Data
:
:
Struct
(
DataStruct
{
fields
:
Fields
:
:
Unit
.
.
}
)
=
>
{
dummies
:
:
parser_struct
(
ident
)
;
gen_for_struct
(
ident
&
input
.
generics
&
Punctuated
:
:
<
Field
Comma
>
:
:
new
(
)
&
input
.
attrs
)
}
Data
:
:
Enum
(
ref
e
)
=
>
{
dummies
:
:
parser_enum
(
ident
)
;
gen_for_enum
(
ident
&
input
.
generics
&
input
.
attrs
e
)
}
_
=
>
abort_call_site
!
(
"
#
[
derive
(
Parser
)
]
only
supports
non
-
tuple
structs
and
enums
"
)
}
}
fn
gen_for_struct
(
name
:
&
Ident
generics
:
&
Generics
fields
:
&
Punctuated
<
Field
Comma
>
attrs
:
&
[
Attribute
]
)
-
>
TokenStream
{
let
into_app
=
into_app
:
:
gen_for_struct
(
name
generics
attrs
)
;
let
args
=
args
:
:
gen_for_struct
(
name
generics
fields
attrs
)
;
let
(
impl_generics
ty_generics
where_clause
)
=
generics
.
split_for_impl
(
)
;
quote
!
{
impl
#
impl_generics
clap
:
:
Parser
for
#
name
#
ty_generics
#
where_clause
{
}
#
into_app
#
args
}
}
fn
gen_for_enum
(
name
:
&
Ident
generics
:
&
Generics
attrs
:
&
[
Attribute
]
e
:
&
DataEnum
)
-
>
TokenStream
{
let
into_app
=
into_app
:
:
gen_for_enum
(
name
generics
attrs
)
;
let
subcommand
=
subcommand
:
:
gen_for_enum
(
name
generics
attrs
e
)
;
let
(
impl_generics
ty_generics
where_clause
)
=
generics
.
split_for_impl
(
)
;
quote
!
{
impl
#
impl_generics
clap
:
:
Parser
for
#
name
#
ty_generics
#
where_clause
{
}
#
into_app
#
subcommand
}
}
