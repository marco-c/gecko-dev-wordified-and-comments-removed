#
[
cfg
(
test
)
]
mod
tests
;
use
crate
:
:
error
:
:
ParseError
;
use
crate
:
:
internal
:
:
{
IResult
Parser
}
;
pub
fn
pair
<
I
O1
O2
E
:
ParseError
<
I
>
F
G
>
(
mut
first
:
F
mut
second
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
(
O1
O2
)
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Parser
<
I
O2
E
>
{
move
|
input
:
I
|
{
let
(
input
o1
)
=
first
.
parse
(
input
)
?
;
second
.
parse
(
input
)
.
map
(
|
(
i
o2
)
|
(
i
(
o1
o2
)
)
)
}
}
pub
fn
preceded
<
I
O1
O2
E
:
ParseError
<
I
>
F
G
>
(
mut
first
:
F
mut
second
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Parser
<
I
O2
E
>
{
move
|
input
:
I
|
{
let
(
input
_
)
=
first
.
parse
(
input
)
?
;
second
.
parse
(
input
)
}
}
pub
fn
terminated
<
I
O1
O2
E
:
ParseError
<
I
>
F
G
>
(
mut
first
:
F
mut
second
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O1
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Parser
<
I
O2
E
>
{
move
|
input
:
I
|
{
let
(
input
o1
)
=
first
.
parse
(
input
)
?
;
second
.
parse
(
input
)
.
map
(
|
(
i
_
)
|
(
i
o1
)
)
}
}
pub
fn
separated_pair
<
I
O1
O2
O3
E
:
ParseError
<
I
>
F
G
H
>
(
mut
first
:
F
mut
sep
:
G
mut
second
:
H
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
(
O1
O3
)
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Parser
<
I
O2
E
>
H
:
Parser
<
I
O3
E
>
{
move
|
input
:
I
|
{
let
(
input
o1
)
=
first
.
parse
(
input
)
?
;
let
(
input
_
)
=
sep
.
parse
(
input
)
?
;
second
.
parse
(
input
)
.
map
(
|
(
i
o2
)
|
(
i
(
o1
o2
)
)
)
}
}
pub
fn
delimited
<
I
O1
O2
O3
E
:
ParseError
<
I
>
F
G
H
>
(
mut
first
:
F
mut
second
:
G
mut
third
:
H
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Parser
<
I
O2
E
>
H
:
Parser
<
I
O3
E
>
{
move
|
input
:
I
|
{
let
(
input
_
)
=
first
.
parse
(
input
)
?
;
let
(
input
o2
)
=
second
.
parse
(
input
)
?
;
third
.
parse
(
input
)
.
map
(
|
(
i
_
)
|
(
i
o2
)
)
}
}
pub
trait
Tuple
<
I
O
E
>
{
fn
parse
(
&
mut
self
input
:
I
)
-
>
IResult
<
I
O
E
>
;
}
impl
<
Input
Output
Error
:
ParseError
<
Input
>
F
:
Parser
<
Input
Output
Error
>
>
Tuple
<
Input
(
Output
)
Error
>
for
(
F
)
{
fn
parse
(
&
mut
self
input
:
Input
)
-
>
IResult
<
Input
(
Output
)
Error
>
{
self
.
0
.
parse
(
input
)
.
map
(
|
(
i
o
)
|
(
i
(
o
)
)
)
}
}
macro_rules
!
tuple_trait
(
(
name1
:
ident
ty1
:
ident
name2
:
ident
ty2
:
ident
(
name
:
ident
ty
:
ident
)
*
)
=
>
(
tuple_trait
!
(
__impl
name1
ty1
name2
ty2
;
(
name
ty
)
*
)
;
)
;
(
__impl
(
name
:
ident
ty
:
ident
)
+
;
name1
:
ident
ty1
:
ident
(
name2
:
ident
ty2
:
ident
)
*
)
=
>
(
tuple_trait_impl
!
(
(
name
ty
)
+
)
;
tuple_trait
!
(
__impl
(
name
ty
)
+
name1
ty1
;
(
name2
ty2
)
*
)
;
)
;
(
__impl
(
name
:
ident
ty
:
ident
)
+
;
name1
:
ident
ty1
:
ident
)
=
>
(
tuple_trait_impl
!
(
(
name
ty
)
+
)
;
tuple_trait_impl
!
(
(
name
ty
)
+
name1
ty1
)
;
)
;
)
;
macro_rules
!
tuple_trait_impl
(
(
(
name
:
ident
ty
:
ident
)
+
)
=
>
(
impl
<
Input
:
Clone
(
ty
)
+
Error
:
ParseError
<
Input
>
(
name
:
Parser
<
Input
ty
Error
>
)
+
>
Tuple
<
Input
(
(
ty
)
+
)
Error
>
for
(
(
name
)
+
)
{
fn
parse
(
&
mut
self
input
:
Input
)
-
>
IResult
<
Input
(
(
ty
)
+
)
Error
>
{
tuple_trait_inner
!
(
0
self
input
(
)
(
name
)
+
)
}
}
)
;
)
;
macro_rules
!
tuple_trait_inner
(
(
it
:
tt
self
:
expr
input
:
expr
(
)
head
:
ident
(
id
:
ident
)
+
)
=
>
(
{
let
(
i
o
)
=
self
.
it
.
parse
(
input
.
clone
(
)
)
?
;
succ
!
(
it
tuple_trait_inner
!
(
self
i
(
o
)
(
id
)
+
)
)
}
)
;
(
it
:
tt
self
:
expr
input
:
expr
(
(
parsed
:
tt
)
*
)
head
:
ident
(
id
:
ident
)
+
)
=
>
(
{
let
(
i
o
)
=
self
.
it
.
parse
(
input
.
clone
(
)
)
?
;
succ
!
(
it
tuple_trait_inner
!
(
self
i
(
(
parsed
)
*
o
)
(
id
)
+
)
)
}
)
;
(
it
:
tt
self
:
expr
input
:
expr
(
(
parsed
:
tt
)
*
)
head
:
ident
)
=
>
(
{
let
(
i
o
)
=
self
.
it
.
parse
(
input
.
clone
(
)
)
?
;
Ok
(
(
i
(
(
parsed
)
*
o
)
)
)
}
)
;
)
;
tuple_trait
!
(
FnA
A
FnB
B
FnC
C
FnD
D
FnE
E
FnF
F
FnG
G
FnH
H
FnI
I
FnJ
J
FnK
K
FnL
L
FnM
M
FnN
N
FnO
O
FnP
P
FnQ
Q
FnR
R
FnS
S
FnT
T
FnU
U
)
;
impl
<
I
E
:
ParseError
<
I
>
>
Tuple
<
I
(
)
E
>
for
(
)
{
fn
parse
(
&
mut
self
input
:
I
)
-
>
IResult
<
I
(
)
E
>
{
Ok
(
(
input
(
)
)
)
}
}
pub
fn
tuple
<
I
O
E
:
ParseError
<
I
>
List
:
Tuple
<
I
O
E
>
>
(
mut
l
:
List
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E
>
{
move
|
i
:
I
|
l
.
parse
(
i
)
}
