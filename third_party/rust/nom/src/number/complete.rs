use
crate
:
:
branch
:
:
alt
;
use
crate
:
:
bytes
:
:
complete
:
:
tag
;
use
crate
:
:
character
:
:
complete
:
:
{
char
digit1
sign
}
;
use
crate
:
:
combinator
:
:
{
cut
map
opt
recognize
}
;
use
crate
:
:
error
:
:
ParseError
;
use
crate
:
:
error
:
:
{
make_error
ErrorKind
}
;
use
crate
:
:
internal
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
{
Range
RangeFrom
RangeTo
}
;
use
crate
:
:
sequence
:
:
{
pair
tuple
}
;
use
crate
:
:
traits
:
:
{
AsBytes
AsChar
Compare
InputIter
InputLength
InputTake
InputTakeAtPosition
Offset
Slice
}
;
#
[
inline
]
pub
fn
be_u8
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u8
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
1
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
res
=
input
.
iter_elements
(
)
.
next
(
)
.
unwrap
(
)
;
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
be_u16
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u16
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
2
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u16
;
for
byte
in
input
.
iter_elements
(
)
.
take
(
bound
)
{
res
=
(
res
<
<
8
)
+
byte
as
u16
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
be_u24
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
3
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u32
;
for
byte
in
input
.
iter_elements
(
)
.
take
(
bound
)
{
res
=
(
res
<
<
8
)
+
byte
as
u32
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
be_u32
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
4
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u32
;
for
byte
in
input
.
iter_elements
(
)
.
take
(
bound
)
{
res
=
(
res
<
<
8
)
+
byte
as
u32
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
be_u64
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
8
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u64
;
for
byte
in
input
.
iter_elements
(
)
.
take
(
bound
)
{
res
=
(
res
<
<
8
)
+
byte
as
u64
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
be_u128
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u128
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
16
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u128
;
for
byte
in
input
.
iter_elements
(
)
.
take
(
bound
)
{
res
=
(
res
<
<
8
)
+
byte
as
u128
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
be_i8
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i8
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u8
.
map
(
|
x
|
x
as
i8
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
be_i16
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i16
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u16
.
map
(
|
x
|
x
as
i16
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
be_i24
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u24
.
map
(
|
x
|
{
if
x
&
0x80_00_00
!
=
0
{
(
x
|
0xff_00_00_00
)
as
i32
}
else
{
x
as
i32
}
}
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
be_i32
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u32
.
map
(
|
x
|
x
as
i32
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
be_i64
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u64
.
map
(
|
x
|
x
as
i64
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
be_i128
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i128
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u128
.
map
(
|
x
|
x
as
i128
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
le_u8
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u8
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
1
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
res
=
input
.
iter_elements
(
)
.
next
(
)
.
unwrap
(
)
;
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
le_u16
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u16
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
2
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u16
;
for
(
index
byte
)
in
input
.
iter_indices
(
)
.
take
(
bound
)
{
res
+
=
(
byte
as
u16
)
<
<
(
8
*
index
)
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
le_u24
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
3
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u32
;
for
(
index
byte
)
in
input
.
iter_indices
(
)
.
take
(
bound
)
{
res
+
=
(
byte
as
u32
)
<
<
(
8
*
index
)
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
le_u32
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
4
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u32
;
for
(
index
byte
)
in
input
.
iter_indices
(
)
.
take
(
bound
)
{
res
+
=
(
byte
as
u32
)
<
<
(
8
*
index
)
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
le_u64
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
8
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u64
;
for
(
index
byte
)
in
input
.
iter_indices
(
)
.
take
(
bound
)
{
res
+
=
(
byte
as
u64
)
<
<
(
8
*
index
)
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
le_u128
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u128
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
16
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
res
=
0u128
;
for
(
index
byte
)
in
input
.
iter_indices
(
)
.
take
(
bound
)
{
res
+
=
(
byte
as
u128
)
<
<
(
8
*
index
)
;
}
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
le_i8
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i8
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
be_u8
.
map
(
|
x
|
x
as
i8
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
le_i16
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i16
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
le_u16
.
map
(
|
x
|
x
as
i16
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
le_i24
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
le_u24
.
map
(
|
x
|
{
if
x
&
0x80_00_00
!
=
0
{
(
x
|
0xff_00_00_00
)
as
i32
}
else
{
x
as
i32
}
}
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
le_i32
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
le_u32
.
map
(
|
x
|
x
as
i32
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
le_i64
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
le_u64
.
map
(
|
x
|
x
as
i64
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
le_i128
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
i128
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
le_u128
.
map
(
|
x
|
x
as
i128
)
.
parse
(
input
)
}
#
[
inline
]
pub
fn
u8
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
u8
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
bound
:
usize
=
1
;
if
input
.
input_len
(
)
<
bound
{
Err
(
Err
:
:
Error
(
make_error
(
input
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
res
=
input
.
iter_elements
(
)
.
next
(
)
.
unwrap
(
)
;
Ok
(
(
input
.
slice
(
bound
.
.
)
res
)
)
}
}
#
[
inline
]
pub
fn
u16
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
u16
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_u16
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_u16
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_u16
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_u16
}
}
#
[
inline
]
pub
fn
u24
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
u32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_u24
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_u24
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_u24
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_u24
}
}
#
[
inline
]
pub
fn
u32
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
u32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_u32
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_u32
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_u32
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_u32
}
}
#
[
inline
]
pub
fn
u64
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
u64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_u64
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_u64
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_u64
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_u64
}
}
#
[
inline
]
pub
fn
u128
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
u128
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_u128
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_u128
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_u128
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_u128
}
}
#
[
inline
]
pub
fn
i8
<
I
E
:
ParseError
<
I
>
>
(
i
:
I
)
-
>
IResult
<
I
i8
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
u8
.
map
(
|
x
|
x
as
i8
)
.
parse
(
i
)
}
#
[
inline
]
pub
fn
i16
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
i16
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_i16
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_i16
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_i16
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_i16
}
}
#
[
inline
]
pub
fn
i24
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
i32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_i24
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_i24
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_i24
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_i24
}
}
#
[
inline
]
pub
fn
i32
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
i32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_i32
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_i32
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_i32
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_i32
}
}
#
[
inline
]
pub
fn
i64
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
i64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_i64
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_i64
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_i64
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_i64
}
}
#
[
inline
]
pub
fn
i128
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
i128
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_i128
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_i128
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_i128
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_i128
}
}
#
[
inline
]
pub
fn
be_f32
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
f32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
be_u32
(
input
)
{
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
f32
:
:
from_bits
(
o
)
)
)
}
}
#
[
inline
]
pub
fn
be_f64
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
f64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
be_u64
(
input
)
{
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
f64
:
:
from_bits
(
o
)
)
)
}
}
#
[
inline
]
pub
fn
le_f32
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
f32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
le_u32
(
input
)
{
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
f32
:
:
from_bits
(
o
)
)
)
}
}
#
[
inline
]
pub
fn
le_f64
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
f64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
le_u64
(
input
)
{
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
f64
:
:
from_bits
(
o
)
)
)
}
}
#
[
inline
]
pub
fn
f32
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
f32
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_f32
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_f32
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_f32
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_f32
}
}
#
[
inline
]
pub
fn
f64
<
I
E
:
ParseError
<
I
>
>
(
endian
:
crate
:
:
number
:
:
Endianness
)
-
>
fn
(
I
)
-
>
IResult
<
I
f64
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
match
endian
{
crate
:
:
number
:
:
Endianness
:
:
Big
=
>
be_f64
crate
:
:
number
:
:
Endianness
:
:
Little
=
>
le_f64
#
[
cfg
(
target_endian
=
"
big
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
be_f64
#
[
cfg
(
target_endian
=
"
little
"
)
]
crate
:
:
number
:
:
Endianness
:
:
Native
=
>
le_f64
}
}
#
[
inline
]
pub
fn
hex_u32
<
'
a
E
:
ParseError
<
&
'
a
[
u8
]
>
>
(
input
:
&
'
a
[
u8
]
)
-
>
IResult
<
&
'
a
[
u8
]
u32
E
>
{
let
(
i
o
)
=
crate
:
:
bytes
:
:
complete
:
:
is_a
(
&
b
"
0123456789abcdefABCDEF
"
[
.
.
]
)
(
input
)
?
;
let
(
parsed
remaining
)
=
if
o
.
len
(
)
<
=
8
{
(
o
i
)
}
else
{
(
&
input
[
.
.
8
]
&
input
[
8
.
.
]
)
}
;
let
res
=
parsed
.
iter
(
)
.
rev
(
)
.
enumerate
(
)
.
map
(
|
(
k
&
v
)
|
{
let
digit
=
v
as
char
;
digit
.
to_digit
(
16
)
.
unwrap_or
(
0
)
<
<
(
k
*
4
)
}
)
.
sum
(
)
;
Ok
(
(
remaining
res
)
)
}
#
[
rustfmt
:
:
skip
]
pub
fn
recognize_float
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
T
E
>
where
T
:
Slice
<
RangeFrom
<
usize
>
>
+
Slice
<
RangeTo
<
usize
>
>
T
:
Clone
+
Offset
T
:
InputIter
<
T
as
InputIter
>
:
:
Item
:
AsChar
T
:
InputTakeAtPosition
<
T
as
InputTakeAtPosition
>
:
:
Item
:
AsChar
{
recognize
(
tuple
(
(
opt
(
alt
(
(
char
(
'
+
'
)
char
(
'
-
'
)
)
)
)
alt
(
(
map
(
tuple
(
(
digit1
opt
(
pair
(
char
(
'
.
'
)
opt
(
digit1
)
)
)
)
)
|
_
|
(
)
)
map
(
tuple
(
(
char
(
'
.
'
)
digit1
)
)
|
_
|
(
)
)
)
)
opt
(
tuple
(
(
alt
(
(
char
(
'
e
'
)
char
(
'
E
'
)
)
)
opt
(
alt
(
(
char
(
'
+
'
)
char
(
'
-
'
)
)
)
)
cut
(
digit1
)
)
)
)
)
)
)
(
input
)
}
#
[
doc
(
hidden
)
]
pub
fn
recognize_float_or_exceptions
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
T
E
>
where
T
:
Slice
<
RangeFrom
<
usize
>
>
+
Slice
<
RangeTo
<
usize
>
>
T
:
Clone
+
Offset
T
:
InputIter
+
InputTake
+
Compare
<
&
'
static
str
>
<
T
as
InputIter
>
:
:
Item
:
AsChar
T
:
InputTakeAtPosition
<
T
as
InputTakeAtPosition
>
:
:
Item
:
AsChar
{
alt
(
(
|
i
:
T
|
{
recognize_float
:
:
<
_
E
>
(
i
.
clone
(
)
)
.
map_err
(
|
e
|
match
e
{
crate
:
:
Err
:
:
Error
(
_
)
=
>
crate
:
:
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Float
)
)
crate
:
:
Err
:
:
Failure
(
_
)
=
>
crate
:
:
Err
:
:
Failure
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Float
)
)
crate
:
:
Err
:
:
Incomplete
(
needed
)
=
>
crate
:
:
Err
:
:
Incomplete
(
needed
)
}
)
}
|
i
:
T
|
{
crate
:
:
bytes
:
:
complete
:
:
tag_no_case
:
:
<
_
_
E
>
(
"
nan
"
)
(
i
.
clone
(
)
)
.
map_err
(
|
_
|
crate
:
:
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Float
)
)
)
}
|
i
:
T
|
{
crate
:
:
bytes
:
:
complete
:
:
tag_no_case
:
:
<
_
_
E
>
(
"
inf
"
)
(
i
.
clone
(
)
)
.
map_err
(
|
_
|
crate
:
:
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Float
)
)
)
}
|
i
:
T
|
{
crate
:
:
bytes
:
:
complete
:
:
tag_no_case
:
:
<
_
_
E
>
(
"
infinity
"
)
(
i
.
clone
(
)
)
.
map_err
(
|
_
|
crate
:
:
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Float
)
)
)
}
)
)
(
input
)
}
pub
fn
recognize_float_parts
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
(
bool
T
T
i32
)
E
>
where
T
:
Slice
<
RangeFrom
<
usize
>
>
+
Slice
<
RangeTo
<
usize
>
>
+
Slice
<
Range
<
usize
>
>
T
:
Clone
+
Offset
T
:
InputIter
+
InputTake
<
T
as
InputIter
>
:
:
Item
:
AsChar
+
Copy
T
:
InputTakeAtPosition
+
InputLength
<
T
as
InputTakeAtPosition
>
:
:
Item
:
AsChar
T
:
for
<
'
a
>
Compare
<
&
'
a
[
u8
]
>
T
:
AsBytes
{
let
(
i
sign
)
=
sign
(
input
.
clone
(
)
)
?
;
let
(
i
zeroes
)
=
match
i
.
as_bytes
(
)
.
iter
(
)
.
position
(
|
c
|
*
c
!
=
b
'
0
'
)
{
Some
(
index
)
=
>
i
.
take_split
(
index
)
None
=
>
i
.
take_split
(
i
.
input_len
(
)
)
}
;
let
(
i
mut
integer
)
=
match
i
.
as_bytes
(
)
.
iter
(
)
.
position
(
|
c
|
!
(
*
c
>
=
b
'
0
'
&
&
*
c
<
=
b
'
9
'
)
)
{
Some
(
index
)
=
>
i
.
take_split
(
index
)
None
=
>
i
.
take_split
(
i
.
input_len
(
)
)
}
;
if
integer
.
input_len
(
)
=
=
0
&
&
zeroes
.
input_len
(
)
>
0
{
integer
=
zeroes
.
slice
(
zeroes
.
input_len
(
)
-
1
.
.
)
;
}
let
(
i
opt_dot
)
=
opt
(
tag
(
&
b
"
.
"
[
.
.
]
)
)
(
i
)
?
;
let
(
i
fraction
)
=
if
opt_dot
.
is_none
(
)
{
let
i2
=
i
.
clone
(
)
;
(
i2
i
.
slice
(
.
.
0
)
)
}
else
{
let
mut
zero_count
=
0usize
;
let
mut
position
=
None
;
for
(
pos
c
)
in
i
.
as_bytes
(
)
.
iter
(
)
.
enumerate
(
)
{
if
*
c
>
=
b
'
0
'
&
&
*
c
<
=
b
'
9
'
{
if
*
c
=
=
b
'
0
'
{
zero_count
+
=
1
;
}
else
{
zero_count
=
0
;
}
}
else
{
position
=
Some
(
pos
)
;
break
;
}
}
let
position
=
position
.
unwrap_or
(
i
.
input_len
(
)
)
;
let
index
=
if
zero_count
=
=
0
{
position
}
else
if
zero_count
=
=
position
{
position
-
zero_count
+
1
}
else
{
position
-
zero_count
}
;
(
i
.
slice
(
position
.
.
)
i
.
slice
(
.
.
index
)
)
}
;
if
integer
.
input_len
(
)
=
=
0
&
&
fraction
.
input_len
(
)
=
=
0
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
input
ErrorKind
:
:
Float
)
)
)
;
}
let
i2
=
i
.
clone
(
)
;
let
(
i
e
)
=
match
i
.
as_bytes
(
)
.
iter
(
)
.
next
(
)
{
Some
(
b
'
e
'
)
=
>
(
i
.
slice
(
1
.
.
)
true
)
Some
(
b
'
E
'
)
=
>
(
i
.
slice
(
1
.
.
)
true
)
_
=
>
(
i
false
)
}
;
let
(
i
exp
)
=
if
e
{
cut
(
crate
:
:
character
:
:
complete
:
:
i32
)
(
i
)
?
}
else
{
(
i2
0
)
}
;
Ok
(
(
i
(
sign
integer
fraction
exp
)
)
)
}
use
crate
:
:
traits
:
:
ParseTo
;
pub
fn
float
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
f32
E
>
where
T
:
Slice
<
RangeFrom
<
usize
>
>
+
Slice
<
RangeTo
<
usize
>
>
+
Slice
<
Range
<
usize
>
>
T
:
Clone
+
Offset
+
ParseTo
<
f32
>
+
Compare
<
&
'
static
str
>
T
:
InputIter
+
InputLength
+
InputTake
<
T
as
InputIter
>
:
:
Item
:
AsChar
+
Copy
<
T
as
InputIter
>
:
:
IterElem
:
Clone
T
:
InputTakeAtPosition
<
T
as
InputTakeAtPosition
>
:
:
Item
:
AsChar
T
:
AsBytes
T
:
for
<
'
a
>
Compare
<
&
'
a
[
u8
]
>
{
let
(
i
s
)
=
recognize_float_or_exceptions
(
input
)
?
;
match
s
.
parse_to
(
)
{
Some
(
f
)
=
>
Ok
(
(
i
f
)
)
None
=
>
Err
(
crate
:
:
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
crate
:
:
error
:
:
ErrorKind
:
:
Float
)
)
)
}
}
pub
fn
double
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
f64
E
>
where
T
:
Slice
<
RangeFrom
<
usize
>
>
+
Slice
<
RangeTo
<
usize
>
>
+
Slice
<
Range
<
usize
>
>
T
:
Clone
+
Offset
+
ParseTo
<
f64
>
+
Compare
<
&
'
static
str
>
T
:
InputIter
+
InputLength
+
InputTake
<
T
as
InputIter
>
:
:
Item
:
AsChar
+
Copy
<
T
as
InputIter
>
:
:
IterElem
:
Clone
T
:
InputTakeAtPosition
<
T
as
InputTakeAtPosition
>
:
:
Item
:
AsChar
T
:
AsBytes
T
:
for
<
'
a
>
Compare
<
&
'
a
[
u8
]
>
{
let
(
i
s
)
=
recognize_float_or_exceptions
(
input
)
?
;
match
s
.
parse_to
(
)
{
Some
(
f
)
=
>
Ok
(
(
i
f
)
)
None
=
>
Err
(
crate
:
:
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
crate
:
:
error
:
:
ErrorKind
:
:
Float
)
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
error
:
:
ErrorKind
;
use
crate
:
:
internal
:
:
Err
;
use
proptest
:
:
prelude
:
:
*
;
macro_rules
!
assert_parse
(
(
left
:
expr
right
:
expr
)
=
>
{
let
res
:
crate
:
:
IResult
<
_
_
(
_
ErrorKind
)
>
=
left
;
assert_eq
!
(
res
right
)
;
}
;
)
;
#
[
test
]
fn
i8_tests
(
)
{
assert_parse
!
(
i8
(
&
[
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
i8
(
&
[
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
127
)
)
)
;
assert_parse
!
(
i8
(
&
[
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
i8
(
&
[
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
128
)
)
)
;
}
#
[
test
]
fn
be_i8_tests
(
)
{
assert_parse
!
(
be_i8
(
&
[
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
be_i8
(
&
[
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
127
)
)
)
;
assert_parse
!
(
be_i8
(
&
[
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
be_i8
(
&
[
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
128
)
)
)
;
}
#
[
test
]
fn
be_i16_tests
(
)
{
assert_parse
!
(
be_i16
(
&
[
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
be_i16
(
&
[
0x7f
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
32_767_i16
)
)
)
;
assert_parse
!
(
be_i16
(
&
[
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
be_i16
(
&
[
0x80
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
32_768_i16
)
)
)
;
}
#
[
test
]
fn
be_u24_tests
(
)
{
assert_parse
!
(
be_u24
(
&
[
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
be_u24
(
&
[
0x00
0xFF
0xFF
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
65_535_u32
)
)
)
;
assert_parse
!
(
be_u24
(
&
[
0x12
0x34
0x56
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
1_193_046_u32
)
)
)
;
}
#
[
test
]
fn
be_i24_tests
(
)
{
assert_parse
!
(
be_i24
(
&
[
0xFF
0xFF
0xFF
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1_i32
)
)
)
;
assert_parse
!
(
be_i24
(
&
[
0xFF
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
65_536_i32
)
)
)
;
assert_parse
!
(
be_i24
(
&
[
0xED
0xCB
0xAA
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1_193_046_i32
)
)
)
;
}
#
[
test
]
fn
be_i32_tests
(
)
{
assert_parse
!
(
be_i32
(
&
[
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
be_i32
(
&
[
0x7f
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
2_147_483_647_i32
)
)
)
;
assert_parse
!
(
be_i32
(
&
[
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
be_i32
(
&
[
0x80
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
2_147_483_648_i32
)
)
)
;
}
#
[
test
]
fn
be_i64_tests
(
)
{
assert_parse
!
(
be_i64
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
be_i64
(
&
[
0x7f
0xff
0xff
0xff
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
9_223_372_036_854_775_807_i64
)
)
)
;
assert_parse
!
(
be_i64
(
&
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
be_i64
(
&
[
0x80
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
9_223_372_036_854_775_808_i64
)
)
)
;
}
#
[
test
]
fn
be_i128_tests
(
)
{
assert_parse
!
(
be_i128
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
be_i128
(
&
[
0x7f
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
170_141_183_460_469_231_731_687_303_715_884_105_727_i128
)
)
)
;
assert_parse
!
(
be_i128
(
&
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
be_i128
(
&
[
0x80
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
170_141_183_460_469_231_731_687_303_715_884_105_728_i128
)
)
)
;
}
#
[
test
]
fn
le_i8_tests
(
)
{
assert_parse
!
(
le_i8
(
&
[
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
le_i8
(
&
[
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
127
)
)
)
;
assert_parse
!
(
le_i8
(
&
[
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
le_i8
(
&
[
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
128
)
)
)
;
}
#
[
test
]
fn
le_i16_tests
(
)
{
assert_parse
!
(
le_i16
(
&
[
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
le_i16
(
&
[
0xff
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
32_767_i16
)
)
)
;
assert_parse
!
(
le_i16
(
&
[
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
le_i16
(
&
[
0x00
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
32_768_i16
)
)
)
;
}
#
[
test
]
fn
le_u24_tests
(
)
{
assert_parse
!
(
le_u24
(
&
[
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
le_u24
(
&
[
0xFF
0xFF
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
65_535_u32
)
)
)
;
assert_parse
!
(
le_u24
(
&
[
0x56
0x34
0x12
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
1_193_046_u32
)
)
)
;
}
#
[
test
]
fn
le_i24_tests
(
)
{
assert_parse
!
(
le_i24
(
&
[
0xFF
0xFF
0xFF
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1_i32
)
)
)
;
assert_parse
!
(
le_i24
(
&
[
0x00
0x00
0xFF
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
65_536_i32
)
)
)
;
assert_parse
!
(
le_i24
(
&
[
0xAA
0xCB
0xED
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1_193_046_i32
)
)
)
;
}
#
[
test
]
fn
le_i32_tests
(
)
{
assert_parse
!
(
le_i32
(
&
[
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
le_i32
(
&
[
0xff
0xff
0xff
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
2_147_483_647_i32
)
)
)
;
assert_parse
!
(
le_i32
(
&
[
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
le_i32
(
&
[
0x00
0x00
0x00
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
2_147_483_648_i32
)
)
)
;
}
#
[
test
]
fn
le_i64_tests
(
)
{
assert_parse
!
(
le_i64
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
le_i64
(
&
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
9_223_372_036_854_775_807_i64
)
)
)
;
assert_parse
!
(
le_i64
(
&
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
le_i64
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
9_223_372_036_854_775_808_i64
)
)
)
;
}
#
[
test
]
fn
le_i128_tests
(
)
{
assert_parse
!
(
le_i128
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
le_i128
(
&
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0x7f
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
170_141_183_460_469_231_731_687_303_715_884_105_727_i128
)
)
)
;
assert_parse
!
(
le_i128
(
&
[
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
0xff
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
1
)
)
)
;
assert_parse
!
(
le_i128
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x80
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
170_141_183_460_469_231_731_687_303_715_884_105_728_i128
)
)
)
;
}
#
[
test
]
fn
be_f32_tests
(
)
{
assert_parse
!
(
be_f32
(
&
[
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0_f32
)
)
)
;
assert_parse
!
(
be_f32
(
&
[
0x4d
0x31
0x1f
0xd8
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
185_728_392_f32
)
)
)
;
}
#
[
test
]
fn
be_f64_tests
(
)
{
assert_parse
!
(
be_f64
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0_f64
)
)
)
;
assert_parse
!
(
be_f64
(
&
[
0x41
0xa6
0x23
0xfb
0x10
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
185_728_392_f64
)
)
)
;
}
#
[
test
]
fn
le_f32_tests
(
)
{
assert_parse
!
(
le_f32
(
&
[
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0_f32
)
)
)
;
assert_parse
!
(
le_f32
(
&
[
0xd8
0x1f
0x31
0x4d
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
185_728_392_f32
)
)
)
;
}
#
[
test
]
fn
le_f64_tests
(
)
{
assert_parse
!
(
le_f64
(
&
[
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0_f64
)
)
)
;
assert_parse
!
(
le_f64
(
&
[
0x00
0x00
0x00
0x10
0xfb
0x23
0xa6
0x41
]
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
185_728_392_f64
)
)
)
;
}
#
[
test
]
fn
hex_u32_tests
(
)
{
assert_parse
!
(
hex_u32
(
&
b
"
;
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
;
"
[
.
.
]
ErrorKind
:
:
IsA
)
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
ff
;
"
[
.
.
]
)
Ok
(
(
&
b
"
;
"
[
.
.
]
255
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
1be2
;
"
[
.
.
]
)
Ok
(
(
&
b
"
;
"
[
.
.
]
7138
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
c5a31be2
;
"
[
.
.
]
)
Ok
(
(
&
b
"
;
"
[
.
.
]
3_315_801_058
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
C5A31be2
;
"
[
.
.
]
)
Ok
(
(
&
b
"
;
"
[
.
.
]
3_315_801_058
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
00c5a31be2
;
"
[
.
.
]
)
Ok
(
(
&
b
"
e2
;
"
[
.
.
]
12_952_347
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
c5a31be201
;
"
[
.
.
]
)
Ok
(
(
&
b
"
01
;
"
[
.
.
]
3_315_801_058
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
ffffffff
;
"
[
.
.
]
)
Ok
(
(
&
b
"
;
"
[
.
.
]
4_294_967_295
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
0x1be2
;
"
[
.
.
]
)
Ok
(
(
&
b
"
x1be2
;
"
[
.
.
]
0
)
)
)
;
assert_parse
!
(
hex_u32
(
&
b
"
12af
"
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
0x12af
)
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
float_test
(
)
{
let
mut
test_cases
=
vec
!
[
"
+
3
.
14
"
"
3
.
14
"
"
-
3
.
14
"
"
0
"
"
0
.
0
"
"
1
.
"
"
.
789
"
"
-
.
5
"
"
1e7
"
"
-
1E
-
7
"
"
.
3e
-
2
"
"
1
.
e4
"
"
1
.
2e4
"
"
12
.
34
"
"
-
1
.
234E
-
12
"
"
-
1
.
234e
-
12
"
"
0
.
00000000000000000087
"
]
;
for
test
in
test_cases
.
drain
(
.
.
)
{
let
expected32
=
str
:
:
parse
:
:
<
f32
>
(
test
)
.
unwrap
(
)
;
let
expected64
=
str
:
:
parse
:
:
<
f64
>
(
test
)
.
unwrap
(
)
;
println
!
(
"
now
parsing
:
{
}
-
>
{
}
"
test
expected32
)
;
let
larger
=
format
!
(
"
{
}
"
test
)
;
assert_parse
!
(
recognize_float
(
&
larger
[
.
.
]
)
Ok
(
(
"
"
test
)
)
)
;
assert_parse
!
(
float
(
larger
.
as_bytes
(
)
)
Ok
(
(
&
b
"
"
[
.
.
]
expected32
)
)
)
;
assert_parse
!
(
float
(
&
larger
[
.
.
]
)
Ok
(
(
"
"
expected32
)
)
)
;
assert_parse
!
(
double
(
larger
.
as_bytes
(
)
)
Ok
(
(
&
b
"
"
[
.
.
]
expected64
)
)
)
;
assert_parse
!
(
double
(
&
larger
[
.
.
]
)
Ok
(
(
"
"
expected64
)
)
)
;
}
let
remaining_exponent
=
"
-
1
.
234E
-
"
;
assert_parse
!
(
recognize_float
(
remaining_exponent
)
Err
(
Err
:
:
Failure
(
(
"
"
ErrorKind
:
:
Digit
)
)
)
)
;
let
(
_i
nan
)
=
float
:
:
<
_
(
)
>
(
"
NaN
"
)
.
unwrap
(
)
;
assert
!
(
nan
.
is_nan
(
)
)
;
let
(
_i
inf
)
=
float
:
:
<
_
(
)
>
(
"
inf
"
)
.
unwrap
(
)
;
assert
!
(
inf
.
is_infinite
(
)
)
;
let
(
_i
inf
)
=
float
:
:
<
_
(
)
>
(
"
infinite
"
)
.
unwrap
(
)
;
assert
!
(
inf
.
is_infinite
(
)
)
;
}
#
[
test
]
fn
configurable_endianness
(
)
{
use
crate
:
:
number
:
:
Endianness
;
fn
be_tst16
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
u16
>
{
u16
(
Endianness
:
:
Big
)
(
i
)
}
fn
le_tst16
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
u16
>
{
u16
(
Endianness
:
:
Little
)
(
i
)
}
assert_eq
!
(
be_tst16
(
&
[
0x80
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
32_768_u16
)
)
)
;
assert_eq
!
(
le_tst16
(
&
[
0x80
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
128_u16
)
)
)
;
fn
be_tst32
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
u32
>
{
u32
(
Endianness
:
:
Big
)
(
i
)
}
fn
le_tst32
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
u32
>
{
u32
(
Endianness
:
:
Little
)
(
i
)
}
assert_eq
!
(
be_tst32
(
&
[
0x12
0x00
0x60
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
302_014_464_u32
)
)
)
;
assert_eq
!
(
le_tst32
(
&
[
0x12
0x00
0x60
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
6_291_474_u32
)
)
)
;
fn
be_tst64
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
u64
>
{
u64
(
Endianness
:
:
Big
)
(
i
)
}
fn
le_tst64
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
u64
>
{
u64
(
Endianness
:
:
Little
)
(
i
)
}
assert_eq
!
(
be_tst64
(
&
[
0x12
0x00
0x60
0x00
0x12
0x00
0x80
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
1_297_142_246_100_992_000_u64
)
)
)
;
assert_eq
!
(
le_tst64
(
&
[
0x12
0x00
0x60
0x00
0x12
0x00
0x80
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
36_028_874_334_666_770_u64
)
)
)
;
fn
be_tsti16
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
i16
>
{
i16
(
Endianness
:
:
Big
)
(
i
)
}
fn
le_tsti16
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
i16
>
{
i16
(
Endianness
:
:
Little
)
(
i
)
}
assert_eq
!
(
be_tsti16
(
&
[
0x00
0x80
]
)
Ok
(
(
&
b
"
"
[
.
.
]
128_i16
)
)
)
;
assert_eq
!
(
le_tsti16
(
&
[
0x00
0x80
]
)
Ok
(
(
&
b
"
"
[
.
.
]
-
32_768_i16
)
)
)
;
fn
be_tsti32
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
i32
>
{
i32
(
Endianness
:
:
Big
)
(
i
)
}
fn
le_tsti32
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
i32
>
{
i32
(
Endianness
:
:
Little
)
(
i
)
}
assert_eq
!
(
be_tsti32
(
&
[
0x00
0x12
0x60
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
1_204_224_i32
)
)
)
;
assert_eq
!
(
le_tsti32
(
&
[
0x00
0x12
0x60
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
6_296_064_i32
)
)
)
;
fn
be_tsti64
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
i64
>
{
i64
(
Endianness
:
:
Big
)
(
i
)
}
fn
le_tsti64
(
i
:
&
[
u8
]
)
-
>
IResult
<
&
[
u8
]
i64
>
{
i64
(
Endianness
:
:
Little
)
(
i
)
}
assert_eq
!
(
be_tsti64
(
&
[
0x00
0xFF
0x60
0x00
0x12
0x00
0x80
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
71_881_672_479_506_432_i64
)
)
)
;
assert_eq
!
(
le_tsti64
(
&
[
0x00
0xFF
0x60
0x00
0x12
0x00
0x80
0x00
]
)
Ok
(
(
&
b
"
"
[
.
.
]
36_028_874_334_732_032_i64
)
)
)
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
fn
parse_f64
(
i
:
&
str
)
-
>
IResult
<
&
str
f64
(
)
>
{
match
recognize_float_or_exceptions
(
i
)
{
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
i
s
)
)
=
>
{
if
s
.
is_empty
(
)
{
return
Err
(
Err
:
:
Error
(
(
)
)
)
;
}
match
s
.
parse_to
(
)
{
Some
(
n
)
=
>
Ok
(
(
i
n
)
)
None
=
>
Err
(
Err
:
:
Error
(
(
)
)
)
}
}
}
}
proptest
!
{
#
[
test
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
floats
(
s
in
"
\
\
PC
*
"
)
{
println
!
(
"
testing
{
}
"
s
)
;
let
res1
=
parse_f64
(
&
s
)
;
let
res2
=
double
:
:
<
_
(
)
>
(
s
.
as_str
(
)
)
;
assert_eq
!
(
res1
res2
)
;
}
}
}
