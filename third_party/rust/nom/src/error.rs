use
crate
:
:
internal
:
:
Parser
;
use
crate
:
:
lib
:
:
std
:
:
fmt
;
pub
trait
ParseError
<
I
>
:
Sized
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
;
fn
append
(
input
:
I
kind
:
ErrorKind
other
:
Self
)
-
>
Self
;
fn
from_char
(
input
:
I
_
:
char
)
-
>
Self
{
Self
:
:
from_error_kind
(
input
ErrorKind
:
:
Char
)
}
fn
or
(
self
other
:
Self
)
-
>
Self
{
other
}
}
pub
trait
ContextError
<
I
>
:
Sized
{
fn
add_context
(
_input
:
I
_ctx
:
&
'
static
str
other
:
Self
)
-
>
Self
{
other
}
}
pub
trait
FromExternalError
<
I
E
>
{
fn
from_external_error
(
input
:
I
kind
:
ErrorKind
e
:
E
)
-
>
Self
;
}
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
Error
<
I
>
{
pub
input
:
I
pub
code
:
ErrorKind
}
impl
<
I
>
Error
<
I
>
{
pub
fn
new
(
input
:
I
code
:
ErrorKind
)
-
>
Error
<
I
>
{
Error
{
input
code
}
}
}
impl
<
I
>
ParseError
<
I
>
for
Error
<
I
>
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
{
Error
{
input
code
:
kind
}
}
fn
append
(
_
:
I
_
:
ErrorKind
other
:
Self
)
-
>
Self
{
other
}
}
impl
<
I
>
ContextError
<
I
>
for
Error
<
I
>
{
}
impl
<
I
E
>
FromExternalError
<
I
E
>
for
Error
<
I
>
{
fn
from_external_error
(
input
:
I
kind
:
ErrorKind
_e
:
E
)
-
>
Self
{
Error
{
input
code
:
kind
}
}
}
impl
<
I
:
fmt
:
:
Display
>
fmt
:
:
Display
for
Error
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
error
{
:
?
}
at
:
{
}
"
self
.
code
self
.
input
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
I
:
fmt
:
:
Debug
+
fmt
:
:
Display
>
std
:
:
error
:
:
Error
for
Error
<
I
>
{
}
impl
<
I
>
ParseError
<
I
>
for
(
I
ErrorKind
)
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
{
(
input
kind
)
}
fn
append
(
_
:
I
_
:
ErrorKind
other
:
Self
)
-
>
Self
{
other
}
}
impl
<
I
>
ContextError
<
I
>
for
(
I
ErrorKind
)
{
}
impl
<
I
E
>
FromExternalError
<
I
E
>
for
(
I
ErrorKind
)
{
fn
from_external_error
(
input
:
I
kind
:
ErrorKind
_e
:
E
)
-
>
Self
{
(
input
kind
)
}
}
impl
<
I
>
ParseError
<
I
>
for
(
)
{
fn
from_error_kind
(
_
:
I
_
:
ErrorKind
)
-
>
Self
{
}
fn
append
(
_
:
I
_
:
ErrorKind
_
:
Self
)
-
>
Self
{
}
}
impl
<
I
>
ContextError
<
I
>
for
(
)
{
}
impl
<
I
E
>
FromExternalError
<
I
E
>
for
(
)
{
fn
from_external_error
(
_input
:
I
_kind
:
ErrorKind
_e
:
E
)
-
>
Self
{
}
}
pub
fn
make_error
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
kind
:
ErrorKind
)
-
>
E
{
E
:
:
from_error_kind
(
input
kind
)
}
pub
fn
append_error
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
kind
:
ErrorKind
other
:
E
)
-
>
E
{
E
:
:
append
(
input
kind
other
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
VerboseError
<
I
>
{
pub
errors
:
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
<
(
I
VerboseErrorKind
)
>
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
VerboseErrorKind
{
Context
(
&
'
static
str
)
Char
(
char
)
Nom
(
ErrorKind
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
impl
<
I
>
ParseError
<
I
>
for
VerboseError
<
I
>
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
{
VerboseError
{
errors
:
vec
!
[
(
input
VerboseErrorKind
:
:
Nom
(
kind
)
)
]
}
}
fn
append
(
input
:
I
kind
:
ErrorKind
mut
other
:
Self
)
-
>
Self
{
other
.
errors
.
push
(
(
input
VerboseErrorKind
:
:
Nom
(
kind
)
)
)
;
other
}
fn
from_char
(
input
:
I
c
:
char
)
-
>
Self
{
VerboseError
{
errors
:
vec
!
[
(
input
VerboseErrorKind
:
:
Char
(
c
)
)
]
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
impl
<
I
>
ContextError
<
I
>
for
VerboseError
<
I
>
{
fn
add_context
(
input
:
I
ctx
:
&
'
static
str
mut
other
:
Self
)
-
>
Self
{
other
.
errors
.
push
(
(
input
VerboseErrorKind
:
:
Context
(
ctx
)
)
)
;
other
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
impl
<
I
E
>
FromExternalError
<
I
E
>
for
VerboseError
<
I
>
{
fn
from_external_error
(
input
:
I
kind
:
ErrorKind
_e
:
E
)
-
>
Self
{
Self
:
:
from_error_kind
(
input
kind
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
I
:
fmt
:
:
Display
>
fmt
:
:
Display
for
VerboseError
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
Parse
error
:
"
)
?
;
for
(
input
error
)
in
&
self
.
errors
{
match
error
{
VerboseErrorKind
:
:
Nom
(
e
)
=
>
writeln
!
(
f
"
{
:
?
}
at
:
{
}
"
e
input
)
?
VerboseErrorKind
:
:
Char
(
c
)
=
>
writeln
!
(
f
"
expected
'
{
}
'
at
:
{
}
"
c
input
)
?
VerboseErrorKind
:
:
Context
(
s
)
=
>
writeln
!
(
f
"
in
section
'
{
}
'
at
:
{
}
"
s
input
)
?
}
}
Ok
(
(
)
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
I
:
fmt
:
:
Debug
+
fmt
:
:
Display
>
std
:
:
error
:
:
Error
for
VerboseError
<
I
>
{
}
use
crate
:
:
internal
:
:
{
Err
IResult
}
;
pub
fn
context
<
I
:
Clone
E
:
ContextError
<
I
>
F
O
>
(
context
:
&
'
static
str
mut
f
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
i
:
I
|
match
f
.
parse
(
i
.
clone
(
)
)
{
Ok
(
o
)
=
>
Ok
(
o
)
Err
(
Err
:
:
Incomplete
(
i
)
)
=
>
Err
(
Err
:
:
Incomplete
(
i
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
add_context
(
i
context
e
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
E
:
:
add_context
(
i
context
e
)
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
alloc
"
)
)
)
]
pub
fn
convert_error
<
I
:
core
:
:
ops
:
:
Deref
<
Target
=
str
>
>
(
input
:
I
e
:
VerboseError
<
I
>
)
-
>
crate
:
:
lib
:
:
std
:
:
string
:
:
String
{
use
crate
:
:
lib
:
:
std
:
:
fmt
:
:
Write
;
use
crate
:
:
traits
:
:
Offset
;
let
mut
result
=
crate
:
:
lib
:
:
std
:
:
string
:
:
String
:
:
new
(
)
;
for
(
i
(
substring
kind
)
)
in
e
.
errors
.
iter
(
)
.
enumerate
(
)
{
let
offset
=
input
.
offset
(
substring
)
;
if
input
.
is_empty
(
)
{
match
kind
{
VerboseErrorKind
:
:
Char
(
c
)
=
>
{
write
!
(
&
mut
result
"
{
}
:
expected
'
{
}
'
got
empty
input
\
n
\
n
"
i
c
)
}
VerboseErrorKind
:
:
Context
(
s
)
=
>
write
!
(
&
mut
result
"
{
}
:
in
{
}
got
empty
input
\
n
\
n
"
i
s
)
VerboseErrorKind
:
:
Nom
(
e
)
=
>
write
!
(
&
mut
result
"
{
}
:
in
{
:
?
}
got
empty
input
\
n
\
n
"
i
e
)
}
}
else
{
let
prefix
=
&
input
.
as_bytes
(
)
[
.
.
offset
]
;
let
line_number
=
prefix
.
iter
(
)
.
filter
(
|
&
&
b
|
b
=
=
b
'
\
n
'
)
.
count
(
)
+
1
;
let
line_begin
=
prefix
.
iter
(
)
.
rev
(
)
.
position
(
|
&
b
|
b
=
=
b
'
\
n
'
)
.
map
(
|
pos
|
offset
-
pos
)
.
unwrap_or
(
0
)
;
let
line
=
input
[
line_begin
.
.
]
.
lines
(
)
.
next
(
)
.
unwrap_or
(
&
input
[
line_begin
.
.
]
)
.
trim_end
(
)
;
let
column_number
=
line
.
offset
(
substring
)
+
1
;
match
kind
{
VerboseErrorKind
:
:
Char
(
c
)
=
>
{
if
let
Some
(
actual
)
=
substring
.
chars
(
)
.
next
(
)
{
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
expected
'
{
expected
}
'
found
{
actual
}
\
n
\
n
"
i
=
i
line_number
=
line_number
line
=
line
caret
=
'
^
'
column
=
column_number
expected
=
c
actual
=
actual
)
}
else
{
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
expected
'
{
expected
}
'
got
end
of
input
\
n
\
n
"
i
=
i
line_number
=
line_number
line
=
line
caret
=
'
^
'
column
=
column_number
expected
=
c
)
}
}
VerboseErrorKind
:
:
Context
(
s
)
=
>
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
in
{
context
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
n
"
i
=
i
line_number
=
line_number
context
=
s
line
=
line
caret
=
'
^
'
column
=
column_number
)
VerboseErrorKind
:
:
Nom
(
e
)
=
>
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
in
{
nom_err
:
?
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
n
"
i
=
i
line_number
=
line_number
nom_err
=
e
line
=
line
caret
=
'
^
'
column
=
column_number
)
}
}
.
unwrap
(
)
;
}
result
}
#
[
rustfmt
:
:
skip
]
#
[
derive
(
Debug
PartialEq
Eq
Hash
Clone
Copy
)
]
#
[
allow
(
deprecated
missing_docs
)
]
pub
enum
ErrorKind
{
Tag
MapRes
MapOpt
Alt
IsNot
IsA
SeparatedList
SeparatedNonEmptyList
Many0
Many1
ManyTill
Count
TakeUntil
LengthValue
TagClosure
Alpha
Digit
HexDigit
OctDigit
AlphaNumeric
Space
MultiSpace
LengthValueFn
Eof
Switch
TagBits
OneOf
NoneOf
Char
CrLf
RegexpMatch
RegexpMatches
RegexpFind
RegexpCapture
RegexpCaptures
TakeWhile1
Complete
Fix
Escaped
EscapedTransform
NonEmpty
ManyMN
Not
Permutation
Verify
TakeTill1
TakeWhileMN
TooLarge
Many0Count
Many1Count
Float
Satisfy
Fail
}
#
[
rustfmt
:
:
skip
]
#
[
allow
(
deprecated
)
]
pub
fn
error_to_u32
(
e
:
&
ErrorKind
)
-
>
u32
{
match
*
e
{
ErrorKind
:
:
Tag
=
>
1
ErrorKind
:
:
MapRes
=
>
2
ErrorKind
:
:
MapOpt
=
>
3
ErrorKind
:
:
Alt
=
>
4
ErrorKind
:
:
IsNot
=
>
5
ErrorKind
:
:
IsA
=
>
6
ErrorKind
:
:
SeparatedList
=
>
7
ErrorKind
:
:
SeparatedNonEmptyList
=
>
8
ErrorKind
:
:
Many1
=
>
9
ErrorKind
:
:
Count
=
>
10
ErrorKind
:
:
TakeUntil
=
>
12
ErrorKind
:
:
LengthValue
=
>
15
ErrorKind
:
:
TagClosure
=
>
16
ErrorKind
:
:
Alpha
=
>
17
ErrorKind
:
:
Digit
=
>
18
ErrorKind
:
:
AlphaNumeric
=
>
19
ErrorKind
:
:
Space
=
>
20
ErrorKind
:
:
MultiSpace
=
>
21
ErrorKind
:
:
LengthValueFn
=
>
22
ErrorKind
:
:
Eof
=
>
23
ErrorKind
:
:
Switch
=
>
27
ErrorKind
:
:
TagBits
=
>
28
ErrorKind
:
:
OneOf
=
>
29
ErrorKind
:
:
NoneOf
=
>
30
ErrorKind
:
:
Char
=
>
40
ErrorKind
:
:
CrLf
=
>
41
ErrorKind
:
:
RegexpMatch
=
>
42
ErrorKind
:
:
RegexpMatches
=
>
43
ErrorKind
:
:
RegexpFind
=
>
44
ErrorKind
:
:
RegexpCapture
=
>
45
ErrorKind
:
:
RegexpCaptures
=
>
46
ErrorKind
:
:
TakeWhile1
=
>
47
ErrorKind
:
:
Complete
=
>
48
ErrorKind
:
:
Fix
=
>
49
ErrorKind
:
:
Escaped
=
>
50
ErrorKind
:
:
EscapedTransform
=
>
51
ErrorKind
:
:
NonEmpty
=
>
56
ErrorKind
:
:
ManyMN
=
>
57
ErrorKind
:
:
HexDigit
=
>
59
ErrorKind
:
:
OctDigit
=
>
61
ErrorKind
:
:
Many0
=
>
62
ErrorKind
:
:
Not
=
>
63
ErrorKind
:
:
Permutation
=
>
64
ErrorKind
:
:
ManyTill
=
>
65
ErrorKind
:
:
Verify
=
>
66
ErrorKind
:
:
TakeTill1
=
>
67
ErrorKind
:
:
TakeWhileMN
=
>
69
ErrorKind
:
:
TooLarge
=
>
70
ErrorKind
:
:
Many0Count
=
>
71
ErrorKind
:
:
Many1Count
=
>
72
ErrorKind
:
:
Float
=
>
73
ErrorKind
:
:
Satisfy
=
>
74
ErrorKind
:
:
Fail
=
>
75
}
}
impl
ErrorKind
{
#
[
rustfmt
:
:
skip
]
#
[
allow
(
deprecated
)
]
pub
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
ErrorKind
:
:
Tag
=
>
"
Tag
"
ErrorKind
:
:
MapRes
=
>
"
Map
on
Result
"
ErrorKind
:
:
MapOpt
=
>
"
Map
on
Option
"
ErrorKind
:
:
Alt
=
>
"
Alternative
"
ErrorKind
:
:
IsNot
=
>
"
IsNot
"
ErrorKind
:
:
IsA
=
>
"
IsA
"
ErrorKind
:
:
SeparatedList
=
>
"
Separated
list
"
ErrorKind
:
:
SeparatedNonEmptyList
=
>
"
Separated
non
empty
list
"
ErrorKind
:
:
Many0
=
>
"
Many0
"
ErrorKind
:
:
Many1
=
>
"
Many1
"
ErrorKind
:
:
Count
=
>
"
Count
"
ErrorKind
:
:
TakeUntil
=
>
"
Take
until
"
ErrorKind
:
:
LengthValue
=
>
"
Length
followed
by
value
"
ErrorKind
:
:
TagClosure
=
>
"
Tag
closure
"
ErrorKind
:
:
Alpha
=
>
"
Alphabetic
"
ErrorKind
:
:
Digit
=
>
"
Digit
"
ErrorKind
:
:
AlphaNumeric
=
>
"
AlphaNumeric
"
ErrorKind
:
:
Space
=
>
"
Space
"
ErrorKind
:
:
MultiSpace
=
>
"
Multiple
spaces
"
ErrorKind
:
:
LengthValueFn
=
>
"
LengthValueFn
"
ErrorKind
:
:
Eof
=
>
"
End
of
file
"
ErrorKind
:
:
Switch
=
>
"
Switch
"
ErrorKind
:
:
TagBits
=
>
"
Tag
on
bitstream
"
ErrorKind
:
:
OneOf
=
>
"
OneOf
"
ErrorKind
:
:
NoneOf
=
>
"
NoneOf
"
ErrorKind
:
:
Char
=
>
"
Char
"
ErrorKind
:
:
CrLf
=
>
"
CrLf
"
ErrorKind
:
:
RegexpMatch
=
>
"
RegexpMatch
"
ErrorKind
:
:
RegexpMatches
=
>
"
RegexpMatches
"
ErrorKind
:
:
RegexpFind
=
>
"
RegexpFind
"
ErrorKind
:
:
RegexpCapture
=
>
"
RegexpCapture
"
ErrorKind
:
:
RegexpCaptures
=
>
"
RegexpCaptures
"
ErrorKind
:
:
TakeWhile1
=
>
"
TakeWhile1
"
ErrorKind
:
:
Complete
=
>
"
Complete
"
ErrorKind
:
:
Fix
=
>
"
Fix
"
ErrorKind
:
:
Escaped
=
>
"
Escaped
"
ErrorKind
:
:
EscapedTransform
=
>
"
EscapedTransform
"
ErrorKind
:
:
NonEmpty
=
>
"
NonEmpty
"
ErrorKind
:
:
ManyMN
=
>
"
Many
(
m
n
)
"
ErrorKind
:
:
HexDigit
=
>
"
Hexadecimal
Digit
"
ErrorKind
:
:
OctDigit
=
>
"
Octal
digit
"
ErrorKind
:
:
Not
=
>
"
Negation
"
ErrorKind
:
:
Permutation
=
>
"
Permutation
"
ErrorKind
:
:
ManyTill
=
>
"
ManyTill
"
ErrorKind
:
:
Verify
=
>
"
predicate
verification
"
ErrorKind
:
:
TakeTill1
=
>
"
TakeTill1
"
ErrorKind
:
:
TakeWhileMN
=
>
"
TakeWhileMN
"
ErrorKind
:
:
TooLarge
=
>
"
Needed
data
size
is
too
large
"
ErrorKind
:
:
Many0Count
=
>
"
Count
occurrence
of
>
=
0
patterns
"
ErrorKind
:
:
Many1Count
=
>
"
Count
occurrence
of
>
=
1
patterns
"
ErrorKind
:
:
Float
=
>
"
Float
"
ErrorKind
:
:
Satisfy
=
>
"
Satisfy
"
ErrorKind
:
:
Fail
=
>
"
Fail
"
}
}
}
#
[
allow
(
unused_variables
)
]
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
error_position
(
(
input
:
expr
code
:
expr
)
=
>
(
{
crate
:
:
error
:
:
make_error
(
input
code
)
}
)
;
)
;
#
[
allow
(
unused_variables
)
]
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
error_node_position
(
(
input
:
expr
code
:
expr
next
:
expr
)
=
>
(
{
crate
:
:
error
:
:
append_error
(
input
code
next
)
}
)
;
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
#
[
cfg_attr
(
feature
=
"
docsrs
"
doc
(
cfg
(
feature
=
"
std
"
)
)
)
]
pub
fn
dbg_dmp
<
'
a
F
O
E
:
std
:
:
fmt
:
:
Debug
>
(
f
:
F
context
:
&
'
static
str
)
-
>
impl
Fn
(
&
'
a
[
u8
]
)
-
>
IResult
<
&
'
a
[
u8
]
O
E
>
where
F
:
Fn
(
&
'
a
[
u8
]
)
-
>
IResult
<
&
'
a
[
u8
]
O
E
>
{
use
crate
:
:
HexDisplay
;
move
|
i
:
&
'
a
[
u8
]
|
match
f
(
i
)
{
Err
(
e
)
=
>
{
println
!
(
"
{
}
:
Error
(
{
:
?
}
)
at
:
\
n
{
}
"
context
e
i
.
to_hex
(
8
)
)
;
Err
(
e
)
}
a
=
>
a
}
}
#
[
cfg
(
test
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
character
:
:
complete
:
:
char
;
#
[
test
]
fn
convert_error_panic
(
)
{
let
input
=
"
"
;
let
_result
:
IResult
<
_
_
VerboseError
<
&
str
>
>
=
char
(
'
x
'
)
(
input
)
;
}
}
