pub
trait
ParseError
<
I
>
:
Sized
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
;
fn
append
(
input
:
I
kind
:
ErrorKind
other
:
Self
)
-
>
Self
;
fn
from_char
(
input
:
I
_
:
char
)
-
>
Self
{
Self
:
:
from_error_kind
(
input
ErrorKind
:
:
Char
)
}
fn
or
(
self
other
:
Self
)
-
>
Self
{
other
}
fn
add_context
(
_input
:
I
_ctx
:
&
'
static
str
other
:
Self
)
-
>
Self
{
other
}
}
impl
<
I
>
ParseError
<
I
>
for
(
I
ErrorKind
)
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
{
(
input
kind
)
}
fn
append
(
_
:
I
_
:
ErrorKind
other
:
Self
)
-
>
Self
{
other
}
}
impl
<
I
>
ParseError
<
I
>
for
(
)
{
fn
from_error_kind
(
_
:
I
_
:
ErrorKind
)
-
>
Self
{
}
fn
append
(
_
:
I
_
:
ErrorKind
_
:
Self
)
-
>
Self
{
}
}
pub
fn
make_error
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
kind
:
ErrorKind
)
-
>
E
{
E
:
:
from_error_kind
(
input
kind
)
}
pub
fn
append_error
<
I
E
:
ParseError
<
I
>
>
(
input
:
I
kind
:
ErrorKind
other
:
E
)
-
>
E
{
E
:
:
append
(
input
kind
other
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
VerboseError
<
I
>
{
pub
errors
:
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
<
(
I
VerboseErrorKind
)
>
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
enum
VerboseErrorKind
{
Context
(
&
'
static
str
)
Char
(
char
)
Nom
(
ErrorKind
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
I
>
ParseError
<
I
>
for
VerboseError
<
I
>
{
fn
from_error_kind
(
input
:
I
kind
:
ErrorKind
)
-
>
Self
{
VerboseError
{
errors
:
vec
!
[
(
input
VerboseErrorKind
:
:
Nom
(
kind
)
)
]
}
}
fn
append
(
input
:
I
kind
:
ErrorKind
mut
other
:
Self
)
-
>
Self
{
other
.
errors
.
push
(
(
input
VerboseErrorKind
:
:
Nom
(
kind
)
)
)
;
other
}
fn
from_char
(
input
:
I
c
:
char
)
-
>
Self
{
VerboseError
{
errors
:
vec
!
[
(
input
VerboseErrorKind
:
:
Char
(
c
)
)
]
}
}
fn
add_context
(
input
:
I
ctx
:
&
'
static
str
mut
other
:
Self
)
-
>
Self
{
other
.
errors
.
push
(
(
input
VerboseErrorKind
:
:
Context
(
ctx
)
)
)
;
other
}
}
use
crate
:
:
internal
:
:
{
Err
IResult
}
;
pub
fn
context
<
I
:
Clone
E
:
ParseError
<
I
>
F
O
>
(
context
:
&
'
static
str
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
O
E
>
where
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
{
move
|
i
:
I
|
match
f
(
i
.
clone
(
)
)
{
Ok
(
o
)
=
>
Ok
(
o
)
Err
(
Err
:
:
Incomplete
(
i
)
)
=
>
Err
(
Err
:
:
Incomplete
(
i
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
add_context
(
i
context
e
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
E
:
:
add_context
(
i
context
e
)
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
convert_error
(
input
:
&
str
e
:
VerboseError
<
&
str
>
)
-
>
crate
:
:
lib
:
:
std
:
:
string
:
:
String
{
use
crate
:
:
lib
:
:
std
:
:
fmt
:
:
Write
;
use
crate
:
:
traits
:
:
Offset
;
let
mut
result
=
crate
:
:
lib
:
:
std
:
:
string
:
:
String
:
:
new
(
)
;
for
(
i
(
substring
kind
)
)
in
e
.
errors
.
iter
(
)
.
enumerate
(
)
{
let
offset
=
input
.
offset
(
substring
)
;
if
input
.
is_empty
(
)
{
match
kind
{
VerboseErrorKind
:
:
Char
(
c
)
=
>
write
!
(
&
mut
result
"
{
}
:
expected
'
{
}
'
got
empty
input
\
n
\
n
"
i
c
)
VerboseErrorKind
:
:
Context
(
s
)
=
>
write
!
(
&
mut
result
"
{
}
:
in
{
}
got
empty
input
\
n
\
n
"
i
s
)
VerboseErrorKind
:
:
Nom
(
e
)
=
>
write
!
(
&
mut
result
"
{
}
:
in
{
:
?
}
got
empty
input
\
n
\
n
"
i
e
)
}
}
else
{
let
prefix
=
&
input
.
as_bytes
(
)
[
.
.
offset
]
;
let
line_number
=
prefix
.
iter
(
)
.
filter
(
|
&
&
b
|
b
=
=
b
'
\
n
'
)
.
count
(
)
+
1
;
let
line_begin
=
prefix
.
iter
(
)
.
rev
(
)
.
position
(
|
&
b
|
b
=
=
b
'
\
n
'
)
.
map
(
|
pos
|
offset
-
pos
)
.
unwrap_or
(
0
)
;
let
line
=
input
[
line_begin
.
.
]
.
lines
(
)
.
next
(
)
.
unwrap_or
(
&
input
[
line_begin
.
.
]
)
.
trim_end
(
)
;
let
column_number
=
line
.
offset
(
substring
)
+
1
;
match
kind
{
VerboseErrorKind
:
:
Char
(
c
)
=
>
if
let
Some
(
actual
)
=
substring
.
chars
(
)
.
next
(
)
{
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
expected
'
{
expected
}
'
found
{
actual
}
\
n
\
n
"
i
=
i
line_number
=
line_number
line
=
line
caret
=
'
^
'
column
=
column_number
expected
=
c
actual
=
actual
)
}
else
{
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
expected
'
{
expected
}
'
got
end
of
input
\
n
\
n
"
i
=
i
line_number
=
line_number
line
=
line
caret
=
'
^
'
column
=
column_number
expected
=
c
)
}
VerboseErrorKind
:
:
Context
(
s
)
=
>
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
in
{
context
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
n
"
i
=
i
line_number
=
line_number
context
=
s
line
=
line
caret
=
'
^
'
column
=
column_number
)
VerboseErrorKind
:
:
Nom
(
e
)
=
>
write
!
(
&
mut
result
"
{
i
}
:
at
line
{
line_number
}
in
{
nom_err
:
?
}
:
\
n
\
{
line
}
\
n
\
{
caret
:
>
column
}
\
n
\
n
"
i
=
i
line_number
=
line_number
nom_err
=
e
line
=
line
caret
=
'
^
'
column
=
column_number
)
}
}
.
unwrap
(
)
;
}
result
}
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
#
[
derive
(
Debug
PartialEq
Eq
Hash
Clone
Copy
)
]
#
[
allow
(
deprecated
missing_docs
)
]
pub
enum
ErrorKind
{
Tag
MapRes
MapOpt
Alt
IsNot
IsA
SeparatedList
SeparatedNonEmptyList
Many0
Many1
ManyTill
Count
TakeUntil
LengthValue
TagClosure
Alpha
Digit
HexDigit
OctDigit
AlphaNumeric
Space
MultiSpace
LengthValueFn
Eof
Switch
TagBits
OneOf
NoneOf
Char
CrLf
RegexpMatch
RegexpMatches
RegexpFind
RegexpCapture
RegexpCaptures
TakeWhile1
Complete
Fix
Escaped
EscapedTransform
NonEmpty
ManyMN
Not
Permutation
Verify
TakeTill1
TakeWhileMN
ParseTo
TooLarge
Many0Count
Many1Count
Float
}
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
#
[
allow
(
deprecated
)
]
pub
fn
error_to_u32
(
e
:
&
ErrorKind
)
-
>
u32
{
match
*
e
{
ErrorKind
:
:
Tag
=
>
1
ErrorKind
:
:
MapRes
=
>
2
ErrorKind
:
:
MapOpt
=
>
3
ErrorKind
:
:
Alt
=
>
4
ErrorKind
:
:
IsNot
=
>
5
ErrorKind
:
:
IsA
=
>
6
ErrorKind
:
:
SeparatedList
=
>
7
ErrorKind
:
:
SeparatedNonEmptyList
=
>
8
ErrorKind
:
:
Many1
=
>
9
ErrorKind
:
:
Count
=
>
10
ErrorKind
:
:
TakeUntil
=
>
12
ErrorKind
:
:
LengthValue
=
>
15
ErrorKind
:
:
TagClosure
=
>
16
ErrorKind
:
:
Alpha
=
>
17
ErrorKind
:
:
Digit
=
>
18
ErrorKind
:
:
AlphaNumeric
=
>
19
ErrorKind
:
:
Space
=
>
20
ErrorKind
:
:
MultiSpace
=
>
21
ErrorKind
:
:
LengthValueFn
=
>
22
ErrorKind
:
:
Eof
=
>
23
ErrorKind
:
:
Switch
=
>
27
ErrorKind
:
:
TagBits
=
>
28
ErrorKind
:
:
OneOf
=
>
29
ErrorKind
:
:
NoneOf
=
>
30
ErrorKind
:
:
Char
=
>
40
ErrorKind
:
:
CrLf
=
>
41
ErrorKind
:
:
RegexpMatch
=
>
42
ErrorKind
:
:
RegexpMatches
=
>
43
ErrorKind
:
:
RegexpFind
=
>
44
ErrorKind
:
:
RegexpCapture
=
>
45
ErrorKind
:
:
RegexpCaptures
=
>
46
ErrorKind
:
:
TakeWhile1
=
>
47
ErrorKind
:
:
Complete
=
>
48
ErrorKind
:
:
Fix
=
>
49
ErrorKind
:
:
Escaped
=
>
50
ErrorKind
:
:
EscapedTransform
=
>
51
ErrorKind
:
:
NonEmpty
=
>
56
ErrorKind
:
:
ManyMN
=
>
57
ErrorKind
:
:
HexDigit
=
>
59
ErrorKind
:
:
OctDigit
=
>
61
ErrorKind
:
:
Many0
=
>
62
ErrorKind
:
:
Not
=
>
63
ErrorKind
:
:
Permutation
=
>
64
ErrorKind
:
:
ManyTill
=
>
65
ErrorKind
:
:
Verify
=
>
66
ErrorKind
:
:
TakeTill1
=
>
67
ErrorKind
:
:
TakeWhileMN
=
>
69
ErrorKind
:
:
ParseTo
=
>
70
ErrorKind
:
:
TooLarge
=
>
71
ErrorKind
:
:
Many0Count
=
>
72
ErrorKind
:
:
Many1Count
=
>
73
ErrorKind
:
:
Float
=
>
74
}
}
impl
ErrorKind
{
#
[
cfg_attr
(
rustfmt
rustfmt_skip
)
]
#
[
allow
(
deprecated
)
]
pub
fn
description
(
&
self
)
-
>
&
str
{
match
*
self
{
ErrorKind
:
:
Tag
=
>
"
Tag
"
ErrorKind
:
:
MapRes
=
>
"
Map
on
Result
"
ErrorKind
:
:
MapOpt
=
>
"
Map
on
Option
"
ErrorKind
:
:
Alt
=
>
"
Alternative
"
ErrorKind
:
:
IsNot
=
>
"
IsNot
"
ErrorKind
:
:
IsA
=
>
"
IsA
"
ErrorKind
:
:
SeparatedList
=
>
"
Separated
list
"
ErrorKind
:
:
SeparatedNonEmptyList
=
>
"
Separated
non
empty
list
"
ErrorKind
:
:
Many0
=
>
"
Many0
"
ErrorKind
:
:
Many1
=
>
"
Many1
"
ErrorKind
:
:
Count
=
>
"
Count
"
ErrorKind
:
:
TakeUntil
=
>
"
Take
until
"
ErrorKind
:
:
LengthValue
=
>
"
Length
followed
by
value
"
ErrorKind
:
:
TagClosure
=
>
"
Tag
closure
"
ErrorKind
:
:
Alpha
=
>
"
Alphabetic
"
ErrorKind
:
:
Digit
=
>
"
Digit
"
ErrorKind
:
:
AlphaNumeric
=
>
"
AlphaNumeric
"
ErrorKind
:
:
Space
=
>
"
Space
"
ErrorKind
:
:
MultiSpace
=
>
"
Multiple
spaces
"
ErrorKind
:
:
LengthValueFn
=
>
"
LengthValueFn
"
ErrorKind
:
:
Eof
=
>
"
End
of
file
"
ErrorKind
:
:
Switch
=
>
"
Switch
"
ErrorKind
:
:
TagBits
=
>
"
Tag
on
bitstream
"
ErrorKind
:
:
OneOf
=
>
"
OneOf
"
ErrorKind
:
:
NoneOf
=
>
"
NoneOf
"
ErrorKind
:
:
Char
=
>
"
Char
"
ErrorKind
:
:
CrLf
=
>
"
CrLf
"
ErrorKind
:
:
RegexpMatch
=
>
"
RegexpMatch
"
ErrorKind
:
:
RegexpMatches
=
>
"
RegexpMatches
"
ErrorKind
:
:
RegexpFind
=
>
"
RegexpFind
"
ErrorKind
:
:
RegexpCapture
=
>
"
RegexpCapture
"
ErrorKind
:
:
RegexpCaptures
=
>
"
RegexpCaptures
"
ErrorKind
:
:
TakeWhile1
=
>
"
TakeWhile1
"
ErrorKind
:
:
Complete
=
>
"
Complete
"
ErrorKind
:
:
Fix
=
>
"
Fix
"
ErrorKind
:
:
Escaped
=
>
"
Escaped
"
ErrorKind
:
:
EscapedTransform
=
>
"
EscapedTransform
"
ErrorKind
:
:
NonEmpty
=
>
"
NonEmpty
"
ErrorKind
:
:
ManyMN
=
>
"
Many
(
m
n
)
"
ErrorKind
:
:
HexDigit
=
>
"
Hexadecimal
Digit
"
ErrorKind
:
:
OctDigit
=
>
"
Octal
digit
"
ErrorKind
:
:
Not
=
>
"
Negation
"
ErrorKind
:
:
Permutation
=
>
"
Permutation
"
ErrorKind
:
:
ManyTill
=
>
"
ManyTill
"
ErrorKind
:
:
Verify
=
>
"
predicate
verification
"
ErrorKind
:
:
TakeTill1
=
>
"
TakeTill1
"
ErrorKind
:
:
TakeWhileMN
=
>
"
TakeWhileMN
"
ErrorKind
:
:
ParseTo
=
>
"
Parse
string
to
the
specified
type
"
ErrorKind
:
:
TooLarge
=
>
"
Needed
data
size
is
too
large
"
ErrorKind
:
:
Many0Count
=
>
"
Count
occurrence
of
>
=
0
patterns
"
ErrorKind
:
:
Many1Count
=
>
"
Count
occurrence
of
>
=
1
patterns
"
ErrorKind
:
:
Float
=
>
"
Float
"
}
}
}
#
[
allow
(
unused_variables
)
]
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
error_position
(
(
input
:
expr
code
:
expr
)
=
>
(
{
crate
:
:
error
:
:
make_error
(
input
code
)
}
)
;
)
;
#
[
allow
(
unused_variables
)
]
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
error_node_position
(
(
input
:
expr
code
:
expr
next
:
expr
)
=
>
(
{
crate
:
:
error
:
:
append_error
(
input
code
next
)
}
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
fix_error
(
(
i
:
expr
t
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
e
)
=
>
{
let
e2
=
match
e
{
Err
:
:
Error
(
err
)
=
>
{
Err
:
:
Error
(
err
.
into
(
)
)
}
Err
:
:
Failure
(
err
)
=
>
{
Err
:
:
Failure
(
err
.
into
(
)
)
}
Err
:
:
Incomplete
(
e
)
=
>
Err
:
:
Incomplete
(
e
)
}
;
Err
(
e2
)
}
}
}
)
;
(
i
:
expr
t
:
ty
f
:
expr
)
=
>
(
fix_error
!
(
i
t
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
flat_map
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
flat_map
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
flat_map
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
flat_map
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
flat_map
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
crate
:
:
combinator
:
:
map_parserc
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
move
|
i
|
{
submac2
!
(
i
(
args2
)
*
)
}
)
)
;
)
;
#
[
cfg
(
test
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
character
:
:
complete
:
:
char
;
#
[
test
]
fn
convert_error_panic
(
)
{
let
input
=
"
"
;
let
result
:
IResult
<
_
_
VerboseError
<
&
str
>
>
=
char
(
'
x
'
)
(
input
)
;
}
}
