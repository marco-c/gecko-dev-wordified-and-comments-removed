#
[
cfg
(
feature
=
"
std
"
)
]
use
crate
:
:
internal
:
:
IResult
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
fmt
:
:
Debug
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
trait
HexDisplay
{
fn
to_hex
(
&
self
chunk_size
:
usize
)
-
>
String
;
fn
to_hex_from
(
&
self
chunk_size
:
usize
from
:
usize
)
-
>
String
;
}
#
[
cfg
(
feature
=
"
std
"
)
]
static
CHARS
:
&
'
static
[
u8
]
=
b
"
0123456789abcdef
"
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
HexDisplay
for
[
u8
]
{
#
[
allow
(
unused_variables
)
]
fn
to_hex
(
&
self
chunk_size
:
usize
)
-
>
String
{
self
.
to_hex_from
(
chunk_size
0
)
}
#
[
allow
(
unused_variables
)
]
fn
to_hex_from
(
&
self
chunk_size
:
usize
from
:
usize
)
-
>
String
{
let
mut
v
=
Vec
:
:
with_capacity
(
self
.
len
(
)
*
3
)
;
let
mut
i
=
from
;
for
chunk
in
self
.
chunks
(
chunk_size
)
{
let
s
=
format
!
(
"
{
:
08x
}
"
i
)
;
for
&
ch
in
s
.
as_bytes
(
)
.
iter
(
)
{
v
.
push
(
ch
)
;
}
v
.
push
(
b
'
\
t
'
)
;
i
+
=
chunk_size
;
for
&
byte
in
chunk
{
v
.
push
(
CHARS
[
(
byte
>
>
4
)
as
usize
]
)
;
v
.
push
(
CHARS
[
(
byte
&
0xf
)
as
usize
]
)
;
v
.
push
(
b
'
'
)
;
}
if
chunk_size
>
chunk
.
len
(
)
{
for
j
in
0
.
.
(
chunk_size
-
chunk
.
len
(
)
)
{
v
.
push
(
b
'
'
)
;
v
.
push
(
b
'
'
)
;
v
.
push
(
b
'
'
)
;
}
}
v
.
push
(
b
'
\
t
'
)
;
for
&
byte
in
chunk
{
if
(
byte
>
=
32
&
&
byte
<
=
126
)
|
|
byte
>
=
128
{
v
.
push
(
byte
)
;
}
else
{
v
.
push
(
b
'
.
'
)
;
}
}
v
.
push
(
b
'
\
n
'
)
;
}
String
:
:
from_utf8_lossy
(
&
v
[
.
.
]
)
.
into_owned
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
HexDisplay
for
str
{
#
[
allow
(
unused_variables
)
]
fn
to_hex
(
&
self
chunk_size
:
usize
)
-
>
String
{
self
.
to_hex_from
(
chunk_size
0
)
}
#
[
allow
(
unused_variables
)
]
fn
to_hex_from
(
&
self
chunk_size
:
usize
from
:
usize
)
-
>
String
{
self
.
as_bytes
(
)
.
to_hex_from
(
chunk_size
from
)
}
}
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
nom_line
(
(
)
=
>
(
line
!
(
)
)
;
)
;
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
nom_println
(
(
(
args
:
tt
)
*
)
=
>
(
println
!
(
(
args
)
*
)
)
;
)
;
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
nom_stringify
(
(
(
args
:
tt
)
*
)
=
>
(
stringify
!
(
(
args
)
*
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
dbg
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
let
l
=
nom_line
!
(
)
;
match
submac
!
(
i
(
args
)
*
)
{
Err
(
e
)
=
>
{
nom_println
!
(
"
Err
(
{
:
?
}
)
at
l
.
{
}
by
'
{
}
'
"
e
l
nom_stringify
!
(
submac
!
(
(
args
)
*
)
)
)
;
Err
(
e
)
}
a
=
>
a
}
}
)
;
(
i
:
expr
f
:
ident
)
=
>
(
dbg
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
cfg
(
feature
=
"
std
"
)
]
pub
fn
dbg_dmp
<
'
a
F
O
E
:
Debug
>
(
f
:
F
context
:
&
'
static
str
)
-
>
impl
Fn
(
&
'
a
[
u8
]
)
-
>
IResult
<
&
'
a
[
u8
]
O
E
>
where
F
:
Fn
(
&
'
a
[
u8
]
)
-
>
IResult
<
&
'
a
[
u8
]
O
E
>
{
move
|
i
:
&
'
a
[
u8
]
|
{
match
f
(
i
)
{
Err
(
e
)
=
>
{
println
!
(
"
{
}
:
Error
(
{
:
?
}
)
at
:
\
n
{
}
"
context
e
i
.
to_hex
(
8
)
)
;
Err
(
e
)
}
a
=
>
a
}
}
}
#
[
macro_export
(
local_inner_macros
)
]
#
[
cfg
(
feature
=
"
std
"
)
]
macro_rules
!
dbg_dmp
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
HexDisplay
;
let
l
=
nom_line
!
(
)
;
match
submac
!
(
i
(
args
)
*
)
{
Err
(
e
)
=
>
{
nom_println
!
(
"
Error
(
{
:
?
}
)
at
l
.
{
}
by
'
{
}
'
\
n
{
}
"
e
l
nom_stringify
!
(
submac
!
(
(
args
)
*
)
)
i
.
to_hex
(
8
)
)
;
Err
(
e
)
}
a
=
>
a
}
}
)
;
(
i
:
expr
f
:
ident
)
=
>
(
dbg_dmp
!
(
i
call
!
(
f
)
)
;
)
;
)
;
