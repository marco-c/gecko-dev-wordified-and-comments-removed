#
[
allow
(
unused_variables
)
]
#
[
macro_export
]
macro_rules
!
closure
(
(
ty
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
|
i
:
ty
|
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
named
(
(
#
(
args
:
tt
)
*
)
=
>
(
named_attr
!
(
#
(
args
)
*
)
;
)
;
(
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
pub
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
pub
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
pub
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
pub
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
pub
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
(
crate
)
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
#
[
allow
(
unused_variables
)
]
pub
(
crate
)
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
(
crate
)
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
#
[
allow
(
unused_variables
)
]
pub
(
crate
)
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
(
crate
)
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
#
[
allow
(
unused_variables
)
]
pub
(
crate
)
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
(
crate
)
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
#
[
allow
(
unused_variables
)
]
pub
(
crate
)
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
pub
(
crate
)
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
#
[
allow
(
unused_variables
)
]
pub
(
crate
)
fn
name
<
'
a
>
(
i
:
&
'
a
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
named_args
{
(
pub
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
fn
func_name
(
input
:
&
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
pub
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
fn
func_name
<
'
this_is_probably_unique_i_hope_please
'
a
>
(
input
:
&
'
this_is_probably_unique_i_hope_please
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
'
this_is_probably_unique_i_hope_please
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
pub
(
crate
)
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
(
crate
)
fn
func_name
(
input
:
&
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
pub
(
crate
)
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
(
crate
)
fn
func_name
<
'
this_is_probably_unique_i_hope_please
'
a
>
(
input
:
&
'
this_is_probably_unique_i_hope_please
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
'
this_is_probably_unique_i_hope_please
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
fn
func_name
(
input
:
&
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
fn
func_name
<
'
this_is_probably_unique_i_hope_please
'
a
>
(
input
:
&
'
this_is_probably_unique_i_hope_please
[
u8
]
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
&
'
this_is_probably_unique_i_hope_please
[
u8
]
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
pub
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
input_type
:
ty
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
fn
func_name
(
input
:
input_type
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
input_type
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
func_name
:
ident
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
input_type
:
ty
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
fn
func_name
(
input
:
input_type
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
input_type
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
pub
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
input_type
:
ty
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
pub
fn
func_name
<
'
a
>
(
input
:
input_type
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
input_type
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
(
func_name
:
ident
<
'
a
>
(
(
arg
:
ident
:
typ
:
ty
)
*
)
<
input_type
:
ty
return_type
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
{
fn
func_name
<
'
a
>
(
input
:
input_type
(
arg
:
typ
)
*
)
-
>
crate
:
:
IResult
<
input_type
return_type
>
{
submac
!
(
input
(
args
)
*
)
}
}
;
}
#
[
macro_export
]
macro_rules
!
named_attr
(
(
(
#
[
attr
:
meta
]
)
*
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
fn
name
<
'
a
>
(
i
:
&
'
a
[
u8
]
)
-
>
crate
:
:
IResult
<
&
'
a
[
u8
]
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
fn
name
<
'
a
>
(
i
:
&
'
a
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
crate
)
name
:
ident
(
i
:
ty
)
-
>
o
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
(
crate
)
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
crate
)
name
:
ident
<
i
:
ty
o
:
ty
e
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
(
crate
)
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
e
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
crate
)
name
:
ident
<
i
:
ty
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
(
crate
)
fn
name
(
i
:
i
)
-
>
crate
:
:
IResult
<
i
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
crate
)
name
:
ident
<
o
:
ty
>
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
(
crate
)
fn
name
(
i
:
&
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
o
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
(
(
#
[
attr
:
meta
]
)
*
pub
(
crate
)
name
:
ident
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
(
#
[
attr
]
)
*
pub
(
crate
)
fn
name
<
'
a
>
(
i
:
&
'
a
[
u8
]
)
-
>
crate
:
:
IResult
<
&
[
u8
]
&
[
u8
]
u32
>
{
submac
!
(
i
(
args
)
*
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
call
(
(
i
:
expr
fun
:
expr
)
=
>
(
fun
(
i
)
)
;
(
i
:
expr
fun
:
expr
(
args
:
expr
)
*
)
=
>
(
fun
(
i
(
args
)
*
)
)
;
)
;
#
[
macro_export
]
macro_rules
!
apply
(
(
i
:
expr
fun
:
expr
(
args
:
expr
)
*
)
=
>
(
fun
(
i
(
args
)
*
)
)
;
)
;
#
[
macro_export
]
macro_rules
!
return_error
(
(
i
:
expr
code
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Context
Err
}
;
let
i_
=
i
.
clone
(
)
;
let
cl
=
|
|
{
submac
!
(
i_
(
args
)
*
)
}
;
fn
unify_types
<
I
E
>
(
_
:
&
Context
<
I
E
>
_
:
&
Context
<
I
E
>
)
{
}
match
cl
(
)
{
Err
(
Err
:
:
Incomplete
(
x
)
)
=
>
Err
(
Err
:
:
Incomplete
(
x
)
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
Err
:
:
Error
(
e
)
)
|
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
unify_types
(
&
e
&
Context
:
:
Code
(
i
code
)
)
;
return
Err
(
Err
:
:
Failure
(
error_node_position
!
(
i
code
e
)
)
)
}
}
}
)
;
(
i
:
expr
code
:
expr
f
:
expr
)
=
>
(
return_error
!
(
i
code
call
!
(
f
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Context
Err
}
;
let
i_
=
i
.
clone
(
)
;
let
cl
=
|
|
{
submac
!
(
i_
(
args
)
*
)
}
;
match
cl
(
)
{
Err
(
Err
:
:
Incomplete
(
x
)
)
=
>
Err
(
Err
:
:
Incomplete
(
x
)
)
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
Err
:
:
Error
(
e
)
)
|
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
return
Err
(
Err
:
:
Failure
(
e
)
)
}
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
return_error
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
add_return_error
(
(
i
:
expr
code
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
}
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
{
Err
(
Err
:
:
Error
(
error_node_position
!
(
i
code
e
)
)
)
}
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
Err
(
Err
:
:
Failure
(
error_node_position
!
(
i
code
e
)
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
code
:
expr
f
:
expr
)
=
>
(
add_return_error
!
(
i
code
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
complete
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
}
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Err
(
Err
:
:
Incomplete
(
_
)
)
=
>
{
Err
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
Complete
:
:
<
u32
>
)
)
)
}
rest
=
>
rest
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
complete
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
try_parse
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
(
i
o
)
Err
(
e
)
=
>
return
Err
(
e
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
try_parse
!
(
i
call
!
(
f
)
)
)
;
)
;
#
[
macro_export
]
macro_rules
!
map
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
{
pub
fn
_unify
<
T
R
F
:
FnOnce
(
T
)
-
>
R
>
(
f
:
F
t
:
T
)
-
>
R
{
f
(
t
)
}
(
submac
!
(
i
(
args
)
*
)
)
.
map
(
|
(
i
o
)
|
{
(
i
_unify
(
g
o
)
)
}
)
}
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map
!
(
__impl
i
submac
!
(
(
args
)
*
)
g
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map
!
(
__impl
i
call
!
(
f
)
g
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
map_res
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
{
match
submac2
!
(
o
(
args2
)
*
)
{
Ok
(
output
)
=
>
Ok
(
(
i
output
)
)
Err
(
_
)
=
>
{
let
e
=
crate
:
:
ErrorKind
:
:
MapRes
;
Err
(
Err
:
:
Error
(
error_position
!
(
i
e
)
)
)
}
}
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map_res
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
map_res
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map_res
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
map_res
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
map_res_err
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Context
Convert
Err
}
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
{
match
submac2
!
(
o
(
args2
)
*
)
{
Ok
(
output
)
=
>
Ok
(
(
i
output
)
)
Err
(
e
)
=
>
{
let
e
=
Context
:
:
convert
(
Context
:
:
Code
(
i
crate
:
:
ErrorKind
:
:
Custom
(
e
)
)
)
;
Err
(
Err
:
:
Error
(
error_node_position
!
(
i
crate
:
:
ErrorKind
:
:
MapRes
e
)
)
)
}
}
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map_res_err
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
map_res_err
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map_res_err
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
map_res_err
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
map_opt
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
}
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
match
submac2
!
(
o
(
args2
)
*
)
{
Some
(
output
)
=
>
Ok
(
(
i
output
)
)
None
=
>
{
let
e
=
ErrorKind
:
:
MapOpt
;
Err
(
Err
:
:
Error
(
error_position
!
(
i
e
)
)
)
}
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
map_opt
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
map_opt
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
map_opt
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
map_opt
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
parse_to
(
(
i
:
expr
t
:
ty
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
Context
}
;
use
crate
:
:
ParseTo
;
use
crate
:
:
Slice
;
use
crate
:
:
InputLength
;
let
res
:
Option
<
t
>
=
(
i
)
.
parse_to
(
)
;
match
res
{
Some
(
output
)
=
>
Ok
(
(
i
.
slice
(
i
.
input_len
(
)
.
.
)
output
)
)
None
=
>
Err
(
Err
:
:
Error
(
Context
:
:
Code
(
i
ErrorKind
:
:
ParseTo
:
:
<
u32
>
)
)
)
}
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
verify
(
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
}
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
i
o
)
)
=
>
if
submac2
!
(
o
(
args2
)
*
)
{
Ok
(
(
i
o
)
)
}
else
{
Err
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
Verify
)
)
)
}
}
}
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
verify
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
verify
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
verify
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
verify
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
value
(
(
i
:
expr
res
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
_
)
)
=
>
{
Ok
(
(
i
res
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
res
:
expr
f
:
expr
)
=
>
(
value
!
(
i
res
call
!
(
f
)
)
)
;
(
i
:
expr
res
:
expr
)
=
>
(
{
let
res
:
crate
:
:
IResult
<
_
_
>
=
Ok
(
(
i
res
)
)
;
res
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
expr_res
(
(
i
:
expr
e
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
}
;
match
e
{
Ok
(
output
)
=
>
Ok
(
(
i
output
)
)
Err
(
_
)
=
>
Err
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
ExprRes
:
:
<
u32
>
)
)
)
}
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
expr_opt
(
(
i
:
expr
e
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
ErrorKind
}
;
match
e
{
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
Some
(
output
)
=
>
Ok
(
(
i
output
)
)
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
None
=
>
Err
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
ExprOpt
:
:
<
u32
>
)
)
)
}
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
opt
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
*
;
use
crate
:
:
Err
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
Some
(
o
)
)
)
Err
(
Err
:
:
Error
(
_
)
)
=
>
Ok
(
(
i
None
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
opt
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
opt_res
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
Ok
(
o
)
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Ok
(
(
i
Err
(
Err
:
:
Error
(
e
)
)
)
)
/
/
in
case
of
failure
we
return
a
real
error
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
opt_res
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
cond_with_error
(
(
i
:
expr
cond
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
if
cond
{
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
Some
(
o
)
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
else
{
let
res
:
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
<
_
_
>
=
Ok
(
(
i
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
None
)
)
;
res
}
}
)
;
(
i
:
expr
cond
:
expr
f
:
expr
)
=
>
(
cond_with_error
!
(
i
cond
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
cond
(
(
i
:
expr
cond
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
option
:
:
Option
:
:
*
;
use
crate
:
:
Err
;
if
cond
{
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
Some
(
o
)
)
)
Err
(
Err
:
:
Error
(
_
)
)
=
>
{
Ok
(
(
i
None
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
else
{
Ok
(
(
i
None
)
)
}
}
)
;
(
i
:
expr
cond
:
expr
f
:
expr
)
=
>
(
cond
!
(
i
cond
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
cond_reduce
(
(
i
:
expr
cond
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Convert
Err
ErrorKind
IResult
}
;
let
default_err
=
Err
(
Err
:
:
convert
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
CondReduce
:
:
<
u32
>
)
)
)
)
;
if
cond
{
let
sub_res
=
submac
!
(
i
(
args
)
*
)
;
fn
unify_types
<
I
O
E
>
(
_
:
&
IResult
<
I
O
E
>
_
:
&
IResult
<
I
O
E
>
)
{
}
unify_types
(
&
sub_res
&
default_err
)
;
match
sub_res
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
else
{
default_err
}
}
)
;
(
i
:
expr
cond
:
expr
f
:
expr
)
=
>
(
cond_reduce
!
(
i
cond
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
peek
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Convert
Err
}
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
_
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
e
)
=
>
Err
(
Err
:
:
convert
(
e
)
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
peek
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
not
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Context
ErrorKind
Err
IResult
}
;
let
i_
=
i
.
clone
(
)
;
/
/
we
need
this
to
avoid
type
inference
errors
fn
unify_types
<
I
O
P
E
>
(
_
:
&
IResult
<
I
O
E
>
_
:
&
IResult
<
I
P
E
>
)
{
}
match
submac
!
(
i_
(
args
)
*
)
{
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
)
)
Err
(
Err
:
:
Incomplete
(
i
)
)
=
>
Err
(
Err
:
:
Incomplete
(
i
)
)
Err
(
_
)
=
>
Ok
(
(
i
(
)
)
)
Ok
(
_
)
=
>
{
let
c
=
Context
:
:
Code
(
i
ErrorKind
:
:
Not
)
;
let
err
=
Err
(
Err
:
:
Error
(
c
)
)
;
let
default
=
Ok
(
(
i
(
)
)
)
;
unify_types
(
&
err
&
default
)
;
err
}
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
not
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
tap
(
(
i
:
expr
name
:
ident
:
submac
:
ident
!
(
(
args
:
tt
)
*
)
=
>
e
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Convert
Err
Needed
IResult
}
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
{
let
name
=
o
;
e
;
Ok
(
(
i
name
)
)
}
Err
(
e
)
=
>
Err
(
Err
:
:
convert
(
e
)
)
}
}
)
;
(
i
:
expr
name
:
ident
:
f
:
expr
=
>
e
:
expr
)
=
>
(
tap
!
(
i
name
:
call
!
(
f
)
=
>
e
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
eof
(
(
i
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
AtEof
Err
ErrorKind
}
;
use
crate
:
:
InputLength
;
if
(
i
)
.
at_eof
(
)
&
&
(
i
)
.
input_len
(
)
=
=
0
{
Ok
(
(
i
i
)
)
}
else
{
/
/
FIXME
what
do
we
do
with
need_more
?
Err
(
Err
:
:
Error
(
error_position
!
(
i
ErrorKind
:
:
Eof
:
:
<
u32
>
)
)
)
}
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
exact
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
terminated
!
(
i
submac
!
(
(
args
)
*
)
eof
!
(
)
)
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
exact
!
(
i
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
recognize
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Offset
;
use
crate
:
:
Slice
;
let
i_
=
i
.
clone
(
)
;
match
submac
!
(
i_
(
args
)
*
)
{
Ok
(
(
i
_
)
)
=
>
{
let
index
=
(
&
i
)
.
offset
(
&
i
)
;
Ok
(
(
i
(
i
)
.
slice
(
.
.
index
)
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
recognize
!
(
i
call
!
(
f
)
)
)
;
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
internal
:
:
{
Err
IResult
Needed
}
;
use
util
:
:
ErrorKind
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
lib
:
:
std
:
:
boxed
:
:
Box
;
macro_rules
!
tag
(
(
i
:
expr
tag
:
expr
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Err
Needed
IResult
ErrorKind
}
;
use
crate
:
:
{
Compare
CompareResult
InputLength
Slice
need_more
}
;
let
res
:
IResult
<
_
_
>
=
match
(
i
)
.
compare
(
tag
)
{
CompareResult
:
:
Ok
=
>
{
let
blen
=
tag
.
input_len
(
)
;
Ok
(
(
i
.
slice
(
blen
.
.
)
i
.
slice
(
.
.
blen
)
)
)
}
CompareResult
:
:
Incomplete
=
>
{
need_more
(
i
Needed
:
:
Size
(
tag
.
input_len
(
)
)
)
}
CompareResult
:
:
Error
=
>
{
let
e
:
ErrorKind
<
u32
>
=
ErrorKind
:
:
Tag
;
Err
(
Err
:
:
Error
(
crate
:
:
Context
:
:
Code
(
i
e
)
)
)
}
}
;
res
}
)
;
)
;
macro_rules
!
take
(
(
i
:
expr
count
:
expr
)
=
>
(
{
let
cnt
=
count
as
usize
;
let
res
:
IResult
<
&
[
u8
]
&
[
u8
]
>
=
if
i
.
len
(
)
<
cnt
{
crate
:
:
need_more
(
i
crate
:
:
Needed
:
:
Size
(
cnt
)
)
}
else
{
Ok
(
(
&
i
[
cnt
.
.
]
&
i
[
0
.
.
cnt
]
)
)
}
;
res
}
)
;
)
;
mod
pub_named_mod
{
named
!
(
pub
tst
tag
!
(
"
abcd
"
)
)
;
}
#
[
test
]
fn
pub_named_test
(
)
{
let
a
=
&
b
"
abcd
"
[
.
.
]
;
let
res
=
pub_named_mod
:
:
tst
(
a
)
;
assert_eq
!
(
res
Ok
(
(
&
b
"
"
[
.
.
]
a
)
)
)
;
}
mod
pub_crate_named_mod
{
named
!
(
pub
(
crate
)
tst
tag
!
(
"
abcd
"
)
)
;
}
#
[
test
]
fn
pub_crate_named_test
(
)
{
let
a
=
&
b
"
abcd
"
[
.
.
]
;
let
res
=
pub_crate_named_mod
:
:
tst
(
a
)
;
assert_eq
!
(
res
Ok
(
(
&
b
"
"
[
.
.
]
a
)
)
)
;
}
#
[
test
]
fn
apply_test
(
)
{
fn
sum2
(
a
:
u8
b
:
u8
)
-
>
u8
{
a
+
b
}
fn
sum3
(
a
:
u8
b
:
u8
c
:
u8
)
-
>
u8
{
a
+
b
+
c
}
let
a
=
apply
!
(
1
sum2
2
)
;
let
b
=
apply
!
(
1
sum3
2
3
)
;
assert_eq
!
(
a
3
)
;
assert_eq
!
(
b
6
)
;
}
#
[
test
]
fn
opt
(
)
{
named
!
(
opt_abcd
<
&
[
u8
]
Option
<
&
[
u8
]
>
>
opt
!
(
tag
!
(
"
abcd
"
)
)
)
;
let
a
=
&
b
"
abcdef
"
[
.
.
]
;
let
b
=
&
b
"
bcdefg
"
[
.
.
]
;
let
c
=
&
b
"
ab
"
[
.
.
]
;
assert_eq
!
(
opt_abcd
(
a
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Some
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
opt_abcd
(
b
)
Ok
(
(
&
b
"
bcdefg
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
opt_abcd
(
c
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
4
)
)
)
)
;
}
#
[
cfg
(
feature
=
"
verbose
-
errors
"
)
]
#
[
test
]
fn
opt_res
(
)
{
named
!
(
opt_res_abcd
<
&
[
u8
]
Result
<
&
[
u8
]
Err
<
&
[
u8
]
>
>
>
opt_res
!
(
tag
!
(
"
abcd
"
)
)
)
;
let
a
=
&
b
"
abcdef
"
[
.
.
]
;
let
b
=
&
b
"
bcdefg
"
[
.
.
]
;
let
c
=
&
b
"
ab
"
[
.
.
]
;
assert_eq
!
(
opt_res_abcd
(
a
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Ok
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
opt_res_abcd
(
b
)
Ok
(
(
&
b
"
bcdefg
"
[
.
.
]
Err
(
Err
:
:
Error
(
error_position
!
(
b
ErrorKind
:
:
Tag
)
)
)
)
)
)
;
assert_eq
!
(
opt_res_abcd
(
c
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
4
)
)
)
)
;
}
#
[
cfg
(
not
(
feature
=
"
verbose
-
errors
"
)
)
]
#
[
test
]
fn
opt_res
(
)
{
named
!
(
opt_res_abcd
<
&
[
u8
]
Result
<
&
[
u8
]
Err
<
&
[
u8
]
u32
>
>
>
opt_res
!
(
tag
!
(
"
abcd
"
)
)
)
;
let
a
=
&
b
"
abcdef
"
[
.
.
]
;
let
b
=
&
b
"
bcdefg
"
[
.
.
]
;
let
c
=
&
b
"
ab
"
[
.
.
]
;
assert_eq
!
(
opt_res_abcd
(
a
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Ok
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
opt_res_abcd
(
b
)
Ok
(
(
&
b
"
bcdefg
"
[
.
.
]
Err
(
Err
:
:
Error
(
error_position
!
(
b
ErrorKind
:
:
Tag
)
)
)
)
)
)
;
assert_eq
!
(
opt_res_abcd
(
c
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
4
)
)
)
)
;
}
use
lib
:
:
std
:
:
convert
:
:
From
;
#
[
derive
(
Debug
PartialEq
)
]
pub
struct
CustomError
(
&
'
static
str
)
;
impl
From
<
u32
>
for
CustomError
{
fn
from
(
_
:
u32
)
-
>
Self
{
CustomError
(
"
test
"
)
}
}
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
cond
(
)
{
let
f_true
:
Box
<
Fn
(
&
'
static
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
>
=
Box
:
:
new
(
closure
!
(
&
'
static
[
u8
]
fix_error
!
(
CustomError
cond
!
(
true
tag
!
(
"
abcd
"
)
)
)
)
)
;
let
f_false
:
Box
<
Fn
(
&
'
static
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
>
=
Box
:
:
new
(
closure
!
(
&
'
static
[
u8
]
fix_error
!
(
CustomError
cond
!
(
false
tag
!
(
"
abcd
"
)
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Some
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
ab
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
4
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
xxx
"
[
.
.
]
)
Ok
(
(
&
b
"
xxx
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
abcdef
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
ab
"
[
.
.
]
)
Ok
(
(
&
b
"
ab
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
xxx
"
[
.
.
]
)
Ok
(
(
&
b
"
xxx
"
[
.
.
]
None
)
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
cond_wrapping
(
)
{
named
!
(
tag_abcd
tag
!
(
"
abcd
"
)
)
;
let
f_true
:
Box
<
Fn
(
&
'
static
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
>
=
Box
:
:
new
(
closure
!
(
&
'
static
[
u8
]
fix_error
!
(
CustomError
cond
!
(
true
tag_abcd
)
)
)
)
;
let
f_false
:
Box
<
Fn
(
&
'
static
[
u8
]
)
-
>
IResult
<
&
[
u8
]
Option
<
&
[
u8
]
>
CustomError
>
>
=
Box
:
:
new
(
closure
!
(
&
'
static
[
u8
]
fix_error
!
(
CustomError
cond
!
(
false
tag_abcd
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
ef
"
[
.
.
]
Some
(
&
b
"
abcd
"
[
.
.
]
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
ab
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
4
)
)
)
)
;
assert_eq
!
(
f_true
(
&
b
"
xxx
"
[
.
.
]
)
Ok
(
(
&
b
"
xxx
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
abcdef
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
ab
"
[
.
.
]
)
Ok
(
(
&
b
"
ab
"
[
.
.
]
None
)
)
)
;
assert_eq
!
(
f_false
(
&
b
"
xxx
"
[
.
.
]
)
Ok
(
(
&
b
"
xxx
"
[
.
.
]
None
)
)
)
;
}
#
[
test
]
fn
peek
(
)
{
named
!
(
peek_tag
<
&
[
u8
]
&
[
u8
]
>
peek
!
(
tag
!
(
"
abcd
"
)
)
)
;
assert_eq
!
(
peek_tag
(
&
b
"
abcdef
"
[
.
.
]
)
Ok
(
(
&
b
"
abcdef
"
[
.
.
]
&
b
"
abcd
"
[
.
.
]
)
)
)
;
assert_eq
!
(
peek_tag
(
&
b
"
ab
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
4
)
)
)
)
;
assert_eq
!
(
peek_tag
(
&
b
"
xxx
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
xxx
"
[
.
.
]
ErrorKind
:
:
Tag
)
)
)
)
;
}
#
[
test
]
fn
not
(
)
{
use
types
:
:
CompleteStr
;
named
!
(
not_aaa
<
(
)
>
not
!
(
tag
!
(
"
aaa
"
)
)
)
;
assert_eq
!
(
not_aaa
(
&
b
"
aaa
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
aaa
"
[
.
.
]
ErrorKind
:
:
Not
)
)
)
)
;
assert_eq
!
(
not_aaa
(
&
b
"
aa
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
3
)
)
)
)
;
assert_eq
!
(
not_aaa
(
&
b
"
abcd
"
[
.
.
]
)
Ok
(
(
&
b
"
abcd
"
[
.
.
]
(
)
)
)
)
;
named
!
(
not_aaa_complete
<
CompleteStr
(
)
>
not
!
(
tag
!
(
"
aaa
"
)
)
)
;
assert_eq
!
(
not_aaa_complete
(
CompleteStr
(
"
aaa
"
)
)
Err
(
Err
:
:
Error
(
error_position
!
(
CompleteStr
(
"
aaa
"
)
ErrorKind
:
:
Not
)
)
)
)
;
assert_eq
!
(
not_aaa_complete
(
CompleteStr
(
"
aa
"
)
)
Ok
(
(
CompleteStr
(
"
aa
"
)
(
)
)
)
)
;
assert_eq
!
(
not_aaa_complete
(
CompleteStr
(
"
abcd
"
)
)
Ok
(
(
CompleteStr
(
"
abcd
"
)
(
)
)
)
)
;
}
#
[
test
]
fn
verify
(
)
{
named
!
(
test
verify
!
(
take
!
(
5
)
|
slice
:
&
[
u8
]
|
slice
[
0
]
=
=
b
'
a
'
)
)
;
assert_eq
!
(
test
(
&
b
"
bcd
"
[
.
.
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
5
)
)
)
)
;
assert_eq
!
(
test
(
&
b
"
bcdefg
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
b
"
bcdefg
"
[
.
.
]
ErrorKind
:
:
Verify
)
)
)
)
;
assert_eq
!
(
test
(
&
b
"
abcdefg
"
[
.
.
]
)
Ok
(
(
&
b
"
fg
"
[
.
.
]
&
b
"
abcde
"
[
.
.
]
)
)
)
;
}
#
[
test
]
fn
parse_to
(
)
{
use
util
:
:
Convert
;
assert_eq
!
(
parse_to
!
(
"
ab
"
usize
)
Err
(
Err
:
:
Error
(
error_position
!
(
"
ab
"
ErrorKind
:
:
ParseTo
)
)
)
)
;
assert_eq
!
(
parse_to
!
(
"
42
"
usize
)
Ok
(
(
"
"
42
)
)
)
;
assert_eq
!
(
ErrorKind
:
:
<
u64
>
:
:
convert
(
ErrorKind
:
:
ParseTo
:
:
<
u32
>
)
ErrorKind
:
:
ParseTo
:
:
<
u64
>
)
;
}
#
[
test
]
fn
map_res_err
(
)
{
use
Context
;
use
be_u8
;
#
[
derive
(
Debug
Eq
PartialEq
)
]
enum
ParseError
{
InvalidValue
(
u8
)
}
impl
From
<
u32
>
for
ParseError
{
fn
from
(
_
:
u32
)
-
>
Self
{
unreachable
!
(
)
}
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
enum
ValidValue
{
One
Two
}
fn
validate
(
value
:
u8
)
-
>
Result
<
ValidValue
ParseError
>
{
match
value
{
b
'
1
'
=
>
Ok
(
ValidValue
:
:
One
)
b
'
2
'
=
>
Ok
(
ValidValue
:
:
Two
)
_
=
>
Err
(
ParseError
:
:
InvalidValue
(
value
)
)
}
}
named
!
(
test
<
&
[
u8
]
ValidValue
ParseError
>
map_res_err
!
(
fix_error
!
(
ParseError
be_u8
)
validate
)
)
;
assert_eq
!
(
test
(
&
b
"
1
"
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
ValidValue
:
:
One
)
)
)
;
assert_eq
!
(
test
(
&
b
"
2
"
[
.
.
]
)
Ok
(
(
&
b
"
"
[
.
.
]
ValidValue
:
:
Two
)
)
)
;
#
[
cfg
(
feature
=
"
verbose
-
errors
"
)
]
{
assert_eq
!
(
test
(
&
b
"
3
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
Context
:
:
List
(
vec
!
[
(
&
b
"
3
"
[
.
.
]
ErrorKind
:
:
Custom
(
ParseError
:
:
InvalidValue
(
b
'
3
'
)
)
)
(
&
b
"
3
"
[
.
.
]
ErrorKind
:
:
MapRes
)
]
)
)
)
)
;
}
#
[
cfg
(
not
(
feature
=
"
verbose
-
errors
"
)
)
]
{
assert_eq
!
(
test
(
&
b
"
3
"
[
.
.
]
)
Err
(
Err
:
:
Error
(
Context
:
:
Code
(
&
b
"
3
"
[
.
.
]
ErrorKind
:
:
MapRes
)
)
)
)
;
}
}
}
