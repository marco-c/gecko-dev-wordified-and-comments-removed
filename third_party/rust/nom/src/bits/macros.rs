#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
bits
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
crate
:
:
bits
:
:
bitsc
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
)
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
bits
!
(
i
call
!
(
f
)
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
bytes
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
crate
:
:
bits
:
:
bytesc
(
i
move
|
i
|
{
submac
!
(
i
(
args
)
*
)
}
)
}
)
;
(
i
:
expr
f
:
expr
)
=
>
(
bytes
!
(
i
call
!
(
f
)
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
take_bits
(
(
i
:
expr
count
:
expr
)
=
>
(
{
let
res
:
crate
:
:
IResult
<
_
_
>
=
crate
:
:
bits
:
:
streaming
:
:
take
(
count
)
(
i
)
;
res
}
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
tag_bits
(
(
i
:
expr
count
:
expr
p
:
expr
)
=
>
(
{
let
res
:
crate
:
:
IResult
<
_
_
>
=
crate
:
:
bits
:
:
streaming
:
:
tag
(
p
count
)
(
i
)
;
res
}
)
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
{
AddAssign
Shl
Shr
}
;
use
crate
:
:
internal
:
:
{
Err
Needed
IResult
}
;
use
crate
:
:
error
:
:
ErrorKind
;
#
[
test
]
fn
take_bits
(
)
{
let
input
=
[
0b10_10_10_10
0b11_11_00_00
0b00_11_00_11
]
;
let
sl
=
&
input
[
.
.
]
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
0u8
)
Ok
(
(
(
sl
0
)
0
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
8u8
)
Ok
(
(
(
&
sl
[
1
.
.
]
0
)
170
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
3u8
)
Ok
(
(
(
&
sl
[
0
.
.
]
3
)
5
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
6u8
)
Ok
(
(
(
&
sl
[
0
.
.
]
6
)
42
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
1
)
1u8
)
Ok
(
(
(
&
sl
[
0
.
.
]
2
)
0
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
1
)
2u8
)
Ok
(
(
(
&
sl
[
0
.
.
]
3
)
1
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
1
)
3u8
)
Ok
(
(
(
&
sl
[
0
.
.
]
4
)
2
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
6
)
3u8
)
Ok
(
(
(
&
sl
[
1
.
.
]
1
)
5
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
10u8
)
Ok
(
(
(
&
sl
[
1
.
.
]
2
)
683
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
8u8
)
Ok
(
(
(
&
sl
[
1
.
.
]
0
)
170
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
6
)
10u8
)
Ok
(
(
(
&
sl
[
2
.
.
]
0
)
752
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
6
)
11u8
)
Ok
(
(
(
&
sl
[
2
.
.
]
1
)
1504
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
20u8
)
Ok
(
(
(
&
sl
[
2
.
.
]
4
)
700_163
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
4
)
20u8
)
Ok
(
(
(
&
sl
[
3
.
.
]
0
)
716_851
)
)
)
;
let
r
:
IResult
<
_
u32
>
=
take_bits
!
(
(
sl
4
)
22u8
)
;
assert_eq
!
(
r
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
22
)
)
)
)
;
}
#
[
test
]
fn
tag_bits
(
)
{
let
input
=
[
0b10_10_10_10
0b11_11_00_00
0b00_11_00_11
]
;
let
sl
=
&
input
[
.
.
]
;
assert_eq
!
(
tag_bits
!
(
(
sl
0
)
3u8
0b101
)
Ok
(
(
(
&
sl
[
0
.
.
]
3
)
5
)
)
)
;
assert_eq
!
(
tag_bits
!
(
(
sl
0
)
4u8
0b1010
)
Ok
(
(
(
&
sl
[
0
.
.
]
4
)
10
)
)
)
;
}
named
!
(
ch
<
(
&
[
u8
]
usize
)
(
u8
u8
)
>
do_parse
!
(
tag_bits
!
(
3u8
0b101
)
>
>
x
:
take_bits
!
(
4u8
)
>
>
y
:
take_bits
!
(
5u8
)
>
>
(
x
y
)
)
)
;
#
[
test
]
fn
chain_bits
(
)
{
let
input
=
[
0b10_10_10_10
0b11_11_00_00
0b00_11_00_11
]
;
let
sl
=
&
input
[
.
.
]
;
assert_eq
!
(
ch
(
(
&
input
[
.
.
]
0
)
)
Ok
(
(
(
&
sl
[
1
.
.
]
4
)
(
5
15
)
)
)
)
;
assert_eq
!
(
ch
(
(
&
input
[
.
.
]
4
)
)
Ok
(
(
(
&
sl
[
2
.
.
]
0
)
(
7
16
)
)
)
)
;
assert_eq
!
(
ch
(
(
&
input
[
.
.
1
]
0
)
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
5
)
)
)
)
;
}
named
!
(
ch_bytes
<
(
u8
u8
)
>
bits
!
(
ch
)
)
;
#
[
test
]
fn
bits_to_bytes
(
)
{
let
input
=
[
0b10_10_10_10
0b11_11_00_00
0b00_11_00_11
]
;
assert_eq
!
(
ch_bytes
(
&
input
[
.
.
]
)
Ok
(
(
&
input
[
2
.
.
]
(
5
15
)
)
)
)
;
assert_eq
!
(
ch_bytes
(
&
input
[
.
.
1
]
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
1
)
)
)
)
;
assert_eq
!
(
ch_bytes
(
&
input
[
1
.
.
]
)
Err
(
Err
:
:
Error
(
error_position
!
(
&
input
[
1
.
.
]
ErrorKind
:
:
TagBits
)
)
)
)
;
}
named
!
(
bits_bytes_bs
bits
!
(
bytes
!
(
crate
:
:
combinator
:
:
rest
:
:
<
_
(
&
[
u8
]
ErrorKind
)
>
)
)
)
;
#
[
test
]
fn
bits_bytes
(
)
{
let
input
=
[
0b10_10_10_10
]
;
assert_eq
!
(
bits_bytes_bs
(
&
input
[
.
.
]
)
Ok
(
(
&
[
]
[
.
.
]
&
[
0b10_10_10_10
]
[
.
.
]
)
)
)
;
}
#
[
derive
(
PartialEq
Debug
)
]
struct
FakeUint
(
u32
)
;
impl
AddAssign
for
FakeUint
{
fn
add_assign
(
&
mut
self
other
:
FakeUint
)
{
*
self
=
FakeUint
(
self
.
0
+
other
.
0
)
;
}
}
impl
Shr
<
usize
>
for
FakeUint
{
type
Output
=
FakeUint
;
fn
shr
(
self
shift
:
usize
)
-
>
FakeUint
{
FakeUint
(
self
.
0
>
>
shift
)
}
}
impl
Shl
<
usize
>
for
FakeUint
{
type
Output
=
FakeUint
;
fn
shl
(
self
shift
:
usize
)
-
>
FakeUint
{
FakeUint
(
self
.
0
<
<
shift
)
}
}
impl
From
<
u8
>
for
FakeUint
{
fn
from
(
i
:
u8
)
-
>
FakeUint
{
FakeUint
(
u32
:
:
from
(
i
)
)
}
}
#
[
test
]
fn
non_privitive_type
(
)
{
let
input
=
[
0b10_10_10_10
0b11_11_00_00
0b00_11_00_11
]
;
let
sl
=
&
input
[
.
.
]
;
assert_eq
!
(
take_bits
!
(
(
sl
0
)
20u8
)
Ok
(
(
(
&
sl
[
2
.
.
]
4
)
FakeUint
(
700_163
)
)
)
)
;
assert_eq
!
(
take_bits
!
(
(
sl
4
)
20u8
)
Ok
(
(
(
&
sl
[
3
.
.
]
0
)
FakeUint
(
716_851
)
)
)
)
;
let
r3
:
IResult
<
_
FakeUint
>
=
take_bits
!
(
(
sl
4
)
22u8
)
;
assert_eq
!
(
r3
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
22
)
)
)
)
;
}
}
