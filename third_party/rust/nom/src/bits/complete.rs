use
crate
:
:
error
:
:
{
ErrorKind
ParseError
}
;
use
crate
:
:
internal
:
:
{
Err
IResult
}
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
{
AddAssign
Div
RangeFrom
Shl
Shr
}
;
use
crate
:
:
traits
:
:
{
InputIter
InputLength
Slice
ToUsize
}
;
pub
fn
take
<
I
O
C
E
:
ParseError
<
(
I
usize
)
>
>
(
count
:
C
)
-
>
impl
Fn
(
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
O
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
C
:
ToUsize
O
:
From
<
u8
>
+
AddAssign
+
Shl
<
usize
Output
=
O
>
+
Shr
<
usize
Output
=
O
>
{
let
count
=
count
.
to_usize
(
)
;
move
|
(
input
bit_offset
)
:
(
I
usize
)
|
{
if
count
=
=
0
{
Ok
(
(
(
input
bit_offset
)
0u8
.
into
(
)
)
)
}
else
{
let
cnt
=
(
count
+
bit_offset
)
.
div
(
8
)
;
if
input
.
input_len
(
)
*
8
<
count
+
bit_offset
{
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
(
input
bit_offset
)
ErrorKind
:
:
Eof
)
)
)
}
else
{
let
mut
acc
:
O
=
0_u8
.
into
(
)
;
let
mut
offset
:
usize
=
bit_offset
;
let
mut
remaining
:
usize
=
count
;
let
mut
end_offset
:
usize
=
0
;
for
byte
in
input
.
iter_elements
(
)
.
take
(
cnt
+
1
)
{
if
remaining
=
=
0
{
break
;
}
let
val
:
O
=
if
offset
=
=
0
{
byte
.
into
(
)
}
else
{
(
(
byte
<
<
offset
)
as
u8
>
>
offset
)
.
into
(
)
}
;
if
remaining
<
8
-
offset
{
acc
+
=
val
>
>
(
8
-
offset
-
remaining
)
;
end_offset
=
remaining
+
offset
;
break
;
}
else
{
acc
+
=
val
<
<
(
remaining
-
(
8
-
offset
)
)
;
remaining
-
=
8
-
offset
;
offset
=
0
;
}
}
Ok
(
(
(
input
.
slice
(
cnt
.
.
)
end_offset
)
acc
)
)
}
}
}
}
pub
fn
tag
<
I
O
C
E
:
ParseError
<
(
I
usize
)
>
>
(
pattern
:
O
count
:
C
)
-
>
impl
Fn
(
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
O
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
+
Clone
C
:
ToUsize
O
:
From
<
u8
>
+
AddAssign
+
Shl
<
usize
Output
=
O
>
+
Shr
<
usize
Output
=
O
>
+
PartialEq
{
let
count
=
count
.
to_usize
(
)
;
move
|
input
:
(
I
usize
)
|
{
let
inp
=
input
.
clone
(
)
;
take
(
count
)
(
input
)
.
and_then
(
|
(
i
o
)
|
{
if
pattern
=
=
o
{
Ok
(
(
i
o
)
)
}
else
{
Err
(
Err
:
:
Error
(
error_position
!
(
inp
ErrorKind
:
:
TagBits
)
)
)
}
}
)
}
}
pub
fn
bool
<
I
E
:
ParseError
<
(
I
usize
)
>
>
(
input
:
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
bool
E
>
where
I
:
Slice
<
RangeFrom
<
usize
>
>
+
InputIter
<
Item
=
u8
>
+
InputLength
{
let
(
res
bit
)
:
(
_
u32
)
=
take
(
1usize
)
(
input
)
?
;
Ok
(
(
res
bit
!
=
0
)
)
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_take_0
(
)
{
let
input
=
[
0b00010010
]
.
as_ref
(
)
;
let
count
=
0usize
;
assert_eq
!
(
count
0usize
)
;
let
offset
=
0usize
;
let
result
:
crate
:
:
IResult
<
(
&
[
u8
]
usize
)
usize
>
=
take
(
count
)
(
(
input
offset
)
)
;
assert_eq
!
(
result
Ok
(
(
(
input
offset
)
0
)
)
)
;
}
#
[
test
]
fn
test_take_eof
(
)
{
let
input
=
[
0b00010010
]
.
as_ref
(
)
;
let
result
:
crate
:
:
IResult
<
(
&
[
u8
]
usize
)
usize
>
=
take
(
1usize
)
(
(
input
8
)
)
;
assert_eq
!
(
result
Err
(
crate
:
:
Err
:
:
Error
(
crate
:
:
error
:
:
Error
{
input
:
(
input
8
)
code
:
ErrorKind
:
:
Eof
}
)
)
)
}
#
[
test
]
fn
test_take_span_over_multiple_bytes
(
)
{
let
input
=
[
0b00010010
0b00110100
0b11111111
0b11111111
]
.
as_ref
(
)
;
let
result
:
crate
:
:
IResult
<
(
&
[
u8
]
usize
)
usize
>
=
take
(
24usize
)
(
(
input
4
)
)
;
assert_eq
!
(
result
Ok
(
(
(
[
0b11111111
]
.
as_ref
(
)
4
)
0b1000110100111111111111
)
)
)
;
}
#
[
test
]
fn
test_bool_0
(
)
{
let
input
=
[
0b10000000
]
.
as_ref
(
)
;
let
result
:
crate
:
:
IResult
<
(
&
[
u8
]
usize
)
bool
>
=
bool
(
(
input
0
)
)
;
assert_eq
!
(
result
Ok
(
(
(
input
1
)
true
)
)
)
;
}
#
[
test
]
fn
test_bool_eof
(
)
{
let
input
=
[
0b10000000
]
.
as_ref
(
)
;
let
result
:
crate
:
:
IResult
<
(
&
[
u8
]
usize
)
bool
>
=
bool
(
(
input
8
)
)
;
assert_eq
!
(
result
Err
(
crate
:
:
Err
:
:
Error
(
crate
:
:
error
:
:
Error
{
input
:
(
input
8
)
code
:
ErrorKind
:
:
Eof
}
)
)
)
;
}
}
