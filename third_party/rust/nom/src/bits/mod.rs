pub
mod
complete
;
pub
mod
streaming
;
use
crate
:
:
error
:
:
{
ErrorKind
ParseError
}
;
use
crate
:
:
internal
:
:
{
Err
IResult
Needed
Parser
}
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
RangeFrom
;
use
crate
:
:
traits
:
:
{
ErrorConvert
Slice
}
;
pub
fn
bits
<
I
O
E1
E2
P
>
(
mut
parser
:
P
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E2
>
where
E1
:
ParseError
<
(
I
usize
)
>
+
ErrorConvert
<
E2
>
E2
:
ParseError
<
I
>
I
:
Slice
<
RangeFrom
<
usize
>
>
P
:
Parser
<
(
I
usize
)
O
E1
>
{
move
|
input
:
I
|
match
parser
.
parse
(
(
input
0
)
)
{
Ok
(
(
(
rest
offset
)
result
)
)
=
>
{
let
remaining_bytes_index
=
offset
/
8
+
if
offset
%
8
=
=
0
{
0
}
else
{
1
}
;
Ok
(
(
rest
.
slice
(
remaining_bytes_index
.
.
)
result
)
)
}
Err
(
Err
:
:
Incomplete
(
n
)
)
=
>
Err
(
Err
:
:
Incomplete
(
n
.
map
(
|
u
|
u
.
get
(
)
/
8
+
1
)
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
e
.
convert
(
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
.
convert
(
)
)
)
}
}
pub
fn
bytes
<
I
O
E1
E2
P
>
(
mut
parser
:
P
)
-
>
impl
FnMut
(
(
I
usize
)
)
-
>
IResult
<
(
I
usize
)
O
E2
>
where
E1
:
ParseError
<
I
>
+
ErrorConvert
<
E2
>
E2
:
ParseError
<
(
I
usize
)
>
I
:
Slice
<
RangeFrom
<
usize
>
>
+
Clone
P
:
Parser
<
I
O
E1
>
{
move
|
(
input
offset
)
:
(
I
usize
)
|
{
let
inner
=
if
offset
%
8
!
=
0
{
input
.
slice
(
(
1
+
offset
/
8
)
.
.
)
}
else
{
input
.
slice
(
(
offset
/
8
)
.
.
)
}
;
let
i
=
(
input
offset
)
;
match
parser
.
parse
(
inner
)
{
Ok
(
(
rest
res
)
)
=
>
Ok
(
(
(
rest
0
)
res
)
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Unknown
)
)
=
>
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Unknown
)
)
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
sz
)
)
)
=
>
Err
(
match
sz
.
get
(
)
.
checked_mul
(
8
)
{
Some
(
v
)
=
>
Err
:
:
Incomplete
(
Needed
:
:
new
(
v
)
)
None
=
>
Err
:
:
Failure
(
E2
:
:
from_error_kind
(
i
ErrorKind
:
:
TooLarge
)
)
}
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
e
.
convert
(
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
.
convert
(
)
)
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
use
crate
:
:
bits
:
:
streaming
:
:
take
;
use
crate
:
:
error
:
:
Error
;
use
crate
:
:
sequence
:
:
tuple
;
#
[
test
]
fn
test_complete_byte_consumption_bits
(
)
{
let
input
=
&
[
0x12
0x34
0x56
0x78
]
;
let
result
:
IResult
<
&
[
u8
]
(
u8
u8
u8
)
>
=
bits
:
:
<
_
_
Error
<
(
&
[
u8
]
usize
)
>
_
_
>
(
tuple
(
(
take
(
4usize
)
take
(
8usize
)
take
(
4usize
)
)
)
)
(
input
)
;
let
output
=
result
.
expect
(
"
We
take
2
bytes
and
the
input
is
longer
than
2
bytes
"
)
;
let
remaining
=
output
.
0
;
assert_eq
!
(
remaining
[
0x56
0x78
]
)
;
let
parsed
=
output
.
1
;
assert_eq
!
(
parsed
.
0
0x01
)
;
assert_eq
!
(
parsed
.
1
0x23
)
;
assert_eq
!
(
parsed
.
2
0x04
)
;
}
#
[
test
]
fn
test_partial_byte_consumption_bits
(
)
{
let
input
=
&
[
0x12
0x34
0x56
0x78
]
;
let
result
:
IResult
<
&
[
u8
]
(
u8
u8
)
>
=
bits
:
:
<
_
_
Error
<
(
&
[
u8
]
usize
)
>
_
_
>
(
tuple
(
(
take
(
4usize
)
take
(
8usize
)
)
)
)
(
input
)
;
let
output
=
result
.
expect
(
"
We
take
1
.
5
bytes
and
the
input
is
longer
than
2
bytes
"
)
;
let
remaining
=
output
.
0
;
assert_eq
!
(
remaining
[
0x56
0x78
]
)
;
let
parsed
=
output
.
1
;
assert_eq
!
(
parsed
.
0
0x01
)
;
assert_eq
!
(
parsed
.
1
0x23
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
test_incomplete_bits
(
)
{
let
input
=
&
[
0x12
]
;
let
result
:
IResult
<
&
[
u8
]
(
u8
u8
)
>
=
bits
:
:
<
_
_
Error
<
(
&
[
u8
]
usize
)
>
_
_
>
(
tuple
(
(
take
(
4usize
)
take
(
8usize
)
)
)
)
(
input
)
;
assert
!
(
result
.
is_err
(
)
)
;
let
error
=
result
.
err
(
)
.
unwrap
(
)
;
assert_eq
!
(
"
Parsing
requires
2
bytes
/
chars
"
error
.
to_string
(
)
)
;
}
}
