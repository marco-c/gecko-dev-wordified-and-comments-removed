#
!
[
allow
(
unused_imports
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
lib
:
:
std
:
:
boxed
:
:
Box
;
use
crate
:
:
error
:
:
{
ErrorKind
FromExternalError
ParseError
}
;
use
crate
:
:
internal
:
:
*
;
use
crate
:
:
lib
:
:
std
:
:
borrow
:
:
Borrow
;
use
crate
:
:
lib
:
:
std
:
:
convert
:
:
Into
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
crate
:
:
lib
:
:
std
:
:
fmt
:
:
Debug
;
use
crate
:
:
lib
:
:
std
:
:
mem
:
:
transmute
;
use
crate
:
:
lib
:
:
std
:
:
ops
:
:
{
Range
RangeFrom
RangeTo
}
;
use
crate
:
:
traits
:
:
{
AsChar
InputIter
InputLength
InputTakeAtPosition
ParseTo
}
;
use
crate
:
:
traits
:
:
{
Compare
CompareResult
Offset
Slice
}
;
#
[
cfg
(
test
)
]
mod
tests
;
#
[
inline
]
pub
fn
rest
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
T
E
>
where
T
:
Slice
<
RangeFrom
<
usize
>
>
T
:
InputLength
{
Ok
(
(
input
.
slice
(
input
.
input_len
(
)
.
.
)
input
)
)
}
#
[
inline
]
pub
fn
rest_len
<
T
E
:
ParseError
<
T
>
>
(
input
:
T
)
-
>
IResult
<
T
usize
E
>
where
T
:
InputLength
{
let
len
=
input
.
input_len
(
)
;
Ok
(
(
input
len
)
)
}
pub
fn
map
<
I
O1
O2
E
F
G
>
(
mut
parser
:
F
mut
f
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
FnMut
(
O1
)
-
>
O2
{
move
|
input
:
I
|
{
let
(
input
o1
)
=
parser
.
parse
(
input
)
?
;
Ok
(
(
input
f
(
o1
)
)
)
}
}
pub
fn
map_res
<
I
:
Clone
O1
O2
E
:
FromExternalError
<
I
E2
>
E2
F
G
>
(
mut
parser
:
F
mut
f
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
FnMut
(
O1
)
-
>
Result
<
O2
E2
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
let
(
input
o1
)
=
parser
.
parse
(
input
)
?
;
match
f
(
o1
)
{
Ok
(
o2
)
=
>
Ok
(
(
input
o2
)
)
Err
(
e
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_external_error
(
i
ErrorKind
:
:
MapRes
e
)
)
)
}
}
}
pub
fn
map_opt
<
I
:
Clone
O1
O2
E
:
ParseError
<
I
>
F
G
>
(
mut
parser
:
F
mut
f
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
FnMut
(
O1
)
-
>
Option
<
O2
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
let
(
input
o1
)
=
parser
.
parse
(
input
)
?
;
match
f
(
o1
)
{
Some
(
o2
)
=
>
Ok
(
(
input
o2
)
)
None
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
MapOpt
)
)
)
}
}
}
pub
fn
map_parser
<
I
O1
O2
E
:
ParseError
<
I
>
F
G
>
(
mut
parser
:
F
mut
applied_parser
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Parser
<
O1
O2
E
>
{
move
|
input
:
I
|
{
let
(
input
o1
)
=
parser
.
parse
(
input
)
?
;
let
(
_
o2
)
=
applied_parser
.
parse
(
o1
)
?
;
Ok
(
(
input
o2
)
)
}
}
pub
fn
flat_map
<
I
O1
O2
E
:
ParseError
<
I
>
F
G
H
>
(
mut
parser
:
F
mut
applied_parser
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
FnMut
(
O1
)
-
>
H
H
:
Parser
<
I
O2
E
>
{
move
|
input
:
I
|
{
let
(
input
o1
)
=
parser
.
parse
(
input
)
?
;
applied_parser
(
o1
)
.
parse
(
input
)
}
}
pub
fn
opt
<
I
:
Clone
O
E
:
ParseError
<
I
>
F
>
(
mut
f
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
Option
<
O
>
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
match
f
.
parse
(
input
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
Some
(
o
)
)
)
Err
(
Err
:
:
Error
(
_
)
)
=
>
Ok
(
(
i
None
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
}
pub
fn
cond
<
I
O
E
:
ParseError
<
I
>
F
>
(
b
:
bool
mut
f
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
Option
<
O
>
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
if
b
{
match
f
.
parse
(
input
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
Some
(
o
)
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
else
{
Ok
(
(
input
None
)
)
}
}
}
pub
fn
peek
<
I
:
Clone
O
E
:
ParseError
<
I
>
F
>
(
mut
f
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
match
f
.
parse
(
input
)
{
Ok
(
(
_
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
}
pub
fn
eof
<
I
:
InputLength
+
Clone
E
:
ParseError
<
I
>
>
(
input
:
I
)
-
>
IResult
<
I
I
E
>
{
if
input
.
input_len
(
)
=
=
0
{
let
clone
=
input
.
clone
(
)
;
Ok
(
(
input
clone
)
)
}
else
{
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
input
ErrorKind
:
:
Eof
)
)
)
}
}
pub
fn
complete
<
I
:
Clone
O
E
:
ParseError
<
I
>
F
>
(
mut
f
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
match
f
.
parse
(
input
)
{
Err
(
Err
:
:
Incomplete
(
_
)
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Complete
)
)
)
rest
=
>
rest
}
}
}
pub
fn
all_consuming
<
I
O
E
:
ParseError
<
I
>
F
>
(
mut
f
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E
>
where
I
:
InputLength
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
(
input
res
)
=
f
.
parse
(
input
)
?
;
if
input
.
input_len
(
)
=
=
0
{
Ok
(
(
input
res
)
)
}
else
{
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
input
ErrorKind
:
:
Eof
)
)
)
}
}
}
pub
fn
verify
<
I
:
Clone
O1
O2
E
:
ParseError
<
I
>
F
G
>
(
mut
first
:
F
second
:
G
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O1
E
>
where
F
:
Parser
<
I
O1
E
>
G
:
Fn
(
&
O2
)
-
>
bool
O1
:
Borrow
<
O2
>
O2
:
?
Sized
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
let
(
input
o
)
=
first
.
parse
(
input
)
?
;
if
second
(
o
.
borrow
(
)
)
{
Ok
(
(
input
o
)
)
}
else
{
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Verify
)
)
)
}
}
}
pub
fn
value
<
I
O1
:
Clone
O2
E
:
ParseError
<
I
>
F
>
(
val
:
O1
mut
parser
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O1
E
>
where
F
:
Parser
<
I
O2
E
>
{
move
|
input
:
I
|
parser
.
parse
(
input
)
.
map
(
|
(
i
_
)
|
(
i
val
.
clone
(
)
)
)
}
pub
fn
not
<
I
:
Clone
O
E
:
ParseError
<
I
>
F
>
(
mut
parser
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
(
)
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
match
parser
.
parse
(
input
)
{
Ok
(
_
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Not
)
)
)
Err
(
Err
:
:
Error
(
_
)
)
=
>
Ok
(
(
i
(
)
)
)
Err
(
e
)
=
>
Err
(
e
)
}
}
}
pub
fn
recognize
<
I
:
Clone
+
Offset
+
Slice
<
RangeTo
<
usize
>
>
O
E
:
ParseError
<
I
>
F
>
(
mut
parser
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
I
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
match
parser
.
parse
(
i
)
{
Ok
(
(
i
_
)
)
=
>
{
let
index
=
input
.
offset
(
&
i
)
;
Ok
(
(
i
input
.
slice
(
.
.
index
)
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
}
pub
fn
consumed
<
I
O
F
E
>
(
mut
parser
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
(
I
O
)
E
>
where
I
:
Clone
+
Offset
+
Slice
<
RangeTo
<
usize
>
>
E
:
ParseError
<
I
>
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
{
let
i
=
input
.
clone
(
)
;
match
parser
.
parse
(
i
)
{
Ok
(
(
remaining
result
)
)
=
>
{
let
index
=
input
.
offset
(
&
remaining
)
;
let
consumed
=
input
.
slice
(
.
.
index
)
;
Ok
(
(
remaining
(
consumed
result
)
)
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
}
pub
fn
cut
<
I
O
E
:
ParseError
<
I
>
F
>
(
mut
parser
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O
E
>
where
F
:
Parser
<
I
O
E
>
{
move
|
input
:
I
|
match
parser
.
parse
(
input
)
{
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
)
)
rest
=
>
rest
}
}
pub
fn
into
<
I
O1
O2
E1
E2
F
>
(
mut
parser
:
F
)
-
>
impl
FnMut
(
I
)
-
>
IResult
<
I
O2
E2
>
where
O1
:
Into
<
O2
>
E1
:
Into
<
E2
>
E1
:
ParseError
<
I
>
E2
:
ParseError
<
I
>
F
:
Parser
<
I
O1
E1
>
{
move
|
input
:
I
|
match
parser
.
parse
(
input
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
.
into
(
)
)
)
Err
(
Err
:
:
Error
(
e
)
)
=
>
Err
(
Err
:
:
Error
(
e
.
into
(
)
)
)
Err
(
Err
:
:
Failure
(
e
)
)
=
>
Err
(
Err
:
:
Failure
(
e
.
into
(
)
)
)
Err
(
Err
:
:
Incomplete
(
e
)
)
=
>
Err
(
Err
:
:
Incomplete
(
e
)
)
}
}
pub
fn
iterator
<
Input
Output
Error
F
>
(
input
:
Input
f
:
F
)
-
>
ParserIterator
<
Input
Error
F
>
where
F
:
Parser
<
Input
Output
Error
>
Error
:
ParseError
<
Input
>
{
ParserIterator
{
iterator
:
f
input
state
:
Some
(
State
:
:
Running
)
}
}
pub
struct
ParserIterator
<
I
E
F
>
{
iterator
:
F
input
:
I
state
:
Option
<
State
<
E
>
>
}
impl
<
I
:
Clone
E
F
>
ParserIterator
<
I
E
F
>
{
pub
fn
finish
(
mut
self
)
-
>
IResult
<
I
(
)
E
>
{
match
self
.
state
.
take
(
)
.
unwrap
(
)
{
State
:
:
Running
|
State
:
:
Done
=
>
Ok
(
(
self
.
input
(
)
)
)
State
:
:
Failure
(
e
)
=
>
Err
(
Err
:
:
Failure
(
e
)
)
State
:
:
Incomplete
(
i
)
=
>
Err
(
Err
:
:
Incomplete
(
i
)
)
}
}
}
impl
<
'
a
Input
Output
Error
F
>
core
:
:
iter
:
:
Iterator
for
&
'
a
mut
ParserIterator
<
Input
Error
F
>
where
F
:
FnMut
(
Input
)
-
>
IResult
<
Input
Output
Error
>
Input
:
Clone
{
type
Item
=
Output
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
State
:
:
Running
=
self
.
state
.
take
(
)
.
unwrap
(
)
{
let
input
=
self
.
input
.
clone
(
)
;
match
(
self
.
iterator
)
(
input
)
{
Ok
(
(
i
o
)
)
=
>
{
self
.
input
=
i
;
self
.
state
=
Some
(
State
:
:
Running
)
;
Some
(
o
)
}
Err
(
Err
:
:
Error
(
_
)
)
=
>
{
self
.
state
=
Some
(
State
:
:
Done
)
;
None
}
Err
(
Err
:
:
Failure
(
e
)
)
=
>
{
self
.
state
=
Some
(
State
:
:
Failure
(
e
)
)
;
None
}
Err
(
Err
:
:
Incomplete
(
i
)
)
=
>
{
self
.
state
=
Some
(
State
:
:
Incomplete
(
i
)
)
;
None
}
}
}
else
{
None
}
}
}
enum
State
<
E
>
{
Running
Done
Failure
(
E
)
Incomplete
(
Needed
)
}
pub
fn
success
<
I
O
:
Clone
E
:
ParseError
<
I
>
>
(
val
:
O
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
O
E
>
{
move
|
input
:
I
|
Ok
(
(
input
val
.
clone
(
)
)
)
}
pub
fn
fail
<
I
O
E
:
ParseError
<
I
>
>
(
i
:
I
)
-
>
IResult
<
I
O
E
>
{
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Fail
)
)
)
}
