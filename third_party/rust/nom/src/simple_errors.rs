use
util
:
:
{
Convert
ErrorKind
}
;
use
lib
:
:
std
:
:
convert
:
:
From
;
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
enum
Context
<
I
E
=
u32
>
{
Code
(
I
ErrorKind
<
E
>
)
}
impl
<
I
F
E
:
From
<
F
>
>
Convert
<
Context
<
I
F
>
>
for
Context
<
I
E
>
{
fn
convert
(
c
:
Context
<
I
F
>
)
-
>
Self
{
let
Context
:
:
Code
(
i
e
)
=
c
;
Context
:
:
Code
(
i
ErrorKind
:
:
convert
(
e
)
)
}
}
impl
<
I
E
>
Context
<
I
E
>
{
pub
fn
into_error_kind
(
self
)
-
>
ErrorKind
<
E
>
{
let
Context
:
:
Code
(
_
e
)
=
self
;
ErrorKind
:
:
convert
(
e
)
}
}
#
[
macro_export
]
macro_rules
!
fix_error
(
(
i
:
expr
t
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
Err
;
use
crate
:
:
{
Convert
Context
ErrorKind
}
;
match
submac
!
(
i
(
args
)
*
)
{
Ok
(
(
i
o
)
)
=
>
Ok
(
(
i
o
)
)
Err
(
e
)
=
>
{
let
e2
=
match
e
{
Err
:
:
Error
(
err
)
=
>
{
let
Context
:
:
Code
(
i
code
)
=
err
;
let
code2
:
ErrorKind
<
t
>
=
ErrorKind
:
:
convert
(
code
)
;
Err
:
:
Error
(
Context
:
:
Code
(
i
code2
)
)
}
Err
:
:
Failure
(
err
)
=
>
{
let
Context
:
:
Code
(
i
code
)
=
err
;
let
code2
:
ErrorKind
<
t
>
=
ErrorKind
:
:
convert
(
code
)
;
Err
:
:
Failure
(
Context
:
:
Code
(
i
code2
)
)
}
Err
:
:
Incomplete
(
e
)
=
>
Err
:
:
Incomplete
(
e
)
}
;
Err
(
e2
)
}
}
}
)
;
(
i
:
expr
t
:
ty
f
:
expr
)
=
>
(
fix_error
!
(
i
t
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
flat_map
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
flat_map
!
(
__impl
i
submac
!
(
(
args
)
*
)
submac2
!
(
(
args2
)
*
)
)
;
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
flat_map
!
(
__impl
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
flat_map
!
(
__impl
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
flat_map
!
(
__impl
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
__impl
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
{
use
crate
:
:
lib
:
:
std
:
:
result
:
:
Result
:
:
*
;
use
crate
:
:
{
Convert
Err
}
;
(
submac
!
(
i
(
args
)
*
)
)
.
and_then
(
|
(
i
o
)
|
{
match
submac2
!
(
o
(
args2
)
*
)
{
Err
(
e
)
=
>
Err
(
Err
:
:
convert
(
e
)
)
Ok
(
(
_
o2
)
)
=
>
Ok
(
(
i
o2
)
)
}
}
)
}
)
;
)
;
