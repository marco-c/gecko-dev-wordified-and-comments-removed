#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
one_of
(
(
i
:
expr
inp
:
expr
)
=
>
(
crate
:
:
character
:
:
streaming
:
:
one_of
(
inp
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
none_of
(
(
i
:
expr
inp
:
expr
)
=
>
(
crate
:
:
character
:
:
streaming
:
:
none_of
(
inp
)
(
i
)
)
;
)
;
#
[
macro_export
(
local_inner_macros
)
]
macro_rules
!
char
(
(
i
:
expr
c
:
expr
)
=
>
(
crate
:
:
character
:
:
streaming
:
:
char
(
c
)
(
i
)
)
;
)
;
#
[
cfg
(
test
)
]
mod
tests
{
use
crate
:
:
internal
:
:
Err
;
use
crate
:
:
error
:
:
ErrorKind
;
#
[
test
]
fn
one_of
(
)
{
named
!
(
f
<
char
>
one_of
!
(
"
ab
"
)
)
;
let
a
=
&
b
"
abcd
"
[
.
.
]
;
assert_eq
!
(
f
(
a
)
Ok
(
(
&
b
"
bcd
"
[
.
.
]
'
a
'
)
)
)
;
let
b
=
&
b
"
cde
"
[
.
.
]
;
assert_eq
!
(
f
(
b
)
Err
(
Err
:
:
Error
(
error_position
!
(
b
ErrorKind
:
:
OneOf
)
)
)
)
;
named
!
(
utf8
(
&
str
)
-
>
char
one_of
!
(
"
+
\
u
{
FF0B
}
"
)
)
;
assert
!
(
utf8
(
"
+
"
)
.
is_ok
(
)
)
;
assert
!
(
utf8
(
"
\
u
{
FF0B
}
"
)
.
is_ok
(
)
)
;
}
#
[
test
]
fn
none_of
(
)
{
named
!
(
f
<
char
>
none_of
!
(
"
ab
"
)
)
;
let
a
=
&
b
"
abcd
"
[
.
.
]
;
assert_eq
!
(
f
(
a
)
Err
(
Err
:
:
Error
(
error_position
!
(
a
ErrorKind
:
:
NoneOf
)
)
)
)
;
let
b
=
&
b
"
cde
"
[
.
.
]
;
assert_eq
!
(
f
(
b
)
Ok
(
(
&
b
"
de
"
[
.
.
]
'
c
'
)
)
)
;
}
#
[
test
]
fn
char
(
)
{
named
!
(
f
<
char
>
char
!
(
'
c
'
)
)
;
let
a
=
&
b
"
abcd
"
[
.
.
]
;
assert_eq
!
(
f
(
a
)
Err
(
Err
:
:
Error
(
error_position
!
(
a
ErrorKind
:
:
Char
)
)
)
)
;
let
b
=
&
b
"
cde
"
[
.
.
]
;
assert_eq
!
(
f
(
b
)
Ok
(
(
&
b
"
de
"
[
.
.
]
'
c
'
)
)
)
;
}
#
[
test
]
fn
char_str
(
)
{
named
!
(
f
<
&
str
char
>
char
!
(
'
c
'
)
)
;
let
a
=
&
"
abcd
"
[
.
.
]
;
assert_eq
!
(
f
(
a
)
Err
(
Err
:
:
Error
(
error_position
!
(
a
ErrorKind
:
:
Char
)
)
)
)
;
let
b
=
&
"
cde
"
[
.
.
]
;
assert_eq
!
(
f
(
b
)
Ok
(
(
&
"
de
"
[
.
.
]
'
c
'
)
)
)
;
}
}
