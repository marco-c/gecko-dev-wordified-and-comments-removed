use
self
:
:
Needed
:
:
*
;
#
[
cfg
(
feature
=
"
verbose
-
errors
"
)
]
use
verbose_errors
:
:
Context
;
#
[
cfg
(
not
(
feature
=
"
verbose
-
errors
"
)
)
]
use
simple_errors
:
:
Context
;
pub
type
IResult
<
I
O
E
=
u32
>
=
Result
<
(
I
O
)
Err
<
I
E
>
>
;
#
[
derive
(
Debug
PartialEq
Eq
Clone
Copy
)
]
pub
enum
Needed
{
Unknown
Size
(
usize
)
}
impl
Needed
{
pub
fn
is_known
(
&
self
)
-
>
bool
{
*
self
!
=
Unknown
}
#
[
inline
]
pub
fn
map
<
F
:
FnOnce
(
usize
)
-
>
usize
>
(
self
f
:
F
)
-
>
Needed
{
match
self
{
Unknown
=
>
Unknown
Size
(
n
)
=
>
Size
(
f
(
n
)
)
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
enum
Err
<
I
E
=
u32
>
{
Incomplete
(
Needed
)
Error
(
Context
<
I
E
>
)
Failure
(
Context
<
I
E
>
)
}
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
fmt
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
I
E
>
fmt
:
:
Display
for
Err
<
I
E
>
where
I
:
fmt
:
:
Debug
E
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
:
?
}
"
self
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
error
:
:
Error
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
I
E
>
Error
for
Err
<
I
E
>
where
I
:
fmt
:
:
Debug
E
:
fmt
:
:
Debug
{
fn
description
(
&
self
)
-
>
&
str
{
match
self
{
&
Err
:
:
Incomplete
(
.
.
)
=
>
"
there
was
not
enough
data
"
&
Err
:
:
Error
(
Context
:
:
Code
(
_
ref
error_kind
)
)
|
&
Err
:
:
Failure
(
Context
:
:
Code
(
_
ref
error_kind
)
)
=
>
error_kind
.
description
(
)
#
[
cfg
(
feature
=
"
verbose
-
errors
"
)
]
&
Err
:
:
Error
(
Context
:
:
List
(
.
.
)
)
|
&
Err
:
:
Failure
(
Context
:
:
List
(
.
.
)
)
=
>
"
list
of
errors
"
}
}
fn
cause
(
&
self
)
-
>
Option
<
&
Error
>
{
None
}
}
use
util
:
:
Convert
;
impl
<
I
F
E
:
From
<
F
>
>
Convert
<
Err
<
I
F
>
>
for
Err
<
I
E
>
{
fn
convert
(
e
:
Err
<
I
F
>
)
-
>
Self
{
match
e
{
Err
:
:
Incomplete
(
n
)
=
>
Err
:
:
Incomplete
(
n
)
Err
:
:
Failure
(
c
)
=
>
Err
:
:
Failure
(
Context
:
:
convert
(
c
)
)
Err
:
:
Error
(
c
)
=
>
Err
:
:
Error
(
Context
:
:
convert
(
c
)
)
}
}
}
impl
<
I
E
>
Err
<
I
E
>
{
pub
fn
into_error_kind
(
self
)
-
>
:
:
util
:
:
ErrorKind
<
E
>
{
match
self
{
Err
:
:
Incomplete
(
_
)
=
>
:
:
util
:
:
ErrorKind
:
:
Complete
Err
:
:
Failure
(
c
)
=
>
c
.
into_error_kind
(
)
Err
:
:
Error
(
c
)
=
>
c
.
into_error_kind
(
)
}
}
pub
fn
is_incomplete
(
&
self
)
-
>
bool
{
match
*
self
{
Err
:
:
Incomplete
(
_
)
=
>
true
_
=
>
false
}
}
}
#
[
cfg
(
feature
=
"
verbose
-
errors
"
)
]
#
[
macro_export
]
macro_rules
!
error_position
(
(
input
:
expr
code
:
expr
)
=
>
(
{
crate
:
:
Context
:
:
Code
(
input
code
)
}
)
;
)
;
#
[
cfg
(
not
(
feature
=
"
verbose
-
errors
"
)
)
]
#
[
allow
(
unused_variables
)
]
#
[
macro_export
]
macro_rules
!
error_position
(
(
input
:
expr
code
:
expr
)
=
>
(
{
crate
:
:
Context
:
:
Code
(
input
code
)
}
)
;
)
;
#
[
cfg
(
feature
=
"
verbose
-
errors
"
)
]
#
[
macro_export
]
macro_rules
!
error_node_position
(
(
input
:
expr
code
:
expr
next
:
expr
)
=
>
{
{
let
mut
error_vec
=
match
next
{
crate
:
:
Context
:
:
Code
(
i
e
)
=
>
{
let
mut
v
=
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
v
.
push
(
(
i
e
)
)
;
v
}
crate
:
:
Context
:
:
List
(
v
)
=
>
{
v
}
}
;
error_vec
.
push
(
(
input
code
)
)
;
crate
:
:
Context
:
:
List
(
error_vec
)
}
}
)
;
#
[
cfg
(
not
(
feature
=
"
verbose
-
errors
"
)
)
]
#
[
allow
(
unused_variables
)
]
#
[
macro_export
]
macro_rules
!
error_node_position
(
(
input
:
expr
code
:
expr
next
:
expr
)
=
>
(
{
fn
unify_types
<
T
>
(
_
:
&
T
_
:
&
T
)
{
}
let
res
=
crate
:
:
Context
:
:
Code
(
input
code
)
;
unify_types
(
&
res
&
next
)
;
res
}
)
;
)
;
#
[
cfg
(
test
)
]
mod
tests
{
}
