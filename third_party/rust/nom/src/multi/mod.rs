#
[
macro_use
]
mod
macros
;
use
crate
:
:
internal
:
:
{
Err
IResult
Needed
}
;
use
crate
:
:
error
:
:
ParseError
;
use
crate
:
:
traits
:
:
{
InputLength
InputTake
ToUsize
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
;
use
crate
:
:
error
:
:
ErrorKind
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many0
<
I
O
E
F
>
(
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
acc
=
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
:
:
with_capacity
(
4
)
;
let
mut
i
=
i
.
clone
(
)
;
loop
{
match
f
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
acc
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Many0
)
)
)
;
}
i
=
i1
;
acc
.
push
(
o
)
;
}
}
}
}
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many0c
<
I
O
E
F
>
(
input
:
I
f
:
F
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
many0
(
f
)
(
input
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many1
<
I
O
E
F
>
(
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
i
=
i
.
clone
(
)
;
match
f
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
err
)
)
=
>
return
Err
(
Err
:
:
Error
(
E
:
:
append
(
i
ErrorKind
:
:
Many1
err
)
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o
)
)
=
>
{
let
mut
acc
=
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
:
:
with_capacity
(
4
)
;
acc
.
push
(
o
)
;
i
=
i1
;
loop
{
match
f
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
acc
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Many1
)
)
)
;
}
i
=
i1
;
acc
.
push
(
o
)
;
}
}
}
}
}
}
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many1c
<
I
O
E
F
>
(
input
:
I
f
:
F
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
Copy
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
many1
(
f
)
(
input
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many_till
<
I
O
P
E
F
G
>
(
f
:
F
g
:
G
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
(
Vec
<
O
>
P
)
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
P
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
res
=
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
let
mut
i
=
i
.
clone
(
)
;
loop
{
match
g
(
i
.
clone
(
)
)
{
Ok
(
(
i1
o
)
)
=
>
return
Ok
(
(
i1
(
res
o
)
)
)
Err
(
Err
:
:
Error
(
_
)
)
=
>
{
match
f
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
err
)
)
=
>
return
Err
(
Err
:
:
Error
(
E
:
:
append
(
i
ErrorKind
:
:
ManyTill
err
)
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i1
ErrorKind
:
:
ManyTill
)
)
)
;
}
res
.
push
(
o
)
;
i
=
i1
;
}
}
}
Err
(
e
)
=
>
return
Err
(
e
)
}
}
}
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many_tillc
<
I
O
P
E
F
G
>
(
i
:
I
f
:
F
g
:
G
)
-
>
IResult
<
I
(
Vec
<
O
>
P
)
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
P
E
>
E
:
ParseError
<
I
>
{
many_till
(
f
g
)
(
i
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
separated_list
<
I
O
O2
E
F
G
>
(
sep
:
G
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
O2
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
res
=
Vec
:
:
new
(
)
;
let
mut
i
=
i
.
clone
(
)
;
match
f
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
res
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i1
ErrorKind
:
:
SeparatedList
)
)
)
;
}
res
.
push
(
o
)
;
i
=
i1
;
}
}
loop
{
match
sep
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
res
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
_
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i1
ErrorKind
:
:
SeparatedList
)
)
)
;
}
match
f
(
i1
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
res
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i2
o
)
)
=
>
{
if
i2
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i2
ErrorKind
:
:
SeparatedList
)
)
)
;
}
res
.
push
(
o
)
;
i
=
i2
;
}
}
}
}
}
}
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
separated_listc
<
I
O
O2
E
F
G
>
(
i
:
I
sep
:
G
f
:
F
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
O2
E
>
E
:
ParseError
<
I
>
{
separated_list
(
sep
f
)
(
i
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
separated_nonempty_list
<
I
O
O2
E
F
G
>
(
sep
:
G
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
O2
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
res
=
Vec
:
:
new
(
)
;
let
mut
i
=
i
.
clone
(
)
;
match
f
(
i
.
clone
(
)
)
{
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i1
ErrorKind
:
:
SeparatedList
)
)
)
;
}
res
.
push
(
o
)
;
i
=
i1
;
}
}
loop
{
match
sep
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
res
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
_
)
)
=
>
{
if
i1
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i1
ErrorKind
:
:
SeparatedList
)
)
)
;
}
match
f
(
i1
.
clone
(
)
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
i
res
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i2
o
)
)
=
>
{
if
i2
=
=
i
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i2
ErrorKind
:
:
SeparatedList
)
)
)
;
}
res
.
push
(
o
)
;
i
=
i2
;
}
}
}
}
}
}
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
separated_nonempty_listc
<
I
O
O2
E
F
G
>
(
i
:
I
sep
:
G
f
:
F
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
O2
E
>
E
:
ParseError
<
I
>
{
separated_nonempty_list
(
sep
f
)
(
i
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many_m_n
<
I
O
E
F
>
(
m
:
usize
n
:
usize
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
res
=
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
:
:
with_capacity
(
m
)
;
let
mut
input
=
i
.
clone
(
)
;
let
mut
count
:
usize
=
0
;
if
n
=
=
0
{
return
Ok
(
(
i
vec
!
(
)
)
)
}
loop
{
let
_i
=
input
.
clone
(
)
;
match
f
(
_i
)
{
Ok
(
(
i
o
)
)
=
>
{
if
i
=
=
input
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
input
ErrorKind
:
:
ManyMN
)
)
)
;
}
res
.
push
(
o
)
;
input
=
i
;
count
+
=
1
;
if
count
=
=
n
{
return
Ok
(
(
input
res
)
)
;
}
}
Err
(
Err
:
:
Error
(
e
)
)
=
>
{
if
count
<
m
{
return
Err
(
Err
:
:
Error
(
E
:
:
append
(
input
ErrorKind
:
:
ManyMN
e
)
)
)
;
}
else
{
return
Ok
(
(
input
res
)
)
;
}
}
Err
(
e
)
=
>
{
return
Err
(
e
)
;
}
}
}
}
}
#
[
doc
(
hidden
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
many_m_nc
<
I
O
E
F
>
(
i
:
I
m
:
usize
n
:
usize
f
:
F
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
many_m_n
(
m
n
f
)
(
i
)
}
pub
fn
many0_count
<
I
O
E
F
>
(
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
usize
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
input
=
i
.
clone
(
)
;
let
mut
count
=
0
;
loop
{
let
input_
=
input
.
clone
(
)
;
match
f
(
input_
)
{
Ok
(
(
i
_
)
)
=
>
{
if
i
=
=
input
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
input
ErrorKind
:
:
Many0Count
)
)
)
;
}
input
=
i
;
count
+
=
1
;
}
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
input
count
)
)
Err
(
e
)
=
>
return
Err
(
e
)
}
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
many0_countc
<
I
O
E
F
>
(
i
:
I
f
:
F
)
-
>
IResult
<
I
usize
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
many0_count
(
f
)
(
i
)
}
pub
fn
many1_count
<
I
O
E
F
>
(
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
usize
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
i_
=
i
.
clone
(
)
;
match
f
(
i_
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Many1Count
)
)
)
Err
(
i
)
=
>
Err
(
i
)
Ok
(
(
i1
_
)
)
=
>
{
let
mut
count
=
1
;
let
mut
input
=
i1
;
loop
{
let
input_
=
input
.
clone
(
)
;
match
f
(
input_
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
return
Ok
(
(
input
count
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i
_
)
)
=
>
{
if
i
=
=
input
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Many1Count
)
)
)
;
}
count
+
=
1
;
input
=
i
;
}
}
}
}
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
many1_countc
<
I
O
E
F
>
(
i
:
I
f
:
F
)
-
>
IResult
<
I
usize
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
many1_count
(
f
)
(
i
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
count
<
I
O
E
F
>
(
f
:
F
count
:
usize
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
Vec
<
O
>
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
mut
input
=
i
.
clone
(
)
;
let
mut
res
=
crate
:
:
lib
:
:
std
:
:
vec
:
:
Vec
:
:
new
(
)
;
for
_
in
0
.
.
count
{
let
input_
=
input
.
clone
(
)
;
match
f
(
input_
)
{
Ok
(
(
i
o
)
)
=
>
{
res
.
push
(
o
)
;
input
=
i
;
}
Err
(
Err
:
:
Error
(
e
)
)
=
>
{
return
Err
(
Err
:
:
Error
(
E
:
:
append
(
i
ErrorKind
:
:
Count
e
)
)
)
;
}
Err
(
e
)
=
>
{
return
Err
(
e
)
;
}
}
}
Ok
(
(
input
res
)
)
}
}
pub
fn
fold_many0
<
I
O
E
F
G
R
>
(
f
:
F
init
:
R
g
:
G
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
R
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
R
O
)
-
>
R
E
:
ParseError
<
I
>
R
:
Clone
{
move
|
i
:
I
|
{
let
mut
res
=
init
.
clone
(
)
;
let
mut
input
=
i
.
clone
(
)
;
loop
{
let
i_
=
input
.
clone
(
)
;
match
f
(
i_
)
{
Ok
(
(
i
o
)
)
=
>
{
if
i
=
=
input
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
input
ErrorKind
:
:
Many0
)
)
)
;
}
res
=
g
(
res
o
)
;
input
=
i
;
}
Err
(
Err
:
:
Error
(
_
)
)
=
>
{
return
Ok
(
(
input
res
)
)
;
}
Err
(
e
)
=
>
{
return
Err
(
e
)
;
}
}
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
fold_many0c
<
I
O
E
F
G
R
>
(
i
:
I
f
:
F
init
:
R
g
:
G
)
-
>
IResult
<
I
R
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
R
O
)
-
>
R
E
:
ParseError
<
I
>
R
:
Clone
{
fold_many0
(
f
init
g
)
(
i
)
}
pub
fn
fold_many1
<
I
O
E
F
G
R
>
(
f
:
F
init
:
R
g
:
G
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
R
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
R
O
)
-
>
R
E
:
ParseError
<
I
>
R
:
Clone
{
move
|
i
:
I
|
{
let
_i
=
i
.
clone
(
)
;
let
init
=
init
.
clone
(
)
;
match
f
(
_i
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Many1
)
)
)
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i1
o1
)
)
=
>
{
let
mut
acc
=
g
(
init
o1
)
;
let
mut
input
=
i1
;
loop
{
let
_input
=
input
.
clone
(
)
;
match
f
(
_input
)
{
Err
(
Err
:
:
Error
(
_
)
)
=
>
{
break
;
}
Err
(
e
)
=
>
return
Err
(
e
)
Ok
(
(
i
o
)
)
=
>
{
if
i
=
=
input
{
return
Err
(
Err
:
:
Failure
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Many1
)
)
)
;
}
acc
=
g
(
acc
o
)
;
input
=
i
;
}
}
}
Ok
(
(
input
acc
)
)
}
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
fold_many1c
<
I
O
E
F
G
R
>
(
i
:
I
f
:
F
init
:
R
g
:
G
)
-
>
IResult
<
I
R
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
R
O
)
-
>
R
E
:
ParseError
<
I
>
R
:
Clone
{
fold_many1
(
f
init
g
)
(
i
)
}
pub
fn
fold_many_m_n
<
I
O
E
F
G
R
>
(
m
:
usize
n
:
usize
f
:
F
init
:
R
g
:
G
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
R
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
R
O
)
-
>
R
E
:
ParseError
<
I
>
R
:
Clone
{
move
|
i
:
I
|
{
let
mut
acc
=
init
.
clone
(
)
;
let
mut
input
=
i
.
clone
(
)
;
for
count
in
0
.
.
n
{
let
_input
=
input
.
clone
(
)
;
match
f
(
_input
)
{
Ok
(
(
i
o
)
)
=
>
{
if
i
=
=
input
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
ManyMN
)
)
)
;
}
acc
=
g
(
acc
o
)
;
input
=
i
;
}
Err
(
Err
:
:
Error
(
_
)
)
=
>
if
count
<
m
{
return
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
ManyMN
)
)
)
;
}
else
{
break
;
}
Err
(
e
)
=
>
return
Err
(
e
)
}
}
Ok
(
(
input
acc
)
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
fold_many_m_nc
<
I
O
E
F
G
R
>
(
i
:
I
m
:
usize
n
:
usize
f
:
F
init
:
R
g
:
G
)
-
>
IResult
<
I
R
E
>
where
I
:
Clone
+
PartialEq
F
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
G
:
Fn
(
R
O
)
-
>
R
E
:
ParseError
<
I
>
R
:
Clone
{
fold_many_m_n
(
m
n
f
init
g
)
(
i
)
}
pub
fn
length_data
<
I
N
E
F
>
(
f
:
F
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
I
E
>
where
I
:
Clone
+
InputLength
+
InputTake
N
:
Copy
+
ToUsize
F
:
Fn
(
I
)
-
>
IResult
<
I
N
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
(
i
length
)
=
f
(
i
)
?
;
let
length
:
usize
=
length
.
to_usize
(
)
;
if
i
.
input_len
(
)
<
length
{
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
length
)
)
)
}
else
{
Ok
(
i
.
take_split
(
length
)
)
}
}
}
pub
fn
length_value
<
I
O
N
E
F
G
>
(
f
:
F
g
:
G
)
-
>
impl
Fn
(
I
)
-
>
IResult
<
I
O
E
>
where
I
:
Clone
+
InputLength
+
InputTake
N
:
Copy
+
ToUsize
F
:
Fn
(
I
)
-
>
IResult
<
I
N
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
move
|
i
:
I
|
{
let
(
i
length
)
=
f
(
i
)
?
;
let
length
:
usize
=
length
.
to_usize
(
)
;
if
i
.
input_len
(
)
<
length
{
Err
(
Err
:
:
Incomplete
(
Needed
:
:
Size
(
length
)
)
)
}
else
{
let
(
rest
i
)
=
i
.
take_split
(
length
)
;
match
g
(
i
.
clone
(
)
)
{
Err
(
Err
:
:
Incomplete
(
_
)
)
=
>
Err
(
Err
:
:
Error
(
E
:
:
from_error_kind
(
i
ErrorKind
:
:
Complete
)
)
)
Err
(
e
)
=
>
Err
(
e
)
Ok
(
(
_
o
)
)
=
>
Ok
(
(
rest
o
)
)
}
}
}
}
#
[
doc
(
hidden
)
]
pub
fn
length_valuec
<
I
O
N
E
F
G
>
(
i
:
I
f
:
F
g
:
G
)
-
>
IResult
<
I
O
E
>
where
I
:
Clone
+
InputLength
+
InputTake
N
:
Copy
+
ToUsize
F
:
Fn
(
I
)
-
>
IResult
<
I
N
E
>
G
:
Fn
(
I
)
-
>
IResult
<
I
O
E
>
E
:
ParseError
<
I
>
{
length_value
(
f
g
)
(
i
)
}
