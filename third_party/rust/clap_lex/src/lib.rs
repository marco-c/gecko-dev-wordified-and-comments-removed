#
!
[
cfg_attr
(
docsrs
feature
(
doc_auto_cfg
)
)
]
#
!
[
warn
(
missing_docs
)
]
#
!
[
warn
(
clippy
:
:
print_stderr
)
]
#
!
[
warn
(
clippy
:
:
print_stdout
)
]
mod
ext
;
use
std
:
:
ffi
:
:
OsStr
;
use
std
:
:
ffi
:
:
OsString
;
pub
use
std
:
:
io
:
:
SeekFrom
;
pub
use
ext
:
:
OsStrExt
;
#
[
derive
(
Default
Clone
Debug
PartialEq
Eq
)
]
pub
struct
RawArgs
{
items
:
Vec
<
OsString
>
}
impl
RawArgs
{
pub
fn
from_args
(
)
-
>
Self
{
Self
:
:
new
(
std
:
:
env
:
:
args_os
(
)
)
}
pub
fn
new
(
iter
:
impl
IntoIterator
<
Item
=
impl
Into
<
OsString
>
>
)
-
>
Self
{
let
iter
=
iter
.
into_iter
(
)
;
Self
:
:
from
(
iter
)
}
pub
fn
cursor
(
&
self
)
-
>
ArgCursor
{
ArgCursor
:
:
new
(
)
}
pub
fn
next
(
&
self
cursor
:
&
mut
ArgCursor
)
-
>
Option
<
ParsedArg
<
'
_
>
>
{
self
.
next_os
(
cursor
)
.
map
(
ParsedArg
:
:
new
)
}
pub
fn
next_os
(
&
self
cursor
:
&
mut
ArgCursor
)
-
>
Option
<
&
OsStr
>
{
let
next
=
self
.
items
.
get
(
cursor
.
cursor
)
.
map
(
|
s
|
s
.
as_os_str
(
)
)
;
cursor
.
cursor
=
cursor
.
cursor
.
saturating_add
(
1
)
;
next
}
pub
fn
peek
(
&
self
cursor
:
&
ArgCursor
)
-
>
Option
<
ParsedArg
<
'
_
>
>
{
self
.
peek_os
(
cursor
)
.
map
(
ParsedArg
:
:
new
)
}
pub
fn
peek_os
(
&
self
cursor
:
&
ArgCursor
)
-
>
Option
<
&
OsStr
>
{
self
.
items
.
get
(
cursor
.
cursor
)
.
map
(
|
s
|
s
.
as_os_str
(
)
)
}
pub
fn
remaining
(
&
self
cursor
:
&
mut
ArgCursor
)
-
>
impl
Iterator
<
Item
=
&
OsStr
>
{
let
remaining
=
self
.
items
[
cursor
.
cursor
.
.
]
.
iter
(
)
.
map
(
|
s
|
s
.
as_os_str
(
)
)
;
cursor
.
cursor
=
self
.
items
.
len
(
)
;
remaining
}
pub
fn
seek
(
&
self
cursor
:
&
mut
ArgCursor
pos
:
SeekFrom
)
{
let
pos
=
match
pos
{
SeekFrom
:
:
Start
(
pos
)
=
>
pos
SeekFrom
:
:
End
(
pos
)
=
>
(
self
.
items
.
len
(
)
as
i64
)
.
saturating_add
(
pos
)
.
max
(
0
)
as
u64
SeekFrom
:
:
Current
(
pos
)
=
>
(
cursor
.
cursor
as
i64
)
.
saturating_add
(
pos
)
.
max
(
0
)
as
u64
}
;
let
pos
=
(
pos
as
usize
)
.
min
(
self
.
items
.
len
(
)
)
;
cursor
.
cursor
=
pos
;
}
pub
fn
insert
(
&
mut
self
cursor
:
&
ArgCursor
insert_items
:
impl
IntoIterator
<
Item
=
impl
Into
<
OsString
>
>
)
{
self
.
items
.
splice
(
cursor
.
cursor
.
.
cursor
.
cursor
insert_items
.
into_iter
(
)
.
map
(
Into
:
:
into
)
)
;
}
pub
fn
is_end
(
&
self
cursor
:
&
ArgCursor
)
-
>
bool
{
self
.
peek_os
(
cursor
)
.
is_none
(
)
}
}
impl
<
I
T
>
From
<
I
>
for
RawArgs
where
I
:
Iterator
<
Item
=
T
>
T
:
Into
<
OsString
>
{
fn
from
(
val
:
I
)
-
>
Self
{
Self
{
items
:
val
.
map
(
|
x
|
x
.
into
(
)
)
.
collect
(
)
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
)
]
pub
struct
ArgCursor
{
cursor
:
usize
}
impl
ArgCursor
{
fn
new
(
)
-
>
Self
{
Self
{
cursor
:
0
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
pub
struct
ParsedArg
<
'
s
>
{
inner
:
&
'
s
OsStr
}
impl
<
'
s
>
ParsedArg
<
'
s
>
{
fn
new
(
inner
:
&
'
s
OsStr
)
-
>
Self
{
Self
{
inner
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
inner
.
is_empty
(
)
}
pub
fn
is_stdio
(
&
self
)
-
>
bool
{
self
.
inner
=
=
"
-
"
}
pub
fn
is_escape
(
&
self
)
-
>
bool
{
self
.
inner
=
=
"
-
-
"
}
pub
fn
is_negative_number
(
&
self
)
-
>
bool
{
self
.
to_value
(
)
.
ok
(
)
.
and_then
(
|
s
|
Some
(
is_number
(
s
.
strip_prefix
(
'
-
'
)
?
)
)
)
.
unwrap_or_default
(
)
}
pub
fn
to_long
(
&
self
)
-
>
Option
<
(
Result
<
&
str
&
OsStr
>
Option
<
&
OsStr
>
)
>
{
let
raw
=
self
.
inner
;
let
remainder
=
raw
.
strip_prefix
(
"
-
-
"
)
?
;
if
remainder
.
is_empty
(
)
{
debug_assert
!
(
self
.
is_escape
(
)
)
;
return
None
;
}
let
(
flag
value
)
=
if
let
Some
(
(
p0
p1
)
)
=
remainder
.
split_once
(
"
=
"
)
{
(
p0
Some
(
p1
)
)
}
else
{
(
remainder
None
)
}
;
let
flag
=
flag
.
to_str
(
)
.
ok_or
(
flag
)
;
Some
(
(
flag
value
)
)
}
pub
fn
is_long
(
&
self
)
-
>
bool
{
self
.
inner
.
starts_with
(
"
-
-
"
)
&
&
!
self
.
is_escape
(
)
}
pub
fn
to_short
(
&
self
)
-
>
Option
<
ShortFlags
<
'
_
>
>
{
if
let
Some
(
remainder_os
)
=
self
.
inner
.
strip_prefix
(
"
-
"
)
{
if
remainder_os
.
starts_with
(
"
-
"
)
{
None
}
else
if
remainder_os
.
is_empty
(
)
{
debug_assert
!
(
self
.
is_stdio
(
)
)
;
None
}
else
{
Some
(
ShortFlags
:
:
new
(
remainder_os
)
)
}
}
else
{
None
}
}
pub
fn
is_short
(
&
self
)
-
>
bool
{
self
.
inner
.
starts_with
(
"
-
"
)
&
&
!
self
.
is_stdio
(
)
&
&
!
self
.
inner
.
starts_with
(
"
-
-
"
)
}
pub
fn
to_value_os
(
&
self
)
-
>
&
OsStr
{
self
.
inner
}
pub
fn
to_value
(
&
self
)
-
>
Result
<
&
str
&
OsStr
>
{
self
.
inner
.
to_str
(
)
.
ok_or
(
self
.
inner
)
}
pub
fn
display
(
&
self
)
-
>
impl
std
:
:
fmt
:
:
Display
+
'
_
{
self
.
inner
.
to_string_lossy
(
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ShortFlags
<
'
s
>
{
inner
:
&
'
s
OsStr
utf8_prefix
:
std
:
:
str
:
:
CharIndices
<
'
s
>
invalid_suffix
:
Option
<
&
'
s
OsStr
>
}
impl
<
'
s
>
ShortFlags
<
'
s
>
{
fn
new
(
inner
:
&
'
s
OsStr
)
-
>
Self
{
let
(
utf8_prefix
invalid_suffix
)
=
split_nonutf8_once
(
inner
)
;
let
utf8_prefix
=
utf8_prefix
.
char_indices
(
)
;
Self
{
inner
utf8_prefix
invalid_suffix
}
}
pub
fn
advance_by
(
&
mut
self
n
:
usize
)
-
>
Result
<
(
)
usize
>
{
for
i
in
0
.
.
n
{
self
.
next
(
)
.
ok_or
(
i
)
?
.
map_err
(
|
_
|
i
)
?
;
}
Ok
(
(
)
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
invalid_suffix
.
is_none
(
)
&
&
self
.
utf8_prefix
.
as_str
(
)
.
is_empty
(
)
}
pub
fn
is_negative_number
(
&
self
)
-
>
bool
{
self
.
invalid_suffix
.
is_none
(
)
&
&
is_number
(
self
.
utf8_prefix
.
as_str
(
)
)
}
pub
fn
next_flag
(
&
mut
self
)
-
>
Option
<
Result
<
char
&
'
s
OsStr
>
>
{
if
let
Some
(
(
_
flag
)
)
=
self
.
utf8_prefix
.
next
(
)
{
return
Some
(
Ok
(
flag
)
)
;
}
if
let
Some
(
suffix
)
=
self
.
invalid_suffix
{
self
.
invalid_suffix
=
None
;
return
Some
(
Err
(
suffix
)
)
;
}
None
}
pub
fn
next_value_os
(
&
mut
self
)
-
>
Option
<
&
'
s
OsStr
>
{
if
let
Some
(
(
index
_
)
)
=
self
.
utf8_prefix
.
next
(
)
{
self
.
utf8_prefix
=
"
"
.
char_indices
(
)
;
self
.
invalid_suffix
=
None
;
let
remainder
=
unsafe
{
ext
:
:
split_at
(
self
.
inner
index
)
.
1
}
;
return
Some
(
remainder
)
;
}
if
let
Some
(
suffix
)
=
self
.
invalid_suffix
{
self
.
invalid_suffix
=
None
;
return
Some
(
suffix
)
;
}
None
}
}
impl
<
'
s
>
Iterator
for
ShortFlags
<
'
s
>
{
type
Item
=
Result
<
char
&
'
s
OsStr
>
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
next_flag
(
)
}
}
fn
split_nonutf8_once
(
b
:
&
OsStr
)
-
>
(
&
str
Option
<
&
OsStr
>
)
{
match
b
.
try_str
(
)
{
Ok
(
s
)
=
>
(
s
None
)
Err
(
err
)
=
>
{
let
(
valid
after_valid
)
=
unsafe
{
ext
:
:
split_at
(
b
err
.
valid_up_to
(
)
)
}
;
let
valid
=
valid
.
try_str
(
)
.
unwrap
(
)
;
(
valid
Some
(
after_valid
)
)
}
}
}
fn
is_number
(
arg
:
&
str
)
-
>
bool
{
let
mut
seen_dot
=
false
;
let
mut
position_of_e
=
None
;
for
(
i
c
)
in
arg
.
as_bytes
(
)
.
iter
(
)
.
enumerate
(
)
{
match
c
{
b
'
0
'
.
.
=
b
'
9
'
=
>
{
}
b
'
.
'
if
!
seen_dot
&
&
position_of_e
.
is_none
(
)
&
&
i
>
0
=
>
seen_dot
=
true
b
'
e
'
if
position_of_e
.
is_none
(
)
&
&
i
>
0
=
>
position_of_e
=
Some
(
i
)
_
=
>
return
false
}
}
match
position_of_e
{
Some
(
i
)
=
>
i
!
=
arg
.
len
(
)
-
1
None
=
>
true
}
}
