use
serde
:
:
{
Serialize
Deserialize
}
;
use
de
:
:
Deserializer
;
use
ser
:
:
Serializer
;
use
token
:
:
Token
;
use
std
:
:
fmt
:
:
Debug
;
pub
fn
assert_tokens
<
'
de
T
>
(
value
:
&
T
tokens
:
&
'
de
[
Token
]
)
where
T
:
Serialize
+
Deserialize
<
'
de
>
+
PartialEq
+
Debug
{
assert_ser_tokens
(
value
tokens
)
;
assert_de_tokens
(
value
tokens
)
;
}
pub
fn
assert_ser_tokens
<
T
>
(
value
:
&
T
tokens
:
&
[
Token
]
)
where
T
:
Serialize
{
let
mut
ser
=
Serializer
:
:
new
(
tokens
)
;
match
value
.
serialize
(
&
mut
ser
)
{
Ok
(
_
)
=
>
{
}
Err
(
err
)
=
>
panic
!
(
"
value
failed
to
serialize
:
{
}
"
err
)
}
if
ser
.
remaining
(
)
>
0
{
panic
!
(
"
{
}
remaining
tokens
"
ser
.
remaining
(
)
)
;
}
}
pub
fn
assert_ser_tokens_error
<
T
>
(
value
:
&
T
tokens
:
&
[
Token
]
error
:
&
str
)
where
T
:
Serialize
{
let
mut
ser
=
Serializer
:
:
new
(
tokens
)
;
match
value
.
serialize
(
&
mut
ser
)
{
Ok
(
_
)
=
>
panic
!
(
"
value
serialized
successfully
"
)
Err
(
e
)
=
>
assert_eq
!
(
e
*
error
)
}
if
ser
.
remaining
(
)
>
0
{
panic
!
(
"
{
}
remaining
tokens
"
ser
.
remaining
(
)
)
;
}
}
pub
fn
assert_de_tokens
<
'
de
T
>
(
value
:
&
T
tokens
:
&
'
de
[
Token
]
)
where
T
:
Deserialize
<
'
de
>
+
PartialEq
+
Debug
{
let
mut
de
=
Deserializer
:
:
new
(
tokens
)
;
match
T
:
:
deserialize
(
&
mut
de
)
{
Ok
(
v
)
=
>
assert_eq
!
(
v
*
value
)
Err
(
e
)
=
>
panic
!
(
"
tokens
failed
to
deserialize
:
{
}
"
e
)
}
if
de
.
remaining
(
)
>
0
{
panic
!
(
"
{
}
remaining
tokens
"
de
.
remaining
(
)
)
;
}
}
pub
fn
assert_de_tokens_error
<
'
de
T
>
(
tokens
:
&
'
de
[
Token
]
error
:
&
str
)
where
T
:
Deserialize
<
'
de
>
{
let
mut
de
=
Deserializer
:
:
new
(
tokens
)
;
match
T
:
:
deserialize
(
&
mut
de
)
{
Ok
(
_
)
=
>
panic
!
(
"
tokens
deserialized
successfully
"
)
Err
(
e
)
=
>
assert_eq
!
(
e
*
error
)
}
de
.
next_token_opt
(
)
;
if
de
.
remaining
(
)
>
0
{
panic
!
(
"
{
}
remaining
tokens
"
de
.
remaining
(
)
)
;
}
}
