#
!
[
cfg_attr
(
not
(
feature
=
"
std
"
)
no_std
)
]
#
!
[
warn
(
missing_debug_implementations
missing_docs
rust_2018_idioms
unreachable_pub
)
]
#
!
[
cfg_attr
(
test
warn
(
single_use_lifetimes
)
)
]
#
!
[
doc
(
test
(
no_crate_inject
attr
(
deny
(
warnings
rust_2018_idioms
single_use_lifetimes
)
allow
(
dead_code
unused_assignments
unused_variables
)
)
)
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
use
core
:
:
ops
:
:
DerefMut
;
use
core
:
:
pin
:
:
Pin
;
use
core
:
:
task
:
:
{
Context
Poll
}
;
#
[
must_use
=
"
sinks
do
nothing
unless
polled
"
]
pub
trait
Sink
<
Item
>
{
type
Error
;
fn
poll_ready
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
;
fn
start_send
(
self
:
Pin
<
&
mut
Self
>
item
:
Item
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
;
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
;
}
impl
<
S
:
?
Sized
+
Sink
<
Item
>
+
Unpin
Item
>
Sink
<
Item
>
for
&
mut
S
{
type
Error
=
S
:
:
Error
;
fn
poll_ready
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
poll_ready
(
cx
)
}
fn
start_send
(
mut
self
:
Pin
<
&
mut
Self
>
item
:
Item
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
start_send
(
item
)
}
fn
poll_flush
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
poll_flush
(
cx
)
}
fn
poll_close
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
poll_close
(
cx
)
}
}
impl
<
P
Item
>
Sink
<
Item
>
for
Pin
<
P
>
where
P
:
DerefMut
+
Unpin
P
:
:
Target
:
Sink
<
Item
>
{
type
Error
=
<
P
:
:
Target
as
Sink
<
Item
>
>
:
:
Error
;
fn
poll_ready
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
self
.
get_mut
(
)
.
as_mut
(
)
.
poll_ready
(
cx
)
}
fn
start_send
(
self
:
Pin
<
&
mut
Self
>
item
:
Item
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
get_mut
(
)
.
as_mut
(
)
.
start_send
(
item
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
self
.
get_mut
(
)
.
as_mut
(
)
.
poll_flush
(
cx
)
}
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
self
.
get_mut
(
)
.
as_mut
(
)
.
poll_close
(
cx
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
mod
if_alloc
{
use
super
:
:
*
;
use
core
:
:
convert
:
:
Infallible
as
Never
;
impl
<
T
>
Sink
<
T
>
for
alloc
:
:
vec
:
:
Vec
<
T
>
{
type
Error
=
Never
;
fn
poll_ready
(
self
:
Pin
<
&
mut
Self
>
_
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
fn
start_send
(
self
:
Pin
<
&
mut
Self
>
item
:
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
unsafe
{
self
.
get_unchecked_mut
(
)
}
.
push
(
item
)
;
Ok
(
(
)
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
_
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
_
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
}
impl
<
T
>
Sink
<
T
>
for
alloc
:
:
collections
:
:
VecDeque
<
T
>
{
type
Error
=
Never
;
fn
poll_ready
(
self
:
Pin
<
&
mut
Self
>
_
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
fn
start_send
(
self
:
Pin
<
&
mut
Self
>
item
:
T
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
unsafe
{
self
.
get_unchecked_mut
(
)
}
.
push_back
(
item
)
;
Ok
(
(
)
)
}
fn
poll_flush
(
self
:
Pin
<
&
mut
Self
>
_
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
fn
poll_close
(
self
:
Pin
<
&
mut
Self
>
_
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Poll
:
:
Ready
(
Ok
(
(
)
)
)
}
}
impl
<
S
:
?
Sized
+
Sink
<
Item
>
+
Unpin
Item
>
Sink
<
Item
>
for
alloc
:
:
boxed
:
:
Box
<
S
>
{
type
Error
=
S
:
:
Error
;
fn
poll_ready
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
poll_ready
(
cx
)
}
fn
start_send
(
mut
self
:
Pin
<
&
mut
Self
>
item
:
Item
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
start_send
(
item
)
}
fn
poll_flush
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
poll_flush
(
cx
)
}
fn
poll_close
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Result
<
(
)
Self
:
:
Error
>
>
{
Pin
:
:
new
(
&
mut
*
*
self
)
.
poll_close
(
cx
)
}
}
}
