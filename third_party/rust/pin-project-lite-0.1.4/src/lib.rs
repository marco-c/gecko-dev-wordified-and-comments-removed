#
!
[
no_std
]
#
!
[
recursion_limit
=
"
256
"
]
#
!
[
doc
(
html_root_url
=
"
https
:
/
/
docs
.
rs
/
pin
-
project
-
lite
/
0
.
1
.
4
"
)
]
#
!
[
doc
(
test
(
no_crate_inject
attr
(
deny
(
warnings
rust_2018_idioms
single_use_lifetimes
)
allow
(
dead_code
)
)
)
)
]
#
!
[
warn
(
unsafe_code
)
]
#
!
[
warn
(
rust_2018_idioms
single_use_lifetimes
unreachable_pub
)
]
#
!
[
warn
(
clippy
:
:
all
)
]
#
!
[
allow
(
clippy
:
:
mem_replace_with_default
)
]
#
[
macro_export
]
macro_rules
!
pin_project
{
(
(
#
[
attrs
:
meta
]
)
*
pub
struct
ident
:
ident
(
<
(
lifetime
:
lifetime
(
:
lifetime_bound
:
lifetime
)
?
)
*
(
)
?
(
generics
:
ident
(
:
generics_bound
:
path
)
?
(
:
?
generics_unsized_bound
:
path
)
?
(
:
generics_lifetime_bound
:
lifetime
)
?
(
=
generics_default
:
ty
)
?
)
*
(
)
?
>
)
?
(
where
(
where_clause_ty
:
ty
:
where_clause_bound
:
path
)
*
(
)
?
)
?
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
(
)
?
}
)
=
>
{
crate
:
:
pin_project
!
{
internal
(
pub
(
crate
)
)
(
#
[
attrs
]
)
*
pub
struct
ident
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
(
=
generics_default
)
?
)
*
>
)
?
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
?
{
(
(
#
[
pin
]
)
?
field_vis
field
:
field_ty
)
+
}
}
}
;
(
(
#
[
attrs
:
meta
]
)
*
vis
:
vis
struct
ident
:
ident
(
<
(
lifetime
:
lifetime
(
:
lifetime_bound
:
lifetime
)
?
)
*
(
)
?
(
generics
:
ident
(
:
generics_bound
:
path
)
?
(
:
?
generics_unsized_bound
:
path
)
?
(
:
generics_lifetime_bound
:
lifetime
)
?
(
=
generics_default
:
ty
)
?
)
*
(
)
?
>
)
?
(
where
(
where_clause_ty
:
ty
:
where_clause_bound
:
path
)
*
(
)
?
)
?
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
(
)
?
}
)
=
>
{
crate
:
:
pin_project
!
{
internal
(
vis
)
(
#
[
attrs
]
)
*
vis
struct
ident
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
(
=
generics_default
)
?
)
*
>
)
?
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
?
{
(
(
#
[
pin
]
)
?
field_vis
field
:
field_ty
)
+
}
}
}
;
(
internal
(
proj_vis
:
vis
)
(
#
[
attrs
:
meta
]
)
*
vis
:
vis
struct
ident
:
ident
(
<
(
lifetime
:
lifetime
(
:
lifetime_bound
:
lifetime
)
?
)
*
(
generics
:
ident
(
:
generics_bound
:
path
)
?
(
:
?
generics_unsized_bound
:
path
)
?
(
:
generics_lifetime_bound
:
lifetime
)
?
(
=
generics_default
:
ty
)
?
)
*
>
)
?
(
where
(
where_clause_ty
:
ty
:
where_clause_bound
:
path
)
*
)
?
{
(
(
#
[
pin
:
ident
]
)
?
field_vis
:
vis
field
:
ident
:
field_ty
:
ty
)
+
}
)
=
>
{
(
#
[
attrs
]
)
*
vis
struct
ident
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
(
=
generics_default
)
?
)
*
>
)
?
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
(
field_vis
field
:
field_ty
)
+
}
/
/
limitation
:
underscore_const_names
requires
rust
1
.
37
+
(
wontfix
)
const
_
:
(
)
=
{
#
[
allow
(
clippy
:
:
mut_mut
)
]
/
/
This
lint
warns
&
mut
&
mut
<
ty
>
.
#
[
allow
(
dead_code
)
]
/
/
This
lint
warns
unused
fields
/
variants
.
proj_vis
struct
Projection
<
'
__pin
(
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
)
?
>
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
(
field_vis
field
:
crate
:
:
pin_project
!
(
make_proj_field
(
#
[
pin
]
)
?
field_ty
;
mut
)
)
+
}
#
[
allow
(
dead_code
)
]
/
/
This
lint
warns
unused
fields
/
variants
.
proj_vis
struct
ProjectionRef
<
'
__pin
(
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
)
?
>
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
(
field_vis
field
:
crate
:
:
pin_project
!
(
make_proj_field
(
#
[
pin
]
)
?
field_ty
;
)
)
+
}
impl
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
>
)
?
ident
(
<
(
lifetime
)
*
(
generics
)
*
>
)
?
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
proj_vis
fn
project
<
'
__pin
>
(
self
:
:
:
core
:
:
pin
:
:
Pin
<
&
'
__pin
mut
Self
>
)
-
>
Projection
<
'
__pin
(
(
lifetime
)
*
(
generics
)
*
)
?
>
{
unsafe
{
let
this
=
self
.
get_unchecked_mut
(
)
;
Projection
{
(
field
:
crate
:
:
pin_project
!
(
make_unsafe_field_proj
this
;
(
#
[
pin
]
)
?
field
;
mut
)
)
+
}
}
}
proj_vis
fn
project_ref
<
'
__pin
>
(
self
:
:
:
core
:
:
pin
:
:
Pin
<
&
'
__pin
Self
>
)
-
>
ProjectionRef
<
'
__pin
(
(
lifetime
)
*
(
generics
)
*
)
?
>
{
unsafe
{
let
this
=
self
.
get_ref
(
)
;
ProjectionRef
{
(
field
:
crate
:
:
pin_project
!
(
make_unsafe_field_proj
this
;
(
#
[
pin
]
)
?
field
;
)
)
+
}
}
}
}
/
/
Automatically
create
the
appropriate
conditional
Unpin
implementation
.
/
/
/
/
Basically
this
is
equivalent
to
the
following
code
:
/
/
rust
/
/
impl
<
T
U
>
Unpin
for
Struct
<
T
U
>
where
T
:
Unpin
{
}
/
/
/
/
/
/
However
if
struct
is
public
and
there
is
a
private
type
field
/
/
this
would
cause
an
E0446
(
private
type
in
public
interface
)
.
/
/
/
/
When
RFC
2145
is
implemented
(
rust
-
lang
/
rust
#
48054
)
/
/
this
will
become
a
lint
rather
then
a
hard
error
.
/
/
/
/
As
a
workaround
for
this
we
generate
a
new
struct
containing
all
of
the
pinned
/
/
fields
from
our
#
[
pin_project
]
type
.
This
struct
is
delcared
within
/
/
a
function
which
makes
it
impossible
to
be
named
by
user
code
.
/
/
This
guarnatees
that
it
will
use
the
default
auto
-
trait
impl
for
Unpin
-
/
/
that
is
it
will
implement
Unpin
iff
all
of
its
fields
implement
Unpin
.
/
/
This
type
can
be
safely
declared
as
'
public
'
satisfiying
the
privacy
/
/
checker
without
actually
allowing
user
code
to
access
it
.
/
/
/
/
This
allows
users
to
apply
the
#
[
pin_project
]
attribute
to
types
/
/
regardless
of
the
privacy
of
the
types
of
their
fields
.
/
/
/
/
See
also
https
:
/
/
github
.
com
/
taiki
-
e
/
pin
-
project
/
pull
/
53
.
vis
struct
__Origin
<
'
__pin
(
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
)
?
>
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
__dummy_lifetime
:
:
:
core
:
:
marker
:
:
PhantomData
<
&
'
__pin
(
)
>
(
field
:
crate
:
:
pin_project
!
(
make_unpin_bound
(
#
[
pin
]
)
?
field_ty
)
)
+
}
impl
<
'
__pin
(
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
)
?
>
:
:
core
:
:
marker
:
:
Unpin
for
ident
(
<
(
lifetime
)
*
(
generics
)
*
>
)
?
where
__Origin
<
'
__pin
(
(
lifetime
)
*
(
generics
)
*
)
?
>
:
:
:
core
:
:
marker
:
:
Unpin
(
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
}
/
/
Ensure
that
struct
does
not
implement
Drop
.
/
/
/
/
There
are
two
possible
cases
:
/
/
1
.
The
user
type
does
not
implement
Drop
.
In
this
case
/
/
the
first
blanked
impl
will
not
apply
to
it
.
This
code
/
/
will
compile
as
there
is
only
one
impl
of
MustNotImplDrop
for
the
user
type
/
/
2
.
The
user
type
does
impl
Drop
.
This
will
make
the
blanket
impl
applicable
/
/
which
will
then
comflict
with
the
explicit
MustNotImplDrop
impl
below
.
/
/
This
will
result
in
a
compilation
error
which
is
exactly
what
we
want
.
trait
MustNotImplDrop
{
}
#
[
allow
(
clippy
:
:
drop_bounds
)
]
impl
<
T
:
:
:
core
:
:
ops
:
:
Drop
>
MustNotImplDrop
for
T
{
}
#
[
allow
(
single_use_lifetimes
)
]
impl
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
>
)
?
MustNotImplDrop
for
ident
(
<
(
lifetime
)
*
(
generics
)
*
>
)
?
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
}
/
/
Ensure
that
it
'
s
impossible
to
use
pin
projections
on
a
#
[
repr
(
packed
)
]
struct
.
/
/
/
/
Taking
a
reference
to
a
packed
field
is
unsafe
amd
appplying
/
/
#
[
deny
(
safe_packed_borrows
)
]
makes
sure
that
doing
this
without
/
/
an
'
unsafe
'
block
(
which
we
deliberately
do
not
generate
)
/
/
is
a
hard
error
.
/
/
/
/
If
the
struct
ends
up
having
#
[
repr
(
packed
)
]
applied
somehow
/
/
this
will
generate
an
(
unfriendly
)
error
message
.
Under
all
reasonable
/
/
circumstances
we
'
ll
detect
the
#
[
repr
(
packed
)
]
attribute
and
generate
/
/
a
much
nicer
error
above
.
/
/
/
/
See
https
:
/
/
github
.
com
/
taiki
-
e
/
pin
-
project
/
pull
/
34
for
more
details
.
#
[
allow
(
single_use_lifetimes
)
]
#
[
allow
(
non_snake_case
)
]
#
[
deny
(
safe_packed_borrows
)
]
fn
__assert_not_repr_packed
(
<
(
lifetime
(
:
lifetime_bound
)
?
)
*
(
generics
(
:
generics_bound
)
?
(
:
?
generics_unsized_bound
)
?
(
:
generics_lifetime_bound
)
?
)
*
>
)
?
(
this
:
&
ident
(
<
(
lifetime
)
*
(
generics
)
*
>
)
?
)
(
where
(
where_clause_ty
:
where_clause_bound
)
*
)
*
{
(
&
this
.
field
;
)
+
}
}
;
}
;
(
make_unpin_bound
#
[
pin
]
field_ty
:
ty
)
=
>
{
field_ty
}
;
(
make_unpin_bound
field_ty
:
ty
)
=
>
{
crate
:
:
__private
:
:
AlwaysUnpin
<
field_ty
>
}
;
(
make_unsafe_field_proj
this
:
ident
;
#
[
pin
]
field
:
ident
;
(
mut
:
ident
)
?
)
=
>
{
:
:
core
:
:
pin
:
:
Pin
:
:
new_unchecked
(
&
(
mut
)
?
this
.
field
)
}
;
(
make_unsafe_field_proj
this
:
ident
;
field
:
ident
;
(
mut
:
ident
)
?
)
=
>
{
&
(
mut
)
?
this
.
field
}
;
(
make_proj_field
#
[
pin
]
field_ty
:
ty
;
(
mut
:
ident
)
?
)
=
>
{
:
:
core
:
:
pin
:
:
Pin
<
&
'
__pin
(
mut
)
?
(
field_ty
)
>
}
;
(
make_proj_field
field_ty
:
ty
;
(
mut
:
ident
)
?
)
=
>
{
&
'
__pin
(
mut
)
?
(
field_ty
)
}
;
}
#
[
doc
(
hidden
)
]
pub
mod
__private
{
use
core
:
:
marker
:
:
PhantomData
;
#
[
doc
(
hidden
)
]
pub
struct
AlwaysUnpin
<
T
:
?
Sized
>
(
PhantomData
<
T
>
)
;
impl
<
T
:
?
Sized
>
Unpin
for
AlwaysUnpin
<
T
>
{
}
}
