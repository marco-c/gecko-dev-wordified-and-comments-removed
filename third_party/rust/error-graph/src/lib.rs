use
{
std
:
:
{
error
:
:
Error
fmt
:
:
{
self
Debug
Display
Formatter
}
}
strategy
:
:
*
}
;
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
pub
mod
strategy
;
pub
trait
WriteErrorList
<
E
>
:
Sized
+
private
:
:
Sealed
<
E
>
{
fn
push
(
&
mut
self
error
:
E
)
;
fn
subwriter
<
'
sub
SubMapFn
SubErr
:
'
sub
>
(
&
'
sub
mut
self
map_fn
:
SubMapFn
)
-
>
impl
WriteErrorList
<
SubErr
>
+
'
sub
where
SubMapFn
:
FnOnce
(
ErrorList
<
SubErr
>
)
-
>
E
+
'
sub
;
fn
sublist
<
SubMapFn
SubErr
>
(
&
mut
self
map_fn
:
SubMapFn
)
-
>
Sublist
<
'
_
SubErr
SubMapFn
Self
E
>
where
SubMapFn
:
FnOnce
(
ErrorList
<
SubErr
>
)
-
>
E
{
Sublist
:
:
new
(
map_fn
self
)
}
fn
finish
(
self
)
{
drop
(
self
)
}
}
impl
<
E
T
:
WriteErrorList
<
E
>
>
private
:
:
Sealed
<
E
>
for
&
mut
T
{
}
impl
<
E
T
:
WriteErrorList
<
E
>
>
WriteErrorList
<
E
>
for
&
mut
T
{
fn
push
(
&
mut
self
error
:
E
)
{
WriteErrorList
:
:
push
(
*
self
error
)
}
fn
subwriter
<
'
sub
SubMapFn
SubErr
:
'
sub
>
(
&
'
sub
mut
self
map_fn
:
SubMapFn
)
-
>
impl
WriteErrorList
<
SubErr
>
+
'
sub
where
SubMapFn
:
FnOnce
(
ErrorList
<
SubErr
>
)
-
>
E
+
'
sub
{
WriteErrorList
:
:
subwriter
(
*
self
map_fn
)
}
}
#
[
derive
(
Debug
Eq
Hash
PartialEq
)
]
pub
struct
ErrorList
<
E
>
{
errors
:
Vec
<
E
>
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
E
:
Serialize
>
Serialize
for
ErrorList
<
E
>
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
Serialize
:
:
serialize
(
&
self
.
errors
serializer
)
}
}
#
[
cfg
(
feature
=
"
serde
"
)
]
impl
<
'
de
E
:
Deserialize
<
'
de
>
>
Deserialize
<
'
de
>
for
ErrorList
<
E
>
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
Ok
(
ErrorList
{
errors
:
Deserialize
:
:
deserialize
(
deserializer
)
?
}
)
}
}
impl
<
E
>
ErrorList
<
E
>
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
errors
.
is_empty
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
errors
.
len
(
)
}
pub
fn
iter
<
'
a
>
(
&
'
a
self
)
-
>
impl
Iterator
<
Item
=
&
'
a
E
>
where
E
:
'
a
{
self
.
errors
.
iter
(
)
}
pub
fn
iter_mut
<
'
a
>
(
&
'
a
mut
self
)
-
>
impl
Iterator
<
Item
=
&
'
a
mut
E
>
where
E
:
'
a
{
self
.
errors
.
iter_mut
(
)
}
}
impl
<
E
>
private
:
:
Sealed
<
E
>
for
ErrorList
<
E
>
{
}
impl
<
E
>
WriteErrorList
<
E
>
for
ErrorList
<
E
>
{
fn
push
(
&
mut
self
error
:
E
)
{
self
.
errors
.
push
(
error
)
;
}
fn
subwriter
<
'
sub
SubMapFn
SubErr
:
'
sub
>
(
&
'
sub
mut
self
map_fn
:
SubMapFn
)
-
>
impl
WriteErrorList
<
SubErr
>
+
'
sub
where
SubMapFn
:
FnOnce
(
ErrorList
<
SubErr
>
)
-
>
E
+
'
sub
{
self
.
sublist
(
map_fn
)
}
}
impl
<
E
>
Default
for
ErrorList
<
E
>
{
fn
default
(
)
-
>
Self
{
Self
{
errors
:
Vec
:
:
new
(
)
}
}
}
impl
<
E
:
Error
>
Display
for
ErrorList
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
one
or
more
errors
occurred
:
"
)
?
;
writeln
!
(
f
)
?
;
for
(
i
e
)
in
self
.
errors
.
iter
(
)
.
enumerate
(
)
{
writeln
!
(
f
"
{
i
}
:
"
)
?
;
for
line
in
e
.
to_string
(
)
.
lines
(
)
{
writeln
!
(
f
"
{
line
}
"
)
?
;
}
writeln
!
(
f
)
?
;
let
mut
source
=
e
.
source
(
)
;
while
let
Some
(
e
)
=
source
{
writeln
!
(
f
"
caused
by
:
"
)
?
;
for
line
in
e
.
to_string
(
)
.
lines
(
)
{
writeln
!
(
f
"
{
line
}
"
)
?
;
}
writeln
!
(
f
)
?
;
source
=
e
.
source
(
)
;
}
}
Ok
(
(
)
)
}
}
impl
<
E
:
Error
>
Error
for
ErrorList
<
E
>
{
}
impl
<
E
>
IntoIterator
for
ErrorList
<
E
>
{
type
Item
=
<
Vec
<
E
>
as
IntoIterator
>
:
:
Item
;
type
IntoIter
=
<
Vec
<
E
>
as
IntoIterator
>
:
:
IntoIter
;
fn
into_iter
(
self
)
-
>
Self
:
:
IntoIter
{
self
.
errors
.
into_iter
(
)
}
}
mod
private
{
pub
trait
Sealed
<
E
>
{
}
}
