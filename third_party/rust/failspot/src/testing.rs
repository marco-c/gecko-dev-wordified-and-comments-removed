use
{
flagset
:
:
FlagSet
std
:
:
{
ops
:
:
{
Deref
DerefMut
}
sync
:
:
{
Mutex
MutexGuard
RwLock
}
}
}
;
#
[
derive
(
Debug
)
]
pub
struct
Config
<
T
:
flagset
:
:
Flags
>
{
inner
:
RwLock
<
ConfigInner
<
T
>
>
client_mutex
:
Mutex
<
(
)
>
}
#
[
derive
(
Debug
Eq
PartialEq
)
]
struct
ConfigInner
<
T
:
flagset
:
:
Flags
>
{
enabled_spots
:
FlagSet
<
T
>
}
impl
<
T
:
flagset
:
:
Flags
>
Default
for
Config
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
{
inner
:
Default
:
:
default
(
)
client_mutex
:
Default
:
:
default
(
)
}
}
}
impl
<
T
:
flagset
:
:
Flags
>
Default
for
ConfigInner
<
T
>
{
fn
default
(
)
-
>
Self
{
Self
{
enabled_spots
:
Default
:
:
default
(
)
}
}
}
impl
<
T
:
flagset
:
:
Flags
>
Config
<
T
>
{
pub
fn
enabled
(
&
self
spot
:
T
)
-
>
bool
{
self
.
inner
(
)
.
enabled_spots
.
contains
(
spot
)
}
pub
fn
client
(
&
self
)
-
>
Client
<
'
_
T
>
{
Client
:
:
new
(
self
)
}
fn
inner
(
&
self
)
-
>
impl
Deref
<
Target
=
ConfigInner
<
T
>
>
+
'
_
{
self
.
inner
.
read
(
)
.
unwrap
(
)
}
fn
inner_mut
(
&
self
)
-
>
impl
DerefMut
<
Target
=
ConfigInner
<
T
>
>
+
'
_
{
self
.
inner
.
write
(
)
.
unwrap
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
Client
<
'
a
T
:
flagset
:
:
Flags
>
{
config
:
&
'
a
Config
<
T
>
_guard
:
MutexGuard
<
'
a
(
)
>
}
impl
<
'
a
T
:
flagset
:
:
Flags
>
Client
<
'
a
T
>
{
pub
fn
new
(
config
:
&
'
a
Config
<
T
>
)
-
>
Self
{
let
_guard
=
config
.
client_mutex
.
lock
(
)
.
unwrap_or_else
(
|
e
|
e
.
into_inner
(
)
)
;
assert_eq
!
(
*
config
.
inner
(
)
ConfigInner
:
:
default
(
)
"
somehow
failed
to
reset
config
to
default
after
last
client
"
)
;
Client
{
config
_guard
}
}
pub
fn
set_enabled
(
&
mut
self
spot
:
T
enabled
:
bool
)
-
>
&
mut
Self
{
if
enabled
{
self
.
config
.
inner_mut
(
)
.
enabled_spots
|
=
spot
;
}
else
{
self
.
config
.
inner_mut
(
)
.
enabled_spots
-
=
spot
;
}
self
}
pub
fn
reset
(
&
mut
self
)
-
>
&
mut
Self
{
*
self
.
config
.
inner_mut
(
)
=
ConfigInner
:
:
default
(
)
;
self
}
pub
fn
finish
(
self
)
{
drop
(
self
)
}
}
impl
<
'
a
T
:
flagset
:
:
Flags
>
Drop
for
Client
<
'
a
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
reset
(
)
;
}
}
