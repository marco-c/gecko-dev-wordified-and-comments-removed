use
std
:
:
collections
:
:
{
BTreeMap
HashSet
}
;
use
std
:
:
fs
;
use
std
:
:
io
:
:
Write
;
use
std
:
:
path
;
use
error
;
static
SHIFTWIDTH
:
usize
=
4
;
struct
_IndentedScope
{
fmt
:
Formatter
after
:
Option
<
String
>
}
impl
_IndentedScope
{
fn
_enter
(
&
mut
self
)
{
self
.
fmt
.
_indent_push
(
)
;
}
fn
_exit
(
&
mut
self
)
{
self
.
fmt
.
_indent_pop
(
)
;
if
let
Some
(
ref
s
)
=
self
.
after
{
self
.
fmt
.
line
(
&
s
)
;
}
}
}
pub
struct
Formatter
{
indent
:
usize
lines
:
Vec
<
String
>
}
impl
Formatter
{
pub
fn
new
(
)
-
>
Formatter
{
Formatter
{
indent
:
0
lines
:
Vec
:
:
new
(
)
}
}
pub
fn
_indent_push
(
&
mut
self
)
{
self
.
indent
+
=
1
;
}
pub
fn
_indent_pop
(
&
mut
self
)
{
assert
!
(
self
.
indent
>
0
"
Already
at
top
level
indentation
"
)
;
self
.
indent
-
=
1
;
}
fn
get_indent
(
&
self
)
-
>
String
{
if
self
.
indent
=
=
0
{
String
:
:
new
(
)
}
else
{
format
!
(
"
{
:
-
1
}
"
"
"
self
.
indent
*
SHIFTWIDTH
)
}
}
fn
_get_outdent
(
&
mut
self
)
-
>
String
{
self
.
_indent_push
(
)
;
let
s
=
self
.
get_indent
(
)
;
self
.
_indent_pop
(
)
;
s
}
pub
fn
line
(
&
mut
self
contents
:
&
str
)
{
let
indented_line
=
format
!
(
"
{
}
{
}
\
n
"
self
.
get_indent
(
)
contents
)
;
self
.
lines
.
push
(
indented_line
)
;
}
pub
fn
_outdented_line
(
&
mut
self
s
:
&
str
)
{
let
new_line
=
format
!
(
"
{
}
{
}
"
self
.
_get_outdent
(
)
s
)
;
self
.
lines
.
push
(
new_line
)
;
}
pub
fn
update_file
(
&
self
filename
:
&
str
directory
:
&
str
)
-
>
Result
<
(
)
error
:
:
Error
>
{
#
[
cfg
(
target_family
=
"
windows
"
)
]
let
path_str
=
format
!
(
"
{
}
\
\
{
}
"
directory
filename
)
;
#
[
cfg
(
not
(
target_family
=
"
windows
"
)
)
]
let
path_str
=
format
!
(
"
{
}
/
{
}
"
directory
filename
)
;
let
path
=
path
:
:
Path
:
:
new
(
&
path_str
)
;
let
mut
f
=
fs
:
:
File
:
:
create
(
path
)
?
;
for
l
in
self
.
lines
.
iter
(
)
.
map
(
|
l
|
l
.
as_bytes
(
)
)
{
f
.
write_all
(
l
)
?
;
}
Ok
(
(
)
)
}
fn
_indented
(
&
self
_before
:
Option
<
&
str
>
_after
:
Option
<
&
str
>
)
-
>
_IndentedScope
{
unimplemented
!
(
)
;
}
pub
fn
_multi_line
(
&
mut
self
s
:
&
str
)
{
parse_multiline
(
s
)
.
into_iter
(
)
.
for_each
(
|
l
|
self
.
line
(
&
l
)
)
;
}
pub
fn
_comment
(
&
mut
self
s
:
&
str
)
{
let
commented_line
=
format
!
(
"
/
/
{
}
"
s
)
;
self
.
line
(
&
commented_line
)
;
}
pub
fn
doc_comment
(
&
mut
self
contents
:
&
str
)
{
parse_multiline
(
contents
)
.
iter
(
)
.
map
(
|
l
|
format
!
(
"
/
/
/
{
}
"
l
)
)
.
for_each
(
|
s
|
self
.
line
(
s
.
as_str
(
)
)
)
;
}
fn
_add_match
(
&
mut
self
_m
:
&
_Match
)
{
unimplemented
!
(
)
;
}
}
fn
_indent
(
s
:
&
str
)
-
>
Option
<
usize
>
{
if
s
.
is_empty
(
)
{
None
}
else
{
let
t
=
s
.
trim_left
(
)
;
Some
(
s
.
len
(
)
-
t
.
len
(
)
)
}
}
fn
parse_multiline
(
s
:
&
str
)
-
>
Vec
<
String
>
{
let
expanded_tab
=
format
!
(
"
{
:
-
1
}
"
"
"
SHIFTWIDTH
)
;
let
lines
:
Vec
<
String
>
=
s
.
lines
(
)
.
map
(
|
l
|
l
.
replace
(
"
\
t
"
&
expanded_tab
)
)
.
collect
(
)
;
let
indent
=
lines
.
iter
(
)
.
skip
(
1
)
.
map
(
|
l
|
l
.
len
(
)
-
l
.
trim_left
(
)
.
len
(
)
)
.
filter
(
|
&
i
|
i
>
0
)
.
min
(
)
;
let
mut
lines_iter
=
lines
.
iter
(
)
.
skip_while
(
|
l
|
l
.
is_empty
(
)
)
;
let
mut
trimmed
=
Vec
:
:
with_capacity
(
lines
.
len
(
)
)
;
if
let
Some
(
s
)
=
lines_iter
.
next
(
)
.
map
(
|
l
|
l
.
trim
(
)
)
.
map
(
|
l
|
l
.
to_string
(
)
)
{
trimmed
.
push
(
s
)
;
}
let
mut
other_lines
=
if
let
Some
(
indent
)
=
indent
{
lines_iter
.
map
(
|
l
|
&
l
[
indent
.
.
]
)
.
map
(
|
l
|
l
.
trim_right
(
)
)
.
map
(
|
l
|
l
.
to_string
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
else
{
lines_iter
.
map
(
|
l
|
l
.
trim_right
(
)
)
.
map
(
|
l
|
l
.
to_string
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
;
trimmed
.
append
(
&
mut
other_lines
)
;
while
let
Some
(
s
)
=
trimmed
.
pop
(
)
{
if
s
.
is_empty
(
)
{
continue
;
}
else
{
trimmed
.
push
(
s
)
;
break
;
}
}
trimmed
}
struct
_Match
<
'
a
>
{
_expr
:
&
'
a
str
arms
:
BTreeMap
<
(
Vec
<
&
'
a
str
>
&
'
a
str
)
HashSet
<
&
'
a
str
>
>
}
impl
<
'
a
>
_Match
<
'
a
>
{
fn
_new
(
expr
:
&
'
a
str
)
-
>
Self
{
Self
{
_expr
:
expr
arms
:
BTreeMap
:
:
new
(
)
}
}
fn
_arm
(
&
mut
self
name
:
&
'
a
str
fields
:
Vec
<
&
'
a
str
>
body
:
&
'
a
str
)
{
let
match_arm
=
self
.
arms
.
entry
(
(
fields
body
)
)
.
or_insert_with
(
HashSet
:
:
new
)
;
match_arm
.
insert
(
name
)
;
}
}
#
[
cfg
(
test
)
]
mod
srcgen_tests
{
use
super
:
:
_Match
;
use
super
:
:
parse_multiline
;
use
super
:
:
Formatter
;
#
[
test
]
fn
adding_arms_works
(
)
{
let
mut
m
=
_Match
:
:
_new
(
"
x
"
)
;
m
.
_arm
(
"
Orange
"
vec
!
[
"
a
"
"
b
"
]
"
some
body
"
)
;
m
.
_arm
(
"
Yellow
"
vec
!
[
"
a
"
"
b
"
]
"
some
body
"
)
;
m
.
_arm
(
"
Green
"
vec
!
[
"
a
"
"
b
"
]
"
different
body
"
)
;
m
.
_arm
(
"
Blue
"
vec
!
[
"
x
"
"
y
"
]
"
some
body
"
)
;
assert_eq
!
(
m
.
arms
.
len
(
)
3
)
;
}
#
[
test
]
fn
parse_multiline_works
(
)
{
let
input
=
"
\
n
hello
\
n
world
\
n
"
;
let
expected
=
vec
!
[
"
hello
"
"
world
"
]
;
let
output
=
parse_multiline
(
input
)
;
assert_eq
!
(
output
expected
)
;
}
#
[
test
]
fn
formatter_basic_example_works
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
line
(
"
Hello
line
1
"
)
;
fmt
.
_indent_push
(
)
;
fmt
.
_comment
(
"
Nested
comment
"
)
;
fmt
.
_indent_pop
(
)
;
fmt
.
line
(
"
Back
home
again
"
)
;
let
expected_lines
=
vec
!
[
"
Hello
line
1
\
n
"
"
/
/
Nested
comment
\
n
"
"
Back
home
again
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
get_indent_works
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
let
expected_results
=
vec
!
[
"
"
"
"
"
"
"
"
]
;
let
actual_results
=
Vec
:
:
with_capacity
(
4
)
;
(
0
.
.
3
)
.
for_each
(
|
_
|
{
fmt
.
get_indent
(
)
;
fmt
.
_indent_push
(
)
;
}
)
;
(
0
.
.
3
)
.
for_each
(
|
_
|
fmt
.
_indent_pop
(
)
)
;
fmt
.
get_indent
(
)
;
actual_results
.
into_iter
(
)
.
zip
(
expected_results
.
into_iter
(
)
)
.
for_each
(
|
(
actual
expected
)
:
(
String
&
str
)
|
assert_eq
!
(
&
actual
expected
)
)
;
}
#
[
test
]
fn
fmt_can_add_type_to_lines
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
line
(
&
format
!
(
"
pub
const
{
}
:
Type
=
Type
(
{
:
#
x
}
)
;
"
"
example
"
0
)
)
;
let
expected_lines
=
vec
!
[
"
pub
const
example
:
Type
=
Type
(
0x0
)
;
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
fmt_can_add_indented_line
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
line
(
"
hello
"
)
;
fmt
.
_indent_push
(
)
;
fmt
.
line
(
"
world
"
)
;
let
expected_lines
=
vec
!
[
"
hello
\
n
"
"
world
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
fmt_can_add_doc_comments
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
doc_comment
(
"
documentation
\
nis
\
ngood
"
)
;
let
expected_lines
=
vec
!
[
"
/
/
/
documentation
\
n
"
"
/
/
/
is
\
n
"
"
/
/
/
good
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
}
