#
!
[
macro_use
]
use
std
:
:
cmp
;
use
std
:
:
collections
:
:
{
BTreeMap
BTreeSet
}
;
use
std
:
:
fs
;
use
std
:
:
io
:
:
Write
;
use
std
:
:
path
;
use
crate
:
:
error
;
static
SHIFTWIDTH
:
usize
=
4
;
macro_rules
!
fmtln
{
(
fmt
:
ident
fmtstring
:
expr
(
fmtargs
:
expr
)
*
)
=
>
{
fmt
.
line
(
format
!
(
fmtstring
(
fmtargs
)
*
)
)
;
}
;
(
fmt
:
ident
arg
:
expr
)
=
>
{
fmt
.
line
(
arg
)
;
}
;
(
_
:
tt
(
args
:
expr
)
+
)
=
>
{
compile_error
!
(
"
This
macro
requires
at
least
two
arguments
:
the
Formatter
instance
and
a
format
string
.
"
)
;
}
;
(
_
:
tt
)
=
>
{
compile_error
!
(
"
This
macro
requires
at
least
two
arguments
:
the
Formatter
instance
and
a
format
string
.
"
)
;
}
;
}
pub
(
crate
)
struct
Formatter
{
indent
:
usize
lines
:
Vec
<
String
>
}
impl
Formatter
{
pub
fn
new
(
)
-
>
Self
{
Self
{
indent
:
0
lines
:
Vec
:
:
new
(
)
}
}
pub
fn
indent_push
(
&
mut
self
)
{
self
.
indent
+
=
1
;
}
pub
fn
indent_pop
(
&
mut
self
)
{
assert
!
(
self
.
indent
>
0
"
Already
at
top
level
indentation
"
)
;
self
.
indent
-
=
1
;
}
pub
fn
indent
<
T
F
:
FnOnce
(
&
mut
Formatter
)
-
>
T
>
(
&
mut
self
f
:
F
)
-
>
T
{
self
.
indent_push
(
)
;
let
ret
=
f
(
self
)
;
self
.
indent_pop
(
)
;
ret
}
fn
get_indent
(
&
self
)
-
>
String
{
if
self
.
indent
=
=
0
{
String
:
:
new
(
)
}
else
{
format
!
(
"
{
:
-
1
}
"
"
"
self
.
indent
*
SHIFTWIDTH
)
}
}
fn
get_outdent
(
&
mut
self
)
-
>
String
{
self
.
indent_pop
(
)
;
let
s
=
self
.
get_indent
(
)
;
self
.
indent_push
(
)
;
s
}
pub
fn
line
(
&
mut
self
contents
:
impl
AsRef
<
str
>
)
{
let
indented_line
=
format
!
(
"
{
}
{
}
\
n
"
self
.
get_indent
(
)
contents
.
as_ref
(
)
)
;
self
.
lines
.
push
(
indented_line
)
;
}
pub
fn
empty_line
(
&
mut
self
)
{
self
.
lines
.
push
(
"
\
n
"
.
to_string
(
)
)
;
}
pub
fn
outdented_line
(
&
mut
self
s
:
&
str
)
{
let
new_line
=
format
!
(
"
{
}
{
}
\
n
"
self
.
get_outdent
(
)
s
)
;
self
.
lines
.
push
(
new_line
)
;
}
pub
fn
update_file
(
&
self
filename
:
impl
AsRef
<
str
>
directory
:
&
str
)
-
>
Result
<
(
)
error
:
:
Error
>
{
#
[
cfg
(
target_family
=
"
windows
"
)
]
let
path_str
=
format
!
(
"
{
}
\
\
{
}
"
directory
filename
.
as_ref
(
)
)
;
#
[
cfg
(
not
(
target_family
=
"
windows
"
)
)
]
let
path_str
=
format
!
(
"
{
}
/
{
}
"
directory
filename
.
as_ref
(
)
)
;
let
path
=
path
:
:
Path
:
:
new
(
&
path_str
)
;
let
mut
f
=
fs
:
:
File
:
:
create
(
path
)
?
;
for
l
in
self
.
lines
.
iter
(
)
.
map
(
|
l
|
l
.
as_bytes
(
)
)
{
f
.
write_all
(
l
)
?
;
}
Ok
(
(
)
)
}
pub
fn
multi_line
(
&
mut
self
s
:
&
str
)
{
parse_multiline
(
s
)
.
into_iter
(
)
.
for_each
(
|
l
|
self
.
line
(
&
l
)
)
;
}
pub
fn
comment
(
&
mut
self
s
:
impl
AsRef
<
str
>
)
{
fmtln
!
(
self
"
/
/
{
}
"
s
.
as_ref
(
)
)
;
}
pub
fn
doc_comment
(
&
mut
self
contents
:
impl
AsRef
<
str
>
)
{
parse_multiline
(
contents
.
as_ref
(
)
)
.
iter
(
)
.
map
(
|
l
|
{
if
l
.
is_empty
(
)
{
"
/
/
/
"
.
into
(
)
}
else
{
format
!
(
"
/
/
/
{
}
"
l
)
}
}
)
.
for_each
(
|
s
|
self
.
line
(
s
.
as_str
(
)
)
)
;
}
pub
fn
add_match
(
&
mut
self
m
:
Match
)
{
fmtln
!
(
self
"
match
{
}
{
{
"
m
.
expr
)
;
self
.
indent
(
|
fmt
|
{
for
(
&
(
ref
fields
ref
body
)
ref
names
)
in
m
.
arms
.
iter
(
)
{
let
conditions
=
names
.
iter
(
)
.
map
(
|
name
|
{
if
!
fields
.
is_empty
(
)
{
format
!
(
"
{
}
{
{
{
}
}
}
"
name
fields
.
join
(
"
"
)
)
}
else
{
name
.
clone
(
)
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
|
\
n
"
)
+
"
=
>
{
"
;
fmt
.
multi_line
(
&
conditions
)
;
fmt
.
indent
(
|
fmt
|
{
fmt
.
line
(
body
)
;
}
)
;
fmt
.
line
(
"
}
"
)
;
}
if
let
Some
(
body
)
=
m
.
catch_all
{
fmt
.
line
(
"
_
=
>
{
"
)
;
fmt
.
indent
(
|
fmt
|
{
fmt
.
line
(
body
)
;
}
)
;
fmt
.
line
(
"
}
"
)
;
}
}
)
;
self
.
line
(
"
}
"
)
;
}
}
fn
_indent
(
s
:
&
str
)
-
>
Option
<
usize
>
{
if
s
.
is_empty
(
)
{
None
}
else
{
let
t
=
s
.
trim_start
(
)
;
Some
(
s
.
len
(
)
-
t
.
len
(
)
)
}
}
fn
parse_multiline
(
s
:
&
str
)
-
>
Vec
<
String
>
{
let
expanded_tab
=
format
!
(
"
{
:
-
1
}
"
"
"
SHIFTWIDTH
)
;
let
lines
:
Vec
<
String
>
=
s
.
lines
(
)
.
map
(
|
l
|
l
.
replace
(
"
\
t
"
&
expanded_tab
)
)
.
collect
(
)
;
let
indent
=
lines
.
iter
(
)
.
skip
(
1
)
.
filter
(
|
l
|
!
l
.
trim
(
)
.
is_empty
(
)
)
.
map
(
|
l
|
l
.
len
(
)
-
l
.
trim_start
(
)
.
len
(
)
)
.
min
(
)
;
let
mut
lines_iter
=
lines
.
iter
(
)
.
skip_while
(
|
l
|
l
.
is_empty
(
)
)
;
let
mut
trimmed
=
Vec
:
:
with_capacity
(
lines
.
len
(
)
)
;
if
let
Some
(
s
)
=
lines_iter
.
next
(
)
.
map
(
|
l
|
l
.
trim
(
)
)
.
map
(
|
l
|
l
.
to_string
(
)
)
{
trimmed
.
push
(
s
)
;
}
let
mut
other_lines
=
if
let
Some
(
indent
)
=
indent
{
lines_iter
.
map
(
|
l
|
&
l
[
cmp
:
:
min
(
indent
l
.
len
(
)
)
.
.
]
)
.
map
(
|
l
|
l
.
trim_end
(
)
)
.
map
(
|
l
|
l
.
to_string
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
else
{
lines_iter
.
map
(
|
l
|
l
.
trim_end
(
)
)
.
map
(
|
l
|
l
.
to_string
(
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
}
;
trimmed
.
append
(
&
mut
other_lines
)
;
while
let
Some
(
s
)
=
trimmed
.
pop
(
)
{
if
s
.
is_empty
(
)
{
continue
;
}
else
{
trimmed
.
push
(
s
)
;
break
;
}
}
trimmed
}
pub
(
crate
)
struct
Match
{
expr
:
String
arms
:
BTreeMap
<
(
Vec
<
String
>
String
)
BTreeSet
<
String
>
>
catch_all
:
Option
<
String
>
}
impl
Match
{
pub
fn
new
(
expr
:
impl
Into
<
String
>
)
-
>
Self
{
Self
{
expr
:
expr
.
into
(
)
arms
:
BTreeMap
:
:
new
(
)
catch_all
:
None
}
}
fn
set_catch_all
(
&
mut
self
clause
:
String
)
{
assert
!
(
self
.
catch_all
.
is_none
(
)
)
;
self
.
catch_all
=
Some
(
clause
)
;
}
pub
fn
arm
<
T
:
Into
<
String
>
S
:
Into
<
String
>
>
(
&
mut
self
name
:
T
fields
:
Vec
<
S
>
body
:
T
)
{
let
name
=
name
.
into
(
)
;
assert
!
(
name
!
=
"
_
"
"
catch
all
clause
can
'
t
extract
fields
use
arm_no_fields
instead
.
"
)
;
let
body
=
body
.
into
(
)
;
let
fields
=
fields
.
into_iter
(
)
.
map
(
|
x
|
x
.
into
(
)
)
.
collect
(
)
;
let
match_arm
=
self
.
arms
.
entry
(
(
fields
body
)
)
.
or_insert_with
(
BTreeSet
:
:
new
)
;
match_arm
.
insert
(
name
)
;
}
pub
fn
arm_no_fields
(
&
mut
self
name
:
impl
Into
<
String
>
body
:
impl
Into
<
String
>
)
{
let
body
=
body
.
into
(
)
;
let
name
=
name
.
into
(
)
;
if
name
=
=
"
_
"
{
self
.
set_catch_all
(
body
)
;
return
;
}
let
match_arm
=
self
.
arms
.
entry
(
(
Vec
:
:
new
(
)
body
)
)
.
or_insert_with
(
BTreeSet
:
:
new
)
;
match_arm
.
insert
(
name
)
;
}
}
#
[
cfg
(
test
)
]
mod
srcgen_tests
{
use
super
:
:
parse_multiline
;
use
super
:
:
Formatter
;
use
super
:
:
Match
;
fn
from_raw_string
<
S
:
Into
<
String
>
>
(
s
:
S
)
-
>
Vec
<
String
>
{
s
.
into
(
)
.
trim
(
)
.
split
(
"
\
n
"
)
.
into_iter
(
)
.
map
(
|
x
|
format
!
(
"
{
}
\
n
"
x
)
)
.
collect
(
)
}
#
[
test
]
fn
adding_arms_works
(
)
{
let
mut
m
=
Match
:
:
new
(
"
x
"
)
;
m
.
arm
(
"
Orange
"
vec
!
[
"
a
"
"
b
"
]
"
some
body
"
)
;
m
.
arm
(
"
Yellow
"
vec
!
[
"
a
"
"
b
"
]
"
some
body
"
)
;
m
.
arm
(
"
Green
"
vec
!
[
"
a
"
"
b
"
]
"
different
body
"
)
;
m
.
arm
(
"
Blue
"
vec
!
[
"
x
"
"
y
"
]
"
some
body
"
)
;
assert_eq
!
(
m
.
arms
.
len
(
)
3
)
;
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
add_match
(
m
)
;
let
expected_lines
=
from_raw_string
(
r
#
"
match
x
{
Green
{
a
b
}
=
>
{
different
body
}
Orange
{
a
b
}
|
Yellow
{
a
b
}
=
>
{
some
body
}
Blue
{
x
y
}
=
>
{
some
body
}
}
"
#
)
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
match_with_catchall_order
(
)
{
let
mut
m
=
Match
:
:
new
(
"
x
"
)
;
m
.
arm
(
"
Orange
"
vec
!
[
"
a
"
"
b
"
]
"
some
body
"
)
;
m
.
arm
(
"
Green
"
vec
!
[
"
a
"
"
b
"
]
"
different
body
"
)
;
m
.
arm_no_fields
(
"
_
"
"
unreachable
!
(
)
"
)
;
assert_eq
!
(
m
.
arms
.
len
(
)
2
)
;
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
add_match
(
m
)
;
let
expected_lines
=
from_raw_string
(
r
#
"
match
x
{
Green
{
a
b
}
=
>
{
different
body
}
Orange
{
a
b
}
=
>
{
some
body
}
_
=
>
{
unreachable
!
(
)
}
}
"
#
)
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
parse_multiline_works
(
)
{
let
input
=
"
\
n
hello
\
n
world
\
n
"
;
let
expected
=
vec
!
[
"
hello
"
"
world
"
]
;
let
output
=
parse_multiline
(
input
)
;
assert_eq
!
(
output
expected
)
;
}
#
[
test
]
fn
formatter_basic_example_works
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
line
(
"
Hello
line
1
"
)
;
fmt
.
indent_push
(
)
;
fmt
.
comment
(
"
Nested
comment
"
)
;
fmt
.
indent_pop
(
)
;
fmt
.
line
(
"
Back
home
again
"
)
;
let
expected_lines
=
vec
!
[
"
Hello
line
1
\
n
"
"
/
/
Nested
comment
\
n
"
"
Back
home
again
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
get_indent_works
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
let
expected_results
=
vec
!
[
"
"
"
"
"
"
"
"
]
;
let
actual_results
=
Vec
:
:
with_capacity
(
4
)
;
(
0
.
.
3
)
.
for_each
(
|
_
|
{
fmt
.
get_indent
(
)
;
fmt
.
indent_push
(
)
;
}
)
;
(
0
.
.
3
)
.
for_each
(
|
_
|
fmt
.
indent_pop
(
)
)
;
fmt
.
get_indent
(
)
;
actual_results
.
into_iter
(
)
.
zip
(
expected_results
.
into_iter
(
)
)
.
for_each
(
|
(
actual
expected
)
:
(
String
&
str
)
|
assert_eq
!
(
&
actual
expected
)
)
;
}
#
[
test
]
fn
fmt_can_add_type_to_lines
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
line
(
format
!
(
"
pub
const
{
}
:
Type
=
Type
(
{
:
#
x
}
)
;
"
"
example
"
0
)
)
;
let
expected_lines
=
vec
!
[
"
pub
const
example
:
Type
=
Type
(
0x0
)
;
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
fmt_can_add_indented_line
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
line
(
"
hello
"
)
;
fmt
.
indent_push
(
)
;
fmt
.
line
(
"
world
"
)
;
let
expected_lines
=
vec
!
[
"
hello
\
n
"
"
world
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
fmt_can_add_doc_comments
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
doc_comment
(
"
documentation
\
nis
\
ngood
"
)
;
let
expected_lines
=
vec
!
[
"
/
/
/
documentation
\
n
"
"
/
/
/
is
\
n
"
"
/
/
/
good
\
n
"
]
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
#
[
test
]
fn
fmt_can_add_doc_comments_with_empty_lines
(
)
{
let
mut
fmt
=
Formatter
:
:
new
(
)
;
fmt
.
doc_comment
(
r
#
"
documentation
can
be
really
good
.
If
you
stick
to
writing
it
.
"
#
)
;
let
expected_lines
=
from_raw_string
(
r
#
"
/
/
/
documentation
/
/
/
can
be
really
good
.
/
/
/
/
/
/
If
you
stick
to
writing
it
.
"
#
)
;
assert_eq
!
(
fmt
.
lines
expected_lines
)
;
}
}
