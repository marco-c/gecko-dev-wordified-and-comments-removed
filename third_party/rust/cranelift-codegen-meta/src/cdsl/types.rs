use
std
:
:
fmt
;
use
base
:
:
types
as
base_types
;
static
LANE_BASE
:
u8
=
0x70
;
static
_RUST_NAME_PREFIX
:
&
'
static
str
=
"
ir
:
:
types
:
:
"
;
#
[
derive
(
Debug
)
]
pub
enum
ValueType
{
BV
(
BVType
)
Lane
(
LaneType
)
Special
(
SpecialType
)
Vector
(
VectorType
)
}
impl
ValueType
{
pub
fn
all_lane_types
(
)
-
>
LaneTypeIterator
{
LaneTypeIterator
:
:
new
(
)
}
pub
fn
all_special_types
(
)
-
>
SpecialTypeIterator
{
SpecialTypeIterator
:
:
new
(
)
}
pub
fn
doc
(
&
self
)
-
>
String
{
match
*
self
{
ValueType
:
:
BV
(
ref
b
)
=
>
b
.
doc
(
)
ValueType
:
:
Lane
(
l
)
=
>
l
.
doc
(
)
ValueType
:
:
Special
(
s
)
=
>
s
.
doc
(
)
ValueType
:
:
Vector
(
ref
v
)
=
>
v
.
doc
(
)
}
}
pub
fn
lane_bits
(
&
self
)
-
>
u64
{
match
*
self
{
ValueType
:
:
BV
(
ref
b
)
=
>
b
.
lane_bits
(
)
ValueType
:
:
Lane
(
l
)
=
>
l
.
lane_bits
(
)
ValueType
:
:
Special
(
s
)
=
>
s
.
lane_bits
(
)
ValueType
:
:
Vector
(
ref
v
)
=
>
v
.
lane_bits
(
)
}
}
pub
fn
lane_count
(
&
self
)
-
>
u64
{
match
*
self
{
ValueType
:
:
Vector
(
ref
v
)
=
>
v
.
lane_count
(
)
_
=
>
1
}
}
pub
fn
membytes
(
&
self
)
-
>
u64
{
self
.
width
(
)
/
8
}
pub
fn
number
(
&
self
)
-
>
Option
<
u8
>
{
match
*
self
{
ValueType
:
:
BV
(
_
)
=
>
None
ValueType
:
:
Lane
(
l
)
=
>
Some
(
l
.
number
(
)
)
ValueType
:
:
Special
(
s
)
=
>
Some
(
s
.
number
(
)
)
ValueType
:
:
Vector
(
ref
v
)
=
>
Some
(
v
.
number
(
)
)
}
}
pub
fn
_rust_name
(
&
self
)
-
>
String
{
format
!
(
"
{
}
{
}
"
_RUST_NAME_PREFIX
self
.
to_string
(
)
.
to_uppercase
(
)
)
}
pub
fn
_wider_or_equal
(
&
self
rhs
:
&
ValueType
)
-
>
bool
{
(
self
.
lane_count
(
)
=
=
rhs
.
lane_count
(
)
)
&
&
(
self
.
lane_bits
(
)
>
=
rhs
.
lane_bits
(
)
)
}
pub
fn
width
(
&
self
)
-
>
u64
{
self
.
lane_count
(
)
*
self
.
lane_bits
(
)
}
}
impl
fmt
:
:
Display
for
ValueType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
ValueType
:
:
BV
(
ref
b
)
=
>
b
.
fmt
(
f
)
ValueType
:
:
Lane
(
l
)
=
>
l
.
fmt
(
f
)
ValueType
:
:
Special
(
s
)
=
>
s
.
fmt
(
f
)
ValueType
:
:
Vector
(
ref
v
)
=
>
v
.
fmt
(
f
)
}
}
}
impl
From
<
BVType
>
for
ValueType
{
fn
from
(
bv
:
BVType
)
-
>
Self
{
ValueType
:
:
BV
(
bv
)
}
}
impl
From
<
LaneType
>
for
ValueType
{
fn
from
(
lane
:
LaneType
)
-
>
Self
{
ValueType
:
:
Lane
(
lane
)
}
}
impl
From
<
SpecialType
>
for
ValueType
{
fn
from
(
spec
:
SpecialType
)
-
>
Self
{
ValueType
:
:
Special
(
spec
)
}
}
impl
From
<
VectorType
>
for
ValueType
{
fn
from
(
vector
:
VectorType
)
-
>
Self
{
ValueType
:
:
Vector
(
vector
)
}
}
#
[
derive
(
Clone
Copy
)
]
pub
enum
LaneType
{
BoolType
(
base_types
:
:
Bool
)
FloatType
(
base_types
:
:
Float
)
IntType
(
base_types
:
:
Int
)
}
impl
LaneType
{
pub
fn
doc
(
self
)
-
>
String
{
match
self
{
LaneType
:
:
BoolType
(
_
)
=
>
format
!
(
"
A
boolean
type
with
{
}
bits
.
"
self
.
lane_bits
(
)
)
LaneType
:
:
FloatType
(
base_types
:
:
Float
:
:
F32
)
=
>
String
:
:
from
(
"
A
32
-
bit
floating
point
type
represented
in
the
IEEE
754
-
2008
*
binary32
*
interchange
format
.
This
corresponds
to
the
:
c
:
type
:
float
type
in
most
C
implementations
.
"
)
LaneType
:
:
FloatType
(
base_types
:
:
Float
:
:
F64
)
=
>
String
:
:
from
(
"
A
64
-
bit
floating
point
type
represented
in
the
IEEE
754
-
2008
*
binary64
*
interchange
format
.
This
corresponds
to
the
:
c
:
type
:
double
type
in
most
C
implementations
.
"
)
LaneType
:
:
IntType
(
_
)
if
self
.
lane_bits
(
)
<
32
=
>
format
!
(
"
An
integer
type
with
{
}
bits
.
WARNING
:
arithmetic
on
{
}
bit
integers
is
incomplete
"
self
.
lane_bits
(
)
self
.
lane_bits
(
)
)
LaneType
:
:
IntType
(
_
)
=
>
format
!
(
"
An
integer
type
with
{
}
bits
.
"
self
.
lane_bits
(
)
)
}
}
pub
fn
lane_bits
(
self
)
-
>
u64
{
match
self
{
LaneType
:
:
BoolType
(
ref
b
)
=
>
*
b
as
u64
LaneType
:
:
FloatType
(
ref
f
)
=
>
*
f
as
u64
LaneType
:
:
IntType
(
ref
i
)
=
>
*
i
as
u64
}
}
pub
fn
number
(
self
)
-
>
u8
{
LANE_BASE
+
match
self
{
LaneType
:
:
BoolType
(
base_types
:
:
Bool
:
:
B1
)
=
>
0
LaneType
:
:
BoolType
(
base_types
:
:
Bool
:
:
B8
)
=
>
1
LaneType
:
:
BoolType
(
base_types
:
:
Bool
:
:
B16
)
=
>
2
LaneType
:
:
BoolType
(
base_types
:
:
Bool
:
:
B32
)
=
>
3
LaneType
:
:
BoolType
(
base_types
:
:
Bool
:
:
B64
)
=
>
4
LaneType
:
:
IntType
(
base_types
:
:
Int
:
:
I8
)
=
>
5
LaneType
:
:
IntType
(
base_types
:
:
Int
:
:
I16
)
=
>
6
LaneType
:
:
IntType
(
base_types
:
:
Int
:
:
I32
)
=
>
7
LaneType
:
:
IntType
(
base_types
:
:
Int
:
:
I64
)
=
>
8
LaneType
:
:
FloatType
(
base_types
:
:
Float
:
:
F32
)
=
>
9
LaneType
:
:
FloatType
(
base_types
:
:
Float
:
:
F64
)
=
>
10
}
}
}
impl
fmt
:
:
Display
for
LaneType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
LaneType
:
:
BoolType
(
_
)
=
>
write
!
(
f
"
b
{
}
"
self
.
lane_bits
(
)
)
LaneType
:
:
FloatType
(
_
)
=
>
write
!
(
f
"
f
{
}
"
self
.
lane_bits
(
)
)
LaneType
:
:
IntType
(
_
)
=
>
write
!
(
f
"
i
{
}
"
self
.
lane_bits
(
)
)
}
}
}
impl
fmt
:
:
Debug
for
LaneType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
let
inner_msg
=
format
!
(
"
bits
=
{
}
"
self
.
lane_bits
(
)
)
;
write
!
(
f
"
{
}
"
match
*
self
{
LaneType
:
:
BoolType
(
_
)
=
>
format
!
(
"
BoolType
(
{
}
)
"
inner_msg
)
LaneType
:
:
FloatType
(
_
)
=
>
format
!
(
"
FloatType
(
{
}
)
"
inner_msg
)
LaneType
:
:
IntType
(
_
)
=
>
format
!
(
"
IntType
(
{
}
)
"
inner_msg
)
}
)
}
}
impl
From
<
base_types
:
:
Bool
>
for
LaneType
{
fn
from
(
b
:
base_types
:
:
Bool
)
-
>
Self
{
LaneType
:
:
BoolType
(
b
)
}
}
impl
From
<
base_types
:
:
Float
>
for
LaneType
{
fn
from
(
f
:
base_types
:
:
Float
)
-
>
Self
{
LaneType
:
:
FloatType
(
f
)
}
}
impl
From
<
base_types
:
:
Int
>
for
LaneType
{
fn
from
(
i
:
base_types
:
:
Int
)
-
>
Self
{
LaneType
:
:
IntType
(
i
)
}
}
pub
struct
LaneTypeIterator
{
bool_iter
:
base_types
:
:
BoolIterator
int_iter
:
base_types
:
:
IntIterator
float_iter
:
base_types
:
:
FloatIterator
}
impl
LaneTypeIterator
{
fn
new
(
)
-
>
Self
{
Self
{
bool_iter
:
base_types
:
:
BoolIterator
:
:
new
(
)
int_iter
:
base_types
:
:
IntIterator
:
:
new
(
)
float_iter
:
base_types
:
:
FloatIterator
:
:
new
(
)
}
}
}
impl
Iterator
for
LaneTypeIterator
{
type
Item
=
LaneType
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
b
)
=
self
.
bool_iter
.
next
(
)
{
Some
(
LaneType
:
:
from
(
b
)
)
}
else
if
let
Some
(
i
)
=
self
.
int_iter
.
next
(
)
{
Some
(
LaneType
:
:
from
(
i
)
)
}
else
if
let
Some
(
f
)
=
self
.
float_iter
.
next
(
)
{
Some
(
LaneType
:
:
from
(
f
)
)
}
else
{
None
}
}
}
pub
struct
VectorType
{
base
:
LaneType
lanes
:
u64
}
impl
VectorType
{
pub
fn
new
(
base
:
LaneType
lanes
:
u64
)
-
>
Self
{
Self
{
base
lanes
}
}
pub
fn
doc
(
&
self
)
-
>
String
{
format
!
(
"
A
SIMD
vector
with
{
}
lanes
containing
a
{
}
each
.
"
self
.
lane_count
(
)
self
.
base
)
}
pub
fn
lane_bits
(
&
self
)
-
>
u64
{
self
.
base
.
lane_bits
(
)
}
pub
fn
lane_count
(
&
self
)
-
>
u64
{
self
.
lanes
}
pub
fn
number
(
&
self
)
-
>
u8
{
let
lanes_log_2
:
u32
=
63
-
self
.
lane_count
(
)
.
leading_zeros
(
)
;
let
base_num
=
u32
:
:
from
(
self
.
base
.
number
(
)
)
;
let
num
=
(
lanes_log_2
<
<
4
)
+
base_num
;
num
as
u8
}
}
impl
fmt
:
:
Display
for
VectorType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
x
{
}
"
self
.
base
self
.
lane_count
(
)
)
}
}
impl
fmt
:
:
Debug
for
VectorType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
VectorType
(
base
=
{
}
lanes
=
{
}
)
"
self
.
base
self
.
lane_count
(
)
)
}
}
pub
struct
BVType
{
bits
:
u64
}
impl
BVType
{
pub
fn
_new
(
bits
:
u64
)
-
>
Self
{
Self
{
bits
}
}
pub
fn
doc
(
&
self
)
-
>
String
{
format
!
(
"
A
bitvector
type
with
{
}
bits
.
"
self
.
bits
)
}
pub
fn
lane_bits
(
&
self
)
-
>
u64
{
self
.
bits
}
}
impl
fmt
:
:
Display
for
BVType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
bv
{
}
"
self
.
bits
)
}
}
impl
fmt
:
:
Debug
for
BVType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
BVType
(
bits
=
{
}
)
"
self
.
lane_bits
(
)
)
}
}
#
[
derive
(
Clone
Copy
)
]
pub
enum
SpecialType
{
Flag
(
base_types
:
:
Flag
)
}
impl
SpecialType
{
pub
fn
doc
(
self
)
-
>
String
{
match
self
{
SpecialType
:
:
Flag
(
base_types
:
:
Flag
:
:
IFlags
)
=
>
String
:
:
from
(
"
CPU
flags
representing
the
result
of
an
integer
comparison
.
These
flags
can
be
tested
with
an
:
type
:
intcc
condition
code
.
"
)
SpecialType
:
:
Flag
(
base_types
:
:
Flag
:
:
FFlags
)
=
>
String
:
:
from
(
"
CPU
flags
representing
the
result
of
a
floating
point
comparison
.
These
flags
can
be
tested
with
a
:
type
:
floatcc
condition
code
.
"
)
}
}
pub
fn
lane_bits
(
self
)
-
>
u64
{
match
self
{
SpecialType
:
:
Flag
(
_
)
=
>
0
}
}
pub
fn
number
(
self
)
-
>
u8
{
match
self
{
SpecialType
:
:
Flag
(
base_types
:
:
Flag
:
:
IFlags
)
=
>
1
SpecialType
:
:
Flag
(
base_types
:
:
Flag
:
:
FFlags
)
=
>
2
}
}
}
impl
fmt
:
:
Display
for
SpecialType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
*
self
{
SpecialType
:
:
Flag
(
base_types
:
:
Flag
:
:
IFlags
)
=
>
write
!
(
f
"
iflags
"
)
SpecialType
:
:
Flag
(
base_types
:
:
Flag
:
:
FFlags
)
=
>
write
!
(
f
"
fflags
"
)
}
}
}
impl
fmt
:
:
Debug
for
SpecialType
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
match
*
self
{
SpecialType
:
:
Flag
(
_
)
=
>
format
!
(
"
FlagsType
(
{
}
)
"
self
)
}
)
}
}
impl
From
<
base_types
:
:
Flag
>
for
SpecialType
{
fn
from
(
f
:
base_types
:
:
Flag
)
-
>
Self
{
SpecialType
:
:
Flag
(
f
)
}
}
pub
struct
SpecialTypeIterator
{
flag_iter
:
base_types
:
:
FlagIterator
}
impl
SpecialTypeIterator
{
fn
new
(
)
-
>
Self
{
Self
{
flag_iter
:
base_types
:
:
FlagIterator
:
:
new
(
)
}
}
}
impl
Iterator
for
SpecialTypeIterator
{
type
Item
=
SpecialType
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
let
Some
(
f
)
=
self
.
flag_iter
.
next
(
)
{
Some
(
SpecialType
:
:
from
(
f
)
)
}
else
{
None
}
}
}
