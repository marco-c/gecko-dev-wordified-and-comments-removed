use
crate
:
:
cdsl
:
:
operands
:
:
{
OperandKind
OperandKindFields
}
;
fn
new
(
format_field_name
:
&
'
static
str
rust_type
:
&
'
static
str
doc
:
&
'
static
str
)
-
>
OperandKind
{
OperandKind
:
:
new
(
format_field_name
rust_type
OperandKindFields
:
:
EntityRef
)
.
with_doc
(
doc
)
}
pub
(
crate
)
struct
EntityRefs
{
pub
(
crate
)
block
:
OperandKind
pub
(
crate
)
stack_slot
:
OperandKind
pub
(
crate
)
global_value
:
OperandKind
pub
(
crate
)
sig_ref
:
OperandKind
pub
(
crate
)
func_ref
:
OperandKind
pub
(
crate
)
jump_table
:
OperandKind
pub
(
crate
)
heap
:
OperandKind
pub
(
crate
)
table
:
OperandKind
pub
(
crate
)
varargs
:
OperandKind
}
impl
EntityRefs
{
pub
fn
new
(
)
-
>
Self
{
Self
{
block
:
new
(
"
destination
"
"
ir
:
:
Block
"
"
a
basic
block
in
the
same
function
.
"
)
stack_slot
:
new
(
"
stack_slot
"
"
ir
:
:
StackSlot
"
"
A
stack
slot
"
)
global_value
:
new
(
"
global_value
"
"
ir
:
:
GlobalValue
"
"
A
global
value
.
"
)
sig_ref
:
new
(
"
sig_ref
"
"
ir
:
:
SigRef
"
"
A
function
signature
.
"
)
func_ref
:
new
(
"
func_ref
"
"
ir
:
:
FuncRef
"
"
An
external
function
.
"
)
jump_table
:
new
(
"
table
"
"
ir
:
:
JumpTable
"
"
A
jump
table
.
"
)
heap
:
new
(
"
heap
"
"
ir
:
:
Heap
"
"
A
heap
.
"
)
table
:
new
(
"
table
"
"
ir
:
:
Table
"
"
A
table
.
"
)
varargs
:
OperandKind
:
:
new
(
"
"
"
&
[
Value
]
"
OperandKindFields
:
:
VariableArgs
)
.
with_doc
(
r
#
"
A
variable
size
list
of
value
operands
.
Use
this
to
represent
arguments
passed
to
a
function
call
arguments
passed
to
a
basic
block
or
a
variable
number
of
results
returned
from
an
instruction
.
"
#
)
}
}
}
