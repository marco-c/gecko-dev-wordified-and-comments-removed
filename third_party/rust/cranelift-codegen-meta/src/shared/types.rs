#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
(
crate
)
enum
Bool
{
B1
=
1
B8
=
8
B16
=
16
B32
=
32
B64
=
64
B128
=
128
}
pub
(
crate
)
struct
BoolIterator
{
index
:
u8
}
impl
BoolIterator
{
pub
fn
new
(
)
-
>
Self
{
Self
{
index
:
0
}
}
}
impl
Iterator
for
BoolIterator
{
type
Item
=
Bool
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
res
=
match
self
.
index
{
0
=
>
Some
(
Bool
:
:
B1
)
1
=
>
Some
(
Bool
:
:
B8
)
2
=
>
Some
(
Bool
:
:
B16
)
3
=
>
Some
(
Bool
:
:
B32
)
4
=
>
Some
(
Bool
:
:
B64
)
5
=
>
Some
(
Bool
:
:
B128
)
_
=
>
return
None
}
;
self
.
index
+
=
1
;
res
}
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
(
crate
)
enum
Int
{
I8
=
8
I16
=
16
I32
=
32
I64
=
64
I128
=
128
}
pub
(
crate
)
struct
IntIterator
{
index
:
u8
}
impl
IntIterator
{
pub
fn
new
(
)
-
>
Self
{
Self
{
index
:
0
}
}
}
impl
Iterator
for
IntIterator
{
type
Item
=
Int
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
res
=
match
self
.
index
{
0
=
>
Some
(
Int
:
:
I8
)
1
=
>
Some
(
Int
:
:
I16
)
2
=
>
Some
(
Int
:
:
I32
)
3
=
>
Some
(
Int
:
:
I64
)
4
=
>
Some
(
Int
:
:
I128
)
_
=
>
return
None
}
;
self
.
index
+
=
1
;
res
}
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
(
crate
)
enum
Float
{
F32
=
32
F64
=
64
}
pub
(
crate
)
struct
FloatIterator
{
index
:
u8
}
impl
FloatIterator
{
pub
fn
new
(
)
-
>
Self
{
Self
{
index
:
0
}
}
}
impl
Iterator
for
FloatIterator
{
type
Item
=
Float
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
res
=
match
self
.
index
{
0
=
>
Some
(
Float
:
:
F32
)
1
=
>
Some
(
Float
:
:
F64
)
_
=
>
return
None
}
;
self
.
index
+
=
1
;
res
}
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
(
crate
)
enum
Flag
{
IFlags
FFlags
}
pub
(
crate
)
struct
FlagIterator
{
index
:
u8
}
impl
FlagIterator
{
pub
fn
new
(
)
-
>
Self
{
Self
{
index
:
0
}
}
}
impl
Iterator
for
FlagIterator
{
type
Item
=
Flag
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
res
=
match
self
.
index
{
0
=
>
Some
(
Flag
:
:
IFlags
)
1
=
>
Some
(
Flag
:
:
FFlags
)
_
=
>
return
None
}
;
self
.
index
+
=
1
;
res
}
}
#
[
derive
(
Debug
Clone
Copy
Eq
PartialEq
Hash
)
]
pub
(
crate
)
enum
Reference
{
R32
=
32
R64
=
64
}
pub
(
crate
)
struct
ReferenceIterator
{
index
:
u8
}
impl
ReferenceIterator
{
pub
fn
new
(
)
-
>
Self
{
Self
{
index
:
0
}
}
}
impl
Iterator
for
ReferenceIterator
{
type
Item
=
Reference
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
let
res
=
match
self
.
index
{
0
=
>
Some
(
Reference
:
:
R32
)
1
=
>
Some
(
Reference
:
:
R64
)
_
=
>
return
None
}
;
self
.
index
+
=
1
;
res
}
}
#
[
cfg
(
test
)
]
mod
iter_tests
{
use
super
:
:
*
;
#
[
test
]
fn
bool_iter_works
(
)
{
let
mut
bool_iter
=
BoolIterator
:
:
new
(
)
;
assert_eq
!
(
bool_iter
.
next
(
)
Some
(
Bool
:
:
B1
)
)
;
assert_eq
!
(
bool_iter
.
next
(
)
Some
(
Bool
:
:
B8
)
)
;
assert_eq
!
(
bool_iter
.
next
(
)
Some
(
Bool
:
:
B16
)
)
;
assert_eq
!
(
bool_iter
.
next
(
)
Some
(
Bool
:
:
B32
)
)
;
assert_eq
!
(
bool_iter
.
next
(
)
Some
(
Bool
:
:
B64
)
)
;
assert_eq
!
(
bool_iter
.
next
(
)
Some
(
Bool
:
:
B128
)
)
;
assert_eq
!
(
bool_iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
int_iter_works
(
)
{
let
mut
int_iter
=
IntIterator
:
:
new
(
)
;
assert_eq
!
(
int_iter
.
next
(
)
Some
(
Int
:
:
I8
)
)
;
assert_eq
!
(
int_iter
.
next
(
)
Some
(
Int
:
:
I16
)
)
;
assert_eq
!
(
int_iter
.
next
(
)
Some
(
Int
:
:
I32
)
)
;
assert_eq
!
(
int_iter
.
next
(
)
Some
(
Int
:
:
I64
)
)
;
assert_eq
!
(
int_iter
.
next
(
)
Some
(
Int
:
:
I128
)
)
;
assert_eq
!
(
int_iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
float_iter_works
(
)
{
let
mut
float_iter
=
FloatIterator
:
:
new
(
)
;
assert_eq
!
(
float_iter
.
next
(
)
Some
(
Float
:
:
F32
)
)
;
assert_eq
!
(
float_iter
.
next
(
)
Some
(
Float
:
:
F64
)
)
;
assert_eq
!
(
float_iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
flag_iter_works
(
)
{
let
mut
flag_iter
=
FlagIterator
:
:
new
(
)
;
assert_eq
!
(
flag_iter
.
next
(
)
Some
(
Flag
:
:
IFlags
)
)
;
assert_eq
!
(
flag_iter
.
next
(
)
Some
(
Flag
:
:
FFlags
)
)
;
assert_eq
!
(
flag_iter
.
next
(
)
None
)
;
}
#
[
test
]
fn
reference_iter_works
(
)
{
let
mut
reference_iter
=
ReferenceIterator
:
:
new
(
)
;
assert_eq
!
(
reference_iter
.
next
(
)
Some
(
Reference
:
:
R32
)
)
;
assert_eq
!
(
reference_iter
.
next
(
)
Some
(
Reference
:
:
R64
)
)
;
assert_eq
!
(
reference_iter
.
next
(
)
None
)
;
}
}
