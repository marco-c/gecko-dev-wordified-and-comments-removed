#
!
[
cfg_attr
(
feature
=
"
shrink_to
"
feature
(
shrink_to
)
)
]
#
!
[
cfg_attr
(
feature
=
"
toowned_clone_into
"
feature
(
toowned_clone_into
)
)
]
#
!
[
no_std
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
extern
crate
alloc
;
use
core
:
:
cmp
;
use
core
:
:
fmt
;
use
core
:
:
hash
:
:
{
Hash
Hasher
}
;
use
core
:
:
mem
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
borrow
:
:
{
Borrow
Cow
ToOwned
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
boxed
:
:
Box
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
rc
:
:
Rc
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
string
:
:
String
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
sync
:
:
Arc
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
alloc
:
:
vec
:
:
Vec
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
ops
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
core
:
:
str
:
:
FromStr
;
mod
lossy
;
mod
sys
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
sys
:
:
Buf
;
use
sys
:
:
Slice
;
mod
sys_common
;
use
sys_common
:
:
AsInner
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
sys_common
:
:
{
FromInner
IntoInner
}
;
#
[
derive
(
Clone
)
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
struct
UnixString
{
inner
:
Buf
}
pub
struct
UnixStr
{
inner
:
Slice
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
UnixString
{
pub
fn
new
(
)
-
>
Self
{
Self
{
inner
:
Buf
:
:
from_string
(
String
:
:
new
(
)
)
}
}
pub
fn
as_unix_str
(
&
self
)
-
>
&
UnixStr
{
self
}
pub
fn
into_string
(
self
)
-
>
Result
<
String
UnixString
>
{
self
.
inner
.
into_string
(
)
.
map_err
(
|
buf
|
UnixString
{
inner
:
buf
}
)
}
pub
fn
push
<
T
:
AsRef
<
UnixStr
>
>
(
&
mut
self
s
:
T
)
{
self
.
inner
.
push_slice
(
&
s
.
as_ref
(
)
.
inner
)
}
pub
fn
with_capacity
(
capacity
:
usize
)
-
>
Self
{
Self
{
inner
:
Buf
:
:
with_capacity
(
capacity
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
inner
.
clear
(
)
}
pub
fn
capacity
(
&
self
)
-
>
usize
{
self
.
inner
.
capacity
(
)
}
pub
fn
reserve
(
&
mut
self
additional
:
usize
)
{
self
.
inner
.
reserve
(
additional
)
}
pub
fn
reserve_exact
(
&
mut
self
additional
:
usize
)
{
self
.
inner
.
reserve_exact
(
additional
)
}
pub
fn
shrink_to_fit
(
&
mut
self
)
{
self
.
inner
.
shrink_to_fit
(
)
}
#
[
inline
]
#
[
cfg
(
feature
=
"
shrink_to
"
)
]
pub
fn
shrink_to
(
&
mut
self
min_capacity
:
usize
)
{
self
.
inner
.
shrink_to
(
min_capacity
)
}
pub
fn
into_boxed_unix_str
(
self
)
-
>
Box
<
UnixStr
>
{
let
rw
=
Box
:
:
into_raw
(
self
.
inner
.
into_box
(
)
)
as
*
mut
UnixStr
;
unsafe
{
Box
:
:
from_raw
(
rw
)
}
}
pub
fn
from_vec
(
vec
:
Vec
<
u8
>
)
-
>
Self
{
FromInner
:
:
from_inner
(
Buf
{
inner
:
vec
}
)
}
pub
fn
into_vec
(
self
)
-
>
Vec
<
u8
>
{
self
.
into_inner
(
)
.
inner
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
String
>
for
UnixString
{
fn
from
(
s
:
String
)
-
>
Self
{
UnixString
{
inner
:
Buf
:
:
from_string
(
s
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
T
:
?
Sized
+
AsRef
<
UnixStr
>
>
From
<
&
T
>
for
UnixString
{
fn
from
(
s
:
&
T
)
-
>
Self
{
s
.
as_ref
(
)
.
to_unix_string
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ops
:
:
Index
<
ops
:
:
RangeFull
>
for
UnixString
{
type
Output
=
UnixStr
;
#
[
inline
]
fn
index
(
&
self
_index
:
ops
:
:
RangeFull
)
-
>
&
UnixStr
{
UnixStr
:
:
from_inner
(
self
.
inner
.
as_slice
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ops
:
:
IndexMut
<
ops
:
:
RangeFull
>
for
UnixString
{
#
[
inline
]
fn
index_mut
(
&
mut
self
_index
:
ops
:
:
RangeFull
)
-
>
&
mut
UnixStr
{
UnixStr
:
:
from_inner_mut
(
self
.
inner
.
as_mut_slice
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ops
:
:
Deref
for
UnixString
{
type
Target
=
UnixStr
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
UnixStr
{
&
self
[
.
.
]
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ops
:
:
DerefMut
for
UnixString
{
#
[
inline
]
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
UnixStr
{
&
mut
self
[
.
.
]
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Default
for
UnixString
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
Self
:
:
new
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
fmt
:
:
Debug
for
UnixString
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
*
*
self
formatter
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialEq
for
UnixString
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
&
*
*
self
=
=
&
*
*
other
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialEq
<
str
>
for
UnixString
{
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
&
*
*
self
=
=
other
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialEq
<
UnixString
>
for
str
{
fn
eq
(
&
self
other
:
&
UnixString
)
-
>
bool
{
&
*
*
other
=
=
self
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialEq
<
&
str
>
for
UnixString
{
fn
eq
(
&
self
other
:
&
&
str
)
-
>
bool
{
*
*
self
=
=
*
*
other
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
PartialEq
<
UnixString
>
for
&
'
a
str
{
fn
eq
(
&
self
other
:
&
UnixString
)
-
>
bool
{
*
*
other
=
=
*
*
self
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Eq
for
UnixString
{
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialOrd
for
UnixString
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
(
&
*
*
self
)
.
partial_cmp
(
&
*
*
other
)
}
#
[
inline
]
fn
lt
(
&
self
other
:
&
Self
)
-
>
bool
{
&
*
*
self
<
&
*
*
other
}
#
[
inline
]
fn
le
(
&
self
other
:
&
Self
)
-
>
bool
{
&
*
*
self
<
=
&
*
*
other
}
#
[
inline
]
fn
gt
(
&
self
other
:
&
Self
)
-
>
bool
{
&
*
*
self
>
&
*
*
other
}
#
[
inline
]
fn
ge
(
&
self
other
:
&
Self
)
-
>
bool
{
&
*
*
self
>
=
&
*
*
other
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
PartialOrd
<
str
>
for
UnixString
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
str
)
-
>
Option
<
cmp
:
:
Ordering
>
{
(
&
*
*
self
)
.
partial_cmp
(
other
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Ord
for
UnixString
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
(
&
*
*
self
)
.
cmp
(
&
*
*
other
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Hash
for
UnixString
{
#
[
inline
]
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
(
&
*
*
self
)
.
hash
(
state
)
}
}
impl
UnixStr
{
#
[
inline
]
pub
fn
new
<
S
:
AsRef
<
UnixStr
>
+
?
Sized
>
(
s
:
&
S
)
-
>
&
UnixStr
{
s
.
as_ref
(
)
}
#
[
inline
]
fn
from_inner
(
inner
:
&
Slice
)
-
>
&
UnixStr
{
unsafe
{
&
*
(
inner
as
*
const
Slice
as
*
const
UnixStr
)
}
}
#
[
inline
]
#
[
cfg
(
feature
=
"
alloc
"
)
]
fn
from_inner_mut
(
inner
:
&
mut
Slice
)
-
>
&
mut
UnixStr
{
unsafe
{
&
mut
*
(
inner
as
*
mut
Slice
as
*
mut
UnixStr
)
}
}
pub
fn
to_str
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
inner
.
to_str
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
to_string_lossy
(
&
self
)
-
>
Cow
<
'
_
str
>
{
self
.
inner
.
to_string_lossy
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
to_unix_string
(
&
self
)
-
>
UnixString
{
UnixString
{
inner
:
self
.
inner
.
to_owned
(
)
}
}
#
[
inline
]
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
inner
.
inner
.
is_empty
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
inner
.
inner
.
len
(
)
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
pub
fn
into_unix_string
(
self
:
Box
<
UnixStr
>
)
-
>
UnixString
{
let
boxed
=
unsafe
{
Box
:
:
from_raw
(
Box
:
:
into_raw
(
self
)
as
*
mut
Slice
)
}
;
UnixString
{
inner
:
Buf
:
:
from_box
(
boxed
)
}
}
#
[
inline
]
fn
bytes
(
&
self
)
-
>
&
[
u8
]
{
unsafe
{
&
*
(
&
self
.
inner
as
*
const
_
as
*
const
[
u8
]
)
}
}
#
[
cfg
(
feature
=
"
unixstring_ascii
"
)
]
pub
fn
make_ascii_lowercase
(
&
mut
self
)
{
self
.
inner
.
make_ascii_lowercase
(
)
}
#
[
cfg
(
feature
=
"
unixstring_ascii
"
)
]
pub
fn
make_ascii_uppercase
(
&
mut
self
)
{
self
.
inner
.
make_ascii_uppercase
(
)
}
#
[
cfg
(
all
(
feature
=
"
alloc
"
feature
=
"
unixstring_ascii
"
)
)
]
pub
fn
to_ascii_lowercase
(
&
self
)
-
>
UnixString
{
UnixString
:
:
from_inner
(
self
.
inner
.
to_ascii_lowercase
(
)
)
}
#
[
cfg
(
all
(
feature
=
"
alloc
"
feature
=
"
unixstring_ascii
"
)
)
]
pub
fn
to_ascii_uppercase
(
&
self
)
-
>
UnixString
{
UnixString
:
:
from_inner
(
self
.
inner
.
to_ascii_uppercase
(
)
)
}
#
[
cfg
(
feature
=
"
unixstring_ascii
"
)
]
pub
fn
is_ascii
(
&
self
)
-
>
bool
{
self
.
inner
.
is_ascii
(
)
}
#
[
cfg
(
feature
=
"
unixstring_ascii
"
)
]
pub
fn
eq_ignore_ascii_case
<
S
:
?
Sized
+
AsRef
<
UnixStr
>
>
(
&
self
other
:
&
S
)
-
>
bool
{
self
.
inner
.
eq_ignore_ascii_case
(
&
other
.
as_ref
(
)
.
inner
)
}
pub
fn
from_bytes
(
slice
:
&
[
u8
]
)
-
>
&
Self
{
unsafe
{
mem
:
:
transmute
(
slice
)
}
}
pub
fn
as_bytes
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
as_inner
(
)
.
inner
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
&
UnixStr
>
for
Box
<
UnixStr
>
{
fn
from
(
s
:
&
UnixStr
)
-
>
Self
{
let
rw
=
Box
:
:
into_raw
(
s
.
inner
.
into_box
(
)
)
as
*
mut
UnixStr
;
unsafe
{
Box
:
:
from_raw
(
rw
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
Cow
<
'
_
UnixStr
>
>
for
Box
<
UnixStr
>
{
#
[
inline
]
fn
from
(
cow
:
Cow
<
'
_
UnixStr
>
)
-
>
Self
{
match
cow
{
Cow
:
:
Borrowed
(
s
)
=
>
Box
:
:
from
(
s
)
Cow
:
:
Owned
(
s
)
=
>
Box
:
:
from
(
s
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
Box
<
UnixStr
>
>
for
UnixString
{
fn
from
(
boxed
:
Box
<
UnixStr
>
)
-
>
Self
{
boxed
.
into_unix_string
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
UnixString
>
for
Box
<
UnixStr
>
{
fn
from
(
s
:
UnixString
)
-
>
Self
{
s
.
into_boxed_unix_str
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Clone
for
Box
<
UnixStr
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
Self
{
self
.
to_unix_string
(
)
.
into_boxed_unix_str
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
UnixString
>
for
Arc
<
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
UnixString
)
-
>
Self
{
let
arc
=
s
.
inner
.
into_arc
(
)
;
unsafe
{
Arc
:
:
from_raw
(
Arc
:
:
into_raw
(
arc
)
as
*
const
UnixStr
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
&
UnixStr
>
for
Arc
<
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
&
UnixStr
)
-
>
Self
{
let
arc
=
s
.
inner
.
into_arc
(
)
;
unsafe
{
Arc
:
:
from_raw
(
Arc
:
:
into_raw
(
arc
)
as
*
const
UnixStr
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
UnixString
>
for
Rc
<
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
UnixString
)
-
>
Self
{
let
rc
=
s
.
inner
.
into_rc
(
)
;
unsafe
{
Rc
:
:
from_raw
(
Rc
:
:
into_raw
(
rc
)
as
*
const
UnixStr
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
From
<
&
UnixStr
>
for
Rc
<
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
&
UnixStr
)
-
>
Self
{
let
rc
=
s
.
inner
.
into_rc
(
)
;
unsafe
{
Rc
:
:
from_raw
(
Rc
:
:
into_raw
(
rc
)
as
*
const
UnixStr
)
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
UnixString
>
for
Cow
<
'
a
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
UnixString
)
-
>
Self
{
Cow
:
:
Owned
(
s
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
&
'
a
UnixStr
>
for
Cow
<
'
a
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
&
'
a
UnixStr
)
-
>
Self
{
Cow
:
:
Borrowed
(
s
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
&
'
a
UnixString
>
for
Cow
<
'
a
UnixStr
>
{
#
[
inline
]
fn
from
(
s
:
&
'
a
UnixString
)
-
>
Self
{
Cow
:
:
Borrowed
(
s
.
as_unix_str
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
>
From
<
Cow
<
'
a
UnixStr
>
>
for
UnixString
{
#
[
inline
]
fn
from
(
s
:
Cow
<
'
a
UnixStr
>
)
-
>
Self
{
s
.
into_owned
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Default
for
Box
<
UnixStr
>
{
fn
default
(
)
-
>
Self
{
let
rw
=
Box
:
:
into_raw
(
Slice
:
:
empty_box
(
)
)
as
*
mut
UnixStr
;
unsafe
{
Box
:
:
from_raw
(
rw
)
}
}
}
impl
Default
for
&
UnixStr
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
UnixStr
:
:
new
(
"
"
)
}
}
impl
PartialEq
for
UnixStr
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
UnixStr
)
-
>
bool
{
self
.
bytes
(
)
.
eq
(
other
.
bytes
(
)
)
}
}
impl
PartialEq
<
str
>
for
UnixStr
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
str
)
-
>
bool
{
*
self
=
=
*
UnixStr
:
:
new
(
other
)
}
}
impl
PartialEq
<
UnixStr
>
for
str
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
UnixStr
)
-
>
bool
{
*
other
=
=
*
UnixStr
:
:
new
(
self
)
}
}
impl
Eq
for
UnixStr
{
}
impl
PartialOrd
for
UnixStr
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
bytes
(
)
.
partial_cmp
(
other
.
bytes
(
)
)
}
#
[
inline
]
fn
lt
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
bytes
(
)
.
lt
(
other
.
bytes
(
)
)
}
#
[
inline
]
fn
le
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
bytes
(
)
.
le
(
other
.
bytes
(
)
)
}
#
[
inline
]
fn
gt
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
bytes
(
)
.
gt
(
other
.
bytes
(
)
)
}
#
[
inline
]
fn
ge
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
bytes
(
)
.
ge
(
other
.
bytes
(
)
)
}
}
impl
PartialOrd
<
str
>
for
UnixStr
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
str
)
-
>
Option
<
cmp
:
:
Ordering
>
{
self
.
partial_cmp
(
Self
:
:
new
(
other
)
)
}
}
impl
Ord
for
UnixStr
{
#
[
inline
]
fn
cmp
(
&
self
other
:
&
Self
)
-
>
cmp
:
:
Ordering
{
self
.
bytes
(
)
.
cmp
(
other
.
bytes
(
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
macro_rules
!
impl_cmp
{
(
lhs
:
ty
rhs
:
ty
)
=
>
{
impl
<
'
a
'
b
>
PartialEq
<
rhs
>
for
lhs
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
rhs
)
-
>
bool
{
<
UnixStr
as
PartialEq
>
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
PartialEq
<
lhs
>
for
rhs
{
#
[
inline
]
fn
eq
(
&
self
other
:
&
lhs
)
-
>
bool
{
<
UnixStr
as
PartialEq
>
:
:
eq
(
self
other
)
}
}
impl
<
'
a
'
b
>
PartialOrd
<
rhs
>
for
lhs
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
rhs
)
-
>
Option
<
cmp
:
:
Ordering
>
{
<
UnixStr
as
PartialOrd
>
:
:
partial_cmp
(
self
other
)
}
}
impl
<
'
a
'
b
>
PartialOrd
<
lhs
>
for
rhs
{
#
[
inline
]
fn
partial_cmp
(
&
self
other
:
&
lhs
)
-
>
Option
<
cmp
:
:
Ordering
>
{
<
UnixStr
as
PartialOrd
>
:
:
partial_cmp
(
self
other
)
}
}
}
;
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
UnixString
UnixStr
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
UnixString
&
'
a
UnixStr
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
Cow
<
'
a
UnixStr
>
UnixStr
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
Cow
<
'
a
UnixStr
>
&
'
b
UnixStr
)
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl_cmp
!
(
Cow
<
'
a
UnixStr
>
UnixString
)
;
impl
Hash
for
UnixStr
{
#
[
inline
]
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
bytes
(
)
.
hash
(
state
)
}
}
impl
fmt
:
:
Debug
for
UnixStr
{
fn
fmt
(
&
self
formatter
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fmt
:
:
Debug
:
:
fmt
(
&
self
.
inner
formatter
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
Borrow
<
UnixStr
>
for
UnixString
{
fn
borrow
(
&
self
)
-
>
&
UnixStr
{
&
self
[
.
.
]
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
ToOwned
for
UnixStr
{
type
Owned
=
UnixString
;
fn
to_owned
(
&
self
)
-
>
Self
:
:
Owned
{
self
.
to_unix_string
(
)
}
#
[
cfg
(
feature
=
"
toowned_clone_into
"
)
]
fn
clone_into
(
&
self
target
:
&
mut
Self
:
:
Owned
)
{
self
.
inner
.
clone_into
(
&
mut
target
.
inner
)
}
}
impl
AsRef
<
UnixStr
>
for
UnixStr
{
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
self
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
UnixStr
>
for
UnixString
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
self
}
}
impl
AsRef
<
UnixStr
>
for
str
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
UnixStr
:
:
from_inner
(
Slice
:
:
from_str
(
self
)
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
AsRef
<
UnixStr
>
for
String
{
#
[
inline
]
fn
as_ref
(
&
self
)
-
>
&
UnixStr
{
(
&
*
*
self
)
.
as_ref
(
)
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
FromInner
<
Buf
>
for
UnixString
{
fn
from_inner
(
buf
:
Buf
)
-
>
UnixString
{
UnixString
{
inner
:
buf
}
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
IntoInner
<
Buf
>
for
UnixString
{
fn
into_inner
(
self
)
-
>
Buf
{
self
.
inner
}
}
impl
AsInner
<
Slice
>
for
UnixStr
{
#
[
inline
]
fn
as_inner
(
&
self
)
-
>
&
Slice
{
&
self
.
inner
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
FromStr
for
UnixString
{
type
Err
=
core
:
:
convert
:
:
Infallible
;
fn
from_str
(
s
:
&
str
)
-
>
Result
<
Self
Self
:
:
Err
>
{
Ok
(
UnixString
:
:
from
(
s
)
)
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
sys_common
:
:
{
AsInner
IntoInner
}
;
use
alloc
:
:
rc
:
:
Rc
;
use
alloc
:
:
sync
:
:
Arc
;
#
[
test
]
fn
test_unix_string_with_capacity
(
)
{
let
unix_string
=
UnixString
:
:
with_capacity
(
0
)
;
assert_eq
!
(
0
unix_string
.
inner
.
into_inner
(
)
.
capacity
(
)
)
;
let
unix_string
=
UnixString
:
:
with_capacity
(
10
)
;
assert_eq
!
(
10
unix_string
.
inner
.
into_inner
(
)
.
capacity
(
)
)
;
let
mut
unix_string
=
UnixString
:
:
with_capacity
(
0
)
;
unix_string
.
push
(
"
abc
"
)
;
assert
!
(
unix_string
.
inner
.
into_inner
(
)
.
capacity
(
)
>
=
3
)
;
}
#
[
test
]
fn
test_unix_string_clear
(
)
{
let
mut
unix_string
=
UnixString
:
:
from
(
"
abc
"
)
;
assert_eq
!
(
3
unix_string
.
inner
.
as_inner
(
)
.
len
(
)
)
;
unix_string
.
clear
(
)
;
assert_eq
!
(
&
unix_string
"
"
)
;
assert_eq
!
(
0
unix_string
.
inner
.
as_inner
(
)
.
len
(
)
)
;
}
#
[
test
]
fn
test_unix_string_capacity
(
)
{
let
unix_string
=
UnixString
:
:
with_capacity
(
0
)
;
assert_eq
!
(
0
unix_string
.
capacity
(
)
)
;
let
unix_string
=
UnixString
:
:
with_capacity
(
10
)
;
assert_eq
!
(
10
unix_string
.
capacity
(
)
)
;
let
mut
unix_string
=
UnixString
:
:
with_capacity
(
0
)
;
unix_string
.
push
(
"
abc
"
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
3
)
;
}
#
[
test
]
fn
test_unix_string_reserve
(
)
{
let
mut
unix_string
=
UnixString
:
:
new
(
)
;
assert_eq
!
(
unix_string
.
capacity
(
)
0
)
;
unix_string
.
reserve
(
2
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
2
)
;
for
_
in
0
.
.
16
{
unix_string
.
push
(
"
a
"
)
;
}
assert
!
(
unix_string
.
capacity
(
)
>
=
16
)
;
unix_string
.
reserve
(
16
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
32
)
;
unix_string
.
push
(
"
a
"
)
;
unix_string
.
reserve
(
16
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
33
)
}
#
[
test
]
fn
test_unix_string_reserve_exact
(
)
{
let
mut
unix_string
=
UnixString
:
:
new
(
)
;
assert_eq
!
(
unix_string
.
capacity
(
)
0
)
;
unix_string
.
reserve_exact
(
2
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
2
)
;
for
_
in
0
.
.
16
{
unix_string
.
push
(
"
a
"
)
;
}
assert
!
(
unix_string
.
capacity
(
)
>
=
16
)
;
unix_string
.
reserve_exact
(
16
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
32
)
;
unix_string
.
push
(
"
a
"
)
;
unix_string
.
reserve_exact
(
16
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
33
)
}
#
[
test
]
fn
test_unix_string_default
(
)
{
let
unix_string
:
UnixString
=
Default
:
:
default
(
)
;
assert_eq
!
(
"
"
&
unix_string
)
;
}
#
[
test
]
fn
test_unix_str_is_empty
(
)
{
let
mut
unix_string
=
UnixString
:
:
new
(
)
;
assert
!
(
unix_string
.
is_empty
(
)
)
;
unix_string
.
push
(
"
abc
"
)
;
assert
!
(
!
unix_string
.
is_empty
(
)
)
;
unix_string
.
clear
(
)
;
assert
!
(
unix_string
.
is_empty
(
)
)
;
}
#
[
test
]
fn
test_unix_str_len
(
)
{
let
mut
unix_string
=
UnixString
:
:
new
(
)
;
assert_eq
!
(
0
unix_string
.
len
(
)
)
;
unix_string
.
push
(
"
abc
"
)
;
assert_eq
!
(
3
unix_string
.
len
(
)
)
;
unix_string
.
clear
(
)
;
assert_eq
!
(
0
unix_string
.
len
(
)
)
;
}
#
[
test
]
fn
test_unix_str_default
(
)
{
let
unix_str
:
&
UnixStr
=
Default
:
:
default
(
)
;
assert_eq
!
(
"
"
unix_str
)
;
}
#
[
test
]
fn
into_boxed
(
)
{
let
orig
=
"
Hello
world
!
"
;
let
unix_str
=
UnixStr
:
:
new
(
orig
)
;
let
boxed
:
Box
<
UnixStr
>
=
Box
:
:
from
(
unix_str
)
;
let
unix_string
=
unix_str
.
to_owned
(
)
.
into_boxed_unix_str
(
)
.
into_unix_string
(
)
;
assert_eq
!
(
unix_str
&
*
boxed
)
;
assert_eq
!
(
&
*
boxed
&
*
unix_string
)
;
assert_eq
!
(
&
*
unix_string
unix_str
)
;
}
#
[
test
]
fn
boxed_default
(
)
{
let
boxed
=
<
Box
<
UnixStr
>
>
:
:
default
(
)
;
assert
!
(
boxed
.
is_empty
(
)
)
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
toowned_clone_into
"
)
]
fn
test_unix_str_clone_into
(
)
{
let
mut
unix_string
=
UnixString
:
:
with_capacity
(
123
)
;
unix_string
.
push
(
"
hello
"
)
;
let
unix_str
=
UnixStr
:
:
new
(
"
bonjour
"
)
;
unix_str
.
clone_into
(
&
mut
unix_string
)
;
assert_eq
!
(
unix_str
unix_string
)
;
assert
!
(
unix_string
.
capacity
(
)
>
=
123
)
;
}
#
[
test
]
fn
into_rc
(
)
{
let
orig
=
"
Hello
world
!
"
;
let
unix_str
=
UnixStr
:
:
new
(
orig
)
;
let
rc
:
Rc
<
UnixStr
>
=
Rc
:
:
from
(
unix_str
)
;
let
arc
:
Arc
<
UnixStr
>
=
Arc
:
:
from
(
unix_str
)
;
assert_eq
!
(
&
*
rc
unix_str
)
;
assert_eq
!
(
&
*
arc
unix_str
)
;
let
rc2
:
Rc
<
UnixStr
>
=
Rc
:
:
from
(
unix_str
.
to_owned
(
)
)
;
let
arc2
:
Arc
<
UnixStr
>
=
Arc
:
:
from
(
unix_str
.
to_owned
(
)
)
;
assert_eq
!
(
&
*
rc2
unix_str
)
;
assert_eq
!
(
&
*
arc2
unix_str
)
;
}
}
