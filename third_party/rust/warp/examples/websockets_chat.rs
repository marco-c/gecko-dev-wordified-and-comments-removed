#
!
[
deny
(
warnings
)
]
extern
crate
futures
;
extern
crate
pretty_env_logger
;
extern
crate
warp
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
sync
:
:
{
atomic
:
:
{
AtomicUsize
Ordering
}
Arc
Mutex
}
;
use
futures
:
:
sync
:
:
mpsc
;
use
futures
:
:
{
Future
Stream
}
;
use
warp
:
:
ws
:
:
{
Message
WebSocket
}
;
use
warp
:
:
Filter
;
static
NEXT_USER_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
1
)
;
type
Users
=
Arc
<
Mutex
<
HashMap
<
usize
mpsc
:
:
UnboundedSender
<
Message
>
>
>
>
;
fn
main
(
)
{
pretty_env_logger
:
:
init
(
)
;
let
users
=
Arc
:
:
new
(
Mutex
:
:
new
(
HashMap
:
:
new
(
)
)
)
;
let
users
=
warp
:
:
any
(
)
.
map
(
move
|
|
users
.
clone
(
)
)
;
let
chat
=
warp
:
:
path
(
"
chat
"
)
.
and
(
warp
:
:
ws2
(
)
)
.
and
(
users
)
.
map
(
|
ws
:
warp
:
:
ws
:
:
Ws2
users
|
{
ws
.
on_upgrade
(
move
|
socket
|
user_connected
(
socket
users
)
)
}
)
;
let
index
=
warp
:
:
path
:
:
end
(
)
.
map
(
|
|
warp
:
:
reply
:
:
html
(
INDEX_HTML
)
)
;
let
routes
=
index
.
or
(
chat
)
;
warp
:
:
serve
(
routes
)
.
run
(
(
[
127
0
0
1
]
3030
)
)
;
}
fn
user_connected
(
ws
:
WebSocket
users
:
Users
)
-
>
impl
Future
<
Item
=
(
)
Error
=
(
)
>
{
let
my_id
=
NEXT_USER_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
eprintln
!
(
"
new
chat
user
:
{
}
"
my_id
)
;
let
(
user_ws_tx
user_ws_rx
)
=
ws
.
split
(
)
;
let
(
tx
rx
)
=
mpsc
:
:
unbounded
(
)
;
warp
:
:
spawn
(
rx
.
map_err
(
|
(
)
|
-
>
warp
:
:
Error
{
unreachable
!
(
"
unbounded
rx
never
errors
"
)
}
)
.
forward
(
user_ws_tx
)
.
map
(
|
_tx_rx
|
(
)
)
.
map_err
(
|
ws_err
|
eprintln
!
(
"
websocket
send
error
:
{
}
"
ws_err
)
)
)
;
users
.
lock
(
)
.
unwrap
(
)
.
insert
(
my_id
tx
)
;
let
users2
=
users
.
clone
(
)
;
user_ws_rx
.
for_each
(
move
|
msg
|
{
user_message
(
my_id
msg
&
users
)
;
Ok
(
(
)
)
}
)
.
then
(
move
|
result
|
{
user_disconnected
(
my_id
&
users2
)
;
result
}
)
.
map_err
(
move
|
e
|
{
eprintln
!
(
"
websocket
error
(
uid
=
{
}
)
:
{
}
"
my_id
e
)
;
}
)
}
fn
user_message
(
my_id
:
usize
msg
:
Message
users
:
&
Users
)
{
let
msg
=
if
let
Ok
(
s
)
=
msg
.
to_str
(
)
{
s
}
else
{
return
;
}
;
let
new_msg
=
format
!
(
"
<
User
#
{
}
>
:
{
}
"
my_id
msg
)
;
for
(
&
uid
tx
)
in
users
.
lock
(
)
.
unwrap
(
)
.
iter
(
)
{
if
my_id
!
=
uid
{
match
tx
.
unbounded_send
(
Message
:
:
text
(
new_msg
.
clone
(
)
)
)
{
Ok
(
(
)
)
=
>
(
)
Err
(
_disconnected
)
=
>
{
}
}
}
}
}
fn
user_disconnected
(
my_id
:
usize
users
:
&
Users
)
{
eprintln
!
(
"
good
bye
user
:
{
}
"
my_id
)
;
users
.
lock
(
)
.
unwrap
(
)
.
remove
(
&
my_id
)
;
}
static
INDEX_HTML
:
&
str
=
r
#
"
<
!
DOCTYPE
html
>
<
html
>
<
head
>
<
title
>
Warp
Chat
<
/
title
>
<
/
head
>
<
body
>
<
h1
>
warp
chat
<
/
h1
>
<
div
id
=
"
chat
"
>
<
p
>
<
em
>
Connecting
.
.
.
<
/
em
>
<
/
p
>
<
/
div
>
<
input
type
=
"
text
"
id
=
"
text
"
/
>
<
button
type
=
"
button
"
id
=
"
send
"
>
Send
<
/
button
>
<
script
type
=
"
text
/
javascript
"
>
var
uri
=
'
ws
:
/
/
'
+
location
.
host
+
'
/
chat
'
;
var
ws
=
new
WebSocket
(
uri
)
;
function
message
(
data
)
{
var
line
=
document
.
createElement
(
'
p
'
)
;
line
.
innerText
=
data
;
chat
.
appendChild
(
line
)
;
}
ws
.
onopen
=
function
(
)
{
chat
.
innerHTML
=
"
<
p
>
<
em
>
Connected
!
<
/
em
>
<
/
p
>
"
;
}
ws
.
onmessage
=
function
(
msg
)
{
message
(
msg
.
data
)
;
}
;
send
.
onclick
=
function
(
)
{
var
msg
=
text
.
value
;
ws
.
send
(
msg
)
;
text
.
value
=
'
'
;
message
(
'
<
You
>
:
'
+
msg
)
;
}
;
<
/
script
>
<
/
body
>
<
/
html
>
"
#
;
