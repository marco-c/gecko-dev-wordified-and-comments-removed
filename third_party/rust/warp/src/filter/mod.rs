mod
and
;
mod
and_then
;
mod
boxed
;
mod
map
;
mod
map_err
;
mod
or
;
mod
or_else
;
mod
recover
;
mod
service
;
mod
unify
;
mod
untuple_one
;
mod
wrap
;
use
futures
:
:
{
future
Future
IntoFuture
}
;
pub
(
crate
)
use
generic
:
:
{
one
Combine
Either
Func
HList
One
Tuple
}
;
use
reject
:
:
{
CombineRejection
Reject
Rejection
}
;
use
route
:
:
{
self
Route
}
;
pub
(
crate
)
use
self
:
:
and
:
:
And
;
use
self
:
:
and_then
:
:
AndThen
;
pub
use
self
:
:
boxed
:
:
BoxedFilter
;
pub
(
crate
)
use
self
:
:
map
:
:
Map
;
pub
(
crate
)
use
self
:
:
map_err
:
:
MapErr
;
pub
(
crate
)
use
self
:
:
or
:
:
Or
;
use
self
:
:
or_else
:
:
OrElse
;
use
self
:
:
recover
:
:
Recover
;
use
self
:
:
unify
:
:
Unify
;
use
self
:
:
untuple_one
:
:
UntupleOne
;
pub
(
crate
)
use
self
:
:
wrap
:
:
{
Wrap
WrapSealed
}
;
pub
trait
FilterBase
{
type
Extract
:
Tuple
;
type
Error
:
Reject
;
type
Future
:
Future
<
Item
=
Self
:
:
Extract
Error
=
Self
:
:
Error
>
+
Send
;
fn
filter
(
&
self
)
-
>
Self
:
:
Future
;
fn
map_err
<
F
E
>
(
self
fun
:
F
)
-
>
MapErr
<
Self
F
>
where
Self
:
Sized
F
:
Fn
(
Self
:
:
Error
)
-
>
E
+
Clone
E
:
:
:
std
:
:
fmt
:
:
Debug
+
Send
{
MapErr
{
filter
:
self
callback
:
fun
}
}
}
pub
fn
__warp_filter_compilefail_doctest
(
)
{
let
_
=
:
:
any
(
)
.
filter
(
)
;
}
pub
trait
Filter
:
FilterBase
{
fn
and
<
F
>
(
self
other
:
F
)
-
>
And
<
Self
F
>
where
Self
:
Sized
<
Self
:
:
Extract
as
Tuple
>
:
:
HList
:
Combine
<
<
F
:
:
Extract
as
Tuple
>
:
:
HList
>
F
:
Filter
+
Clone
F
:
:
Error
:
CombineRejection
<
Self
:
:
Error
>
{
And
{
first
:
self
second
:
other
}
}
fn
or
<
F
>
(
self
other
:
F
)
-
>
Or
<
Self
F
>
where
Self
:
Sized
F
:
Filter
F
:
:
Error
:
CombineRejection
<
Self
:
:
Error
>
{
Or
{
first
:
self
second
:
other
}
}
fn
map
<
F
>
(
self
fun
:
F
)
-
>
Map
<
Self
F
>
where
Self
:
Sized
F
:
Func
<
Self
:
:
Extract
>
+
Clone
{
Map
{
filter
:
self
callback
:
fun
}
}
fn
and_then
<
F
>
(
self
fun
:
F
)
-
>
AndThen
<
Self
F
>
where
Self
:
Sized
F
:
Func
<
Self
:
:
Extract
>
+
Clone
F
:
:
Output
:
IntoFuture
+
Send
<
F
:
:
Output
as
IntoFuture
>
:
:
Error
:
CombineRejection
<
Self
:
:
Error
>
<
F
:
:
Output
as
IntoFuture
>
:
:
Future
:
Send
{
AndThen
{
filter
:
self
callback
:
fun
}
}
fn
or_else
<
F
>
(
self
fun
:
F
)
-
>
OrElse
<
Self
F
>
where
Self
:
Sized
F
:
Func
<
Self
:
:
Error
>
F
:
:
Output
:
IntoFuture
<
Item
=
Self
:
:
Extract
Error
=
Self
:
:
Error
>
+
Send
<
F
:
:
Output
as
IntoFuture
>
:
:
Future
:
Send
{
OrElse
{
filter
:
self
callback
:
fun
}
}
fn
recover
<
F
>
(
self
fun
:
F
)
-
>
Recover
<
Self
F
>
where
Self
:
Sized
F
:
Func
<
Self
:
:
Error
>
F
:
:
Output
:
IntoFuture
<
Error
=
Self
:
:
Error
>
+
Send
<
F
:
:
Output
as
IntoFuture
>
:
:
Future
:
Send
{
Recover
{
filter
:
self
callback
:
fun
}
}
fn
unify
<
T
>
(
self
)
-
>
Unify
<
Self
>
where
Self
:
Filter
<
Extract
=
(
Either
<
T
T
>
)
>
+
Sized
T
:
Tuple
{
Unify
{
filter
:
self
}
}
fn
untuple_one
<
T
>
(
self
)
-
>
UntupleOne
<
Self
>
where
Self
:
Filter
<
Extract
=
(
T
)
>
+
Sized
T
:
Tuple
{
UntupleOne
{
filter
:
self
}
}
fn
with
<
W
>
(
self
wrapper
:
W
)
-
>
W
:
:
Wrapped
where
Self
:
Sized
W
:
Wrap
<
Self
>
{
wrapper
.
wrap
(
self
)
}
fn
boxed
(
self
)
-
>
BoxedFilter
<
Self
:
:
Extract
>
where
Self
:
Sized
+
Send
+
Sync
+
'
static
Self
:
:
Extract
:
Send
Self
:
:
Error
:
Into
<
Rejection
>
{
BoxedFilter
:
:
new
(
self
)
}
}
impl
<
T
:
FilterBase
>
Filter
for
T
{
}
pub
trait
FilterClone
:
Filter
+
Clone
{
}
impl
<
T
:
Filter
+
Clone
>
FilterClone
for
T
{
}
fn
_assert_object_safe
(
)
{
fn
_assert
(
_f
:
&
dyn
Filter
<
Extract
=
(
)
Error
=
(
)
Future
=
future
:
:
FutureResult
<
(
)
(
)
>
>
)
{
}
}
pub
(
crate
)
fn
filter_fn
<
F
U
>
(
func
:
F
)
-
>
FilterFn
<
F
>
where
F
:
Fn
(
&
mut
Route
)
-
>
U
U
:
IntoFuture
U
:
:
Item
:
Tuple
U
:
:
Error
:
Reject
{
FilterFn
{
func
}
}
pub
(
crate
)
fn
filter_fn_one
<
F
U
>
(
func
:
F
)
-
>
FilterFn
<
impl
Fn
(
&
mut
Route
)
-
>
future
:
:
Map
<
U
:
:
Future
fn
(
U
:
:
Item
)
-
>
(
U
:
:
Item
)
>
+
Copy
>
where
F
:
Fn
(
&
mut
Route
)
-
>
U
+
Copy
U
:
IntoFuture
U
:
:
Error
:
Reject
{
filter_fn
(
move
|
route
|
func
(
route
)
.
into_future
(
)
.
map
(
tup_one
as
_
)
)
}
fn
tup_one
<
T
>
(
item
:
T
)
-
>
(
T
)
{
(
item
)
}
#
[
derive
(
Copy
Clone
)
]
#
[
allow
(
missing_debug_implementations
)
]
pub
(
crate
)
struct
FilterFn
<
F
>
{
func
:
F
}
impl
<
F
U
>
FilterBase
for
FilterFn
<
F
>
where
F
:
Fn
(
&
mut
Route
)
-
>
U
U
:
IntoFuture
U
:
:
Future
:
Send
U
:
:
Item
:
Tuple
U
:
:
Error
:
Reject
{
type
Extract
=
U
:
:
Item
;
type
Error
=
U
:
:
Error
;
type
Future
=
U
:
:
Future
;
#
[
inline
]
fn
filter
(
&
self
)
-
>
Self
:
:
Future
{
route
:
:
with
(
|
route
|
(
self
.
func
)
(
route
)
.
into_future
(
)
)
}
}
