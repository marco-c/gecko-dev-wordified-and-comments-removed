use
std
:
:
any
:
:
Any
;
use
std
:
:
convert
:
:
Infallible
;
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
http
:
:
{
self
header
:
:
{
HeaderValue
CONTENT_TYPE
}
StatusCode
}
;
use
hyper
:
:
Body
;
pub
(
crate
)
use
self
:
:
sealed
:
:
{
CombineRejection
IsReject
}
;
#
[
inline
]
pub
fn
reject
(
)
-
>
Rejection
{
not_found
(
)
}
#
[
inline
]
pub
fn
not_found
(
)
-
>
Rejection
{
Rejection
{
reason
:
Reason
:
:
NotFound
}
}
#
[
inline
]
pub
(
crate
)
fn
invalid_query
(
)
-
>
Rejection
{
known
(
InvalidQuery
{
_p
:
(
)
}
)
}
#
[
inline
]
pub
(
crate
)
fn
missing_header
(
name
:
&
'
static
str
)
-
>
Rejection
{
known
(
MissingHeader
{
name
}
)
}
#
[
inline
]
pub
(
crate
)
fn
invalid_header
(
name
:
&
'
static
str
)
-
>
Rejection
{
known
(
InvalidHeader
{
name
}
)
}
#
[
inline
]
pub
(
crate
)
fn
missing_cookie
(
name
:
&
'
static
str
)
-
>
Rejection
{
known
(
MissingCookie
{
name
}
)
}
#
[
inline
]
pub
(
crate
)
fn
method_not_allowed
(
)
-
>
Rejection
{
known
(
MethodNotAllowed
{
_p
:
(
)
}
)
}
#
[
inline
]
pub
(
crate
)
fn
length_required
(
)
-
>
Rejection
{
known
(
LengthRequired
{
_p
:
(
)
}
)
}
#
[
inline
]
pub
(
crate
)
fn
payload_too_large
(
)
-
>
Rejection
{
known
(
PayloadTooLarge
{
_p
:
(
)
}
)
}
#
[
inline
]
pub
(
crate
)
fn
unsupported_media_type
(
)
-
>
Rejection
{
known
(
UnsupportedMediaType
{
_p
:
(
)
}
)
}
pub
fn
custom
<
T
:
Reject
>
(
err
:
T
)
-
>
Rejection
{
Rejection
:
:
custom
(
Box
:
:
new
(
err
)
)
}
fn
__reject_custom_compilefail
(
)
{
}
pub
trait
Reject
:
fmt
:
:
Debug
+
Sized
+
Send
+
Sync
+
'
static
{
}
trait
Cause
:
fmt
:
:
Debug
+
Send
+
Sync
+
'
static
{
fn
as_any
(
&
self
)
-
>
&
dyn
Any
;
}
impl
<
T
>
Cause
for
T
where
T
:
fmt
:
:
Debug
+
Send
+
Sync
+
'
static
{
fn
as_any
(
&
self
)
-
>
&
dyn
Any
{
self
}
}
impl
dyn
Cause
{
fn
downcast_ref
<
T
:
Any
>
(
&
self
)
-
>
Option
<
&
T
>
{
self
.
as_any
(
)
.
downcast_ref
:
:
<
T
>
(
)
}
}
pub
(
crate
)
fn
known
<
T
:
Into
<
Known
>
>
(
err
:
T
)
-
>
Rejection
{
Rejection
:
:
known
(
err
.
into
(
)
)
}
pub
struct
Rejection
{
reason
:
Reason
}
enum
Reason
{
NotFound
Other
(
Box
<
Rejections
>
)
}
enum
Rejections
{
Known
(
Known
)
Custom
(
Box
<
dyn
Cause
>
)
Combined
(
Box
<
Rejections
>
Box
<
Rejections
>
)
}
macro_rules
!
enum_known
{
(
(
(
#
[
attr
:
meta
]
)
*
var
:
ident
(
ty
:
path
)
)
+
)
=
>
(
pub
(
crate
)
enum
Known
{
(
(
#
[
attr
]
)
*
var
(
ty
)
)
+
}
impl
Known
{
fn
inner_as_any
(
&
self
)
-
>
&
dyn
Any
{
match
*
self
{
(
(
#
[
attr
]
)
*
Known
:
:
var
(
ref
t
)
=
>
t
)
+
}
}
}
impl
fmt
:
:
Debug
for
Known
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
(
(
#
[
attr
]
)
*
Known
:
:
var
(
ref
t
)
=
>
t
.
fmt
(
f
)
)
+
}
}
}
impl
fmt
:
:
Display
for
Known
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
(
(
#
[
attr
]
)
*
Known
:
:
var
(
ref
t
)
=
>
t
.
fmt
(
f
)
)
+
}
}
}
(
#
[
doc
(
hidden
)
]
(
#
[
attr
]
)
*
impl
From
<
ty
>
for
Known
{
fn
from
(
ty
:
ty
)
-
>
Known
{
Known
:
:
var
(
ty
)
}
}
)
+
)
;
}
enum_known
!
{
MethodNotAllowed
(
MethodNotAllowed
)
InvalidHeader
(
InvalidHeader
)
MissingHeader
(
MissingHeader
)
MissingCookie
(
MissingCookie
)
InvalidQuery
(
InvalidQuery
)
LengthRequired
(
LengthRequired
)
PayloadTooLarge
(
PayloadTooLarge
)
UnsupportedMediaType
(
UnsupportedMediaType
)
FileOpenError
(
crate
:
:
fs
:
:
FileOpenError
)
FilePermissionError
(
crate
:
:
fs
:
:
FilePermissionError
)
BodyReadError
(
crate
:
:
body
:
:
BodyReadError
)
BodyDeserializeError
(
crate
:
:
body
:
:
BodyDeserializeError
)
CorsForbidden
(
crate
:
:
cors
:
:
CorsForbidden
)
#
[
cfg
(
feature
=
"
websocket
"
)
]
MissingConnectionUpgrade
(
crate
:
:
ws
:
:
MissingConnectionUpgrade
)
MissingExtension
(
crate
:
:
ext
:
:
MissingExtension
)
BodyConsumedMultipleTimes
(
crate
:
:
body
:
:
BodyConsumedMultipleTimes
)
}
impl
Rejection
{
fn
known
(
known
:
Known
)
-
>
Self
{
Rejection
{
reason
:
Reason
:
:
Other
(
Box
:
:
new
(
Rejections
:
:
Known
(
known
)
)
)
}
}
fn
custom
(
other
:
Box
<
dyn
Cause
>
)
-
>
Self
{
Rejection
{
reason
:
Reason
:
:
Other
(
Box
:
:
new
(
Rejections
:
:
Custom
(
other
)
)
)
}
}
pub
fn
find
<
T
:
'
static
>
(
&
self
)
-
>
Option
<
&
T
>
{
if
let
Reason
:
:
Other
(
ref
rejections
)
=
self
.
reason
{
return
rejections
.
find
(
)
;
}
None
}
pub
fn
is_not_found
(
&
self
)
-
>
bool
{
matches
!
(
self
.
reason
Reason
:
:
NotFound
)
}
}
impl
<
T
:
Reject
>
From
<
T
>
for
Rejection
{
#
[
inline
]
fn
from
(
err
:
T
)
-
>
Rejection
{
custom
(
err
)
}
}
impl
From
<
Infallible
>
for
Rejection
{
#
[
inline
]
fn
from
(
infallible
:
Infallible
)
-
>
Rejection
{
match
infallible
{
}
}
}
impl
IsReject
for
Infallible
{
fn
status
(
&
self
)
-
>
StatusCode
{
match
*
self
{
}
}
fn
into_response
(
&
self
)
-
>
crate
:
:
reply
:
:
Response
{
match
*
self
{
}
}
}
impl
IsReject
for
Rejection
{
fn
status
(
&
self
)
-
>
StatusCode
{
match
self
.
reason
{
Reason
:
:
NotFound
=
>
StatusCode
:
:
NOT_FOUND
Reason
:
:
Other
(
ref
other
)
=
>
other
.
status
(
)
}
}
fn
into_response
(
&
self
)
-
>
crate
:
:
reply
:
:
Response
{
match
self
.
reason
{
Reason
:
:
NotFound
=
>
{
let
mut
res
=
http
:
:
Response
:
:
default
(
)
;
*
res
.
status_mut
(
)
=
StatusCode
:
:
NOT_FOUND
;
res
}
Reason
:
:
Other
(
ref
other
)
=
>
other
.
into_response
(
)
}
}
}
impl
fmt
:
:
Debug
for
Rejection
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
debug_tuple
(
"
Rejection
"
)
.
field
(
&
self
.
reason
)
.
finish
(
)
}
}
impl
fmt
:
:
Debug
for
Reason
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
match
*
self
{
Reason
:
:
NotFound
=
>
f
.
write_str
(
"
NotFound
"
)
Reason
:
:
Other
(
ref
other
)
=
>
match
*
*
other
{
Rejections
:
:
Known
(
ref
e
)
=
>
fmt
:
:
Debug
:
:
fmt
(
e
f
)
Rejections
:
:
Custom
(
ref
e
)
=
>
fmt
:
:
Debug
:
:
fmt
(
e
f
)
Rejections
:
:
Combined
(
ref
a
ref
b
)
=
>
{
let
mut
list
=
f
.
debug_list
(
)
;
a
.
debug_list
(
&
mut
list
)
;
b
.
debug_list
(
&
mut
list
)
;
list
.
finish
(
)
}
}
}
}
}
impl
Rejections
{
fn
status
(
&
self
)
-
>
StatusCode
{
match
*
self
{
Rejections
:
:
Known
(
ref
k
)
=
>
match
*
k
{
Known
:
:
MethodNotAllowed
(
_
)
=
>
StatusCode
:
:
METHOD_NOT_ALLOWED
Known
:
:
InvalidHeader
(
_
)
|
Known
:
:
MissingHeader
(
_
)
|
Known
:
:
MissingCookie
(
_
)
|
Known
:
:
InvalidQuery
(
_
)
|
Known
:
:
BodyReadError
(
_
)
|
Known
:
:
BodyDeserializeError
(
_
)
=
>
StatusCode
:
:
BAD_REQUEST
#
[
cfg
(
feature
=
"
websocket
"
)
]
Known
:
:
MissingConnectionUpgrade
(
_
)
=
>
StatusCode
:
:
BAD_REQUEST
Known
:
:
LengthRequired
(
_
)
=
>
StatusCode
:
:
LENGTH_REQUIRED
Known
:
:
PayloadTooLarge
(
_
)
=
>
StatusCode
:
:
PAYLOAD_TOO_LARGE
Known
:
:
UnsupportedMediaType
(
_
)
=
>
StatusCode
:
:
UNSUPPORTED_MEDIA_TYPE
Known
:
:
FilePermissionError
(
_
)
|
Known
:
:
CorsForbidden
(
_
)
=
>
StatusCode
:
:
FORBIDDEN
Known
:
:
FileOpenError
(
_
)
|
Known
:
:
MissingExtension
(
_
)
|
Known
:
:
BodyConsumedMultipleTimes
(
_
)
=
>
StatusCode
:
:
INTERNAL_SERVER_ERROR
}
Rejections
:
:
Custom
(
.
.
)
=
>
StatusCode
:
:
INTERNAL_SERVER_ERROR
Rejections
:
:
Combined
(
.
.
)
=
>
self
.
preferred
(
)
.
status
(
)
}
}
fn
into_response
(
&
self
)
-
>
crate
:
:
reply
:
:
Response
{
match
*
self
{
Rejections
:
:
Known
(
ref
e
)
=
>
{
let
mut
res
=
http
:
:
Response
:
:
new
(
Body
:
:
from
(
e
.
to_string
(
)
)
)
;
*
res
.
status_mut
(
)
=
self
.
status
(
)
;
res
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
plain
;
charset
=
utf
-
8
"
)
)
;
res
}
Rejections
:
:
Custom
(
ref
e
)
=
>
{
tracing
:
:
error
!
(
"
unhandled
custom
rejection
returning
500
response
:
{
:
?
}
"
e
)
;
let
body
=
format
!
(
"
Unhandled
rejection
:
{
:
?
}
"
e
)
;
let
mut
res
=
http
:
:
Response
:
:
new
(
Body
:
:
from
(
body
)
)
;
*
res
.
status_mut
(
)
=
self
.
status
(
)
;
res
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
plain
;
charset
=
utf
-
8
"
)
)
;
res
}
Rejections
:
:
Combined
(
.
.
)
=
>
self
.
preferred
(
)
.
into_response
(
)
}
}
fn
find
<
T
:
'
static
>
(
&
self
)
-
>
Option
<
&
T
>
{
match
*
self
{
Rejections
:
:
Known
(
ref
e
)
=
>
e
.
inner_as_any
(
)
.
downcast_ref
(
)
Rejections
:
:
Custom
(
ref
e
)
=
>
e
.
downcast_ref
(
)
Rejections
:
:
Combined
(
ref
a
ref
b
)
=
>
a
.
find
(
)
.
or_else
(
|
|
b
.
find
(
)
)
}
}
fn
debug_list
(
&
self
f
:
&
mut
fmt
:
:
DebugList
<
'
_
'
_
>
)
{
match
*
self
{
Rejections
:
:
Known
(
ref
e
)
=
>
{
f
.
entry
(
e
)
;
}
Rejections
:
:
Custom
(
ref
e
)
=
>
{
f
.
entry
(
e
)
;
}
Rejections
:
:
Combined
(
ref
a
ref
b
)
=
>
{
a
.
debug_list
(
f
)
;
b
.
debug_list
(
f
)
;
}
}
}
fn
preferred
(
&
self
)
-
>
&
Rejections
{
match
self
{
Rejections
:
:
Known
(
_
)
|
Rejections
:
:
Custom
(
_
)
=
>
self
Rejections
:
:
Combined
(
a
b
)
=
>
{
let
a
=
a
.
preferred
(
)
;
let
b
=
b
.
preferred
(
)
;
match
(
a
.
status
(
)
b
.
status
(
)
)
{
(
_
StatusCode
:
:
NOT_FOUND
)
=
>
a
(
StatusCode
:
:
NOT_FOUND
_
)
=
>
b
(
_
StatusCode
:
:
METHOD_NOT_ALLOWED
)
=
>
a
(
StatusCode
:
:
METHOD_NOT_ALLOWED
_
)
=
>
b
(
sa
sb
)
if
sa
<
sb
=
>
b
_
=
>
a
}
}
}
}
}
unit_error
!
{
/
/
/
Invalid
query
pub
InvalidQuery
:
"
Invalid
query
string
"
}
unit_error
!
{
/
/
/
HTTP
method
not
allowed
pub
MethodNotAllowed
:
"
HTTP
method
not
allowed
"
}
unit_error
!
{
/
/
/
A
content
-
length
header
is
required
pub
LengthRequired
:
"
A
content
-
length
header
is
required
"
}
unit_error
!
{
/
/
/
The
request
payload
is
too
large
pub
PayloadTooLarge
:
"
The
request
payload
is
too
large
"
}
unit_error
!
{
/
/
/
The
request
'
s
content
-
type
is
not
supported
pub
UnsupportedMediaType
:
"
The
request
'
s
content
-
type
is
not
supported
"
}
#
[
derive
(
Debug
)
]
pub
struct
MissingHeader
{
name
:
&
'
static
str
}
impl
MissingHeader
{
pub
fn
name
(
&
self
)
-
>
&
str
{
self
.
name
}
}
impl
fmt
:
:
Display
for
MissingHeader
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Missing
request
header
{
:
?
}
"
self
.
name
)
}
}
impl
StdError
for
MissingHeader
{
}
#
[
derive
(
Debug
)
]
pub
struct
InvalidHeader
{
name
:
&
'
static
str
}
impl
InvalidHeader
{
pub
fn
name
(
&
self
)
-
>
&
str
{
self
.
name
}
}
impl
fmt
:
:
Display
for
InvalidHeader
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Invalid
request
header
{
:
?
}
"
self
.
name
)
}
}
impl
StdError
for
InvalidHeader
{
}
#
[
derive
(
Debug
)
]
pub
struct
MissingCookie
{
name
:
&
'
static
str
}
impl
MissingCookie
{
pub
fn
name
(
&
self
)
-
>
&
str
{
self
.
name
}
}
impl
fmt
:
:
Display
for
MissingCookie
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Missing
request
cookie
{
:
?
}
"
self
.
name
)
}
}
impl
StdError
for
MissingCookie
{
}
mod
sealed
{
use
super
:
:
{
Reason
Rejection
Rejections
}
;
use
http
:
:
StatusCode
;
use
std
:
:
convert
:
:
Infallible
;
use
std
:
:
fmt
;
pub
trait
IsReject
:
fmt
:
:
Debug
+
Send
+
Sync
{
fn
status
(
&
self
)
-
>
StatusCode
;
fn
into_response
(
&
self
)
-
>
crate
:
:
reply
:
:
Response
;
}
fn
_assert_object_safe
(
)
{
fn
_assert
(
_
:
&
dyn
IsReject
)
{
}
}
pub
trait
CombineRejection
<
E
>
:
Send
+
Sized
{
type
One
:
IsReject
+
From
<
Self
>
+
From
<
E
>
+
Into
<
Rejection
>
;
type
Combined
:
IsReject
;
fn
combine
(
self
other
:
E
)
-
>
Self
:
:
Combined
;
}
impl
CombineRejection
<
Rejection
>
for
Rejection
{
type
One
=
Rejection
;
type
Combined
=
Rejection
;
fn
combine
(
self
other
:
Rejection
)
-
>
Self
:
:
Combined
{
let
reason
=
match
(
self
.
reason
other
.
reason
)
{
(
Reason
:
:
Other
(
left
)
Reason
:
:
Other
(
right
)
)
=
>
{
Reason
:
:
Other
(
Box
:
:
new
(
Rejections
:
:
Combined
(
left
right
)
)
)
}
(
Reason
:
:
Other
(
other
)
Reason
:
:
NotFound
)
|
(
Reason
:
:
NotFound
Reason
:
:
Other
(
other
)
)
=
>
{
Reason
:
:
Other
(
other
)
}
(
Reason
:
:
NotFound
Reason
:
:
NotFound
)
=
>
Reason
:
:
NotFound
}
;
Rejection
{
reason
}
}
}
impl
CombineRejection
<
Infallible
>
for
Rejection
{
type
One
=
Rejection
;
type
Combined
=
Infallible
;
fn
combine
(
self
other
:
Infallible
)
-
>
Self
:
:
Combined
{
match
other
{
}
}
}
impl
CombineRejection
<
Rejection
>
for
Infallible
{
type
One
=
Rejection
;
type
Combined
=
Infallible
;
fn
combine
(
self
_
:
Rejection
)
-
>
Self
:
:
Combined
{
match
self
{
}
}
}
impl
CombineRejection
<
Infallible
>
for
Infallible
{
type
One
=
Infallible
;
type
Combined
=
Infallible
;
fn
combine
(
self
_
:
Infallible
)
-
>
Self
:
:
Combined
{
match
self
{
}
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
http
:
:
StatusCode
;
#
[
derive
(
Debug
PartialEq
)
]
struct
Left
;
#
[
derive
(
Debug
PartialEq
)
]
struct
Right
;
impl
Reject
for
Left
{
}
impl
Reject
for
Right
{
}
#
[
test
]
fn
rejection_status
(
)
{
assert_eq
!
(
not_found
(
)
.
status
(
)
StatusCode
:
:
NOT_FOUND
)
;
assert_eq
!
(
method_not_allowed
(
)
.
status
(
)
StatusCode
:
:
METHOD_NOT_ALLOWED
)
;
assert_eq
!
(
length_required
(
)
.
status
(
)
StatusCode
:
:
LENGTH_REQUIRED
)
;
assert_eq
!
(
payload_too_large
(
)
.
status
(
)
StatusCode
:
:
PAYLOAD_TOO_LARGE
)
;
assert_eq
!
(
unsupported_media_type
(
)
.
status
(
)
StatusCode
:
:
UNSUPPORTED_MEDIA_TYPE
)
;
assert_eq
!
(
custom
(
Left
)
.
status
(
)
StatusCode
:
:
INTERNAL_SERVER_ERROR
)
;
}
#
[
tokio
:
:
test
]
async
fn
combine_rejection_causes_with_some_left_and_none_right
(
)
{
let
left
=
custom
(
Left
)
;
let
right
=
not_found
(
)
;
let
reject
=
left
.
combine
(
right
)
;
let
resp
=
reject
.
into_response
(
)
;
assert_eq
!
(
resp
.
status
(
)
StatusCode
:
:
INTERNAL_SERVER_ERROR
)
;
assert_eq
!
(
response_body_string
(
resp
)
.
await
"
Unhandled
rejection
:
Left
"
)
}
#
[
tokio
:
:
test
]
async
fn
combine_rejection_causes_with_none_left_and_some_right
(
)
{
let
left
=
not_found
(
)
;
let
right
=
custom
(
Right
)
;
let
reject
=
left
.
combine
(
right
)
;
let
resp
=
reject
.
into_response
(
)
;
assert_eq
!
(
resp
.
status
(
)
StatusCode
:
:
INTERNAL_SERVER_ERROR
)
;
assert_eq
!
(
response_body_string
(
resp
)
.
await
"
Unhandled
rejection
:
Right
"
)
}
#
[
tokio
:
:
test
]
async
fn
unhandled_customs
(
)
{
let
reject
=
not_found
(
)
.
combine
(
custom
(
Right
)
)
;
let
resp
=
reject
.
into_response
(
)
;
assert_eq
!
(
resp
.
status
(
)
StatusCode
:
:
INTERNAL_SERVER_ERROR
)
;
assert_eq
!
(
response_body_string
(
resp
)
.
await
"
Unhandled
rejection
:
Right
"
)
;
let
reject
=
custom
(
Left
)
.
combine
(
custom
(
Right
)
)
;
let
resp
=
reject
.
into_response
(
)
;
assert_eq
!
(
resp
.
status
(
)
StatusCode
:
:
INTERNAL_SERVER_ERROR
)
;
assert_eq
!
(
response_body_string
(
resp
)
.
await
"
Unhandled
rejection
:
Left
"
)
;
let
reject
=
not_found
(
)
.
combine
(
not_found
(
)
)
.
combine
(
not_found
(
)
)
.
combine
(
custom
(
Right
)
)
.
combine
(
not_found
(
)
)
;
let
resp
=
reject
.
into_response
(
)
;
assert_eq
!
(
resp
.
status
(
)
StatusCode
:
:
INTERNAL_SERVER_ERROR
)
;
assert_eq
!
(
response_body_string
(
resp
)
.
await
"
Unhandled
rejection
:
Right
"
)
;
}
async
fn
response_body_string
(
resp
:
crate
:
:
reply
:
:
Response
)
-
>
String
{
let
(
_
body
)
=
resp
.
into_parts
(
)
;
let
body_bytes
=
hyper
:
:
body
:
:
to_bytes
(
body
)
.
await
.
expect
(
"
failed
concat
"
)
;
String
:
:
from_utf8_lossy
(
&
body_bytes
)
.
to_string
(
)
}
#
[
test
]
fn
find_cause
(
)
{
let
rej
=
custom
(
Left
)
;
assert_eq
!
(
rej
.
find
:
:
<
Left
>
(
)
Some
(
&
Left
)
)
;
let
rej
=
rej
.
combine
(
method_not_allowed
(
)
)
;
assert_eq
!
(
rej
.
find
:
:
<
Left
>
(
)
Some
(
&
Left
)
)
;
assert
!
(
rej
.
find
:
:
<
MethodNotAllowed
>
(
)
.
is_some
(
)
"
MethodNotAllowed
"
)
;
}
#
[
test
]
fn
size_of_rejection
(
)
{
assert_eq
!
(
:
:
std
:
:
mem
:
:
size_of
:
:
<
Rejection
>
(
)
:
:
std
:
:
mem
:
:
size_of
:
:
<
usize
>
(
)
)
;
}
#
[
derive
(
Debug
)
]
struct
X
(
u32
)
;
impl
Reject
for
X
{
}
fn
combine_n
<
F
R
>
(
n
:
u32
new_reject
:
F
)
-
>
Rejection
where
F
:
Fn
(
u32
)
-
>
R
R
:
Reject
{
let
mut
rej
=
not_found
(
)
;
for
i
in
0
.
.
n
{
rej
=
rej
.
combine
(
custom
(
new_reject
(
i
)
)
)
;
}
rej
}
#
[
test
]
fn
test_debug
(
)
{
let
rej
=
combine_n
(
3
X
)
;
let
s
=
format
!
(
"
{
:
?
}
"
rej
)
;
assert_eq
!
(
s
"
Rejection
(
[
X
(
0
)
X
(
1
)
X
(
2
)
]
)
"
)
;
}
#
[
test
]
fn
convert_big_rejections_into_response
(
)
{
let
mut
rejections
=
Rejections
:
:
Custom
(
Box
:
:
new
(
std
:
:
io
:
:
Error
:
:
from_raw_os_error
(
100
)
)
)
;
for
_
in
0
.
.
50
{
rejections
=
Rejections
:
:
Combined
(
Box
:
:
new
(
Rejections
:
:
Known
(
Known
:
:
MethodNotAllowed
(
MethodNotAllowed
{
_p
:
(
)
}
)
)
)
Box
:
:
new
(
rejections
)
)
;
}
let
reason
=
Reason
:
:
Other
(
Box
:
:
new
(
rejections
)
)
;
let
rejection
=
Rejection
{
reason
}
;
assert_eq
!
(
StatusCode
:
:
INTERNAL_SERVER_ERROR
rejection
.
into_response
(
)
.
status
(
)
)
;
}
}
