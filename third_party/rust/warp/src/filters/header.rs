use
std
:
:
str
:
:
FromStr
;
use
std
:
:
error
:
:
Error
as
StdError
;
use
headers
:
:
{
Header
HeaderMapExt
}
;
use
http
:
:
HeaderMap
;
use
filter
:
:
{
filter_fn
filter_fn_one
Filter
One
}
;
use
never
:
:
Never
;
use
reject
:
:
{
self
Rejection
}
;
pub
fn
header
<
T
:
FromStr
+
Send
>
(
name
:
&
'
static
str
)
-
>
impl
Filter
<
Extract
=
One
<
T
>
Error
=
Rejection
>
+
Copy
{
filter_fn_one
(
move
|
route
|
{
trace
!
(
"
header
(
{
:
?
}
)
"
name
)
;
route
.
headers
(
)
.
get
(
name
)
.
ok_or_else
(
|
|
reject
:
:
known
(
MissingHeader
(
name
)
)
)
.
and_then
(
|
value
|
{
value
.
to_str
(
)
.
map_err
(
|
_
|
reject
:
:
known
(
InvalidHeader
(
name
)
)
)
}
)
.
and_then
(
|
s
|
T
:
:
from_str
(
s
)
.
map_err
(
|
_
|
reject
:
:
known
(
InvalidHeader
(
name
)
)
)
)
}
)
}
pub
(
crate
)
fn
header2
<
T
:
Header
+
Send
>
(
)
-
>
impl
Filter
<
Extract
=
One
<
T
>
Error
=
Rejection
>
+
Copy
{
filter_fn_one
(
move
|
route
|
{
trace
!
(
"
header2
(
{
:
?
}
)
"
T
:
:
name
(
)
)
;
route
.
headers
(
)
.
typed_get
(
)
.
ok_or_else
(
|
|
reject
:
:
known
(
InvalidHeader
(
T
:
:
name
(
)
.
as_str
(
)
)
)
)
}
)
}
pub
fn
optional
<
T
>
(
name
:
&
'
static
str
)
-
>
impl
Filter
<
Extract
=
One
<
Option
<
T
>
>
Error
=
Rejection
>
+
Copy
where
T
:
FromStr
+
Send
{
filter_fn_one
(
move
|
route
|
{
trace
!
(
"
optional
(
{
:
?
}
)
"
name
)
;
let
result
=
route
.
headers
(
)
.
get
(
name
)
.
map
(
|
value
|
{
value
.
to_str
(
)
.
map_err
(
|
_
|
reject
:
:
known
(
InvalidHeader
(
name
)
)
)
?
.
parse
:
:
<
T
>
(
)
.
map_err
(
|
_
|
reject
:
:
known
(
InvalidHeader
(
name
)
)
)
}
)
;
match
result
{
Some
(
Ok
(
t
)
)
=
>
Ok
(
Some
(
t
)
)
Some
(
Err
(
e
)
)
=
>
Err
(
e
)
None
=
>
Ok
(
None
)
}
}
)
}
pub
(
crate
)
fn
optional2
<
T
>
(
)
-
>
impl
Filter
<
Extract
=
One
<
Option
<
T
>
>
Error
=
Never
>
+
Copy
where
T
:
Header
+
Send
{
filter_fn_one
(
move
|
route
|
Ok
(
route
.
headers
(
)
.
typed_get
(
)
)
)
}
pub
fn
exact
(
name
:
&
'
static
str
value
:
&
'
static
str
)
-
>
impl
Filter
<
Extract
=
(
)
Error
=
Rejection
>
+
Copy
{
filter_fn
(
move
|
route
|
{
trace
!
(
"
exact
?
(
{
:
?
}
{
:
?
}
)
"
name
value
)
;
route
.
headers
(
)
.
get
(
name
)
.
ok_or_else
(
|
|
reject
:
:
known
(
MissingHeader
(
name
)
)
)
.
and_then
(
|
val
|
{
if
val
=
=
value
{
Ok
(
(
)
)
}
else
{
Err
(
reject
:
:
known
(
InvalidHeader
(
name
)
)
)
}
}
)
}
)
}
pub
fn
exact_ignore_case
(
name
:
&
'
static
str
value
:
&
'
static
str
)
-
>
impl
Filter
<
Extract
=
(
)
Error
=
Rejection
>
+
Copy
{
filter_fn
(
move
|
route
|
{
trace
!
(
"
exact_ignore_case
(
{
:
?
}
{
:
?
}
)
"
name
value
)
;
route
.
headers
(
)
.
get
(
name
)
.
ok_or_else
(
|
|
reject
:
:
known
(
MissingHeader
(
name
)
)
)
.
and_then
(
|
val
|
{
if
val
.
as_bytes
(
)
.
eq_ignore_ascii_case
(
value
.
as_bytes
(
)
)
{
Ok
(
(
)
)
}
else
{
Err
(
reject
:
:
known
(
InvalidHeader
(
name
)
)
)
}
}
)
}
)
}
pub
fn
headers_cloned
(
)
-
>
impl
Filter
<
Extract
=
One
<
HeaderMap
>
Error
=
Never
>
+
Copy
{
filter_fn_one
(
|
route
|
Ok
(
route
.
headers
(
)
.
clone
(
)
)
)
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
MissingHeader
(
&
'
static
str
)
;
impl
:
:
std
:
:
fmt
:
:
Display
for
MissingHeader
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Missing
request
header
'
{
}
'
"
self
.
0
)
}
}
impl
StdError
for
MissingHeader
{
fn
description
(
&
self
)
-
>
&
str
{
"
Missing
request
header
"
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
InvalidHeader
(
&
'
static
str
)
;
impl
:
:
std
:
:
fmt
:
:
Display
for
InvalidHeader
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
Invalid
request
header
'
{
}
'
"
self
.
0
)
}
}
impl
StdError
for
InvalidHeader
{
fn
description
(
&
self
)
-
>
&
str
{
"
Invalid
request
header
"
}
}
