use
tracing
:
:
Span
;
use
std
:
:
net
:
:
SocketAddr
;
use
http
:
:
{
self
header
}
;
use
crate
:
:
filter
:
:
{
Filter
WrapSealed
}
;
use
crate
:
:
reject
:
:
IsReject
;
use
crate
:
:
reply
:
:
Reply
;
use
crate
:
:
route
:
:
Route
;
use
self
:
:
internal
:
:
WithTrace
;
pub
fn
request
(
)
-
>
Trace
<
impl
Fn
(
Info
<
'
_
>
)
-
>
Span
+
Clone
>
{
use
tracing
:
:
field
:
:
{
display
Empty
}
;
trace
(
|
info
:
Info
<
'
_
>
|
{
let
span
=
tracing
:
:
info_span
!
(
"
request
"
remote
.
addr
=
Empty
method
=
%
info
.
method
(
)
path
=
%
info
.
path
(
)
version
=
?
info
.
route
.
version
(
)
referer
=
Empty
)
;
if
let
Some
(
remote_addr
)
=
info
.
remote_addr
(
)
{
span
.
record
(
"
remote
.
addr
"
&
display
(
remote_addr
)
)
;
}
if
let
Some
(
referer
)
=
info
.
referer
(
)
{
span
.
record
(
"
referer
"
&
display
(
referer
)
)
;
}
tracing
:
:
debug
!
(
parent
:
&
span
"
received
request
"
)
;
span
}
)
}
pub
fn
trace
<
F
>
(
func
:
F
)
-
>
Trace
<
F
>
where
F
:
Fn
(
Info
<
'
_
>
)
-
>
Span
+
Clone
{
Trace
{
func
}
}
pub
fn
named
(
name
:
&
'
static
str
)
-
>
Trace
<
impl
Fn
(
Info
<
'
_
>
)
-
>
Span
+
Copy
>
{
trace
(
move
|
_
|
tracing
:
:
debug_span
!
(
"
context
"
"
{
}
"
name
)
)
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
struct
Trace
<
F
>
{
func
:
F
}
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Info
<
'
a
>
{
route
:
&
'
a
Route
}
impl
<
FN
F
>
WrapSealed
<
F
>
for
Trace
<
FN
>
where
FN
:
Fn
(
Info
<
'
_
>
)
-
>
Span
+
Clone
+
Send
F
:
Filter
+
Clone
+
Send
F
:
:
Extract
:
Reply
F
:
:
Error
:
IsReject
{
type
Wrapped
=
WithTrace
<
FN
F
>
;
fn
wrap
(
&
self
filter
:
F
)
-
>
Self
:
:
Wrapped
{
WithTrace
{
filter
trace
:
self
.
clone
(
)
}
}
}
impl
<
'
a
>
Info
<
'
a
>
{
pub
fn
remote_addr
(
&
self
)
-
>
Option
<
SocketAddr
>
{
self
.
route
.
remote_addr
(
)
}
pub
fn
method
(
&
self
)
-
>
&
http
:
:
Method
{
self
.
route
.
method
(
)
}
pub
fn
path
(
&
self
)
-
>
&
str
{
self
.
route
.
full_path
(
)
}
pub
fn
version
(
&
self
)
-
>
http
:
:
Version
{
self
.
route
.
version
(
)
}
pub
fn
referer
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
route
.
headers
(
)
.
get
(
header
:
:
REFERER
)
.
and_then
(
|
v
|
v
.
to_str
(
)
.
ok
(
)
)
}
pub
fn
user_agent
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
route
.
headers
(
)
.
get
(
header
:
:
USER_AGENT
)
.
and_then
(
|
v
|
v
.
to_str
(
)
.
ok
(
)
)
}
pub
fn
host
(
&
self
)
-
>
Option
<
&
str
>
{
self
.
route
.
headers
(
)
.
get
(
header
:
:
HOST
)
.
and_then
(
|
v
|
v
.
to_str
(
)
.
ok
(
)
)
}
pub
fn
request_headers
(
&
self
)
-
>
&
http
:
:
HeaderMap
{
self
.
route
.
headers
(
)
}
}
mod
internal
{
use
futures_util
:
:
{
future
:
:
Inspect
future
:
:
MapOk
FutureExt
TryFutureExt
}
;
use
super
:
:
{
Info
Trace
}
;
use
crate
:
:
filter
:
:
{
Filter
FilterBase
Internal
}
;
use
crate
:
:
reject
:
:
IsReject
;
use
crate
:
:
reply
:
:
Reply
;
use
crate
:
:
reply
:
:
Response
;
use
crate
:
:
route
;
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Traced
(
pub
(
super
)
Response
)
;
impl
Reply
for
Traced
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
0
}
}
#
[
allow
(
missing_debug_implementations
)
]
#
[
derive
(
Clone
Copy
)
]
pub
struct
WithTrace
<
FN
F
>
{
pub
(
super
)
filter
:
F
pub
(
super
)
trace
:
Trace
<
FN
>
}
use
tracing
:
:
instrument
:
:
{
Instrument
Instrumented
}
;
use
tracing
:
:
Span
;
fn
finished_logger
<
E
:
IsReject
>
(
reply
:
&
Result
<
(
Traced
)
E
>
)
{
let
(
status
error
)
=
match
reply
{
Ok
(
(
Traced
(
resp
)
)
)
=
>
(
resp
.
status
(
)
None
)
Err
(
error
)
=
>
(
error
.
status
(
)
Some
(
error
)
)
}
;
if
status
.
is_success
(
)
{
tracing
:
:
info
!
(
target
:
"
warp
:
:
filters
:
:
trace
"
status
=
status
.
as_u16
(
)
"
finished
processing
with
success
"
)
;
}
else
if
status
.
is_server_error
(
)
{
tracing
:
:
error
!
(
target
:
"
warp
:
:
filters
:
:
trace
"
status
=
status
.
as_u16
(
)
error
=
?
error
"
unable
to
process
request
(
internal
error
)
"
)
;
}
else
if
status
.
is_client_error
(
)
{
tracing
:
:
warn
!
(
target
:
"
warp
:
:
filters
:
:
trace
"
status
=
status
.
as_u16
(
)
error
=
?
error
"
unable
to
serve
request
(
client
error
)
"
)
;
}
else
{
tracing
:
:
info
!
(
target
:
"
warp
:
:
filters
:
:
trace
"
status
=
status
.
as_u16
(
)
error
=
?
error
"
finished
processing
with
status
"
)
;
}
}
fn
convert_reply
<
R
:
Reply
>
(
reply
:
R
)
-
>
(
Traced
)
{
(
Traced
(
reply
.
into_response
(
)
)
)
}
impl
<
FN
F
>
FilterBase
for
WithTrace
<
FN
F
>
where
FN
:
Fn
(
Info
<
'
_
>
)
-
>
Span
+
Clone
+
Send
F
:
Filter
+
Clone
+
Send
F
:
:
Extract
:
Reply
F
:
:
Error
:
IsReject
{
type
Extract
=
(
Traced
)
;
type
Error
=
F
:
:
Error
;
type
Future
=
Instrumented
<
Inspect
<
MapOk
<
F
:
:
Future
fn
(
F
:
:
Extract
)
-
>
Self
:
:
Extract
>
fn
(
&
Result
<
Self
:
:
Extract
F
:
:
Error
>
)
>
>
;
fn
filter
(
&
self
_
:
Internal
)
-
>
Self
:
:
Future
{
let
span
=
route
:
:
with
(
|
route
|
(
self
.
trace
.
func
)
(
Info
{
route
}
)
)
;
let
_entered
=
span
.
enter
(
)
;
tracing
:
:
info
!
(
target
:
"
warp
:
:
filters
:
:
trace
"
"
processing
request
"
)
;
self
.
filter
.
filter
(
Internal
)
.
map_ok
(
convert_reply
as
fn
(
F
:
:
Extract
)
-
>
Self
:
:
Extract
)
.
inspect
(
finished_logger
as
fn
(
&
Result
<
Self
:
:
Extract
F
:
:
Error
>
)
)
.
instrument
(
span
.
clone
(
)
)
}
}
}
