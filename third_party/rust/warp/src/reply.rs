use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
crate
:
:
generic
:
:
{
Either
One
}
;
use
http
:
:
header
:
:
{
HeaderName
HeaderValue
CONTENT_TYPE
}
;
use
http
:
:
StatusCode
;
use
hyper
:
:
Body
;
use
serde
:
:
Serialize
;
use
serde_json
;
pub
(
crate
)
use
self
:
:
sealed
:
:
Reply_
;
use
self
:
:
sealed
:
:
{
BoxedReply
Internal
}
;
#
[
doc
(
hidden
)
]
pub
use
crate
:
:
filters
:
:
reply
as
with
;
pub
type
Response
=
:
:
http
:
:
Response
<
Body
>
;
#
[
inline
]
pub
fn
reply
(
)
-
>
impl
Reply
{
StatusCode
:
:
OK
}
pub
fn
json
<
T
>
(
val
:
&
T
)
-
>
Json
where
T
:
Serialize
{
Json
{
inner
:
serde_json
:
:
to_vec
(
val
)
.
map_err
(
|
err
|
{
tracing
:
:
error
!
(
"
reply
:
:
json
error
:
{
}
"
err
)
;
}
)
}
}
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Json
{
inner
:
Result
<
Vec
<
u8
>
(
)
>
}
impl
Reply
for
Json
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
.
inner
{
Ok
(
body
)
=
>
{
let
mut
res
=
Response
:
:
new
(
body
.
into
(
)
)
;
res
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
application
/
json
"
)
)
;
res
}
Err
(
(
)
)
=
>
StatusCode
:
:
INTERNAL_SERVER_ERROR
.
into_response
(
)
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
ReplyJsonError
;
impl
fmt
:
:
Display
for
ReplyJsonError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
"
warp
:
:
reply
:
:
json
(
)
failed
"
)
}
}
impl
StdError
for
ReplyJsonError
{
}
pub
fn
html
<
T
>
(
body
:
T
)
-
>
Html
<
T
>
where
Body
:
From
<
T
>
T
:
Send
{
Html
{
body
}
}
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Html
<
T
>
{
body
:
T
}
impl
<
T
>
Reply
for
Html
<
T
>
where
Body
:
From
<
T
>
T
:
Send
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
Response
:
:
new
(
Body
:
:
from
(
self
.
body
)
)
;
res
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
html
;
charset
=
utf
-
8
"
)
)
;
res
}
}
pub
trait
Reply
:
BoxedReply
+
Send
{
fn
into_response
(
self
)
-
>
Response
;
}
impl
<
T
:
Reply
+
?
Sized
>
Reply
for
Box
<
T
>
{
fn
into_response
(
self
)
-
>
Response
{
self
.
boxed_into_response
(
Internal
)
}
}
fn
_assert_object_safe
(
)
{
fn
_assert
(
_
:
&
dyn
Reply
)
{
}
}
pub
fn
with_status
<
T
:
Reply
>
(
reply
:
T
status
:
StatusCode
)
-
>
WithStatus
<
T
>
{
WithStatus
{
reply
status
}
}
#
[
derive
(
Debug
)
]
pub
struct
WithStatus
<
T
>
{
reply
:
T
status
:
StatusCode
}
impl
<
T
:
Reply
>
Reply
for
WithStatus
<
T
>
{
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
self
.
reply
.
into_response
(
)
;
*
res
.
status_mut
(
)
=
self
.
status
;
res
}
}
pub
fn
with_header
<
T
:
Reply
K
V
>
(
reply
:
T
name
:
K
value
:
V
)
-
>
WithHeader
<
T
>
where
HeaderName
:
TryFrom
<
K
>
<
HeaderName
as
TryFrom
<
K
>
>
:
:
Error
:
Into
<
http
:
:
Error
>
HeaderValue
:
TryFrom
<
V
>
<
HeaderValue
as
TryFrom
<
V
>
>
:
:
Error
:
Into
<
http
:
:
Error
>
{
let
header
=
match
<
HeaderName
as
TryFrom
<
K
>
>
:
:
try_from
(
name
)
{
Ok
(
name
)
=
>
match
<
HeaderValue
as
TryFrom
<
V
>
>
:
:
try_from
(
value
)
{
Ok
(
value
)
=
>
Some
(
(
name
value
)
)
Err
(
err
)
=
>
{
let
err
=
err
.
into
(
)
;
tracing
:
:
error
!
(
"
with_header
value
error
:
{
}
"
err
)
;
None
}
}
Err
(
err
)
=
>
{
let
err
=
err
.
into
(
)
;
tracing
:
:
error
!
(
"
with_header
name
error
:
{
}
"
err
)
;
None
}
}
;
WithHeader
{
header
reply
}
}
#
[
derive
(
Debug
)
]
pub
struct
WithHeader
<
T
>
{
header
:
Option
<
(
HeaderName
HeaderValue
)
>
reply
:
T
}
impl
<
T
:
Reply
>
Reply
for
WithHeader
<
T
>
{
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
self
.
reply
.
into_response
(
)
;
if
let
Some
(
(
name
value
)
)
=
self
.
header
{
res
.
headers_mut
(
)
.
insert
(
name
value
)
;
}
res
}
}
impl
<
T
:
Send
>
Reply
for
:
:
http
:
:
Response
<
T
>
where
Body
:
From
<
T
>
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
map
(
Body
:
:
from
)
}
}
impl
Reply
for
:
:
http
:
:
StatusCode
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
Response
:
:
default
(
)
;
*
res
.
status_mut
(
)
=
self
;
res
}
}
impl
<
T
>
Reply
for
Result
<
T
:
:
http
:
:
Error
>
where
T
:
Reply
+
Send
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
Ok
(
t
)
=
>
t
.
into_response
(
)
Err
(
e
)
=
>
{
tracing
:
:
error
!
(
"
reply
error
:
{
:
?
}
"
e
)
;
StatusCode
:
:
INTERNAL_SERVER_ERROR
.
into_response
(
)
}
}
}
}
fn
text_plain
<
T
:
Into
<
Body
>
>
(
body
:
T
)
-
>
Response
{
let
mut
response
=
:
:
http
:
:
Response
:
:
new
(
body
.
into
(
)
)
;
response
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
plain
;
charset
=
utf
-
8
"
)
)
;
response
}
impl
Reply
for
String
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
text_plain
(
self
)
}
}
impl
Reply
for
Vec
<
u8
>
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
:
:
http
:
:
Response
:
:
builder
(
)
.
header
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
application
/
octet
-
stream
"
)
)
.
body
(
Body
:
:
from
(
self
)
)
.
unwrap
(
)
}
}
impl
Reply
for
&
'
static
str
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
text_plain
(
self
)
}
}
impl
Reply
for
Cow
<
'
static
str
>
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
Cow
:
:
Borrowed
(
s
)
=
>
s
.
into_response
(
)
Cow
:
:
Owned
(
s
)
=
>
s
.
into_response
(
)
}
}
}
impl
Reply
for
&
'
static
[
u8
]
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
:
:
http
:
:
Response
:
:
builder
(
)
.
header
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
application
/
octet
-
stream
"
)
)
.
body
(
Body
:
:
from
(
self
)
)
.
unwrap
(
)
}
}
impl
<
T
U
>
Reply
for
Either
<
T
U
>
where
T
:
Reply
U
:
Reply
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
Either
:
:
A
(
a
)
=
>
a
.
into_response
(
)
Either
:
:
B
(
b
)
=
>
b
.
into_response
(
)
}
}
}
impl
<
T
>
Reply
for
One
<
T
>
where
T
:
Reply
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
0
.
into_response
(
)
}
}
impl
Reply
for
std
:
:
convert
:
:
Infallible
{
#
[
inline
(
always
)
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
}
}
}
mod
sealed
{
use
super
:
:
{
Reply
Response
}
;
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Reply_
(
pub
(
crate
)
Response
)
;
impl
Reply
for
Reply_
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
0
}
}
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Internal
;
pub
trait
BoxedReply
{
fn
boxed_into_response
(
self
:
Box
<
Self
>
internal
:
Internal
)
-
>
Response
;
}
impl
<
T
:
Reply
>
BoxedReply
for
T
{
fn
boxed_into_response
(
self
:
Box
<
Self
>
_
:
Internal
)
-
>
Response
{
(
*
self
)
.
into_response
(
)
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
collections
:
:
HashMap
;
use
super
:
:
*
;
#
[
test
]
fn
json_serde_error
(
)
{
let
mut
map
=
HashMap
:
:
new
(
)
;
map
.
insert
(
vec
!
[
1
2
]
45
)
;
let
res
=
json
(
&
map
)
.
into_response
(
)
;
assert_eq
!
(
res
.
status
(
)
500
)
;
}
#
[
test
]
fn
response_builder_error
(
)
{
let
res
=
:
:
http
:
:
Response
:
:
builder
(
)
.
status
(
1337
)
.
body
(
"
woops
"
)
.
into_response
(
)
;
assert_eq
!
(
res
.
status
(
)
500
)
;
}
#
[
test
]
fn
boxed_reply
(
)
{
let
r
:
Box
<
dyn
Reply
>
=
Box
:
:
new
(
reply
(
)
)
;
let
resp
=
r
.
into_response
(
)
;
assert_eq
!
(
resp
.
status
(
)
200
)
;
}
}
