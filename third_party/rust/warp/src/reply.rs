use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
error
:
:
Error
as
StdError
;
use
std
:
:
fmt
;
use
generic
:
:
{
Either
One
}
;
use
http
:
:
header
:
:
{
HeaderName
HeaderValue
CONTENT_TYPE
}
;
use
http
:
:
{
HttpTryFrom
StatusCode
}
;
use
hyper
:
:
Body
;
use
serde
:
:
Serialize
;
use
serde_json
;
use
reject
:
:
Reject
;
pub
(
crate
)
use
self
:
:
sealed
:
:
Reply_
;
#
[
doc
(
hidden
)
]
pub
use
filters
:
:
reply
as
with
;
pub
type
Response
=
:
:
http
:
:
Response
<
Body
>
;
#
[
inline
]
pub
fn
reply
(
)
-
>
impl
Reply
{
StatusCode
:
:
OK
}
pub
fn
json
<
T
>
(
val
:
&
T
)
-
>
impl
Reply
where
T
:
Serialize
{
Json
{
inner
:
serde_json
:
:
to_vec
(
val
)
.
map_err
(
|
err
|
{
error
!
(
"
reply
:
:
json
error
:
{
}
"
err
)
;
}
)
}
}
#
[
allow
(
missing_debug_implementations
)
]
struct
Json
{
inner
:
Result
<
Vec
<
u8
>
(
)
>
}
impl
Reply
for
Json
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
.
inner
{
Ok
(
body
)
=
>
{
let
mut
res
=
Response
:
:
new
(
body
.
into
(
)
)
;
res
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
application
/
json
"
)
)
;
res
}
Err
(
(
)
)
=
>
:
:
reject
:
:
known
(
ReplyJsonError
)
.
into_response
(
)
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
ReplyJsonError
;
impl
fmt
:
:
Display
for
ReplyJsonError
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
self
.
description
(
)
)
}
}
impl
StdError
for
ReplyJsonError
{
fn
description
(
&
self
)
-
>
&
str
{
"
warp
:
:
reply
:
:
json
(
)
failed
"
}
}
pub
fn
html
<
T
>
(
body
:
T
)
-
>
impl
Reply
where
Body
:
From
<
T
>
T
:
Send
{
Html
{
body
}
}
#
[
allow
(
missing_debug_implementations
)
]
struct
Html
<
T
>
{
body
:
T
}
impl
<
T
>
Reply
for
Html
<
T
>
where
Body
:
From
<
T
>
T
:
Send
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
Response
:
:
new
(
Body
:
:
from
(
self
.
body
)
)
;
res
.
headers_mut
(
)
.
insert
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
html
;
charset
=
utf
-
8
"
)
)
;
res
}
}
pub
trait
Reply
:
Send
{
fn
into_response
(
self
)
-
>
Response
;
}
fn
_assert_object_safe
(
)
{
fn
_assert
(
_
:
&
dyn
Reply
)
{
}
}
pub
fn
with_status
<
T
:
Reply
>
(
reply
:
T
status
:
StatusCode
)
-
>
WithStatus
<
T
>
{
WithStatus
{
reply
status
}
}
#
[
derive
(
Debug
)
]
pub
struct
WithStatus
<
T
>
{
reply
:
T
status
:
StatusCode
}
impl
<
T
:
Reply
>
Reply
for
WithStatus
<
T
>
{
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
self
.
reply
.
into_response
(
)
;
*
res
.
status_mut
(
)
=
self
.
status
;
res
}
}
pub
fn
with_header
<
T
:
Reply
K
V
>
(
reply
:
T
name
:
K
value
:
V
)
-
>
WithHeader
<
T
>
where
HeaderName
:
HttpTryFrom
<
K
>
HeaderValue
:
HttpTryFrom
<
V
>
{
let
header
=
match
<
HeaderName
as
HttpTryFrom
<
K
>
>
:
:
try_from
(
name
)
{
Ok
(
name
)
=
>
match
<
HeaderValue
as
HttpTryFrom
<
V
>
>
:
:
try_from
(
value
)
{
Ok
(
value
)
=
>
Some
(
(
name
value
)
)
Err
(
err
)
=
>
{
error
!
(
"
with_header
value
error
:
{
}
"
err
.
into
(
)
)
;
None
}
}
Err
(
err
)
=
>
{
error
!
(
"
with_header
name
error
:
{
}
"
err
.
into
(
)
)
;
None
}
}
;
WithHeader
{
header
reply
}
}
#
[
derive
(
Debug
)
]
pub
struct
WithHeader
<
T
>
{
header
:
Option
<
(
HeaderName
HeaderValue
)
>
reply
:
T
}
impl
<
T
:
Reply
>
Reply
for
WithHeader
<
T
>
{
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
self
.
reply
.
into_response
(
)
;
if
let
Some
(
(
name
value
)
)
=
self
.
header
{
res
.
headers_mut
(
)
.
insert
(
name
value
)
;
}
res
}
}
impl
<
T
:
Send
>
Reply
for
:
:
http
:
:
Response
<
T
>
where
Body
:
From
<
T
>
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
map
(
Body
:
:
from
)
}
}
impl
Reply
for
:
:
http
:
:
StatusCode
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
let
mut
res
=
Response
:
:
default
(
)
;
*
res
.
status_mut
(
)
=
self
;
res
}
}
impl
<
T
>
Reply
for
Result
<
T
:
:
http
:
:
Error
>
where
T
:
Reply
+
Send
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
Ok
(
t
)
=
>
t
.
into_response
(
)
Err
(
e
)
=
>
{
error
!
(
"
reply
error
:
{
:
?
}
"
e
)
;
:
:
reject
:
:
known
(
ReplyHttpError
(
e
)
)
.
into_response
(
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
ReplyHttpError
(
:
:
http
:
:
Error
)
;
impl
:
:
std
:
:
fmt
:
:
Display
for
ReplyHttpError
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
http
:
:
Response
:
:
builder
error
:
{
}
"
self
.
0
)
}
}
impl
StdError
for
ReplyHttpError
{
fn
description
(
&
self
)
-
>
&
str
{
"
http
:
:
Response
:
:
builder
error
"
}
}
impl
Reply
for
String
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
:
:
http
:
:
Response
:
:
builder
(
)
.
header
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
plain
;
charset
=
utf
-
8
"
)
)
.
body
(
Body
:
:
from
(
self
)
)
.
unwrap
(
)
}
}
impl
Reply
for
Vec
<
u8
>
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
:
:
http
:
:
Response
:
:
builder
(
)
.
header
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
application
/
octet
-
stream
"
)
)
.
body
(
Body
:
:
from
(
self
)
)
.
unwrap
(
)
}
}
impl
Reply
for
&
'
static
str
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
:
:
http
:
:
Response
:
:
builder
(
)
.
header
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
text
/
plain
;
charset
=
utf
-
8
"
)
)
.
body
(
Body
:
:
from
(
self
)
)
.
unwrap
(
)
}
}
impl
Reply
for
Cow
<
'
static
str
>
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
Cow
:
:
Borrowed
(
s
)
=
>
s
.
into_response
(
)
Cow
:
:
Owned
(
s
)
=
>
s
.
into_response
(
)
}
}
}
impl
Reply
for
&
'
static
[
u8
]
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
:
:
http
:
:
Response
:
:
builder
(
)
.
header
(
CONTENT_TYPE
HeaderValue
:
:
from_static
(
"
application
/
octet
-
stream
"
)
)
.
body
(
Body
:
:
from
(
self
)
)
.
unwrap
(
)
}
}
impl
<
T
U
>
Reply
for
Either
<
T
U
>
where
T
:
Reply
U
:
Reply
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
Either
:
:
A
(
a
)
=
>
a
.
into_response
(
)
Either
:
:
B
(
b
)
=
>
b
.
into_response
(
)
}
}
}
impl
<
T
>
Reply
for
One
<
T
>
where
T
:
Reply
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
0
.
into_response
(
)
}
}
impl
Reply
for
:
:
never
:
:
Never
{
#
[
inline
(
always
)
]
fn
into_response
(
self
)
-
>
Response
{
match
self
{
}
}
}
mod
sealed
{
use
super
:
:
{
Reply
Response
}
;
#
[
allow
(
missing_debug_implementations
)
]
pub
struct
Reply_
(
pub
(
crate
)
Response
)
;
impl
Reply
for
Reply_
{
#
[
inline
]
fn
into_response
(
self
)
-
>
Response
{
self
.
0
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
collections
:
:
HashMap
;
use
super
:
:
*
;
#
[
test
]
fn
json_serde_error
(
)
{
let
mut
map
=
HashMap
:
:
new
(
)
;
map
.
insert
(
vec
!
[
1
2
]
45
)
;
let
res
=
json
(
&
map
)
.
into_response
(
)
;
assert_eq
!
(
res
.
status
(
)
500
)
;
}
#
[
test
]
fn
response_builder_error
(
)
{
let
res
=
:
:
http
:
:
Response
:
:
builder
(
)
.
status
(
1337
)
.
body
(
"
woops
"
)
.
into_response
(
)
;
assert_eq
!
(
res
.
status
(
)
500
)
;
}
}
