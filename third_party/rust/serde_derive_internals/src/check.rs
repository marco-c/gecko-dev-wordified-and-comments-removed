use
ast
:
:
{
Body
Container
Style
}
;
use
attr
:
:
Identifier
;
use
Ctxt
;
pub
fn
check
(
cx
:
&
Ctxt
cont
:
&
Container
)
{
check_getter
(
cx
cont
)
;
check_identifier
(
cx
cont
)
;
check_variant_skip_attrs
(
cx
cont
)
;
}
fn
check_getter
(
cx
:
&
Ctxt
cont
:
&
Container
)
{
match
cont
.
body
{
Body
:
:
Enum
(
_
_
)
=
>
{
if
cont
.
body
.
has_getter
(
)
{
cx
.
error
(
"
#
[
serde
(
getter
=
\
"
.
.
.
\
"
)
]
is
not
allowed
in
an
enum
"
)
;
}
}
Body
:
:
Struct
(
_
_
)
=
>
{
if
cont
.
body
.
has_getter
(
)
&
&
cont
.
attrs
.
remote
(
)
.
is_none
(
)
{
cx
.
error
(
"
#
[
serde
(
getter
=
\
"
.
.
.
\
"
)
]
can
only
be
used
in
structs
\
that
have
#
[
serde
(
remote
=
\
"
.
.
.
\
"
)
]
"
)
;
}
}
}
}
fn
check_identifier
(
cx
:
&
Ctxt
cont
:
&
Container
)
{
let
variants
=
match
cont
.
body
{
Body
:
:
Enum
(
_
ref
variants
)
=
>
variants
Body
:
:
Struct
(
_
_
)
=
>
{
return
;
}
}
;
for
(
i
variant
)
in
variants
.
iter
(
)
.
enumerate
(
)
{
match
(
variant
.
style
cont
.
attrs
.
identifier
(
)
variant
.
attrs
.
other
(
)
)
{
(
_
Identifier
:
:
Variant
true
)
|
(
_
Identifier
:
:
No
true
)
=
>
{
cx
.
error
(
"
#
[
serde
(
other
)
]
may
only
be
used
inside
a
field_identifier
"
)
;
}
(
Style
:
:
Unit
Identifier
:
:
Field
true
)
=
>
{
if
i
<
variants
.
len
(
)
-
1
{
cx
.
error
(
"
#
[
serde
(
other
)
]
must
be
the
last
variant
"
)
;
}
}
(
_
Identifier
:
:
Field
true
)
=
>
{
cx
.
error
(
"
#
[
serde
(
other
)
]
must
be
on
a
unit
variant
"
)
;
}
(
_
Identifier
:
:
No
false
)
=
>
{
}
(
Style
:
:
Unit
_
false
)
=
>
{
}
(
Style
:
:
Newtype
Identifier
:
:
Field
false
)
=
>
{
if
i
<
variants
.
len
(
)
-
1
{
cx
.
error
(
format
!
(
"
{
}
must
be
the
last
variant
"
variant
.
ident
)
)
;
}
}
(
_
Identifier
:
:
Field
false
)
=
>
{
cx
.
error
(
"
field_identifier
may
only
contain
unit
variants
"
)
;
}
(
_
Identifier
:
:
Variant
false
)
=
>
{
cx
.
error
(
"
variant_identifier
may
only
contain
unit
variants
"
)
;
}
}
}
}
fn
check_variant_skip_attrs
(
cx
:
&
Ctxt
cont
:
&
Container
)
{
let
variants
=
match
cont
.
body
{
Body
:
:
Enum
(
_
ref
variants
)
=
>
variants
Body
:
:
Struct
(
_
_
)
=
>
{
return
;
}
}
;
for
variant
in
variants
.
iter
(
)
{
if
variant
.
attrs
.
serialize_with
(
)
.
is_some
(
)
{
if
variant
.
attrs
.
skip_serializing
(
)
{
cx
.
error
(
format
!
(
"
variant
{
}
cannot
have
both
#
[
serde
(
serialize_with
)
]
and
\
#
[
serde
(
skip_serializing
)
]
"
variant
.
ident
)
)
;
}
for
(
i
field
)
in
variant
.
fields
.
iter
(
)
.
enumerate
(
)
{
let
ident
=
field
.
ident
.
as_ref
(
)
.
map_or_else
(
|
|
format
!
(
"
{
}
"
i
)
|
ident
|
format
!
(
"
{
}
"
ident
)
)
;
if
field
.
attrs
.
skip_serializing
(
)
{
cx
.
error
(
format
!
(
"
variant
{
}
cannot
have
both
#
[
serde
(
serialize_with
)
]
and
\
a
field
{
}
marked
with
#
[
serde
(
skip_serializing
)
]
"
variant
.
ident
ident
)
)
;
}
if
field
.
attrs
.
skip_serializing_if
(
)
.
is_some
(
)
{
cx
.
error
(
format
!
(
"
variant
{
}
cannot
have
both
#
[
serde
(
serialize_with
)
]
and
\
a
field
{
}
marked
with
#
[
serde
(
skip_serializing_if
)
]
"
variant
.
ident
ident
)
)
;
}
}
}
if
variant
.
attrs
.
deserialize_with
(
)
.
is_some
(
)
{
if
variant
.
attrs
.
skip_deserializing
(
)
{
cx
.
error
(
format
!
(
"
variant
{
}
cannot
have
both
#
[
serde
(
deserialize_with
)
]
and
\
#
[
serde
(
skip_deserializing
)
]
"
variant
.
ident
)
)
;
}
for
(
i
field
)
in
variant
.
fields
.
iter
(
)
.
enumerate
(
)
{
if
field
.
attrs
.
skip_deserializing
(
)
{
let
ident
=
field
.
ident
.
as_ref
(
)
.
map_or_else
(
|
|
format
!
(
"
{
}
"
i
)
|
ident
|
format
!
(
"
{
}
"
ident
)
)
;
cx
.
error
(
format
!
(
"
variant
{
}
cannot
have
both
#
[
serde
(
deserialize_with
)
]
\
and
a
field
{
}
marked
with
#
[
serde
(
skip_deserializing
)
]
"
variant
.
ident
ident
)
)
;
}
}
}
}
}
