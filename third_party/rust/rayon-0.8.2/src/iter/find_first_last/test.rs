use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
super
:
:
*
;
#
[
test
]
fn
same_range_first_consumers_return_correct_answer
(
)
{
let
find_op
=
|
x
:
&
i32
|
x
%
2
=
=
0
;
let
first_found
=
AtomicUsize
:
:
new
(
usize
:
:
max_value
(
)
)
;
let
far_right_consumer
=
FindConsumer
:
:
new
(
&
find_op
MatchPosition
:
:
Leftmost
&
first_found
)
;
let
consumer
=
far_right_consumer
.
split_off_left
(
)
;
let
bits_in_usize
=
usize
:
:
min_value
(
)
.
count_zeros
(
)
;
for
_
in
0
.
.
bits_in_usize
{
consumer
.
split_off_left
(
)
;
}
let
reducer
=
consumer
.
to_reducer
(
)
;
let
left_folder
=
consumer
.
split_off_left
(
)
.
into_folder
(
)
;
let
right_folder
=
consumer
.
into_folder
(
)
;
let
left_folder
=
left_folder
.
consume
(
0
)
.
consume
(
1
)
;
assert_eq
!
(
left_folder
.
boundary
right_folder
.
boundary
)
;
assert
!
(
!
right_folder
.
full
(
)
)
;
assert
!
(
far_right_consumer
.
full
(
)
)
;
let
right_folder
=
right_folder
.
consume
(
2
)
.
consume
(
3
)
;
assert_eq
!
(
reducer
.
reduce
(
left_folder
.
complete
(
)
right_folder
.
complete
(
)
)
Some
(
0
)
)
;
}
#
[
test
]
fn
same_range_last_consumers_return_correct_answer
(
)
{
let
find_op
=
|
x
:
&
i32
|
x
%
2
=
=
0
;
let
last_found
=
AtomicUsize
:
:
new
(
0
)
;
let
consumer
=
FindConsumer
:
:
new
(
&
find_op
MatchPosition
:
:
Rightmost
&
last_found
)
;
let
far_left_consumer
=
consumer
.
split_off_left
(
)
;
let
bits_in_usize
=
usize
:
:
min_value
(
)
.
count_zeros
(
)
;
for
_
in
0
.
.
bits_in_usize
{
consumer
.
split_off_left
(
)
;
}
let
reducer
=
consumer
.
to_reducer
(
)
;
let
consumer
=
consumer
.
split_off_left
(
)
;
let
left_folder
=
consumer
.
split_off_left
(
)
.
into_folder
(
)
;
let
right_folder
=
consumer
.
into_folder
(
)
;
let
right_folder
=
right_folder
.
consume
(
2
)
.
consume
(
3
)
;
assert_eq
!
(
left_folder
.
boundary
right_folder
.
boundary
)
;
assert
!
(
!
left_folder
.
full
(
)
)
;
assert
!
(
far_left_consumer
.
full
(
)
)
;
let
left_folder
=
left_folder
.
consume
(
0
)
.
consume
(
1
)
;
assert_eq
!
(
reducer
.
reduce
(
left_folder
.
complete
(
)
right_folder
.
complete
(
)
)
Some
(
2
)
)
;
}
#
[
test
]
fn
find_first_folder_does_not_clobber_first_found
(
)
{
let
best_found
=
AtomicUsize
:
:
new
(
usize
:
:
max_value
(
)
)
;
let
f
=
FindFolder
{
find_op
:
&
(
|
&
_
:
&
i32
|
-
>
bool
{
true
}
)
boundary
:
0
match_position
:
MatchPosition
:
:
Leftmost
best_found
:
&
best_found
item
:
None
}
;
let
f
=
f
.
consume
(
0_i32
)
.
consume
(
1_i32
)
.
consume
(
2_i32
)
;
assert
!
(
f
.
full
(
)
)
;
assert_eq
!
(
f
.
complete
(
)
Some
(
0_i32
)
)
;
}
#
[
test
]
fn
find_last_folder_yields_last_match
(
)
{
let
best_found
=
AtomicUsize
:
:
new
(
0
)
;
let
f
=
FindFolder
{
find_op
:
&
(
|
&
_
:
&
i32
|
-
>
bool
{
true
}
)
boundary
:
0
match_position
:
MatchPosition
:
:
Rightmost
best_found
:
&
best_found
item
:
None
}
;
let
f
=
f
.
consume
(
0_i32
)
.
consume
(
1_i32
)
.
consume
(
2_i32
)
;
assert_eq
!
(
f
.
complete
(
)
Some
(
2_i32
)
)
;
}
fn
octillion
(
)
-
>
impl
ParallelIterator
<
Item
=
u128
>
{
(
0u32
.
.
1_000_000_000
)
.
into_par_iter
(
)
.
with_max_len
(
1_000
)
.
map
(
|
i
|
i
as
u64
*
1_000_000_000
)
.
flat_map
(
|
i
|
{
(
0u32
.
.
1_000_000_000
)
.
into_par_iter
(
)
.
with_max_len
(
1_000
)
.
map
(
move
|
j
|
i
+
j
as
u64
)
}
)
.
map
(
|
i
|
i
as
u128
*
1_000_000_000
)
.
flat_map
(
|
i
|
{
(
0u32
.
.
1_000_000_000
)
.
into_par_iter
(
)
.
with_max_len
(
1_000
)
.
map
(
move
|
j
|
i
+
j
as
u128
)
}
)
}
#
[
test
]
fn
find_first_octillion
(
)
{
let
x
=
octillion
(
)
.
find_first
(
|
_
|
true
)
;
assert_eq
!
(
x
Some
(
0
)
)
;
}
#
[
test
]
fn
find_last_octillion
(
)
{
let
config
=
:
:
Configuration
:
:
new
(
)
.
num_threads
(
2
)
;
let
pool
=
:
:
ThreadPool
:
:
new
(
config
)
.
unwrap
(
)
;
let
x
=
pool
.
install
(
|
|
octillion
(
)
.
find_last
(
|
_
|
true
)
)
;
assert_eq
!
(
x
Some
(
999999999999999999999999999
)
)
;
}
