use
nss
;
use
{
CoseError
Signature
SignatureAlgorithm
SignatureParameters
}
;
use
std
:
:
collections
:
:
BTreeMap
;
use
cbor
:
:
CborType
;
use
cose
:
:
util
:
:
get_sig_struct_bytes
;
use
cose
:
:
decoder
:
:
decode_signature
;
use
cose
:
:
decoder
:
:
{
COSE_TYPE_ES256
COSE_TYPE_ES384
COSE_TYPE_ES512
COSE_TYPE_PS256
}
;
pub
fn
signature_type_to_cbor_value
(
signature_type
:
&
SignatureAlgorithm
)
-
>
CborType
{
CborType
:
:
SignedInteger
(
match
signature_type
{
&
SignatureAlgorithm
:
:
ES256
=
>
COSE_TYPE_ES256
&
SignatureAlgorithm
:
:
ES384
=
>
COSE_TYPE_ES384
&
SignatureAlgorithm
:
:
ES512
=
>
COSE_TYPE_ES512
&
SignatureAlgorithm
:
:
PS256
=
>
COSE_TYPE_PS256
}
)
}
pub
fn
build_protected_sig_header
(
ee_cert
:
&
[
u8
]
alg
:
&
SignatureAlgorithm
)
-
>
CborType
{
let
mut
header_map
:
BTreeMap
<
CborType
CborType
>
=
BTreeMap
:
:
new
(
)
;
let
signature_type_value
=
signature_type_to_cbor_value
(
alg
)
;
header_map
.
insert
(
CborType
:
:
Integer
(
1
)
signature_type_value
)
;
header_map
.
insert
(
CborType
:
:
Integer
(
4
)
CborType
:
:
Bytes
(
ee_cert
.
to_vec
(
)
)
)
;
let
header_map
=
CborType
:
:
Map
(
header_map
)
.
serialize
(
)
;
CborType
:
:
Bytes
(
header_map
)
}
pub
fn
build_protected_header
(
cert_chain
:
&
[
&
[
u8
]
]
)
-
>
CborType
{
let
mut
cert_array
:
Vec
<
CborType
>
=
Vec
:
:
new
(
)
;
for
cert
in
cert_chain
{
cert_array
.
push
(
CborType
:
:
Bytes
(
cert
.
to_vec
(
)
)
)
;
}
let
mut
protected_body_header
:
BTreeMap
<
CborType
CborType
>
=
BTreeMap
:
:
new
(
)
;
protected_body_header
.
insert
(
CborType
:
:
Integer
(
4
)
CborType
:
:
Array
(
cert_array
)
)
;
let
protected_body_header
=
CborType
:
:
Map
(
protected_body_header
)
.
serialize
(
)
;
CborType
:
:
Bytes
(
protected_body_header
)
}
pub
fn
build_sig_struct
(
ee_cert
:
&
[
u8
]
alg
:
&
SignatureAlgorithm
sig_bytes
:
&
Vec
<
u8
>
)
-
>
CborType
{
let
mut
signature_item
:
Vec
<
CborType
>
=
Vec
:
:
new
(
)
;
signature_item
.
push
(
build_protected_sig_header
(
ee_cert
alg
)
)
;
let
empty_map
:
BTreeMap
<
CborType
CborType
>
=
BTreeMap
:
:
new
(
)
;
signature_item
.
push
(
CborType
:
:
Map
(
empty_map
)
)
;
signature_item
.
push
(
CborType
:
:
Bytes
(
sig_bytes
.
clone
(
)
)
)
;
CborType
:
:
Array
(
signature_item
)
}
pub
fn
build_cose_signature
(
cert_chain
:
&
[
&
[
u8
]
]
signature_vec
:
&
Vec
<
Signature
>
)
-
>
Vec
<
u8
>
{
let
mut
cose_signature
:
Vec
<
CborType
>
=
Vec
:
:
new
(
)
;
cose_signature
.
push
(
build_protected_header
(
cert_chain
)
)
;
let
empty_map
:
BTreeMap
<
CborType
CborType
>
=
BTreeMap
:
:
new
(
)
;
cose_signature
.
push
(
CborType
:
:
Map
(
empty_map
)
)
;
cose_signature
.
push
(
CborType
:
:
Null
)
;
let
mut
signatures
:
Vec
<
CborType
>
=
Vec
:
:
new
(
)
;
for
signature
in
signature_vec
{
let
signature_item
=
build_sig_struct
(
signature
.
parameter
.
certificate
&
signature
.
parameter
.
algorithm
&
signature
.
signature_bytes
)
;
signatures
.
push
(
signature_item
)
;
}
cose_signature
.
push
(
CborType
:
:
Array
(
signatures
)
)
;
let
signature_struct
=
CborType
:
:
Tag
(
98
Box
:
:
new
(
CborType
:
:
Array
(
cose_signature
)
.
clone
(
)
)
)
;
return
signature_struct
.
serialize
(
)
;
}
pub
fn
sign
(
payload
:
&
[
u8
]
cert_chain
:
&
[
&
[
u8
]
]
parameters
:
&
Vec
<
SignatureParameters
>
)
-
>
Result
<
Vec
<
u8
>
CoseError
>
{
assert
!
(
parameters
.
len
(
)
>
0
)
;
if
parameters
.
len
(
)
<
1
{
return
Err
(
CoseError
:
:
InvalidArgument
)
;
}
let
mut
signatures
:
Vec
<
Signature
>
=
Vec
:
:
new
(
)
;
for
param
in
parameters
{
let
protected_sig_header_serialized
=
build_protected_sig_header
(
param
.
certificate
&
param
.
algorithm
)
;
let
protected_header_serialized
=
build_protected_header
(
cert_chain
)
;
let
payload
=
get_sig_struct_bytes
(
protected_header_serialized
protected_sig_header_serialized
payload
)
;
let
signature_bytes
=
match
nss
:
:
sign
(
&
param
.
algorithm
&
param
.
pkcs8
&
payload
)
{
Err
(
_
)
=
>
return
Err
(
CoseError
:
:
SigningFailed
)
Ok
(
signature
)
=
>
signature
}
;
let
signature
=
Signature
{
parameter
:
param
signature_bytes
:
signature_bytes
}
;
signatures
.
push
(
signature
)
;
}
assert
!
(
signatures
.
len
(
)
>
0
)
;
if
signatures
.
len
(
)
<
1
{
return
Err
(
CoseError
:
:
MalformedInput
)
;
}
let
cose_signature
=
build_cose_signature
(
cert_chain
&
signatures
)
;
Ok
(
cose_signature
)
}
pub
fn
verify_signature
(
payload
:
&
[
u8
]
cose_signature
:
Vec
<
u8
>
)
-
>
Result
<
(
)
CoseError
>
{
let
cose_signatures
=
decode_signature
(
&
cose_signature
payload
)
?
;
if
cose_signatures
.
len
(
)
<
1
{
return
Err
(
CoseError
:
:
MalformedInput
)
;
}
for
signature
in
cose_signatures
{
let
signature_algorithm
=
&
signature
.
signature_type
;
let
signature_bytes
=
&
signature
.
signature
;
let
real_payload
=
&
signature
.
to_verify
;
let
verify_result
=
nss
:
:
verify_signature
(
&
signature_algorithm
&
signature
.
signer_cert
real_payload
signature_bytes
)
;
if
!
verify_result
.
is_ok
(
)
{
return
Err
(
CoseError
:
:
VerificationFailed
)
;
}
}
Ok
(
(
)
)
}
