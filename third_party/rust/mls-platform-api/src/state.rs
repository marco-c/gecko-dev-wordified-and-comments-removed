use
std
:
:
{
collections
:
:
HashMap
path
:
:
Path
sync
:
:
{
Arc
Mutex
}
}
;
use
mls_rs
:
:
{
client_builder
:
:
MlsConfig
crypto
:
:
{
SignaturePublicKey
SignatureSecretKey
}
error
:
:
IntoAnyError
identity
:
:
{
Credential
SigningIdentity
}
mls_rules
:
:
{
CommitOptions
DefaultMlsRules
}
storage_provider
:
:
KeyPackageData
CipherSuite
Client
ProtocolVersion
}
;
use
crate
:
:
ClientConfig
;
use
mls_rs_provider_sqlite
:
:
{
connection_strategy
:
:
{
CipheredConnectionStrategy
ConnectionStrategy
FileConnectionStrategy
SqlCipherConfig
SqlCipherKey
}
SqLiteDataStorageEngine
}
;
use
crate
:
:
{
Identity
PlatformError
}
;
#
[
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
Clone
)
]
pub
struct
GroupData
{
state_data
:
Vec
<
u8
>
epoch_data
:
HashMap
<
u64
Vec
<
u8
>
>
}
#
[
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
Clone
)
]
pub
struct
PlatformState
{
pub
db_path
:
String
pub
db_key
:
[
u8
;
32
]
}
#
[
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
Clone
Default
)
]
pub
struct
TemporaryState
{
pub
groups
:
Arc
<
Mutex
<
HashMap
<
Vec
<
u8
>
GroupData
>
>
>
pub
sigkeys
:
HashMap
<
Vec
<
u8
>
SignatureData
>
pub
key_packages
:
Arc
<
Mutex
<
HashMap
<
Vec
<
u8
>
KeyPackageData
>
>
>
}
#
[
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
Clone
)
]
pub
struct
SignatureData
{
#
[
serde
(
with
=
"
hex
:
:
serde
"
)
]
pub
public_key
:
Vec
<
u8
>
pub
cs
:
u16
#
[
serde
(
with
=
"
hex
:
:
serde
"
)
]
pub
secret_key
:
Vec
<
u8
>
pub
credential
:
Option
<
Credential
>
}
impl
PlatformState
{
pub
fn
new
(
db_path
:
&
str
db_key
:
&
[
u8
;
32
]
)
-
>
Result
<
Self
PlatformError
>
{
let
state
=
Self
{
db_path
:
db_path
.
to_string
(
)
db_key
:
*
db_key
}
;
state
.
get_sqlite_engine
(
)
?
.
application_data_storage
(
)
.
map_err
(
|
e
|
(
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
)
?
;
Ok
(
state
)
}
pub
fn
get_signing_identities
(
&
self
)
-
>
Result
<
Vec
<
Identity
>
PlatformError
>
{
todo
!
(
)
;
}
pub
fn
client
(
&
self
myself_identifier
:
&
[
u8
]
myself_credential
:
Option
<
Credential
>
version
:
ProtocolVersion
config
:
&
ClientConfig
)
-
>
Result
<
Client
<
impl
MlsConfig
>
PlatformError
>
{
let
crypto_provider
=
mls_rs_crypto_nss
:
:
NssCryptoProvider
:
:
default
(
)
;
let
engine
=
self
.
get_sqlite_engine
(
)
?
.
with_context
(
myself_identifier
.
to_vec
(
)
)
;
let
mut
myself_sig_data
=
self
.
get_sig_data
(
myself_identifier
)
?
.
ok_or
(
PlatformError
:
:
UnavailableSecret
)
?
;
let
myself_credential
=
if
let
Some
(
cred
)
=
myself_credential
{
myself_sig_data
.
credential
=
Some
(
cred
.
clone
(
)
)
;
self
.
store_sigdata
(
myself_identifier
&
myself_sig_data
)
?
;
cred
}
else
if
let
Some
(
cred
)
=
myself_sig_data
.
credential
{
cred
}
else
{
return
Err
(
PlatformError
:
:
UndefinedIdentity
)
;
}
;
let
myself_signing_identity
=
SigningIdentity
:
:
new
(
myself_credential
myself_sig_data
.
public_key
.
into
(
)
)
;
let
mut
builder
=
mls_rs
:
:
client_builder
:
:
ClientBuilder
:
:
new_sqlite
(
engine
)
.
map_err
(
|
e
|
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
?
.
crypto_provider
(
crypto_provider
)
.
identity_provider
(
mls_rs
:
:
identity
:
:
basic
:
:
BasicIdentityProvider
)
.
signing_identity
(
myself_signing_identity
myself_sig_data
.
secret_key
.
into
(
)
myself_sig_data
.
cs
.
into
(
)
)
.
protocol_version
(
version
)
;
if
let
Some
(
key_package_extensions
)
=
&
config
.
key_package_extensions
{
builder
=
builder
.
key_package_extensions
(
key_package_extensions
.
clone
(
)
)
;
}
;
if
let
Some
(
leaf_node_extensions
)
=
&
config
.
leaf_node_extensions
{
builder
=
builder
.
leaf_node_extensions
(
leaf_node_extensions
.
clone
(
)
)
;
}
if
let
Some
(
key_package_lifetime_s
)
=
config
.
key_package_lifetime_s
{
builder
=
builder
.
key_package_lifetime
(
key_package_lifetime_s
)
;
}
let
mls_rules
=
DefaultMlsRules
:
:
new
(
)
.
with_commit_options
(
CommitOptions
:
:
default
(
)
.
with_allow_external_commit
(
config
.
allow_external_commits
)
)
;
builder
=
builder
.
mls_rules
(
mls_rules
)
;
Ok
(
builder
.
build
(
)
)
}
pub
fn
client_default
(
&
self
myself_identifier
:
&
[
u8
]
)
-
>
Result
<
Client
<
impl
MlsConfig
>
PlatformError
>
{
self
.
client
(
myself_identifier
None
ProtocolVersion
:
:
MLS_10
&
Default
:
:
default
(
)
)
}
pub
fn
insert_sigkey
(
&
self
myself_sigkey
:
&
SignatureSecretKey
myself_pubkey
:
&
SignaturePublicKey
cs
:
CipherSuite
identifier
:
&
[
u8
]
)
-
>
Result
<
(
)
PlatformError
>
{
let
signature_data
=
SignatureData
{
public_key
:
myself_pubkey
.
to_vec
(
)
cs
:
*
cs
secret_key
:
myself_sigkey
.
to_vec
(
)
credential
:
None
}
;
self
.
store_sigdata
(
identifier
&
signature_data
)
?
;
Ok
(
(
)
)
}
fn
store_sigdata
(
&
self
identifier
:
&
[
u8
]
data
:
&
SignatureData
)
-
>
Result
<
(
)
PlatformError
>
{
let
data
=
bincode
:
:
serialize
(
&
data
)
?
;
let
engine
=
self
.
get_sqlite_engine
(
)
?
;
let
storage
=
engine
.
application_data_storage
(
)
.
map_err
(
|
e
|
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
?
;
storage
.
insert
(
hex
:
:
encode
(
identifier
)
data
)
.
map_err
(
|
e
|
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
?
;
Ok
(
(
)
)
}
pub
fn
get_sig_data
(
&
self
myself_identifier
:
&
[
u8
]
)
-
>
Result
<
Option
<
SignatureData
>
PlatformError
>
{
let
key
=
myself_identifier
.
to_vec
(
)
;
let
engine
=
self
.
get_sqlite_engine
(
)
?
;
let
storage
=
engine
.
application_data_storage
(
)
.
map_err
(
|
e
|
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
?
;
storage
.
get
(
&
hex
:
:
encode
(
key
)
)
.
map_err
(
|
e
|
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
?
.
map_or_else
(
|
|
Ok
(
None
)
|
data
|
bincode
:
:
deserialize
(
&
data
)
.
map
(
Some
)
.
map_err
(
Into
:
:
into
)
)
}
pub
fn
get_sqlite_engine
(
&
self
)
-
>
Result
<
SqLiteDataStorageEngine
<
impl
ConnectionStrategy
>
PlatformError
>
{
let
path
=
Path
:
:
new
(
&
self
.
db_path
)
;
let
file_conn
=
FileConnectionStrategy
:
:
new
(
path
)
;
let
cipher_config
=
SqlCipherConfig
:
:
new
(
SqlCipherKey
:
:
RawKey
(
self
.
db_key
)
)
;
let
cipher_conn
=
CipheredConnectionStrategy
:
:
new
(
file_conn
cipher_config
)
;
SqLiteDataStorageEngine
:
:
new
(
cipher_conn
)
.
map_err
(
|
e
|
PlatformError
:
:
StorageError
(
e
.
into_any_error
(
)
)
)
}
pub
fn
delete_group
(
&
self
gid
:
&
[
u8
]
identifier
:
&
[
u8
]
)
-
>
Result
<
(
)
PlatformError
>
{
let
storage
=
self
.
get_sqlite_engine
(
)
?
.
with_context
(
identifier
.
to_vec
(
)
)
.
group_state_storage
(
)
.
map_err
(
|
_
|
PlatformError
:
:
InternalError
)
?
;
storage
.
delete_group
(
gid
)
.
map_err
(
|
_
|
PlatformError
:
:
InternalError
)
}
pub
fn
delete
(
db_path
:
&
str
)
-
>
Result
<
(
)
PlatformError
>
{
let
path
=
Path
:
:
new
(
db_path
)
;
if
path
.
exists
(
)
{
std
:
:
fs
:
:
remove_file
(
path
)
?
;
}
Ok
(
(
)
)
}
}
