#
[
macro_export
]
macro_rules
!
tag_s
(
(
i
:
expr
tag
:
expr
)
=
>
(
{
tag
!
(
i
tag
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
tag_no_case_s
(
(
i
:
expr
tag
:
expr
)
=
>
(
{
tag_no_case
!
(
i
tag
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_s
(
(
i
:
expr
count
:
expr
)
=
>
(
{
let
input
=
i
;
let
cnt
=
count
as
usize
;
take
!
(
input
cnt
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
is_not_s
(
(
input
:
expr
arr
:
expr
)
=
>
(
{
is_not
!
(
input
arr
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
is_a_s
(
(
input
:
expr
arr
:
expr
)
=
>
(
{
is_a
!
(
input
arr
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_while_s
(
(
input
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
take_while
!
(
input
submac
!
(
(
args
)
*
)
)
}
)
;
(
input
:
expr
f
:
expr
)
=
>
(
take_while_s
!
(
input
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_while1_s
(
(
input
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
take_while1
!
(
input
submac
!
(
(
args
)
*
)
)
)
;
(
input
:
expr
f
:
expr
)
=
>
(
take_while1_s
!
(
input
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_till_s
(
(
input
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
take_till
!
(
input
submac
!
(
(
args
)
*
)
)
}
)
;
(
input
:
expr
f
:
expr
)
=
>
(
take_till_s
!
(
input
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_till1_s
(
(
input
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
take_till1
!
(
input
submac
!
(
(
args
)
*
)
)
}
)
;
(
input
:
expr
f
:
expr
)
=
>
(
take_till1_s
!
(
input
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_until_and_consume_s
(
(
input
:
expr
substr
:
expr
)
=
>
(
{
take_until_and_consume
!
(
input
substr
)
}
)
;
)
;
#
[
macro_export
]
macro_rules
!
take_until_s
(
(
input
:
expr
substr
:
expr
)
=
>
(
{
take_until
!
(
input
substr
)
}
)
;
)
;
#
[
cfg
(
test
)
]
mod
test
{
use
:
:
IResult
;
#
[
test
]
fn
tag_str_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
Hello
World
!
"
;
const
TAG
:
&
'
static
str
=
"
Hello
"
;
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
tag_s
!
(
input
TAG
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
"
World
!
"
"
Parser
tag_s
consumed
leftover
input
.
"
)
;
assert
!
(
output
=
=
TAG
"
Parser
tag_s
doesn
'
t
return
the
tag
it
matched
on
success
.
\
Expected
{
}
got
{
}
.
"
TAG
output
)
;
}
other
=
>
panic
!
(
"
Parser
tag_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
tag_str_incomplete
(
)
{
const
INPUT
:
&
'
static
str
=
"
Hello
"
;
const
TAG
:
&
'
static
str
=
"
Hello
World
!
"
;
match
tag_s
!
(
INPUT
TAG
)
{
IResult
:
:
Incomplete
(
_
)
=
>
(
)
other
=
>
{
panic
!
(
"
Parser
tag_s
didn
'
t
require
more
input
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
;
}
}
;
}
#
[
test
]
fn
tag_str_error
(
)
{
const
INPUT
:
&
'
static
str
=
"
Hello
World
!
"
;
const
TAG
:
&
'
static
str
=
"
Random
"
;
match
tag_s
!
(
INPUT
TAG
)
{
IResult
:
:
Error
(
_
)
=
>
(
)
other
=
>
{
panic
!
(
"
Parser
tag_s
didn
'
t
fail
when
it
should
have
.
Got
{
:
?
}
.
"
other
)
;
}
}
;
}
#
[
test
]
fn
take_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
match
take_s
!
(
INPUT
9
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_s
consumed
leftover
input
.
Leftover
{
}
.
"
extra
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
take_s
doens
'
t
return
the
string
it
consumed
on
success
.
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_until_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
FIND
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
match
take_until_s
!
(
INPUT
FIND
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_until_s
\
consumed
leftover
input
.
Leftover
{
}
.
"
extra
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
take_until_s
\
doens
'
t
return
the
string
it
consumed
on
success
.
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_until_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_s_incomplete
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
match
take_s
!
(
INPUT
13
)
{
IResult
:
:
Incomplete
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
take_s
didn
'
t
require
more
input
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
}
use
internal
:
:
IResult
:
:
{
Done
Error
Incomplete
}
;
use
internal
:
:
Needed
;
use
util
:
:
ErrorKind
;
pub
fn
is_alphabetic
(
c
:
char
)
-
>
bool
{
(
c
as
u8
>
=
0x41
&
&
c
as
u8
<
=
0x5A
)
|
|
(
c
as
u8
>
=
0x61
&
&
c
as
u8
<
=
0x7A
)
}
#
[
test
]
fn
take_while_s
(
)
{
named
!
(
f
<
&
str
&
str
>
take_while_s
!
(
is_alphabetic
)
)
;
let
a
=
"
"
;
let
b
=
"
abcd
"
;
let
c
=
"
abcd123
"
;
let
d
=
"
123
"
;
assert_eq
!
(
f
(
&
a
[
.
.
]
)
Done
(
&
a
[
.
.
]
&
a
[
.
.
]
)
)
;
assert_eq
!
(
f
(
&
b
[
.
.
]
)
Done
(
&
a
[
.
.
]
&
b
[
.
.
]
)
)
;
assert_eq
!
(
f
(
&
c
[
.
.
]
)
Done
(
&
d
[
.
.
]
&
b
[
.
.
]
)
)
;
assert_eq
!
(
f
(
&
d
[
.
.
]
)
Done
(
&
d
[
.
.
]
&
a
[
.
.
]
)
)
;
}
#
[
test
]
fn
take_while1_s
(
)
{
named
!
(
f
<
&
str
&
str
>
take_while1_s
!
(
is_alphabetic
)
)
;
let
a
=
"
"
;
let
b
=
"
abcd
"
;
let
c
=
"
abcd123
"
;
let
d
=
"
123
"
;
assert_eq
!
(
f
(
&
a
[
.
.
]
)
Incomplete
(
Needed
:
:
Size
(
1
)
)
)
;
assert_eq
!
(
f
(
&
b
[
.
.
]
)
Done
(
&
a
[
.
.
]
&
b
[
.
.
]
)
)
;
assert_eq
!
(
f
(
&
c
[
.
.
]
)
Done
(
&
"
123
"
[
.
.
]
&
b
[
.
.
]
)
)
;
assert_eq
!
(
f
(
&
d
[
.
.
]
)
Error
(
error_position
!
(
ErrorKind
:
:
TakeWhile1
&
d
[
.
.
]
)
)
)
;
}
#
[
test
]
fn
take_till_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
fn
till_s
(
c
:
char
)
-
>
bool
{
c
=
=
'
'
}
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
take_till_s
!
(
input
till_s
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_till_s
consumed
leftover
input
.
"
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
take_till_s
doesn
'
t
return
the
string
it
consumed
on
success
.
\
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_till_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_while_s_succeed_none
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
fn
while_s
(
c
:
char
)
-
>
bool
{
c
=
=
'
9
'
}
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
take_while_s
!
(
input
while_s
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_while_s
consumed
leftover
input
.
"
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
take_while_s
doesn
'
t
return
the
string
it
consumed
on
success
.
\
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_while_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
is_not_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
AVOID
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
is_not_s
!
(
input
AVOID
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
is_not_s
consumed
leftover
input
.
Leftover
{
}
.
"
extra
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
is_not_s
doens
'
t
return
the
string
it
consumed
on
success
.
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
is_not_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_until_and_consume_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
FIND
:
&
'
static
str
=
"
"
;
const
OUTPUT
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
match
take_until_and_consume_s
!
(
INPUT
FIND
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_until_and_consume_s
\
consumed
leftover
input
.
Leftover
{
}
.
"
extra
)
;
assert
!
(
output
=
=
OUTPUT
"
Parser
take_until_and_consume_s
\
doens
'
t
return
the
string
it
selected
on
success
.
Expected
{
}
got
{
}
.
"
OUTPUT
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_until_and_consume_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_while_s_succeed_some
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
fn
while_s
(
c
:
char
)
-
>
bool
{
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
}
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
take_while_s
!
(
input
while_s
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_while_s
consumed
leftover
input
.
"
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
take_while_s
doesn
'
t
return
the
string
it
consumed
on
success
.
\
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_while_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
is_not_s_fail
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
AVOID
:
&
'
static
str
=
"
"
;
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
is_not_s
!
(
input
AVOID
)
}
match
test
(
INPUT
)
{
IResult
:
:
Error
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
is_not_s
didn
'
t
fail
when
it
should
have
.
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_while1_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
fn
while1_s
(
c
:
char
)
-
>
bool
{
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
'
}
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
take_while1_s
!
(
input
while1_s
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
take_while1_s
consumed
leftover
input
.
"
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
take_while1_s
doesn
'
t
return
the
string
it
consumed
on
success
.
\
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
take_while1_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_until_and_consume_s_incomplete
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
FIND
:
&
'
static
str
=
"
"
;
match
take_until_and_consume_s
!
(
INPUT
FIND
)
{
IResult
:
:
Incomplete
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
take_until_and_consume_s
didn
'
t
require
more
input
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_until_s_incomplete
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
FIND
:
&
'
static
str
=
"
"
;
match
take_until_s
!
(
INPUT
FIND
)
{
IResult
:
:
Incomplete
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
take_until_s
didn
'
t
require
more
input
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
is_a_s_succeed
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
MATCH
:
&
'
static
str
=
"
"
;
const
CONSUMED
:
&
'
static
str
=
"
"
;
const
LEFTOVER
:
&
'
static
str
=
"
"
;
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
is_a_s
!
(
input
MATCH
)
}
match
test
(
INPUT
)
{
IResult
:
:
Done
(
extra
output
)
=
>
{
assert
!
(
extra
=
=
LEFTOVER
"
Parser
is_a_s
consumed
leftover
input
.
Leftover
{
}
.
"
extra
)
;
assert
!
(
output
=
=
CONSUMED
"
Parser
is_a_s
doens
'
t
return
the
string
it
consumed
on
success
.
Expected
{
}
got
{
}
.
"
CONSUMED
output
)
;
}
other
=
>
panic
!
(
"
Parser
is_a_s
didn
'
t
succeed
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_while1_s_fail
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
fn
while1_s
(
c
:
char
)
-
>
bool
{
c
=
=
'
9
'
}
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
take_while1_s
!
(
input
while1_s
)
}
match
test
(
INPUT
)
{
IResult
:
:
Error
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
take_while1_s
didn
'
t
fail
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
is_a_s_fail
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
MATCH
:
&
'
static
str
=
"
"
;
fn
test
(
input
:
&
str
)
-
>
IResult
<
&
str
&
str
>
{
is_a_s
!
(
input
MATCH
)
}
match
test
(
INPUT
)
{
IResult
:
:
Error
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
is_a_s
didn
'
t
fail
when
it
should
have
.
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_until_and_consume_s_error
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
FIND
:
&
'
static
str
=
"
R
"
;
match
take_until_and_consume_s
!
(
INPUT
FIND
)
{
IResult
:
:
Error
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
take_until_and_consume_s
didn
'
t
fail
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
fn
take_until_s_error
(
)
{
const
INPUT
:
&
'
static
str
=
"
"
;
const
FIND
:
&
'
static
str
=
"
R
"
;
match
take_until_s
!
(
INPUT
FIND
)
{
IResult
:
:
Error
(
_
)
=
>
(
)
other
=
>
panic
!
(
"
Parser
take_until_and_consume_s
didn
'
t
fail
when
it
should
have
.
\
Got
{
:
?
}
.
"
other
)
}
;
}
#
[
test
]
#
[
cfg
(
feature
=
"
std
"
)
]
fn
recognize_is_a_s
(
)
{
let
a
=
"
aabbab
"
;
let
b
=
"
ababcd
"
;
named
!
(
f
<
&
str
&
str
>
recognize
!
(
many1
!
(
alt
!
(
tag_s
!
(
"
a
"
)
|
tag_s
!
(
"
b
"
)
)
)
)
)
;
assert_eq
!
(
f
(
&
a
[
.
.
]
)
Done
(
&
a
[
6
.
.
]
&
a
[
.
.
]
)
)
;
assert_eq
!
(
f
(
&
b
[
.
.
]
)
Done
(
&
b
[
4
.
.
]
&
b
[
.
.
4
]
)
)
;
}
#
[
test
]
fn
utf8_indexing
(
)
{
named
!
(
dot
(
&
str
)
-
>
&
str
tag_s
!
(
"
.
"
)
)
;
dot
(
"
"
)
;
}
#
[
test
]
fn
case_insensitive
(
)
{
named
!
(
test
<
&
str
&
str
>
tag_no_case
!
(
"
ABcd
"
)
)
;
assert_eq
!
(
test
(
"
aBCdefgh
"
)
Done
(
"
efgh
"
"
aBCd
"
)
)
;
assert_eq
!
(
test
(
"
abcdefgh
"
)
Done
(
"
efgh
"
"
abcd
"
)
)
;
assert_eq
!
(
test
(
"
ABCDefgh
"
)
Done
(
"
efgh
"
"
ABCD
"
)
)
;
named
!
(
test2
<
&
str
&
str
>
tag_no_case
!
(
"
ABcd
"
)
)
;
assert_eq
!
(
test2
(
"
aBCdefgh
"
)
Done
(
"
efgh
"
"
aBCd
"
)
)
;
assert_eq
!
(
test2
(
"
abcdefgh
"
)
Done
(
"
efgh
"
"
abcd
"
)
)
;
assert_eq
!
(
test2
(
"
ABCDefgh
"
)
Done
(
"
efgh
"
"
ABCD
"
)
)
;
}
}
