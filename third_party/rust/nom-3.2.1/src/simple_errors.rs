use
util
:
:
ErrorKind
;
use
internal
:
:
{
IResult
IError
}
;
use
internal
:
:
IResult
:
:
*
;
pub
type
Err
<
E
=
u32
>
=
ErrorKind
<
E
>
;
impl
<
I
O
E
>
IResult
<
I
O
E
>
{
#
[
inline
]
pub
fn
map_err
<
N
F
>
(
self
f
:
F
)
-
>
IResult
<
I
O
N
>
where
F
:
FnOnce
(
Err
<
E
>
)
-
>
Err
<
N
>
{
match
self
{
Error
(
e
)
=
>
Error
(
f
(
e
)
)
Incomplete
(
n
)
=
>
Incomplete
(
n
)
Done
(
i
o
)
=
>
Done
(
i
o
)
}
}
pub
fn
unwrap_err
(
self
)
-
>
Err
<
E
>
{
match
self
{
Error
(
e
)
=
>
e
Done
(
_
_
)
=
>
panic
!
(
"
unwrap_err
(
)
called
on
an
IResult
that
is
Done
"
)
Incomplete
(
_
)
=
>
panic
!
(
"
unwrap_err
(
)
called
on
an
IResult
that
is
Incomplete
"
)
}
}
pub
fn
to_full_result
(
self
)
-
>
Result
<
O
IError
<
E
>
>
{
match
self
{
Done
(
_
o
)
=
>
Ok
(
o
)
Incomplete
(
n
)
=
>
Err
(
IError
:
:
Incomplete
(
n
)
)
Error
(
e
)
=
>
Err
(
IError
:
:
Error
(
e
)
)
}
}
pub
fn
to_result
(
self
)
-
>
Result
<
O
Err
<
E
>
>
{
match
self
{
Done
(
_
o
)
=
>
Ok
(
o
)
Error
(
e
)
=
>
Err
(
e
)
Incomplete
(
_
)
=
>
panic
!
(
"
to_result
(
)
called
on
an
IResult
that
is
Incomplete
"
)
}
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
any
:
:
Any
;
#
[
cfg
(
feature
=
"
std
"
)
]
use
std
:
:
{
error
fmt
}
;
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
E
:
fmt
:
:
Debug
+
Any
>
error
:
:
Error
for
Err
<
E
>
{
fn
description
(
&
self
)
-
>
&
str
{
self
.
description
(
)
}
}
#
[
cfg
(
feature
=
"
std
"
)
]
impl
<
E
:
fmt
:
:
Debug
>
fmt
:
:
Display
for
Err
<
E
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
description
(
)
)
}
}
#
[
macro_export
]
macro_rules
!
fix_error
(
(
i
:
expr
t
:
ty
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
{
match
submac
!
(
i
(
args
)
*
)
{
crate
:
:
IResult
:
:
Incomplete
(
x
)
=
>
crate
:
:
IResult
:
:
Incomplete
(
x
)
crate
:
:
IResult
:
:
Done
(
i
o
)
=
>
crate
:
:
IResult
:
:
Done
(
i
o
)
crate
:
:
IResult
:
:
Error
(
_
)
=
>
{
let
e
:
crate
:
:
ErrorKind
<
t
>
=
crate
:
:
ErrorKind
:
:
Fix
;
crate
:
:
IResult
:
:
Error
(
e
)
}
}
}
)
;
(
i
:
expr
t
:
ty
f
:
expr
)
=
>
(
fix_error
!
(
i
t
call
!
(
f
)
)
;
)
;
)
;
#
[
macro_export
]
macro_rules
!
flat_map
(
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
submac2
:
ident
!
(
(
args2
:
tt
)
*
)
)
=
>
(
{
match
submac
!
(
i
(
args
)
*
)
{
crate
:
:
IResult
:
:
Error
(
e
)
=
>
crate
:
:
IResult
:
:
Error
(
e
)
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Unknown
)
=
>
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Unknown
)
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Size
(
i
)
)
=
>
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Size
(
i
)
)
crate
:
:
IResult
:
:
Done
(
i
o
)
=
>
match
submac2
!
(
o
(
args2
)
*
)
{
crate
:
:
IResult
:
:
Error
(
e
)
=
>
crate
:
:
IResult
:
:
Error
(
e
)
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Unknown
)
=
>
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Unknown
)
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Size
(
ref
i2
)
)
=
>
crate
:
:
IResult
:
:
Incomplete
(
crate
:
:
Needed
:
:
Size
(
*
i2
)
)
crate
:
:
IResult
:
:
Done
(
_
o2
)
=
>
crate
:
:
IResult
:
:
Done
(
i
o2
)
}
}
}
)
;
(
i
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
g
:
expr
)
=
>
(
flat_map
!
(
i
submac
!
(
(
args
)
*
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
g
:
expr
)
=
>
(
flat_map
!
(
i
call
!
(
f
)
call
!
(
g
)
)
;
)
;
(
i
:
expr
f
:
expr
submac
:
ident
!
(
(
args
:
tt
)
*
)
)
=
>
(
flat_map
!
(
i
call
!
(
f
)
submac
!
(
(
args
)
*
)
)
;
)
;
)
;
