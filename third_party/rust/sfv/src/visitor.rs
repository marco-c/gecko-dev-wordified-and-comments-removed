use
std
:
:
{
convert
:
:
Infallible
error
:
:
Error
}
;
use
crate
:
:
{
BareItemFromInput
KeyRef
}
;
pub
trait
ParameterVisitor
<
'
de
>
{
type
Error
:
Error
;
fn
parameter
(
&
mut
self
key
:
&
'
de
KeyRef
value
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
finish
(
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
where
Self
:
Sized
{
Ok
(
(
)
)
}
}
pub
trait
ItemVisitor
<
'
de
>
{
type
Error
:
Error
;
fn
bare_item
(
self
bare_item
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
;
}
pub
trait
InnerListVisitor
<
'
de
>
{
type
Error
:
Error
;
fn
item
(
&
mut
self
)
-
>
Result
<
impl
ItemVisitor
<
'
de
>
Self
:
:
Error
>
;
fn
finish
(
self
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
;
}
pub
trait
EntryVisitor
<
'
de
>
:
ItemVisitor
<
'
de
>
{
fn
inner_list
(
self
)
-
>
Result
<
impl
InnerListVisitor
<
'
de
>
Self
:
:
Error
>
;
}
pub
trait
DictionaryVisitor
<
'
de
>
{
type
Error
:
Error
;
fn
entry
(
&
mut
self
key
:
&
'
de
KeyRef
)
-
>
Result
<
impl
EntryVisitor
<
'
de
>
Self
:
:
Error
>
;
}
pub
trait
ListVisitor
<
'
de
>
{
type
Error
:
Error
;
fn
entry
(
&
mut
self
)
-
>
Result
<
impl
EntryVisitor
<
'
de
>
Self
:
:
Error
>
;
}
#
[
derive
(
Clone
Copy
Debug
Default
)
]
pub
struct
Ignored
;
impl
<
'
de
>
ParameterVisitor
<
'
de
>
for
Ignored
{
type
Error
=
Infallible
;
fn
parameter
(
&
mut
self
_key
:
&
'
de
KeyRef
_value
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Ok
(
(
)
)
}
}
impl
<
'
de
>
ItemVisitor
<
'
de
>
for
Ignored
{
type
Error
=
Infallible
;
fn
bare_item
(
self
_bare_item
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
Ignored
)
}
}
impl
<
'
de
>
EntryVisitor
<
'
de
>
for
Ignored
{
fn
inner_list
(
self
)
-
>
Result
<
impl
InnerListVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
Ignored
)
}
}
impl
<
'
de
>
InnerListVisitor
<
'
de
>
for
Ignored
{
type
Error
=
Infallible
;
fn
item
(
&
mut
self
)
-
>
Result
<
impl
ItemVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
Ignored
)
}
fn
finish
(
self
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
Ignored
)
}
}
impl
<
'
de
>
DictionaryVisitor
<
'
de
>
for
Ignored
{
type
Error
=
Infallible
;
fn
entry
(
&
mut
self
_key
:
&
'
de
KeyRef
)
-
>
Result
<
impl
EntryVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
Ignored
)
}
}
impl
<
'
de
>
ListVisitor
<
'
de
>
for
Ignored
{
type
Error
=
Infallible
;
fn
entry
(
&
mut
self
)
-
>
Result
<
impl
EntryVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
Ignored
)
}
}
impl
<
'
de
V
:
ParameterVisitor
<
'
de
>
>
ParameterVisitor
<
'
de
>
for
Option
<
V
>
{
type
Error
=
V
:
:
Error
;
fn
parameter
(
&
mut
self
key
:
&
'
de
KeyRef
value
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
match
self
{
None
=
>
Ok
(
(
)
)
Some
(
visitor
)
=
>
visitor
.
parameter
(
key
value
)
}
}
}
impl
<
'
de
V
:
ItemVisitor
<
'
de
>
>
ItemVisitor
<
'
de
>
for
Option
<
V
>
{
type
Error
=
V
:
:
Error
;
fn
bare_item
(
self
bare_item
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
{
match
self
{
None
=
>
Ok
(
None
)
Some
(
visitor
)
=
>
visitor
.
bare_item
(
bare_item
)
.
map
(
Some
)
}
}
}
impl
<
'
de
V
:
EntryVisitor
<
'
de
>
>
EntryVisitor
<
'
de
>
for
Option
<
V
>
{
fn
inner_list
(
self
)
-
>
Result
<
impl
InnerListVisitor
<
'
de
>
Self
:
:
Error
>
{
match
self
{
None
=
>
Ok
(
None
)
Some
(
visitor
)
=
>
visitor
.
inner_list
(
)
.
map
(
Some
)
}
}
}
impl
<
'
de
V
:
InnerListVisitor
<
'
de
>
>
InnerListVisitor
<
'
de
>
for
Option
<
V
>
{
type
Error
=
V
:
:
Error
;
fn
item
(
&
mut
self
)
-
>
Result
<
impl
ItemVisitor
<
'
de
>
Self
:
:
Error
>
{
match
self
{
None
=
>
Ok
(
None
)
Some
(
visitor
)
=
>
visitor
.
item
(
)
.
map
(
Some
)
}
}
fn
finish
(
self
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
{
match
self
{
None
=
>
Ok
(
None
)
Some
(
visitor
)
=
>
visitor
.
finish
(
)
.
map
(
Some
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
pub
enum
Never
{
}
impl
<
'
de
>
ParameterVisitor
<
'
de
>
for
Never
{
type
Error
=
Infallible
;
fn
parameter
(
&
mut
self
_key
:
&
'
de
KeyRef
_value
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
match
*
self
{
}
}
}
impl
<
'
de
>
ItemVisitor
<
'
de
>
for
Never
{
type
Error
=
Infallible
;
fn
bare_item
(
self
_bare_item
:
BareItemFromInput
<
'
de
>
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
self
)
}
}
impl
<
'
de
>
EntryVisitor
<
'
de
>
for
Never
{
fn
inner_list
(
self
)
-
>
Result
<
impl
InnerListVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
self
)
}
}
impl
<
'
de
>
InnerListVisitor
<
'
de
>
for
Never
{
type
Error
=
Infallible
;
fn
item
(
&
mut
self
)
-
>
Result
<
impl
ItemVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
*
self
)
}
fn
finish
(
self
)
-
>
Result
<
impl
ParameterVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
self
)
}
}
impl
<
'
de
>
DictionaryVisitor
<
'
de
>
for
Never
{
type
Error
=
Infallible
;
fn
entry
(
&
mut
self
_key
:
&
'
de
KeyRef
)
-
>
Result
<
impl
EntryVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
*
self
)
}
}
impl
<
'
de
>
ListVisitor
<
'
de
>
for
Never
{
type
Error
=
Infallible
;
fn
entry
(
&
mut
self
)
-
>
Result
<
impl
EntryVisitor
<
'
de
>
Self
:
:
Error
>
{
Ok
(
*
self
)
}
}
