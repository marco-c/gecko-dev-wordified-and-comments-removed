use
nom
:
:
branch
:
:
alt
;
use
nom
:
:
bytes
:
:
complete
:
:
tag
;
use
nom
:
:
character
:
:
complete
:
:
{
anychar
multispace1
newline
}
;
use
nom
:
:
combinator
:
:
{
map
recognize
value
}
;
use
nom
:
:
error
:
:
{
ErrorKind
VerboseError
VerboseErrorKind
}
;
use
nom
:
:
multi
:
:
fold_many0
;
use
nom
:
:
{
Err
as
NomErr
IResult
}
;
pub
type
ParserResult
<
'
a
O
>
=
IResult
<
&
'
a
str
O
VerboseError
<
&
'
a
str
>
>
;
pub
fn
cnst
<
'
a
T
E
>
(
t
:
T
)
-
>
impl
Fn
(
&
'
a
str
)
-
>
Result
<
(
&
'
a
str
T
)
E
>
where
T
:
'
a
+
Clone
{
move
|
i
|
Ok
(
(
i
t
.
clone
(
)
)
)
}
pub
fn
eoi
(
i
:
&
str
)
-
>
ParserResult
<
(
)
>
{
if
i
.
is_empty
(
)
{
Ok
(
(
i
(
)
)
)
}
else
{
Err
(
NomErr
:
:
Error
(
VerboseError
{
errors
:
vec
!
[
(
i
VerboseErrorKind
:
:
Nom
(
ErrorKind
:
:
Eof
)
)
]
}
)
)
}
}
pub
fn
eol
(
i
:
&
str
)
-
>
ParserResult
<
(
)
>
{
alt
(
(
eoi
value
(
(
)
newline
)
)
)
(
i
)
}
pub
fn
till
<
'
a
A
B
F
G
>
(
f
:
F
g
:
G
)
-
>
impl
Fn
(
&
'
a
str
)
-
>
ParserResult
<
'
a
(
)
>
where
F
:
Fn
(
&
'
a
str
)
-
>
ParserResult
<
'
a
A
>
G
:
Fn
(
&
'
a
str
)
-
>
ParserResult
<
'
a
B
>
{
move
|
mut
i
|
loop
{
if
let
Ok
(
(
i2
_
)
)
=
g
(
i
)
{
break
Ok
(
(
i2
(
)
)
)
;
}
let
(
i2
_
)
=
f
(
i
)
?
;
i
=
i2
;
}
}
pub
fn
many0_
<
'
a
A
F
>
(
f
:
F
)
-
>
impl
Fn
(
&
'
a
str
)
-
>
ParserResult
<
'
a
(
)
>
where
F
:
Fn
(
&
'
a
str
)
-
>
ParserResult
<
'
a
A
>
{
move
|
i
|
fold_many0
(
&
f
(
)
|
_
_
|
(
)
)
(
i
)
}
pub
fn
str_till_eol
(
i
:
&
str
)
-
>
ParserResult
<
&
str
>
{
map
(
recognize
(
till
(
alt
(
(
value
(
(
)
tag
(
"
\
\
\
n
"
)
)
value
(
(
)
anychar
)
)
)
eol
)
)
|
i
|
{
if
i
.
as_bytes
(
)
.
last
(
)
=
=
Some
(
&
b
'
\
n
'
)
{
&
i
[
0
.
.
i
.
len
(
)
-
1
]
}
else
{
i
}
}
)
(
i
)
}
pub
fn
blank_space
(
i
:
&
str
)
-
>
ParserResult
<
&
str
>
{
recognize
(
many0_
(
alt
(
(
multispace1
tag
(
"
\
\
\
n
"
)
)
)
)
)
(
i
)
}
