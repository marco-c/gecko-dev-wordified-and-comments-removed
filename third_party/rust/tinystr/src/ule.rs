use
crate
:
:
{
TinyAsciiStr
UnvalidatedTinyAsciiStr
}
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
zerovec
:
:
maps
:
:
ZeroMapKV
;
use
zerovec
:
:
ule
:
:
*
;
#
[
cfg
(
feature
=
"
alloc
"
)
]
use
zerovec
:
:
{
ZeroSlice
ZeroVec
}
;
unsafe
impl
<
const
N
:
usize
>
ULE
for
TinyAsciiStr
<
N
>
{
#
[
inline
]
fn
validate_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
UleError
>
{
if
bytes
.
len
(
)
%
N
!
=
0
{
return
Err
(
UleError
:
:
length
:
:
<
Self
>
(
bytes
.
len
(
)
)
)
;
}
for
chunk
in
bytes
.
chunks_exact
(
N
)
{
let
_
=
TinyAsciiStr
:
:
<
N
>
:
:
try_from_utf8_inner
(
chunk
true
)
.
map_err
(
|
_
|
UleError
:
:
parse
:
:
<
Self
>
(
)
)
?
;
}
Ok
(
(
)
)
}
}
impl
<
const
N
:
usize
>
NicheBytes
<
N
>
for
TinyAsciiStr
<
N
>
{
const
NICHE_BIT_PATTERN
:
[
u8
;
N
]
=
[
255
;
N
]
;
}
impl
<
const
N
:
usize
>
AsULE
for
TinyAsciiStr
<
N
>
{
type
ULE
=
Self
;
#
[
inline
]
fn
to_unaligned
(
self
)
-
>
Self
:
:
ULE
{
self
}
#
[
inline
]
fn
from_unaligned
(
unaligned
:
Self
:
:
ULE
)
-
>
Self
{
unaligned
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
const
N
:
usize
>
ZeroMapKV
<
'
a
>
for
TinyAsciiStr
<
N
>
{
type
Container
=
ZeroVec
<
'
a
TinyAsciiStr
<
N
>
>
;
type
Slice
=
ZeroSlice
<
TinyAsciiStr
<
N
>
>
;
type
GetType
=
TinyAsciiStr
<
N
>
;
type
OwnedType
=
TinyAsciiStr
<
N
>
;
}
unsafe
impl
<
const
N
:
usize
>
ULE
for
UnvalidatedTinyAsciiStr
<
N
>
{
#
[
inline
]
fn
validate_bytes
(
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
UleError
>
{
if
bytes
.
len
(
)
%
N
!
=
0
{
return
Err
(
UleError
:
:
length
:
:
<
Self
>
(
bytes
.
len
(
)
)
)
;
}
Ok
(
(
)
)
}
}
impl
<
const
N
:
usize
>
AsULE
for
UnvalidatedTinyAsciiStr
<
N
>
{
type
ULE
=
Self
;
#
[
inline
]
fn
to_unaligned
(
self
)
-
>
Self
:
:
ULE
{
self
}
#
[
inline
]
fn
from_unaligned
(
unaligned
:
Self
:
:
ULE
)
-
>
Self
{
unaligned
}
}
#
[
cfg
(
feature
=
"
alloc
"
)
]
impl
<
'
a
const
N
:
usize
>
ZeroMapKV
<
'
a
>
for
UnvalidatedTinyAsciiStr
<
N
>
{
type
Container
=
ZeroVec
<
'
a
UnvalidatedTinyAsciiStr
<
N
>
>
;
type
Slice
=
ZeroSlice
<
UnvalidatedTinyAsciiStr
<
N
>
>
;
type
GetType
=
UnvalidatedTinyAsciiStr
<
N
>
;
type
OwnedType
=
UnvalidatedTinyAsciiStr
<
N
>
;
}
#
[
cfg
(
test
)
]
mod
test
{
use
crate
:
:
*
;
use
zerovec
:
:
*
;
#
[
test
]
fn
test_zerovec
(
)
{
let
mut
vec
=
ZeroVec
:
:
<
TinyAsciiStr
<
7
>
>
:
:
new
(
)
;
vec
.
with_mut
(
|
v
|
v
.
push
(
"
foobar
"
.
parse
(
)
.
unwrap
(
)
)
)
;
vec
.
with_mut
(
|
v
|
v
.
push
(
"
baz
"
.
parse
(
)
.
unwrap
(
)
)
)
;
vec
.
with_mut
(
|
v
|
v
.
push
(
"
quux
"
.
parse
(
)
.
unwrap
(
)
)
)
;
let
bytes
=
vec
.
as_bytes
(
)
;
let
vec
:
ZeroVec
<
TinyAsciiStr
<
7
>
>
=
ZeroVec
:
:
parse_bytes
(
bytes
)
.
unwrap
(
)
;
assert_eq
!
(
&
*
vec
.
get
(
0
)
.
unwrap
(
)
"
foobar
"
)
;
assert_eq
!
(
&
*
vec
.
get
(
1
)
.
unwrap
(
)
"
baz
"
)
;
assert_eq
!
(
&
*
vec
.
get
(
2
)
.
unwrap
(
)
"
quux
"
)
;
}
}
