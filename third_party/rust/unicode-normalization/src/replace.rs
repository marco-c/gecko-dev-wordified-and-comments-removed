use
core
:
:
fmt
:
:
{
self
Write
}
;
use
tinyvec
:
:
ArrayVec
;
#
[
derive
(
Clone
)
]
pub
struct
Replacements
<
I
>
{
iter
:
I
buffer
:
Option
<
char
>
}
#
[
inline
]
pub
fn
new_cjk_compat_variants
<
I
:
Iterator
<
Item
=
char
>
>
(
iter
:
I
)
-
>
Replacements
<
I
>
{
Replacements
{
iter
buffer
:
None
}
}
impl
<
I
:
Iterator
<
Item
=
char
>
>
Iterator
for
Replacements
<
I
>
{
type
Item
=
char
;
#
[
inline
]
fn
next
(
&
mut
self
)
-
>
Option
<
char
>
{
if
let
Some
(
c
)
=
self
.
buffer
.
take
(
)
{
return
Some
(
c
)
;
}
match
self
.
iter
.
next
(
)
{
Some
(
ch
)
=
>
{
let
mut
buffer
=
ArrayVec
:
:
<
[
char
;
2
]
>
:
:
new
(
)
;
super
:
:
char
:
:
decompose_cjk_compat_variants
(
ch
|
d
|
buffer
.
push
(
d
)
)
;
self
.
buffer
=
buffer
.
get
(
1
)
.
copied
(
)
;
Some
(
buffer
[
0
]
)
}
None
=
>
None
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
let
(
lower
_
)
=
self
.
iter
.
size_hint
(
)
;
(
lower
None
)
}
}
impl
<
I
:
Iterator
<
Item
=
char
>
+
Clone
>
fmt
:
:
Display
for
Replacements
<
I
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
for
c
in
self
.
clone
(
)
{
f
.
write_char
(
c
)
?
;
}
Ok
(
(
)
)
}
}
