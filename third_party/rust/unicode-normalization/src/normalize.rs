use
std
:
:
cmp
:
:
Ordering
:
:
{
Equal
Less
Greater
}
;
use
std
:
:
ops
:
:
FnMut
;
use
tables
:
:
normalization
:
:
{
canonical_table
canonical_table_STRTAB
}
;
use
tables
:
:
normalization
:
:
{
compatibility_table
compatibility_table_STRTAB
}
;
use
tables
:
:
normalization
:
:
{
composition_table
composition_table_STRTAB
}
;
use
tables
:
:
normalization
:
:
Slice
;
fn
bsearch_table
<
T
>
(
c
:
char
r
:
&
'
static
[
(
char
Slice
)
]
strtab
:
&
'
static
[
T
]
)
-
>
Option
<
&
'
static
[
T
]
>
{
match
r
.
binary_search_by
(
|
&
(
val
_
)
|
{
if
c
=
=
val
{
Equal
}
else
if
val
<
c
{
Less
}
else
{
Greater
}
}
)
{
Ok
(
idx
)
=
>
{
let
ref
slice
=
r
[
idx
]
.
1
;
let
offset
=
slice
.
offset
as
usize
;
let
length
=
slice
.
length
as
usize
;
Some
(
&
strtab
[
offset
.
.
(
offset
+
length
)
]
)
}
Err
(
_
)
=
>
None
}
}
pub
fn
decompose_canonical
<
F
>
(
c
:
char
mut
i
:
F
)
where
F
:
FnMut
(
char
)
{
d
(
c
&
mut
i
false
)
;
}
pub
fn
decompose_compatible
<
F
>
(
c
:
char
mut
i
:
F
)
where
F
:
FnMut
(
char
)
{
d
(
c
&
mut
i
true
)
;
}
fn
d
<
F
>
(
c
:
char
i
:
&
mut
F
k
:
bool
)
where
F
:
FnMut
(
char
)
{
if
c
<
=
'
\
x7f
'
{
(
*
i
)
(
c
)
;
return
;
}
if
(
c
as
u32
)
>
=
S_BASE
&
&
(
c
as
u32
)
<
(
S_BASE
+
S_COUNT
)
{
decompose_hangul
(
c
i
)
;
return
;
}
match
bsearch_table
(
c
canonical_table
canonical_table_STRTAB
)
{
Some
(
canon
)
=
>
{
for
x
in
canon
{
d
(
*
x
i
k
)
;
}
return
;
}
None
=
>
(
)
}
if
!
k
{
(
*
i
)
(
c
)
;
return
;
}
match
bsearch_table
(
c
compatibility_table
compatibility_table_STRTAB
)
{
Some
(
compat
)
=
>
{
for
x
in
compat
{
d
(
*
x
i
k
)
;
}
return
;
}
None
=
>
(
)
}
(
*
i
)
(
c
)
;
}
pub
fn
compose
(
a
:
char
b
:
char
)
-
>
Option
<
char
>
{
compose_hangul
(
a
b
)
.
or_else
(
|
|
{
match
bsearch_table
(
a
composition_table
composition_table_STRTAB
)
{
None
=
>
None
Some
(
candidates
)
=
>
{
match
candidates
.
binary_search_by
(
|
&
(
val
_
)
|
{
if
b
=
=
val
{
Equal
}
else
if
val
<
b
{
Less
}
else
{
Greater
}
}
)
{
Ok
(
idx
)
=
>
{
let
(
_
result
)
=
candidates
[
idx
]
;
Some
(
result
)
}
Err
(
_
)
=
>
None
}
}
}
}
)
}
const
S_BASE
:
u32
=
0xAC00
;
const
L_BASE
:
u32
=
0x1100
;
const
V_BASE
:
u32
=
0x1161
;
const
T_BASE
:
u32
=
0x11A7
;
const
L_COUNT
:
u32
=
19
;
const
V_COUNT
:
u32
=
21
;
const
T_COUNT
:
u32
=
28
;
const
N_COUNT
:
u32
=
(
V_COUNT
*
T_COUNT
)
;
const
S_COUNT
:
u32
=
(
L_COUNT
*
N_COUNT
)
;
#
[
allow
(
unsafe_code
)
]
#
[
inline
(
always
)
]
fn
decompose_hangul
<
F
>
(
s
:
char
f
:
&
mut
F
)
where
F
:
FnMut
(
char
)
{
use
std
:
:
mem
:
:
transmute
;
let
si
=
s
as
u32
-
S_BASE
;
let
li
=
si
/
N_COUNT
;
unsafe
{
(
*
f
)
(
transmute
(
L_BASE
+
li
)
)
;
let
vi
=
(
si
%
N_COUNT
)
/
T_COUNT
;
(
*
f
)
(
transmute
(
V_BASE
+
vi
)
)
;
let
ti
=
si
%
T_COUNT
;
if
ti
>
0
{
(
*
f
)
(
transmute
(
T_BASE
+
ti
)
)
;
}
}
}
#
[
allow
(
unsafe_code
)
]
#
[
inline
(
always
)
]
fn
compose_hangul
(
a
:
char
b
:
char
)
-
>
Option
<
char
>
{
use
std
:
:
mem
:
:
transmute
;
let
l
=
a
as
u32
;
let
v
=
b
as
u32
;
if
L_BASE
<
=
l
&
&
l
<
(
L_BASE
+
L_COUNT
)
&
&
V_BASE
<
=
v
&
&
v
<
(
V_BASE
+
V_COUNT
)
{
let
r
=
S_BASE
+
(
l
-
L_BASE
)
*
N_COUNT
+
(
v
-
V_BASE
)
*
T_COUNT
;
return
unsafe
{
Some
(
transmute
(
r
)
)
}
;
}
if
S_BASE
<
=
l
&
&
l
<
=
(
S_BASE
+
S_COUNT
-
T_COUNT
)
&
&
T_BASE
<
=
v
&
&
v
<
(
T_BASE
+
T_COUNT
)
&
&
(
l
-
S_BASE
)
%
T_COUNT
=
=
0
{
let
r
=
l
+
(
v
-
T_BASE
)
;
return
unsafe
{
Some
(
transmute
(
r
)
)
}
;
}
None
}
