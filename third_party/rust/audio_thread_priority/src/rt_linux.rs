extern
crate
dbus
;
extern
crate
libc
;
use
std
:
:
cmp
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
io
:
:
Error
as
OSError
;
use
dbus
:
:
{
Connection
BusType
Props
MessageItem
Message
}
;
const
DBUS_SOCKET_TIMEOUT
:
i32
=
10_000
;
const
RT_PRIO_DEFAULT
:
u32
=
10
;
#
[
allow
(
non_camel_case_types
)
]
type
kernel_pid_t
=
libc
:
:
c_long
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
)
]
pub
struct
RtPriorityThreadInfoInternal
{
pid
:
libc
:
:
pid_t
thread_id
:
kernel_pid_t
pthread_id
:
libc
:
:
pthread_t
policy
:
libc
:
:
c_int
param
:
libc
:
:
sched_param
}
impl
RtPriorityThreadInfoInternal
{
pub
fn
serialize
(
&
self
)
-
>
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
{
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
Self
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
>
(
*
self
)
}
}
pub
fn
deserialize
(
bytes
:
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
)
-
>
Self
{
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
Self
>
(
bytes
)
}
}
}
impl
PartialEq
for
RtPriorityThreadInfoInternal
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
thread_id
=
=
other
.
thread_id
&
&
self
.
pthread_id
=
=
other
.
pthread_id
}
}
pub
struct
RtPriorityHandleInternal
{
thread_info
:
RtPriorityThreadInfoInternal
}
fn
item_as_i64
(
i
:
MessageItem
)
-
>
Result
<
i64
Box
<
dyn
Error
>
>
{
match
i
{
MessageItem
:
:
Int32
(
i
)
=
>
Ok
(
i
as
i64
)
MessageItem
:
:
Int64
(
i
)
=
>
Ok
(
i
)
_
=
>
Err
(
Box
:
:
from
(
&
*
format
!
(
"
Property
is
not
integer
(
{
:
?
}
)
"
i
)
)
)
}
}
fn
rtkit_set_realtime
(
thread
:
u64
pid
:
u64
prio
:
u32
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
let
m
=
if
unsafe
{
libc
:
:
getpid
(
)
as
u64
}
=
=
pid
{
let
mut
m
=
Message
:
:
new_method_call
(
"
org
.
freedesktop
.
RealtimeKit1
"
"
/
org
/
freedesktop
/
RealtimeKit1
"
"
org
.
freedesktop
.
RealtimeKit1
"
"
MakeThreadRealtime
"
)
?
;
m
.
append_items
(
&
[
thread
.
into
(
)
prio
.
into
(
)
]
)
;
m
}
else
{
let
mut
m
=
Message
:
:
new_method_call
(
"
org
.
freedesktop
.
RealtimeKit1
"
"
/
org
/
freedesktop
/
RealtimeKit1
"
"
org
.
freedesktop
.
RealtimeKit1
"
"
MakeThreadRealtimeWithPID
"
)
?
;
m
.
append_items
(
&
[
pid
.
into
(
)
thread
.
into
(
)
prio
.
into
(
)
]
)
;
m
}
;
let
c
=
Connection
:
:
get_private
(
BusType
:
:
System
)
?
;
c
.
send_with_reply_and_block
(
m
DBUS_SOCKET_TIMEOUT
)
?
;
return
Ok
(
(
)
)
;
}
fn
get_limits
(
)
-
>
Result
<
(
i64
u64
libc
:
:
rlimit64
)
Box
<
dyn
Error
>
>
{
let
c
=
Connection
:
:
get_private
(
BusType
:
:
System
)
?
;
let
p
=
Props
:
:
new
(
&
c
"
org
.
freedesktop
.
RealtimeKit1
"
"
/
org
/
freedesktop
/
RealtimeKit1
"
"
org
.
freedesktop
.
RealtimeKit1
"
DBUS_SOCKET_TIMEOUT
)
;
let
mut
current_limit
=
libc
:
:
rlimit64
{
rlim_cur
:
0
rlim_max
:
0
}
;
let
max_prio
=
item_as_i64
(
p
.
get
(
"
MaxRealtimePriority
"
)
?
)
?
;
if
max_prio
<
0
{
return
Err
(
Box
:
:
from
(
"
invalid
negative
MaxRealtimePriority
"
)
)
;
}
let
max_rttime
=
item_as_i64
(
p
.
get
(
"
RTTimeUSecMax
"
)
?
)
?
;
if
max_rttime
<
0
{
return
Err
(
Box
:
:
from
(
"
invalid
negative
RTTimeUSecMax
"
)
)
;
}
if
unsafe
{
libc
:
:
getrlimit64
(
libc
:
:
RLIMIT_RTTIME
&
mut
current_limit
)
}
<
0
{
error
!
(
"
getrlimit64
:
{
}
"
OSError
:
:
last_os_error
(
)
.
raw_os_error
(
)
.
unwrap
(
)
)
;
return
Err
(
Box
:
:
from
(
"
getrlimit
failed
"
)
)
;
}
Ok
(
(
max_prio
(
max_rttime
as
u64
)
current_limit
)
)
}
fn
set_limits
(
request
:
u64
max
:
u64
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
let
new_limit
=
libc
:
:
rlimit64
{
rlim_cur
:
request
rlim_max
:
max
}
;
if
unsafe
{
libc
:
:
setrlimit64
(
libc
:
:
RLIMIT_RTTIME
&
new_limit
)
}
<
0
{
return
Err
(
Box
:
:
from
(
"
setrlimit
failed
"
)
)
;
}
Ok
(
(
)
)
}
pub
fn
promote_current_thread_to_real_time_internal
(
audio_buffer_frames
:
u32
audio_samplerate_hz
:
u32
)
-
>
Result
<
RtPriorityHandleInternal
(
)
>
{
let
thread_info
=
get_current_thread_info_internal
(
)
?
;
promote_thread_to_real_time_internal
(
thread_info
audio_buffer_frames
audio_samplerate_hz
)
}
pub
fn
demote_current_thread_from_real_time_internal
(
rt_priority_handle
:
RtPriorityHandleInternal
)
-
>
Result
<
(
)
(
)
>
{
assert
!
(
unsafe
{
libc
:
:
pthread_self
(
)
}
=
=
rt_priority_handle
.
thread_info
.
pthread_id
)
;
if
unsafe
{
libc
:
:
pthread_setschedparam
(
rt_priority_handle
.
thread_info
.
pthread_id
rt_priority_handle
.
thread_info
.
policy
&
rt_priority_handle
.
thread_info
.
param
)
}
<
0
{
error
!
(
"
could
not
demote
thread
{
}
"
OSError
:
:
last_os_error
(
)
.
raw_os_error
(
)
.
unwrap
(
)
)
;
return
Err
(
(
)
)
;
}
return
Ok
(
(
)
)
;
}
pub
fn
demote_thread_from_real_time_internal
(
thread_info
:
RtPriorityThreadInfoInternal
)
-
>
Result
<
(
)
(
)
>
{
let
param
=
unsafe
{
std
:
:
mem
:
:
zeroed
:
:
<
libc
:
:
sched_param
>
(
)
}
;
const
SCHED_RESET_ON_FORK
:
libc
:
:
c_int
=
0x40000000
;
if
unsafe
{
libc
:
:
pthread_setschedparam
(
thread_info
.
pthread_id
libc
:
:
SCHED_OTHER
|
SCHED_RESET_ON_FORK
&
param
)
}
<
0
{
error
!
(
"
could
not
demote
thread
{
}
"
OSError
:
:
last_os_error
(
)
.
raw_os_error
(
)
.
unwrap
(
)
)
;
return
Err
(
(
)
)
;
}
return
Ok
(
(
)
)
;
}
pub
fn
get_current_thread_info_internal
(
)
-
>
Result
<
RtPriorityThreadInfoInternal
(
)
>
{
let
thread_id
=
unsafe
{
libc
:
:
syscall
(
libc
:
:
SYS_gettid
)
}
;
let
pthread_id
=
unsafe
{
libc
:
:
pthread_self
(
)
}
;
let
mut
param
=
unsafe
{
std
:
:
mem
:
:
zeroed
:
:
<
libc
:
:
sched_param
>
(
)
}
;
let
mut
policy
=
0
;
if
unsafe
{
libc
:
:
pthread_getschedparam
(
pthread_id
&
mut
policy
&
mut
param
)
}
<
0
{
error
!
(
"
pthread_getschedparam
error
{
}
"
OSError
:
:
last_os_error
(
)
.
raw_os_error
(
)
.
unwrap
(
)
)
;
return
Err
(
(
)
)
;
}
let
pid
=
unsafe
{
libc
:
:
getpid
(
)
}
;
Ok
(
RtPriorityThreadInfoInternal
{
pid
thread_id
pthread_id
policy
param
}
)
}
pub
fn
set_real_time_hard_limit_internal
(
audio_buffer_frames
:
u32
audio_samplerate_hz
:
u32
)
-
>
Result
<
(
)
(
)
>
{
let
buffer_frames
=
if
audio_buffer_frames
>
0
{
audio_buffer_frames
}
else
{
audio_samplerate_hz
/
20
}
;
let
budget_us
=
(
buffer_frames
*
1_000_000
/
audio_samplerate_hz
)
as
u64
;
let
(
_
max_rttime
_
)
=
get_limits
(
)
.
map_err
(
|
_
|
{
}
)
?
;
let
rttime_request
=
cmp
:
:
min
(
budget_us
max_rttime
as
u64
)
;
set_limits
(
rttime_request
max_rttime
)
.
map_err
(
|
_
|
{
}
)
?
;
Ok
(
(
)
)
}
pub
fn
promote_thread_to_real_time_internal
(
thread_info
:
RtPriorityThreadInfoInternal
audio_buffer_frames
:
u32
audio_samplerate_hz
:
u32
)
-
>
Result
<
RtPriorityHandleInternal
(
)
>
{
let
RtPriorityThreadInfoInternal
{
pid
thread_id
.
.
}
=
thread_info
;
let
handle
=
RtPriorityHandleInternal
{
thread_info
}
;
let
(
_
_
limits
)
=
get_limits
(
)
.
map_err
(
|
_
|
{
}
)
?
;
set_real_time_hard_limit_internal
(
audio_buffer_frames
audio_samplerate_hz
)
?
;
let
r
=
rtkit_set_realtime
(
thread_id
as
u64
pid
as
u64
RT_PRIO_DEFAULT
)
;
if
r
.
is_err
(
)
{
if
unsafe
{
libc
:
:
setrlimit64
(
libc
:
:
RLIMIT_RTTIME
&
limits
)
}
<
0
{
error
!
(
"
setrlimit64
:
{
}
"
OSError
:
:
last_os_error
(
)
.
raw_os_error
(
)
.
unwrap
(
)
)
;
return
Err
(
(
)
)
;
}
}
return
Ok
(
handle
)
;
}
