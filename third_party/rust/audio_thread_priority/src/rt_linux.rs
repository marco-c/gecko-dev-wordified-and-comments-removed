extern
crate
dbus
;
extern
crate
libc
;
use
std
:
:
cmp
;
use
std
:
:
convert
:
:
TryInto
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
io
:
:
Error
as
OSError
;
use
dbus
:
:
{
BusType
Connection
Message
MessageItem
Props
}
;
use
crate
:
:
AudioThreadPriorityError
;
const
DBUS_SOCKET_TIMEOUT
:
i32
=
10_000
;
const
RT_PRIO_DEFAULT
:
u32
=
10
;
#
[
allow
(
non_camel_case_types
)
]
type
kernel_pid_t
=
libc
:
:
c_long
;
impl
From
<
dbus
:
:
Error
>
for
AudioThreadPriorityError
{
fn
from
(
error
:
dbus
:
:
Error
)
-
>
Self
{
AudioThreadPriorityError
:
:
new
(
&
format
!
(
"
{
}
:
{
}
"
error
.
name
(
)
.
unwrap_or
(
"
?
"
)
error
.
message
(
)
.
unwrap_or
(
"
?
"
)
)
)
}
}
impl
From
<
Box
<
dyn
Error
>
>
for
AudioThreadPriorityError
{
fn
from
(
error
:
Box
<
dyn
Error
>
)
-
>
Self
{
AudioThreadPriorityError
:
:
new
(
&
error
.
to_string
(
)
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
)
]
pub
struct
RtPriorityThreadInfoInternal
{
thread_id
:
kernel_pid_t
pthread_id
:
libc
:
:
pthread_t
pid
:
libc
:
:
pid_t
policy
:
libc
:
:
c_int
}
impl
RtPriorityThreadInfoInternal
{
pub
fn
serialize
(
&
self
)
-
>
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
{
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
Self
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
>
(
*
self
)
}
}
pub
fn
deserialize
(
bytes
:
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
)
-
>
Self
{
unsafe
{
std
:
:
mem
:
:
transmute
:
:
<
[
u8
;
std
:
:
mem
:
:
size_of
:
:
<
Self
>
(
)
]
Self
>
(
bytes
)
}
}
}
impl
PartialEq
for
RtPriorityThreadInfoInternal
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
self
.
thread_id
=
=
other
.
thread_id
&
&
self
.
pthread_id
=
=
other
.
pthread_id
}
}
pub
struct
RtPriorityHandleInternal
{
thread_info
:
RtPriorityThreadInfoInternal
}
fn
item_as_i64
(
i
:
MessageItem
)
-
>
Result
<
i64
AudioThreadPriorityError
>
{
match
i
{
MessageItem
:
:
Int32
(
i
)
=
>
Ok
(
i
as
i64
)
MessageItem
:
:
Int64
(
i
)
=
>
Ok
(
i
)
_
=
>
Err
(
AudioThreadPriorityError
:
:
new
(
&
format
!
(
"
Property
is
not
integer
(
{
:
?
}
)
"
i
)
)
)
}
}
fn
rtkit_set_realtime
(
thread
:
u64
pid
:
u64
prio
:
u32
)
-
>
Result
<
(
)
Box
<
dyn
Error
>
>
{
let
m
=
if
unsafe
{
libc
:
:
getpid
(
)
as
u64
}
=
=
pid
{
let
mut
m
=
Message
:
:
new_method_call
(
"
org
.
freedesktop
.
RealtimeKit1
"
"
/
org
/
freedesktop
/
RealtimeKit1
"
"
org
.
freedesktop
.
RealtimeKit1
"
"
MakeThreadRealtime
"
)
?
;
m
.
append_items
(
&
[
thread
.
into
(
)
prio
.
into
(
)
]
)
;
m
}
else
{
let
mut
m
=
Message
:
:
new_method_call
(
"
org
.
freedesktop
.
RealtimeKit1
"
"
/
org
/
freedesktop
/
RealtimeKit1
"
"
org
.
freedesktop
.
RealtimeKit1
"
"
MakeThreadRealtimeWithPID
"
)
?
;
m
.
append_items
(
&
[
pid
.
into
(
)
thread
.
into
(
)
prio
.
into
(
)
]
)
;
m
}
;
let
c
=
Connection
:
:
get_private
(
BusType
:
:
System
)
?
;
c
.
send_with_reply_and_block
(
m
DBUS_SOCKET_TIMEOUT
)
?
;
Ok
(
(
)
)
}
fn
get_limits
(
)
-
>
Result
<
(
i64
u64
libc
:
:
rlimit
)
AudioThreadPriorityError
>
{
let
c
=
Connection
:
:
get_private
(
BusType
:
:
System
)
?
;
let
p
=
Props
:
:
new
(
&
c
"
org
.
freedesktop
.
RealtimeKit1
"
"
/
org
/
freedesktop
/
RealtimeKit1
"
"
org
.
freedesktop
.
RealtimeKit1
"
DBUS_SOCKET_TIMEOUT
)
;
let
mut
current_limit
=
libc
:
:
rlimit
{
rlim_cur
:
0
rlim_max
:
0
}
;
let
max_prio
=
item_as_i64
(
p
.
get
(
"
MaxRealtimePriority
"
)
?
)
?
;
if
max_prio
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new
(
"
invalid
negative
MaxRealtimePriority
"
)
)
;
}
let
max_rttime
=
item_as_i64
(
p
.
get
(
"
RTTimeUSecMax
"
)
?
)
?
;
if
max_rttime
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new
(
"
invalid
negative
RTTimeUSecMax
"
)
)
;
}
if
unsafe
{
libc
:
:
getrlimit
(
libc
:
:
RLIMIT_RTTIME
&
mut
current_limit
)
}
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
getrlimit
"
Box
:
:
new
(
OSError
:
:
last_os_error
(
)
)
)
)
;
}
Ok
(
(
max_prio
(
max_rttime
as
u64
)
current_limit
)
)
}
fn
set_limits
(
request
:
u64
max
:
u64
)
-
>
Result
<
(
)
AudioThreadPriorityError
>
{
#
[
allow
(
clippy
:
:
useless_conversion
)
]
let
new_limit
=
libc
:
:
rlimit
{
rlim_cur
:
request
.
try_into
(
)
.
map_err
(
|
_
|
AudioThreadPriorityError
:
:
new
(
"
setrlimit
"
)
)
?
rlim_max
:
max
.
try_into
(
)
.
map_err
(
|
_
|
AudioThreadPriorityError
:
:
new
(
"
setrlimit
"
)
)
?
}
;
if
unsafe
{
libc
:
:
setrlimit
(
libc
:
:
RLIMIT_RTTIME
&
new_limit
)
}
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
setrlimit
"
Box
:
:
new
(
OSError
:
:
last_os_error
(
)
)
)
)
;
}
Ok
(
(
)
)
}
pub
fn
promote_current_thread_to_real_time_internal
(
audio_buffer_frames
:
u32
audio_samplerate_hz
:
u32
)
-
>
Result
<
RtPriorityHandleInternal
AudioThreadPriorityError
>
{
let
thread_info
=
get_current_thread_info_internal
(
)
?
;
promote_thread_to_real_time_internal
(
thread_info
audio_buffer_frames
audio_samplerate_hz
)
}
pub
fn
demote_current_thread_from_real_time_internal
(
rt_priority_handle
:
RtPriorityHandleInternal
)
-
>
Result
<
(
)
AudioThreadPriorityError
>
{
assert
!
(
unsafe
{
libc
:
:
pthread_self
(
)
}
=
=
rt_priority_handle
.
thread_info
.
pthread_id
)
;
let
param
=
unsafe
{
std
:
:
mem
:
:
zeroed
:
:
<
libc
:
:
sched_param
>
(
)
}
;
if
unsafe
{
libc
:
:
pthread_setschedparam
(
rt_priority_handle
.
thread_info
.
pthread_id
rt_priority_handle
.
thread_info
.
policy
&
param
)
}
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
could
not
demote
thread
"
Box
:
:
new
(
OSError
:
:
last_os_error
(
)
)
)
)
;
}
Ok
(
(
)
)
}
pub
fn
demote_thread_from_real_time_internal
(
thread_info
:
RtPriorityThreadInfoInternal
)
-
>
Result
<
(
)
AudioThreadPriorityError
>
{
let
param
=
unsafe
{
std
:
:
mem
:
:
zeroed
:
:
<
libc
:
:
sched_param
>
(
)
}
;
const
SCHED_RESET_ON_FORK
:
libc
:
:
c_int
=
0x40000000
;
if
unsafe
{
libc
:
:
pthread_setschedparam
(
thread_info
.
pthread_id
libc
:
:
SCHED_OTHER
|
SCHED_RESET_ON_FORK
&
param
)
}
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
could
not
demote
thread
"
Box
:
:
new
(
OSError
:
:
last_os_error
(
)
)
)
)
;
}
Ok
(
(
)
)
}
pub
fn
get_current_thread_info_internal
(
)
-
>
Result
<
RtPriorityThreadInfoInternal
AudioThreadPriorityError
>
{
let
thread_id
=
unsafe
{
libc
:
:
syscall
(
libc
:
:
SYS_gettid
)
}
;
let
pthread_id
=
unsafe
{
libc
:
:
pthread_self
(
)
}
;
let
mut
param
=
unsafe
{
std
:
:
mem
:
:
zeroed
:
:
<
libc
:
:
sched_param
>
(
)
}
;
let
mut
policy
=
0
;
if
unsafe
{
libc
:
:
pthread_getschedparam
(
pthread_id
&
mut
policy
&
mut
param
)
}
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
pthread_getschedparam
"
Box
:
:
new
(
OSError
:
:
last_os_error
(
)
)
)
)
;
}
let
pid
=
unsafe
{
libc
:
:
getpid
(
)
}
;
Ok
(
RtPriorityThreadInfoInternal
{
pid
thread_id
pthread_id
policy
}
)
}
pub
fn
set_real_time_hard_limit_internal
(
audio_buffer_frames
:
u32
audio_samplerate_hz
:
u32
)
-
>
Result
<
(
)
AudioThreadPriorityError
>
{
let
buffer_frames
=
if
audio_buffer_frames
>
0
{
audio_buffer_frames
}
else
{
audio_samplerate_hz
/
20
}
;
let
budget_us
=
buffer_frames
as
u64
*
1_000_000
/
audio_samplerate_hz
as
u64
;
let
(
_
max_rttime
_
)
=
get_limits
(
)
?
;
let
rttime_request
=
cmp
:
:
min
(
budget_us
max_rttime
)
;
set_limits
(
rttime_request
max_rttime
)
?
;
Ok
(
(
)
)
}
pub
fn
promote_thread_to_real_time_internal
(
thread_info
:
RtPriorityThreadInfoInternal
audio_buffer_frames
:
u32
audio_samplerate_hz
:
u32
)
-
>
Result
<
RtPriorityHandleInternal
AudioThreadPriorityError
>
{
let
RtPriorityThreadInfoInternal
{
pid
thread_id
.
.
}
=
thread_info
;
let
handle
=
RtPriorityHandleInternal
{
thread_info
}
;
set_real_time_hard_limit_internal
(
audio_buffer_frames
audio_samplerate_hz
)
?
;
let
r
=
rtkit_set_realtime
(
thread_id
as
u64
pid
as
u64
RT_PRIO_DEFAULT
)
;
match
r
{
Ok
(
_
)
=
>
Ok
(
handle
)
Err
(
e
)
=
>
{
let
(
_
_
limits
)
=
get_limits
(
)
?
;
if
limits
.
rlim_cur
!
=
libc
:
:
RLIM_INFINITY
&
&
unsafe
{
libc
:
:
setrlimit
(
libc
:
:
RLIMIT_RTTIME
&
limits
)
}
<
0
{
return
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
setrlimit
"
Box
:
:
new
(
OSError
:
:
last_os_error
(
)
)
)
)
;
}
Err
(
AudioThreadPriorityError
:
:
new_with_inner
(
"
Thread
promotion
error
"
e
)
)
}
}
}
