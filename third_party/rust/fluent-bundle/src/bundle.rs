use
std
:
:
borrow
:
:
Borrow
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
collections
:
:
hash_map
:
:
{
Entry
as
HashEntry
HashMap
}
;
use
std
:
:
default
:
:
Default
;
use
std
:
:
fmt
;
use
fluent_syntax
:
:
ast
;
use
unic_langid
:
:
LanguageIdentifier
;
use
crate
:
:
args
:
:
FluentArgs
;
use
crate
:
:
entry
:
:
Entry
;
use
crate
:
:
entry
:
:
GetEntry
;
use
crate
:
:
errors
:
:
{
EntryKind
FluentError
}
;
use
crate
:
:
memoizer
:
:
MemoizerKind
;
use
crate
:
:
message
:
:
{
FluentAttribute
FluentMessage
}
;
use
crate
:
:
resolver
:
:
{
ResolveValue
Scope
WriteValue
}
;
use
crate
:
:
resource
:
:
FluentResource
;
use
crate
:
:
types
:
:
FluentValue
;
pub
struct
FluentBundleBase
<
R
M
>
{
pub
locales
:
Vec
<
LanguageIdentifier
>
pub
(
crate
)
resources
:
Vec
<
R
>
pub
(
crate
)
entries
:
HashMap
<
String
Entry
>
pub
(
crate
)
intls
:
M
pub
(
crate
)
use_isolating
:
bool
pub
(
crate
)
transform
:
Option
<
fn
(
&
str
)
-
>
Cow
<
str
>
>
pub
(
crate
)
formatter
:
Option
<
fn
(
&
FluentValue
&
M
)
-
>
Option
<
String
>
>
}
impl
<
R
M
:
MemoizerKind
>
FluentBundleBase
<
R
M
>
{
pub
fn
new
(
locales
:
Vec
<
LanguageIdentifier
>
)
-
>
Self
{
let
first_locale
=
locales
.
get
(
0
)
.
cloned
(
)
.
unwrap_or_default
(
)
;
Self
{
locales
resources
:
vec
!
[
]
entries
:
HashMap
:
:
new
(
)
intls
:
M
:
:
new
(
first_locale
)
use_isolating
:
true
transform
:
None
formatter
:
None
}
}
pub
fn
add_resource
(
&
mut
self
r
:
R
)
-
>
Result
<
(
)
Vec
<
FluentError
>
>
where
R
:
Borrow
<
FluentResource
>
{
let
mut
errors
=
vec
!
[
]
;
let
res
=
r
.
borrow
(
)
;
let
res_pos
=
self
.
resources
.
len
(
)
;
for
(
entry_pos
entry
)
in
res
.
ast
(
)
.
body
.
iter
(
)
.
enumerate
(
)
{
let
id
=
match
entry
{
ast
:
:
Entry
:
:
Message
(
ast
:
:
Message
{
ref
id
.
.
}
)
|
ast
:
:
Entry
:
:
Term
(
ast
:
:
Term
{
ref
id
.
.
}
)
=
>
id
.
name
_
=
>
continue
}
;
let
(
entry
kind
)
=
match
entry
{
ast
:
:
Entry
:
:
Message
(
.
.
)
=
>
{
(
Entry
:
:
Message
(
[
res_pos
entry_pos
]
)
EntryKind
:
:
Message
)
}
ast
:
:
Entry
:
:
Term
(
.
.
)
=
>
(
Entry
:
:
Term
(
[
res_pos
entry_pos
]
)
EntryKind
:
:
Term
)
_
=
>
continue
}
;
match
self
.
entries
.
entry
(
id
.
to_string
(
)
)
{
HashEntry
:
:
Vacant
(
empty
)
=
>
{
empty
.
insert
(
entry
)
;
}
HashEntry
:
:
Occupied
(
_
)
=
>
{
errors
.
push
(
FluentError
:
:
Overriding
{
kind
id
:
id
.
to_string
(
)
}
)
;
}
}
}
self
.
resources
.
push
(
r
)
;
if
errors
.
is_empty
(
)
{
Ok
(
(
)
)
}
else
{
Err
(
errors
)
}
}
pub
fn
add_resource_overriding
(
&
mut
self
r
:
R
)
where
R
:
Borrow
<
FluentResource
>
{
let
res
=
r
.
borrow
(
)
;
let
res_pos
=
self
.
resources
.
len
(
)
;
for
(
entry_pos
entry
)
in
res
.
ast
(
)
.
body
.
iter
(
)
.
enumerate
(
)
{
let
id
=
match
entry
{
ast
:
:
Entry
:
:
Message
(
ast
:
:
Message
{
ref
id
.
.
}
)
|
ast
:
:
Entry
:
:
Term
(
ast
:
:
Term
{
ref
id
.
.
}
)
=
>
id
.
name
_
=
>
continue
}
;
let
entry
=
match
entry
{
ast
:
:
Entry
:
:
Message
(
.
.
)
=
>
Entry
:
:
Message
(
[
res_pos
entry_pos
]
)
ast
:
:
Entry
:
:
Term
(
.
.
)
=
>
Entry
:
:
Term
(
[
res_pos
entry_pos
]
)
_
=
>
continue
}
;
self
.
entries
.
insert
(
id
.
to_string
(
)
entry
)
;
}
self
.
resources
.
push
(
r
)
;
}
pub
fn
set_use_isolating
(
&
mut
self
value
:
bool
)
{
self
.
use_isolating
=
value
;
}
pub
fn
set_transform
(
&
mut
self
func
:
Option
<
fn
(
&
str
)
-
>
Cow
<
str
>
>
)
{
if
let
Some
(
f
)
=
func
{
self
.
transform
=
Some
(
f
)
;
}
else
{
self
.
transform
=
None
;
}
}
pub
fn
set_formatter
(
&
mut
self
func
:
Option
<
fn
(
&
FluentValue
&
M
)
-
>
Option
<
String
>
>
)
{
if
let
Some
(
f
)
=
func
{
self
.
formatter
=
Some
(
f
)
;
}
else
{
self
.
formatter
=
None
;
}
}
pub
fn
has_message
(
&
self
id
:
&
str
)
-
>
bool
where
R
:
Borrow
<
FluentResource
>
{
self
.
get_entry_message
(
id
)
.
is_some
(
)
}
pub
fn
get_message
(
&
self
id
:
&
str
)
-
>
Option
<
FluentMessage
>
where
R
:
Borrow
<
FluentResource
>
{
let
message
=
self
.
get_entry_message
(
id
)
?
;
let
value
=
message
.
value
.
as_ref
(
)
;
let
mut
attributes
=
Vec
:
:
with_capacity
(
message
.
attributes
.
len
(
)
)
;
for
attr
in
&
message
.
attributes
{
attributes
.
push
(
FluentAttribute
{
id
:
attr
.
id
.
name
value
:
&
attr
.
value
}
)
;
}
Some
(
FluentMessage
{
value
attributes
}
)
}
pub
fn
write_pattern
<
'
bundle
W
>
(
&
'
bundle
self
w
:
&
mut
W
pattern
:
&
'
bundle
ast
:
:
Pattern
<
&
str
>
args
:
Option
<
&
'
bundle
FluentArgs
>
errors
:
&
mut
Vec
<
FluentError
>
)
-
>
fmt
:
:
Result
where
R
:
Borrow
<
FluentResource
>
W
:
fmt
:
:
Write
{
let
mut
scope
=
Scope
:
:
new
(
self
args
Some
(
errors
)
)
;
pattern
.
write
(
w
&
mut
scope
)
}
pub
fn
format_pattern
<
'
bundle
>
(
&
'
bundle
self
pattern
:
&
'
bundle
ast
:
:
Pattern
<
&
str
>
args
:
Option
<
&
'
bundle
FluentArgs
>
errors
:
&
mut
Vec
<
FluentError
>
)
-
>
Cow
<
'
bundle
str
>
where
R
:
Borrow
<
FluentResource
>
{
let
mut
scope
=
Scope
:
:
new
(
self
args
Some
(
errors
)
)
;
let
value
=
pattern
.
resolve
(
&
mut
scope
)
;
value
.
as_string
(
&
scope
)
}
pub
fn
add_function
<
F
>
(
&
mut
self
id
:
&
str
func
:
F
)
-
>
Result
<
(
)
FluentError
>
where
F
:
for
<
'
a
>
Fn
(
&
[
FluentValue
<
'
a
>
]
&
FluentArgs
)
-
>
FluentValue
<
'
a
>
+
Sync
+
Send
+
'
static
{
match
self
.
entries
.
entry
(
id
.
to_owned
(
)
)
{
HashEntry
:
:
Vacant
(
entry
)
=
>
{
entry
.
insert
(
Entry
:
:
Function
(
Box
:
:
new
(
func
)
)
)
;
Ok
(
(
)
)
}
HashEntry
:
:
Occupied
(
_
)
=
>
Err
(
FluentError
:
:
Overriding
{
kind
:
EntryKind
:
:
Function
id
:
id
.
to_owned
(
)
}
)
}
}
}
impl
<
R
M
:
MemoizerKind
>
Default
for
FluentBundleBase
<
R
M
>
{
fn
default
(
)
-
>
Self
{
let
langid
=
LanguageIdentifier
:
:
default
(
)
;
Self
{
locales
:
vec
!
[
langid
.
clone
(
)
]
resources
:
vec
!
[
]
entries
:
Default
:
:
default
(
)
use_isolating
:
true
intls
:
M
:
:
new
(
langid
)
transform
:
None
formatter
:
None
}
}
}
