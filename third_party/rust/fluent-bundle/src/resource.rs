use
fluent_syntax
:
:
ast
;
use
fluent_syntax
:
:
parser
:
:
{
parse_runtime
ParserError
}
;
use
self_cell
:
:
self_cell
;
type
Resource
<
'
s
>
=
ast
:
:
Resource
<
&
'
s
str
>
;
self_cell
!
(
pub
struct
InnerFluentResource
{
owner
:
String
#
[
covariant
]
dependent
:
Resource
}
impl
{
Debug
}
)
;
#
[
derive
(
Debug
)
]
pub
struct
FluentResource
(
InnerFluentResource
)
;
impl
FluentResource
{
pub
fn
try_new
(
source
:
String
)
-
>
Result
<
Self
(
Self
Vec
<
ParserError
>
)
>
{
let
mut
errors
=
None
;
let
res
=
InnerFluentResource
:
:
new
(
source
|
source
|
match
parse_runtime
(
source
.
as_str
(
)
)
{
Ok
(
ast
)
=
>
ast
Err
(
(
ast
err
)
)
=
>
{
errors
=
Some
(
err
)
;
ast
}
}
)
;
match
errors
{
None
=
>
Ok
(
Self
(
res
)
)
Some
(
err
)
=
>
Err
(
(
Self
(
res
)
err
)
)
}
}
pub
fn
source
(
&
self
)
-
>
&
str
{
&
self
.
0
.
borrow_owner
(
)
}
pub
fn
entries
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
ast
:
:
Entry
<
&
str
>
>
{
self
.
0
.
borrow_dependent
(
)
.
body
.
iter
(
)
}
pub
fn
get_entry
(
&
self
idx
:
usize
)
-
>
Option
<
&
ast
:
:
Entry
<
&
str
>
>
{
self
.
0
.
borrow_dependent
(
)
.
body
.
get
(
idx
)
}
}
