use
crate
:
:
numeric_value
:
:
{
parse_float
parse_int
NumericLiteralBase
}
;
use
crate
:
:
parser
:
:
Parser
;
use
ast
:
:
source_atom_set
:
:
{
CommonSourceAtomSetIndices
SourceAtomSet
}
;
use
ast
:
:
source_slice_list
:
:
SourceSliceList
;
use
ast
:
:
SourceLocation
;
use
bumpalo
:
:
{
collections
:
:
String
Bump
}
;
use
generated_parser
:
:
{
ParseError
Result
TerminalId
Token
TokenValue
}
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
str
:
:
Chars
;
use
unic_ucd_ident
:
:
{
is_id_continue
is_id_start
}
;
pub
struct
Lexer
<
'
alloc
>
{
allocator
:
&
'
alloc
Bump
source_length
:
usize
chars
:
Chars
<
'
alloc
>
is_on_new_line
:
bool
atoms
:
Rc
<
RefCell
<
SourceAtomSet
<
'
alloc
>
>
>
slices
:
Rc
<
RefCell
<
SourceSliceList
<
'
alloc
>
>
>
}
enum
NumericResult
{
Int
{
base
:
NumericLiteralBase
}
Float
BigInt
{
#
[
allow
(
dead_code
)
]
base
:
NumericLiteralBase
}
}
impl
<
'
alloc
>
Lexer
<
'
alloc
>
{
pub
fn
new
(
allocator
:
&
'
alloc
Bump
chars
:
Chars
<
'
alloc
>
atoms
:
Rc
<
RefCell
<
SourceAtomSet
<
'
alloc
>
>
>
slices
:
Rc
<
RefCell
<
SourceSliceList
<
'
alloc
>
>
>
)
-
>
Lexer
<
'
alloc
>
{
Self
:
:
with_offset
(
allocator
chars
0
atoms
slices
)
}
pub
fn
with_offset
(
allocator
:
&
'
alloc
Bump
chars
:
Chars
<
'
alloc
>
offset
:
usize
atoms
:
Rc
<
RefCell
<
SourceAtomSet
<
'
alloc
>
>
>
slices
:
Rc
<
RefCell
<
SourceSliceList
<
'
alloc
>
>
>
)
-
>
Lexer
<
'
alloc
>
{
let
source_length
=
offset
+
chars
.
as_str
(
)
.
len
(
)
;
Lexer
{
allocator
source_length
chars
is_on_new_line
:
true
atoms
slices
}
}
fn
is_looking_at
(
&
self
s
:
&
str
)
-
>
bool
{
self
.
chars
.
as_str
(
)
.
starts_with
(
s
)
}
pub
fn
offset
(
&
self
)
-
>
usize
{
self
.
source_length
-
self
.
chars
.
as_str
(
)
.
len
(
)
}
fn
peek
(
&
self
)
-
>
Option
<
char
>
{
self
.
chars
.
as_str
(
)
.
chars
(
)
.
next
(
)
}
fn
double_peek
(
&
self
)
-
>
Option
<
char
>
{
let
mut
chars
=
self
.
chars
.
as_str
(
)
.
chars
(
)
;
chars
.
next
(
)
;
chars
.
next
(
)
}
pub
fn
next
<
'
parser
>
(
&
mut
self
parser
:
&
Parser
<
'
parser
>
)
-
>
Result
<
'
alloc
Token
>
{
let
result
=
self
.
advance_impl
(
parser
)
?
;
let
is_on_new_line
=
self
.
is_on_new_line
;
self
.
is_on_new_line
=
false
;
Ok
(
Token
{
terminal_id
:
result
.
terminal_id
loc
:
result
.
loc
is_on_new_line
value
:
result
.
value
}
)
}
fn
unexpected_err
(
&
mut
self
)
-
>
ParseError
<
'
alloc
>
{
if
let
Some
(
ch
)
=
self
.
peek
(
)
{
ParseError
:
:
IllegalCharacter
(
ch
)
}
else
{
ParseError
:
:
UnexpectedEnd
}
}
}
const
ZWNJ
:
char
=
'
\
u
{
200c
}
'
;
const
ZWJ
:
char
=
'
\
u
{
200d
}
'
;
const
ZWNBSP
:
char
=
'
\
u
{
feff
}
'
;
const
TAB
:
char
=
'
\
u
{
9
}
'
;
const
VT
:
char
=
'
\
u
{
b
}
'
;
const
FF
:
char
=
'
\
u
{
c
}
'
;
const
SP
:
char
=
'
\
u
{
20
}
'
;
const
NBSP
:
char
=
'
\
u
{
a0
}
'
;
const
LF
:
char
=
'
\
u
{
a
}
'
;
const
CR
:
char
=
'
\
u
{
d
}
'
;
const
LS
:
char
=
'
\
u
{
2028
}
'
;
const
PS
:
char
=
'
\
u
{
2029
}
'
;
struct
AdvanceResult
{
terminal_id
:
TerminalId
loc
:
SourceLocation
value
:
TokenValue
}
impl
<
'
alloc
>
Lexer
<
'
alloc
>
{
fn
skip_multi_line_comment
(
&
mut
self
builder
:
&
mut
AutoCow
<
'
alloc
>
)
-
>
Result
<
'
alloc
(
)
>
{
while
let
Some
(
ch
)
=
self
.
chars
.
next
(
)
{
match
ch
{
'
*
'
if
self
.
peek
(
)
=
=
Some
(
'
/
'
)
=
>
{
self
.
chars
.
next
(
)
;
*
builder
=
AutoCow
:
:
new
(
&
self
)
;
return
Ok
(
(
)
)
;
}
CR
|
LF
|
PS
|
LS
=
>
{
self
.
is_on_new_line
=
true
;
}
_
=
>
{
}
}
}
Err
(
ParseError
:
:
UnterminatedMultiLineComment
)
}
fn
skip_single_line_comment
(
&
mut
self
builder
:
&
mut
AutoCow
<
'
alloc
>
)
{
while
let
Some
(
ch
)
=
self
.
chars
.
next
(
)
{
match
ch
{
CR
|
LF
|
LS
|
PS
=
>
break
_
=
>
continue
}
}
*
builder
=
AutoCow
:
:
new
(
&
self
)
;
self
.
is_on_new_line
=
true
;
}
}
fn
is_identifier_start
(
c
:
char
)
-
>
bool
{
if
c
.
is_ascii
(
)
{
c
=
=
'
'
|
|
c
=
=
'
_
'
|
|
c
.
is_ascii_alphabetic
(
)
}
else
{
is_id_start
(
c
)
}
}
fn
is_identifier_part
(
c
:
char
)
-
>
bool
{
if
c
.
is_ascii
(
)
{
c
=
=
'
'
|
|
c
=
=
'
_
'
|
|
c
.
is_ascii_alphanumeric
(
)
}
else
{
is_id_continue
(
c
)
|
|
c
=
=
ZWNJ
|
|
c
=
=
ZWJ
}
}
impl
<
'
alloc
>
Lexer
<
'
alloc
>
{
fn
identifier_name_tail
(
&
mut
self
mut
builder
:
AutoCow
<
'
alloc
>
)
-
>
Result
<
'
alloc
(
bool
&
'
alloc
str
)
>
{
while
let
Some
(
ch
)
=
self
.
peek
(
)
{
if
!
is_identifier_part
(
ch
)
{
if
ch
=
=
'
\
\
'
{
self
.
chars
.
next
(
)
;
builder
.
force_allocation_without_current_ascii_char
(
&
self
)
;
let
value
=
self
.
unicode_escape_sequence_after_backslash
(
)
?
;
if
!
is_identifier_part
(
value
)
{
return
Err
(
ParseError
:
:
InvalidEscapeSequence
)
;
}
builder
.
push_different
(
value
)
;
continue
;
}
break
;
}
self
.
chars
.
next
(
)
;
builder
.
push_matching
(
ch
)
;
}
let
has_different
=
builder
.
has_different
(
)
;
Ok
(
(
has_different
builder
.
finish
(
&
self
)
)
)
}
fn
identifier_name
(
&
mut
self
mut
builder
:
AutoCow
<
'
alloc
>
)
-
>
Result
<
'
alloc
&
'
alloc
str
>
{
match
self
.
chars
.
next
(
)
{
None
=
>
{
return
Err
(
ParseError
:
:
UnexpectedEnd
)
;
}
Some
(
c
)
=
>
{
match
c
{
'
'
|
'
_
'
|
'
a
'
.
.
=
'
z
'
|
'
A
'
.
.
=
'
Z
'
=
>
{
builder
.
push_matching
(
c
)
;
}
'
\
\
'
=
>
{
builder
.
force_allocation_without_current_ascii_char
(
&
self
)
;
let
value
=
self
.
unicode_escape_sequence_after_backslash
(
)
?
;
if
!
is_identifier_start
(
value
)
{
return
Err
(
ParseError
:
:
IllegalCharacter
(
value
)
)
;
}
builder
.
push_different
(
value
)
;
}
other
if
is_identifier_start
(
other
)
=
>
{
builder
.
push_matching
(
other
)
;
}
other
=
>
{
return
Err
(
ParseError
:
:
IllegalCharacter
(
other
)
)
;
}
}
self
.
identifier_name_tail
(
builder
)
.
map
(
|
(
_has_escapes
name
)
|
name
)
}
}
}
fn
identifier_tail
(
&
mut
self
start
:
usize
builder
:
AutoCow
<
'
alloc
>
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
(
has_different
text
)
=
self
.
identifier_name_tail
(
builder
)
?
;
let
(
id
value
)
=
if
has_different
{
(
TerminalId
:
:
NameWithEscape
self
.
string_to_token_value
(
text
)
)
}
else
{
match
&
text
as
&
str
{
"
as
"
=
>
(
TerminalId
:
:
As
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
as_
(
)
)
)
"
async
"
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
async
cannot
be
handled
in
parser
due
to
multiple
lookahead
"
)
)
;
}
"
await
"
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
await
cannot
be
handled
in
parser
"
)
)
;
}
"
break
"
=
>
(
TerminalId
:
:
Break
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
break_
(
)
)
)
"
case
"
=
>
(
TerminalId
:
:
Case
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
case
(
)
)
)
"
catch
"
=
>
(
TerminalId
:
:
Catch
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
catch
(
)
)
)
"
class
"
=
>
(
TerminalId
:
:
Class
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
class
(
)
)
)
"
const
"
=
>
(
TerminalId
:
:
Const
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
const_
(
)
)
)
"
continue
"
=
>
(
TerminalId
:
:
Continue
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
continue_
(
)
)
)
"
debugger
"
=
>
(
TerminalId
:
:
Debugger
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
debugger
(
)
)
)
"
default
"
=
>
(
TerminalId
:
:
Default
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
default
(
)
)
)
"
delete
"
=
>
(
TerminalId
:
:
Delete
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
delete
(
)
)
)
"
do
"
=
>
(
TerminalId
:
:
Do
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
do_
(
)
)
)
"
else
"
=
>
(
TerminalId
:
:
Else
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
else_
(
)
)
)
"
enum
"
=
>
(
TerminalId
:
:
Enum
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
enum_
(
)
)
)
"
export
"
=
>
(
TerminalId
:
:
Export
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
export
(
)
)
)
"
extends
"
=
>
(
TerminalId
:
:
Extends
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
extends
(
)
)
)
"
finally
"
=
>
(
TerminalId
:
:
Finally
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
finally
(
)
)
)
"
for
"
=
>
(
TerminalId
:
:
For
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
for_
(
)
)
)
"
from
"
=
>
(
TerminalId
:
:
From
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
from
(
)
)
)
"
function
"
=
>
(
TerminalId
:
:
Function
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
function
(
)
)
)
"
get
"
=
>
(
TerminalId
:
:
Get
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
get
(
)
)
)
"
if
"
=
>
(
TerminalId
:
:
If
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
if_
(
)
)
)
"
implements
"
=
>
(
TerminalId
:
:
Implements
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
implements
(
)
)
)
"
import
"
=
>
(
TerminalId
:
:
Import
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
import
(
)
)
)
"
in
"
=
>
(
TerminalId
:
:
In
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
in_
(
)
)
)
"
instanceof
"
=
>
(
TerminalId
:
:
Instanceof
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
instanceof
(
)
)
)
"
interface
"
=
>
(
TerminalId
:
:
Interface
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
interface
(
)
)
)
"
let
"
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
let
cannot
be
handled
in
parser
due
to
multiple
lookahead
"
)
)
;
}
"
new
"
=
>
(
TerminalId
:
:
New
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
new_
(
)
)
)
"
of
"
=
>
(
TerminalId
:
:
Of
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
of
(
)
)
)
"
package
"
=
>
(
TerminalId
:
:
Package
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
package
(
)
)
)
"
private
"
=
>
(
TerminalId
:
:
Private
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
private
(
)
)
)
"
protected
"
=
>
(
TerminalId
:
:
Protected
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
protected
(
)
)
)
"
public
"
=
>
(
TerminalId
:
:
Public
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
public
(
)
)
)
"
return
"
=
>
(
TerminalId
:
:
Return
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
return_
(
)
)
)
"
set
"
=
>
(
TerminalId
:
:
Set
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
set
(
)
)
)
"
static
"
=
>
(
TerminalId
:
:
Static
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
static_
(
)
)
)
"
super
"
=
>
(
TerminalId
:
:
Super
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
super_
(
)
)
)
"
switch
"
=
>
(
TerminalId
:
:
Switch
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
switch
(
)
)
)
"
target
"
=
>
(
TerminalId
:
:
Target
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
target
(
)
)
)
"
this
"
=
>
(
TerminalId
:
:
This
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
this
(
)
)
)
"
throw
"
=
>
(
TerminalId
:
:
Throw
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
throw
(
)
)
)
"
try
"
=
>
(
TerminalId
:
:
Try
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
try_
(
)
)
)
"
typeof
"
=
>
(
TerminalId
:
:
Typeof
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
typeof_
(
)
)
)
"
var
"
=
>
(
TerminalId
:
:
Var
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
var
(
)
)
)
"
void
"
=
>
(
TerminalId
:
:
Void
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
void
(
)
)
)
"
while
"
=
>
(
TerminalId
:
:
While
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
while_
(
)
)
)
"
with
"
=
>
(
TerminalId
:
:
With
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
with
(
)
)
)
"
yield
"
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
yield
cannot
be
handled
in
parser
"
)
)
;
}
"
null
"
=
>
(
TerminalId
:
:
NullLiteral
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
null
(
)
)
)
"
true
"
=
>
(
TerminalId
:
:
BooleanLiteral
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
true_
(
)
)
)
"
false
"
=
>
(
TerminalId
:
:
BooleanLiteral
TokenValue
:
:
Atom
(
CommonSourceAtomSetIndices
:
:
false_
(
)
)
)
_
=
>
(
TerminalId
:
:
Name
self
.
string_to_token_value
(
text
)
)
}
}
;
Ok
(
AdvanceResult
{
terminal_id
:
id
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
}
)
}
fn
private_identifier
(
&
mut
self
start
:
usize
builder
:
AutoCow
<
'
alloc
>
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
name
=
self
.
identifier_name
(
builder
)
?
;
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
PrivateIdentifier
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
self
.
string_to_token_value
(
name
)
}
)
}
fn
unicode_escape_sequence_after_backslash
(
&
mut
self
)
-
>
Result
<
'
alloc
char
>
{
match
self
.
chars
.
next
(
)
{
Some
(
'
u
'
)
=
>
{
}
_
=
>
{
return
Err
(
ParseError
:
:
InvalidEscapeSequence
)
;
}
}
self
.
unicode_escape_sequence_after_backslash_and_u
(
)
}
fn
unicode_escape_sequence_after_backslash_and_u
(
&
mut
self
)
-
>
Result
<
'
alloc
char
>
{
let
value
=
match
self
.
peek
(
)
{
Some
(
'
{
'
)
=
>
{
self
.
chars
.
next
(
)
;
let
value
=
self
.
code_point
(
)
?
;
match
self
.
chars
.
next
(
)
{
Some
(
'
}
'
)
=
>
{
}
_
=
>
{
return
Err
(
ParseError
:
:
InvalidEscapeSequence
)
;
}
}
value
}
_
=
>
self
.
hex_4_digits
(
)
?
}
;
Ok
(
value
)
}
}
impl
<
'
alloc
>
Lexer
<
'
alloc
>
{
fn
decimal_digits
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
if
let
Some
(
'
0
'
.
.
=
'
9
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
self
.
decimal_digits_after_first_digit
(
)
?
;
Ok
(
(
)
)
}
fn
optional_decimal_digits
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
if
let
Some
(
'
0
'
.
.
=
'
9
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Ok
(
(
)
)
;
}
self
.
decimal_digits_after_first_digit
(
)
?
;
Ok
(
(
)
)
}
fn
decimal_digits_after_first_digit
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
while
let
Some
(
next
)
=
self
.
peek
(
)
{
match
next
{
'
_
'
=
>
{
self
.
chars
.
next
(
)
;
if
let
Some
(
'
0
'
.
.
=
'
9
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
}
'
0
'
.
.
=
'
9
'
=
>
{
self
.
chars
.
next
(
)
;
}
_
=
>
break
}
}
Ok
(
(
)
)
}
fn
optional_exponent
(
&
mut
self
)
-
>
Result
<
'
alloc
bool
>
{
if
let
Some
(
'
e
'
)
|
Some
(
'
E
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
self
.
decimal_exponent
(
)
?
;
return
Ok
(
true
)
;
}
Ok
(
false
)
}
fn
decimal_exponent
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
if
let
Some
(
'
+
'
)
|
Some
(
'
-
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
self
.
decimal_digits
(
)
?
;
Ok
(
(
)
)
}
fn
hex_digit
(
&
mut
self
)
-
>
Result
<
'
alloc
u32
>
{
match
self
.
chars
.
next
(
)
{
None
=
>
Err
(
ParseError
:
:
InvalidEscapeSequence
)
Some
(
c
'
0
'
.
.
=
'
9
'
)
=
>
Ok
(
c
as
u32
-
'
0
'
as
u32
)
Some
(
c
'
a
'
.
.
=
'
f
'
)
=
>
Ok
(
10
+
(
c
as
u32
-
'
a
'
as
u32
)
)
Some
(
c
'
A
'
.
.
=
'
F
'
)
=
>
Ok
(
10
+
(
c
as
u32
-
'
A
'
as
u32
)
)
Some
(
other
)
=
>
Err
(
ParseError
:
:
IllegalCharacter
(
other
)
)
}
}
fn
code_point_to_char
(
value
:
u32
)
-
>
Result
<
'
alloc
char
>
{
if
0xd800
<
=
value
&
&
value
<
=
0xdfff
{
Err
(
ParseError
:
:
NotImplemented
(
"
unicode
escape
sequences
(
surrogates
)
"
)
)
}
else
{
char
:
:
try_from
(
value
)
.
map_err
(
|
_
|
ParseError
:
:
InvalidEscapeSequence
)
}
}
fn
hex_4_digits
(
&
mut
self
)
-
>
Result
<
'
alloc
char
>
{
let
mut
value
=
0
;
for
_
in
0
.
.
4
{
value
=
(
value
<
<
4
)
|
self
.
hex_digit
(
)
?
;
}
Self
:
:
code_point_to_char
(
value
)
}
fn
code_point
(
&
mut
self
)
-
>
Result
<
'
alloc
char
>
{
let
mut
value
=
self
.
hex_digit
(
)
?
;
loop
{
let
next
=
match
self
.
peek
(
)
{
None
=
>
{
return
Err
(
ParseError
:
:
InvalidEscapeSequence
)
;
}
Some
(
c
'
0
'
.
.
=
'
9
'
)
=
>
c
as
u32
-
'
0
'
as
u32
Some
(
c
'
a
'
.
.
=
'
f
'
)
=
>
10
+
(
c
as
u32
-
'
a
'
as
u32
)
Some
(
c
'
A
'
.
.
=
'
F
'
)
=
>
10
+
(
c
as
u32
-
'
A
'
as
u32
)
Some
(
_
)
=
>
break
}
;
self
.
chars
.
next
(
)
;
value
=
(
value
<
<
4
)
|
next
;
if
value
>
0x10FFFF
{
return
Err
(
ParseError
:
:
InvalidEscapeSequence
)
;
}
}
Self
:
:
code_point_to_char
(
value
)
}
fn
numeric_literal_starting_with_zero
(
&
mut
self
)
-
>
Result
<
'
alloc
NumericResult
>
{
let
mut
base
=
NumericLiteralBase
:
:
Decimal
;
match
self
.
peek
(
)
{
Some
(
'
b
'
)
|
Some
(
'
B
'
)
=
>
{
self
.
chars
.
next
(
)
;
base
=
NumericLiteralBase
:
:
Binary
;
if
let
Some
(
'
0
'
.
.
=
'
1
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
while
let
Some
(
next
)
=
self
.
peek
(
)
{
match
next
{
'
_
'
=
>
{
self
.
chars
.
next
(
)
;
if
let
Some
(
'
0
'
.
.
=
'
1
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
}
'
0
'
.
.
=
'
1
'
=
>
{
self
.
chars
.
next
(
)
;
}
_
=
>
break
}
}
if
let
Some
(
'
n
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
self
.
check_after_numeric_literal
(
)
?
;
return
Ok
(
NumericResult
:
:
BigInt
{
base
}
)
;
}
}
Some
(
'
o
'
)
|
Some
(
'
O
'
)
=
>
{
self
.
chars
.
next
(
)
;
base
=
NumericLiteralBase
:
:
Octal
;
if
let
Some
(
'
0
'
.
.
=
'
7
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
while
let
Some
(
next
)
=
self
.
peek
(
)
{
match
next
{
'
_
'
=
>
{
self
.
chars
.
next
(
)
;
if
let
Some
(
'
0
'
.
.
=
'
7
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
}
'
0
'
.
.
=
'
7
'
=
>
{
self
.
chars
.
next
(
)
;
}
_
=
>
break
}
}
if
let
Some
(
'
n
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
self
.
check_after_numeric_literal
(
)
?
;
return
Ok
(
NumericResult
:
:
BigInt
{
base
}
)
;
}
}
Some
(
'
x
'
)
|
Some
(
'
X
'
)
=
>
{
self
.
chars
.
next
(
)
;
base
=
NumericLiteralBase
:
:
Hex
;
if
let
Some
(
'
0
'
.
.
=
'
9
'
)
|
Some
(
'
a
'
.
.
=
'
f
'
)
|
Some
(
'
A
'
.
.
=
'
F
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
while
let
Some
(
next
)
=
self
.
peek
(
)
{
match
next
{
'
_
'
=
>
{
self
.
chars
.
next
(
)
;
if
let
Some
(
'
0
'
.
.
=
'
9
'
)
|
Some
(
'
a
'
.
.
=
'
f
'
)
|
Some
(
'
A
'
.
.
=
'
F
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
}
else
{
return
Err
(
self
.
unexpected_err
(
)
)
;
}
}
'
0
'
.
.
=
'
9
'
|
'
a
'
.
.
=
'
f
'
|
'
A
'
.
.
=
'
F
'
=
>
{
self
.
chars
.
next
(
)
;
}
_
=
>
break
}
}
if
let
Some
(
'
n
'
)
=
self
.
peek
(
)
{
self
.
chars
.
next
(
)
;
self
.
check_after_numeric_literal
(
)
?
;
return
Ok
(
NumericResult
:
:
BigInt
{
base
}
)
;
}
}
Some
(
'
.
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
self
.
decimal_literal_after_decimal_point_after_digits
(
)
;
}
Some
(
'
e
'
)
|
Some
(
'
E
'
)
=
>
{
self
.
chars
.
next
(
)
;
self
.
decimal_exponent
(
)
?
;
return
Ok
(
NumericResult
:
:
Float
)
;
}
Some
(
'
n
'
)
=
>
{
self
.
chars
.
next
(
)
;
self
.
check_after_numeric_literal
(
)
?
;
return
Ok
(
NumericResult
:
:
BigInt
{
base
}
)
;
}
Some
(
'
0
'
.
.
=
'
9
'
)
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
LegacyOctalIntegerLiteral
"
)
)
;
}
_
=
>
{
}
}
self
.
check_after_numeric_literal
(
)
?
;
Ok
(
NumericResult
:
:
Int
{
base
}
)
}
fn
decimal_literal_after_first_digit
(
&
mut
self
)
-
>
Result
<
'
alloc
NumericResult
>
{
self
.
decimal_digits_after_first_digit
(
)
?
;
match
self
.
peek
(
)
{
Some
(
'
.
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
self
.
decimal_literal_after_decimal_point_after_digits
(
)
;
}
Some
(
'
n
'
)
=
>
{
self
.
chars
.
next
(
)
;
self
.
check_after_numeric_literal
(
)
?
;
return
Ok
(
NumericResult
:
:
BigInt
{
base
:
NumericLiteralBase
:
:
Decimal
}
)
;
}
_
=
>
{
}
}
let
has_exponent
=
self
.
optional_exponent
(
)
?
;
self
.
check_after_numeric_literal
(
)
?
;
let
result
=
if
has_exponent
{
NumericResult
:
:
Float
}
else
{
NumericResult
:
:
Int
{
base
:
NumericLiteralBase
:
:
Decimal
}
}
;
Ok
(
result
)
}
fn
decimal_literal_after_decimal_point
(
&
mut
self
)
-
>
Result
<
'
alloc
NumericResult
>
{
self
.
decimal_digits
(
)
?
;
self
.
optional_exponent
(
)
?
;
self
.
check_after_numeric_literal
(
)
?
;
Ok
(
NumericResult
:
:
Float
)
}
fn
decimal_literal_after_decimal_point_after_digits
(
&
mut
self
)
-
>
Result
<
'
alloc
NumericResult
>
{
self
.
optional_decimal_digits
(
)
?
;
self
.
optional_exponent
(
)
?
;
self
.
check_after_numeric_literal
(
)
?
;
Ok
(
NumericResult
:
:
Float
)
}
fn
check_after_numeric_literal
(
&
self
)
-
>
Result
<
'
alloc
(
)
>
{
if
let
Some
(
ch
)
=
self
.
peek
(
)
{
if
is_identifier_start
(
ch
)
|
|
ch
.
is_digit
(
10
)
{
return
Err
(
ParseError
:
:
IllegalCharacter
(
ch
)
)
;
}
}
Ok
(
(
)
)
}
fn
escape_sequence
(
&
mut
self
text
:
&
mut
String
<
'
alloc
>
)
-
>
Result
<
'
alloc
(
)
>
{
match
self
.
chars
.
next
(
)
{
None
=
>
{
return
Err
(
ParseError
:
:
UnterminatedString
)
;
}
Some
(
c
)
=
>
match
c
{
LF
|
LS
|
PS
=
>
{
}
CR
=
>
{
if
self
.
peek
(
)
=
=
Some
(
LF
)
{
self
.
chars
.
next
(
)
;
}
}
'
\
'
'
|
'
"
'
|
'
\
\
'
=
>
{
text
.
push
(
c
)
;
}
'
b
'
=
>
{
text
.
push
(
'
\
u
{
8
}
'
)
;
}
'
f
'
=
>
{
text
.
push
(
FF
)
;
}
'
n
'
=
>
{
text
.
push
(
LF
)
;
}
'
r
'
=
>
{
text
.
push
(
CR
)
;
}
'
t
'
=
>
{
text
.
push
(
TAB
)
;
}
'
v
'
=
>
{
text
.
push
(
VT
)
;
}
'
x
'
=
>
{
let
mut
value
=
self
.
hex_digit
(
)
?
;
value
=
(
value
<
<
4
)
|
self
.
hex_digit
(
)
?
;
match
char
:
:
try_from
(
value
)
{
Err
(
_
)
=
>
{
return
Err
(
ParseError
:
:
InvalidEscapeSequence
)
;
}
Ok
(
c
)
=
>
{
text
.
push
(
c
)
;
}
}
}
'
u
'
=
>
{
let
c
=
self
.
unicode_escape_sequence_after_backslash_and_u
(
)
?
;
text
.
push
(
c
)
;
}
'
0
'
=
>
{
match
self
.
peek
(
)
{
Some
(
'
0
'
.
.
=
'
7
'
)
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
legacy
octal
escape
sequence
in
string
"
)
)
;
}
Some
(
'
8
'
.
.
=
'
9
'
)
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
digit
immediately
following
\
\
0
escape
sequence
"
)
)
;
}
_
=
>
{
}
}
text
.
push
(
'
\
0
'
)
;
}
'
1
'
.
.
=
'
7
'
=
>
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
legacy
octal
escape
sequence
in
string
"
)
)
;
}
other
=
>
{
text
.
push
(
other
)
;
}
}
}
Ok
(
(
)
)
}
fn
string_literal
(
&
mut
self
delimiter
:
char
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
offset
=
self
.
offset
(
)
-
1
;
let
mut
builder
=
AutoCow
:
:
new
(
&
self
)
;
loop
{
match
self
.
chars
.
next
(
)
{
None
|
Some
(
'
\
r
'
)
|
Some
(
'
\
n
'
)
=
>
{
return
Err
(
ParseError
:
:
UnterminatedString
)
;
}
Some
(
c
'
"
'
)
|
Some
(
c
'
\
'
'
)
=
>
{
if
c
=
=
delimiter
{
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
StringLiteral
loc
:
SourceLocation
:
:
new
(
offset
self
.
offset
(
)
)
value
:
self
.
string_to_token_value
(
builder
.
finish_without_push
(
&
self
)
)
}
)
;
}
else
{
builder
.
push_matching
(
c
)
;
}
}
Some
(
'
\
\
'
)
=
>
{
let
text
=
builder
.
get_mut_string_without_current_ascii_char
(
&
self
)
;
self
.
escape_sequence
(
text
)
?
;
}
Some
(
other
)
=
>
{
builder
.
push_matching
(
other
)
;
}
}
}
}
fn
regular_expression_backslash_sequence
(
&
mut
self
)
-
>
Result
<
'
alloc
(
)
>
{
match
self
.
chars
.
next
(
)
{
None
|
Some
(
CR
)
|
Some
(
LF
)
|
Some
(
LS
)
|
Some
(
PS
)
=
>
Err
(
ParseError
:
:
UnterminatedRegExp
)
Some
(
_
)
=
>
Ok
(
(
)
)
}
}
fn
regular_expression_literal
(
&
mut
self
builder
:
&
mut
AutoCow
<
'
alloc
>
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
offset
=
self
.
offset
(
)
;
loop
{
match
self
.
chars
.
next
(
)
{
None
|
Some
(
CR
)
|
Some
(
LF
)
|
Some
(
LS
)
|
Some
(
PS
)
=
>
{
return
Err
(
ParseError
:
:
UnterminatedRegExp
)
;
}
Some
(
'
/
'
)
=
>
{
break
;
}
Some
(
'
[
'
)
=
>
{
loop
{
match
self
.
chars
.
next
(
)
{
None
|
Some
(
CR
)
|
Some
(
LF
)
|
Some
(
LS
)
|
Some
(
PS
)
=
>
{
return
Err
(
ParseError
:
:
UnterminatedRegExp
)
;
}
Some
(
'
]
'
)
=
>
{
break
;
}
Some
(
'
\
\
'
)
=
>
{
self
.
regular_expression_backslash_sequence
(
)
?
;
}
Some
(
_
)
=
>
{
}
}
}
}
Some
(
'
\
\
'
)
=
>
{
self
.
regular_expression_backslash_sequence
(
)
?
;
}
Some
(
_
)
=
>
{
}
}
}
let
mut
flag_text
=
AutoCow
:
:
new
(
&
self
)
;
while
let
Some
(
ch
)
=
self
.
peek
(
)
{
match
ch
{
'
'
|
'
_
'
|
'
a
'
.
.
=
'
z
'
|
'
A
'
.
.
=
'
Z
'
|
'
0
'
.
.
=
'
9
'
=
>
{
self
.
chars
.
next
(
)
;
flag_text
.
push_matching
(
ch
)
;
}
_
=
>
break
}
}
let
literal
=
builder
.
finish
(
&
self
)
;
let
gimsuy_mask
:
u32
=
[
'
g
'
'
i
'
'
m
'
'
s
'
'
u
'
'
y
'
]
.
iter
(
)
.
map
(
|
x
|
1
<
<
(
(
*
x
as
u8
)
-
(
'
a
'
as
u8
)
)
)
.
sum
(
)
;
let
mut
flag_text_set
:
u32
=
0
;
for
ch
in
flag_text
.
finish
(
&
self
)
.
chars
(
)
{
if
!
ch
.
is_ascii_lowercase
(
)
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
Unexpected
flag
in
regular
expression
literal
"
)
)
;
}
let
ch_mask
=
1
<
<
(
(
ch
as
u8
)
-
(
'
a
'
as
u8
)
)
;
if
ch_mask
&
gimsuy_mask
=
=
0
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
Unexpected
flag
in
regular
expression
literal
"
)
)
;
}
if
flag_text_set
&
ch_mask
!
=
0
{
return
Err
(
ParseError
:
:
NotImplemented
(
"
Flag
is
mentioned
twice
in
regular
expression
literal
"
)
)
;
}
flag_text_set
|
=
ch_mask
;
}
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
RegularExpressionLiteral
loc
:
SourceLocation
:
:
new
(
offset
self
.
offset
(
)
)
value
:
self
.
slice_to_token_value
(
literal
)
}
)
}
fn
template_part
(
&
mut
self
start
:
usize
subst
:
TerminalId
tail
:
TerminalId
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
mut
builder
=
AutoCow
:
:
new
(
&
self
)
;
while
let
Some
(
ch
)
=
self
.
chars
.
next
(
)
{
if
ch
=
=
'
'
&
&
self
.
peek
(
)
=
=
Some
(
'
{
'
)
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
subst
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
self
.
string_to_token_value
(
builder
.
finish_without_push
(
&
self
)
)
}
)
;
}
if
ch
=
=
'
'
{
return
Ok
(
AdvanceResult
{
terminal_id
:
tail
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
self
.
string_to_token_value
(
builder
.
finish_without_push
(
&
self
)
)
}
)
;
}
if
ch
=
=
'
\
\
'
{
let
text
=
builder
.
get_mut_string_without_current_ascii_char
(
&
self
)
;
self
.
escape_sequence
(
text
)
?
;
}
else
{
builder
.
push_matching
(
ch
)
;
}
}
Err
(
ParseError
:
:
UnterminatedString
)
}
fn
advance_impl
<
'
parser
>
(
&
mut
self
parser
:
&
Parser
<
'
parser
>
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
mut
builder
=
AutoCow
:
:
new
(
&
self
)
;
let
mut
start
=
self
.
offset
(
)
;
while
let
Some
(
c
)
=
self
.
chars
.
next
(
)
{
match
c
{
TAB
|
VT
|
FF
|
SP
|
NBSP
|
ZWNBSP
|
'
\
u
{
1680
}
'
|
'
\
u
{
2000
}
'
.
.
=
'
\
u
{
200a
}
'
|
'
\
u
{
202f
}
'
|
'
\
u
{
205f
}
'
|
'
\
u
{
3000
}
'
=
>
{
builder
=
AutoCow
:
:
new
(
&
self
)
;
start
=
self
.
offset
(
)
;
continue
;
}
LF
|
CR
|
LS
|
PS
=
>
{
self
.
is_on_new_line
=
true
;
builder
=
AutoCow
:
:
new
(
&
self
)
;
start
=
self
.
offset
(
)
;
continue
;
}
'
0
'
=
>
{
let
result
=
self
.
numeric_literal_starting_with_zero
(
)
?
;
return
Ok
(
self
.
numeric_result_to_advance_result
(
builder
.
finish
(
&
self
)
start
result
)
?
)
;
}
'
1
'
.
.
=
'
9
'
=
>
{
let
result
=
self
.
decimal_literal_after_first_digit
(
)
?
;
return
Ok
(
self
.
numeric_result_to_advance_result
(
builder
.
finish
(
&
self
)
start
result
)
?
)
;
}
'
"
'
|
'
\
'
'
=
>
{
return
self
.
string_literal
(
c
)
;
}
'
'
=
>
{
return
self
.
template_part
(
start
TerminalId
:
:
TemplateHead
TerminalId
:
:
NoSubstitutionTemplate
)
;
}
'
!
'
=
>
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
StrictNotEqual
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LaxNotEqual
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LogicalNot
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
%
'
=
>
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
RemainderAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Remainder
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
&
'
=
>
match
self
.
peek
(
)
{
Some
(
'
&
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LogicalAnd
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseAndAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseAnd
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
*
'
=
>
match
self
.
peek
(
)
{
Some
(
'
*
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
ExponentiateAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Exponentiate
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
MultiplyAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Star
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
+
'
=
>
match
self
.
peek
(
)
{
Some
(
'
+
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Increment
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
AddAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Plus
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
-
'
=
>
match
self
.
peek
(
)
{
Some
(
'
-
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
>
'
)
if
self
.
is_on_new_line
=
>
{
self
.
skip_single_line_comment
(
&
mut
builder
)
;
continue
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Decrement
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
SubtractAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Minus
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
.
'
=
>
match
self
.
peek
(
)
{
Some
(
'
.
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
.
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Ellipsis
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Err
(
ParseError
:
:
IllegalCharacter
(
'
.
'
)
)
}
}
Some
(
'
0
'
.
.
=
'
9
'
)
=
>
{
let
result
=
self
.
decimal_literal_after_decimal_point
(
)
?
;
return
Ok
(
self
.
numeric_result_to_advance_result
(
builder
.
finish
(
&
self
)
start
result
)
?
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Dot
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
/
'
=
>
match
self
.
peek
(
)
{
Some
(
'
/
'
)
=
>
{
self
.
chars
.
next
(
)
;
self
.
skip_single_line_comment
(
&
mut
builder
)
;
start
=
self
.
offset
(
)
;
continue
;
}
Some
(
'
*
'
)
=
>
{
self
.
chars
.
next
(
)
;
self
.
skip_multi_line_comment
(
&
mut
builder
)
?
;
start
=
self
.
offset
(
)
;
continue
;
}
_
=
>
{
if
parser
.
can_accept_terminal
(
TerminalId
:
:
Divide
)
{
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
DivideAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Divide
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
return
self
.
regular_expression_literal
(
&
mut
builder
)
;
}
}
'
}
'
=
>
{
if
parser
.
can_accept_terminal
(
TerminalId
:
:
TemplateMiddle
)
{
return
self
.
template_part
(
start
TerminalId
:
:
TemplateMiddle
TerminalId
:
:
TemplateTail
)
;
}
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
CloseBrace
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
'
<
'
=
>
match
self
.
peek
(
)
{
Some
(
'
<
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LeftShiftAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LeftShift
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LessThanOrEqualTo
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
Some
(
'
!
'
)
if
self
.
is_looking_at
(
"
!
-
-
"
)
=
>
{
self
.
skip_single_line_comment
(
&
mut
builder
)
;
start
=
self
.
offset
(
)
;
continue
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LessThan
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
=
'
=
>
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
StrictEqual
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LaxEqual
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
Some
(
'
>
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Arrow
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
EqualSign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
>
'
=
>
match
self
.
peek
(
)
{
Some
(
'
>
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
>
'
)
=
>
{
self
.
chars
.
next
(
)
;
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
UnsignedRightShiftAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
UnsignedRightShift
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
SignedRightShiftAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
SignedRightShift
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
GreaterThanOrEqualTo
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
GreaterThan
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
^
'
=
>
match
self
.
peek
(
)
{
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseXorAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseXor
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
|
'
=
>
match
self
.
peek
(
)
{
Some
(
'
|
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
LogicalOr
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
Some
(
'
=
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseOrAssign
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseOr
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
?
'
=
>
match
self
.
peek
(
)
{
Some
(
'
?
'
)
=
>
{
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Coalesce
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
Some
(
'
.
'
)
=
>
{
if
let
Some
(
'
0
'
.
.
=
'
9
'
)
=
self
.
double_peek
(
)
{
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
QuestionMark
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
self
.
chars
.
next
(
)
;
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
OptionalChain
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
;
}
_
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
QuestionMark
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
'
(
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
OpenParenthesis
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
)
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
CloseParenthesis
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Comma
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
:
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Colon
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
;
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
Semicolon
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
[
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
OpenBracket
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
]
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
CloseBracket
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
{
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
OpenBrace
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
~
'
=
>
return
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
BitwiseNot
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
'
'
|
'
_
'
|
'
a
'
.
.
=
'
z
'
|
'
A
'
.
.
=
'
Z
'
=
>
{
builder
.
push_matching
(
c
)
;
return
self
.
identifier_tail
(
start
builder
)
;
}
'
\
\
'
=
>
{
builder
.
force_allocation_without_current_ascii_char
(
&
self
)
;
let
value
=
self
.
unicode_escape_sequence_after_backslash
(
)
?
;
if
!
is_identifier_start
(
value
)
{
return
Err
(
ParseError
:
:
IllegalCharacter
(
value
)
)
;
}
builder
.
push_different
(
value
)
;
return
self
.
identifier_tail
(
start
builder
)
;
}
'
#
'
=
>
{
if
start
=
=
0
{
if
let
Some
(
'
!
'
)
=
self
.
peek
(
)
{
self
.
skip_single_line_comment
(
&
mut
builder
)
;
start
=
self
.
offset
(
)
;
continue
;
}
}
builder
.
push_matching
(
c
)
;
return
self
.
private_identifier
(
start
builder
)
;
}
other
if
is_identifier_start
(
other
)
=
>
{
builder
.
push_matching
(
other
)
;
return
self
.
identifier_tail
(
start
builder
)
;
}
other
=
>
{
return
Err
(
ParseError
:
:
IllegalCharacter
(
other
)
)
;
}
}
}
Ok
(
AdvanceResult
{
terminal_id
:
TerminalId
:
:
End
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
:
TokenValue
:
:
None
}
)
}
fn
string_to_token_value
(
&
mut
self
s
:
&
'
alloc
str
)
-
>
TokenValue
{
let
index
=
self
.
atoms
.
borrow_mut
(
)
.
insert
(
s
)
;
TokenValue
:
:
Atom
(
index
)
}
fn
slice_to_token_value
(
&
mut
self
s
:
&
'
alloc
str
)
-
>
TokenValue
{
let
index
=
self
.
slices
.
borrow_mut
(
)
.
insert
(
s
)
;
TokenValue
:
:
Slice
(
index
)
}
fn
numeric_result_to_advance_result
(
&
mut
self
s
:
&
'
alloc
str
start
:
usize
result
:
NumericResult
)
-
>
Result
<
'
alloc
AdvanceResult
>
{
let
(
terminal_id
value
)
=
match
result
{
NumericResult
:
:
Int
{
base
}
=
>
{
let
n
=
parse_int
(
s
base
)
.
map_err
(
|
s
|
ParseError
:
:
NotImplemented
(
s
)
)
?
;
(
TerminalId
:
:
NumericLiteral
TokenValue
:
:
Number
(
n
)
)
}
NumericResult
:
:
Float
=
>
{
let
n
=
parse_float
(
s
)
.
map_err
(
|
s
|
ParseError
:
:
NotImplemented
(
s
)
)
?
;
(
TerminalId
:
:
NumericLiteral
TokenValue
:
:
Number
(
n
)
)
}
NumericResult
:
:
BigInt
{
.
.
}
=
>
{
(
TerminalId
:
:
BigIntLiteral
self
.
string_to_token_value
(
s
)
)
}
}
;
Ok
(
AdvanceResult
{
terminal_id
loc
:
SourceLocation
:
:
new
(
start
self
.
offset
(
)
)
value
}
)
}
}
struct
AutoCow
<
'
alloc
>
{
start
:
&
'
alloc
str
value
:
Option
<
String
<
'
alloc
>
>
}
impl
<
'
alloc
>
AutoCow
<
'
alloc
>
{
fn
new
(
lexer
:
&
Lexer
<
'
alloc
>
)
-
>
Self
{
AutoCow
{
start
:
lexer
.
chars
.
as_str
(
)
value
:
None
}
}
fn
push_matching
(
&
mut
self
c
:
char
)
{
if
let
Some
(
text
)
=
&
mut
self
.
value
{
text
.
push
(
c
)
;
}
}
fn
push_different
(
&
mut
self
c
:
char
)
{
debug_assert
!
(
self
.
value
.
is_some
(
)
)
;
self
.
value
.
as_mut
(
)
.
unwrap
(
)
.
push
(
c
)
}
fn
get_mut_string_without_current_ascii_char
<
'
b
>
(
&
'
b
mut
self
lexer
:
&
'
_
Lexer
<
'
alloc
>
)
-
>
&
'
b
mut
String
<
'
alloc
>
{
self
.
force_allocation_without_current_ascii_char
(
lexer
)
;
self
.
value
.
as_mut
(
)
.
unwrap
(
)
}
fn
force_allocation_without_current_ascii_char
(
&
mut
self
lexer
:
&
'
_
Lexer
<
'
alloc
>
)
{
if
self
.
value
.
is_some
(
)
{
return
;
}
self
.
value
=
Some
(
String
:
:
from_str_in
(
&
self
.
start
[
.
.
self
.
start
.
len
(
)
-
lexer
.
chars
.
as_str
(
)
.
len
(
)
-
1
]
lexer
.
allocator
)
)
;
}
fn
has_different
(
&
self
)
-
>
bool
{
self
.
value
.
is_some
(
)
}
fn
finish
(
&
mut
self
lexer
:
&
Lexer
<
'
alloc
>
)
-
>
&
'
alloc
str
{
match
self
.
value
.
take
(
)
{
Some
(
arena_string
)
=
>
arena_string
.
into_bump_str
(
)
None
=
>
&
self
.
start
[
.
.
self
.
start
.
len
(
)
-
lexer
.
chars
.
as_str
(
)
.
len
(
)
]
}
}
fn
finish_without_push
(
&
mut
self
lexer
:
&
Lexer
<
'
alloc
>
)
-
>
&
'
alloc
str
{
match
self
.
value
.
take
(
)
{
Some
(
arena_string
)
=
>
arena_string
.
into_bump_str
(
)
None
=
>
&
self
.
start
[
.
.
self
.
start
.
len
(
)
-
lexer
.
chars
.
as_str
(
)
.
len
(
)
-
1
]
}
}
}
