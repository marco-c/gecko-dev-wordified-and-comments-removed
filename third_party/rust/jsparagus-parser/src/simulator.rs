use
crate
:
:
parser
:
:
Parser
;
use
ast
:
:
SourceLocation
;
use
generated_parser
:
:
{
noop_actions
ParseError
ParserTrait
Result
StackValue
Term
TermValue
TerminalId
Token
TABLES
}
;
pub
struct
Simulator
<
'
alloc
'
parser
>
{
sp
:
usize
state_stack
:
&
'
parser
[
usize
]
node_stack
:
&
'
parser
[
TermValue
<
StackValue
<
'
alloc
>
>
]
sim_state_stack
:
Vec
<
usize
>
sim_node_stack
:
Vec
<
TermValue
<
(
)
>
>
replay_stack
:
Vec
<
TermValue
<
(
)
>
>
}
impl
<
'
alloc
'
parser
>
ParserTrait
<
'
alloc
(
)
>
for
Simulator
<
'
alloc
'
parser
>
{
fn
shift
(
&
mut
self
tv
:
TermValue
<
(
)
>
)
-
>
Result
<
bool
>
{
let
mut
state
=
self
.
state
(
)
;
assert
!
(
state
<
TABLES
.
shift_count
)
;
let
mut
tv
=
tv
;
loop
{
let
term_index
:
usize
=
tv
.
term
.
into
(
)
;
assert
!
(
term_index
<
TABLES
.
shift_width
)
;
let
index
=
state
*
TABLES
.
shift_width
+
term_index
;
let
goto
=
TABLES
.
shift_table
[
index
]
;
if
goto
<
0
{
self
.
try_error_handling
(
tv
)
?
;
tv
=
self
.
replay_stack
.
pop
(
)
.
unwrap
(
)
;
continue
;
}
state
=
goto
as
usize
;
self
.
sim_state_stack
.
push
(
state
)
;
self
.
sim_node_stack
.
push
(
tv
)
;
while
state
>
=
TABLES
.
shift_count
{
assert
!
(
state
<
TABLES
.
action_count
+
TABLES
.
shift_count
)
;
if
noop_actions
(
self
state
)
?
{
return
Ok
(
true
)
;
}
state
=
self
.
state
(
)
;
}
assert
!
(
state
<
TABLES
.
shift_count
)
;
if
let
Some
(
tv_temp
)
=
self
.
replay_stack
.
pop
(
)
{
tv
=
tv_temp
;
}
else
{
break
;
}
}
Ok
(
false
)
}
fn
replay
(
&
mut
self
tv
:
TermValue
<
(
)
>
)
{
self
.
replay_stack
.
push
(
tv
)
}
fn
epsilon
(
&
mut
self
state
:
usize
)
{
if
self
.
sim_state_stack
.
is_empty
(
)
{
self
.
sim_state_stack
.
push
(
self
.
state_stack
[
self
.
sp
]
)
;
self
.
sim_node_stack
.
push
(
TermValue
{
term
:
self
.
node_stack
[
self
.
sp
-
1
]
.
term
value
:
(
)
}
)
;
self
.
sp
-
=
1
;
}
*
self
.
sim_state_stack
.
last_mut
(
)
.
unwrap
(
)
=
state
;
}
fn
pop
(
&
mut
self
)
-
>
TermValue
<
(
)
>
{
if
let
Some
(
s
)
=
self
.
sim_node_stack
.
pop
(
)
{
self
.
sim_state_stack
.
pop
(
)
;
return
s
;
}
let
t
=
self
.
node_stack
[
self
.
sp
-
1
]
.
term
;
self
.
sp
-
=
1
;
TermValue
{
term
:
t
value
:
(
)
}
}
fn
check_not_on_new_line
(
&
mut
self
_peek
:
usize
)
-
>
Result
<
bool
>
{
Ok
(
true
)
}
}
impl
<
'
alloc
'
parser
>
Simulator
<
'
alloc
'
parser
>
{
pub
fn
new
(
state_stack
:
&
'
parser
[
usize
]
node_stack
:
&
'
parser
[
TermValue
<
StackValue
<
'
alloc
>
>
]
)
-
>
Simulator
<
'
alloc
'
parser
>
{
let
sp
=
state_stack
.
len
(
)
-
1
;
assert_eq
!
(
state_stack
.
len
(
)
node_stack
.
len
(
)
+
1
)
;
Simulator
{
sp
state_stack
node_stack
sim_state_stack
:
vec
!
[
]
sim_node_stack
:
vec
!
[
]
replay_stack
:
vec
!
[
]
}
}
fn
state
(
&
self
)
-
>
usize
{
if
let
Some
(
res
)
=
self
.
sim_state_stack
.
last
(
)
{
*
res
}
else
{
self
.
state_stack
[
self
.
sp
]
}
}
pub
fn
write_token
(
&
mut
self
token
:
&
Token
)
-
>
Result
<
(
)
>
{
let
accept
=
self
.
shift
(
TermValue
{
term
:
Term
:
:
Terminal
(
token
.
terminal_id
)
value
:
(
)
}
)
?
;
assert
!
(
!
accept
)
;
Ok
(
(
)
)
}
pub
fn
close
(
&
mut
self
_position
:
usize
)
-
>
Result
<
(
)
>
{
let
accept
=
self
.
shift
(
TermValue
{
term
:
Term
:
:
Terminal
(
TerminalId
:
:
End
)
value
:
(
)
}
)
?
;
assert
!
(
accept
)
;
assert
!
(
self
.
sp
+
self
.
sim_node_stack
.
len
(
)
>
=
1
)
;
Ok
(
(
)
)
}
fn
try_error_handling
(
&
mut
self
t
:
TermValue
<
(
)
>
)
-
>
Result
<
bool
>
{
if
let
Term
:
:
Terminal
(
term
)
=
t
.
term
{
let
bogus_loc
=
SourceLocation
:
:
new
(
0
0
)
;
let
token
=
&
Token
:
:
basic_token
(
term
bogus_loc
)
;
if
t
.
term
=
=
Term
:
:
Terminal
(
TerminalId
:
:
ErrorToken
)
{
return
Err
(
Parser
:
:
parse_error
(
token
)
)
;
}
let
state
=
self
.
state
(
)
;
assert
!
(
state
<
TABLES
.
shift_count
)
;
let
error_code
=
TABLES
.
error_codes
[
state
]
;
if
let
Some
(
error_code
)
=
error_code
{
Parser
:
:
recover
(
token
error_code
)
?
;
self
.
replay
(
t
)
;
self
.
replay
(
TermValue
{
term
:
Term
:
:
Terminal
(
TerminalId
:
:
ErrorToken
)
value
:
(
)
}
)
;
return
Ok
(
false
)
;
}
return
Err
(
Parser
:
:
parse_error
(
token
)
)
;
}
Err
(
ParseError
:
:
ParserCannotUnpackToken
)
}
}
