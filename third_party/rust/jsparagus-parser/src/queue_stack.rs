use
std
:
:
ptr
;
pub
struct
QueueStack
<
T
>
{
buf
:
Vec
<
T
>
top
:
usize
gap
:
usize
}
impl
<
T
>
QueueStack
<
T
>
{
pub
fn
with_capacity
(
n
:
usize
)
-
>
QueueStack
<
T
>
{
QueueStack
{
buf
:
Vec
:
:
with_capacity
(
n
)
top
:
0
gap
:
0
}
}
pub
fn
enqueue
(
&
mut
self
value
:
T
)
{
self
.
buf
.
push
(
value
)
;
}
pub
fn
push_next
(
&
mut
self
value
:
T
)
{
self
.
compact_with_gap
(
1
)
;
self
.
gap
-
=
1
;
unsafe
{
let
ptr
=
self
.
buf
.
as_mut_ptr
(
)
.
add
(
self
.
top
+
self
.
gap
)
;
ptr
.
write
(
value
)
;
}
}
pub
fn
can_shift
(
&
self
)
-
>
bool
{
self
.
gap
=
=
0
&
&
!
self
.
queue_empty
(
)
}
pub
fn
can_unshift
(
&
self
)
-
>
bool
{
self
.
gap
=
=
0
&
&
!
self
.
stack_empty
(
)
}
pub
fn
unshift
(
&
mut
self
)
{
assert
!
(
self
.
can_unshift
(
)
)
;
self
.
top
-
=
1
;
}
#
[
inline
(
always
)
]
pub
fn
shift
(
&
mut
self
)
{
assert
!
(
self
.
can_shift
(
)
)
;
self
.
top
+
=
1
;
}
pub
fn
pop
(
&
mut
self
)
-
>
Option
<
T
>
{
if
self
.
top
=
=
0
{
None
}
else
{
self
.
top
-
=
1
;
self
.
gap
+
=
1
;
unsafe
{
let
ptr
=
self
.
buf
.
as_mut_ptr
(
)
.
add
(
self
.
top
)
;
Some
(
ptr
.
read
(
)
)
}
}
}
fn
compact_with_gap
(
&
mut
self
new_gap
:
usize
)
{
assert
!
(
new_gap
<
=
(
std
:
:
isize
:
:
MAX
as
usize
)
)
;
assert
!
(
self
.
gap
<
=
(
std
:
:
isize
:
:
MAX
as
usize
)
)
;
let
diff
=
new_gap
as
isize
-
self
.
gap
as
isize
;
if
diff
=
=
0
{
return
;
}
if
diff
>
0
{
self
.
buf
.
reserve
(
diff
as
usize
)
;
}
let
count
=
self
.
queue_len
(
)
;
let
new_len
=
self
.
top
+
new_gap
+
count
;
assert
!
(
new_len
<
self
.
buf
.
capacity
(
)
)
;
unsafe
{
let
src_ptr
=
self
.
buf
.
as_mut_ptr
(
)
.
add
(
self
.
top
+
self
.
gap
)
;
let
dst_ptr
=
src_ptr
.
offset
(
diff
)
;
ptr
:
:
copy
(
src_ptr
dst_ptr
count
)
;
self
.
buf
.
set_len
(
new_len
)
;
self
.
gap
=
new_gap
;
}
debug_assert_eq
!
(
self
.
queue_len
(
)
count
)
;
}
pub
fn
next
(
&
self
)
-
>
Option
<
&
T
>
{
if
self
.
queue_empty
(
)
{
None
}
else
{
Some
(
&
self
.
buf
[
self
.
top
+
self
.
gap
]
)
}
}
#
[
allow
(
dead_code
)
]
pub
fn
top
(
&
self
)
-
>
Option
<
&
T
>
{
if
self
.
top
=
=
0
{
None
}
else
{
Some
(
&
self
.
buf
[
self
.
top
-
1
]
)
}
}
#
[
allow
(
dead_code
)
]
pub
fn
top_mut
(
&
mut
self
)
-
>
Option
<
&
mut
T
>
{
if
self
.
top
=
=
0
{
None
}
else
{
Some
(
&
mut
self
.
buf
[
self
.
top
-
1
]
)
}
}
pub
fn
stack_len
(
&
self
)
-
>
usize
{
self
.
top
}
pub
fn
queue_len
(
&
self
)
-
>
usize
{
self
.
buf
.
len
(
)
-
self
.
top
-
self
.
gap
}
pub
fn
stack_empty
(
&
self
)
-
>
bool
{
self
.
top
=
=
0
}
pub
fn
queue_empty
(
&
self
)
-
>
bool
{
self
.
top
=
=
self
.
buf
.
len
(
)
}
pub
fn
stack_slice
(
&
self
)
-
>
&
[
T
]
{
&
self
.
buf
[
.
.
self
.
top
]
}
#
[
allow
(
dead_code
)
]
pub
fn
queue_slice
(
&
self
)
-
>
&
[
T
]
{
&
self
.
buf
[
self
.
top
+
self
.
gap
.
.
]
}
}
impl
<
T
>
Drop
for
QueueStack
<
T
>
{
fn
drop
(
&
mut
self
)
{
self
.
compact_with_gap
(
0
)
;
}
}
