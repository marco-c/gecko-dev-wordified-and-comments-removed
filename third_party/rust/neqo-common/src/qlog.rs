use
std
:
:
{
cell
:
:
RefCell
fmt
:
:
{
self
Display
}
fs
:
:
OpenOptions
io
:
:
BufWriter
path
:
:
PathBuf
rc
:
:
Rc
time
:
:
{
Instant
SystemTime
}
}
;
use
qlog
:
:
{
streamer
:
:
QlogStreamer
CommonFields
Configuration
TraceSeq
VantagePoint
VantagePointType
}
;
use
crate
:
:
Role
;
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
Qlog
{
inner
:
Option
<
Rc
<
RefCell
<
Option
<
SharedStreamer
>
>
>
>
}
pub
struct
SharedStreamer
{
qlog_path
:
PathBuf
streamer
:
QlogStreamer
}
impl
Qlog
{
pub
fn
enabled_with_file
<
D
:
Display
>
(
mut
qlog_path
:
PathBuf
role
:
Role
title
:
Option
<
String
>
description
:
Option
<
String
>
file_prefix
:
D
now
:
Instant
)
-
>
Result
<
Self
qlog
:
:
Error
>
{
qlog_path
.
push
(
format
!
(
"
{
file_prefix
}
.
sqlog
"
)
)
;
let
file
=
OpenOptions
:
:
new
(
)
.
write
(
true
)
.
create_new
(
true
)
.
open
(
&
qlog_path
)
?
;
let
streamer
=
QlogStreamer
:
:
new
(
qlog
:
:
QLOG_VERSION
.
to_string
(
)
title
description
None
now
new_trace
(
role
)
qlog
:
:
events
:
:
EventImportance
:
:
Base
Box
:
:
new
(
BufWriter
:
:
new
(
file
)
)
)
;
Self
:
:
enabled
(
streamer
qlog_path
)
}
pub
fn
enabled
(
mut
streamer
:
QlogStreamer
qlog_path
:
PathBuf
)
-
>
Result
<
Self
qlog
:
:
Error
>
{
streamer
.
start_log
(
)
?
;
Ok
(
Self
{
inner
:
Some
(
Rc
:
:
new
(
RefCell
:
:
new
(
Some
(
SharedStreamer
{
qlog_path
streamer
}
)
)
)
)
}
)
}
#
[
must_use
]
pub
fn
disabled
(
)
-
>
Self
{
Self
:
:
default
(
)
}
pub
fn
add_event_at
<
F
>
(
&
mut
self
f
:
F
now
:
Instant
)
where
F
:
FnOnce
(
)
-
>
Option
<
qlog
:
:
events
:
:
EventData
>
{
self
.
add_event_with_stream
(
|
s
|
{
if
let
Some
(
ev_data
)
=
f
(
)
{
s
.
add_event_data_with_instant
(
ev_data
now
)
?
;
}
Ok
(
(
)
)
}
)
;
}
pub
fn
add_event_with_stream
<
F
>
(
&
mut
self
f
:
F
)
where
F
:
FnOnce
(
&
mut
QlogStreamer
)
-
>
Result
<
(
)
qlog
:
:
Error
>
{
let
Some
(
inner
)
=
self
.
inner
.
as_mut
(
)
else
{
return
;
}
;
let
mut
borrow
=
inner
.
borrow_mut
(
)
;
let
Some
(
shared_streamer
)
=
borrow
.
as_mut
(
)
else
{
drop
(
borrow
)
;
self
.
inner
=
None
;
return
;
}
;
if
let
Err
(
e
)
=
f
(
&
mut
shared_streamer
.
streamer
)
{
log
:
:
error
!
(
"
Qlog
event
generation
failed
with
error
{
e
}
;
closing
qlog
.
"
)
;
*
borrow
=
None
;
drop
(
borrow
)
;
self
.
inner
=
None
;
}
}
}
impl
fmt
:
:
Debug
for
SharedStreamer
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Qlog
writing
to
{
}
"
self
.
qlog_path
.
display
(
)
)
}
}
impl
Drop
for
SharedStreamer
{
fn
drop
(
&
mut
self
)
{
if
let
Err
(
e
)
=
self
.
streamer
.
finish_log
(
)
{
log
:
:
error
!
(
"
Error
dropping
Qlog
:
{
e
}
"
)
;
}
}
}
#
[
must_use
]
pub
fn
new_trace
(
role
:
Role
)
-
>
TraceSeq
{
TraceSeq
{
vantage_point
:
VantagePoint
{
name
:
Some
(
format
!
(
"
neqo
-
{
role
}
"
)
)
ty
:
match
role
{
Role
:
:
Client
=
>
VantagePointType
:
:
Client
Role
:
:
Server
=
>
VantagePointType
:
:
Server
}
flow
:
None
}
title
:
Some
(
format
!
(
"
neqo
-
{
role
}
trace
"
)
)
description
:
Some
(
format
!
(
"
neqo
-
{
role
}
trace
"
)
)
configuration
:
Some
(
Configuration
{
time_offset
:
Some
(
0
.
0
)
original_uris
:
None
}
)
common_fields
:
Some
(
CommonFields
{
group_id
:
None
protocol_type
:
None
reference_time
:
SystemTime
:
:
now
(
)
.
duration_since
(
SystemTime
:
:
UNIX_EPOCH
)
.
map
(
|
d
|
d
.
as_secs_f64
(
)
*
1_000
.
0
)
.
ok
(
)
time_format
:
Some
(
"
relative
"
.
to_string
(
)
)
}
)
}
}
#
[
cfg
(
test
)
]
#
[
cfg_attr
(
coverage_nightly
coverage
(
off
)
)
]
mod
test
{
use
regex
:
:
Regex
;
use
test_fixture
:
:
EXPECTED_LOG_HEADER
;
const
EV_DATA
:
qlog
:
:
events
:
:
EventData
=
qlog
:
:
events
:
:
EventData
:
:
SpinBitUpdated
(
qlog
:
:
events
:
:
connectivity
:
:
SpinBitUpdated
{
state
:
true
}
)
;
const
EXPECTED_LOG_EVENT
:
&
str
=
concat
!
(
"
\
u
{
1e
}
"
r
#
"
{
"
time
"
:
0
.
0
"
name
"
:
"
connectivity
:
spin_bit_updated
"
"
data
"
:
{
"
state
"
:
true
}
}
"
#
"
\
n
"
)
;
#
[
test
]
fn
new_neqo_qlog
(
)
{
let
(
_log
contents
)
=
test_fixture
:
:
new_neqo_qlog
(
)
;
assert_eq
!
(
contents
.
to_string
(
)
EXPECTED_LOG_HEADER
)
;
}
#
[
test
]
fn
add_event_at
(
)
{
let
(
mut
log
contents
)
=
test_fixture
:
:
new_neqo_qlog
(
)
;
log
.
add_event_at
(
|
|
Some
(
EV_DATA
)
test_fixture
:
:
now
(
)
)
;
assert_eq
!
(
Regex
:
:
new
(
"
\
"
time
\
"
:
[
0
-
9
]
+
.
[
0
-
9
]
+
"
)
.
unwrap
(
)
.
replace
(
&
contents
.
to_string
(
)
"
\
"
time
\
"
:
0
.
0
"
)
format
!
(
"
{
EXPECTED_LOG_HEADER
}
{
EXPECTED_LOG_EVENT
}
"
)
)
;
}
}
