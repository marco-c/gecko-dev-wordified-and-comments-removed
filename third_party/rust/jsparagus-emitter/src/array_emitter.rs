use
crate
:
:
ast_emitter
:
:
AstEmitter
;
use
crate
:
:
emitter
:
:
EmitError
;
pub
struct
ArrayElementEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
state
:
&
'
a
mut
ArrayEmitterState
pub
elem
:
F
}
impl
<
'
a
F
>
ArrayElementEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
(
self
.
elem
)
(
emitter
)
?
;
match
&
mut
self
.
state
.
0
{
ArrayEmitterStateInternal
:
:
BeforeSpread
{
ref
mut
index
}
=
>
{
emitter
.
emit
.
init_elem_array
(
*
index
)
;
*
index
+
=
1
;
}
ArrayEmitterStateInternal
:
:
AfterSpread
=
>
{
emitter
.
emit
.
init_elem_inc
(
)
;
}
}
Ok
(
(
)
)
}
}
pub
struct
ArrayElisionEmitter
<
'
a
>
{
pub
state
:
&
'
a
mut
ArrayEmitterState
}
impl
<
'
a
>
ArrayElisionEmitter
<
'
a
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
{
emitter
.
emit
.
hole
(
)
;
match
&
mut
self
.
state
.
0
{
ArrayEmitterStateInternal
:
:
BeforeSpread
{
ref
mut
index
}
=
>
{
emitter
.
emit
.
init_elem_array
(
*
index
)
;
*
index
+
=
1
;
}
ArrayEmitterStateInternal
:
:
AfterSpread
=
>
{
emitter
.
emit
.
init_elem_inc
(
)
;
}
}
}
}
pub
struct
ArraySpreadEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
state
:
&
'
a
mut
ArrayEmitterState
pub
elem
:
F
}
impl
<
'
a
F
>
ArraySpreadEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
match
self
.
state
.
0
{
ArrayEmitterStateInternal
:
:
BeforeSpread
{
index
}
=
>
{
emitter
.
emit
.
numeric
(
index
as
f64
)
;
}
_
=
>
{
}
}
self
.
state
.
0
=
ArrayEmitterStateInternal
:
:
AfterSpread
;
Err
(
EmitError
:
:
NotImplemented
(
"
TODO
:
spread
element
"
)
)
}
}
enum
ArrayEmitterStateInternal
{
BeforeSpread
{
index
:
u32
}
AfterSpread
}
pub
struct
ArrayEmitterState
(
ArrayEmitterStateInternal
)
;
impl
ArrayEmitterState
{
fn
new
(
)
-
>
Self
{
Self
(
ArrayEmitterStateInternal
:
:
BeforeSpread
{
index
:
0
}
)
}
}
pub
enum
ArrayElementKind
{
Normal
Elision
Spread
}
pub
struct
ArrayEmitter
<
'
a
ElemT
ElemKindF
ElemF
>
where
ElemKindF
:
Fn
(
&
ElemT
)
-
>
ArrayElementKind
ElemF
:
Fn
(
&
mut
AstEmitter
&
mut
ArrayEmitterState
&
'
a
ElemT
)
-
>
Result
<
(
)
EmitError
>
{
pub
elements
:
std
:
:
slice
:
:
Iter
<
'
a
ElemT
>
pub
elem_kind
:
ElemKindF
pub
elem
:
ElemF
}
impl
<
'
a
ElemT
ElemKindF
ElemF
>
ArrayEmitter
<
'
a
ElemT
ElemKindF
ElemF
>
where
ElemKindF
:
Fn
(
&
ElemT
)
-
>
ArrayElementKind
ElemF
:
Fn
(
&
mut
AstEmitter
&
mut
ArrayEmitterState
&
'
a
ElemT
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
let
min_length
=
self
.
elements
.
clone
(
)
.
map
(
|
e
|
match
(
self
.
elem_kind
)
(
e
)
{
ArrayElementKind
:
:
Normal
=
>
1
ArrayElementKind
:
:
Elision
=
>
1
ArrayElementKind
:
:
Spread
=
>
0
}
)
.
sum
:
:
<
u32
>
(
)
;
emitter
.
emit
.
new_array
(
min_length
)
;
let
mut
state
=
ArrayEmitterState
:
:
new
(
)
;
for
element
in
self
.
elements
{
(
self
.
elem
)
(
emitter
&
mut
state
element
)
?
;
}
match
state
.
0
{
ArrayEmitterStateInternal
:
:
AfterSpread
=
>
{
emitter
.
emit
.
pop
(
)
;
}
_
=
>
{
}
}
Ok
(
(
)
)
}
}
