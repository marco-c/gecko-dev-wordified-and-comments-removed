use
crate
:
:
scope
:
:
{
BindingName
GlobalScopeData
LexicalScopeData
ScopeData
ScopeDataList
ScopeDataMap
ScopeIndex
}
;
use
ast
:
:
source_atom_set
:
:
SourceAtomSetIndex
;
use
ast
:
:
{
associated_data
:
:
AssociatedData
types
:
:
*
visit
:
:
Pass
}
;
use
indexmap
:
:
set
:
:
IndexSet
;
use
std
:
:
marker
:
:
PhantomData
;
#
[
allow
(
dead_code
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
VarScopedDeclarationsItemKind
{
VariableDeclaration
ForBinding
FunctionDeclaration
GeneratorDeclaration
AsyncFunctionDeclaration
AsyncGeneratorDeclaration
BindingIdentifier
}
#
[
allow
(
dead_code
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
LexicallyScopedDeclarations
{
FunctionDeclaration
GeneratorDeclaration
AsyncFunctionDeclaration
AsyncGeneratorDeclaration
ClassDeclaration
LexicalDeclarationWithLet
LexicalDeclarationWithConst
ExportDeclarationWithAssignmentExpression
}
#
[
derive
(
Debug
Clone
PartialEq
)
]
enum
ScopeKind
{
Var
Let
Const
#
[
allow
(
dead_code
)
]
FormalParameter
#
[
allow
(
dead_code
)
]
CatchParameter
#
[
allow
(
dead_code
)
]
Export
#
[
allow
(
dead_code
)
]
ScriptBodyStatementList
#
[
allow
(
dead_code
)
]
FunctionStatementList
#
[
allow
(
dead_code
)
]
BlockStatementList
}
#
[
derive
(
Debug
)
]
struct
GlobalContext
{
declared_function_names
:
IndexSet
<
SourceAtomSetIndex
>
declared_var_names
:
IndexSet
<
SourceAtomSetIndex
>
let_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
}
impl
GlobalContext
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
declared_function_names
:
IndexSet
:
:
new
(
)
declared_var_names
:
IndexSet
:
:
new
(
)
let_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
scope_index
}
}
fn
declare_var
<
'
alloc
>
(
&
mut
self
binding
:
&
BindingIdentifier
)
{
self
.
declared_var_names
.
insert
(
binding
.
name
.
value
)
;
}
fn
declare_let
<
'
alloc
>
(
&
mut
self
binding
:
&
BindingIdentifier
)
{
self
.
let_names
.
push
(
binding
.
name
.
value
)
;
}
fn
declare_const
<
'
alloc
>
(
&
mut
self
binding
:
&
BindingIdentifier
)
{
self
.
const_names
.
push
(
binding
.
name
.
value
)
;
}
fn
declare_function
<
'
alloc
>
(
&
mut
self
fun
:
&
Function
)
{
let
fn_
=
if
let
Some
(
ref
name
)
=
fun
.
name
{
name
.
name
.
value
}
else
{
panic
!
(
"
FunctionDeclaration
should
have
name
"
)
;
}
;
self
.
declared_function_names
.
insert
(
fn_
)
;
}
fn
remove_function_names_from_var_names
(
&
mut
self
)
{
for
n
in
&
self
.
declared_function_names
{
self
.
declared_var_names
.
remove
(
n
)
;
}
}
fn
into_scope_data
(
self
)
-
>
ScopeData
{
let
mut
data
=
GlobalScopeData
:
:
new
(
self
.
declared_var_names
.
len
(
)
+
self
.
declared_function_names
.
len
(
)
self
.
let_names
.
len
(
)
self
.
const_names
.
len
(
)
)
;
for
n
in
&
self
.
declared_var_names
{
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
)
)
}
for
n
in
&
self
.
declared_function_names
{
data
.
bindings
.
push
(
BindingName
:
:
new_top_level_function
(
*
n
)
)
;
}
for
n
in
&
self
.
let_names
{
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
)
)
}
for
n
in
&
self
.
const_names
{
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
)
)
}
ScopeData
:
:
Global
(
data
)
}
}
#
[
derive
(
Debug
)
]
struct
BlockContext
{
let_names
:
Vec
<
SourceAtomSetIndex
>
fun_names
:
Vec
<
SourceAtomSetIndex
>
const_names
:
Vec
<
SourceAtomSetIndex
>
scope_index
:
ScopeIndex
}
impl
BlockContext
{
fn
new
(
scope_index
:
ScopeIndex
)
-
>
Self
{
Self
{
let_names
:
Vec
:
:
new
(
)
fun_names
:
Vec
:
:
new
(
)
const_names
:
Vec
:
:
new
(
)
scope_index
}
}
fn
declare_let
<
'
alloc
>
(
&
mut
self
binding
:
&
BindingIdentifier
)
{
self
.
let_names
.
push
(
binding
.
name
.
value
)
;
}
fn
declare_const
<
'
alloc
>
(
&
mut
self
binding
:
&
BindingIdentifier
)
{
self
.
const_names
.
push
(
binding
.
name
.
value
)
;
}
fn
declare_function
<
'
alloc
>
(
&
mut
self
fun
:
&
Function
)
{
let
fn_
=
if
let
Some
(
ref
name
)
=
fun
.
name
{
name
.
name
.
value
}
else
{
panic
!
(
"
FunctionDeclaration
should
have
name
"
)
;
}
;
self
.
fun_names
.
push
(
fn_
)
;
}
fn
into_scope_data
(
self
enclosing
:
ScopeIndex
)
-
>
ScopeData
{
let
mut
data
=
LexicalScopeData
:
:
new
(
self
.
let_names
.
len
(
)
+
self
.
fun_names
.
len
(
)
self
.
const_names
.
len
(
)
enclosing
)
;
for
n
in
&
self
.
let_names
{
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
)
)
}
for
n
in
&
self
.
fun_names
{
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
)
)
}
for
n
in
&
self
.
const_names
{
data
.
bindings
.
push
(
BindingName
:
:
new
(
*
n
)
)
}
ScopeData
:
:
Lexical
(
data
)
}
}
#
[
derive
(
Debug
)
]
enum
Context
{
Global
(
GlobalContext
)
Block
(
BlockContext
)
}
impl
Context
{
fn
get_scope_index
(
&
self
)
-
>
ScopeIndex
{
match
self
{
Context
:
:
Global
(
context
)
=
>
context
.
scope_index
Context
:
:
Block
(
context
)
=
>
context
.
scope_index
}
}
}
#
[
derive
(
Debug
)
]
struct
ScopeKindStack
{
stack
:
Vec
<
ScopeKind
>
}
impl
ScopeKindStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
ScopeKind
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
push
(
&
mut
self
kind
:
ScopeKind
)
{
self
.
stack
.
push
(
kind
)
}
fn
pop
(
&
mut
self
kind
:
ScopeKind
)
{
match
self
.
stack
.
pop
(
)
{
Some
(
k
)
if
k
=
=
kind
=
>
{
}
_
=
>
panic
!
(
"
unmatching
scope
kind
"
)
}
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
stack
.
len
(
)
=
=
0
}
}
#
[
derive
(
Debug
)
]
struct
ContextStack
{
stack
:
Vec
<
Context
>
}
impl
ContextStack
{
fn
new
(
)
-
>
Self
{
Self
{
stack
:
Vec
:
:
new
(
)
}
}
fn
innermost_var
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Context
{
for
context
in
self
.
stack
.
iter_mut
(
)
.
rev
(
)
{
match
context
{
Context
:
:
Global
(
_
)
=
>
return
context
_
=
>
{
}
}
}
panic
!
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
;
}
fn
innermost_lexical
<
'
a
>
(
&
'
a
mut
self
)
-
>
&
'
a
mut
Context
{
self
.
stack
.
last_mut
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
}
fn
current_scope_index
(
&
self
)
-
>
ScopeIndex
{
self
.
stack
.
last
(
)
.
expect
(
"
There
should
be
at
least
one
scope
on
the
stack
"
)
.
get_scope_index
(
)
}
fn
push_global
(
&
mut
self
context
:
GlobalContext
)
{
self
.
stack
.
push
(
Context
:
:
Global
(
context
)
)
}
fn
pop_global
(
&
mut
self
)
-
>
GlobalContext
{
match
self
.
stack
.
pop
(
)
{
Some
(
Context
:
:
Global
(
context
)
)
=
>
context
_
=
>
panic
!
(
"
unmatching
context
"
)
}
}
fn
push_block
(
&
mut
self
context
:
BlockContext
)
{
self
.
stack
.
push
(
Context
:
:
Block
(
context
)
)
}
fn
pop_block
(
&
mut
self
)
-
>
BlockContext
{
match
self
.
stack
.
pop
(
)
{
Some
(
Context
:
:
Block
(
context
)
)
=
>
context
_
=
>
panic
!
(
"
unmatching
context
"
)
}
}
}
#
[
derive
(
Debug
)
]
struct
ScopePass
<
'
alloc
>
{
scope_kind_stack
:
ScopeKindStack
context_stack
:
ContextStack
scopes
:
ScopeDataList
global
:
Option
<
ScopeIndex
>
non_global
:
AssociatedData
<
ScopeIndex
>
phantom
:
PhantomData
<
&
'
alloc
(
)
>
}
impl
<
'
alloc
>
ScopePass
<
'
alloc
>
{
fn
new
(
)
-
>
Self
{
Self
{
scope_kind_stack
:
ScopeKindStack
:
:
new
(
)
context_stack
:
ContextStack
:
:
new
(
)
scopes
:
ScopeDataList
:
:
new
(
)
global
:
None
non_global
:
AssociatedData
:
:
new
(
)
phantom
:
PhantomData
}
}
}
impl
<
'
alloc
>
From
<
ScopePass
<
'
alloc
>
>
for
ScopeDataMap
{
fn
from
(
pass
:
ScopePass
<
'
alloc
>
)
-
>
ScopeDataMap
{
ScopeDataMap
:
:
new
(
pass
.
scopes
pass
.
global
.
expect
(
"
There
should
be
global
scope
data
"
)
pass
.
non_global
)
}
}
impl
<
'
alloc
>
Pass
<
'
alloc
>
for
ScopePass
<
'
alloc
>
{
fn
enter_script
(
&
mut
self
_ast
:
&
mut
Script
<
'
alloc
>
)
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
context
=
GlobalContext
:
:
new
(
index
)
;
self
.
global
=
Some
(
index
)
;
self
.
context_stack
.
push_global
(
context
)
;
}
fn
leave_script
(
&
mut
self
_ast
:
&
mut
Script
<
'
alloc
>
)
{
let
mut
context
=
self
.
context_stack
.
pop_global
(
)
;
context
.
remove_function_names_from_var_names
(
)
;
self
.
scopes
.
populate
(
context
.
scope_index
context
.
into_scope_data
(
)
)
;
}
fn
enter_enum_statement_variant_block_statement
(
&
mut
self
block
:
&
mut
Block
<
'
alloc
>
)
{
let
index
=
self
.
scopes
.
allocate
(
)
;
let
context
=
BlockContext
:
:
new
(
index
)
;
self
.
non_global
.
insert
(
block
index
)
;
self
.
context_stack
.
push_block
(
context
)
;
}
fn
leave_enum_statement_variant_block_statement
(
&
mut
self
_block
:
&
mut
Block
<
'
alloc
>
)
{
let
context
=
self
.
context_stack
.
pop_block
(
)
;
let
enclosing
=
self
.
context_stack
.
current_scope_index
(
)
;
self
.
scopes
.
populate
(
context
.
scope_index
context
.
into_scope_data
(
enclosing
)
)
;
}
fn
enter_variable_declaration
(
&
mut
self
ast
:
&
mut
VariableDeclaration
<
'
alloc
>
)
{
match
ast
.
kind
{
VariableDeclarationKind
:
:
Var
{
.
.
}
=
>
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Var
)
;
}
VariableDeclarationKind
:
:
Let
{
.
.
}
=
>
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Let
)
;
}
VariableDeclarationKind
:
:
Const
{
.
.
}
=
>
{
self
.
scope_kind_stack
.
push
(
ScopeKind
:
:
Const
)
;
}
}
}
fn
leave_variable_declaration
(
&
mut
self
ast
:
&
mut
VariableDeclaration
<
'
alloc
>
)
{
match
ast
.
kind
{
VariableDeclarationKind
:
:
Var
{
.
.
}
=
>
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Var
)
;
}
VariableDeclarationKind
:
:
Let
{
.
.
}
=
>
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Let
)
;
}
VariableDeclarationKind
:
:
Const
{
.
.
}
=
>
{
self
.
scope_kind_stack
.
pop
(
ScopeKind
:
:
Const
)
;
}
}
}
fn
visit_binding_identifier
(
&
mut
self
ast
:
&
mut
BindingIdentifier
)
{
if
self
.
scope_kind_stack
.
is_empty
(
)
{
return
;
}
match
self
.
scope_kind_stack
.
innermost
(
)
{
ScopeKind
:
:
Var
=
>
match
self
.
context_stack
.
innermost_var
(
)
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_var
(
ast
)
_
=
>
panic
!
(
"
unexpected
var
context
"
)
}
ScopeKind
:
:
Let
=
>
match
self
.
context_stack
.
innermost_lexical
(
)
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_let
(
ast
)
Context
:
:
Block
(
ref
mut
context
)
=
>
context
.
declare_let
(
ast
)
}
ScopeKind
:
:
Const
=
>
match
self
.
context_stack
.
innermost_lexical
(
)
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_const
(
ast
)
Context
:
:
Block
(
ref
mut
context
)
=
>
context
.
declare_const
(
ast
)
}
_
=
>
panic
!
(
"
Not
implemeneted
"
)
}
}
fn
enter_enum_statement_variant_function_declaration
(
&
mut
self
ast
:
&
mut
Function
<
'
alloc
>
)
{
match
self
.
context_stack
.
innermost_lexical
(
)
{
Context
:
:
Global
(
ref
mut
context
)
=
>
context
.
declare_function
(
ast
)
Context
:
:
Block
(
ref
mut
context
)
=
>
context
.
declare_function
(
ast
)
}
}
}
pub
fn
generate_scope_data
<
'
alloc
>
(
ast
:
&
mut
Program
<
'
alloc
>
)
-
>
ScopeDataMap
{
let
mut
scope_pass
=
ScopePass
:
:
new
(
)
;
scope_pass
.
visit_program
(
ast
)
;
scope_pass
.
into
(
)
}
