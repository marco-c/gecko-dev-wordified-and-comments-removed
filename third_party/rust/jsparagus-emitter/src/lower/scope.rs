pub
mod
full
{
use
ast
:
:
{
arena
types
:
:
*
visit
:
:
Pass
}
;
use
bumpalo
:
:
Bump
;
use
std
:
:
mem
:
:
replace
;
#
[
allow
(
dead_code
)
]
pub
fn
pass
<
'
alloc
>
(
allocator
:
&
'
alloc
Bump
ast
:
&
mut
Program
<
'
alloc
>
)
{
ScopePass
{
allocator
top_scope
:
Scope
{
declarations
:
arena
:
:
Vec
:
:
new_in
(
allocator
)
}
}
.
visit_program
(
ast
)
;
}
struct
Scope
<
'
alloc
>
{
declarations
:
arena
:
:
Vec
<
'
alloc
&
'
alloc
str
>
}
struct
ScopePass
<
'
alloc
>
{
allocator
:
&
'
alloc
bumpalo
:
:
Bump
top_scope
:
Scope
<
'
alloc
>
}
impl
<
'
alloc
>
Pass
<
'
alloc
>
for
ScopePass
<
'
alloc
>
{
fn
visit_binding_identifier
(
&
mut
self
ast
:
&
mut
BindingIdentifier
<
'
alloc
>
)
{
self
.
visit_identifier
(
&
mut
ast
.
name
)
;
}
fn
visit_block
(
&
mut
self
ast
:
&
mut
Block
<
'
alloc
>
)
{
let
old_scope
=
replace
(
&
mut
self
.
top_scope
Scope
{
declarations
:
arena
:
:
Vec
:
:
new_in
(
self
.
allocator
)
}
)
;
for
item
in
&
mut
ast
.
statements
{
self
.
visit_statement
(
item
)
;
}
let
this_scope
=
replace
(
&
mut
self
.
top_scope
old_scope
)
;
ast
.
declarations
=
Some
(
this_scope
.
declarations
)
;
}
}
}
pub
mod
postfix
{
use
ast
:
:
arena
;
#
[
allow
(
dead_code
)
]
#
[
derive
(
Debug
)
]
struct
ScopeInfo
<
'
alloc
>
{
declarations
:
arena
:
:
Vec
<
'
alloc
arena
:
:
String
<
'
alloc
>
>
references
:
arena
:
:
Vec
<
'
alloc
arena
:
:
String
<
'
alloc
>
>
}
}
