use
crate
:
:
ast_emitter
:
:
AstEmitter
;
use
crate
:
:
emitter
:
:
EmitError
;
use
ast
:
:
source_atom_set
:
:
SourceAtomSetIndex
;
pub
struct
NamePropertyEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
state
:
&
'
a
mut
ObjectEmitterState
pub
key
:
SourceAtomSetIndex
pub
value
:
F
}
impl
<
'
a
F
>
NamePropertyEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
match
self
.
to_property_index
(
emitter
self
.
key
)
{
Some
(
value
)
=
>
{
IndexPropertyEmitter
{
state
:
self
.
state
key
:
value
as
f64
value
:
self
.
value
}
.
emit
(
emitter
)
?
;
}
None
=
>
{
let
name_index
=
emitter
.
emit
.
get_atom_index
(
self
.
key
)
;
(
self
.
value
)
(
emitter
)
?
;
emitter
.
emit
.
init_prop
(
name_index
)
;
}
}
Ok
(
(
)
)
}
fn
to_property_index
(
&
self
emitter
:
&
mut
AstEmitter
index
:
SourceAtomSetIndex
)
-
>
Option
<
u32
>
{
let
s
=
emitter
.
compilation_info
.
atoms
.
get
(
index
)
;
s
.
parse
:
:
<
u32
>
(
)
.
ok
(
)
}
}
pub
struct
IndexPropertyEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
state
:
&
'
a
mut
ObjectEmitterState
pub
key
:
f64
pub
value
:
F
}
impl
<
'
a
F
>
IndexPropertyEmitter
<
'
a
F
>
where
F
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
emitter
.
emit
.
numeric
(
self
.
key
)
;
(
self
.
value
)
(
emitter
)
?
;
emitter
.
emit
.
init_elem
(
)
;
Ok
(
(
)
)
}
}
pub
struct
ComputedPropertyEmitter
<
'
a
F1
F2
>
where
F1
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
F2
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
state
:
&
'
a
mut
ObjectEmitterState
pub
key
:
F1
pub
value
:
F2
}
impl
<
'
a
F1
F2
>
ComputedPropertyEmitter
<
'
a
F1
F2
>
where
F1
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
F2
:
Fn
(
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
(
self
.
key
)
(
emitter
)
?
;
(
self
.
value
)
(
emitter
)
?
;
emitter
.
emit
.
init_elem
(
)
;
Ok
(
(
)
)
}
}
struct
ObjectEmitterStateInternal
{
}
pub
struct
ObjectEmitterState
(
ObjectEmitterStateInternal
)
;
impl
ObjectEmitterState
{
fn
new
(
)
-
>
Self
{
Self
(
ObjectEmitterStateInternal
{
}
)
}
}
pub
struct
ObjectEmitter
<
'
a
PropT
PropF
>
where
PropF
:
Fn
(
&
mut
AstEmitter
&
mut
ObjectEmitterState
&
PropT
)
-
>
Result
<
(
)
EmitError
>
{
pub
properties
:
std
:
:
slice
:
:
Iter
<
'
a
PropT
>
pub
prop
:
PropF
}
impl
<
'
a
PropT
PropF
>
ObjectEmitter
<
'
a
PropT
PropF
>
where
PropF
:
Fn
(
&
mut
AstEmitter
&
mut
ObjectEmitterState
&
PropT
)
-
>
Result
<
(
)
EmitError
>
{
pub
fn
emit
(
self
emitter
:
&
mut
AstEmitter
)
-
>
Result
<
(
)
EmitError
>
{
emitter
.
emit
.
new_init
(
)
;
let
mut
state
=
ObjectEmitterState
:
:
new
(
)
;
for
prop
in
self
.
properties
{
(
self
.
prop
)
(
emitter
&
mut
state
prop
)
?
;
}
Ok
(
(
)
)
}
}
