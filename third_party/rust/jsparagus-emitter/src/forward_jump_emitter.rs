use
super
:
:
emitter
:
:
BytecodeOffset
;
use
crate
:
:
ast_emitter
:
:
AstEmitter
;
#
[
derive
(
Debug
)
]
pub
enum
JumpKind
{
Coalesce
LogicalAnd
LogicalOr
IfEq
Goto
}
#
[
derive
(
Debug
)
]
#
[
must_use
]
pub
struct
JumpPatchEmitter
{
offset
:
BytecodeOffset
depth
:
usize
}
impl
JumpPatchEmitter
{
pub
fn
patch_merge
(
self
emitter
:
&
mut
AstEmitter
)
{
emitter
.
emit
.
patch_jump_target
(
vec
!
[
self
.
offset
]
)
;
emitter
.
emit
.
jump_target
(
)
;
debug_assert
!
(
emitter
.
emit
.
stack_depth
(
)
=
=
self
.
depth
)
;
}
pub
fn
patch_not_merge
(
self
emitter
:
&
mut
AstEmitter
)
{
emitter
.
emit
.
patch_jump_target
(
vec
!
[
self
.
offset
]
)
;
emitter
.
emit
.
jump_target
(
)
;
emitter
.
emit
.
set_stack_depth
(
self
.
depth
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
ForwardJumpEmitter
{
pub
jump
:
JumpKind
}
impl
ForwardJumpEmitter
{
pub
fn
emit
(
&
mut
self
emitter
:
&
mut
AstEmitter
)
-
>
JumpPatchEmitter
{
let
offset
=
emitter
.
emit
.
bytecode_offset
(
)
;
self
.
emit_jump
(
emitter
)
;
let
depth
=
emitter
.
emit
.
stack_depth
(
)
;
if
self
.
should_fallthrough
(
)
{
emitter
.
emit
.
jump_target
(
)
;
}
JumpPatchEmitter
{
offset
depth
}
}
fn
should_fallthrough
(
&
mut
self
)
-
>
bool
{
match
self
.
jump
{
JumpKind
:
:
Goto
{
.
.
}
=
>
false
_
=
>
true
}
}
fn
emit_jump
(
&
mut
self
emitter
:
&
mut
AstEmitter
)
{
let
placeholder_offset
:
i32
=
0
;
match
self
.
jump
{
JumpKind
:
:
Coalesce
{
.
.
}
=
>
{
emitter
.
emit
.
coalesce
(
placeholder_offset
)
;
}
JumpKind
:
:
LogicalOr
{
.
.
}
=
>
{
emitter
.
emit
.
or_
(
placeholder_offset
)
;
}
JumpKind
:
:
LogicalAnd
{
.
.
}
=
>
{
emitter
.
emit
.
and_
(
placeholder_offset
)
;
}
JumpKind
:
:
IfEq
{
.
.
}
=
>
{
emitter
.
emit
.
if_eq
(
placeholder_offset
)
;
}
JumpKind
:
:
Goto
{
.
.
}
=
>
{
emitter
.
emit
.
goto_
(
placeholder_offset
)
;
}
}
}
}
