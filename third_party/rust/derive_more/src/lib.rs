#
!
[
recursion_limit
=
"
128
"
]
extern
crate
proc_macro
;
extern
crate
proc_macro2
;
#
[
macro_use
]
extern
crate
quote
;
extern
crate
syn
;
use
proc_macro
:
:
TokenStream
;
use
syn
:
:
parse
:
:
Error
as
ParseError
;
mod
utils
;
mod
add_assign_like
;
mod
add_like
;
mod
constructor
;
mod
deref
;
mod
deref_mut
;
mod
display
;
mod
from
;
mod
from_str
;
mod
index
;
mod
index_mut
;
mod
into
;
mod
mul_assign_like
;
mod
mul_like
;
mod
not_like
;
mod
try_into
;
trait
Output
{
fn
process
(
self
)
-
>
TokenStream
;
}
impl
Output
for
proc_macro2
:
:
TokenStream
{
fn
process
(
self
)
-
>
TokenStream
{
self
.
into
(
)
}
}
impl
Output
for
Result
<
proc_macro2
:
:
TokenStream
ParseError
>
{
fn
process
(
self
)
-
>
TokenStream
{
match
self
{
Ok
(
ts
)
=
>
ts
.
into
(
)
Err
(
e
)
=
>
e
.
to_compile_error
(
)
.
into
(
)
}
}
}
macro_rules
!
create_derive
(
(
mod_
:
ident
trait_
:
ident
fn_name
:
ident
(
attribute
:
ident
)
*
)
=
>
{
#
[
proc_macro_derive
(
trait_
attributes
(
(
attribute
)
*
)
)
]
#
[
doc
(
hidden
)
]
pub
fn
fn_name
(
input
:
TokenStream
)
-
>
TokenStream
{
let
ast
=
syn
:
:
parse
(
input
)
.
unwrap
(
)
;
Output
:
:
process
(
mod_
:
:
expand
(
&
ast
stringify
!
(
trait_
)
)
)
}
}
)
;
create_derive
!
(
from
From
from_derive
)
;
create_derive
!
(
into
Into
into_derive
)
;
create_derive
!
(
constructor
Constructor
constructor_derive
)
;
create_derive
!
(
not_like
Not
not_derive
)
;
create_derive
!
(
not_like
Neg
neg_derive
)
;
create_derive
!
(
add_like
Add
add_derive
)
;
create_derive
!
(
add_like
Sub
sub_derive
)
;
create_derive
!
(
add_like
BitAnd
bit_and_derive
)
;
create_derive
!
(
add_like
BitOr
bit_or_derive
)
;
create_derive
!
(
add_like
BitXor
bit_xor_derive
)
;
create_derive
!
(
mul_like
Mul
mul_derive
)
;
create_derive
!
(
mul_like
Div
div_derive
)
;
create_derive
!
(
mul_like
Rem
rem_derive
)
;
create_derive
!
(
mul_like
Shr
shr_derive
)
;
create_derive
!
(
mul_like
Shl
shl_derive
)
;
create_derive
!
(
add_assign_like
AddAssign
add_assign_derive
)
;
create_derive
!
(
add_assign_like
SubAssign
sub_assign_derive
)
;
create_derive
!
(
add_assign_like
BitAndAssign
bit_and_assign_derive
)
;
create_derive
!
(
add_assign_like
BitOrAssign
bit_or_assign_derive
)
;
create_derive
!
(
add_assign_like
BitXorAssign
bit_xor_assign_derive
)
;
create_derive
!
(
mul_assign_like
MulAssign
mul_assign_derive
)
;
create_derive
!
(
mul_assign_like
DivAssign
div_assign_derive
)
;
create_derive
!
(
mul_assign_like
RemAssign
rem_assign_derive
)
;
create_derive
!
(
mul_assign_like
ShrAssign
shr_assign_derive
)
;
create_derive
!
(
mul_assign_like
ShlAssign
shl_assign_derive
)
;
create_derive
!
(
from_str
FromStr
from_str_derive
)
;
create_derive
!
(
display
Display
display_derive
display
)
;
create_derive
!
(
display
Binary
binary_derive
binary
)
;
create_derive
!
(
display
Octal
octal_derive
octal
)
;
create_derive
!
(
display
LowerHex
lower_hex_derive
lower_hex
)
;
create_derive
!
(
display
UpperHex
upper_hex_derive
upper_hex
)
;
create_derive
!
(
display
LowerExp
lower_exp_derive
lower_exp
)
;
create_derive
!
(
display
UpperExp
upper_exp_derive
upper_exp
)
;
create_derive
!
(
display
Pointer
pointer_derive
pointer
)
;
create_derive
!
(
index
Index
index_derive
)
;
create_derive
!
(
index_mut
IndexMut
index_mut_derive
)
;
create_derive
!
(
try_into
TryInto
try_into_derive
)
;
create_derive
!
(
deref
Deref
deref_derive
)
;
create_derive
!
(
deref_mut
DerefMut
deref_mut_derive
)
;
