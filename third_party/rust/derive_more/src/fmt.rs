use
:
:
core
;
use
core
:
:
fmt
:
:
{
Debug
Formatter
Result
Write
}
;
use
core
:
:
prelude
:
:
v1
:
:
*
;
#
[
must_use
=
"
must
eventually
call
finish
(
)
or
finish_non_exhaustive
(
)
on
\
Debug
builders
"
]
pub
struct
DebugTuple
<
'
a
'
b
:
'
a
>
{
fmt
:
&
'
a
mut
Formatter
<
'
b
>
result
:
Result
fields
:
usize
empty_name
:
bool
}
pub
fn
debug_tuple
<
'
a
'
b
>
(
fmt
:
&
'
a
mut
Formatter
<
'
b
>
name
:
&
str
)
-
>
DebugTuple
<
'
a
'
b
>
{
let
result
=
fmt
.
write_str
(
name
)
;
DebugTuple
{
fmt
result
fields
:
0
empty_name
:
name
.
is_empty
(
)
}
}
impl
<
'
a
'
b
:
'
a
>
DebugTuple
<
'
a
'
b
>
{
pub
fn
field
(
&
mut
self
value
:
&
dyn
Debug
)
-
>
&
mut
Self
{
self
.
result
=
self
.
result
.
and_then
(
|
_
|
{
if
self
.
is_pretty
(
)
{
if
self
.
fields
=
=
0
{
self
.
fmt
.
write_str
(
"
(
\
n
"
)
?
;
}
let
mut
padded_formatter
=
Padded
:
:
new
(
self
.
fmt
)
;
padded_formatter
.
write_fmt
(
format_args
!
(
"
{
value
:
#
?
}
"
)
)
?
;
padded_formatter
.
write_str
(
"
\
n
"
)
}
else
{
let
prefix
=
if
self
.
fields
=
=
0
{
"
(
"
}
else
{
"
"
}
;
self
.
fmt
.
write_str
(
prefix
)
?
;
value
.
fmt
(
self
.
fmt
)
}
}
)
;
self
.
fields
+
=
1
;
self
}
pub
fn
finish
(
&
mut
self
)
-
>
Result
{
if
self
.
fields
>
0
{
self
.
result
=
self
.
result
.
and_then
(
|
_
|
{
if
self
.
fields
=
=
1
&
&
self
.
empty_name
&
&
!
self
.
is_pretty
(
)
{
self
.
fmt
.
write_str
(
"
"
)
?
;
}
self
.
fmt
.
write_str
(
"
)
"
)
}
)
;
}
self
.
result
}
pub
fn
finish_non_exhaustive
(
&
mut
self
)
-
>
Result
{
self
.
result
=
self
.
result
.
and_then
(
|
_
|
{
if
self
.
fields
>
0
{
if
self
.
is_pretty
(
)
{
let
mut
padded_formatter
=
Padded
:
:
new
(
self
.
fmt
)
;
padded_formatter
.
write_str
(
"
.
.
\
n
"
)
?
;
self
.
fmt
.
write_str
(
"
)
"
)
}
else
{
self
.
fmt
.
write_str
(
"
.
.
)
"
)
}
}
else
{
self
.
fmt
.
write_str
(
"
(
.
.
)
"
)
}
}
)
;
self
.
result
}
fn
is_pretty
(
&
self
)
-
>
bool
{
self
.
fmt
.
alternate
(
)
}
}
struct
Padded
<
'
a
'
b
>
{
formatter
:
&
'
a
mut
Formatter
<
'
b
>
on_newline
:
bool
}
impl
<
'
a
'
b
>
Padded
<
'
a
'
b
>
{
fn
new
(
formatter
:
&
'
a
mut
Formatter
<
'
b
>
)
-
>
Self
{
Self
{
formatter
on_newline
:
true
}
}
}
impl
<
'
a
'
b
>
Write
for
Padded
<
'
a
'
b
>
{
fn
write_str
(
&
mut
self
s
:
&
str
)
-
>
Result
{
for
s
in
s
.
split_inclusive
(
'
\
n
'
)
{
if
self
.
on_newline
{
self
.
formatter
.
write_str
(
"
"
)
?
;
}
self
.
on_newline
=
s
.
ends_with
(
'
\
n
'
)
;
self
.
formatter
.
write_str
(
s
)
?
;
}
Ok
(
(
)
)
}
}
