use
super
:
:
Incoming
;
use
super
:
:
TcpStream
;
use
std
:
:
fmt
;
use
std
:
:
io
;
use
std
:
:
net
:
:
{
self
SocketAddr
}
;
use
futures
:
:
{
Poll
Async
}
;
use
mio
;
use
tokio_reactor
:
:
{
Handle
PollEvented
}
;
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
use
futures2
;
pub
struct
TcpListener
{
io
:
PollEvented
<
mio
:
:
net
:
:
TcpListener
>
}
impl
TcpListener
{
pub
fn
bind
(
addr
:
&
SocketAddr
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
l
=
mio
:
:
net
:
:
TcpListener
:
:
bind
(
addr
)
?
;
Ok
(
TcpListener
:
:
new
(
l
)
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
poll_accept
instead
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
accept
(
&
mut
self
)
-
>
io
:
:
Result
<
(
TcpStream
SocketAddr
)
>
{
match
self
.
poll_accept
(
)
?
{
Async
:
:
Ready
(
ret
)
=
>
Ok
(
ret
)
Async
:
:
NotReady
=
>
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
}
pub
fn
poll_accept
(
&
mut
self
)
-
>
Poll
<
(
TcpStream
SocketAddr
)
io
:
:
Error
>
{
let
(
io
addr
)
=
try_ready
!
(
self
.
poll_accept_std
(
)
)
;
let
io
=
mio
:
:
net
:
:
TcpStream
:
:
from_stream
(
io
)
?
;
let
io
=
TcpStream
:
:
new
(
io
)
;
Ok
(
(
io
addr
)
.
into
(
)
)
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
pub
fn
poll_accept2
(
&
mut
self
cx
:
&
mut
futures2
:
:
task
:
:
Context
)
-
>
futures2
:
:
Poll
<
(
TcpStream
SocketAddr
)
io
:
:
Error
>
{
let
(
io
addr
)
=
match
self
.
poll_accept_std2
(
cx
)
?
{
futures2
:
:
Async
:
:
Ready
(
x
)
=
>
x
futures2
:
:
Async
:
:
Pending
=
>
return
Ok
(
futures2
:
:
Async
:
:
Pending
)
}
;
let
io
=
mio
:
:
net
:
:
TcpStream
:
:
from_stream
(
io
)
?
;
let
io
=
TcpStream
:
:
new
(
io
)
;
Ok
(
(
io
addr
)
.
into
(
)
)
}
#
[
deprecated
(
since
=
"
0
.
1
.
2
"
note
=
"
use
poll_accept_std
instead
"
)
]
#
[
doc
(
hidden
)
]
pub
fn
accept_std
(
&
mut
self
)
-
>
io
:
:
Result
<
(
net
:
:
TcpStream
SocketAddr
)
>
{
match
self
.
poll_accept_std
(
)
?
{
Async
:
:
Ready
(
ret
)
=
>
Ok
(
ret
)
Async
:
:
NotReady
=
>
Err
(
io
:
:
ErrorKind
:
:
WouldBlock
.
into
(
)
)
}
}
pub
fn
poll_accept_std
(
&
mut
self
)
-
>
Poll
<
(
net
:
:
TcpStream
SocketAddr
)
io
:
:
Error
>
{
try_ready
!
(
self
.
io
.
poll_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
)
;
match
self
.
io
.
get_ref
(
)
.
accept_std
(
)
{
Ok
(
pair
)
=
>
Ok
(
pair
.
into
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_read_ready
(
mio
:
:
Ready
:
:
readable
(
)
)
?
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
#
[
cfg
(
feature
=
"
unstable
-
futures
"
)
]
pub
fn
poll_accept_std2
(
&
mut
self
cx
:
&
mut
futures2
:
:
task
:
:
Context
)
-
>
futures2
:
:
Poll
<
(
net
:
:
TcpStream
SocketAddr
)
io
:
:
Error
>
{
if
let
futures2
:
:
Async
:
:
Pending
=
self
.
io
.
poll_read_ready2
(
cx
mio
:
:
Ready
:
:
readable
(
)
)
?
{
return
Ok
(
futures2
:
:
Async
:
:
Pending
)
;
}
match
self
.
io
.
get_ref
(
)
.
accept_std
(
)
{
Ok
(
pair
)
=
>
Ok
(
pair
.
into
(
)
)
Err
(
ref
e
)
if
e
.
kind
(
)
=
=
io
:
:
ErrorKind
:
:
WouldBlock
=
>
{
self
.
io
.
clear_read_ready2
(
cx
mio
:
:
Ready
:
:
readable
(
)
)
?
;
Ok
(
futures2
:
:
Async
:
:
Pending
)
}
Err
(
e
)
=
>
Err
(
e
)
}
}
pub
fn
from_std
(
listener
:
net
:
:
TcpListener
handle
:
&
Handle
)
-
>
io
:
:
Result
<
TcpListener
>
{
let
io
=
mio
:
:
net
:
:
TcpListener
:
:
from_std
(
listener
)
?
;
let
io
=
PollEvented
:
:
new_with_handle
(
io
handle
)
?
;
Ok
(
TcpListener
{
io
}
)
}
fn
new
(
listener
:
mio
:
:
net
:
:
TcpListener
)
-
>
TcpListener
{
let
io
=
PollEvented
:
:
new
(
listener
)
;
TcpListener
{
io
}
}
pub
fn
local_addr
(
&
self
)
-
>
io
:
:
Result
<
SocketAddr
>
{
self
.
io
.
get_ref
(
)
.
local_addr
(
)
}
pub
fn
incoming
(
self
)
-
>
Incoming
{
Incoming
:
:
new
(
self
)
}
pub
fn
ttl
(
&
self
)
-
>
io
:
:
Result
<
u32
>
{
self
.
io
.
get_ref
(
)
.
ttl
(
)
}
pub
fn
set_ttl
(
&
self
ttl
:
u32
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
io
.
get_ref
(
)
.
set_ttl
(
ttl
)
}
}
impl
fmt
:
:
Debug
for
TcpListener
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
self
.
io
.
get_ref
(
)
.
fmt
(
f
)
}
}
#
[
cfg
(
unix
)
]
mod
sys
{
use
std
:
:
os
:
:
unix
:
:
prelude
:
:
*
;
use
super
:
:
TcpListener
;
impl
AsRawFd
for
TcpListener
{
fn
as_raw_fd
(
&
self
)
-
>
RawFd
{
self
.
io
.
get_ref
(
)
.
as_raw_fd
(
)
}
}
}
#
[
cfg
(
windows
)
]
mod
sys
{
}
