use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
;
use
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
{
self
AcqRel
Acquire
Release
SeqCst
}
;
use
epoch
:
:
Pin
;
fn
low_bits
<
T
>
(
)
-
>
usize
{
(
1
<
<
mem
:
:
align_of
:
:
<
T
>
(
)
.
trailing_zeros
(
)
)
-
1
}
fn
raw_and_tag
<
T
>
(
raw
:
*
mut
T
tag
:
usize
)
-
>
usize
{
let
mask
=
low_bits
:
:
<
T
>
(
)
;
assert
!
(
raw
as
usize
&
mask
=
=
0
"
unaligned
pointer
"
)
;
assert
!
(
tag
<
=
mask
"
tag
too
large
to
fit
into
the
unused
bits
:
{
}
>
{
}
"
tag
mask
)
;
raw
as
usize
|
tag
}
#
[
derive
(
Debug
)
]
pub
struct
Atomic
<
T
>
{
data
:
AtomicUsize
_marker
:
PhantomData
<
*
mut
T
>
}
unsafe
impl
<
T
:
Send
+
Sync
>
Send
for
Atomic
<
T
>
{
}
unsafe
impl
<
T
:
Send
+
Sync
>
Sync
for
Atomic
<
T
>
{
}
impl
<
T
>
Atomic
<
T
>
{
unsafe
fn
from_data
(
data
:
usize
)
-
>
Self
{
Atomic
{
data
:
AtomicUsize
:
:
new
(
data
)
_marker
:
PhantomData
}
}
pub
fn
null
(
tag
:
usize
)
-
>
Self
{
unsafe
{
Self
:
:
from_raw
(
ptr
:
:
null_mut
(
)
tag
)
}
}
pub
fn
new
(
data
:
T
tag
:
usize
)
-
>
Self
{
unsafe
{
Self
:
:
from_raw
(
Box
:
:
into_raw
(
Box
:
:
new
(
data
)
)
tag
)
}
}
pub
fn
from_ptr
(
ptr
:
Ptr
<
T
>
)
-
>
Self
{
unsafe
{
Self
:
:
from_data
(
ptr
.
data
)
}
}
pub
fn
from_box
(
b
:
Box
<
T
>
tag
:
usize
)
-
>
Self
{
unsafe
{
Self
:
:
from_raw
(
Box
:
:
into_raw
(
b
)
tag
)
}
}
pub
unsafe
fn
from_raw
(
raw
:
*
mut
T
tag
:
usize
)
-
>
Self
{
Self
:
:
from_data
(
raw_and_tag
(
raw
tag
)
)
}
pub
fn
load
<
'
p
>
(
&
self
_
:
&
'
p
Pin
)
-
>
Ptr
<
'
p
T
>
{
unsafe
{
Ptr
:
:
from_data
(
self
.
data
.
load
(
Acquire
)
)
}
}
pub
fn
load_raw
(
&
self
order
:
Ordering
)
-
>
(
*
mut
T
usize
)
{
let
p
=
unsafe
{
Ptr
:
:
<
T
>
:
:
from_data
(
self
.
data
.
load
(
order
)
)
}
;
(
p
.
as_raw
(
)
p
.
tag
(
)
)
}
pub
fn
store
<
'
p
>
(
&
self
new
:
Ptr
<
'
p
T
>
)
{
self
.
data
.
store
(
new
.
data
Release
)
;
}
pub
fn
store_box
<
'
p
>
(
&
self
new
:
Box
<
T
>
tag
:
usize
_
:
&
'
p
Pin
)
-
>
Ptr
<
'
p
T
>
{
let
ptr
=
unsafe
{
Ptr
:
:
from_raw
(
Box
:
:
into_raw
(
new
)
tag
)
}
;
self
.
data
.
store
(
ptr
.
data
Release
)
;
ptr
}
pub
unsafe
fn
store_raw
<
'
p
>
(
&
self
new
:
*
mut
T
tag
:
usize
order
:
Ordering
_
:
&
'
p
Pin
)
-
>
Ptr
<
'
p
T
>
{
let
ptr
=
Ptr
:
:
from_raw
(
new
tag
)
;
self
.
data
.
store
(
ptr
.
data
order
)
;
ptr
}
pub
fn
swap
<
'
p
>
(
&
self
new
:
Ptr
<
'
p
T
>
)
-
>
Ptr
<
'
p
T
>
{
unsafe
{
Ptr
:
:
from_data
(
self
.
data
.
swap
(
new
.
data
AcqRel
)
)
}
}
pub
fn
swap_box
<
'
p
>
(
&
self
new
:
Box
<
T
>
tag
:
usize
_
:
&
'
p
Pin
)
-
>
Ptr
<
'
p
T
>
{
let
data
=
unsafe
{
Ptr
:
:
from_raw
(
Box
:
:
into_raw
(
new
)
tag
)
.
data
}
;
unsafe
{
Ptr
:
:
from_data
(
self
.
data
.
swap
(
data
AcqRel
)
)
}
}
pub
unsafe
fn
swap_raw
<
'
p
>
(
&
self
new
:
*
mut
T
tag
:
usize
order
:
Ordering
)
-
>
Ptr
<
'
p
T
>
{
let
data
=
Ptr
:
:
from_raw
(
new
tag
)
.
data
;
Ptr
:
:
from_data
(
self
.
data
.
swap
(
data
order
)
)
}
pub
fn
cas
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
new
:
Ptr
<
'
p
T
>
)
-
>
Result
<
(
)
Ptr
<
'
p
T
>
>
{
let
previous
=
self
.
data
.
compare_and_swap
(
current
.
data
new
.
data
AcqRel
)
;
if
previous
=
=
current
.
data
{
Ok
(
(
)
)
}
else
{
unsafe
{
Err
(
Ptr
:
:
from_data
(
previous
)
)
}
}
}
pub
fn
cas_sc
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
new
:
Ptr
<
'
p
T
>
)
-
>
Result
<
(
)
Ptr
<
'
p
T
>
>
{
let
previous
=
self
.
data
.
compare_and_swap
(
current
.
data
new
.
data
SeqCst
)
;
if
previous
=
=
current
.
data
{
Ok
(
(
)
)
}
else
{
unsafe
{
Err
(
Ptr
:
:
from_data
(
previous
)
)
}
}
}
pub
fn
cas_weak
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
new
:
Ptr
<
'
p
T
>
)
-
>
Result
<
(
)
Ptr
<
'
p
T
>
>
{
match
self
.
data
.
compare_exchange_weak
(
current
.
data
new
.
data
AcqRel
Acquire
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
previous
)
=
>
unsafe
{
Err
(
Ptr
:
:
from_data
(
previous
)
)
}
}
}
pub
fn
cas_weak_sc
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
new
:
Ptr
<
'
p
T
>
)
-
>
Result
<
(
)
Ptr
<
'
p
T
>
>
{
match
self
.
data
.
compare_exchange_weak
(
current
.
data
new
.
data
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
Ok
(
(
)
)
Err
(
previous
)
=
>
unsafe
{
Err
(
Ptr
:
:
from_data
(
previous
)
)
}
}
}
pub
fn
cas_box
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
mut
new
:
Box
<
T
>
tag
:
usize
)
-
>
Result
<
Ptr
<
'
p
T
>
(
Ptr
<
'
p
T
>
Box
<
T
>
)
>
{
let
new_data
=
raw_and_tag
(
new
.
as_mut
(
)
tag
)
;
let
previous
=
self
.
data
.
compare_and_swap
(
current
.
data
new_data
AcqRel
)
;
if
previous
=
=
current
.
data
{
mem
:
:
forget
(
new
)
;
unsafe
{
Ok
(
Ptr
:
:
from_data
(
new_data
)
)
}
}
else
{
unsafe
{
Err
(
(
Ptr
:
:
from_data
(
previous
)
new
)
)
}
}
}
pub
fn
cas_box_sc
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
mut
new
:
Box
<
T
>
tag
:
usize
)
-
>
Result
<
Ptr
<
'
p
T
>
(
Ptr
<
'
p
T
>
Box
<
T
>
)
>
{
let
new_data
=
raw_and_tag
(
new
.
as_mut
(
)
tag
)
;
let
previous
=
self
.
data
.
compare_and_swap
(
current
.
data
new_data
SeqCst
)
;
if
previous
=
=
current
.
data
{
mem
:
:
forget
(
new
)
;
unsafe
{
Ok
(
Ptr
:
:
from_data
(
new_data
)
)
}
}
else
{
unsafe
{
Err
(
(
Ptr
:
:
from_data
(
previous
)
new
)
)
}
}
}
pub
fn
cas_box_weak
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
mut
new
:
Box
<
T
>
tag
:
usize
)
-
>
Result
<
Ptr
<
'
p
T
>
(
Ptr
<
'
p
T
>
Box
<
T
>
)
>
{
let
new_data
=
raw_and_tag
(
new
.
as_mut
(
)
tag
)
;
match
self
.
data
.
compare_exchange_weak
(
current
.
data
new_data
AcqRel
Acquire
)
{
Ok
(
_
)
=
>
{
mem
:
:
forget
(
new
)
;
unsafe
{
Ok
(
Ptr
:
:
from_data
(
new_data
)
)
}
}
Err
(
previous
)
=
>
unsafe
{
Err
(
(
Ptr
:
:
from_data
(
previous
)
new
)
)
}
}
}
pub
fn
cas_box_weak_sc
<
'
p
>
(
&
self
current
:
Ptr
<
'
p
T
>
mut
new
:
Box
<
T
>
tag
:
usize
)
-
>
Result
<
Ptr
<
'
p
T
>
(
Ptr
<
'
p
T
>
Box
<
T
>
)
>
{
let
new_data
=
raw_and_tag
(
new
.
as_mut
(
)
tag
)
;
match
self
.
data
.
compare_exchange_weak
(
current
.
data
new_data
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
{
mem
:
:
forget
(
new
)
;
unsafe
{
Ok
(
Ptr
:
:
from_data
(
new_data
)
)
}
}
Err
(
previous
)
=
>
unsafe
{
Err
(
(
Ptr
:
:
from_data
(
previous
)
new
)
)
}
}
}
pub
unsafe
fn
cas_raw
(
&
self
current
:
(
*
mut
T
usize
)
new
:
(
*
mut
T
usize
)
order
:
Ordering
)
-
>
Result
<
(
)
(
*
mut
T
usize
)
>
{
let
current_data
=
raw_and_tag
(
current
.
0
current
.
1
)
;
let
new_data
=
raw_and_tag
(
new
.
0
new
.
1
)
;
let
previous
=
self
.
data
.
compare_and_swap
(
current_data
new_data
order
)
;
if
previous
=
=
current_data
{
Ok
(
(
)
)
}
else
{
let
ptr
=
Ptr
:
:
from_data
(
previous
)
;
Err
(
(
ptr
.
as_raw
(
)
ptr
.
tag
(
)
)
)
}
}
pub
unsafe
fn
cas_raw_weak
(
&
self
current
:
(
*
mut
T
usize
)
new
:
(
*
mut
T
usize
)
order
:
Ordering
)
-
>
Result
<
(
)
(
*
mut
T
usize
)
>
{
let
current_data
=
raw_and_tag
(
current
.
0
current
.
1
)
;
let
new_data
=
raw_and_tag
(
new
.
0
new
.
1
)
;
let
previous
=
self
.
data
.
compare_and_swap
(
current_data
new_data
order
)
;
if
previous
=
=
current_data
{
Ok
(
(
)
)
}
else
{
let
ptr
=
Ptr
:
:
from_data
(
previous
)
;
Err
(
(
ptr
.
as_raw
(
)
ptr
.
tag
(
)
)
)
}
}
}
impl
<
T
>
Default
for
Atomic
<
T
>
{
fn
default
(
)
-
>
Self
{
Atomic
{
data
:
AtomicUsize
:
:
new
(
0
)
_marker
:
PhantomData
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
Ptr
<
'
p
T
:
'
p
>
{
data
:
usize
_marker
:
PhantomData
<
(
*
mut
T
&
'
p
T
)
>
}
impl
<
'
a
T
>
Clone
for
Ptr
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
Ptr
{
data
:
self
.
data
_marker
:
PhantomData
}
}
}
impl
<
'
a
T
>
Copy
for
Ptr
<
'
a
T
>
{
}
impl
<
'
p
T
:
'
p
>
Ptr
<
'
p
T
>
{
unsafe
fn
from_data
(
data
:
usize
)
-
>
Self
{
Ptr
{
data
:
data
_marker
:
PhantomData
}
}
pub
fn
null
(
tag
:
usize
)
-
>
Self
{
unsafe
{
Self
:
:
from_data
(
raw_and_tag
:
:
<
T
>
(
ptr
:
:
null_mut
(
)
tag
)
)
}
}
pub
unsafe
fn
from_raw
(
raw
:
*
mut
T
tag
:
usize
)
-
>
Self
{
Self
:
:
from_data
(
raw_and_tag
(
raw
tag
)
)
}
pub
fn
is_null
(
&
self
)
-
>
bool
{
self
.
as_raw
(
)
.
is_null
(
)
}
pub
fn
as_ref
(
&
self
)
-
>
Option
<
&
'
p
T
>
{
unsafe
{
self
.
as_raw
(
)
.
as_ref
(
)
}
}
pub
fn
as_raw
(
&
self
)
-
>
*
mut
T
{
(
self
.
data
&
!
low_bits
:
:
<
T
>
(
)
)
as
*
mut
T
}
pub
fn
unwrap
(
&
self
)
-
>
&
'
p
T
{
self
.
as_ref
(
)
.
unwrap
(
)
}
pub
fn
tag
(
&
self
)
-
>
usize
{
self
.
data
&
low_bits
:
:
<
T
>
(
)
}
pub
fn
with_tag
(
&
self
tag
:
usize
)
-
>
Self
{
unsafe
{
Self
:
:
from_raw
(
self
.
as_raw
(
)
tag
)
}
}
}
impl
<
'
p
T
>
Default
for
Ptr
<
'
p
T
>
{
fn
default
(
)
-
>
Self
{
Ptr
{
data
:
0
_marker
:
PhantomData
}
}
}
