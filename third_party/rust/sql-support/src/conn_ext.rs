use
rusqlite
:
:
{
self
types
:
:
{
FromSql
ToSql
}
Connection
Params
Result
as
SqlResult
Row
Savepoint
Transaction
TransactionBehavior
}
;
use
std
:
:
iter
:
:
FromIterator
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
time
:
:
Instant
;
use
crate
:
:
maybe_cached
:
:
MaybeCached
;
use
crate
:
:
{
debug
warn
}
;
pub
trait
ConnExt
{
fn
conn
(
&
self
)
-
>
&
Connection
;
fn
set_pragma
<
T
>
(
&
self
pragma_name
:
&
str
pragma_value
:
T
)
-
>
SqlResult
<
&
Self
>
where
T
:
ToSql
Self
:
Sized
{
self
.
conn
(
)
.
pragma_update
(
None
pragma_name
&
pragma_value
)
?
;
Ok
(
self
)
}
fn
prepare_maybe_cached
<
'
conn
>
(
&
'
conn
self
sql
:
&
str
cache
:
bool
)
-
>
SqlResult
<
MaybeCached
<
'
conn
>
>
{
MaybeCached
:
:
prepare
(
self
.
conn
(
)
sql
cache
)
}
fn
execute_all
(
&
self
stmts
:
&
[
&
str
]
)
-
>
SqlResult
<
(
)
>
{
let
conn
=
self
.
conn
(
)
;
for
sql
in
stmts
{
let
r
=
conn
.
execute
(
sql
[
]
)
;
match
r
{
Ok
(
_
)
=
>
{
}
Err
(
rusqlite
:
:
Error
:
:
ExecuteReturnedResults
)
=
>
{
}
Err
(
e
)
=
>
return
Err
(
e
)
}
}
Ok
(
(
)
)
}
fn
execute_one
(
&
self
stmt
:
&
str
)
-
>
SqlResult
<
(
)
>
{
self
.
execute_all
(
&
[
stmt
]
)
}
fn
execute_cached
<
P
:
Params
>
(
&
self
sql
:
&
str
params
:
P
)
-
>
SqlResult
<
usize
>
{
let
mut
stmt
=
self
.
conn
(
)
.
prepare_cached
(
sql
)
?
;
stmt
.
execute
(
params
)
}
fn
conn_ext_query_one
<
T
:
FromSql
>
(
&
self
sql
:
&
str
)
-
>
SqlResult
<
T
>
{
let
res
:
T
=
self
.
conn
(
)
.
query_row_and_then
(
sql
[
]
|
row
|
row
.
get
(
0
)
)
?
;
Ok
(
res
)
}
fn
exists
<
P
:
Params
>
(
&
self
sql
:
&
str
params
:
P
)
-
>
SqlResult
<
bool
>
{
let
conn
=
self
.
conn
(
)
;
let
mut
stmt
=
conn
.
prepare
(
sql
)
?
;
let
exists
=
stmt
.
query
(
params
)
?
.
next
(
)
?
.
is_some
(
)
;
Ok
(
exists
)
}
fn
try_query_one
<
T
:
FromSql
P
:
Params
>
(
&
self
sql
:
&
str
params
:
P
cache
:
bool
)
-
>
SqlResult
<
Option
<
T
>
>
where
Self
:
Sized
{
use
rusqlite
:
:
OptionalExtension
;
let
res
:
Option
<
Option
<
T
>
>
=
self
.
conn
(
)
.
query_row_and_then_cachable
(
sql
params
|
row
|
row
.
get
(
0
)
cache
)
.
optional
(
)
?
;
Ok
(
res
.
unwrap_or_default
(
)
)
}
fn
query_row_and_then_cachable
<
T
E
P
F
>
(
&
self
sql
:
&
str
params
:
P
mapper
:
F
cache
:
bool
)
-
>
Result
<
T
E
>
where
Self
:
Sized
P
:
Params
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnOnce
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
Ok
(
self
.
try_query_row
(
sql
params
mapper
cache
)
?
.
ok_or
(
rusqlite
:
:
Error
:
:
QueryReturnedNoRows
)
?
)
}
fn
query_rows_and_then
<
T
E
P
F
>
(
&
self
sql
:
&
str
params
:
P
mapper
:
F
)
-
>
Result
<
Vec
<
T
>
E
>
where
Self
:
Sized
P
:
Params
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
query_rows_and_then_cachable
(
self
.
conn
(
)
sql
params
mapper
false
)
}
fn
query_rows_and_then_cached
<
T
E
P
F
>
(
&
self
sql
:
&
str
params
:
P
mapper
:
F
)
-
>
Result
<
Vec
<
T
>
E
>
where
Self
:
Sized
P
:
Params
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
query_rows_and_then_cachable
(
self
.
conn
(
)
sql
params
mapper
true
)
}
fn
query_rows_into
<
Coll
T
E
P
F
>
(
&
self
sql
:
&
str
params
:
P
mapper
:
F
)
-
>
Result
<
Coll
E
>
where
Self
:
Sized
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
Coll
:
FromIterator
<
T
>
P
:
Params
{
query_rows_and_then_cachable
(
self
.
conn
(
)
sql
params
mapper
false
)
}
fn
query_rows_into_cached
<
Coll
T
E
P
F
>
(
&
self
sql
:
&
str
params
:
P
mapper
:
F
)
-
>
Result
<
Coll
E
>
where
Self
:
Sized
P
:
Params
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
Coll
:
FromIterator
<
T
>
{
query_rows_and_then_cachable
(
self
.
conn
(
)
sql
params
mapper
true
)
}
fn
try_query_row
<
T
E
P
F
>
(
&
self
sql
:
&
str
params
:
P
mapper
:
F
cache
:
bool
)
-
>
Result
<
Option
<
T
>
E
>
where
Self
:
Sized
P
:
Params
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnOnce
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
{
let
conn
=
self
.
conn
(
)
;
let
mut
stmt
=
MaybeCached
:
:
prepare
(
conn
sql
cache
)
?
;
let
mut
rows
=
stmt
.
query
(
params
)
?
;
rows
.
next
(
)
?
.
map
(
mapper
)
.
transpose
(
)
}
fn
unchecked_transaction
(
&
self
)
-
>
SqlResult
<
UncheckedTransaction
<
'
_
>
>
{
UncheckedTransaction
:
:
new
(
self
.
conn
(
)
TransactionBehavior
:
:
Deferred
)
}
fn
unchecked_transaction_imm
(
&
self
)
-
>
SqlResult
<
UncheckedTransaction
<
'
_
>
>
{
UncheckedTransaction
:
:
new
(
self
.
conn
(
)
TransactionBehavior
:
:
Immediate
)
}
fn
get_db_size
(
&
self
)
-
>
Result
<
u32
rusqlite
:
:
Error
>
{
let
page_count
:
u32
=
self
.
conn_ext_query_one
(
"
SELECT
*
from
pragma_page_count
(
)
"
)
?
;
let
page_size
:
u32
=
self
.
conn_ext_query_one
(
"
SELECT
*
from
pragma_page_size
(
)
"
)
?
;
let
freelist_count
:
u32
=
self
.
conn_ext_query_one
(
"
SELECT
*
from
pragma_freelist_count
(
)
"
)
?
;
Ok
(
(
page_count
-
freelist_count
)
*
page_size
)
}
}
impl
ConnExt
for
Connection
{
#
[
inline
]
fn
conn
(
&
self
)
-
>
&
Connection
{
self
}
}
impl
ConnExt
for
Transaction
<
'
_
>
{
#
[
inline
]
fn
conn
(
&
self
)
-
>
&
Connection
{
self
}
}
impl
ConnExt
for
Savepoint
<
'
_
>
{
#
[
inline
]
fn
conn
(
&
self
)
-
>
&
Connection
{
self
}
}
pub
struct
UncheckedTransaction
<
'
conn
>
{
pub
conn
:
&
'
conn
Connection
pub
started_at
:
Instant
pub
finished
:
bool
}
impl
<
'
conn
>
UncheckedTransaction
<
'
conn
>
{
pub
fn
new
(
conn
:
&
'
conn
Connection
behavior
:
TransactionBehavior
)
-
>
SqlResult
<
Self
>
{
let
query
=
match
behavior
{
TransactionBehavior
:
:
Deferred
=
>
"
BEGIN
DEFERRED
"
TransactionBehavior
:
:
Immediate
=
>
"
BEGIN
IMMEDIATE
"
TransactionBehavior
:
:
Exclusive
=
>
"
BEGIN
EXCLUSIVE
"
_
=
>
unreachable
!
(
)
}
;
conn
.
execute_batch
(
query
)
.
map
(
move
|
_
|
UncheckedTransaction
{
conn
started_at
:
Instant
:
:
now
(
)
finished
:
false
}
)
}
pub
fn
commit
(
mut
self
)
-
>
SqlResult
<
(
)
>
{
if
self
.
finished
{
warn
!
(
"
ignoring
request
to
commit
an
already
finished
transaction
"
)
;
return
Ok
(
(
)
)
;
}
self
.
finished
=
true
;
self
.
conn
.
execute_batch
(
"
COMMIT
"
)
?
;
debug
!
(
"
Transaction
commited
after
{
:
?
}
"
self
.
started_at
.
elapsed
(
)
)
;
Ok
(
(
)
)
}
pub
fn
rollback
(
mut
self
)
-
>
SqlResult
<
(
)
>
{
if
self
.
finished
{
warn
!
(
"
ignoring
request
to
rollback
an
already
finished
transaction
"
)
;
return
Ok
(
(
)
)
;
}
self
.
rollback_
(
)
}
fn
rollback_
(
&
mut
self
)
-
>
SqlResult
<
(
)
>
{
self
.
finished
=
true
;
self
.
conn
.
execute_batch
(
"
ROLLBACK
"
)
?
;
Ok
(
(
)
)
}
fn
finish_
(
&
mut
self
)
-
>
SqlResult
<
(
)
>
{
if
self
.
finished
|
|
self
.
conn
.
is_autocommit
(
)
{
return
Ok
(
(
)
)
;
}
self
.
rollback_
(
)
?
;
Ok
(
(
)
)
}
}
impl
Deref
for
UncheckedTransaction
<
'
_
>
{
type
Target
=
Connection
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
Connection
{
self
.
conn
}
}
impl
Drop
for
UncheckedTransaction
<
'
_
>
{
fn
drop
(
&
mut
self
)
{
if
let
Err
(
e
)
=
self
.
finish_
(
)
{
warn
!
(
"
Error
dropping
an
unchecked
transaction
:
{
}
"
e
)
;
}
}
}
impl
ConnExt
for
UncheckedTransaction
<
'
_
>
{
#
[
inline
]
fn
conn
(
&
self
)
-
>
&
Connection
{
self
}
}
fn
query_rows_and_then_cachable
<
Coll
T
E
P
F
>
(
conn
:
&
Connection
sql
:
&
str
params
:
P
mapper
:
F
cache
:
bool
)
-
>
Result
<
Coll
E
>
where
E
:
From
<
rusqlite
:
:
Error
>
F
:
FnMut
(
&
Row
<
'
_
>
)
-
>
Result
<
T
E
>
Coll
:
FromIterator
<
T
>
P
:
Params
{
let
mut
stmt
=
conn
.
prepare_maybe_cached
(
sql
cache
)
?
;
let
iter
=
stmt
.
query_and_then
(
params
mapper
)
?
;
iter
.
collect
:
:
<
Result
<
Coll
E
>
>
(
)
}
