use
crate
:
:
open_database
:
:
{
open_database_with_flags
ConnectionInitializer
Error
}
;
use
interrupt_support
:
:
{
register_interrupt
SqlInterruptHandle
SqlInterruptScope
}
;
use
parking_lot
:
:
{
MappedMutexGuard
Mutex
MutexGuard
}
;
use
rusqlite
:
:
{
Connection
OpenFlags
}
;
use
std
:
:
{
path
:
:
{
Path
PathBuf
}
sync
:
:
{
Arc
Weak
}
}
;
pub
struct
LazyDb
<
CI
>
{
path
:
PathBuf
open_flags
:
OpenFlags
connection_initializer
:
CI
connection
:
Mutex
<
Option
<
Connection
>
>
interrupt_handle
:
Mutex
<
Option
<
Arc
<
SqlInterruptHandle
>
>
>
}
impl
<
CI
:
ConnectionInitializer
>
LazyDb
<
CI
>
{
pub
fn
new
(
path
:
&
Path
open_flags
:
OpenFlags
connection_initializer
:
CI
)
-
>
Self
{
Self
{
path
:
path
.
to_owned
(
)
open_flags
connection_initializer
connection
:
Mutex
:
:
new
(
None
)
interrupt_handle
:
Mutex
:
:
new
(
None
)
}
}
pub
fn
lock
(
&
self
)
-
>
Result
<
(
MappedMutexGuard
<
'
_
Connection
>
SqlInterruptScope
)
Error
>
{
let
conn
=
self
.
get_conn
(
)
?
;
let
scope
=
self
.
get_scope
(
&
conn
)
?
;
Ok
(
(
conn
scope
)
)
}
fn
get_conn
(
&
self
)
-
>
Result
<
MappedMutexGuard
<
'
_
Connection
>
Error
>
{
let
mut
guard
=
self
.
connection
.
lock
(
)
;
if
guard
.
is_none
(
)
{
*
guard
=
Some
(
open_database_with_flags
(
&
self
.
path
self
.
open_flags
&
self
.
connection_initializer
)
?
)
;
}
;
Ok
(
MutexGuard
:
:
map
(
guard
|
conn_option
|
{
conn_option
.
as_mut
(
)
.
unwrap
(
)
}
)
)
}
fn
get_scope
(
&
self
conn
:
&
Connection
)
-
>
Result
<
SqlInterruptScope
Error
>
{
let
mut
handle_guard
=
self
.
interrupt_handle
.
lock
(
)
;
let
result
=
match
handle_guard
.
as_ref
(
)
{
Some
(
handle
)
=
>
handle
.
begin_interrupt_scope
(
)
None
=
>
{
let
handle
=
Arc
:
:
new
(
SqlInterruptHandle
:
:
new
(
conn
)
)
;
register_interrupt
(
Arc
:
:
downgrade
(
&
handle
)
as
Weak
<
dyn
AsRef
<
SqlInterruptHandle
>
+
Send
+
Sync
>
)
;
handle_guard
.
insert
(
handle
)
.
begin_interrupt_scope
(
)
}
}
;
result
.
map_err
(
|
_
|
Error
:
:
Shutdown
)
}
pub
fn
close
(
&
self
interrupt
:
bool
)
{
let
mut
interrupt_handle
=
self
.
interrupt_handle
.
lock
(
)
;
if
let
Some
(
handle
)
=
interrupt_handle
.
as_ref
(
)
{
if
interrupt
{
handle
.
interrupt
(
)
;
}
*
interrupt_handle
=
None
;
}
drop
(
interrupt_handle
)
;
*
self
.
connection
.
lock
(
)
=
None
;
}
pub
fn
interrupt
(
&
self
)
{
if
let
Some
(
handle
)
=
self
.
interrupt_handle
.
lock
(
)
.
as_ref
(
)
{
handle
.
interrupt
(
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
crate
:
:
open_database
:
:
test_utils
:
:
TestConnectionInitializer
;
fn
open_test_db
(
)
-
>
LazyDb
<
TestConnectionInitializer
>
{
LazyDb
:
:
new
(
Path
:
:
new
(
"
:
memory
:
"
)
OpenFlags
:
:
default
(
)
TestConnectionInitializer
:
:
new
(
)
)
}
#
[
test
]
fn
test_interrupt
(
)
{
let
lazy_db
=
open_test_db
(
)
;
let
(
_
scope
)
=
lazy_db
.
lock
(
)
.
unwrap
(
)
;
assert
!
(
!
scope
.
was_interrupted
(
)
)
;
lazy_db
.
interrupt
(
)
;
assert
!
(
scope
.
was_interrupted
(
)
)
;
}
#
[
test
]
fn
interrupt_before_db_is_opened_should_not_fail
(
)
{
let
lazy_db
=
open_test_db
(
)
;
lazy_db
.
interrupt
(
)
;
}
}
