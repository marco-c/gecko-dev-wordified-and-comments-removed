use
std
:
:
fmt
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
RepeatDisplay
<
'
a
F
>
{
count
:
usize
sep
:
&
'
a
str
fmt_one
:
F
}
impl
<
'
a
F
>
fmt
:
:
Display
for
RepeatDisplay
<
'
a
F
>
where
F
:
Fn
(
usize
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
for
i
in
0
.
.
self
.
count
{
if
i
!
=
0
{
f
.
write_str
(
self
.
sep
)
?
;
}
(
self
.
fmt_one
)
(
i
f
)
?
;
}
Ok
(
(
)
)
}
}
#
[
inline
]
pub
fn
repeat_display
<
F
>
(
count
:
usize
sep
:
&
str
fmt_one
:
F
)
-
>
RepeatDisplay
<
'
_
F
>
where
F
:
Fn
(
usize
&
mut
fmt
:
:
Formatter
<
'
_
>
)
-
>
fmt
:
:
Result
{
RepeatDisplay
{
count
sep
fmt_one
}
}
pub
fn
repeat_sql_vars
(
count
:
usize
)
-
>
impl
fmt
:
:
Display
{
repeat_display
(
count
"
"
|
_
f
|
write
!
(
f
"
?
"
)
)
}
pub
fn
repeat_sql_values
(
count
:
usize
)
-
>
impl
fmt
:
:
Display
{
repeat_display
(
count
"
"
|
_
f
|
write
!
(
f
"
(
?
)
"
)
)
}
pub
fn
repeat_multi_values
(
num_values
:
usize
vars_per_value
:
usize
)
-
>
impl
fmt
:
:
Display
{
assert_ne
!
(
vars_per_value
0
"
Illegal
value
for
vars_per_value
must
not
be
zero
"
)
;
repeat_display
(
num_values
"
"
move
|
_
f
|
{
write
!
(
f
"
(
{
}
)
"
repeat_sql_vars
(
vars_per_value
)
)
}
)
}
