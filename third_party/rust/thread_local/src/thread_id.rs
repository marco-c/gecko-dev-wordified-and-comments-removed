use
std
:
:
collections
:
:
BinaryHeap
;
use
std
:
:
sync
:
:
Mutex
;
use
std
:
:
usize
;
struct
ThreadIdManager
{
limit
:
usize
free_list
:
BinaryHeap
<
usize
>
}
impl
ThreadIdManager
{
fn
new
(
)
-
>
ThreadIdManager
{
ThreadIdManager
{
limit
:
usize
:
:
MAX
free_list
:
BinaryHeap
:
:
new
(
)
}
}
fn
alloc
(
&
mut
self
)
-
>
usize
{
if
let
Some
(
id
)
=
self
.
free_list
.
pop
(
)
{
id
}
else
{
let
id
=
self
.
limit
;
self
.
limit
=
self
.
limit
.
checked_sub
(
1
)
.
expect
(
"
Ran
out
of
thread
IDs
"
)
;
id
}
}
fn
free
(
&
mut
self
id
:
usize
)
{
self
.
free_list
.
push
(
id
)
;
}
}
lazy_static
!
{
static
ref
THREAD_ID_MANAGER
:
Mutex
<
ThreadIdManager
>
=
Mutex
:
:
new
(
ThreadIdManager
:
:
new
(
)
)
;
}
struct
ThreadId
(
usize
)
;
impl
ThreadId
{
fn
new
(
)
-
>
ThreadId
{
ThreadId
(
THREAD_ID_MANAGER
.
lock
(
)
.
unwrap
(
)
.
alloc
(
)
)
}
}
impl
Drop
for
ThreadId
{
fn
drop
(
&
mut
self
)
{
THREAD_ID_MANAGER
.
lock
(
)
.
unwrap
(
)
.
free
(
self
.
0
)
;
}
}
thread_local
!
(
static
THREAD_ID
:
ThreadId
=
ThreadId
:
:
new
(
)
)
;
pub
fn
get
(
)
-
>
usize
{
THREAD_ID
.
with
(
|
x
|
x
.
0
)
}
