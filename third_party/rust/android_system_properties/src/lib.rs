use
std
:
:
{
ffi
:
:
{
CStr
CString
}
os
:
:
raw
:
:
{
c_char
c_int
c_void
}
}
;
#
[
cfg
(
target_os
=
"
android
"
)
]
use
std
:
:
mem
;
unsafe
fn
property_callback
(
payload
:
*
mut
String
_name
:
*
const
c_char
value
:
*
const
c_char
_serial
:
u32
)
{
let
cvalue
=
CStr
:
:
from_ptr
(
value
)
;
(
*
payload
)
=
cvalue
.
to_str
(
)
.
unwrap
(
)
.
to_string
(
)
;
}
type
Callback
=
unsafe
fn
(
*
mut
String
*
const
c_char
*
const
c_char
u32
)
;
type
SystemPropertyGetFn
=
unsafe
extern
"
C
"
fn
(
*
const
c_char
*
mut
c_char
)
-
>
c_int
;
type
SystemPropertyFindFn
=
unsafe
extern
"
C
"
fn
(
*
const
c_char
)
-
>
*
const
c_void
;
type
SystemPropertyReadCallbackFn
=
unsafe
extern
"
C
"
fn
(
*
const
c_void
Callback
*
mut
String
)
-
>
*
const
c_void
;
#
[
derive
(
Debug
)
]
pub
struct
AndroidSystemProperties
{
libc_so
:
*
mut
c_void
get_fn
:
Option
<
SystemPropertyGetFn
>
find_fn
:
Option
<
SystemPropertyFindFn
>
read_callback_fn
:
Option
<
SystemPropertyReadCallbackFn
>
}
unsafe
impl
Send
for
AndroidSystemProperties
{
}
unsafe
impl
Sync
for
AndroidSystemProperties
{
}
impl
AndroidSystemProperties
{
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
pub
fn
new
(
)
-
>
Self
{
AndroidSystemProperties
{
libc_so
:
std
:
:
ptr
:
:
null_mut
(
)
find_fn
:
None
read_callback_fn
:
None
get_fn
:
None
}
}
#
[
cfg
(
target_os
=
"
android
"
)
]
pub
fn
new
(
)
-
>
Self
{
let
libc_so
=
unsafe
{
libc
:
:
dlopen
(
b
"
libc
.
so
\
0
"
.
as_ptr
(
)
.
cast
(
)
libc
:
:
RTLD_NOLOAD
)
}
;
let
mut
properties
=
AndroidSystemProperties
{
libc_so
find_fn
:
None
read_callback_fn
:
None
get_fn
:
None
}
;
if
libc_so
.
is_null
(
)
{
return
properties
;
}
unsafe
fn
load_fn
(
libc_so
:
*
mut
c_void
name
:
&
[
u8
]
)
-
>
Option
<
*
const
c_void
>
{
let
fn_ptr
=
libc
:
:
dlsym
(
libc_so
name
.
as_ptr
(
)
.
cast
(
)
)
;
if
fn_ptr
.
is_null
(
)
{
return
None
;
}
Some
(
fn_ptr
)
}
unsafe
{
properties
.
read_callback_fn
=
load_fn
(
libc_so
b
"
__system_property_read_callback
\
0
"
)
.
map
(
|
raw
|
mem
:
:
transmute
:
:
<
*
const
c_void
SystemPropertyReadCallbackFn
>
(
raw
)
)
;
properties
.
find_fn
=
load_fn
(
libc_so
b
"
__system_property_find
\
0
"
)
.
map
(
|
raw
|
mem
:
:
transmute
:
:
<
*
const
c_void
SystemPropertyFindFn
>
(
raw
)
)
;
if
properties
.
read_callback_fn
.
is_none
(
)
|
|
properties
.
find_fn
.
is_none
(
)
{
properties
.
get_fn
=
load_fn
(
libc_so
b
"
__system_property_get
\
0
"
)
.
map
(
|
raw
|
mem
:
:
transmute
:
:
<
*
const
c_void
SystemPropertyGetFn
>
(
raw
)
)
;
}
}
properties
}
pub
fn
get
(
&
self
name
:
&
str
)
-
>
Option
<
String
>
{
let
cname
=
CString
:
:
new
(
name
)
.
ok
(
)
?
;
self
.
get_from_cstr
(
&
cname
)
}
pub
fn
get_from_cstr
(
&
self
cname
:
&
std
:
:
ffi
:
:
CStr
)
-
>
Option
<
String
>
{
if
let
(
Some
(
find_fn
)
Some
(
read_callback_fn
)
)
=
(
self
.
find_fn
self
.
read_callback_fn
)
{
let
info
=
unsafe
{
(
find_fn
)
(
cname
.
as_ptr
(
)
)
}
;
if
info
.
is_null
(
)
{
return
None
;
}
let
mut
result
=
String
:
:
new
(
)
;
unsafe
{
(
read_callback_fn
)
(
info
property_callback
&
mut
result
)
;
}
return
Some
(
result
)
;
}
if
let
Some
(
get_fn
)
=
self
.
get_fn
{
const
PROPERTY_VALUE_MAX
:
usize
=
92
;
let
mut
buffer
:
Vec
<
u8
>
=
Vec
:
:
with_capacity
(
PROPERTY_VALUE_MAX
)
;
let
raw
=
buffer
.
as_mut_ptr
(
)
as
*
mut
c_char
;
let
len
=
unsafe
{
(
get_fn
)
(
cname
.
as_ptr
(
)
raw
)
}
;
if
len
>
0
{
assert
!
(
len
as
usize
<
=
buffer
.
capacity
(
)
)
;
unsafe
{
buffer
.
set_len
(
len
as
usize
)
;
}
String
:
:
from_utf8
(
buffer
)
.
ok
(
)
}
else
{
None
}
}
else
{
None
}
}
}
impl
Drop
for
AndroidSystemProperties
{
fn
drop
(
&
mut
self
)
{
if
!
self
.
libc_so
.
is_null
(
)
{
unsafe
{
libc
:
:
dlclose
(
self
.
libc_so
)
;
}
}
}
}
