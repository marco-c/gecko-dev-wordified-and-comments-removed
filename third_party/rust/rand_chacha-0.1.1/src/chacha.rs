use
core
:
:
fmt
;
use
rand_core
:
:
{
CryptoRng
RngCore
SeedableRng
Error
le
}
;
use
rand_core
:
:
block
:
:
{
BlockRngCore
BlockRng
}
;
const
SEED_WORDS
:
usize
=
8
;
const
STATE_WORDS
:
usize
=
16
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
ChaChaRng
(
BlockRng
<
ChaChaCore
>
)
;
impl
RngCore
for
ChaChaRng
{
#
[
inline
]
fn
next_u32
(
&
mut
self
)
-
>
u32
{
self
.
0
.
next_u32
(
)
}
#
[
inline
]
fn
next_u64
(
&
mut
self
)
-
>
u64
{
self
.
0
.
next_u64
(
)
}
#
[
inline
]
fn
fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
{
self
.
0
.
fill_bytes
(
dest
)
}
#
[
inline
]
fn
try_fill_bytes
(
&
mut
self
dest
:
&
mut
[
u8
]
)
-
>
Result
<
(
)
Error
>
{
self
.
0
.
try_fill_bytes
(
dest
)
}
}
impl
SeedableRng
for
ChaChaRng
{
type
Seed
=
<
ChaChaCore
as
SeedableRng
>
:
:
Seed
;
fn
from_seed
(
seed
:
Self
:
:
Seed
)
-
>
Self
{
ChaChaRng
(
BlockRng
:
:
<
ChaChaCore
>
:
:
from_seed
(
seed
)
)
}
fn
from_rng
<
R
:
RngCore
>
(
rng
:
R
)
-
>
Result
<
Self
Error
>
{
BlockRng
:
:
<
ChaChaCore
>
:
:
from_rng
(
rng
)
.
map
(
ChaChaRng
)
}
}
impl
CryptoRng
for
ChaChaRng
{
}
impl
ChaChaRng
{
#
[
cfg
(
all
(
rustc_1_26
not
(
target_os
=
"
emscripten
"
)
)
)
]
pub
fn
get_word_pos
(
&
self
)
-
>
u128
{
let
mut
c
=
(
self
.
0
.
core
.
state
[
13
]
as
u64
)
<
<
32
|
(
self
.
0
.
core
.
state
[
12
]
as
u64
)
;
let
mut
index
=
self
.
0
.
index
(
)
;
if
index
>
=
STATE_WORDS
{
index
=
0
;
}
else
{
c
=
c
.
wrapping_sub
(
1
)
;
}
(
(
c
as
u128
)
<
<
4
)
|
(
index
as
u128
)
}
#
[
cfg
(
all
(
rustc_1_26
not
(
target_os
=
"
emscripten
"
)
)
)
]
pub
fn
set_word_pos
(
&
mut
self
word_offset
:
u128
)
{
let
index
=
(
word_offset
as
usize
)
&
0xF
;
let
counter
=
(
word_offset
>
>
4
)
as
u64
;
self
.
0
.
core
.
state
[
12
]
=
counter
as
u32
;
self
.
0
.
core
.
state
[
13
]
=
(
counter
>
>
32
)
as
u32
;
if
index
!
=
0
{
self
.
0
.
generate_and_set
(
index
)
;
}
else
{
self
.
0
.
reset
(
)
;
}
}
pub
fn
set_stream
(
&
mut
self
stream
:
u64
)
{
let
index
=
self
.
0
.
index
(
)
;
self
.
0
.
core
.
state
[
14
]
=
stream
as
u32
;
self
.
0
.
core
.
state
[
15
]
=
(
stream
>
>
32
)
as
u32
;
if
index
<
STATE_WORDS
{
{
if
self
.
0
.
core
.
state
[
12
]
=
=
0
{
self
.
0
.
core
.
state
[
13
]
=
self
.
0
.
core
.
state
[
13
]
.
wrapping_sub
(
1
)
;
}
self
.
0
.
core
.
state
[
12
]
=
self
.
0
.
core
.
state
[
12
]
.
wrapping_sub
(
1
)
;
}
self
.
0
.
generate_and_set
(
index
)
;
}
}
}
#
[
derive
(
Clone
)
]
pub
struct
ChaChaCore
{
state
:
[
u32
;
STATE_WORDS
]
}
impl
fmt
:
:
Debug
for
ChaChaCore
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ChaChaCore
{
{
}
}
"
)
}
}
macro_rules
!
quarter_round
{
(
a
:
expr
b
:
expr
c
:
expr
d
:
expr
)
=
>
{
{
a
=
a
.
wrapping_add
(
b
)
;
d
^
=
a
;
d
=
d
.
rotate_left
(
16
)
;
c
=
c
.
wrapping_add
(
d
)
;
b
^
=
c
;
b
=
b
.
rotate_left
(
12
)
;
a
=
a
.
wrapping_add
(
b
)
;
d
^
=
a
;
d
=
d
.
rotate_left
(
8
)
;
c
=
c
.
wrapping_add
(
d
)
;
b
^
=
c
;
b
=
b
.
rotate_left
(
7
)
;
}
}
}
macro_rules
!
double_round
{
(
x
:
expr
)
=
>
{
{
/
/
Column
round
quarter_round
!
(
x
[
0
]
x
[
4
]
x
[
8
]
x
[
12
]
)
;
quarter_round
!
(
x
[
1
]
x
[
5
]
x
[
9
]
x
[
13
]
)
;
quarter_round
!
(
x
[
2
]
x
[
6
]
x
[
10
]
x
[
14
]
)
;
quarter_round
!
(
x
[
3
]
x
[
7
]
x
[
11
]
x
[
15
]
)
;
/
/
Diagonal
round
quarter_round
!
(
x
[
0
]
x
[
5
]
x
[
10
]
x
[
15
]
)
;
quarter_round
!
(
x
[
1
]
x
[
6
]
x
[
11
]
x
[
12
]
)
;
quarter_round
!
(
x
[
2
]
x
[
7
]
x
[
8
]
x
[
13
]
)
;
quarter_round
!
(
x
[
3
]
x
[
4
]
x
[
9
]
x
[
14
]
)
;
}
}
}
impl
BlockRngCore
for
ChaChaCore
{
type
Item
=
u32
;
type
Results
=
[
u32
;
STATE_WORDS
]
;
fn
generate
(
&
mut
self
results
:
&
mut
Self
:
:
Results
)
{
fn
core
(
results
:
&
mut
[
u32
;
STATE_WORDS
]
state
:
&
[
u32
;
STATE_WORDS
]
)
{
let
mut
tmp
=
*
state
;
let
rounds
=
20
;
for
_
in
0
.
.
rounds
/
2
{
double_round
!
(
tmp
)
;
}
for
i
in
0
.
.
STATE_WORDS
{
results
[
i
]
=
tmp
[
i
]
.
wrapping_add
(
state
[
i
]
)
;
}
}
core
(
results
&
self
.
state
)
;
self
.
state
[
12
]
=
self
.
state
[
12
]
.
wrapping_add
(
1
)
;
if
self
.
state
[
12
]
!
=
0
{
return
;
}
;
self
.
state
[
13
]
=
self
.
state
[
13
]
.
wrapping_add
(
1
)
;
}
}
impl
SeedableRng
for
ChaChaCore
{
type
Seed
=
[
u8
;
SEED_WORDS
*
4
]
;
fn
from_seed
(
seed
:
Self
:
:
Seed
)
-
>
Self
{
let
mut
seed_le
=
[
0u32
;
SEED_WORDS
]
;
le
:
:
read_u32_into
(
&
seed
&
mut
seed_le
)
;
Self
{
state
:
[
0x61707865
0x3320646E
0x79622D32
0x6B206574
seed_le
[
0
]
seed_le
[
1
]
seed_le
[
2
]
seed_le
[
3
]
seed_le
[
4
]
seed_le
[
5
]
seed_le
[
6
]
seed_le
[
7
]
0
0
0
0
]
}
}
}
impl
CryptoRng
for
ChaChaCore
{
}
impl
From
<
ChaChaCore
>
for
ChaChaRng
{
fn
from
(
core
:
ChaChaCore
)
-
>
Self
{
ChaChaRng
(
BlockRng
:
:
new
(
core
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
:
:
rand_core
:
:
{
RngCore
SeedableRng
}
;
use
super
:
:
ChaChaRng
;
#
[
test
]
fn
test_chacha_construction
(
)
{
let
seed
=
[
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
2
0
0
0
0
0
0
0
3
0
0
0
0
0
0
0
]
;
let
mut
rng1
=
ChaChaRng
:
:
from_seed
(
seed
)
;
assert_eq
!
(
rng1
.
next_u32
(
)
137206642
)
;
let
mut
rng2
=
ChaChaRng
:
:
from_rng
(
rng1
)
.
unwrap
(
)
;
assert_eq
!
(
rng2
.
next_u32
(
)
1325750369
)
;
}
#
[
test
]
fn
test_chacha_true_values_a
(
)
{
let
seed
=
[
0u8
;
32
]
;
let
mut
rng
=
ChaChaRng
:
:
from_seed
(
seed
)
;
let
mut
results
=
[
0u32
;
16
]
;
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng
.
next_u32
(
)
;
}
let
expected
=
[
0xade0b876
0x903df1a0
0xe56a5d40
0x28bd8653
0xb819d2bd
0x1aed8da0
0xccef36a8
0xc70d778b
0x7c5941da
0x8d485751
0x3fe02477
0x374ad8b8
0xf4b8436a
0x1ca11815
0x69b687c3
0x8665eeb2
]
;
assert_eq
!
(
results
expected
)
;
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng
.
next_u32
(
)
;
}
let
expected
=
[
0xbee7079f
0x7a385155
0x7c97ba98
0x0d082d73
0xa0290fcb
0x6965e348
0x3e53c612
0xed7aee32
0x7621b729
0x434ee69c
0xb03371d5
0xd539d874
0x281fed31
0x45fb0a51
0x1f0ae1ac
0x6f4d794b
]
;
assert_eq
!
(
results
expected
)
;
}
#
[
test
]
fn
test_chacha_true_values_b
(
)
{
let
seed
=
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
]
;
let
mut
rng
=
ChaChaRng
:
:
from_seed
(
seed
)
;
for
_
in
0
.
.
16
{
rng
.
next_u32
(
)
;
}
let
mut
results
=
[
0u32
;
16
]
;
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng
.
next_u32
(
)
;
}
let
expected
=
[
0x2452eb3a
0x9249f8ec
0x8d829d9b
0xddd4ceb1
0xe8252083
0x60818b01
0xf38422b8
0x5aaa49c9
0xbb00ca8e
0xda3ba7b4
0xc4b592d1
0xfdf2732f
0x4436274e
0x2561b3c8
0xebdd4aa6
0xa0136c00
]
;
assert_eq
!
(
results
expected
)
;
}
#
[
test
]
#
[
cfg
(
all
(
rustc_1_26
not
(
target_os
=
"
emscripten
"
)
)
)
]
fn
test_chacha_true_values_c
(
)
{
let
seed
=
[
0
0xff
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
;
let
expected
=
[
0xfb4dd572
0x4bc42ef1
0xdf922636
0x327f1394
0xa78dea8f
0x5e269039
0xa1bebbc1
0xcaf09aae
0xa25ab213
0x48a6b46c
0x1b9d9bcb
0x092c5be6
0x546ca624
0x1bec45d5
0x87f47473
0x96f0992e
]
;
let
expected_end
=
3
*
16
;
let
mut
results
=
[
0u32
;
16
]
;
let
mut
rng1
=
ChaChaRng
:
:
from_seed
(
seed
)
;
for
_
in
0
.
.
32
{
rng1
.
next_u32
(
)
;
}
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng1
.
next_u32
(
)
;
}
assert_eq
!
(
results
expected
)
;
assert_eq
!
(
rng1
.
get_word_pos
(
)
expected_end
)
;
let
mut
rng2
=
ChaChaRng
:
:
from_seed
(
seed
)
;
rng2
.
set_word_pos
(
2
*
16
)
;
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng2
.
next_u32
(
)
;
}
assert_eq
!
(
results
expected
)
;
assert_eq
!
(
rng2
.
get_word_pos
(
)
expected_end
)
;
let
mut
buf
=
[
0u8
;
32
]
;
rng2
.
fill_bytes
(
&
mut
buf
[
.
.
]
)
;
assert_eq
!
(
rng2
.
get_word_pos
(
)
expected_end
+
8
)
;
rng2
.
fill_bytes
(
&
mut
buf
[
0
.
.
25
]
)
;
assert_eq
!
(
rng2
.
get_word_pos
(
)
expected_end
+
15
)
;
rng2
.
next_u64
(
)
;
assert_eq
!
(
rng2
.
get_word_pos
(
)
expected_end
+
17
)
;
rng2
.
next_u32
(
)
;
rng2
.
next_u64
(
)
;
assert_eq
!
(
rng2
.
get_word_pos
(
)
expected_end
+
20
)
;
rng2
.
fill_bytes
(
&
mut
buf
[
0
.
.
1
]
)
;
assert_eq
!
(
rng2
.
get_word_pos
(
)
expected_end
+
21
)
;
}
#
[
test
]
fn
test_chacha_multiple_blocks
(
)
{
let
seed
=
[
0
0
0
0
1
0
0
0
2
0
0
0
3
0
0
0
4
0
0
0
5
0
0
0
6
0
0
0
7
0
0
0
]
;
let
mut
rng
=
ChaChaRng
:
:
from_seed
(
seed
)
;
let
mut
results
=
[
0u32
;
16
]
;
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng
.
next_u32
(
)
;
for
_
in
0
.
.
16
{
rng
.
next_u32
(
)
;
}
}
let
expected
=
[
0xf225c81a
0x6ab1be57
0x04d42951
0x70858036
0x49884684
0x64efec72
0x4be2d186
0x3615b384
0x11cfa18e
0xd3c50049
0x75c775f6
0x434c6530
0x2c5bad8f
0x898881dc
0x5f1c86d9
0xc1f8e7f4
]
;
assert_eq
!
(
results
expected
)
;
}
#
[
test
]
fn
test_chacha_true_bytes
(
)
{
let
seed
=
[
0u8
;
32
]
;
let
mut
rng
=
ChaChaRng
:
:
from_seed
(
seed
)
;
let
mut
results
=
[
0u8
;
32
]
;
rng
.
fill_bytes
(
&
mut
results
)
;
let
expected
=
[
118
184
224
173
160
241
61
144
64
93
106
229
83
134
189
40
189
210
25
184
160
141
237
26
168
54
239
204
139
119
13
199
]
;
assert_eq
!
(
results
expected
)
;
}
#
[
test
]
fn
test_chacha_nonce
(
)
{
let
seed
=
[
0u8
;
32
]
;
let
mut
rng
=
ChaChaRng
:
:
from_seed
(
seed
)
;
rng
.
set_stream
(
2u64
<
<
(
24
+
32
)
)
;
let
mut
results
=
[
0u32
;
16
]
;
for
i
in
results
.
iter_mut
(
)
{
*
i
=
rng
.
next_u32
(
)
;
}
let
expected
=
[
0x374dc6c2
0x3736d58c
0xb904e24a
0xcd3f93ef
0x88228b1a
0x96a4dfb3
0x5b76ab72
0xc727ee54
0x0e0e978a
0xf3145c95
0x1b748ea8
0xf786c297
0x99c28f5f
0x628314e8
0x398a19fa
0x6ded1b53
]
;
assert_eq
!
(
results
expected
)
;
}
#
[
test
]
fn
test_chacha_clone_streams
(
)
{
let
seed
=
[
0
0
0
0
1
0
0
0
2
0
0
0
3
0
0
0
4
0
0
0
5
0
0
0
6
0
0
0
7
0
0
0
]
;
let
mut
rng
=
ChaChaRng
:
:
from_seed
(
seed
)
;
let
mut
clone
=
rng
.
clone
(
)
;
for
_
in
0
.
.
16
{
assert_eq
!
(
rng
.
next_u64
(
)
clone
.
next_u64
(
)
)
;
}
rng
.
set_stream
(
51
)
;
for
_
in
0
.
.
7
{
assert
!
(
rng
.
next_u32
(
)
!
=
clone
.
next_u32
(
)
)
;
}
clone
.
set_stream
(
51
)
;
for
_
in
7
.
.
16
{
assert_eq
!
(
rng
.
next_u32
(
)
clone
.
next_u32
(
)
)
;
}
}
}
