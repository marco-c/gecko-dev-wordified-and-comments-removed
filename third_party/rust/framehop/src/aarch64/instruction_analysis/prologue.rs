use
super
:
:
super
:
:
unwind_rule
:
:
UnwindRuleAarch64
;
struct
PrologueDetectorAarch64
{
sp_offset
:
i32
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
enum
PrologueStepResult
{
UnexpectedInstruction
(
UnexpectedInstructionType
)
ValidPrologueInstruction
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
enum
PrologueResult
{
ProbablyAlreadyInBody
(
UnexpectedInstructionType
)
FoundFunctionStart
{
sp_offset
:
i32
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
enum
PrologueInstructionType
{
NotExpectedInPrologue
CouldBePartOfPrologueIfThereIsAlsoAStackPointerSub
VeryLikelyPartOfPrologue
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
)
]
enum
UnexpectedInstructionType
{
StoreOfWrongSize
StoreReferenceRegisterNotSp
AddSubNotOperatingOnSp
NoNextInstruction
NoStackPointerSubBeforeStore
Unknown
}
impl
PrologueDetectorAarch64
{
pub
fn
new
(
)
-
>
Self
{
Self
{
sp_offset
:
0
}
}
pub
fn
analyze_slices
(
&
mut
self
slice_from_start
:
&
[
u8
]
slice_to_end
:
&
[
u8
]
)
-
>
PrologueResult
{
if
slice_to_end
.
len
(
)
<
4
{
return
PrologueResult
:
:
ProbablyAlreadyInBody
(
UnexpectedInstructionType
:
:
NoNextInstruction
)
;
}
let
next_instruction
=
u32
:
:
from_le_bytes
(
[
slice_to_end
[
0
]
slice_to_end
[
1
]
slice_to_end
[
2
]
slice_to_end
[
3
]
]
)
;
let
next_instruction_type
=
Self
:
:
analyze_prologue_instruction_type
(
next_instruction
)
;
if
next_instruction_type
=
=
PrologueInstructionType
:
:
NotExpectedInPrologue
{
return
PrologueResult
:
:
ProbablyAlreadyInBody
(
UnexpectedInstructionType
:
:
Unknown
)
;
}
let
instructions
=
slice_from_start
.
chunks_exact
(
4
)
.
map
(
|
c
|
u32
:
:
from_le_bytes
(
[
c
[
0
]
c
[
1
]
c
[
2
]
c
[
3
]
]
)
)
.
rev
(
)
;
for
instruction
in
instructions
{
if
let
PrologueStepResult
:
:
UnexpectedInstruction
(
_
)
=
self
.
reverse_step_instruction
(
instruction
)
{
break
;
}
}
if
next_instruction_type
=
=
PrologueInstructionType
:
:
CouldBePartOfPrologueIfThereIsAlsoAStackPointerSub
&
&
self
.
sp_offset
=
=
0
{
return
PrologueResult
:
:
ProbablyAlreadyInBody
(
UnexpectedInstructionType
:
:
NoStackPointerSubBeforeStore
)
;
}
PrologueResult
:
:
FoundFunctionStart
{
sp_offset
:
self
.
sp_offset
}
}
pub
fn
analyze_prologue_instruction_type
(
word
:
u32
)
-
>
PrologueInstructionType
{
if
word
=
=
0xd503237f
|
|
word
=
=
0x910003fd
{
return
PrologueInstructionType
:
:
VeryLikelyPartOfPrologue
;
}
let
bits_22_to_32
=
word
>
>
22
;
if
bits_22_to_32
&
0b1011111001
=
=
0b1010100000
{
let
writeback_bits
=
bits_22_to_32
&
0b110
;
let
reference_reg
=
(
(
word
>
>
5
)
&
0b11111
)
as
u16
;
if
writeback_bits
=
=
0b000
|
|
reference_reg
!
=
31
{
return
PrologueInstructionType
:
:
NotExpectedInPrologue
;
}
if
writeback_bits
=
=
0b100
{
return
PrologueInstructionType
:
:
CouldBePartOfPrologueIfThereIsAlsoAStackPointerSub
;
}
return
PrologueInstructionType
:
:
VeryLikelyPartOfPrologue
;
}
if
bits_22_to_32
&
0b1011111110
=
=
0b1001000100
{
let
result_reg
=
(
word
&
0b11111
)
as
u16
;
let
input_reg
=
(
(
word
>
>
5
)
&
0b11111
)
as
u16
;
let
is_sub
=
(
(
word
>
>
30
)
&
0b1
)
=
=
0b1
;
let
expected_result_reg
=
if
is_sub
{
31
}
else
{
29
}
;
if
input_reg
!
=
31
|
|
result_reg
!
=
expected_result_reg
{
return
PrologueInstructionType
:
:
NotExpectedInPrologue
;
}
return
PrologueInstructionType
:
:
VeryLikelyPartOfPrologue
;
}
PrologueInstructionType
:
:
NotExpectedInPrologue
}
pub
fn
reverse_step_instruction
(
&
mut
self
word
:
u32
)
-
>
PrologueStepResult
{
if
word
=
=
0xd503237f
{
return
PrologueStepResult
:
:
ValidPrologueInstruction
;
}
if
(
word
>
>
22
)
&
0b1011111001
=
=
0b1010100000
{
let
writeback_bits
=
(
word
>
>
23
)
&
0b11
;
if
writeback_bits
=
=
0b00
{
return
PrologueStepResult
:
:
UnexpectedInstruction
(
UnexpectedInstructionType
:
:
StoreOfWrongSize
)
;
}
let
reference_reg
=
(
(
word
>
>
5
)
&
0b11111
)
as
u16
;
if
reference_reg
!
=
31
{
return
PrologueStepResult
:
:
UnexpectedInstruction
(
UnexpectedInstructionType
:
:
StoreReferenceRegisterNotSp
)
;
}
let
is_preindexed_writeback
=
writeback_bits
=
=
0b11
;
let
is_postindexed_writeback
=
writeback_bits
=
=
0b01
;
if
is_preindexed_writeback
|
|
is_postindexed_writeback
{
let
imm7
=
(
(
(
(
(
word
>
>
15
)
&
0b1111111
)
as
i16
)
<
<
9
)
>
>
6
)
as
i32
;
self
.
sp_offset
-
=
imm7
;
}
return
PrologueStepResult
:
:
ValidPrologueInstruction
;
}
if
(
word
>
>
23
)
&
0b111111111
=
=
0b110100010
{
let
result_reg
=
(
word
&
0b11111
)
as
u16
;
let
input_reg
=
(
(
word
>
>
5
)
&
0b11111
)
as
u16
;
if
result_reg
!
=
31
|
|
input_reg
!
=
31
{
return
PrologueStepResult
:
:
UnexpectedInstruction
(
UnexpectedInstructionType
:
:
AddSubNotOperatingOnSp
)
;
}
let
mut
imm12
=
(
(
word
>
>
10
)
&
0b111111111111
)
as
i32
;
let
shift_immediate_by_12
=
(
(
word
>
>
22
)
&
0b1
)
=
=
0b1
;
if
shift_immediate_by_12
{
imm12
<
<
=
12
}
self
.
sp_offset
+
=
imm12
;
return
PrologueStepResult
:
:
ValidPrologueInstruction
;
}
PrologueStepResult
:
:
UnexpectedInstruction
(
UnexpectedInstructionType
:
:
Unknown
)
}
}
pub
fn
unwind_rule_from_detected_prologue
(
slice_from_start
:
&
[
u8
]
slice_to_end
:
&
[
u8
]
)
-
>
Option
<
UnwindRuleAarch64
>
{
let
mut
detector
=
PrologueDetectorAarch64
:
:
new
(
)
;
match
detector
.
analyze_slices
(
slice_from_start
slice_to_end
)
{
PrologueResult
:
:
ProbablyAlreadyInBody
(
_
)
=
>
None
PrologueResult
:
:
FoundFunctionStart
{
sp_offset
}
=
>
{
let
sp_offset_by_16
=
u16
:
:
try_from
(
sp_offset
/
16
)
.
ok
(
)
?
;
let
rule
=
if
sp_offset_by_16
=
=
0
{
UnwindRuleAarch64
:
:
NoOp
}
else
{
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
}
}
;
Some
(
rule
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
test_prologue_1
(
)
{
let
bytes
=
&
[
0xff
0x43
0x01
0xd1
0xf6
0x57
0x02
0xa9
0xf4
0x4f
0x03
0xa9
0xfd
0x7b
0x04
0xa9
0xfd
0x03
0x01
0x91
0xf4
0x03
0x04
0xaa
0xf5
0x03
0x01
0xaa
]
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
0
]
&
bytes
[
0
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
NoOp
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
4
]
&
bytes
[
4
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
5
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
8
]
&
bytes
[
8
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
5
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
12
]
&
bytes
[
12
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
5
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
16
]
&
bytes
[
16
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
5
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
20
]
&
bytes
[
20
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
24
]
&
bytes
[
24
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
28
]
&
bytes
[
28
.
.
]
)
None
)
;
}
#
[
test
]
fn
test_prologue_with_pacibsp
(
)
{
let
bytes
=
&
[
0x08
0x58
0x29
0xb8
0xc0
0x03
0x5f
0xd6
0x7f
0x23
0x03
0xd5
0xf8
0x5f
0xbc
0xa9
0xf6
0x57
0x01
0xa9
0xf4
0x4f
0x02
0xa9
0xfd
0x7b
0x03
0xa9
0xfd
0xc3
0x00
0x91
0xf3
0x03
0x02
0xaa
0xf4
0x03
0x01
0xaa
]
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
0
]
&
bytes
[
0
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
4
]
&
bytes
[
4
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
8
]
&
bytes
[
8
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
NoOp
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
12
]
&
bytes
[
12
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
NoOp
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
16
]
&
bytes
[
16
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
4
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
20
]
&
bytes
[
20
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
4
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
24
]
&
bytes
[
24
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
4
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
28
]
&
bytes
[
28
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
4
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
32
]
&
bytes
[
32
.
.
]
)
None
)
;
}
#
[
test
]
fn
test_prologue_with_mov_fp_sp
(
)
{
let
bytes
=
&
[
0x7f
0x23
0x03
0xd5
0xfd
0x7b
0xbf
0xa9
0xfd
0x03
0x00
0x91
0x68
0x04
0x00
0x51
]
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
0
]
&
bytes
[
0
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
NoOp
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
4
]
&
bytes
[
4
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
NoOp
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
8
]
&
bytes
[
8
.
.
]
)
Some
(
UnwindRuleAarch64
:
:
OffsetSp
{
sp_offset_by_16
:
1
}
)
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
12
]
&
bytes
[
12
.
.
]
)
None
)
;
}
#
[
test
]
fn
test_no_prologue_despite_stack_store
(
)
{
let
bytes
=
&
[
0xe8
0x17
0x00
0xf9
0x03
0x00
0x00
0x14
0xff
0xff
0x01
0xa9
0xff
0x17
0x00
0xf9
0xe0
0x03
0x00
0x91
]
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
0
]
&
bytes
[
0
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
4
]
&
bytes
[
4
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
8
]
&
bytes
[
8
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
12
]
&
bytes
[
12
.
.
]
)
None
)
;
assert_eq
!
(
unwind_rule_from_detected_prologue
(
&
bytes
[
.
.
16
]
&
bytes
[
16
.
.
]
)
None
)
;
}
}
