use
super
:
:
super
:
:
unwind_rule
:
:
UnwindRuleX86_64
;
pub
fn
unwind_rule_from_detected_epilogue
(
text_bytes
:
&
[
u8
]
pc_offset
:
usize
)
-
>
Option
<
UnwindRuleX86_64
>
{
let
(
slice_from_start
slice_to_end
)
=
text_bytes
.
split_at
(
pc_offset
)
;
let
mut
sp_offset_by_8
=
0
;
let
mut
bp_offset_by_8
=
None
;
let
mut
bytes
=
slice_to_end
;
loop
{
if
bytes
.
is_empty
(
)
{
return
None
;
}
if
bytes
[
0
]
=
=
0xc3
{
break
;
}
if
bytes
[
0
]
=
=
0xeb
|
|
bytes
[
0
]
=
=
0xe9
|
|
bytes
[
0
]
=
=
0xff
{
if
sp_offset_by_8
!
=
0
{
break
;
}
if
let
Some
(
potential_pop_byte
)
=
slice_from_start
.
last
(
)
{
if
potential_pop_byte
&
0xf8
=
=
0x58
{
break
;
}
}
return
None
;
}
if
bytes
[
0
]
=
=
0x5d
{
bp_offset_by_8
=
Some
(
sp_offset_by_8
as
i16
)
;
sp_offset_by_8
+
=
1
;
bytes
=
&
bytes
[
1
.
.
]
;
continue
;
}
if
(
0x58
.
.
=
0x5f
)
.
contains
(
&
bytes
[
0
]
)
{
sp_offset_by_8
+
=
1
;
bytes
=
&
bytes
[
1
.
.
]
;
continue
;
}
if
bytes
.
len
(
)
>
=
2
&
&
bytes
[
0
]
&
0xfe
=
=
0x40
&
&
bytes
[
1
]
&
0xf8
=
=
0x58
{
sp_offset_by_8
+
=
1
;
bytes
=
&
bytes
[
2
.
.
]
;
continue
;
}
return
None
;
}
let
rule
=
if
sp_offset_by_8
=
=
0
{
UnwindRuleX86_64
:
:
JustReturn
}
else
{
sp_offset_by_8
+
=
1
;
if
let
Some
(
bp_storage_offset_from_sp_by_8
)
=
bp_offset_by_8
{
UnwindRuleX86_64
:
:
OffsetSpAndRestoreBp
{
sp_offset_by_8
bp_storage_offset_from_sp_by_8
}
}
else
{
UnwindRuleX86_64
:
:
OffsetSp
{
sp_offset_by_8
}
}
}
;
Some
(
rule
)
}
