use
std
:
:
collections
:
:
HashSet
;
use
syn
:
:
{
self
visit
}
;
use
internals
:
:
ast
:
:
Container
;
use
internals
:
:
attr
;
macro_rules
!
path
{
(
(
path
:
tt
)
+
)
=
>
{
syn
:
:
parse_path
(
stringify
!
(
(
path
)
+
)
)
.
unwrap
(
)
}
;
}
pub
fn
without_defaults
(
generics
:
&
syn
:
:
Generics
)
-
>
syn
:
:
Generics
{
syn
:
:
Generics
{
ty_params
:
generics
.
ty_params
.
iter
(
)
.
map
(
|
ty_param
|
{
syn
:
:
TyParam
{
default
:
None
.
.
ty_param
.
clone
(
)
}
}
)
.
collect
(
)
.
.
generics
.
clone
(
)
}
}
pub
fn
with_where_predicates
(
generics
:
&
syn
:
:
Generics
predicates
:
&
[
syn
:
:
WherePredicate
]
)
-
>
syn
:
:
Generics
{
let
mut
generics
=
generics
.
clone
(
)
;
generics
.
where_clause
.
predicates
.
extend_from_slice
(
predicates
)
;
generics
}
pub
fn
with_where_predicates_from_fields
<
F
>
(
cont
:
&
Container
generics
:
&
syn
:
:
Generics
from_field
:
F
)
-
>
syn
:
:
Generics
where
F
:
Fn
(
&
attr
:
:
Field
)
-
>
Option
<
&
[
syn
:
:
WherePredicate
]
>
{
let
predicates
=
cont
.
body
.
all_fields
(
)
.
flat_map
(
|
field
|
from_field
(
&
field
.
attrs
)
)
.
flat_map
(
|
predicates
|
predicates
.
to_vec
(
)
)
;
let
mut
generics
=
generics
.
clone
(
)
;
generics
.
where_clause
.
predicates
.
extend
(
predicates
)
;
generics
}
pub
fn
with_bound
<
F
>
(
cont
:
&
Container
generics
:
&
syn
:
:
Generics
filter
:
F
bound
:
&
syn
:
:
Path
)
-
>
syn
:
:
Generics
where
F
:
Fn
(
&
attr
:
:
Field
)
-
>
bool
{
struct
FindTyParams
{
all_ty_params
:
HashSet
<
syn
:
:
Ident
>
relevant_ty_params
:
HashSet
<
syn
:
:
Ident
>
}
impl
visit
:
:
Visitor
for
FindTyParams
{
fn
visit_path
(
&
mut
self
path
:
&
syn
:
:
Path
)
{
if
let
Some
(
seg
)
=
path
.
segments
.
last
(
)
{
if
seg
.
ident
=
=
"
PhantomData
"
{
return
;
}
}
if
!
path
.
global
&
&
path
.
segments
.
len
(
)
=
=
1
{
let
id
=
path
.
segments
[
0
]
.
ident
.
clone
(
)
;
if
self
.
all_ty_params
.
contains
(
&
id
)
{
self
.
relevant_ty_params
.
insert
(
id
)
;
}
}
visit
:
:
walk_path
(
self
path
)
;
}
}
let
all_ty_params
:
HashSet
<
_
>
=
generics
.
ty_params
.
iter
(
)
.
map
(
|
ty_param
|
ty_param
.
ident
.
clone
(
)
)
.
collect
(
)
;
let
relevant_tys
=
cont
.
body
.
all_fields
(
)
.
filter
(
|
&
field
|
filter
(
&
field
.
attrs
)
)
.
map
(
|
field
|
&
field
.
ty
)
;
let
mut
visitor
=
FindTyParams
{
all_ty_params
:
all_ty_params
relevant_ty_params
:
HashSet
:
:
new
(
)
}
;
for
ty
in
relevant_tys
{
visit
:
:
walk_ty
(
&
mut
visitor
ty
)
;
}
let
new_predicates
=
generics
.
ty_params
.
iter
(
)
.
map
(
|
ty_param
|
ty_param
.
ident
.
clone
(
)
)
.
filter
(
|
id
|
visitor
.
relevant_ty_params
.
contains
(
id
)
)
.
map
(
|
id
|
{
syn
:
:
WherePredicate
:
:
BoundPredicate
(
syn
:
:
WhereBoundPredicate
{
bound_lifetimes
:
Vec
:
:
new
(
)
bounded_ty
:
syn
:
:
Ty
:
:
Path
(
None
id
.
into
(
)
)
bounds
:
vec
!
[
syn
:
:
TyParamBound
:
:
Trait
(
syn
:
:
PolyTraitRef
{
bound_lifetimes
:
Vec
:
:
new
(
)
trait_ref
:
bound
.
clone
(
)
}
syn
:
:
TraitBoundModifier
:
:
None
)
]
}
)
}
)
;
let
mut
generics
=
generics
.
clone
(
)
;
generics
.
where_clause
.
predicates
.
extend
(
new_predicates
)
;
generics
}
pub
fn
with_self_bound
(
cont
:
&
Container
generics
:
&
syn
:
:
Generics
bound
:
&
syn
:
:
Path
)
-
>
syn
:
:
Generics
{
let
mut
generics
=
generics
.
clone
(
)
;
generics
.
where_clause
.
predicates
.
push
(
syn
:
:
WherePredicate
:
:
BoundPredicate
(
syn
:
:
WhereBoundPredicate
{
bound_lifetimes
:
Vec
:
:
new
(
)
bounded_ty
:
type_of_item
(
cont
)
bounds
:
vec
!
[
syn
:
:
TyParamBound
:
:
Trait
(
syn
:
:
PolyTraitRef
{
bound_lifetimes
:
Vec
:
:
new
(
)
trait_ref
:
bound
.
clone
(
)
}
syn
:
:
TraitBoundModifier
:
:
None
)
]
}
)
)
;
generics
}
pub
fn
with_lifetime_bound
(
generics
:
&
syn
:
:
Generics
lifetime
:
&
str
)
-
>
syn
:
:
Generics
{
let
mut
generics
=
generics
.
clone
(
)
;
for
lifetime_def
in
&
mut
generics
.
lifetimes
{
lifetime_def
.
bounds
.
push
(
syn
:
:
Lifetime
:
:
new
(
lifetime
)
)
;
}
for
ty_param
in
&
mut
generics
.
ty_params
{
ty_param
.
bounds
.
push
(
syn
:
:
TyParamBound
:
:
Region
(
syn
:
:
Lifetime
:
:
new
(
lifetime
)
)
)
;
}
generics
.
lifetimes
.
push
(
syn
:
:
LifetimeDef
{
attrs
:
Vec
:
:
new
(
)
lifetime
:
syn
:
:
Lifetime
:
:
new
(
lifetime
)
bounds
:
Vec
:
:
new
(
)
}
)
;
generics
}
fn
type_of_item
(
cont
:
&
Container
)
-
>
syn
:
:
Ty
{
syn
:
:
Ty
:
:
Path
(
None
syn
:
:
Path
{
global
:
false
segments
:
vec
!
[
syn
:
:
PathSegment
{
ident
:
cont
.
ident
.
clone
(
)
parameters
:
syn
:
:
PathParameters
:
:
AngleBracketed
(
syn
:
:
AngleBracketedParameterData
{
lifetimes
:
cont
.
generics
.
lifetimes
.
iter
(
)
.
map
(
|
def
|
def
.
lifetime
.
clone
(
)
)
.
collect
(
)
types
:
cont
.
generics
.
ty_params
.
iter
(
)
.
map
(
|
param
|
syn
:
:
Ty
:
:
Path
(
None
param
.
ident
.
clone
(
)
.
into
(
)
)
)
.
collect
(
)
bindings
:
Vec
:
:
new
(
)
}
)
}
]
}
)
}
