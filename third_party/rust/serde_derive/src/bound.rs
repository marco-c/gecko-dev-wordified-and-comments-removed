use
std
:
:
collections
:
:
HashSet
;
use
syn
:
:
{
self
visit
}
;
use
syn
:
:
punctuated
:
:
Punctuated
;
use
internals
:
:
ast
:
:
{
Data
Container
}
;
use
internals
:
:
attr
;
use
proc_macro2
:
:
{
Span
Term
}
;
pub
fn
without_defaults
(
generics
:
&
syn
:
:
Generics
)
-
>
syn
:
:
Generics
{
syn
:
:
Generics
{
params
:
generics
.
params
.
iter
(
)
.
map
(
|
param
|
match
*
param
{
syn
:
:
GenericParam
:
:
Type
(
ref
param
)
=
>
{
syn
:
:
GenericParam
:
:
Type
(
syn
:
:
TypeParam
{
eq_token
:
None
default
:
None
.
.
param
.
clone
(
)
}
)
}
_
=
>
param
.
clone
(
)
}
)
.
collect
(
)
.
.
generics
.
clone
(
)
}
}
pub
fn
with_where_predicates
(
generics
:
&
syn
:
:
Generics
predicates
:
&
[
syn
:
:
WherePredicate
]
)
-
>
syn
:
:
Generics
{
let
mut
generics
=
generics
.
clone
(
)
;
if
generics
.
where_clause
.
is_none
(
)
{
generics
.
where_clause
=
Some
(
syn
:
:
WhereClause
{
where_token
:
Default
:
:
default
(
)
predicates
:
Punctuated
:
:
new
(
)
}
)
;
}
generics
.
where_clause
.
as_mut
(
)
.
unwrap
(
)
.
predicates
.
extend
(
predicates
.
into_iter
(
)
.
cloned
(
)
)
;
generics
}
pub
fn
with_where_predicates_from_fields
<
F
>
(
cont
:
&
Container
generics
:
&
syn
:
:
Generics
from_field
:
F
)
-
>
syn
:
:
Generics
where
F
:
Fn
(
&
attr
:
:
Field
)
-
>
Option
<
&
[
syn
:
:
WherePredicate
]
>
{
let
predicates
=
cont
.
data
.
all_fields
(
)
.
flat_map
(
|
field
|
from_field
(
&
field
.
attrs
)
)
.
flat_map
(
|
predicates
|
predicates
.
to_vec
(
)
)
;
let
mut
generics
=
generics
.
clone
(
)
;
if
generics
.
where_clause
.
is_none
(
)
{
generics
.
where_clause
=
Some
(
syn
:
:
WhereClause
{
where_token
:
Default
:
:
default
(
)
predicates
:
Punctuated
:
:
new
(
)
}
)
;
}
generics
.
where_clause
.
as_mut
(
)
.
unwrap
(
)
.
predicates
.
extend
(
predicates
)
;
generics
}
pub
fn
with_bound
<
F
>
(
cont
:
&
Container
generics
:
&
syn
:
:
Generics
filter
:
F
bound
:
&
syn
:
:
Path
)
-
>
syn
:
:
Generics
where
F
:
Fn
(
&
attr
:
:
Field
Option
<
&
attr
:
:
Variant
>
)
-
>
bool
{
struct
FindTyParams
{
all_ty_params
:
HashSet
<
syn
:
:
Ident
>
relevant_ty_params
:
HashSet
<
syn
:
:
Ident
>
}
impl
<
'
ast
>
visit
:
:
Visit
<
'
ast
>
for
FindTyParams
{
fn
visit_path
(
&
mut
self
path
:
&
syn
:
:
Path
)
{
if
let
Some
(
seg
)
=
path
.
segments
.
last
(
)
{
if
seg
.
into_value
(
)
.
ident
=
=
"
PhantomData
"
{
return
;
}
}
if
path
.
leading_colon
.
is_none
(
)
&
&
path
.
segments
.
len
(
)
=
=
1
{
let
id
=
path
.
segments
[
0
]
.
ident
;
if
self
.
all_ty_params
.
contains
(
&
id
)
{
self
.
relevant_ty_params
.
insert
(
id
)
;
}
}
visit
:
:
visit_path
(
self
path
)
;
}
fn
visit_macro
(
&
mut
self
_mac
:
&
syn
:
:
Macro
)
{
}
}
let
all_ty_params
:
HashSet
<
_
>
=
generics
.
params
.
iter
(
)
.
filter_map
(
|
param
|
match
*
param
{
syn
:
:
GenericParam
:
:
Type
(
ref
param
)
=
>
Some
(
param
.
ident
)
_
=
>
None
}
)
.
collect
(
)
;
let
mut
visitor
=
FindTyParams
{
all_ty_params
:
all_ty_params
relevant_ty_params
:
HashSet
:
:
new
(
)
}
;
match
cont
.
data
{
Data
:
:
Enum
(
_
ref
variants
)
=
>
for
variant
in
variants
.
iter
(
)
{
let
relevant_fields
=
variant
.
fields
.
iter
(
)
.
filter
(
|
field
|
filter
(
&
field
.
attrs
Some
(
&
variant
.
attrs
)
)
)
;
for
field
in
relevant_fields
{
visit
:
:
visit_type
(
&
mut
visitor
field
.
ty
)
;
}
}
Data
:
:
Struct
(
_
ref
fields
)
=
>
{
for
field
in
fields
.
iter
(
)
.
filter
(
|
field
|
filter
(
&
field
.
attrs
None
)
)
{
visit
:
:
visit_type
(
&
mut
visitor
field
.
ty
)
;
}
}
}
let
new_predicates
=
generics
.
params
.
iter
(
)
.
filter_map
(
|
param
|
match
*
param
{
syn
:
:
GenericParam
:
:
Type
(
ref
param
)
=
>
Some
(
param
.
ident
)
_
=
>
None
}
)
.
filter
(
|
id
|
visitor
.
relevant_ty_params
.
contains
(
id
)
)
.
map
(
|
id
|
{
syn
:
:
WherePredicate
:
:
Type
(
syn
:
:
PredicateType
{
lifetimes
:
None
bounded_ty
:
syn
:
:
Type
:
:
Path
(
syn
:
:
TypePath
{
qself
:
None
path
:
id
.
into
(
)
}
)
colon_token
:
Default
:
:
default
(
)
bounds
:
vec
!
[
syn
:
:
TypeParamBound
:
:
Trait
(
syn
:
:
TraitBound
{
modifier
:
syn
:
:
TraitBoundModifier
:
:
None
lifetimes
:
None
path
:
bound
.
clone
(
)
}
)
]
.
into_iter
(
)
.
collect
(
)
}
)
}
)
;
let
mut
generics
=
generics
.
clone
(
)
;
if
generics
.
where_clause
.
is_none
(
)
{
generics
.
where_clause
=
Some
(
syn
:
:
WhereClause
{
where_token
:
Default
:
:
default
(
)
predicates
:
Punctuated
:
:
new
(
)
}
)
;
}
generics
.
where_clause
.
as_mut
(
)
.
unwrap
(
)
.
predicates
.
extend
(
new_predicates
)
;
generics
}
pub
fn
with_self_bound
(
cont
:
&
Container
generics
:
&
syn
:
:
Generics
bound
:
&
syn
:
:
Path
)
-
>
syn
:
:
Generics
{
let
mut
generics
=
generics
.
clone
(
)
;
if
generics
.
where_clause
.
is_none
(
)
{
generics
.
where_clause
=
Some
(
syn
:
:
WhereClause
{
where_token
:
Default
:
:
default
(
)
predicates
:
Punctuated
:
:
new
(
)
}
)
;
}
generics
.
where_clause
.
as_mut
(
)
.
unwrap
(
)
.
predicates
.
push
(
syn
:
:
WherePredicate
:
:
Type
(
syn
:
:
PredicateType
{
lifetimes
:
None
bounded_ty
:
type_of_item
(
cont
)
colon_token
:
Default
:
:
default
(
)
bounds
:
vec
!
[
syn
:
:
TypeParamBound
:
:
Trait
(
syn
:
:
TraitBound
{
modifier
:
syn
:
:
TraitBoundModifier
:
:
None
lifetimes
:
None
path
:
bound
.
clone
(
)
}
)
]
.
into_iter
(
)
.
collect
(
)
}
)
)
;
generics
}
pub
fn
with_lifetime_bound
(
generics
:
&
syn
:
:
Generics
lifetime
:
&
str
)
-
>
syn
:
:
Generics
{
let
bound
=
syn
:
:
Lifetime
:
:
new
(
Term
:
:
intern
(
lifetime
)
Span
:
:
def_site
(
)
)
;
let
def
=
syn
:
:
LifetimeDef
{
attrs
:
Vec
:
:
new
(
)
lifetime
:
bound
colon_token
:
None
bounds
:
Punctuated
:
:
new
(
)
}
;
let
params
=
Some
(
syn
:
:
GenericParam
:
:
Lifetime
(
def
)
)
.
into_iter
(
)
.
chain
(
generics
.
params
.
iter
(
)
.
cloned
(
)
.
map
(
|
mut
param
|
{
match
param
{
syn
:
:
GenericParam
:
:
Lifetime
(
ref
mut
param
)
=
>
{
param
.
bounds
.
push
(
bound
)
;
}
syn
:
:
GenericParam
:
:
Type
(
ref
mut
param
)
=
>
{
param
.
bounds
.
push
(
syn
:
:
TypeParamBound
:
:
Lifetime
(
bound
)
)
;
}
syn
:
:
GenericParam
:
:
Const
(
_
)
=
>
{
}
}
param
}
)
)
.
collect
(
)
;
syn
:
:
Generics
{
params
:
params
.
.
generics
.
clone
(
)
}
}
fn
type_of_item
(
cont
:
&
Container
)
-
>
syn
:
:
Type
{
syn
:
:
Type
:
:
Path
(
syn
:
:
TypePath
{
qself
:
None
path
:
syn
:
:
Path
{
leading_colon
:
None
segments
:
vec
!
[
syn
:
:
PathSegment
{
ident
:
cont
.
ident
arguments
:
syn
:
:
PathArguments
:
:
AngleBracketed
(
syn
:
:
AngleBracketedGenericArguments
{
colon2_token
:
None
lt_token
:
Default
:
:
default
(
)
args
:
cont
.
generics
.
params
.
iter
(
)
.
map
(
|
param
|
match
*
param
{
syn
:
:
GenericParam
:
:
Type
(
ref
param
)
=
>
{
syn
:
:
GenericArgument
:
:
Type
(
syn
:
:
Type
:
:
Path
(
syn
:
:
TypePath
{
qself
:
None
path
:
param
.
ident
.
into
(
)
}
)
)
}
syn
:
:
GenericParam
:
:
Lifetime
(
ref
param
)
=
>
{
syn
:
:
GenericArgument
:
:
Lifetime
(
param
.
lifetime
)
}
syn
:
:
GenericParam
:
:
Const
(
_
)
=
>
{
panic
!
(
"
Serde
does
not
support
const
generics
yet
"
)
;
}
}
)
.
collect
(
)
gt_token
:
Default
:
:
default
(
)
}
)
}
]
.
into_iter
(
)
.
collect
(
)
}
}
)
}
