use
crate
:
:
tree_kem
:
:
node
:
:
NodeVec
;
use
super
:
:
*
;
pub
use
mls_rs_core
:
:
group
:
:
Member
;
pub
(
crate
)
fn
member_from_leaf_node
(
leaf_node
:
&
LeafNode
leaf_index
:
LeafIndex
)
-
>
Member
{
Member
:
:
new
(
*
leaf_index
leaf_node
.
signing_identity
.
clone
(
)
leaf_node
.
ungreased_capabilities
(
)
leaf_node
.
ungreased_extensions
(
)
)
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
Roster
<
'
a
>
{
pub
(
crate
)
public_tree
:
&
'
a
NodeVec
}
impl
<
'
a
>
Roster
<
'
a
>
{
pub
fn
members_iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
Member
>
+
'
a
{
self
.
public_tree
.
non_empty_leaves
(
)
.
map
(
|
(
index
node
)
|
member_from_leaf_node
(
node
index
)
)
}
pub
fn
members
(
&
self
)
-
>
Vec
<
Member
>
{
self
.
members_iter
(
)
.
collect
(
)
}
pub
fn
member_with_index
(
&
self
index
:
u32
)
-
>
Result
<
Member
MlsError
>
{
let
index
=
LeafIndex
(
index
)
;
self
.
public_tree
.
borrow_as_leaf
(
index
)
.
map
(
|
l
|
member_from_leaf_node
(
l
index
)
)
}
pub
fn
member_identities_iter
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
SigningIdentity
>
+
'
_
{
self
.
public_tree
.
non_empty_leaves
(
)
.
map
(
|
(
_
node
)
|
&
node
.
signing_identity
)
}
}
impl
TreeKemPublic
{
pub
(
crate
)
fn
roster
(
&
self
)
-
>
Roster
{
Roster
{
public_tree
:
&
self
.
nodes
}
}
}
